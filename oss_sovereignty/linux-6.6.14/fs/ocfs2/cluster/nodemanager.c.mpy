{
  "module_name": "nodemanager.c",
  "hash_id": "c54f25dbbcae2afaafcb4fd50d76e593b7165470798bb4ba821cdcf23787887c",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/cluster/nodemanager.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/configfs.h>\n\n#include \"tcp.h\"\n#include \"nodemanager.h\"\n#include \"heartbeat.h\"\n#include \"masklog.h\"\n#include \"sys.h\"\n\n \nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nstatic const char *o2nm_fence_method_desc[O2NM_FENCE_METHODS] = {\n\t\"reset\",\t \n\t\"panic\",\t \n};\n\nstatic inline void o2nm_lock_subsystem(void);\nstatic inline void o2nm_unlock_subsystem(void);\n\nstruct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}\nEXPORT_SYMBOL_GPL(o2nm_get_node_by_num);\n\nint o2nm_configured_node_map(unsigned long *map, unsigned bytes)\n{\n\tstruct o2nm_cluster *cluster = o2nm_single_cluster;\n\n\tBUG_ON(bytes < (sizeof(cluster->cl_nodes_bitmap)));\n\n\tif (cluster == NULL)\n\t\treturn -EINVAL;\n\n\tread_lock(&cluster->cl_nodes_lock);\n\tbitmap_copy(map, cluster->cl_nodes_bitmap, O2NM_MAX_NODES);\n\tread_unlock(&cluster->cl_nodes_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(o2nm_configured_node_map);\n\nstatic struct o2nm_node *o2nm_node_ip_tree_lookup(struct o2nm_cluster *cluster,\n\t\t\t\t\t\t  __be32 ip_needle,\n\t\t\t\t\t\t  struct rb_node ***ret_p,\n\t\t\t\t\t\t  struct rb_node **ret_parent)\n{\n\tstruct rb_node **p = &cluster->cl_node_ip_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct o2nm_node *node, *ret = NULL;\n\n\twhile (*p) {\n\t\tint cmp;\n\n\t\tparent = *p;\n\t\tnode = rb_entry(parent, struct o2nm_node, nd_ip_node);\n\n\t\tcmp = memcmp(&ip_needle, &node->nd_ipv4_address,\n\t\t\t\tsizeof(ip_needle));\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tret = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret_p != NULL)\n\t\t*ret_p = p;\n\tif (ret_parent != NULL)\n\t\t*ret_parent = parent;\n\n\treturn ret;\n}\n\nstruct o2nm_node *o2nm_get_node_by_ip(__be32 addr)\n{\n\tstruct o2nm_node *node = NULL;\n\tstruct o2nm_cluster *cluster = o2nm_single_cluster;\n\n\tif (cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&cluster->cl_nodes_lock);\n\tnode = o2nm_node_ip_tree_lookup(cluster, addr, NULL, NULL);\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&cluster->cl_nodes_lock);\n\nout:\n\treturn node;\n}\nEXPORT_SYMBOL_GPL(o2nm_get_node_by_ip);\n\nvoid o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}\nEXPORT_SYMBOL_GPL(o2nm_node_put);\n\nvoid o2nm_node_get(struct o2nm_node *node)\n{\n\tconfig_item_get(&node->nd_item);\n}\nEXPORT_SYMBOL_GPL(o2nm_node_get);\n\nu8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}\nEXPORT_SYMBOL_GPL(o2nm_this_node);\n\n \n\nstatic struct o2nm_cluster *to_o2nm_cluster(struct config_item *item)\n{\n\treturn item ?\n\t\tcontainer_of(to_config_group(item), struct o2nm_cluster,\n\t\t\t     cl_group)\n\t\t: NULL;\n}\n\nstatic struct o2nm_node *to_o2nm_node(struct config_item *item)\n{\n\treturn item ? container_of(item, struct o2nm_node, nd_item) : NULL;\n}\n\nstatic void o2nm_node_release(struct config_item *item)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tkfree(node);\n}\n\nstatic ssize_t o2nm_node_num_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%d\\n\", to_o2nm_node(item)->nd_num);\n}\n\nstatic struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\t \n\tif (node->nd_item.ci_parent)\n\t\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n\telse\n\t\treturn NULL;\n}\n\nenum {\n\tO2NM_NODE_ATTR_NUM = 0,\n\tO2NM_NODE_ATTR_PORT,\n\tO2NM_NODE_ATTR_ADDRESS,\n};\n\nstatic ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n\t\t\t\t   size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster;\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tint ret = 0;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp >= O2NM_MAX_NODES)\n\t\treturn -ERANGE;\n\n\t \n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL;  \n\n\to2nm_lock_subsystem();\n\tcluster = to_o2nm_cluster_from_node(node);\n\tif (!cluster) {\n\t\to2nm_unlock_subsystem();\n\t\treturn -EINVAL;\n\t}\n\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (cluster->cl_nodes[tmp])\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_NUM,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse  {\n\t\tcluster->cl_nodes[tmp] = node;\n\t\tnode->nd_num = tmp;\n\t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\to2nm_unlock_subsystem();\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic ssize_t o2nm_node_ipv4_port_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%u\\n\", ntohs(to_o2nm_node(item)->nd_ipv4_port));\n}\n\nstatic ssize_t o2nm_node_ipv4_port_store(struct config_item *item,\n\t\t\t\t\t const char *page, size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp == 0)\n\t\treturn -EINVAL;\n\tif (tmp >= (u16)-1)\n\t\treturn -ERANGE;\n\n\tif (test_and_set_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EBUSY;\n\tnode->nd_ipv4_port = htons(tmp);\n\n\treturn count;\n}\n\nstatic ssize_t o2nm_node_ipv4_address_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%pI4\\n\", &to_o2nm_node(item)->nd_ipv4_address);\n}\n\nstatic ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n\t\t\t\t\t    const char *page,\n\t\t\t\t\t    size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster;\n\tint ret, i;\n\tstruct rb_node **p, *parent;\n\tunsigned int octets[4];\n\t__be32 ipv4_addr = 0;\n\n\tret = sscanf(page, \"%3u.%3u.%3u.%3u\", &octets[3], &octets[2],\n\t\t     &octets[1], &octets[0]);\n\tif (ret != 4)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(octets); i++) {\n\t\tif (octets[i] > 255)\n\t\t\treturn -ERANGE;\n\t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n\t}\n\n\to2nm_lock_subsystem();\n\tcluster = to_o2nm_cluster_from_node(node);\n\tif (!cluster) {\n\t\to2nm_unlock_subsystem();\n\t\treturn -EINVAL;\n\t}\n\n\tret = 0;\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse {\n\t\trb_link_node(&node->nd_ip_node, parent, p);\n\t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\to2nm_unlock_subsystem();\n\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));\n\n\treturn count;\n}\n\nstatic ssize_t o2nm_node_local_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%d\\n\", to_o2nm_node(item)->nd_local);\n}\n\nstatic ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n\t\t\t\t     size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster;\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tssize_t ret;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\ttmp = !!tmp;  \n\n\t \n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL;  \n\n\to2nm_lock_subsystem();\n\tcluster = to_o2nm_cluster_from_node(node);\n\tif (!cluster) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (tmp && tmp == cluster->cl_has_local &&\n\t    cluster->cl_local_node != node->nd_num) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (tmp && !cluster->cl_has_local) {\n\t\tret = o2net_start_listening(node);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (!tmp && cluster->cl_has_local &&\n\t    cluster->cl_local_node == node->nd_num) {\n\t\to2net_stop_listening(node);\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t}\n\n\tnode->nd_local = tmp;\n\tif (node->nd_local) {\n\t\tcluster->cl_has_local = tmp;\n\t\tcluster->cl_local_node = node->nd_num;\n\t}\n\n\tret = count;\n\nout:\n\to2nm_unlock_subsystem();\n\treturn ret;\n}\n\nCONFIGFS_ATTR(o2nm_node_, num);\nCONFIGFS_ATTR(o2nm_node_, ipv4_port);\nCONFIGFS_ATTR(o2nm_node_, ipv4_address);\nCONFIGFS_ATTR(o2nm_node_, local);\n\nstatic struct configfs_attribute *o2nm_node_attrs[] = {\n\t&o2nm_node_attr_num,\n\t&o2nm_node_attr_ipv4_port,\n\t&o2nm_node_attr_ipv4_address,\n\t&o2nm_node_attr_local,\n\tNULL,\n};\n\nstatic struct configfs_item_operations o2nm_node_item_ops = {\n\t.release\t\t= o2nm_node_release,\n};\n\nstatic const struct config_item_type o2nm_node_type = {\n\t.ct_item_ops\t= &o2nm_node_item_ops,\n\t.ct_attrs\t= o2nm_node_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n \n\nstruct o2nm_node_group {\n\tstruct config_group ns_group;\n\t \n};\n\n#if 0\nstatic struct o2nm_node_group *to_o2nm_node_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(group, struct o2nm_node_group, ns_group)\n\t\t: NULL;\n}\n#endif\n\nstatic ssize_t o2nm_cluster_attr_write(const char *page, ssize_t count,\n                                       unsigned int *val)\n{\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp == 0)\n\t\treturn -EINVAL;\n\tif (tmp >= (u32)-1)\n\t\treturn -ERANGE;\n\n\t*val = tmp;\n\n\treturn count;\n}\n\nstatic ssize_t o2nm_cluster_idle_timeout_ms_show(struct config_item *item,\n\tchar *page)\n{\n\treturn sprintf(page, \"%u\\n\", to_o2nm_cluster(item)->cl_idle_timeout_ms);\n}\n\nstatic ssize_t o2nm_cluster_idle_timeout_ms_store(struct config_item *item,\n\tconst char *page, size_t count)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\tssize_t ret;\n\tunsigned int val;\n\n\tret =  o2nm_cluster_attr_write(page, count, &val);\n\n\tif (ret > 0) {\n\t\tif (cluster->cl_idle_timeout_ms != val\n\t\t\t&& o2net_num_connected_peers()) {\n\t\t\tmlog(ML_NOTICE,\n\t\t\t     \"o2net: cannot change idle timeout after \"\n\t\t\t     \"the first peer has agreed to it.\"\n\t\t\t     \"  %d connected peers\\n\",\n\t\t\t     o2net_num_connected_peers());\n\t\t\tret = -EINVAL;\n\t\t} else if (val <= cluster->cl_keepalive_delay_ms) {\n\t\t\tmlog(ML_NOTICE, \"o2net: idle timeout must be larger \"\n\t\t\t     \"than keepalive delay\\n\");\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tcluster->cl_idle_timeout_ms = val;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t o2nm_cluster_keepalive_delay_ms_show(\n\tstruct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%u\\n\",\n\t\t\tto_o2nm_cluster(item)->cl_keepalive_delay_ms);\n}\n\nstatic ssize_t o2nm_cluster_keepalive_delay_ms_store(\n\tstruct config_item *item, const char *page, size_t count)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\tssize_t ret;\n\tunsigned int val;\n\n\tret =  o2nm_cluster_attr_write(page, count, &val);\n\n\tif (ret > 0) {\n\t\tif (cluster->cl_keepalive_delay_ms != val\n\t\t    && o2net_num_connected_peers()) {\n\t\t\tmlog(ML_NOTICE,\n\t\t\t     \"o2net: cannot change keepalive delay after\"\n\t\t\t     \" the first peer has agreed to it.\"\n\t\t\t     \"  %d connected peers\\n\",\n\t\t\t     o2net_num_connected_peers());\n\t\t\tret = -EINVAL;\n\t\t} else if (val >= cluster->cl_idle_timeout_ms) {\n\t\t\tmlog(ML_NOTICE, \"o2net: keepalive delay must be \"\n\t\t\t     \"smaller than idle timeout\\n\");\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tcluster->cl_keepalive_delay_ms = val;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t o2nm_cluster_reconnect_delay_ms_show(\n\tstruct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%u\\n\",\n\t\t\tto_o2nm_cluster(item)->cl_reconnect_delay_ms);\n}\n\nstatic ssize_t o2nm_cluster_reconnect_delay_ms_store(\n\tstruct config_item *item, const char *page, size_t count)\n{\n\treturn o2nm_cluster_attr_write(page, count,\n                               &to_o2nm_cluster(item)->cl_reconnect_delay_ms);\n}\n\nstatic ssize_t o2nm_cluster_fence_method_show(\n\tstruct config_item *item, char *page)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\tssize_t ret = 0;\n\n\tif (cluster)\n\t\tret = sprintf(page, \"%s\\n\",\n\t\t\t      o2nm_fence_method_desc[cluster->cl_fence_method]);\n\treturn ret;\n}\n\nstatic ssize_t o2nm_cluster_fence_method_store(\n\tstruct config_item *item, const char *page, size_t count)\n{\n\tunsigned int i;\n\n\tif (page[count - 1] != '\\n')\n\t\tgoto bail;\n\n\tfor (i = 0; i < O2NM_FENCE_METHODS; ++i) {\n\t\tif (count != strlen(o2nm_fence_method_desc[i]) + 1)\n\t\t\tcontinue;\n\t\tif (strncasecmp(page, o2nm_fence_method_desc[i], count - 1))\n\t\t\tcontinue;\n\t\tif (to_o2nm_cluster(item)->cl_fence_method != i) {\n\t\t\tprintk(KERN_INFO \"ocfs2: Changing fence method to %s\\n\",\n\t\t\t       o2nm_fence_method_desc[i]);\n\t\t\tto_o2nm_cluster(item)->cl_fence_method = i;\n\t\t}\n\t\treturn count;\n\t}\n\nbail:\n\treturn -EINVAL;\n}\n\nCONFIGFS_ATTR(o2nm_cluster_, idle_timeout_ms);\nCONFIGFS_ATTR(o2nm_cluster_, keepalive_delay_ms);\nCONFIGFS_ATTR(o2nm_cluster_, reconnect_delay_ms);\nCONFIGFS_ATTR(o2nm_cluster_, fence_method);\n\nstatic struct configfs_attribute *o2nm_cluster_attrs[] = {\n\t&o2nm_cluster_attr_idle_timeout_ms,\n\t&o2nm_cluster_attr_keepalive_delay_ms,\n\t&o2nm_cluster_attr_reconnect_delay_ms,\n\t&o2nm_cluster_attr_fence_method,\n\tNULL,\n};\n\nstatic struct config_item *o2nm_node_group_make_item(struct config_group *group,\n\t\t\t\t\t\t     const char *name)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (strlen(name) > O2NM_MAX_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tnode = kzalloc(sizeof(struct o2nm_node), GFP_KERNEL);\n\tif (node == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrcpy(node->nd_name, name);  \n\tconfig_item_init_type_name(&node->nd_item, name, &o2nm_node_type);\n\tspin_lock_init(&node->nd_lock);\n\n\tmlog(ML_CLUSTER, \"o2nm: Registering node %s\\n\", name);\n\n\treturn &node->nd_item;\n}\n\nstatic void o2nm_node_group_drop_item(struct config_group *group,\n\t\t\t\t      struct config_item *item)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(group->cg_item.ci_parent);\n\n\tif (cluster->cl_nodes[node->nd_num] == node) {\n\t\to2net_disconnect_node(node);\n\n\t\tif (cluster->cl_has_local &&\n\t\t    (cluster->cl_local_node == node->nd_num)) {\n\t\t\tcluster->cl_has_local = 0;\n\t\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t\t\to2net_stop_listening(node);\n\t\t}\n\t}\n\n\t \n\n\twrite_lock(&cluster->cl_nodes_lock);\n\n\t \n\tif (node->nd_ipv4_address)\n\t\trb_erase(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n\n\t \n\tif (cluster->cl_nodes[node->nd_num] == node) {\n\t\tcluster->cl_nodes[node->nd_num] = NULL;\n\t\tclear_bit(node->nd_num, cluster->cl_nodes_bitmap);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\n\tmlog(ML_CLUSTER, \"o2nm: Unregistered node %s\\n\",\n\t     config_item_name(&node->nd_item));\n\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations o2nm_node_group_group_ops = {\n\t.make_item\t= o2nm_node_group_make_item,\n\t.drop_item\t= o2nm_node_group_drop_item,\n};\n\nstatic const struct config_item_type o2nm_node_group_type = {\n\t.ct_group_ops\t= &o2nm_node_group_group_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n \n\nstatic void o2nm_cluster_release(struct config_item *item)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\n\tkfree(cluster);\n}\n\nstatic struct configfs_item_operations o2nm_cluster_item_ops = {\n\t.release\t= o2nm_cluster_release,\n};\n\nstatic const struct config_item_type o2nm_cluster_type = {\n\t.ct_item_ops\t= &o2nm_cluster_item_ops,\n\t.ct_attrs\t= o2nm_cluster_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n \n\nstruct o2nm_cluster_group {\n\tstruct configfs_subsystem cs_subsys;\n\t \n};\n\n#if 0\nstatic struct o2nm_cluster_group *to_o2nm_cluster_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(to_configfs_subsystem(group), struct o2nm_cluster_group, cs_subsys)\n\t       : NULL;\n}\n#endif\n\nstatic struct config_group *o2nm_cluster_group_make_group(struct config_group *group,\n\t\t\t\t\t\t\t  const char *name)\n{\n\tstruct o2nm_cluster *cluster = NULL;\n\tstruct o2nm_node_group *ns = NULL;\n\tstruct config_group *o2hb_group = NULL, *ret = NULL;\n\n\t \n\tif (o2nm_single_cluster)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tcluster = kzalloc(sizeof(struct o2nm_cluster), GFP_KERNEL);\n\tns = kzalloc(sizeof(struct o2nm_node_group), GFP_KERNEL);\n\to2hb_group = o2hb_alloc_hb_set();\n\tif (cluster == NULL || ns == NULL || o2hb_group == NULL)\n\t\tgoto out;\n\n\tconfig_group_init_type_name(&cluster->cl_group, name,\n\t\t\t\t    &o2nm_cluster_type);\n\tconfigfs_add_default_group(&ns->ns_group, &cluster->cl_group);\n\n\tconfig_group_init_type_name(&ns->ns_group, \"node\",\n\t\t\t\t    &o2nm_node_group_type);\n\tconfigfs_add_default_group(o2hb_group, &cluster->cl_group);\n\n\trwlock_init(&cluster->cl_nodes_lock);\n\tcluster->cl_node_ip_tree = RB_ROOT;\n\tcluster->cl_reconnect_delay_ms = O2NET_RECONNECT_DELAY_MS_DEFAULT;\n\tcluster->cl_idle_timeout_ms    = O2NET_IDLE_TIMEOUT_MS_DEFAULT;\n\tcluster->cl_keepalive_delay_ms = O2NET_KEEPALIVE_DELAY_MS_DEFAULT;\n\tcluster->cl_fence_method       = O2NM_FENCE_RESET;\n\n\tret = &cluster->cl_group;\n\to2nm_single_cluster = cluster;\n\nout:\n\tif (ret == NULL) {\n\t\tkfree(cluster);\n\t\tkfree(ns);\n\t\to2hb_free_hb_set(o2hb_group);\n\t\tret = ERR_PTR(-ENOMEM);\n\t}\n\n\treturn ret;\n}\n\nstatic void o2nm_cluster_group_drop_item(struct config_group *group, struct config_item *item)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\n\tBUG_ON(o2nm_single_cluster != cluster);\n\to2nm_single_cluster = NULL;\n\n\tconfigfs_remove_default_groups(&cluster->cl_group);\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations o2nm_cluster_group_group_ops = {\n\t.make_group\t= o2nm_cluster_group_make_group,\n\t.drop_item\t= o2nm_cluster_group_drop_item,\n};\n\nstatic const struct config_item_type o2nm_cluster_group_type = {\n\t.ct_group_ops\t= &o2nm_cluster_group_group_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nstatic inline void o2nm_lock_subsystem(void)\n{\n\tmutex_lock(&o2nm_cluster_group.cs_subsys.su_mutex);\n}\n\nstatic inline void o2nm_unlock_subsystem(void)\n{\n\tmutex_unlock(&o2nm_cluster_group.cs_subsys.su_mutex);\n}\n\nint o2nm_depend_item(struct config_item *item)\n{\n\treturn configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);\n}\n\nvoid o2nm_undepend_item(struct config_item *item)\n{\n\tconfigfs_undepend_item(item);\n}\n\nint o2nm_depend_this_node(void)\n{\n\tint ret = 0;\n\tstruct o2nm_node *local_node;\n\n\tlocal_node = o2nm_get_node_by_num(o2nm_this_node());\n\tif (!local_node) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = o2nm_depend_item(&local_node->nd_item);\n\to2nm_node_put(local_node);\n\nout:\n\treturn ret;\n}\n\nvoid o2nm_undepend_this_node(void)\n{\n\tstruct o2nm_node *local_node;\n\n\tlocal_node = o2nm_get_node_by_num(o2nm_this_node());\n\tBUG_ON(!local_node);\n\n\to2nm_undepend_item(&local_node->nd_item);\n\to2nm_node_put(local_node);\n}\n\n\nstatic void __exit exit_o2nm(void)\n{\n\t \n\to2net_unregister_hb_callbacks();\n\tconfigfs_unregister_subsystem(&o2nm_cluster_group.cs_subsys);\n\to2cb_sys_shutdown();\n\n\to2net_exit();\n\to2hb_exit();\n}\n\nstatic int __init init_o2nm(void)\n{\n\tint ret;\n\n\to2hb_init();\n\n\tret = o2net_init();\n\tif (ret)\n\t\tgoto out_o2hb;\n\n\tret = o2net_register_hb_callbacks();\n\tif (ret)\n\t\tgoto out_o2net;\n\n\tconfig_group_init(&o2nm_cluster_group.cs_subsys.su_group);\n\tmutex_init(&o2nm_cluster_group.cs_subsys.su_mutex);\n\tret = configfs_register_subsystem(&o2nm_cluster_group.cs_subsys);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"nodemanager: Registration returned %d\\n\", ret);\n\t\tgoto out_callbacks;\n\t}\n\n\tret = o2cb_sys_init();\n\tif (!ret)\n\t\tgoto out;\n\n\tconfigfs_unregister_subsystem(&o2nm_cluster_group.cs_subsys);\nout_callbacks:\n\to2net_unregister_hb_callbacks();\nout_o2net:\n\to2net_exit();\nout_o2hb:\n\to2hb_exit();\nout:\n\treturn ret;\n}\n\nMODULE_AUTHOR(\"Oracle\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"OCFS2 cluster management\");\n\nmodule_init(init_o2nm)\nmodule_exit(exit_o2nm)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}