{
  "module_name": "masklog.h",
  "hash_id": "bb23ed43188b512c62ef3a4fcd77db455ca75413973291bb6994eb1ed15a9778",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/cluster/masklog.h",
  "human_readable_source": " \n \n\n#ifndef O2CLUSTER_MASKLOG_H\n#define O2CLUSTER_MASKLOG_H\n\n \n\n \n#include <linux/sched.h>\n\n \n \n#define ML_TCP\t\t0x0000000000000001ULL  \n#define ML_MSG\t\t0x0000000000000002ULL  \n#define ML_SOCKET\t0x0000000000000004ULL  \n#define ML_HEARTBEAT\t0x0000000000000008ULL  \n#define ML_HB_BIO\t0x0000000000000010ULL  \n#define ML_DLMFS\t0x0000000000000020ULL  \n#define ML_DLM\t\t0x0000000000000040ULL  \n#define ML_DLM_DOMAIN\t0x0000000000000080ULL  \n#define ML_DLM_THREAD\t0x0000000000000100ULL  \n#define ML_DLM_MASTER\t0x0000000000000200ULL  \n#define ML_DLM_RECOVERY\t0x0000000000000400ULL  \n#define ML_DLM_GLUE\t0x0000000000000800ULL  \n#define ML_VOTE\t\t0x0000000000001000ULL  \n#define ML_CONN\t\t0x0000000000002000ULL  \n#define ML_QUORUM\t0x0000000000004000ULL  \n#define ML_BASTS\t0x0000000000008000ULL  \n#define ML_CLUSTER\t0x0000000000010000ULL  \n\n \n#define ML_ERROR\t0x1000000000000000ULL  \n#define ML_NOTICE\t0x2000000000000000ULL  \n#define ML_KTHREAD\t0x4000000000000000ULL  \n\n#define MLOG_INITIAL_AND_MASK (ML_ERROR|ML_NOTICE)\n#ifndef MLOG_MASK_PREFIX\n#define MLOG_MASK_PREFIX 0\n#endif\n\n \n#if defined(CONFIG_OCFS2_DEBUG_MASKLOG)\n#define ML_ALLOWED_BITS ~0\n#else\n#define ML_ALLOWED_BITS (ML_ERROR|ML_NOTICE)\n#endif\n\n#define MLOG_MAX_BITS 64\n\nstruct mlog_bits {\n\tunsigned long words[MLOG_MAX_BITS / BITS_PER_LONG];\n};\n\nextern struct mlog_bits mlog_and_bits, mlog_not_bits;\n\n#if BITS_PER_LONG == 32\n\n#define __mlog_test_u64(mask, bits)\t\t\t\\\n\t( (u32)(mask & 0xffffffff) & bits.words[0] || \t\\\n\t  ((u64)(mask) >> 32) & bits.words[1] )\n#define __mlog_set_u64(mask, bits) do {\t\t\t\\\n\tbits.words[0] |= (u32)(mask & 0xffffffff);\t\\\n       \tbits.words[1] |= (u64)(mask) >> 32;\t\t\\\n} while (0)\n#define __mlog_clear_u64(mask, bits) do {\t\t\\\n\tbits.words[0] &= ~((u32)(mask & 0xffffffff));\t\\\n       \tbits.words[1] &= ~((u64)(mask) >> 32);\t\t\\\n} while (0)\n#define MLOG_BITS_RHS(mask) {\t\t\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t[0] = (u32)(mask & 0xffffffff),\t\t\\\n\t\t[1] = (u64)(mask) >> 32,\t\t\\\n\t}\t\t\t\t\t\t\\\n}\n\n#else  \n\n#define __mlog_test_u64(mask, bits)\t((mask) & bits.words[0])\n#define __mlog_set_u64(mask, bits) do {\t\t\\\n\tbits.words[0] |= (mask);\t\t\\\n} while (0)\n#define __mlog_clear_u64(mask, bits) do {\t\\\n\tbits.words[0] &= ~(mask);\t\t\\\n} while (0)\n#define MLOG_BITS_RHS(mask) { { (mask) } }\n\n#endif\n\n__printf(4, 5)\nvoid __mlog_printk(const u64 *m, const char *func, int line,\n\t\t   const char *fmt, ...);\n\n \n#define mlog(mask, fmt, ...)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tu64 _m = MLOG_MASK_PREFIX | (mask);\t\t\t\t\\\n\tif (_m & ML_ALLOWED_BITS)\t\t\t\t\t\\\n\t\t__mlog_printk(&_m, __func__, __LINE__, fmt,\t\t\\\n\t\t\t      ##__VA_ARGS__);\t\t\t\t\\\n} while (0)\n\n#define mlog_ratelimited(mask, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tstatic DEFINE_RATELIMIT_STATE(_rs,\t\t\t\t\\\n\t\t\t\t      DEFAULT_RATELIMIT_INTERVAL,\t\\\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\t\t\\\n\tif (__ratelimit(&_rs))\t\t\t\t\t\t\\\n\t\tmlog(mask, fmt, ##__VA_ARGS__);\t\t\t\t\\\n} while (0)\n\n#define mlog_errno(st) ({\t\t\t\t\t\t\\\n\tint _st = (st);\t\t\t\t\t\t\t\\\n\tif (_st != -ERESTARTSYS && _st != -EINTR &&\t\t\t\\\n\t    _st != AOP_TRUNCATED_PAGE && _st != -ENOSPC &&\t\t\\\n\t    _st != -EDQUOT)\t\t\t\t\t\t\\\n\t\tmlog(ML_ERROR, \"status = %lld\\n\", (long long)_st);\t\\\n\t_st;\t\t\t\t\t\t\t\t\\\n})\n\n#define mlog_bug_on_msg(cond, fmt, args...) do {\t\t\t\\\n\tif (cond) {\t\t\t\t\t\t\t\\\n\t\tmlog(ML_ERROR, \"bug expression: \" #cond \"\\n\");\t\t\\\n\t\tmlog(ML_ERROR, fmt, ##args);\t\t\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\nint mlog_sys_init(struct kset *o2cb_subsys);\nvoid mlog_sys_shutdown(void);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}