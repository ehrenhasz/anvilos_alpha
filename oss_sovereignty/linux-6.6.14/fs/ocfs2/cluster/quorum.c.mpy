{
  "module_name": "quorum.c",
  "hash_id": "7cc6553f95156bc9eb82478a0b0e9daa8ce968771a436d50de6d802a4f04a46d",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/cluster/quorum.c",
  "human_readable_source": "\n \n\n \n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/reboot.h>\n\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#define MLOG_MASK_PREFIX ML_QUORUM\n#include \"masklog.h\"\n#include \"quorum.h\"\n\nstatic struct o2quo_state {\n\tspinlock_t\t\tqs_lock;\n\tstruct work_struct\tqs_work;\n\tint\t\t\tqs_pending;\n\tint\t\t\tqs_heartbeating;\n\tunsigned long\t\tqs_hb_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_connected;\n\tunsigned long\t\tqs_conn_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_holds;\n\tunsigned long\t\tqs_hold_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n} o2quo_state;\n\n \nstatic void o2quo_fence_self(void)\n{\n\t \n\to2hb_stop_all_regions();\n\n\tswitch (o2nm_single_cluster->cl_fence_method) {\n\tcase O2NM_FENCE_PANIC:\n\t\tpanic(\"*** ocfs2 is very sorry to be fencing this system by \"\n\t\t      \"panicing ***\\n\");\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(o2nm_single_cluster->cl_fence_method >=\n\t\t\tO2NM_FENCE_METHODS);\n\t\tfallthrough;\n\tcase O2NM_FENCE_RESET:\n\t\tprintk(KERN_ERR \"*** ocfs2 is very sorry to be fencing this \"\n\t\t       \"system by restarting ***\\n\");\n\t\temergency_restart();\n\t\tbreak;\n\t}\n}\n\n \nvoid o2quo_disk_timeout(void)\n{\n\to2quo_fence_self();\n}\n\nstatic void o2quo_make_decision(struct work_struct *work)\n{\n\tint quorum;\n\tint lowest_hb, lowest_reachable = 0, fence = 0;\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock_bh(&qs->qs_lock);\n\n\tlowest_hb = find_first_bit(qs->qs_hb_bm, O2NM_MAX_NODES);\n\tif (lowest_hb != O2NM_MAX_NODES)\n\t\tlowest_reachable = test_bit(lowest_hb, qs->qs_conn_bm);\n\n\tmlog(0, \"heartbeating: %d, connected: %d, \"\n\t     \"lowest: %d (%sreachable)\\n\", qs->qs_heartbeating,\n\t     qs->qs_connected, lowest_hb, lowest_reachable ? \"\" : \"un\");\n\n\tif (!test_bit(o2nm_this_node(), qs->qs_hb_bm) ||\n\t    qs->qs_heartbeating == 1)\n\t\tgoto out;\n\n\tif (qs->qs_heartbeating & 1) {\n\t\t \n\t\tquorum = (qs->qs_heartbeating + 1)/2;\n\t\tif (qs->qs_connected < quorum) {\n\t\t\tmlog(ML_ERROR, \"fencing this node because it is \"\n\t\t\t     \"only connected to %u nodes and %u is needed \"\n\t\t\t     \"to make a quorum out of %u heartbeating nodes\\n\",\n\t\t\t     qs->qs_connected, quorum,\n\t\t\t     qs->qs_heartbeating);\n\t\t\tfence = 1;\n\t\t}\n\t} else {\n\t\t \n\t\tquorum = qs->qs_heartbeating / 2;\n\t\tif (qs->qs_connected < quorum) {\n\t\t\tmlog(ML_ERROR, \"fencing this node because it is \"\n\t\t\t     \"only connected to %u nodes and %u is needed \"\n\t\t\t     \"to make a quorum out of %u heartbeating nodes\\n\",\n\t\t\t     qs->qs_connected, quorum,\n\t\t\t     qs->qs_heartbeating);\n\t\t\tfence = 1;\n\t\t}\n\t\telse if ((qs->qs_connected == quorum) &&\n\t\t\t !lowest_reachable) {\n\t\t\tmlog(ML_ERROR, \"fencing this node because it is \"\n\t\t\t     \"connected to a half-quorum of %u out of %u \"\n\t\t\t     \"nodes which doesn't include the lowest active \"\n\t\t\t     \"node %u\\n\", quorum, qs->qs_heartbeating,\n\t\t\t     lowest_hb);\n\t\t\tfence = 1;\n\t\t}\n\t}\n\nout:\n\tif (fence) {\n\t\tspin_unlock_bh(&qs->qs_lock);\n\t\to2quo_fence_self();\n\t} else {\n\t\tmlog(ML_NOTICE, \"not fencing this node, heartbeating: %d, \"\n\t\t\t\"connected: %d, lowest: %d (%sreachable)\\n\",\n\t\t\tqs->qs_heartbeating, qs->qs_connected, lowest_hb,\n\t\t\tlowest_reachable ? \"\" : \"un\");\n\t\tspin_unlock_bh(&qs->qs_lock);\n\n\t}\n\n}\n\nstatic void o2quo_set_hold(struct o2quo_state *qs, u8 node)\n{\n\tassert_spin_locked(&qs->qs_lock);\n\n\tif (!test_and_set_bit(node, qs->qs_hold_bm)) {\n\t\tqs->qs_holds++;\n\t\tmlog_bug_on_msg(qs->qs_holds == O2NM_MAX_NODES,\n\t\t\t        \"node %u\\n\", node);\n\t\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_holds);\n\t}\n}\n\nstatic void o2quo_clear_hold(struct o2quo_state *qs, u8 node)\n{\n\tassert_spin_locked(&qs->qs_lock);\n\n\tif (test_and_clear_bit(node, qs->qs_hold_bm)) {\n\t\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_holds - 1);\n\t\tif (--qs->qs_holds == 0) {\n\t\t\tif (qs->qs_pending) {\n\t\t\t\tqs->qs_pending = 0;\n\t\t\t\tschedule_work(&qs->qs_work);\n\t\t\t}\n\t\t}\n\t\tmlog_bug_on_msg(qs->qs_holds < 0, \"node %u, holds %d\\n\",\n\t\t\t\tnode, qs->qs_holds);\n\t}\n}\n\n \nvoid o2quo_hb_up(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock_bh(&qs->qs_lock);\n\n\tqs->qs_heartbeating++;\n\tmlog_bug_on_msg(qs->qs_heartbeating == O2NM_MAX_NODES,\n\t\t        \"node %u\\n\", node);\n\tmlog_bug_on_msg(test_bit(node, qs->qs_hb_bm), \"node %u\\n\", node);\n\tset_bit(node, qs->qs_hb_bm);\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_heartbeating);\n\n\tif (!test_bit(node, qs->qs_conn_bm))\n\t\to2quo_set_hold(qs, node);\n\telse\n\t\to2quo_clear_hold(qs, node);\n\n\tspin_unlock_bh(&qs->qs_lock);\n}\n\n \nvoid o2quo_hb_down(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock_bh(&qs->qs_lock);\n\n\tqs->qs_heartbeating--;\n\tmlog_bug_on_msg(qs->qs_heartbeating < 0,\n\t\t\t\"node %u, %d heartbeating\\n\",\n\t\t\tnode, qs->qs_heartbeating);\n\tmlog_bug_on_msg(!test_bit(node, qs->qs_hb_bm), \"node %u\\n\", node);\n\tclear_bit(node, qs->qs_hb_bm);\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_heartbeating);\n\n\to2quo_clear_hold(qs, node);\n\n\tspin_unlock_bh(&qs->qs_lock);\n}\n\n \nvoid o2quo_hb_still_up(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock_bh(&qs->qs_lock);\n\n\tmlog(0, \"node %u\\n\", node);\n\n\tqs->qs_pending = 1;\n\to2quo_clear_hold(qs, node);\n\n\tspin_unlock_bh(&qs->qs_lock);\n}\n\n \nvoid o2quo_conn_up(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock_bh(&qs->qs_lock);\n\n\tqs->qs_connected++;\n\tmlog_bug_on_msg(qs->qs_connected == O2NM_MAX_NODES,\n\t\t        \"node %u\\n\", node);\n\tmlog_bug_on_msg(test_bit(node, qs->qs_conn_bm), \"node %u\\n\", node);\n\tset_bit(node, qs->qs_conn_bm);\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_connected);\n\n\tif (!test_bit(node, qs->qs_hb_bm))\n\t\to2quo_set_hold(qs, node);\n\telse\n\t\to2quo_clear_hold(qs, node);\n\n\tspin_unlock_bh(&qs->qs_lock);\n}\n\n \nvoid o2quo_conn_err(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock_bh(&qs->qs_lock);\n\n\tif (test_bit(node, qs->qs_conn_bm)) {\n\t\tqs->qs_connected--;\n\t\tmlog_bug_on_msg(qs->qs_connected < 0,\n\t\t\t\t\"node %u, connected %d\\n\",\n\t\t\t\tnode, qs->qs_connected);\n\n\t\tclear_bit(node, qs->qs_conn_bm);\n\n\t\tif (test_bit(node, qs->qs_hb_bm))\n\t\t\to2quo_set_hold(qs, node);\n\t}\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_connected);\n\n\n\tspin_unlock_bh(&qs->qs_lock);\n}\n\nvoid o2quo_init(void)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock_init(&qs->qs_lock);\n\tINIT_WORK(&qs->qs_work, o2quo_make_decision);\n}\n\nvoid o2quo_exit(void)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tflush_work(&qs->qs_work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}