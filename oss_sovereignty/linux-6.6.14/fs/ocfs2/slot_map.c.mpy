{
  "module_name": "slot_map.c",
  "hash_id": "53ab5049932d47c63a2437385baa7e12d90216d4d0c1b54c109c062730e87e2f",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/slot_map.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"dlmglue.h\"\n#include \"extent_map.h\"\n#include \"heartbeat.h\"\n#include \"inode.h\"\n#include \"slot_map.h\"\n#include \"super.h\"\n#include \"sysfile.h\"\n#include \"ocfs2_trace.h\"\n\n#include \"buffer_head_io.h\"\n\n\nstruct ocfs2_slot {\n\tint sl_valid;\n\tunsigned int sl_node_num;\n};\n\nstruct ocfs2_slot_info {\n\tint si_extended;\n\tint si_slots_per_block;\n\tstruct inode *si_inode;\n\tunsigned int si_blocks;\n\tstruct buffer_head **si_bh;\n\tunsigned int si_num_slots;\n\tstruct ocfs2_slot si_slots[];\n};\n\n\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);\n\nstatic void ocfs2_invalidate_slot(struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\tsi->si_slots[slot_num].sl_valid = 0;\n}\n\nstatic void ocfs2_set_slot(struct ocfs2_slot_info *si,\n\t\t\t   int slot_num, unsigned int node_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\n\tsi->si_slots[slot_num].sl_valid = 1;\n\tsi->si_slots[slot_num].sl_node_num = node_num;\n}\n\n \nstatic void ocfs2_update_slot_info_extended(struct ocfs2_slot_info *si)\n{\n\tint b, i, slotno;\n\tstruct ocfs2_slot_map_extended *se;\n\n\tslotno = 0;\n\tfor (b = 0; b < si->si_blocks; b++) {\n\t\tse = (struct ocfs2_slot_map_extended *)si->si_bh[b]->b_data;\n\t\tfor (i = 0;\n\t\t     (i < si->si_slots_per_block) &&\n\t\t     (slotno < si->si_num_slots);\n\t\t     i++, slotno++) {\n\t\t\tif (se->se_slots[i].es_valid)\n\t\t\t\tocfs2_set_slot(si, slotno,\n\t\t\t\t\t       le32_to_cpu(se->se_slots[i].es_node_num));\n\t\t\telse\n\t\t\t\tocfs2_invalidate_slot(si, slotno);\n\t\t}\n\t}\n}\n\n \nstatic void ocfs2_update_slot_info_old(struct ocfs2_slot_info *si)\n{\n\tint i;\n\tstruct ocfs2_slot_map *sm;\n\n\tsm = (struct ocfs2_slot_map *)si->si_bh[0]->b_data;\n\n\tfor (i = 0; i < si->si_num_slots; i++) {\n\t\tif (le16_to_cpu(sm->sm_slots[i]) == (u16)OCFS2_INVALID_SLOT)\n\t\t\tocfs2_invalidate_slot(si, i);\n\t\telse\n\t\t\tocfs2_set_slot(si, i, le16_to_cpu(sm->sm_slots[i]));\n\t}\n}\n\nstatic void ocfs2_update_slot_info(struct ocfs2_slot_info *si)\n{\n\t \n\tif (si->si_extended)\n\t\tocfs2_update_slot_info_extended(si);\n\telse\n\t\tocfs2_update_slot_info_old(si);\n}\n\nint ocfs2_refresh_slot_info(struct ocfs2_super *osb)\n{\n\tint ret;\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tif (si == NULL)\n\t\treturn 0;\n\n\tBUG_ON(si->si_blocks == 0);\n\tBUG_ON(si->si_bh == NULL);\n\n\ttrace_ocfs2_refresh_slot_info(si->si_blocks);\n\n\t \n\tret = ocfs2_read_blocks(INODE_CACHE(si->si_inode), -1, si->si_blocks,\n\t\t\t\tsi->si_bh, OCFS2_BH_IGNORE_CACHE, NULL);\n\tif (ret == 0) {\n\t\tspin_lock(&osb->osb_lock);\n\t\tocfs2_update_slot_info(si);\n\t\tspin_unlock(&osb->osb_lock);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void ocfs2_update_disk_slot_extended(struct ocfs2_slot_info *si,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct buffer_head **bh)\n{\n\tint blkind = slot_num / si->si_slots_per_block;\n\tint slotno = slot_num % si->si_slots_per_block;\n\tstruct ocfs2_slot_map_extended *se;\n\n\tBUG_ON(blkind >= si->si_blocks);\n\n\tse = (struct ocfs2_slot_map_extended *)si->si_bh[blkind]->b_data;\n\tse->se_slots[slotno].es_valid = si->si_slots[slot_num].sl_valid;\n\tif (si->si_slots[slot_num].sl_valid)\n\t\tse->se_slots[slotno].es_node_num =\n\t\t\tcpu_to_le32(si->si_slots[slot_num].sl_node_num);\n\t*bh = si->si_bh[blkind];\n}\n\nstatic void ocfs2_update_disk_slot_old(struct ocfs2_slot_info *si,\n\t\t\t\t       int slot_num,\n\t\t\t\t       struct buffer_head **bh)\n{\n\tint i;\n\tstruct ocfs2_slot_map *sm;\n\n\tsm = (struct ocfs2_slot_map *)si->si_bh[0]->b_data;\n\tfor (i = 0; i < si->si_num_slots; i++) {\n\t\tif (si->si_slots[i].sl_valid)\n\t\t\tsm->sm_slots[i] =\n\t\t\t\tcpu_to_le16(si->si_slots[i].sl_node_num);\n\t\telse\n\t\t\tsm->sm_slots[i] = cpu_to_le16(OCFS2_INVALID_SLOT);\n\t}\n\t*bh = si->si_bh[0];\n}\n\nstatic int ocfs2_update_disk_slot(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tint status;\n\tstruct buffer_head *bh;\n\n\tspin_lock(&osb->osb_lock);\n\tif (si->si_extended)\n\t\tocfs2_update_disk_slot_extended(si, slot_num, &bh);\n\telse\n\t\tocfs2_update_disk_slot_old(si, slot_num, &bh);\n\tspin_unlock(&osb->osb_lock);\n\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(si->si_inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}\n\n \nstatic int ocfs2_slot_map_physical_size(struct ocfs2_super *osb,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tunsigned long long *bytes)\n{\n\tunsigned long long bytes_needed;\n\n\tif (ocfs2_uses_extended_slot_map(osb)) {\n\t\tbytes_needed = osb->max_slots *\n\t\t\tsizeof(struct ocfs2_extended_slot);\n\t} else {\n\t\tbytes_needed = osb->max_slots * sizeof(__le16);\n\t}\n\tif (bytes_needed > i_size_read(inode)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Slot map file is too small!  (size %llu, needed %llu)\\n\",\n\t\t     i_size_read(inode), bytes_needed);\n\t\treturn -ENOSPC;\n\t}\n\n\t*bytes = bytes_needed;\n\treturn 0;\n}\n\n \nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num)\n{\n\tint i, ret = -ENOENT;\n\n\tfor(i = 0; i < si->si_num_slots; i++) {\n\t\tif (si->si_slots[i].sl_valid &&\n\t\t    (node_num == si->si_slots[i].sl_node_num)) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int __ocfs2_find_empty_slot(struct ocfs2_slot_info *si,\n\t\t\t\t   int preferred)\n{\n\tint i, ret = -ENOSPC;\n\n\tif ((preferred >= 0) && (preferred < si->si_num_slots)) {\n\t\tif (!si->si_slots[preferred].sl_valid) {\n\t\t\tret = preferred;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor(i = 0; i < si->si_num_slots; i++) {\n\t\tif (!si->si_slots[i].sl_valid) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn ret;\n}\n\nint ocfs2_node_num_to_slot(struct ocfs2_super *osb, unsigned int node_num)\n{\n\tint slot;\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tspin_lock(&osb->osb_lock);\n\tslot = __ocfs2_node_num_to_slot(si, node_num);\n\tspin_unlock(&osb->osb_lock);\n\n\treturn slot;\n}\n\nint ocfs2_slot_to_node_num_locked(struct ocfs2_super *osb, int slot_num,\n\t\t\t\t  unsigned int *node_num)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tassert_spin_locked(&osb->osb_lock);\n\n\tBUG_ON(slot_num < 0);\n\tBUG_ON(slot_num >= osb->max_slots);\n\n\tif (!si->si_slots[slot_num].sl_valid)\n\t\treturn -ENOENT;\n\n\t*node_num = si->si_slots[slot_num].sl_node_num;\n\treturn 0;\n}\n\nstatic void __ocfs2_free_slot_info(struct ocfs2_slot_info *si)\n{\n\tunsigned int i;\n\n\tif (si == NULL)\n\t\treturn;\n\n\tiput(si->si_inode);\n\tif (si->si_bh) {\n\t\tfor (i = 0; i < si->si_blocks; i++) {\n\t\t\tif (si->si_bh[i]) {\n\t\t\t\tbrelse(si->si_bh[i]);\n\t\t\t\tsi->si_bh[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tkfree(si->si_bh);\n\t}\n\n\tkfree(si);\n}\n\nint ocfs2_clear_slot(struct ocfs2_super *osb, int slot_num)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tif (si == NULL)\n\t\treturn 0;\n\n\tspin_lock(&osb->osb_lock);\n\tocfs2_invalidate_slot(si, slot_num);\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ocfs2_update_disk_slot(osb, osb->slot_info, slot_num);\n}\n\nstatic int ocfs2_map_slot_buffers(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_slot_info *si)\n{\n\tint status = 0;\n\tu64 blkno;\n\tunsigned long long blocks, bytes = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\tstatus = ocfs2_slot_map_physical_size(osb, si->si_inode, &bytes);\n\tif (status)\n\t\tgoto bail;\n\n\tblocks = ocfs2_blocks_for_bytes(si->si_inode->i_sb, bytes);\n\tBUG_ON(blocks > UINT_MAX);\n\tsi->si_blocks = blocks;\n\tif (!si->si_blocks)\n\t\tgoto bail;\n\n\tif (si->si_extended)\n\t\tsi->si_slots_per_block =\n\t\t\t(osb->sb->s_blocksize /\n\t\t\t sizeof(struct ocfs2_extended_slot));\n\telse\n\t\tsi->si_slots_per_block = osb->sb->s_blocksize / sizeof(__le16);\n\n\t \n\tBUG_ON((osb->max_slots / si->si_slots_per_block) > blocks);\n\n\ttrace_ocfs2_map_slot_buffers(bytes, si->si_blocks);\n\n\tsi->si_bh = kcalloc(si->si_blocks, sizeof(struct buffer_head *),\n\t\t\t    GFP_KERNEL);\n\tif (!si->si_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tfor (i = 0; i < si->si_blocks; i++) {\n\t\tstatus = ocfs2_extent_map_get_blocks(si->si_inode, i,\n\t\t\t\t\t\t     &blkno, NULL, NULL);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttrace_ocfs2_map_slot_buffers_block((unsigned long long)blkno, i);\n\n\t\tbh = NULL;   \n\t\tstatus = ocfs2_read_blocks(INODE_CACHE(si->si_inode), blkno,\n\t\t\t\t\t   1, &bh, OCFS2_BH_IGNORE_CACHE, NULL);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tsi->si_bh[i] = bh;\n\t}\n\nbail:\n\treturn status;\n}\n\nint ocfs2_init_slot_info(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_slot_info *si;\n\n\tsi = kzalloc(struct_size(si, si_slots, osb->max_slots), GFP_KERNEL);\n\tif (!si) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tsi->si_extended = ocfs2_uses_extended_slot_map(osb);\n\tsi->si_num_slots = osb->max_slots;\n\n\tinode = ocfs2_get_system_file_inode(osb, SLOT_MAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tsi->si_inode = inode;\n\tstatus = ocfs2_map_slot_buffers(osb, si);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->slot_info = (struct ocfs2_slot_info *)si;\nbail:\n\tif (status < 0)\n\t\t__ocfs2_free_slot_info(si);\n\n\treturn status;\n}\n\nvoid ocfs2_free_slot_info(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tosb->slot_info = NULL;\n\t__ocfs2_free_slot_info(si);\n}\n\nint ocfs2_find_slot(struct ocfs2_super *osb)\n{\n\tint status;\n\tint slot;\n\tstruct ocfs2_slot_info *si;\n\n\tsi = osb->slot_info;\n\n\tspin_lock(&osb->osb_lock);\n\tocfs2_update_slot_info(si);\n\n\t \n\tslot = __ocfs2_node_num_to_slot(si, osb->node_num);\n\tif (slot < 0) {\n\t\t \n\t\tslot = __ocfs2_find_empty_slot(si, osb->preferred_slot);\n\t\tif (slot < 0) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tmlog(ML_ERROR, \"no free slots available!\\n\");\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\t} else\n\t\tprintk(KERN_INFO \"ocfs2: Slot %d on device (%s) was already \"\n\t\t       \"allocated to this node!\\n\", slot, osb->dev_str);\n\n\tocfs2_set_slot(si, slot, osb->node_num);\n\tosb->slot_num = slot;\n\tspin_unlock(&osb->osb_lock);\n\n\ttrace_ocfs2_find_slot(osb->slot_num);\n\n\tstatus = ocfs2_update_disk_slot(osb, si, osb->slot_num);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\t \n\t\tspin_lock(&osb->osb_lock);\n\t\tocfs2_invalidate_slot(si, osb->slot_num);\n\t\tosb->slot_num = OCFS2_INVALID_SLOT;\n\t\tspin_unlock(&osb->osb_lock);\n\t}\n\nbail:\n\treturn status;\n}\n\nvoid ocfs2_put_slot(struct ocfs2_super *osb)\n{\n\tint status, slot_num;\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tif (!si)\n\t\treturn;\n\n\tspin_lock(&osb->osb_lock);\n\tocfs2_update_slot_info(si);\n\n\tslot_num = osb->slot_num;\n\tocfs2_invalidate_slot(si, osb->slot_num);\n\tosb->slot_num = OCFS2_INVALID_SLOT;\n\tspin_unlock(&osb->osb_lock);\n\n\tstatus = ocfs2_update_disk_slot(osb, si, slot_num);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_free_slot_info(osb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}