{
  "module_name": "refcounttree.c",
  "hash_id": "0ae6ac88772c8273a891b8b973f0c200c52f34a9e04bbcd83d31606668c7027e",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/refcounttree.c",
  "human_readable_source": "\n \n\n#include <linux/sort.h>\n#include <cluster/masklog.h>\n#include \"ocfs2.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"blockcheck.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"dlmglue.h\"\n#include \"extent_map.h\"\n#include \"aops.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ocfs2_trace.h\"\n#include \"file.h\"\n\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/posix_acl.h>\n\nstruct ocfs2_cow_context {\n\tstruct inode *inode;\n\tu32 cow_start;\n\tu32 cow_len;\n\tstruct ocfs2_extent_tree data_et;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tstruct buffer_head *ref_root_bh;\n\tstruct ocfs2_alloc_context *meta_ac;\n\tstruct ocfs2_alloc_context *data_ac;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tvoid *cow_object;\n\tstruct ocfs2_post_refcount *post_refcount;\n\tint extra_credits;\n\tint (*get_clusters)(struct ocfs2_cow_context *context,\n\t\t\t    u32 v_cluster, u32 *p_cluster,\n\t\t\t    u32 *num_clusters,\n\t\t\t    unsigned int *extent_flags);\n\tint (*cow_duplicate_clusters)(handle_t *handle,\n\t\t\t\t      struct inode *inode,\n\t\t\t\t      u32 cpos, u32 old_cluster,\n\t\t\t\t      u32 new_cluster, u32 new_len);\n};\n\nstatic inline struct ocfs2_refcount_tree *\ncache_info_to_refcount(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_refcount_tree, rf_ci);\n}\n\nstatic int ocfs2_validate_refcount_block(struct super_block *sb,\n\t\t\t\t\t struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_refcount_block *rb =\n\t\t(struct ocfs2_refcount_block *)bh->b_data;\n\n\ttrace_ocfs2_validate_refcount_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t \n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &rb->rf_check);\n\tif (rc) {\n\t\tmlog(ML_ERROR, \"Checksum failed for refcount block %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\treturn rc;\n\t}\n\n\n\tif (!OCFS2_IS_VALID_REFCOUNT_BLOCK(rb)) {\n\t\trc = ocfs2_error(sb,\n\t\t\t\t \"Refcount block #%llu has bad signature %.*s\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr, 7,\n\t\t\t\t rb->rf_signature);\n\t\tgoto out;\n\t}\n\n\tif (le64_to_cpu(rb->rf_blkno) != bh->b_blocknr) {\n\t\trc = ocfs2_error(sb,\n\t\t\t\t \"Refcount block #%llu has an invalid rf_blkno of %llu\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t (unsigned long long)le64_to_cpu(rb->rf_blkno));\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rb->rf_fs_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\trc = ocfs2_error(sb,\n\t\t\t\t \"Refcount block #%llu has an invalid rf_fs_generation of #%u\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t le32_to_cpu(rb->rf_fs_generation));\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}\n\nstatic int ocfs2_read_refcount_block(struct ocfs2_caching_info *ci,\n\t\t\t\t     u64 rb_blkno,\n\t\t\t\t     struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, rb_blkno, &tmp,\n\t\t\t      ocfs2_validate_refcount_block);\n\n\t \n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}\n\nstatic u64 ocfs2_refcount_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\n\n\treturn rf->rf_blkno;\n}\n\nstatic struct super_block *\nocfs2_refcount_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\n\n\treturn rf->rf_sb;\n}\n\nstatic void ocfs2_refcount_cache_lock(struct ocfs2_caching_info *ci)\n__acquires(&rf->rf_lock)\n{\n\tstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\n\n\tspin_lock(&rf->rf_lock);\n}\n\nstatic void ocfs2_refcount_cache_unlock(struct ocfs2_caching_info *ci)\n__releases(&rf->rf_lock)\n{\n\tstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\n\n\tspin_unlock(&rf->rf_lock);\n}\n\nstatic void ocfs2_refcount_cache_io_lock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\n\n\tmutex_lock(&rf->rf_io_mutex);\n}\n\nstatic void ocfs2_refcount_cache_io_unlock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\n\n\tmutex_unlock(&rf->rf_io_mutex);\n}\n\nstatic const struct ocfs2_caching_operations ocfs2_refcount_caching_ops = {\n\t.co_owner\t\t= ocfs2_refcount_cache_owner,\n\t.co_get_super\t\t= ocfs2_refcount_cache_get_super,\n\t.co_cache_lock\t\t= ocfs2_refcount_cache_lock,\n\t.co_cache_unlock\t= ocfs2_refcount_cache_unlock,\n\t.co_io_lock\t\t= ocfs2_refcount_cache_io_lock,\n\t.co_io_unlock\t\t= ocfs2_refcount_cache_io_unlock,\n};\n\nstatic struct ocfs2_refcount_tree *\nocfs2_find_refcount_tree(struct ocfs2_super *osb, u64 blkno)\n{\n\tstruct rb_node *n = osb->osb_rf_lock_tree.rb_node;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\n\twhile (n) {\n\t\ttree = rb_entry(n, struct ocfs2_refcount_tree, rf_node);\n\n\t\tif (blkno < tree->rf_blkno)\n\t\t\tn = n->rb_left;\n\t\telse if (blkno > tree->rf_blkno)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn tree;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void ocfs2_insert_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_refcount_tree *new)\n{\n\tu64 rf_blkno = new->rf_blkno;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p = &osb->osb_rf_lock_tree.rb_node;\n\tstruct ocfs2_refcount_tree *tmp;\n\n\twhile (*p) {\n\t\tparent = *p;\n\n\t\ttmp = rb_entry(parent, struct ocfs2_refcount_tree,\n\t\t\t       rf_node);\n\n\t\tif (rf_blkno < tmp->rf_blkno)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (rf_blkno > tmp->rf_blkno)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\t \n\t\t\tmlog(ML_ERROR, \"Duplicate refcount block %llu found!\\n\",\n\t\t\t     (unsigned long long)rf_blkno);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->rf_node, parent, p);\n\trb_insert_color(&new->rf_node, &osb->osb_rf_lock_tree);\n}\n\nstatic void ocfs2_free_refcount_tree(struct ocfs2_refcount_tree *tree)\n{\n\tocfs2_metadata_cache_exit(&tree->rf_ci);\n\tocfs2_simple_drop_lockres(OCFS2_SB(tree->rf_sb), &tree->rf_lockres);\n\tocfs2_lock_res_free(&tree->rf_lockres);\n\tkfree(tree);\n}\n\nstatic inline void\nocfs2_erase_refcount_tree_from_list_no_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *tree)\n{\n\trb_erase(&tree->rf_node, &osb->osb_rf_lock_tree);\n\tif (osb->osb_ref_tree_lru && osb->osb_ref_tree_lru == tree)\n\t\tosb->osb_ref_tree_lru = NULL;\n}\n\nstatic void ocfs2_erase_refcount_tree_from_list(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *tree)\n{\n\tspin_lock(&osb->osb_lock);\n\tocfs2_erase_refcount_tree_from_list_no_lock(osb, tree);\n\tspin_unlock(&osb->osb_lock);\n}\n\nstatic void ocfs2_kref_remove_refcount_tree(struct kref *kref)\n{\n\tstruct ocfs2_refcount_tree *tree =\n\t\tcontainer_of(kref, struct ocfs2_refcount_tree, rf_getcnt);\n\n\tocfs2_free_refcount_tree(tree);\n}\n\nstatic inline void\nocfs2_refcount_tree_get(struct ocfs2_refcount_tree *tree)\n{\n\tkref_get(&tree->rf_getcnt);\n}\n\nstatic inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}\n\nstatic inline void ocfs2_init_refcount_tree_ci(struct ocfs2_refcount_tree *new,\n\t\t\t\t\t       struct super_block *sb)\n{\n\tocfs2_metadata_cache_init(&new->rf_ci, &ocfs2_refcount_caching_ops);\n\tmutex_init(&new->rf_io_mutex);\n\tnew->rf_sb = sb;\n\tspin_lock_init(&new->rf_lock);\n}\n\nstatic inline void ocfs2_init_refcount_tree_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *new,\n\t\t\t\t\tu64 rf_blkno, u32 generation)\n{\n\tinit_rwsem(&new->rf_sem);\n\tocfs2_refcount_lock_res_init(&new->rf_lockres, osb,\n\t\t\t\t     rf_blkno, generation);\n}\n\nstatic struct ocfs2_refcount_tree*\nocfs2_allocate_refcount_tree(struct ocfs2_super *osb, u64 rf_blkno)\n{\n\tstruct ocfs2_refcount_tree *new;\n\n\tnew = kzalloc(sizeof(struct ocfs2_refcount_tree), GFP_NOFS);\n\tif (!new)\n\t\treturn NULL;\n\n\tnew->rf_blkno = rf_blkno;\n\tkref_init(&new->rf_getcnt);\n\tocfs2_init_refcount_tree_ci(new, osb->sb);\n\n\treturn new;\n}\n\nstatic int ocfs2_get_refcount_tree(struct ocfs2_super *osb, u64 rf_blkno,\n\t\t\t\t   struct ocfs2_refcount_tree **ret_tree)\n{\n\tint ret = 0;\n\tstruct ocfs2_refcount_tree *tree, *new = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *ref_rb;\n\n\tspin_lock(&osb->osb_lock);\n\tif (osb->osb_ref_tree_lru &&\n\t    osb->osb_ref_tree_lru->rf_blkno == rf_blkno)\n\t\ttree = osb->osb_ref_tree_lru;\n\telse\n\t\ttree = ocfs2_find_refcount_tree(osb, rf_blkno);\n\tif (tree)\n\t\tgoto out;\n\n\tspin_unlock(&osb->osb_lock);\n\n\tnew = ocfs2_allocate_refcount_tree(osb, rf_blkno);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\t \n\tret = ocfs2_read_refcount_block(&new->rf_ci, rf_blkno, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_metadata_cache_exit(&new->rf_ci);\n\t\tkfree(new);\n\t\treturn ret;\n\t}\n\n\tref_rb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tnew->rf_generation = le32_to_cpu(ref_rb->rf_generation);\n\tocfs2_init_refcount_tree_lock(osb, new, rf_blkno,\n\t\t\t\t      new->rf_generation);\n\tocfs2_metadata_cache_purge(&new->rf_ci);\n\n\tspin_lock(&osb->osb_lock);\n\ttree = ocfs2_find_refcount_tree(osb, rf_blkno);\n\tif (tree)\n\t\tgoto out;\n\n\tocfs2_insert_refcount_tree(osb, new);\n\n\ttree = new;\n\tnew = NULL;\n\nout:\n\t*ret_tree = tree;\n\n\tosb->osb_ref_tree_lru = tree;\n\n\tspin_unlock(&osb->osb_lock);\n\n\tif (new)\n\t\tocfs2_free_refcount_tree(new);\n\n\tbrelse(ref_root_bh);\n\treturn ret;\n}\n\nstatic int ocfs2_get_refcount_block(struct inode *inode, u64 *ref_blkno)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!ocfs2_is_refcount_inode(inode));\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\t*ref_blkno = le64_to_cpu(di->i_refcount_loc);\n\tbrelse(di_bh);\nout:\n\treturn ret;\n}\n\nstatic int __ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_refcount_tree *tree, int rw)\n{\n\tint ret;\n\n\tret = ocfs2_refcount_lock(tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rw)\n\t\tdown_write(&tree->rf_sem);\n\telse\n\t\tdown_read(&tree->rf_sem);\n\nout:\n\treturn ret;\n}\n\n \nint ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t \n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t \n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}\n\nvoid ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}\n\nvoid ocfs2_purge_refcount_trees(struct ocfs2_super *osb)\n{\n\tstruct rb_node *node;\n\tstruct ocfs2_refcount_tree *tree;\n\tstruct rb_root *root = &osb->osb_rf_lock_tree;\n\n\twhile ((node = rb_last(root)) != NULL) {\n\t\ttree = rb_entry(node, struct ocfs2_refcount_tree, rf_node);\n\n\t\ttrace_ocfs2_purge_refcount_trees(\n\t\t\t\t(unsigned long long) tree->rf_blkno);\n\n\t\trb_erase(&tree->rf_node, root);\n\t\tocfs2_free_refcount_tree(tree);\n\t}\n}\n\n \nstatic int ocfs2_create_refcount_tree(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh)\n{\n\tint ret;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_tree *new_tree = NULL, *tree = NULL;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\n\tBUG_ON(ocfs2_is_refcount_inode(inode));\n\n\ttrace_ocfs2_create_refcount_tree(\n\t\t(unsigned long long)oi->ip_blkno);\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_REFCOUNT_TREE_CREATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &suballoc_bit_start, &num_got,\n\t\t\t\t   &first_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnew_tree = ocfs2_allocate_refcount_tree(osb, first_blkno);\n\tif (!new_tree) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnew_bh = sb_getblk(inode->i_sb, first_blkno);\n\tif (!new_bh) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\tocfs2_set_new_buffer_uptodate(&new_tree->rf_ci, new_bh);\n\n\tret = ocfs2_journal_access_rb(handle, &new_tree->rf_ci, new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t \n\trb = (struct ocfs2_refcount_block *)new_bh->b_data;\n\tmemset(rb, 0, inode->i_sb->s_blocksize);\n\tstrcpy((void *)rb, OCFS2_REFCOUNT_BLOCK_SIGNATURE);\n\trb->rf_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\trb->rf_suballoc_loc = cpu_to_le64(suballoc_loc);\n\trb->rf_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\trb->rf_fs_generation = cpu_to_le32(osb->fs_generation);\n\trb->rf_blkno = cpu_to_le64(first_blkno);\n\trb->rf_count = cpu_to_le32(1);\n\trb->rf_records.rl_count =\n\t\t\tcpu_to_le16(ocfs2_refcount_recs_per_rb(osb->sb));\n\tspin_lock(&osb->osb_lock);\n\trb->rf_generation = osb->s_next_generation++;\n\tspin_unlock(&osb->osb_lock);\n\n\tocfs2_journal_dirty(handle, new_bh);\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_HAS_REFCOUNT_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tdi->i_refcount_loc = cpu_to_le64(first_blkno);\n\tspin_unlock(&oi->ip_lock);\n\n\ttrace_ocfs2_create_refcount_tree_blkno((unsigned long long)first_blkno);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\t \n\tnew_tree->rf_generation = le32_to_cpu(rb->rf_generation);\n\tocfs2_init_refcount_tree_lock(osb, new_tree, first_blkno,\n\t\t\t\t      new_tree->rf_generation);\n\n\tspin_lock(&osb->osb_lock);\n\ttree = ocfs2_find_refcount_tree(osb, first_blkno);\n\n\t \n\tBUG_ON(tree && tree->rf_generation == new_tree->rf_generation);\n\tif (tree)\n\t\tocfs2_erase_refcount_tree_from_list_no_lock(osb, tree);\n\tocfs2_insert_refcount_tree(osb, new_tree);\n\tspin_unlock(&osb->osb_lock);\n\tnew_tree = NULL;\n\tif (tree)\n\t\tocfs2_refcount_tree_put(tree);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (new_tree) {\n\t\tocfs2_metadata_cache_exit(&new_tree->rf_ci);\n\t\tkfree(new_tree);\n\t}\n\n\tbrelse(new_bh);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\treturn ret;\n}\n\nstatic int ocfs2_set_refcount_tree(struct inode *inode,\n\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t   u64 refcount_loc)\n{\n\tint ret;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\n\tBUG_ON(ocfs2_is_refcount_inode(inode));\n\n\tret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t       &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_REFCOUNT_TREE_SET_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, &ref_tree->rf_ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tle32_add_cpu(&rb->rf_count, 1);\n\n\tocfs2_journal_dirty(handle, ref_root_bh);\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_HAS_REFCOUNT_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tdi->i_refcount_loc = cpu_to_le64(refcount_loc);\n\tspin_unlock(&oi->ip_lock);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\n\n\treturn ret;\n}\n\nint ocfs2_remove_refcount_tree(struct inode *inode, struct buffer_head *di_bh)\n{\n\tint ret, delete_tree = 0;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_refcount_block *rb;\n\tstruct inode *alloc_inode = NULL;\n\tstruct buffer_head *alloc_bh = NULL;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tint credits = OCFS2_REFCOUNT_TREE_REMOVE_CREDITS;\n\tu64 blk = 0, bg_blkno = 0, ref_blkno = le64_to_cpu(di->i_refcount_loc);\n\tu16 bit = 0;\n\n\tif (!ocfs2_is_refcount_inode(inode))\n\t\treturn 0;\n\n\tBUG_ON(!ref_blkno);\n\tret = ocfs2_lock_refcount_tree(osb, ref_blkno, 1, &ref_tree, &blk_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)blk_bh->b_data;\n\n\t \n\tif (le32_to_cpu(rb->rf_count) == 1) {\n\t\tblk = le64_to_cpu(rb->rf_blkno);\n\t\tbit = le16_to_cpu(rb->rf_suballoc_bit);\n\t\tif (rb->rf_suballoc_loc)\n\t\t\tbg_blkno = le64_to_cpu(rb->rf_suballoc_loc);\n\t\telse\n\t\t\tbg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\n\t\talloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\tEXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\tle16_to_cpu(rb->rf_suballoc_slot));\n\t\tif (!alloc_inode) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tinode_lock(alloc_inode);\n\n\t\tret = ocfs2_inode_lock(alloc_inode, &alloc_bh, 1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_mutex;\n\t\t}\n\n\t\tcredits += OCFS2_SUBALLOC_FREE;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, &ref_tree->rf_ci, blk_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_HAS_REFCOUNT_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tdi->i_refcount_loc = 0;\n\tspin_unlock(&oi->ip_lock);\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tle32_add_cpu(&rb->rf_count , -1);\n\tocfs2_journal_dirty(handle, blk_bh);\n\n\tif (!rb->rf_count) {\n\t\tdelete_tree = 1;\n\t\tocfs2_erase_refcount_tree_from_list(osb, ref_tree);\n\t\tret = ocfs2_free_suballoc_bits(handle, alloc_inode,\n\t\t\t\t\t       alloc_bh, bit, bg_blkno, 1);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout_unlock:\n\tif (alloc_inode) {\n\t\tocfs2_inode_unlock(alloc_inode, 1);\n\t\tbrelse(alloc_bh);\n\t}\nout_mutex:\n\tif (alloc_inode) {\n\t\tinode_unlock(alloc_inode);\n\t\tiput(alloc_inode);\n\t}\nout:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tif (delete_tree)\n\t\tocfs2_refcount_tree_put(ref_tree);\n\tbrelse(blk_bh);\n\n\treturn ret;\n}\n\nstatic void ocfs2_find_refcount_rec_in_rl(struct ocfs2_caching_info *ci,\n\t\t\t\t\t  struct buffer_head *ref_leaf_bh,\n\t\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t\t  int *index)\n{\n\tint i = 0;\n\tstruct ocfs2_refcount_block *rb =\n\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_rec *rec = NULL;\n\n\tfor (; i < le16_to_cpu(rb->rf_records.rl_used); i++) {\n\t\trec = &rb->rf_records.rl_recs[i];\n\n\t\tif (le64_to_cpu(rec->r_cpos) +\n\t\t    le32_to_cpu(rec->r_clusters) <= cpos)\n\t\t\tcontinue;\n\t\telse if (le64_to_cpu(rec->r_cpos) > cpos)\n\t\t\tbreak;\n\n\t\t \n\t\tif (ret_rec)\n\t\t\t*ret_rec = *rec;\n\t\tgoto out;\n\t}\n\n\tif (ret_rec) {\n\t\t \n\t\tret_rec->r_cpos = cpu_to_le64(cpos);\n\t\tret_rec->r_refcount = 0;\n\t\tif (i < le16_to_cpu(rb->rf_records.rl_used) &&\n\t\t    le64_to_cpu(rec->r_cpos) < cpos + len)\n\t\t\tret_rec->r_clusters =\n\t\t\t\tcpu_to_le32(le64_to_cpu(rec->r_cpos) - cpos);\n\t\telse\n\t\t\tret_rec->r_clusters = cpu_to_le32(len);\n\t}\n\nout:\n\t*index = i;\n}\n\n \nint ocfs2_try_remove_refcount_tree(struct inode *inode,\n\t\t\t\t   struct buffer_head *di_bh)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&oi->ip_xattr_sem);\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (oi->ip_clusters)\n\t\tgoto out;\n\n\tif ((oi->ip_dyn_features & OCFS2_HAS_XATTR_FL) && di->i_xattr_loc)\n\t\tgoto out;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL &&\n\t    ocfs2_has_inline_xattr_value_outside(inode, di))\n\t\tgoto out;\n\n\tret = ocfs2_remove_refcount_tree(inode, di_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tup_write(&oi->ip_alloc_sem);\n\tup_write(&oi->ip_xattr_sem);\n\treturn 0;\n}\n\n \nstatic int ocfs2_get_refcount_cpos_end(struct ocfs2_caching_info *ci,\n\t\t\t\t       struct buffer_head *ref_root_bh,\n\t\t\t\t       struct ocfs2_extent_block *eb,\n\t\t\t\t       struct ocfs2_extent_list *el,\n\t\t\t\t       int index,  u32 *cpos_end)\n{\n\tint ret, i, subtree_root;\n\tu32 cpos;\n\tu64 blkno;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_path *left_path = NULL, *right_path = NULL;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_extent_list *tmp_el;\n\n\tif (index < le16_to_cpu(el->l_next_free_rec) - 1) {\n\t\t \n\t\t*cpos_end = le32_to_cpu(el->l_recs[index+1].e_cpos);\n\t\treturn 0;\n\t}\n\n\tif (!eb || !eb->h_next_leaf_blk) {\n\t\t \n\t\t*cpos_end = UINT_MAX;\n\t\treturn 0;\n\t}\n\n\t \n\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\n\tleft_path = ocfs2_new_path_from_et(&et);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcpos = le32_to_cpu(eb->h_list.l_recs[index].e_cpos);\n\tret = ocfs2_find_path(ci, left_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tright_path = ocfs2_new_path_from_path(left_path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_right_leaf(sb, left_path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tsubtree_root = ocfs2_find_subtree_root(&et, left_path,\n\t\t\t\t\t       right_path);\n\n\ttmp_el = left_path->p_node[subtree_root].el;\n\tblkno = left_path->p_node[subtree_root+1].bh->b_blocknr;\n\tfor (i = 0; i < le16_to_cpu(tmp_el->l_next_free_rec); i++) {\n\t\tif (le64_to_cpu(tmp_el->l_recs[i].e_blkno) == blkno) {\n\t\t\t*cpos_end = le32_to_cpu(tmp_el->l_recs[i+1].e_cpos);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tBUG_ON(i == le16_to_cpu(tmp_el->l_next_free_rec));\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\treturn ret;\n}\n\n \nstatic int ocfs2_get_refcount_rec(struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *ref_root_bh,\n\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t  int *index,\n\t\t\t\t  struct buffer_head **ret_bh)\n{\n\tint ret = 0, i, found;\n\tu32 low_cpos, cpos_end;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct buffer_head *eb_bh = NULL, *ref_leaf_bh = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)) {\n\t\tocfs2_find_refcount_rec_in_rl(ci, ref_root_bh, cpos, len,\n\t\t\t\t\t      ret_rec, index);\n\t\t*ret_bh = ref_root_bh;\n\t\tget_bh(ref_root_bh);\n\t\treturn 0;\n\t}\n\n\tel = &rb->rf_list;\n\tlow_cpos = cpos & OCFS2_32BIT_POS_MASK;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(ci, el, low_cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tret = ocfs2_error(sb,\n\t\t\t\t\t  \"refcount tree %llu has non zero tree depth in leaf btree tree block %llu\\n\",\n\t\t\t\t\t  (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t\t  (unsigned long long)eb_bh->b_blocknr);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= low_cpos) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tret = ocfs2_get_refcount_cpos_end(ci, ref_root_bh,\n\t\t\t\t\t\t  eb, el, i, &cpos_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos_end < low_cpos + len)\n\t\t\tlen = cpos_end - low_cpos;\n\t}\n\n\tret = ocfs2_read_refcount_block(ci, le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t&ref_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_find_refcount_rec_in_rl(ci, ref_leaf_bh, cpos, len,\n\t\t\t\t      ret_rec, index);\n\t*ret_bh = ref_leaf_bh;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}\n\nenum ocfs2_ref_rec_contig {\n\tREF_CONTIG_NONE = 0,\n\tREF_CONTIG_LEFT,\n\tREF_CONTIG_RIGHT,\n\tREF_CONTIG_LEFTRIGHT,\n};\n\nstatic enum ocfs2_ref_rec_contig\n\tocfs2_refcount_rec_adjacent(struct ocfs2_refcount_block *rb,\n\t\t\t\t    int index)\n{\n\tif ((rb->rf_records.rl_recs[index].r_refcount ==\n\t    rb->rf_records.rl_recs[index + 1].r_refcount) &&\n\t    (le64_to_cpu(rb->rf_records.rl_recs[index].r_cpos) +\n\t    le32_to_cpu(rb->rf_records.rl_recs[index].r_clusters) ==\n\t    le64_to_cpu(rb->rf_records.rl_recs[index + 1].r_cpos)))\n\t\treturn REF_CONTIG_RIGHT;\n\n\treturn REF_CONTIG_NONE;\n}\n\nstatic enum ocfs2_ref_rec_contig\n\tocfs2_refcount_rec_contig(struct ocfs2_refcount_block *rb,\n\t\t\t\t  int index)\n{\n\tenum ocfs2_ref_rec_contig ret = REF_CONTIG_NONE;\n\n\tif (index < le16_to_cpu(rb->rf_records.rl_used) - 1)\n\t\tret = ocfs2_refcount_rec_adjacent(rb, index);\n\n\tif (index > 0) {\n\t\tenum ocfs2_ref_rec_contig tmp;\n\n\t\ttmp = ocfs2_refcount_rec_adjacent(rb, index - 1);\n\n\t\tif (tmp == REF_CONTIG_RIGHT) {\n\t\t\tif (ret == REF_CONTIG_RIGHT)\n\t\t\t\tret = REF_CONTIG_LEFTRIGHT;\n\t\t\telse\n\t\t\t\tret = REF_CONTIG_LEFT;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void ocfs2_rotate_refcount_rec_left(struct ocfs2_refcount_block *rb,\n\t\t\t\t\t   int index)\n{\n\tBUG_ON(rb->rf_records.rl_recs[index].r_refcount !=\n\t       rb->rf_records.rl_recs[index+1].r_refcount);\n\n\tle32_add_cpu(&rb->rf_records.rl_recs[index].r_clusters,\n\t\t     le32_to_cpu(rb->rf_records.rl_recs[index+1].r_clusters));\n\n\tif (index < le16_to_cpu(rb->rf_records.rl_used) - 2)\n\t\tmemmove(&rb->rf_records.rl_recs[index + 1],\n\t\t\t&rb->rf_records.rl_recs[index + 2],\n\t\t\tsizeof(struct ocfs2_refcount_rec) *\n\t\t\t(le16_to_cpu(rb->rf_records.rl_used) - index - 2));\n\n\tmemset(&rb->rf_records.rl_recs[le16_to_cpu(rb->rf_records.rl_used) - 1],\n\t       0, sizeof(struct ocfs2_refcount_rec));\n\tle16_add_cpu(&rb->rf_records.rl_used, -1);\n}\n\n \nstatic void ocfs2_refcount_rec_merge(struct ocfs2_refcount_block *rb,\n\t\t\t\t     int index)\n{\n\tenum ocfs2_ref_rec_contig contig =\n\t\t\t\tocfs2_refcount_rec_contig(rb, index);\n\n\tif (contig == REF_CONTIG_NONE)\n\t\treturn;\n\n\tif (contig == REF_CONTIG_LEFT || contig == REF_CONTIG_LEFTRIGHT) {\n\t\tBUG_ON(index == 0);\n\t\tindex--;\n\t}\n\n\tocfs2_rotate_refcount_rec_left(rb, index);\n\n\tif (contig == REF_CONTIG_LEFTRIGHT)\n\t\tocfs2_rotate_refcount_rec_left(rb, index);\n}\n\n \nstatic int ocfs2_change_refcount_rec(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_leaf_bh,\n\t\t\t\t     int index, int merge, int change)\n{\n\tint ret;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rl = &rb->rf_records;\n\tstruct ocfs2_refcount_rec *rec = &rl->rl_recs[index];\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_change_refcount_rec(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\tindex, le32_to_cpu(rec->r_refcount), change);\n\tle32_add_cpu(&rec->r_refcount, change);\n\n\tif (!rec->r_refcount) {\n\t\tif (index != le16_to_cpu(rl->rl_used) - 1) {\n\t\t\tmemmove(rec, rec + 1,\n\t\t\t\t(le16_to_cpu(rl->rl_used) - index - 1) *\n\t\t\t\tsizeof(struct ocfs2_refcount_rec));\n\t\t\tmemset(&rl->rl_recs[le16_to_cpu(rl->rl_used) - 1],\n\t\t\t       0, sizeof(struct ocfs2_refcount_rec));\n\t\t}\n\n\t\tle16_add_cpu(&rl->rl_used, -1);\n\t} else if (merge)\n\t\tocfs2_refcount_rec_merge(rb, index);\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_expand_inline_ref_root(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct buffer_head **ref_leaf_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, blkno;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_refcount_block *new_rb;\n\tstruct ocfs2_refcount_block *root_rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &suballoc_bit_start, &num_got,\n\t\t\t\t   &blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnew_bh = sb_getblk(sb, blkno);\n\tif (new_bh == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(ci, new_bh);\n\n\tret = ocfs2_journal_access_rb(handle, ci, new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tmemcpy(new_bh->b_data, ref_root_bh->b_data, sb->s_blocksize);\n\n\tnew_rb = (struct ocfs2_refcount_block *)new_bh->b_data;\n\tnew_rb->rf_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\tnew_rb->rf_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tnew_rb->rf_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\tnew_rb->rf_blkno = cpu_to_le64(blkno);\n\tnew_rb->rf_cpos = cpu_to_le32(0);\n\tnew_rb->rf_parent = cpu_to_le64(ref_root_bh->b_blocknr);\n\tnew_rb->rf_flags = cpu_to_le32(OCFS2_REFCOUNT_LEAF_FL);\n\tocfs2_journal_dirty(handle, new_bh);\n\n\t \n\tmemset(&root_rb->rf_list, 0, sb->s_blocksize -\n\t       offsetof(struct ocfs2_refcount_block, rf_list));\n\troot_rb->rf_list.l_count = cpu_to_le16(ocfs2_extent_recs_per_rb(sb));\n\troot_rb->rf_clusters = cpu_to_le32(1);\n\troot_rb->rf_list.l_next_free_rec = cpu_to_le16(1);\n\troot_rb->rf_list.l_recs[0].e_blkno = cpu_to_le64(blkno);\n\troot_rb->rf_list.l_recs[0].e_leaf_clusters = cpu_to_le16(1);\n\troot_rb->rf_flags = cpu_to_le32(OCFS2_REFCOUNT_TREE_FL);\n\n\tocfs2_journal_dirty(handle, ref_root_bh);\n\n\ttrace_ocfs2_expand_inline_ref_root((unsigned long long)blkno,\n\t\tle16_to_cpu(new_rb->rf_records.rl_used));\n\n\t*ref_leaf_bh = new_bh;\n\tnew_bh = NULL;\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}\n\nstatic int ocfs2_refcount_rec_no_intersect(struct ocfs2_refcount_rec *prev,\n\t\t\t\t\t   struct ocfs2_refcount_rec *next)\n{\n\tif (ocfs2_get_ref_rec_low_cpos(prev) + le32_to_cpu(prev->r_clusters) <=\n\t\tocfs2_get_ref_rec_low_cpos(next))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int cmp_refcount_rec_by_low_cpos(const void *a, const void *b)\n{\n\tconst struct ocfs2_refcount_rec *l = a, *r = b;\n\tu32 l_cpos = ocfs2_get_ref_rec_low_cpos(l);\n\tu32 r_cpos = ocfs2_get_ref_rec_low_cpos(r);\n\n\tif (l_cpos > r_cpos)\n\t\treturn 1;\n\tif (l_cpos < r_cpos)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int cmp_refcount_rec_by_cpos(const void *a, const void *b)\n{\n\tconst struct ocfs2_refcount_rec *l = a, *r = b;\n\tu64 l_cpos = le64_to_cpu(l->r_cpos);\n\tu64 r_cpos = le64_to_cpu(r->r_cpos);\n\n\tif (l_cpos > r_cpos)\n\t\treturn 1;\n\tif (l_cpos < r_cpos)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void swap_refcount_rec(void *a, void *b, int size)\n{\n\tstruct ocfs2_refcount_rec *l = a, *r = b;\n\n\tswap(*l, *r);\n}\n\n \nstatic int ocfs2_find_refcount_split_pos(struct ocfs2_refcount_list *rl,\n\t\t\t\t\t u32 *split_pos, int *split_index)\n{\n\tint num_used = le16_to_cpu(rl->rl_used);\n\tint delta, middle = num_used / 2;\n\n\tfor (delta = 0; delta < middle; delta++) {\n\t\t \n\t\tif (ocfs2_refcount_rec_no_intersect(\n\t\t\t\t\t&rl->rl_recs[middle - delta - 1],\n\t\t\t\t\t&rl->rl_recs[middle - delta])) {\n\t\t\t*split_index = middle - delta;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif ((middle + delta + 1) == num_used)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ocfs2_refcount_rec_no_intersect(\n\t\t\t\t\t&rl->rl_recs[middle + delta],\n\t\t\t\t\t&rl->rl_recs[middle + delta + 1])) {\n\t\t\t*split_index = middle + delta + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (delta >= middle)\n\t\treturn -ENOSPC;\n\n\t*split_pos = ocfs2_get_ref_rec_low_cpos(&rl->rl_recs[*split_index]);\n\treturn 0;\n}\n\nstatic int ocfs2_divide_leaf_refcount_block(struct buffer_head *ref_leaf_bh,\n\t\t\t\t\t    struct buffer_head *new_bh,\n\t\t\t\t\t    u32 *split_cpos)\n{\n\tint split_index = 0, num_moved, ret;\n\tu32 cpos = 0;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rl = &rb->rf_records;\n\tstruct ocfs2_refcount_block *new_rb =\n\t\t\t(struct ocfs2_refcount_block *)new_bh->b_data;\n\tstruct ocfs2_refcount_list *new_rl = &new_rb->rf_records;\n\n\ttrace_ocfs2_divide_leaf_refcount_block(\n\t\t(unsigned long long)ref_leaf_bh->b_blocknr,\n\t\tle16_to_cpu(rl->rl_count), le16_to_cpu(rl->rl_used));\n\n\t \n\tsort(&rl->rl_recs, le16_to_cpu(rl->rl_used),\n\t     sizeof(struct ocfs2_refcount_rec),\n\t     cmp_refcount_rec_by_low_cpos, swap_refcount_rec);\n\n\tret = ocfs2_find_refcount_split_pos(rl, &cpos, &split_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tnew_rb->rf_cpos = cpu_to_le32(cpos);\n\n\t \n\tnum_moved = le16_to_cpu(rl->rl_used) - split_index;\n\tmemcpy(new_rl->rl_recs, &rl->rl_recs[split_index],\n\t       num_moved * sizeof(struct ocfs2_refcount_rec));\n\n\t \n\tmemset(&rl->rl_recs[split_index], 0,\n\t       num_moved * sizeof(struct ocfs2_refcount_rec));\n\n\t \n\tle16_add_cpu(&rl->rl_used, -num_moved);\n\tnew_rl->rl_used = cpu_to_le16(num_moved);\n\n\tsort(&rl->rl_recs, le16_to_cpu(rl->rl_used),\n\t     sizeof(struct ocfs2_refcount_rec),\n\t     cmp_refcount_rec_by_cpos, swap_refcount_rec);\n\n\tsort(&new_rl->rl_recs, le16_to_cpu(new_rl->rl_used),\n\t     sizeof(struct ocfs2_refcount_rec),\n\t     cmp_refcount_rec_by_cpos, swap_refcount_rec);\n\n\t*split_cpos = cpos;\n\treturn 0;\n}\n\nstatic int ocfs2_new_leaf_refcount_block(handle_t *handle,\n\t\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t\t struct buffer_head *ref_root_bh,\n\t\t\t\t\t struct buffer_head *ref_leaf_bh,\n\t\t\t\t\t struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tu16 suballoc_bit_start;\n\tu32 num_got, new_cpos;\n\tu64 suballoc_loc, blkno;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *root_rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_refcount_block *new_rb;\n\tstruct ocfs2_extent_tree ref_et;\n\n\tBUG_ON(!(le32_to_cpu(root_rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL));\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &suballoc_bit_start, &num_got,\n\t\t\t\t   &blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnew_bh = sb_getblk(sb, blkno);\n\tif (new_bh == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(ci, new_bh);\n\n\tret = ocfs2_journal_access_rb(handle, ci, new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tnew_rb = (struct ocfs2_refcount_block *)new_bh->b_data;\n\tmemset(new_rb, 0, sb->s_blocksize);\n\tstrcpy((void *)new_rb, OCFS2_REFCOUNT_BLOCK_SIGNATURE);\n\tnew_rb->rf_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\tnew_rb->rf_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tnew_rb->rf_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\tnew_rb->rf_fs_generation = cpu_to_le32(OCFS2_SB(sb)->fs_generation);\n\tnew_rb->rf_blkno = cpu_to_le64(blkno);\n\tnew_rb->rf_parent = cpu_to_le64(ref_root_bh->b_blocknr);\n\tnew_rb->rf_flags = cpu_to_le32(OCFS2_REFCOUNT_LEAF_FL);\n\tnew_rb->rf_records.rl_count =\n\t\t\t\tcpu_to_le16(ocfs2_refcount_recs_per_rb(sb));\n\tnew_rb->rf_generation = root_rb->rf_generation;\n\n\tret = ocfs2_divide_leaf_refcount_block(ref_leaf_bh, new_bh, &new_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\tocfs2_journal_dirty(handle, new_bh);\n\n\tocfs2_init_refcount_extent_tree(&ref_et, ci, ref_root_bh);\n\n\ttrace_ocfs2_new_leaf_refcount_block(\n\t\t\t(unsigned long long)new_bh->b_blocknr, new_cpos);\n\n\t \n\tret = ocfs2_insert_extent(handle, &ref_et, new_cpos, new_bh->b_blocknr,\n\t\t\t\t  1, 0, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}\n\nstatic int ocfs2_expand_refcount_tree(handle_t *handle,\n\t\t\t\t      struct ocfs2_caching_info *ci,\n\t\t\t\t      struct buffer_head *ref_root_bh,\n\t\t\t\t      struct buffer_head *ref_leaf_bh,\n\t\t\t\t      struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tstruct buffer_head *expand_bh = NULL;\n\n\tif (ref_root_bh == ref_leaf_bh) {\n\t\t \n\t\tret = ocfs2_expand_inline_ref_root(handle, ci, ref_root_bh,\n\t\t\t\t\t\t   &expand_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\texpand_bh = ref_leaf_bh;\n\t\tget_bh(expand_bh);\n\t}\n\n\n\t \n\tret = ocfs2_new_leaf_refcount_block(handle, ci, ref_root_bh,\n\t\t\t\t\t    expand_bh, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(expand_bh);\n\treturn ret;\n}\n\n \nstatic int ocfs2_adjust_refcount_rec(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     struct buffer_head *ref_leaf_bh,\n\t\t\t\t     struct ocfs2_refcount_rec *rec)\n{\n\tint ret = 0, i;\n\tu32 new_cpos, old_cpos;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_refcount_block *rb =\n\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tstruct ocfs2_extent_list *el;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL))\n\t\tgoto out;\n\n\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\told_cpos = le32_to_cpu(rb->rf_cpos);\n\tnew_cpos = le64_to_cpu(rec->r_cpos) & OCFS2_32BIT_POS_MASK;\n\tif (old_cpos <= new_cpos)\n\t\tgoto out;\n\n\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\n\tpath = ocfs2_new_path_from_et(&et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(ci, path, old_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tret = ocfs2_extend_trans(handle, 2);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_eb(handle, ci, path_leaf_bh(path),\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tel = path_leaf_el(path);\n\n\tfor (i = 0; i < le16_to_cpu(el->l_next_free_rec); i++)\n\t\tif (le32_to_cpu(el->l_recs[i].e_cpos) == old_cpos)\n\t\t\tbreak;\n\n\tBUG_ON(i == le16_to_cpu(el->l_next_free_rec));\n\n\tel->l_recs[i].e_cpos = cpu_to_le32(new_cpos);\n\n\t \n\trb->rf_cpos = cpu_to_le32(new_cpos);\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}\n\nstatic int ocfs2_insert_refcount_rec(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     struct buffer_head *ref_leaf_bh,\n\t\t\t\t     struct ocfs2_refcount_rec *rec,\n\t\t\t\t     int index, int merge,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rf_list = &rb->rf_records;\n\tstruct buffer_head *new_bh = NULL;\n\n\tBUG_ON(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL);\n\n\tif (rf_list->rl_used == rf_list->rl_count) {\n\t\tu64 cpos = le64_to_cpu(rec->r_cpos);\n\t\tu32 len = le32_to_cpu(rec->r_clusters);\n\n\t\tret = ocfs2_expand_refcount_tree(handle, ci, ref_root_bh,\n\t\t\t\t\t\t ref_leaf_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, NULL, &index,\n\t\t\t\t\t     &new_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tref_leaf_bh = new_bh;\n\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\t\trf_list = &rb->rf_records;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (index < le16_to_cpu(rf_list->rl_used))\n\t\tmemmove(&rf_list->rl_recs[index + 1],\n\t\t\t&rf_list->rl_recs[index],\n\t\t\t(le16_to_cpu(rf_list->rl_used) - index) *\n\t\t\t sizeof(struct ocfs2_refcount_rec));\n\n\ttrace_ocfs2_insert_refcount_rec(\n\t\t(unsigned long long)ref_leaf_bh->b_blocknr, index,\n\t\t(unsigned long long)le64_to_cpu(rec->r_cpos),\n\t\tle32_to_cpu(rec->r_clusters), le32_to_cpu(rec->r_refcount));\n\n\trf_list->rl_recs[index] = *rec;\n\n\tle16_add_cpu(&rf_list->rl_used, 1);\n\n\tif (merge)\n\t\tocfs2_refcount_rec_merge(rb, index);\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\n\tif (index == 0) {\n\t\tret = ocfs2_adjust_refcount_rec(handle, ci,\n\t\t\t\t\t\tref_root_bh,\n\t\t\t\t\t\tref_leaf_bh, rec);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}\n\n \nstatic int ocfs2_split_refcount_rec(handle_t *handle,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t\t    struct buffer_head *ref_leaf_bh,\n\t\t\t\t    struct ocfs2_refcount_rec *split_rec,\n\t\t\t\t    int index, int merge,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, recs_need;\n\tu32 len;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rf_list = &rb->rf_records;\n\tstruct ocfs2_refcount_rec *orig_rec = &rf_list->rl_recs[index];\n\tstruct ocfs2_refcount_rec *tail_rec = NULL;\n\tstruct buffer_head *new_bh = NULL;\n\n\tBUG_ON(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL);\n\n\ttrace_ocfs2_split_refcount_rec(le64_to_cpu(orig_rec->r_cpos),\n\t\tle32_to_cpu(orig_rec->r_clusters),\n\t\tle32_to_cpu(orig_rec->r_refcount),\n\t\tle64_to_cpu(split_rec->r_cpos),\n\t\tle32_to_cpu(split_rec->r_clusters),\n\t\tle32_to_cpu(split_rec->r_refcount));\n\n\t \n\tif (!split_rec->r_refcount &&\n\t    (split_rec->r_cpos == orig_rec->r_cpos ||\n\t     le64_to_cpu(split_rec->r_cpos) +\n\t     le32_to_cpu(split_rec->r_clusters) ==\n\t     le64_to_cpu(orig_rec->r_cpos) + le32_to_cpu(orig_rec->r_clusters)))\n\t\trecs_need = 0;\n\telse\n\t\trecs_need = 1;\n\n\t \n\tif (split_rec->r_refcount &&\n\t    (split_rec->r_cpos != orig_rec->r_cpos &&\n\t     le64_to_cpu(split_rec->r_cpos) +\n\t     le32_to_cpu(split_rec->r_clusters) !=\n\t     le64_to_cpu(orig_rec->r_cpos) + le32_to_cpu(orig_rec->r_clusters)))\n\t\trecs_need++;\n\n\t \n\tif (le16_to_cpu(rf_list->rl_used) + recs_need >\n\t\t\t\t\t le16_to_cpu(rf_list->rl_count)) {\n\t\tstruct ocfs2_refcount_rec tmp_rec;\n\t\tu64 cpos = le64_to_cpu(orig_rec->r_cpos);\n\t\tlen = le32_to_cpu(orig_rec->r_clusters);\n\t\tret = ocfs2_expand_refcount_tree(handle, ci, ref_root_bh,\n\t\t\t\t\t\t ref_leaf_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &tmp_rec, &index,\n\t\t\t\t\t     &new_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tref_leaf_bh = new_bh;\n\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\t\trf_list = &rb->rf_records;\n\t\torig_rec = &rf_list->rl_recs[index];\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tif (index != le16_to_cpu(rf_list->rl_used) - 1)\n\t\tmemmove(&rf_list->rl_recs[index + 1 + recs_need],\n\t\t\t&rf_list->rl_recs[index + 1],\n\t\t\t(le16_to_cpu(rf_list->rl_used) - index - 1) *\n\t\t\t sizeof(struct ocfs2_refcount_rec));\n\n\tlen = (le64_to_cpu(orig_rec->r_cpos) +\n\t      le32_to_cpu(orig_rec->r_clusters)) -\n\t      (le64_to_cpu(split_rec->r_cpos) +\n\t      le32_to_cpu(split_rec->r_clusters));\n\n\t \n\tif (len) {\n\t\ttail_rec = &rf_list->rl_recs[index + recs_need];\n\n\t\tmemcpy(tail_rec, orig_rec, sizeof(struct ocfs2_refcount_rec));\n\t\tle64_add_cpu(&tail_rec->r_cpos,\n\t\t\t     le32_to_cpu(tail_rec->r_clusters) - len);\n\t\ttail_rec->r_clusters = cpu_to_le32(len);\n\t}\n\n\t \n\tif (split_rec->r_cpos != orig_rec->r_cpos && tail_rec != orig_rec) {\n\t\tlen = le64_to_cpu(split_rec->r_cpos) -\n\t\t      le64_to_cpu(orig_rec->r_cpos);\n\t\torig_rec->r_clusters = cpu_to_le32(len);\n\t\tindex++;\n\t}\n\n\tle16_add_cpu(&rf_list->rl_used, recs_need);\n\n\tif (split_rec->r_refcount) {\n\t\trf_list->rl_recs[index] = *split_rec;\n\t\ttrace_ocfs2_split_refcount_rec_insert(\n\t\t\t(unsigned long long)ref_leaf_bh->b_blocknr, index,\n\t\t\t(unsigned long long)le64_to_cpu(split_rec->r_cpos),\n\t\t\tle32_to_cpu(split_rec->r_clusters),\n\t\t\tle32_to_cpu(split_rec->r_refcount));\n\n\t\tif (merge)\n\t\t\tocfs2_refcount_rec_merge(rb, index);\n\t}\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}\n\nstatic int __ocfs2_increase_refcount(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     u64 cpos, u32 len, int merge,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0, index;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\tstruct ocfs2_refcount_rec rec;\n\tunsigned int set_len = 0;\n\n\ttrace_ocfs2_increase_refcount_begin(\n\t     (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t     (unsigned long long)cpos, len);\n\n\twhile (len) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &rec, &index,\n\t\t\t\t\t     &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_len = le32_to_cpu(rec.r_clusters);\n\n\t\t \n\t\tif (rec.r_refcount && le64_to_cpu(rec.r_cpos) == cpos &&\n\t\t    set_len <= len) {\n\t\t\ttrace_ocfs2_increase_refcount_change(\n\t\t\t\t(unsigned long long)cpos, set_len,\n\t\t\t\tle32_to_cpu(rec.r_refcount));\n\t\t\tret = ocfs2_change_refcount_rec(handle, ci,\n\t\t\t\t\t\t\tref_leaf_bh, index,\n\t\t\t\t\t\t\tmerge, 1);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (!rec.r_refcount) {\n\t\t\trec.r_refcount = cpu_to_le32(1);\n\n\t\t\ttrace_ocfs2_increase_refcount_insert(\n\t\t\t     (unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t     set_len);\n\t\t\tret = ocfs2_insert_refcount_rec(handle, ci, ref_root_bh,\n\t\t\t\t\t\t\tref_leaf_bh,\n\t\t\t\t\t\t\t&rec, index,\n\t\t\t\t\t\t\tmerge, meta_ac);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else  {\n\t\t\tset_len = min((u64)(cpos + len),\n\t\t\t\t      le64_to_cpu(rec.r_cpos) + set_len) - cpos;\n\t\t\trec.r_cpos = cpu_to_le64(cpos);\n\t\t\trec.r_clusters = cpu_to_le32(set_len);\n\t\t\tle32_add_cpu(&rec.r_refcount, 1);\n\n\t\t\ttrace_ocfs2_increase_refcount_split(\n\t\t\t     (unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t     set_len, le32_to_cpu(rec.r_refcount));\n\t\t\tret = ocfs2_split_refcount_rec(handle, ci,\n\t\t\t\t\t\t       ref_root_bh, ref_leaf_bh,\n\t\t\t\t\t\t       &rec, index, merge,\n\t\t\t\t\t\t       meta_ac, dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += set_len;\n\t\tlen -= set_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}\n\nstatic int ocfs2_remove_refcount_extent(handle_t *handle,\n\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct buffer_head *ref_leaf_bh,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_extent_tree et;\n\n\tBUG_ON(rb->rf_records.rl_used);\n\n\ttrace_ocfs2_remove_refcount_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)ref_leaf_bh->b_blocknr,\n\t\tle32_to_cpu(rb->rf_cpos));\n\n\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\tret = ocfs2_remove_extent(handle, &et, le32_to_cpu(rb->rf_cpos),\n\t\t\t\t  1, meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_from_cache(ci, ref_leaf_bh);\n\n\t \n\tret = ocfs2_cache_block_dealloc(dealloc, EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\tle16_to_cpu(rb->rf_suballoc_slot),\n\t\t\t\t\tle64_to_cpu(rb->rf_suballoc_loc),\n\t\t\t\t\tle64_to_cpu(rb->rf_blkno),\n\t\t\t\t\tle16_to_cpu(rb->rf_suballoc_bit));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tle32_add_cpu(&rb->rf_clusters, -1);\n\n\t \n\tif (!rb->rf_list.l_next_free_rec) {\n\t\tBUG_ON(rb->rf_clusters);\n\n\t\ttrace_ocfs2_restore_refcount_block(\n\t\t     (unsigned long long)ref_root_bh->b_blocknr);\n\n\t\trb->rf_flags = 0;\n\t\trb->rf_parent = 0;\n\t\trb->rf_cpos = 0;\n\t\tmemset(&rb->rf_records, 0, sb->s_blocksize -\n\t\t       offsetof(struct ocfs2_refcount_block, rf_records));\n\t\trb->rf_records.rl_count =\n\t\t\t\tcpu_to_le16(ocfs2_refcount_recs_per_rb(sb));\n\t}\n\n\tocfs2_journal_dirty(handle, ref_root_bh);\n\nout:\n\treturn ret;\n}\n\nint ocfs2_increase_refcount(handle_t *handle,\n\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t    u64 cpos, u32 len,\n\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\treturn __ocfs2_increase_refcount(handle, ci, ref_root_bh,\n\t\t\t\t\t cpos, len, 1,\n\t\t\t\t\t meta_ac, dealloc);\n}\n\nstatic int ocfs2_decrease_refcount_rec(handle_t *handle,\n\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct buffer_head *ref_leaf_bh,\n\t\t\t\tint index, u64 cpos, unsigned int len,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_rec *rec = &rb->rf_records.rl_recs[index];\n\n\tBUG_ON(cpos < le64_to_cpu(rec->r_cpos));\n\tBUG_ON(cpos + len >\n\t       le64_to_cpu(rec->r_cpos) + le32_to_cpu(rec->r_clusters));\n\n\ttrace_ocfs2_decrease_refcount_rec(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)cpos, len);\n\n\tif (cpos == le64_to_cpu(rec->r_cpos) &&\n\t    len == le32_to_cpu(rec->r_clusters))\n\t\tret = ocfs2_change_refcount_rec(handle, ci,\n\t\t\t\t\t\tref_leaf_bh, index, 1, -1);\n\telse {\n\t\tstruct ocfs2_refcount_rec split = *rec;\n\t\tsplit.r_cpos = cpu_to_le64(cpos);\n\t\tsplit.r_clusters = cpu_to_le32(len);\n\n\t\tle32_add_cpu(&split.r_refcount, -1);\n\n\t\tret = ocfs2_split_refcount_rec(handle, ci,\n\t\t\t\t\t       ref_root_bh, ref_leaf_bh,\n\t\t\t\t\t       &split, index, 1,\n\t\t\t\t\t       meta_ac, dealloc);\n\t}\n\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!rb->rf_records.rl_used && ref_leaf_bh != ref_root_bh) {\n\t\tret = ocfs2_remove_refcount_extent(handle, ci, ref_root_bh,\n\t\t\t\t\t\t   ref_leaf_bh, meta_ac,\n\t\t\t\t\t\t   dealloc);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int __ocfs2_decrease_refcount(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     u64 cpos, u32 len,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     int delete)\n{\n\tint ret = 0, index = 0;\n\tstruct ocfs2_refcount_rec rec;\n\tunsigned int r_count = 0, r_len;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\n\ttrace_ocfs2_decrease_refcount(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)cpos, len, delete);\n\n\twhile (len) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &rec, &index,\n\t\t\t\t\t     &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr_count = le32_to_cpu(rec.r_refcount);\n\t\tBUG_ON(r_count == 0);\n\t\tif (!delete)\n\t\t\tBUG_ON(r_count > 1);\n\n\t\tr_len = min((u64)(cpos + len), le64_to_cpu(rec.r_cpos) +\n\t\t\t      le32_to_cpu(rec.r_clusters)) - cpos;\n\n\t\tret = ocfs2_decrease_refcount_rec(handle, ci, ref_root_bh,\n\t\t\t\t\t\t  ref_leaf_bh, index,\n\t\t\t\t\t\t  cpos, r_len,\n\t\t\t\t\t\t  meta_ac, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (le32_to_cpu(rec.r_refcount) == 1 && delete) {\n\t\t\tret = ocfs2_cache_cluster_dealloc(dealloc,\n\t\t\t\t\t  ocfs2_clusters_to_blocks(sb, cpos),\n\t\t\t\t\t\t\t  r_len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += r_len;\n\t\tlen -= r_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}\n\n \nint ocfs2_decrease_refcount(struct inode *inode,\n\t\t\t    handle_t *handle, u32 cpos, u32 len,\n\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t    int delete)\n{\n\tint ret;\n\tu64 ref_blkno;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\n\tBUG_ON(!ocfs2_is_refcount_inode(inode));\n\n\tret = ocfs2_get_refcount_block(inode, &ref_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb), ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_decrease_refcount(handle, &tree->rf_ci, ref_root_bh,\n\t\t\t\t\tcpos, len, meta_ac, dealloc, delete);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}\n\n \nstatic int ocfs2_mark_extent_refcounted(struct inode *inode,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\thandle_t *handle, u32 cpos,\n\t\t\t\tu32 len, u32 phys,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\n\ttrace_ocfs2_mark_extent_refcounted(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\t   cpos, len, phys);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tret = ocfs2_error(inode->i_sb, \"Inode %lu want to use refcount tree, but the feature bit is not set in the super block\\n\",\n\t\t\t\t  inode->i_ino);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_change_extent_flag(handle, et, cpos,\n\t\t\t\t       len, phys, meta_ac, dealloc,\n\t\t\t\t       OCFS2_EXT_REFCOUNTED, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}\n\n \nstatic int ocfs2_calc_refcount_meta_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t\t\t    u64 start_cpos,\n\t\t\t\t\t    u32 clusters,\n\t\t\t\t\t    int *meta_add,\n\t\t\t\t\t    int *credits)\n{\n\tint ret = 0, index, ref_blocks = 0, recs_add = 0;\n\tu64 cpos = start_cpos;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_rec rec;\n\tstruct buffer_head *ref_leaf_bh = NULL, *prev_bh = NULL;\n\tu32 len;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, clusters, &rec,\n\t\t\t\t\t     &index, &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ref_leaf_bh != prev_bh) {\n\t\t\t \n\t\t\tif (prev_bh) {\n\t\t\t\trb = (struct ocfs2_refcount_block *)\n\t\t\t\t\t\t\tprev_bh->b_data;\n\n\t\t\t\tif (le16_to_cpu(rb->rf_records.rl_used) +\n\t\t\t\t    recs_add >\n\t\t\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\t\t\tref_blocks++;\n\t\t\t}\n\n\t\t\trecs_add = 0;\n\t\t\t*credits += 1;\n\t\t\tbrelse(prev_bh);\n\t\t\tprev_bh = ref_leaf_bh;\n\t\t\tget_bh(prev_bh);\n\t\t}\n\n\t\ttrace_ocfs2_calc_refcount_meta_credits_iterate(\n\t\t\t\trecs_add, (unsigned long long)cpos, clusters,\n\t\t\t\t(unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t\tle32_to_cpu(rec.r_clusters),\n\t\t\t\tle32_to_cpu(rec.r_refcount), index);\n\n\t\tlen = min((u64)cpos + clusters, le64_to_cpu(rec.r_cpos) +\n\t\t\t  le32_to_cpu(rec.r_clusters)) - cpos;\n\t\t \n\t\tif (rec.r_refcount) {\n\t\t\trecs_add += 2;\n\t\t\t \n\t\t\tif (cpos == start_cpos &&\n\t\t\t    cpos != le64_to_cpu(rec.r_cpos))\n\t\t\t\trecs_add++;\n\n\t\t\t \n\t\t\tif (cpos + clusters < le64_to_cpu(rec.r_cpos) +\n\t\t\t    le32_to_cpu(rec.r_clusters))\n\t\t\t\trecs_add++;\n\t\t} else\n\t\t\trecs_add++;\n\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t\tclusters -= len;\n\t\tcpos += len;\n\t}\n\n\tif (prev_bh) {\n\t\trb = (struct ocfs2_refcount_block *)prev_bh->b_data;\n\n\t\tif (le16_to_cpu(rb->rf_records.rl_used) + recs_add >\n\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\tref_blocks++;\n\n\t\t*credits += 1;\n\t}\n\n\tif (!ref_blocks)\n\t\tgoto out;\n\n\t*meta_add += ref_blocks;\n\t*credits += ref_blocks;\n\n\t \n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL) {\n\t\tstruct ocfs2_extent_tree et;\n\n\t\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\t\t*meta_add += ocfs2_extend_meta_needed(et.et_root_el);\n\t\t*credits += ocfs2_calc_extend_credits(sb,\n\t\t\t\t\t\t      et.et_root_el);\n\t} else {\n\t\t*credits += OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\t\t*meta_add += 1;\n\t}\n\nout:\n\n\ttrace_ocfs2_calc_refcount_meta_credits(\n\t\t(unsigned long long)start_cpos, clusters,\n\t\t*meta_add, *credits);\n\tbrelse(ref_leaf_bh);\n\tbrelse(prev_bh);\n\treturn ret;\n}\n\n \nint ocfs2_prepare_refcount_change_for_del(struct inode *inode,\n\t\t\t\t\t  u64 refcount_loc,\n\t\t\t\t\t  u64 phys_blkno,\n\t\t\t\t\t  u32 clusters,\n\t\t\t\t\t  int *credits,\n\t\t\t\t\t  int *ref_blocks)\n{\n\tint ret;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\tu64 start_cpos = ocfs2_blocks_to_clusters(inode->i_sb, phys_blkno);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tret = ocfs2_error(inode->i_sb, \"Inode %lu want to use refcount tree, but the feature bit is not set in the super block\\n\",\n\t\t\t\t  inode->i_ino);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!ocfs2_is_refcount_inode(inode));\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb),\n\t\t\t\t      refcount_loc, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, refcount_loc,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\n\t\t\t\t\t       &tree->rf_ci,\n\t\t\t\t\t       ref_root_bh,\n\t\t\t\t\t       start_cpos, clusters,\n\t\t\t\t\t       ref_blocks, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_prepare_refcount_change_for_del(*ref_blocks, *credits);\n\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}\n\n#define\tMAX_CONTIG_BYTES\t1048576\n\nstatic inline unsigned int ocfs2_cow_contig_clusters(struct super_block *sb)\n{\n\treturn ocfs2_clusters_for_bytes(sb, MAX_CONTIG_BYTES);\n}\n\nstatic inline unsigned int ocfs2_cow_contig_mask(struct super_block *sb)\n{\n\treturn ~(ocfs2_cow_contig_clusters(sb) - 1);\n}\n\n \nstatic inline unsigned int ocfs2_cow_align_start(struct super_block *sb,\n\t\t\t\t\t\t unsigned int start,\n\t\t\t\t\t\t unsigned int cpos)\n{\n\tBUG_ON(start > cpos);\n\n\treturn start + ((cpos - start) & ocfs2_cow_contig_mask(sb));\n}\n\n \nstatic inline unsigned int ocfs2_cow_align_length(struct super_block *sb,\n\t\t\t\t\t\t  unsigned int len)\n{\n\tunsigned int padded =\n\t\t(len + (ocfs2_cow_contig_clusters(sb) - 1)) &\n\t\tocfs2_cow_contig_mask(sb);\n\n\t \n\tif (padded < len)\n\t\tpadded = UINT_MAX;\n\n\treturn padded;\n}\n\n \nstatic int ocfs2_refcount_cal_cow_clusters(struct inode *inode,\n\t\t\t\t\t   struct ocfs2_extent_list *el,\n\t\t\t\t\t   u32 cpos,\n\t\t\t\t\t   u32 write_len,\n\t\t\t\t\t   u32 max_cpos,\n\t\t\t\t\t   u32 *cow_start,\n\t\t\t\t\t   u32 *cow_len)\n{\n\tint ret = 0;\n\tint tree_height = le16_to_cpu(el->l_tree_depth), i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct ocfs2_extent_rec *rec;\n\tunsigned int want_clusters, rec_end = 0;\n\tint contig_clusters = ocfs2_cow_contig_clusters(inode->i_sb);\n\tint leaf_clusters;\n\n\tBUG_ON(cpos + write_len > max_cpos);\n\n\tif (tree_height > 0) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tret = ocfs2_error(inode->i_sb,\n\t\t\t\t\t  \"Inode %lu has non zero tree depth in leaf block %llu\\n\",\n\t\t\t\t\t  inode->i_ino,\n\t\t\t\t\t  (unsigned long long)eb_bh->b_blocknr);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*cow_len = 0;\n\tfor (i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (ocfs2_is_empty_extent(rec)) {\n\t\t\tmlog_bug_on_msg(i != 0, \"Inode %lu has empty record in \"\n\t\t\t\t\t\"index %d\\n\", inode->i_ino, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (le32_to_cpu(rec->e_cpos) +\n\t\t    le16_to_cpu(rec->e_leaf_clusters) <= cpos)\n\t\t\tcontinue;\n\n\t\tif (*cow_len == 0) {\n\t\t\t \n\t\t\tBUG_ON(!(rec->e_flags & OCFS2_EXT_REFCOUNTED));\n\t\t\t*cow_start = le32_to_cpu(rec->e_cpos);\n\t\t}\n\n\t\t \n\t\tif ((!(rec->e_flags & OCFS2_EXT_REFCOUNTED)) ||\n\t\t    (*cow_len && rec_end != le32_to_cpu(rec->e_cpos)) ||\n\t\t    (max_cpos <= le32_to_cpu(rec->e_cpos)))\n\t\t\tbreak;\n\n\t\tleaf_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\t\trec_end = le32_to_cpu(rec->e_cpos) + leaf_clusters;\n\t\tif (rec_end > max_cpos) {\n\t\t\trec_end = max_cpos;\n\t\t\tleaf_clusters = rec_end - le32_to_cpu(rec->e_cpos);\n\t\t}\n\n\t\t \n\t\tif (!*cow_len)\n\t\t\twant_clusters = write_len;\n\t\telse\n\t\t\twant_clusters = (cpos + write_len) -\n\t\t\t\t(*cow_start + *cow_len);\n\t\tif (want_clusters < contig_clusters)\n\t\t\twant_clusters = contig_clusters;\n\n\t\t \n\t\tif (leaf_clusters <= contig_clusters)\n\t\t\t*cow_len += leaf_clusters;\n\t\telse if (*cow_len || (*cow_start == cpos)) {\n\t\t\t \n\t\t\twant_clusters = ocfs2_cow_align_length(inode->i_sb,\n\t\t\t\t\t\t\t       want_clusters);\n\n\t\t\tif (leaf_clusters < want_clusters)\n\t\t\t\t*cow_len += leaf_clusters;\n\t\t\telse\n\t\t\t\t*cow_len += want_clusters;\n\t\t} else if ((*cow_start + contig_clusters) >=\n\t\t\t   (cpos + write_len)) {\n\t\t\t \n\t\t\t*cow_len = contig_clusters;\n\t\t} else if ((rec_end - cpos) <= contig_clusters) {\n\t\t\t \n\t\t\t*cow_start = rec_end - contig_clusters;\n\t\t\t*cow_len = contig_clusters;\n\t\t} else if ((rec_end - cpos) <= want_clusters) {\n\t\t\t \n\t\t\t*cow_start = ocfs2_cow_align_start(inode->i_sb,\n\t\t\t\t\t\t\t   *cow_start, cpos);\n\t\t\t*cow_len = rec_end - *cow_start;\n\t\t} else {\n\t\t\t \n\t\t\t*cow_start = ocfs2_cow_align_start(inode->i_sb,\n\t\t\t\t\t\t\t   *cow_start, cpos);\n\n\t\t\twant_clusters = (cpos + write_len) - *cow_start;\n\t\t\twant_clusters = ocfs2_cow_align_length(inode->i_sb,\n\t\t\t\t\t\t\t       want_clusters);\n\t\t\tif (*cow_start + want_clusters <= rec_end)\n\t\t\t\t*cow_len = want_clusters;\n\t\t\telse\n\t\t\t\t*cow_len = rec_end - *cow_start;\n\t\t}\n\n\t\t \n\t\tif ((*cow_start + *cow_len) >= (cpos + write_len))\n\t\t\tbreak;\n\n\t\t \n\t\tif (i + 1 == le16_to_cpu(el->l_next_free_rec) &&\n\t\t    eb && eb->h_next_leaf_blk) {\n\t\t\tbrelse(eb_bh);\n\t\t\teb_bh = NULL;\n\n\t\t\tret = ocfs2_read_extent_block(INODE_CACHE(inode),\n\t\t\t\t\t       le64_to_cpu(eb->h_next_leaf_blk),\n\t\t\t\t\t       &eb_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\t\tel = &eb->h_list;\n\t\t\ti = -1;\n\t\t}\n\t}\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}\n\n \nstatic int ocfs2_lock_refcount_allocators(struct super_block *sb,\n\t\t\t\t\tu32 p_cluster, u32 num_clusters,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tstruct ocfs2_alloc_context **data_ac,\n\t\t\t\t\tint *credits)\n{\n\tint ret = 0, meta_add = 0;\n\tint num_free_extents = ocfs2_num_free_extents(et);\n\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (num_free_extents < num_clusters + 2)\n\t\tmeta_add =\n\t\t\tocfs2_extend_meta_needed(et->et_root_el);\n\n\t*credits += ocfs2_calc_extend_credits(sb, et->et_root_el);\n\n\tret = ocfs2_calc_refcount_meta_credits(sb, ref_ci, ref_root_bh,\n\t\t\t\t\t       p_cluster, num_clusters,\n\t\t\t\t\t       &meta_add, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_lock_refcount_allocators(meta_add, *credits);\n\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(sb), meta_add,\n\t\t\t\t\t\tmeta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (data_ac) {\n\t\tret = ocfs2_reserve_clusters(OCFS2_SB(sb), num_clusters,\n\t\t\t\t\t     data_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int ocfs2_clear_cow_buffer(handle_t *handle, struct buffer_head *bh)\n{\n\tBUG_ON(buffer_dirty(bh));\n\n\tclear_buffer_mapped(bh);\n\n\treturn 0;\n}\n\nint ocfs2_duplicate_clusters_by_page(handle_t *handle,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     u32 cpos, u32 old_cluster,\n\t\t\t\t     u32 new_cluster, u32 new_len)\n{\n\tint ret = 0, partial;\n\tstruct super_block *sb = inode->i_sb;\n\tu64 new_block = ocfs2_clusters_to_blocks(sb, new_cluster);\n\tstruct page *page;\n\tpgoff_t page_index;\n\tunsigned int from, to;\n\tloff_t offset, end, map_end;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\ttrace_ocfs2_duplicate_clusters_by_page(cpos, old_cluster,\n\t\t\t\t\t       new_cluster, new_len);\n\n\toffset = ((loff_t)cpos) << OCFS2_SB(sb)->s_clustersize_bits;\n\tend = offset + (new_len << OCFS2_SB(sb)->s_clustersize_bits);\n\t \n\tif (end > i_size_read(inode))\n\t\tend = i_size_read(inode);\n\n\twhile (offset < end) {\n\t\tpage_index = offset >> PAGE_SHIFT;\n\t\tmap_end = ((loff_t)page_index + 1) << PAGE_SHIFT;\n\t\tif (map_end > end)\n\t\t\tmap_end = end;\n\n\t\t \n\t\tfrom = offset & (PAGE_SIZE - 1);\n\t\tto = PAGE_SIZE;\n\t\tif (map_end & (PAGE_SIZE - 1))\n\t\t\tto = map_end & (PAGE_SIZE - 1);\n\nretry:\n\t\tpage = find_or_create_page(mapping, page_index, GFP_NOFS);\n\t\tif (!page) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (PAGE_SIZE <= OCFS2_SB(sb)->s_clustersize) {\n\t\t\tif (PageDirty(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page);\n\n\t\t\t\tret = filemap_write_and_wait_range(mapping,\n\t\t\t\t\t\toffset, map_end - 1);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tstruct folio *folio = page_folio(page);\n\n\t\t\tret = block_read_full_folio(folio, ocfs2_get_block);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tfolio_lock(folio);\n\t\t}\n\n\t\tif (page_has_buffers(page)) {\n\t\t\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\t\t\tfrom, to, &partial,\n\t\t\t\t\t\tocfs2_clear_cow_buffer);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\n\t\tocfs2_map_and_dirty_page(inode,\n\t\t\t\t\t handle, from, to,\n\t\t\t\t\t page, 0, &new_block);\n\t\tmark_page_accessed(page);\nunlock:\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\t\toffset = map_end;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nint ocfs2_duplicate_clusters_by_jbd(handle_t *handle,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    u32 cpos, u32 old_cluster,\n\t\t\t\t    u32 new_cluster, u32 new_len)\n{\n\tint ret = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ocfs2_caching_info *ci = INODE_CACHE(inode);\n\tint i, blocks = ocfs2_clusters_to_blocks(sb, new_len);\n\tu64 old_block = ocfs2_clusters_to_blocks(sb, old_cluster);\n\tu64 new_block = ocfs2_clusters_to_blocks(sb, new_cluster);\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tstruct buffer_head *old_bh = NULL;\n\tstruct buffer_head *new_bh = NULL;\n\n\ttrace_ocfs2_duplicate_clusters_by_page(cpos, old_cluster,\n\t\t\t\t\t       new_cluster, new_len);\n\n\tfor (i = 0; i < blocks; i++, old_block++, new_block++) {\n\t\tnew_bh = sb_getblk(osb->sb, new_block);\n\t\tif (new_bh == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_set_new_buffer_uptodate(ci, new_bh);\n\n\t\tret = ocfs2_read_block(ci, old_block, &old_bh, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_journal_access(handle, ci, new_bh,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(new_bh->b_data, old_bh->b_data, sb->s_blocksize);\n\t\tocfs2_journal_dirty(handle, new_bh);\n\n\t\tbrelse(new_bh);\n\t\tbrelse(old_bh);\n\t\tnew_bh = NULL;\n\t\told_bh = NULL;\n\t}\n\n\tbrelse(new_bh);\n\tbrelse(old_bh);\n\treturn ret;\n}\n\nstatic int ocfs2_clear_ext_refcount(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    u32 cpos, u32 p_cluster, u32 len,\n\t\t\t\t    unsigned int ext_flags,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tstruct ocfs2_extent_rec replace_rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tu64 ino = ocfs2_metadata_cache_owner(et->et_ci);\n\n\ttrace_ocfs2_clear_ext_refcount((unsigned long long)ino,\n\t\t\t\t       cpos, len, p_cluster, ext_flags);\n\n\tmemset(&replace_rec, 0, sizeof(replace_rec));\n\treplace_rec.e_cpos = cpu_to_le32(cpos);\n\treplace_rec.e_leaf_clusters = cpu_to_le16(len);\n\treplace_rec.e_blkno = cpu_to_le64(ocfs2_clusters_to_blocks(sb,\n\t\t\t\t\t\t\t\t   p_cluster));\n\treplace_rec.e_flags = ext_flags;\n\treplace_rec.e_flags &= ~OCFS2_EXT_REFCOUNTED;\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tret = ocfs2_error(sb,\n\t\t\t\t  \"Inode %llu has an extent at cpos %u which can no longer be found\\n\",\n\t\t\t\t  (unsigned long long)ino, cpos);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_split_extent(handle, et, path, index,\n\t\t\t\t &replace_rec, meta_ac, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}\n\nstatic int ocfs2_replace_clusters(handle_t *handle,\n\t\t\t\t  struct ocfs2_cow_context *context,\n\t\t\t\t  u32 cpos, u32 old,\n\t\t\t\t  u32 new, u32 len,\n\t\t\t\t  unsigned int ext_flags)\n{\n\tint ret;\n\tstruct ocfs2_caching_info *ci = context->data_et.et_ci;\n\tu64 ino = ocfs2_metadata_cache_owner(ci);\n\n\ttrace_ocfs2_replace_clusters((unsigned long long)ino,\n\t\t\t\t     cpos, old, new, len, ext_flags);\n\n\t \n\tif (!(ext_flags & OCFS2_EXT_UNWRITTEN)) {\n\t\tret = context->cow_duplicate_clusters(handle, context->inode,\n\t\t\t\t\t\t      cpos, old, new, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_clear_ext_refcount(handle, &context->data_et,\n\t\t\t\t       cpos, new, len, ext_flags,\n\t\t\t\t       context->meta_ac, &context->dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\treturn ret;\n}\n\nint ocfs2_cow_sync_writeback(struct super_block *sb,\n\t\t\t     struct inode *inode,\n\t\t\t     u32 cpos, u32 num_clusters)\n{\n\tint ret;\n\tloff_t start, end;\n\n\tif (ocfs2_should_order_data(inode))\n\t\treturn 0;\n\n\tstart = ((loff_t)cpos) << OCFS2_SB(sb)->s_clustersize_bits;\n\tend = start + (num_clusters << OCFS2_SB(sb)->s_clustersize_bits) - 1;\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}\n\nstatic int ocfs2_di_get_clusters(struct ocfs2_cow_context *context,\n\t\t\t\t u32 v_cluster, u32 *p_cluster,\n\t\t\t\t u32 *num_clusters,\n\t\t\t\t unsigned int *extent_flags)\n{\n\treturn ocfs2_get_clusters(context->inode, v_cluster, p_cluster,\n\t\t\t\t  num_clusters, extent_flags);\n}\n\nstatic int ocfs2_make_clusters_writable(struct super_block *sb,\n\t\t\t\t\tstruct ocfs2_cow_context *context,\n\t\t\t\t\tu32 cpos, u32 p_cluster,\n\t\t\t\t\tu32 num_clusters, unsigned int e_flags)\n{\n\tint ret, delete, index, credits =  0;\n\tu32 new_bit, new_len, orig_num_clusters;\n\tunsigned int set_len;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\thandle_t *handle;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\tstruct ocfs2_caching_info *ref_ci = &context->ref_tree->rf_ci;\n\tstruct ocfs2_refcount_rec rec;\n\n\ttrace_ocfs2_make_clusters_writable(cpos, p_cluster,\n\t\t\t\t\t   num_clusters, e_flags);\n\n\tret = ocfs2_lock_refcount_allocators(sb, p_cluster, num_clusters,\n\t\t\t\t\t     &context->data_et,\n\t\t\t\t\t     ref_ci,\n\t\t\t\t\t     context->ref_root_bh,\n\t\t\t\t\t     &context->meta_ac,\n\t\t\t\t\t     &context->data_ac, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tif (context->post_refcount)\n\t\tcredits += context->post_refcount->credits;\n\n\tcredits += context->extra_credits;\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\torig_num_clusters = num_clusters;\n\n\twhile (num_clusters) {\n\t\tret = ocfs2_get_refcount_rec(ref_ci, context->ref_root_bh,\n\t\t\t\t\t     p_cluster, num_clusters,\n\t\t\t\t\t     &rec, &index, &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tBUG_ON(!rec.r_refcount);\n\t\tset_len = min((u64)p_cluster + num_clusters,\n\t\t\t      le64_to_cpu(rec.r_cpos) +\n\t\t\t      le32_to_cpu(rec.r_clusters)) - p_cluster;\n\n\t\t \n\t\tif (le32_to_cpu(rec.r_refcount) == 1) {\n\t\t\tdelete = 0;\n\t\t\tret = ocfs2_clear_ext_refcount(handle,\n\t\t\t\t\t\t       &context->data_et,\n\t\t\t\t\t\t       cpos, p_cluster,\n\t\t\t\t\t\t       set_len, e_flags,\n\t\t\t\t\t\t       context->meta_ac,\n\t\t\t\t\t\t       &context->dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t} else {\n\t\t\tdelete = 1;\n\n\t\t\tret = __ocfs2_claim_clusters(handle,\n\t\t\t\t\t\t     context->data_ac,\n\t\t\t\t\t\t     1, set_len,\n\t\t\t\t\t\t     &new_bit, &new_len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\n\t\t\tret = ocfs2_replace_clusters(handle, context,\n\t\t\t\t\t\t     cpos, p_cluster, new_bit,\n\t\t\t\t\t\t     new_len, e_flags);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t\tset_len = new_len;\n\t\t}\n\n\t\tret = __ocfs2_decrease_refcount(handle, ref_ci,\n\t\t\t\t\t\tcontext->ref_root_bh,\n\t\t\t\t\t\tp_cluster, set_len,\n\t\t\t\t\t\tcontext->meta_ac,\n\t\t\t\t\t\t&context->dealloc, delete);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tcpos += set_len;\n\t\tp_cluster += set_len;\n\t\tnum_clusters -= set_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\n\t \n\tif (context->post_refcount && context->post_refcount->func) {\n\t\tret = context->post_refcount->func(context->inode, handle,\n\t\t\t\t\t\tcontext->post_refcount->para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\t \n\tif (context->get_clusters == ocfs2_di_get_clusters) {\n\t\tret = ocfs2_cow_sync_writeback(sb, context->inode, cpos,\n\t\t\t\t\t       orig_num_clusters);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (context->data_ac) {\n\t\tocfs2_free_alloc_context(context->data_ac);\n\t\tcontext->data_ac = NULL;\n\t}\n\tif (context->meta_ac) {\n\t\tocfs2_free_alloc_context(context->meta_ac);\n\t\tcontext->meta_ac = NULL;\n\t}\n\tbrelse(ref_leaf_bh);\n\n\treturn ret;\n}\n\nstatic int ocfs2_replace_cow(struct ocfs2_cow_context *context)\n{\n\tint ret = 0;\n\tstruct inode *inode = context->inode;\n\tu32 cow_start = context->cow_start, cow_len = context->cow_len;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (!ocfs2_refcount_tree(osb)) {\n\t\treturn ocfs2_error(inode->i_sb, \"Inode %lu want to use refcount tree, but the feature bit is not set in the super block\\n\",\n\t\t\t\t   inode->i_ino);\n\t}\n\n\tocfs2_init_dealloc_ctxt(&context->dealloc);\n\n\twhile (cow_len) {\n\t\tret = context->get_clusters(context, cow_start, &p_cluster,\n\t\t\t\t\t    &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tBUG_ON(!(ext_flags & OCFS2_EXT_REFCOUNTED));\n\n\t\tif (cow_len < num_clusters)\n\t\t\tnum_clusters = cow_len;\n\n\t\tret = ocfs2_make_clusters_writable(inode->i_sb, context,\n\t\t\t\t\t\t   cow_start, p_cluster,\n\t\t\t\t\t\t   num_clusters, ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tcow_len -= num_clusters;\n\t\tcow_start += num_clusters;\n\t}\n\n\tif (ocfs2_dealloc_has_cluster(&context->dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\t\tocfs2_run_deallocs(osb, &context->dealloc);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_refcount_cow_hunk(struct inode *inode,\n\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t   u32 cpos, u32 write_len, u32 max_cpos)\n{\n\tint ret;\n\tu32 cow_start = 0, cow_len = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tstruct ocfs2_cow_context *context = NULL;\n\n\tBUG_ON(!ocfs2_is_refcount_inode(inode));\n\n\tret = ocfs2_refcount_cal_cow_clusters(inode, &di->id2.i_list,\n\t\t\t\t\t      cpos, write_len, max_cpos,\n\t\t\t\t\t      &cow_start, &cow_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_refcount_cow_hunk(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t      cpos, write_len, max_cpos,\n\t\t\t\t      cow_start, cow_len);\n\n\tBUG_ON(cow_len == 0);\n\n\tcontext = kzalloc(sizeof(struct ocfs2_cow_context), GFP_NOFS);\n\tif (!context) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_lock_refcount_tree(osb, le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcontext->inode = inode;\n\tcontext->cow_start = cow_start;\n\tcontext->cow_len = cow_len;\n\tcontext->ref_tree = ref_tree;\n\tcontext->ref_root_bh = ref_root_bh;\n\tcontext->cow_duplicate_clusters = ocfs2_duplicate_clusters_by_page;\n\tcontext->get_clusters = ocfs2_di_get_clusters;\n\n\tocfs2_init_dinode_extent_tree(&context->data_et,\n\t\t\t\t      INODE_CACHE(inode), di_bh);\n\n\tret = ocfs2_replace_cow(context);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\t \n\tocfs2_extent_map_trunc(inode, cow_start);\n\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\nout:\n\tkfree(context);\n\treturn ret;\n}\n\n \nint ocfs2_refcount_cow(struct inode *inode,\n\t\t       struct buffer_head *di_bh,\n\t\t       u32 cpos, u32 write_len, u32 max_cpos)\n{\n\tint ret = 0;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\n\twhile (write_len) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write_len < num_clusters)\n\t\t\tnum_clusters = write_len;\n\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED) {\n\t\t\tret = ocfs2_refcount_cow_hunk(inode, di_bh, cpos,\n\t\t\t\t\t\t      num_clusters, max_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twrite_len -= num_clusters;\n\t\tcpos += num_clusters;\n\t}\n\n\treturn ret;\n}\n\nstatic int ocfs2_xattr_value_get_clusters(struct ocfs2_cow_context *context,\n\t\t\t\t\t  u32 v_cluster, u32 *p_cluster,\n\t\t\t\t\t  u32 *num_clusters,\n\t\t\t\t\t  unsigned int *extent_flags)\n{\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_xattr_value_root *xv = context->cow_object;\n\n\treturn ocfs2_xattr_get_clusters(inode, v_cluster, p_cluster,\n\t\t\t\t\tnum_clusters, &xv->xr_list,\n\t\t\t\t\textent_flags);\n}\n\n \nint ocfs2_refcounted_xattr_delete_need(struct inode *inode,\n\t\t\t\t       struct ocfs2_caching_info *ref_ci,\n\t\t\t\t       struct buffer_head *ref_root_bh,\n\t\t\t\t       struct ocfs2_xattr_value_root *xv,\n\t\t\t\t       int *meta_add, int *credits)\n{\n\tint ret = 0, index, ref_blocks = 0;\n\tu32 p_cluster, num_clusters;\n\tu32 cpos = 0, clusters = le32_to_cpu(xv->xr_clusters);\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_rec rec;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, &xv->xr_list,\n\t\t\t\t\t       NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcpos += num_clusters;\n\n\t\twhile (num_clusters) {\n\t\t\tret = ocfs2_get_refcount_rec(ref_ci, ref_root_bh,\n\t\t\t\t\t\t     p_cluster, num_clusters,\n\t\t\t\t\t\t     &rec, &index,\n\t\t\t\t\t\t     &ref_leaf_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUG_ON(!rec.r_refcount);\n\n\t\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\n\t\t\t \n\t\t\tif (le16_to_cpu(rb->rf_records.rl_used) + clusters * 2 >\n\t\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\t\tref_blocks++;\n\n\t\t\t*credits += 1;\n\t\t\tbrelse(ref_leaf_bh);\n\t\t\tref_leaf_bh = NULL;\n\n\t\t\tif (num_clusters <= le32_to_cpu(rec.r_clusters))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tnum_clusters -= le32_to_cpu(rec.r_clusters);\n\t\t\tp_cluster += num_clusters;\n\t\t}\n\t}\n\n\t*meta_add += ref_blocks;\n\tif (!ref_blocks)\n\t\tgoto out;\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\telse {\n\t\tstruct ocfs2_extent_tree et;\n\n\t\tocfs2_init_refcount_extent_tree(&et, ref_ci, ref_root_bh);\n\t\t*credits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t      et.et_root_el);\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}\n\n \nint ocfs2_refcount_cow_xattr(struct inode *inode,\n\t\t\t     struct ocfs2_dinode *di,\n\t\t\t     struct ocfs2_xattr_value_buf *vb,\n\t\t\t     struct ocfs2_refcount_tree *ref_tree,\n\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t     u32 cpos, u32 write_len,\n\t\t\t     struct ocfs2_post_refcount *post)\n{\n\tint ret;\n\tstruct ocfs2_xattr_value_root *xv = vb->vb_xv;\n\tstruct ocfs2_cow_context *context = NULL;\n\tu32 cow_start, cow_len;\n\n\tBUG_ON(!ocfs2_is_refcount_inode(inode));\n\n\tret = ocfs2_refcount_cal_cow_clusters(inode, &xv->xr_list,\n\t\t\t\t\t      cpos, write_len, UINT_MAX,\n\t\t\t\t\t      &cow_start, &cow_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(cow_len == 0);\n\n\tcontext = kzalloc(sizeof(struct ocfs2_cow_context), GFP_NOFS);\n\tif (!context) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcontext->inode = inode;\n\tcontext->cow_start = cow_start;\n\tcontext->cow_len = cow_len;\n\tcontext->ref_tree = ref_tree;\n\tcontext->ref_root_bh = ref_root_bh;\n\tcontext->cow_object = xv;\n\n\tcontext->cow_duplicate_clusters = ocfs2_duplicate_clusters_by_jbd;\n\t \n\tcontext->extra_credits =\n\t\tocfs2_clusters_to_blocks(inode->i_sb, 1) * cow_len;\n\tcontext->get_clusters = ocfs2_xattr_value_get_clusters;\n\tcontext->post_refcount = post;\n\n\tocfs2_init_xattr_value_extent_tree(&context->data_et,\n\t\t\t\t\t   INODE_CACHE(inode), vb);\n\n\tret = ocfs2_replace_cow(context);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tkfree(context);\n\treturn ret;\n}\n\n \nint ocfs2_add_refcount_flag(struct inode *inode,\n\t\t\t    struct ocfs2_extent_tree *data_et,\n\t\t\t    struct ocfs2_caching_info *ref_ci,\n\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t    u32 cpos, u32 p_cluster, u32 num_clusters,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t    struct ocfs2_post_refcount *post)\n{\n\tint ret;\n\thandle_t *handle;\n\tint credits = 1, ref_blocks = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\n\t \n\tref_blocks = ocfs2_extend_meta_needed(data_et->et_root_el);\n\n\tret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\n\t\t\t\t\t       ref_ci, ref_root_bh,\n\t\t\t\t\t       p_cluster, num_clusters,\n\t\t\t\t\t       &ref_blocks, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_add_refcount_flag(ref_blocks, credits);\n\n\tif (ref_blocks) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb,\n\t\t\t\t\t\t\tref_blocks, &meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (post)\n\t\tcredits += post->credits;\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_mark_extent_refcounted(inode, data_et, handle,\n\t\t\t\t\t   cpos, num_clusters, p_cluster,\n\t\t\t\t\t   meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = __ocfs2_increase_refcount(handle, ref_ci, ref_root_bh,\n\t\t\t\t\tp_cluster, num_clusters, 0,\n\t\t\t\t\tmeta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (post && post->func) {\n\t\tret = post->func(inode, handle, post->para);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}\n\nstatic int ocfs2_change_ctime(struct inode *inode,\n\t\t\t      struct buffer_head *di_bh)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(inode->i_sb),\n\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tinode_set_ctime_current(inode);\n\tdi->i_ctime = cpu_to_le64(inode_get_ctime(inode).tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode_get_ctime(inode).tv_nsec);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_attach_refcount_tree(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh)\n{\n\tint ret, data_changed = 0;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tunsigned int ext_flags;\n\tloff_t size;\n\tu32 cpos, num_clusters, clusters, p_cluster;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_extent_tree di_et;\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tif (!ocfs2_is_refcount_inode(inode)) {\n\t\tret = ocfs2_create_refcount_tree(inode, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tBUG_ON(!di->i_refcount_loc);\n\tret = ocfs2_lock_refcount_tree(osb,\n\t\t\t\t       le64_to_cpu(di->i_refcount_loc), 1,\n\t\t\t\t       &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tgoto attach_xattr;\n\n\tocfs2_init_dinode_extent_tree(&di_et, INODE_CACHE(inode), di_bh);\n\n\tsize = i_size_read(inode);\n\tclusters = ocfs2_clusters_for_bytes(inode->i_sb, size);\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (p_cluster && !(ext_flags & OCFS2_EXT_REFCOUNTED)) {\n\t\t\tret = ocfs2_add_refcount_flag(inode, &di_et,\n\t\t\t\t\t\t      &ref_tree->rf_ci,\n\t\t\t\t\t\t      ref_root_bh, cpos,\n\t\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t\t      &dealloc, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tdata_changed = 1;\n\t\t}\n\t\tcpos += num_clusters;\n\t}\n\nattach_xattr:\n\tif (oi->ip_dyn_features & OCFS2_HAS_XATTR_FL) {\n\t\tret = ocfs2_xattr_attach_refcount_tree(inode, di_bh,\n\t\t\t\t\t\t       &ref_tree->rf_ci,\n\t\t\t\t\t\t       ref_root_bh,\n\t\t\t\t\t\t       &dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tif (data_changed) {\n\t\tret = ocfs2_change_ctime(inode, di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nunlock:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\n\n\tif (!ret && ocfs2_dealloc_has_cluster(&dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\t\tocfs2_run_deallocs(osb, &dealloc);\n\t}\nout:\n\t \n\tocfs2_extent_map_trunc(inode, 0);\n\n\treturn ret;\n}\n\nstatic int ocfs2_add_refcounted_extent(struct inode *inode,\n\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ref_ci,\n\t\t\t\t   struct buffer_head *ref_root_bh,\n\t\t\t\t   u32 cpos, u32 p_cluster, u32 num_clusters,\n\t\t\t\t   unsigned int ext_flags,\n\t\t\t\t   struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\thandle_t *handle;\n\tint credits = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\n\tret = ocfs2_lock_refcount_allocators(inode->i_sb,\n\t\t\t\t\t     p_cluster, num_clusters,\n\t\t\t\t\t     et, ref_ci,\n\t\t\t\t\t     ref_root_bh, &meta_ac,\n\t\t\t\t\t     NULL, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_insert_extent(handle, et, cpos,\n\t\t\tocfs2_clusters_to_blocks(inode->i_sb, p_cluster),\n\t\t\tnum_clusters, ext_flags, meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_increase_refcount(handle, ref_ci, ref_root_bh,\n\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t      meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = dquot_alloc_space_nodirty(inode,\n\t\tocfs2_clusters_to_bytes(osb->sb, num_clusters));\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}\n\nstatic int ocfs2_duplicate_inline_data(struct inode *s_inode,\n\t\t\t\t       struct buffer_head *s_bh,\n\t\t\t\t       struct inode *t_inode,\n\t\t\t\t       struct buffer_head *t_bh)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(s_inode->i_sb);\n\tstruct ocfs2_dinode *s_di = (struct ocfs2_dinode *)s_bh->b_data;\n\tstruct ocfs2_dinode *t_di = (struct ocfs2_dinode *)t_bh->b_data;\n\n\tBUG_ON(!(OCFS2_I(s_inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL));\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(t_inode), t_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tt_di->id2.i_data.id_count = s_di->id2.i_data.id_count;\n\tmemcpy(t_di->id2.i_data.id_data, s_di->id2.i_data.id_data,\n\t       le16_to_cpu(s_di->id2.i_data.id_count));\n\tspin_lock(&OCFS2_I(t_inode)->ip_lock);\n\tOCFS2_I(t_inode)->ip_dyn_features |= OCFS2_INLINE_DATA_FL;\n\tt_di->i_dyn_features = cpu_to_le16(OCFS2_I(t_inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(t_inode)->ip_lock);\n\n\tocfs2_journal_dirty(handle, t_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_duplicate_extent_list(struct inode *s_inode,\n\t\t\t\tstruct inode *t_inode,\n\t\t\t\tstruct buffer_head *t_bh,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tu32 p_cluster, num_clusters, clusters, cpos;\n\tloff_t size;\n\tunsigned int ext_flags;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(t_inode), t_bh);\n\n\tsize = i_size_read(s_inode);\n\tclusters = ocfs2_clusters_for_bytes(s_inode->i_sb, size);\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_get_clusters(s_inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tif (p_cluster) {\n\t\t\tret = ocfs2_add_refcounted_extent(t_inode, &et,\n\t\t\t\t\t\t\t  ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t  cpos, p_cluster,\n\t\t\t\t\t\t\t  num_clusters,\n\t\t\t\t\t\t\t  ext_flags,\n\t\t\t\t\t\t\t  dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += num_clusters;\n\t}\n\nout:\n\treturn ret;\n}\n\n \nstatic int ocfs2_complete_reflink(struct inode *s_inode,\n\t\t\t\t  struct buffer_head *s_bh,\n\t\t\t\t  struct inode *t_inode,\n\t\t\t\t  struct buffer_head *t_bh,\n\t\t\t\t  bool preserve)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_dinode *s_di = (struct ocfs2_dinode *)s_bh->b_data;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)t_bh->b_data;\n\tloff_t size = i_size_read(s_inode);\n\n\thandle = ocfs2_start_trans(OCFS2_SB(t_inode->i_sb),\n\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(t_inode), t_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&OCFS2_I(t_inode)->ip_lock);\n\tOCFS2_I(t_inode)->ip_clusters = OCFS2_I(s_inode)->ip_clusters;\n\tOCFS2_I(t_inode)->ip_attr = OCFS2_I(s_inode)->ip_attr;\n\tOCFS2_I(t_inode)->ip_dyn_features = OCFS2_I(s_inode)->ip_dyn_features;\n\tspin_unlock(&OCFS2_I(t_inode)->ip_lock);\n\ti_size_write(t_inode, size);\n\tt_inode->i_blocks = s_inode->i_blocks;\n\n\tdi->i_xattr_inline_size = s_di->i_xattr_inline_size;\n\tdi->i_clusters = s_di->i_clusters;\n\tdi->i_size = s_di->i_size;\n\tdi->i_dyn_features = s_di->i_dyn_features;\n\tdi->i_attr = s_di->i_attr;\n\n\tif (preserve) {\n\t\tt_inode->i_uid = s_inode->i_uid;\n\t\tt_inode->i_gid = s_inode->i_gid;\n\t\tt_inode->i_mode = s_inode->i_mode;\n\t\tdi->i_uid = s_di->i_uid;\n\t\tdi->i_gid = s_di->i_gid;\n\t\tdi->i_mode = s_di->i_mode;\n\n\t\t \n\t\tinode_set_ctime_current(t_inode);\n\n\t\tdi->i_ctime = cpu_to_le64(inode_get_ctime(t_inode).tv_sec);\n\t\tdi->i_ctime_nsec = cpu_to_le32(inode_get_ctime(t_inode).tv_nsec);\n\n\t\tt_inode->i_mtime = s_inode->i_mtime;\n\t\tdi->i_mtime = s_di->i_mtime;\n\t\tdi->i_mtime_nsec = s_di->i_mtime_nsec;\n\t}\n\n\tocfs2_journal_dirty(handle, t_bh);\n\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(t_inode->i_sb), handle);\n\treturn ret;\n}\n\nstatic int ocfs2_create_reflink_node(struct inode *s_inode,\n\t\t\t\t     struct buffer_head *s_bh,\n\t\t\t\t     struct inode *t_inode,\n\t\t\t\t     struct buffer_head *t_bh,\n\t\t\t\t     bool preserve)\n{\n\tint ret;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_super *osb = OCFS2_SB(s_inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)s_bh->b_data;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tret = ocfs2_set_refcount_tree(t_inode, t_bh,\n\t\t\t\t      le64_to_cpu(di->i_refcount_loc));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(s_inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_duplicate_inline_data(s_inode, s_bh,\n\t\t\t\t\t\t  t_inode, t_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_lock_refcount_tree(osb, le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_duplicate_extent_list(s_inode, t_inode, t_bh,\n\t\t\t\t\t  &ref_tree->rf_ci, ref_root_bh,\n\t\t\t\t\t  &dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_refcount;\n\t}\n\nout_unlock_refcount:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\nout:\n\tif (ocfs2_dealloc_has_cluster(&dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\t\tocfs2_run_deallocs(osb, &dealloc);\n\t}\n\n\treturn ret;\n}\n\nstatic int __ocfs2_reflink(struct dentry *old_dentry,\n\t\t\t   struct buffer_head *old_bh,\n\t\t\t   struct inode *new_inode,\n\t\t\t   bool preserve)\n{\n\tint ret;\n\tstruct inode *inode = d_inode(old_dentry);\n\tstruct buffer_head *new_bh = NULL;\n\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SYSTEM_FILE) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = filemap_fdatawrite(inode->i_mapping);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_attach_refcount_tree(inode, old_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tinode_lock_nested(new_inode, I_MUTEX_CHILD);\n\tret = ocfs2_inode_lock_nested(new_inode, &new_bh, 1,\n\t\t\t\t      OI_LS_REFLINK_TARGET);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_create_reflink_node(inode, old_bh,\n\t\t\t\t\tnew_inode, new_bh, preserve);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto inode_unlock;\n\t}\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_XATTR_FL) {\n\t\tret = ocfs2_reflink_xattrs(inode, old_bh,\n\t\t\t\t\t   new_inode, new_bh,\n\t\t\t\t\t   preserve);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto inode_unlock;\n\t\t}\n\t}\n\n\tret = ocfs2_complete_reflink(inode, old_bh,\n\t\t\t\t     new_inode, new_bh, preserve);\n\tif (ret)\n\t\tmlog_errno(ret);\n\ninode_unlock:\n\tocfs2_inode_unlock(new_inode, 1);\n\tbrelse(new_bh);\nout_unlock:\n\tinode_unlock(new_inode);\nout:\n\tif (!ret) {\n\t\tret = filemap_fdatawait(inode->i_mapping);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\treturn ret;\n}\n\nstatic int ocfs2_reflink(struct dentry *old_dentry, struct inode *dir,\n\t\t\t struct dentry *new_dentry, bool preserve)\n{\n\tint error, had_lock;\n\tstruct inode *inode = d_inode(old_dentry);\n\tstruct buffer_head *old_bh = NULL;\n\tstruct inode *new_orphan_inode = NULL;\n\tstruct ocfs2_lock_holder oh;\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\n\terror = ocfs2_create_inode_in_orphan(dir, inode->i_mode,\n\t\t\t\t\t     &new_orphan_inode);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = ocfs2_rw_lock(inode, 1);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = ocfs2_inode_lock(inode, &old_bh, 1);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\tocfs2_rw_unlock(inode, 1);\n\t\tgoto out;\n\t}\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\terror = __ocfs2_reflink(old_dentry, old_bh,\n\t\t\t\tnew_orphan_inode, preserve);\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tocfs2_inode_unlock(inode, 1);\n\tocfs2_rw_unlock(inode, 1);\n\tbrelse(old_bh);\n\n\tif (error) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\thad_lock = ocfs2_inode_lock_tracker(new_orphan_inode, NULL, 1,\n\t\t\t\t\t    &oh);\n\tif (had_lock < 0) {\n\t\terror = had_lock;\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!preserve) {\n\t\terror = ocfs2_init_security_and_acl(dir, new_orphan_inode,\n\t\t\t\t\t\t    &new_dentry->d_name);\n\t\tif (error)\n\t\t\tmlog_errno(error);\n\t}\n\tif (!error) {\n\t\terror = ocfs2_mv_orphaned_inode_to_new(dir, new_orphan_inode,\n\t\t\t\t\t\t       new_dentry);\n\t\tif (error)\n\t\t\tmlog_errno(error);\n\t}\n\tocfs2_inode_unlock_tracker(new_orphan_inode, 1, &oh, had_lock);\n\nout:\n\tif (new_orphan_inode) {\n\t\t \n\t\tocfs2_open_unlock(new_orphan_inode);\n\t\tif (error)\n\t\t\tiput(new_orphan_inode);\n\t}\n\n\treturn error;\n}\n\n \n\n \nstatic inline int ocfs2_may_create(struct inode *dir, struct dentry *child)\n{\n\tif (d_really_is_positive(child))\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\treturn inode_permission(&nop_mnt_idmap, dir, MAY_WRITE | MAY_EXEC);\n}\n\n \nstatic int ocfs2_vfs_reflink(struct dentry *old_dentry, struct inode *dir,\n\t\t\t     struct dentry *new_dentry, bool preserve)\n{\n\tstruct inode *inode = d_inode(old_dentry);\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\terror = ocfs2_may_create(dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (dir->i_sb != inode->i_sb)\n\t\treturn -EXDEV;\n\n\t \n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\t \n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EPERM;\n\n\t \n\tif (preserve) {\n\t\tif (!uid_eq(current_fsuid(), inode->i_uid) && !capable(CAP_CHOWN))\n\t\t\treturn -EPERM;\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_CHOWN))\n\t\t\treturn -EPERM;\n\t}\n\n\t \n\tif (!preserve) {\n\t\terror = inode_permission(&nop_mnt_idmap, inode, MAY_READ);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tinode_lock(inode);\n\terror = dquot_initialize(dir);\n\tif (!error)\n\t\terror = ocfs2_reflink(old_dentry, dir, new_dentry, preserve);\n\tinode_unlock(inode);\n\tif (!error)\n\t\tfsnotify_create(dir, new_dentry);\n\treturn error;\n}\n \nint ocfs2_reflink_ioctl(struct inode *inode,\n\t\t\tconst char __user *oldname,\n\t\t\tconst char __user *newname,\n\t\t\tbool preserve)\n{\n\tstruct dentry *new_dentry;\n\tstruct path old_path, new_path;\n\tint error;\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\terror = user_path_at(AT_FDCWD, oldname, 0, &old_path);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\treturn error;\n\t}\n\n\tnew_dentry = user_path_create(AT_FDCWD, newname, &new_path, 0);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry)) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt) {\n\t\tmlog_errno(error);\n\t\tgoto out_dput;\n\t}\n\n\terror = ocfs2_vfs_reflink(old_path.dentry,\n\t\t\t\t  d_inode(new_path.dentry),\n\t\t\t\t  new_dentry, preserve);\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\nout:\n\tpath_put(&old_path);\n\n\treturn error;\n}\n\n \nint ocfs2_reflink_update_dest(struct inode *dest,\n\t\t\t      struct buffer_head *d_bh,\n\t\t\t      loff_t newlen)\n{\n\thandle_t *handle;\n\tint ret;\n\n\tdest->i_blocks = ocfs2_inode_sector_count(dest);\n\n\tif (newlen <= i_size_read(dest))\n\t\treturn 0;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(dest->i_sb),\n\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t \n\tspin_lock(&OCFS2_I(dest)->ip_lock);\n\tif (newlen > i_size_read(dest))\n\t\ti_size_write(dest, newlen);\n\tspin_unlock(&OCFS2_I(dest)->ip_lock);\n\tdest->i_mtime = inode_set_ctime_current(dest);\n\n\tret = ocfs2_mark_inode_dirty(handle, dest, d_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(dest->i_sb), handle);\n\treturn ret;\n}\n\n \nstatic loff_t ocfs2_reflink_remap_extent(struct inode *s_inode,\n\t\t\t\t\t struct buffer_head *s_bh,\n\t\t\t\t\t loff_t pos_in,\n\t\t\t\t\t struct inode *t_inode,\n\t\t\t\t\t struct buffer_head *t_bh,\n\t\t\t\t\t loff_t pos_out,\n\t\t\t\t\t loff_t len,\n\t\t\t\t\t struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tstruct ocfs2_extent_tree s_et;\n\tstruct ocfs2_extent_tree t_et;\n\tstruct ocfs2_dinode *dis;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tstruct ocfs2_super *osb;\n\tloff_t remapped_bytes = 0;\n\tloff_t pstart, plen;\n\tu32 p_cluster, num_clusters, slast, spos, tpos, remapped_clus = 0;\n\tunsigned int ext_flags;\n\tint ret = 0;\n\n\tosb = OCFS2_SB(s_inode->i_sb);\n\tdis = (struct ocfs2_dinode *)s_bh->b_data;\n\tocfs2_init_dinode_extent_tree(&s_et, INODE_CACHE(s_inode), s_bh);\n\tocfs2_init_dinode_extent_tree(&t_et, INODE_CACHE(t_inode), t_bh);\n\n\tspos = ocfs2_bytes_to_clusters(s_inode->i_sb, pos_in);\n\ttpos = ocfs2_bytes_to_clusters(t_inode->i_sb, pos_out);\n\tslast = ocfs2_clusters_for_bytes(s_inode->i_sb, pos_in + len);\n\n\twhile (spos < slast) {\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret = ocfs2_get_clusters(s_inode, spos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum_clusters = min_t(u32, num_clusters, slast - spos);\n\n\t\t \n\t\tpstart = ocfs2_clusters_to_bytes(t_inode->i_sb, tpos);\n\t\tplen = ocfs2_clusters_to_bytes(t_inode->i_sb, num_clusters);\n\t\tret = ocfs2_remove_inode_range(t_inode, t_bh, pstart, plen);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (p_cluster == 0)\n\t\t\tgoto next_loop;\n\n\t\t \n\t\tret = ocfs2_lock_refcount_tree(osb,\n\t\t\t\t\t       le64_to_cpu(dis->i_refcount_loc),\n\t\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED)) {\n\t\t\tret = ocfs2_add_refcount_flag(s_inode, &s_et,\n\t\t\t\t\t\t      &ref_tree->rf_ci,\n\t\t\t\t\t\t      ref_root_bh, spos,\n\t\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t\t      dealloc, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_unlock_refcount;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\text_flags |= OCFS2_EXT_REFCOUNTED;\n\t\tret = ocfs2_add_refcounted_extent(t_inode, &t_et,\n\t\t\t\t\t\t  &ref_tree->rf_ci,\n\t\t\t\t\t\t  ref_root_bh,\n\t\t\t\t\t\t  tpos, p_cluster,\n\t\t\t\t\t\t  num_clusters,\n\t\t\t\t\t\t  ext_flags,\n\t\t\t\t\t\t  dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock_refcount;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\t\tbrelse(ref_root_bh);\nnext_loop:\n\t\tspos += num_clusters;\n\t\ttpos += num_clusters;\n\t\tremapped_clus += num_clusters;\n\t}\n\n\tgoto out;\nout_unlock_refcount:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\nout:\n\tremapped_bytes = ocfs2_clusters_to_bytes(t_inode->i_sb, remapped_clus);\n\tremapped_bytes = min_t(loff_t, len, remapped_bytes);\n\n\treturn remapped_bytes > 0 ? remapped_bytes : ret;\n}\n\n \nloff_t ocfs2_reflink_remap_blocks(struct inode *s_inode,\n\t\t\t\t  struct buffer_head *s_bh,\n\t\t\t\t  loff_t pos_in,\n\t\t\t\t  struct inode *t_inode,\n\t\t\t\t  struct buffer_head *t_bh,\n\t\t\t\t  loff_t pos_out,\n\t\t\t\t  loff_t len)\n{\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_super *osb;\n\tstruct ocfs2_dinode *dis;\n\tstruct ocfs2_dinode *dit;\n\tloff_t ret;\n\n\tosb = OCFS2_SB(s_inode->i_sb);\n\tdis = (struct ocfs2_dinode *)s_bh->b_data;\n\tdit = (struct ocfs2_dinode *)t_bh->b_data;\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\t \n\tif (pos_in == pos_out && pos_in == 0 && len == i_size_read(s_inode) &&\n\t    i_size_read(t_inode) <= len &&\n\t    (OCFS2_I(s_inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)) {\n\t\tret = ocfs2_duplicate_inline_data(s_inode, s_bh, t_inode, t_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tret = -EOPNOTSUPP;\n\tif (ocfs2_is_refcount_inode(s_inode) &&\n\t    ocfs2_is_refcount_inode(t_inode) &&\n\t    le64_to_cpu(dis->i_refcount_loc) !=\n\t    le64_to_cpu(dit->i_refcount_loc))\n\t\tgoto out;\n\n\t \n\tif (!ocfs2_is_refcount_inode(s_inode) &&\n\t    !ocfs2_is_refcount_inode(t_inode)) {\n\t\tret = ocfs2_create_refcount_tree(s_inode, s_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (!ocfs2_is_refcount_inode(s_inode)) {\n\t\tret = ocfs2_set_refcount_tree(s_inode, s_bh,\n\t\t\t\t\t      le64_to_cpu(dit->i_refcount_loc));\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (!ocfs2_is_refcount_inode(t_inode)) {\n\t\tret = ocfs2_set_refcount_tree(t_inode, t_bh,\n\t\t\t\t\t      le64_to_cpu(dis->i_refcount_loc));\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (OCFS2_I(t_inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_convert_inline_data_to_extents(t_inode, t_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tret = ocfs2_reflink_remap_extent(s_inode, s_bh, pos_in, t_inode, t_bh,\n\t\t\t\t\t pos_out, len, &dealloc);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (ocfs2_dealloc_has_cluster(&dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\t\tocfs2_run_deallocs(osb, &dealloc);\n\t}\n\n\treturn ret;\n}\n\n \nint ocfs2_reflink_inodes_lock(struct inode *s_inode,\n\t\t\t      struct buffer_head **bh_s,\n\t\t\t      struct inode *t_inode,\n\t\t\t      struct buffer_head **bh_t)\n{\n\tstruct inode *inode1 = s_inode;\n\tstruct inode *inode2 = t_inode;\n\tstruct ocfs2_inode_info *oi1;\n\tstruct ocfs2_inode_info *oi2;\n\tstruct buffer_head *bh1 = NULL;\n\tstruct buffer_head *bh2 = NULL;\n\tbool same_inode = (s_inode == t_inode);\n\tbool need_swap = (inode1->i_ino > inode2->i_ino);\n\tint status;\n\n\t \n\tlock_two_nondirectories(s_inode, t_inode);\n\tif (need_swap)\n\t\tswap(inode1, inode2);\n\n\tstatus = ocfs2_rw_lock(inode1, 1);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_i1;\n\t}\n\tif (!same_inode) {\n\t\tstatus = ocfs2_rw_lock(inode2, 1);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_i2;\n\t\t}\n\t}\n\n\t \n\toi1 = OCFS2_I(inode1);\n\toi2 = OCFS2_I(inode2);\n\n\ttrace_ocfs2_double_lock((unsigned long long)oi1->ip_blkno,\n\t\t\t\t(unsigned long long)oi2->ip_blkno);\n\n\t \n\tif (oi1->ip_blkno > oi2->ip_blkno)\n\t\tmlog_errno(-ENOLCK);\n\n\t \n\tstatus = ocfs2_inode_lock_nested(inode1, &bh1, 1,\n\t\t\t\t\t OI_LS_REFLINK_TARGET);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto out_rw2;\n\t}\n\n\t \n\tif (!same_inode) {\n\t\tstatus = ocfs2_inode_lock_nested(inode2, &bh2, 1,\n\t\t\t\t\t\t OI_LS_REFLINK_TARGET);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOENT)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto out_cl1;\n\t\t}\n\t} else {\n\t\tbh2 = bh1;\n\t}\n\n\t \n\tif (need_swap)\n\t\tswap(bh1, bh2);\n\t*bh_s = bh1;\n\t*bh_t = bh2;\n\n\ttrace_ocfs2_double_lock_end(\n\t\t\t(unsigned long long)oi1->ip_blkno,\n\t\t\t(unsigned long long)oi2->ip_blkno);\n\n\treturn 0;\n\nout_cl1:\n\tocfs2_inode_unlock(inode1, 1);\n\tbrelse(bh1);\nout_rw2:\n\tocfs2_rw_unlock(inode2, 1);\nout_i2:\n\tocfs2_rw_unlock(inode1, 1);\nout_i1:\n\tunlock_two_nondirectories(s_inode, t_inode);\n\treturn status;\n}\n\n \nvoid ocfs2_reflink_inodes_unlock(struct inode *s_inode,\n\t\t\t\t struct buffer_head *s_bh,\n\t\t\t\t struct inode *t_inode,\n\t\t\t\t struct buffer_head *t_bh)\n{\n\tocfs2_inode_unlock(s_inode, 1);\n\tocfs2_rw_unlock(s_inode, 1);\n\tbrelse(s_bh);\n\tif (s_inode != t_inode) {\n\t\tocfs2_inode_unlock(t_inode, 1);\n\t\tocfs2_rw_unlock(t_inode, 1);\n\t\tbrelse(t_bh);\n\t}\n\tunlock_two_nondirectories(s_inode, t_inode);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}