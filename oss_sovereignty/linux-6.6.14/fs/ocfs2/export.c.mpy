{
  "module_name": "export.c",
  "hash_id": "9f705af4217cb4c239bd2dcb34214d31e4c90012a00ea92bee98b0d770d96732",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/export.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/types.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"alloc.h\"\n#include \"dir.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"export.h\"\n#include \"inode.h\"\n\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_trace.h\"\n\nstruct ocfs2_inode_handle\n{\n\tu64 ih_blkno;\n\tu32 ih_generation;\n};\n\nstatic struct dentry *ocfs2_get_dentry(struct super_block *sb,\n\t\tstruct ocfs2_inode_handle *handle)\n{\n\tstruct inode *inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tu64 blkno = handle->ih_blkno;\n\tint status, set;\n\tstruct dentry *result;\n\n\ttrace_ocfs2_get_dentry_begin(sb, handle, (unsigned long long)blkno);\n\n\tif (blkno == 0) {\n\t\tresult = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_ilookup(sb, blkno);\n\t \n\tif (inode)\n\t\tgoto check_gen;\n\n\t \n\tstatus = ocfs2_nfs_sync_lock(osb, 1);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"getting nfs sync lock(EX) failed %d\\n\", status);\n\t\tgoto check_err;\n\t}\n\n\tstatus = ocfs2_test_inode_bit(osb, blkno, &set);\n\tif (status < 0) {\n\t\tif (status == -EINVAL) {\n\t\t\t \n\t\t\tstatus = -ESTALE;\n\t\t} else\n\t\t\tmlog(ML_ERROR, \"test inode bit failed %d\\n\", status);\n\t\tgoto unlock_nfs_sync;\n\t}\n\n\ttrace_ocfs2_get_dentry_test_bit(status, set);\n\t \n\tif (!set) {\n\t\tstatus = -ESTALE;\n\t\tgoto unlock_nfs_sync;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, 0, 0);\n\nunlock_nfs_sync:\n\tocfs2_nfs_sync_unlock(osb, 1);\n\ncheck_err:\n\tif (status < 0) {\n\t\tif (status == -ESTALE) {\n\t\t\ttrace_ocfs2_get_dentry_stale((unsigned long long)blkno,\n\t\t\t\t\t\t     handle->ih_generation);\n\t\t}\n\t\tresult = ERR_PTR(status);\n\t\tgoto bail;\n\t}\n\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tresult = ERR_CAST(inode);\n\t\tgoto bail;\n\t}\n\ncheck_gen:\n\tif (handle->ih_generation != inode->i_generation) {\n\t\ttrace_ocfs2_get_dentry_generation((unsigned long long)blkno,\n\t\t\t\t\t\t  handle->ih_generation,\n\t\t\t\t\t\t  inode->i_generation);\n\t\tiput(inode);\n\t\tresult = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\tresult = d_obtain_alias(inode);\n\tif (IS_ERR(result))\n\t\tmlog_errno(PTR_ERR(result));\n\nbail:\n\ttrace_ocfs2_get_dentry_end(result);\n\treturn result;\n}\n\nstatic struct dentry *ocfs2_get_parent(struct dentry *child)\n{\n\tint status;\n\tu64 blkno;\n\tstruct dentry *parent;\n\tstruct inode *dir = d_inode(child);\n\tint set;\n\n\ttrace_ocfs2_get_parent(child, child->d_name.len, child->d_name.name,\n\t\t\t       (unsigned long long)OCFS2_I(dir)->ip_blkno);\n\n\tstatus = ocfs2_nfs_sync_lock(OCFS2_SB(dir->i_sb), 1);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"getting nfs sync lock(EX) failed %d\\n\", status);\n\t\tparent = ERR_PTR(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_inode_lock(dir, NULL, 0);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tparent = ERR_PTR(status);\n\t\tgoto unlock_nfs_sync;\n\t}\n\n\tstatus = ocfs2_lookup_ino_from_name(dir, \"..\", 2, &blkno);\n\tif (status < 0) {\n\t\tparent = ERR_PTR(-ENOENT);\n\t\tgoto bail_unlock;\n\t}\n\n\tstatus = ocfs2_test_inode_bit(OCFS2_SB(dir->i_sb), blkno, &set);\n\tif (status < 0) {\n\t\tif (status == -EINVAL) {\n\t\t\tstatus = -ESTALE;\n\t\t} else\n\t\t\tmlog(ML_ERROR, \"test inode bit failed %d\\n\", status);\n\t\tparent = ERR_PTR(status);\n\t\tgoto bail_unlock;\n\t}\n\n\ttrace_ocfs2_get_dentry_test_bit(status, set);\n\tif (!set) {\n\t\tstatus = -ESTALE;\n\t\tparent = ERR_PTR(status);\n\t\tgoto bail_unlock;\n\t}\n\n\tparent = d_obtain_alias(ocfs2_iget(OCFS2_SB(dir->i_sb), blkno, 0, 0));\n\nbail_unlock:\n\tocfs2_inode_unlock(dir, 0);\n\nunlock_nfs_sync:\n\tocfs2_nfs_sync_unlock(OCFS2_SB(dir->i_sb), 1);\n\nbail:\n\ttrace_ocfs2_get_parent_end(parent);\n\n\treturn parent;\n}\n\nstatic int ocfs2_encode_fh(struct inode *inode, u32 *fh_in, int *max_len,\n\t\t\t   struct inode *parent)\n{\n\tint len = *max_len;\n\tint type = 1;\n\tu64 blkno;\n\tu32 generation;\n\t__le32 *fh = (__force __le32 *) fh_in;\n\n#ifdef TRACE_HOOKS_ARE_NOT_BRAINDEAD_IN_YOUR_OPINION\n#error \"You go ahead and fix that mess, then.  Somehow\"\n\ttrace_ocfs2_encode_fh_begin(dentry, dentry->d_name.len,\n\t\t\t\t    dentry->d_name.name,\n\t\t\t\t    fh, len, connectable);\n#endif\n\n\tif (parent && (len < 6)) {\n\t\t*max_len = 6;\n\t\ttype = FILEID_INVALID;\n\t\tgoto bail;\n\t} else if (len < 3) {\n\t\t*max_len = 3;\n\t\ttype = FILEID_INVALID;\n\t\tgoto bail;\n\t}\n\n\tblkno = OCFS2_I(inode)->ip_blkno;\n\tgeneration = inode->i_generation;\n\n\ttrace_ocfs2_encode_fh_self((unsigned long long)blkno, generation);\n\n\tlen = 3;\n\tfh[0] = cpu_to_le32((u32)(blkno >> 32));\n\tfh[1] = cpu_to_le32((u32)(blkno & 0xffffffff));\n\tfh[2] = cpu_to_le32(generation);\n\n\tif (parent) {\n\t\tblkno = OCFS2_I(parent)->ip_blkno;\n\t\tgeneration = parent->i_generation;\n\n\t\tfh[3] = cpu_to_le32((u32)(blkno >> 32));\n\t\tfh[4] = cpu_to_le32((u32)(blkno & 0xffffffff));\n\t\tfh[5] = cpu_to_le32(generation);\n\n\t\tlen = 6;\n\t\ttype = 2;\n\n\t\ttrace_ocfs2_encode_fh_parent((unsigned long long)blkno,\n\t\t\t\t\t     generation);\n\t}\n\n\t*max_len = len;\n\nbail:\n\ttrace_ocfs2_encode_fh_type(type);\n\treturn type;\n}\n\nstatic struct dentry *ocfs2_fh_to_dentry(struct super_block *sb,\n\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\tstruct ocfs2_inode_handle handle;\n\n\tif (fh_len < 3 || fh_type > 2)\n\t\treturn NULL;\n\n\thandle.ih_blkno = (u64)le32_to_cpu(fid->raw[0]) << 32;\n\thandle.ih_blkno |= (u64)le32_to_cpu(fid->raw[1]);\n\thandle.ih_generation = le32_to_cpu(fid->raw[2]);\n\treturn ocfs2_get_dentry(sb, &handle);\n}\n\nstatic struct dentry *ocfs2_fh_to_parent(struct super_block *sb,\n\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\tstruct ocfs2_inode_handle parent;\n\n\tif (fh_type != 2 || fh_len < 6)\n\t\treturn NULL;\n\n\tparent.ih_blkno = (u64)le32_to_cpu(fid->raw[3]) << 32;\n\tparent.ih_blkno |= (u64)le32_to_cpu(fid->raw[4]);\n\tparent.ih_generation = le32_to_cpu(fid->raw[5]);\n\treturn ocfs2_get_dentry(sb, &parent);\n}\n\nconst struct export_operations ocfs2_export_ops = {\n\t.encode_fh\t= ocfs2_encode_fh,\n\t.fh_to_dentry\t= ocfs2_fh_to_dentry,\n\t.fh_to_parent\t= ocfs2_fh_to_parent,\n\t.get_parent\t= ocfs2_get_parent,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}