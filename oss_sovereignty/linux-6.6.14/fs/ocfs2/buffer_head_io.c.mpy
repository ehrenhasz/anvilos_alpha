{
  "module_name": "buffer_head_io.c",
  "hash_id": "4fa51c6a78b29dd50fc07370a90d57c8284c7fcd4c9ef1a83843602d10276e1a",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/buffer_head_io.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/highmem.h>\n#include <linux/bio.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"uptodate.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n\n \nenum ocfs2_state_bits {\n\tBH_NeedsValidate = BH_JBDPrivateStart,\n};\n\n \nBUFFER_FNS(NeedsValidate, needs_validate);\n\nint ocfs2_write_block(struct ocfs2_super *osb, struct buffer_head *bh,\n\t\t      struct ocfs2_caching_info *ci)\n{\n\tint ret = 0;\n\n\ttrace_ocfs2_write_block((unsigned long long)bh->b_blocknr, ci);\n\n\tBUG_ON(bh->b_blocknr < OCFS2_SUPER_BLOCK_BLKNO);\n\tBUG_ON(buffer_jbd(bh));\n\n\t \n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\n\tlock_buffer(bh);\n\tset_buffer_uptodate(bh);\n\n\t \n\tclear_buffer_dirty(bh);\n\n\tget_bh(bh);  \n\tbh->b_end_io = end_buffer_write_sync;\n\tsubmit_bh(REQ_OP_WRITE, bh);\n\n\twait_on_buffer(bh);\n\n\tif (buffer_uptodate(bh)) {\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t} else {\n\t\t \n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t}\n\n\tocfs2_metadata_cache_io_unlock(ci);\nout:\n\treturn ret;\n}\n\n \nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\tint new_bh = 0;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\t \n\tnew_bh = (bhs[0] == NULL);\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t \n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n#else\n\t\t\tunlock_buffer(bh);\n\t\t\tcontinue;\n#endif\n\t\t}\n\n\t\tget_bh(bh);  \n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(REQ_OP_READ, bh);\n\t}\n\nread_failure:\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\tif (unlikely(status)) {\n\t\t\tif (new_bh && bh) {\n\t\t\t\t \n\t\t\t\tif (!buffer_jbd(bh))\n\t\t\t\t\twait_on_buffer(bh);\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i - 1] = NULL;\n\t\t\t} else if (bh && buffer_uptodate(bh)) {\n\t\t\t\tclear_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t \n\t\t\tstatus = -EIO;\n\t\t\tgoto read_failure;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}\n\n \nint ocfs2_read_blocks(struct ocfs2_caching_info *ci, u64 block, int nr,\n\t\t      struct buffer_head *bhs[], int flags,\n\t\t      int (*validate)(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh))\n{\n\tint status = 0;\n\tint i, ignore_cache = 0;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tint new_bh = 0;\n\n\ttrace_ocfs2_read_blocks_begin(ci, (unsigned long long)block, nr, flags);\n\n\tBUG_ON(!ci);\n\tBUG_ON((flags & OCFS2_BH_READAHEAD) &&\n\t       (flags & OCFS2_BH_IGNORE_CACHE));\n\n\tif (bhs == NULL) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr < 0) {\n\t\tmlog(ML_ERROR, \"asked to read %d blocks!\\n\", nr);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\t \n\tnew_bh = (bhs[0] == NULL);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tocfs2_metadata_cache_io_unlock(ci);\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\t\tignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);\n\n\t\t \n\n\t\tif (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\ttrace_ocfs2_read_blocks_from_disk(\n\t\t\t     (unsigned long long)bh->b_blocknr,\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci));\n\t\t\t \n\t\t\tignore_cache = 1;\n\t\t}\n\n\t\ttrace_ocfs2_read_blocks_bh((unsigned long long)bh->b_blocknr,\n\t\t\tignore_cache, buffer_jbd(bh), buffer_dirty(bh));\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_cache) {\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_read_ahead(ci, bh))\n\t\t\t\tcontinue;\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\t\tmlog(ML_ERROR, \"block %llu had the JBD bit set \"\n\t\t\t\t\t       \"while I was in lock_buffer!\",\n\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\t\tBUG();\n#else\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n#endif\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!(flags & OCFS2_BH_IGNORE_CACHE)\n\t\t\t    && !(flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tget_bh(bh);  \n\t\t\tif (validate)\n\t\t\t\tset_buffer_needs_validate(bh);\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(REQ_OP_READ, bh);\n\t\t\tcontinue;\n\t\t}\n\t}\n\nread_failure:\n\tfor (i = (nr - 1); i >= 0; i--) {\n\t\tbh = bhs[i];\n\n\t\tif (!(flags & OCFS2_BH_READAHEAD)) {\n\t\t\tif (unlikely(status)) {\n\t\t\t\t \n\t\t\t\tif (new_bh && bh) {\n\t\t\t\t\t \n\t\t\t\t\tif (!buffer_jbd(bh))\n\t\t\t\t\t\twait_on_buffer(bh);\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t} else if (bh && buffer_uptodate(bh)) {\n\t\t\t\t\tclear_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (!buffer_jbd(bh))\n\t\t\t\twait_on_buffer(bh);\n\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t \n\t\t\t\tstatus = -EIO;\n\t\t\t\tclear_buffer_needs_validate(bh);\n\t\t\t\tgoto read_failure;\n\t\t\t}\n\n\t\t\tif (buffer_needs_validate(bh)) {\n\t\t\t\t \n\t\t\t\tBUG_ON(buffer_jbd(bh));\n\t\t\t\tclear_buffer_needs_validate(bh);\n\t\t\t\tstatus = validate(sb, bh);\n\t\t\t\tif (status)\n\t\t\t\t\tgoto read_failure;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t}\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\ttrace_ocfs2_read_blocks_end((unsigned long long)block, nr,\n\t\t\t\t    flags, ignore_cache);\n\nbail:\n\n\treturn status;\n}\n\n \nstatic void ocfs2_check_super_or_backup(struct super_block *sb,\n\t\t\t\t\tsector_t blkno)\n{\n\tint i;\n\tu64 backup_blkno;\n\n\tif (blkno == OCFS2_SUPER_BLOCK_BLKNO)\n\t\treturn;\n\n\tfor (i = 0; i < OCFS2_MAX_BACKUP_SUPERBLOCKS; i++) {\n\t\tbackup_blkno = ocfs2_backup_super_blkno(sb, i);\n\t\tif (backup_blkno == blkno)\n\t\t\treturn;\n\t}\n\n\tBUG();\n}\n\n \nint ocfs2_write_super_or_backup(struct ocfs2_super *osb,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint ret = 0;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\n\tBUG_ON(buffer_jbd(bh));\n\tocfs2_check_super_or_backup(osb->sb, bh->b_blocknr);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb)) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tlock_buffer(bh);\n\tset_buffer_uptodate(bh);\n\n\t \n\tclear_buffer_dirty(bh);\n\n\tget_bh(bh);  \n\tbh->b_end_io = end_buffer_write_sync;\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &di->i_check);\n\tsubmit_bh(REQ_OP_WRITE, bh);\n\n\twait_on_buffer(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t}\n\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}