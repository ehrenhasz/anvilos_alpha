{
  "module_name": "localalloc.c",
  "hash_id": "1d516dc32b36ca7d632d40d4a89d0d6e55f336c6894377cc8c16f08a429aa522",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/localalloc.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/bitops.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"alloc.h\"\n#include \"blockcheck.h\"\n#include \"dlmglue.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"localalloc.h\"\n#include \"suballoc.h\"\n#include \"super.h\"\n#include \"sysfile.h\"\n#include \"ocfs2_trace.h\"\n\n#include \"buffer_head_io.h\"\n\n#define OCFS2_LOCAL_ALLOC(dinode)\t(&((dinode)->id2.i_lab))\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\n\nstatic int ocfs2_local_alloc_find_clear_bits(struct ocfs2_super *osb,\n\t\t\t\t\t     struct ocfs2_dinode *alloc,\n\t\t\t\t\t     u32 *numbits,\n\t\t\t\t\t     struct ocfs2_alloc_reservation *resv);\n\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nstatic int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);\n\nstatic int ocfs2_local_alloc_reserve_for_window(struct ocfs2_super *osb,\n\t\t\t\t\t\tstruct ocfs2_alloc_context **ac,\n\t\t\t\t\t\tstruct inode **bitmap_inode,\n\t\t\t\t\t\tstruct buffer_head **bitmap_bh);\n\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);\n\nstatic int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);\n\n \n#define\tOCFS2_LA_MAX_DEFAULT_MB\t256\n#define\tOCFS2_LA_OLD_DEFAULT\t8\nunsigned int ocfs2_la_default_mb(struct ocfs2_super *osb)\n{\n\tunsigned int la_mb;\n\tunsigned int gd_mb;\n\tunsigned int la_max_mb;\n\tunsigned int megs_per_slot;\n\tstruct super_block *sb = osb->sb;\n\n\tgd_mb = ocfs2_clusters_to_megabytes(osb->sb,\n\t\t8 * ocfs2_group_bitmap_size(sb, 0, osb->s_feature_incompat));\n\n\t \n\tif ((sb->s_blocksize == 512 && osb->s_clustersize <= 8192)\n\t    || (sb->s_blocksize == 1024 && osb->s_clustersize == 4096))\n\t\treturn OCFS2_LA_OLD_DEFAULT;\n\n\t \n\tgd_mb -= 16;\n\tgd_mb &= 0xFFFFFFFB;\n\n\tla_mb = gd_mb;\n\n\t \n\tif (la_mb > OCFS2_LA_MAX_DEFAULT_MB) {\n\t\t \n\t\tif (gd_mb > (2 * OCFS2_LA_MAX_DEFAULT_MB))\n\t\t\tla_mb = 256;\n\t\telse {\n\t\t\tunsigned int gd_mult = gd_mb;\n\n\t\t\twhile (gd_mult > 256)\n\t\t\t\tgd_mult = gd_mult >> 1;\n\n\t\t\tla_mb = gd_mult;\n\t\t}\n\t}\n\n\tmegs_per_slot = osb->osb_clusters_at_boot / osb->max_slots;\n\tmegs_per_slot = ocfs2_clusters_to_megabytes(osb->sb, megs_per_slot);\n\t \n\tif (megs_per_slot < la_mb)\n\t\tla_mb = megs_per_slot;\n\n\t \n\tla_max_mb = ocfs2_clusters_to_megabytes(osb->sb,\n\t\t\t\t\t\tocfs2_local_alloc_size(sb) * 8);\n\tif (la_mb > la_max_mb)\n\t\tla_mb = la_max_mb;\n\n\treturn la_mb;\n}\n\nvoid ocfs2_la_set_sizes(struct ocfs2_super *osb, int requested_mb)\n{\n\tstruct super_block *sb = osb->sb;\n\tunsigned int la_default_mb = ocfs2_la_default_mb(osb);\n\tunsigned int la_max_mb;\n\n\tla_max_mb = ocfs2_clusters_to_megabytes(sb,\n\t\t\t\t\t\tocfs2_local_alloc_size(sb) * 8);\n\n\ttrace_ocfs2_la_set_sizes(requested_mb, la_max_mb, la_default_mb);\n\n\tif (requested_mb == -1) {\n\t\t \n\t\tosb->local_alloc_default_bits =\n\t\t\tocfs2_megabytes_to_clusters(sb, la_default_mb);\n\t} else if (requested_mb > la_max_mb) {\n\t\t \n\t\tosb->local_alloc_default_bits =\n\t\t\tocfs2_megabytes_to_clusters(sb, la_max_mb);\n\t} else {\n\t\tosb->local_alloc_default_bits =\n\t\t\tocfs2_megabytes_to_clusters(sb, requested_mb);\n\t}\n\n\tosb->local_alloc_bits = osb->local_alloc_default_bits;\n}\n\nstatic inline int ocfs2_la_state_enabled(struct ocfs2_super *osb)\n{\n\treturn (osb->local_alloc_state == OCFS2_LA_THROTTLED ||\n\t\tosb->local_alloc_state == OCFS2_LA_ENABLED);\n}\n\nvoid ocfs2_local_alloc_seen_free_bits(struct ocfs2_super *osb,\n\t\t\t\t      unsigned int num_clusters)\n{\n\tspin_lock(&osb->osb_lock);\n\tif (osb->local_alloc_state == OCFS2_LA_DISABLED ||\n\t    osb->local_alloc_state == OCFS2_LA_THROTTLED)\n\t\tif (num_clusters >= osb->local_alloc_default_bits) {\n\t\t\tcancel_delayed_work(&osb->la_enable_wq);\n\t\t\tosb->local_alloc_state = OCFS2_LA_ENABLED;\n\t\t}\n\tspin_unlock(&osb->osb_lock);\n}\n\nvoid ocfs2_la_enable_worker(struct work_struct *work)\n{\n\tstruct ocfs2_super *osb =\n\t\tcontainer_of(work, struct ocfs2_super,\n\t\t\t     la_enable_wq.work);\n\tspin_lock(&osb->osb_lock);\n\tosb->local_alloc_state = OCFS2_LA_ENABLED;\n\tspin_unlock(&osb->osb_lock);\n}\n\n \nint ocfs2_alloc_should_use_local(struct ocfs2_super *osb, u64 bits)\n{\n\tint ret = 0;\n\tint la_bits;\n\n\tspin_lock(&osb->osb_lock);\n\tla_bits = osb->local_alloc_bits;\n\n\tif (!ocfs2_la_state_enabled(osb))\n\t\tgoto bail;\n\n\t \n\tif (bits > (la_bits / 2))\n\t\tgoto bail;\n\n\tret = 1;\nbail:\n\ttrace_ocfs2_alloc_should_use_local(\n\t     (unsigned long long)bits, osb->local_alloc_state, la_bits, ret);\n\tspin_unlock(&osb->osb_lock);\n\treturn ret;\n}\n\nint ocfs2_load_local_alloc(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *alloc = NULL;\n\tstruct buffer_head *alloc_bh = NULL;\n\tu32 num_used;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_local_alloc *la;\n\n\tif (osb->local_alloc_bits == 0)\n\t\tgoto bail;\n\n\tif (osb->local_alloc_bits >= osb->bitmap_cpg) {\n\t\tmlog(ML_NOTICE, \"Requested local alloc window %d is larger \"\n\t\t     \"than max possible %u. Using defaults.\\n\",\n\t\t     osb->local_alloc_bits, (osb->bitmap_cpg - 1));\n\t\tosb->local_alloc_bits =\n\t\t\tocfs2_megabytes_to_clusters(osb->sb,\n\t\t\t\t\t\t    ocfs2_la_default_mb(osb));\n\t}\n\n\t \n\tinode = ocfs2_get_system_file_inode(osb, LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block_full(inode, &alloc_bh,\n\t\t\t\t\t     OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\talloc = (struct ocfs2_dinode *) alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tif (!(le32_to_cpu(alloc->i_flags) &\n\t    (OCFS2_LOCAL_ALLOC_FL|OCFS2_BITMAP_FL))) {\n\t\tmlog(ML_ERROR, \"Invalid local alloc inode, %llu\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif ((la->la_size == 0) ||\n\t    (le16_to_cpu(la->la_size) > ocfs2_local_alloc_size(inode->i_sb))) {\n\t\tmlog(ML_ERROR, \"Local alloc size is invalid (la_size = %u)\\n\",\n\t\t     le16_to_cpu(la->la_size));\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\t \n\tnum_used = ocfs2_local_alloc_count_bits(alloc);\n\n\t \n\tif (num_used\n\t    || alloc->id1.bitmap1.i_used\n\t    || alloc->id1.bitmap1.i_total\n\t    || la->la_bm_off) {\n\t\tmlog(ML_ERROR, \"inconsistent detected, clean journal with\"\n\t\t     \" unrecovered local alloc, please run fsck.ocfs2!\\n\"\n\t\t     \"found = %u, set = %u, taken = %u, off = %u\\n\",\n\t\t     num_used, le32_to_cpu(alloc->id1.bitmap1.i_used),\n\t\t     le32_to_cpu(alloc->id1.bitmap1.i_total),\n\t\t     OCFS2_LOCAL_ALLOC(alloc)->la_bm_off);\n\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tosb->local_alloc_bh = alloc_bh;\n\tosb->local_alloc_state = OCFS2_LA_ENABLED;\n\nbail:\n\tif (status < 0)\n\t\tbrelse(alloc_bh);\n\tiput(inode);\n\n\ttrace_ocfs2_load_local_alloc(osb->local_alloc_bits);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\n \nvoid ocfs2_shutdown_local_alloc(struct ocfs2_super *osb)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct inode *local_alloc_inode = NULL;\n\tstruct buffer_head *bh = NULL;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct ocfs2_dinode *alloc_copy = NULL;\n\tstruct ocfs2_dinode *alloc = NULL;\n\n\tcancel_delayed_work(&osb->la_enable_wq);\n\tif (osb->ocfs2_wq)\n\t\tflush_workqueue(osb->ocfs2_wq);\n\n\tif (osb->local_alloc_state == OCFS2_LA_UNUSED)\n\t\tgoto out;\n\n\tlocal_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (!local_alloc_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tosb->local_alloc_state = OCFS2_LA_DISABLED;\n\n\tocfs2_resmap_uninit(&osb->osb_la_resmap);\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tinode_lock(main_bm_inode);\n\n\tstatus = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\t \n\thandle = ocfs2_start_trans(osb, OCFS2_WINDOW_MOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tmlog_errno(PTR_ERR(handle));\n\t\thandle = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\tbh = osb->local_alloc_bh;\n\talloc = (struct ocfs2_dinode *) bh->b_data;\n\n\talloc_copy = kmemdup(alloc, bh->b_size, GFP_NOFS);\n\tif (!alloc_copy) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out_commit;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(local_alloc_inode),\n\t\t\t\t\t bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_clear_local_alloc(alloc);\n\tocfs2_journal_dirty(handle, bh);\n\n\tbrelse(bh);\n\tosb->local_alloc_bh = NULL;\n\tosb->local_alloc_state = OCFS2_LA_UNUSED;\n\n\tstatus = ocfs2_sync_local_to_main(osb, handle, alloc_copy,\n\t\t\t\t\t  main_bm_inode, main_bm_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(main_bm_bh);\n\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tinode_unlock(main_bm_inode);\n\tiput(main_bm_inode);\n\nout:\n\tiput(local_alloc_inode);\n\n\tkfree(alloc_copy);\n}\n\n \nint ocfs2_begin_local_alloc_recovery(struct ocfs2_super *osb,\n\t\t\t\t     int slot_num,\n\t\t\t\t     struct ocfs2_dinode **alloc_copy)\n{\n\tint status = 0;\n\tstruct buffer_head *alloc_bh = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_dinode *alloc;\n\n\ttrace_ocfs2_begin_local_alloc_recovery(slot_num);\n\n\t*alloc_copy = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinode_lock(inode);\n\n\tstatus = ocfs2_read_inode_block_full(inode, &alloc_bh,\n\t\t\t\t\t     OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*alloc_copy = kmalloc(alloc_bh->b_size, GFP_KERNEL);\n\tif (!(*alloc_copy)) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tmemcpy((*alloc_copy), alloc_bh->b_data, alloc_bh->b_size);\n\n\talloc = (struct ocfs2_dinode *) alloc_bh->b_data;\n\tocfs2_clear_local_alloc(alloc);\n\n\tocfs2_compute_meta_ecc(osb->sb, alloc_bh->b_data, &alloc->i_check);\n\tstatus = ocfs2_write_block(osb, alloc_bh, INODE_CACHE(inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\tif (status < 0) {\n\t\tkfree(*alloc_copy);\n\t\t*alloc_copy = NULL;\n\t}\n\n\tbrelse(alloc_bh);\n\n\tif (inode) {\n\t\tinode_unlock(inode);\n\t\tiput(inode);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\n \nint ocfs2_complete_local_alloc_recovery(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_dinode *alloc)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tinode_lock(main_bm_inode);\n\n\tstatus = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_WINDOW_MOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\thandle->h_sync = 1;\n\n\tstatus = ocfs2_sync_local_to_main(osb, handle, alloc,\n\t\t\t\t\t  main_bm_inode, main_bm_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tinode_unlock(main_bm_inode);\n\n\tbrelse(main_bm_bh);\n\n\tiput(main_bm_inode);\n\nout:\n\tif (!status)\n\t\tocfs2_init_steal_slots(osb);\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\n \nint ocfs2_reserve_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\t   u32 bits_wanted,\n\t\t\t\t   struct ocfs2_alloc_context *ac)\n{\n\tint status;\n\tstruct ocfs2_dinode *alloc;\n\tstruct inode *local_alloc_inode;\n\tunsigned int free_bits;\n\n\tBUG_ON(!ac);\n\n\tlocal_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (!local_alloc_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinode_lock(local_alloc_inode);\n\n\t \n\tspin_lock(&osb->osb_lock);\n\tif (!ocfs2_la_state_enabled(osb) ||\n\t    (bits_wanted > osb->local_alloc_bits)) {\n\t\tspin_unlock(&osb->osb_lock);\n\t\tstatus = -ENOSPC;\n\t\tgoto bail;\n\t}\n\tspin_unlock(&osb->osb_lock);\n\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tif (le32_to_cpu(alloc->id1.bitmap1.i_used) !=\n\t    ocfs2_local_alloc_count_bits(alloc)) {\n\t\tstatus = ocfs2_error(osb->sb, \"local alloc inode %llu says it has %u used bits, but a count shows %u\\n\",\n\t\t\t\t(unsigned long long)le64_to_cpu(alloc->i_blkno),\n\t\t\t\tle32_to_cpu(alloc->id1.bitmap1.i_used),\n\t\t\t\tocfs2_local_alloc_count_bits(alloc));\n\t\tgoto bail;\n\t}\n#endif\n\n\tfree_bits = le32_to_cpu(alloc->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_used);\n\tif (bits_wanted > free_bits) {\n\t\t \n\t\tstatus =\n\t\t\tocfs2_local_alloc_slide_window(osb, local_alloc_inode);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t \n\t\tstatus = -ENOSPC;\n\t\tif (!ocfs2_la_state_enabled(osb))\n\t\t\tgoto bail;\n\n\t\tfree_bits = le32_to_cpu(alloc->id1.bitmap1.i_total) -\n\t\t\tle32_to_cpu(alloc->id1.bitmap1.i_used);\n\t\tif (bits_wanted > free_bits)\n\t\t\tgoto bail;\n\t}\n\n\tac->ac_inode = local_alloc_inode;\n\t \n\tac->ac_alloc_slot = osb->slot_num;\n\tac->ac_which = OCFS2_AC_USE_LOCAL;\n\tget_bh(osb->local_alloc_bh);\n\tac->ac_bh = osb->local_alloc_bh;\n\tstatus = 0;\nbail:\n\tif (status < 0 && local_alloc_inode) {\n\t\tinode_unlock(local_alloc_inode);\n\t\tiput(local_alloc_inode);\n\t}\n\n\ttrace_ocfs2_reserve_local_alloc_bits(\n\t\t(unsigned long long)ac->ac_max_block,\n\t\tbits_wanted, osb->slot_num, status);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\nint ocfs2_claim_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t\t u32 bits_wanted,\n\t\t\t\t u32 *bit_off,\n\t\t\t\t u32 *num_bits)\n{\n\tint status, start;\n\tstruct inode *local_alloc_inode;\n\tvoid *bitmap;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_local_alloc *la;\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL);\n\n\tlocal_alloc_inode = ac->ac_inode;\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tstart = ocfs2_local_alloc_find_clear_bits(osb, alloc, &bits_wanted,\n\t\t\t\t\t\t  ac->ac_resv);\n\tif (start == -1) {\n\t\t \n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tbitmap = la->la_bitmap;\n\t*bit_off = le32_to_cpu(la->la_bm_off) + start;\n\t*num_bits = bits_wanted;\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(local_alloc_inode),\n\t\t\t\t\t osb->local_alloc_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_resmap_claimed_bits(&osb->osb_la_resmap, ac->ac_resv, start,\n\t\t\t\t  bits_wanted);\n\n\twhile(bits_wanted--)\n\t\tocfs2_set_bit(start++, bitmap);\n\n\tle32_add_cpu(&alloc->id1.bitmap1.i_used, *num_bits);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\nint ocfs2_free_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\tu32 bit_off,\n\t\t\t\tu32 num_bits)\n{\n\tint status, start;\n\tu32 clear_bits;\n\tstruct inode *local_alloc_inode;\n\tvoid *bitmap;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_local_alloc *la;\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL);\n\n\tlocal_alloc_inode = ac->ac_inode;\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tbitmap = la->la_bitmap;\n\tstart = bit_off - le32_to_cpu(la->la_bm_off);\n\tclear_bits = num_bits;\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\tINODE_CACHE(local_alloc_inode),\n\t\t\tosb->local_alloc_bh,\n\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\twhile (clear_bits--)\n\t\tocfs2_clear_bit(start++, bitmap);\n\n\tle32_add_cpu(&alloc->id1.bitmap1.i_used, -num_bits);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\nbail:\n\treturn status;\n}\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc)\n{\n\tu32 count;\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\n\tcount = memweight(la->la_bitmap, le16_to_cpu(la->la_size));\n\n\ttrace_ocfs2_local_alloc_count_bits(count);\n\treturn count;\n}\n\nstatic int ocfs2_local_alloc_find_clear_bits(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_dinode *alloc,\n\t\t\t\t     u32 *numbits,\n\t\t\t\t     struct ocfs2_alloc_reservation *resv)\n{\n\tint numfound = 0, bitoff, left, startoff;\n\tint local_resv = 0;\n\tstruct ocfs2_alloc_reservation r;\n\tvoid *bitmap = NULL;\n\tstruct ocfs2_reservation_map *resmap = &osb->osb_la_resmap;\n\n\tif (!alloc->id1.bitmap1.i_total) {\n\t\tbitoff = -1;\n\t\tgoto bail;\n\t}\n\n\tif (!resv) {\n\t\tlocal_resv = 1;\n\t\tocfs2_resv_init_once(&r);\n\t\tocfs2_resv_set_type(&r, OCFS2_RESV_FLAG_TMP);\n\t\tresv = &r;\n\t}\n\n\tnumfound = *numbits;\n\tif (ocfs2_resmap_resv_bits(resmap, resv, &bitoff, &numfound) == 0) {\n\t\tif (numfound < *numbits)\n\t\t\t*numbits = numfound;\n\t\tgoto bail;\n\t}\n\n\t \n\tBUG_ON(osb->osb_resv_level != 0);\n\n\t \n\n\tbitmap = OCFS2_LOCAL_ALLOC(alloc)->la_bitmap;\n\n\tnumfound = bitoff = startoff = 0;\n\tleft = le32_to_cpu(alloc->id1.bitmap1.i_total);\n\twhile ((bitoff = ocfs2_find_next_zero_bit(bitmap, left, startoff)) != -1) {\n\t\tif (bitoff == left) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\t \n\n\t\t \n\t\tif (bitoff == startoff) {\n\t\t\t \n\t\t\tnumfound++;\n\t\t\tstartoff++;\n\t\t} else {\n\t\t\t \n\t\t\tnumfound = 1;\n\t\t\tstartoff = bitoff+1;\n\t\t}\n\t\t \n\t\tif (numfound == *numbits) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttrace_ocfs2_local_alloc_find_clear_bits_search_bitmap(bitoff, numfound);\n\n\tif (numfound == *numbits)\n\t\tbitoff = startoff - numfound;\n\telse\n\t\tbitoff = -1;\n\nbail:\n\tif (local_resv)\n\t\tocfs2_resv_discard(resmap, resv);\n\n\ttrace_ocfs2_local_alloc_find_clear_bits(*numbits,\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_total),\n\t\tbitoff, numfound);\n\n\treturn bitoff;\n}\n\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc)\n{\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\tint i;\n\n\talloc->id1.bitmap1.i_total = 0;\n\talloc->id1.bitmap1.i_used = 0;\n\tla->la_bm_off = 0;\n\tfor(i = 0; i < le16_to_cpu(la->la_size); i++)\n\t\tla->la_bitmap[i] = 0;\n}\n\n#if 0\n \nstatic void ocfs2_verify_zero_bits(unsigned long *bitmap,\n\t\t\t\t   unsigned int start,\n\t\t\t\t   unsigned int count)\n{\n\tunsigned int tmp = count;\n\twhile(tmp--) {\n\t\tif (ocfs2_test_bit(start + tmp, bitmap)) {\n\t\t\tprintk(\"ocfs2_verify_zero_bits: start = %u, count = \"\n\t\t\t       \"%u\\n\", start, count);\n\t\t\tprintk(\"ocfs2_verify_zero_bits: bit %u is set!\",\n\t\t\t       start + tmp);\n\t\t\tBUG();\n\t\t}\n\t}\n}\n#endif\n\n \nstatic int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh)\n{\n\tint status = 0;\n\tint bit_off, left, count, start;\n\tu64 la_start_blk;\n\tu64 blkno;\n\tvoid *bitmap;\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\n\ttrace_ocfs2_sync_local_to_main(\n\t     le32_to_cpu(alloc->id1.bitmap1.i_total),\n\t     le32_to_cpu(alloc->id1.bitmap1.i_used));\n\n\tif (!alloc->id1.bitmap1.i_total) {\n\t\tgoto bail;\n\t}\n\n\tif (le32_to_cpu(alloc->id1.bitmap1.i_used) ==\n\t    le32_to_cpu(alloc->id1.bitmap1.i_total)) {\n\t\tgoto bail;\n\t}\n\n\tla_start_blk = ocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\tle32_to_cpu(la->la_bm_off));\n\tbitmap = la->la_bitmap;\n\tstart = count = 0;\n\tleft = le32_to_cpu(alloc->id1.bitmap1.i_total);\n\n\twhile ((bit_off = ocfs2_find_next_zero_bit(bitmap, left, start))\n\t       != -1) {\n\t\tif ((bit_off < left) && (bit_off == start)) {\n\t\t\tcount++;\n\t\t\tstart++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (count) {\n\t\t\tblkno = la_start_blk +\n\t\t\t\tocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\t\t start - count);\n\n\t\t\ttrace_ocfs2_sync_local_to_main_free(\n\t\t\t     count, start - count,\n\t\t\t     (unsigned long long)la_start_blk,\n\t\t\t     (unsigned long long)blkno);\n\n\t\t\tstatus = ocfs2_release_clusters(handle,\n\t\t\t\t\t\t\tmain_bm_inode,\n\t\t\t\t\t\t\tmain_bm_bh, blkno,\n\t\t\t\t\t\t\tcount);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tif (bit_off >= left)\n\t\t\tbreak;\n\t\tcount = 1;\n\t\tstart = bit_off + 1;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\nenum ocfs2_la_event {\n\tOCFS2_LA_EVENT_SLIDE,\t\t \n\tOCFS2_LA_EVENT_FRAGMENTED,\t \n\tOCFS2_LA_EVENT_ENOSPC,\t\t \n};\n#define OCFS2_LA_ENABLE_INTERVAL (30 * HZ)\n \nstatic int ocfs2_recalc_la_window(struct ocfs2_super *osb,\n\t\t\t\t  enum ocfs2_la_event event)\n{\n\tunsigned int bits;\n\tint state;\n\n\tspin_lock(&osb->osb_lock);\n\tif (osb->local_alloc_state == OCFS2_LA_DISABLED) {\n\t\tWARN_ON_ONCE(osb->local_alloc_state == OCFS2_LA_DISABLED);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (event == OCFS2_LA_EVENT_ENOSPC ||\n\t    event == OCFS2_LA_EVENT_FRAGMENTED) {\n\t\t \n\t\tbits = osb->local_alloc_bits >> 1;\n\t\tif (bits > ocfs2_megabytes_to_clusters(osb->sb, 1)) {\n\t\t\t \n\t\t\tosb->local_alloc_state = OCFS2_LA_THROTTLED;\n\t\t\tosb->local_alloc_bits = bits;\n\t\t} else {\n\t\t\tosb->local_alloc_state = OCFS2_LA_DISABLED;\n\t\t}\n\t\tqueue_delayed_work(osb->ocfs2_wq, &osb->la_enable_wq,\n\t\t\t\t   OCFS2_LA_ENABLE_INTERVAL);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (osb->local_alloc_state != OCFS2_LA_THROTTLED)\n\t\tosb->local_alloc_bits = osb->local_alloc_default_bits;\n\nout_unlock:\n\tstate = osb->local_alloc_state;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn state;\n}\n\nstatic int ocfs2_local_alloc_reserve_for_window(struct ocfs2_super *osb,\n\t\t\t\t\t\tstruct ocfs2_alloc_context **ac,\n\t\t\t\t\t\tstruct inode **bitmap_inode,\n\t\t\t\t\t\tstruct buffer_head **bitmap_bh)\n{\n\tint status;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nretry_enospc:\n\t(*ac)->ac_bits_wanted = osb->local_alloc_bits;\n\tstatus = ocfs2_reserve_cluster_bitmap_bits(osb, *ac);\n\tif (status == -ENOSPC) {\n\t\tif (ocfs2_recalc_la_window(osb, OCFS2_LA_EVENT_ENOSPC) ==\n\t\t    OCFS2_LA_DISABLED)\n\t\t\tgoto bail;\n\n\t\tocfs2_free_ac_resource(*ac);\n\t\tmemset(*ac, 0, sizeof(struct ocfs2_alloc_context));\n\t\tgoto retry_enospc;\n\t}\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*bitmap_inode = (*ac)->ac_inode;\n\tigrab(*bitmap_inode);\n\t*bitmap_bh = (*ac)->ac_bh;\n\tget_bh(*bitmap_bh);\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\n \nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac)\n{\n\tint status = 0;\n\tu32 cluster_off, cluster_count;\n\tstruct ocfs2_dinode *alloc = NULL;\n\tstruct ocfs2_local_alloc *la;\n\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\ttrace_ocfs2_local_alloc_new_window(\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_total),\n\t\tosb->local_alloc_bits);\n\n\t \n\tac->ac_last_group = osb->la_last_gd;\n\n\t \n\tstatus = ocfs2_claim_clusters(handle, ac, osb->local_alloc_bits,\n\t\t\t\t      &cluster_off, &cluster_count);\n\tif (status == -ENOSPC) {\nretry_enospc:\n\t\t \n\t\tif (ocfs2_recalc_la_window(osb, OCFS2_LA_EVENT_FRAGMENTED) ==\n\t\t    OCFS2_LA_DISABLED)\n\t\t\tgoto bail;\n\n\t\tac->ac_bits_wanted = osb->local_alloc_bits;\n\t\tstatus = ocfs2_claim_clusters(handle, ac,\n\t\t\t\t\t      osb->local_alloc_bits,\n\t\t\t\t\t      &cluster_off,\n\t\t\t\t\t      &cluster_count);\n\t\tif (status == -ENOSPC)\n\t\t\tgoto retry_enospc;\n\t\t \n\t\tif (status == 0) {\n\t\t\tspin_lock(&osb->osb_lock);\n\t\t\tosb->local_alloc_bits = cluster_count;\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->la_last_gd = ac->ac_last_group;\n\n\tla->la_bm_off = cpu_to_le32(cluster_off);\n\talloc->id1.bitmap1.i_total = cpu_to_le32(cluster_count);\n\t \n\talloc->id1.bitmap1.i_used = 0;\n\tmemset(OCFS2_LOCAL_ALLOC(alloc)->la_bitmap, 0,\n\t       le16_to_cpu(la->la_size));\n\n\tocfs2_resmap_restart(&osb->osb_la_resmap, cluster_count,\n\t\t\t     OCFS2_LOCAL_ALLOC(alloc)->la_bitmap);\n\n\ttrace_ocfs2_local_alloc_new_window_result(\n\t\tOCFS2_LOCAL_ALLOC(alloc)->la_bm_off,\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_total));\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\n \nstatic int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode)\n{\n\tint status = 0;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_dinode *alloc_copy = NULL;\n\tstruct ocfs2_alloc_context *ac = NULL;\n\n\tocfs2_recalc_la_window(osb, OCFS2_LA_EVENT_SLIDE);\n\n\t \n\tstatus = ocfs2_local_alloc_reserve_for_window(osb,\n\t\t\t\t\t\t      &ac,\n\t\t\t\t\t\t      &main_bm_inode,\n\t\t\t\t\t\t      &main_bm_bh);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_WINDOW_MOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\n\t \n\talloc_copy = kmemdup(alloc, osb->local_alloc_bh->b_size, GFP_NOFS);\n\tif (!alloc_copy) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(local_alloc_inode),\n\t\t\t\t\t osb->local_alloc_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_clear_local_alloc(alloc);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\n\tstatus = ocfs2_sync_local_to_main(osb, handle, alloc_copy,\n\t\t\t\t\t  main_bm_inode, main_bm_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_local_alloc_new_window(osb, handle, ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tatomic_inc(&osb->alloc_stats.moves);\n\nbail:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tbrelse(main_bm_bh);\n\n\tiput(main_bm_inode);\n\tkfree(alloc_copy);\n\n\tif (ac)\n\t\tocfs2_free_alloc_context(ac);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}