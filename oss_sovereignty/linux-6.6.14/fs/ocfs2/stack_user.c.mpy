{
  "module_name": "stack_user.c",
  "hash_id": "ca186f0df1a0259a98633586982771d436ea120fb9bd8ba6ccd85323c61c75db",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/stack_user.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/filelock.h>\n#include <linux/miscdevice.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n\n#include \"stackglue.h\"\n\n#include <linux/dlm_plock.h>\n\n \n\n \n#define OCFS2_CONTROL_PROTO\t\t\t\"T01\\n\"\n#define OCFS2_CONTROL_PROTO_LEN\t\t\t4\n\n \n#define OCFS2_CONTROL_HANDSHAKE_INVALID\t\t(0)\n#define OCFS2_CONTROL_HANDSHAKE_READ\t\t(1)\n#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)\n#define OCFS2_CONTROL_HANDSHAKE_VALID\t\t(3)\n\n \n#define OCFS2_CONTROL_MESSAGE_OP_LEN\t\t4\n#define OCFS2_CONTROL_MESSAGE_SETNODE_OP\t\"SETN\"\n#define OCFS2_CONTROL_MESSAGE_SETNODE_TOTAL_LEN\t14\n#define OCFS2_CONTROL_MESSAGE_SETVERSION_OP\t\"SETV\"\n#define OCFS2_CONTROL_MESSAGE_SETVERSION_TOTAL_LEN\t11\n#define OCFS2_CONTROL_MESSAGE_DOWN_OP\t\t\"DOWN\"\n#define OCFS2_CONTROL_MESSAGE_DOWN_TOTAL_LEN\t47\n#define OCFS2_TEXT_UUID_LEN\t\t\t32\n#define OCFS2_CONTROL_MESSAGE_VERNUM_LEN\t2\n#define OCFS2_CONTROL_MESSAGE_NODENUM_LEN\t8\n#define VERSION_LOCK\t\t\t\t\"version_lock\"\n\nenum ocfs2_connection_type {\n\tWITH_CONTROLD,\n\tNO_CONTROLD\n};\n\n \nstruct ocfs2_live_connection {\n\tstruct list_head\t\toc_list;\n\tstruct ocfs2_cluster_connection\t*oc_conn;\n\tenum ocfs2_connection_type\toc_type;\n\tatomic_t                        oc_this_node;\n\tint                             oc_our_slot;\n\tstruct dlm_lksb                 oc_version_lksb;\n\tchar                            oc_lvb[DLM_LVB_LEN];\n\tstruct completion               oc_sync_wait;\n\twait_queue_head_t\t\toc_wait;\n};\n\nstruct ocfs2_control_private {\n\tstruct list_head op_list;\n\tint op_state;\n\tint op_this_node;\n\tstruct ocfs2_protocol_version op_proto;\n};\n\n \nstruct ocfs2_control_message_setn {\n\tchar\ttag[OCFS2_CONTROL_MESSAGE_OP_LEN];\n\tchar\tspace;\n\tchar\tnodestr[OCFS2_CONTROL_MESSAGE_NODENUM_LEN];\n\tchar\tnewline;\n};\n\n \nstruct ocfs2_control_message_setv {\n\tchar\ttag[OCFS2_CONTROL_MESSAGE_OP_LEN];\n\tchar\tspace1;\n\tchar\tmajor[OCFS2_CONTROL_MESSAGE_VERNUM_LEN];\n\tchar\tspace2;\n\tchar\tminor[OCFS2_CONTROL_MESSAGE_VERNUM_LEN];\n\tchar\tnewline;\n};\n\n \nstruct ocfs2_control_message_down {\n\tchar\ttag[OCFS2_CONTROL_MESSAGE_OP_LEN];\n\tchar\tspace1;\n\tchar\tuuid[OCFS2_TEXT_UUID_LEN];\n\tchar\tspace2;\n\tchar\tnodestr[OCFS2_CONTROL_MESSAGE_NODENUM_LEN];\n\tchar\tnewline;\n};\n\nunion ocfs2_control_message {\n\tchar\t\t\t\t\ttag[OCFS2_CONTROL_MESSAGE_OP_LEN];\n\tstruct ocfs2_control_message_setn\tu_setn;\n\tstruct ocfs2_control_message_setv\tu_setv;\n\tstruct ocfs2_control_message_down\tu_down;\n};\n\nstatic struct ocfs2_stack_plugin ocfs2_user_plugin;\n\nstatic atomic_t ocfs2_control_opened;\nstatic int ocfs2_control_this_node = -1;\nstatic struct ocfs2_protocol_version running_proto;\n\nstatic LIST_HEAD(ocfs2_live_connection_list);\nstatic LIST_HEAD(ocfs2_control_private_list);\nstatic DEFINE_MUTEX(ocfs2_control_lock);\n\nstatic inline void ocfs2_control_set_handshake_state(struct file *file,\n\t\t\t\t\t\t     int state)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\tp->op_state = state;\n}\n\nstatic inline int ocfs2_control_get_handshake_state(struct file *file)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\treturn p->op_state;\n}\n\nstatic struct ocfs2_live_connection *ocfs2_connection_find(const char *name)\n{\n\tsize_t len = strlen(name);\n\tstruct ocfs2_live_connection *c;\n\n\tBUG_ON(!mutex_is_locked(&ocfs2_control_lock));\n\n\tlist_for_each_entry(c, &ocfs2_live_connection_list, oc_list) {\n\t\tif ((c->oc_conn->cc_namelen == len) &&\n\t\t    !strncmp(c->oc_conn->cc_name, name, len))\n\t\t\treturn c;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int ocfs2_live_connection_attach(struct ocfs2_cluster_connection *conn,\n\t\t\t\t     struct ocfs2_live_connection *c)\n{\n\tint rc = 0;\n\n\tmutex_lock(&ocfs2_control_lock);\n\tc->oc_conn = conn;\n\n\tif ((c->oc_type == NO_CONTROLD) || atomic_read(&ocfs2_control_opened))\n\t\tlist_add(&c->oc_list, &ocfs2_live_connection_list);\n\telse {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Userspace control daemon is not present\\n\");\n\t\trc = -ESRCH;\n\t}\n\n\tmutex_unlock(&ocfs2_control_lock);\n\treturn rc;\n}\n\n \nstatic void ocfs2_live_connection_drop(struct ocfs2_live_connection *c)\n{\n\tmutex_lock(&ocfs2_control_lock);\n\tlist_del_init(&c->oc_list);\n\tc->oc_conn = NULL;\n\tmutex_unlock(&ocfs2_control_lock);\n\n\tkfree(c);\n}\n\nstatic int ocfs2_control_cfu(void *target, size_t target_len,\n\t\t\t     const char __user *buf, size_t count)\n{\n\t \n\tif ((count != target_len) ||\n\t    (count > sizeof(union ocfs2_control_message)))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(target, buf, target_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic ssize_t ocfs2_control_validate_protocol(struct file *file,\n\t\t\t\t\t       const char __user *buf,\n\t\t\t\t\t       size_t count)\n{\n\tssize_t ret;\n\tchar kbuf[OCFS2_CONTROL_PROTO_LEN];\n\n\tret = ocfs2_control_cfu(kbuf, OCFS2_CONTROL_PROTO_LEN,\n\t\t\t\tbuf, count);\n\tif (ret)\n\t\treturn ret;\n\n\tif (strncmp(kbuf, OCFS2_CONTROL_PROTO, OCFS2_CONTROL_PROTO_LEN))\n\t\treturn -EINVAL;\n\n\tocfs2_control_set_handshake_state(file,\n\t\t\t\t\t  OCFS2_CONTROL_HANDSHAKE_PROTOCOL);\n\n\treturn count;\n}\n\nstatic void ocfs2_control_send_down(const char *uuid,\n\t\t\t\t    int nodenum)\n{\n\tstruct ocfs2_live_connection *c;\n\n\tmutex_lock(&ocfs2_control_lock);\n\n\tc = ocfs2_connection_find(uuid);\n\tif (c) {\n\t\tBUG_ON(c->oc_conn == NULL);\n\t\tc->oc_conn->cc_recovery_handler(nodenum,\n\t\t\t\t\t\tc->oc_conn->cc_recovery_data);\n\t}\n\n\tmutex_unlock(&ocfs2_control_lock);\n}\n\n \nstatic int ocfs2_control_install_private(struct file *file)\n{\n\tint rc = 0;\n\tint set_p = 1;\n\tstruct ocfs2_control_private *p = file->private_data;\n\n\tBUG_ON(p->op_state != OCFS2_CONTROL_HANDSHAKE_PROTOCOL);\n\n\tmutex_lock(&ocfs2_control_lock);\n\n\tif (p->op_this_node < 0) {\n\t\tset_p = 0;\n\t} else if ((ocfs2_control_this_node >= 0) &&\n\t\t   (ocfs2_control_this_node != p->op_this_node)) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!p->op_proto.pv_major) {\n\t\tset_p = 0;\n\t} else if (!list_empty(&ocfs2_live_connection_list) &&\n\t\t   ((running_proto.pv_major != p->op_proto.pv_major) ||\n\t\t    (running_proto.pv_minor != p->op_proto.pv_minor))) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (set_p) {\n\t\tocfs2_control_this_node = p->op_this_node;\n\t\trunning_proto.pv_major = p->op_proto.pv_major;\n\t\trunning_proto.pv_minor = p->op_proto.pv_minor;\n\t}\n\nout_unlock:\n\tmutex_unlock(&ocfs2_control_lock);\n\n\tif (!rc && set_p) {\n\t\t \n\t\tatomic_inc(&ocfs2_control_opened);\n\t\tocfs2_control_set_handshake_state(file,\n\t\t\t\t\tOCFS2_CONTROL_HANDSHAKE_VALID);\n\t}\n\n\treturn rc;\n}\n\nstatic int ocfs2_control_get_this_node(void)\n{\n\tint rc;\n\n\tmutex_lock(&ocfs2_control_lock);\n\tif (ocfs2_control_this_node < 0)\n\t\trc = -EINVAL;\n\telse\n\t\trc = ocfs2_control_this_node;\n\tmutex_unlock(&ocfs2_control_lock);\n\n\treturn rc;\n}\n\nstatic int ocfs2_control_do_setnode_msg(struct file *file,\n\t\t\t\t\tstruct ocfs2_control_message_setn *msg)\n{\n\tlong nodenum;\n\tchar *ptr = NULL;\n\tstruct ocfs2_control_private *p = file->private_data;\n\n\tif (ocfs2_control_get_handshake_state(file) !=\n\t    OCFS2_CONTROL_HANDSHAKE_PROTOCOL)\n\t\treturn -EINVAL;\n\n\tif (strncmp(msg->tag, OCFS2_CONTROL_MESSAGE_SETNODE_OP,\n\t\t    OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\treturn -EINVAL;\n\n\tif ((msg->space != ' ') || (msg->newline != '\\n'))\n\t\treturn -EINVAL;\n\tmsg->space = msg->newline = '\\0';\n\n\tnodenum = simple_strtol(msg->nodestr, &ptr, 16);\n\tif (!ptr || *ptr)\n\t\treturn -EINVAL;\n\n\tif ((nodenum == LONG_MIN) || (nodenum == LONG_MAX) ||\n\t    (nodenum > INT_MAX) || (nodenum < 0))\n\t\treturn -ERANGE;\n\tp->op_this_node = nodenum;\n\n\treturn ocfs2_control_install_private(file);\n}\n\nstatic int ocfs2_control_do_setversion_msg(struct file *file,\n\t\t\t\t\t   struct ocfs2_control_message_setv *msg)\n{\n\tlong major, minor;\n\tchar *ptr = NULL;\n\tstruct ocfs2_control_private *p = file->private_data;\n\tstruct ocfs2_protocol_version *max =\n\t\t&ocfs2_user_plugin.sp_max_proto;\n\n\tif (ocfs2_control_get_handshake_state(file) !=\n\t    OCFS2_CONTROL_HANDSHAKE_PROTOCOL)\n\t\treturn -EINVAL;\n\n\tif (strncmp(msg->tag, OCFS2_CONTROL_MESSAGE_SETVERSION_OP,\n\t\t    OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\treturn -EINVAL;\n\n\tif ((msg->space1 != ' ') || (msg->space2 != ' ') ||\n\t    (msg->newline != '\\n'))\n\t\treturn -EINVAL;\n\tmsg->space1 = msg->space2 = msg->newline = '\\0';\n\n\tmajor = simple_strtol(msg->major, &ptr, 16);\n\tif (!ptr || *ptr)\n\t\treturn -EINVAL;\n\tminor = simple_strtol(msg->minor, &ptr, 16);\n\tif (!ptr || *ptr)\n\t\treturn -EINVAL;\n\n\t \n\tif ((major == LONG_MIN) || (major == LONG_MAX) ||\n\t    (major > (u8)-1) || (major < 1))\n\t\treturn -ERANGE;\n\tif ((minor == LONG_MIN) || (minor == LONG_MAX) ||\n\t    (minor > (u8)-1) || (minor < 0))\n\t\treturn -ERANGE;\n\tif ((major != max->pv_major) ||\n\t    (minor > max->pv_minor))\n\t\treturn -EINVAL;\n\n\tp->op_proto.pv_major = major;\n\tp->op_proto.pv_minor = minor;\n\n\treturn ocfs2_control_install_private(file);\n}\n\nstatic int ocfs2_control_do_down_msg(struct file *file,\n\t\t\t\t     struct ocfs2_control_message_down *msg)\n{\n\tlong nodenum;\n\tchar *p = NULL;\n\n\tif (ocfs2_control_get_handshake_state(file) !=\n\t    OCFS2_CONTROL_HANDSHAKE_VALID)\n\t\treturn -EINVAL;\n\n\tif (strncmp(msg->tag, OCFS2_CONTROL_MESSAGE_DOWN_OP,\n\t\t    OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\treturn -EINVAL;\n\n\tif ((msg->space1 != ' ') || (msg->space2 != ' ') ||\n\t    (msg->newline != '\\n'))\n\t\treturn -EINVAL;\n\tmsg->space1 = msg->space2 = msg->newline = '\\0';\n\n\tnodenum = simple_strtol(msg->nodestr, &p, 16);\n\tif (!p || *p)\n\t\treturn -EINVAL;\n\n\tif ((nodenum == LONG_MIN) || (nodenum == LONG_MAX) ||\n\t    (nodenum > INT_MAX) || (nodenum < 0))\n\t\treturn -ERANGE;\n\n\tocfs2_control_send_down(msg->uuid, nodenum);\n\n\treturn 0;\n}\n\nstatic ssize_t ocfs2_control_message(struct file *file,\n\t\t\t\t     const char __user *buf,\n\t\t\t\t     size_t count)\n{\n\tssize_t ret;\n\tunion ocfs2_control_message msg;\n\n\t \n\tWARN_ON(offsetof(struct ocfs2_control_message_down, uuid) !=\n\t\t(sizeof(msg.u_down.tag) + sizeof(msg.u_down.space1)));\n\n\tmemset(&msg, 0, sizeof(union ocfs2_control_message));\n\tret = ocfs2_control_cfu(&msg, count, buf, count);\n\tif (ret)\n\t\tgoto out;\n\n\tif ((count == OCFS2_CONTROL_MESSAGE_SETNODE_TOTAL_LEN) &&\n\t    !strncmp(msg.tag, OCFS2_CONTROL_MESSAGE_SETNODE_OP,\n\t\t     OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\tret = ocfs2_control_do_setnode_msg(file, &msg.u_setn);\n\telse if ((count == OCFS2_CONTROL_MESSAGE_SETVERSION_TOTAL_LEN) &&\n\t\t !strncmp(msg.tag, OCFS2_CONTROL_MESSAGE_SETVERSION_OP,\n\t\t\t  OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\tret = ocfs2_control_do_setversion_msg(file, &msg.u_setv);\n\telse if ((count == OCFS2_CONTROL_MESSAGE_DOWN_TOTAL_LEN) &&\n\t\t !strncmp(msg.tag, OCFS2_CONTROL_MESSAGE_DOWN_OP,\n\t\t\t  OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\tret = ocfs2_control_do_down_msg(file, &msg.u_down);\n\telse\n\t\tret = -EINVAL;\n\nout:\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t ocfs2_control_write(struct file *file,\n\t\t\t\t   const char __user *buf,\n\t\t\t\t   size_t count,\n\t\t\t\t   loff_t *ppos)\n{\n\tssize_t ret;\n\n\tswitch (ocfs2_control_get_handshake_state(file)) {\n\t\tcase OCFS2_CONTROL_HANDSHAKE_INVALID:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\n\t\tcase OCFS2_CONTROL_HANDSHAKE_READ:\n\t\t\tret = ocfs2_control_validate_protocol(file, buf,\n\t\t\t\t\t\t\t      count);\n\t\t\tbreak;\n\n\t\tcase OCFS2_CONTROL_HANDSHAKE_PROTOCOL:\n\t\tcase OCFS2_CONTROL_HANDSHAKE_VALID:\n\t\t\tret = ocfs2_control_message(file, buf, count);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic ssize_t ocfs2_control_read(struct file *file,\n\t\t\t\t  char __user *buf,\n\t\t\t\t  size_t count,\n\t\t\t\t  loff_t *ppos)\n{\n\tssize_t ret;\n\n\tret = simple_read_from_buffer(buf, count, ppos,\n\t\t\tOCFS2_CONTROL_PROTO, OCFS2_CONTROL_PROTO_LEN);\n\n\t \n\tif (ret > 0 && *ppos >= OCFS2_CONTROL_PROTO_LEN)\n\t\tocfs2_control_set_handshake_state(file,\n\t\t\t\t\t\t  OCFS2_CONTROL_HANDSHAKE_READ);\n\n\treturn ret;\n}\n\nstatic int ocfs2_control_release(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\n\tmutex_lock(&ocfs2_control_lock);\n\n\tif (ocfs2_control_get_handshake_state(file) !=\n\t    OCFS2_CONTROL_HANDSHAKE_VALID)\n\t\tgoto out;\n\n\tif (atomic_dec_and_test(&ocfs2_control_opened)) {\n\t\tif (!list_empty(&ocfs2_live_connection_list)) {\n\t\t\t \n\t\t\tprintk(KERN_ERR\n\t\t\t       \"ocfs2: Unexpected release of ocfs2_control!\\n\"\n\t\t\t       \"       Loss of cluster connection requires \"\n\t\t\t       \"an emergency restart!\\n\");\n\t\t\temergency_restart();\n\t\t}\n\t\t \n\t\tocfs2_control_this_node = -1;\n\t\trunning_proto.pv_major = 0;\n\t\trunning_proto.pv_minor = 0;\n\t}\n\nout:\n\tlist_del_init(&p->op_list);\n\tfile->private_data = NULL;\n\n\tmutex_unlock(&ocfs2_control_lock);\n\n\tkfree(p);\n\n\treturn 0;\n}\n\nstatic int ocfs2_control_open(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_control_private *p;\n\n\tp = kzalloc(sizeof(struct ocfs2_control_private), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\tp->op_this_node = -1;\n\n\tmutex_lock(&ocfs2_control_lock);\n\tfile->private_data = p;\n\tlist_add(&p->op_list, &ocfs2_control_private_list);\n\tmutex_unlock(&ocfs2_control_lock);\n\n\treturn 0;\n}\n\nstatic const struct file_operations ocfs2_control_fops = {\n\t.open    = ocfs2_control_open,\n\t.release = ocfs2_control_release,\n\t.read    = ocfs2_control_read,\n\t.write   = ocfs2_control_write,\n\t.owner   = THIS_MODULE,\n\t.llseek  = default_llseek,\n};\n\nstatic struct miscdevice ocfs2_control_device = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"ocfs2_control\",\n\t.fops\t\t= &ocfs2_control_fops,\n};\n\nstatic int ocfs2_control_init(void)\n{\n\tint rc;\n\n\tatomic_set(&ocfs2_control_opened, 0);\n\n\trc = misc_register(&ocfs2_control_device);\n\tif (rc)\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Unable to register ocfs2_control device \"\n\t\t       \"(errno %d)\\n\",\n\t\t       -rc);\n\n\treturn rc;\n}\n\nstatic void ocfs2_control_exit(void)\n{\n\tmisc_deregister(&ocfs2_control_device);\n}\n\nstatic void fsdlm_lock_ast_wrapper(void *astarg)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\tint status = lksb->lksb_fsdlm.sb_status;\n\n\t \n\n\tif (status == -DLM_EUNLOCK || status == -DLM_ECANCEL)\n\t\tlksb->lksb_conn->cc_proto->lp_unlock_ast(lksb, 0);\n\telse\n\t\tlksb->lksb_conn->cc_proto->lp_lock_ast(lksb);\n}\n\nstatic void fsdlm_blocking_ast_wrapper(void *astarg, int level)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\n\tlksb->lksb_conn->cc_proto->lp_blocking_ast(lksb, level);\n}\n\nstatic int user_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t\t int mode,\n\t\t\t struct ocfs2_dlm_lksb *lksb,\n\t\t\t u32 flags,\n\t\t\t void *name,\n\t\t\t unsigned int namelen)\n{\n\tif (!lksb->lksb_fsdlm.sb_lvbptr)\n\t\tlksb->lksb_fsdlm.sb_lvbptr = (char *)lksb +\n\t\t\t\t\t     sizeof(struct dlm_lksb);\n\n\treturn dlm_lock(conn->cc_lockspace, mode, &lksb->lksb_fsdlm,\n\t\t\tflags|DLM_LKF_NODLCKWT, name, namelen, 0,\n\t\t\tfsdlm_lock_ast_wrapper, lksb,\n\t\t\tfsdlm_blocking_ast_wrapper);\n}\n\nstatic int user_dlm_unlock(struct ocfs2_cluster_connection *conn,\n\t\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t\t   u32 flags)\n{\n\treturn dlm_unlock(conn->cc_lockspace, lksb->lksb_fsdlm.sb_lkid,\n\t\t\t  flags, &lksb->lksb_fsdlm, lksb);\n}\n\nstatic int user_dlm_lock_status(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn lksb->lksb_fsdlm.sb_status;\n}\n\nstatic int user_dlm_lvb_valid(struct ocfs2_dlm_lksb *lksb)\n{\n\tint invalid = lksb->lksb_fsdlm.sb_flags & DLM_SBF_VALNOTVALID;\n\n\treturn !invalid;\n}\n\nstatic void *user_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\tif (!lksb->lksb_fsdlm.sb_lvbptr)\n\t\tlksb->lksb_fsdlm.sb_lvbptr = (char *)lksb +\n\t\t\t\t\t     sizeof(struct dlm_lksb);\n\treturn (void *)(lksb->lksb_fsdlm.sb_lvbptr);\n}\n\nstatic void user_dlm_dump_lksb(struct ocfs2_dlm_lksb *lksb)\n{\n}\n\nstatic int user_plock(struct ocfs2_cluster_connection *conn,\n\t\t      u64 ino,\n\t\t      struct file *file,\n\t\t      int cmd,\n\t\t      struct file_lock *fl)\n{\n\t \n\n\tif (cmd == F_CANCELLK)\n\t\treturn dlm_posix_cancel(conn->cc_lockspace, ino, file, fl);\n\telse if (IS_GETLK(cmd))\n\t\treturn dlm_posix_get(conn->cc_lockspace, ino, file, fl);\n\telse if (fl->fl_type == F_UNLCK)\n\t\treturn dlm_posix_unlock(conn->cc_lockspace, ino, file, fl);\n\telse\n\t\treturn dlm_posix_lock(conn->cc_lockspace, ino, file, cmd, fl);\n}\n\n \nstatic int fs_protocol_compare(struct ocfs2_protocol_version *existing,\n\t\t\t       struct ocfs2_protocol_version *request)\n{\n\tif (existing->pv_major != request->pv_major)\n\t\treturn 1;\n\n\tif (existing->pv_minor > request->pv_minor)\n\t\treturn 1;\n\n\tif (existing->pv_minor < request->pv_minor)\n\t\trequest->pv_minor = existing->pv_minor;\n\n\treturn 0;\n}\n\nstatic void lvb_to_version(char *lvb, struct ocfs2_protocol_version *ver)\n{\n\tstruct ocfs2_protocol_version *pv =\n\t\t(struct ocfs2_protocol_version *)lvb;\n\t \n\tver->pv_major = pv->pv_major;\n\tver->pv_minor = pv->pv_minor;\n}\n\nstatic void version_to_lvb(struct ocfs2_protocol_version *ver, char *lvb)\n{\n\tstruct ocfs2_protocol_version *pv =\n\t\t(struct ocfs2_protocol_version *)lvb;\n\t \n\tpv->pv_major = ver->pv_major;\n\tpv->pv_minor = ver->pv_minor;\n}\n\nstatic void sync_wait_cb(void *arg)\n{\n\tstruct ocfs2_cluster_connection *conn = arg;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\tcomplete(&lc->oc_sync_wait);\n}\n\nstatic int sync_unlock(struct ocfs2_cluster_connection *conn,\n\t\tstruct dlm_lksb *lksb, char *name)\n{\n\tint error;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\n\terror = dlm_unlock(conn->cc_lockspace, lksb->sb_lkid, 0, lksb, conn);\n\tif (error) {\n\t\tprintk(KERN_ERR \"%s lkid %x error %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&lc->oc_sync_wait);\n\n\tif (lksb->sb_status != -DLM_EUNLOCK) {\n\t\tprintk(KERN_ERR \"%s lkid %x status %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, lksb->sb_status);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int sync_lock(struct ocfs2_cluster_connection *conn,\n\t\tint mode, uint32_t flags,\n\t\tstruct dlm_lksb *lksb, char *name)\n{\n\tint error, status;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\n\terror = dlm_lock(conn->cc_lockspace, mode, lksb, flags,\n\t\t\tname, strlen(name),\n\t\t\t0, sync_wait_cb, conn, NULL);\n\tif (error) {\n\t\tprintk(KERN_ERR \"%s lkid %x flags %x mode %d error %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, flags, mode, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&lc->oc_sync_wait);\n\n\tstatus = lksb->sb_status;\n\n\tif (status && status != -EAGAIN) {\n\t\tprintk(KERN_ERR \"%s lkid %x flags %x mode %d status %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, flags, mode, status);\n\t}\n\n\treturn status;\n}\n\n\nstatic int version_lock(struct ocfs2_cluster_connection *conn, int mode,\n\t\tint flags)\n{\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\treturn sync_lock(conn, mode, flags,\n\t\t\t&lc->oc_version_lksb, VERSION_LOCK);\n}\n\nstatic int version_unlock(struct ocfs2_cluster_connection *conn)\n{\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\treturn sync_unlock(conn, &lc->oc_version_lksb, VERSION_LOCK);\n}\n\n \n\nstatic int get_protocol_version(struct ocfs2_cluster_connection *conn)\n{\n\tint ret;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\tstruct ocfs2_protocol_version pv;\n\n\trunning_proto.pv_major =\n\t\tocfs2_user_plugin.sp_max_proto.pv_major;\n\trunning_proto.pv_minor =\n\t\tocfs2_user_plugin.sp_max_proto.pv_minor;\n\n\tlc->oc_version_lksb.sb_lvbptr = lc->oc_lvb;\n\tret = version_lock(conn, DLM_LOCK_EX,\n\t\t\tDLM_LKF_VALBLK|DLM_LKF_NOQUEUE);\n\tif (!ret) {\n\t\tconn->cc_version.pv_major = running_proto.pv_major;\n\t\tconn->cc_version.pv_minor = running_proto.pv_minor;\n\t\tversion_to_lvb(&running_proto, lc->oc_lvb);\n\t\tversion_lock(conn, DLM_LOCK_PR, DLM_LKF_CONVERT|DLM_LKF_VALBLK);\n\t} else if (ret == -EAGAIN) {\n\t\tret = version_lock(conn, DLM_LOCK_PR, DLM_LKF_VALBLK);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tlvb_to_version(lc->oc_lvb, &pv);\n\n\t\tif ((pv.pv_major != running_proto.pv_major) ||\n\t\t\t\t(pv.pv_minor > running_proto.pv_minor)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tconn->cc_version.pv_major = pv.pv_major;\n\t\tconn->cc_version.pv_minor = pv.pv_minor;\n\t}\nout:\n\treturn ret;\n}\n\nstatic void user_recover_prep(void *arg)\n{\n}\n\nstatic void user_recover_slot(void *arg, struct dlm_slot *slot)\n{\n\tstruct ocfs2_cluster_connection *conn = arg;\n\tprintk(KERN_INFO \"ocfs2: Node %d/%d down. Initiating recovery.\\n\",\n\t\t\tslot->nodeid, slot->slot);\n\tconn->cc_recovery_handler(slot->nodeid, conn->cc_recovery_data);\n\n}\n\nstatic void user_recover_done(void *arg, struct dlm_slot *slots,\n\t\tint num_slots, int our_slot,\n\t\tuint32_t generation)\n{\n\tstruct ocfs2_cluster_connection *conn = arg;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\tint i;\n\n\tfor (i = 0; i < num_slots; i++)\n\t\tif (slots[i].slot == our_slot) {\n\t\t\tatomic_set(&lc->oc_this_node, slots[i].nodeid);\n\t\t\tbreak;\n\t\t}\n\n\tlc->oc_our_slot = our_slot;\n\twake_up(&lc->oc_wait);\n}\n\nstatic const struct dlm_lockspace_ops ocfs2_ls_ops = {\n\t.recover_prep = user_recover_prep,\n\t.recover_slot = user_recover_slot,\n\t.recover_done = user_recover_done,\n};\n\nstatic int user_cluster_disconnect(struct ocfs2_cluster_connection *conn)\n{\n\tversion_unlock(conn);\n\tdlm_release_lockspace(conn->cc_lockspace, 2);\n\tconn->cc_lockspace = NULL;\n\tocfs2_live_connection_drop(conn->cc_private);\n\tconn->cc_private = NULL;\n\treturn 0;\n}\n\nstatic int user_cluster_connect(struct ocfs2_cluster_connection *conn)\n{\n\tdlm_lockspace_t *fsdlm;\n\tstruct ocfs2_live_connection *lc;\n\tint rc, ops_rv;\n\n\tBUG_ON(conn == NULL);\n\n\tlc = kzalloc(sizeof(struct ocfs2_live_connection), GFP_KERNEL);\n\tif (!lc)\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head(&lc->oc_wait);\n\tinit_completion(&lc->oc_sync_wait);\n\tatomic_set(&lc->oc_this_node, 0);\n\tconn->cc_private = lc;\n\tlc->oc_type = NO_CONTROLD;\n\n\trc = dlm_new_lockspace(conn->cc_name, conn->cc_cluster_name,\n\t\t\t       DLM_LSFL_NEWEXCL, DLM_LVB_LEN,\n\t\t\t       &ocfs2_ls_ops, conn, &ops_rv, &fsdlm);\n\tif (rc) {\n\t\tif (rc == -EEXIST || rc == -EPROTO)\n\t\t\tprintk(KERN_ERR \"ocfs2: Unable to create the \"\n\t\t\t\t\"lockspace %s (%d), because a ocfs2-tools \"\n\t\t\t\t\"program is running on this file system \"\n\t\t\t\t\"with the same name lockspace\\n\",\n\t\t\t\tconn->cc_name, rc);\n\t\tgoto out;\n\t}\n\n\tif (ops_rv == -EOPNOTSUPP) {\n\t\tlc->oc_type = WITH_CONTROLD;\n\t\tprintk(KERN_NOTICE \"ocfs2: You seem to be using an older \"\n\t\t\t\t\"version of dlm_controld and/or ocfs2-tools.\"\n\t\t\t\t\" Please consider upgrading.\\n\");\n\t} else if (ops_rv) {\n\t\trc = ops_rv;\n\t\tgoto out;\n\t}\n\tconn->cc_lockspace = fsdlm;\n\n\trc = ocfs2_live_connection_attach(conn, lc);\n\tif (rc)\n\t\tgoto out;\n\n\tif (lc->oc_type == NO_CONTROLD) {\n\t\trc = get_protocol_version(conn);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"ocfs2: Could not determine\"\n\t\t\t\t\t\" locking version\\n\");\n\t\t\tuser_cluster_disconnect(conn);\n\t\t\tgoto out;\n\t\t}\n\t\twait_event(lc->oc_wait, (atomic_read(&lc->oc_this_node) > 0));\n\t}\n\n\t \n\tif (fs_protocol_compare(&running_proto, &conn->cc_version)) {\n\t\tprintk(KERN_ERR\n\t\t       \"Unable to mount with fs locking protocol version \"\n\t\t       \"%u.%u because negotiated protocol is %u.%u\\n\",\n\t\t       conn->cc_version.pv_major, conn->cc_version.pv_minor,\n\t\t       running_proto.pv_major, running_proto.pv_minor);\n\t\trc = -EPROTO;\n\t\tocfs2_live_connection_drop(lc);\n\t\tlc = NULL;\n\t}\n\nout:\n\tif (rc)\n\t\tkfree(lc);\n\treturn rc;\n}\n\n\nstatic int user_cluster_this_node(struct ocfs2_cluster_connection *conn,\n\t\t\t\t  unsigned int *this_node)\n{\n\tint rc;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\n\tif (lc->oc_type == WITH_CONTROLD)\n\t\trc = ocfs2_control_get_this_node();\n\telse if (lc->oc_type == NO_CONTROLD)\n\t\trc = atomic_read(&lc->oc_this_node);\n\telse\n\t\trc = -EINVAL;\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*this_node = rc;\n\treturn 0;\n}\n\nstatic struct ocfs2_stack_operations ocfs2_user_plugin_ops = {\n\t.connect\t= user_cluster_connect,\n\t.disconnect\t= user_cluster_disconnect,\n\t.this_node\t= user_cluster_this_node,\n\t.dlm_lock\t= user_dlm_lock,\n\t.dlm_unlock\t= user_dlm_unlock,\n\t.lock_status\t= user_dlm_lock_status,\n\t.lvb_valid\t= user_dlm_lvb_valid,\n\t.lock_lvb\t= user_dlm_lvb,\n\t.plock\t\t= user_plock,\n\t.dump_lksb\t= user_dlm_dump_lksb,\n};\n\nstatic struct ocfs2_stack_plugin ocfs2_user_plugin = {\n\t.sp_name\t= \"user\",\n\t.sp_ops\t\t= &ocfs2_user_plugin_ops,\n\t.sp_owner\t= THIS_MODULE,\n};\n\n\nstatic int __init ocfs2_user_plugin_init(void)\n{\n\tint rc;\n\n\trc = ocfs2_control_init();\n\tif (!rc) {\n\t\trc = ocfs2_stack_glue_register(&ocfs2_user_plugin);\n\t\tif (rc)\n\t\t\tocfs2_control_exit();\n\t}\n\n\treturn rc;\n}\n\nstatic void __exit ocfs2_user_plugin_exit(void)\n{\n\tocfs2_stack_glue_unregister(&ocfs2_user_plugin);\n\tocfs2_control_exit();\n}\n\nMODULE_AUTHOR(\"Oracle\");\nMODULE_DESCRIPTION(\"ocfs2 driver for userspace cluster stacks\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(ocfs2_user_plugin_init);\nmodule_exit(ocfs2_user_plugin_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}