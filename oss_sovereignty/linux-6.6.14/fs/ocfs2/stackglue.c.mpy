{
  "module_name": "stackglue.c",
  "hash_id": "fdb3dd2e800417ee8893d3876ecdf9f43dbe879f4786e574bb97df9a2a9ecb55",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/stackglue.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/fs.h>\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n\n#include \"ocfs2_fs.h\"\n\n#include \"stackglue.h\"\n\n#define OCFS2_STACK_PLUGIN_O2CB\t\t\"o2cb\"\n#define OCFS2_STACK_PLUGIN_USER\t\t\"user\"\n#define OCFS2_MAX_HB_CTL_PATH\t\t256\n\nstatic struct ocfs2_protocol_version locking_max_version;\nstatic DEFINE_SPINLOCK(ocfs2_stack_lock);\nstatic LIST_HEAD(ocfs2_stack_list);\nstatic char cluster_stack_name[OCFS2_STACK_LABEL_LEN + 1];\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\n \nstatic struct ocfs2_stack_plugin *active_stack;\n\nstatic struct ocfs2_stack_plugin *ocfs2_stack_lookup(const char *name)\n{\n\tstruct ocfs2_stack_plugin *p;\n\n\tassert_spin_locked(&ocfs2_stack_lock);\n\n\tlist_for_each_entry(p, &ocfs2_stack_list, sp_list) {\n\t\tif (!strcmp(p->sp_name, name))\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}\n\nstatic int ocfs2_stack_driver_request(const char *stack_name,\n\t\t\t\t      const char *plugin_name)\n{\n\tint rc;\n\tstruct ocfs2_stack_plugin *p;\n\n\tspin_lock(&ocfs2_stack_lock);\n\n\t \n\tif (strcmp(stack_name, cluster_stack_name)) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (active_stack) {\n\t\t \n\t\tif (!strcmp(active_stack->sp_name, plugin_name))\n\t\t\trc = 0;\n\t\telse\n\t\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tp = ocfs2_stack_lookup(plugin_name);\n\tif (!p || !try_module_get(p->sp_owner)) {\n\t\trc = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tactive_stack = p;\n\trc = 0;\n\nout:\n\t \n\tif (!rc)\n\t\tactive_stack->sp_count++;\n\n\tspin_unlock(&ocfs2_stack_lock);\n\treturn rc;\n}\n\n \nstatic int ocfs2_stack_driver_get(const char *stack_name)\n{\n\tint rc;\n\tchar *plugin_name = OCFS2_STACK_PLUGIN_O2CB;\n\n\t \n\tif (!stack_name || !*stack_name)\n\t\tstack_name = OCFS2_STACK_PLUGIN_O2CB;\n\n\tif (strlen(stack_name) != OCFS2_STACK_LABEL_LEN) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2 passed an invalid cluster stack label: \\\"%s\\\"\\n\",\n\t\t       stack_name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (strcmp(stack_name, OCFS2_STACK_PLUGIN_O2CB))\n\t\tplugin_name = OCFS2_STACK_PLUGIN_USER;\n\n\trc = ocfs2_stack_driver_request(stack_name, plugin_name);\n\tif (rc == -ENOENT) {\n\t\trequest_module(\"ocfs2_stack_%s\", plugin_name);\n\t\trc = ocfs2_stack_driver_request(stack_name, plugin_name);\n\t}\n\n\tif (rc == -ENOENT) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Cluster stack driver \\\"%s\\\" cannot be found\\n\",\n\t\t       plugin_name);\n\t} else if (rc == -EBUSY) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: A different cluster stack is in use\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic void ocfs2_stack_driver_put(void)\n{\n\tspin_lock(&ocfs2_stack_lock);\n\tBUG_ON(active_stack == NULL);\n\tBUG_ON(active_stack->sp_count == 0);\n\n\tactive_stack->sp_count--;\n\tif (!active_stack->sp_count) {\n\t\tmodule_put(active_stack->sp_owner);\n\t\tactive_stack = NULL;\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n}\n\nint ocfs2_stack_glue_register(struct ocfs2_stack_plugin *plugin)\n{\n\tint rc;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tif (!ocfs2_stack_lookup(plugin->sp_name)) {\n\t\tplugin->sp_count = 0;\n\t\tplugin->sp_max_proto = locking_max_version;\n\t\tlist_add(&plugin->sp_list, &ocfs2_stack_list);\n\t\tprintk(KERN_INFO \"ocfs2: Registered cluster interface %s\\n\",\n\t\t       plugin->sp_name);\n\t\trc = 0;\n\t} else {\n\t\tprintk(KERN_ERR \"ocfs2: Stack \\\"%s\\\" already registered\\n\",\n\t\t       plugin->sp_name);\n\t\trc = -EEXIST;\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ocfs2_stack_glue_register);\n\nvoid ocfs2_stack_glue_unregister(struct ocfs2_stack_plugin *plugin)\n{\n\tstruct ocfs2_stack_plugin *p;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tp = ocfs2_stack_lookup(plugin->sp_name);\n\tif (p) {\n\t\tBUG_ON(p != plugin);\n\t\tBUG_ON(plugin == active_stack);\n\t\tBUG_ON(plugin->sp_count != 0);\n\t\tlist_del_init(&plugin->sp_list);\n\t\tprintk(KERN_INFO \"ocfs2: Unregistered cluster interface %s\\n\",\n\t\t       plugin->sp_name);\n\t} else {\n\t\tprintk(KERN_ERR \"Stack \\\"%s\\\" is not registered\\n\",\n\t\t       plugin->sp_name);\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n}\nEXPORT_SYMBOL_GPL(ocfs2_stack_glue_unregister);\n\nvoid ocfs2_stack_glue_set_max_proto_version(struct ocfs2_protocol_version *max_proto)\n{\n\tstruct ocfs2_stack_plugin *p;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tif (memcmp(max_proto, &locking_max_version,\n\t\t   sizeof(struct ocfs2_protocol_version))) {\n\t\tBUG_ON(locking_max_version.pv_major != 0);\n\n\t\tlocking_max_version = *max_proto;\n\t\tlist_for_each_entry(p, &ocfs2_stack_list, sp_list) {\n\t\t\tp->sp_max_proto = locking_max_version;\n\t\t}\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n}\nEXPORT_SYMBOL_GPL(ocfs2_stack_glue_set_max_proto_version);\n\n\n \nint ocfs2_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t   int mode,\n\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t   u32 flags,\n\t\t   void *name,\n\t\t   unsigned int namelen)\n{\n\tif (!lksb->lksb_conn)\n\t\tlksb->lksb_conn = conn;\n\telse\n\t\tBUG_ON(lksb->lksb_conn != conn);\n\treturn active_stack->sp_ops->dlm_lock(conn, mode, lksb, flags,\n\t\t\t\t\t      name, namelen);\n}\nEXPORT_SYMBOL_GPL(ocfs2_dlm_lock);\n\nint ocfs2_dlm_unlock(struct ocfs2_cluster_connection *conn,\n\t\t     struct ocfs2_dlm_lksb *lksb,\n\t\t     u32 flags)\n{\n\tBUG_ON(lksb->lksb_conn == NULL);\n\n\treturn active_stack->sp_ops->dlm_unlock(conn, lksb, flags);\n}\nEXPORT_SYMBOL_GPL(ocfs2_dlm_unlock);\n\nint ocfs2_dlm_lock_status(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_status(lksb);\n}\nEXPORT_SYMBOL_GPL(ocfs2_dlm_lock_status);\n\nint ocfs2_dlm_lvb_valid(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lvb_valid(lksb);\n}\nEXPORT_SYMBOL_GPL(ocfs2_dlm_lvb_valid);\n\nvoid *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}\nEXPORT_SYMBOL_GPL(ocfs2_dlm_lvb);\n\nvoid ocfs2_dlm_dump_lksb(struct ocfs2_dlm_lksb *lksb)\n{\n\tactive_stack->sp_ops->dump_lksb(lksb);\n}\nEXPORT_SYMBOL_GPL(ocfs2_dlm_dump_lksb);\n\nint ocfs2_stack_supports_plocks(void)\n{\n\treturn active_stack && active_stack->sp_ops->plock;\n}\nEXPORT_SYMBOL_GPL(ocfs2_stack_supports_plocks);\n\n \nint ocfs2_plock(struct ocfs2_cluster_connection *conn, u64 ino,\n\t\tstruct file *file, int cmd, struct file_lock *fl)\n{\n\tWARN_ON_ONCE(active_stack->sp_ops->plock == NULL);\n\tif (active_stack->sp_ops->plock)\n\t\treturn active_stack->sp_ops->plock(conn, ino, file, cmd, fl);\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL_GPL(ocfs2_plock);\n\nint ocfs2_cluster_connect(const char *stack_name,\n\t\t\t  const char *cluster_name,\n\t\t\t  int cluster_name_len,\n\t\t\t  const char *group,\n\t\t\t  int grouplen,\n\t\t\t  struct ocfs2_locking_protocol *lproto,\n\t\t\t  void (*recovery_handler)(int node_num,\n\t\t\t\t\t\t   void *recovery_data),\n\t\t\t  void *recovery_data,\n\t\t\t  struct ocfs2_cluster_connection **conn)\n{\n\tint rc = 0;\n\tstruct ocfs2_cluster_connection *new_conn;\n\n\tBUG_ON(group == NULL);\n\tBUG_ON(conn == NULL);\n\tBUG_ON(recovery_handler == NULL);\n\n\tif (grouplen > GROUP_NAME_MAX) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (memcmp(&lproto->lp_max_version, &locking_max_version,\n\t\t   sizeof(struct ocfs2_protocol_version))) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnew_conn = kzalloc(sizeof(struct ocfs2_cluster_connection),\n\t\t\t   GFP_KERNEL);\n\tif (!new_conn) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tstrscpy(new_conn->cc_name, group, GROUP_NAME_MAX + 1);\n\tnew_conn->cc_namelen = grouplen;\n\tif (cluster_name_len)\n\t\tstrscpy(new_conn->cc_cluster_name, cluster_name,\n\t\t\tCLUSTER_NAME_MAX + 1);\n\tnew_conn->cc_cluster_name_len = cluster_name_len;\n\tnew_conn->cc_recovery_handler = recovery_handler;\n\tnew_conn->cc_recovery_data = recovery_data;\n\n\tnew_conn->cc_proto = lproto;\n\t \n\tnew_conn->cc_version = lproto->lp_max_version;\n\n\t \n\trc = ocfs2_stack_driver_get(stack_name);\n\tif (rc)\n\t\tgoto out_free;\n\n\trc = active_stack->sp_ops->connect(new_conn);\n\tif (rc) {\n\t\tocfs2_stack_driver_put();\n\t\tgoto out_free;\n\t}\n\n\t*conn = new_conn;\n\nout_free:\n\tif (rc)\n\t\tkfree(new_conn);\n\nout:\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ocfs2_cluster_connect);\n\n \nint ocfs2_cluster_connect_agnostic(const char *group,\n\t\t\t\t   int grouplen,\n\t\t\t\t   struct ocfs2_locking_protocol *lproto,\n\t\t\t\t   void (*recovery_handler)(int node_num,\n\t\t\t\t\t\t\t    void *recovery_data),\n\t\t\t\t   void *recovery_data,\n\t\t\t\t   struct ocfs2_cluster_connection **conn)\n{\n\tchar *stack_name = NULL;\n\n\tif (cluster_stack_name[0])\n\t\tstack_name = cluster_stack_name;\n\treturn ocfs2_cluster_connect(stack_name, NULL, 0, group, grouplen,\n\t\t\t\t     lproto, recovery_handler, recovery_data,\n\t\t\t\t     conn);\n}\nEXPORT_SYMBOL_GPL(ocfs2_cluster_connect_agnostic);\n\n \nint ocfs2_cluster_disconnect(struct ocfs2_cluster_connection *conn,\n\t\t\t     int hangup_pending)\n{\n\tint ret;\n\n\tBUG_ON(conn == NULL);\n\n\tret = active_stack->sp_ops->disconnect(conn);\n\n\t \n\tif (!ret) {\n\t\tkfree(conn);\n\t\tif (!hangup_pending)\n\t\t\tocfs2_stack_driver_put();\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ocfs2_cluster_disconnect);\n\n \nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t \n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}\n\n \nvoid ocfs2_cluster_hangup(const char *group, int grouplen)\n{\n\tBUG_ON(group == NULL);\n\tBUG_ON(group[grouplen] != '\\0');\n\n\tocfs2_leave_group(group);\n\n\t \n\tocfs2_stack_driver_put();\n}\nEXPORT_SYMBOL_GPL(ocfs2_cluster_hangup);\n\nint ocfs2_cluster_this_node(struct ocfs2_cluster_connection *conn,\n\t\t\t    unsigned int *node)\n{\n\treturn active_stack->sp_ops->this_node(conn, node);\n}\nEXPORT_SYMBOL_GPL(ocfs2_cluster_this_node);\n\n\n \n\nstatic ssize_t ocfs2_max_locking_protocol_show(struct kobject *kobj,\n\t\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t\t       char *buf)\n{\n\tssize_t ret = 0;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tif (locking_max_version.pv_major)\n\t\tret = snprintf(buf, PAGE_SIZE, \"%u.%u\\n\",\n\t\t\t       locking_max_version.pv_major,\n\t\t\t       locking_max_version.pv_minor);\n\tspin_unlock(&ocfs2_stack_lock);\n\n\treturn ret;\n}\n\nstatic struct kobj_attribute ocfs2_attr_max_locking_protocol =\n\t__ATTR(max_locking_protocol, S_IRUGO,\n\t       ocfs2_max_locking_protocol_show, NULL);\n\nstatic ssize_t ocfs2_loaded_cluster_plugins_show(struct kobject *kobj,\n\t\t\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t\t\t char *buf)\n{\n\tssize_t ret = 0, total = 0, remain = PAGE_SIZE;\n\tstruct ocfs2_stack_plugin *p;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tlist_for_each_entry(p, &ocfs2_stack_list, sp_list) {\n\t\tret = snprintf(buf, remain, \"%s\\n\",\n\t\t\t       p->sp_name);\n\t\tif (ret >= remain) {\n\t\t\t \n\t\t\ttotal = -E2BIG;\n\t\t\tbreak;\n\t\t}\n\t\ttotal += ret;\n\t\tremain -= ret;\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n\n\treturn total;\n}\n\nstatic struct kobj_attribute ocfs2_attr_loaded_cluster_plugins =\n\t__ATTR(loaded_cluster_plugins, S_IRUGO,\n\t       ocfs2_loaded_cluster_plugins_show, NULL);\n\nstatic ssize_t ocfs2_active_cluster_plugin_show(struct kobject *kobj,\n\t\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\t\tchar *buf)\n{\n\tssize_t ret = 0;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tif (active_stack) {\n\t\tret = snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\t       active_stack->sp_name);\n\t\tif (ret >= PAGE_SIZE)\n\t\t\tret = -E2BIG;\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n\n\treturn ret;\n}\n\nstatic struct kobj_attribute ocfs2_attr_active_cluster_plugin =\n\t__ATTR(active_cluster_plugin, S_IRUGO,\n\t       ocfs2_active_cluster_plugin_show, NULL);\n\nstatic ssize_t ocfs2_cluster_stack_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tssize_t ret;\n\tspin_lock(&ocfs2_stack_lock);\n\tret = snprintf(buf, PAGE_SIZE, \"%s\\n\", cluster_stack_name);\n\tspin_unlock(&ocfs2_stack_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t ocfs2_cluster_stack_store(struct kobject *kobj,\n\t\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tsize_t len = count;\n\tssize_t ret;\n\n\tif (len == 0)\n\t\treturn len;\n\n\tif (buf[len - 1] == '\\n')\n\t\tlen--;\n\n\tif ((len != OCFS2_STACK_LABEL_LEN) ||\n\t    (strnlen(buf, len) != len))\n\t\treturn -EINVAL;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tif (active_stack) {\n\t\tif (!strncmp(buf, cluster_stack_name, len))\n\t\t\tret = count;\n\t\telse\n\t\t\tret = -EBUSY;\n\t} else {\n\t\tmemcpy(cluster_stack_name, buf, len);\n\t\tret = count;\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n\n\treturn ret;\n}\n\n\nstatic struct kobj_attribute ocfs2_attr_cluster_stack =\n\t__ATTR(cluster_stack, S_IRUGO | S_IWUSR,\n\t       ocfs2_cluster_stack_show,\n\t       ocfs2_cluster_stack_store);\n\n\n\nstatic ssize_t ocfs2_dlm_recover_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"1\\n\");\n}\n\nstatic struct kobj_attribute ocfs2_attr_dlm_recover_support =\n\t__ATTR(dlm_recover_callback_support, S_IRUGO,\n\t       ocfs2_dlm_recover_show, NULL);\n\nstatic struct attribute *ocfs2_attrs[] = {\n\t&ocfs2_attr_max_locking_protocol.attr,\n\t&ocfs2_attr_loaded_cluster_plugins.attr,\n\t&ocfs2_attr_active_cluster_plugin.attr,\n\t&ocfs2_attr_cluster_stack.attr,\n\t&ocfs2_attr_dlm_recover_support.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ocfs2_attr_group = {\n\t.attrs = ocfs2_attrs,\n};\n\nstruct kset *ocfs2_kset;\nEXPORT_SYMBOL_GPL(ocfs2_kset);\n\nstatic void ocfs2_sysfs_exit(void)\n{\n\tkset_unregister(ocfs2_kset);\n}\n\nstatic int ocfs2_sysfs_init(void)\n{\n\tint ret;\n\n\tocfs2_kset = kset_create_and_add(\"ocfs2\", NULL, fs_kobj);\n\tif (!ocfs2_kset)\n\t\treturn -ENOMEM;\n\n\tret = sysfs_create_group(&ocfs2_kset->kobj, &ocfs2_attr_group);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tkset_unregister(ocfs2_kset);\n\treturn ret;\n}\n\n \n\nstatic struct ctl_table ocfs2_nm_table[] = {\n\t{\n\t\t.procname\t= \"hb_ctl_path\",\n\t\t.data\t\t= ocfs2_hb_ctl_path,\n\t\t.maxlen\t\t= OCFS2_MAX_HB_CTL_PATH,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dostring,\n\t},\n\t{ }\n};\n\nstatic struct ctl_table_header *ocfs2_table_header;\n\n \n\nstatic int __init ocfs2_stack_glue_init(void)\n{\n\tint ret;\n\n\tstrcpy(cluster_stack_name, OCFS2_STACK_PLUGIN_O2CB);\n\n\tocfs2_table_header = register_sysctl(\"fs/ocfs2/nm\", ocfs2_nm_table);\n\tif (!ocfs2_table_header) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2 stack glue: unable to register sysctl\\n\");\n\t\treturn -ENOMEM;  \n\t}\n\n\tret = ocfs2_sysfs_init();\n\tif (ret)\n\t\tunregister_sysctl_table(ocfs2_table_header);\n\n\treturn ret;\n}\n\nstatic void __exit ocfs2_stack_glue_exit(void)\n{\n\tmemset(&locking_max_version, 0,\n\t       sizeof(struct ocfs2_protocol_version));\n\tocfs2_sysfs_exit();\n\tif (ocfs2_table_header)\n\t\tunregister_sysctl_table(ocfs2_table_header);\n}\n\nMODULE_AUTHOR(\"Oracle\");\nMODULE_DESCRIPTION(\"ocfs2 cluster stack glue layer\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(ocfs2_stack_glue_init);\nmodule_exit(ocfs2_stack_glue_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}