{
  "module_name": "journal.h",
  "hash_id": "8662ac3ac00b1f1ae1d3ba220eefdac871dab6c2755ff5b65bf6c55873844465",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/journal.h",
  "human_readable_source": " \n \n\n#ifndef OCFS2_JOURNAL_H\n#define OCFS2_JOURNAL_H\n\n#include <linux/fs.h>\n#include <linux/jbd2.h>\n\nenum ocfs2_journal_state {\n\tOCFS2_JOURNAL_FREE = 0,\n\tOCFS2_JOURNAL_LOADED,\n\tOCFS2_JOURNAL_IN_SHUTDOWN,\n};\n\nstruct ocfs2_super;\nstruct ocfs2_dinode;\n\n \n\nstruct ocfs2_recovery_map {\n\tunsigned int rm_used;\n\tunsigned int rm_entries[];\n};\n\n\nstruct ocfs2_journal {\n\tenum ocfs2_journal_state   j_state;     \n\n\tjournal_t                 *j_journal;  \n\tstruct inode              *j_inode;    \n\tstruct ocfs2_super        *j_osb;      \n\tstruct buffer_head        *j_bh;       \n\tatomic_t                  j_num_trans;  \n\tspinlock_t                j_lock;\n\tunsigned long             j_trans_id;\n\tstruct rw_semaphore       j_trans_barrier;\n\twait_queue_head_t         j_checkpointed;\n\n\t \n\tstruct list_head          j_la_cleanups;\n\tstruct work_struct        j_recovery_work;\n};\n\nextern spinlock_t trans_inc_lock;\n\n \nstatic inline unsigned long ocfs2_inc_trans_id(struct ocfs2_journal *j)\n{\n\tunsigned long old_id;\n\tspin_lock(&trans_inc_lock);\n\told_id = j->j_trans_id++;\n\tif (unlikely(!j->j_trans_id))\n\t\tj->j_trans_id = 1;\n\tspin_unlock(&trans_inc_lock);\n\treturn old_id;\n}\n\nstatic inline void ocfs2_set_ci_lock_trans(struct ocfs2_journal *journal,\n\t\t\t\t\t   struct ocfs2_caching_info *ci)\n{\n\tspin_lock(&trans_inc_lock);\n\tci->ci_last_trans = journal->j_trans_id;\n\tspin_unlock(&trans_inc_lock);\n}\n\n \nstatic inline int ocfs2_ci_fully_checkpointed(struct ocfs2_caching_info *ci)\n{\n\tint ret;\n\tstruct ocfs2_journal *journal =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci))->journal;\n\n\tspin_lock(&trans_inc_lock);\n\tret = time_after(journal->j_trans_id, ci->ci_last_trans);\n\tspin_unlock(&trans_inc_lock);\n\treturn ret;\n}\n\n \nstatic inline int ocfs2_ci_is_new(struct ocfs2_caching_info *ci)\n{\n\tint ret;\n\tstruct ocfs2_journal *journal =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci))->journal;\n\n\tspin_lock(&trans_inc_lock);\n\tret = !(time_after(journal->j_trans_id, ci->ci_created_trans));\n\tif (!ret)\n\t\tci->ci_created_trans = 0;\n\tspin_unlock(&trans_inc_lock);\n\treturn ret;\n}\n\n \nstatic inline int ocfs2_inode_is_new(struct inode *inode)\n{\n\t \n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SYSTEM_FILE)\n\t\treturn 0;\n\n\treturn ocfs2_ci_is_new(INODE_CACHE(inode));\n}\n\nstatic inline void ocfs2_ci_set_new(struct ocfs2_super *osb,\n\t\t\t\t    struct ocfs2_caching_info *ci)\n{\n\tspin_lock(&trans_inc_lock);\n\tci->ci_created_trans = osb->journal->j_trans_id;\n\tspin_unlock(&trans_inc_lock);\n}\n\n \nvoid ocfs2_orphan_scan_init(struct ocfs2_super *osb);\nvoid ocfs2_orphan_scan_start(struct ocfs2_super *osb);\nvoid ocfs2_orphan_scan_stop(struct ocfs2_super *osb);\n\nvoid ocfs2_complete_recovery(struct work_struct *work);\nvoid ocfs2_wait_for_recovery(struct ocfs2_super *osb);\n\nint ocfs2_recovery_init(struct ocfs2_super *osb);\nvoid ocfs2_recovery_exit(struct ocfs2_super *osb);\n\nint ocfs2_compute_replay_slots(struct ocfs2_super *osb);\nvoid ocfs2_free_replay_slots(struct ocfs2_super *osb);\n \nvoid   ocfs2_set_journal_params(struct ocfs2_super *osb);\nint    ocfs2_journal_alloc(struct ocfs2_super *osb);\nint    ocfs2_journal_init(struct ocfs2_super *osb, int *dirty);\nvoid   ocfs2_journal_shutdown(struct ocfs2_super *osb);\nint    ocfs2_journal_wipe(struct ocfs2_journal *journal,\n\t\t\t  int full);\nint    ocfs2_journal_load(struct ocfs2_journal *journal, int local,\n\t\t\t  int replayed);\nint    ocfs2_check_journals_nolocks(struct ocfs2_super *osb);\nvoid   ocfs2_recovery_thread(struct ocfs2_super *osb,\n\t\t\t     int node_num);\nint    ocfs2_mark_dead_nodes(struct ocfs2_super *osb);\nvoid   ocfs2_complete_mount_recovery(struct ocfs2_super *osb);\nvoid ocfs2_complete_quota_recovery(struct ocfs2_super *osb);\n\nstatic inline void ocfs2_start_checkpoint(struct ocfs2_super *osb)\n{\n\twake_up(&osb->checkpoint_event);\n}\n\nstatic inline void ocfs2_checkpoint_inode(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn;\n\n\tif (!ocfs2_ci_fully_checkpointed(INODE_CACHE(inode))) {\n\t\t \n\t\tocfs2_start_checkpoint(osb);\n\n\t\twait_event(osb->journal->j_checkpointed,\n\t\t\t   ocfs2_ci_fully_checkpointed(INODE_CACHE(inode)));\n\t}\n}\n\n \n\n \nhandle_t\t\t    *ocfs2_start_trans(struct ocfs2_super *osb,\n\t\t\t\t\t       int max_buffs);\nint\t\t\t     ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t\t\t\t\thandle_t *handle);\nint\t\t\t     ocfs2_extend_trans(handle_t *handle, int nblocks);\nint\t\t\t     ocfs2_allocate_extend_trans(handle_t *handle,\n\t\t\t\t\t\tint thresh);\n\n \n#define OCFS2_MAX_TRANS_DATA\t64U\n\n \n#define OCFS2_JOURNAL_ACCESS_CREATE 0\n#define OCFS2_JOURNAL_ACCESS_WRITE  1\n#define OCFS2_JOURNAL_ACCESS_UNDO   2\n\n\n \nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type);\n \nint ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type);\n \nint ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type);\n \nint ocfs2_journal_access_gd(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type);\n \nint ocfs2_journal_access_xb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type);\n \nint ocfs2_journal_access_dq(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type);\n \nint ocfs2_journal_access_db(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type);\n \nint ocfs2_journal_access_dr(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type);\n \nint ocfs2_journal_access_dl(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type);\n \nint ocfs2_journal_access(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t struct buffer_head *bh, int type);\n\n \nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh);\n\n \n\n \n#define OCFS2_INODE_UPDATE_CREDITS 1\n\n \n#define OCFS2_XATTR_BLOCK_UPDATE_CREDITS 1\n\n \n#define OCFS2_QUOTA_BLOCK_UPDATE_CREDITS 1\n\n \n#define OCFS2_QINFO_WRITE_CREDITS (OCFS2_INODE_UPDATE_CREDITS + \\\n\t\t\t\t   OCFS2_QUOTA_BLOCK_UPDATE_CREDITS)\n\n#define OCFS2_LOCAL_QINFO_WRITE_CREDITS OCFS2_QUOTA_BLOCK_UPDATE_CREDITS\n \n \n \n#define OCFS2_QWRITE_CREDITS (OCFS2_QINFO_WRITE_CREDITS + \\\n\t\t\t      OCFS2_QUOTA_BLOCK_UPDATE_CREDITS)\n\n \n#define OCFS2_QSYNC_CREDITS (OCFS2_QINFO_WRITE_CREDITS + \\\n\t\t\t     2 * OCFS2_QUOTA_BLOCK_UPDATE_CREDITS)\n\nstatic inline int ocfs2_quota_trans_credits(struct super_block *sb)\n{\n\tint credits = 0;\n\n\tif (OCFS2_HAS_RO_COMPAT_FEATURE(sb, OCFS2_FEATURE_RO_COMPAT_USRQUOTA))\n\t\tcredits += OCFS2_QWRITE_CREDITS;\n\tif (OCFS2_HAS_RO_COMPAT_FEATURE(sb, OCFS2_FEATURE_RO_COMPAT_GRPQUOTA))\n\t\tcredits += OCFS2_QWRITE_CREDITS;\n\treturn credits;\n}\n\n \n#define OCFS2_GROUP_EXTEND_CREDITS\t(OCFS2_INODE_UPDATE_CREDITS + 1)\n\n \n#define OCFS2_GROUP_ADD_CREDITS\t(OCFS2_INODE_UPDATE_CREDITS + 1)\n\n \n#define OCFS2_SUBALLOC_ALLOC (3)\n\nstatic inline int ocfs2_inline_to_extents_credits(struct super_block *sb)\n{\n\treturn OCFS2_SUBALLOC_ALLOC + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}\n\n \n#define OCFS2_SUBALLOC_FREE  (2)\n\n#define OCFS2_TRUNCATE_LOG_UPDATE OCFS2_INODE_UPDATE_CREDITS\n#define OCFS2_TRUNCATE_LOG_FLUSH_ONE_REC (OCFS2_SUBALLOC_FREE \t\t      \\\n\t\t\t\t\t + OCFS2_TRUNCATE_LOG_UPDATE)\n\nstatic inline int ocfs2_remove_extent_credits(struct super_block *sb)\n{\n\treturn OCFS2_TRUNCATE_LOG_UPDATE + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}\n\n \n#define OCFS2_DIR_LINK_ADDITIONAL_CREDITS (1 + OCFS2_SUBALLOC_ALLOC + 1)\n\nstatic inline int ocfs2_add_dir_index_credits(struct super_block *sb)\n{\n\t \n\treturn 1 + 2 * OCFS2_SUBALLOC_ALLOC +\n\t\tocfs2_clusters_to_blocks(sb, 1);\n}\n\n \nstatic inline int ocfs2_mknod_credits(struct super_block *sb, int is_dir,\n\t\t\t\t      int xattr_credits)\n{\n\tint dir_credits = OCFS2_DIR_LINK_ADDITIONAL_CREDITS;\n\n\tif (is_dir)\n\t\tdir_credits += ocfs2_add_dir_index_credits(sb);\n\n\treturn 4 + OCFS2_SUBALLOC_ALLOC + dir_credits + xattr_credits +\n\t       ocfs2_quota_trans_credits(sb);\n}\n\n \n#define OCFS2_WINDOW_MOVE_CREDITS (OCFS2_INODE_UPDATE_CREDITS                 \\\n\t\t\t\t  + OCFS2_SUBALLOC_ALLOC + OCFS2_SUBALLOC_FREE)\n\n \n#define OCFS2_SIMPLE_DIR_EXTEND_CREDITS (2)\n\n \nstatic inline int ocfs2_link_credits(struct super_block *sb)\n{\n\treturn 2 * OCFS2_INODE_UPDATE_CREDITS + 4 +\n\t       ocfs2_quota_trans_credits(sb);\n}\n\n \nstatic inline int ocfs2_unlink_credits(struct super_block *sb)\n{\n\t \n\treturn 2 * OCFS2_INODE_UPDATE_CREDITS + 3 + ocfs2_link_credits(sb);\n}\n\n \n#define OCFS2_DELETE_INODE_CREDITS (3 * OCFS2_INODE_UPDATE_CREDITS + 4)\n\n \n#define OCFS2_INODE_ADD_TO_ORPHAN_CREDITS  (2 * OCFS2_INODE_UPDATE_CREDITS + 4)\n#define OCFS2_INODE_DEL_FROM_ORPHAN_CREDITS  OCFS2_INODE_ADD_TO_ORPHAN_CREDITS\n\n \nstatic inline int ocfs2_rename_credits(struct super_block *sb)\n{\n\treturn 3 * OCFS2_INODE_UPDATE_CREDITS + 6 + ocfs2_unlink_credits(sb);\n}\n\n \n#define OCFS2_XATTR_BLOCK_CREATE_CREDITS (OCFS2_SUBALLOC_ALLOC * 2 + \\\n\t\t\t\t\t  + OCFS2_INODE_UPDATE_CREDITS \\\n\t\t\t\t\t  + OCFS2_XATTR_BLOCK_UPDATE_CREDITS)\n\n \n#define OCFS2_DX_ROOT_REMOVE_CREDITS (OCFS2_INODE_UPDATE_CREDITS +\t\\\n\t\t\t\t      OCFS2_SUBALLOC_FREE)\n\nstatic inline int ocfs2_calc_dxi_expand_credits(struct super_block *sb)\n{\n\tint credits = 1 + OCFS2_SUBALLOC_ALLOC;\n\n\tcredits += ocfs2_clusters_to_blocks(sb, 1);\n\tcredits += ocfs2_quota_trans_credits(sb);\n\n\treturn credits;\n}\n\n \n#define OCFS2_REFCOUNT_TREE_CREATE_CREDITS (OCFS2_INODE_UPDATE_CREDITS + 1 \\\n\t\t\t\t\t    + OCFS2_SUBALLOC_ALLOC)\n\n \n#define OCFS2_REFCOUNT_TREE_SET_CREDITS (OCFS2_INODE_UPDATE_CREDITS + 1)\n\n \n#define OCFS2_REFCOUNT_TREE_REMOVE_CREDITS (OCFS2_INODE_UPDATE_CREDITS + 1)\n\n \n#define OCFS2_EXPAND_REFCOUNT_TREE_CREDITS (OCFS2_SUBALLOC_ALLOC * 2 + 3)\n\n \nstatic inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t \n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t \n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t \n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}\n\nstatic inline int ocfs2_calc_symlink_credits(struct super_block *sb)\n{\n\tint blocks = ocfs2_mknod_credits(sb, 0, 0);\n\n\t \n\tblocks += ocfs2_clusters_to_blocks(sb, 1);\n\n\treturn blocks + ocfs2_quota_trans_credits(sb);\n}\n\nstatic inline int ocfs2_calc_group_alloc_credits(struct super_block *sb,\n\t\t\t\t\t\t unsigned int cpg)\n{\n\tint blocks;\n\tint bitmap_blocks = OCFS2_SUBALLOC_ALLOC + 1;\n\t \n\tblocks = 1 + 1 + 1 + bitmap_blocks;\n\treturn blocks;\n}\n\n \nstatic inline int ocfs2_calc_bg_discontig_credits(struct super_block *sb)\n{\n\treturn ocfs2_extent_recs_per_gd(sb);\n}\n\nstatic inline int ocfs2_jbd2_inode_add_write(handle_t *handle, struct inode *inode,\n\t\t\t\t\t     loff_t start_byte, loff_t length)\n{\n\treturn jbd2_journal_inode_ranged_write(handle,\n\t\t\t\t\t       &OCFS2_I(inode)->ip_jinode,\n\t\t\t\t\t       start_byte, length);\n}\n\nstatic inline int ocfs2_begin_ordered_truncate(struct inode *inode,\n\t\t\t\t\t       loff_t new_size)\n{\n\treturn jbd2_journal_begin_ordered_truncate(\n\t\t\t\tOCFS2_SB(inode->i_sb)->journal->j_journal,\n\t\t\t\t&OCFS2_I(inode)->ip_jinode,\n\t\t\t\tnew_size);\n}\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tif (!is_handle_aborted(handle)) {\n\t\toi->i_sync_tid = handle->h_transaction->t_tid;\n\t\tif (datasync)\n\t\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n\t}\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}