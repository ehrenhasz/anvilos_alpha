{
  "module_name": "filecheck.c",
  "hash_id": "c1ac995740ec735945fbd87b17038a78a1830f6812032b2200226ac3f403609e",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/filecheck.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/fs.h>\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include \"inode.h\"\n\n#include \"filecheck.h\"\n\n\n \nstatic const char * const ocfs2_filecheck_errs[] = {\n\t\"SUCCESS\",\n\t\"FAILED\",\n\t\"INPROGRESS\",\n\t\"READONLY\",\n\t\"INJBD\",\n\t\"INVALIDINO\",\n\t\"BLOCKECC\",\n\t\"BLOCKNO\",\n\t\"VALIDFLAG\",\n\t\"GENERATION\",\n\t\"UNSUPPORTED\"\n};\n\nstruct ocfs2_filecheck_entry {\n\tstruct list_head fe_list;\n\tunsigned long fe_ino;\n\tunsigned int fe_type;\n\tunsigned int fe_done:1;\n\tunsigned int fe_status:31;\n};\n\nstruct ocfs2_filecheck_args {\n\tunsigned int fa_type;\n\tunion {\n\t\tunsigned long fa_ino;\n\t\tunsigned int fa_len;\n\t};\n};\n\nstatic const char *\nocfs2_filecheck_error(int errno)\n{\n\tif (!errno)\n\t\treturn ocfs2_filecheck_errs[errno];\n\n\tBUG_ON(errno < OCFS2_FILECHECK_ERR_START ||\n\t       errno > OCFS2_FILECHECK_ERR_END);\n\treturn ocfs2_filecheck_errs[errno - OCFS2_FILECHECK_ERR_START + 1];\n}\n\nstatic ssize_t ocfs2_filecheck_attr_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tchar *buf);\nstatic ssize_t ocfs2_filecheck_attr_store(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count);\nstatic struct kobj_attribute ocfs2_filecheck_attr_chk =\n\t\t\t\t\t__ATTR(check, S_IRUSR | S_IWUSR,\n\t\t\t\t\tocfs2_filecheck_attr_show,\n\t\t\t\t\tocfs2_filecheck_attr_store);\nstatic struct kobj_attribute ocfs2_filecheck_attr_fix =\n\t\t\t\t\t__ATTR(fix, S_IRUSR | S_IWUSR,\n\t\t\t\t\tocfs2_filecheck_attr_show,\n\t\t\t\t\tocfs2_filecheck_attr_store);\nstatic struct kobj_attribute ocfs2_filecheck_attr_set =\n\t\t\t\t\t__ATTR(set, S_IRUSR | S_IWUSR,\n\t\t\t\t\tocfs2_filecheck_attr_show,\n\t\t\t\t\tocfs2_filecheck_attr_store);\nstatic struct attribute *ocfs2_filecheck_attrs[] = {\n\t&ocfs2_filecheck_attr_chk.attr,\n\t&ocfs2_filecheck_attr_fix.attr,\n\t&ocfs2_filecheck_attr_set.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(ocfs2_filecheck);\n\nstatic void ocfs2_filecheck_release(struct kobject *kobj)\n{\n\tstruct ocfs2_filecheck_sysfs_entry *entry = container_of(kobj,\n\t\t\t\tstruct ocfs2_filecheck_sysfs_entry, fs_kobj);\n\n\tcomplete(&entry->fs_kobj_unregister);\n}\n\nstatic ssize_t\nocfs2_filecheck_show(struct kobject *kobj, struct attribute *attr, char *buf)\n{\n\tssize_t ret = -EIO;\n\tstruct kobj_attribute *kattr = container_of(attr,\n\t\t\t\t\tstruct kobj_attribute, attr);\n\n\tkobject_get(kobj);\n\tif (kattr->show)\n\t\tret = kattr->show(kobj, kattr, buf);\n\tkobject_put(kobj);\n\treturn ret;\n}\n\nstatic ssize_t\nocfs2_filecheck_store(struct kobject *kobj, struct attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tssize_t ret = -EIO;\n\tstruct kobj_attribute *kattr = container_of(attr,\n\t\t\t\t\tstruct kobj_attribute, attr);\n\n\tkobject_get(kobj);\n\tif (kattr->store)\n\t\tret = kattr->store(kobj, kattr, buf, count);\n\tkobject_put(kobj);\n\treturn ret;\n}\n\nstatic const struct sysfs_ops ocfs2_filecheck_ops = {\n\t.show = ocfs2_filecheck_show,\n\t.store = ocfs2_filecheck_store,\n};\n\nstatic struct kobj_type ocfs2_ktype_filecheck = {\n\t.default_groups = ocfs2_filecheck_groups,\n\t.sysfs_ops = &ocfs2_filecheck_ops,\n\t.release = ocfs2_filecheck_release,\n};\n\nstatic void\nocfs2_filecheck_sysfs_free(struct ocfs2_filecheck_sysfs_entry *entry)\n{\n\tstruct ocfs2_filecheck_entry *p;\n\n\tspin_lock(&entry->fs_fcheck->fc_lock);\n\twhile (!list_empty(&entry->fs_fcheck->fc_head)) {\n\t\tp = list_first_entry(&entry->fs_fcheck->fc_head,\n\t\t\t\t     struct ocfs2_filecheck_entry, fe_list);\n\t\tlist_del(&p->fe_list);\n\t\tBUG_ON(!p->fe_done);  \n\t\tkfree(p);\n\t}\n\tspin_unlock(&entry->fs_fcheck->fc_lock);\n\n\tkfree(entry->fs_fcheck);\n\tentry->fs_fcheck = NULL;\n}\n\nint ocfs2_filecheck_create_sysfs(struct ocfs2_super *osb)\n{\n\tint ret;\n\tstruct ocfs2_filecheck *fcheck;\n\tstruct ocfs2_filecheck_sysfs_entry *entry = &osb->osb_fc_ent;\n\n\tfcheck = kmalloc(sizeof(struct ocfs2_filecheck), GFP_NOFS);\n\tif (!fcheck)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&fcheck->fc_head);\n\tspin_lock_init(&fcheck->fc_lock);\n\tfcheck->fc_max = OCFS2_FILECHECK_MINSIZE;\n\tfcheck->fc_size = 0;\n\tfcheck->fc_done = 0;\n\n\tentry->fs_kobj.kset = osb->osb_dev_kset;\n\tinit_completion(&entry->fs_kobj_unregister);\n\tret = kobject_init_and_add(&entry->fs_kobj, &ocfs2_ktype_filecheck,\n\t\t\t\t\tNULL, \"filecheck\");\n\tif (ret) {\n\t\tkobject_put(&entry->fs_kobj);\n\t\tkfree(fcheck);\n\t\treturn ret;\n\t}\n\n\tentry->fs_fcheck = fcheck;\n\treturn 0;\n}\n\nvoid ocfs2_filecheck_remove_sysfs(struct ocfs2_super *osb)\n{\n\tif (!osb->osb_fc_ent.fs_fcheck)\n\t\treturn;\n\n\tkobject_del(&osb->osb_fc_ent.fs_kobj);\n\tkobject_put(&osb->osb_fc_ent.fs_kobj);\n\twait_for_completion(&osb->osb_fc_ent.fs_kobj_unregister);\n\tocfs2_filecheck_sysfs_free(&osb->osb_fc_ent);\n}\n\nstatic int\nocfs2_filecheck_erase_entries(struct ocfs2_filecheck_sysfs_entry *ent,\n\t\t\t      unsigned int count);\nstatic int\nocfs2_filecheck_adjust_max(struct ocfs2_filecheck_sysfs_entry *ent,\n\t\t\t   unsigned int len)\n{\n\tint ret;\n\n\tif ((len < OCFS2_FILECHECK_MINSIZE) || (len > OCFS2_FILECHECK_MAXSIZE))\n\t\treturn -EINVAL;\n\n\tspin_lock(&ent->fs_fcheck->fc_lock);\n\tif (len < (ent->fs_fcheck->fc_size - ent->fs_fcheck->fc_done)) {\n\t\tmlog(ML_NOTICE,\n\t\t\"Cannot set online file check maximum entry number \"\n\t\t\"to %u due to too many pending entries(%u)\\n\",\n\t\tlen, ent->fs_fcheck->fc_size - ent->fs_fcheck->fc_done);\n\t\tret = -EBUSY;\n\t} else {\n\t\tif (len < ent->fs_fcheck->fc_size)\n\t\t\tBUG_ON(!ocfs2_filecheck_erase_entries(ent,\n\t\t\t\tent->fs_fcheck->fc_size - len));\n\n\t\tent->fs_fcheck->fc_max = len;\n\t\tret = 0;\n\t}\n\tspin_unlock(&ent->fs_fcheck->fc_lock);\n\n\treturn ret;\n}\n\n#define OCFS2_FILECHECK_ARGS_LEN\t24\nstatic int\nocfs2_filecheck_args_get_long(const char *buf, size_t count,\n\t\t\t      unsigned long *val)\n{\n\tchar buffer[OCFS2_FILECHECK_ARGS_LEN];\n\n\tmemcpy(buffer, buf, count);\n\tbuffer[count] = '\\0';\n\n\tif (kstrtoul(buffer, 0, val))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int\nocfs2_filecheck_type_parse(const char *name, unsigned int *type)\n{\n\tif (!strncmp(name, \"fix\", 4))\n\t\t*type = OCFS2_FILECHECK_TYPE_FIX;\n\telse if (!strncmp(name, \"check\", 6))\n\t\t*type = OCFS2_FILECHECK_TYPE_CHK;\n\telse if (!strncmp(name, \"set\", 4))\n\t\t*type = OCFS2_FILECHECK_TYPE_SET;\n\telse\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int\nocfs2_filecheck_args_parse(const char *name, const char *buf, size_t count,\n\t\t\t   struct ocfs2_filecheck_args *args)\n{\n\tunsigned long val = 0;\n\tunsigned int type;\n\n\t \n\tif ((count < 1) || (count >= OCFS2_FILECHECK_ARGS_LEN))\n\t\treturn 1;\n\n\tif (ocfs2_filecheck_type_parse(name, &type))\n\t\treturn 1;\n\tif (ocfs2_filecheck_args_get_long(buf, count, &val))\n\t\treturn 1;\n\n\tif (val <= 0)\n\t\treturn 1;\n\n\targs->fa_type = type;\n\tif (type == OCFS2_FILECHECK_TYPE_SET)\n\t\targs->fa_len = (unsigned int)val;\n\telse\n\t\targs->fa_ino = val;\n\n\treturn 0;\n}\n\nstatic ssize_t ocfs2_filecheck_attr_show(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\n\tssize_t ret = 0, total = 0, remain = PAGE_SIZE;\n\tunsigned int type;\n\tstruct ocfs2_filecheck_entry *p;\n\tstruct ocfs2_filecheck_sysfs_entry *ent = container_of(kobj,\n\t\t\t\tstruct ocfs2_filecheck_sysfs_entry, fs_kobj);\n\n\tif (ocfs2_filecheck_type_parse(attr->attr.name, &type))\n\t\treturn -EINVAL;\n\n\tif (type == OCFS2_FILECHECK_TYPE_SET) {\n\t\tspin_lock(&ent->fs_fcheck->fc_lock);\n\t\ttotal = snprintf(buf, remain, \"%u\\n\", ent->fs_fcheck->fc_max);\n\t\tspin_unlock(&ent->fs_fcheck->fc_lock);\n\t\tgoto exit;\n\t}\n\n\tret = snprintf(buf, remain, \"INO\\t\\tDONE\\tERROR\\n\");\n\ttotal += ret;\n\tremain -= ret;\n\tspin_lock(&ent->fs_fcheck->fc_lock);\n\tlist_for_each_entry(p, &ent->fs_fcheck->fc_head, fe_list) {\n\t\tif (p->fe_type != type)\n\t\t\tcontinue;\n\n\t\tret = snprintf(buf + total, remain, \"%lu\\t\\t%u\\t%s\\n\",\n\t\t\t       p->fe_ino, p->fe_done,\n\t\t\t       ocfs2_filecheck_error(p->fe_status));\n\t\tif (ret >= remain) {\n\t\t\t \n\t\t\ttotal = -E2BIG;\n\t\t\tbreak;\n\t\t}\n\t\ttotal += ret;\n\t\tremain -= ret;\n\t}\n\tspin_unlock(&ent->fs_fcheck->fc_lock);\n\nexit:\n\treturn total;\n}\n\nstatic inline int\nocfs2_filecheck_is_dup_entry(struct ocfs2_filecheck_sysfs_entry *ent,\n\t\t\t\tunsigned long ino)\n{\n\tstruct ocfs2_filecheck_entry *p;\n\n\tlist_for_each_entry(p, &ent->fs_fcheck->fc_head, fe_list) {\n\t\tif (!p->fe_done) {\n\t\t\tif (p->fe_ino == ino)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline int\nocfs2_filecheck_erase_entry(struct ocfs2_filecheck_sysfs_entry *ent)\n{\n\tstruct ocfs2_filecheck_entry *p;\n\n\tlist_for_each_entry(p, &ent->fs_fcheck->fc_head, fe_list) {\n\t\tif (p->fe_done) {\n\t\t\tlist_del(&p->fe_list);\n\t\t\tkfree(p);\n\t\t\tent->fs_fcheck->fc_size--;\n\t\t\tent->fs_fcheck->fc_done--;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nocfs2_filecheck_erase_entries(struct ocfs2_filecheck_sysfs_entry *ent,\n\t\t\t      unsigned int count)\n{\n\tunsigned int i = 0;\n\tunsigned int ret = 0;\n\n\twhile (i++ < count) {\n\t\tif (ocfs2_filecheck_erase_entry(ent))\n\t\t\tret++;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn (ret == count ? 1 : 0);\n}\n\nstatic void\nocfs2_filecheck_done_entry(struct ocfs2_filecheck_sysfs_entry *ent,\n\t\t\t   struct ocfs2_filecheck_entry *entry)\n{\n\tspin_lock(&ent->fs_fcheck->fc_lock);\n\tentry->fe_done = 1;\n\tent->fs_fcheck->fc_done++;\n\tspin_unlock(&ent->fs_fcheck->fc_lock);\n}\n\nstatic unsigned int\nocfs2_filecheck_handle(struct ocfs2_super *osb,\n\t\t       unsigned long ino, unsigned int flags)\n{\n\tunsigned int ret = OCFS2_FILECHECK_ERR_SUCCESS;\n\tstruct inode *inode = NULL;\n\tint rc;\n\n\tinode = ocfs2_iget(osb, ino, flags, 0);\n\tif (IS_ERR(inode)) {\n\t\trc = (int)(-(long)inode);\n\t\tif (rc >= OCFS2_FILECHECK_ERR_START &&\n\t\t    rc < OCFS2_FILECHECK_ERR_END)\n\t\t\tret = rc;\n\t\telse\n\t\t\tret = OCFS2_FILECHECK_ERR_FAILED;\n\t} else\n\t\tiput(inode);\n\n\treturn ret;\n}\n\nstatic void\nocfs2_filecheck_handle_entry(struct ocfs2_filecheck_sysfs_entry *ent,\n\t\t\t     struct ocfs2_filecheck_entry *entry)\n{\n\tstruct ocfs2_super *osb = container_of(ent, struct ocfs2_super,\n\t\t\t\t\t\tosb_fc_ent);\n\n\tif (entry->fe_type == OCFS2_FILECHECK_TYPE_CHK)\n\t\tentry->fe_status = ocfs2_filecheck_handle(osb,\n\t\t\t\tentry->fe_ino, OCFS2_FI_FLAG_FILECHECK_CHK);\n\telse if (entry->fe_type == OCFS2_FILECHECK_TYPE_FIX)\n\t\tentry->fe_status = ocfs2_filecheck_handle(osb,\n\t\t\t\tentry->fe_ino, OCFS2_FI_FLAG_FILECHECK_FIX);\n\telse\n\t\tentry->fe_status = OCFS2_FILECHECK_ERR_UNSUPPORTED;\n\n\tocfs2_filecheck_done_entry(ent, entry);\n}\n\nstatic ssize_t ocfs2_filecheck_attr_store(struct kobject *kobj,\n\t\t\t\t     struct kobj_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tssize_t ret = 0;\n\tstruct ocfs2_filecheck_args args;\n\tstruct ocfs2_filecheck_entry *entry;\n\tstruct ocfs2_filecheck_sysfs_entry *ent = container_of(kobj,\n\t\t\t\tstruct ocfs2_filecheck_sysfs_entry, fs_kobj);\n\n\tif (count == 0)\n\t\treturn count;\n\n\tif (ocfs2_filecheck_args_parse(attr->attr.name, buf, count, &args))\n\t\treturn -EINVAL;\n\n\tif (args.fa_type == OCFS2_FILECHECK_TYPE_SET) {\n\t\tret = ocfs2_filecheck_adjust_max(ent, args.fa_len);\n\t\tgoto exit;\n\t}\n\n\tentry = kmalloc(sizeof(struct ocfs2_filecheck_entry), GFP_NOFS);\n\tif (!entry) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tspin_lock(&ent->fs_fcheck->fc_lock);\n\tif (ocfs2_filecheck_is_dup_entry(ent, args.fa_ino)) {\n\t\tret = -EEXIST;\n\t\tkfree(entry);\n\t} else if ((ent->fs_fcheck->fc_size >= ent->fs_fcheck->fc_max) &&\n\t\t(ent->fs_fcheck->fc_done == 0)) {\n\t\tmlog(ML_NOTICE,\n\t\t\"Cannot do more file check \"\n\t\t\"since file check queue(%u) is full now\\n\",\n\t\tent->fs_fcheck->fc_max);\n\t\tret = -EAGAIN;\n\t\tkfree(entry);\n\t} else {\n\t\tif ((ent->fs_fcheck->fc_size >= ent->fs_fcheck->fc_max) &&\n\t\t    (ent->fs_fcheck->fc_done > 0)) {\n\t\t\t \n\t\t\tBUG_ON(!ocfs2_filecheck_erase_entry(ent));\n\t\t}\n\n\t\tentry->fe_ino = args.fa_ino;\n\t\tentry->fe_type = args.fa_type;\n\t\tentry->fe_done = 0;\n\t\tentry->fe_status = OCFS2_FILECHECK_ERR_INPROGRESS;\n\t\tlist_add_tail(&entry->fe_list, &ent->fs_fcheck->fc_head);\n\t\tent->fs_fcheck->fc_size++;\n\t}\n\tspin_unlock(&ent->fs_fcheck->fc_lock);\n\n\tif (!ret)\n\t\tocfs2_filecheck_handle_entry(ent, entry);\n\nexit:\n\treturn (!ret ? count : ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}