{
  "module_name": "uptodate.c",
  "hash_id": "e852163955e3d8c0c13e45b00f583875c2478083a785266844d5045c8c418cf4",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/uptodate.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include <linux/rbtree.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"inode.h\"\n#include \"uptodate.h\"\n#include \"ocfs2_trace.h\"\n\nstruct ocfs2_meta_cache_item {\n\tstruct rb_node\tc_node;\n\tsector_t\tc_block;\n};\n\nstatic struct kmem_cache *ocfs2_uptodate_cachep;\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}\n\nstatic void ocfs2_metadata_cache_lock(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\tci->ci_ops->co_cache_lock(ci);\n}\n\nstatic void ocfs2_metadata_cache_unlock(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\tci->ci_ops->co_cache_unlock(ci);\n}\n\nvoid ocfs2_metadata_cache_io_lock(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\tci->ci_ops->co_io_lock(ci);\n}\n\nvoid ocfs2_metadata_cache_io_unlock(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\tci->ci_ops->co_io_unlock(ci);\n}\n\n\nstatic void ocfs2_metadata_cache_reset(struct ocfs2_caching_info *ci,\n\t\t\t\t       int clear)\n{\n\tci->ci_flags |= OCFS2_CACHE_FL_INLINE;\n\tci->ci_num_cached = 0;\n\n\tif (clear) {\n\t\tci->ci_created_trans = 0;\n\t\tci->ci_last_trans = 0;\n\t}\n}\n\nvoid ocfs2_metadata_cache_init(struct ocfs2_caching_info *ci,\n\t\t\t       const struct ocfs2_caching_operations *ops)\n{\n\tBUG_ON(!ops);\n\n\tci->ci_ops = ops;\n\tocfs2_metadata_cache_reset(ci, 1);\n}\n\nvoid ocfs2_metadata_cache_exit(struct ocfs2_caching_info *ci)\n{\n\tocfs2_metadata_cache_purge(ci);\n\tocfs2_metadata_cache_reset(ci, 1);\n}\n\n\n \nstatic unsigned int ocfs2_purge_copied_metadata_tree(struct rb_root *root)\n{\n\tunsigned int purged = 0;\n\tstruct rb_node *node;\n\tstruct ocfs2_meta_cache_item *item;\n\n\twhile ((node = rb_last(root)) != NULL) {\n\t\titem = rb_entry(node, struct ocfs2_meta_cache_item, c_node);\n\n\t\ttrace_ocfs2_purge_copied_metadata_tree(\n\t\t\t\t\t(unsigned long long) item->c_block);\n\n\t\trb_erase(&item->c_node, root);\n\t\tkmem_cache_free(ocfs2_uptodate_cachep, item);\n\n\t\tpurged++;\n\t}\n\treturn purged;\n}\n\n \nvoid ocfs2_metadata_cache_purge(struct ocfs2_caching_info *ci)\n{\n\tunsigned int tree, to_purge, purged;\n\tstruct rb_root root = RB_ROOT;\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\tocfs2_metadata_cache_lock(ci);\n\ttree = !(ci->ci_flags & OCFS2_CACHE_FL_INLINE);\n\tto_purge = ci->ci_num_cached;\n\n\ttrace_ocfs2_metadata_cache_purge(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\tto_purge, tree);\n\n\t \n\tif (tree)\n\t\troot = ci->ci_cache.ci_tree;\n\n\tocfs2_metadata_cache_reset(ci, 0);\n\tocfs2_metadata_cache_unlock(ci);\n\n\tpurged = ocfs2_purge_copied_metadata_tree(&root);\n\t \n\tif (tree && purged != to_purge)\n\t\tmlog(ML_ERROR, \"Owner %llu, count = %u, purged = %u\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t     to_purge, purged);\n}\n\n \nstatic int ocfs2_search_cache_array(struct ocfs2_caching_info *ci,\n\t\t\t\t    sector_t item)\n{\n\tint i;\n\n\tfor (i = 0; i < ci->ci_num_cached; i++) {\n\t\tif (item == ci->ci_cache.ci_array[i])\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\n \nstatic struct ocfs2_meta_cache_item *\nocfs2_search_cache_tree(struct ocfs2_caching_info *ci,\n\t\t\tsector_t block)\n{\n\tstruct rb_node * n = ci->ci_cache.ci_tree.rb_node;\n\tstruct ocfs2_meta_cache_item *item = NULL;\n\n\twhile (n) {\n\t\titem = rb_entry(n, struct ocfs2_meta_cache_item, c_node);\n\n\t\tif (block < item->c_block)\n\t\t\tn = n->rb_left;\n\t\telse if (block > item->c_block)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn item;\n\t}\n\n\treturn NULL;\n}\n\nstatic int ocfs2_buffer_cached(struct ocfs2_caching_info *ci,\n\t\t\t       struct buffer_head *bh)\n{\n\tint index = -1;\n\tstruct ocfs2_meta_cache_item *item = NULL;\n\n\tocfs2_metadata_cache_lock(ci);\n\n\ttrace_ocfs2_buffer_cached_begin(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long) bh->b_blocknr,\n\t\t!!(ci->ci_flags & OCFS2_CACHE_FL_INLINE));\n\n\tif (ci->ci_flags & OCFS2_CACHE_FL_INLINE)\n\t\tindex = ocfs2_search_cache_array(ci, bh->b_blocknr);\n\telse\n\t\titem = ocfs2_search_cache_tree(ci, bh->b_blocknr);\n\n\tocfs2_metadata_cache_unlock(ci);\n\n\ttrace_ocfs2_buffer_cached_end(index, item);\n\n\treturn (index != -1) || (item != NULL);\n}\n\n \nint ocfs2_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t  struct buffer_head *bh)\n{\n\t \n\tif (!buffer_uptodate(bh))\n\t\treturn 0;\n\n\t \n\tif (buffer_jbd(bh))\n\t\treturn 1;\n\n\t \n\treturn ocfs2_buffer_cached(ci, bh);\n}\n\n \nint ocfs2_buffer_read_ahead(struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh)\n{\n\treturn buffer_locked(bh) && ocfs2_buffer_cached(ci, bh);\n}\n\n \nstatic void ocfs2_append_cache_array(struct ocfs2_caching_info *ci,\n\t\t\t\t     sector_t block)\n{\n\tBUG_ON(ci->ci_num_cached >= OCFS2_CACHE_INFO_MAX_ARRAY);\n\n\ttrace_ocfs2_append_cache_array(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)block, ci->ci_num_cached);\n\n\tci->ci_cache.ci_array[ci->ci_num_cached] = block;\n\tci->ci_num_cached++;\n}\n\n \nstatic void __ocfs2_insert_cache_tree(struct ocfs2_caching_info *ci,\n\t\t\t\t      struct ocfs2_meta_cache_item *new)\n{\n\tsector_t block = new->c_block;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p = &ci->ci_cache.ci_tree.rb_node;\n\tstruct ocfs2_meta_cache_item *tmp;\n\n\ttrace_ocfs2_insert_cache_tree(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)block, ci->ci_num_cached);\n\n\twhile(*p) {\n\t\tparent = *p;\n\n\t\ttmp = rb_entry(parent, struct ocfs2_meta_cache_item, c_node);\n\n\t\tif (block < tmp->c_block)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (block > tmp->c_block)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\t \n\t\t\tmlog(ML_ERROR, \"Duplicate block %llu cached!\\n\",\n\t\t\t     (unsigned long long) block);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->c_node, parent, p);\n\trb_insert_color(&new->c_node, &ci->ci_cache.ci_tree);\n\tci->ci_num_cached++;\n}\n\n \nstatic inline int ocfs2_insert_can_use_array(struct ocfs2_caching_info *ci)\n{\n\treturn (ci->ci_flags & OCFS2_CACHE_FL_INLINE) &&\n\t\t(ci->ci_num_cached < OCFS2_CACHE_INFO_MAX_ARRAY);\n}\n\n \nstatic void ocfs2_expand_cache(struct ocfs2_caching_info *ci,\n\t\t\t       struct ocfs2_meta_cache_item **tree)\n{\n\tint i;\n\n\tmlog_bug_on_msg(ci->ci_num_cached != OCFS2_CACHE_INFO_MAX_ARRAY,\n\t\t\t\"Owner %llu, num cached = %u, should be %u\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\tci->ci_num_cached, OCFS2_CACHE_INFO_MAX_ARRAY);\n\tmlog_bug_on_msg(!(ci->ci_flags & OCFS2_CACHE_FL_INLINE),\n\t\t\t\"Owner %llu not marked as inline anymore!\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci));\n\n\t \n\tfor (i = 0; i < OCFS2_CACHE_INFO_MAX_ARRAY; i++)\n\t\ttree[i]->c_block = ci->ci_cache.ci_array[i];\n\n\tci->ci_flags &= ~OCFS2_CACHE_FL_INLINE;\n\tci->ci_cache.ci_tree = RB_ROOT;\n\t \n\tci->ci_num_cached = 0;\n\n\tfor (i = 0; i < OCFS2_CACHE_INFO_MAX_ARRAY; i++) {\n\t\t__ocfs2_insert_cache_tree(ci, tree[i]);\n\t\ttree[i] = NULL;\n\t}\n\n\ttrace_ocfs2_expand_cache(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\tci->ci_flags, ci->ci_num_cached);\n}\n\n \nstatic void __ocfs2_set_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t\tsector_t block,\n\t\t\t\t\tint expand_tree)\n{\n\tint i;\n\tstruct ocfs2_meta_cache_item *new = NULL;\n\tstruct ocfs2_meta_cache_item *tree[OCFS2_CACHE_INFO_MAX_ARRAY] =\n\t\t{ NULL, };\n\n\ttrace_ocfs2_set_buffer_uptodate(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)block, expand_tree);\n\n\tnew = kmem_cache_alloc(ocfs2_uptodate_cachep, GFP_NOFS);\n\tif (!new) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn;\n\t}\n\tnew->c_block = block;\n\n\tif (expand_tree) {\n\t\t \n\t\tfor (i = 0; i < OCFS2_CACHE_INFO_MAX_ARRAY; i++) {\n\t\t\ttree[i] = kmem_cache_alloc(ocfs2_uptodate_cachep,\n\t\t\t\t\t\t   GFP_NOFS);\n\t\t\tif (!tree[i]) {\n\t\t\t\tmlog_errno(-ENOMEM);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t \n\t\t}\n\t}\n\n\tocfs2_metadata_cache_lock(ci);\n\tif (ocfs2_insert_can_use_array(ci)) {\n\t\t \n\t\tocfs2_append_cache_array(ci, block);\n\t\tocfs2_metadata_cache_unlock(ci);\n\t\tgoto out_free;\n\t}\n\n\tif (expand_tree)\n\t\tocfs2_expand_cache(ci, tree);\n\n\t__ocfs2_insert_cache_tree(ci, new);\n\tocfs2_metadata_cache_unlock(ci);\n\n\tnew = NULL;\nout_free:\n\tif (new)\n\t\tkmem_cache_free(ocfs2_uptodate_cachep, new);\n\n\t \n\tif (tree[0]) {\n\t\tfor (i = 0; i < OCFS2_CACHE_INFO_MAX_ARRAY; i++)\n\t\t\tif (tree[i])\n\t\t\t\tkmem_cache_free(ocfs2_uptodate_cachep,\n\t\t\t\t\t\ttree[i]);\n\t}\n}\n\n \nvoid ocfs2_set_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t       struct buffer_head *bh)\n{\n\tint expand;\n\n\t \n\tif (ocfs2_buffer_cached(ci, bh))\n\t\treturn;\n\n\ttrace_ocfs2_set_buffer_uptodate_begin(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr);\n\n\t \n\tocfs2_metadata_cache_lock(ci);\n\tif (ocfs2_insert_can_use_array(ci)) {\n\t\t \n\t\tocfs2_append_cache_array(ci, bh->b_blocknr);\n\t\tocfs2_metadata_cache_unlock(ci);\n\t\treturn;\n\t}\n\n\texpand = 0;\n\tif (ci->ci_flags & OCFS2_CACHE_FL_INLINE) {\n\t\t \n\t\texpand = 1;\n\t}\n\tocfs2_metadata_cache_unlock(ci);\n\n\t__ocfs2_set_buffer_uptodate(ci, bh->b_blocknr, expand);\n}\n\n \nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t \n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}\n\n \nstatic void ocfs2_remove_metadata_array(struct ocfs2_caching_info *ci,\n\t\t\t\t\tint index)\n{\n\tsector_t *array = ci->ci_cache.ci_array;\n\tint bytes;\n\n\tBUG_ON(index < 0 || index >= OCFS2_CACHE_INFO_MAX_ARRAY);\n\tBUG_ON(index >= ci->ci_num_cached);\n\tBUG_ON(!ci->ci_num_cached);\n\n\ttrace_ocfs2_remove_metadata_array(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\tindex, ci->ci_num_cached);\n\n\tci->ci_num_cached--;\n\n\t \n\tif (ci->ci_num_cached && index < ci->ci_num_cached) {\n\t\tbytes = sizeof(sector_t) * (ci->ci_num_cached - index);\n\t\tmemmove(&array[index], &array[index + 1], bytes);\n\t}\n}\n\n \nstatic void ocfs2_remove_metadata_tree(struct ocfs2_caching_info *ci,\n\t\t\t\t       struct ocfs2_meta_cache_item *item)\n{\n\ttrace_ocfs2_remove_metadata_tree(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)item->c_block);\n\n\trb_erase(&item->c_node, &ci->ci_cache.ci_tree);\n\tci->ci_num_cached--;\n}\n\nstatic void ocfs2_remove_block_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t\t\t  sector_t block)\n{\n\tint index;\n\tstruct ocfs2_meta_cache_item *item = NULL;\n\n\tocfs2_metadata_cache_lock(ci);\n\ttrace_ocfs2_remove_block_from_cache(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long) block, ci->ci_num_cached,\n\t\tci->ci_flags);\n\n\tif (ci->ci_flags & OCFS2_CACHE_FL_INLINE) {\n\t\tindex = ocfs2_search_cache_array(ci, block);\n\t\tif (index != -1)\n\t\t\tocfs2_remove_metadata_array(ci, index);\n\t} else {\n\t\titem = ocfs2_search_cache_tree(ci, block);\n\t\tif (item)\n\t\t\tocfs2_remove_metadata_tree(ci, item);\n\t}\n\tocfs2_metadata_cache_unlock(ci);\n\n\tif (item)\n\t\tkmem_cache_free(ocfs2_uptodate_cachep, item);\n}\n\n \nvoid ocfs2_remove_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t     struct buffer_head *bh)\n{\n\tsector_t block = bh->b_blocknr;\n\n\tocfs2_remove_block_from_cache(ci, block);\n}\n\n \nvoid ocfs2_remove_xattr_clusters_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t\t\t    sector_t block,\n\t\t\t\t\t    u32 c_len)\n{\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tunsigned int i, b_len = ocfs2_clusters_to_blocks(sb, 1) * c_len;\n\n\tfor (i = 0; i < b_len; i++, block++)\n\t\tocfs2_remove_block_from_cache(ci, block);\n}\n\nint __init init_ocfs2_uptodate_cache(void)\n{\n\tocfs2_uptodate_cachep = kmem_cache_create(\"ocfs2_uptodate\",\n\t\t\t\t  sizeof(struct ocfs2_meta_cache_item),\n\t\t\t\t  0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (!ocfs2_uptodate_cachep)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid exit_ocfs2_uptodate_cache(void)\n{\n\tkmem_cache_destroy(ocfs2_uptodate_cachep);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}