{
  "module_name": "dcache.c",
  "hash_id": "2abe8e558b054fa44a68d17d62f84257594427bd17dd65f725d39f29fa623261",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/dcache.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"alloc.h\"\n#include \"dcache.h\"\n#include \"dlmglue.h\"\n#include \"file.h\"\n#include \"inode.h\"\n#include \"ocfs2_trace.h\"\n\nvoid ocfs2_dentry_attach_gen(struct dentry *dentry)\n{\n\tunsigned long gen =\n\t\tOCFS2_I(d_inode(dentry->d_parent))->ip_dir_lock_gen;\n\tBUG_ON(d_inode(dentry));\n\tdentry->d_fsdata = (void *)gen;\n}\n\n\nstatic int ocfs2_dentry_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tint ret = 0;     \n\tstruct ocfs2_super *osb;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = d_inode(dentry);\n\tosb = OCFS2_SB(dentry->d_sb);\n\n\ttrace_ocfs2_dentry_revalidate(dentry, dentry->d_name.len,\n\t\t\t\t      dentry->d_name.name);\n\n\t \n\tif (inode == NULL) {\n\t\tunsigned long gen = (unsigned long) dentry->d_fsdata;\n\t\tunsigned long pgen;\n\t\tspin_lock(&dentry->d_lock);\n\t\tpgen = OCFS2_I(d_inode(dentry->d_parent))->ip_dir_lock_gen;\n\t\tspin_unlock(&dentry->d_lock);\n\t\ttrace_ocfs2_dentry_revalidate_negative(dentry->d_name.len,\n\t\t\t\t\t\t       dentry->d_name.name,\n\t\t\t\t\t\t       pgen, gen);\n\t\tif (gen != pgen)\n\t\t\tgoto bail;\n\t\tgoto valid;\n\t}\n\n\tBUG_ON(!osb);\n\n\tif (inode == osb->root_inode || is_bad_inode(inode))\n\t\tgoto bail;\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\t \n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_DELETED) {\n\t\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\t\ttrace_ocfs2_dentry_revalidate_delete(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tgoto bail;\n\t}\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\t \n\tif (inode->i_nlink == 0) {\n\t\ttrace_ocfs2_dentry_revalidate_orphaned(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\tS_ISDIR(inode->i_mode));\n\t\tgoto bail;\n\t}\n\n\t \n\tif (!dentry->d_fsdata) {\n\t\ttrace_ocfs2_dentry_revalidate_nofsdata(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tgoto bail;\n\t}\n\nvalid:\n\tret = 1;\n\nbail:\n\ttrace_ocfs2_dentry_revalidate_ret(ret);\n\treturn ret;\n}\n\nstatic int ocfs2_match_dentry(struct dentry *dentry,\n\t\t\t      u64 parent_blkno,\n\t\t\t      int skip_unhashed)\n{\n\tstruct inode *parent;\n\n\t \n\tif (!dentry->d_fsdata)\n\t\treturn 0;\n\n\tif (!dentry->d_parent)\n\t\treturn 0;\n\n\tif (skip_unhashed && d_unhashed(dentry))\n\t\treturn 0;\n\n\tparent = d_inode(dentry->d_parent);\n\t \n\tif (!parent)\n\t\treturn 0;\n\n\t \n\tif (OCFS2_I(parent)->ip_blkno != parent_blkno)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstruct dentry *ocfs2_find_local_alias(struct inode *inode,\n\t\t\t\t      u64 parent_blkno,\n\t\t\t\t      int skip_unhashed)\n{\n\tstruct dentry *dentry;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (ocfs2_match_dentry(dentry, parent_blkno, skip_unhashed)) {\n\t\t\ttrace_ocfs2_find_local_alias(dentry->d_name.len,\n\t\t\t\t\t\t     dentry->d_name.name);\n\n\t\t\tdget_dlock(dentry);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn dentry;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn NULL;\n}\n\nDEFINE_SPINLOCK(dentry_attach_lock);\n\n \nint ocfs2_dentry_attach_lock(struct dentry *dentry,\n\t\t\t     struct inode *inode,\n\t\t\t     u64 parent_blkno)\n{\n\tint ret;\n\tstruct dentry *alias;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\ttrace_ocfs2_dentry_attach_lock(dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       (unsigned long long)parent_blkno, dl);\n\n\t \n\tif (!inode)\n\t\treturn 0;\n\n\tif (d_really_is_negative(dentry) && dentry->d_fsdata) {\n\t\t \n\t\tdentry->d_fsdata = dl = NULL;\n\t}\n\n\tif (dl) {\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\t\treturn 0;\n\t}\n\n\talias = ocfs2_find_local_alias(inode, parent_blkno, 0);\n\tif (alias) {\n\t\t \n\t\tdl = alias->d_fsdata;\n\t\tmlog_bug_on_msg(!dl, \"parent %llu, ino %llu\\n\",\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\n\t\t\t\t\" \\\"%pd\\\": old parent: %llu, new: %llu\\n\",\n\t\t\t\tdentry,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)dl->dl_parent_blkno);\n\n\t\ttrace_ocfs2_dentry_attach_lock_found(dl->dl_lockres.l_name,\n\t\t\t\t(unsigned long long)parent_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t\tgoto out_attach;\n\t}\n\n\t \n\tdl = kmalloc(sizeof(*dl), GFP_NOFS);\n\tif (!dl) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tdl->dl_count = 0;\n\t \n\tdl->dl_inode = igrab(inode);\n\tdl->dl_parent_blkno = parent_blkno;\n\tocfs2_dentry_lock_res_init(dl, parent_blkno, inode);\n\nout_attach:\n\tspin_lock(&dentry_attach_lock);\n\tif (unlikely(dentry->d_fsdata && !alias)) {\n\t\t \n\t\tspin_unlock(&dentry_attach_lock);\n\t\tiput(dl->dl_inode);\n\t\tocfs2_lock_res_free(&dl->dl_lockres);\n\t\tkfree(dl);\n\t\treturn 0;\n\t}\n\n\tdentry->d_fsdata = dl;\n\tdl->dl_count++;\n\tspin_unlock(&dentry_attach_lock);\n\n\t \n\tret = ocfs2_dentry_lock(dentry, 0);\n\tif (!ret)\n\t\tocfs2_dentry_unlock(dentry, 0);\n\telse\n\t\tmlog_errno(ret);\n\n\t \n\tif (ret < 0 && !alias) {\n\t\tocfs2_lock_res_free(&dl->dl_lockres);\n\t\tBUG_ON(dl->dl_count != 1);\n\t\tspin_lock(&dentry_attach_lock);\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry_attach_lock);\n\t\tkfree(dl);\n\t\tiput(inode);\n\t}\n\n\tdput(alias);\n\n\treturn ret;\n}\n\n \nstatic void ocfs2_drop_dentry_lock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_dentry_lock *dl)\n{\n\tiput(dl->dl_inode);\n\tocfs2_simple_drop_lockres(osb, &dl->dl_lockres);\n\tocfs2_lock_res_free(&dl->dl_lockres);\n\tkfree(dl);\n}\n\nvoid ocfs2_dentry_lock_put(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_dentry_lock *dl)\n{\n\tint unlock = 0;\n\n\tBUG_ON(dl->dl_count == 0);\n\n\tspin_lock(&dentry_attach_lock);\n\tdl->dl_count--;\n\tunlock = !dl->dl_count;\n\tspin_unlock(&dentry_attach_lock);\n\n\tif (unlock)\n\t\tocfs2_drop_dentry_lock(osb, dl);\n}\n\nstatic void ocfs2_dentry_iput(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\tif (!dl) {\n\t\t \n\t\tif (!(dentry->d_flags & DCACHE_DISCONNECTED) &&\n\t\t    !d_unhashed(dentry)) {\n\t\t\tunsigned long long ino = 0ULL;\n\t\t\tif (inode)\n\t\t\t\tino = (unsigned long long)OCFS2_I(inode)->ip_blkno;\n\t\t\tmlog(ML_ERROR, \"Dentry is missing cluster lock. \"\n\t\t\t     \"inode: %llu, d_flags: 0x%x, d_name: %pd\\n\",\n\t\t\t     ino, dentry->d_flags, dentry);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tmlog_bug_on_msg(dl->dl_count == 0, \"dentry: %pd, count: %u\\n\",\n\t\t\tdentry, dl->dl_count);\n\n\tocfs2_dentry_lock_put(OCFS2_SB(dentry->d_sb), dl);\n\nout:\n\tiput(inode);\n}\n\n \nvoid ocfs2_dentry_move(struct dentry *dentry, struct dentry *target,\n\t\t       struct inode *old_dir, struct inode *new_dir)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(old_dir->i_sb);\n\tstruct inode *inode = d_inode(dentry);\n\n\t \n\tif (old_dir == new_dir)\n\t\tgoto out_move;\n\n\tocfs2_dentry_lock_put(osb, dentry->d_fsdata);\n\n\tdentry->d_fsdata = NULL;\n\tret = ocfs2_dentry_attach_lock(dentry, inode, OCFS2_I(new_dir)->ip_blkno);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_move:\n\td_move(dentry, target);\n}\n\nconst struct dentry_operations ocfs2_dentry_ops = {\n\t.d_revalidate\t\t= ocfs2_dentry_revalidate,\n\t.d_iput\t\t\t= ocfs2_dentry_iput,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}