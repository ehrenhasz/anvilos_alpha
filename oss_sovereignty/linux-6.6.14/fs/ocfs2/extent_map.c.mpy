{
  "module_name": "extent_map.c",
  "hash_id": "8cf2ae471cd8583aa9adecf9620993d12c3691b547155e306695d9797d16907e",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/extent_map.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fiemap.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"alloc.h\"\n#include \"dlmglue.h\"\n#include \"extent_map.h\"\n#include \"inode.h\"\n#include \"super.h\"\n#include \"symlink.h\"\n#include \"aops.h\"\n#include \"ocfs2_trace.h\"\n\n#include \"buffer_head_io.h\"\n\n \n\nvoid ocfs2_extent_map_init(struct inode *inode)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->ip_extent_map.em_num_items = 0;\n\tINIT_LIST_HEAD(&oi->ip_extent_map.em_list);\n}\n\nstatic void __ocfs2_extent_map_lookup(struct ocfs2_extent_map *em,\n\t\t\t\t      unsigned int cpos,\n\t\t\t\t      struct ocfs2_extent_map_item **ret_emi)\n{\n\tunsigned int range;\n\tstruct ocfs2_extent_map_item *emi;\n\n\t*ret_emi = NULL;\n\n\tlist_for_each_entry(emi, &em->em_list, ei_list) {\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\n\t\tif (cpos >= emi->ei_cpos && cpos < range) {\n\t\t\tlist_move(&emi->ei_list, &em->em_list);\n\n\t\t\t*ret_emi = emi;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int ocfs2_extent_map_lookup(struct inode *inode, unsigned int cpos,\n\t\t\t\t   unsigned int *phys, unsigned int *len,\n\t\t\t\t   unsigned int *flags)\n{\n\tunsigned int coff;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map_item *emi;\n\n\tspin_lock(&oi->ip_lock);\n\n\t__ocfs2_extent_map_lookup(&oi->ip_extent_map, cpos, &emi);\n\tif (emi) {\n\t\tcoff = cpos - emi->ei_cpos;\n\t\t*phys = emi->ei_phys + coff;\n\t\tif (len)\n\t\t\t*len = emi->ei_clusters - coff;\n\t\tif (flags)\n\t\t\t*flags = emi->ei_flags;\n\t}\n\n\tspin_unlock(&oi->ip_lock);\n\n\tif (emi == NULL)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\n \nvoid ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t \n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t \n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}\n\n \nstatic int ocfs2_ei_is_contained(struct ocfs2_extent_map_item *emi1,\n\t\t\t\t struct ocfs2_extent_map_item *emi2)\n{\n\tunsigned int range1, range2;\n\n\t \n\trange1 = emi1->ei_cpos + emi1->ei_clusters;\n\tif (emi2->ei_cpos >= emi1->ei_cpos && emi2->ei_cpos < range1)\n\t\treturn 1;\n\n\t \n\trange2 = emi2->ei_cpos + emi2->ei_clusters;\n\tif (range2 > emi1->ei_cpos && range2 <= range1)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void ocfs2_copy_emi_fields(struct ocfs2_extent_map_item *dest,\n\t\t\t\t  struct ocfs2_extent_map_item *src)\n{\n\tdest->ei_cpos = src->ei_cpos;\n\tdest->ei_phys = src->ei_phys;\n\tdest->ei_clusters = src->ei_clusters;\n\tdest->ei_flags = src->ei_flags;\n}\n\n \nstatic int ocfs2_try_to_merge_extent_map(struct ocfs2_extent_map_item *emi,\n\t\t\t\t\t struct ocfs2_extent_map_item *ins)\n{\n\t \n\tif (ins->ei_phys == (emi->ei_phys + emi->ei_clusters) &&\n\t    ins->ei_cpos == (emi->ei_cpos + emi->ei_clusters) &&\n\t    ins->ei_flags == emi->ei_flags) {\n\t\temi->ei_clusters += ins->ei_clusters;\n\t\treturn 1;\n\t} else if ((ins->ei_phys + ins->ei_clusters) == emi->ei_phys &&\n\t\t   (ins->ei_cpos + ins->ei_clusters) == emi->ei_cpos &&\n\t\t   ins->ei_flags == emi->ei_flags) {\n\t\temi->ei_phys = ins->ei_phys;\n\t\temi->ei_cpos = ins->ei_cpos;\n\t\temi->ei_clusters += ins->ei_clusters;\n\t\treturn 1;\n\t}\n\n\t \n\tif (ocfs2_ei_is_contained(emi, ins) ||\n\t    ocfs2_ei_is_contained(ins, emi)) {\n\t\tocfs2_copy_emi_fields(emi, ins);\n\t\treturn 1;\n\t}\n\n\t \n\treturn 0;\n}\n\n \nvoid ocfs2_extent_map_insert_rec(struct inode *inode,\n\t\t\t\t struct ocfs2_extent_rec *rec)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tstruct ocfs2_extent_map_item *emi, *new_emi = NULL;\n\tstruct ocfs2_extent_map_item ins;\n\n\tins.ei_cpos = le32_to_cpu(rec->e_cpos);\n\tins.ei_phys = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t       le64_to_cpu(rec->e_blkno));\n\tins.ei_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\tins.ei_flags = rec->e_flags;\n\nsearch:\n\tspin_lock(&oi->ip_lock);\n\n\tlist_for_each_entry(emi, &em->em_list, ei_list) {\n\t\tif (ocfs2_try_to_merge_extent_map(emi, &ins)) {\n\t\t\tlist_move(&emi->ei_list, &em->em_list);\n\t\t\tspin_unlock(&oi->ip_lock);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\n\tif (em->em_num_items < OCFS2_MAX_EXTENT_MAP_ITEMS) {\n\t\tif (new_emi == NULL) {\n\t\t\tspin_unlock(&oi->ip_lock);\n\n\t\t\tnew_emi = kmalloc(sizeof(*new_emi), GFP_NOFS);\n\t\t\tif (new_emi == NULL)\n\t\t\t\tgoto out;\n\n\t\t\tgoto search;\n\t\t}\n\n\t\tocfs2_copy_emi_fields(new_emi, &ins);\n\t\tlist_add(&new_emi->ei_list, &em->em_list);\n\t\tem->em_num_items++;\n\t\tnew_emi = NULL;\n\t} else {\n\t\tBUG_ON(list_empty(&em->em_list) || em->em_num_items == 0);\n\t\temi = list_entry(em->em_list.prev,\n\t\t\t\t struct ocfs2_extent_map_item, ei_list);\n\t\tlist_move(&emi->ei_list, &em->em_list);\n\t\tocfs2_copy_emi_fields(emi, &ins);\n\t}\n\n\tspin_unlock(&oi->ip_lock);\n\nout:\n\tkfree(new_emi);\n}\n\nstatic int ocfs2_last_eb_is_empty(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di)\n{\n\tint ret, next_free;\n\tu64 last_eb_blk = le64_to_cpu(di->i_last_eb_blk);\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tret = ocfs2_read_extent_block(INODE_CACHE(inode), last_eb_blk, &eb_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\tel = &eb->h_list;\n\n\tif (el->l_tree_depth) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %lu has non zero tree depth in leaf block %llu\\n\",\n\t\t\t    inode->i_ino,\n\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\n\tif (next_free == 0 ||\n\t    (next_free == 1 && ocfs2_is_empty_extent(&el->l_recs[0])))\n\t\tret = 1;\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}\n\n \nstatic int ocfs2_search_for_hole_index(struct ocfs2_extent_list *el,\n\t\t\t\t       u32 v_cluster)\n{\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (v_cluster < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\n \nint ocfs2_figure_hole_clusters(struct ocfs2_caching_info *ci,\n\t\t\t       struct ocfs2_extent_list *el,\n\t\t\t       struct buffer_head *eb_bh,\n\t\t\t       u32 v_cluster,\n\t\t\t       u32 *num_clusters)\n{\n\tint ret, i;\n\tstruct buffer_head *next_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb, *next_eb;\n\n\ti = ocfs2_search_for_hole_index(el, v_cluster);\n\n\tif (i == le16_to_cpu(el->l_next_free_rec) && eb_bh) {\n\t\teb = (struct ocfs2_extent_block *)eb_bh->b_data;\n\n\t\t \n\n\t\tif (le64_to_cpu(eb->h_next_leaf_blk) == 0ULL)\n\t\t\tgoto no_more_extents;\n\n\t\tret = ocfs2_read_extent_block(ci,\n\t\t\t\t\t      le64_to_cpu(eb->h_next_leaf_blk),\n\t\t\t\t\t      &next_eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnext_eb = (struct ocfs2_extent_block *)next_eb_bh->b_data;\n\t\tel = &next_eb->h_list;\n\t\ti = ocfs2_search_for_hole_index(el, v_cluster);\n\t}\n\nno_more_extents:\n\tif (i == le16_to_cpu(el->l_next_free_rec)) {\n\t\t \n\t\t*num_clusters = UINT_MAX - v_cluster;\n\t} else {\n\t\t*num_clusters = le32_to_cpu(el->l_recs[i].e_cpos) - v_cluster;\n\t}\n\n\tret = 0;\nout:\n\tbrelse(next_eb_bh);\n\treturn ret;\n}\n\nstatic int ocfs2_get_clusters_nocache(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh,\n\t\t\t\t      u32 v_cluster, unsigned int *hole_len,\n\t\t\t\t      struct ocfs2_extent_rec *ret_rec,\n\t\t\t\t      unsigned int *is_last)\n{\n\tint i, ret, tree_height, len;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct buffer_head *eb_bh = NULL;\n\n\tmemset(ret_rec, 0, sizeof(*ret_rec));\n\tif (is_last)\n\t\t*is_last = 0;\n\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\tel = &di->id2.i_list;\n\ttree_height = le16_to_cpu(el->l_tree_depth);\n\n\tif (tree_height > 0) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in leaf block %llu\\n\",\n\t\t\t\t    inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\t \n\t\tif (hole_len) {\n\t\t\tret = ocfs2_figure_hole_clusters(INODE_CACHE(inode),\n\t\t\t\t\t\t\t el, eb_bh,\n\t\t\t\t\t\t\t v_cluster, &len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*hole_len = len;\n\t\t}\n\t\tgoto out_hole;\n\t}\n\n\trec = &el->l_recs[i];\n\n\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\tif (!rec->e_blkno) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %lu has bad extent record (%u, %u, 0)\\n\",\n\t\t\t    inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t*ret_rec = *rec;\n\n\t \n\tif (is_last) {\n\t\tif (i == (le16_to_cpu(el->l_next_free_rec) - 1)) {\n\t\t\tif (tree_height == 0)\n\t\t\t\t*is_last = 1;\n\t\t\telse if (eb->h_blkno == di->i_last_eb_blk)\n\t\t\t\t*is_last = 1;\n\t\t\telse if (eb->h_next_leaf_blk == di->i_last_eb_blk) {\n\t\t\t\tret = ocfs2_last_eb_is_empty(inode, di);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ret == 1)\n\t\t\t\t\t*is_last = 1;\n\t\t\t}\n\t\t}\n\t}\n\nout_hole:\n\tret = 0;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}\n\nstatic void ocfs2_relative_extent_offsets(struct super_block *sb,\n\t\t\t\t\t  u32 v_cluster,\n\t\t\t\t\t  struct ocfs2_extent_rec *rec,\n\t\t\t\t\t  u32 *p_cluster, u32 *num_clusters)\n\n{\n\tu32 coff = v_cluster - le32_to_cpu(rec->e_cpos);\n\n\t*p_cluster = ocfs2_blocks_to_clusters(sb, le64_to_cpu(rec->e_blkno));\n\t*p_cluster = *p_cluster + coff;\n\n\tif (num_clusters)\n\t\t*num_clusters = le16_to_cpu(rec->e_leaf_clusters) - coff;\n}\n\nint ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in xattr leaf block %llu\\n\",\n\t\t\t\t    inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has bad extent record (%u, %u, 0) in xattr\\n\",\n\t\t\t\t    inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}\n\nint ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int hole_len, flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t \n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}\n\n \nint ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}\n\n \nstatic int ocfs2_fiemap_inline(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t       struct fiemap_extent_info *fieinfo,\n\t\t\t       u64 map_start)\n{\n\tint ret;\n\tunsigned int id_count;\n\tstruct ocfs2_dinode *di;\n\tu64 phys;\n\tu32 flags = FIEMAP_EXTENT_DATA_INLINE|FIEMAP_EXTENT_LAST;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tif (ocfs2_inode_is_fast_symlink(inode))\n\t\tid_count = ocfs2_fast_symlink_chars(inode->i_sb);\n\telse\n\t\tid_count = le16_to_cpu(di->id2.i_data.id_count);\n\n\tif (map_start < id_count) {\n\t\tphys = oi->ip_blkno << inode->i_sb->s_blocksize_bits;\n\t\tif (ocfs2_inode_is_fast_symlink(inode))\n\t\t\tphys += offsetof(struct ocfs2_dinode, id2.i_symlink);\n\t\telse\n\t\t\tphys += offsetof(struct ocfs2_dinode,\n\t\t\t\t\t id2.i_data.id_data);\n\n\t\tret = fiemap_fill_next_extent(fieinfo, 0, phys, id_count,\n\t\t\t\t\t      flags);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ocfs2_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t u64 map_start, u64 map_len)\n{\n\tint ret, is_last;\n\tu32 mapping_end, cpos;\n\tunsigned int hole_size;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu64 len_bytes, phys_bytes, virt_bytes;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tret = fiemap_prep(inode, fieinfo, map_start, &map_len, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\n\t \n\tif ((OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) ||\n\t    ocfs2_inode_is_fast_symlink(inode)) {\n\t\tret = ocfs2_fiemap_inline(inode, di_bh, fieinfo, map_start);\n\t\tgoto out_unlock;\n\t}\n\n\tcpos = map_start >> osb->s_clustersize_bits;\n\tmapping_end = ocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t       map_start + map_len);\n\tis_last = 0;\n\twhile (cpos < mapping_end && !is_last) {\n\t\tu32 fe_flags;\n\n\t\tret = ocfs2_get_clusters_nocache(inode, di_bh, cpos,\n\t\t\t\t\t\t &hole_size, &rec, &is_last);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (rec.e_blkno == 0ULL) {\n\t\t\tcpos += hole_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfe_flags = 0;\n\t\tif (rec.e_flags & OCFS2_EXT_UNWRITTEN)\n\t\t\tfe_flags |= FIEMAP_EXTENT_UNWRITTEN;\n\t\tif (rec.e_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tfe_flags |= FIEMAP_EXTENT_SHARED;\n\t\tif (is_last)\n\t\t\tfe_flags |= FIEMAP_EXTENT_LAST;\n\t\tlen_bytes = (u64)le16_to_cpu(rec.e_leaf_clusters) << osb->s_clustersize_bits;\n\t\tphys_bytes = le64_to_cpu(rec.e_blkno) << osb->sb->s_blocksize_bits;\n\t\tvirt_bytes = (u64)le32_to_cpu(rec.e_cpos) << osb->s_clustersize_bits;\n\n\t\tret = fiemap_fill_next_extent(fieinfo, virt_bytes, phys_bytes,\n\t\t\t\t\t      len_bytes, fe_flags);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tcpos = le32_to_cpu(rec.e_cpos)+ le16_to_cpu(rec.e_leaf_clusters);\n\t}\n\n\tif (ret > 0)\n\t\tret = 0;\n\nout_unlock:\n\tbrelse(di_bh);\n\n\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tocfs2_inode_unlock(inode, 0);\nout:\n\n\treturn ret;\n}\n\n \nint ocfs2_overwrite_io(struct inode *inode, struct buffer_head *di_bh,\n\t\t       u64 map_start, u64 map_len)\n{\n\tint ret = 0, is_last;\n\tu32 mapping_end, cpos;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tif (ocfs2_size_fits_inline_data(di_bh, map_start + map_len))\n\t\t\treturn ret;\n\t\telse\n\t\t\treturn -EAGAIN;\n\t}\n\n\tcpos = map_start >> osb->s_clustersize_bits;\n\tmapping_end = ocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t       map_start + map_len);\n\tis_last = 0;\n\twhile (cpos < mapping_end && !is_last) {\n\t\tret = ocfs2_get_clusters_nocache(inode, di_bh, cpos,\n\t\t\t\t\t\t NULL, &rec, &is_last);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (rec.e_blkno == 0ULL)\n\t\t\tbreak;\n\n\t\tif (rec.e_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tbreak;\n\n\t\tcpos = le32_to_cpu(rec.e_cpos) +\n\t\t\tle16_to_cpu(rec.e_leaf_clusters);\n\t}\n\n\tif (cpos < mapping_end)\n\t\tret = -EAGAIN;\nout:\n\treturn ret;\n}\n\nint ocfs2_seek_data_hole_offset(struct file *file, loff_t *offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\tunsigned int is_last = 0, is_data = 0;\n\tu16 cs_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tu32 cpos, cend, clen, hole_size;\n\tu64 extoff, extlen;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tBUG_ON(whence != SEEK_DATA && whence != SEEK_HOLE);\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tif (*offset >= i_size_read(inode)) {\n\t\tret = -ENXIO;\n\t\tgoto out_unlock;\n\t}\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tif (whence == SEEK_HOLE)\n\t\t\t*offset = i_size_read(inode);\n\t\tgoto out_unlock;\n\t}\n\n\tclen = 0;\n\tcpos = *offset >> cs_bits;\n\tcend = ocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode));\n\n\twhile (cpos < cend && !is_last) {\n\t\tret = ocfs2_get_clusters_nocache(inode, di_bh, cpos, &hole_size,\n\t\t\t\t\t\t &rec, &is_last);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\textoff = cpos;\n\t\textoff <<= cs_bits;\n\n\t\tif (rec.e_blkno == 0ULL) {\n\t\t\tclen = hole_size;\n\t\t\tis_data = 0;\n\t\t} else {\n\t\t\tclen = le16_to_cpu(rec.e_leaf_clusters) -\n\t\t\t\t(cpos - le32_to_cpu(rec.e_cpos));\n\t\t\tis_data = (rec.e_flags & OCFS2_EXT_UNWRITTEN) ?  0 : 1;\n\t\t}\n\n\t\tif ((!is_data && whence == SEEK_HOLE) ||\n\t\t    (is_data && whence == SEEK_DATA)) {\n\t\t\tif (extoff > *offset)\n\t\t\t\t*offset = extoff;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (!is_last)\n\t\t\tcpos += clen;\n\t}\n\n\tif (whence == SEEK_HOLE) {\n\t\textoff = cpos;\n\t\textoff <<= cs_bits;\n\t\textlen = clen;\n\t\textlen <<=  cs_bits;\n\n\t\tif ((extoff + extlen) > i_size_read(inode))\n\t\t\textlen = i_size_read(inode) - extoff;\n\t\textoff += extlen;\n\t\tif (extoff > *offset)\n\t\t\t*offset = extoff;\n\t\tgoto out_unlock;\n\t}\n\n\tret = -ENXIO;\n\nout_unlock:\n\n\tbrelse(di_bh);\n\n\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tocfs2_inode_unlock(inode, 0);\nout:\n\treturn ret;\n}\n\nint ocfs2_read_virt_blocks(struct inode *inode, u64 v_block, int nr,\n\t\t\t   struct buffer_head *bhs[], int flags,\n\t\t\t   int (*validate)(struct super_block *sb,\n\t\t\t\t\t   struct buffer_head *bh))\n{\n\tint rc = 0;\n\tu64 p_block, p_count;\n\tint i, count, done = 0;\n\n\ttrace_ocfs2_read_virt_blocks(\n\t     inode, (unsigned long long)v_block, nr, bhs, flags,\n\t     validate);\n\n\tif (((v_block + nr - 1) << inode->i_sb->s_blocksize_bits) >=\n\t    i_size_read(inode)) {\n\t\tBUG_ON(!(flags & OCFS2_BH_READAHEAD));\n\t\tgoto out;\n\t}\n\n\twhile (done < nr) {\n\t\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t\trc = ocfs2_extent_map_get_blocks(inode, v_block + done,\n\t\t\t\t\t\t &p_block, &p_count, NULL);\n\t\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!p_block) {\n\t\t\trc = -EIO;\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode #%llu contains a hole at offset %llu\\n\",\n\t\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t     (unsigned long long)(v_block + done) <<\n\t\t\t     inode->i_sb->s_blocksize_bits);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = nr - done;\n\t\tif (p_count < count)\n\t\t\tcount = p_count;\n\n\t\t \n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (!bhs[done + i])\n\t\t\t\tcontinue;\n\t\t\tBUG_ON(bhs[done + i]->b_blocknr != (p_block + i));\n\t\t}\n\n\t\trc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, count,\n\t\t\t\t       bhs + done, flags, validate);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t\tdone += count;\n\t}\n\nout:\n\treturn rc;\n}\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}