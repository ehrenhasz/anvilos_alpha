{
  "module_name": "namei.c",
  "hash_id": "54e53d8ddbf998a0218e7f0dd5324bf4adedc87765cb85fae4a702b86346dc9b",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/namei.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/iversion.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"alloc.h\"\n#include \"dcache.h\"\n#include \"dir.h\"\n#include \"dlmglue.h\"\n#include \"extent_map.h\"\n#include \"file.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"namei.h\"\n#include \"suballoc.h\"\n#include \"super.h\"\n#include \"symlink.h\"\n#include \"sysfile.h\"\n#include \"uptodate.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ocfs2_trace.h\"\n#include \"ioctl.h\"\n\n#include \"buffer_head_io.h\"\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);\n\nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio);\n\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio);\n\nstatic int ocfs2_create_symlink_data(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     const char *symname);\n\nstatic int ocfs2_double_lock(struct ocfs2_super *osb,\n\t\t\t     struct buffer_head **bh1,\n\t\t\t     struct inode *inode1,\n\t\t\t     struct buffer_head **bh2,\n\t\t\t     struct inode *inode2,\n\t\t\t     int rename);\n\nstatic void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2);\n \n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic struct dentry *ocfs2_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t   unsigned int flags)\n{\n\tint status;\n\tu64 blkno;\n\tstruct inode *inode = NULL;\n\tstruct dentry *ret;\n\tstruct ocfs2_inode_info *oi;\n\n\ttrace_ocfs2_lookup(dir, dentry, dentry->d_name.len,\n\t\t\t   dentry->d_name.name,\n\t\t\t   (unsigned long long)OCFS2_I(dir)->ip_blkno, 0);\n\n\tif (dentry->d_name.len > OCFS2_MAX_FILENAME_LEN) {\n\t\tret = ERR_PTR(-ENAMETOOLONG);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_inode_lock_nested(dir, NULL, 0, OI_LS_PARENT);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tret = ERR_PTR(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_lookup_ino_from_name(dir, dentry->d_name.name,\n\t\t\t\t\t    dentry->d_name.len, &blkno);\n\tif (status < 0)\n\t\tgoto bail_add;\n\n\tinode = ocfs2_iget(OCFS2_SB(dir->i_sb), blkno, 0, 0);\n\tif (IS_ERR(inode)) {\n\t\tret = ERR_PTR(-EACCES);\n\t\tgoto bail_unlock;\n\t}\n\n\toi = OCFS2_I(inode);\n\t \n\tspin_lock(&oi->ip_lock);\n\toi->ip_flags &= ~OCFS2_INODE_MAYBE_ORPHANED;\n\tspin_unlock(&oi->ip_lock);\n\nbail_add:\n\tret = d_splice_alias(inode, dentry);\n\n\tif (inode) {\n\t\t \n\t\tif (!IS_ERR_OR_NULL(ret))\n\t\t\tdentry = ret;\n\n\t\tstatus = ocfs2_dentry_attach_lock(dentry, inode,\n\t\t\t\t\t\t  OCFS2_I(dir)->ip_blkno);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tret = ERR_PTR(status);\n\t\t\tgoto bail_unlock;\n\t\t}\n\t} else\n\t\tocfs2_dentry_attach_gen(dentry);\n\nbail_unlock:\n\t \n\tocfs2_inode_unlock(dir, 0);\n\nbail:\n\n\ttrace_ocfs2_lookup_ret(ret);\n\n\treturn ret;\n}\n\nstatic struct inode *ocfs2_get_init_inode(struct inode *dir, umode_t mode)\n{\n\tstruct inode *inode;\n\tint status;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode) {\n\t\tmlog(ML_ERROR, \"new_inode failed!\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t \n\tif (S_ISDIR(mode))\n\t\tset_nlink(inode, 2);\n\tmode = mode_strip_sgid(&nop_mnt_idmap, dir, mode);\n\tinode_init_owner(&nop_mnt_idmap, inode, dir, mode);\n\tstatus = dquot_initialize(inode);\n\tif (status)\n\t\treturn ERR_PTR(status);\n\n\treturn inode;\n}\n\nstatic void ocfs2_cleanup_add_entry_failure(struct ocfs2_super *osb,\n\t\tstruct dentry *dentry, struct inode *inode)\n{\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\n\tocfs2_simple_drop_lockres(osb, &dl->dl_lockres);\n\tocfs2_lock_res_free(&dl->dl_lockres);\n\tBUG_ON(dl->dl_count != 1);\n\tspin_lock(&dentry_attach_lock);\n\tdentry->d_fsdata = NULL;\n\tspin_unlock(&dentry_attach_lock);\n\tkfree(dl);\n\tiput(inode);\n}\n\nstatic int ocfs2_mknod(struct mnt_idmap *idmap,\n\t\t       struct inode *dir,\n\t\t       struct dentry *dentry,\n\t\t       umode_t mode,\n\t\t       dev_t dev)\n{\n\tint status = 0;\n\tstruct buffer_head *parent_fe_bh = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_super *osb;\n\tstruct ocfs2_dinode *dirfe;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct buffer_head *new_fe_bh = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tint want_clusters = 0;\n\tint want_meta = 0;\n\tint xattr_credits = 0;\n\tstruct ocfs2_security_xattr_info si = {\n\t\t.name = NULL,\n\t\t.enable = 1,\n\t};\n\tint did_quota_inode = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\tsigset_t oldset;\n\tint did_block_signals = 0;\n\tstruct ocfs2_dentry_lock *dl = NULL;\n\n\ttrace_ocfs2_mknod(dir, dentry, dentry->d_name.len, dentry->d_name.name,\n\t\t\t  (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t  (unsigned long)dev, mode);\n\n\tstatus = dquot_initialize(dir);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\t \n\tosb = OCFS2_SB(dir->i_sb);\n\n\tstatus = ocfs2_inode_lock(dir, &parent_fe_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tif (S_ISDIR(mode) && (dir->i_nlink >= ocfs2_link_max(osb))) {\n\t\tstatus = -EMLINK;\n\t\tgoto leave;\n\t}\n\n\tdirfe = (struct ocfs2_dinode *) parent_fe_bh->b_data;\n\tif (!ocfs2_read_links_count(dirfe)) {\n\t\t \n\t\tstatus = -ENOENT;\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_check_dir_for_entry(dir, dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len);\n\tif (status)\n\t\tgoto leave;\n\n\t \n\tstatus = ocfs2_prepare_dir_for_insert(osb, dir, parent_fe_bh,\n\t\t\t\t\t      dentry->d_name.name,\n\t\t\t\t\t      dentry->d_name.len, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t \n\tstatus = ocfs2_reserve_new_inode(osb, &inode_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinode = ocfs2_get_init_inode(dir, mode);\n\tif (IS_ERR(inode)) {\n\t\tstatus = PTR_ERR(inode);\n\t\tinode = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t \n\tstatus = ocfs2_init_security_get(inode, dir, &dentry->d_name, &si);\n\tif (status) {\n\t\tif (status == -EOPNOTSUPP)\n\t\t\tsi.enable = 0;\n\t\telse {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\t \n\tstatus = ocfs2_calc_xattr_init(dir, parent_fe_bh, mode,\n\t\t\t\t       &si, &want_clusters,\n\t\t\t\t       &xattr_credits, &want_meta);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t \n\tif (S_ISDIR(mode) && !ocfs2_supports_inline_data(osb)) {\n\t\twant_clusters += 1;\n\n\t\t \n\t\tif (ocfs2_supports_indexed_dirs(osb))\n\t\t\twant_meta++;\n\t}\n\n\tstatus = ocfs2_reserve_new_metadata_blocks(osb, want_meta, &meta_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_reserve_clusters(osb, want_clusters, &data_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_mknod_credits(osb->sb,\n\t\t\t\t\t\t\t    S_ISDIR(mode),\n\t\t\t\t\t\t\t    xattr_credits));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t \n\tocfs2_block_signals(&oldset);\n\tdid_block_signals = 1;\n\n\tstatus = dquot_alloc_inode(inode);\n\tif (status)\n\t\tgoto leave;\n\tdid_quota_inode = 1;\n\n\t \n\tstatus = ocfs2_mknod_locked(osb, dir, inode, dev,\n\t\t\t\t    &new_fe_bh, parent_fe_bh, handle,\n\t\t\t\t    inode_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tfe = (struct ocfs2_dinode *) new_fe_bh->b_data;\n\tif (S_ISDIR(mode)) {\n\t\tstatus = ocfs2_fill_new_dir(osb, handle, dir, inode,\n\t\t\t\t\t    new_fe_bh, data_ac, meta_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(dir),\n\t\t\t\t\t\t parent_fe_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t\tocfs2_add_links_count(dirfe, 1);\n\t\tocfs2_journal_dirty(handle, parent_fe_bh);\n\t\tinc_nlink(dir);\n\t}\n\n\tstatus = ocfs2_init_acl(handle, inode, dir, new_fe_bh, parent_fe_bh,\n\t\t\t meta_ac, data_ac);\n\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto roll_back;\n\t}\n\n\tif (si.enable) {\n\t\tstatus = ocfs2_init_security_set(handle, inode, new_fe_bh, &si,\n\t\t\t\t\t\t meta_ac, data_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto roll_back;\n\t\t}\n\t}\n\n\t \n\tstatus = ocfs2_dentry_attach_lock(dentry, inode,\n\t\t\t\t\t  OCFS2_I(dir)->ip_blkno);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto roll_back;\n\t}\n\n\tdl = dentry->d_fsdata;\n\n\tstatus = ocfs2_add_entry(handle, dentry, inode,\n\t\t\t\t OCFS2_I(inode)->ip_blkno, parent_fe_bh,\n\t\t\t\t &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto roll_back;\n\t}\n\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\n\tstatus = 0;\n\nroll_back:\n\tif (status < 0 && S_ISDIR(mode)) {\n\t\tocfs2_add_links_count(dirfe, -1);\n\t\tdrop_nlink(dir);\n\t}\n\nleave:\n\tif (status < 0 && did_quota_inode)\n\t\tdquot_free_inode(inode);\n\tif (handle) {\n\t\tif (status < 0 && fe)\n\t\t\tocfs2_set_links_count(fe, 0);\n\t\tocfs2_commit_trans(osb, handle);\n\t}\n\n\tocfs2_inode_unlock(dir, 1);\n\tif (did_block_signals)\n\t\tocfs2_unblock_signals(&oldset);\n\n\tbrelse(new_fe_bh);\n\tbrelse(parent_fe_bh);\n\tkfree(si.value);\n\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (inode_ac)\n\t\tocfs2_free_alloc_context(inode_ac);\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\t \n\tif ((status < 0) && inode) {\n\t\tif (dl)\n\t\t\tocfs2_cleanup_add_entry_failure(osb, dentry, inode);\n\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_SKIP_ORPHAN_DIR;\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}\n\nstatic int __ocfs2_mknod_locked(struct inode *dir,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tdev_t dev,\n\t\t\t\tstruct buffer_head **new_fe_bh,\n\t\t\t\tstruct buffer_head *parent_fe_bh,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_alloc_context *inode_ac,\n\t\t\t\tu64 fe_blkno, u64 suballoc_loc, u16 suballoc_bit)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_extent_list *fel;\n\tu16 feat;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct timespec64 ts;\n\n\t*new_fe_bh = NULL;\n\n\t \n\tinode->i_ino = ino_from_blkno(osb->sb, fe_blkno);\n\toi->ip_blkno = fe_blkno;\n\tspin_lock(&osb->osb_lock);\n\tinode->i_generation = osb->s_next_generation++;\n\tspin_unlock(&osb->osb_lock);\n\n\t*new_fe_bh = sb_getblk(osb->sb, fe_blkno);\n\tif (!*new_fe_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), *new_fe_bh);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t\t *new_fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tfe = (struct ocfs2_dinode *) (*new_fe_bh)->b_data;\n\tmemset(fe, 0, osb->sb->s_blocksize);\n\n\tfe->i_generation = cpu_to_le32(inode->i_generation);\n\tfe->i_fs_generation = cpu_to_le32(osb->fs_generation);\n\tfe->i_blkno = cpu_to_le64(fe_blkno);\n\tfe->i_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tfe->i_suballoc_bit = cpu_to_le16(suballoc_bit);\n\tfe->i_suballoc_slot = cpu_to_le16(inode_ac->ac_alloc_slot);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tfe->id1.dev1.i_rdev = cpu_to_le64(huge_encode_dev(dev));\n\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\n\tfe->i_last_eb_blk = 0;\n\tstrcpy(fe->i_signature, OCFS2_INODE_SIGNATURE);\n\tfe->i_flags |= cpu_to_le32(OCFS2_VALID_FL);\n\tktime_get_real_ts64(&ts);\n\tfe->i_atime = fe->i_ctime = fe->i_mtime =\n\t\tcpu_to_le64(ts.tv_sec);\n\tfe->i_mtime_nsec = fe->i_ctime_nsec = fe->i_atime_nsec =\n\t\tcpu_to_le32(ts.tv_nsec);\n\tfe->i_dtime = 0;\n\n\t \n\tfeat = le16_to_cpu(fe->i_dyn_features);\n\tif (S_ISDIR(inode->i_mode) && ocfs2_supports_inline_data(osb)) {\n\t\tfe->i_dyn_features = cpu_to_le16(feat | OCFS2_INLINE_DATA_FL);\n\n\t\tfe->id2.i_data.id_count = cpu_to_le16(\n\t\t\t\tocfs2_max_inline_data_with_xattr(osb->sb, fe));\n\t} else {\n\t\tfel = &fe->id2.i_list;\n\t\tfel->l_tree_depth = 0;\n\t\tfel->l_next_free_rec = 0;\n\t\tfel->l_count = cpu_to_le16(ocfs2_extent_recs_per_inode(osb->sb));\n\t}\n\n\tocfs2_journal_dirty(handle, *new_fe_bh);\n\n\tocfs2_populate_inode(inode, fe, 1);\n\tocfs2_ci_set_new(osb, INODE_CACHE(inode));\n\tif (!ocfs2_mount_local(osb)) {\n\t\tstatus = ocfs2_create_new_inode_locks(inode);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\nleave:\n\tif (status < 0) {\n\t\tif (*new_fe_bh) {\n\t\t\tbrelse(*new_fe_bh);\n\t\t\t*new_fe_bh = NULL;\n\t\t}\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac)\n{\n\tint status = 0;\n\tu64 suballoc_loc, fe_blkno = 0;\n\tu16 suballoc_bit;\n\n\t*new_fe_bh = NULL;\n\n\tstatus = ocfs2_claim_new_inode(handle, dir, parent_fe_bh,\n\t\t\t\t       inode_ac, &suballoc_loc,\n\t\t\t\t       &suballoc_bit, &fe_blkno);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\treturn __ocfs2_mknod_locked(dir, inode, dev, new_fe_bh,\n\t\t\t\t    parent_fe_bh, handle, inode_ac,\n\t\t\t\t    fe_blkno, suballoc_loc, suballoc_bit);\n}\n\nstatic int ocfs2_mkdir(struct mnt_idmap *idmap,\n\t\t       struct inode *dir,\n\t\t       struct dentry *dentry,\n\t\t       umode_t mode)\n{\n\tint ret;\n\n\ttrace_ocfs2_mkdir(dir, dentry, dentry->d_name.len, dentry->d_name.name,\n\t\t\t  OCFS2_I(dir)->ip_blkno, mode);\n\tret = ocfs2_mknod(&nop_mnt_idmap, dir, dentry, mode | S_IFDIR, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}\n\nstatic int ocfs2_create(struct mnt_idmap *idmap,\n\t\t\tstruct inode *dir,\n\t\t\tstruct dentry *dentry,\n\t\t\tumode_t mode,\n\t\t\tbool excl)\n{\n\tint ret;\n\n\ttrace_ocfs2_create(dir, dentry, dentry->d_name.len, dentry->d_name.name,\n\t\t\t   (unsigned long long)OCFS2_I(dir)->ip_blkno, mode);\n\tret = ocfs2_mknod(&nop_mnt_idmap, dir, dentry, mode | S_IFREG, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}\n\nstatic int ocfs2_link(struct dentry *old_dentry,\n\t\t      struct inode *dir,\n\t\t      struct dentry *dentry)\n{\n\thandle_t *handle;\n\tstruct inode *inode = d_inode(old_dentry);\n\tstruct inode *old_dir = d_inode(old_dentry->d_parent);\n\tint err;\n\tstruct buffer_head *fe_bh = NULL;\n\tstruct buffer_head *old_dir_bh = NULL;\n\tstruct buffer_head *parent_fe_bh = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\tsigset_t oldset;\n\tu64 old_de_ino;\n\n\ttrace_ocfs2_link((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t old_dentry->d_name.len, old_dentry->d_name.name,\n\t\t\t dentry->d_name.len, dentry->d_name.name);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\terr = dquot_initialize(dir);\n\tif (err) {\n\t\tmlog_errno(err);\n\t\treturn err;\n\t}\n\n\terr = ocfs2_double_lock(osb, &old_dir_bh, old_dir,\n\t\t\t&parent_fe_bh, dir, 0);\n\tif (err < 0) {\n\t\tif (err != -ENOENT)\n\t\t\tmlog_errno(err);\n\t\treturn err;\n\t}\n\n\t \n\tif (!parent_fe_bh) {\n\t\tif (old_dir_bh) {\n\t\t\tparent_fe_bh = old_dir_bh;\n\t\t\tget_bh(parent_fe_bh);\n\t\t} else {\n\t\t\tmlog(ML_ERROR, \"%s: no old_dir_bh!\\n\", osb->uuid_str);\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!dir->i_nlink) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terr = ocfs2_lookup_ino_from_name(old_dir, old_dentry->d_name.name,\n\t\t\told_dentry->d_name.len, &old_de_ino);\n\tif (err) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t \n\tif (old_de_ino != OCFS2_I(inode)->ip_blkno) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terr = ocfs2_check_dir_for_entry(dir, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len);\n\tif (err)\n\t\tgoto out;\n\n\terr = ocfs2_prepare_dir_for_insert(osb, dir, parent_fe_bh,\n\t\t\t\t\t   dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len, &lookup);\n\tif (err < 0) {\n\t\tmlog_errno(err);\n\t\tgoto out;\n\t}\n\n\terr = ocfs2_inode_lock(inode, &fe_bh, 1);\n\tif (err < 0) {\n\t\tif (err != -ENOENT)\n\t\t\tmlog_errno(err);\n\t\tgoto out;\n\t}\n\n\tfe = (struct ocfs2_dinode *) fe_bh->b_data;\n\tif (ocfs2_read_links_count(fe) >= ocfs2_link_max(osb)) {\n\t\terr = -EMLINK;\n\t\tgoto out_unlock_inode;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_link_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(err);\n\t\tgoto out_unlock_inode;\n\t}\n\n\t \n\tocfs2_block_signals(&oldset);\n\n\terr = ocfs2_journal_access_di(handle, INODE_CACHE(inode), fe_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (err < 0) {\n\t\tmlog_errno(err);\n\t\tgoto out_commit;\n\t}\n\n\tinc_nlink(inode);\n\tinode_set_ctime_current(inode);\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_ctime = cpu_to_le64(inode_get_ctime(inode).tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode_get_ctime(inode).tv_nsec);\n\tocfs2_journal_dirty(handle, fe_bh);\n\n\terr = ocfs2_add_entry(handle, dentry, inode,\n\t\t\t      OCFS2_I(inode)->ip_blkno,\n\t\t\t      parent_fe_bh, &lookup);\n\tif (err) {\n\t\tocfs2_add_links_count(fe, -1);\n\t\tdrop_nlink(inode);\n\t\tmlog_errno(err);\n\t\tgoto out_commit;\n\t}\n\n\terr = ocfs2_dentry_attach_lock(dentry, inode, OCFS2_I(dir)->ip_blkno);\n\tif (err) {\n\t\tmlog_errno(err);\n\t\tgoto out_commit;\n\t}\n\n\tihold(inode);\n\td_instantiate(dentry, inode);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\tocfs2_unblock_signals(&oldset);\nout_unlock_inode:\n\tocfs2_inode_unlock(inode, 1);\n\nout:\n\tocfs2_double_unlock(old_dir, dir);\n\n\tbrelse(fe_bh);\n\tbrelse(parent_fe_bh);\n\tbrelse(old_dir_bh);\n\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (err)\n\t\tmlog_errno(err);\n\n\treturn err;\n}\n\n \nstatic int ocfs2_remote_dentry_delete(struct dentry *dentry)\n{\n\tint ret;\n\n\tret = ocfs2_dentry_lock(dentry, 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\telse\n\t\tocfs2_dentry_unlock(dentry, 1);\n\n\treturn ret;\n}\n\nstatic inline int ocfs2_inode_is_unlinkable(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (inode->i_nlink == 2)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (inode->i_nlink == 1)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int ocfs2_unlink(struct inode *dir,\n\t\t\tstruct dentry *dentry)\n{\n\tint status;\n\tint child_locked = 0;\n\tbool is_unlinkable = false;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct inode *orphan_dir = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tu64 blkno;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct buffer_head *fe_bh = NULL;\n\tstruct buffer_head *parent_node_bh = NULL;\n\thandle_t *handle = NULL;\n\tchar orphan_name[OCFS2_ORPHAN_NAMELEN + 1];\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\tstruct ocfs2_dir_lookup_result orphan_insert = { NULL, };\n\n\ttrace_ocfs2_unlink(dir, dentry, dentry->d_name.len,\n\t\t\t   dentry->d_name.name,\n\t\t\t   (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t   (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = dquot_initialize(dir);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tBUG_ON(d_inode(dentry->d_parent) != dir);\n\n\tif (inode == osb->root_inode)\n\t\treturn -EPERM;\n\n\tstatus = ocfs2_inode_lock_nested(dir, &parent_node_bh, 1,\n\t\t\t\t\t OI_LS_PARENT);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tstatus = ocfs2_find_files_on_disk(dentry->d_name.name,\n\t\t\t\t\t  dentry->d_name.len, &blkno, dir,\n\t\t\t\t\t  &lookup);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (OCFS2_I(inode)->ip_blkno != blkno) {\n\t\tstatus = -ENOENT;\n\n\t\ttrace_ocfs2_unlink_noent(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t(unsigned long long)blkno,\n\t\t\t\tOCFS2_I(inode)->ip_flags);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_inode_lock(inode, &fe_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tchild_locked = 1;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (inode->i_nlink != 2 || !ocfs2_empty_dir(inode)) {\n\t\t\tstatus = -ENOTEMPTY;\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\tstatus = ocfs2_remote_dentry_delete(dentry);\n\tif (status < 0) {\n\t\t \n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (ocfs2_inode_is_unlinkable(inode)) {\n\t\tstatus = ocfs2_prepare_orphan_dir(osb, &orphan_dir,\n\t\t\t\t\t\t  OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\t\t  orphan_name, &orphan_insert,\n\t\t\t\t\t\t  false);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto leave;\n\t\t}\n\t\tis_unlinkable = true;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_unlink_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tfe = (struct ocfs2_dinode *) fe_bh->b_data;\n\n\t \n\tstatus = ocfs2_delete_entry(handle, dir, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tdrop_nlink(inode);\n\tdrop_nlink(inode);\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tocfs2_journal_dirty(handle, fe_bh);\n\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tif (S_ISDIR(inode->i_mode))\n\t\tdrop_nlink(dir);\n\n\tstatus = ocfs2_mark_inode_dirty(handle, dir, parent_node_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tinc_nlink(dir);\n\t\tgoto leave;\n\t}\n\n\tif (is_unlinkable) {\n\t\tstatus = ocfs2_orphan_add(osb, handle, inode, fe_bh,\n\t\t\t\torphan_name, &orphan_insert, orphan_dir, false);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\nleave:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tif (orphan_dir) {\n\t\t \n\t\tocfs2_inode_unlock(orphan_dir, 1);\n\t\tinode_unlock(orphan_dir);\n\t\tiput(orphan_dir);\n\t}\n\n\tif (child_locked)\n\t\tocfs2_inode_unlock(inode, 1);\n\n\tocfs2_inode_unlock(dir, 1);\n\n\tbrelse(fe_bh);\n\tbrelse(parent_node_bh);\n\n\tocfs2_free_dir_lookup_result(&orphan_insert);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (status && (status != -ENOTEMPTY) && (status != -ENOENT))\n\t\tmlog_errno(status);\n\n\treturn status;\n}\n\nstatic int ocfs2_check_if_ancestor(struct ocfs2_super *osb,\n\t\tu64 src_inode_no, u64 dest_inode_no)\n{\n\tint ret = 0, i = 0;\n\tu64 parent_inode_no = 0;\n\tu64 child_inode_no = src_inode_no;\n\tstruct inode *child_inode;\n\n#define MAX_LOOKUP_TIMES 32\n\twhile (1) {\n\t\tchild_inode = ocfs2_iget(osb, child_inode_no, 0, 0);\n\t\tif (IS_ERR(child_inode)) {\n\t\t\tret = PTR_ERR(child_inode);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_inode_lock(child_inode, NULL, 0);\n\t\tif (ret < 0) {\n\t\t\tiput(child_inode);\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_lookup_ino_from_name(child_inode, \"..\", 2,\n\t\t\t\t&parent_inode_no);\n\t\tocfs2_inode_unlock(child_inode, 0);\n\t\tiput(child_inode);\n\t\tif (ret < 0) {\n\t\t\tret = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (parent_inode_no == dest_inode_no) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (parent_inode_no == osb->root_inode->i_ino) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tchild_inode_no = parent_inode_no;\n\n\t\tif (++i >= MAX_LOOKUP_TIMES) {\n\t\t\tmlog_ratelimited(ML_NOTICE, \"max lookup times reached, \"\n\t\t\t\t\t\"filesystem may have nested directories, \"\n\t\t\t\t\t\"src inode: %llu, dest inode: %llu.\\n\",\n\t\t\t\t\t(unsigned long long)src_inode_no,\n\t\t\t\t\t(unsigned long long)dest_inode_no);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_double_lock(struct ocfs2_super *osb,\n\t\t\t     struct buffer_head **bh1,\n\t\t\t     struct inode *inode1,\n\t\t\t     struct buffer_head **bh2,\n\t\t\t     struct inode *inode2,\n\t\t\t     int rename)\n{\n\tint status;\n\tint inode1_is_ancestor, inode2_is_ancestor;\n\tstruct ocfs2_inode_info *oi1 = OCFS2_I(inode1);\n\tstruct ocfs2_inode_info *oi2 = OCFS2_I(inode2);\n\n\ttrace_ocfs2_double_lock((unsigned long long)oi1->ip_blkno,\n\t\t\t\t(unsigned long long)oi2->ip_blkno);\n\n\tif (*bh1)\n\t\t*bh1 = NULL;\n\tif (*bh2)\n\t\t*bh2 = NULL;\n\n\t \n\tif (oi1->ip_blkno != oi2->ip_blkno) {\n\t\tinode1_is_ancestor = ocfs2_check_if_ancestor(osb, oi2->ip_blkno,\n\t\t\t\toi1->ip_blkno);\n\t\tif (inode1_is_ancestor < 0) {\n\t\t\tstatus = inode1_is_ancestor;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tinode2_is_ancestor = ocfs2_check_if_ancestor(osb, oi1->ip_blkno,\n\t\t\t\toi2->ip_blkno);\n\t\tif (inode2_is_ancestor < 0) {\n\t\t\tstatus = inode2_is_ancestor;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif ((inode1_is_ancestor == 1) ||\n\t\t\t\t(oi1->ip_blkno < oi2->ip_blkno &&\n\t\t\t\tinode2_is_ancestor == 0)) {\n\t\t\t \n\t\t\tswap(bh2, bh1);\n\t\t\tswap(inode2, inode1);\n\t\t}\n\t\t \n\t\tstatus = ocfs2_inode_lock_nested(inode2, bh2, 1,\n\t\t\t\trename == 1 ? OI_LS_RENAME1 : OI_LS_PARENT);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOENT)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t \n\tstatus = ocfs2_inode_lock_nested(inode1, bh1, 1,\n\t\t\trename == 1 ?  OI_LS_RENAME2 : OI_LS_PARENT);\n\tif (status < 0) {\n\t\t \n\t\tif (oi1->ip_blkno != oi2->ip_blkno) {\n\t\t\tocfs2_inode_unlock(inode2, 1);\n\t\t\tbrelse(*bh2);\n\t\t\t*bh2 = NULL;\n\t\t}\n\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t}\n\n\ttrace_ocfs2_double_lock_end(\n\t\t\t(unsigned long long)oi1->ip_blkno,\n\t\t\t(unsigned long long)oi2->ip_blkno);\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\nstatic void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2)\n{\n\tocfs2_inode_unlock(inode1, 1);\n\n\tif (inode1 != inode2)\n\t\tocfs2_inode_unlock(inode2, 1);\n}\n\nstatic int ocfs2_rename(struct mnt_idmap *idmap,\n\t\t\tstruct inode *old_dir,\n\t\t\tstruct dentry *old_dentry,\n\t\t\tstruct inode *new_dir,\n\t\t\tstruct dentry *new_dentry,\n\t\t\tunsigned int flags)\n{\n\tint status = 0, rename_lock = 0, parents_locked = 0, target_exists = 0;\n\tint old_child_locked = 0, new_child_locked = 0, update_dot_dot = 0;\n\tstruct inode *old_inode = d_inode(old_dentry);\n\tstruct inode *new_inode = d_inode(new_dentry);\n\tstruct inode *orphan_dir = NULL;\n\tstruct ocfs2_dinode *newfe = NULL;\n\tchar orphan_name[OCFS2_ORPHAN_NAMELEN + 1];\n\tstruct buffer_head *newfe_bh = NULL;\n\tstruct buffer_head *old_inode_bh = NULL;\n\tstruct ocfs2_super *osb = NULL;\n\tu64 newfe_blkno, old_de_ino;\n\thandle_t *handle = NULL;\n\tstruct buffer_head *old_dir_bh = NULL;\n\tstruct buffer_head *new_dir_bh = NULL;\n\tu32 old_dir_nlink = old_dir->i_nlink;\n\tstruct ocfs2_dinode *old_di;\n\tstruct ocfs2_dir_lookup_result old_inode_dot_dot_res = { NULL, };\n\tstruct ocfs2_dir_lookup_result target_lookup_res = { NULL, };\n\tstruct ocfs2_dir_lookup_result old_entry_lookup = { NULL, };\n\tstruct ocfs2_dir_lookup_result orphan_insert = { NULL, };\n\tstruct ocfs2_dir_lookup_result target_insert = { NULL, };\n\tbool should_add_orphan = false;\n\n\tif (flags)\n\t\treturn -EINVAL;\n\n\t \n\n\ttrace_ocfs2_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t   old_dentry->d_name.len, old_dentry->d_name.name,\n\t\t\t   new_dentry->d_name.len, new_dentry->d_name.name);\n\n\tstatus = dquot_initialize(old_dir);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tstatus = dquot_initialize(new_dir);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb = OCFS2_SB(old_dir->i_sb);\n\n\tif (new_inode) {\n\t\tif (!igrab(new_inode))\n\t\t\tBUG();\n\t}\n\n\t \n\tif (old_dir != new_dir && S_ISDIR(old_inode->i_mode)) {\n\t\tstatus = ocfs2_rename_lock(osb);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\trename_lock = 1;\n\n\t\t \n\t\tstatus = ocfs2_check_if_ancestor(osb, new_dir->i_ino,\n\t\t\t\told_inode->i_ino);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t} else if (status == 1) {\n\t\t\tstatus = -EPERM;\n\t\t\ttrace_ocfs2_rename_not_permitted(\n\t\t\t\t\t(unsigned long long)old_inode->i_ino,\n\t\t\t\t\t(unsigned long long)new_dir->i_ino);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t \n\tstatus = ocfs2_double_lock(osb, &old_dir_bh, old_dir,\n\t\t\t\t   &new_dir_bh, new_dir, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tparents_locked = 1;\n\n\tif (!new_dir->i_nlink) {\n\t\tstatus = -EACCES;\n\t\tgoto bail;\n\t}\n\n\t \n\tif (!new_dir_bh) {\n\t\tif (old_dir_bh) {\n\t\t\tnew_dir_bh = old_dir_bh;\n\t\t\tget_bh(new_dir_bh);\n\t\t} else {\n\t\t\tmlog(ML_ERROR, \"no old_dir_bh!\\n\");\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t \n\tstatus = ocfs2_inode_lock_nested(old_inode, &old_inode_bh, 1,\n\t\t\t\t\t OI_LS_PARENT);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\told_child_locked = 1;\n\n\tstatus = ocfs2_remote_dentry_delete(old_dentry);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\tu64 old_inode_parent;\n\n\t\tupdate_dot_dot = 1;\n\t\tstatus = ocfs2_find_files_on_disk(\"..\", 2, &old_inode_parent,\n\t\t\t\t\t\t  old_inode,\n\t\t\t\t\t\t  &old_inode_dot_dot_res);\n\t\tif (status) {\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (old_inode_parent != OCFS2_I(old_dir)->ip_blkno) {\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!new_inode && new_dir != old_dir &&\n\t\t    new_dir->i_nlink >= ocfs2_link_max(osb)) {\n\t\t\tstatus = -EMLINK;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_lookup_ino_from_name(old_dir, old_dentry->d_name.name,\n\t\t\t\t\t    old_dentry->d_name.len,\n\t\t\t\t\t    &old_de_ino);\n\tif (status) {\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\n\t \n\tif (old_de_ino != OCFS2_I(old_inode)->ip_blkno) {\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\n\t \n\tstatus = ocfs2_find_files_on_disk(new_dentry->d_name.name,\n\t\t\t\t\t  new_dentry->d_name.len,\n\t\t\t\t\t  &newfe_blkno, new_dir,\n\t\t\t\t\t  &target_lookup_res);\n\t \n\tif ((status < 0) && (status != -ENOENT)) {\n\t\t \n\t\t \n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (status == 0)\n\t\ttarget_exists = 1;\n\n\tif (!target_exists && new_inode) {\n\t\t \n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\n\t \n\tif (target_exists) {\n\t\t \n\t\tif (!new_inode) {\n\t\t\tstatus = -EACCES;\n\n\t\t\ttrace_ocfs2_rename_target_exists(new_dentry->d_name.len,\n\t\t\t\t\t\tnew_dentry->d_name.name);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (OCFS2_I(new_inode)->ip_blkno != newfe_blkno) {\n\t\t\tstatus = -EACCES;\n\n\t\t\ttrace_ocfs2_rename_disagree(\n\t\t\t     (unsigned long long)OCFS2_I(new_inode)->ip_blkno,\n\t\t\t     (unsigned long long)newfe_blkno,\n\t\t\t     OCFS2_I(new_inode)->ip_flags);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_inode_lock(new_inode, &newfe_bh, 1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOENT)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tnew_child_locked = 1;\n\n\t\tstatus = ocfs2_remote_dentry_delete(new_dentry);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tnewfe = (struct ocfs2_dinode *) newfe_bh->b_data;\n\n\t\ttrace_ocfs2_rename_over_existing(\n\t\t     (unsigned long long)newfe_blkno, newfe_bh, newfe_bh ?\n\t\t     (unsigned long long)newfe_bh->b_blocknr : 0ULL);\n\n\t\tif (S_ISDIR(new_inode->i_mode) || (new_inode->i_nlink == 1)) {\n\t\t\tstatus = ocfs2_prepare_orphan_dir(osb, &orphan_dir,\n\t\t\t\t\t\tOCFS2_I(new_inode)->ip_blkno,\n\t\t\t\t\t\torphan_name, &orphan_insert,\n\t\t\t\t\t\tfalse);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tshould_add_orphan = true;\n\t\t}\n\t} else {\n\t\tBUG_ON(d_inode(new_dentry->d_parent) != new_dir);\n\n\t\tstatus = ocfs2_check_dir_for_entry(new_dir,\n\t\t\t\t\t\t   new_dentry->d_name.name,\n\t\t\t\t\t\t   new_dentry->d_name.len);\n\t\tif (status)\n\t\t\tgoto bail;\n\n\t\tstatus = ocfs2_prepare_dir_for_insert(osb, new_dir, new_dir_bh,\n\t\t\t\t\t\t      new_dentry->d_name.name,\n\t\t\t\t\t\t      new_dentry->d_name.len,\n\t\t\t\t\t\t      &target_insert);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_rename_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (target_exists) {\n\t\tif (S_ISDIR(new_inode->i_mode)) {\n\t\t\tif (new_inode->i_nlink != 2 ||\n\t\t\t    !ocfs2_empty_dir(new_inode)) {\n\t\t\t\tstatus = -ENOTEMPTY;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(new_inode),\n\t\t\t\t\t\t newfe_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t \n\t\tstatus = ocfs2_update_entry(new_dir, handle, &target_lookup_res,\n\t\t\t\t\t    old_inode);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tinode_inc_iversion(new_dir);\n\n\t\tif (S_ISDIR(new_inode->i_mode))\n\t\t\tocfs2_set_links_count(newfe, 0);\n\t\telse\n\t\t\tocfs2_add_links_count(newfe, -1);\n\t\tocfs2_journal_dirty(handle, newfe_bh);\n\t\tif (should_add_orphan) {\n\t\t\tstatus = ocfs2_orphan_add(osb, handle, new_inode,\n\t\t\t\t\tnewfe_bh, orphan_name,\n\t\t\t\t\t&orphan_insert, orphan_dir, false);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tstatus = ocfs2_add_entry(handle, new_dentry, old_inode,\n\t\t\t\t\t OCFS2_I(old_inode)->ip_blkno,\n\t\t\t\t\t new_dir_bh, &target_insert);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tinode_set_ctime_current(old_inode);\n\tmark_inode_dirty(old_inode);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(old_inode),\n\t\t\t\t\t old_inode_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status >= 0) {\n\t\told_di = (struct ocfs2_dinode *) old_inode_bh->b_data;\n\n\t\told_di->i_ctime = cpu_to_le64(inode_get_ctime(old_inode).tv_sec);\n\t\told_di->i_ctime_nsec = cpu_to_le32(inode_get_ctime(old_inode).tv_nsec);\n\t\tocfs2_journal_dirty(handle, old_inode_bh);\n\t} else\n\t\tmlog_errno(status);\n\n\t \n\tstatus = ocfs2_find_entry(old_dentry->d_name.name,\n\t\t\t\t  old_dentry->d_name.len, old_dir,\n\t\t\t\t  &old_entry_lookup);\n\tif (status) {\n\t\tif (!is_journal_aborted(osb->journal->j_journal)) {\n\t\t\tocfs2_error(osb->sb, \"new entry %.*s is added, but old entry %.*s \"\n\t\t\t\t\t\"is not deleted.\",\n\t\t\t\t\tnew_dentry->d_name.len, new_dentry->d_name.name,\n\t\t\t\t\told_dentry->d_name.len, old_dentry->d_name.name);\n\t\t}\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_delete_entry(handle, old_dir, &old_entry_lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tif (!is_journal_aborted(osb->journal->j_journal)) {\n\t\t\tocfs2_error(osb->sb, \"new entry %.*s is added, but old entry %.*s \"\n\t\t\t\t\t\"is not deleted.\",\n\t\t\t\t\tnew_dentry->d_name.len, new_dentry->d_name.name,\n\t\t\t\t\told_dentry->d_name.len, old_dentry->d_name.name);\n\t\t}\n\t\tgoto bail;\n\t}\n\n\tif (new_inode) {\n\t\tdrop_nlink(new_inode);\n\t\tinode_set_ctime_current(new_inode);\n\t}\n\told_dir->i_mtime = inode_set_ctime_current(old_dir);\n\n\tif (update_dot_dot) {\n\t\tstatus = ocfs2_update_entry(old_inode, handle,\n\t\t\t\t\t    &old_inode_dot_dot_res, new_dir);\n\t\tdrop_nlink(old_dir);\n\t\tif (new_inode) {\n\t\t\tdrop_nlink(new_inode);\n\t\t} else {\n\t\t\tinc_nlink(new_dir);\n\t\t\tmark_inode_dirty(new_dir);\n\t\t}\n\t}\n\tmark_inode_dirty(old_dir);\n\tocfs2_mark_inode_dirty(handle, old_dir, old_dir_bh);\n\tif (new_inode) {\n\t\tmark_inode_dirty(new_inode);\n\t\tocfs2_mark_inode_dirty(handle, new_inode, newfe_bh);\n\t}\n\n\tif (old_dir != new_dir) {\n\t\t \n\t\tnew_dir->i_mtime = inode_set_ctime_to_ts(new_dir,\n\t\t\t\t\t\t\t inode_get_ctime(old_dir));\n\n\t\t \n\t\tocfs2_mark_inode_dirty(handle, new_dir, new_dir_bh);\n\t}\n\n\tif (old_dir_nlink != old_dir->i_nlink) {\n\t\tif (!old_dir_bh) {\n\t\t\tmlog(ML_ERROR, \"need to change nlink for old dir \"\n\t\t\t     \"%llu from %d to %d but bh is NULL!\\n\",\n\t\t\t     (unsigned long long)OCFS2_I(old_dir)->ip_blkno,\n\t\t\t     (int)old_dir_nlink, old_dir->i_nlink);\n\t\t} else {\n\t\t\tstruct ocfs2_dinode *fe;\n\t\t\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t\t\t INODE_CACHE(old_dir),\n\t\t\t\t\t\t\t old_dir_bh,\n\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tfe = (struct ocfs2_dinode *) old_dir_bh->b_data;\n\t\t\tocfs2_set_links_count(fe, old_dir->i_nlink);\n\t\t\tocfs2_journal_dirty(handle, old_dir_bh);\n\t\t}\n\t}\n\tocfs2_dentry_move(old_dentry, new_dentry, old_dir, new_dir);\n\tstatus = 0;\nbail:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tif (orphan_dir) {\n\t\t \n\t\tocfs2_inode_unlock(orphan_dir, 1);\n\t\tinode_unlock(orphan_dir);\n\t\tiput(orphan_dir);\n\t}\n\n\tif (new_child_locked)\n\t\tocfs2_inode_unlock(new_inode, 1);\n\n\tif (old_child_locked)\n\t\tocfs2_inode_unlock(old_inode, 1);\n\n\tif (parents_locked)\n\t\tocfs2_double_unlock(old_dir, new_dir);\n\n\tif (rename_lock)\n\t\tocfs2_rename_unlock(osb);\n\n\tif (new_inode)\n\t\tsync_mapping_buffers(old_inode->i_mapping);\n\n\tiput(new_inode);\n\n\tocfs2_free_dir_lookup_result(&target_lookup_res);\n\tocfs2_free_dir_lookup_result(&old_entry_lookup);\n\tocfs2_free_dir_lookup_result(&old_inode_dot_dot_res);\n\tocfs2_free_dir_lookup_result(&orphan_insert);\n\tocfs2_free_dir_lookup_result(&target_insert);\n\n\tbrelse(newfe_bh);\n\tbrelse(old_inode_bh);\n\tbrelse(old_dir_bh);\n\tbrelse(new_dir_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}\n\n \nstatic int ocfs2_create_symlink_data(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     const char *symname)\n{\n\tstruct buffer_head **bhs = NULL;\n\tconst char *c;\n\tstruct super_block *sb = osb->sb;\n\tu64 p_blkno, p_blocks;\n\tint virtual, blocks, status, i, bytes_left;\n\n\tbytes_left = i_size_read(inode) + 1;\n\t \n\tblocks = (bytes_left + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\n\ttrace_ocfs2_create_symlink_data((unsigned long long)inode->i_blocks,\n\t\t\t\t\ti_size_read(inode), blocks);\n\n\t \n\tif (bytes_left >\n\t    ocfs2_clusters_to_bytes(sb, OCFS2_I(inode)->ip_clusters)) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tbhs = kcalloc(blocks, sizeof(struct buffer_head *), GFP_KERNEL);\n\tif (!bhs) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_extent_map_get_blocks(inode, 0, &p_blkno, &p_blocks,\n\t\t\t\t\t     NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t \n\tif ((p_blocks << sb->s_blocksize_bits) < bytes_left) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tvirtual = 0;\n\twhile(bytes_left > 0) {\n\t\tc = &symname[virtual * sb->s_blocksize];\n\n\t\tbhs[virtual] = sb_getblk(sb, p_blkno);\n\t\tif (!bhs[virtual]) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode),\n\t\t\t\t\t      bhs[virtual]);\n\n\t\tstatus = ocfs2_journal_access(handle, INODE_CACHE(inode),\n\t\t\t\t\t      bhs[virtual],\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmemset(bhs[virtual]->b_data, 0, sb->s_blocksize);\n\n\t\tmemcpy(bhs[virtual]->b_data, c,\n\t\t       (bytes_left > sb->s_blocksize) ? sb->s_blocksize :\n\t\t       bytes_left);\n\n\t\tocfs2_journal_dirty(handle, bhs[virtual]);\n\n\t\tvirtual++;\n\t\tp_blkno++;\n\t\tbytes_left -= sb->s_blocksize;\n\t}\n\n\tstatus = 0;\nbail:\n\n\tif (bhs) {\n\t\tfor(i = 0; i < blocks; i++)\n\t\t\tbrelse(bhs[i]);\n\t\tkfree(bhs);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\nstatic int ocfs2_symlink(struct mnt_idmap *idmap,\n\t\t\t struct inode *dir,\n\t\t\t struct dentry *dentry,\n\t\t\t const char *symname)\n{\n\tint status, l, credits;\n\tu64 newsize;\n\tstruct ocfs2_super *osb = NULL;\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb;\n\tstruct buffer_head *new_fe_bh = NULL;\n\tstruct buffer_head *parent_fe_bh = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_dinode *dirfe;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *xattr_ac = NULL;\n\tint want_clusters = 0;\n\tint xattr_credits = 0;\n\tstruct ocfs2_security_xattr_info si = {\n\t\t.name = NULL,\n\t\t.enable = 1,\n\t};\n\tint did_quota = 0, did_quota_inode = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\tsigset_t oldset;\n\tint did_block_signals = 0;\n\tstruct ocfs2_dentry_lock *dl = NULL;\n\n\ttrace_ocfs2_symlink_begin(dir, dentry, symname,\n\t\t\t\t  dentry->d_name.len, dentry->d_name.name);\n\n\tstatus = dquot_initialize(dir);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tsb = dir->i_sb;\n\tosb = OCFS2_SB(sb);\n\n\tl = strlen(symname) + 1;\n\n\tcredits = ocfs2_calc_symlink_credits(sb);\n\n\t \n\tstatus = ocfs2_inode_lock(dir, &parent_fe_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tdirfe = (struct ocfs2_dinode *) parent_fe_bh->b_data;\n\tif (!ocfs2_read_links_count(dirfe)) {\n\t\t \n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_check_dir_for_entry(dir, dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = ocfs2_prepare_dir_for_insert(osb, dir, parent_fe_bh,\n\t\t\t\t\t      dentry->d_name.name,\n\t\t\t\t\t      dentry->d_name.len, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_reserve_new_inode(osb, &inode_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_get_init_inode(dir, S_IFLNK | S_IRWXUGO);\n\tif (IS_ERR(inode)) {\n\t\tstatus = PTR_ERR(inode);\n\t\tinode = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t \n\tstatus = ocfs2_init_security_get(inode, dir, &dentry->d_name, &si);\n\tif (status) {\n\t\tif (status == -EOPNOTSUPP)\n\t\t\tsi.enable = 0;\n\t\telse {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t \n\tif (si.enable) {\n\t\tstatus = ocfs2_calc_security_init(dir, &si, &want_clusters,\n\t\t\t\t\t\t  &xattr_credits, &xattr_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t \n\tif (l > ocfs2_fast_symlink_chars(sb))\n\t\twant_clusters += 1;\n\n\tstatus = ocfs2_reserve_clusters(osb, want_clusters, &data_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits + xattr_credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t \n\tocfs2_block_signals(&oldset);\n\tdid_block_signals = 1;\n\n\tstatus = dquot_alloc_inode(inode);\n\tif (status)\n\t\tgoto bail;\n\tdid_quota_inode = 1;\n\n\ttrace_ocfs2_symlink_create(dir, dentry, dentry->d_name.len,\n\t\t\t\t   dentry->d_name.name,\n\t\t\t\t   (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t   inode->i_mode);\n\n\tstatus = ocfs2_mknod_locked(osb, dir, inode,\n\t\t\t\t    0, &new_fe_bh, parent_fe_bh, handle,\n\t\t\t\t    inode_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tfe = (struct ocfs2_dinode *) new_fe_bh->b_data;\n\tinode->i_rdev = 0;\n\tnewsize = l - 1;\n\tinode->i_op = &ocfs2_symlink_inode_operations;\n\tinode_nohighmem(inode);\n\tif (l > ocfs2_fast_symlink_chars(sb)) {\n\t\tu32 offset = 0;\n\n\t\tstatus = dquot_alloc_space_nodirty(inode,\n\t\t    ocfs2_clusters_to_bytes(osb->sb, 1));\n\t\tif (status)\n\t\t\tgoto bail;\n\t\tdid_quota = 1;\n\t\tinode->i_mapping->a_ops = &ocfs2_aops;\n\t\tstatus = ocfs2_add_inode_data(osb, inode, &offset, 1, 0,\n\t\t\t\t\t      new_fe_bh,\n\t\t\t\t\t      handle, data_ac, NULL,\n\t\t\t\t\t      NULL);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC && status != -EINTR) {\n\t\t\t\tmlog(ML_ERROR,\n\t\t\t\t     \"Failed to extend file to %llu\\n\",\n\t\t\t\t     (unsigned long long)newsize);\n\t\t\t\tmlog_errno(status);\n\t\t\t\tstatus = -ENOSPC;\n\t\t\t}\n\t\t\tgoto bail;\n\t\t}\n\t\ti_size_write(inode, newsize);\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t} else {\n\t\tinode->i_mapping->a_ops = &ocfs2_fast_symlink_aops;\n\t\tmemcpy((char *) fe->id2.i_symlink, symname, l);\n\t\ti_size_write(inode, newsize);\n\t\tinode->i_blocks = 0;\n\t}\n\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, new_fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (!ocfs2_inode_is_fast_symlink(inode)) {\n\t\tstatus = ocfs2_create_symlink_data(osb, handle, inode,\n\t\t\t\t\t\t   symname);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (si.enable) {\n\t\tstatus = ocfs2_init_security_set(handle, inode, new_fe_bh, &si,\n\t\t\t\t\t\t xattr_ac, data_ac);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t \n\tstatus = ocfs2_dentry_attach_lock(dentry, inode, OCFS2_I(dir)->ip_blkno);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdl = dentry->d_fsdata;\n\n\tstatus = ocfs2_add_entry(handle, dentry, inode,\n\t\t\t\t le64_to_cpu(fe->i_blkno), parent_fe_bh,\n\t\t\t\t &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\nbail:\n\tif (status < 0 && did_quota)\n\t\tdquot_free_space_nodirty(inode,\n\t\t\t\t\tocfs2_clusters_to_bytes(osb->sb, 1));\n\tif (status < 0 && did_quota_inode)\n\t\tdquot_free_inode(inode);\n\tif (handle) {\n\t\tif (status < 0 && fe)\n\t\t\tocfs2_set_links_count(fe, 0);\n\t\tocfs2_commit_trans(osb, handle);\n\t}\n\n\tocfs2_inode_unlock(dir, 1);\n\tif (did_block_signals)\n\t\tocfs2_unblock_signals(&oldset);\n\n\tbrelse(new_fe_bh);\n\tbrelse(parent_fe_bh);\n\tkfree(si.value);\n\tocfs2_free_dir_lookup_result(&lookup);\n\tif (inode_ac)\n\t\tocfs2_free_alloc_context(inode_ac);\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (xattr_ac)\n\t\tocfs2_free_alloc_context(xattr_ac);\n\tif ((status < 0) && inode) {\n\t\tif (dl)\n\t\t\tocfs2_cleanup_add_entry_failure(osb, dentry, inode);\n\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_SKIP_ORPHAN_DIR;\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}\n\nstatic int ocfs2_blkno_stringify(u64 blkno, char *name)\n{\n\tint status, namelen;\n\n\tnamelen = snprintf(name, OCFS2_ORPHAN_NAMELEN + 1, \"%016llx\",\n\t\t\t   (long long)blkno);\n\tif (namelen <= 0) {\n\t\tif (namelen)\n\t\t\tstatus = namelen;\n\t\telse\n\t\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (namelen != OCFS2_ORPHAN_NAMELEN) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_blkno_stringify(blkno, name, namelen);\n\n\tstatus = 0;\nbail:\n\tif (status < 0)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\nstatic int ocfs2_lookup_lock_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t\tstruct inode **ret_orphan_dir,\n\t\t\t\t\tstruct buffer_head **ret_orphan_dir_bh)\n{\n\tstruct inode *orphan_dir_inode;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint ret = 0;\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t       osb->slot_num);\n\tif (!orphan_dir_inode) {\n\t\tret = -ENOENT;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tinode_lock(orphan_dir_inode);\n\n\tret = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\tif (ret < 0) {\n\t\tinode_unlock(orphan_dir_inode);\n\t\tiput(orphan_dir_inode);\n\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t*ret_orphan_dir = orphan_dir_inode;\n\t*ret_orphan_dir_bh = orphan_dir_bh;\n\n\treturn 0;\n}\n\nstatic int __ocfs2_prepare_orphan_dir(struct inode *orphan_dir_inode,\n\t\t\t\t      struct buffer_head *orphan_dir_bh,\n\t\t\t\t      u64 blkno,\n\t\t\t\t      char *name,\n\t\t\t\t      struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t      bool dio)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(orphan_dir_inode->i_sb);\n\tint namelen = dio ?\n\t\t\t(OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN) :\n\t\t\tOCFS2_ORPHAN_NAMELEN;\n\n\tif (dio) {\n\t\tret = snprintf(name, OCFS2_DIO_ORPHAN_PREFIX_LEN + 1, \"%s\",\n\t\t\t\tOCFS2_DIO_ORPHAN_PREFIX);\n\t\tif (ret != OCFS2_DIO_ORPHAN_PREFIX_LEN) {\n\t\t\tret = -EINVAL;\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_blkno_stringify(blkno,\n\t\t\t\tname + OCFS2_DIO_ORPHAN_PREFIX_LEN);\n\t} else\n\t\tret = ocfs2_blkno_stringify(blkno, name);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = ocfs2_prepare_dir_for_insert(osb, orphan_dir_inode,\n\t\t\t\t\t   orphan_dir_bh, name,\n\t\t\t\t\t   namelen, lookup);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ocfs2_prepare_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t    struct inode **ret_orphan_dir,\n\t\t\t\t    u64 blkno,\n\t\t\t\t    char *name,\n\t\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t    bool dio)\n{\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint ret = 0;\n\n\tret = ocfs2_lookup_lock_orphan_dir(osb, &orphan_dir_inode,\n\t\t\t\t\t   &orphan_dir_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = __ocfs2_prepare_orphan_dir(orphan_dir_inode, orphan_dir_bh,\n\t\t\t\t\t blkno, name, lookup, dio);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_orphan_dir = orphan_dir_inode;\n\nout:\n\tbrelse(orphan_dir_bh);\n\n\tif (ret) {\n\t\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\t\tinode_unlock(orphan_dir_inode);\n\t\tiput(orphan_dir_inode);\n\t}\n\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}\n\nstatic int ocfs2_orphan_add(struct ocfs2_super *osb,\n\t\t\t    handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *fe_bh,\n\t\t\t    char *name,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct inode *orphan_dir_inode,\n\t\t\t    bool dio)\n{\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tint status = 0;\n\tstruct ocfs2_dinode *orphan_fe;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) fe_bh->b_data;\n\tint namelen = dio ?\n\t\t\t(OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN) :\n\t\t\tOCFS2_ORPHAN_NAMELEN;\n\n\ttrace_ocfs2_orphan_add_begin(\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_read_inode_block(orphan_dir_inode, &orphan_dir_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t \n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(inode),\n\t\t\t\t\t fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t \n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, 1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\n\tstatus = __ocfs2_add_entry(handle, orphan_dir_inode, name,\n\t\t\t\t   namelen, inode,\n\t\t\t\t   OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   orphan_dir_bh, lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto rollback;\n\t}\n\n\tif (dio) {\n\t\t \n\t\tfe->i_flags |= cpu_to_le32(OCFS2_DIO_ORPHANED_FL);\n\t\tfe->i_dio_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t} else {\n\t\tfe->i_flags |= cpu_to_le32(OCFS2_ORPHANED_FL);\n\t\tOCFS2_I(inode)->ip_flags &= ~OCFS2_INODE_SKIP_ORPHAN_DIR;\n\n\t\t \n\t\tfe->i_orphaned_slot = cpu_to_le16(osb->slot_num);\n\t}\n\n\tocfs2_journal_dirty(handle, fe_bh);\n\n\ttrace_ocfs2_orphan_add_end((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   osb->slot_num);\n\nrollback:\n\tif (status < 0) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tocfs2_add_links_count(orphan_fe, -1);\n\t\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\t}\n\nleave:\n\tbrelse(orphan_dir_bh);\n\n\treturn status;\n}\n\n \nint ocfs2_orphan_del(struct ocfs2_super *osb,\n\t\t     handle_t *handle,\n\t\t     struct inode *orphan_dir_inode,\n\t\t     struct inode *inode,\n\t\t     struct buffer_head *orphan_dir_bh,\n\t\t     bool dio)\n{\n\tchar name[OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN + 1];\n\tstruct ocfs2_dinode *orphan_fe;\n\tint status = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tif (dio) {\n\t\tstatus = snprintf(name, OCFS2_DIO_ORPHAN_PREFIX_LEN + 1, \"%s\",\n\t\t\t\tOCFS2_DIO_ORPHAN_PREFIX);\n\t\tif (status != OCFS2_DIO_ORPHAN_PREFIX_LEN) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\n\t\tstatus = ocfs2_blkno_stringify(OCFS2_I(inode)->ip_blkno,\n\t\t\t\tname + OCFS2_DIO_ORPHAN_PREFIX_LEN);\n\t} else\n\t\tstatus = ocfs2_blkno_stringify(OCFS2_I(inode)->ip_blkno, name);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\ttrace_ocfs2_orphan_del(\n\t     (unsigned long long)OCFS2_I(orphan_dir_inode)->ip_blkno,\n\t     name, strlen(name));\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(orphan_dir_inode),\n\t\t\t\t\t orphan_dir_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t \n\tstatus = ocfs2_find_entry(name, strlen(name), orphan_dir_inode,\n\t\t\t\t  &lookup);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t \n\tstatus = ocfs2_delete_entry(handle, orphan_dir_inode, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t \n\torphan_fe = (struct ocfs2_dinode *) orphan_dir_bh->b_data;\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_add_links_count(orphan_fe, -1);\n\tset_nlink(orphan_dir_inode, ocfs2_read_links_count(orphan_fe));\n\tocfs2_journal_dirty(handle, orphan_dir_bh);\n\nleave:\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\n \nstatic int ocfs2_prep_new_orphaned_file(struct inode *dir,\n\t\t\t\t\tstruct buffer_head *dir_bh,\n\t\t\t\t\tchar *orphan_name,\n\t\t\t\t\tstruct inode **ret_orphan_dir,\n\t\t\t\t\tu64 *ret_di_blkno,\n\t\t\t\t\tstruct ocfs2_dir_lookup_result *orphan_insert,\n\t\t\t\t\tstruct ocfs2_alloc_context **ret_inode_ac)\n{\n\tint ret;\n\tu64 di_blkno;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct inode *orphan_dir = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\n\tret = ocfs2_lookup_lock_orphan_dir(osb, &orphan_dir, &orphan_dir_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = ocfs2_reserve_new_inode(osb, &inode_ac);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_new_inode_loc(dir, dir_bh, inode_ac,\n\t\t\t\t       &di_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_prepare_orphan_dir(orphan_dir, orphan_dir_bh,\n\t\t\t\t\t di_blkno, orphan_name, orphan_insert,\n\t\t\t\t\t false);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (ret == 0) {\n\t\t*ret_orphan_dir = orphan_dir;\n\t\t*ret_di_blkno = di_blkno;\n\t\t*ret_inode_ac = inode_ac;\n\t\t \n\t} else {\n\t\t \n\t\tif (inode_ac)\n\t\t\tocfs2_free_alloc_context(inode_ac);\n\n\t\t \n\t\tinode_unlock(orphan_dir);\n\t\tocfs2_inode_unlock(orphan_dir, 1);\n\t\tiput(orphan_dir);\n\t}\n\n\tbrelse(orphan_dir_bh);\n\n\treturn ret;\n}\n\nint ocfs2_create_inode_in_orphan(struct inode *dir,\n\t\t\t\t int mode,\n\t\t\t\t struct inode **new_inode)\n{\n\tint status, did_quota_inode = 0;\n\tstruct inode *inode = NULL;\n\tstruct inode *orphan_dir = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\thandle_t *handle = NULL;\n\tchar orphan_name[OCFS2_ORPHAN_NAMELEN + 1];\n\tstruct buffer_head *parent_di_bh = NULL;\n\tstruct buffer_head *new_di_bh = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\tstruct ocfs2_dir_lookup_result orphan_insert = { NULL, };\n\tu64 di_blkno, suballoc_loc;\n\tu16 suballoc_bit;\n\n\tstatus = ocfs2_inode_lock(dir, &parent_di_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tstatus = ocfs2_prep_new_orphaned_file(dir, parent_di_bh,\n\t\t\t\t\t      orphan_name, &orphan_dir,\n\t\t\t\t\t      &di_blkno, &orphan_insert, &inode_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinode = ocfs2_get_init_inode(dir, mode);\n\tif (IS_ERR(inode)) {\n\t\tstatus = PTR_ERR(inode);\n\t\tinode = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_mknod_credits(osb->sb, 0, 0));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = dquot_alloc_inode(inode);\n\tif (status)\n\t\tgoto leave;\n\tdid_quota_inode = 1;\n\n\tstatus = ocfs2_claim_new_inode_at_loc(handle, dir, inode_ac,\n\t\t\t\t\t      &suballoc_loc,\n\t\t\t\t\t      &suballoc_bit, di_blkno);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tclear_nlink(inode);\n\t \n\tstatus = __ocfs2_mknod_locked(dir, inode,\n\t\t\t\t      0, &new_di_bh, parent_di_bh, handle,\n\t\t\t\t      inode_ac, di_blkno, suballoc_loc,\n\t\t\t\t      suballoc_bit);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_orphan_add(osb, handle, inode, new_di_bh, orphan_name,\n\t\t\t\t  &orphan_insert, orphan_dir, false);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t \n\tstatus = ocfs2_open_lock(inode);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tinsert_inode_hash(inode);\nleave:\n\tif (status < 0 && did_quota_inode)\n\t\tdquot_free_inode(inode);\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tif (orphan_dir) {\n\t\t \n\t\tocfs2_inode_unlock(orphan_dir, 1);\n\t\tinode_unlock(orphan_dir);\n\t\tiput(orphan_dir);\n\t}\n\n\tif ((status < 0) && inode) {\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t}\n\n\tif (inode_ac)\n\t\tocfs2_free_alloc_context(inode_ac);\n\n\tbrelse(new_di_bh);\n\n\tif (!status)\n\t\t*new_inode = inode;\n\n\tocfs2_free_dir_lookup_result(&orphan_insert);\n\n\tocfs2_inode_unlock(dir, 1);\n\tbrelse(parent_di_bh);\n\treturn status;\n}\n\nint ocfs2_add_inode_to_orphan(struct ocfs2_super *osb,\n\tstruct inode *inode)\n{\n\tchar orphan_name[OCFS2_DIO_ORPHAN_PREFIX_LEN + OCFS2_ORPHAN_NAMELEN + 1];\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct ocfs2_dir_lookup_result orphan_insert = { NULL, };\n\tstruct buffer_head *di_bh = NULL;\n\tint status = 0;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\n\tstatus = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\t \n\tif (unlikely(di->i_flags & cpu_to_le32(OCFS2_DIO_ORPHANED_FL))) {\n\t\tstatus = ocfs2_truncate_file(inode, di_bh, i_size_read(inode));\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail_unlock_inode;\n\t\t}\n\n\t\tstatus = ocfs2_del_inode_from_orphan(osb, inode, di_bh, 0, 0);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_unlock_inode;\n\t\t}\n\t}\n\n\tstatus = ocfs2_prepare_orphan_dir(osb, &orphan_dir_inode,\n\t\t\tOCFS2_I(inode)->ip_blkno,\n\t\t\torphan_name,\n\t\t\t&orphan_insert,\n\t\t\ttrue);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tOCFS2_INODE_ADD_TO_ORPHAN_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tgoto bail_unlock_orphan;\n\t}\n\n\tstatus = ocfs2_orphan_add(osb, handle, inode, di_bh, orphan_name,\n\t\t\t&orphan_insert, orphan_dir_inode, true);\n\tif (status)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nbail_unlock_orphan:\n\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\tinode_unlock(orphan_dir_inode);\n\tiput(orphan_dir_inode);\n\n\tocfs2_free_dir_lookup_result(&orphan_insert);\n\nbail_unlock_inode:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\n\nbail:\n\treturn status;\n}\n\nint ocfs2_del_inode_from_orphan(struct ocfs2_super *osb,\n\t\tstruct inode *inode, struct buffer_head *di_bh,\n\t\tint update_isize, loff_t end)\n{\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\thandle_t *handle = NULL;\n\tint status = 0;\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\tORPHAN_DIR_SYSTEM_INODE,\n\t\t\tle16_to_cpu(di->i_dio_orphaned_slot));\n\tif (!orphan_dir_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinode_lock(orphan_dir_inode);\n\tstatus = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\tif (status < 0) {\n\t\tinode_unlock(orphan_dir_inode);\n\t\tiput(orphan_dir_inode);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tOCFS2_INODE_DEL_FROM_ORPHAN_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tgoto bail_unlock_orphan;\n\t}\n\n\tBUG_ON(!(di->i_flags & cpu_to_le32(OCFS2_DIO_ORPHANED_FL)));\n\n\tstatus = ocfs2_orphan_del(osb, handle, orphan_dir_inode,\n\t\t\t\tinode, orphan_dir_bh, true);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_commit;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\tINODE_CACHE(inode),\n\t\t\tdi_bh,\n\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_commit;\n\t}\n\n\tdi->i_flags &= ~cpu_to_le32(OCFS2_DIO_ORPHANED_FL);\n\tdi->i_dio_orphaned_slot = 0;\n\n\tif (update_isize) {\n\t\tstatus = ocfs2_set_inode_size(handle, inode, di_bh, end);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\t} else\n\t\tocfs2_journal_dirty(handle, di_bh);\n\nbail_commit:\n\tocfs2_commit_trans(osb, handle);\n\nbail_unlock_orphan:\n\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\tinode_unlock(orphan_dir_inode);\n\tbrelse(orphan_dir_bh);\n\tiput(orphan_dir_inode);\n\nbail:\n\treturn status;\n}\n\nint ocfs2_mv_orphaned_inode_to_new(struct inode *dir,\n\t\t\t\t   struct inode *inode,\n\t\t\t\t   struct dentry *dentry)\n{\n\tint status = 0;\n\tstruct buffer_head *parent_di_bh = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *dir_di, *di;\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\ttrace_ocfs2_mv_orphaned_inode_to_new(dir, dentry,\n\t\t\t\tdentry->d_name.len, dentry->d_name.name,\n\t\t\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_inode_lock(dir, &parent_di_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tdir_di = (struct ocfs2_dinode *) parent_di_bh->b_data;\n\tif (!dir_di->i_links_count) {\n\t\t \n\t\tstatus = -ENOENT;\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_check_dir_for_entry(dir, dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len);\n\tif (status)\n\t\tgoto leave;\n\n\t \n\tstatus = ocfs2_prepare_dir_for_insert(osb, dir, parent_di_bh,\n\t\t\t\t\t      dentry->d_name.name,\n\t\t\t\t\t      dentry->d_name.len, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t       osb->slot_num);\n\tif (!orphan_dir_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinode_lock(orphan_dir_inode);\n\n\tstatus = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tinode_unlock(orphan_dir_inode);\n\t\tiput(orphan_dir_inode);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto orphan_unlock;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_rename_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto orphan_unlock;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t\t di_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tstatus = ocfs2_orphan_del(osb, handle, orphan_dir_inode, inode,\n\t\t\t\t  orphan_dir_bh, false);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdi->i_flags &= ~cpu_to_le32(OCFS2_ORPHANED_FL);\n\tdi->i_orphaned_slot = 0;\n\tset_nlink(inode, 1);\n\tocfs2_set_links_count(di, inode->i_nlink);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tstatus = ocfs2_add_entry(handle, dentry, inode,\n\t\t\t\t OCFS2_I(inode)->ip_blkno, parent_di_bh,\n\t\t\t\t &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tstatus = ocfs2_dentry_attach_lock(dentry, inode,\n\t\t\t\t\t  OCFS2_I(dir)->ip_blkno);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\td_instantiate(dentry, inode);\n\tstatus = 0;\nout_commit:\n\tocfs2_commit_trans(osb, handle);\norphan_unlock:\n\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\tinode_unlock(orphan_dir_inode);\n\tiput(orphan_dir_inode);\nleave:\n\n\tocfs2_inode_unlock(dir, 1);\n\n\tbrelse(di_bh);\n\tbrelse(parent_di_bh);\n\tbrelse(orphan_dir_bh);\n\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}\n\nconst struct inode_operations ocfs2_dir_iops = {\n\t.create\t\t= ocfs2_create,\n\t.lookup\t\t= ocfs2_lookup,\n\t.link\t\t= ocfs2_link,\n\t.unlink\t\t= ocfs2_unlink,\n\t.rmdir\t\t= ocfs2_unlink,\n\t.symlink\t= ocfs2_symlink,\n\t.mkdir\t\t= ocfs2_mkdir,\n\t.mknod\t\t= ocfs2_mknod,\n\t.rename\t\t= ocfs2_rename,\n\t.setattr\t= ocfs2_setattr,\n\t.getattr\t= ocfs2_getattr,\n\t.permission\t= ocfs2_permission,\n\t.listxattr\t= ocfs2_listxattr,\n\t.fiemap         = ocfs2_fiemap,\n\t.get_inode_acl\t= ocfs2_iop_get_acl,\n\t.set_acl\t= ocfs2_iop_set_acl,\n\t.fileattr_get\t= ocfs2_fileattr_get,\n\t.fileattr_set\t= ocfs2_fileattr_set,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}