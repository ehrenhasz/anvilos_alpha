{
  "module_name": "super.c",
  "hash_id": "d9aad58a0483bd06dd9ba5b0fc5f0becd960d6c3ebbab1ae2c1e609c8d7fc519",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/super.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/moduleparam.h>\n#include <linux/blkdev.h>\n#include <linux/socket.h>\n#include <linux/inet.h>\n#include <linux/parser.h>\n#include <linux/crc32.h>\n#include <linux/debugfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/signal.h>\n\n#define CREATE_TRACE_POINTS\n#include \"ocfs2_trace.h\"\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n \n#include \"ocfs1_fs_compat.h\"\n\n#include \"alloc.h\"\n#include \"aops.h\"\n#include \"blockcheck.h\"\n#include \"dlmglue.h\"\n#include \"export.h\"\n#include \"extent_map.h\"\n#include \"heartbeat.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"localalloc.h\"\n#include \"namei.h\"\n#include \"slot_map.h\"\n#include \"super.h\"\n#include \"sysfile.h\"\n#include \"uptodate.h\"\n#include \"xattr.h\"\n#include \"quota.h\"\n#include \"refcounttree.h\"\n#include \"suballoc.h\"\n\n#include \"buffer_head_io.h\"\n#include \"filecheck.h\"\n\nstatic struct kmem_cache *ocfs2_inode_cachep;\nstruct kmem_cache *ocfs2_dquot_cachep;\nstruct kmem_cache *ocfs2_qf_chunk_cachep;\n\nstatic struct dentry *ocfs2_debugfs_root;\n\nMODULE_AUTHOR(\"Oracle\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"OCFS2 cluster file system\");\n\nstruct mount_options\n{\n\tunsigned long\tcommit_interval;\n\tunsigned long\tmount_opt;\n\tunsigned int\tatime_quantum;\n\tunsigned short\tslot;\n\tint\t\tlocalalloc_opt;\n\tunsigned int\tresv_level;\n\tint\t\tdir_resv_level;\n\tchar\t\tcluster_stack[OCFS2_STACK_LABEL_LEN + 1];\n};\n\nstatic int ocfs2_parse_options(struct super_block *sb, char *options,\n\t\t\t       struct mount_options *mopt,\n\t\t\t       int is_remount);\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic int ocfs2_show_options(struct seq_file *s, struct dentry *root);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\nstatic void ocfs2_dismount_volume(struct super_block *sb, int mnt_err);\nstatic int ocfs2_initialize_mem_caches(void);\nstatic void ocfs2_free_mem_caches(void);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\n\nstatic int ocfs2_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic int ocfs2_sync_fs(struct super_block *sb, int wait);\n\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);\nstatic int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);\nstatic int ocfs2_get_sector(struct super_block *sb,\n\t\t\t    struct buffer_head **bh,\n\t\t\t    int block,\n\t\t\t    int sect_size);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic void ocfs2_free_inode(struct inode *inode);\nstatic int ocfs2_susp_quotas(struct ocfs2_super *osb, int unsuspend);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic struct dquot **ocfs2_get_dquots(struct inode *inode)\n{\n\treturn OCFS2_I(inode)->i_dquot;\n}\n\nstatic const struct super_operations ocfs2_sops = {\n\t.statfs\t\t= ocfs2_statfs,\n\t.alloc_inode\t= ocfs2_alloc_inode,\n\t.free_inode\t= ocfs2_free_inode,\n\t.drop_inode\t= ocfs2_drop_inode,\n\t.evict_inode\t= ocfs2_evict_inode,\n\t.sync_fs\t= ocfs2_sync_fs,\n\t.put_super\t= ocfs2_put_super,\n\t.remount_fs\t= ocfs2_remount,\n\t.show_options   = ocfs2_show_options,\n\t.quota_read\t= ocfs2_quota_read,\n\t.quota_write\t= ocfs2_quota_write,\n\t.get_dquots\t= ocfs2_get_dquots,\n};\n\nenum {\n\tOpt_barrier,\n\tOpt_err_panic,\n\tOpt_err_ro,\n\tOpt_intr,\n\tOpt_nointr,\n\tOpt_hb_none,\n\tOpt_hb_local,\n\tOpt_hb_global,\n\tOpt_data_ordered,\n\tOpt_data_writeback,\n\tOpt_atime_quantum,\n\tOpt_slot,\n\tOpt_commit,\n\tOpt_localalloc,\n\tOpt_localflocks,\n\tOpt_stack,\n\tOpt_user_xattr,\n\tOpt_nouser_xattr,\n\tOpt_inode64,\n\tOpt_acl,\n\tOpt_noacl,\n\tOpt_usrquota,\n\tOpt_grpquota,\n\tOpt_coherency_buffered,\n\tOpt_coherency_full,\n\tOpt_resv_level,\n\tOpt_dir_resv_level,\n\tOpt_journal_async_commit,\n\tOpt_err_cont,\n\tOpt_err,\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_intr, \"intr\"},\n\t{Opt_nointr, \"nointr\"},\n\t{Opt_hb_none, OCFS2_HB_NONE},\n\t{Opt_hb_local, OCFS2_HB_LOCAL},\n\t{Opt_hb_global, OCFS2_HB_GLOBAL},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_atime_quantum, \"atime_quantum=%u\"},\n\t{Opt_slot, \"preferred_slot=%u\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_localalloc, \"localalloc=%d\"},\n\t{Opt_localflocks, \"localflocks\"},\n\t{Opt_stack, \"cluster_stack=%s\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_inode64, \"inode64\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_coherency_buffered, \"coherency=buffered\"},\n\t{Opt_coherency_full, \"coherency=full\"},\n\t{Opt_resv_level, \"resv_level=%u\"},\n\t{Opt_dir_resv_level, \"dir_resv_level=%u\"},\n\t{Opt_journal_async_commit, \"journal_async_commit\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err, NULL}\n};\n\n#ifdef CONFIG_DEBUG_FS\nstatic int ocfs2_osb_dump(struct ocfs2_super *osb, char *buf, int len)\n{\n\tstruct ocfs2_cluster_connection *cconn = osb->cconn;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\tstruct ocfs2_orphan_scan *os = &osb->osb_orphan_scan;\n\tint i, out = 0;\n\tunsigned long flags;\n\n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"%10s => Id: %-s  Uuid: %-s  Gen: 0x%X  Label: %-s\\n\",\n\t\t\t\"Device\", osb->dev_str, osb->uuid_str,\n\t\t\tosb->fs_generation, osb->vol_label);\n\n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"%10s => State: %d  Flags: 0x%lX\\n\", \"Volume\",\n\t\t\tatomic_read(&osb->vol_state), osb->osb_flags);\n\n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"%10s => Block: %lu  Cluster: %d\\n\", \"Sizes\",\n\t\t\tosb->sb->s_blocksize, osb->s_clustersize);\n\n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"%10s => Compat: 0x%X  Incompat: 0x%X  \"\n\t\t\t\"ROcompat: 0x%X\\n\",\n\t\t\t\"Features\", osb->s_feature_compat,\n\t\t\tosb->s_feature_incompat, osb->s_feature_ro_compat);\n\n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"%10s => Opts: 0x%lX  AtimeQuanta: %u\\n\", \"Mount\",\n\t\t\tosb->s_mount_opt, osb->s_atime_quantum);\n\n\tif (cconn) {\n\t\tout += scnprintf(buf + out, len - out,\n\t\t\t\t\"%10s => Stack: %s  Name: %*s  \"\n\t\t\t\t\"Version: %d.%d\\n\", \"Cluster\",\n\t\t\t\t(*osb->osb_cluster_stack == '\\0' ?\n\t\t\t\t \"o2cb\" : osb->osb_cluster_stack),\n\t\t\t\tcconn->cc_namelen, cconn->cc_name,\n\t\t\t\tcconn->cc_version.pv_major,\n\t\t\t\tcconn->cc_version.pv_minor);\n\t}\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"%10s => Pid: %d  Count: %lu  WakeSeq: %lu  \"\n\t\t\t\"WorkSeq: %lu\\n\", \"DownCnvt\",\n\t\t\t(osb->dc_task ?  task_pid_nr(osb->dc_task) : -1),\n\t\t\tosb->blocked_lock_count, osb->dc_wake_sequence,\n\t\t\tosb->dc_work_sequence);\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\n\tspin_lock(&osb->osb_lock);\n\tout += scnprintf(buf + out, len - out, \"%10s => Pid: %d  Nodes:\",\n\t\t\t\"Recovery\",\n\t\t\t(osb->recovery_thread_task ?\n\t\t\t task_pid_nr(osb->recovery_thread_task) : -1));\n\tif (rm->rm_used == 0)\n\t\tout += scnprintf(buf + out, len - out, \" None\\n\");\n\telse {\n\t\tfor (i = 0; i < rm->rm_used; i++)\n\t\t\tout += scnprintf(buf + out, len - out, \" %d\",\n\t\t\t\t\trm->rm_entries[i]);\n\t\tout += scnprintf(buf + out, len - out, \"\\n\");\n\t}\n\tspin_unlock(&osb->osb_lock);\n\n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"%10s => Pid: %d  Interval: %lu\\n\", \"Commit\",\n\t\t\t(osb->commit_task ? task_pid_nr(osb->commit_task) : -1),\n\t\t\tosb->osb_commit_interval);\n\n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"%10s => State: %d  TxnId: %lu  NumTxns: %d\\n\",\n\t\t\t\"Journal\", osb->journal->j_state,\n\t\t\tosb->journal->j_trans_id,\n\t\t\tatomic_read(&osb->journal->j_num_trans));\n\n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"%10s => GlobalAllocs: %d  LocalAllocs: %d  \"\n\t\t\t\"SubAllocs: %d  LAWinMoves: %d  SAExtends: %d\\n\",\n\t\t\t\"Stats\",\n\t\t\tatomic_read(&osb->alloc_stats.bitmap_data),\n\t\t\tatomic_read(&osb->alloc_stats.local_data),\n\t\t\tatomic_read(&osb->alloc_stats.bg_allocs),\n\t\t\tatomic_read(&osb->alloc_stats.moves),\n\t\t\tatomic_read(&osb->alloc_stats.bg_extends));\n\n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"%10s => State: %u  Descriptor: %llu  Size: %u bits  \"\n\t\t\t\"Default: %u bits\\n\",\n\t\t\t\"LocalAlloc\", osb->local_alloc_state,\n\t\t\t(unsigned long long)osb->la_last_gd,\n\t\t\tosb->local_alloc_bits, osb->local_alloc_default_bits);\n\n\tspin_lock(&osb->osb_lock);\n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"%10s => InodeSlot: %d  StolenInodes: %d, \"\n\t\t\t\"MetaSlot: %d  StolenMeta: %d\\n\", \"Steal\",\n\t\t\tosb->s_inode_steal_slot,\n\t\t\tatomic_read(&osb->s_num_inodes_stolen),\n\t\t\tosb->s_meta_steal_slot,\n\t\t\tatomic_read(&osb->s_num_meta_stolen));\n\tspin_unlock(&osb->osb_lock);\n\n\tout += scnprintf(buf + out, len - out, \"OrphanScan => \");\n\tout += scnprintf(buf + out, len - out, \"Local: %u  Global: %u \",\n\t\t\tos->os_count, os->os_seqno);\n\tout += scnprintf(buf + out, len - out, \" Last Scan: \");\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_INACTIVE)\n\t\tout += scnprintf(buf + out, len - out, \"Disabled\\n\");\n\telse\n\t\tout += scnprintf(buf + out, len - out, \"%lu seconds ago\\n\",\n\t\t\t\t(unsigned long)(ktime_get_seconds() - os->os_scantime));\n\n\tout += scnprintf(buf + out, len - out, \"%10s => %3s  %10s\\n\",\n\t\t\t\"Slots\", \"Num\", \"RecoGen\");\n\tfor (i = 0; i < osb->max_slots; ++i) {\n\t\tout += scnprintf(buf + out, len - out,\n\t\t\t\t\"%10s  %c %3d  %10d\\n\",\n\t\t\t\t\" \",\n\t\t\t\t(i == osb->slot_num ? '*' : ' '),\n\t\t\t\ti, osb->slot_recovery_generations[i]);\n\t}\n\n\treturn out;\n}\n\nstatic int ocfs2_osb_debug_open(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_super *osb = inode->i_private;\n\tchar *buf = NULL;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto bail;\n\n\ti_size_write(inode, ocfs2_osb_dump(osb, buf, PAGE_SIZE));\n\n\tfile->private_data = buf;\n\n\treturn 0;\nbail:\n\treturn -ENOMEM;\n}\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\treturn 0;\n}\n\nstatic ssize_t ocfs2_debug_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\treturn simple_read_from_buffer(buf, nbytes, ppos, file->private_data,\n\t\t\t\t       i_size_read(file->f_mapping->host));\n}\n#else\nstatic int ocfs2_osb_debug_open(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\nstatic ssize_t ocfs2_debug_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\treturn 0;\n}\n#endif\t \n\nstatic const struct file_operations ocfs2_osb_debug_fops = {\n\t.open =\t\tocfs2_osb_debug_open,\n\t.release =\tocfs2_debug_release,\n\t.read =\t\tocfs2_debug_read,\n\t.llseek =\tgeneric_file_llseek,\n};\n\nstatic int ocfs2_sync_fs(struct super_block *sb, int wait)\n{\n\tint status;\n\ttid_t target;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (wait) {\n\t\tstatus = ocfs2_flush_truncate_log(osb);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t} else {\n\t\tocfs2_schedule_truncate_log_flush(osb, 0);\n\t}\n\n\tif (jbd2_journal_start_commit(osb->journal->j_journal,\n\t\t\t\t      &target)) {\n\t\tif (wait)\n\t\t\tjbd2_log_wait_commit(osb->journal->j_journal,\n\t\t\t\t\t     target);\n\t}\n\treturn 0;\n}\n\nstatic int ocfs2_need_system_inode(struct ocfs2_super *osb, int ino)\n{\n\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_RO_COMPAT_USRQUOTA)\n\t    && (ino == USER_QUOTA_SYSTEM_INODE\n\t\t|| ino == LOCAL_USER_QUOTA_SYSTEM_INODE))\n\t\treturn 0;\n\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)\n\t    && (ino == GROUP_QUOTA_SYSTEM_INODE\n\t\t|| ino == LOCAL_GROUP_QUOTA_SYSTEM_INODE))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb)\n{\n\tstruct inode *new = NULL;\n\tint status = 0;\n\tint i;\n\n\tnew = ocfs2_iget(osb, osb->root_blkno, OCFS2_FI_FLAG_SYSFILE, 0);\n\tif (IS_ERR(new)) {\n\t\tstatus = PTR_ERR(new);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tosb->root_inode = new;\n\n\tnew = ocfs2_iget(osb, osb->system_dir_blkno, OCFS2_FI_FLAG_SYSFILE, 0);\n\tif (IS_ERR(new)) {\n\t\tstatus = PTR_ERR(new);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tosb->sys_root_inode = new;\n\n\tfor (i = OCFS2_FIRST_ONLINE_SYSTEM_INODE;\n\t     i <= OCFS2_LAST_GLOBAL_SYSTEM_INODE; i++) {\n\t\tif (!ocfs2_need_system_inode(osb, i))\n\t\t\tcontinue;\n\t\tnew = ocfs2_get_system_file_inode(osb, i, osb->slot_num);\n\t\tif (!new) {\n\t\t\tocfs2_release_system_inodes(osb);\n\t\t\tstatus = ocfs2_is_soft_readonly(osb) ? -EROFS : -EINVAL;\n\t\t\tmlog_errno(status);\n\t\t\tmlog(ML_ERROR, \"Unable to load system inode %d, \"\n\t\t\t     \"possibly corrupt fs?\", i);\n\t\t\tgoto bail;\n\t\t}\n\t\t\n\t\tiput(new);\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb)\n{\n\tstruct inode *new = NULL;\n\tint status = 0;\n\tint i;\n\n\tfor (i = OCFS2_LAST_GLOBAL_SYSTEM_INODE + 1;\n\t     i < NUM_SYSTEM_INODES;\n\t     i++) {\n\t\tif (!ocfs2_need_system_inode(osb, i))\n\t\t\tcontinue;\n\t\tnew = ocfs2_get_system_file_inode(osb, i, osb->slot_num);\n\t\tif (!new) {\n\t\t\tocfs2_release_system_inodes(osb);\n\t\t\tstatus = ocfs2_is_soft_readonly(osb) ? -EROFS : -EINVAL;\n\t\t\tmlog(ML_ERROR, \"status=%d, sysfile=%d, slot=%d\\n\",\n\t\t\t     status, i, osb->slot_num);\n\t\t\tgoto bail;\n\t\t}\n\t\t \n\t\tiput(new);\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb)\n{\n\tint i;\n\tstruct inode *inode;\n\n\tfor (i = 0; i < NUM_GLOBAL_SYSTEM_INODES; i++) {\n\t\tinode = osb->global_system_inodes[i];\n\t\tif (inode) {\n\t\t\tiput(inode);\n\t\t\tosb->global_system_inodes[i] = NULL;\n\t\t}\n\t}\n\n\tinode = osb->sys_root_inode;\n\tif (inode) {\n\t\tiput(inode);\n\t\tosb->sys_root_inode = NULL;\n\t}\n\n\tinode = osb->root_inode;\n\tif (inode) {\n\t\tiput(inode);\n\t\tosb->root_inode = NULL;\n\t}\n\n\tif (!osb->local_system_inodes)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_LOCAL_SYSTEM_INODES * osb->max_slots; i++) {\n\t\tif (osb->local_system_inodes[i]) {\n\t\t\tiput(osb->local_system_inodes[i]);\n\t\t\tosb->local_system_inodes[i] = NULL;\n\t\t}\n\t}\n\n\tkfree(osb->local_system_inodes);\n\tosb->local_system_inodes = NULL;\n}\n\n \nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb)\n{\n\tstruct ocfs2_inode_info *oi;\n\n\toi = alloc_inode_sb(sb, ocfs2_inode_cachep, GFP_NOFS);\n\tif (!oi)\n\t\treturn NULL;\n\n\toi->i_sync_tid = 0;\n\toi->i_datasync_tid = 0;\n\tmemset(&oi->i_dquot, 0, sizeof(oi->i_dquot));\n\n\tjbd2_journal_init_jbd_inode(&oi->ip_jinode, &oi->vfs_inode);\n\treturn &oi->vfs_inode;\n}\n\nstatic void ocfs2_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(ocfs2_inode_cachep, OCFS2_I(inode));\n}\n\nstatic unsigned long long ocfs2_max_file_offset(unsigned int bbits,\n\t\t\t\t\t\tunsigned int cbits)\n{\n\tunsigned int bytes = 1 << cbits;\n\tunsigned int trim = bytes;\n\tunsigned int bitshift = 32;\n\n\t \n\n#if BITS_PER_LONG == 32\n\tBUILD_BUG_ON(sizeof(sector_t) != 8);\n\t \n\tif (bytes > PAGE_SIZE) {\n\t\tbytes = PAGE_SIZE;\n\t\ttrim = 1;\n\t\t \n\t\tbitshift = 31;\n\t}\n#endif\n\n\t \n\treturn (((unsigned long long)bytes) << bitshift) - trim;\n}\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data)\n{\n\tint incompat_features;\n\tint ret = 0;\n\tstruct mount_options parsed_options;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tu32 tmp;\n\n\tsync_filesystem(sb);\n\n\tif (!ocfs2_parse_options(sb, data, &parsed_options, 1) ||\n\t    !ocfs2_check_set_options(sb, &parsed_options)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttmp = OCFS2_MOUNT_HB_LOCAL | OCFS2_MOUNT_HB_GLOBAL |\n\t\tOCFS2_MOUNT_HB_NONE;\n\tif ((osb->s_mount_opt & tmp) != (parsed_options.mount_opt & tmp)) {\n\t\tret = -EINVAL;\n\t\tmlog(ML_ERROR, \"Cannot change heartbeat mode on remount\\n\");\n\t\tgoto out;\n\t}\n\n\tif ((osb->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK) !=\n\t    (parsed_options.mount_opt & OCFS2_MOUNT_DATA_WRITEBACK)) {\n\t\tret = -EINVAL;\n\t\tmlog(ML_ERROR, \"Cannot change data mode on remount\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_INODE64) &&\n\t    (parsed_options.mount_opt & OCFS2_MOUNT_INODE64)) {\n\t\tret = -EINVAL;\n\t\tmlog(ML_ERROR, \"Cannot enable inode64 on remount\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif ((bool)(*flags & SB_RDONLY) != sb_rdonly(sb)) {\n\t\t \n\t\tif (*flags & SB_RDONLY) {\n\t\t\tret = ocfs2_susp_quotas(osb, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tspin_lock(&osb->osb_lock);\n\t\tif (osb->osb_flags & OCFS2_OSB_HARD_RO) {\n\t\t\tmlog(ML_ERROR, \"Remount on readonly device is forbidden.\\n\");\n\t\t\tret = -EROFS;\n\t\t\tgoto unlock_osb;\n\t\t}\n\n\t\tif (*flags & SB_RDONLY) {\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t\tosb->osb_flags |= OCFS2_OSB_SOFT_RO;\n\t\t} else {\n\t\t\tif (osb->osb_flags & OCFS2_OSB_ERROR_FS) {\n\t\t\t\tmlog(ML_ERROR, \"Cannot remount RDWR \"\n\t\t\t\t     \"filesystem due to previous errors.\\n\");\n\t\t\t\tret = -EROFS;\n\t\t\t\tgoto unlock_osb;\n\t\t\t}\n\t\t\tincompat_features = OCFS2_HAS_RO_COMPAT_FEATURE(sb, ~OCFS2_FEATURE_RO_COMPAT_SUPP);\n\t\t\tif (incompat_features) {\n\t\t\t\tmlog(ML_ERROR, \"Cannot remount RDWR because \"\n\t\t\t\t     \"of unsupported optional features \"\n\t\t\t\t     \"(%x).\\n\", incompat_features);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto unlock_osb;\n\t\t\t}\n\t\t\tsb->s_flags &= ~SB_RDONLY;\n\t\t\tosb->osb_flags &= ~OCFS2_OSB_SOFT_RO;\n\t\t}\n\t\ttrace_ocfs2_remount(sb->s_flags, osb->osb_flags, *flags);\nunlock_osb:\n\t\tspin_unlock(&osb->osb_lock);\n\t\t \n\t\tif (!ret && !(*flags & SB_RDONLY)) {\n\t\t\tif (sb_any_quota_suspended(sb))\n\t\t\t\tret = ocfs2_susp_quotas(osb, 1);\n\t\t\telse\n\t\t\t\tret = ocfs2_enable_quotas(osb);\n\t\t\tif (ret < 0) {\n\t\t\t\t \n\t\t\t\tspin_lock(&osb->osb_lock);\n\t\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t\t\tosb->osb_flags |= OCFS2_OSB_SOFT_RO;\n\t\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ret) {\n\t\t \n\t\tosb->s_mount_opt = parsed_options.mount_opt;\n\t\tosb->s_atime_quantum = parsed_options.atime_quantum;\n\t\tosb->preferred_slot = parsed_options.slot;\n\t\tif (parsed_options.commit_interval)\n\t\t\tosb->osb_commit_interval = parsed_options.commit_interval;\n\n\t\tif (!ocfs2_is_hard_readonly(osb))\n\t\t\tocfs2_set_journal_params(osb);\n\n\t\tsb->s_flags = (sb->s_flags & ~SB_POSIXACL) |\n\t\t\t((osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) ?\n\t\t\t\t\t\t\tSB_POSIXACL : 0);\n\t}\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_sb_probe(struct super_block *sb,\n\t\t\t  struct buffer_head **bh,\n\t\t\t  int *sector_size,\n\t\t\t  struct ocfs2_blockcheck_stats *stats)\n{\n\tint status, tmpstat;\n\tstruct ocfs1_vol_disk_hdr *hdr;\n\tstruct ocfs2_dinode *di;\n\tint blksize;\n\n\t*bh = NULL;\n\n\t \n\t*sector_size = bdev_logical_block_size(sb->s_bdev);\n\tif (*sector_size > OCFS2_MAX_BLOCKSIZE) {\n\t\tmlog(ML_ERROR, \"Hardware sector size too large: %d (max=%d)\\n\",\n\t\t     *sector_size, OCFS2_MAX_BLOCKSIZE);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\t \n\tif (*sector_size < OCFS2_MIN_BLOCKSIZE)\n\t\t*sector_size = OCFS2_MIN_BLOCKSIZE;\n\n\t \n\tstatus = ocfs2_get_sector(sb, bh, 0, *sector_size);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\thdr = (struct ocfs1_vol_disk_hdr *) (*bh)->b_data;\n\tif (hdr->major_version == OCFS1_MAJOR_VERSION) {\n\t\tmlog(ML_ERROR, \"incompatible version: %u.%u\\n\",\n\t\t     hdr->major_version, hdr->minor_version);\n\t\tstatus = -EINVAL;\n\t}\n\tif (memcmp(hdr->signature, OCFS1_VOLUME_SIGNATURE,\n\t\t   strlen(OCFS1_VOLUME_SIGNATURE)) == 0) {\n\t\tmlog(ML_ERROR, \"incompatible volume signature: %8s\\n\",\n\t\t     hdr->signature);\n\t\tstatus = -EINVAL;\n\t}\n\tbrelse(*bh);\n\t*bh = NULL;\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"This is an ocfs v1 filesystem which must be \"\n\t\t     \"upgraded before mounting with ocfs v2\\n\");\n\t\tgoto bail;\n\t}\n\n\t \n\tstatus = -EINVAL;\n\tfor (blksize = *sector_size;\n\t     blksize <= OCFS2_MAX_BLOCKSIZE;\n\t     blksize <<= 1) {\n\t\ttmpstat = ocfs2_get_sector(sb, bh,\n\t\t\t\t\t   OCFS2_SUPER_BLOCK_BLKNO,\n\t\t\t\t\t   blksize);\n\t\tif (tmpstat < 0) {\n\t\t\tstatus = tmpstat;\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\t\tdi = (struct ocfs2_dinode *) (*bh)->b_data;\n\t\tmemset(stats, 0, sizeof(struct ocfs2_blockcheck_stats));\n\t\tspin_lock_init(&stats->b_lock);\n\t\ttmpstat = ocfs2_verify_volume(di, *bh, blksize, stats);\n\t\tif (tmpstat < 0) {\n\t\t\tbrelse(*bh);\n\t\t\t*bh = NULL;\n\t\t}\n\t\tif (tmpstat != -EAGAIN) {\n\t\t\tstatus = tmpstat;\n\t\t\tbreak;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}\n\nstatic int ocfs2_verify_heartbeat(struct ocfs2_super *osb)\n{\n\tu32 hb_enabled = OCFS2_MOUNT_HB_LOCAL | OCFS2_MOUNT_HB_GLOBAL;\n\n\tif (osb->s_mount_opt & hb_enabled) {\n\t\tif (ocfs2_mount_local(osb)) {\n\t\t\tmlog(ML_ERROR, \"Cannot heartbeat on a locally \"\n\t\t\t     \"mounted device.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ocfs2_userspace_stack(osb)) {\n\t\t\tmlog(ML_ERROR, \"Userspace stack expected, but \"\n\t\t\t     \"o2cb heartbeat arguments passed to mount\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (((osb->s_mount_opt & OCFS2_MOUNT_HB_GLOBAL) &&\n\t\t     !ocfs2_cluster_o2cb_global_heartbeat(osb)) ||\n\t\t    ((osb->s_mount_opt & OCFS2_MOUNT_HB_LOCAL) &&\n\t\t     ocfs2_cluster_o2cb_global_heartbeat(osb))) {\n\t\t\tmlog(ML_ERROR, \"Mismatching o2cb heartbeat modes\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!(osb->s_mount_opt & hb_enabled)) {\n\t\tif (!ocfs2_mount_local(osb) && !ocfs2_is_hard_readonly(osb) &&\n\t\t    !ocfs2_userspace_stack(osb)) {\n\t\t\tmlog(ML_ERROR, \"Heartbeat has to be started to mount \"\n\t\t\t     \"a read-write clustered device.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ocfs2_verify_userspace_stack(struct ocfs2_super *osb,\n\t\t\t\t\tstruct mount_options *mopt)\n{\n\tif (!ocfs2_userspace_stack(osb) && mopt->cluster_stack[0]) {\n\t\tmlog(ML_ERROR,\n\t\t     \"cluster stack passed to mount, but this filesystem \"\n\t\t     \"does not support it\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ocfs2_userspace_stack(osb) &&\n\t    strncmp(osb->osb_cluster_stack, mopt->cluster_stack,\n\t\t    OCFS2_STACK_LABEL_LEN)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"cluster stack passed to mount (\\\"%s\\\") does not \"\n\t\t     \"match the filesystem (\\\"%s\\\")\\n\",\n\t\t     mopt->cluster_stack,\n\t\t     osb->osb_cluster_stack);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ocfs2_susp_quotas(struct ocfs2_super *osb, int unsuspend)\n{\n\tint type;\n\tstruct super_block *sb = osb->sb;\n\tunsigned int feature[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_USRQUOTA,\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_GRPQUOTA};\n\tint status = 0;\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(sb, feature[type]))\n\t\t\tcontinue;\n\t\tif (unsuspend)\n\t\t\tstatus = dquot_resume(sb, type);\n\t\telse {\n\t\t\tstruct ocfs2_mem_dqinfo *oinfo;\n\n\t\t\t \n\t\t\toinfo = sb_dqinfo(sb, type)->dqi_priv;\n\t\t\tcancel_delayed_work_sync(&oinfo->dqi_sync_work);\n\t\t\tstatus = dquot_suspend(sb, type);\n\t\t}\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Failed to suspend/unsuspend quotas on \"\n\t\t     \"remount (error = %d).\\n\", status);\n\treturn status;\n}\n\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb)\n{\n\tstruct inode *inode[OCFS2_MAXQUOTAS] = { NULL, NULL };\n\tstruct super_block *sb = osb->sb;\n\tunsigned int feature[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_USRQUOTA,\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_GRPQUOTA};\n\tunsigned int ino[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tLOCAL_USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\tLOCAL_GROUP_QUOTA_SYSTEM_INODE };\n\tint status;\n\tint type;\n\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NEGATIVE_USAGE;\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(sb, feature[type]))\n\t\t\tcontinue;\n\t\tinode[type] = ocfs2_get_system_file_inode(osb, ino[type],\n\t\t\t\t\t\t\tosb->slot_num);\n\t\tif (!inode[type]) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto out_quota_off;\n\t\t}\n\t\tstatus = dquot_load_quota_inode(inode[type], type, QFMT_OCFS2,\n\t\t\t\t\t\tDQUOT_USAGE_ENABLED);\n\t\tif (status < 0)\n\t\t\tgoto out_quota_off;\n\t}\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tiput(inode[type]);\n\treturn 0;\nout_quota_off:\n\tocfs2_disable_quotas(osb);\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tiput(inode[type]);\n\tmlog_errno(status);\n\treturn status;\n}\n\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb)\n{\n\tint type;\n\tstruct inode *inode;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_mem_dqinfo *oinfo;\n\n\t \n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!sb_has_quota_loaded(sb, type))\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_suspended(sb, type)) {\n\t\t\toinfo = sb_dqinfo(sb, type)->dqi_priv;\n\t\t\tcancel_delayed_work_sync(&oinfo->dqi_sync_work);\n\t\t}\n\t\tinode = igrab(sb->s_dquot.files[type]);\n\t\t \n\t\tdquot_disable(sb, type, DQUOT_USAGE_ENABLED |\n\t\t\t\t\tDQUOT_LIMITS_ENABLED);\n\t\tiput(inode);\n\t}\n}\n\nstatic int ocfs2_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct dentry *root;\n\tint status, sector_size;\n\tstruct mount_options parsed_options;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_super *osb = NULL;\n\tstruct buffer_head *bh = NULL;\n\tchar nodestr[12];\n\tstruct ocfs2_blockcheck_stats stats;\n\n\ttrace_ocfs2_fill_super(sb, data, silent);\n\n\tif (!ocfs2_parse_options(sb, data, &parsed_options, 0)) {\n\t\tstatus = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tstatus = ocfs2_sb_probe(sb, &bh, &sector_size, &stats);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"superblock probe failed!\\n\");\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_initialize_super(sb, bh, sector_size, &stats);\n\tbrelse(bh);\n\tbh = NULL;\n\tif (status < 0)\n\t\tgoto out;\n\n\tosb = OCFS2_SB(sb);\n\n\tif (!ocfs2_check_set_options(sb, &parsed_options)) {\n\t\tstatus = -EINVAL;\n\t\tgoto out_super;\n\t}\n\tosb->s_mount_opt = parsed_options.mount_opt;\n\tosb->s_atime_quantum = parsed_options.atime_quantum;\n\tosb->preferred_slot = parsed_options.slot;\n\tosb->osb_commit_interval = parsed_options.commit_interval;\n\n\tocfs2_la_set_sizes(osb, parsed_options.localalloc_opt);\n\tosb->osb_resv_level = parsed_options.resv_level;\n\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\tif (parsed_options.dir_resv_level == -1)\n\t\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\telse\n\t\tosb->osb_dir_resv_level = parsed_options.dir_resv_level;\n\n\tstatus = ocfs2_verify_userspace_stack(osb, &parsed_options);\n\tif (status)\n\t\tgoto out_super;\n\n\tsb->s_magic = OCFS2_SUPER_MAGIC;\n\n\tsb->s_flags = (sb->s_flags & ~(SB_POSIXACL | SB_NOSEC)) |\n\t\t((osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) ? SB_POSIXACL : 0);\n\n\t \n\tif (bdev_read_only(sb->s_bdev)) {\n\t\tif (!sb_rdonly(sb)) {\n\t\t\tstatus = -EACCES;\n\t\t\tmlog(ML_ERROR, \"Readonly device detected but readonly \"\n\t\t\t     \"mount was not specified.\\n\");\n\t\t\tgoto out_super;\n\t\t}\n\n\t\t \n\t\tif (osb->s_mount_opt & OCFS2_MOUNT_HB_LOCAL) {\n\t\t\tstatus = -EROFS;\n\t\t\tmlog(ML_ERROR, \"Local heartbeat specified on readonly \"\n\t\t\t     \"device.\\n\");\n\t\t\tgoto out_super;\n\t\t}\n\n\t\tstatus = ocfs2_check_journals_nolocks(osb);\n\t\tif (status < 0) {\n\t\t\tif (status == -EROFS)\n\t\t\t\tmlog(ML_ERROR, \"Recovery required on readonly \"\n\t\t\t\t     \"file system, but write access is \"\n\t\t\t\t     \"unavailable.\\n\");\n\t\t\tgoto out_super;\n\t\t}\n\n\t\tocfs2_set_ro_flag(osb, 1);\n\n\t\tprintk(KERN_NOTICE \"ocfs2: Readonly device (%s) detected. \"\n\t\t       \"Cluster services will not be used for this mount. \"\n\t\t       \"Recovery will be skipped.\\n\", osb->dev_str);\n\t}\n\n\tif (!ocfs2_is_hard_readonly(osb)) {\n\t\tif (sb_rdonly(sb))\n\t\t\tocfs2_set_ro_flag(osb, 0);\n\t}\n\n\tstatus = ocfs2_verify_heartbeat(osb);\n\tif (status < 0)\n\t\tgoto out_super;\n\n\tosb->osb_debug_root = debugfs_create_dir(osb->uuid_str,\n\t\t\t\t\t\t ocfs2_debugfs_root);\n\n\tdebugfs_create_file(\"fs_state\", S_IFREG|S_IRUSR, osb->osb_debug_root,\n\t\t\t    osb, &ocfs2_osb_debug_fops);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\tocfs2_blockcheck_stats_debugfs_install( &osb->osb_ecc_stats,\n\t\t\t\t\t\t\tosb->osb_debug_root);\n\n\tstatus = ocfs2_mount_volume(sb);\n\tif (status < 0)\n\t\tgoto out_debugfs;\n\n\tif (osb->root_inode)\n\t\tinode = igrab(osb->root_inode);\n\n\tif (!inode) {\n\t\tstatus = -EIO;\n\t\tgoto out_dismount;\n\t}\n\n\tosb->osb_dev_kset = kset_create_and_add(sb->s_id, NULL,\n\t\t\t\t\t\t&ocfs2_kset->kobj);\n\tif (!osb->osb_dev_kset) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create device kset %s.\\n\", sb->s_id);\n\t\tgoto out_dismount;\n\t}\n\n\t \n\tif (ocfs2_filecheck_create_sysfs(osb)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create filecheck sysfs directory at \"\n\t\t\t\"/sys/fs/ocfs2/%s/filecheck.\\n\", sb->s_id);\n\t\tgoto out_dismount;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out_dismount;\n\t}\n\n\tsb->s_root = root;\n\n\tocfs2_complete_mount_recovery(osb);\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Mounting device (%s) on (node %s, slot %d) \"\n\t       \"with %s data mode.\\n\",\n\t       osb->dev_str, nodestr, osb->slot_num,\n\t       osb->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK ? \"writeback\" :\n\t       \"ordered\");\n\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED);\n\twake_up(&osb->osb_mount_event);\n\n\t \n\tif (!sb_rdonly(sb)) {\n\t\tstatus = ocfs2_enable_quotas(osb);\n\t\tif (status < 0) {\n\t\t\t \n\t\t\tmlog_errno(status);\n\t\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\t\twake_up(&osb->osb_mount_event);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tocfs2_complete_quota_recovery(osb);\n\n\t \n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED_QUOTAS);\n\twake_up(&osb->osb_mount_event);\n\n\t \n\tocfs2_orphan_scan_start(osb);\n\n\treturn status;\n\nout_dismount:\n\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\twake_up(&osb->osb_mount_event);\n\tocfs2_free_replay_slots(osb);\n\tocfs2_dismount_volume(sb, 1);\n\tgoto out;\n\nout_debugfs:\n\tdebugfs_remove_recursive(osb->osb_debug_root);\nout_super:\n\tocfs2_release_system_inodes(osb);\n\tkfree(osb->recovery_map);\n\tocfs2_delete_osb(osb);\n\tkfree(osb);\nout:\n\tmlog_errno(status);\n\n\treturn status;\n}\n\nstatic struct dentry *ocfs2_mount(struct file_system_type *fs_type,\n\t\t\tint flags,\n\t\t\tconst char *dev_name,\n\t\t\tvoid *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ocfs2_fill_super);\n}\n\nstatic struct file_system_type ocfs2_fs_type = {\n\t.owner          = THIS_MODULE,\n\t.name           = \"ocfs2\",\n\t.mount          = ocfs2_mount,\n\t.kill_sb        = kill_block_super,\n\t.fs_flags       = FS_REQUIRES_DEV|FS_RENAME_DOES_D_MOVE,\n\t.next           = NULL\n};\nMODULE_ALIAS_FS(\"ocfs2\");\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t \n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}\n\nstatic int ocfs2_parse_options(struct super_block *sb,\n\t\t\t       char *options,\n\t\t\t       struct mount_options *mopt,\n\t\t\t       int is_remount)\n{\n\tint status, user_stack = 0;\n\tchar *p;\n\tu32 tmp;\n\tint token, option;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\ttrace_ocfs2_parse_options(is_remount, options ? options : \"(none)\");\n\n\tmopt->commit_interval = 0;\n\tmopt->mount_opt = OCFS2_MOUNT_NOINTR;\n\tmopt->atime_quantum = OCFS2_DEFAULT_ATIME_QUANTUM;\n\tmopt->slot = OCFS2_INVALID_SLOT;\n\tmopt->localalloc_opt = -1;\n\tmopt->cluster_stack[0] = '\\0';\n\tmopt->resv_level = OCFS2_DEFAULT_RESV_LEVEL;\n\tmopt->dir_resv_level = -1;\n\n\tif (!options) {\n\t\tstatus = 1;\n\t\tgoto bail;\n\t}\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_hb_local:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_LOCAL;\n\t\t\tbreak;\n\t\tcase Opt_hb_none:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_NONE;\n\t\t\tbreak;\n\t\tcase Opt_hb_global:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_GLOBAL;\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option)\n\t\t\t\tmopt->mount_opt |= OCFS2_MOUNT_BARRIER;\n\t\t\telse\n\t\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_BARRIER;\n\t\t\tbreak;\n\t\tcase Opt_intr:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NOINTR;\n\t\t\tbreak;\n\t\tcase Opt_nointr:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NOINTR;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_ERRORS_CONT;\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_ERRORS_ROFS;\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_ERRORS_CONT;\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_ERRORS_PANIC;\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_ERRORS_ROFS;\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_ERRORS_ROFS;\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_ERRORS_PANIC;\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_ERRORS_CONT;\n\t\t\tbreak;\n\t\tcase Opt_data_ordered:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_DATA_WRITEBACK;\n\t\t\tbreak;\n\t\tcase Opt_data_writeback:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_DATA_WRITEBACK;\n\t\t\tbreak;\n\t\tcase Opt_user_xattr:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NOUSERXATTR;\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NOUSERXATTR;\n\t\t\tbreak;\n\t\tcase Opt_atime_quantum:\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= 0)\n\t\t\t\tmopt->atime_quantum = option;\n\t\t\tbreak;\n\t\tcase Opt_slot:\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option)\n\t\t\t\tmopt->slot = (u16)option;\n\t\t\tbreak;\n\t\tcase Opt_commit:\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tif (option == 0)\n\t\t\t\toption = JBD2_DEFAULT_MAX_COMMIT_AGE;\n\t\t\tmopt->commit_interval = HZ * option;\n\t\t\tbreak;\n\t\tcase Opt_localalloc:\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= 0)\n\t\t\t\tmopt->localalloc_opt = option;\n\t\t\tbreak;\n\t\tcase Opt_localflocks:\n\t\t\t \n\t\t\tif (!is_remount)\n\t\t\t\tmopt->mount_opt |= OCFS2_MOUNT_LOCALFLOCKS;\n\t\t\tbreak;\n\t\tcase Opt_stack:\n\t\t\t \n\t\t\tif (((args[0].to - args[0].from) !=\n\t\t\t     OCFS2_STACK_LABEL_LEN) ||\n\t\t\t    (strnlen(args[0].from,\n\t\t\t\t     OCFS2_STACK_LABEL_LEN) !=\n\t\t\t     OCFS2_STACK_LABEL_LEN)) {\n\t\t\t\tmlog(ML_ERROR,\n\t\t\t\t     \"Invalid cluster_stack option\\n\");\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tmemcpy(mopt->cluster_stack, args[0].from,\n\t\t\t       OCFS2_STACK_LABEL_LEN);\n\t\t\tmopt->cluster_stack[OCFS2_STACK_LABEL_LEN] = '\\0';\n\t\t\t \n\t\t\tif (memcmp(mopt->cluster_stack,\n\t\t\t\t   OCFS2_CLASSIC_CLUSTER_STACK,\n\t\t\t\t   OCFS2_STACK_LABEL_LEN))\n\t\t\t\tuser_stack = 1;\n\t\t\tbreak;\n\t\tcase Opt_inode64:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_INODE64;\n\t\t\tbreak;\n\t\tcase Opt_usrquota:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_USRQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_GRPQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_coherency_buffered:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_COHERENCY_BUFFERED;\n\t\t\tbreak;\n\t\tcase Opt_coherency_full:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_COHERENCY_BUFFERED;\n\t\t\tbreak;\n\t\tcase Opt_acl:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NO_POSIX_ACL;\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_POSIX_ACL;\n\t\t\tbreak;\n\t\tcase Opt_resv_level:\n\t\t\tif (is_remount)\n\t\t\t\tbreak;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= OCFS2_MIN_RESV_LEVEL &&\n\t\t\t    option < OCFS2_MAX_RESV_LEVEL)\n\t\t\t\tmopt->resv_level = option;\n\t\t\tbreak;\n\t\tcase Opt_dir_resv_level:\n\t\t\tif (is_remount)\n\t\t\t\tbreak;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= OCFS2_MIN_RESV_LEVEL &&\n\t\t\t    option < OCFS2_MAX_RESV_LEVEL)\n\t\t\t\tmopt->dir_resv_level = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_async_commit:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_JOURNAL_ASYNC_COMMIT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t     \"or missing value\\n\", p);\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (user_stack == 0) {\n\t\t \n\t\ttmp = mopt->mount_opt & (OCFS2_MOUNT_HB_LOCAL |\n\t\t\t\t\t OCFS2_MOUNT_HB_GLOBAL |\n\t\t\t\t\t OCFS2_MOUNT_HB_NONE);\n\t\tif (hweight32(tmp) != 1) {\n\t\t\tmlog(ML_ERROR, \"Invalid heartbeat mount options\\n\");\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 1;\n\nbail:\n\treturn status;\n}\n\nstatic int ocfs2_show_options(struct seq_file *s, struct dentry *root)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(root->d_sb);\n\tunsigned long opts = osb->s_mount_opt;\n\tunsigned int local_alloc_megs;\n\n\tif (opts & (OCFS2_MOUNT_HB_LOCAL | OCFS2_MOUNT_HB_GLOBAL)) {\n\t\tseq_printf(s, \",_netdev\");\n\t\tif (opts & OCFS2_MOUNT_HB_LOCAL)\n\t\t\tseq_printf(s, \",%s\", OCFS2_HB_LOCAL);\n\t\telse\n\t\t\tseq_printf(s, \",%s\", OCFS2_HB_GLOBAL);\n\t} else\n\t\tseq_printf(s, \",%s\", OCFS2_HB_NONE);\n\n\tif (opts & OCFS2_MOUNT_NOINTR)\n\t\tseq_printf(s, \",nointr\");\n\n\tif (opts & OCFS2_MOUNT_DATA_WRITEBACK)\n\t\tseq_printf(s, \",data=writeback\");\n\telse\n\t\tseq_printf(s, \",data=ordered\");\n\n\tif (opts & OCFS2_MOUNT_BARRIER)\n\t\tseq_printf(s, \",barrier=1\");\n\n\tif (opts & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tseq_printf(s, \",errors=panic\");\n\telse if (opts & OCFS2_MOUNT_ERRORS_CONT)\n\t\tseq_printf(s, \",errors=continue\");\n\telse\n\t\tseq_printf(s, \",errors=remount-ro\");\n\n\tif (osb->preferred_slot != OCFS2_INVALID_SLOT)\n\t\tseq_printf(s, \",preferred_slot=%d\", osb->preferred_slot);\n\n\tseq_printf(s, \",atime_quantum=%u\", osb->s_atime_quantum);\n\n\tif (osb->osb_commit_interval)\n\t\tseq_printf(s, \",commit=%u\",\n\t\t\t   (unsigned) (osb->osb_commit_interval / HZ));\n\n\tlocal_alloc_megs = osb->local_alloc_bits >> (20 - osb->s_clustersize_bits);\n\tif (local_alloc_megs != ocfs2_la_default_mb(osb))\n\t\tseq_printf(s, \",localalloc=%d\", local_alloc_megs);\n\n\tif (opts & OCFS2_MOUNT_LOCALFLOCKS)\n\t\tseq_printf(s, \",localflocks,\");\n\n\tif (osb->osb_cluster_stack[0])\n\t\tseq_show_option(s, \"cluster_stack\", osb->osb_cluster_stack);\n\tif (opts & OCFS2_MOUNT_USRQUOTA)\n\t\tseq_printf(s, \",usrquota\");\n\tif (opts & OCFS2_MOUNT_GRPQUOTA)\n\t\tseq_printf(s, \",grpquota\");\n\n\tif (opts & OCFS2_MOUNT_COHERENCY_BUFFERED)\n\t\tseq_printf(s, \",coherency=buffered\");\n\telse\n\t\tseq_printf(s, \",coherency=full\");\n\n\tif (opts & OCFS2_MOUNT_NOUSERXATTR)\n\t\tseq_printf(s, \",nouser_xattr\");\n\telse\n\t\tseq_printf(s, \",user_xattr\");\n\n\tif (opts & OCFS2_MOUNT_INODE64)\n\t\tseq_printf(s, \",inode64\");\n\n\tif (opts & OCFS2_MOUNT_POSIX_ACL)\n\t\tseq_printf(s, \",acl\");\n\telse\n\t\tseq_printf(s, \",noacl\");\n\n\tif (osb->osb_resv_level != OCFS2_DEFAULT_RESV_LEVEL)\n\t\tseq_printf(s, \",resv_level=%d\", osb->osb_resv_level);\n\n\tif (osb->osb_dir_resv_level != osb->osb_resv_level)\n\t\tseq_printf(s, \",dir_resv_level=%d\", osb->osb_resv_level);\n\n\tif (opts & OCFS2_MOUNT_JOURNAL_ASYNC_COMMIT)\n\t\tseq_printf(s, \",journal_async_commit\");\n\n\treturn 0;\n}\n\nstatic int __init ocfs2_init(void)\n{\n\tint status;\n\n\tstatus = init_ocfs2_uptodate_cache();\n\tif (status < 0)\n\t\tgoto out1;\n\n\tstatus = ocfs2_initialize_mem_caches();\n\tif (status < 0)\n\t\tgoto out2;\n\n\tocfs2_debugfs_root = debugfs_create_dir(\"ocfs2\", NULL);\n\n\tocfs2_set_locking_protocol();\n\n\tstatus = register_quota_format(&ocfs2_quota_format);\n\tif (status < 0)\n\t\tgoto out3;\n\tstatus = register_filesystem(&ocfs2_fs_type);\n\tif (!status)\n\t\treturn 0;\n\n\tunregister_quota_format(&ocfs2_quota_format);\nout3:\n\tdebugfs_remove(ocfs2_debugfs_root);\n\tocfs2_free_mem_caches();\nout2:\n\texit_ocfs2_uptodate_cache();\nout1:\n\tmlog_errno(status);\n\treturn status;\n}\n\nstatic void __exit ocfs2_exit(void)\n{\n\tunregister_quota_format(&ocfs2_quota_format);\n\n\tdebugfs_remove(ocfs2_debugfs_root);\n\n\tocfs2_free_mem_caches();\n\n\tunregister_filesystem(&ocfs2_fs_type);\n\n\texit_ocfs2_uptodate_cache();\n}\n\nstatic void ocfs2_put_super(struct super_block *sb)\n{\n\ttrace_ocfs2_put_super(sb);\n\n\tocfs2_sync_blockdev(sb);\n\tocfs2_dismount_volume(sb, 0);\n}\n\nstatic int ocfs2_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct ocfs2_super *osb;\n\tu32 numbits, freebits;\n\tint status;\n\tstruct ocfs2_dinode *bm_lock;\n\tstruct buffer_head *bh = NULL;\n\tstruct inode *inode = NULL;\n\n\ttrace_ocfs2_statfs(dentry->d_sb, buf);\n\n\tosb = OCFS2_SB(dentry->d_sb);\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!inode) {\n\t\tmlog(ML_ERROR, \"failed to get bitmap inode\\n\");\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_inode_lock(inode, &bh, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tbm_lock = (struct ocfs2_dinode *) bh->b_data;\n\n\tnumbits = le32_to_cpu(bm_lock->id1.bitmap1.i_total);\n\tfreebits = numbits - le32_to_cpu(bm_lock->id1.bitmap1.i_used);\n\n\tbuf->f_type = OCFS2_SUPER_MAGIC;\n\tbuf->f_bsize = dentry->d_sb->s_blocksize;\n\tbuf->f_namelen = OCFS2_MAX_FILENAME_LEN;\n\tbuf->f_blocks = ((sector_t) numbits) *\n\t\t\t(osb->s_clustersize >> osb->sb->s_blocksize_bits);\n\tbuf->f_bfree = ((sector_t) freebits) *\n\t\t       (osb->s_clustersize >> osb->sb->s_blocksize_bits);\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_files = numbits;\n\tbuf->f_ffree = freebits;\n\tbuf->f_fsid.val[0] = crc32_le(0, osb->uuid_str, OCFS2_VOL_UUID_LEN)\n\t\t\t\t& 0xFFFFFFFFUL;\n\tbuf->f_fsid.val[1] = crc32_le(0, osb->uuid_str + OCFS2_VOL_UUID_LEN,\n\t\t\t\tOCFS2_VOL_UUID_LEN) & 0xFFFFFFFFUL;\n\n\tbrelse(bh);\n\n\tocfs2_inode_unlock(inode, 0);\n\tstatus = 0;\nbail:\n\tiput(inode);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}\n\nstatic void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\tINIT_LIST_HEAD(&oi->ip_unwritten_list);\n\toi->ip_dir_start_lookup = 0;\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\toi->ip_next_orphan = NULL;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}\n\nstatic int ocfs2_initialize_mem_caches(void)\n{\n\tocfs2_inode_cachep = kmem_cache_create(\"ocfs2_inode_cache\",\n\t\t\t\t       sizeof(struct ocfs2_inode_info),\n\t\t\t\t       0,\n\t\t\t\t       (SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t       ocfs2_inode_init_once);\n\tocfs2_dquot_cachep = kmem_cache_create(\"ocfs2_dquot_cache\",\n\t\t\t\t\tsizeof(struct ocfs2_dquot),\n\t\t\t\t\t0,\n\t\t\t\t\t(SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\tNULL);\n\tocfs2_qf_chunk_cachep = kmem_cache_create(\"ocfs2_qf_chunk_cache\",\n\t\t\t\t\tsizeof(struct ocfs2_quota_chunk),\n\t\t\t\t\t0,\n\t\t\t\t\t(SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD),\n\t\t\t\t\tNULL);\n\tif (!ocfs2_inode_cachep || !ocfs2_dquot_cachep ||\n\t    !ocfs2_qf_chunk_cachep) {\n\t\tkmem_cache_destroy(ocfs2_inode_cachep);\n\t\tkmem_cache_destroy(ocfs2_dquot_cachep);\n\t\tkmem_cache_destroy(ocfs2_qf_chunk_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void ocfs2_free_mem_caches(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(ocfs2_inode_cachep);\n\tocfs2_inode_cachep = NULL;\n\n\tkmem_cache_destroy(ocfs2_dquot_cachep);\n\tocfs2_dquot_cachep = NULL;\n\n\tkmem_cache_destroy(ocfs2_qf_chunk_cachep);\n\tocfs2_qf_chunk_cachep = NULL;\n}\n\nstatic int ocfs2_get_sector(struct super_block *sb,\n\t\t\t    struct buffer_head **bh,\n\t\t\t    int block,\n\t\t\t    int sect_size)\n{\n\tif (!sb_set_blocksize(sb, sect_size)) {\n\t\tmlog(ML_ERROR, \"unable to set blocksize\\n\");\n\t\treturn -EIO;\n\t}\n\n\t*bh = sb_getblk(sb, block);\n\tif (!*bh) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\tlock_buffer(*bh);\n\tif (!buffer_dirty(*bh))\n\t\tclear_buffer_uptodate(*bh);\n\tunlock_buffer(*bh);\n\tif (bh_read(*bh, 0) < 0) {\n\t\tmlog_errno(-EIO);\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int ocfs2_mount_volume(struct super_block *sb)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\tgoto out;\n\n\tmutex_init(&osb->obs_trim_fs_mutex);\n\n\tstatus = ocfs2_dlm_init(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tif (status == -EBADR && ocfs2_userspace_stack(osb))\n\t\t\tmlog(ML_ERROR, \"couldn't mount because cluster name on\"\n\t\t\t\" disk does not match the running cluster name.\\n\");\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_super_lock(osb, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_dlm;\n\t}\n\n\t \n\tstatus = ocfs2_find_slot(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_super_lock;\n\t}\n\n\t \n\tstatus = ocfs2_init_local_system_inodes(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_super_lock;\n\t}\n\n\tstatus = ocfs2_check_volume(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_system_inodes;\n\t}\n\n\tstatus = ocfs2_truncate_log_init(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_check_volume;\n\t}\n\n\tocfs2_super_unlock(osb, 1);\n\treturn 0;\n\nout_check_volume:\n\tocfs2_free_replay_slots(osb);\nout_system_inodes:\n\tif (osb->local_alloc_state == OCFS2_LA_ENABLED)\n\t\tocfs2_shutdown_local_alloc(osb);\n\tocfs2_release_system_inodes(osb);\n\t \n\tocfs2_free_slot_info(osb);\n\tocfs2_journal_shutdown(osb);\nout_super_lock:\n\tocfs2_super_unlock(osb, 1);\nout_dlm:\n\tocfs2_dlm_shutdown(osb, 0);\nout:\n\treturn status;\n}\n\nstatic void ocfs2_dismount_volume(struct super_block *sb, int mnt_err)\n{\n\tint tmp, hangup_needed = 0;\n\tstruct ocfs2_super *osb = NULL;\n\tchar nodestr[12];\n\n\ttrace_ocfs2_dismount_volume(sb);\n\n\tBUG_ON(!sb);\n\tosb = OCFS2_SB(sb);\n\tBUG_ON(!osb);\n\n\t \n\tocfs2_filecheck_remove_sysfs(osb);\n\n\tkset_unregister(osb->osb_dev_kset);\n\n\t \n\tocfs2_orphan_scan_stop(osb);\n\n\tocfs2_disable_quotas(osb);\n\n\t \n\tWARN_ON(!llist_empty(&osb->dquot_drop_list));\n\t \n\tcancel_work_sync(&osb->dquot_drop_work);\n\n\tocfs2_shutdown_local_alloc(osb);\n\n\tocfs2_truncate_log_shutdown(osb);\n\n\t \n\tocfs2_recovery_exit(osb);\n\n\tocfs2_sync_blockdev(sb);\n\n\tocfs2_purge_refcount_trees(osb);\n\n\t \n\tif (osb->cconn) {\n\t\ttmp = ocfs2_super_lock(osb, 1);\n\t\tif (tmp < 0) {\n\t\t\tmlog_errno(tmp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (osb->slot_num != OCFS2_INVALID_SLOT)\n\t\tocfs2_put_slot(osb);\n\n\tif (osb->cconn)\n\t\tocfs2_super_unlock(osb, 1);\n\n\tocfs2_release_system_inodes(osb);\n\n\tocfs2_journal_shutdown(osb);\n\n\t \n\tif (!mnt_err && !ocfs2_mount_local(osb) && osb->uuid_str &&\n\t    !ocfs2_is_hard_readonly(osb))\n\t\thangup_needed = 1;\n\n\tocfs2_dlm_shutdown(osb, hangup_needed);\n\n\tocfs2_blockcheck_stats_debugfs_remove(&osb->osb_ecc_stats);\n\tdebugfs_remove_recursive(osb->osb_debug_root);\n\n\tif (hangup_needed)\n\t\tocfs2_cluster_hangup(osb->uuid_str, strlen(osb->uuid_str));\n\n\tatomic_set(&osb->vol_state, VOLUME_DISMOUNTED);\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Unmounting device (%s) on (node %s)\\n\",\n\t       osb->dev_str, nodestr);\n\n\tocfs2_delete_osb(osb);\n\tkfree(osb);\n\tsb->s_dev = 0;\n\tsb->s_fs_info = NULL;\n}\n\nstatic int ocfs2_setup_osb_uuid(struct ocfs2_super *osb, const unsigned char *uuid,\n\t\t\t\tunsigned uuid_bytes)\n{\n\tint i, ret;\n\tchar *ptr;\n\n\tBUG_ON(uuid_bytes != OCFS2_VOL_UUID_LEN);\n\n\tosb->uuid_str = kzalloc(OCFS2_VOL_UUID_LEN * 2 + 1, GFP_KERNEL);\n\tif (osb->uuid_str == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, ptr = osb->uuid_str; i < OCFS2_VOL_UUID_LEN; i++) {\n\t\t \n\t\tret = snprintf(ptr, 3, \"%02X\", uuid[i]);\n\t\tif (ret != 2)  \n\t\t\treturn -EINVAL;\n\t\t \n\t\tptr += 2;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ocfs2_journal_addressable(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tu64 max_block =\n\t\tocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t osb->osb_clusters_at_boot) - 1;\n\n\t \n\tif (max_block <= (u32)~0ULL)\n\t\tgoto out;\n\n\t \n\tif (!(OCFS2_HAS_COMPAT_FEATURE(osb->sb,\n\t\t\t\t       OCFS2_FEATURE_COMPAT_JBD2_SB) &&\n\t      jbd2_journal_check_used_features(osb->journal->j_journal, 0, 0,\n\t\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT))) {\n\t\tmlog(ML_ERROR, \"The journal cannot address the entire volume. \"\n\t\t     \"Enable the 'block64' journal option with tunefs.ocfs2\");\n\t\tstatus = -EFBIG;\n\t\tgoto out;\n\t}\n\n out:\n\treturn status;\n}\n\nstatic int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats)\n{\n\tint status;\n\tint i, cbits, bbits;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_super *osb;\n\tu64 total_blocks;\n\n\tosb = kzalloc(sizeof(struct ocfs2_super), GFP_KERNEL);\n\tif (!osb) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tsb->s_fs_info = osb;\n\tsb->s_op = &ocfs2_sops;\n\tsb->s_d_op = &ocfs2_dentry_ops;\n\tsb->s_export_op = &ocfs2_export_ops;\n\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\tsb->dq_op = &ocfs2_quota_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n\tsb->s_xattr = ocfs2_xattr_handlers;\n\tsb->s_time_gran = 1;\n\tsb->s_flags |= SB_NOATIME;\n\t \n\tcbits = le32_to_cpu(di->id2.i_super.s_clustersize_bits);\n\tbbits = le32_to_cpu(di->id2.i_super.s_blocksize_bits);\n\tsb->s_maxbytes = ocfs2_max_file_offset(bbits, cbits);\n\tmemcpy(&sb->s_uuid, di->id2.i_super.s_uuid,\n\t       sizeof(di->id2.i_super.s_uuid));\n\n\tosb->osb_dx_mask = (1 << (cbits - bbits)) - 1;\n\n\tfor (i = 0; i < 3; i++)\n\t\tosb->osb_dx_seed[i] = le32_to_cpu(di->id2.i_super.s_dx_seed[i]);\n\tosb->osb_dx_seed[3] = le32_to_cpu(di->id2.i_super.s_uuid_hash);\n\n\tosb->sb = sb;\n\tosb->s_sectsize_bits = blksize_bits(sector_size);\n\tBUG_ON(!osb->s_sectsize_bits);\n\n\tspin_lock_init(&osb->dc_task_lock);\n\tinit_waitqueue_head(&osb->dc_event);\n\tosb->dc_work_sequence = 0;\n\tosb->dc_wake_sequence = 0;\n\tINIT_LIST_HEAD(&osb->blocked_lock_list);\n\tosb->blocked_lock_count = 0;\n\tspin_lock_init(&osb->osb_lock);\n\tspin_lock_init(&osb->osb_xattr_lock);\n\tocfs2_init_steal_slots(osb);\n\n\tmutex_init(&osb->system_file_mutex);\n\n\tatomic_set(&osb->alloc_stats.moves, 0);\n\tatomic_set(&osb->alloc_stats.local_data, 0);\n\tatomic_set(&osb->alloc_stats.bitmap_data, 0);\n\tatomic_set(&osb->alloc_stats.bg_allocs, 0);\n\tatomic_set(&osb->alloc_stats.bg_extends, 0);\n\n\t \n\tosb->osb_ecc_stats = *stats;\n\n\tocfs2_init_node_maps(osb);\n\n\tsnprintf(osb->dev_str, sizeof(osb->dev_str), \"%u,%u\",\n\t\t MAJOR(osb->sb->s_dev), MINOR(osb->sb->s_dev));\n\n\tosb->max_slots = le16_to_cpu(di->id2.i_super.s_max_slots);\n\tif (osb->max_slots > OCFS2_MAX_SLOTS || osb->max_slots == 0) {\n\t\tmlog(ML_ERROR, \"Invalid number of node slots (%u)\\n\",\n\t\t     osb->max_slots);\n\t\tstatus = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tocfs2_orphan_scan_init(osb);\n\n\tstatus = ocfs2_recovery_init(osb);\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Unable to initialize recovery state\\n\");\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tinit_waitqueue_head(&osb->checkpoint_event);\n\n\tosb->s_atime_quantum = OCFS2_DEFAULT_ATIME_QUANTUM;\n\n\tosb->slot_num = OCFS2_INVALID_SLOT;\n\n\tosb->s_xattr_inline_size = le16_to_cpu(\n\t\t\t\t\tdi->id2.i_super.s_xattr_inline_size);\n\n\tosb->local_alloc_state = OCFS2_LA_UNUSED;\n\tosb->local_alloc_bh = NULL;\n\tINIT_DELAYED_WORK(&osb->la_enable_wq, ocfs2_la_enable_worker);\n\n\tinit_waitqueue_head(&osb->osb_mount_event);\n\n\tocfs2_resmap_init(osb, &osb->osb_la_resmap);\n\n\tosb->vol_label = kmalloc(OCFS2_MAX_VOL_LABEL_LEN, GFP_KERNEL);\n\tif (!osb->vol_label) {\n\t\tmlog(ML_ERROR, \"unable to alloc vol label\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto out_recovery_map;\n\t}\n\n\tosb->slot_recovery_generations =\n\t\tkcalloc(osb->max_slots, sizeof(*osb->slot_recovery_generations),\n\t\t\tGFP_KERNEL);\n\tif (!osb->slot_recovery_generations) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_vol_label;\n\t}\n\n\tinit_waitqueue_head(&osb->osb_wipe_event);\n\tosb->osb_orphan_wipes = kcalloc(osb->max_slots,\n\t\t\t\t\tsizeof(*osb->osb_orphan_wipes),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!osb->osb_orphan_wipes) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_slot_recovery_gen;\n\t}\n\n\tosb->osb_rf_lock_tree = RB_ROOT;\n\n\tosb->s_feature_compat =\n\t\tle32_to_cpu(OCFS2_RAW_SB(di)->s_feature_compat);\n\tosb->s_feature_ro_compat =\n\t\tle32_to_cpu(OCFS2_RAW_SB(di)->s_feature_ro_compat);\n\tosb->s_feature_incompat =\n\t\tle32_to_cpu(OCFS2_RAW_SB(di)->s_feature_incompat);\n\n\tif ((i = OCFS2_HAS_INCOMPAT_FEATURE(osb->sb, ~OCFS2_FEATURE_INCOMPAT_SUPP))) {\n\t\tmlog(ML_ERROR, \"couldn't mount because of unsupported \"\n\t\t     \"optional features (%x).\\n\", i);\n\t\tstatus = -EINVAL;\n\t\tgoto out_orphan_wipes;\n\t}\n\tif (!sb_rdonly(osb->sb) && (i = OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, ~OCFS2_FEATURE_RO_COMPAT_SUPP))) {\n\t\tmlog(ML_ERROR, \"couldn't mount RDWR because of \"\n\t\t     \"unsupported optional features (%x).\\n\", i);\n\t\tstatus = -EINVAL;\n\t\tgoto out_orphan_wipes;\n\t}\n\n\tif (ocfs2_clusterinfo_valid(osb)) {\n\t\t \n\t\tosb->osb_stackflags =\n\t\t\tOCFS2_RAW_SB(di)->s_cluster_info.ci_stackflags;\n\t\tmemcpy(osb->osb_cluster_stack,\n\t\t       OCFS2_RAW_SB(di)->s_cluster_info.ci_stack,\n\t\t       OCFS2_STACK_LABEL_LEN);\n\t\tif (strlen(osb->osb_cluster_stack) != OCFS2_STACK_LABEL_LEN) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"couldn't mount because of an invalid \"\n\t\t\t     \"cluster stack label (%s) \\n\",\n\t\t\t     osb->osb_cluster_stack);\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto out_orphan_wipes;\n\t\t}\n\t\tmemcpy(osb->osb_cluster_name,\n\t\t\tOCFS2_RAW_SB(di)->s_cluster_info.ci_cluster,\n\t\t\tOCFS2_CLUSTER_NAME_LEN);\n\t} else {\n\t\t \n\t\tosb->osb_cluster_stack[0] = '\\0';\n\t}\n\n\tget_random_bytes(&osb->s_next_generation, sizeof(u32));\n\n\t \n\tstatus = ocfs2_journal_alloc(osb);\n\tif (status < 0)\n\t\tgoto out_orphan_wipes;\n\n\tINIT_WORK(&osb->dquot_drop_work, ocfs2_drop_dquot_refs);\n\tinit_llist_head(&osb->dquot_drop_list);\n\n\t \n\tosb->s_clustersize_bits =\n\t\tle32_to_cpu(di->id2.i_super.s_clustersize_bits);\n\tosb->s_clustersize = 1 << osb->s_clustersize_bits;\n\n\tif (osb->s_clustersize < OCFS2_MIN_CLUSTERSIZE ||\n\t    osb->s_clustersize > OCFS2_MAX_CLUSTERSIZE) {\n\t\tmlog(ML_ERROR, \"Volume has invalid cluster size (%d)\\n\",\n\t\t     osb->s_clustersize);\n\t\tstatus = -EINVAL;\n\t\tgoto out_journal;\n\t}\n\n\ttotal_blocks = ocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\tle32_to_cpu(di->i_clusters));\n\n\tstatus = generic_check_addressable(osb->sb->s_blocksize_bits,\n\t\t\t\t\t   total_blocks);\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Volume too large \"\n\t\t     \"to mount safely on this system\");\n\t\tstatus = -EFBIG;\n\t\tgoto out_journal;\n\t}\n\n\tif (ocfs2_setup_osb_uuid(osb, di->id2.i_super.s_uuid,\n\t\t\t\t sizeof(di->id2.i_super.s_uuid))) {\n\t\tmlog(ML_ERROR, \"Out of memory trying to setup our uuid.\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto out_journal;\n\t}\n\n\tstrscpy(osb->vol_label, di->id2.i_super.s_label,\n\t\tOCFS2_MAX_VOL_LABEL_LEN);\n\tosb->root_blkno = le64_to_cpu(di->id2.i_super.s_root_blkno);\n\tosb->system_dir_blkno = le64_to_cpu(di->id2.i_super.s_system_dir_blkno);\n\tosb->first_cluster_group_blkno =\n\t\tle64_to_cpu(di->id2.i_super.s_first_cluster_group);\n\tosb->fs_generation = le32_to_cpu(di->i_fs_generation);\n\tosb->uuid_hash = le32_to_cpu(di->id2.i_super.s_uuid_hash);\n\ttrace_ocfs2_initialize_super(osb->vol_label, osb->uuid_str,\n\t\t\t\t     (unsigned long long)osb->root_blkno,\n\t\t\t\t     (unsigned long long)osb->system_dir_blkno,\n\t\t\t\t     osb->s_clustersize_bits);\n\n\tosb->osb_dlm_debug = ocfs2_new_dlm_debug();\n\tif (!osb->osb_dlm_debug) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_uuid_str;\n\t}\n\n\tatomic_set(&osb->vol_state, VOLUME_INIT);\n\n\t \n\tstatus = ocfs2_init_global_system_inodes(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_dlm_out;\n\t}\n\n\t \n\tinode = ocfs2_get_system_file_inode(osb, GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto out_system_inodes;\n\t}\n\n\tosb->bitmap_blkno = OCFS2_I(inode)->ip_blkno;\n\tosb->osb_clusters_at_boot = OCFS2_I(inode)->ip_clusters;\n\tiput(inode);\n\n\tosb->bitmap_cpg = ocfs2_group_bitmap_size(sb, 0,\n\t\t\t\t osb->s_feature_incompat) * 8;\n\n\tstatus = ocfs2_init_slot_info(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_system_inodes;\n\t}\n\n\tosb->ocfs2_wq = alloc_ordered_workqueue(\"ocfs2_wq\", WQ_MEM_RECLAIM);\n\tif (!osb->ocfs2_wq) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_slot_info;\n\t}\n\n\treturn status;\n\nout_slot_info:\n\tocfs2_free_slot_info(osb);\nout_system_inodes:\n\tocfs2_release_system_inodes(osb);\nout_dlm_out:\n\tocfs2_put_dlm_debug(osb->osb_dlm_debug);\nout_uuid_str:\n\tkfree(osb->uuid_str);\nout_journal:\n\tkfree(osb->journal);\nout_orphan_wipes:\n\tkfree(osb->osb_orphan_wipes);\nout_slot_recovery_gen:\n\tkfree(osb->slot_recovery_generations);\nout_vol_label:\n\tkfree(osb->vol_label);\nout_recovery_map:\n\tkfree(osb->recovery_map);\nout:\n\tkfree(osb);\n\tsb->s_fs_info = NULL;\n\treturn status;\n}\n\n \nstatic int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 blksz,\n\t\t\t       struct ocfs2_blockcheck_stats *stats)\n{\n\tint status = -EAGAIN;\n\n\tif (memcmp(di->i_signature, OCFS2_SUPER_BLOCK_SIGNATURE,\n\t\t   strlen(OCFS2_SUPER_BLOCK_SIGNATURE)) == 0) {\n\t\t \n\t\tif (le32_to_cpu(di->id2.i_super.s_feature_incompat) &\n\t\t    OCFS2_FEATURE_INCOMPAT_META_ECC) {\n\t\t\tstatus = ocfs2_block_check_validate(bh->b_data,\n\t\t\t\t\t\t\t    bh->b_size,\n\t\t\t\t\t\t\t    &di->i_check,\n\t\t\t\t\t\t\t    stats);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t\tstatus = -EINVAL;\n\t\tif ((1 << le32_to_cpu(di->id2.i_super.s_blocksize_bits)) != blksz) {\n\t\t\tmlog(ML_ERROR, \"found superblock with incorrect block \"\n\t\t\t     \"size: found %u, should be %u\\n\",\n\t\t\t     1 << le32_to_cpu(di->id2.i_super.s_blocksize_bits),\n\t\t\t       blksz);\n\t\t} else if (le16_to_cpu(di->id2.i_super.s_major_rev_level) !=\n\t\t\t   OCFS2_MAJOR_REV_LEVEL ||\n\t\t\t   le16_to_cpu(di->id2.i_super.s_minor_rev_level) !=\n\t\t\t   OCFS2_MINOR_REV_LEVEL) {\n\t\t\tmlog(ML_ERROR, \"found superblock with bad version: \"\n\t\t\t     \"found %u.%u, should be %u.%u\\n\",\n\t\t\t     le16_to_cpu(di->id2.i_super.s_major_rev_level),\n\t\t\t     le16_to_cpu(di->id2.i_super.s_minor_rev_level),\n\t\t\t     OCFS2_MAJOR_REV_LEVEL,\n\t\t\t     OCFS2_MINOR_REV_LEVEL);\n\t\t} else if (bh->b_blocknr != le64_to_cpu(di->i_blkno)) {\n\t\t\tmlog(ML_ERROR, \"bad block number on superblock: \"\n\t\t\t     \"found %llu, should be %llu\\n\",\n\t\t\t     (unsigned long long)le64_to_cpu(di->i_blkno),\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t} else if (le32_to_cpu(di->id2.i_super.s_clustersize_bits) < 12 ||\n\t\t\t    le32_to_cpu(di->id2.i_super.s_clustersize_bits) > 20) {\n\t\t\tmlog(ML_ERROR, \"bad cluster size found: %u\\n\",\n\t\t\t     1 << le32_to_cpu(di->id2.i_super.s_clustersize_bits));\n\t\t} else if (!le64_to_cpu(di->id2.i_super.s_root_blkno)) {\n\t\t\tmlog(ML_ERROR, \"bad root_blkno: 0\\n\");\n\t\t} else if (!le64_to_cpu(di->id2.i_super.s_system_dir_blkno)) {\n\t\t\tmlog(ML_ERROR, \"bad system_dir_blkno: 0\\n\");\n\t\t} else if (le16_to_cpu(di->id2.i_super.s_max_slots) > OCFS2_MAX_SLOTS) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Superblock slots found greater than file system \"\n\t\t\t     \"maximum: found %u, max %u\\n\",\n\t\t\t     le16_to_cpu(di->id2.i_super.s_max_slots),\n\t\t\t     OCFS2_MAX_SLOTS);\n\t\t} else {\n\t\t\t \n\t\t\tstatus = 0;\n\t\t}\n\t}\n\nout:\n\tif (status && status != -EAGAIN)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\nstatic int ocfs2_check_volume(struct ocfs2_super *osb)\n{\n\tint status;\n\tint dirty;\n\tint local;\n\tstruct ocfs2_dinode *local_alloc = NULL;  \n\n\t \n\tstatus = ocfs2_journal_init(osb, &dirty);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"Could not initialize journal!\\n\");\n\t\tgoto finally;\n\t}\n\n\t \n\tstatus = ocfs2_journal_addressable(osb);\n\tif (status)\n\t\tgoto finally;\n\n\t \n\tif (!dirty) {\n\t\tstatus = ocfs2_journal_wipe(osb->journal, 0);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto finally;\n\t\t}\n\t} else {\n\t\tprintk(KERN_NOTICE \"ocfs2: File system on device (%s) was not \"\n\t\t       \"unmounted cleanly, recovering it.\\n\", osb->dev_str);\n\t}\n\n\tlocal = ocfs2_mount_local(osb);\n\n\t \n\tstatus = ocfs2_journal_load(osb->journal, local, dirty);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"ocfs2 journal load failed! %d\\n\", status);\n\t\tgoto finally;\n\t}\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_JOURNAL_ASYNC_COMMIT)\n\t\tjbd2_journal_set_features(osb->journal->j_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\telse\n\t\tjbd2_journal_clear_features(osb->journal->j_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\n\tif (dirty) {\n\t\t \n\t\tstatus = ocfs2_begin_local_alloc_recovery(osb,\n\t\t\t\t\t\t\t  osb->slot_num,\n\t\t\t\t\t\t\t  &local_alloc);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto finally;\n\t\t}\n\t\t \n\t}\n\n\tstatus = ocfs2_load_local_alloc(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto finally;\n\t}\n\n\tif (dirty) {\n\t\t \n\t\tosb->local_alloc_copy = local_alloc;\n\t\tlocal_alloc = NULL;\n\t}\n\n\t \n\tstatus = ocfs2_mark_dead_nodes(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto finally;\n\t}\n\n\tstatus = ocfs2_compute_replay_slots(osb);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nfinally:\n\tkfree(local_alloc);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\n \nstatic void ocfs2_delete_osb(struct ocfs2_super *osb)\n{\n\t \n\n\t \n\tif (osb->ocfs2_wq)\n\t\tdestroy_workqueue(osb->ocfs2_wq);\n\n\tocfs2_free_slot_info(osb);\n\n\tkfree(osb->osb_orphan_wipes);\n\tkfree(osb->slot_recovery_generations);\n\t \n\tkfree(osb->journal);\n\tkfree(osb->local_alloc_copy);\n\tkfree(osb->uuid_str);\n\tkfree(osb->vol_label);\n\tocfs2_put_dlm_debug(osb->osb_dlm_debug);\n\tmemset(osb, 0, sizeof(struct ocfs2_super));\n}\n\n \nstatic int ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tint rv = 0;\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\tpr_crit(\"On-disk corruption discovered. \"\n\t\t\"Please run fsck.ocfs2 once the filesystem is unmounted.\\n\");\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC) {\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\t} else if (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_CONT) {\n\t\tpr_crit(\"OCFS2: Returning error to the calling process.\\n\");\n\t\trv = -EIO;\n\t} else {  \n\t\trv = -EROFS;\n\t\tif (sb_rdonly(sb) && (ocfs2_is_soft_readonly(osb) || ocfs2_is_hard_readonly(osb)))\n\t\t\treturn rv;\n\n\t\tpr_crit(\"OCFS2: File system is now read-only.\\n\");\n\t\tsb->s_flags |= SB_RDONLY;\n\t\tocfs2_set_ro_flag(osb, 0);\n\t}\n\n\treturn rv;\n}\n\nint __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t \n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}\n\n \nvoid __ocfs2_abort(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"OCFS2: abort (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\t \n\n\t \n\tif (!ocfs2_mount_local(OCFS2_SB(sb)))\n\t\tOCFS2_SB(sb)->s_mount_opt |= OCFS2_MOUNT_ERRORS_PANIC;\n\tocfs2_handle_error(sb);\n}\n\n \nvoid ocfs2_block_signals(sigset_t *oldset)\n{\n\tint rc;\n\tsigset_t blocked;\n\n\tsigfillset(&blocked);\n\trc = sigprocmask(SIG_BLOCK, &blocked, oldset);\n\tBUG_ON(rc);\n}\n\nvoid ocfs2_unblock_signals(sigset_t *oldset)\n{\n\tint rc = sigprocmask(SIG_SETMASK, oldset, NULL);\n\tBUG_ON(rc);\n}\n\nmodule_init(ocfs2_init);\nmodule_exit(ocfs2_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}