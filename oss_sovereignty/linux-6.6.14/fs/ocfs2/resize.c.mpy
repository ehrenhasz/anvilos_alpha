{
  "module_name": "resize.c",
  "hash_id": "1997da8ca127d56b34ecb4059a2176f8aa7963dcaffb02ae02f02bc065a5e30d",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/resize.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/types.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"alloc.h\"\n#include \"dlmglue.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"super.h\"\n#include \"sysfile.h\"\n#include \"uptodate.h\"\n#include \"ocfs2_trace.h\"\n\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"resize.h\"\n\n \nstatic u16 ocfs2_calc_new_backup_super(struct inode *inode,\n\t\t\t\t       struct ocfs2_group_desc *gd,\n\t\t\t\t       u16 cl_cpg,\n\t\t\t\t       u16 old_bg_clusters,\n\t\t\t\t       int set)\n{\n\tint i;\n\tu16 backups = 0;\n\tu32 cluster, lgd_cluster;\n\tu64 blkno, gd_blkno, lgd_blkno = le64_to_cpu(gd->bg_blkno);\n\n\tfor (i = 0; i < OCFS2_MAX_BACKUP_SUPERBLOCKS; i++) {\n\t\tblkno = ocfs2_backup_super_blkno(inode->i_sb, i);\n\t\tcluster = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\n\t\tgd_blkno = ocfs2_which_cluster_group(inode, cluster);\n\t\tif (gd_blkno < lgd_blkno)\n\t\t\tcontinue;\n\t\telse if (gd_blkno > lgd_blkno)\n\t\t\tbreak;\n\n\t\t \n\t\tlgd_cluster = ocfs2_blocks_to_clusters(inode->i_sb, lgd_blkno);\n\t\tlgd_cluster += old_bg_clusters;\n\t\tif (lgd_cluster >= cluster)\n\t\t\tcontinue;\n\n\t\tif (set)\n\t\t\tocfs2_set_bit(cluster % cl_cpg,\n\t\t\t\t      (unsigned long *)gd->bg_bitmap);\n\t\telse\n\t\t\tocfs2_clear_bit(cluster % cl_cpg,\n\t\t\t\t\t(unsigned long *)gd->bg_bitmap);\n\t\tbackups++;\n\t}\n\n\treturn backups;\n}\n\nstatic int ocfs2_update_last_group_and_inode(handle_t *handle,\n\t\t\t\t\t     struct inode *bm_inode,\n\t\t\t\t\t     struct buffer_head *bm_bh,\n\t\t\t\t\t     struct buffer_head *group_bh,\n\t\t\t\t\t     u32 first_new_cluster,\n\t\t\t\t\t     int new_clusters)\n{\n\tint ret = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(bm_inode->i_sb);\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bm_bh->b_data;\n\tstruct ocfs2_chain_list *cl = &fe->id2.i_chain;\n\tstruct ocfs2_chain_rec *cr;\n\tstruct ocfs2_group_desc *group;\n\tu16 chain, num_bits, backups = 0;\n\tu16 cl_bpc = le16_to_cpu(cl->cl_bpc);\n\tu16 cl_cpg = le16_to_cpu(cl->cl_cpg);\n\tu16 old_bg_clusters;\n\n\ttrace_ocfs2_update_last_group_and_inode(new_clusters,\n\t\t\t\t\t\tfirst_new_cluster);\n\n\tret = ocfs2_journal_access_gd(handle, INODE_CACHE(bm_inode),\n\t\t\t\t      group_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tgroup = (struct ocfs2_group_desc *)group_bh->b_data;\n\n\told_bg_clusters = le16_to_cpu(group->bg_bits) / cl_bpc;\n\t \n\tnum_bits = new_clusters * cl_bpc;\n\tle16_add_cpu(&group->bg_bits, num_bits);\n\tle16_add_cpu(&group->bg_free_bits_count, num_bits);\n\n\t \n\tif (OCFS2_HAS_COMPAT_FEATURE(osb->sb,\n\t\t\t\t     OCFS2_FEATURE_COMPAT_BACKUP_SB)) {\n\t\tbackups = ocfs2_calc_new_backup_super(bm_inode,\n\t\t\t\t\t\t     group,\n\t\t\t\t\t\t     cl_cpg, old_bg_clusters, 1);\n\t\tle16_add_cpu(&group->bg_free_bits_count, -1 * backups);\n\t}\n\n\tocfs2_journal_dirty(handle, group_bh);\n\n\t \n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(bm_inode), bm_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_rollback;\n\t}\n\n\tchain = le16_to_cpu(group->bg_chain);\n\tcr = (&cl->cl_recs[chain]);\n\tle32_add_cpu(&cr->c_total, num_bits);\n\tle32_add_cpu(&cr->c_free, num_bits);\n\tle32_add_cpu(&fe->id1.bitmap1.i_total, num_bits);\n\tle32_add_cpu(&fe->i_clusters, new_clusters);\n\n\tif (backups) {\n\t\tle32_add_cpu(&cr->c_free, -1 * backups);\n\t\tle32_add_cpu(&fe->id1.bitmap1.i_used, backups);\n\t}\n\n\tspin_lock(&OCFS2_I(bm_inode)->ip_lock);\n\tOCFS2_I(bm_inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tle64_add_cpu(&fe->i_size, (u64)new_clusters << osb->s_clustersize_bits);\n\tspin_unlock(&OCFS2_I(bm_inode)->ip_lock);\n\ti_size_write(bm_inode, le64_to_cpu(fe->i_size));\n\n\tocfs2_journal_dirty(handle, bm_bh);\n\nout_rollback:\n\tif (ret < 0) {\n\t\tocfs2_calc_new_backup_super(bm_inode,\n\t\t\t\t\t    group,\n\t\t\t\t\t    cl_cpg, old_bg_clusters, 0);\n\t\tle16_add_cpu(&group->bg_free_bits_count, backups);\n\t\tle16_add_cpu(&group->bg_bits, -1 * num_bits);\n\t\tle16_add_cpu(&group->bg_free_bits_count, -1 * num_bits);\n\t}\nout:\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}\n\nstatic int update_backups(struct inode * inode, u32 clusters, char *data)\n{\n\tint i, ret = 0;\n\tu32 cluster;\n\tu64 blkno;\n\tstruct buffer_head *backup = NULL;\n\tstruct ocfs2_dinode *backup_di = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t \n\tfor (i = 0; i < OCFS2_MAX_BACKUP_SUPERBLOCKS; i++) {\n\t\tblkno = ocfs2_backup_super_blkno(inode->i_sb, i);\n\t\tcluster = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\t\tif (cluster >= clusters)\n\t\t\tbreak;\n\n\t\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &backup);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(backup->b_data, data, inode->i_sb->s_blocksize);\n\n\t\tbackup_di = (struct ocfs2_dinode *)backup->b_data;\n\t\tbackup_di->i_blkno = cpu_to_le64(blkno);\n\n\t\tret = ocfs2_write_super_or_backup(osb, backup);\n\t\tbrelse(backup);\n\t\tbackup = NULL;\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void ocfs2_update_super_and_backups(struct inode *inode,\n\t\t\t\t\t   int new_clusters)\n{\n\tint ret;\n\tu32 clusters = 0;\n\tstruct buffer_head *super_bh = NULL;\n\tstruct ocfs2_dinode *super_di = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t \n\tret = ocfs2_read_blocks_sync(osb, OCFS2_SUPER_BLOCK_BLKNO, 1,\n\t\t\t\t     &super_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tsuper_di = (struct ocfs2_dinode *)super_bh->b_data;\n\tle32_add_cpu(&super_di->i_clusters, new_clusters);\n\tclusters = le32_to_cpu(super_di->i_clusters);\n\n\tret = ocfs2_write_super_or_backup(osb, super_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_HAS_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_COMPAT_BACKUP_SB))\n\t\tret = update_backups(inode, clusters, super_bh->b_data);\n\nout:\n\tbrelse(super_bh);\n\tif (ret)\n\t\tprintk(KERN_WARNING \"ocfs2: Failed to update super blocks on %s\"\n\t\t\t\" during fs resize. This condition is not fatal,\"\n\t\t\t\" but fsck.ocfs2 should be run to fix it\\n\",\n\t\t\tosb->dev_str);\n\treturn;\n}\n\n \nint ocfs2_group_extend(struct inode * inode, int new_clusters)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_group_desc *group = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu16 cl_bpc;\n\tu32 first_new_cluster;\n\tu64 lgd_blkno;\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (new_clusters < 0)\n\t\treturn -EINVAL;\n\telse if (new_clusters == 0)\n\t\treturn 0;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tinode_lock(main_bm_inode);\n\n\tret = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\tfe = (struct ocfs2_dinode *)main_bm_bh->b_data;\n\n\t \n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (le16_to_cpu(fe->id2.i_chain.cl_cpg) !=\n\t\tocfs2_group_bitmap_size(osb->sb, 0,\n\t\t\t\t\tosb->s_feature_incompat) * 8) {\n\t\tmlog(ML_ERROR, \"The disk is too old and small. \"\n\t\t     \"Force to do offline resize.\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tfirst_new_cluster = le32_to_cpu(fe->i_clusters);\n\tlgd_blkno = ocfs2_which_cluster_group(main_bm_inode,\n\t\t\t\t\t      first_new_cluster - 1);\n\n\tret = ocfs2_read_group_descriptor(main_bm_inode, fe, lgd_blkno,\n\t\t\t\t\t  &group_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\tgroup = (struct ocfs2_group_desc *)group_bh->b_data;\n\n\tcl_bpc = le16_to_cpu(fe->id2.i_chain.cl_bpc);\n\tif (le16_to_cpu(group->bg_bits) / cl_bpc + new_clusters >\n\t\tle16_to_cpu(fe->id2.i_chain.cl_cpg)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\n\ttrace_ocfs2_group_extend(\n\t     (unsigned long long)le64_to_cpu(group->bg_blkno), new_clusters);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_GROUP_EXTEND_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tmlog_errno(PTR_ERR(handle));\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tret = ocfs2_update_last_group_and_inode(handle, main_bm_inode,\n\t\t\t\t\t\tmain_bm_bh, group_bh,\n\t\t\t\t\t\tfirst_new_cluster,\n\t\t\t\t\t\tnew_clusters);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_update_super_and_backups(main_bm_inode, new_clusters);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout_unlock:\n\tbrelse(group_bh);\n\tbrelse(main_bm_bh);\n\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tinode_unlock(main_bm_inode);\n\tiput(main_bm_inode);\n\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_check_new_group(struct inode *inode,\n\t\t\t\t struct ocfs2_dinode *di,\n\t\t\t\t struct ocfs2_new_group_input *input,\n\t\t\t\t struct buffer_head *group_bh)\n{\n\tint ret;\n\tstruct ocfs2_group_desc *gd =\n\t\t(struct ocfs2_group_desc *)group_bh->b_data;\n\tu16 cl_bpc = le16_to_cpu(di->id2.i_chain.cl_bpc);\n\n\tret = ocfs2_check_group_descriptor(inode->i_sb, di, group_bh);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (le16_to_cpu(gd->bg_chain) != input->chain)\n\t\tmlog(ML_ERROR, \"Group descriptor # %llu has bad chain %u \"\n\t\t     \"while input has %u set.\\n\",\n\t\t     (unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t     le16_to_cpu(gd->bg_chain), input->chain);\n\telse if (le16_to_cpu(gd->bg_bits) != input->clusters * cl_bpc)\n\t\tmlog(ML_ERROR, \"Group descriptor # %llu has bit count %u but \"\n\t\t     \"input has %u clusters set\\n\",\n\t\t     (unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t     le16_to_cpu(gd->bg_bits), input->clusters);\n\telse if (le16_to_cpu(gd->bg_free_bits_count) != input->frees * cl_bpc)\n\t\tmlog(ML_ERROR, \"Group descriptor # %llu has free bit count %u \"\n\t\t     \"but it should have %u set\\n\",\n\t\t     (unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t     le16_to_cpu(gd->bg_bits),\n\t\t     input->frees * cl_bpc);\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_verify_group_and_input(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_new_group_input *input,\n\t\t\t\t\tstruct buffer_head *group_bh)\n{\n\tu16 cl_count = le16_to_cpu(di->id2.i_chain.cl_count);\n\tu16 cl_cpg = le16_to_cpu(di->id2.i_chain.cl_cpg);\n\tu16 next_free = le16_to_cpu(di->id2.i_chain.cl_next_free_rec);\n\tu32 cluster = ocfs2_blocks_to_clusters(inode->i_sb, input->group);\n\tu32 total_clusters = le32_to_cpu(di->i_clusters);\n\tint ret = -EINVAL;\n\n\tif (cluster < total_clusters)\n\t\tmlog(ML_ERROR, \"add a group which is in the current volume.\\n\");\n\telse if (input->chain >= cl_count)\n\t\tmlog(ML_ERROR, \"input chain exceeds the limit.\\n\");\n\telse if (next_free != cl_count && next_free != input->chain)\n\t\tmlog(ML_ERROR,\n\t\t     \"the add group should be in chain %u\\n\", next_free);\n\telse if (total_clusters + input->clusters < total_clusters)\n\t\tmlog(ML_ERROR, \"add group's clusters overflow.\\n\");\n\telse if (input->clusters > cl_cpg)\n\t\tmlog(ML_ERROR, \"the cluster exceeds the maximum of a group\\n\");\n\telse if (input->frees > input->clusters)\n\t\tmlog(ML_ERROR, \"the free cluster exceeds the total clusters\\n\");\n\telse if (total_clusters % cl_cpg != 0)\n\t\tmlog(ML_ERROR,\n\t\t     \"the last group isn't full. Use group extend first.\\n\");\n\telse if (input->group != ocfs2_which_cluster_group(inode, cluster))\n\t\tmlog(ML_ERROR, \"group blkno is invalid\\n\");\n\telse if ((ret = ocfs2_check_new_group(inode, di, input, group_bh)))\n\t\tmlog(ML_ERROR, \"group descriptor check failed.\\n\");\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}\n\n \nint ocfs2_group_add(struct inode *inode, struct ocfs2_new_group_input *input)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *group_bh = NULL;\n\tstruct ocfs2_group_desc *group = NULL;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_chain_rec *cr;\n\tu16 cl_bpc;\n\tu64 bg_ptr;\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tinode_lock(main_bm_inode);\n\n\tret = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\tfe = (struct ocfs2_dinode *)main_bm_bh->b_data;\n\n\tif (le16_to_cpu(fe->id2.i_chain.cl_cpg) !=\n\t\tocfs2_group_bitmap_size(osb->sb, 0,\n\t\t\t\t\tosb->s_feature_incompat) * 8) {\n\t\tmlog(ML_ERROR, \"The disk is too old and small.\"\n\t\t     \" Force to do offline resize.\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_read_blocks_sync(osb, input->group, 1, &group_bh);\n\tif (ret < 0) {\n\t\tmlog(ML_ERROR, \"Can't read the group descriptor # %llu \"\n\t\t     \"from the device.\", (unsigned long long)input->group);\n\t\tgoto out_unlock;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), group_bh);\n\n\tret = ocfs2_verify_group_and_input(main_bm_inode, fe, input, group_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_free_group_bh;\n\t}\n\n\ttrace_ocfs2_group_add((unsigned long long)input->group,\n\t\t\t       input->chain, input->clusters, input->frees);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_GROUP_ADD_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tmlog_errno(PTR_ERR(handle));\n\t\tret = -EINVAL;\n\t\tgoto out_free_group_bh;\n\t}\n\n\tcl_bpc = le16_to_cpu(fe->id2.i_chain.cl_bpc);\n\tcl = &fe->id2.i_chain;\n\tcr = &cl->cl_recs[input->chain];\n\n\tret = ocfs2_journal_access_gd(handle, INODE_CACHE(main_bm_inode),\n\t\t\t\t      group_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tgroup = (struct ocfs2_group_desc *)group_bh->b_data;\n\tbg_ptr = le64_to_cpu(group->bg_next_group);\n\tgroup->bg_next_group = cr->c_blkno;\n\tocfs2_journal_dirty(handle, group_bh);\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(main_bm_inode),\n\t\t\t\t      main_bm_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tgroup->bg_next_group = cpu_to_le64(bg_ptr);\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (input->chain == le16_to_cpu(cl->cl_next_free_rec)) {\n\t\tle16_add_cpu(&cl->cl_next_free_rec, 1);\n\t\tmemset(cr, 0, sizeof(struct ocfs2_chain_rec));\n\t}\n\n\tcr->c_blkno = cpu_to_le64(input->group);\n\tle32_add_cpu(&cr->c_total, input->clusters * cl_bpc);\n\tle32_add_cpu(&cr->c_free, input->frees * cl_bpc);\n\n\tle32_add_cpu(&fe->id1.bitmap1.i_total, input->clusters *cl_bpc);\n\tle32_add_cpu(&fe->id1.bitmap1.i_used,\n\t\t     (input->clusters - input->frees) * cl_bpc);\n\tle32_add_cpu(&fe->i_clusters, input->clusters);\n\n\tocfs2_journal_dirty(handle, main_bm_bh);\n\n\tspin_lock(&OCFS2_I(main_bm_inode)->ip_lock);\n\tOCFS2_I(main_bm_inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tle64_add_cpu(&fe->i_size, (u64)input->clusters << osb->s_clustersize_bits);\n\tspin_unlock(&OCFS2_I(main_bm_inode)->ip_lock);\n\ti_size_write(main_bm_inode, le64_to_cpu(fe->i_size));\n\n\tocfs2_update_super_and_backups(main_bm_inode, input->clusters);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_free_group_bh:\n\tbrelse(group_bh);\n\nout_unlock:\n\tbrelse(main_bm_bh);\n\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tinode_unlock(main_bm_inode);\n\tiput(main_bm_inode);\n\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}