{
  "module_name": "move_extents.c",
  "hash_id": "59cde591a89dff6c93954f4de340b61d9867abeb523843ee0adc0e49f26e1591",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/move_extents.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/mount.h>\n#include <linux/swap.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n#include \"ocfs2_ioctl.h\"\n\n#include \"alloc.h\"\n#include \"localalloc.h\"\n#include \"aops.h\"\n#include \"dlmglue.h\"\n#include \"extent_map.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"move_extents.h\"\n\nstruct ocfs2_move_extents_context {\n\tstruct inode *inode;\n\tstruct file *file;\n\tint auto_defrag;\n\tint partial;\n\tint credits;\n\tu32 new_phys_cpos;\n\tu32 clusters_moved;\n\tu64 refcount_loc;\n\tstruct ocfs2_move_extents *range;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_alloc_context *meta_ac;\n\tstruct ocfs2_alloc_context *data_ac;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n};\n\nstatic int __ocfs2_move_extent(handle_t *handle,\n\t\t\t       struct ocfs2_move_extents_context *context,\n\t\t\t       u32 cpos, u32 len, u32 p_cpos, u32 new_p_cpos,\n\t\t\t       int ext_flags)\n{\n\tint ret = 0, index;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_rec *rec, replace_rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tu64 ino = ocfs2_metadata_cache_owner(context->et.et_ci);\n\tu64 old_blkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cpos);\n\n\tret = ocfs2_duplicate_clusters_by_page(handle, inode, cpos,\n\t\t\t\t\t       p_cpos, new_p_cpos, len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmemset(&replace_rec, 0, sizeof(replace_rec));\n\treplace_rec.e_cpos = cpu_to_le32(cpos);\n\treplace_rec.e_leaf_clusters = cpu_to_le16(len);\n\treplace_rec.e_blkno = cpu_to_le64(ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t\t\t   new_p_cpos));\n\n\tpath = ocfs2_new_path_from_et(&context->et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(INODE_CACHE(inode), path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tret = ocfs2_error(inode->i_sb,\n\t\t\t\t  \"Inode %llu has an extent at cpos %u which can no longer be found\\n\",\n\t\t\t\t  (unsigned long long)ino, cpos);\n\t\tgoto out;\n\t}\n\n\trec = &el->l_recs[index];\n\n\tBUG_ON(ext_flags != rec->e_flags);\n\t \n\treplace_rec.e_flags = ext_flags & ~OCFS2_EXT_REFCOUNTED;\n\n\tret = ocfs2_split_extent(handle, &context->et, path, index,\n\t\t\t\t &replace_rec, context->meta_ac,\n\t\t\t\t &context->dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcontext->new_phys_cpos = new_p_cpos;\n\n\t \n\tif (old_blkno) {\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t old_blkno),\n\t\t\t\t\tlen, context->meta_ac,\n\t\t\t\t\t&context->dealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\told_blkno, len);\n\t}\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}\n\n \nstatic int ocfs2_lock_meta_allocator_move_extents(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tu32 clusters_to_move,\n\t\t\t\t\tu32 extents_to_split,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tint extra_blocks,\n\t\t\t\t\tint *credits)\n{\n\tint ret, num_free_extents;\n\tunsigned int max_recs_needed = 2 * extents_to_split + clusters_to_move;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tnum_free_extents = ocfs2_num_free_extents(et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed))\n\t\textra_blocks += ocfs2_extend_meta_needed(et->et_root_el);\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, extra_blocks, meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\n\t*credits += ocfs2_calc_extend_credits(osb->sb, et->et_root_el);\n\n\tmlog(0, \"reserve metadata_blocks: %d, data_clusters: %u, credits: %d\\n\",\n\t     extra_blocks, clusters_to_move, *credits);\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_defrag_extent(struct ocfs2_move_extents_context *context,\n\t\t\t       u32 cpos, u32 phys_cpos, u32 *len, int ext_flags)\n{\n\tint ret, credits = 0, extra_blocks = 0, partial = context->partial;\n\thandle_t *handle;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\tu32 new_phys_cpos, new_len;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\tint need_free = 0;\n\n\tif ((ext_flags & OCFS2_EXT_REFCOUNTED) && *len) {\n\t\tBUG_ON(!ocfs2_is_refcount_inode(inode));\n\t\tBUG_ON(!context->refcount_loc);\n\n\t\tret = ocfs2_lock_refcount_tree(osb, context->refcount_loc, 1,\n\t\t\t\t\t       &ref_tree, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\tcontext->refcount_loc,\n\t\t\t\t\t\t\tphys_blkno,\n\t\t\t\t\t\t\t*len,\n\t\t\t\t\t\t\t&credits,\n\t\t\t\t\t\t\t&extra_blocks);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_lock_meta_allocator_move_extents(inode, &context->et,\n\t\t\t\t\t\t*len, 1,\n\t\t\t\t\t\t&context->meta_ac,\n\t\t\t\t\t\textra_blocks, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\n\tinode_lock(tl_inode);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock_mutex;\n\t\t}\n\t}\n\n\t \n\tret = ocfs2_reserve_clusters(osb, *len, &context->data_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_mutex;\n\t}\n\n\tret = __ocfs2_claim_clusters(handle, context->data_ac, 1, *len,\n\t\t\t\t     &new_phys_cpos, &new_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t \n\tif (new_len != *len) {\n\t\tmlog(0, \"len_claimed: %u, len: %u\\n\", new_len, *len);\n\t\tif (!partial) {\n\t\t\tcontext->range->me_flags &= ~OCFS2_MOVE_EXT_FL_COMPLETE;\n\t\t\tret = -ENOSPC;\n\t\t\tneed_free = 1;\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\tmlog(0, \"cpos: %u, phys_cpos: %u, new_phys_cpos: %u\\n\", cpos,\n\t     phys_cpos, new_phys_cpos);\n\n\tret = __ocfs2_move_extent(handle, context, cpos, new_len, phys_cpos,\n\t\t\t\t  new_phys_cpos, ext_flags);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (partial && (new_len != *len))\n\t\t*len = new_len;\n\n\t \n\tret = ocfs2_cow_sync_writeback(inode->i_sb, context->inode, cpos, *len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tif (need_free && context->data_ac) {\n\t\tstruct ocfs2_alloc_context *data_ac = context->data_ac;\n\n\t\tif (context->data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tnew_phys_cpos, new_len);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, new_phys_cpos),\n\t\t\t\t\tnew_len);\n\t}\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock_mutex:\n\tinode_unlock(tl_inode);\n\n\tif (context->data_ac) {\n\t\tocfs2_free_alloc_context(context->data_ac);\n\t\tcontext->data_ac = NULL;\n\t}\n\n\tif (context->meta_ac) {\n\t\tocfs2_free_alloc_context(context->meta_ac);\n\t\tcontext->meta_ac = NULL;\n\t}\n\nout:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_find_victim_alloc_group(struct inode *inode,\n\t\t\t\t\t u64 vict_blkno,\n\t\t\t\t\t int type, int slot,\n\t\t\t\t\t int *vict_bit,\n\t\t\t\t\t struct buffer_head **ret_bh)\n{\n\tint ret, i, bits_per_unit = 0;\n\tu64 blkno;\n\tchar namebuf[40];\n\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *ac_bh = NULL, *gd_bh = NULL;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_chain_rec *rec;\n\tstruct ocfs2_dinode *ac_dinode;\n\tstruct ocfs2_group_desc *bg;\n\n\tocfs2_sprintf_system_inode_name(namebuf, sizeof(namebuf), type, slot);\n\tret = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t strlen(namebuf), &blkno);\n\tif (ret) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &ac_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tac_dinode = (struct ocfs2_dinode *)ac_bh->b_data;\n\tcl = &(ac_dinode->id2.i_chain);\n\trec = &(cl->cl_recs[0]);\n\n\tif (type == GLOBAL_BITMAP_SYSTEM_INODE)\n\t\tbits_per_unit = osb->s_clustersize_bits -\n\t\t\t\t\tinode->i_sb->s_blocksize_bits;\n\t \n\tif ((vict_blkno < le64_to_cpu(rec->c_blkno)) ||\n\t    (vict_blkno >= ((u64)le32_to_cpu(ac_dinode->id1.bitmap1.i_total) <<\n\t\t\t\tbits_per_unit))) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i++) {\n\n\t\trec = &(cl->cl_recs[i]);\n\t\tif (!rec)\n\t\t\tcontinue;\n\n\t\tbg = NULL;\n\n\t\tdo {\n\t\t\tif (!bg)\n\t\t\t\tblkno = le64_to_cpu(rec->c_blkno);\n\t\t\telse\n\t\t\t\tblkno = le64_to_cpu(bg->bg_next_group);\n\n\t\t\tif (gd_bh) {\n\t\t\t\tbrelse(gd_bh);\n\t\t\t\tgd_bh = NULL;\n\t\t\t}\n\n\t\t\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &gd_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbg = (struct ocfs2_group_desc *)gd_bh->b_data;\n\n\t\t\tif (vict_blkno < (le64_to_cpu(bg->bg_blkno) +\n\t\t\t\t\t\t(le16_to_cpu(bg->bg_bits) << bits_per_unit))) {\n\n\t\t\t\t*ret_bh = gd_bh;\n\t\t\t\t*vict_bit = (vict_blkno - blkno) >>\n\t\t\t\t\t\t\tbits_per_unit;\n\t\t\t\tmlog(0, \"find the victim group: #%llu, \"\n\t\t\t\t     \"total_bits: %u, vict_bit: %u\\n\",\n\t\t\t\t     blkno, le16_to_cpu(bg->bg_bits),\n\t\t\t\t     *vict_bit);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t} while (le64_to_cpu(bg->bg_next_group));\n\t}\n\n\tret = -EINVAL;\nout:\n\tbrelse(ac_bh);\n\n\t \n\treturn ret;\n}\n\n \nstatic int ocfs2_validate_and_adjust_move_goal(struct inode *inode,\n\t\t\t\t\t       struct ocfs2_move_extents *range)\n{\n\tint ret, goal_bit = 0;\n\n\tstruct buffer_head *gd_bh = NULL;\n\tstruct ocfs2_group_desc *bg;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint c_to_b = 1 << (osb->s_clustersize_bits -\n\t\t\t\t\tinode->i_sb->s_blocksize_bits);\n\n\t \n\trange->me_goal = ocfs2_block_to_cluster_start(inode->i_sb,\n\t\t\t\t\t\t      range->me_goal);\n\t \n\tret = ocfs2_find_victim_alloc_group(inode, range->me_goal,\n\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT,\n\t\t\t\t\t    &goal_bit, &gd_bh);\n\tif (ret)\n\t\tgoto out;\n\n\tbg = (struct ocfs2_group_desc *)gd_bh->b_data;\n\n\t \n\tif (range->me_goal == le64_to_cpu(bg->bg_blkno))\n\t\trange->me_goal += c_to_b;\n\n\t \n\tif ((le16_to_cpu(bg->bg_bits) - goal_bit) * osb->s_clustersize <\n\t\t\t\t\t\t\t\trange->me_len) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\t \n\tmlog(0, \"extents get ready to be moved to #%llu block\\n\",\n\t     range->me_goal);\n\nout:\n\tbrelse(gd_bh);\n\n\treturn ret;\n}\n\nstatic void ocfs2_probe_alloc_group(struct inode *inode, struct buffer_head *bh,\n\t\t\t\t    int *goal_bit, u32 move_len, u32 max_hop,\n\t\t\t\t    u32 *phys_cpos)\n{\n\tint i, used, last_free_bits = 0, base_bit = *goal_bit;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\tu32 base_cpos = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t le64_to_cpu(gd->bg_blkno));\n\n\tfor (i = base_bit; i < le16_to_cpu(gd->bg_bits); i++) {\n\n\t\tused = ocfs2_test_bit(i, (unsigned long *)gd->bg_bitmap);\n\t\tif (used) {\n\t\t\t \n\t\t\tif ((i - base_bit) > max_hop) {\n\t\t\t\t*phys_cpos = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (last_free_bits)\n\t\t\t\tlast_free_bits = 0;\n\n\t\t\tcontinue;\n\t\t} else\n\t\t\tlast_free_bits++;\n\n\t\tif (last_free_bits == move_len) {\n\t\t\ti -= move_len;\n\t\t\t*goal_bit = i;\n\t\t\t*phys_cpos = base_cpos + i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmlog(0, \"found phys_cpos: %u to fit the wanted moving.\\n\", *phys_cpos);\n}\n\nstatic int ocfs2_move_extent(struct ocfs2_move_extents_context *context,\n\t\t\t     u32 cpos, u32 phys_cpos, u32 *new_phys_cpos,\n\t\t\t     u32 len, int ext_flags)\n{\n\tint ret, credits = 0, extra_blocks = 0, goal_bit = 0;\n\thandle_t *handle;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *gb_inode = NULL;\n\tstruct buffer_head *gb_bh = NULL;\n\tstruct buffer_head *gd_bh = NULL;\n\tstruct ocfs2_group_desc *gd;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\tu32 move_max_hop = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    context->range->me_threshold);\n\tu64 phys_blkno, new_phys_blkno;\n\n\tphys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\n\tif ((ext_flags & OCFS2_EXT_REFCOUNTED) && len) {\n\t\tBUG_ON(!ocfs2_is_refcount_inode(inode));\n\t\tBUG_ON(!context->refcount_loc);\n\n\t\tret = ocfs2_lock_refcount_tree(osb, context->refcount_loc, 1,\n\t\t\t\t\t       &ref_tree, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\tcontext->refcount_loc,\n\t\t\t\t\t\t\tphys_blkno,\n\t\t\t\t\t\t\tlen,\n\t\t\t\t\t\t\t&credits,\n\t\t\t\t\t\t\t&extra_blocks);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_lock_meta_allocator_move_extents(inode, &context->et,\n\t\t\t\t\t\tlen, 1,\n\t\t\t\t\t\t&context->meta_ac,\n\t\t\t\t\t\textra_blocks, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tcredits += OCFS2_INODE_UPDATE_CREDITS + 1;\n\n\t \n\tgb_inode = ocfs2_get_system_file_inode(osb, GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!gb_inode) {\n\t\tmlog(ML_ERROR, \"unable to get global_bitmap inode\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tinode_lock(gb_inode);\n\n\tret = ocfs2_inode_lock(gb_inode, &gb_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_gb_mutex;\n\t}\n\n\tinode_lock(tl_inode);\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_tl_inode;\n\t}\n\n\tnew_phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, *new_phys_cpos);\n\tret = ocfs2_find_victim_alloc_group(inode, new_phys_blkno,\n\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT,\n\t\t\t\t\t    &goal_bit, &gd_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t \n\tocfs2_probe_alloc_group(inode, gd_bh, &goal_bit, len, move_max_hop,\n\t\t\t\tnew_phys_cpos);\n\tif (!*new_phys_cpos) {\n\t\tret = -ENOSPC;\n\t\tgoto out_commit;\n\t}\n\n\tret = __ocfs2_move_extent(handle, context, cpos, len, phys_cpos,\n\t\t\t\t  *new_phys_cpos, ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tgd = (struct ocfs2_group_desc *)gd_bh->b_data;\n\tret = ocfs2_alloc_dinode_update_counts(gb_inode, handle, gb_bh, len,\n\t\t\t\t\t       le16_to_cpu(gd->bg_chain));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_block_group_set_bits(handle, gb_inode, gd, gd_bh,\n\t\t\t\t\t goal_bit, len);\n\tif (ret) {\n\t\tocfs2_rollback_alloc_dinode_counts(gb_inode, gb_bh, len,\n\t\t\t\t\t       le16_to_cpu(gd->bg_chain));\n\t\tmlog_errno(ret);\n\t}\n\n\t \n\tret = ocfs2_cow_sync_writeback(inode->i_sb, context->inode, cpos, len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\tbrelse(gd_bh);\n\nout_unlock_tl_inode:\n\tinode_unlock(tl_inode);\n\n\tocfs2_inode_unlock(gb_inode, 1);\nout_unlock_gb_mutex:\n\tinode_unlock(gb_inode);\n\tbrelse(gb_bh);\n\tiput(gb_inode);\n\nout:\n\tif (context->meta_ac) {\n\t\tocfs2_free_alloc_context(context->meta_ac);\n\t\tcontext->meta_ac = NULL;\n\t}\n\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}\n\n \nstatic void ocfs2_calc_extent_defrag_len(u32 *alloc_size, u32 *len_defraged,\n\t\t\t\t\t u32 threshold, int *skip)\n{\n\tif ((*alloc_size + *len_defraged) < threshold) {\n\t\t \n\t\t*len_defraged += *alloc_size;\n\t} else if (*len_defraged == 0) {\n\t\t \n\t\t*skip = 1;\n\t} else {\n\t\t \n\t\t*alloc_size = threshold - *len_defraged;\n\t\t*len_defraged = 0;\n\t}\n}\n\nstatic int __ocfs2_move_extents_range(struct buffer_head *di_bh,\n\t\t\t\tstruct ocfs2_move_extents_context *context)\n{\n\tint ret = 0, flags, do_defrag, skip = 0;\n\tu32 cpos, phys_cpos, move_start, len_to_move, alloc_size;\n\tu32 len_defraged = 0, defrag_thresh = 0, new_phys_cpos = 0;\n\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_move_extents *range = context->range;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif ((i_size_read(inode) == 0) || (range->me_len == 0))\n\t\treturn 0;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\tcontext->refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\n\tocfs2_init_dinode_extent_tree(&context->et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&context->dealloc);\n\n\t \n\n\tdo_defrag = context->auto_defrag;\n\n\t \n\tmove_start = ocfs2_clusters_for_bytes(osb->sb, range->me_start);\n\tlen_to_move = (range->me_start + range->me_len) >>\n\t\t\t\t\t\tosb->s_clustersize_bits;\n\tif (len_to_move >= move_start)\n\t\tlen_to_move -= move_start;\n\telse\n\t\tlen_to_move = 0;\n\n\tif (do_defrag) {\n\t\tdefrag_thresh = range->me_threshold >> osb->s_clustersize_bits;\n\t\tif (defrag_thresh <= 1)\n\t\t\tgoto done;\n\t} else\n\t\tnew_phys_cpos = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t\t range->me_goal);\n\n\tmlog(0, \"Inode: %llu, start: %llu, len: %llu, cstart: %u, clen: %u, \"\n\t     \"thresh: %u\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     (unsigned long long)range->me_start,\n\t     (unsigned long long)range->me_len,\n\t     move_start, len_to_move, defrag_thresh);\n\n\tcpos = move_start;\n\twhile (len_to_move) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos, &alloc_size,\n\t\t\t\t\t &flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (alloc_size > len_to_move)\n\t\t\talloc_size = len_to_move;\n\n\t\t \n\t\tif (!phys_cpos) {\n\t\t\tif (do_defrag)\n\t\t\t\tlen_defraged = 0;\n\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (do_defrag) {\n\t\t\tocfs2_calc_extent_defrag_len(&alloc_size, &len_defraged,\n\t\t\t\t\t\t     defrag_thresh, &skip);\n\t\t\t \n\t\t\tif (skip) {\n\t\t\t\tskip = 0;\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tmlog(0, \"#Defrag: cpos: %u, phys_cpos: %u, \"\n\t\t\t     \"alloc_size: %u, len_defraged: %u\\n\",\n\t\t\t     cpos, phys_cpos, alloc_size, len_defraged);\n\n\t\t\tret = ocfs2_defrag_extent(context, cpos, phys_cpos,\n\t\t\t\t\t\t  &alloc_size, flags);\n\t\t} else {\n\t\t\tret = ocfs2_move_extent(context, cpos, phys_cpos,\n\t\t\t\t\t\t&new_phys_cpos, alloc_size,\n\t\t\t\t\t\tflags);\n\n\t\t\tnew_phys_cpos += alloc_size;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcontext->clusters_moved += alloc_size;\nnext:\n\t\tcpos += alloc_size;\n\t\tlen_to_move -= alloc_size;\n\t}\n\ndone:\n\trange->me_flags |= OCFS2_MOVE_EXT_FL_COMPLETE;\n\nout:\n\trange->me_moved_len = ocfs2_clusters_to_bytes(osb->sb,\n\t\t\t\t\t\t      context->clusters_moved);\n\trange->me_new_offset = ocfs2_clusters_to_bytes(osb->sb,\n\t\t\t\t\t\t       context->new_phys_cpos);\n\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &context->dealloc);\n\n\treturn ret;\n}\n\nstatic int ocfs2_move_extents(struct ocfs2_move_extents_context *context)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_dinode *di;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tinode_lock(inode);\n\n\t \n\tstatus = ocfs2_rw_lock(inode, 1);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_rw_unlock;\n\t}\n\n\t \n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tstatus = __ocfs2_move_extents_range(di_bh, context);\n\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_inode_unlock;\n\t}\n\n\t \n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_inode_unlock;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tinode_set_ctime_current(inode);\n\tdi->i_ctime = cpu_to_le64(inode_get_ctime(inode).tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode_get_ctime(inode).tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_inode_unlock:\n\tbrelse(di_bh);\n\tocfs2_inode_unlock(inode, 1);\nout_rw_unlock:\n\tocfs2_rw_unlock(inode, 1);\nout:\n\tinode_unlock(inode);\n\n\treturn status;\n}\n\nint ocfs2_ioctl_move_extents(struct file *filp, void __user *argp)\n{\n\tint status;\n\n\tstruct inode *inode = file_inode(filp);\n\tstruct ocfs2_move_extents range;\n\tstruct ocfs2_move_extents_context *context;\n\n\tif (!argp)\n\t\treturn -EINVAL;\n\n\tstatus = mnt_want_write_file(filp);\n\tif (status)\n\t\treturn status;\n\n\tif ((!S_ISREG(inode->i_mode)) || !(filp->f_mode & FMODE_WRITE)) {\n\t\tstatus = -EPERM;\n\t\tgoto out_drop;\n\t}\n\n\tif (inode->i_flags & (S_IMMUTABLE|S_APPEND)) {\n\t\tstatus = -EPERM;\n\t\tgoto out_drop;\n\t}\n\n\tcontext = kzalloc(sizeof(struct ocfs2_move_extents_context), GFP_NOFS);\n\tif (!context) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_drop;\n\t}\n\n\tcontext->inode = inode;\n\tcontext->file = filp;\n\n\tif (copy_from_user(&range, argp, sizeof(range))) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tif (range.me_start > i_size_read(inode)) {\n\t\tstatus = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tif (range.me_start + range.me_len > i_size_read(inode))\n\t\t\trange.me_len = i_size_read(inode) - range.me_start;\n\n\tcontext->range = &range;\n\n\t \n\tif (!range.me_threshold)\n\t\trange.me_threshold = 1024 * 1024;\n\n\tif (range.me_threshold > i_size_read(inode))\n\t\trange.me_threshold = i_size_read(inode);\n\n\tif (range.me_flags & OCFS2_MOVE_EXT_FL_AUTO_DEFRAG) {\n\t\tcontext->auto_defrag = 1;\n\n\t\tif (range.me_flags & OCFS2_MOVE_EXT_FL_PART_DEFRAG)\n\t\t\tcontext->partial = 1;\n\t} else {\n\t\t \n\n\t\tstatus = ocfs2_validate_and_adjust_move_goal(inode, &range);\n\t\tif (status)\n\t\t\tgoto out_copy;\n\t}\n\n\tstatus = ocfs2_move_extents(context);\n\tif (status)\n\t\tmlog_errno(status);\nout_copy:\n\t \n\tif (copy_to_user(argp, &range, sizeof(range)))\n\t\tstatus = -EFAULT;\n\nout_free:\n\tkfree(context);\nout_drop:\n\tmnt_drop_write_file(filp);\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}