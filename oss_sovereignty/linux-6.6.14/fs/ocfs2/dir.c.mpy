{
  "module_name": "dir.c",
  "hash_id": "4f48700a19c1b9ac45356902ca705cae0c24c3d86b59c78ea9b0441ed195f818",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/dir.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/sort.h>\n#include <linux/iversion.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"alloc.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"dlmglue.h\"\n#include \"extent_map.h\"\n#include \"file.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"namei.h\"\n#include \"suballoc.h\"\n#include \"super.h\"\n#include \"sysfile.h\"\n#include \"uptodate.h\"\n#include \"ocfs2_trace.h\"\n\n#include \"buffer_head_io.h\"\n\n#define NAMEI_RA_CHUNKS  2\n#define NAMEI_RA_BLOCKS  4\n#define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh);\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\n \nstatic int ocfs2_supports_dir_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\treturn ocfs2_meta_ecc(osb) || ocfs2_dir_indexed(dir);\n}\n\n \nstatic int ocfs2_new_dir_wants_trailer(struct inode *dir)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\treturn ocfs2_meta_ecc(osb) ||\n\t\tocfs2_supports_indexed_dirs(osb);\n}\n\nstatic inline unsigned int ocfs2_dir_trailer_blk_off(struct super_block *sb)\n{\n\treturn sb->s_blocksize - sizeof(struct ocfs2_dir_block_trailer);\n}\n\n#define ocfs2_trailer_from_bh(_bh, _sb) ((struct ocfs2_dir_block_trailer *) ((_bh)->b_data + ocfs2_dir_trailer_blk_off((_sb))))\n\n \nstruct ocfs2_dir_block_trailer *ocfs2_dir_trailer_from_size(int blocksize,\n\t\t\t\t\t\t\t    void *data)\n{\n\tchar *p = data;\n\n\tp += blocksize - sizeof(struct ocfs2_dir_block_trailer);\n\treturn (struct ocfs2_dir_block_trailer *)p;\n}\n\n \nstatic int ocfs2_skip_dir_trailer(struct inode *dir,\n\t\t\t\t  struct ocfs2_dir_entry *de,\n\t\t\t\t  unsigned long offset,\n\t\t\t\t  unsigned long blklen)\n{\n\tunsigned long toff = blklen - sizeof(struct ocfs2_dir_block_trailer);\n\n\tif (!ocfs2_supports_dir_trailer(dir))\n\t\treturn 0;\n\n\tif (offset != toff)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void ocfs2_init_dir_trailer(struct inode *inode,\n\t\t\t\t   struct buffer_head *bh, u16 rec_len)\n{\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\ttrailer = ocfs2_trailer_from_bh(bh, inode->i_sb);\n\tstrcpy(trailer->db_signature, OCFS2_DIR_TRAILER_SIGNATURE);\n\ttrailer->db_compat_rec_len =\n\t\t\tcpu_to_le16(sizeof(struct ocfs2_dir_block_trailer));\n\ttrailer->db_parent_dinode = cpu_to_le64(OCFS2_I(inode)->ip_blkno);\n\ttrailer->db_blkno = cpu_to_le64(bh->b_blocknr);\n\ttrailer->db_free_rec_len = cpu_to_le16(rec_len);\n}\n \nstatic int ocfs2_dx_dir_link_trailer(struct inode *dir, handle_t *handle,\n\t\t\t\t     struct buffer_head *dx_root_bh,\n\t\t\t\t     struct buffer_head *dirdata_bh)\n{\n\tint ret;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\ttrailer = ocfs2_trailer_from_bh(dirdata_bh, dir->i_sb);\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\ttrailer->db_free_next = dx_root->dr_free_blk;\n\tdx_root->dr_free_blk = cpu_to_le64(dirdata_bh->b_blocknr);\n\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_free_list_at_root(struct ocfs2_dir_lookup_result *res)\n{\n\treturn res->dl_prev_leaf_bh == NULL;\n}\n\nvoid ocfs2_free_dir_lookup_result(struct ocfs2_dir_lookup_result *res)\n{\n\tbrelse(res->dl_dx_root_bh);\n\tbrelse(res->dl_leaf_bh);\n\tbrelse(res->dl_dx_leaf_bh);\n\tbrelse(res->dl_prev_leaf_bh);\n}\n\nstatic int ocfs2_dir_indexed(struct inode *inode)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INDEXED_DIR_FL)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int ocfs2_dx_root_inline(struct ocfs2_dx_root_block *dx_root)\n{\n\treturn dx_root->dr_flags & OCFS2_DX_FLAG_INLINE;\n}\n\n \n#define DELTA 0x9E3779B9\n\nstatic void TEA_transform(__u32 buf[4], __u32 const in[])\n{\n\t__u32\tsum = 0;\n\t__u32\tb0 = buf[0], b1 = buf[1];\n\t__u32\ta = in[0], b = in[1], c = in[2], d = in[3];\n\tint\tn = 16;\n\n\tdo {\n\t\tsum += DELTA;\n\t\tb0 += ((b1 << 4)+a) ^ (b1+sum) ^ ((b1 >> 5)+b);\n\t\tb1 += ((b0 << 4)+c) ^ (b0+sum) ^ ((b0 >> 5)+d);\n\t} while (--n);\n\n\tbuf[0] += b0;\n\tbuf[1] += b1;\n}\n\nstatic void str2hashbuf(const char *msg, int len, __u32 *buf, int num)\n{\n\t__u32\tpad, val;\n\tint\ti;\n\n\tpad = (__u32)len | ((__u32)len << 8);\n\tpad |= pad << 16;\n\n\tval = pad;\n\tif (len > num*4)\n\t\tlen = num * 4;\n\tfor (i = 0; i < len; i++) {\n\t\tif ((i % 4) == 0)\n\t\t\tval = pad;\n\t\tval = msg[i] + (val << 8);\n\t\tif ((i % 4) == 3) {\n\t\t\t*buf++ = val;\n\t\t\tval = pad;\n\t\t\tnum--;\n\t\t}\n\t}\n\tif (--num >= 0)\n\t\t*buf++ = val;\n\twhile (--num >= 0)\n\t\t*buf++ = pad;\n}\n\nstatic void ocfs2_dx_dir_name_hash(struct inode *dir, const char *name, int len,\n\t\t\t\t   struct ocfs2_dx_hinfo *hinfo)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tconst char\t*p;\n\t__u32\t\tin[8], buf[4];\n\n\t \n\tif ((len == 1 && !strncmp(\".\", name, 1)) ||\n\t    (len == 2 && !strncmp(\"..\", name, 2))) {\n\t\tbuf[0] = buf[1] = 0;\n\t\tgoto out;\n\t}\n\n#ifdef OCFS2_DEBUG_DX_DIRS\n\t \n\tbuf[0] = buf[1] = len;\n\tgoto out;\n#endif\n\n\tmemcpy(buf, osb->osb_dx_seed, sizeof(buf));\n\n\tp = name;\n\twhile (len > 0) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tlen -= 16;\n\t\tp += 16;\n\t}\n\nout:\n\thinfo->major_hash = buf[0];\n\thinfo->minor_hash = buf[1];\n}\n\n \nstatic int ocfs2_check_dir_entry(struct inode * dir,\n\t\t\t\t struct ocfs2_dir_entry * de,\n\t\t\t\t struct buffer_head * bh,\n\t\t\t\t unsigned long offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = le16_to_cpu(de->rec_len);\n\n\tif (unlikely(rlen < OCFS2_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < OCFS2_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(\n\t\t ((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize))\n\t\terror_msg = \"directory entry across blocks\";\n\n\tif (unlikely(error_msg != NULL))\n\t\tmlog(ML_ERROR, \"bad entry in directory #%llu: %s - \"\n\t\t     \"offset=%lu, inode=%llu, rec_len=%d, name_len=%d\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, error_msg,\n\t\t     offset, (unsigned long long)le64_to_cpu(de->inode), rlen,\n\t\t     de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}\n\nstatic inline int ocfs2_match(int len,\n\t\t\t      const char * const name,\n\t\t\t      struct ocfs2_dir_entry *de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}\n\n \nstatic inline int ocfs2_search_dirblock(struct buffer_head *bh,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tconst char *name, int namelen,\n\t\t\t\t\tunsigned long offset,\n\t\t\t\t\tchar *first_de,\n\t\t\t\t\tunsigned int bytes,\n\t\t\t\t\tstruct ocfs2_dir_entry **res_dir)\n{\n\tstruct ocfs2_dir_entry *de;\n\tchar *dlimit, *de_buf;\n\tint de_len;\n\tint ret = 0;\n\n\tde_buf = first_de;\n\tdlimit = de_buf + bytes;\n\n\twhile (de_buf < dlimit) {\n\t\t \n\t\t \n\n\t\tde = (struct ocfs2_dir_entry *) de_buf;\n\n\t\tif (de_buf + namelen <= dlimit &&\n\t\t    ocfs2_match(namelen, name, de)) {\n\t\t\t \n\t\t\tif (!ocfs2_check_dir_entry(dir, de, bh, offset)) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t*res_dir = de;\n\t\t\tret = 1;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t \n\t\tde_len = le16_to_cpu(de->rec_len);\n\t\tif (de_len <= 0) {\n\t\t\tret = -1;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tde_buf += de_len;\n\t\toffset += de_len;\n\t}\n\nbail:\n\ttrace_ocfs2_search_dirblock(ret);\n\treturn ret;\n}\n\nstatic struct buffer_head *ocfs2_find_entry_id(const char *name,\n\t\t\t\t\t       int namelen,\n\t\t\t\t\t       struct inode *dir,\n\t\t\t\t\t       struct ocfs2_dir_entry **res_dir)\n{\n\tint ret, found;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_inline_data *data;\n\n\tret = ocfs2_read_inode_block(dir, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdata = &di->id2.i_data;\n\n\tfound = ocfs2_search_dirblock(di_bh, dir, name, namelen, 0,\n\t\t\t\t      data->id_data, i_size_read(dir), res_dir);\n\tif (found == 1)\n\t\treturn di_bh;\n\n\tbrelse(di_bh);\nout:\n\treturn NULL;\n}\n\nstatic int ocfs2_validate_dir_block(struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_dir_block_trailer *trailer =\n\t\tocfs2_trailer_from_bh(bh, sb);\n\n\n\t \n\ttrace_ocfs2_validate_dir_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t \n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &trailer->db_check);\n\tif (rc)\n\t\tmlog(ML_ERROR, \"Checksum failed for dinode %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\n\treturn rc;\n}\n\n \nstatic int ocfs2_check_dir_trailer(struct inode *dir, struct buffer_head *bh)\n{\n\tint rc = 0;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\ttrailer = ocfs2_trailer_from_bh(bh, dir->i_sb);\n\tif (!OCFS2_IS_VALID_DIR_TRAILER(trailer)) {\n\t\trc = ocfs2_error(dir->i_sb,\n\t\t\t\t \"Invalid dirblock #%llu: signature = %.*s\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr, 7,\n\t\t\t\t trailer->db_signature);\n\t\tgoto out;\n\t}\n\tif (le64_to_cpu(trailer->db_blkno) != bh->b_blocknr) {\n\t\trc = ocfs2_error(dir->i_sb,\n\t\t\t\t \"Directory block #%llu has an invalid db_blkno of %llu\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t (unsigned long long)le64_to_cpu(trailer->db_blkno));\n\t\tgoto out;\n\t}\n\tif (le64_to_cpu(trailer->db_parent_dinode) !=\n\t    OCFS2_I(dir)->ip_blkno) {\n\t\trc = ocfs2_error(dir->i_sb,\n\t\t\t\t \"Directory block #%llu on dinode #%llu has an invalid parent_dinode of %llu\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t (unsigned long long)le64_to_cpu(trailer->db_blkno));\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}\n\n \nstatic int ocfs2_read_dir_block(struct inode *inode, u64 v_block,\n\t\t\t\tstruct buffer_head **bh, int flags)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, flags,\n\t\t\t\t    ocfs2_validate_dir_block);\n\tif (rc) {\n\t\tmlog_errno(rc);\n\t\tgoto out;\n\t}\n\n\tif (!(flags & OCFS2_BH_READAHEAD) &&\n\t    ocfs2_supports_dir_trailer(inode)) {\n\t\trc = ocfs2_check_dir_trailer(inode, tmp);\n\t\tif (rc) {\n\t\t\tif (!*bh)\n\t\t\t\tbrelse(tmp);\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc ? -EIO : 0;\n}\n\n \nstatic int ocfs2_read_dir_block_direct(struct inode *dir, u64 phys,\n\t\t\t\t       struct buffer_head **bh)\n{\n\tint ret;\n\tstruct buffer_head *tmp = *bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), phys, &tmp,\n\t\t\t       ocfs2_validate_dir_block);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_supports_dir_trailer(dir)) {\n\t\tret = ocfs2_check_dir_trailer(dir, tmp);\n\t\tif (ret) {\n\t\t\tif (!*bh)\n\t\t\t\tbrelse(tmp);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!ret && !*bh)\n\t\t*bh = tmp;\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_validate_dx_root(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh)\n{\n\tint ret;\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\tdx_root = (struct ocfs2_dx_root_block *) bh->b_data;\n\n\tret = ocfs2_validate_meta_ecc(sb, bh->b_data, &dx_root->dr_check);\n\tif (ret) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Checksum failed for dir index root block %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\treturn ret;\n\t}\n\n\tif (!OCFS2_IS_VALID_DX_ROOT(dx_root)) {\n\t\tret = ocfs2_error(sb,\n\t\t\t\t  \"Dir Index Root # %llu has bad signature %.*s\\n\",\n\t\t\t\t  (unsigned long long)le64_to_cpu(dx_root->dr_blkno),\n\t\t\t\t  7, dx_root->dr_signature);\n\t}\n\n\treturn ret;\n}\n\nstatic int ocfs2_read_dx_root(struct inode *dir, struct ocfs2_dinode *di,\n\t\t\t      struct buffer_head **dx_root_bh)\n{\n\tint ret;\n\tu64 blkno = le64_to_cpu(di->i_dx_root);\n\tstruct buffer_head *tmp = *dx_root_bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), blkno, &tmp,\n\t\t\t       ocfs2_validate_dx_root);\n\n\t \n\tif (!ret && !*dx_root_bh)\n\t\t*dx_root_bh = tmp;\n\n\treturn ret;\n}\n\nstatic int ocfs2_validate_dx_leaf(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh)\n{\n\tint ret;\n\tstruct ocfs2_dx_leaf *dx_leaf = (struct ocfs2_dx_leaf *)bh->b_data;\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\tret = ocfs2_validate_meta_ecc(sb, bh->b_data, &dx_leaf->dl_check);\n\tif (ret) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Checksum failed for dir index leaf block %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\treturn ret;\n\t}\n\n\tif (!OCFS2_IS_VALID_DX_LEAF(dx_leaf)) {\n\t\tret = ocfs2_error(sb, \"Dir Index Leaf has bad signature %.*s\\n\",\n\t\t\t\t  7, dx_leaf->dl_signature);\n\t}\n\n\treturn ret;\n}\n\nstatic int ocfs2_read_dx_leaf(struct inode *dir, u64 blkno,\n\t\t\t      struct buffer_head **dx_leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *tmp = *dx_leaf_bh;\n\n\tret = ocfs2_read_block(INODE_CACHE(dir), blkno, &tmp,\n\t\t\t       ocfs2_validate_dx_leaf);\n\n\t \n\tif (!ret && !*dx_leaf_bh)\n\t\t*dx_leaf_bh = tmp;\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_read_dx_leaves(struct inode *dir, u64 start, int num,\n\t\t\t\tstruct buffer_head **dx_leaf_bhs)\n{\n\tint ret;\n\n\tret = ocfs2_read_blocks(INODE_CACHE(dir), start, num, dx_leaf_bhs, 0,\n\t\t\t\tocfs2_validate_dx_leaf);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}\n\nstatic struct buffer_head *ocfs2_find_entry_el(const char *name, int namelen,\n\t\t\t\t\t       struct inode *dir,\n\t\t\t\t\t       struct ocfs2_dir_entry **res_dir)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\tunsigned long start, block, b;\n\tint ra_max = 0;\t\t \n\tint ra_ptr = 0;\t\t \n\tint num = 0;\n\tint nblocks, i;\n\n\tsb = dir->i_sb;\n\n\tnblocks = i_size_read(dir) >> sb->s_blocksize_bits;\n\tstart = OCFS2_I(dir)->ip_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\n\nrestart:\n\tdo {\n\t\t \n\t\tif (ra_ptr >= ra_max) {\n\t\t\t \n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t \n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\n\t\t\t\tbh = NULL;\n\t\t\t\tocfs2_read_dir_block(dir, b++, &bh,\n\t\t\t\t\t\t\t   OCFS2_BH_READAHEAD);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\tif (ocfs2_read_dir_block(dir, block, &bh, 0)) {\n\t\t\t \n\t\t\tmlog(ML_ERROR, \"reading directory %llu, \"\n\t\t\t\t    \"offset %lu\\n\",\n\t\t\t\t    (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t    block);\n\t\t\tgoto next;\n\t\t}\n\t\ti = ocfs2_search_dirblock(bh, dir, name, namelen,\n\t\t\t\t\t  block << sb->s_blocksize_bits,\n\t\t\t\t\t  bh->b_data, sb->s_blocksize,\n\t\t\t\t\t  res_dir);\n\t\tif (i == 1) {\n\t\t\tOCFS2_I(dir)->ip_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t \n\tblock = nblocks;\n\tnblocks = i_size_read(dir) >> sb->s_blocksize_bits;\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t \n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\n\ttrace_ocfs2_find_entry_el(ret);\n\treturn ret;\n}\n\nstatic int ocfs2_dx_dir_lookup_rec(struct inode *inode,\n\t\t\t\t   struct ocfs2_extent_list *el,\n\t\t\t\t   u32 major_hash,\n\t\t\t\t   u32 *ret_cpos,\n\t\t\t\t   u64 *ret_phys_blkno,\n\t\t\t\t   unsigned int *ret_clen)\n{\n\tint ret = 0, i, found;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, major_hash,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tret = ocfs2_error(inode->i_sb,\n\t\t\t\t\t  \"Inode %lu has non zero tree depth in btree tree block %llu\\n\",\n\t\t\t\t\t  inode->i_ino,\n\t\t\t\t\t  (unsigned long long)eb_bh->b_blocknr);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= major_hash) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tret = ocfs2_error(inode->i_sb,\n\t\t\t\t  \"Inode %lu has bad extent record (%u, %u, 0) in btree\\n\",\n\t\t\t\t  inode->i_ino,\n\t\t\t\t  le32_to_cpu(rec->e_cpos),\n\t\t\t\t  ocfs2_rec_clusters(el, rec));\n\t\tgoto out;\n\t}\n\n\tif (ret_phys_blkno)\n\t\t*ret_phys_blkno = le64_to_cpu(rec->e_blkno);\n\tif (ret_cpos)\n\t\t*ret_cpos = le32_to_cpu(rec->e_cpos);\n\tif (ret_clen)\n\t\t*ret_clen = le16_to_cpu(rec->e_leaf_clusters);\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}\n\n \nstatic inline unsigned int __ocfs2_dx_dir_hash_idx(struct ocfs2_super *osb,\n\t\t\t\t\t\t   u32 minor_hash)\n{\n\treturn minor_hash & osb->osb_dx_mask;\n}\n\nstatic inline unsigned int ocfs2_dx_dir_hash_idx(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_dx_hinfo *hinfo)\n{\n\treturn __ocfs2_dx_dir_hash_idx(osb, hinfo->minor_hash);\n}\n\nstatic int ocfs2_dx_dir_lookup(struct inode *inode,\n\t\t\t       struct ocfs2_extent_list *el,\n\t\t\t       struct ocfs2_dx_hinfo *hinfo,\n\t\t\t       u32 *ret_cpos,\n\t\t\t       u64 *ret_phys_blkno)\n{\n\tint ret = 0;\n\tunsigned int cend, clen;\n\tu32 cpos;\n\tu64 blkno;\n\tu32 name_hash = hinfo->major_hash;\n\n\tret = ocfs2_dx_dir_lookup_rec(inode, el, name_hash, &cpos, &blkno,\n\t\t\t\t      &clen);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcend = cpos + clen;\n\tif (name_hash >= cend) {\n\t\t \n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb, clen - 1);\n\t\tcpos += clen - 1;\n\t} else {\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t  name_hash - cpos);\n\t\tcpos = name_hash;\n\t}\n\n\t \n\tblkno += ocfs2_dx_dir_hash_idx(OCFS2_SB(inode->i_sb), hinfo);\n\n\tif (ret_phys_blkno)\n\t\t*ret_phys_blkno = blkno;\n\tif (ret_cpos)\n\t\t*ret_cpos = cpos;\n\nout:\n\n\treturn ret;\n}\n\nstatic int ocfs2_dx_dir_search(const char *name, int namelen,\n\t\t\t       struct inode *dir,\n\t\t\t       struct ocfs2_dx_root_block *dx_root,\n\t\t\t       struct ocfs2_dir_lookup_result *res)\n{\n\tint ret, i, found;\n\tu64 phys;\n\tstruct buffer_head *dx_leaf_bh = NULL;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tstruct ocfs2_dx_entry *dx_entry = NULL;\n\tstruct buffer_head *dir_ent_bh = NULL;\n\tstruct ocfs2_dir_entry *dir_ent = NULL;\n\tstruct ocfs2_dx_hinfo *hinfo = &res->dl_hinfo;\n\tstruct ocfs2_extent_list *dr_el;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\tocfs2_dx_dir_name_hash(dir, name, namelen, &res->dl_hinfo);\n\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tentry_list = &dx_root->dr_entries;\n\t\tgoto search;\n\t}\n\n\tdr_el = &dx_root->dr_list;\n\n\tret = ocfs2_dx_dir_lookup(dir, dr_el, hinfo, NULL, &phys);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_dx_dir_search((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t  namelen, name, hinfo->major_hash,\n\t\t\t\t  hinfo->minor_hash, (unsigned long long)phys);\n\n\tret = ocfs2_read_dx_leaf(dir, phys, &dx_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaf = (struct ocfs2_dx_leaf *) dx_leaf_bh->b_data;\n\n\ttrace_ocfs2_dx_dir_search_leaf_info(\n\t\t\tle16_to_cpu(dx_leaf->dl_list.de_num_used),\n\t\t\tle16_to_cpu(dx_leaf->dl_list.de_count));\n\n\tentry_list = &dx_leaf->dl_list;\n\nsearch:\n\t \n\tfound = 0;\n\tfor (i = 0; i < le16_to_cpu(entry_list->de_num_used); i++) {\n\t\tdx_entry = &entry_list->de_entries[i];\n\n\t\tif (hinfo->major_hash != le32_to_cpu(dx_entry->dx_major_hash)\n\t\t    || hinfo->minor_hash != le32_to_cpu(dx_entry->dx_minor_hash))\n\t\t\tcontinue;\n\n\t\t \n\t\tret = ocfs2_read_dir_block_direct(dir,\n\t\t\t\t\t  le64_to_cpu(dx_entry->dx_dirent_blk),\n\t\t\t\t\t  &dir_ent_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\n\t\tfound = ocfs2_search_dirblock(dir_ent_bh, dir, name, namelen,\n\t\t\t\t\t      0, dir_ent_bh->b_data,\n\t\t\t\t\t      dir->i_sb->s_blocksize, &dir_ent);\n\t\tif (found == 1)\n\t\t\tbreak;\n\n\t\tif (found == -1) {\n\t\t\t \n\t\t\tret = -EIO;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbrelse(dir_ent_bh);\n\t\tdir_ent_bh = NULL;\n\t}\n\n\tif (found <= 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tres->dl_leaf_bh = dir_ent_bh;\n\tres->dl_entry = dir_ent;\n\tres->dl_dx_leaf_bh = dx_leaf_bh;\n\tres->dl_dx_entry = dx_entry;\n\n\tret = 0;\nout:\n\tif (ret) {\n\t\tbrelse(dx_leaf_bh);\n\t\tbrelse(dir_ent_bh);\n\t}\n\treturn ret;\n}\n\nstatic int ocfs2_find_entry_dx(const char *name, int namelen,\n\t\t\t       struct inode *dir,\n\t\t\t       struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tret = ocfs2_read_inode_block(dir, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_read_dx_root(dir, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\n\tret = ocfs2_dx_dir_search(name, namelen, dir, dx_root, lookup);\n\tif (ret) {\n\t\tif (ret != -ENOENT)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tlookup->dl_dx_root_bh = dx_root_bh;\n\tdx_root_bh = NULL;\nout:\n\tbrelse(di_bh);\n\tbrelse(dx_root_bh);\n\treturn ret;\n}\n\n \nint ocfs2_find_entry(const char *name, int namelen,\n\t\t     struct inode *dir, struct ocfs2_dir_lookup_result *lookup)\n{\n\tstruct buffer_head *bh;\n\tstruct ocfs2_dir_entry *res_dir = NULL;\n\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_find_entry_dx(name, namelen, dir, lookup);\n\n\t \n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tbh = ocfs2_find_entry_id(name, namelen, dir, &res_dir);\n\telse\n\t\tbh = ocfs2_find_entry_el(name, namelen, dir, &res_dir);\n\n\tif (bh == NULL)\n\t\treturn -ENOENT;\n\n\tlookup->dl_leaf_bh = bh;\n\tlookup->dl_entry = res_dir;\n\treturn 0;\n}\n\n \nint ocfs2_update_entry(struct inode *dir, handle_t *handle,\n\t\t       struct ocfs2_dir_lookup_result *res,\n\t\t       struct inode *new_entry_inode)\n{\n\tint ret;\n\tocfs2_journal_access_func access = ocfs2_journal_access_db;\n\tstruct ocfs2_dir_entry *de = res->dl_entry;\n\tstruct buffer_head *de_bh = res->dl_leaf_bh;\n\n\t \n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\taccess = ocfs2_journal_access_di;\n\n\tret = access(handle, INODE_CACHE(dir), de_bh,\n\t\t     OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tde->inode = cpu_to_le64(OCFS2_I(new_entry_inode)->ip_blkno);\n\tocfs2_set_de_type(de, new_entry_inode->i_mode);\n\n\tocfs2_journal_dirty(handle, de_bh);\n\nout:\n\treturn ret;\n}\n\n \nstatic int __ocfs2_delete_entry(handle_t *handle, struct inode *dir,\n\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\tstruct buffer_head *bh, char *first_de,\n\t\t\t\tunsigned int bytes)\n{\n\tstruct ocfs2_dir_entry *de, *pde;\n\tint i, status = -ENOENT;\n\tocfs2_journal_access_func access = ocfs2_journal_access_db;\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\taccess = ocfs2_journal_access_di;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ocfs2_dir_entry *) first_de;\n\twhile (i < bytes) {\n\t\tif (!ocfs2_check_dir_entry(dir, de, bh, i)) {\n\t\t\tstatus = -EIO;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tif (de == de_del)  {\n\t\t\tstatus = access(handle, INODE_CACHE(dir), bh,\n\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -EIO;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (pde)\n\t\t\t\tle16_add_cpu(&pde->rec_len,\n\t\t\t\t\t\tle16_to_cpu(de->rec_len));\n\t\t\tde->inode = 0;\n\t\t\tinode_inc_iversion(dir);\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tgoto bail;\n\t\t}\n\t\ti += le16_to_cpu(de->rec_len);\n\t\tpde = de;\n\t\tde = (struct ocfs2_dir_entry *)((char *)de + le16_to_cpu(de->rec_len));\n\t}\nbail:\n\treturn status;\n}\n\nstatic unsigned int ocfs2_figure_dirent_hole(struct ocfs2_dir_entry *de)\n{\n\tunsigned int hole;\n\n\tif (le64_to_cpu(de->inode) == 0)\n\t\thole = le16_to_cpu(de->rec_len);\n\telse\n\t\thole = le16_to_cpu(de->rec_len) -\n\t\t\tOCFS2_DIR_REC_LEN(de->name_len);\n\n\treturn hole;\n}\n\nstatic int ocfs2_find_max_rec_len(struct super_block *sb,\n\t\t\t\t  struct buffer_head *dirblock_bh)\n{\n\tint size, this_hole, largest_hole = 0;\n\tchar *trailer, *de_buf, *limit, *start = dirblock_bh->b_data;\n\tstruct ocfs2_dir_entry *de;\n\n\ttrailer = (char *)ocfs2_trailer_from_bh(dirblock_bh, sb);\n\tsize = ocfs2_dir_trailer_blk_off(sb);\n\tlimit = start + size;\n\tde_buf = start;\n\tde = (struct ocfs2_dir_entry *)de_buf;\n\tdo {\n\t\tif (de_buf != trailer) {\n\t\t\tthis_hole = ocfs2_figure_dirent_hole(de);\n\t\t\tif (this_hole > largest_hole)\n\t\t\t\tlargest_hole = this_hole;\n\t\t}\n\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\t} while (de_buf < limit);\n\n\tif (largest_hole >= OCFS2_DIR_MIN_REC_LEN)\n\t\treturn largest_hole;\n\treturn 0;\n}\n\nstatic void ocfs2_dx_list_remove_entry(struct ocfs2_dx_entry_list *entry_list,\n\t\t\t\t       int index)\n{\n\tint num_used = le16_to_cpu(entry_list->de_num_used);\n\n\tif (num_used == 1 || index == (num_used - 1))\n\t\tgoto clear;\n\n\tmemmove(&entry_list->de_entries[index],\n\t\t&entry_list->de_entries[index + 1],\n\t\t(num_used - index - 1)*sizeof(struct ocfs2_dx_entry));\nclear:\n\tnum_used--;\n\tmemset(&entry_list->de_entries[num_used], 0,\n\t       sizeof(struct ocfs2_dx_entry));\n\tentry_list->de_num_used = cpu_to_le16(num_used);\n}\n\nstatic int ocfs2_delete_entry_dx(handle_t *handle, struct inode *dir,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret, index, max_rec_len, add_to_free_list = 0;\n\tstruct buffer_head *dx_root_bh = lookup->dl_dx_root_bh;\n\tstruct buffer_head *leaf_bh = lookup->dl_leaf_bh;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tstruct ocfs2_dx_entry *dx_entry = lookup->dl_dx_entry;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\t \n\n\t \n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tentry_list = &dx_root->dr_entries;\n\t} else {\n\t\tdx_leaf = (struct ocfs2_dx_leaf *) lookup->dl_dx_leaf_bh->b_data;\n\t\tentry_list = &dx_leaf->dl_list;\n\t}\n\n\t \n\tBUG_ON(le16_to_cpu(entry_list->de_count) <= 0);\n\tBUG_ON(le16_to_cpu(entry_list->de_num_used) <= 0);\n\n\tindex = (char *)dx_entry - (char *)entry_list->de_entries;\n\tindex /= sizeof(*dx_entry);\n\n\tif (index >= le16_to_cpu(entry_list->de_num_used)) {\n\t\tmlog(ML_ERROR, \"Dir %llu: Bad dx_entry ptr idx %d, (%p, %p)\\n\",\n\t\t     (unsigned long long)OCFS2_I(dir)->ip_blkno, index,\n\t\t     entry_list, dx_entry);\n\t\treturn -EIO;\n\t}\n\n\t \n\ttrailer = ocfs2_trailer_from_bh(leaf_bh, dir->i_sb);\n\tif (trailer->db_free_rec_len == 0)\n\t\tadd_to_free_list = 1;\n\n\t \n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!ocfs2_dx_root_inline(dx_root)) {\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir),\n\t\t\t\t\t      lookup->dl_dx_leaf_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ttrace_ocfs2_delete_entry_dx((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t    index);\n\n\tret = __ocfs2_delete_entry(handle, dir, lookup->dl_entry,\n\t\t\t\t   leaf_bh, leaf_bh->b_data, leaf_bh->b_size);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmax_rec_len = ocfs2_find_max_rec_len(dir->i_sb, leaf_bh);\n\ttrailer->db_free_rec_len = cpu_to_le16(max_rec_len);\n\tif (add_to_free_list) {\n\t\ttrailer->db_free_next = dx_root->dr_free_blk;\n\t\tdx_root->dr_free_blk = cpu_to_le64(leaf_bh->b_blocknr);\n\t\tocfs2_journal_dirty(handle, dx_root_bh);\n\t}\n\n\t \n\tocfs2_journal_dirty(handle, leaf_bh);\n\n\tle32_add_cpu(&dx_root->dr_num_entries, -1);\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\n\tocfs2_dx_list_remove_entry(entry_list, index);\n\n\tif (!ocfs2_dx_root_inline(dx_root))\n\t\tocfs2_journal_dirty(handle, lookup->dl_dx_leaf_bh);\n\nout:\n\treturn ret;\n}\n\nstatic inline int ocfs2_delete_entry_id(handle_t *handle,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_inline_data *data;\n\n\tret = ocfs2_read_inode_block(dir, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdata = &di->id2.i_data;\n\n\tret = __ocfs2_delete_entry(handle, dir, de_del, bh, data->id_data,\n\t\t\t\t   i_size_read(dir));\n\n\tbrelse(di_bh);\nout:\n\treturn ret;\n}\n\nstatic inline int ocfs2_delete_entry_el(handle_t *handle,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tstruct ocfs2_dir_entry *de_del,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\treturn __ocfs2_delete_entry(handle, dir, de_del, bh, bh->b_data,\n\t\t\t\t    bh->b_size);\n}\n\n \nint ocfs2_delete_entry(handle_t *handle,\n\t\t       struct inode *dir,\n\t\t       struct ocfs2_dir_lookup_result *res)\n{\n\tif (ocfs2_dir_indexed(dir))\n\t\treturn ocfs2_delete_entry_dx(handle, dir, res);\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_delete_entry_id(handle, dir, res->dl_entry,\n\t\t\t\t\t     res->dl_leaf_bh);\n\n\treturn ocfs2_delete_entry_el(handle, dir, res->dl_entry,\n\t\t\t\t     res->dl_leaf_bh);\n}\n\n \nstatic inline int ocfs2_dirent_would_fit(struct ocfs2_dir_entry *de,\n\t\t\t\t\t unsigned int new_rec_len)\n{\n\tunsigned int de_really_used;\n\n\t \n\tif (le64_to_cpu(de->inode) == 0 &&\n\t    le16_to_cpu(de->rec_len) >= new_rec_len)\n\t\treturn 1;\n\n\t \n\tde_really_used = OCFS2_DIR_REC_LEN(de->name_len);\n\tif (le16_to_cpu(de->rec_len) >= (de_really_used + new_rec_len))\n\t    return 1;\n\n\treturn 0;\n}\n\nstatic void ocfs2_dx_dir_leaf_insert_tail(struct ocfs2_dx_leaf *dx_leaf,\n\t\t\t\t\t  struct ocfs2_dx_entry *dx_new_entry)\n{\n\tint i;\n\n\ti = le16_to_cpu(dx_leaf->dl_list.de_num_used);\n\tdx_leaf->dl_list.de_entries[i] = *dx_new_entry;\n\n\tle16_add_cpu(&dx_leaf->dl_list.de_num_used, 1);\n}\n\nstatic void ocfs2_dx_entry_list_insert(struct ocfs2_dx_entry_list *entry_list,\n\t\t\t\t       struct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t       u64 dirent_blk)\n{\n\tint i;\n\tstruct ocfs2_dx_entry *dx_entry;\n\n\ti = le16_to_cpu(entry_list->de_num_used);\n\tdx_entry = &entry_list->de_entries[i];\n\n\tmemset(dx_entry, 0, sizeof(*dx_entry));\n\tdx_entry->dx_major_hash = cpu_to_le32(hinfo->major_hash);\n\tdx_entry->dx_minor_hash = cpu_to_le32(hinfo->minor_hash);\n\tdx_entry->dx_dirent_blk = cpu_to_le64(dirent_blk);\n\n\tle16_add_cpu(&entry_list->de_num_used, 1);\n}\n\nstatic int __ocfs2_dx_dir_leaf_insert(struct inode *dir, handle_t *handle,\n\t\t\t\t      struct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t      u64 dirent_blk,\n\t\t\t\t      struct buffer_head *dx_leaf_bh)\n{\n\tint ret;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\n\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir), dx_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaf = (struct ocfs2_dx_leaf *)dx_leaf_bh->b_data;\n\tocfs2_dx_entry_list_insert(&dx_leaf->dl_list, hinfo, dirent_blk);\n\tocfs2_journal_dirty(handle, dx_leaf_bh);\n\nout:\n\treturn ret;\n}\n\nstatic void ocfs2_dx_inline_root_insert(struct inode *dir, handle_t *handle,\n\t\t\t\t\tstruct ocfs2_dx_hinfo *hinfo,\n\t\t\t\t\tu64 dirent_blk,\n\t\t\t\t\tstruct ocfs2_dx_root_block *dx_root)\n{\n\tocfs2_dx_entry_list_insert(&dx_root->dr_entries, hinfo, dirent_blk);\n}\n\nstatic int ocfs2_dx_dir_insert(struct inode *dir, handle_t *handle,\n\t\t\t       struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret = 0;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct buffer_head *dx_root_bh = lookup->dl_dx_root_bh;\n\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_root = (struct ocfs2_dx_root_block *)lookup->dl_dx_root_bh->b_data;\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tocfs2_dx_inline_root_insert(dir, handle,\n\t\t\t\t\t    &lookup->dl_hinfo,\n\t\t\t\t\t    lookup->dl_leaf_bh->b_blocknr,\n\t\t\t\t\t    dx_root);\n\t} else {\n\t\tret = __ocfs2_dx_dir_leaf_insert(dir, handle, &lookup->dl_hinfo,\n\t\t\t\t\t\t lookup->dl_leaf_bh->b_blocknr,\n\t\t\t\t\t\t lookup->dl_dx_leaf_bh);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tle32_add_cpu(&dx_root->dr_num_entries, 1);\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\nout:\n\treturn ret;\n}\n\nstatic void ocfs2_remove_block_from_free_list(struct inode *dir,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct ocfs2_dir_lookup_result *lookup)\n{\n\tstruct ocfs2_dir_block_trailer *trailer, *prev;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct buffer_head *bh;\n\n\ttrailer = ocfs2_trailer_from_bh(lookup->dl_leaf_bh, dir->i_sb);\n\n\tif (ocfs2_free_list_at_root(lookup)) {\n\t\tbh = lookup->dl_dx_root_bh;\n\t\tdx_root = (struct ocfs2_dx_root_block *)bh->b_data;\n\t\tdx_root->dr_free_blk = trailer->db_free_next;\n\t} else {\n\t\tbh = lookup->dl_prev_leaf_bh;\n\t\tprev = ocfs2_trailer_from_bh(bh, dir->i_sb);\n\t\tprev->db_free_next = trailer->db_free_next;\n\t}\n\n\ttrailer->db_free_rec_len = cpu_to_le16(0);\n\ttrailer->db_free_next = cpu_to_le64(0);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_journal_dirty(handle, lookup->dl_leaf_bh);\n}\n\n \nstatic void ocfs2_recalc_free_list(struct inode *dir, handle_t *handle,\n\t\t\t\t   struct ocfs2_dir_lookup_result *lookup)\n{\n\tint max_rec_len;\n\tstruct ocfs2_dir_block_trailer *trailer;\n\n\t \n\tmax_rec_len = ocfs2_find_max_rec_len(dir->i_sb, lookup->dl_leaf_bh);\n\tif (max_rec_len) {\n\t\t \n\t\ttrailer = ocfs2_trailer_from_bh(lookup->dl_leaf_bh, dir->i_sb);\n\t\ttrailer->db_free_rec_len = cpu_to_le16(max_rec_len);\n\t\tocfs2_journal_dirty(handle, lookup->dl_leaf_bh);\n\t} else {\n\t\tocfs2_remove_block_from_free_list(dir, handle, lookup);\n\t}\n}\n\n \nint __ocfs2_add_entry(handle_t *handle,\n\t\t      struct inode *dir,\n\t\t      const char *name, int namelen,\n\t\t      struct inode *inode, u64 blkno,\n\t\t      struct buffer_head *parent_fe_bh,\n\t\t      struct ocfs2_dir_lookup_result *lookup)\n{\n\tunsigned long offset;\n\tunsigned short rec_len;\n\tstruct ocfs2_dir_entry *de, *de1;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)parent_fe_bh->b_data;\n\tstruct super_block *sb = dir->i_sb;\n\tint retval;\n\tunsigned int size = sb->s_blocksize;\n\tstruct buffer_head *insert_bh = lookup->dl_leaf_bh;\n\tchar *data_start = insert_bh->b_data;\n\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tstruct buffer_head *bh;\n\n\t\t \n\t\tif (ocfs2_free_list_at_root(lookup)) {\n\t\t\tbh = lookup->dl_dx_root_bh;\n\t\t\tretval = ocfs2_journal_access_dr(handle,\n\t\t\t\t\t\t INODE_CACHE(dir), bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t} else {\n\t\t\tbh = lookup->dl_prev_leaf_bh;\n\t\t\tretval = ocfs2_journal_access_db(handle,\n\t\t\t\t\t\t INODE_CACHE(dir), bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t}\n\t\tif (retval) {\n\t\t\tmlog_errno(retval);\n\t\t\treturn retval;\n\t\t}\n\t} else if (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tdata_start = di->id2.i_data.id_data;\n\t\tsize = i_size_read(dir);\n\n\t\tBUG_ON(insert_bh != parent_fe_bh);\n\t}\n\n\trec_len = OCFS2_DIR_REC_LEN(namelen);\n\toffset = 0;\n\tde = (struct ocfs2_dir_entry *) data_start;\n\twhile (1) {\n\t\tBUG_ON((char *)de >= (size + data_start));\n\n\t\t \n\t\tif (!ocfs2_check_dir_entry(dir, de, insert_bh, offset)) {\n\t\t\tretval = -ENOENT;\n\t\t\tgoto bail;\n\t\t}\n\t\tif (ocfs2_match(namelen, name, de)) {\n\t\t\tretval = -EEXIST;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t \n\t\tmlog_bug_on_msg(ocfs2_skip_dir_trailer(dir, de, offset, size),\n\t\t\t\t\"Hit dir trailer trying to insert %.*s \"\n\t\t\t        \"(namelen %d) into directory %llu.  \"\n\t\t\t\t\"offset is %lu, trailer offset is %d\\n\",\n\t\t\t\tnamelen, name, namelen,\n\t\t\t\t(unsigned long long)parent_fe_bh->b_blocknr,\n\t\t\t\toffset, ocfs2_dir_trailer_blk_off(dir->i_sb));\n\n\t\tif (ocfs2_dirent_would_fit(de, rec_len)) {\n\t\t\tdir->i_mtime = inode_set_ctime_current(dir);\n\t\t\tretval = ocfs2_mark_inode_dirty(handle, dir, parent_fe_bh);\n\t\t\tif (retval < 0) {\n\t\t\t\tmlog_errno(retval);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tif (insert_bh == parent_fe_bh)\n\t\t\t\tretval = ocfs2_journal_access_di(handle,\n\t\t\t\t\t\t\t\t INODE_CACHE(dir),\n\t\t\t\t\t\t\t\t insert_bh,\n\t\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\telse {\n\t\t\t\tretval = ocfs2_journal_access_db(handle,\n\t\t\t\t\t\t\t\t INODE_CACHE(dir),\n\t\t\t\t\t\t\t\t insert_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\n\t\t\t\tif (!retval && ocfs2_dir_indexed(dir))\n\t\t\t\t\tretval = ocfs2_dx_dir_insert(dir,\n\t\t\t\t\t\t\t\thandle,\n\t\t\t\t\t\t\t\tlookup);\n\t\t\t}\n\n\t\t\tif (retval) {\n\t\t\t\tmlog_errno(retval);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\t \n\t\t\toffset += le16_to_cpu(de->rec_len);\n\t\t\tif (le64_to_cpu(de->inode)) {\n\t\t\t\tde1 = (struct ocfs2_dir_entry *)((char *) de +\n\t\t\t\t\tOCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde1->rec_len =\n\t\t\t\t\tcpu_to_le16(le16_to_cpu(de->rec_len) -\n\t\t\t\t\tOCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde->rec_len = cpu_to_le16(OCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde = de1;\n\t\t\t}\n\t\t\tde->file_type = FT_UNKNOWN;\n\t\t\tif (blkno) {\n\t\t\t\tde->inode = cpu_to_le64(blkno);\n\t\t\t\tocfs2_set_de_type(de, inode->i_mode);\n\t\t\t} else\n\t\t\t\tde->inode = 0;\n\t\t\tde->name_len = namelen;\n\t\t\tmemcpy(de->name, name, namelen);\n\n\t\t\tif (ocfs2_dir_indexed(dir))\n\t\t\t\tocfs2_recalc_free_list(dir, handle, lookup);\n\n\t\t\tinode_inc_iversion(dir);\n\t\t\tocfs2_journal_dirty(handle, insert_bh);\n\t\t\tretval = 0;\n\t\t\tgoto bail;\n\t\t}\n\n\t\toffset += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *) ((char *) de + le16_to_cpu(de->rec_len));\n\t}\n\n\t \n\tretval = -ENOSPC;\nbail:\n\tif (retval)\n\t\tmlog_errno(retval);\n\n\treturn retval;\n}\n\nstatic int ocfs2_dir_foreach_blk_id(struct inode *inode,\n\t\t\t\t    u64 *f_version,\n\t\t\t\t    struct dir_context *ctx)\n{\n\tint ret, i;\n\tunsigned long offset = ctx->pos;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_inline_data *data;\n\tstruct ocfs2_dir_entry *de;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"Unable to read inode block for dir %llu\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tgoto out;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdata = &di->id2.i_data;\n\n\twhile (ctx->pos < i_size_read(inode)) {\n\t\t \n\t\tif (!inode_eq_iversion(inode, *f_version)) {\n\t\t\tfor (i = 0; i < i_size_read(inode) && i < offset; ) {\n\t\t\t\tde = (struct ocfs2_dir_entry *)\n\t\t\t\t\t(data->id_data + i);\n\t\t\t\t \n\t\t\t\tif (le16_to_cpu(de->rec_len) <\n\t\t\t\t    OCFS2_DIR_REC_LEN(1))\n\t\t\t\t\tbreak;\n\t\t\t\ti += le16_to_cpu(de->rec_len);\n\t\t\t}\n\t\t\tctx->pos = offset = i;\n\t\t\t*f_version = inode_query_iversion(inode);\n\t\t}\n\n\t\tde = (struct ocfs2_dir_entry *) (data->id_data + ctx->pos);\n\t\tif (!ocfs2_check_dir_entry(inode, de, di_bh, ctx->pos)) {\n\t\t\t \n\t\t\tctx->pos = i_size_read(inode);\n\t\t\tbreak;\n\t\t}\n\t\toffset += le16_to_cpu(de->rec_len);\n\t\tif (le64_to_cpu(de->inode)) {\n\t\t\tif (!dir_emit(ctx, de->name, de->name_len,\n\t\t\t\t      le64_to_cpu(de->inode),\n\t\t\t\t      fs_ftype_to_dtype(de->file_type)))\n\t\t\t\tgoto out;\n\t\t}\n\t\tctx->pos += le16_to_cpu(de->rec_len);\n\t}\nout:\n\tbrelse(di_bh);\n\treturn 0;\n}\n\n \nstatic int ocfs2_dir_foreach_blk_el(struct inode *inode,\n\t\t\t\t    u64 *f_version,\n\t\t\t\t    struct dir_context *ctx,\n\t\t\t\t    bool persist)\n{\n\tunsigned long offset, blk, last_ra_blk = 0;\n\tint i;\n\tstruct buffer_head * bh, * tmp;\n\tstruct ocfs2_dir_entry * de;\n\tstruct super_block * sb = inode->i_sb;\n\tunsigned int ra_sectors = 16;\n\tint stored = 0;\n\n\tbh = NULL;\n\n\toffset = ctx->pos & (sb->s_blocksize - 1);\n\n\twhile (ctx->pos < i_size_read(inode)) {\n\t\tblk = ctx->pos >> sb->s_blocksize_bits;\n\t\tif (ocfs2_read_dir_block(inode, blk, &bh, 0)) {\n\t\t\t \n\t\t\tctx->pos += sb->s_blocksize - offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!last_ra_blk\n\t\t    || (((last_ra_blk - blk) << 9) <= (ra_sectors / 2))) {\n\t\t\tfor (i = ra_sectors >> (sb->s_blocksize_bits - 9);\n\t\t\t     i > 0; i--) {\n\t\t\t\ttmp = NULL;\n\t\t\t\tif (!ocfs2_read_dir_block(inode, ++blk, &tmp,\n\t\t\t\t\t\t\t  OCFS2_BH_READAHEAD))\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tlast_ra_blk = blk;\n\t\t\tra_sectors = 8;\n\t\t}\n\n\t\t \n\t\tif (!inode_eq_iversion(inode, *f_version)) {\n\t\t\tfor (i = 0; i < sb->s_blocksize && i < offset; ) {\n\t\t\t\tde = (struct ocfs2_dir_entry *) (bh->b_data + i);\n\t\t\t\t \n\t\t\t\tif (le16_to_cpu(de->rec_len) <\n\t\t\t\t    OCFS2_DIR_REC_LEN(1))\n\t\t\t\t\tbreak;\n\t\t\t\ti += le16_to_cpu(de->rec_len);\n\t\t\t}\n\t\t\toffset = i;\n\t\t\tctx->pos = (ctx->pos & ~(sb->s_blocksize - 1))\n\t\t\t\t| offset;\n\t\t\t*f_version = inode_query_iversion(inode);\n\t\t}\n\n\t\twhile (ctx->pos < i_size_read(inode)\n\t\t       && offset < sb->s_blocksize) {\n\t\t\tde = (struct ocfs2_dir_entry *) (bh->b_data + offset);\n\t\t\tif (!ocfs2_check_dir_entry(inode, de, bh, offset)) {\n\t\t\t\t \n\t\t\t\tctx->pos = (ctx->pos | (sb->s_blocksize - 1)) + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (le64_to_cpu(de->inode)) {\n\t\t\t\tif (!dir_emit(ctx, de->name,\n\t\t\t\t\t\tde->name_len,\n\t\t\t\t\t\tle64_to_cpu(de->inode),\n\t\t\t\t\tfs_ftype_to_dtype(de->file_type))) {\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tstored++;\n\t\t\t}\n\t\t\toffset += le16_to_cpu(de->rec_len);\n\t\t\tctx->pos += le16_to_cpu(de->rec_len);\n\t\t}\n\t\toffset = 0;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\tif (!persist && stored)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int ocfs2_dir_foreach_blk(struct inode *inode, u64 *f_version,\n\t\t\t\t struct dir_context *ctx,\n\t\t\t\t bool persist)\n{\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_dir_foreach_blk_id(inode, f_version, ctx);\n\treturn ocfs2_dir_foreach_blk_el(inode, f_version, ctx, persist);\n}\n\n \nint ocfs2_dir_foreach(struct inode *inode, struct dir_context *ctx)\n{\n\tu64 version = inode_query_iversion(inode);\n\tocfs2_dir_foreach_blk(inode, &version, ctx, true);\n\treturn 0;\n}\n\n \nint ocfs2_readdir(struct file *file, struct dir_context *ctx)\n{\n\tint error = 0;\n\tstruct inode *inode = file_inode(file);\n\tint lock_level = 0;\n\n\ttrace_ocfs2_readdir((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\terror = ocfs2_inode_lock_atime(inode, file->f_path.mnt, &lock_level, 1);\n\tif (lock_level && error >= 0) {\n\t\t \n\t\tocfs2_inode_unlock(inode, 1);\n\t\tlock_level = 0;\n\t\terror = ocfs2_inode_lock(inode, NULL, 0);\n\t}\n\tif (error < 0) {\n\t\tif (error != -ENOENT)\n\t\t\tmlog_errno(error);\n\t\t \n\t\tgoto bail_nolock;\n\t}\n\n\terror = ocfs2_dir_foreach_blk(inode, &file->f_version, ctx, false);\n\n\tocfs2_inode_unlock(inode, lock_level);\n\tif (error)\n\t\tmlog_errno(error);\n\nbail_nolock:\n\n\treturn error;\n}\n\n \nint ocfs2_find_files_on_disk(const char *name,\n\t\t\t     int namelen,\n\t\t\t     u64 *blkno,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ocfs2_dir_lookup_result *lookup)\n{\n\tint status = -ENOENT;\n\n\ttrace_ocfs2_find_files_on_disk(namelen, name, blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_find_entry(name, namelen, inode, lookup);\n\tif (status)\n\t\tgoto leave;\n\n\t*blkno = le64_to_cpu(lookup->dl_entry->inode);\n\n\tstatus = 0;\nleave:\n\n\treturn status;\n}\n\n \nint ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}\n\n \nint ocfs2_check_dir_for_entry(struct inode *dir,\n\t\t\t      const char *name,\n\t\t\t      int namelen)\n{\n\tint ret = 0;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\ttrace_ocfs2_check_dir_for_entry(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen, name);\n\n\tif (ocfs2_find_entry(name, namelen, dir, &lookup) == 0) {\n\t\tret = -EEXIST;\n\t\tmlog_errno(ret);\n\t}\n\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}\n\nstruct ocfs2_empty_dir_priv {\n\tstruct dir_context ctx;\n\tunsigned seen_dot;\n\tunsigned seen_dot_dot;\n\tunsigned seen_other;\n\tunsigned dx_dir;\n};\nstatic bool ocfs2_empty_dir_filldir(struct dir_context *ctx, const char *name,\n\t\t\t\t   int name_len, loff_t pos, u64 ino,\n\t\t\t\t   unsigned type)\n{\n\tstruct ocfs2_empty_dir_priv *p =\n\t\tcontainer_of(ctx, struct ocfs2_empty_dir_priv, ctx);\n\n\t \n\tif (name_len == 1 && !strncmp(\".\", name, 1) && pos == 0) {\n\t\tp->seen_dot = 1;\n\t\treturn true;\n\t}\n\n\tif (name_len == 2 && !strncmp(\"..\", name, 2) &&\n\t    pos == OCFS2_DIR_REC_LEN(1)) {\n\t\tp->seen_dot_dot = 1;\n\n\t\tif (p->dx_dir && p->seen_dot)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\tp->seen_other = 1;\n\treturn false;\n}\n\nstatic int ocfs2_empty_dir_dx(struct inode *inode,\n\t\t\t      struct ocfs2_empty_dir_priv *priv)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tpriv->dx_dir = 1;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_read_dx_root(inode, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\tif (le32_to_cpu(dx_root->dr_num_entries) != 2)\n\t\tpriv->seen_other = 1;\n\nout:\n\tbrelse(di_bh);\n\tbrelse(dx_root_bh);\n\treturn ret;\n}\n\n \nint ocfs2_empty_dir(struct inode *inode)\n{\n\tint ret;\n\tstruct ocfs2_empty_dir_priv priv = {\n\t\t.ctx.actor = ocfs2_empty_dir_filldir,\n\t};\n\n\tif (ocfs2_dir_indexed(inode)) {\n\t\tret = ocfs2_empty_dir_dx(inode, &priv);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\t \n\t}\n\n\tret = ocfs2_dir_foreach(inode, &priv.ctx);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (!priv.seen_dot || !priv.seen_dot_dot) {\n\t\tmlog(ML_ERROR, \"bad directory (dir #%llu) - no `.' or `..'\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\t \n\t\treturn 1;\n\t}\n\n\treturn !priv.seen_other;\n}\n\n \nstatic struct ocfs2_dir_entry *ocfs2_fill_initial_dirents(struct inode *inode,\n\t\t\t\t\t\t\t  struct inode *parent,\n\t\t\t\t\t\t\t  char *start,\n\t\t\t\t\t\t\t  unsigned int size)\n{\n\tstruct ocfs2_dir_entry *de = (struct ocfs2_dir_entry *)start;\n\n\tde->inode = cpu_to_le64(OCFS2_I(inode)->ip_blkno);\n\tde->name_len = 1;\n\tde->rec_len =\n\t\tcpu_to_le16(OCFS2_DIR_REC_LEN(de->name_len));\n\tstrcpy(de->name, \".\");\n\tocfs2_set_de_type(de, S_IFDIR);\n\n\tde = (struct ocfs2_dir_entry *) ((char *)de + le16_to_cpu(de->rec_len));\n\tde->inode = cpu_to_le64(OCFS2_I(parent)->ip_blkno);\n\tde->rec_len = cpu_to_le16(size - OCFS2_DIR_REC_LEN(1));\n\tde->name_len = 2;\n\tstrcpy(de->name, \"..\");\n\tocfs2_set_de_type(de, S_IFDIR);\n\n\treturn de;\n}\n\n \nstatic int ocfs2_fill_new_dir_id(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct inode *parent,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct buffer_head *di_bh)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inline_data *data = &di->id2.i_data;\n\tunsigned int size = le16_to_cpu(data->id_count);\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_fill_initial_dirents(inode, parent, data->id_data, size);\n\tocfs2_journal_dirty(handle, di_bh);\n\n\ti_size_write(inode, size);\n\tset_nlink(inode, 2);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\n\tret = ocfs2_mark_inode_dirty(handle, inode, di_bh);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_fill_new_dir_el(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct inode *parent,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct buffer_head *fe_bh,\n\t\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t\t struct buffer_head **ret_new_bh)\n{\n\tint status;\n\tunsigned int size = osb->sb->s_blocksize;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_dir_entry *de;\n\n\tif (ocfs2_new_dir_wants_trailer(inode))\n\t\tsize = ocfs2_dir_trailer_blk_off(parent->i_sb);\n\n\tstatus = ocfs2_do_extend_dir(osb->sb, handle, inode, fe_bh,\n\t\t\t\t     data_ac, NULL, &new_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), new_bh);\n\n\tstatus = ocfs2_journal_access_db(handle, INODE_CACHE(inode), new_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmemset(new_bh->b_data, 0, osb->sb->s_blocksize);\n\n\tde = ocfs2_fill_initial_dirents(inode, parent, new_bh->b_data, size);\n\tif (ocfs2_new_dir_wants_trailer(inode)) {\n\t\tint size = le16_to_cpu(de->rec_len);\n\n\t\t \n\t\tsize -= OCFS2_DIR_REC_LEN(2);\n\t\tsize -= sizeof(struct ocfs2_dir_block_trailer);\n\n\t\tocfs2_init_dir_trailer(inode, new_bh, size);\n\t}\n\n\tocfs2_journal_dirty(handle, new_bh);\n\n\ti_size_write(inode, inode->i_sb->s_blocksize);\n\tset_nlink(inode, 2);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\tif (ret_new_bh) {\n\t\t*ret_new_bh = new_bh;\n\t\tnew_bh = NULL;\n\t}\nbail:\n\tbrelse(new_bh);\n\n\treturn status;\n}\n\nstatic int ocfs2_dx_dir_attach_index(struct ocfs2_super *osb,\n\t\t\t\t     handle_t *handle, struct inode *dir,\n\t\t\t\t     struct buffer_head *di_bh,\n\t\t\t\t     struct buffer_head *dirdata_bh,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     int dx_inline, u32 num_entries,\n\t\t\t\t     struct buffer_head **ret_dx_root_bh)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tu16 dr_suballoc_bit;\n\tu64 suballoc_loc, dr_blkno;\n\tunsigned int num_bits;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dir_block_trailer *trailer =\n\t\tocfs2_trailer_from_bh(dirdata_bh, dir->i_sb);\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &dr_suballoc_bit, &num_bits, &dr_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_dx_dir_attach_index(\n\t\t\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t(unsigned long long)dr_blkno);\n\n\tdx_root_bh = sb_getblk(osb->sb, dr_blkno);\n\tif (dx_root_bh == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), dx_root_bh);\n\n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tmemset(dx_root, 0, osb->sb->s_blocksize);\n\tstrcpy(dx_root->dr_signature, OCFS2_DX_ROOT_SIGNATURE);\n\tdx_root->dr_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\tdx_root->dr_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tdx_root->dr_suballoc_bit = cpu_to_le16(dr_suballoc_bit);\n\tdx_root->dr_fs_generation = cpu_to_le32(osb->fs_generation);\n\tdx_root->dr_blkno = cpu_to_le64(dr_blkno);\n\tdx_root->dr_dir_blkno = cpu_to_le64(OCFS2_I(dir)->ip_blkno);\n\tdx_root->dr_num_entries = cpu_to_le32(num_entries);\n\tif (le16_to_cpu(trailer->db_free_rec_len))\n\t\tdx_root->dr_free_blk = cpu_to_le64(dirdata_bh->b_blocknr);\n\telse\n\t\tdx_root->dr_free_blk = cpu_to_le64(0);\n\n\tif (dx_inline) {\n\t\tdx_root->dr_flags |= OCFS2_DX_FLAG_INLINE;\n\t\tdx_root->dr_entries.de_count =\n\t\t\tcpu_to_le16(ocfs2_dx_entries_per_root(osb->sb));\n\t} else {\n\t\tdx_root->dr_list.l_count =\n\t\t\tcpu_to_le16(ocfs2_extent_recs_per_dx_root(osb->sb));\n\t}\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(dir), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdi->i_dx_root = cpu_to_le64(dr_blkno);\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tOCFS2_I(dir)->ip_dyn_features |= OCFS2_INDEXED_DIR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(dir)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\t*ret_dx_root_bh = dx_root_bh;\n\tdx_root_bh = NULL;\n\nout:\n\tbrelse(dx_root_bh);\n\treturn ret;\n}\n\nstatic int ocfs2_dx_dir_format_cluster(struct ocfs2_super *osb,\n\t\t\t\t       handle_t *handle, struct inode *dir,\n\t\t\t\t       struct buffer_head **dx_leaves,\n\t\t\t\t       int num_dx_leaves, u64 start_blk)\n{\n\tint ret, i;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tstruct buffer_head *bh;\n\n\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\tbh = sb_getblk(osb->sb, start_blk + i);\n\t\tif (bh == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tdx_leaves[i] = bh;\n\n\t\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), bh);\n\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir), bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdx_leaf = (struct ocfs2_dx_leaf *) bh->b_data;\n\n\t\tmemset(dx_leaf, 0, osb->sb->s_blocksize);\n\t\tstrcpy(dx_leaf->dl_signature, OCFS2_DX_LEAF_SIGNATURE);\n\t\tdx_leaf->dl_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\tdx_leaf->dl_blkno = cpu_to_le64(bh->b_blocknr);\n\t\tdx_leaf->dl_list.de_count =\n\t\t\tcpu_to_le16(ocfs2_dx_entries_per_leaf(osb->sb));\n\n\t\ttrace_ocfs2_dx_dir_format_cluster(\n\t\t\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t(unsigned long long)bh->b_blocknr,\n\t\t\t\tle16_to_cpu(dx_leaf->dl_list.de_count));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\n \nstatic int __ocfs2_dx_dir_new_cluster(struct inode *dir,\n\t\t\t\t      u32 cpos, handle_t *handle,\n\t\t\t\t      struct ocfs2_alloc_context *data_ac,\n\t\t\t\t      struct buffer_head **dx_leaves,\n\t\t\t\t      int num_dx_leaves, u64 *ret_phys_blkno)\n{\n\tint ret;\n\tu32 phys, num;\n\tu64 phys_blkno;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\n\t \n\tret = __ocfs2_claim_clusters(handle, data_ac, 1, 1, &phys, &num);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tphys_blkno = ocfs2_clusters_to_blocks(osb->sb, phys);\n\tret = ocfs2_dx_dir_format_cluster(osb, handle, dir, dx_leaves,\n\t\t\t\t\t  num_dx_leaves, phys_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_phys_blkno = phys_blkno;\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_dx_dir_new_cluster(struct inode *dir,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    u32 cpos, handle_t *handle,\n\t\t\t\t    struct ocfs2_alloc_context *data_ac,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct buffer_head **dx_leaves,\n\t\t\t\t    int num_dx_leaves)\n{\n\tint ret;\n\tu64 phys_blkno;\n\n\tret = __ocfs2_dx_dir_new_cluster(dir, cpos, handle, data_ac, dx_leaves,\n\t\t\t\t\t num_dx_leaves, &phys_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_insert_extent(handle, et, cpos, phys_blkno, 1, 0,\n\t\t\t\t  meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\treturn ret;\n}\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}\n\nstatic int ocfs2_fill_new_dir_dx(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct inode *parent,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct buffer_head *di_bh,\n\t\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t\t struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tstruct buffer_head *leaf_bh = NULL;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_hinfo hinfo;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\t \n\n\tret = ocfs2_fill_new_dir_el(osb, handle, parent, inode, di_bh,\n\t\t\t\t    data_ac, &leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_dx_dir_attach_index(osb, handle, inode, di_bh, leaf_bh,\n\t\t\t\t\tmeta_ac, 1, 2, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tentry_list = &dx_root->dr_entries;\n\n\t \n\tocfs2_dx_dir_name_hash(inode, \".\", 1, &hinfo);\n\tocfs2_dx_entry_list_insert(entry_list, &hinfo, leaf_bh->b_blocknr);\n\n\tocfs2_dx_dir_name_hash(inode, \"..\", 2, &hinfo);\n\tocfs2_dx_entry_list_insert(entry_list, &hinfo, leaf_bh->b_blocknr);\n\nout:\n\tbrelse(dx_root_bh);\n\tbrelse(leaf_bh);\n\treturn ret;\n}\n\nint ocfs2_fill_new_dir(struct ocfs2_super *osb,\n\t\t       handle_t *handle,\n\t\t       struct inode *parent,\n\t\t       struct inode *inode,\n\t\t       struct buffer_head *fe_bh,\n\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t       struct ocfs2_alloc_context *meta_ac)\n\n{\n\tBUG_ON(!ocfs2_supports_inline_data(osb) && data_ac == NULL);\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn ocfs2_fill_new_dir_id(osb, handle, parent, inode, fe_bh);\n\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\treturn ocfs2_fill_new_dir_dx(osb, handle, parent, inode, fe_bh,\n\t\t\t\t\t     data_ac, meta_ac);\n\n\treturn ocfs2_fill_new_dir_el(osb, handle, parent, inode, fe_bh,\n\t\t\t\t     data_ac, NULL);\n}\n\nstatic int ocfs2_dx_dir_index_block(struct inode *dir,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct buffer_head **dx_leaves,\n\t\t\t\t    int num_dx_leaves,\n\t\t\t\t    u32 *num_dx_entries,\n\t\t\t\t    struct buffer_head *dirent_bh)\n{\n\tint ret = 0, namelen, i;\n\tchar *de_buf, *limit;\n\tstruct ocfs2_dir_entry *de;\n\tstruct buffer_head *dx_leaf_bh;\n\tstruct ocfs2_dx_hinfo hinfo;\n\tu64 dirent_blk = dirent_bh->b_blocknr;\n\n\tde_buf = dirent_bh->b_data;\n\tlimit = de_buf + dir->i_sb->s_blocksize;\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tnamelen = de->name_len;\n\t\tif (!namelen || !de->inode)\n\t\t\tgoto inc;\n\n\t\tocfs2_dx_dir_name_hash(dir, de->name, namelen, &hinfo);\n\n\t\ti = ocfs2_dx_dir_hash_idx(OCFS2_SB(dir->i_sb), &hinfo);\n\t\tdx_leaf_bh = dx_leaves[i];\n\n\t\tret = __ocfs2_dx_dir_leaf_insert(dir, handle, &hinfo,\n\t\t\t\t\t\t dirent_blk, dx_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t*num_dx_entries = *num_dx_entries + 1;\n\ninc:\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t}\n\nout:\n\treturn ret;\n}\n\n \nstatic void ocfs2_dx_dir_index_root_block(struct inode *dir,\n\t\t\t\t\t struct buffer_head *dx_root_bh,\n\t\t\t\t\t struct buffer_head *dirent_bh)\n{\n\tchar *de_buf, *limit;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dir_entry *de;\n\tstruct ocfs2_dx_hinfo hinfo;\n\tu64 dirent_blk = dirent_bh->b_blocknr;\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\tde_buf = dirent_bh->b_data;\n\tlimit = de_buf + dir->i_sb->s_blocksize;\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tif (!de->name_len || !de->inode)\n\t\t\tgoto inc;\n\n\t\tocfs2_dx_dir_name_hash(dir, de->name, de->name_len, &hinfo);\n\n\t\ttrace_ocfs2_dx_dir_index_root_block(\n\t\t\t\t(unsigned long long)dir->i_ino,\n\t\t\t\thinfo.major_hash, hinfo.minor_hash,\n\t\t\t\tde->name_len, de->name,\n\t\t\t\tle16_to_cpu(dx_root->dr_entries.de_num_used));\n\n\t\tocfs2_dx_entry_list_insert(&dx_root->dr_entries, &hinfo,\n\t\t\t\t\t   dirent_blk);\n\n\t\tle32_add_cpu(&dx_root->dr_num_entries, 1);\ninc:\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t}\n}\n\n \nstatic int ocfs2_new_dx_should_be_inline(struct inode *dir,\n\t\t\t\t\t struct buffer_head *di_bh)\n{\n\tint dirent_count = 0;\n\tchar *de_buf, *limit;\n\tstruct ocfs2_dir_entry *de;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tde_buf = di->id2.i_data.id_data;\n\tlimit = de_buf + i_size_read(dir);\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tif (de->name_len && de->inode)\n\t\t\tdirent_count++;\n\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t}\n\n\t \n\treturn dirent_count < ocfs2_dx_entries_per_root(dir->i_sb);\n}\n\n \nstatic unsigned int ocfs2_expand_last_dirent(char *start, unsigned int old_size,\n\t\t\t\t\t     struct inode *dir)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ocfs2_dir_entry *de;\n\tstruct ocfs2_dir_entry *prev_de;\n\tchar *de_buf, *limit;\n\tunsigned int new_size = sb->s_blocksize;\n\tunsigned int bytes, this_hole;\n\tunsigned int largest_hole = 0;\n\n\tif (ocfs2_new_dir_wants_trailer(dir))\n\t\tnew_size = ocfs2_dir_trailer_blk_off(sb);\n\n\tbytes = new_size - old_size;\n\n\tlimit = start + old_size;\n\tde_buf = start;\n\tde = (struct ocfs2_dir_entry *)de_buf;\n\tdo {\n\t\tthis_hole = ocfs2_figure_dirent_hole(de);\n\t\tif (this_hole > largest_hole)\n\t\t\tlargest_hole = this_hole;\n\n\t\tprev_de = de;\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\t} while (de_buf < limit);\n\n\tle16_add_cpu(&prev_de->rec_len, bytes);\n\n\t \n\tthis_hole = ocfs2_figure_dirent_hole(prev_de);\n\tif (this_hole > largest_hole)\n\t\tlargest_hole = this_hole;\n\n\tif (largest_hole >= OCFS2_DIR_MIN_REC_LEN)\n\t\treturn largest_hole;\n\treturn 0;\n}\n\n \nstatic int ocfs2_expand_inline_dir(struct inode *dir, struct buffer_head *di_bh,\n\t\t\t\t   unsigned int blocks_wanted,\n\t\t\t\t   struct ocfs2_dir_lookup_result *lookup,\n\t\t\t\t   struct buffer_head **first_block_bh)\n{\n\tu32 alloc, dx_alloc, bit_off, len, num_dx_entries = 0;\n\tstruct super_block *sb = dir->i_sb;\n\tint ret, i, num_dx_leaves = 0, dx_inline = 0,\n\t\tcredits = ocfs2_inline_to_extents_credits(sb);\n\tu64 dx_insert_blkno, blkno,\n\t\tbytes = blocks_wanted << sb->s_blocksize_bits;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(dir);\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct buffer_head *dirdata_bh = NULL;\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct buffer_head **dx_leaves = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\thandle_t *handle;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_extent_tree dx_et;\n\tint did_quota = 0, bytes_allocated = 0;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(dir), di_bh);\n\n\talloc = ocfs2_clusters_for_bytes(sb, bytes);\n\tdx_alloc = 0;\n\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (ocfs2_supports_indexed_dirs(osb)) {\n\t\tcredits += ocfs2_add_dir_index_credits(sb);\n\n\t\tdx_inline = ocfs2_new_dx_should_be_inline(dir, di_bh);\n\t\tif (!dx_inline) {\n\t\t\t \n\t\t\tdx_alloc++;\n\t\t\tdx_leaves = ocfs2_dx_dir_kmalloc_leaves(sb,\n\t\t\t\t\t\t\t\t&num_dx_leaves);\n\t\t\tif (!dx_leaves) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, &meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tBUG_ON(alloc > 2);\n\n\tret = ocfs2_reserve_clusters(osb, alloc + dx_alloc, &data_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tif (alloc == 2)\n\t\tcredits += OCFS2_SUBALLOC_ALLOC;\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = dquot_alloc_space_nodirty(dir,\n\t\tocfs2_clusters_to_bytes(osb->sb, alloc + dx_alloc));\n\tif (ret)\n\t\tgoto out_commit;\n\tdid_quota = 1;\n\n\tif (ocfs2_supports_indexed_dirs(osb) && !dx_inline) {\n\t\t \n\t\tret = __ocfs2_dx_dir_new_cluster(dir, 0, handle, data_ac,\n\t\t\t\t\t\t dx_leaves, num_dx_leaves,\n\t\t\t\t\t\t &dx_insert_blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t\tbytes_allocated += ocfs2_clusters_to_bytes(dir->i_sb, 1);\n\t}\n\n\t \n\tif (ocfs2_dir_resv_allowed(osb))\n\t\tdata_ac->ac_resv = &oi->ip_la_data_resv;\n\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off, &len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\tbytes_allocated += ocfs2_clusters_to_bytes(dir->i_sb, 1);\n\n\t \n\tblkno = ocfs2_clusters_to_blocks(dir->i_sb, bit_off);\n\tdirdata_bh = sb_getblk(sb, blkno);\n\tif (!dirdata_bh) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), dirdata_bh);\n\n\tret = ocfs2_journal_access_db(handle, INODE_CACHE(dir), dirdata_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tmemcpy(dirdata_bh->b_data, di->id2.i_data.id_data, i_size_read(dir));\n\tmemset(dirdata_bh->b_data + i_size_read(dir), 0,\n\t       sb->s_blocksize - i_size_read(dir));\n\ti = ocfs2_expand_last_dirent(dirdata_bh->b_data, i_size_read(dir), dir);\n\tif (ocfs2_new_dir_wants_trailer(dir)) {\n\t\t \n\t\tocfs2_init_dir_trailer(dir, dirdata_bh, i);\n\t}\n\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_journal_dirty(handle, dirdata_bh);\n\n\tif (ocfs2_supports_indexed_dirs(osb) && !dx_inline) {\n\t\t \n\t\tret = ocfs2_dx_dir_index_block(dir, handle, dx_leaves,\n\t\t\t\t\t       num_dx_leaves, &num_dx_entries,\n\t\t\t\t\t       dirdata_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\t \n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(dir), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_dinode_new_extent_list(dir, di);\n\n\ti_size_write(dir, sb->s_blocksize);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\n\tdi->i_size = cpu_to_le64(sb->s_blocksize);\n\tdi->i_ctime = di->i_mtime = cpu_to_le64(inode_get_ctime(dir).tv_sec);\n\tdi->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(inode_get_ctime(dir).tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\n\t \n\tret = ocfs2_insert_extent(handle, &et, 0, blkno, len,\n\t\t\t\t  0, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t \n\tdir->i_blocks = ocfs2_inode_sector_count(dir);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tif (ocfs2_supports_indexed_dirs(osb)) {\n\t\tret = ocfs2_dx_dir_attach_index(osb, handle, dir, di_bh,\n\t\t\t\t\t\tdirdata_bh, meta_ac, dx_inline,\n\t\t\t\t\t\tnum_dx_entries, &dx_root_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tif (dx_inline) {\n\t\t\tocfs2_dx_dir_index_root_block(dir, dx_root_bh,\n\t\t\t\t\t\t      dirdata_bh);\n\t\t} else {\n\t\t\tocfs2_init_dx_root_extent_tree(&dx_et,\n\t\t\t\t\t\t       INODE_CACHE(dir),\n\t\t\t\t\t\t       dx_root_bh);\n\t\t\tret = ocfs2_insert_extent(handle, &dx_et, 0,\n\t\t\t\t\t\t  dx_insert_blkno, 1, 0, NULL);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t}\n\t}\n\n\t \n\tif (alloc > len) {\n\t\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off,\n\t\t\t\t\t   &len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t\tblkno = ocfs2_clusters_to_blocks(dir->i_sb, bit_off);\n\n\t\tret = ocfs2_insert_extent(handle, &et, 1,\n\t\t\t\t\t  blkno, len, 0, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t\tbytes_allocated += ocfs2_clusters_to_bytes(dir->i_sb, 1);\n\t}\n\n\t*first_block_bh = dirdata_bh;\n\tdirdata_bh = NULL;\n\tif (ocfs2_supports_indexed_dirs(osb)) {\n\t\tunsigned int off;\n\n\t\tif (!dx_inline) {\n\t\t\t \n\t\t\toff = ocfs2_dx_dir_hash_idx(osb,\n\t\t\t\t\t\t    &lookup->dl_hinfo);\n\t\t\tget_bh(dx_leaves[off]);\n\t\t\tlookup->dl_dx_leaf_bh = dx_leaves[off];\n\t\t}\n\t\tlookup->dl_dx_root_bh = dx_root_bh;\n\t\tdx_root_bh = NULL;\n\t}\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(dir, bytes_allocated);\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tup_write(&oi->ip_alloc_sem);\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tif (dx_leaves) {\n\t\tfor (i = 0; i < num_dx_leaves; i++)\n\t\t\tbrelse(dx_leaves[i]);\n\t\tkfree(dx_leaves);\n\t}\n\n\tbrelse(dirdata_bh);\n\tbrelse(dx_root_bh);\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_do_extend_dir(struct super_block *sb,\n\t\t\t       handle_t *handle,\n\t\t\t       struct inode *dir,\n\t\t\t       struct buffer_head *parent_fe_bh,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct buffer_head **new_bh)\n{\n\tint status;\n\tint extend, did_quota = 0;\n\tu64 p_blkno, v_blkno;\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\textend = (i_size_read(dir) == ocfs2_clusters_to_bytes(sb, OCFS2_I(dir)->ip_clusters));\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\n\tif (extend) {\n\t\tu32 offset = OCFS2_I(dir)->ip_clusters;\n\n\t\tstatus = dquot_alloc_space_nodirty(dir,\n\t\t\t\t\tocfs2_clusters_to_bytes(sb, 1));\n\t\tif (status)\n\t\t\tgoto bail;\n\t\tdid_quota = 1;\n\n\t\tstatus = ocfs2_add_inode_data(OCFS2_SB(sb), dir, &offset,\n\t\t\t\t\t      1, 0, parent_fe_bh, handle,\n\t\t\t\t\t      data_ac, meta_ac, NULL);\n\t\tBUG_ON(status == -EAGAIN);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tv_blkno = ocfs2_blocks_for_bytes(sb, i_size_read(dir));\n\tstatus = ocfs2_extent_map_get_blocks(dir, v_blkno, &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*new_bh = sb_getblk(sb, p_blkno);\n\tif (!*new_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tstatus = 0;\nbail:\n\tif (did_quota && status < 0)\n\t\tdquot_free_space_nodirty(dir, ocfs2_clusters_to_bytes(sb, 1));\n\treturn status;\n}\n\n \nstatic int ocfs2_extend_dir(struct ocfs2_super *osb,\n\t\t\t    struct inode *dir,\n\t\t\t    struct buffer_head *parent_fe_bh,\n\t\t\t    unsigned int blocks_wanted,\n\t\t\t    struct ocfs2_dir_lookup_result *lookup,\n\t\t\t    struct buffer_head **new_de_bh)\n{\n\tint status = 0;\n\tint credits, num_free_extents, drop_alloc_sem = 0;\n\tloff_t dir_i_size;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) parent_fe_bh->b_data;\n\tstruct ocfs2_extent_list *el = &fe->id2.i_list;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\thandle_t *handle = NULL;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_dir_entry * de;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_extent_tree et;\n\tstruct buffer_head *dx_root_bh = lookup->dl_dx_root_bh;\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\t \n\t\tBUG_ON(dx_root_bh);\n\n\t\tstatus = ocfs2_expand_inline_dir(dir, parent_fe_bh,\n\t\t\t\t\t\t blocks_wanted, lookup,\n\t\t\t\t\t\t &new_bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t \n\t\tdx_root_bh = lookup->dl_dx_root_bh;\n\n\t\tif (blocks_wanted == 1) {\n\t\t\t \n\t\t\tBUG_ON(new_bh == NULL);\n\t\t\tgoto bail_bh;\n\t\t}\n\n\t\t \n\t\tbrelse(new_bh);\n\t\tnew_bh = NULL;\n\n\t\tdown_write(&OCFS2_I(dir)->ip_alloc_sem);\n\t\tdrop_alloc_sem = 1;\n\t\tdir_i_size = i_size_read(dir);\n\t\tcredits = OCFS2_SIMPLE_DIR_EXTEND_CREDITS;\n\t\tgoto do_extend;\n\t}\n\n\tdown_write(&OCFS2_I(dir)->ip_alloc_sem);\n\tdrop_alloc_sem = 1;\n\tdir_i_size = i_size_read(dir);\n\ttrace_ocfs2_extend_dir((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t       dir_i_size);\n\n\t \n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tif (dir_i_size == ocfs2_clusters_to_bytes(sb, OCFS2_I(dir)->ip_clusters)) {\n\t\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(dir),\n\t\t\t\t\t      parent_fe_bh);\n\t\tnum_free_extents = ocfs2_num_free_extents(&et);\n\t\tif (num_free_extents < 0) {\n\t\t\tstatus = num_free_extents;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!num_free_extents) {\n\t\t\tstatus = ocfs2_reserve_new_metadata(osb, el, &meta_ac);\n\t\t\tif (status < 0) {\n\t\t\t\tif (status != -ENOSPC)\n\t\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tstatus = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (ocfs2_dir_resv_allowed(osb))\n\t\t\tdata_ac->ac_resv = &OCFS2_I(dir)->ip_la_data_resv;\n\n\t\tcredits = ocfs2_calc_extend_credits(sb, el);\n\t} else {\n\t\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\t\tcredits = OCFS2_SIMPLE_DIR_EXTEND_CREDITS;\n\t}\n\ndo_extend:\n\tif (ocfs2_dir_indexed(dir))\n\t\tcredits++;  \n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_do_extend_dir(osb->sb, handle, dir, parent_fe_bh,\n\t\t\t\t     data_ac, meta_ac, &new_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(dir), new_bh);\n\n\tstatus = ocfs2_journal_access_db(handle, INODE_CACHE(dir), new_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmemset(new_bh->b_data, 0, sb->s_blocksize);\n\n\tde = (struct ocfs2_dir_entry *) new_bh->b_data;\n\tde->inode = 0;\n\tif (ocfs2_supports_dir_trailer(dir)) {\n\t\tde->rec_len = cpu_to_le16(ocfs2_dir_trailer_blk_off(sb));\n\n\t\tocfs2_init_dir_trailer(dir, new_bh, le16_to_cpu(de->rec_len));\n\n\t\tif (ocfs2_dir_indexed(dir)) {\n\t\t\tstatus = ocfs2_dx_dir_link_trailer(dir, handle,\n\t\t\t\t\t\t\t   dx_root_bh, new_bh);\n\t\t\tif (status) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tde->rec_len = cpu_to_le16(sb->s_blocksize);\n\t}\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_journal_dirty(handle, new_bh);\n\n\tdir_i_size += dir->i_sb->s_blocksize;\n\ti_size_write(dir, dir_i_size);\n\tdir->i_blocks = ocfs2_inode_sector_count(dir);\n\tstatus = ocfs2_mark_inode_dirty(handle, dir, parent_fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail_bh:\n\t*new_de_bh = new_bh;\n\tget_bh(*new_de_bh);\nbail:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\tif (drop_alloc_sem)\n\t\tup_write(&OCFS2_I(dir)->ip_alloc_sem);\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tbrelse(new_bh);\n\n\treturn status;\n}\n\nstatic int ocfs2_find_dir_space_id(struct inode *dir, struct buffer_head *di_bh,\n\t\t\t\t   const char *name, int namelen,\n\t\t\t\t   struct buffer_head **ret_de_bh,\n\t\t\t\t   unsigned int *blocks_wanted)\n{\n\tint ret;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_dir_entry *de, *last_de = NULL;\n\tchar *de_buf, *limit;\n\tunsigned long offset = 0;\n\tunsigned int rec_len, new_rec_len, free_space;\n\n\t \n\tif (ocfs2_new_dir_wants_trailer(dir))\n\t\tfree_space = ocfs2_dir_trailer_blk_off(sb) - i_size_read(dir);\n\telse\n\t\tfree_space = dir->i_sb->s_blocksize - i_size_read(dir);\n\n\tde_buf = di->id2.i_data.id_data;\n\tlimit = de_buf + i_size_read(dir);\n\trec_len = OCFS2_DIR_REC_LEN(namelen);\n\n\twhile (de_buf < limit) {\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\n\t\tif (!ocfs2_check_dir_entry(dir, de, di_bh, offset)) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ocfs2_match(namelen, name, de)) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\n\t\tif (ocfs2_dirent_would_fit(de, rec_len)) {\n\t\t\t \n\t\t\t*ret_de_bh = di_bh;\n\t\t\tget_bh(*ret_de_bh);\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlast_de = de;\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\toffset += le16_to_cpu(de->rec_len);\n\t}\n\n\t \n\t*blocks_wanted = 1;\n\tnew_rec_len = le16_to_cpu(last_de->rec_len) + free_space;\n\tif (new_rec_len < (rec_len + OCFS2_DIR_REC_LEN(last_de->name_len)))\n\t\t*blocks_wanted = 2;\n\n\tret = -ENOSPC;\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_find_dir_space_el(struct inode *dir, const char *name,\n\t\t\t\t   int namelen, struct buffer_head **ret_de_bh)\n{\n\tunsigned long offset;\n\tstruct buffer_head *bh = NULL;\n\tunsigned short rec_len;\n\tstruct ocfs2_dir_entry *de;\n\tstruct super_block *sb = dir->i_sb;\n\tint status;\n\tint blocksize = dir->i_sb->s_blocksize;\n\n\tstatus = ocfs2_read_dir_block(dir, 0, &bh, 0);\n\tif (status)\n\t\tgoto bail;\n\n\trec_len = OCFS2_DIR_REC_LEN(namelen);\n\toffset = 0;\n\tde = (struct ocfs2_dir_entry *) bh->b_data;\n\twhile (1) {\n\t\tif ((char *)de >= sb->s_blocksize + bh->b_data) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\n\t\t\tif (i_size_read(dir) <= offset) {\n\t\t\t\t \n\t\t\t\tstatus = -ENOSPC;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tstatus = ocfs2_read_dir_block(dir,\n\t\t\t\t\t     offset >> sb->s_blocksize_bits,\n\t\t\t\t\t     &bh, 0);\n\t\t\tif (status)\n\t\t\t\tgoto bail;\n\n\t\t\t \n\t\t\tde = (struct ocfs2_dir_entry *) bh->b_data;\n\t\t}\n\t\tif (!ocfs2_check_dir_entry(dir, de, bh, offset)) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto bail;\n\t\t}\n\t\tif (ocfs2_match(namelen, name, de)) {\n\t\t\tstatus = -EEXIST;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (ocfs2_skip_dir_trailer(dir, de, offset % blocksize,\n\t\t\t\t\t   blocksize))\n\t\t\tgoto next;\n\n\t\tif (ocfs2_dirent_would_fit(de, rec_len)) {\n\t\t\t \n\t\t\t*ret_de_bh = bh;\n\t\t\tget_bh(*ret_de_bh);\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\nnext:\n\t\toffset += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)((char *) de + le16_to_cpu(de->rec_len));\n\t}\n\nbail:\n\tbrelse(bh);\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}\n\nstatic int dx_leaf_sort_cmp(const void *a, const void *b)\n{\n\tconst struct ocfs2_dx_entry *entry1 = a;\n\tconst struct ocfs2_dx_entry *entry2 = b;\n\tu32 major_hash1 = le32_to_cpu(entry1->dx_major_hash);\n\tu32 major_hash2 = le32_to_cpu(entry2->dx_major_hash);\n\tu32 minor_hash1 = le32_to_cpu(entry1->dx_minor_hash);\n\tu32 minor_hash2 = le32_to_cpu(entry2->dx_minor_hash);\n\n\tif (major_hash1 > major_hash2)\n\t\treturn 1;\n\tif (major_hash1 < major_hash2)\n\t\treturn -1;\n\n\t \n\tif (minor_hash1 > minor_hash2)\n\t\treturn 1;\n\tif (minor_hash1 < minor_hash2)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void dx_leaf_sort_swap(void *a, void *b, int size)\n{\n\tstruct ocfs2_dx_entry *entry1 = a;\n\tstruct ocfs2_dx_entry *entry2 = b;\n\n\tBUG_ON(size != sizeof(*entry1));\n\n\tswap(*entry1, *entry2);\n}\n\nstatic int ocfs2_dx_leaf_same_major(struct ocfs2_dx_leaf *dx_leaf)\n{\n\tstruct ocfs2_dx_entry_list *dl_list = &dx_leaf->dl_list;\n\tint i, num = le16_to_cpu(dl_list->de_num_used);\n\n\tfor (i = 0; i < (num - 1); i++) {\n\t\tif (le32_to_cpu(dl_list->de_entries[i].dx_major_hash) !=\n\t\t    le32_to_cpu(dl_list->de_entries[i + 1].dx_major_hash))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic int ocfs2_dx_dir_find_leaf_split(struct ocfs2_dx_leaf *dx_leaf,\n\t\t\t\t\tu32 leaf_cpos, u32 insert_hash,\n\t\t\t\t\tu32 *split_hash)\n{\n\tstruct ocfs2_dx_entry_list *dl_list = &dx_leaf->dl_list;\n\tint i, num_used = le16_to_cpu(dl_list->de_num_used);\n\tint allsame;\n\n\t \n\tallsame = ocfs2_dx_leaf_same_major(dx_leaf);\n\tif (allsame) {\n\t\tu32 val = le32_to_cpu(dl_list->de_entries[0].dx_major_hash);\n\n\t\tif (val == insert_hash) {\n\t\t\t \n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tif (val == leaf_cpos) {\n\t\t\t \n\t\t\t*split_hash = leaf_cpos + 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (val > insert_hash) {\n\t\t\t \n\t\t\t*split_hash = val;\n\t\t\treturn 0;\n\t\t}\n\n\t\t*split_hash = insert_hash;\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = (num_used / 2); i < num_used; i++)\n\t\tif (le32_to_cpu(dl_list->de_entries[i].dx_major_hash) >\n\t\t    leaf_cpos)\n\t\t\tbreak;\n\n\tBUG_ON(i == num_used);  \n\t*split_hash = le32_to_cpu(dl_list->de_entries[i].dx_major_hash);\n\treturn 0;\n}\n\n \nstatic void ocfs2_dx_dir_transfer_leaf(struct inode *dir, u32 split_hash,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct ocfs2_dx_leaf *tmp_dx_leaf,\n\t\t\t\t       struct buffer_head **orig_dx_leaves,\n\t\t\t\t       struct buffer_head **new_dx_leaves,\n\t\t\t\t       int num_dx_leaves)\n{\n\tint i, j, num_used;\n\tu32 major_hash;\n\tstruct ocfs2_dx_leaf *orig_dx_leaf, *new_dx_leaf;\n\tstruct ocfs2_dx_entry_list *orig_list, *tmp_list;\n\tstruct ocfs2_dx_entry *dx_entry;\n\n\ttmp_list = &tmp_dx_leaf->dl_list;\n\n\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\torig_dx_leaf = (struct ocfs2_dx_leaf *) orig_dx_leaves[i]->b_data;\n\t\torig_list = &orig_dx_leaf->dl_list;\n\t\tnew_dx_leaf = (struct ocfs2_dx_leaf *) new_dx_leaves[i]->b_data;\n\n\t\tnum_used = le16_to_cpu(orig_list->de_num_used);\n\n\t\tmemcpy(tmp_dx_leaf, orig_dx_leaf, dir->i_sb->s_blocksize);\n\t\ttmp_list->de_num_used = cpu_to_le16(0);\n\t\tmemset(&tmp_list->de_entries, 0, sizeof(*dx_entry)*num_used);\n\n\t\tfor (j = 0; j < num_used; j++) {\n\t\t\tdx_entry = &orig_list->de_entries[j];\n\t\t\tmajor_hash = le32_to_cpu(dx_entry->dx_major_hash);\n\t\t\tif (major_hash >= split_hash)\n\t\t\t\tocfs2_dx_dir_leaf_insert_tail(new_dx_leaf,\n\t\t\t\t\t\t\t      dx_entry);\n\t\t\telse\n\t\t\t\tocfs2_dx_dir_leaf_insert_tail(tmp_dx_leaf,\n\t\t\t\t\t\t\t      dx_entry);\n\t\t}\n\t\tmemcpy(orig_dx_leaf, tmp_dx_leaf, dir->i_sb->s_blocksize);\n\n\t\tocfs2_journal_dirty(handle, orig_dx_leaves[i]);\n\t\tocfs2_journal_dirty(handle, new_dx_leaves[i]);\n\t}\n}\n\nstatic int ocfs2_dx_dir_rebalance_credits(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_dx_root_block *dx_root)\n{\n\tint credits = ocfs2_clusters_to_blocks(osb->sb, 3);\n\n\tcredits += ocfs2_calc_extend_credits(osb->sb, &dx_root->dr_list);\n\tcredits += ocfs2_quota_trans_credits(osb->sb);\n\treturn credits;\n}\n\n \nstatic int ocfs2_dx_dir_rebalance(struct ocfs2_super *osb, struct inode *dir,\n\t\t\t\t  struct buffer_head *dx_root_bh,\n\t\t\t\t  struct buffer_head *dx_leaf_bh,\n\t\t\t\t  struct ocfs2_dx_hinfo *hinfo, u32 leaf_cpos,\n\t\t\t\t  u64 leaf_blkno)\n{\n\tstruct ocfs2_dx_leaf *dx_leaf = (struct ocfs2_dx_leaf *)dx_leaf_bh->b_data;\n\tint credits, ret, i, num_used, did_quota = 0;\n\tu32 cpos, split_hash, insert_hash = hinfo->major_hash;\n\tu64 orig_leaves_start;\n\tint num_dx_leaves;\n\tstruct buffer_head **orig_dx_leaves = NULL;\n\tstruct buffer_head **new_dx_leaves = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL, *meta_ac = NULL;\n\tstruct ocfs2_extent_tree et;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_leaf *tmp_dx_leaf = NULL;\n\n\ttrace_ocfs2_dx_dir_rebalance((unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t     (unsigned long long)leaf_blkno,\n\t\t\t\t     insert_hash);\n\n\tocfs2_init_dx_root_extent_tree(&et, INODE_CACHE(dir), dx_root_bh);\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\t \n\tif (le32_to_cpu(dx_root->dr_clusters) == UINT_MAX)\n\t\treturn -ENOSPC;\n\n\tnum_used = le16_to_cpu(dx_leaf->dl_list.de_num_used);\n\tif (num_used < le16_to_cpu(dx_leaf->dl_list.de_count)) {\n\t\tmlog(ML_ERROR, \"DX Dir: %llu, Asked to rebalance empty leaf: \"\n\t\t     \"%llu, %d\\n\", (unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t     (unsigned long long)leaf_blkno, num_used);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\torig_dx_leaves = ocfs2_dx_dir_kmalloc_leaves(osb->sb, &num_dx_leaves);\n\tif (!orig_dx_leaves) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnew_dx_leaves = ocfs2_dx_dir_kmalloc_leaves(osb->sb, NULL);\n\tif (!new_dx_leaves) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_lock_allocators(dir, &et, 1, 0, &data_ac, &meta_ac);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcredits = ocfs2_dx_dir_rebalance_credits(osb, dx_root);\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = dquot_alloc_space_nodirty(dir,\n\t\t\t\t       ocfs2_clusters_to_bytes(dir->i_sb, 1));\n\tif (ret)\n\t\tgoto out_commit;\n\tdid_quota = 1;\n\n\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir), dx_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t \n\tsort(dx_leaf->dl_list.de_entries, num_used,\n\t     sizeof(struct ocfs2_dx_entry), dx_leaf_sort_cmp,\n\t     dx_leaf_sort_swap);\n\n\tocfs2_journal_dirty(handle, dx_leaf_bh);\n\n\tret = ocfs2_dx_dir_find_leaf_split(dx_leaf, leaf_cpos, insert_hash,\n\t\t\t\t\t   &split_hash);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto  out_commit;\n\t}\n\n\ttrace_ocfs2_dx_dir_rebalance_split(leaf_cpos, split_hash, insert_hash);\n\n\t \n\n\t \n\ttmp_dx_leaf = kmalloc(osb->sb->s_blocksize, GFP_NOFS);\n\tif (!tmp_dx_leaf) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\torig_leaves_start = ocfs2_block_to_cluster_start(dir->i_sb, leaf_blkno);\n\tret = ocfs2_read_dx_leaves(dir, orig_leaves_start, num_dx_leaves,\n\t\t\t\t   orig_dx_leaves);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tcpos = split_hash;\n\tret = ocfs2_dx_dir_new_cluster(dir, &et, cpos, handle,\n\t\t\t\t       data_ac, meta_ac, new_dx_leaves,\n\t\t\t\t       num_dx_leaves);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir),\n\t\t\t\t\t      orig_dx_leaves[i],\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tret = ocfs2_journal_access_dl(handle, INODE_CACHE(dir),\n\t\t\t\t\t      new_dx_leaves[i],\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\tocfs2_dx_dir_transfer_leaf(dir, split_hash, handle, tmp_dx_leaf,\n\t\t\t\t   orig_dx_leaves, new_dx_leaves, num_dx_leaves);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(dir,\n\t\t\t\tocfs2_clusters_to_bytes(dir->i_sb, 1));\n\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (orig_dx_leaves || new_dx_leaves) {\n\t\tfor (i = 0; i < num_dx_leaves; i++) {\n\t\t\tif (orig_dx_leaves)\n\t\t\t\tbrelse(orig_dx_leaves[i]);\n\t\t\tif (new_dx_leaves)\n\t\t\t\tbrelse(new_dx_leaves[i]);\n\t\t}\n\t\tkfree(orig_dx_leaves);\n\t\tkfree(new_dx_leaves);\n\t}\n\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\n\tkfree(tmp_dx_leaf);\n\treturn ret;\n}\n\nstatic int ocfs2_find_dir_space_dx(struct ocfs2_super *osb, struct inode *dir,\n\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t   struct buffer_head *dx_root_bh,\n\t\t\t\t   const char *name, int namelen,\n\t\t\t\t   struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret, rebalanced = 0;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct buffer_head *dx_leaf_bh = NULL;\n\tstruct ocfs2_dx_leaf *dx_leaf;\n\tu64 blkno;\n\tu32 leaf_cpos;\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\nrestart_search:\n\tret = ocfs2_dx_dir_lookup(dir, &dx_root->dr_list, &lookup->dl_hinfo,\n\t\t\t\t  &leaf_cpos, &blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_dx_leaf(dir, blkno, &dx_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaf = (struct ocfs2_dx_leaf *)dx_leaf_bh->b_data;\n\n\tif (le16_to_cpu(dx_leaf->dl_list.de_num_used) >=\n\t    le16_to_cpu(dx_leaf->dl_list.de_count)) {\n\t\tif (rebalanced) {\n\t\t\t \n\t\t\tret = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_dx_dir_rebalance(osb, dir, dx_root_bh, dx_leaf_bh,\n\t\t\t\t\t     &lookup->dl_hinfo, leaf_cpos,\n\t\t\t\t\t     blkno);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tbrelse(dx_leaf_bh);\n\t\tdx_leaf_bh = NULL;\n\t\trebalanced = 1;\n\t\tgoto restart_search;\n\t}\n\n\tlookup->dl_dx_leaf_bh = dx_leaf_bh;\n\tdx_leaf_bh = NULL;\n\nout:\n\tbrelse(dx_leaf_bh);\n\treturn ret;\n}\n\nstatic int ocfs2_search_dx_free_list(struct inode *dir,\n\t\t\t\t     struct buffer_head *dx_root_bh,\n\t\t\t\t     int namelen,\n\t\t\t\t     struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret = -ENOSPC;\n\tstruct buffer_head *leaf_bh = NULL, *prev_leaf_bh = NULL;\n\tstruct ocfs2_dir_block_trailer *db;\n\tu64 next_block;\n\tint rec_len = OCFS2_DIR_REC_LEN(namelen);\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tnext_block = le64_to_cpu(dx_root->dr_free_blk);\n\n\twhile (next_block) {\n\t\tbrelse(prev_leaf_bh);\n\t\tprev_leaf_bh = leaf_bh;\n\t\tleaf_bh = NULL;\n\n\t\tret = ocfs2_read_dir_block_direct(dir, next_block, &leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdb = ocfs2_trailer_from_bh(leaf_bh, dir->i_sb);\n\t\tif (rec_len <= le16_to_cpu(db->db_free_rec_len)) {\n\t\t\tlookup->dl_leaf_bh = leaf_bh;\n\t\t\tlookup->dl_prev_leaf_bh = prev_leaf_bh;\n\t\t\tleaf_bh = NULL;\n\t\t\tprev_leaf_bh = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tnext_block = le64_to_cpu(db->db_free_next);\n\t}\n\n\tif (!next_block)\n\t\tret = -ENOSPC;\n\nout:\n\n\tbrelse(leaf_bh);\n\tbrelse(prev_leaf_bh);\n\treturn ret;\n}\n\nstatic int ocfs2_expand_inline_dx_root(struct inode *dir,\n\t\t\t\t       struct buffer_head *dx_root_bh)\n{\n\tint ret, num_dx_leaves, i, j, did_quota = 0;\n\tstruct buffer_head **dx_leaves = NULL;\n\tstruct ocfs2_extent_tree et;\n\tu64 insert_blkno;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\tstruct ocfs2_dx_entry *dx_entry;\n\tstruct ocfs2_dx_leaf *target_leaf;\n\n\tret = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_leaves = ocfs2_dx_dir_kmalloc_leaves(osb->sb, &num_dx_leaves);\n\tif (!dx_leaves) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_calc_dxi_expand_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = dquot_alloc_space_nodirty(dir,\n\t\t\t\t       ocfs2_clusters_to_bytes(osb->sb, 1));\n\tif (ret)\n\t\tgoto out_commit;\n\tdid_quota = 1;\n\n\t \n\tret = ocfs2_journal_access_dr(handle, INODE_CACHE(dir), dx_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = __ocfs2_dx_dir_new_cluster(dir, 0, handle, data_ac, dx_leaves,\n\t\t\t\t\t num_dx_leaves, &insert_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t \n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\tentry_list = &dx_root->dr_entries;\n\n\tfor (i = 0; i < le16_to_cpu(entry_list->de_num_used); i++) {\n\t\tdx_entry = &entry_list->de_entries[i];\n\n\t\tj = __ocfs2_dx_dir_hash_idx(osb,\n\t\t\t\t\t    le32_to_cpu(dx_entry->dx_minor_hash));\n\t\ttarget_leaf = (struct ocfs2_dx_leaf *)dx_leaves[j]->b_data;\n\n\t\tocfs2_dx_dir_leaf_insert_tail(target_leaf, dx_entry);\n\n\t\t \n\t}\n\n\tdx_root->dr_flags &= ~OCFS2_DX_FLAG_INLINE;\n\tmemset(&dx_root->dr_list, 0, osb->sb->s_blocksize -\n\t       offsetof(struct ocfs2_dx_root_block, dr_list));\n\tdx_root->dr_list.l_count =\n\t\tcpu_to_le16(ocfs2_extent_recs_per_dx_root(osb->sb));\n\n\t \n\tocfs2_init_dx_root_extent_tree(&et, INODE_CACHE(dir), dx_root_bh);\n\tret = ocfs2_insert_extent(handle, &et, 0, insert_blkno, 1, 0, NULL);\n\tif (ret)\n\t\tmlog_errno(ret);\n\tdid_quota = 0;\n\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\tocfs2_journal_dirty(handle, dx_root_bh);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(dir,\n\t\t\t\t\t  ocfs2_clusters_to_bytes(dir->i_sb, 1));\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\n\tif (dx_leaves) {\n\t\tfor (i = 0; i < num_dx_leaves; i++)\n\t\t\tbrelse(dx_leaves[i]);\n\t\tkfree(dx_leaves);\n\t}\n\treturn ret;\n}\n\nstatic int ocfs2_inline_dx_has_space(struct buffer_head *dx_root_bh)\n{\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dx_entry_list *entry_list;\n\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\tentry_list = &dx_root->dr_entries;\n\n\tif (le16_to_cpu(entry_list->de_num_used) >=\n\t    le16_to_cpu(entry_list->de_count))\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}\n\nstatic int ocfs2_prepare_dx_dir_for_insert(struct inode *dir,\n\t\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t\t   const char *name,\n\t\t\t\t\t   int namelen,\n\t\t\t\t\t   struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret, free_dx_root = 1;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct buffer_head *leaf_bh = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_dx_root_block *dx_root;\n\n\tret = ocfs2_read_dx_root(dir, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\tif (le32_to_cpu(dx_root->dr_num_entries) == OCFS2_DX_ENTRIES_MAX) {\n\t\tret = -ENOSPC;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_dx_root_inline(dx_root)) {\n\t\tret = ocfs2_inline_dx_has_space(dx_root_bh);\n\n\t\tif (ret == 0)\n\t\t\tgoto search_el;\n\n\t\t \n\t\tret = ocfs2_expand_inline_dx_root(dir, dx_root_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tret = ocfs2_find_dir_space_dx(osb, dir, di_bh, dx_root_bh, name,\n\t\t\t\t      namelen, lookup);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nsearch_el:\n\t \n\tret = ocfs2_search_dx_free_list(dir, dx_root_bh, namelen, lookup);\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tlookup->dl_dx_root_bh = dx_root_bh;\n\tfree_dx_root = 0;\n\n\tif (ret == -ENOSPC) {\n\t\tret = ocfs2_extend_dir(osb, dir, di_bh, 1, lookup, &leaf_bh);\n\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tlookup->dl_prev_leaf_bh = NULL;\n\t\tlookup->dl_leaf_bh = leaf_bh;\n\t}\n\nout:\n\tif (free_dx_root)\n\t\tbrelse(dx_root_bh);\n\treturn ret;\n}\n\n \nint ocfs2_prepare_dir_for_insert(struct ocfs2_super *osb,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct buffer_head *parent_fe_bh,\n\t\t\t\t const char *name,\n\t\t\t\t int namelen,\n\t\t\t\t struct ocfs2_dir_lookup_result *lookup)\n{\n\tint ret;\n\tunsigned int blocks_wanted = 1;\n\tstruct buffer_head *bh = NULL;\n\n\ttrace_ocfs2_prepare_dir_for_insert(\n\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno, namelen);\n\n\tif (!namelen) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\tocfs2_dx_dir_name_hash(dir, name, namelen, &lookup->dl_hinfo);\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tret = ocfs2_prepare_dx_dir_for_insert(dir, parent_fe_bh,\n\t\t\t\t\t\t      name, namelen, lookup);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_find_dir_space_id(dir, parent_fe_bh, name,\n\t\t\t\t\t      namelen, &bh, &blocks_wanted);\n\t} else\n\t\tret = ocfs2_find_dir_space_el(dir, name, namelen, &bh);\n\n\tif (ret && ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ret == -ENOSPC) {\n\t\t \n\t\tBUG_ON(bh);\n\n\t\tret = ocfs2_extend_dir(osb, dir, parent_fe_bh, blocks_wanted,\n\t\t\t\t       lookup, &bh);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(!bh);\n\t}\n\n\tlookup->dl_leaf_bh = bh;\n\tbh = NULL;\nout:\n\tbrelse(bh);\n\treturn ret;\n}\n\nstatic int ocfs2_dx_dir_remove_index(struct inode *dir,\n\t\t\t\t     struct buffer_head *di_bh,\n\t\t\t\t     struct buffer_head *dx_root_bh)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct inode *dx_alloc_inode = NULL;\n\tstruct buffer_head *dx_alloc_bh = NULL;\n\thandle_t *handle;\n\tu64 blk;\n\tu16 bit;\n\tu64 bg_blkno;\n\n\tdx_root = (struct ocfs2_dx_root_block *) dx_root_bh->b_data;\n\n\tdx_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\tEXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\tle16_to_cpu(dx_root->dr_suballoc_slot));\n\tif (!dx_alloc_inode) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tinode_lock(dx_alloc_inode);\n\n\tret = ocfs2_inode_lock(dx_alloc_inode, &dx_alloc_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_DX_ROOT_REMOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(dir), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&OCFS2_I(dir)->ip_lock);\n\tOCFS2_I(dir)->ip_dyn_features &= ~OCFS2_INDEXED_DIR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(dir)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(dir)->ip_lock);\n\tdi->i_dx_root = cpu_to_le64(0ULL);\n\tocfs2_update_inode_fsync_trans(handle, dir, 1);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tblk = le64_to_cpu(dx_root->dr_blkno);\n\tbit = le16_to_cpu(dx_root->dr_suballoc_bit);\n\tif (dx_root->dr_suballoc_loc)\n\t\tbg_blkno = le64_to_cpu(dx_root->dr_suballoc_loc);\n\telse\n\t\tbg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\tret = ocfs2_free_suballoc_bits(handle, dx_alloc_inode, dx_alloc_bh,\n\t\t\t\t       bit, bg_blkno, 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tocfs2_inode_unlock(dx_alloc_inode, 1);\n\nout_mutex:\n\tinode_unlock(dx_alloc_inode);\n\tbrelse(dx_alloc_bh);\nout:\n\tiput(dx_alloc_inode);\n\treturn ret;\n}\n\nint ocfs2_dx_dir_truncate(struct inode *dir, struct buffer_head *di_bh)\n{\n\tint ret;\n\tunsigned int clen;\n\tu32 major_hash = UINT_MAX, p_cpos, cpos;\n\tu64 blkno;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct buffer_head *dx_root_bh = NULL;\n\tstruct ocfs2_dx_root_block *dx_root;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tif (!ocfs2_dir_indexed(dir))\n\t\treturn 0;\n\n\tret = ocfs2_read_dx_root(dir, di, &dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tdx_root = (struct ocfs2_dx_root_block *)dx_root_bh->b_data;\n\n\tif (ocfs2_dx_root_inline(dx_root))\n\t\tgoto remove_index;\n\n\tocfs2_init_dx_root_extent_tree(&et, INODE_CACHE(dir), dx_root_bh);\n\n\t \n\twhile (le32_to_cpu(dx_root->dr_clusters)) {\n\t\tret = ocfs2_dx_dir_lookup_rec(dir, &dx_root->dr_list,\n\t\t\t\t\t      major_hash, &cpos, &blkno, &clen);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tp_cpos = ocfs2_blocks_to_clusters(dir->i_sb, blkno);\n\n\t\tret = ocfs2_remove_btree_range(dir, &et, cpos, p_cpos, clen, 0,\n\t\t\t\t\t       &dealloc, 0, false);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos == 0)\n\t\t\tbreak;\n\n\t\tmajor_hash = cpos - 1;\n\t}\n\nremove_index:\n\tret = ocfs2_dx_dir_remove_index(dir, di_bh, dx_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_from_cache(INODE_CACHE(dir), dx_root_bh);\nout:\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\tbrelse(dx_root_bh);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}