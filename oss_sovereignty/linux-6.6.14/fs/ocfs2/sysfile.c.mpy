{
  "module_name": "sysfile.c",
  "hash_id": "87f4a8c4bbd01ba179393867c5d1043bcf037f0cfa9843a01b04e9b7681382f1",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/sysfile.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/highmem.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"alloc.h\"\n#include \"dir.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"sysfile.h\"\n\n#include \"buffer_head_io.h\"\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nstatic struct lock_class_key ocfs2_sysfile_cluster_lock_key[NUM_SYSTEM_INODES];\n#endif\n\nstatic inline int is_global_system_inode(int type)\n{\n\treturn type >= OCFS2_FIRST_ONLINE_SYSTEM_INODE &&\n\t\ttype <= OCFS2_LAST_GLOBAL_SYSTEM_INODE;\n}\n\nstatic struct inode **get_local_system_inode(struct ocfs2_super *osb,\n\t\t\t\t\t     int type,\n\t\t\t\t\t     u32 slot)\n{\n\tint index;\n\tstruct inode **local_system_inodes, **free = NULL;\n\n\tBUG_ON(slot == OCFS2_INVALID_SLOT);\n\tBUG_ON(type < OCFS2_FIRST_LOCAL_SYSTEM_INODE ||\n\t       type > OCFS2_LAST_LOCAL_SYSTEM_INODE);\n\n\tspin_lock(&osb->osb_lock);\n\tlocal_system_inodes = osb->local_system_inodes;\n\tspin_unlock(&osb->osb_lock);\n\n\tif (unlikely(!local_system_inodes)) {\n\t\tlocal_system_inodes =\n\t\t\tkzalloc(array3_size(sizeof(struct inode *),\n\t\t\t\t\t    NUM_LOCAL_SYSTEM_INODES,\n\t\t\t\t\t    osb->max_slots),\n\t\t\t\tGFP_NOFS);\n\t\tif (!local_system_inodes) {\n\t\t\tmlog_errno(-ENOMEM);\n\t\t\t \n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock(&osb->osb_lock);\n\t\tif (osb->local_system_inodes) {\n\t\t\t \n\t\t\tfree = local_system_inodes;\n\t\t\tlocal_system_inodes = osb->local_system_inodes;\n\t\t} else\n\t\t\tosb->local_system_inodes = local_system_inodes;\n\t\tspin_unlock(&osb->osb_lock);\n\t\tkfree(free);\n\t}\n\n\tindex = (slot * NUM_LOCAL_SYSTEM_INODES) +\n\t\t(type - OCFS2_FIRST_LOCAL_SYSTEM_INODE);\n\n\treturn &local_system_inodes[index];\n}\n\nstruct inode *ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t  int type,\n\t\t\t\t\t  u32 slot)\n{\n\tstruct inode *inode = NULL;\n\tstruct inode **arr = NULL;\n\n\t \n\tif (is_global_system_inode(type)) {\n\t\tarr = &(osb->global_system_inodes[type]);\n\t} else\n\t\tarr = get_local_system_inode(osb, type, slot);\n\n\tmutex_lock(&osb->system_file_mutex);\n\tif (arr && ((inode = *arr) != NULL)) {\n\t\t \n\t\tinode = igrab(inode);\n\t\tmutex_unlock(&osb->system_file_mutex);\n\t\tBUG_ON(!inode);\n\n\t\treturn inode;\n\t}\n\n\t \n\tinode = _ocfs2_get_system_file_inode(osb, type, slot);\n\n\t \n\tif (arr && inode) {\n\t\t*arr = igrab(inode);\n\t\tBUG_ON(!*arr);\n\t}\n\tmutex_unlock(&osb->system_file_mutex);\n\treturn inode;\n}\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t \n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}