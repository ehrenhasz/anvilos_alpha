{
  "module_name": "journal.c",
  "hash_id": "75f9fbff52250c1245d501ac8fce4ae807714b6553fdb7d3498209e2909145be",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/journal.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/kthread.h>\n#include <linux/time.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/writeback.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"alloc.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"dlmglue.h\"\n#include \"extent_map.h\"\n#include \"heartbeat.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"localalloc.h\"\n#include \"slot_map.h\"\n#include \"super.h\"\n#include \"sysfile.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"file.h\"\n#include \"namei.h\"\n\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n\nDEFINE_SPINLOCK(trans_inc_lock);\n\n#define ORPHAN_SCAN_SCHEDULE_TIMEOUT 300000\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int __ocfs2_recovery_thread(void *arg);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int __ocfs2_wait_on_mount(struct ocfs2_super *osb, int quota);\nstatic int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\nstatic int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);\nstatic int ocfs2_commit_thread(void *arg);\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);\n\nstatic inline int ocfs2_wait_on_mount(struct ocfs2_super *osb)\n{\n\treturn __ocfs2_wait_on_mount(osb, 0);\n}\n\nstatic inline int ocfs2_wait_on_quotas(struct ocfs2_super *osb)\n{\n\treturn __ocfs2_wait_on_mount(osb, 1);\n}\n\n \n\nenum ocfs2_replay_state {\n\tREPLAY_UNNEEDED = 0,\t \n\tREPLAY_NEEDED, \t\t \n\tREPLAY_DONE \t\t \n};\n\nstruct ocfs2_replay_map {\n\tunsigned int rm_slots;\n\tenum ocfs2_replay_state rm_state;\n\tunsigned char rm_replay_slots[];\n};\n\nstatic void ocfs2_replay_map_set_state(struct ocfs2_super *osb, int state)\n{\n\tif (!osb->replay_map)\n\t\treturn;\n\n\t \n\tif (osb->replay_map->rm_state == REPLAY_DONE)\n\t\treturn;\n\n\tosb->replay_map->rm_state = state;\n}\n\nint ocfs2_compute_replay_slots(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_replay_map *replay_map;\n\tint i, node_num;\n\n\t \n\tif (osb->replay_map)\n\t\treturn 0;\n\n\treplay_map = kzalloc(struct_size(replay_map, rm_replay_slots,\n\t\t\t\t\t osb->max_slots),\n\t\t\t     GFP_KERNEL);\n\tif (!replay_map) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&osb->osb_lock);\n\n\treplay_map->rm_slots = osb->max_slots;\n\treplay_map->rm_state = REPLAY_UNNEEDED;\n\n\t \n\tfor (i = 0; i < replay_map->rm_slots; i++) {\n\t\tif (ocfs2_slot_to_node_num_locked(osb, i, &node_num) == -ENOENT)\n\t\t\treplay_map->rm_replay_slots[i] = 1;\n\t}\n\n\tosb->replay_map = replay_map;\n\tspin_unlock(&osb->osb_lock);\n\treturn 0;\n}\n\nstatic void ocfs2_queue_replay_slots(struct ocfs2_super *osb,\n\t\tenum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_replay_map *replay_map = osb->replay_map;\n\tint i;\n\n\tif (!replay_map)\n\t\treturn;\n\n\tif (replay_map->rm_state != REPLAY_NEEDED)\n\t\treturn;\n\n\tfor (i = 0; i < replay_map->rm_slots; i++)\n\t\tif (replay_map->rm_replay_slots[i])\n\t\t\tocfs2_queue_recovery_completion(osb->journal, i, NULL,\n\t\t\t\t\t\t\tNULL, NULL,\n\t\t\t\t\t\t\torphan_reco_type);\n\treplay_map->rm_state = REPLAY_DONE;\n}\n\nvoid ocfs2_free_replay_slots(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_replay_map *replay_map = osb->replay_map;\n\n\tif (!osb->replay_map)\n\t\treturn;\n\n\tkfree(replay_map);\n\tosb->replay_map = NULL;\n}\n\nint ocfs2_recovery_init(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_recovery_map *rm;\n\n\tmutex_init(&osb->recovery_lock);\n\tosb->disable_recovery = 0;\n\tosb->recovery_thread_task = NULL;\n\tinit_waitqueue_head(&osb->recovery_event);\n\n\trm = kzalloc(struct_size(rm, rm_entries, osb->max_slots),\n\t\t     GFP_KERNEL);\n\tif (!rm) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tosb->recovery_map = rm;\n\n\treturn 0;\n}\n\n \nstatic int ocfs2_recovery_thread_running(struct ocfs2_super *osb)\n{\n\tmb();\n\treturn osb->recovery_thread_task != NULL;\n}\n\nvoid ocfs2_recovery_exit(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_recovery_map *rm;\n\n\t \n\tmutex_lock(&osb->recovery_lock);\n\tosb->disable_recovery = 1;\n\tmutex_unlock(&osb->recovery_lock);\n\twait_event(osb->recovery_event, !ocfs2_recovery_thread_running(osb));\n\n\t \n\tif (osb->ocfs2_wq)\n\t\tflush_workqueue(osb->ocfs2_wq);\n\n\t \n\trm = osb->recovery_map;\n\t \n\n\tkfree(rm);\n}\n\nstatic int __ocfs2_recovery_map_test(struct ocfs2_super *osb,\n\t\t\t\t     unsigned int node_num)\n{\n\tint i;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tassert_spin_locked(&osb->osb_lock);\n\n\tfor (i = 0; i < rm->rm_used; i++) {\n\t\tif (rm->rm_entries[i] == node_num)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ocfs2_recovery_map_set(struct ocfs2_super *osb,\n\t\t\t\t  unsigned int node_num)\n{\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tspin_lock(&osb->osb_lock);\n\tif (__ocfs2_recovery_map_test(osb, node_num)) {\n\t\tspin_unlock(&osb->osb_lock);\n\t\treturn 1;\n\t}\n\n\t \n\tBUG_ON(rm->rm_used >= osb->max_slots);\n\n\trm->rm_entries[rm->rm_used] = node_num;\n\trm->rm_used++;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn 0;\n}\n\nstatic void ocfs2_recovery_map_clear(struct ocfs2_super *osb,\n\t\t\t\t     unsigned int node_num)\n{\n\tint i;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tspin_lock(&osb->osb_lock);\n\n\tfor (i = 0; i < rm->rm_used; i++) {\n\t\tif (rm->rm_entries[i] == node_num)\n\t\t\tbreak;\n\t}\n\n\tif (i < rm->rm_used) {\n\t\t \n\t\tmemmove(&(rm->rm_entries[i]), &(rm->rm_entries[i + 1]),\n\t\t\t(rm->rm_used - i - 1) * sizeof(unsigned int));\n\t\trm->rm_used--;\n\t}\n\n\tspin_unlock(&osb->osb_lock);\n}\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tunsigned int flushed;\n\tstruct ocfs2_journal *journal = NULL;\n\n\tjournal = osb->journal;\n\n\t \n\tdown_write(&journal->j_trans_barrier);\n\n\tflushed = atomic_read(&journal->j_num_trans);\n\ttrace_ocfs2_commit_cache_begin(flushed);\n\tif (flushed == 0) {\n\t\tup_write(&journal->j_trans_barrier);\n\t\tgoto finally;\n\t}\n\n\tjbd2_journal_lock_updates(journal->j_journal);\n\tstatus = jbd2_journal_flush(journal->j_journal, 0);\n\tjbd2_journal_unlock_updates(journal->j_journal);\n\tif (status < 0) {\n\t\tup_write(&journal->j_trans_barrier);\n\t\tmlog_errno(status);\n\t\tgoto finally;\n\t}\n\n\tocfs2_inc_trans_id(journal);\n\n\tflushed = atomic_read(&journal->j_num_trans);\n\tatomic_set(&journal->j_num_trans, 0);\n\tup_write(&journal->j_trans_barrier);\n\n\ttrace_ocfs2_commit_cache_end(journal->j_trans_id, flushed);\n\n\tocfs2_wake_downconvert_thread(osb);\n\twake_up(&journal->j_checkpointed);\nfinally:\n\treturn status;\n}\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t \n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}\n\n \nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = jbd2_handle_buffer_credits(handle);\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}\n\n \nint ocfs2_allocate_extend_trans(handle_t *handle, int thresh)\n{\n\tint status, old_nblks;\n\n\tBUG_ON(!handle);\n\n\told_nblks = jbd2_handle_buffer_credits(handle);\n\ttrace_ocfs2_allocate_extend_trans(old_nblks, thresh);\n\n\tif (old_nblks < thresh)\n\t\treturn 0;\n\n\tstatus = jbd2_journal_extend(handle, OCFS2_MAX_TRANS_DATA, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (status > 0) {\n\t\tstatus = jbd2_journal_restart(handle, OCFS2_MAX_TRANS_DATA);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\nbail:\n\treturn status;\n}\n\n\nstruct ocfs2_triggers {\n\tstruct jbd2_buffer_trigger_type\tot_triggers;\n\tint\t\t\t\tot_offset;\n};\n\nstatic inline struct ocfs2_triggers *to_ocfs2_trigger(struct jbd2_buffer_trigger_type *triggers)\n{\n\treturn container_of(triggers, struct ocfs2_triggers, ot_triggers);\n}\n\nstatic void ocfs2_frozen_trigger(struct jbd2_buffer_trigger_type *triggers,\n\t\t\t\t struct buffer_head *bh,\n\t\t\t\t void *data, size_t size)\n{\n\tstruct ocfs2_triggers *ot = to_ocfs2_trigger(triggers);\n\n\t \n\tocfs2_block_check_compute(data, size, data + ot->ot_offset);\n}\n\n \nstatic void ocfs2_dq_frozen_trigger(struct jbd2_buffer_trigger_type *triggers,\n\t\t\t\t struct buffer_head *bh,\n\t\t\t\t void *data, size_t size)\n{\n\tstruct ocfs2_disk_dqtrailer *dqt =\n\t\tocfs2_block_dqtrailer(size, data);\n\n\t \n\tocfs2_block_check_compute(data, size, &dqt->dq_check);\n}\n\n \nstatic void ocfs2_db_frozen_trigger(struct jbd2_buffer_trigger_type *triggers,\n\t\t\t\t struct buffer_head *bh,\n\t\t\t\t void *data, size_t size)\n{\n\tstruct ocfs2_dir_block_trailer *trailer =\n\t\tocfs2_dir_trailer_from_size(size, data);\n\n\t \n\tocfs2_block_check_compute(data, size, &trailer->db_check);\n}\n\nstatic void ocfs2_abort_trigger(struct jbd2_buffer_trigger_type *triggers,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tmlog(ML_ERROR,\n\t     \"ocfs2_abort_trigger called by JBD2.  bh = 0x%lx, \"\n\t     \"bh->b_blocknr = %llu\\n\",\n\t     (unsigned long)bh,\n\t     (unsigned long long)bh->b_blocknr);\n\n\tocfs2_error(bh->b_assoc_map->host->i_sb,\n\t\t    \"JBD2 has aborted our journal, ocfs2 cannot continue\\n\");\n}\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nstatic struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};\n\nstatic struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};\n\nstatic struct ocfs2_triggers gd_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_group_desc, bg_check),\n};\n\nstatic struct ocfs2_triggers db_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_db_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};\n\nstatic struct ocfs2_triggers xb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_xattr_block, xb_check),\n};\n\nstatic struct ocfs2_triggers dq_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_dq_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};\n\nstatic struct ocfs2_triggers dr_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_root_block, dr_check),\n};\n\nstatic struct ocfs2_triggers dl_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_leaf, dl_check),\n};\n\nstatic int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t \n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu, b_state=0x%lx\\n\",\n\t\t     (unsigned long long)bh->b_blocknr, bh->b_state);\n\n\t\tlock_buffer(bh);\n\t\t \n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh)) {\n\t\t\tunlock_buffer(bh);\n\t\t\treturn ocfs2_error(osb->sb, \"A previous attempt to \"\n\t\t\t\t\t\"write this buffer head failed\\n\");\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n\n\t \n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}\n\nint ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}\n\nint ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}\n\nint ocfs2_journal_access_gd(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &gd_triggers, type);\n}\n\nint ocfs2_journal_access_db(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &db_triggers, type);\n}\n\nint ocfs2_journal_access_xb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &xb_triggers, type);\n}\n\nint ocfs2_journal_access_dq(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dq_triggers, type);\n}\n\nint ocfs2_journal_access_dr(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dr_triggers, type);\n}\n\nint ocfs2_journal_access_dl(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dl_triggers, type);\n}\n\nint ocfs2_journal_access(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, NULL, type);\n}\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(bh->b_assoc_map->host->i_sb,\n\t\t\t\t    \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}\n\n#define OCFS2_DEFAULT_COMMIT_INTERVAL\t(HZ * JBD2_DEFAULT_MAX_COMMIT_AGE)\n\nvoid ocfs2_set_journal_params(struct ocfs2_super *osb)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\tunsigned long commit_interval = OCFS2_DEFAULT_COMMIT_INTERVAL;\n\n\tif (osb->osb_commit_interval)\n\t\tcommit_interval = osb->osb_commit_interval;\n\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_commit_interval = commit_interval;\n\tif (osb->s_mount_opt & OCFS2_MOUNT_BARRIER)\n\t\tjournal->j_flags |= JBD2_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JBD2_BARRIER;\n\twrite_unlock(&journal->j_state_lock);\n}\n\n \nint ocfs2_journal_alloc(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tstruct ocfs2_journal *journal;\n\n\tjournal = kzalloc(sizeof(struct ocfs2_journal), GFP_KERNEL);\n\tif (!journal) {\n\t\tmlog(ML_ERROR, \"unable to alloc journal\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tosb->journal = journal;\n\tjournal->j_osb = osb;\n\n\tatomic_set(&journal->j_num_trans, 0);\n\tinit_rwsem(&journal->j_trans_barrier);\n\tinit_waitqueue_head(&journal->j_checkpointed);\n\tspin_lock_init(&journal->j_lock);\n\tjournal->j_trans_id = 1UL;\n\tINIT_LIST_HEAD(&journal->j_la_cleanups);\n\tINIT_WORK(&journal->j_recovery_work, ocfs2_complete_recovery);\n\tjournal->j_state = OCFS2_JOURNAL_FREE;\n\nbail:\n\treturn status;\n}\n\nstatic int ocfs2_journal_submit_inode_data_buffers(struct jbd2_inode *jinode)\n{\n\tstruct address_space *mapping = jinode->i_vfs_inode->i_mapping;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode =  WB_SYNC_ALL,\n\t\t.nr_to_write = mapping->nrpages * 2,\n\t\t.range_start = jinode->i_dirty_start,\n\t\t.range_end = jinode->i_dirty_end,\n\t};\n\n\treturn filemap_fdatawrite_wbc(mapping, &wbc);\n}\n\nint ocfs2_journal_init(struct ocfs2_super *osb, int *dirty)\n{\n\tint status = -1;\n\tstruct inode *inode = NULL;  \n\tjournal_t *j_journal = NULL;\n\tstruct ocfs2_journal *journal = osb->journal;\n\tstruct ocfs2_dinode *di = NULL;\n\tstruct buffer_head *bh = NULL;\n\tint inode_lock = 0;\n\n\tBUG_ON(!journal);\n\t \n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (inode == NULL) {\n\t\tstatus = -EACCES;\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tmlog(ML_ERROR, \"access error (bad inode)\\n\");\n\t\tiput(inode);\n\t\tinode = NULL;\n\t\tstatus = -EACCES;\n\t\tgoto done;\n\t}\n\n\tSET_INODE_JOURNAL(inode);\n\tOCFS2_I(inode)->ip_open_count++;\n\n\t \n\tstatus = ocfs2_inode_lock_full(inode, &bh, 1, OCFS2_META_LOCK_RECOVERY);\n\tif (status < 0) {\n\t\tif (status != -ERESTARTSYS)\n\t\t\tmlog(ML_ERROR, \"Could not get lock on journal!\\n\");\n\t\tgoto done;\n\t}\n\n\tinode_lock = 1;\n\tdi = (struct ocfs2_dinode *)bh->b_data;\n\n\tif (i_size_read(inode) <  OCFS2_MIN_JOURNAL_SIZE) {\n\t\tmlog(ML_ERROR, \"Journal file size (%lld) is too small!\\n\",\n\t\t     i_size_read(inode));\n\t\tstatus = -EINVAL;\n\t\tgoto done;\n\t}\n\n\ttrace_ocfs2_journal_init(i_size_read(inode),\n\t\t\t\t (unsigned long long)inode->i_blocks,\n\t\t\t\t OCFS2_I(inode)->ip_clusters);\n\n\t \n\tj_journal = jbd2_journal_init_inode(inode);\n\tif (IS_ERR(j_journal)) {\n\t\tmlog(ML_ERROR, \"Linux journal layer error\\n\");\n\t\tstatus = PTR_ERR(j_journal);\n\t\tgoto done;\n\t}\n\n\ttrace_ocfs2_journal_init_maxlen(j_journal->j_total_len);\n\n\t*dirty = (le32_to_cpu(di->id1.journal1.ij_flags) &\n\t\t  OCFS2_JOURNAL_DIRTY_FL);\n\n\tjournal->j_journal = j_journal;\n\tjournal->j_journal->j_submit_inode_data_buffers =\n\t\tocfs2_journal_submit_inode_data_buffers;\n\tjournal->j_journal->j_finish_inode_data_buffers =\n\t\tjbd2_journal_finish_inode_data_buffers;\n\tjournal->j_inode = inode;\n\tjournal->j_bh = bh;\n\n\tocfs2_set_journal_params(osb);\n\n\tjournal->j_state = OCFS2_JOURNAL_LOADED;\n\n\tstatus = 0;\ndone:\n\tif (status < 0) {\n\t\tif (inode_lock)\n\t\t\tocfs2_inode_unlock(inode, 1);\n\t\tbrelse(bh);\n\t\tif (inode) {\n\t\t\tOCFS2_I(inode)->ip_open_count--;\n\t\t\tiput(inode);\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic void ocfs2_bump_recovery_generation(struct ocfs2_dinode *di)\n{\n\tle32_add_cpu(&(di->id1.journal1.ij_recovery_generation), 1);\n}\n\nstatic u32 ocfs2_get_recovery_generation(struct ocfs2_dinode *di)\n{\n\treturn le32_to_cpu(di->id1.journal1.ij_recovery_generation);\n}\n\nstatic int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed)\n{\n\tint status;\n\tunsigned int flags;\n\tstruct ocfs2_journal *journal = osb->journal;\n\tstruct buffer_head *bh = journal->j_bh;\n\tstruct ocfs2_dinode *fe;\n\n\tfe = (struct ocfs2_dinode *)bh->b_data;\n\n\t \n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tif (dirty)\n\t\tflags |= OCFS2_JOURNAL_DIRTY_FL;\n\telse\n\t\tflags &= ~OCFS2_JOURNAL_DIRTY_FL;\n\tfe->id1.journal1.ij_flags = cpu_to_le32(flags);\n\n\tif (replayed)\n\t\tocfs2_bump_recovery_generation(fe);\n\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &fe->i_check);\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(journal->j_inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}\n\n \nvoid ocfs2_journal_shutdown(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_journal *journal = NULL;\n\tint status = 0;\n\tstruct inode *inode = NULL;\n\tint num_running_trans = 0;\n\n\tBUG_ON(!osb);\n\n\tjournal = osb->journal;\n\tif (!journal)\n\t\tgoto done;\n\n\tinode = journal->j_inode;\n\n\tif (journal->j_state != OCFS2_JOURNAL_LOADED)\n\t\tgoto done;\n\n\t \n\tif (!igrab(inode))\n\t\tBUG();\n\n\tnum_running_trans = atomic_read(&(osb->journal->j_num_trans));\n\ttrace_ocfs2_journal_shutdown(num_running_trans);\n\n\t \n\tjournal->j_state = OCFS2_JOURNAL_IN_SHUTDOWN;\n\n\t \n\tif (osb->commit_task) {\n\t\t \n\t\ttrace_ocfs2_journal_shutdown_wait(osb->commit_task);\n\t\tkthread_stop(osb->commit_task);\n\t\tosb->commit_task = NULL;\n\t}\n\n\tBUG_ON(atomic_read(&(osb->journal->j_num_trans)) != 0);\n\n\tif (ocfs2_mount_local(osb)) {\n\t\tjbd2_journal_lock_updates(journal->j_journal);\n\t\tstatus = jbd2_journal_flush(journal->j_journal, 0);\n\t\tjbd2_journal_unlock_updates(journal->j_journal);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\t \n\tif (!jbd2_journal_destroy(journal->j_journal) && !status) {\n\t\t \n\t\tstatus = ocfs2_journal_toggle_dirty(osb, 0, 0);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\tjournal->j_journal = NULL;\n\n\tOCFS2_I(inode)->ip_open_count--;\n\n\t \n\tocfs2_inode_unlock(inode, 1);\n\n\tbrelse(journal->j_bh);\n\tjournal->j_bh = NULL;\n\n\tjournal->j_state = OCFS2_JOURNAL_FREE;\n\ndone:\n\tiput(inode);\n\tkfree(journal);\n\tosb->journal = NULL;\n}\n\nstatic void ocfs2_clear_journal_error(struct super_block *sb,\n\t\t\t\t      journal_t *journal,\n\t\t\t\t      int slot)\n{\n\tint olderr;\n\n\tolderr = jbd2_journal_errno(journal);\n\tif (olderr) {\n\t\tmlog(ML_ERROR, \"File system error %d recorded in \"\n\t\t     \"journal %u.\\n\", olderr, slot);\n\t\tmlog(ML_ERROR, \"File system on device %s needs checking.\\n\",\n\t\t     sb->s_id);\n\n\t\tjbd2_journal_ack_err(journal);\n\t\tjbd2_journal_clear_err(journal);\n\t}\n}\n\nint ocfs2_journal_load(struct ocfs2_journal *journal, int local, int replayed)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb;\n\n\tBUG_ON(!journal);\n\n\tosb = journal->j_osb;\n\n\tstatus = jbd2_journal_load(journal->j_journal);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"Failed to load journal!\\n\");\n\t\tgoto done;\n\t}\n\n\tocfs2_clear_journal_error(osb->sb, journal->j_journal, osb->slot_num);\n\n\tif (replayed) {\n\t\tjbd2_journal_lock_updates(journal->j_journal);\n\t\tstatus = jbd2_journal_flush(journal->j_journal, 0);\n\t\tjbd2_journal_unlock_updates(journal->j_journal);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\tstatus = ocfs2_journal_toggle_dirty(osb, 1, replayed);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\t \n\tif (!local) {\n\t\tosb->commit_task = kthread_run(ocfs2_commit_thread, osb,\n\t\t\t\t\"ocfs2cmt-%s\", osb->uuid_str);\n\t\tif (IS_ERR(osb->commit_task)) {\n\t\t\tstatus = PTR_ERR(osb->commit_task);\n\t\t\tosb->commit_task = NULL;\n\t\t\tmlog(ML_ERROR, \"unable to launch ocfs2commit thread, \"\n\t\t\t     \"error=%d\", status);\n\t\t\tgoto done;\n\t\t}\n\t} else\n\t\tosb->commit_task = NULL;\n\ndone:\n\treturn status;\n}\n\n\n \nint ocfs2_journal_wipe(struct ocfs2_journal *journal, int full)\n{\n\tint status;\n\n\tBUG_ON(!journal);\n\n\tstatus = jbd2_journal_wipe(journal->j_journal, full);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_toggle_dirty(journal->j_osb, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\treturn status;\n}\n\nstatic int ocfs2_recovery_completed(struct ocfs2_super *osb)\n{\n\tint empty;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tspin_lock(&osb->osb_lock);\n\tempty = (rm->rm_used == 0);\n\tspin_unlock(&osb->osb_lock);\n\n\treturn empty;\n}\n\nvoid ocfs2_wait_for_recovery(struct ocfs2_super *osb)\n{\n\twait_event(osb->recovery_event, ocfs2_recovery_completed(osb));\n}\n\n \nstatic int ocfs2_force_read_journal(struct inode *inode)\n{\n\tint status = 0;\n\tint i;\n\tu64 v_blkno, p_blkno, p_blocks, num_blocks;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tnum_blocks = ocfs2_blocks_for_bytes(inode->i_sb, i_size_read(inode));\n\tv_blkno = 0;\n\twhile (v_blkno < num_blocks) {\n\t\tstatus = ocfs2_extent_map_get_blocks(inode, v_blkno,\n\t\t\t\t\t\t     &p_blkno, &p_blocks, NULL);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tfor (i = 0; i < p_blocks; i++, p_blkno++) {\n\t\t\tbh = __find_get_block(osb->sb->s_bdev, p_blkno,\n\t\t\t\t\tosb->sb->s_blocksize);\n\t\t\t \n\t\t\tif (!bh)\n\t\t\t\tcontinue;\n\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\t \n\t\t\tstatus = ocfs2_read_blocks_sync(osb, p_blkno, 1, &bh);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\n\t\tv_blkno += p_blocks;\n\t}\n\nbail:\n\treturn status;\n}\n\nstruct ocfs2_la_recovery_item {\n\tstruct list_head\tlri_list;\n\tint\t\t\tlri_slot;\n\tstruct ocfs2_dinode\t*lri_la_dinode;\n\tstruct ocfs2_dinode\t*lri_tl_dinode;\n\tstruct ocfs2_quota_recovery *lri_qrec;\n\tenum ocfs2_orphan_reco_type  lri_orphan_reco_type;\n};\n\n \nvoid ocfs2_complete_recovery(struct work_struct *work)\n{\n\tint ret = 0;\n\tstruct ocfs2_journal *journal =\n\t\tcontainer_of(work, struct ocfs2_journal, j_recovery_work);\n\tstruct ocfs2_super *osb = journal->j_osb;\n\tstruct ocfs2_dinode *la_dinode, *tl_dinode;\n\tstruct ocfs2_la_recovery_item *item, *n;\n\tstruct ocfs2_quota_recovery *qrec;\n\tenum ocfs2_orphan_reco_type orphan_reco_type;\n\tLIST_HEAD(tmp_la_list);\n\n\ttrace_ocfs2_complete_recovery(\n\t\t(unsigned long long)OCFS2_I(journal->j_inode)->ip_blkno);\n\n\tspin_lock(&journal->j_lock);\n\tlist_splice_init(&journal->j_la_cleanups, &tmp_la_list);\n\tspin_unlock(&journal->j_lock);\n\n\tlist_for_each_entry_safe(item, n, &tmp_la_list, lri_list) {\n\t\tlist_del_init(&item->lri_list);\n\n\t\tocfs2_wait_on_quotas(osb);\n\n\t\tla_dinode = item->lri_la_dinode;\n\t\ttl_dinode = item->lri_tl_dinode;\n\t\tqrec = item->lri_qrec;\n\t\torphan_reco_type = item->lri_orphan_reco_type;\n\n\t\ttrace_ocfs2_complete_recovery_slot(item->lri_slot,\n\t\t\tla_dinode ? le64_to_cpu(la_dinode->i_blkno) : 0,\n\t\t\ttl_dinode ? le64_to_cpu(tl_dinode->i_blkno) : 0,\n\t\t\tqrec);\n\n\t\tif (la_dinode) {\n\t\t\tret = ocfs2_complete_local_alloc_recovery(osb,\n\t\t\t\t\t\t\t\t  la_dinode);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\tkfree(la_dinode);\n\t\t}\n\n\t\tif (tl_dinode) {\n\t\t\tret = ocfs2_complete_truncate_log_recovery(osb,\n\t\t\t\t\t\t\t\t   tl_dinode);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\tkfree(tl_dinode);\n\t\t}\n\n\t\tret = ocfs2_recover_orphans(osb, item->lri_slot,\n\t\t\t\torphan_reco_type);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\n\t\tif (qrec) {\n\t\t\tret = ocfs2_finish_quota_recovery(osb, qrec,\n\t\t\t\t\t\t\t  item->lri_slot);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\t\t\t \n\t\t}\n\n\t\tkfree(item);\n\t}\n\n\ttrace_ocfs2_complete_recovery_end(ret);\n}\n\n \nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_la_recovery_item *item;\n\n\titem = kmalloc(sizeof(struct ocfs2_la_recovery_item), GFP_NOFS);\n\tif (!item) {\n\t\t \n\t\tkfree(la_dinode);\n\t\tkfree(tl_dinode);\n\n\t\tif (qrec)\n\t\t\tocfs2_free_quota_recovery(qrec);\n\n\t\tmlog_errno(-ENOMEM);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&item->lri_list);\n\titem->lri_la_dinode = la_dinode;\n\titem->lri_slot = slot_num;\n\titem->lri_tl_dinode = tl_dinode;\n\titem->lri_qrec = qrec;\n\titem->lri_orphan_reco_type = orphan_reco_type;\n\n\tspin_lock(&journal->j_lock);\n\tlist_add_tail(&item->lri_list, &journal->j_la_cleanups);\n\tqueue_work(journal->j_osb->ocfs2_wq, &journal->j_recovery_work);\n\tspin_unlock(&journal->j_lock);\n}\n\n \nvoid ocfs2_complete_mount_recovery(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn;\n\n\t \n\tocfs2_queue_recovery_completion(journal, osb->slot_num,\n\t\t\t\t\tosb->local_alloc_copy, NULL, NULL,\n\t\t\t\t\tORPHAN_NEED_TRUNCATE);\n\tocfs2_schedule_truncate_log_flush(osb, 0);\n\n\tosb->local_alloc_copy = NULL;\n\n\t \n\tocfs2_replay_map_set_state(osb, REPLAY_NEEDED);\n\tocfs2_queue_replay_slots(osb, ORPHAN_NEED_TRUNCATE);\n\tocfs2_free_replay_slots(osb);\n}\n\nvoid ocfs2_complete_quota_recovery(struct ocfs2_super *osb)\n{\n\tif (osb->quota_rec) {\n\t\tocfs2_queue_recovery_completion(osb->journal,\n\t\t\t\t\t\tosb->slot_num,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tosb->quota_rec,\n\t\t\t\t\t\tORPHAN_NEED_TRUNCATE);\n\t\tosb->quota_rec = NULL;\n\t}\n}\n\nstatic int __ocfs2_recovery_thread(void *arg)\n{\n\tint status, node_num, slot_num;\n\tstruct ocfs2_super *osb = arg;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\tint *rm_quota = NULL;\n\tint rm_quota_used = 0, i;\n\tstruct ocfs2_quota_recovery *qrec;\n\n\t \n\tint quota_enabled = OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb,\n\t\t\tOCFS2_FEATURE_RO_COMPAT_USRQUOTA)\n\t\t|| OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb,\n\t\t\tOCFS2_FEATURE_RO_COMPAT_GRPQUOTA);\n\n\tstatus = ocfs2_wait_on_mount(osb);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tif (quota_enabled) {\n\t\trm_quota = kcalloc(osb->max_slots, sizeof(int), GFP_NOFS);\n\t\tif (!rm_quota) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto bail;\n\t\t}\n\t}\nrestart:\n\tstatus = ocfs2_super_lock(osb, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_compute_replay_slots(osb);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t \n\tocfs2_queue_recovery_completion(osb->journal, osb->slot_num, NULL,\n\t\t\t\t\tNULL, NULL, ORPHAN_NO_NEED_TRUNCATE);\n\n\tspin_lock(&osb->osb_lock);\n\twhile (rm->rm_used) {\n\t\t \n\t\tnode_num = rm->rm_entries[0];\n\t\tspin_unlock(&osb->osb_lock);\n\t\tslot_num = ocfs2_node_num_to_slot(osb, node_num);\n\t\ttrace_ocfs2_recovery_thread_node(node_num, slot_num);\n\t\tif (slot_num == -ENOENT) {\n\t\t\tstatus = 0;\n\t\t\tgoto skip_recovery;\n\t\t}\n\n\t\t \n\t\tif (quota_enabled) {\n\t\t\tfor (i = 0; i < rm_quota_used\n\t\t\t\t\t&& rm_quota[i] != slot_num; i++)\n\t\t\t\t;\n\n\t\t\tif (i == rm_quota_used)\n\t\t\t\trm_quota[rm_quota_used++] = slot_num;\n\t\t}\n\n\t\tstatus = ocfs2_recover_node(osb, node_num, slot_num);\nskip_recovery:\n\t\tif (!status) {\n\t\t\tocfs2_recovery_map_clear(osb, node_num);\n\t\t} else {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Error %d recovering node %d on device (%u,%u)!\\n\",\n\t\t\t     status, node_num,\n\t\t\t     MAJOR(osb->sb->s_dev), MINOR(osb->sb->s_dev));\n\t\t\tmlog(ML_ERROR, \"Volume requires unmount.\\n\");\n\t\t}\n\n\t\tspin_lock(&osb->osb_lock);\n\t}\n\tspin_unlock(&osb->osb_lock);\n\ttrace_ocfs2_recovery_thread_end(status);\n\n\t \n\tstatus = ocfs2_check_journals_nolocks(osb);\n\tstatus = (status == -EROFS) ? 0 : status;\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t \n\tif (quota_enabled) {\n\t\tfor (i = 0; i < rm_quota_used; i++) {\n\t\t\tqrec = ocfs2_begin_quota_recovery(osb, rm_quota[i]);\n\t\t\tif (IS_ERR(qrec)) {\n\t\t\t\tstatus = PTR_ERR(qrec);\n\t\t\t\tmlog_errno(status);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tocfs2_queue_recovery_completion(osb->journal,\n\t\t\t\t\trm_quota[i],\n\t\t\t\t\tNULL, NULL, qrec,\n\t\t\t\t\tORPHAN_NEED_TRUNCATE);\n\t\t}\n\t}\n\n\tocfs2_super_unlock(osb, 1);\n\n\t \n\tocfs2_queue_replay_slots(osb, ORPHAN_NEED_TRUNCATE);\n\nbail:\n\tmutex_lock(&osb->recovery_lock);\n\tif (!status && !ocfs2_recovery_completed(osb)) {\n\t\tmutex_unlock(&osb->recovery_lock);\n\t\tgoto restart;\n\t}\n\n\tocfs2_free_replay_slots(osb);\n\tosb->recovery_thread_task = NULL;\n\tmb();  \n\twake_up(&osb->recovery_event);\n\n\tmutex_unlock(&osb->recovery_lock);\n\n\tif (quota_enabled)\n\t\tkfree(rm_quota);\n\n\treturn status;\n}\n\nvoid ocfs2_recovery_thread(struct ocfs2_super *osb, int node_num)\n{\n\tmutex_lock(&osb->recovery_lock);\n\n\ttrace_ocfs2_recovery_thread(node_num, osb->node_num,\n\t\tosb->disable_recovery, osb->recovery_thread_task,\n\t\tosb->disable_recovery ?\n\t\t-1 : ocfs2_recovery_map_set(osb, node_num));\n\n\tif (osb->disable_recovery)\n\t\tgoto out;\n\n\tif (osb->recovery_thread_task)\n\t\tgoto out;\n\n\tosb->recovery_thread_task =  kthread_run(__ocfs2_recovery_thread, osb,\n\t\t\t\"ocfs2rec-%s\", osb->uuid_str);\n\tif (IS_ERR(osb->recovery_thread_task)) {\n\t\tmlog_errno((int)PTR_ERR(osb->recovery_thread_task));\n\t\tosb->recovery_thread_task = NULL;\n\t}\n\nout:\n\tmutex_unlock(&osb->recovery_lock);\n\twake_up(&osb->recovery_event);\n}\n\nstatic int ocfs2_read_journal_inode(struct ocfs2_super *osb,\n\t\t\t\t    int slot_num,\n\t\t\t\t    struct buffer_head **bh,\n\t\t\t\t    struct inode **ret_inode)\n{\n\tint status = -EACCES;\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(slot_num >= osb->max_slots);\n\n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (!inode || is_bad_inode(inode)) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tSET_INODE_JOURNAL(inode);\n\n\tstatus = ocfs2_read_inode_block_full(inode, bh, OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\nbail:\n\tif (inode) {\n\t\tif (status || !ret_inode)\n\t\t\tiput(inode);\n\t\telse\n\t\t\t*ret_inode = inode;\n\t}\n\treturn status;\n}\n\n \nstatic int ocfs2_replay_journal(struct ocfs2_super *osb,\n\t\t\t\tint node_num,\n\t\t\t\tint slot_num)\n{\n\tint status;\n\tint got_lock = 0;\n\tunsigned int flags;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_dinode *fe;\n\tjournal_t *journal = NULL;\n\tstruct buffer_head *bh = NULL;\n\tu32 slot_reco_gen;\n\n\tstatus = ocfs2_read_journal_inode(osb, slot_num, &bh, &inode);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\tfe = (struct ocfs2_dinode *)bh->b_data;\n\tslot_reco_gen = ocfs2_get_recovery_generation(fe);\n\tbrelse(bh);\n\tbh = NULL;\n\n\t \n\tif (osb->slot_recovery_generations[slot_num] != slot_reco_gen) {\n\t\ttrace_ocfs2_replay_journal_recovered(slot_num,\n\t\t     osb->slot_recovery_generations[slot_num], slot_reco_gen);\n\t\tosb->slot_recovery_generations[slot_num] = slot_reco_gen;\n\t\tstatus = -EBUSY;\n\t\tgoto done;\n\t}\n\n\t \n\n\tstatus = ocfs2_inode_lock_full(inode, &bh, 1, OCFS2_META_LOCK_RECOVERY);\n\tif (status < 0) {\n\t\ttrace_ocfs2_replay_journal_lock_err(status);\n\t\tif (status != -ERESTARTSYS)\n\t\t\tmlog(ML_ERROR, \"Could not lock journal!\\n\");\n\t\tgoto done;\n\t}\n\tgot_lock = 1;\n\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tslot_reco_gen = ocfs2_get_recovery_generation(fe);\n\n\tif (!(flags & OCFS2_JOURNAL_DIRTY_FL)) {\n\t\ttrace_ocfs2_replay_journal_skip(node_num);\n\t\t \n\t\tosb->slot_recovery_generations[slot_num] = slot_reco_gen;\n\t\tgoto done;\n\t}\n\n\t \n\tocfs2_replay_map_set_state(osb, REPLAY_NEEDED);\n\n\tprintk(KERN_NOTICE \"ocfs2: Begin replay journal (node %d, slot %d) on \"\\\n\t       \"device (%u,%u)\\n\", node_num, slot_num, MAJOR(osb->sb->s_dev),\n\t       MINOR(osb->sb->s_dev));\n\n\tOCFS2_I(inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\n\tstatus = ocfs2_force_read_journal(inode);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\tjournal = jbd2_journal_init_inode(inode);\n\tif (IS_ERR(journal)) {\n\t\tmlog(ML_ERROR, \"Linux journal layer error\\n\");\n\t\tstatus = PTR_ERR(journal);\n\t\tgoto done;\n\t}\n\n\tstatus = jbd2_journal_load(journal);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tBUG_ON(!igrab(inode));\n\t\tjbd2_journal_destroy(journal);\n\t\tgoto done;\n\t}\n\n\tocfs2_clear_journal_error(osb->sb, journal, slot_num);\n\n\t \n\tjbd2_journal_lock_updates(journal);\n\tstatus = jbd2_journal_flush(journal, 0);\n\tjbd2_journal_unlock_updates(journal);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t \n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tflags &= ~OCFS2_JOURNAL_DIRTY_FL;\n\tfe->id1.journal1.ij_flags = cpu_to_le32(flags);\n\n\t \n\tocfs2_bump_recovery_generation(fe);\n\tosb->slot_recovery_generations[slot_num] =\n\t\t\t\t\tocfs2_get_recovery_generation(fe);\n\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &fe->i_check);\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tBUG_ON(!igrab(inode));\n\n\tjbd2_journal_destroy(journal);\n\n\tprintk(KERN_NOTICE \"ocfs2: End replay journal (node %d, slot %d) on \"\\\n\t       \"device (%u,%u)\\n\", node_num, slot_num, MAJOR(osb->sb->s_dev),\n\t       MINOR(osb->sb->s_dev));\ndone:\n\t \n\tif (got_lock)\n\t\tocfs2_inode_unlock(inode, 1);\n\n\tiput(inode);\n\tbrelse(bh);\n\n\treturn status;\n}\n\n \nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *la_copy = NULL;\n\tstruct ocfs2_dinode *tl_copy = NULL;\n\n\ttrace_ocfs2_recover_node(node_num, slot_num, osb->node_num);\n\n\t \n\tBUG_ON(osb->node_num == node_num);\n\n\tstatus = ocfs2_replay_journal(osb, node_num, slot_num);\n\tif (status < 0) {\n\t\tif (status == -EBUSY) {\n\t\t\ttrace_ocfs2_recover_node_skip(slot_num, node_num);\n\t\t\tstatus = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\t \n\tstatus = ocfs2_begin_local_alloc_recovery(osb, slot_num, &la_copy);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\t \n\tstatus = ocfs2_begin_truncate_log_recovery(osb, slot_num, &tl_copy);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t \n\tstatus = ocfs2_clear_slot(osb, slot_num);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t \n\tocfs2_queue_recovery_completion(osb->journal, slot_num, la_copy,\n\t\t\t\t\ttl_copy, NULL, ORPHAN_NEED_TRUNCATE);\n\n\tstatus = 0;\ndone:\n\n\treturn status;\n}\n\n \nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num)\n{\n\tint status, flags;\n\tstruct inode *inode = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (inode == NULL) {\n\t\tmlog(ML_ERROR, \"access error\\n\");\n\t\tstatus = -EACCES;\n\t\tgoto bail;\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tmlog(ML_ERROR, \"access error (bad inode)\\n\");\n\t\tiput(inode);\n\t\tinode = NULL;\n\t\tstatus = -EACCES;\n\t\tgoto bail;\n\t}\n\tSET_INODE_JOURNAL(inode);\n\n\tflags = OCFS2_META_LOCK_RECOVERY | OCFS2_META_LOCK_NOQUEUE;\n\tstatus = ocfs2_inode_lock_full(inode, NULL, 1, flags);\n\tif (status < 0) {\n\t\tif (status != -EAGAIN)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_inode_unlock(inode, 1);\nbail:\n\tiput(inode);\n\n\treturn status;\n}\n\n \nint ocfs2_mark_dead_nodes(struct ocfs2_super *osb)\n{\n\tunsigned int node_num;\n\tint status, i;\n\tu32 gen;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *di;\n\n\t \n\n\tfor (i = 0; i < osb->max_slots; i++) {\n\t\t \n\t\tstatus = ocfs2_read_journal_inode(osb, i, &bh, NULL);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tdi = (struct ocfs2_dinode *)bh->b_data;\n\t\tgen = ocfs2_get_recovery_generation(di);\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\n\t\tspin_lock(&osb->osb_lock);\n\t\tosb->slot_recovery_generations[i] = gen;\n\n\t\ttrace_ocfs2_mark_dead_nodes(i,\n\t\t\t\t\t    osb->slot_recovery_generations[i]);\n\n\t\tif (i == osb->slot_num) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = ocfs2_slot_to_node_num_locked(osb, i, &node_num);\n\t\tif (status == -ENOENT) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (__ocfs2_recovery_map_test(osb, node_num)) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&osb->osb_lock);\n\n\t\t \n\t\tstatus = ocfs2_trylock_journal(osb, i);\n\t\tif (!status) {\n\t\t\t \n\t\t\tocfs2_recovery_thread(osb, node_num);\n\t\t} else if ((status < 0) && (status != -EAGAIN)) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}\n\n \nstatic inline unsigned long ocfs2_orphan_scan_timeout(void)\n{\n\tunsigned long time;\n\n\tget_random_bytes(&time, sizeof(time));\n\ttime = ORPHAN_SCAN_SCHEDULE_TIMEOUT + (time % 5000);\n\treturn msecs_to_jiffies(time);\n}\n\n \nstatic void ocfs2_queue_orphan_scan(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\tint status, i;\n\tu32 seqno = 0;\n\n\tos = &osb->osb_orphan_scan;\n\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_INACTIVE)\n\t\tgoto out;\n\n\ttrace_ocfs2_queue_orphan_scan_begin(os->os_count, os->os_seqno,\n\t\t\t\t\t    atomic_read(&os->os_state));\n\n\tstatus = ocfs2_orphan_scan_lock(osb, &seqno);\n\tif (status < 0) {\n\t\tif (status != -EAGAIN)\n\t\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t \n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_INACTIVE)\n\t\tgoto unlock;\n\n\tif (os->os_seqno != seqno) {\n\t\tos->os_seqno = seqno;\n\t\tgoto unlock;\n\t}\n\n\tfor (i = 0; i < osb->max_slots; i++)\n\t\tocfs2_queue_recovery_completion(osb->journal, i, NULL, NULL,\n\t\t\t\t\t\tNULL, ORPHAN_NO_NEED_TRUNCATE);\n\t \n\tseqno++;\n\tos->os_count++;\n\tos->os_scantime = ktime_get_seconds();\nunlock:\n\tocfs2_orphan_scan_unlock(osb, seqno);\nout:\n\ttrace_ocfs2_queue_orphan_scan_end(os->os_count, os->os_seqno,\n\t\t\t\t\t  atomic_read(&os->os_state));\n\treturn;\n}\n\n \nstatic void ocfs2_orphan_scan_work(struct work_struct *work)\n{\n\tstruct ocfs2_orphan_scan *os;\n\tstruct ocfs2_super *osb;\n\n\tos = container_of(work, struct ocfs2_orphan_scan,\n\t\t\t  os_orphan_scan_work.work);\n\tosb = os->os_osb;\n\n\tmutex_lock(&os->os_lock);\n\tocfs2_queue_orphan_scan(osb);\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_ACTIVE)\n\t\tqueue_delayed_work(osb->ocfs2_wq, &os->os_orphan_scan_work,\n\t\t\t\t      ocfs2_orphan_scan_timeout());\n\tmutex_unlock(&os->os_lock);\n}\n\nvoid ocfs2_orphan_scan_stop(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\n\tos = &osb->osb_orphan_scan;\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_ACTIVE) {\n\t\tatomic_set(&os->os_state, ORPHAN_SCAN_INACTIVE);\n\t\tmutex_lock(&os->os_lock);\n\t\tcancel_delayed_work(&os->os_orphan_scan_work);\n\t\tmutex_unlock(&os->os_lock);\n\t}\n}\n\nvoid ocfs2_orphan_scan_init(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\n\tos = &osb->osb_orphan_scan;\n\tos->os_osb = osb;\n\tos->os_count = 0;\n\tos->os_seqno = 0;\n\tmutex_init(&os->os_lock);\n\tINIT_DELAYED_WORK(&os->os_orphan_scan_work, ocfs2_orphan_scan_work);\n}\n\nvoid ocfs2_orphan_scan_start(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\n\tos = &osb->osb_orphan_scan;\n\tos->os_scantime = ktime_get_seconds();\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_mount_local(osb))\n\t\tatomic_set(&os->os_state, ORPHAN_SCAN_INACTIVE);\n\telse {\n\t\tatomic_set(&os->os_state, ORPHAN_SCAN_ACTIVE);\n\t\tqueue_delayed_work(osb->ocfs2_wq, &os->os_orphan_scan_work,\n\t\t\t\t   ocfs2_orphan_scan_timeout());\n\t}\n}\n\nstruct ocfs2_orphan_filldir_priv {\n\tstruct dir_context\tctx;\n\tstruct inode\t\t*head;\n\tstruct ocfs2_super\t*osb;\n\tenum ocfs2_orphan_reco_type orphan_reco_type;\n};\n\nstatic bool ocfs2_orphan_filldir(struct dir_context *ctx, const char *name,\n\t\t\t\tint name_len, loff_t pos, u64 ino,\n\t\t\t\tunsigned type)\n{\n\tstruct ocfs2_orphan_filldir_priv *p =\n\t\tcontainer_of(ctx, struct ocfs2_orphan_filldir_priv, ctx);\n\tstruct inode *iter;\n\n\tif (name_len == 1 && !strncmp(\".\", name, 1))\n\t\treturn true;\n\tif (name_len == 2 && !strncmp(\"..\", name, 2))\n\t\treturn true;\n\n\t \n\tif ((p->orphan_reco_type == ORPHAN_NO_NEED_TRUNCATE) &&\n\t\t\t(!strncmp(name, OCFS2_DIO_ORPHAN_PREFIX,\n\t\t\tOCFS2_DIO_ORPHAN_PREFIX_LEN)))\n\t\treturn true;\n\n\t \n\titer = ocfs2_iget(p->osb, ino,\n\t\t\t  OCFS2_FI_FLAG_ORPHAN_RECOVERY, 0);\n\tif (IS_ERR(iter))\n\t\treturn true;\n\n\tif (!strncmp(name, OCFS2_DIO_ORPHAN_PREFIX,\n\t\t\tOCFS2_DIO_ORPHAN_PREFIX_LEN))\n\t\tOCFS2_I(iter)->ip_flags |= OCFS2_INODE_DIO_ORPHAN_ENTRY;\n\n\t \n\tif (OCFS2_I(iter)->ip_next_orphan) {\n\t\tiput(iter);\n\t\treturn true;\n\t}\n\n\ttrace_ocfs2_orphan_filldir((unsigned long long)OCFS2_I(iter)->ip_blkno);\n\t \n\tOCFS2_I(iter)->ip_next_orphan = p->head;\n\tp->head = iter;\n\n\treturn true;\n}\n\nstatic int ocfs2_queue_orphans(struct ocfs2_super *osb,\n\t\t\t       int slot,\n\t\t\t       struct inode **head,\n\t\t\t       enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tint status;\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct ocfs2_orphan_filldir_priv priv = {\n\t\t.ctx.actor = ocfs2_orphan_filldir,\n\t\t.osb = osb,\n\t\t.head = *head,\n\t\t.orphan_reco_type = orphan_reco_type\n\t};\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t       slot);\n\tif  (!orphan_dir_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tinode_lock(orphan_dir_inode);\n\tstatus = ocfs2_inode_lock(orphan_dir_inode, NULL, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_dir_foreach(orphan_dir_inode, &priv.ctx);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_cluster;\n\t}\n\n\t*head = priv.head;\n\nout_cluster:\n\tocfs2_inode_unlock(orphan_dir_inode, 0);\nout:\n\tinode_unlock(orphan_dir_inode);\n\tiput(orphan_dir_inode);\n\treturn status;\n}\n\nstatic int ocfs2_orphan_recovery_can_continue(struct ocfs2_super *osb,\n\t\t\t\t\t      int slot)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = !osb->osb_orphan_wipes[slot];\n\tspin_unlock(&osb->osb_lock);\n\treturn ret;\n}\n\nstatic void ocfs2_mark_recovering_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t\t     int slot)\n{\n\tspin_lock(&osb->osb_lock);\n\t \n\tocfs2_node_map_set_bit(osb, &osb->osb_recovering_orphan_dirs, slot);\n\twhile (osb->osb_orphan_wipes[slot]) {\n\t\t \n\t\tspin_unlock(&osb->osb_lock);\n\t\twait_event_interruptible(osb->osb_wipe_event,\n\t\t\t\t\t ocfs2_orphan_recovery_can_continue(osb, slot));\n\t\tspin_lock(&osb->osb_lock);\n\t}\n\tspin_unlock(&osb->osb_lock);\n}\n\nstatic void ocfs2_clear_recovering_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t\t      int slot)\n{\n\tocfs2_node_map_clear_bit(osb, &osb->osb_recovering_orphan_dirs, slot);\n}\n\n \nstatic int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tint ret = 0;\n\tstruct inode *inode = NULL;\n\tstruct inode *iter;\n\tstruct ocfs2_inode_info *oi;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\n\ttrace_ocfs2_recover_orphans(slot);\n\n\tocfs2_mark_recovering_orphan_dir(osb, slot);\n\tret = ocfs2_queue_orphans(osb, slot, &inode, orphan_reco_type);\n\tocfs2_clear_recovering_orphan_dir(osb, slot);\n\n\t \n\tif (ret)\n\t\tmlog_errno(ret);\n\n\twhile (inode) {\n\t\toi = OCFS2_I(inode);\n\t\ttrace_ocfs2_recover_orphans_iput(\n\t\t\t\t\t(unsigned long long)oi->ip_blkno);\n\n\t\titer = oi->ip_next_orphan;\n\t\toi->ip_next_orphan = NULL;\n\n\t\tif (oi->ip_flags & OCFS2_INODE_DIO_ORPHAN_ENTRY) {\n\t\t\tinode_lock(inode);\n\t\t\tret = ocfs2_rw_lock(inode, 1);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto unlock_mutex;\n\t\t\t}\n\t\t\t \n\t\t\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto unlock_rw;\n\t\t\t}\n\n\t\t\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\t\t\tif (di->i_flags & cpu_to_le32(OCFS2_DIO_ORPHANED_FL)) {\n\t\t\t\tret = ocfs2_truncate_file(inode, di_bh,\n\t\t\t\t\t\ti_size_read(inode));\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (ret != -ENOSPC)\n\t\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto unlock_inode;\n\t\t\t\t}\n\n\t\t\t\tret = ocfs2_del_inode_from_orphan(osb, inode,\n\t\t\t\t\t\tdi_bh, 0, 0);\n\t\t\t\tif (ret)\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t}\nunlock_inode:\n\t\t\tocfs2_inode_unlock(inode, 1);\n\t\t\tbrelse(di_bh);\n\t\t\tdi_bh = NULL;\nunlock_rw:\n\t\t\tocfs2_rw_unlock(inode, 1);\nunlock_mutex:\n\t\t\tinode_unlock(inode);\n\n\t\t\t \n\t\t\toi->ip_flags &= ~OCFS2_INODE_DIO_ORPHAN_ENTRY;\n\t\t} else {\n\t\t\tspin_lock(&oi->ip_lock);\n\t\t\t \n\t\t\toi->ip_flags |= OCFS2_INODE_MAYBE_ORPHANED;\n\t\t\tspin_unlock(&oi->ip_lock);\n\t\t}\n\n\t\tiput(inode);\n\t\tinode = iter;\n\t}\n\n\treturn ret;\n}\n\nstatic int __ocfs2_wait_on_mount(struct ocfs2_super *osb, int quota)\n{\n\t \n\twait_event(osb->osb_mount_event,\n\t\t  (!quota && atomic_read(&osb->vol_state) == VOLUME_MOUNTED) ||\n\t\t   atomic_read(&osb->vol_state) == VOLUME_MOUNTED_QUOTAS ||\n\t\t   atomic_read(&osb->vol_state) == VOLUME_DISABLED);\n\n\t \n\tif (atomic_read(&osb->vol_state) == VOLUME_DISABLED) {\n\t\ttrace_ocfs2_wait_on_mount(VOLUME_DISABLED);\n\t\tmlog(0, \"mount error, exiting!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int ocfs2_commit_thread(void *arg)\n{\n\tint status;\n\tstruct ocfs2_super *osb = arg;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\t \n\twhile (!(kthread_should_stop() &&\n\t\t atomic_read(&journal->j_num_trans) == 0)) {\n\n\t\twait_event_interruptible(osb->checkpoint_event,\n\t\t\t\t\t atomic_read(&journal->j_num_trans)\n\t\t\t\t\t || kthread_should_stop());\n\n\t\tstatus = ocfs2_commit_cache(osb);\n\t\tif (status < 0) {\n\t\t\tstatic unsigned long abort_warn_time;\n\n\t\t\t \n\t\t\tif (printk_timed_ratelimit(&abort_warn_time, 60*HZ))\n\t\t\t\tmlog(ML_ERROR, \"status = %d, journal is \"\n\t\t\t\t\t\t\"already aborted.\\n\", status);\n\t\t\t \n\t\t\tmsleep_interruptible(1000);\n\t\t}\n\n\t\tif (kthread_should_stop() && atomic_read(&journal->j_num_trans)){\n\t\t\tmlog(ML_KTHREAD,\n\t\t\t     \"commit_thread: %u transactions pending on \"\n\t\t\t     \"shutdown\\n\",\n\t\t\t     atomic_read(&journal->j_num_trans));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint ocfs2_check_journals_nolocks(struct ocfs2_super *osb)\n{\n\tint ret = 0;\n\tunsigned int slot;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint journal_dirty = 0;\n\n\tfor(slot = 0; slot < osb->max_slots; slot++) {\n\t\tret = ocfs2_read_journal_inode(osb, slot, &di_bh, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\n\t\tosb->slot_recovery_generations[slot] =\n\t\t\t\t\tocfs2_get_recovery_generation(di);\n\n\t\tif (le32_to_cpu(di->id1.journal1.ij_flags) &\n\t\t    OCFS2_JOURNAL_DIRTY_FL)\n\t\t\tjournal_dirty = 1;\n\n\t\tbrelse(di_bh);\n\t\tdi_bh = NULL;\n\t}\n\nout:\n\tif (journal_dirty)\n\t\tret = -EROFS;\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}