{
  "module_name": "dlmast.c",
  "hash_id": "4509a31146ac6e4fbe57c20b4ba600ef1d52ad46032b757f04ed03338851532a",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/dlm/dlmast.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/socket.h>\n#include <linux/inet.h>\n#include <linux/spinlock.h>\n\n\n#include \"../cluster/heartbeat.h\"\n#include \"../cluster/nodemanager.h\"\n#include \"../cluster/tcp.h\"\n\n#include \"dlmapi.h\"\n#include \"dlmcommon.h\"\n\n#define MLOG_MASK_PREFIX ML_DLM\n#include \"../cluster/masklog.h\"\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\n \nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tassert_spin_locked(&dlm->ast_lock);\n\tassert_spin_locked(&lock->spinlock);\n\n\tif (lock->ml.highest_blocked == LKM_IVMODE)\n\t\treturn 0;\n\tBUG_ON(lock->ml.highest_blocked == LKM_NLMODE);\n\n\tif (lock->bast_pending &&\n\t    list_empty(&lock->bast_list))\n\t\t \n\t\treturn 0;\n\n\tif (lock->ml.type == LKM_EXMODE)\n\t\t \n\t\treturn 0;\n\telse if (lock->ml.type == LKM_NLMODE)\n\t\t \n\t\treturn 1;\n\telse if (lock->ml.highest_blocked != LKM_EXMODE)\n\t\t \n\t\treturn 1;\n\n\treturn 0;\n}\n\nvoid __dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tres = lock->lockres;\n\n\tassert_spin_locked(&dlm->ast_lock);\n\n\tif (!list_empty(&lock->ast_list)) {\n\t\tmlog(ML_ERROR, \"%s: res %.*s, lock %u:%llu, \"\n\t\t     \"AST list not empty, pending %d, newlevel %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     lock->ast_pending, lock->ml.type);\n\t\tBUG();\n\t}\n\tif (lock->ast_pending)\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, AST getting flushed\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\t \n\tdlm_lock_get(lock);\n\tspin_lock(&lock->spinlock);\n\n\t \n\tif (dlm_should_cancel_bast(dlm, lock)) {\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, Cancelling BAST\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\t\tlock->bast_pending = 0;\n\t\tlist_del_init(&lock->bast_list);\n\t\tlock->ml.highest_blocked = LKM_IVMODE;\n\t\t \n\t\tdlm_lock_put(lock);\n\t\t \n\t\tdlm_lockres_release_ast(dlm, res);\n\t}\n\tlist_add_tail(&lock->ast_list, &dlm->pending_asts);\n\tlock->ast_pending = 1;\n\tspin_unlock(&lock->spinlock);\n}\n\nvoid dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tspin_lock(&dlm->ast_lock);\n\t__dlm_queue_ast(dlm, lock);\n\tspin_unlock(&dlm->ast_lock);\n}\n\n\nvoid __dlm_queue_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tassert_spin_locked(&dlm->ast_lock);\n\n\tres = lock->lockres;\n\n\tBUG_ON(!list_empty(&lock->bast_list));\n\tif (lock->bast_pending)\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, BAST getting flushed\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\t \n\tdlm_lock_get(lock);\n\tspin_lock(&lock->spinlock);\n\tlist_add_tail(&lock->bast_list, &dlm->pending_basts);\n\tlock->bast_pending = 1;\n\tspin_unlock(&lock->spinlock);\n}\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock)\n{\n\tstruct dlm_lockstatus *lksb = lock->lksb;\n\tBUG_ON(!lksb);\n\n\t \n\tspin_lock(&res->spinlock);\n\tif (res->owner == dlm->node_num) {\n\t\t \n\t\tif (lksb->flags & DLM_LKSB_GET_LVB) {\n\t\t\tmlog(0, \"getting lvb from lockres for %s node\\n\",\n\t\t\t\t  lock->ml.node == dlm->node_num ? \"master\" :\n\t\t\t\t  \"remote\");\n\t\t\tmemcpy(lksb->lvb, res->lvb, DLM_LVB_LEN);\n\t\t}\n\t\t \n\t}\n\tspin_unlock(&res->spinlock);\n\n\t \n\tlksb->flags &= ~(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB);\n}\n\nvoid dlm_do_local_ast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t      struct dlm_lock *lock)\n{\n\tdlm_astlockfunc_t *fn;\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Local AST\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\tfn = lock->ast;\n\tBUG_ON(lock->ml.node != dlm->node_num);\n\n\tdlm_update_lvb(dlm, res, lock);\n\t(*fn)(lock->astdata);\n}\n\n\nint dlm_do_remote_ast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t      struct dlm_lock *lock)\n{\n\tint ret;\n\tstruct dlm_lockstatus *lksb;\n\tint lksbflags;\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Remote AST\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\tlksb = lock->lksb;\n\tBUG_ON(lock->ml.node == dlm->node_num);\n\n\tlksbflags = lksb->flags;\n\tdlm_update_lvb(dlm, res, lock);\n\n\t \n\tret = dlm_send_proxy_ast(dlm, res, lock, lksbflags);\n\treturn ret;\n}\n\nvoid dlm_do_local_bast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t       struct dlm_lock *lock, int blocked_type)\n{\n\tdlm_bastlockfunc_t *fn = lock->bast;\n\n\tBUG_ON(lock->ml.node != dlm->node_num);\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Local BAST, blocked %d\\n\",\n\t     dlm->name, res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t     blocked_type);\n\n\t(*fn)(lock->astdata, blocked_type);\n}\n\n\n\nint dlm_proxy_ast_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t  void **ret_data)\n{\n\tint ret;\n\tunsigned int locklen;\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *lock = NULL;\n\tstruct dlm_proxy_ast *past = (struct dlm_proxy_ast *) msg->buf;\n\tchar *name;\n\tstruct list_head *head = NULL;\n\t__be64 cookie;\n\tu32 flags;\n\tu8 node;\n\n\tif (!dlm_grab(dlm)) {\n\t\tdlm_error(DLM_REJECTED);\n\t\treturn DLM_REJECTED;\n\t}\n\n\tmlog_bug_on_msg(!dlm_domain_fully_joined(dlm),\n\t\t\t\"Domain %s not fully joined!\\n\", dlm->name);\n\n\tname = past->name;\n\tlocklen = past->namelen;\n\tcookie = past->cookie;\n\tflags = be32_to_cpu(past->flags);\n\tnode = past->node_idx;\n\n\tif (locklen > DLM_LOCKID_NAME_MAX) {\n\t\tret = DLM_IVBUFLEN;\n\t\tmlog(ML_ERROR, \"Invalid name length (%d) in proxy ast \"\n\t\t     \"handler!\\n\", locklen);\n\t\tgoto leave;\n\t}\n\n\tif ((flags & (LKM_PUT_LVB|LKM_GET_LVB)) ==\n\t     (LKM_PUT_LVB|LKM_GET_LVB)) {\n\t\tmlog(ML_ERROR, \"Both PUT and GET lvb specified, (0x%x)\\n\",\n\t\t     flags);\n\t\tret = DLM_BADARGS;\n\t\tgoto leave;\n\t}\n\n\tmlog(0, \"lvb: %s\\n\", flags & LKM_PUT_LVB ? \"put lvb\" :\n\t\t  (flags & LKM_GET_LVB ? \"get lvb\" : \"none\"));\n\n\tmlog(0, \"type=%d, blocked_type=%d\\n\", past->type, past->blocked_type);\n\n\tif (past->type != DLM_AST &&\n\t    past->type != DLM_BAST) {\n\t\tmlog(ML_ERROR, \"Unknown ast type! %d, cookie=%u:%llu\"\n\t\t     \"name=%.*s, node=%u\\n\", past->type,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(cookie)),\n\t\t     locklen, name, node);\n\t\tret = DLM_IVLOCKID;\n\t\tgoto leave;\n\t}\n\n\tres = dlm_lookup_lockres(dlm, name, locklen);\n\tif (!res) {\n\t\tmlog(0, \"Got %sast for unknown lockres! cookie=%u:%llu, \"\n\t\t     \"name=%.*s, node=%u\\n\", (past->type == DLM_AST ? \"\" : \"b\"),\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(cookie)),\n\t\t     locklen, name, node);\n\t\tret = DLM_IVLOCKID;\n\t\tgoto leave;\n\t}\n\n\t \n\tBUG_ON(res->owner == dlm->node_num);\n\n\tmlog(0, \"%s: res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\tmlog(0, \"Responding with DLM_RECOVERING!\\n\");\n\t\tret = DLM_RECOVERING;\n\t\tgoto unlock_out;\n\t}\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\tmlog(0, \"Responding with DLM_MIGRATING!\\n\");\n\t\tret = DLM_MIGRATING;\n\t\tgoto unlock_out;\n\t}\n\t \n\thead = &res->converting;\n\tlock = NULL;\n\tlist_for_each_entry(lock, head, list) {\n\t\tif (lock->ml.cookie == cookie)\n\t\t\tgoto do_ast;\n\t}\n\n\t \n\tif (past->type == DLM_AST)\n\t\thead = &res->blocked;\n\telse\n\t\thead = &res->granted;\n\n\tlist_for_each_entry(lock, head, list) {\n\t\t \n\t\tif (lock->ml.cookie == cookie) {\n\t\t\tif (lock->unlock_pending)\n\t\t\t\tbreak;\n\t\t\tgoto do_ast;\n\t\t}\n\t}\n\n\tmlog(0, \"Got %sast for unknown lock! cookie=%u:%llu, name=%.*s, \"\n\t     \"node=%u\\n\", past->type == DLM_AST ? \"\" : \"b\",\n\t     dlm_get_lock_cookie_node(be64_to_cpu(cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(cookie)),\n\t     locklen, name, node);\n\n\tret = DLM_NORMAL;\nunlock_out:\n\tspin_unlock(&res->spinlock);\n\tgoto leave;\n\ndo_ast:\n\tret = DLM_NORMAL;\n\tif (past->type == DLM_AST) {\n\t\t \n\t\tlist_move_tail(&lock->list, &res->granted);\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, Granted type %d => %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(cookie)),\n\t\t     lock->ml.type, lock->ml.convert_type);\n\n\t\tif (lock->ml.convert_type != LKM_IVMODE) {\n\t\t\tlock->ml.type = lock->ml.convert_type;\n\t\t\tlock->ml.convert_type = LKM_IVMODE;\n\t\t} else {\n\t\t\t\n\t\t}\n\n\t\tlock->lksb->status = DLM_NORMAL;\n\n\t\t \n\t\tif (flags & LKM_GET_LVB) {\n\t\t\tBUG_ON(!(lock->lksb->flags & DLM_LKSB_GET_LVB));\n\t\t\tmemcpy(lock->lksb->lvb, past->lvb, DLM_LVB_LEN);\n\t\t}\n\t}\n\tspin_unlock(&res->spinlock);\n\n\tif (past->type == DLM_AST)\n\t\tdlm_do_local_ast(dlm, res, lock);\n\telse\n\t\tdlm_do_local_bast(dlm, res, lock, past->blocked_type);\n\nleave:\n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\tdlm_put(dlm);\n\treturn ret;\n}\n\n\n\nint dlm_send_proxy_ast_msg(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock, int msg_type,\n\t\t\t   int blocked_type, int flags)\n{\n\tint ret = 0;\n\tstruct dlm_proxy_ast past;\n\tstruct kvec vec[2];\n\tsize_t veclen = 1;\n\tint status;\n\n\tmlog(0, \"%s: res %.*s, to %u, type %d, blocked_type %d\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, lock->ml.node, msg_type,\n\t     blocked_type);\n\n\tmemset(&past, 0, sizeof(struct dlm_proxy_ast));\n\tpast.node_idx = dlm->node_num;\n\tpast.type = msg_type;\n\tpast.blocked_type = blocked_type;\n\tpast.namelen = res->lockname.len;\n\tmemcpy(past.name, res->lockname.name, past.namelen);\n\tpast.cookie = lock->ml.cookie;\n\n\tvec[0].iov_len = sizeof(struct dlm_proxy_ast);\n\tvec[0].iov_base = &past;\n\tif (flags & DLM_LKSB_GET_LVB) {\n\t\tbe32_add_cpu(&past.flags, LKM_GET_LVB);\n\t\tvec[1].iov_len = DLM_LVB_LEN;\n\t\tvec[1].iov_base = lock->lksb->lvb;\n\t\tveclen++;\n\t}\n\n\tret = o2net_send_message_vec(DLM_PROXY_AST_MSG, dlm->key, vec, veclen,\n\t\t\t\t     lock->ml.node, &status);\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"%s: res %.*s, error %d send AST to node %u\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name, ret,\n\t\t     lock->ml.node);\n\telse {\n\t\tif (status == DLM_RECOVERING) {\n\t\t\tmlog(ML_ERROR, \"sent AST to node %u, it thinks this \"\n\t\t\t     \"node is dead!\\n\", lock->ml.node);\n\t\t\tBUG();\n\t\t} else if (status == DLM_MIGRATING) {\n\t\t\tmlog(ML_ERROR, \"sent AST to node %u, it returned \"\n\t\t\t     \"DLM_MIGRATING!\\n\", lock->ml.node);\n\t\t\tBUG();\n\t\t} else if (status != DLM_NORMAL && status != DLM_IVLOCKID) {\n\t\t\tmlog(ML_ERROR, \"AST to node %u returned %d!\\n\",\n\t\t\t     lock->ml.node, status);\n\t\t\t \n\t\t}\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}