{
  "module_name": "dlmlock.c",
  "hash_id": "20ea4456c37fb93983cb0a063ae6bc145be88392cf81cb675f2684efbfbc66d0",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/dlm/dlmlock.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/socket.h>\n#include <linux/inet.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n\n\n#include \"../cluster/heartbeat.h\"\n#include \"../cluster/nodemanager.h\"\n#include \"../cluster/tcp.h\"\n\n#include \"dlmapi.h\"\n#include \"dlmcommon.h\"\n\n#include \"dlmconvert.h\"\n\n#define MLOG_MASK_PREFIX ML_DLM\n#include \"../cluster/masklog.h\"\n\nstatic struct kmem_cache *dlm_lock_cache;\n\nstatic DEFINE_SPINLOCK(dlm_cookie_lock);\nstatic u64 dlm_next_cookie = 1;\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);\nstatic void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);\nstatic void dlm_lock_release(struct kref *kref);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nint dlm_init_lock_cache(void)\n{\n\tdlm_lock_cache = kmem_cache_create(\"o2dlm_lock\",\n\t\t\t\t\t   sizeof(struct dlm_lock),\n\t\t\t\t\t   0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (dlm_lock_cache == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid dlm_destroy_lock_cache(void)\n{\n\tkmem_cache_destroy(dlm_lock_cache);\n}\n\n \nstatic int dlm_can_grant_new_lock(struct dlm_lock_resource *res,\n\t\t\t\t  struct dlm_lock *lock)\n{\n\tstruct dlm_lock *tmplock;\n\n\tlist_for_each_entry(tmplock, &res->granted, list) {\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, lock->ml.type))\n\t\t\treturn 0;\n\t}\n\n\tlist_for_each_entry(tmplock, &res->converting, list) {\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, lock->ml.type))\n\t\t\treturn 0;\n\t\tif (!dlm_lock_compatible(tmplock->ml.convert_type,\n\t\t\t\t\t lock->ml.type))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic enum dlm_status dlmlock_master(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      struct dlm_lock *lock, int flags)\n{\n\tint call_ast = 0, kick_thread = 0;\n\tenum dlm_status status = DLM_NORMAL;\n\n\tmlog(0, \"type=%d\\n\", lock->ml.type);\n\n\tspin_lock(&res->spinlock);\n\t \n\tstatus = __dlm_lockres_state_to_status(res);\n\tif (status != DLM_NORMAL &&\n\t    lock->ml.node != dlm->node_num) {\n\t\t \n\t\tspin_unlock(&res->spinlock);\n\t\tdlm_error(status);\n\t\treturn status;\n\t}\n\t__dlm_wait_on_lockres(res);\n\t__dlm_lockres_reserve_ast(res);\n\n\tif (dlm_can_grant_new_lock(res, lock)) {\n\t\tmlog(0, \"I can grant this lock right away\\n\");\n\t\t \n\t\tlock->lksb->status = DLM_NORMAL;\n\t\tstatus = DLM_NORMAL;\n\t\tdlm_lock_get(lock);\n\t\tlist_add_tail(&lock->list, &res->granted);\n\n\t\t \n\t\tif (!dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t  res->lockname.len)) {\n\t\t\tkick_thread = 1;\n\t\t\tcall_ast = 1;\n\t\t} else {\n\t\t\tmlog(0, \"%s: returning DLM_NORMAL to \"\n\t\t\t     \"node %u for reco lock\\n\", dlm->name,\n\t\t\t     lock->ml.node);\n\t\t}\n\t} else {\n\t\t \n\t\tif (flags & LKM_NOQUEUE) {\n\t\t\tstatus = DLM_NOTQUEUED;\n\t\t\tif (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t\t res->lockname.len)) {\n\t\t\t\tmlog(0, \"%s: returning NOTQUEUED to \"\n\t\t\t\t     \"node %u for reco lock\\n\", dlm->name,\n\t\t\t\t     lock->ml.node);\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = DLM_NORMAL;\n\t\t\tdlm_lock_get(lock);\n\t\t\tlist_add_tail(&lock->list, &res->blocked);\n\t\t\tkick_thread = 1;\n\t\t}\n\t}\n\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\t \n\tif (call_ast)\n\t\tdlm_queue_ast(dlm, lock);\n\telse\n\t\tdlm_lockres_release_ast(dlm, res);\n\n\tdlm_lockres_calc_usage(dlm, res);\n\tif (kick_thread)\n\t\tdlm_kick_thread(dlm, res);\n\n\treturn status;\n}\n\nvoid dlm_revert_pending_lock(struct dlm_lock_resource *res,\n\t\t\t     struct dlm_lock *lock)\n{\n\t \n\tlist_del_init(&lock->list);\n\tlock->lksb->flags &= ~DLM_LKSB_GET_LVB;\n}\n\n\n \nstatic enum dlm_status dlmlock_remote(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      struct dlm_lock *lock, int flags)\n{\n\tenum dlm_status status = DLM_DENIED;\n\tint lockres_changed = 1;\n\n\tmlog(0, \"type=%d, lockres %.*s, flags = 0x%x\\n\",\n\t     lock->ml.type, res->lockname.len,\n\t     res->lockname.name, flags);\n\n\t \n\tspin_lock(&res->spinlock);\n\t__dlm_wait_on_lockres(res);\n\tif (res->owner == dlm->node_num) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn DLM_RECOVERING;\n\t}\n\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\n\t \n\tdlm_lock_get(lock);\n\tlist_add_tail(&lock->list, &res->blocked);\n\tlock->lock_pending = 1;\n\tspin_unlock(&res->spinlock);\n\n\t \n\tstatus = dlm_send_remote_lock_request(dlm, res, lock, flags);\n\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tlock->lock_pending = 0;\n\tif (status != DLM_NORMAL) {\n\t\tif (status == DLM_RECOVERING &&\n\t\t    dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t res->lockname.len)) {\n\t\t\t \n\t\t\tmlog(0, \"%s: recovery lock was owned by \"\n\t\t\t     \"dead node %u, remaster it now.\\n\",\n\t\t\t     dlm->name, res->owner);\n\t\t} else if (status != DLM_NOTQUEUED) {\n\t\t\t \n\t\t\tlockres_changed = 0;\n\t\t\tdlm_error(status);\n\t\t}\n\t\tdlm_revert_pending_lock(res, lock);\n\t\tdlm_lock_put(lock);\n\t} else if (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\tres->lockname.len)) {\n\t\t \n\t\tmlog(0, \"%s: $RECOVERY lock for this node (%u) is \"\n\t\t     \"mastered by %u; got lock, manually granting (no ast)\\n\",\n\t\t     dlm->name, dlm->node_num, res->owner);\n\t\tlist_move_tail(&lock->list, &res->granted);\n\t}\n\tspin_unlock(&res->spinlock);\n\n\tif (lockres_changed)\n\t\tdlm_lockres_calc_usage(dlm, res);\n\n\twake_up(&res->wq);\n\treturn status;\n}\n\n\n \nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags)\n{\n\tstruct dlm_create_lock create;\n\tint tmpret, status = 0;\n\tenum dlm_status ret;\n\n\tmemset(&create, 0, sizeof(create));\n\tcreate.node_idx = dlm->node_num;\n\tcreate.requested_type = lock->ml.type;\n\tcreate.cookie = lock->ml.cookie;\n\tcreate.namelen = res->lockname.len;\n\tcreate.flags = cpu_to_be32(flags);\n\tmemcpy(create.name, res->lockname.name, create.namelen);\n\n\ttmpret = o2net_send_message(DLM_CREATE_LOCK_MSG, dlm->key, &create,\n\t\t\t\t    sizeof(create), res->owner, &status);\n\tif (tmpret >= 0) {\n\t\tret = status;\n\t\tif (ret == DLM_REJECTED) {\n\t\t\tmlog(ML_ERROR, \"%s: res %.*s, Stale lockres no longer \"\n\t\t\t     \"owned by node %u. That node is coming back up \"\n\t\t\t     \"currently.\\n\", dlm->name, create.namelen,\n\t\t\t     create.name, res->owner);\n\t\t\tdlm_print_one_lock_resource(res);\n\t\t\tBUG();\n\t\t}\n\t} else {\n\t\tmlog(ML_ERROR, \"%s: res %.*s, Error %d send CREATE LOCK to \"\n\t\t     \"node %u\\n\", dlm->name, create.namelen, create.name,\n\t\t     tmpret, res->owner);\n\t\tif (dlm_is_host_down(tmpret))\n\t\t\tret = DLM_RECOVERING;\n\t\telse\n\t\t\tret = dlm_err_to_dlm_status(tmpret);\n\t}\n\n\treturn ret;\n}\n\nvoid dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}\n\nvoid dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}\n\nstatic void dlm_lock_release(struct kref *kref)\n{\n\tstruct dlm_lock *lock;\n\n\tlock = container_of(kref, struct dlm_lock, lock_refs);\n\n\tBUG_ON(!list_empty(&lock->list));\n\tBUG_ON(!list_empty(&lock->ast_list));\n\tBUG_ON(!list_empty(&lock->bast_list));\n\tBUG_ON(lock->ast_pending);\n\tBUG_ON(lock->bast_pending);\n\n\tdlm_lock_detach_lockres(lock);\n\n\tif (lock->lksb_kernel_allocated) {\n\t\tmlog(0, \"freeing kernel-allocated lksb\\n\");\n\t\tkfree(lock->lksb);\n\t}\n\tkmem_cache_free(dlm_lock_cache, lock);\n}\n\n \nvoid dlm_lock_attach_lockres(struct dlm_lock *lock,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tdlm_lockres_get(res);\n\tlock->lockres = res;\n}\n\n \nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tres = lock->lockres;\n\tif (res) {\n\t\tlock->lockres = NULL;\n\t\tmlog(0, \"removing lock's lockres reference\\n\");\n\t\tdlm_lockres_put(res);\n\t}\n}\n\nstatic void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie)\n{\n\tINIT_LIST_HEAD(&newlock->list);\n\tINIT_LIST_HEAD(&newlock->ast_list);\n\tINIT_LIST_HEAD(&newlock->bast_list);\n\tspin_lock_init(&newlock->spinlock);\n\tnewlock->ml.type = type;\n\tnewlock->ml.convert_type = LKM_IVMODE;\n\tnewlock->ml.highest_blocked = LKM_IVMODE;\n\tnewlock->ml.node = node;\n\tnewlock->ml.pad1 = 0;\n\tnewlock->ml.list = 0;\n\tnewlock->ml.flags = 0;\n\tnewlock->ast = NULL;\n\tnewlock->bast = NULL;\n\tnewlock->astdata = NULL;\n\tnewlock->ml.cookie = cpu_to_be64(cookie);\n\tnewlock->ast_pending = 0;\n\tnewlock->bast_pending = 0;\n\tnewlock->convert_pending = 0;\n\tnewlock->lock_pending = 0;\n\tnewlock->unlock_pending = 0;\n\tnewlock->cancel_pending = 0;\n\tnewlock->lksb_kernel_allocated = 0;\n\n\tkref_init(&newlock->lock_refs);\n}\n\nstruct dlm_lock * dlm_new_lock(int type, u8 node, u64 cookie,\n\t\t\t       struct dlm_lockstatus *lksb)\n{\n\tstruct dlm_lock *lock;\n\tint kernel_allocated = 0;\n\n\tlock = kmem_cache_zalloc(dlm_lock_cache, GFP_NOFS);\n\tif (!lock)\n\t\treturn NULL;\n\n\tif (!lksb) {\n\t\t \n\t\tlksb = kzalloc(sizeof(*lksb), GFP_NOFS);\n\t\tif (!lksb) {\n\t\t\tkmem_cache_free(dlm_lock_cache, lock);\n\t\t\treturn NULL;\n\t\t}\n\t\tkernel_allocated = 1;\n\t}\n\n\tdlm_init_lock(lock, type, node, cookie);\n\tif (kernel_allocated)\n\t\tlock->lksb_kernel_allocated = 1;\n\tlock->lksb = lksb;\n\tlksb->lockid = lock;\n\treturn lock;\n}\n\n \nint dlm_create_lock_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t    void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_create_lock *create = (struct dlm_create_lock *)msg->buf;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *newlock = NULL;\n\tstruct dlm_lockstatus *lksb = NULL;\n\tenum dlm_status status = DLM_NORMAL;\n\tchar *name;\n\tunsigned int namelen;\n\n\tBUG_ON(!dlm);\n\n\tif (!dlm_grab(dlm))\n\t\treturn DLM_REJECTED;\n\n\tname = create->name;\n\tnamelen = create->namelen;\n\tstatus = DLM_REJECTED;\n\tif (!dlm_domain_fully_joined(dlm)) {\n\t\tmlog(ML_ERROR, \"Domain %s not fully joined, but node %u is \"\n\t\t     \"sending a create_lock message for lock %.*s!\\n\",\n\t\t     dlm->name, create->node_idx, namelen, name);\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = DLM_IVBUFLEN;\n\tif (namelen > DLM_LOCKID_NAME_MAX) {\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = DLM_SYSERR;\n\tnewlock = dlm_new_lock(create->requested_type,\n\t\t\t       create->node_idx,\n\t\t\t       be64_to_cpu(create->cookie), NULL);\n\tif (!newlock) {\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\n\tlksb = newlock->lksb;\n\n\tif (be32_to_cpu(create->flags) & LKM_GET_LVB) {\n\t\tlksb->flags |= DLM_LKSB_GET_LVB;\n\t\tmlog(0, \"set DLM_LKSB_GET_LVB flag\\n\");\n\t}\n\n\tstatus = DLM_IVLOCKID;\n\tres = dlm_lookup_lockres(dlm, name, namelen);\n\tif (!res) {\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&res->spinlock);\n\tstatus = __dlm_lockres_state_to_status(res);\n\tspin_unlock(&res->spinlock);\n\n\tif (status != DLM_NORMAL) {\n\t\tmlog(0, \"lockres recovering/migrating/in-progress\\n\");\n\t\tgoto leave;\n\t}\n\n\tdlm_lock_attach_lockres(newlock, res);\n\n\tstatus = dlmlock_master(dlm, res, newlock, be32_to_cpu(create->flags));\nleave:\n\tif (status != DLM_NORMAL)\n\t\tif (newlock)\n\t\t\tdlm_lock_put(newlock);\n\n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\tdlm_put(dlm);\n\n\treturn status;\n}\n\n\n \nstatic inline void dlm_get_next_cookie(u8 node_num, u64 *cookie)\n{\n\tu64 tmpnode = node_num;\n\n\t \n\ttmpnode <<= 56;\n\n\tspin_lock(&dlm_cookie_lock);\n\t*cookie = (dlm_next_cookie | tmpnode);\n\tif (++dlm_next_cookie & 0xff00000000000000ull) {\n\t\tmlog(0, \"This node's cookie will now wrap!\\n\");\n\t\tdlm_next_cookie = 1;\n\t}\n\tspin_unlock(&dlm_cookie_lock);\n}\n\nenum dlm_status dlmlock(struct dlm_ctxt *dlm, int mode,\n\t\t\tstruct dlm_lockstatus *lksb, int flags,\n\t\t\tconst char *name, int namelen, dlm_astlockfunc_t *ast,\n\t\t\tvoid *data, dlm_bastlockfunc_t *bast)\n{\n\tenum dlm_status status;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *lock = NULL;\n\tint convert = 0, recovery = 0;\n\n\t \n\tif (!lksb) {\n\t\tdlm_error(DLM_BADARGS);\n\t\treturn DLM_BADARGS;\n\t}\n\n\tstatus = DLM_BADPARAM;\n\tif (mode != LKM_EXMODE && mode != LKM_PRMODE && mode != LKM_NLMODE) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\n\tif (flags & ~LKM_VALID_FLAGS) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\n\tconvert = (flags & LKM_CONVERT);\n\trecovery = (flags & LKM_RECOVERY);\n\n\tif (recovery &&\n\t    (!dlm_is_recovery_lock(name, namelen) || convert) ) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\tif (convert && (flags & LKM_LOCAL)) {\n\t\tmlog(ML_ERROR, \"strange LOCAL convert request!\\n\");\n\t\tgoto error;\n\t}\n\n\tif (convert) {\n\t\t \n\n\t\t \n\t\tlock = lksb->lockid;\n\t\tif (!lock) {\n\t\t\tmlog(ML_ERROR, \"NULL lock pointer in convert \"\n\t\t\t     \"request\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tres = lock->lockres;\n\t\tif (!res) {\n\t\t\tmlog(ML_ERROR, \"NULL lockres pointer in convert \"\n\t\t\t     \"request\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tdlm_lockres_get(res);\n\n\t\t \n\t\tif (lock->lksb != lksb || lock->ast != ast ||\n\t\t    lock->bast != bast || lock->astdata != data) {\n\t\t\tstatus = DLM_BADARGS;\n\t\t\tmlog(ML_ERROR, \"new args:  lksb=%p, ast=%p, bast=%p, \"\n\t\t\t     \"astdata=%p\\n\", lksb, ast, bast, data);\n\t\t\tmlog(ML_ERROR, \"orig args: lksb=%p, ast=%p, bast=%p, \"\n\t\t\t     \"astdata=%p\\n\", lock->lksb, lock->ast,\n\t\t\t     lock->bast, lock->astdata);\n\t\t\tgoto error;\n\t\t}\nretry_convert:\n\t\tdlm_wait_for_recovery(dlm);\n\n\t\tif (res->owner == dlm->node_num)\n\t\t\tstatus = dlmconvert_master(dlm, res, lock, flags, mode);\n\t\telse\n\t\t\tstatus = dlmconvert_remote(dlm, res, lock, flags, mode);\n\t\tif (status == DLM_RECOVERING || status == DLM_MIGRATING ||\n\t\t    status == DLM_FORWARD) {\n\t\t\t \n\t\t\tmlog(0, \"retrying convert with migration/recovery/\"\n\t\t\t     \"in-progress\\n\");\n\t\t\tmsleep(100);\n\t\t\tgoto retry_convert;\n\t\t}\n\t} else {\n\t\tu64 tmpcookie;\n\n\t\t \n\t\tstatus = DLM_BADARGS;\n\t\tif (!name) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tstatus = DLM_IVBUFLEN;\n\t\tif (namelen > DLM_LOCKID_NAME_MAX || namelen < 1) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tdlm_get_next_cookie(dlm->node_num, &tmpcookie);\n\t\tlock = dlm_new_lock(mode, dlm->node_num, tmpcookie, lksb);\n\t\tif (!lock) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (!recovery)\n\t\t\tdlm_wait_for_recovery(dlm);\n\n\t\t \n\t\tres = dlm_get_lock_resource(dlm, name, namelen, flags);\n\t\tif (!res) {\n\t\t\tstatus = DLM_IVLOCKID;\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tmlog(0, \"type=%d, flags = 0x%x\\n\", mode, flags);\n\t\tmlog(0, \"creating lock: lock=%p res=%p\\n\", lock, res);\n\n\t\tdlm_lock_attach_lockres(lock, res);\n\t\tlock->ast = ast;\n\t\tlock->bast = bast;\n\t\tlock->astdata = data;\n\nretry_lock:\n\t\tif (flags & LKM_VALBLK) {\n\t\t\tmlog(0, \"LKM_VALBLK passed by caller\\n\");\n\n\t\t\t \n\t\t\tif (mode < LKM_PRMODE)\n\t\t\t\tflags &= ~LKM_VALBLK;\n\t\t\telse {\n\t\t\t\tflags |= LKM_GET_LVB;\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t}\n\t\t}\n\n\t\tif (res->owner == dlm->node_num)\n\t\t\tstatus = dlmlock_master(dlm, res, lock, flags);\n\t\telse\n\t\t\tstatus = dlmlock_remote(dlm, res, lock, flags);\n\n\t\tif (status == DLM_RECOVERING || status == DLM_MIGRATING ||\n\t\t    status == DLM_FORWARD) {\n\t\t\tmsleep(100);\n\t\t\tif (recovery) {\n\t\t\t\tif (status != DLM_RECOVERING)\n\t\t\t\t\tgoto retry_lock;\n\t\t\t\t \n\t\t\t\tdlm_wait_for_node_death(dlm, res->owner,\n\t\t\t\t\t\tDLM_NODE_DEATH_WAIT_MAX);\n\t\t\t} else {\n\t\t\t\tdlm_wait_for_recovery(dlm);\n\t\t\t\tgoto retry_lock;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tspin_lock(&res->spinlock);\n\t\tdlm_lockres_drop_inflight_ref(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\n\t\tdlm_lockres_calc_usage(dlm, res);\n\t\tdlm_kick_thread(dlm, res);\n\n\t\tif (status != DLM_NORMAL) {\n\t\t\tlock->lksb->flags &= ~DLM_LKSB_GET_LVB;\n\t\t\tif (status != DLM_NOTQUEUED)\n\t\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\t}\n\nerror:\n\tif (status != DLM_NORMAL) {\n\t\tif (lock && !convert)\n\t\t\tdlm_lock_put(lock);\n\t\t\n\t\tlksb->status = status;\n\t}\n\n\t \n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(dlmlock);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}