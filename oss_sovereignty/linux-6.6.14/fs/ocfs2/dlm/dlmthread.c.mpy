{
  "module_name": "dlmthread.c",
  "hash_id": "1a95921651a1c0ab45c60279fee79324647ec944e8f1bc7abce6e836ac896ce6",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/dlm/dlmthread.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/socket.h>\n#include <linux/inet.h>\n#include <linux/timer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\n\n#include \"../cluster/heartbeat.h\"\n#include \"../cluster/nodemanager.h\"\n#include \"../cluster/tcp.h\"\n\n#include \"dlmapi.h\"\n#include \"dlmcommon.h\"\n#include \"dlmdomain.h\"\n\n#define MLOG_MASK_PREFIX (ML_DLM|ML_DLM_THREAD)\n#include \"../cluster/masklog.h\"\n\nstatic int dlm_thread(void *data);\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\n \n \nvoid __dlm_wait_on_lockres_flags(struct dlm_lock_resource *res, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tassert_spin_locked(&res->spinlock);\n\n\tadd_wait_queue(&res->wq, &wait);\nrepeat:\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (res->state & flags) {\n\t\tspin_unlock(&res->spinlock);\n\t\tschedule();\n\t\tspin_lock(&res->spinlock);\n\t\tgoto repeat;\n\t}\n\tremove_wait_queue(&res->wq, &wait);\n\t__set_current_state(TASK_RUNNING);\n}\n\nint __dlm_lockres_has_locks(struct dlm_lock_resource *res)\n{\n\tif (list_empty(&res->granted) &&\n\t    list_empty(&res->converting) &&\n\t    list_empty(&res->blocked))\n\t\treturn 0;\n\treturn 1;\n}\n\n \nint __dlm_lockres_unused(struct dlm_lock_resource *res)\n{\n\tint bit;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tif (__dlm_lockres_has_locks(res))\n\t\treturn 0;\n\n\t \n\tif (res->inflight_locks)\n\t\treturn 0;\n\n\tif (!list_empty(&res->dirty) || res->state & DLM_LOCK_RES_DIRTY)\n\t\treturn 0;\n\n\tif (res->state & (DLM_LOCK_RES_RECOVERING|\n\t\t\tDLM_LOCK_RES_RECOVERY_WAITING))\n\t\treturn 0;\n\n\t \n\tbit = find_first_bit(res->refmap, O2NM_MAX_NODES);\n\tif (bit < O2NM_MAX_NODES)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n\n \nvoid __dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tif (__dlm_lockres_unused(res)){\n\t\tif (list_empty(&res->purge)) {\n\t\t\tmlog(0, \"%s: Adding res %.*s to purge list\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\n\t\t\tres->last_used = jiffies;\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->purge, &dlm->purge_list);\n\t\t\tdlm->purge_count++;\n\t\t}\n\t} else if (!list_empty(&res->purge)) {\n\t\tmlog(0, \"%s: Removing res %.*s from purge list\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\n\t\tlist_del_init(&res->purge);\n\t\tdlm_lockres_put(res);\n\t\tdlm->purge_count--;\n\t}\n}\n\nvoid dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}\n\n \nvoid __dlm_do_purge_lockres(struct dlm_ctxt *dlm,\n\t\tstruct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tif (!list_empty(&res->purge)) {\n\t\tmlog(0, \"%s: Removing res %.*s from purgelist\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\tlist_del_init(&res->purge);\n\t\tdlm_lockres_put(res);\n\t\tdlm->purge_count--;\n\t}\n\n\tif (!__dlm_lockres_unused(res)) {\n\t\tmlog(ML_ERROR, \"%s: res %.*s in use after deref\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\t__dlm_print_one_lock_resource(res);\n\t\tBUG();\n\t}\n\n\t__dlm_unhash_lockres(dlm, res);\n\n\tspin_lock(&dlm->track_lock);\n\tif (!list_empty(&res->tracking))\n\t\tlist_del_init(&res->tracking);\n\telse {\n\t\tmlog(ML_ERROR, \"%s: Resource %.*s not on the Tracking list\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tspin_unlock(&dlm->track_lock);\n\n\t \n\tres->state &= ~DLM_LOCK_RES_DROPPING_REF;\n}\n\nstatic void dlm_purge_lockres(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tint master;\n\tint ret = 0;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tmaster = (res->owner == dlm->node_num);\n\n\tmlog(0, \"%s: Purging res %.*s, master %d\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, master);\n\n\tif (!master) {\n\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tmlog(ML_NOTICE, \"%s: res %.*s already in DLM_LOCK_RES_DROPPING_REF state\\n\",\n\t\t\t\tdlm->name, res->lockname.len, res->lockname.name);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\treturn;\n\t\t}\n\n\t\tres->state |= DLM_LOCK_RES_DROPPING_REF;\n\t\t \n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\n\t\tspin_lock(&res->spinlock);\n\t\t \n\t\t__dlm_wait_on_lockres_flags(res, DLM_LOCK_RES_SETREF_INPROG);\n\t\tspin_unlock(&res->spinlock);\n\n\t\t \n\t\tret = dlm_drop_lockres_ref(dlm, res);\n\t\tif (ret < 0) {\n\t\t\tif (!dlm_is_host_down(ret))\n\t\t\t\tBUG();\n\t\t}\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t}\n\n\tif (!list_empty(&res->purge)) {\n\t\tmlog(0, \"%s: Removing res %.*s from purgelist, master %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name, master);\n\t\tlist_del_init(&res->purge);\n\t\tdlm_lockres_put(res);\n\t\tdlm->purge_count--;\n\t}\n\n\tif (!master && ret == DLM_DEREF_RESPONSE_INPROG) {\n\t\tmlog(0, \"%s: deref %.*s in progress\\n\",\n\t\t\tdlm->name, res->lockname.len, res->lockname.name);\n\t\tspin_unlock(&res->spinlock);\n\t\treturn;\n\t}\n\n\tif (!__dlm_lockres_unused(res)) {\n\t\tmlog(ML_ERROR, \"%s: res %.*s in use after deref\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\t__dlm_print_one_lock_resource(res);\n\t\tBUG();\n\t}\n\n\t__dlm_unhash_lockres(dlm, res);\n\n\tspin_lock(&dlm->track_lock);\n\tif (!list_empty(&res->tracking))\n\t\tlist_del_init(&res->tracking);\n\telse {\n\t\tmlog(ML_ERROR, \"Resource %.*s not on the Tracking list\\n\",\n\t\t\t\tres->lockname.len, res->lockname.name);\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tspin_unlock(&dlm->track_lock);\n\n\t \n\tif (!master) {\n\t\tres->state &= ~DLM_LOCK_RES_DROPPING_REF;\n\t\tspin_unlock(&res->spinlock);\n\t\twake_up(&res->wq);\n\t} else\n\t\tspin_unlock(&res->spinlock);\n}\n\nstatic void dlm_run_purge_list(struct dlm_ctxt *dlm,\n\t\t\t       int purge_now)\n{\n\tunsigned int run_max, unused;\n\tunsigned long purge_jiffies;\n\tstruct dlm_lock_resource *lockres;\n\n\tspin_lock(&dlm->spinlock);\n\trun_max = dlm->purge_count;\n\n\twhile(run_max && !list_empty(&dlm->purge_list)) {\n\t\trun_max--;\n\n\t\tlockres = list_entry(dlm->purge_list.next,\n\t\t\t\t     struct dlm_lock_resource, purge);\n\n\t\tspin_lock(&lockres->spinlock);\n\n\t\tpurge_jiffies = lockres->last_used +\n\t\t\tmsecs_to_jiffies(DLM_PURGE_INTERVAL_MS);\n\n\t\t \n\t\tif (!purge_now && time_after(purge_jiffies, jiffies)) {\n\t\t\t \n\t\t\tspin_unlock(&lockres->spinlock);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tunused = __dlm_lockres_unused(lockres);\n\t\tif (!unused ||\n\t\t    (lockres->state & DLM_LOCK_RES_MIGRATING) ||\n\t\t    (lockres->inflight_assert_workers != 0)) {\n\t\t\tmlog(0, \"%s: res %.*s is in use or being remastered, \"\n\t\t\t     \"used %d, state %d, assert master workers %u\\n\",\n\t\t\t     dlm->name, lockres->lockname.len,\n\t\t\t     lockres->lockname.name,\n\t\t\t     !unused, lockres->state,\n\t\t\t     lockres->inflight_assert_workers);\n\t\t\tlist_move_tail(&lockres->purge, &dlm->purge_list);\n\t\t\tspin_unlock(&lockres->spinlock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdlm_lockres_get(lockres);\n\n\t\tdlm_purge_lockres(dlm, lockres);\n\n\t\tdlm_lockres_put(lockres);\n\n\t\t \n\t\tcond_resched_lock(&dlm->spinlock);\n\t}\n\n\tspin_unlock(&dlm->spinlock);\n}\n\nstatic void dlm_shuffle_lists(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock, *target;\n\tint can_grant = 1;\n\n\t \n\tassert_spin_locked(&dlm->ast_lock);\n\tassert_spin_locked(&res->spinlock);\n\tBUG_ON((res->state & (DLM_LOCK_RES_MIGRATING|\n\t\t\t      DLM_LOCK_RES_RECOVERING|\n\t\t\t      DLM_LOCK_RES_IN_PROGRESS)));\n\nconverting:\n\tif (list_empty(&res->converting))\n\t\tgoto blocked;\n\tmlog(0, \"%s: res %.*s has locks on the convert queue\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name);\n\n\ttarget = list_entry(res->converting.next, struct dlm_lock, list);\n\tif (target->ml.convert_type == LKM_IVMODE) {\n\t\tmlog(ML_ERROR, \"%s: res %.*s converting lock to invalid mode\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\tBUG();\n\t}\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type,\n\t\t\t\t\t target->ml.convert_type)) {\n\t\t\tcan_grant = 0;\n\t\t\t \n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\t \n\t\t\tif (lock->ml.highest_blocked < target->ml.convert_type)\n\t\t\t\tlock->ml.highest_blocked =\n\t\t\t\t\ttarget->ml.convert_type;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type,\n\t\t\t\t\t target->ml.convert_type)) {\n\t\t\tcan_grant = 0;\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\tif (lock->ml.highest_blocked < target->ml.convert_type)\n\t\t\t\tlock->ml.highest_blocked =\n\t\t\t\t\ttarget->ml.convert_type;\n\t\t}\n\t}\n\n\t \n\tif (can_grant) {\n\t\tspin_lock(&target->spinlock);\n\t\tBUG_ON(target->ml.highest_blocked != LKM_IVMODE);\n\n\t\tmlog(0, \"%s: res %.*s, AST for Converting lock %u:%llu, type \"\n\t\t     \"%d => %d, node %u\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(target->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(target->ml.cookie)),\n\t\t     target->ml.type,\n\t\t     target->ml.convert_type, target->ml.node);\n\n\t\ttarget->ml.type = target->ml.convert_type;\n\t\ttarget->ml.convert_type = LKM_IVMODE;\n\t\tlist_move_tail(&target->list, &res->granted);\n\n\t\tBUG_ON(!target->lksb);\n\t\ttarget->lksb->status = DLM_NORMAL;\n\n\t\tspin_unlock(&target->spinlock);\n\n\t\t__dlm_lockres_reserve_ast(res);\n\t\t__dlm_queue_ast(dlm, target);\n\t\t \n\t\tgoto converting;\n\t}\n\nblocked:\n\tif (list_empty(&res->blocked))\n\t\tgoto leave;\n\ttarget = list_entry(res->blocked.next, struct dlm_lock, list);\n\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type, target->ml.type)) {\n\t\t\tcan_grant = 0;\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\tif (lock->ml.highest_blocked < target->ml.type)\n\t\t\t\tlock->ml.highest_blocked = target->ml.type;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type, target->ml.type)) {\n\t\t\tcan_grant = 0;\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\tif (lock->ml.highest_blocked < target->ml.type)\n\t\t\t\tlock->ml.highest_blocked = target->ml.type;\n\t\t}\n\t}\n\n\t \n\tif (can_grant) {\n\t\tspin_lock(&target->spinlock);\n\t\tBUG_ON(target->ml.highest_blocked != LKM_IVMODE);\n\n\t\tmlog(0, \"%s: res %.*s, AST for Blocked lock %u:%llu, type %d, \"\n\t\t     \"node %u\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(target->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(target->ml.cookie)),\n\t\t     target->ml.type, target->ml.node);\n\n\t\t \n\t\tlist_move_tail(&target->list, &res->granted);\n\n\t\tBUG_ON(!target->lksb);\n\t\ttarget->lksb->status = DLM_NORMAL;\n\n\t\tspin_unlock(&target->spinlock);\n\n\t\t__dlm_lockres_reserve_ast(res);\n\t\t__dlm_queue_ast(dlm, target);\n\t\t \n\t\tgoto converting;\n\t}\n\nleave:\n\treturn;\n}\n\n \nvoid dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}\n\nvoid __dlm_dirty_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t \n\tif (res->owner == dlm->node_num) {\n\t\tif (res->state & (DLM_LOCK_RES_MIGRATING |\n\t\t\t\t  DLM_LOCK_RES_BLOCK_DIRTY))\n\t\t    return;\n\n\t\tif (list_empty(&res->dirty)) {\n\t\t\t \n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->dirty, &dlm->dirty_list);\n\t\t\tres->state |= DLM_LOCK_RES_DIRTY;\n\t\t}\n\t}\n\n\tmlog(0, \"%s: res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n}\n\n\n \nint dlm_launch_thread(struct dlm_ctxt *dlm)\n{\n\tmlog(0, \"Starting dlm_thread...\\n\");\n\n\tdlm->dlm_thread_task = kthread_run(dlm_thread, dlm, \"dlm-%s\",\n\t\t\tdlm->name);\n\tif (IS_ERR(dlm->dlm_thread_task)) {\n\t\tmlog_errno(PTR_ERR(dlm->dlm_thread_task));\n\t\tdlm->dlm_thread_task = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid dlm_complete_thread(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_thread_task) {\n\t\tmlog(ML_KTHREAD, \"Waiting for dlm thread to exit\\n\");\n\t\tkthread_stop(dlm->dlm_thread_task);\n\t\tdlm->dlm_thread_task = NULL;\n\t}\n}\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\tstruct dlm_lock *lock;\n\tstruct dlm_lock_resource *res;\n\tu8 hi;\n\n\tspin_lock(&dlm->ast_lock);\n\twhile (!list_empty(&dlm->pending_asts)) {\n\t\tlock = list_entry(dlm->pending_asts.next,\n\t\t\t\t  struct dlm_lock, ast_list);\n\t\t \n\t\tdlm_lock_get(lock);\n\t\tres = lock->lockres;\n\t\tmlog(0, \"%s: res %.*s, Flush AST for lock %u:%llu, type %d, \"\n\t\t     \"node %u\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     lock->ml.type, lock->ml.node);\n\n\t\tBUG_ON(!lock->ast_pending);\n\n\t\t \n\t\tlist_del_init(&lock->ast_list);\n\t\tdlm_lock_put(lock);\n\t\tspin_unlock(&dlm->ast_lock);\n\n\t\tif (lock->ml.node != dlm->node_num) {\n\t\t\tret = dlm_do_remote_ast(dlm, res, lock);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\t\t} else\n\t\t\tdlm_do_local_ast(dlm, res, lock);\n\n\t\tspin_lock(&dlm->ast_lock);\n\n\t\t \n\t\tif (!list_empty(&lock->ast_list)) {\n\t\t\tmlog(0, \"%s: res %.*s, AST queued while flushing last \"\n\t\t\t     \"one\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name);\n\t\t} else\n\t\t\tlock->ast_pending = 0;\n\n\t\t \n\t\tdlm_lock_put(lock);\n\t\tdlm_lockres_release_ast(dlm, res);\n\t}\n\n\twhile (!list_empty(&dlm->pending_basts)) {\n\t\tlock = list_entry(dlm->pending_basts.next,\n\t\t\t\t  struct dlm_lock, bast_list);\n\t\t \n\t\tdlm_lock_get(lock);\n\t\tres = lock->lockres;\n\n\t\tBUG_ON(!lock->bast_pending);\n\n\t\t \n\t\tspin_lock(&lock->spinlock);\n\t\tBUG_ON(lock->ml.highest_blocked <= LKM_IVMODE);\n\t\thi = lock->ml.highest_blocked;\n\t\tlock->ml.highest_blocked = LKM_IVMODE;\n\t\tspin_unlock(&lock->spinlock);\n\n\t\t \n\t\tlist_del_init(&lock->bast_list);\n\t\tdlm_lock_put(lock);\n\t\tspin_unlock(&dlm->ast_lock);\n\n\t\tmlog(0, \"%s: res %.*s, Flush BAST for lock %u:%llu, \"\n\t\t     \"blocked %d, node %u\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     hi, lock->ml.node);\n\n\t\tif (lock->ml.node != dlm->node_num) {\n\t\t\tret = dlm_send_proxy_bast(dlm, res, lock, hi);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\t\t} else\n\t\t\tdlm_do_local_bast(dlm, res, lock, hi);\n\n\t\tspin_lock(&dlm->ast_lock);\n\n\t\t \n\t\tif (!list_empty(&lock->bast_list)) {\n\t\t\tmlog(0, \"%s: res %.*s, BAST queued while flushing last \"\n\t\t\t     \"one\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name);\n\t\t} else\n\t\t\tlock->bast_pending = 0;\n\n\t\t \n\t\tdlm_lock_put(lock);\n\t\tdlm_lockres_release_ast(dlm, res);\n\t}\n\twake_up(&dlm->ast_wq);\n\tspin_unlock(&dlm->ast_lock);\n}\n\n\n#define DLM_THREAD_TIMEOUT_MS (4 * 1000)\n#define DLM_THREAD_MAX_DIRTY  100\n\nstatic int dlm_thread(void *data)\n{\n\tstruct dlm_lock_resource *res;\n\tstruct dlm_ctxt *dlm = data;\n\tunsigned long timeout = msecs_to_jiffies(DLM_THREAD_TIMEOUT_MS);\n\n\tmlog(0, \"dlm thread running for %s...\\n\", dlm->name);\n\n\twhile (!kthread_should_stop()) {\n\t\tint n = DLM_THREAD_MAX_DIRTY;\n\n\t\t \n\t\tdlm_run_purge_list(dlm, dlm_shutting_down(dlm));\n\n\t\t \n\t\tspin_lock(&dlm->spinlock);\n\t\twhile (!list_empty(&dlm->dirty_list)) {\n\t\t\tint delay = 0;\n\t\t\tres = list_entry(dlm->dirty_list.next,\n\t\t\t\t\t struct dlm_lock_resource, dirty);\n\n\t\t\t \n\t\t\tBUG_ON(!res);\n\t\t\tdlm_lockres_get(res);\n\n\t\t\tspin_lock(&res->spinlock);\n\t\t\t \n\t\t\tlist_del_init(&res->dirty);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\t \n\t\t\tdlm_lockres_put(res);\n\n\t\t \t \n\n\t\t\tspin_lock(&dlm->ast_lock);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tif (res->owner != dlm->node_num) {\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tmlog(ML_ERROR, \"%s: inprog %d, mig %d, reco %d,\"\n\t\t\t\t     \" dirty %d\\n\", dlm->name,\n\t\t\t\t     !!(res->state & DLM_LOCK_RES_IN_PROGRESS),\n\t\t\t\t     !!(res->state & DLM_LOCK_RES_MIGRATING),\n\t\t\t\t     !!(res->state & DLM_LOCK_RES_RECOVERING),\n\t\t\t\t     !!(res->state & DLM_LOCK_RES_DIRTY));\n\t\t\t}\n\t\t\tBUG_ON(res->owner != dlm->node_num);\n\n\t\t\t \n\t\t\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\t\t\tif (res->state & (DLM_LOCK_RES_IN_PROGRESS |\n\t\t\t\t\t  DLM_LOCK_RES_RECOVERING |\n\t\t\t\t\t  DLM_LOCK_RES_RECOVERY_WAITING)) {\n\t\t\t\t \n\t\t\t\tres->state &= ~DLM_LOCK_RES_DIRTY;\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tspin_unlock(&dlm->ast_lock);\n\t\t\t\tmlog(0, \"%s: res %.*s, inprogress, delay list \"\n\t\t\t\t     \"shuffle, state %d\\n\", dlm->name,\n\t\t\t\t     res->lockname.len, res->lockname.name,\n\t\t\t\t     res->state);\n\t\t\t\tdelay = 1;\n\t\t\t\tgoto in_progress;\n\t\t\t}\n\n\t\t\t \n\n\t\t\t \n\t\t\tdlm_shuffle_lists(dlm, res);\n\t\t\tres->state &= ~DLM_LOCK_RES_DIRTY;\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tspin_unlock(&dlm->ast_lock);\n\n\t\t\tdlm_lockres_calc_usage(dlm, res);\n\nin_progress:\n\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\t \n\t\t\tif (delay) {\n\t\t\t\tspin_lock(&res->spinlock);\n\t\t\t\t__dlm_dirty_lockres(dlm, res);\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t}\n\t\t\tdlm_lockres_put(res);\n\n\t\t\t \n\t\t\tif (!--n) {\n\t\t\t\tmlog(0, \"%s: Throttling dlm thread\\n\",\n\t\t\t\t     dlm->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock(&dlm->spinlock);\n\t\tdlm_flush_asts(dlm);\n\n\t\t \n\t\tif (!n) {\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\n\t\twait_event_interruptible_timeout(dlm->dlm_thread_wq,\n\t\t\t\t\t\t !dlm_dirty_list_empty(dlm) ||\n\t\t\t\t\t\t kthread_should_stop(),\n\t\t\t\t\t\t timeout);\n\t}\n\n\tmlog(0, \"quitting DLM thread\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}