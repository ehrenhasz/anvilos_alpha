{
  "module_name": "dlmdomain.c",
  "hash_id": "13bf4a99daee3db60b79f868924443c8ac09c0b51c32cc498379fb3c97fd9ccd",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/dlm/dlmdomain.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/debugfs.h>\n#include <linux/sched/signal.h>\n\n#include \"../cluster/heartbeat.h\"\n#include \"../cluster/nodemanager.h\"\n#include \"../cluster/tcp.h\"\n\n#include \"dlmapi.h\"\n#include \"dlmcommon.h\"\n#include \"dlmdomain.h\"\n#include \"dlmdebug.h\"\n\n#define MLOG_MASK_PREFIX (ML_DLM|ML_DLM_DOMAIN)\n#include \"../cluster/masklog.h\"\n\n \nstatic inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}\n\nstatic inline void byte_copymap(u8 dmap[], unsigned long smap[],\n\t\t\tunsigned int sz)\n{\n\tunsigned int nn;\n\n\tif (!sz)\n\t\treturn;\n\n\tmemset(dmap, 0, ((sz + 7) >> 3));\n\tfor (nn = 0 ; nn < sz; nn++)\n\t\tif (test_bit(nn, smap))\n\t\t\tbyte_set_bit(nn, dmap);\n}\n\nstatic void dlm_free_pagevec(void **vec, int pages)\n{\n\twhile (pages--)\n\t\tfree_page((unsigned long)vec[pages]);\n\tkfree(vec);\n}\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc_array(pages, sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}\n\n \n\nDEFINE_SPINLOCK(dlm_domain_lock);\nLIST_HEAD(dlm_domains);\nstatic DECLARE_WAIT_QUEUE_HEAD(dlm_domain_events);\n\n \nstatic const struct dlm_protocol_version dlm_protocol = {\n\t.pv_major = 1,\n\t.pv_minor = 3,\n};\n\n#define DLM_DOMAIN_BACKOFF_MS 200\n\nstatic int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data);\nstatic int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t     void **ret_data);\nstatic int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);\nstatic int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t    void *data, void **ret_data);\nstatic int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);\nstatic int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request);\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nvoid __dlm_unhash_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (hlist_unhashed(&res->hash_node))\n\t\treturn;\n\n\tmlog(0, \"%s: Unhash res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n\thlist_del_init(&res->hash_node);\n\tdlm_lockres_put(res);\n}\n\nvoid __dlm_insert_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tstruct hlist_head *bucket;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tbucket = dlm_lockres_hash(dlm, res->lockname.hash);\n\n\t \n\tdlm_lockres_get(res);\n\n\thlist_add_head(&res->hash_node, bucket);\n\n\tmlog(0, \"%s: Hash res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n}\n\nstruct dlm_lock_resource * __dlm_lookup_lockres_full(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t     const char *name,\n\t\t\t\t\t\t     unsigned int len,\n\t\t\t\t\t\t     unsigned int hash)\n{\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock_resource *res;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tbucket = dlm_lockres_hash(dlm, hash);\n\n\thlist_for_each_entry(res, bucket, hash_node) {\n\t\tif (res->lockname.name[0] != name[0])\n\t\t\tcontinue;\n\t\tif (unlikely(res->lockname.len != len))\n\t\t\tcontinue;\n\t\tif (memcmp(res->lockname.name + 1, name + 1, len - 1))\n\t\t\tcontinue;\n\t\tdlm_lockres_get(res);\n\t\treturn res;\n\t}\n\treturn NULL;\n}\n\n \nstruct dlm_lock_resource * __dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tunsigned int hash)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tres = __dlm_lookup_lockres_full(dlm, name, len, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\treturn res;\n}\n\nstruct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t    const char *name,\n\t\t\t\t    unsigned int len)\n{\n\tstruct dlm_lock_resource *res;\n\tunsigned int hash = dlm_lockid_hash(name, len);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, len, hash);\n\tspin_unlock(&dlm->spinlock);\n\treturn res;\n}\n\nstatic struct dlm_ctxt * __dlm_lookup_domain_full(const char *domain, int len)\n{\n\tstruct dlm_ctxt *tmp;\n\n\tassert_spin_locked(&dlm_domain_lock);\n\n\t \n\tlist_for_each_entry(tmp, &dlm_domains, list) {\n\t\tif (strlen(tmp->name) == len &&\n\t\t    memcmp(tmp->name, domain, len)==0)\n\t\t\treturn tmp;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct dlm_ctxt * __dlm_lookup_domain(const char *domain)\n{\n\tassert_spin_locked(&dlm_domain_lock);\n\n\treturn __dlm_lookup_domain_full(domain, strlen(domain));\n}\n\n\n \nstatic int dlm_wait_on_domain_helper(const char *domain)\n{\n\tint ret = 0;\n\tstruct dlm_ctxt *tmp = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\ttmp = __dlm_lookup_domain(domain);\n\tif (!tmp)\n\t\tret = 1;\n\telse if (tmp->dlm_state == DLM_CTXT_JOINED)\n\t\tret = 1;\n\n\tspin_unlock(&dlm_domain_lock);\n\treturn ret;\n}\n\nstatic void dlm_free_ctxt_mem(struct dlm_ctxt *dlm)\n{\n\tdlm_destroy_debugfs_subroot(dlm);\n\n\tif (dlm->lockres_hash)\n\t\tdlm_free_pagevec((void **)dlm->lockres_hash, DLM_HASH_PAGES);\n\n\tif (dlm->master_hash)\n\t\tdlm_free_pagevec((void **)dlm->master_hash, DLM_HASH_PAGES);\n\n\tkfree(dlm->name);\n\tkfree(dlm);\n}\n\n \nstatic void dlm_ctxt_release(struct kref *kref)\n{\n\tstruct dlm_ctxt *dlm;\n\n\tdlm = container_of(kref, struct dlm_ctxt, dlm_refs);\n\n\tBUG_ON(dlm->num_joins);\n\tBUG_ON(dlm->dlm_state == DLM_CTXT_JOINED);\n\n\t \n\tlist_del_init(&dlm->list);\n\n\tspin_unlock(&dlm_domain_lock);\n\n\tmlog(0, \"freeing memory from domain %s\\n\", dlm->name);\n\n\twake_up(&dlm_domain_events);\n\n\tdlm_free_ctxt_mem(dlm);\n\n\tspin_lock(&dlm_domain_lock);\n}\n\nvoid dlm_put(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm_domain_lock);\n\tkref_put(&dlm->dlm_refs, dlm_ctxt_release);\n\tspin_unlock(&dlm_domain_lock);\n}\n\nstatic void __dlm_get(struct dlm_ctxt *dlm)\n{\n\tkref_get(&dlm->dlm_refs);\n}\n\n \nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}\n\nint dlm_domain_fully_joined(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm_domain_lock);\n\tret = (dlm->dlm_state == DLM_CTXT_JOINED) ||\n\t\t(dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN);\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}\n\nstatic void dlm_destroy_dlm_worker(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_worker) {\n\t\tdestroy_workqueue(dlm->dlm_worker);\n\t\tdlm->dlm_worker = NULL;\n\t}\n}\n\nstatic void dlm_complete_dlm_shutdown(struct dlm_ctxt *dlm)\n{\n\tdlm_unregister_domain_handlers(dlm);\n\tdlm_complete_thread(dlm);\n\tdlm_complete_recovery_thread(dlm);\n\tdlm_destroy_dlm_worker(dlm);\n\n\t \n\tspin_lock(&dlm_domain_lock);\n\tlist_del_init(&dlm->list);\n\tspin_unlock(&dlm_domain_lock);\n\n\t \n\twake_up(&dlm_domain_events);\n}\n\nstatic int dlm_migrate_all_locks(struct dlm_ctxt *dlm)\n{\n\tint i, num, n, ret = 0;\n\tstruct dlm_lock_resource *res;\n\tstruct hlist_node *iter;\n\tstruct hlist_head *bucket;\n\tint dropped;\n\n\tmlog(0, \"Migrating locks from domain %s\\n\", dlm->name);\n\n\tnum = 0;\n\tspin_lock(&dlm->spinlock);\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\nredo_bucket:\n\t\tn = 0;\n\t\tbucket = dlm_lockres_hash(dlm, i);\n\t\titer = bucket->first;\n\t\twhile (iter) {\n\t\t\tn++;\n\t\t\tres = hlist_entry(iter, struct dlm_lock_resource,\n\t\t\t\t\t  hash_node);\n\t\t\tdlm_lockres_get(res);\n\t\t\t \n\t\t\tdropped = dlm_empty_lockres(dlm, res);\n\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tif (dropped)\n\t\t\t\t__dlm_lockres_calc_usage(dlm, res);\n\t\t\telse\n\t\t\t\titer = res->hash_node.next;\n\t\t\tspin_unlock(&res->spinlock);\n\n\t\t\tdlm_lockres_put(res);\n\n\t\t\tif (dropped) {\n\t\t\t\tcond_resched_lock(&dlm->spinlock);\n\t\t\t\tgoto redo_bucket;\n\t\t\t}\n\t\t}\n\t\tcond_resched_lock(&dlm->spinlock);\n\t\tnum += n;\n\t}\n\n\tif (!num) {\n\t\tif (dlm->reco.state & DLM_RECO_STATE_ACTIVE) {\n\t\t\tmlog(0, \"%s: perhaps there are more lock resources \"\n\t\t\t     \"need to be migrated after dlm recovery\\n\", dlm->name);\n\t\t\tret = -EAGAIN;\n\t\t} else {\n\t\t\tmlog(0, \"%s: we won't do dlm recovery after migrating \"\n\t\t\t     \"all lock resources\\n\", dlm->name);\n\t\t\tdlm->migrate_done = 1;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm->spinlock);\n\twake_up(&dlm->dlm_thread_wq);\n\n\t \n\tif (num) {\n\t\tmlog(0, \"%s: %d lock resources in hash last pass\\n\",\n\t\t     dlm->name, num);\n\t\tret = -EAGAIN;\n\t}\n\tmlog(0, \"DONE Migrating locks from domain %s\\n\", dlm->name);\n\treturn ret;\n}\n\nstatic int dlm_no_joining_node(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm->spinlock);\n\tret = dlm->joining_node == DLM_LOCK_RES_OWNER_UNKNOWN;\n\tspin_unlock(&dlm->spinlock);\n\n\treturn ret;\n}\n\nstatic int dlm_begin_exit_domain_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t\t void *data, void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tunsigned int node;\n\tstruct dlm_exit_domain *exit_msg = (struct dlm_exit_domain *) msg->buf;\n\n\tif (!dlm_grab(dlm))\n\t\treturn 0;\n\n\tnode = exit_msg->node_idx;\n\tmlog(0, \"%s: Node %u sent a begin exit domain message\\n\", dlm->name, node);\n\n\tspin_lock(&dlm->spinlock);\n\tset_bit(node, dlm->exit_domain_map);\n\tspin_unlock(&dlm->spinlock);\n\n\tdlm_put(dlm);\n\n\treturn 0;\n}\n\nstatic void dlm_mark_domain_leaving(struct dlm_ctxt *dlm)\n{\n\t \nagain:\n\tspin_lock(&dlm_domain_lock);\n\tspin_lock(&dlm->spinlock);\n\n\tif (dlm->joining_node != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\tmlog(0, \"Node %d is joining, we wait on it.\\n\",\n\t\t\t  dlm->joining_node);\n\t\tspin_unlock(&dlm->spinlock);\n\t\tspin_unlock(&dlm_domain_lock);\n\n\t\twait_event(dlm->dlm_join_events, dlm_no_joining_node(dlm));\n\t\tgoto again;\n\t}\n\n\tdlm->dlm_state = DLM_CTXT_LEAVING;\n\tspin_unlock(&dlm->spinlock);\n\tspin_unlock(&dlm_domain_lock);\n}\n\nstatic void __dlm_print_nodes(struct dlm_ctxt *dlm)\n{\n\tint node = -1, num = 0;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tprintk(\"( \");\n\twhile ((node = find_next_bit(dlm->domain_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tprintk(\"%d \", node);\n\t\t++num;\n\t}\n\tprintk(\") %u nodes\\n\", num);\n}\n\nstatic int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tunsigned int node;\n\tstruct dlm_exit_domain *exit_msg = (struct dlm_exit_domain *) msg->buf;\n\n\tmlog(0, \"%p %u %p\", msg, len, data);\n\n\tif (!dlm_grab(dlm))\n\t\treturn 0;\n\n\tnode = exit_msg->node_idx;\n\n\tspin_lock(&dlm->spinlock);\n\tclear_bit(node, dlm->domain_map);\n\tclear_bit(node, dlm->exit_domain_map);\n\tprintk(KERN_NOTICE \"o2dlm: Node %u leaves domain %s \", node, dlm->name);\n\t__dlm_print_nodes(dlm);\n\n\t \n\tdlm_hb_event_notify_attached(dlm, node, 0);\n\n\tspin_unlock(&dlm->spinlock);\n\n\tdlm_put(dlm);\n\n\treturn 0;\n}\n\nstatic int dlm_send_one_domain_exit(struct dlm_ctxt *dlm, u32 msg_type,\n\t\t\t\t    unsigned int node)\n{\n\tint status;\n\tstruct dlm_exit_domain leave_msg;\n\n\tmlog(0, \"%s: Sending domain exit message %u to node %u\\n\", dlm->name,\n\t     msg_type, node);\n\n\tmemset(&leave_msg, 0, sizeof(leave_msg));\n\tleave_msg.node_idx = dlm->node_num;\n\n\tstatus = o2net_send_message(msg_type, dlm->key, &leave_msg,\n\t\t\t\t    sizeof(leave_msg), node, NULL);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d sending domain exit message %u \"\n\t\t     \"to node %u on domain %s\\n\", status, msg_type, node,\n\t\t     dlm->name);\n\n\treturn status;\n}\n\nstatic void dlm_begin_exit_domain(struct dlm_ctxt *dlm)\n{\n\tint node = -1;\n\n\t \n\tif (dlm->dlm_locking_proto.pv_major == 1 &&\n\t    dlm->dlm_locking_proto.pv_minor < 2)\n\t\treturn;\n\n\t \n\tspin_lock(&dlm->spinlock);\n\twhile (1) {\n\t\tnode = find_next_bit(dlm->domain_map, O2NM_MAX_NODES, node + 1);\n\t\tif (node >= O2NM_MAX_NODES)\n\t\t\tbreak;\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tspin_unlock(&dlm->spinlock);\n\t\tdlm_send_one_domain_exit(dlm, DLM_BEGIN_EXIT_DOMAIN_MSG, node);\n\t\tspin_lock(&dlm->spinlock);\n\t}\n\tspin_unlock(&dlm->spinlock);\n}\n\nstatic void dlm_leave_domain(struct dlm_ctxt *dlm)\n{\n\tint node, clear_node, status;\n\n\t \n\n\tspin_lock(&dlm->spinlock);\n\t \n\tclear_bit(dlm->node_num, dlm->domain_map);\n\twhile ((node = find_next_bit(dlm->domain_map, O2NM_MAX_NODES,\n\t\t\t\t     0)) < O2NM_MAX_NODES) {\n\t\t \n\t\tspin_unlock(&dlm->spinlock);\n\n\t\tclear_node = 1;\n\n\t\tstatus = dlm_send_one_domain_exit(dlm, DLM_EXIT_DOMAIN_MSG,\n\t\t\t\t\t\t  node);\n\t\tif (status < 0 &&\n\t\t    status != -ENOPROTOOPT &&\n\t\t    status != -ENOTCONN) {\n\t\t\tmlog(ML_NOTICE, \"Error %d sending domain exit message \"\n\t\t\t     \"to node %d\\n\", status, node);\n\n\t\t\t \n\t\t\tmsleep(DLM_DOMAIN_BACKOFF_MS);\n\t\t\tclear_node = 0;\n\t\t}\n\n\t\tspin_lock(&dlm->spinlock);\n\t\t \n\t\tif (clear_node)\n\t\t\tclear_bit(node, dlm->domain_map);\n\t}\n\tspin_unlock(&dlm->spinlock);\n}\n\nvoid dlm_unregister_domain(struct dlm_ctxt *dlm)\n{\n\tint leave = 0;\n\tstruct dlm_lock_resource *res;\n\n\tspin_lock(&dlm_domain_lock);\n\tBUG_ON(dlm->dlm_state != DLM_CTXT_JOINED);\n\tBUG_ON(!dlm->num_joins);\n\n\tdlm->num_joins--;\n\tif (!dlm->num_joins) {\n\t\t \n\t\tdlm->dlm_state = DLM_CTXT_IN_SHUTDOWN;\n\t\tleave = 1;\n\t}\n\tspin_unlock(&dlm_domain_lock);\n\n\tif (leave) {\n\t\tmlog(0, \"shutting down domain %s\\n\", dlm->name);\n\t\tdlm_begin_exit_domain(dlm);\n\n\t\t \n\t\tdlm_kick_thread(dlm, NULL);\n\n\t\twhile (dlm_migrate_all_locks(dlm)) {\n\t\t\t \n\t\t\tmsleep(500);\n\t\t\tmlog(0, \"%s: more migration to do\\n\", dlm->name);\n\t\t}\n\n\t\t \n\t\tif (!list_empty(&dlm->tracking_list)) {\n\t\t\tmlog(ML_ERROR, \"Following lockres' are still on the \"\n\t\t\t     \"tracking list:\\n\");\n\t\t\tlist_for_each_entry(res, &dlm->tracking_list, tracking)\n\t\t\t\tdlm_print_one_lock_resource(res);\n\t\t}\n\n\t\tdlm_mark_domain_leaving(dlm);\n\t\tdlm_leave_domain(dlm);\n\t\tprintk(KERN_NOTICE \"o2dlm: Leaving domain %s\\n\", dlm->name);\n\t\tdlm_force_free_mles(dlm);\n\t\tdlm_complete_dlm_shutdown(dlm);\n\t}\n\tdlm_put(dlm);\n}\nEXPORT_SYMBOL_GPL(dlm_unregister_domain);\n\nstatic int dlm_query_join_proto_check(char *proto_type, int node,\n\t\t\t\t      struct dlm_protocol_version *ours,\n\t\t\t\t      struct dlm_protocol_version *request)\n{\n\tint rc;\n\tstruct dlm_protocol_version proto = *request;\n\n\tif (!dlm_protocol_compare(ours, &proto)) {\n\t\tmlog(0,\n\t\t     \"node %u wanted to join with %s locking protocol \"\n\t\t     \"%u.%u, we respond with %u.%u\\n\",\n\t\t     node, proto_type,\n\t\t     request->pv_major,\n\t\t     request->pv_minor,\n\t\t     proto.pv_major, proto.pv_minor);\n\t\trequest->pv_minor = proto.pv_minor;\n\t\trc = 0;\n\t} else {\n\t\tmlog(ML_NOTICE,\n\t\t     \"Node %u wanted to join with %s locking \"\n\t\t     \"protocol %u.%u, but we have %u.%u, disallowing\\n\",\n\t\t     node, proto_type,\n\t\t     request->pv_major,\n\t\t     request->pv_minor,\n\t\t     ours->pv_major,\n\t\t     ours->pv_minor);\n\t\trc = 1;\n\t}\n\n\treturn rc;\n}\n\n \nstatic void dlm_query_join_packet_to_wire(struct dlm_query_join_packet *packet,\n\t\t\t\t\t  u32 *wire)\n{\n\tunion dlm_query_join_response response;\n\n\tresponse.packet = *packet;\n\t*wire = be32_to_cpu(response.intval);\n}\n\nstatic void dlm_query_join_wire_to_packet(u32 wire,\n\t\t\t\t\t  struct dlm_query_join_packet *packet)\n{\n\tunion dlm_query_join_response response;\n\n\tresponse.intval = cpu_to_be32(wire);\n\t*packet = response.packet;\n}\n\nstatic int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data)\n{\n\tstruct dlm_query_join_request *query;\n\tstruct dlm_query_join_packet packet = {\n\t\t.code = JOIN_DISALLOW,\n\t};\n\tstruct dlm_ctxt *dlm = NULL;\n\tu32 response;\n\tu8 nodenum;\n\n\tquery = (struct dlm_query_join_request *) msg->buf;\n\n\tmlog(0, \"node %u wants to join domain %s\\n\", query->node_idx,\n\t\t  query->domain);\n\n\t \n\tif (!o2hb_check_node_heartbeating_no_sem(query->node_idx)) {\n\t\tmlog(0, \"node %u is not in our live map yet\\n\",\n\t\t     query->node_idx);\n\n\t\tpacket.code = JOIN_DISALLOW;\n\t\tgoto respond;\n\t}\n\n\tpacket.code = JOIN_OK_NO_MAP;\n\n\tspin_lock(&dlm_domain_lock);\n\tdlm = __dlm_lookup_domain_full(query->domain, query->name_len);\n\tif (!dlm)\n\t\tgoto unlock_respond;\n\n\t \n\tnodenum=0;\n\twhile (nodenum < O2NM_MAX_NODES) {\n\t\tif (test_bit(nodenum, dlm->domain_map)) {\n\t\t\tif (!byte_test_bit(nodenum, query->node_map)) {\n\t\t\t\tmlog(0, \"disallow join as node %u does not \"\n\t\t\t\t     \"have node %u in its nodemap\\n\",\n\t\t\t\t     query->node_idx, nodenum);\n\t\t\t\tpacket.code = JOIN_DISALLOW;\n\t\t\t\tgoto unlock_respond;\n\t\t\t}\n\t\t}\n\t\tnodenum++;\n\t}\n\n\t \n\tif (dlm->dlm_state != DLM_CTXT_LEAVING) {\n\t\tint bit = query->node_idx;\n\t\tspin_lock(&dlm->spinlock);\n\n\t\tif (dlm->dlm_state == DLM_CTXT_NEW &&\n\t\t    dlm->joining_node == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t \n\t\t\tpacket.code = JOIN_OK_NO_MAP;\n\t\t} else if (dlm->joining_node != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t \n\t\t\tpacket.code = JOIN_DISALLOW;\n\t\t} else if (dlm->reco.state & DLM_RECO_STATE_ACTIVE) {\n\t\t\tmlog(0, \"node %u trying to join, but recovery \"\n\t\t\t     \"is ongoing.\\n\", bit);\n\t\t\tpacket.code = JOIN_DISALLOW;\n\t\t} else if (test_bit(bit, dlm->recovery_map)) {\n\t\t\tmlog(0, \"node %u trying to join, but it \"\n\t\t\t     \"still needs recovery.\\n\", bit);\n\t\t\tpacket.code = JOIN_DISALLOW;\n\t\t} else if (test_bit(bit, dlm->domain_map)) {\n\t\t\tmlog(0, \"node %u trying to join, but it \"\n\t\t\t     \"is still in the domain! needs recovery?\\n\",\n\t\t\t     bit);\n\t\t\tpacket.code = JOIN_DISALLOW;\n\t\t} else {\n\t\t\t \n\n\t\t\t \n\t\t\tif (dlm_query_join_proto_check(\"DLM\", bit,\n\t\t\t\t\t\t       &dlm->dlm_locking_proto,\n\t\t\t\t\t\t       &query->dlm_proto)) {\n\t\t\t\tpacket.code = JOIN_PROTOCOL_MISMATCH;\n\t\t\t} else if (dlm_query_join_proto_check(\"fs\", bit,\n\t\t\t\t\t\t\t      &dlm->fs_locking_proto,\n\t\t\t\t\t\t\t      &query->fs_proto)) {\n\t\t\t\tpacket.code = JOIN_PROTOCOL_MISMATCH;\n\t\t\t} else {\n\t\t\t\tpacket.dlm_minor = query->dlm_proto.pv_minor;\n\t\t\t\tpacket.fs_minor = query->fs_proto.pv_minor;\n\t\t\t\tpacket.code = JOIN_OK;\n\t\t\t\t__dlm_set_joining_node(dlm, query->node_idx);\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock(&dlm->spinlock);\n\t}\nunlock_respond:\n\tspin_unlock(&dlm_domain_lock);\n\nrespond:\n\tmlog(0, \"We respond with %u\\n\", packet.code);\n\n\tdlm_query_join_packet_to_wire(&packet, &response);\n\treturn response;\n}\n\nstatic int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t     void **ret_data)\n{\n\tstruct dlm_assert_joined *assert;\n\tstruct dlm_ctxt *dlm = NULL;\n\n\tassert = (struct dlm_assert_joined *) msg->buf;\n\n\tmlog(0, \"node %u asserts join on domain %s\\n\", assert->node_idx,\n\t\t  assert->domain);\n\n\tspin_lock(&dlm_domain_lock);\n\tdlm = __dlm_lookup_domain_full(assert->domain, assert->name_len);\n\t \n\tif (dlm) {\n\t\tspin_lock(&dlm->spinlock);\n\n\t\t \n\t\tBUG_ON(dlm->joining_node != assert->node_idx);\n\n\t\tif (dlm->reco.state & DLM_RECO_STATE_ACTIVE) {\n\t\t\tmlog(0, \"dlm recovery is ongoing, disallow join\\n\");\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tspin_unlock(&dlm_domain_lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tset_bit(assert->node_idx, dlm->domain_map);\n\t\tclear_bit(assert->node_idx, dlm->exit_domain_map);\n\t\t__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\n\n\t\tprintk(KERN_NOTICE \"o2dlm: Node %u joins domain %s \",\n\t\t       assert->node_idx, dlm->name);\n\t\t__dlm_print_nodes(dlm);\n\n\t\t \n\t\tdlm_hb_event_notify_attached(dlm, assert->node_idx, 1);\n\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn 0;\n}\n\nstatic int dlm_match_regions(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_query_region *qr,\n\t\t\t     char *local, int locallen)\n{\n\tchar *remote = qr->qr_regions;\n\tchar *l, *r;\n\tint localnr, i, j, foundit;\n\tint status = 0;\n\n\tif (!o2hb_global_heartbeat_active()) {\n\t\tif (qr->qr_numregions) {\n\t\t\tmlog(ML_ERROR, \"Domain %s: Joining node %d has global \"\n\t\t\t     \"heartbeat enabled but local node %d does not\\n\",\n\t\t\t     qr->qr_domain, qr->qr_node, dlm->node_num);\n\t\t\tstatus = -EINVAL;\n\t\t}\n\t\tgoto bail;\n\t}\n\n\tif (o2hb_global_heartbeat_active() && !qr->qr_numregions) {\n\t\tmlog(ML_ERROR, \"Domain %s: Local node %d has global \"\n\t\t     \"heartbeat enabled but joining node %d does not\\n\",\n\t\t     qr->qr_domain, dlm->node_num, qr->qr_node);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tr = remote;\n\tfor (i = 0; i < qr->qr_numregions; ++i) {\n\t\tmlog(0, \"Region %.*s\\n\", O2HB_MAX_REGION_NAME_LEN, r);\n\t\tr += O2HB_MAX_REGION_NAME_LEN;\n\t}\n\n\tlocalnr = min(O2NM_MAX_REGIONS, locallen/O2HB_MAX_REGION_NAME_LEN);\n\tlocalnr = o2hb_get_all_regions(local, (u8)localnr);\n\n\t \n\tl = local;\n\tfor (i = 0; i < localnr; ++i) {\n\t\tfoundit = 0;\n\t\tr = remote;\n\t\tfor (j = 0; j <= qr->qr_numregions; ++j) {\n\t\t\tif (!memcmp(l, r, O2HB_MAX_REGION_NAME_LEN)) {\n\t\t\t\tfoundit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr += O2HB_MAX_REGION_NAME_LEN;\n\t\t}\n\t\tif (!foundit) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog(ML_ERROR, \"Domain %s: Region '%.*s' registered \"\n\t\t\t     \"in local node %d but not in joining node %d\\n\",\n\t\t\t     qr->qr_domain, O2HB_MAX_REGION_NAME_LEN, l,\n\t\t\t     dlm->node_num, qr->qr_node);\n\t\t\tgoto bail;\n\t\t}\n\t\tl += O2HB_MAX_REGION_NAME_LEN;\n\t}\n\n\t \n\tr = remote;\n\tfor (i = 0; i < qr->qr_numregions; ++i) {\n\t\tfoundit = 0;\n\t\tl = local;\n\t\tfor (j = 0; j < localnr; ++j) {\n\t\t\tif (!memcmp(r, l, O2HB_MAX_REGION_NAME_LEN)) {\n\t\t\t\tfoundit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl += O2HB_MAX_REGION_NAME_LEN;\n\t\t}\n\t\tif (!foundit) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog(ML_ERROR, \"Domain %s: Region '%.*s' registered \"\n\t\t\t     \"in joining node %d but not in local node %d\\n\",\n\t\t\t     qr->qr_domain, O2HB_MAX_REGION_NAME_LEN, r,\n\t\t\t     qr->qr_node, dlm->node_num);\n\t\t\tgoto bail;\n\t\t}\n\t\tr += O2HB_MAX_REGION_NAME_LEN;\n\t}\n\nbail:\n\treturn status;\n}\n\nstatic int dlm_send_regions(struct dlm_ctxt *dlm, unsigned long *node_map)\n{\n\tstruct dlm_query_region *qr = NULL;\n\tint status, ret = 0, i;\n\tchar *p;\n\n\tif (find_first_bit(node_map, O2NM_MAX_NODES) >= O2NM_MAX_NODES)\n\t\tgoto bail;\n\n\tqr = kzalloc(sizeof(struct dlm_query_region), GFP_KERNEL);\n\tif (!qr) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tqr->qr_node = dlm->node_num;\n\tqr->qr_namelen = strlen(dlm->name);\n\tmemcpy(qr->qr_domain, dlm->name, qr->qr_namelen);\n\t \n\tif (o2hb_global_heartbeat_active())\n\t\tqr->qr_numregions = o2hb_get_all_regions(qr->qr_regions,\n\t\t\t\t\t\t\t O2NM_MAX_REGIONS);\n\n\tp = qr->qr_regions;\n\tfor (i = 0; i < qr->qr_numregions; ++i, p += O2HB_MAX_REGION_NAME_LEN)\n\t\tmlog(0, \"Region %.*s\\n\", O2HB_MAX_REGION_NAME_LEN, p);\n\n\ti = -1;\n\twhile ((i = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t  i + 1)) < O2NM_MAX_NODES) {\n\t\tif (i == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tmlog(0, \"Sending regions to node %d\\n\", i);\n\n\t\tret = o2net_send_message(DLM_QUERY_REGION, DLM_MOD_KEY, qr,\n\t\t\t\t\t sizeof(struct dlm_query_region),\n\t\t\t\t\t i, &status);\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (ret) {\n\t\t\tmlog(ML_ERROR, \"Region mismatch %d, node %d\\n\",\n\t\t\t     ret, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\nbail:\n\tkfree(qr);\n\treturn ret;\n}\n\nstatic int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t    void *data, void **ret_data)\n{\n\tstruct dlm_query_region *qr;\n\tstruct dlm_ctxt *dlm = NULL;\n\tchar *local = NULL;\n\tint status = 0;\n\n\tqr = (struct dlm_query_region *) msg->buf;\n\n\tmlog(0, \"Node %u queries hb regions on domain %s\\n\", qr->qr_node,\n\t     qr->qr_domain);\n\n\t \n\tlocal = kmalloc(sizeof(qr->qr_regions), GFP_KERNEL);\n\tif (!local)\n\t\treturn -ENOMEM;\n\n\tstatus = -EINVAL;\n\n\tspin_lock(&dlm_domain_lock);\n\tdlm = __dlm_lookup_domain_full(qr->qr_domain, qr->qr_namelen);\n\tif (!dlm) {\n\t\tmlog(ML_ERROR, \"Node %d queried hb regions on domain %s \"\n\t\t     \"before join domain\\n\", qr->qr_node, qr->qr_domain);\n\t\tgoto out_domain_lock;\n\t}\n\n\tspin_lock(&dlm->spinlock);\n\tif (dlm->joining_node != qr->qr_node) {\n\t\tmlog(ML_ERROR, \"Node %d queried hb regions on domain %s \"\n\t\t     \"but joining node is %d\\n\", qr->qr_node, qr->qr_domain,\n\t\t     dlm->joining_node);\n\t\tgoto out_dlm_lock;\n\t}\n\n\t \n\tif (dlm->dlm_locking_proto.pv_major == 1 &&\n\t    dlm->dlm_locking_proto.pv_minor == 0) {\n\t\tmlog(ML_ERROR, \"Node %d queried hb regions on domain %s \"\n\t\t     \"but active dlm protocol is %d.%d\\n\", qr->qr_node,\n\t\t     qr->qr_domain, dlm->dlm_locking_proto.pv_major,\n\t\t     dlm->dlm_locking_proto.pv_minor);\n\t\tgoto out_dlm_lock;\n\t}\n\n\tstatus = dlm_match_regions(dlm, qr, local, sizeof(qr->qr_regions));\n\nout_dlm_lock:\n\tspin_unlock(&dlm->spinlock);\n\nout_domain_lock:\n\tspin_unlock(&dlm_domain_lock);\n\n\tkfree(local);\n\n\treturn status;\n}\n\nstatic int dlm_match_nodes(struct dlm_ctxt *dlm, struct dlm_query_nodeinfo *qn)\n{\n\tstruct o2nm_node *local;\n\tstruct dlm_node_info *remote;\n\tint i, j;\n\tint status = 0;\n\n\tfor (j = 0; j < qn->qn_numnodes; ++j)\n\t\tmlog(0, \"Node %3d, %pI4:%u\\n\", qn->qn_nodes[j].ni_nodenum,\n\t\t     &(qn->qn_nodes[j].ni_ipv4_address),\n\t\t     ntohs(qn->qn_nodes[j].ni_ipv4_port));\n\n\tfor (i = 0; i < O2NM_MAX_NODES && !status; ++i) {\n\t\tlocal = o2nm_get_node_by_num(i);\n\t\tremote = NULL;\n\t\tfor (j = 0; j < qn->qn_numnodes; ++j) {\n\t\t\tif (qn->qn_nodes[j].ni_nodenum == i) {\n\t\t\t\tremote = &(qn->qn_nodes[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!local && !remote)\n\t\t\tcontinue;\n\n\t\tif ((local && !remote) || (!local && remote))\n\t\t\tstatus = -EINVAL;\n\n\t\tif (!status &&\n\t\t    ((remote->ni_nodenum != local->nd_num) ||\n\t\t     (remote->ni_ipv4_port != local->nd_ipv4_port) ||\n\t\t     (remote->ni_ipv4_address != local->nd_ipv4_address)))\n\t\t\tstatus = -EINVAL;\n\n\t\tif (status) {\n\t\t\tif (remote && !local)\n\t\t\t\tmlog(ML_ERROR, \"Domain %s: Node %d (%pI4:%u) \"\n\t\t\t\t     \"registered in joining node %d but not in \"\n\t\t\t\t     \"local node %d\\n\", qn->qn_domain,\n\t\t\t\t     remote->ni_nodenum,\n\t\t\t\t     &(remote->ni_ipv4_address),\n\t\t\t\t     ntohs(remote->ni_ipv4_port),\n\t\t\t\t     qn->qn_nodenum, dlm->node_num);\n\t\t\tif (local && !remote)\n\t\t\t\tmlog(ML_ERROR, \"Domain %s: Node %d (%pI4:%u) \"\n\t\t\t\t     \"registered in local node %d but not in \"\n\t\t\t\t     \"joining node %d\\n\", qn->qn_domain,\n\t\t\t\t     local->nd_num, &(local->nd_ipv4_address),\n\t\t\t\t     ntohs(local->nd_ipv4_port),\n\t\t\t\t     dlm->node_num, qn->qn_nodenum);\n\t\t\tBUG_ON((!local && !remote));\n\t\t}\n\n\t\tif (local)\n\t\t\to2nm_node_put(local);\n\t}\n\n\treturn status;\n}\n\nstatic int dlm_send_nodeinfo(struct dlm_ctxt *dlm, unsigned long *node_map)\n{\n\tstruct dlm_query_nodeinfo *qn = NULL;\n\tstruct o2nm_node *node;\n\tint ret = 0, status, count, i;\n\n\tif (find_first_bit(node_map, O2NM_MAX_NODES) >= O2NM_MAX_NODES)\n\t\tgoto bail;\n\n\tqn = kzalloc(sizeof(struct dlm_query_nodeinfo), GFP_KERNEL);\n\tif (!qn) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tfor (i = 0, count = 0; i < O2NM_MAX_NODES; ++i) {\n\t\tnode = o2nm_get_node_by_num(i);\n\t\tif (!node)\n\t\t\tcontinue;\n\t\tqn->qn_nodes[count].ni_nodenum = node->nd_num;\n\t\tqn->qn_nodes[count].ni_ipv4_port = node->nd_ipv4_port;\n\t\tqn->qn_nodes[count].ni_ipv4_address = node->nd_ipv4_address;\n\t\tmlog(0, \"Node %3d, %pI4:%u\\n\", node->nd_num,\n\t\t     &(node->nd_ipv4_address), ntohs(node->nd_ipv4_port));\n\t\t++count;\n\t\to2nm_node_put(node);\n\t}\n\n\tqn->qn_nodenum = dlm->node_num;\n\tqn->qn_numnodes = count;\n\tqn->qn_namelen = strlen(dlm->name);\n\tmemcpy(qn->qn_domain, dlm->name, qn->qn_namelen);\n\n\ti = -1;\n\twhile ((i = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t  i + 1)) < O2NM_MAX_NODES) {\n\t\tif (i == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tmlog(0, \"Sending nodeinfo to node %d\\n\", i);\n\n\t\tret = o2net_send_message(DLM_QUERY_NODEINFO, DLM_MOD_KEY,\n\t\t\t\t\t qn, sizeof(struct dlm_query_nodeinfo),\n\t\t\t\t\t i, &status);\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (ret) {\n\t\t\tmlog(ML_ERROR, \"node mismatch %d, node %d\\n\", ret, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\nbail:\n\tkfree(qn);\n\treturn ret;\n}\n\nstatic int dlm_query_nodeinfo_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t      void *data, void **ret_data)\n{\n\tstruct dlm_query_nodeinfo *qn;\n\tstruct dlm_ctxt *dlm = NULL;\n\tint locked = 0, status = -EINVAL;\n\n\tqn = (struct dlm_query_nodeinfo *) msg->buf;\n\n\tmlog(0, \"Node %u queries nodes on domain %s\\n\", qn->qn_nodenum,\n\t     qn->qn_domain);\n\n\tspin_lock(&dlm_domain_lock);\n\tdlm = __dlm_lookup_domain_full(qn->qn_domain, qn->qn_namelen);\n\tif (!dlm) {\n\t\tmlog(ML_ERROR, \"Node %d queried nodes on domain %s before \"\n\t\t     \"join domain\\n\", qn->qn_nodenum, qn->qn_domain);\n\t\tgoto bail;\n\t}\n\n\tspin_lock(&dlm->spinlock);\n\tlocked = 1;\n\tif (dlm->joining_node != qn->qn_nodenum) {\n\t\tmlog(ML_ERROR, \"Node %d queried nodes on domain %s but \"\n\t\t     \"joining node is %d\\n\", qn->qn_nodenum, qn->qn_domain,\n\t\t     dlm->joining_node);\n\t\tgoto bail;\n\t}\n\n\t \n\tif (dlm->dlm_locking_proto.pv_major == 1 &&\n\t    dlm->dlm_locking_proto.pv_minor == 0) {\n\t\tmlog(ML_ERROR, \"Node %d queried nodes on domain %s \"\n\t\t     \"but active dlm protocol is %d.%d\\n\", qn->qn_nodenum,\n\t\t     qn->qn_domain, dlm->dlm_locking_proto.pv_major,\n\t\t     dlm->dlm_locking_proto.pv_minor);\n\t\tgoto bail;\n\t}\n\n\tstatus = dlm_match_nodes(dlm, qn);\n\nbail:\n\tif (locked)\n\t\tspin_unlock(&dlm->spinlock);\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn status;\n}\n\nstatic int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data)\n{\n\tstruct dlm_cancel_join *cancel;\n\tstruct dlm_ctxt *dlm = NULL;\n\n\tcancel = (struct dlm_cancel_join *) msg->buf;\n\n\tmlog(0, \"node %u cancels join on domain %s\\n\", cancel->node_idx,\n\t\t  cancel->domain);\n\n\tspin_lock(&dlm_domain_lock);\n\tdlm = __dlm_lookup_domain_full(cancel->domain, cancel->name_len);\n\n\tif (dlm) {\n\t\tspin_lock(&dlm->spinlock);\n\n\t\t \n\t\tBUG_ON(dlm->joining_node != cancel->node_idx);\n\t\t__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\n\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn 0;\n}\n\nstatic int dlm_send_one_join_cancel(struct dlm_ctxt *dlm,\n\t\t\t\t    unsigned int node)\n{\n\tint status;\n\tstruct dlm_cancel_join cancel_msg;\n\n\tmemset(&cancel_msg, 0, sizeof(cancel_msg));\n\tcancel_msg.node_idx = dlm->node_num;\n\tcancel_msg.name_len = strlen(dlm->name);\n\tmemcpy(cancel_msg.domain, dlm->name, cancel_msg.name_len);\n\n\tstatus = o2net_send_message(DLM_CANCEL_JOIN_MSG, DLM_MOD_KEY,\n\t\t\t\t    &cancel_msg, sizeof(cancel_msg), node,\n\t\t\t\t    NULL);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", status, DLM_CANCEL_JOIN_MSG, DLM_MOD_KEY,\n\t\t     node);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn status;\n}\n\n \nstatic int dlm_send_join_cancels(struct dlm_ctxt *dlm,\n\t\t\t\t unsigned long *node_map,\n\t\t\t\t unsigned int map_size)\n{\n\tint status, tmpstat;\n\tint node;\n\n\tif (map_size != (BITS_TO_LONGS(O2NM_MAX_NODES) *\n\t\t\t sizeof(unsigned long))) {\n\t\tmlog(ML_ERROR,\n\t\t     \"map_size %u != BITS_TO_LONGS(O2NM_MAX_NODES) %u\\n\",\n\t\t     map_size, (unsigned)BITS_TO_LONGS(O2NM_MAX_NODES));\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = 0;\n\tnode = -1;\n\twhile ((node = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\ttmpstat = dlm_send_one_join_cancel(dlm, node);\n\t\tif (tmpstat) {\n\t\t\tmlog(ML_ERROR, \"Error return %d cancelling join on \"\n\t\t\t     \"node %d\\n\", tmpstat, node);\n\t\t\tif (!status)\n\t\t\t\tstatus = tmpstat;\n\t\t}\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\nstatic int dlm_request_join(struct dlm_ctxt *dlm,\n\t\t\t    int node,\n\t\t\t    enum dlm_query_join_response_code *response)\n{\n\tint status;\n\tstruct dlm_query_join_request join_msg;\n\tstruct dlm_query_join_packet packet;\n\tu32 join_resp;\n\n\tmlog(0, \"querying node %d\\n\", node);\n\n\tmemset(&join_msg, 0, sizeof(join_msg));\n\tjoin_msg.node_idx = dlm->node_num;\n\tjoin_msg.name_len = strlen(dlm->name);\n\tmemcpy(join_msg.domain, dlm->name, join_msg.name_len);\n\tjoin_msg.dlm_proto = dlm->dlm_locking_proto;\n\tjoin_msg.fs_proto = dlm->fs_locking_proto;\n\n\t \n\tbyte_copymap(join_msg.node_map, dlm->live_nodes_map, O2NM_MAX_NODES);\n\n\tstatus = o2net_send_message(DLM_QUERY_JOIN_MSG, DLM_MOD_KEY, &join_msg,\n\t\t\t\t    sizeof(join_msg), node, &join_resp);\n\tif (status < 0 && status != -ENOPROTOOPT) {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", status, DLM_QUERY_JOIN_MSG, DLM_MOD_KEY,\n\t\t     node);\n\t\tgoto bail;\n\t}\n\tdlm_query_join_wire_to_packet(join_resp, &packet);\n\n\t \n\tif (status == -ENOPROTOOPT) {\n\t\tstatus = 0;\n\t\t*response = JOIN_OK_NO_MAP;\n\t} else {\n\t\t*response = packet.code;\n\t\tswitch (packet.code) {\n\t\tcase JOIN_DISALLOW:\n\t\tcase JOIN_OK_NO_MAP:\n\t\t\tbreak;\n\t\tcase JOIN_PROTOCOL_MISMATCH:\n\t\t\tmlog(ML_NOTICE,\n\t\t\t     \"This node requested DLM locking protocol %u.%u and \"\n\t\t\t     \"filesystem locking protocol %u.%u.  At least one of \"\n\t\t\t     \"the protocol versions on node %d is not compatible, \"\n\t\t\t     \"disconnecting\\n\",\n\t\t\t     dlm->dlm_locking_proto.pv_major,\n\t\t\t     dlm->dlm_locking_proto.pv_minor,\n\t\t\t     dlm->fs_locking_proto.pv_major,\n\t\t\t     dlm->fs_locking_proto.pv_minor,\n\t\t\t     node);\n\t\t\tstatus = -EPROTO;\n\t\t\tbreak;\n\t\tcase JOIN_OK:\n\t\t\t \n\t\t\tdlm->dlm_locking_proto.pv_minor = packet.dlm_minor;\n\t\t\tdlm->fs_locking_proto.pv_minor = packet.fs_minor;\n\t\t\tmlog(0,\n\t\t\t     \"Node %d responds JOIN_OK with DLM locking protocol \"\n\t\t\t     \"%u.%u and fs locking protocol %u.%u\\n\",\n\t\t\t     node,\n\t\t\t     dlm->dlm_locking_proto.pv_major,\n\t\t\t     dlm->dlm_locking_proto.pv_minor,\n\t\t\t     dlm->fs_locking_proto.pv_major,\n\t\t\t     dlm->fs_locking_proto.pv_minor);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog(ML_ERROR, \"invalid response %d from node %u\\n\",\n\t\t\t     packet.code, node);\n\t\t\t \n\t\t\t*response = JOIN_DISALLOW;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmlog(0, \"status %d, node %d response is %d\\n\", status, node,\n\t     *response);\n\nbail:\n\treturn status;\n}\n\nstatic int dlm_send_one_join_assert(struct dlm_ctxt *dlm,\n\t\t\t\t    unsigned int node)\n{\n\tint status;\n\tint ret;\n\tstruct dlm_assert_joined assert_msg;\n\n\tmlog(0, \"Sending join assert to node %u\\n\", node);\n\n\tmemset(&assert_msg, 0, sizeof(assert_msg));\n\tassert_msg.node_idx = dlm->node_num;\n\tassert_msg.name_len = strlen(dlm->name);\n\tmemcpy(assert_msg.domain, dlm->name, assert_msg.name_len);\n\n\tstatus = o2net_send_message(DLM_ASSERT_JOINED_MSG, DLM_MOD_KEY,\n\t\t\t\t    &assert_msg, sizeof(assert_msg), node,\n\t\t\t\t    &ret);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", status, DLM_ASSERT_JOINED_MSG, DLM_MOD_KEY,\n\t\t     node);\n\telse\n\t\tstatus = ret;\n\n\treturn status;\n}\n\nstatic void dlm_send_join_asserts(struct dlm_ctxt *dlm,\n\t\t\t\t  unsigned long *node_map)\n{\n\tint status, node, live;\n\n\tstatus = 0;\n\tnode = -1;\n\twhile ((node = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\t \n\t\t\tstatus = dlm_send_one_join_assert(dlm, node);\n\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tlive = test_bit(node, dlm->live_nodes_map);\n\t\t\tspin_unlock(&dlm->spinlock);\n\n\t\t\tif (status) {\n\t\t\t\tmlog(ML_ERROR, \"Error return %d asserting \"\n\t\t\t\t     \"join on node %d\\n\", status, node);\n\n\t\t\t\t \n\t\t\t\tif (live)\n\t\t\t\t\tmsleep(DLM_DOMAIN_BACKOFF_MS);\n\t\t\t}\n\t\t} while (status && live);\n\t}\n}\n\nstruct domain_join_ctxt {\n\tunsigned long live_map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tunsigned long yes_resp_map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n};\n\nstatic int dlm_should_restart_join(struct dlm_ctxt *dlm,\n\t\t\t\t   struct domain_join_ctxt *ctxt,\n\t\t\t\t   enum dlm_query_join_response_code response)\n{\n\tint ret;\n\n\tif (response == JOIN_DISALLOW) {\n\t\tmlog(0, \"Latest response of disallow -- should restart\\n\");\n\t\treturn 1;\n\t}\n\n\tspin_lock(&dlm->spinlock);\n\t \n\tret = !bitmap_equal(ctxt->live_map, dlm->live_nodes_map,\n\t\t\t    O2NM_MAX_NODES);\n\tspin_unlock(&dlm->spinlock);\n\n\tif (ret)\n\t\tmlog(0, \"Node maps changed -- should restart\\n\");\n\n\treturn ret;\n}\n\nstatic int dlm_try_to_join_domain(struct dlm_ctxt *dlm)\n{\n\tint status = 0, tmpstat, node;\n\tstruct domain_join_ctxt *ctxt;\n\tenum dlm_query_join_response_code response = JOIN_DISALLOW;\n\n\tmlog(0, \"%p\", dlm);\n\n\tctxt = kzalloc(sizeof(*ctxt), GFP_KERNEL);\n\tif (!ctxt) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t \n\to2hb_fill_node_map(dlm->live_nodes_map, O2NM_MAX_NODES);\n\n\tspin_lock(&dlm->spinlock);\n\tbitmap_copy(ctxt->live_map, dlm->live_nodes_map, O2NM_MAX_NODES);\n\t__dlm_set_joining_node(dlm, dlm->node_num);\n\tspin_unlock(&dlm->spinlock);\n\n\tnode = -1;\n\twhile ((node = find_next_bit(ctxt->live_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tstatus = dlm_request_join(dlm, node, &response);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t \n\t\tif (response == JOIN_OK)\n\t\t\tset_bit(node, ctxt->yes_resp_map);\n\n\t\tif (dlm_should_restart_join(dlm, ctxt, response)) {\n\t\t\tstatus = -EAGAIN;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tmlog(0, \"Yay, done querying nodes!\\n\");\n\n\t \n\tspin_lock(&dlm->spinlock);\n\tbitmap_copy(dlm->domain_map, ctxt->yes_resp_map, O2NM_MAX_NODES);\n\tset_bit(dlm->node_num, dlm->domain_map);\n\tspin_unlock(&dlm->spinlock);\n\n\t \n\tif (dlm->dlm_locking_proto.pv_major > 1 ||\n\t    dlm->dlm_locking_proto.pv_minor > 0) {\n\t\tstatus = dlm_send_nodeinfo(dlm, ctxt->yes_resp_map);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tstatus = dlm_send_regions(dlm, ctxt->yes_resp_map);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tdlm_send_join_asserts(dlm, ctxt->yes_resp_map);\n\n\t \n\tspin_lock(&dlm_domain_lock);\n\tdlm->dlm_state = DLM_CTXT_JOINED;\n\tdlm->num_joins++;\n\tspin_unlock(&dlm_domain_lock);\n\nbail:\n\tspin_lock(&dlm->spinlock);\n\t__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\n\tif (!status) {\n\t\tprintk(KERN_NOTICE \"o2dlm: Joining domain %s \", dlm->name);\n\t\t__dlm_print_nodes(dlm);\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\tif (ctxt) {\n\t\t \n\t\tif (status < 0) {\n\t\t\ttmpstat = dlm_send_join_cancels(dlm,\n\t\t\t\t\t\t\tctxt->yes_resp_map,\n\t\t\t\t\t\t\tsizeof(ctxt->yes_resp_map));\n\t\t\tif (tmpstat < 0)\n\t\t\t\tmlog_errno(tmpstat);\n\t\t}\n\t\tkfree(ctxt);\n\t}\n\n\tmlog(0, \"returning %d\\n\", status);\n\treturn status;\n}\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm)\n{\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_up);\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_down);\n\to2net_unregister_handler_list(&dlm->dlm_domain_handlers);\n}\n\nstatic int dlm_register_domain_handlers(struct dlm_ctxt *dlm)\n{\n\tint status;\n\n\tmlog(0, \"registering handlers.\\n\");\n\n\to2hb_setup_callback(&dlm->dlm_hb_down, O2HB_NODE_DOWN_CB,\n\t\t\t    dlm_hb_node_down_cb, dlm, DLM_HB_NODE_DOWN_PRI);\n\to2hb_setup_callback(&dlm->dlm_hb_up, O2HB_NODE_UP_CB,\n\t\t\t    dlm_hb_node_up_cb, dlm, DLM_HB_NODE_UP_PRI);\n\n\tstatus = o2hb_register_callback(dlm->name, &dlm->dlm_hb_down);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2hb_register_callback(dlm->name, &dlm->dlm_hb_up);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MASTER_REQUEST_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_master_request),\n\t\t\t\t\tdlm_master_request_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_ASSERT_MASTER_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_assert_master),\n\t\t\t\t\tdlm_assert_master_handler,\n\t\t\t\t\tdlm, dlm_assert_master_post_handler,\n\t\t\t\t\t&dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_CREATE_LOCK_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_create_lock),\n\t\t\t\t\tdlm_create_lock_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_CONVERT_LOCK_MSG, dlm->key,\n\t\t\t\t\tDLM_CONVERT_LOCK_MAX_LEN,\n\t\t\t\t\tdlm_convert_lock_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_UNLOCK_LOCK_MSG, dlm->key,\n\t\t\t\t\tDLM_UNLOCK_LOCK_MAX_LEN,\n\t\t\t\t\tdlm_unlock_lock_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_PROXY_AST_MSG, dlm->key,\n\t\t\t\t\tDLM_PROXY_AST_MAX_LEN,\n\t\t\t\t\tdlm_proxy_ast_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_EXIT_DOMAIN_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_exit_domain),\n\t\t\t\t\tdlm_exit_domain_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_DEREF_LOCKRES_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_deref_lockres),\n\t\t\t\t\tdlm_deref_lockres_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MIGRATE_REQUEST_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_migrate_request),\n\t\t\t\t\tdlm_migrate_request_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MIG_LOCKRES_MSG, dlm->key,\n\t\t\t\t\tDLM_MIG_LOCKRES_MAX_LEN,\n\t\t\t\t\tdlm_mig_lockres_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MASTER_REQUERY_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_master_requery),\n\t\t\t\t\tdlm_master_requery_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_LOCK_REQUEST_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_lock_request),\n\t\t\t\t\tdlm_request_all_locks_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_RECO_DATA_DONE_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_reco_data_done),\n\t\t\t\t\tdlm_reco_data_done_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_BEGIN_RECO_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_begin_reco),\n\t\t\t\t\tdlm_begin_reco_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_FINALIZE_RECO_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_finalize_reco),\n\t\t\t\t\tdlm_finalize_reco_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_BEGIN_EXIT_DOMAIN_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_exit_domain),\n\t\t\t\t\tdlm_begin_exit_domain_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_DEREF_LOCKRES_DONE, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_deref_lockres_done),\n\t\t\t\t\tdlm_deref_lockres_done_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\nbail:\n\tif (status)\n\t\tdlm_unregister_domain_handlers(dlm);\n\n\treturn status;\n}\n\nstatic int dlm_join_domain(struct dlm_ctxt *dlm)\n{\n\tint status;\n\tunsigned int backoff;\n\tunsigned int total_backoff = 0;\n\tchar wq_name[O2NM_MAX_NAME_LEN];\n\n\tBUG_ON(!dlm);\n\n\tmlog(0, \"Join domain %s\\n\", dlm->name);\n\n\tstatus = dlm_register_domain_handlers(dlm);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = dlm_launch_thread(dlm);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = dlm_launch_recovery_thread(dlm);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdlm_debug_init(dlm);\n\n\tsnprintf(wq_name, O2NM_MAX_NAME_LEN, \"dlm_wq-%s\", dlm->name);\n\tdlm->dlm_worker = alloc_workqueue(wq_name, WQ_MEM_RECLAIM, 0);\n\tif (!dlm->dlm_worker) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdo {\n\t\tstatus = dlm_try_to_join_domain(dlm);\n\n\t\t \n#define\tDLM_JOIN_TIMEOUT_MSECS\t90000\n\t\tif (status == -EAGAIN) {\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tstatus = -ERESTARTSYS;\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tif (total_backoff > DLM_JOIN_TIMEOUT_MSECS) {\n\t\t\t\tstatus = -ERESTARTSYS;\n\t\t\t\tmlog(ML_NOTICE, \"Timed out joining dlm domain \"\n\t\t\t\t     \"%s after %u msecs\\n\", dlm->name,\n\t\t\t\t     total_backoff);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\t \n\t\t\tbackoff = (unsigned int)(jiffies & 0x3);\n\t\t\tbackoff *= DLM_DOMAIN_BACKOFF_MS;\n\t\t\ttotal_backoff += backoff;\n\t\t\tmlog(0, \"backoff %d\\n\", backoff);\n\t\t\tmsleep(backoff);\n\t\t}\n\t} while (status == -EAGAIN);\n\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\twake_up(&dlm_domain_events);\n\n\tif (status) {\n\t\tdlm_unregister_domain_handlers(dlm);\n\t\tdlm_complete_thread(dlm);\n\t\tdlm_complete_recovery_thread(dlm);\n\t\tdlm_destroy_dlm_worker(dlm);\n\t}\n\n\treturn status;\n}\n\nstatic struct dlm_ctxt *dlm_alloc_ctxt(const char *domain,\n\t\t\t\tu32 key)\n{\n\tint i;\n\tint ret;\n\tstruct dlm_ctxt *dlm = NULL;\n\n\tdlm = kzalloc(sizeof(*dlm), GFP_KERNEL);\n\tif (!dlm) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tdlm->name = kstrdup(domain, GFP_KERNEL);\n\tif (dlm->name == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tdlm->lockres_hash = (struct hlist_head **)dlm_alloc_pagevec(DLM_HASH_PAGES);\n\tif (!dlm->lockres_hash) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++)\n\t\tINIT_HLIST_HEAD(dlm_lockres_hash(dlm, i));\n\n\tdlm->master_hash = (struct hlist_head **)\n\t\t\t\tdlm_alloc_pagevec(DLM_HASH_PAGES);\n\tif (!dlm->master_hash) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++)\n\t\tINIT_HLIST_HEAD(dlm_master_hash(dlm, i));\n\n\tdlm->key = key;\n\tdlm->node_num = o2nm_this_node();\n\n\tdlm_create_debugfs_subroot(dlm);\n\n\tspin_lock_init(&dlm->spinlock);\n\tspin_lock_init(&dlm->master_lock);\n\tspin_lock_init(&dlm->ast_lock);\n\tspin_lock_init(&dlm->track_lock);\n\tINIT_LIST_HEAD(&dlm->list);\n\tINIT_LIST_HEAD(&dlm->dirty_list);\n\tINIT_LIST_HEAD(&dlm->reco.resources);\n\tINIT_LIST_HEAD(&dlm->reco.node_data);\n\tINIT_LIST_HEAD(&dlm->purge_list);\n\tINIT_LIST_HEAD(&dlm->dlm_domain_handlers);\n\tINIT_LIST_HEAD(&dlm->tracking_list);\n\tdlm->reco.state = 0;\n\n\tINIT_LIST_HEAD(&dlm->pending_asts);\n\tINIT_LIST_HEAD(&dlm->pending_basts);\n\n\tmlog(0, \"dlm->recovery_map=%p, &(dlm->recovery_map[0])=%p\\n\",\n\t\t  dlm->recovery_map, &(dlm->recovery_map[0]));\n\n\tbitmap_zero(dlm->recovery_map, O2NM_MAX_NODES);\n\tbitmap_zero(dlm->live_nodes_map, O2NM_MAX_NODES);\n\tbitmap_zero(dlm->domain_map, O2NM_MAX_NODES);\n\n\tdlm->dlm_thread_task = NULL;\n\tdlm->dlm_reco_thread_task = NULL;\n\tdlm->dlm_worker = NULL;\n\tinit_waitqueue_head(&dlm->dlm_thread_wq);\n\tinit_waitqueue_head(&dlm->dlm_reco_thread_wq);\n\tinit_waitqueue_head(&dlm->reco.event);\n\tinit_waitqueue_head(&dlm->ast_wq);\n\tinit_waitqueue_head(&dlm->migration_wq);\n\tINIT_LIST_HEAD(&dlm->mle_hb_events);\n\n\tdlm->joining_node = DLM_LOCK_RES_OWNER_UNKNOWN;\n\tinit_waitqueue_head(&dlm->dlm_join_events);\n\n\tdlm->migrate_done = 0;\n\n\tdlm->reco.new_master = O2NM_INVALID_NODE_NUM;\n\tdlm->reco.dead_node = O2NM_INVALID_NODE_NUM;\n\n\tatomic_set(&dlm->res_tot_count, 0);\n\tatomic_set(&dlm->res_cur_count, 0);\n\tfor (i = 0; i < DLM_MLE_NUM_TYPES; ++i) {\n\t\tatomic_set(&dlm->mle_tot_count[i], 0);\n\t\tatomic_set(&dlm->mle_cur_count[i], 0);\n\t}\n\n\tspin_lock_init(&dlm->work_lock);\n\tINIT_LIST_HEAD(&dlm->work_list);\n\tINIT_WORK(&dlm->dispatched_work, dlm_dispatch_work);\n\n\tkref_init(&dlm->dlm_refs);\n\tdlm->dlm_state = DLM_CTXT_NEW;\n\n\tINIT_LIST_HEAD(&dlm->dlm_eviction_callbacks);\n\n\tmlog(0, \"context init: refcount %u\\n\",\n\t\t  kref_read(&dlm->dlm_refs));\n\n\tret = 0;\nleave:\n\tif (ret < 0 && dlm) {\n\t\tif (dlm->master_hash)\n\t\t\tdlm_free_pagevec((void **)dlm->master_hash,\n\t\t\t\t\tDLM_HASH_PAGES);\n\n\t\tif (dlm->lockres_hash)\n\t\t\tdlm_free_pagevec((void **)dlm->lockres_hash,\n\t\t\t\t\tDLM_HASH_PAGES);\n\n\t\tkfree(dlm->name);\n\t\tkfree(dlm);\n\t\tdlm = NULL;\n\t}\n\treturn dlm;\n}\n\n \nstatic int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request)\n{\n\tif (existing->pv_major != request->pv_major)\n\t\treturn 1;\n\n\tif (existing->pv_minor > request->pv_minor)\n\t\treturn 1;\n\n\tif (existing->pv_minor < request->pv_minor)\n\t\trequest->pv_minor = existing->pv_minor;\n\n\treturn 0;\n}\n\n \nstruct dlm_ctxt * dlm_register_domain(const char *domain,\n\t\t\t       u32 key,\n\t\t\t       struct dlm_protocol_version *fs_proto)\n{\n\tint ret;\n\tstruct dlm_ctxt *dlm = NULL;\n\tstruct dlm_ctxt *new_ctxt = NULL;\n\n\tif (strlen(domain) >= O2NM_MAX_NAME_LEN) {\n\t\tret = -ENAMETOOLONG;\n\t\tmlog(ML_ERROR, \"domain name length too long\\n\");\n\t\tgoto leave;\n\t}\n\n\tmlog(0, \"register called for domain \\\"%s\\\"\\n\", domain);\n\nretry:\n\tdlm = NULL;\n\tif (signal_pending(current)) {\n\t\tret = -ERESTARTSYS;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&dlm_domain_lock);\n\n\tdlm = __dlm_lookup_domain(domain);\n\tif (dlm) {\n\t\tif (dlm->dlm_state != DLM_CTXT_JOINED) {\n\t\t\tspin_unlock(&dlm_domain_lock);\n\n\t\t\tmlog(0, \"This ctxt is not joined yet!\\n\");\n\t\t\twait_event_interruptible(dlm_domain_events,\n\t\t\t\t\t\t dlm_wait_on_domain_helper(\n\t\t\t\t\t\t\t domain));\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (dlm_protocol_compare(&dlm->fs_locking_proto, fs_proto)) {\n\t\t\tspin_unlock(&dlm_domain_lock);\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Requested locking protocol version is not \"\n\t\t\t     \"compatible with already registered domain \"\n\t\t\t     \"\\\"%s\\\"\\n\", domain);\n\t\t\tret = -EPROTO;\n\t\t\tgoto leave;\n\t\t}\n\n\t\t__dlm_get(dlm);\n\t\tdlm->num_joins++;\n\n\t\tspin_unlock(&dlm_domain_lock);\n\n\t\tret = 0;\n\t\tgoto leave;\n\t}\n\n\t \n\tif (!new_ctxt) {\n\t\tspin_unlock(&dlm_domain_lock);\n\n\t\tnew_ctxt = dlm_alloc_ctxt(domain, key);\n\t\tif (new_ctxt)\n\t\t\tgoto retry;\n\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\t \n\tdlm = new_ctxt;\n\tnew_ctxt = NULL;\n\n\t \n\tlist_add_tail(&dlm->list, &dlm_domains);\n\tspin_unlock(&dlm_domain_lock);\n\n\t \n\tdlm->dlm_locking_proto = dlm_protocol;\n\tdlm->fs_locking_proto = *fs_proto;\n\n\tret = dlm_join_domain(dlm);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tdlm_put(dlm);\n\t\tgoto leave;\n\t}\n\n\t \n\t*fs_proto = dlm->fs_locking_proto;\n\n\tret = 0;\nleave:\n\tif (new_ctxt)\n\t\tdlm_free_ctxt_mem(new_ctxt);\n\n\tif (ret < 0)\n\t\tdlm = ERR_PTR(ret);\n\n\treturn dlm;\n}\nEXPORT_SYMBOL_GPL(dlm_register_domain);\n\nstatic LIST_HEAD(dlm_join_handlers);\n\nstatic void dlm_unregister_net_handlers(void)\n{\n\to2net_unregister_handler_list(&dlm_join_handlers);\n}\n\nstatic int dlm_register_net_handlers(void)\n{\n\tint status = 0;\n\n\tstatus = o2net_register_handler(DLM_QUERY_JOIN_MSG, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_query_join_request),\n\t\t\t\t\tdlm_query_join_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_ASSERT_JOINED_MSG, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_assert_joined),\n\t\t\t\t\tdlm_assert_joined_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_CANCEL_JOIN_MSG, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_cancel_join),\n\t\t\t\t\tdlm_cancel_join_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_QUERY_REGION, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_query_region),\n\t\t\t\t\tdlm_query_region_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_QUERY_NODEINFO, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_query_nodeinfo),\n\t\t\t\t\tdlm_query_nodeinfo_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\nbail:\n\tif (status < 0)\n\t\tdlm_unregister_net_handlers();\n\n\treturn status;\n}\n\n \n\n \nstatic DECLARE_RWSEM(dlm_callback_sem);\n\nvoid dlm_fire_domain_eviction_callbacks(struct dlm_ctxt *dlm,\n\t\t\t\t\tint node_num)\n{\n\tstruct dlm_eviction_cb *cb;\n\n\tdown_read(&dlm_callback_sem);\n\tlist_for_each_entry(cb, &dlm->dlm_eviction_callbacks, ec_item) {\n\t\tcb->ec_func(node_num, cb->ec_data);\n\t}\n\tup_read(&dlm_callback_sem);\n}\n\nvoid dlm_setup_eviction_cb(struct dlm_eviction_cb *cb,\n\t\t\t   dlm_eviction_func *f,\n\t\t\t   void *data)\n{\n\tINIT_LIST_HEAD(&cb->ec_item);\n\tcb->ec_func = f;\n\tcb->ec_data = data;\n}\nEXPORT_SYMBOL_GPL(dlm_setup_eviction_cb);\n\nvoid dlm_register_eviction_cb(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_eviction_cb *cb)\n{\n\tdown_write(&dlm_callback_sem);\n\tlist_add_tail(&cb->ec_item, &dlm->dlm_eviction_callbacks);\n\tup_write(&dlm_callback_sem);\n}\nEXPORT_SYMBOL_GPL(dlm_register_eviction_cb);\n\nvoid dlm_unregister_eviction_cb(struct dlm_eviction_cb *cb)\n{\n\tdown_write(&dlm_callback_sem);\n\tlist_del_init(&cb->ec_item);\n\tup_write(&dlm_callback_sem);\n}\nEXPORT_SYMBOL_GPL(dlm_unregister_eviction_cb);\n\nstatic int __init dlm_init(void)\n{\n\tint status;\n\n\tstatus = dlm_init_mle_cache();\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Could not create o2dlm_mle slabcache\\n\");\n\t\tgoto error;\n\t}\n\n\tstatus = dlm_init_master_caches();\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Could not create o2dlm_lockres and \"\n\t\t     \"o2dlm_lockname slabcaches\\n\");\n\t\tgoto error;\n\t}\n\n\tstatus = dlm_init_lock_cache();\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Count not create o2dlm_lock slabcache\\n\");\n\t\tgoto error;\n\t}\n\n\tstatus = dlm_register_net_handlers();\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Unable to register network handlers\\n\");\n\t\tgoto error;\n\t}\n\n\tdlm_create_debugfs_root();\n\n\treturn 0;\nerror:\n\tdlm_unregister_net_handlers();\n\tdlm_destroy_lock_cache();\n\tdlm_destroy_master_caches();\n\tdlm_destroy_mle_cache();\n\treturn -1;\n}\n\nstatic void __exit dlm_exit (void)\n{\n\tdlm_destroy_debugfs_root();\n\tdlm_unregister_net_handlers();\n\tdlm_destroy_lock_cache();\n\tdlm_destroy_master_caches();\n\tdlm_destroy_mle_cache();\n}\n\nMODULE_AUTHOR(\"Oracle\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"OCFS2 Distributed Lock Management\");\n\nmodule_init(dlm_init);\nmodule_exit(dlm_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}