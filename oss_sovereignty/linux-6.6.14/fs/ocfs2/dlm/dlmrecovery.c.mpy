{
  "module_name": "dlmrecovery.c",
  "hash_id": "73e6dae83d0998c838d0caa64ff4ece656cb74a920e04b1eb430c13ed7e5bca3",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/dlm/dlmrecovery.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/socket.h>\n#include <linux/inet.h>\n#include <linux/timer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\n\n#include \"../cluster/heartbeat.h\"\n#include \"../cluster/nodemanager.h\"\n#include \"../cluster/tcp.h\"\n\n#include \"dlmapi.h\"\n#include \"dlmcommon.h\"\n#include \"dlmdomain.h\"\n\n#define MLOG_MASK_PREFIX (ML_DLM|ML_DLM_RECOVERY)\n#include \"../cluster/masklog.h\"\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\n\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\n\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm);\n\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_all_done_msg(struct dlm_ctxt *dlm,\n\t\t\t\t u8 dead_node, u8 send_to);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\nstatic void dlm_reco_ast(void *astdata);\nstatic void dlm_reco_bast(void *astdata, int blocked_type);\nstatic void dlm_reco_unlock_ast(void *astdata, enum dlm_status st);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\nstatic int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master);\n\nstatic u64 dlm_get_next_mig_cookie(void);\n\nstatic DEFINE_SPINLOCK(dlm_reco_state_lock);\nstatic DEFINE_SPINLOCK(dlm_mig_cookie_lock);\nstatic u64 dlm_mig_cookie = 1;\n\nstatic u64 dlm_get_next_mig_cookie(void)\n{\n\tu64 c;\n\tspin_lock(&dlm_mig_cookie_lock);\n\tc = dlm_mig_cookie;\n\tif (dlm_mig_cookie == (~0ULL))\n\t\tdlm_mig_cookie = 1;\n\telse\n\t\tdlm_mig_cookie++;\n\tspin_unlock(&dlm_mig_cookie_lock);\n\treturn c;\n}\n\nstatic inline void dlm_set_reco_dead_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 dead_node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tif (dlm->reco.dead_node != dead_node)\n\t\tmlog(0, \"%s: changing dead_node from %u to %u\\n\",\n\t\t     dlm->name, dlm->reco.dead_node, dead_node);\n\tdlm->reco.dead_node = dead_node;\n}\n\nstatic inline void dlm_set_reco_master(struct dlm_ctxt *dlm,\n\t\t\t\t       u8 master)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tmlog(0, \"%s: changing new_master from %u to %u\\n\",\n\t     dlm->name, dlm->reco.new_master, master);\n\tdlm->reco.new_master = master;\n}\n\nstatic inline void __dlm_reset_recovery(struct dlm_ctxt *dlm)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tclear_bit(dlm->reco.dead_node, dlm->recovery_map);\n\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\tdlm_set_reco_master(dlm, O2NM_INVALID_NODE_NUM);\n}\n\n \nvoid dlm_dispatch_work(struct work_struct *work)\n{\n\tstruct dlm_ctxt *dlm =\n\t\tcontainer_of(work, struct dlm_ctxt, dispatched_work);\n\tLIST_HEAD(tmp_list);\n\tstruct dlm_work_item *item, *next;\n\tdlm_workfunc_t *workfunc;\n\tint tot=0;\n\n\tspin_lock(&dlm->work_lock);\n\tlist_splice_init(&dlm->work_list, &tmp_list);\n\tspin_unlock(&dlm->work_lock);\n\n\tlist_for_each_entry(item, &tmp_list, list) {\n\t\ttot++;\n\t}\n\tmlog(0, \"%s: work thread has %d work items\\n\", dlm->name, tot);\n\n\tlist_for_each_entry_safe(item, next, &tmp_list, list) {\n\t\tworkfunc = item->func;\n\t\tlist_del_init(&item->list);\n\n\t\t \n\t\tBUG_ON(item->dlm != dlm);\n\n\t\t \n\t\tworkfunc(item, item->data);\n\n\t\tdlm_put(dlm);\n\t\tkfree(item);\n\t}\n}\n\n \n\nvoid dlm_kick_recovery_thread(struct dlm_ctxt *dlm)\n{\n\t \n\n\twake_up(&dlm->dlm_reco_thread_wq);\n}\n\n \nint dlm_launch_recovery_thread(struct dlm_ctxt *dlm)\n{\n\tmlog(0, \"starting dlm recovery thread...\\n\");\n\n\tdlm->dlm_reco_thread_task = kthread_run(dlm_recovery_thread, dlm,\n\t\t\t\"dlm_reco-%s\", dlm->name);\n\tif (IS_ERR(dlm->dlm_reco_thread_task)) {\n\t\tmlog_errno(PTR_ERR(dlm->dlm_reco_thread_task));\n\t\tdlm->dlm_reco_thread_task = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid dlm_complete_recovery_thread(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_reco_thread_task) {\n\t\tmlog(0, \"waiting for dlm recovery thread to exit\\n\");\n\t\tkthread_stop(dlm->dlm_reco_thread_task);\n\t\tdlm->dlm_reco_thread_task = NULL;\n\t}\n}\n\n\n\n \n\nstatic void dlm_print_reco_node_status(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_reco_node_data *ndata;\n\tstruct dlm_lock_resource *res;\n\n\tmlog(ML_NOTICE, \"%s(%d): recovery info, state=%s, dead=%u, master=%u\\n\",\n\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t     dlm->reco.state & DLM_RECO_STATE_ACTIVE ? \"ACTIVE\" : \"inactive\",\n\t     dlm->reco.dead_node, dlm->reco.new_master);\n\n\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\tchar *st = \"unknown\";\n\t\tswitch (ndata->state) {\n\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\t\tst = \"init\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\tst = \"requesting\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\t\tst = \"dead\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\t\tst = \"receiving\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\t\tst = \"requested\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\t\tst = \"done\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\t\tst = \"finalize-sent\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tst = \"bad\";\n\t\t\t\tbreak;\n\t\t}\n\t\tmlog(ML_NOTICE, \"%s: reco state, node %u, state=%s\\n\",\n\t\t     dlm->name, ndata->node_num, st);\n\t}\n\tlist_for_each_entry(res, &dlm->reco.resources, recovering) {\n\t\tmlog(ML_NOTICE, \"%s: lockres %.*s on recovering list\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t}\n}\n\n#define DLM_RECO_THREAD_TIMEOUT_MS (5 * 1000)\n\nstatic int dlm_recovery_thread(void *data)\n{\n\tint status;\n\tstruct dlm_ctxt *dlm = data;\n\tunsigned long timeout = msecs_to_jiffies(DLM_RECO_THREAD_TIMEOUT_MS);\n\n\tmlog(0, \"dlm thread running for %s...\\n\", dlm->name);\n\n\twhile (!kthread_should_stop()) {\n\t\tif (dlm_domain_fully_joined(dlm)) {\n\t\t\tstatus = dlm_do_recovery(dlm);\n\t\t\tif (status == -EAGAIN) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (status < 0)\n\t\t\t\tmlog_errno(status);\n\t\t}\n\n\t\twait_event_interruptible_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t\t\t kthread_should_stop(),\n\t\t\t\t\t\t timeout);\n\t}\n\n\tmlog(0, \"quitting DLM recovery thread\\n\");\n\treturn 0;\n}\n\n \nstatic int dlm_reco_master_ready(struct dlm_ctxt *dlm)\n{\n\tint ready;\n\tspin_lock(&dlm->spinlock);\n\tready = (dlm->reco.new_master != O2NM_INVALID_NODE_NUM);\n\tspin_unlock(&dlm->spinlock);\n\treturn ready;\n}\n\n \nint dlm_is_node_dead(struct dlm_ctxt *dlm, u8 node)\n{\n\tint dead;\n\tspin_lock(&dlm->spinlock);\n\tdead = !test_bit(node, dlm->domain_map);\n\tspin_unlock(&dlm->spinlock);\n\treturn dead;\n}\n\n \nstatic int dlm_is_node_recovered(struct dlm_ctxt *dlm, u8 node)\n{\n\tint recovered;\n\tspin_lock(&dlm->spinlock);\n\trecovered = !test_bit(node, dlm->recovery_map);\n\tspin_unlock(&dlm->spinlock);\n\treturn recovered;\n}\n\n\nvoid dlm_wait_for_node_death(struct dlm_ctxt *dlm, u8 node, int timeout)\n{\n\tif (dlm_is_node_dead(dlm, node))\n\t\treturn;\n\n\tprintk(KERN_NOTICE \"o2dlm: Waiting on the death of node %u in \"\n\t       \"domain %s\\n\", node, dlm->name);\n\n\tif (timeout)\n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t   dlm_is_node_dead(dlm, node),\n\t\t\t\t   msecs_to_jiffies(timeout));\n\telse\n\t\twait_event(dlm->dlm_reco_thread_wq,\n\t\t\t   dlm_is_node_dead(dlm, node));\n}\n\nvoid dlm_wait_for_node_recovery(struct dlm_ctxt *dlm, u8 node, int timeout)\n{\n\tif (dlm_is_node_recovered(dlm, node))\n\t\treturn;\n\n\tprintk(KERN_NOTICE \"o2dlm: Waiting on the recovery of node %u in \"\n\t       \"domain %s\\n\", node, dlm->name);\n\n\tif (timeout)\n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t   dlm_is_node_recovered(dlm, node),\n\t\t\t\t   msecs_to_jiffies(timeout));\n\telse\n\t\twait_event(dlm->dlm_reco_thread_wq,\n\t\t\t   dlm_is_node_recovered(dlm, node));\n}\n\n \nstatic int dlm_in_recovery(struct dlm_ctxt *dlm)\n{\n\tint in_recovery;\n\tspin_lock(&dlm->spinlock);\n\tin_recovery = !!(dlm->reco.state & DLM_RECO_STATE_ACTIVE);\n\tspin_unlock(&dlm->spinlock);\n\treturn in_recovery;\n}\n\n\nvoid dlm_wait_for_recovery(struct dlm_ctxt *dlm)\n{\n\tif (dlm_in_recovery(dlm)) {\n\t\tmlog(0, \"%s: reco thread %d in recovery: \"\n\t\t     \"state=%d, master=%u, dead=%u\\n\",\n\t\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t\t     dlm->reco.state, dlm->reco.new_master,\n\t\t     dlm->reco.dead_node);\n\t}\n\twait_event(dlm->reco.event, !dlm_in_recovery(dlm));\n}\n\nstatic void dlm_begin_recovery(struct dlm_ctxt *dlm)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tBUG_ON(dlm->reco.state & DLM_RECO_STATE_ACTIVE);\n\tprintk(KERN_NOTICE \"o2dlm: Begin recovery on domain %s for node %u\\n\",\n\t       dlm->name, dlm->reco.dead_node);\n\tdlm->reco.state |= DLM_RECO_STATE_ACTIVE;\n}\n\nstatic void dlm_end_recovery(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm->spinlock);\n\tBUG_ON(!(dlm->reco.state & DLM_RECO_STATE_ACTIVE));\n\tdlm->reco.state &= ~DLM_RECO_STATE_ACTIVE;\n\tspin_unlock(&dlm->spinlock);\n\tprintk(KERN_NOTICE \"o2dlm: End recovery on domain %s\\n\", dlm->name);\n\twake_up(&dlm->reco.event);\n}\n\nstatic void dlm_print_recovery_master(struct dlm_ctxt *dlm)\n{\n\tprintk(KERN_NOTICE \"o2dlm: Node %u (%s) is the Recovery Master for the \"\n\t       \"dead node %u in domain %s\\n\", dlm->reco.new_master,\n\t       (dlm->node_num == dlm->reco.new_master ? \"me\" : \"he\"),\n\t       dlm->reco.dead_node, dlm->name);\n}\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm)\n{\n\tint status = 0;\n\tint ret;\n\n\tspin_lock(&dlm->spinlock);\n\n\tif (dlm->migrate_done) {\n\t\tmlog(0, \"%s: no need do recovery after migrating all \"\n\t\t     \"lock resources\\n\", dlm->name);\n\t\tspin_unlock(&dlm->spinlock);\n\t\treturn 0;\n\t}\n\n\t \n\tif (dlm->reco.new_master != O2NM_INVALID_NODE_NUM &&\n\t    test_bit(dlm->reco.new_master, dlm->recovery_map)) {\n\t\tmlog(0, \"new master %u died while recovering %u!\\n\",\n\t\t     dlm->reco.new_master, dlm->reco.dead_node);\n\t\t \n\t\tdlm_set_reco_master(dlm, O2NM_INVALID_NODE_NUM);\n\t}\n\n\t \n\tif (dlm->reco.dead_node == O2NM_INVALID_NODE_NUM) {\n\t\tint bit;\n\n\t\tbit = find_first_bit(dlm->recovery_map, O2NM_MAX_NODES);\n\t\tif (bit >= O2NM_MAX_NODES || bit < 0)\n\t\t\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\t\telse\n\t\t\tdlm_set_reco_dead_node(dlm, bit);\n\t} else if (!test_bit(dlm->reco.dead_node, dlm->recovery_map)) {\n\t\t \n\t\tmlog(ML_ERROR, \"dead_node %u no longer in recovery map!\\n\",\n\t\t     dlm->reco.dead_node);\n\t\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\t}\n\n\tif (dlm->reco.dead_node == O2NM_INVALID_NODE_NUM) {\n\t\t \n\t\tspin_unlock(&dlm->spinlock);\n\t\t \n\t\treturn 0;\n\t}\n\tmlog(0, \"%s(%d):recovery thread found node %u in the recovery map!\\n\",\n\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t     dlm->reco.dead_node);\n\n\t \n\t \n\tdlm_begin_recovery(dlm);\n\n\tspin_unlock(&dlm->spinlock);\n\n\tif (dlm->reco.new_master == dlm->node_num)\n\t\tgoto master_here;\n\n\tif (dlm->reco.new_master == O2NM_INVALID_NODE_NUM) {\n\t\t \n\t\tret = dlm_pick_recovery_master(dlm);\n\t\tif (!ret) {\n\t\t\t \n\t\t\tgoto master_here;\n\t\t}\n\t\tmlog(0, \"another node will master this recovery session.\\n\");\n\t}\n\n\tdlm_print_recovery_master(dlm);\n\n\t \n\tdlm_end_recovery(dlm);\n\n\t \n\treturn 0;\n\nmaster_here:\n\tdlm_print_recovery_master(dlm);\n\n\tstatus = dlm_remaster_locks(dlm, dlm->reco.dead_node);\n\tif (status < 0) {\n\t\t \n\t\tmlog(ML_ERROR, \"%s: Error %d remastering locks for node %u, \"\n\t\t     \"retrying.\\n\", dlm->name, status, dlm->reco.dead_node);\n\t\t \n\t\tmsleep(100);\n\t} else {\n\t\t \n\t\tmlog(0, \"DONE mastering recovery of %s:%u here(this=%u)!\\n\",\n\t\t     dlm->name, dlm->reco.dead_node, dlm->node_num);\n\t\tspin_lock(&dlm->spinlock);\n\t\t__dlm_reset_recovery(dlm);\n\t\tdlm->reco.state &= ~DLM_RECO_STATE_FINALIZE;\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\tdlm_end_recovery(dlm);\n\n\t \n\treturn -EAGAIN;\n}\n\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tint status = 0;\n\tstruct dlm_reco_node_data *ndata;\n\tint all_nodes_done;\n\tint destroy = 0;\n\tint pass = 0;\n\n\tdo {\n\t\t \n\t\tstatus = dlm_init_recovery_area(dlm, dead_node);\n\t\tif (status < 0) {\n\t\t\tmlog(ML_ERROR, \"%s: failed to alloc recovery area, \"\n\t\t\t     \"retrying\\n\", dlm->name);\n\t\t\tmsleep(1000);\n\t\t}\n\t} while (status != 0);\n\n\t \n\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\tBUG_ON(ndata->state != DLM_RECO_NODE_DATA_INIT);\n\t\tndata->state = DLM_RECO_NODE_DATA_REQUESTING;\n\n\t\tmlog(0, \"%s: Requesting lock info from node %u\\n\", dlm->name,\n\t\t     ndata->node_num);\n\n\t\tif (ndata->node_num == dlm->node_num) {\n\t\t\tndata->state = DLM_RECO_NODE_DATA_DONE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdo {\n\t\t\tstatus = dlm_request_all_locks(dlm, ndata->node_num,\n\t\t\t\t\t\t       dead_node);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tif (dlm_is_host_down(status)) {\n\t\t\t\t\t \n\t\t\t\t\tstatus = 0;\n\t\t\t\t\tndata->state = DLM_RECO_NODE_DATA_DEAD;\n\t\t\t\t\t \n\t\t\t\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t\t\t\t   dlm_is_node_dead(dlm,\n\t\t\t\t\t\t\t\tndata->node_num),\n\t\t\t\t\t\t\t   msecs_to_jiffies(1000));\n\t\t\t\t\tmlog(0, \"waited 1 sec for %u, \"\n\t\t\t\t\t     \"dead? %s\\n\", ndata->node_num,\n\t\t\t\t\t     dlm_is_node_dead(dlm, ndata->node_num) ?\n\t\t\t\t\t     \"yes\" : \"no\");\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tmlog(0, \"%s: node %u returned \"\n\t\t\t\t\t     \"%d during recovery, retrying \"\n\t\t\t\t\t     \"after a short wait\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num,\n\t\t\t\t\t     status);\n\t\t\t\t\tmsleep(100);\n\t\t\t\t}\n\t\t\t}\n\t\t} while (status != 0);\n\n\t\tspin_lock(&dlm_reco_state_lock);\n\t\tswitch (ndata->state) {\n\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\t\tBUG();\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\t\tmlog(0, \"node %u died after requesting \"\n\t\t\t\t     \"recovery info for node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\tndata->state = DLM_RECO_NODE_DATA_REQUESTED;\n\t\t\t\tmlog(0, \"now receiving recovery data from \"\n\t\t\t\t     \"node %u for dead node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\t\tmlog(0, \"already receiving recovery data from \"\n\t\t\t\t     \"node %u for dead node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\t\tmlog(0, \"already DONE receiving recovery data \"\n\t\t\t\t     \"from node %u for dead node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&dlm_reco_state_lock);\n\t}\n\n\tmlog(0, \"%s: Done requesting all lock info\\n\", dlm->name);\n\n\t \n\n\twhile (1) {\n\t\t \n\t\tall_nodes_done = 1;\n\t\tspin_lock(&dlm_reco_state_lock);\n\t\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\t\tmlog(0, \"checking recovery state of node %u\\n\",\n\t\t\t     ndata->node_num);\n\t\t\tswitch (ndata->state) {\n\t\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\t\tmlog(ML_ERROR, \"bad ndata state for \"\n\t\t\t\t\t     \"node %u: state=%d\\n\",\n\t\t\t\t\t     ndata->node_num, ndata->state);\n\t\t\t\t\tBUG();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\t\t\tmlog(0, \"node %u died after \"\n\t\t\t\t\t     \"requesting recovery info for \"\n\t\t\t\t\t     \"node %u\\n\", ndata->node_num,\n\t\t\t\t\t     dead_node);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\t\t\tmlog(0, \"%s: node %u still in state %s\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num,\n\t\t\t\t\t     ndata->state==DLM_RECO_NODE_DATA_RECEIVING ?\n\t\t\t\t\t     \"receiving\" : \"requested\");\n\t\t\t\t\tall_nodes_done = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\t\t\tmlog(0, \"%s: node %u state is done\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\t\t\tmlog(0, \"%s: node %u state is finalize\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&dlm_reco_state_lock);\n\n\t\tmlog(0, \"pass #%d, all_nodes_done?: %s\\n\", ++pass,\n\t\t     all_nodes_done?\"yes\":\"no\");\n\t\tif (all_nodes_done) {\n\t\t\tint ret;\n\n\t\t\t \n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tdlm->reco.state |= DLM_RECO_STATE_FINALIZE;\n\t\t\tspin_unlock(&dlm->spinlock);\n\n\t\t\t \n\t\t\tmlog(0, \"all nodes are done! send finalize\\n\");\n\t\t\tret = dlm_send_finalize_reco_message(dlm);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tdlm_finish_local_lockres_recovery(dlm, dead_node,\n\t\t\t\t\t\t\t  dlm->node_num);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tmlog(0, \"should be done with recovery!\\n\");\n\n\t\t\tmlog(0, \"finishing recovery of %s at %lu, \"\n\t\t\t     \"dead=%u, this=%u, new=%u\\n\", dlm->name,\n\t\t\t     jiffies, dlm->reco.dead_node,\n\t\t\t     dlm->node_num, dlm->reco.new_master);\n\t\t\tdestroy = 1;\n\t\t\tstatus = 0;\n\t\t\t \n\t\t\tdlm_kick_thread(dlm, NULL);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\twait_event_interruptible_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t\t kthread_should_stop(),\n\t\t\t\t\t msecs_to_jiffies(DLM_RECO_THREAD_TIMEOUT_MS));\n\n\t}\n\n\tif (destroy)\n\t\tdlm_destroy_recovery_area(dlm);\n\n\treturn status;\n}\n\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tint num=0;\n\tstruct dlm_reco_node_data *ndata;\n\n\tspin_lock(&dlm->spinlock);\n\tbitmap_copy(dlm->reco.node_map, dlm->domain_map, O2NM_MAX_NODES);\n\t \n\tspin_unlock(&dlm->spinlock);\n\n\twhile (1) {\n\t\tnum = find_next_bit (dlm->reco.node_map, O2NM_MAX_NODES, num);\n\t\tif (num >= O2NM_MAX_NODES) {\n\t\t\tbreak;\n\t\t}\n\t\tBUG_ON(num == dead_node);\n\n\t\tndata = kzalloc(sizeof(*ndata), GFP_NOFS);\n\t\tif (!ndata) {\n\t\t\tdlm_destroy_recovery_area(dlm);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tndata->node_num = num;\n\t\tndata->state = DLM_RECO_NODE_DATA_INIT;\n\t\tspin_lock(&dlm_reco_state_lock);\n\t\tlist_add_tail(&ndata->list, &dlm->reco.node_data);\n\t\tspin_unlock(&dlm_reco_state_lock);\n\t\tnum++;\n\t}\n\n\treturn 0;\n}\n\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_reco_node_data *ndata, *next;\n\tLIST_HEAD(tmplist);\n\n\tspin_lock(&dlm_reco_state_lock);\n\tlist_splice_init(&dlm->reco.node_data, &tmplist);\n\tspin_unlock(&dlm_reco_state_lock);\n\n\tlist_for_each_entry_safe(ndata, next, &tmplist, list) {\n\t\tlist_del_init(&ndata->list);\n\t\tkfree(ndata);\n\t}\n}\n\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm, u8 request_from,\n\t\t\t\t u8 dead_node)\n{\n\tstruct dlm_lock_request lr;\n\tint ret;\n\tint status;\n\n\tmlog(0, \"\\n\");\n\n\n\tmlog(0, \"dlm_request_all_locks: dead node is %u, sending request \"\n\t\t  \"to %u\\n\", dead_node, request_from);\n\n\tmemset(&lr, 0, sizeof(lr));\n\tlr.node_idx = dlm->node_num;\n\tlr.dead_node = dead_node;\n\n\t \n\tret = o2net_send_message(DLM_LOCK_REQUEST_MSG, dlm->key,\n\t\t\t\t &lr, sizeof(lr), request_from, &status);\n\n\t \n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"%s: Error %d send LOCK_REQUEST to node %u \"\n\t\t     \"to recover dead node %u\\n\", dlm->name, ret,\n\t\t     request_from, dead_node);\n\telse\n\t\tret = status;\n\t \n\t \n\treturn ret;\n\n}\n\nint dlm_request_all_locks_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_lock_request *lr = (struct dlm_lock_request *)msg->buf;\n\tchar *buf = NULL;\n\tstruct dlm_work_item *item = NULL;\n\n\tif (!dlm_grab(dlm))\n\t\treturn -EINVAL;\n\n\tif (lr->dead_node != dlm->reco.dead_node) {\n\t\tmlog(ML_ERROR, \"%s: node %u sent dead_node=%u, but local \"\n\t\t     \"dead_node is %u\\n\", dlm->name, lr->node_idx,\n\t\t     lr->dead_node, dlm->reco.dead_node);\n\t\tdlm_print_reco_node_status(dlm);\n\t\t \n\t\tdlm_put(dlm);\n\t\treturn -ENOMEM;\n\t}\n\tBUG_ON(lr->dead_node != dlm->reco.dead_node);\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (!item) {\n\t\tdlm_put(dlm);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tbuf = (char *) __get_free_page(GFP_NOFS);\n\tif (!buf) {\n\t\tkfree(item);\n\t\tdlm_put(dlm);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tdlm_grab(dlm);   \n\tdlm_init_work_item(dlm, item, dlm_request_all_locks_worker, buf);\n\titem->u.ral.reco_master = lr->node_idx;\n\titem->u.ral.dead_node = lr->dead_node;\n\tspin_lock(&dlm->work_lock);\n\tlist_add_tail(&item->list, &dlm->work_list);\n\tspin_unlock(&dlm->work_lock);\n\tqueue_work(dlm->dlm_worker, &dlm->dispatched_work);\n\n\tdlm_put(dlm);\n\treturn 0;\n}\n\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item, void *data)\n{\n\tstruct dlm_migratable_lockres *mres;\n\tstruct dlm_lock_resource *res;\n\tstruct dlm_ctxt *dlm;\n\tLIST_HEAD(resources);\n\tint ret;\n\tu8 dead_node, reco_master;\n\tint skip_all_done = 0;\n\n\tdlm = item->dlm;\n\tdead_node = item->u.ral.dead_node;\n\treco_master = item->u.ral.reco_master;\n\tmres = (struct dlm_migratable_lockres *)data;\n\n\tmlog(0, \"%s: recovery worker started, dead=%u, master=%u\\n\",\n\t     dlm->name, dead_node, reco_master);\n\n\tif (dead_node != dlm->reco.dead_node ||\n\t    reco_master != dlm->reco.new_master) {\n\t\t \n\t\tif (dlm->reco.new_master == O2NM_INVALID_NODE_NUM) {\n\t\t\tmlog(ML_NOTICE, \"%s: will not send recovery state, \"\n\t\t\t     \"recovery master %u died, thread=(dead=%u,mas=%u)\"\n\t\t\t     \" current=(dead=%u,mas=%u)\\n\", dlm->name,\n\t\t\t     reco_master, dead_node, reco_master,\n\t\t\t     dlm->reco.dead_node, dlm->reco.new_master);\n\t\t} else {\n\t\t\tmlog(ML_NOTICE, \"%s: reco state invalid: reco(dead=%u, \"\n\t\t\t     \"master=%u), request(dead=%u, master=%u)\\n\",\n\t\t\t     dlm->name, dlm->reco.dead_node,\n\t\t\t     dlm->reco.new_master, dead_node, reco_master);\n\t\t}\n\t\tgoto leave;\n\t}\n\n\t \n\tdlm_move_reco_locks_to_list(dlm, &resources, dead_node);\n\n\t \n\n\t \n\tlist_for_each_entry(res, &resources, recovering) {\n\t\tret = dlm_send_one_lockres(dlm, res, mres, reco_master,\n\t\t\t\t   \tDLM_MRES_RECOVERY);\n\t\tif (ret < 0) {\n\t\t\tmlog(ML_ERROR, \"%s: node %u went down while sending \"\n\t\t\t     \"recovery state for dead node %u, ret=%d\\n\", dlm->name,\n\t\t\t     reco_master, dead_node, ret);\n\t\t\tskip_all_done = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tspin_lock(&dlm->spinlock);\n\tlist_splice_init(&resources, &dlm->reco.resources);\n\tspin_unlock(&dlm->spinlock);\n\n\tif (!skip_all_done) {\n\t\tret = dlm_send_all_done_msg(dlm, dead_node, reco_master);\n\t\tif (ret < 0) {\n\t\t\tmlog(ML_ERROR, \"%s: node %u went down while sending \"\n\t\t\t     \"recovery all-done for dead node %u, ret=%d\\n\",\n\t\t\t     dlm->name, reco_master, dead_node, ret);\n\t\t}\n\t}\nleave:\n\tfree_page((unsigned long)data);\n}\n\n\nstatic int dlm_send_all_done_msg(struct dlm_ctxt *dlm, u8 dead_node, u8 send_to)\n{\n\tint ret, tmpret;\n\tstruct dlm_reco_data_done done_msg;\n\n\tmemset(&done_msg, 0, sizeof(done_msg));\n\tdone_msg.node_idx = dlm->node_num;\n\tdone_msg.dead_node = dead_node;\n\tmlog(0, \"sending DATA DONE message to %u, \"\n\t     \"my node=%u, dead node=%u\\n\", send_to, done_msg.node_idx,\n\t     done_msg.dead_node);\n\n\tret = o2net_send_message(DLM_RECO_DATA_DONE_MSG, dlm->key, &done_msg,\n\t\t\t\t sizeof(done_msg), send_to, &tmpret);\n\tif (ret < 0) {\n\t\tmlog(ML_ERROR, \"%s: Error %d send RECO_DATA_DONE to node %u \"\n\t\t     \"to recover dead node %u\\n\", dlm->name, ret, send_to,\n\t\t     dead_node);\n\t\tif (!dlm_is_host_down(ret)) {\n\t\t\tBUG();\n\t\t}\n\t} else\n\t\tret = tmpret;\n\treturn ret;\n}\n\n\nint dlm_reco_data_done_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t       void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_reco_data_done *done = (struct dlm_reco_data_done *)msg->buf;\n\tstruct dlm_reco_node_data *ndata = NULL;\n\tint ret = -EINVAL;\n\n\tif (!dlm_grab(dlm))\n\t\treturn -EINVAL;\n\n\tmlog(0, \"got DATA DONE: dead_node=%u, reco.dead_node=%u, \"\n\t     \"node_idx=%u, this node=%u\\n\", done->dead_node,\n\t     dlm->reco.dead_node, done->node_idx, dlm->node_num);\n\n\tmlog_bug_on_msg((done->dead_node != dlm->reco.dead_node),\n\t\t\t\"Got DATA DONE: dead_node=%u, reco.dead_node=%u, \"\n\t\t\t\"node_idx=%u, this node=%u\\n\", done->dead_node,\n\t\t\tdlm->reco.dead_node, done->node_idx, dlm->node_num);\n\n\tspin_lock(&dlm_reco_state_lock);\n\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\tif (ndata->node_num != done->node_idx)\n\t\t\tcontinue;\n\n\t\tswitch (ndata->state) {\n\t\t\t \n\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\t\tmlog(ML_ERROR, \"bad ndata state for node %u:\"\n\t\t\t\t     \" state=%d\\n\", ndata->node_num,\n\t\t\t\t     ndata->state);\n\t\t\t\tBUG();\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\tmlog(0, \"node %u is DONE sending \"\n\t\t\t\t\t  \"recovery data!\\n\",\n\t\t\t\t\t  ndata->node_num);\n\n\t\t\t\tndata->state = DLM_RECO_NODE_DATA_DONE;\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&dlm_reco_state_lock);\n\n\t \n\tif (!ret)\n\t\tdlm_kick_recovery_thread(dlm);\n\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"failed to find recovery node data for node \"\n\t\t     \"%u\\n\", done->node_idx);\n\tdlm_put(dlm);\n\n\tmlog(0, \"leaving reco data done handler, ret=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list,\n\t\t\t\t       \tu8 dead_node)\n{\n\tstruct dlm_lock_resource *res, *next;\n\tstruct dlm_lock *lock;\n\n\tspin_lock(&dlm->spinlock);\n\tlist_for_each_entry_safe(res, next, &dlm->reco.resources, recovering) {\n\t\t \n\t\tif (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t res->lockname.len)) {\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t\t\tif (lock->ml.node == dead_node) {\n\t\t\t\t\tmlog(0, \"AHA! there was \"\n\t\t\t\t\t     \"a $RECOVERY lock for dead \"\n\t\t\t\t\t     \"node %u (%s)!\\n\",\n\t\t\t\t\t     dead_node, dlm->name);\n\t\t\t\t\tlist_del_init(&lock->list);\n\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\t \n\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (res->owner == dead_node) {\n\t\t\tmlog(0, \"found lockres owned by dead node while \"\n\t\t\t\t  \"doing recovery for node %u. sending it.\\n\",\n\t\t\t\t  dead_node);\n\t\t\tlist_move_tail(&res->recovering, list);\n\t\t} else if (res->owner == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\tmlog(0, \"found UNKNOWN owner while doing recovery \"\n\t\t\t\t  \"for node %u. sending it.\\n\", dead_node);\n\t\t\tlist_move_tail(&res->recovering, list);\n\t\t}\n\t}\n\tspin_unlock(&dlm->spinlock);\n}\n\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res)\n{\n\tint total_locks = 0;\n\tstruct list_head *iter, *queue = &res->granted;\n\tint i;\n\n\tfor (i=0; i<3; i++) {\n\t\tlist_for_each(iter, queue)\n\t\t\ttotal_locks++;\n\t\tqueue++;\n\t}\n\treturn total_locks;\n}\n\n\nstatic int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_migratable_lockres *mres,\n\t\t\t\t      u8 send_to,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      int total_locks)\n{\n\tu64 mig_cookie = be64_to_cpu(mres->mig_cookie);\n\tint mres_total_locks = be32_to_cpu(mres->total_locks);\n\tint ret = 0, status = 0;\n\tu8 orig_flags = mres->flags,\n\t   orig_master = mres->master;\n\n\tBUG_ON(mres->num_locks > DLM_MAX_MIGRATABLE_LOCKS);\n\tif (!mres->num_locks)\n\t\treturn 0;\n\n\t \n\torig_flags = mres->flags;\n\tBUG_ON(total_locks > mres_total_locks);\n\tif (total_locks == mres_total_locks)\n\t\tmres->flags |= DLM_MRES_ALL_DONE;\n\n\tmlog(0, \"%s:%.*s: sending mig lockres (%s) to %u\\n\",\n\t     dlm->name, res->lockname.len, res->lockname.name,\n\t     orig_flags & DLM_MRES_MIGRATION ? \"migration\" : \"recovery\",\n\t     send_to);\n\n\t \n\tret = o2net_send_message(DLM_MIG_LOCKRES_MSG, dlm->key, mres,\n\t\t\t\t struct_size(mres, ml, mres->num_locks),\n\t\t\t\t send_to, &status);\n\tif (ret < 0) {\n\t\t \n\t\tmlog(ML_ERROR, \"%s: res %.*s, Error %d send MIG_LOCKRES to \"\n\t\t     \"node %u (%s)\\n\", dlm->name, mres->lockname_len,\n\t\t     mres->lockname, ret, send_to,\n\t\t     (orig_flags & DLM_MRES_MIGRATION ?\n\t\t      \"migration\" : \"recovery\"));\n\t} else {\n\t\t \n\t\tret = status;\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmlog(ML_ERROR, \"node %u told me to kill \"\n\t\t\t\t     \"myself!\\n\", send_to);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tdlm_init_migratable_lockres(mres, res->lockname.name,\n\t\t\t\t    res->lockname.len, mres_total_locks,\n\t\t\t\t    mig_cookie, orig_flags, orig_master);\n\treturn ret;\n}\n\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master)\n{\n\t \n\tclear_page(mres);\n\tmres->lockname_len = namelen;\n\tmemcpy(mres->lockname, lockname, namelen);\n\tmres->num_locks = 0;\n\tmres->total_locks = cpu_to_be32(total_locks);\n\tmres->mig_cookie = cpu_to_be64(cookie);\n\tmres->flags = flags;\n\tmres->master = master;\n}\n\nstatic void dlm_prepare_lvb_for_migration(struct dlm_lock *lock,\n\t\t\t\t\t  struct dlm_migratable_lockres *mres,\n\t\t\t\t\t  int queue)\n{\n\tif (!lock->lksb)\n\t       return;\n\n\t \n\tif (queue == DLM_BLOCKED_LIST)\n\t\treturn;\n\n\t \n\tif (lock->ml.type != LKM_EXMODE && lock->ml.type != LKM_PRMODE)\n\t\treturn;\n\n\tif (dlm_lvb_is_empty(mres->lvb)) {\n\t\tmemcpy(mres->lvb, lock->lksb->lvb, DLM_LVB_LEN);\n\t\treturn;\n\t}\n\n\t \n\tif (!memcmp(mres->lvb, lock->lksb->lvb, DLM_LVB_LEN))\n\t\treturn;\n\n\tmlog(ML_ERROR, \"Mismatched lvb in lock cookie=%u:%llu, name=%.*s, \"\n\t     \"node=%u\\n\",\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t     lock->lockres->lockname.len, lock->lockres->lockname.name,\n\t     lock->ml.node);\n\tdlm_print_one_lock_resource(lock->lockres);\n\tBUG();\n}\n\n \nstatic int dlm_add_lock_to_array(struct dlm_lock *lock,\n\t\t\t\t struct dlm_migratable_lockres *mres, int queue)\n{\n\tstruct dlm_migratable_lock *ml;\n\tint lock_num = mres->num_locks;\n\n\tml = &(mres->ml[lock_num]);\n\tml->cookie = lock->ml.cookie;\n\tml->type = lock->ml.type;\n\tml->convert_type = lock->ml.convert_type;\n\tml->highest_blocked = lock->ml.highest_blocked;\n\tml->list = queue;\n\tif (lock->lksb) {\n\t\tml->flags = lock->lksb->flags;\n\t\tdlm_prepare_lvb_for_migration(lock, mres, queue);\n\t}\n\tml->node = lock->ml.node;\n\tmres->num_locks++;\n\t \n\tif (mres->num_locks == DLM_MAX_MIGRATABLE_LOCKS)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void dlm_add_dummy_lock(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_migratable_lockres *mres)\n{\n\tstruct dlm_lock dummy;\n\tmemset(&dummy, 0, sizeof(dummy));\n\tdummy.ml.cookie = 0;\n\tdummy.ml.type = LKM_IVMODE;\n\tdummy.ml.convert_type = LKM_IVMODE;\n\tdummy.ml.highest_blocked = LKM_IVMODE;\n\tdummy.lksb = NULL;\n\tdummy.ml.node = dlm->node_num;\n\tdlm_add_lock_to_array(&dummy, mres, DLM_BLOCKED_LIST);\n}\n\nstatic inline int dlm_is_dummy_lock(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lock *ml,\n\t\t\t\t    u8 *nodenum)\n{\n\tif (unlikely(ml->cookie == 0 &&\n\t    ml->type == LKM_IVMODE &&\n\t    ml->convert_type == LKM_IVMODE &&\n\t    ml->highest_blocked == LKM_IVMODE &&\n\t    ml->list == DLM_BLOCKED_LIST)) {\n\t\t*nodenum = ml->node;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint dlm_send_one_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t struct dlm_migratable_lockres *mres,\n\t\t\t u8 send_to, u8 flags)\n{\n\tstruct list_head *queue;\n\tint total_locks, i;\n\tu64 mig_cookie = 0;\n\tstruct dlm_lock *lock;\n\tint ret = 0;\n\n\tBUG_ON(!(flags & (DLM_MRES_RECOVERY|DLM_MRES_MIGRATION)));\n\n\tmlog(0, \"sending to %u\\n\", send_to);\n\n\ttotal_locks = dlm_num_locks_in_lockres(res);\n\tif (total_locks > DLM_MAX_MIGRATABLE_LOCKS) {\n\t\t \n\t\tmlog(0, \"argh.  lockres has %d locks.  this will \"\n\t\t\t  \"require more than one network packet to \"\n\t\t\t  \"migrate\\n\", total_locks);\n\t\tmig_cookie = dlm_get_next_mig_cookie();\n\t}\n\n\tdlm_init_migratable_lockres(mres, res->lockname.name,\n\t\t\t\t    res->lockname.len, total_locks,\n\t\t\t\t    mig_cookie, flags, res->owner);\n\n\ttotal_locks = 0;\n\tfor (i=DLM_GRANTED_LIST; i<=DLM_BLOCKED_LIST; i++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\t \n\t\t\ttotal_locks++;\n\t\t\tif (!dlm_add_lock_to_array(lock, mres, i))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tret = dlm_send_mig_lockres_msg(dlm, mres, send_to,\n\t\t\t\t\t\t       res, total_locks);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tif (total_locks == 0) {\n\t\t \n\t\tmlog(0, \"%s:%.*s: sending dummy lock to %u, %s\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     send_to, flags & DLM_MRES_RECOVERY ? \"recovery\" :\n\t\t     \"migration\");\n\t\tdlm_add_dummy_lock(dlm, mres);\n\t}\n\t \n\tret = dlm_send_mig_lockres_msg(dlm, mres, send_to, res, total_locks);\n\tif (ret < 0)\n\t\tgoto error;\n\treturn ret;\n\nerror:\n\tmlog(ML_ERROR, \"%s: dlm_send_mig_lockres_msg returned %d\\n\",\n\t     dlm->name, ret);\n\tif (!dlm_is_host_down(ret))\n\t\tBUG();\n\tmlog(0, \"%s: node %u went down while sending %s \"\n\t     \"lockres %.*s\\n\", dlm->name, send_to,\n\t     flags & DLM_MRES_RECOVERY ?  \"recovery\" : \"migration\",\n\t     res->lockname.len, res->lockname.name);\n\treturn ret;\n}\n\n\n\n \n \n\nint dlm_mig_lockres_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t    void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_migratable_lockres *mres =\n\t\t(struct dlm_migratable_lockres *)msg->buf;\n\tint ret = 0;\n\tu8 real_master;\n\tu8 extra_refs = 0;\n\tchar *buf = NULL;\n\tstruct dlm_work_item *item = NULL;\n\tstruct dlm_lock_resource *res = NULL;\n\tunsigned int hash;\n\n\tif (!dlm_grab(dlm))\n\t\treturn -EINVAL;\n\n\tif (!dlm_joined(dlm)) {\n\t\tmlog(ML_ERROR, \"Domain %s not joined! \"\n\t\t\t  \"lockres %.*s, master %u\\n\",\n\t\t\t  dlm->name, mres->lockname_len,\n\t\t\t  mres->lockname, mres->master);\n\t\tdlm_put(dlm);\n\t\treturn -EINVAL;\n\t}\n\n\tBUG_ON(!(mres->flags & (DLM_MRES_RECOVERY|DLM_MRES_MIGRATION)));\n\n\treal_master = mres->master;\n\tif (real_master == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t \n\t\tBUG_ON(!(mres->flags & DLM_MRES_RECOVERY));\n\t}\n\n\tmlog(0, \"%s message received from node %u\\n\",\n\t\t  (mres->flags & DLM_MRES_RECOVERY) ?\n\t\t  \"recovery\" : \"migration\", mres->master);\n\tif (mres->flags & DLM_MRES_ALL_DONE)\n\t\tmlog(0, \"all done flag.  all lockres data received!\\n\");\n\n\tret = -ENOMEM;\n\tbuf = kmalloc(be16_to_cpu(msg->data_len), GFP_NOFS);\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (!buf || !item)\n\t\tgoto leave;\n\n\t \n\thash = dlm_lockid_hash(mres->lockname, mres->lockname_len);\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres_full(dlm, mres->lockname, mres->lockname_len,\n\t\t\thash);\n\tif (res) {\n\t \t \n\t\t \n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tmlog(0, \"%s: node is attempting to migrate \"\n\t\t\t\t\"lockres %.*s, but marked as dropping \"\n\t\t\t\t\" ref!\\n\", dlm->name,\n\t\t\t\tmres->lockname_len, mres->lockname);\n\t\t\tret = -EINVAL;\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t\tgoto leave;\n\t\t}\n\n\t\tif (mres->flags & DLM_MRES_RECOVERY) {\n\t\t\tres->state |= DLM_LOCK_RES_RECOVERING;\n\t\t} else {\n\t\t\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\t\t\t \n\t\t\t\tmlog(0, \"lock %.*s is already migrating\\n\",\n\t\t\t\t\t  mres->lockname_len,\n\t\t\t\t\t  mres->lockname);\n\t\t\t} else if (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\t\t\t \n\t\t\t\tmlog(ML_ERROR, \"node is attempting to migrate \"\n\t\t\t\t     \"lock %.*s, but marked as recovering!\\n\",\n\t\t\t\t     mres->lockname_len, mres->lockname);\n\t\t\t\tret = -EFAULT;\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\t\tdlm_lockres_put(res);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tres->state |= DLM_LOCK_RES_MIGRATING;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t} else {\n\t\tspin_unlock(&dlm->spinlock);\n\t\t \n\t\tres = dlm_new_lockres(dlm, mres->lockname, mres->lockname_len);\n\t\tif (!res)\n\t\t\tgoto leave;\n\n\t\t \n\t\tdlm_lockres_get(res);\n\n\t\t \n\t\tif (mres->flags & DLM_MRES_RECOVERY)\n\t\t\tres->state |= DLM_LOCK_RES_RECOVERING;\n\t\telse\n\t\t\tres->state |= DLM_LOCK_RES_MIGRATING;\n\n\t\tspin_lock(&dlm->spinlock);\n\t\t__dlm_insert_lockres(dlm, res);\n\t\tspin_unlock(&dlm->spinlock);\n\n\t\t \n\t\tdlm_lockres_get(res);\n\n\t\t \n\t\textra_refs++;\n\n\t\t \n\t\tspin_lock(&res->spinlock);\n\t\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\t\tspin_unlock(&res->spinlock);\n\t\twake_up(&res->wq);\n\t}\n\n\t \n\tret = 0;\n\tspin_lock(&res->spinlock);\n\t \n\tdlm_lockres_grab_inflight_ref(dlm, res);\n\tif (mres->master == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t \n\t\tBUG_ON(!(mres->flags & DLM_MRES_RECOVERY));\n\t\tmlog(0, \"recovery has passed me a lockres with an \"\n\t\t\t  \"unknown owner.. will need to requery: \"\n\t\t\t  \"%.*s\\n\", mres->lockname_len, mres->lockname);\n\t} else {\n\t\t \n\t\tdlm_change_lockres_owner(dlm, res, dlm->node_num);\n\t}\n\tspin_unlock(&res->spinlock);\n\n\t \n\tdlm_grab(dlm);   \n\tmemcpy(buf, msg->buf, be16_to_cpu(msg->data_len));   \n\tdlm_init_work_item(dlm, item, dlm_mig_lockres_worker, buf);\n\titem->u.ml.lockres = res;  \n\titem->u.ml.real_master = real_master;\n\titem->u.ml.extra_ref = extra_refs;\n\tspin_lock(&dlm->work_lock);\n\tlist_add_tail(&item->list, &dlm->work_list);\n\tspin_unlock(&dlm->work_lock);\n\tqueue_work(dlm->dlm_worker, &dlm->dispatched_work);\n\nleave:\n\t \n\tif (extra_refs)\n\t\tdlm_lockres_put(res);\n\n\tdlm_put(dlm);\n\tif (ret < 0) {\n\t\tkfree(buf);\n\t\tkfree(item);\n\t\tmlog_errno(ret);\n\t}\n\n\treturn ret;\n}\n\n\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data)\n{\n\tstruct dlm_ctxt *dlm;\n\tstruct dlm_migratable_lockres *mres;\n\tint ret = 0;\n\tstruct dlm_lock_resource *res;\n\tu8 real_master;\n\tu8 extra_ref;\n\n\tdlm = item->dlm;\n\tmres = (struct dlm_migratable_lockres *)data;\n\n\tres = item->u.ml.lockres;\n\treal_master = item->u.ml.real_master;\n\textra_ref = item->u.ml.extra_ref;\n\n\tif (real_master == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t \nagain:\n\t\tret = dlm_lockres_master_requery(dlm, res, &real_master);\n\t\tif (ret < 0) {\n\t\t\tmlog(0, \"dlm_lockres_master_requery ret=%d\\n\",\n\t\t\t\t  ret);\n\t\t\tgoto again;\n\t\t}\n\t\tif (real_master == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\tmlog(0, \"lockres %.*s not claimed.  \"\n\t\t\t\t   \"this node will take it.\\n\",\n\t\t\t\t   res->lockname.len, res->lockname.name);\n\t\t} else {\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_drop_inflight_ref(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tmlog(0, \"master needs to respond to sender \"\n\t\t\t\t  \"that node %u still owns %.*s\\n\",\n\t\t\t\t  real_master, res->lockname.len,\n\t\t\t\t  res->lockname.name);\n\t\t\t \n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\tret = dlm_process_recovery_data(dlm, res, mres);\n\tif (ret < 0)\n\t\tmlog(0, \"dlm_process_recovery_data returned  %d\\n\", ret);\n\telse\n\t\tmlog(0, \"dlm_process_recovery_data succeeded\\n\");\n\n\tif ((mres->flags & (DLM_MRES_MIGRATION|DLM_MRES_ALL_DONE)) ==\n\t                   (DLM_MRES_MIGRATION|DLM_MRES_ALL_DONE)) {\n\t\tret = dlm_finish_migration(dlm, res, mres->master);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\nleave:\n\t \n\tif (res) {\n\t\tif (extra_ref)\n\t\t\tdlm_lockres_put(res);\n\t\tdlm_lockres_put(res);\n\t}\n\tkfree(data);\n}\n\n\n\nstatic int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master)\n{\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint ret = 0;\n\n\t*real_master = DLM_LOCK_RES_OWNER_UNKNOWN;\n\n\t \n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\t \n\t\tif (nodenum == dlm->node_num)\n\t\t\tcontinue;\n\t\tret = dlm_do_master_requery(dlm, res, nodenum, real_master);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tif (!dlm_is_host_down(ret))\n\t\t\t\tBUG();\n\t\t\t \n\t\t}\n\t\tif (*real_master != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\tmlog(0, \"lock master is %u\\n\", *real_master);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint dlm_do_master_requery(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t  u8 nodenum, u8 *real_master)\n{\n\tint ret;\n\tstruct dlm_master_requery req;\n\tint status = DLM_LOCK_RES_OWNER_UNKNOWN;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.node_idx = dlm->node_num;\n\treq.namelen = res->lockname.len;\n\tmemcpy(req.name, res->lockname.name, res->lockname.len);\n\nresend:\n\tret = o2net_send_message(DLM_MASTER_REQUERY_MSG, dlm->key,\n\t\t\t\t &req, sizeof(req), nodenum, &status);\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t     \"0x%x) to node %u\\n\", ret, DLM_MASTER_REQUERY_MSG,\n\t\t     dlm->key, nodenum);\n\telse if (status == -ENOMEM) {\n\t\tmlog_errno(status);\n\t\tmsleep(50);\n\t\tgoto resend;\n\t} else {\n\t\tBUG_ON(status < 0);\n\t\tBUG_ON(status > DLM_LOCK_RES_OWNER_UNKNOWN);\n\t\t*real_master = (u8) (status & 0xff);\n\t\tmlog(0, \"node %u responded to master requery with %u\\n\",\n\t\t\t  nodenum, *real_master);\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\n\n \nint dlm_master_requery_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t       void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_master_requery *req = (struct dlm_master_requery *)msg->buf;\n\tstruct dlm_lock_resource *res = NULL;\n\tunsigned int hash;\n\tint master = DLM_LOCK_RES_OWNER_UNKNOWN;\n\tu32 flags = DLM_ASSERT_MASTER_REQUERY;\n\tint dispatched = 0;\n\n\tif (!dlm_grab(dlm)) {\n\t\t \n\t\treturn master;\n\t}\n\n\thash = dlm_lockid_hash(req->name, req->namelen);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, req->name, req->namelen, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tmaster = res->owner;\n\t\tif (master == dlm->node_num) {\n\t\t\tint ret = dlm_dispatch_assert_master(dlm, res,\n\t\t\t\t\t\t\t     0, 0, flags);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tdlm_lockres_put(res);\n\t\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\t\tdlm_put(dlm);\n\t\t\t\t \n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\tdispatched = 1;\n\t\t\t\t__dlm_lockres_grab_inflight_worker(dlm, res);\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t}\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\tif (!dispatched)\n\t\tdlm_put(dlm);\n\treturn master;\n}\n\nstatic inline struct list_head *\ndlm_list_num_to_pointer(struct dlm_lock_resource *res, int list_num)\n{\n\tstruct list_head *ret;\n\tBUG_ON(list_num < 0);\n\tBUG_ON(list_num > 2);\n\tret = &(res->granted);\n\tret += list_num;\n\treturn ret;\n}\n \n\n \n\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres)\n{\n\tstruct dlm_migratable_lock *ml;\n\tstruct list_head *queue, *iter;\n\tstruct list_head *tmpq = NULL;\n\tstruct dlm_lock *newlock = NULL;\n\tstruct dlm_lockstatus *lksb = NULL;\n\tint ret = 0;\n\tint i, j, bad;\n\tstruct dlm_lock *lock;\n\tu8 from = O2NM_MAX_NODES;\n\t__be64 c;\n\n\tmlog(0, \"running %d locks for this lockres\\n\", mres->num_locks);\n\tfor (i=0; i<mres->num_locks; i++) {\n\t\tml = &(mres->ml[i]);\n\n\t\tif (dlm_is_dummy_lock(dlm, ml, &from)) {\n\t\t\t \n\t\t\tBUG_ON(mres->num_locks != 1);\n\t\t\tmlog(0, \"%s:%.*s: dummy lock for %u\\n\",\n\t\t\t     dlm->name, mres->lockname_len, mres->lockname,\n\t\t\t     from);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, from);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tbreak;\n\t\t}\n\t\tBUG_ON(ml->highest_blocked != LKM_IVMODE);\n\t\tnewlock = NULL;\n\t\tlksb = NULL;\n\n\t\tqueue = dlm_list_num_to_pointer(res, ml->list);\n\t\ttmpq = NULL;\n\n\t\t \n\t\tif (ml->node == dlm->node_num) {\n\t\t\t \n\t\t\tBUG_ON(!(mres->flags & DLM_MRES_MIGRATION));\n\n\t\t\tlock = NULL;\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tfor (j = DLM_GRANTED_LIST; j <= DLM_BLOCKED_LIST; j++) {\n\t\t\t\ttmpq = dlm_list_idx_to_ptr(res, j);\n\t\t\t\tlist_for_each(iter, tmpq) {\n\t\t\t\t\tlock = list_entry(iter,\n\t\t\t\t\t\t  struct dlm_lock, list);\n\t\t\t\t\tif (lock->ml.cookie == ml->cookie)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tlock = NULL;\n\t\t\t\t}\n\t\t\t\tif (lock)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!lock) {\n\t\t\t\tc = ml->cookie;\n\t\t\t\tmlog(ML_ERROR, \"Could not find local lock \"\n\t\t\t\t\t       \"with cookie %u:%llu, node %u, \"\n\t\t\t\t\t       \"list %u, flags 0x%x, type %d, \"\n\t\t\t\t\t       \"conv %d, highest blocked %d\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     ml->node, ml->list, ml->flags, ml->type,\n\t\t\t\t     ml->convert_type, ml->highest_blocked);\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tBUG();\n\t\t\t}\n\n\t\t\tif (lock->ml.node != ml->node) {\n\t\t\t\tc = lock->ml.cookie;\n\t\t\t\tmlog(ML_ERROR, \"Mismatched node# in lock \"\n\t\t\t\t     \"cookie %u:%llu, name %.*s, node %u\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     res->lockname.len, res->lockname.name,\n\t\t\t\t     lock->ml.node);\n\t\t\t\tc = ml->cookie;\n\t\t\t\tmlog(ML_ERROR, \"Migrate lock cookie %u:%llu, \"\n\t\t\t\t     \"node %u, list %u, flags 0x%x, type %d, \"\n\t\t\t\t     \"conv %d, highest blocked %d\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     ml->node, ml->list, ml->flags, ml->type,\n\t\t\t\t     ml->convert_type, ml->highest_blocked);\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tBUG();\n\t\t\t}\n\n\t\t\tif (tmpq != queue) {\n\t\t\t\tc = ml->cookie;\n\t\t\t\tmlog(0, \"Lock cookie %u:%llu was on list %u \"\n\t\t\t\t     \"instead of list %u for %.*s\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     j, ml->list, res->lockname.len,\n\t\t\t\t     res->lockname.name);\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\n\t\t\t \n\t\t\t \n\t\t\tlist_move_tail(&lock->list, queue);\n\t\t\tspin_unlock(&res->spinlock);\n\n\t\t\tmlog(0, \"just reordered a local lock!\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tnewlock = dlm_new_lock(ml->type, ml->node,\n\t\t\t\t       be64_to_cpu(ml->cookie), NULL);\n\t\tif (!newlock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto leave;\n\t\t}\n\t\tlksb = newlock->lksb;\n\t\tdlm_lock_attach_lockres(newlock, res);\n\n\t\tif (ml->convert_type != LKM_IVMODE) {\n\t\t\tBUG_ON(queue != &res->converting);\n\t\t\tnewlock->ml.convert_type = ml->convert_type;\n\t\t}\n\t\tlksb->flags |= (ml->flags &\n\t\t\t\t(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB));\n\n\t\tif (ml->type == LKM_NLMODE)\n\t\t\tgoto skip_lvb;\n\n\t\t \n\t\tif (ml->list == DLM_BLOCKED_LIST)\n\t\t\tgoto skip_lvb;\n\n\t\tif (!dlm_lvb_is_empty(mres->lvb)) {\n\t\t\tif (lksb->flags & DLM_LKSB_PUT_LVB) {\n\t\t\t\t \n\t\t\t\tmemcpy(lksb->lvb, mres->lvb, DLM_LVB_LEN);\n\t\t\t\t \n\t\t\t\tmemcpy(res->lvb, mres->lvb, DLM_LVB_LEN);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tBUG_ON(ml->type != LKM_EXMODE &&\n\t\t\t\t       ml->type != LKM_PRMODE);\n\t\t\t\tif (!dlm_lvb_is_empty(res->lvb) &&\n \t\t\t\t    (ml->type == LKM_EXMODE ||\n \t\t\t\t     memcmp(res->lvb, mres->lvb, DLM_LVB_LEN))) {\n \t\t\t\t\tint i;\n \t\t\t\t\tmlog(ML_ERROR, \"%s:%.*s: received bad \"\n \t\t\t\t\t     \"lvb! type=%d\\n\", dlm->name,\n \t\t\t\t\t     res->lockname.len,\n \t\t\t\t\t     res->lockname.name, ml->type);\n \t\t\t\t\tprintk(\"lockres lvb=[\");\n \t\t\t\t\tfor (i=0; i<DLM_LVB_LEN; i++)\n \t\t\t\t\t\tprintk(\"%02x\", res->lvb[i]);\n \t\t\t\t\tprintk(\"]\\nmigrated lvb=[\");\n \t\t\t\t\tfor (i=0; i<DLM_LVB_LEN; i++)\n \t\t\t\t\t\tprintk(\"%02x\", mres->lvb[i]);\n \t\t\t\t\tprintk(\"]\\n\");\n \t\t\t\t\tdlm_print_one_lock_resource(res);\n \t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tmemcpy(res->lvb, mres->lvb, DLM_LVB_LEN);\n\t\t\t}\n\t\t}\nskip_lvb:\n\n\t\t \n\t\tbad = 0;\n\t\tspin_lock(&res->spinlock);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.cookie == ml->cookie) {\n\t\t\t\tc = lock->ml.cookie;\n\t\t\t\tmlog(ML_ERROR, \"%s:%.*s: %u:%llu: lock already \"\n\t\t\t\t     \"exists on this lockres!\\n\", dlm->name,\n\t\t\t\t     res->lockname.len, res->lockname.name,\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)));\n\n\t\t\t\tmlog(ML_NOTICE, \"sent lock: type=%d, conv=%d, \"\n\t\t\t\t     \"node=%u, cookie=%u:%llu, queue=%d\\n\",\n\t      \t\t\t     ml->type, ml->convert_type, ml->node,\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(ml->cookie)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(ml->cookie)),\n\t\t\t\t     ml->list);\n\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tbad = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!bad) {\n\t\t\tdlm_lock_get(newlock);\n\t\t\tif (mres->flags & DLM_MRES_RECOVERY &&\n\t\t\t\t\tml->list == DLM_CONVERTING_LIST &&\n\t\t\t\t\tnewlock->ml.type >\n\t\t\t\t\tnewlock->ml.convert_type) {\n\t\t\t\t \n\t\t\t\tlist_add(&newlock->list, queue);\n\t\t\t} else\n\t\t\t\tlist_add_tail(&newlock->list, queue);\n\t\t\tmlog(0, \"%s:%.*s: added lock for node %u, \"\n\t\t\t     \"setting refmap bit\\n\", dlm->name,\n\t\t\t     res->lockname.len, res->lockname.name, ml->node);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, ml->node);\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\tmlog(0, \"done running all the locks\\n\");\n\nleave:\n\t \n\tspin_lock(&res->spinlock);\n\tdlm_lockres_drop_inflight_ref(dlm, res);\n\tspin_unlock(&res->spinlock);\n\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}\n\nvoid dlm_move_lockres_to_recovery_list(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res)\n{\n\tint i;\n\tstruct list_head *queue;\n\tstruct dlm_lock *lock, *next;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\tres->state |= DLM_LOCK_RES_RECOVERING;\n\tif (!list_empty(&res->recovering)) {\n\t\tmlog(0,\n\t\t     \"Recovering res %s:%.*s, is already on recovery list!\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\tlist_del_init(&res->recovering);\n\t\tdlm_lockres_put(res);\n\t}\n\t \n\tdlm_lockres_get(res);\n\tlist_add_tail(&res->recovering, &dlm->reco.resources);\n\n\t \n\tfor (i=DLM_BLOCKED_LIST; i>=DLM_GRANTED_LIST; i--) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry_safe(lock, next, queue, list) {\n\t\t\tdlm_lock_get(lock);\n\t\t\tif (lock->convert_pending) {\n\t\t\t\t \n\t\t\t\tmlog(0, \"node died with convert pending \"\n\t\t\t\t     \"on %.*s. move back to granted list.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_revert_pending_convert(res, lock);\n\t\t\t\tlock->convert_pending = 0;\n\t\t\t} else if (lock->lock_pending) {\n\t\t\t\t \n\t\t\t\tBUG_ON(i != DLM_BLOCKED_LIST);\n\t\t\t\tmlog(0, \"node died with lock pending \"\n\t\t\t\t     \"on %.*s. remove from blocked list and skip.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\t \n\t\t\t\tdlm_revert_pending_lock(res, lock);\n\t\t\t\tlock->lock_pending = 0;\n\t\t\t} else if (lock->unlock_pending) {\n\t\t\t\t \n\t\t\t\tBUG_ON(i != DLM_GRANTED_LIST);\n\t\t\t\tmlog(0, \"node died with unlock pending \"\n\t\t\t\t     \"on %.*s. remove from blocked list and skip.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_commit_pending_unlock(res, lock);\n\t\t\t\tlock->unlock_pending = 0;\n\t\t\t} else if (lock->cancel_pending) {\n\t\t\t\t \n\t\t\t\tBUG_ON(i != DLM_CONVERTING_LIST);\n\t\t\t\tmlog(0, \"node died with cancel pending \"\n\t\t\t\t     \"on %.*s. move back to granted list.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_commit_pending_cancel(res, lock);\n\t\t\t\tlock->cancel_pending = 0;\n\t\t\t}\n\t\t\tdlm_lock_put(lock);\n\t\t}\n\t}\n}\n\n\n\n \nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master)\n{\n\tint i;\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock_resource *res, *next;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_for_each_entry_safe(res, next, &dlm->reco.resources, recovering) {\n\t\tif (res->owner == dead_node) {\n\t\t\tmlog(0, \"%s: res %.*s, Changing owner from %u to %u\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     res->owner, new_master);\n\t\t\tlist_del_init(&res->recovering);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\t \n\t\t\tdlm_change_lockres_owner(dlm, res, new_master);\n\t\t\tres->state &= ~DLM_LOCK_RES_RECOVERING;\n\t\t\tif (__dlm_lockres_has_locks(res))\n\t\t\t\t__dlm_dirty_lockres(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\twake_up(&res->wq);\n\t\t\tdlm_lockres_put(res);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_lockres_hash(dlm, i);\n\t\thlist_for_each_entry(res, bucket, hash_node) {\n\t\t\tif (res->state & DLM_LOCK_RES_RECOVERY_WAITING) {\n\t\t\t\tspin_lock(&res->spinlock);\n\t\t\t\tres->state &= ~DLM_LOCK_RES_RECOVERY_WAITING;\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\twake_up(&res->wq);\n\t\t\t}\n\n\t\t\tif (!(res->state & DLM_LOCK_RES_RECOVERING))\n\t\t\t\tcontinue;\n\n\t\t\tif (res->owner != dead_node &&\n\t\t\t    res->owner != dlm->node_num)\n\t\t\t\tcontinue;\n\n\t\t\tif (!list_empty(&res->recovering)) {\n\t\t\t\tlist_del_init(&res->recovering);\n\t\t\t\tdlm_lockres_put(res);\n\t\t\t}\n\n\t\t\t \n\t\t\tmlog(0, \"%s: res %.*s, Changing owner from %u to %u\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     res->owner, new_master);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_change_lockres_owner(dlm, res, new_master);\n\t\t\tres->state &= ~DLM_LOCK_RES_RECOVERING;\n\t\t\tif (__dlm_lockres_has_locks(res))\n\t\t\t\t__dlm_dirty_lockres(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\twake_up(&res->wq);\n\t\t}\n\t}\n}\n\nstatic inline int dlm_lvb_needs_invalidation(struct dlm_lock *lock, int local)\n{\n\tif (local) {\n\t\tif (lock->ml.type != LKM_EXMODE &&\n\t\t    lock->ml.type != LKM_PRMODE)\n\t\t\treturn 1;\n\t} else if (lock->ml.type == LKM_EXMODE)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void dlm_revalidate_lvb(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_lock_resource *res, u8 dead_node)\n{\n\tstruct list_head *queue;\n\tstruct dlm_lock *lock;\n\tint blank_lvb = 0, local = 0;\n\tint i;\n\tu8 search_node;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tif (res->owner == dlm->node_num)\n\t\t \n\t\tsearch_node = dead_node;\n\telse {\n\t\t \n\t\tsearch_node = dlm->node_num;\n\t\tlocal = 1;   \n\t}\n\n\tfor (i=DLM_GRANTED_LIST; i<=DLM_CONVERTING_LIST; i++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.node == search_node) {\n\t\t\t\tif (dlm_lvb_needs_invalidation(lock, local)) {\n\t\t\t\t\t \n\t\t\t\t\tblank_lvb = 1;\n\t\t\t\t\tmemset(lock->lksb->lvb, 0, DLM_LVB_LEN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (blank_lvb) {\n\t\tmlog(0, \"clearing %.*s lvb, dead node %u had EX\\n\",\n\t\t     res->lockname.len, res->lockname.name, dead_node);\n\t\tmemset(res->lvb, 0, DLM_LVB_LEN);\n\t}\n}\n\nstatic void dlm_free_dead_locks(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res, u8 dead_node)\n{\n\tstruct dlm_lock *lock, *next;\n\tunsigned int freed = 0;\n\n\t \n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t \n\n\t \n\tlist_for_each_entry_safe(lock, next, &res->granted, list) {\n\t\tif (lock->ml.node == dead_node) {\n\t\t\tlist_del_init(&lock->list);\n\t\t\tdlm_lock_put(lock);\n\t\t\t \n\t\t\tdlm_lock_put(lock);\n\t\t\tfreed++;\n\t\t}\n\t}\n\tlist_for_each_entry_safe(lock, next, &res->converting, list) {\n\t\tif (lock->ml.node == dead_node) {\n\t\t\tlist_del_init(&lock->list);\n\t\t\tdlm_lock_put(lock);\n\t\t\t \n\t\t\tdlm_lock_put(lock);\n\t\t\tfreed++;\n\t\t}\n\t}\n\tlist_for_each_entry_safe(lock, next, &res->blocked, list) {\n\t\tif (lock->ml.node == dead_node) {\n\t\t\tlist_del_init(&lock->list);\n\t\t\tdlm_lock_put(lock);\n\t\t\t \n\t\t\tdlm_lock_put(lock);\n\t\t\tfreed++;\n\t\t}\n\t}\n\n\tif (freed) {\n\t\tmlog(0, \"%s:%.*s: freed %u locks for dead node %u, \"\n\t\t     \"dropping ref from lockres\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name, freed, dead_node);\n\t\tif(!test_bit(dead_node, res->refmap)) {\n\t\t\tmlog(ML_ERROR, \"%s:%.*s: freed %u locks for dead node %u, \"\n\t\t\t     \"but ref was not set\\n\", dlm->name,\n\t\t\t     res->lockname.len, res->lockname.name, freed, dead_node);\n\t\t\t__dlm_print_one_lock_resource(res);\n\t\t}\n\t\tres->state |= DLM_LOCK_RES_RECOVERY_WAITING;\n\t\tdlm_lockres_clear_refmap_bit(dlm, res, dead_node);\n\t} else if (test_bit(dead_node, res->refmap)) {\n\t\tmlog(0, \"%s:%.*s: dead node %u had a ref, but had \"\n\t\t     \"no locks and had not purged before dying\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name, dead_node);\n\t\tdlm_lockres_clear_refmap_bit(dlm, res, dead_node);\n\t}\n\n\t \n\t__dlm_dirty_lockres(dlm, res);\n}\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_lock_resource *res;\n\tint i;\n\tstruct hlist_head *bucket;\n\tstruct hlist_node *tmp;\n\tstruct dlm_lock *lock;\n\n\n\t \n\tdlm_clean_master_list(dlm, dead_node);\n\n\t \n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_lockres_hash(dlm, i);\n\t\thlist_for_each_entry_safe(res, tmp, bucket, hash_node) {\n \t\t\t \n\t\t\tif (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t\t res->lockname.len)) {\n\t\t\t\tspin_lock(&res->spinlock);\n\t\t\t\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t\t\t\tif (lock->ml.node == dead_node) {\n\t\t\t\t\t\tmlog(0, \"AHA! there was \"\n\t\t\t\t\t\t     \"a $RECOVERY lock for dead \"\n\t\t\t\t\t\t     \"node %u (%s)!\\n\",\n\t\t\t\t\t\t     dead_node, dlm->name);\n\t\t\t\t\t\tlist_del_init(&lock->list);\n\t\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\t\t \n\t\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ((res->owner == dead_node) &&\n\t\t\t\t\t\t\t(res->state & DLM_LOCK_RES_DROPPING_REF)) {\n\t\t\t\t\tdlm_lockres_get(res);\n\t\t\t\t\t__dlm_do_purge_lockres(dlm, res);\n\t\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\t\twake_up(&res->wq);\n\t\t\t\t\tdlm_lockres_put(res);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (res->owner == dlm->node_num)\n\t\t\t\t\tdlm_lockres_clear_refmap_bit(dlm, res, dead_node);\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_lock(&res->spinlock);\n\t\t\t \n\t\t\tdlm_revalidate_lvb(dlm, res, dead_node);\n\t\t\tif (res->owner == dead_node) {\n\t\t\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\t\t\tmlog(0, \"%s:%.*s: owned by \"\n\t\t\t\t\t\t\"dead node %u, this node was \"\n\t\t\t\t\t\t\"dropping its ref when master died. \"\n\t\t\t\t\t\t\"continue, purging the lockres.\\n\",\n\t\t\t\t\t\tdlm->name, res->lockname.len,\n\t\t\t\t\t\tres->lockname.name, dead_node);\n\t\t\t\t\tdlm_lockres_get(res);\n\t\t\t\t\t__dlm_do_purge_lockres(dlm, res);\n\t\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\t\twake_up(&res->wq);\n\t\t\t\t\tdlm_lockres_put(res);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdlm_move_lockres_to_recovery_list(dlm, res);\n\t\t\t} else if (res->owner == dlm->node_num) {\n\t\t\t\tdlm_free_dead_locks(dlm, res, dead_node);\n\t\t\t\t__dlm_lockres_calc_usage(dlm, res);\n\t\t\t} else if (res->owner == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t\tif (test_bit(dead_node, res->refmap)) {\n\t\t\t\t\tmlog(0, \"%s:%.*s: dead node %u had a ref, but had \"\n\t\t\t\t\t\t\"no locks and had not purged before dying\\n\",\n\t\t\t\t\t\tdlm->name, res->lockname.len,\n\t\t\t\t\t\tres->lockname.name, dead_node);\n\t\t\t\t\tdlm_lockres_clear_refmap_bit(dlm, res, dead_node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&res->spinlock);\n\t\t}\n\t}\n\n}\n\nstatic void __dlm_hb_node_down(struct dlm_ctxt *dlm, int idx)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tif (dlm->reco.new_master == idx) {\n\t\tmlog(0, \"%s: recovery master %d just died\\n\",\n\t\t     dlm->name, idx);\n\t\tif (dlm->reco.state & DLM_RECO_STATE_FINALIZE) {\n\t\t\t \n\t\t\tmlog(0, \"%s: dead master %d had reached \"\n\t\t\t     \"finalize1 state, clearing\\n\", dlm->name, idx);\n\t\t\tdlm->reco.state &= ~DLM_RECO_STATE_FINALIZE;\n\t\t\t__dlm_reset_recovery(dlm);\n\t\t}\n\t}\n\n\t \n\tif (dlm->joining_node == idx) {\n\t\tmlog(0, \"Clearing join state for node %u\\n\", idx);\n\t\t__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\n\t}\n\n\t \n\tif (!test_bit(idx, dlm->live_nodes_map)) {\n\t\tmlog(0, \"for domain %s, node %d is already dead. \"\n\t\t     \"another node likely did recovery already.\\n\",\n\t\t     dlm->name, idx);\n\t\treturn;\n\t}\n\n\t \n\tif (!test_bit(idx, dlm->domain_map)) {\n\t\t \n\t\tmlog(0, \"node %u already removed from domain!\\n\", idx);\n\t\treturn;\n\t}\n\n\tclear_bit(idx, dlm->live_nodes_map);\n\n\t \n\tif (!test_bit(idx, dlm->recovery_map))\n\t\tdlm_do_local_recovery_cleanup(dlm, idx);\n\n\t \n\tdlm_hb_event_notify_attached(dlm, idx, 0);\n\n\tmlog(0, \"node %u being removed from domain map!\\n\", idx);\n\tclear_bit(idx, dlm->domain_map);\n\tclear_bit(idx, dlm->exit_domain_map);\n\t \n\twake_up(&dlm->migration_wq);\n\n\tset_bit(idx, dlm->recovery_map);\n}\n\nvoid dlm_hb_node_down_cb(struct o2nm_node *node, int idx, void *data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\n\tif (!dlm_grab(dlm))\n\t\treturn;\n\n\t \n\tif (test_bit(idx, dlm->domain_map))\n\t\tdlm_fire_domain_eviction_callbacks(dlm, idx);\n\n\tspin_lock(&dlm->spinlock);\n\t__dlm_hb_node_down(dlm, idx);\n\tspin_unlock(&dlm->spinlock);\n\n\tdlm_put(dlm);\n}\n\nvoid dlm_hb_node_up_cb(struct o2nm_node *node, int idx, void *data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\n\tif (!dlm_grab(dlm))\n\t\treturn;\n\n\tspin_lock(&dlm->spinlock);\n\tset_bit(idx, dlm->live_nodes_map);\n\t \n\tspin_unlock(&dlm->spinlock);\n\n\tdlm_put(dlm);\n}\n\nstatic void dlm_reco_ast(void *astdata)\n{\n\tstruct dlm_ctxt *dlm = astdata;\n\tmlog(0, \"ast for recovery lock fired!, this=%u, dlm=%s\\n\",\n\t     dlm->node_num, dlm->name);\n}\nstatic void dlm_reco_bast(void *astdata, int blocked_type)\n{\n\tstruct dlm_ctxt *dlm = astdata;\n\tmlog(0, \"bast for recovery lock fired!, this=%u, dlm=%s\\n\",\n\t     dlm->node_num, dlm->name);\n}\nstatic void dlm_reco_unlock_ast(void *astdata, enum dlm_status st)\n{\n\tmlog(0, \"unlockast for recovery lock fired!\\n\");\n}\n\n \nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm)\n{\n\tenum dlm_status ret;\n\tstruct dlm_lockstatus lksb;\n\tint status = -EINVAL;\n\n\tmlog(0, \"starting recovery of %s at %lu, dead=%u, this=%u\\n\",\n\t     dlm->name, jiffies, dlm->reco.dead_node, dlm->node_num);\nagain:\n\tmemset(&lksb, 0, sizeof(lksb));\n\n\tret = dlmlock(dlm, LKM_EXMODE, &lksb, LKM_NOQUEUE|LKM_RECOVERY,\n\t\t      DLM_RECOVERY_LOCK_NAME, DLM_RECOVERY_LOCK_NAME_LEN,\n\t\t      dlm_reco_ast, dlm, dlm_reco_bast);\n\n\tmlog(0, \"%s: dlmlock($RECOVERY) returned %d, lksb=%d\\n\",\n\t     dlm->name, ret, lksb.status);\n\n\tif (ret == DLM_NORMAL) {\n\t\tmlog(0, \"dlm=%s dlmlock says I got it (this=%u)\\n\",\n\t\t     dlm->name, dlm->node_num);\n\n\t\t \n\t\tif (dlm_reco_master_ready(dlm)) {\n\t\t\tmlog(0, \"%s: got reco EX lock, but %u will \"\n\t\t\t     \"do the recovery\\n\", dlm->name,\n\t\t\t     dlm->reco.new_master);\n\t\t\tstatus = -EEXIST;\n\t\t} else {\n\t\t\tstatus = 0;\n\n\t\t\t \n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tif (dlm->reco.dead_node == O2NM_INVALID_NODE_NUM) {\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tmlog(0, \"%s: got reco EX lock, but \"\n\t\t\t\t     \"node got recovered already\\n\", dlm->name);\n\t\t\t\tif (dlm->reco.new_master != O2NM_INVALID_NODE_NUM) {\n\t\t\t\t\tmlog(ML_ERROR, \"%s: new master is %u \"\n\t\t\t\t\t     \"but no dead node!\\n\",\n\t\t\t\t\t     dlm->name, dlm->reco.new_master);\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t}\n\n\t\t \n\t\tif (!status) {\n\t\t\tmlog(0, \"%s: dead=%u, this=%u, sending \"\n\t\t\t     \"begin_reco now\\n\", dlm->name,\n\t\t\t     dlm->reco.dead_node, dlm->node_num);\n\t\t\tstatus = dlm_send_begin_reco_message(dlm,\n\t\t\t\t      dlm->reco.dead_node);\n\t\t\t \n\t\t\tBUG_ON(status);\n\n\t\t\t \n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tdlm_set_reco_master(dlm, dlm->node_num);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t}\n\n\t\t \n\t\tret = dlmunlock(dlm, &lksb, 0, dlm_reco_unlock_ast, dlm);\n\t\tif (ret == DLM_DENIED) {\n\t\t\tmlog(0, \"got DLM_DENIED, trying LKM_CANCEL\\n\");\n\t\t\tret = dlmunlock(dlm, &lksb, LKM_CANCEL, dlm_reco_unlock_ast, dlm);\n\t\t}\n\t\tif (ret != DLM_NORMAL) {\n\t\t\t \n\t\t\tmlog(ML_ERROR, \"dlmunlock returned %d\\n\", ret);\n\t\t}\n\t} else if (ret == DLM_NOTQUEUED) {\n\t\tmlog(0, \"dlm=%s dlmlock says another node got it (this=%u)\\n\",\n\t\t     dlm->name, dlm->node_num);\n\t\t \n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t\t dlm_reco_master_ready(dlm),\n\t\t\t\t\t msecs_to_jiffies(1000));\n\t\tif (!dlm_reco_master_ready(dlm)) {\n\t\t\tmlog(0, \"%s: reco master taking awhile\\n\",\n\t\t\t     dlm->name);\n\t\t\tgoto again;\n\t\t}\n\t\t \n\t\tmlog(0, \"%s: reco master %u is ready to recover %u\\n\",\n\t\t     dlm->name, dlm->reco.new_master, dlm->reco.dead_node);\n\t\tstatus = -EEXIST;\n\t} else if (ret == DLM_RECOVERING) {\n\t\tmlog(0, \"dlm=%s dlmlock says master node died (this=%u)\\n\",\n\t\t     dlm->name, dlm->node_num);\n\t\tgoto again;\n\t} else {\n\t\tstruct dlm_lock_resource *res;\n\n\t\t \n\t\tmlog(ML_ERROR, \"%s: got %s from dlmlock($RECOVERY), \"\n\t\t     \"lksb.status=%s\\n\", dlm->name, dlm_errname(ret),\n\t\t     dlm_errname(lksb.status));\n\t\tres = dlm_lookup_lockres(dlm, DLM_RECOVERY_LOCK_NAME,\n\t\t\t\t\t DLM_RECOVERY_LOCK_NAME_LEN);\n\t\tif (res) {\n\t\t\tdlm_print_one_lock_resource(res);\n\t\t\tdlm_lockres_put(res);\n\t\t} else {\n\t\t\tmlog(ML_ERROR, \"recovery lock not found\\n\");\n\t\t}\n\t\tBUG();\n\t}\n\n\treturn status;\n}\n\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_begin_reco br;\n\tint ret = 0;\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint status;\n\n\tmlog(0, \"%s: dead node is %u\\n\", dlm->name, dead_node);\n\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\n\tclear_bit(dead_node, iter.node_map);\n\n\tmemset(&br, 0, sizeof(br));\n\tbr.node_idx = dlm->node_num;\n\tbr.dead_node = dead_node;\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\tret = 0;\n\t\tif (nodenum == dead_node) {\n\t\t\tmlog(0, \"not sending begin reco to dead node \"\n\t\t\t\t  \"%u\\n\", dead_node);\n\t\t\tcontinue;\n\t\t}\n\t\tif (nodenum == dlm->node_num) {\n\t\t\tmlog(0, \"not sending begin reco to self\\n\");\n\t\t\tcontinue;\n\t\t}\nretry:\n\t\tmlog(0, \"attempting to send begin reco msg to %d\\n\",\n\t\t\t  nodenum);\n\t\tret = o2net_send_message(DLM_BEGIN_RECO_MSG, dlm->key,\n\t\t\t\t\t &br, sizeof(br), nodenum, &status);\n\t\t \n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (dlm_is_host_down(ret)) {\n\t\t\t \n\t\t\tmlog(ML_NOTICE, \"%s: node %u was down when sending \"\n\t\t\t     \"begin reco msg (%d)\\n\", dlm->name, nodenum, ret);\n\t\t\tret = 0;\n\t\t}\n\n\t\t \n\t\tif (ret == -EAGAIN || ret == EAGAIN) {\n\t\t\tmlog(0, \"%s: trying to start recovery of node \"\n\t\t\t     \"%u, but node %u is waiting for last recovery \"\n\t\t\t     \"to complete, backoff for a bit\\n\", dlm->name,\n\t\t\t     dead_node, nodenum);\n\t\t\tmsleep(100);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tstruct dlm_lock_resource *res;\n\n\t\t\t \n\t\t\tmlog_errno(ret);\n\t\t\tmlog(ML_ERROR, \"begin reco of dlm %s to node %u \"\n\t\t\t     \"returned %d\\n\", dlm->name, nodenum, ret);\n\t\t\tres = dlm_lookup_lockres(dlm, DLM_RECOVERY_LOCK_NAME,\n\t\t\t\t\t\t DLM_RECOVERY_LOCK_NAME_LEN);\n\t\t\tif (res) {\n\t\t\t\tdlm_print_one_lock_resource(res);\n\t\t\t\tdlm_lockres_put(res);\n\t\t\t} else {\n\t\t\t\tmlog(ML_ERROR, \"recovery lock not found\\n\");\n\t\t\t}\n\t\t\t \n\t\t\tmsleep(100);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint dlm_begin_reco_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t   void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_begin_reco *br = (struct dlm_begin_reco *)msg->buf;\n\n\t \n\tif (!dlm_grab(dlm))\n\t\treturn 0;\n\n\tspin_lock(&dlm->spinlock);\n\tif (dlm->reco.state & DLM_RECO_STATE_FINALIZE) {\n\t\tmlog(0, \"%s: node %u wants to recover node %u (%u:%u) \"\n\t\t     \"but this node is in finalize state, waiting on finalize2\\n\",\n\t\t     dlm->name, br->node_idx, br->dead_node,\n\t\t     dlm->reco.dead_node, dlm->reco.new_master);\n\t\tspin_unlock(&dlm->spinlock);\n\t\tdlm_put(dlm);\n\t\treturn -EAGAIN;\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\tmlog(0, \"%s: node %u wants to recover node %u (%u:%u)\\n\",\n\t     dlm->name, br->node_idx, br->dead_node,\n\t     dlm->reco.dead_node, dlm->reco.new_master);\n\n\tdlm_fire_domain_eviction_callbacks(dlm, br->dead_node);\n\n\tspin_lock(&dlm->spinlock);\n\tif (dlm->reco.new_master != O2NM_INVALID_NODE_NUM) {\n\t\tif (test_bit(dlm->reco.new_master, dlm->recovery_map)) {\n\t\t\tmlog(0, \"%s: new_master %u died, changing \"\n\t\t\t     \"to %u\\n\", dlm->name, dlm->reco.new_master,\n\t\t\t     br->node_idx);\n\t\t} else {\n\t\t\tmlog(0, \"%s: new_master %u NOT DEAD, changing \"\n\t\t\t     \"to %u\\n\", dlm->name, dlm->reco.new_master,\n\t\t\t     br->node_idx);\n\t\t\t \n\t\t}\n\t}\n\tif (dlm->reco.dead_node != O2NM_INVALID_NODE_NUM) {\n\t\tmlog(ML_NOTICE, \"%s: dead_node previously set to %u, \"\n\t\t     \"node %u changing it to %u\\n\", dlm->name,\n\t\t     dlm->reco.dead_node, br->node_idx, br->dead_node);\n\t}\n\tdlm_set_reco_master(dlm, br->node_idx);\n\tdlm_set_reco_dead_node(dlm, br->dead_node);\n\tif (!test_bit(br->dead_node, dlm->recovery_map)) {\n\t\tmlog(0, \"recovery master %u sees %u as dead, but this \"\n\t\t     \"node has not yet.  marking %u as dead\\n\",\n\t\t     br->node_idx, br->dead_node, br->dead_node);\n\t\tif (!test_bit(br->dead_node, dlm->domain_map) ||\n\t\t    !test_bit(br->dead_node, dlm->live_nodes_map))\n\t\t\tmlog(0, \"%u not in domain/live_nodes map \"\n\t\t\t     \"so setting it in reco map manually\\n\",\n\t\t\t     br->dead_node);\n\t\t \n\t\tset_bit(br->dead_node, dlm->domain_map);\n\t\tset_bit(br->dead_node, dlm->live_nodes_map);\n\t\t__dlm_hb_node_down(dlm, br->dead_node);\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\tdlm_kick_recovery_thread(dlm);\n\n\tmlog(0, \"%s: recovery started by node %u, for %u (%u:%u)\\n\",\n\t     dlm->name, br->node_idx, br->dead_node,\n\t     dlm->reco.dead_node, dlm->reco.new_master);\n\n\tdlm_put(dlm);\n\treturn 0;\n}\n\n#define DLM_FINALIZE_STAGE2  0x01\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm)\n{\n\tint ret = 0;\n\tstruct dlm_finalize_reco fr;\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint status;\n\tint stage = 1;\n\n\tmlog(0, \"finishing recovery for node %s:%u, \"\n\t     \"stage %d\\n\", dlm->name, dlm->reco.dead_node, stage);\n\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\nstage2:\n\tmemset(&fr, 0, sizeof(fr));\n\tfr.node_idx = dlm->node_num;\n\tfr.dead_node = dlm->reco.dead_node;\n\tif (stage == 2)\n\t\tfr.flags |= DLM_FINALIZE_STAGE2;\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\tif (nodenum == dlm->node_num)\n\t\t\tcontinue;\n\t\tret = o2net_send_message(DLM_FINALIZE_RECO_MSG, dlm->key,\n\t\t\t\t\t &fr, sizeof(fr), nodenum, &status);\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (ret < 0) {\n\t\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t\t     \"0x%x) to node %u\\n\", ret, DLM_FINALIZE_RECO_MSG,\n\t\t\t     dlm->key, nodenum);\n\t\t\tif (dlm_is_host_down(ret)) {\n\t\t\t\t \n\t\t\t\tmlog(ML_ERROR, \"node %u went down after this \"\n\t\t\t\t     \"node finished recovery.\\n\", nodenum);\n\t\t\t\tret = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (stage == 1) {\n\t\t \n\t\titer.curnode = -1;\n\t\tstage = 2;\n\t\tgoto stage2;\n\t}\n\n\treturn ret;\n}\n\nint dlm_finalize_reco_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t      void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_finalize_reco *fr = (struct dlm_finalize_reco *)msg->buf;\n\tint stage = 1;\n\n\t \n\tif (!dlm_grab(dlm))\n\t\treturn 0;\n\n\tif (fr->flags & DLM_FINALIZE_STAGE2)\n\t\tstage = 2;\n\n\tmlog(0, \"%s: node %u finalizing recovery stage%d of \"\n\t     \"node %u (%u:%u)\\n\", dlm->name, fr->node_idx, stage,\n\t     fr->dead_node, dlm->reco.dead_node, dlm->reco.new_master);\n\n\tspin_lock(&dlm->spinlock);\n\n\tif (dlm->reco.new_master != fr->node_idx) {\n\t\tmlog(ML_ERROR, \"node %u sent recovery finalize msg, but node \"\n\t\t     \"%u is supposed to be the new master, dead=%u\\n\",\n\t\t     fr->node_idx, dlm->reco.new_master, fr->dead_node);\n\t\tBUG();\n\t}\n\tif (dlm->reco.dead_node != fr->dead_node) {\n\t\tmlog(ML_ERROR, \"node %u sent recovery finalize msg for dead \"\n\t\t     \"node %u, but node %u is supposed to be dead\\n\",\n\t\t     fr->node_idx, fr->dead_node, dlm->reco.dead_node);\n\t\tBUG();\n\t}\n\n\tswitch (stage) {\n\t\tcase 1:\n\t\t\tdlm_finish_local_lockres_recovery(dlm, fr->dead_node, fr->node_idx);\n\t\t\tif (dlm->reco.state & DLM_RECO_STATE_FINALIZE) {\n\t\t\t\tmlog(ML_ERROR, \"%s: received finalize1 from \"\n\t\t\t\t     \"new master %u for dead node %u, but \"\n\t\t\t\t     \"this node has already received it!\\n\",\n\t\t\t\t     dlm->name, fr->node_idx, fr->dead_node);\n\t\t\t\tdlm_print_reco_node_status(dlm);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tdlm->reco.state |= DLM_RECO_STATE_FINALIZE;\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (!(dlm->reco.state & DLM_RECO_STATE_FINALIZE)) {\n\t\t\t\tmlog(ML_ERROR, \"%s: received finalize2 from \"\n\t\t\t\t     \"new master %u for dead node %u, but \"\n\t\t\t\t     \"this node did not have finalize1!\\n\",\n\t\t\t\t     dlm->name, fr->node_idx, fr->dead_node);\n\t\t\t\tdlm_print_reco_node_status(dlm);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tdlm->reco.state &= ~DLM_RECO_STATE_FINALIZE;\n\t\t\t__dlm_reset_recovery(dlm);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tdlm_kick_recovery_thread(dlm);\n\t\t\tbreak;\n\t}\n\n\tmlog(0, \"%s: recovery done, reco master was %u, dead now %u, master now %u\\n\",\n\t     dlm->name, fr->node_idx, dlm->reco.dead_node, dlm->reco.new_master);\n\n\tdlm_put(dlm);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}