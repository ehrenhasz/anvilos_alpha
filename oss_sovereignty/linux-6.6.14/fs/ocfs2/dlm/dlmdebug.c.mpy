{
  "module_name": "dlmdebug.c",
  "hash_id": "b9e0a301f309ffee36893c59c1c5ff518c17e513ad342fa81e3f49318487723d",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/dlm/dlmdebug.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/spinlock.h>\n#include <linux/debugfs.h>\n#include <linux/export.h>\n\n#include \"../cluster/heartbeat.h\"\n#include \"../cluster/nodemanager.h\"\n#include \"../cluster/tcp.h\"\n\n#include \"dlmapi.h\"\n#include \"dlmcommon.h\"\n#include \"dlmdomain.h\"\n#include \"dlmdebug.h\"\n\n#define MLOG_MASK_PREFIX ML_DLM\n#include \"../cluster/masklog.h\"\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tspin_lock(&res->spinlock);\n\t__dlm_print_one_lock_resource(res);\n\tspin_unlock(&res->spinlock);\n}\n\nstatic void dlm_print_lockres_refmap(struct dlm_lock_resource *res)\n{\n\tint bit;\n\tassert_spin_locked(&res->spinlock);\n\n\tprintk(\"  refmap nodes: [ \");\n\tbit = 0;\n\twhile (1) {\n\t\tbit = find_next_bit(res->refmap, O2NM_MAX_NODES, bit);\n\t\tif (bit >= O2NM_MAX_NODES)\n\t\t\tbreak;\n\t\tprintk(\"%u \", bit);\n\t\tbit++;\n\t}\n\tprintk(\"], inflight=%u\\n\", res->inflight_locks);\n}\n\nstatic void __dlm_print_lock(struct dlm_lock *lock)\n{\n\tspin_lock(&lock->spinlock);\n\n\tprintk(\"    type=%d, conv=%d, node=%u, cookie=%u:%llu, \"\n\t       \"ref=%u, ast=(empty=%c,pend=%c), bast=(empty=%c,pend=%c), \"\n\t       \"pending=(conv=%c,lock=%c,cancel=%c,unlock=%c)\\n\",\n\t       lock->ml.type, lock->ml.convert_type, lock->ml.node,\n\t       dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t       dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t       kref_read(&lock->lock_refs),\n\t       (list_empty(&lock->ast_list) ? 'y' : 'n'),\n\t       (lock->ast_pending ? 'y' : 'n'),\n\t       (list_empty(&lock->bast_list) ? 'y' : 'n'),\n\t       (lock->bast_pending ? 'y' : 'n'),\n\t       (lock->convert_pending ? 'y' : 'n'),\n\t       (lock->lock_pending ? 'y' : 'n'),\n\t       (lock->cancel_pending ? 'y' : 'n'),\n\t       (lock->unlock_pending ? 'y' : 'n'));\n\n\tspin_unlock(&lock->spinlock);\n}\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, kref_read(&res->refs),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}\n\nvoid dlm_print_one_lock(struct dlm_lock *lockid)\n{\n\tdlm_print_one_lock_resource(lockid->lockres);\n}\nEXPORT_SYMBOL_GPL(dlm_print_one_lock);\n\nstatic const char *dlm_errnames[] = {\n\t[DLM_NORMAL] =\t\t\t\"DLM_NORMAL\",\n\t[DLM_GRANTED] =\t\t\t\"DLM_GRANTED\",\n\t[DLM_DENIED] =\t\t\t\"DLM_DENIED\",\n\t[DLM_DENIED_NOLOCKS] =\t\t\"DLM_DENIED_NOLOCKS\",\n\t[DLM_WORKING] =\t\t\t\"DLM_WORKING\",\n\t[DLM_BLOCKED] =\t\t\t\"DLM_BLOCKED\",\n\t[DLM_BLOCKED_ORPHAN] =\t\t\"DLM_BLOCKED_ORPHAN\",\n\t[DLM_DENIED_GRACE_PERIOD] =\t\"DLM_DENIED_GRACE_PERIOD\",\n\t[DLM_SYSERR] =\t\t\t\"DLM_SYSERR\",\n\t[DLM_NOSUPPORT] =\t\t\"DLM_NOSUPPORT\",\n\t[DLM_CANCELGRANT] =\t\t\"DLM_CANCELGRANT\",\n\t[DLM_IVLOCKID] =\t\t\"DLM_IVLOCKID\",\n\t[DLM_SYNC] =\t\t\t\"DLM_SYNC\",\n\t[DLM_BADTYPE] =\t\t\t\"DLM_BADTYPE\",\n\t[DLM_BADRESOURCE] =\t\t\"DLM_BADRESOURCE\",\n\t[DLM_MAXHANDLES] =\t\t\"DLM_MAXHANDLES\",\n\t[DLM_NOCLINFO] =\t\t\"DLM_NOCLINFO\",\n\t[DLM_NOLOCKMGR] =\t\t\"DLM_NOLOCKMGR\",\n\t[DLM_NOPURGED] =\t\t\"DLM_NOPURGED\",\n\t[DLM_BADARGS] =\t\t\t\"DLM_BADARGS\",\n\t[DLM_VOID] =\t\t\t\"DLM_VOID\",\n\t[DLM_NOTQUEUED] =\t\t\"DLM_NOTQUEUED\",\n\t[DLM_IVBUFLEN] =\t\t\"DLM_IVBUFLEN\",\n\t[DLM_CVTUNGRANT] =\t\t\"DLM_CVTUNGRANT\",\n\t[DLM_BADPARAM] =\t\t\"DLM_BADPARAM\",\n\t[DLM_VALNOTVALID] =\t\t\"DLM_VALNOTVALID\",\n\t[DLM_REJECTED] =\t\t\"DLM_REJECTED\",\n\t[DLM_ABORT] =\t\t\t\"DLM_ABORT\",\n\t[DLM_CANCEL] =\t\t\t\"DLM_CANCEL\",\n\t[DLM_IVRESHANDLE] =\t\t\"DLM_IVRESHANDLE\",\n\t[DLM_DEADLOCK] =\t\t\"DLM_DEADLOCK\",\n\t[DLM_DENIED_NOASTS] =\t\t\"DLM_DENIED_NOASTS\",\n\t[DLM_FORWARD] =\t\t\t\"DLM_FORWARD\",\n\t[DLM_TIMEOUT] =\t\t\t\"DLM_TIMEOUT\",\n\t[DLM_IVGROUPID] =\t\t\"DLM_IVGROUPID\",\n\t[DLM_VERS_CONFLICT] =\t\t\"DLM_VERS_CONFLICT\",\n\t[DLM_BAD_DEVICE_PATH] =\t\t\"DLM_BAD_DEVICE_PATH\",\n\t[DLM_NO_DEVICE_PERMISSION] =\t\"DLM_NO_DEVICE_PERMISSION\",\n\t[DLM_NO_CONTROL_DEVICE ] =\t\"DLM_NO_CONTROL_DEVICE \",\n\t[DLM_RECOVERING] =\t\t\"DLM_RECOVERING\",\n\t[DLM_MIGRATING] =\t\t\"DLM_MIGRATING\",\n\t[DLM_MAXSTATS] =\t\t\"DLM_MAXSTATS\",\n};\n\nstatic const char *dlm_errmsgs[] = {\n\t[DLM_NORMAL] = \t\t\t\"request in progress\",\n\t[DLM_GRANTED] = \t\t\"request granted\",\n\t[DLM_DENIED] = \t\t\t\"request denied\",\n\t[DLM_DENIED_NOLOCKS] = \t\t\"request denied, out of system resources\",\n\t[DLM_WORKING] = \t\t\"async request in progress\",\n\t[DLM_BLOCKED] = \t\t\"lock request blocked\",\n\t[DLM_BLOCKED_ORPHAN] = \t\t\"lock request blocked by a orphan lock\",\n\t[DLM_DENIED_GRACE_PERIOD] = \t\"topological change in progress\",\n\t[DLM_SYSERR] = \t\t\t\"system error\",\n\t[DLM_NOSUPPORT] = \t\t\"unsupported\",\n\t[DLM_CANCELGRANT] = \t\t\"can't cancel convert: already granted\",\n\t[DLM_IVLOCKID] = \t\t\"bad lockid\",\n\t[DLM_SYNC] = \t\t\t\"synchronous request granted\",\n\t[DLM_BADTYPE] = \t\t\"bad resource type\",\n\t[DLM_BADRESOURCE] = \t\t\"bad resource handle\",\n\t[DLM_MAXHANDLES] = \t\t\"no more resource handles\",\n\t[DLM_NOCLINFO] = \t\t\"can't contact cluster manager\",\n\t[DLM_NOLOCKMGR] = \t\t\"can't contact lock manager\",\n\t[DLM_NOPURGED] = \t\t\"can't contact purge daemon\",\n\t[DLM_BADARGS] = \t\t\"bad api args\",\n\t[DLM_VOID] = \t\t\t\"no status\",\n\t[DLM_NOTQUEUED] = \t\t\"NOQUEUE was specified and request failed\",\n\t[DLM_IVBUFLEN] = \t\t\"invalid resource name length\",\n\t[DLM_CVTUNGRANT] = \t\t\"attempted to convert ungranted lock\",\n\t[DLM_BADPARAM] = \t\t\"invalid lock mode specified\",\n\t[DLM_VALNOTVALID] = \t\t\"value block has been invalidated\",\n\t[DLM_REJECTED] = \t\t\"request rejected, unrecognized client\",\n\t[DLM_ABORT] = \t\t\t\"blocked lock request cancelled\",\n\t[DLM_CANCEL] = \t\t\t\"conversion request cancelled\",\n\t[DLM_IVRESHANDLE] = \t\t\"invalid resource handle\",\n\t[DLM_DEADLOCK] = \t\t\"deadlock recovery refused this request\",\n\t[DLM_DENIED_NOASTS] = \t\t\"failed to allocate AST\",\n\t[DLM_FORWARD] = \t\t\"request must wait for primary's response\",\n\t[DLM_TIMEOUT] = \t\t\"timeout value for lock has expired\",\n\t[DLM_IVGROUPID] = \t\t\"invalid group specification\",\n\t[DLM_VERS_CONFLICT] = \t\t\"version conflicts prevent request handling\",\n\t[DLM_BAD_DEVICE_PATH] = \t\"Locks device does not exist or path wrong\",\n\t[DLM_NO_DEVICE_PERMISSION] = \t\"Client has insufficient perms for device\",\n\t[DLM_NO_CONTROL_DEVICE] = \t\"Cannot set options on opened device \",\n\t[DLM_RECOVERING] = \t\t\"lock resource being recovered\",\n\t[DLM_MIGRATING] = \t\t\"lock resource being migrated\",\n\t[DLM_MAXSTATS] = \t\t\"invalid error number\",\n};\n\nconst char *dlm_errmsg(enum dlm_status err)\n{\n\tif (err >= DLM_MAXSTATS || err < 0)\n\t\treturn dlm_errmsgs[DLM_MAXSTATS];\n\treturn dlm_errmsgs[err];\n}\nEXPORT_SYMBOL_GPL(dlm_errmsg);\n\nconst char *dlm_errname(enum dlm_status err)\n{\n\tif (err >= DLM_MAXSTATS || err < 0)\n\t\treturn dlm_errnames[DLM_MAXSTATS];\n\treturn dlm_errnames[err];\n}\nEXPORT_SYMBOL_GPL(dlm_errname);\n\n \nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len)\n{\n\tint out = 0;\n\t__be64 inode_blkno_be;\n\n#define OCFS2_DENTRY_LOCK_INO_START\t18\n\tif (*lockname == 'N') {\n\t\tmemcpy((__be64 *)&inode_blkno_be,\n\t\t       (char *)&lockname[OCFS2_DENTRY_LOCK_INO_START],\n\t\t       sizeof(__be64));\n\t\tout += scnprintf(buf + out, len - out, \"%.*s%08x\",\n\t\t\t\tOCFS2_DENTRY_LOCK_INO_START - 1, lockname,\n\t\t\t\t(unsigned int)be64_to_cpu(inode_blkno_be));\n\t} else\n\t\tout += scnprintf(buf + out, len - out, \"%.*s\",\n\t\t\t\tlocklen, lockname);\n\treturn out;\n}\n\nstatic int stringify_nodemap(unsigned long *nodemap, int maxnodes,\n\t\t\t     char *buf, int len)\n{\n\tint out = 0;\n\tint i = -1;\n\n\twhile ((i = find_next_bit(nodemap, maxnodes, i + 1)) < maxnodes)\n\t\tout += scnprintf(buf + out, len - out, \"%d \", i);\n\n\treturn out;\n}\n\nstatic int dump_mle(struct dlm_master_list_entry *mle, char *buf, int len)\n{\n\tint out = 0;\n\tchar *mle_type;\n\n\tif (mle->type == DLM_MLE_BLOCK)\n\t\tmle_type = \"BLK\";\n\telse if (mle->type == DLM_MLE_MASTER)\n\t\tmle_type = \"MAS\";\n\telse\n\t\tmle_type = \"MIG\";\n\n\tout += stringify_lockname(mle->mname, mle->mnamelen, buf + out, len - out);\n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"\\t%3s\\tmas=%3u\\tnew=%3u\\tevt=%1d\\tuse=%1d\\tref=%3d\\n\",\n\t\t\tmle_type, mle->master, mle->new_master,\n\t\t\t!list_empty(&mle->hb_events),\n\t\t\t!!mle->inuse,\n\t\t\tkref_read(&mle->mle_refs));\n\n\tout += scnprintf(buf + out, len - out, \"Maybe=\");\n\tout += stringify_nodemap(mle->maybe_map, O2NM_MAX_NODES,\n\t\t\t\t buf + out, len - out);\n\tout += scnprintf(buf + out, len - out, \"\\n\");\n\n\tout += scnprintf(buf + out, len - out, \"Vote=\");\n\tout += stringify_nodemap(mle->vote_map, O2NM_MAX_NODES,\n\t\t\t\t buf + out, len - out);\n\tout += scnprintf(buf + out, len - out, \"\\n\");\n\n\tout += scnprintf(buf + out, len - out, \"Response=\");\n\tout += stringify_nodemap(mle->response_map, O2NM_MAX_NODES,\n\t\t\t\t buf + out, len - out);\n\tout += scnprintf(buf + out, len - out, \"\\n\");\n\n\tout += scnprintf(buf + out, len - out, \"Node=\");\n\tout += stringify_nodemap(mle->node_map, O2NM_MAX_NODES,\n\t\t\t\t buf + out, len - out);\n\tout += scnprintf(buf + out, len - out, \"\\n\");\n\n\tout += scnprintf(buf + out, len - out, \"\\n\");\n\n\treturn out;\n}\n\nvoid dlm_print_one_mle(struct dlm_master_list_entry *mle)\n{\n\tchar *buf;\n\n\tbuf = (char *) get_zeroed_page(GFP_ATOMIC);\n\tif (buf) {\n\t\tdump_mle(mle, buf, PAGE_SIZE - 1);\n\t\tfree_page((unsigned long)buf);\n\t}\n}\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic struct dentry *dlm_debugfs_root;\n\n#define DLM_DEBUGFS_DIR\t\t\t\t\"o2dlm\"\n#define DLM_DEBUGFS_DLM_STATE\t\t\t\"dlm_state\"\n#define DLM_DEBUGFS_LOCKING_STATE\t\t\"locking_state\"\n#define DLM_DEBUGFS_MLE_STATE\t\t\t\"mle_state\"\n#define DLM_DEBUGFS_PURGE_LIST\t\t\t\"purge_list\"\n\n \nstatic int debug_release(struct inode *inode, struct file *file)\n{\n\tfree_page((unsigned long)file->private_data);\n\treturn 0;\n}\n\nstatic ssize_t debug_read(struct file *file, char __user *buf,\n\t\t\t  size_t nbytes, loff_t *ppos)\n{\n\treturn simple_read_from_buffer(buf, nbytes, ppos, file->private_data,\n\t\t\t\t       i_size_read(file->f_mapping->host));\n}\n \n\n \nstatic int debug_purgelist_print(struct dlm_ctxt *dlm, char *buf, int len)\n{\n\tstruct dlm_lock_resource *res;\n\tint out = 0;\n\tunsigned long total = 0;\n\n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"Dumping Purgelist for Domain: %s\\n\", dlm->name);\n\n\tspin_lock(&dlm->spinlock);\n\tlist_for_each_entry(res, &dlm->purge_list, purge) {\n\t\t++total;\n\t\tif (len - out < 100)\n\t\t\tcontinue;\n\t\tspin_lock(&res->spinlock);\n\t\tout += stringify_lockname(res->lockname.name,\n\t\t\t\t\t  res->lockname.len,\n\t\t\t\t\t  buf + out, len - out);\n\t\tout += scnprintf(buf + out, len - out, \"\\t%ld\\n\",\n\t\t\t\t(jiffies - res->last_used)/HZ);\n\t\tspin_unlock(&res->spinlock);\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\tout += scnprintf(buf + out, len - out, \"Total on list: %lu\\n\", total);\n\n\treturn out;\n}\n\nstatic int debug_purgelist_open(struct inode *inode, struct file *file)\n{\n\tstruct dlm_ctxt *dlm = inode->i_private;\n\tchar *buf = NULL;\n\n\tbuf = (char *) get_zeroed_page(GFP_NOFS);\n\tif (!buf)\n\t\tgoto bail;\n\n\ti_size_write(inode, debug_purgelist_print(dlm, buf, PAGE_SIZE - 1));\n\n\tfile->private_data = buf;\n\n\treturn 0;\nbail:\n\treturn -ENOMEM;\n}\n\nstatic const struct file_operations debug_purgelist_fops = {\n\t.open =\t\tdebug_purgelist_open,\n\t.release =\tdebug_release,\n\t.read =\t\tdebug_read,\n\t.llseek =\tgeneric_file_llseek,\n};\n \n\n \nstatic int debug_mle_print(struct dlm_ctxt *dlm, char *buf, int len)\n{\n\tstruct dlm_master_list_entry *mle;\n\tstruct hlist_head *bucket;\n\tint i, out = 0;\n\tunsigned long total = 0, longest = 0, bucket_count = 0;\n\n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"Dumping MLEs for Domain: %s\\n\", dlm->name);\n\n\tspin_lock(&dlm->master_lock);\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_master_hash(dlm, i);\n\t\thlist_for_each_entry(mle, bucket, master_hash_node) {\n\t\t\t++total;\n\t\t\t++bucket_count;\n\t\t\tif (len - out < 200)\n\t\t\t\tcontinue;\n\t\t\tout += dump_mle(mle, buf + out, len - out);\n\t\t}\n\t\tlongest = max(longest, bucket_count);\n\t\tbucket_count = 0;\n\t}\n\tspin_unlock(&dlm->master_lock);\n\n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"Total: %lu, Longest: %lu\\n\", total, longest);\n\treturn out;\n}\n\nstatic int debug_mle_open(struct inode *inode, struct file *file)\n{\n\tstruct dlm_ctxt *dlm = inode->i_private;\n\tchar *buf = NULL;\n\n\tbuf = (char *) get_zeroed_page(GFP_NOFS);\n\tif (!buf)\n\t\tgoto bail;\n\n\ti_size_write(inode, debug_mle_print(dlm, buf, PAGE_SIZE - 1));\n\n\tfile->private_data = buf;\n\n\treturn 0;\nbail:\n\treturn -ENOMEM;\n}\n\nstatic const struct file_operations debug_mle_fops = {\n\t.open =\t\tdebug_mle_open,\n\t.release =\tdebug_release,\n\t.read =\t\tdebug_read,\n\t.llseek =\tgeneric_file_llseek,\n};\n\n \n\n \nstatic int dump_lock(struct dlm_lock *lock, int list_type, char *buf, int len)\n{\n\tint out;\n\n#define DEBUG_LOCK_VERSION\t1\n\tspin_lock(&lock->spinlock);\n\tout = scnprintf(buf, len, \"LOCK:%d,%d,%d,%d,%d,%d:%lld,%d,%d,%d,%d,%d,\"\n\t\t       \"%d,%d,%d,%d\\n\",\n\t\t       DEBUG_LOCK_VERSION,\n\t\t       list_type, lock->ml.type, lock->ml.convert_type,\n\t\t       lock->ml.node,\n\t\t       dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t       dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t       !list_empty(&lock->ast_list),\n\t\t       !list_empty(&lock->bast_list),\n\t\t       lock->ast_pending, lock->bast_pending,\n\t\t       lock->convert_pending, lock->lock_pending,\n\t\t       lock->cancel_pending, lock->unlock_pending,\n\t\t       kref_read(&lock->lock_refs));\n\tspin_unlock(&lock->spinlock);\n\n\treturn out;\n}\n\nstatic int dump_lockres(struct dlm_lock_resource *res, char *buf, int len)\n{\n\tstruct dlm_lock *lock;\n\tint i;\n\tint out = 0;\n\n\tout += scnprintf(buf + out, len - out, \"NAME:\");\n\tout += stringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t\t  buf + out, len - out);\n\tout += scnprintf(buf + out, len - out, \"\\n\");\n\n#define DEBUG_LRES_VERSION\t1\n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"LRES:%d,%d,%d,%ld,%d,%d,%d,%d,%d,%d,%d\\n\",\n\t\t\tDEBUG_LRES_VERSION,\n\t\t\tres->owner, res->state, res->last_used,\n\t\t\t!list_empty(&res->purge),\n\t\t\t!list_empty(&res->dirty),\n\t\t\t!list_empty(&res->recovering),\n\t\t\tres->inflight_locks, res->migration_pending,\n\t\t\tatomic_read(&res->asts_reserved),\n\t\t\tkref_read(&res->refs));\n\n\t \n\tout += scnprintf(buf + out, len - out, \"RMAP:\");\n\tout += stringify_nodemap(res->refmap, O2NM_MAX_NODES,\n\t\t\t\t buf + out, len - out);\n\tout += scnprintf(buf + out, len - out, \"\\n\");\n\n\t \n\tout += scnprintf(buf + out, len - out, \"LVBX:\");\n\tfor (i = 0; i < DLM_LVB_LEN; i++)\n\t\tout += scnprintf(buf + out, len - out,\n\t\t\t\t\t\"%02x\", (unsigned char)res->lvb[i]);\n\tout += scnprintf(buf + out, len - out, \"\\n\");\n\n\t \n\tlist_for_each_entry(lock, &res->granted, list)\n\t\tout += dump_lock(lock, 0, buf + out, len - out);\n\n\t \n\tlist_for_each_entry(lock, &res->converting, list)\n\t\tout += dump_lock(lock, 1, buf + out, len - out);\n\n\t \n\tlist_for_each_entry(lock, &res->blocked, list)\n\t\tout += dump_lock(lock, 2, buf + out, len - out);\n\n\tout += scnprintf(buf + out, len - out, \"\\n\");\n\n\treturn out;\n}\n\nstatic void *lockres_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct debug_lockres *dl = m->private;\n\tstruct dlm_ctxt *dlm = dl->dl_ctxt;\n\tstruct dlm_lock_resource *oldres = dl->dl_res;\n\tstruct dlm_lock_resource *res = NULL, *iter;\n\tstruct list_head *track_list;\n\n\tspin_lock(&dlm->track_lock);\n\tif (oldres)\n\t\ttrack_list = &oldres->tracking;\n\telse {\n\t\ttrack_list = &dlm->tracking_list;\n\t\tif (list_empty(track_list)) {\n\t\t\tdl = NULL;\n\t\t\tspin_unlock(&dlm->track_lock);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tlist_for_each_entry(iter, track_list, tracking) {\n\t\tif (&iter->tracking != &dlm->tracking_list) {\n\t\t\tdlm_lockres_get(iter);\n\t\t\tres = iter;\n\t\t}\n\t\tbreak;\n\t}\n\tspin_unlock(&dlm->track_lock);\n\n\tif (oldres)\n\t\tdlm_lockres_put(oldres);\n\n\tdl->dl_res = res;\n\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tdump_lockres(res, dl->dl_buf, dl->dl_len - 1);\n\t\tspin_unlock(&res->spinlock);\n\t} else\n\t\tdl = NULL;\n\nbail:\n\t \n\treturn dl;\n}\n\nstatic void lockres_seq_stop(struct seq_file *m, void *v)\n{\n}\n\nstatic void *lockres_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn NULL;\n}\n\nstatic int lockres_seq_show(struct seq_file *s, void *v)\n{\n\tstruct debug_lockres *dl = (struct debug_lockres *)v;\n\n\tseq_printf(s, \"%s\", dl->dl_buf);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations debug_lockres_ops = {\n\t.start =\tlockres_seq_start,\n\t.stop =\t\tlockres_seq_stop,\n\t.next =\t\tlockres_seq_next,\n\t.show =\t\tlockres_seq_show,\n};\n\nstatic int debug_lockres_open(struct inode *inode, struct file *file)\n{\n\tstruct dlm_ctxt *dlm = inode->i_private;\n\tstruct debug_lockres *dl;\n\tvoid *buf;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto bail;\n\n\tdl = __seq_open_private(file, &debug_lockres_ops, sizeof(*dl));\n\tif (!dl)\n\t\tgoto bailfree;\n\n\tdl->dl_len = PAGE_SIZE;\n\tdl->dl_buf = buf;\n\n\tdlm_grab(dlm);\n\tdl->dl_ctxt = dlm;\n\n\treturn 0;\n\nbailfree:\n\tkfree(buf);\nbail:\n\tmlog_errno(-ENOMEM);\n\treturn -ENOMEM;\n}\n\nstatic int debug_lockres_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct debug_lockres *dl = (struct debug_lockres *)seq->private;\n\n\tif (dl->dl_res)\n\t\tdlm_lockres_put(dl->dl_res);\n\tdlm_put(dl->dl_ctxt);\n\tkfree(dl->dl_buf);\n\treturn seq_release_private(inode, file);\n}\n\nstatic const struct file_operations debug_lockres_fops = {\n\t.open =\t\tdebug_lockres_open,\n\t.release =\tdebug_lockres_release,\n\t.read =\t\tseq_read,\n\t.llseek =\tseq_lseek,\n};\n \n\n \nstatic int debug_state_print(struct dlm_ctxt *dlm, char *buf, int len)\n{\n\tint out = 0;\n\tstruct dlm_reco_node_data *node;\n\tchar *state;\n\tint cur_mles = 0, tot_mles = 0;\n\tint i;\n\n\tspin_lock(&dlm->spinlock);\n\n\tswitch (dlm->dlm_state) {\n\tcase DLM_CTXT_NEW:\n\t\tstate = \"NEW\"; break;\n\tcase DLM_CTXT_JOINED:\n\t\tstate = \"JOINED\"; break;\n\tcase DLM_CTXT_IN_SHUTDOWN:\n\t\tstate = \"SHUTDOWN\"; break;\n\tcase DLM_CTXT_LEAVING:\n\t\tstate = \"LEAVING\"; break;\n\tdefault:\n\t\tstate = \"UNKNOWN\"; break;\n\t}\n\n\t \n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"Domain: %s  Key: 0x%08x  Protocol: %d.%d\\n\",\n\t\t\tdlm->name, dlm->key, dlm->dlm_locking_proto.pv_major,\n\t\t\tdlm->dlm_locking_proto.pv_minor);\n\n\t \n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"Thread Pid: %d  Node: %d  State: %s\\n\",\n\t\t\ttask_pid_nr(dlm->dlm_thread_task), dlm->node_num, state);\n\n\t \n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"Number of Joins: %d  Joining Node: %d\\n\",\n\t\t\tdlm->num_joins, dlm->joining_node);\n\n\t \n\tout += scnprintf(buf + out, len - out, \"Domain Map: \");\n\tout += stringify_nodemap(dlm->domain_map, O2NM_MAX_NODES,\n\t\t\t\t buf + out, len - out);\n\tout += scnprintf(buf + out, len - out, \"\\n\");\n\n\t \n\tout += scnprintf(buf + out, len - out, \"Exit Domain Map: \");\n\tout += stringify_nodemap(dlm->exit_domain_map, O2NM_MAX_NODES,\n\t\t\t\t buf + out, len - out);\n\tout += scnprintf(buf + out, len - out, \"\\n\");\n\n\t \n\tout += scnprintf(buf + out, len - out, \"Live Map: \");\n\tout += stringify_nodemap(dlm->live_nodes_map, O2NM_MAX_NODES,\n\t\t\t\t buf + out, len - out);\n\tout += scnprintf(buf + out, len - out, \"\\n\");\n\n\t \n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"Lock Resources: %d (%d)\\n\",\n\t\t\tatomic_read(&dlm->res_cur_count),\n\t\t\tatomic_read(&dlm->res_tot_count));\n\n\tfor (i = 0; i < DLM_MLE_NUM_TYPES; ++i)\n\t\ttot_mles += atomic_read(&dlm->mle_tot_count[i]);\n\n\tfor (i = 0; i < DLM_MLE_NUM_TYPES; ++i)\n\t\tcur_mles += atomic_read(&dlm->mle_cur_count[i]);\n\n\t \n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"MLEs: %d (%d)\\n\", cur_mles, tot_mles);\n\n\t \n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"  Blocking: %d (%d)\\n\",\n\t\t\tatomic_read(&dlm->mle_cur_count[DLM_MLE_BLOCK]),\n\t\t\tatomic_read(&dlm->mle_tot_count[DLM_MLE_BLOCK]));\n\n\t \n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"  Mastery: %d (%d)\\n\",\n\t\t\tatomic_read(&dlm->mle_cur_count[DLM_MLE_MASTER]),\n\t\t\tatomic_read(&dlm->mle_tot_count[DLM_MLE_MASTER]));\n\n\t \n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"  Migration: %d (%d)\\n\",\n\t\t\tatomic_read(&dlm->mle_cur_count[DLM_MLE_MIGRATION]),\n\t\t\tatomic_read(&dlm->mle_tot_count[DLM_MLE_MIGRATION]));\n\n\t \n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"Lists: Dirty=%s  Purge=%s  PendingASTs=%s  \"\n\t\t\t\"PendingBASTs=%s\\n\",\n\t\t\t(list_empty(&dlm->dirty_list) ? \"Empty\" : \"InUse\"),\n\t\t\t(list_empty(&dlm->purge_list) ? \"Empty\" : \"InUse\"),\n\t\t\t(list_empty(&dlm->pending_asts) ? \"Empty\" : \"InUse\"),\n\t\t\t(list_empty(&dlm->pending_basts) ? \"Empty\" : \"InUse\"));\n\n\t \n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"Purge Count: %d  Refs: %d\\n\", dlm->purge_count,\n\t\t\tkref_read(&dlm->dlm_refs));\n\n\t \n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"Dead Node: %d\\n\", dlm->reco.dead_node);\n\n\t \n\tif (dlm->reco.state == DLM_RECO_STATE_ACTIVE)\n\t\tstate = \"ACTIVE\";\n\telse\n\t\tstate = \"INACTIVE\";\n\n\t \n\tout += scnprintf(buf + out, len - out,\n\t\t\t\"Recovery Pid: %d  Master: %d  State: %s\\n\",\n\t\t\ttask_pid_nr(dlm->dlm_reco_thread_task),\n\t\t\tdlm->reco.new_master, state);\n\n\t \n\tout += scnprintf(buf + out, len - out, \"Recovery Map: \");\n\tout += stringify_nodemap(dlm->recovery_map, O2NM_MAX_NODES,\n\t\t\t\t buf + out, len - out);\n\tout += scnprintf(buf + out, len - out, \"\\n\");\n\n\t \n\tout += scnprintf(buf + out, len - out, \"Recovery Node State:\\n\");\n\tlist_for_each_entry(node, &dlm->reco.node_data, list) {\n\t\tswitch (node->state) {\n\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\tstate = \"INIT\";\n\t\t\tbreak;\n\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\tstate = \"REQUESTING\";\n\t\t\tbreak;\n\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\tstate = \"DEAD\";\n\t\t\tbreak;\n\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\tstate = \"RECEIVING\";\n\t\t\tbreak;\n\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\tstate = \"REQUESTED\";\n\t\t\tbreak;\n\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\tstate = \"DONE\";\n\t\t\tbreak;\n\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\tstate = \"FINALIZE-SENT\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstate = \"BAD\";\n\t\t\tbreak;\n\t\t}\n\t\tout += scnprintf(buf + out, len - out, \"\\t%u - %s\\n\",\n\t\t\t\tnode->node_num, state);\n\t}\n\n\tspin_unlock(&dlm->spinlock);\n\n\treturn out;\n}\n\nstatic int debug_state_open(struct inode *inode, struct file *file)\n{\n\tstruct dlm_ctxt *dlm = inode->i_private;\n\tchar *buf = NULL;\n\n\tbuf = (char *) get_zeroed_page(GFP_NOFS);\n\tif (!buf)\n\t\tgoto bail;\n\n\ti_size_write(inode, debug_state_print(dlm, buf, PAGE_SIZE - 1));\n\n\tfile->private_data = buf;\n\n\treturn 0;\nbail:\n\treturn -ENOMEM;\n}\n\nstatic const struct file_operations debug_state_fops = {\n\t.open =\t\tdebug_state_open,\n\t.release =\tdebug_release,\n\t.read =\t\tdebug_read,\n\t.llseek =\tgeneric_file_llseek,\n};\n \n\n \nvoid dlm_debug_init(struct dlm_ctxt *dlm)\n{\n\t \n\tdebugfs_create_file(DLM_DEBUGFS_DLM_STATE, S_IFREG|S_IRUSR,\n\t\t\t    dlm->dlm_debugfs_subroot, dlm, &debug_state_fops);\n\n\t \n\tdebugfs_create_file(DLM_DEBUGFS_LOCKING_STATE, S_IFREG|S_IRUSR,\n\t\t\t    dlm->dlm_debugfs_subroot, dlm, &debug_lockres_fops);\n\n\t \n\tdebugfs_create_file(DLM_DEBUGFS_MLE_STATE, S_IFREG|S_IRUSR,\n\t\t\t    dlm->dlm_debugfs_subroot, dlm, &debug_mle_fops);\n\n\t \n\tdebugfs_create_file(DLM_DEBUGFS_PURGE_LIST, S_IFREG|S_IRUSR,\n\t\t\t    dlm->dlm_debugfs_subroot, dlm,\n\t\t\t    &debug_purgelist_fops);\n}\n\n \nvoid dlm_create_debugfs_subroot(struct dlm_ctxt *dlm)\n{\n\tdlm->dlm_debugfs_subroot = debugfs_create_dir(dlm->name,\n\t\t\t\t\t\t      dlm_debugfs_root);\n}\n\nvoid dlm_destroy_debugfs_subroot(struct dlm_ctxt *dlm)\n{\n\tdebugfs_remove_recursive(dlm->dlm_debugfs_subroot);\n}\n\n \nvoid dlm_create_debugfs_root(void)\n{\n\tdlm_debugfs_root = debugfs_create_dir(DLM_DEBUGFS_DIR, NULL);\n}\n\nvoid dlm_destroy_debugfs_root(void)\n{\n\tdebugfs_remove(dlm_debugfs_root);\n}\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}