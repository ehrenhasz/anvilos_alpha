{
  "module_name": "dlmcommon.h",
  "hash_id": "de09b4042e8bf2b4f6b88810cc40e541ae348c511002ad404b90303f226a85db",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/dlm/dlmcommon.h",
  "human_readable_source": " \n \n\n#ifndef DLMCOMMON_H\n#define DLMCOMMON_H\n\n#include <linux/kref.h>\n\n#define DLM_HB_NODE_DOWN_PRI     (0xf000000)\n#define DLM_HB_NODE_UP_PRI       (0x8000000)\n\n#define DLM_LOCKID_NAME_MAX    32\n\n#define DLM_LOCK_RES_OWNER_UNKNOWN     O2NM_MAX_NODES\n\n#define DLM_HASH_SIZE_DEFAULT\t(1 << 17)\n#if DLM_HASH_SIZE_DEFAULT < PAGE_SIZE\n# define DLM_HASH_PAGES\t\t1\n#else\n# define DLM_HASH_PAGES\t\t(DLM_HASH_SIZE_DEFAULT / PAGE_SIZE)\n#endif\n#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))\n#define DLM_HASH_BUCKETS\t(DLM_HASH_PAGES * DLM_BUCKETS_PER_PAGE)\n\n \n#define dlm_lockid_hash(_n, _l) full_name_hash(NULL, _n, _l)\n\nenum dlm_mle_type {\n\tDLM_MLE_BLOCK = 0,\n\tDLM_MLE_MASTER = 1,\n\tDLM_MLE_MIGRATION = 2,\n\tDLM_MLE_NUM_TYPES = 3,\n};\n\nstruct dlm_master_list_entry {\n\tstruct hlist_node master_hash_node;\n\tstruct list_head hb_events;\n\tstruct dlm_ctxt *dlm;\n\tspinlock_t spinlock;\n\twait_queue_head_t wq;\n\tatomic_t woken;\n\tstruct kref mle_refs;\n\tint inuse;\n\tunsigned long maybe_map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tunsigned long vote_map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tunsigned long response_map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tunsigned long node_map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tu8 master;\n\tu8 new_master;\n\tenum dlm_mle_type type;\n\tstruct o2hb_callback_func mle_hb_up;\n\tstruct o2hb_callback_func mle_hb_down;\n\tstruct dlm_lock_resource *mleres;\n\tunsigned char mname[DLM_LOCKID_NAME_MAX];\n\tunsigned int mnamelen;\n\tunsigned int mnamehash;\n};\n\nenum dlm_ast_type {\n\tDLM_AST = 0,\n\tDLM_BAST = 1,\n\tDLM_ASTUNLOCK = 2,\n};\n\n\n#define LKM_VALID_FLAGS (LKM_VALBLK | LKM_CONVERT | LKM_UNLOCK | \\\n\t\t\t LKM_CANCEL | LKM_INVVALBLK | LKM_FORCE | \\\n\t\t\t LKM_RECOVERY | LKM_LOCAL | LKM_NOQUEUE)\n\n#define DLM_RECOVERY_LOCK_NAME       \"$RECOVERY\"\n#define DLM_RECOVERY_LOCK_NAME_LEN   9\n\nstatic inline int dlm_is_recovery_lock(const char *lock_name, int name_len)\n{\n\tif (name_len == DLM_RECOVERY_LOCK_NAME_LEN &&\n\t    memcmp(lock_name, DLM_RECOVERY_LOCK_NAME, name_len)==0)\n\t\treturn 1;\n\treturn 0;\n}\n\n#define DLM_RECO_STATE_ACTIVE    0x0001\n#define DLM_RECO_STATE_FINALIZE  0x0002\n\nstruct dlm_recovery_ctxt\n{\n\tstruct list_head resources;\n\tstruct list_head node_data;\n\tu8  new_master;\n\tu8  dead_node;\n\tu16 state;\n\tunsigned long node_map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\twait_queue_head_t event;\n};\n\nenum dlm_ctxt_state {\n\tDLM_CTXT_NEW = 0,\n\tDLM_CTXT_JOINED = 1,\n\tDLM_CTXT_IN_SHUTDOWN = 2,\n\tDLM_CTXT_LEAVING = 3,\n};\n\nstruct dlm_ctxt\n{\n\tstruct list_head list;\n\tstruct hlist_head **lockres_hash;\n\tstruct list_head dirty_list;\n\tstruct list_head purge_list;\n\tstruct list_head pending_asts;\n\tstruct list_head pending_basts;\n\tstruct list_head tracking_list;\n\tunsigned int purge_count;\n\tspinlock_t spinlock;\n\tspinlock_t ast_lock;\n\tspinlock_t track_lock;\n\tchar *name;\n\tu8 node_num;\n\tu32 key;\n\tu8  joining_node;\n\tu8 migrate_done;  \n\twait_queue_head_t dlm_join_events;\n\tunsigned long live_nodes_map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tunsigned long domain_map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tunsigned long exit_domain_map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tunsigned long recovery_map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tstruct dlm_recovery_ctxt reco;\n\tspinlock_t master_lock;\n\tstruct hlist_head **master_hash;\n\tstruct list_head mle_hb_events;\n\n\t \n\tatomic_t mle_tot_count[DLM_MLE_NUM_TYPES];\n\tatomic_t mle_cur_count[DLM_MLE_NUM_TYPES];\n\tatomic_t res_tot_count;\n\tatomic_t res_cur_count;\n\n\tstruct dentry *dlm_debugfs_subroot;\n\n\t \n\tstruct kref dlm_refs;\n\tenum dlm_ctxt_state dlm_state;\n\tunsigned int num_joins;\n\n\tstruct o2hb_callback_func dlm_hb_up;\n\tstruct o2hb_callback_func dlm_hb_down;\n\tstruct task_struct *dlm_thread_task;\n\tstruct task_struct *dlm_reco_thread_task;\n\tstruct workqueue_struct *dlm_worker;\n\twait_queue_head_t dlm_thread_wq;\n\twait_queue_head_t dlm_reco_thread_wq;\n\twait_queue_head_t ast_wq;\n\twait_queue_head_t migration_wq;\n\n\tstruct work_struct dispatched_work;\n\tstruct list_head work_list;\n\tspinlock_t work_lock;\n\tstruct list_head dlm_domain_handlers;\n\tstruct list_head\tdlm_eviction_callbacks;\n\n\t \n\tstruct dlm_protocol_version fs_locking_proto;\n\t \n\tstruct dlm_protocol_version dlm_locking_proto;\n};\n\nstatic inline struct hlist_head *dlm_lockres_hash(struct dlm_ctxt *dlm, unsigned i)\n{\n\treturn dlm->lockres_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] + (i % DLM_BUCKETS_PER_PAGE);\n}\n\nstatic inline struct hlist_head *dlm_master_hash(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t unsigned i)\n{\n\treturn dlm->master_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] +\n\t\t\t(i % DLM_BUCKETS_PER_PAGE);\n}\n\n \nvoid dlm_dispatch_work(struct work_struct *work);\n\nstruct dlm_lock_resource;\nstruct dlm_work_item;\n\ntypedef void (dlm_workfunc_t)(struct dlm_work_item *, void *);\n\nstruct dlm_request_all_locks_priv\n{\n\tu8 reco_master;\n\tu8 dead_node;\n};\n\nstruct dlm_mig_lockres_priv\n{\n\tstruct dlm_lock_resource *lockres;\n\tu8 real_master;\n\tu8 extra_ref;\n};\n\nstruct dlm_assert_master_priv\n{\n\tstruct dlm_lock_resource *lockres;\n\tu8 request_from;\n\tu32 flags;\n\tunsigned ignore_higher:1;\n};\n\nstruct dlm_deref_lockres_priv\n{\n\tstruct dlm_lock_resource *deref_res;\n\tu8 deref_node;\n};\n\nstruct dlm_work_item\n{\n\tstruct list_head list;\n\tdlm_workfunc_t *func;\n\tstruct dlm_ctxt *dlm;\n\tvoid *data;\n\tunion {\n\t\tstruct dlm_request_all_locks_priv ral;\n\t\tstruct dlm_mig_lockres_priv ml;\n\t\tstruct dlm_assert_master_priv am;\n\t\tstruct dlm_deref_lockres_priv dl;\n\t} u;\n};\n\nstatic inline void dlm_init_work_item(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_work_item *i,\n\t\t\t\t      dlm_workfunc_t *f, void *data)\n{\n\tmemset(i, 0, sizeof(*i));\n\ti->func = f;\n\tINIT_LIST_HEAD(&i->list);\n\ti->data = data;\n\ti->dlm = dlm;   \n}\n\n\n\nstatic inline void __dlm_set_joining_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tdlm->joining_node = node;\n\twake_up(&dlm->dlm_join_events);\n}\n\n#define DLM_LOCK_RES_UNINITED             0x00000001\n#define DLM_LOCK_RES_RECOVERING           0x00000002\n#define DLM_LOCK_RES_READY                0x00000004\n#define DLM_LOCK_RES_DIRTY                0x00000008\n#define DLM_LOCK_RES_IN_PROGRESS          0x00000010\n#define DLM_LOCK_RES_MIGRATING            0x00000020\n#define DLM_LOCK_RES_DROPPING_REF         0x00000040\n#define DLM_LOCK_RES_BLOCK_DIRTY          0x00001000\n#define DLM_LOCK_RES_SETREF_INPROG        0x00002000\n#define DLM_LOCK_RES_RECOVERY_WAITING     0x00004000\n\n \n#define DLM_NODE_DEATH_WAIT_MAX (5 * 1000)\n\n#define DLM_PURGE_INTERVAL_MS   (8 * 1000)\n\nstruct dlm_lock_resource\n{\n\t \n\tstruct hlist_node hash_node;\n\tstruct qstr lockname;\n\tstruct kref      refs;\n\n\t \n\tstruct list_head granted;\n\tstruct list_head converting;\n\tstruct list_head blocked;\n\tstruct list_head purge;\n\n\t \n\tstruct list_head dirty;\n\tstruct list_head recovering; \n\n\t \n\tstruct list_head tracking;\t \n\n\t \n\tunsigned long    last_used;\n\n\tstruct dlm_ctxt *dlm;\n\n\tunsigned migration_pending:1;\n\tatomic_t asts_reserved;\n\tspinlock_t spinlock;\n\twait_queue_head_t wq;\n\tu8  owner;              \n\tu16 state;\n\tchar lvb[DLM_LVB_LEN];\n\tunsigned int inflight_locks;\n\tunsigned int inflight_assert_workers;\n\tunsigned long refmap[BITS_TO_LONGS(O2NM_MAX_NODES)];\n};\n\nstruct dlm_migratable_lock\n{\n\t__be64 cookie;\n\n\t \n\t__be16 pad1;\n\tu8 list;  \n\tu8 flags;\n\n\ts8 type;\n\ts8 convert_type;\n\ts8 highest_blocked;\n\tu8 node;\n};  \n\nstruct dlm_lock\n{\n\tstruct dlm_migratable_lock ml;\n\n\tstruct list_head list;\n\tstruct list_head ast_list;\n\tstruct list_head bast_list;\n\tstruct dlm_lock_resource *lockres;\n\tspinlock_t spinlock;\n\tstruct kref lock_refs;\n\n\t\n\tdlm_astlockfunc_t *ast;\n\tdlm_bastlockfunc_t *bast;\n\tvoid *astdata;\n\tstruct dlm_lockstatus *lksb;\n\tunsigned ast_pending:1,\n\t\t bast_pending:1,\n\t\t convert_pending:1,\n\t\t lock_pending:1,\n\t\t cancel_pending:1,\n\t\t unlock_pending:1,\n\t\t lksb_kernel_allocated:1;\n};\n\nenum dlm_lockres_list {\n\tDLM_GRANTED_LIST = 0,\n\tDLM_CONVERTING_LIST = 1,\n\tDLM_BLOCKED_LIST = 2,\n};\n\nstatic inline int dlm_lvb_is_empty(char *lvb)\n{\n\tint i;\n\tfor (i=0; i<DLM_LVB_LEN; i++)\n\t\tif (lvb[i])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic inline char *dlm_list_in_text(enum dlm_lockres_list idx)\n{\n\tif (idx == DLM_GRANTED_LIST)\n\t\treturn \"granted\";\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\treturn \"converting\";\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\treturn \"blocked\";\n\telse\n\t\treturn \"unknown\";\n}\n\nstatic inline struct list_head *\ndlm_list_idx_to_ptr(struct dlm_lock_resource *res, enum dlm_lockres_list idx)\n{\n\tstruct list_head *ret = NULL;\n\tif (idx == DLM_GRANTED_LIST)\n\t\tret = &res->granted;\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\tret = &res->converting;\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\tret = &res->blocked;\n\telse\n\t\tBUG();\n\treturn ret;\n}\n\n\n\n\nstruct dlm_node_iter\n{\n\tunsigned long node_map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint curnode;\n};\n\n\nenum {\n\tDLM_MASTER_REQUEST_MSG\t\t= 500,\n\tDLM_UNUSED_MSG1\t\t\t= 501,\n\tDLM_ASSERT_MASTER_MSG\t\t= 502,\n\tDLM_CREATE_LOCK_MSG\t\t= 503,\n\tDLM_CONVERT_LOCK_MSG\t\t= 504,\n\tDLM_PROXY_AST_MSG\t\t= 505,\n\tDLM_UNLOCK_LOCK_MSG\t\t= 506,\n\tDLM_DEREF_LOCKRES_MSG\t\t= 507,\n\tDLM_MIGRATE_REQUEST_MSG\t\t= 508,\n\tDLM_MIG_LOCKRES_MSG\t\t= 509,\n\tDLM_QUERY_JOIN_MSG\t\t= 510,\n\tDLM_ASSERT_JOINED_MSG\t\t= 511,\n\tDLM_CANCEL_JOIN_MSG\t\t= 512,\n\tDLM_EXIT_DOMAIN_MSG\t\t= 513,\n\tDLM_MASTER_REQUERY_MSG\t\t= 514,\n\tDLM_LOCK_REQUEST_MSG\t\t= 515,\n\tDLM_RECO_DATA_DONE_MSG\t\t= 516,\n\tDLM_BEGIN_RECO_MSG\t\t= 517,\n\tDLM_FINALIZE_RECO_MSG\t\t= 518,\n\tDLM_QUERY_REGION\t\t= 519,\n\tDLM_QUERY_NODEINFO\t\t= 520,\n\tDLM_BEGIN_EXIT_DOMAIN_MSG\t= 521,\n\tDLM_DEREF_LOCKRES_DONE\t\t= 522,\n};\n\nstruct dlm_reco_node_data\n{\n\tint state;\n\tu8 node_num;\n\tstruct list_head list;\n};\n\nenum {\n\tDLM_RECO_NODE_DATA_DEAD = -1,\n\tDLM_RECO_NODE_DATA_INIT = 0,\n\tDLM_RECO_NODE_DATA_REQUESTING = 1,\n\tDLM_RECO_NODE_DATA_REQUESTED = 2,\n\tDLM_RECO_NODE_DATA_RECEIVING = 3,\n\tDLM_RECO_NODE_DATA_DONE = 4,\n\tDLM_RECO_NODE_DATA_FINALIZE_SENT = 5,\n};\n\n\nenum {\n\tDLM_MASTER_RESP_NO = 0,\n\tDLM_MASTER_RESP_YES = 1,\n\tDLM_MASTER_RESP_MAYBE = 2,\n\tDLM_MASTER_RESP_ERROR = 3,\n};\n\n\nstruct dlm_master_request\n{\n\tu8 node_idx;\n\tu8 namelen;\n\t__be16 pad1;\n\t__be32 flags;\n\n\tu8 name[O2NM_MAX_NAME_LEN];\n};\n\n#define DLM_ASSERT_RESPONSE_REASSERT       0x00000001\n#define DLM_ASSERT_RESPONSE_MASTERY_REF    0x00000002\n\n#define DLM_ASSERT_MASTER_MLE_CLEANUP      0x00000001\n#define DLM_ASSERT_MASTER_REQUERY          0x00000002\n#define DLM_ASSERT_MASTER_FINISH_MIGRATION 0x00000004\nstruct dlm_assert_master\n{\n\tu8 node_idx;\n\tu8 namelen;\n\t__be16 pad1;\n\t__be32 flags;\n\n\tu8 name[O2NM_MAX_NAME_LEN];\n};\n\n#define DLM_MIGRATE_RESPONSE_MASTERY_REF   0x00000001\n\nstruct dlm_migrate_request\n{\n\tu8 master;\n\tu8 new_master;\n\tu8 namelen;\n\tu8 pad1;\n\t__be32 pad2;\n\tu8 name[O2NM_MAX_NAME_LEN];\n};\n\nstruct dlm_master_requery\n{\n\tu8 pad1;\n\tu8 pad2;\n\tu8 node_idx;\n\tu8 namelen;\n\t__be32 pad3;\n\tu8 name[O2NM_MAX_NAME_LEN];\n};\n\n#define DLM_MRES_RECOVERY   0x01\n#define DLM_MRES_MIGRATION  0x02\n#define DLM_MRES_ALL_DONE   0x04\n\n \n#define DLM_MAX_MIGRATABLE_LOCKS   240\n\nstruct dlm_migratable_lockres\n{\n\tu8 master;\n\tu8 lockname_len;\n\tu8 num_locks;    \n\tu8 flags;\n\t__be32 total_locks; \n\t__be64 mig_cookie;  \n\t\t\t \n\t\n\tu8 lockname[DLM_LOCKID_NAME_MAX];\n\t\n\tu8 lvb[DLM_LVB_LEN];\n\t\n\tstruct dlm_migratable_lock ml[];  \n};\n#define DLM_MIG_LOCKRES_MAX_LEN  \\\n\t(sizeof(struct dlm_migratable_lockres) + \\\n\t (sizeof(struct dlm_migratable_lock) * \\\n\t  DLM_MAX_MIGRATABLE_LOCKS) )\n\n \n#define DLM_MIG_LOCKRES_RESERVED   (O2NET_MAX_PAYLOAD_BYTES - \\\n\t\t\t\t    DLM_MIG_LOCKRES_MAX_LEN)\n\nstruct dlm_create_lock\n{\n\t__be64 cookie;\n\n\t__be32 flags;\n\tu8 pad1;\n\tu8 node_idx;\n\ts8 requested_type;\n\tu8 namelen;\n\n\tu8 name[O2NM_MAX_NAME_LEN];\n};\n\nstruct dlm_convert_lock\n{\n\t__be64 cookie;\n\n\t__be32 flags;\n\tu8 pad1;\n\tu8 node_idx;\n\ts8 requested_type;\n\tu8 namelen;\n\n\tu8 name[O2NM_MAX_NAME_LEN];\n\n\ts8 lvb[];\n};\n#define DLM_CONVERT_LOCK_MAX_LEN  (sizeof(struct dlm_convert_lock)+DLM_LVB_LEN)\n\nstruct dlm_unlock_lock\n{\n\t__be64 cookie;\n\n\t__be32 flags;\n\t__be16 pad1;\n\tu8 node_idx;\n\tu8 namelen;\n\n\tu8 name[O2NM_MAX_NAME_LEN];\n\n\ts8 lvb[];\n};\n#define DLM_UNLOCK_LOCK_MAX_LEN  (sizeof(struct dlm_unlock_lock)+DLM_LVB_LEN)\n\nstruct dlm_proxy_ast\n{\n\t__be64 cookie;\n\n\t__be32 flags;\n\tu8 node_idx;\n\tu8 type;\n\tu8 blocked_type;\n\tu8 namelen;\n\n\tu8 name[O2NM_MAX_NAME_LEN];\n\n\ts8 lvb[];\n};\n#define DLM_PROXY_AST_MAX_LEN  (sizeof(struct dlm_proxy_ast)+DLM_LVB_LEN)\n\n#define DLM_MOD_KEY (0x666c6172)\nenum dlm_query_join_response_code {\n\tJOIN_DISALLOW = 0,\n\tJOIN_OK = 1,\n\tJOIN_OK_NO_MAP = 2,\n\tJOIN_PROTOCOL_MISMATCH = 3,\n};\n\nstruct dlm_query_join_packet {\n\tu8 code;\t \n\tu8 dlm_minor;\t \n\tu8 fs_minor;\t \n\tu8 reserved;\n};\n\nunion dlm_query_join_response {\n\t__be32 intval;\n\tstruct dlm_query_join_packet packet;\n};\n\nstruct dlm_lock_request\n{\n\tu8 node_idx;\n\tu8 dead_node;\n\t__be16 pad1;\n\t__be32 pad2;\n};\n\nstruct dlm_reco_data_done\n{\n\tu8 node_idx;\n\tu8 dead_node;\n\t__be16 pad1;\n\t__be32 pad2;\n\n\t \n\t \n\tu8 reco_lvb[DLM_LVB_LEN];\n};\n\nstruct dlm_begin_reco\n{\n\tu8 node_idx;\n\tu8 dead_node;\n\t__be16 pad1;\n\t__be32 pad2;\n};\n\nstruct dlm_query_join_request\n{\n\tu8 node_idx;\n\tu8 pad1[2];\n\tu8 name_len;\n\tstruct dlm_protocol_version dlm_proto;\n\tstruct dlm_protocol_version fs_proto;\n\tu8 domain[O2NM_MAX_NAME_LEN];\n\tu8 node_map[BITS_TO_BYTES(O2NM_MAX_NODES)];\n};\n\nstruct dlm_assert_joined\n{\n\tu8 node_idx;\n\tu8 pad1[2];\n\tu8 name_len;\n\tu8 domain[O2NM_MAX_NAME_LEN];\n};\n\nstruct dlm_cancel_join\n{\n\tu8 node_idx;\n\tu8 pad1[2];\n\tu8 name_len;\n\tu8 domain[O2NM_MAX_NAME_LEN];\n};\n\nstruct dlm_query_region {\n\tu8 qr_node;\n\tu8 qr_numregions;\n\tu8 qr_namelen;\n\tu8 pad1;\n\tu8 qr_domain[O2NM_MAX_NAME_LEN];\n\tu8 qr_regions[O2HB_MAX_REGION_NAME_LEN * O2NM_MAX_REGIONS];\n};\n\nstruct dlm_node_info {\n\tu8 ni_nodenum;\n\tu8 pad1;\n\t__be16 ni_ipv4_port;\n\t__be32 ni_ipv4_address;\n};\n\nstruct dlm_query_nodeinfo {\n\tu8 qn_nodenum;\n\tu8 qn_numnodes;\n\tu8 qn_namelen;\n\tu8 pad1;\n\tu8 qn_domain[O2NM_MAX_NAME_LEN];\n\tstruct dlm_node_info qn_nodes[O2NM_MAX_NODES];\n};\n\nstruct dlm_exit_domain\n{\n\tu8 node_idx;\n\tu8 pad1[3];\n};\n\nstruct dlm_finalize_reco\n{\n\tu8 node_idx;\n\tu8 dead_node;\n\tu8 flags;\n\tu8 pad1;\n\t__be32 pad2;\n};\n\nstruct dlm_deref_lockres\n{\n\tu32 pad1;\n\tu16 pad2;\n\tu8 node_idx;\n\tu8 namelen;\n\n\tu8 name[O2NM_MAX_NAME_LEN];\n};\n\nenum {\n\tDLM_DEREF_RESPONSE_DONE = 0,\n\tDLM_DEREF_RESPONSE_INPROG = 1,\n};\n\nstruct dlm_deref_lockres_done {\n\tu32 pad1;\n\tu16 pad2;\n\tu8 node_idx;\n\tu8 namelen;\n\n\tu8 name[O2NM_MAX_NAME_LEN];\n};\n\nstatic inline enum dlm_status\n__dlm_lockres_state_to_status(struct dlm_lock_resource *res)\n{\n\tenum dlm_status status = DLM_NORMAL;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tif (res->state & (DLM_LOCK_RES_RECOVERING|\n\t\t\tDLM_LOCK_RES_RECOVERY_WAITING))\n\t\tstatus = DLM_RECOVERING;\n\telse if (res->state & DLM_LOCK_RES_MIGRATING)\n\t\tstatus = DLM_MIGRATING;\n\telse if (res->state & DLM_LOCK_RES_IN_PROGRESS)\n\t\tstatus = DLM_FORWARD;\n\n\treturn status;\n}\n\nstatic inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}\n\nstatic inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}\n\nstruct dlm_lock * dlm_new_lock(int type, u8 node, u64 cookie,\n\t\t\t       struct dlm_lockstatus *lksb);\nvoid dlm_lock_get(struct dlm_lock *lock);\nvoid dlm_lock_put(struct dlm_lock *lock);\n\nvoid dlm_lock_attach_lockres(struct dlm_lock *lock,\n\t\t\t     struct dlm_lock_resource *res);\n\nint dlm_create_lock_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t    void **ret_data);\nint dlm_convert_lock_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t     void **ret_data);\nint dlm_proxy_ast_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t  void **ret_data);\n\nvoid dlm_revert_pending_convert(struct dlm_lock_resource *res,\n\t\t\t\tstruct dlm_lock *lock);\nvoid dlm_revert_pending_lock(struct dlm_lock_resource *res,\n\t\t\t     struct dlm_lock *lock);\n\nint dlm_unlock_lock_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t    void **ret_data);\nvoid dlm_commit_pending_cancel(struct dlm_lock_resource *res,\n\t\t\t       struct dlm_lock *lock);\nvoid dlm_commit_pending_unlock(struct dlm_lock_resource *res,\n\t\t\t       struct dlm_lock *lock);\n\nint dlm_launch_thread(struct dlm_ctxt *dlm);\nvoid dlm_complete_thread(struct dlm_ctxt *dlm);\nint dlm_launch_recovery_thread(struct dlm_ctxt *dlm);\nvoid dlm_complete_recovery_thread(struct dlm_ctxt *dlm);\nvoid dlm_wait_for_recovery(struct dlm_ctxt *dlm);\nvoid dlm_kick_recovery_thread(struct dlm_ctxt *dlm);\nint dlm_is_node_dead(struct dlm_ctxt *dlm, u8 node);\nvoid dlm_wait_for_node_death(struct dlm_ctxt *dlm, u8 node, int timeout);\nvoid dlm_wait_for_node_recovery(struct dlm_ctxt *dlm, u8 node, int timeout);\n\nvoid dlm_put(struct dlm_ctxt *dlm);\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm);\nint dlm_domain_fully_joined(struct dlm_ctxt *dlm);\n\nvoid __dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_lock_resource *res);\nvoid dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res);\nstatic inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t \n\tkref_get(&res->refs);\n}\nvoid dlm_lockres_put(struct dlm_lock_resource *res);\nvoid __dlm_unhash_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res);\nvoid __dlm_insert_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res);\nstruct dlm_lock_resource * __dlm_lookup_lockres_full(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t     const char *name,\n\t\t\t\t\t\t     unsigned int len,\n\t\t\t\t\t\t     unsigned int hash);\nstruct dlm_lock_resource * __dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tunsigned int hash);\nstruct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t\t      const char *name,\n\t\t\t\t\t      unsigned int len);\n\nint dlm_is_host_down(int errno);\n\nstruct dlm_lock_resource * dlm_get_lock_resource(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t const char *lockid,\n\t\t\t\t\t\t int namelen,\n\t\t\t\t\t\t int flags);\nstruct dlm_lock_resource *dlm_new_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  unsigned int namelen);\n\nvoid dlm_lockres_set_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res, int bit);\nvoid dlm_lockres_clear_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res, int bit);\n\nvoid dlm_lockres_drop_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res);\nvoid dlm_lockres_grab_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res);\n\nvoid __dlm_lockres_grab_inflight_worker(struct dlm_ctxt *dlm,\n\t\tstruct dlm_lock_resource *res);\n\nvoid dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\nvoid __dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\nvoid __dlm_queue_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\nvoid dlm_do_local_ast(struct dlm_ctxt *dlm,\n\t\t      struct dlm_lock_resource *res,\n\t\t      struct dlm_lock *lock);\nint dlm_do_remote_ast(struct dlm_ctxt *dlm,\n\t\t      struct dlm_lock_resource *res,\n\t\t      struct dlm_lock *lock);\nvoid dlm_do_local_bast(struct dlm_ctxt *dlm,\n\t\t       struct dlm_lock_resource *res,\n\t\t       struct dlm_lock *lock,\n\t\t       int blocked_type);\nint dlm_send_proxy_ast_msg(struct dlm_ctxt *dlm,\n\t\t\t   struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock,\n\t\t\t   int msg_type,\n\t\t\t   int blocked_type, int flags);\nstatic inline int dlm_send_proxy_bast(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t      int blocked_type)\n{\n\treturn dlm_send_proxy_ast_msg(dlm, res, lock, DLM_BAST,\n\t\t\t\t      blocked_type, 0);\n}\n\nstatic inline int dlm_send_proxy_ast(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_lock *lock,\n\t\t\t\t     int flags)\n{\n\treturn dlm_send_proxy_ast_msg(dlm, res, lock, DLM_AST,\n\t\t\t\t      0, flags);\n}\n\nvoid dlm_print_one_lock_resource(struct dlm_lock_resource *res);\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res);\n\nvoid dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res);\nvoid __dlm_dirty_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res);\n\n\nvoid dlm_hb_node_down_cb(struct o2nm_node *node, int idx, void *data);\nvoid dlm_hb_node_up_cb(struct o2nm_node *node, int idx, void *data);\n\nint dlm_empty_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res);\nint dlm_finish_migration(struct dlm_ctxt *dlm,\n\t\t\t struct dlm_lock_resource *res,\n\t\t\t u8 old_master);\nvoid dlm_lockres_release_ast(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res);\nvoid __dlm_lockres_reserve_ast(struct dlm_lock_resource *res);\n\nint dlm_master_request_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t       void **ret_data);\nint dlm_assert_master_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t      void **ret_data);\nvoid dlm_assert_master_post_handler(int status, void *data, void *ret_data);\nint dlm_deref_lockres_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t      void **ret_data);\nint dlm_deref_lockres_done_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t      void **ret_data);\nint dlm_migrate_request_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\tvoid **ret_data);\nint dlm_mig_lockres_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t    void **ret_data);\nint dlm_master_requery_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t       void **ret_data);\nint dlm_request_all_locks_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data);\nint dlm_reco_data_done_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t       void **ret_data);\nint dlm_begin_reco_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t   void **ret_data);\nint dlm_finalize_reco_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t      void **ret_data);\nint dlm_do_master_requery(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t  u8 nodenum, u8 *real_master);\n\nvoid __dlm_do_purge_lockres(struct dlm_ctxt *dlm,\n\t\tstruct dlm_lock_resource *res);\n\nint dlm_dispatch_assert_master(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_lock_resource *res,\n\t\t\t       int ignore_higher,\n\t\t\t       u8 request_from,\n\t\t\t       u32 flags);\n\n\nint dlm_send_one_lockres(struct dlm_ctxt *dlm,\n\t\t\t struct dlm_lock_resource *res,\n\t\t\t struct dlm_migratable_lockres *mres,\n\t\t\t u8 send_to,\n\t\t\t u8 flags);\nvoid dlm_move_lockres_to_recovery_list(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\n \nvoid __dlm_wait_on_lockres_flags(struct dlm_lock_resource *res, int flags);\n\n \nstatic inline void __dlm_wait_on_lockres(struct dlm_lock_resource *res)\n{\n\t__dlm_wait_on_lockres_flags(res, (DLM_LOCK_RES_IN_PROGRESS|\n\t\t\t\t    \t  DLM_LOCK_RES_RECOVERING|\n\t\t\t\t\t  DLM_LOCK_RES_RECOVERY_WAITING|\n\t\t\t\t\t  DLM_LOCK_RES_MIGRATING));\n}\n\nvoid __dlm_unlink_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle);\nvoid __dlm_insert_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle);\n\n \nint dlm_init_master_caches(void);\nvoid dlm_destroy_master_caches(void);\n\nint dlm_init_lock_cache(void);\nvoid dlm_destroy_lock_cache(void);\n\nint dlm_init_mle_cache(void);\nvoid dlm_destroy_mle_cache(void);\n\nvoid dlm_hb_event_notify_attached(struct dlm_ctxt *dlm, int idx, int node_up);\nint dlm_drop_lockres_ref(struct dlm_ctxt *dlm,\n\t\t\t struct dlm_lock_resource *res);\nvoid dlm_clean_master_list(struct dlm_ctxt *dlm,\n\t\t\t   u8 dead_node);\nvoid dlm_force_free_mles(struct dlm_ctxt *dlm);\nint dlm_lock_basts_flushed(struct dlm_ctxt *dlm, struct dlm_lock *lock);\nint __dlm_lockres_has_locks(struct dlm_lock_resource *res);\nint __dlm_lockres_unused(struct dlm_lock_resource *res);\n\nstatic inline const char * dlm_lock_mode_name(int mode)\n{\n\tswitch (mode) {\n\t\tcase LKM_EXMODE:\n\t\t\treturn \"EX\";\n\t\tcase LKM_PRMODE:\n\t\t\treturn \"PR\";\n\t\tcase LKM_NLMODE:\n\t\t\treturn \"NL\";\n\t}\n\treturn \"UNKNOWN\";\n}\n\n\nstatic inline int dlm_lock_compatible(int existing, int request)\n{\n\t \n\tif (request == LKM_NLMODE ||\n\t    existing == LKM_NLMODE)\n\t\treturn 1;\n\n\t \n\tif (request == LKM_EXMODE)\n\t\treturn 0;\n\n\t \n\tif (existing == LKM_PRMODE)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic inline int dlm_lock_on_list(struct list_head *head,\n\t\t\t\t   struct dlm_lock *lock)\n{\n\tstruct dlm_lock *tmplock;\n\n\tlist_for_each_entry(tmplock, head, list) {\n\t\tif (tmplock == lock)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nstatic inline enum dlm_status dlm_err_to_dlm_status(int err)\n{\n\tenum dlm_status ret;\n\tif (err == -ENOMEM)\n\t\tret = DLM_SYSERR;\n\telse if (err == -ETIMEDOUT || o2net_link_down(err, NULL))\n\t\tret = DLM_NOLOCKMGR;\n\telse if (err == -EINVAL)\n\t\tret = DLM_BADPARAM;\n\telse if (err == -ENAMETOOLONG)\n\t\tret = DLM_IVBUFLEN;\n\telse\n\t\tret = DLM_BADARGS;\n\treturn ret;\n}\n\n\nstatic inline void dlm_node_iter_init(unsigned long *map,\n\t\t\t\t      struct dlm_node_iter *iter)\n{\n\tbitmap_copy(iter->node_map, map, O2NM_MAX_NODES);\n\titer->curnode = -1;\n}\n\nstatic inline int dlm_node_iter_next(struct dlm_node_iter *iter)\n{\n\tint bit;\n\tbit = find_next_bit(iter->node_map, O2NM_MAX_NODES, iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\titer->curnode = bit;\n\treturn bit;\n}\n\nstatic inline void dlm_set_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tres->owner = owner;\n}\n\nstatic inline void dlm_change_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t\t    u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tif (owner != res->owner)\n\t\tdlm_set_lockres_owner(dlm, res, owner);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}