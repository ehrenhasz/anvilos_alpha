{
  "module_name": "dlmconvert.c",
  "hash_id": "db4dd877768bc108c2abf2ab65155c4a4820adf3e048021e1ff7f5ec5c5da15e",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/dlm/dlmconvert.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/socket.h>\n#include <linux/inet.h>\n#include <linux/spinlock.h>\n\n\n#include \"../cluster/heartbeat.h\"\n#include \"../cluster/nodemanager.h\"\n#include \"../cluster/tcp.h\"\n\n#include \"dlmapi.h\"\n#include \"dlmcommon.h\"\n\n#include \"dlmconvert.h\"\n\n#define MLOG_MASK_PREFIX ML_DLM\n#include \"../cluster/masklog.h\"\n\n \nstatic enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread);\nstatic enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);\n\n \nenum dlm_status dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t  struct dlm_lock *lock, int flags, int type)\n{\n\tint call_ast = 0, kick_thread = 0;\n\tenum dlm_status status;\n\n\tspin_lock(&res->spinlock);\n\t \n\t__dlm_wait_on_lockres(res);\n\t__dlm_lockres_reserve_ast(res);\n\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\n\tstatus = __dlmconvert_master(dlm, res, lock, flags, type,\n\t\t\t\t     &call_ast, &kick_thread);\n\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\tif (status != DLM_NORMAL && status != DLM_NOTQUEUED)\n\t\tdlm_error(status);\n\n\t \n\tif (call_ast)\n\t\tdlm_queue_ast(dlm, lock);\n\telse\n\t\tdlm_lockres_release_ast(dlm, res);\n\n\tif (kick_thread)\n\t\tdlm_kick_thread(dlm, res);\n\n\treturn status;\n}\n\n \nstatic enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread)\n{\n\tenum dlm_status status = DLM_NORMAL;\n\tstruct dlm_lock *tmplock=NULL;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"type=%d, convert_type=%d, new convert_type=%d\\n\",\n\t     lock->ml.type, lock->ml.convert_type, type);\n\n\tspin_lock(&lock->spinlock);\n\n\t \n\tif (lock->ml.convert_type != LKM_IVMODE) {\n\t\tmlog(ML_ERROR, \"attempted to convert a lock with a lock \"\n\t\t     \"conversion pending\\n\");\n\t\tstatus = DLM_DENIED;\n\t\tgoto unlock_exit;\n\t}\n\n\t \n\tif (!dlm_lock_on_list(&res->granted, lock)) {\n\t\tmlog(ML_ERROR, \"attempted to convert a lock not on grant \"\n\t\t     \"queue\\n\");\n\t\tstatus = DLM_DENIED;\n\t\tgoto unlock_exit;\n\t}\n\n\tif (flags & LKM_VALBLK) {\n\t\tswitch (lock->ml.type) {\n\t\t\tcase LKM_EXMODE:\n\t\t\t\t \n\t\t\t\tmlog(0, \"will set lvb: converting %s->%s\\n\",\n\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_PUT_LVB;\n\t\t\t\tbreak;\n\t\t\tcase LKM_PRMODE:\n\t\t\tcase LKM_NLMODE:\n\t\t\t\t \n\t\t\t\tif (type > LKM_NLMODE) {\n\t\t\t\t\tmlog(0, \"will fetch new value into \"\n\t\t\t\t\t     \"lvb: converting %s->%s\\n\",\n\t\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t\t} else {\n\t\t\t\t\tmlog(0, \"will NOT fetch new value \"\n\t\t\t\t\t     \"into lvb: converting %s->%s\\n\",\n\t\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\t\tflags &= ~(LKM_VALBLK);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t \n\tif (type <= lock->ml.type)\n\t\tgoto grant;\n\n\t \n\tstatus = DLM_NORMAL;\n\tlist_for_each_entry(tmplock, &res->granted, list) {\n\t\tif (tmplock == lock)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, type))\n\t\t\tgoto switch_queues;\n\t}\n\n\tlist_for_each_entry(tmplock, &res->converting, list) {\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, type))\n\t\t\tgoto switch_queues;\n\t\t \n\t\tif (!dlm_lock_compatible(tmplock->ml.convert_type, type))\n\t\t\tgoto switch_queues;\n\t}\n\n\t \n\ngrant:\n\tmlog(0, \"res %.*s, granting %s lock\\n\", res->lockname.len,\n\t     res->lockname.name, dlm_lock_mode_name(type));\n\t \n\tlock->lksb->status = DLM_NORMAL;\n\tif (lock->ml.node == dlm->node_num)\n\t\tmlog(0, \"doing in-place convert for nonlocal lock\\n\");\n\tlock->ml.type = type;\n\tif (lock->lksb->flags & DLM_LKSB_PUT_LVB)\n\t\tmemcpy(res->lvb, lock->lksb->lvb, DLM_LVB_LEN);\n\n\t \n\tlist_move_tail(&lock->list, &res->granted);\n\n\tstatus = DLM_NORMAL;\n\t*call_ast = 1;\n\tgoto unlock_exit;\n\nswitch_queues:\n\tif (flags & LKM_NOQUEUE) {\n\t\tmlog(0, \"failed to convert NOQUEUE lock %.*s from \"\n\t\t     \"%d to %d...\\n\", res->lockname.len, res->lockname.name,\n\t\t     lock->ml.type, type);\n\t\tstatus = DLM_NOTQUEUED;\n\t\tgoto unlock_exit;\n\t}\n\tmlog(0, \"res %.*s, queueing...\\n\", res->lockname.len,\n\t     res->lockname.name);\n\n\tlock->ml.convert_type = type;\n\t \n\tlist_move_tail(&lock->list, &res->converting);\n\nunlock_exit:\n\tspin_unlock(&lock->spinlock);\n\tif (status == DLM_DENIED) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tif (status == DLM_NORMAL)\n\t\t*kick_thread = 1;\n\treturn status;\n}\n\nvoid dlm_revert_pending_convert(struct dlm_lock_resource *res,\n\t\t\t\tstruct dlm_lock *lock)\n{\n\t \n\tlist_move_tail(&lock->list, &res->granted);\n\tlock->ml.convert_type = LKM_IVMODE;\n\tlock->lksb->flags &= ~(DLM_LKSB_GET_LVB|DLM_LKSB_PUT_LVB);\n}\n\n \nenum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t  struct dlm_lock *lock, int flags, int type)\n{\n\tenum dlm_status status;\n\n\tmlog(0, \"type=%d, convert_type=%d, busy=%d\\n\", lock->ml.type,\n\t     lock->ml.convert_type, res->state & DLM_LOCK_RES_IN_PROGRESS);\n\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\tmlog(0, \"bailing out early since res is RECOVERING \"\n\t\t     \"on secondary queue\\n\");\n\t\t \n\t\tstatus = DLM_RECOVERING;\n\t\tgoto bail;\n\t}\n\t \n\t__dlm_wait_on_lockres(res);\n\n\tif (lock->ml.convert_type != LKM_IVMODE) {\n\t\t__dlm_print_one_lock_resource(res);\n\t\tmlog(ML_ERROR, \"converting a remote lock that is already \"\n\t\t     \"converting! (cookie=%u:%llu, conv=%d)\\n\",\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     lock->ml.convert_type);\n\t\tstatus = DLM_DENIED;\n\t\tgoto bail;\n\t}\n\n\tif (lock->ml.type == type && lock->ml.convert_type == LKM_IVMODE) {\n\t\tmlog(0, \"last convert request returned DLM_RECOVERING, but \"\n\t\t     \"owner has already queued and sent ast to me. res %.*s, \"\n\t\t     \"(cookie=%u:%llu, type=%d, conv=%d)\\n\",\n\t\t     res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     lock->ml.type, lock->ml.convert_type);\n\t\tstatus = DLM_NORMAL;\n\t\tgoto bail;\n\t}\n\n\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\t \n\t \n\tlist_move_tail(&lock->list, &res->converting);\n\tlock->convert_pending = 1;\n\tlock->ml.convert_type = type;\n\n\tif (flags & LKM_VALBLK) {\n\t\tif (lock->ml.type == LKM_EXMODE) {\n\t\t\tflags |= LKM_PUT_LVB;\n\t\t\tlock->lksb->flags |= DLM_LKSB_PUT_LVB;\n\t\t} else {\n\t\t\tif (lock->ml.convert_type == LKM_NLMODE)\n\t\t\t\tflags &= ~LKM_VALBLK;\n\t\t\telse {\n\t\t\t\tflags |= LKM_GET_LVB;\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&res->spinlock);\n\n\t \n\tstatus = dlm_send_remote_convert_request(dlm, res, lock, flags, type);\n\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\t \n\tif (status != DLM_NORMAL) {\n\t\tif (status != DLM_NOTQUEUED)\n\t\t\tdlm_error(status);\n\t\tdlm_revert_pending_convert(res, lock);\n\t} else if (!lock->convert_pending) {\n\t\tmlog(0, \"%s: res %.*s, owner died and lock has been moved back \"\n\t\t\t\t\"to granted list, retry convert.\\n\",\n\t\t\t\tdlm->name, res->lockname.len, res->lockname.name);\n\t\tstatus = DLM_RECOVERING;\n\t}\n\n\tlock->convert_pending = 0;\nbail:\n\tspin_unlock(&res->spinlock);\n\n\t \n\t \n\twake_up(&res->wq);\n\n\treturn status;\n}\n\n \nstatic enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type)\n{\n\tstruct dlm_convert_lock convert;\n\tint tmpret;\n\tenum dlm_status ret;\n\tint status = 0;\n\tstruct kvec vec[2];\n\tsize_t veclen = 1;\n\n\tmlog(0, \"%.*s\\n\", res->lockname.len, res->lockname.name);\n\n\tmemset(&convert, 0, sizeof(struct dlm_convert_lock));\n\tconvert.node_idx = dlm->node_num;\n\tconvert.requested_type = type;\n\tconvert.cookie = lock->ml.cookie;\n\tconvert.namelen = res->lockname.len;\n\tconvert.flags = cpu_to_be32(flags);\n\tmemcpy(convert.name, res->lockname.name, convert.namelen);\n\n\tvec[0].iov_len = sizeof(struct dlm_convert_lock);\n\tvec[0].iov_base = &convert;\n\n\tif (flags & LKM_PUT_LVB) {\n\t\t \n\t\tvec[1].iov_len = DLM_LVB_LEN;\n\t\tvec[1].iov_base = lock->lksb->lvb;\n\t\tveclen++;\n\t}\n\n\ttmpret = o2net_send_message_vec(DLM_CONVERT_LOCK_MSG, dlm->key,\n\t\t\t\t\tvec, veclen, res->owner, &status);\n\tif (tmpret >= 0) {\n\t\t\n\t\tret = status;  \n\t\tif (ret == DLM_RECOVERING) {\n\t\t\tmlog(0, \"node %u returned DLM_RECOVERING from convert \"\n\t\t\t     \"message!\\n\", res->owner);\n\t\t} else if (ret == DLM_MIGRATING) {\n\t\t\tmlog(0, \"node %u returned DLM_MIGRATING from convert \"\n\t\t\t     \"message!\\n\", res->owner);\n\t\t} else if (ret == DLM_FORWARD) {\n\t\t\tmlog(0, \"node %u returned DLM_FORWARD from convert \"\n\t\t\t     \"message!\\n\", res->owner);\n\t\t} else if (ret != DLM_NORMAL && ret != DLM_NOTQUEUED)\n\t\t\tdlm_error(ret);\n\t} else {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", tmpret, DLM_CONVERT_LOCK_MSG, dlm->key,\n\t\t     res->owner);\n\t\tif (dlm_is_host_down(tmpret)) {\n\t\t\t \n\t\t\tdlm_wait_for_node_death(dlm, res->owner,\n\t\t\t\t\t\tDLM_NODE_DEATH_WAIT_MAX);\n\t\t\tret = DLM_RECOVERING;\n\t\t\tmlog(0, \"node %u died so returning DLM_RECOVERING \"\n\t\t\t     \"from convert message!\\n\", res->owner);\n\t\t} else {\n\t\t\tret = dlm_err_to_dlm_status(tmpret);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nint dlm_convert_lock_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t     void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_convert_lock *cnv = (struct dlm_convert_lock *)msg->buf;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *lock = NULL;\n\tstruct dlm_lock *tmp_lock;\n\tstruct dlm_lockstatus *lksb;\n\tenum dlm_status status = DLM_NORMAL;\n\tu32 flags;\n\tint call_ast = 0, kick_thread = 0, ast_reserved = 0, wake = 0;\n\n\tif (!dlm_grab(dlm)) {\n\t\tdlm_error(DLM_REJECTED);\n\t\treturn DLM_REJECTED;\n\t}\n\n\tmlog_bug_on_msg(!dlm_domain_fully_joined(dlm),\n\t\t\t\"Domain %s not fully joined!\\n\", dlm->name);\n\n\tif (cnv->namelen > DLM_LOCKID_NAME_MAX) {\n\t\tstatus = DLM_IVBUFLEN;\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\n\tflags = be32_to_cpu(cnv->flags);\n\n\tif ((flags & (LKM_PUT_LVB|LKM_GET_LVB)) ==\n\t     (LKM_PUT_LVB|LKM_GET_LVB)) {\n\t\tmlog(ML_ERROR, \"both PUT and GET lvb specified\\n\");\n\t\tstatus = DLM_BADARGS;\n\t\tgoto leave;\n\t}\n\n\tmlog(0, \"lvb: %s\\n\", flags & LKM_PUT_LVB ? \"put lvb\" :\n\t     (flags & LKM_GET_LVB ? \"get lvb\" : \"none\"));\n\n\tstatus = DLM_IVLOCKID;\n\tres = dlm_lookup_lockres(dlm, cnv->name, cnv->namelen);\n\tif (!res) {\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&res->spinlock);\n\tstatus = __dlm_lockres_state_to_status(res);\n\tif (status != DLM_NORMAL) {\n\t\tspin_unlock(&res->spinlock);\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\tlist_for_each_entry(tmp_lock, &res->granted, list) {\n\t\tif (tmp_lock->ml.cookie == cnv->cookie &&\n\t\t    tmp_lock->ml.node == cnv->node_idx) {\n\t\t\tlock = tmp_lock;\n\t\t\tdlm_lock_get(lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&res->spinlock);\n\tif (!lock) {\n\t\tstatus = DLM_IVLOCKID;\n\t\tmlog(ML_ERROR, \"did not find lock to convert on grant queue! \"\n\t\t\t       \"cookie=%u:%llu\\n\",\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(cnv->cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(cnv->cookie)));\n\t\tdlm_print_one_lock_resource(res);\n\t\tgoto leave;\n\t}\n\n\t \n\tlksb = lock->lksb;\n\n\t \n\tif (flags & LKM_PUT_LVB) {\n\t\tBUG_ON(lksb->flags & (DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB));\n\t\tlksb->flags |= DLM_LKSB_PUT_LVB;\n\t\tmemcpy(&lksb->lvb[0], &cnv->lvb[0], DLM_LVB_LEN);\n\t} else if (flags & LKM_GET_LVB) {\n\t\tBUG_ON(lksb->flags & (DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB));\n\t\tlksb->flags |= DLM_LKSB_GET_LVB;\n\t}\n\n\tspin_lock(&res->spinlock);\n\tstatus = __dlm_lockres_state_to_status(res);\n\tif (status == DLM_NORMAL) {\n\t\t__dlm_lockres_reserve_ast(res);\n\t\tast_reserved = 1;\n\t\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\t\tstatus = __dlmconvert_master(dlm, res, lock, flags,\n\t\t\t\t\t     cnv->requested_type,\n\t\t\t\t\t     &call_ast, &kick_thread);\n\t\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\t\twake = 1;\n\t}\n\tspin_unlock(&res->spinlock);\n\tif (wake)\n\t\twake_up(&res->wq);\n\n\tif (status != DLM_NORMAL) {\n\t\tif (status != DLM_NOTQUEUED)\n\t\t\tdlm_error(status);\n\t\tlksb->flags &= ~(DLM_LKSB_GET_LVB|DLM_LKSB_PUT_LVB);\n\t}\n\nleave:\n\tif (lock)\n\t\tdlm_lock_put(lock);\n\n\t \n\tif (call_ast)\n\t\tdlm_queue_ast(dlm, lock);\n\telse if (ast_reserved)\n\t\tdlm_lockres_release_ast(dlm, res);\n\n\tif (kick_thread)\n\t\tdlm_kick_thread(dlm, res);\n\n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\tdlm_put(dlm);\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}