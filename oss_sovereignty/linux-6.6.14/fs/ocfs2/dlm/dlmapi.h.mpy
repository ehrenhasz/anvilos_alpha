{
  "module_name": "dlmapi.h",
  "hash_id": "97dc3b396dbe8e2f12a15ab116f60f68dcefc388d6b0d53a836511a7e7472aa2",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/dlm/dlmapi.h",
  "human_readable_source": " \n \n\n#ifndef DLMAPI_H\n#define DLMAPI_H\n\nstruct dlm_lock;\nstruct dlm_ctxt;\n\n \nenum dlm_status {\n\tDLM_NORMAL = 0,            \n\tDLM_GRANTED,               \n\tDLM_DENIED,                \n\tDLM_DENIED_NOLOCKS,        \n\tDLM_WORKING,               \n\tDLM_BLOCKED,               \n\tDLM_BLOCKED_ORPHAN,        \n\tDLM_DENIED_GRACE_PERIOD,   \n\tDLM_SYSERR,                \n\tDLM_NOSUPPORT,             \n\tDLM_CANCELGRANT,           \n\tDLM_IVLOCKID,              \n\tDLM_SYNC,                  \n\tDLM_BADTYPE,               \n\tDLM_BADRESOURCE,           \n\tDLM_MAXHANDLES,            \n\tDLM_NOCLINFO,              \n\tDLM_NOLOCKMGR,             \n\tDLM_NOPURGED,              \n\tDLM_BADARGS,               \n\tDLM_VOID,                  \n\tDLM_NOTQUEUED,             \n\tDLM_IVBUFLEN,              \n\tDLM_CVTUNGRANT,            \n\tDLM_BADPARAM,              \n\tDLM_VALNOTVALID,           \n\tDLM_REJECTED,              \n\tDLM_ABORT,                 \n\tDLM_CANCEL,                \n\tDLM_IVRESHANDLE,           \n\tDLM_DEADLOCK,              \n\tDLM_DENIED_NOASTS,         \n\tDLM_FORWARD,               \n\tDLM_TIMEOUT,               \n\tDLM_IVGROUPID,             \n\tDLM_VERS_CONFLICT,         \n\tDLM_BAD_DEVICE_PATH,       \n\tDLM_NO_DEVICE_PERMISSION,  \n\tDLM_NO_CONTROL_DEVICE,     \n\n\tDLM_RECOVERING,            \n\tDLM_MIGRATING,             \n\tDLM_MAXSTATS,              \n};\n\n \nconst char *dlm_errmsg(enum dlm_status err);\n \nconst char *dlm_errname(enum dlm_status err);\n\n \n#define dlm_error(st) do {\t\t\t\t\t\t\\\n\tif ((st) != DLM_RECOVERING &&\t\t\t\t\t\\\n\t    (st) != DLM_MIGRATING &&\t\t\t\t\t\\\n\t    (st) != DLM_FORWARD)\t\t\t\t\t\\\n\t\tmlog(ML_ERROR, \"dlm status = %s\\n\", dlm_errname((st)));\t\\\n} while (0)\n\n#define DLM_LKSB_UNUSED1           0x01\n#define DLM_LKSB_PUT_LVB           0x02\n#define DLM_LKSB_GET_LVB           0x04\n#define DLM_LKSB_UNUSED2           0x08\n#define DLM_LKSB_UNUSED3           0x10\n#define DLM_LKSB_UNUSED4           0x20\n#define DLM_LKSB_UNUSED5           0x40\n#define DLM_LKSB_UNUSED6           0x80\n\n#define DLM_LVB_LEN  64\n\n \nstruct dlm_lockstatus {\n\tenum dlm_status status;\n\tu32 flags;\n\tstruct dlm_lock *lockid;\n\tchar lvb[DLM_LVB_LEN];\n};\n\n \n#define LKM_IVMODE      (-1)             \n#define LKM_NLMODE      0                \n#define LKM_CRMODE      1                \n#define LKM_CWMODE      2                \n#define LKM_PRMODE      3                \n#define LKM_PWMODE      4                \n#define LKM_EXMODE      5                \n#define LKM_MAXMODE     5\n#define LKM_MODEMASK    0xff\n\n \n#define LKM_ORPHAN       0x00000010   \n#define LKM_PARENTABLE   0x00000020   \n#define LKM_BLOCK        0x00000040   \n#define LKM_LOCAL        0x00000080   \n#define LKM_VALBLK       0x00000100   \n#define LKM_NOQUEUE      0x00000200   \n#define LKM_CONVERT      0x00000400   \n#define LKM_NODLCKWT     0x00000800   \n#define LKM_UNLOCK       0x00001000   \n#define LKM_CANCEL       0x00002000   \n#define LKM_DEQALL       0x00004000   \n#define LKM_INVVALBLK    0x00008000   \n#define LKM_SYNCSTS      0x00010000   \n#define LKM_TIMEOUT      0x00020000   \n#define LKM_SNGLDLCK     0x00040000   \n#define LKM_FINDLOCAL    0x00080000   \n#define LKM_PROC_OWNED   0x00100000   \n#define LKM_XID          0x00200000   \n#define LKM_XID_CONFLICT 0x00400000   \n#define LKM_FORCE        0x00800000   \n#define LKM_REVVALBLK    0x01000000   \n \n#define LKM_UNUSED1      0x00000001   \n#define LKM_UNUSED2      0x00000002   \n#define LKM_UNUSED3      0x00000004   \n#define LKM_UNUSED4      0x00000008   \n#define LKM_UNUSED5      0x02000000   \n#define LKM_UNUSED6      0x04000000   \n#define LKM_UNUSED7      0x08000000   \n\n \n#define LKM_MIGRATION    0x10000000   \n#define LKM_PUT_LVB      0x20000000   \n#define LKM_GET_LVB      0x40000000   \n#define LKM_RECOVERY     0x80000000   \n\n\ntypedef void (dlm_astlockfunc_t)(void *);\ntypedef void (dlm_bastlockfunc_t)(void *, int);\ntypedef void (dlm_astunlockfunc_t)(void *, enum dlm_status);\n\nenum dlm_status dlmlock(struct dlm_ctxt *dlm,\n\t\t\tint mode,\n\t\t\tstruct dlm_lockstatus *lksb,\n\t\t\tint flags,\n\t\t\tconst char *name,\n\t\t\tint namelen,\n\t\t\tdlm_astlockfunc_t *ast,\n\t\t\tvoid *data,\n\t\t\tdlm_bastlockfunc_t *bast);\n\nenum dlm_status dlmunlock(struct dlm_ctxt *dlm,\n\t\t\t  struct dlm_lockstatus *lksb,\n\t\t\t  int flags,\n\t\t\t  dlm_astunlockfunc_t *unlockast,\n\t\t\t  void *data);\n\nstruct dlm_protocol_version {\n\tu8 pv_major;\n\tu8 pv_minor;\n};\nstruct dlm_ctxt * dlm_register_domain(const char *domain, u32 key,\n\t\t\t\t      struct dlm_protocol_version *fs_proto);\n\nvoid dlm_unregister_domain(struct dlm_ctxt *dlm);\n\nvoid dlm_print_one_lock(struct dlm_lock *lockid);\n\ntypedef void (dlm_eviction_func)(int, void *);\nstruct dlm_eviction_cb {\n\tstruct list_head        ec_item;\n\tdlm_eviction_func       *ec_func;\n\tvoid                    *ec_data;\n};\nvoid dlm_setup_eviction_cb(struct dlm_eviction_cb *cb,\n\t\t\t   dlm_eviction_func *f,\n\t\t\t   void *data);\nvoid dlm_register_eviction_cb(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_eviction_cb *cb);\nvoid dlm_unregister_eviction_cb(struct dlm_eviction_cb *cb);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}