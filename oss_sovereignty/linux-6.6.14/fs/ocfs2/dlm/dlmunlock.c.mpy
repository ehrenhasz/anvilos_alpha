{
  "module_name": "dlmunlock.c",
  "hash_id": "83b103d0604586eb06f3792f93364ce8aa24eeb4912644698924e937ecef16d7",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/dlm/dlmunlock.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/socket.h>\n#include <linux/inet.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n\n#include \"../cluster/heartbeat.h\"\n#include \"../cluster/nodemanager.h\"\n#include \"../cluster/tcp.h\"\n\n#include \"dlmapi.h\"\n#include \"dlmcommon.h\"\n\n#define MLOG_MASK_PREFIX ML_DLM\n#include \"../cluster/masklog.h\"\n\n#define DLM_UNLOCK_FREE_LOCK           0x00000001\n#define DLM_UNLOCK_CALL_AST            0x00000002\n#define DLM_UNLOCK_REMOVE_LOCK         0x00000004\n#define DLM_UNLOCK_REGRANT_LOCK        0x00000008\n#define DLM_UNLOCK_CLEAR_CONVERT_TYPE  0x00000010\n\n\nstatic enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);\nstatic enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions);\n\nstatic enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);\n\n\n \n\n\n \nstatic enum dlm_status dlmunlock_common(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\t\tstruct dlm_lock *lock,\n\t\t\t\t\tstruct dlm_lockstatus *lksb,\n\t\t\t\t\tint flags, int *call_ast,\n\t\t\t\t\tint master_node)\n{\n\tenum dlm_status status;\n\tint actions = 0;\n\tint in_use;\n\tu8 owner;\n\tint recovery_wait = 0;\n\n\tmlog(0, \"master_node = %d, valblk = %d\\n\", master_node,\n\t     flags & LKM_VALBLK);\n\n\tif (master_node)\n\t\tBUG_ON(res->owner != dlm->node_num);\n\telse\n\t\tBUG_ON(res->owner == dlm->node_num);\n\n\tspin_lock(&dlm->ast_lock);\n\t \n\tin_use = !list_empty(&lock->ast_list);\n\tspin_unlock(&dlm->ast_lock);\n\tif (in_use && !(flags & LKM_CANCEL)) {\n\t       mlog(ML_ERROR, \"lockres %.*s: Someone is calling dlmunlock \"\n\t\t    \"while waiting for an ast!\", res->lockname.len,\n\t\t    res->lockname.name);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_IN_PROGRESS) {\n\t\tif (master_node && !(flags & LKM_CANCEL)) {\n\t\t\tmlog(ML_ERROR, \"lockres in progress!\\n\");\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\treturn DLM_FORWARD;\n\t\t}\n\t\t \n\t\t__dlm_wait_on_lockres(res);\n\t\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\t}\n\tspin_lock(&lock->spinlock);\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\tstatus = DLM_RECOVERING;\n\t\tgoto leave;\n\t}\n\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\tstatus = DLM_MIGRATING;\n\t\tgoto leave;\n\t}\n\n\t \n\tif (flags & LKM_CANCEL)\n\t\tstatus = dlm_get_cancel_actions(dlm, res, lock, lksb, &actions);\n\telse\n\t\tstatus = dlm_get_unlock_actions(dlm, res, lock, lksb, &actions);\n\n\tif (status != DLM_NORMAL && (status != DLM_CANCELGRANT || !master_node))\n\t\tgoto leave;\n\n\t \n\tif (flags & LKM_VALBLK) {\n\t\t \n\t\tif (master_node)\n\t\t\tmemcpy(res->lvb, lksb->lvb, DLM_LVB_LEN);\n\t\telse\n\t\t\tflags |= LKM_PUT_LVB;  \n\t}\n\n\tif (!master_node) {\n\t\towner = res->owner;\n\t\t \n\t\tif (flags & LKM_CANCEL)\n\t\t\tlock->cancel_pending = 1;\n\t\telse\n\t\t\tlock->unlock_pending = 1;\n\t\tspin_unlock(&lock->spinlock);\n\t\tspin_unlock(&res->spinlock);\n\t\tstatus = dlm_send_remote_unlock_request(dlm, res, lock, lksb,\n\t\t\t\t\t\t\tflags, owner);\n\t\tspin_lock(&res->spinlock);\n\t\tspin_lock(&lock->spinlock);\n\t\t \n\t\tif (status == DLM_CANCELGRANT) {\n\t\t\tactions &= ~(DLM_UNLOCK_REMOVE_LOCK|\n\t\t\t\t     DLM_UNLOCK_REGRANT_LOCK|\n\t\t\t\t     DLM_UNLOCK_CLEAR_CONVERT_TYPE);\n\t\t} else if (status == DLM_RECOVERING ||\n\t\t\t   status == DLM_MIGRATING ||\n\t\t\t   status == DLM_FORWARD ||\n\t\t\t   status == DLM_NOLOCKMGR\n\t\t\t   ) {\n\t\t\t \n\t\t\tmlog(0, \"%s:%.*s: clearing actions, %s\\n\",\n\t\t\t     dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name,\n\t\t\t     status==DLM_RECOVERING?\"recovering\":\n\t\t\t     (status==DLM_MIGRATING?\"migrating\":\n\t\t\t\t(status == DLM_FORWARD ? \"forward\" :\n\t\t\t\t\t\t\"nolockmanager\")));\n\t\t\tactions = 0;\n\t\t}\n\t\tif (flags & LKM_CANCEL)\n\t\t\tlock->cancel_pending = 0;\n\t\telse {\n\t\t\tif (!lock->unlock_pending)\n\t\t\t\trecovery_wait = 1;\n\t\t\telse\n\t\t\t\tlock->unlock_pending = 0;\n\t\t}\n\t}\n\n\t \n\tdlm_lock_get(lock);\n\n\tif (actions & DLM_UNLOCK_REMOVE_LOCK) {\n\t\tlist_del_init(&lock->list);\n\t\tdlm_lock_put(lock);\n\t}\n\tif (actions & DLM_UNLOCK_REGRANT_LOCK) {\n\t\tdlm_lock_get(lock);\n\t\tlist_add_tail(&lock->list, &res->granted);\n\t}\n\tif (actions & DLM_UNLOCK_CLEAR_CONVERT_TYPE) {\n\t\tmlog(0, \"clearing convert_type at %smaster node\\n\",\n\t\t     master_node ? \"\" : \"non-\");\n\t\tlock->ml.convert_type = LKM_IVMODE;\n\t}\n\n\t \n\tdlm_lock_put(lock);\n\nleave:\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tif (!dlm_lock_on_list(&res->converting, lock))\n\t\tBUG_ON(lock->ml.convert_type != LKM_IVMODE);\n\telse\n\t\tBUG_ON(lock->ml.convert_type == LKM_IVMODE);\n\tspin_unlock(&lock->spinlock);\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\tif (recovery_wait) {\n\t\tspin_lock(&res->spinlock);\n\t\t \n\t\t__dlm_wait_on_lockres_flags(res, DLM_LOCK_RES_RECOVERING);\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\t \n\tif (actions & DLM_UNLOCK_FREE_LOCK) {\n\t\t \n\t\tBUG_ON(!(actions & DLM_UNLOCK_REMOVE_LOCK));\n\t\tmlog(0, \"lock %u:%llu should be gone now! refs=%d\\n\",\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     kref_read(&lock->lock_refs)-1);\n\t\tdlm_lock_put(lock);\n\t}\n\tif (actions & DLM_UNLOCK_CALL_AST)\n\t\t*call_ast = 1;\n\n\t \n\tif (status == DLM_NORMAL)\n\t\tlksb->flags &= ~(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB);\n\n\treturn status;\n}\n\nvoid dlm_commit_pending_unlock(struct dlm_lock_resource *res,\n\t\t\t       struct dlm_lock *lock)\n{\n\t \n\tlist_del_init(&lock->list);\n}\n\nvoid dlm_commit_pending_cancel(struct dlm_lock_resource *res,\n\t\t\t       struct dlm_lock *lock)\n{\n\tlist_move_tail(&lock->list, &res->granted);\n\tlock->ml.convert_type = LKM_IVMODE;\n}\n\n\nstatic inline enum dlm_status dlmunlock_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t\t  struct dlm_lock *lock,\n\t\t\t\t\t  struct dlm_lockstatus *lksb,\n\t\t\t\t\t  int flags,\n\t\t\t\t\t  int *call_ast)\n{\n\treturn dlmunlock_common(dlm, res, lock, lksb, flags, call_ast, 1);\n}\n\nstatic inline enum dlm_status dlmunlock_remote(struct dlm_ctxt *dlm,\n\t\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t\t  struct dlm_lock *lock,\n\t\t\t\t\t  struct dlm_lockstatus *lksb,\n\t\t\t\t\t  int flags, int *call_ast)\n{\n\treturn dlmunlock_common(dlm, res, lock, lksb, flags, call_ast, 0);\n}\n\n \nstatic enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner)\n{\n\tstruct dlm_unlock_lock unlock;\n\tint tmpret;\n\tenum dlm_status ret;\n\tint status = 0;\n\tstruct kvec vec[2];\n\tsize_t veclen = 1;\n\n\tmlog(0, \"%.*s\\n\", res->lockname.len, res->lockname.name);\n\n\tif (owner == dlm->node_num) {\n\t\t \n\t\tmlog(0, \"%s:%.*s: this node became the master due to a \"\n\t\t     \"migration, re-evaluate now\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name);\n\t\treturn DLM_FORWARD;\n\t}\n\n\tmemset(&unlock, 0, sizeof(unlock));\n\tunlock.node_idx = dlm->node_num;\n\tunlock.flags = cpu_to_be32(flags);\n\tunlock.cookie = lock->ml.cookie;\n\tunlock.namelen = res->lockname.len;\n\tmemcpy(unlock.name, res->lockname.name, unlock.namelen);\n\n\tvec[0].iov_len = sizeof(struct dlm_unlock_lock);\n\tvec[0].iov_base = &unlock;\n\n\tif (flags & LKM_PUT_LVB) {\n\t\t \n\t\tvec[1].iov_len = DLM_LVB_LEN;\n\t\tvec[1].iov_base = lock->lksb->lvb;\n\t\tveclen++;\n\t}\n\n\ttmpret = o2net_send_message_vec(DLM_UNLOCK_LOCK_MSG, dlm->key,\n\t\t\t\t\tvec, veclen, owner, &status);\n\tif (tmpret >= 0) {\n\t\t \n\t\tif (status == DLM_FORWARD)\n\t\t\tmlog(0, \"master was in-progress.  retry\\n\");\n\t\tret = status;\n\t} else {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", tmpret, DLM_UNLOCK_LOCK_MSG, dlm->key, owner);\n\t\tif (dlm_is_host_down(tmpret)) {\n\t\t\t \n\t\t\tif (dlm_is_node_dead(dlm, owner))\n\t\t\t\tret = DLM_NORMAL;\n\t\t\telse\n\t\t\t\tret = DLM_NOLOCKMGR;\n\t\t} else {\n\t\t\t \n\t\t\tret = dlm_err_to_dlm_status(tmpret);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nint dlm_unlock_lock_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t    void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_unlock_lock *unlock = (struct dlm_unlock_lock *)msg->buf;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *lock = NULL, *iter;\n\tenum dlm_status status = DLM_NORMAL;\n\tint i;\n\tstruct dlm_lockstatus *lksb = NULL;\n\tint ignore;\n\tu32 flags;\n\tstruct list_head *queue;\n\n\tflags = be32_to_cpu(unlock->flags);\n\n\tif (flags & LKM_GET_LVB) {\n\t\tmlog(ML_ERROR, \"bad args!  GET_LVB specified on unlock!\\n\");\n\t\treturn DLM_BADARGS;\n\t}\n\n\tif ((flags & (LKM_PUT_LVB|LKM_CANCEL)) == (LKM_PUT_LVB|LKM_CANCEL)) {\n\t\tmlog(ML_ERROR, \"bad args!  cannot modify lvb on a CANCEL \"\n\t\t     \"request!\\n\");\n\t\treturn DLM_BADARGS;\n\t}\n\n\tif (unlock->namelen > DLM_LOCKID_NAME_MAX) {\n\t\tmlog(ML_ERROR, \"Invalid name length in unlock handler!\\n\");\n\t\treturn DLM_IVBUFLEN;\n\t}\n\n\tif (!dlm_grab(dlm))\n\t\treturn DLM_FORWARD;\n\n\tmlog_bug_on_msg(!dlm_domain_fully_joined(dlm),\n\t\t\t\"Domain %s not fully joined!\\n\", dlm->name);\n\n\tmlog(0, \"lvb: %s\\n\", flags & LKM_PUT_LVB ? \"put lvb\" : \"none\");\n\n\tres = dlm_lookup_lockres(dlm, unlock->name, unlock->namelen);\n\tif (!res) {\n\t\t \n\t\tmlog(0, \"returning DLM_FORWARD -- res no longer exists\\n\");\n\t\tstatus = DLM_FORWARD;\n\t\tgoto not_found;\n\t}\n\n\tqueue=&res->granted;\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\tspin_unlock(&res->spinlock);\n\t\tmlog(0, \"returning DLM_RECOVERING\\n\");\n\t\tstatus = DLM_RECOVERING;\n\t\tgoto leave;\n\t}\n\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\tspin_unlock(&res->spinlock);\n\t\tmlog(0, \"returning DLM_MIGRATING\\n\");\n\t\tstatus = DLM_MIGRATING;\n\t\tgoto leave;\n\t}\n\n\tif (res->owner != dlm->node_num) {\n\t\tspin_unlock(&res->spinlock);\n\t\tmlog(0, \"returning DLM_FORWARD -- not master\\n\");\n\t\tstatus = DLM_FORWARD;\n\t\tgoto leave;\n\t}\n\n\tfor (i=0; i<3; i++) {\n\t\tlist_for_each_entry(iter, queue, list) {\n\t\t\tif (iter->ml.cookie == unlock->cookie &&\n\t\t\t    iter->ml.node == unlock->node_idx) {\n\t\t\t\tdlm_lock_get(iter);\n\t\t\t\tlock = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (lock)\n\t\t\tbreak;\n\t\t \n\t\tqueue++;\n\t}\n\tspin_unlock(&res->spinlock);\n\tif (!lock) {\n\t\tstatus = DLM_IVLOCKID;\n\t\tgoto not_found;\n\t}\n\n\t \n\tlksb = lock->lksb;\n\tif (flags & (LKM_VALBLK|LKM_PUT_LVB) &&\n\t    lock->ml.type != LKM_EXMODE)\n\t\tflags &= ~(LKM_VALBLK|LKM_PUT_LVB);\n\n\t \n\tif (flags & LKM_PUT_LVB) {\n\t\tlksb->flags |= DLM_LKSB_PUT_LVB;\n\t\tmemcpy(&lksb->lvb[0], &unlock->lvb[0], DLM_LVB_LEN);\n\t}\n\n\t \n\tstatus = dlmunlock_master(dlm, res, lock, lksb, flags, &ignore);\n\tif (status == DLM_FORWARD)\n\t\tmlog(0, \"lockres is in progress\\n\");\n\n\tif (flags & LKM_PUT_LVB)\n\t\tlksb->flags &= ~DLM_LKSB_PUT_LVB;\n\n\tdlm_lockres_calc_usage(dlm, res);\n\tdlm_kick_thread(dlm, res);\n\nnot_found:\n\tif (!lock)\n\t\tmlog(ML_ERROR, \"failed to find lock to unlock! \"\n\t\t\t       \"cookie=%u:%llu\\n\",\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(unlock->cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(unlock->cookie)));\n\telse\n\t\tdlm_lock_put(lock);\n\nleave:\n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\tdlm_put(dlm);\n\n\treturn status;\n}\n\n\nstatic enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions)\n{\n\tenum dlm_status status;\n\n\tif (dlm_lock_on_list(&res->blocked, lock)) {\n\t\t \n\t\tstatus = DLM_NORMAL;\n\t\t*actions = (DLM_UNLOCK_CALL_AST |\n\t\t\t    DLM_UNLOCK_REMOVE_LOCK);\n\t} else if (dlm_lock_on_list(&res->converting, lock)) {\n\t\t \n\t\tstatus = DLM_NORMAL;\n\t\t*actions = (DLM_UNLOCK_CALL_AST |\n\t\t\t    DLM_UNLOCK_REMOVE_LOCK |\n\t\t\t    DLM_UNLOCK_REGRANT_LOCK |\n\t\t\t    DLM_UNLOCK_CLEAR_CONVERT_TYPE);\n\t} else if (dlm_lock_on_list(&res->granted, lock)) {\n\t\t \n\t\tstatus = DLM_CANCELGRANT;\n\t\t*actions = DLM_UNLOCK_CALL_AST;\n\t} else {\n\t\tmlog(ML_ERROR, \"lock to cancel is not on any list!\\n\");\n\t\tstatus = DLM_IVLOCKID;\n\t\t*actions = 0;\n\t}\n\treturn status;\n}\n\nstatic enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t\t      struct dlm_lockstatus *lksb,\n\t\t\t\t\t      int *actions)\n{\n\tenum dlm_status status;\n\n\t \n\tif (!dlm_lock_on_list(&res->granted, lock)) {\n\t\tstatus = DLM_DENIED;\n\t\tdlm_error(status);\n\t\t*actions = 0;\n\t} else {\n\t\t \n\t\tstatus = DLM_NORMAL;\n\t\t*actions = (DLM_UNLOCK_FREE_LOCK |\n\t\t\t    DLM_UNLOCK_CALL_AST |\n\t\t\t    DLM_UNLOCK_REMOVE_LOCK);\n\t}\n\treturn status;\n}\n\n \nenum dlm_status dlmunlock(struct dlm_ctxt *dlm, struct dlm_lockstatus *lksb,\n\t\t\t  int flags, dlm_astunlockfunc_t *unlockast, void *data)\n{\n\tenum dlm_status status;\n\tstruct dlm_lock_resource *res;\n\tstruct dlm_lock *lock = NULL;\n\tint call_ast, is_master;\n\n\tif (!lksb) {\n\t\tdlm_error(DLM_BADARGS);\n\t\treturn DLM_BADARGS;\n\t}\n\n\tif (flags & ~(LKM_CANCEL | LKM_VALBLK | LKM_INVVALBLK)) {\n\t\tdlm_error(DLM_BADPARAM);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tif ((flags & (LKM_VALBLK | LKM_CANCEL)) == (LKM_VALBLK | LKM_CANCEL)) {\n\t\tmlog(0, \"VALBLK given with CANCEL: ignoring VALBLK\\n\");\n\t\tflags &= ~LKM_VALBLK;\n\t}\n\n\tif (!lksb->lockid || !lksb->lockid->lockres) {\n\t\tdlm_error(DLM_BADPARAM);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tlock = lksb->lockid;\n\tBUG_ON(!lock);\n\tdlm_lock_get(lock);\n\n\tres = lock->lockres;\n\tBUG_ON(!res);\n\tdlm_lockres_get(res);\nretry:\n\tcall_ast = 0;\n\t \n\tmlog(0, \"lock=%p res=%p\\n\", lock, res);\n\n\tspin_lock(&res->spinlock);\n\tis_master = (res->owner == dlm->node_num);\n\tif (flags & LKM_VALBLK && lock->ml.type != LKM_EXMODE)\n\t\tflags &= ~LKM_VALBLK;\n\tspin_unlock(&res->spinlock);\n\n\tif (is_master) {\n\t\tstatus = dlmunlock_master(dlm, res, lock, lksb, flags,\n\t\t\t\t\t  &call_ast);\n\t\tmlog(0, \"done calling dlmunlock_master: returned %d, \"\n\t\t     \"call_ast is %d\\n\", status, call_ast);\n\t} else {\n\t\tstatus = dlmunlock_remote(dlm, res, lock, lksb, flags,\n\t\t\t\t\t  &call_ast);\n\t\tmlog(0, \"done calling dlmunlock_remote: returned %d, \"\n\t\t     \"call_ast is %d\\n\", status, call_ast);\n\t}\n\n\tif (status == DLM_RECOVERING ||\n\t    status == DLM_MIGRATING ||\n\t    status == DLM_FORWARD ||\n\t    status == DLM_NOLOCKMGR) {\n\n\t\t \n\n\t\t \n\t\tmsleep(50);\n\n\t\tmlog(0, \"retrying unlock due to pending recovery/\"\n\t\t     \"migration/in-progress/reconnect\\n\");\n\t\tgoto retry;\n\t}\n\n\tif (call_ast) {\n\t\tmlog(0, \"calling unlockast(%p, %d)\\n\", data, status);\n\t\tif (is_master) {\n\t\t\t \n\t\t\tdlm_kick_thread(dlm, NULL);\n\t\t\twait_event(dlm->ast_wq,\n\t\t\t\t   dlm_lock_basts_flushed(dlm, lock));\n\t\t}\n\t\t(*unlockast)(data, status);\n\t}\n\n\tif (status == DLM_CANCELGRANT)\n\t\tstatus = DLM_NORMAL;\n\n\tif (status == DLM_NORMAL) {\n\t\tmlog(0, \"kicking the thread\\n\");\n\t\tdlm_kick_thread(dlm, res);\n\t} else\n\t\tdlm_error(status);\n\n\tdlm_lockres_calc_usage(dlm, res);\n\tdlm_lockres_put(res);\n\tdlm_lock_put(lock);\n\n\tmlog(0, \"returning status=%d!\\n\", status);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(dlmunlock);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}