{
  "module_name": "keystore.c",
  "hash_id": "9c0fc6bb4a5240ae20de6322257b5e37d3dcea6e81b664edcacb6d33c9e7e8b0",
  "original_prompt": "Ingested from linux-6.6.14/fs/ecryptfs/keystore.c",
  "human_readable_source": "\n \n\n#include <crypto/hash.h>\n#include <crypto/skcipher.h>\n#include <linux/string.h>\n#include <linux/pagemap.h>\n#include <linux/key.h>\n#include <linux/random.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include \"ecryptfs_kernel.h\"\n\n \nstatic int process_request_key_err(long err_code)\n{\n\tint rc = 0;\n\n\tswitch (err_code) {\n\tcase -ENOKEY:\n\t\tecryptfs_printk(KERN_WARNING, \"No key\\n\");\n\t\trc = -ENOENT;\n\t\tbreak;\n\tcase -EKEYEXPIRED:\n\t\tecryptfs_printk(KERN_WARNING, \"Key expired\\n\");\n\t\trc = -ETIME;\n\t\tbreak;\n\tcase -EKEYREVOKED:\n\t\tecryptfs_printk(KERN_WARNING, \"Key revoked\\n\");\n\t\trc = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tecryptfs_printk(KERN_WARNING, \"Unknown error code: \"\n\t\t\t\t\"[0x%.16lx]\\n\", err_code);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}\n\nstatic int process_find_global_auth_tok_for_sig_err(int err_code)\n{\n\tint rc = err_code;\n\n\tswitch (err_code) {\n\tcase -ENOENT:\n\t\tecryptfs_printk(KERN_WARNING, \"Missing auth tok\\n\");\n\t\tbreak;\n\tcase -EINVAL:\n\t\tecryptfs_printk(KERN_WARNING, \"Invalid auth tok\\n\");\n\t\tbreak;\n\tdefault:\n\t\trc = process_request_key_err(err_code);\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\n \nint ecryptfs_parse_packet_length(unsigned char *data, size_t *size,\n\t\t\t\t size_t *length_size)\n{\n\tint rc = 0;\n\n\t(*length_size) = 0;\n\t(*size) = 0;\n\tif (data[0] < 192) {\n\t\t \n\t\t(*size) = data[0];\n\t\t(*length_size) = 1;\n\t} else if (data[0] < 224) {\n\t\t \n\t\t(*size) = (data[0] - 192) * 256;\n\t\t(*size) += data[1] + 192;\n\t\t(*length_size) = 2;\n\t} else if (data[0] == 255) {\n\t\t \n\t\tecryptfs_printk(KERN_ERR, \"Five-byte packet length not \"\n\t\t\t\t\"supported\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing packet length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}\n\n \nint ecryptfs_write_packet_length(char *dest, size_t size,\n\t\t\t\t size_t *packet_size_length)\n{\n\tint rc = 0;\n\n\tif (size < 192) {\n\t\tdest[0] = size;\n\t\t(*packet_size_length) = 1;\n\t} else if (size < 65536) {\n\t\tdest[0] = (((size - 192) / 256) + 192);\n\t\tdest[1] = ((size - 192) % 256);\n\t\t(*packet_size_length) = 2;\n\t} else {\n\t\t \n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING,\n\t\t\t\t\"Unsupported packet size: [%zd]\\n\", size);\n\t}\n\treturn rc;\n}\n\nstatic int\nwrite_tag_64_packet(char *signature, struct ecryptfs_session_key *session_key,\n\t\t    char **packet, size_t *packet_len)\n{\n\tsize_t i = 0;\n\tsize_t data_len;\n\tsize_t packet_size_len;\n\tchar *message;\n\tint rc;\n\n\t \n\tdata_len = (5 + ECRYPTFS_SIG_SIZE_HEX\n\t\t    + session_key->encrypted_key_size);\n\t*packet = kmalloc(data_len, GFP_KERNEL);\n\tmessage = *packet;\n\tif (!message) {\n\t\tecryptfs_printk(KERN_ERR, \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmessage[i++] = ECRYPTFS_TAG_64_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&message[i], ECRYPTFS_SIG_SIZE_HEX,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 64 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmemcpy(&message[i], signature, ECRYPTFS_SIG_SIZE_HEX);\n\ti += ECRYPTFS_SIG_SIZE_HEX;\n\trc = ecryptfs_write_packet_length(&message[i],\n\t\t\t\t\t  session_key->encrypted_key_size,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 64 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmemcpy(&message[i], session_key->encrypted_key,\n\t       session_key->encrypted_key_size);\n\ti += session_key->encrypted_key_size;\n\t*packet_len = i;\nout:\n\treturn rc;\n}\n\nstatic int\nparse_tag_65_packet(struct ecryptfs_session_key *session_key, u8 *cipher_code,\n\t\t    struct ecryptfs_message *msg)\n{\n\tsize_t i = 0;\n\tchar *data;\n\tsize_t data_len;\n\tsize_t m_size;\n\tsize_t message_len;\n\tu16 checksum = 0;\n\tu16 expected_checksum = 0;\n\tint rc;\n\n\t \n\tmessage_len = msg->data_len;\n\tdata = msg->data;\n\tif (message_len < 4) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (data[i++] != ECRYPTFS_TAG_65_PACKET_TYPE) {\n\t\tecryptfs_printk(KERN_ERR, \"Type should be ECRYPTFS_TAG_65\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (data[i++]) {\n\t\tecryptfs_printk(KERN_ERR, \"Status indicator has non-zero value \"\n\t\t\t\t\"[%d]\\n\", data[i-1]);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[i], &m_size, &data_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error parsing packet length; \"\n\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\ti += data_len;\n\tif (message_len < (i + m_size)) {\n\t\tecryptfs_printk(KERN_ERR, \"The message received from ecryptfsd \"\n\t\t\t\t\"is shorter than expected\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (m_size < 3) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\"The decrypted key is not long enough to \"\n\t\t\t\t\"include a cipher code and checksum\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\t*cipher_code = data[i++];\n\t \n\tsession_key->decrypted_key_size = m_size - 3;\n\tif (session_key->decrypted_key_size > ECRYPTFS_MAX_KEY_BYTES) {\n\t\tecryptfs_printk(KERN_ERR, \"key_size [%d] larger than \"\n\t\t\t\t\"the maximum key size [%d]\\n\",\n\t\t\t\tsession_key->decrypted_key_size,\n\t\t\t\tECRYPTFS_MAX_ENCRYPTED_KEY_BYTES);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tmemcpy(session_key->decrypted_key, &data[i],\n\t       session_key->decrypted_key_size);\n\ti += session_key->decrypted_key_size;\n\texpected_checksum += (unsigned char)(data[i++]) << 8;\n\texpected_checksum += (unsigned char)(data[i++]);\n\tfor (i = 0; i < session_key->decrypted_key_size; i++)\n\t\tchecksum += session_key->decrypted_key[i];\n\tif (expected_checksum != checksum) {\n\t\tecryptfs_printk(KERN_ERR, \"Invalid checksum for file \"\n\t\t\t\t\"encryption  key; expected [%x]; calculated \"\n\t\t\t\t\"[%x]\\n\", expected_checksum, checksum);\n\t\trc = -EIO;\n\t}\nout:\n\treturn rc;\n}\n\n\nstatic int\nwrite_tag_66_packet(char *signature, u8 cipher_code,\n\t\t    struct ecryptfs_crypt_stat *crypt_stat, char **packet,\n\t\t    size_t *packet_len)\n{\n\tsize_t i = 0;\n\tsize_t j;\n\tsize_t data_len;\n\tsize_t checksum = 0;\n\tsize_t packet_size_len;\n\tchar *message;\n\tint rc;\n\n\t \n\tdata_len = (5 + ECRYPTFS_SIG_SIZE_HEX + crypt_stat->key_size);\n\t*packet = kmalloc(data_len, GFP_KERNEL);\n\tmessage = *packet;\n\tif (!message) {\n\t\tecryptfs_printk(KERN_ERR, \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmessage[i++] = ECRYPTFS_TAG_66_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&message[i], ECRYPTFS_SIG_SIZE_HEX,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 66 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmemcpy(&message[i], signature, ECRYPTFS_SIG_SIZE_HEX);\n\ti += ECRYPTFS_SIG_SIZE_HEX;\n\t \n\trc = ecryptfs_write_packet_length(&message[i], crypt_stat->key_size + 3,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 66 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmessage[i++] = cipher_code;\n\tmemcpy(&message[i], crypt_stat->key, crypt_stat->key_size);\n\ti += crypt_stat->key_size;\n\tfor (j = 0; j < crypt_stat->key_size; j++)\n\t\tchecksum += crypt_stat->key[j];\n\tmessage[i++] = (checksum / 256) % 256;\n\tmessage[i++] = (checksum % 256);\n\t*packet_len = i;\nout:\n\treturn rc;\n}\n\nstatic int\nparse_tag_67_packet(struct ecryptfs_key_record *key_rec,\n\t\t    struct ecryptfs_message *msg)\n{\n\tsize_t i = 0;\n\tchar *data;\n\tsize_t data_len;\n\tsize_t message_len;\n\tint rc;\n\n\t \n\tmessage_len = msg->data_len;\n\tdata = msg->data;\n\t \n\tif (message_len < 4) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: message_len is [%zd]; minimum acceptable \"\n\t\t       \"message length is [%d]\\n\", __func__, message_len, 4);\n\t\tgoto out;\n\t}\n\tif (data[i++] != ECRYPTFS_TAG_67_PACKET_TYPE) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: Type should be ECRYPTFS_TAG_67\\n\",\n\t\t       __func__);\n\t\tgoto out;\n\t}\n\tif (data[i++]) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: Status indicator has non zero \"\n\t\t       \"value [%d]\\n\", __func__, data[i-1]);\n\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[i], &key_rec->enc_key_size,\n\t\t\t\t\t  &data_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error parsing packet length; \"\n\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\ti += data_len;\n\tif (message_len < (i + key_rec->enc_key_size)) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: message_len [%zd]; max len is [%zd]\\n\",\n\t\t       __func__, message_len, (i + key_rec->enc_key_size));\n\t\tgoto out;\n\t}\n\tif (key_rec->enc_key_size > ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: Encrypted key_size [%zd] larger than \"\n\t\t       \"the maximum key size [%d]\\n\", __func__,\n\t\t       key_rec->enc_key_size,\n\t\t       ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES);\n\t\tgoto out;\n\t}\n\tmemcpy(key_rec->enc_key, &data[i], key_rec->enc_key_size);\nout:\n\treturn rc;\n}\n\n \nstatic int ecryptfs_verify_version(u16 version)\n{\n\tint rc = 0;\n\tunsigned char major;\n\tunsigned char minor;\n\n\tmajor = ((version >> 8) & 0xFF);\n\tminor = (version & 0xFF);\n\tif (major != ECRYPTFS_VERSION_MAJOR) {\n\t\tecryptfs_printk(KERN_ERR, \"Major version number mismatch. \"\n\t\t\t\t\"Expected [%d]; got [%d]\\n\",\n\t\t\t\tECRYPTFS_VERSION_MAJOR, major);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (minor != ECRYPTFS_VERSION_MINOR) {\n\t\tecryptfs_printk(KERN_ERR, \"Minor version number mismatch. \"\n\t\t\t\t\"Expected [%d]; got [%d]\\n\",\n\t\t\t\tECRYPTFS_VERSION_MINOR, minor);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}\n\n \nstatic int\necryptfs_verify_auth_tok_from_key(struct key *auth_tok_key,\n\t\t\t\t  struct ecryptfs_auth_tok **auth_tok)\n{\n\tint rc = 0;\n\n\t(*auth_tok) = ecryptfs_get_key_payload_data(auth_tok_key);\n\tif (IS_ERR(*auth_tok)) {\n\t\trc = PTR_ERR(*auth_tok);\n\t\t*auth_tok = NULL;\n\t\tgoto out;\n\t}\n\n\tif (ecryptfs_verify_version((*auth_tok)->version)) {\n\t\tprintk(KERN_ERR \"Data structure version mismatch. Userspace \"\n\t\t       \"tools must match eCryptfs kernel module with major \"\n\t\t       \"version [%d] and minor version [%d]\\n\",\n\t\t       ECRYPTFS_VERSION_MAJOR, ECRYPTFS_VERSION_MINOR);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((*auth_tok)->token_type != ECRYPTFS_PASSWORD\n\t    && (*auth_tok)->token_type != ECRYPTFS_PRIVATE_KEY) {\n\t\tprintk(KERN_ERR \"Invalid auth_tok structure \"\n\t\t       \"returned from key query\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}\n\nstatic int\necryptfs_find_global_auth_tok_for_sig(\n\tstruct key **auth_tok_key,\n\tstruct ecryptfs_auth_tok **auth_tok,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat, char *sig)\n{\n\tstruct ecryptfs_global_auth_tok *walker;\n\tint rc = 0;\n\n\t(*auth_tok_key) = NULL;\n\t(*auth_tok) = NULL;\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_for_each_entry(walker,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\tif (memcmp(walker->sig, sig, ECRYPTFS_SIG_SIZE_HEX))\n\t\t\tcontinue;\n\n\t\tif (walker->flags & ECRYPTFS_AUTH_TOK_INVALID) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = key_validate(walker->global_auth_tok_key);\n\t\tif (rc) {\n\t\t\tif (rc == -EKEYEXPIRED)\n\t\t\t\tgoto out;\n\t\t\tgoto out_invalid_auth_tok;\n\t\t}\n\n\t\tdown_write(&(walker->global_auth_tok_key->sem));\n\t\trc = ecryptfs_verify_auth_tok_from_key(\n\t\t\t\twalker->global_auth_tok_key, auth_tok);\n\t\tif (rc)\n\t\t\tgoto out_invalid_auth_tok_unlock;\n\n\t\t(*auth_tok_key) = walker->global_auth_tok_key;\n\t\tkey_get(*auth_tok_key);\n\t\tgoto out;\n\t}\n\trc = -ENOENT;\n\tgoto out;\nout_invalid_auth_tok_unlock:\n\tup_write(&(walker->global_auth_tok_key->sem));\nout_invalid_auth_tok:\n\tprintk(KERN_WARNING \"Invalidating auth tok with sig = [%s]\\n\", sig);\n\twalker->flags |= ECRYPTFS_AUTH_TOK_INVALID;\n\tkey_put(walker->global_auth_tok_key);\n\twalker->global_auth_tok_key = NULL;\nout:\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\treturn rc;\n}\n\n \nstatic int\necryptfs_find_auth_tok_for_sig(\n\tstruct key **auth_tok_key,\n\tstruct ecryptfs_auth_tok **auth_tok,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\tchar *sig)\n{\n\tint rc = 0;\n\n\trc = ecryptfs_find_global_auth_tok_for_sig(auth_tok_key, auth_tok,\n\t\t\t\t\t\t   mount_crypt_stat, sig);\n\tif (rc == -ENOENT) {\n\t\t \n\t\tif (mount_crypt_stat->flags\n\t\t\t\t& ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY)\n\t\t\treturn -EINVAL;\n\n\t\trc = ecryptfs_keyring_auth_tok_for_sig(auth_tok_key, auth_tok,\n\t\t\t\t\t\t       sig);\n\t}\n\treturn rc;\n}\n\n \nstruct ecryptfs_write_tag_70_packet_silly_stack {\n\tu8 cipher_code;\n\tsize_t max_packet_size;\n\tsize_t packet_size_len;\n\tsize_t block_aligned_filename_size;\n\tsize_t block_size;\n\tsize_t i;\n\tsize_t j;\n\tsize_t num_rand_bytes;\n\tstruct mutex *tfm_mutex;\n\tchar *block_aligned_filename;\n\tstruct ecryptfs_auth_tok *auth_tok;\n\tstruct scatterlist src_sg[2];\n\tstruct scatterlist dst_sg[2];\n\tstruct crypto_skcipher *skcipher_tfm;\n\tstruct skcipher_request *skcipher_req;\n\tchar iv[ECRYPTFS_MAX_IV_BYTES];\n\tchar hash[ECRYPTFS_TAG_70_DIGEST_SIZE];\n\tchar tmp_hash[ECRYPTFS_TAG_70_DIGEST_SIZE];\n\tstruct crypto_shash *hash_tfm;\n\tstruct shash_desc *hash_desc;\n};\n\n \nint\necryptfs_write_tag_70_packet(char *dest, size_t *remaining_bytes,\n\t\t\t     size_t *packet_size,\n\t\t\t     struct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\t\t\t     char *filename, size_t filename_size)\n{\n\tstruct ecryptfs_write_tag_70_packet_silly_stack *s;\n\tstruct key *auth_tok_key = NULL;\n\tint rc = 0;\n\n\ts = kzalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\t(*packet_size) = 0;\n\trc = ecryptfs_find_auth_tok_for_sig(\n\t\t&auth_tok_key,\n\t\t&s->auth_tok, mount_crypt_stat,\n\t\tmount_crypt_stat->global_default_fnek_sig);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to find auth tok for \"\n\t\t       \"fnek sig [%s]; rc = [%d]\\n\", __func__,\n\t\t       mount_crypt_stat->global_default_fnek_sig, rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(\n\t\t&s->skcipher_tfm,\n\t\t&s->tfm_mutex, mount_crypt_stat->global_default_fn_cipher_name);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       mount_crypt_stat->global_default_fn_cipher_name, rc);\n\t\tgoto out;\n\t}\n\tmutex_lock(s->tfm_mutex);\n\ts->block_size = crypto_skcipher_blocksize(s->skcipher_tfm);\n\t \n\ts->num_rand_bytes = (ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES + 1);\n\ts->block_aligned_filename_size = (s->num_rand_bytes + filename_size);\n\tif ((s->block_aligned_filename_size % s->block_size) != 0) {\n\t\ts->num_rand_bytes += (s->block_size\n\t\t\t\t      - (s->block_aligned_filename_size\n\t\t\t\t\t % s->block_size));\n\t\ts->block_aligned_filename_size = (s->num_rand_bytes\n\t\t\t\t\t\t  + filename_size);\n\t}\n\t \n\ts->max_packet_size = (ECRYPTFS_TAG_70_MAX_METADATA_SIZE\n\t\t\t      + s->block_aligned_filename_size);\n\tif (!dest) {\n\t\t(*packet_size) = s->max_packet_size;\n\t\tgoto out_unlock;\n\t}\n\tif (s->max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_WARNING \"%s: Require [%zd] bytes to write; only \"\n\t\t       \"[%zd] available\\n\", __func__, s->max_packet_size,\n\t\t       (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\ts->skcipher_req = skcipher_request_alloc(s->skcipher_tfm, GFP_KERNEL);\n\tif (!s->skcipher_req) {\n\t\tprintk(KERN_ERR \"%s: Out of kernel memory whilst attempting to \"\n\t\t       \"skcipher_request_alloc for %s\\n\", __func__,\n\t\t       crypto_skcipher_driver_name(s->skcipher_tfm));\n\t\trc = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tskcipher_request_set_callback(s->skcipher_req,\n\t\t\t\t      CRYPTO_TFM_REQ_MAY_SLEEP, NULL, NULL);\n\n\ts->block_aligned_filename = kzalloc(s->block_aligned_filename_size,\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!s->block_aligned_filename) {\n\t\trc = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\tdest[s->i++] = ECRYPTFS_TAG_70_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&dest[s->i],\n\t\t\t\t\t  (ECRYPTFS_SIG_SIZE\n\t\t\t\t\t   + 1  \n\t\t\t\t\t   + s->block_aligned_filename_size),\n\t\t\t\t\t  &s->packet_size_len);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error generating tag 70 packet \"\n\t\t       \"header; cannot generate packet length; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_free_unlock;\n\t}\n\ts->i += s->packet_size_len;\n\tecryptfs_from_hex(&dest[s->i],\n\t\t\t  mount_crypt_stat->global_default_fnek_sig,\n\t\t\t  ECRYPTFS_SIG_SIZE);\n\ts->i += ECRYPTFS_SIG_SIZE;\n\ts->cipher_code = ecryptfs_code_for_cipher_string(\n\t\tmount_crypt_stat->global_default_fn_cipher_name,\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\tif (s->cipher_code == 0) {\n\t\tprintk(KERN_WARNING \"%s: Unable to generate code for \"\n\t\t       \"cipher [%s] with key bytes [%zd]\\n\", __func__,\n\t\t       mount_crypt_stat->global_default_fn_cipher_name,\n\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\trc = -EINVAL;\n\t\tgoto out_free_unlock;\n\t}\n\tdest[s->i++] = s->cipher_code;\n\t \n\tif (s->auth_tok->token_type != ECRYPTFS_PASSWORD) {\n\t\trc = -EOPNOTSUPP;\n\t\tprintk(KERN_INFO \"%s: Filename encryption only supports \"\n\t\t       \"password tokens\\n\", __func__);\n\t\tgoto out_free_unlock;\n\t}\n\ts->hash_tfm = crypto_alloc_shash(ECRYPTFS_TAG_70_DIGEST, 0, 0);\n\tif (IS_ERR(s->hash_tfm)) {\n\t\t\trc = PTR_ERR(s->hash_tfm);\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to \"\n\t\t\t       \"allocate hash crypto context; rc = [%d]\\n\",\n\t\t\t       __func__, rc);\n\t\t\tgoto out_free_unlock;\n\t}\n\n\ts->hash_desc = kmalloc(sizeof(*s->hash_desc) +\n\t\t\t       crypto_shash_descsize(s->hash_tfm), GFP_KERNEL);\n\tif (!s->hash_desc) {\n\t\trc = -ENOMEM;\n\t\tgoto out_release_free_unlock;\n\t}\n\n\ts->hash_desc->tfm = s->hash_tfm;\n\n\trc = crypto_shash_digest(s->hash_desc,\n\t\t\t\t (u8 *)s->auth_tok->token.password.session_key_encryption_key,\n\t\t\t\t s->auth_tok->token.password.session_key_encryption_key_bytes,\n\t\t\t\t s->hash);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error computing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_release_free_unlock;\n\t}\n\tfor (s->j = 0; s->j < (s->num_rand_bytes - 1); s->j++) {\n\t\ts->block_aligned_filename[s->j] =\n\t\t\ts->hash[(s->j % ECRYPTFS_TAG_70_DIGEST_SIZE)];\n\t\tif ((s->j % ECRYPTFS_TAG_70_DIGEST_SIZE)\n\t\t    == (ECRYPTFS_TAG_70_DIGEST_SIZE - 1)) {\n\t\t\trc = crypto_shash_digest(s->hash_desc, (u8 *)s->hash,\n\t\t\t\t\t\tECRYPTFS_TAG_70_DIGEST_SIZE,\n\t\t\t\t\t\ts->tmp_hash);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"%s: Error computing crypto hash; \"\n\t\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out_release_free_unlock;\n\t\t\t}\n\t\t\tmemcpy(s->hash, s->tmp_hash,\n\t\t\t       ECRYPTFS_TAG_70_DIGEST_SIZE);\n\t\t}\n\t\tif (s->block_aligned_filename[s->j] == '\\0')\n\t\t\ts->block_aligned_filename[s->j] = ECRYPTFS_NON_NULL;\n\t}\n\tmemcpy(&s->block_aligned_filename[s->num_rand_bytes], filename,\n\t       filename_size);\n\trc = virt_to_scatterlist(s->block_aligned_filename,\n\t\t\t\t s->block_aligned_filename_size, s->src_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert filename memory to scatterlist; rc = [%d]. \"\n\t\t       \"block_aligned_filename_size = [%zd]\\n\", __func__, rc,\n\t\t       s->block_aligned_filename_size);\n\t\tgoto out_release_free_unlock;\n\t}\n\trc = virt_to_scatterlist(&dest[s->i], s->block_aligned_filename_size,\n\t\t\t\t s->dst_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert encrypted filename memory to scatterlist; \"\n\t\t       \"rc = [%d]. block_aligned_filename_size = [%zd]\\n\",\n\t\t       __func__, rc, s->block_aligned_filename_size);\n\t\tgoto out_release_free_unlock;\n\t}\n\t \n\trc = crypto_skcipher_setkey(\n\t\ts->skcipher_tfm,\n\t\ts->auth_tok->token.password.session_key_encryption_key,\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"%s: Error setting key for crypto context; \"\n\t\t       \"rc = [%d]. s->auth_tok->token.password.session_key_\"\n\t\t       \"encryption_key = [0x%p]; mount_crypt_stat->\"\n\t\t       \"global_default_fn_cipher_key_bytes = [%zd]\\n\", __func__,\n\t\t       rc,\n\t\t       s->auth_tok->token.password.session_key_encryption_key,\n\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tgoto out_release_free_unlock;\n\t}\n\tskcipher_request_set_crypt(s->skcipher_req, s->src_sg, s->dst_sg,\n\t\t\t\t   s->block_aligned_filename_size, s->iv);\n\trc = crypto_skcipher_encrypt(s->skcipher_req);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to encrypt filename; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_release_free_unlock;\n\t}\n\ts->i += s->block_aligned_filename_size;\n\t(*packet_size) = s->i;\n\t(*remaining_bytes) -= (*packet_size);\nout_release_free_unlock:\n\tcrypto_free_shash(s->hash_tfm);\nout_free_unlock:\n\tkfree_sensitive(s->block_aligned_filename);\nout_unlock:\n\tmutex_unlock(s->tfm_mutex);\nout:\n\tif (auth_tok_key) {\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t}\n\tskcipher_request_free(s->skcipher_req);\n\tkfree_sensitive(s->hash_desc);\n\tkfree(s);\n\treturn rc;\n}\n\nstruct ecryptfs_parse_tag_70_packet_silly_stack {\n\tu8 cipher_code;\n\tsize_t max_packet_size;\n\tsize_t packet_size_len;\n\tsize_t parsed_tag_70_packet_size;\n\tsize_t block_aligned_filename_size;\n\tsize_t block_size;\n\tsize_t i;\n\tstruct mutex *tfm_mutex;\n\tchar *decrypted_filename;\n\tstruct ecryptfs_auth_tok *auth_tok;\n\tstruct scatterlist src_sg[2];\n\tstruct scatterlist dst_sg[2];\n\tstruct crypto_skcipher *skcipher_tfm;\n\tstruct skcipher_request *skcipher_req;\n\tchar fnek_sig_hex[ECRYPTFS_SIG_SIZE_HEX + 1];\n\tchar iv[ECRYPTFS_MAX_IV_BYTES];\n\tchar cipher_string[ECRYPTFS_MAX_CIPHER_NAME_SIZE + 1];\n};\n\n \nint\necryptfs_parse_tag_70_packet(char **filename, size_t *filename_size,\n\t\t\t     size_t *packet_size,\n\t\t\t     struct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\t\t\t     char *data, size_t max_packet_size)\n{\n\tstruct ecryptfs_parse_tag_70_packet_silly_stack *s;\n\tstruct key *auth_tok_key = NULL;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*filename_size) = 0;\n\t(*filename) = NULL;\n\ts = kzalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tif (max_packet_size < ECRYPTFS_TAG_70_MIN_METADATA_SIZE) {\n\t\tprintk(KERN_WARNING \"%s: max_packet_size is [%zd]; it must be \"\n\t\t       \"at least [%d]\\n\", __func__, max_packet_size,\n\t\t       ECRYPTFS_TAG_70_MIN_METADATA_SIZE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t \n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_70_PACKET_TYPE) {\n\t\tprintk(KERN_WARNING \"%s: Invalid packet tag [0x%.2x]; must be \"\n\t\t       \"tag [0x%.2x]\\n\", __func__,\n\t\t       data[((*packet_size) - 1)], ECRYPTFS_TAG_70_PACKET_TYPE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)],\n\t\t\t\t\t  &s->parsed_tag_70_packet_size,\n\t\t\t\t\t  &s->packet_size_len);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"%s: Error parsing packet length; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out;\n\t}\n\ts->block_aligned_filename_size = (s->parsed_tag_70_packet_size\n\t\t\t\t\t  - ECRYPTFS_SIG_SIZE - 1);\n\tif ((1 + s->packet_size_len + s->parsed_tag_70_packet_size)\n\t    > max_packet_size) {\n\t\tprintk(KERN_WARNING \"%s: max_packet_size is [%zd]; real packet \"\n\t\t       \"size is [%zd]\\n\", __func__, max_packet_size,\n\t\t       (1 + s->packet_size_len + 1\n\t\t\t+ s->block_aligned_filename_size));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += s->packet_size_len;\n\tecryptfs_to_hex(s->fnek_sig_hex, &data[(*packet_size)],\n\t\t\tECRYPTFS_SIG_SIZE);\n\ts->fnek_sig_hex[ECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t(*packet_size) += ECRYPTFS_SIG_SIZE;\n\ts->cipher_code = data[(*packet_size)++];\n\trc = ecryptfs_cipher_code_to_string(s->cipher_string, s->cipher_code);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"%s: Cipher code [%d] is invalid\\n\",\n\t\t       __func__, s->cipher_code);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_find_auth_tok_for_sig(&auth_tok_key,\n\t\t\t\t\t    &s->auth_tok, mount_crypt_stat,\n\t\t\t\t\t    s->fnek_sig_hex);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to find auth tok for \"\n\t\t       \"fnek sig [%s]; rc = [%d]\\n\", __func__, s->fnek_sig_hex,\n\t\t       rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&s->skcipher_tfm,\n\t\t\t\t\t\t\t&s->tfm_mutex,\n\t\t\t\t\t\t\ts->cipher_string);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       s->cipher_string, rc);\n\t\tgoto out;\n\t}\n\tmutex_lock(s->tfm_mutex);\n\trc = virt_to_scatterlist(&data[(*packet_size)],\n\t\t\t\t s->block_aligned_filename_size, s->src_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert encrypted filename memory to scatterlist; \"\n\t\t       \"rc = [%d]. block_aligned_filename_size = [%zd]\\n\",\n\t\t       __func__, rc, s->block_aligned_filename_size);\n\t\tgoto out_unlock;\n\t}\n\t(*packet_size) += s->block_aligned_filename_size;\n\ts->decrypted_filename = kmalloc(s->block_aligned_filename_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!s->decrypted_filename) {\n\t\trc = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\trc = virt_to_scatterlist(s->decrypted_filename,\n\t\t\t\t s->block_aligned_filename_size, s->dst_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert decrypted filename memory to scatterlist; \"\n\t\t       \"rc = [%d]. block_aligned_filename_size = [%zd]\\n\",\n\t\t       __func__, rc, s->block_aligned_filename_size);\n\t\tgoto out_free_unlock;\n\t}\n\n\ts->skcipher_req = skcipher_request_alloc(s->skcipher_tfm, GFP_KERNEL);\n\tif (!s->skcipher_req) {\n\t\tprintk(KERN_ERR \"%s: Out of kernel memory whilst attempting to \"\n\t\t       \"skcipher_request_alloc for %s\\n\", __func__,\n\t\t       crypto_skcipher_driver_name(s->skcipher_tfm));\n\t\trc = -ENOMEM;\n\t\tgoto out_free_unlock;\n\t}\n\n\tskcipher_request_set_callback(s->skcipher_req,\n\t\t\t\t      CRYPTO_TFM_REQ_MAY_SLEEP, NULL, NULL);\n\n\t \n\t \n\tif (s->auth_tok->token_type != ECRYPTFS_PASSWORD) {\n\t\trc = -EOPNOTSUPP;\n\t\tprintk(KERN_INFO \"%s: Filename encryption only supports \"\n\t\t       \"password tokens\\n\", __func__);\n\t\tgoto out_free_unlock;\n\t}\n\trc = crypto_skcipher_setkey(\n\t\ts->skcipher_tfm,\n\t\ts->auth_tok->token.password.session_key_encryption_key,\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"%s: Error setting key for crypto context; \"\n\t\t       \"rc = [%d]. s->auth_tok->token.password.session_key_\"\n\t\t       \"encryption_key = [0x%p]; mount_crypt_stat->\"\n\t\t       \"global_default_fn_cipher_key_bytes = [%zd]\\n\", __func__,\n\t\t       rc,\n\t\t       s->auth_tok->token.password.session_key_encryption_key,\n\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tgoto out_free_unlock;\n\t}\n\tskcipher_request_set_crypt(s->skcipher_req, s->src_sg, s->dst_sg,\n\t\t\t\t   s->block_aligned_filename_size, s->iv);\n\trc = crypto_skcipher_decrypt(s->skcipher_req);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to decrypt filename; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_free_unlock;\n\t}\n\n\twhile (s->i < s->block_aligned_filename_size &&\n\t       s->decrypted_filename[s->i] != '\\0')\n\t\ts->i++;\n\tif (s->i == s->block_aligned_filename_size) {\n\t\tprintk(KERN_WARNING \"%s: Invalid tag 70 packet; could not \"\n\t\t       \"find valid separator between random characters and \"\n\t\t       \"the filename\\n\", __func__);\n\t\trc = -EINVAL;\n\t\tgoto out_free_unlock;\n\t}\n\ts->i++;\n\t(*filename_size) = (s->block_aligned_filename_size - s->i);\n\tif (!((*filename_size) > 0 && (*filename_size < PATH_MAX))) {\n\t\tprintk(KERN_WARNING \"%s: Filename size is [%zd], which is \"\n\t\t       \"invalid\\n\", __func__, (*filename_size));\n\t\trc = -EINVAL;\n\t\tgoto out_free_unlock;\n\t}\n\t(*filename) = kmalloc(((*filename_size) + 1), GFP_KERNEL);\n\tif (!(*filename)) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_unlock;\n\t}\n\tmemcpy((*filename), &s->decrypted_filename[s->i], (*filename_size));\n\t(*filename)[(*filename_size)] = '\\0';\nout_free_unlock:\n\tkfree(s->decrypted_filename);\nout_unlock:\n\tmutex_unlock(s->tfm_mutex);\nout:\n\tif (rc) {\n\t\t(*packet_size) = 0;\n\t\t(*filename_size) = 0;\n\t\t(*filename) = NULL;\n\t}\n\tif (auth_tok_key) {\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t}\n\tskcipher_request_free(s->skcipher_req);\n\tkfree(s);\n\treturn rc;\n}\n\nstatic int\necryptfs_get_auth_tok_sig(char **sig, struct ecryptfs_auth_tok *auth_tok)\n{\n\tint rc = 0;\n\n\t(*sig) = NULL;\n\tswitch (auth_tok->token_type) {\n\tcase ECRYPTFS_PASSWORD:\n\t\t(*sig) = auth_tok->token.password.signature;\n\t\tbreak;\n\tcase ECRYPTFS_PRIVATE_KEY:\n\t\t(*sig) = auth_tok->token.private_key.signature;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Cannot get sig for auth_tok of type [%d]\\n\",\n\t\t       auth_tok->token_type);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}\n\n \nstatic int\ndecrypt_pki_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,\n\t\t\t\t  struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tu8 cipher_code = 0;\n\tstruct ecryptfs_msg_ctx *msg_ctx;\n\tstruct ecryptfs_message *msg = NULL;\n\tchar *auth_tok_sig;\n\tchar *payload = NULL;\n\tsize_t payload_len = 0;\n\tint rc;\n\n\trc = ecryptfs_get_auth_tok_sig(&auth_tok_sig, auth_tok);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Unrecognized auth tok type: [%d]\\n\",\n\t\t       auth_tok->token_type);\n\t\tgoto out;\n\t}\n\trc = write_tag_64_packet(auth_tok_sig, &(auth_tok->session_key),\n\t\t\t\t &payload, &payload_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Failed to write tag 64 packet\\n\");\n\t\tgoto out;\n\t}\n\trc = ecryptfs_send_message(payload, payload_len, &msg_ctx);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error sending message to \"\n\t\t\t\t\"ecryptfsd: %d\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_wait_for_response(msg_ctx, &msg);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Failed to receive tag 65 packet \"\n\t\t\t\t\"from the user space daemon\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = parse_tag_65_packet(&(auth_tok->session_key),\n\t\t\t\t &cipher_code, msg);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to parse tag 65 packet; rc = [%d]\\n\",\n\t\t       rc);\n\t\tgoto out;\n\t}\n\tauth_tok->session_key.flags |= ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\tmemcpy(crypt_stat->key, auth_tok->session_key.decrypted_key,\n\t       auth_tok->session_key.decrypted_key_size);\n\tcrypt_stat->key_size = auth_tok->session_key.decrypted_key_size;\n\trc = ecryptfs_cipher_code_to_string(crypt_stat->cipher, cipher_code);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Cipher code [%d] is invalid\\n\",\n\t\t\t\tcipher_code);\n\t\tgoto out;\n\t}\n\tcrypt_stat->flags |= ECRYPTFS_KEY_VALID;\n\tif (ecryptfs_verbosity > 0) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Decrypted session key:\\n\");\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\nout:\n\tkfree(msg);\n\tkfree(payload);\n\treturn rc;\n}\n\nstatic void wipe_auth_tok_list(struct list_head *auth_tok_list_head)\n{\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item_tmp;\n\n\tlist_for_each_entry_safe(auth_tok_list_item, auth_tok_list_item_tmp,\n\t\t\t\t auth_tok_list_head, list) {\n\t\tlist_del(&auth_tok_list_item->list);\n\t\tkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\n\t\t\t\tauth_tok_list_item);\n\t}\n}\n\nstruct kmem_cache *ecryptfs_auth_tok_list_item_cache;\n\n \nstatic int\nparse_tag_1_packet(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   unsigned char *data, struct list_head *auth_tok_list,\n\t\t   struct ecryptfs_auth_tok **new_auth_tok,\n\t\t   size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*new_auth_tok) = NULL;\n\t \n\tif (unlikely(max_packet_size < 12)) {\n\t\tprintk(KERN_ERR \"Invalid max packet size; must be >=12\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_1_PACKET_TYPE) {\n\t\tprintk(KERN_ERR \"Enter w/ first byte != 0x%.2x\\n\",\n\t\t       ECRYPTFS_TAG_1_PACKET_TYPE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t \n\tauth_tok_list_item =\n\t\tkmem_cache_zalloc(ecryptfs_auth_tok_list_item_cache,\n\t\t\t\t  GFP_KERNEL);\n\tif (!auth_tok_list_item) {\n\t\tprintk(KERN_ERR \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*new_auth_tok) = &auth_tok_list_item->auth_tok;\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Error parsing packet length; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\t\tgoto out_free;\n\t}\n\tif (unlikely(body_size < (ECRYPTFS_SIG_SIZE + 2))) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*packet_size) += length_size;\n\tif (unlikely((*packet_size) + body_size > max_packet_size)) {\n\t\tprintk(KERN_WARNING \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tif (unlikely(data[(*packet_size)++] != 0x03)) {\n\t\tprintk(KERN_WARNING \"Unknown version number [%d]\\n\",\n\t\t       data[(*packet_size) - 1]);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tecryptfs_to_hex((*new_auth_tok)->token.private_key.signature,\n\t\t\t&data[(*packet_size)], ECRYPTFS_SIG_SIZE);\n\t*packet_size += ECRYPTFS_SIG_SIZE;\n\t \n\t(*packet_size)++;\n\t(*new_auth_tok)->session_key.encrypted_key_size =\n\t\tbody_size - (ECRYPTFS_SIG_SIZE + 2);\n\tif ((*new_auth_tok)->session_key.encrypted_key_size\n\t    > ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES) {\n\t\tprintk(KERN_WARNING \"Tag 1 packet contains key larger \"\n\t\t       \"than ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tmemcpy((*new_auth_tok)->session_key.encrypted_key,\n\t       &data[(*packet_size)], (body_size - (ECRYPTFS_SIG_SIZE + 2)));\n\t(*packet_size) += (*new_auth_tok)->session_key.encrypted_key_size;\n\t(*new_auth_tok)->session_key.flags &=\n\t\t~ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\t(*new_auth_tok)->session_key.flags |=\n\t\tECRYPTFS_CONTAINS_ENCRYPTED_KEY;\n\t(*new_auth_tok)->token_type = ECRYPTFS_PRIVATE_KEY;\n\t(*new_auth_tok)->flags = 0;\n\t(*new_auth_tok)->session_key.flags &=\n\t\t~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_DECRYPT);\n\t(*new_auth_tok)->session_key.flags &=\n\t\t~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_ENCRYPT);\n\tlist_add(&auth_tok_list_item->list, auth_tok_list);\n\tgoto out;\nout_free:\n\t(*new_auth_tok) = NULL;\n\tmemset(auth_tok_list_item, 0,\n\t       sizeof(struct ecryptfs_auth_tok_list_item));\n\tkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\n\t\t\tauth_tok_list_item);\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\treturn rc;\n}\n\n \nstatic int\nparse_tag_3_packet(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   unsigned char *data, struct list_head *auth_tok_list,\n\t\t   struct ecryptfs_auth_tok **new_auth_tok,\n\t\t   size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*new_auth_tok) = NULL;\n\t \n\tif (max_packet_size < (ECRYPTFS_SALT_SIZE + 7)) {\n\t\tprintk(KERN_ERR \"Max packet size too large\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_3_PACKET_TYPE) {\n\t\tprintk(KERN_ERR \"First byte != 0x%.2x; invalid packet\\n\",\n\t\t       ECRYPTFS_TAG_3_PACKET_TYPE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t \n\tauth_tok_list_item =\n\t    kmem_cache_zalloc(ecryptfs_auth_tok_list_item_cache, GFP_KERNEL);\n\tif (!auth_tok_list_item) {\n\t\tprintk(KERN_ERR \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*new_auth_tok) = &auth_tok_list_item->auth_tok;\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Error parsing packet length; rc = [%d]\\n\",\n\t\t       rc);\n\t\tgoto out_free;\n\t}\n\tif (unlikely(body_size < (ECRYPTFS_SALT_SIZE + 5))) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*packet_size) += length_size;\n\tif (unlikely((*packet_size) + body_size > max_packet_size)) {\n\t\tprintk(KERN_ERR \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*new_auth_tok)->session_key.encrypted_key_size =\n\t\t(body_size - (ECRYPTFS_SALT_SIZE + 5));\n\tif ((*new_auth_tok)->session_key.encrypted_key_size\n\t    > ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES) {\n\t\tprintk(KERN_WARNING \"Tag 3 packet contains key larger \"\n\t\t       \"than ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tif (unlikely(data[(*packet_size)++] != 0x04)) {\n\t\tprintk(KERN_WARNING \"Unknown version number [%d]\\n\",\n\t\t       data[(*packet_size) - 1]);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\trc = ecryptfs_cipher_code_to_string(crypt_stat->cipher,\n\t\t\t\t\t    (u16)data[(*packet_size)]);\n\tif (rc)\n\t\tgoto out_free;\n\t \n\tswitch(data[(*packet_size)++]) {\n\tcase RFC2440_CIPHER_AES_192:\n\t\tcrypt_stat->key_size = 24;\n\t\tbreak;\n\tdefault:\n\t\tcrypt_stat->key_size =\n\t\t\t(*new_auth_tok)->session_key.encrypted_key_size;\n\t}\n\trc = ecryptfs_init_crypt_ctx(crypt_stat);\n\tif (rc)\n\t\tgoto out_free;\n\tif (unlikely(data[(*packet_size)++] != 0x03)) {\n\t\tprintk(KERN_WARNING \"Only S2K ID 3 is currently supported\\n\");\n\t\trc = -ENOSYS;\n\t\tgoto out_free;\n\t}\n\t \n\tswitch (data[(*packet_size)++]) {\n\tcase 0x01:  \n\t\t \n\t\tmemcpy((*new_auth_tok)->token.password.salt,\n\t\t       &data[(*packet_size)], ECRYPTFS_SALT_SIZE);\n\t\t(*packet_size) += ECRYPTFS_SALT_SIZE;\n\t\t \n\t\t(*new_auth_tok)->token.password.hash_iterations =\n\t\t\t((u32) 16 + (data[(*packet_size)] & 15))\n\t\t\t\t<< ((data[(*packet_size)] >> 4) + 6);\n\t\t(*packet_size)++;\n\t\t \n\t\tmemcpy((*new_auth_tok)->session_key.encrypted_key,\n\t\t       &data[(*packet_size)],\n\t\t       (*new_auth_tok)->session_key.encrypted_key_size);\n\t\t(*packet_size) +=\n\t\t\t(*new_auth_tok)->session_key.encrypted_key_size;\n\t\t(*new_auth_tok)->session_key.flags &=\n\t\t\t~ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\t\t(*new_auth_tok)->session_key.flags |=\n\t\t\tECRYPTFS_CONTAINS_ENCRYPTED_KEY;\n\t\t(*new_auth_tok)->token.password.hash_algo = 0x01;  \n\t\tbreak;\n\tdefault:\n\t\tecryptfs_printk(KERN_ERR, \"Unsupported hash algorithm: \"\n\t\t\t\t\"[%d]\\n\", data[(*packet_size) - 1]);\n\t\trc = -ENOSYS;\n\t\tgoto out_free;\n\t}\n\t(*new_auth_tok)->token_type = ECRYPTFS_PASSWORD;\n\t \n\t(*new_auth_tok)->session_key.flags &=\n\t\t\t    ~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_DECRYPT);\n\t(*new_auth_tok)->session_key.flags &=\n\t\t\t    ~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_ENCRYPT);\n\tlist_add(&auth_tok_list_item->list, auth_tok_list);\n\tgoto out;\nout_free:\n\t(*new_auth_tok) = NULL;\n\tmemset(auth_tok_list_item, 0,\n\t       sizeof(struct ecryptfs_auth_tok_list_item));\n\tkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\n\t\t\tauth_tok_list_item);\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\treturn rc;\n}\n\n \nstatic int\nparse_tag_11_packet(unsigned char *data, unsigned char *contents,\n\t\t    size_t max_contents_bytes, size_t *tag_11_contents_size,\n\t\t    size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*tag_11_contents_size) = 0;\n\t \n\tif (max_packet_size < 16) {\n\t\tprintk(KERN_ERR \"Maximum packet size too small\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_11_PACKET_TYPE) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\tgoto out;\n\t}\n\tif (body_size < 14) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += length_size;\n\t(*tag_11_contents_size) = (body_size - 14);\n\tif (unlikely((*packet_size) + body_size + 1 > max_packet_size)) {\n\t\tprintk(KERN_ERR \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (unlikely((*tag_11_contents_size) > max_contents_bytes)) {\n\t\tprintk(KERN_ERR \"Literal data section in tag 11 packet exceeds \"\n\t\t       \"expected size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x62) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x08) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += 12;  \n\tmemcpy(contents, &data[(*packet_size)], (*tag_11_contents_size));\n\t(*packet_size) += (*tag_11_contents_size);\nout:\n\tif (rc) {\n\t\t(*packet_size) = 0;\n\t\t(*tag_11_contents_size) = 0;\n\t}\n\treturn rc;\n}\n\nint ecryptfs_keyring_auth_tok_for_sig(struct key **auth_tok_key,\n\t\t\t\t      struct ecryptfs_auth_tok **auth_tok,\n\t\t\t\t      char *sig)\n{\n\tint rc = 0;\n\n\t(*auth_tok_key) = request_key(&key_type_user, sig, NULL);\n\tif (IS_ERR(*auth_tok_key)) {\n\t\t(*auth_tok_key) = ecryptfs_get_encrypted_key(sig);\n\t\tif (IS_ERR(*auth_tok_key)) {\n\t\t\tprintk(KERN_ERR \"Could not find key with description: [%s]\\n\",\n\t\t\t      sig);\n\t\t\trc = process_request_key_err(PTR_ERR(*auth_tok_key));\n\t\t\t(*auth_tok_key) = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tdown_write(&(*auth_tok_key)->sem);\n\trc = ecryptfs_verify_auth_tok_from_key(*auth_tok_key, auth_tok);\n\tif (rc) {\n\t\tup_write(&(*auth_tok_key)->sem);\n\t\tkey_put(*auth_tok_key);\n\t\t(*auth_tok_key) = NULL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}\n\n \nstatic int\ndecrypt_passphrase_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,\n\t\t\t\t\t struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tstruct scatterlist dst_sg[2];\n\tstruct scatterlist src_sg[2];\n\tstruct mutex *tfm_mutex;\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req = NULL;\n\tint rc = 0;\n\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(\n\t\t\tKERN_DEBUG, \"Session key encryption key (size [%d]):\\n\",\n\t\t\tauth_tok->token.password.session_key_encryption_key_bytes);\n\t\tecryptfs_dump_hex(\n\t\t\tauth_tok->token.password.session_key_encryption_key,\n\t\t\tauth_tok->token.password.session_key_encryption_key_bytes);\n\t}\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&tfm, &tfm_mutex,\n\t\t\t\t\t\t\tcrypt_stat->cipher);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       crypt_stat->cipher, rc);\n\t\tgoto out;\n\t}\n\trc = virt_to_scatterlist(auth_tok->session_key.encrypted_key,\n\t\t\t\t auth_tok->session_key.encrypted_key_size,\n\t\t\t\t src_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to convert \"\n\t\t\t\"auth_tok->session_key.encrypted_key to scatterlist; \"\n\t\t\t\"expected rc = 1; got rc = [%d]. \"\n\t\t       \"auth_tok->session_key.encrypted_key_size = [%d]\\n\", rc,\n\t\t\tauth_tok->session_key.encrypted_key_size);\n\t\tgoto out;\n\t}\n\tauth_tok->session_key.decrypted_key_size =\n\t\tauth_tok->session_key.encrypted_key_size;\n\trc = virt_to_scatterlist(auth_tok->session_key.decrypted_key,\n\t\t\t\t auth_tok->session_key.decrypted_key_size,\n\t\t\t\t dst_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to convert \"\n\t\t\t\"auth_tok->session_key.decrypted_key to scatterlist; \"\n\t\t\t\"expected rc = 1; got rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tmutex_lock(tfm_mutex);\n\treq = skcipher_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tmutex_unlock(tfm_mutex);\n\t\tprintk(KERN_ERR \"%s: Out of kernel memory whilst attempting to \"\n\t\t       \"skcipher_request_alloc for %s\\n\", __func__,\n\t\t       crypto_skcipher_driver_name(tfm));\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tskcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t      NULL, NULL);\n\trc = crypto_skcipher_setkey(\n\t\ttfm, auth_tok->token.password.session_key_encryption_key,\n\t\tcrypt_stat->key_size);\n\tif (unlikely(rc < 0)) {\n\t\tmutex_unlock(tfm_mutex);\n\t\tprintk(KERN_ERR \"Error setting key for crypto context\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tskcipher_request_set_crypt(req, src_sg, dst_sg,\n\t\t\t\t   auth_tok->session_key.encrypted_key_size,\n\t\t\t\t   NULL);\n\trc = crypto_skcipher_decrypt(req);\n\tmutex_unlock(tfm_mutex);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Error decrypting; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tauth_tok->session_key.flags |= ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\tmemcpy(crypt_stat->key, auth_tok->session_key.decrypted_key,\n\t       auth_tok->session_key.decrypted_key_size);\n\tcrypt_stat->flags |= ECRYPTFS_KEY_VALID;\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"FEK of size [%zd]:\\n\",\n\t\t\t\tcrypt_stat->key_size);\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\nout:\n\tskcipher_request_free(req);\n\treturn rc;\n}\n\n \nint ecryptfs_parse_packet_set(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t      unsigned char *src,\n\t\t\t      struct dentry *ecryptfs_dentry)\n{\n\tsize_t i = 0;\n\tsize_t found_auth_tok;\n\tsize_t next_packet_is_auth_tok_packet;\n\tstruct list_head auth_tok_list;\n\tstruct ecryptfs_auth_tok *matching_auth_tok;\n\tstruct ecryptfs_auth_tok *candidate_auth_tok;\n\tchar *candidate_auth_tok_sig;\n\tsize_t packet_size;\n\tstruct ecryptfs_auth_tok *new_auth_tok;\n\tunsigned char sig_tmp_space[ECRYPTFS_SIG_SIZE];\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tsize_t tag_11_contents_size;\n\tsize_t tag_11_packet_size;\n\tstruct key *auth_tok_key = NULL;\n\tint rc = 0;\n\n\tINIT_LIST_HEAD(&auth_tok_list);\n\t \n\tnext_packet_is_auth_tok_packet = 1;\n\twhile (next_packet_is_auth_tok_packet) {\n\t\tsize_t max_packet_size = ((PAGE_SIZE - 8) - i);\n\n\t\tswitch (src[i]) {\n\t\tcase ECRYPTFS_TAG_3_PACKET_TYPE:\n\t\t\trc = parse_tag_3_packet(crypt_stat,\n\t\t\t\t\t\t(unsigned char *)&src[i],\n\t\t\t\t\t\t&auth_tok_list, &new_auth_tok,\n\t\t\t\t\t\t&packet_size, max_packet_size);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Error parsing \"\n\t\t\t\t\t\t\"tag 3 packet\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\ti += packet_size;\n\t\t\trc = parse_tag_11_packet((unsigned char *)&src[i],\n\t\t\t\t\t\t sig_tmp_space,\n\t\t\t\t\t\t ECRYPTFS_SIG_SIZE,\n\t\t\t\t\t\t &tag_11_contents_size,\n\t\t\t\t\t\t &tag_11_packet_size,\n\t\t\t\t\t\t max_packet_size);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"No valid \"\n\t\t\t\t\t\t\"(ecryptfs-specific) literal \"\n\t\t\t\t\t\t\"packet containing \"\n\t\t\t\t\t\t\"authentication token \"\n\t\t\t\t\t\t\"signature found after \"\n\t\t\t\t\t\t\"tag 3 packet\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\ti += tag_11_packet_size;\n\t\t\tif (ECRYPTFS_SIG_SIZE != tag_11_contents_size) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Expected \"\n\t\t\t\t\t\t\"signature of size [%d]; \"\n\t\t\t\t\t\t\"read size [%zd]\\n\",\n\t\t\t\t\t\tECRYPTFS_SIG_SIZE,\n\t\t\t\t\t\ttag_11_contents_size);\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\tecryptfs_to_hex(new_auth_tok->token.password.signature,\n\t\t\t\t\tsig_tmp_space, tag_11_contents_size);\n\t\t\tnew_auth_tok->token.password.signature[\n\t\t\t\tECRYPTFS_PASSWORD_SIG_SIZE] = '\\0';\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPTED;\n\t\t\tbreak;\n\t\tcase ECRYPTFS_TAG_1_PACKET_TYPE:\n\t\t\trc = parse_tag_1_packet(crypt_stat,\n\t\t\t\t\t\t(unsigned char *)&src[i],\n\t\t\t\t\t\t&auth_tok_list, &new_auth_tok,\n\t\t\t\t\t\t&packet_size, max_packet_size);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Error parsing \"\n\t\t\t\t\t\t\"tag 1 packet\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\ti += packet_size;\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPTED;\n\t\t\tbreak;\n\t\tcase ECRYPTFS_TAG_11_PACKET_TYPE:\n\t\t\tecryptfs_printk(KERN_WARNING, \"Invalid packet set \"\n\t\t\t\t\t\"(Tag 11 not allowed by itself)\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto out_wipe_list;\n\t\tdefault:\n\t\t\tecryptfs_printk(KERN_DEBUG, \"No packet at offset [%zd] \"\n\t\t\t\t\t\"of the file header; hex value of \"\n\t\t\t\t\t\"character is [0x%.2x]\\n\", i, src[i]);\n\t\t\tnext_packet_is_auth_tok_packet = 0;\n\t\t}\n\t}\n\tif (list_empty(&auth_tok_list)) {\n\t\tprintk(KERN_ERR \"The lower file appears to be a non-encrypted \"\n\t\t       \"eCryptfs file; this is not supported in this version \"\n\t\t       \"of the eCryptfs kernel module\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t \nfind_next_matching_auth_tok:\n\tfound_auth_tok = 0;\n\tlist_for_each_entry(auth_tok_list_item, &auth_tok_list, list) {\n\t\tcandidate_auth_tok = &auth_tok_list_item->auth_tok;\n\t\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\t\"Considering candidate auth tok:\\n\");\n\t\t\tecryptfs_dump_auth_tok(candidate_auth_tok);\n\t\t}\n\t\trc = ecryptfs_get_auth_tok_sig(&candidate_auth_tok_sig,\n\t\t\t\t\t       candidate_auth_tok);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"Unrecognized candidate auth tok type: [%d]\\n\",\n\t\t\t       candidate_auth_tok->token_type);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_wipe_list;\n\t\t}\n\t\trc = ecryptfs_find_auth_tok_for_sig(&auth_tok_key,\n\t\t\t\t\t       &matching_auth_tok,\n\t\t\t\t\t       crypt_stat->mount_crypt_stat,\n\t\t\t\t\t       candidate_auth_tok_sig);\n\t\tif (!rc) {\n\t\t\tfound_auth_tok = 1;\n\t\t\tgoto found_matching_auth_tok;\n\t\t}\n\t}\n\tif (!found_auth_tok) {\n\t\tecryptfs_printk(KERN_ERR, \"Could not find a usable \"\n\t\t\t\t\"authentication token\\n\");\n\t\trc = -EIO;\n\t\tgoto out_wipe_list;\n\t}\nfound_matching_auth_tok:\n\tif (candidate_auth_tok->token_type == ECRYPTFS_PRIVATE_KEY) {\n\t\tmemcpy(&(candidate_auth_tok->token.private_key),\n\t\t       &(matching_auth_tok->token.private_key),\n\t\t       sizeof(struct ecryptfs_private_key));\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\trc = decrypt_pki_encrypted_session_key(candidate_auth_tok,\n\t\t\t\t\t\t       crypt_stat);\n\t} else if (candidate_auth_tok->token_type == ECRYPTFS_PASSWORD) {\n\t\tmemcpy(&(candidate_auth_tok->token.password),\n\t\t       &(matching_auth_tok->token.password),\n\t\t       sizeof(struct ecryptfs_password));\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\trc = decrypt_passphrase_encrypted_session_key(\n\t\t\tcandidate_auth_tok, crypt_stat);\n\t} else {\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\trc = -EINVAL;\n\t}\n\tif (rc) {\n\t\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item_tmp;\n\n\t\tecryptfs_printk(KERN_WARNING, \"Error decrypting the \"\n\t\t\t\t\"session key for authentication token with sig \"\n\t\t\t\t\"[%.*s]; rc = [%d]. Removing auth tok \"\n\t\t\t\t\"candidate from the list and searching for \"\n\t\t\t\t\"the next match.\\n\", ECRYPTFS_SIG_SIZE_HEX,\n\t\t\t\tcandidate_auth_tok_sig,\trc);\n\t\tlist_for_each_entry_safe(auth_tok_list_item,\n\t\t\t\t\t auth_tok_list_item_tmp,\n\t\t\t\t\t &auth_tok_list, list) {\n\t\t\tif (candidate_auth_tok\n\t\t\t    == &auth_tok_list_item->auth_tok) {\n\t\t\t\tlist_del(&auth_tok_list_item->list);\n\t\t\t\tkmem_cache_free(\n\t\t\t\t\tecryptfs_auth_tok_list_item_cache,\n\t\t\t\t\tauth_tok_list_item);\n\t\t\t\tgoto find_next_matching_auth_tok;\n\t\t\t}\n\t\t}\n\t\tBUG();\n\t}\n\trc = ecryptfs_compute_root_iv(crypt_stat);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error computing \"\n\t\t\t\t\"the root IV\\n\");\n\t\tgoto out_wipe_list;\n\t}\n\trc = ecryptfs_init_crypt_ctx(crypt_stat);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error initializing crypto \"\n\t\t\t\t\"context for cipher [%s]; rc = [%d]\\n\",\n\t\t\t\tcrypt_stat->cipher, rc);\n\t}\nout_wipe_list:\n\twipe_auth_tok_list(&auth_tok_list);\nout:\n\treturn rc;\n}\n\nstatic int\npki_encrypt_session_key(struct key *auth_tok_key,\n\t\t\tstruct ecryptfs_auth_tok *auth_tok,\n\t\t\tstruct ecryptfs_crypt_stat *crypt_stat,\n\t\t\tstruct ecryptfs_key_record *key_rec)\n{\n\tstruct ecryptfs_msg_ctx *msg_ctx = NULL;\n\tchar *payload = NULL;\n\tsize_t payload_len = 0;\n\tstruct ecryptfs_message *msg;\n\tint rc;\n\n\trc = write_tag_66_packet(auth_tok->token.private_key.signature,\n\t\t\t\t ecryptfs_code_for_cipher_string(\n\t\t\t\t\t crypt_stat->cipher,\n\t\t\t\t\t crypt_stat->key_size),\n\t\t\t\t crypt_stat, &payload, &payload_len);\n\tup_write(&(auth_tok_key->sem));\n\tkey_put(auth_tok_key);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 66 packet\\n\");\n\t\tgoto out;\n\t}\n\trc = ecryptfs_send_message(payload, payload_len, &msg_ctx);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error sending message to \"\n\t\t\t\t\"ecryptfsd: %d\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_wait_for_response(msg_ctx, &msg);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Failed to receive tag 67 packet \"\n\t\t\t\t\"from the user space daemon\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = parse_tag_67_packet(key_rec, msg);\n\tif (rc)\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing tag 67 packet\\n\");\n\tkfree(msg);\nout:\n\tkfree(payload);\n\treturn rc;\n}\n \nstatic int\nwrite_tag_1_packet(char *dest, size_t *remaining_bytes,\n\t\t   struct key *auth_tok_key, struct ecryptfs_auth_tok *auth_tok,\n\t\t   struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   struct ecryptfs_key_record *key_rec, size_t *packet_size)\n{\n\tsize_t i;\n\tsize_t encrypted_session_key_valid = 0;\n\tsize_t packet_size_length;\n\tsize_t max_packet_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\tecryptfs_from_hex(key_rec->sig, auth_tok->token.private_key.signature,\n\t\t\t  ECRYPTFS_SIG_SIZE);\n\tencrypted_session_key_valid = 0;\n\tfor (i = 0; i < crypt_stat->key_size; i++)\n\t\tencrypted_session_key_valid |=\n\t\t\tauth_tok->session_key.encrypted_key[i];\n\tif (encrypted_session_key_valid) {\n\t\tmemcpy(key_rec->enc_key,\n\t\t       auth_tok->session_key.encrypted_key,\n\t\t       auth_tok->session_key.encrypted_key_size);\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\tgoto encrypted_session_key_set;\n\t}\n\tif (auth_tok->session_key.encrypted_key_size == 0)\n\t\tauth_tok->session_key.encrypted_key_size =\n\t\t\tauth_tok->token.private_key.key_size;\n\trc = pki_encrypt_session_key(auth_tok_key, auth_tok, crypt_stat,\n\t\t\t\t     key_rec);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to encrypt session key via a key \"\n\t\t       \"module; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tif (ecryptfs_verbosity > 0) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Encrypted key:\\n\");\n\t\tecryptfs_dump_hex(key_rec->enc_key, key_rec->enc_key_size);\n\t}\nencrypted_session_key_set:\n\t \n\tmax_packet_size = (1                          \n\t\t\t   + 3                        \n\t\t\t   + 1                        \n\t\t\t   + ECRYPTFS_SIG_SIZE        \n\t\t\t   + 1                        \n\t\t\t   + key_rec->enc_key_size);  \n\tif (max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_ERR \"Packet length larger than maximum allowable; \"\n\t\t       \"need up to [%td] bytes, but there are only [%td] \"\n\t\t       \"available\\n\", max_packet_size, (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_size)++] = ECRYPTFS_TAG_1_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&dest[(*packet_size)],\n\t\t\t\t\t  (max_packet_size - 4),\n\t\t\t\t\t  &packet_size_length);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 1 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\t(*packet_size) += packet_size_length;\n\tdest[(*packet_size)++] = 0x03;  \n\tmemcpy(&dest[(*packet_size)], key_rec->sig, ECRYPTFS_SIG_SIZE);\n\t(*packet_size) += ECRYPTFS_SIG_SIZE;\n\tdest[(*packet_size)++] = RFC2440_CIPHER_RSA;\n\tmemcpy(&dest[(*packet_size)], key_rec->enc_key,\n\t       key_rec->enc_key_size);\n\t(*packet_size) += key_rec->enc_key_size;\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\telse\n\t\t(*remaining_bytes) -= (*packet_size);\n\treturn rc;\n}\n\n \nstatic int\nwrite_tag_11_packet(char *dest, size_t *remaining_bytes, char *contents,\n\t\t    size_t contents_length, size_t *packet_length)\n{\n\tsize_t packet_size_length;\n\tsize_t max_packet_size;\n\tint rc = 0;\n\n\t(*packet_length) = 0;\n\t \n\tmax_packet_size = (1                    \n\t\t\t   + 3                  \n\t\t\t   + 1                  \n\t\t\t   + 1                  \n\t\t\t   + 8                  \n\t\t\t   + 4                  \n\t\t\t   + contents_length);  \n\tif (max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_ERR \"Packet length larger than maximum allowable; \"\n\t\t       \"need up to [%td] bytes, but there are only [%td] \"\n\t\t       \"available\\n\", max_packet_size, (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_length)++] = ECRYPTFS_TAG_11_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&dest[(*packet_length)],\n\t\t\t\t\t  (max_packet_size - 4),\n\t\t\t\t\t  &packet_size_length);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error generating tag 11 packet header; cannot \"\n\t\t       \"generate packet length. rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\t(*packet_length) += packet_size_length;\n\tdest[(*packet_length)++] = 0x62;  \n\tdest[(*packet_length)++] = 8;\n\tmemcpy(&dest[(*packet_length)], \"_CONSOLE\", 8);\n\t(*packet_length) += 8;\n\tmemset(&dest[(*packet_length)], 0x00, 4);\n\t(*packet_length) += 4;\n\tmemcpy(&dest[(*packet_length)], contents, contents_length);\n\t(*packet_length) += contents_length;\n out:\n\tif (rc)\n\t\t(*packet_length) = 0;\n\telse\n\t\t(*remaining_bytes) -= (*packet_length);\n\treturn rc;\n}\n\n \nstatic int\nwrite_tag_3_packet(char *dest, size_t *remaining_bytes,\n\t\t   struct ecryptfs_auth_tok *auth_tok,\n\t\t   struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   struct ecryptfs_key_record *key_rec, size_t *packet_size)\n{\n\tsize_t i;\n\tsize_t encrypted_session_key_valid = 0;\n\tchar session_key_encryption_key[ECRYPTFS_MAX_KEY_BYTES];\n\tstruct scatterlist dst_sg[2];\n\tstruct scatterlist src_sg[2];\n\tstruct mutex *tfm_mutex = NULL;\n\tu8 cipher_code;\n\tsize_t packet_size_length;\n\tsize_t max_packet_size;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\tcrypt_stat->mount_crypt_stat;\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\tecryptfs_from_hex(key_rec->sig, auth_tok->token.password.signature,\n\t\t\t  ECRYPTFS_SIG_SIZE);\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&tfm, &tfm_mutex,\n\t\t\t\t\t\t\tcrypt_stat->cipher);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       crypt_stat->cipher, rc);\n\t\tgoto out;\n\t}\n\tif (mount_crypt_stat->global_default_cipher_key_size == 0) {\n\t\tprintk(KERN_WARNING \"No key size specified at mount; \"\n\t\t       \"defaulting to [%d]\\n\",\n\t\t       crypto_skcipher_max_keysize(tfm));\n\t\tmount_crypt_stat->global_default_cipher_key_size =\n\t\t\tcrypto_skcipher_max_keysize(tfm);\n\t}\n\tif (crypt_stat->key_size == 0)\n\t\tcrypt_stat->key_size =\n\t\t\tmount_crypt_stat->global_default_cipher_key_size;\n\tif (auth_tok->session_key.encrypted_key_size == 0)\n\t\tauth_tok->session_key.encrypted_key_size =\n\t\t\tcrypt_stat->key_size;\n\tif (crypt_stat->key_size == 24\n\t    && strcmp(\"aes\", crypt_stat->cipher) == 0) {\n\t\tmemset((crypt_stat->key + 24), 0, 8);\n\t\tauth_tok->session_key.encrypted_key_size = 32;\n\t} else\n\t\tauth_tok->session_key.encrypted_key_size = crypt_stat->key_size;\n\tkey_rec->enc_key_size =\n\t\tauth_tok->session_key.encrypted_key_size;\n\tencrypted_session_key_valid = 0;\n\tfor (i = 0; i < auth_tok->session_key.encrypted_key_size; i++)\n\t\tencrypted_session_key_valid |=\n\t\t\tauth_tok->session_key.encrypted_key[i];\n\tif (encrypted_session_key_valid) {\n\t\tecryptfs_printk(KERN_DEBUG, \"encrypted_session_key_valid != 0; \"\n\t\t\t\t\"using auth_tok->session_key.encrypted_key, \"\n\t\t\t\t\"where key_rec->enc_key_size = [%zd]\\n\",\n\t\t\t\tkey_rec->enc_key_size);\n\t\tmemcpy(key_rec->enc_key,\n\t\t       auth_tok->session_key.encrypted_key,\n\t\t       key_rec->enc_key_size);\n\t\tgoto encrypted_session_key_set;\n\t}\n\tif (auth_tok->token.password.flags &\n\t    ECRYPTFS_SESSION_KEY_ENCRYPTION_KEY_SET) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Using previously generated \"\n\t\t\t\t\"session key encryption key of size [%d]\\n\",\n\t\t\t\tauth_tok->token.password.\n\t\t\t\tsession_key_encryption_key_bytes);\n\t\tmemcpy(session_key_encryption_key,\n\t\t       auth_tok->token.password.session_key_encryption_key,\n\t\t       crypt_stat->key_size);\n\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\"Cached session key encryption key:\\n\");\n\t\tif (ecryptfs_verbosity > 0)\n\t\t\tecryptfs_dump_hex(session_key_encryption_key, 16);\n\t}\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Session key encryption key:\\n\");\n\t\tecryptfs_dump_hex(session_key_encryption_key, 16);\n\t}\n\trc = virt_to_scatterlist(crypt_stat->key, key_rec->enc_key_size,\n\t\t\t\t src_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating scatterlist \"\n\t\t\t\t\"for crypt_stat session key; expected rc = 1; \"\n\t\t\t\t\"got rc = [%d]. key_rec->enc_key_size = [%zd]\\n\",\n\t\t\t\trc, key_rec->enc_key_size);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\trc = virt_to_scatterlist(key_rec->enc_key, key_rec->enc_key_size,\n\t\t\t\t dst_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating scatterlist \"\n\t\t\t\t\"for crypt_stat encrypted session key; \"\n\t\t\t\t\"expected rc = 1; got rc = [%d]. \"\n\t\t\t\t\"key_rec->enc_key_size = [%zd]\\n\", rc,\n\t\t\t\tkey_rec->enc_key_size);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmutex_lock(tfm_mutex);\n\trc = crypto_skcipher_setkey(tfm, session_key_encryption_key,\n\t\t\t\t    crypt_stat->key_size);\n\tif (rc < 0) {\n\t\tmutex_unlock(tfm_mutex);\n\t\tecryptfs_printk(KERN_ERR, \"Error setting key for crypto \"\n\t\t\t\t\"context; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\n\treq = skcipher_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tmutex_unlock(tfm_mutex);\n\t\tecryptfs_printk(KERN_ERR, \"Out of kernel memory whilst \"\n\t\t\t\t\"attempting to skcipher_request_alloc for \"\n\t\t\t\t\"%s\\n\", crypto_skcipher_driver_name(tfm));\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tskcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t      NULL, NULL);\n\n\trc = 0;\n\tecryptfs_printk(KERN_DEBUG, \"Encrypting [%zd] bytes of the key\\n\",\n\t\t\tcrypt_stat->key_size);\n\tskcipher_request_set_crypt(req, src_sg, dst_sg,\n\t\t\t\t   (*key_rec).enc_key_size, NULL);\n\trc = crypto_skcipher_encrypt(req);\n\tmutex_unlock(tfm_mutex);\n\tskcipher_request_free(req);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error encrypting; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tecryptfs_printk(KERN_DEBUG, \"This should be the encrypted key:\\n\");\n\tif (ecryptfs_verbosity > 0) {\n\t\tecryptfs_printk(KERN_DEBUG, \"EFEK of size [%zd]:\\n\",\n\t\t\t\tkey_rec->enc_key_size);\n\t\tecryptfs_dump_hex(key_rec->enc_key,\n\t\t\t\t  key_rec->enc_key_size);\n\t}\nencrypted_session_key_set:\n\t \n\tmax_packet_size = (1                          \n\t\t\t   + 3                        \n\t\t\t   + 1                        \n\t\t\t   + 1                        \n\t\t\t   + 1                        \n\t\t\t   + 1                        \n\t\t\t   + ECRYPTFS_SALT_SIZE       \n\t\t\t   + 1                        \n\t\t\t   + key_rec->enc_key_size);  \n\tif (max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_ERR \"Packet too large; need up to [%td] bytes, but \"\n\t\t       \"there are only [%td] available\\n\", max_packet_size,\n\t\t       (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_size)++] = ECRYPTFS_TAG_3_PACKET_TYPE;\n\t \n\trc = ecryptfs_write_packet_length(&dest[(*packet_size)],\n\t\t\t\t\t  (max_packet_size - 4),\n\t\t\t\t\t  &packet_size_length);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error generating tag 3 packet header; cannot \"\n\t\t       \"generate packet length. rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\t(*packet_size) += packet_size_length;\n\tdest[(*packet_size)++] = 0x04;  \n\t \n\tcipher_code = ecryptfs_code_for_cipher_string(crypt_stat->cipher,\n\t\t\t\t\t\t      crypt_stat->key_size);\n\tif (cipher_code == 0) {\n\t\tecryptfs_printk(KERN_WARNING, \"Unable to generate code for \"\n\t\t\t\t\"cipher [%s]\\n\", crypt_stat->cipher);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_size)++] = cipher_code;\n\tdest[(*packet_size)++] = 0x03;\t \n\tdest[(*packet_size)++] = 0x01;\t \n\tmemcpy(&dest[(*packet_size)], auth_tok->token.password.salt,\n\t       ECRYPTFS_SALT_SIZE);\n\t(*packet_size) += ECRYPTFS_SALT_SIZE;\t \n\tdest[(*packet_size)++] = 0x60;\t \n\tmemcpy(&dest[(*packet_size)], key_rec->enc_key,\n\t       key_rec->enc_key_size);\n\t(*packet_size) += key_rec->enc_key_size;\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\telse\n\t\t(*remaining_bytes) -= (*packet_size);\n\treturn rc;\n}\n\nstruct kmem_cache *ecryptfs_key_record_cache;\n\n \nint\necryptfs_generate_key_packet_set(char *dest_base,\n\t\t\t\t struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t struct dentry *ecryptfs_dentry, size_t *len,\n\t\t\t\t size_t max)\n{\n\tstruct ecryptfs_auth_tok *auth_tok;\n\tstruct key *auth_tok_key = NULL;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(\n\t\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\tsize_t written;\n\tstruct ecryptfs_key_record *key_rec;\n\tstruct ecryptfs_key_sig *key_sig;\n\tint rc = 0;\n\n\t(*len) = 0;\n\tmutex_lock(&crypt_stat->keysig_list_mutex);\n\tkey_rec = kmem_cache_alloc(ecryptfs_key_record_cache, GFP_KERNEL);\n\tif (!key_rec) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tlist_for_each_entry(key_sig, &crypt_stat->keysig_list,\n\t\t\t    crypt_stat_list) {\n\t\tmemset(key_rec, 0, sizeof(*key_rec));\n\t\trc = ecryptfs_find_global_auth_tok_for_sig(&auth_tok_key,\n\t\t\t\t\t\t\t   &auth_tok,\n\t\t\t\t\t\t\t   mount_crypt_stat,\n\t\t\t\t\t\t\t   key_sig->keysig);\n\t\tif (rc) {\n\t\t\tprintk(KERN_WARNING \"Unable to retrieve auth tok with \"\n\t\t\t       \"sig = [%s]\\n\", key_sig->keysig);\n\t\t\trc = process_find_global_auth_tok_for_sig_err(rc);\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (auth_tok->token_type == ECRYPTFS_PASSWORD) {\n\t\t\trc = write_tag_3_packet((dest_base + (*len)),\n\t\t\t\t\t\t&max, auth_tok,\n\t\t\t\t\t\tcrypt_stat, key_rec,\n\t\t\t\t\t\t&written);\n\t\t\tup_write(&(auth_tok_key->sem));\n\t\t\tkey_put(auth_tok_key);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_WARNING, \"Error \"\n\t\t\t\t\t\t\"writing tag 3 packet\\n\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t(*len) += written;\n\t\t\t \n\t\t\trc = write_tag_11_packet((dest_base + (*len)), &max,\n\t\t\t\t\t\t key_rec->sig,\n\t\t\t\t\t\t ECRYPTFS_SIG_SIZE, &written);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Error writing \"\n\t\t\t\t\t\t\"auth tok signature packet\\n\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t(*len) += written;\n\t\t} else if (auth_tok->token_type == ECRYPTFS_PRIVATE_KEY) {\n\t\t\trc = write_tag_1_packet(dest_base + (*len), &max,\n\t\t\t\t\t\tauth_tok_key, auth_tok,\n\t\t\t\t\t\tcrypt_stat, key_rec, &written);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_WARNING, \"Error \"\n\t\t\t\t\t\t\"writing tag 1 packet\\n\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t(*len) += written;\n\t\t} else {\n\t\t\tup_write(&(auth_tok_key->sem));\n\t\t\tkey_put(auth_tok_key);\n\t\t\tecryptfs_printk(KERN_WARNING, \"Unsupported \"\n\t\t\t\t\t\"authentication token type\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\tif (likely(max > 0)) {\n\t\tdest_base[(*len)] = 0x00;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error writing boundary byte\\n\");\n\t\trc = -EIO;\n\t}\nout_free:\n\tkmem_cache_free(ecryptfs_key_record_cache, key_rec);\nout:\n\tif (rc)\n\t\t(*len) = 0;\n\tmutex_unlock(&crypt_stat->keysig_list_mutex);\n\treturn rc;\n}\n\nstruct kmem_cache *ecryptfs_key_sig_cache;\n\nint ecryptfs_add_keysig(struct ecryptfs_crypt_stat *crypt_stat, char *sig)\n{\n\tstruct ecryptfs_key_sig *new_key_sig;\n\n\tnew_key_sig = kmem_cache_alloc(ecryptfs_key_sig_cache, GFP_KERNEL);\n\tif (!new_key_sig)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_key_sig->keysig, sig, ECRYPTFS_SIG_SIZE_HEX);\n\tnew_key_sig->keysig[ECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t \n\tlist_add(&new_key_sig->crypt_stat_list, &crypt_stat->keysig_list);\n\n\treturn 0;\n}\n\nstruct kmem_cache *ecryptfs_global_auth_tok_cache;\n\nint\necryptfs_add_global_auth_tok(struct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\t\t\t     char *sig, u32 global_auth_tok_flags)\n{\n\tstruct ecryptfs_global_auth_tok *new_auth_tok;\n\n\tnew_auth_tok = kmem_cache_zalloc(ecryptfs_global_auth_tok_cache,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!new_auth_tok)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_auth_tok->sig, sig, ECRYPTFS_SIG_SIZE_HEX);\n\tnew_auth_tok->flags = global_auth_tok_flags;\n\tnew_auth_tok->sig[ECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_add(&new_auth_tok->mount_crypt_stat_list,\n\t\t &mount_crypt_stat->global_auth_tok_list);\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}