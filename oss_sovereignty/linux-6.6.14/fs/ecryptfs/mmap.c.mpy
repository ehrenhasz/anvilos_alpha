{
  "module_name": "mmap.c",
  "hash_id": "caa2ad34fe3bb29c2d69b9bbe24e8c1b245615e74c6a2ebd748e110cf6787a8e",
  "original_prompt": "Ingested from linux-6.6.14/fs/ecryptfs/mmap.c",
  "human_readable_source": "\n \n\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/page-flags.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <asm/unaligned.h>\n#include \"ecryptfs_kernel.h\"\n\n \nstruct page *ecryptfs_get_locked_page(struct inode *inode, loff_t index)\n{\n\tstruct page *page = read_mapping_page(inode->i_mapping, index, NULL);\n\tif (!IS_ERR(page))\n\t\tlock_page(page);\n\treturn page;\n}\n\n \nstatic int ecryptfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint rc;\n\n\trc = ecryptfs_encrypt_page(page);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error encrypting \"\n\t\t\t\t\"page (upper index [0x%.16lx])\\n\", page->index);\n\t\tClearPageUptodate(page);\n\t\tgoto out;\n\t}\n\tSetPageUptodate(page);\nout:\n\tunlock_page(page);\n\treturn rc;\n}\n\nstatic void strip_xattr_flag(char *page_virt,\n\t\t\t     struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR) {\n\t\tsize_t written;\n\n\t\tcrypt_stat->flags &= ~ECRYPTFS_METADATA_IN_XATTR;\n\t\tecryptfs_write_crypt_stat_flags(page_virt, crypt_stat,\n\t\t\t\t\t\t&written);\n\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\t}\n}\n\n \n\n \nstatic int\necryptfs_copy_up_encrypted_with_header(struct page *page,\n\t\t\t\t       struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tloff_t extent_num_in_page = 0;\n\tloff_t num_extents_per_page = (PAGE_SIZE\n\t\t\t\t       / crypt_stat->extent_size);\n\tint rc = 0;\n\n\twhile (extent_num_in_page < num_extents_per_page) {\n\t\tloff_t view_extent_num = ((((loff_t)page->index)\n\t\t\t\t\t   * num_extents_per_page)\n\t\t\t\t\t  + extent_num_in_page);\n\t\tsize_t num_header_extents_at_front =\n\t\t\t(crypt_stat->metadata_size / crypt_stat->extent_size);\n\n\t\tif (view_extent_num < num_header_extents_at_front) {\n\t\t\t \n\t\t\tchar *page_virt;\n\n\t\t\tpage_virt = kmap_local_page(page);\n\t\t\tmemset(page_virt, 0, PAGE_SIZE);\n\t\t\t \n\t\t\tif (view_extent_num == 0) {\n\t\t\t\tsize_t written;\n\n\t\t\t\trc = ecryptfs_read_xattr_region(\n\t\t\t\t\tpage_virt, page->mapping->host);\n\t\t\t\tstrip_xattr_flag(page_virt + 16, crypt_stat);\n\t\t\t\tecryptfs_write_header_metadata(page_virt + 20,\n\t\t\t\t\t\t\t       crypt_stat,\n\t\t\t\t\t\t\t       &written);\n\t\t\t}\n\t\t\tkunmap_local(page_virt);\n\t\t\tflush_dcache_page(page);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error reading xattr \"\n\t\t\t\t       \"region; rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tloff_t lower_offset =\n\t\t\t\t((view_extent_num * crypt_stat->extent_size)\n\t\t\t\t - crypt_stat->metadata_size);\n\n\t\t\trc = ecryptfs_read_lower_page_segment(\n\t\t\t\tpage, (lower_offset >> PAGE_SHIFT),\n\t\t\t\t(lower_offset & ~PAGE_MASK),\n\t\t\t\tcrypt_stat->extent_size, page->mapping->host);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error attempting to read \"\n\t\t\t\t       \"extent at offset [%lld] in the lower \"\n\t\t\t\t       \"file; rc = [%d]\\n\", __func__,\n\t\t\t\t       lower_offset, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\textent_num_in_page++;\n\t}\nout:\n\treturn rc;\n}\n\n \nstatic int ecryptfs_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct page *page = &folio->page;\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(page->mapping->host)->crypt_stat;\n\tint rc = 0;\n\n\tif (!crypt_stat || !(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\trc = ecryptfs_read_lower_page_segment(page, page->index, 0,\n\t\t\t\t\t\t      PAGE_SIZE,\n\t\t\t\t\t\t      page->mapping->host);\n\t} else if (crypt_stat->flags & ECRYPTFS_VIEW_AS_ENCRYPTED) {\n\t\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR) {\n\t\t\trc = ecryptfs_copy_up_encrypted_with_header(page,\n\t\t\t\t\t\t\t\t    crypt_stat);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error attempting to copy \"\n\t\t\t\t       \"the encrypted content from the lower \"\n\t\t\t\t       \"file whilst inserting the metadata \"\n\t\t\t\t       \"from the xattr into the header; rc = \"\n\t\t\t\t       \"[%d]\\n\", __func__, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t} else {\n\t\t\trc = ecryptfs_read_lower_page_segment(\n\t\t\t\tpage, page->index, 0, PAGE_SIZE,\n\t\t\t\tpage->mapping->host);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error reading page; rc = \"\n\t\t\t\t       \"[%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = ecryptfs_decrypt_page(page);\n\t\tif (rc) {\n\t\t\tecryptfs_printk(KERN_ERR, \"Error decrypting page; \"\n\t\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tif (rc)\n\t\tClearPageUptodate(page);\n\telse\n\t\tSetPageUptodate(page);\n\tecryptfs_printk(KERN_DEBUG, \"Unlocking page with index = [0x%.16lx]\\n\",\n\t\t\tpage->index);\n\tunlock_page(page);\n\treturn rc;\n}\n\n \nstatic int fill_zeros_to_end_of_page(struct page *page, unsigned int to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint end_byte_in_page;\n\n\tif ((i_size_read(inode) / PAGE_SIZE) != page->index)\n\t\tgoto out;\n\tend_byte_in_page = i_size_read(inode) % PAGE_SIZE;\n\tif (to > end_byte_in_page)\n\t\tend_byte_in_page = to;\n\tzero_user_segment(page, end_byte_in_page, PAGE_SIZE);\nout:\n\treturn 0;\n}\n\n \nstatic int ecryptfs_write_begin(struct file *file,\n\t\t\tstruct address_space *mapping,\n\t\t\tloff_t pos, unsigned len,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tstruct page *page;\n\tloff_t prev_page_end_size;\n\tint rc = 0;\n\n\tpage = grab_cache_page_write_begin(mapping, index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\n\tprev_page_end_size = ((loff_t)index << PAGE_SHIFT);\n\tif (!PageUptodate(page)) {\n\t\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t\t&ecryptfs_inode_to_private(mapping->host)->crypt_stat;\n\n\t\tif (!(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\t\trc = ecryptfs_read_lower_page_segment(\n\t\t\t\tpage, index, 0, PAGE_SIZE, mapping->host);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error attempting to read \"\n\t\t\t\t       \"lower page segment; rc = [%d]\\n\",\n\t\t\t\t       __func__, rc);\n\t\t\t\tClearPageUptodate(page);\n\t\t\t\tgoto out;\n\t\t\t} else\n\t\t\t\tSetPageUptodate(page);\n\t\t} else if (crypt_stat->flags & ECRYPTFS_VIEW_AS_ENCRYPTED) {\n\t\t\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR) {\n\t\t\t\trc = ecryptfs_copy_up_encrypted_with_header(\n\t\t\t\t\tpage, crypt_stat);\n\t\t\t\tif (rc) {\n\t\t\t\t\tprintk(KERN_ERR \"%s: Error attempting \"\n\t\t\t\t\t       \"to copy the encrypted content \"\n\t\t\t\t\t       \"from the lower file whilst \"\n\t\t\t\t\t       \"inserting the metadata from \"\n\t\t\t\t\t       \"the xattr into the header; rc \"\n\t\t\t\t\t       \"= [%d]\\n\", __func__, rc);\n\t\t\t\t\tClearPageUptodate(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tSetPageUptodate(page);\n\t\t\t} else {\n\t\t\t\trc = ecryptfs_read_lower_page_segment(\n\t\t\t\t\tpage, index, 0, PAGE_SIZE,\n\t\t\t\t\tmapping->host);\n\t\t\t\tif (rc) {\n\t\t\t\t\tprintk(KERN_ERR \"%s: Error reading \"\n\t\t\t\t\t       \"page; rc = [%d]\\n\",\n\t\t\t\t\t       __func__, rc);\n\t\t\t\t\tClearPageUptodate(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tSetPageUptodate(page);\n\t\t\t}\n\t\t} else {\n\t\t\tif (prev_page_end_size\n\t\t\t    >= i_size_read(page->mapping->host)) {\n\t\t\t\tzero_user(page, 0, PAGE_SIZE);\n\t\t\t\tSetPageUptodate(page);\n\t\t\t} else if (len < PAGE_SIZE) {\n\t\t\t\trc = ecryptfs_decrypt_page(page);\n\t\t\t\tif (rc) {\n\t\t\t\t\tprintk(KERN_ERR \"%s: Error decrypting \"\n\t\t\t\t\t       \"page at index [%ld]; \"\n\t\t\t\t\t       \"rc = [%d]\\n\",\n\t\t\t\t\t       __func__, page->index, rc);\n\t\t\t\t\tClearPageUptodate(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tSetPageUptodate(page);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (index != 0) {\n\t\tif (prev_page_end_size > i_size_read(page->mapping->host)) {\n\t\t\trc = ecryptfs_truncate(file->f_path.dentry,\n\t\t\t\t\t       prev_page_end_size);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error on attempt to \"\n\t\t\t\t       \"truncate to (higher) offset [%lld];\"\n\t\t\t\t       \" rc = [%d]\\n\", __func__,\n\t\t\t\t       prev_page_end_size, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif ((i_size_read(mapping->host) == prev_page_end_size)\n\t    && (pos != 0))\n\t\tzero_user(page, 0, PAGE_SIZE);\nout:\n\tif (unlikely(rc)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\t*pagep = NULL;\n\t}\n\treturn rc;\n}\n\n \nstatic int ecryptfs_write_inode_size_to_header(struct inode *ecryptfs_inode)\n{\n\tchar *file_size_virt;\n\tint rc;\n\n\tfile_size_virt = kmalloc(sizeof(u64), GFP_KERNEL);\n\tif (!file_size_virt) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tput_unaligned_be64(i_size_read(ecryptfs_inode), file_size_virt);\n\trc = ecryptfs_write_lower(ecryptfs_inode, file_size_virt, 0,\n\t\t\t\t  sizeof(u64));\n\tkfree(file_size_virt);\n\tif (rc < 0)\n\t\tprintk(KERN_ERR \"%s: Error writing file size to header; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\telse\n\t\trc = 0;\nout:\n\treturn rc;\n}\n\nstruct kmem_cache *ecryptfs_xattr_cache;\n\nstatic int ecryptfs_write_inode_size_to_xattr(struct inode *ecryptfs_inode)\n{\n\tssize_t size;\n\tvoid *xattr_virt;\n\tstruct dentry *lower_dentry =\n\t\tecryptfs_inode_to_private(ecryptfs_inode)->lower_file->f_path.dentry;\n\tstruct inode *lower_inode = d_inode(lower_dentry);\n\tint rc;\n\n\tif (!(lower_inode->i_opflags & IOP_XATTR)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"No support for setting xattr in lower filesystem\\n\");\n\t\trc = -ENOSYS;\n\t\tgoto out;\n\t}\n\txattr_virt = kmem_cache_alloc(ecryptfs_xattr_cache, GFP_KERNEL);\n\tif (!xattr_virt) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tinode_lock(lower_inode);\n\tsize = __vfs_getxattr(lower_dentry, lower_inode, ECRYPTFS_XATTR_NAME,\n\t\t\t      xattr_virt, PAGE_SIZE);\n\tif (size < 0)\n\t\tsize = 8;\n\tput_unaligned_be64(i_size_read(ecryptfs_inode), xattr_virt);\n\trc = __vfs_setxattr(&nop_mnt_idmap, lower_dentry, lower_inode,\n\t\t\t    ECRYPTFS_XATTR_NAME, xattr_virt, size, 0);\n\tinode_unlock(lower_inode);\n\tif (rc)\n\t\tprintk(KERN_ERR \"Error whilst attempting to write inode size \"\n\t\t       \"to lower file xattr; rc = [%d]\\n\", rc);\n\tkmem_cache_free(ecryptfs_xattr_cache, xattr_virt);\nout:\n\treturn rc;\n}\n\nint ecryptfs_write_inode_size_to_metadata(struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\treturn ecryptfs_write_inode_size_to_xattr(ecryptfs_inode);\n\telse\n\t\treturn ecryptfs_write_inode_size_to_header(ecryptfs_inode);\n}\n\n \nstatic int ecryptfs_write_end(struct file *file,\n\t\t\tstruct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tunsigned from = pos & (PAGE_SIZE - 1);\n\tunsigned to = from + copied;\n\tstruct inode *ecryptfs_inode = mapping->host;\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tint rc;\n\n\tecryptfs_printk(KERN_DEBUG, \"Calling fill_zeros_to_end_of_page\"\n\t\t\t\"(page w/ index = [0x%.16lx], to = [%d])\\n\", index, to);\n\tif (!(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\trc = ecryptfs_write_lower_page_segment(ecryptfs_inode, page, 0,\n\t\t\t\t\t\t       to);\n\t\tif (!rc) {\n\t\t\trc = copied;\n\t\t\tfsstack_copy_inode_size(ecryptfs_inode,\n\t\t\t\tecryptfs_inode_to_lower(ecryptfs_inode));\n\t\t}\n\t\tgoto out;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tif (copied < PAGE_SIZE) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tSetPageUptodate(page);\n\t}\n\t \n\trc = fill_zeros_to_end_of_page(page, to);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error attempting to fill \"\n\t\t\t\"zeros in page with index = [0x%.16lx]\\n\", index);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_encrypt_page(page);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error encrypting page (upper \"\n\t\t\t\t\"index [0x%.16lx])\\n\", index);\n\t\tgoto out;\n\t}\n\tif (pos + copied > i_size_read(ecryptfs_inode)) {\n\t\ti_size_write(ecryptfs_inode, pos + copied);\n\t\tecryptfs_printk(KERN_DEBUG, \"Expanded file size to \"\n\t\t\t\"[0x%.16llx]\\n\",\n\t\t\t(unsigned long long)i_size_read(ecryptfs_inode));\n\t}\n\trc = ecryptfs_write_inode_size_to_metadata(ecryptfs_inode);\n\tif (rc)\n\t\tprintk(KERN_ERR \"Error writing inode size to metadata; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\telse\n\t\trc = copied;\nout:\n\tunlock_page(page);\n\tput_page(page);\n\treturn rc;\n}\n\nstatic sector_t ecryptfs_bmap(struct address_space *mapping, sector_t block)\n{\n\tstruct inode *lower_inode = ecryptfs_inode_to_lower(mapping->host);\n\tint ret = bmap(lower_inode, &block);\n\n\tif (ret)\n\t\treturn 0;\n\treturn block;\n}\n\n#include <linux/buffer_head.h>\n\nconst struct address_space_operations ecryptfs_aops = {\n\t \n#ifdef CONFIG_BLOCK\n\t.dirty_folio\t= block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n#endif\n\t.writepage = ecryptfs_writepage,\n\t.read_folio = ecryptfs_read_folio,\n\t.write_begin = ecryptfs_write_begin,\n\t.write_end = ecryptfs_write_end,\n\t.bmap = ecryptfs_bmap,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}