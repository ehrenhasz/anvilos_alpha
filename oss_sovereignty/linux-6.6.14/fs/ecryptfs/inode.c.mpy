{
  "module_name": "inode.c",
  "hash_id": "3bea9702bcd491ca35924e4fcae5d4cff2b989cb6ffe0bd7922fed6530f261e9",
  "original_prompt": "Ingested from linux-6.6.14/fs/ecryptfs/inode.c",
  "human_readable_source": "\n \n\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/dcache.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs_stack.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fileattr.h>\n#include <asm/unaligned.h>\n#include \"ecryptfs_kernel.h\"\n\nstatic int lock_parent(struct dentry *dentry,\n\t\t       struct dentry **lower_dentry,\n\t\t       struct inode **lower_dir)\n{\n\tstruct dentry *lower_dir_dentry;\n\n\tlower_dir_dentry = ecryptfs_dentry_to_lower(dentry->d_parent);\n\t*lower_dir = d_inode(lower_dir_dentry);\n\t*lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\n\tinode_lock_nested(*lower_dir, I_MUTEX_PARENT);\n\treturn (*lower_dentry)->d_parent == lower_dir_dentry ? 0 : -EINVAL;\n}\n\nstatic int ecryptfs_inode_test(struct inode *inode, void *lower_inode)\n{\n\treturn ecryptfs_inode_to_lower(inode) == lower_inode;\n}\n\nstatic int ecryptfs_inode_set(struct inode *inode, void *opaque)\n{\n\tstruct inode *lower_inode = opaque;\n\n\tecryptfs_set_inode_lower(inode, lower_inode);\n\tfsstack_copy_attr_all(inode, lower_inode);\n\t \n\tfsstack_copy_inode_size(inode, lower_inode);\n\tinode->i_ino = lower_inode->i_ino;\n\tinode->i_mapping->a_ops = &ecryptfs_aops;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\tinode->i_op = &ecryptfs_symlink_iops;\n\telse if (S_ISDIR(inode->i_mode))\n\t\tinode->i_op = &ecryptfs_dir_iops;\n\telse\n\t\tinode->i_op = &ecryptfs_main_iops;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tinode->i_fop = &ecryptfs_dir_fops;\n\telse if (special_file(inode->i_mode))\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\telse\n\t\tinode->i_fop = &ecryptfs_main_fops;\n\n\treturn 0;\n}\n\nstatic struct inode *__ecryptfs_get_inode(struct inode *lower_inode,\n\t\t\t\t\t  struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (lower_inode->i_sb != ecryptfs_superblock_to_lower(sb))\n\t\treturn ERR_PTR(-EXDEV);\n\tif (!igrab(lower_inode))\n\t\treturn ERR_PTR(-ESTALE);\n\tinode = iget5_locked(sb, (unsigned long)lower_inode,\n\t\t\t     ecryptfs_inode_test, ecryptfs_inode_set,\n\t\t\t     lower_inode);\n\tif (!inode) {\n\t\tiput(lower_inode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\tif (!(inode->i_state & I_NEW))\n\t\tiput(lower_inode);\n\n\treturn inode;\n}\n\nstruct inode *ecryptfs_get_inode(struct inode *lower_inode,\n\t\t\t\t struct super_block *sb)\n{\n\tstruct inode *inode = __ecryptfs_get_inode(lower_inode, sb);\n\n\tif (!IS_ERR(inode) && (inode->i_state & I_NEW))\n\t\tunlock_new_inode(inode);\n\n\treturn inode;\n}\n\n \nstatic int ecryptfs_interpose(struct dentry *lower_dentry,\n\t\t\t      struct dentry *dentry, struct super_block *sb)\n{\n\tstruct inode *inode = ecryptfs_get_inode(d_inode(lower_dentry), sb);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}\n\nstatic int ecryptfs_do_unlink(struct inode *dir, struct dentry *dentry,\n\t\t\t      struct inode *inode)\n{\n\tstruct dentry *lower_dentry;\n\tstruct inode *lower_dir;\n\tint rc;\n\n\trc = lock_parent(dentry, &lower_dentry, &lower_dir);\n\tdget(lower_dentry);\t\n\tif (!rc) {\n\t\tif (d_unhashed(lower_dentry))\n\t\t\trc = -EINVAL;\n\t\telse\n\t\t\trc = vfs_unlink(&nop_mnt_idmap, lower_dir, lower_dentry,\n\t\t\t\t\tNULL);\n\t}\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error in vfs_unlink; rc = [%d]\\n\", rc);\n\t\tgoto out_unlock;\n\t}\n\tfsstack_copy_attr_times(dir, lower_dir);\n\tset_nlink(inode, ecryptfs_inode_to_lower(inode)->i_nlink);\n\tinode_set_ctime_to_ts(inode, inode_get_ctime(dir));\nout_unlock:\n\tdput(lower_dentry);\n\tinode_unlock(lower_dir);\n\tif (!rc)\n\t\td_drop(dentry);\n\treturn rc;\n}\n\n \nstatic struct inode *\necryptfs_do_create(struct inode *directory_inode,\n\t\t   struct dentry *ecryptfs_dentry, umode_t mode)\n{\n\tint rc;\n\tstruct dentry *lower_dentry;\n\tstruct inode *lower_dir;\n\tstruct inode *inode;\n\n\trc = lock_parent(ecryptfs_dentry, &lower_dentry, &lower_dir);\n\tif (!rc)\n\t\trc = vfs_create(&nop_mnt_idmap, lower_dir,\n\t\t\t\tlower_dentry, mode, true);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Failure to create dentry in lower fs; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tinode = ERR_PTR(rc);\n\t\tgoto out_lock;\n\t}\n\tinode = __ecryptfs_get_inode(d_inode(lower_dentry),\n\t\t\t\t     directory_inode->i_sb);\n\tif (IS_ERR(inode)) {\n\t\tvfs_unlink(&nop_mnt_idmap, lower_dir, lower_dentry, NULL);\n\t\tgoto out_lock;\n\t}\n\tfsstack_copy_attr_times(directory_inode, lower_dir);\n\tfsstack_copy_inode_size(directory_inode, lower_dir);\nout_lock:\n\tinode_unlock(lower_dir);\n\treturn inode;\n}\n\n \nint ecryptfs_initialize_file(struct dentry *ecryptfs_dentry,\n\t\t\t     struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tint rc = 0;\n\n\tif (S_ISDIR(ecryptfs_inode->i_mode)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"This is a directory\\n\");\n\t\tcrypt_stat->flags &= ~(ECRYPTFS_ENCRYPTED);\n\t\tgoto out;\n\t}\n\tecryptfs_printk(KERN_DEBUG, \"Initializing crypto context\\n\");\n\trc = ecryptfs_new_file_context(ecryptfs_inode);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error creating new file \"\n\t\t\t\t\"context; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_get_lower_file(ecryptfs_dentry, ecryptfs_inode);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to initialize \"\n\t\t\t\"the lower file for the dentry with name \"\n\t\t\t\"[%pd]; rc = [%d]\\n\", __func__,\n\t\t\tecryptfs_dentry, rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_write_metadata(ecryptfs_dentry, ecryptfs_inode);\n\tif (rc)\n\t\tprintk(KERN_ERR \"Error writing headers; rc = [%d]\\n\", rc);\n\tecryptfs_put_lower_file(ecryptfs_inode);\nout:\n\treturn rc;\n}\n\n \nstatic int\necryptfs_create(struct mnt_idmap *idmap,\n\t\tstruct inode *directory_inode, struct dentry *ecryptfs_dentry,\n\t\tumode_t mode, bool excl)\n{\n\tstruct inode *ecryptfs_inode;\n\tint rc;\n\n\tecryptfs_inode = ecryptfs_do_create(directory_inode, ecryptfs_dentry,\n\t\t\t\t\t    mode);\n\tif (IS_ERR(ecryptfs_inode)) {\n\t\tecryptfs_printk(KERN_WARNING, \"Failed to create file in\"\n\t\t\t\t\"lower filesystem\\n\");\n\t\trc = PTR_ERR(ecryptfs_inode);\n\t\tgoto out;\n\t}\n\t \n\trc = ecryptfs_initialize_file(ecryptfs_dentry, ecryptfs_inode);\n\tif (rc) {\n\t\tecryptfs_do_unlink(directory_inode, ecryptfs_dentry,\n\t\t\t\t   ecryptfs_inode);\n\t\tiget_failed(ecryptfs_inode);\n\t\tgoto out;\n\t}\n\td_instantiate_new(ecryptfs_dentry, ecryptfs_inode);\nout:\n\treturn rc;\n}\n\nstatic int ecryptfs_i_size_read(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tint rc;\n\n\trc = ecryptfs_get_lower_file(dentry, inode);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to initialize \"\n\t\t\t\"the lower file for the dentry with name \"\n\t\t\t\"[%pd]; rc = [%d]\\n\", __func__,\n\t\t\tdentry, rc);\n\t\treturn rc;\n\t}\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\t \n\tif (!(crypt_stat->flags & ECRYPTFS_POLICY_APPLIED))\n\t\tecryptfs_set_default_sizes(crypt_stat);\n\n\trc = ecryptfs_read_and_validate_header_region(inode);\n\tecryptfs_put_lower_file(inode);\n\tif (rc) {\n\t\trc = ecryptfs_read_and_validate_xattr_region(dentry, inode);\n\t\tif (!rc)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\t}\n\n\t \n\treturn 0;\n}\n\n \nstatic struct dentry *ecryptfs_lookup_interpose(struct dentry *dentry,\n\t\t\t\t     struct dentry *lower_dentry)\n{\n\tconst struct path *path = ecryptfs_dentry_to_lower_path(dentry->d_parent);\n\tstruct inode *inode, *lower_inode;\n\tstruct ecryptfs_dentry_info *dentry_info;\n\tint rc = 0;\n\n\tdentry_info = kmem_cache_alloc(ecryptfs_dentry_info_cache, GFP_KERNEL);\n\tif (!dentry_info) {\n\t\tdput(lower_dentry);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfsstack_copy_attr_atime(d_inode(dentry->d_parent),\n\t\t\t\td_inode(path->dentry));\n\tBUG_ON(!d_count(lower_dentry));\n\n\tecryptfs_set_dentry_private(dentry, dentry_info);\n\tdentry_info->lower_path.mnt = mntget(path->mnt);\n\tdentry_info->lower_path.dentry = lower_dentry;\n\n\t \n\tlower_inode = READ_ONCE(lower_dentry->d_inode);\n\n\tif (!lower_inode) {\n\t\t \n\t\td_add(dentry, NULL);\n\t\treturn NULL;\n\t}\n\tinode = __ecryptfs_get_inode(lower_inode, dentry->d_sb);\n\tif (IS_ERR(inode)) {\n\t\tprintk(KERN_ERR \"%s: Error interposing; rc = [%ld]\\n\",\n\t\t       __func__, PTR_ERR(inode));\n\t\treturn ERR_CAST(inode);\n\t}\n\tif (S_ISREG(inode->i_mode)) {\n\t\trc = ecryptfs_i_size_read(dentry, inode);\n\t\tif (rc) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t}\n\n\tif (inode->i_state & I_NEW)\n\t\tunlock_new_inode(inode);\n\treturn d_splice_alias(inode, dentry);\n}\n\n \nstatic struct dentry *ecryptfs_lookup(struct inode *ecryptfs_dir_inode,\n\t\t\t\t      struct dentry *ecryptfs_dentry,\n\t\t\t\t      unsigned int flags)\n{\n\tchar *encrypted_and_encoded_name = NULL;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tstruct dentry *lower_dir_dentry, *lower_dentry;\n\tconst char *name = ecryptfs_dentry->d_name.name;\n\tsize_t len = ecryptfs_dentry->d_name.len;\n\tstruct dentry *res;\n\tint rc = 0;\n\n\tlower_dir_dentry = ecryptfs_dentry_to_lower(ecryptfs_dentry->d_parent);\n\n\tmount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\t\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\tif (mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) {\n\t\trc = ecryptfs_encrypt_and_encode_filename(\n\t\t\t&encrypted_and_encoded_name, &len,\n\t\t\tmount_crypt_stat, name, len);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to encrypt and encode \"\n\t\t\t       \"filename; rc = [%d]\\n\", __func__, rc);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tname = encrypted_and_encoded_name;\n\t}\n\n\tlower_dentry = lookup_one_len_unlocked(name, lower_dir_dentry, len);\n\tif (IS_ERR(lower_dentry)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"%s: lookup_one_len() returned \"\n\t\t\t\t\"[%ld] on lower_dentry = [%s]\\n\", __func__,\n\t\t\t\tPTR_ERR(lower_dentry),\n\t\t\t\tname);\n\t\tres = ERR_CAST(lower_dentry);\n\t} else {\n\t\tres = ecryptfs_lookup_interpose(ecryptfs_dentry, lower_dentry);\n\t}\n\tkfree(encrypted_and_encoded_name);\n\treturn res;\n}\n\nstatic int ecryptfs_link(struct dentry *old_dentry, struct inode *dir,\n\t\t\t struct dentry *new_dentry)\n{\n\tstruct dentry *lower_old_dentry;\n\tstruct dentry *lower_new_dentry;\n\tstruct inode *lower_dir;\n\tu64 file_size_save;\n\tint rc;\n\n\tfile_size_save = i_size_read(d_inode(old_dentry));\n\tlower_old_dentry = ecryptfs_dentry_to_lower(old_dentry);\n\trc = lock_parent(new_dentry, &lower_new_dentry, &lower_dir);\n\tif (!rc)\n\t\trc = vfs_link(lower_old_dentry, &nop_mnt_idmap, lower_dir,\n\t\t\t      lower_new_dentry, NULL);\n\tif (rc || d_really_is_negative(lower_new_dentry))\n\t\tgoto out_lock;\n\trc = ecryptfs_interpose(lower_new_dentry, new_dentry, dir->i_sb);\n\tif (rc)\n\t\tgoto out_lock;\n\tfsstack_copy_attr_times(dir, lower_dir);\n\tfsstack_copy_inode_size(dir, lower_dir);\n\tset_nlink(d_inode(old_dentry),\n\t\t  ecryptfs_inode_to_lower(d_inode(old_dentry))->i_nlink);\n\ti_size_write(d_inode(new_dentry), file_size_save);\nout_lock:\n\tinode_unlock(lower_dir);\n\treturn rc;\n}\n\nstatic int ecryptfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\treturn ecryptfs_do_unlink(dir, dentry, d_inode(dentry));\n}\n\nstatic int ecryptfs_symlink(struct mnt_idmap *idmap,\n\t\t\t    struct inode *dir, struct dentry *dentry,\n\t\t\t    const char *symname)\n{\n\tint rc;\n\tstruct dentry *lower_dentry;\n\tstruct inode *lower_dir;\n\tchar *encoded_symname;\n\tsize_t encoded_symlen;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat = NULL;\n\n\trc = lock_parent(dentry, &lower_dentry, &lower_dir);\n\tif (rc)\n\t\tgoto out_lock;\n\tmount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\tdir->i_sb)->mount_crypt_stat;\n\trc = ecryptfs_encrypt_and_encode_filename(&encoded_symname,\n\t\t\t\t\t\t  &encoded_symlen,\n\t\t\t\t\t\t  mount_crypt_stat, symname,\n\t\t\t\t\t\t  strlen(symname));\n\tif (rc)\n\t\tgoto out_lock;\n\trc = vfs_symlink(&nop_mnt_idmap, lower_dir, lower_dentry,\n\t\t\t encoded_symname);\n\tkfree(encoded_symname);\n\tif (rc || d_really_is_negative(lower_dentry))\n\t\tgoto out_lock;\n\trc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb);\n\tif (rc)\n\t\tgoto out_lock;\n\tfsstack_copy_attr_times(dir, lower_dir);\n\tfsstack_copy_inode_size(dir, lower_dir);\nout_lock:\n\tinode_unlock(lower_dir);\n\tif (d_really_is_negative(dentry))\n\t\td_drop(dentry);\n\treturn rc;\n}\n\nstatic int ecryptfs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t  struct dentry *dentry, umode_t mode)\n{\n\tint rc;\n\tstruct dentry *lower_dentry;\n\tstruct inode *lower_dir;\n\n\trc = lock_parent(dentry, &lower_dentry, &lower_dir);\n\tif (!rc)\n\t\trc = vfs_mkdir(&nop_mnt_idmap, lower_dir,\n\t\t\t       lower_dentry, mode);\n\tif (rc || d_really_is_negative(lower_dentry))\n\t\tgoto out;\n\trc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb);\n\tif (rc)\n\t\tgoto out;\n\tfsstack_copy_attr_times(dir, lower_dir);\n\tfsstack_copy_inode_size(dir, lower_dir);\n\tset_nlink(dir, lower_dir->i_nlink);\nout:\n\tinode_unlock(lower_dir);\n\tif (d_really_is_negative(dentry))\n\t\td_drop(dentry);\n\treturn rc;\n}\n\nstatic int ecryptfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct dentry *lower_dentry;\n\tstruct inode *lower_dir;\n\tint rc;\n\n\trc = lock_parent(dentry, &lower_dentry, &lower_dir);\n\tdget(lower_dentry);\t \n\tif (!rc) {\n\t\tif (d_unhashed(lower_dentry))\n\t\t\trc = -EINVAL;\n\t\telse\n\t\t\trc = vfs_rmdir(&nop_mnt_idmap, lower_dir, lower_dentry);\n\t}\n\tif (!rc) {\n\t\tclear_nlink(d_inode(dentry));\n\t\tfsstack_copy_attr_times(dir, lower_dir);\n\t\tset_nlink(dir, lower_dir->i_nlink);\n\t}\n\tdput(lower_dentry);\n\tinode_unlock(lower_dir);\n\tif (!rc)\n\t\td_drop(dentry);\n\treturn rc;\n}\n\nstatic int\necryptfs_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t       struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tint rc;\n\tstruct dentry *lower_dentry;\n\tstruct inode *lower_dir;\n\n\trc = lock_parent(dentry, &lower_dentry, &lower_dir);\n\tif (!rc)\n\t\trc = vfs_mknod(&nop_mnt_idmap, lower_dir,\n\t\t\t       lower_dentry, mode, dev);\n\tif (rc || d_really_is_negative(lower_dentry))\n\t\tgoto out;\n\trc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb);\n\tif (rc)\n\t\tgoto out;\n\tfsstack_copy_attr_times(dir, lower_dir);\n\tfsstack_copy_inode_size(dir, lower_dir);\nout:\n\tinode_unlock(lower_dir);\n\tif (d_really_is_negative(dentry))\n\t\td_drop(dentry);\n\treturn rc;\n}\n\nstatic int\necryptfs_rename(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\tstruct dentry *old_dentry, struct inode *new_dir,\n\t\tstruct dentry *new_dentry, unsigned int flags)\n{\n\tint rc;\n\tstruct dentry *lower_old_dentry;\n\tstruct dentry *lower_new_dentry;\n\tstruct dentry *lower_old_dir_dentry;\n\tstruct dentry *lower_new_dir_dentry;\n\tstruct dentry *trap;\n\tstruct inode *target_inode;\n\tstruct renamedata rd = {};\n\n\tif (flags)\n\t\treturn -EINVAL;\n\n\tlower_old_dir_dentry = ecryptfs_dentry_to_lower(old_dentry->d_parent);\n\tlower_new_dir_dentry = ecryptfs_dentry_to_lower(new_dentry->d_parent);\n\n\tlower_old_dentry = ecryptfs_dentry_to_lower(old_dentry);\n\tlower_new_dentry = ecryptfs_dentry_to_lower(new_dentry);\n\n\ttarget_inode = d_inode(new_dentry);\n\n\ttrap = lock_rename(lower_old_dir_dentry, lower_new_dir_dentry);\n\tdget(lower_new_dentry);\n\trc = -EINVAL;\n\tif (lower_old_dentry->d_parent != lower_old_dir_dentry)\n\t\tgoto out_lock;\n\tif (lower_new_dentry->d_parent != lower_new_dir_dentry)\n\t\tgoto out_lock;\n\tif (d_unhashed(lower_old_dentry) || d_unhashed(lower_new_dentry))\n\t\tgoto out_lock;\n\t \n\tif (trap == lower_old_dentry)\n\t\tgoto out_lock;\n\t \n\tif (trap == lower_new_dentry) {\n\t\trc = -ENOTEMPTY;\n\t\tgoto out_lock;\n\t}\n\n\trd.old_mnt_idmap\t= &nop_mnt_idmap;\n\trd.old_dir\t\t= d_inode(lower_old_dir_dentry);\n\trd.old_dentry\t\t= lower_old_dentry;\n\trd.new_mnt_idmap\t= &nop_mnt_idmap;\n\trd.new_dir\t\t= d_inode(lower_new_dir_dentry);\n\trd.new_dentry\t\t= lower_new_dentry;\n\trc = vfs_rename(&rd);\n\tif (rc)\n\t\tgoto out_lock;\n\tif (target_inode)\n\t\tfsstack_copy_attr_all(target_inode,\n\t\t\t\t      ecryptfs_inode_to_lower(target_inode));\n\tfsstack_copy_attr_all(new_dir, d_inode(lower_new_dir_dentry));\n\tif (new_dir != old_dir)\n\t\tfsstack_copy_attr_all(old_dir, d_inode(lower_old_dir_dentry));\nout_lock:\n\tdput(lower_new_dentry);\n\tunlock_rename(lower_old_dir_dentry, lower_new_dir_dentry);\n\treturn rc;\n}\n\nstatic char *ecryptfs_readlink_lower(struct dentry *dentry, size_t *bufsiz)\n{\n\tDEFINE_DELAYED_CALL(done);\n\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tconst char *link;\n\tchar *buf;\n\tint rc;\n\n\tlink = vfs_get_link(lower_dentry, &done);\n\tif (IS_ERR(link))\n\t\treturn ERR_CAST(link);\n\n\trc = ecryptfs_decode_and_decrypt_filename(&buf, bufsiz, dentry->d_sb,\n\t\t\t\t\t\t  link, strlen(link));\n\tdo_delayed_call(&done);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\n\treturn buf;\n}\n\nstatic const char *ecryptfs_get_link(struct dentry *dentry,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct delayed_call *done)\n{\n\tsize_t len;\n\tchar *buf;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tbuf = ecryptfs_readlink_lower(dentry, &len);\n\tif (IS_ERR(buf))\n\t\treturn buf;\n\tfsstack_copy_attr_atime(d_inode(dentry),\n\t\t\t\td_inode(ecryptfs_dentry_to_lower(dentry)));\n\tbuf[len] = '\\0';\n\tset_delayed_call(done, kfree_link, buf);\n\treturn buf;\n}\n\n \nstatic loff_t\nupper_size_to_lower_size(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t loff_t upper_size)\n{\n\tloff_t lower_size;\n\n\tlower_size = ecryptfs_lower_header_size(crypt_stat);\n\tif (upper_size != 0) {\n\t\tloff_t num_extents;\n\n\t\tnum_extents = upper_size >> crypt_stat->extent_shift;\n\t\tif (upper_size & ~crypt_stat->extent_mask)\n\t\t\tnum_extents++;\n\t\tlower_size += (num_extents * crypt_stat->extent_size);\n\t}\n\treturn lower_size;\n}\n\n \nstatic int truncate_upper(struct dentry *dentry, struct iattr *ia,\n\t\t\t  struct iattr *lower_ia)\n{\n\tint rc = 0;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t i_size = i_size_read(inode);\n\tloff_t lower_size_before_truncate;\n\tloff_t lower_size_after_truncate;\n\n\tif (unlikely((ia->ia_size == i_size))) {\n\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t\treturn 0;\n\t}\n\trc = ecryptfs_get_lower_file(dentry, inode);\n\tif (rc)\n\t\treturn rc;\n\tcrypt_stat = &ecryptfs_inode_to_private(d_inode(dentry))->crypt_stat;\n\t \n\tif (ia->ia_size > i_size) {\n\t\tchar zero[] = { 0x00 };\n\n\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t\t \n\t\trc = ecryptfs_write(inode, zero,\n\t\t\t\t    (ia->ia_size - 1), 1);\n\t} else {  \n\t\t \n\t\tsize_t num_zeros = (PAGE_SIZE\n\t\t\t\t    - (ia->ia_size & ~PAGE_MASK));\n\n\t\tif (!(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\t\ttruncate_setsize(inode, ia->ia_size);\n\t\t\tlower_ia->ia_size = ia->ia_size;\n\t\t\tlower_ia->ia_valid |= ATTR_SIZE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (num_zeros) {\n\t\t\tchar *zeros_virt;\n\n\t\t\tzeros_virt = kzalloc(num_zeros, GFP_KERNEL);\n\t\t\tif (!zeros_virt) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trc = ecryptfs_write(inode, zeros_virt,\n\t\t\t\t\t    ia->ia_size, num_zeros);\n\t\t\tkfree(zeros_virt);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to zero out \"\n\t\t\t\t       \"the remainder of the end page on \"\n\t\t\t\t       \"reducing truncate; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\ttruncate_setsize(inode, ia->ia_size);\n\t\trc = ecryptfs_write_inode_size_to_metadata(inode);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR\t\"Problem with \"\n\t\t\t       \"ecryptfs_write_inode_size_to_metadata; \"\n\t\t\t       \"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tlower_size_before_truncate =\n\t\t    upper_size_to_lower_size(crypt_stat, i_size);\n\t\tlower_size_after_truncate =\n\t\t    upper_size_to_lower_size(crypt_stat, ia->ia_size);\n\t\tif (lower_size_after_truncate < lower_size_before_truncate) {\n\t\t\tlower_ia->ia_size = lower_size_after_truncate;\n\t\t\tlower_ia->ia_valid |= ATTR_SIZE;\n\t\t} else\n\t\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t}\nout:\n\tecryptfs_put_lower_file(inode);\n\treturn rc;\n}\n\nstatic int ecryptfs_inode_newsize_ok(struct inode *inode, loff_t offset)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t lower_oldsize, lower_newsize;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tlower_oldsize = upper_size_to_lower_size(crypt_stat,\n\t\t\t\t\t\t i_size_read(inode));\n\tlower_newsize = upper_size_to_lower_size(crypt_stat, offset);\n\tif (lower_newsize > lower_oldsize) {\n\t\t \n\t\treturn inode_newsize_ok(inode, lower_newsize);\n\t}\n\n\treturn 0;\n}\n\n \nint ecryptfs_truncate(struct dentry *dentry, loff_t new_length)\n{\n\tstruct iattr ia = { .ia_valid = ATTR_SIZE, .ia_size = new_length };\n\tstruct iattr lower_ia = { .ia_valid = 0 };\n\tint rc;\n\n\trc = ecryptfs_inode_newsize_ok(d_inode(dentry), new_length);\n\tif (rc)\n\t\treturn rc;\n\n\trc = truncate_upper(dentry, &ia, &lower_ia);\n\tif (!rc && lower_ia.ia_valid & ATTR_SIZE) {\n\t\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\n\t\tinode_lock(d_inode(lower_dentry));\n\t\trc = notify_change(&nop_mnt_idmap, lower_dentry,\n\t\t\t\t   &lower_ia, NULL);\n\t\tinode_unlock(d_inode(lower_dentry));\n\t}\n\treturn rc;\n}\n\nstatic int\necryptfs_permission(struct mnt_idmap *idmap, struct inode *inode,\n\t\t    int mask)\n{\n\treturn inode_permission(&nop_mnt_idmap,\n\t\t\t\tecryptfs_inode_to_lower(inode), mask);\n}\n\n \nstatic int ecryptfs_setattr(struct mnt_idmap *idmap,\n\t\t\t    struct dentry *dentry, struct iattr *ia)\n{\n\tint rc = 0;\n\tstruct dentry *lower_dentry;\n\tstruct iattr lower_ia;\n\tstruct inode *inode;\n\tstruct inode *lower_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(d_inode(dentry))->crypt_stat;\n\tif (!(crypt_stat->flags & ECRYPTFS_STRUCT_INITIALIZED)) {\n\t\trc = ecryptfs_init_crypt_stat(crypt_stat);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tinode = d_inode(dentry);\n\tlower_inode = ecryptfs_inode_to_lower(inode);\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tmutex_lock(&crypt_stat->cs_mutex);\n\tif (d_is_dir(dentry))\n\t\tcrypt_stat->flags &= ~(ECRYPTFS_ENCRYPTED);\n\telse if (d_is_reg(dentry)\n\t\t && (!(crypt_stat->flags & ECRYPTFS_POLICY_APPLIED)\n\t\t     || !(crypt_stat->flags & ECRYPTFS_KEY_VALID))) {\n\t\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\n\t\tmount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\t\tdentry->d_sb)->mount_crypt_stat;\n\t\trc = ecryptfs_get_lower_file(dentry, inode);\n\t\tif (rc) {\n\t\t\tmutex_unlock(&crypt_stat->cs_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\trc = ecryptfs_read_metadata(dentry);\n\t\tecryptfs_put_lower_file(inode);\n\t\tif (rc) {\n\t\t\tif (!(mount_crypt_stat->flags\n\t\t\t      & ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED)) {\n\t\t\t\trc = -EIO;\n\t\t\t\tprintk(KERN_WARNING \"Either the lower file \"\n\t\t\t\t       \"is not in a valid eCryptfs format, \"\n\t\t\t\t       \"or the key could not be retrieved. \"\n\t\t\t\t       \"Plaintext passthrough mode is not \"\n\t\t\t\t       \"enabled; returning -EIO\\n\");\n\t\t\t\tmutex_unlock(&crypt_stat->cs_mutex);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trc = 0;\n\t\t\tcrypt_stat->flags &= ~(ECRYPTFS_I_SIZE_INITIALIZED\n\t\t\t\t\t       | ECRYPTFS_ENCRYPTED);\n\t\t}\n\t}\n\tmutex_unlock(&crypt_stat->cs_mutex);\n\n\trc = setattr_prepare(&nop_mnt_idmap, dentry, ia);\n\tif (rc)\n\t\tgoto out;\n\tif (ia->ia_valid & ATTR_SIZE) {\n\t\trc = ecryptfs_inode_newsize_ok(inode, ia->ia_size);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tmemcpy(&lower_ia, ia, sizeof(lower_ia));\n\tif (ia->ia_valid & ATTR_FILE)\n\t\tlower_ia.ia_file = ecryptfs_file_to_lower(ia->ia_file);\n\tif (ia->ia_valid & ATTR_SIZE) {\n\t\trc = truncate_upper(dentry, ia, &lower_ia);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (lower_ia.ia_valid & (ATTR_KILL_SUID | ATTR_KILL_SGID))\n\t\tlower_ia.ia_valid &= ~ATTR_MODE;\n\n\tinode_lock(d_inode(lower_dentry));\n\trc = notify_change(&nop_mnt_idmap, lower_dentry, &lower_ia, NULL);\n\tinode_unlock(d_inode(lower_dentry));\nout:\n\tfsstack_copy_attr_all(inode, lower_inode);\n\treturn rc;\n}\n\nstatic int ecryptfs_getattr_link(struct mnt_idmap *idmap,\n\t\t\t\t const struct path *path, struct kstat *stat,\n\t\t\t\t u32 request_mask, unsigned int flags)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tint rc = 0;\n\n\tmount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\t\t\t\t\tdentry->d_sb)->mount_crypt_stat;\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, d_inode(dentry), stat);\n\tif (mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) {\n\t\tchar *target;\n\t\tsize_t targetsiz;\n\n\t\ttarget = ecryptfs_readlink_lower(dentry, &targetsiz);\n\t\tif (!IS_ERR(target)) {\n\t\t\tkfree(target);\n\t\t\tstat->size = targetsiz;\n\t\t} else {\n\t\t\trc = PTR_ERR(target);\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int ecryptfs_do_getattr(const struct path *path, struct kstat *stat,\n\t\t\t       u32 request_mask, unsigned int flags)\n{\n\tif (flags & AT_GETATTR_NOSEC)\n\t\treturn vfs_getattr_nosec(path, stat, request_mask, flags);\n\treturn vfs_getattr(path, stat, request_mask, flags);\n}\n\nstatic int ecryptfs_getattr(struct mnt_idmap *idmap,\n\t\t\t    const struct path *path, struct kstat *stat,\n\t\t\t    u32 request_mask, unsigned int flags)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct kstat lower_stat;\n\tint rc;\n\n\trc = ecryptfs_do_getattr(ecryptfs_dentry_to_lower_path(dentry),\n\t\t\t\t &lower_stat, request_mask, flags);\n\tif (!rc) {\n\t\tfsstack_copy_attr_all(d_inode(dentry),\n\t\t\t\t      ecryptfs_inode_to_lower(d_inode(dentry)));\n\t\tgeneric_fillattr(&nop_mnt_idmap, request_mask,\n\t\t\t\t d_inode(dentry), stat);\n\t\tstat->blocks = lower_stat.blocks;\n\t}\n\treturn rc;\n}\n\nint\necryptfs_setxattr(struct dentry *dentry, struct inode *inode,\n\t\t  const char *name, const void *value,\n\t\t  size_t size, int flags)\n{\n\tint rc;\n\tstruct dentry *lower_dentry;\n\tstruct inode *lower_inode;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tlower_inode = d_inode(lower_dentry);\n\tif (!(lower_inode->i_opflags & IOP_XATTR)) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tinode_lock(lower_inode);\n\trc = __vfs_setxattr_locked(&nop_mnt_idmap, lower_dentry, name, value, size, flags, NULL);\n\tinode_unlock(lower_inode);\n\tif (!rc && inode)\n\t\tfsstack_copy_attr_all(inode, lower_inode);\nout:\n\treturn rc;\n}\n\nssize_t\necryptfs_getxattr_lower(struct dentry *lower_dentry, struct inode *lower_inode,\n\t\t\tconst char *name, void *value, size_t size)\n{\n\tint rc;\n\n\tif (!(lower_inode->i_opflags & IOP_XATTR)) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tinode_lock(lower_inode);\n\trc = __vfs_getxattr(lower_dentry, lower_inode, name, value, size);\n\tinode_unlock(lower_inode);\nout:\n\treturn rc;\n}\n\nstatic ssize_t\necryptfs_getxattr(struct dentry *dentry, struct inode *inode,\n\t\t  const char *name, void *value, size_t size)\n{\n\treturn ecryptfs_getxattr_lower(ecryptfs_dentry_to_lower(dentry),\n\t\t\t\t       ecryptfs_inode_to_lower(inode),\n\t\t\t\t       name, value, size);\n}\n\nstatic ssize_t\necryptfs_listxattr(struct dentry *dentry, char *list, size_t size)\n{\n\tint rc = 0;\n\tstruct dentry *lower_dentry;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tif (!d_inode(lower_dentry)->i_op->listxattr) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tinode_lock(d_inode(lower_dentry));\n\trc = d_inode(lower_dentry)->i_op->listxattr(lower_dentry, list, size);\n\tinode_unlock(d_inode(lower_dentry));\nout:\n\treturn rc;\n}\n\nstatic int ecryptfs_removexattr(struct dentry *dentry, struct inode *inode,\n\t\t\t\tconst char *name)\n{\n\tint rc;\n\tstruct dentry *lower_dentry;\n\tstruct inode *lower_inode;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tlower_inode = ecryptfs_inode_to_lower(inode);\n\tif (!(lower_inode->i_opflags & IOP_XATTR)) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tinode_lock(lower_inode);\n\trc = __vfs_removexattr(&nop_mnt_idmap, lower_dentry, name);\n\tinode_unlock(lower_inode);\nout:\n\treturn rc;\n}\n\nstatic int ecryptfs_fileattr_get(struct dentry *dentry, struct fileattr *fa)\n{\n\treturn vfs_fileattr_get(ecryptfs_dentry_to_lower(dentry), fa);\n}\n\nstatic int ecryptfs_fileattr_set(struct mnt_idmap *idmap,\n\t\t\t\t struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tint rc;\n\n\trc = vfs_fileattr_set(&nop_mnt_idmap, lower_dentry, fa);\n\tfsstack_copy_attr_all(d_inode(dentry), d_inode(lower_dentry));\n\n\treturn rc;\n}\n\nstatic struct posix_acl *ecryptfs_get_acl(struct mnt_idmap *idmap,\n\t\t\t\t\t  struct dentry *dentry, int type)\n{\n\treturn vfs_get_acl(idmap, ecryptfs_dentry_to_lower(dentry),\n\t\t\t   posix_acl_xattr_name(type));\n}\n\nstatic int ecryptfs_set_acl(struct mnt_idmap *idmap,\n\t\t\t    struct dentry *dentry, struct posix_acl *acl,\n\t\t\t    int type)\n{\n\tint rc;\n\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tstruct inode *lower_inode = d_inode(lower_dentry);\n\n\trc = vfs_set_acl(&nop_mnt_idmap, lower_dentry,\n\t\t\t posix_acl_xattr_name(type), acl);\n\tif (!rc)\n\t\tfsstack_copy_attr_all(d_inode(dentry), lower_inode);\n\treturn rc;\n}\n\nconst struct inode_operations ecryptfs_symlink_iops = {\n\t.get_link = ecryptfs_get_link,\n\t.permission = ecryptfs_permission,\n\t.setattr = ecryptfs_setattr,\n\t.getattr = ecryptfs_getattr_link,\n\t.listxattr = ecryptfs_listxattr,\n};\n\nconst struct inode_operations ecryptfs_dir_iops = {\n\t.create = ecryptfs_create,\n\t.lookup = ecryptfs_lookup,\n\t.link = ecryptfs_link,\n\t.unlink = ecryptfs_unlink,\n\t.symlink = ecryptfs_symlink,\n\t.mkdir = ecryptfs_mkdir,\n\t.rmdir = ecryptfs_rmdir,\n\t.mknod = ecryptfs_mknod,\n\t.rename = ecryptfs_rename,\n\t.permission = ecryptfs_permission,\n\t.setattr = ecryptfs_setattr,\n\t.listxattr = ecryptfs_listxattr,\n\t.fileattr_get = ecryptfs_fileattr_get,\n\t.fileattr_set = ecryptfs_fileattr_set,\n\t.get_acl = ecryptfs_get_acl,\n\t.set_acl = ecryptfs_set_acl,\n};\n\nconst struct inode_operations ecryptfs_main_iops = {\n\t.permission = ecryptfs_permission,\n\t.setattr = ecryptfs_setattr,\n\t.getattr = ecryptfs_getattr,\n\t.listxattr = ecryptfs_listxattr,\n\t.fileattr_get = ecryptfs_fileattr_get,\n\t.fileattr_set = ecryptfs_fileattr_set,\n\t.get_acl = ecryptfs_get_acl,\n\t.set_acl = ecryptfs_set_acl,\n};\n\nstatic int ecryptfs_xattr_get(const struct xattr_handler *handler,\n\t\t\t      struct dentry *dentry, struct inode *inode,\n\t\t\t      const char *name, void *buffer, size_t size)\n{\n\treturn ecryptfs_getxattr(dentry, inode, name, buffer, size);\n}\n\nstatic int ecryptfs_xattr_set(const struct xattr_handler *handler,\n\t\t\t      struct mnt_idmap *idmap,\n\t\t\t      struct dentry *dentry, struct inode *inode,\n\t\t\t      const char *name, const void *value, size_t size,\n\t\t\t      int flags)\n{\n\tif (value)\n\t\treturn ecryptfs_setxattr(dentry, inode, name, value, size, flags);\n\telse {\n\t\tBUG_ON(flags != XATTR_REPLACE);\n\t\treturn ecryptfs_removexattr(dentry, inode, name);\n\t}\n}\n\nstatic const struct xattr_handler ecryptfs_xattr_handler = {\n\t.prefix = \"\",   \n\t.get = ecryptfs_xattr_get,\n\t.set = ecryptfs_xattr_set,\n};\n\nconst struct xattr_handler *ecryptfs_xattr_handlers[] = {\n\t&ecryptfs_xattr_handler,\n\tNULL\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}