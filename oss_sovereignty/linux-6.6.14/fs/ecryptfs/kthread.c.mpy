{
  "module_name": "kthread.c",
  "hash_id": "b0a9e9b801e89ad3e8c42f7d602fd489db1efabe844886cff2c3936e94e78c80",
  "original_prompt": "Ingested from linux-6.6.14/fs/ecryptfs/kthread.c",
  "human_readable_source": "\n \n\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include \"ecryptfs_kernel.h\"\n\nstruct ecryptfs_open_req {\n\tstruct file **lower_file;\n\tstruct path path;\n\tstruct completion done;\n\tstruct list_head kthread_ctl_list;\n};\n\nstatic struct ecryptfs_kthread_ctl {\n#define ECRYPTFS_KTHREAD_ZOMBIE 0x00000001\n\tu32 flags;\n\tstruct mutex mux;\n\tstruct list_head req_list;\n\twait_queue_head_t wait;\n} ecryptfs_kthread_ctl;\n\nstatic struct task_struct *ecryptfs_kthread;\n\n \nstatic int ecryptfs_threadfn(void *ignored)\n{\n\tset_freezable();\n\twhile (1)  {\n\t\tstruct ecryptfs_open_req *req;\n\n\t\twait_event_freezable(\n\t\t\tecryptfs_kthread_ctl.wait,\n\t\t\t(!list_empty(&ecryptfs_kthread_ctl.req_list)\n\t\t\t || kthread_should_stop()));\n\t\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\t\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\t\tgoto out;\n\t\t}\n\t\twhile (!list_empty(&ecryptfs_kthread_ctl.req_list)) {\n\t\t\treq = list_first_entry(&ecryptfs_kthread_ctl.req_list,\n\t\t\t\t\t       struct ecryptfs_open_req,\n\t\t\t\t\t       kthread_ctl_list);\n\t\t\tlist_del(&req->kthread_ctl_list);\n\t\t\t*req->lower_file = dentry_open(&req->path,\n\t\t\t\t(O_RDWR | O_LARGEFILE), current_cred());\n\t\t\tcomplete(&req->done);\n\t\t}\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t}\nout:\n\treturn 0;\n}\n\nint __init ecryptfs_init_kthread(void)\n{\n\tint rc = 0;\n\n\tmutex_init(&ecryptfs_kthread_ctl.mux);\n\tinit_waitqueue_head(&ecryptfs_kthread_ctl.wait);\n\tINIT_LIST_HEAD(&ecryptfs_kthread_ctl.req_list);\n\tecryptfs_kthread = kthread_run(&ecryptfs_threadfn, NULL,\n\t\t\t\t       \"ecryptfs-kthread\");\n\tif (IS_ERR(ecryptfs_kthread)) {\n\t\trc = PTR_ERR(ecryptfs_kthread);\n\t\tprintk(KERN_ERR \"%s: Failed to create kernel thread; rc = [%d]\"\n\t\t       \"\\n\", __func__, rc);\n\t}\n\treturn rc;\n}\n\nvoid ecryptfs_destroy_kthread(void)\n{\n\tstruct ecryptfs_open_req *req, *tmp;\n\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tecryptfs_kthread_ctl.flags |= ECRYPTFS_KTHREAD_ZOMBIE;\n\tlist_for_each_entry_safe(req, tmp, &ecryptfs_kthread_ctl.req_list,\n\t\t\t\t kthread_ctl_list) {\n\t\tlist_del(&req->kthread_ctl_list);\n\t\t*req->lower_file = ERR_PTR(-EIO);\n\t\tcomplete(&req->done);\n\t}\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\tkthread_stop(ecryptfs_kthread);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n}\n\n \nint ecryptfs_privileged_open(struct file **lower_file,\n\t\t\t     struct dentry *lower_dentry,\n\t\t\t     struct vfsmount *lower_mnt,\n\t\t\t     const struct cred *cred)\n{\n\tstruct ecryptfs_open_req req;\n\tint flags = O_LARGEFILE;\n\tint rc = 0;\n\n\tinit_completion(&req.done);\n\treq.lower_file = lower_file;\n\treq.path.dentry = lower_dentry;\n\treq.path.mnt = lower_mnt;\n\n\t \n\tflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n\t(*lower_file) = dentry_open(&req.path, flags, cred);\n\tif (!IS_ERR(*lower_file))\n\t\tgoto out;\n\tif ((flags & O_ACCMODE) == O_RDONLY) {\n\t\trc = PTR_ERR((*lower_file));\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\tprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\t\t       \"aborting privileged request to open lower file\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n\twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file))\n\t\trc = PTR_ERR(*lower_file);\nout:\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}