{
  "module_name": "miscdev.c",
  "hash_id": "ae610b825dd89923d6ae1eabf4566b8c437d2a910702ad5dc262c49b80e43488",
  "original_prompt": "Ingested from linux-6.6.14/fs/ecryptfs/miscdev.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/random.h>\n#include <linux/miscdevice.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/module.h>\n#include \"ecryptfs_kernel.h\"\n\nstatic atomic_t ecryptfs_num_miscdev_opens;\n\n \nstatic __poll_t\necryptfs_miscdev_poll(struct file *file, poll_table *pt)\n{\n\tstruct ecryptfs_daemon *daemon = file->private_data;\n\t__poll_t mask = 0;\n\n\tmutex_lock(&daemon->mux);\n\tif (daemon->flags & ECRYPTFS_DAEMON_ZOMBIE) {\n\t\tprintk(KERN_WARNING \"%s: Attempt to poll on zombified \"\n\t\t       \"daemon\\n\", __func__);\n\t\tgoto out_unlock_daemon;\n\t}\n\tif (daemon->flags & ECRYPTFS_DAEMON_IN_READ)\n\t\tgoto out_unlock_daemon;\n\tif (daemon->flags & ECRYPTFS_DAEMON_IN_POLL)\n\t\tgoto out_unlock_daemon;\n\tdaemon->flags |= ECRYPTFS_DAEMON_IN_POLL;\n\tmutex_unlock(&daemon->mux);\n\tpoll_wait(file, &daemon->wait, pt);\n\tmutex_lock(&daemon->mux);\n\tif (!list_empty(&daemon->msg_ctx_out_queue))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\nout_unlock_daemon:\n\tdaemon->flags &= ~ECRYPTFS_DAEMON_IN_POLL;\n\tmutex_unlock(&daemon->mux);\n\treturn mask;\n}\n\n \nstatic int\necryptfs_miscdev_open(struct inode *inode, struct file *file)\n{\n\tstruct ecryptfs_daemon *daemon = NULL;\n\tint rc;\n\n\tmutex_lock(&ecryptfs_daemon_hash_mux);\n\trc = ecryptfs_find_daemon_by_euid(&daemon);\n\tif (!rc) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock_daemon_list;\n\t}\n\trc = ecryptfs_spawn_daemon(&daemon, file);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to spawn daemon; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_unlock_daemon_list;\n\t}\n\tmutex_lock(&daemon->mux);\n\tif (daemon->flags & ECRYPTFS_DAEMON_MISCDEV_OPEN) {\n\t\trc = -EBUSY;\n\t\tgoto out_unlock_daemon;\n\t}\n\tdaemon->flags |= ECRYPTFS_DAEMON_MISCDEV_OPEN;\n\tfile->private_data = daemon;\n\tatomic_inc(&ecryptfs_num_miscdev_opens);\nout_unlock_daemon:\n\tmutex_unlock(&daemon->mux);\nout_unlock_daemon_list:\n\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\treturn rc;\n}\n\n \nstatic int\necryptfs_miscdev_release(struct inode *inode, struct file *file)\n{\n\tstruct ecryptfs_daemon *daemon = file->private_data;\n\tint rc;\n\n\tmutex_lock(&daemon->mux);\n\tBUG_ON(!(daemon->flags & ECRYPTFS_DAEMON_MISCDEV_OPEN));\n\tdaemon->flags &= ~ECRYPTFS_DAEMON_MISCDEV_OPEN;\n\tatomic_dec(&ecryptfs_num_miscdev_opens);\n\tmutex_unlock(&daemon->mux);\n\n\tmutex_lock(&ecryptfs_daemon_hash_mux);\n\trc = ecryptfs_exorcise_daemon(daemon);\n\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\tif (rc) {\n\t\tprintk(KERN_CRIT \"%s: Fatal error whilst attempting to \"\n\t\t       \"shut down daemon; rc = [%d]. Please report this \"\n\t\t       \"bug.\\n\", __func__, rc);\n\t\tBUG();\n\t}\n\treturn rc;\n}\n\n \nint ecryptfs_send_miscdev(char *data, size_t data_size,\n\t\t\t  struct ecryptfs_msg_ctx *msg_ctx, u8 msg_type,\n\t\t\t  u16 msg_flags, struct ecryptfs_daemon *daemon)\n{\n\tstruct ecryptfs_message *msg;\n\n\tmsg = kmalloc((sizeof(*msg) + data_size), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&msg_ctx->mux);\n\tmsg_ctx->msg = msg;\n\tmsg_ctx->msg->index = msg_ctx->index;\n\tmsg_ctx->msg->data_len = data_size;\n\tmsg_ctx->type = msg_type;\n\tmemcpy(msg_ctx->msg->data, data, data_size);\n\tmsg_ctx->msg_size = (sizeof(*msg_ctx->msg) + data_size);\n\tlist_add_tail(&msg_ctx->daemon_out_list, &daemon->msg_ctx_out_queue);\n\tmutex_unlock(&msg_ctx->mux);\n\n\tmutex_lock(&daemon->mux);\n\tdaemon->num_queued_msg_ctx++;\n\twake_up_interruptible(&daemon->wait);\n\tmutex_unlock(&daemon->mux);\n\n\treturn 0;\n}\n\n \n#define PKT_TYPE_SIZE\t\t1\n#define PKT_CTR_SIZE\t\t4\n#define MIN_NON_MSG_PKT_SIZE\t(PKT_TYPE_SIZE + PKT_CTR_SIZE)\n#define MIN_MSG_PKT_SIZE\t(PKT_TYPE_SIZE + PKT_CTR_SIZE \\\n\t\t\t\t + ECRYPTFS_MIN_PKT_LEN_SIZE)\n \n#define MAX_MSG_PKT_SIZE\t(PKT_TYPE_SIZE + PKT_CTR_SIZE \\\n\t\t\t\t + ECRYPTFS_MAX_PKT_LEN_SIZE \\\n\t\t\t\t + sizeof(struct ecryptfs_message) \\\n\t\t\t\t + 4 + ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES)\n#define PKT_TYPE_OFFSET\t\t0\n#define PKT_CTR_OFFSET\t\tPKT_TYPE_SIZE\n#define PKT_LEN_OFFSET\t\t(PKT_TYPE_SIZE + PKT_CTR_SIZE)\n\n \nstatic ssize_t\necryptfs_miscdev_read(struct file *file, char __user *buf, size_t count,\n\t\t      loff_t *ppos)\n{\n\tstruct ecryptfs_daemon *daemon = file->private_data;\n\tstruct ecryptfs_msg_ctx *msg_ctx;\n\tsize_t packet_length_size;\n\tchar packet_length[ECRYPTFS_MAX_PKT_LEN_SIZE];\n\tsize_t i;\n\tsize_t total_length;\n\tint rc;\n\n\tmutex_lock(&daemon->mux);\n\tif (daemon->flags & ECRYPTFS_DAEMON_ZOMBIE) {\n\t\trc = 0;\n\t\tprintk(KERN_WARNING \"%s: Attempt to read from zombified \"\n\t\t       \"daemon\\n\", __func__);\n\t\tgoto out_unlock_daemon;\n\t}\n\tif (daemon->flags & ECRYPTFS_DAEMON_IN_READ) {\n\t\trc = 0;\n\t\tgoto out_unlock_daemon;\n\t}\n\t \n\tdaemon->flags |= ECRYPTFS_DAEMON_IN_READ;\ncheck_list:\n\tif (list_empty(&daemon->msg_ctx_out_queue)) {\n\t\tmutex_unlock(&daemon->mux);\n\t\trc = wait_event_interruptible(\n\t\t\tdaemon->wait, !list_empty(&daemon->msg_ctx_out_queue));\n\t\tmutex_lock(&daemon->mux);\n\t\tif (rc < 0) {\n\t\t\trc = 0;\n\t\t\tgoto out_unlock_daemon;\n\t\t}\n\t}\n\tif (daemon->flags & ECRYPTFS_DAEMON_ZOMBIE) {\n\t\trc = 0;\n\t\tgoto out_unlock_daemon;\n\t}\n\tif (list_empty(&daemon->msg_ctx_out_queue)) {\n\t\t \n\t\tgoto check_list;\n\t}\n\tmsg_ctx = list_first_entry(&daemon->msg_ctx_out_queue,\n\t\t\t\t   struct ecryptfs_msg_ctx, daemon_out_list);\n\tBUG_ON(!msg_ctx);\n\tmutex_lock(&msg_ctx->mux);\n\tif (msg_ctx->msg) {\n\t\trc = ecryptfs_write_packet_length(packet_length,\n\t\t\t\t\t\t  msg_ctx->msg_size,\n\t\t\t\t\t\t  &packet_length_size);\n\t\tif (rc) {\n\t\t\trc = 0;\n\t\t\tprintk(KERN_WARNING \"%s: Error writing packet length; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out_unlock_msg_ctx;\n\t\t}\n\t} else {\n\t\tpacket_length_size = 0;\n\t\tmsg_ctx->msg_size = 0;\n\t}\n\ttotal_length = (PKT_TYPE_SIZE + PKT_CTR_SIZE + packet_length_size\n\t\t\t+ msg_ctx->msg_size);\n\tif (count < total_length) {\n\t\trc = 0;\n\t\tprintk(KERN_WARNING \"%s: Only given user buffer of \"\n\t\t       \"size [%zd], but we need [%zd] to read the \"\n\t\t       \"pending message\\n\", __func__, count, total_length);\n\t\tgoto out_unlock_msg_ctx;\n\t}\n\trc = -EFAULT;\n\tif (put_user(msg_ctx->type, buf))\n\t\tgoto out_unlock_msg_ctx;\n\tif (put_user(cpu_to_be32(msg_ctx->counter),\n\t\t     (__be32 __user *)(&buf[PKT_CTR_OFFSET])))\n\t\tgoto out_unlock_msg_ctx;\n\ti = PKT_TYPE_SIZE + PKT_CTR_SIZE;\n\tif (msg_ctx->msg) {\n\t\tif (copy_to_user(&buf[i], packet_length, packet_length_size))\n\t\t\tgoto out_unlock_msg_ctx;\n\t\ti += packet_length_size;\n\t\tif (copy_to_user(&buf[i], msg_ctx->msg, msg_ctx->msg_size))\n\t\t\tgoto out_unlock_msg_ctx;\n\t\ti += msg_ctx->msg_size;\n\t}\n\trc = i;\n\tlist_del(&msg_ctx->daemon_out_list);\n\tkfree(msg_ctx->msg);\n\tmsg_ctx->msg = NULL;\n\t \n\tif (msg_ctx->type != ECRYPTFS_MSG_REQUEST)\n\t\tecryptfs_msg_ctx_alloc_to_free(msg_ctx);\nout_unlock_msg_ctx:\n\tmutex_unlock(&msg_ctx->mux);\nout_unlock_daemon:\n\tdaemon->flags &= ~ECRYPTFS_DAEMON_IN_READ;\n\tmutex_unlock(&daemon->mux);\n\treturn rc;\n}\n\n \nstatic int ecryptfs_miscdev_response(struct ecryptfs_daemon *daemon, char *data,\n\t\t\t\t     size_t data_size, u32 seq)\n{\n\tstruct ecryptfs_message *msg = (struct ecryptfs_message *)data;\n\tint rc;\n\n\tif ((sizeof(*msg) + msg->data_len) != data_size) {\n\t\tprintk(KERN_WARNING \"%s: (sizeof(*msg) + msg->data_len) = \"\n\t\t       \"[%zd]; data_size = [%zd]. Invalid packet.\\n\", __func__,\n\t\t       (sizeof(*msg) + msg->data_len), data_size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_process_response(daemon, msg, seq);\n\tif (rc)\n\t\tprintk(KERN_ERR\n\t\t       \"Error processing response message; rc = [%d]\\n\", rc);\nout:\n\treturn rc;\n}\n\n \nstatic ssize_t\necryptfs_miscdev_write(struct file *file, const char __user *buf,\n\t\t       size_t count, loff_t *ppos)\n{\n\t__be32 counter_nbo;\n\tu32 seq;\n\tsize_t packet_size, packet_size_length;\n\tchar *data;\n\tunsigned char packet_size_peek[ECRYPTFS_MAX_PKT_LEN_SIZE];\n\tssize_t rc;\n\n\tif (count == 0) {\n\t\treturn 0;\n\t} else if (count == MIN_NON_MSG_PKT_SIZE) {\n\t\t \n\t\tgoto memdup;\n\t} else if (count < MIN_MSG_PKT_SIZE || count > MAX_MSG_PKT_SIZE) {\n\t\tprintk(KERN_WARNING \"%s: Acceptable packet size range is \"\n\t\t       \"[%d-%zu], but amount of data written is [%zu].\\n\",\n\t\t       __func__, MIN_MSG_PKT_SIZE, MAX_MSG_PKT_SIZE, count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(packet_size_peek, &buf[PKT_LEN_OFFSET],\n\t\t\t   sizeof(packet_size_peek))) {\n\t\tprintk(KERN_WARNING \"%s: Error while inspecting packet size\\n\",\n\t\t       __func__);\n\t\treturn -EFAULT;\n\t}\n\n\trc = ecryptfs_parse_packet_length(packet_size_peek, &packet_size,\n\t\t\t\t\t  &packet_size_length);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"%s: Error parsing packet length; \"\n\t\t       \"rc = [%zd]\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif ((PKT_TYPE_SIZE + PKT_CTR_SIZE + packet_size_length + packet_size)\n\t    != count) {\n\t\tprintk(KERN_WARNING \"%s: Invalid packet size [%zu]\\n\", __func__,\n\t\t       packet_size);\n\t\treturn -EINVAL;\n\t}\n\nmemdup:\n\tdata = memdup_user(buf, count);\n\tif (IS_ERR(data)) {\n\t\tprintk(KERN_ERR \"%s: memdup_user returned error [%ld]\\n\",\n\t\t       __func__, PTR_ERR(data));\n\t\treturn PTR_ERR(data);\n\t}\n\tswitch (data[PKT_TYPE_OFFSET]) {\n\tcase ECRYPTFS_MSG_RESPONSE:\n\t\tif (count < (MIN_MSG_PKT_SIZE\n\t\t\t     + sizeof(struct ecryptfs_message))) {\n\t\t\tprintk(KERN_WARNING \"%s: Minimum acceptable packet \"\n\t\t\t       \"size is [%zd], but amount of data written is \"\n\t\t\t       \"only [%zd]. Discarding response packet.\\n\",\n\t\t\t       __func__,\n\t\t\t       (MIN_MSG_PKT_SIZE\n\t\t\t\t+ sizeof(struct ecryptfs_message)), count);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tmemcpy(&counter_nbo, &data[PKT_CTR_OFFSET], PKT_CTR_SIZE);\n\t\tseq = be32_to_cpu(counter_nbo);\n\t\trc = ecryptfs_miscdev_response(file->private_data,\n\t\t\t\t&data[PKT_LEN_OFFSET + packet_size_length],\n\t\t\t\tpacket_size, seq);\n\t\tif (rc) {\n\t\t\tprintk(KERN_WARNING \"%s: Failed to deliver miscdev \"\n\t\t\t       \"response to requesting operation; rc = [%zd]\\n\",\n\t\t\t       __func__, rc);\n\t\t\tgoto out_free;\n\t\t}\n\t\tbreak;\n\tcase ECRYPTFS_MSG_HELO:\n\tcase ECRYPTFS_MSG_QUIT:\n\t\tbreak;\n\tdefault:\n\t\tecryptfs_printk(KERN_WARNING, \"Dropping miscdev \"\n\t\t\t\t\"message of unrecognized type [%d]\\n\",\n\t\t\t\tdata[0]);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\trc = count;\nout_free:\n\tkfree(data);\n\treturn rc;\n}\n\n\nstatic const struct file_operations ecryptfs_miscdev_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = ecryptfs_miscdev_open,\n\t.poll    = ecryptfs_miscdev_poll,\n\t.read    = ecryptfs_miscdev_read,\n\t.write   = ecryptfs_miscdev_write,\n\t.release = ecryptfs_miscdev_release,\n\t.llseek  = noop_llseek,\n};\n\nstatic struct miscdevice ecryptfs_miscdev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name  = \"ecryptfs\",\n\t.fops  = &ecryptfs_miscdev_fops\n};\n\n \nint __init ecryptfs_init_ecryptfs_miscdev(void)\n{\n\tint rc;\n\n\tatomic_set(&ecryptfs_num_miscdev_opens, 0);\n\trc = misc_register(&ecryptfs_miscdev);\n\tif (rc)\n\t\tprintk(KERN_ERR \"%s: Failed to register miscellaneous device \"\n\t\t       \"for communications with userspace daemons; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\treturn rc;\n}\n\n \nvoid ecryptfs_destroy_ecryptfs_miscdev(void)\n{\n\tBUG_ON(atomic_read(&ecryptfs_num_miscdev_opens) != 0);\n\tmisc_deregister(&ecryptfs_miscdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}