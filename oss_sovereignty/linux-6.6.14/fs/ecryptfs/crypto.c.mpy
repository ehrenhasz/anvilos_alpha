{
  "module_name": "crypto.c",
  "hash_id": "dd353987fc9e93ef27e30d80e8c4727836b7b85dbc5f91ad294abe3e49008daf",
  "original_prompt": "Ingested from linux-6.6.14/fs/ecryptfs/crypto.c",
  "human_readable_source": "\n \n\n#include <crypto/hash.h>\n#include <crypto/skcipher.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/random.h>\n#include <linux/compiler.h>\n#include <linux/key.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n#include <linux/kernel.h>\n#include <linux/xattr.h>\n#include \"ecryptfs_kernel.h\"\n\n#define DECRYPT\t\t0\n#define ENCRYPT\t\t1\n\n \nvoid ecryptfs_from_hex(char *dst, char *src, int dst_size)\n{\n\tint x;\n\tchar tmp[3] = { 0, };\n\n\tfor (x = 0; x < dst_size; x++) {\n\t\ttmp[0] = src[x * 2];\n\t\ttmp[1] = src[x * 2 + 1];\n\t\tdst[x] = (unsigned char)simple_strtol(tmp, NULL, 16);\n\t}\n}\n\n \nstatic int ecryptfs_calculate_md5(char *dst,\n\t\t\t\t  struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t  char *src, int len)\n{\n\tint rc = crypto_shash_tfm_digest(crypt_stat->hash_tfm, src, len, dst);\n\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error computing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}\n\nstatic int ecryptfs_crypto_api_algify_cipher_name(char **algified_name,\n\t\t\t\t\t\t  char *cipher_name,\n\t\t\t\t\t\t  char *chaining_modifier)\n{\n\tint cipher_name_len = strlen(cipher_name);\n\tint chaining_modifier_len = strlen(chaining_modifier);\n\tint algified_name_len;\n\tint rc;\n\n\talgified_name_len = (chaining_modifier_len + cipher_name_len + 3);\n\t(*algified_name) = kmalloc(algified_name_len, GFP_KERNEL);\n\tif (!(*algified_name)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsnprintf((*algified_name), algified_name_len, \"%s(%s)\",\n\t\t chaining_modifier, cipher_name);\n\trc = 0;\nout:\n\treturn rc;\n}\n\n \nint ecryptfs_derive_iv(char *iv, struct ecryptfs_crypt_stat *crypt_stat,\n\t\t       loff_t offset)\n{\n\tint rc = 0;\n\tchar dst[MD5_DIGEST_SIZE];\n\tchar src[ECRYPTFS_MAX_IV_BYTES + 16];\n\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"root iv:\\n\");\n\t\tecryptfs_dump_hex(crypt_stat->root_iv, crypt_stat->iv_bytes);\n\t}\n\t \n\tmemcpy(src, crypt_stat->root_iv, crypt_stat->iv_bytes);\n\tmemset((src + crypt_stat->iv_bytes), 0, 16);\n\tsnprintf((src + crypt_stat->iv_bytes), 16, \"%lld\", offset);\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"source:\\n\");\n\t\tecryptfs_dump_hex(src, (crypt_stat->iv_bytes + 16));\n\t}\n\trc = ecryptfs_calculate_md5(dst, crypt_stat, src,\n\t\t\t\t    (crypt_stat->iv_bytes + 16));\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error attempting to compute \"\n\t\t\t\t\"MD5 while generating IV for a page\\n\");\n\t\tgoto out;\n\t}\n\tmemcpy(iv, dst, crypt_stat->iv_bytes);\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"derived iv:\\n\");\n\t\tecryptfs_dump_hex(iv, crypt_stat->iv_bytes);\n\t}\nout:\n\treturn rc;\n}\n\n \nint ecryptfs_init_crypt_stat(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = crypto_alloc_shash(ECRYPTFS_DEFAULT_HASH, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\trc = PTR_ERR(tfm);\n\t\tecryptfs_printk(KERN_ERR, \"Error attempting to \"\n\t\t\t\t\"allocate crypto context; rc = [%d]\\n\",\n\t\t\t\trc);\n\t\treturn rc;\n\t}\n\n\tmemset((void *)crypt_stat, 0, sizeof(struct ecryptfs_crypt_stat));\n\tINIT_LIST_HEAD(&crypt_stat->keysig_list);\n\tmutex_init(&crypt_stat->keysig_list_mutex);\n\tmutex_init(&crypt_stat->cs_mutex);\n\tmutex_init(&crypt_stat->cs_tfm_mutex);\n\tcrypt_stat->hash_tfm = tfm;\n\tcrypt_stat->flags |= ECRYPTFS_STRUCT_INITIALIZED;\n\n\treturn 0;\n}\n\n \nvoid ecryptfs_destroy_crypt_stat(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tstruct ecryptfs_key_sig *key_sig, *key_sig_tmp;\n\n\tcrypto_free_skcipher(crypt_stat->tfm);\n\tcrypto_free_shash(crypt_stat->hash_tfm);\n\tlist_for_each_entry_safe(key_sig, key_sig_tmp,\n\t\t\t\t &crypt_stat->keysig_list, crypt_stat_list) {\n\t\tlist_del(&key_sig->crypt_stat_list);\n\t\tkmem_cache_free(ecryptfs_key_sig_cache, key_sig);\n\t}\n\tmemset(crypt_stat, 0, sizeof(struct ecryptfs_crypt_stat));\n}\n\nvoid ecryptfs_destroy_mount_crypt_stat(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *auth_tok, *auth_tok_tmp;\n\n\tif (!(mount_crypt_stat->flags & ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED))\n\t\treturn;\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_for_each_entry_safe(auth_tok, auth_tok_tmp,\n\t\t\t\t &mount_crypt_stat->global_auth_tok_list,\n\t\t\t\t mount_crypt_stat_list) {\n\t\tlist_del(&auth_tok->mount_crypt_stat_list);\n\t\tif (!(auth_tok->flags & ECRYPTFS_AUTH_TOK_INVALID))\n\t\t\tkey_put(auth_tok->global_auth_tok_key);\n\t\tkmem_cache_free(ecryptfs_global_auth_tok_cache, auth_tok);\n\t}\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmemset(mount_crypt_stat, 0, sizeof(struct ecryptfs_mount_crypt_stat));\n}\n\n \nint virt_to_scatterlist(const void *addr, int size, struct scatterlist *sg,\n\t\t\tint sg_size)\n{\n\tint i = 0;\n\tstruct page *pg;\n\tint offset;\n\tint remainder_of_page;\n\n\tsg_init_table(sg, sg_size);\n\n\twhile (size > 0 && i < sg_size) {\n\t\tpg = virt_to_page(addr);\n\t\toffset = offset_in_page(addr);\n\t\tsg_set_page(&sg[i], pg, 0, offset);\n\t\tremainder_of_page = PAGE_SIZE - offset;\n\t\tif (size >= remainder_of_page) {\n\t\t\tsg[i].length = remainder_of_page;\n\t\t\taddr += remainder_of_page;\n\t\t\tsize -= remainder_of_page;\n\t\t} else {\n\t\t\tsg[i].length = size;\n\t\t\taddr += size;\n\t\t\tsize = 0;\n\t\t}\n\t\ti++;\n\t}\n\tif (size > 0)\n\t\treturn -ENOMEM;\n\treturn i;\n}\n\n \nstatic int crypt_scatterlist(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t     struct scatterlist *dst_sg,\n\t\t\t     struct scatterlist *src_sg, int size,\n\t\t\t     unsigned char *iv, int op)\n{\n\tstruct skcipher_request *req = NULL;\n\tDECLARE_CRYPTO_WAIT(ecr);\n\tint rc = 0;\n\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Key size [%zd]; key:\\n\",\n\t\t\t\tcrypt_stat->key_size);\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\n\n\tmutex_lock(&crypt_stat->cs_tfm_mutex);\n\treq = skcipher_request_alloc(crypt_stat->tfm, GFP_NOFS);\n\tif (!req) {\n\t\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tskcipher_request_set_callback(req,\n\t\t\tCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\tcrypto_req_done, &ecr);\n\t \n\tif (!(crypt_stat->flags & ECRYPTFS_KEY_SET)) {\n\t\trc = crypto_skcipher_setkey(crypt_stat->tfm, crypt_stat->key,\n\t\t\t\t\t    crypt_stat->key_size);\n\t\tif (rc) {\n\t\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\t\"Error setting key; rc = [%d]\\n\",\n\t\t\t\t\trc);\n\t\t\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcrypt_stat->flags |= ECRYPTFS_KEY_SET;\n\t}\n\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\tskcipher_request_set_crypt(req, src_sg, dst_sg, size, iv);\n\trc = op == ENCRYPT ? crypto_skcipher_encrypt(req) :\n\t\t\t     crypto_skcipher_decrypt(req);\n\trc = crypto_wait_req(rc, &ecr);\nout:\n\tskcipher_request_free(req);\n\treturn rc;\n}\n\n \nstatic loff_t lower_offset_for_page(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t    struct page *page)\n{\n\treturn ecryptfs_lower_header_size(crypt_stat) +\n\t       ((loff_t)page->index << PAGE_SHIFT);\n}\n\n \nstatic int crypt_extent(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\tstruct page *dst_page,\n\t\t\tstruct page *src_page,\n\t\t\tunsigned long extent_offset, int op)\n{\n\tpgoff_t page_index = op == ENCRYPT ? src_page->index : dst_page->index;\n\tloff_t extent_base;\n\tchar extent_iv[ECRYPTFS_MAX_IV_BYTES];\n\tstruct scatterlist src_sg, dst_sg;\n\tsize_t extent_size = crypt_stat->extent_size;\n\tint rc;\n\n\textent_base = (((loff_t)page_index) * (PAGE_SIZE / extent_size));\n\trc = ecryptfs_derive_iv(extent_iv, crypt_stat,\n\t\t\t\t(extent_base + extent_offset));\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error attempting to derive IV for \"\n\t\t\t\"extent [0x%.16llx]; rc = [%d]\\n\",\n\t\t\t(unsigned long long)(extent_base + extent_offset), rc);\n\t\tgoto out;\n\t}\n\n\tsg_init_table(&src_sg, 1);\n\tsg_init_table(&dst_sg, 1);\n\n\tsg_set_page(&src_sg, src_page, extent_size,\n\t\t    extent_offset * extent_size);\n\tsg_set_page(&dst_sg, dst_page, extent_size,\n\t\t    extent_offset * extent_size);\n\n\trc = crypt_scatterlist(crypt_stat, &dst_sg, &src_sg, extent_size,\n\t\t\t       extent_iv, op);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to crypt page with \"\n\t\t       \"page_index = [%ld], extent_offset = [%ld]; \"\n\t\t       \"rc = [%d]\\n\", __func__, page_index, extent_offset, rc);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}\n\n \nint ecryptfs_encrypt_page(struct page *page)\n{\n\tstruct inode *ecryptfs_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *enc_extent_virt;\n\tstruct page *enc_extent_page = NULL;\n\tloff_t extent_offset;\n\tloff_t lower_offset;\n\tint rc = 0;\n\n\tecryptfs_inode = page->mapping->host;\n\tcrypt_stat =\n\t\t&(ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat);\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\tenc_extent_page = alloc_page(GFP_USER);\n\tif (!enc_extent_page) {\n\t\trc = -ENOMEM;\n\t\tecryptfs_printk(KERN_ERR, \"Error allocating memory for \"\n\t\t\t\t\"encrypted extent\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (extent_offset = 0;\n\t     extent_offset < (PAGE_SIZE / crypt_stat->extent_size);\n\t     extent_offset++) {\n\t\trc = crypt_extent(crypt_stat, enc_extent_page, page,\n\t\t\t\t  extent_offset, ENCRYPT);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting extent; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlower_offset = lower_offset_for_page(crypt_stat, page);\n\tenc_extent_virt = kmap_local_page(enc_extent_page);\n\trc = ecryptfs_write_lower(ecryptfs_inode, enc_extent_virt, lower_offset,\n\t\t\t\t  PAGE_SIZE);\n\tkunmap_local(enc_extent_virt);\n\tif (rc < 0) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\"Error attempting to write lower page; rc = [%d]\\n\",\n\t\t\trc);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\tif (enc_extent_page) {\n\t\t__free_page(enc_extent_page);\n\t}\n\treturn rc;\n}\n\n \nint ecryptfs_decrypt_page(struct page *page)\n{\n\tstruct inode *ecryptfs_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *page_virt;\n\tunsigned long extent_offset;\n\tloff_t lower_offset;\n\tint rc = 0;\n\n\tecryptfs_inode = page->mapping->host;\n\tcrypt_stat =\n\t\t&(ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat);\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\n\tlower_offset = lower_offset_for_page(crypt_stat, page);\n\tpage_virt = kmap_local_page(page);\n\trc = ecryptfs_read_lower(page_virt, lower_offset, PAGE_SIZE,\n\t\t\t\t ecryptfs_inode);\n\tkunmap_local(page_virt);\n\tif (rc < 0) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\"Error attempting to read lower page; rc = [%d]\\n\",\n\t\t\trc);\n\t\tgoto out;\n\t}\n\n\tfor (extent_offset = 0;\n\t     extent_offset < (PAGE_SIZE / crypt_stat->extent_size);\n\t     extent_offset++) {\n\t\trc = crypt_extent(crypt_stat, page, page,\n\t\t\t\t  extent_offset, DECRYPT);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error decrypting extent; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn rc;\n}\n\n#define ECRYPTFS_MAX_SCATTERLIST_LEN 4\n\n \nint ecryptfs_init_crypt_ctx(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tchar *full_alg_name;\n\tint rc = -EINVAL;\n\n\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\"Initializing cipher [%s]; strlen = [%d]; \"\n\t\t\t\"key_size_bits = [%zd]\\n\",\n\t\t\tcrypt_stat->cipher, (int)strlen(crypt_stat->cipher),\n\t\t\tcrypt_stat->key_size << 3);\n\tmutex_lock(&crypt_stat->cs_tfm_mutex);\n\tif (crypt_stat->tfm) {\n\t\trc = 0;\n\t\tgoto out_unlock;\n\t}\n\trc = ecryptfs_crypto_api_algify_cipher_name(&full_alg_name,\n\t\t\t\t\t\t    crypt_stat->cipher, \"cbc\");\n\tif (rc)\n\t\tgoto out_unlock;\n\tcrypt_stat->tfm = crypto_alloc_skcipher(full_alg_name, 0, 0);\n\tif (IS_ERR(crypt_stat->tfm)) {\n\t\trc = PTR_ERR(crypt_stat->tfm);\n\t\tcrypt_stat->tfm = NULL;\n\t\tecryptfs_printk(KERN_ERR, \"cryptfs: init_crypt_ctx(): \"\n\t\t\t\t\"Error initializing cipher [%s]\\n\",\n\t\t\t\tfull_alg_name);\n\t\tgoto out_free;\n\t}\n\tcrypto_skcipher_set_flags(crypt_stat->tfm,\n\t\t\t\t  CRYPTO_TFM_REQ_FORBID_WEAK_KEYS);\n\trc = 0;\nout_free:\n\tkfree(full_alg_name);\nout_unlock:\n\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\treturn rc;\n}\n\nstatic void set_extent_mask_and_shift(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tint extent_size_tmp;\n\n\tcrypt_stat->extent_mask = 0xFFFFFFFF;\n\tcrypt_stat->extent_shift = 0;\n\tif (crypt_stat->extent_size == 0)\n\t\treturn;\n\textent_size_tmp = crypt_stat->extent_size;\n\twhile ((extent_size_tmp & 0x01) == 0) {\n\t\textent_size_tmp >>= 1;\n\t\tcrypt_stat->extent_mask <<= 1;\n\t\tcrypt_stat->extent_shift++;\n\t}\n}\n\nvoid ecryptfs_set_default_sizes(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\t \n\tcrypt_stat->extent_size = ECRYPTFS_DEFAULT_EXTENT_SIZE;\n\tset_extent_mask_and_shift(crypt_stat);\n\tcrypt_stat->iv_bytes = ECRYPTFS_DEFAULT_IV_BYTES;\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\tcrypt_stat->metadata_size = ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n\telse {\n\t\tif (PAGE_SIZE <= ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE)\n\t\t\tcrypt_stat->metadata_size =\n\t\t\t\tECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n\t\telse\n\t\t\tcrypt_stat->metadata_size = PAGE_SIZE;\n\t}\n}\n\n \nint ecryptfs_compute_root_iv(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tint rc = 0;\n\tchar dst[MD5_DIGEST_SIZE];\n\n\tBUG_ON(crypt_stat->iv_bytes > MD5_DIGEST_SIZE);\n\tBUG_ON(crypt_stat->iv_bytes <= 0);\n\tif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING, \"Session key not valid; \"\n\t\t\t\t\"cannot generate root IV\\n\");\n\t\tgoto out;\n\t}\n\trc = ecryptfs_calculate_md5(dst, crypt_stat, crypt_stat->key,\n\t\t\t\t    crypt_stat->key_size);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error attempting to compute \"\n\t\t\t\t\"MD5 while generating root IV\\n\");\n\t\tgoto out;\n\t}\n\tmemcpy(crypt_stat->root_iv, dst, crypt_stat->iv_bytes);\nout:\n\tif (rc) {\n\t\tmemset(crypt_stat->root_iv, 0, crypt_stat->iv_bytes);\n\t\tcrypt_stat->flags |= ECRYPTFS_SECURITY_WARNING;\n\t}\n\treturn rc;\n}\n\nstatic void ecryptfs_generate_new_key(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tget_random_bytes(crypt_stat->key, crypt_stat->key_size);\n\tcrypt_stat->flags |= ECRYPTFS_KEY_VALID;\n\tecryptfs_compute_root_iv(crypt_stat);\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Generated new session key:\\n\");\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\n}\n\n \nstatic void ecryptfs_copy_mount_wide_flags_to_inode_flags(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tif (mount_crypt_stat->flags & ECRYPTFS_XATTR_METADATA_ENABLED)\n\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\tif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\n\t\tcrypt_stat->flags |= ECRYPTFS_VIEW_AS_ENCRYPTED;\n\tif (mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) {\n\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPT_FILENAMES;\n\t\tif (mount_crypt_stat->flags\n\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCFN_USE_MOUNT_FNEK;\n\t\telse if (mount_crypt_stat->flags\n\t\t\t & ECRYPTFS_GLOBAL_ENCFN_USE_FEK)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCFN_USE_FEK;\n\t}\n}\n\nstatic int ecryptfs_copy_mount_wide_sigs_to_inode_sigs(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *global_auth_tok;\n\tint rc = 0;\n\n\tmutex_lock(&crypt_stat->keysig_list_mutex);\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\n\tlist_for_each_entry(global_auth_tok,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\tif (global_auth_tok->flags & ECRYPTFS_AUTH_TOK_FNEK)\n\t\t\tcontinue;\n\t\trc = ecryptfs_add_keysig(crypt_stat, global_auth_tok->sig);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error adding keysig; rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmutex_unlock(&crypt_stat->keysig_list_mutex);\n\treturn rc;\n}\n\n \nstatic void ecryptfs_set_default_crypt_stat_vals(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\tecryptfs_set_default_sizes(crypt_stat);\n\tstrcpy(crypt_stat->cipher, ECRYPTFS_DEFAULT_CIPHER);\n\tcrypt_stat->key_size = ECRYPTFS_DEFAULT_KEY_BYTES;\n\tcrypt_stat->flags &= ~(ECRYPTFS_KEY_VALID);\n\tcrypt_stat->file_version = ECRYPTFS_FILE_VERSION;\n\tcrypt_stat->mount_crypt_stat = mount_crypt_stat;\n}\n\n \nint ecryptfs_new_file_context(struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t    &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t    &ecryptfs_superblock_to_private(\n\t\t    ecryptfs_inode->i_sb)->mount_crypt_stat;\n\tint cipher_name_len;\n\tint rc = 0;\n\n\tecryptfs_set_default_crypt_stat_vals(crypt_stat, mount_crypt_stat);\n\tcrypt_stat->flags |= (ECRYPTFS_ENCRYPTED | ECRYPTFS_KEY_VALID);\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\trc = ecryptfs_copy_mount_wide_sigs_to_inode_sigs(crypt_stat,\n\t\t\t\t\t\t\t mount_crypt_stat);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to copy mount-wide key sigs \"\n\t\t       \"to the inode key sigs; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tcipher_name_len =\n\t\tstrlen(mount_crypt_stat->global_default_cipher_name);\n\tmemcpy(crypt_stat->cipher,\n\t       mount_crypt_stat->global_default_cipher_name,\n\t       cipher_name_len);\n\tcrypt_stat->cipher[cipher_name_len] = '\\0';\n\tcrypt_stat->key_size =\n\t\tmount_crypt_stat->global_default_cipher_key_size;\n\tecryptfs_generate_new_key(crypt_stat);\n\trc = ecryptfs_init_crypt_ctx(crypt_stat);\n\tif (rc)\n\t\tecryptfs_printk(KERN_ERR, \"Error initializing cryptographic \"\n\t\t\t\t\"context for cipher [%s]: rc = [%d]\\n\",\n\t\t\t\tcrypt_stat->cipher, rc);\nout:\n\treturn rc;\n}\n\n \nstatic int ecryptfs_validate_marker(char *data)\n{\n\tu32 m_1, m_2;\n\n\tm_1 = get_unaligned_be32(data);\n\tm_2 = get_unaligned_be32(data + 4);\n\tif ((m_1 ^ MAGIC_ECRYPTFS_MARKER) == m_2)\n\t\treturn 0;\n\tecryptfs_printk(KERN_DEBUG, \"m_1 = [0x%.8x]; m_2 = [0x%.8x]; \"\n\t\t\t\"MAGIC_ECRYPTFS_MARKER = [0x%.8x]\\n\", m_1, m_2,\n\t\t\tMAGIC_ECRYPTFS_MARKER);\n\tecryptfs_printk(KERN_DEBUG, \"(m_1 ^ MAGIC_ECRYPTFS_MARKER) = \"\n\t\t\t\"[0x%.8x]\\n\", (m_1 ^ MAGIC_ECRYPTFS_MARKER));\n\treturn -EINVAL;\n}\n\nstruct ecryptfs_flag_map_elem {\n\tu32 file_flag;\n\tu32 local_flag;\n};\n\n \nstatic struct ecryptfs_flag_map_elem ecryptfs_flag_map[] = {\n\t{0x00000001, ECRYPTFS_ENABLE_HMAC},\n\t{0x00000002, ECRYPTFS_ENCRYPTED},\n\t{0x00000004, ECRYPTFS_METADATA_IN_XATTR},\n\t{0x00000008, ECRYPTFS_ENCRYPT_FILENAMES}\n};\n\n \nstatic void ecryptfs_process_flags(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t  char *page_virt, int *bytes_read)\n{\n\tint i;\n\tu32 flags;\n\n\tflags = get_unaligned_be32(page_virt);\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_flag_map); i++)\n\t\tif (flags & ecryptfs_flag_map[i].file_flag) {\n\t\t\tcrypt_stat->flags |= ecryptfs_flag_map[i].local_flag;\n\t\t} else\n\t\t\tcrypt_stat->flags &= ~(ecryptfs_flag_map[i].local_flag);\n\t \n\tcrypt_stat->file_version = ((flags >> 24) & 0xFF);\n\t(*bytes_read) = 4;\n}\n\n \nstatic void write_ecryptfs_marker(char *page_virt, size_t *written)\n{\n\tu32 m_1, m_2;\n\n\tget_random_bytes(&m_1, (MAGIC_ECRYPTFS_MARKER_SIZE_BYTES / 2));\n\tm_2 = (m_1 ^ MAGIC_ECRYPTFS_MARKER);\n\tput_unaligned_be32(m_1, page_virt);\n\tpage_virt += (MAGIC_ECRYPTFS_MARKER_SIZE_BYTES / 2);\n\tput_unaligned_be32(m_2, page_virt);\n\t(*written) = MAGIC_ECRYPTFS_MARKER_SIZE_BYTES;\n}\n\nvoid ecryptfs_write_crypt_stat_flags(char *page_virt,\n\t\t\t\t     struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t     size_t *written)\n{\n\tu32 flags = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_flag_map); i++)\n\t\tif (crypt_stat->flags & ecryptfs_flag_map[i].local_flag)\n\t\t\tflags |= ecryptfs_flag_map[i].file_flag;\n\t \n\tflags |= ((((u8)crypt_stat->file_version) << 24) & 0xFF000000);\n\tput_unaligned_be32(flags, page_virt);\n\t(*written) = 4;\n}\n\nstruct ecryptfs_cipher_code_str_map_elem {\n\tchar cipher_str[16];\n\tu8 cipher_code;\n};\n\n \nstatic struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};\n\n \nu8 ecryptfs_code_for_cipher_string(char *cipher_name, size_t key_bytes)\n{\n\tint i;\n\tu8 code = 0;\n\tstruct ecryptfs_cipher_code_str_map_elem *map =\n\t\tecryptfs_cipher_code_str_map;\n\n\tif (strcmp(cipher_name, \"aes\") == 0) {\n\t\tswitch (key_bytes) {\n\t\tcase 16:\n\t\t\tcode = RFC2440_CIPHER_AES_128;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tcode = RFC2440_CIPHER_AES_192;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tcode = RFC2440_CIPHER_AES_256;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\t\tif (strcmp(cipher_name, map[i].cipher_str) == 0) {\n\t\t\t\tcode = map[i].cipher_code;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn code;\n}\n\n \nint ecryptfs_cipher_code_to_string(char *str, u8 cipher_code)\n{\n\tint rc = 0;\n\tint i;\n\n\tstr[0] = '\\0';\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\tif (cipher_code == ecryptfs_cipher_code_str_map[i].cipher_code)\n\t\t\tstrcpy(str, ecryptfs_cipher_code_str_map[i].cipher_str);\n\tif (str[0] == '\\0') {\n\t\tecryptfs_printk(KERN_WARNING, \"Cipher code not recognized: \"\n\t\t\t\t\"[%d]\\n\", cipher_code);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}\n\nint ecryptfs_read_and_validate_header_region(struct inode *inode)\n{\n\tu8 file_size[ECRYPTFS_SIZE_AND_MARKER_BYTES];\n\tu8 *marker = file_size + ECRYPTFS_FILE_SIZE_BYTES;\n\tint rc;\n\n\trc = ecryptfs_read_lower(file_size, 0, ECRYPTFS_SIZE_AND_MARKER_BYTES,\n\t\t\t\t inode);\n\tif (rc < 0)\n\t\treturn rc;\n\telse if (rc < ECRYPTFS_SIZE_AND_MARKER_BYTES)\n\t\treturn -EINVAL;\n\trc = ecryptfs_validate_marker(marker);\n\tif (!rc)\n\t\tecryptfs_i_size_init(file_size, inode);\n\treturn rc;\n}\n\nvoid\necryptfs_write_header_metadata(char *virt,\n\t\t\t       struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t       size_t *written)\n{\n\tu32 header_extent_size;\n\tu16 num_header_extents_at_front;\n\n\theader_extent_size = (u32)crypt_stat->extent_size;\n\tnum_header_extents_at_front =\n\t\t(u16)(crypt_stat->metadata_size / crypt_stat->extent_size);\n\tput_unaligned_be32(header_extent_size, virt);\n\tvirt += 4;\n\tput_unaligned_be16(num_header_extents_at_front, virt);\n\t(*written) = 6;\n}\n\nstruct kmem_cache *ecryptfs_header_cache;\n\n \nstatic int ecryptfs_write_headers_virt(char *page_virt, size_t max,\n\t\t\t\t       size_t *size,\n\t\t\t\t       struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t       struct dentry *ecryptfs_dentry)\n{\n\tint rc;\n\tsize_t written;\n\tsize_t offset;\n\n\toffset = ECRYPTFS_FILE_SIZE_BYTES;\n\twrite_ecryptfs_marker((page_virt + offset), &written);\n\toffset += written;\n\tecryptfs_write_crypt_stat_flags((page_virt + offset), crypt_stat,\n\t\t\t\t\t&written);\n\toffset += written;\n\tecryptfs_write_header_metadata((page_virt + offset), crypt_stat,\n\t\t\t\t       &written);\n\toffset += written;\n\trc = ecryptfs_generate_key_packet_set((page_virt + offset), crypt_stat,\n\t\t\t\t\t      ecryptfs_dentry, &written,\n\t\t\t\t\t      max - offset);\n\tif (rc)\n\t\tecryptfs_printk(KERN_WARNING, \"Error generating key packet \"\n\t\t\t\t\"set; rc = [%d]\\n\", rc);\n\tif (size) {\n\t\toffset += written;\n\t\t*size = offset;\n\t}\n\treturn rc;\n}\n\nstatic int\necryptfs_write_metadata_to_contents(struct inode *ecryptfs_inode,\n\t\t\t\t    char *virt, size_t virt_len)\n{\n\tint rc;\n\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt,\n\t\t\t\t  0, virt_len);\n\tif (rc < 0)\n\t\tprintk(KERN_ERR \"%s: Error attempting to write header \"\n\t\t       \"information to lower file; rc = [%d]\\n\", __func__, rc);\n\telse\n\t\trc = 0;\n\treturn rc;\n}\n\nstatic int\necryptfs_write_metadata_to_xattr(struct dentry *ecryptfs_dentry,\n\t\t\t\t struct inode *ecryptfs_inode,\n\t\t\t\t char *page_virt, size_t size)\n{\n\tint rc;\n\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(ecryptfs_dentry);\n\tstruct inode *lower_inode = d_inode(lower_dentry);\n\n\tif (!(lower_inode->i_opflags & IOP_XATTR)) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tinode_lock(lower_inode);\n\trc = __vfs_setxattr(&nop_mnt_idmap, lower_dentry, lower_inode,\n\t\t\t    ECRYPTFS_XATTR_NAME, page_virt, size, 0);\n\tif (!rc && ecryptfs_inode)\n\t\tfsstack_copy_attr_all(ecryptfs_inode, lower_inode);\n\tinode_unlock(lower_inode);\nout:\n\treturn rc;\n}\n\nstatic unsigned long ecryptfs_get_zeroed_pages(gfp_t gfp_mask,\n\t\t\t\t\t       unsigned int order)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(gfp_mask | __GFP_ZERO, order);\n\tif (page)\n\t\treturn (unsigned long) page_address(page);\n\treturn 0;\n}\n\n \nint ecryptfs_write_metadata(struct dentry *ecryptfs_dentry,\n\t\t\t    struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tunsigned int order;\n\tchar *virt;\n\tsize_t virt_len;\n\tsize_t size = 0;\n\tint rc = 0;\n\n\tif (likely(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\tif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {\n\t\t\tprintk(KERN_ERR \"Key is invalid; bailing out\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tprintk(KERN_WARNING \"%s: Encrypted flag not set\\n\",\n\t\t       __func__);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tvirt_len = crypt_stat->metadata_size;\n\torder = get_order(virt_len);\n\t \n\tvirt = (char *)ecryptfs_get_zeroed_pages(GFP_KERNEL, order);\n\tif (!virt) {\n\t\tprintk(KERN_ERR \"%s: Out of memory\\n\", __func__);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\t \n\trc = ecryptfs_write_headers_virt(virt, virt_len, &size, crypt_stat,\n\t\t\t\t\t ecryptfs_dentry);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"%s: Error whilst writing headers; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_free;\n\t}\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\trc = ecryptfs_write_metadata_to_xattr(ecryptfs_dentry, ecryptfs_inode,\n\t\t\t\t\t\t      virt, size);\n\telse\n\t\trc = ecryptfs_write_metadata_to_contents(ecryptfs_inode, virt,\n\t\t\t\t\t\t\t virt_len);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error writing metadata out to lower file; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_free;\n\t}\nout_free:\n\tfree_pages((unsigned long)virt, order);\nout:\n\treturn rc;\n}\n\n#define ECRYPTFS_DONT_VALIDATE_HEADER_SIZE 0\n#define ECRYPTFS_VALIDATE_HEADER_SIZE 1\nstatic int parse_header_metadata(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t char *virt, int *bytes_read,\n\t\t\t\t int validate_header_size)\n{\n\tint rc = 0;\n\tu32 header_extent_size;\n\tu16 num_header_extents_at_front;\n\n\theader_extent_size = get_unaligned_be32(virt);\n\tvirt += sizeof(__be32);\n\tnum_header_extents_at_front = get_unaligned_be16(virt);\n\tcrypt_stat->metadata_size = (((size_t)num_header_extents_at_front\n\t\t\t\t     * (size_t)header_extent_size));\n\t(*bytes_read) = (sizeof(__be32) + sizeof(__be16));\n\tif ((validate_header_size == ECRYPTFS_VALIDATE_HEADER_SIZE)\n\t    && (crypt_stat->metadata_size\n\t\t< ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE)) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_WARNING \"Invalid header size: [%zd]\\n\",\n\t\t       crypt_stat->metadata_size);\n\t}\n\treturn rc;\n}\n\n \nstatic void set_default_header_data(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tcrypt_stat->metadata_size = ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n}\n\nvoid ecryptfs_i_size_init(const char *page_virt, struct inode *inode)\n{\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tu64 file_size;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tmount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(inode->i_sb)->mount_crypt_stat;\n\tif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED) {\n\t\tfile_size = i_size_read(ecryptfs_inode_to_lower(inode));\n\t\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\t\tfile_size += crypt_stat->metadata_size;\n\t} else\n\t\tfile_size = get_unaligned_be64(page_virt);\n\ti_size_write(inode, (loff_t)file_size);\n\tcrypt_stat->flags |= ECRYPTFS_I_SIZE_INITIALIZED;\n}\n\n \nstatic int ecryptfs_read_headers_virt(char *page_virt,\n\t\t\t\t      struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t      struct dentry *ecryptfs_dentry,\n\t\t\t\t      int validate_header_size)\n{\n\tint rc = 0;\n\tint offset;\n\tint bytes_read;\n\n\tecryptfs_set_default_sizes(crypt_stat);\n\tcrypt_stat->mount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\toffset = ECRYPTFS_FILE_SIZE_BYTES;\n\trc = ecryptfs_validate_marker(page_virt + offset);\n\tif (rc)\n\t\tgoto out;\n\tif (!(crypt_stat->flags & ECRYPTFS_I_SIZE_INITIALIZED))\n\t\tecryptfs_i_size_init(page_virt, d_inode(ecryptfs_dentry));\n\toffset += MAGIC_ECRYPTFS_MARKER_SIZE_BYTES;\n\tecryptfs_process_flags(crypt_stat, (page_virt + offset), &bytes_read);\n\tif (crypt_stat->file_version > ECRYPTFS_SUPPORTED_FILE_VERSION) {\n\t\tecryptfs_printk(KERN_WARNING, \"File version is [%d]; only \"\n\t\t\t\t\"file version [%d] is supported by this \"\n\t\t\t\t\"version of eCryptfs\\n\",\n\t\t\t\tcrypt_stat->file_version,\n\t\t\t\tECRYPTFS_SUPPORTED_FILE_VERSION);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\toffset += bytes_read;\n\tif (crypt_stat->file_version >= 1) {\n\t\trc = parse_header_metadata(crypt_stat, (page_virt + offset),\n\t\t\t\t\t   &bytes_read, validate_header_size);\n\t\tif (rc) {\n\t\t\tecryptfs_printk(KERN_WARNING, \"Error reading header \"\n\t\t\t\t\t\"metadata; rc = [%d]\\n\", rc);\n\t\t}\n\t\toffset += bytes_read;\n\t} else\n\t\tset_default_header_data(crypt_stat);\n\trc = ecryptfs_parse_packet_set(crypt_stat, (page_virt + offset),\n\t\t\t\t       ecryptfs_dentry);\nout:\n\treturn rc;\n}\n\n \nint ecryptfs_read_xattr_region(char *page_virt, struct inode *ecryptfs_inode)\n{\n\tstruct dentry *lower_dentry =\n\t\tecryptfs_inode_to_private(ecryptfs_inode)->lower_file->f_path.dentry;\n\tssize_t size;\n\tint rc = 0;\n\n\tsize = ecryptfs_getxattr_lower(lower_dentry,\n\t\t\t\t       ecryptfs_inode_to_lower(ecryptfs_inode),\n\t\t\t\t       ECRYPTFS_XATTR_NAME,\n\t\t\t\t       page_virt, ECRYPTFS_DEFAULT_EXTENT_SIZE);\n\tif (size < 0) {\n\t\tif (unlikely(ecryptfs_verbosity > 0))\n\t\t\tprintk(KERN_INFO \"Error attempting to read the [%s] \"\n\t\t\t       \"xattr from the lower file; return value = \"\n\t\t\t       \"[%zd]\\n\", ECRYPTFS_XATTR_NAME, size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}\n\nint ecryptfs_read_and_validate_xattr_region(struct dentry *dentry,\n\t\t\t\t\t    struct inode *inode)\n{\n\tu8 file_size[ECRYPTFS_SIZE_AND_MARKER_BYTES];\n\tu8 *marker = file_size + ECRYPTFS_FILE_SIZE_BYTES;\n\tint rc;\n\n\trc = ecryptfs_getxattr_lower(ecryptfs_dentry_to_lower(dentry),\n\t\t\t\t     ecryptfs_inode_to_lower(inode),\n\t\t\t\t     ECRYPTFS_XATTR_NAME, file_size,\n\t\t\t\t     ECRYPTFS_SIZE_AND_MARKER_BYTES);\n\tif (rc < 0)\n\t\treturn rc;\n\telse if (rc < ECRYPTFS_SIZE_AND_MARKER_BYTES)\n\t\treturn -EINVAL;\n\trc = ecryptfs_validate_marker(marker);\n\tif (!rc)\n\t\tecryptfs_i_size_init(file_size, inode);\n\treturn rc;\n}\n\n \nint ecryptfs_read_metadata(struct dentry *ecryptfs_dentry)\n{\n\tint rc;\n\tchar *page_virt;\n\tstruct inode *ecryptfs_inode = d_inode(ecryptfs_dentry);\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t    &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(\n\t\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\t \n\tpage_virt = kmem_cache_alloc(ecryptfs_header_cache, GFP_USER);\n\tif (!page_virt) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_read_lower(page_virt, 0, crypt_stat->extent_size,\n\t\t\t\t ecryptfs_inode);\n\tif (rc >= 0)\n\t\trc = ecryptfs_read_headers_virt(page_virt, crypt_stat,\n\t\t\t\t\t\tecryptfs_dentry,\n\t\t\t\t\t\tECRYPTFS_VALIDATE_HEADER_SIZE);\n\tif (rc) {\n\t\t \n\t\tmemset(page_virt, 0, PAGE_SIZE);\n\t\trc = ecryptfs_read_xattr_region(page_virt, ecryptfs_inode);\n\t\tif (rc) {\n\t\t\tprintk(KERN_DEBUG \"Valid eCryptfs headers not found in \"\n\t\t\t       \"file header region or xattr region, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\trc = ecryptfs_read_headers_virt(page_virt, crypt_stat,\n\t\t\t\t\t\tecryptfs_dentry,\n\t\t\t\t\t\tECRYPTFS_DONT_VALIDATE_HEADER_SIZE);\n\t\tif (rc) {\n\t\t\tprintk(KERN_DEBUG \"Valid eCryptfs headers not found in \"\n\t\t\t       \"file xattr region either, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t}\n\t\tif (crypt_stat->mount_crypt_stat->flags\n\t\t    & ECRYPTFS_XATTR_METADATA_ENABLED) {\n\t\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"Attempt to access file with \"\n\t\t\t       \"crypto metadata only in the extended attribute \"\n\t\t\t       \"region, but eCryptfs was mounted without \"\n\t\t\t       \"xattr support enabled. eCryptfs will not treat \"\n\t\t\t       \"this like an encrypted file, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t}\n\t}\nout:\n\tif (page_virt) {\n\t\tmemset(page_virt, 0, PAGE_SIZE);\n\t\tkmem_cache_free(ecryptfs_header_cache, page_virt);\n\t}\n\treturn rc;\n}\n\n \nstatic int\necryptfs_encrypt_filename(struct ecryptfs_filename *filename,\n\t\t\t  struct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tint rc = 0;\n\n\tfilename->encrypted_filename = NULL;\n\tfilename->encrypted_filename_size = 0;\n\tif (mount_crypt_stat && (mount_crypt_stat->flags\n\t\t\t\t     & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)) {\n\t\tsize_t packet_size;\n\t\tsize_t remaining_bytes;\n\n\t\trc = ecryptfs_write_tag_70_packet(\n\t\t\tNULL, NULL,\n\t\t\t&filename->encrypted_filename_size,\n\t\t\tmount_crypt_stat, NULL,\n\t\t\tfilename->filename_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to get packet \"\n\t\t\t       \"size for tag 72; rc = [%d]\\n\", __func__,\n\t\t\t       rc);\n\t\t\tfilename->encrypted_filename_size = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tfilename->encrypted_filename =\n\t\t\tkmalloc(filename->encrypted_filename_size, GFP_KERNEL);\n\t\tif (!filename->encrypted_filename) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tremaining_bytes = filename->encrypted_filename_size;\n\t\trc = ecryptfs_write_tag_70_packet(filename->encrypted_filename,\n\t\t\t\t\t\t  &remaining_bytes,\n\t\t\t\t\t\t  &packet_size,\n\t\t\t\t\t\t  mount_crypt_stat,\n\t\t\t\t\t\t  filename->filename,\n\t\t\t\t\t\t  filename->filename_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to generate \"\n\t\t\t       \"tag 70 packet; rc = [%d]\\n\", __func__,\n\t\t\t       rc);\n\t\t\tkfree(filename->encrypted_filename);\n\t\t\tfilename->encrypted_filename = NULL;\n\t\t\tfilename->encrypted_filename_size = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tfilename->encrypted_filename_size = packet_size;\n\t} else {\n\t\tprintk(KERN_ERR \"%s: No support for requested filename \"\n\t\t       \"encryption method in this release\\n\", __func__);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}\n\nstatic int ecryptfs_copy_filename(char **copied_name, size_t *copied_name_size,\n\t\t\t\t  const char *name, size_t name_size)\n{\n\tint rc = 0;\n\n\t(*copied_name) = kmalloc((name_size + 1), GFP_KERNEL);\n\tif (!(*copied_name)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy((void *)(*copied_name), (void *)name, name_size);\n\t(*copied_name)[(name_size)] = '\\0';\t \n\t(*copied_name_size) = name_size;\nout:\n\treturn rc;\n}\n\n \nstatic int\necryptfs_process_key_cipher(struct crypto_skcipher **key_tfm,\n\t\t\t    char *cipher_name, size_t *key_size)\n{\n\tchar dummy_key[ECRYPTFS_MAX_KEY_BYTES];\n\tchar *full_alg_name = NULL;\n\tint rc;\n\n\t*key_tfm = NULL;\n\tif (*key_size > ECRYPTFS_MAX_KEY_BYTES) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"Requested key size is [%zd] bytes; maximum \"\n\t\t      \"allowable is [%d]\\n\", *key_size, ECRYPTFS_MAX_KEY_BYTES);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_crypto_api_algify_cipher_name(&full_alg_name, cipher_name,\n\t\t\t\t\t\t    \"ecb\");\n\tif (rc)\n\t\tgoto out;\n\t*key_tfm = crypto_alloc_skcipher(full_alg_name, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(*key_tfm)) {\n\t\trc = PTR_ERR(*key_tfm);\n\t\tprintk(KERN_ERR \"Unable to allocate crypto cipher with name \"\n\t\t       \"[%s]; rc = [%d]\\n\", full_alg_name, rc);\n\t\tgoto out;\n\t}\n\tcrypto_skcipher_set_flags(*key_tfm, CRYPTO_TFM_REQ_FORBID_WEAK_KEYS);\n\tif (*key_size == 0)\n\t\t*key_size = crypto_skcipher_max_keysize(*key_tfm);\n\tget_random_bytes(dummy_key, *key_size);\n\trc = crypto_skcipher_setkey(*key_tfm, dummy_key, *key_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to set key of size [%zd] for \"\n\t\t       \"cipher [%s]; rc = [%d]\\n\", *key_size, full_alg_name,\n\t\t       rc);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\tkfree(full_alg_name);\n\treturn rc;\n}\n\nstruct kmem_cache *ecryptfs_key_tfm_cache;\nstatic struct list_head key_tfm_list;\nDEFINE_MUTEX(key_tfm_list_mutex);\n\nint __init ecryptfs_init_crypto(void)\n{\n\tINIT_LIST_HEAD(&key_tfm_list);\n\treturn 0;\n}\n\n \nint ecryptfs_destroy_crypto(void)\n{\n\tstruct ecryptfs_key_tfm *key_tfm, *key_tfm_tmp;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tlist_for_each_entry_safe(key_tfm, key_tfm_tmp, &key_tfm_list,\n\t\t\t\t key_tfm_list) {\n\t\tlist_del(&key_tfm->key_tfm_list);\n\t\tcrypto_free_skcipher(key_tfm->key_tfm);\n\t\tkmem_cache_free(ecryptfs_key_tfm_cache, key_tfm);\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn 0;\n}\n\nint\necryptfs_add_new_key_tfm(struct ecryptfs_key_tfm **key_tfm, char *cipher_name,\n\t\t\t size_t key_size)\n{\n\tstruct ecryptfs_key_tfm *tmp_tfm;\n\tint rc = 0;\n\n\tBUG_ON(!mutex_is_locked(&key_tfm_list_mutex));\n\n\ttmp_tfm = kmem_cache_alloc(ecryptfs_key_tfm_cache, GFP_KERNEL);\n\tif (key_tfm)\n\t\t(*key_tfm) = tmp_tfm;\n\tif (!tmp_tfm) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmutex_init(&tmp_tfm->key_tfm_mutex);\n\tstrncpy(tmp_tfm->cipher_name, cipher_name,\n\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\ttmp_tfm->cipher_name[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\ttmp_tfm->key_size = key_size;\n\trc = ecryptfs_process_key_cipher(&tmp_tfm->key_tfm,\n\t\t\t\t\t tmp_tfm->cipher_name,\n\t\t\t\t\t &tmp_tfm->key_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to initialize key TFM \"\n\t\t       \"cipher with name = [%s]; rc = [%d]\\n\",\n\t\t       tmp_tfm->cipher_name, rc);\n\t\tkmem_cache_free(ecryptfs_key_tfm_cache, tmp_tfm);\n\t\tif (key_tfm)\n\t\t\t(*key_tfm) = NULL;\n\t\tgoto out;\n\t}\n\tlist_add(&tmp_tfm->key_tfm_list, &key_tfm_list);\nout:\n\treturn rc;\n}\n\n \nint ecryptfs_tfm_exists(char *cipher_name, struct ecryptfs_key_tfm **key_tfm)\n{\n\tstruct ecryptfs_key_tfm *tmp_key_tfm;\n\n\tBUG_ON(!mutex_is_locked(&key_tfm_list_mutex));\n\n\tlist_for_each_entry(tmp_key_tfm, &key_tfm_list, key_tfm_list) {\n\t\tif (strcmp(tmp_key_tfm->cipher_name, cipher_name) == 0) {\n\t\t\tif (key_tfm)\n\t\t\t\t(*key_tfm) = tmp_key_tfm;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (key_tfm)\n\t\t(*key_tfm) = NULL;\n\treturn 0;\n}\n\n \nint ecryptfs_get_tfm_and_mutex_for_cipher_name(struct crypto_skcipher **tfm,\n\t\t\t\t\t       struct mutex **tfm_mutex,\n\t\t\t\t\t       char *cipher_name)\n{\n\tstruct ecryptfs_key_tfm *key_tfm;\n\tint rc = 0;\n\n\t(*tfm) = NULL;\n\t(*tfm_mutex) = NULL;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(cipher_name, &key_tfm)) {\n\t\trc = ecryptfs_add_new_key_tfm(&key_tfm, cipher_name, 0);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error adding new key_tfm to list; \"\n\t\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t(*tfm) = key_tfm->key_tfm;\n\t(*tfm_mutex) = &key_tfm->key_tfm_mutex;\nout:\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn rc;\n}\n\n \nstatic unsigned char *portable_filename_chars = (\"-.0123456789ABCD\"\n\t\t\t\t\t\t \"EFGHIJKLMNOPQRST\"\n\t\t\t\t\t\t \"UVWXYZabcdefghij\"\n\t\t\t\t\t\t \"klmnopqrstuvwxyz\");\n\n \nstatic const unsigned char filename_rev_map[256] = {\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,  \n\t0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,  \n\t0x0A, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12,  \n\t0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A,  \n\t0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22,  \n\t0x23, 0x24, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C,  \n\t0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34,  \n\t0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C,  \n\t0x3D, 0x3E, 0x3F  \n};\n\n \nstatic void ecryptfs_encode_for_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t\t  unsigned char *src, size_t src_size)\n{\n\tsize_t num_blocks;\n\tsize_t block_num = 0;\n\tsize_t dst_offset = 0;\n\tunsigned char last_block[3];\n\n\tif (src_size == 0) {\n\t\t(*dst_size) = 0;\n\t\tgoto out;\n\t}\n\tnum_blocks = (src_size / 3);\n\tif ((src_size % 3) == 0) {\n\t\tmemcpy(last_block, (&src[src_size - 3]), 3);\n\t} else {\n\t\tnum_blocks++;\n\t\tlast_block[2] = 0x00;\n\t\tswitch (src_size % 3) {\n\t\tcase 1:\n\t\t\tlast_block[0] = src[src_size - 1];\n\t\t\tlast_block[1] = 0x00;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tlast_block[0] = src[src_size - 2];\n\t\t\tlast_block[1] = src[src_size - 1];\n\t\t}\n\t}\n\t(*dst_size) = (num_blocks * 4);\n\tif (!dst)\n\t\tgoto out;\n\twhile (block_num < num_blocks) {\n\t\tunsigned char *src_block;\n\t\tunsigned char dst_block[4];\n\n\t\tif (block_num == (num_blocks - 1))\n\t\t\tsrc_block = last_block;\n\t\telse\n\t\t\tsrc_block = &src[block_num * 3];\n\t\tdst_block[0] = ((src_block[0] >> 2) & 0x3F);\n\t\tdst_block[1] = (((src_block[0] << 4) & 0x30)\n\t\t\t\t| ((src_block[1] >> 4) & 0x0F));\n\t\tdst_block[2] = (((src_block[1] << 2) & 0x3C)\n\t\t\t\t| ((src_block[2] >> 6) & 0x03));\n\t\tdst_block[3] = (src_block[2] & 0x3F);\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[0]];\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[1]];\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[2]];\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[3]];\n\t\tblock_num++;\n\t}\nout:\n\treturn;\n}\n\nstatic size_t ecryptfs_max_decoded_size(size_t encoded_size)\n{\n\t \n\treturn ((encoded_size + 1) * 3) / 4;\n}\n\n \nstatic void\necryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\n\tif (!dst) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdst[dst_byte_offset++] |= (src_byte);\n\t\t\tcurrent_bit_offset = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}\n\n \nint ecryptfs_encrypt_and_encode_filename(\n\tchar **encoded_name,\n\tsize_t *encoded_name_size,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\tconst char *name, size_t name_size)\n{\n\tsize_t encoded_name_no_prefix_size;\n\tint rc = 0;\n\n\t(*encoded_name) = NULL;\n\t(*encoded_name_size) = 0;\n\tif (mount_crypt_stat && (mount_crypt_stat->flags\n\t\t\t\t     & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)) {\n\t\tstruct ecryptfs_filename *filename;\n\n\t\tfilename = kzalloc(sizeof(*filename), GFP_KERNEL);\n\t\tif (!filename) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfilename->filename = (char *)name;\n\t\tfilename->filename_size = name_size;\n\t\trc = ecryptfs_encrypt_filename(filename, mount_crypt_stat);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to encrypt \"\n\t\t\t       \"filename; rc = [%d]\\n\", __func__, rc);\n\t\t\tkfree(filename);\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_encode_for_filename(\n\t\t\tNULL, &encoded_name_no_prefix_size,\n\t\t\tfilename->encrypted_filename,\n\t\t\tfilename->encrypted_filename_size);\n\t\tif (mount_crypt_stat\n\t\t\t&& (mount_crypt_stat->flags\n\t\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK))\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\telse\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\t(*encoded_name) = kmalloc((*encoded_name_size) + 1, GFP_KERNEL);\n\t\tif (!(*encoded_name)) {\n\t\t\trc = -ENOMEM;\n\t\t\tkfree(filename->encrypted_filename);\n\t\t\tkfree(filename);\n\t\t\tgoto out;\n\t\t}\n\t\tif (mount_crypt_stat\n\t\t\t&& (mount_crypt_stat->flags\n\t\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)) {\n\t\t\tmemcpy((*encoded_name),\n\t\t\t       ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX,\n\t\t\t       ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE);\n\t\t\tecryptfs_encode_for_filename(\n\t\t\t    ((*encoded_name)\n\t\t\t     + ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE),\n\t\t\t    &encoded_name_no_prefix_size,\n\t\t\t    filename->encrypted_filename,\n\t\t\t    filename->encrypted_filename_size);\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\t\t(*encoded_name)[(*encoded_name_size)] = '\\0';\n\t\t} else {\n\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to encode \"\n\t\t\t       \"encrypted filename; rc = [%d]\\n\", __func__,\n\t\t\t       rc);\n\t\t\tkfree((*encoded_name));\n\t\t\t(*encoded_name) = NULL;\n\t\t\t(*encoded_name_size) = 0;\n\t\t}\n\t\tkfree(filename->encrypted_filename);\n\t\tkfree(filename);\n\t} else {\n\t\trc = ecryptfs_copy_filename(encoded_name,\n\t\t\t\t\t    encoded_name_size,\n\t\t\t\t\t    name, name_size);\n\t}\nout:\n\treturn rc;\n}\n\nstatic bool is_dot_dotdot(const char *name, size_t name_size)\n{\n\tif (name_size == 1 && name[0] == '.')\n\t\treturn true;\n\telse if (name_size == 2 && name[0] == '.' && name[1] == '.')\n\t\treturn true;\n\n\treturn false;\n}\n\n \nint ecryptfs_decode_and_decrypt_filename(char **plaintext_name,\n\t\t\t\t\t size_t *plaintext_name_size,\n\t\t\t\t\t struct super_block *sb,\n\t\t\t\t\t const char *name, size_t name_size)\n{\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(sb)->mount_crypt_stat;\n\tchar *decoded_name;\n\tsize_t decoded_name_size;\n\tsize_t packet_size;\n\tint rc = 0;\n\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) &&\n\t    !(mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)) {\n\t\tif (is_dot_dotdot(name, name_size)) {\n\t\t\trc = ecryptfs_copy_filename(plaintext_name,\n\t\t\t\t\t\t    plaintext_name_size,\n\t\t\t\t\t\t    name, name_size);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (name_size <= ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE ||\n\t\t    strncmp(name, ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX,\n\t\t\t    ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tname += ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\n\t\tname_size -= ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\n\t\tecryptfs_decode_from_filename(NULL, &decoded_name_size,\n\t\t\t\t\t      name, name_size);\n\t\tdecoded_name = kmalloc(decoded_name_size, GFP_KERNEL);\n\t\tif (!decoded_name) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_decode_from_filename(decoded_name, &decoded_name_size,\n\t\t\t\t\t      name, name_size);\n\t\trc = ecryptfs_parse_tag_70_packet(plaintext_name,\n\t\t\t\t\t\t  plaintext_name_size,\n\t\t\t\t\t\t  &packet_size,\n\t\t\t\t\t\t  mount_crypt_stat,\n\t\t\t\t\t\t  decoded_name,\n\t\t\t\t\t\t  decoded_name_size);\n\t\tif (rc) {\n\t\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\t\"%s: Could not parse tag 70 packet from filename\\n\",\n\t\t\t\t\t__func__);\n\t\t\tgoto out_free;\n\t\t}\n\t} else {\n\t\trc = ecryptfs_copy_filename(plaintext_name,\n\t\t\t\t\t    plaintext_name_size,\n\t\t\t\t\t    name, name_size);\n\t\tgoto out;\n\t}\nout_free:\n\tkfree(decoded_name);\nout:\n\treturn rc;\n}\n\n#define ENC_NAME_MAX_BLOCKLEN_8_OR_16\t143\n\nint ecryptfs_set_f_namelen(long *namelen, long lower_namelen,\n\t\t\t   struct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct crypto_skcipher *tfm;\n\tstruct mutex *tfm_mutex;\n\tsize_t cipher_blocksize;\n\tint rc;\n\n\tif (!(mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)) {\n\t\t(*namelen) = lower_namelen;\n\t\treturn 0;\n\t}\n\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&tfm, &tfm_mutex,\n\t\t\tmount_crypt_stat->global_default_fn_cipher_name);\n\tif (unlikely(rc)) {\n\t\t(*namelen) = 0;\n\t\treturn rc;\n\t}\n\n\tmutex_lock(tfm_mutex);\n\tcipher_blocksize = crypto_skcipher_blocksize(tfm);\n\tmutex_unlock(tfm_mutex);\n\n\t \n\tif (lower_namelen == NAME_MAX\n\t    && (cipher_blocksize == 8 || cipher_blocksize == 16)) {\n\t\t(*namelen) = ENC_NAME_MAX_BLOCKLEN_8_OR_16;\n\t\treturn 0;\n\t}\n\n\t \n\t(*namelen) = lower_namelen;\n\t(*namelen) -= ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\n\t \n\t(*namelen) = ecryptfs_max_decoded_size(*namelen) - 3;\n\t(*namelen) -= ECRYPTFS_TAG_70_MAX_METADATA_SIZE;\n\t(*namelen) -= ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES;\n\t \n\t(*namelen) -= cipher_blocksize - 1;\n\n\tif ((*namelen) < 0)\n\t\t(*namelen) = 0;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}