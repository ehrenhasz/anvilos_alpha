{
  "module_name": "main.c",
  "hash_id": "eef4b74759fda37adc2dc6d1a78641e8412454547e597bad29d3ad07c9d7d02e",
  "original_prompt": "Ingested from linux-6.6.14/fs/ecryptfs/main.c",
  "human_readable_source": "\n \n\n#include <linux/dcache.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/skbuff.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/key.h>\n#include <linux/parser.h>\n#include <linux/fs_stack.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include \"ecryptfs_kernel.h\"\n\n \nint ecryptfs_verbosity = 0;\n\nmodule_param(ecryptfs_verbosity, int, 0);\nMODULE_PARM_DESC(ecryptfs_verbosity,\n\t\t \"Initial verbosity level (0 or 1; defaults to \"\n\t\t \"0, which is Quiet)\");\n\n \nunsigned int ecryptfs_message_buf_len = ECRYPTFS_DEFAULT_MSG_CTX_ELEMS;\n\nmodule_param(ecryptfs_message_buf_len, uint, 0);\nMODULE_PARM_DESC(ecryptfs_message_buf_len,\n\t\t \"Number of message buffer elements\");\n\n \nsigned long ecryptfs_message_wait_timeout = ECRYPTFS_MAX_MSG_CTX_TTL / HZ;\n\nmodule_param(ecryptfs_message_wait_timeout, long, 0);\nMODULE_PARM_DESC(ecryptfs_message_wait_timeout,\n\t\t \"Maximum number of seconds that an operation will \"\n\t\t \"sleep while waiting for a message response from \"\n\t\t \"userspace\");\n\n \nunsigned int ecryptfs_number_of_users = ECRYPTFS_DEFAULT_NUM_USERS;\n\nmodule_param(ecryptfs_number_of_users, uint, 0);\nMODULE_PARM_DESC(ecryptfs_number_of_users, \"An estimate of the number of \"\n\t\t \"concurrent users of eCryptfs\");\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') {  \n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}\n\n \nstatic int ecryptfs_init_lower_file(struct dentry *dentry,\n\t\t\t\t    struct file **lower_file)\n{\n\tconst struct cred *cred = current_cred();\n\tconst struct path *path = ecryptfs_dentry_to_lower_path(dentry);\n\tint rc;\n\n\trc = ecryptfs_privileged_open(lower_file, path->dentry, path->mnt,\n\t\t\t\t      cred);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error opening lower file \"\n\t\t       \"for lower_dentry [0x%p] and lower_mnt [0x%p]; \"\n\t\t       \"rc = [%d]\\n\", path->dentry, path->mnt, rc);\n\t\t(*lower_file) = NULL;\n\t}\n\treturn rc;\n}\n\nint ecryptfs_get_lower_file(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\tint count, rc = 0;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tmutex_lock(&inode_info->lower_file_mutex);\n\tcount = atomic_inc_return(&inode_info->lower_file_count);\n\tif (WARN_ON_ONCE(count < 1))\n\t\trc = -EINVAL;\n\telse if (count == 1) {\n\t\trc = ecryptfs_init_lower_file(dentry,\n\t\t\t\t\t      &inode_info->lower_file);\n\t\tif (rc)\n\t\t\tatomic_set(&inode_info->lower_file_count, 0);\n\t}\n\tmutex_unlock(&inode_info->lower_file_mutex);\n\treturn rc;\n}\n\nvoid ecryptfs_put_lower_file(struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tif (atomic_dec_and_mutex_lock(&inode_info->lower_file_count,\n\t\t\t\t      &inode_info->lower_file_mutex)) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tfput(inode_info->lower_file);\n\t\tinode_info->lower_file = NULL;\n\t\tmutex_unlock(&inode_info->lower_file_mutex);\n\t}\n}\n\nenum { ecryptfs_opt_sig, ecryptfs_opt_ecryptfs_sig,\n       ecryptfs_opt_cipher, ecryptfs_opt_ecryptfs_cipher,\n       ecryptfs_opt_ecryptfs_key_bytes,\n       ecryptfs_opt_passthrough, ecryptfs_opt_xattr_metadata,\n       ecryptfs_opt_encrypted_view, ecryptfs_opt_fnek_sig,\n       ecryptfs_opt_fn_cipher, ecryptfs_opt_fn_cipher_key_bytes,\n       ecryptfs_opt_unlink_sigs, ecryptfs_opt_mount_auth_tok_only,\n       ecryptfs_opt_check_dev_ruid,\n       ecryptfs_opt_err };\n\nstatic const match_table_t tokens = {\n\t{ecryptfs_opt_sig, \"sig=%s\"},\n\t{ecryptfs_opt_ecryptfs_sig, \"ecryptfs_sig=%s\"},\n\t{ecryptfs_opt_cipher, \"cipher=%s\"},\n\t{ecryptfs_opt_ecryptfs_cipher, \"ecryptfs_cipher=%s\"},\n\t{ecryptfs_opt_ecryptfs_key_bytes, \"ecryptfs_key_bytes=%u\"},\n\t{ecryptfs_opt_passthrough, \"ecryptfs_passthrough\"},\n\t{ecryptfs_opt_xattr_metadata, \"ecryptfs_xattr_metadata\"},\n\t{ecryptfs_opt_encrypted_view, \"ecryptfs_encrypted_view\"},\n\t{ecryptfs_opt_fnek_sig, \"ecryptfs_fnek_sig=%s\"},\n\t{ecryptfs_opt_fn_cipher, \"ecryptfs_fn_cipher=%s\"},\n\t{ecryptfs_opt_fn_cipher_key_bytes, \"ecryptfs_fn_key_bytes=%u\"},\n\t{ecryptfs_opt_unlink_sigs, \"ecryptfs_unlink_sigs\"},\n\t{ecryptfs_opt_mount_auth_tok_only, \"ecryptfs_mount_auth_tok_only\"},\n\t{ecryptfs_opt_check_dev_ruid, \"ecryptfs_check_dev_ruid\"},\n\t{ecryptfs_opt_err, NULL}\n};\n\nstatic int ecryptfs_init_global_auth_toks(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *global_auth_tok;\n\tstruct ecryptfs_auth_tok *auth_tok;\n\tint rc = 0;\n\n\tlist_for_each_entry(global_auth_tok,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\trc = ecryptfs_keyring_auth_tok_for_sig(\n\t\t\t&global_auth_tok->global_auth_tok_key, &auth_tok,\n\t\t\tglobal_auth_tok->sig);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Could not find valid key in user \"\n\t\t\t       \"session keyring for sig specified in mount \"\n\t\t\t       \"option: [%s]\\n\", global_auth_tok->sig);\n\t\t\tglobal_auth_tok->flags |= ECRYPTFS_AUTH_TOK_INVALID;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tglobal_auth_tok->flags &= ~ECRYPTFS_AUTH_TOK_INVALID;\n\t\t\tup_write(&(global_auth_tok->global_auth_tok_key)->sem);\n\t\t}\n\t}\nout:\n\treturn rc;\n}\n\nstatic void ecryptfs_init_mount_crypt_stat(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tmemset((void *)mount_crypt_stat, 0,\n\t       sizeof(struct ecryptfs_mount_crypt_stat));\n\tINIT_LIST_HEAD(&mount_crypt_stat->global_auth_tok_list);\n\tmutex_init(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmount_crypt_stat->flags |= ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED;\n}\n\n \nstatic int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,\n\t\t\t\t  uid_t *check_ruid)\n{\n\tchar *p;\n\tint rc = 0;\n\tint sig_set = 0;\n\tint cipher_name_set = 0;\n\tint fn_cipher_name_set = 0;\n\tint cipher_key_bytes;\n\tint cipher_key_bytes_set = 0;\n\tint fn_cipher_key_bytes;\n\tint fn_cipher_key_bytes_set = 0;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&sbi->mount_crypt_stat;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\tchar *sig_src;\n\tchar *cipher_name_dst;\n\tchar *cipher_name_src;\n\tchar *fn_cipher_name_dst;\n\tchar *fn_cipher_name_src;\n\tchar *fnek_dst;\n\tchar *fnek_src;\n\tchar *cipher_key_bytes_src;\n\tchar *fn_cipher_key_bytes_src;\n\tu8 cipher_code;\n\n\t*check_ruid = 0;\n\n\tif (!options) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tecryptfs_init_mount_crypt_stat(mount_crypt_stat);\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase ecryptfs_opt_sig:\n\t\tcase ecryptfs_opt_ecryptfs_sig:\n\t\t\tsig_src = args[0].from;\n\t\t\trc = ecryptfs_add_global_auth_tok(mount_crypt_stat,\n\t\t\t\t\t\t\t  sig_src, 0);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global sig; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsig_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_cipher:\n\t\tcase ecryptfs_opt_ecryptfs_cipher:\n\t\t\tcipher_name_src = args[0].from;\n\t\t\tcipher_name_dst =\n\t\t\t\tmount_crypt_stat->\n\t\t\t\tglobal_default_cipher_name;\n\t\t\tstrncpy(cipher_name_dst, cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tcipher_name_dst[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tcipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_ecryptfs_key_bytes:\n\t\t\tcipher_key_bytes_src = args[0].from;\n\t\t\tcipher_key_bytes =\n\t\t\t\t(int)simple_strtol(cipher_key_bytes_src,\n\t\t\t\t\t\t   &cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_cipher_key_size =\n\t\t\t\tcipher_key_bytes;\n\t\t\tcipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_passthrough:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_xattr_metadata:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_encrypted_view:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_ENCRYPTED_VIEW_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fnek_sig:\n\t\t\tfnek_src = args[0].from;\n\t\t\tfnek_dst =\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig;\n\t\t\tstrncpy(fnek_dst, fnek_src, ECRYPTFS_SIG_SIZE_HEX);\n\t\t\tmount_crypt_stat->global_default_fnek_sig[\n\t\t\t\tECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t\t\trc = ecryptfs_add_global_auth_tok(\n\t\t\t\tmount_crypt_stat,\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig,\n\t\t\t\tECRYPTFS_AUTH_TOK_FNEK);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global fnek sig [%s]; rc = [%d]\\n\",\n\t\t\t\t       mount_crypt_stat->global_default_fnek_sig,\n\t\t\t\t       rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\t(ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES\n\t\t\t\t | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK);\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher:\n\t\t\tfn_cipher_name_src = args[0].from;\n\t\t\tfn_cipher_name_dst =\n\t\t\t\tmount_crypt_stat->global_default_fn_cipher_name;\n\t\t\tstrncpy(fn_cipher_name_dst, fn_cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_name[\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tfn_cipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher_key_bytes:\n\t\t\tfn_cipher_key_bytes_src = args[0].from;\n\t\t\tfn_cipher_key_bytes =\n\t\t\t\t(int)simple_strtol(fn_cipher_key_bytes_src,\n\t\t\t\t\t\t   &fn_cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\t\tfn_cipher_key_bytes;\n\t\t\tfn_cipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_unlink_sigs:\n\t\t\tmount_crypt_stat->flags |= ECRYPTFS_UNLINK_SIGS;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_mount_auth_tok_only:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_check_dev_ruid:\n\t\t\t*check_ruid = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_err:\n\t\tdefault:\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: eCryptfs: unrecognized option [%s]\\n\",\n\t\t\t       __func__, p);\n\t\t}\n\t}\n\tif (!sig_set) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_ERR, \"You must supply at least one valid \"\n\t\t\t\t\"auth tok signature as a mount \"\n\t\t\t\t\"parameter; see the eCryptfs README\\n\");\n\t\tgoto out;\n\t}\n\tif (!cipher_name_set) {\n\t\tint cipher_name_len = strlen(ECRYPTFS_DEFAULT_CIPHER);\n\n\t\tBUG_ON(cipher_name_len > ECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\tstrcpy(mount_crypt_stat->global_default_cipher_name,\n\t\t       ECRYPTFS_DEFAULT_CIPHER);\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_name_set)\n\t\tstrcpy(mount_crypt_stat->global_default_fn_cipher_name,\n\t\t       mount_crypt_stat->global_default_cipher_name);\n\tif (!cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_cipher_key_size = 0;\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\tmount_crypt_stat->global_default_cipher_key_size;\n\n\tcipher_code = ecryptfs_code_for_cipher_string(\n\t\tmount_crypt_stat->global_default_cipher_name,\n\t\tmount_crypt_stat->global_default_cipher_key_size);\n\tif (!cipher_code) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\"eCryptfs doesn't support cipher: %s\\n\",\n\t\t\t\tmount_crypt_stat->global_default_cipher_name);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(mount_crypt_stat->global_default_cipher_name,\n\t\t\t\t NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_cipher_name,\n\t\t\tmount_crypt_stat->global_default_cipher_key_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_cipher_key_size,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !ecryptfs_tfm_exists(\n\t\t    mount_crypt_stat->global_default_fn_cipher_name, NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\trc = ecryptfs_init_global_auth_toks(mount_crypt_stat);\n\tif (rc)\n\t\tprintk(KERN_WARNING \"One or more global auth toks could not \"\n\t\t       \"properly register; rc = [%d]\\n\", rc);\nout:\n\treturn rc;\n}\n\nstruct kmem_cache *ecryptfs_sb_info_cache;\nstatic struct file_system_type ecryptfs_fs_type;\n\n \nstatic struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,\n\t\t\tconst char *dev_name, void *raw_data)\n{\n\tstruct super_block *s;\n\tstruct ecryptfs_sb_info *sbi;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tstruct ecryptfs_dentry_info *root_info;\n\tconst char *err = \"Getting sb failed\";\n\tstruct inode *inode;\n\tstruct path path;\n\tuid_t check_ruid;\n\tint rc;\n\n\tsbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);\n\tif (!sbi) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (!dev_name) {\n\t\trc = -EINVAL;\n\t\terr = \"Device name cannot be null\";\n\t\tgoto out;\n\t}\n\n\trc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);\n\tif (rc) {\n\t\terr = \"Error parsing options\";\n\t\tgoto out;\n\t}\n\tmount_crypt_stat = &sbi->mount_crypt_stat;\n\n\ts = sget(fs_type, NULL, set_anon_super, flags, NULL);\n\tif (IS_ERR(s)) {\n\t\trc = PTR_ERR(s);\n\t\tgoto out;\n\t}\n\n\trc = super_setup_bdi(s);\n\tif (rc)\n\t\tgoto out1;\n\n\tecryptfs_set_superblock_private(s, sbi);\n\n\t \n\tsbi = NULL;\n\ts->s_op = &ecryptfs_sops;\n\ts->s_xattr = ecryptfs_xattr_handlers;\n\ts->s_d_op = &ecryptfs_dops;\n\n\terr = \"Reading sb failed\";\n\trc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"kern_path() failed\\n\");\n\t\tgoto out1;\n\t}\n\tif (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"Mount on filesystem of type \"\n\t\t\t\"eCryptfs explicitly disallowed due to \"\n\t\t\t\"known incompatibilities\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (is_idmapped_mnt(path.mnt)) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"Mounting on idmapped mounts currently disallowed\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (check_ruid && !uid_eq(d_inode(path.dentry)->i_uid, current_uid())) {\n\t\trc = -EPERM;\n\t\tprintk(KERN_ERR \"Mount of device (uid: %d) not owned by \"\n\t\t       \"requested user (uid: %d)\\n\",\n\t\t\ti_uid_read(d_inode(path.dentry)),\n\t\t\tfrom_kuid(&init_user_ns, current_uid()));\n\t\tgoto out_free;\n\t}\n\n\tecryptfs_set_superblock_lower(s, path.dentry->d_sb);\n\n\t \n\ts->s_flags = flags & ~SB_POSIXACL;\n\ts->s_flags |= path.dentry->d_sb->s_flags & SB_POSIXACL;\n\n\t \n\tif (sb_rdonly(path.dentry->d_sb) || mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\n\t\ts->s_flags |= SB_RDONLY;\n\n\ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n\ts->s_blocksize = path.dentry->d_sb->s_blocksize;\n\ts->s_magic = ECRYPTFS_SUPER_MAGIC;\n\ts->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;\n\n\trc = -EINVAL;\n\tif (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n\t\tpr_err(\"eCryptfs: maximum fs stacking depth exceeded\\n\");\n\t\tgoto out_free;\n\t}\n\n\tinode = ecryptfs_get_inode(d_inode(path.dentry), s);\n\trc = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_free;\n\n\ts->s_root = d_make_root(inode);\n\tif (!s->s_root) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\trc = -ENOMEM;\n\troot_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);\n\tif (!root_info)\n\t\tgoto out_free;\n\n\t \n\tecryptfs_set_dentry_private(s->s_root, root_info);\n\troot_info->lower_path = path;\n\n\ts->s_flags |= SB_ACTIVE;\n\treturn dget(s->s_root);\n\nout_free:\n\tpath_put(&path);\nout1:\n\tdeactivate_locked_super(s);\nout:\n\tif (sbi) {\n\t\tecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);\n\t\tkmem_cache_free(ecryptfs_sb_info_cache, sbi);\n\t}\n\tprintk(KERN_ERR \"%s; rc = [%d]\\n\", err, rc);\n\treturn ERR_PTR(rc);\n}\n\n \nstatic void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}\n\nstatic struct file_system_type ecryptfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"ecryptfs\",\n\t.mount = ecryptfs_mount,\n\t.kill_sb = ecryptfs_kill_block_super,\n\t.fs_flags = 0\n};\nMODULE_ALIAS_FS(\"ecryptfs\");\n\n \nstatic void\ninode_info_init_once(void *vptr)\n{\n\tstruct ecryptfs_inode_info *ei = (struct ecryptfs_inode_info *)vptr;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic struct ecryptfs_cache_info {\n\tstruct kmem_cache **cache;\n\tconst char *name;\n\tsize_t size;\n\tslab_flags_t flags;\n\tvoid (*ctor)(void *obj);\n} ecryptfs_cache_infos[] = {\n\t{\n\t\t.cache = &ecryptfs_auth_tok_list_item_cache,\n\t\t.name = \"ecryptfs_auth_tok_list_item\",\n\t\t.size = sizeof(struct ecryptfs_auth_tok_list_item),\n\t},\n\t{\n\t\t.cache = &ecryptfs_file_info_cache,\n\t\t.name = \"ecryptfs_file_cache\",\n\t\t.size = sizeof(struct ecryptfs_file_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_dentry_info_cache,\n\t\t.name = \"ecryptfs_dentry_info_cache\",\n\t\t.size = sizeof(struct ecryptfs_dentry_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_inode_info_cache,\n\t\t.name = \"ecryptfs_inode_cache\",\n\t\t.size = sizeof(struct ecryptfs_inode_info),\n\t\t.flags = SLAB_ACCOUNT,\n\t\t.ctor = inode_info_init_once,\n\t},\n\t{\n\t\t.cache = &ecryptfs_sb_info_cache,\n\t\t.name = \"ecryptfs_sb_cache\",\n\t\t.size = sizeof(struct ecryptfs_sb_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_header_cache,\n\t\t.name = \"ecryptfs_headers\",\n\t\t.size = PAGE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_xattr_cache,\n\t\t.name = \"ecryptfs_xattr_cache\",\n\t\t.size = PAGE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_record_cache,\n\t\t.name = \"ecryptfs_key_record_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_record),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_sig_cache,\n\t\t.name = \"ecryptfs_key_sig_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_sig),\n\t},\n\t{\n\t\t.cache = &ecryptfs_global_auth_tok_cache,\n\t\t.name = \"ecryptfs_global_auth_tok_cache\",\n\t\t.size = sizeof(struct ecryptfs_global_auth_tok),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_tfm_cache,\n\t\t.name = \"ecryptfs_key_tfm_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_tfm),\n\t},\n};\n\nstatic void ecryptfs_free_kmem_caches(void)\n{\n\tint i;\n\n\t \n\trcu_barrier();\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\tkmem_cache_destroy(*(info->cache));\n\t}\n}\n\n \nstatic int ecryptfs_init_kmem_caches(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\t*(info->cache) = kmem_cache_create(info->name, info->size, 0,\n\t\t\t\tSLAB_HWCACHE_ALIGN | info->flags, info->ctor);\n\t\tif (!*(info->cache)) {\n\t\t\tecryptfs_free_kmem_caches();\n\t\t\tecryptfs_printk(KERN_WARNING, \"%s: \"\n\t\t\t\t\t\"kmem_cache_create failed\\n\",\n\t\t\t\t\tinfo->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic struct kobject *ecryptfs_kobj;\n\nstatic ssize_t version_show(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr, char *buff)\n{\n\treturn snprintf(buff, PAGE_SIZE, \"%d\\n\", ECRYPTFS_VERSIONING_MASK);\n}\n\nstatic struct kobj_attribute version_attr = __ATTR_RO(version);\n\nstatic struct attribute *attributes[] = {\n\t&version_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group attr_group = {\n\t.attrs = attributes,\n};\n\nstatic int do_sysfs_registration(void)\n{\n\tint rc;\n\n\tecryptfs_kobj = kobject_create_and_add(\"ecryptfs\", fs_kobj);\n\tif (!ecryptfs_kobj) {\n\t\tprintk(KERN_ERR \"Unable to create ecryptfs kset\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\trc = sysfs_create_group(ecryptfs_kobj, &attr_group);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"Unable to create ecryptfs version attributes\\n\");\n\t\tkobject_put(ecryptfs_kobj);\n\t}\nout:\n\treturn rc;\n}\n\nstatic void do_sysfs_unregistration(void)\n{\n\tsysfs_remove_group(ecryptfs_kobj, &attr_group);\n\tkobject_put(ecryptfs_kobj);\n}\n\nstatic int __init ecryptfs_init(void)\n{\n\tint rc;\n\n\tif (ECRYPTFS_DEFAULT_EXTENT_SIZE > PAGE_SIZE) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_ERR, \"The eCryptfs extent size is \"\n\t\t\t\t\"larger than the host's page size, and so \"\n\t\t\t\t\"eCryptfs cannot run on this system. The \"\n\t\t\t\t\"default eCryptfs extent size is [%u] bytes; \"\n\t\t\t\t\"the page size is [%lu] bytes.\\n\",\n\t\t\t\tECRYPTFS_DEFAULT_EXTENT_SIZE,\n\t\t\t\t(unsigned long)PAGE_SIZE);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_init_kmem_caches();\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"Failed to allocate one or more kmem_cache objects\\n\");\n\t\tgoto out;\n\t}\n\trc = do_sysfs_registration();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"sysfs registration failed\\n\");\n\t\tgoto out_free_kmem_caches;\n\t}\n\trc = ecryptfs_init_kthread();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: kthread initialization failed; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_do_sysfs_unregistration;\n\t}\n\trc = ecryptfs_init_messaging();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failure occurred while attempting to \"\n\t\t\t\t\"initialize the communications channel to \"\n\t\t\t\t\"ecryptfsd\\n\");\n\t\tgoto out_destroy_kthread;\n\t}\n\trc = ecryptfs_init_crypto();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failure whilst attempting to init crypto; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\t\tgoto out_release_messaging;\n\t}\n\trc = register_filesystem(&ecryptfs_fs_type);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to register filesystem\\n\");\n\t\tgoto out_destroy_crypto;\n\t}\n\tif (ecryptfs_verbosity > 0)\n\t\tprintk(KERN_CRIT \"eCryptfs verbosity set to %d. Secret values \"\n\t\t\t\"will be written to the syslog!\\n\", ecryptfs_verbosity);\n\n\tgoto out;\nout_destroy_crypto:\n\tecryptfs_destroy_crypto();\nout_release_messaging:\n\tecryptfs_release_messaging();\nout_destroy_kthread:\n\tecryptfs_destroy_kthread();\nout_do_sysfs_unregistration:\n\tdo_sysfs_unregistration();\nout_free_kmem_caches:\n\tecryptfs_free_kmem_caches();\nout:\n\treturn rc;\n}\n\nstatic void __exit ecryptfs_exit(void)\n{\n\tint rc;\n\n\trc = ecryptfs_destroy_crypto();\n\tif (rc)\n\t\tprintk(KERN_ERR \"Failure whilst attempting to destroy crypto; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\tecryptfs_release_messaging();\n\tecryptfs_destroy_kthread();\n\tdo_sysfs_unregistration();\n\tunregister_filesystem(&ecryptfs_fs_type);\n\tecryptfs_free_kmem_caches();\n}\n\nMODULE_AUTHOR(\"Michael A. Halcrow <mhalcrow@us.ibm.com>\");\nMODULE_DESCRIPTION(\"eCryptfs\");\n\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(ecryptfs_init)\nmodule_exit(ecryptfs_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}