{
  "module_name": "messaging.c",
  "hash_id": "c147077971c55d538409c867cbdd49b96675ec13cfb503f1555959a8a70fe592",
  "original_prompt": "Ingested from linux-6.6.14/fs/ecryptfs/messaging.c",
  "human_readable_source": "\n \n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include \"ecryptfs_kernel.h\"\n\nstatic LIST_HEAD(ecryptfs_msg_ctx_free_list);\nstatic LIST_HEAD(ecryptfs_msg_ctx_alloc_list);\nstatic DEFINE_MUTEX(ecryptfs_msg_ctx_lists_mux);\n\nstatic struct hlist_head *ecryptfs_daemon_hash;\nDEFINE_MUTEX(ecryptfs_daemon_hash_mux);\nstatic int ecryptfs_hash_bits;\n#define ecryptfs_current_euid_hash(uid) \\\n\thash_long((unsigned long)from_kuid(&init_user_ns, current_euid()), ecryptfs_hash_bits)\n\nstatic u32 ecryptfs_msg_counter;\nstatic struct ecryptfs_msg_ctx *ecryptfs_msg_ctx_arr;\n\n \nstatic int ecryptfs_acquire_free_msg_ctx(struct ecryptfs_msg_ctx **msg_ctx)\n{\n\tstruct list_head *p;\n\tint rc;\n\n\tif (list_empty(&ecryptfs_msg_ctx_free_list)) {\n\t\tprintk(KERN_WARNING \"%s: The eCryptfs free \"\n\t\t       \"context list is empty.  It may be helpful to \"\n\t\t       \"specify the ecryptfs_message_buf_len \"\n\t\t       \"parameter to be greater than the current \"\n\t\t       \"value of [%d]\\n\", __func__, ecryptfs_message_buf_len);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tlist_for_each(p, &ecryptfs_msg_ctx_free_list) {\n\t\t*msg_ctx = list_entry(p, struct ecryptfs_msg_ctx, node);\n\t\tif (mutex_trylock(&(*msg_ctx)->mux)) {\n\t\t\t(*msg_ctx)->task = current;\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = -ENOMEM;\nout:\n\treturn rc;\n}\n\n \nstatic void ecryptfs_msg_ctx_free_to_alloc(struct ecryptfs_msg_ctx *msg_ctx)\n{\n\tlist_move(&msg_ctx->node, &ecryptfs_msg_ctx_alloc_list);\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_PENDING;\n\tmsg_ctx->counter = ++ecryptfs_msg_counter;\n}\n\n \nvoid ecryptfs_msg_ctx_alloc_to_free(struct ecryptfs_msg_ctx *msg_ctx)\n{\n\tlist_move(&(msg_ctx->node), &ecryptfs_msg_ctx_free_list);\n\tkfree(msg_ctx->msg);\n\tmsg_ctx->msg = NULL;\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_FREE;\n}\n\n \nint ecryptfs_find_daemon_by_euid(struct ecryptfs_daemon **daemon)\n{\n\tint rc;\n\n\thlist_for_each_entry(*daemon,\n\t\t\t    &ecryptfs_daemon_hash[ecryptfs_current_euid_hash()],\n\t\t\t    euid_chain) {\n\t\tif (uid_eq((*daemon)->file->f_cred->euid, current_euid())) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = -EINVAL;\nout:\n\treturn rc;\n}\n\n \nint\necryptfs_spawn_daemon(struct ecryptfs_daemon **daemon, struct file *file)\n{\n\tint rc = 0;\n\n\t(*daemon) = kzalloc(sizeof(**daemon), GFP_KERNEL);\n\tif (!(*daemon)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*daemon)->file = file;\n\tmutex_init(&(*daemon)->mux);\n\tINIT_LIST_HEAD(&(*daemon)->msg_ctx_out_queue);\n\tinit_waitqueue_head(&(*daemon)->wait);\n\t(*daemon)->num_queued_msg_ctx = 0;\n\thlist_add_head(&(*daemon)->euid_chain,\n\t\t       &ecryptfs_daemon_hash[ecryptfs_current_euid_hash()]);\nout:\n\treturn rc;\n}\n\n \nint ecryptfs_exorcise_daemon(struct ecryptfs_daemon *daemon)\n{\n\tstruct ecryptfs_msg_ctx *msg_ctx, *msg_ctx_tmp;\n\tint rc = 0;\n\n\tmutex_lock(&daemon->mux);\n\tif ((daemon->flags & ECRYPTFS_DAEMON_IN_READ)\n\t    || (daemon->flags & ECRYPTFS_DAEMON_IN_POLL)) {\n\t\trc = -EBUSY;\n\t\tmutex_unlock(&daemon->mux);\n\t\tgoto out;\n\t}\n\tlist_for_each_entry_safe(msg_ctx, msg_ctx_tmp,\n\t\t\t\t &daemon->msg_ctx_out_queue, daemon_out_list) {\n\t\tlist_del(&msg_ctx->daemon_out_list);\n\t\tdaemon->num_queued_msg_ctx--;\n\t\tprintk(KERN_WARNING \"%s: Warning: dropping message that is in \"\n\t\t       \"the out queue of a dying daemon\\n\", __func__);\n\t\tecryptfs_msg_ctx_alloc_to_free(msg_ctx);\n\t}\n\thlist_del(&daemon->euid_chain);\n\tmutex_unlock(&daemon->mux);\n\tkfree_sensitive(daemon);\nout:\n\treturn rc;\n}\n\n \nint ecryptfs_process_response(struct ecryptfs_daemon *daemon,\n\t\t\t      struct ecryptfs_message *msg, u32 seq)\n{\n\tstruct ecryptfs_msg_ctx *msg_ctx;\n\tsize_t msg_size;\n\tint rc;\n\n\tif (msg->index >= ecryptfs_message_buf_len) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"%s: Attempt to reference \"\n\t\t       \"context buffer at index [%d]; maximum \"\n\t\t       \"allowable is [%d]\\n\", __func__, msg->index,\n\t\t       (ecryptfs_message_buf_len - 1));\n\t\tgoto out;\n\t}\n\tmsg_ctx = &ecryptfs_msg_ctx_arr[msg->index];\n\tmutex_lock(&msg_ctx->mux);\n\tif (msg_ctx->state != ECRYPTFS_MSG_CTX_STATE_PENDING) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_WARNING \"%s: Desired context element is not \"\n\t\t       \"pending a response\\n\", __func__);\n\t\tgoto unlock;\n\t} else if (msg_ctx->counter != seq) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_WARNING \"%s: Invalid message sequence; \"\n\t\t       \"expected [%d]; received [%d]\\n\", __func__,\n\t\t       msg_ctx->counter, seq);\n\t\tgoto unlock;\n\t}\n\tmsg_size = (sizeof(*msg) + msg->data_len);\n\tmsg_ctx->msg = kmemdup(msg, msg_size, GFP_KERNEL);\n\tif (!msg_ctx->msg) {\n\t\trc = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_DONE;\n\twake_up_process(msg_ctx->task);\n\trc = 0;\nunlock:\n\tmutex_unlock(&msg_ctx->mux);\nout:\n\treturn rc;\n}\n\n \nstatic int\necryptfs_send_message_locked(char *data, int data_len, u8 msg_type,\n\t\t\t     struct ecryptfs_msg_ctx **msg_ctx)\n{\n\tstruct ecryptfs_daemon *daemon;\n\tint rc;\n\n\trc = ecryptfs_find_daemon_by_euid(&daemon);\n\tif (rc) {\n\t\trc = -ENOTCONN;\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_msg_ctx_lists_mux);\n\trc = ecryptfs_acquire_free_msg_ctx(msg_ctx);\n\tif (rc) {\n\t\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\t\tprintk(KERN_WARNING \"%s: Could not claim a free \"\n\t\t       \"context element\\n\", __func__);\n\t\tgoto out;\n\t}\n\tecryptfs_msg_ctx_free_to_alloc(*msg_ctx);\n\tmutex_unlock(&(*msg_ctx)->mux);\n\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\trc = ecryptfs_send_miscdev(data, data_len, *msg_ctx, msg_type, 0,\n\t\t\t\t   daemon);\n\tif (rc)\n\t\tprintk(KERN_ERR \"%s: Error attempting to send message to \"\n\t\t       \"userspace daemon; rc = [%d]\\n\", __func__, rc);\nout:\n\treturn rc;\n}\n\n \nint ecryptfs_send_message(char *data, int data_len,\n\t\t\t  struct ecryptfs_msg_ctx **msg_ctx)\n{\n\tint rc;\n\n\tmutex_lock(&ecryptfs_daemon_hash_mux);\n\trc = ecryptfs_send_message_locked(data, data_len, ECRYPTFS_MSG_REQUEST,\n\t\t\t\t\t  msg_ctx);\n\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\treturn rc;\n}\n\n \nint ecryptfs_wait_for_response(struct ecryptfs_msg_ctx *msg_ctx,\n\t\t\t       struct ecryptfs_message **msg)\n{\n\tsigned long timeout = ecryptfs_message_wait_timeout * HZ;\n\tint rc = 0;\n\nsleep:\n\ttimeout = schedule_timeout_interruptible(timeout);\n\tmutex_lock(&ecryptfs_msg_ctx_lists_mux);\n\tmutex_lock(&msg_ctx->mux);\n\tif (msg_ctx->state != ECRYPTFS_MSG_CTX_STATE_DONE) {\n\t\tif (timeout) {\n\t\t\tmutex_unlock(&msg_ctx->mux);\n\t\t\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\t\t\tgoto sleep;\n\t\t}\n\t\trc = -ENOMSG;\n\t} else {\n\t\t*msg = msg_ctx->msg;\n\t\tmsg_ctx->msg = NULL;\n\t}\n\tecryptfs_msg_ctx_alloc_to_free(msg_ctx);\n\tmutex_unlock(&msg_ctx->mux);\n\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\treturn rc;\n}\n\nint __init ecryptfs_init_messaging(void)\n{\n\tint i;\n\tint rc = 0;\n\n\tif (ecryptfs_number_of_users > ECRYPTFS_MAX_NUM_USERS) {\n\t\tecryptfs_number_of_users = ECRYPTFS_MAX_NUM_USERS;\n\t\tprintk(KERN_WARNING \"%s: Specified number of users is \"\n\t\t       \"too large, defaulting to [%d] users\\n\", __func__,\n\t\t       ecryptfs_number_of_users);\n\t}\n\tmutex_lock(&ecryptfs_daemon_hash_mux);\n\tecryptfs_hash_bits = 1;\n\twhile (ecryptfs_number_of_users >> ecryptfs_hash_bits)\n\t\tecryptfs_hash_bits++;\n\tecryptfs_daemon_hash = kmalloc((sizeof(struct hlist_head)\n\t\t\t\t\t* (1 << ecryptfs_hash_bits)),\n\t\t\t\t       GFP_KERNEL);\n\tif (!ecryptfs_daemon_hash) {\n\t\trc = -ENOMEM;\n\t\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < (1 << ecryptfs_hash_bits); i++)\n\t\tINIT_HLIST_HEAD(&ecryptfs_daemon_hash[i]);\n\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\tecryptfs_msg_ctx_arr = kmalloc((sizeof(struct ecryptfs_msg_ctx)\n\t\t\t\t\t* ecryptfs_message_buf_len),\n\t\t\t\t       GFP_KERNEL);\n\tif (!ecryptfs_msg_ctx_arr) {\n\t\tkfree(ecryptfs_daemon_hash);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_msg_ctx_lists_mux);\n\tecryptfs_msg_counter = 0;\n\tfor (i = 0; i < ecryptfs_message_buf_len; i++) {\n\t\tINIT_LIST_HEAD(&ecryptfs_msg_ctx_arr[i].node);\n\t\tINIT_LIST_HEAD(&ecryptfs_msg_ctx_arr[i].daemon_out_list);\n\t\tmutex_init(&ecryptfs_msg_ctx_arr[i].mux);\n\t\tmutex_lock(&ecryptfs_msg_ctx_arr[i].mux);\n\t\tecryptfs_msg_ctx_arr[i].index = i;\n\t\tecryptfs_msg_ctx_arr[i].state = ECRYPTFS_MSG_CTX_STATE_FREE;\n\t\tecryptfs_msg_ctx_arr[i].counter = 0;\n\t\tecryptfs_msg_ctx_arr[i].task = NULL;\n\t\tecryptfs_msg_ctx_arr[i].msg = NULL;\n\t\tlist_add_tail(&ecryptfs_msg_ctx_arr[i].node,\n\t\t\t      &ecryptfs_msg_ctx_free_list);\n\t\tmutex_unlock(&ecryptfs_msg_ctx_arr[i].mux);\n\t}\n\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\trc = ecryptfs_init_ecryptfs_miscdev();\n\tif (rc)\n\t\tecryptfs_release_messaging();\nout:\n\treturn rc;\n}\n\nvoid ecryptfs_release_messaging(void)\n{\n\tif (ecryptfs_msg_ctx_arr) {\n\t\tint i;\n\n\t\tmutex_lock(&ecryptfs_msg_ctx_lists_mux);\n\t\tfor (i = 0; i < ecryptfs_message_buf_len; i++) {\n\t\t\tmutex_lock(&ecryptfs_msg_ctx_arr[i].mux);\n\t\t\tkfree(ecryptfs_msg_ctx_arr[i].msg);\n\t\t\tmutex_unlock(&ecryptfs_msg_ctx_arr[i].mux);\n\t\t}\n\t\tkfree(ecryptfs_msg_ctx_arr);\n\t\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\t}\n\tif (ecryptfs_daemon_hash) {\n\t\tstruct ecryptfs_daemon *daemon;\n\t\tstruct hlist_node *n;\n\t\tint i;\n\n\t\tmutex_lock(&ecryptfs_daemon_hash_mux);\n\t\tfor (i = 0; i < (1 << ecryptfs_hash_bits); i++) {\n\t\t\tint rc;\n\n\t\t\thlist_for_each_entry_safe(daemon, n,\n\t\t\t\t\t\t  &ecryptfs_daemon_hash[i],\n\t\t\t\t\t\t  euid_chain) {\n\t\t\t\trc = ecryptfs_exorcise_daemon(daemon);\n\t\t\t\tif (rc)\n\t\t\t\t\tprintk(KERN_ERR \"%s: Error whilst \"\n\t\t\t\t\t       \"attempting to destroy daemon; \"\n\t\t\t\t\t       \"rc = [%d]. Dazed and confused, \"\n\t\t\t\t\t       \"but trying to continue.\\n\",\n\t\t\t\t\t       __func__, rc);\n\t\t\t}\n\t\t}\n\t\tkfree(ecryptfs_daemon_hash);\n\t\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\t}\n\tecryptfs_destroy_ecryptfs_miscdev();\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}