{
  "module_name": "read_write.c",
  "hash_id": "462a11263ad84fdec164c9854807989b4d70c374c2cec21c1abf5f5a98e3256e",
  "original_prompt": "Ingested from linux-6.6.14/fs/ecryptfs/read_write.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/sched/signal.h>\n\n#include \"ecryptfs_kernel.h\"\n\n \nint ecryptfs_write_lower(struct inode *ecryptfs_inode, char *data,\n\t\t\t loff_t offset, size_t size)\n{\n\tstruct file *lower_file;\n\tssize_t rc;\n\n\tlower_file = ecryptfs_inode_to_private(ecryptfs_inode)->lower_file;\n\tif (!lower_file)\n\t\treturn -EIO;\n\trc = kernel_write(lower_file, data, size, &offset);\n\tmark_inode_dirty_sync(ecryptfs_inode);\n\treturn rc;\n}\n\n \nint ecryptfs_write_lower_page_segment(struct inode *ecryptfs_inode,\n\t\t\t\t      struct page *page_for_lower,\n\t\t\t\t      size_t offset_in_page, size_t size)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_for_lower->index) << PAGE_SHIFT)\n\t\t  + offset_in_page);\n\tvirt = kmap_local_page(page_for_lower);\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt, offset, size);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap_local(virt);\n\treturn rc;\n}\n\n \nint ecryptfs_write(struct inode *ecryptfs_inode, char *data, loff_t offset,\n\t\t   size_t size)\n{\n\tstruct page *ecryptfs_page;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *ecryptfs_page_virt;\n\tloff_t ecryptfs_file_size = i_size_read(ecryptfs_inode);\n\tloff_t data_offset = 0;\n\tloff_t pos;\n\tint rc = 0;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\t \n\tif (offset > ecryptfs_file_size)\n\t\tpos = ecryptfs_file_size;\n\telse\n\t\tpos = offset;\n\twhile (pos < (offset + size)) {\n\t\tpgoff_t ecryptfs_page_idx = (pos >> PAGE_SHIFT);\n\t\tsize_t start_offset_in_page = (pos & ~PAGE_MASK);\n\t\tsize_t num_bytes = (PAGE_SIZE - start_offset_in_page);\n\t\tloff_t total_remaining_bytes = ((offset + size) - pos);\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\trc = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (num_bytes > total_remaining_bytes)\n\t\t\tnum_bytes = total_remaining_bytes;\n\t\tif (pos < offset) {\n\t\t\t \n\t\t\tloff_t total_remaining_zeros = (offset - pos);\n\n\t\t\tif (num_bytes > total_remaining_zeros)\n\t\t\t\tnum_bytes = total_remaining_zeros;\n\t\t}\n\t\tecryptfs_page = ecryptfs_get_locked_page(ecryptfs_inode,\n\t\t\t\t\t\t\t ecryptfs_page_idx);\n\t\tif (IS_ERR(ecryptfs_page)) {\n\t\t\trc = PTR_ERR(ecryptfs_page);\n\t\t\tprintk(KERN_ERR \"%s: Error getting page at \"\n\t\t\t       \"index [%ld] from eCryptfs inode \"\n\t\t\t       \"mapping; rc = [%d]\\n\", __func__,\n\t\t\t       ecryptfs_page_idx, rc);\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_page_virt = kmap_local_page(ecryptfs_page);\n\n\t\t \n\t\tif (pos < offset || !start_offset_in_page) {\n\t\t\t \n\t\t\tmemset(((char *)ecryptfs_page_virt\n\t\t\t\t+ start_offset_in_page), 0,\n\t\t\t\tPAGE_SIZE - start_offset_in_page);\n\t\t}\n\n\t\t \n\t\tif (pos >= offset) {\n\t\t\tmemcpy(((char *)ecryptfs_page_virt\n\t\t\t\t+ start_offset_in_page),\n\t\t\t       (data + data_offset), num_bytes);\n\t\t\tdata_offset += num_bytes;\n\t\t}\n\t\tkunmap_local(ecryptfs_page_virt);\n\t\tflush_dcache_page(ecryptfs_page);\n\t\tSetPageUptodate(ecryptfs_page);\n\t\tunlock_page(ecryptfs_page);\n\t\tif (crypt_stat->flags & ECRYPTFS_ENCRYPTED)\n\t\t\trc = ecryptfs_encrypt_page(ecryptfs_page);\n\t\telse\n\t\t\trc = ecryptfs_write_lower_page_segment(ecryptfs_inode,\n\t\t\t\t\t\tecryptfs_page,\n\t\t\t\t\t\tstart_offset_in_page,\n\t\t\t\t\t\tdata_offset);\n\t\tput_page(ecryptfs_page);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting \"\n\t\t\t       \"page; rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t\tpos += num_bytes;\n\t}\n\tif (pos > ecryptfs_file_size) {\n\t\ti_size_write(ecryptfs_inode, pos);\n\t\tif (crypt_stat->flags & ECRYPTFS_ENCRYPTED) {\n\t\t\tint rc2;\n\n\t\t\trc2 = ecryptfs_write_inode_size_to_metadata(\n\t\t\t\t\t\t\t\tecryptfs_inode);\n\t\t\tif (rc2) {\n\t\t\t\tprintk(KERN_ERR\t\"Problem with \"\n\t\t\t\t       \"ecryptfs_write_inode_size_to_metadata; \"\n\t\t\t\t       \"rc = [%d]\\n\", rc2);\n\t\t\t\tif (!rc)\n\t\t\t\t\trc = rc2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\treturn rc;\n}\n\n \nint ecryptfs_read_lower(char *data, loff_t offset, size_t size,\n\t\t\tstruct inode *ecryptfs_inode)\n{\n\tstruct file *lower_file;\n\tlower_file = ecryptfs_inode_to_private(ecryptfs_inode)->lower_file;\n\tif (!lower_file)\n\t\treturn -EIO;\n\treturn kernel_read(lower_file, data, size, &offset);\n}\n\n \nint ecryptfs_read_lower_page_segment(struct page *page_for_ecryptfs,\n\t\t\t\t     pgoff_t page_index,\n\t\t\t\t     size_t offset_in_page, size_t size,\n\t\t\t\t     struct inode *ecryptfs_inode)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_index) << PAGE_SHIFT) + offset_in_page);\n\tvirt = kmap_local_page(page_for_ecryptfs);\n\trc = ecryptfs_read_lower(virt, offset, size, ecryptfs_inode);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap_local(virt);\n\tflush_dcache_page(page_for_ecryptfs);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}