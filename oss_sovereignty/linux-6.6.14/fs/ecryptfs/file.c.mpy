{
  "module_name": "file.c",
  "hash_id": "286d51cf3aaee98d7a749edfc7329b73f94285c42ac14f02062d12f54bb333fd",
  "original_prompt": "Ingested from linux-6.6.14/fs/ecryptfs/file.c",
  "human_readable_source": "\n \n\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/security.h>\n#include <linux/compat.h>\n#include <linux/fs_stack.h>\n#include \"ecryptfs_kernel.h\"\n\n \nstatic ssize_t ecryptfs_read_update_atime(struct kiocb *iocb,\n\t\t\t\tstruct iov_iter *to)\n{\n\tssize_t rc;\n\tconst struct path *path;\n\tstruct file *file = iocb->ki_filp;\n\n\trc = generic_file_read_iter(iocb, to);\n\tif (rc >= 0) {\n\t\tpath = ecryptfs_dentry_to_lower_path(file->f_path.dentry);\n\t\ttouch_atime(path);\n\t}\n\treturn rc;\n}\n\n \nstatic ssize_t ecryptfs_splice_read_update_atime(struct file *in, loff_t *ppos,\n\t\t\t\t\t\t struct pipe_inode_info *pipe,\n\t\t\t\t\t\t size_t len, unsigned int flags)\n{\n\tssize_t rc;\n\tconst struct path *path;\n\n\trc = filemap_splice_read(in, ppos, pipe, len, flags);\n\tif (rc >= 0) {\n\t\tpath = ecryptfs_dentry_to_lower_path(in->f_path.dentry);\n\t\ttouch_atime(path);\n\t}\n\treturn rc;\n}\n\nstruct ecryptfs_getdents_callback {\n\tstruct dir_context ctx;\n\tstruct dir_context *caller;\n\tstruct super_block *sb;\n\tint filldir_called;\n\tint entries_written;\n};\n\n \nstatic bool\necryptfs_filldir(struct dir_context *ctx, const char *lower_name,\n\t\t int lower_namelen, loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct ecryptfs_getdents_callback *buf =\n\t\tcontainer_of(ctx, struct ecryptfs_getdents_callback, ctx);\n\tsize_t name_size;\n\tchar *name;\n\tint err;\n\tbool res;\n\n\tbuf->filldir_called++;\n\terr = ecryptfs_decode_and_decrypt_filename(&name, &name_size,\n\t\t\t\t\t\t   buf->sb, lower_name,\n\t\t\t\t\t\t   lower_namelen);\n\tif (err) {\n\t\tif (err != -EINVAL) {\n\t\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\t\"%s: Error attempting to decode and decrypt filename [%s]; rc = [%d]\\n\",\n\t\t\t\t\t__func__, lower_name, err);\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\treturn true;\n\t}\n\n\tbuf->caller->pos = buf->ctx.pos;\n\tres = dir_emit(buf->caller, name, name_size, ino, d_type);\n\tkfree(name);\n\tif (res)\n\t\tbuf->entries_written++;\n\treturn res;\n}\n\n \nstatic int ecryptfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tint rc;\n\tstruct file *lower_file;\n\tstruct inode *inode = file_inode(file);\n\tstruct ecryptfs_getdents_callback buf = {\n\t\t.ctx.actor = ecryptfs_filldir,\n\t\t.caller = ctx,\n\t\t.sb = inode->i_sb,\n\t};\n\tlower_file = ecryptfs_file_to_lower(file);\n\trc = iterate_dir(lower_file, &buf.ctx);\n\tctx->pos = buf.ctx.pos;\n\tif (rc >= 0 && (buf.entries_written || !buf.filldir_called))\n\t\tfsstack_copy_attr_atime(inode, file_inode(lower_file));\n\treturn rc;\n}\n\nstruct kmem_cache *ecryptfs_file_info_cache;\n\nstatic int read_or_initialize_metadata(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tint rc;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tmount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\t\t\t\t\tinode->i_sb)->mount_crypt_stat;\n\tmutex_lock(&crypt_stat->cs_mutex);\n\n\tif (crypt_stat->flags & ECRYPTFS_POLICY_APPLIED &&\n\t    crypt_stat->flags & ECRYPTFS_KEY_VALID) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = ecryptfs_read_metadata(dentry);\n\tif (!rc)\n\t\tgoto out;\n\n\tif (mount_crypt_stat->flags & ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED) {\n\t\tcrypt_stat->flags &= ~(ECRYPTFS_I_SIZE_INITIALIZED\n\t\t\t\t       | ECRYPTFS_ENCRYPTED);\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (!(mount_crypt_stat->flags & ECRYPTFS_XATTR_METADATA_ENABLED) &&\n\t    !i_size_read(ecryptfs_inode_to_lower(inode))) {\n\t\trc = ecryptfs_initialize_file(dentry, inode);\n\t\tif (!rc)\n\t\t\tgoto out;\n\t}\n\n\trc = -EIO;\nout:\n\tmutex_unlock(&crypt_stat->cs_mutex);\n\treturn rc;\n}\n\nstatic int ecryptfs_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct file *lower_file = ecryptfs_file_to_lower(file);\n\t \n\tif (!lower_file->f_op->mmap)\n\t\treturn -ENODEV;\n\treturn generic_file_mmap(file, vma);\n}\n\n \nstatic int ecryptfs_open(struct inode *inode, struct file *file)\n{\n\tint rc = 0;\n\tstruct ecryptfs_crypt_stat *crypt_stat = NULL;\n\tstruct dentry *ecryptfs_dentry = file->f_path.dentry;\n\t \n\tstruct ecryptfs_file_info *file_info;\n\n\t \n\tfile_info = kmem_cache_zalloc(ecryptfs_file_info_cache, GFP_KERNEL);\n\tecryptfs_set_file_private(file, file_info);\n\tif (!file_info) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\"Error attempting to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tmutex_lock(&crypt_stat->cs_mutex);\n\tif (!(crypt_stat->flags & ECRYPTFS_POLICY_APPLIED)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Setting flags for stat...\\n\");\n\t\t \n\t\tcrypt_stat->flags |= (ECRYPTFS_POLICY_APPLIED\n\t\t\t\t      | ECRYPTFS_ENCRYPTED);\n\t}\n\tmutex_unlock(&crypt_stat->cs_mutex);\n\trc = ecryptfs_get_lower_file(ecryptfs_dentry, inode);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to initialize \"\n\t\t\t\"the lower file for the dentry with name \"\n\t\t\t\"[%pd]; rc = [%d]\\n\", __func__,\n\t\t\tecryptfs_dentry, rc);\n\t\tgoto out_free;\n\t}\n\tif ((ecryptfs_inode_to_private(inode)->lower_file->f_flags & O_ACCMODE)\n\t    == O_RDONLY && (file->f_flags & O_ACCMODE) != O_RDONLY) {\n\t\trc = -EPERM;\n\t\tprintk(KERN_WARNING \"%s: Lower file is RO; eCryptfs \"\n\t\t       \"file must hence be opened RO\\n\", __func__);\n\t\tgoto out_put;\n\t}\n\tecryptfs_set_file_lower(\n\t\tfile, ecryptfs_inode_to_private(inode)->lower_file);\n\trc = read_or_initialize_metadata(ecryptfs_dentry);\n\tif (rc)\n\t\tgoto out_put;\n\tecryptfs_printk(KERN_DEBUG, \"inode w/ addr = [0x%p], i_ino = \"\n\t\t\t\"[0x%.16lx] size: [0x%.16llx]\\n\", inode, inode->i_ino,\n\t\t\t(unsigned long long)i_size_read(inode));\n\tgoto out;\nout_put:\n\tecryptfs_put_lower_file(inode);\nout_free:\n\tkmem_cache_free(ecryptfs_file_info_cache,\n\t\t\tecryptfs_file_to_private(file));\nout:\n\treturn rc;\n}\n\n \nstatic int ecryptfs_dir_open(struct inode *inode, struct file *file)\n{\n\tstruct dentry *ecryptfs_dentry = file->f_path.dentry;\n\t \n\tstruct ecryptfs_file_info *file_info;\n\tstruct file *lower_file;\n\n\t \n\tfile_info = kmem_cache_zalloc(ecryptfs_file_info_cache, GFP_KERNEL);\n\tecryptfs_set_file_private(file, file_info);\n\tif (unlikely(!file_info)) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\"Error attempting to allocate memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tlower_file = dentry_open(ecryptfs_dentry_to_lower_path(ecryptfs_dentry),\n\t\t\t\t file->f_flags, current_cred());\n\tif (IS_ERR(lower_file)) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to initialize \"\n\t\t\t\"the lower file for the dentry with name \"\n\t\t\t\"[%pd]; rc = [%ld]\\n\", __func__,\n\t\t\tecryptfs_dentry, PTR_ERR(lower_file));\n\t\tkmem_cache_free(ecryptfs_file_info_cache, file_info);\n\t\treturn PTR_ERR(lower_file);\n\t}\n\tecryptfs_set_file_lower(file, lower_file);\n\treturn 0;\n}\n\nstatic int ecryptfs_flush(struct file *file, fl_owner_t td)\n{\n\tstruct file *lower_file = ecryptfs_file_to_lower(file);\n\n\tif (lower_file->f_op->flush) {\n\t\tfilemap_write_and_wait(file->f_mapping);\n\t\treturn lower_file->f_op->flush(lower_file, td);\n\t}\n\n\treturn 0;\n}\n\nstatic int ecryptfs_release(struct inode *inode, struct file *file)\n{\n\tecryptfs_put_lower_file(inode);\n\tkmem_cache_free(ecryptfs_file_info_cache,\n\t\t\tecryptfs_file_to_private(file));\n\treturn 0;\n}\n\nstatic int ecryptfs_dir_release(struct inode *inode, struct file *file)\n{\n\tfput(ecryptfs_file_to_lower(file));\n\tkmem_cache_free(ecryptfs_file_info_cache,\n\t\t\tecryptfs_file_to_private(file));\n\treturn 0;\n}\n\nstatic loff_t ecryptfs_dir_llseek(struct file *file, loff_t offset, int whence)\n{\n\treturn vfs_llseek(ecryptfs_file_to_lower(file), offset, whence);\n}\n\nstatic int\necryptfs_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tint rc;\n\n\trc = file_write_and_wait(file);\n\tif (rc)\n\t\treturn rc;\n\n\treturn vfs_fsync(ecryptfs_file_to_lower(file), datasync);\n}\n\nstatic int ecryptfs_fasync(int fd, struct file *file, int flag)\n{\n\tint rc = 0;\n\tstruct file *lower_file = NULL;\n\n\tlower_file = ecryptfs_file_to_lower(file);\n\tif (lower_file->f_op->fasync)\n\t\trc = lower_file->f_op->fasync(fd, lower_file, flag);\n\treturn rc;\n}\n\nstatic long\necryptfs_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct file *lower_file = ecryptfs_file_to_lower(file);\n\tlong rc = -ENOTTY;\n\n\tif (!lower_file->f_op->unlocked_ioctl)\n\t\treturn rc;\n\n\tswitch (cmd) {\n\tcase FITRIM:\n\tcase FS_IOC_GETFLAGS:\n\tcase FS_IOC_SETFLAGS:\n\tcase FS_IOC_GETVERSION:\n\tcase FS_IOC_SETVERSION:\n\t\trc = lower_file->f_op->unlocked_ioctl(lower_file, cmd, arg);\n\t\tfsstack_copy_attr_all(file_inode(file), file_inode(lower_file));\n\n\t\treturn rc;\n\tdefault:\n\t\treturn rc;\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nstatic long\necryptfs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct file *lower_file = ecryptfs_file_to_lower(file);\n\tlong rc = -ENOIOCTLCMD;\n\n\tif (!lower_file->f_op->compat_ioctl)\n\t\treturn rc;\n\n\tswitch (cmd) {\n\tcase FITRIM:\n\tcase FS_IOC32_GETFLAGS:\n\tcase FS_IOC32_SETFLAGS:\n\tcase FS_IOC32_GETVERSION:\n\tcase FS_IOC32_SETVERSION:\n\t\trc = lower_file->f_op->compat_ioctl(lower_file, cmd, arg);\n\t\tfsstack_copy_attr_all(file_inode(file), file_inode(lower_file));\n\n\t\treturn rc;\n\tdefault:\n\t\treturn rc;\n\t}\n}\n#endif\n\nconst struct file_operations ecryptfs_dir_fops = {\n\t.iterate_shared = ecryptfs_readdir,\n\t.read = generic_read_dir,\n\t.unlocked_ioctl = ecryptfs_unlocked_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = ecryptfs_compat_ioctl,\n#endif\n\t.open = ecryptfs_dir_open,\n\t.release = ecryptfs_dir_release,\n\t.fsync = ecryptfs_fsync,\n\t.llseek = ecryptfs_dir_llseek,\n};\n\nconst struct file_operations ecryptfs_main_fops = {\n\t.llseek = generic_file_llseek,\n\t.read_iter = ecryptfs_read_update_atime,\n\t.write_iter = generic_file_write_iter,\n\t.unlocked_ioctl = ecryptfs_unlocked_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = ecryptfs_compat_ioctl,\n#endif\n\t.mmap = ecryptfs_mmap,\n\t.open = ecryptfs_open,\n\t.flush = ecryptfs_flush,\n\t.release = ecryptfs_release,\n\t.fsync = ecryptfs_fsync,\n\t.fasync = ecryptfs_fasync,\n\t.splice_read = ecryptfs_splice_read_update_atime,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}