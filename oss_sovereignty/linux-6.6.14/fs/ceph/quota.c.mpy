{
  "module_name": "quota.c",
  "hash_id": "fb2bef6c75944e83ab00a19daecf254d74ab02b0c4fcb39acd069a12b4d55a34",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/quota.c",
  "human_readable_source": "\n \n\n#include <linux/statfs.h>\n\n#include \"super.h\"\n#include \"mds_client.h\"\n\nvoid ceph_adjust_quota_realms_count(struct inode *inode, bool inc)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(inode->i_sb);\n\tif (inc)\n\t\tatomic64_inc(&mdsc->quotarealms_count);\n\telse\n\t\tatomic64_dec(&mdsc->quotarealms_count);\n}\n\nstatic inline bool ceph_has_realms_with_quotas(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(sb);\n\tstruct inode *root = d_inode(sb->s_root);\n\n\tif (atomic64_read(&mdsc->quotarealms_count) > 0)\n\t\treturn true;\n\t \n\tif (root && ceph_ino(root) == CEPH_INO_ROOT)\n\t\treturn false;\n\t \n\tif (ceph_vino_is_reserved(ceph_inode(inode)->i_vino))\n\t\treturn false;\n\t \n\treturn true;\n}\n\nvoid ceph_handle_quota(struct ceph_mds_client *mdsc,\n\t\t       struct ceph_mds_session *session,\n\t\t       struct ceph_msg *msg)\n{\n\tstruct super_block *sb = mdsc->fsc->sb;\n\tstruct ceph_mds_quota *h = msg->front.iov_base;\n\tstruct ceph_vino vino;\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\n\tif (!ceph_inc_mds_stopping_blocker(mdsc, session))\n\t\treturn;\n\n\tif (msg->front.iov_len < sizeof(*h)) {\n\t\tpr_err(\"%s corrupt message mds%d len %d\\n\", __func__,\n\t\t       session->s_mds, (int)msg->front.iov_len);\n\t\tceph_msg_dump(msg);\n\t\tgoto out;\n\t}\n\n\t \n\tvino.ino = le64_to_cpu(h->ino);\n\tvino.snap = CEPH_NOSNAP;\n\tinode = ceph_find_inode(sb, vino);\n\tif (!inode) {\n\t\tpr_warn(\"Failed to find inode %llu\\n\", vino.ino);\n\t\tgoto out;\n\t}\n\tci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tci->i_rbytes = le64_to_cpu(h->rbytes);\n\tci->i_rfiles = le64_to_cpu(h->rfiles);\n\tci->i_rsubdirs = le64_to_cpu(h->rsubdirs);\n\t__ceph_update_quota(ci, le64_to_cpu(h->max_bytes),\n\t\t            le64_to_cpu(h->max_files));\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tiput(inode);\nout:\n\tceph_dec_mds_stopping_blocker(mdsc);\n}\n\nstatic struct ceph_quotarealm_inode *\nfind_quotarealm_inode(struct ceph_mds_client *mdsc, u64 ino)\n{\n\tstruct ceph_quotarealm_inode *qri = NULL;\n\tstruct rb_node **node, *parent = NULL;\n\n\tmutex_lock(&mdsc->quotarealms_inodes_mutex);\n\tnode = &(mdsc->quotarealms_inodes.rb_node);\n\twhile (*node) {\n\t\tparent = *node;\n\t\tqri = container_of(*node, struct ceph_quotarealm_inode, node);\n\n\t\tif (ino < qri->ino)\n\t\t\tnode = &((*node)->rb_left);\n\t\telse if (ino > qri->ino)\n\t\t\tnode = &((*node)->rb_right);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!qri || (qri->ino != ino)) {\n\t\t \n\t\tqri = kmalloc(sizeof(*qri), GFP_KERNEL);\n\t\tif (qri) {\n\t\t\tqri->ino = ino;\n\t\t\tqri->inode = NULL;\n\t\t\tqri->timeout = 0;\n\t\t\tmutex_init(&qri->mutex);\n\t\t\trb_link_node(&qri->node, parent, node);\n\t\t\trb_insert_color(&qri->node, &mdsc->quotarealms_inodes);\n\t\t} else\n\t\t\tpr_warn(\"Failed to alloc quotarealms_inode\\n\");\n\t}\n\tmutex_unlock(&mdsc->quotarealms_inodes_mutex);\n\n\treturn qri;\n}\n\n \nstatic struct inode *lookup_quotarealm_inode(struct ceph_mds_client *mdsc,\n\t\t\t\t\t     struct super_block *sb,\n\t\t\t\t\t     struct ceph_snap_realm *realm)\n{\n\tstruct ceph_quotarealm_inode *qri;\n\tstruct inode *in;\n\n\tqri = find_quotarealm_inode(mdsc, realm->ino);\n\tif (!qri)\n\t\treturn NULL;\n\n\tmutex_lock(&qri->mutex);\n\tif (qri->inode && ceph_is_any_caps(qri->inode)) {\n\t\t \n\t\tmutex_unlock(&qri->mutex);\n\t\treturn qri->inode;\n\t}\n\t \n\tif (qri->timeout &&\n\t    time_before_eq(jiffies, qri->timeout)) {\n\t\tmutex_unlock(&qri->mutex);\n\t\treturn NULL;\n\t}\n\tif (qri->inode) {\n\t\t \n\t\tint ret = __ceph_do_getattr(qri->inode, NULL,\n\t\t\t\t\t    CEPH_STAT_CAP_INODE, true);\n\t\tif (ret >= 0)\n\t\t\tin = qri->inode;\n\t\telse\n\t\t\tin = ERR_PTR(ret);\n\t}  else {\n\t\tin = ceph_lookup_inode(sb, realm->ino);\n\t}\n\n\tif (IS_ERR(in)) {\n\t\tdout(\"Can't lookup inode %llx (err: %ld)\\n\",\n\t\t     realm->ino, PTR_ERR(in));\n\t\tqri->timeout = jiffies + msecs_to_jiffies(60 * 1000);  \n\t} else {\n\t\tqri->timeout = 0;\n\t\tqri->inode = in;\n\t}\n\tmutex_unlock(&qri->mutex);\n\n\treturn in;\n}\n\nvoid ceph_cleanup_quotarealms_inodes(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_quotarealm_inode *qri;\n\tstruct rb_node *node;\n\n\t \n\tmutex_lock(&mdsc->quotarealms_inodes_mutex);\n\twhile (!RB_EMPTY_ROOT(&mdsc->quotarealms_inodes)) {\n\t\tnode = rb_first(&mdsc->quotarealms_inodes);\n\t\tqri = rb_entry(node, struct ceph_quotarealm_inode, node);\n\t\trb_erase(node, &mdsc->quotarealms_inodes);\n\t\tiput(qri->inode);\n\t\tkfree(qri);\n\t}\n\tmutex_unlock(&mdsc->quotarealms_inodes_mutex);\n}\n\n \nstatic struct ceph_snap_realm *get_quota_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t       struct inode *inode,\n\t\t\t\t\t       enum quota_get_realm which_quota,\n\t\t\t\t\t       bool retry)\n{\n\tstruct ceph_inode_info *ci = NULL;\n\tstruct ceph_snap_realm *realm, *next;\n\tstruct inode *in;\n\tbool has_quota;\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP)\n\t\treturn NULL;\n\nrestart:\n\trealm = ceph_inode(inode)->i_snap_realm;\n\tif (realm)\n\t\tceph_get_snap_realm(mdsc, realm);\n\telse\n\t\tpr_err_ratelimited(\"get_quota_realm: ino (%llx.%llx) \"\n\t\t\t\t   \"null i_snap_realm\\n\", ceph_vinop(inode));\n\twhile (realm) {\n\t\tbool has_inode;\n\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\thas_inode = realm->inode;\n\t\tin = has_inode ? igrab(realm->inode) : NULL;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tif (has_inode && !in)\n\t\t\tbreak;\n\t\tif (!in) {\n\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\tin = lookup_quotarealm_inode(mdsc, inode->i_sb, realm);\n\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\tif (IS_ERR_OR_NULL(in))\n\t\t\t\tbreak;\n\t\t\tceph_put_snap_realm(mdsc, realm);\n\t\t\tif (!retry)\n\t\t\t\treturn ERR_PTR(-EAGAIN);\n\t\t\tgoto restart;\n\t\t}\n\n\t\tci = ceph_inode(in);\n\t\thas_quota = __ceph_has_quota(ci, which_quota);\n\t\tiput(in);\n\n\t\tnext = realm->parent;\n\t\tif (has_quota || !next)\n\t\t       return realm;\n\n\t\tceph_get_snap_realm(mdsc, next);\n\t\tceph_put_snap_realm(mdsc, realm);\n\t\trealm = next;\n\t}\n\tif (realm)\n\t\tceph_put_snap_realm(mdsc, realm);\n\n\treturn NULL;\n}\n\nbool ceph_quota_is_same_realm(struct inode *old, struct inode *new)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(old->i_sb);\n\tstruct ceph_snap_realm *old_realm, *new_realm;\n\tbool is_same;\n\nrestart:\n\t \n\tdown_read(&mdsc->snap_rwsem);\n\told_realm = get_quota_realm(mdsc, old, QUOTA_GET_ANY, true);\n\tnew_realm = get_quota_realm(mdsc, new, QUOTA_GET_ANY, false);\n\tif (PTR_ERR(new_realm) == -EAGAIN) {\n\t\tup_read(&mdsc->snap_rwsem);\n\t\tif (old_realm)\n\t\t\tceph_put_snap_realm(mdsc, old_realm);\n\t\tgoto restart;\n\t}\n\tis_same = (old_realm == new_realm);\n\tup_read(&mdsc->snap_rwsem);\n\n\tif (old_realm)\n\t\tceph_put_snap_realm(mdsc, old_realm);\n\tif (new_realm)\n\t\tceph_put_snap_realm(mdsc, new_realm);\n\n\treturn is_same;\n}\n\nenum quota_check_op {\n\tQUOTA_CHECK_MAX_FILES_OP,\t \n\tQUOTA_CHECK_MAX_BYTES_OP,\t \n\tQUOTA_CHECK_MAX_BYTES_APPROACHING_OP\t \n};\n\n \nstatic bool check_quota_exceeded(struct inode *inode, enum quota_check_op op,\n\t\t\t\t loff_t delta)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(inode->i_sb);\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_snap_realm *realm, *next;\n\tstruct inode *in;\n\tu64 max, rvalue;\n\tbool exceeded = false;\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP)\n\t\treturn false;\n\n\tdown_read(&mdsc->snap_rwsem);\nrestart:\n\trealm = ceph_inode(inode)->i_snap_realm;\n\tif (realm)\n\t\tceph_get_snap_realm(mdsc, realm);\n\telse\n\t\tpr_err_ratelimited(\"check_quota_exceeded: ino (%llx.%llx) \"\n\t\t\t\t   \"null i_snap_realm\\n\", ceph_vinop(inode));\n\twhile (realm) {\n\t\tbool has_inode;\n\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\thas_inode = realm->inode;\n\t\tin = has_inode ? igrab(realm->inode) : NULL;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tif (has_inode && !in)\n\t\t\tbreak;\n\t\tif (!in) {\n\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\tin = lookup_quotarealm_inode(mdsc, inode->i_sb, realm);\n\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\tif (IS_ERR_OR_NULL(in))\n\t\t\t\tbreak;\n\t\t\tceph_put_snap_realm(mdsc, realm);\n\t\t\tgoto restart;\n\t\t}\n\t\tci = ceph_inode(in);\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (op == QUOTA_CHECK_MAX_FILES_OP) {\n\t\t\tmax = ci->i_max_files;\n\t\t\trvalue = ci->i_rfiles + ci->i_rsubdirs;\n\t\t} else {\n\t\t\tmax = ci->i_max_bytes;\n\t\t\trvalue = ci->i_rbytes;\n\t\t}\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tswitch (op) {\n\t\tcase QUOTA_CHECK_MAX_FILES_OP:\n\t\tcase QUOTA_CHECK_MAX_BYTES_OP:\n\t\t\texceeded = (max && (rvalue + delta > max));\n\t\t\tbreak;\n\t\tcase QUOTA_CHECK_MAX_BYTES_APPROACHING_OP:\n\t\t\tif (max) {\n\t\t\t\tif (rvalue >= max)\n\t\t\t\t\texceeded = true;\n\t\t\t\telse {\n\t\t\t\t\t \n\t\t\t\t\texceeded =\n\t\t\t\t\t\t(((max - rvalue) >> 4) < delta);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tpr_warn(\"Invalid quota check op (%d)\\n\", op);\n\t\t\texceeded = true;  \n\t\t}\n\t\tiput(in);\n\n\t\tnext = realm->parent;\n\t\tif (exceeded || !next)\n\t\t\tbreak;\n\t\tceph_get_snap_realm(mdsc, next);\n\t\tceph_put_snap_realm(mdsc, realm);\n\t\trealm = next;\n\t}\n\tif (realm)\n\t\tceph_put_snap_realm(mdsc, realm);\n\tup_read(&mdsc->snap_rwsem);\n\n\treturn exceeded;\n}\n\n \nbool ceph_quota_is_max_files_exceeded(struct inode *inode)\n{\n\tif (!ceph_has_realms_with_quotas(inode))\n\t\treturn false;\n\n\tWARN_ON(!S_ISDIR(inode->i_mode));\n\n\treturn check_quota_exceeded(inode, QUOTA_CHECK_MAX_FILES_OP, 1);\n}\n\n \nbool ceph_quota_is_max_bytes_exceeded(struct inode *inode, loff_t newsize)\n{\n\tloff_t size = i_size_read(inode);\n\n\tif (!ceph_has_realms_with_quotas(inode))\n\t\treturn false;\n\n\t \n\tif (newsize <= size)\n\t\treturn false;\n\n\treturn check_quota_exceeded(inode, QUOTA_CHECK_MAX_BYTES_OP, (newsize - size));\n}\n\n \nbool ceph_quota_is_max_bytes_approaching(struct inode *inode, loff_t newsize)\n{\n\tloff_t size = ceph_inode(inode)->i_reported_size;\n\n\tif (!ceph_has_realms_with_quotas(inode))\n\t\treturn false;\n\n\t \n\tif (newsize <= size)\n\t\treturn false;\n\n\treturn check_quota_exceeded(inode, QUOTA_CHECK_MAX_BYTES_APPROACHING_OP,\n\t\t\t\t    (newsize - size));\n}\n\n \nbool ceph_quota_update_statfs(struct ceph_fs_client *fsc, struct kstatfs *buf)\n{\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_snap_realm *realm;\n\tstruct inode *in;\n\tu64 total = 0, used, free;\n\tbool is_updated = false;\n\n\tdown_read(&mdsc->snap_rwsem);\n\trealm = get_quota_realm(mdsc, d_inode(fsc->sb->s_root),\n\t\t\t\tQUOTA_GET_MAX_BYTES, true);\n\tup_read(&mdsc->snap_rwsem);\n\tif (!realm)\n\t\treturn false;\n\n\tspin_lock(&realm->inodes_with_caps_lock);\n\tin = realm->inode ? igrab(realm->inode) : NULL;\n\tspin_unlock(&realm->inodes_with_caps_lock);\n\tif (in) {\n\t\tci = ceph_inode(in);\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_max_bytes) {\n\t\t\ttotal = ci->i_max_bytes >> CEPH_BLOCK_SHIFT;\n\t\t\tused = ci->i_rbytes >> CEPH_BLOCK_SHIFT;\n\t\t\t \n\t\t\tif (!total) {\n\t\t\t\ttotal = ci->i_max_bytes >> CEPH_4K_BLOCK_SHIFT;\n\t\t\t\tused = ci->i_rbytes >> CEPH_4K_BLOCK_SHIFT;\n\t                        buf->f_frsize = 1 << CEPH_4K_BLOCK_SHIFT;\n\t\t\t}\n\t\t\t \n\t\t\tfree = total > used ? total - used : 0;\n\t\t\t \n\t\t\tif (!total) {\n\t\t\t\ttotal = 1;\n\t\t\t\tfree = ci->i_max_bytes > ci->i_rbytes ? 1 : 0;\n\t                        buf->f_frsize = 1 << CEPH_4K_BLOCK_SHIFT;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tif (total) {\n\t\t\tbuf->f_blocks = total;\n\t\t\tbuf->f_bfree = free;\n\t\t\tbuf->f_bavail = free;\n\t\t\tis_updated = true;\n\t\t}\n\t\tiput(in);\n\t}\n\tceph_put_snap_realm(mdsc, realm);\n\n\treturn is_updated;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}