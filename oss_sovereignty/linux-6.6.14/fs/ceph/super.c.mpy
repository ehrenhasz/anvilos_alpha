{
  "module_name": "super.c",
  "hash_id": "a1bd905925c8d33bce5915de7fe8fff0efc78f48af7601b601f5c6978696e280",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/super.c",
  "human_readable_source": "\n\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/inet.h>\n#include <linux/in6.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/string.h>\n\n#include \"super.h\"\n#include \"mds_client.h\"\n#include \"cache.h\"\n#include \"crypto.h\"\n\n#include <linux/ceph/ceph_features.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/debugfs.h>\n\n#include <uapi/linux/magic.h>\n\nstatic DEFINE_SPINLOCK(ceph_fsc_lock);\nstatic LIST_HEAD(ceph_fsc_list);\n\n \n\n \nstatic void ceph_put_super(struct super_block *s)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(s);\n\n\tdout(\"put_super\\n\");\n\tceph_fscrypt_free_dummy_policy(fsc);\n\tceph_mdsc_close_sessions(fsc->mdsc);\n}\n\nstatic int ceph_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(d_inode(dentry));\n\tstruct ceph_mon_client *monc = &fsc->client->monc;\n\tstruct ceph_statfs st;\n\tint i, err;\n\tu64 data_pool;\n\n\tif (fsc->mdsc->mdsmap->m_num_data_pg_pools == 1) {\n\t\tdata_pool = fsc->mdsc->mdsmap->m_data_pg_pools[0];\n\t} else {\n\t\tdata_pool = CEPH_NOPOOL;\n\t}\n\n\tdout(\"statfs\\n\");\n\terr = ceph_monc_do_statfs(monc, data_pool, &st);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tbuf->f_type = CEPH_SUPER_MAGIC;   \n\n\t \n\tbuf->f_frsize = 1 << CEPH_BLOCK_SHIFT;\n\n\t \n\tif (ceph_test_mount_opt(fsc, NOQUOTADF) ||\n\t    !ceph_quota_update_statfs(fsc, buf)) {\n\t\tbuf->f_blocks = le64_to_cpu(st.kb) >> (CEPH_BLOCK_SHIFT-10);\n\t\tbuf->f_bfree = le64_to_cpu(st.kb_avail) >> (CEPH_BLOCK_SHIFT-10);\n\t\tbuf->f_bavail = le64_to_cpu(st.kb_avail) >> (CEPH_BLOCK_SHIFT-10);\n\t}\n\n\t \n\tbuf->f_bsize = buf->f_frsize;\n\n\tbuf->f_files = le64_to_cpu(st.num_objects);\n\tbuf->f_ffree = -1;\n\tbuf->f_namelen = NAME_MAX;\n\n\t \n\tbuf->f_fsid.val[0] = 0;\n\tmutex_lock(&monc->mutex);\n\tfor (i = 0 ; i < sizeof(monc->monmap->fsid) / sizeof(__le32) ; ++i)\n\t\tbuf->f_fsid.val[0] ^= le32_to_cpu(((__le32 *)&monc->monmap->fsid)[i]);\n\tmutex_unlock(&monc->mutex);\n\n\t \n\tbuf->f_fsid.val[1] = monc->fs_cluster_id;\n\n\treturn 0;\n}\n\nstatic int ceph_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\n\tif (!wait) {\n\t\tdout(\"sync_fs (non-blocking)\\n\");\n\t\tceph_flush_dirty_caps(fsc->mdsc);\n\t\tdout(\"sync_fs (non-blocking) done\\n\");\n\t\treturn 0;\n\t}\n\n\tdout(\"sync_fs (blocking)\\n\");\n\tceph_osdc_sync(&fsc->client->osdc);\n\tceph_mdsc_sync(fsc->mdsc);\n\tdout(\"sync_fs (blocking) done\\n\");\n\treturn 0;\n}\n\n \nenum {\n\tOpt_wsize,\n\tOpt_rsize,\n\tOpt_rasize,\n\tOpt_caps_wanted_delay_min,\n\tOpt_caps_wanted_delay_max,\n\tOpt_caps_max,\n\tOpt_readdir_max_entries,\n\tOpt_readdir_max_bytes,\n\tOpt_congestion_kb,\n\t \n\tOpt_snapdirname,\n\tOpt_mds_namespace,\n\tOpt_recover_session,\n\tOpt_source,\n\tOpt_mon_addr,\n\tOpt_test_dummy_encryption,\n\t \n\tOpt_dirstat,\n\tOpt_rbytes,\n\tOpt_asyncreaddir,\n\tOpt_dcache,\n\tOpt_ino32,\n\tOpt_fscache,\n\tOpt_poolperm,\n\tOpt_require_active_mds,\n\tOpt_acl,\n\tOpt_quotadf,\n\tOpt_copyfrom,\n\tOpt_wsync,\n\tOpt_pagecache,\n\tOpt_sparseread,\n};\n\nenum ceph_recover_session_mode {\n\tceph_recover_session_no,\n\tceph_recover_session_clean\n};\n\nstatic const struct constant_table ceph_param_recover[] = {\n\t{ \"no\",\t\tceph_recover_session_no },\n\t{ \"clean\",\tceph_recover_session_clean },\n\t{}\n};\n\nstatic const struct fs_parameter_spec ceph_mount_parameters[] = {\n\tfsparam_flag_no (\"acl\",\t\t\t\tOpt_acl),\n\tfsparam_flag_no (\"asyncreaddir\",\t\tOpt_asyncreaddir),\n\tfsparam_s32\t(\"caps_max\",\t\t\tOpt_caps_max),\n\tfsparam_u32\t(\"caps_wanted_delay_max\",\tOpt_caps_wanted_delay_max),\n\tfsparam_u32\t(\"caps_wanted_delay_min\",\tOpt_caps_wanted_delay_min),\n\tfsparam_u32\t(\"write_congestion_kb\",\t\tOpt_congestion_kb),\n\tfsparam_flag_no (\"copyfrom\",\t\t\tOpt_copyfrom),\n\tfsparam_flag_no (\"dcache\",\t\t\tOpt_dcache),\n\tfsparam_flag_no (\"dirstat\",\t\t\tOpt_dirstat),\n\tfsparam_flag_no\t(\"fsc\",\t\t\t\tOpt_fscache),  \n\tfsparam_string\t(\"fsc\",\t\t\t\tOpt_fscache),  \n\tfsparam_flag_no (\"ino32\",\t\t\tOpt_ino32),\n\tfsparam_string\t(\"mds_namespace\",\t\tOpt_mds_namespace),\n\tfsparam_string\t(\"mon_addr\",\t\t\tOpt_mon_addr),\n\tfsparam_flag_no (\"poolperm\",\t\t\tOpt_poolperm),\n\tfsparam_flag_no (\"quotadf\",\t\t\tOpt_quotadf),\n\tfsparam_u32\t(\"rasize\",\t\t\tOpt_rasize),\n\tfsparam_flag_no (\"rbytes\",\t\t\tOpt_rbytes),\n\tfsparam_u32\t(\"readdir_max_bytes\",\t\tOpt_readdir_max_bytes),\n\tfsparam_u32\t(\"readdir_max_entries\",\t\tOpt_readdir_max_entries),\n\tfsparam_enum\t(\"recover_session\",\t\tOpt_recover_session, ceph_param_recover),\n\tfsparam_flag_no (\"require_active_mds\",\t\tOpt_require_active_mds),\n\tfsparam_u32\t(\"rsize\",\t\t\tOpt_rsize),\n\tfsparam_string\t(\"snapdirname\",\t\t\tOpt_snapdirname),\n\tfsparam_string\t(\"source\",\t\t\tOpt_source),\n\tfsparam_flag\t(\"test_dummy_encryption\",\tOpt_test_dummy_encryption),\n\tfsparam_string\t(\"test_dummy_encryption\",\tOpt_test_dummy_encryption),\n\tfsparam_u32\t(\"wsize\",\t\t\tOpt_wsize),\n\tfsparam_flag_no\t(\"wsync\",\t\t\tOpt_wsync),\n\tfsparam_flag_no\t(\"pagecache\",\t\t\tOpt_pagecache),\n\tfsparam_flag_no\t(\"sparseread\",\t\t\tOpt_sparseread),\n\t{}\n};\n\nstruct ceph_parse_opts_ctx {\n\tstruct ceph_options\t\t*copts;\n\tstruct ceph_mount_options\t*opts;\n};\n\n \nstatic void canonicalize_path(char *path)\n{\n\tint i, j = 0;\n\n\tfor (i = 0; path[i] != '\\0'; i++) {\n\t\tif (path[i] != '/' || j < 1 || path[j - 1] != '/')\n\t\t\tpath[j++] = path[i];\n\t}\n\n\tif (j > 1 && path[j - 1] == '/')\n\t\tj--;\n\tpath[j] = '\\0';\n}\n\n \nstatic int namespace_equals(struct ceph_mount_options *fsopt,\n\t\t\t    const char *namespace, size_t len)\n{\n\treturn !(fsopt->mds_namespace &&\n\t\t (strlen(fsopt->mds_namespace) != len ||\n\t\t  strncmp(fsopt->mds_namespace, namespace, len)));\n}\n\nstatic int ceph_parse_old_source(const char *dev_name, const char *dev_name_end,\n\t\t\t\t struct fs_context *fc)\n{\n\tint r;\n\tstruct ceph_parse_opts_ctx *pctx = fc->fs_private;\n\tstruct ceph_mount_options *fsopt = pctx->opts;\n\n\tif (*dev_name_end != ':')\n\t\treturn invalfc(fc, \"separator ':' missing in source\");\n\n\tr = ceph_parse_mon_ips(dev_name, dev_name_end - dev_name,\n\t\t\t       pctx->copts, fc->log.log, ',');\n\tif (r)\n\t\treturn r;\n\n\tfsopt->new_dev_syntax = false;\n\treturn 0;\n}\n\nstatic int ceph_parse_new_source(const char *dev_name, const char *dev_name_end,\n\t\t\t\t struct fs_context *fc)\n{\n\tsize_t len;\n\tstruct ceph_fsid fsid;\n\tstruct ceph_parse_opts_ctx *pctx = fc->fs_private;\n\tstruct ceph_mount_options *fsopt = pctx->opts;\n\tchar *fsid_start, *fs_name_start;\n\n\tif (*dev_name_end != '=') {\n\t\tdout(\"separator '=' missing in source\");\n\t\treturn -EINVAL;\n\t}\n\n\tfsid_start = strchr(dev_name, '@');\n\tif (!fsid_start)\n\t\treturn invalfc(fc, \"missing cluster fsid\");\n\t++fsid_start;  \n\n\tfs_name_start = strchr(fsid_start, '.');\n\tif (!fs_name_start)\n\t\treturn invalfc(fc, \"missing file system name\");\n\n\tif (ceph_parse_fsid(fsid_start, &fsid))\n\t\treturn invalfc(fc, \"Invalid FSID\");\n\n\t++fs_name_start;  \n\tlen = dev_name_end - fs_name_start;\n\n\tif (!namespace_equals(fsopt, fs_name_start, len))\n\t\treturn invalfc(fc, \"Mismatching mds_namespace\");\n\tkfree(fsopt->mds_namespace);\n\tfsopt->mds_namespace = kstrndup(fs_name_start, len, GFP_KERNEL);\n\tif (!fsopt->mds_namespace)\n\t\treturn -ENOMEM;\n\tdout(\"file system (mds namespace) '%s'\\n\", fsopt->mds_namespace);\n\n\tfsopt->new_dev_syntax = true;\n\treturn 0;\n}\n\n \nstatic int ceph_parse_source(struct fs_parameter *param, struct fs_context *fc)\n{\n\tstruct ceph_parse_opts_ctx *pctx = fc->fs_private;\n\tstruct ceph_mount_options *fsopt = pctx->opts;\n\tchar *dev_name = param->string, *dev_name_end;\n\tint ret;\n\n\tdout(\"%s '%s'\\n\", __func__, dev_name);\n\tif (!dev_name || !*dev_name)\n\t\treturn invalfc(fc, \"Empty source\");\n\n\tdev_name_end = strchr(dev_name, '/');\n\tif (dev_name_end) {\n\t\t \n\t\tkfree(fsopt->server_path);\n\t\tfsopt->server_path = kstrdup(dev_name_end, GFP_KERNEL);\n\t\tif (!fsopt->server_path)\n\t\t\treturn -ENOMEM;\n\n\t\tcanonicalize_path(fsopt->server_path);\n\t} else {\n\t\tdev_name_end = dev_name + strlen(dev_name);\n\t}\n\n\tdev_name_end--;\t\t \n\tif (dev_name_end < dev_name)\n\t\treturn invalfc(fc, \"Path missing in source\");\n\n\tdout(\"device name '%.*s'\\n\", (int)(dev_name_end - dev_name), dev_name);\n\tif (fsopt->server_path)\n\t\tdout(\"server path '%s'\\n\", fsopt->server_path);\n\n\tdout(\"trying new device syntax\");\n\tret = ceph_parse_new_source(dev_name, dev_name_end, fc);\n\tif (ret) {\n\t\tif (ret != -EINVAL)\n\t\t\treturn ret;\n\t\tdout(\"trying old device syntax\");\n\t\tret = ceph_parse_old_source(dev_name, dev_name_end, fc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfc->source = param->string;\n\tparam->string = NULL;\n\treturn 0;\n}\n\nstatic int ceph_parse_mon_addr(struct fs_parameter *param,\n\t\t\t       struct fs_context *fc)\n{\n\tstruct ceph_parse_opts_ctx *pctx = fc->fs_private;\n\tstruct ceph_mount_options *fsopt = pctx->opts;\n\n\tkfree(fsopt->mon_addr);\n\tfsopt->mon_addr = param->string;\n\tparam->string = NULL;\n\n\treturn ceph_parse_mon_ips(fsopt->mon_addr, strlen(fsopt->mon_addr),\n\t\t\t\t  pctx->copts, fc->log.log, '/');\n}\n\nstatic int ceph_parse_mount_param(struct fs_context *fc,\n\t\t\t\t  struct fs_parameter *param)\n{\n\tstruct ceph_parse_opts_ctx *pctx = fc->fs_private;\n\tstruct ceph_mount_options *fsopt = pctx->opts;\n\tstruct fs_parse_result result;\n\tunsigned int mode;\n\tint token, ret;\n\n\tret = ceph_parse_param(param, pctx->copts, fc->log.log);\n\tif (ret != -ENOPARAM)\n\t\treturn ret;\n\n\ttoken = fs_parse(fc, ceph_mount_parameters, param, &result);\n\tdout(\"%s fs_parse '%s' token %d\\n\", __func__, param->key, token);\n\tif (token < 0)\n\t\treturn token;\n\n\tswitch (token) {\n\tcase Opt_snapdirname:\n\t\tkfree(fsopt->snapdir_name);\n\t\tfsopt->snapdir_name = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\tcase Opt_mds_namespace:\n\t\tif (!namespace_equals(fsopt, param->string, strlen(param->string)))\n\t\t\treturn invalfc(fc, \"Mismatching mds_namespace\");\n\t\tkfree(fsopt->mds_namespace);\n\t\tfsopt->mds_namespace = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\tcase Opt_recover_session:\n\t\tmode = result.uint_32;\n\t\tif (mode == ceph_recover_session_no)\n\t\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_CLEANRECOVER;\n\t\telse if (mode == ceph_recover_session_clean)\n\t\t\tfsopt->flags |= CEPH_MOUNT_OPT_CLEANRECOVER;\n\t\telse\n\t\t\tBUG();\n\t\tbreak;\n\tcase Opt_source:\n\t\tif (fc->source)\n\t\t\treturn invalfc(fc, \"Multiple sources specified\");\n\t\treturn ceph_parse_source(param, fc);\n\tcase Opt_mon_addr:\n\t\treturn ceph_parse_mon_addr(param, fc);\n\tcase Opt_wsize:\n\t\tif (result.uint_32 < PAGE_SIZE ||\n\t\t    result.uint_32 > CEPH_MAX_WRITE_SIZE)\n\t\t\tgoto out_of_range;\n\t\tfsopt->wsize = ALIGN(result.uint_32, PAGE_SIZE);\n\t\tbreak;\n\tcase Opt_rsize:\n\t\tif (result.uint_32 < PAGE_SIZE ||\n\t\t    result.uint_32 > CEPH_MAX_READ_SIZE)\n\t\t\tgoto out_of_range;\n\t\tfsopt->rsize = ALIGN(result.uint_32, PAGE_SIZE);\n\t\tbreak;\n\tcase Opt_rasize:\n\t\tfsopt->rasize = ALIGN(result.uint_32, PAGE_SIZE);\n\t\tbreak;\n\tcase Opt_caps_wanted_delay_min:\n\t\tif (result.uint_32 < 1)\n\t\t\tgoto out_of_range;\n\t\tfsopt->caps_wanted_delay_min = result.uint_32;\n\t\tbreak;\n\tcase Opt_caps_wanted_delay_max:\n\t\tif (result.uint_32 < 1)\n\t\t\tgoto out_of_range;\n\t\tfsopt->caps_wanted_delay_max = result.uint_32;\n\t\tbreak;\n\tcase Opt_caps_max:\n\t\tif (result.int_32 < 0)\n\t\t\tgoto out_of_range;\n\t\tfsopt->caps_max = result.int_32;\n\t\tbreak;\n\tcase Opt_readdir_max_entries:\n\t\tif (result.uint_32 < 1)\n\t\t\tgoto out_of_range;\n\t\tfsopt->max_readdir = result.uint_32;\n\t\tbreak;\n\tcase Opt_readdir_max_bytes:\n\t\tif (result.uint_32 < PAGE_SIZE && result.uint_32 != 0)\n\t\t\tgoto out_of_range;\n\t\tfsopt->max_readdir_bytes = result.uint_32;\n\t\tbreak;\n\tcase Opt_congestion_kb:\n\t\tif (result.uint_32 < 1024)  \n\t\t\tgoto out_of_range;\n\t\tfsopt->congestion_kb = result.uint_32;\n\t\tbreak;\n\tcase Opt_dirstat:\n\t\tif (!result.negated)\n\t\t\tfsopt->flags |= CEPH_MOUNT_OPT_DIRSTAT;\n\t\telse\n\t\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_DIRSTAT;\n\t\tbreak;\n\tcase Opt_rbytes:\n\t\tif (!result.negated)\n\t\t\tfsopt->flags |= CEPH_MOUNT_OPT_RBYTES;\n\t\telse\n\t\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_RBYTES;\n\t\tbreak;\n\tcase Opt_asyncreaddir:\n\t\tif (!result.negated)\n\t\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_NOASYNCREADDIR;\n\t\telse\n\t\t\tfsopt->flags |= CEPH_MOUNT_OPT_NOASYNCREADDIR;\n\t\tbreak;\n\tcase Opt_dcache:\n\t\tif (!result.negated)\n\t\t\tfsopt->flags |= CEPH_MOUNT_OPT_DCACHE;\n\t\telse\n\t\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_DCACHE;\n\t\tbreak;\n\tcase Opt_ino32:\n\t\tif (!result.negated)\n\t\t\tfsopt->flags |= CEPH_MOUNT_OPT_INO32;\n\t\telse\n\t\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_INO32;\n\t\tbreak;\n\n\tcase Opt_fscache:\n#ifdef CONFIG_CEPH_FSCACHE\n\t\tkfree(fsopt->fscache_uniq);\n\t\tfsopt->fscache_uniq = NULL;\n\t\tif (result.negated) {\n\t\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_FSCACHE;\n\t\t} else {\n\t\t\tfsopt->flags |= CEPH_MOUNT_OPT_FSCACHE;\n\t\t\tfsopt->fscache_uniq = param->string;\n\t\t\tparam->string = NULL;\n\t\t}\n\t\tbreak;\n#else\n\t\treturn invalfc(fc, \"fscache support is disabled\");\n#endif\n\tcase Opt_poolperm:\n\t\tif (!result.negated)\n\t\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_NOPOOLPERM;\n\t\telse\n\t\t\tfsopt->flags |= CEPH_MOUNT_OPT_NOPOOLPERM;\n\t\tbreak;\n\tcase Opt_require_active_mds:\n\t\tif (!result.negated)\n\t\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_MOUNTWAIT;\n\t\telse\n\t\t\tfsopt->flags |= CEPH_MOUNT_OPT_MOUNTWAIT;\n\t\tbreak;\n\tcase Opt_quotadf:\n\t\tif (!result.negated)\n\t\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_NOQUOTADF;\n\t\telse\n\t\t\tfsopt->flags |= CEPH_MOUNT_OPT_NOQUOTADF;\n\t\tbreak;\n\tcase Opt_copyfrom:\n\t\tif (!result.negated)\n\t\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_NOCOPYFROM;\n\t\telse\n\t\t\tfsopt->flags |= CEPH_MOUNT_OPT_NOCOPYFROM;\n\t\tbreak;\n\tcase Opt_acl:\n\t\tif (!result.negated) {\n#ifdef CONFIG_CEPH_FS_POSIX_ACL\n\t\t\tfc->sb_flags |= SB_POSIXACL;\n#else\n\t\t\treturn invalfc(fc, \"POSIX ACL support is disabled\");\n#endif\n\t\t} else {\n\t\t\tfc->sb_flags &= ~SB_POSIXACL;\n\t\t}\n\t\tbreak;\n\tcase Opt_wsync:\n\t\tif (!result.negated)\n\t\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_ASYNC_DIROPS;\n\t\telse\n\t\t\tfsopt->flags |= CEPH_MOUNT_OPT_ASYNC_DIROPS;\n\t\tbreak;\n\tcase Opt_pagecache:\n\t\tif (result.negated)\n\t\t\tfsopt->flags |= CEPH_MOUNT_OPT_NOPAGECACHE;\n\t\telse\n\t\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_NOPAGECACHE;\n\t\tbreak;\n\tcase Opt_sparseread:\n\t\tif (result.negated)\n\t\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_SPARSEREAD;\n\t\telse\n\t\t\tfsopt->flags |= CEPH_MOUNT_OPT_SPARSEREAD;\n\t\tbreak;\n\tcase Opt_test_dummy_encryption:\n#ifdef CONFIG_FS_ENCRYPTION\n\t\tfscrypt_free_dummy_policy(&fsopt->dummy_enc_policy);\n\t\tret = fscrypt_parse_test_dummy_encryption(param,\n\t\t\t\t\t\t&fsopt->dummy_enc_policy);\n\t\tif (ret == -EINVAL) {\n\t\t\twarnfc(fc, \"Value of option \\\"%s\\\" is unrecognized\",\n\t\t\t       param->key);\n\t\t} else if (ret == -EEXIST) {\n\t\t\twarnfc(fc, \"Conflicting test_dummy_encryption options\");\n\t\t\tret = -EINVAL;\n\t\t}\n#else\n\t\twarnfc(fc,\n\t\t       \"FS encryption not supported: test_dummy_encryption mount option ignored\");\n#endif\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n\nout_of_range:\n\treturn invalfc(fc, \"%s out of range\", param->key);\n}\n\nstatic void destroy_mount_options(struct ceph_mount_options *args)\n{\n\tdout(\"destroy_mount_options %p\\n\", args);\n\tif (!args)\n\t\treturn;\n\n\tkfree(args->snapdir_name);\n\tkfree(args->mds_namespace);\n\tkfree(args->server_path);\n\tkfree(args->fscache_uniq);\n\tkfree(args->mon_addr);\n\tfscrypt_free_dummy_policy(&args->dummy_enc_policy);\n\tkfree(args);\n}\n\nstatic int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}\n\nstatic int compare_mount_options(struct ceph_mount_options *new_fsopt,\n\t\t\t\t struct ceph_options *new_opt,\n\t\t\t\t struct ceph_fs_client *fsc)\n{\n\tstruct ceph_mount_options *fsopt1 = new_fsopt;\n\tstruct ceph_mount_options *fsopt2 = fsc->mount_options;\n\tint ofs = offsetof(struct ceph_mount_options, snapdir_name);\n\tint ret;\n\n\tret = memcmp(fsopt1, fsopt2, ofs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = strcmp_null(fsopt1->snapdir_name, fsopt2->snapdir_name);\n\tif (ret)\n\t\treturn ret;\n\n\tret = strcmp_null(fsopt1->mds_namespace, fsopt2->mds_namespace);\n\tif (ret)\n\t\treturn ret;\n\n\tret = strcmp_null(fsopt1->server_path, fsopt2->server_path);\n\tif (ret)\n\t\treturn ret;\n\n\tret = strcmp_null(fsopt1->fscache_uniq, fsopt2->fscache_uniq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = strcmp_null(fsopt1->mon_addr, fsopt2->mon_addr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ceph_compare_options(new_opt, fsc->client);\n}\n\n \nstatic int ceph_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(root->d_sb);\n\tstruct ceph_mount_options *fsopt = fsc->mount_options;\n\tsize_t pos;\n\tint ret;\n\n\t \n\tseq_putc(m, ',');\n\tpos = m->count;\n\n\tret = ceph_print_client_options(m, fsc->client, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (m->count == pos)\n\t\tm->count--;\n\n\tif (fsopt->flags & CEPH_MOUNT_OPT_DIRSTAT)\n\t\tseq_puts(m, \",dirstat\");\n\tif ((fsopt->flags & CEPH_MOUNT_OPT_RBYTES))\n\t\tseq_puts(m, \",rbytes\");\n\tif (fsopt->flags & CEPH_MOUNT_OPT_NOASYNCREADDIR)\n\t\tseq_puts(m, \",noasyncreaddir\");\n\tif ((fsopt->flags & CEPH_MOUNT_OPT_DCACHE) == 0)\n\t\tseq_puts(m, \",nodcache\");\n\tif (fsopt->flags & CEPH_MOUNT_OPT_INO32)\n\t\tseq_puts(m, \",ino32\");\n\tif (fsopt->flags & CEPH_MOUNT_OPT_FSCACHE) {\n\t\tseq_show_option(m, \"fsc\", fsopt->fscache_uniq);\n\t}\n\tif (fsopt->flags & CEPH_MOUNT_OPT_NOPOOLPERM)\n\t\tseq_puts(m, \",nopoolperm\");\n\tif (fsopt->flags & CEPH_MOUNT_OPT_NOQUOTADF)\n\t\tseq_puts(m, \",noquotadf\");\n\n#ifdef CONFIG_CEPH_FS_POSIX_ACL\n\tif (root->d_sb->s_flags & SB_POSIXACL)\n\t\tseq_puts(m, \",acl\");\n\telse\n\t\tseq_puts(m, \",noacl\");\n#endif\n\n\tif ((fsopt->flags & CEPH_MOUNT_OPT_NOCOPYFROM) == 0)\n\t\tseq_puts(m, \",copyfrom\");\n\n\t \n\tif (fsopt->mds_namespace && !fsopt->new_dev_syntax)\n\t\tseq_show_option(m, \"mds_namespace\", fsopt->mds_namespace);\n\n\tif (fsopt->mon_addr)\n\t\tseq_printf(m, \",mon_addr=%s\", fsopt->mon_addr);\n\n\tif (fsopt->flags & CEPH_MOUNT_OPT_CLEANRECOVER)\n\t\tseq_show_option(m, \"recover_session\", \"clean\");\n\n\tif (!(fsopt->flags & CEPH_MOUNT_OPT_ASYNC_DIROPS))\n\t\tseq_puts(m, \",wsync\");\n\tif (fsopt->flags & CEPH_MOUNT_OPT_NOPAGECACHE)\n\t\tseq_puts(m, \",nopagecache\");\n\tif (fsopt->flags & CEPH_MOUNT_OPT_SPARSEREAD)\n\t\tseq_puts(m, \",sparseread\");\n\n\tfscrypt_show_test_dummy_encryption(m, ',', root->d_sb);\n\n\tif (fsopt->wsize != CEPH_MAX_WRITE_SIZE)\n\t\tseq_printf(m, \",wsize=%u\", fsopt->wsize);\n\tif (fsopt->rsize != CEPH_MAX_READ_SIZE)\n\t\tseq_printf(m, \",rsize=%u\", fsopt->rsize);\n\tif (fsopt->rasize != CEPH_RASIZE_DEFAULT)\n\t\tseq_printf(m, \",rasize=%u\", fsopt->rasize);\n\tif (fsopt->congestion_kb != default_congestion_kb())\n\t\tseq_printf(m, \",write_congestion_kb=%u\", fsopt->congestion_kb);\n\tif (fsopt->caps_max)\n\t\tseq_printf(m, \",caps_max=%d\", fsopt->caps_max);\n\tif (fsopt->caps_wanted_delay_min != CEPH_CAPS_WANTED_DELAY_MIN_DEFAULT)\n\t\tseq_printf(m, \",caps_wanted_delay_min=%u\",\n\t\t\t fsopt->caps_wanted_delay_min);\n\tif (fsopt->caps_wanted_delay_max != CEPH_CAPS_WANTED_DELAY_MAX_DEFAULT)\n\t\tseq_printf(m, \",caps_wanted_delay_max=%u\",\n\t\t\t   fsopt->caps_wanted_delay_max);\n\tif (fsopt->max_readdir != CEPH_MAX_READDIR_DEFAULT)\n\t\tseq_printf(m, \",readdir_max_entries=%u\", fsopt->max_readdir);\n\tif (fsopt->max_readdir_bytes != CEPH_MAX_READDIR_BYTES_DEFAULT)\n\t\tseq_printf(m, \",readdir_max_bytes=%u\", fsopt->max_readdir_bytes);\n\tif (strcmp(fsopt->snapdir_name, CEPH_SNAPDIRNAME_DEFAULT))\n\t\tseq_show_option(m, \"snapdirname\", fsopt->snapdir_name);\n\n\treturn 0;\n}\n\n \nstatic int extra_mon_dispatch(struct ceph_client *client, struct ceph_msg *msg)\n{\n\tstruct ceph_fs_client *fsc = client->private;\n\tint type = le16_to_cpu(msg->hdr.type);\n\n\tswitch (type) {\n\tcase CEPH_MSG_MDS_MAP:\n\t\tceph_mdsc_handle_mdsmap(fsc->mdsc, msg);\n\t\treturn 0;\n\tcase CEPH_MSG_FS_MAP_USER:\n\t\tceph_mdsc_handle_fsmap(fsc->mdsc, msg);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n \nstatic struct ceph_fs_client *create_fs_client(struct ceph_mount_options *fsopt,\n\t\t\t\t\tstruct ceph_options *opt)\n{\n\tstruct ceph_fs_client *fsc;\n\tint err;\n\n\tfsc = kzalloc(sizeof(*fsc), GFP_KERNEL);\n\tif (!fsc) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tfsc->client = ceph_create_client(opt, fsc);\n\tif (IS_ERR(fsc->client)) {\n\t\terr = PTR_ERR(fsc->client);\n\t\tgoto fail;\n\t}\n\topt = NULL;  \n\n\tfsc->client->extra_mon_dispatch = extra_mon_dispatch;\n\tceph_set_opt(fsc->client, ABORT_ON_FULL);\n\n\tif (!fsopt->mds_namespace) {\n\t\tceph_monc_want_map(&fsc->client->monc, CEPH_SUB_MDSMAP,\n\t\t\t\t   0, true);\n\t} else {\n\t\tceph_monc_want_map(&fsc->client->monc, CEPH_SUB_FSMAP,\n\t\t\t\t   0, false);\n\t}\n\n\tfsc->mount_options = fsopt;\n\n\tfsc->sb = NULL;\n\tfsc->mount_state = CEPH_MOUNT_MOUNTING;\n\tfsc->filp_gen = 1;\n\tfsc->have_copy_from2 = true;\n\n\tatomic_long_set(&fsc->writeback_count, 0);\n\tfsc->write_congested = false;\n\n\terr = -ENOMEM;\n\t \n\tfsc->inode_wq = alloc_workqueue(\"ceph-inode\", WQ_UNBOUND, 0);\n\tif (!fsc->inode_wq)\n\t\tgoto fail_client;\n\tfsc->cap_wq = alloc_workqueue(\"ceph-cap\", 0, 1);\n\tif (!fsc->cap_wq)\n\t\tgoto fail_inode_wq;\n\n\thash_init(fsc->async_unlink_conflict);\n\tspin_lock_init(&fsc->async_unlink_conflict_lock);\n\n\tspin_lock(&ceph_fsc_lock);\n\tlist_add_tail(&fsc->metric_wakeup, &ceph_fsc_list);\n\tspin_unlock(&ceph_fsc_lock);\n\n\treturn fsc;\n\nfail_inode_wq:\n\tdestroy_workqueue(fsc->inode_wq);\nfail_client:\n\tceph_destroy_client(fsc->client);\nfail:\n\tkfree(fsc);\n\tif (opt)\n\t\tceph_destroy_options(opt);\n\tdestroy_mount_options(fsopt);\n\treturn ERR_PTR(err);\n}\n\nstatic void flush_fs_workqueues(struct ceph_fs_client *fsc)\n{\n\tflush_workqueue(fsc->inode_wq);\n\tflush_workqueue(fsc->cap_wq);\n}\n\nstatic void destroy_fs_client(struct ceph_fs_client *fsc)\n{\n\tdout(\"destroy_fs_client %p\\n\", fsc);\n\n\tspin_lock(&ceph_fsc_lock);\n\tlist_del(&fsc->metric_wakeup);\n\tspin_unlock(&ceph_fsc_lock);\n\n\tceph_mdsc_destroy(fsc);\n\tdestroy_workqueue(fsc->inode_wq);\n\tdestroy_workqueue(fsc->cap_wq);\n\n\tdestroy_mount_options(fsc->mount_options);\n\n\tceph_destroy_client(fsc->client);\n\n\tkfree(fsc);\n\tdout(\"destroy_fs_client %p done\\n\", fsc);\n}\n\n \nstruct kmem_cache *ceph_inode_cachep;\nstruct kmem_cache *ceph_cap_cachep;\nstruct kmem_cache *ceph_cap_snap_cachep;\nstruct kmem_cache *ceph_cap_flush_cachep;\nstruct kmem_cache *ceph_dentry_cachep;\nstruct kmem_cache *ceph_file_cachep;\nstruct kmem_cache *ceph_dir_file_cachep;\nstruct kmem_cache *ceph_mds_request_cachep;\nmempool_t *ceph_wb_pagevec_pool;\n\nstatic void ceph_inode_init_once(void *foo)\n{\n\tstruct ceph_inode_info *ci = foo;\n\tinode_init_once(&ci->netfs.inode);\n}\n\nstatic int __init init_caches(void)\n{\n\tint error = -ENOMEM;\n\n\tceph_inode_cachep = kmem_cache_create(\"ceph_inode_info\",\n\t\t\t\t      sizeof(struct ceph_inode_info),\n\t\t\t\t      __alignof__(struct ceph_inode_info),\n\t\t\t\t      SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD|\n\t\t\t\t      SLAB_ACCOUNT, ceph_inode_init_once);\n\tif (!ceph_inode_cachep)\n\t\treturn -ENOMEM;\n\n\tceph_cap_cachep = KMEM_CACHE(ceph_cap, SLAB_MEM_SPREAD);\n\tif (!ceph_cap_cachep)\n\t\tgoto bad_cap;\n\tceph_cap_snap_cachep = KMEM_CACHE(ceph_cap_snap, SLAB_MEM_SPREAD);\n\tif (!ceph_cap_snap_cachep)\n\t\tgoto bad_cap_snap;\n\tceph_cap_flush_cachep = KMEM_CACHE(ceph_cap_flush,\n\t\t\t\t\t   SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD);\n\tif (!ceph_cap_flush_cachep)\n\t\tgoto bad_cap_flush;\n\n\tceph_dentry_cachep = KMEM_CACHE(ceph_dentry_info,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD);\n\tif (!ceph_dentry_cachep)\n\t\tgoto bad_dentry;\n\n\tceph_file_cachep = KMEM_CACHE(ceph_file_info, SLAB_MEM_SPREAD);\n\tif (!ceph_file_cachep)\n\t\tgoto bad_file;\n\n\tceph_dir_file_cachep = KMEM_CACHE(ceph_dir_file_info, SLAB_MEM_SPREAD);\n\tif (!ceph_dir_file_cachep)\n\t\tgoto bad_dir_file;\n\n\tceph_mds_request_cachep = KMEM_CACHE(ceph_mds_request, SLAB_MEM_SPREAD);\n\tif (!ceph_mds_request_cachep)\n\t\tgoto bad_mds_req;\n\n\tceph_wb_pagevec_pool = mempool_create_kmalloc_pool(10, CEPH_MAX_WRITE_SIZE >> PAGE_SHIFT);\n\tif (!ceph_wb_pagevec_pool)\n\t\tgoto bad_pagevec_pool;\n\n\treturn 0;\n\nbad_pagevec_pool:\n\tkmem_cache_destroy(ceph_mds_request_cachep);\nbad_mds_req:\n\tkmem_cache_destroy(ceph_dir_file_cachep);\nbad_dir_file:\n\tkmem_cache_destroy(ceph_file_cachep);\nbad_file:\n\tkmem_cache_destroy(ceph_dentry_cachep);\nbad_dentry:\n\tkmem_cache_destroy(ceph_cap_flush_cachep);\nbad_cap_flush:\n\tkmem_cache_destroy(ceph_cap_snap_cachep);\nbad_cap_snap:\n\tkmem_cache_destroy(ceph_cap_cachep);\nbad_cap:\n\tkmem_cache_destroy(ceph_inode_cachep);\n\treturn error;\n}\n\nstatic void destroy_caches(void)\n{\n\t \n\trcu_barrier();\n\n\tkmem_cache_destroy(ceph_inode_cachep);\n\tkmem_cache_destroy(ceph_cap_cachep);\n\tkmem_cache_destroy(ceph_cap_snap_cachep);\n\tkmem_cache_destroy(ceph_cap_flush_cachep);\n\tkmem_cache_destroy(ceph_dentry_cachep);\n\tkmem_cache_destroy(ceph_file_cachep);\n\tkmem_cache_destroy(ceph_dir_file_cachep);\n\tkmem_cache_destroy(ceph_mds_request_cachep);\n\tmempool_destroy(ceph_wb_pagevec_pool);\n}\n\nstatic void __ceph_umount_begin(struct ceph_fs_client *fsc)\n{\n\tceph_osdc_abort_requests(&fsc->client->osdc, -EIO);\n\tceph_mdsc_force_umount(fsc->mdsc);\n\tfsc->filp_gen++; \n}\n\n \nvoid ceph_umount_begin(struct super_block *sb)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\n\tdout(\"ceph_umount_begin - starting forced umount\\n\");\n\tif (!fsc)\n\t\treturn;\n\tfsc->mount_state = CEPH_MOUNT_SHUTDOWN;\n\t__ceph_umount_begin(fsc);\n}\n\nstatic const struct super_operations ceph_super_ops = {\n\t.alloc_inode\t= ceph_alloc_inode,\n\t.free_inode\t= ceph_free_inode,\n\t.write_inode    = ceph_write_inode,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= ceph_evict_inode,\n\t.sync_fs        = ceph_sync_fs,\n\t.put_super\t= ceph_put_super,\n\t.show_options   = ceph_show_options,\n\t.statfs\t\t= ceph_statfs,\n\t.umount_begin   = ceph_umount_begin,\n};\n\n \nstatic struct dentry *open_root_dentry(struct ceph_fs_client *fsc,\n\t\t\t\t       const char *path,\n\t\t\t\t       unsigned long started)\n{\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req = NULL;\n\tint err;\n\tstruct dentry *root;\n\n\t \n\tdout(\"open_root_inode opening '%s'\\n\", path);\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_GETATTR, USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn ERR_CAST(req);\n\treq->r_path1 = kstrdup(path, GFP_NOFS);\n\tif (!req->r_path1) {\n\t\troot = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\treq->r_ino1.ino = CEPH_INO_ROOT;\n\treq->r_ino1.snap = CEPH_NOSNAP;\n\treq->r_started = started;\n\treq->r_timeout = fsc->client->options->mount_timeout;\n\treq->r_args.getattr.mask = cpu_to_le32(CEPH_STAT_CAP_INODE);\n\treq->r_num_caps = 2;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (err == 0) {\n\t\tstruct inode *inode = req->r_target_inode;\n\t\treq->r_target_inode = NULL;\n\t\tdout(\"open_root_inode success\\n\");\n\t\troot = d_make_root(inode);\n\t\tif (!root) {\n\t\t\troot = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t\tdout(\"open_root_inode success, root dentry is %p\\n\", root);\n\t} else {\n\t\troot = ERR_PTR(err);\n\t}\nout:\n\tceph_mdsc_put_request(req);\n\treturn root;\n}\n\n#ifdef CONFIG_FS_ENCRYPTION\nstatic int ceph_apply_test_dummy_encryption(struct super_block *sb,\n\t\t\t\t\t    struct fs_context *fc,\n\t\t\t\t\t    struct ceph_mount_options *fsopt)\n{\n\tstruct ceph_fs_client *fsc = sb->s_fs_info;\n\n\tif (!fscrypt_is_dummy_policy_set(&fsopt->dummy_enc_policy))\n\t\treturn 0;\n\n\t \n\tif (fc->purpose == FS_CONTEXT_FOR_RECONFIGURE &&\n\t    !fscrypt_is_dummy_policy_set(&fsc->fsc_dummy_enc_policy)) {\n\t\tif (fscrypt_dummy_policies_equal(&fsopt->dummy_enc_policy,\n\t\t\t\t\t\t &fsc->fsc_dummy_enc_policy))\n\t\t\treturn 0;\n\t\terrorfc(fc, \"Can't set test_dummy_encryption on remount\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (fscrypt_is_dummy_policy_set(&fsc->fsc_dummy_enc_policy)) {\n\t\tif (fscrypt_dummy_policies_equal(&fsopt->dummy_enc_policy,\n\t\t\t\t\t\t &fsc->fsc_dummy_enc_policy))\n\t\t\treturn 0;\n\t\terrorfc(fc, \"Conflicting test_dummy_encryption options\");\n\t\treturn -EINVAL;\n\t}\n\n\tfsc->fsc_dummy_enc_policy = fsopt->dummy_enc_policy;\n\tmemset(&fsopt->dummy_enc_policy, 0, sizeof(fsopt->dummy_enc_policy));\n\n\twarnfc(fc, \"test_dummy_encryption mode enabled\");\n\treturn 0;\n}\n#else\nstatic int ceph_apply_test_dummy_encryption(struct super_block *sb,\n\t\t\t\t\t    struct fs_context *fc,\n\t\t\t\t\t    struct ceph_mount_options *fsopt)\n{\n\treturn 0;\n}\n#endif\n\n \nstatic struct dentry *ceph_real_mount(struct ceph_fs_client *fsc,\n\t\t\t\t      struct fs_context *fc)\n{\n\tint err;\n\tunsigned long started = jiffies;   \n\tstruct dentry *root;\n\n\tdout(\"mount start %p\\n\", fsc);\n\tmutex_lock(&fsc->client->mount_mutex);\n\n\tif (!fsc->sb->s_root) {\n\t\tconst char *path = fsc->mount_options->server_path ?\n\t\t\t\t     fsc->mount_options->server_path + 1 : \"\";\n\n\t\terr = __ceph_open_session(fsc->client, started);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (fsc->mount_options->flags & CEPH_MOUNT_OPT_FSCACHE) {\n\t\t\terr = ceph_fscache_register_fs(fsc, fc);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\terr = ceph_apply_test_dummy_encryption(fsc->sb, fc,\n\t\t\t\t\t\t       fsc->mount_options);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tdout(\"mount opening path '%s'\\n\", path);\n\n\t\tceph_fs_debugfs_init(fsc);\n\n\t\troot = open_root_dentry(fsc, path, started);\n\t\tif (IS_ERR(root)) {\n\t\t\terr = PTR_ERR(root);\n\t\t\tgoto out;\n\t\t}\n\t\tfsc->sb->s_root = dget(root);\n\t} else {\n\t\troot = dget(fsc->sb->s_root);\n\t}\n\n\tfsc->mount_state = CEPH_MOUNT_MOUNTED;\n\tdout(\"mount success\\n\");\n\tmutex_unlock(&fsc->client->mount_mutex);\n\treturn root;\n\nout:\n\tmutex_unlock(&fsc->client->mount_mutex);\n\tceph_fscrypt_free_dummy_policy(fsc);\n\treturn ERR_PTR(err);\n}\n\nstatic int ceph_set_super(struct super_block *s, struct fs_context *fc)\n{\n\tstruct ceph_fs_client *fsc = s->s_fs_info;\n\tint ret;\n\n\tdout(\"set_super %p\\n\", s);\n\n\ts->s_maxbytes = MAX_LFS_FILESIZE;\n\n\ts->s_xattr = ceph_xattr_handlers;\n\tfsc->sb = s;\n\tfsc->max_file_size = 1ULL << 40;  \n\n\ts->s_op = &ceph_super_ops;\n\ts->s_d_op = &ceph_dentry_ops;\n\ts->s_export_op = &ceph_export_ops;\n\n\ts->s_time_gran = 1;\n\ts->s_time_min = 0;\n\ts->s_time_max = U32_MAX;\n\ts->s_flags |= SB_NODIRATIME | SB_NOATIME;\n\n\tceph_fscrypt_set_ops(s);\n\n\tret = set_anon_super_fc(s, fc);\n\tif (ret != 0)\n\t\tfsc->sb = NULL;\n\treturn ret;\n}\n\n \nstatic int ceph_compare_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct ceph_fs_client *new = fc->s_fs_info;\n\tstruct ceph_mount_options *fsopt = new->mount_options;\n\tstruct ceph_options *opt = new->client->options;\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\n\tdout(\"ceph_compare_super %p\\n\", sb);\n\n\tif (compare_mount_options(fsopt, opt, fsc)) {\n\t\tdout(\"monitor(s)/mount options don't match\\n\");\n\t\treturn 0;\n\t}\n\tif ((opt->flags & CEPH_OPT_FSID) &&\n\t    ceph_fsid_compare(&opt->fsid, &fsc->client->fsid)) {\n\t\tdout(\"fsid doesn't match\\n\");\n\t\treturn 0;\n\t}\n\tif (fc->sb_flags != (sb->s_flags & ~SB_BORN)) {\n\t\tdout(\"flags differ\\n\");\n\t\treturn 0;\n\t}\n\n\tif (fsc->blocklisted && !ceph_test_mount_opt(fsc, CLEANRECOVER)) {\n\t\tdout(\"client is blocklisted (and CLEANRECOVER is not set)\\n\");\n\t\treturn 0;\n\t}\n\n\tif (fsc->mount_state == CEPH_MOUNT_SHUTDOWN) {\n\t\tdout(\"client has been forcibly unmounted\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic atomic_long_t bdi_seq = ATOMIC_LONG_INIT(0);\n\nstatic int ceph_setup_bdi(struct super_block *sb, struct ceph_fs_client *fsc)\n{\n\tint err;\n\n\terr = super_setup_bdi_name(sb, \"ceph-%ld\",\n\t\t\t\t   atomic_long_inc_return(&bdi_seq));\n\tif (err)\n\t\treturn err;\n\n\t \n\tsb->s_bdi->ra_pages = fsc->mount_options->rasize >> PAGE_SHIFT;\n\n\t \n\tsb->s_bdi->io_pages = fsc->mount_options->rsize >> PAGE_SHIFT;\n\n\treturn 0;\n}\n\nstatic int ceph_get_tree(struct fs_context *fc)\n{\n\tstruct ceph_parse_opts_ctx *pctx = fc->fs_private;\n\tstruct ceph_mount_options *fsopt = pctx->opts;\n\tstruct super_block *sb;\n\tstruct ceph_fs_client *fsc;\n\tstruct dentry *res;\n\tint (*compare_super)(struct super_block *, struct fs_context *) =\n\t\tceph_compare_super;\n\tint err;\n\n\tdout(\"ceph_get_tree\\n\");\n\n\tif (!fc->source)\n\t\treturn invalfc(fc, \"No source\");\n\tif (fsopt->new_dev_syntax && !fsopt->mon_addr)\n\t\treturn invalfc(fc, \"No monitor address\");\n\n\t \n\tfsc = create_fs_client(pctx->opts, pctx->copts);\n\tpctx->opts = NULL;\n\tpctx->copts = NULL;\n\tif (IS_ERR(fsc)) {\n\t\terr = PTR_ERR(fsc);\n\t\tgoto out_final;\n\t}\n\n\terr = ceph_mdsc_init(fsc);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (ceph_test_opt(fsc->client, NOSHARE))\n\t\tcompare_super = NULL;\n\n\tfc->s_fs_info = fsc;\n\tsb = sget_fc(fc, compare_super, ceph_set_super);\n\tfc->s_fs_info = NULL;\n\tif (IS_ERR(sb)) {\n\t\terr = PTR_ERR(sb);\n\t\tgoto out;\n\t}\n\n\tif (ceph_sb_to_client(sb) != fsc) {\n\t\tdestroy_fs_client(fsc);\n\t\tfsc = ceph_sb_to_client(sb);\n\t\tdout(\"get_sb got existing client %p\\n\", fsc);\n\t} else {\n\t\tdout(\"get_sb using new client %p\\n\", fsc);\n\t\terr = ceph_setup_bdi(sb, fsc);\n\t\tif (err < 0)\n\t\t\tgoto out_splat;\n\t}\n\n\tres = ceph_real_mount(fsc, fc);\n\tif (IS_ERR(res)) {\n\t\terr = PTR_ERR(res);\n\t\tgoto out_splat;\n\t}\n\tdout(\"root %p inode %p ino %llx.%llx\\n\", res,\n\t     d_inode(res), ceph_vinop(d_inode(res)));\n\tfc->root = fsc->sb->s_root;\n\treturn 0;\n\nout_splat:\n\tif (!ceph_mdsmap_is_cluster_available(fsc->mdsc->mdsmap)) {\n\t\tpr_info(\"No mds server is up or the cluster is laggy\\n\");\n\t\terr = -EHOSTUNREACH;\n\t}\n\n\tceph_mdsc_close_sessions(fsc->mdsc);\n\tdeactivate_locked_super(sb);\n\tgoto out_final;\n\nout:\n\tdestroy_fs_client(fsc);\nout_final:\n\tdout(\"ceph_get_tree fail %d\\n\", err);\n\treturn err;\n}\n\nstatic void ceph_free_fc(struct fs_context *fc)\n{\n\tstruct ceph_parse_opts_ctx *pctx = fc->fs_private;\n\n\tif (pctx) {\n\t\tdestroy_mount_options(pctx->opts);\n\t\tceph_destroy_options(pctx->copts);\n\t\tkfree(pctx);\n\t}\n}\n\nstatic int ceph_reconfigure_fc(struct fs_context *fc)\n{\n\tint err;\n\tstruct ceph_parse_opts_ctx *pctx = fc->fs_private;\n\tstruct ceph_mount_options *fsopt = pctx->opts;\n\tstruct super_block *sb = fc->root->d_sb;\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\n\terr = ceph_apply_test_dummy_encryption(sb, fc, fsopt);\n\tif (err)\n\t\treturn err;\n\n\tif (fsopt->flags & CEPH_MOUNT_OPT_ASYNC_DIROPS)\n\t\tceph_set_mount_opt(fsc, ASYNC_DIROPS);\n\telse\n\t\tceph_clear_mount_opt(fsc, ASYNC_DIROPS);\n\n\tif (fsopt->flags & CEPH_MOUNT_OPT_SPARSEREAD)\n\t\tceph_set_mount_opt(fsc, SPARSEREAD);\n\telse\n\t\tceph_clear_mount_opt(fsc, SPARSEREAD);\n\n\tif (strcmp_null(fsc->mount_options->mon_addr, fsopt->mon_addr)) {\n\t\tkfree(fsc->mount_options->mon_addr);\n\t\tfsc->mount_options->mon_addr = fsopt->mon_addr;\n\t\tfsopt->mon_addr = NULL;\n\t\tpr_notice(\"ceph: monitor addresses recorded, but not used for reconnection\");\n\t}\n\n\tsync_filesystem(sb);\n\treturn 0;\n}\n\nstatic const struct fs_context_operations ceph_context_ops = {\n\t.free\t\t= ceph_free_fc,\n\t.parse_param\t= ceph_parse_mount_param,\n\t.get_tree\t= ceph_get_tree,\n\t.reconfigure\t= ceph_reconfigure_fc,\n};\n\n \nstatic int ceph_init_fs_context(struct fs_context *fc)\n{\n\tstruct ceph_parse_opts_ctx *pctx;\n\tstruct ceph_mount_options *fsopt;\n\n\tpctx = kzalloc(sizeof(*pctx), GFP_KERNEL);\n\tif (!pctx)\n\t\treturn -ENOMEM;\n\n\tpctx->copts = ceph_alloc_options();\n\tif (!pctx->copts)\n\t\tgoto nomem;\n\n\tpctx->opts = kzalloc(sizeof(*pctx->opts), GFP_KERNEL);\n\tif (!pctx->opts)\n\t\tgoto nomem;\n\n\tfsopt = pctx->opts;\n\tfsopt->flags = CEPH_MOUNT_OPT_DEFAULT;\n\n\tfsopt->wsize = CEPH_MAX_WRITE_SIZE;\n\tfsopt->rsize = CEPH_MAX_READ_SIZE;\n\tfsopt->rasize = CEPH_RASIZE_DEFAULT;\n\tfsopt->snapdir_name = kstrdup(CEPH_SNAPDIRNAME_DEFAULT, GFP_KERNEL);\n\tif (!fsopt->snapdir_name)\n\t\tgoto nomem;\n\n\tfsopt->caps_wanted_delay_min = CEPH_CAPS_WANTED_DELAY_MIN_DEFAULT;\n\tfsopt->caps_wanted_delay_max = CEPH_CAPS_WANTED_DELAY_MAX_DEFAULT;\n\tfsopt->max_readdir = CEPH_MAX_READDIR_DEFAULT;\n\tfsopt->max_readdir_bytes = CEPH_MAX_READDIR_BYTES_DEFAULT;\n\tfsopt->congestion_kb = default_congestion_kb();\n\n#ifdef CONFIG_CEPH_FS_POSIX_ACL\n\tfc->sb_flags |= SB_POSIXACL;\n#endif\n\n\tfc->fs_private = pctx;\n\tfc->ops = &ceph_context_ops;\n\treturn 0;\n\nnomem:\n\tdestroy_mount_options(pctx->opts);\n\tceph_destroy_options(pctx->copts);\n\tkfree(pctx);\n\treturn -ENOMEM;\n}\n\n \nstatic bool __inc_stopping_blocker(struct ceph_mds_client *mdsc)\n{\n\tspin_lock(&mdsc->stopping_lock);\n\tif (mdsc->stopping >= CEPH_MDSC_STOPPING_FLUSHING) {\n\t\tspin_unlock(&mdsc->stopping_lock);\n\t\treturn false;\n\t}\n\tatomic_inc(&mdsc->stopping_blockers);\n\tspin_unlock(&mdsc->stopping_lock);\n\treturn true;\n}\n\nstatic void __dec_stopping_blocker(struct ceph_mds_client *mdsc)\n{\n\tspin_lock(&mdsc->stopping_lock);\n\tif (!atomic_dec_return(&mdsc->stopping_blockers) &&\n\t    mdsc->stopping >= CEPH_MDSC_STOPPING_FLUSHING)\n\t\tcomplete_all(&mdsc->stopping_waiter);\n\tspin_unlock(&mdsc->stopping_lock);\n}\n\n \nbool ceph_inc_mds_stopping_blocker(struct ceph_mds_client *mdsc,\n\t\t\t\t   struct ceph_mds_session *session)\n{\n\tmutex_lock(&session->s_mutex);\n\tinc_session_sequence(session);\n\tmutex_unlock(&session->s_mutex);\n\n\treturn __inc_stopping_blocker(mdsc);\n}\n\nvoid ceph_dec_mds_stopping_blocker(struct ceph_mds_client *mdsc)\n{\n\t__dec_stopping_blocker(mdsc);\n}\n\n \nbool ceph_inc_osd_stopping_blocker(struct ceph_mds_client *mdsc)\n{\n\treturn __inc_stopping_blocker(mdsc);\n}\n\nvoid ceph_dec_osd_stopping_blocker(struct ceph_mds_client *mdsc)\n{\n\t__dec_stopping_blocker(mdsc);\n}\n\nstatic void ceph_kill_sb(struct super_block *s)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(s);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tbool wait;\n\n\tdout(\"kill_sb %p\\n\", s);\n\n\tceph_mdsc_pre_umount(mdsc);\n\tflush_fs_workqueues(fsc);\n\n\t \n\tsync_filesystem(s);\n\n\tspin_lock(&mdsc->stopping_lock);\n\tmdsc->stopping = CEPH_MDSC_STOPPING_FLUSHING;\n\twait = !!atomic_read(&mdsc->stopping_blockers);\n\tspin_unlock(&mdsc->stopping_lock);\n\n\tif (wait && atomic_read(&mdsc->stopping_blockers)) {\n\t\tlong timeleft = wait_for_completion_killable_timeout(\n\t\t\t\t\t&mdsc->stopping_waiter,\n\t\t\t\t\tfsc->client->options->mount_timeout);\n\t\tif (!timeleft)  \n\t\t\tpr_warn(\"umount timed out, %ld\\n\", timeleft);\n\t\telse if (timeleft < 0)  \n\t\t\tpr_warn(\"umount was killed, %ld\\n\", timeleft);\n\t}\n\n\tmdsc->stopping = CEPH_MDSC_STOPPING_FLUSHED;\n\tkill_anon_super(s);\n\n\tfsc->client->extra_mon_dispatch = NULL;\n\tceph_fs_debugfs_cleanup(fsc);\n\n\tceph_fscache_unregister_fs(fsc);\n\n\tdestroy_fs_client(fsc);\n}\n\nstatic struct file_system_type ceph_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ceph\",\n\t.init_fs_context = ceph_init_fs_context,\n\t.kill_sb\t= ceph_kill_sb,\n\t.fs_flags\t= FS_RENAME_DOES_D_MOVE,\n};\nMODULE_ALIAS_FS(\"ceph\");\n\nint ceph_force_reconnect(struct super_block *sb)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\tint err = 0;\n\n\tfsc->mount_state = CEPH_MOUNT_RECOVER;\n\t__ceph_umount_begin(fsc);\n\n\t \n\tflush_workqueue(fsc->inode_wq);\n\n\t \n\tceph_reset_client_addr(fsc->client);\n\n\tceph_osdc_clear_abort_err(&fsc->client->osdc);\n\n\tfsc->blocklisted = false;\n\tfsc->mount_state = CEPH_MOUNT_MOUNTED;\n\n\tif (sb->s_root) {\n\t\terr = __ceph_do_getattr(d_inode(sb->s_root), NULL,\n\t\t\t\t\tCEPH_STAT_CAP_INODE, true);\n\t}\n\treturn err;\n}\n\nstatic int __init init_ceph(void)\n{\n\tint ret = init_caches();\n\tif (ret)\n\t\tgoto out;\n\n\tceph_flock_init();\n\tret = register_filesystem(&ceph_fs_type);\n\tif (ret)\n\t\tgoto out_caches;\n\n\tpr_info(\"loaded (mds proto %d)\\n\", CEPH_MDSC_PROTOCOL);\n\n\treturn 0;\n\nout_caches:\n\tdestroy_caches();\nout:\n\treturn ret;\n}\n\nstatic void __exit exit_ceph(void)\n{\n\tdout(\"exit_ceph\\n\");\n\tunregister_filesystem(&ceph_fs_type);\n\tdestroy_caches();\n}\n\nstatic int param_set_metrics(const char *val, const struct kernel_param *kp)\n{\n\tstruct ceph_fs_client *fsc;\n\tint ret;\n\n\tret = param_set_bool(val, kp);\n\tif (ret) {\n\t\tpr_err(\"Failed to parse sending metrics switch value '%s'\\n\",\n\t\t       val);\n\t\treturn ret;\n\t} else if (!disable_send_metrics) {\n\t\t\n\t\tspin_lock(&ceph_fsc_lock);\n\t\tlist_for_each_entry(fsc, &ceph_fsc_list, metric_wakeup) {\n\t\t\tmetric_schedule_delayed(&fsc->mdsc->metric);\n\t\t}\n\t\tspin_unlock(&ceph_fsc_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops param_ops_metrics = {\n\t.set = param_set_metrics,\n\t.get = param_get_bool,\n};\n\nbool disable_send_metrics = false;\nmodule_param_cb(disable_send_metrics, &param_ops_metrics, &disable_send_metrics, 0644);\nMODULE_PARM_DESC(disable_send_metrics, \"Enable sending perf metrics to ceph cluster (default: on)\");\n\n \nstatic bool mount_support = true;\nstatic const struct kernel_param_ops param_ops_mount_syntax = {\n\t.get = param_get_bool,\n};\nmodule_param_cb(mount_syntax_v1, &param_ops_mount_syntax, &mount_support, 0444);\nmodule_param_cb(mount_syntax_v2, &param_ops_mount_syntax, &mount_support, 0444);\n\nmodule_init(init_ceph);\nmodule_exit(exit_ceph);\n\nMODULE_AUTHOR(\"Sage Weil <sage@newdream.net>\");\nMODULE_AUTHOR(\"Yehuda Sadeh <yehuda@hq.newdream.net>\");\nMODULE_AUTHOR(\"Patience Warnick <patience@newdream.net>\");\nMODULE_DESCRIPTION(\"Ceph filesystem for Linux\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}