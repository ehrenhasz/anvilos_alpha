{
  "module_name": "debugfs.c",
  "hash_id": "eb68d250aa68c1c7d9c92ac717453445ab0d996d8786000a8c14427c1fda17f1",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/debugfs.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/math64.h>\n#include <linux/ktime.h>\n\n#include <linux/ceph/libceph.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/debugfs.h>\n\n#include \"super.h\"\n\n#ifdef CONFIG_DEBUG_FS\n\n#include \"mds_client.h\"\n#include \"metric.h\"\n\nstatic int mdsmap_show(struct seq_file *s, void *p)\n{\n\tint i;\n\tstruct ceph_fs_client *fsc = s->private;\n\tstruct ceph_mdsmap *mdsmap;\n\n\tif (!fsc->mdsc || !fsc->mdsc->mdsmap)\n\t\treturn 0;\n\tmdsmap = fsc->mdsc->mdsmap;\n\tseq_printf(s, \"epoch %d\\n\", mdsmap->m_epoch);\n\tseq_printf(s, \"root %d\\n\", mdsmap->m_root);\n\tseq_printf(s, \"max_mds %d\\n\", mdsmap->m_max_mds);\n\tseq_printf(s, \"session_timeout %d\\n\", mdsmap->m_session_timeout);\n\tseq_printf(s, \"session_autoclose %d\\n\", mdsmap->m_session_autoclose);\n\tfor (i = 0; i < mdsmap->possible_max_rank; i++) {\n\t\tstruct ceph_entity_addr *addr = &mdsmap->m_info[i].addr;\n\t\tint state = mdsmap->m_info[i].state;\n\t\tseq_printf(s, \"\\tmds%d\\t%s\\t(%s)\\n\", i,\n\t\t\t       ceph_pr_addr(addr),\n\t\t\t       ceph_mds_state_name(state));\n\t}\n\treturn 0;\n}\n\n \nstatic int mdsc_show(struct seq_file *s, void *p)\n{\n\tstruct ceph_fs_client *fsc = s->private;\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct rb_node *rp;\n\tint pathlen = 0;\n\tu64 pathbase;\n\tchar *path;\n\n\tmutex_lock(&mdsc->mutex);\n\tfor (rp = rb_first(&mdsc->request_tree); rp; rp = rb_next(rp)) {\n\t\treq = rb_entry(rp, struct ceph_mds_request, r_node);\n\n\t\tif (req->r_request && req->r_session)\n\t\t\tseq_printf(s, \"%lld\\tmds%d\\t\", req->r_tid,\n\t\t\t\t   req->r_session->s_mds);\n\t\telse if (!req->r_request)\n\t\t\tseq_printf(s, \"%lld\\t(no request)\\t\", req->r_tid);\n\t\telse\n\t\t\tseq_printf(s, \"%lld\\t(no session)\\t\", req->r_tid);\n\n\t\tseq_printf(s, \"%s\", ceph_mds_op_name(req->r_op));\n\n\t\tif (test_bit(CEPH_MDS_R_GOT_UNSAFE, &req->r_req_flags))\n\t\t\tseq_puts(s, \"\\t(unsafe)\");\n\t\telse\n\t\t\tseq_puts(s, \"\\t\");\n\n\t\tif (req->r_inode) {\n\t\t\tseq_printf(s, \" #%llx\", ceph_ino(req->r_inode));\n\t\t} else if (req->r_dentry) {\n\t\t\tpath = ceph_mdsc_build_path(req->r_dentry, &pathlen,\n\t\t\t\t\t\t    &pathbase, 0);\n\t\t\tif (IS_ERR(path))\n\t\t\t\tpath = NULL;\n\t\t\tspin_lock(&req->r_dentry->d_lock);\n\t\t\tseq_printf(s, \" #%llx/%pd (%s)\",\n\t\t\t\t   ceph_ino(d_inode(req->r_dentry->d_parent)),\n\t\t\t\t   req->r_dentry,\n\t\t\t\t   path ? path : \"\");\n\t\t\tspin_unlock(&req->r_dentry->d_lock);\n\t\t\tceph_mdsc_free_path(path, pathlen);\n\t\t} else if (req->r_path1) {\n\t\t\tseq_printf(s, \" #%llx/%s\", req->r_ino1.ino,\n\t\t\t\t   req->r_path1);\n\t\t} else {\n\t\t\tseq_printf(s, \" #%llx\", req->r_ino1.ino);\n\t\t}\n\n\t\tif (req->r_old_dentry) {\n\t\t\tpath = ceph_mdsc_build_path(req->r_old_dentry, &pathlen,\n\t\t\t\t\t\t    &pathbase, 0);\n\t\t\tif (IS_ERR(path))\n\t\t\t\tpath = NULL;\n\t\t\tspin_lock(&req->r_old_dentry->d_lock);\n\t\t\tseq_printf(s, \" #%llx/%pd (%s)\",\n\t\t\t\t   req->r_old_dentry_dir ?\n\t\t\t\t   ceph_ino(req->r_old_dentry_dir) : 0,\n\t\t\t\t   req->r_old_dentry,\n\t\t\t\t   path ? path : \"\");\n\t\t\tspin_unlock(&req->r_old_dentry->d_lock);\n\t\t\tceph_mdsc_free_path(path, pathlen);\n\t\t} else if (req->r_path2 && req->r_op != CEPH_MDS_OP_SYMLINK) {\n\t\t\tif (req->r_ino2.ino)\n\t\t\t\tseq_printf(s, \" #%llx/%s\", req->r_ino2.ino,\n\t\t\t\t\t   req->r_path2);\n\t\t\telse\n\t\t\t\tseq_printf(s, \" %s\", req->r_path2);\n\t\t}\n\n\t\tseq_puts(s, \"\\n\");\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\n\treturn 0;\n}\n\n#define CEPH_LAT_METRIC_SHOW(name, total, avg, min, max, sq) {\t\t\\\n\ts64 _total, _avg, _min, _max, _sq, _st;\t\t\t\t\\\n\t_avg = ktime_to_us(avg);\t\t\t\t\t\\\n\t_min = ktime_to_us(min == KTIME_MAX ? 0 : min);\t\t\t\\\n\t_max = ktime_to_us(max);\t\t\t\t\t\\\n\t_total = total - 1;\t\t\t\t\t\t\\\n\t_sq = _total > 0 ? DIV64_U64_ROUND_CLOSEST(sq, _total) : 0;\t\\\n\t_st = int_sqrt64(_sq);\t\t\t\t\t\t\\\n\t_st = ktime_to_us(_st);\t\t\t\t\t\t\\\n\tseq_printf(s, \"%-14s%-12lld%-16lld%-16lld%-16lld%lld\\n\",\t\\\n\t\t   name, total, _avg, _min, _max, _st);\t\t\t\\\n}\n\n#define CEPH_SZ_METRIC_SHOW(name, total, avg, min, max, sum) {\t\t\\\n\tu64 _min = min == U64_MAX ? 0 : min;\t\t\t\t\\\n\tseq_printf(s, \"%-14s%-12lld%-16llu%-16llu%-16llu%llu\\n\",\t\\\n\t\t   name, total, avg, _min, max, sum);\t\t\t\\\n}\n\nstatic int metrics_file_show(struct seq_file *s, void *p)\n{\n\tstruct ceph_fs_client *fsc = s->private;\n\tstruct ceph_client_metric *m = &fsc->mdsc->metric;\n\n\tseq_printf(s, \"item                               total\\n\");\n\tseq_printf(s, \"------------------------------------------\\n\");\n\tseq_printf(s, \"%-35s%lld\\n\", \"total inodes\",\n\t\t   percpu_counter_sum(&m->total_inodes));\n\tseq_printf(s, \"%-35s%lld\\n\", \"opened files\",\n\t\t   atomic64_read(&m->opened_files));\n\tseq_printf(s, \"%-35s%lld\\n\", \"pinned i_caps\",\n\t\t   atomic64_read(&m->total_caps));\n\tseq_printf(s, \"%-35s%lld\\n\", \"opened inodes\",\n\t\t   percpu_counter_sum(&m->opened_inodes));\n\treturn 0;\n}\n\nstatic const char * const metric_str[] = {\n\t\"read\",\n\t\"write\",\n\t\"metadata\",\n\t\"copyfrom\"\n};\nstatic int metrics_latency_show(struct seq_file *s, void *p)\n{\n\tstruct ceph_fs_client *fsc = s->private;\n\tstruct ceph_client_metric *cm = &fsc->mdsc->metric;\n\tstruct ceph_metric *m;\n\ts64 total, avg, min, max, sq;\n\tint i;\n\n\tseq_printf(s, \"item          total       avg_lat(us)     min_lat(us)     max_lat(us)     stdev(us)\\n\");\n\tseq_printf(s, \"-----------------------------------------------------------------------------------\\n\");\n\n\tfor (i = 0; i < METRIC_MAX; i++) {\n\t\tm = &cm->metric[i];\n\t\tspin_lock(&m->lock);\n\t\ttotal = m->total;\n\t\tavg = m->latency_avg;\n\t\tmin = m->latency_min;\n\t\tmax = m->latency_max;\n\t\tsq = m->latency_sq_sum;\n\t\tspin_unlock(&m->lock);\n\t\tCEPH_LAT_METRIC_SHOW(metric_str[i], total, avg, min, max, sq);\n\t}\n\n\treturn 0;\n}\n\nstatic int metrics_size_show(struct seq_file *s, void *p)\n{\n\tstruct ceph_fs_client *fsc = s->private;\n\tstruct ceph_client_metric *cm = &fsc->mdsc->metric;\n\tstruct ceph_metric *m;\n\ts64 total;\n\tu64 sum, avg, min, max;\n\tint i;\n\n\tseq_printf(s, \"item          total       avg_sz(bytes)   min_sz(bytes)   max_sz(bytes)  total_sz(bytes)\\n\");\n\tseq_printf(s, \"----------------------------------------------------------------------------------------\\n\");\n\n\tfor (i = 0; i < METRIC_MAX; i++) {\n\t\t \n\t\tif (i == METRIC_METADATA)\n\t\t\tcontinue;\n\t\tm = &cm->metric[i];\n\t\tspin_lock(&m->lock);\n\t\ttotal = m->total;\n\t\tsum = m->size_sum;\n\t\tavg = total > 0 ? DIV64_U64_ROUND_CLOSEST(sum, total) : 0;\n\t\tmin = m->size_min;\n\t\tmax = m->size_max;\n\t\tspin_unlock(&m->lock);\n\t\tCEPH_SZ_METRIC_SHOW(metric_str[i], total, avg, min, max, sum);\n\t}\n\n\treturn 0;\n}\n\nstatic int metrics_caps_show(struct seq_file *s, void *p)\n{\n\tstruct ceph_fs_client *fsc = s->private;\n\tstruct ceph_client_metric *m = &fsc->mdsc->metric;\n\tint nr_caps = 0;\n\n\tseq_printf(s, \"item          total           miss            hit\\n\");\n\tseq_printf(s, \"-------------------------------------------------\\n\");\n\n\tseq_printf(s, \"%-14s%-16lld%-16lld%lld\\n\", \"d_lease\",\n\t\t   atomic64_read(&m->total_dentries),\n\t\t   percpu_counter_sum(&m->d_lease_mis),\n\t\t   percpu_counter_sum(&m->d_lease_hit));\n\n\tnr_caps = atomic64_read(&m->total_caps);\n\tseq_printf(s, \"%-14s%-16d%-16lld%lld\\n\", \"caps\", nr_caps,\n\t\t   percpu_counter_sum(&m->i_caps_mis),\n\t\t   percpu_counter_sum(&m->i_caps_hit));\n\n\treturn 0;\n}\n\nstatic int caps_show_cb(struct inode *inode, int mds, void *p)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct seq_file *s = p;\n\tstruct ceph_cap *cap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (cap)\n\t\tseq_printf(s, \"0x%-17llx%-3d%-17s%-17s\\n\", ceph_ino(inode),\n\t\t\t   cap->session->s_mds,\n\t\t\t   ceph_cap_string(cap->issued),\n\t\t\t   ceph_cap_string(cap->implemented));\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn 0;\n}\n\nstatic int caps_show(struct seq_file *s, void *p)\n{\n\tstruct ceph_fs_client *fsc = s->private;\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tint total, avail, used, reserved, min, i;\n\tstruct cap_wait\t*cw;\n\n\tceph_reservation_status(fsc, &total, &avail, &used, &reserved, &min);\n\tseq_printf(s, \"total\\t\\t%d\\n\"\n\t\t   \"avail\\t\\t%d\\n\"\n\t\t   \"used\\t\\t%d\\n\"\n\t\t   \"reserved\\t%d\\n\"\n\t\t   \"min\\t\\t%d\\n\\n\",\n\t\t   total, avail, used, reserved, min);\n\tseq_printf(s, \"ino              mds  issued           implemented\\n\");\n\tseq_printf(s, \"--------------------------------------------------\\n\");\n\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tstruct ceph_mds_session *session;\n\n\t\tsession = __ceph_lookup_mds_session(mdsc, i);\n\t\tif (!session)\n\t\t\tcontinue;\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tmutex_lock(&session->s_mutex);\n\t\tceph_iterate_session_caps(session, caps_show_cb, s);\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t\tmutex_lock(&mdsc->mutex);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\n\tseq_printf(s, \"\\n\\nWaiters:\\n--------\\n\");\n\tseq_printf(s, \"tgid         ino                need             want\\n\");\n\tseq_printf(s, \"-----------------------------------------------------\\n\");\n\n\tspin_lock(&mdsc->caps_list_lock);\n\tlist_for_each_entry(cw, &mdsc->cap_wait_list, list) {\n\t\tseq_printf(s, \"%-13d0x%-17llx%-17s%-17s\\n\", cw->tgid, cw->ino,\n\t\t\t\tceph_cap_string(cw->need),\n\t\t\t\tceph_cap_string(cw->want));\n\t}\n\tspin_unlock(&mdsc->caps_list_lock);\n\n\treturn 0;\n}\n\nstatic int mds_sessions_show(struct seq_file *s, void *ptr)\n{\n\tstruct ceph_fs_client *fsc = s->private;\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_auth_client *ac = fsc->client->monc.auth;\n\tstruct ceph_options *opt = fsc->client->options;\n\tint mds;\n\n\tmutex_lock(&mdsc->mutex);\n\n\t \n\tseq_printf(s, \"global_id %llu\\n\", ac->global_id);\n\n\t \n\tseq_printf(s, \"name \\\"%s\\\"\\n\", opt->name ? opt->name : \"\");\n\n\t \n\tfor (mds = 0; mds < mdsc->max_sessions; mds++) {\n\t\tstruct ceph_mds_session *session =\n\t\t\t__ceph_lookup_mds_session(mdsc, mds);\n\t\tif (!session) {\n\t\t\tcontinue;\n\t\t}\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tseq_printf(s, \"mds.%d %s\\n\",\n\t\t\t\tsession->s_mds,\n\t\t\t\tceph_session_state_name(session->s_state));\n\n\t\tceph_put_mds_session(session);\n\t\tmutex_lock(&mdsc->mutex);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\n\treturn 0;\n}\n\nstatic int status_show(struct seq_file *s, void *p)\n{\n\tstruct ceph_fs_client *fsc = s->private;\n\tstruct ceph_entity_inst *inst = &fsc->client->msgr.inst;\n\tstruct ceph_entity_addr *client_addr = ceph_client_addr(fsc->client);\n\n\tseq_printf(s, \"instance: %s.%lld %s/%u\\n\", ENTITY_NAME(inst->name),\n\t\t   ceph_pr_addr(client_addr), le32_to_cpu(client_addr->nonce));\n\tseq_printf(s, \"blocklisted: %s\\n\", fsc->blocklisted ? \"true\" : \"false\");\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(mdsmap);\nDEFINE_SHOW_ATTRIBUTE(mdsc);\nDEFINE_SHOW_ATTRIBUTE(caps);\nDEFINE_SHOW_ATTRIBUTE(mds_sessions);\nDEFINE_SHOW_ATTRIBUTE(status);\nDEFINE_SHOW_ATTRIBUTE(metrics_file);\nDEFINE_SHOW_ATTRIBUTE(metrics_latency);\nDEFINE_SHOW_ATTRIBUTE(metrics_size);\nDEFINE_SHOW_ATTRIBUTE(metrics_caps);\n\n\n \nstatic int congestion_kb_set(void *data, u64 val)\n{\n\tstruct ceph_fs_client *fsc = (struct ceph_fs_client *)data;\n\n\tfsc->mount_options->congestion_kb = (int)val;\n\treturn 0;\n}\n\nstatic int congestion_kb_get(void *data, u64 *val)\n{\n\tstruct ceph_fs_client *fsc = (struct ceph_fs_client *)data;\n\n\t*val = (u64)fsc->mount_options->congestion_kb;\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(congestion_kb_fops, congestion_kb_get,\n\t\t\tcongestion_kb_set, \"%llu\\n\");\n\n\nvoid ceph_fs_debugfs_cleanup(struct ceph_fs_client *fsc)\n{\n\tdout(\"ceph_fs_debugfs_cleanup\\n\");\n\tdebugfs_remove(fsc->debugfs_bdi);\n\tdebugfs_remove(fsc->debugfs_congestion_kb);\n\tdebugfs_remove(fsc->debugfs_mdsmap);\n\tdebugfs_remove(fsc->debugfs_mds_sessions);\n\tdebugfs_remove(fsc->debugfs_caps);\n\tdebugfs_remove(fsc->debugfs_status);\n\tdebugfs_remove(fsc->debugfs_mdsc);\n\tdebugfs_remove_recursive(fsc->debugfs_metrics_dir);\n}\n\nvoid ceph_fs_debugfs_init(struct ceph_fs_client *fsc)\n{\n\tchar name[100];\n\n\tdout(\"ceph_fs_debugfs_init\\n\");\n\tfsc->debugfs_congestion_kb =\n\t\tdebugfs_create_file(\"writeback_congestion_kb\",\n\t\t\t\t    0600,\n\t\t\t\t    fsc->client->debugfs_dir,\n\t\t\t\t    fsc,\n\t\t\t\t    &congestion_kb_fops);\n\n\tsnprintf(name, sizeof(name), \"../../bdi/%s\",\n\t\t bdi_dev_name(fsc->sb->s_bdi));\n\tfsc->debugfs_bdi =\n\t\tdebugfs_create_symlink(\"bdi\",\n\t\t\t\t       fsc->client->debugfs_dir,\n\t\t\t\t       name);\n\n\tfsc->debugfs_mdsmap = debugfs_create_file(\"mdsmap\",\n\t\t\t\t\t0400,\n\t\t\t\t\tfsc->client->debugfs_dir,\n\t\t\t\t\tfsc,\n\t\t\t\t\t&mdsmap_fops);\n\n\tfsc->debugfs_mds_sessions = debugfs_create_file(\"mds_sessions\",\n\t\t\t\t\t0400,\n\t\t\t\t\tfsc->client->debugfs_dir,\n\t\t\t\t\tfsc,\n\t\t\t\t\t&mds_sessions_fops);\n\n\tfsc->debugfs_mdsc = debugfs_create_file(\"mdsc\",\n\t\t\t\t\t\t0400,\n\t\t\t\t\t\tfsc->client->debugfs_dir,\n\t\t\t\t\t\tfsc,\n\t\t\t\t\t\t&mdsc_fops);\n\n\tfsc->debugfs_caps = debugfs_create_file(\"caps\",\n\t\t\t\t\t\t0400,\n\t\t\t\t\t\tfsc->client->debugfs_dir,\n\t\t\t\t\t\tfsc,\n\t\t\t\t\t\t&caps_fops);\n\n\tfsc->debugfs_status = debugfs_create_file(\"status\",\n\t\t\t\t\t\t  0400,\n\t\t\t\t\t\t  fsc->client->debugfs_dir,\n\t\t\t\t\t\t  fsc,\n\t\t\t\t\t\t  &status_fops);\n\n\tfsc->debugfs_metrics_dir = debugfs_create_dir(\"metrics\",\n\t\t\t\t\t\t      fsc->client->debugfs_dir);\n\n\tdebugfs_create_file(\"file\", 0400, fsc->debugfs_metrics_dir, fsc,\n\t\t\t    &metrics_file_fops);\n\tdebugfs_create_file(\"latency\", 0400, fsc->debugfs_metrics_dir, fsc,\n\t\t\t    &metrics_latency_fops);\n\tdebugfs_create_file(\"size\", 0400, fsc->debugfs_metrics_dir, fsc,\n\t\t\t    &metrics_size_fops);\n\tdebugfs_create_file(\"caps\", 0400, fsc->debugfs_metrics_dir, fsc,\n\t\t\t    &metrics_caps_fops);\n}\n\n\n#else   \n\nvoid ceph_fs_debugfs_init(struct ceph_fs_client *fsc)\n{\n}\n\nvoid ceph_fs_debugfs_cleanup(struct ceph_fs_client *fsc)\n{\n}\n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}