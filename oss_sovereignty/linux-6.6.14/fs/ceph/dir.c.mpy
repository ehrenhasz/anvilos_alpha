{
  "module_name": "dir.c",
  "hash_id": "5df31956c66569814d10b4cd47f75075b2d094278dcd420e297efef9e8f5146d",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/dir.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/spinlock.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/xattr.h>\n\n#include \"super.h\"\n#include \"mds_client.h\"\n#include \"crypto.h\"\n\n \n\n \n\nconst struct dentry_operations ceph_dentry_ops;\n\nstatic bool __dentry_lease_is_valid(struct ceph_dentry_info *di);\nstatic int __dir_lease_try_check(const struct dentry *dentry);\n\n \nstatic int ceph_d_init(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(dentry->d_sb);\n\n\tdi = kmem_cache_zalloc(ceph_dentry_cachep, GFP_KERNEL);\n\tif (!di)\n\t\treturn -ENOMEM;           \n\n\tdi->dentry = dentry;\n\tdi->lease_session = NULL;\n\tdi->time = jiffies;\n\tdentry->d_fsdata = di;\n\tINIT_LIST_HEAD(&di->lease_list);\n\n\tatomic64_inc(&mdsc->metric.total_dentries);\n\n\treturn 0;\n}\n\n \n#define OFFSET_BITS\t28\n#define OFFSET_MASK\t((1 << OFFSET_BITS) - 1)\n#define HASH_ORDER\t(0xffull << (OFFSET_BITS + 24))\nloff_t ceph_make_fpos(unsigned high, unsigned off, bool hash_order)\n{\n\tloff_t fpos = ((loff_t)high << 28) | (loff_t)off;\n\tif (hash_order)\n\t\tfpos |= HASH_ORDER;\n\treturn fpos;\n}\n\nstatic bool is_hash_order(loff_t p)\n{\n\treturn (p & HASH_ORDER) == HASH_ORDER;\n}\n\nstatic unsigned fpos_frag(loff_t p)\n{\n\treturn p >> OFFSET_BITS;\n}\n\nstatic unsigned fpos_hash(loff_t p)\n{\n\treturn ceph_frag_value(fpos_frag(p));\n}\n\nstatic unsigned fpos_off(loff_t p)\n{\n\treturn p & OFFSET_MASK;\n}\n\nstatic int fpos_cmp(loff_t l, loff_t r)\n{\n\tint v = ceph_frag_compare(fpos_frag(l), fpos_frag(r));\n\tif (v)\n\t\treturn v;\n\treturn (int)(fpos_off(l) - fpos_off(r));\n}\n\n \nstatic int note_last_dentry(struct ceph_dir_file_info *dfi, const char *name,\n\t\t            int len, unsigned next_offset)\n{\n\tchar *buf = kmalloc(len+1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tkfree(dfi->last_name);\n\tdfi->last_name = buf;\n\tmemcpy(dfi->last_name, name, len);\n\tdfi->last_name[len] = 0;\n\tdfi->next_offset = next_offset;\n\tdout(\"note_last_dentry '%s'\\n\", dfi->last_name);\n\treturn 0;\n}\n\n\nstatic struct dentry *\n__dcache_find_get_entry(struct dentry *parent, u64 idx,\n\t\t\tstruct ceph_readdir_cache_control *cache_ctl)\n{\n\tstruct inode *dir = d_inode(parent);\n\tstruct dentry *dentry;\n\tunsigned idx_mask = (PAGE_SIZE / sizeof(struct dentry *)) - 1;\n\tloff_t ptr_pos = idx * sizeof(struct dentry *);\n\tpgoff_t ptr_pgoff = ptr_pos >> PAGE_SHIFT;\n\n\tif (ptr_pos >= i_size_read(dir))\n\t\treturn NULL;\n\n\tif (!cache_ctl->page || ptr_pgoff != page_index(cache_ctl->page)) {\n\t\tceph_readdir_cache_release(cache_ctl);\n\t\tcache_ctl->page = find_lock_page(&dir->i_data, ptr_pgoff);\n\t\tif (!cache_ctl->page) {\n\t\t\tdout(\" page %lu not found\\n\", ptr_pgoff);\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t\t}\n\t\t \n\t\tunlock_page(cache_ctl->page);\n\t\tcache_ctl->dentries = kmap(cache_ctl->page);\n\t}\n\n\tcache_ctl->index = idx & idx_mask;\n\n\trcu_read_lock();\n\tspin_lock(&parent->d_lock);\n\t \n\tif (ceph_dir_is_complete_ordered(dir) && ptr_pos < i_size_read(dir))\n\t\tdentry = cache_ctl->dentries[cache_ctl->index];\n\telse\n\t\tdentry = NULL;\n\tspin_unlock(&parent->d_lock);\n\tif (dentry && !lockref_get_not_dead(&dentry->d_lockref))\n\t\tdentry = NULL;\n\trcu_read_unlock();\n\treturn dentry ? : ERR_PTR(-EAGAIN);\n}\n\n \nstatic int __dcache_readdir(struct file *file,  struct dir_context *ctx,\n\t\t\t    int shared_gen)\n{\n\tstruct ceph_dir_file_info *dfi = file->private_data;\n\tstruct dentry *parent = file->f_path.dentry;\n\tstruct inode *dir = d_inode(parent);\n\tstruct dentry *dentry, *last = NULL;\n\tstruct ceph_dentry_info *di;\n\tstruct ceph_readdir_cache_control cache_ctl = {};\n\tu64 idx = 0;\n\tint err = 0;\n\n\tdout(\"__dcache_readdir %p v%u at %llx\\n\", dir, (unsigned)shared_gen, ctx->pos);\n\n\t \n\tif (ctx->pos > 2) {\n\t\tu64 count = div_u64(i_size_read(dir), sizeof(struct dentry *));\n\t\twhile (count > 0) {\n\t\t\tu64 step = count >> 1;\n\t\t\tdentry = __dcache_find_get_entry(parent, idx + step,\n\t\t\t\t\t\t\t &cache_ctl);\n\t\t\tif (!dentry) {\n\t\t\t\t \n\t\t\t\tidx = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IS_ERR(dentry)) {\n\t\t\t\terr = PTR_ERR(dentry);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdi = ceph_dentry(dentry);\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tif (fpos_cmp(di->offset, ctx->pos) < 0) {\n\t\t\t\tidx += step + 1;\n\t\t\t\tcount -= step + 1;\n\t\t\t} else {\n\t\t\t\tcount = step;\n\t\t\t}\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\n\t\tdout(\"__dcache_readdir %p cache idx %llu\\n\", dir, idx);\n\t}\n\n\n\tfor (;;) {\n\t\tbool emit_dentry = false;\n\t\tdentry = __dcache_find_get_entry(parent, idx++, &cache_ctl);\n\t\tif (!dentry) {\n\t\t\tdfi->file_info.flags |= CEPH_F_ATEND;\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (IS_ERR(dentry)) {\n\t\t\terr = PTR_ERR(dentry);\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tdi = ceph_dentry(dentry);\n\t\tif (d_unhashed(dentry) ||\n\t\t    d_really_is_negative(dentry) ||\n\t\t    di->lease_shared_gen != shared_gen ||\n\t\t    ((dentry->d_flags & DCACHE_NOKEY_NAME) &&\n\t\t     fscrypt_has_encryption_key(dir))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fpos_cmp(ctx->pos, di->offset) <= 0) {\n\t\t\t__ceph_dentry_dir_lease_touch(di);\n\t\t\temit_dentry = true;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\n\t\tif (emit_dentry) {\n\t\t\tdout(\" %llx dentry %p %pd %p\\n\", di->offset,\n\t\t\t     dentry, dentry, d_inode(dentry));\n\t\t\tctx->pos = di->offset;\n\t\t\tif (!dir_emit(ctx, dentry->d_name.name,\n\t\t\t\t      dentry->d_name.len, ceph_present_inode(d_inode(dentry)),\n\t\t\t\t      d_inode(dentry)->i_mode >> 12)) {\n\t\t\t\tdput(dentry);\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tctx->pos++;\n\n\t\t\tif (last)\n\t\t\t\tdput(last);\n\t\t\tlast = dentry;\n\t\t} else {\n\t\t\tdput(dentry);\n\t\t}\n\t}\nout:\n\tceph_readdir_cache_release(&cache_ctl);\n\tif (last) {\n\t\tint ret;\n\t\tdi = ceph_dentry(last);\n\t\tret = note_last_dentry(dfi, last->d_name.name, last->d_name.len,\n\t\t\t\t       fpos_off(di->offset) + 1);\n\t\tif (ret < 0)\n\t\t\terr = ret;\n\t\tdput(last);\n\t\t \n\t\tif (dfi->readdir_cache_idx >= 0) {\n\t\t\tdfi->readdir_cache_idx = -1;\n\t\t\tdfi->dir_release_count = 0;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic bool need_send_readdir(struct ceph_dir_file_info *dfi, loff_t pos)\n{\n\tif (!dfi->last_readdir)\n\t\treturn true;\n\tif (is_hash_order(pos))\n\t\treturn !ceph_frag_contains_value(dfi->frag, fpos_hash(pos));\n\telse\n\t\treturn dfi->frag != fpos_frag(pos);\n}\n\nstatic int ceph_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct ceph_dir_file_info *dfi = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tint i;\n\tint err;\n\tunsigned frag = -1;\n\tstruct ceph_mds_reply_info_parsed *rinfo;\n\n\tdout(\"readdir %p file %p pos %llx\\n\", inode, file, ctx->pos);\n\tif (dfi->file_info.flags & CEPH_F_ATEND)\n\t\treturn 0;\n\n\t \n\tif (ctx->pos == 0) {\n\t\tdout(\"readdir off 0 -> '.'\\n\");\n\t\tif (!dir_emit(ctx, \".\", 1, ceph_present_inode(inode),\n\t\t\t    inode->i_mode >> 12))\n\t\t\treturn 0;\n\t\tctx->pos = 1;\n\t}\n\tif (ctx->pos == 1) {\n\t\tu64 ino;\n\t\tstruct dentry *dentry = file->f_path.dentry;\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tino = ceph_present_inode(dentry->d_parent->d_inode);\n\t\tspin_unlock(&dentry->d_lock);\n\n\t\tdout(\"readdir off 1 -> '..'\\n\");\n\t\tif (!dir_emit(ctx, \"..\", 2, ino, inode->i_mode >> 12))\n\t\t\treturn 0;\n\t\tctx->pos = 2;\n\t}\n\n\terr = ceph_fscrypt_prepare_readdir(inode);\n\tif (err < 0)\n\t\treturn err;\n\n\tspin_lock(&ci->i_ceph_lock);\n\t \n\t__ceph_touch_fmode(ci, mdsc, CEPH_FILE_MODE_WR);\n\t \n\tif (ceph_test_mount_opt(fsc, DCACHE) &&\n\t    !ceph_test_mount_opt(fsc, NOASYNCREADDIR) &&\n\t    ceph_snap(inode) != CEPH_SNAPDIR &&\n\t    __ceph_dir_is_complete_ordered(ci) &&\n\t    __ceph_caps_issued_mask_metric(ci, CEPH_CAP_FILE_SHARED, 1)) {\n\t\tint shared_gen = atomic_read(&ci->i_shared_gen);\n\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\terr = __dcache_readdir(file, ctx, shared_gen);\n\t\tif (err != -EAGAIN)\n\t\t\treturn err;\n\t} else {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n\n\t \nmore:\n\t \n\tif (need_send_readdir(dfi, ctx->pos)) {\n\t\tstruct ceph_mds_request *req;\n\t\tint op = ceph_snap(inode) == CEPH_SNAPDIR ?\n\t\t\tCEPH_MDS_OP_LSSNAP : CEPH_MDS_OP_READDIR;\n\n\t\t \n\t\tif (dfi->last_readdir) {\n\t\t\tceph_mdsc_put_request(dfi->last_readdir);\n\t\t\tdfi->last_readdir = NULL;\n\t\t}\n\n\t\tif (is_hash_order(ctx->pos)) {\n\t\t\t \n\t\t\tif (frag == (unsigned)-1)\n\t\t\t\tfrag = ceph_choose_frag(ci, fpos_hash(ctx->pos),\n\t\t\t\t\t\t\tNULL, NULL);\n\t\t} else {\n\t\t\tfrag = fpos_frag(ctx->pos);\n\t\t}\n\n\t\tdout(\"readdir fetching %llx.%llx frag %x offset '%s'\\n\",\n\t\t     ceph_vinop(inode), frag, dfi->last_name);\n\t\treq = ceph_mdsc_create_request(mdsc, op, USE_AUTH_MDS);\n\t\tif (IS_ERR(req))\n\t\t\treturn PTR_ERR(req);\n\n\t\terr = ceph_alloc_readdir_reply_buffer(req, inode);\n\t\tif (err) {\n\t\t\tceph_mdsc_put_request(req);\n\t\t\treturn err;\n\t\t}\n\t\t \n\t\treq->r_direct_mode = USE_AUTH_MDS;\n\t\tif (op == CEPH_MDS_OP_READDIR) {\n\t\t\treq->r_direct_hash = ceph_frag_value(frag);\n\t\t\t__set_bit(CEPH_MDS_R_DIRECT_IS_HASH, &req->r_req_flags);\n\t\t\treq->r_inode_drop = CEPH_CAP_FILE_EXCL;\n\t\t}\n\t\tif (dfi->last_name) {\n\t\t\tstruct qstr d_name = { .name = dfi->last_name,\n\t\t\t\t\t       .len = strlen(dfi->last_name) };\n\n\t\t\treq->r_path2 = kzalloc(NAME_MAX + 1, GFP_KERNEL);\n\t\t\tif (!req->r_path2) {\n\t\t\t\tceph_mdsc_put_request(req);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\terr = ceph_encode_encrypted_dname(inode, &d_name,\n\t\t\t\t\t\t\t  req->r_path2);\n\t\t\tif (err < 0) {\n\t\t\t\tceph_mdsc_put_request(req);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (is_hash_order(ctx->pos)) {\n\t\t\treq->r_args.readdir.offset_hash =\n\t\t\t\tcpu_to_le32(fpos_hash(ctx->pos));\n\t\t}\n\n\t\treq->r_dir_release_cnt = dfi->dir_release_count;\n\t\treq->r_dir_ordered_cnt = dfi->dir_ordered_count;\n\t\treq->r_readdir_cache_idx = dfi->readdir_cache_idx;\n\t\treq->r_readdir_offset = dfi->next_offset;\n\t\treq->r_args.readdir.frag = cpu_to_le32(frag);\n\t\treq->r_args.readdir.flags =\n\t\t\t\tcpu_to_le16(CEPH_READDIR_REPLY_BITFLAGS);\n\n\t\treq->r_inode = inode;\n\t\tihold(inode);\n\t\treq->r_dentry = dget(file->f_path.dentry);\n\t\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\t\tif (err < 0) {\n\t\t\tceph_mdsc_put_request(req);\n\t\t\treturn err;\n\t\t}\n\t\tdout(\"readdir got and parsed readdir result=%d on \"\n\t\t     \"frag %x, end=%d, complete=%d, hash_order=%d\\n\",\n\t\t     err, frag,\n\t\t     (int)req->r_reply_info.dir_end,\n\t\t     (int)req->r_reply_info.dir_complete,\n\t\t     (int)req->r_reply_info.hash_order);\n\n\t\trinfo = &req->r_reply_info;\n\t\tif (le32_to_cpu(rinfo->dir_dir->frag) != frag) {\n\t\t\tfrag = le32_to_cpu(rinfo->dir_dir->frag);\n\t\t\tif (!rinfo->hash_order) {\n\t\t\t\tdfi->next_offset = req->r_readdir_offset;\n\t\t\t\t \n\t\t\t\tctx->pos = ceph_make_fpos(frag,\n\t\t\t\t\t\t\t  dfi->next_offset,\n\t\t\t\t\t\t\t  false);\n\t\t\t}\n\t\t}\n\n\t\tdfi->frag = frag;\n\t\tdfi->last_readdir = req;\n\n\t\tif (test_bit(CEPH_MDS_R_DID_PREPOPULATE, &req->r_req_flags)) {\n\t\t\tdfi->readdir_cache_idx = req->r_readdir_cache_idx;\n\t\t\tif (dfi->readdir_cache_idx < 0) {\n\t\t\t\t \n\t\t\t\tdfi->dir_ordered_count = 0;\n\t\t\t} else if (ceph_frag_is_leftmost(frag) &&\n\t\t\t\t   dfi->next_offset == 2) {\n\t\t\t\t \n\t\t\t\tdfi->dir_release_count = req->r_dir_release_cnt;\n\t\t\t\tdfi->dir_ordered_count = req->r_dir_ordered_cnt;\n\t\t\t}\n\t\t} else {\n\t\t\tdout(\"readdir !did_prepopulate\\n\");\n\t\t\t \n\t\t\tdfi->readdir_cache_idx = -1;\n\t\t\t \n\t\t\tdfi->dir_release_count = 0;\n\t\t}\n\n\t\t \n\t\tif (rinfo->dir_nr > 0) {\n\t\t\tstruct ceph_mds_reply_dir_entry *rde =\n\t\t\t\t\trinfo->dir_entries + (rinfo->dir_nr-1);\n\t\t\tunsigned next_offset = req->r_reply_info.dir_end ?\n\t\t\t\t\t2 : (fpos_off(rde->offset) + 1);\n\t\t\terr = note_last_dentry(dfi, rde->name, rde->name_len,\n\t\t\t\t\t       next_offset);\n\t\t\tif (err) {\n\t\t\t\tceph_mdsc_put_request(dfi->last_readdir);\n\t\t\t\tdfi->last_readdir = NULL;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (req->r_reply_info.dir_end) {\n\t\t\tdfi->next_offset = 2;\n\t\t\t \n\t\t}\n\t}\n\n\trinfo = &dfi->last_readdir->r_reply_info;\n\tdout(\"readdir frag %x num %d pos %llx chunk first %llx\\n\",\n\t     dfi->frag, rinfo->dir_nr, ctx->pos,\n\t     rinfo->dir_nr ? rinfo->dir_entries[0].offset : 0LL);\n\n\ti = 0;\n\t \n\tif (rinfo->dir_nr > 0) {\n\t\tint step, nr = rinfo->dir_nr;\n\t\twhile (nr > 0) {\n\t\t\tstep = nr >> 1;\n\t\t\tif (rinfo->dir_entries[i + step].offset < ctx->pos) {\n\t\t\t\ti +=  step + 1;\n\t\t\t\tnr -= step + 1;\n\t\t\t} else {\n\t\t\t\tnr = step;\n\t\t\t}\n\t\t}\n\t}\n\tfor (; i < rinfo->dir_nr; i++) {\n\t\tstruct ceph_mds_reply_dir_entry *rde = rinfo->dir_entries + i;\n\n\t\tif (rde->offset < ctx->pos) {\n\t\t\tpr_warn(\"%s: rde->offset 0x%llx ctx->pos 0x%llx\\n\",\n\t\t\t\t__func__, rde->offset, ctx->pos);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (WARN_ON_ONCE(!rde->inode.in))\n\t\t\treturn -EIO;\n\n\t\tctx->pos = rde->offset;\n\t\tdout(\"readdir (%d/%d) -> %llx '%.*s' %p\\n\",\n\t\t     i, rinfo->dir_nr, ctx->pos,\n\t\t     rde->name_len, rde->name, &rde->inode.in);\n\n\t\tif (!dir_emit(ctx, rde->name, rde->name_len,\n\t\t\t      ceph_present_ino(inode->i_sb, le64_to_cpu(rde->inode.in->ino)),\n\t\t\t      le32_to_cpu(rde->inode.in->mode) >> 12)) {\n\t\t\t \n\t\t\tdout(\"filldir stopping us...\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tctx->pos++;\n\t}\n\n\tceph_mdsc_put_request(dfi->last_readdir);\n\tdfi->last_readdir = NULL;\n\n\tif (dfi->next_offset > 2) {\n\t\tfrag = dfi->frag;\n\t\tgoto more;\n\t}\n\n\t \n\tif (!ceph_frag_is_rightmost(dfi->frag)) {\n\t\tfrag = ceph_frag_next(dfi->frag);\n\t\tif (is_hash_order(ctx->pos)) {\n\t\t\tloff_t new_pos = ceph_make_fpos(ceph_frag_value(frag),\n\t\t\t\t\t\t\tdfi->next_offset, true);\n\t\t\tif (new_pos > ctx->pos)\n\t\t\t\tctx->pos = new_pos;\n\t\t\t \n\t\t} else {\n\t\t\tctx->pos = ceph_make_fpos(frag, dfi->next_offset,\n\t\t\t\t\t\t\tfalse);\n\t\t\tkfree(dfi->last_name);\n\t\t\tdfi->last_name = NULL;\n\t\t}\n\t\tdout(\"readdir next frag is %x\\n\", frag);\n\t\tgoto more;\n\t}\n\tdfi->file_info.flags |= CEPH_F_ATEND;\n\n\t \n\tif (atomic64_read(&ci->i_release_count) ==\n\t\t\t\t\tdfi->dir_release_count) {\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (dfi->dir_ordered_count ==\n\t\t\t\tatomic64_read(&ci->i_ordered_count)) {\n\t\t\tdout(\" marking %p complete and ordered\\n\", inode);\n\t\t\t \n\t\t\tBUG_ON(dfi->readdir_cache_idx < 0);\n\t\t\ti_size_write(inode, dfi->readdir_cache_idx *\n\t\t\t\t     sizeof(struct dentry*));\n\t\t} else {\n\t\t\tdout(\" marking %p complete\\n\", inode);\n\t\t}\n\t\t__ceph_dir_set_complete(ci, dfi->dir_release_count,\n\t\t\t\t\tdfi->dir_ordered_count);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n\tdout(\"readdir %p file %p done.\\n\", inode, file);\n\treturn 0;\n}\n\nstatic void reset_readdir(struct ceph_dir_file_info *dfi)\n{\n\tif (dfi->last_readdir) {\n\t\tceph_mdsc_put_request(dfi->last_readdir);\n\t\tdfi->last_readdir = NULL;\n\t}\n\tkfree(dfi->last_name);\n\tdfi->last_name = NULL;\n\tdfi->dir_release_count = 0;\n\tdfi->readdir_cache_idx = -1;\n\tdfi->next_offset = 2;   \n\tdfi->file_info.flags &= ~CEPH_F_ATEND;\n}\n\n \nstatic bool need_reset_readdir(struct ceph_dir_file_info *dfi, loff_t new_pos)\n{\n\tstruct ceph_mds_reply_info_parsed *rinfo;\n\tloff_t chunk_offset;\n\tif (new_pos == 0)\n\t\treturn true;\n\tif (is_hash_order(new_pos)) {\n\t\t \n\t} else if (dfi->frag != fpos_frag(new_pos)) {\n\t\treturn true;\n\t}\n\trinfo = dfi->last_readdir ? &dfi->last_readdir->r_reply_info : NULL;\n\tif (!rinfo || !rinfo->dir_nr)\n\t\treturn true;\n\tchunk_offset = rinfo->dir_entries[0].offset;\n\treturn new_pos < chunk_offset ||\n\t       is_hash_order(new_pos) != is_hash_order(chunk_offset);\n}\n\nstatic loff_t ceph_dir_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct ceph_dir_file_info *dfi = file->private_data;\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t retval;\n\n\tinode_lock(inode);\n\tretval = -EINVAL;\n\tswitch (whence) {\n\tcase SEEK_CUR:\n\t\toffset += file->f_pos;\n\t\tbreak;\n\tcase SEEK_SET:\n\t\tbreak;\n\tcase SEEK_END:\n\t\tretval = -EOPNOTSUPP;\n\t\tgoto out;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tif (offset >= 0) {\n\t\tif (need_reset_readdir(dfi, offset)) {\n\t\t\tdout(\"dir_llseek dropping %p content\\n\", file);\n\t\t\treset_readdir(dfi);\n\t\t} else if (is_hash_order(offset) && offset > file->f_pos) {\n\t\t\t \n\t\t\tdfi->dir_release_count = 0;\n\t\t\tdfi->readdir_cache_idx = -1;\n\t\t}\n\n\t\tif (offset != file->f_pos) {\n\t\t\tfile->f_pos = offset;\n\t\t\tfile->f_version = 0;\n\t\t\tdfi->file_info.flags &= ~CEPH_F_ATEND;\n\t\t}\n\t\tretval = offset;\n\t}\nout:\n\tinode_unlock(inode);\n\treturn retval;\n}\n\n \nstruct dentry *ceph_handle_snapdir(struct ceph_mds_request *req,\n\t\t\t\t   struct dentry *dentry)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(dentry->d_sb);\n\tstruct inode *parent = d_inode(dentry->d_parent);  \n\n\t \n\tif (ceph_snap(parent) == CEPH_NOSNAP &&\n\t    strcmp(dentry->d_name.name, fsc->mount_options->snapdir_name) == 0) {\n\t\tstruct dentry *res;\n\t\tstruct inode *inode = ceph_get_snapdir(parent);\n\n\t\tres = d_splice_alias(inode, dentry);\n\t\tdout(\"ENOENT on snapdir %p '%pd', linking to snapdir %p. Spliced dentry %p\\n\",\n\t\t     dentry, dentry, inode, res);\n\t\tif (res)\n\t\t\tdentry = res;\n\t}\n\treturn dentry;\n}\n\n \nstruct dentry *ceph_finish_lookup(struct ceph_mds_request *req,\n\t\t\t\t  struct dentry *dentry, int err)\n{\n\tif (err == -ENOENT) {\n\t\t \n\t\terr = 0;\n\t\tif (!req->r_reply_info.head->is_dentry) {\n\t\t\tdout(\"ENOENT and no trace, dentry %p inode %p\\n\",\n\t\t\t     dentry, d_inode(dentry));\n\t\t\tif (d_really_is_positive(dentry)) {\n\t\t\t\td_drop(dentry);\n\t\t\t\terr = -ENOENT;\n\t\t\t} else {\n\t\t\t\td_add(dentry, NULL);\n\t\t\t}\n\t\t}\n\t}\n\tif (err)\n\t\tdentry = ERR_PTR(err);\n\telse if (dentry != req->r_dentry)\n\t\tdentry = dget(req->r_dentry);    \n\telse\n\t\tdentry = NULL;\n\treturn dentry;\n}\n\nstatic bool is_root_ceph_dentry(struct inode *inode, struct dentry *dentry)\n{\n\treturn ceph_ino(inode) == CEPH_INO_ROOT &&\n\t\tstrncmp(dentry->d_name.name, \".ceph\", 5) == 0;\n}\n\n \nstatic struct dentry *ceph_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(dir->i_sb);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(dir->i_sb);\n\tstruct ceph_mds_request *req;\n\tint op;\n\tint mask;\n\tint err;\n\n\tdout(\"lookup %p dentry %p '%pd'\\n\",\n\t     dir, dentry, dentry);\n\n\tif (dentry->d_name.len > NAME_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tif (IS_ENCRYPTED(dir)) {\n\t\tbool had_key = fscrypt_has_encryption_key(dir);\n\n\t\terr = fscrypt_prepare_lookup_partial(dir, dentry);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\n\t\t \n\t\tif (!had_key && fscrypt_has_encryption_key(dir))\n\t\t\tceph_dir_clear_complete(dir);\n\t}\n\n\t \n\tif (d_really_is_negative(dentry)) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(dir);\n\t\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tdout(\" dir %p flags are 0x%lx\\n\", dir, ci->i_ceph_flags);\n\t\tif (strncmp(dentry->d_name.name,\n\t\t\t    fsc->mount_options->snapdir_name,\n\t\t\t    dentry->d_name.len) &&\n\t\t    !is_root_ceph_dentry(dir, dentry) &&\n\t\t    ceph_test_mount_opt(fsc, DCACHE) &&\n\t\t    __ceph_dir_is_complete(ci) &&\n\t\t    __ceph_caps_issued_mask_metric(ci, CEPH_CAP_FILE_SHARED, 1)) {\n\t\t\t__ceph_touch_fmode(ci, mdsc, CEPH_FILE_MODE_RD);\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tdout(\" dir %p complete, -ENOENT\\n\", dir);\n\t\t\td_add(dentry, NULL);\n\t\t\tdi->lease_shared_gen = atomic_read(&ci->i_shared_gen);\n\t\t\treturn NULL;\n\t\t}\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n\n\top = ceph_snap(dir) == CEPH_SNAPDIR ?\n\t\tCEPH_MDS_OP_LOOKUPSNAP : CEPH_MDS_OP_LOOKUP;\n\treq = ceph_mdsc_create_request(mdsc, op, USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn ERR_CAST(req);\n\treq->r_dentry = dget(dentry);\n\treq->r_num_caps = 2;\n\n\tmask = CEPH_STAT_CAP_INODE | CEPH_CAP_AUTH_SHARED;\n\tif (ceph_security_xattr_wanted(dir))\n\t\tmask |= CEPH_CAP_XATTR_SHARED;\n\treq->r_args.getattr.mask = cpu_to_le32(mask);\n\n\tihold(dir);\n\treq->r_parent = dir;\n\tset_bit(CEPH_MDS_R_PARENT_LOCKED, &req->r_req_flags);\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (err == -ENOENT) {\n\t\tstruct dentry *res;\n\n\t\tres = ceph_handle_snapdir(req, dentry);\n\t\tif (IS_ERR(res)) {\n\t\t\terr = PTR_ERR(res);\n\t\t} else {\n\t\t\tdentry = res;\n\t\t\terr = 0;\n\t\t}\n\t}\n\tdentry = ceph_finish_lookup(req, dentry, err);\n\tceph_mdsc_put_request(req);   \n\tdout(\"lookup result=%p\\n\", dentry);\n\treturn dentry;\n}\n\n \nint ceph_handle_notrace_create(struct inode *dir, struct dentry *dentry)\n{\n\tstruct dentry *result = ceph_lookup(dir, dentry, 0);\n\n\tif (result && !IS_ERR(result)) {\n\t\t \n\t\td_drop(result);\n\t\treturn -ESTALE;\n\t}\n\treturn PTR_ERR(result);\n}\n\nstatic int ceph_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(dir->i_sb);\n\tstruct ceph_mds_request *req;\n\tstruct ceph_acl_sec_ctx as_ctx = {};\n\tint err;\n\n\tif (ceph_snap(dir) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\terr = ceph_wait_on_conflict_unlink(dentry);\n\tif (err)\n\t\treturn err;\n\n\tif (ceph_quota_is_max_files_exceeded(dir)) {\n\t\terr = -EDQUOT;\n\t\tgoto out;\n\t}\n\n\tdout(\"mknod in dir %p dentry %p mode 0%ho rdev %d\\n\",\n\t     dir, dentry, mode, rdev);\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_MKNOD, USE_AUTH_MDS);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\treq->r_new_inode = ceph_new_inode(dir, dentry, &mode, &as_ctx);\n\tif (IS_ERR(req->r_new_inode)) {\n\t\terr = PTR_ERR(req->r_new_inode);\n\t\treq->r_new_inode = NULL;\n\t\tgoto out_req;\n\t}\n\n\tif (S_ISREG(mode) && IS_ENCRYPTED(dir))\n\t\tset_bit(CEPH_MDS_R_FSCRYPT_FILE, &req->r_req_flags);\n\n\treq->r_dentry = dget(dentry);\n\treq->r_num_caps = 2;\n\treq->r_parent = dir;\n\tihold(dir);\n\tset_bit(CEPH_MDS_R_PARENT_LOCKED, &req->r_req_flags);\n\treq->r_args.mknod.mode = cpu_to_le32(mode);\n\treq->r_args.mknod.rdev = cpu_to_le32(rdev);\n\treq->r_dentry_drop = CEPH_CAP_FILE_SHARED | CEPH_CAP_AUTH_EXCL |\n\t\t\t     CEPH_CAP_XATTR_EXCL;\n\treq->r_dentry_unless = CEPH_CAP_FILE_EXCL;\n\n\tceph_as_ctx_to_req(req, &as_ctx);\n\n\terr = ceph_mdsc_do_request(mdsc, dir, req);\n\tif (!err && !req->r_reply_info.head->is_dentry)\n\t\terr = ceph_handle_notrace_create(dir, dentry);\nout_req:\n\tceph_mdsc_put_request(req);\nout:\n\tif (!err)\n\t\tceph_init_inode_acls(d_inode(dentry), &as_ctx);\n\telse\n\t\td_drop(dentry);\n\tceph_release_acl_sec_ctx(&as_ctx);\n\treturn err;\n}\n\nstatic int ceph_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, umode_t mode, bool excl)\n{\n\treturn ceph_mknod(idmap, dir, dentry, mode, 0);\n}\n\n#if IS_ENABLED(CONFIG_FS_ENCRYPTION)\nstatic int prep_encrypted_symlink_target(struct ceph_mds_request *req,\n\t\t\t\t\t const char *dest)\n{\n\tint err;\n\tint len = strlen(dest);\n\tstruct fscrypt_str osd_link = FSTR_INIT(NULL, 0);\n\n\terr = fscrypt_prepare_symlink(req->r_parent, dest, len, PATH_MAX,\n\t\t\t\t      &osd_link);\n\tif (err)\n\t\tgoto out;\n\n\terr = fscrypt_encrypt_symlink(req->r_new_inode, dest, len, &osd_link);\n\tif (err)\n\t\tgoto out;\n\n\treq->r_path2 = kmalloc(CEPH_BASE64_CHARS(osd_link.len) + 1, GFP_KERNEL);\n\tif (!req->r_path2) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tlen = ceph_base64_encode(osd_link.name, osd_link.len, req->r_path2);\n\treq->r_path2[len] = '\\0';\nout:\n\tfscrypt_fname_free_buffer(&osd_link);\n\treturn err;\n}\n#else\nstatic int prep_encrypted_symlink_target(struct ceph_mds_request *req,\n\t\t\t\t\t const char *dest)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nstatic int ceph_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct dentry *dentry, const char *dest)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(dir->i_sb);\n\tstruct ceph_mds_request *req;\n\tstruct ceph_acl_sec_ctx as_ctx = {};\n\tumode_t mode = S_IFLNK | 0777;\n\tint err;\n\n\tif (ceph_snap(dir) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\terr = ceph_wait_on_conflict_unlink(dentry);\n\tif (err)\n\t\treturn err;\n\n\tif (ceph_quota_is_max_files_exceeded(dir)) {\n\t\terr = -EDQUOT;\n\t\tgoto out;\n\t}\n\n\tdout(\"symlink in dir %p dentry %p to '%s'\\n\", dir, dentry, dest);\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SYMLINK, USE_AUTH_MDS);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\treq->r_new_inode = ceph_new_inode(dir, dentry, &mode, &as_ctx);\n\tif (IS_ERR(req->r_new_inode)) {\n\t\terr = PTR_ERR(req->r_new_inode);\n\t\treq->r_new_inode = NULL;\n\t\tgoto out_req;\n\t}\n\n\treq->r_parent = dir;\n\tihold(dir);\n\n\tif (IS_ENCRYPTED(req->r_new_inode)) {\n\t\terr = prep_encrypted_symlink_target(req, dest);\n\t\tif (err)\n\t\t\tgoto out_req;\n\t} else {\n\t\treq->r_path2 = kstrdup(dest, GFP_KERNEL);\n\t\tif (!req->r_path2) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_req;\n\t\t}\n\t}\n\n\tset_bit(CEPH_MDS_R_PARENT_LOCKED, &req->r_req_flags);\n\treq->r_dentry = dget(dentry);\n\treq->r_num_caps = 2;\n\treq->r_dentry_drop = CEPH_CAP_FILE_SHARED | CEPH_CAP_AUTH_EXCL |\n\t\t\t     CEPH_CAP_XATTR_EXCL;\n\treq->r_dentry_unless = CEPH_CAP_FILE_EXCL;\n\n\tceph_as_ctx_to_req(req, &as_ctx);\n\n\terr = ceph_mdsc_do_request(mdsc, dir, req);\n\tif (!err && !req->r_reply_info.head->is_dentry)\n\t\terr = ceph_handle_notrace_create(dir, dentry);\nout_req:\n\tceph_mdsc_put_request(req);\nout:\n\tif (err)\n\t\td_drop(dentry);\n\tceph_release_acl_sec_ctx(&as_ctx);\n\treturn err;\n}\n\nstatic int ceph_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(dir->i_sb);\n\tstruct ceph_mds_request *req;\n\tstruct ceph_acl_sec_ctx as_ctx = {};\n\tint err;\n\tint op;\n\n\terr = ceph_wait_on_conflict_unlink(dentry);\n\tif (err)\n\t\treturn err;\n\n\tif (ceph_snap(dir) == CEPH_SNAPDIR) {\n\t\t \n\t\top = CEPH_MDS_OP_MKSNAP;\n\t\tdout(\"mksnap dir %p snap '%pd' dn %p\\n\", dir,\n\t\t     dentry, dentry);\n\t} else if (ceph_snap(dir) == CEPH_NOSNAP) {\n\t\tdout(\"mkdir dir %p dn %p mode 0%ho\\n\", dir, dentry, mode);\n\t\top = CEPH_MDS_OP_MKDIR;\n\t} else {\n\t\terr = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (op == CEPH_MDS_OP_MKDIR &&\n\t    ceph_quota_is_max_files_exceeded(dir)) {\n\t\terr = -EDQUOT;\n\t\tgoto out;\n\t}\n\tif ((op == CEPH_MDS_OP_MKSNAP) && IS_ENCRYPTED(dir) &&\n\t    !fscrypt_has_encryption_key(dir)) {\n\t\terr = -ENOKEY;\n\t\tgoto out;\n\t}\n\n\n\treq = ceph_mdsc_create_request(mdsc, op, USE_AUTH_MDS);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tmode |= S_IFDIR;\n\treq->r_new_inode = ceph_new_inode(dir, dentry, &mode, &as_ctx);\n\tif (IS_ERR(req->r_new_inode)) {\n\t\terr = PTR_ERR(req->r_new_inode);\n\t\treq->r_new_inode = NULL;\n\t\tgoto out_req;\n\t}\n\n\treq->r_dentry = dget(dentry);\n\treq->r_num_caps = 2;\n\treq->r_parent = dir;\n\tihold(dir);\n\tset_bit(CEPH_MDS_R_PARENT_LOCKED, &req->r_req_flags);\n\treq->r_args.mkdir.mode = cpu_to_le32(mode);\n\treq->r_dentry_drop = CEPH_CAP_FILE_SHARED | CEPH_CAP_AUTH_EXCL |\n\t\t\t     CEPH_CAP_XATTR_EXCL;\n\treq->r_dentry_unless = CEPH_CAP_FILE_EXCL;\n\n\tceph_as_ctx_to_req(req, &as_ctx);\n\n\terr = ceph_mdsc_do_request(mdsc, dir, req);\n\tif (!err &&\n\t    !req->r_reply_info.head->is_target &&\n\t    !req->r_reply_info.head->is_dentry)\n\t\terr = ceph_handle_notrace_create(dir, dentry);\nout_req:\n\tceph_mdsc_put_request(req);\nout:\n\tif (!err)\n\t\tceph_init_inode_acls(d_inode(dentry), &as_ctx);\n\telse\n\t\td_drop(dentry);\n\tceph_release_acl_sec_ctx(&as_ctx);\n\treturn err;\n}\n\nstatic int ceph_link(struct dentry *old_dentry, struct inode *dir,\n\t\t     struct dentry *dentry)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(dir->i_sb);\n\tstruct ceph_mds_request *req;\n\tint err;\n\n\tif (dentry->d_flags & DCACHE_DISCONNECTED)\n\t\treturn -EINVAL;\n\n\terr = ceph_wait_on_conflict_unlink(dentry);\n\tif (err)\n\t\treturn err;\n\n\tif (ceph_snap(dir) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\terr = fscrypt_prepare_link(old_dentry, dir, dentry);\n\tif (err)\n\t\treturn err;\n\n\tdout(\"link in dir %p %llx.%llx old_dentry %p:'%pd' dentry %p:'%pd'\\n\",\n\t     dir, ceph_vinop(dir), old_dentry, old_dentry, dentry, dentry);\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LINK, USE_AUTH_MDS);\n\tif (IS_ERR(req)) {\n\t\td_drop(dentry);\n\t\treturn PTR_ERR(req);\n\t}\n\treq->r_dentry = dget(dentry);\n\treq->r_num_caps = 2;\n\treq->r_old_dentry = dget(old_dentry);\n\t \n\tif (old_dentry->d_flags & DCACHE_DISCONNECTED)\n\t\treq->r_ino2 = ceph_vino(d_inode(old_dentry));\n\treq->r_parent = dir;\n\tihold(dir);\n\tset_bit(CEPH_MDS_R_PARENT_LOCKED, &req->r_req_flags);\n\treq->r_dentry_drop = CEPH_CAP_FILE_SHARED | CEPH_CAP_XATTR_EXCL;\n\treq->r_dentry_unless = CEPH_CAP_FILE_EXCL;\n\t \n\treq->r_old_inode_drop = CEPH_CAP_LINK_SHARED | CEPH_CAP_LINK_EXCL;\n\terr = ceph_mdsc_do_request(mdsc, dir, req);\n\tif (err) {\n\t\td_drop(dentry);\n\t} else if (!req->r_reply_info.head->is_dentry) {\n\t\tihold(d_inode(old_dentry));\n\t\td_instantiate(dentry, d_inode(old_dentry));\n\t}\n\tceph_mdsc_put_request(req);\n\treturn err;\n}\n\nstatic void ceph_async_unlink_cb(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_request *req)\n{\n\tstruct dentry *dentry = req->r_dentry;\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(dentry->d_sb);\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tint result = req->r_err ? req->r_err :\n\t\t\tle32_to_cpu(req->r_reply_info.head->result);\n\n\tif (!test_bit(CEPH_DENTRY_ASYNC_UNLINK_BIT, &di->flags))\n\t\tpr_warn(\"%s dentry %p:%pd async unlink bit is not set\\n\",\n\t\t\t__func__, dentry, dentry);\n\n\tspin_lock(&fsc->async_unlink_conflict_lock);\n\thash_del_rcu(&di->hnode);\n\tspin_unlock(&fsc->async_unlink_conflict_lock);\n\n\tspin_lock(&dentry->d_lock);\n\tdi->flags &= ~CEPH_DENTRY_ASYNC_UNLINK;\n\twake_up_bit(&di->flags, CEPH_DENTRY_ASYNC_UNLINK_BIT);\n\tspin_unlock(&dentry->d_lock);\n\n\tsynchronize_rcu();\n\n\tif (result == -EJUKEBOX)\n\t\tgoto out;\n\n\t \n\tif (result) {\n\t\tint pathlen = 0;\n\t\tu64 base = 0;\n\t\tchar *path = ceph_mdsc_build_path(dentry, &pathlen,\n\t\t\t\t\t\t  &base, 0);\n\n\t\t \n\t\tmapping_set_error(req->r_parent->i_mapping, result);\n\t\tceph_dir_clear_complete(req->r_parent);\n\n\t\t \n\t\tif (!d_unhashed(dentry))\n\t\t\td_drop(dentry);\n\n\t\t \n\t\tmapping_set_error(req->r_old_inode->i_mapping, result);\n\n\t\tpr_warn(\"async unlink failure path=(%llx)%s result=%d!\\n\",\n\t\t\tbase, IS_ERR(path) ? \"<<bad>>\" : path, result);\n\t\tceph_mdsc_free_path(path, pathlen);\n\t}\nout:\n\tiput(req->r_old_inode);\n\tceph_mdsc_release_dir_caps(req);\n}\n\nstatic int get_caps_for_async_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(dir);\n\tstruct ceph_dentry_info *di;\n\tint got = 0, want = CEPH_CAP_FILE_EXCL | CEPH_CAP_DIR_UNLINK;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif ((__ceph_caps_issued(ci, NULL) & want) == want) {\n\t\tceph_take_cap_refs(ci, want, false);\n\t\tgot = want;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\t \n\tif (!got)\n\t\treturn 0;\n\n        spin_lock(&dentry->d_lock);\n        di = ceph_dentry(dentry);\n\t \n\tif (atomic_read(&ci->i_shared_gen) != di->lease_shared_gen ||\n\t    !(di->flags & CEPH_DENTRY_PRIMARY_LINK))\n\t\twant = 0;\n        spin_unlock(&dentry->d_lock);\n\n\t \n\tif (want == got)\n\t\treturn got;\n\n\tceph_put_cap_refs(ci, got);\n\treturn 0;\n}\n\n \nstatic int ceph_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(dir->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ceph_mds_request *req;\n\tbool try_async = ceph_test_mount_opt(fsc, ASYNC_DIROPS);\n\tint err = -EROFS;\n\tint op;\n\n\tif (ceph_snap(dir) == CEPH_SNAPDIR) {\n\t\t \n\t\tdout(\"rmsnap dir %p '%pd' dn %p\\n\", dir, dentry, dentry);\n\t\top = CEPH_MDS_OP_RMSNAP;\n\t} else if (ceph_snap(dir) == CEPH_NOSNAP) {\n\t\tdout(\"unlink/rmdir dir %p dn %p inode %p\\n\",\n\t\t     dir, dentry, inode);\n\t\top = d_is_dir(dentry) ?\n\t\t\tCEPH_MDS_OP_RMDIR : CEPH_MDS_OP_UNLINK;\n\t} else\n\t\tgoto out;\nretry:\n\treq = ceph_mdsc_create_request(mdsc, op, USE_AUTH_MDS);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\treq->r_dentry = dget(dentry);\n\treq->r_num_caps = 2;\n\treq->r_parent = dir;\n\tihold(dir);\n\treq->r_dentry_drop = CEPH_CAP_FILE_SHARED | CEPH_CAP_XATTR_EXCL;\n\treq->r_dentry_unless = CEPH_CAP_FILE_EXCL;\n\treq->r_inode_drop = ceph_drop_caps_for_unlink(inode);\n\n\tif (try_async && op == CEPH_MDS_OP_UNLINK &&\n\t    (req->r_dir_caps = get_caps_for_async_unlink(dir, dentry))) {\n\t\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\n\t\tdout(\"async unlink on %llu/%.*s caps=%s\", ceph_ino(dir),\n\t\t     dentry->d_name.len, dentry->d_name.name,\n\t\t     ceph_cap_string(req->r_dir_caps));\n\t\tset_bit(CEPH_MDS_R_ASYNC, &req->r_req_flags);\n\t\treq->r_callback = ceph_async_unlink_cb;\n\t\treq->r_old_inode = d_inode(dentry);\n\t\tihold(req->r_old_inode);\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tdi->flags |= CEPH_DENTRY_ASYNC_UNLINK;\n\t\tspin_unlock(&dentry->d_lock);\n\n\t\tspin_lock(&fsc->async_unlink_conflict_lock);\n\t\thash_add_rcu(fsc->async_unlink_conflict, &di->hnode,\n\t\t\t     dentry->d_name.hash);\n\t\tspin_unlock(&fsc->async_unlink_conflict_lock);\n\n\t\terr = ceph_mdsc_submit_request(mdsc, dir, req);\n\t\tif (!err) {\n\t\t\t \n\t\t\tdrop_nlink(inode);\n\t\t\td_delete(dentry);\n\t\t} else {\n\t\t\tspin_lock(&fsc->async_unlink_conflict_lock);\n\t\t\thash_del_rcu(&di->hnode);\n\t\t\tspin_unlock(&fsc->async_unlink_conflict_lock);\n\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tdi->flags &= ~CEPH_DENTRY_ASYNC_UNLINK;\n\t\t\tspin_unlock(&dentry->d_lock);\n\n\t\t\tif (err == -EJUKEBOX) {\n\t\t\t\ttry_async = false;\n\t\t\t\tceph_mdsc_put_request(req);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tset_bit(CEPH_MDS_R_PARENT_LOCKED, &req->r_req_flags);\n\t\terr = ceph_mdsc_do_request(mdsc, dir, req);\n\t\tif (!err && !req->r_reply_info.head->is_dentry)\n\t\t\td_delete(dentry);\n\t}\n\n\tceph_mdsc_put_request(req);\nout:\n\treturn err;\n}\n\nstatic int ceph_rename(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\t       struct dentry *old_dentry, struct inode *new_dir,\n\t\t       struct dentry *new_dentry, unsigned int flags)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(old_dir->i_sb);\n\tstruct ceph_mds_request *req;\n\tint op = CEPH_MDS_OP_RENAME;\n\tint err;\n\n\tif (flags)\n\t\treturn -EINVAL;\n\n\tif (ceph_snap(old_dir) != ceph_snap(new_dir))\n\t\treturn -EXDEV;\n\tif (ceph_snap(old_dir) != CEPH_NOSNAP) {\n\t\tif (old_dir == new_dir && ceph_snap(old_dir) == CEPH_SNAPDIR)\n\t\t\top = CEPH_MDS_OP_RENAMESNAP;\n\t\telse\n\t\t\treturn -EROFS;\n\t}\n\t \n\tif ((old_dir != new_dir) &&\n\t    (!ceph_quota_is_same_realm(old_dir, new_dir)))\n\t\treturn -EXDEV;\n\n\terr = ceph_wait_on_conflict_unlink(new_dentry);\n\tif (err)\n\t\treturn err;\n\n\terr = fscrypt_prepare_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t     flags);\n\tif (err)\n\t\treturn err;\n\n\tdout(\"rename dir %p dentry %p to dir %p dentry %p\\n\",\n\t     old_dir, old_dentry, new_dir, new_dentry);\n\treq = ceph_mdsc_create_request(mdsc, op, USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\tihold(old_dir);\n\treq->r_dentry = dget(new_dentry);\n\treq->r_num_caps = 2;\n\treq->r_old_dentry = dget(old_dentry);\n\treq->r_old_dentry_dir = old_dir;\n\treq->r_parent = new_dir;\n\tihold(new_dir);\n\tset_bit(CEPH_MDS_R_PARENT_LOCKED, &req->r_req_flags);\n\treq->r_old_dentry_drop = CEPH_CAP_FILE_SHARED | CEPH_CAP_XATTR_EXCL;\n\treq->r_old_dentry_unless = CEPH_CAP_FILE_EXCL;\n\treq->r_dentry_drop = CEPH_CAP_FILE_SHARED | CEPH_CAP_XATTR_EXCL;\n\treq->r_dentry_unless = CEPH_CAP_FILE_EXCL;\n\t \n\treq->r_old_inode_drop = CEPH_CAP_LINK_SHARED | CEPH_CAP_LINK_EXCL;\n\tif (d_really_is_positive(new_dentry)) {\n\t\treq->r_inode_drop =\n\t\t\tceph_drop_caps_for_unlink(d_inode(new_dentry));\n\t}\n\terr = ceph_mdsc_do_request(mdsc, old_dir, req);\n\tif (!err && !req->r_reply_info.head->is_dentry) {\n\t\t \n\t\td_move(old_dentry, new_dentry);\n\t}\n\tceph_mdsc_put_request(req);\n\treturn err;\n}\n\n \nvoid __ceph_dentry_lease_touch(struct ceph_dentry_info *di)\n{\n\tstruct dentry *dn = di->dentry;\n\tstruct ceph_mds_client *mdsc;\n\n\tdout(\"dentry_lease_touch %p %p '%pd'\\n\", di, dn, dn);\n\n\tdi->flags |= CEPH_DENTRY_LEASE_LIST;\n\tif (di->flags & CEPH_DENTRY_SHRINK_LIST) {\n\t\tdi->flags |= CEPH_DENTRY_REFERENCED;\n\t\treturn;\n\t}\n\n\tmdsc = ceph_sb_to_client(dn->d_sb)->mdsc;\n\tspin_lock(&mdsc->dentry_list_lock);\n\tlist_move_tail(&di->lease_list, &mdsc->dentry_leases);\n\tspin_unlock(&mdsc->dentry_list_lock);\n}\n\nstatic void __dentry_dir_lease_touch(struct ceph_mds_client* mdsc,\n\t\t\t\t     struct ceph_dentry_info *di)\n{\n\tdi->flags &= ~(CEPH_DENTRY_LEASE_LIST | CEPH_DENTRY_REFERENCED);\n\tdi->lease_gen = 0;\n\tdi->time = jiffies;\n\tlist_move_tail(&di->lease_list, &mdsc->dentry_dir_leases);\n}\n\n \nvoid __ceph_dentry_dir_lease_touch(struct ceph_dentry_info *di)\n{\n\tstruct dentry *dn = di->dentry;\n\tstruct ceph_mds_client *mdsc;\n\n\tdout(\"dentry_dir_lease_touch %p %p '%pd' (offset 0x%llx)\\n\",\n\t     di, dn, dn, di->offset);\n\n\tif (!list_empty(&di->lease_list)) {\n\t\tif (di->flags & CEPH_DENTRY_LEASE_LIST) {\n\t\t\t \n\t\t\tif (__dentry_lease_is_valid(di))\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tdi->flags |= CEPH_DENTRY_REFERENCED;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (di->flags & CEPH_DENTRY_SHRINK_LIST) {\n\t\tdi->flags |= CEPH_DENTRY_REFERENCED;\n\t\tdi->flags &= ~CEPH_DENTRY_LEASE_LIST;\n\t\treturn;\n\t}\n\n\tmdsc = ceph_sb_to_client(dn->d_sb)->mdsc;\n\tspin_lock(&mdsc->dentry_list_lock);\n\t__dentry_dir_lease_touch(mdsc, di),\n\tspin_unlock(&mdsc->dentry_list_lock);\n}\n\nstatic void __dentry_lease_unlist(struct ceph_dentry_info *di)\n{\n\tstruct ceph_mds_client *mdsc;\n\tif (di->flags & CEPH_DENTRY_SHRINK_LIST)\n\t\treturn;\n\tif (list_empty(&di->lease_list))\n\t\treturn;\n\n\tmdsc = ceph_sb_to_client(di->dentry->d_sb)->mdsc;\n\tspin_lock(&mdsc->dentry_list_lock);\n\tlist_del_init(&di->lease_list);\n\tspin_unlock(&mdsc->dentry_list_lock);\n}\n\nenum {\n\tKEEP\t= 0,\n\tDELETE\t= 1,\n\tTOUCH\t= 2,\n\tSTOP\t= 4,\n};\n\nstruct ceph_lease_walk_control {\n\tbool dir_lease;\n\tbool expire_dir_lease;\n\tunsigned long nr_to_scan;\n\tunsigned long dir_lease_ttl;\n};\n\nstatic unsigned long\n__dentry_leases_walk(struct ceph_mds_client *mdsc,\n\t\t     struct ceph_lease_walk_control *lwc,\n\t\t     int (*check)(struct dentry*, void*))\n{\n\tstruct ceph_dentry_info *di, *tmp;\n\tstruct dentry *dentry, *last = NULL;\n\tstruct list_head* list;\n        LIST_HEAD(dispose);\n\tunsigned long freed = 0;\n\tint ret = 0;\n\n\tlist = lwc->dir_lease ? &mdsc->dentry_dir_leases : &mdsc->dentry_leases;\n\tspin_lock(&mdsc->dentry_list_lock);\n\tlist_for_each_entry_safe(di, tmp, list, lease_list) {\n\t\tif (!lwc->nr_to_scan)\n\t\t\tbreak;\n\t\t--lwc->nr_to_scan;\n\n\t\tdentry = di->dentry;\n\t\tif (last == dentry)\n\t\t\tbreak;\n\n\t\tif (!spin_trylock(&dentry->d_lock))\n\t\t\tcontinue;\n\n\t\tif (__lockref_is_dead(&dentry->d_lockref)) {\n\t\t\tlist_del_init(&di->lease_list);\n\t\t\tgoto next;\n\t\t}\n\n\t\tret = check(dentry, lwc);\n\t\tif (ret & TOUCH) {\n\t\t\t \n\t\t\t__dentry_dir_lease_touch(mdsc, di);\n\t\t\tif (!last)\n\t\t\t\tlast = dentry;\n\t\t}\n\t\tif (ret & DELETE) {\n\t\t\t \n\t\t\tdi->flags &= ~CEPH_DENTRY_REFERENCED;\n\t\t\tif (dentry->d_lockref.count > 0) {\n\t\t\t\t \n\t\t\t\tlist_del_init(&di->lease_list);\n\t\t\t} else {\n\t\t\t\tdi->flags |= CEPH_DENTRY_SHRINK_LIST;\n\t\t\t\tlist_move_tail(&di->lease_list, &dispose);\n\t\t\t\tdget_dlock(dentry);\n\t\t\t}\n\t\t}\nnext:\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (ret & STOP)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&mdsc->dentry_list_lock);\n\n\twhile (!list_empty(&dispose)) {\n\t\tdi = list_first_entry(&dispose, struct ceph_dentry_info,\n\t\t\t\t      lease_list);\n\t\tdentry = di->dentry;\n\t\tspin_lock(&dentry->d_lock);\n\n\t\tlist_del_init(&di->lease_list);\n\t\tdi->flags &= ~CEPH_DENTRY_SHRINK_LIST;\n\t\tif (di->flags & CEPH_DENTRY_REFERENCED) {\n\t\t\tspin_lock(&mdsc->dentry_list_lock);\n\t\t\tif (di->flags & CEPH_DENTRY_LEASE_LIST) {\n\t\t\t\tlist_add_tail(&di->lease_list,\n\t\t\t\t\t      &mdsc->dentry_leases);\n\t\t\t} else {\n\t\t\t\t__dentry_dir_lease_touch(mdsc, di);\n\t\t\t}\n\t\t\tspin_unlock(&mdsc->dentry_list_lock);\n\t\t} else {\n\t\t\tfreed++;\n\t\t}\n\n\t\tspin_unlock(&dentry->d_lock);\n\t\t \n\t\tdput(dentry);\n\t}\n\treturn freed;\n}\n\nstatic int __dentry_lease_check(struct dentry *dentry, void *arg)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tint ret;\n\n\tif (__dentry_lease_is_valid(di))\n\t\treturn STOP;\n\tret = __dir_lease_try_check(dentry);\n\tif (ret == -EBUSY)\n\t\treturn KEEP;\n\tif (ret > 0)\n\t\treturn TOUCH;\n\treturn DELETE;\n}\n\nstatic int __dir_lease_check(struct dentry *dentry, void *arg)\n{\n\tstruct ceph_lease_walk_control *lwc = arg;\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\n\tint ret = __dir_lease_try_check(dentry);\n\tif (ret == -EBUSY)\n\t\treturn KEEP;\n\tif (ret > 0) {\n\t\tif (time_before(jiffies, di->time + lwc->dir_lease_ttl))\n\t\t\treturn STOP;\n\t\t \n\t\tif (!lwc->expire_dir_lease)\n\t\t\treturn TOUCH;\n\t\tif (dentry->d_lockref.count > 0 ||\n\t\t    (di->flags & CEPH_DENTRY_REFERENCED))\n\t\t\treturn TOUCH;\n\t\t \n\t\tdi->lease_shared_gen = 0;\n\t}\n\treturn DELETE;\n}\n\nint ceph_trim_dentries(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_lease_walk_control lwc;\n\tunsigned long count;\n\tunsigned long freed;\n\n\tspin_lock(&mdsc->caps_list_lock);\n        if (mdsc->caps_use_max > 0 &&\n            mdsc->caps_use_count > mdsc->caps_use_max)\n\t\tcount = mdsc->caps_use_count - mdsc->caps_use_max;\n\telse\n\t\tcount = 0;\n        spin_unlock(&mdsc->caps_list_lock);\n\n\tlwc.dir_lease = false;\n\tlwc.nr_to_scan  = CEPH_CAPS_PER_RELEASE * 2;\n\tfreed = __dentry_leases_walk(mdsc, &lwc, __dentry_lease_check);\n\tif (!lwc.nr_to_scan)  \n\t\treturn -EAGAIN;\n\n\tif (lwc.nr_to_scan < CEPH_CAPS_PER_RELEASE)\n\t\tlwc.nr_to_scan = CEPH_CAPS_PER_RELEASE;\n\n\tlwc.dir_lease = true;\n\tlwc.expire_dir_lease = freed < count;\n\tlwc.dir_lease_ttl = mdsc->fsc->mount_options->caps_wanted_delay_max * HZ;\n\tfreed +=__dentry_leases_walk(mdsc, &lwc, __dir_lease_check);\n\tif (!lwc.nr_to_scan)  \n\t\treturn -EAGAIN;\n\n\treturn freed > 0 ? 1 : 0;\n}\n\n \nvoid ceph_invalidate_dentry_lease(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tspin_lock(&dentry->d_lock);\n\tdi->time = jiffies;\n\tdi->lease_shared_gen = 0;\n\tdi->flags &= ~CEPH_DENTRY_PRIMARY_LINK;\n\t__dentry_lease_unlist(di);\n\tspin_unlock(&dentry->d_lock);\n}\n\n \nstatic bool __dentry_lease_is_valid(struct ceph_dentry_info *di)\n{\n\tstruct ceph_mds_session *session;\n\n\tif (!di->lease_gen)\n\t\treturn false;\n\n\tsession = di->lease_session;\n\tif (session) {\n\t\tu32 gen;\n\t\tunsigned long ttl;\n\n\t\tgen = atomic_read(&session->s_cap_gen);\n\t\tttl = session->s_cap_ttl;\n\n\t\tif (di->lease_gen == gen &&\n\t\t    time_before(jiffies, ttl) &&\n\t\t    time_before(jiffies, di->time))\n\t\t\treturn true;\n\t}\n\tdi->lease_gen = 0;\n\treturn false;\n}\n\nstatic int dentry_lease_is_valid(struct dentry *dentry, unsigned int flags)\n{\n\tstruct ceph_dentry_info *di;\n\tstruct ceph_mds_session *session = NULL;\n\tu32 seq = 0;\n\tint valid = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tdi = ceph_dentry(dentry);\n\tif (di && __dentry_lease_is_valid(di)) {\n\t\tvalid = 1;\n\n\t\tif (di->lease_renew_after &&\n\t\t    time_after(jiffies, di->lease_renew_after)) {\n\t\t\t \n\t\t\tif (flags & LOOKUP_RCU) {\n\t\t\t\tvalid = -ECHILD;\n\t\t\t} else {\n\t\t\t\tsession = ceph_get_mds_session(di->lease_session);\n\t\t\t\tseq = di->lease_seq;\n\t\t\t\tdi->lease_renew_after = 0;\n\t\t\t\tdi->lease_renew_from = jiffies;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\tif (session) {\n\t\tceph_mdsc_lease_send_msg(session, dentry,\n\t\t\t\t\t CEPH_MDS_LEASE_RENEW, seq);\n\t\tceph_put_mds_session(session);\n\t}\n\tdout(\"dentry_lease_is_valid - dentry %p = %d\\n\", dentry, valid);\n\treturn valid;\n}\n\n \nstatic int __dir_lease_try_check(const struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tstruct inode *dir;\n\tstruct ceph_inode_info *ci;\n\tint valid = 0;\n\n\tif (!di->lease_shared_gen)\n\t\treturn 0;\n\tif (IS_ROOT(dentry))\n\t\treturn 0;\n\n\tdir = d_inode(dentry->d_parent);\n\tci = ceph_inode(dir);\n\n\tif (spin_trylock(&ci->i_ceph_lock)) {\n\t\tif (atomic_read(&ci->i_shared_gen) == di->lease_shared_gen &&\n\t\t    __ceph_caps_issued_mask(ci, CEPH_CAP_FILE_SHARED, 0))\n\t\t\tvalid = 1;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t} else {\n\t\tvalid = -EBUSY;\n\t}\n\n\tif (!valid)\n\t\tdi->lease_shared_gen = 0;\n\treturn valid;\n}\n\n \nstatic int dir_lease_is_valid(struct inode *dir, struct dentry *dentry,\n\t\t\t      struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(dir);\n\tint valid;\n\tint shared_gen;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tvalid = __ceph_caps_issued_mask(ci, CEPH_CAP_FILE_SHARED, 1);\n\tif (valid) {\n\t\t__ceph_touch_fmode(ci, mdsc, CEPH_FILE_MODE_RD);\n\t\tshared_gen = atomic_read(&ci->i_shared_gen);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (valid) {\n\t\tstruct ceph_dentry_info *di;\n\t\tspin_lock(&dentry->d_lock);\n\t\tdi = ceph_dentry(dentry);\n\t\tif (dir == d_inode(dentry->d_parent) &&\n\t\t    di && di->lease_shared_gen == shared_gen)\n\t\t\t__ceph_dentry_dir_lease_touch(di);\n\t\telse\n\t\t\tvalid = 0;\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\tdout(\"dir_lease_is_valid dir %p v%u dentry %p = %d\\n\",\n\t     dir, (unsigned)atomic_read(&ci->i_shared_gen), dentry, valid);\n\treturn valid;\n}\n\n \nstatic int ceph_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tint valid = 0;\n\tstruct dentry *parent;\n\tstruct inode *dir, *inode;\n\tstruct ceph_mds_client *mdsc;\n\n\tvalid = fscrypt_d_revalidate(dentry, flags);\n\tif (valid <= 0)\n\t\treturn valid;\n\n\tif (flags & LOOKUP_RCU) {\n\t\tparent = READ_ONCE(dentry->d_parent);\n\t\tdir = d_inode_rcu(parent);\n\t\tif (!dir)\n\t\t\treturn -ECHILD;\n\t\tinode = d_inode_rcu(dentry);\n\t} else {\n\t\tparent = dget_parent(dentry);\n\t\tdir = d_inode(parent);\n\t\tinode = d_inode(dentry);\n\t}\n\n\tdout(\"d_revalidate %p '%pd' inode %p offset 0x%llx nokey %d\\n\", dentry,\n\t     dentry, inode, ceph_dentry(dentry)->offset,\n\t     !!(dentry->d_flags & DCACHE_NOKEY_NAME));\n\n\tmdsc = ceph_sb_to_client(dir->i_sb)->mdsc;\n\n\t \n\tif (ceph_snap(dir) != CEPH_NOSNAP) {\n\t\tdout(\"d_revalidate %p '%pd' inode %p is SNAPPED\\n\", dentry,\n\t\t     dentry, inode);\n\t\tvalid = 1;\n\t} else if (inode && ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\tvalid = 1;\n\t} else {\n\t\tvalid = dentry_lease_is_valid(dentry, flags);\n\t\tif (valid == -ECHILD)\n\t\t\treturn valid;\n\t\tif (valid || dir_lease_is_valid(dir, dentry, mdsc)) {\n\t\t\tif (inode)\n\t\t\t\tvalid = ceph_is_any_caps(inode);\n\t\t\telse\n\t\t\t\tvalid = 1;\n\t\t}\n\t}\n\n\tif (!valid) {\n\t\tstruct ceph_mds_request *req;\n\t\tint op, err;\n\t\tu32 mask;\n\n\t\tif (flags & LOOKUP_RCU)\n\t\t\treturn -ECHILD;\n\n\t\tpercpu_counter_inc(&mdsc->metric.d_lease_mis);\n\n\t\top = ceph_snap(dir) == CEPH_SNAPDIR ?\n\t\t\tCEPH_MDS_OP_LOOKUPSNAP : CEPH_MDS_OP_LOOKUP;\n\t\treq = ceph_mdsc_create_request(mdsc, op, USE_ANY_MDS);\n\t\tif (!IS_ERR(req)) {\n\t\t\treq->r_dentry = dget(dentry);\n\t\t\treq->r_num_caps = 2;\n\t\t\treq->r_parent = dir;\n\t\t\tihold(dir);\n\n\t\t\tmask = CEPH_STAT_CAP_INODE | CEPH_CAP_AUTH_SHARED;\n\t\t\tif (ceph_security_xattr_wanted(dir))\n\t\t\t\tmask |= CEPH_CAP_XATTR_SHARED;\n\t\t\treq->r_args.getattr.mask = cpu_to_le32(mask);\n\n\t\t\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\t\t\tswitch (err) {\n\t\t\tcase 0:\n\t\t\t\tif (d_really_is_positive(dentry) &&\n\t\t\t\t    d_inode(dentry) == req->r_target_inode)\n\t\t\t\t\tvalid = 1;\n\t\t\t\tbreak;\n\t\t\tcase -ENOENT:\n\t\t\t\tif (d_really_is_negative(dentry))\n\t\t\t\t\tvalid = 1;\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tceph_mdsc_put_request(req);\n\t\t\tdout(\"d_revalidate %p lookup result=%d\\n\",\n\t\t\t     dentry, err);\n\t\t}\n\t} else {\n\t\tpercpu_counter_inc(&mdsc->metric.d_lease_hit);\n\t}\n\n\tdout(\"d_revalidate %p %s\\n\", dentry, valid ? \"valid\" : \"invalid\");\n\tif (!valid)\n\t\tceph_dir_clear_complete(dir);\n\n\tif (!(flags & LOOKUP_RCU))\n\t\tdput(parent);\n\treturn valid;\n}\n\n \nstatic int ceph_d_delete(const struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di;\n\n\t \n\tif (d_really_is_negative(dentry))\n\t\treturn 0;\n\tif (ceph_snap(d_inode(dentry)) != CEPH_NOSNAP)\n\t\treturn 0;\n\t \n\tdi = ceph_dentry(dentry);\n\tif (di) {\n\t\tif (__dentry_lease_is_valid(di))\n\t\t\treturn 0;\n\t\tif (__dir_lease_try_check(dentry))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nstatic void ceph_d_release(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(dentry->d_sb);\n\n\tdout(\"d_release %p\\n\", dentry);\n\n\tatomic64_dec(&fsc->mdsc->metric.total_dentries);\n\n\tspin_lock(&dentry->d_lock);\n\t__dentry_lease_unlist(di);\n\tdentry->d_fsdata = NULL;\n\tspin_unlock(&dentry->d_lock);\n\n\tceph_put_mds_session(di->lease_session);\n\tkmem_cache_free(ceph_dentry_cachep, di);\n}\n\n \nstatic void ceph_d_prune(struct dentry *dentry)\n{\n\tstruct ceph_inode_info *dir_ci;\n\tstruct ceph_dentry_info *di;\n\n\tdout(\"ceph_d_prune %pd %p\\n\", dentry, dentry);\n\n\t \n\tif (IS_ROOT(dentry))\n\t\treturn;\n\n\t \n\tdir_ci = ceph_inode(d_inode(dentry->d_parent));\n\tif (dir_ci->i_vino.snap == CEPH_SNAPDIR)\n\t\treturn;\n\n\t \n\tif (d_really_is_negative(dentry))\n\t\treturn;\n\n\t \n\tif (!d_unhashed(dentry)) {\n\t\t__ceph_dir_clear_complete(dir_ci);\n\t\treturn;\n\t}\n\n\t \n\tdi = ceph_dentry(dentry);\n\tif (di->offset > 0 &&\n\t    di->lease_shared_gen == atomic_read(&dir_ci->i_shared_gen))\n\t\t__ceph_dir_clear_ordered(dir_ci);\n}\n\n \nstatic ssize_t ceph_read_dir(struct file *file, char __user *buf, size_t size,\n\t\t\t     loff_t *ppos)\n{\n\tstruct ceph_dir_file_info *dfi = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint left;\n\tconst int bufsize = 1024;\n\n\tif (!ceph_test_mount_opt(ceph_sb_to_client(inode->i_sb), DIRSTAT))\n\t\treturn -EISDIR;\n\n\tif (!dfi->dir_info) {\n\t\tdfi->dir_info = kmalloc(bufsize, GFP_KERNEL);\n\t\tif (!dfi->dir_info)\n\t\t\treturn -ENOMEM;\n\t\tdfi->dir_info_len =\n\t\t\tsnprintf(dfi->dir_info, bufsize,\n\t\t\t\t\"entries:   %20lld\\n\"\n\t\t\t\t\" files:    %20lld\\n\"\n\t\t\t\t\" subdirs:  %20lld\\n\"\n\t\t\t\t\"rentries:  %20lld\\n\"\n\t\t\t\t\" rfiles:   %20lld\\n\"\n\t\t\t\t\" rsubdirs: %20lld\\n\"\n\t\t\t\t\"rbytes:    %20lld\\n\"\n\t\t\t\t\"rctime:    %10lld.%09ld\\n\",\n\t\t\t\tci->i_files + ci->i_subdirs,\n\t\t\t\tci->i_files,\n\t\t\t\tci->i_subdirs,\n\t\t\t\tci->i_rfiles + ci->i_rsubdirs,\n\t\t\t\tci->i_rfiles,\n\t\t\t\tci->i_rsubdirs,\n\t\t\t\tci->i_rbytes,\n\t\t\t\tci->i_rctime.tv_sec,\n\t\t\t\tci->i_rctime.tv_nsec);\n\t}\n\n\tif (*ppos >= dfi->dir_info_len)\n\t\treturn 0;\n\tsize = min_t(unsigned, size, dfi->dir_info_len-*ppos);\n\tleft = copy_to_user(buf, dfi->dir_info + *ppos, size);\n\tif (left == size)\n\t\treturn -EFAULT;\n\t*ppos += (size - left);\n\treturn size - left;\n}\n\n\n\n \nunsigned ceph_dentry_hash(struct inode *dir, struct dentry *dn)\n{\n\tstruct ceph_inode_info *dci = ceph_inode(dir);\n\tunsigned hash;\n\n\tswitch (dci->i_dir_layout.dl_dir_hash) {\n\tcase 0:\t \n\tcase CEPH_STR_HASH_LINUX:\n\t\treturn dn->d_name.hash;\n\n\tdefault:\n\t\tspin_lock(&dn->d_lock);\n\t\thash = ceph_str_hash(dci->i_dir_layout.dl_dir_hash,\n\t\t\t\t     dn->d_name.name, dn->d_name.len);\n\t\tspin_unlock(&dn->d_lock);\n\t\treturn hash;\n\t}\n}\n\nWRAP_DIR_ITER(ceph_readdir) \nconst struct file_operations ceph_dir_fops = {\n\t.read = ceph_read_dir,\n\t.iterate_shared = shared_ceph_readdir,\n\t.llseek = ceph_dir_llseek,\n\t.open = ceph_open,\n\t.release = ceph_release,\n\t.unlocked_ioctl = ceph_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n\t.fsync = ceph_fsync,\n\t.lock = ceph_lock,\n\t.flock = ceph_flock,\n};\n\nconst struct file_operations ceph_snapdir_fops = {\n\t.iterate_shared = shared_ceph_readdir,\n\t.llseek = ceph_dir_llseek,\n\t.open = ceph_open,\n\t.release = ceph_release,\n};\n\nconst struct inode_operations ceph_dir_iops = {\n\t.lookup = ceph_lookup,\n\t.permission = ceph_permission,\n\t.getattr = ceph_getattr,\n\t.setattr = ceph_setattr,\n\t.listxattr = ceph_listxattr,\n\t.get_inode_acl = ceph_get_acl,\n\t.set_acl = ceph_set_acl,\n\t.mknod = ceph_mknod,\n\t.symlink = ceph_symlink,\n\t.mkdir = ceph_mkdir,\n\t.link = ceph_link,\n\t.unlink = ceph_unlink,\n\t.rmdir = ceph_unlink,\n\t.rename = ceph_rename,\n\t.create = ceph_create,\n\t.atomic_open = ceph_atomic_open,\n};\n\nconst struct inode_operations ceph_snapdir_iops = {\n\t.lookup = ceph_lookup,\n\t.permission = ceph_permission,\n\t.getattr = ceph_getattr,\n\t.mkdir = ceph_mkdir,\n\t.rmdir = ceph_unlink,\n\t.rename = ceph_rename,\n};\n\nconst struct dentry_operations ceph_dentry_ops = {\n\t.d_revalidate = ceph_d_revalidate,\n\t.d_delete = ceph_d_delete,\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n\t.d_init = ceph_d_init,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}