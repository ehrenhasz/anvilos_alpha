{
  "module_name": "mds_client.h",
  "hash_id": "97fea4da9f382c6ae458112f80e54b579e01eeefc0a3bad1870907abdf89b158",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/mds_client.h",
  "human_readable_source": " \n#ifndef _FS_CEPH_MDS_CLIENT_H\n#define _FS_CEPH_MDS_CLIENT_H\n\n#include <linux/completion.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/rbtree.h>\n#include <linux/spinlock.h>\n#include <linux/refcount.h>\n#include <linux/utsname.h>\n#include <linux/ktime.h>\n\n#include <linux/ceph/types.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/auth.h>\n\n#include \"metric.h\"\n#include \"super.h\"\n\n \nenum ceph_feature_type {\n\tCEPHFS_FEATURE_MIMIC = 8,\n\tCEPHFS_FEATURE_REPLY_ENCODING,\n\tCEPHFS_FEATURE_RECLAIM_CLIENT,\n\tCEPHFS_FEATURE_LAZY_CAP_WANTED,\n\tCEPHFS_FEATURE_MULTI_RECONNECT,\n\tCEPHFS_FEATURE_DELEG_INO,\n\tCEPHFS_FEATURE_METRIC_COLLECT,\n\tCEPHFS_FEATURE_ALTERNATE_NAME,\n\tCEPHFS_FEATURE_NOTIFY_SESSION_STATE,\n\tCEPHFS_FEATURE_OP_GETVXATTR,\n\tCEPHFS_FEATURE_32BITS_RETRY_FWD,\n\n\tCEPHFS_FEATURE_MAX = CEPHFS_FEATURE_32BITS_RETRY_FWD,\n};\n\n#define CEPHFS_FEATURES_CLIENT_SUPPORTED {\t\\\n\t0, 1, 2, 3, 4, 5, 6, 7,\t\t\t\\\n\tCEPHFS_FEATURE_MIMIC,\t\t\t\\\n\tCEPHFS_FEATURE_REPLY_ENCODING,\t\t\\\n\tCEPHFS_FEATURE_LAZY_CAP_WANTED,\t\t\\\n\tCEPHFS_FEATURE_MULTI_RECONNECT,\t\t\\\n\tCEPHFS_FEATURE_DELEG_INO,\t\t\\\n\tCEPHFS_FEATURE_METRIC_COLLECT,\t\t\\\n\tCEPHFS_FEATURE_ALTERNATE_NAME,\t\t\\\n\tCEPHFS_FEATURE_NOTIFY_SESSION_STATE,\t\\\n\tCEPHFS_FEATURE_OP_GETVXATTR,\t\t\\\n\tCEPHFS_FEATURE_32BITS_RETRY_FWD,\t\\\n}\n\n \n\nstruct ceph_fs_client;\nstruct ceph_cap;\n\n \nstruct ceph_mds_reply_info_in {\n\tstruct ceph_mds_reply_inode *in;\n\tstruct ceph_dir_layout dir_layout;\n\tu32 symlink_len;\n\tchar *symlink;\n\tu32 xattr_len;\n\tchar *xattr_data;\n\tu64 inline_version;\n\tu32 inline_len;\n\tchar *inline_data;\n\tu32 pool_ns_len;\n\tchar *pool_ns_data;\n\tu64 max_bytes;\n\tu64 max_files;\n\ts32 dir_pin;\n\tstruct ceph_timespec btime;\n\tstruct ceph_timespec snap_btime;\n\tu8 *fscrypt_auth;\n\tu8 *fscrypt_file;\n\tu32 fscrypt_auth_len;\n\tu32 fscrypt_file_len;\n\tu64 rsnaps;\n\tu64 change_attr;\n};\n\nstruct ceph_mds_reply_dir_entry {\n\tbool\t\t\t      is_nokey;\n\tchar                          *name;\n\tu32                           name_len;\n\tu32\t\t\t      raw_hash;\n\tstruct ceph_mds_reply_lease   *lease;\n\tstruct ceph_mds_reply_info_in inode;\n\tloff_t\t\t\t      offset;\n};\n\nstruct ceph_mds_reply_xattr {\n\tchar *xattr_value;\n\tsize_t xattr_value_len;\n};\n\n \nstruct ceph_mds_reply_info_parsed {\n\tstruct ceph_mds_reply_head    *head;\n\n\t \n\tstruct ceph_mds_reply_info_in diri, targeti;\n\tstruct ceph_mds_reply_dirfrag *dirfrag;\n\tchar                          *dname;\n\tu8\t\t\t      *altname;\n\tu32                           dname_len;\n\tu32                           altname_len;\n\tstruct ceph_mds_reply_lease   *dlease;\n\tstruct ceph_mds_reply_xattr   xattr_info;\n\n\t \n\tunion {\n\t\t \n\t\tstruct ceph_filelock *filelock_reply;\n\n\t\t \n\t\tstruct {\n\t\t\tstruct ceph_mds_reply_dirfrag *dir_dir;\n\t\t\tsize_t\t\t\t      dir_buf_size;\n\t\t\tint                           dir_nr;\n\t\t\tbool\t\t\t      dir_end;\n\t\t\tbool\t\t\t      dir_complete;\n\t\t\tbool\t\t\t      hash_order;\n\t\t\tbool\t\t\t      offset_hash;\n\t\t\tstruct ceph_mds_reply_dir_entry  *dir_entries;\n\t\t};\n\n\t\t \n\t\tstruct {\n\t\t\tbool has_create_ino;\n\t\t\tu64 ino;\n\t\t};\n\t};\n\n\t \n\tvoid *snapblob;\n\tint snapblob_len;\n};\n\n\n \n#define CEPH_CAPS_PER_RELEASE ((PAGE_SIZE - sizeof(u32) -\t\t\\\n\t\t\t\tsizeof(struct ceph_mds_cap_release)) /\t\\\n\t\t\t        sizeof(struct ceph_mds_cap_item))\n\n\n \nenum {\n\tCEPH_MDS_SESSION_NEW = 1,\n\tCEPH_MDS_SESSION_OPENING = 2,\n\tCEPH_MDS_SESSION_OPEN = 3,\n\tCEPH_MDS_SESSION_HUNG = 4,\n\tCEPH_MDS_SESSION_RESTARTING = 5,\n\tCEPH_MDS_SESSION_RECONNECTING = 6,\n\tCEPH_MDS_SESSION_CLOSING = 7,\n\tCEPH_MDS_SESSION_CLOSED = 8,\n\tCEPH_MDS_SESSION_REJECTED = 9,\n};\n\nstruct ceph_mds_session {\n\tstruct ceph_mds_client *s_mdsc;\n\tint               s_mds;\n\tint               s_state;\n\tunsigned long     s_ttl;       \n\tunsigned long\t  s_features;\n\tu64               s_seq;       \n\tstruct mutex      s_mutex;     \n\n\tstruct ceph_connection s_con;\n\n\tstruct ceph_auth_handshake s_auth;\n\n\tatomic_t          s_cap_gen;   \n\tunsigned long     s_cap_ttl;   \n\n\t \n\tspinlock_t        s_cap_lock;\n\trefcount_t        s_ref;\n\tstruct list_head  s_caps;      \n\tstruct ceph_cap  *s_cap_iterator;\n\tint               s_nr_caps;\n\tint               s_num_cap_releases;\n\tint\t\t  s_cap_reconnect;\n\tint\t\t  s_readonly;\n\tstruct list_head  s_cap_releases;  \n\tstruct work_struct s_cap_release_work;\n\n\t \n\tstruct list_head  s_cap_dirty;\t       \n\n\t \n\tstruct list_head  s_cap_flushing;      \n\n\tunsigned long     s_renew_requested;  \n\tu64               s_renew_seq;\n\n\tstruct list_head  s_waiting;   \n\tstruct list_head  s_unsafe;    \n\tstruct xarray\t  s_delegated_inos;\n};\n\n \nenum {\n\tUSE_ANY_MDS,\n\tUSE_RANDOM_MDS,\n\tUSE_AUTH_MDS,    \n};\n\nstruct ceph_mds_request;\nstruct ceph_mds_client;\n\n \ntypedef void (*ceph_mds_request_callback_t) (struct ceph_mds_client *mdsc,\n\t\t\t\t\t     struct ceph_mds_request *req);\n \ntypedef int (*ceph_mds_request_wait_callback_t) (struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t struct ceph_mds_request *req);\n\n \nstruct ceph_mds_request {\n\tu64 r_tid;                    \n\tstruct rb_node r_node;\n\tstruct ceph_mds_client *r_mdsc;\n\n\tstruct kref       r_kref;\n\tint r_op;                     \n\n\t \n\tstruct inode *r_inode;               \n\tstruct dentry *r_dentry;             \n\tstruct dentry *r_old_dentry;         \n\tstruct inode *r_old_dentry_dir;      \n\tchar *r_path1, *r_path2;\n\tstruct ceph_vino r_ino1, r_ino2;\n\n\tstruct inode *r_parent;\t\t     \n\tstruct inode *r_target_inode;        \n\tstruct inode *r_new_inode;\t     \n\n#define CEPH_MDS_R_DIRECT_IS_HASH\t(1)  \n#define CEPH_MDS_R_ABORTED\t\t(2)  \n#define CEPH_MDS_R_GOT_UNSAFE\t\t(3)  \n#define CEPH_MDS_R_GOT_SAFE\t\t(4)  \n#define CEPH_MDS_R_GOT_RESULT\t\t(5)  \n#define CEPH_MDS_R_DID_PREPOPULATE\t(6)  \n#define CEPH_MDS_R_PARENT_LOCKED\t(7)  \n#define CEPH_MDS_R_ASYNC\t\t(8)  \n#define CEPH_MDS_R_FSCRYPT_FILE\t\t(9)  \n\tunsigned long\tr_req_flags;\n\n\tstruct mutex r_fill_mutex;\n\n\tunion ceph_mds_request_args r_args;\n\n\tstruct ceph_fscrypt_auth *r_fscrypt_auth;\n\tu64\tr_fscrypt_file;\n\n\tu8 *r_altname;\t\t     \n\tu32 r_altname_len;\t     \n\n\tint r_fmode;         \n\tint r_request_release_offset;\n\tconst struct cred *r_cred;\n\tstruct timespec64 r_stamp;\n\n\t \n\tint r_direct_mode;\n\tu32 r_direct_hash;       \n\n\t \n\tstruct ceph_pagelist *r_pagelist;\n\n\t \n\tint r_inode_drop, r_inode_unless;\n\tint r_dentry_drop, r_dentry_unless;\n\tint r_old_dentry_drop, r_old_dentry_unless;\n\tstruct inode *r_old_inode;\n\tint r_old_inode_drop, r_old_inode_unless;\n\n\tstruct ceph_msg  *r_request;   \n\tstruct ceph_msg  *r_reply;\n\tstruct ceph_mds_reply_info_parsed r_reply_info;\n\tint r_err;\n\tu32               r_readdir_offset;\n\n\tstruct page *r_locked_page;\n\tint r_dir_caps;\n\tint r_num_caps;\n\n\tunsigned long r_timeout;   \n\tunsigned long r_started;   \n\tunsigned long r_start_latency;   \n\tunsigned long r_end_latency;     \n\tunsigned long r_request_started;  \n\n\t \n\tstruct inode\t*r_unsafe_dir;\n\tstruct list_head r_unsafe_dir_item;\n\n\t \n\tstruct list_head r_unsafe_target_item;\n\n\tstruct ceph_mds_session *r_session;\n\n\tint               r_attempts;    \n\tint               r_num_fwd;     \n\tint               r_resend_mds;  \n\tu32               r_sent_on_mseq;  \n\tu64\t\t  r_deleg_ino;\n\n\tstruct list_head  r_wait;\n\tstruct completion r_completion;\n\tstruct completion r_safe_completion;\n\tceph_mds_request_callback_t r_callback;\n\tstruct list_head  r_unsafe_item;   \n\n\tlong long\t  r_dir_release_cnt;\n\tlong long\t  r_dir_ordered_cnt;\n\tint\t\t  r_readdir_cache_idx;\n\n\tint\t\t  r_feature_needed;\n\n\tstruct ceph_cap_reservation r_caps_reservation;\n};\n\nstruct ceph_pool_perm {\n\tstruct rb_node node;\n\tint perm;\n\ts64 pool;\n\tsize_t pool_ns_len;\n\tchar pool_ns[];\n};\n\nstruct ceph_snapid_map {\n\tstruct rb_node node;\n\tstruct list_head lru;\n\tatomic_t ref;\n\tdev_t dev;\n\tu64 snap;\n\tunsigned long last_used;\n};\n\n \nstruct ceph_quotarealm_inode {\n\tstruct rb_node node;\n\tu64 ino;\n\tunsigned long timeout;  \n\tstruct mutex mutex;\n\tstruct inode *inode;\n};\n\nstruct cap_wait {\n\tstruct list_head\tlist;\n\tu64\t\t\tino;\n\tpid_t\t\t\ttgid;\n\tint\t\t\tneed;\n\tint\t\t\twant;\n};\n\nenum {\n\tCEPH_MDSC_STOPPING_BEGIN = 1,\n\tCEPH_MDSC_STOPPING_FLUSHING = 2,\n\tCEPH_MDSC_STOPPING_FLUSHED = 3,\n};\n\n \nstruct ceph_mds_client {\n\tstruct ceph_fs_client  *fsc;\n\tstruct mutex            mutex;          \n\n\tstruct ceph_mdsmap      *mdsmap;\n\tstruct completion       safe_umount_waiters;\n\twait_queue_head_t       session_close_wq;\n\tstruct list_head        waiting_for_map;\n\tint \t\t\tmdsmap_err;\n\n\tstruct ceph_mds_session **sessions;     \n\tatomic_t\t\tnum_sessions;\n\tint                     max_sessions;   \n\n\tspinlock_t              stopping_lock;   \n\tint                     stopping;       \n\tatomic_t                stopping_blockers;\n\tstruct completion\tstopping_waiter;\n\n\tatomic64_t\t\tquotarealms_count;  \n\t \n\tstruct rb_root\t\tquotarealms_inodes;\n\tstruct mutex\t\tquotarealms_inodes_mutex;\n\n\t \n\tu64\t\t\tlast_snap_seq;\n\tstruct rw_semaphore     snap_rwsem;\n\tstruct rb_root          snap_realms;\n\tstruct list_head        snap_empty;\n\tint\t\t\tnum_snap_realms;\n\tspinlock_t              snap_empty_lock;   \n\n\tu64                    last_tid;       \n\tu64                    oldest_tid;     \n\tstruct rb_root         request_tree;   \n\tstruct delayed_work    delayed_work;   \n\tunsigned long    last_renew_caps;   \n\tstruct list_head cap_delay_list;    \n\tspinlock_t       cap_delay_lock;    \n\tstruct list_head snap_flush_list;   \n\tspinlock_t       snap_flush_lock;\n\n\tu64               last_cap_flush_tid;\n\tstruct list_head  cap_flush_list;\n\tstruct list_head  cap_dirty_migrating;  \n\tint               num_cap_flushing;  \n\tspinlock_t        cap_dirty_lock;    \n\twait_queue_head_t cap_flushing_wq;\n\n\tstruct work_struct cap_reclaim_work;\n\tatomic_t\t   cap_reclaim_pending;\n\n\t \n\tspinlock_t\tcaps_list_lock;\n\tstruct\t\tlist_head caps_list;  \n\tstruct\t\tlist_head cap_wait_list;\n\tint\t\tcaps_total_count;     \n\tint\t\tcaps_use_count;       \n\tint\t\tcaps_use_max;\t      \n\tint\t\tcaps_reserve_count;   \n\tint\t\tcaps_avail_count;     \n\tint\t\tcaps_min_count;       \n\tspinlock_t\t  dentry_list_lock;\n\tstruct list_head  dentry_leases;      \n\tstruct list_head  dentry_dir_leases;  \n\n\tstruct ceph_client_metric metric;\n\n\tspinlock_t\t\tsnapid_map_lock;\n\tstruct rb_root\t\tsnapid_map_tree;\n\tstruct list_head\tsnapid_map_lru;\n\n\tstruct rw_semaphore     pool_perm_rwsem;\n\tstruct rb_root\t\tpool_perm_tree;\n\n\tchar nodename[__NEW_UTS_LEN + 1];\n};\n\nextern const char *ceph_mds_op_name(int op);\n\nextern bool check_session_state(struct ceph_mds_session *s);\nvoid inc_session_sequence(struct ceph_mds_session *s);\n\nextern struct ceph_mds_session *\n__ceph_lookup_mds_session(struct ceph_mds_client *, int mds);\n\nextern const char *ceph_session_state_name(int s);\n\nextern struct ceph_mds_session *\nceph_get_mds_session(struct ceph_mds_session *s);\nextern void ceph_put_mds_session(struct ceph_mds_session *s);\n\nextern int ceph_send_msg_mds(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_msg *msg, int mds);\n\nextern int ceph_mdsc_init(struct ceph_fs_client *fsc);\nextern void ceph_mdsc_close_sessions(struct ceph_mds_client *mdsc);\nextern void ceph_mdsc_force_umount(struct ceph_mds_client *mdsc);\nextern void ceph_mdsc_destroy(struct ceph_fs_client *fsc);\n\nextern void ceph_mdsc_sync(struct ceph_mds_client *mdsc);\n\nextern void ceph_invalidate_dir_request(struct ceph_mds_request *req);\nextern int ceph_alloc_readdir_reply_buffer(struct ceph_mds_request *req,\n\t\t\t\t\t   struct inode *dir);\nextern struct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode);\nextern int ceph_mdsc_submit_request(struct ceph_mds_client *mdsc,\n\t\t\t\t    struct inode *dir,\n\t\t\t\t    struct ceph_mds_request *req);\nint ceph_mdsc_wait_request(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req,\n\t\t\tceph_mds_request_wait_callback_t wait_func);\nextern int ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t\tstruct inode *dir,\n\t\t\t\tstruct ceph_mds_request *req);\nextern void ceph_mdsc_release_dir_caps(struct ceph_mds_request *req);\nextern void ceph_mdsc_release_dir_caps_no_check(struct ceph_mds_request *req);\nstatic inline void ceph_mdsc_get_request(struct ceph_mds_request *req)\n{\n\tkref_get(&req->r_kref);\n}\nextern void ceph_mdsc_release_request(struct kref *kref);\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}\n\nextern void send_flush_mdlog(struct ceph_mds_session *s);\nextern void ceph_mdsc_iterate_sessions(struct ceph_mds_client *mdsc,\n\t\t\t\t       void (*cb)(struct ceph_mds_session *),\n\t\t\t\t       bool check_state);\nextern struct ceph_msg *ceph_create_session_msg(u32 op, u64 seq);\nextern void __ceph_queue_cap_release(struct ceph_mds_session *session,\n\t\t\t\t    struct ceph_cap *cap);\nextern void ceph_flush_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t\t    struct ceph_mds_session *session);\nextern void ceph_queue_cap_reclaim_work(struct ceph_mds_client *mdsc);\nextern void ceph_reclaim_caps_nr(struct ceph_mds_client *mdsc, int nr);\nextern int ceph_iterate_session_caps(struct ceph_mds_session *session,\n\t\t\t\t     int (*cb)(struct inode *, int mds, void *),\n\t\t\t\t     void *arg);\nextern void ceph_mdsc_pre_umount(struct ceph_mds_client *mdsc);\n\nstatic inline void ceph_mdsc_free_path(char *path, int len)\n{\n\tif (!IS_ERR_OR_NULL(path))\n\t\t__putname(path - (PATH_MAX - 1 - len));\n}\n\nextern char *ceph_mdsc_build_path(struct dentry *dentry, int *plen, u64 *base,\n\t\t\t\t  int for_wire);\n\nextern void __ceph_mdsc_drop_dentry_lease(struct dentry *dentry);\nextern void ceph_mdsc_lease_send_msg(struct ceph_mds_session *session,\n\t\t\t\t     struct dentry *dentry, char action,\n\t\t\t\t     u32 seq);\n\nextern void ceph_mdsc_handle_mdsmap(struct ceph_mds_client *mdsc,\n\t\t\t\t    struct ceph_msg *msg);\nextern void ceph_mdsc_handle_fsmap(struct ceph_mds_client *mdsc,\n\t\t\t\t   struct ceph_msg *msg);\n\nextern struct ceph_mds_session *\nceph_mdsc_open_export_target_session(struct ceph_mds_client *mdsc, int target);\nextern void ceph_mdsc_open_export_target_sessions(struct ceph_mds_client *mdsc,\n\t\t\t\t\t  struct ceph_mds_session *session);\n\nextern int ceph_trim_caps(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session,\n\t\t\t  int max_caps);\n\nstatic inline int ceph_wait_on_async_create(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\treturn wait_on_bit(&ci->i_ceph_flags, CEPH_ASYNC_CREATE_BIT,\n\t\t\t   TASK_KILLABLE);\n}\n\nextern int ceph_wait_on_conflict_unlink(struct dentry *dentry);\nextern u64 ceph_get_deleg_ino(struct ceph_mds_session *session);\nextern int ceph_restore_deleg_ino(struct ceph_mds_session *session, u64 ino);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}