{
  "module_name": "crypto.c",
  "hash_id": "e2dd7f4c98818fea4f6fc327091fdcdc07fc6b44da53b7e977a1e312c1c7678f",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/crypto.c",
  "human_readable_source": "\n \n#include <linux/ceph/ceph_debug.h>\n#include <linux/xattr.h>\n#include <linux/fscrypt.h>\n#include <linux/ceph/striper.h>\n\n#include \"super.h\"\n#include \"mds_client.h\"\n#include \"crypto.h\"\n\n \nstatic const char base64_table[65] =\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+,\";\n\nint ceph_base64_encode(const u8 *src, int srclen, char *dst)\n{\n\tu32 ac = 0;\n\tint bits = 0;\n\tint i;\n\tchar *cp = dst;\n\n\tfor (i = 0; i < srclen; i++) {\n\t\tac = (ac << 8) | src[i];\n\t\tbits += 8;\n\t\tdo {\n\t\t\tbits -= 6;\n\t\t\t*cp++ = base64_table[(ac >> bits) & 0x3f];\n\t\t} while (bits >= 6);\n\t}\n\tif (bits)\n\t\t*cp++ = base64_table[(ac << (6 - bits)) & 0x3f];\n\treturn cp - dst;\n}\n\nint ceph_base64_decode(const char *src, int srclen, u8 *dst)\n{\n\tu32 ac = 0;\n\tint bits = 0;\n\tint i;\n\tu8 *bp = dst;\n\n\tfor (i = 0; i < srclen; i++) {\n\t\tconst char *p = strchr(base64_table, src[i]);\n\n\t\tif (p == NULL || src[i] == 0)\n\t\t\treturn -1;\n\t\tac = (ac << 6) | (p - base64_table);\n\t\tbits += 6;\n\t\tif (bits >= 8) {\n\t\t\tbits -= 8;\n\t\t\t*bp++ = (u8)(ac >> bits);\n\t\t}\n\t}\n\tif (ac & ((1 << bits) - 1))\n\t\treturn -1;\n\treturn bp - dst;\n}\n\nstatic int ceph_crypt_get_context(struct inode *inode, void *ctx, size_t len)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fscrypt_auth *cfa = (struct ceph_fscrypt_auth *)ci->fscrypt_auth;\n\tu32 ctxlen;\n\n\t \n\tif (!cfa || (ci->fscrypt_auth_len < (offsetof(struct ceph_fscrypt_auth, cfa_blob) + 1)))\n\t\treturn -ENOBUFS;\n\n\t \n\tif (le32_to_cpu(cfa->cfa_version) != CEPH_FSCRYPT_AUTH_VERSION)\n\t\treturn -ENOBUFS;\n\n\tctxlen = le32_to_cpu(cfa->cfa_blob_len);\n\tif (len < ctxlen)\n\t\treturn -ERANGE;\n\n\tmemcpy(ctx, cfa->cfa_blob, ctxlen);\n\treturn ctxlen;\n}\n\nstatic int ceph_crypt_set_context(struct inode *inode, const void *ctx,\n\t\t\t\t  size_t len, void *fs_data)\n{\n\tint ret;\n\tstruct iattr attr = { };\n\tstruct ceph_iattr cia = { };\n\tstruct ceph_fscrypt_auth *cfa;\n\n\tWARN_ON_ONCE(fs_data);\n\n\tif (len > FSCRYPT_SET_CONTEXT_MAX_SIZE)\n\t\treturn -EINVAL;\n\n\tcfa = kzalloc(sizeof(*cfa), GFP_KERNEL);\n\tif (!cfa)\n\t\treturn -ENOMEM;\n\n\tcfa->cfa_version = cpu_to_le32(CEPH_FSCRYPT_AUTH_VERSION);\n\tcfa->cfa_blob_len = cpu_to_le32(len);\n\tmemcpy(cfa->cfa_blob, ctx, len);\n\n\tcia.fscrypt_auth = cfa;\n\n\tret = __ceph_setattr(inode, &attr, &cia);\n\tif (ret == 0)\n\t\tinode_set_flags(inode, S_ENCRYPTED, S_ENCRYPTED);\n\tkfree(cia.fscrypt_auth);\n\treturn ret;\n}\n\nstatic bool ceph_crypt_empty_dir(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\treturn ci->i_rsubdirs + ci->i_rfiles == 1;\n}\n\nstatic const union fscrypt_policy *ceph_get_dummy_policy(struct super_block *sb)\n{\n\treturn ceph_sb_to_client(sb)->fsc_dummy_enc_policy.policy;\n}\n\nstatic struct fscrypt_operations ceph_fscrypt_ops = {\n\t.get_context\t\t= ceph_crypt_get_context,\n\t.set_context\t\t= ceph_crypt_set_context,\n\t.get_dummy_policy\t= ceph_get_dummy_policy,\n\t.empty_dir\t\t= ceph_crypt_empty_dir,\n};\n\nvoid ceph_fscrypt_set_ops(struct super_block *sb)\n{\n\tfscrypt_set_ops(sb, &ceph_fscrypt_ops);\n}\n\nvoid ceph_fscrypt_free_dummy_policy(struct ceph_fs_client *fsc)\n{\n\tfscrypt_free_dummy_policy(&fsc->fsc_dummy_enc_policy);\n}\n\nint ceph_fscrypt_prepare_context(struct inode *dir, struct inode *inode,\n\t\t\t\t struct ceph_acl_sec_ctx *as)\n{\n\tint ret, ctxsize;\n\tbool encrypted = false;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tret = fscrypt_prepare_new_inode(dir, inode, &encrypted);\n\tif (ret)\n\t\treturn ret;\n\tif (!encrypted)\n\t\treturn 0;\n\n\tas->fscrypt_auth = kzalloc(sizeof(*as->fscrypt_auth), GFP_KERNEL);\n\tif (!as->fscrypt_auth)\n\t\treturn -ENOMEM;\n\n\tctxsize = fscrypt_context_for_new_inode(as->fscrypt_auth->cfa_blob,\n\t\t\t\t\t\tinode);\n\tif (ctxsize < 0)\n\t\treturn ctxsize;\n\n\tas->fscrypt_auth->cfa_version = cpu_to_le32(CEPH_FSCRYPT_AUTH_VERSION);\n\tas->fscrypt_auth->cfa_blob_len = cpu_to_le32(ctxsize);\n\n\tWARN_ON_ONCE(ci->fscrypt_auth);\n\tkfree(ci->fscrypt_auth);\n\tci->fscrypt_auth_len = ceph_fscrypt_auth_len(as->fscrypt_auth);\n\tci->fscrypt_auth = kmemdup(as->fscrypt_auth, ci->fscrypt_auth_len,\n\t\t\t\t   GFP_KERNEL);\n\tif (!ci->fscrypt_auth)\n\t\treturn -ENOMEM;\n\n\tinode->i_flags |= S_ENCRYPTED;\n\n\treturn 0;\n}\n\nvoid ceph_fscrypt_as_ctx_to_req(struct ceph_mds_request *req,\n\t\t\t\tstruct ceph_acl_sec_ctx *as)\n{\n\tswap(req->r_fscrypt_auth, as->fscrypt_auth);\n}\n\n \nstatic struct inode *parse_longname(const struct inode *parent,\n\t\t\t\t    const char *name, int *name_len)\n{\n\tstruct inode *dir = NULL;\n\tstruct ceph_vino vino = { .snap = CEPH_NOSNAP };\n\tchar *inode_number;\n\tchar *name_end;\n\tint orig_len = *name_len;\n\tint ret = -EIO;\n\n\t \n\tname++;\n\tname_end = strrchr(name, '_');\n\tif (!name_end) {\n\t\tdout(\"Failed to parse long snapshot name: %s\\n\", name);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\t*name_len = (name_end - name);\n\tif (*name_len <= 0) {\n\t\tpr_err(\"Failed to parse long snapshot name\\n\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\t \n\tinode_number = kmemdup_nul(name_end + 1,\n\t\t\t\t   orig_len - *name_len - 2,\n\t\t\t\t   GFP_KERNEL);\n\tif (!inode_number)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = kstrtou64(inode_number, 10, &vino.ino);\n\tif (ret) {\n\t\tdout(\"Failed to parse inode number: %s\\n\", name);\n\t\tdir = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tdir = ceph_find_inode(parent->i_sb, vino);\n\tif (!dir) {\n\t\t \n\t\tdir = ceph_get_inode(parent->i_sb, vino, NULL);\n\t\tif (IS_ERR(dir))\n\t\t\tdout(\"Can't find inode %s (%s)\\n\", inode_number, name);\n\t}\n\nout:\n\tkfree(inode_number);\n\treturn dir;\n}\n\nint ceph_encode_encrypted_dname(struct inode *parent, struct qstr *d_name,\n\t\t\t\tchar *buf)\n{\n\tstruct inode *dir = parent;\n\tstruct qstr iname;\n\tu32 len;\n\tint name_len;\n\tint elen;\n\tint ret;\n\tu8 *cryptbuf = NULL;\n\n\tiname.name = d_name->name;\n\tname_len = d_name->len;\n\n\t \n\tif ((ceph_snap(dir) == CEPH_SNAPDIR) && (name_len > 0) &&\n\t    (iname.name[0] == '_')) {\n\t\tdir = parse_longname(parent, iname.name, &name_len);\n\t\tif (IS_ERR(dir))\n\t\t\treturn PTR_ERR(dir);\n\t\tiname.name++;  \n\t}\n\tiname.len = name_len;\n\n\tif (!fscrypt_has_encryption_key(dir)) {\n\t\tmemcpy(buf, d_name->name, d_name->len);\n\t\telen = d_name->len;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!fscrypt_fname_encrypted_size(dir, iname.len, NAME_MAX, &len)) {\n\t\telen = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\t \n\tcryptbuf = kmalloc(len > CEPH_NOHASH_NAME_MAX ? NAME_MAX : len,\n\t\t\t   GFP_KERNEL);\n\tif (!cryptbuf) {\n\t\telen = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = fscrypt_fname_encrypt(dir, &iname, cryptbuf, len);\n\tif (ret) {\n\t\telen = ret;\n\t\tgoto out;\n\t}\n\n\t \n\tif (len > CEPH_NOHASH_NAME_MAX) {\n\t\tu8 hash[SHA256_DIGEST_SIZE];\n\t\tu8 *extra = cryptbuf + CEPH_NOHASH_NAME_MAX;\n\n\t\t \n\t\tsha256(extra, len - CEPH_NOHASH_NAME_MAX, hash);\n\t\tmemcpy(extra, hash, SHA256_DIGEST_SIZE);\n\t\tlen = CEPH_NOHASH_NAME_MAX + SHA256_DIGEST_SIZE;\n\t}\n\n\t \n\telen = ceph_base64_encode(cryptbuf, len, buf);\n\tdout(\"base64-encoded ciphertext name = %.*s\\n\", elen, buf);\n\n\t \n\tWARN_ON(elen > 240);\n\tif ((elen > 0) && (dir != parent)) {\n\t\tchar tmp_buf[NAME_MAX];\n\n\t\telen = snprintf(tmp_buf, sizeof(tmp_buf), \"_%.*s_%ld\",\n\t\t\t\telen, buf, dir->i_ino);\n\t\tmemcpy(buf, tmp_buf, elen);\n\t}\n\nout:\n\tkfree(cryptbuf);\n\tif (dir != parent) {\n\t\tif ((dir->i_state & I_NEW))\n\t\t\tdiscard_new_inode(dir);\n\t\telse\n\t\t\tiput(dir);\n\t}\n\treturn elen;\n}\n\nint ceph_encode_encrypted_fname(struct inode *parent, struct dentry *dentry,\n\t\t\t\tchar *buf)\n{\n\tWARN_ON_ONCE(!fscrypt_has_encryption_key(parent));\n\n\treturn ceph_encode_encrypted_dname(parent, &dentry->d_name, buf);\n}\n\n \nint ceph_fname_to_usr(const struct ceph_fname *fname, struct fscrypt_str *tname,\n\t\t      struct fscrypt_str *oname, bool *is_nokey)\n{\n\tstruct inode *dir = fname->dir;\n\tstruct fscrypt_str _tname = FSTR_INIT(NULL, 0);\n\tstruct fscrypt_str iname;\n\tchar *name = fname->name;\n\tint name_len = fname->name_len;\n\tint ret;\n\n\t \n\tif (fname->name_len > NAME_MAX || fname->ctext_len > NAME_MAX)\n\t\treturn -EIO;\n\n\t \n\tif ((ceph_snap(dir) == CEPH_SNAPDIR) && (name_len > 0) &&\n\t    (name[0] == '_')) {\n\t\tdir = parse_longname(dir, name, &name_len);\n\t\tif (IS_ERR(dir))\n\t\t\treturn PTR_ERR(dir);\n\t\tname++;  \n\t}\n\n\tif (!IS_ENCRYPTED(dir)) {\n\t\toname->name = fname->name;\n\t\toname->len = fname->name_len;\n\t\tret = 0;\n\t\tgoto out_inode;\n\t}\n\n\tret = ceph_fscrypt_prepare_readdir(dir);\n\tif (ret)\n\t\tgoto out_inode;\n\n\t \n\tif (!fscrypt_has_encryption_key(dir)) {\n\t\tif (fname->no_copy)\n\t\t\toname->name = fname->name;\n\t\telse\n\t\t\tmemcpy(oname->name, fname->name, fname->name_len);\n\t\toname->len = fname->name_len;\n\t\tif (is_nokey)\n\t\t\t*is_nokey = true;\n\t\tret = 0;\n\t\tgoto out_inode;\n\t}\n\n\tif (fname->ctext_len == 0) {\n\t\tint declen;\n\n\t\tif (!tname) {\n\t\t\tret = fscrypt_fname_alloc_buffer(NAME_MAX, &_tname);\n\t\t\tif (ret)\n\t\t\t\tgoto out_inode;\n\t\t\ttname = &_tname;\n\t\t}\n\n\t\tdeclen = ceph_base64_decode(name, name_len, tname->name);\n\t\tif (declen <= 0) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tiname.name = tname->name;\n\t\tiname.len = declen;\n\t} else {\n\t\tiname.name = fname->ctext;\n\t\tiname.len = fname->ctext_len;\n\t}\n\n\tret = fscrypt_fname_disk_to_usr(dir, 0, 0, &iname, oname);\n\tif (!ret && (dir != fname->dir)) {\n\t\tchar tmp_buf[CEPH_BASE64_CHARS(NAME_MAX)];\n\n\t\tname_len = snprintf(tmp_buf, sizeof(tmp_buf), \"_%.*s_%ld\",\n\t\t\t\t    oname->len, oname->name, dir->i_ino);\n\t\tmemcpy(oname->name, tmp_buf, name_len);\n\t\toname->len = name_len;\n\t}\n\nout:\n\tfscrypt_fname_free_buffer(&_tname);\nout_inode:\n\tif (dir != fname->dir) {\n\t\tif ((dir->i_state & I_NEW))\n\t\t\tdiscard_new_inode(dir);\n\t\telse\n\t\t\tiput(dir);\n\t}\n\treturn ret;\n}\n\n \nint ceph_fscrypt_prepare_readdir(struct inode *dir)\n{\n\tbool had_key = fscrypt_has_encryption_key(dir);\n\tint err;\n\n\tif (!IS_ENCRYPTED(dir))\n\t\treturn 0;\n\n\terr = __fscrypt_prepare_readdir(dir);\n\tif (err)\n\t\treturn err;\n\tif (!had_key && fscrypt_has_encryption_key(dir)) {\n\t\t \n\t\tceph_dir_clear_complete(dir);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint ceph_fscrypt_decrypt_block_inplace(const struct inode *inode,\n\t\t\t\t  struct page *page, unsigned int len,\n\t\t\t\t  unsigned int offs, u64 lblk_num)\n{\n\tdout(\"%s: len %u offs %u blk %llu\\n\", __func__, len, offs, lblk_num);\n\treturn fscrypt_decrypt_block_inplace(inode, page, len, offs, lblk_num);\n}\n\nint ceph_fscrypt_encrypt_block_inplace(const struct inode *inode,\n\t\t\t\t  struct page *page, unsigned int len,\n\t\t\t\t  unsigned int offs, u64 lblk_num,\n\t\t\t\t  gfp_t gfp_flags)\n{\n\tdout(\"%s: len %u offs %u blk %llu\\n\", __func__, len, offs, lblk_num);\n\treturn fscrypt_encrypt_block_inplace(inode, page, len, offs, lblk_num,\n\t\t\t\t\t     gfp_flags);\n}\n\n \nint ceph_fscrypt_decrypt_pages(struct inode *inode, struct page **page,\n\t\t\t       u64 off, int len)\n{\n\tint i, num_blocks;\n\tu64 baseblk = off >> CEPH_FSCRYPT_BLOCK_SHIFT;\n\tint ret = 0;\n\n\t \n\tnum_blocks = ceph_fscrypt_blocks(off, len & CEPH_FSCRYPT_BLOCK_MASK);\n\n\t \n\tfor (i = 0; i < num_blocks; ++i) {\n\t\tint blkoff = i << CEPH_FSCRYPT_BLOCK_SHIFT;\n\t\tint pgidx = blkoff >> PAGE_SHIFT;\n\t\tunsigned int pgoffs = offset_in_page(blkoff);\n\t\tint fret;\n\n\t\tfret = ceph_fscrypt_decrypt_block_inplace(inode, page[pgidx],\n\t\t\t\tCEPH_FSCRYPT_BLOCK_SIZE, pgoffs,\n\t\t\t\tbaseblk + i);\n\t\tif (fret < 0) {\n\t\t\tif (ret == 0)\n\t\t\t\tret = fret;\n\t\t\tbreak;\n\t\t}\n\t\tret += CEPH_FSCRYPT_BLOCK_SIZE;\n\t}\n\treturn ret;\n}\n\n \nint ceph_fscrypt_decrypt_extents(struct inode *inode, struct page **page,\n\t\t\t\t u64 off, struct ceph_sparse_extent *map,\n\t\t\t\t u32 ext_cnt)\n{\n\tint i, ret = 0;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 objno, objoff;\n\tu32 xlen;\n\n\t \n\tif (ext_cnt == 0) {\n\t\tdout(\"%s: empty array, ret 0\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tceph_calc_file_object_mapping(&ci->i_layout, off, map[0].len,\n\t\t\t\t      &objno, &objoff, &xlen);\n\n\tfor (i = 0; i < ext_cnt; ++i) {\n\t\tstruct ceph_sparse_extent *ext = &map[i];\n\t\tint pgsoff = ext->off - objoff;\n\t\tint pgidx = pgsoff >> PAGE_SHIFT;\n\t\tint fret;\n\n\t\tif ((ext->off | ext->len) & ~CEPH_FSCRYPT_BLOCK_MASK) {\n\t\t\tpr_warn(\"%s: bad encrypted sparse extent idx %d off %llx len %llx\\n\",\n\t\t\t\t__func__, i, ext->off, ext->len);\n\t\t\treturn -EIO;\n\t\t}\n\t\tfret = ceph_fscrypt_decrypt_pages(inode, &page[pgidx],\n\t\t\t\t\t\t off + pgsoff, ext->len);\n\t\tdout(\"%s: [%d] 0x%llx~0x%llx fret %d\\n\", __func__, i,\n\t\t\t\text->off, ext->len, fret);\n\t\tif (fret < 0) {\n\t\t\tif (ret == 0)\n\t\t\t\tret = fret;\n\t\t\tbreak;\n\t\t}\n\t\tret = pgsoff + fret;\n\t}\n\tdout(\"%s: ret %d\\n\", __func__, ret);\n\treturn ret;\n}\n\n \nint ceph_fscrypt_encrypt_pages(struct inode *inode, struct page **page, u64 off,\n\t\t\t\tint len, gfp_t gfp)\n{\n\tint i, num_blocks;\n\tu64 baseblk = off >> CEPH_FSCRYPT_BLOCK_SHIFT;\n\tint ret = 0;\n\n\t \n\tnum_blocks = ceph_fscrypt_blocks(off, len & CEPH_FSCRYPT_BLOCK_MASK);\n\n\t \n\tfor (i = 0; i < num_blocks; ++i) {\n\t\tint blkoff = i << CEPH_FSCRYPT_BLOCK_SHIFT;\n\t\tint pgidx = blkoff >> PAGE_SHIFT;\n\t\tunsigned int pgoffs = offset_in_page(blkoff);\n\t\tint fret;\n\n\t\tfret = ceph_fscrypt_encrypt_block_inplace(inode, page[pgidx],\n\t\t\t\tCEPH_FSCRYPT_BLOCK_SIZE, pgoffs,\n\t\t\t\tbaseblk + i, gfp);\n\t\tif (fret < 0) {\n\t\t\tif (ret == 0)\n\t\t\t\tret = fret;\n\t\t\tbreak;\n\t\t}\n\t\tret += CEPH_FSCRYPT_BLOCK_SIZE;\n\t}\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}