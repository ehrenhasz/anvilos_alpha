{
  "module_name": "file.c",
  "hash_id": "e368aaf96f4d5582daaa9004db0f0b165ee4e5b03e61e542dea66f86473d1572",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/file.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n#include <linux/ceph/striper.h>\n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/writeback.h>\n#include <linux/falloc.h>\n#include <linux/iversion.h>\n#include <linux/ktime.h>\n\n#include \"super.h\"\n#include \"mds_client.h\"\n#include \"cache.h\"\n#include \"io.h\"\n#include \"metric.h\"\n\nstatic __le32 ceph_flags_sys2wire(u32 flags)\n{\n\tu32 wire_flags = 0;\n\n\tswitch (flags & O_ACCMODE) {\n\tcase O_RDONLY:\n\t\twire_flags |= CEPH_O_RDONLY;\n\t\tbreak;\n\tcase O_WRONLY:\n\t\twire_flags |= CEPH_O_WRONLY;\n\t\tbreak;\n\tcase O_RDWR:\n\t\twire_flags |= CEPH_O_RDWR;\n\t\tbreak;\n\t}\n\n\tflags &= ~O_ACCMODE;\n\n#define ceph_sys2wire(a) if (flags & a) { wire_flags |= CEPH_##a; flags &= ~a; }\n\n\tceph_sys2wire(O_CREAT);\n\tceph_sys2wire(O_EXCL);\n\tceph_sys2wire(O_TRUNC);\n\tceph_sys2wire(O_DIRECTORY);\n\tceph_sys2wire(O_NOFOLLOW);\n\n#undef ceph_sys2wire\n\n\tif (flags)\n\t\tdout(\"unused open flags: %x\\n\", flags);\n\n\treturn cpu_to_le32(wire_flags);\n}\n\n \n\n \n#define ITER_GET_BVECS_PAGES\t64\n\nstatic ssize_t __iter_get_bvecs(struct iov_iter *iter, size_t maxsize,\n\t\t\t\tstruct bio_vec *bvecs)\n{\n\tsize_t size = 0;\n\tint bvec_idx = 0;\n\n\tif (maxsize > iov_iter_count(iter))\n\t\tmaxsize = iov_iter_count(iter);\n\n\twhile (size < maxsize) {\n\t\tstruct page *pages[ITER_GET_BVECS_PAGES];\n\t\tssize_t bytes;\n\t\tsize_t start;\n\t\tint idx = 0;\n\n\t\tbytes = iov_iter_get_pages2(iter, pages, maxsize - size,\n\t\t\t\t\t   ITER_GET_BVECS_PAGES, &start);\n\t\tif (bytes < 0)\n\t\t\treturn size ?: bytes;\n\n\t\tsize += bytes;\n\n\t\tfor ( ; bytes; idx++, bvec_idx++) {\n\t\t\tint len = min_t(int, bytes, PAGE_SIZE - start);\n\n\t\t\tbvec_set_page(&bvecs[bvec_idx], pages[idx], len, start);\n\t\t\tbytes -= len;\n\t\t\tstart = 0;\n\t\t}\n\t}\n\n\treturn size;\n}\n\n \nstatic ssize_t iter_get_bvecs_alloc(struct iov_iter *iter, size_t maxsize,\n\t\t\t\t    struct bio_vec **bvecs, int *num_bvecs)\n{\n\tstruct bio_vec *bv;\n\tsize_t orig_count = iov_iter_count(iter);\n\tssize_t bytes;\n\tint npages;\n\n\tiov_iter_truncate(iter, maxsize);\n\tnpages = iov_iter_npages(iter, INT_MAX);\n\tiov_iter_reexpand(iter, orig_count);\n\n\t \n\tbv = kvmalloc_array(npages, sizeof(*bv), GFP_KERNEL | __GFP_ZERO);\n\tif (!bv)\n\t\treturn -ENOMEM;\n\n\tbytes = __iter_get_bvecs(iter, maxsize, bv);\n\tif (bytes < 0) {\n\t\t \n\t\tkvfree(bv);\n\t\treturn bytes;\n\t}\n\n\t*bvecs = bv;\n\t*num_bvecs = npages;\n\treturn bytes;\n}\n\nstatic void put_bvecs(struct bio_vec *bvecs, int num_bvecs, bool should_dirty)\n{\n\tint i;\n\n\tfor (i = 0; i < num_bvecs; i++) {\n\t\tif (bvecs[i].bv_page) {\n\t\t\tif (should_dirty)\n\t\t\t\tset_page_dirty_lock(bvecs[i].bv_page);\n\t\t\tput_page(bvecs[i].bv_page);\n\t\t}\n\t}\n\tkvfree(bvecs);\n}\n\n \nstatic struct ceph_mds_request *\nprepare_open_request(struct super_block *sb, int flags, int create_mode)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(sb);\n\tstruct ceph_mds_request *req;\n\tint want_auth = USE_ANY_MDS;\n\tint op = (flags & O_CREAT) ? CEPH_MDS_OP_CREATE : CEPH_MDS_OP_OPEN;\n\n\tif (flags & (O_WRONLY|O_RDWR|O_CREAT|O_TRUNC))\n\t\twant_auth = USE_AUTH_MDS;\n\n\treq = ceph_mdsc_create_request(mdsc, op, want_auth);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\treq->r_fmode = ceph_flags_to_mode(flags);\n\treq->r_args.open.flags = ceph_flags_sys2wire(flags);\n\treq->r_args.open.mode = cpu_to_le32(create_mode);\nout:\n\treturn req;\n}\n\nstatic int ceph_init_file_info(struct inode *inode, struct file *file,\n\t\t\t\t\tint fmode, bool isdir)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mount_options *opt =\n\t\tceph_inode_to_client(&ci->netfs.inode)->mount_options;\n\tstruct ceph_file_info *fi;\n\tint ret;\n\n\tdout(\"%s %p %p 0%o (%s)\\n\", __func__, inode, file,\n\t\t\tinode->i_mode, isdir ? \"dir\" : \"regular\");\n\tBUG_ON(inode->i_fop->release != ceph_release);\n\n\tif (isdir) {\n\t\tstruct ceph_dir_file_info *dfi =\n\t\t\tkmem_cache_zalloc(ceph_dir_file_cachep, GFP_KERNEL);\n\t\tif (!dfi)\n\t\t\treturn -ENOMEM;\n\n\t\tfile->private_data = dfi;\n\t\tfi = &dfi->file_info;\n\t\tdfi->next_offset = 2;\n\t\tdfi->readdir_cache_idx = -1;\n\t} else {\n\t\tfi = kmem_cache_zalloc(ceph_file_cachep, GFP_KERNEL);\n\t\tif (!fi)\n\t\t\treturn -ENOMEM;\n\n\t\tif (opt->flags & CEPH_MOUNT_OPT_NOPAGECACHE)\n\t\t\tfi->flags |= CEPH_F_SYNC;\n\n\t\tfile->private_data = fi;\n\t}\n\n\tceph_get_fmode(ci, fmode, 1);\n\tfi->fmode = fmode;\n\n\tspin_lock_init(&fi->rw_contexts_lock);\n\tINIT_LIST_HEAD(&fi->rw_contexts);\n\tfi->filp_gen = READ_ONCE(ceph_inode_to_client(inode)->filp_gen);\n\n\tif ((file->f_mode & FMODE_WRITE) && ceph_has_inline_data(ci)) {\n\t\tret = ceph_uninline_data(file);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tceph_fscache_unuse_cookie(inode, file->f_mode & FMODE_WRITE);\n\tceph_put_fmode(ci, fi->fmode, 1);\n\tkmem_cache_free(ceph_file_cachep, fi);\n\t \n\twake_up_all(&ci->i_cap_wq);\n\treturn ret;\n}\n\n \nstatic int ceph_init_file(struct inode *inode, struct file *file, int fmode)\n{\n\tint ret = 0;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tceph_fscache_use_cookie(inode, file->f_mode & FMODE_WRITE);\n\t\tfallthrough;\n\tcase S_IFDIR:\n\t\tret = ceph_init_file_info(inode, file, fmode,\n\t\t\t\t\t\tS_ISDIR(inode->i_mode));\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\tdout(\"init_file %p %p 0%o (symlink)\\n\", inode, file,\n\t\t     inode->i_mode);\n\t\tbreak;\n\n\tdefault:\n\t\tdout(\"init_file %p %p 0%o (special)\\n\", inode, file,\n\t\t     inode->i_mode);\n\t\t \n\t\tBUG_ON(inode->i_fop->release == ceph_release);\n\n\t\t \n\t\tret = inode->i_fop->open(inode, file);\n\t}\n\treturn ret;\n}\n\n \nint ceph_renew_caps(struct inode *inode, int fmode)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(inode->i_sb);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_request *req;\n\tint err, flags, wanted;\n\n\tspin_lock(&ci->i_ceph_lock);\n\t__ceph_touch_fmode(ci, mdsc, fmode);\n\twanted = __ceph_caps_file_wanted(ci);\n\tif (__ceph_is_any_real_caps(ci) &&\n\t    (!(wanted & CEPH_CAP_ANY_WR) || ci->i_auth_cap)) {\n\t\tint issued = __ceph_caps_issued(ci, NULL);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tdout(\"renew caps %p want %s issued %s updating mds_wanted\\n\",\n\t\t     inode, ceph_cap_string(wanted), ceph_cap_string(issued));\n\t\tceph_check_caps(ci, 0);\n\t\treturn 0;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tflags = 0;\n\tif ((wanted & CEPH_CAP_FILE_RD) && (wanted & CEPH_CAP_FILE_WR))\n\t\tflags = O_RDWR;\n\telse if (wanted & CEPH_CAP_FILE_RD)\n\t\tflags = O_RDONLY;\n\telse if (wanted & CEPH_CAP_FILE_WR)\n\t\tflags = O_WRONLY;\n#ifdef O_LAZY\n\tif (wanted & CEPH_CAP_FILE_LAZYIO)\n\t\tflags |= O_LAZY;\n#endif\n\n\treq = prepare_open_request(inode->i_sb, flags, 0);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tceph_mdsc_put_request(req);\nout:\n\tdout(\"renew caps %p open result=%d\\n\", inode, err);\n\treturn err < 0 ? err : 0;\n}\n\n \nint ceph_open(struct inode *inode, struct file *file)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct ceph_file_info *fi = file->private_data;\n\tint err;\n\tint flags, fmode, wanted;\n\n\tif (fi) {\n\t\tdout(\"open file %p is already opened\\n\", file);\n\t\treturn 0;\n\t}\n\n\t \n\tflags = file->f_flags & ~(O_CREAT|O_EXCL);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tflags = O_DIRECTORY;   \n\t} else if (S_ISREG(inode->i_mode)) {\n\t\terr = fscrypt_file_open(inode, file);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tdout(\"open inode %p ino %llx.%llx file %p flags %d (%d)\\n\", inode,\n\t     ceph_vinop(inode), file, flags, file->f_flags);\n\tfmode = ceph_flags_to_mode(flags);\n\twanted = ceph_caps_for_mode(fmode);\n\n\t \n\tif (ceph_snap(inode) != CEPH_NOSNAP && (file->f_mode & FMODE_WRITE))\n\t\treturn -EROFS;\n\n\t \n\tif (ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\treturn ceph_init_file(inode, file, fmode);\n\t}\n\n\t \n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_is_any_real_caps(ci) &&\n\t    (((fmode & CEPH_FILE_MODE_WR) == 0) || ci->i_auth_cap)) {\n\t\tint mds_wanted = __ceph_caps_mds_wanted(ci, true);\n\t\tint issued = __ceph_caps_issued(ci, NULL);\n\n\t\tdout(\"open %p fmode %d want %s issued %s using existing\\n\",\n\t\t     inode, fmode, ceph_cap_string(wanted),\n\t\t     ceph_cap_string(issued));\n\t\t__ceph_touch_fmode(ci, mdsc, fmode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t \n\t\tif ((issued & wanted) != wanted &&\n\t\t    (mds_wanted & wanted) != wanted &&\n\t\t    ceph_snap(inode) != CEPH_SNAPDIR)\n\t\t\tceph_check_caps(ci, 0);\n\n\t\treturn ceph_init_file(inode, file, fmode);\n\t} else if (ceph_snap(inode) != CEPH_NOSNAP &&\n\t\t   (ci->i_snap_caps & wanted) == wanted) {\n\t\t__ceph_touch_fmode(ci, mdsc, fmode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\treturn ceph_init_file(inode, file, fmode);\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"open fmode %d wants %s\\n\", fmode, ceph_cap_string(wanted));\n\treq = prepare_open_request(inode->i_sb, flags, 0);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\treq->r_inode = inode;\n\tihold(inode);\n\n\treq->r_num_caps = 1;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (!err)\n\t\terr = ceph_init_file(inode, file, req->r_fmode);\n\tceph_mdsc_put_request(req);\n\tdout(\"open result=%d on %llx.%llx\\n\", err, ceph_vinop(inode));\nout:\n\treturn err;\n}\n\n \nstatic void\ncache_file_layout(struct inode *dst, struct inode *src)\n{\n\tstruct ceph_inode_info *cdst = ceph_inode(dst);\n\tstruct ceph_inode_info *csrc = ceph_inode(src);\n\n\tspin_lock(&cdst->i_ceph_lock);\n\tif ((__ceph_caps_issued(cdst, NULL) & CEPH_CAP_DIR_CREATE) &&\n\t    !ceph_file_layout_is_valid(&cdst->i_cached_layout)) {\n\t\tmemcpy(&cdst->i_cached_layout, &csrc->i_layout,\n\t\t\tsizeof(cdst->i_cached_layout));\n\t\trcu_assign_pointer(cdst->i_cached_layout.pool_ns,\n\t\t\t\t   ceph_try_get_string(csrc->i_layout.pool_ns));\n\t}\n\tspin_unlock(&cdst->i_ceph_lock);\n}\n\n \nstatic int try_prep_async_create(struct inode *dir, struct dentry *dentry,\n\t\t\t\t struct ceph_file_layout *lo, u64 *pino)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(dir);\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tint got = 0, want = CEPH_CAP_FILE_EXCL | CEPH_CAP_DIR_CREATE;\n\tu64 ino;\n\n\tspin_lock(&ci->i_ceph_lock);\n\t \n\tif (!ci->i_auth_cap)\n\t\tgoto no_async;\n\n\t \n\tif (xa_empty(&ci->i_auth_cap->session->s_delegated_inos))\n\t\tgoto no_async;\n\n\tif (!ceph_file_layout_is_valid(&ci->i_cached_layout))\n\t\tgoto no_async;\n\n\tif ((__ceph_caps_issued(ci, NULL) & want) != want)\n\t\tgoto no_async;\n\n\tif (d_in_lookup(dentry)) {\n\t\tif (!__ceph_dir_is_complete(ci))\n\t\t\tgoto no_async;\n\t\tspin_lock(&dentry->d_lock);\n\t\tdi->lease_shared_gen = atomic_read(&ci->i_shared_gen);\n\t\tspin_unlock(&dentry->d_lock);\n\t} else if (atomic_read(&ci->i_shared_gen) !=\n\t\t   READ_ONCE(di->lease_shared_gen)) {\n\t\tgoto no_async;\n\t}\n\n\tino = ceph_get_deleg_ino(ci->i_auth_cap->session);\n\tif (!ino)\n\t\tgoto no_async;\n\n\t*pino = ino;\n\tceph_take_cap_refs(ci, want, false);\n\tmemcpy(lo, &ci->i_cached_layout, sizeof(*lo));\n\trcu_assign_pointer(lo->pool_ns,\n\t\t\t   ceph_try_get_string(ci->i_cached_layout.pool_ns));\n\tgot = want;\nno_async:\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn got;\n}\n\nstatic void restore_deleg_ino(struct inode *dir, u64 ino)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(dir);\n\tstruct ceph_mds_session *s = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_auth_cap)\n\t\ts = ceph_get_mds_session(ci->i_auth_cap->session);\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (s) {\n\t\tint err = ceph_restore_deleg_ino(s, ino);\n\t\tif (err)\n\t\t\tpr_warn(\"ceph: unable to restore delegated ino 0x%llx to session: %d\\n\",\n\t\t\t\tino, err);\n\t\tceph_put_mds_session(s);\n\t}\n}\n\nstatic void wake_async_create_waiters(struct inode *inode,\n\t\t\t\t      struct ceph_mds_session *session)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tbool check_cap = false;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_ceph_flags & CEPH_I_ASYNC_CREATE) {\n\t\tci->i_ceph_flags &= ~CEPH_I_ASYNC_CREATE;\n\t\twake_up_bit(&ci->i_ceph_flags, CEPH_ASYNC_CREATE_BIT);\n\n\t\tif (ci->i_ceph_flags & CEPH_I_ASYNC_CHECK_CAPS) {\n\t\t\tci->i_ceph_flags &= ~CEPH_I_ASYNC_CHECK_CAPS;\n\t\t\tcheck_cap = true;\n\t\t}\n\t}\n\tceph_kick_flushing_inode_caps(session, ci);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (check_cap)\n\t\tceph_check_caps(ci, CHECK_CAPS_FLUSH);\n}\n\nstatic void ceph_async_create_cb(struct ceph_mds_client *mdsc,\n                                 struct ceph_mds_request *req)\n{\n\tstruct dentry *dentry = req->r_dentry;\n\tstruct inode *dinode = d_inode(dentry);\n\tstruct inode *tinode = req->r_target_inode;\n\tint result = req->r_err ? req->r_err :\n\t\t\tle32_to_cpu(req->r_reply_info.head->result);\n\n\tWARN_ON_ONCE(dinode && tinode && dinode != tinode);\n\n\t \n\tif (result == -EJUKEBOX)\n\t\tgoto out;\n\n\tmapping_set_error(req->r_parent->i_mapping, result);\n\n\tif (result) {\n\t\tint pathlen = 0;\n\t\tu64 base = 0;\n\t\tchar *path = ceph_mdsc_build_path(req->r_dentry, &pathlen,\n\t\t\t\t\t\t  &base, 0);\n\n\t\tpr_warn(\"async create failure path=(%llx)%s result=%d!\\n\",\n\t\t\tbase, IS_ERR(path) ? \"<<bad>>\" : path, result);\n\t\tceph_mdsc_free_path(path, pathlen);\n\n\t\tceph_dir_clear_complete(req->r_parent);\n\t\tif (!d_unhashed(dentry))\n\t\t\td_drop(dentry);\n\n\t\tif (dinode) {\n\t\t\tmapping_set_error(dinode->i_mapping, result);\n\t\t\tceph_inode_shutdown(dinode);\n\t\t\twake_async_create_waiters(dinode, req->r_session);\n\t\t}\n\t}\n\n\tif (tinode) {\n\t\tu64 ino = ceph_vino(tinode).ino;\n\n\t\tif (req->r_deleg_ino != ino)\n\t\t\tpr_warn(\"%s: inode number mismatch! err=%d deleg_ino=0x%llx target=0x%llx\\n\",\n\t\t\t\t__func__, req->r_err, req->r_deleg_ino, ino);\n\n\t\tmapping_set_error(tinode->i_mapping, result);\n\t\twake_async_create_waiters(tinode, req->r_session);\n\t} else if (!result) {\n\t\tpr_warn(\"%s: no req->r_target_inode for 0x%llx\\n\", __func__,\n\t\t\treq->r_deleg_ino);\n\t}\nout:\n\tceph_mdsc_release_dir_caps(req);\n}\n\nstatic int ceph_finish_async_create(struct inode *dir, struct inode *inode,\n\t\t\t\t    struct dentry *dentry,\n\t\t\t\t    struct file *file, umode_t mode,\n\t\t\t\t    struct ceph_mds_request *req,\n\t\t\t\t    struct ceph_acl_sec_ctx *as_ctx,\n\t\t\t\t    struct ceph_file_layout *lo)\n{\n\tint ret;\n\tchar xattr_buf[4];\n\tstruct ceph_mds_reply_inode in = { };\n\tstruct ceph_mds_reply_info_in iinfo = { .in = &in };\n\tstruct ceph_inode_info *ci = ceph_inode(dir);\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tstruct timespec64 now;\n\tstruct ceph_string *pool_ns;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(dir->i_sb);\n\tstruct ceph_vino vino = { .ino = req->r_deleg_ino,\n\t\t\t\t  .snap = CEPH_NOSNAP };\n\n\tktime_get_real_ts64(&now);\n\n\tiinfo.inline_version = CEPH_INLINE_NONE;\n\tiinfo.change_attr = 1;\n\tceph_encode_timespec64(&iinfo.btime, &now);\n\n\tif (req->r_pagelist) {\n\t\tiinfo.xattr_len = req->r_pagelist->length;\n\t\tiinfo.xattr_data = req->r_pagelist->mapped_tail;\n\t} else {\n\t\t \n\t\tiinfo.xattr_len = ARRAY_SIZE(xattr_buf);\n\t\tiinfo.xattr_data = xattr_buf;\n\t\tmemset(iinfo.xattr_data, 0, iinfo.xattr_len);\n\t}\n\n\tin.ino = cpu_to_le64(vino.ino);\n\tin.snapid = cpu_to_le64(CEPH_NOSNAP);\n\tin.version = cpu_to_le64(1);\t \n\tin.cap.caps = in.cap.wanted = cpu_to_le32(CEPH_CAP_ALL_FILE);\n\tin.cap.cap_id = cpu_to_le64(1);\n\tin.cap.realm = cpu_to_le64(ci->i_snap_realm->ino);\n\tin.cap.flags = CEPH_CAP_FLAG_AUTH;\n\tin.ctime = in.mtime = in.atime = iinfo.btime;\n\tin.truncate_seq = cpu_to_le32(1);\n\tin.truncate_size = cpu_to_le64(-1ULL);\n\tin.xattr_version = cpu_to_le64(1);\n\tin.uid = cpu_to_le32(from_kuid(&init_user_ns, current_fsuid()));\n\tif (dir->i_mode & S_ISGID) {\n\t\tin.gid = cpu_to_le32(from_kgid(&init_user_ns, dir->i_gid));\n\n\t\t \n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else {\n\t\tin.gid = cpu_to_le32(from_kgid(&init_user_ns, current_fsgid()));\n\t}\n\tin.mode = cpu_to_le32((u32)mode);\n\n\tin.nlink = cpu_to_le32(1);\n\tin.max_size = cpu_to_le64(lo->stripe_unit);\n\n\tceph_file_layout_to_legacy(lo, &in.layout);\n\t \n\tpool_ns = rcu_dereference_raw(lo->pool_ns);\n\tif (pool_ns) {\n\t\tiinfo.pool_ns_len = pool_ns->len;\n\t\tiinfo.pool_ns_data = pool_ns->str;\n\t}\n\n\tdown_read(&mdsc->snap_rwsem);\n\tret = ceph_fill_inode(inode, NULL, &iinfo, NULL, req->r_session,\n\t\t\t      req->r_fmode, NULL);\n\tup_read(&mdsc->snap_rwsem);\n\tif (ret) {\n\t\tdout(\"%s failed to fill inode: %d\\n\", __func__, ret);\n\t\tceph_dir_clear_complete(dir);\n\t\tif (!d_unhashed(dentry))\n\t\t\td_drop(dentry);\n\t\tdiscard_new_inode(inode);\n\t} else {\n\t\tstruct dentry *dn;\n\n\t\tdout(\"%s d_adding new inode 0x%llx to 0x%llx/%s\\n\", __func__,\n\t\t\tvino.ino, ceph_ino(dir), dentry->d_name.name);\n\t\tceph_dir_clear_ordered(dir);\n\t\tceph_init_inode_acls(inode, as_ctx);\n\t\tif (inode->i_state & I_NEW) {\n\t\t\t \n\t\t\tceph_inode(inode)->i_ceph_flags = CEPH_I_ASYNC_CREATE;\n\t\t\tunlock_new_inode(inode);\n\t\t}\n\t\tif (d_in_lookup(dentry) || d_really_is_negative(dentry)) {\n\t\t\tif (!d_unhashed(dentry))\n\t\t\t\td_drop(dentry);\n\t\t\tdn = d_splice_alias(inode, dentry);\n\t\t\tWARN_ON_ONCE(dn && dn != dentry);\n\t\t}\n\t\tfile->f_mode |= FMODE_CREATED;\n\t\tret = finish_open(file, dentry, ceph_open);\n\t}\n\n\tspin_lock(&dentry->d_lock);\n\tdi->flags &= ~CEPH_DENTRY_ASYNC_CREATE;\n\twake_up_bit(&di->flags, CEPH_DENTRY_ASYNC_CREATE_BIT);\n\tspin_unlock(&dentry->d_lock);\n\n\treturn ret;\n}\n\n \nint ceph_atomic_open(struct inode *dir, struct dentry *dentry,\n\t\t     struct file *file, unsigned flags, umode_t mode)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(dir->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct inode *new_inode = NULL;\n\tstruct dentry *dn;\n\tstruct ceph_acl_sec_ctx as_ctx = {};\n\tbool try_async = ceph_test_mount_opt(fsc, ASYNC_DIROPS);\n\tint mask;\n\tint err;\n\n\tdout(\"atomic_open %p dentry %p '%pd' %s flags %d mode 0%o\\n\",\n\t     dir, dentry, dentry,\n\t     d_unhashed(dentry) ? \"unhashed\" : \"hashed\", flags, mode);\n\n\tif (dentry->d_name.len > NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\terr = ceph_wait_on_conflict_unlink(dentry);\n\tif (err)\n\t\treturn err;\n\t \n\tflags &= ~O_TRUNC;\n\nretry:\n\tif (flags & O_CREAT) {\n\t\tif (ceph_quota_is_max_files_exceeded(dir))\n\t\t\treturn -EDQUOT;\n\n\t\tnew_inode = ceph_new_inode(dir, dentry, &mode, &as_ctx);\n\t\tif (IS_ERR(new_inode)) {\n\t\t\terr = PTR_ERR(new_inode);\n\t\t\tgoto out_ctx;\n\t\t}\n\t\t \n\t\tif (as_ctx.pagelist &&\n\t\t    !list_is_singular(&as_ctx.pagelist->head))\n\t\t\ttry_async = false;\n\t} else if (!d_in_lookup(dentry)) {\n\t\t \n\t\treturn -ENOENT;\n\t}\n\n\t \n\treq = prepare_open_request(dir->i_sb, flags, mode);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out_ctx;\n\t}\n\treq->r_dentry = dget(dentry);\n\treq->r_num_caps = 2;\n\tmask = CEPH_STAT_CAP_INODE | CEPH_CAP_AUTH_SHARED;\n\tif (ceph_security_xattr_wanted(dir))\n\t\tmask |= CEPH_CAP_XATTR_SHARED;\n\treq->r_args.open.mask = cpu_to_le32(mask);\n\treq->r_parent = dir;\n\tihold(dir);\n\tif (IS_ENCRYPTED(dir)) {\n\t\tset_bit(CEPH_MDS_R_FSCRYPT_FILE, &req->r_req_flags);\n\t\terr = fscrypt_prepare_lookup_partial(dir, dentry);\n\t\tif (err < 0)\n\t\t\tgoto out_req;\n\t}\n\n\tif (flags & O_CREAT) {\n\t\tstruct ceph_file_layout lo;\n\n\t\treq->r_dentry_drop = CEPH_CAP_FILE_SHARED | CEPH_CAP_AUTH_EXCL |\n\t\t\t\t     CEPH_CAP_XATTR_EXCL;\n\t\treq->r_dentry_unless = CEPH_CAP_FILE_EXCL;\n\n\t\tceph_as_ctx_to_req(req, &as_ctx);\n\n\t\tif (try_async && (req->r_dir_caps =\n\t\t\t\t  try_prep_async_create(dir, dentry, &lo,\n\t\t\t\t\t\t\t&req->r_deleg_ino))) {\n\t\t\tstruct ceph_vino vino = { .ino = req->r_deleg_ino,\n\t\t\t\t\t\t  .snap = CEPH_NOSNAP };\n\t\t\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\n\t\t\tset_bit(CEPH_MDS_R_ASYNC, &req->r_req_flags);\n\t\t\treq->r_args.open.flags |= cpu_to_le32(CEPH_O_EXCL);\n\t\t\treq->r_callback = ceph_async_create_cb;\n\n\t\t\t \n\t\t\tnew_inode = ceph_get_inode(dir->i_sb, vino, new_inode);\n\t\t\tif (IS_ERR(new_inode)) {\n\t\t\t\terr = PTR_ERR(new_inode);\n\t\t\t\tnew_inode = NULL;\n\t\t\t\tgoto out_req;\n\t\t\t}\n\t\t\tWARN_ON_ONCE(!(new_inode->i_state & I_NEW));\n\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tdi->flags |= CEPH_DENTRY_ASYNC_CREATE;\n\t\t\tspin_unlock(&dentry->d_lock);\n\n\t\t\terr = ceph_mdsc_submit_request(mdsc, dir, req);\n\t\t\tif (!err) {\n\t\t\t\terr = ceph_finish_async_create(dir, new_inode,\n\t\t\t\t\t\t\t       dentry, file,\n\t\t\t\t\t\t\t       mode, req,\n\t\t\t\t\t\t\t       &as_ctx, &lo);\n\t\t\t\tnew_inode = NULL;\n\t\t\t} else if (err == -EJUKEBOX) {\n\t\t\t\trestore_deleg_ino(dir, req->r_deleg_ino);\n\t\t\t\tceph_mdsc_put_request(req);\n\t\t\t\tdiscard_new_inode(new_inode);\n\t\t\t\tceph_release_acl_sec_ctx(&as_ctx);\n\t\t\t\tmemset(&as_ctx, 0, sizeof(as_ctx));\n\t\t\t\tnew_inode = NULL;\n\t\t\t\ttry_async = false;\n\t\t\t\tceph_put_string(rcu_dereference_raw(lo.pool_ns));\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tceph_put_string(rcu_dereference_raw(lo.pool_ns));\n\t\t\tgoto out_req;\n\t\t}\n\t}\n\n\tset_bit(CEPH_MDS_R_PARENT_LOCKED, &req->r_req_flags);\n\treq->r_new_inode = new_inode;\n\tnew_inode = NULL;\n\terr = ceph_mdsc_do_request(mdsc, (flags & O_CREAT) ? dir : NULL, req);\n\tif (err == -ENOENT) {\n\t\tdentry = ceph_handle_snapdir(req, dentry);\n\t\tif (IS_ERR(dentry)) {\n\t\t\terr = PTR_ERR(dentry);\n\t\t\tgoto out_req;\n\t\t}\n\t\terr = 0;\n\t}\n\n\tif (!err && (flags & O_CREAT) && !req->r_reply_info.head->is_dentry)\n\t\terr = ceph_handle_notrace_create(dir, dentry);\n\n\tif (d_in_lookup(dentry)) {\n\t\tdn = ceph_finish_lookup(req, dentry, err);\n\t\tif (IS_ERR(dn))\n\t\t\terr = PTR_ERR(dn);\n\t} else {\n\t\t \n\t\tdn = NULL;\n\t}\n\tif (err)\n\t\tgoto out_req;\n\tif (dn || d_really_is_negative(dentry) || d_is_symlink(dentry)) {\n\t\t \n\t\tdout(\"atomic_open finish_no_open on dn %p\\n\", dn);\n\t\terr = finish_no_open(file, dn);\n\t} else {\n\t\tif (IS_ENCRYPTED(dir) &&\n\t\t    !fscrypt_has_permitted_context(dir, d_inode(dentry))) {\n\t\t\tpr_warn(\"Inconsistent encryption context (parent %llx:%llx child %llx:%llx)\\n\",\n\t\t\t\tceph_vinop(dir), ceph_vinop(d_inode(dentry)));\n\t\t\tgoto out_req;\n\t\t}\n\n\t\tdout(\"atomic_open finish_open on dn %p\\n\", dn);\n\t\tif (req->r_op == CEPH_MDS_OP_CREATE && req->r_reply_info.has_create_ino) {\n\t\t\tstruct inode *newino = d_inode(dentry);\n\n\t\t\tcache_file_layout(dir, newino);\n\t\t\tceph_init_inode_acls(newino, &as_ctx);\n\t\t\tfile->f_mode |= FMODE_CREATED;\n\t\t}\n\t\terr = finish_open(file, dentry, ceph_open);\n\t}\nout_req:\n\tceph_mdsc_put_request(req);\n\tiput(new_inode);\nout_ctx:\n\tceph_release_acl_sec_ctx(&as_ctx);\n\tdout(\"atomic_open result=%d\\n\", err);\n\treturn err;\n}\n\nint ceph_release(struct inode *inode, struct file *file)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct ceph_dir_file_info *dfi = file->private_data;\n\t\tdout(\"release inode %p dir file %p\\n\", inode, file);\n\t\tWARN_ON(!list_empty(&dfi->file_info.rw_contexts));\n\n\t\tceph_put_fmode(ci, dfi->file_info.fmode, 1);\n\n\t\tif (dfi->last_readdir)\n\t\t\tceph_mdsc_put_request(dfi->last_readdir);\n\t\tkfree(dfi->last_name);\n\t\tkfree(dfi->dir_info);\n\t\tkmem_cache_free(ceph_dir_file_cachep, dfi);\n\t} else {\n\t\tstruct ceph_file_info *fi = file->private_data;\n\t\tdout(\"release inode %p regular file %p\\n\", inode, file);\n\t\tWARN_ON(!list_empty(&fi->rw_contexts));\n\n\t\tceph_fscache_unuse_cookie(inode, file->f_mode & FMODE_WRITE);\n\t\tceph_put_fmode(ci, fi->fmode, 1);\n\n\t\tkmem_cache_free(ceph_file_cachep, fi);\n\t}\n\n\t \n\twake_up_all(&ci->i_cap_wq);\n\treturn 0;\n}\n\nenum {\n\tHAVE_RETRIED = 1,\n\tCHECK_EOF =    2,\n\tREAD_INLINE =  3,\n};\n\n \nssize_t __ceph_sync_read(struct inode *inode, loff_t *ki_pos,\n\t\t\t struct iov_iter *to, int *retry_op,\n\t\t\t u64 *last_objver)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_osd_client *osdc = &fsc->client->osdc;\n\tssize_t ret;\n\tu64 off = *ki_pos;\n\tu64 len = iov_iter_count(to);\n\tu64 i_size = i_size_read(inode);\n\tbool sparse = IS_ENCRYPTED(inode) || ceph_test_mount_opt(fsc, SPARSEREAD);\n\tu64 objver = 0;\n\n\tdout(\"sync_read on inode %p %llx~%llx\\n\", inode, *ki_pos, len);\n\n\tif (ceph_inode_is_shutdown(inode))\n\t\treturn -EIO;\n\n\tif (!len)\n\t\treturn 0;\n\t \n\tret = filemap_write_and_wait_range(inode->i_mapping,\n\t\t\t\t\t   off, off + len - 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = 0;\n\twhile ((len = iov_iter_count(to)) > 0) {\n\t\tstruct ceph_osd_request *req;\n\t\tstruct page **pages;\n\t\tint num_pages;\n\t\tsize_t page_off;\n\t\tbool more;\n\t\tint idx;\n\t\tsize_t left;\n\t\tstruct ceph_osd_req_op *op;\n\t\tu64 read_off = off;\n\t\tu64 read_len = len;\n\n\t\t \n\t\tceph_fscrypt_adjust_off_and_len(inode, &read_off, &read_len);\n\n\t\tdout(\"sync_read orig %llu~%llu reading %llu~%llu\",\n\t\t     off, len, read_off, read_len);\n\n\t\treq = ceph_osdc_new_request(osdc, &ci->i_layout,\n\t\t\t\t\tci->i_vino, read_off, &read_len, 0, 1,\n\t\t\t\t\tsparse ? CEPH_OSD_OP_SPARSE_READ :\n\t\t\t\t\t\t CEPH_OSD_OP_READ,\n\t\t\t\t\tCEPH_OSD_FLAG_READ,\n\t\t\t\t\tNULL, ci->i_truncate_seq,\n\t\t\t\t\tci->i_truncate_size, false);\n\t\tif (IS_ERR(req)) {\n\t\t\tret = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (off + len > read_off + read_len)\n\t\t\tlen = read_off + read_len - off;\n\t\tmore = len < iov_iter_count(to);\n\n\t\tnum_pages = calc_pages_for(read_off, read_len);\n\t\tpage_off = offset_in_page(off);\n\t\tpages = ceph_alloc_page_vector(num_pages, GFP_KERNEL);\n\t\tif (IS_ERR(pages)) {\n\t\t\tceph_osdc_put_request(req);\n\t\t\tret = PTR_ERR(pages);\n\t\t\tbreak;\n\t\t}\n\n\t\tosd_req_op_extent_osd_data_pages(req, 0, pages, read_len,\n\t\t\t\t\t\t offset_in_page(read_off),\n\t\t\t\t\t\t false, false);\n\n\t\top = &req->r_ops[0];\n\t\tif (sparse) {\n\t\t\tret = ceph_alloc_sparse_ext_map(op);\n\t\t\tif (ret) {\n\t\t\t\tceph_osdc_put_request(req);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tceph_osdc_start_request(osdc, req);\n\t\tret = ceph_osdc_wait_request(osdc, req);\n\n\t\tceph_update_read_metrics(&fsc->mdsc->metric,\n\t\t\t\t\t req->r_start_latency,\n\t\t\t\t\t req->r_end_latency,\n\t\t\t\t\t read_len, ret);\n\n\t\tif (ret > 0)\n\t\t\tobjver = req->r_version;\n\n\t\ti_size = i_size_read(inode);\n\t\tdout(\"sync_read %llu~%llu got %zd i_size %llu%s\\n\",\n\t\t     off, len, ret, i_size, (more ? \" MORE\" : \"\"));\n\n\t\t \n\t\tif (sparse && ret >= 0)\n\t\t\tret = ceph_sparse_ext_map_end(op);\n\t\telse if (ret == -ENOENT)\n\t\t\tret = 0;\n\n\t\tif (ret > 0 && IS_ENCRYPTED(inode)) {\n\t\t\tint fret;\n\n\t\t\tfret = ceph_fscrypt_decrypt_extents(inode, pages,\n\t\t\t\t\tread_off, op->extent.sparse_ext,\n\t\t\t\t\top->extent.sparse_ext_cnt);\n\t\t\tif (fret < 0) {\n\t\t\t\tret = fret;\n\t\t\t\tceph_osdc_put_request(req);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tfret -= (off - read_off);\n\n\t\t\t \n\t\t\tfret = max(fret, 0);\n\n\t\t\t \n\t\t\tret = min_t(ssize_t, fret, len);\n\t\t}\n\n\t\tceph_osdc_put_request(req);\n\n\t\t \n\t\tif (ret >= 0 && ret < len && (off + ret < i_size)) {\n\t\t\tint zlen = min(len - ret, i_size - off - ret);\n\t\t\tint zoff = page_off + ret;\n\n\t\t\tdout(\"sync_read zero gap %llu~%llu\\n\",\n\t\t\t\toff + ret, off + ret + zlen);\n\t\t\tceph_zero_page_vector_range(zoff, zlen, pages);\n\t\t\tret += zlen;\n\t\t}\n\n\t\tidx = 0;\n\t\tleft = ret > 0 ? ret : 0;\n\t\twhile (left > 0) {\n\t\t\tsize_t plen, copied;\n\n\t\t\tplen = min_t(size_t, left, PAGE_SIZE - page_off);\n\t\t\tSetPageUptodate(pages[idx]);\n\t\t\tcopied = copy_page_to_iter(pages[idx++],\n\t\t\t\t\t\t   page_off, plen, to);\n\t\t\toff += copied;\n\t\t\tleft -= copied;\n\t\t\tpage_off = 0;\n\t\t\tif (copied < plen) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tceph_release_page_vector(pages, num_pages);\n\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EBLOCKLISTED)\n\t\t\t\tfsc->blocklisted = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (off >= i_size || !more)\n\t\t\tbreak;\n\t}\n\n\tif (ret > 0) {\n\t\tif (off > *ki_pos) {\n\t\t\tif (off >= i_size) {\n\t\t\t\t*retry_op = CHECK_EOF;\n\t\t\t\tret = i_size - *ki_pos;\n\t\t\t\t*ki_pos = i_size;\n\t\t\t} else {\n\t\t\t\tret = off - *ki_pos;\n\t\t\t\t*ki_pos = off;\n\t\t\t}\n\t\t}\n\n\t\tif (last_objver)\n\t\t\t*last_objver = objver;\n\t}\n\tdout(\"sync_read result %zd retry_op %d\\n\", ret, *retry_op);\n\treturn ret;\n}\n\nstatic ssize_t ceph_sync_read(struct kiocb *iocb, struct iov_iter *to,\n\t\t\t      int *retry_op)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\n\tdout(\"sync_read on file %p %llx~%zx %s\\n\", file, iocb->ki_pos,\n\t     iov_iter_count(to), (file->f_flags & O_DIRECT) ? \"O_DIRECT\" : \"\");\n\n\treturn __ceph_sync_read(inode, &iocb->ki_pos, to, retry_op, NULL);\n}\n\nstruct ceph_aio_request {\n\tstruct kiocb *iocb;\n\tsize_t total_len;\n\tbool write;\n\tbool should_dirty;\n\tint error;\n\tstruct list_head osd_reqs;\n\tunsigned num_reqs;\n\tatomic_t pending_reqs;\n\tstruct timespec64 mtime;\n\tstruct ceph_cap_flush *prealloc_cf;\n};\n\nstruct ceph_aio_work {\n\tstruct work_struct work;\n\tstruct ceph_osd_request *req;\n};\n\nstatic void ceph_aio_retry_work(struct work_struct *work);\n\nstatic void ceph_aio_complete(struct inode *inode,\n\t\t\t      struct ceph_aio_request *aio_req)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tif (!atomic_dec_and_test(&aio_req->pending_reqs))\n\t\treturn;\n\n\tif (aio_req->iocb->ki_flags & IOCB_DIRECT)\n\t\tinode_dio_end(inode);\n\n\tret = aio_req->error;\n\tif (!ret)\n\t\tret = aio_req->total_len;\n\n\tdout(\"ceph_aio_complete %p rc %d\\n\", inode, ret);\n\n\tif (ret >= 0 && aio_req->write) {\n\t\tint dirty;\n\n\t\tloff_t endoff = aio_req->iocb->ki_pos + aio_req->total_len;\n\t\tif (endoff > i_size_read(inode)) {\n\t\t\tif (ceph_inode_set_size(inode, endoff))\n\t\t\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY);\n\t\t}\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_FILE_WR,\n\t\t\t\t\t       &aio_req->prealloc_cf);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tif (dirty)\n\t\t\t__mark_inode_dirty(inode, dirty);\n\n\t}\n\n\tceph_put_cap_refs(ci, (aio_req->write ? CEPH_CAP_FILE_WR :\n\t\t\t\t\t\tCEPH_CAP_FILE_RD));\n\n\taio_req->iocb->ki_complete(aio_req->iocb, ret);\n\n\tceph_free_cap_flush(aio_req->prealloc_cf);\n\tkfree(aio_req);\n}\n\nstatic void ceph_aio_complete_req(struct ceph_osd_request *req)\n{\n\tint rc = req->r_result;\n\tstruct inode *inode = req->r_inode;\n\tstruct ceph_aio_request *aio_req = req->r_priv;\n\tstruct ceph_osd_data *osd_data = osd_req_op_extent_osd_data(req, 0);\n\tstruct ceph_osd_req_op *op = &req->r_ops[0];\n\tstruct ceph_client_metric *metric = &ceph_sb_to_mdsc(inode->i_sb)->metric;\n\tunsigned int len = osd_data->bvec_pos.iter.bi_size;\n\tbool sparse = (op->op == CEPH_OSD_OP_SPARSE_READ);\n\n\tBUG_ON(osd_data->type != CEPH_OSD_DATA_TYPE_BVECS);\n\tBUG_ON(!osd_data->num_bvecs);\n\n\tdout(\"ceph_aio_complete_req %p rc %d bytes %u\\n\", inode, rc, len);\n\n\tif (rc == -EOLDSNAPC) {\n\t\tstruct ceph_aio_work *aio_work;\n\t\tBUG_ON(!aio_req->write);\n\n\t\taio_work = kmalloc(sizeof(*aio_work), GFP_NOFS);\n\t\tif (aio_work) {\n\t\t\tINIT_WORK(&aio_work->work, ceph_aio_retry_work);\n\t\t\taio_work->req = req;\n\t\t\tqueue_work(ceph_inode_to_client(inode)->inode_wq,\n\t\t\t\t   &aio_work->work);\n\t\t\treturn;\n\t\t}\n\t\trc = -ENOMEM;\n\t} else if (!aio_req->write) {\n\t\tif (sparse && rc >= 0)\n\t\t\trc = ceph_sparse_ext_map_end(op);\n\t\tif (rc == -ENOENT)\n\t\t\trc = 0;\n\t\tif (rc >= 0 && len > rc) {\n\t\t\tstruct iov_iter i;\n\t\t\tint zlen = len - rc;\n\n\t\t\t \n\t\t\tif (aio_req->num_reqs == 1) {\n\t\t\t\tloff_t i_size = i_size_read(inode);\n\t\t\t\tloff_t endoff = aio_req->iocb->ki_pos + rc;\n\t\t\t\tif (endoff < i_size)\n\t\t\t\t\tzlen = min_t(size_t, zlen,\n\t\t\t\t\t\t     i_size - endoff);\n\t\t\t\taio_req->total_len = rc + zlen;\n\t\t\t}\n\n\t\t\tiov_iter_bvec(&i, ITER_DEST, osd_data->bvec_pos.bvecs,\n\t\t\t\t      osd_data->num_bvecs, len);\n\t\t\tiov_iter_advance(&i, rc);\n\t\t\tiov_iter_zero(zlen, &i);\n\t\t}\n\t}\n\n\t \n\tif (req->r_start_latency) {\n\t\tif (aio_req->write)\n\t\t\tceph_update_write_metrics(metric, req->r_start_latency,\n\t\t\t\t\t\t  req->r_end_latency, len, rc);\n\t\telse\n\t\t\tceph_update_read_metrics(metric, req->r_start_latency,\n\t\t\t\t\t\t req->r_end_latency, len, rc);\n\t}\n\n\tput_bvecs(osd_data->bvec_pos.bvecs, osd_data->num_bvecs,\n\t\t  aio_req->should_dirty);\n\tceph_osdc_put_request(req);\n\n\tif (rc < 0)\n\t\tcmpxchg(&aio_req->error, 0, rc);\n\n\tceph_aio_complete(inode, aio_req);\n\treturn;\n}\n\nstatic void ceph_aio_retry_work(struct work_struct *work)\n{\n\tstruct ceph_aio_work *aio_work =\n\t\tcontainer_of(work, struct ceph_aio_work, work);\n\tstruct ceph_osd_request *orig_req = aio_work->req;\n\tstruct ceph_aio_request *aio_req = orig_req->r_priv;\n\tstruct inode *inode = orig_req->r_inode;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_snap_context *snapc;\n\tstruct ceph_osd_request *req;\n\tint ret;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_have_pending_cap_snap(ci)) {\n\t\tstruct ceph_cap_snap *capsnap =\n\t\t\tlist_last_entry(&ci->i_cap_snaps,\n\t\t\t\t\tstruct ceph_cap_snap,\n\t\t\t\t\tci_item);\n\t\tsnapc = ceph_get_snap_context(capsnap->context);\n\t} else {\n\t\tBUG_ON(!ci->i_head_snapc);\n\t\tsnapc = ceph_get_snap_context(ci->i_head_snapc);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\treq = ceph_osdc_alloc_request(orig_req->r_osdc, snapc, 1,\n\t\t\tfalse, GFP_NOFS);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\treq = orig_req;\n\t\tgoto out;\n\t}\n\n\treq->r_flags =   CEPH_OSD_FLAG_WRITE;\n\tceph_oloc_copy(&req->r_base_oloc, &orig_req->r_base_oloc);\n\tceph_oid_copy(&req->r_base_oid, &orig_req->r_base_oid);\n\n\treq->r_ops[0] = orig_req->r_ops[0];\n\n\treq->r_mtime = aio_req->mtime;\n\treq->r_data_offset = req->r_ops[0].extent.offset;\n\n\tret = ceph_osdc_alloc_messages(req, GFP_NOFS);\n\tif (ret) {\n\t\tceph_osdc_put_request(req);\n\t\treq = orig_req;\n\t\tgoto out;\n\t}\n\n\tceph_osdc_put_request(orig_req);\n\n\treq->r_callback = ceph_aio_complete_req;\n\treq->r_inode = inode;\n\treq->r_priv = aio_req;\n\n\tceph_osdc_start_request(req->r_osdc, req);\nout:\n\tif (ret < 0) {\n\t\treq->r_result = ret;\n\t\tceph_aio_complete_req(req);\n\t}\n\n\tceph_put_snap_context(snapc);\n\tkfree(aio_work);\n}\n\nstatic ssize_t\nceph_direct_read_write(struct kiocb *iocb, struct iov_iter *iter,\n\t\t       struct ceph_snap_context *snapc,\n\t\t       struct ceph_cap_flush **pcf)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_client_metric *metric = &fsc->mdsc->metric;\n\tstruct ceph_vino vino;\n\tstruct ceph_osd_request *req;\n\tstruct bio_vec *bvecs;\n\tstruct ceph_aio_request *aio_req = NULL;\n\tint num_pages = 0;\n\tint flags;\n\tint ret = 0;\n\tstruct timespec64 mtime = current_time(inode);\n\tsize_t count = iov_iter_count(iter);\n\tloff_t pos = iocb->ki_pos;\n\tbool write = iov_iter_rw(iter) == WRITE;\n\tbool should_dirty = !write && user_backed_iter(iter);\n\tbool sparse = ceph_test_mount_opt(fsc, SPARSEREAD);\n\n\tif (write && ceph_snap(file_inode(file)) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tdout(\"sync_direct_%s on file %p %lld~%u snapc %p seq %lld\\n\",\n\t     (write ? \"write\" : \"read\"), file, pos, (unsigned)count,\n\t     snapc, snapc ? snapc->seq : 0);\n\n\tif (write) {\n\t\tint ret2;\n\n\t\tceph_fscache_invalidate(inode, true);\n\n\t\tret2 = invalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\tpos >> PAGE_SHIFT,\n\t\t\t\t\t(pos + count - 1) >> PAGE_SHIFT);\n\t\tif (ret2 < 0)\n\t\t\tdout(\"invalidate_inode_pages2_range returned %d\\n\", ret2);\n\n\t\tflags =   CEPH_OSD_FLAG_WRITE;\n\t} else {\n\t\tflags = CEPH_OSD_FLAG_READ;\n\t}\n\n\twhile (iov_iter_count(iter) > 0) {\n\t\tu64 size = iov_iter_count(iter);\n\t\tssize_t len;\n\t\tstruct ceph_osd_req_op *op;\n\t\tint readop = sparse ? CEPH_OSD_OP_SPARSE_READ : CEPH_OSD_OP_READ;\n\n\t\tif (write)\n\t\t\tsize = min_t(u64, size, fsc->mount_options->wsize);\n\t\telse\n\t\t\tsize = min_t(u64, size, fsc->mount_options->rsize);\n\n\t\tvino = ceph_vino(inode);\n\t\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t\t    vino, pos, &size, 0,\n\t\t\t\t\t    1,\n\t\t\t\t\t    write ? CEPH_OSD_OP_WRITE : readop,\n\t\t\t\t\t    flags, snapc,\n\t\t\t\t\t    ci->i_truncate_seq,\n\t\t\t\t\t    ci->i_truncate_size,\n\t\t\t\t\t    false);\n\t\tif (IS_ERR(req)) {\n\t\t\tret = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tlen = iter_get_bvecs_alloc(iter, size, &bvecs, &num_pages);\n\t\tif (len < 0) {\n\t\t\tceph_osdc_put_request(req);\n\t\t\tret = len;\n\t\t\tbreak;\n\t\t}\n\t\tif (len != size)\n\t\t\tosd_req_op_extent_update(req, 0, len);\n\n\t\t \n\t\tif (pos == iocb->ki_pos && !is_sync_kiocb(iocb) &&\n\t\t    (len == count || pos + count <= i_size_read(inode))) {\n\t\t\taio_req = kzalloc(sizeof(*aio_req), GFP_KERNEL);\n\t\t\tif (aio_req) {\n\t\t\t\taio_req->iocb = iocb;\n\t\t\t\taio_req->write = write;\n\t\t\t\taio_req->should_dirty = should_dirty;\n\t\t\t\tINIT_LIST_HEAD(&aio_req->osd_reqs);\n\t\t\t\tif (write) {\n\t\t\t\t\taio_req->mtime = mtime;\n\t\t\t\t\tswap(aio_req->prealloc_cf, *pcf);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t}\n\n\t\tif (write) {\n\t\t\t \n\t\t\ttruncate_inode_pages_range(inode->i_mapping, pos,\n\t\t\t\t\t\t   PAGE_ALIGN(pos + len) - 1);\n\n\t\t\treq->r_mtime = mtime;\n\t\t}\n\n\t\tosd_req_op_extent_osd_data_bvecs(req, 0, bvecs, num_pages, len);\n\t\top = &req->r_ops[0];\n\t\tif (sparse) {\n\t\t\tret = ceph_alloc_sparse_ext_map(op);\n\t\t\tif (ret) {\n\t\t\t\tceph_osdc_put_request(req);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (aio_req) {\n\t\t\taio_req->total_len += len;\n\t\t\taio_req->num_reqs++;\n\t\t\tatomic_inc(&aio_req->pending_reqs);\n\n\t\t\treq->r_callback = ceph_aio_complete_req;\n\t\t\treq->r_inode = inode;\n\t\t\treq->r_priv = aio_req;\n\t\t\tlist_add_tail(&req->r_private_item, &aio_req->osd_reqs);\n\n\t\t\tpos += len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tceph_osdc_start_request(req->r_osdc, req);\n\t\tret = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\n\t\tif (write)\n\t\t\tceph_update_write_metrics(metric, req->r_start_latency,\n\t\t\t\t\t\t  req->r_end_latency, len, ret);\n\t\telse\n\t\t\tceph_update_read_metrics(metric, req->r_start_latency,\n\t\t\t\t\t\t req->r_end_latency, len, ret);\n\n\t\tsize = i_size_read(inode);\n\t\tif (!write) {\n\t\t\tif (sparse && ret >= 0)\n\t\t\t\tret = ceph_sparse_ext_map_end(op);\n\t\t\telse if (ret == -ENOENT)\n\t\t\t\tret = 0;\n\n\t\t\tif (ret >= 0 && ret < len && pos + ret < size) {\n\t\t\t\tstruct iov_iter i;\n\t\t\t\tint zlen = min_t(size_t, len - ret,\n\t\t\t\t\t\t size - pos - ret);\n\n\t\t\t\tiov_iter_bvec(&i, ITER_DEST, bvecs, num_pages, len);\n\t\t\t\tiov_iter_advance(&i, ret);\n\t\t\t\tiov_iter_zero(zlen, &i);\n\t\t\t\tret += zlen;\n\t\t\t}\n\t\t\tif (ret >= 0)\n\t\t\t\tlen = ret;\n\t\t}\n\n\t\tput_bvecs(bvecs, num_pages, should_dirty);\n\t\tceph_osdc_put_request(req);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tpos += len;\n\t\tif (!write && pos >= size)\n\t\t\tbreak;\n\n\t\tif (write && pos > size) {\n\t\t\tif (ceph_inode_set_size(inode, pos))\n\t\t\t\tceph_check_caps(ceph_inode(inode),\n\t\t\t\t\t\tCHECK_CAPS_AUTHONLY);\n\t\t}\n\t}\n\n\tif (aio_req) {\n\t\tLIST_HEAD(osd_reqs);\n\n\t\tif (aio_req->num_reqs == 0) {\n\t\t\tkfree(aio_req);\n\t\t\treturn ret;\n\t\t}\n\n\t\tceph_get_cap_refs(ci, write ? CEPH_CAP_FILE_WR :\n\t\t\t\t\t      CEPH_CAP_FILE_RD);\n\n\t\tlist_splice(&aio_req->osd_reqs, &osd_reqs);\n\t\tinode_dio_begin(inode);\n\t\twhile (!list_empty(&osd_reqs)) {\n\t\t\treq = list_first_entry(&osd_reqs,\n\t\t\t\t\t       struct ceph_osd_request,\n\t\t\t\t\t       r_private_item);\n\t\t\tlist_del_init(&req->r_private_item);\n\t\t\tif (ret >= 0)\n\t\t\t\tceph_osdc_start_request(req->r_osdc, req);\n\t\t\tif (ret < 0) {\n\t\t\t\treq->r_result = ret;\n\t\t\t\tceph_aio_complete_req(req);\n\t\t\t}\n\t\t}\n\t\treturn -EIOCBQUEUED;\n\t}\n\n\tif (ret != -EOLDSNAPC && pos > iocb->ki_pos) {\n\t\tret = pos - iocb->ki_pos;\n\t\tiocb->ki_pos = pos;\n\t}\n\treturn ret;\n}\n\n \nstatic ssize_t\nceph_sync_write(struct kiocb *iocb, struct iov_iter *from, loff_t pos,\n\t\tstruct ceph_snap_context *snapc)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_osd_client *osdc = &fsc->client->osdc;\n\tstruct ceph_osd_request *req;\n\tstruct page **pages;\n\tu64 len;\n\tint num_pages;\n\tint written = 0;\n\tint ret;\n\tbool check_caps = false;\n\tstruct timespec64 mtime = current_time(inode);\n\tsize_t count = iov_iter_count(from);\n\n\tif (ceph_snap(file_inode(file)) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tdout(\"sync_write on file %p %lld~%u snapc %p seq %lld\\n\",\n\t     file, pos, (unsigned)count, snapc, snapc->seq);\n\n\tret = filemap_write_and_wait_range(inode->i_mapping,\n\t\t\t\t\t   pos, pos + count - 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tceph_fscache_invalidate(inode, false);\n\n\twhile ((len = iov_iter_count(from)) > 0) {\n\t\tsize_t left;\n\t\tint n;\n\t\tu64 write_pos = pos;\n\t\tu64 write_len = len;\n\t\tu64 objnum, objoff;\n\t\tu32 xlen;\n\t\tu64 assert_ver = 0;\n\t\tbool rmw;\n\t\tbool first, last;\n\t\tstruct iov_iter saved_iter = *from;\n\t\tsize_t off;\n\n\t\tceph_fscrypt_adjust_off_and_len(inode, &write_pos, &write_len);\n\n\t\t \n\t\tceph_calc_file_object_mapping(&ci->i_layout, write_pos,\n\t\t\t\t\t      write_len, &objnum, &objoff,\n\t\t\t\t\t      &xlen);\n\t\twrite_len = xlen;\n\n\t\t \n\t\tif (pos + len > write_pos + write_len)\n\t\t\tlen = write_pos + write_len - pos;\n\n\t\t \n\t\tfirst = pos != write_pos;\n\t\tlast = (pos + len) != (write_pos + write_len);\n\t\trmw = first || last;\n\n\t\tdout(\"sync_write ino %llx %lld~%llu adjusted %lld~%llu -- %srmw\\n\",\n\t\t     ci->i_vino.ino, pos, len, write_pos, write_len,\n\t\t     rmw ? \"\" : \"no \");\n\n\t\t \n\t\tnum_pages = calc_pages_for(write_pos, write_len);\n\t\tpages = ceph_alloc_page_vector(num_pages, GFP_KERNEL);\n\t\tif (IS_ERR(pages)) {\n\t\t\tret = PTR_ERR(pages);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (rmw) {\n\t\t\tu64 first_pos = write_pos;\n\t\t\tu64 last_pos = (write_pos + write_len) - CEPH_FSCRYPT_BLOCK_SIZE;\n\t\t\tu64 read_len = CEPH_FSCRYPT_BLOCK_SIZE;\n\t\t\tstruct ceph_osd_req_op *op;\n\n\t\t\t \n\t\t\tWARN_ON_ONCE(!IS_ENCRYPTED(inode));\n\n\t\t\t \n\t\t\tif (first && last_pos == first_pos)\n\t\t\t\tlast = false;\n\n\t\t\t \n\t\t\treq = ceph_osdc_new_request(osdc, &ci->i_layout,\n\t\t\t\t\tci->i_vino, first ? first_pos : last_pos,\n\t\t\t\t\t&read_len, 0, (first && last) ? 2 : 1,\n\t\t\t\t\tCEPH_OSD_OP_SPARSE_READ, CEPH_OSD_FLAG_READ,\n\t\t\t\t\tNULL, ci->i_truncate_seq,\n\t\t\t\t\tci->i_truncate_size, false);\n\t\t\tif (IS_ERR(req)) {\n\t\t\t\tceph_release_page_vector(pages, num_pages);\n\t\t\t\tret = PTR_ERR(req);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (read_len != CEPH_FSCRYPT_BLOCK_SIZE) {\n\t\t\t\tceph_osdc_put_request(req);\n\t\t\t\tceph_release_page_vector(pages, num_pages);\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\top = &req->r_ops[0];\n\n\t\t\tif (first) {\n\t\t\t\tosd_req_op_extent_osd_data_pages(req, 0, pages,\n\t\t\t\t\t\t\t CEPH_FSCRYPT_BLOCK_SIZE,\n\t\t\t\t\t\t\t offset_in_page(first_pos),\n\t\t\t\t\t\t\t false, false);\n\t\t\t\t \n\t\t\t\tret = __ceph_alloc_sparse_ext_map(op, 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tceph_osdc_put_request(req);\n\t\t\t\t\tceph_release_page_vector(pages, num_pages);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (last) {\n\t\t\t\t \n\t\t\t\tif (first) {\n\t\t\t\t\top = &req->r_ops[1];\n\t\t\t\t\tosd_req_op_extent_init(req, 1,\n\t\t\t\t\t\t\tCEPH_OSD_OP_SPARSE_READ,\n\t\t\t\t\t\t\tlast_pos, CEPH_FSCRYPT_BLOCK_SIZE,\n\t\t\t\t\t\t\tci->i_truncate_size,\n\t\t\t\t\t\t\tci->i_truncate_seq);\n\t\t\t\t}\n\n\t\t\t\tret = __ceph_alloc_sparse_ext_map(op, 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tceph_osdc_put_request(req);\n\t\t\t\t\tceph_release_page_vector(pages, num_pages);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tosd_req_op_extent_osd_data_pages(req, first ? 1 : 0,\n\t\t\t\t\t\t\t&pages[num_pages - 1],\n\t\t\t\t\t\t\tCEPH_FSCRYPT_BLOCK_SIZE,\n\t\t\t\t\t\t\toffset_in_page(last_pos),\n\t\t\t\t\t\t\tfalse, false);\n\t\t\t}\n\n\t\t\tceph_osdc_start_request(osdc, req);\n\t\t\tret = ceph_osdc_wait_request(osdc, req);\n\n\t\t\t \n\t\t\tceph_update_read_metrics(&fsc->mdsc->metric,\n\t\t\t\t\t\t req->r_start_latency,\n\t\t\t\t\t\t req->r_end_latency,\n\t\t\t\t\t\t read_len, ret);\n\n\t\t\t \n\t\t\tif (ret == -ENOENT) {\n\t\t\t\t \n\t\t\t\tceph_osdc_put_request(req);\n\t\t\t\tret = 0;\n\n\t\t\t\t \n\t\t\t\tif (first)\n\t\t\t\t\tzero_user_segment(pages[0], 0,\n\t\t\t\t\t\t\t  offset_in_page(first_pos));\n\t\t\t\tif (last)\n\t\t\t\t\tzero_user_segment(pages[num_pages - 1],\n\t\t\t\t\t\t\t  offset_in_page(last_pos),\n\t\t\t\t\t\t\t  PAGE_SIZE);\n\t\t\t} else {\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tceph_osdc_put_request(req);\n\t\t\t\t\tceph_release_page_vector(pages, num_pages);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\top = &req->r_ops[0];\n\t\t\t\tif (op->extent.sparse_ext_cnt == 0) {\n\t\t\t\t\tif (first)\n\t\t\t\t\t\tzero_user_segment(pages[0], 0,\n\t\t\t\t\t\t\t\t  offset_in_page(first_pos));\n\t\t\t\t\telse\n\t\t\t\t\t\tzero_user_segment(pages[num_pages - 1],\n\t\t\t\t\t\t\t\t  offset_in_page(last_pos),\n\t\t\t\t\t\t\t\t  PAGE_SIZE);\n\t\t\t\t} else if (op->extent.sparse_ext_cnt != 1 ||\n\t\t\t\t\t   ceph_sparse_ext_map_end(op) !=\n\t\t\t\t\t\tCEPH_FSCRYPT_BLOCK_SIZE) {\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tceph_osdc_put_request(req);\n\t\t\t\t\tceph_release_page_vector(pages, num_pages);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (first && last) {\n\t\t\t\t\top = &req->r_ops[1];\n\t\t\t\t\tif (op->extent.sparse_ext_cnt == 0) {\n\t\t\t\t\t\tzero_user_segment(pages[num_pages - 1],\n\t\t\t\t\t\t\t\t  offset_in_page(last_pos),\n\t\t\t\t\t\t\t\t  PAGE_SIZE);\n\t\t\t\t\t} else if (op->extent.sparse_ext_cnt != 1 ||\n\t\t\t\t\t\t   ceph_sparse_ext_map_end(op) !=\n\t\t\t\t\t\t\tCEPH_FSCRYPT_BLOCK_SIZE) {\n\t\t\t\t\t\tret = -EIO;\n\t\t\t\t\t\tceph_osdc_put_request(req);\n\t\t\t\t\t\tceph_release_page_vector(pages, num_pages);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tassert_ver = req->r_version;\n\t\t\t\tWARN_ON_ONCE(ret > 0 && assert_ver == 0);\n\n\t\t\t\tceph_osdc_put_request(req);\n\t\t\t\tif (first) {\n\t\t\t\t\tret = ceph_fscrypt_decrypt_block_inplace(inode,\n\t\t\t\t\t\t\tpages[0], CEPH_FSCRYPT_BLOCK_SIZE,\n\t\t\t\t\t\t\toffset_in_page(first_pos),\n\t\t\t\t\t\t\tfirst_pos >> CEPH_FSCRYPT_BLOCK_SHIFT);\n\t\t\t\t\tif (ret < 0) {\n\t\t\t\t\t\tceph_release_page_vector(pages, num_pages);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (last) {\n\t\t\t\t\tret = ceph_fscrypt_decrypt_block_inplace(inode,\n\t\t\t\t\t\t\tpages[num_pages - 1],\n\t\t\t\t\t\t\tCEPH_FSCRYPT_BLOCK_SIZE,\n\t\t\t\t\t\t\toffset_in_page(last_pos),\n\t\t\t\t\t\t\tlast_pos >> CEPH_FSCRYPT_BLOCK_SHIFT);\n\t\t\t\t\tif (ret < 0) {\n\t\t\t\t\t\tceph_release_page_vector(pages, num_pages);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tleft = len;\n\t\toff = offset_in_page(pos);\n\t\tfor (n = 0; n < num_pages; n++) {\n\t\t\tsize_t plen = min_t(size_t, left, PAGE_SIZE - off);\n\n\t\t\t \n\t\t\tret = copy_page_from_iter(pages[n], off, plen, from);\n\t\t\tif (ret != plen) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toff = 0;\n\t\t\tleft -= ret;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdout(\"sync_write write failed with %d\\n\", ret);\n\t\t\tceph_release_page_vector(pages, num_pages);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (IS_ENCRYPTED(inode)) {\n\t\t\tret = ceph_fscrypt_encrypt_pages(inode, pages,\n\t\t\t\t\t\t\t write_pos, write_len,\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (ret < 0) {\n\t\t\t\tdout(\"encryption failed with %d\\n\", ret);\n\t\t\t\tceph_release_page_vector(pages, num_pages);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treq = ceph_osdc_new_request(osdc, &ci->i_layout,\n\t\t\t\t\t    ci->i_vino, write_pos, &write_len,\n\t\t\t\t\t    rmw ? 1 : 0, rmw ? 2 : 1,\n\t\t\t\t\t    CEPH_OSD_OP_WRITE,\n\t\t\t\t\t    CEPH_OSD_FLAG_WRITE,\n\t\t\t\t\t    snapc, ci->i_truncate_seq,\n\t\t\t\t\t    ci->i_truncate_size, false);\n\t\tif (IS_ERR(req)) {\n\t\t\tret = PTR_ERR(req);\n\t\t\tceph_release_page_vector(pages, num_pages);\n\t\t\tbreak;\n\t\t}\n\n\t\tdout(\"sync_write write op %lld~%llu\\n\", write_pos, write_len);\n\t\tosd_req_op_extent_osd_data_pages(req, rmw ? 1 : 0, pages, write_len,\n\t\t\t\t\t\t offset_in_page(write_pos), false,\n\t\t\t\t\t\t true);\n\t\treq->r_inode = inode;\n\t\treq->r_mtime = mtime;\n\n\t\t \n\t\tif (rmw) {\n\t\t\t \n\t\t\tif (assert_ver) {\n\t\t\t\tosd_req_op_init(req, 0, CEPH_OSD_OP_ASSERT_VER, 0);\n\t\t\t\treq->r_ops[0].assert_ver.ver = assert_ver;\n\t\t\t} else {\n\t\t\t\tosd_req_op_init(req, 0, CEPH_OSD_OP_CREATE,\n\t\t\t\t\t\tCEPH_OSD_OP_FLAG_EXCL);\n\t\t\t}\n\t\t}\n\n\t\tceph_osdc_start_request(osdc, req);\n\t\tret = ceph_osdc_wait_request(osdc, req);\n\n\t\tceph_update_write_metrics(&fsc->mdsc->metric, req->r_start_latency,\n\t\t\t\t\t  req->r_end_latency, len, ret);\n\t\tceph_osdc_put_request(req);\n\t\tif (ret != 0) {\n\t\t\tdout(\"sync_write osd write returned %d\\n\", ret);\n\t\t\t \n\t\t\tif ((assert_ver && (ret == -ERANGE || ret == -EOVERFLOW)) ||\n\t\t\t    (!assert_ver && ret == -EEXIST)) {\n\t\t\t\t \n\t\t\t\tWARN_ON_ONCE(!rmw);\n\n\t\t\t\t \n\t\t\t\tWARN_ON_ONCE(ret == -EOVERFLOW);\n\n\t\t\t\t*from = saved_iter;\n\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tceph_set_error_write(ci);\n\t\t\tbreak;\n\t\t}\n\n\t\tceph_clear_error_write(ci);\n\n\t\t \n\t\tret = invalidate_inode_pages2_range(\n\t\t\t\tinode->i_mapping,\n\t\t\t\tpos >> PAGE_SHIFT,\n\t\t\t\t(pos + len - 1) >> PAGE_SHIFT);\n\t\tif (ret < 0) {\n\t\t\tdout(\"invalidate_inode_pages2_range returned %d\\n\",\n\t\t\t     ret);\n\t\t\tret = 0;\n\t\t}\n\t\tpos += len;\n\t\twritten += len;\n\t\tdout(\"sync_write written %d\\n\", written);\n\t\tif (pos > i_size_read(inode)) {\n\t\t\tcheck_caps = ceph_inode_set_size(inode, pos);\n\t\t\tif (check_caps)\n\t\t\t\tceph_check_caps(ceph_inode(inode),\n\t\t\t\t\t\tCHECK_CAPS_AUTHONLY);\n\t\t}\n\n\t}\n\n\tif (ret != -EOLDSNAPC && written > 0) {\n\t\tret = written;\n\t\tiocb->ki_pos = pos;\n\t}\n\tdout(\"sync_write returning %d\\n\", ret);\n\treturn ret;\n}\n\n \nstatic ssize_t ceph_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct ceph_file_info *fi = filp->private_data;\n\tsize_t len = iov_iter_count(to);\n\tstruct inode *inode = file_inode(filp);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tbool direct_lock = iocb->ki_flags & IOCB_DIRECT;\n\tssize_t ret;\n\tint want = 0, got = 0;\n\tint retry_op = 0, read = 0;\n\nagain:\n\tdout(\"aio_read %p %llx.%llx %llu~%u trying to get caps on %p\\n\",\n\t     inode, ceph_vinop(inode), iocb->ki_pos, (unsigned)len, inode);\n\n\tif (ceph_inode_is_shutdown(inode))\n\t\treturn -ESTALE;\n\n\tif (direct_lock)\n\t\tceph_start_io_direct(inode);\n\telse\n\t\tceph_start_io_read(inode);\n\n\tif (!(fi->flags & CEPH_F_SYNC) && !direct_lock)\n\t\twant |= CEPH_CAP_FILE_CACHE;\n\tif (fi->fmode & CEPH_FILE_MODE_LAZY)\n\t\twant |= CEPH_CAP_FILE_LAZYIO;\n\n\tret = ceph_get_caps(filp, CEPH_CAP_FILE_RD, want, -1, &got);\n\tif (ret < 0) {\n\t\tif (direct_lock)\n\t\t\tceph_end_io_direct(inode);\n\t\telse\n\t\t\tceph_end_io_read(inode);\n\t\treturn ret;\n\t}\n\n\tif ((got & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) == 0 ||\n\t    (iocb->ki_flags & IOCB_DIRECT) ||\n\t    (fi->flags & CEPH_F_SYNC)) {\n\n\t\tdout(\"aio_sync_read %p %llx.%llx %llu~%u got cap refs on %s\\n\",\n\t\t     inode, ceph_vinop(inode), iocb->ki_pos, (unsigned)len,\n\t\t     ceph_cap_string(got));\n\n\t\tif (!ceph_has_inline_data(ci)) {\n\t\t\tif (!retry_op &&\n\t\t\t    (iocb->ki_flags & IOCB_DIRECT) &&\n\t\t\t    !IS_ENCRYPTED(inode)) {\n\t\t\t\tret = ceph_direct_read_write(iocb, to,\n\t\t\t\t\t\t\t     NULL, NULL);\n\t\t\t\tif (ret >= 0 && ret < len)\n\t\t\t\t\tretry_op = CHECK_EOF;\n\t\t\t} else {\n\t\t\t\tret = ceph_sync_read(iocb, to, &retry_op);\n\t\t\t}\n\t\t} else {\n\t\t\tretry_op = READ_INLINE;\n\t\t}\n\t} else {\n\t\tCEPH_DEFINE_RW_CONTEXT(rw_ctx, got);\n\t\tdout(\"aio_read %p %llx.%llx %llu~%u got cap refs on %s\\n\",\n\t\t     inode, ceph_vinop(inode), iocb->ki_pos, (unsigned)len,\n\t\t     ceph_cap_string(got));\n\t\tceph_add_rw_context(fi, &rw_ctx);\n\t\tret = generic_file_read_iter(iocb, to);\n\t\tceph_del_rw_context(fi, &rw_ctx);\n\t}\n\n\tdout(\"aio_read %p %llx.%llx dropping cap refs on %s = %d\\n\",\n\t     inode, ceph_vinop(inode), ceph_cap_string(got), (int)ret);\n\tceph_put_cap_refs(ci, got);\n\n\tif (direct_lock)\n\t\tceph_end_io_direct(inode);\n\telse\n\t\tceph_end_io_read(inode);\n\n\tif (retry_op > HAVE_RETRIED && ret >= 0) {\n\t\tint statret;\n\t\tstruct page *page = NULL;\n\t\tloff_t i_size;\n\t\tif (retry_op == READ_INLINE) {\n\t\t\tpage = __page_cache_alloc(GFP_KERNEL);\n\t\t\tif (!page)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tstatret = __ceph_do_getattr(inode, page,\n\t\t\t\t\t    CEPH_STAT_CAP_INLINE_DATA, !!page);\n\t\tif (statret < 0) {\n\t\t\tif (page)\n\t\t\t\t__free_page(page);\n\t\t\tif (statret == -ENODATA) {\n\t\t\t\tBUG_ON(retry_op != READ_INLINE);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\treturn statret;\n\t\t}\n\n\t\ti_size = i_size_read(inode);\n\t\tif (retry_op == READ_INLINE) {\n\t\t\tBUG_ON(ret > 0 || read > 0);\n\t\t\tif (iocb->ki_pos < i_size &&\n\t\t\t    iocb->ki_pos < PAGE_SIZE) {\n\t\t\t\tloff_t end = min_t(loff_t, i_size,\n\t\t\t\t\t\t   iocb->ki_pos + len);\n\t\t\t\tend = min_t(loff_t, end, PAGE_SIZE);\n\t\t\t\tif (statret < end)\n\t\t\t\t\tzero_user_segment(page, statret, end);\n\t\t\t\tret = copy_page_to_iter(page,\n\t\t\t\t\t\tiocb->ki_pos & ~PAGE_MASK,\n\t\t\t\t\t\tend - iocb->ki_pos, to);\n\t\t\t\tiocb->ki_pos += ret;\n\t\t\t\tread += ret;\n\t\t\t}\n\t\t\tif (iocb->ki_pos < i_size && read < len) {\n\t\t\t\tsize_t zlen = min_t(size_t, len - read,\n\t\t\t\t\t\t    i_size - iocb->ki_pos);\n\t\t\t\tret = iov_iter_zero(zlen, to);\n\t\t\t\tiocb->ki_pos += ret;\n\t\t\t\tread += ret;\n\t\t\t}\n\t\t\t__free_pages(page, 0);\n\t\t\treturn read;\n\t\t}\n\n\t\t \n\t\tif (retry_op == CHECK_EOF && iocb->ki_pos < i_size &&\n\t\t    ret < len) {\n\t\t\tdout(\"sync_read hit hole, ppos %lld < size %lld\"\n\t\t\t     \", reading more\\n\", iocb->ki_pos, i_size);\n\n\t\t\tread += ret;\n\t\t\tlen -= ret;\n\t\t\tretry_op = HAVE_RETRIED;\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\tif (ret >= 0)\n\t\tret += read;\n\n\treturn ret;\n}\n\n \nstatic ssize_t ceph_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\tstruct pipe_inode_info *pipe,\n\t\t\t\tsize_t len, unsigned int flags)\n{\n\tstruct ceph_file_info *fi = in->private_data;\n\tstruct inode *inode = file_inode(in);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tssize_t ret;\n\tint want = 0, got = 0;\n\tCEPH_DEFINE_RW_CONTEXT(rw_ctx, 0);\n\n\tdout(\"splice_read %p %llx.%llx %llu~%zu trying to get caps on %p\\n\",\n\t     inode, ceph_vinop(inode), *ppos, len, inode);\n\n\tif (ceph_inode_is_shutdown(inode))\n\t\treturn -ESTALE;\n\n\tif (ceph_has_inline_data(ci) ||\n\t    (fi->flags & CEPH_F_SYNC))\n\t\treturn copy_splice_read(in, ppos, pipe, len, flags);\n\n\tceph_start_io_read(inode);\n\n\twant = CEPH_CAP_FILE_CACHE;\n\tif (fi->fmode & CEPH_FILE_MODE_LAZY)\n\t\twant |= CEPH_CAP_FILE_LAZYIO;\n\n\tret = ceph_get_caps(in, CEPH_CAP_FILE_RD, want, -1, &got);\n\tif (ret < 0)\n\t\tgoto out_end;\n\n\tif ((got & (CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO)) == 0) {\n\t\tdout(\"splice_read/sync %p %llx.%llx %llu~%zu got cap refs on %s\\n\",\n\t\t     inode, ceph_vinop(inode), *ppos, len,\n\t\t     ceph_cap_string(got));\n\n\t\tceph_put_cap_refs(ci, got);\n\t\tceph_end_io_read(inode);\n\t\treturn copy_splice_read(in, ppos, pipe, len, flags);\n\t}\n\n\tdout(\"splice_read %p %llx.%llx %llu~%zu got cap refs on %s\\n\",\n\t     inode, ceph_vinop(inode), *ppos, len, ceph_cap_string(got));\n\n\trw_ctx.caps = got;\n\tceph_add_rw_context(fi, &rw_ctx);\n\tret = filemap_splice_read(in, ppos, pipe, len, flags);\n\tceph_del_rw_context(fi, &rw_ctx);\n\n\tdout(\"splice_read %p %llx.%llx dropping cap refs on %s = %zd\\n\",\n\t     inode, ceph_vinop(inode), ceph_cap_string(got), ret);\n\n\tceph_put_cap_refs(ci, got);\nout_end:\n\tceph_end_io_read(inode);\n\treturn ret;\n}\n\n \nstatic ssize_t ceph_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct ceph_file_info *fi = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_osd_client *osdc = &fsc->client->osdc;\n\tstruct ceph_cap_flush *prealloc_cf;\n\tssize_t count, written = 0;\n\tint err, want = 0, got;\n\tbool direct_lock = false;\n\tu32 map_flags;\n\tu64 pool_flags;\n\tloff_t pos;\n\tloff_t limit = max(i_size_read(inode), fsc->max_file_size);\n\n\tif (ceph_inode_is_shutdown(inode))\n\t\treturn -ESTALE;\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tprealloc_cf = ceph_alloc_cap_flush();\n\tif (!prealloc_cf)\n\t\treturn -ENOMEM;\n\n\tif ((iocb->ki_flags & (IOCB_DIRECT | IOCB_APPEND)) == IOCB_DIRECT)\n\t\tdirect_lock = true;\n\nretry_snap:\n\tif (direct_lock)\n\t\tceph_start_io_direct(inode);\n\telse\n\t\tceph_start_io_write(inode);\n\n\tif (iocb->ki_flags & IOCB_APPEND) {\n\t\terr = ceph_do_getattr(inode, CEPH_STAT_CAP_SIZE, false);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\terr = generic_write_checks(iocb, from);\n\tif (err <= 0)\n\t\tgoto out;\n\n\tpos = iocb->ki_pos;\n\tif (unlikely(pos >= limit)) {\n\t\terr = -EFBIG;\n\t\tgoto out;\n\t} else {\n\t\tiov_iter_truncate(from, limit - pos);\n\t}\n\n\tcount = iov_iter_count(from);\n\tif (ceph_quota_is_max_bytes_exceeded(inode, pos + count)) {\n\t\terr = -EDQUOT;\n\t\tgoto out;\n\t}\n\n\tdown_read(&osdc->lock);\n\tmap_flags = osdc->osdmap->flags;\n\tpool_flags = ceph_pg_pool_flags(osdc->osdmap, ci->i_layout.pool_id);\n\tup_read(&osdc->lock);\n\tif ((map_flags & CEPH_OSDMAP_FULL) ||\n\t    (pool_flags & CEPH_POOL_FLAG_FULL)) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\terr = file_remove_privs(file);\n\tif (err)\n\t\tgoto out;\n\n\tdout(\"aio_write %p %llx.%llx %llu~%zd getting caps. i_size %llu\\n\",\n\t     inode, ceph_vinop(inode), pos, count, i_size_read(inode));\n\tif (!(fi->flags & CEPH_F_SYNC) && !direct_lock)\n\t\twant |= CEPH_CAP_FILE_BUFFER;\n\tif (fi->fmode & CEPH_FILE_MODE_LAZY)\n\t\twant |= CEPH_CAP_FILE_LAZYIO;\n\tgot = 0;\n\terr = ceph_get_caps(file, CEPH_CAP_FILE_WR, want, pos + count, &got);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = file_update_time(file);\n\tif (err)\n\t\tgoto out_caps;\n\n\tinode_inc_iversion_raw(inode);\n\n\tdout(\"aio_write %p %llx.%llx %llu~%zd got cap refs on %s\\n\",\n\t     inode, ceph_vinop(inode), pos, count, ceph_cap_string(got));\n\n\tif ((got & (CEPH_CAP_FILE_BUFFER|CEPH_CAP_FILE_LAZYIO)) == 0 ||\n\t    (iocb->ki_flags & IOCB_DIRECT) || (fi->flags & CEPH_F_SYNC) ||\n\t    (ci->i_ceph_flags & CEPH_I_ERROR_WRITE)) {\n\t\tstruct ceph_snap_context *snapc;\n\t\tstruct iov_iter data;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (__ceph_have_pending_cap_snap(ci)) {\n\t\t\tstruct ceph_cap_snap *capsnap =\n\t\t\t\t\tlist_last_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t\tstruct ceph_cap_snap,\n\t\t\t\t\t\t\tci_item);\n\t\t\tsnapc = ceph_get_snap_context(capsnap->context);\n\t\t} else {\n\t\t\tBUG_ON(!ci->i_head_snapc);\n\t\t\tsnapc = ceph_get_snap_context(ci->i_head_snapc);\n\t\t}\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t \n\t\tdata = *from;\n\t\tif ((iocb->ki_flags & IOCB_DIRECT) && !IS_ENCRYPTED(inode))\n\t\t\twritten = ceph_direct_read_write(iocb, &data, snapc,\n\t\t\t\t\t\t\t &prealloc_cf);\n\t\telse\n\t\t\twritten = ceph_sync_write(iocb, &data, pos, snapc);\n\t\tif (direct_lock)\n\t\t\tceph_end_io_direct(inode);\n\t\telse\n\t\t\tceph_end_io_write(inode);\n\t\tif (written > 0)\n\t\t\tiov_iter_advance(from, written);\n\t\tceph_put_snap_context(snapc);\n\t} else {\n\t\t \n\t\twritten = generic_perform_write(iocb, from);\n\t\tceph_end_io_write(inode);\n\t}\n\n\tif (written >= 0) {\n\t\tint dirty;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_FILE_WR,\n\t\t\t\t\t       &prealloc_cf);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tif (dirty)\n\t\t\t__mark_inode_dirty(inode, dirty);\n\t\tif (ceph_quota_is_max_bytes_approaching(inode, iocb->ki_pos))\n\t\t\tceph_check_caps(ci, CHECK_CAPS_FLUSH);\n\t}\n\n\tdout(\"aio_write %p %llx.%llx %llu~%u  dropping cap refs on %s\\n\",\n\t     inode, ceph_vinop(inode), pos, (unsigned)count,\n\t     ceph_cap_string(got));\n\tceph_put_cap_refs(ci, got);\n\n\tif (written == -EOLDSNAPC) {\n\t\tdout(\"aio_write %p %llx.%llx %llu~%u\" \"got EOLDSNAPC, retrying\\n\",\n\t\t     inode, ceph_vinop(inode), pos, (unsigned)count);\n\t\tgoto retry_snap;\n\t}\n\n\tif (written >= 0) {\n\t\tif ((map_flags & CEPH_OSDMAP_NEARFULL) ||\n\t\t    (pool_flags & CEPH_POOL_FLAG_NEARFULL))\n\t\t\tiocb->ki_flags |= IOCB_DSYNC;\n\t\twritten = generic_write_sync(iocb, written);\n\t}\n\n\tgoto out_unlocked;\nout_caps:\n\tceph_put_cap_refs(ci, got);\nout:\n\tif (direct_lock)\n\t\tceph_end_io_direct(inode);\n\telse\n\t\tceph_end_io_write(inode);\nout_unlocked:\n\tceph_free_cap_flush(prealloc_cf);\n\treturn written ? written : err;\n}\n\n \nstatic loff_t ceph_llseek(struct file *file, loff_t offset, int whence)\n{\n\tif (whence == SEEK_END || whence == SEEK_DATA || whence == SEEK_HOLE) {\n\t\tstruct inode *inode = file_inode(file);\n\t\tint ret;\n\n\t\tret = ceph_do_getattr(inode, CEPH_STAT_CAP_SIZE, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn generic_file_llseek(file, offset, whence);\n}\n\nstatic inline void ceph_zero_partial_page(\n\tstruct inode *inode, loff_t offset, unsigned size)\n{\n\tstruct page *page;\n\tpgoff_t index = offset >> PAGE_SHIFT;\n\n\tpage = find_lock_page(inode->i_mapping, index);\n\tif (page) {\n\t\twait_on_page_writeback(page);\n\t\tzero_user(page, offset & (PAGE_SIZE - 1), size);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n}\n\nstatic void ceph_zero_pagecache_range(struct inode *inode, loff_t offset,\n\t\t\t\t      loff_t length)\n{\n\tloff_t nearly = round_up(offset, PAGE_SIZE);\n\tif (offset < nearly) {\n\t\tloff_t size = nearly - offset;\n\t\tif (length < size)\n\t\t\tsize = length;\n\t\tceph_zero_partial_page(inode, offset, size);\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\tif (length >= PAGE_SIZE) {\n\t\tloff_t size = round_down(length, PAGE_SIZE);\n\t\ttruncate_pagecache_range(inode, offset, offset + size - 1);\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\tif (length)\n\t\tceph_zero_partial_page(inode, offset, length);\n}\n\nstatic int ceph_zero_partial_object(struct inode *inode,\n\t\t\t\t    loff_t offset, loff_t *length)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_osd_request *req;\n\tint ret = 0;\n\tloff_t zero = 0;\n\tint op;\n\n\tif (ceph_inode_is_shutdown(inode))\n\t\treturn -EIO;\n\n\tif (!length) {\n\t\top = offset ? CEPH_OSD_OP_DELETE : CEPH_OSD_OP_TRUNCATE;\n\t\tlength = &zero;\n\t} else {\n\t\top = CEPH_OSD_OP_ZERO;\n\t}\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t\tceph_vino(inode),\n\t\t\t\t\toffset, length,\n\t\t\t\t\t0, 1, op,\n\t\t\t\t\tCEPH_OSD_FLAG_WRITE,\n\t\t\t\t\tNULL, 0, 0, false);\n\tif (IS_ERR(req)) {\n\t\tret = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\treq->r_mtime = inode->i_mtime;\n\tceph_osdc_start_request(&fsc->client->osdc, req);\n\tret = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\tif (ret == -ENOENT)\n\t\tret = 0;\n\tceph_osdc_put_request(req);\n\nout:\n\treturn ret;\n}\n\nstatic int ceph_zero_objects(struct inode *inode, loff_t offset, loff_t length)\n{\n\tint ret = 0;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\ts32 stripe_unit = ci->i_layout.stripe_unit;\n\ts32 stripe_count = ci->i_layout.stripe_count;\n\ts32 object_size = ci->i_layout.object_size;\n\tu64 object_set_size = object_size * stripe_count;\n\tu64 nearly, t;\n\n\t \n\tnearly = offset + object_set_size - 1;\n\tt = nearly;\n\tnearly -= do_div(t, object_set_size);\n\n\twhile (length && offset < nearly) {\n\t\tloff_t size = length;\n\t\tret = ceph_zero_partial_object(inode, offset, &size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\twhile (length >= object_set_size) {\n\t\tint i;\n\t\tloff_t pos = offset;\n\t\tfor (i = 0; i < stripe_count; ++i) {\n\t\t\tret = ceph_zero_partial_object(inode, pos, NULL);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tpos += stripe_unit;\n\t\t}\n\t\toffset += object_set_size;\n\t\tlength -= object_set_size;\n\t}\n\twhile (length) {\n\t\tloff_t size = length;\n\t\tret = ceph_zero_partial_object(inode, offset, &size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\treturn ret;\n}\n\nstatic long ceph_fallocate(struct file *file, int mode,\n\t\t\t\tloff_t offset, loff_t length)\n{\n\tstruct ceph_file_info *fi = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap_flush *prealloc_cf;\n\tint want, got = 0;\n\tint dirty;\n\tint ret = 0;\n\tloff_t endoff = 0;\n\tloff_t size;\n\n\tdout(\"%s %p %llx.%llx mode %x, offset %llu length %llu\\n\", __func__,\n\t     inode, ceph_vinop(inode), mode, offset, length);\n\n\tif (mode != (FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (IS_ENCRYPTED(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tprealloc_cf = ceph_alloc_cap_flush();\n\tif (!prealloc_cf)\n\t\treturn -ENOMEM;\n\n\tinode_lock(inode);\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP) {\n\t\tret = -EROFS;\n\t\tgoto unlock;\n\t}\n\n\tsize = i_size_read(inode);\n\n\t \n\tif (offset >= size)\n\t\tgoto unlock;\n\tif ((offset + length) > size)\n\t\tlength = size - offset;\n\n\tif (fi->fmode & CEPH_FILE_MODE_LAZY)\n\t\twant = CEPH_CAP_FILE_BUFFER | CEPH_CAP_FILE_LAZYIO;\n\telse\n\t\twant = CEPH_CAP_FILE_BUFFER;\n\n\tret = ceph_get_caps(file, CEPH_CAP_FILE_WR, want, endoff, &got);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tret = file_modified(file);\n\tif (ret)\n\t\tgoto put_caps;\n\n\tfilemap_invalidate_lock(inode->i_mapping);\n\tceph_fscache_invalidate(inode, false);\n\tceph_zero_pagecache_range(inode, offset, length);\n\tret = ceph_zero_objects(inode, offset, length);\n\n\tif (!ret) {\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_FILE_WR,\n\t\t\t\t\t       &prealloc_cf);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tif (dirty)\n\t\t\t__mark_inode_dirty(inode, dirty);\n\t}\n\tfilemap_invalidate_unlock(inode->i_mapping);\n\nput_caps:\n\tceph_put_cap_refs(ci, got);\nunlock:\n\tinode_unlock(inode);\n\tceph_free_cap_flush(prealloc_cf);\n\treturn ret;\n}\n\n \nstatic int get_rd_wr_caps(struct file *src_filp, int *src_got,\n\t\t\t  struct file *dst_filp,\n\t\t\t  loff_t dst_endoff, int *dst_got)\n{\n\tint ret = 0;\n\tbool retrying = false;\n\nretry_caps:\n\tret = ceph_get_caps(dst_filp, CEPH_CAP_FILE_WR, CEPH_CAP_FILE_BUFFER,\n\t\t\t    dst_endoff, dst_got);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ceph_try_get_caps(file_inode(src_filp),\n\t\t\t\tCEPH_CAP_FILE_RD, CEPH_CAP_FILE_SHARED,\n\t\t\t\tfalse, src_got);\n\tif (ret <= 0) {\n\t\t \n\t\tceph_put_cap_refs(ceph_inode(file_inode(dst_filp)), *dst_got);\n\t\tif (retrying) {\n\t\t\tif (!ret)\n\t\t\t\t \n\t\t\t\tret = -EAGAIN;\n\t\t\treturn ret;\n\t\t}\n\t\tret = ceph_get_caps(src_filp, CEPH_CAP_FILE_RD,\n\t\t\t\t    CEPH_CAP_FILE_SHARED, -1, src_got);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tceph_put_cap_refs(ceph_inode(file_inode(src_filp)), *src_got);\n\t\tretrying = true;\n\t\tgoto retry_caps;\n\t}\n\treturn ret;\n}\n\nstatic void put_rd_wr_caps(struct ceph_inode_info *src_ci, int src_got,\n\t\t\t   struct ceph_inode_info *dst_ci, int dst_got)\n{\n\tceph_put_cap_refs(src_ci, src_got);\n\tceph_put_cap_refs(dst_ci, dst_got);\n}\n\n \nstatic int is_file_size_ok(struct inode *src_inode, struct inode *dst_inode,\n\t\t\t   loff_t src_off, loff_t dst_off, size_t len)\n{\n\tloff_t size, endoff;\n\n\tsize = i_size_read(src_inode);\n\t \n\tif (src_off + len > size) {\n\t\tdout(\"Copy beyond EOF (%llu + %zu > %llu)\\n\",\n\t\t     src_off, len, size);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tsize = i_size_read(dst_inode);\n\n\tendoff = dst_off + len;\n\tif (inode_newsize_ok(dst_inode, endoff))\n\t\treturn -EOPNOTSUPP;\n\n\tif (ceph_quota_is_max_bytes_exceeded(dst_inode, endoff))\n\t\treturn -EDQUOT;\n\n\treturn 0;\n}\n\nstatic struct ceph_osd_request *\nceph_alloc_copyfrom_request(struct ceph_osd_client *osdc,\n\t\t\t    u64 src_snapid,\n\t\t\t    struct ceph_object_id *src_oid,\n\t\t\t    struct ceph_object_locator *src_oloc,\n\t\t\t    struct ceph_object_id *dst_oid,\n\t\t\t    struct ceph_object_locator *dst_oloc,\n\t\t\t    u32 truncate_seq, u64 truncate_size)\n{\n\tstruct ceph_osd_request *req;\n\tint ret;\n\tu32 src_fadvise_flags =\n\t\tCEPH_OSD_OP_FLAG_FADVISE_SEQUENTIAL |\n\t\tCEPH_OSD_OP_FLAG_FADVISE_NOCACHE;\n\tu32 dst_fadvise_flags =\n\t\tCEPH_OSD_OP_FLAG_FADVISE_SEQUENTIAL |\n\t\tCEPH_OSD_OP_FLAG_FADVISE_DONTNEED;\n\n\treq = ceph_osdc_alloc_request(osdc, NULL, 1, false, GFP_KERNEL);\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treq->r_flags = CEPH_OSD_FLAG_WRITE;\n\n\tceph_oloc_copy(&req->r_t.base_oloc, dst_oloc);\n\tceph_oid_copy(&req->r_t.base_oid, dst_oid);\n\n\tret = osd_req_op_copy_from_init(req, src_snapid, 0,\n\t\t\t\t\tsrc_oid, src_oloc,\n\t\t\t\t\tsrc_fadvise_flags,\n\t\t\t\t\tdst_fadvise_flags,\n\t\t\t\t\ttruncate_seq,\n\t\t\t\t\ttruncate_size,\n\t\t\t\t\tCEPH_OSD_COPY_FROM_FLAG_TRUNCATE_SEQ);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ceph_osdc_alloc_messages(req, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out;\n\n\treturn req;\n\nout:\n\tceph_osdc_put_request(req);\n\treturn ERR_PTR(ret);\n}\n\nstatic ssize_t ceph_do_objects_copy(struct ceph_inode_info *src_ci, u64 *src_off,\n\t\t\t\t    struct ceph_inode_info *dst_ci, u64 *dst_off,\n\t\t\t\t    struct ceph_fs_client *fsc,\n\t\t\t\t    size_t len, unsigned int flags)\n{\n\tstruct ceph_object_locator src_oloc, dst_oloc;\n\tstruct ceph_object_id src_oid, dst_oid;\n\tstruct ceph_osd_client *osdc;\n\tstruct ceph_osd_request *req;\n\tsize_t bytes = 0;\n\tu64 src_objnum, src_objoff, dst_objnum, dst_objoff;\n\tu32 src_objlen, dst_objlen;\n\tu32 object_size = src_ci->i_layout.object_size;\n\tint ret;\n\n\tsrc_oloc.pool = src_ci->i_layout.pool_id;\n\tsrc_oloc.pool_ns = ceph_try_get_string(src_ci->i_layout.pool_ns);\n\tdst_oloc.pool = dst_ci->i_layout.pool_id;\n\tdst_oloc.pool_ns = ceph_try_get_string(dst_ci->i_layout.pool_ns);\n\tosdc = &fsc->client->osdc;\n\n\twhile (len >= object_size) {\n\t\tceph_calc_file_object_mapping(&src_ci->i_layout, *src_off,\n\t\t\t\t\t      object_size, &src_objnum,\n\t\t\t\t\t      &src_objoff, &src_objlen);\n\t\tceph_calc_file_object_mapping(&dst_ci->i_layout, *dst_off,\n\t\t\t\t\t      object_size, &dst_objnum,\n\t\t\t\t\t      &dst_objoff, &dst_objlen);\n\t\tceph_oid_init(&src_oid);\n\t\tceph_oid_printf(&src_oid, \"%llx.%08llx\",\n\t\t\t\tsrc_ci->i_vino.ino, src_objnum);\n\t\tceph_oid_init(&dst_oid);\n\t\tceph_oid_printf(&dst_oid, \"%llx.%08llx\",\n\t\t\t\tdst_ci->i_vino.ino, dst_objnum);\n\t\t \n\t\treq = ceph_alloc_copyfrom_request(osdc, src_ci->i_vino.snap,\n\t\t\t\t\t\t  &src_oid, &src_oloc,\n\t\t\t\t\t\t  &dst_oid, &dst_oloc,\n\t\t\t\t\t\t  dst_ci->i_truncate_seq,\n\t\t\t\t\t\t  dst_ci->i_truncate_size);\n\t\tif (IS_ERR(req))\n\t\t\tret = PTR_ERR(req);\n\t\telse {\n\t\t\tceph_osdc_start_request(osdc, req);\n\t\t\tret = ceph_osdc_wait_request(osdc, req);\n\t\t\tceph_update_copyfrom_metrics(&fsc->mdsc->metric,\n\t\t\t\t\t\t     req->r_start_latency,\n\t\t\t\t\t\t     req->r_end_latency,\n\t\t\t\t\t\t     object_size, ret);\n\t\t\tceph_osdc_put_request(req);\n\t\t}\n\t\tif (ret) {\n\t\t\tif (ret == -EOPNOTSUPP) {\n\t\t\t\tfsc->have_copy_from2 = false;\n\t\t\t\tpr_notice(\"OSDs don't support copy-from2; disabling copy offload\\n\");\n\t\t\t}\n\t\t\tdout(\"ceph_osdc_copy_from returned %d\\n\", ret);\n\t\t\tif (!bytes)\n\t\t\t\tbytes = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tlen -= object_size;\n\t\tbytes += object_size;\n\t\t*src_off += object_size;\n\t\t*dst_off += object_size;\n\t}\n\nout:\n\tceph_oloc_destroy(&src_oloc);\n\tceph_oloc_destroy(&dst_oloc);\n\treturn bytes;\n}\n\nstatic ssize_t __ceph_copy_file_range(struct file *src_file, loff_t src_off,\n\t\t\t\t      struct file *dst_file, loff_t dst_off,\n\t\t\t\t      size_t len, unsigned int flags)\n{\n\tstruct inode *src_inode = file_inode(src_file);\n\tstruct inode *dst_inode = file_inode(dst_file);\n\tstruct ceph_inode_info *src_ci = ceph_inode(src_inode);\n\tstruct ceph_inode_info *dst_ci = ceph_inode(dst_inode);\n\tstruct ceph_cap_flush *prealloc_cf;\n\tstruct ceph_fs_client *src_fsc = ceph_inode_to_client(src_inode);\n\tloff_t size;\n\tssize_t ret = -EIO, bytes;\n\tu64 src_objnum, dst_objnum, src_objoff, dst_objoff;\n\tu32 src_objlen, dst_objlen;\n\tint src_got = 0, dst_got = 0, err, dirty;\n\n\tif (src_inode->i_sb != dst_inode->i_sb) {\n\t\tstruct ceph_fs_client *dst_fsc = ceph_inode_to_client(dst_inode);\n\n\t\tif (ceph_fsid_compare(&src_fsc->client->fsid,\n\t\t\t\t      &dst_fsc->client->fsid)) {\n\t\t\tdout(\"Copying files across clusters: src: %pU dst: %pU\\n\",\n\t\t\t     &src_fsc->client->fsid, &dst_fsc->client->fsid);\n\t\t\treturn -EXDEV;\n\t\t}\n\t}\n\tif (ceph_snap(dst_inode) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\t \n\n\tif (ceph_test_mount_opt(src_fsc, NOCOPYFROM))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!src_fsc->have_copy_from2)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((src_ci->i_layout.stripe_unit != dst_ci->i_layout.stripe_unit) ||\n\t    (src_ci->i_layout.stripe_count != 1) ||\n\t    (dst_ci->i_layout.stripe_count != 1) ||\n\t    (src_ci->i_layout.object_size != dst_ci->i_layout.object_size)) {\n\t\tdout(\"Invalid src/dst files layout\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (IS_ENCRYPTED(src_inode) || IS_ENCRYPTED(dst_inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len < src_ci->i_layout.object_size)\n\t\treturn -EOPNOTSUPP;  \n\n\tprealloc_cf = ceph_alloc_cap_flush();\n\tif (!prealloc_cf)\n\t\treturn -ENOMEM;\n\n\t \n\tret = file_write_and_wait_range(src_file, src_off, (src_off + len));\n\tif (ret < 0) {\n\t\tdout(\"failed to write src file (%zd)\\n\", ret);\n\t\tgoto out;\n\t}\n\tret = file_write_and_wait_range(dst_file, dst_off, (dst_off + len));\n\tif (ret < 0) {\n\t\tdout(\"failed to write dst file (%zd)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\terr = get_rd_wr_caps(src_file, &src_got,\n\t\t\t     dst_file, (dst_off + len), &dst_got);\n\tif (err < 0) {\n\t\tdout(\"get_rd_wr_caps returned %d\\n\", err);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = is_file_size_ok(src_inode, dst_inode, src_off, dst_off, len);\n\tif (ret < 0)\n\t\tgoto out_caps;\n\n\t \n\tceph_fscache_invalidate(dst_inode, false);\n\tret = invalidate_inode_pages2_range(dst_inode->i_mapping,\n\t\t\t\t\t    dst_off >> PAGE_SHIFT,\n\t\t\t\t\t    (dst_off + len) >> PAGE_SHIFT);\n\tif (ret < 0) {\n\t\tdout(\"Failed to invalidate inode pages (%zd)\\n\", ret);\n\t\tret = 0;  \n\t}\n\tceph_calc_file_object_mapping(&src_ci->i_layout, src_off,\n\t\t\t\t      src_ci->i_layout.object_size,\n\t\t\t\t      &src_objnum, &src_objoff, &src_objlen);\n\tceph_calc_file_object_mapping(&dst_ci->i_layout, dst_off,\n\t\t\t\t      dst_ci->i_layout.object_size,\n\t\t\t\t      &dst_objnum, &dst_objoff, &dst_objlen);\n\t \n\tif (src_objoff != dst_objoff) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_caps;\n\t}\n\n\t \n\tif (src_objoff) {\n\t\tdout(\"Initial partial copy of %u bytes\\n\", src_objlen);\n\n\t\t \n\t\tput_rd_wr_caps(src_ci, src_got, dst_ci, dst_got);\n\t\tret = do_splice_direct(src_file, &src_off, dst_file,\n\t\t\t\t       &dst_off, src_objlen, flags);\n\t\t \n\t\tif (ret < (long)src_objlen) {\n\t\t\tdout(\"Failed partial copy (%zd)\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t\tlen -= ret;\n\t\terr = get_rd_wr_caps(src_file, &src_got,\n\t\t\t\t     dst_file, (dst_off + len), &dst_got);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\terr = is_file_size_ok(src_inode, dst_inode,\n\t\t\t\t      src_off, dst_off, len);\n\t\tif (err < 0)\n\t\t\tgoto out_caps;\n\t}\n\n\tsize = i_size_read(dst_inode);\n\tbytes = ceph_do_objects_copy(src_ci, &src_off, dst_ci, &dst_off,\n\t\t\t\t     src_fsc, len, flags);\n\tif (bytes <= 0) {\n\t\tif (!ret)\n\t\t\tret = bytes;\n\t\tgoto out_caps;\n\t}\n\tdout(\"Copied %zu bytes out of %zu\\n\", bytes, len);\n\tlen -= bytes;\n\tret += bytes;\n\n\tfile_update_time(dst_file);\n\tinode_inc_iversion_raw(dst_inode);\n\n\tif (dst_off > size) {\n\t\t \n\t\tif (ceph_inode_set_size(dst_inode, dst_off) ||\n\t\t    ceph_quota_is_max_bytes_approaching(dst_inode, dst_off))\n\t\t\tceph_check_caps(dst_ci, CHECK_CAPS_AUTHONLY | CHECK_CAPS_FLUSH);\n\t}\n\t \n\tspin_lock(&dst_ci->i_ceph_lock);\n\tdirty = __ceph_mark_dirty_caps(dst_ci, CEPH_CAP_FILE_WR, &prealloc_cf);\n\tspin_unlock(&dst_ci->i_ceph_lock);\n\tif (dirty)\n\t\t__mark_inode_dirty(dst_inode, dirty);\n\nout_caps:\n\tput_rd_wr_caps(src_ci, src_got, dst_ci, dst_got);\n\n\t \n\tif (len && (len < src_ci->i_layout.object_size)) {\n\t\tdout(\"Final partial copy of %zu bytes\\n\", len);\n\t\tbytes = do_splice_direct(src_file, &src_off, dst_file,\n\t\t\t\t\t &dst_off, len, flags);\n\t\tif (bytes > 0)\n\t\t\tret += bytes;\n\t\telse\n\t\t\tdout(\"Failed partial copy (%zd)\\n\", bytes);\n\t}\n\nout:\n\tceph_free_cap_flush(prealloc_cf);\n\n\treturn ret;\n}\n\nstatic ssize_t ceph_copy_file_range(struct file *src_file, loff_t src_off,\n\t\t\t\t    struct file *dst_file, loff_t dst_off,\n\t\t\t\t    size_t len, unsigned int flags)\n{\n\tssize_t ret;\n\n\tret = __ceph_copy_file_range(src_file, src_off, dst_file, dst_off,\n\t\t\t\t     len, flags);\n\n\tif (ret == -EOPNOTSUPP || ret == -EXDEV)\n\t\tret = generic_copy_file_range(src_file, src_off, dst_file,\n\t\t\t\t\t      dst_off, len, flags);\n\treturn ret;\n}\n\nconst struct file_operations ceph_file_fops = {\n\t.open = ceph_open,\n\t.release = ceph_release,\n\t.llseek = ceph_llseek,\n\t.read_iter = ceph_read_iter,\n\t.write_iter = ceph_write_iter,\n\t.mmap = ceph_mmap,\n\t.fsync = ceph_fsync,\n\t.lock = ceph_lock,\n\t.setlease = simple_nosetlease,\n\t.flock = ceph_flock,\n\t.splice_read = ceph_splice_read,\n\t.splice_write = iter_file_splice_write,\n\t.unlocked_ioctl = ceph_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n\t.fallocate\t= ceph_fallocate,\n\t.copy_file_range = ceph_copy_file_range,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}