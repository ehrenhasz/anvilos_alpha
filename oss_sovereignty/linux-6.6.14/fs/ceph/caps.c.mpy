{
  "module_name": "caps.c",
  "hash_id": "2e87151741bf65ad9d44eda9b874bf6d913f64fdf34fa6428f01cf72bb0f6721",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/caps.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/wait.h>\n#include <linux/writeback.h>\n#include <linux/iversion.h>\n#include <linux/filelock.h>\n\n#include \"super.h\"\n#include \"mds_client.h\"\n#include \"cache.h\"\n#include \"crypto.h\"\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n\n \n\nstatic u64 __get_oldest_flush_tid(struct ceph_mds_client *mdsc);\nstatic void __kick_flushing_caps(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_session *session,\n\t\t\t\t struct ceph_inode_info *ci,\n\t\t\t\t u64 oldest_flush_tid);\n\n \n#define MAX_CAP_STR 20\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nstatic char *gcap_string(char *s, int c)\n{\n\tif (c & CEPH_CAP_GSHARED)\n\t\t*s++ = 's';\n\tif (c & CEPH_CAP_GEXCL)\n\t\t*s++ = 'x';\n\tif (c & CEPH_CAP_GCACHE)\n\t\t*s++ = 'c';\n\tif (c & CEPH_CAP_GRD)\n\t\t*s++ = 'r';\n\tif (c & CEPH_CAP_GWR)\n\t\t*s++ = 'w';\n\tif (c & CEPH_CAP_GBUFFER)\n\t\t*s++ = 'b';\n\tif (c & CEPH_CAP_GWREXTEND)\n\t\t*s++ = 'a';\n\tif (c & CEPH_CAP_GLAZYIO)\n\t\t*s++ = 'l';\n\treturn s;\n}\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}\n\nvoid ceph_caps_init(struct ceph_mds_client *mdsc)\n{\n\tINIT_LIST_HEAD(&mdsc->caps_list);\n\tspin_lock_init(&mdsc->caps_list_lock);\n}\n\nvoid ceph_caps_finalize(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_cap *cap;\n\n\tspin_lock(&mdsc->caps_list_lock);\n\twhile (!list_empty(&mdsc->caps_list)) {\n\t\tcap = list_first_entry(&mdsc->caps_list,\n\t\t\t\t       struct ceph_cap, caps_item);\n\t\tlist_del(&cap->caps_item);\n\t\tkmem_cache_free(ceph_cap_cachep, cap);\n\t}\n\tmdsc->caps_total_count = 0;\n\tmdsc->caps_avail_count = 0;\n\tmdsc->caps_use_count = 0;\n\tmdsc->caps_reserve_count = 0;\n\tmdsc->caps_min_count = 0;\n\tspin_unlock(&mdsc->caps_list_lock);\n}\n\nvoid ceph_adjust_caps_max_min(struct ceph_mds_client *mdsc,\n\t\t\t      struct ceph_mount_options *fsopt)\n{\n\tspin_lock(&mdsc->caps_list_lock);\n\tmdsc->caps_min_count = fsopt->max_readdir;\n\tif (mdsc->caps_min_count < 1024)\n\t\tmdsc->caps_min_count = 1024;\n\tmdsc->caps_use_max = fsopt->caps_max;\n\tif (mdsc->caps_use_max > 0 &&\n\t    mdsc->caps_use_max < mdsc->caps_min_count)\n\t\tmdsc->caps_use_max = mdsc->caps_min_count;\n\tspin_unlock(&mdsc->caps_list_lock);\n}\n\nstatic void __ceph_unreserve_caps(struct ceph_mds_client *mdsc, int nr_caps)\n{\n\tstruct ceph_cap *cap;\n\tint i;\n\n\tif (nr_caps) {\n\t\tBUG_ON(mdsc->caps_reserve_count < nr_caps);\n\t\tmdsc->caps_reserve_count -= nr_caps;\n\t\tif (mdsc->caps_avail_count >=\n\t\t    mdsc->caps_reserve_count + mdsc->caps_min_count) {\n\t\t\tmdsc->caps_total_count -= nr_caps;\n\t\t\tfor (i = 0; i < nr_caps; i++) {\n\t\t\t\tcap = list_first_entry(&mdsc->caps_list,\n\t\t\t\t\tstruct ceph_cap, caps_item);\n\t\t\t\tlist_del(&cap->caps_item);\n\t\t\t\tkmem_cache_free(ceph_cap_cachep, cap);\n\t\t\t}\n\t\t} else {\n\t\t\tmdsc->caps_avail_count += nr_caps;\n\t\t}\n\n\t\tdout(\"%s: caps %d = %d used + %d resv + %d avail\\n\",\n\t\t     __func__,\n\t\t     mdsc->caps_total_count, mdsc->caps_use_count,\n\t\t     mdsc->caps_reserve_count, mdsc->caps_avail_count);\n\t\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t\t mdsc->caps_avail_count);\n\t}\n}\n\n \nint ceph_reserve_caps(struct ceph_mds_client *mdsc,\n\t\t      struct ceph_cap_reservation *ctx, int need)\n{\n\tint i, j;\n\tstruct ceph_cap *cap;\n\tint have;\n\tint alloc = 0;\n\tint max_caps;\n\tint err = 0;\n\tbool trimmed = false;\n\tstruct ceph_mds_session *s;\n\tLIST_HEAD(newcaps);\n\n\tdout(\"reserve caps ctx=%p need=%d\\n\", ctx, need);\n\n\t \n\tspin_lock(&mdsc->caps_list_lock);\n\tif (mdsc->caps_avail_count >= need)\n\t\thave = need;\n\telse\n\t\thave = mdsc->caps_avail_count;\n\tmdsc->caps_avail_count -= have;\n\tmdsc->caps_reserve_count += have;\n\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t mdsc->caps_avail_count);\n\tspin_unlock(&mdsc->caps_list_lock);\n\n\tfor (i = have; i < need; ) {\n\t\tcap = kmem_cache_alloc(ceph_cap_cachep, GFP_NOFS);\n\t\tif (cap) {\n\t\t\tlist_add(&cap->caps_item, &newcaps);\n\t\t\talloc++;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!trimmed) {\n\t\t\tfor (j = 0; j < mdsc->max_sessions; j++) {\n\t\t\t\ts = __ceph_lookup_mds_session(mdsc, j);\n\t\t\t\tif (!s)\n\t\t\t\t\tcontinue;\n\t\t\t\tmutex_unlock(&mdsc->mutex);\n\n\t\t\t\tmutex_lock(&s->s_mutex);\n\t\t\t\tmax_caps = s->s_nr_caps - (need - i);\n\t\t\t\tceph_trim_caps(mdsc, s, max_caps);\n\t\t\t\tmutex_unlock(&s->s_mutex);\n\n\t\t\t\tceph_put_mds_session(s);\n\t\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\t}\n\t\t\ttrimmed = true;\n\n\t\t\tspin_lock(&mdsc->caps_list_lock);\n\t\t\tif (mdsc->caps_avail_count) {\n\t\t\t\tint more_have;\n\t\t\t\tif (mdsc->caps_avail_count >= need - i)\n\t\t\t\t\tmore_have = need - i;\n\t\t\t\telse\n\t\t\t\t\tmore_have = mdsc->caps_avail_count;\n\n\t\t\t\ti += more_have;\n\t\t\t\thave += more_have;\n\t\t\t\tmdsc->caps_avail_count -= more_have;\n\t\t\t\tmdsc->caps_reserve_count += more_have;\n\n\t\t\t}\n\t\t\tspin_unlock(&mdsc->caps_list_lock);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_warn(\"reserve caps ctx=%p ENOMEM need=%d got=%d\\n\",\n\t\t\tctx, need, have + alloc);\n\t\terr = -ENOMEM;\n\t\tbreak;\n\t}\n\n\tif (!err) {\n\t\tBUG_ON(have + alloc != need);\n\t\tctx->count = need;\n\t\tctx->used = 0;\n\t}\n\n\tspin_lock(&mdsc->caps_list_lock);\n\tmdsc->caps_total_count += alloc;\n\tmdsc->caps_reserve_count += alloc;\n\tlist_splice(&newcaps, &mdsc->caps_list);\n\n\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t mdsc->caps_avail_count);\n\n\tif (err)\n\t\t__ceph_unreserve_caps(mdsc, have + alloc);\n\n\tspin_unlock(&mdsc->caps_list_lock);\n\n\tdout(\"reserve caps ctx=%p %d = %d used + %d resv + %d avail\\n\",\n\t     ctx, mdsc->caps_total_count, mdsc->caps_use_count,\n\t     mdsc->caps_reserve_count, mdsc->caps_avail_count);\n\treturn err;\n}\n\nvoid ceph_unreserve_caps(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_cap_reservation *ctx)\n{\n\tbool reclaim = false;\n\tif (!ctx->count)\n\t\treturn;\n\n\tdout(\"unreserve caps ctx=%p count=%d\\n\", ctx, ctx->count);\n\tspin_lock(&mdsc->caps_list_lock);\n\t__ceph_unreserve_caps(mdsc, ctx->count);\n\tctx->count = 0;\n\n\tif (mdsc->caps_use_max > 0 &&\n\t    mdsc->caps_use_count > mdsc->caps_use_max)\n\t\treclaim = true;\n\tspin_unlock(&mdsc->caps_list_lock);\n\n\tif (reclaim)\n\t\tceph_reclaim_caps_nr(mdsc, ctx->used);\n}\n\nstruct ceph_cap *ceph_get_cap(struct ceph_mds_client *mdsc,\n\t\t\t      struct ceph_cap_reservation *ctx)\n{\n\tstruct ceph_cap *cap = NULL;\n\n\t \n\tif (!ctx) {\n\t\tcap = kmem_cache_alloc(ceph_cap_cachep, GFP_NOFS);\n\t\tif (cap) {\n\t\t\tspin_lock(&mdsc->caps_list_lock);\n\t\t\tmdsc->caps_use_count++;\n\t\t\tmdsc->caps_total_count++;\n\t\t\tspin_unlock(&mdsc->caps_list_lock);\n\t\t} else {\n\t\t\tspin_lock(&mdsc->caps_list_lock);\n\t\t\tif (mdsc->caps_avail_count) {\n\t\t\t\tBUG_ON(list_empty(&mdsc->caps_list));\n\n\t\t\t\tmdsc->caps_avail_count--;\n\t\t\t\tmdsc->caps_use_count++;\n\t\t\t\tcap = list_first_entry(&mdsc->caps_list,\n\t\t\t\t\t\tstruct ceph_cap, caps_item);\n\t\t\t\tlist_del(&cap->caps_item);\n\n\t\t\t\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t       mdsc->caps_reserve_count + mdsc->caps_avail_count);\n\t\t\t}\n\t\t\tspin_unlock(&mdsc->caps_list_lock);\n\t\t}\n\n\t\treturn cap;\n\t}\n\n\tspin_lock(&mdsc->caps_list_lock);\n\tdout(\"get_cap ctx=%p (%d) %d = %d used + %d resv + %d avail\\n\",\n\t     ctx, ctx->count, mdsc->caps_total_count, mdsc->caps_use_count,\n\t     mdsc->caps_reserve_count, mdsc->caps_avail_count);\n\tBUG_ON(!ctx->count);\n\tBUG_ON(ctx->count > mdsc->caps_reserve_count);\n\tBUG_ON(list_empty(&mdsc->caps_list));\n\n\tctx->count--;\n\tctx->used++;\n\tmdsc->caps_reserve_count--;\n\tmdsc->caps_use_count++;\n\n\tcap = list_first_entry(&mdsc->caps_list, struct ceph_cap, caps_item);\n\tlist_del(&cap->caps_item);\n\n\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t       mdsc->caps_reserve_count + mdsc->caps_avail_count);\n\tspin_unlock(&mdsc->caps_list_lock);\n\treturn cap;\n}\n\nvoid ceph_put_cap(struct ceph_mds_client *mdsc, struct ceph_cap *cap)\n{\n\tspin_lock(&mdsc->caps_list_lock);\n\tdout(\"put_cap %p %d = %d used + %d resv + %d avail\\n\",\n\t     cap, mdsc->caps_total_count, mdsc->caps_use_count,\n\t     mdsc->caps_reserve_count, mdsc->caps_avail_count);\n\tmdsc->caps_use_count--;\n\t \n\tif (mdsc->caps_avail_count >= mdsc->caps_reserve_count +\n\t\t\t\t      mdsc->caps_min_count) {\n\t\tmdsc->caps_total_count--;\n\t\tkmem_cache_free(ceph_cap_cachep, cap);\n\t} else {\n\t\tmdsc->caps_avail_count++;\n\t\tlist_add(&cap->caps_item, &mdsc->caps_list);\n\t}\n\n\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t       mdsc->caps_reserve_count + mdsc->caps_avail_count);\n\tspin_unlock(&mdsc->caps_list_lock);\n}\n\nvoid ceph_reservation_status(struct ceph_fs_client *fsc,\n\t\t\t     int *total, int *avail, int *used, int *reserved,\n\t\t\t     int *min)\n{\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\n\tspin_lock(&mdsc->caps_list_lock);\n\n\tif (total)\n\t\t*total = mdsc->caps_total_count;\n\tif (avail)\n\t\t*avail = mdsc->caps_avail_count;\n\tif (used)\n\t\t*used = mdsc->caps_use_count;\n\tif (reserved)\n\t\t*reserved = mdsc->caps_reserve_count;\n\tif (min)\n\t\t*min = mdsc->caps_min_count;\n\n\tspin_unlock(&mdsc->caps_list_lock);\n}\n\n \nstruct ceph_cap *__get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *n = ci->i_caps.rb_node;\n\n\twhile (n) {\n\t\tcap = rb_entry(n, struct ceph_cap, ci_node);\n\t\tif (mds < cap->mds)\n\t\t\tn = n->rb_left;\n\t\telse if (mds > cap->mds)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn cap;\n\t}\n\treturn NULL;\n}\n\nstruct ceph_cap *ceph_get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ci, mds);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn cap;\n}\n\n \nstatic void __insert_cap_node(struct ceph_inode_info *ci,\n\t\t\t      struct ceph_cap *new)\n{\n\tstruct rb_node **p = &ci->i_caps.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_cap *cap = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tcap = rb_entry(parent, struct ceph_cap, ci_node);\n\t\tif (new->mds < cap->mds)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->mds > cap->mds)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&new->ci_node, parent, p);\n\trb_insert_color(&new->ci_node, &ci->i_caps);\n}\n\n \nstatic void __cap_set_timeouts(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_inode_info *ci)\n{\n\tstruct ceph_mount_options *opt = mdsc->fsc->mount_options;\n\tci->i_hold_caps_max = round_jiffies(jiffies +\n\t\t\t\t\t    opt->caps_wanted_delay_max * HZ);\n\tdout(\"__cap_set_timeouts %p %lu\\n\", &ci->netfs.inode,\n\t     ci->i_hold_caps_max - jiffies);\n}\n\n \nstatic void __cap_delay_requeue(struct ceph_mds_client *mdsc,\n\t\t\t\tstruct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_requeue %p flags 0x%lx at %lu\\n\", &ci->netfs.inode,\n\t     ci->i_ceph_flags, ci->i_hold_caps_max);\n\tif (!mdsc->stopping) {\n\t\tspin_lock(&mdsc->cap_delay_lock);\n\t\tif (!list_empty(&ci->i_cap_delay_list)) {\n\t\t\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\t\t\tgoto no_change;\n\t\t\tlist_del_init(&ci->i_cap_delay_list);\n\t\t}\n\t\t__cap_set_timeouts(mdsc, ci);\n\t\tlist_add_tail(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\nno_change:\n\t\tspin_unlock(&mdsc->cap_delay_lock);\n\t}\n}\n\n \nstatic void __cap_delay_requeue_front(struct ceph_mds_client *mdsc,\n\t\t\t\t      struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_requeue_front %p\\n\", &ci->netfs.inode);\n\tspin_lock(&mdsc->cap_delay_lock);\n\tci->i_ceph_flags |= CEPH_I_FLUSH;\n\tif (!list_empty(&ci->i_cap_delay_list))\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\tlist_add(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}\n\n \nstatic void __cap_delay_cancel(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_cancel %p\\n\", &ci->netfs.inode);\n\tif (list_empty(&ci->i_cap_delay_list))\n\t\treturn;\n\tspin_lock(&mdsc->cap_delay_lock);\n\tlist_del_init(&ci->i_cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}\n\n \nstatic void __check_cap_issue(struct ceph_inode_info *ci, struct ceph_cap *cap,\n\t\t\t      unsigned issued)\n{\n\tunsigned had = __ceph_caps_issued(ci, NULL);\n\n\tlockdep_assert_held(&ci->i_ceph_lock);\n\n\t \n\tif (S_ISREG(ci->netfs.inode.i_mode) &&\n\t    (issued & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    (had & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) == 0) {\n\t\tci->i_rdcache_gen++;\n\t}\n\n\t \n\tif ((issued & CEPH_CAP_FILE_SHARED) != (had & CEPH_CAP_FILE_SHARED)) {\n\t\tif (issued & CEPH_CAP_FILE_SHARED)\n\t\t\tatomic_inc(&ci->i_shared_gen);\n\t\tif (S_ISDIR(ci->netfs.inode.i_mode)) {\n\t\t\tdout(\" marking %p NOT complete\\n\", &ci->netfs.inode);\n\t\t\t__ceph_dir_clear_complete(ci);\n\t\t}\n\t}\n\n\t \n\tif (S_ISDIR(ci->netfs.inode.i_mode) && (had & CEPH_CAP_DIR_CREATE) &&\n\t\t!(issued & CEPH_CAP_DIR_CREATE)) {\n\t     ceph_put_string(rcu_dereference_raw(ci->i_cached_layout.pool_ns));\n\t     memset(&ci->i_cached_layout, 0, sizeof(ci->i_cached_layout));\n\t}\n}\n\n \nvoid change_auth_cap_ses(struct ceph_inode_info *ci,\n\t\t\t struct ceph_mds_session *session)\n{\n\tlockdep_assert_held(&ci->i_ceph_lock);\n\n\tif (list_empty(&ci->i_dirty_item) && list_empty(&ci->i_flushing_item))\n\t\treturn;\n\n\tspin_lock(&session->s_mdsc->cap_dirty_lock);\n\tif (!list_empty(&ci->i_dirty_item))\n\t\tlist_move(&ci->i_dirty_item, &session->s_cap_dirty);\n\tif (!list_empty(&ci->i_flushing_item))\n\t\tlist_move_tail(&ci->i_flushing_item, &session->s_cap_flushing);\n\tspin_unlock(&session->s_mdsc->cap_dirty_lock);\n}\n\n \nvoid ceph_add_cap(struct inode *inode,\n\t\t  struct ceph_mds_session *session, u64 cap_id,\n\t\t  unsigned issued, unsigned wanted,\n\t\t  unsigned seq, unsigned mseq, u64 realmino, int flags,\n\t\t  struct ceph_cap **new_cap)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tint mds = session->s_mds;\n\tint actual_wanted;\n\tu32 gen;\n\n\tlockdep_assert_held(&ci->i_ceph_lock);\n\n\tdout(\"add_cap %p mds%d cap %llx %s seq %d\\n\", inode,\n\t     session->s_mds, cap_id, ceph_cap_string(issued), seq);\n\n\tgen = atomic_read(&session->s_cap_gen);\n\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap) {\n\t\tcap = *new_cap;\n\t\t*new_cap = NULL;\n\n\t\tcap->issued = 0;\n\t\tcap->implemented = 0;\n\t\tcap->mds = mds;\n\t\tcap->mds_wanted = 0;\n\t\tcap->mseq = 0;\n\n\t\tcap->ci = ci;\n\t\t__insert_cap_node(ci, cap);\n\n\t\t \n\t\tcap->session = session;\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add_tail(&cap->session_caps, &session->s_caps);\n\t\tsession->s_nr_caps++;\n\t\tatomic64_inc(&mdsc->metric.total_caps);\n\t\tspin_unlock(&session->s_cap_lock);\n\t} else {\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_move_tail(&cap->session_caps, &session->s_caps);\n\t\tspin_unlock(&session->s_cap_lock);\n\n\t\tif (cap->cap_gen < gen)\n\t\t\tcap->issued = cap->implemented = CEPH_CAP_PIN;\n\n\t\t \n\t\tif (ceph_seq_cmp(seq, cap->seq) <= 0) {\n\t\t\tWARN_ON(cap != ci->i_auth_cap);\n\t\t\tWARN_ON(cap->cap_id != cap_id);\n\t\t\tseq = cap->seq;\n\t\t\tmseq = cap->mseq;\n\t\t\tissued |= cap->issued;\n\t\t\tflags |= CEPH_CAP_FLAG_AUTH;\n\t\t}\n\t}\n\n\tif (!ci->i_snap_realm ||\n\t    ((flags & CEPH_CAP_FLAG_AUTH) &&\n\t     realmino != (u64)-1 && ci->i_snap_realm->ino != realmino)) {\n\t\t \n\t\tstruct ceph_snap_realm *realm = ceph_lookup_snap_realm(mdsc,\n\t\t\t\t\t\t\t       realmino);\n\t\tif (realm)\n\t\t\tceph_change_snap_realm(inode, realm);\n\t\telse\n\t\t\tWARN(1, \"%s: couldn't find snap realm 0x%llx (ino 0x%llx oldrealm 0x%llx)\\n\",\n\t\t\t     __func__, realmino, ci->i_vino.ino,\n\t\t\t     ci->i_snap_realm ? ci->i_snap_realm->ino : 0);\n\t}\n\n\t__check_cap_issue(ci, cap, issued);\n\n\t \n\tactual_wanted = __ceph_caps_wanted(ci);\n\tif ((wanted & ~actual_wanted) ||\n\t    (issued & ~actual_wanted & CEPH_CAP_ANY_WR)) {\n\t\tdout(\" issued %s, mds wanted %s, actual %s, queueing\\n\",\n\t\t     ceph_cap_string(issued), ceph_cap_string(wanted),\n\t\t     ceph_cap_string(actual_wanted));\n\t\t__cap_delay_requeue(mdsc, ci);\n\t}\n\n\tif (flags & CEPH_CAP_FLAG_AUTH) {\n\t\tif (!ci->i_auth_cap ||\n\t\t    ceph_seq_cmp(ci->i_auth_cap->mseq, mseq) < 0) {\n\t\t\tif (ci->i_auth_cap &&\n\t\t\t    ci->i_auth_cap->session != cap->session)\n\t\t\t\tchange_auth_cap_ses(ci, cap->session);\n\t\t\tci->i_auth_cap = cap;\n\t\t\tcap->mds_wanted = wanted;\n\t\t}\n\t} else {\n\t\tWARN_ON(ci->i_auth_cap == cap);\n\t}\n\n\tdout(\"add_cap inode %p (%llx.%llx) cap %p %s now %s seq %d mds%d\\n\",\n\t     inode, ceph_vinop(inode), cap, ceph_cap_string(issued),\n\t     ceph_cap_string(issued|cap->issued), seq, mds);\n\tcap->cap_id = cap_id;\n\tcap->issued = issued;\n\tcap->implemented |= issued;\n\tif (ceph_seq_cmp(mseq, cap->mseq) > 0)\n\t\tcap->mds_wanted = wanted;\n\telse\n\t\tcap->mds_wanted |= wanted;\n\tcap->seq = seq;\n\tcap->issue_seq = seq;\n\tcap->mseq = mseq;\n\tcap->cap_gen = gen;\n\twake_up_all(&ci->i_cap_wq);\n}\n\n \nstatic int __cap_is_valid(struct ceph_cap *cap)\n{\n\tunsigned long ttl;\n\tu32 gen;\n\n\tgen = atomic_read(&cap->session->s_cap_gen);\n\tttl = cap->session->s_cap_ttl;\n\n\tif (cap->cap_gen < gen || time_after_eq(jiffies, ttl)) {\n\t\tdout(\"__cap_is_valid %p cap %p issued %s \"\n\t\t     \"but STALE (gen %u vs %u)\\n\", &cap->ci->netfs.inode,\n\t\t     cap, ceph_cap_string(cap->issued), cap->cap_gen, gen);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nint __ceph_caps_issued(struct ceph_inode_info *ci, int *implemented)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tif (implemented)\n\t\t*implemented = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\tdout(\"__ceph_caps_issued %p cap %p issued %s\\n\",\n\t\t     &ci->netfs.inode, cap, ceph_cap_string(cap->issued));\n\t\thave |= cap->issued;\n\t\tif (implemented)\n\t\t\t*implemented |= cap->implemented;\n\t}\n\t \n\tif (ci->i_auth_cap) {\n\t\tcap = ci->i_auth_cap;\n\t\thave &= ~cap->implemented | cap->issued;\n\t}\n\treturn have;\n}\n\n \nint __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}\n\n \nstatic void __touch_cap(struct ceph_cap *cap)\n{\n\tstruct ceph_mds_session *s = cap->session;\n\n\tspin_lock(&s->s_cap_lock);\n\tif (!s->s_cap_iterator) {\n\t\tdout(\"__touch_cap %p cap %p mds%d\\n\", &cap->ci->netfs.inode, cap,\n\t\t     s->s_mds);\n\t\tlist_move_tail(&cap->session_caps, &s->s_caps);\n\t} else {\n\t\tdout(\"__touch_cap %p cap %p mds%d NOP, iterating over caps\\n\",\n\t\t     &cap->ci->netfs.inode, cap, s->s_mds);\n\t}\n\tspin_unlock(&s->s_cap_lock);\n}\n\n \nint __ceph_caps_issued_mask(struct ceph_inode_info *ci, int mask, int touch)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\tint have = ci->i_snap_caps;\n\n\tif ((have & mask) == mask) {\n\t\tdout(\"__ceph_caps_issued_mask ino 0x%llx snap issued %s\"\n\t\t     \" (mask %s)\\n\", ceph_ino(&ci->netfs.inode),\n\t\t     ceph_cap_string(have),\n\t\t     ceph_cap_string(mask));\n\t\treturn 1;\n\t}\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\tif ((cap->issued & mask) == mask) {\n\t\t\tdout(\"__ceph_caps_issued_mask ino 0x%llx cap %p issued %s\"\n\t\t\t     \" (mask %s)\\n\", ceph_ino(&ci->netfs.inode), cap,\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(mask));\n\t\t\tif (touch)\n\t\t\t\t__touch_cap(cap);\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\thave |= cap->issued;\n\t\tif ((have & mask) == mask) {\n\t\t\tdout(\"__ceph_caps_issued_mask ino 0x%llx combo issued %s\"\n\t\t\t     \" (mask %s)\\n\", ceph_ino(&ci->netfs.inode),\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(mask));\n\t\t\tif (touch) {\n\t\t\t\tstruct rb_node *q;\n\n\t\t\t\t \n\t\t\t\t__touch_cap(cap);\n\t\t\t\tfor (q = rb_first(&ci->i_caps); q != p;\n\t\t\t\t     q = rb_next(q)) {\n\t\t\t\t\tcap = rb_entry(q, struct ceph_cap,\n\t\t\t\t\t\t       ci_node);\n\t\t\t\t\tif (!__cap_is_valid(cap))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (cap->issued & mask)\n\t\t\t\t\t\t__touch_cap(cap);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint __ceph_caps_issued_mask_metric(struct ceph_inode_info *ci, int mask,\n\t\t\t\t   int touch)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(ci->netfs.inode.i_sb);\n\tint r;\n\n\tr = __ceph_caps_issued_mask(ci, mask, touch);\n\tif (r)\n\t\tceph_update_cap_hit(&fsc->mdsc->metric);\n\telse\n\t\tceph_update_cap_mis(&fsc->mdsc->metric);\n\treturn r;\n}\n\n \nint __ceph_caps_revoking_other(struct ceph_inode_info *ci,\n\t\t\t       struct ceph_cap *ocap, int mask)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap != ocap &&\n\t\t    (cap->implemented & ~cap->issued & mask))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint ceph_caps_revoking(struct ceph_inode_info *ci, int mask)\n{\n\tstruct inode *inode = &ci->netfs.inode;\n\tint ret;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tret = __ceph_caps_revoking_other(ci, NULL, mask);\n\tspin_unlock(&ci->i_ceph_lock);\n\tdout(\"ceph_caps_revoking %p %s = %d\\n\", inode,\n\t     ceph_cap_string(mask), ret);\n\treturn ret;\n}\n\nint __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref ||\n\t    (S_ISREG(ci->netfs.inode.i_mode) &&\n\t     ci->netfs.inode.i_data.nrpages))\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\tif (ci->i_fx_ref)\n\t\tused |= CEPH_CAP_FILE_EXCL;\n\treturn used;\n}\n\n#define FMODE_WAIT_BIAS 1000\n\n \nint __ceph_caps_file_wanted(struct ceph_inode_info *ci)\n{\n\tconst int PIN_SHIFT = ffs(CEPH_FILE_MODE_PIN);\n\tconst int RD_SHIFT = ffs(CEPH_FILE_MODE_RD);\n\tconst int WR_SHIFT = ffs(CEPH_FILE_MODE_WR);\n\tconst int LAZY_SHIFT = ffs(CEPH_FILE_MODE_LAZY);\n\tstruct ceph_mount_options *opt =\n\t\tceph_inode_to_client(&ci->netfs.inode)->mount_options;\n\tunsigned long used_cutoff = jiffies - opt->caps_wanted_delay_max * HZ;\n\tunsigned long idle_cutoff = jiffies - opt->caps_wanted_delay_min * HZ;\n\n\tif (S_ISDIR(ci->netfs.inode.i_mode)) {\n\t\tint want = 0;\n\n\t\t \n\t\tif (ci->i_nr_by_mode[RD_SHIFT] > 0 ||\n\t\t    time_after(ci->i_last_rd, used_cutoff))\n\t\t\twant |= CEPH_CAP_ANY_SHARED;\n\n\t\tif (ci->i_nr_by_mode[WR_SHIFT] > 0 ||\n\t\t    time_after(ci->i_last_wr, used_cutoff)) {\n\t\t\twant |= CEPH_CAP_ANY_SHARED | CEPH_CAP_FILE_EXCL;\n\t\t\tif (opt->flags & CEPH_MOUNT_OPT_ASYNC_DIROPS)\n\t\t\t\twant |= CEPH_CAP_ANY_DIR_OPS;\n\t\t}\n\n\t\tif (want || ci->i_nr_by_mode[PIN_SHIFT] > 0)\n\t\t\twant |= CEPH_CAP_PIN;\n\n\t\treturn want;\n\t} else {\n\t\tint bits = 0;\n\n\t\tif (ci->i_nr_by_mode[RD_SHIFT] > 0) {\n\t\t\tif (ci->i_nr_by_mode[RD_SHIFT] >= FMODE_WAIT_BIAS ||\n\t\t\t    time_after(ci->i_last_rd, used_cutoff))\n\t\t\t\tbits |= 1 << RD_SHIFT;\n\t\t} else if (time_after(ci->i_last_rd, idle_cutoff)) {\n\t\t\tbits |= 1 << RD_SHIFT;\n\t\t}\n\n\t\tif (ci->i_nr_by_mode[WR_SHIFT] > 0) {\n\t\t\tif (ci->i_nr_by_mode[WR_SHIFT] >= FMODE_WAIT_BIAS ||\n\t\t\t    time_after(ci->i_last_wr, used_cutoff))\n\t\t\t\tbits |= 1 << WR_SHIFT;\n\t\t} else if (time_after(ci->i_last_wr, idle_cutoff)) {\n\t\t\tbits |= 1 << WR_SHIFT;\n\t\t}\n\n\t\t \n\t\tif ((bits & (CEPH_FILE_MODE_RDWR << 1)) &&\n\t\t    ci->i_nr_by_mode[LAZY_SHIFT] > 0)\n\t\t\tbits |= 1 << LAZY_SHIFT;\n\n\t\treturn bits ? ceph_caps_for_mode(bits >> 1) : 0;\n\t}\n}\n\n \nint __ceph_caps_wanted(struct ceph_inode_info *ci)\n{\n\tint w = __ceph_caps_file_wanted(ci) | __ceph_caps_used(ci);\n\tif (S_ISDIR(ci->netfs.inode.i_mode)) {\n\t\t \n\t\tif (w & CEPH_CAP_ANY_DIR_OPS)\n\t\t\tw |= CEPH_CAP_FILE_EXCL;\n\t} else {\n\t\t \n\t\tif (w & CEPH_CAP_FILE_BUFFER)\n\t\t\tw |= CEPH_CAP_FILE_EXCL;\n\t}\n\treturn w;\n}\n\n \nint __ceph_caps_mds_wanted(struct ceph_inode_info *ci, bool check)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\tint mds_wanted = 0;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (check && !__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\tif (cap == ci->i_auth_cap)\n\t\t\tmds_wanted |= cap->mds_wanted;\n\t\telse\n\t\t\tmds_wanted |= (cap->mds_wanted & ~CEPH_CAP_ANY_FILE_WR);\n\t}\n\treturn mds_wanted;\n}\n\nint ceph_is_any_caps(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tret = __ceph_is_any_real_caps(ci);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\treturn ret;\n}\n\n \nvoid __ceph_remove_cap(struct ceph_cap *cap, bool queue_release)\n{\n\tstruct ceph_mds_session *session = cap->session;\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct ceph_mds_client *mdsc;\n\tint removed = 0;\n\n\t \n\tif (!ci) {\n\t\tdout(\"%s: cap inode is NULL\\n\", __func__);\n\t\treturn;\n\t}\n\n\tlockdep_assert_held(&ci->i_ceph_lock);\n\n\tdout(\"__ceph_remove_cap %p from %p\\n\", cap, &ci->netfs.inode);\n\n\tmdsc = ceph_inode_to_client(&ci->netfs.inode)->mdsc;\n\n\t \n\trb_erase(&cap->ci_node, &ci->i_caps);\n\tif (ci->i_auth_cap == cap)\n\t\tci->i_auth_cap = NULL;\n\n\t \n\tspin_lock(&session->s_cap_lock);\n\tif (session->s_cap_iterator == cap) {\n\t\t \n\t\tdout(\"__ceph_remove_cap  delaying %p removal from session %p\\n\",\n\t\t     cap, cap->session);\n\t} else {\n\t\tlist_del_init(&cap->session_caps);\n\t\tsession->s_nr_caps--;\n\t\tatomic64_dec(&mdsc->metric.total_caps);\n\t\tcap->session = NULL;\n\t\tremoved = 1;\n\t}\n\t \n\tcap->ci = NULL;\n\n\t \n\tif (queue_release &&\n\t    (!session->s_cap_reconnect ||\n\t     cap->cap_gen == atomic_read(&session->s_cap_gen))) {\n\t\tcap->queue_release = 1;\n\t\tif (removed) {\n\t\t\t__ceph_queue_cap_release(session, cap);\n\t\t\tremoved = 0;\n\t\t}\n\t} else {\n\t\tcap->queue_release = 0;\n\t}\n\tcap->cap_ino = ci->i_vino.ino;\n\n\tspin_unlock(&session->s_cap_lock);\n\n\tif (removed)\n\t\tceph_put_cap(mdsc, cap);\n\n\tif (!__ceph_is_any_real_caps(ci)) {\n\t\t \n\t\tif (ci->i_wr_ref == 0 && ci->i_snap_realm)\n\t\t\tceph_change_snap_realm(&ci->netfs.inode, NULL);\n\n\t\t__cap_delay_cancel(mdsc, ci);\n\t}\n}\n\nvoid ceph_remove_cap(struct ceph_cap *cap, bool queue_release)\n{\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct ceph_fs_client *fsc;\n\n\t \n\tif (!ci) {\n\t\tdout(\"%s: cap inode is NULL\\n\", __func__);\n\t\treturn;\n\t}\n\n\tlockdep_assert_held(&ci->i_ceph_lock);\n\n\tfsc = ceph_inode_to_client(&ci->netfs.inode);\n\tWARN_ON_ONCE(ci->i_auth_cap == cap &&\n\t\t     !list_empty(&ci->i_dirty_item) &&\n\t\t     !fsc->blocklisted &&\n\t\t     !ceph_inode_is_shutdown(&ci->netfs.inode));\n\n\t__ceph_remove_cap(cap, queue_release);\n}\n\nstruct cap_msg_args {\n\tstruct ceph_mds_session\t*session;\n\tu64\t\t\tino, cid, follows;\n\tu64\t\t\tflush_tid, oldest_flush_tid, size, max_size;\n\tu64\t\t\txattr_version;\n\tu64\t\t\tchange_attr;\n\tstruct ceph_buffer\t*xattr_buf;\n\tstruct ceph_buffer\t*old_xattr_buf;\n\tstruct timespec64\tatime, mtime, ctime, btime;\n\tint\t\t\top, caps, wanted, dirty;\n\tu32\t\t\tseq, issue_seq, mseq, time_warp_seq;\n\tu32\t\t\tflags;\n\tkuid_t\t\t\tuid;\n\tkgid_t\t\t\tgid;\n\tumode_t\t\t\tmode;\n\tbool\t\t\tinline_data;\n\tbool\t\t\twake;\n\tbool\t\t\tencrypted;\n\tu32\t\t\tfscrypt_auth_len;\n\tu8\t\t\tfscrypt_auth[sizeof(struct ceph_fscrypt_auth)];  \n};\n\n \nstatic void encode_cap_msg(struct ceph_msg *msg, struct cap_msg_args *arg)\n{\n\tstruct ceph_mds_caps *fc;\n\tvoid *p;\n\tstruct ceph_osd_client *osdc = &arg->session->s_mdsc->fsc->client->osdc;\n\n\tdout(\"%s %s %llx %llx caps %s wanted %s dirty %s seq %u/%u tid %llu/%llu mseq %u follows %lld size %llu/%llu xattr_ver %llu xattr_len %d\\n\",\n\t     __func__, ceph_cap_op_name(arg->op), arg->cid, arg->ino,\n\t     ceph_cap_string(arg->caps), ceph_cap_string(arg->wanted),\n\t     ceph_cap_string(arg->dirty), arg->seq, arg->issue_seq,\n\t     arg->flush_tid, arg->oldest_flush_tid, arg->mseq, arg->follows,\n\t     arg->size, arg->max_size, arg->xattr_version,\n\t     arg->xattr_buf ? (int)arg->xattr_buf->vec.iov_len : 0);\n\n\tmsg->hdr.version = cpu_to_le16(12);\n\tmsg->hdr.tid = cpu_to_le64(arg->flush_tid);\n\n\tfc = msg->front.iov_base;\n\tmemset(fc, 0, sizeof(*fc));\n\n\tfc->cap_id = cpu_to_le64(arg->cid);\n\tfc->op = cpu_to_le32(arg->op);\n\tfc->seq = cpu_to_le32(arg->seq);\n\tfc->issue_seq = cpu_to_le32(arg->issue_seq);\n\tfc->migrate_seq = cpu_to_le32(arg->mseq);\n\tfc->caps = cpu_to_le32(arg->caps);\n\tfc->wanted = cpu_to_le32(arg->wanted);\n\tfc->dirty = cpu_to_le32(arg->dirty);\n\tfc->ino = cpu_to_le64(arg->ino);\n\tfc->snap_follows = cpu_to_le64(arg->follows);\n\n#if IS_ENABLED(CONFIG_FS_ENCRYPTION)\n\tif (arg->encrypted)\n\t\tfc->size = cpu_to_le64(round_up(arg->size,\n\t\t\t\t\t\tCEPH_FSCRYPT_BLOCK_SIZE));\n\telse\n#endif\n\t\tfc->size = cpu_to_le64(arg->size);\n\tfc->max_size = cpu_to_le64(arg->max_size);\n\tceph_encode_timespec64(&fc->mtime, &arg->mtime);\n\tceph_encode_timespec64(&fc->atime, &arg->atime);\n\tceph_encode_timespec64(&fc->ctime, &arg->ctime);\n\tfc->time_warp_seq = cpu_to_le32(arg->time_warp_seq);\n\n\tfc->uid = cpu_to_le32(from_kuid(&init_user_ns, arg->uid));\n\tfc->gid = cpu_to_le32(from_kgid(&init_user_ns, arg->gid));\n\tfc->mode = cpu_to_le32(arg->mode);\n\n\tfc->xattr_version = cpu_to_le64(arg->xattr_version);\n\tif (arg->xattr_buf) {\n\t\tmsg->middle = ceph_buffer_get(arg->xattr_buf);\n\t\tfc->xattr_len = cpu_to_le32(arg->xattr_buf->vec.iov_len);\n\t\tmsg->hdr.middle_len = cpu_to_le32(arg->xattr_buf->vec.iov_len);\n\t}\n\n\tp = fc + 1;\n\t \n\tceph_encode_32(&p, 0);\n\t \n\tceph_encode_64(&p, arg->inline_data ? 0 : CEPH_INLINE_NONE);\n\t \n\tceph_encode_32(&p, 0);\n\t \n\tceph_encode_32(&p, READ_ONCE(osdc->epoch_barrier));\n\t \n\tceph_encode_64(&p, arg->oldest_flush_tid);\n\n\t \n\tceph_encode_32(&p, 0);\n\tceph_encode_32(&p, 0);\n\n\t \n\tceph_encode_32(&p, 0);\n\n\t \n\tceph_encode_timespec64(p, &arg->btime);\n\tp += sizeof(struct ceph_timespec);\n\tceph_encode_64(&p, arg->change_attr);\n\n\t \n\tceph_encode_32(&p, arg->flags);\n\n\t \n\tceph_encode_64(&p, 0);\n\tceph_encode_64(&p, 0);\n\n#if IS_ENABLED(CONFIG_FS_ENCRYPTION)\n\t \n\tceph_encode_32(&p, arg->fscrypt_auth_len);\n\tceph_encode_copy(&p, arg->fscrypt_auth, arg->fscrypt_auth_len);\n\tceph_encode_32(&p, sizeof(__le64));\n\tceph_encode_64(&p, arg->size);\n#else  \n\tceph_encode_32(&p, 0);\n\tceph_encode_32(&p, 0);\n#endif  \n}\n\n \nvoid __ceph_remove_caps(struct ceph_inode_info *ci)\n{\n\tstruct rb_node *p;\n\n\t \n\tspin_lock(&ci->i_ceph_lock);\n\tp = rb_first(&ci->i_caps);\n\twhile (p) {\n\t\tstruct ceph_cap *cap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tp = rb_next(p);\n\t\tceph_remove_cap(cap, true);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n}\n\n \nstatic void __prep_cap(struct cap_msg_args *arg, struct ceph_cap *cap,\n\t\t       int op, int flags, int used, int want, int retain,\n\t\t       int flushing, u64 flush_tid, u64 oldest_flush_tid)\n{\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct inode *inode = &ci->netfs.inode;\n\tint held, revoking;\n\n\tlockdep_assert_held(&ci->i_ceph_lock);\n\n\theld = cap->issued | cap->implemented;\n\trevoking = cap->implemented & ~cap->issued;\n\tretain &= ~revoking;\n\n\tdout(\"%s %p cap %p session %p %s -> %s (revoking %s)\\n\",\n\t     __func__, inode, cap, cap->session,\n\t     ceph_cap_string(held), ceph_cap_string(held & retain),\n\t     ceph_cap_string(revoking));\n\tBUG_ON((retain & CEPH_CAP_PIN) == 0);\n\n\tci->i_ceph_flags &= ~CEPH_I_FLUSH;\n\n\tcap->issued &= retain;   \n\t \n\targ->wake = cap->implemented & ~cap->issued;\n\tcap->implemented &= cap->issued | used;\n\tcap->mds_wanted = want;\n\n\targ->session = cap->session;\n\targ->ino = ceph_vino(inode).ino;\n\targ->cid = cap->cap_id;\n\targ->follows = flushing ? ci->i_head_snapc->seq : 0;\n\targ->flush_tid = flush_tid;\n\targ->oldest_flush_tid = oldest_flush_tid;\n\targ->size = i_size_read(inode);\n\tci->i_reported_size = arg->size;\n\targ->max_size = ci->i_wanted_max_size;\n\tif (cap == ci->i_auth_cap) {\n\t\tif (want & CEPH_CAP_ANY_FILE_WR)\n\t\t\tci->i_requested_max_size = arg->max_size;\n\t\telse\n\t\t\tci->i_requested_max_size = 0;\n\t}\n\n\tif (flushing & CEPH_CAP_XATTR_EXCL) {\n\t\targ->old_xattr_buf = __ceph_build_xattrs_blob(ci);\n\t\targ->xattr_version = ci->i_xattrs.version;\n\t\targ->xattr_buf = ci->i_xattrs.blob;\n\t} else {\n\t\targ->xattr_buf = NULL;\n\t\targ->old_xattr_buf = NULL;\n\t}\n\n\targ->mtime = inode->i_mtime;\n\targ->atime = inode->i_atime;\n\targ->ctime = inode_get_ctime(inode);\n\targ->btime = ci->i_btime;\n\targ->change_attr = inode_peek_iversion_raw(inode);\n\n\targ->op = op;\n\targ->caps = cap->implemented;\n\targ->wanted = want;\n\targ->dirty = flushing;\n\n\targ->seq = cap->seq;\n\targ->issue_seq = cap->issue_seq;\n\targ->mseq = cap->mseq;\n\targ->time_warp_seq = ci->i_time_warp_seq;\n\n\targ->uid = inode->i_uid;\n\targ->gid = inode->i_gid;\n\targ->mode = inode->i_mode;\n\n\targ->inline_data = ci->i_inline_version != CEPH_INLINE_NONE;\n\tif (!(flags & CEPH_CLIENT_CAPS_PENDING_CAPSNAP) &&\n\t    !list_empty(&ci->i_cap_snaps)) {\n\t\tstruct ceph_cap_snap *capsnap;\n\t\tlist_for_each_entry_reverse(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t\tif (capsnap->cap_flush.tid)\n\t\t\t\tbreak;\n\t\t\tif (capsnap->need_flush) {\n\t\t\t\tflags |= CEPH_CLIENT_CAPS_PENDING_CAPSNAP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\targ->flags = flags;\n\targ->encrypted = IS_ENCRYPTED(inode);\n#if IS_ENABLED(CONFIG_FS_ENCRYPTION)\n\tif (ci->fscrypt_auth_len &&\n\t    WARN_ON_ONCE(ci->fscrypt_auth_len > sizeof(struct ceph_fscrypt_auth))) {\n\t\t \n\t\targ->fscrypt_auth_len = 0;\n\t} else {\n\t\targ->fscrypt_auth_len = ci->fscrypt_auth_len;\n\t\tmemcpy(arg->fscrypt_auth, ci->fscrypt_auth,\n\t\t       min_t(size_t, ci->fscrypt_auth_len,\n\t\t\t     sizeof(arg->fscrypt_auth)));\n\t}\n#endif  \n}\n\n#if IS_ENABLED(CONFIG_FS_ENCRYPTION)\n#define CAP_MSG_FIXED_FIELDS (sizeof(struct ceph_mds_caps) + \\\n\t\t      4 + 8 + 4 + 4 + 8 + 4 + 4 + 4 + 8 + 8 + 4 + 8 + 8 + 4 + 4 + 8)\n\nstatic inline int cap_msg_size(struct cap_msg_args *arg)\n{\n\treturn CAP_MSG_FIXED_FIELDS + arg->fscrypt_auth_len;\n}\n#else\n#define CAP_MSG_FIXED_FIELDS (sizeof(struct ceph_mds_caps) + \\\n\t\t      4 + 8 + 4 + 4 + 8 + 4 + 4 + 4 + 8 + 8 + 4 + 8 + 8 + 4 + 4)\n\nstatic inline int cap_msg_size(struct cap_msg_args *arg)\n{\n\treturn CAP_MSG_FIXED_FIELDS;\n}\n#endif  \n\n \nstatic void __send_cap(struct cap_msg_args *arg, struct ceph_inode_info *ci)\n{\n\tstruct ceph_msg *msg;\n\tstruct inode *inode = &ci->netfs.inode;\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPS, cap_msg_size(arg), GFP_NOFS,\n\t\t\t   false);\n\tif (!msg) {\n\t\tpr_err(\"error allocating cap msg: ino (%llx.%llx) flushing %s tid %llu, requeuing cap.\\n\",\n\t\t       ceph_vinop(inode), ceph_cap_string(arg->dirty),\n\t\t       arg->flush_tid);\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\t__cap_delay_requeue(arg->session->s_mdsc, ci);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\treturn;\n\t}\n\n\tencode_cap_msg(msg, arg);\n\tceph_con_send(&arg->session->s_con, msg);\n\tceph_buffer_put(arg->old_xattr_buf);\n\tif (arg->wake)\n\t\twake_up_all(&ci->i_cap_wq);\n}\n\nstatic inline int __send_flush_snap(struct inode *inode,\n\t\t\t\t    struct ceph_mds_session *session,\n\t\t\t\t    struct ceph_cap_snap *capsnap,\n\t\t\t\t    u32 mseq, u64 oldest_flush_tid)\n{\n\tstruct cap_msg_args\targ;\n\tstruct ceph_msg\t\t*msg;\n\n\targ.session = session;\n\targ.ino = ceph_vino(inode).ino;\n\targ.cid = 0;\n\targ.follows = capsnap->follows;\n\targ.flush_tid = capsnap->cap_flush.tid;\n\targ.oldest_flush_tid = oldest_flush_tid;\n\n\targ.size = capsnap->size;\n\targ.max_size = 0;\n\targ.xattr_version = capsnap->xattr_version;\n\targ.xattr_buf = capsnap->xattr_blob;\n\targ.old_xattr_buf = NULL;\n\n\targ.atime = capsnap->atime;\n\targ.mtime = capsnap->mtime;\n\targ.ctime = capsnap->ctime;\n\targ.btime = capsnap->btime;\n\targ.change_attr = capsnap->change_attr;\n\n\targ.op = CEPH_CAP_OP_FLUSHSNAP;\n\targ.caps = capsnap->issued;\n\targ.wanted = 0;\n\targ.dirty = capsnap->dirty;\n\n\targ.seq = 0;\n\targ.issue_seq = 0;\n\targ.mseq = mseq;\n\targ.time_warp_seq = capsnap->time_warp_seq;\n\n\targ.uid = capsnap->uid;\n\targ.gid = capsnap->gid;\n\targ.mode = capsnap->mode;\n\n\targ.inline_data = capsnap->inline_data;\n\targ.flags = 0;\n\targ.wake = false;\n\targ.encrypted = IS_ENCRYPTED(inode);\n\n\t \n\targ.fscrypt_auth_len = 0;\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPS, cap_msg_size(&arg),\n\t\t\t   GFP_NOFS, false);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tencode_cap_msg(msg, &arg);\n\tceph_con_send(&arg.session->s_con, msg);\n\treturn 0;\n}\n\n \nstatic void __ceph_flush_snaps(struct ceph_inode_info *ci,\n\t\t\t       struct ceph_mds_session *session)\n\t\t__releases(ci->i_ceph_lock)\n\t\t__acquires(ci->i_ceph_lock)\n{\n\tstruct inode *inode = &ci->netfs.inode;\n\tstruct ceph_mds_client *mdsc = session->s_mdsc;\n\tstruct ceph_cap_snap *capsnap;\n\tu64 oldest_flush_tid = 0;\n\tu64 first_tid = 1, last_tid = 0;\n\n\tdout(\"__flush_snaps %p session %p\\n\", inode, session);\n\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t \n\t\tif (capsnap->dirty_pages || capsnap->writing)\n\t\t\tbreak;\n\n\t\t \n\t\tBUG_ON(!capsnap->need_flush);\n\n\t\t \n\t\tif (capsnap->cap_flush.tid > 0) {\n\t\t\tdout(\" already flushed %p, skipping\\n\", capsnap);\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tcapsnap->cap_flush.tid = ++mdsc->last_cap_flush_tid;\n\t\tlist_add_tail(&capsnap->cap_flush.g_list,\n\t\t\t      &mdsc->cap_flush_list);\n\t\tif (oldest_flush_tid == 0)\n\t\t\toldest_flush_tid = __get_oldest_flush_tid(mdsc);\n\t\tif (list_empty(&ci->i_flushing_item)) {\n\t\t\tlist_add_tail(&ci->i_flushing_item,\n\t\t\t\t      &session->s_cap_flushing);\n\t\t}\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\t\tlist_add_tail(&capsnap->cap_flush.i_list,\n\t\t\t      &ci->i_cap_flush_list);\n\n\t\tif (first_tid == 1)\n\t\t\tfirst_tid = capsnap->cap_flush.tid;\n\t\tlast_tid = capsnap->cap_flush.tid;\n\t}\n\n\tci->i_ceph_flags &= ~CEPH_I_FLUSH_SNAPS;\n\n\twhile (first_tid <= last_tid) {\n\t\tstruct ceph_cap *cap = ci->i_auth_cap;\n\t\tstruct ceph_cap_flush *cf = NULL, *iter;\n\t\tint ret;\n\n\t\tif (!(cap && cap->session == session)) {\n\t\t\tdout(\"__flush_snaps %p auth cap %p not mds%d, \"\n\t\t\t     \"stop\\n\", inode, cap, session->s_mds);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = -ENOENT;\n\t\tlist_for_each_entry(iter, &ci->i_cap_flush_list, i_list) {\n\t\t\tif (iter->tid >= first_tid) {\n\t\t\t\tcf = iter;\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tfirst_tid = cf->tid + 1;\n\n\t\tcapsnap = container_of(cf, struct ceph_cap_snap, cap_flush);\n\t\trefcount_inc(&capsnap->nref);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\tdout(\"__flush_snaps %p capsnap %p tid %llu %s\\n\",\n\t\t     inode, capsnap, cf->tid, ceph_cap_string(capsnap->dirty));\n\n\t\tret = __send_flush_snap(inode, session, capsnap, cap->mseq,\n\t\t\t\t\toldest_flush_tid);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"__flush_snaps: error sending cap flushsnap, \"\n\t\t\t       \"ino (%llx.%llx) tid %llu follows %llu\\n\",\n\t\t\t\tceph_vinop(inode), cf->tid, capsnap->follows);\n\t\t}\n\n\t\tceph_put_cap_snap(capsnap);\n\t\tspin_lock(&ci->i_ceph_lock);\n\t}\n}\n\nvoid ceph_flush_snaps(struct ceph_inode_info *ci,\n\t\t      struct ceph_mds_session **psession)\n{\n\tstruct inode *inode = &ci->netfs.inode;\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_session *session = NULL;\n\tbool need_put = false;\n\tint mds;\n\n\tdout(\"ceph_flush_snaps %p\\n\", inode);\n\tif (psession)\n\t\tsession = *psession;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tif (!(ci->i_ceph_flags & CEPH_I_FLUSH_SNAPS)) {\n\t\tdout(\" no capsnap needs flush, doing nothing\\n\");\n\t\tgoto out;\n\t}\n\tif (!ci->i_auth_cap) {\n\t\tdout(\" no auth cap (migrating?), doing nothing\\n\");\n\t\tgoto out;\n\t}\n\n\tmds = ci->i_auth_cap->session->s_mds;\n\tif (session && session->s_mds != mds) {\n\t\tdout(\" oops, wrong session %p mutex\\n\", session);\n\t\tceph_put_mds_session(session);\n\t\tsession = NULL;\n\t}\n\tif (!session) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tmutex_lock(&mdsc->mutex);\n\t\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tgoto retry;\n\t}\n\n\t\n\tif (ci->i_ceph_flags & CEPH_I_KICK_FLUSH)\n\t\t__kick_flushing_caps(mdsc, session, ci, 0);\n\n\t__ceph_flush_snaps(ci, session);\nout:\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (psession)\n\t\t*psession = session;\n\telse\n\t\tceph_put_mds_session(session);\n\t \n\tspin_lock(&mdsc->snap_flush_lock);\n\tif (!list_empty(&ci->i_snap_flush_item))\n\t\tneed_put = true;\n\tlist_del_init(&ci->i_snap_flush_item);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\n\tif (need_put)\n\t\tiput(inode);\n}\n\n \nint __ceph_mark_dirty_caps(struct ceph_inode_info *ci, int mask,\n\t\t\t   struct ceph_cap_flush **pcf)\n{\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->netfs.inode.i_sb)->mdsc;\n\tstruct inode *inode = &ci->netfs.inode;\n\tint was = ci->i_dirty_caps;\n\tint dirty = 0;\n\n\tlockdep_assert_held(&ci->i_ceph_lock);\n\n\tif (!ci->i_auth_cap) {\n\t\tpr_warn(\"__mark_dirty_caps %p %llx mask %s, \"\n\t\t\t\"but no auth cap (session was closed?)\\n\",\n\t\t\tinode, ceph_ino(inode), ceph_cap_string(mask));\n\t\treturn 0;\n\t}\n\n\tdout(\"__mark_dirty_caps %p %s dirty %s -> %s\\n\", &ci->netfs.inode,\n\t     ceph_cap_string(mask), ceph_cap_string(was),\n\t     ceph_cap_string(was | mask));\n\tci->i_dirty_caps |= mask;\n\tif (was == 0) {\n\t\tstruct ceph_mds_session *session = ci->i_auth_cap->session;\n\n\t\tWARN_ON_ONCE(ci->i_prealloc_cap_flush);\n\t\tswap(ci->i_prealloc_cap_flush, *pcf);\n\n\t\tif (!ci->i_head_snapc) {\n\t\t\tWARN_ON_ONCE(!rwsem_is_locked(&mdsc->snap_rwsem));\n\t\t\tci->i_head_snapc = ceph_get_snap_context(\n\t\t\t\tci->i_snap_realm->cached_context);\n\t\t}\n\t\tdout(\" inode %p now dirty snapc %p auth cap %p\\n\",\n\t\t     &ci->netfs.inode, ci->i_head_snapc, ci->i_auth_cap);\n\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_add(&ci->i_dirty_item, &session->s_cap_dirty);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tif (ci->i_flushing_caps == 0) {\n\t\t\tihold(inode);\n\t\t\tdirty |= I_DIRTY_SYNC;\n\t\t}\n\t} else {\n\t\tWARN_ON_ONCE(!ci->i_prealloc_cap_flush);\n\t}\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\tif (((was | ci->i_flushing_caps) & CEPH_CAP_FILE_BUFFER) &&\n\t    (mask & CEPH_CAP_FILE_BUFFER))\n\t\tdirty |= I_DIRTY_DATASYNC;\n\t__cap_delay_requeue(mdsc, ci);\n\treturn dirty;\n}\n\nstruct ceph_cap_flush *ceph_alloc_cap_flush(void)\n{\n\tstruct ceph_cap_flush *cf;\n\n\tcf = kmem_cache_alloc(ceph_cap_flush_cachep, GFP_KERNEL);\n\tif (!cf)\n\t\treturn NULL;\n\n\tcf->is_capsnap = false;\n\treturn cf;\n}\n\nvoid ceph_free_cap_flush(struct ceph_cap_flush *cf)\n{\n\tif (cf)\n\t\tkmem_cache_free(ceph_cap_flush_cachep, cf);\n}\n\nstatic u64 __get_oldest_flush_tid(struct ceph_mds_client *mdsc)\n{\n\tif (!list_empty(&mdsc->cap_flush_list)) {\n\t\tstruct ceph_cap_flush *cf =\n\t\t\tlist_first_entry(&mdsc->cap_flush_list,\n\t\t\t\t\t struct ceph_cap_flush, g_list);\n\t\treturn cf->tid;\n\t}\n\treturn 0;\n}\n\n \nstatic bool __detach_cap_flush_from_mdsc(struct ceph_mds_client *mdsc,\n\t\t\t\t\t struct ceph_cap_flush *cf)\n{\n\tstruct ceph_cap_flush *prev;\n\tbool wake = cf->wake;\n\n\tif (wake && cf->g_list.prev != &mdsc->cap_flush_list) {\n\t\tprev = list_prev_entry(cf, g_list);\n\t\tprev->wake = true;\n\t\twake = false;\n\t}\n\tlist_del_init(&cf->g_list);\n\treturn wake;\n}\n\nstatic bool __detach_cap_flush_from_ci(struct ceph_inode_info *ci,\n\t\t\t\t       struct ceph_cap_flush *cf)\n{\n\tstruct ceph_cap_flush *prev;\n\tbool wake = cf->wake;\n\n\tif (wake && cf->i_list.prev != &ci->i_cap_flush_list) {\n\t\tprev = list_prev_entry(cf, i_list);\n\t\tprev->wake = true;\n\t\twake = false;\n\t}\n\tlist_del_init(&cf->i_list);\n\treturn wake;\n}\n\n \nstatic u64 __mark_caps_flushing(struct inode *inode,\n\t\t\t\tstruct ceph_mds_session *session, bool wake,\n\t\t\t\tu64 *oldest_flush_tid)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap_flush *cf = NULL;\n\tint flushing;\n\n\tlockdep_assert_held(&ci->i_ceph_lock);\n\tBUG_ON(ci->i_dirty_caps == 0);\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\tBUG_ON(!ci->i_prealloc_cap_flush);\n\n\tflushing = ci->i_dirty_caps;\n\tdout(\"__mark_caps_flushing flushing %s, flushing_caps %s -> %s\\n\",\n\t     ceph_cap_string(flushing),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(ci->i_flushing_caps | flushing));\n\tci->i_flushing_caps |= flushing;\n\tci->i_dirty_caps = 0;\n\tdout(\" inode %p now !dirty\\n\", inode);\n\n\tswap(cf, ci->i_prealloc_cap_flush);\n\tcf->caps = flushing;\n\tcf->wake = wake;\n\n\tspin_lock(&mdsc->cap_dirty_lock);\n\tlist_del_init(&ci->i_dirty_item);\n\n\tcf->tid = ++mdsc->last_cap_flush_tid;\n\tlist_add_tail(&cf->g_list, &mdsc->cap_flush_list);\n\t*oldest_flush_tid = __get_oldest_flush_tid(mdsc);\n\n\tif (list_empty(&ci->i_flushing_item)) {\n\t\tlist_add_tail(&ci->i_flushing_item, &session->s_cap_flushing);\n\t\tmdsc->num_cap_flushing++;\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\tlist_add_tail(&cf->i_list, &ci->i_cap_flush_list);\n\n\treturn cf->tid;\n}\n\n \nstatic int try_nonblocking_invalidate(struct inode *inode)\n\t__releases(ci->i_ceph_lock)\n\t__acquires(ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu32 invalidating_gen = ci->i_rdcache_gen;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tceph_fscache_invalidate(inode, false);\n\tinvalidate_mapping_pages(&inode->i_data, 0, -1);\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (inode->i_data.nrpages == 0 &&\n\t    invalidating_gen == ci->i_rdcache_gen) {\n\t\t \n\t\tdout(\"try_nonblocking_invalidate %p success\\n\", inode);\n\t\t \n\t\tci->i_rdcache_revoking = ci->i_rdcache_gen - 1;\n\t\treturn 0;\n\t}\n\tdout(\"try_nonblocking_invalidate %p failed\\n\", inode);\n\treturn -1;\n}\n\nbool __ceph_should_report_size(struct ceph_inode_info *ci)\n{\n\tloff_t size = i_size_read(&ci->netfs.inode);\n\t \n\tif (ci->i_flushing_caps & CEPH_CAP_FILE_WR)\n\t\treturn false;\n\tif (size >= ci->i_max_size)\n\t\treturn true;\n\t \n\tif (ci->i_max_size > ci->i_reported_size &&\n\t    (size << 1) >= ci->i_max_size + ci->i_reported_size)\n\t\treturn true;\n\treturn false;\n}\n\n \nvoid ceph_check_caps(struct ceph_inode_info *ci, int flags)\n{\n\tstruct inode *inode = &ci->netfs.inode;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(inode->i_sb);\n\tstruct ceph_cap *cap;\n\tu64 flush_tid, oldest_flush_tid;\n\tint file_wanted, used, cap_used;\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;    \n\tstruct rb_node *p;\n\tbool queue_invalidate = false;\n\tbool tried_invalidate = false;\n\tbool queue_writeback = false;\n\tstruct ceph_mds_session *session = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_ceph_flags & CEPH_I_ASYNC_CREATE) {\n\t\tci->i_ceph_flags |= CEPH_I_ASYNC_CHECK_CAPS;\n\n\t\t \n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\treturn;\n\t}\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\nretry:\n\t \n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\n\t \n\tused = __ceph_caps_used(ci);\n\n\t \n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\twant = file_wanted;\n\n\t \n\tretain = file_wanted | used | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (file_wanted) {\n\t\t\tretain |= CEPH_CAP_ANY;        \n\t\t} else if (S_ISDIR(inode->i_mode) &&\n\t\t\t   (issued & CEPH_CAP_FILE_SHARED) &&\n\t\t\t   __ceph_dir_is_complete(ci)) {\n\t\t\t \n\t\t\tif (IS_RDONLY(inode)) {\n\t\t\t\twant = CEPH_CAP_ANY_SHARED;\n\t\t\t} else {\n\t\t\t\twant |= CEPH_CAP_ANY_SHARED | CEPH_CAP_FILE_EXCL;\n\t\t\t}\n\t\t\tretain |= want;\n\t\t} else {\n\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t \n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %llx.%llx file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", ceph_vinop(inode),\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\",\n\t     (flags & CHECK_CAPS_NOINVAL) ? \" NOINVAL\" : \"\");\n\n\t \n\tif ((!(flags & CHECK_CAPS_NOINVAL) || mdsc->stopping) &&\n\t    S_ISREG(inode->i_mode) &&\n\t    !(ci->i_wb_ref || ci->i_wrbuffer_ref) &&    \n\t    inode->i_data.nrpages &&\t\t \n\t    (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t CEPH_CAP_FILE_LAZYIO)) &&  \n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %llx.%llx\\n\",\n\t\t     ceph_vinop(inode));\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\tqueue_invalidate = true;\n\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t}\n\t\ttried_invalidate = true;\n\t\tgoto retry;\n\t}\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tint mflags = 0;\n\t\tstruct cap_msg_args arg;\n\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\n\t\t \n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t \n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t \n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (__ceph_should_report_size(ci)) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (cap == ci->i_auth_cap) {\n\t\t\tif ((flags & CHECK_CAPS_FLUSH) && ci->i_dirty_caps) {\n\t\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t\tif (ci->i_ceph_flags & CEPH_I_FLUSH_SNAPS) {\n\t\t\t\tdout(\"flushing snap caps\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (revoking) {\n\t\t\tif ((revoking & cap_used) == 0) {\n\t\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t\t      ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (S_ISREG(inode->i_mode) && ci->i_wrbuffer_ref &&\n\t\t\t    (revoking & CEPH_CAP_FILE_BUFFER))\n\t\t\t\tqueue_writeback = true;\n\t\t}\n\n\t\t \n\t\tif (want & ~cap->mds_wanted) {\n\t\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\t\tgoto ack;\n\t\t\tif (!__cap_is_valid(cap))\n\t\t\t\tgoto ack;\n\t\t}\n\n\t\t \n\t\tif ((cap->issued & ~retain) == 0)\n\t\t\tcontinue;      \n\nack:\n\t\tceph_put_mds_session(session);\n\t\tsession = ceph_get_mds_session(cap->session);\n\n\t\t \n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (ci->i_ceph_flags &\n\t\t     (CEPH_I_KICK_FLUSH | CEPH_I_FLUSH_SNAPS))) {\n\t\t\tif (ci->i_ceph_flags & CEPH_I_KICK_FLUSH)\n\t\t\t\t__kick_flushing_caps(mdsc, session, ci, 0);\n\t\t\tif (ci->i_ceph_flags & CEPH_I_FLUSH_SNAPS)\n\t\t\t\t__ceph_flush_snaps(ci, session);\n\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps) {\n\t\t\tflushing = ci->i_dirty_caps;\n\t\t\tflush_tid = __mark_caps_flushing(inode, session, false,\n\t\t\t\t\t\t\t &oldest_flush_tid);\n\t\t\tif (flags & CHECK_CAPS_FLUSH &&\n\t\t\t    list_empty(&session->s_cap_dirty))\n\t\t\t\tmflags |= CEPH_CLIENT_CAPS_SYNC;\n\t\t} else {\n\t\t\tflushing = 0;\n\t\t\tflush_tid = 0;\n\t\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\t\toldest_flush_tid = __get_oldest_flush_tid(mdsc);\n\t\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\t}\n\n\t\tmds = cap->mds;   \n\n\t\t__prep_cap(&arg, cap, CEPH_CAP_OP_UPDATE, mflags, cap_used,\n\t\t\t   want, retain, flushing, flush_tid, oldest_flush_tid);\n\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t__send_cap(&arg, ci);\n\t\tspin_lock(&ci->i_ceph_lock);\n\n\t\tgoto retry;  \n\t}\n\n\t \n\tif (__ceph_is_any_real_caps(ci) &&\n\t    list_empty(&ci->i_cap_delay_list) &&\n\t    (file_wanted & ~CEPH_CAP_PIN) &&\n\t    !(used & (CEPH_CAP_FILE_RD | CEPH_CAP_ANY_FILE_WR))) {\n\t\t__cap_delay_requeue(mdsc, ci);\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tceph_put_mds_session(session);\n\tif (queue_writeback)\n\t\tceph_queue_writeback(inode);\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n}\n\n \nstatic int try_flush_caps(struct inode *inode, u64 *ptid)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint flushing = 0;\n\tu64 flush_tid = 0, oldest_flush_tid = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tif (ci->i_dirty_caps && ci->i_auth_cap) {\n\t\tstruct ceph_cap *cap = ci->i_auth_cap;\n\t\tstruct cap_msg_args arg;\n\t\tstruct ceph_mds_session *session = cap->session;\n\n\t\tif (session->s_state < CEPH_MDS_SESSION_OPEN) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ci->i_ceph_flags &\n\t\t    (CEPH_I_KICK_FLUSH | CEPH_I_FLUSH_SNAPS)) {\n\t\t\tif (ci->i_ceph_flags & CEPH_I_KICK_FLUSH)\n\t\t\t\t__kick_flushing_caps(mdsc, session, ci, 0);\n\t\t\tif (ci->i_ceph_flags & CEPH_I_FLUSH_SNAPS)\n\t\t\t\t__ceph_flush_snaps(ci, session);\n\t\t\tgoto retry_locked;\n\t\t}\n\n\t\tflushing = ci->i_dirty_caps;\n\t\tflush_tid = __mark_caps_flushing(inode, session, true,\n\t\t\t\t\t\t &oldest_flush_tid);\n\n\t\t__prep_cap(&arg, cap, CEPH_CAP_OP_FLUSH, CEPH_CLIENT_CAPS_SYNC,\n\t\t\t   __ceph_caps_used(ci), __ceph_caps_wanted(ci),\n\t\t\t   (cap->issued | cap->implemented),\n\t\t\t   flushing, flush_tid, oldest_flush_tid);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t__send_cap(&arg, ci);\n\t} else {\n\t\tif (!list_empty(&ci->i_cap_flush_list)) {\n\t\t\tstruct ceph_cap_flush *cf =\n\t\t\t\tlist_last_entry(&ci->i_cap_flush_list,\n\t\t\t\t\t\tstruct ceph_cap_flush, i_list);\n\t\t\tcf->wake = true;\n\t\t\tflush_tid = cf->tid;\n\t\t}\n\t\tflushing = ci->i_flushing_caps;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\nout:\n\t*ptid = flush_tid;\n\treturn flushing;\n}\n\n \nstatic int caps_are_flushed(struct inode *inode, u64 flush_tid)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (!list_empty(&ci->i_cap_flush_list)) {\n\t\tstruct ceph_cap_flush * cf =\n\t\t\tlist_first_entry(&ci->i_cap_flush_list,\n\t\t\t\t\t struct ceph_cap_flush, i_list);\n\t\tif (cf->tid <= flush_tid)\n\t\t\tret = 0;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}\n\n \nstatic int flush_mdlog_and_wait_inode_unsafe_requests(struct inode *inode)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_request *req1 = NULL, *req2 = NULL;\n\tint ret, err = 0;\n\n\tspin_lock(&ci->i_unsafe_lock);\n\tif (S_ISDIR(inode->i_mode) && !list_empty(&ci->i_unsafe_dirops)) {\n\t\treq1 = list_last_entry(&ci->i_unsafe_dirops,\n\t\t\t\t\tstruct ceph_mds_request,\n\t\t\t\t\tr_unsafe_dir_item);\n\t\tceph_mdsc_get_request(req1);\n\t}\n\tif (!list_empty(&ci->i_unsafe_iops)) {\n\t\treq2 = list_last_entry(&ci->i_unsafe_iops,\n\t\t\t\t\tstruct ceph_mds_request,\n\t\t\t\t\tr_unsafe_target_item);\n\t\tceph_mdsc_get_request(req2);\n\t}\n\tspin_unlock(&ci->i_unsafe_lock);\n\n\t \n\tif (req1 || req2) {\n\t\tstruct ceph_mds_request *req;\n\t\tstruct ceph_mds_session **sessions;\n\t\tstruct ceph_mds_session *s;\n\t\tunsigned int max_sessions;\n\t\tint i;\n\n\t\tmutex_lock(&mdsc->mutex);\n\t\tmax_sessions = mdsc->max_sessions;\n\n\t\tsessions = kcalloc(max_sessions, sizeof(s), GFP_KERNEL);\n\t\tif (!sessions) {\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tif (req1) {\n\t\t\tlist_for_each_entry(req, &ci->i_unsafe_dirops,\n\t\t\t\t\t    r_unsafe_dir_item) {\n\t\t\t\ts = req->r_session;\n\t\t\t\tif (!s)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!sessions[s->s_mds]) {\n\t\t\t\t\ts = ceph_get_mds_session(s);\n\t\t\t\t\tsessions[s->s_mds] = s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (req2) {\n\t\t\tlist_for_each_entry(req, &ci->i_unsafe_iops,\n\t\t\t\t\t    r_unsafe_target_item) {\n\t\t\t\ts = req->r_session;\n\t\t\t\tif (!s)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!sessions[s->s_mds]) {\n\t\t\t\t\ts = ceph_get_mds_session(s);\n\t\t\t\t\tsessions[s->s_mds] = s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\n\t\t \n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_auth_cap) {\n\t\t\ts = ci->i_auth_cap->session;\n\t\t\tif (!sessions[s->s_mds])\n\t\t\t\tsessions[s->s_mds] = ceph_get_mds_session(s);\n\t\t}\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tmutex_unlock(&mdsc->mutex);\n\n\t\t \n\t\tfor (i = 0; i < max_sessions; i++) {\n\t\t\ts = sessions[i];\n\t\t\tif (s) {\n\t\t\t\tsend_flush_mdlog(s);\n\t\t\t\tceph_put_mds_session(s);\n\t\t\t}\n\t\t}\n\t\tkfree(sessions);\n\t}\n\n\tdout(\"%s %p wait on tid %llu %llu\\n\", __func__,\n\t     inode, req1 ? req1->r_tid : 0ULL, req2 ? req2->r_tid : 0ULL);\n\tif (req1) {\n\t\tret = !wait_for_completion_timeout(&req1->r_safe_completion,\n\t\t\t\t\tceph_timeout_jiffies(req1->r_timeout));\n\t\tif (ret)\n\t\t\terr = -EIO;\n\t}\n\tif (req2) {\n\t\tret = !wait_for_completion_timeout(&req2->r_safe_completion,\n\t\t\t\t\tceph_timeout_jiffies(req2->r_timeout));\n\t\tif (ret)\n\t\t\terr = -EIO;\n\t}\n\nout:\n\tif (req1)\n\t\tceph_mdsc_put_request(req1);\n\tif (req2)\n\t\tceph_mdsc_put_request(req2);\n\treturn err;\n}\n\nint ceph_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 flush_tid;\n\tint ret, err;\n\tint dirty;\n\n\tdout(\"fsync %p%s\\n\", inode, datasync ? \" datasync\" : \"\");\n\n\tret = file_write_and_wait_range(file, start, end);\n\tif (datasync)\n\t\tgoto out;\n\n\tret = ceph_wait_on_async_create(inode);\n\tif (ret)\n\t\tgoto out;\n\n\tdirty = try_flush_caps(inode, &flush_tid);\n\tdout(\"fsync dirty caps are %s\\n\", ceph_cap_string(dirty));\n\n\terr = flush_mdlog_and_wait_inode_unsafe_requests(inode);\n\n\t \n\tif (!err && (dirty & ~CEPH_CAP_ANY_FILE_WR)) {\n\t\terr = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t\t\tcaps_are_flushed(inode, flush_tid));\n\t}\n\n\tif (err < 0)\n\t\tret = err;\n\n\terr = file_check_and_advance_wb_err(file);\n\tif (err < 0)\n\t\tret = err;\nout:\n\tdout(\"fsync %p%s result=%d\\n\", inode, datasync ? \" datasync\" : \"\", ret);\n\treturn ret;\n}\n\n \nint ceph_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 flush_tid;\n\tint err = 0;\n\tint dirty;\n\tint wait = (wbc->sync_mode == WB_SYNC_ALL && !wbc->for_sync);\n\n\tdout(\"write_inode %p wait=%d\\n\", inode, wait);\n\tceph_fscache_unpin_writeback(inode, wbc);\n\tif (wait) {\n\t\terr = ceph_wait_on_async_create(inode);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdirty = try_flush_caps(inode, &flush_tid);\n\t\tif (dirty)\n\t\t\terr = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t\t       caps_are_flushed(inode, flush_tid));\n\t} else {\n\t\tstruct ceph_mds_client *mdsc =\n\t\t\tceph_sb_to_client(inode->i_sb)->mdsc;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (__ceph_caps_dirty(ci))\n\t\t\t__cap_delay_requeue_front(mdsc, ci);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n\treturn err;\n}\n\nstatic void __kick_flushing_caps(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_session *session,\n\t\t\t\t struct ceph_inode_info *ci,\n\t\t\t\t u64 oldest_flush_tid)\n\t__releases(ci->i_ceph_lock)\n\t__acquires(ci->i_ceph_lock)\n{\n\tstruct inode *inode = &ci->netfs.inode;\n\tstruct ceph_cap *cap;\n\tstruct ceph_cap_flush *cf;\n\tint ret;\n\tu64 first_tid = 0;\n\tu64 last_snap_flush = 0;\n\n\t \n\tif (ci->i_ceph_flags & CEPH_I_ASYNC_CREATE)\n\t\treturn;\n\n\tci->i_ceph_flags &= ~CEPH_I_KICK_FLUSH;\n\n\tlist_for_each_entry_reverse(cf, &ci->i_cap_flush_list, i_list) {\n\t\tif (cf->is_capsnap) {\n\t\t\tlast_snap_flush = cf->tid;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(cf, &ci->i_cap_flush_list, i_list) {\n\t\tif (cf->tid < first_tid)\n\t\t\tcontinue;\n\n\t\tcap = ci->i_auth_cap;\n\t\tif (!(cap && cap->session == session)) {\n\t\t\tpr_err(\"%p auth cap %p not mds%d ???\\n\",\n\t\t\t       inode, cap, session->s_mds);\n\t\t\tbreak;\n\t\t}\n\n\t\tfirst_tid = cf->tid + 1;\n\n\t\tif (!cf->is_capsnap) {\n\t\t\tstruct cap_msg_args arg;\n\n\t\t\tdout(\"kick_flushing_caps %p cap %p tid %llu %s\\n\",\n\t\t\t     inode, cap, cf->tid, ceph_cap_string(cf->caps));\n\t\t\t__prep_cap(&arg, cap, CEPH_CAP_OP_FLUSH,\n\t\t\t\t\t (cf->tid < last_snap_flush ?\n\t\t\t\t\t  CEPH_CLIENT_CAPS_PENDING_CAPSNAP : 0),\n\t\t\t\t\t  __ceph_caps_used(ci),\n\t\t\t\t\t  __ceph_caps_wanted(ci),\n\t\t\t\t\t  (cap->issued | cap->implemented),\n\t\t\t\t\t  cf->caps, cf->tid, oldest_flush_tid);\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t__send_cap(&arg, ci);\n\t\t} else {\n\t\t\tstruct ceph_cap_snap *capsnap =\n\t\t\t\t\tcontainer_of(cf, struct ceph_cap_snap,\n\t\t\t\t\t\t    cap_flush);\n\t\t\tdout(\"kick_flushing_caps %p capsnap %p tid %llu %s\\n\",\n\t\t\t     inode, capsnap, cf->tid,\n\t\t\t     ceph_cap_string(capsnap->dirty));\n\n\t\t\trefcount_inc(&capsnap->nref);\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t\tret = __send_flush_snap(inode, session, capsnap, cap->mseq,\n\t\t\t\t\t\toldest_flush_tid);\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"kick_flushing_caps: error sending \"\n\t\t\t\t\t\"cap flushsnap, ino (%llx.%llx) \"\n\t\t\t\t\t\"tid %llu follows %llu\\n\",\n\t\t\t\t\tceph_vinop(inode), cf->tid,\n\t\t\t\t\tcapsnap->follows);\n\t\t\t}\n\n\t\t\tceph_put_cap_snap(capsnap);\n\t\t}\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t}\n}\n\nvoid ceph_early_kick_flushing_caps(struct ceph_mds_client *mdsc,\n\t\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_cap *cap;\n\tu64 oldest_flush_tid;\n\n\tdout(\"early_kick_flushing_caps mds%d\\n\", session->s_mds);\n\n\tspin_lock(&mdsc->cap_dirty_lock);\n\toldest_flush_tid = __get_oldest_flush_tid(mdsc);\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\tlist_for_each_entry(ci, &session->s_cap_flushing, i_flushing_item) {\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tcap = ci->i_auth_cap;\n\t\tif (!(cap && cap->session == session)) {\n\t\t\tpr_err(\"%p auth cap %p not mds%d ???\\n\",\n\t\t\t\t&ci->netfs.inode, cap, session->s_mds);\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t \n\t\tif ((cap->issued & ci->i_flushing_caps) !=\n\t\t    ci->i_flushing_caps) {\n\t\t\t \n\t\t\tcap->seq = 0;\n\t\t\tcap->issue_seq = 0;\n\t\t\tcap->mseq = 0;\n\t\t\t__kick_flushing_caps(mdsc, session, ci,\n\t\t\t\t\t     oldest_flush_tid);\n\t\t} else {\n\t\t\tci->i_ceph_flags |= CEPH_I_KICK_FLUSH;\n\t\t}\n\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n}\n\nvoid ceph_kick_flushing_caps(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_cap *cap;\n\tu64 oldest_flush_tid;\n\n\tlockdep_assert_held(&session->s_mutex);\n\n\tdout(\"kick_flushing_caps mds%d\\n\", session->s_mds);\n\n\tspin_lock(&mdsc->cap_dirty_lock);\n\toldest_flush_tid = __get_oldest_flush_tid(mdsc);\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\tlist_for_each_entry(ci, &session->s_cap_flushing, i_flushing_item) {\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tcap = ci->i_auth_cap;\n\t\tif (!(cap && cap->session == session)) {\n\t\t\tpr_err(\"%p auth cap %p not mds%d ???\\n\",\n\t\t\t\t&ci->netfs.inode, cap, session->s_mds);\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ci->i_ceph_flags & CEPH_I_KICK_FLUSH) {\n\t\t\t__kick_flushing_caps(mdsc, session, ci,\n\t\t\t\t\t     oldest_flush_tid);\n\t\t}\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n}\n\nvoid ceph_kick_flushing_inode_caps(struct ceph_mds_session *session,\n\t\t\t\t   struct ceph_inode_info *ci)\n{\n\tstruct ceph_mds_client *mdsc = session->s_mdsc;\n\tstruct ceph_cap *cap = ci->i_auth_cap;\n\n\tlockdep_assert_held(&ci->i_ceph_lock);\n\n\tdout(\"%s %p flushing %s\\n\", __func__, &ci->netfs.inode,\n\t     ceph_cap_string(ci->i_flushing_caps));\n\n\tif (!list_empty(&ci->i_cap_flush_list)) {\n\t\tu64 oldest_flush_tid;\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_move_tail(&ci->i_flushing_item,\n\t\t\t       &cap->session->s_cap_flushing);\n\t\toldest_flush_tid = __get_oldest_flush_tid(mdsc);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\t\t__kick_flushing_caps(mdsc, session, ci, oldest_flush_tid);\n\t}\n}\n\n\n \nvoid ceph_take_cap_refs(struct ceph_inode_info *ci, int got,\n\t\t\t    bool snap_rwsem_locked)\n{\n\tlockdep_assert_held(&ci->i_ceph_lock);\n\n\tif (got & CEPH_CAP_PIN)\n\t\tci->i_pin_ref++;\n\tif (got & CEPH_CAP_FILE_RD)\n\t\tci->i_rd_ref++;\n\tif (got & CEPH_CAP_FILE_CACHE)\n\t\tci->i_rdcache_ref++;\n\tif (got & CEPH_CAP_FILE_EXCL)\n\t\tci->i_fx_ref++;\n\tif (got & CEPH_CAP_FILE_WR) {\n\t\tif (ci->i_wr_ref == 0 && !ci->i_head_snapc) {\n\t\t\tBUG_ON(!snap_rwsem_locked);\n\t\t\tci->i_head_snapc = ceph_get_snap_context(\n\t\t\t\t\tci->i_snap_realm->cached_context);\n\t\t}\n\t\tci->i_wr_ref++;\n\t}\n\tif (got & CEPH_CAP_FILE_BUFFER) {\n\t\tif (ci->i_wb_ref == 0)\n\t\t\tihold(&ci->netfs.inode);\n\t\tci->i_wb_ref++;\n\t\tdout(\"%s %p wb %d -> %d (?)\\n\", __func__,\n\t\t     &ci->netfs.inode, ci->i_wb_ref-1, ci->i_wb_ref);\n\t}\n}\n\n \nenum {\n\t \n\tNON_BLOCKING\t= (1 << 8),\n\tCHECK_FILELOCK\t= (1 << 9),\n};\n\nstatic int try_get_cap_refs(struct inode *inode, int need, int want,\n\t\t\t    loff_t endoff, int flags, int *got)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tint ret = 0;\n\tint have, implemented;\n\tbool snap_rwsem_locked = false;\n\n\tdout(\"get_cap_refs %p need %s want %s\\n\", inode,\n\t     ceph_cap_string(need), ceph_cap_string(want));\n\nagain:\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif ((flags & CHECK_FILELOCK) &&\n\t    (ci->i_ceph_flags & CEPH_I_ERROR_FILELOCK)) {\n\t\tdout(\"try_get_cap_refs %p error filelock\\n\", inode);\n\t\tret = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\twhile (ci->i_truncate_pending) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tif (snap_rwsem_locked) {\n\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\tsnap_rwsem_locked = false;\n\t\t}\n\t\t__ceph_do_pending_vmtruncate(inode);\n\t\tspin_lock(&ci->i_ceph_lock);\n\t}\n\n\thave = __ceph_caps_issued(ci, &implemented);\n\n\tif (have & need & CEPH_CAP_FILE_WR) {\n\t\tif (endoff >= 0 && endoff > (loff_t)ci->i_max_size) {\n\t\t\tdout(\"get_cap_refs %p endoff %llu > maxsize %llu\\n\",\n\t\t\t     inode, endoff, ci->i_max_size);\n\t\t\tif (endoff > ci->i_requested_max_size)\n\t\t\t\tret = ci->i_auth_cap ? -EFBIG : -EUCLEAN;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t \n\t\tif (__ceph_have_pending_cap_snap(ci)) {\n\t\t\tdout(\"get_cap_refs %p cap_snap_pending\\n\", inode);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif ((have & need) == need) {\n\t\t \n\t\tint not = want & ~(have & need);\n\t\tint revoking = implemented & ~have;\n\t\tint exclude = revoking & not;\n\t\tdout(\"get_cap_refs %p have %s but not %s (revoking %s)\\n\",\n\t\t     inode, ceph_cap_string(have), ceph_cap_string(not),\n\t\t     ceph_cap_string(revoking));\n\t\tif (!exclude || !(exclude & CEPH_CAP_FILE_BUFFER)) {\n\t\t\tif (!snap_rwsem_locked &&\n\t\t\t    !ci->i_head_snapc &&\n\t\t\t    (need & CEPH_CAP_FILE_WR)) {\n\t\t\t\tif (!down_read_trylock(&mdsc->snap_rwsem)) {\n\t\t\t\t\t \n\t\t\t\t\tif (flags & NON_BLOCKING) {\n\t\t\t\t\t\tret = -EAGAIN;\n\t\t\t\t\t\tgoto out_unlock;\n\t\t\t\t\t}\n\n\t\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\t\tsnap_rwsem_locked = true;\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tsnap_rwsem_locked = true;\n\t\t\t}\n\t\t\tif ((have & want) == want)\n\t\t\t\t*got = need | (want & ~exclude);\n\t\t\telse\n\t\t\t\t*got = need;\n\t\t\tceph_take_cap_refs(ci, *got, true);\n\t\t\tret = 1;\n\t\t}\n\t} else {\n\t\tint session_readonly = false;\n\t\tint mds_wanted;\n\t\tif (ci->i_auth_cap &&\n\t\t    (need & (CEPH_CAP_FILE_WR | CEPH_CAP_FILE_EXCL))) {\n\t\t\tstruct ceph_mds_session *s = ci->i_auth_cap->session;\n\t\t\tspin_lock(&s->s_cap_lock);\n\t\t\tsession_readonly = s->s_readonly;\n\t\t\tspin_unlock(&s->s_cap_lock);\n\t\t}\n\t\tif (session_readonly) {\n\t\t\tdout(\"get_cap_refs %p need %s but mds%d readonly\\n\",\n\t\t\t     inode, ceph_cap_string(need), ci->i_auth_cap->mds);\n\t\t\tret = -EROFS;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (ceph_inode_is_shutdown(inode)) {\n\t\t\tdout(\"get_cap_refs %p inode is shutdown\\n\", inode);\n\t\t\tret = -ESTALE;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tmds_wanted = __ceph_caps_mds_wanted(ci, false);\n\t\tif (need & ~mds_wanted) {\n\t\t\tdout(\"get_cap_refs %p need %s > mds_wanted %s\\n\",\n\t\t\t     inode, ceph_cap_string(need),\n\t\t\t     ceph_cap_string(mds_wanted));\n\t\t\tret = -EUCLEAN;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tdout(\"get_cap_refs %p have %s need %s\\n\", inode,\n\t\t     ceph_cap_string(have), ceph_cap_string(need));\n\t}\nout_unlock:\n\n\t__ceph_touch_fmode(ci, mdsc, flags);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (snap_rwsem_locked)\n\t\tup_read(&mdsc->snap_rwsem);\n\n\tif (!ret)\n\t\tceph_update_cap_mis(&mdsc->metric);\n\telse if (ret == 1)\n\t\tceph_update_cap_hit(&mdsc->metric);\n\n\tdout(\"get_cap_refs %p ret %d got %s\\n\", inode,\n\t     ret, ceph_cap_string(*got));\n\treturn ret;\n}\n\n \nstatic void check_max_size(struct inode *inode, loff_t endoff)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint check = 0;\n\n\t \n\tspin_lock(&ci->i_ceph_lock);\n\tif (endoff >= ci->i_max_size && endoff > ci->i_wanted_max_size) {\n\t\tdout(\"write %p at large endoff %llu, req max_size\\n\",\n\t\t     inode, endoff);\n\t\tci->i_wanted_max_size = endoff;\n\t}\n\t \n\tif (ci->i_auth_cap &&\n\t    (ci->i_auth_cap->issued & CEPH_CAP_FILE_WR) &&\n\t    ci->i_wanted_max_size > ci->i_max_size &&\n\t    ci->i_wanted_max_size > ci->i_requested_max_size)\n\t\tcheck = 1;\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (check)\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY);\n}\n\nstatic inline int get_used_fmode(int caps)\n{\n\tint fmode = 0;\n\tif (caps & CEPH_CAP_FILE_RD)\n\t\tfmode |= CEPH_FILE_MODE_RD;\n\tif (caps & CEPH_CAP_FILE_WR)\n\t\tfmode |= CEPH_FILE_MODE_WR;\n\treturn fmode;\n}\n\nint ceph_try_get_caps(struct inode *inode, int need, int want,\n\t\t      bool nonblock, int *got)\n{\n\tint ret, flags;\n\n\tBUG_ON(need & ~CEPH_CAP_FILE_RD);\n\tBUG_ON(want & ~(CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO |\n\t\t\tCEPH_CAP_FILE_SHARED | CEPH_CAP_FILE_EXCL |\n\t\t\tCEPH_CAP_ANY_DIR_OPS));\n\tif (need) {\n\t\tret = ceph_pool_perm_check(inode, need);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tflags = get_used_fmode(need | want);\n\tif (nonblock)\n\t\tflags |= NON_BLOCKING;\n\n\tret = try_get_cap_refs(inode, need, want, 0, flags, got);\n\t \n\tif (ret == -EAGAIN || ret == -EFBIG || ret == -EUCLEAN)\n\t\tret = 0;\n\treturn ret;\n}\n\n \nint __ceph_get_caps(struct inode *inode, struct ceph_file_info *fi, int need,\n\t\t    int want, loff_t endoff, int *got)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tint ret, _got, flags;\n\n\tret = ceph_pool_perm_check(inode, need);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (fi && (fi->fmode & CEPH_FILE_MODE_WR) &&\n\t    fi->filp_gen != READ_ONCE(fsc->filp_gen))\n\t\treturn -EBADF;\n\n\tflags = get_used_fmode(need | want);\n\n\twhile (true) {\n\t\tflags &= CEPH_FILE_MODE_MASK;\n\t\tif (vfs_inode_has_locks(inode))\n\t\t\tflags |= CHECK_FILELOCK;\n\t\t_got = 0;\n\t\tret = try_get_cap_refs(inode, need, want, endoff,\n\t\t\t\t       flags, &_got);\n\t\tWARN_ON_ONCE(ret == -EAGAIN);\n\t\tif (!ret) {\n\t\t\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\t\t\tstruct cap_wait cw;\n\t\t\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\t\t\tcw.ino = ceph_ino(inode);\n\t\t\tcw.tgid = current->tgid;\n\t\t\tcw.need = need;\n\t\t\tcw.want = want;\n\n\t\t\tspin_lock(&mdsc->caps_list_lock);\n\t\t\tlist_add(&cw.list, &mdsc->cap_wait_list);\n\t\t\tspin_unlock(&mdsc->caps_list_lock);\n\n\t\t\t \n\t\t\tceph_get_fmode(ci, flags, FMODE_WAIT_BIAS);\n\t\t\tadd_wait_queue(&ci->i_cap_wq, &wait);\n\n\t\t\tflags |= NON_BLOCKING;\n\t\t\twhile (!(ret = try_get_cap_refs(inode, need, want,\n\t\t\t\t\t\t\tendoff, flags, &_got))) {\n\t\t\t\tif (signal_pending(current)) {\n\t\t\t\t\tret = -ERESTARTSYS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t\t\t}\n\n\t\t\tremove_wait_queue(&ci->i_cap_wq, &wait);\n\t\t\tceph_put_fmode(ci, flags, FMODE_WAIT_BIAS);\n\n\t\t\tspin_lock(&mdsc->caps_list_lock);\n\t\t\tlist_del(&cw.list);\n\t\t\tspin_unlock(&mdsc->caps_list_lock);\n\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (fi && (fi->fmode & CEPH_FILE_MODE_WR) &&\n\t\t    fi->filp_gen != READ_ONCE(fsc->filp_gen)) {\n\t\t\tif (ret >= 0 && _got)\n\t\t\t\tceph_put_cap_refs(ci, _got);\n\t\t\treturn -EBADF;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EFBIG || ret == -EUCLEAN) {\n\t\t\t\tint ret2 = ceph_wait_on_async_create(inode);\n\t\t\t\tif (ret2 < 0)\n\t\t\t\t\treturn ret2;\n\t\t\t}\n\t\t\tif (ret == -EFBIG) {\n\t\t\t\tcheck_max_size(inode, endoff);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ret == -EUCLEAN) {\n\t\t\t\t \n\t\t\t\tret = ceph_renew_caps(inode, flags);\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (S_ISREG(ci->netfs.inode.i_mode) &&\n\t\t    ceph_has_inline_data(ci) &&\n\t\t    (_got & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t\t    i_size_read(inode) > 0) {\n\t\t\tstruct page *page =\n\t\t\t\tfind_get_page(inode->i_mapping, 0);\n\t\t\tif (page) {\n\t\t\t\tbool uptodate = PageUptodate(page);\n\n\t\t\t\tput_page(page);\n\t\t\t\tif (uptodate)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tceph_put_cap_refs(ci, _got);\n\t\t\t_got = 0;\n\n\t\t\t \n\t\t\tret = __ceph_do_getattr(inode, NULL,\n\t\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA,\n\t\t\t\t\t\ttrue);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\t*got = _got;\n\treturn 0;\n}\n\nint ceph_get_caps(struct file *filp, int need, int want, loff_t endoff,\n\t\t  int *got)\n{\n\tstruct ceph_file_info *fi = filp->private_data;\n\tstruct inode *inode = file_inode(filp);\n\n\treturn __ceph_get_caps(inode, fi, need, want, endoff, got);\n}\n\n \nvoid ceph_get_cap_refs(struct ceph_inode_info *ci, int caps)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\tceph_take_cap_refs(ci, caps, false);\n\tspin_unlock(&ci->i_ceph_lock);\n}\n\n\n \nstatic int ceph_try_drop_cap_snap(struct ceph_inode_info *ci,\n\t\t\t\t  struct ceph_cap_snap *capsnap)\n{\n\tif (!capsnap->need_flush &&\n\t    !capsnap->writing && !capsnap->dirty_pages) {\n\t\tdout(\"dropping cap_snap %p follows %llu\\n\",\n\t\t     capsnap, capsnap->follows);\n\t\tBUG_ON(capsnap->cap_flush.tid > 0);\n\t\tceph_put_snap_context(capsnap->context);\n\t\tif (!list_is_last(&capsnap->ci_item, &ci->i_cap_snaps))\n\t\t\tci->i_ceph_flags |= CEPH_I_FLUSH_SNAPS;\n\n\t\tlist_del(&capsnap->ci_item);\n\t\tceph_put_cap_snap(capsnap);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nenum put_cap_refs_mode {\n\tPUT_CAP_REFS_SYNC = 0,\n\tPUT_CAP_REFS_NO_CHECK,\n\tPUT_CAP_REFS_ASYNC,\n};\n\n \nstatic void __ceph_put_cap_refs(struct ceph_inode_info *ci, int had,\n\t\t\t\tenum put_cap_refs_mode mode)\n{\n\tstruct inode *inode = &ci->netfs.inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tbool check_flushsnaps = false;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_EXCL)\n\t\tif (--ci->i_fx_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\t \n\t\t\tput++;\n\t\t\tcheck_flushsnaps = true;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR) {\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\t \n\t\t\tWARN_ON_ONCE(ci->i_wb_ref);\n\n\t\t\tlast++;\n\t\t\tcheck_flushsnaps = true;\n\t\t\tif (ci->i_wrbuffer_ref_head == 0 &&\n\t\t\t    ci->i_dirty_caps == 0 &&\n\t\t\t    ci->i_flushing_caps == 0) {\n\t\t\t\tBUG_ON(!ci->i_head_snapc);\n\t\t\t\tceph_put_snap_context(ci->i_head_snapc);\n\t\t\t\tci->i_head_snapc = NULL;\n\t\t\t}\n\t\t\t \n\t\t\tif (!__ceph_is_any_real_caps(ci) && ci->i_snap_realm)\n\t\t\t\tceph_change_snap_realm(inode, NULL);\n\t\t}\n\t}\n\tif (check_flushsnaps && __ceph_have_pending_cap_snap(ci)) {\n\t\tstruct ceph_cap_snap *capsnap =\n\t\t\tlist_last_entry(&ci->i_cap_snaps,\n\t\t\t\t\tstruct ceph_cap_snap,\n\t\t\t\t\tci_item);\n\n\t\tcapsnap->writing = 0;\n\t\tif (ceph_try_drop_cap_snap(ci, capsnap))\n\t\t\t \n\t\t\tput++;\n\t\telse if (__ceph_finish_cap_snap(ci, capsnap))\n\t\t\tflushsnaps = 1;\n\t\twake = 1;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tswitch (mode) {\n\tcase PUT_CAP_REFS_SYNC:\n\t\tif (last)\n\t\t\tceph_check_caps(ci, 0);\n\t\telse if (flushsnaps)\n\t\t\tceph_flush_snaps(ci, NULL);\n\t\tbreak;\n\tcase PUT_CAP_REFS_ASYNC:\n\t\tif (last)\n\t\t\tceph_queue_check_caps(inode);\n\t\telse if (flushsnaps)\n\t\t\tceph_queue_flush_snaps(inode);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\twhile (put-- > 0)\n\t\tiput(inode);\n}\n\nvoid ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\t__ceph_put_cap_refs(ci, had, PUT_CAP_REFS_SYNC);\n}\n\nvoid ceph_put_cap_refs_async(struct ceph_inode_info *ci, int had)\n{\n\t__ceph_put_cap_refs(ci, had, PUT_CAP_REFS_ASYNC);\n}\n\nvoid ceph_put_cap_refs_no_check_caps(struct ceph_inode_info *ci, int had)\n{\n\t__ceph_put_cap_refs(ci, had, PUT_CAP_REFS_NO_CHECK);\n}\n\n \nvoid ceph_put_wrbuffer_cap_refs(struct ceph_inode_info *ci, int nr,\n\t\t\t\tstruct ceph_snap_context *snapc)\n{\n\tstruct inode *inode = &ci->netfs.inode;\n\tstruct ceph_cap_snap *capsnap = NULL, *iter;\n\tint put = 0;\n\tbool last = false;\n\tbool flush_snaps = false;\n\tbool complete_capsnap = false;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tci->i_wrbuffer_ref -= nr;\n\tif (ci->i_wrbuffer_ref == 0) {\n\t\tlast = true;\n\t\tput++;\n\t}\n\n\tif (ci->i_head_snapc == snapc) {\n\t\tci->i_wrbuffer_ref_head -= nr;\n\t\tif (ci->i_wrbuffer_ref_head == 0 &&\n\t\t    ci->i_wr_ref == 0 &&\n\t\t    ci->i_dirty_caps == 0 &&\n\t\t    ci->i_flushing_caps == 0) {\n\t\t\tBUG_ON(!ci->i_head_snapc);\n\t\t\tceph_put_snap_context(ci->i_head_snapc);\n\t\t\tci->i_head_snapc = NULL;\n\t\t}\n\t\tdout(\"put_wrbuffer_cap_refs on %p head %d/%d -> %d/%d %s\\n\",\n\t\t     inode,\n\t\t     ci->i_wrbuffer_ref+nr, ci->i_wrbuffer_ref_head+nr,\n\t\t     ci->i_wrbuffer_ref, ci->i_wrbuffer_ref_head,\n\t\t     last ? \" LAST\" : \"\");\n\t} else {\n\t\tlist_for_each_entry(iter, &ci->i_cap_snaps, ci_item) {\n\t\t\tif (iter->context == snapc) {\n\t\t\t\tcapsnap = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!capsnap) {\n\t\t\t \n\t\t\tWARN_ON_ONCE(ci->i_auth_cap);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tcapsnap->dirty_pages -= nr;\n\t\tif (capsnap->dirty_pages == 0) {\n\t\t\tcomplete_capsnap = true;\n\t\t\tif (!capsnap->writing) {\n\t\t\t\tif (ceph_try_drop_cap_snap(ci, capsnap)) {\n\t\t\t\t\tput++;\n\t\t\t\t} else {\n\t\t\t\t\tci->i_ceph_flags |= CEPH_I_FLUSH_SNAPS;\n\t\t\t\t\tflush_snaps = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdout(\"put_wrbuffer_cap_refs on %p cap_snap %p \"\n\t\t     \" snap %lld %d/%d -> %d/%d %s%s\\n\",\n\t\t     inode, capsnap, capsnap->context->seq,\n\t\t     ci->i_wrbuffer_ref+nr, capsnap->dirty_pages + nr,\n\t\t     ci->i_wrbuffer_ref, capsnap->dirty_pages,\n\t\t     last ? \" (wrbuffer last)\" : \"\",\n\t\t     complete_capsnap ? \" (complete capsnap)\" : \"\");\n\t}\n\nunlock:\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last) {\n\t\tceph_check_caps(ci, 0);\n\t} else if (flush_snaps) {\n\t\tceph_flush_snaps(ci, NULL);\n\t}\n\tif (complete_capsnap)\n\t\twake_up_all(&ci->i_cap_wq);\n\twhile (put-- > 0) {\n\t\tiput(inode);\n\t}\n}\n\n \nstatic void invalidate_aliases(struct inode *inode)\n{\n\tstruct dentry *dn, *prev = NULL;\n\n\tdout(\"invalidate_aliases inode %p\\n\", inode);\n\td_prune_aliases(inode);\n\t \n\twhile ((dn = d_find_alias(inode))) {\n\t\tif (dn == prev) {\n\t\t\tdput(dn);\n\t\t\tbreak;\n\t\t}\n\t\td_invalidate(dn);\n\t\tif (prev)\n\t\t\tdput(prev);\n\t\tprev = dn;\n\t}\n\tif (prev)\n\t\tdput(prev);\n}\n\nstruct cap_extra_info {\n\tstruct ceph_string *pool_ns;\n\t \n\tu64 inline_version;\n\tvoid *inline_data;\n\tu32 inline_len;\n\t \n\tbool dirstat_valid;\n\tu64 nfiles;\n\tu64 nsubdirs;\n\tu64 change_attr;\n\t \n\tint issued;\n\tstruct timespec64 btime;\n\tu8 *fscrypt_auth;\n\tu32 fscrypt_auth_len;\n\tu64 fscrypt_file_size;\n};\n\n \nstatic void handle_cap_grant(struct inode *inode,\n\t\t\t     struct ceph_mds_session *session,\n\t\t\t     struct ceph_cap *cap,\n\t\t\t     struct ceph_mds_caps *grant,\n\t\t\t     struct ceph_buffer *xattr_buf,\n\t\t\t     struct cap_extra_info *extra_info)\n\t__releases(ci->i_ceph_lock)\n\t__releases(session->s_mdsc->snap_rwsem)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint seq = le32_to_cpu(grant->seq);\n\tint newcaps = le32_to_cpu(grant->caps);\n\tint used, wanted, dirty;\n\tu64 size = le64_to_cpu(grant->size);\n\tu64 max_size = le64_to_cpu(grant->max_size);\n\tunsigned char check_caps = 0;\n\tbool was_stale = cap->cap_gen < atomic_read(&session->s_cap_gen);\n\tbool wake = false;\n\tbool writeback = false;\n\tbool queue_trunc = false;\n\tbool queue_invalidate = false;\n\tbool deleted_inode = false;\n\tbool fill_inline = false;\n\n\t \n\tif (IS_ENCRYPTED(inode) && size)\n\t\tsize = extra_info->fscrypt_file_size;\n\n\tdout(\"handle_cap_grant inode %p cap %p mds%d seq %d %s\\n\",\n\t     inode, cap, session->s_mds, seq, ceph_cap_string(newcaps));\n\tdout(\" size %llu max_size %llu, i_size %llu\\n\", size, max_size,\n\t\ti_size_read(inode));\n\n\n\t \n\tif (S_ISREG(inode->i_mode) &&  \n\t    ((cap->issued & ~newcaps) & CEPH_CAP_FILE_CACHE) &&\n\t    (newcaps & CEPH_CAP_FILE_LAZYIO) == 0 &&\n\t    !(ci->i_wrbuffer_ref || ci->i_wb_ref)) {\n\t\tif (try_nonblocking_invalidate(inode)) {\n\t\t\t \n\t\t\tif (ci->i_rdcache_revoking != ci->i_rdcache_gen) {\n\t\t\t\tqueue_invalidate = true;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (was_stale)\n\t\tcap->issued = cap->implemented = CEPH_CAP_PIN;\n\n\t \n\tif (ceph_seq_cmp(seq, cap->seq) <= 0) {\n\t\tWARN_ON(cap != ci->i_auth_cap);\n\t\tWARN_ON(cap->cap_id != le64_to_cpu(grant->cap_id));\n\t\tseq = cap->seq;\n\t\tnewcaps |= cap->issued;\n\t}\n\n\t \n\tcap->cap_gen = atomic_read(&session->s_cap_gen);\n\tcap->seq = seq;\n\n\t__check_cap_issue(ci, cap, newcaps);\n\n\tinode_set_max_iversion_raw(inode, extra_info->change_attr);\n\n\tif ((newcaps & CEPH_CAP_AUTH_SHARED) &&\n\t    (extra_info->issued & CEPH_CAP_AUTH_EXCL) == 0) {\n\t\tumode_t mode = le32_to_cpu(grant->mode);\n\n\t\tif (inode_wrong_type(inode, mode))\n\t\t\tpr_warn_once(\"inode type changed! (ino %llx.%llx is 0%o, mds says 0%o)\\n\",\n\t\t\t\t     ceph_vinop(inode), inode->i_mode, mode);\n\t\telse\n\t\t\tinode->i_mode = mode;\n\t\tinode->i_uid = make_kuid(&init_user_ns, le32_to_cpu(grant->uid));\n\t\tinode->i_gid = make_kgid(&init_user_ns, le32_to_cpu(grant->gid));\n\t\tci->i_btime = extra_info->btime;\n\t\tdout(\"%p mode 0%o uid.gid %d.%d\\n\", inode, inode->i_mode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kgid(&init_user_ns, inode->i_gid));\n#if IS_ENABLED(CONFIG_FS_ENCRYPTION)\n\t\tif (ci->fscrypt_auth_len != extra_info->fscrypt_auth_len ||\n\t\t    memcmp(ci->fscrypt_auth, extra_info->fscrypt_auth,\n\t\t\t   ci->fscrypt_auth_len))\n\t\t\tpr_warn_ratelimited(\"%s: cap grant attempt to change fscrypt_auth on non-I_NEW inode (old len %d new len %d)\\n\",\n\t\t\t\t__func__, ci->fscrypt_auth_len,\n\t\t\t\textra_info->fscrypt_auth_len);\n#endif\n\t}\n\n\tif ((newcaps & CEPH_CAP_LINK_SHARED) &&\n\t    (extra_info->issued & CEPH_CAP_LINK_EXCL) == 0) {\n\t\tset_nlink(inode, le32_to_cpu(grant->nlink));\n\t\tif (inode->i_nlink == 0)\n\t\t\tdeleted_inode = true;\n\t}\n\n\tif ((extra_info->issued & CEPH_CAP_XATTR_EXCL) == 0 &&\n\t    grant->xattr_len) {\n\t\tint len = le32_to_cpu(grant->xattr_len);\n\t\tu64 version = le64_to_cpu(grant->xattr_version);\n\n\t\tif (version > ci->i_xattrs.version) {\n\t\t\tdout(\" got new xattrs v%llu on %p len %d\\n\",\n\t\t\t     version, inode, len);\n\t\t\tif (ci->i_xattrs.blob)\n\t\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\t\tci->i_xattrs.blob = ceph_buffer_get(xattr_buf);\n\t\t\tci->i_xattrs.version = version;\n\t\t\tceph_forget_all_cached_acls(inode);\n\t\t\tceph_security_invalidate_secctx(inode);\n\t\t}\n\t}\n\n\tif (newcaps & CEPH_CAP_ANY_RD) {\n\t\tstruct timespec64 mtime, atime, ctime;\n\t\t \n\t\tceph_decode_timespec64(&mtime, &grant->mtime);\n\t\tceph_decode_timespec64(&atime, &grant->atime);\n\t\tceph_decode_timespec64(&ctime, &grant->ctime);\n\t\tceph_fill_file_time(inode, extra_info->issued,\n\t\t\t\t    le32_to_cpu(grant->time_warp_seq),\n\t\t\t\t    &ctime, &mtime, &atime);\n\t}\n\n\tif ((newcaps & CEPH_CAP_FILE_SHARED) && extra_info->dirstat_valid) {\n\t\tci->i_files = extra_info->nfiles;\n\t\tci->i_subdirs = extra_info->nsubdirs;\n\t}\n\n\tif (newcaps & (CEPH_CAP_ANY_FILE_RD | CEPH_CAP_ANY_FILE_WR)) {\n\t\t \n\t\ts64 old_pool = ci->i_layout.pool_id;\n\t\tstruct ceph_string *old_ns;\n\n\t\tceph_file_layout_from_legacy(&ci->i_layout, &grant->layout);\n\t\told_ns = rcu_dereference_protected(ci->i_layout.pool_ns,\n\t\t\t\t\tlockdep_is_held(&ci->i_ceph_lock));\n\t\trcu_assign_pointer(ci->i_layout.pool_ns, extra_info->pool_ns);\n\n\t\tif (ci->i_layout.pool_id != old_pool ||\n\t\t    extra_info->pool_ns != old_ns)\n\t\t\tci->i_ceph_flags &= ~CEPH_I_POOL_PERM;\n\n\t\textra_info->pool_ns = old_ns;\n\n\t\t \n\t\tqueue_trunc = ceph_fill_file_size(inode, extra_info->issued,\n\t\t\t\t\tle32_to_cpu(grant->truncate_seq),\n\t\t\t\t\tle64_to_cpu(grant->truncate_size),\n\t\t\t\t\tsize);\n\t}\n\n\tif (ci->i_auth_cap == cap && (newcaps & CEPH_CAP_ANY_FILE_WR)) {\n\t\tif (max_size != ci->i_max_size) {\n\t\t\tdout(\"max_size %lld -> %llu\\n\",\n\t\t\t     ci->i_max_size, max_size);\n\t\t\tci->i_max_size = max_size;\n\t\t\tif (max_size >= ci->i_wanted_max_size) {\n\t\t\t\tci->i_wanted_max_size = 0;   \n\t\t\t\tci->i_requested_max_size = 0;\n\t\t\t}\n\t\t\twake = true;\n\t\t}\n\t}\n\n\t \n\twanted = __ceph_caps_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\tdirty = __ceph_caps_dirty(ci);\n\tdout(\" my wanted = %s, used = %s, dirty %s\\n\",\n\t     ceph_cap_string(wanted),\n\t     ceph_cap_string(used),\n\t     ceph_cap_string(dirty));\n\n\tif ((was_stale || le32_to_cpu(grant->op) == CEPH_CAP_OP_IMPORT) &&\n\t    (wanted & ~(cap->mds_wanted | newcaps))) {\n\t\t \n\t\tcheck_caps = 1;\n\t}\n\n\t \n\tif (cap->issued & ~newcaps) {\n\t\tint revoking = cap->issued & ~newcaps;\n\n\t\tdout(\"revocation: %s -> %s (revoking %s)\\n\",\n\t\t     ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(newcaps),\n\t\t     ceph_cap_string(revoking));\n\t\tif (S_ISREG(inode->i_mode) &&\n\t\t    (revoking & used & CEPH_CAP_FILE_BUFFER))\n\t\t\twriteback = true;   \n\t\telse if (queue_invalidate &&\n\t\t\t revoking == CEPH_CAP_FILE_CACHE &&\n\t\t\t (newcaps & CEPH_CAP_FILE_LAZYIO) == 0)\n\t\t\t;  \n\t\telse if (cap == ci->i_auth_cap)\n\t\t\tcheck_caps = 1;  \n\t\telse\n\t\t\tcheck_caps = 2;  \n\t\t \n\t\tif (~cap->issued & newcaps)\n\t\t\twake = true;\n\t\tcap->issued = newcaps;\n\t\tcap->implemented |= newcaps;\n\t} else if (cap->issued == newcaps) {\n\t\tdout(\"caps unchanged: %s -> %s\\n\",\n\t\t     ceph_cap_string(cap->issued), ceph_cap_string(newcaps));\n\t} else {\n\t\tdout(\"grant: %s -> %s\\n\", ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(newcaps));\n\t\t \n\t\tif (cap == ci->i_auth_cap &&\n\t\t    __ceph_caps_revoking_other(ci, cap, newcaps))\n\t\t    check_caps = 2;\n\n\t\tcap->issued = newcaps;\n\t\tcap->implemented |= newcaps;  \n\t\twake = true;\n\t}\n\tBUG_ON(cap->issued & ~cap->implemented);\n\n\t \n\tif (le32_to_cpu(grant->op) == CEPH_CAP_OP_REVOKE) {\n\t\tcap->mds_wanted = 0;\n\t\tif (cap == ci->i_auth_cap)\n\t\t\tcheck_caps = 1;  \n\t\telse\n\t\t\tcheck_caps = 2;  \n\t}\n\n\tif (extra_info->inline_version > 0 &&\n\t    extra_info->inline_version >= ci->i_inline_version) {\n\t\tci->i_inline_version = extra_info->inline_version;\n\t\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t\t    (newcaps & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)))\n\t\t\tfill_inline = true;\n\t}\n\n\tif (le32_to_cpu(grant->op) == CEPH_CAP_OP_IMPORT) {\n\t\tif (ci->i_auth_cap == cap) {\n\t\t\tif (newcaps & ~extra_info->issued)\n\t\t\t\twake = true;\n\n\t\t\tif (ci->i_requested_max_size > max_size ||\n\t\t\t    !(le32_to_cpu(grant->wanted) & CEPH_CAP_ANY_FILE_WR)) {\n\t\t\t\t \n\t\t\t\tci->i_requested_max_size = 0;\n\t\t\t\twake = true;\n\t\t\t}\n\n\t\t\tceph_kick_flushing_inode_caps(session, ci);\n\t\t}\n\t\tup_read(&session->s_mdsc->snap_rwsem);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (fill_inline)\n\t\tceph_fill_inline_data(inode, NULL, extra_info->inline_data,\n\t\t\t\t      extra_info->inline_len);\n\n\tif (queue_trunc)\n\t\tceph_queue_vmtruncate(inode);\n\n\tif (writeback)\n\t\t \n\t\tceph_queue_writeback(inode);\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\tif (deleted_inode)\n\t\tinvalidate_aliases(inode);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\tmutex_unlock(&session->s_mutex);\n\tif (check_caps == 1)\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY | CHECK_CAPS_NOINVAL);\n\telse if (check_caps == 2)\n\t\tceph_check_caps(ci, CHECK_CAPS_NOINVAL);\n}\n\n \nstatic void handle_cap_flush_ack(struct inode *inode, u64 flush_tid,\n\t\t\t\t struct ceph_mds_caps *m,\n\t\t\t\t struct ceph_mds_session *session,\n\t\t\t\t struct ceph_cap *cap)\n\t__releases(ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_cap_flush *cf, *tmp_cf;\n\tLIST_HEAD(to_remove);\n\tunsigned seq = le32_to_cpu(m->seq);\n\tint dirty = le32_to_cpu(m->dirty);\n\tint cleaned = 0;\n\tbool drop = false;\n\tbool wake_ci = false;\n\tbool wake_mdsc = false;\n\n\tlist_for_each_entry_safe(cf, tmp_cf, &ci->i_cap_flush_list, i_list) {\n\t\t \n\t\tif (cf->tid == flush_tid)\n\t\t\tcleaned = cf->caps;\n\n\t\t \n\t\tif (cf->is_capsnap)\n\t\t\tcontinue;\n\n\t\tif (cf->tid <= flush_tid) {\n\t\t\t \n\t\t\twake_ci |= __detach_cap_flush_from_ci(ci, cf);\n\t\t\tlist_add_tail(&cf->i_list, &to_remove);\n\t\t} else {\n\t\t\t \n\t\t\tcleaned &= ~cf->caps;\n\t\t\tif (!cleaned)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tdout(\"handle_cap_flush_ack inode %p mds%d seq %d on %s cleaned %s,\"\n\t     \" flushing %s -> %s\\n\",\n\t     inode, session->s_mds, seq, ceph_cap_string(dirty),\n\t     ceph_cap_string(cleaned), ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(ci->i_flushing_caps & ~cleaned));\n\n\tif (list_empty(&to_remove) && !cleaned)\n\t\tgoto out;\n\n\tci->i_flushing_caps &= ~cleaned;\n\n\tspin_lock(&mdsc->cap_dirty_lock);\n\n\tlist_for_each_entry(cf, &to_remove, i_list)\n\t\twake_mdsc |= __detach_cap_flush_from_mdsc(mdsc, cf);\n\n\tif (ci->i_flushing_caps == 0) {\n\t\tif (list_empty(&ci->i_cap_flush_list)) {\n\t\t\tlist_del_init(&ci->i_flushing_item);\n\t\t\tif (!list_empty(&session->s_cap_flushing)) {\n\t\t\t\tdout(\" mds%d still flushing cap on %p\\n\",\n\t\t\t\t     session->s_mds,\n\t\t\t\t     &list_first_entry(&session->s_cap_flushing,\n\t\t\t\t\t\tstruct ceph_inode_info,\n\t\t\t\t\t\ti_flushing_item)->netfs.inode);\n\t\t\t}\n\t\t}\n\t\tmdsc->num_cap_flushing--;\n\t\tdout(\" inode %p now !flushing\\n\", inode);\n\n\t\tif (ci->i_dirty_caps == 0) {\n\t\t\tdout(\" inode %p now clean\\n\", inode);\n\t\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\t\tdrop = true;\n\t\t\tif (ci->i_wr_ref == 0 &&\n\t\t\t    ci->i_wrbuffer_ref_head == 0) {\n\t\t\t\tBUG_ON(!ci->i_head_snapc);\n\t\t\t\tceph_put_snap_context(ci->i_head_snapc);\n\t\t\t\tci->i_head_snapc = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&ci->i_dirty_item));\n\t\t}\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\nout:\n\tspin_unlock(&ci->i_ceph_lock);\n\n\twhile (!list_empty(&to_remove)) {\n\t\tcf = list_first_entry(&to_remove,\n\t\t\t\t      struct ceph_cap_flush, i_list);\n\t\tlist_del_init(&cf->i_list);\n\t\tif (!cf->is_capsnap)\n\t\t\tceph_free_cap_flush(cf);\n\t}\n\n\tif (wake_ci)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (wake_mdsc)\n\t\twake_up_all(&mdsc->cap_flushing_wq);\n\tif (drop)\n\t\tiput(inode);\n}\n\nvoid __ceph_remove_capsnap(struct inode *inode, struct ceph_cap_snap *capsnap,\n\t\t\t   bool *wake_ci, bool *wake_mdsc)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tbool ret;\n\n\tlockdep_assert_held(&ci->i_ceph_lock);\n\n\tdout(\"removing capsnap %p, inode %p ci %p\\n\", capsnap, inode, ci);\n\n\tlist_del_init(&capsnap->ci_item);\n\tret = __detach_cap_flush_from_ci(ci, &capsnap->cap_flush);\n\tif (wake_ci)\n\t\t*wake_ci = ret;\n\n\tspin_lock(&mdsc->cap_dirty_lock);\n\tif (list_empty(&ci->i_cap_flush_list))\n\t\tlist_del_init(&ci->i_flushing_item);\n\n\tret = __detach_cap_flush_from_mdsc(mdsc, &capsnap->cap_flush);\n\tif (wake_mdsc)\n\t\t*wake_mdsc = ret;\n\tspin_unlock(&mdsc->cap_dirty_lock);\n}\n\nvoid ceph_remove_capsnap(struct inode *inode, struct ceph_cap_snap *capsnap,\n\t\t\t bool *wake_ci, bool *wake_mdsc)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tlockdep_assert_held(&ci->i_ceph_lock);\n\n\tWARN_ON_ONCE(capsnap->dirty_pages || capsnap->writing);\n\t__ceph_remove_capsnap(inode, capsnap, wake_ci, wake_mdsc);\n}\n\n \nstatic void handle_cap_flushsnap_ack(struct inode *inode, u64 flush_tid,\n\t\t\t\t     struct ceph_mds_caps *m,\n\t\t\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tu64 follows = le64_to_cpu(m->snap_follows);\n\tstruct ceph_cap_snap *capsnap = NULL, *iter;\n\tbool wake_ci = false;\n\tbool wake_mdsc = false;\n\n\tdout(\"handle_cap_flushsnap_ack inode %p ci %p mds%d follows %lld\\n\",\n\t     inode, ci, session->s_mds, follows);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tlist_for_each_entry(iter, &ci->i_cap_snaps, ci_item) {\n\t\tif (iter->follows == follows) {\n\t\t\tif (iter->cap_flush.tid != flush_tid) {\n\t\t\t\tdout(\" cap_snap %p follows %lld tid %lld !=\"\n\t\t\t\t     \" %lld\\n\", iter, follows,\n\t\t\t\t     flush_tid, iter->cap_flush.tid);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcapsnap = iter;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdout(\" skipping cap_snap %p follows %lld\\n\",\n\t\t\t     iter, iter->follows);\n\t\t}\n\t}\n\tif (capsnap)\n\t\tceph_remove_capsnap(inode, capsnap, &wake_ci, &wake_mdsc);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (capsnap) {\n\t\tceph_put_snap_context(capsnap->context);\n\t\tceph_put_cap_snap(capsnap);\n\t\tif (wake_ci)\n\t\t\twake_up_all(&ci->i_cap_wq);\n\t\tif (wake_mdsc)\n\t\t\twake_up_all(&mdsc->cap_flushing_wq);\n\t\tiput(inode);\n\t}\n}\n\n \nstatic bool handle_cap_trunc(struct inode *inode,\n\t\t\t     struct ceph_mds_caps *trunc,\n\t\t\t     struct ceph_mds_session *session,\n\t\t\t     struct cap_extra_info *extra_info)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint mds = session->s_mds;\n\tint seq = le32_to_cpu(trunc->seq);\n\tu32 truncate_seq = le32_to_cpu(trunc->truncate_seq);\n\tu64 truncate_size = le64_to_cpu(trunc->truncate_size);\n\tu64 size = le64_to_cpu(trunc->size);\n\tint implemented = 0;\n\tint dirty = __ceph_caps_dirty(ci);\n\tint issued = __ceph_caps_issued(ceph_inode(inode), &implemented);\n\tbool queue_trunc = false;\n\n\tlockdep_assert_held(&ci->i_ceph_lock);\n\n\tissued |= implemented | dirty;\n\n\t \n\tif (IS_ENCRYPTED(inode) && size)\n\t\tsize = extra_info->fscrypt_file_size;\n\n\tdout(\"%s inode %p mds%d seq %d to %lld truncate seq %d\\n\",\n\t     __func__, inode, mds, seq, truncate_size, truncate_seq);\n\tqueue_trunc = ceph_fill_file_size(inode, issued,\n\t\t\t\t\t  truncate_seq, truncate_size, size);\n\treturn queue_trunc;\n}\n\n \nstatic void handle_cap_export(struct inode *inode, struct ceph_mds_caps *ex,\n\t\t\t      struct ceph_mds_cap_peer *ph,\n\t\t\t      struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_session *tsession = NULL;\n\tstruct ceph_cap *cap, *tcap, *new_cap = NULL;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 t_cap_id;\n\tunsigned mseq = le32_to_cpu(ex->migrate_seq);\n\tunsigned t_seq, t_mseq;\n\tint target, issued;\n\tint mds = session->s_mds;\n\n\tif (ph) {\n\t\tt_cap_id = le64_to_cpu(ph->cap_id);\n\t\tt_seq = le32_to_cpu(ph->seq);\n\t\tt_mseq = le32_to_cpu(ph->mseq);\n\t\ttarget = le32_to_cpu(ph->mds);\n\t} else {\n\t\tt_cap_id = t_seq = t_mseq = 0;\n\t\ttarget = -1;\n\t}\n\n\tdout(\"handle_cap_export inode %p ci %p mds%d mseq %d target %d\\n\",\n\t     inode, ci, mds, mseq, target);\nretry:\n\tdown_read(&mdsc->snap_rwsem);\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap || cap->cap_id != le64_to_cpu(ex->cap_id))\n\t\tgoto out_unlock;\n\n\tif (target < 0) {\n\t\tceph_remove_cap(cap, false);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\n\tissued = cap->issued;\n\tif (issued != cap->implemented)\n\t\tpr_err_ratelimited(\"handle_cap_export: issued != implemented: \"\n\t\t\t\t\"ino (%llx.%llx) mds%d seq %d mseq %d \"\n\t\t\t\t\"issued %s implemented %s\\n\",\n\t\t\t\tceph_vinop(inode), mds, cap->seq, cap->mseq,\n\t\t\t\tceph_cap_string(issued),\n\t\t\t\tceph_cap_string(cap->implemented));\n\n\n\ttcap = __get_cap_for_mds(ci, target);\n\tif (tcap) {\n\t\t \n\t\tif (tcap->cap_id == t_cap_id &&\n\t\t    ceph_seq_cmp(tcap->seq, t_seq) < 0) {\n\t\t\tdout(\" updating import cap %p mds%d\\n\", tcap, target);\n\t\t\ttcap->cap_id = t_cap_id;\n\t\t\ttcap->seq = t_seq - 1;\n\t\t\ttcap->issue_seq = t_seq - 1;\n\t\t\ttcap->issued |= issued;\n\t\t\ttcap->implemented |= issued;\n\t\t\tif (cap == ci->i_auth_cap) {\n\t\t\t\tci->i_auth_cap = tcap;\n\t\t\t\tchange_auth_cap_ses(ci, tcap->session);\n\t\t\t}\n\t\t}\n\t\tceph_remove_cap(cap, false);\n\t\tgoto out_unlock;\n\t} else if (tsession) {\n\t\t \n\t\tint flag = (cap == ci->i_auth_cap) ? CEPH_CAP_FLAG_AUTH : 0;\n\t\ttcap = new_cap;\n\t\tceph_add_cap(inode, tsession, t_cap_id, issued, 0,\n\t\t\t     t_seq - 1, t_mseq, (u64)-1, flag, &new_cap);\n\n\t\tif (!list_empty(&ci->i_cap_flush_list) &&\n\t\t    ci->i_auth_cap == tcap) {\n\t\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\t\tlist_move_tail(&ci->i_flushing_item,\n\t\t\t\t       &tcap->session->s_cap_flushing);\n\t\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\t}\n\n\t\tceph_remove_cap(cap, false);\n\t\tgoto out_unlock;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tup_read(&mdsc->snap_rwsem);\n\tmutex_unlock(&session->s_mutex);\n\n\t \n\ttsession = ceph_mdsc_open_export_target_session(mdsc, target);\n\tif (!IS_ERR(tsession)) {\n\t\tif (mds > target) {\n\t\t\tmutex_lock(&session->s_mutex);\n\t\t\tmutex_lock_nested(&tsession->s_mutex,\n\t\t\t\t\t  SINGLE_DEPTH_NESTING);\n\t\t} else {\n\t\t\tmutex_lock(&tsession->s_mutex);\n\t\t\tmutex_lock_nested(&session->s_mutex,\n\t\t\t\t\t  SINGLE_DEPTH_NESTING);\n\t\t}\n\t\tnew_cap = ceph_get_cap(mdsc, NULL);\n\t} else {\n\t\tWARN_ON(1);\n\t\ttsession = NULL;\n\t\ttarget = -1;\n\t\tmutex_lock(&session->s_mutex);\n\t}\n\tgoto retry;\n\nout_unlock:\n\tspin_unlock(&ci->i_ceph_lock);\n\tup_read(&mdsc->snap_rwsem);\n\tmutex_unlock(&session->s_mutex);\n\tif (tsession) {\n\t\tmutex_unlock(&tsession->s_mutex);\n\t\tceph_put_mds_session(tsession);\n\t}\n\tif (new_cap)\n\t\tceph_put_cap(mdsc, new_cap);\n}\n\n \nstatic void handle_cap_import(struct ceph_mds_client *mdsc,\n\t\t\t      struct inode *inode, struct ceph_mds_caps *im,\n\t\t\t      struct ceph_mds_cap_peer *ph,\n\t\t\t      struct ceph_mds_session *session,\n\t\t\t      struct ceph_cap **target_cap, int *old_issued)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap, *ocap, *new_cap = NULL;\n\tint mds = session->s_mds;\n\tint issued;\n\tunsigned caps = le32_to_cpu(im->caps);\n\tunsigned wanted = le32_to_cpu(im->wanted);\n\tunsigned seq = le32_to_cpu(im->seq);\n\tunsigned mseq = le32_to_cpu(im->migrate_seq);\n\tu64 realmino = le64_to_cpu(im->realm);\n\tu64 cap_id = le64_to_cpu(im->cap_id);\n\tu64 p_cap_id;\n\tint peer;\n\n\tif (ph) {\n\t\tp_cap_id = le64_to_cpu(ph->cap_id);\n\t\tpeer = le32_to_cpu(ph->mds);\n\t} else {\n\t\tp_cap_id = 0;\n\t\tpeer = -1;\n\t}\n\n\tdout(\"handle_cap_import inode %p ci %p mds%d mseq %d peer %d\\n\",\n\t     inode, ci, mds, mseq, peer);\nretry:\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap) {\n\t\tif (!new_cap) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tnew_cap = ceph_get_cap(mdsc, NULL);\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tgoto retry;\n\t\t}\n\t\tcap = new_cap;\n\t} else {\n\t\tif (new_cap) {\n\t\t\tceph_put_cap(mdsc, new_cap);\n\t\t\tnew_cap = NULL;\n\t\t}\n\t}\n\n\t__ceph_caps_issued(ci, &issued);\n\tissued |= __ceph_caps_dirty(ci);\n\n\tceph_add_cap(inode, session, cap_id, caps, wanted, seq, mseq,\n\t\t     realmino, CEPH_CAP_FLAG_AUTH, &new_cap);\n\n\tocap = peer >= 0 ? __get_cap_for_mds(ci, peer) : NULL;\n\tif (ocap && ocap->cap_id == p_cap_id) {\n\t\tdout(\" remove export cap %p mds%d flags %d\\n\",\n\t\t     ocap, peer, ph->flags);\n\t\tif ((ph->flags & CEPH_CAP_FLAG_AUTH) &&\n\t\t    (ocap->seq != le32_to_cpu(ph->seq) ||\n\t\t     ocap->mseq != le32_to_cpu(ph->mseq))) {\n\t\t\tpr_err_ratelimited(\"handle_cap_import: \"\n\t\t\t\t\t\"mismatched seq/mseq: ino (%llx.%llx) \"\n\t\t\t\t\t\"mds%d seq %d mseq %d importer mds%d \"\n\t\t\t\t\t\"has peer seq %d mseq %d\\n\",\n\t\t\t\t\tceph_vinop(inode), peer, ocap->seq,\n\t\t\t\t\tocap->mseq, mds, le32_to_cpu(ph->seq),\n\t\t\t\t\tle32_to_cpu(ph->mseq));\n\t\t}\n\t\tceph_remove_cap(ocap, (ph->flags & CEPH_CAP_FLAG_RELEASE));\n\t}\n\n\t*old_issued = issued;\n\t*target_cap = cap;\n}\n\n#ifdef CONFIG_FS_ENCRYPTION\nstatic int parse_fscrypt_fields(void **p, void *end,\n\t\t\t\tstruct cap_extra_info *extra)\n{\n\tu32 len;\n\n\tceph_decode_32_safe(p, end, extra->fscrypt_auth_len, bad);\n\tif (extra->fscrypt_auth_len) {\n\t\tceph_decode_need(p, end, extra->fscrypt_auth_len, bad);\n\t\textra->fscrypt_auth = kmalloc(extra->fscrypt_auth_len,\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!extra->fscrypt_auth)\n\t\t\treturn -ENOMEM;\n\t\tceph_decode_copy_safe(p, end, extra->fscrypt_auth,\n\t\t\t\t\textra->fscrypt_auth_len, bad);\n\t}\n\n\tceph_decode_32_safe(p, end, len, bad);\n\tif (len >= sizeof(u64)) {\n\t\tceph_decode_64_safe(p, end, extra->fscrypt_file_size, bad);\n\t\tlen -= sizeof(u64);\n\t}\n\tceph_decode_skip_n(p, end, len, bad);\n\treturn 0;\nbad:\n\treturn -EIO;\n}\n#else\nstatic int parse_fscrypt_fields(void **p, void *end,\n\t\t\t\tstruct cap_extra_info *extra)\n{\n\tu32 len;\n\n\t \n\tceph_decode_32_safe(p, end, len, bad);\n\tif (len)\n\t\tceph_decode_skip_n(p, end, len, bad);\n\tceph_decode_32_safe(p, end, len, bad);\n\tif (len)\n\t\tceph_decode_skip_n(p, end, len, bad);\n\treturn 0;\nbad:\n\treturn -EIO;\n}\n#endif\n\n \nvoid ceph_handle_caps(struct ceph_mds_session *session,\n\t\t      struct ceph_msg *msg)\n{\n\tstruct ceph_mds_client *mdsc = session->s_mdsc;\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_cap *cap;\n\tstruct ceph_mds_caps *h;\n\tstruct ceph_mds_cap_peer *peer = NULL;\n\tstruct ceph_snap_realm *realm = NULL;\n\tint op;\n\tint msg_version = le16_to_cpu(msg->hdr.version);\n\tu32 seq, mseq;\n\tstruct ceph_vino vino;\n\tvoid *snaptrace;\n\tsize_t snaptrace_len;\n\tvoid *p, *end;\n\tstruct cap_extra_info extra_info = {};\n\tbool queue_trunc;\n\tbool close_sessions = false;\n\tbool do_cap_release = false;\n\n\tdout(\"handle_caps from mds%d\\n\", session->s_mds);\n\n\tif (!ceph_inc_mds_stopping_blocker(mdsc, session))\n\t\treturn;\n\n\t \n\tend = msg->front.iov_base + msg->front.iov_len;\n\tif (msg->front.iov_len < sizeof(*h))\n\t\tgoto bad;\n\th = msg->front.iov_base;\n\top = le32_to_cpu(h->op);\n\tvino.ino = le64_to_cpu(h->ino);\n\tvino.snap = CEPH_NOSNAP;\n\tseq = le32_to_cpu(h->seq);\n\tmseq = le32_to_cpu(h->migrate_seq);\n\n\tsnaptrace = h + 1;\n\tsnaptrace_len = le32_to_cpu(h->snap_trace_len);\n\tp = snaptrace + snaptrace_len;\n\n\tif (msg_version >= 2) {\n\t\tu32 flock_len;\n\t\tceph_decode_32_safe(&p, end, flock_len, bad);\n\t\tif (p + flock_len > end)\n\t\t\tgoto bad;\n\t\tp += flock_len;\n\t}\n\n\tif (msg_version >= 3) {\n\t\tif (op == CEPH_CAP_OP_IMPORT) {\n\t\t\tif (p + sizeof(*peer) > end)\n\t\t\t\tgoto bad;\n\t\t\tpeer = p;\n\t\t\tp += sizeof(*peer);\n\t\t} else if (op == CEPH_CAP_OP_EXPORT) {\n\t\t\t \n\t\t\tpeer = (void *)&h->size;\n\t\t}\n\t}\n\n\tif (msg_version >= 4) {\n\t\tceph_decode_64_safe(&p, end, extra_info.inline_version, bad);\n\t\tceph_decode_32_safe(&p, end, extra_info.inline_len, bad);\n\t\tif (p + extra_info.inline_len > end)\n\t\t\tgoto bad;\n\t\textra_info.inline_data = p;\n\t\tp += extra_info.inline_len;\n\t}\n\n\tif (msg_version >= 5) {\n\t\tstruct ceph_osd_client\t*osdc = &mdsc->fsc->client->osdc;\n\t\tu32\t\t\tepoch_barrier;\n\n\t\tceph_decode_32_safe(&p, end, epoch_barrier, bad);\n\t\tceph_osdc_update_epoch_barrier(osdc, epoch_barrier);\n\t}\n\n\tif (msg_version >= 8) {\n\t\tu32 pool_ns_len;\n\n\t\t \n\t\tceph_decode_skip_64(&p, end, bad);\t \n\t\t \n\t\tceph_decode_skip_32(&p, end, bad);\t \n\t\tceph_decode_skip_32(&p, end, bad);\t \n\t\t \n\t\tceph_decode_32_safe(&p, end, pool_ns_len, bad);\n\t\tif (pool_ns_len > 0) {\n\t\t\tceph_decode_need(&p, end, pool_ns_len, bad);\n\t\t\textra_info.pool_ns =\n\t\t\t\tceph_find_or_create_string(p, pool_ns_len);\n\t\t\tp += pool_ns_len;\n\t\t}\n\t}\n\n\tif (msg_version >= 9) {\n\t\tstruct ceph_timespec *btime;\n\n\t\tif (p + sizeof(*btime) > end)\n\t\t\tgoto bad;\n\t\tbtime = p;\n\t\tceph_decode_timespec64(&extra_info.btime, btime);\n\t\tp += sizeof(*btime);\n\t\tceph_decode_64_safe(&p, end, extra_info.change_attr, bad);\n\t}\n\n\tif (msg_version >= 11) {\n\t\t \n\t\tceph_decode_skip_32(&p, end, bad);  \n\t\t \n\t\textra_info.dirstat_valid = true;\n\t\tceph_decode_64_safe(&p, end, extra_info.nfiles, bad);\n\t\tceph_decode_64_safe(&p, end, extra_info.nsubdirs, bad);\n\t}\n\n\tif (msg_version >= 12) {\n\t\tif (parse_fscrypt_fields(&p, end, &extra_info))\n\t\t\tgoto bad;\n\t}\n\n\t \n\tinode = ceph_find_inode(mdsc->fsc->sb, vino);\n\tdout(\" op %s ino %llx.%llx inode %p\\n\", ceph_cap_op_name(op), vino.ino,\n\t     vino.snap, inode);\n\n\tmutex_lock(&session->s_mutex);\n\tdout(\" mds%d seq %lld cap seq %u\\n\", session->s_mds, session->s_seq,\n\t     (unsigned)seq);\n\n\tif (!inode) {\n\t\tdout(\" i don't have ino %llx\\n\", vino.ino);\n\n\t\tswitch (op) {\n\t\tcase CEPH_CAP_OP_IMPORT:\n\t\tcase CEPH_CAP_OP_REVOKE:\n\t\tcase CEPH_CAP_OP_GRANT:\n\t\t\tdo_cap_release = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tgoto flush_cap_releases;\n\t}\n\tci = ceph_inode(inode);\n\n\t \n\tswitch (op) {\n\tcase CEPH_CAP_OP_FLUSHSNAP_ACK:\n\t\thandle_cap_flushsnap_ack(inode, le64_to_cpu(msg->hdr.tid),\n\t\t\t\t\t h, session);\n\t\tgoto done;\n\n\tcase CEPH_CAP_OP_EXPORT:\n\t\thandle_cap_export(inode, h, peer, session);\n\t\tgoto done_unlocked;\n\n\tcase CEPH_CAP_OP_IMPORT:\n\t\trealm = NULL;\n\t\tif (snaptrace_len) {\n\t\t\tdown_write(&mdsc->snap_rwsem);\n\t\t\tif (ceph_update_snap_trace(mdsc, snaptrace,\n\t\t\t\t\t\t   snaptrace + snaptrace_len,\n\t\t\t\t\t\t   false, &realm)) {\n\t\t\t\tup_write(&mdsc->snap_rwsem);\n\t\t\t\tclose_sessions = true;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tdowngrade_write(&mdsc->snap_rwsem);\n\t\t} else {\n\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t}\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\thandle_cap_import(mdsc, inode, h, peer, session,\n\t\t\t\t  &cap, &extra_info.issued);\n\t\thandle_cap_grant(inode, session, cap,\n\t\t\t\t h, msg->middle, &extra_info);\n\t\tif (realm)\n\t\t\tceph_put_snap_realm(mdsc, realm);\n\t\tgoto done_unlocked;\n\t}\n\n\t \n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ceph_inode(inode), session->s_mds);\n\tif (!cap) {\n\t\tdout(\" no cap on %p ino %llx.%llx from mds%d\\n\",\n\t\t     inode, ceph_ino(inode), ceph_snap(inode),\n\t\t     session->s_mds);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tswitch (op) {\n\t\tcase CEPH_CAP_OP_REVOKE:\n\t\tcase CEPH_CAP_OP_GRANT:\n\t\t\tdo_cap_release = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tgoto flush_cap_releases;\n\t}\n\n\t \n\tswitch (op) {\n\tcase CEPH_CAP_OP_REVOKE:\n\tcase CEPH_CAP_OP_GRANT:\n\t\t__ceph_caps_issued(ci, &extra_info.issued);\n\t\textra_info.issued |= __ceph_caps_dirty(ci);\n\t\thandle_cap_grant(inode, session, cap,\n\t\t\t\t h, msg->middle, &extra_info);\n\t\tgoto done_unlocked;\n\n\tcase CEPH_CAP_OP_FLUSH_ACK:\n\t\thandle_cap_flush_ack(inode, le64_to_cpu(msg->hdr.tid),\n\t\t\t\t     h, session, cap);\n\t\tbreak;\n\n\tcase CEPH_CAP_OP_TRUNC:\n\t\tqueue_trunc = handle_cap_trunc(inode, h, session,\n\t\t\t\t\t\t&extra_info);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tif (queue_trunc)\n\t\t\tceph_queue_vmtruncate(inode);\n\t\tbreak;\n\n\tdefault:\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tpr_err(\"ceph_handle_caps: unknown cap op %d %s\\n\", op,\n\t\t       ceph_cap_op_name(op));\n\t}\n\ndone:\n\tmutex_unlock(&session->s_mutex);\ndone_unlocked:\n\tiput(inode);\nout:\n\tceph_dec_mds_stopping_blocker(mdsc);\n\n\tceph_put_string(extra_info.pool_ns);\n\n\t \n\tif (close_sessions)\n\t\tceph_mdsc_close_sessions(mdsc);\n\n\tkfree(extra_info.fscrypt_auth);\n\treturn;\n\nflush_cap_releases:\n\t \n\tif (do_cap_release) {\n\t\tcap = ceph_get_cap(mdsc, NULL);\n\t\tcap->cap_ino = vino.ino;\n\t\tcap->queue_release = 1;\n\t\tcap->cap_id = le64_to_cpu(h->cap_id);\n\t\tcap->mseq = mseq;\n\t\tcap->seq = seq;\n\t\tcap->issue_seq = seq;\n\t\tspin_lock(&session->s_cap_lock);\n\t\t__ceph_queue_cap_release(session, cap);\n\t\tspin_unlock(&session->s_cap_lock);\n\t}\n\tceph_flush_cap_releases(mdsc, session);\n\tgoto done;\n\nbad:\n\tpr_err(\"ceph_handle_caps: corrupt message\\n\");\n\tceph_msg_dump(msg);\n\tgoto out;\n}\n\n \nunsigned long ceph_check_delayed_caps(struct ceph_mds_client *mdsc)\n{\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_mount_options *opt = mdsc->fsc->mount_options;\n\tunsigned long delay_max = opt->caps_wanted_delay_max * HZ;\n\tunsigned long loop_start = jiffies;\n\tunsigned long delay = 0;\n\n\tdout(\"check_delayed_caps\\n\");\n\tspin_lock(&mdsc->cap_delay_lock);\n\twhile (!list_empty(&mdsc->cap_delay_list)) {\n\t\tci = list_first_entry(&mdsc->cap_delay_list,\n\t\t\t\t      struct ceph_inode_info,\n\t\t\t\t      i_cap_delay_list);\n\t\tif (time_before(loop_start, ci->i_hold_caps_max - delay_max)) {\n\t\t\tdout(\"%s caps added recently.  Exiting loop\", __func__);\n\t\t\tdelay = ci->i_hold_caps_max;\n\t\t\tbreak;\n\t\t}\n\t\tif ((ci->i_ceph_flags & CEPH_I_FLUSH) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max))\n\t\t\tbreak;\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\n\t\tinode = igrab(&ci->netfs.inode);\n\t\tif (inode) {\n\t\t\tspin_unlock(&mdsc->cap_delay_lock);\n\t\t\tdout(\"check_delayed_caps on %p\\n\", inode);\n\t\t\tceph_check_caps(ci, 0);\n\t\t\tiput(inode);\n\t\t\tspin_lock(&mdsc->cap_delay_lock);\n\t\t}\n\t}\n\tspin_unlock(&mdsc->cap_delay_lock);\n\n\treturn delay;\n}\n\n \nstatic void flush_dirty_session_caps(struct ceph_mds_session *s)\n{\n\tstruct ceph_mds_client *mdsc = s->s_mdsc;\n\tstruct ceph_inode_info *ci;\n\tstruct inode *inode;\n\n\tdout(\"flush_dirty_caps\\n\");\n\tspin_lock(&mdsc->cap_dirty_lock);\n\twhile (!list_empty(&s->s_cap_dirty)) {\n\t\tci = list_first_entry(&s->s_cap_dirty, struct ceph_inode_info,\n\t\t\t\t      i_dirty_item);\n\t\tinode = &ci->netfs.inode;\n\t\tihold(inode);\n\t\tdout(\"flush_dirty_caps %llx.%llx\\n\", ceph_vinop(inode));\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tceph_wait_on_async_create(inode);\n\t\tceph_check_caps(ci, CHECK_CAPS_FLUSH);\n\t\tiput(inode);\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\tdout(\"flush_dirty_caps done\\n\");\n}\n\nvoid ceph_flush_dirty_caps(struct ceph_mds_client *mdsc)\n{\n\tceph_mdsc_iterate_sessions(mdsc, flush_dirty_session_caps, true);\n}\n\nvoid __ceph_touch_fmode(struct ceph_inode_info *ci,\n\t\t\tstruct ceph_mds_client *mdsc, int fmode)\n{\n\tunsigned long now = jiffies;\n\tif (fmode & CEPH_FILE_MODE_RD)\n\t\tci->i_last_rd = now;\n\tif (fmode & CEPH_FILE_MODE_WR)\n\t\tci->i_last_wr = now;\n\t \n\tif (fmode &&\n\t    __ceph_is_any_real_caps(ci) &&\n\t    list_empty(&ci->i_cap_delay_list))\n\t\t__cap_delay_requeue(mdsc, ci);\n}\n\nvoid ceph_get_fmode(struct ceph_inode_info *ci, int fmode, int count)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(ci->netfs.inode.i_sb);\n\tint bits = (fmode << 1) | 1;\n\tbool already_opened = false;\n\tint i;\n\n\tif (count == 1)\n\t\tatomic64_inc(&mdsc->metric.opened_files);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tfor (i = 0; i < CEPH_FILE_MODE_BITS; i++) {\n\t\t \n\t\tif (i && ci->i_nr_by_mode[i])\n\t\t\talready_opened = true;\n\n\t\tif (bits & (1 << i))\n\t\t\tci->i_nr_by_mode[i] += count;\n\t}\n\n\tif (!already_opened)\n\t\tpercpu_counter_inc(&mdsc->metric.opened_inodes);\n\tspin_unlock(&ci->i_ceph_lock);\n}\n\n \nvoid ceph_put_fmode(struct ceph_inode_info *ci, int fmode, int count)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(ci->netfs.inode.i_sb);\n\tint bits = (fmode << 1) | 1;\n\tbool is_closed = true;\n\tint i;\n\n\tif (count == 1)\n\t\tatomic64_dec(&mdsc->metric.opened_files);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tfor (i = 0; i < CEPH_FILE_MODE_BITS; i++) {\n\t\tif (bits & (1 << i)) {\n\t\t\tBUG_ON(ci->i_nr_by_mode[i] < count);\n\t\t\tci->i_nr_by_mode[i] -= count;\n\t\t}\n\n\t\t \n\t\tif (i && ci->i_nr_by_mode[i])\n\t\t\tis_closed = false;\n\t}\n\n\tif (is_closed)\n\t\tpercpu_counter_dec(&mdsc->metric.opened_inodes);\n\tspin_unlock(&ci->i_ceph_lock);\n}\n\n \nint ceph_drop_caps_for_unlink(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint drop = CEPH_CAP_LINK_SHARED | CEPH_CAP_LINK_EXCL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (inode->i_nlink == 1) {\n\t\tdrop |= ~(__ceph_caps_wanted(ci) | CEPH_CAP_PIN);\n\n\t\tif (__ceph_caps_dirty(ci)) {\n\t\t\tstruct ceph_mds_client *mdsc =\n\t\t\t\tceph_inode_to_client(inode)->mdsc;\n\t\t\t__cap_delay_requeue_front(mdsc, ci);\n\t\t}\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn drop;\n}\n\n \nint ceph_encode_inode_release(void **p, struct inode *inode,\n\t\t\t      int mds, int drop, int unless, int force)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tstruct ceph_mds_request_release *rel = *p;\n\tint used, dirty;\n\tint ret = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tused = __ceph_caps_used(ci);\n\tdirty = __ceph_caps_dirty(ci);\n\n\tdout(\"encode_inode_release %p mds%d used|dirty %s drop %s unless %s\\n\",\n\t     inode, mds, ceph_cap_string(used|dirty), ceph_cap_string(drop),\n\t     ceph_cap_string(unless));\n\n\t \n\tdrop &= ~(used | dirty);\n\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (cap && __cap_is_valid(cap)) {\n\t\tunless &= cap->issued;\n\t\tif (unless) {\n\t\t\tif (unless & CEPH_CAP_AUTH_EXCL)\n\t\t\t\tdrop &= ~CEPH_CAP_AUTH_SHARED;\n\t\t\tif (unless & CEPH_CAP_LINK_EXCL)\n\t\t\t\tdrop &= ~CEPH_CAP_LINK_SHARED;\n\t\t\tif (unless & CEPH_CAP_XATTR_EXCL)\n\t\t\t\tdrop &= ~CEPH_CAP_XATTR_SHARED;\n\t\t\tif (unless & CEPH_CAP_FILE_EXCL)\n\t\t\t\tdrop &= ~CEPH_CAP_FILE_SHARED;\n\t\t}\n\n\t\tif (force || (cap->issued & drop)) {\n\t\t\tif (cap->issued & drop) {\n\t\t\t\tint wanted = __ceph_caps_wanted(ci);\n\t\t\t\tdout(\"encode_inode_release %p cap %p \"\n\t\t\t\t     \"%s -> %s, wanted %s -> %s\\n\", inode, cap,\n\t\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t\t     ceph_cap_string(cap->issued & ~drop),\n\t\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t\t     ceph_cap_string(wanted));\n\n\t\t\t\tcap->issued &= ~drop;\n\t\t\t\tcap->implemented &= ~drop;\n\t\t\t\tcap->mds_wanted = wanted;\n\t\t\t\tif (cap == ci->i_auth_cap &&\n\t\t\t\t    !(wanted & CEPH_CAP_ANY_FILE_WR))\n\t\t\t\t\tci->i_requested_max_size = 0;\n\t\t\t} else {\n\t\t\t\tdout(\"encode_inode_release %p cap %p %s\"\n\t\t\t\t     \" (force)\\n\", inode, cap,\n\t\t\t\t     ceph_cap_string(cap->issued));\n\t\t\t}\n\n\t\t\trel->ino = cpu_to_le64(ceph_ino(inode));\n\t\t\trel->cap_id = cpu_to_le64(cap->cap_id);\n\t\t\trel->seq = cpu_to_le32(cap->seq);\n\t\t\trel->issue_seq = cpu_to_le32(cap->issue_seq);\n\t\t\trel->mseq = cpu_to_le32(cap->mseq);\n\t\t\trel->caps = cpu_to_le32(cap->implemented);\n\t\t\trel->wanted = cpu_to_le32(cap->mds_wanted);\n\t\t\trel->dname_len = 0;\n\t\t\trel->dname_seq = 0;\n\t\t\t*p += sizeof(*rel);\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tdout(\"encode_inode_release %p cap %p %s (noop)\\n\",\n\t\t\t     inode, cap, ceph_cap_string(cap->issued));\n\t\t}\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}\n\n \nint ceph_encode_dentry_release(void **p, struct dentry *dentry,\n\t\t\t       struct inode *dir,\n\t\t\t       int mds, int drop, int unless)\n{\n\tstruct dentry *parent = NULL;\n\tstruct ceph_mds_request_release *rel = *p;\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tint force = 0;\n\tint ret;\n\n\t \n\tspin_lock(&dentry->d_lock);\n\tif (di->lease_session && di->lease_session->s_mds == mds)\n\t\tforce = 1;\n\tif (!dir) {\n\t\tparent = dget(dentry->d_parent);\n\t\tdir = d_inode(parent);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\tret = ceph_encode_inode_release(p, dir, mds, drop, unless, force);\n\tdput(parent);\n\n\tspin_lock(&dentry->d_lock);\n\tif (ret && di->lease_session && di->lease_session->s_mds == mds) {\n\t\tdout(\"encode_dentry_release %p mds%d seq %d\\n\",\n\t\t     dentry, mds, (int)di->lease_seq);\n\t\trel->dname_seq = cpu_to_le32(di->lease_seq);\n\t\t__ceph_mdsc_drop_dentry_lease(dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (IS_ENCRYPTED(dir) && fscrypt_has_encryption_key(dir)) {\n\t\t\tint ret2 = ceph_encode_encrypted_fname(dir, dentry, *p);\n\n\t\t\tif (ret2 < 0)\n\t\t\t\treturn ret2;\n\n\t\t\trel->dname_len = cpu_to_le32(ret2);\n\t\t\t*p += ret2;\n\t\t} else {\n\t\t\trel->dname_len = cpu_to_le32(dentry->d_name.len);\n\t\t\tmemcpy(*p, dentry->d_name.name, dentry->d_name.len);\n\t\t\t*p += dentry->d_name.len;\n\t\t}\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\treturn ret;\n}\n\nstatic int remove_capsnaps(struct ceph_mds_client *mdsc, struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap_snap *capsnap;\n\tint capsnap_release = 0;\n\n\tlockdep_assert_held(&ci->i_ceph_lock);\n\n\tdout(\"removing capsnaps, ci is %p, inode is %p\\n\", ci, inode);\n\n\twhile (!list_empty(&ci->i_cap_snaps)) {\n\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t   struct ceph_cap_snap, ci_item);\n\t\t__ceph_remove_capsnap(inode, capsnap, NULL, NULL);\n\t\tceph_put_snap_context(capsnap->context);\n\t\tceph_put_cap_snap(capsnap);\n\t\tcapsnap_release++;\n\t}\n\twake_up_all(&ci->i_cap_wq);\n\twake_up_all(&mdsc->cap_flushing_wq);\n\treturn capsnap_release;\n}\n\nint ceph_purge_inode_cap(struct inode *inode, struct ceph_cap *cap, bool *invalidate)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tbool is_auth;\n\tbool dirty_dropped = false;\n\tint iputs = 0;\n\n\tlockdep_assert_held(&ci->i_ceph_lock);\n\n\tdout(\"removing cap %p, ci is %p, inode is %p\\n\",\n\t     cap, ci, &ci->netfs.inode);\n\n\tis_auth = (cap == ci->i_auth_cap);\n\t__ceph_remove_cap(cap, false);\n\tif (is_auth) {\n\t\tstruct ceph_cap_flush *cf;\n\n\t\tif (ceph_inode_is_shutdown(inode)) {\n\t\t\tif (inode->i_data.nrpages > 0)\n\t\t\t\t*invalidate = true;\n\t\t\tif (ci->i_wrbuffer_ref > 0)\n\t\t\t\tmapping_set_error(&inode->i_data, -EIO);\n\t\t}\n\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\n\t\t \n\t\twhile (!list_empty(&ci->i_cap_flush_list)) {\n\t\t\tcf = list_first_entry(&ci->i_cap_flush_list,\n\t\t\t\t\t      struct ceph_cap_flush, i_list);\n\t\t\tlist_del_init(&cf->g_list);\n\t\t\tlist_del_init(&cf->i_list);\n\t\t\tif (!cf->is_capsnap)\n\t\t\t\tceph_free_cap_flush(cf);\n\t\t}\n\n\t\tif (!list_empty(&ci->i_dirty_item)) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\" dropping dirty %s state for %p %lld\\n\",\n\t\t\t\tceph_cap_string(ci->i_dirty_caps),\n\t\t\t\tinode, ceph_ino(inode));\n\t\t\tci->i_dirty_caps = 0;\n\t\t\tlist_del_init(&ci->i_dirty_item);\n\t\t\tdirty_dropped = true;\n\t\t}\n\t\tif (!list_empty(&ci->i_flushing_item)) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\" dropping dirty+flushing %s state for %p %lld\\n\",\n\t\t\t\tceph_cap_string(ci->i_flushing_caps),\n\t\t\t\tinode, ceph_ino(inode));\n\t\t\tci->i_flushing_caps = 0;\n\t\t\tlist_del_init(&ci->i_flushing_item);\n\t\t\tmdsc->num_cap_flushing--;\n\t\t\tdirty_dropped = true;\n\t\t}\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\t\tif (dirty_dropped) {\n\t\t\tmapping_set_error(inode->i_mapping, -EIO);\n\n\t\t\tif (ci->i_wrbuffer_ref_head == 0 &&\n\t\t\t    ci->i_wr_ref == 0 &&\n\t\t\t    ci->i_dirty_caps == 0 &&\n\t\t\t    ci->i_flushing_caps == 0) {\n\t\t\t\tceph_put_snap_context(ci->i_head_snapc);\n\t\t\t\tci->i_head_snapc = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (atomic_read(&ci->i_filelock_ref) > 0) {\n\t\t\t \n\t\t\tci->i_ceph_flags |= CEPH_I_ERROR_FILELOCK;\n\t\t\tpr_warn_ratelimited(\" dropping file locks for %p %lld\\n\",\n\t\t\t\t\t    inode, ceph_ino(inode));\n\t\t}\n\n\t\tif (!ci->i_dirty_caps && ci->i_prealloc_cap_flush) {\n\t\t\tcf = ci->i_prealloc_cap_flush;\n\t\t\tci->i_prealloc_cap_flush = NULL;\n\t\t\tif (!cf->is_capsnap)\n\t\t\t\tceph_free_cap_flush(cf);\n\t\t}\n\n\t\tif (!list_empty(&ci->i_cap_snaps))\n\t\t\tiputs = remove_capsnaps(mdsc, inode);\n\t}\n\tif (dirty_dropped)\n\t\t++iputs;\n\treturn iputs;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}