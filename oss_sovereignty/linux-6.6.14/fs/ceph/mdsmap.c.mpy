{
  "module_name": "mdsmap.c",
  "hash_id": "168bd53ad8c2effa69db8eebdce1da897abd62811d30e488026c6138dafaaaf6",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/mdsmap.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/bug.h>\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n\n#include \"super.h\"\n\n#define CEPH_MDS_IS_READY(i, ignore_laggy) \\\n\t(m->m_info[i].state > 0 && ignore_laggy ? true : !m->m_info[i].laggy)\n\nstatic int __mdsmap_get_random_mds(struct ceph_mdsmap *m, bool ignore_laggy)\n{\n\tint n = 0;\n\tint i, j;\n\n\t \n\tfor (i = 0; i < m->possible_max_rank; i++)\n\t\tif (CEPH_MDS_IS_READY(i, ignore_laggy))\n\t\t\tn++;\n\tif (n == 0)\n\t\treturn -1;\n\n\t \n\tn = get_random_u32_below(n);\n\tfor (j = 0, i = 0; i < m->possible_max_rank; i++) {\n\t\tif (CEPH_MDS_IS_READY(i, ignore_laggy))\n\t\t\tj++;\n\t\tif (j > n)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\n \nint ceph_mdsmap_get_random_mds(struct ceph_mdsmap *m)\n{\n\tint mds;\n\n\tmds = __mdsmap_get_random_mds(m, false);\n\tif (mds == m->possible_max_rank || mds == -1)\n\t\tmds = __mdsmap_get_random_mds(m, true);\n\n\treturn mds == m->possible_max_rank ? -1 : mds;\n}\n\n#define __decode_and_drop_type(p, end, type, bad)\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (*p + sizeof(type) > end)\t\t\t\\\n\t\t\tgoto bad;\t\t\t\t\\\n\t\t*p += sizeof(type);\t\t\t\t\\\n\t} while (0)\n\n#define __decode_and_drop_set(p, end, type, bad)\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tu32 n;\t\t\t\t\t\t\\\n\t\tsize_t need;\t\t\t\t\t\\\n\t\tceph_decode_32_safe(p, end, n, bad);\t\t\\\n\t\tneed = sizeof(type) * n;\t\t\t\\\n\t\tceph_decode_need(p, end, need, bad);\t\t\\\n\t\t*p += need;\t\t\t\t\t\\\n\t} while (0)\n\n#define __decode_and_drop_map(p, end, ktype, vtype, bad)\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tu32 n;\t\t\t\t\t\t\\\n\t\tsize_t need;\t\t\t\t\t\\\n\t\tceph_decode_32_safe(p, end, n, bad);\t\t\\\n\t\tneed = (sizeof(ktype) + sizeof(vtype)) * n;\t\\\n\t\tceph_decode_need(p, end, need, bad);\t\t\\\n\t\t*p += need;\t\t\t\t\t\\\n\t} while (0)\n\n\nstatic int __decode_and_drop_compat_set(void **p, void* end)\n{\n\tint i;\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tu32 n;\n\t\tceph_decode_need(p, end, sizeof(u64) + sizeof(u32), bad);\n\t\t \n\t\t*p += sizeof(u64);\n\t\t \n\t\tn = ceph_decode_32(p);\n\t\twhile (n-- > 0) {\n\t\t\tu32 len;\n\t\t\tceph_decode_need(p, end, sizeof(u64) + sizeof(u32),\n\t\t\t\t\t bad);\n\t\t\t*p += sizeof(u64);\n\t\t\tlen = ceph_decode_32(p);\n\t\t\tceph_decode_need(p, end, len, bad);\n\t\t\t*p += len;\n\t\t}\n\t}\n\treturn 0;\nbad:\n\treturn -1;\n}\n\n \nstruct ceph_mdsmap *ceph_mdsmap_decode(void **p, void *end, bool msgr2)\n{\n\tstruct ceph_mdsmap *m;\n\tconst void *start = *p;\n\tint i, j, n;\n\tint err;\n\tu8 mdsmap_v;\n\tu16 mdsmap_ev;\n\tu32 target;\n\n\tm = kzalloc(sizeof(*m), GFP_NOFS);\n\tif (!m)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tceph_decode_need(p, end, 1 + 1, bad);\n\tmdsmap_v = ceph_decode_8(p);\n\t*p += sizeof(u8);\t\t\t \n\tif (mdsmap_v >= 4) {\n\t       u32 mdsmap_len;\n\t       ceph_decode_32_safe(p, end, mdsmap_len, bad);\n\t       if (end < *p + mdsmap_len)\n\t\t       goto bad;\n\t       end = *p + mdsmap_len;\n\t}\n\n\tceph_decode_need(p, end, 8*sizeof(u32) + sizeof(u64), bad);\n\tm->m_epoch = ceph_decode_32(p);\n\tm->m_client_epoch = ceph_decode_32(p);\n\tm->m_last_failure = ceph_decode_32(p);\n\tm->m_root = ceph_decode_32(p);\n\tm->m_session_timeout = ceph_decode_32(p);\n\tm->m_session_autoclose = ceph_decode_32(p);\n\tm->m_max_file_size = ceph_decode_64(p);\n\tm->m_max_mds = ceph_decode_32(p);\n\n\t \n\tm->m_num_active_mds = n = ceph_decode_32(p);\n\n\t \n\tm->possible_max_rank = max(m->m_num_active_mds, m->m_max_mds);\n\n\tm->m_info = kcalloc(m->possible_max_rank, sizeof(*m->m_info), GFP_NOFS);\n\tif (!m->m_info)\n\t\tgoto nomem;\n\n\t \n\tfor (i = 0; i < n; i++) {\n\t\tu64 global_id;\n\t\tu32 namelen;\n\t\ts32 mds, inc, state;\n\t\tu8 info_v;\n\t\tvoid *info_end = NULL;\n\t\tstruct ceph_entity_addr addr;\n\t\tu32 num_export_targets;\n\t\tvoid *pexport_targets = NULL;\n\t\tstruct ceph_timespec laggy_since;\n\t\tstruct ceph_mds_info *info;\n\t\tbool laggy;\n\n\t\tceph_decode_need(p, end, sizeof(u64) + 1, bad);\n\t\tglobal_id = ceph_decode_64(p);\n\t\tinfo_v= ceph_decode_8(p);\n\t\tif (info_v >= 4) {\n\t\t\tu32 info_len;\n\t\t\tceph_decode_need(p, end, 1 + sizeof(u32), bad);\n\t\t\t*p += sizeof(u8);\t \n\t\t\tinfo_len = ceph_decode_32(p);\n\t\t\tinfo_end = *p + info_len;\n\t\t\tif (info_end > end)\n\t\t\t\tgoto bad;\n\t\t}\n\n\t\tceph_decode_need(p, end, sizeof(u64) + sizeof(u32), bad);\n\t\t*p += sizeof(u64);\n\t\tnamelen = ceph_decode_32(p);   \n\t\t*p += namelen;\n\n\t\tceph_decode_32_safe(p, end, mds, bad);\n\t\tceph_decode_32_safe(p, end, inc, bad);\n\t\tceph_decode_32_safe(p, end, state, bad);\n\t\t*p += sizeof(u64);\t\t \n\t\tif (info_v >= 8)\n\t\t\terr = ceph_decode_entity_addrvec(p, end, msgr2, &addr);\n\t\telse\n\t\t\terr = ceph_decode_entity_addr(p, end, &addr);\n\t\tif (err)\n\t\t\tgoto corrupt;\n\n\t\tceph_decode_copy_safe(p, end, &laggy_since, sizeof(laggy_since),\n\t\t\t\t      bad);\n\t\tlaggy = laggy_since.tv_sec != 0 || laggy_since.tv_nsec != 0;\n\t\t*p += sizeof(u32);\n\t\tceph_decode_32_safe(p, end, namelen, bad);\n\t\t*p += namelen;\n\t\tif (info_v >= 2) {\n\t\t\tceph_decode_32_safe(p, end, num_export_targets, bad);\n\t\t\tpexport_targets = *p;\n\t\t\t*p += num_export_targets * sizeof(u32);\n\t\t} else {\n\t\t\tnum_export_targets = 0;\n\t\t}\n\n\t\tif (info_end && *p != info_end) {\n\t\t\tif (*p > info_end)\n\t\t\t\tgoto bad;\n\t\t\t*p = info_end;\n\t\t}\n\n\t\tdout(\"mdsmap_decode %d/%d %lld mds%d.%d %s %s%s\\n\",\n\t\t     i+1, n, global_id, mds, inc,\n\t\t     ceph_pr_addr(&addr),\n\t\t     ceph_mds_state_name(state),\n\t\t     laggy ? \"(laggy)\" : \"\");\n\n\t\tif (mds < 0 || mds >= m->possible_max_rank) {\n\t\t\tpr_warn(\"mdsmap_decode got incorrect mds(%d)\\n\", mds);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (state <= 0) {\n\t\t\tdout(\"mdsmap_decode got incorrect state(%s)\\n\",\n\t\t\t     ceph_mds_state_name(state));\n\t\t\tcontinue;\n\t\t}\n\n\t\tinfo = &m->m_info[mds];\n\t\tinfo->global_id = global_id;\n\t\tinfo->state = state;\n\t\tinfo->addr = addr;\n\t\tinfo->laggy = laggy;\n\t\tinfo->num_export_targets = num_export_targets;\n\t\tif (num_export_targets) {\n\t\t\tinfo->export_targets = kcalloc(num_export_targets,\n\t\t\t\t\t\t       sizeof(u32), GFP_NOFS);\n\t\t\tif (!info->export_targets)\n\t\t\t\tgoto nomem;\n\t\t\tfor (j = 0; j < num_export_targets; j++) {\n\t\t\t\ttarget = ceph_decode_32(&pexport_targets);\n\t\t\t\tinfo->export_targets[j] = target;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo->export_targets = NULL;\n\t\t}\n\t}\n\n\t \n\tceph_decode_32_safe(p, end, n, bad);\n\tm->m_num_data_pg_pools = n;\n\tm->m_data_pg_pools = kcalloc(n, sizeof(u64), GFP_NOFS);\n\tif (!m->m_data_pg_pools)\n\t\tgoto nomem;\n\tceph_decode_need(p, end, sizeof(u64)*(n+1), bad);\n\tfor (i = 0; i < n; i++)\n\t\tm->m_data_pg_pools[i] = ceph_decode_64(p);\n\tm->m_cas_pg_pool = ceph_decode_64(p);\n\tm->m_enabled = m->m_epoch > 1;\n\n\tmdsmap_ev = 1;\n\tif (mdsmap_v >= 2) {\n\t\tceph_decode_16_safe(p, end, mdsmap_ev, bad_ext);\n\t}\n\tif (mdsmap_ev >= 3) {\n\t\tif (__decode_and_drop_compat_set(p, end) < 0)\n\t\t\tgoto bad_ext;\n\t}\n\t \n\tif (mdsmap_ev < 5) {\n\t\t__decode_and_drop_type(p, end, u32, bad_ext);\n\t} else {\n\t\t__decode_and_drop_type(p, end, u64, bad_ext);\n\t}\n\n\t \n\t__decode_and_drop_type(p, end, struct ceph_timespec, bad_ext);\n\t__decode_and_drop_type(p, end, struct ceph_timespec, bad_ext);\n\t__decode_and_drop_type(p, end, u32, bad_ext);\n\n\t \n\t{\n\t\tint num_laggy = 0;\n\t\tceph_decode_32_safe(p, end, n, bad_ext);\n\t\tceph_decode_need(p, end, sizeof(u32) * n, bad_ext);\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\ts32 mds = ceph_decode_32(p);\n\t\t\tif (mds >= 0 && mds < m->possible_max_rank) {\n\t\t\t\tif (m->m_info[mds].laggy)\n\t\t\t\t\tnum_laggy++;\n\t\t\t}\n\t\t}\n\t\tm->m_num_laggy = num_laggy;\n\n\t\tif (n > m->possible_max_rank) {\n\t\t\tvoid *new_m_info = krealloc(m->m_info,\n\t\t\t\t\t\t    n * sizeof(*m->m_info),\n\t\t\t\t\t\t    GFP_NOFS | __GFP_ZERO);\n\t\t\tif (!new_m_info)\n\t\t\t\tgoto nomem;\n\t\t\tm->m_info = new_m_info;\n\t\t}\n\t\tm->possible_max_rank = n;\n\t}\n\n\t \n\t__decode_and_drop_map(p, end, u32, u32, bad_ext);\n\t \n\t__decode_and_drop_map(p, end, u32, u64, bad_ext);\n\t \n\t__decode_and_drop_set(p, end, u32, bad_ext);\n\t \n\t__decode_and_drop_set(p, end, u32, bad_ext);\n\n\tif (mdsmap_ev >= 4) {\n\t\t \n\t\t__decode_and_drop_type(p, end, u32, bad_ext);\n\t}\n\tif (mdsmap_ev >= 6) {\n\t\t \n\t\t__decode_and_drop_type(p, end, u8, bad_ext);\n\t\t \n\t\t__decode_and_drop_type(p, end, u8, bad_ext);\n\t}\n\tif (mdsmap_ev >= 7) {\n\t\t \n\t\t__decode_and_drop_type(p, end, u8, bad_ext);\n\t}\n\tif (mdsmap_ev >= 8) {\n\t\t \n\t\tceph_decode_8_safe(p, end, m->m_enabled, bad_ext);\n\t\t \n\t\tceph_decode_skip_string(p, end, bad_ext);\n\t}\n\t \n\tif (mdsmap_ev >= 9) {\n\t\tsize_t need;\n\t\tceph_decode_32_safe(p, end, n, bad_ext);\n\t\tneed = sizeof(u32) * n;\n\t\tceph_decode_need(p, end, need, bad_ext);\n\t\t*p += need;\n\t\tm->m_damaged = n > 0;\n\t} else {\n\t\tm->m_damaged = false;\n\t}\n\tif (mdsmap_ev >= 17) {\n\t\t \n\t\tceph_decode_skip_string(p, end, bad_ext);\n\t\t \n\t\tceph_decode_skip_32(p, end, bad_ext);\n\t\t \n\t\tceph_decode_skip_32(p, end, bad_ext);\n\t\t \n\t\tceph_decode_skip_8(p, end, bad_ext);\n\t\t \n\t\tceph_decode_skip_set(p, end, 64, bad_ext);\n\t\tceph_decode_64_safe(p, end, m->m_max_xattr_size, bad_ext);\n\t} else {\n\t\t \n\t\tm->m_max_xattr_size = 0;\n\t}\nbad_ext:\n\tdout(\"mdsmap_decode m_enabled: %d, m_damaged: %d, m_num_laggy: %d\\n\",\n\t     !!m->m_enabled, !!m->m_damaged, m->m_num_laggy);\n\t*p = end;\n\tdout(\"mdsmap_decode success epoch %u\\n\", m->m_epoch);\n\treturn m;\nnomem:\n\terr = -ENOMEM;\n\tgoto out_err;\ncorrupt:\n\tpr_err(\"corrupt mdsmap\\n\");\n\tprint_hex_dump(KERN_DEBUG, \"mdsmap: \",\n\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       start, end - start, true);\nout_err:\n\tceph_mdsmap_destroy(m);\n\treturn ERR_PTR(err);\nbad:\n\terr = -EINVAL;\n\tgoto corrupt;\n}\n\nvoid ceph_mdsmap_destroy(struct ceph_mdsmap *m)\n{\n\tint i;\n\n\tif (m->m_info) {\n\t\tfor (i = 0; i < m->possible_max_rank; i++)\n\t\t\tkfree(m->m_info[i].export_targets);\n\t\tkfree(m->m_info);\n\t}\n\tkfree(m->m_data_pg_pools);\n\tkfree(m);\n}\n\nbool ceph_mdsmap_is_cluster_available(struct ceph_mdsmap *m)\n{\n\tint i, nr_active = 0;\n\tif (!m->m_enabled)\n\t\treturn false;\n\tif (m->m_damaged)\n\t\treturn false;\n\tif (m->m_num_laggy == m->m_num_active_mds)\n\t\treturn false;\n\tfor (i = 0; i < m->possible_max_rank; i++) {\n\t\tif (m->m_info[i].state == CEPH_MDS_STATE_ACTIVE)\n\t\t\tnr_active++;\n\t}\n\treturn nr_active > 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}