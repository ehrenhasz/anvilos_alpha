{
  "module_name": "super.h",
  "hash_id": "eced5e79898419053db45194b79e38f2035741758b956a580ff7731454c53cd4",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/super.h",
  "human_readable_source": " \n#ifndef _FS_CEPH_SUPER_H\n#define _FS_CEPH_SUPER_H\n\n#include <linux/ceph/ceph_debug.h>\n\n#include <asm/unaligned.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/posix_acl.h>\n#include <linux/refcount.h>\n#include <linux/security.h>\n#include <linux/netfs.h>\n#include <linux/fscache.h>\n#include <linux/hashtable.h>\n\n#include <linux/ceph/libceph.h>\n#include \"crypto.h\"\n\n \n#define CEPH_BLOCK_SHIFT   22   \n#define CEPH_BLOCK         (1 << CEPH_BLOCK_SHIFT)\n#define CEPH_4K_BLOCK_SHIFT 12   \n\n#define CEPH_MOUNT_OPT_CLEANRECOVER    (1<<1)  \n#define CEPH_MOUNT_OPT_DIRSTAT         (1<<4)  \n#define CEPH_MOUNT_OPT_RBYTES          (1<<5)  \n#define CEPH_MOUNT_OPT_NOASYNCREADDIR  (1<<7)  \n#define CEPH_MOUNT_OPT_INO32           (1<<8)  \n#define CEPH_MOUNT_OPT_DCACHE          (1<<9)  \n#define CEPH_MOUNT_OPT_FSCACHE         (1<<10)  \n#define CEPH_MOUNT_OPT_NOPOOLPERM      (1<<11)  \n#define CEPH_MOUNT_OPT_MOUNTWAIT       (1<<12)  \n#define CEPH_MOUNT_OPT_NOQUOTADF       (1<<13)  \n#define CEPH_MOUNT_OPT_NOCOPYFROM      (1<<14)  \n#define CEPH_MOUNT_OPT_ASYNC_DIROPS    (1<<15)  \n#define CEPH_MOUNT_OPT_NOPAGECACHE     (1<<16)  \n#define CEPH_MOUNT_OPT_SPARSEREAD      (1<<17)  \n\n#define CEPH_MOUNT_OPT_DEFAULT\t\t\t\\\n\t(CEPH_MOUNT_OPT_DCACHE |\t\t\\\n\t CEPH_MOUNT_OPT_NOCOPYFROM |\t\t\\\n\t CEPH_MOUNT_OPT_ASYNC_DIROPS)\n\n#define ceph_set_mount_opt(fsc, opt) \\\n\t(fsc)->mount_options->flags |= CEPH_MOUNT_OPT_##opt\n#define ceph_clear_mount_opt(fsc, opt) \\\n\t(fsc)->mount_options->flags &= ~CEPH_MOUNT_OPT_##opt\n#define ceph_test_mount_opt(fsc, opt) \\\n\t(!!((fsc)->mount_options->flags & CEPH_MOUNT_OPT_##opt))\n\n \n#define CEPH_MAX_READ_SIZE              CEPH_MSG_MAX_DATA_LEN\n \n#define CEPH_MAX_WRITE_SIZE\t\tCEPH_MSG_MAX_DATA_LEN\n#define CEPH_RASIZE_DEFAULT             (8192*1024)     \n#define CEPH_MAX_READDIR_DEFAULT        1024\n#define CEPH_MAX_READDIR_BYTES_DEFAULT  (512*1024)\n#define CEPH_SNAPDIRNAME_DEFAULT        \".snap\"\n\n \n#define CEPH_CAPS_WANTED_DELAY_MIN_DEFAULT      5   \n#define CEPH_CAPS_WANTED_DELAY_MAX_DEFAULT     60   \n\nstruct ceph_mount_options {\n\tunsigned int flags;\n\n\tunsigned int wsize;             \n\tunsigned int rsize;             \n\tunsigned int rasize;            \n\tunsigned int congestion_kb;     \n\tunsigned int caps_wanted_delay_min, caps_wanted_delay_max;\n\tint caps_max;\n\tunsigned int max_readdir;        \n\tunsigned int max_readdir_bytes;  \n\n\tbool new_dev_syntax;\n\n\t \n\n\tchar *snapdir_name;    \n\tchar *mds_namespace;   \n\tchar *server_path;     \n\tchar *fscache_uniq;    \n\tchar *mon_addr;\n\tstruct fscrypt_dummy_policy dummy_enc_policy;\n};\n\n \nenum {\n\tCEPH_MOUNT_MOUNTING,\n\tCEPH_MOUNT_MOUNTED,\n\tCEPH_MOUNT_UNMOUNTING,\n\tCEPH_MOUNT_UNMOUNTED,\n\tCEPH_MOUNT_SHUTDOWN,\n\tCEPH_MOUNT_RECOVER,\n\tCEPH_MOUNT_FENCE_IO,\n};\n\n#define CEPH_ASYNC_CREATE_CONFLICT_BITS 8\n\nstruct ceph_fs_client {\n\tstruct super_block *sb;\n\n\tstruct list_head metric_wakeup;\n\n\tstruct ceph_mount_options *mount_options;\n\tstruct ceph_client *client;\n\n\tint mount_state;\n\n\tbool blocklisted;\n\n\tbool have_copy_from2;\n\n\tu32 filp_gen;\n\tloff_t max_file_size;\n\n\tstruct ceph_mds_client *mdsc;\n\n\tatomic_long_t writeback_count;\n\tbool write_congested;\n\n\tstruct workqueue_struct *inode_wq;\n\tstruct workqueue_struct *cap_wq;\n\n\tDECLARE_HASHTABLE(async_unlink_conflict, CEPH_ASYNC_CREATE_CONFLICT_BITS);\n\tspinlock_t async_unlink_conflict_lock;\n\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *debugfs_dentry_lru, *debugfs_caps;\n\tstruct dentry *debugfs_congestion_kb;\n\tstruct dentry *debugfs_bdi;\n\tstruct dentry *debugfs_mdsc, *debugfs_mdsmap;\n\tstruct dentry *debugfs_status;\n\tstruct dentry *debugfs_mds_sessions;\n\tstruct dentry *debugfs_metrics_dir;\n#endif\n\n#ifdef CONFIG_CEPH_FSCACHE\n\tstruct fscache_volume *fscache;\n#endif\n#ifdef CONFIG_FS_ENCRYPTION\n\tstruct fscrypt_dummy_policy fsc_dummy_enc_policy;\n#endif\n};\n\n \nstruct ceph_cap {\n\tstruct ceph_inode_info *ci;\n\tstruct rb_node ci_node;           \n\tstruct ceph_mds_session *session;\n\tstruct list_head session_caps;    \n\tu64 cap_id;        \n\tunion {\n\t\t \n\t\tstruct {\n\t\t\tint issued;        \n\t\t\tint implemented;   \n\t\t\tint mds;\t   \n\t\t\tint mds_wanted;    \n\t\t};\n\t\t \n\t\tstruct {\n\t\t\tu64 cap_ino;\n\t\t\tint queue_release;\n\t\t};\n\t};\n\tu32 seq, issue_seq, mseq;\n\tu32 cap_gen;       \n\tunsigned long last_used;\n\tstruct list_head caps_item;\n};\n\n#define CHECK_CAPS_AUTHONLY   1   \n#define CHECK_CAPS_FLUSH      2   \n#define CHECK_CAPS_NOINVAL    4   \n\nstruct ceph_cap_flush {\n\tu64 tid;\n\tint caps;\n\tbool wake;  \n\tbool is_capsnap;  \n\tstruct list_head g_list;  \n\tstruct list_head i_list;  \n};\n\n \nstruct ceph_cap_snap {\n\trefcount_t nref;\n\tstruct list_head ci_item;\n\n\tstruct ceph_cap_flush cap_flush;\n\n\tu64 follows;\n\tint issued, dirty;\n\tstruct ceph_snap_context *context;\n\n\tumode_t mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tstruct ceph_buffer *xattr_blob;\n\tu64 xattr_version;\n\n\tu64 size;\n\tu64 change_attr;\n\tstruct timespec64 mtime, atime, ctime, btime;\n\tu64 time_warp_seq;\n\tu64 truncate_size;\n\tu32 truncate_seq;\n\tint writing;    \n\tint dirty_pages;      \n\tbool inline_data;\n\tbool need_flush;\n};\n\nstatic inline void ceph_put_cap_snap(struct ceph_cap_snap *capsnap)\n{\n\tif (refcount_dec_and_test(&capsnap->nref)) {\n\t\tif (capsnap->xattr_blob)\n\t\t\tceph_buffer_put(capsnap->xattr_blob);\n\t\tkmem_cache_free(ceph_cap_snap_cachep, capsnap);\n\t}\n}\n\n \n#define CEPH_MAX_DIRFRAG_REP 4\n\nstruct ceph_inode_frag {\n\tstruct rb_node node;\n\n\t \n\tu32 frag;\n\tint split_by;          \n\n\t \n\tint mds;               \n\tint ndist;             \n\tint dist[CEPH_MAX_DIRFRAG_REP];\n};\n\n \nstruct ceph_inode_xattr {\n\tstruct rb_node node;\n\n\tconst char *name;\n\tint name_len;\n\tconst char *val;\n\tint val_len;\n\tint dirty;\n\n\tint should_free_name;\n\tint should_free_val;\n};\n\n \nstruct ceph_dentry_info {\n\tstruct dentry *dentry;\n\tstruct ceph_mds_session *lease_session;\n\tstruct list_head lease_list;\n\tstruct hlist_node hnode;\n\tunsigned long flags;\n\tint lease_shared_gen;\n\tu32 lease_gen;\n\tu32 lease_seq;\n\tunsigned long lease_renew_after, lease_renew_from;\n\tunsigned long time;\n\tu64 offset;\n};\n\n#define CEPH_DENTRY_REFERENCED\t\t(1 << 0)\n#define CEPH_DENTRY_LEASE_LIST\t\t(1 << 1)\n#define CEPH_DENTRY_SHRINK_LIST\t\t(1 << 2)\n#define CEPH_DENTRY_PRIMARY_LINK\t(1 << 3)\n#define CEPH_DENTRY_ASYNC_UNLINK_BIT\t(4)\n#define CEPH_DENTRY_ASYNC_UNLINK\t(1 << CEPH_DENTRY_ASYNC_UNLINK_BIT)\n#define CEPH_DENTRY_ASYNC_CREATE_BIT\t(5)\n#define CEPH_DENTRY_ASYNC_CREATE\t(1 << CEPH_DENTRY_ASYNC_CREATE_BIT)\n\nstruct ceph_inode_xattrs_info {\n\t \n\tstruct ceph_buffer *blob, *prealloc_blob;\n\n\tstruct rb_root index;\n\tbool dirty;\n\tint count;\n\tint names_size;\n\tint vals_size;\n\tu64 version, index_version;\n};\n\n \nstruct ceph_inode_info {\n\tstruct netfs_inode netfs;  \n\tstruct ceph_vino i_vino;    \n\n\tspinlock_t i_ceph_lock;\n\n\tu64 i_version;\n\tu64 i_inline_version;\n\tu32 i_time_warp_seq;\n\n\tunsigned long i_ceph_flags;\n\tatomic64_t i_release_count;\n\tatomic64_t i_ordered_count;\n\tatomic64_t i_complete_seq[2];\n\n\tstruct ceph_dir_layout i_dir_layout;\n\tstruct ceph_file_layout i_layout;\n\tstruct ceph_file_layout i_cached_layout;\t\n\tchar *i_symlink;\n\n\t \n\tstruct timespec64 i_rctime;\n\tu64 i_rbytes, i_rfiles, i_rsubdirs, i_rsnaps;\n\tu64 i_files, i_subdirs;\n\n\t \n\tu64 i_max_bytes, i_max_files;\n\n\ts32 i_dir_pin;\n\n\tstruct rb_root i_fragtree;\n\tint i_fragtree_nsplits;\n\tstruct mutex i_fragtree_mutex;\n\n\tstruct ceph_inode_xattrs_info i_xattrs;\n\n\t \n\tstruct rb_root i_caps;            \n\tstruct ceph_cap *i_auth_cap;      \n\tunsigned i_dirty_caps, i_flushing_caps;      \n\n\t \n\tstruct list_head i_dirty_item;\n\n\t \n\tstruct list_head i_flushing_item;\n\n\t \n\tstruct ceph_cap_flush *i_prealloc_cap_flush;\n\tstruct list_head i_cap_flush_list;\n\twait_queue_head_t i_cap_wq;       \n\tunsigned long i_hold_caps_max;  \n\tstruct list_head i_cap_delay_list;   \n\tstruct ceph_cap_reservation i_cap_migration_resv;\n\tstruct list_head i_cap_snaps;    \n\tstruct ceph_snap_context *i_head_snapc;   \n\tunsigned i_snap_caps;            \n\n\tunsigned long i_last_rd;\n\tunsigned long i_last_wr;\n\tint i_nr_by_mode[CEPH_FILE_MODE_BITS];   \n\n\tstruct mutex i_truncate_mutex;\n\tu32 i_truncate_seq;         \n\tu64 i_truncate_size;        \n\tint i_truncate_pending;     \n\t \n\tu64 i_truncate_pagecache_size;\n\n\tu64 i_max_size;             \n\tu64 i_reported_size;  \n\tu64 i_wanted_max_size;      \n\tu64 i_requested_max_size;   \n\n\t \n\tint i_pin_ref;\n\tint i_rd_ref, i_rdcache_ref, i_wr_ref, i_wb_ref, i_fx_ref;\n\tint i_wrbuffer_ref, i_wrbuffer_ref_head;\n\tatomic_t i_filelock_ref;\n\tatomic_t i_shared_gen;        \n\tu32 i_rdcache_gen;       \n\tu32 i_rdcache_revoking;  \n\n\tstruct list_head i_unsafe_dirops;  \n\tstruct list_head i_unsafe_iops;    \n\tspinlock_t i_unsafe_lock;\n\n\tunion {\n\t\tstruct ceph_snap_realm *i_snap_realm;  \n\t\tstruct ceph_snapid_map *i_snapid_map;  \n\t};\n\tstruct list_head i_snap_realm_item;\n\tstruct list_head i_snap_flush_item;\n\tstruct timespec64 i_btime;\n\tstruct timespec64 i_snap_btime;\n\n\tstruct work_struct i_work;\n\tunsigned long  i_work_mask;\n\n#ifdef CONFIG_FS_ENCRYPTION\n\tu32 fscrypt_auth_len;\n\tu32 fscrypt_file_len;\n\tu8 *fscrypt_auth;\n\tu8 *fscrypt_file;\n#endif\n};\n\nstruct ceph_netfs_request_data {\n\tint caps;\n\n\t \n\tunsigned int file_ra_pages;\n\n\t \n\tbool file_ra_disabled;\n};\n\nstatic inline struct ceph_inode_info *\nceph_inode(const struct inode *inode)\n{\n\treturn container_of(inode, struct ceph_inode_info, netfs.inode);\n}\n\nstatic inline struct ceph_fs_client *\nceph_inode_to_client(const struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}\n\nstatic inline struct ceph_fs_client *\nceph_sb_to_client(const struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}\n\nstatic inline struct ceph_mds_client *\nceph_sb_to_mdsc(const struct super_block *sb)\n{\n\treturn (struct ceph_mds_client *)ceph_sb_to_client(sb)->mdsc;\n}\n\nstatic inline struct ceph_vino\nceph_vino(const struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino;\n}\n\nstatic inline u32 ceph_ino_to_ino32(u64 vino)\n{\n\tu32 ino = vino & 0xffffffff;\n\tino ^= vino >> 32;\n\tif (!ino)\n\t\tino = 2;\n\treturn ino;\n}\n\n \nstatic inline ino_t ceph_vino_to_ino_t(struct ceph_vino vino)\n{\n\tif (sizeof(ino_t) == sizeof(u32))\n\t\treturn ceph_ino_to_ino32(vino.ino);\n\treturn (ino_t)vino.ino;\n}\n\n \n#define ceph_vinop(i) ceph_inode(i)->i_vino.ino, ceph_inode(i)->i_vino.snap\n\nstatic inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}\n\nstatic inline u64 ceph_snap(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.snap;\n}\n\n \nstatic inline u64 ceph_present_ino(struct super_block *sb, u64 ino)\n{\n\tif (unlikely(ceph_test_mount_opt(ceph_sb_to_client(sb), INO32)))\n\t\treturn ceph_ino_to_ino32(ino);\n\treturn ino;\n}\n\nstatic inline u64 ceph_present_inode(struct inode *inode)\n{\n\treturn ceph_present_ino(inode->i_sb, ceph_ino(inode));\n}\n\nstatic inline int ceph_ino_compare(struct inode *inode, void *data)\n{\n\tstruct ceph_vino *pvino = (struct ceph_vino *)data;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\treturn ci->i_vino.ino == pvino->ino &&\n\t\tci->i_vino.snap == pvino->snap;\n}\n\n \n#define CEPH_MAX_MDS\t\t\t0x100\n#define CEPH_NUM_STRAY\t\t\t10\n#define CEPH_MDS_INO_MDSDIR_OFFSET\t(1 * CEPH_MAX_MDS)\n#define CEPH_MDS_INO_LOG_OFFSET\t\t(2 * CEPH_MAX_MDS)\n#define CEPH_INO_SYSTEM_BASE\t\t((6*CEPH_MAX_MDS) + (CEPH_MAX_MDS * CEPH_NUM_STRAY))\n\nstatic inline bool ceph_vino_is_reserved(const struct ceph_vino vino)\n{\n\tif (vino.ino >= CEPH_INO_SYSTEM_BASE ||\n\t    vino.ino < CEPH_MDS_INO_MDSDIR_OFFSET)\n\t\treturn false;\n\n\t \n\tWARN_RATELIMIT(vino.ino >= CEPH_MDS_INO_LOG_OFFSET,\n\t\t\t\"Attempt to access reserved inode number 0x%llx\",\n\t\t\tvino.ino);\n\treturn true;\n}\n\nstatic inline struct inode *ceph_find_inode(struct super_block *sb,\n\t\t\t\t\t    struct ceph_vino vino)\n{\n\tif (ceph_vino_is_reserved(vino))\n\t\treturn NULL;\n\n\t \n\treturn ilookup5(sb, (unsigned long)vino.ino, ceph_ino_compare, &vino);\n}\n\n\n \n#define CEPH_I_DIR_ORDERED\t(1 << 0)   \n#define CEPH_I_FLUSH\t\t(1 << 2)   \n#define CEPH_I_POOL_PERM\t(1 << 3)   \n#define CEPH_I_POOL_RD\t\t(1 << 4)   \n#define CEPH_I_POOL_WR\t\t(1 << 5)   \n#define CEPH_I_SEC_INITED\t(1 << 6)   \n#define CEPH_I_KICK_FLUSH\t(1 << 7)   \n#define CEPH_I_FLUSH_SNAPS\t(1 << 8)   \n#define CEPH_I_ERROR_WRITE\t(1 << 9)  \n#define CEPH_I_ERROR_FILELOCK\t(1 << 10)  \n#define CEPH_I_ODIRECT\t\t(1 << 11)  \n#define CEPH_ASYNC_CREATE_BIT\t(12)\t   \n#define CEPH_I_ASYNC_CREATE\t(1 << CEPH_ASYNC_CREATE_BIT)\n#define CEPH_I_SHUTDOWN\t\t(1 << 13)  \n#define CEPH_I_ASYNC_CHECK_CAPS\t(1 << 14)  \n\n \n#define CEPH_I_WORK_WRITEBACK\t\t0\n#define CEPH_I_WORK_INVALIDATE_PAGES\t1\n#define CEPH_I_WORK_VMTRUNCATE\t\t2\n#define CEPH_I_WORK_CHECK_CAPS\t\t3\n#define CEPH_I_WORK_FLUSH_SNAPS\t\t4\n\n \nstatic inline void ceph_set_error_write(struct ceph_inode_info *ci)\n{\n\tif (!(READ_ONCE(ci->i_ceph_flags) & CEPH_I_ERROR_WRITE)) {\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tci->i_ceph_flags |= CEPH_I_ERROR_WRITE;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n}\n\nstatic inline void ceph_clear_error_write(struct ceph_inode_info *ci)\n{\n\tif (READ_ONCE(ci->i_ceph_flags) & CEPH_I_ERROR_WRITE) {\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tci->i_ceph_flags &= ~CEPH_I_ERROR_WRITE;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n}\n\nstatic inline void __ceph_dir_set_complete(struct ceph_inode_info *ci,\n\t\t\t\t\t   long long release_count,\n\t\t\t\t\t   long long ordered_count)\n{\n\t \n\tsmp_mb();\n\tatomic64_set(&ci->i_complete_seq[0], release_count);\n\tatomic64_set(&ci->i_complete_seq[1], ordered_count);\n}\n\nstatic inline void __ceph_dir_clear_complete(struct ceph_inode_info *ci)\n{\n\tatomic64_inc(&ci->i_release_count);\n}\n\nstatic inline void __ceph_dir_clear_ordered(struct ceph_inode_info *ci)\n{\n\tatomic64_inc(&ci->i_ordered_count);\n}\n\nstatic inline bool __ceph_dir_is_complete(struct ceph_inode_info *ci)\n{\n\treturn atomic64_read(&ci->i_complete_seq[0]) ==\n\t\tatomic64_read(&ci->i_release_count);\n}\n\nstatic inline bool __ceph_dir_is_complete_ordered(struct ceph_inode_info *ci)\n{\n\treturn  atomic64_read(&ci->i_complete_seq[0]) ==\n\t\tatomic64_read(&ci->i_release_count) &&\n\t\tatomic64_read(&ci->i_complete_seq[1]) ==\n\t\tatomic64_read(&ci->i_ordered_count);\n}\n\nstatic inline void ceph_dir_clear_complete(struct inode *inode)\n{\n\t__ceph_dir_clear_complete(ceph_inode(inode));\n}\n\nstatic inline void ceph_dir_clear_ordered(struct inode *inode)\n{\n\t__ceph_dir_clear_ordered(ceph_inode(inode));\n}\n\nstatic inline bool ceph_dir_is_complete_ordered(struct inode *inode)\n{\n\tbool ret = __ceph_dir_is_complete_ordered(ceph_inode(inode));\n\tsmp_rmb();\n\treturn ret;\n}\n\n \nextern struct ceph_inode_frag *__ceph_find_frag(struct ceph_inode_info *ci,\n\t\t\t\t\t\tu32 f);\n\n \nextern u32 ceph_choose_frag(struct ceph_inode_info *ci, u32 v,\n\t\t\t    struct ceph_inode_frag *pfrag,\n\t\t\t    int *found);\n\nstatic inline struct ceph_dentry_info *ceph_dentry(const struct dentry *dentry)\n{\n\treturn (struct ceph_dentry_info *)dentry->d_fsdata;\n}\n\n \nstatic inline bool __ceph_is_any_real_caps(struct ceph_inode_info *ci)\n{\n\treturn !RB_EMPTY_ROOT(&ci->i_caps);\n}\n\nextern int __ceph_caps_issued(struct ceph_inode_info *ci, int *implemented);\nextern int __ceph_caps_issued_mask(struct ceph_inode_info *ci, int mask, int t);\nextern int __ceph_caps_issued_mask_metric(struct ceph_inode_info *ci, int mask,\n\t\t\t\t\t  int t);\nextern int __ceph_caps_issued_other(struct ceph_inode_info *ci,\n\t\t\t\t    struct ceph_cap *cap);\n\nstatic inline int ceph_caps_issued(struct ceph_inode_info *ci)\n{\n\tint issued;\n\tspin_lock(&ci->i_ceph_lock);\n\tissued = __ceph_caps_issued(ci, NULL);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn issued;\n}\n\nstatic inline int ceph_caps_issued_mask_metric(struct ceph_inode_info *ci,\n\t\t\t\t\t       int mask, int touch)\n{\n\tint r;\n\tspin_lock(&ci->i_ceph_lock);\n\tr = __ceph_caps_issued_mask_metric(ci, mask, touch);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn r;\n}\n\nstatic inline int __ceph_caps_dirty(struct ceph_inode_info *ci)\n{\n\treturn ci->i_dirty_caps | ci->i_flushing_caps;\n}\nextern struct ceph_cap_flush *ceph_alloc_cap_flush(void);\nextern void ceph_free_cap_flush(struct ceph_cap_flush *cf);\nextern int __ceph_mark_dirty_caps(struct ceph_inode_info *ci, int mask,\n\t\t\t\t  struct ceph_cap_flush **pcf);\n\nextern int __ceph_caps_revoking_other(struct ceph_inode_info *ci,\n\t\t\t\t      struct ceph_cap *ocap, int mask);\nextern int ceph_caps_revoking(struct ceph_inode_info *ci, int mask);\nextern int __ceph_caps_used(struct ceph_inode_info *ci);\n\nstatic inline bool __ceph_is_file_opened(struct ceph_inode_info *ci)\n{\n\treturn ci->i_nr_by_mode[0];\n}\nextern int __ceph_caps_file_wanted(struct ceph_inode_info *ci);\nextern int __ceph_caps_wanted(struct ceph_inode_info *ci);\n\n \nextern int __ceph_caps_mds_wanted(struct ceph_inode_info *ci, bool check);\n\nextern void ceph_caps_init(struct ceph_mds_client *mdsc);\nextern void ceph_caps_finalize(struct ceph_mds_client *mdsc);\nextern void ceph_adjust_caps_max_min(struct ceph_mds_client *mdsc,\n\t\t\t\t     struct ceph_mount_options *fsopt);\nextern int ceph_reserve_caps(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_cap_reservation *ctx, int need);\nextern void ceph_unreserve_caps(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_cap_reservation *ctx);\nextern void ceph_reservation_status(struct ceph_fs_client *client,\n\t\t\t\t    int *total, int *avail, int *used,\n\t\t\t\t    int *reserved, int *min);\nextern void change_auth_cap_ses(struct ceph_inode_info *ci,\n\t\t\t\tstruct ceph_mds_session *session);\n\n\n\n \n#define CEPH_F_SYNC     1\n#define CEPH_F_ATEND    2\n\nstruct ceph_file_info {\n\tshort fmode;      \n\tshort flags;      \n\n\tspinlock_t rw_contexts_lock;\n\tstruct list_head rw_contexts;\n\n\tu32 filp_gen;\n};\n\nstruct ceph_dir_file_info {\n\tstruct ceph_file_info file_info;\n\n\t \n\tu32 frag;\n\tstruct ceph_mds_request *last_readdir;\n\n\t \n\tunsigned next_offset;   \n\tchar *last_name;        \n\tlong long dir_release_count;\n\tlong long dir_ordered_count;\n\tint readdir_cache_idx;\n\n\t \n\tchar *dir_info;\n\tint dir_info_len;\n};\n\nstruct ceph_rw_context {\n\tstruct list_head list;\n\tstruct task_struct *thread;\n\tint caps;\n};\n\n#define CEPH_DEFINE_RW_CONTEXT(_name, _caps)\t\\\n\tstruct ceph_rw_context _name = {\t\\\n\t\t.thread = current,\t\t\\\n\t\t.caps = _caps,\t\t\t\\\n\t}\n\nstatic inline void ceph_add_rw_context(struct ceph_file_info *cf,\n\t\t\t\t       struct ceph_rw_context *ctx)\n{\n\tspin_lock(&cf->rw_contexts_lock);\n\tlist_add(&ctx->list, &cf->rw_contexts);\n\tspin_unlock(&cf->rw_contexts_lock);\n}\n\nstatic inline void ceph_del_rw_context(struct ceph_file_info *cf,\n\t\t\t\t       struct ceph_rw_context *ctx)\n{\n\tspin_lock(&cf->rw_contexts_lock);\n\tlist_del(&ctx->list);\n\tspin_unlock(&cf->rw_contexts_lock);\n}\n\nstatic inline struct ceph_rw_context*\nceph_find_rw_context(struct ceph_file_info *cf)\n{\n\tstruct ceph_rw_context *ctx, *found = NULL;\n\tspin_lock(&cf->rw_contexts_lock);\n\tlist_for_each_entry(ctx, &cf->rw_contexts, list) {\n\t\tif (ctx->thread == current) {\n\t\t\tfound = ctx;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&cf->rw_contexts_lock);\n\treturn found;\n}\n\nstruct ceph_readdir_cache_control {\n\tstruct page  *page;\n\tstruct dentry **dentries;\n\tint index;\n};\n\n \nstruct ceph_snap_realm {\n\tu64 ino;\n\tstruct inode *inode;\n\tatomic_t nref;\n\tstruct rb_node node;\n\n\tu64 created, seq;\n\tu64 parent_ino;\n\tu64 parent_since;    \n\n\tu64 *prior_parent_snaps;       \n\tu32 num_prior_parent_snaps;    \n\tu64 *snaps;                    \n\tu32 num_snaps;\n\n\tstruct ceph_snap_realm *parent;\n\tstruct list_head children;        \n\tstruct list_head child_item;\n\n\tstruct list_head empty_item;      \n\n\tstruct list_head dirty_item;      \n\n\tstruct list_head rebuild_item;    \n\n\t \n\tstruct ceph_snap_context *cached_context;\n\n\tstruct list_head inodes_with_caps;\n\tspinlock_t inodes_with_caps_lock;\n};\n\nstatic inline int default_congestion_kb(void)\n{\n\tint congestion_kb;\n\n\t \n\tcongestion_kb = (16*int_sqrt(totalram_pages())) << (PAGE_SHIFT-10);\n\tif (congestion_kb > 256*1024)\n\t\tcongestion_kb = 256*1024;\n\n\treturn congestion_kb;\n}\n\n\n \nextern int ceph_force_reconnect(struct super_block *sb);\n \nstruct ceph_snap_realm *ceph_lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t       u64 ino);\nextern void ceph_get_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\tstruct ceph_snap_realm *realm);\nextern void ceph_put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\tstruct ceph_snap_realm *realm);\nextern int ceph_update_snap_trace(struct ceph_mds_client *m,\n\t\t\t\t  void *p, void *e, bool deletion,\n\t\t\t\t  struct ceph_snap_realm **realm_ret);\nvoid ceph_change_snap_realm(struct inode *inode, struct ceph_snap_realm *realm);\nextern void ceph_handle_snap(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_session *session,\n\t\t\t     struct ceph_msg *msg);\nextern int __ceph_finish_cap_snap(struct ceph_inode_info *ci,\n\t\t\t\t  struct ceph_cap_snap *capsnap);\nextern void ceph_cleanup_global_and_empty_realms(struct ceph_mds_client *mdsc);\n\nextern struct ceph_snapid_map *ceph_get_snapid_map(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   u64 snap);\nextern void ceph_put_snapid_map(struct ceph_mds_client* mdsc,\n\t\t\t\tstruct ceph_snapid_map *sm);\nextern void ceph_trim_snapid_map(struct ceph_mds_client *mdsc);\nextern void ceph_cleanup_snapid_map(struct ceph_mds_client *mdsc);\nvoid ceph_umount_begin(struct super_block *sb);\n\n\n \nstatic inline bool __ceph_have_pending_cap_snap(struct ceph_inode_info *ci)\n{\n\treturn !list_empty(&ci->i_cap_snaps) &&\n\t       list_last_entry(&ci->i_cap_snaps, struct ceph_cap_snap,\n\t\t\t       ci_item)->writing;\n}\n\n \nstruct ceph_mds_reply_info_in;\nstruct ceph_mds_reply_dirfrag;\nstruct ceph_acl_sec_ctx;\n\nextern const struct inode_operations ceph_file_iops;\n\nextern struct inode *ceph_alloc_inode(struct super_block *sb);\nextern void ceph_evict_inode(struct inode *inode);\nextern void ceph_free_inode(struct inode *inode);\n\nstruct inode *ceph_new_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t     umode_t *mode, struct ceph_acl_sec_ctx *as_ctx);\nvoid ceph_as_ctx_to_req(struct ceph_mds_request *req,\n\t\t\tstruct ceph_acl_sec_ctx *as_ctx);\n\nextern struct inode *ceph_get_inode(struct super_block *sb,\n\t\t\t\t    struct ceph_vino vino,\n\t\t\t\t    struct inode *newino);\nextern struct inode *ceph_get_snapdir(struct inode *parent);\nextern int ceph_fill_file_size(struct inode *inode, int issued,\n\t\t\t       u32 truncate_seq, u64 truncate_size, u64 size);\nextern void ceph_fill_file_time(struct inode *inode, int issued,\n\t\t\t\tu64 time_warp_seq, struct timespec64 *ctime,\n\t\t\t\tstruct timespec64 *mtime,\n\t\t\t\tstruct timespec64 *atime);\nextern int ceph_fill_inode(struct inode *inode, struct page *locked_page,\n\t\t    struct ceph_mds_reply_info_in *iinfo,\n\t\t    struct ceph_mds_reply_dirfrag *dirinfo,\n\t\t    struct ceph_mds_session *session, int cap_fmode,\n\t\t    struct ceph_cap_reservation *caps_reservation);\nextern int ceph_fill_trace(struct super_block *sb,\n\t\t\t   struct ceph_mds_request *req);\nextern int ceph_readdir_prepopulate(struct ceph_mds_request *req,\n\t\t\t\t    struct ceph_mds_session *session);\n\nextern int ceph_inode_holds_cap(struct inode *inode, int mask);\n\nextern bool ceph_inode_set_size(struct inode *inode, loff_t size);\nextern void __ceph_do_pending_vmtruncate(struct inode *inode);\n\nvoid ceph_queue_inode_work(struct inode *inode, int work_bit);\n\nstatic inline void ceph_queue_vmtruncate(struct inode *inode)\n{\n\tceph_queue_inode_work(inode, CEPH_I_WORK_VMTRUNCATE);\n}\n\nstatic inline void ceph_queue_invalidate(struct inode *inode)\n{\n\tceph_queue_inode_work(inode, CEPH_I_WORK_INVALIDATE_PAGES);\n}\n\nstatic inline void ceph_queue_writeback(struct inode *inode)\n{\n\tceph_queue_inode_work(inode, CEPH_I_WORK_WRITEBACK);\n}\n\nstatic inline void ceph_queue_check_caps(struct inode *inode)\n{\n\tceph_queue_inode_work(inode, CEPH_I_WORK_CHECK_CAPS);\n}\n\nstatic inline void ceph_queue_flush_snaps(struct inode *inode)\n{\n\tceph_queue_inode_work(inode, CEPH_I_WORK_FLUSH_SNAPS);\n}\n\nextern int ceph_try_to_choose_auth_mds(struct inode *inode, int mask);\nextern int __ceph_do_getattr(struct inode *inode, struct page *locked_page,\n\t\t\t     int mask, bool force);\nstatic inline int ceph_do_getattr(struct inode *inode, int mask, bool force)\n{\n\treturn __ceph_do_getattr(inode, NULL, mask, force);\n}\nextern int ceph_permission(struct mnt_idmap *idmap,\n\t\t\t   struct inode *inode, int mask);\n\nstruct ceph_iattr {\n\tstruct ceph_fscrypt_auth\t*fscrypt_auth;\n};\n\nextern int __ceph_setattr(struct inode *inode, struct iattr *attr,\n\t\t\t  struct ceph_iattr *cia);\nextern int ceph_setattr(struct mnt_idmap *idmap,\n\t\t\tstruct dentry *dentry, struct iattr *attr);\nextern int ceph_getattr(struct mnt_idmap *idmap,\n\t\t\tconst struct path *path, struct kstat *stat,\n\t\t\tu32 request_mask, unsigned int flags);\nvoid ceph_inode_shutdown(struct inode *inode);\n\nstatic inline bool ceph_inode_is_shutdown(struct inode *inode)\n{\n\tunsigned long flags = READ_ONCE(ceph_inode(inode)->i_ceph_flags);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tint state = READ_ONCE(fsc->mount_state);\n\n\treturn (flags & CEPH_I_SHUTDOWN) || state >= CEPH_MOUNT_SHUTDOWN;\n}\n\n \nint __ceph_setxattr(struct inode *, const char *, const void *, size_t, int);\nint ceph_do_getvxattr(struct inode *inode, const char *name, void *value, size_t size);\nssize_t __ceph_getxattr(struct inode *, const char *, void *, size_t);\nextern ssize_t ceph_listxattr(struct dentry *, char *, size_t);\nextern struct ceph_buffer *__ceph_build_xattrs_blob(struct ceph_inode_info *ci);\nextern void __ceph_destroy_xattrs(struct ceph_inode_info *ci);\nextern const struct xattr_handler *ceph_xattr_handlers[];\n\nstruct ceph_acl_sec_ctx {\n#ifdef CONFIG_CEPH_FS_POSIX_ACL\n\tvoid *default_acl;\n\tvoid *acl;\n#endif\n#ifdef CONFIG_CEPH_FS_SECURITY_LABEL\n\tvoid *sec_ctx;\n\tu32 sec_ctxlen;\n#endif\n#ifdef CONFIG_FS_ENCRYPTION\n\tstruct ceph_fscrypt_auth *fscrypt_auth;\n#endif\n\tstruct ceph_pagelist *pagelist;\n};\n\n#ifdef CONFIG_SECURITY\nextern bool ceph_security_xattr_deadlock(struct inode *in);\nextern bool ceph_security_xattr_wanted(struct inode *in);\n#else\nstatic inline bool ceph_security_xattr_deadlock(struct inode *in)\n{\n\treturn false;\n}\nstatic inline bool ceph_security_xattr_wanted(struct inode *in)\n{\n\treturn false;\n}\n#endif\n\n#ifdef CONFIG_CEPH_FS_SECURITY_LABEL\nextern int ceph_security_init_secctx(struct dentry *dentry, umode_t mode,\n\t\t\t\t     struct ceph_acl_sec_ctx *ctx);\nstatic inline void ceph_security_invalidate_secctx(struct inode *inode)\n{\n\tsecurity_inode_invalidate_secctx(inode);\n}\n#else\nstatic inline int ceph_security_init_secctx(struct dentry *dentry, umode_t mode,\n\t\t\t\t\t    struct ceph_acl_sec_ctx *ctx)\n{\n\treturn 0;\n}\nstatic inline void ceph_security_invalidate_secctx(struct inode *inode)\n{\n}\n#endif\n\nvoid ceph_release_acl_sec_ctx(struct ceph_acl_sec_ctx *as_ctx);\n\n \n#ifdef CONFIG_CEPH_FS_POSIX_ACL\n\nstruct posix_acl *ceph_get_acl(struct inode *, int, bool);\nint ceph_set_acl(struct mnt_idmap *idmap,\n\t\t struct dentry *dentry, struct posix_acl *acl, int type);\nint ceph_pre_init_acls(struct inode *dir, umode_t *mode,\n\t\t       struct ceph_acl_sec_ctx *as_ctx);\nvoid ceph_init_inode_acls(struct inode *inode,\n\t\t\t  struct ceph_acl_sec_ctx *as_ctx);\n\nstatic inline void ceph_forget_all_cached_acls(struct inode *inode)\n{\n       forget_all_cached_acls(inode);\n}\n\n#else\n\n#define ceph_get_acl NULL\n#define ceph_set_acl NULL\n\nstatic inline int ceph_pre_init_acls(struct inode *dir, umode_t *mode,\n\t\t\t\t     struct ceph_acl_sec_ctx *as_ctx)\n{\n\treturn 0;\n}\nstatic inline void ceph_init_inode_acls(struct inode *inode,\n\t\t\t\t\tstruct ceph_acl_sec_ctx *as_ctx)\n{\n}\nstatic inline int ceph_acl_chmod(struct dentry *dentry, struct inode *inode)\n{\n\treturn 0;\n}\n\nstatic inline void ceph_forget_all_cached_acls(struct inode *inode)\n{\n}\n\n#endif\n\n \nextern const char *ceph_cap_string(int c);\nextern void ceph_handle_caps(struct ceph_mds_session *session,\n\t\t\t     struct ceph_msg *msg);\nextern struct ceph_cap *ceph_get_cap(struct ceph_mds_client *mdsc,\n\t\t\t\t     struct ceph_cap_reservation *ctx);\nextern void ceph_add_cap(struct inode *inode,\n\t\t\t struct ceph_mds_session *session, u64 cap_id,\n\t\t\t unsigned issued, unsigned wanted,\n\t\t\t unsigned cap, unsigned seq, u64 realmino, int flags,\n\t\t\t struct ceph_cap **new_cap);\nextern void __ceph_remove_cap(struct ceph_cap *cap, bool queue_release);\nextern void ceph_remove_cap(struct ceph_cap *cap, bool queue_release);\nextern void __ceph_remove_caps(struct ceph_inode_info *ci);\nextern void ceph_put_cap(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_cap *cap);\nextern int ceph_is_any_caps(struct inode *inode);\n\nextern int ceph_write_inode(struct inode *inode, struct writeback_control *wbc);\nextern int ceph_fsync(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync);\nextern void ceph_early_kick_flushing_caps(struct ceph_mds_client *mdsc,\n\t\t\t\t\t  struct ceph_mds_session *session);\nextern void ceph_kick_flushing_caps(struct ceph_mds_client *mdsc,\n\t\t\t\t    struct ceph_mds_session *session);\nvoid ceph_kick_flushing_inode_caps(struct ceph_mds_session *session,\n\t\t\t\t   struct ceph_inode_info *ci);\nextern struct ceph_cap *__get_cap_for_mds(struct ceph_inode_info *ci,\n\t\t\t\t\t  int mds);\nextern struct ceph_cap *ceph_get_cap_for_mds(struct ceph_inode_info *ci,\n\t\t\t\t\t     int mds);\nextern void ceph_take_cap_refs(struct ceph_inode_info *ci, int caps,\n\t\t\t\tbool snap_rwsem_locked);\nextern void ceph_get_cap_refs(struct ceph_inode_info *ci, int caps);\nextern void ceph_put_cap_refs(struct ceph_inode_info *ci, int had);\nextern void ceph_put_cap_refs_async(struct ceph_inode_info *ci, int had);\nextern void ceph_put_cap_refs_no_check_caps(struct ceph_inode_info *ci,\n\t\t\t\t\t    int had);\nextern void ceph_put_wrbuffer_cap_refs(struct ceph_inode_info *ci, int nr,\n\t\t\t\t       struct ceph_snap_context *snapc);\nextern void __ceph_remove_capsnap(struct inode *inode,\n\t\t\t\t  struct ceph_cap_snap *capsnap,\n\t\t\t\t  bool *wake_ci, bool *wake_mdsc);\nextern void ceph_remove_capsnap(struct inode *inode,\n\t\t\t\tstruct ceph_cap_snap *capsnap,\n\t\t\t\tbool *wake_ci, bool *wake_mdsc);\nextern void ceph_flush_snaps(struct ceph_inode_info *ci,\n\t\t\t     struct ceph_mds_session **psession);\nextern bool __ceph_should_report_size(struct ceph_inode_info *ci);\nextern void ceph_check_caps(struct ceph_inode_info *ci, int flags);\nextern unsigned long ceph_check_delayed_caps(struct ceph_mds_client *mdsc);\nextern void ceph_flush_dirty_caps(struct ceph_mds_client *mdsc);\nextern int  ceph_drop_caps_for_unlink(struct inode *inode);\nextern int ceph_encode_inode_release(void **p, struct inode *inode,\n\t\t\t\t     int mds, int drop, int unless, int force);\nextern int ceph_encode_dentry_release(void **p, struct dentry *dn,\n\t\t\t\t      struct inode *dir,\n\t\t\t\t      int mds, int drop, int unless);\n\nextern int __ceph_get_caps(struct inode *inode, struct ceph_file_info *fi,\n\t\t\t   int need, int want, loff_t endoff, int *got);\nextern int ceph_get_caps(struct file *filp, int need, int want,\n\t\t\t loff_t endoff, int *got);\nextern int ceph_try_get_caps(struct inode *inode,\n\t\t\t     int need, int want, bool nonblock, int *got);\n\n \nextern void ceph_get_fmode(struct ceph_inode_info *ci, int mode, int count);\nextern void ceph_put_fmode(struct ceph_inode_info *ci, int mode, int count);\nextern void __ceph_touch_fmode(struct ceph_inode_info *ci,\n\t\t\t       struct ceph_mds_client *mdsc, int fmode);\n\n \nextern const struct address_space_operations ceph_aops;\nextern const struct netfs_request_ops ceph_netfs_ops;\nextern int ceph_mmap(struct file *file, struct vm_area_struct *vma);\nextern int ceph_uninline_data(struct file *file);\nextern int ceph_pool_perm_check(struct inode *inode, int need);\nextern void ceph_pool_perm_destroy(struct ceph_mds_client* mdsc);\nint ceph_purge_inode_cap(struct inode *inode, struct ceph_cap *cap, bool *invalidate);\n\nstatic inline bool ceph_has_inline_data(struct ceph_inode_info *ci)\n{\n\tif (ci->i_inline_version == CEPH_INLINE_NONE ||\n\t    ci->i_inline_version == 1)  \n\t\treturn false;\n\treturn true;\n}\n\n \nextern const struct file_operations ceph_file_fops;\n\nextern int ceph_renew_caps(struct inode *inode, int fmode);\nextern int ceph_open(struct inode *inode, struct file *file);\nextern int ceph_atomic_open(struct inode *dir, struct dentry *dentry,\n\t\t\t    struct file *file, unsigned flags, umode_t mode);\nextern ssize_t __ceph_sync_read(struct inode *inode, loff_t *ki_pos,\n\t\t\t\tstruct iov_iter *to, int *retry_op,\n\t\t\t\tu64 *last_objver);\nextern int ceph_release(struct inode *inode, struct file *filp);\nextern void ceph_fill_inline_data(struct inode *inode, struct page *locked_page,\n\t\t\t\t  char *data, size_t len);\n\n \nextern const struct file_operations ceph_dir_fops;\nextern const struct file_operations ceph_snapdir_fops;\nextern const struct inode_operations ceph_dir_iops;\nextern const struct inode_operations ceph_snapdir_iops;\nextern const struct dentry_operations ceph_dentry_ops;\n\nextern loff_t ceph_make_fpos(unsigned high, unsigned off, bool hash_order);\nextern int ceph_handle_notrace_create(struct inode *dir, struct dentry *dentry);\nextern struct dentry *ceph_handle_snapdir(struct ceph_mds_request *req,\n\t\t\t       struct dentry *dentry);\nextern struct dentry *ceph_finish_lookup(struct ceph_mds_request *req,\n\t\t\t\t\t struct dentry *dentry, int err);\n\nextern void __ceph_dentry_lease_touch(struct ceph_dentry_info *di);\nextern void __ceph_dentry_dir_lease_touch(struct ceph_dentry_info *di);\nextern void ceph_invalidate_dentry_lease(struct dentry *dentry);\nextern int ceph_trim_dentries(struct ceph_mds_client *mdsc);\nextern unsigned ceph_dentry_hash(struct inode *dir, struct dentry *dn);\nextern void ceph_readdir_cache_release(struct ceph_readdir_cache_control *ctl);\n\n \nextern long ceph_ioctl(struct file *file, unsigned int cmd, unsigned long arg);\n\n \nextern const struct export_operations ceph_export_ops;\nstruct inode *ceph_lookup_inode(struct super_block *sb, u64 ino);\n\n \nextern __init void ceph_flock_init(void);\nextern int ceph_lock(struct file *file, int cmd, struct file_lock *fl);\nextern int ceph_flock(struct file *file, int cmd, struct file_lock *fl);\nextern void ceph_count_locks(struct inode *inode, int *p_num, int *f_num);\nextern int ceph_encode_locks_to_buffer(struct inode *inode,\n\t\t\t\t       struct ceph_filelock *flocks,\n\t\t\t\t       int num_fcntl_locks,\n\t\t\t\t       int num_flock_locks);\nextern int ceph_locks_to_pagelist(struct ceph_filelock *flocks,\n\t\t\t\t  struct ceph_pagelist *pagelist,\n\t\t\t\t  int num_fcntl_locks, int num_flock_locks);\n\n \nextern void ceph_fs_debugfs_init(struct ceph_fs_client *client);\nextern void ceph_fs_debugfs_cleanup(struct ceph_fs_client *client);\n\n \n\nenum quota_get_realm {\n\tQUOTA_GET_MAX_FILES,\n\tQUOTA_GET_MAX_BYTES,\n\tQUOTA_GET_ANY\n};\n\nstatic inline bool __ceph_has_quota(struct ceph_inode_info *ci,\n\t\t\t\t    enum quota_get_realm which)\n{\n\tbool has_quota = false;\n\n\tswitch (which) {\n\tcase QUOTA_GET_MAX_BYTES:\n\t\thas_quota = !!ci->i_max_bytes;\n\t\tbreak;\n\tcase QUOTA_GET_MAX_FILES:\n\t\thas_quota = !!ci->i_max_files;\n\t\tbreak;\n\tdefault:\n\t\thas_quota = !!(ci->i_max_files || ci->i_max_bytes);\n\t}\n\treturn has_quota;\n}\n\nextern void ceph_adjust_quota_realms_count(struct inode *inode, bool inc);\n\nstatic inline void __ceph_update_quota(struct ceph_inode_info *ci,\n\t\t\t\t       u64 max_bytes, u64 max_files)\n{\n\tbool had_quota, has_quota;\n\thad_quota = __ceph_has_quota(ci, QUOTA_GET_ANY);\n\tci->i_max_bytes = max_bytes;\n\tci->i_max_files = max_files;\n\thas_quota = __ceph_has_quota(ci, QUOTA_GET_ANY);\n\n\tif (had_quota != has_quota)\n\t\tceph_adjust_quota_realms_count(&ci->netfs.inode, has_quota);\n}\n\nextern void ceph_handle_quota(struct ceph_mds_client *mdsc,\n\t\t\t      struct ceph_mds_session *session,\n\t\t\t      struct ceph_msg *msg);\nextern bool ceph_quota_is_max_files_exceeded(struct inode *inode);\nextern bool ceph_quota_is_same_realm(struct inode *old, struct inode *new);\nextern bool ceph_quota_is_max_bytes_exceeded(struct inode *inode,\n\t\t\t\t\t     loff_t newlen);\nextern bool ceph_quota_is_max_bytes_approaching(struct inode *inode,\n\t\t\t\t\t\tloff_t newlen);\nextern bool ceph_quota_update_statfs(struct ceph_fs_client *fsc,\n\t\t\t\t     struct kstatfs *buf);\nextern void ceph_cleanup_quotarealms_inodes(struct ceph_mds_client *mdsc);\n\nbool ceph_inc_mds_stopping_blocker(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *session);\nvoid ceph_dec_mds_stopping_blocker(struct ceph_mds_client *mdsc);\nbool ceph_inc_osd_stopping_blocker(struct ceph_mds_client *mdsc);\nvoid ceph_dec_osd_stopping_blocker(struct ceph_mds_client *mdsc);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}