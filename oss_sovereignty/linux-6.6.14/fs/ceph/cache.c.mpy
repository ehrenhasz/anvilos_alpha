{
  "module_name": "cache.c",
  "hash_id": "b2118d10b9186e31138279fdd654ebae8bb27afa41cc9b90b1408923481d7dfe",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/cache.c",
  "human_readable_source": "\n \n\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/fs_context.h>\n#include \"super.h\"\n#include \"cache.h\"\n\nvoid ceph_fscache_register_inode_cookie(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\n\t \n\tif (!fsc->fscache)\n\t\treturn;\n\n\t \n\tif (!S_ISREG(inode->i_mode))\n\t\treturn;\n\n\t \n\tif (!(inode->i_state & I_NEW))\n\t\treturn;\n\n\tWARN_ON_ONCE(ci->netfs.cache);\n\n\tci->netfs.cache =\n\t\tfscache_acquire_cookie(fsc->fscache, 0,\n\t\t\t\t       &ci->i_vino, sizeof(ci->i_vino),\n\t\t\t\t       &ci->i_version, sizeof(ci->i_version),\n\t\t\t\t       i_size_read(inode));\n\tif (ci->netfs.cache)\n\t\tmapping_set_release_always(inode->i_mapping);\n}\n\nvoid ceph_fscache_unregister_inode_cookie(struct ceph_inode_info *ci)\n{\n\tfscache_relinquish_cookie(ceph_fscache_cookie(ci), false);\n}\n\nvoid ceph_fscache_use_cookie(struct inode *inode, bool will_modify)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tfscache_use_cookie(ceph_fscache_cookie(ci), will_modify);\n}\n\nvoid ceph_fscache_unuse_cookie(struct inode *inode, bool update)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tif (update) {\n\t\tloff_t i_size = i_size_read(inode);\n\n\t\tfscache_unuse_cookie(ceph_fscache_cookie(ci),\n\t\t\t\t     &ci->i_version, &i_size);\n\t} else {\n\t\tfscache_unuse_cookie(ceph_fscache_cookie(ci), NULL, NULL);\n\t}\n}\n\nvoid ceph_fscache_update(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tloff_t i_size = i_size_read(inode);\n\n\tfscache_update_cookie(ceph_fscache_cookie(ci), &ci->i_version, &i_size);\n}\n\nvoid ceph_fscache_invalidate(struct inode *inode, bool dio_write)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tfscache_invalidate(ceph_fscache_cookie(ci),\n\t\t\t   &ci->i_version, i_size_read(inode),\n\t\t\t   dio_write ? FSCACHE_INVAL_DIO_WRITE : 0);\n}\n\nint ceph_fscache_register_fs(struct ceph_fs_client* fsc, struct fs_context *fc)\n{\n\tconst struct ceph_fsid *fsid = &fsc->client->fsid;\n\tconst char *fscache_uniq = fsc->mount_options->fscache_uniq;\n\tsize_t uniq_len = fscache_uniq ? strlen(fscache_uniq) : 0;\n\tchar *name;\n\tint err = 0;\n\n\tname = kasprintf(GFP_KERNEL, \"ceph,%pU%s%s\", fsid, uniq_len ? \",\" : \"\",\n\t\t\t uniq_len ? fscache_uniq : \"\");\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tfsc->fscache = fscache_acquire_volume(name, NULL, NULL, 0);\n\tif (IS_ERR_OR_NULL(fsc->fscache)) {\n\t\terrorfc(fc, \"Unable to register fscache cookie for %s\", name);\n\t\terr = fsc->fscache ? PTR_ERR(fsc->fscache) : -EOPNOTSUPP;\n\t\tfsc->fscache = NULL;\n\t}\n\tkfree(name);\n\treturn err;\n}\n\nvoid ceph_fscache_unregister_fs(struct ceph_fs_client* fsc)\n{\n\tfscache_relinquish_volume(fsc->fscache, NULL, false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}