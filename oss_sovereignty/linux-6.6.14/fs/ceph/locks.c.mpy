{
  "module_name": "locks.c",
  "hash_id": "392950082af379a1dc2805ae3e533c8598520b4816531f7cbc1b37ef070c339b",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/locks.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/random.h>\n\n#include \"super.h\"\n#include \"mds_client.h\"\n#include <linux/filelock.h>\n#include <linux/ceph/pagelist.h>\n\nstatic u64 lock_secret;\nstatic int ceph_lock_wait_for_completion(struct ceph_mds_client *mdsc,\n                                         struct ceph_mds_request *req);\n\nstatic inline u64 secure_addr(void *addr)\n{\n\tu64 v = lock_secret ^ (u64)(unsigned long)addr;\n\t \n\tv |= (1ULL << 63);\n\treturn v;\n}\n\nvoid __init ceph_flock_init(void)\n{\n\tget_random_bytes(&lock_secret, sizeof(lock_secret));\n}\n\nstatic void ceph_fl_copy_lock(struct file_lock *dst, struct file_lock *src)\n{\n\tstruct inode *inode = file_inode(dst->fl_file);\n\tatomic_inc(&ceph_inode(inode)->i_filelock_ref);\n\tdst->fl_u.ceph.inode = igrab(inode);\n}\n\n \nstatic void ceph_fl_release_lock(struct file_lock *fl)\n{\n\tstruct inode *inode = fl->fl_u.ceph.inode;\n\tstruct ceph_inode_info *ci;\n\n\t \n\tif (!inode)\n\t\treturn;\n\n\tci = ceph_inode(inode);\n\tif (atomic_dec_and_test(&ci->i_filelock_ref)) {\n\t\t \n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tci->i_ceph_flags &= ~CEPH_I_ERROR_FILELOCK;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n\tfl->fl_u.ceph.inode = NULL;\n\tiput(inode);\n}\n\nstatic const struct file_lock_operations ceph_fl_lock_ops = {\n\t.fl_copy_lock = ceph_fl_copy_lock,\n\t.fl_release_private = ceph_fl_release_lock,\n};\n\n \nstatic int ceph_lock_message(u8 lock_type, u16 operation, struct inode *inode,\n\t\t\t     int cmd, u8 wait, struct file_lock *fl)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(inode->i_sb);\n\tstruct ceph_mds_request *req;\n\tint err;\n\tu64 length = 0;\n\tu64 owner;\n\n\tif (operation == CEPH_MDS_OP_SETFILELOCK) {\n\t\t \n\t\tfl->fl_ops = &ceph_fl_lock_ops;\n\t\tfl->fl_ops->fl_copy_lock(fl, NULL);\n\t}\n\n\tif (operation != CEPH_MDS_OP_SETFILELOCK || cmd == CEPH_LOCK_UNLOCK)\n\t\twait = 0;\n\n\treq = ceph_mdsc_create_request(mdsc, operation, USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\n\t \n\tif (LLONG_MAX == fl->fl_end)\n\t\tlength = 0;\n\telse\n\t\tlength = fl->fl_end - fl->fl_start + 1;\n\n\towner = secure_addr(fl->fl_owner);\n\n\tdout(\"ceph_lock_message: rule: %d, op: %d, owner: %llx, pid: %llu, \"\n\t     \"start: %llu, length: %llu, wait: %d, type: %d\\n\", (int)lock_type,\n\t     (int)operation, owner, (u64)fl->fl_pid, fl->fl_start, length,\n\t     wait, fl->fl_type);\n\n\treq->r_args.filelock_change.rule = lock_type;\n\treq->r_args.filelock_change.type = cmd;\n\treq->r_args.filelock_change.owner = cpu_to_le64(owner);\n\treq->r_args.filelock_change.pid = cpu_to_le64((u64)fl->fl_pid);\n\treq->r_args.filelock_change.start = cpu_to_le64(fl->fl_start);\n\treq->r_args.filelock_change.length = cpu_to_le64(length);\n\treq->r_args.filelock_change.wait = wait;\n\n\terr = ceph_mdsc_submit_request(mdsc, inode, req);\n\tif (!err)\n\t\terr = ceph_mdsc_wait_request(mdsc, req, wait ?\n\t\t\t\t\tceph_lock_wait_for_completion : NULL);\n\tif (!err && operation == CEPH_MDS_OP_GETFILELOCK) {\n\t\tfl->fl_pid = -le64_to_cpu(req->r_reply_info.filelock_reply->pid);\n\t\tif (CEPH_LOCK_SHARED == req->r_reply_info.filelock_reply->type)\n\t\t\tfl->fl_type = F_RDLCK;\n\t\telse if (CEPH_LOCK_EXCL == req->r_reply_info.filelock_reply->type)\n\t\t\tfl->fl_type = F_WRLCK;\n\t\telse\n\t\t\tfl->fl_type = F_UNLCK;\n\n\t\tfl->fl_start = le64_to_cpu(req->r_reply_info.filelock_reply->start);\n\t\tlength = le64_to_cpu(req->r_reply_info.filelock_reply->start) +\n\t\t\t\t\t\t le64_to_cpu(req->r_reply_info.filelock_reply->length);\n\t\tif (length >= 1)\n\t\t\tfl->fl_end = length -1;\n\t\telse\n\t\t\tfl->fl_end = 0;\n\n\t}\n\tceph_mdsc_put_request(req);\n\tdout(\"ceph_lock_message: rule: %d, op: %d, pid: %llu, start: %llu, \"\n\t     \"length: %llu, wait: %d, type: %d, err code %d\\n\", (int)lock_type,\n\t     (int)operation, (u64)fl->fl_pid, fl->fl_start,\n\t     length, wait, fl->fl_type, err);\n\treturn err;\n}\n\nstatic int ceph_lock_wait_for_completion(struct ceph_mds_client *mdsc,\n                                         struct ceph_mds_request *req)\n{\n\tstruct ceph_mds_request *intr_req;\n\tstruct inode *inode = req->r_inode;\n\tint err, lock_type;\n\n\tBUG_ON(req->r_op != CEPH_MDS_OP_SETFILELOCK);\n\tif (req->r_args.filelock_change.rule == CEPH_LOCK_FCNTL)\n\t\tlock_type = CEPH_LOCK_FCNTL_INTR;\n\telse if (req->r_args.filelock_change.rule == CEPH_LOCK_FLOCK)\n\t\tlock_type = CEPH_LOCK_FLOCK_INTR;\n\telse\n\t\tBUG_ON(1);\n\tBUG_ON(req->r_args.filelock_change.type == CEPH_LOCK_UNLOCK);\n\n\terr = wait_for_completion_interruptible(&req->r_completion);\n\tif (!err)\n\t\treturn 0;\n\n\tdout(\"ceph_lock_wait_for_completion: request %llu was interrupted\\n\",\n\t     req->r_tid);\n\n\tmutex_lock(&mdsc->mutex);\n\tif (test_bit(CEPH_MDS_R_GOT_RESULT, &req->r_req_flags)) {\n\t\terr = 0;\n\t} else {\n\t\t \n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\tset_bit(CEPH_MDS_R_ABORTED, &req->r_req_flags);\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (!req->r_session) {\n\t\t\t \n\t\t\terr = 0;\n\t\t}\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\tif (!err)\n\t\treturn 0;\n\n\tintr_req = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETFILELOCK,\n\t\t\t\t\t    USE_AUTH_MDS);\n\tif (IS_ERR(intr_req))\n\t\treturn PTR_ERR(intr_req);\n\n\tintr_req->r_inode = inode;\n\tihold(inode);\n\tintr_req->r_num_caps = 1;\n\n\tintr_req->r_args.filelock_change = req->r_args.filelock_change;\n\tintr_req->r_args.filelock_change.rule = lock_type;\n\tintr_req->r_args.filelock_change.type = CEPH_LOCK_UNLOCK;\n\n\terr = ceph_mdsc_do_request(mdsc, inode, intr_req);\n\tceph_mdsc_put_request(intr_req);\n\n\tif (err && err != -ERESTARTSYS)\n\t\treturn err;\n\n\twait_for_completion_killable(&req->r_safe_completion);\n\treturn 0;\n}\n\nstatic int try_unlock_file(struct file *file, struct file_lock *fl)\n{\n\tint err;\n\tunsigned int orig_flags = fl->fl_flags;\n\tfl->fl_flags |= FL_EXISTS;\n\terr = locks_lock_file_wait(file, fl);\n\tfl->fl_flags = orig_flags;\n\tif (err == -ENOENT) {\n\t\tif (!(orig_flags & FL_EXISTS))\n\t\t\terr = 0;\n\t\treturn err;\n\t}\n\treturn 1;\n}\n\n \nint ceph_lock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint err = 0;\n\tu16 op = CEPH_MDS_OP_SETFILELOCK;\n\tu8 wait = 0;\n\tu8 lock_cmd;\n\n\tif (!(fl->fl_flags & FL_POSIX))\n\t\treturn -ENOLCK;\n\n\tif (ceph_inode_is_shutdown(inode))\n\t\treturn -ESTALE;\n\n\tdout(\"ceph_lock, fl_owner: %p\\n\", fl->fl_owner);\n\n\t \n\tif (IS_GETLK(cmd))\n\t\top = CEPH_MDS_OP_GETFILELOCK;\n\telse if (IS_SETLKW(cmd))\n\t\twait = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_ceph_flags & CEPH_I_ERROR_FILELOCK) {\n\t\terr = -EIO;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (err < 0) {\n\t\tif (op == CEPH_MDS_OP_SETFILELOCK && F_UNLCK == fl->fl_type)\n\t\t\tposix_lock_file(file, fl, NULL);\n\t\treturn err;\n\t}\n\n\tif (F_RDLCK == fl->fl_type)\n\t\tlock_cmd = CEPH_LOCK_SHARED;\n\telse if (F_WRLCK == fl->fl_type)\n\t\tlock_cmd = CEPH_LOCK_EXCL;\n\telse\n\t\tlock_cmd = CEPH_LOCK_UNLOCK;\n\n\tif (op == CEPH_MDS_OP_SETFILELOCK && F_UNLCK == fl->fl_type) {\n\t\terr = try_unlock_file(file, fl);\n\t\tif (err <= 0)\n\t\t\treturn err;\n\t}\n\n\terr = ceph_lock_message(CEPH_LOCK_FCNTL, op, inode, lock_cmd, wait, fl);\n\tif (!err) {\n\t\tif (op == CEPH_MDS_OP_SETFILELOCK && F_UNLCK != fl->fl_type) {\n\t\t\tdout(\"mds locked, locking locally\\n\");\n\t\t\terr = posix_lock_file(file, fl, NULL);\n\t\t\tif (err) {\n\t\t\t\t \n\t\t\t\tceph_lock_message(CEPH_LOCK_FCNTL, op, inode,\n\t\t\t\t\t\t  CEPH_LOCK_UNLOCK, 0, fl);\n\t\t\t\tdout(\"got %d on posix_lock_file, undid lock\\n\",\n\t\t\t\t     err);\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}\n\nint ceph_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint err = 0;\n\tu8 wait = 0;\n\tu8 lock_cmd;\n\n\tif (!(fl->fl_flags & FL_FLOCK))\n\t\treturn -ENOLCK;\n\n\tif (ceph_inode_is_shutdown(inode))\n\t\treturn -ESTALE;\n\n\tdout(\"ceph_flock, fl_file: %p\\n\", fl->fl_file);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_ceph_flags & CEPH_I_ERROR_FILELOCK) {\n\t\terr = -EIO;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (err < 0) {\n\t\tif (F_UNLCK == fl->fl_type)\n\t\t\tlocks_lock_file_wait(file, fl);\n\t\treturn err;\n\t}\n\n\tif (IS_SETLKW(cmd))\n\t\twait = 1;\n\n\tif (F_RDLCK == fl->fl_type)\n\t\tlock_cmd = CEPH_LOCK_SHARED;\n\telse if (F_WRLCK == fl->fl_type)\n\t\tlock_cmd = CEPH_LOCK_EXCL;\n\telse\n\t\tlock_cmd = CEPH_LOCK_UNLOCK;\n\n\tif (F_UNLCK == fl->fl_type) {\n\t\terr = try_unlock_file(file, fl);\n\t\tif (err <= 0)\n\t\t\treturn err;\n\t}\n\n\terr = ceph_lock_message(CEPH_LOCK_FLOCK, CEPH_MDS_OP_SETFILELOCK,\n\t\t\t\tinode, lock_cmd, wait, fl);\n\tif (!err && F_UNLCK != fl->fl_type) {\n\t\terr = locks_lock_file_wait(file, fl);\n\t\tif (err) {\n\t\t\tceph_lock_message(CEPH_LOCK_FLOCK,\n\t\t\t\t\t  CEPH_MDS_OP_SETFILELOCK,\n\t\t\t\t\t  inode, CEPH_LOCK_UNLOCK, 0, fl);\n\t\t\tdout(\"got %d on locks_lock_file_wait, undid lock\\n\", err);\n\t\t}\n\t}\n\treturn err;\n}\n\n \nvoid ceph_count_locks(struct inode *inode, int *fcntl_count, int *flock_count)\n{\n\tstruct file_lock *lock;\n\tstruct file_lock_context *ctx;\n\n\t*fcntl_count = 0;\n\t*flock_count = 0;\n\n\tctx = locks_inode_context(inode);\n\tif (ctx) {\n\t\tspin_lock(&ctx->flc_lock);\n\t\tlist_for_each_entry(lock, &ctx->flc_posix, fl_list)\n\t\t\t++(*fcntl_count);\n\t\tlist_for_each_entry(lock, &ctx->flc_flock, fl_list)\n\t\t\t++(*flock_count);\n\t\tspin_unlock(&ctx->flc_lock);\n\t}\n\tdout(\"counted %d flock locks and %d fcntl locks\\n\",\n\t     *flock_count, *fcntl_count);\n}\n\n \nstatic int lock_to_ceph_filelock(struct file_lock *lock,\n\t\t\t\t struct ceph_filelock *cephlock)\n{\n\tint err = 0;\n\tcephlock->start = cpu_to_le64(lock->fl_start);\n\tcephlock->length = cpu_to_le64(lock->fl_end - lock->fl_start + 1);\n\tcephlock->client = cpu_to_le64(0);\n\tcephlock->pid = cpu_to_le64((u64)lock->fl_pid);\n\tcephlock->owner = cpu_to_le64(secure_addr(lock->fl_owner));\n\n\tswitch (lock->fl_type) {\n\tcase F_RDLCK:\n\t\tcephlock->type = CEPH_LOCK_SHARED;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tcephlock->type = CEPH_LOCK_EXCL;\n\t\tbreak;\n\tcase F_UNLCK:\n\t\tcephlock->type = CEPH_LOCK_UNLOCK;\n\t\tbreak;\n\tdefault:\n\t\tdout(\"Have unknown lock type %d\\n\", lock->fl_type);\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\n \nint ceph_encode_locks_to_buffer(struct inode *inode,\n\t\t\t\tstruct ceph_filelock *flocks,\n\t\t\t\tint num_fcntl_locks, int num_flock_locks)\n{\n\tstruct file_lock *lock;\n\tstruct file_lock_context *ctx = locks_inode_context(inode);\n\tint err = 0;\n\tint seen_fcntl = 0;\n\tint seen_flock = 0;\n\tint l = 0;\n\n\tdout(\"encoding %d flock and %d fcntl locks\\n\", num_flock_locks,\n\t     num_fcntl_locks);\n\n\tif (!ctx)\n\t\treturn 0;\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(lock, &ctx->flc_posix, fl_list) {\n\t\t++seen_fcntl;\n\t\tif (seen_fcntl > num_fcntl_locks) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto fail;\n\t\t}\n\t\terr = lock_to_ceph_filelock(lock, &flocks[l]);\n\t\tif (err)\n\t\t\tgoto fail;\n\t\t++l;\n\t}\n\tlist_for_each_entry(lock, &ctx->flc_flock, fl_list) {\n\t\t++seen_flock;\n\t\tif (seen_flock > num_flock_locks) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto fail;\n\t\t}\n\t\terr = lock_to_ceph_filelock(lock, &flocks[l]);\n\t\tif (err)\n\t\t\tgoto fail;\n\t\t++l;\n\t}\nfail:\n\tspin_unlock(&ctx->flc_lock);\n\treturn err;\n}\n\n \nint ceph_locks_to_pagelist(struct ceph_filelock *flocks,\n\t\t\t   struct ceph_pagelist *pagelist,\n\t\t\t   int num_fcntl_locks, int num_flock_locks)\n{\n\tint err = 0;\n\t__le32 nlocks;\n\n\tnlocks = cpu_to_le32(num_fcntl_locks);\n\terr = ceph_pagelist_append(pagelist, &nlocks, sizeof(nlocks));\n\tif (err)\n\t\tgoto out_fail;\n\n\tif (num_fcntl_locks > 0) {\n\t\terr = ceph_pagelist_append(pagelist, flocks,\n\t\t\t\t\t   num_fcntl_locks * sizeof(*flocks));\n\t\tif (err)\n\t\t\tgoto out_fail;\n\t}\n\n\tnlocks = cpu_to_le32(num_flock_locks);\n\terr = ceph_pagelist_append(pagelist, &nlocks, sizeof(nlocks));\n\tif (err)\n\t\tgoto out_fail;\n\n\tif (num_flock_locks > 0) {\n\t\terr = ceph_pagelist_append(pagelist, &flocks[num_fcntl_locks],\n\t\t\t\t\t   num_flock_locks * sizeof(*flocks));\n\t}\nout_fail:\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}