{
  "module_name": "ioctl.c",
  "hash_id": "596f0c42b39ce1f1b02a6cf8799853006e7fe71902323528700e684fec0a086c",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/ioctl.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n#include <linux/in.h>\n\n#include \"super.h\"\n#include \"mds_client.h\"\n#include \"ioctl.h\"\n#include <linux/ceph/striper.h>\n#include <linux/fscrypt.h>\n\n \n\n \nstatic long ceph_ioctl_get_layout(struct file *file, void __user *arg)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(file_inode(file));\n\tstruct ceph_ioctl_layout l;\n\tint err;\n\n\terr = ceph_do_getattr(file_inode(file), CEPH_STAT_CAP_LAYOUT, false);\n\tif (!err) {\n\t\tl.stripe_unit = ci->i_layout.stripe_unit;\n\t\tl.stripe_count = ci->i_layout.stripe_count;\n\t\tl.object_size = ci->i_layout.object_size;\n\t\tl.data_pool = ci->i_layout.pool_id;\n\t\tl.preferred_osd = -1;\n\t\tif (copy_to_user(arg, &l, sizeof(l)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn err;\n}\n\nstatic long __validate_layout(struct ceph_mds_client *mdsc,\n\t\t\t      struct ceph_ioctl_layout *l)\n{\n\tint i, err;\n\n\t \n\tif ((l->object_size & ~PAGE_MASK) ||\n\t    (l->stripe_unit & ~PAGE_MASK) ||\n\t    ((unsigned)l->stripe_unit != 0 &&\n\t     ((unsigned)l->object_size % (unsigned)l->stripe_unit)))\n\t\treturn -EINVAL;\n\n\t \n\tmutex_lock(&mdsc->mutex);\n\terr = -EINVAL;\n\tfor (i = 0; i < mdsc->mdsmap->m_num_data_pg_pools; i++)\n\t\tif (mdsc->mdsmap->m_data_pg_pools[i] == l->data_pool) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&mdsc->mutex);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic long ceph_ioctl_set_layout(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct ceph_ioctl_layout l;\n\tstruct ceph_inode_info *ci = ceph_inode(file_inode(file));\n\tstruct ceph_ioctl_layout nl;\n\tint err;\n\n\tif (copy_from_user(&l, arg, sizeof(l)))\n\t\treturn -EFAULT;\n\n\t \n\terr = ceph_do_getattr(file_inode(file), CEPH_STAT_CAP_LAYOUT, false);\n\tif (err)\n\t\treturn err;\n\n\tmemset(&nl, 0, sizeof(nl));\n\tif (l.stripe_count)\n\t\tnl.stripe_count = l.stripe_count;\n\telse\n\t\tnl.stripe_count = ci->i_layout.stripe_count;\n\tif (l.stripe_unit)\n\t\tnl.stripe_unit = l.stripe_unit;\n\telse\n\t\tnl.stripe_unit = ci->i_layout.stripe_unit;\n\tif (l.object_size)\n\t\tnl.object_size = l.object_size;\n\telse\n\t\tnl.object_size = ci->i_layout.object_size;\n\tif (l.data_pool)\n\t\tnl.data_pool = l.data_pool;\n\telse\n\t\tnl.data_pool = ci->i_layout.pool_id;\n\n\t \n\tnl.preferred_osd = -1;\n\n\terr = __validate_layout(mdsc, &nl);\n\tif (err)\n\t\treturn err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETLAYOUT,\n\t\t\t\t       USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\n\treq->r_inode_drop = CEPH_CAP_FILE_SHARED | CEPH_CAP_FILE_EXCL;\n\n\treq->r_args.setlayout.layout.fl_stripe_unit =\n\t\tcpu_to_le32(l.stripe_unit);\n\treq->r_args.setlayout.layout.fl_stripe_count =\n\t\tcpu_to_le32(l.stripe_count);\n\treq->r_args.setlayout.layout.fl_object_size =\n\t\tcpu_to_le32(l.object_size);\n\treq->r_args.setlayout.layout.fl_pg_pool = cpu_to_le32(l.data_pool);\n\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tceph_mdsc_put_request(req);\n\treturn err;\n}\n\n \nstatic long ceph_ioctl_set_layout_policy (struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_mds_request *req;\n\tstruct ceph_ioctl_layout l;\n\tint err;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\n\t \n\tif (copy_from_user(&l, arg, sizeof(l)))\n\t\treturn -EFAULT;\n\n\terr = __validate_layout(mdsc, &l);\n\tif (err)\n\t\treturn err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETDIRLAYOUT,\n\t\t\t\t       USE_AUTH_MDS);\n\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\n\treq->r_args.setlayout.layout.fl_stripe_unit =\n\t\t\tcpu_to_le32(l.stripe_unit);\n\treq->r_args.setlayout.layout.fl_stripe_count =\n\t\t\tcpu_to_le32(l.stripe_count);\n\treq->r_args.setlayout.layout.fl_object_size =\n\t\t\tcpu_to_le32(l.object_size);\n\treq->r_args.setlayout.layout.fl_pg_pool =\n\t\t\tcpu_to_le32(l.data_pool);\n\n\terr = ceph_mdsc_do_request(mdsc, inode, req);\n\tceph_mdsc_put_request(req);\n\treturn err;\n}\n\n \nstatic long ceph_ioctl_get_dataloc(struct file *file, void __user *arg)\n{\n\tstruct ceph_ioctl_dataloc dl;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_sb_to_client(inode->i_sb)->client->osdc;\n\tstruct ceph_object_locator oloc;\n\tCEPH_DEFINE_OID_ONSTACK(oid);\n\tu32 xlen;\n\tu64 tmp;\n\tstruct ceph_pg pgid;\n\tint r;\n\n\t \n\tif (copy_from_user(&dl, arg, sizeof(dl)))\n\t\treturn -EFAULT;\n\n\tdown_read(&osdc->lock);\n\tceph_calc_file_object_mapping(&ci->i_layout, dl.file_offset, 1,\n\t\t\t\t      &dl.object_no, &dl.object_offset, &xlen);\n\tdl.file_offset -= dl.object_offset;\n\tdl.object_size = ci->i_layout.object_size;\n\tdl.block_size = ci->i_layout.stripe_unit;\n\n\t \n\ttmp = dl.object_offset;\n\tdl.block_offset = do_div(tmp, dl.block_size);\n\n\tsnprintf(dl.object_name, sizeof(dl.object_name), \"%llx.%08llx\",\n\t\t ceph_ino(inode), dl.object_no);\n\n\toloc.pool = ci->i_layout.pool_id;\n\toloc.pool_ns = ceph_try_get_string(ci->i_layout.pool_ns);\n\tceph_oid_printf(&oid, \"%s\", dl.object_name);\n\n\tr = ceph_object_locator_to_pg(osdc->osdmap, &oid, &oloc, &pgid);\n\n\tceph_oloc_destroy(&oloc);\n\tif (r < 0) {\n\t\tup_read(&osdc->lock);\n\t\treturn r;\n\t}\n\n\tdl.osd = ceph_pg_to_acting_primary(osdc->osdmap, &pgid);\n\tif (dl.osd >= 0) {\n\t\tstruct ceph_entity_addr *a =\n\t\t\tceph_osd_addr(osdc->osdmap, dl.osd);\n\t\tif (a)\n\t\t\tmemcpy(&dl.osd_addr, &a->in_addr, sizeof(dl.osd_addr));\n\t} else {\n\t\tmemset(&dl.osd_addr, 0, sizeof(dl.osd_addr));\n\t}\n\tup_read(&osdc->lock);\n\n\t \n\tif (copy_to_user(arg, &dl, sizeof(dl)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long ceph_ioctl_lazyio(struct file *file)\n{\n\tstruct ceph_file_info *fi = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\n\tif ((fi->fmode & CEPH_FILE_MODE_LAZY) == 0) {\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tfi->fmode |= CEPH_FILE_MODE_LAZY;\n\t\tci->i_nr_by_mode[ffs(CEPH_FILE_MODE_LAZY)]++;\n\t\t__ceph_touch_fmode(ci, mdsc, fi->fmode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tdout(\"ioctl_layzio: file %p marked lazy\\n\", file);\n\n\t\tceph_check_caps(ci, 0);\n\t} else {\n\t\tdout(\"ioctl_layzio: file %p already lazy\\n\", file);\n\t}\n\treturn 0;\n}\n\nstatic long ceph_ioctl_syncio(struct file *file)\n{\n\tstruct ceph_file_info *fi = file->private_data;\n\n\tfi->flags |= CEPH_F_SYNC;\n\treturn 0;\n}\n\nstatic int vet_mds_for_fscrypt(struct file *file)\n{\n\tint i, ret = -EOPNOTSUPP;\n\tstruct ceph_mds_client\t*mdsc = ceph_sb_to_mdsc(file_inode(file)->i_sb);\n\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tstruct ceph_mds_session *s = mdsc->sessions[i];\n\n\t\tif (!s)\n\t\t\tcontinue;\n\t\tif (test_bit(CEPHFS_FEATURE_ALTERNATE_NAME, &s->s_features))\n\t\t\tret = 0;\n\t\tbreak;\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\treturn ret;\n}\n\nstatic long ceph_set_encryption_policy(struct file *file, unsigned long arg)\n{\n\tint ret, got = 0;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\t \n\tif (ci->i_layout.stripe_count > 1)\n\t\treturn -EINVAL;\n\n\tret = vet_mds_for_fscrypt(file);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ceph_get_caps(file, CEPH_CAP_FILE_SHARED, 0, -1, &got);\n\tif (ret)\n\t\treturn ret;\n\n\tret = fscrypt_ioctl_set_policy(file, (const void __user *)arg);\n\tif (got)\n\t\tceph_put_cap_refs(ci, got);\n\n\treturn ret;\n}\n\nstatic const char *ceph_ioctl_cmd_name(const unsigned int cmd)\n{\n\tswitch (cmd) {\n\tcase CEPH_IOC_GET_LAYOUT:\n\t\treturn \"get_layout\";\n\tcase CEPH_IOC_SET_LAYOUT:\n\t\treturn \"set_layout\";\n\tcase CEPH_IOC_SET_LAYOUT_POLICY:\n\t\treturn \"set_layout_policy\";\n\tcase CEPH_IOC_GET_DATALOC:\n\t\treturn \"get_dataloc\";\n\tcase CEPH_IOC_LAZYIO:\n\t\treturn \"lazyio\";\n\tcase CEPH_IOC_SYNCIO:\n\t\treturn \"syncio\";\n\tcase FS_IOC_SET_ENCRYPTION_POLICY:\n\t\treturn \"set_encryption_policy\";\n\tcase FS_IOC_GET_ENCRYPTION_POLICY:\n\t\treturn \"get_encryption_policy\";\n\tcase FS_IOC_GET_ENCRYPTION_POLICY_EX:\n\t\treturn \"get_encryption_policy_ex\";\n\tcase FS_IOC_ADD_ENCRYPTION_KEY:\n\t\treturn \"add_encryption_key\";\n\tcase FS_IOC_REMOVE_ENCRYPTION_KEY:\n\t\treturn \"remove_encryption_key\";\n\tcase FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS:\n\t\treturn \"remove_encryption_key_all_users\";\n\tcase FS_IOC_GET_ENCRYPTION_KEY_STATUS:\n\t\treturn \"get_encryption_key_status\";\n\tcase FS_IOC_GET_ENCRYPTION_NONCE:\n\t\treturn \"get_encryption_nonce\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nlong ceph_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tint ret;\n\n\tdout(\"ioctl file %p cmd %s arg %lu\\n\", file,\n\t     ceph_ioctl_cmd_name(cmd), arg);\n\tswitch (cmd) {\n\tcase CEPH_IOC_GET_LAYOUT:\n\t\treturn ceph_ioctl_get_layout(file, (void __user *)arg);\n\n\tcase CEPH_IOC_SET_LAYOUT:\n\t\treturn ceph_ioctl_set_layout(file, (void __user *)arg);\n\n\tcase CEPH_IOC_SET_LAYOUT_POLICY:\n\t\treturn ceph_ioctl_set_layout_policy(file, (void __user *)arg);\n\n\tcase CEPH_IOC_GET_DATALOC:\n\t\treturn ceph_ioctl_get_dataloc(file, (void __user *)arg);\n\n\tcase CEPH_IOC_LAZYIO:\n\t\treturn ceph_ioctl_lazyio(file);\n\n\tcase CEPH_IOC_SYNCIO:\n\t\treturn ceph_ioctl_syncio(file);\n\n\tcase FS_IOC_SET_ENCRYPTION_POLICY:\n\t\treturn ceph_set_encryption_policy(file, arg);\n\n\tcase FS_IOC_GET_ENCRYPTION_POLICY:\n\t\tret = vet_mds_for_fscrypt(file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn fscrypt_ioctl_get_policy(file, (void __user *)arg);\n\n\tcase FS_IOC_GET_ENCRYPTION_POLICY_EX:\n\t\tret = vet_mds_for_fscrypt(file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn fscrypt_ioctl_get_policy_ex(file, (void __user *)arg);\n\n\tcase FS_IOC_ADD_ENCRYPTION_KEY:\n\t\tret = vet_mds_for_fscrypt(file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn fscrypt_ioctl_add_key(file, (void __user *)arg);\n\n\tcase FS_IOC_REMOVE_ENCRYPTION_KEY:\n\t\treturn fscrypt_ioctl_remove_key(file, (void __user *)arg);\n\n\tcase FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS:\n\t\treturn fscrypt_ioctl_remove_key_all_users(file,\n\t\t\t\t\t\t\t  (void __user *)arg);\n\n\tcase FS_IOC_GET_ENCRYPTION_KEY_STATUS:\n\t\treturn fscrypt_ioctl_get_key_status(file, (void __user *)arg);\n\n\tcase FS_IOC_GET_ENCRYPTION_NONCE:\n\t\tret = vet_mds_for_fscrypt(file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn fscrypt_ioctl_get_nonce(file, (void __user *)arg);\n\t}\n\n\treturn -ENOTTY;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}