{
  "module_name": "export.c",
  "hash_id": "cbdd82c82863c065e91a3c78887ae17d3b70495e77ad3912af1d0f9b8f9b53c5",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/export.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\n#include \"super.h\"\n#include \"mds_client.h\"\n#include \"crypto.h\"\n\n \nstruct ceph_nfs_fh {\n\tu64 ino;\n} __attribute__ ((packed));\n\n \nstruct ceph_nfs_confh {\n\tu64 ino, parent_ino;\n} __attribute__ ((packed));\n\n \nstruct ceph_nfs_snapfh {\n\tu64 ino;\n\tu64 snapid;\n\tu64 parent_ino;\n\tu32 hash;\n} __attribute__ ((packed));\n\nstatic int ceph_encode_snapfh(struct inode *inode, u32 *rawfh, int *max_len,\n\t\t\t      struct inode *parent_inode)\n{\n\tstatic const int snap_handle_length =\n\t\tsizeof(struct ceph_nfs_snapfh) >> 2;\n\tstruct ceph_nfs_snapfh *sfh = (void *)rawfh;\n\tu64 snapid = ceph_snap(inode);\n\tint ret;\n\tbool no_parent = true;\n\n\tif (*max_len < snap_handle_length) {\n\t\t*max_len = snap_handle_length;\n\t\tret = FILEID_INVALID;\n\t\tgoto out;\n\t}\n\n\tret =  -EINVAL;\n\tif (snapid != CEPH_SNAPDIR) {\n\t\tstruct inode *dir;\n\t\tstruct dentry *dentry = d_find_alias(inode);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\n\t\trcu_read_lock();\n\t\tdir = d_inode_rcu(dentry->d_parent);\n\t\tif (ceph_snap(dir) != CEPH_SNAPDIR) {\n\t\t\tsfh->parent_ino = ceph_ino(dir);\n\t\t\tsfh->hash = ceph_dentry_hash(dir, dentry);\n\t\t\tno_parent = false;\n\t\t}\n\t\trcu_read_unlock();\n\t\tdput(dentry);\n\t}\n\n\tif (no_parent) {\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\tgoto out;\n\t\tsfh->parent_ino = sfh->ino;\n\t\tsfh->hash = 0;\n\t}\n\tsfh->ino = ceph_ino(inode);\n\tsfh->snapid = snapid;\n\n\t*max_len = snap_handle_length;\n\tret = FILEID_BTRFS_WITH_PARENT;\nout:\n\tdout(\"encode_snapfh %llx.%llx ret=%d\\n\", ceph_vinop(inode), ret);\n\treturn ret;\n}\n\nstatic int ceph_encode_fh(struct inode *inode, u32 *rawfh, int *max_len,\n\t\t\t  struct inode *parent_inode)\n{\n\tstatic const int handle_length =\n\t\tsizeof(struct ceph_nfs_fh) >> 2;\n\tstatic const int connected_handle_length =\n\t\tsizeof(struct ceph_nfs_confh) >> 2;\n\tint type;\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP)\n\t\treturn ceph_encode_snapfh(inode, rawfh, max_len, parent_inode);\n\n\tif (parent_inode && (*max_len < connected_handle_length)) {\n\t\t*max_len = connected_handle_length;\n\t\treturn FILEID_INVALID;\n\t} else if (*max_len < handle_length) {\n\t\t*max_len = handle_length;\n\t\treturn FILEID_INVALID;\n\t}\n\n\tif (parent_inode) {\n\t\tstruct ceph_nfs_confh *cfh = (void *)rawfh;\n\t\tdout(\"encode_fh %llx with parent %llx\\n\",\n\t\t     ceph_ino(inode), ceph_ino(parent_inode));\n\t\tcfh->ino = ceph_ino(inode);\n\t\tcfh->parent_ino = ceph_ino(parent_inode);\n\t\t*max_len = connected_handle_length;\n\t\ttype = FILEID_INO32_GEN_PARENT;\n\t} else {\n\t\tstruct ceph_nfs_fh *fh = (void *)rawfh;\n\t\tdout(\"encode_fh %llx\\n\", ceph_ino(inode));\n\t\tfh->ino = ceph_ino(inode);\n\t\t*max_len = handle_length;\n\t\ttype = FILEID_INO32_GEN;\n\t}\n\treturn type;\n}\n\nstatic struct inode *__lookup_inode(struct super_block *sb, u64 ino)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(sb)->mdsc;\n\tstruct inode *inode;\n\tstruct ceph_vino vino;\n\tint err;\n\n\tvino.ino = ino;\n\tvino.snap = CEPH_NOSNAP;\n\n\tif (ceph_vino_is_reserved(vino))\n\t\treturn ERR_PTR(-ESTALE);\n\n\tinode = ceph_find_inode(sb, vino);\n\tif (!inode) {\n\t\tstruct ceph_mds_request *req;\n\t\tint mask;\n\n\t\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPINO,\n\t\t\t\t\t       USE_ANY_MDS);\n\t\tif (IS_ERR(req))\n\t\t\treturn ERR_CAST(req);\n\n\t\tmask = CEPH_STAT_CAP_INODE;\n\t\tif (ceph_security_xattr_wanted(d_inode(sb->s_root)))\n\t\t\tmask |= CEPH_CAP_XATTR_SHARED;\n\t\treq->r_args.lookupino.mask = cpu_to_le32(mask);\n\n\t\treq->r_ino1 = vino;\n\t\treq->r_num_caps = 1;\n\t\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\t\tinode = req->r_target_inode;\n\t\tif (inode)\n\t\t\tihold(inode);\n\t\tceph_mdsc_put_request(req);\n\t\tif (!inode)\n\t\t\treturn err < 0 ? ERR_PTR(err) : ERR_PTR(-ESTALE);\n\t} else {\n\t\tif (ceph_inode_is_shutdown(inode)) {\n\t\t\tiput(inode);\n\t\t\treturn ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\treturn inode;\n}\n\nstruct inode *ceph_lookup_inode(struct super_block *sb, u64 ino)\n{\n\tstruct inode *inode = __lookup_inode(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\tif (inode->i_nlink == 0) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn inode;\n}\n\nstatic struct dentry *__fh_to_dentry(struct super_block *sb, u64 ino)\n{\n\tstruct inode *inode = __lookup_inode(sb, ino);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint err;\n\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\t \n\terr = ceph_do_getattr(inode, CEPH_CAP_LINK_SHARED, false);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\t \n\tif ((inode->i_nlink == 0) && !__ceph_is_file_opened(ci)) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn d_obtain_alias(inode);\n}\n\nstatic struct dentry *__snapfh_to_dentry(struct super_block *sb,\n\t\t\t\t\t  struct ceph_nfs_snapfh *sfh,\n\t\t\t\t\t  bool want_parent)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(sb)->mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct inode *inode;\n\tstruct ceph_vino vino;\n\tint mask;\n\tint err;\n\tbool unlinked = false;\n\n\tif (want_parent) {\n\t\tvino.ino = sfh->parent_ino;\n\t\tif (sfh->snapid == CEPH_SNAPDIR)\n\t\t\tvino.snap = CEPH_NOSNAP;\n\t\telse if (sfh->ino == sfh->parent_ino)\n\t\t\tvino.snap = CEPH_SNAPDIR;\n\t\telse\n\t\t\tvino.snap = sfh->snapid;\n\t} else {\n\t\tvino.ino = sfh->ino;\n\t\tvino.snap = sfh->snapid;\n\t}\n\n\tif (ceph_vino_is_reserved(vino))\n\t\treturn ERR_PTR(-ESTALE);\n\n\tinode = ceph_find_inode(sb, vino);\n\tif (inode) {\n\t\tif (ceph_inode_is_shutdown(inode)) {\n\t\t\tiput(inode);\n\t\t\treturn ERR_PTR(-ESTALE);\n\t\t}\n\t\treturn d_obtain_alias(inode);\n\t}\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPINO,\n\t\t\t\t       USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn ERR_CAST(req);\n\n\tmask = CEPH_STAT_CAP_INODE;\n\tif (ceph_security_xattr_wanted(d_inode(sb->s_root)))\n\t\tmask |= CEPH_CAP_XATTR_SHARED;\n\treq->r_args.lookupino.mask = cpu_to_le32(mask);\n\tif (vino.snap < CEPH_NOSNAP) {\n\t\treq->r_args.lookupino.snapid = cpu_to_le64(vino.snap);\n\t\tif (!want_parent && sfh->ino != sfh->parent_ino) {\n\t\t\treq->r_args.lookupino.parent =\n\t\t\t\t\tcpu_to_le64(sfh->parent_ino);\n\t\t\treq->r_args.lookupino.hash =\n\t\t\t\t\tcpu_to_le32(sfh->hash);\n\t\t}\n\t}\n\n\treq->r_ino1 = vino;\n\treq->r_num_caps = 1;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tinode = req->r_target_inode;\n\tif (inode) {\n\t\tif (vino.snap == CEPH_SNAPDIR) {\n\t\t\tif (inode->i_nlink == 0)\n\t\t\t\tunlinked = true;\n\t\t\tinode = ceph_get_snapdir(inode);\n\t\t} else if (ceph_snap(inode) == vino.snap) {\n\t\t\tihold(inode);\n\t\t} else {\n\t\t\t \n\t\t\tinode = ERR_PTR(-EOPNOTSUPP);\n\t\t}\n\t} else {\n\t\tinode = ERR_PTR(-ESTALE);\n\t}\n\tceph_mdsc_put_request(req);\n\n\tif (want_parent) {\n\t\tdout(\"snapfh_to_parent %llx.%llx\\n err=%d\\n\",\n\t\t     vino.ino, vino.snap, err);\n\t} else {\n\t\tdout(\"snapfh_to_dentry %llx.%llx parent %llx hash %x err=%d\",\n\t\t      vino.ino, vino.snap, sfh->parent_ino, sfh->hash, err);\n\t}\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\t \n\treturn unlinked ? d_obtain_root(inode) : d_obtain_alias(inode);\n}\n\n \nstatic struct dentry *ceph_fh_to_dentry(struct super_block *sb,\n\t\t\t\t\tstruct fid *fid,\n\t\t\t\t\tint fh_len, int fh_type)\n{\n\tstruct ceph_nfs_fh *fh = (void *)fid->raw;\n\n\tif (fh_type == FILEID_BTRFS_WITH_PARENT) {\n\t\tstruct ceph_nfs_snapfh *sfh = (void *)fid->raw;\n\t\treturn __snapfh_to_dentry(sb, sfh, false);\n\t}\n\n\tif (fh_type != FILEID_INO32_GEN  &&\n\t    fh_type != FILEID_INO32_GEN_PARENT)\n\t\treturn NULL;\n\tif (fh_len < sizeof(*fh) / 4)\n\t\treturn NULL;\n\n\tdout(\"fh_to_dentry %llx\\n\", fh->ino);\n\treturn __fh_to_dentry(sb, fh->ino);\n}\n\nstatic struct dentry *__get_parent(struct super_block *sb,\n\t\t\t\t   struct dentry *child, u64 ino)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(sb)->mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct inode *inode;\n\tint mask;\n\tint err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPPARENT,\n\t\t\t\t       USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn ERR_CAST(req);\n\n\tif (child) {\n\t\treq->r_inode = d_inode(child);\n\t\tihold(d_inode(child));\n\t} else {\n\t\treq->r_ino1 = (struct ceph_vino) {\n\t\t\t.ino = ino,\n\t\t\t.snap = CEPH_NOSNAP,\n\t\t};\n\t}\n\n\tmask = CEPH_STAT_CAP_INODE;\n\tif (ceph_security_xattr_wanted(d_inode(sb->s_root)))\n\t\tmask |= CEPH_CAP_XATTR_SHARED;\n\treq->r_args.getattr.mask = cpu_to_le32(mask);\n\n\treq->r_num_caps = 1;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (err) {\n\t\tceph_mdsc_put_request(req);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tinode = req->r_target_inode;\n\tif (inode)\n\t\tihold(inode);\n\tceph_mdsc_put_request(req);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn d_obtain_alias(inode);\n}\n\nstatic struct dentry *ceph_get_parent(struct dentry *child)\n{\n\tstruct inode *inode = d_inode(child);\n\tstruct dentry *dn;\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP) {\n\t\tstruct inode* dir;\n\t\tbool unlinked = false;\n\t\t \n\t\tif (!d_is_dir(child)) {\n\t\t\tdn = ERR_PTR(-EINVAL);\n\t\t\tgoto out;\n\t\t}\n\t\tdir = __lookup_inode(inode->i_sb, ceph_ino(inode));\n\t\tif (IS_ERR(dir)) {\n\t\t\tdn = ERR_CAST(dir);\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (ceph_snap(inode) != CEPH_SNAPDIR) {\n\t\t\tstruct inode *snapdir = ceph_get_snapdir(dir);\n\t\t\tif (dir->i_nlink == 0)\n\t\t\t\tunlinked = true;\n\t\t\tiput(dir);\n\t\t\tif (IS_ERR(snapdir)) {\n\t\t\t\tdn = ERR_CAST(snapdir);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdir = snapdir;\n\t\t}\n\t\t \n\t\tif (unlinked)\n\t\t\tdn = d_obtain_root(dir);\n\t\telse\n\t\t\tdn = d_obtain_alias(dir);\n\t} else {\n\t\tdn = __get_parent(child->d_sb, child, 0);\n\t}\nout:\n\tdout(\"get_parent %p ino %llx.%llx err=%ld\\n\",\n\t     child, ceph_vinop(inode), (long)PTR_ERR_OR_ZERO(dn));\n\treturn dn;\n}\n\n \nstatic struct dentry *ceph_fh_to_parent(struct super_block *sb,\n\t\t\t\t\tstruct fid *fid,\n\t\t\t\t\tint fh_len, int fh_type)\n{\n\tstruct ceph_nfs_confh *cfh = (void *)fid->raw;\n\tstruct dentry *dentry;\n\n\tif (fh_type == FILEID_BTRFS_WITH_PARENT) {\n\t\tstruct ceph_nfs_snapfh *sfh = (void *)fid->raw;\n\t\treturn __snapfh_to_dentry(sb, sfh, true);\n\t}\n\n\tif (fh_type != FILEID_INO32_GEN_PARENT)\n\t\treturn NULL;\n\tif (fh_len < sizeof(*cfh) / 4)\n\t\treturn NULL;\n\n\tdout(\"fh_to_parent %llx\\n\", cfh->parent_ino);\n\tdentry = __get_parent(sb, NULL, cfh->ino);\n\tif (unlikely(dentry == ERR_PTR(-ENOENT)))\n\t\tdentry = __fh_to_dentry(sb, cfh->parent_ino);\n\treturn dentry;\n}\n\nstatic int __get_snap_name(struct dentry *parent, char *name,\n\t\t\t   struct dentry *child)\n{\n\tstruct inode *inode = d_inode(child);\n\tstruct inode *dir = d_inode(parent);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_mds_request *req = NULL;\n\tchar *last_name = NULL;\n\tunsigned next_offset = 2;\n\tint err = -EINVAL;\n\n\tif (ceph_ino(inode) != ceph_ino(dir))\n\t\tgoto out;\n\tif (ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\tif (ceph_snap(dir) == CEPH_NOSNAP) {\n\t\t\tstrcpy(name, fsc->mount_options->snapdir_name);\n\t\t\terr = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\tif (ceph_snap(dir) != CEPH_SNAPDIR)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstruct ceph_mds_reply_info_parsed *rinfo;\n\t\tstruct ceph_mds_reply_dir_entry *rde;\n\t\tint i;\n\n\t\treq = ceph_mdsc_create_request(fsc->mdsc, CEPH_MDS_OP_LSSNAP,\n\t\t\t\t\t       USE_AUTH_MDS);\n\t\tif (IS_ERR(req)) {\n\t\t\terr = PTR_ERR(req);\n\t\t\treq = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = ceph_alloc_readdir_reply_buffer(req, inode);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\treq->r_direct_mode = USE_AUTH_MDS;\n\t\treq->r_readdir_offset = next_offset;\n\t\treq->r_args.readdir.flags =\n\t\t\t\tcpu_to_le16(CEPH_READDIR_REPLY_BITFLAGS);\n\t\tif (last_name) {\n\t\t\treq->r_path2 = last_name;\n\t\t\tlast_name = NULL;\n\t\t}\n\n\t\treq->r_inode = dir;\n\t\tihold(dir);\n\t\treq->r_dentry = dget(parent);\n\n\t\tinode_lock(dir);\n\t\terr = ceph_mdsc_do_request(fsc->mdsc, NULL, req);\n\t\tinode_unlock(dir);\n\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\trinfo = &req->r_reply_info;\n\t\tfor (i = 0; i < rinfo->dir_nr; i++) {\n\t\t\trde = rinfo->dir_entries + i;\n\t\t\tBUG_ON(!rde->inode.in);\n\t\t\tif (ceph_snap(inode) ==\n\t\t\t    le64_to_cpu(rde->inode.in->snapid)) {\n\t\t\t\tmemcpy(name, rde->name, rde->name_len);\n\t\t\t\tname[rde->name_len] = '\\0';\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (rinfo->dir_end)\n\t\t\tbreak;\n\n\t\tBUG_ON(rinfo->dir_nr <= 0);\n\t\trde = rinfo->dir_entries + (rinfo->dir_nr - 1);\n\t\tnext_offset += rinfo->dir_nr;\n\t\tlast_name = kstrndup(rde->name, rde->name_len, GFP_KERNEL);\n\t\tif (!last_name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tceph_mdsc_put_request(req);\n\t\treq = NULL;\n\t}\n\terr = -ENOENT;\nout:\n\tif (req)\n\t\tceph_mdsc_put_request(req);\n\tkfree(last_name);\n\tdout(\"get_snap_name %p ino %llx.%llx err=%d\\n\",\n\t     child, ceph_vinop(inode), err);\n\treturn err;\n}\n\nstatic int ceph_get_name(struct dentry *parent, char *name,\n\t\t\t struct dentry *child)\n{\n\tstruct ceph_mds_client *mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct inode *dir = d_inode(parent);\n\tstruct inode *inode = d_inode(child);\n\tstruct ceph_mds_reply_info_parsed *rinfo;\n\tint err;\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP)\n\t\treturn __get_snap_name(parent, name, child);\n\n\tmdsc = ceph_inode_to_client(inode)->mdsc;\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPNAME,\n\t\t\t\t       USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tinode_lock(dir);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_ino2 = ceph_vino(d_inode(parent));\n\treq->r_parent = dir;\n\tihold(dir);\n\tset_bit(CEPH_MDS_R_PARENT_LOCKED, &req->r_req_flags);\n\treq->r_num_caps = 2;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tinode_unlock(dir);\n\n\tif (err)\n\t\tgoto out;\n\n\trinfo = &req->r_reply_info;\n\tif (!IS_ENCRYPTED(dir)) {\n\t\tmemcpy(name, rinfo->dname, rinfo->dname_len);\n\t\tname[rinfo->dname_len] = 0;\n\t} else {\n\t\tstruct fscrypt_str oname = FSTR_INIT(NULL, 0);\n\t\tstruct ceph_fname fname = { .dir\t= dir,\n\t\t\t\t\t    .name\t= rinfo->dname,\n\t\t\t\t\t    .ctext\t= rinfo->altname,\n\t\t\t\t\t    .name_len\t= rinfo->dname_len,\n\t\t\t\t\t    .ctext_len\t= rinfo->altname_len };\n\n\t\terr = ceph_fname_alloc_buffer(dir, &oname);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\terr = ceph_fname_to_usr(&fname, NULL, &oname, NULL);\n\t\tif (!err) {\n\t\t\tmemcpy(name, oname.name, oname.len);\n\t\t\tname[oname.len] = 0;\n\t\t}\n\t\tceph_fname_free_buffer(dir, &oname);\n\t}\nout:\n\tdout(\"get_name %p ino %llx.%llx err %d %s%s\\n\",\n\t\t     child, ceph_vinop(inode), err,\n\t\t     err ? \"\" : \"name \", err ? \"\" : name);\n\tceph_mdsc_put_request(req);\n\treturn err;\n}\n\nconst struct export_operations ceph_export_ops = {\n\t.encode_fh = ceph_encode_fh,\n\t.fh_to_dentry = ceph_fh_to_dentry,\n\t.fh_to_parent = ceph_fh_to_parent,\n\t.get_parent = ceph_get_parent,\n\t.get_name = ceph_get_name,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}