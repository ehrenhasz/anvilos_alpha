{
  "module_name": "crypto.h",
  "hash_id": "4f85e240f99cd4a579451e0cfac9277ea4e0c98cdf4de7a66f9457324e59688f",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/crypto.h",
  "human_readable_source": " \n \n\n#ifndef _CEPH_CRYPTO_H\n#define _CEPH_CRYPTO_H\n\n#include <crypto/sha2.h>\n#include <linux/fscrypt.h>\n\n#define CEPH_FSCRYPT_BLOCK_SHIFT   12\n#define CEPH_FSCRYPT_BLOCK_SIZE    (_AC(1, UL) << CEPH_FSCRYPT_BLOCK_SHIFT)\n#define CEPH_FSCRYPT_BLOCK_MASK\t   (~(CEPH_FSCRYPT_BLOCK_SIZE-1))\n\nstruct ceph_fs_client;\nstruct ceph_acl_sec_ctx;\nstruct ceph_mds_request;\n\nstruct ceph_fname {\n\tstruct inode\t*dir;\n\tchar\t\t*name;\t\t\n\tunsigned char\t*ctext;\t\t\n\tu32\t\tname_len;\t\n\tu32\t\tctext_len;\t\n\tbool\t\tno_copy;\n};\n\n \nstruct ceph_fscrypt_truncate_size_header {\n\t__u8  ver;\n\t__u8  compat;\n\n\t \n\t__le32 data_len;\n\n\t__le64 change_attr;\n\t__le64 file_offset;\n\t__le32 block_size;\n} __packed;\n\nstruct ceph_fscrypt_auth {\n\t__le32\tcfa_version;\n\t__le32\tcfa_blob_len;\n\tu8\tcfa_blob[FSCRYPT_SET_CONTEXT_MAX_SIZE];\n} __packed;\n\n#define CEPH_FSCRYPT_AUTH_VERSION\t1\nstatic inline u32 ceph_fscrypt_auth_len(struct ceph_fscrypt_auth *fa)\n{\n\tu32 ctxsize = le32_to_cpu(fa->cfa_blob_len);\n\n\treturn offsetof(struct ceph_fscrypt_auth, cfa_blob) + ctxsize;\n}\n\n#ifdef CONFIG_FS_ENCRYPTION\n \n#define CEPH_NOHASH_NAME_MAX (180 - SHA256_DIGEST_SIZE)\n\n#define CEPH_BASE64_CHARS(nbytes) DIV_ROUND_UP((nbytes) * 4, 3)\n\nint ceph_base64_encode(const u8 *src, int srclen, char *dst);\nint ceph_base64_decode(const char *src, int srclen, u8 *dst);\n\nvoid ceph_fscrypt_set_ops(struct super_block *sb);\n\nvoid ceph_fscrypt_free_dummy_policy(struct ceph_fs_client *fsc);\n\nint ceph_fscrypt_prepare_context(struct inode *dir, struct inode *inode,\n\t\t\t\t struct ceph_acl_sec_ctx *as);\nvoid ceph_fscrypt_as_ctx_to_req(struct ceph_mds_request *req,\n\t\t\t\tstruct ceph_acl_sec_ctx *as);\nint ceph_encode_encrypted_dname(struct inode *parent, struct qstr *d_name,\n\t\t\t\tchar *buf);\nint ceph_encode_encrypted_fname(struct inode *parent, struct dentry *dentry,\n\t\t\t\tchar *buf);\n\nstatic inline int ceph_fname_alloc_buffer(struct inode *parent,\n\t\t\t\t\t  struct fscrypt_str *fname)\n{\n\tif (!IS_ENCRYPTED(parent))\n\t\treturn 0;\n\treturn fscrypt_fname_alloc_buffer(NAME_MAX, fname);\n}\n\nstatic inline void ceph_fname_free_buffer(struct inode *parent,\n\t\t\t\t\t  struct fscrypt_str *fname)\n{\n\tif (IS_ENCRYPTED(parent))\n\t\tfscrypt_fname_free_buffer(fname);\n}\n\nint ceph_fname_to_usr(const struct ceph_fname *fname, struct fscrypt_str *tname,\n\t\t      struct fscrypt_str *oname, bool *is_nokey);\nint ceph_fscrypt_prepare_readdir(struct inode *dir);\n\nstatic inline unsigned int ceph_fscrypt_blocks(u64 off, u64 len)\n{\n\t \n\tBUILD_BUG_ON(CEPH_FSCRYPT_BLOCK_SHIFT > PAGE_SHIFT);\n\n\treturn ((off+len+CEPH_FSCRYPT_BLOCK_SIZE-1) >> CEPH_FSCRYPT_BLOCK_SHIFT) -\n\t\t(off >> CEPH_FSCRYPT_BLOCK_SHIFT);\n}\n\n \nstatic inline void ceph_fscrypt_adjust_off_and_len(struct inode *inode,\n\t\t\t\t\t\t   u64 *off, u64 *len)\n{\n\tif (IS_ENCRYPTED(inode)) {\n\t\t*len = ceph_fscrypt_blocks(*off, *len) * CEPH_FSCRYPT_BLOCK_SIZE;\n\t\t*off &= CEPH_FSCRYPT_BLOCK_MASK;\n\t}\n}\n\nint ceph_fscrypt_decrypt_block_inplace(const struct inode *inode,\n\t\t\t\t  struct page *page, unsigned int len,\n\t\t\t\t  unsigned int offs, u64 lblk_num);\nint ceph_fscrypt_encrypt_block_inplace(const struct inode *inode,\n\t\t\t\t  struct page *page, unsigned int len,\n\t\t\t\t  unsigned int offs, u64 lblk_num,\n\t\t\t\t  gfp_t gfp_flags);\nint ceph_fscrypt_decrypt_pages(struct inode *inode, struct page **page,\n\t\t\t       u64 off, int len);\nint ceph_fscrypt_decrypt_extents(struct inode *inode, struct page **page,\n\t\t\t\t u64 off, struct ceph_sparse_extent *map,\n\t\t\t\t u32 ext_cnt);\nint ceph_fscrypt_encrypt_pages(struct inode *inode, struct page **page, u64 off,\n\t\t\t       int len, gfp_t gfp);\n\nstatic inline struct page *ceph_fscrypt_pagecache_page(struct page *page)\n{\n\treturn fscrypt_is_bounce_page(page) ? fscrypt_pagecache_page(page) : page;\n}\n\n#else  \n\nstatic inline void ceph_fscrypt_set_ops(struct super_block *sb)\n{\n}\n\nstatic inline void ceph_fscrypt_free_dummy_policy(struct ceph_fs_client *fsc)\n{\n}\n\nstatic inline int ceph_fscrypt_prepare_context(struct inode *dir,\n\t\t\t\t\t       struct inode *inode,\n\t\t\t\t\t       struct ceph_acl_sec_ctx *as)\n{\n\tif (IS_ENCRYPTED(dir))\n\t\treturn -EOPNOTSUPP;\n\treturn 0;\n}\n\nstatic inline void ceph_fscrypt_as_ctx_to_req(struct ceph_mds_request *req,\n\t\t\t\t\t\tstruct ceph_acl_sec_ctx *as_ctx)\n{\n}\n\nstatic inline int ceph_encode_encrypted_dname(struct inode *parent,\n\t\t\t\t\t      struct qstr *d_name, char *buf)\n{\n\tmemcpy(buf, d_name->name, d_name->len);\n\treturn d_name->len;\n}\n\nstatic inline int ceph_encode_encrypted_fname(struct inode *parent,\n\t\t\t\t\t      struct dentry *dentry, char *buf)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int ceph_fname_alloc_buffer(struct inode *parent,\n\t\t\t\t\t  struct fscrypt_str *fname)\n{\n\treturn 0;\n}\n\nstatic inline void ceph_fname_free_buffer(struct inode *parent,\n\t\t\t\t\t  struct fscrypt_str *fname)\n{\n}\n\nstatic inline int ceph_fname_to_usr(const struct ceph_fname *fname,\n\t\t\t\t    struct fscrypt_str *tname,\n\t\t\t\t    struct fscrypt_str *oname, bool *is_nokey)\n{\n\toname->name = fname->name;\n\toname->len = fname->name_len;\n\treturn 0;\n}\n\nstatic inline int ceph_fscrypt_prepare_readdir(struct inode *dir)\n{\n\treturn 0;\n}\n\nstatic inline void ceph_fscrypt_adjust_off_and_len(struct inode *inode,\n\t\t\t\t\t\t   u64 *off, u64 *len)\n{\n}\n\nstatic inline int ceph_fscrypt_decrypt_block_inplace(const struct inode *inode,\n\t\t\t\t\t  struct page *page, unsigned int len,\n\t\t\t\t\t  unsigned int offs, u64 lblk_num)\n{\n\treturn 0;\n}\n\nstatic inline int ceph_fscrypt_encrypt_block_inplace(const struct inode *inode,\n\t\t\t\t\t  struct page *page, unsigned int len,\n\t\t\t\t\t  unsigned int offs, u64 lblk_num,\n\t\t\t\t\t  gfp_t gfp_flags)\n{\n\treturn 0;\n}\n\nstatic inline int ceph_fscrypt_decrypt_pages(struct inode *inode,\n\t\t\t\t\t     struct page **page, u64 off,\n\t\t\t\t\t     int len)\n{\n\treturn 0;\n}\n\nstatic inline int ceph_fscrypt_decrypt_extents(struct inode *inode,\n\t\t\t\t\t       struct page **page, u64 off,\n\t\t\t\t\t       struct ceph_sparse_extent *map,\n\t\t\t\t\t       u32 ext_cnt)\n{\n\treturn 0;\n}\n\nstatic inline int ceph_fscrypt_encrypt_pages(struct inode *inode,\n\t\t\t\t\t     struct page **page, u64 off,\n\t\t\t\t\t     int len, gfp_t gfp)\n{\n\treturn 0;\n}\n\nstatic inline struct page *ceph_fscrypt_pagecache_page(struct page *page)\n{\n\treturn page;\n}\n#endif  \n\nstatic inline loff_t ceph_fscrypt_page_offset(struct page *page)\n{\n\treturn page_offset(ceph_fscrypt_pagecache_page(page));\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}