{
  "module_name": "xattr.c",
  "hash_id": "579c92ffa620c788bde7c0c92f0bae3cc3964ee5877e861ecfe3963c0291cb5a",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/xattr.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n#include <linux/ceph/pagelist.h>\n\n#include \"super.h\"\n#include \"mds_client.h\"\n\n#include <linux/ceph/decode.h>\n\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n\n#define XATTR_CEPH_PREFIX \"ceph.\"\n#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic bool ceph_is_valid_xattr(const char *name)\n{\n\treturn !strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);\n}\n\n \nstruct ceph_vxattr {\n\tchar *name;\n\tsize_t name_size;\t \n\tssize_t (*getxattr_cb)(struct ceph_inode_info *ci, char *val,\n\t\t\t       size_t size);\n\tbool (*exists_cb)(struct ceph_inode_info *ci);\n\tunsigned int flags;\n};\n\n#define VXATTR_FLAG_READONLY\t\t(1<<0)\n#define VXATTR_FLAG_HIDDEN\t\t(1<<1)\n#define VXATTR_FLAG_RSTAT\t\t(1<<2)\n#define VXATTR_FLAG_DIRSTAT\t\t(1<<3)\n\n \n\nstatic bool ceph_vxattrcb_layout_exists(struct ceph_inode_info *ci)\n{\n\tstruct ceph_file_layout *fl = &ci->i_layout;\n\treturn (fl->stripe_unit > 0 || fl->stripe_count > 0 ||\n\t\tfl->object_size > 0 || fl->pool_id >= 0 ||\n\t\trcu_dereference_raw(fl->pool_ns) != NULL);\n}\n\nstatic ssize_t ceph_vxattrcb_layout(struct ceph_inode_info *ci, char *val,\n\t\t\t\t    size_t size)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(ci->netfs.inode.i_sb);\n\tstruct ceph_osd_client *osdc = &fsc->client->osdc;\n\tstruct ceph_string *pool_ns;\n\ts64 pool = ci->i_layout.pool_id;\n\tconst char *pool_name;\n\tconst char *ns_field = \" pool_namespace=\";\n\tchar buf[128];\n\tsize_t len, total_len = 0;\n\tssize_t ret;\n\n\tpool_ns = ceph_try_get_string(ci->i_layout.pool_ns);\n\n\tdout(\"ceph_vxattrcb_layout %p\\n\", &ci->netfs.inode);\n\tdown_read(&osdc->lock);\n\tpool_name = ceph_pg_pool_name_by_id(osdc->osdmap, pool);\n\tif (pool_name) {\n\t\tlen = snprintf(buf, sizeof(buf),\n\t\t\"stripe_unit=%u stripe_count=%u object_size=%u pool=\",\n\t\tci->i_layout.stripe_unit, ci->i_layout.stripe_count,\n\t        ci->i_layout.object_size);\n\t\ttotal_len = len + strlen(pool_name);\n\t} else {\n\t\tlen = snprintf(buf, sizeof(buf),\n\t\t\"stripe_unit=%u stripe_count=%u object_size=%u pool=%lld\",\n\t\tci->i_layout.stripe_unit, ci->i_layout.stripe_count,\n\t\tci->i_layout.object_size, pool);\n\t\ttotal_len = len;\n\t}\n\n\tif (pool_ns)\n\t\ttotal_len += strlen(ns_field) + pool_ns->len;\n\n\tret = total_len;\n\tif (size >= total_len) {\n\t\tmemcpy(val, buf, len);\n\t\tret = len;\n\t\tif (pool_name) {\n\t\t\tlen = strlen(pool_name);\n\t\t\tmemcpy(val + ret, pool_name, len);\n\t\t\tret += len;\n\t\t}\n\t\tif (pool_ns) {\n\t\t\tlen = strlen(ns_field);\n\t\t\tmemcpy(val + ret, ns_field, len);\n\t\t\tret += len;\n\t\t\tmemcpy(val + ret, pool_ns->str, pool_ns->len);\n\t\t\tret += pool_ns->len;\n\t\t}\n\t}\n\tup_read(&osdc->lock);\n\tceph_put_string(pool_ns);\n\treturn ret;\n}\n\n \nstatic __printf(3, 4)\nint ceph_fmt_xattr(char *val, size_t size, const char *fmt, ...)\n{\n\tint ret;\n\tva_list args;\n\tchar buf[96];  \n\n\tva_start(args, fmt);\n\tret = vsnprintf(buf, size ? sizeof(buf) : 0, fmt, args);\n\tva_end(args);\n\n\t \n\tif (size && ret + 1 > sizeof(buf)) {\n\t\tWARN_ONCE(true, \"Returned length too big (%d)\", ret);\n\t\treturn -E2BIG;\n\t}\n\n\tif (ret <= size)\n\t\tmemcpy(val, buf, ret);\n\treturn ret;\n}\n\nstatic ssize_t ceph_vxattrcb_layout_stripe_unit(struct ceph_inode_info *ci,\n\t\t\t\t\t\tchar *val, size_t size)\n{\n\treturn ceph_fmt_xattr(val, size, \"%u\", ci->i_layout.stripe_unit);\n}\n\nstatic ssize_t ceph_vxattrcb_layout_stripe_count(struct ceph_inode_info *ci,\n\t\t\t\t\t\t char *val, size_t size)\n{\n\treturn ceph_fmt_xattr(val, size, \"%u\", ci->i_layout.stripe_count);\n}\n\nstatic ssize_t ceph_vxattrcb_layout_object_size(struct ceph_inode_info *ci,\n\t\t\t\t\t\tchar *val, size_t size)\n{\n\treturn ceph_fmt_xattr(val, size, \"%u\", ci->i_layout.object_size);\n}\n\nstatic ssize_t ceph_vxattrcb_layout_pool(struct ceph_inode_info *ci,\n\t\t\t\t\t char *val, size_t size)\n{\n\tssize_t ret;\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(ci->netfs.inode.i_sb);\n\tstruct ceph_osd_client *osdc = &fsc->client->osdc;\n\ts64 pool = ci->i_layout.pool_id;\n\tconst char *pool_name;\n\n\tdown_read(&osdc->lock);\n\tpool_name = ceph_pg_pool_name_by_id(osdc->osdmap, pool);\n\tif (pool_name) {\n\t\tret = strlen(pool_name);\n\t\tif (ret <= size)\n\t\t\tmemcpy(val, pool_name, ret);\n\t} else {\n\t\tret = ceph_fmt_xattr(val, size, \"%lld\", pool);\n\t}\n\tup_read(&osdc->lock);\n\treturn ret;\n}\n\nstatic ssize_t ceph_vxattrcb_layout_pool_namespace(struct ceph_inode_info *ci,\n\t\t\t\t\t\t   char *val, size_t size)\n{\n\tssize_t ret = 0;\n\tstruct ceph_string *ns = ceph_try_get_string(ci->i_layout.pool_ns);\n\n\tif (ns) {\n\t\tret = ns->len;\n\t\tif (ret <= size)\n\t\t\tmemcpy(val, ns->str, ret);\n\t\tceph_put_string(ns);\n\t}\n\treturn ret;\n}\n\n \n\nstatic ssize_t ceph_vxattrcb_dir_entries(struct ceph_inode_info *ci, char *val,\n\t\t\t\t\t size_t size)\n{\n\treturn ceph_fmt_xattr(val, size, \"%lld\", ci->i_files + ci->i_subdirs);\n}\n\nstatic ssize_t ceph_vxattrcb_dir_files(struct ceph_inode_info *ci, char *val,\n\t\t\t\t       size_t size)\n{\n\treturn ceph_fmt_xattr(val, size, \"%lld\", ci->i_files);\n}\n\nstatic ssize_t ceph_vxattrcb_dir_subdirs(struct ceph_inode_info *ci, char *val,\n\t\t\t\t\t size_t size)\n{\n\treturn ceph_fmt_xattr(val, size, \"%lld\", ci->i_subdirs);\n}\n\nstatic ssize_t ceph_vxattrcb_dir_rentries(struct ceph_inode_info *ci, char *val,\n\t\t\t\t\t  size_t size)\n{\n\treturn ceph_fmt_xattr(val, size, \"%lld\",\n\t\t\t\tci->i_rfiles + ci->i_rsubdirs);\n}\n\nstatic ssize_t ceph_vxattrcb_dir_rfiles(struct ceph_inode_info *ci, char *val,\n\t\t\t\t\tsize_t size)\n{\n\treturn ceph_fmt_xattr(val, size, \"%lld\", ci->i_rfiles);\n}\n\nstatic ssize_t ceph_vxattrcb_dir_rsubdirs(struct ceph_inode_info *ci, char *val,\n\t\t\t\t\t  size_t size)\n{\n\treturn ceph_fmt_xattr(val, size, \"%lld\", ci->i_rsubdirs);\n}\n\nstatic ssize_t ceph_vxattrcb_dir_rsnaps(struct ceph_inode_info *ci, char *val,\n\t\t\t\t\t  size_t size)\n{\n\treturn ceph_fmt_xattr(val, size, \"%lld\", ci->i_rsnaps);\n}\n\nstatic ssize_t ceph_vxattrcb_dir_rbytes(struct ceph_inode_info *ci, char *val,\n\t\t\t\t\tsize_t size)\n{\n\treturn ceph_fmt_xattr(val, size, \"%lld\", ci->i_rbytes);\n}\n\nstatic ssize_t ceph_vxattrcb_dir_rctime(struct ceph_inode_info *ci, char *val,\n\t\t\t\t\tsize_t size)\n{\n\treturn ceph_fmt_xattr(val, size, \"%lld.%09ld\", ci->i_rctime.tv_sec,\n\t\t\t\tci->i_rctime.tv_nsec);\n}\n\n \nstatic bool ceph_vxattrcb_dir_pin_exists(struct ceph_inode_info *ci)\n{\n\treturn ci->i_dir_pin != -ENODATA;\n}\n\nstatic ssize_t ceph_vxattrcb_dir_pin(struct ceph_inode_info *ci, char *val,\n\t\t\t\t     size_t size)\n{\n\treturn ceph_fmt_xattr(val, size, \"%d\", (int)ci->i_dir_pin);\n}\n\n \nstatic bool ceph_vxattrcb_quota_exists(struct ceph_inode_info *ci)\n{\n\tbool ret = false;\n\tspin_lock(&ci->i_ceph_lock);\n\tif ((ci->i_max_files || ci->i_max_bytes) &&\n\t    ci->i_vino.snap == CEPH_NOSNAP &&\n\t    ci->i_snap_realm &&\n\t    ci->i_snap_realm->ino == ci->i_vino.ino)\n\t\tret = true;\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}\n\nstatic ssize_t ceph_vxattrcb_quota(struct ceph_inode_info *ci, char *val,\n\t\t\t\t   size_t size)\n{\n\treturn ceph_fmt_xattr(val, size, \"max_bytes=%llu max_files=%llu\",\n\t\t\t\tci->i_max_bytes, ci->i_max_files);\n}\n\nstatic ssize_t ceph_vxattrcb_quota_max_bytes(struct ceph_inode_info *ci,\n\t\t\t\t\t     char *val, size_t size)\n{\n\treturn ceph_fmt_xattr(val, size, \"%llu\", ci->i_max_bytes);\n}\n\nstatic ssize_t ceph_vxattrcb_quota_max_files(struct ceph_inode_info *ci,\n\t\t\t\t\t     char *val, size_t size)\n{\n\treturn ceph_fmt_xattr(val, size, \"%llu\", ci->i_max_files);\n}\n\n \nstatic bool ceph_vxattrcb_snap_btime_exists(struct ceph_inode_info *ci)\n{\n\treturn (ci->i_snap_btime.tv_sec != 0 || ci->i_snap_btime.tv_nsec != 0);\n}\n\nstatic ssize_t ceph_vxattrcb_snap_btime(struct ceph_inode_info *ci, char *val,\n\t\t\t\t\tsize_t size)\n{\n\treturn ceph_fmt_xattr(val, size, \"%lld.%09ld\", ci->i_snap_btime.tv_sec,\n\t\t\t\tci->i_snap_btime.tv_nsec);\n}\n\nstatic ssize_t ceph_vxattrcb_cluster_fsid(struct ceph_inode_info *ci,\n\t\t\t\t\t  char *val, size_t size)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(ci->netfs.inode.i_sb);\n\n\treturn ceph_fmt_xattr(val, size, \"%pU\", &fsc->client->fsid);\n}\n\nstatic ssize_t ceph_vxattrcb_client_id(struct ceph_inode_info *ci,\n\t\t\t\t       char *val, size_t size)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(ci->netfs.inode.i_sb);\n\n\treturn ceph_fmt_xattr(val, size, \"client%lld\",\n\t\t\t      ceph_client_gid(fsc->client));\n}\n\nstatic ssize_t ceph_vxattrcb_caps(struct ceph_inode_info *ci, char *val,\n\t\t\t\t\tsize_t size)\n{\n\tint issued;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tissued = __ceph_caps_issued(ci, NULL);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\treturn ceph_fmt_xattr(val, size, \"%s/0x%x\",\n\t\t\t      ceph_cap_string(issued), issued);\n}\n\nstatic ssize_t ceph_vxattrcb_auth_mds(struct ceph_inode_info *ci,\n\t\t\t\t       char *val, size_t size)\n{\n\tint ret;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tret = ceph_fmt_xattr(val, size, \"%d\",\n\t\t\t     ci->i_auth_cap ? ci->i_auth_cap->session->s_mds : -1);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_FS_ENCRYPTION)\nstatic bool ceph_vxattrcb_fscrypt_auth_exists(struct ceph_inode_info *ci)\n{\n\treturn ci->fscrypt_auth_len;\n}\n\nstatic ssize_t ceph_vxattrcb_fscrypt_auth(struct ceph_inode_info *ci,\n\t\t\t\t\t  char *val, size_t size)\n{\n\tif (size) {\n\t\tif (size < ci->fscrypt_auth_len)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(val, ci->fscrypt_auth, ci->fscrypt_auth_len);\n\t}\n\treturn ci->fscrypt_auth_len;\n}\n#endif  \n\n#define CEPH_XATTR_NAME(_type, _name)\tXATTR_CEPH_PREFIX #_type \".\" #_name\n#define CEPH_XATTR_NAME2(_type, _name, _name2)\t\\\n\tXATTR_CEPH_PREFIX #_type \".\" #_name \".\" #_name2\n\n#define XATTR_NAME_CEPH(_type, _name, _flags)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name = CEPH_XATTR_NAME(_type, _name),\t\t\t\\\n\t\t.name_size = sizeof (CEPH_XATTR_NAME(_type, _name)), \\\n\t\t.getxattr_cb = ceph_vxattrcb_ ## _type ## _ ## _name, \\\n\t\t.exists_cb = NULL,\t\t\t\t\t\\\n\t\t.flags = (VXATTR_FLAG_READONLY | _flags),\t\t\\\n\t}\n#define XATTR_RSTAT_FIELD(_type, _name)\t\t\t\\\n\tXATTR_NAME_CEPH(_type, _name, VXATTR_FLAG_RSTAT)\n#define XATTR_RSTAT_FIELD_UPDATABLE(_type, _name)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name = CEPH_XATTR_NAME(_type, _name),\t\t\t\\\n\t\t.name_size = sizeof (CEPH_XATTR_NAME(_type, _name)),\t\\\n\t\t.getxattr_cb = ceph_vxattrcb_ ## _type ## _ ## _name,\t\\\n\t\t.exists_cb = NULL,\t\t\t\t\t\\\n\t\t.flags = VXATTR_FLAG_RSTAT,\t\t\t\t\\\n\t}\n#define XATTR_LAYOUT_FIELD(_type, _name, _field)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name = CEPH_XATTR_NAME2(_type, _name, _field),\t\\\n\t\t.name_size = sizeof (CEPH_XATTR_NAME2(_type, _name, _field)), \\\n\t\t.getxattr_cb = ceph_vxattrcb_ ## _name ## _ ## _field, \\\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\t\\\n\t\t.flags = VXATTR_FLAG_HIDDEN,\t\t\t\\\n\t}\n#define XATTR_QUOTA_FIELD(_type, _name)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name = CEPH_XATTR_NAME(_type, _name),\t\t\t\\\n\t\t.name_size = sizeof(CEPH_XATTR_NAME(_type, _name)),\t\\\n\t\t.getxattr_cb = ceph_vxattrcb_ ## _type ## _ ## _name,\t\\\n\t\t.exists_cb = ceph_vxattrcb_quota_exists,\t\t\\\n\t\t.flags = VXATTR_FLAG_HIDDEN,\t\t\t\t\\\n\t}\n\nstatic struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t\t.flags = VXATTR_FLAG_HIDDEN,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool_namespace),\n\tXATTR_NAME_CEPH(dir, entries, VXATTR_FLAG_DIRSTAT),\n\tXATTR_NAME_CEPH(dir, files, VXATTR_FLAG_DIRSTAT),\n\tXATTR_NAME_CEPH(dir, subdirs, VXATTR_FLAG_DIRSTAT),\n\tXATTR_RSTAT_FIELD(dir, rentries),\n\tXATTR_RSTAT_FIELD(dir, rfiles),\n\tXATTR_RSTAT_FIELD(dir, rsubdirs),\n\tXATTR_RSTAT_FIELD(dir, rsnaps),\n\tXATTR_RSTAT_FIELD(dir, rbytes),\n\tXATTR_RSTAT_FIELD_UPDATABLE(dir, rctime),\n\t{\n\t\t.name = \"ceph.dir.pin\",\n\t\t.name_size = sizeof(\"ceph.dir.pin\"),\n\t\t.getxattr_cb = ceph_vxattrcb_dir_pin,\n\t\t.exists_cb = ceph_vxattrcb_dir_pin_exists,\n\t\t.flags = VXATTR_FLAG_HIDDEN,\n\t},\n\t{\n\t\t.name = \"ceph.quota\",\n\t\t.name_size = sizeof(\"ceph.quota\"),\n\t\t.getxattr_cb = ceph_vxattrcb_quota,\n\t\t.exists_cb = ceph_vxattrcb_quota_exists,\n\t\t.flags = VXATTR_FLAG_HIDDEN,\n\t},\n\tXATTR_QUOTA_FIELD(quota, max_bytes),\n\tXATTR_QUOTA_FIELD(quota, max_files),\n\t{\n\t\t.name = \"ceph.snap.btime\",\n\t\t.name_size = sizeof(\"ceph.snap.btime\"),\n\t\t.getxattr_cb = ceph_vxattrcb_snap_btime,\n\t\t.exists_cb = ceph_vxattrcb_snap_btime_exists,\n\t\t.flags = VXATTR_FLAG_READONLY,\n\t},\n\t{\n\t\t.name = \"ceph.caps\",\n\t\t.name_size = sizeof(\"ceph.caps\"),\n\t\t.getxattr_cb = ceph_vxattrcb_caps,\n\t\t.exists_cb = NULL,\n\t\t.flags = VXATTR_FLAG_HIDDEN,\n\t},\n\t{ .name = NULL, 0 }\t \n};\n\n \n\nstatic struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t\t.flags = VXATTR_FLAG_HIDDEN,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\tXATTR_LAYOUT_FIELD(file, layout, pool_namespace),\n\t{\n\t\t.name = \"ceph.snap.btime\",\n\t\t.name_size = sizeof(\"ceph.snap.btime\"),\n\t\t.getxattr_cb = ceph_vxattrcb_snap_btime,\n\t\t.exists_cb = ceph_vxattrcb_snap_btime_exists,\n\t\t.flags = VXATTR_FLAG_READONLY,\n\t},\n\t{\n\t\t.name = \"ceph.caps\",\n\t\t.name_size = sizeof(\"ceph.caps\"),\n\t\t.getxattr_cb = ceph_vxattrcb_caps,\n\t\t.exists_cb = NULL,\n\t\t.flags = VXATTR_FLAG_HIDDEN,\n\t},\n\t{ .name = NULL, 0 }\t \n};\n\nstatic struct ceph_vxattr ceph_common_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.cluster_fsid\",\n\t\t.name_size = sizeof(\"ceph.cluster_fsid\"),\n\t\t.getxattr_cb = ceph_vxattrcb_cluster_fsid,\n\t\t.exists_cb = NULL,\n\t\t.flags = VXATTR_FLAG_READONLY,\n\t},\n\t{\n\t\t.name = \"ceph.client_id\",\n\t\t.name_size = sizeof(\"ceph.client_id\"),\n\t\t.getxattr_cb = ceph_vxattrcb_client_id,\n\t\t.exists_cb = NULL,\n\t\t.flags = VXATTR_FLAG_READONLY,\n\t},\n\t{\n\t\t.name = \"ceph.auth_mds\",\n\t\t.name_size = sizeof(\"ceph.auth_mds\"),\n\t\t.getxattr_cb = ceph_vxattrcb_auth_mds,\n\t\t.exists_cb = NULL,\n\t\t.flags = VXATTR_FLAG_READONLY,\n\t},\n#if IS_ENABLED(CONFIG_FS_ENCRYPTION)\n\t{\n\t\t.name = \"ceph.fscrypt.auth\",\n\t\t.name_size = sizeof(\"ceph.fscrypt.auth\"),\n\t\t.getxattr_cb = ceph_vxattrcb_fscrypt_auth,\n\t\t.exists_cb = ceph_vxattrcb_fscrypt_auth_exists,\n\t\t.flags = VXATTR_FLAG_READONLY,\n\t},\n#endif  \n\t{ .name = NULL, 0 }\t \n};\n\nstatic struct ceph_vxattr *ceph_inode_vxattrs(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn ceph_dir_vxattrs;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn ceph_file_vxattrs;\n\treturn NULL;\n}\n\nstatic struct ceph_vxattr *ceph_match_vxattr(struct inode *inode,\n\t\t\t\t\t\tconst char *name)\n{\n\tstruct ceph_vxattr *vxattr = ceph_inode_vxattrs(inode);\n\n\tif (vxattr) {\n\t\twhile (vxattr->name) {\n\t\t\tif (!strcmp(vxattr->name, name))\n\t\t\t\treturn vxattr;\n\t\t\tvxattr++;\n\t\t}\n\t}\n\n\tvxattr = ceph_common_vxattrs;\n\twhile (vxattr->name) {\n\t\tif (!strcmp(vxattr->name, name))\n\t\t\treturn vxattr;\n\t\tvxattr++;\n\t}\n\n\treturn NULL;\n}\n\n#define MAX_XATTR_VAL_PRINT_LEN 256\n\nstatic int __set_xattr(struct ceph_inode_info *ci,\n\t\t\t   const char *name, int name_len,\n\t\t\t   const char *val, int val_len,\n\t\t\t   int flags, int update_xattr,\n\t\t\t   struct ceph_inode_xattr **newxattr)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint c;\n\tint new = 0;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txattr = rb_entry(parent, struct ceph_inode_xattr, node);\n\t\tc = strncmp(name, xattr->name, min(name_len, xattr->name_len));\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tif (name_len == xattr->name_len)\n\t\t\t\tbreak;\n\t\t\telse if (name_len < xattr->name_len)\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\telse\n\t\t\t\tp = &(*p)->rb_right;\n\t\t}\n\t\txattr = NULL;\n\t}\n\n\tif (update_xattr) {\n\t\tint err = 0;\n\n\t\tif (xattr && (flags & XATTR_CREATE))\n\t\t\terr = -EEXIST;\n\t\telse if (!xattr && (flags & XATTR_REPLACE))\n\t\t\terr = -ENODATA;\n\t\tif (err) {\n\t\t\tkfree(name);\n\t\t\tkfree(val);\n\t\t\tkfree(*newxattr);\n\t\t\treturn err;\n\t\t}\n\t\tif (update_xattr < 0) {\n\t\t\tif (xattr)\n\t\t\t\t__remove_xattr(ci, xattr);\n\t\t\tkfree(name);\n\t\t\tkfree(*newxattr);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!xattr) {\n\t\tnew = 1;\n\t\txattr = *newxattr;\n\t\txattr->name = name;\n\t\txattr->name_len = name_len;\n\t\txattr->should_free_name = update_xattr;\n\n\t\tci->i_xattrs.count++;\n\t\tdout(\"%s count=%d\\n\", __func__, ci->i_xattrs.count);\n\t} else {\n\t\tkfree(*newxattr);\n\t\t*newxattr = NULL;\n\t\tif (xattr->should_free_val)\n\t\t\tkfree(xattr->val);\n\n\t\tif (update_xattr) {\n\t\t\tkfree(name);\n\t\t\tname = xattr->name;\n\t\t}\n\t\tci->i_xattrs.names_size -= xattr->name_len;\n\t\tci->i_xattrs.vals_size -= xattr->val_len;\n\t}\n\tci->i_xattrs.names_size += name_len;\n\tci->i_xattrs.vals_size += val_len;\n\tif (val)\n\t\txattr->val = val;\n\telse\n\t\txattr->val = \"\";\n\n\txattr->val_len = val_len;\n\txattr->dirty = update_xattr;\n\txattr->should_free_val = (val && update_xattr);\n\n\tif (new) {\n\t\trb_link_node(&xattr->node, parent, p);\n\t\trb_insert_color(&xattr->node, &ci->i_xattrs.index);\n\t\tdout(\"%s p=%p\\n\", __func__, p);\n\t}\n\n\tdout(\"%s added %llx.%llx xattr %p %.*s=%.*s%s\\n\", __func__,\n\t     ceph_vinop(&ci->netfs.inode), xattr, name_len, name,\n\t     min(val_len, MAX_XATTR_VAL_PRINT_LEN), val,\n\t     val_len > MAX_XATTR_VAL_PRINT_LEN ? \"...\" : \"\");\n\n\treturn 0;\n}\n\nstatic struct ceph_inode_xattr *__get_xattr(struct ceph_inode_info *ci,\n\t\t\t   const char *name)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint name_len = strlen(name);\n\tint c;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txattr = rb_entry(parent, struct ceph_inode_xattr, node);\n\t\tc = strncmp(name, xattr->name, xattr->name_len);\n\t\tif (c == 0 && name_len > xattr->name_len)\n\t\t\tc = 1;\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tint len = min(xattr->val_len, MAX_XATTR_VAL_PRINT_LEN);\n\n\t\t\tdout(\"%s %s: found %.*s%s\\n\", __func__, name, len,\n\t\t\t     xattr->val, xattr->val_len > len ? \"...\" : \"\");\n\t\t\treturn xattr;\n\t\t}\n\t}\n\n\tdout(\"%s %s: not found\\n\", __func__, name);\n\n\treturn NULL;\n}\n\nstatic void __free_xattr(struct ceph_inode_xattr *xattr)\n{\n\tBUG_ON(!xattr);\n\n\tif (xattr->should_free_name)\n\t\tkfree(xattr->name);\n\tif (xattr->should_free_val)\n\t\tkfree(xattr->val);\n\n\tkfree(xattr);\n}\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr)\n{\n\tif (!xattr)\n\t\treturn -ENODATA;\n\n\trb_erase(&xattr->node, &ci->i_xattrs.index);\n\n\tif (xattr->should_free_name)\n\t\tkfree(xattr->name);\n\tif (xattr->should_free_val)\n\t\tkfree(xattr->val);\n\n\tci->i_xattrs.names_size -= xattr->name_len;\n\tci->i_xattrs.vals_size -= xattr->val_len;\n\tci->i_xattrs.count--;\n\tkfree(xattr);\n\n\treturn 0;\n}\n\nstatic char *__copy_xattr_names(struct ceph_inode_info *ci,\n\t\t\t\tchar *dest)\n{\n\tstruct rb_node *p;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\n\tp = rb_first(&ci->i_xattrs.index);\n\tdout(\"__copy_xattr_names count=%d\\n\", ci->i_xattrs.count);\n\n\twhile (p) {\n\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\t\tmemcpy(dest, xattr->name, xattr->name_len);\n\t\tdest[xattr->name_len] = '\\0';\n\n\t\tdout(\"dest=%s %p (%s) (%d/%d)\\n\", dest, xattr, xattr->name,\n\t\t     xattr->name_len, ci->i_xattrs.names_size);\n\n\t\tdest += xattr->name_len + 1;\n\t\tp = rb_next(p);\n\t}\n\n\treturn dest;\n}\n\nvoid __ceph_destroy_xattrs(struct ceph_inode_info *ci)\n{\n\tstruct rb_node *p, *tmp;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\n\tp = rb_first(&ci->i_xattrs.index);\n\n\tdout(\"__ceph_destroy_xattrs p=%p\\n\", p);\n\n\twhile (p) {\n\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\t\ttmp = p;\n\t\tp = rb_next(tmp);\n\t\tdout(\"__ceph_destroy_xattrs next p=%p (%.*s)\\n\", p,\n\t\t     xattr->name_len, xattr->name);\n\t\trb_erase(tmp, &ci->i_xattrs.index);\n\n\t\t__free_xattr(xattr);\n\t}\n\n\tci->i_xattrs.names_size = 0;\n\tci->i_xattrs.vals_size = 0;\n\tci->i_xattrs.index_version = 0;\n\tci->i_xattrs.count = 0;\n\tci->i_xattrs.index = RB_ROOT;\n}\n\nstatic int __build_xattrs(struct inode *inode)\n\t__releases(ci->i_ceph_lock)\n\t__acquires(ci->i_ceph_lock)\n{\n\tu32 namelen;\n\tu32 numattr = 0;\n\tvoid *p, *end;\n\tu32 len;\n\tconst char *name, *val;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 xattr_version;\n\tstruct ceph_inode_xattr **xattrs = NULL;\n\tint err = 0;\n\tint i;\n\n\tdout(\"__build_xattrs() len=%d\\n\",\n\t     ci->i_xattrs.blob ? (int)ci->i_xattrs.blob->vec.iov_len : 0);\n\n\tif (ci->i_xattrs.index_version >= ci->i_xattrs.version)\n\t\treturn 0;  \n\n\t__ceph_destroy_xattrs(ci);\n\nstart:\n\t \n\tif (ci->i_xattrs.blob && ci->i_xattrs.blob->vec.iov_len > 4) {\n\t\tp = ci->i_xattrs.blob->vec.iov_base;\n\t\tend = p + ci->i_xattrs.blob->vec.iov_len;\n\t\tceph_decode_32_safe(&p, end, numattr, bad);\n\t\txattr_version = ci->i_xattrs.version;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\txattrs = kcalloc(numattr, sizeof(struct ceph_inode_xattr *),\n\t\t\t\t GFP_NOFS);\n\t\terr = -ENOMEM;\n\t\tif (!xattrs)\n\t\t\tgoto bad_lock;\n\n\t\tfor (i = 0; i < numattr; i++) {\n\t\t\txattrs[i] = kmalloc(sizeof(struct ceph_inode_xattr),\n\t\t\t\t\t    GFP_NOFS);\n\t\t\tif (!xattrs[i])\n\t\t\t\tgoto bad_lock;\n\t\t}\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.version != xattr_version) {\n\t\t\t \n\t\t\tfor (i = 0; i < numattr; i++)\n\t\t\t\tkfree(xattrs[i]);\n\t\t\tkfree(xattrs);\n\t\t\txattrs = NULL;\n\t\t\tgoto start;\n\t\t}\n\t\terr = -EIO;\n\t\twhile (numattr--) {\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tnamelen = len;\n\t\t\tname = p;\n\t\t\tp += len;\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tval = p;\n\t\t\tp += len;\n\n\t\t\terr = __set_xattr(ci, name, namelen, val, len,\n\t\t\t\t\t  0, 0, &xattrs[numattr]);\n\n\t\t\tif (err < 0)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.index_version = ci->i_xattrs.version;\n\tci->i_xattrs.dirty = false;\n\n\treturn err;\nbad_lock:\n\tspin_lock(&ci->i_ceph_lock);\nbad:\n\tif (xattrs) {\n\t\tfor (i = 0; i < numattr; i++)\n\t\t\tkfree(xattrs[i]);\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.names_size = 0;\n\treturn err;\n}\n\nstatic int __get_required_blob_size(struct ceph_inode_info *ci, int name_size,\n\t\t\t\t    int val_size)\n{\n\t \n\tint size = 4 + ci->i_xattrs.count*(4 + 4) +\n\t\t\t     ci->i_xattrs.names_size +\n\t\t\t     ci->i_xattrs.vals_size;\n\tdout(\"__get_required_blob_size c=%d names.size=%d vals.size=%d\\n\",\n\t     ci->i_xattrs.count, ci->i_xattrs.names_size,\n\t     ci->i_xattrs.vals_size);\n\n\tif (name_size)\n\t\tsize += 4 + 4 + name_size + val_size;\n\n\treturn size;\n}\n\n \nstruct ceph_buffer *__ceph_build_xattrs_blob(struct ceph_inode_info *ci)\n{\n\tstruct rb_node *p;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tstruct ceph_buffer *old_blob = NULL;\n\tvoid *dest;\n\n\tdout(\"__build_xattrs_blob %p\\n\", &ci->netfs.inode);\n\tif (ci->i_xattrs.dirty) {\n\t\tint need = __get_required_blob_size(ci, 0, 0);\n\n\t\tBUG_ON(need > ci->i_xattrs.prealloc_blob->alloc_len);\n\n\t\tp = rb_first(&ci->i_xattrs.index);\n\t\tdest = ci->i_xattrs.prealloc_blob->vec.iov_base;\n\n\t\tceph_encode_32(&dest, ci->i_xattrs.count);\n\t\twhile (p) {\n\t\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\n\t\t\tceph_encode_32(&dest, xattr->name_len);\n\t\t\tmemcpy(dest, xattr->name, xattr->name_len);\n\t\t\tdest += xattr->name_len;\n\t\t\tceph_encode_32(&dest, xattr->val_len);\n\t\t\tmemcpy(dest, xattr->val, xattr->val_len);\n\t\t\tdest += xattr->val_len;\n\n\t\t\tp = rb_next(p);\n\t\t}\n\n\t\t \n\t\tci->i_xattrs.prealloc_blob->vec.iov_len =\n\t\t\tdest - ci->i_xattrs.prealloc_blob->vec.iov_base;\n\n\t\tif (ci->i_xattrs.blob)\n\t\t\told_blob = ci->i_xattrs.blob;\n\t\tci->i_xattrs.blob = ci->i_xattrs.prealloc_blob;\n\t\tci->i_xattrs.prealloc_blob = NULL;\n\t\tci->i_xattrs.dirty = false;\n\t\tci->i_xattrs.version++;\n\t}\n\n\treturn old_blob;\n}\n\nstatic inline int __get_request_mask(struct inode *in) {\n\tstruct ceph_mds_request *req = current->journal_info;\n\tint mask = 0;\n\tif (req && req->r_target_inode == in) {\n\t\tif (req->r_op == CEPH_MDS_OP_LOOKUP ||\n\t\t    req->r_op == CEPH_MDS_OP_LOOKUPINO ||\n\t\t    req->r_op == CEPH_MDS_OP_LOOKUPPARENT ||\n\t\t    req->r_op == CEPH_MDS_OP_GETATTR) {\n\t\t\tmask = le32_to_cpu(req->r_args.getattr.mask);\n\t\t} else if (req->r_op == CEPH_MDS_OP_OPEN ||\n\t\t\t   req->r_op == CEPH_MDS_OP_CREATE) {\n\t\t\tmask = le32_to_cpu(req->r_args.open.mask);\n\t\t}\n\t}\n\treturn mask;\n}\n\nssize_t __ceph_getxattr(struct inode *inode, const char *name, void *value,\n\t\t      size_t size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_inode_xattr *xattr;\n\tstruct ceph_vxattr *vxattr;\n\tint req_mask;\n\tssize_t err;\n\n\tif (strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN))\n\t\tgoto handle_non_vxattrs;\n\n\t \n\tvxattr = ceph_match_vxattr(inode, name);\n\tif (vxattr) {\n\t\tint mask = 0;\n\t\tif (vxattr->flags & VXATTR_FLAG_RSTAT)\n\t\t\tmask |= CEPH_STAT_RSTAT;\n\t\tif (vxattr->flags & VXATTR_FLAG_DIRSTAT)\n\t\t\tmask |= CEPH_CAP_FILE_SHARED;\n\t\terr = ceph_do_getattr(inode, mask, true);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = -ENODATA;\n\t\tif (!(vxattr->exists_cb && !vxattr->exists_cb(ci))) {\n\t\t\terr = vxattr->getxattr_cb(ci, value, size);\n\t\t\tif (size && size < err)\n\t\t\t\terr = -ERANGE;\n\t\t}\n\t\treturn err;\n\t} else {\n\t\terr = ceph_do_getvxattr(inode, name, value, size);\n\t\t \n\t\tif (err == -EOPNOTSUPP)\n\t\t\terr = -ENODATA;\n\t\treturn err;\n\t}\nhandle_non_vxattrs:\n\treq_mask = __get_request_mask(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"getxattr %p name '%s' ver=%lld index_ver=%lld\\n\", inode, name,\n\t     ci->i_xattrs.version, ci->i_xattrs.index_version);\n\n\tif (ci->i_xattrs.version == 0 ||\n\t    !((req_mask & CEPH_CAP_XATTR_SHARED) ||\n\t      __ceph_caps_issued_mask_metric(ci, CEPH_CAP_XATTR_SHARED, 1))) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t \n\t\tif (current->journal_info) {\n\t\t\tpr_warn_ratelimited(\"sync getxattr %p \"\n\t\t\t\t\t    \"during filling trace\\n\", inode);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\t \n\t\terr = ceph_do_getattr(inode, CEPH_STAT_CAP_XATTR, true);\n\t\tif (err)\n\t\t\treturn err;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t}\n\n\terr = __build_xattrs(inode);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = -ENODATA;   \n\txattr = __get_xattr(ci, name);\n\tif (!xattr)\n\t\tgoto out;\n\n\terr = -ERANGE;\n\tif (size && size < xattr->val_len)\n\t\tgoto out;\n\n\terr = xattr->val_len;\n\tif (size == 0)\n\t\tgoto out;\n\n\tmemcpy(value, xattr->val, xattr->val_len);\n\n\tif (current->journal_info &&\n\t    !strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    security_ismaclabel(name + XATTR_SECURITY_PREFIX_LEN))\n\t\tci->i_ceph_flags |= CEPH_I_SEC_INITED;\nout:\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn err;\n}\n\nssize_t ceph_listxattr(struct dentry *dentry, char *names, size_t size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tbool len_only = (size == 0);\n\tu32 namelen;\n\tint err;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"listxattr %p ver=%lld index_ver=%lld\\n\", inode,\n\t     ci->i_xattrs.version, ci->i_xattrs.index_version);\n\n\tif (ci->i_xattrs.version == 0 ||\n\t    !__ceph_caps_issued_mask_metric(ci, CEPH_CAP_XATTR_SHARED, 1)) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\terr = ceph_do_getattr(inode, CEPH_STAT_CAP_XATTR, true);\n\t\tif (err)\n\t\t\treturn err;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t}\n\n\terr = __build_xattrs(inode);\n\tif (err < 0)\n\t\tgoto out;\n\n\t \n\tnamelen = ci->i_xattrs.names_size + ci->i_xattrs.count;\n\tif (!len_only) {\n\t\tif (namelen > size) {\n\t\t\terr = -ERANGE;\n\t\t\tgoto out;\n\t\t}\n\t\tnames = __copy_xattr_names(ci, names);\n\t\tsize -= namelen;\n\t}\n\terr = namelen;\nout:\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn err;\n}\n\nstatic int ceph_sync_setxattr(struct inode *inode, const char *name,\n\t\t\t      const char *value, size_t size, int flags)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_request *req;\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_osd_client *osdc = &fsc->client->osdc;\n\tstruct ceph_pagelist *pagelist = NULL;\n\tint op = CEPH_MDS_OP_SETXATTR;\n\tint err;\n\n\tif (size > 0) {\n\t\t \n\t\tpagelist = ceph_pagelist_alloc(GFP_NOFS);\n\t\tif (!pagelist)\n\t\t\treturn -ENOMEM;\n\n\t\terr = ceph_pagelist_append(pagelist, value, size);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else if (!value) {\n\t\tif (flags & CEPH_XATTR_REPLACE)\n\t\t\top = CEPH_MDS_OP_RMXATTR;\n\t\telse\n\t\t\tflags |= CEPH_XATTR_REMOVE;\n\t}\n\n\tdout(\"setxattr value size: %zu\\n\", size);\n\n\t \n\treq = ceph_mdsc_create_request(mdsc, op, USE_AUTH_MDS);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\treq->r_path2 = kstrdup(name, GFP_NOFS);\n\tif (!req->r_path2) {\n\t\tceph_mdsc_put_request(req);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (op == CEPH_MDS_OP_SETXATTR) {\n\t\treq->r_args.setxattr.flags = cpu_to_le32(flags);\n\t\treq->r_args.setxattr.osdmap_epoch =\n\t\t\tcpu_to_le32(osdc->osdmap->epoch);\n\t\treq->r_pagelist = pagelist;\n\t\tpagelist = NULL;\n\t}\n\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\treq->r_inode_drop = CEPH_CAP_XATTR_SHARED;\n\n\tdout(\"xattr.ver (before): %lld\\n\", ci->i_xattrs.version);\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tceph_mdsc_put_request(req);\n\tdout(\"xattr.ver (after): %lld\\n\", ci->i_xattrs.version);\n\nout:\n\tif (pagelist)\n\t\tceph_pagelist_release(pagelist);\n\treturn err;\n}\n\nint __ceph_setxattr(struct inode *inode, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tstruct ceph_vxattr *vxattr;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_cap_flush *prealloc_cf = NULL;\n\tstruct ceph_buffer *old_blob = NULL;\n\tint issued;\n\tint err;\n\tint dirty = 0;\n\tint name_len = strlen(name);\n\tint val_len = size;\n\tchar *newname = NULL;\n\tchar *newval = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint required_blob_size;\n\tbool check_realm = false;\n\tbool lock_snap_rwsem = false;\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tvxattr = ceph_match_vxattr(inode, name);\n\tif (vxattr) {\n\t\tif (vxattr->flags & VXATTR_FLAG_READONLY)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (value && !strncmp(vxattr->name, \"ceph.quota\", 10))\n\t\t\tcheck_realm = true;\n\t}\n\n\t \n\tif (!strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN))\n\t\tgoto do_sync_unlocked;\n\n\t \n\terr = -ENOMEM;\n\tnewname = kmemdup(name, name_len + 1, GFP_NOFS);\n\tif (!newname)\n\t\tgoto out;\n\n\tif (val_len) {\n\t\tnewval = kmemdup(value, val_len, GFP_NOFS);\n\t\tif (!newval)\n\t\t\tgoto out;\n\t}\n\n\txattr = kmalloc(sizeof(struct ceph_inode_xattr), GFP_NOFS);\n\tif (!xattr)\n\t\tgoto out;\n\n\tprealloc_cf = ceph_alloc_cap_flush();\n\tif (!prealloc_cf)\n\t\tgoto out;\n\n\tspin_lock(&ci->i_ceph_lock);\nretry:\n\tissued = __ceph_caps_issued(ci, NULL);\n\trequired_blob_size = __get_required_blob_size(ci, name_len, val_len);\n\tif ((ci->i_xattrs.version == 0) || !(issued & CEPH_CAP_XATTR_EXCL) ||\n\t    (required_blob_size > mdsc->mdsmap->m_max_xattr_size)) {\n\t\tdout(\"%s do sync setxattr: version: %llu size: %d max: %llu\\n\",\n\t\t     __func__, ci->i_xattrs.version, required_blob_size,\n\t\t     mdsc->mdsmap->m_max_xattr_size);\n\t\tgoto do_sync;\n\t}\n\n\tif (!lock_snap_rwsem && !ci->i_head_snapc) {\n\t\tlock_snap_rwsem = true;\n\t\tif (!down_read_trylock(&mdsc->snap_rwsem)) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tdout(\"setxattr %p name '%s' issued %s\\n\", inode, name,\n\t     ceph_cap_string(issued));\n\t__build_xattrs(inode);\n\n\tif (!ci->i_xattrs.prealloc_blob ||\n\t    required_blob_size > ci->i_xattrs.prealloc_blob->alloc_len) {\n\t\tstruct ceph_buffer *blob;\n\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tceph_buffer_put(old_blob);  \n\t\tdout(\" pre-allocating new blob size=%d\\n\", required_blob_size);\n\t\tblob = ceph_buffer_new(required_blob_size, GFP_NOFS);\n\t\tif (!blob)\n\t\t\tgoto do_sync_unlocked;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\t \n\t\tif (ci->i_xattrs.prealloc_blob)\n\t\t\told_blob = ci->i_xattrs.prealloc_blob;\n\t\tci->i_xattrs.prealloc_blob = blob;\n\t\tgoto retry;\n\t}\n\n\terr = __set_xattr(ci, newname, name_len, newval, val_len,\n\t\t\t  flags, value ? 1 : -1, &xattr);\n\n\tif (!err) {\n\t\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_XATTR_EXCL,\n\t\t\t\t\t       &prealloc_cf);\n\t\tci->i_xattrs.dirty = true;\n\t\tinode_set_ctime_current(inode);\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tceph_buffer_put(old_blob);\n\tif (lock_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n\tif (dirty)\n\t\t__mark_inode_dirty(inode, dirty);\n\tceph_free_cap_flush(prealloc_cf);\n\treturn err;\n\ndo_sync:\n\tspin_unlock(&ci->i_ceph_lock);\ndo_sync_unlocked:\n\tif (lock_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n\n\t \n\tif (current->journal_info) {\n\t\tpr_warn_ratelimited(\"sync setxattr %p \"\n\t\t\t\t    \"during filling trace\\n\", inode);\n\t\terr = -EBUSY;\n\t} else {\n\t\terr = ceph_sync_setxattr(inode, name, value, size, flags);\n\t\tif (err >= 0 && check_realm) {\n\t\t\t \n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tif ((ci->i_max_files || ci->i_max_bytes) &&\n\t\t\t    !(ci->i_snap_realm &&\n\t\t\t      ci->i_snap_realm->ino == ci->i_vino.ino))\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t}\n\t}\nout:\n\tceph_free_cap_flush(prealloc_cf);\n\tkfree(newname);\n\tkfree(newval);\n\tkfree(xattr);\n\treturn err;\n}\n\nstatic int ceph_get_xattr_handler(const struct xattr_handler *handler,\n\t\t\t\t  struct dentry *dentry, struct inode *inode,\n\t\t\t\t  const char *name, void *value, size_t size)\n{\n\tif (!ceph_is_valid_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\treturn __ceph_getxattr(inode, name, value, size);\n}\n\nstatic int ceph_set_xattr_handler(const struct xattr_handler *handler,\n\t\t\t\t  struct mnt_idmap *idmap,\n\t\t\t\t  struct dentry *unused, struct inode *inode,\n\t\t\t\t  const char *name, const void *value,\n\t\t\t\t  size_t size, int flags)\n{\n\tif (!ceph_is_valid_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\treturn __ceph_setxattr(inode, name, value, size, flags);\n}\n\nstatic const struct xattr_handler ceph_other_xattr_handler = {\n\t.prefix = \"\",   \n\t.get = ceph_get_xattr_handler,\n\t.set = ceph_set_xattr_handler,\n};\n\n#ifdef CONFIG_SECURITY\nbool ceph_security_xattr_wanted(struct inode *in)\n{\n\treturn in->i_security != NULL;\n}\n\nbool ceph_security_xattr_deadlock(struct inode *in)\n{\n\tstruct ceph_inode_info *ci;\n\tbool ret;\n\tif (!in->i_security)\n\t\treturn false;\n\tci = ceph_inode(in);\n\tspin_lock(&ci->i_ceph_lock);\n\tret = !(ci->i_ceph_flags & CEPH_I_SEC_INITED) &&\n\t      !(ci->i_xattrs.version > 0 &&\n\t\t__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0));\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}\n\n#ifdef CONFIG_CEPH_FS_SECURITY_LABEL\nint ceph_security_init_secctx(struct dentry *dentry, umode_t mode,\n\t\t\t   struct ceph_acl_sec_ctx *as_ctx)\n{\n\tstruct ceph_pagelist *pagelist = as_ctx->pagelist;\n\tconst char *name;\n\tsize_t name_len;\n\tint err;\n\n\terr = security_dentry_init_security(dentry, mode, &dentry->d_name,\n\t\t\t\t\t    &name, &as_ctx->sec_ctx,\n\t\t\t\t\t    &as_ctx->sec_ctxlen);\n\tif (err < 0) {\n\t\tWARN_ON_ONCE(err != -EOPNOTSUPP);\n\t\terr = 0;  \n\t\tgoto out;\n\t}\n\n\terr = -ENOMEM;\n\tif (!pagelist) {\n\t\tpagelist = ceph_pagelist_alloc(GFP_KERNEL);\n\t\tif (!pagelist)\n\t\t\tgoto out;\n\t\terr = ceph_pagelist_reserve(pagelist, PAGE_SIZE);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tceph_pagelist_encode_32(pagelist, 1);\n\t}\n\n\t \n\tname_len = strlen(name);\n\terr = ceph_pagelist_reserve(pagelist,\n\t\t\t\t    4 * 2 + name_len + as_ctx->sec_ctxlen);\n\tif (err)\n\t\tgoto out;\n\n\tif (as_ctx->pagelist) {\n\t\t \n\t\tBUG_ON(pagelist->length <= sizeof(__le32));\n\t\tif (list_is_singular(&pagelist->head)) {\n\t\t\tle32_add_cpu((__le32*)pagelist->mapped_tail, 1);\n\t\t} else {\n\t\t\tstruct page *page = list_first_entry(&pagelist->head,\n\t\t\t\t\t\t\t     struct page, lru);\n\t\t\tvoid *addr = kmap_atomic(page);\n\t\t\tle32_add_cpu((__le32*)addr, 1);\n\t\t\tkunmap_atomic(addr);\n\t\t}\n\t} else {\n\t\tas_ctx->pagelist = pagelist;\n\t}\n\n\tceph_pagelist_encode_32(pagelist, name_len);\n\tceph_pagelist_append(pagelist, name, name_len);\n\n\tceph_pagelist_encode_32(pagelist, as_ctx->sec_ctxlen);\n\tceph_pagelist_append(pagelist, as_ctx->sec_ctx, as_ctx->sec_ctxlen);\n\n\terr = 0;\nout:\n\tif (pagelist && !as_ctx->pagelist)\n\t\tceph_pagelist_release(pagelist);\n\treturn err;\n}\n#endif  \n#endif  \n\nvoid ceph_release_acl_sec_ctx(struct ceph_acl_sec_ctx *as_ctx)\n{\n#ifdef CONFIG_CEPH_FS_POSIX_ACL\n\tposix_acl_release(as_ctx->acl);\n\tposix_acl_release(as_ctx->default_acl);\n#endif\n#ifdef CONFIG_CEPH_FS_SECURITY_LABEL\n\tsecurity_release_secctx(as_ctx->sec_ctx, as_ctx->sec_ctxlen);\n#endif\n#ifdef CONFIG_FS_ENCRYPTION\n\tkfree(as_ctx->fscrypt_auth);\n#endif\n\tif (as_ctx->pagelist)\n\t\tceph_pagelist_release(as_ctx->pagelist);\n}\n\n \nconst struct xattr_handler *ceph_xattr_handlers[] = {\n\t&ceph_other_xattr_handler,\n\tNULL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}