{
  "module_name": "inode.c",
  "hash_id": "60a1f7737daec8cc5341da37b03a4535177f3f75325c5471e884ae7cadbd8c4b",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/inode.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/random.h>\n#include <linux/sort.h>\n#include <linux/iversion.h>\n#include <linux/fscrypt.h>\n\n#include \"super.h\"\n#include \"mds_client.h\"\n#include \"cache.h\"\n#include \"crypto.h\"\n#include <linux/ceph/decode.h>\n\n \n\nstatic const struct inode_operations ceph_symlink_iops;\nstatic const struct inode_operations ceph_encrypted_symlink_iops;\n\nstatic void ceph_inode_work(struct work_struct *work);\n\n \nstatic int ceph_set_ino_cb(struct inode *inode, void *data)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(inode->i_sb);\n\n\tci->i_vino = *(struct ceph_vino *)data;\n\tinode->i_ino = ceph_vino_to_ino_t(ci->i_vino);\n\tinode_set_iversion_raw(inode, 0);\n\tpercpu_counter_inc(&mdsc->metric.total_inodes);\n\n\treturn 0;\n}\n\n \nstruct inode *ceph_new_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t     umode_t *mode, struct ceph_acl_sec_ctx *as_ctx)\n{\n\tint err;\n\tstruct inode *inode;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!S_ISLNK(*mode)) {\n\t\terr = ceph_pre_init_acls(dir, mode, as_ctx);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t}\n\n\tinode->i_state = 0;\n\tinode->i_mode = *mode;\n\n\terr = ceph_security_init_secctx(dentry, *mode, as_ctx);\n\tif (err < 0)\n\t\tgoto out_err;\n\n\t \n\tif (ceph_snap(dir) != CEPH_SNAPDIR) {\n\t\terr = ceph_fscrypt_prepare_context(dir, inode, as_ctx);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\treturn inode;\nout_err:\n\tiput(inode);\n\treturn ERR_PTR(err);\n}\n\nvoid ceph_as_ctx_to_req(struct ceph_mds_request *req,\n\t\t\tstruct ceph_acl_sec_ctx *as_ctx)\n{\n\tif (as_ctx->pagelist) {\n\t\treq->r_pagelist = as_ctx->pagelist;\n\t\tas_ctx->pagelist = NULL;\n\t}\n\tceph_fscrypt_as_ctx_to_req(req, as_ctx);\n}\n\n \nstruct inode *ceph_get_inode(struct super_block *sb, struct ceph_vino vino,\n\t\t\t     struct inode *newino)\n{\n\tstruct inode *inode;\n\n\tif (ceph_vino_is_reserved(vino))\n\t\treturn ERR_PTR(-EREMOTEIO);\n\n\tif (newino) {\n\t\tinode = inode_insert5(newino, (unsigned long)vino.ino,\n\t\t\t\t      ceph_ino_compare, ceph_set_ino_cb, &vino);\n\t\tif (inode != newino)\n\t\t\tiput(newino);\n\t} else {\n\t\tinode = iget5_locked(sb, (unsigned long)vino.ino,\n\t\t\t\t     ceph_ino_compare, ceph_set_ino_cb, &vino);\n\t}\n\n\tif (!inode) {\n\t\tdout(\"No inode found for %llx.%llx\\n\", vino.ino, vino.snap);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdout(\"get_inode on %llu=%llx.%llx got %p new %d\\n\", ceph_present_inode(inode),\n\t     ceph_vinop(inode), inode, !!(inode->i_state & I_NEW));\n\treturn inode;\n}\n\n \nstruct inode *ceph_get_snapdir(struct inode *parent)\n{\n\tstruct ceph_vino vino = {\n\t\t.ino = ceph_ino(parent),\n\t\t.snap = CEPH_SNAPDIR,\n\t};\n\tstruct inode *inode = ceph_get_inode(parent->i_sb, vino, NULL);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret = -ENOTDIR;\n\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\tif (!S_ISDIR(parent->i_mode)) {\n\t\tpr_warn_once(\"bad snapdir parent type (mode=0%o)\\n\",\n\t\t\t     parent->i_mode);\n\t\tgoto err;\n\t}\n\n\tif (!(inode->i_state & I_NEW) && !S_ISDIR(inode->i_mode)) {\n\t\tpr_warn_once(\"bad snapdir inode type (mode=0%o)\\n\",\n\t\t\t     inode->i_mode);\n\t\tgoto err;\n\t}\n\n\tinode->i_mode = parent->i_mode;\n\tinode->i_uid = parent->i_uid;\n\tinode->i_gid = parent->i_gid;\n\tinode->i_mtime = parent->i_mtime;\n\tinode_set_ctime_to_ts(inode, inode_get_ctime(parent));\n\tinode->i_atime = parent->i_atime;\n\tci->i_rbytes = 0;\n\tci->i_btime = ceph_inode(parent)->i_btime;\n\n#ifdef CONFIG_FS_ENCRYPTION\n\t \n\tif (IS_ENCRYPTED(parent)) {\n\t\tstruct ceph_inode_info *pci = ceph_inode(parent);\n\n\t\tci->fscrypt_auth = kmemdup(pci->fscrypt_auth,\n\t\t\t\t\t   pci->fscrypt_auth_len,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (ci->fscrypt_auth) {\n\t\t\tinode->i_flags |= S_ENCRYPTED;\n\t\t\tci->fscrypt_auth_len = pci->fscrypt_auth_len;\n\t\t} else {\n\t\t\tdout(\"Failed to alloc snapdir fscrypt_auth\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n#endif\n\tif (inode->i_state & I_NEW) {\n\t\tinode->i_op = &ceph_snapdir_iops;\n\t\tinode->i_fop = &ceph_snapdir_fops;\n\t\tci->i_snap_caps = CEPH_CAP_PIN;  \n\t\tunlock_new_inode(inode);\n\t}\n\n\treturn inode;\nerr:\n\tif ((inode->i_state & I_NEW))\n\t\tdiscard_new_inode(inode);\n\telse\n\t\tiput(inode);\n\treturn ERR_PTR(ret);\n}\n\nconst struct inode_operations ceph_file_iops = {\n\t.permission = ceph_permission,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_getattr,\n\t.listxattr = ceph_listxattr,\n\t.get_inode_acl = ceph_get_acl,\n\t.set_acl = ceph_set_acl,\n};\n\n\n \n\n \nstatic struct ceph_inode_frag *__get_or_create_frag(struct ceph_inode_info *ci,\n\t\t\t\t\t\t    u32 f)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_frag *frag;\n\tint c;\n\n\tp = &ci->i_fragtree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfrag = rb_entry(parent, struct ceph_inode_frag, node);\n\t\tc = ceph_frag_compare(f, frag->frag);\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn frag;\n\t}\n\n\tfrag = kmalloc(sizeof(*frag), GFP_NOFS);\n\tif (!frag)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfrag->frag = f;\n\tfrag->split_by = 0;\n\tfrag->mds = -1;\n\tfrag->ndist = 0;\n\n\trb_link_node(&frag->node, parent, p);\n\trb_insert_color(&frag->node, &ci->i_fragtree);\n\n\tdout(\"get_or_create_frag added %llx.%llx frag %x\\n\",\n\t     ceph_vinop(&ci->netfs.inode), f);\n\treturn frag;\n}\n\n \nstruct ceph_inode_frag *__ceph_find_frag(struct ceph_inode_info *ci, u32 f)\n{\n\tstruct rb_node *n = ci->i_fragtree.rb_node;\n\n\twhile (n) {\n\t\tstruct ceph_inode_frag *frag =\n\t\t\trb_entry(n, struct ceph_inode_frag, node);\n\t\tint c = ceph_frag_compare(f, frag->frag);\n\t\tif (c < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (c > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn frag;\n\t}\n\treturn NULL;\n}\n\n \nstatic u32 __ceph_choose_frag(struct ceph_inode_info *ci, u32 v,\n\t\t\t      struct ceph_inode_frag *pfrag, int *found)\n{\n\tu32 t = ceph_frag_make(0, 0);\n\tstruct ceph_inode_frag *frag;\n\tunsigned nway, i;\n\tu32 n;\n\n\tif (found)\n\t\t*found = 0;\n\n\twhile (1) {\n\t\tWARN_ON(!ceph_frag_contains_value(t, v));\n\t\tfrag = __ceph_find_frag(ci, t);\n\t\tif (!frag)\n\t\t\tbreak;  \n\t\tif (frag->split_by == 0) {\n\t\t\tif (pfrag)\n\t\t\t\tmemcpy(pfrag, frag, sizeof(*pfrag));\n\t\t\tif (found)\n\t\t\t\t*found = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tnway = 1 << frag->split_by;\n\t\tdout(\"choose_frag(%x) %x splits by %d (%d ways)\\n\", v, t,\n\t\t     frag->split_by, nway);\n\t\tfor (i = 0; i < nway; i++) {\n\t\t\tn = ceph_frag_make_child(t, frag->split_by, i);\n\t\t\tif (ceph_frag_contains_value(n, v)) {\n\t\t\t\tt = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(i == nway);\n\t}\n\tdout(\"choose_frag(%x) = %x\\n\", v, t);\n\n\treturn t;\n}\n\nu32 ceph_choose_frag(struct ceph_inode_info *ci, u32 v,\n\t\t     struct ceph_inode_frag *pfrag, int *found)\n{\n\tu32 ret;\n\tmutex_lock(&ci->i_fragtree_mutex);\n\tret = __ceph_choose_frag(ci, v, pfrag, found);\n\tmutex_unlock(&ci->i_fragtree_mutex);\n\treturn ret;\n}\n\n \nstatic int ceph_fill_dirfrag(struct inode *inode,\n\t\t\t     struct ceph_mds_reply_dirfrag *dirinfo)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_inode_frag *frag;\n\tu32 id = le32_to_cpu(dirinfo->frag);\n\tint mds = le32_to_cpu(dirinfo->auth);\n\tint ndist = le32_to_cpu(dirinfo->ndist);\n\tint diri_auth = -1;\n\tint i;\n\tint err = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_auth_cap)\n\t\tdiri_auth = ci->i_auth_cap->mds;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (mds == -1)  \n\t\tmds = diri_auth;\n\n\tmutex_lock(&ci->i_fragtree_mutex);\n\tif (ndist == 0 && mds == diri_auth) {\n\t\t \n\t\tfrag = __ceph_find_frag(ci, id);\n\t\tif (!frag)\n\t\t\tgoto out;\n\t\tif (frag->split_by == 0) {\n\t\t\t \n\t\t\tdout(\"fill_dirfrag removed %llx.%llx frag %x\"\n\t\t\t     \" (no ref)\\n\", ceph_vinop(inode), id);\n\t\t\trb_erase(&frag->node, &ci->i_fragtree);\n\t\t\tkfree(frag);\n\t\t} else {\n\t\t\t \n\t\t\tdout(\"fill_dirfrag cleared %llx.%llx frag %x\"\n\t\t\t     \" referral\\n\", ceph_vinop(inode), id);\n\t\t\tfrag->mds = -1;\n\t\t\tfrag->ndist = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\n\t \n\tfrag = __get_or_create_frag(ci, id);\n\tif (IS_ERR(frag)) {\n\t\t \n\t\tpr_err(\"fill_dirfrag ENOMEM on mds ref %llx.%llx fg %x\\n\",\n\t\t       ceph_vinop(inode), le32_to_cpu(dirinfo->frag));\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfrag->mds = mds;\n\tfrag->ndist = min_t(u32, ndist, CEPH_MAX_DIRFRAG_REP);\n\tfor (i = 0; i < frag->ndist; i++)\n\t\tfrag->dist[i] = le32_to_cpu(dirinfo->dist[i]);\n\tdout(\"fill_dirfrag %llx.%llx frag %x ndist=%d\\n\",\n\t     ceph_vinop(inode), frag->frag, frag->ndist);\n\nout:\n\tmutex_unlock(&ci->i_fragtree_mutex);\n\treturn err;\n}\n\nstatic int frag_tree_split_cmp(const void *l, const void *r)\n{\n\tstruct ceph_frag_tree_split *ls = (struct ceph_frag_tree_split*)l;\n\tstruct ceph_frag_tree_split *rs = (struct ceph_frag_tree_split*)r;\n\treturn ceph_frag_compare(le32_to_cpu(ls->frag),\n\t\t\t\t le32_to_cpu(rs->frag));\n}\n\nstatic bool is_frag_child(u32 f, struct ceph_inode_frag *frag)\n{\n\tif (!frag)\n\t\treturn f == ceph_frag_make(0, 0);\n\tif (ceph_frag_bits(f) != ceph_frag_bits(frag->frag) + frag->split_by)\n\t\treturn false;\n\treturn ceph_frag_contains_value(frag->frag, ceph_frag_value(f));\n}\n\nstatic int ceph_fill_fragtree(struct inode *inode,\n\t\t\t      struct ceph_frag_tree_head *fragtree,\n\t\t\t      struct ceph_mds_reply_dirfrag *dirinfo)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_inode_frag *frag, *prev_frag = NULL;\n\tstruct rb_node *rb_node;\n\tunsigned i, split_by, nsplits;\n\tu32 id;\n\tbool update = false;\n\n\tmutex_lock(&ci->i_fragtree_mutex);\n\tnsplits = le32_to_cpu(fragtree->nsplits);\n\tif (nsplits != ci->i_fragtree_nsplits) {\n\t\tupdate = true;\n\t} else if (nsplits) {\n\t\ti = get_random_u32_below(nsplits);\n\t\tid = le32_to_cpu(fragtree->splits[i].frag);\n\t\tif (!__ceph_find_frag(ci, id))\n\t\t\tupdate = true;\n\t} else if (!RB_EMPTY_ROOT(&ci->i_fragtree)) {\n\t\trb_node = rb_first(&ci->i_fragtree);\n\t\tfrag = rb_entry(rb_node, struct ceph_inode_frag, node);\n\t\tif (frag->frag != ceph_frag_make(0, 0) || rb_next(rb_node))\n\t\t\tupdate = true;\n\t}\n\tif (!update && dirinfo) {\n\t\tid = le32_to_cpu(dirinfo->frag);\n\t\tif (id != __ceph_choose_frag(ci, id, NULL, NULL))\n\t\t\tupdate = true;\n\t}\n\tif (!update)\n\t\tgoto out_unlock;\n\n\tif (nsplits > 1) {\n\t\tsort(fragtree->splits, nsplits, sizeof(fragtree->splits[0]),\n\t\t     frag_tree_split_cmp, NULL);\n\t}\n\n\tdout(\"fill_fragtree %llx.%llx\\n\", ceph_vinop(inode));\n\trb_node = rb_first(&ci->i_fragtree);\n\tfor (i = 0; i < nsplits; i++) {\n\t\tid = le32_to_cpu(fragtree->splits[i].frag);\n\t\tsplit_by = le32_to_cpu(fragtree->splits[i].by);\n\t\tif (split_by == 0 || ceph_frag_bits(id) + split_by > 24) {\n\t\t\tpr_err(\"fill_fragtree %llx.%llx invalid split %d/%u, \"\n\t\t\t       \"frag %x split by %d\\n\", ceph_vinop(inode),\n\t\t\t       i, nsplits, id, split_by);\n\t\t\tcontinue;\n\t\t}\n\t\tfrag = NULL;\n\t\twhile (rb_node) {\n\t\t\tfrag = rb_entry(rb_node, struct ceph_inode_frag, node);\n\t\t\tif (ceph_frag_compare(frag->frag, id) >= 0) {\n\t\t\t\tif (frag->frag != id)\n\t\t\t\t\tfrag = NULL;\n\t\t\t\telse\n\t\t\t\t\trb_node = rb_next(rb_node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trb_node = rb_next(rb_node);\n\t\t\t \n\t\t\tif (frag->split_by > 0 ||\n\t\t\t    !is_frag_child(frag->frag, prev_frag)) {\n\t\t\t\trb_erase(&frag->node, &ci->i_fragtree);\n\t\t\t\tif (frag->split_by > 0)\n\t\t\t\t\tci->i_fragtree_nsplits--;\n\t\t\t\tkfree(frag);\n\t\t\t}\n\t\t\tfrag = NULL;\n\t\t}\n\t\tif (!frag) {\n\t\t\tfrag = __get_or_create_frag(ci, id);\n\t\t\tif (IS_ERR(frag))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (frag->split_by == 0)\n\t\t\tci->i_fragtree_nsplits++;\n\t\tfrag->split_by = split_by;\n\t\tdout(\" frag %x split by %d\\n\", frag->frag, frag->split_by);\n\t\tprev_frag = frag;\n\t}\n\twhile (rb_node) {\n\t\tfrag = rb_entry(rb_node, struct ceph_inode_frag, node);\n\t\trb_node = rb_next(rb_node);\n\t\t \n\t\tif (frag->split_by > 0 ||\n\t\t    !is_frag_child(frag->frag, prev_frag)) {\n\t\t\trb_erase(&frag->node, &ci->i_fragtree);\n\t\t\tif (frag->split_by > 0)\n\t\t\t\tci->i_fragtree_nsplits--;\n\t\t\tkfree(frag);\n\t\t}\n\t}\nout_unlock:\n\tmutex_unlock(&ci->i_fragtree_mutex);\n\treturn 0;\n}\n\n \nstruct inode *ceph_alloc_inode(struct super_block *sb)\n{\n\tstruct ceph_inode_info *ci;\n\tint i;\n\n\tci = alloc_inode_sb(sb, ceph_inode_cachep, GFP_NOFS);\n\tif (!ci)\n\t\treturn NULL;\n\n\tdout(\"alloc_inode %p\\n\", &ci->netfs.inode);\n\n\t \n\tnetfs_inode_init(&ci->netfs, &ceph_netfs_ops);\n\n\tspin_lock_init(&ci->i_ceph_lock);\n\n\tci->i_version = 0;\n\tci->i_inline_version = 0;\n\tci->i_time_warp_seq = 0;\n\tci->i_ceph_flags = 0;\n\tatomic64_set(&ci->i_ordered_count, 1);\n\tatomic64_set(&ci->i_release_count, 1);\n\tatomic64_set(&ci->i_complete_seq[0], 0);\n\tatomic64_set(&ci->i_complete_seq[1], 0);\n\tci->i_symlink = NULL;\n\n\tci->i_max_bytes = 0;\n\tci->i_max_files = 0;\n\n\tmemset(&ci->i_dir_layout, 0, sizeof(ci->i_dir_layout));\n\tmemset(&ci->i_cached_layout, 0, sizeof(ci->i_cached_layout));\n\tRCU_INIT_POINTER(ci->i_layout.pool_ns, NULL);\n\n\tci->i_fragtree = RB_ROOT;\n\tmutex_init(&ci->i_fragtree_mutex);\n\n\tci->i_xattrs.blob = NULL;\n\tci->i_xattrs.prealloc_blob = NULL;\n\tci->i_xattrs.dirty = false;\n\tci->i_xattrs.index = RB_ROOT;\n\tci->i_xattrs.count = 0;\n\tci->i_xattrs.names_size = 0;\n\tci->i_xattrs.vals_size = 0;\n\tci->i_xattrs.version = 0;\n\tci->i_xattrs.index_version = 0;\n\n\tci->i_caps = RB_ROOT;\n\tci->i_auth_cap = NULL;\n\tci->i_dirty_caps = 0;\n\tci->i_flushing_caps = 0;\n\tINIT_LIST_HEAD(&ci->i_dirty_item);\n\tINIT_LIST_HEAD(&ci->i_flushing_item);\n\tci->i_prealloc_cap_flush = NULL;\n\tINIT_LIST_HEAD(&ci->i_cap_flush_list);\n\tinit_waitqueue_head(&ci->i_cap_wq);\n\tci->i_hold_caps_max = 0;\n\tINIT_LIST_HEAD(&ci->i_cap_delay_list);\n\tINIT_LIST_HEAD(&ci->i_cap_snaps);\n\tci->i_head_snapc = NULL;\n\tci->i_snap_caps = 0;\n\n\tci->i_last_rd = ci->i_last_wr = jiffies - 3600 * HZ;\n\tfor (i = 0; i < CEPH_FILE_MODE_BITS; i++)\n\t\tci->i_nr_by_mode[i] = 0;\n\n\tmutex_init(&ci->i_truncate_mutex);\n\tci->i_truncate_seq = 0;\n\tci->i_truncate_size = 0;\n\tci->i_truncate_pending = 0;\n\tci->i_truncate_pagecache_size = 0;\n\n\tci->i_max_size = 0;\n\tci->i_reported_size = 0;\n\tci->i_wanted_max_size = 0;\n\tci->i_requested_max_size = 0;\n\n\tci->i_pin_ref = 0;\n\tci->i_rd_ref = 0;\n\tci->i_rdcache_ref = 0;\n\tci->i_wr_ref = 0;\n\tci->i_wb_ref = 0;\n\tci->i_fx_ref = 0;\n\tci->i_wrbuffer_ref = 0;\n\tci->i_wrbuffer_ref_head = 0;\n\tatomic_set(&ci->i_filelock_ref, 0);\n\tatomic_set(&ci->i_shared_gen, 1);\n\tci->i_rdcache_gen = 0;\n\tci->i_rdcache_revoking = 0;\n\n\tINIT_LIST_HEAD(&ci->i_unsafe_dirops);\n\tINIT_LIST_HEAD(&ci->i_unsafe_iops);\n\tspin_lock_init(&ci->i_unsafe_lock);\n\n\tci->i_snap_realm = NULL;\n\tINIT_LIST_HEAD(&ci->i_snap_realm_item);\n\tINIT_LIST_HEAD(&ci->i_snap_flush_item);\n\n\tINIT_WORK(&ci->i_work, ceph_inode_work);\n\tci->i_work_mask = 0;\n\tmemset(&ci->i_btime, '\\0', sizeof(ci->i_btime));\n#ifdef CONFIG_FS_ENCRYPTION\n\tci->fscrypt_auth = NULL;\n\tci->fscrypt_auth_len = 0;\n#endif\n\treturn &ci->netfs.inode;\n}\n\nvoid ceph_free_inode(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tkfree(ci->i_symlink);\n#ifdef CONFIG_FS_ENCRYPTION\n\tkfree(ci->fscrypt_auth);\n#endif\n\tfscrypt_free_inode(inode);\n\tkmem_cache_free(ceph_inode_cachep, ci);\n}\n\nvoid ceph_evict_inode(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(inode->i_sb);\n\tstruct ceph_inode_frag *frag;\n\tstruct rb_node *n;\n\n\tdout(\"evict_inode %p ino %llx.%llx\\n\", inode, ceph_vinop(inode));\n\n\tpercpu_counter_dec(&mdsc->metric.total_inodes);\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (inode->i_state & I_PINNING_FSCACHE_WB)\n\t\tceph_fscache_unuse_cookie(inode, true);\n\tclear_inode(inode);\n\n\tceph_fscache_unregister_inode_cookie(ci);\n\tfscrypt_put_encryption_info(inode);\n\n\t__ceph_remove_caps(ci);\n\n\tif (__ceph_has_quota(ci, QUOTA_GET_ANY))\n\t\tceph_adjust_quota_realms_count(inode, false);\n\n\t \n\tif (ci->i_snap_realm) {\n\t\tif (ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t\tdout(\" dropping residual ref to snap realm %p\\n\",\n\t\t\t     ci->i_snap_realm);\n\t\t\tceph_change_snap_realm(inode, NULL);\n\t\t} else {\n\t\t\tceph_put_snapid_map(mdsc, ci->i_snapid_map);\n\t\t\tci->i_snap_realm = NULL;\n\t\t}\n\t}\n\n\twhile ((n = rb_first(&ci->i_fragtree)) != NULL) {\n\t\tfrag = rb_entry(n, struct ceph_inode_frag, node);\n\t\trb_erase(n, &ci->i_fragtree);\n\t\tkfree(frag);\n\t}\n\tci->i_fragtree_nsplits = 0;\n\n\t__ceph_destroy_xattrs(ci);\n\tif (ci->i_xattrs.blob)\n\t\tceph_buffer_put(ci->i_xattrs.blob);\n\tif (ci->i_xattrs.prealloc_blob)\n\t\tceph_buffer_put(ci->i_xattrs.prealloc_blob);\n\n\tceph_put_string(rcu_dereference_raw(ci->i_layout.pool_ns));\n\tceph_put_string(rcu_dereference_raw(ci->i_cached_layout.pool_ns));\n}\n\nstatic inline blkcnt_t calc_inode_blocks(u64 size)\n{\n\treturn (size + (1<<9) - 1) >> 9;\n}\n\n \nint ceph_fill_file_size(struct inode *inode, int issued,\n\t\t\tu32 truncate_seq, u64 truncate_size, u64 size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint queue_trunc = 0;\n\tloff_t isize = i_size_read(inode);\n\n\tif (ceph_seq_cmp(truncate_seq, ci->i_truncate_seq) > 0 ||\n\t    (truncate_seq == ci->i_truncate_seq && size > isize)) {\n\t\tdout(\"size %lld -> %llu\\n\", isize, size);\n\t\tif (size > 0 && S_ISDIR(inode->i_mode)) {\n\t\t\tpr_err(\"fill_file_size non-zero size for directory\\n\");\n\t\t\tsize = 0;\n\t\t}\n\t\ti_size_write(inode, size);\n\t\tinode->i_blocks = calc_inode_blocks(size);\n\t\t \n\t\tif (size > isize)\n\t\t\tceph_fscache_update(inode);\n\t\tci->i_reported_size = size;\n\t\tif (truncate_seq != ci->i_truncate_seq) {\n\t\t\tdout(\"%s truncate_seq %u -> %u\\n\", __func__,\n\t\t\t     ci->i_truncate_seq, truncate_seq);\n\t\t\tci->i_truncate_seq = truncate_seq;\n\n\t\t\t \n\t\t\tWARN_ON_ONCE(issued & (CEPH_CAP_FILE_RD |\n\t\t\t\t\t       CEPH_CAP_FILE_LAZYIO));\n\t\t\t \n\t\t\tif ((issued & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t       CEPH_CAP_FILE_BUFFER)) ||\n\t\t\t    mapping_mapped(inode->i_mapping) ||\n\t\t\t    __ceph_is_file_opened(ci)) {\n\t\t\t\tci->i_truncate_pending++;\n\t\t\t\tqueue_trunc = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (ceph_seq_cmp(truncate_seq, ci->i_truncate_seq) >= 0) {\n\t\tdout(\"%s truncate_size %lld -> %llu, encrypted %d\\n\", __func__,\n\t\t     ci->i_truncate_size, truncate_size, !!IS_ENCRYPTED(inode));\n\n\t\tci->i_truncate_size = truncate_size;\n\n\t\tif (IS_ENCRYPTED(inode)) {\n\t\t\tdout(\"%s truncate_pagecache_size %lld -> %llu\\n\",\n\t\t\t     __func__, ci->i_truncate_pagecache_size, size);\n\t\t\tci->i_truncate_pagecache_size = size;\n\t\t} else {\n\t\t\tci->i_truncate_pagecache_size = truncate_size;\n\t\t}\n\t}\n\treturn queue_trunc;\n}\n\nvoid ceph_fill_file_time(struct inode *inode, int issued,\n\t\t\t u64 time_warp_seq, struct timespec64 *ctime,\n\t\t\t struct timespec64 *mtime, struct timespec64 *atime)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct timespec64 ictime = inode_get_ctime(inode);\n\tint warn = 0;\n\n\tif (issued & (CEPH_CAP_FILE_EXCL|\n\t\t      CEPH_CAP_FILE_WR|\n\t\t      CEPH_CAP_FILE_BUFFER|\n\t\t      CEPH_CAP_AUTH_EXCL|\n\t\t      CEPH_CAP_XATTR_EXCL)) {\n\t\tif (ci->i_version == 0 ||\n\t\t    timespec64_compare(ctime, &ictime) > 0) {\n\t\t\tdout(\"ctime %lld.%09ld -> %lld.%09ld inc w/ cap\\n\",\n\t\t\t     ictime.tv_sec, ictime.tv_nsec,\n\t\t\t     ctime->tv_sec, ctime->tv_nsec);\n\t\t\tinode_set_ctime_to_ts(inode, *ctime);\n\t\t}\n\t\tif (ci->i_version == 0 ||\n\t\t    ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) > 0) {\n\t\t\t \n\t\t\tdout(\"mtime %lld.%09ld -> %lld.%09ld \"\n\t\t\t     \"tw %d -> %d\\n\",\n\t\t\t     inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,\n\t\t\t     mtime->tv_sec, mtime->tv_nsec,\n\t\t\t     ci->i_time_warp_seq, (int)time_warp_seq);\n\n\t\t\tinode->i_mtime = *mtime;\n\t\t\tinode->i_atime = *atime;\n\t\t\tci->i_time_warp_seq = time_warp_seq;\n\t\t} else if (time_warp_seq == ci->i_time_warp_seq) {\n\t\t\t \n\t\t\tif (timespec64_compare(mtime, &inode->i_mtime) > 0) {\n\t\t\t\tdout(\"mtime %lld.%09ld -> %lld.%09ld inc\\n\",\n\t\t\t\t     inode->i_mtime.tv_sec,\n\t\t\t\t     inode->i_mtime.tv_nsec,\n\t\t\t\t     mtime->tv_sec, mtime->tv_nsec);\n\t\t\t\tinode->i_mtime = *mtime;\n\t\t\t}\n\t\t\tif (timespec64_compare(atime, &inode->i_atime) > 0) {\n\t\t\t\tdout(\"atime %lld.%09ld -> %lld.%09ld inc\\n\",\n\t\t\t\t     inode->i_atime.tv_sec,\n\t\t\t\t     inode->i_atime.tv_nsec,\n\t\t\t\t     atime->tv_sec, atime->tv_nsec);\n\t\t\t\tinode->i_atime = *atime;\n\t\t\t}\n\t\t} else if (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\t \n\t\t} else {\n\t\t\twarn = 1;\n\t\t}\n\t} else {\n\t\t \n\t\tif (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) >= 0) {\n\t\t\tinode_set_ctime_to_ts(inode, *ctime);\n\t\t\tinode->i_mtime = *mtime;\n\t\t\tinode->i_atime = *atime;\n\t\t\tci->i_time_warp_seq = time_warp_seq;\n\t\t} else {\n\t\t\twarn = 1;\n\t\t}\n\t}\n\tif (warn)  \n\t\tdout(\"%p mds time_warp_seq %llu < %u\\n\",\n\t\t     inode, time_warp_seq, ci->i_time_warp_seq);\n}\n\n#if IS_ENABLED(CONFIG_FS_ENCRYPTION)\nstatic int decode_encrypted_symlink(const char *encsym, int enclen, u8 **decsym)\n{\n\tint declen;\n\tu8 *sym;\n\n\tsym = kmalloc(enclen + 1, GFP_NOFS);\n\tif (!sym)\n\t\treturn -ENOMEM;\n\n\tdeclen = ceph_base64_decode(encsym, enclen, sym);\n\tif (declen < 0) {\n\t\tpr_err(\"%s: can't decode symlink (%d). Content: %.*s\\n\",\n\t\t       __func__, declen, enclen, encsym);\n\t\tkfree(sym);\n\t\treturn -EIO;\n\t}\n\tsym[declen + 1] = '\\0';\n\t*decsym = sym;\n\treturn declen;\n}\n#else\nstatic int decode_encrypted_symlink(const char *encsym, int symlen, u8 **decsym)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\n \nint ceph_fill_inode(struct inode *inode, struct page *locked_page,\n\t\t    struct ceph_mds_reply_info_in *iinfo,\n\t\t    struct ceph_mds_reply_dirfrag *dirinfo,\n\t\t    struct ceph_mds_session *session, int cap_fmode,\n\t\t    struct ceph_cap_reservation *caps_reservation)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(inode->i_sb);\n\tstruct ceph_mds_reply_inode *info = iinfo->in;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued, new_issued, info_caps;\n\tstruct timespec64 mtime, atime, ctime;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tstruct ceph_buffer *old_blob = NULL;\n\tstruct ceph_string *pool_ns = NULL;\n\tstruct ceph_cap *new_cap = NULL;\n\tint err = 0;\n\tbool wake = false;\n\tbool queue_trunc = false;\n\tbool new_version = false;\n\tbool fill_inline = false;\n\tumode_t mode = le32_to_cpu(info->mode);\n\tdev_t rdev = le32_to_cpu(info->rdev);\n\n\tlockdep_assert_held(&mdsc->snap_rwsem);\n\n\tdout(\"%s %p ino %llx.%llx v %llu had %llu\\n\", __func__,\n\t     inode, ceph_vinop(inode), le64_to_cpu(info->version),\n\t     ci->i_version);\n\n\t \n\tif (inode->i_state & I_NEW) {\n\t\tinode->i_mode = mode;\n\t} else {\n\t\tif (inode_wrong_type(inode, mode)) {\n\t\t\tpr_warn_once(\"inode type changed! (ino %llx.%llx is 0%o, mds says 0%o)\\n\",\n\t\t\t\t     ceph_vinop(inode), inode->i_mode, mode);\n\t\t\treturn -ESTALE;\n\t\t}\n\n\t\tif ((S_ISCHR(mode) || S_ISBLK(mode)) && inode->i_rdev != rdev) {\n\t\t\tpr_warn_once(\"dev inode rdev changed! (ino %llx.%llx is %u:%u, mds says %u:%u)\\n\",\n\t\t\t\t     ceph_vinop(inode), MAJOR(inode->i_rdev),\n\t\t\t\t     MINOR(inode->i_rdev), MAJOR(rdev),\n\t\t\t\t     MINOR(rdev));\n\t\t\treturn -ESTALE;\n\t\t}\n\t}\n\n\tinfo_caps = le32_to_cpu(info->cap.caps);\n\n\t \n\tif (info_caps && ceph_snap(inode) == CEPH_NOSNAP) {\n\t\tnew_cap = ceph_get_cap(mdsc, caps_reservation);\n\t\tif (!new_cap)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (iinfo->xattr_len > 4) {\n\t\txattr_blob = ceph_buffer_new(iinfo->xattr_len, GFP_NOFS);\n\t\tif (!xattr_blob)\n\t\t\tpr_err(\"%s ENOMEM xattr blob %d bytes\\n\", __func__,\n\t\t\t       iinfo->xattr_len);\n\t}\n\n\tif (iinfo->pool_ns_len > 0)\n\t\tpool_ns = ceph_find_or_create_string(iinfo->pool_ns_data,\n\t\t\t\t\t\t     iinfo->pool_ns_len);\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP && !ci->i_snapid_map)\n\t\tci->i_snapid_map = ceph_get_snapid_map(mdsc, ceph_snap(inode));\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\t \n\tif (ci->i_version == 0 ||\n\t    ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&\n\t     le64_to_cpu(info->version) > (ci->i_version & ~1)))\n\t\tnew_version = true;\n\n\t \n\tinode_set_max_iversion_raw(inode, iinfo->change_attr);\n\n\t__ceph_caps_issued(ci, &issued);\n\tissued |= __ceph_caps_dirty(ci);\n\tnew_issued = ~issued & info_caps;\n\n\t__ceph_update_quota(ci, iinfo->max_bytes, iinfo->max_files);\n\n#ifdef CONFIG_FS_ENCRYPTION\n\tif (iinfo->fscrypt_auth_len &&\n\t    ((inode->i_state & I_NEW) || (ci->fscrypt_auth_len == 0))) {\n\t\tkfree(ci->fscrypt_auth);\n\t\tci->fscrypt_auth_len = iinfo->fscrypt_auth_len;\n\t\tci->fscrypt_auth = iinfo->fscrypt_auth;\n\t\tiinfo->fscrypt_auth = NULL;\n\t\tiinfo->fscrypt_auth_len = 0;\n\t\tinode_set_flags(inode, S_ENCRYPTED, S_ENCRYPTED);\n\t}\n#endif\n\n\tif ((new_version || (new_issued & CEPH_CAP_AUTH_SHARED)) &&\n\t    (issued & CEPH_CAP_AUTH_EXCL) == 0) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = make_kuid(&init_user_ns, le32_to_cpu(info->uid));\n\t\tinode->i_gid = make_kgid(&init_user_ns, le32_to_cpu(info->gid));\n\t\tdout(\"%p mode 0%o uid.gid %d.%d\\n\", inode, inode->i_mode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kgid(&init_user_ns, inode->i_gid));\n\t\tceph_decode_timespec64(&ci->i_btime, &iinfo->btime);\n\t\tceph_decode_timespec64(&ci->i_snap_btime, &iinfo->snap_btime);\n\t}\n\n\t \n\tif (IS_ENCRYPTED(inode))\n\t\tinode->i_blkbits = CEPH_FSCRYPT_BLOCK_SHIFT;\n\telse if (le32_to_cpu(info->layout.fl_stripe_unit))\n\t\tinode->i_blkbits =\n\t\t\tfls(le32_to_cpu(info->layout.fl_stripe_unit)) - 1;\n\telse\n\t\tinode->i_blkbits = CEPH_BLOCK_SHIFT;\n\n\tif ((new_version || (new_issued & CEPH_CAP_LINK_SHARED)) &&\n\t    (issued & CEPH_CAP_LINK_EXCL) == 0)\n\t\tset_nlink(inode, le32_to_cpu(info->nlink));\n\n\tif (new_version || (new_issued & CEPH_CAP_ANY_RD)) {\n\t\t \n\t\tceph_decode_timespec64(&atime, &info->atime);\n\t\tceph_decode_timespec64(&mtime, &info->mtime);\n\t\tceph_decode_timespec64(&ctime, &info->ctime);\n\t\tceph_fill_file_time(inode, issued,\n\t\t\t\tle32_to_cpu(info->time_warp_seq),\n\t\t\t\t&ctime, &mtime, &atime);\n\t}\n\n\tif (new_version || (info_caps & CEPH_CAP_FILE_SHARED)) {\n\t\tci->i_files = le64_to_cpu(info->files);\n\t\tci->i_subdirs = le64_to_cpu(info->subdirs);\n\t}\n\n\tif (new_version ||\n\t    (new_issued & (CEPH_CAP_ANY_FILE_RD | CEPH_CAP_ANY_FILE_WR))) {\n\t\tu64 size = le64_to_cpu(info->size);\n\t\ts64 old_pool = ci->i_layout.pool_id;\n\t\tstruct ceph_string *old_ns;\n\n\t\tceph_file_layout_from_legacy(&ci->i_layout, &info->layout);\n\t\told_ns = rcu_dereference_protected(ci->i_layout.pool_ns,\n\t\t\t\t\tlockdep_is_held(&ci->i_ceph_lock));\n\t\trcu_assign_pointer(ci->i_layout.pool_ns, pool_ns);\n\n\t\tif (ci->i_layout.pool_id != old_pool || pool_ns != old_ns)\n\t\t\tci->i_ceph_flags &= ~CEPH_I_POOL_PERM;\n\n\t\tpool_ns = old_ns;\n\n\t\tif (IS_ENCRYPTED(inode) && size &&\n\t\t    iinfo->fscrypt_file_len == sizeof(__le64)) {\n\t\t\tu64 fsize = __le64_to_cpu(*(__le64 *)iinfo->fscrypt_file);\n\n\t\t\tif (size == round_up(fsize, CEPH_FSCRYPT_BLOCK_SIZE)) {\n\t\t\t\tsize = fsize;\n\t\t\t} else {\n\t\t\t\tpr_warn(\"fscrypt size mismatch: size=%llu fscrypt_file=%llu, discarding fscrypt_file size.\\n\",\n\t\t\t\t\tinfo->size, size);\n\t\t\t}\n\t\t}\n\n\t\tqueue_trunc = ceph_fill_file_size(inode, issued,\n\t\t\t\t\tle32_to_cpu(info->truncate_seq),\n\t\t\t\t\tle64_to_cpu(info->truncate_size),\n\t\t\t\t\tsize);\n\t\t \n\t\tif ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&\n\t\t    ci->i_max_size != le64_to_cpu(info->max_size)) {\n\t\t\tdout(\"max_size %lld -> %llu\\n\", ci->i_max_size,\n\t\t\t\t\tle64_to_cpu(info->max_size));\n\t\t\tci->i_max_size = le64_to_cpu(info->max_size);\n\t\t}\n\t}\n\n\t \n\tif (new_version || (info->cap.flags & CEPH_CAP_FLAG_AUTH)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tci->i_dir_layout = iinfo->dir_layout;\n\t\t\tci->i_rbytes = le64_to_cpu(info->rbytes);\n\t\t\tci->i_rfiles = le64_to_cpu(info->rfiles);\n\t\t\tci->i_rsubdirs = le64_to_cpu(info->rsubdirs);\n\t\t\tci->i_dir_pin = iinfo->dir_pin;\n\t\t\tci->i_rsnaps = iinfo->rsnaps;\n\t\t\tceph_decode_timespec64(&ci->i_rctime, &info->rctime);\n\t\t}\n\t}\n\n\t \n\t \n\tif ((ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))  &&\n\t    le64_to_cpu(info->xattr_version) > ci->i_xattrs.version) {\n\t\tif (ci->i_xattrs.blob)\n\t\t\told_blob = ci->i_xattrs.blob;\n\t\tci->i_xattrs.blob = xattr_blob;\n\t\tif (xattr_blob)\n\t\t\tmemcpy(ci->i_xattrs.blob->vec.iov_base,\n\t\t\t       iinfo->xattr_data, iinfo->xattr_len);\n\t\tci->i_xattrs.version = le64_to_cpu(info->xattr_version);\n\t\tceph_forget_all_cached_acls(inode);\n\t\tceph_security_invalidate_secctx(inode);\n\t\txattr_blob = NULL;\n\t}\n\n\t \n\tif (le64_to_cpu(info->version) > ci->i_version)\n\t\tci->i_version = le64_to_cpu(info->version);\n\n\tinode->i_mapping->a_ops = &ceph_aops;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFSOCK:\n\t\tinode->i_blkbits = PAGE_SHIFT;\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n\t\tinode->i_op = &ceph_file_iops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &ceph_file_iops;\n\t\tinode->i_fop = &ceph_file_fops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (!ci->i_symlink) {\n\t\t\tu32 symlen = iinfo->symlink_len;\n\t\t\tchar *sym;\n\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t\tif (IS_ENCRYPTED(inode)) {\n\t\t\t\tif (symlen != i_size_read(inode))\n\t\t\t\t\tpr_err(\"%s %llx.%llx BAD symlink size %lld\\n\",\n\t\t\t\t\t\t__func__, ceph_vinop(inode),\n\t\t\t\t\t\ti_size_read(inode));\n\n\t\t\t\terr = decode_encrypted_symlink(iinfo->symlink,\n\t\t\t\t\t\t\t       symlen, (u8 **)&sym);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\tpr_err(\"%s decoding encrypted symlink failed: %d\\n\",\n\t\t\t\t\t\t__func__, err);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsymlen = err;\n\t\t\t\ti_size_write(inode, symlen);\n\t\t\t\tinode->i_blocks = calc_inode_blocks(symlen);\n\t\t\t} else {\n\t\t\t\tif (symlen != i_size_read(inode)) {\n\t\t\t\t\tpr_err(\"%s %llx.%llx BAD symlink size %lld\\n\",\n\t\t\t\t\t\t__func__, ceph_vinop(inode),\n\t\t\t\t\t\ti_size_read(inode));\n\t\t\t\t\ti_size_write(inode, symlen);\n\t\t\t\t\tinode->i_blocks = calc_inode_blocks(symlen);\n\t\t\t\t}\n\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tsym = kstrndup(iinfo->symlink, symlen, GFP_NOFS);\n\t\t\t\tif (!sym)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tif (!ci->i_symlink)\n\t\t\t\tci->i_symlink = sym;\n\t\t\telse\n\t\t\t\tkfree(sym);  \n\t\t}\n\n\t\tif (IS_ENCRYPTED(inode)) {\n\t\t\t \n\t\t\tinode->i_op = &ceph_encrypted_symlink_iops;\n\t\t} else {\n\t\t\tinode->i_link = ci->i_symlink;\n\t\t\tinode->i_op = &ceph_symlink_iops;\n\t\t}\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &ceph_dir_iops;\n\t\tinode->i_fop = &ceph_dir_fops;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s %llx.%llx BAD mode 0%o\\n\", __func__,\n\t\t       ceph_vinop(inode), inode->i_mode);\n\t}\n\n\t \n\tif (info_caps) {\n\t\tif (ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t\tceph_add_cap(inode, session,\n\t\t\t\t     le64_to_cpu(info->cap.cap_id),\n\t\t\t\t     info_caps,\n\t\t\t\t     le32_to_cpu(info->cap.wanted),\n\t\t\t\t     le32_to_cpu(info->cap.seq),\n\t\t\t\t     le32_to_cpu(info->cap.mseq),\n\t\t\t\t     le64_to_cpu(info->cap.realm),\n\t\t\t\t     info->cap.flags, &new_cap);\n\n\t\t\t \n\t\t\tif (S_ISDIR(inode->i_mode) &&\n\t\t\t    ci->i_files == 0 && ci->i_subdirs == 0 &&\n\t\t\t    (info_caps & CEPH_CAP_FILE_SHARED) &&\n\t\t\t    (issued & CEPH_CAP_FILE_EXCL) == 0 &&\n\t\t\t    !__ceph_dir_is_complete(ci)) {\n\t\t\t\tdout(\" marking %p complete (empty)\\n\", inode);\n\t\t\t\ti_size_write(inode, 0);\n\t\t\t\t__ceph_dir_set_complete(ci,\n\t\t\t\t\tatomic64_read(&ci->i_release_count),\n\t\t\t\t\tatomic64_read(&ci->i_ordered_count));\n\t\t\t}\n\n\t\t\twake = true;\n\t\t} else {\n\t\t\tdout(\" %p got snap_caps %s\\n\", inode,\n\t\t\t     ceph_cap_string(info_caps));\n\t\t\tci->i_snap_caps |= info_caps;\n\t\t}\n\t}\n\n\tif (iinfo->inline_version > 0 &&\n\t    iinfo->inline_version >= ci->i_inline_version) {\n\t\tint cache_caps = CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO;\n\t\tci->i_inline_version = iinfo->inline_version;\n\t\tif (ceph_has_inline_data(ci) &&\n\t\t    (locked_page || (info_caps & cache_caps)))\n\t\t\tfill_inline = true;\n\t}\n\n\tif (cap_fmode >= 0) {\n\t\tif (!info_caps)\n\t\t\tpr_warn(\"mds issued no caps on %llx.%llx\\n\",\n\t\t\t\tceph_vinop(inode));\n\t\t__ceph_touch_fmode(ci, mdsc, cap_fmode);\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tceph_fscache_register_inode_cookie(inode);\n\n\tif (fill_inline)\n\t\tceph_fill_inline_data(inode, locked_page,\n\t\t\t\t      iinfo->inline_data, iinfo->inline_len);\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\t \n\tif (queue_trunc)\n\t\tceph_queue_vmtruncate(inode);\n\n\t \n\tif (S_ISDIR(inode->i_mode))\n\t\tceph_fill_fragtree(inode, &info->fragtree, dirinfo);\n\n\t \n\tif (dirinfo)\n\t\tceph_fill_dirfrag(inode, dirinfo);\n\n\terr = 0;\nout:\n\tif (new_cap)\n\t\tceph_put_cap(mdsc, new_cap);\n\tceph_buffer_put(old_blob);\n\tceph_buffer_put(xattr_blob);\n\tceph_put_string(pool_ns);\n\treturn err;\n}\n\n \nstatic void __update_dentry_lease(struct inode *dir, struct dentry *dentry,\n\t\t\t\t  struct ceph_mds_reply_lease *lease,\n\t\t\t\t  struct ceph_mds_session *session,\n\t\t\t\t  unsigned long from_time,\n\t\t\t\t  struct ceph_mds_session **old_lease_session)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tunsigned mask = le16_to_cpu(lease->mask);\n\tlong unsigned duration = le32_to_cpu(lease->duration_ms);\n\tlong unsigned ttl = from_time + (duration * HZ) / 1000;\n\tlong unsigned half_ttl = from_time + (duration * HZ / 2) / 1000;\n\n\tdout(\"update_dentry_lease %p duration %lu ms ttl %lu\\n\",\n\t     dentry, duration, ttl);\n\n\t \n\tif (ceph_snap(dir) != CEPH_NOSNAP)\n\t\treturn;\n\n\tif (mask & CEPH_LEASE_PRIMARY_LINK)\n\t\tdi->flags |= CEPH_DENTRY_PRIMARY_LINK;\n\telse\n\t\tdi->flags &= ~CEPH_DENTRY_PRIMARY_LINK;\n\n\tdi->lease_shared_gen = atomic_read(&ceph_inode(dir)->i_shared_gen);\n\tif (!(mask & CEPH_LEASE_VALID)) {\n\t\t__ceph_dentry_dir_lease_touch(di);\n\t\treturn;\n\t}\n\n\tif (di->lease_gen == atomic_read(&session->s_cap_gen) &&\n\t    time_before(ttl, di->time))\n\t\treturn;   \n\n\tif (di->lease_session && di->lease_session != session) {\n\t\t*old_lease_session = di->lease_session;\n\t\tdi->lease_session = NULL;\n\t}\n\n\tif (!di->lease_session)\n\t\tdi->lease_session = ceph_get_mds_session(session);\n\tdi->lease_gen = atomic_read(&session->s_cap_gen);\n\tdi->lease_seq = le32_to_cpu(lease->seq);\n\tdi->lease_renew_after = half_ttl;\n\tdi->lease_renew_from = 0;\n\tdi->time = ttl;\n\n\t__ceph_dentry_lease_touch(di);\n}\n\nstatic inline void update_dentry_lease(struct inode *dir, struct dentry *dentry,\n\t\t\t\t\tstruct ceph_mds_reply_lease *lease,\n\t\t\t\t\tstruct ceph_mds_session *session,\n\t\t\t\t\tunsigned long from_time)\n{\n\tstruct ceph_mds_session *old_lease_session = NULL;\n\tspin_lock(&dentry->d_lock);\n\t__update_dentry_lease(dir, dentry, lease, session, from_time,\n\t\t\t      &old_lease_session);\n\tspin_unlock(&dentry->d_lock);\n\tceph_put_mds_session(old_lease_session);\n}\n\n \nstatic void update_dentry_lease_careful(struct dentry *dentry,\n\t\t\t\t\tstruct ceph_mds_reply_lease *lease,\n\t\t\t\t\tstruct ceph_mds_session *session,\n\t\t\t\t\tunsigned long from_time,\n\t\t\t\t\tchar *dname, u32 dname_len,\n\t\t\t\t\tstruct ceph_vino *pdvino,\n\t\t\t\t\tstruct ceph_vino *ptvino)\n\n{\n\tstruct inode *dir;\n\tstruct ceph_mds_session *old_lease_session = NULL;\n\n\tspin_lock(&dentry->d_lock);\n\t \n\tif (dentry->d_name.len != dname_len ||\n\t    memcmp(dentry->d_name.name, dname, dname_len))\n\t\tgoto out_unlock;\n\n\tdir = d_inode(dentry->d_parent);\n\t \n\tif (!ceph_ino_compare(dir, pdvino))\n\t\tgoto out_unlock;\n\n\t \n\tif (ptvino) {\n\t\tif (d_really_is_negative(dentry))\n\t\t\tgoto out_unlock;\n\t\tif (!ceph_ino_compare(d_inode(dentry), ptvino))\n\t\t\tgoto out_unlock;\n\t} else {\n\t\tif (d_really_is_positive(dentry))\n\t\t\tgoto out_unlock;\n\t}\n\n\t__update_dentry_lease(dir, dentry, lease, session,\n\t\t\t      from_time, &old_lease_session);\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\tceph_put_mds_session(old_lease_session);\n}\n\n \nstatic int splice_dentry(struct dentry **pdn, struct inode *in)\n{\n\tstruct dentry *dn = *pdn;\n\tstruct dentry *realdn;\n\n\tBUG_ON(d_inode(dn));\n\n\tif (S_ISDIR(in->i_mode)) {\n\t\t \n\t\trealdn = d_find_any_alias(in);\n\t\tif (realdn) {\n\t\t\tstruct ceph_dentry_info *di = ceph_dentry(realdn);\n\t\t\tspin_lock(&realdn->d_lock);\n\n\t\t\trealdn->d_op->d_prune(realdn);\n\n\t\t\tdi->time = jiffies;\n\t\t\tdi->lease_shared_gen = 0;\n\t\t\tdi->offset = 0;\n\n\t\t\tspin_unlock(&realdn->d_lock);\n\t\t\tdput(realdn);\n\t\t}\n\t}\n\n\t \n\tif (!d_unhashed(dn))\n\t\td_drop(dn);\n\trealdn = d_splice_alias(in, dn);\n\tif (IS_ERR(realdn)) {\n\t\tpr_err(\"splice_dentry error %ld %p inode %p ino %llx.%llx\\n\",\n\t\t       PTR_ERR(realdn), dn, in, ceph_vinop(in));\n\t\treturn PTR_ERR(realdn);\n\t}\n\n\tif (realdn) {\n\t\tdout(\"dn %p (%d) spliced with %p (%d) \"\n\t\t     \"inode %p ino %llx.%llx\\n\",\n\t\t     dn, d_count(dn),\n\t\t     realdn, d_count(realdn),\n\t\t     d_inode(realdn), ceph_vinop(d_inode(realdn)));\n\t\tdput(dn);\n\t\t*pdn = realdn;\n\t} else {\n\t\tBUG_ON(!ceph_dentry(dn));\n\t\tdout(\"dn %p attached to %p ino %llx.%llx\\n\",\n\t\t     dn, d_inode(dn), ceph_vinop(d_inode(dn)));\n\t}\n\treturn 0;\n}\n\n \nint ceph_fill_trace(struct super_block *sb, struct ceph_mds_request *req)\n{\n\tstruct ceph_mds_session *session = req->r_session;\n\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\tstruct inode *in = NULL;\n\tstruct ceph_vino tvino, dvino;\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\tint err = 0;\n\n\tdout(\"fill_trace %p is_dentry %d is_target %d\\n\", req,\n\t     rinfo->head->is_dentry, rinfo->head->is_target);\n\n\tif (!rinfo->head->is_target && !rinfo->head->is_dentry) {\n\t\tdout(\"fill_trace reply is empty!\\n\");\n\t\tif (rinfo->head->result == 0 && req->r_parent)\n\t\t\tceph_invalidate_dir_request(req);\n\t\treturn 0;\n\t}\n\n\tif (rinfo->head->is_dentry) {\n\t\tstruct inode *dir = req->r_parent;\n\n\t\tif (dir) {\n\t\t\terr = ceph_fill_inode(dir, NULL, &rinfo->diri,\n\t\t\t\t\t      rinfo->dirfrag, session, -1,\n\t\t\t\t\t      &req->r_caps_reservation);\n\t\t\tif (err < 0)\n\t\t\t\tgoto done;\n\t\t} else {\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\n\t\tif (dir && req->r_op == CEPH_MDS_OP_LOOKUPNAME &&\n\t\t    test_bit(CEPH_MDS_R_PARENT_LOCKED, &req->r_req_flags) &&\n\t\t    !test_bit(CEPH_MDS_R_ABORTED, &req->r_req_flags)) {\n\t\t\tbool is_nokey = false;\n\t\t\tstruct qstr dname;\n\t\t\tstruct dentry *dn, *parent;\n\t\t\tstruct fscrypt_str oname = FSTR_INIT(NULL, 0);\n\t\t\tstruct ceph_fname fname = { .dir\t= dir,\n\t\t\t\t\t\t    .name\t= rinfo->dname,\n\t\t\t\t\t\t    .ctext\t= rinfo->altname,\n\t\t\t\t\t\t    .name_len\t= rinfo->dname_len,\n\t\t\t\t\t\t    .ctext_len\t= rinfo->altname_len };\n\n\t\t\tBUG_ON(!rinfo->head->is_target);\n\t\t\tBUG_ON(req->r_dentry);\n\n\t\t\tparent = d_find_any_alias(dir);\n\t\t\tBUG_ON(!parent);\n\n\t\t\terr = ceph_fname_alloc_buffer(dir, &oname);\n\t\t\tif (err < 0) {\n\t\t\t\tdput(parent);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = ceph_fname_to_usr(&fname, NULL, &oname, &is_nokey);\n\t\t\tif (err < 0) {\n\t\t\t\tdput(parent);\n\t\t\t\tceph_fname_free_buffer(dir, &oname);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tdname.name = oname.name;\n\t\t\tdname.len = oname.len;\n\t\t\tdname.hash = full_name_hash(parent, dname.name, dname.len);\n\t\t\ttvino.ino = le64_to_cpu(rinfo->targeti.in->ino);\n\t\t\ttvino.snap = le64_to_cpu(rinfo->targeti.in->snapid);\nretry_lookup:\n\t\t\tdn = d_lookup(parent, &dname);\n\t\t\tdout(\"d_lookup on parent=%p name=%.*s got %p\\n\",\n\t\t\t     parent, dname.len, dname.name, dn);\n\n\t\t\tif (!dn) {\n\t\t\t\tdn = d_alloc(parent, &dname);\n\t\t\t\tdout(\"d_alloc %p '%.*s' = %p\\n\", parent,\n\t\t\t\t     dname.len, dname.name, dn);\n\t\t\t\tif (!dn) {\n\t\t\t\t\tdput(parent);\n\t\t\t\t\tceph_fname_free_buffer(dir, &oname);\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (is_nokey) {\n\t\t\t\t\tspin_lock(&dn->d_lock);\n\t\t\t\t\tdn->d_flags |= DCACHE_NOKEY_NAME;\n\t\t\t\t\tspin_unlock(&dn->d_lock);\n\t\t\t\t}\n\t\t\t\terr = 0;\n\t\t\t} else if (d_really_is_positive(dn) &&\n\t\t\t\t   (ceph_ino(d_inode(dn)) != tvino.ino ||\n\t\t\t\t    ceph_snap(d_inode(dn)) != tvino.snap)) {\n\t\t\t\tdout(\" dn %p points to wrong inode %p\\n\",\n\t\t\t\t     dn, d_inode(dn));\n\t\t\t\tceph_dir_clear_ordered(dir);\n\t\t\t\td_delete(dn);\n\t\t\t\tdput(dn);\n\t\t\t\tgoto retry_lookup;\n\t\t\t}\n\t\t\tceph_fname_free_buffer(dir, &oname);\n\n\t\t\treq->r_dentry = dn;\n\t\t\tdput(parent);\n\t\t}\n\t}\n\n\tif (rinfo->head->is_target) {\n\t\t \n\t\tBUG_ON(!req->r_target_inode);\n\n\t\tin = req->r_target_inode;\n\t\terr = ceph_fill_inode(in, req->r_locked_page, &rinfo->targeti,\n\t\t\t\tNULL, session,\n\t\t\t\t(!test_bit(CEPH_MDS_R_ABORTED, &req->r_req_flags) &&\n\t\t\t\t !test_bit(CEPH_MDS_R_ASYNC, &req->r_req_flags) &&\n\t\t\t\t rinfo->head->result == 0) ?  req->r_fmode : -1,\n\t\t\t\t&req->r_caps_reservation);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"ceph_fill_inode badness %p %llx.%llx\\n\",\n\t\t\t\tin, ceph_vinop(in));\n\t\t\treq->r_target_inode = NULL;\n\t\t\tif (in->i_state & I_NEW)\n\t\t\t\tdiscard_new_inode(in);\n\t\t\telse\n\t\t\t\tiput(in);\n\t\t\tgoto done;\n\t\t}\n\t\tif (in->i_state & I_NEW)\n\t\t\tunlock_new_inode(in);\n\t}\n\n\t \n\tif (rinfo->head->is_dentry &&\n            !test_bit(CEPH_MDS_R_ABORTED, &req->r_req_flags) &&\n\t    test_bit(CEPH_MDS_R_PARENT_LOCKED, &req->r_req_flags) &&\n\t    (rinfo->head->is_target || strncmp(req->r_dentry->d_name.name,\n\t\t\t\t\t       fsc->mount_options->snapdir_name,\n\t\t\t\t\t       req->r_dentry->d_name.len))) {\n\t\t \n\t\tstruct inode *dir = req->r_parent;\n\t\tstruct dentry *dn = req->r_dentry;\n\t\tbool have_dir_cap, have_lease;\n\n\t\tBUG_ON(!dn);\n\t\tBUG_ON(!dir);\n\t\tBUG_ON(d_inode(dn->d_parent) != dir);\n\n\t\tdvino.ino = le64_to_cpu(rinfo->diri.in->ino);\n\t\tdvino.snap = le64_to_cpu(rinfo->diri.in->snapid);\n\n\t\tBUG_ON(ceph_ino(dir) != dvino.ino);\n\t\tBUG_ON(ceph_snap(dir) != dvino.snap);\n\n\t\t \n\t\thave_dir_cap =\n\t\t\t(le32_to_cpu(rinfo->diri.in->cap.caps) &\n\t\t\t CEPH_CAP_FILE_SHARED);\n\n\t\t \n\t\thave_lease = have_dir_cap ||\n\t\t\tle32_to_cpu(rinfo->dlease->duration_ms);\n\t\tif (!have_lease)\n\t\t\tdout(\"fill_trace  no dentry lease or dir cap\\n\");\n\n\t\t \n\t\tif (req->r_old_dentry && req->r_op == CEPH_MDS_OP_RENAME) {\n\t\t\tstruct inode *olddir = req->r_old_dentry_dir;\n\t\t\tBUG_ON(!olddir);\n\n\t\t\tdout(\" src %p '%pd' dst %p '%pd'\\n\",\n\t\t\t     req->r_old_dentry,\n\t\t\t     req->r_old_dentry,\n\t\t\t     dn, dn);\n\t\t\tdout(\"fill_trace doing d_move %p -> %p\\n\",\n\t\t\t     req->r_old_dentry, dn);\n\n\t\t\t \n\t\t\tceph_dir_clear_ordered(dir);\n\t\t\tceph_dir_clear_ordered(olddir);\n\n\t\t\td_move(req->r_old_dentry, dn);\n\t\t\tdout(\" src %p '%pd' dst %p '%pd'\\n\",\n\t\t\t     req->r_old_dentry,\n\t\t\t     req->r_old_dentry,\n\t\t\t     dn, dn);\n\n\t\t\t \n\t\t\tceph_invalidate_dentry_lease(dn);\n\n\t\t\tdout(\"dn %p gets new offset %lld\\n\", req->r_old_dentry,\n\t\t\t     ceph_dentry(req->r_old_dentry)->offset);\n\n\t\t\t \n\t\t\treq->r_dentry = req->r_old_dentry;\n\t\t\treq->r_old_dentry = dn;\n\t\t\tdn = req->r_dentry;\n\t\t}\n\n\t\t \n\t\tif (!rinfo->head->is_target) {\n\t\t\tdout(\"fill_trace null dentry\\n\");\n\t\t\tif (d_really_is_positive(dn)) {\n\t\t\t\tdout(\"d_delete %p\\n\", dn);\n\t\t\t\tceph_dir_clear_ordered(dir);\n\t\t\t\td_delete(dn);\n\t\t\t} else if (have_lease) {\n\t\t\t\tif (d_unhashed(dn))\n\t\t\t\t\td_add(dn, NULL);\n\t\t\t}\n\n\t\t\tif (!d_unhashed(dn) && have_lease)\n\t\t\t\tupdate_dentry_lease(dir, dn,\n\t\t\t\t\t\t    rinfo->dlease, session,\n\t\t\t\t\t\t    req->r_request_started);\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (d_really_is_negative(dn)) {\n\t\t\tceph_dir_clear_ordered(dir);\n\t\t\tihold(in);\n\t\t\terr = splice_dentry(&req->r_dentry, in);\n\t\t\tif (err < 0)\n\t\t\t\tgoto done;\n\t\t\tdn = req->r_dentry;   \n\t\t} else if (d_really_is_positive(dn) && d_inode(dn) != in) {\n\t\t\tdout(\" %p links to %p %llx.%llx, not %llx.%llx\\n\",\n\t\t\t     dn, d_inode(dn), ceph_vinop(d_inode(dn)),\n\t\t\t     ceph_vinop(in));\n\t\t\td_invalidate(dn);\n\t\t\thave_lease = false;\n\t\t}\n\n\t\tif (have_lease) {\n\t\t\tupdate_dentry_lease(dir, dn,\n\t\t\t\t\t    rinfo->dlease, session,\n\t\t\t\t\t    req->r_request_started);\n\t\t}\n\t\tdout(\" final dn %p\\n\", dn);\n\t} else if ((req->r_op == CEPH_MDS_OP_LOOKUPSNAP ||\n\t\t    req->r_op == CEPH_MDS_OP_MKSNAP) &&\n\t           test_bit(CEPH_MDS_R_PARENT_LOCKED, &req->r_req_flags) &&\n\t\t   !test_bit(CEPH_MDS_R_ABORTED, &req->r_req_flags)) {\n\t\tstruct inode *dir = req->r_parent;\n\n\t\t \n\t\tBUG_ON(!dir);\n\t\tBUG_ON(ceph_snap(dir) != CEPH_SNAPDIR);\n\t\tBUG_ON(!req->r_dentry);\n\t\tdout(\" linking snapped dir %p to dn %p\\n\", in, req->r_dentry);\n\t\tceph_dir_clear_ordered(dir);\n\t\tihold(in);\n\t\terr = splice_dentry(&req->r_dentry, in);\n\t\tif (err < 0)\n\t\t\tgoto done;\n\t} else if (rinfo->head->is_dentry && req->r_dentry) {\n\t\t \n\t\tstruct ceph_vino *ptvino = NULL;\n\t\tdvino.ino = le64_to_cpu(rinfo->diri.in->ino);\n\t\tdvino.snap = le64_to_cpu(rinfo->diri.in->snapid);\n\t\tif (rinfo->head->is_target) {\n\t\t\ttvino.ino = le64_to_cpu(rinfo->targeti.in->ino);\n\t\t\ttvino.snap = le64_to_cpu(rinfo->targeti.in->snapid);\n\t\t\tptvino = &tvino;\n\t\t}\n\t\tupdate_dentry_lease_careful(req->r_dentry, rinfo->dlease,\n\t\t\t\t\t    session, req->r_request_started,\n\t\t\t\t\t    rinfo->dname, rinfo->dname_len,\n\t\t\t\t\t    &dvino, ptvino);\n\t}\ndone:\n\tdout(\"fill_trace done err=%d\\n\", err);\n\treturn err;\n}\n\n \nstatic int readdir_prepopulate_inodes_only(struct ceph_mds_request *req,\n\t\t\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\tint i, err = 0;\n\n\tfor (i = 0; i < rinfo->dir_nr; i++) {\n\t\tstruct ceph_mds_reply_dir_entry *rde = rinfo->dir_entries + i;\n\t\tstruct ceph_vino vino;\n\t\tstruct inode *in;\n\t\tint rc;\n\n\t\tvino.ino = le64_to_cpu(rde->inode.in->ino);\n\t\tvino.snap = le64_to_cpu(rde->inode.in->snapid);\n\n\t\tin = ceph_get_inode(req->r_dentry->d_sb, vino, NULL);\n\t\tif (IS_ERR(in)) {\n\t\t\terr = PTR_ERR(in);\n\t\t\tdout(\"new_inode badness got %d\\n\", err);\n\t\t\tcontinue;\n\t\t}\n\t\trc = ceph_fill_inode(in, NULL, &rde->inode, NULL, session,\n\t\t\t\t     -1, &req->r_caps_reservation);\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"ceph_fill_inode badness on %p got %d\\n\",\n\t\t\t       in, rc);\n\t\t\terr = rc;\n\t\t\tif (in->i_state & I_NEW) {\n\t\t\t\tihold(in);\n\t\t\t\tdiscard_new_inode(in);\n\t\t\t}\n\t\t} else if (in->i_state & I_NEW) {\n\t\t\tunlock_new_inode(in);\n\t\t}\n\n\t\tiput(in);\n\t}\n\n\treturn err;\n}\n\nvoid ceph_readdir_cache_release(struct ceph_readdir_cache_control *ctl)\n{\n\tif (ctl->page) {\n\t\tkunmap(ctl->page);\n\t\tput_page(ctl->page);\n\t\tctl->page = NULL;\n\t}\n}\n\nstatic int fill_readdir_cache(struct inode *dir, struct dentry *dn,\n\t\t\t      struct ceph_readdir_cache_control *ctl,\n\t\t\t      struct ceph_mds_request *req)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(dir);\n\tunsigned nsize = PAGE_SIZE / sizeof(struct dentry*);\n\tunsigned idx = ctl->index % nsize;\n\tpgoff_t pgoff = ctl->index / nsize;\n\n\tif (!ctl->page || pgoff != page_index(ctl->page)) {\n\t\tceph_readdir_cache_release(ctl);\n\t\tif (idx == 0)\n\t\t\tctl->page = grab_cache_page(&dir->i_data, pgoff);\n\t\telse\n\t\t\tctl->page = find_lock_page(&dir->i_data, pgoff);\n\t\tif (!ctl->page) {\n\t\t\tctl->index = -1;\n\t\t\treturn idx == 0 ? -ENOMEM : 0;\n\t\t}\n\t\t \n\t\tunlock_page(ctl->page);\n\t\tctl->dentries = kmap(ctl->page);\n\t\tif (idx == 0)\n\t\t\tmemset(ctl->dentries, 0, PAGE_SIZE);\n\t}\n\n\tif (req->r_dir_release_cnt == atomic64_read(&ci->i_release_count) &&\n\t    req->r_dir_ordered_cnt == atomic64_read(&ci->i_ordered_count)) {\n\t\tdout(\"readdir cache dn %p idx %d\\n\", dn, ctl->index);\n\t\tctl->dentries[idx] = dn;\n\t\tctl->index++;\n\t} else {\n\t\tdout(\"disable readdir cache\\n\");\n\t\tctl->index = -1;\n\t}\n\treturn 0;\n}\n\nint ceph_readdir_prepopulate(struct ceph_mds_request *req,\n\t\t\t     struct ceph_mds_session *session)\n{\n\tstruct dentry *parent = req->r_dentry;\n\tstruct inode *inode = d_inode(parent);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\tstruct qstr dname;\n\tstruct dentry *dn;\n\tstruct inode *in;\n\tint err = 0, skipped = 0, ret, i;\n\tu32 frag = le32_to_cpu(req->r_args.readdir.frag);\n\tu32 last_hash = 0;\n\tu32 fpos_offset;\n\tstruct ceph_readdir_cache_control cache_ctl = {};\n\n\tif (test_bit(CEPH_MDS_R_ABORTED, &req->r_req_flags))\n\t\treturn readdir_prepopulate_inodes_only(req, session);\n\n\tif (rinfo->hash_order) {\n\t\tif (req->r_path2) {\n\t\t\tlast_hash = ceph_str_hash(ci->i_dir_layout.dl_dir_hash,\n\t\t\t\t\t\t  req->r_path2,\n\t\t\t\t\t\t  strlen(req->r_path2));\n\t\t\tlast_hash = ceph_frag_value(last_hash);\n\t\t} else if (rinfo->offset_hash) {\n\t\t\t \n\t\t\tWARN_ON_ONCE(req->r_readdir_offset != 2);\n\t\t\tlast_hash = le32_to_cpu(req->r_args.readdir.offset_hash);\n\t\t}\n\t}\n\n\tif (rinfo->dir_dir &&\n\t    le32_to_cpu(rinfo->dir_dir->frag) != frag) {\n\t\tdout(\"readdir_prepopulate got new frag %x -> %x\\n\",\n\t\t     frag, le32_to_cpu(rinfo->dir_dir->frag));\n\t\tfrag = le32_to_cpu(rinfo->dir_dir->frag);\n\t\tif (!rinfo->hash_order)\n\t\t\treq->r_readdir_offset = 2;\n\t}\n\n\tif (le32_to_cpu(rinfo->head->op) == CEPH_MDS_OP_LSSNAP) {\n\t\tdout(\"readdir_prepopulate %d items under SNAPDIR dn %p\\n\",\n\t\t     rinfo->dir_nr, parent);\n\t} else {\n\t\tdout(\"readdir_prepopulate %d items under dn %p\\n\",\n\t\t     rinfo->dir_nr, parent);\n\t\tif (rinfo->dir_dir)\n\t\t\tceph_fill_dirfrag(d_inode(parent), rinfo->dir_dir);\n\n\t\tif (ceph_frag_is_leftmost(frag) &&\n\t\t    req->r_readdir_offset == 2 &&\n\t\t    !(rinfo->hash_order && last_hash)) {\n\t\t\t \n\t\t\treq->r_dir_release_cnt =\n\t\t\t\tatomic64_read(&ci->i_release_count);\n\t\t\treq->r_dir_ordered_cnt =\n\t\t\t\tatomic64_read(&ci->i_ordered_count);\n\t\t\treq->r_readdir_cache_idx = 0;\n\t\t}\n\t}\n\n\tcache_ctl.index = req->r_readdir_cache_idx;\n\tfpos_offset = req->r_readdir_offset;\n\n\t \n\tfor (i = 0; i < rinfo->dir_nr; i++) {\n\t\tstruct ceph_mds_reply_dir_entry *rde = rinfo->dir_entries + i;\n\t\tstruct ceph_vino tvino;\n\n\t\tdname.name = rde->name;\n\t\tdname.len = rde->name_len;\n\t\tdname.hash = full_name_hash(parent, dname.name, dname.len);\n\n\t\ttvino.ino = le64_to_cpu(rde->inode.in->ino);\n\t\ttvino.snap = le64_to_cpu(rde->inode.in->snapid);\n\n\t\tif (rinfo->hash_order) {\n\t\t\tu32 hash = ceph_frag_value(rde->raw_hash);\n\t\t\tif (hash != last_hash)\n\t\t\t\tfpos_offset = 2;\n\t\t\tlast_hash = hash;\n\t\t\trde->offset = ceph_make_fpos(hash, fpos_offset++, true);\n\t\t} else {\n\t\t\trde->offset = ceph_make_fpos(frag, fpos_offset++, false);\n\t\t}\n\nretry_lookup:\n\t\tdn = d_lookup(parent, &dname);\n\t\tdout(\"d_lookup on parent=%p name=%.*s got %p\\n\",\n\t\t     parent, dname.len, dname.name, dn);\n\n\t\tif (!dn) {\n\t\t\tdn = d_alloc(parent, &dname);\n\t\t\tdout(\"d_alloc %p '%.*s' = %p\\n\", parent,\n\t\t\t     dname.len, dname.name, dn);\n\t\t\tif (!dn) {\n\t\t\t\tdout(\"d_alloc badness\\n\");\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (rde->is_nokey) {\n\t\t\t\tspin_lock(&dn->d_lock);\n\t\t\t\tdn->d_flags |= DCACHE_NOKEY_NAME;\n\t\t\t\tspin_unlock(&dn->d_lock);\n\t\t\t}\n\t\t} else if (d_really_is_positive(dn) &&\n\t\t\t   (ceph_ino(d_inode(dn)) != tvino.ino ||\n\t\t\t    ceph_snap(d_inode(dn)) != tvino.snap)) {\n\t\t\tstruct ceph_dentry_info *di = ceph_dentry(dn);\n\t\t\tdout(\" dn %p points to wrong inode %p\\n\",\n\t\t\t     dn, d_inode(dn));\n\n\t\t\tspin_lock(&dn->d_lock);\n\t\t\tif (di->offset > 0 &&\n\t\t\t    di->lease_shared_gen ==\n\t\t\t    atomic_read(&ci->i_shared_gen)) {\n\t\t\t\t__ceph_dir_clear_ordered(ci);\n\t\t\t\tdi->offset = 0;\n\t\t\t}\n\t\t\tspin_unlock(&dn->d_lock);\n\n\t\t\td_delete(dn);\n\t\t\tdput(dn);\n\t\t\tgoto retry_lookup;\n\t\t}\n\n\t\t \n\t\tif (d_really_is_positive(dn)) {\n\t\t\tin = d_inode(dn);\n\t\t} else {\n\t\t\tin = ceph_get_inode(parent->d_sb, tvino, NULL);\n\t\t\tif (IS_ERR(in)) {\n\t\t\t\tdout(\"new_inode badness\\n\");\n\t\t\t\td_drop(dn);\n\t\t\t\tdput(dn);\n\t\t\t\terr = PTR_ERR(in);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tret = ceph_fill_inode(in, NULL, &rde->inode, NULL, session,\n\t\t\t\t      -1, &req->r_caps_reservation);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"ceph_fill_inode badness on %p\\n\", in);\n\t\t\tif (d_really_is_negative(dn)) {\n\t\t\t\tif (in->i_state & I_NEW) {\n\t\t\t\t\tihold(in);\n\t\t\t\t\tdiscard_new_inode(in);\n\t\t\t\t}\n\t\t\t\tiput(in);\n\t\t\t}\n\t\t\td_drop(dn);\n\t\t\terr = ret;\n\t\t\tgoto next_item;\n\t\t}\n\t\tif (in->i_state & I_NEW)\n\t\t\tunlock_new_inode(in);\n\n\t\tif (d_really_is_negative(dn)) {\n\t\t\tif (ceph_security_xattr_deadlock(in)) {\n\t\t\t\tdout(\" skip splicing dn %p to inode %p\"\n\t\t\t\t     \" (security xattr deadlock)\\n\", dn, in);\n\t\t\t\tiput(in);\n\t\t\t\tskipped++;\n\t\t\t\tgoto next_item;\n\t\t\t}\n\n\t\t\terr = splice_dentry(&dn, in);\n\t\t\tif (err < 0)\n\t\t\t\tgoto next_item;\n\t\t}\n\n\t\tceph_dentry(dn)->offset = rde->offset;\n\n\t\tupdate_dentry_lease(d_inode(parent), dn,\n\t\t\t\t    rde->lease, req->r_session,\n\t\t\t\t    req->r_request_started);\n\n\t\tif (err == 0 && skipped == 0 && cache_ctl.index >= 0) {\n\t\t\tret = fill_readdir_cache(d_inode(parent), dn,\n\t\t\t\t\t\t &cache_ctl, req);\n\t\t\tif (ret < 0)\n\t\t\t\terr = ret;\n\t\t}\nnext_item:\n\t\tdput(dn);\n\t}\nout:\n\tif (err == 0 && skipped == 0) {\n\t\tset_bit(CEPH_MDS_R_DID_PREPOPULATE, &req->r_req_flags);\n\t\treq->r_readdir_cache_idx = cache_ctl.index;\n\t}\n\tceph_readdir_cache_release(&cache_ctl);\n\tdout(\"readdir_prepopulate done\\n\");\n\treturn err;\n}\n\nbool ceph_inode_set_size(struct inode *inode, loff_t size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tbool ret;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"set_size %p %llu -> %llu\\n\", inode, i_size_read(inode), size);\n\ti_size_write(inode, size);\n\tceph_fscache_update(inode);\n\tinode->i_blocks = calc_inode_blocks(size);\n\n\tret = __ceph_should_report_size(ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\treturn ret;\n}\n\nvoid ceph_queue_inode_work(struct inode *inode, int work_bit)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tset_bit(work_bit, &ci->i_work_mask);\n\n\tihold(inode);\n\tif (queue_work(fsc->inode_wq, &ci->i_work)) {\n\t\tdout(\"queue_inode_work %p, mask=%lx\\n\", inode, ci->i_work_mask);\n\t} else {\n\t\tdout(\"queue_inode_work %p already queued, mask=%lx\\n\",\n\t\t     inode, ci->i_work_mask);\n\t\tiput(inode);\n\t}\n}\n\nstatic void ceph_do_invalidate_pages(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu32 orig_gen;\n\tint check = 0;\n\n\tceph_fscache_invalidate(inode, false);\n\n\tmutex_lock(&ci->i_truncate_mutex);\n\n\tif (ceph_inode_is_shutdown(inode)) {\n\t\tpr_warn_ratelimited(\"%s: inode %llx.%llx is shut down\\n\",\n\t\t\t\t    __func__, ceph_vinop(inode));\n\t\tmapping_set_error(inode->i_mapping, -EIO);\n\t\ttruncate_pagecache(inode, 0);\n\t\tmutex_unlock(&ci->i_truncate_mutex);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"invalidate_pages %p gen %d revoking %d\\n\", inode,\n\t     ci->i_rdcache_gen, ci->i_rdcache_revoking);\n\tif (ci->i_rdcache_revoking != ci->i_rdcache_gen) {\n\t\tif (__ceph_caps_revoking_other(ci, NULL, CEPH_CAP_FILE_CACHE))\n\t\t\tcheck = 1;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tmutex_unlock(&ci->i_truncate_mutex);\n\t\tgoto out;\n\t}\n\torig_gen = ci->i_rdcache_gen;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (invalidate_inode_pages2(inode->i_mapping) < 0) {\n\t\tpr_err(\"invalidate_inode_pages2 %llx.%llx failed\\n\",\n\t\t       ceph_vinop(inode));\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (orig_gen == ci->i_rdcache_gen &&\n\t    orig_gen == ci->i_rdcache_revoking) {\n\t\tdout(\"invalidate_pages %p gen %d successful\\n\", inode,\n\t\t     ci->i_rdcache_gen);\n\t\tci->i_rdcache_revoking--;\n\t\tcheck = 1;\n\t} else {\n\t\tdout(\"invalidate_pages %p gen %d raced, now %d revoking %d\\n\",\n\t\t     inode, orig_gen, ci->i_rdcache_gen,\n\t\t     ci->i_rdcache_revoking);\n\t\tif (__ceph_caps_revoking_other(ci, NULL, CEPH_CAP_FILE_CACHE))\n\t\t\tcheck = 1;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tmutex_unlock(&ci->i_truncate_mutex);\nout:\n\tif (check)\n\t\tceph_check_caps(ci, 0);\n}\n\n \nvoid __ceph_do_pending_vmtruncate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 to;\n\tint wrbuffer_refs, finish = 0;\n\n\tmutex_lock(&ci->i_truncate_mutex);\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_truncate_pending == 0) {\n\t\tdout(\"%s %p none pending\\n\", __func__, inode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tmutex_unlock(&ci->i_truncate_mutex);\n\t\treturn;\n\t}\n\n\t \n\tif (ci->i_wrbuffer_ref_head < ci->i_wrbuffer_ref) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tdout(\"%s %p flushing snaps first\\n\", __func__, inode);\n\t\tfilemap_write_and_wait_range(&inode->i_data, 0,\n\t\t\t\t\t     inode->i_sb->s_maxbytes);\n\t\tgoto retry;\n\t}\n\n\t \n\tWARN_ON_ONCE(ci->i_rd_ref || ci->i_wr_ref);\n\n\tto = ci->i_truncate_pagecache_size;\n\twrbuffer_refs = ci->i_wrbuffer_ref;\n\tdout(\"%s %p (%d) to %lld\\n\", __func__, inode,\n\t     ci->i_truncate_pending, to);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tceph_fscache_resize(inode, to);\n\ttruncate_pagecache(inode, to);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (to == ci->i_truncate_pagecache_size) {\n\t\tci->i_truncate_pending = 0;\n\t\tfinish = 1;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (!finish)\n\t\tgoto retry;\n\n\tmutex_unlock(&ci->i_truncate_mutex);\n\n\tif (wrbuffer_refs == 0)\n\t\tceph_check_caps(ci, 0);\n\n\twake_up_all(&ci->i_cap_wq);\n}\n\nstatic void ceph_inode_work(struct work_struct *work)\n{\n\tstruct ceph_inode_info *ci = container_of(work, struct ceph_inode_info,\n\t\t\t\t\t\t i_work);\n\tstruct inode *inode = &ci->netfs.inode;\n\n\tif (test_and_clear_bit(CEPH_I_WORK_WRITEBACK, &ci->i_work_mask)) {\n\t\tdout(\"writeback %p\\n\", inode);\n\t\tfilemap_fdatawrite(&inode->i_data);\n\t}\n\tif (test_and_clear_bit(CEPH_I_WORK_INVALIDATE_PAGES, &ci->i_work_mask))\n\t\tceph_do_invalidate_pages(inode);\n\n\tif (test_and_clear_bit(CEPH_I_WORK_VMTRUNCATE, &ci->i_work_mask))\n\t\t__ceph_do_pending_vmtruncate(inode);\n\n\tif (test_and_clear_bit(CEPH_I_WORK_CHECK_CAPS, &ci->i_work_mask))\n\t\tceph_check_caps(ci, 0);\n\n\tif (test_and_clear_bit(CEPH_I_WORK_FLUSH_SNAPS, &ci->i_work_mask))\n\t\tceph_flush_snaps(ci, NULL);\n\n\tiput(inode);\n}\n\nstatic const char *ceph_encrypted_get_link(struct dentry *dentry,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   struct delayed_call *done)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\treturn fscrypt_get_symlink(inode, ci->i_symlink, i_size_read(inode),\n\t\t\t\t   done);\n}\n\nstatic int ceph_encrypted_symlink_getattr(struct mnt_idmap *idmap,\n\t\t\t\t\t  const struct path *path,\n\t\t\t\t\t  struct kstat *stat, u32 request_mask,\n\t\t\t\t\t  unsigned int query_flags)\n{\n\tint ret;\n\n\tret = ceph_getattr(idmap, path, stat, request_mask, query_flags);\n\tif (ret)\n\t\treturn ret;\n\treturn fscrypt_symlink_getattr(path, stat);\n}\n\n \nstatic const struct inode_operations ceph_symlink_iops = {\n\t.get_link = simple_get_link,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_getattr,\n\t.listxattr = ceph_listxattr,\n};\n\nstatic const struct inode_operations ceph_encrypted_symlink_iops = {\n\t.get_link = ceph_encrypted_get_link,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_encrypted_symlink_getattr,\n\t.listxattr = ceph_listxattr,\n};\n\n \nstatic int fill_fscrypt_truncate(struct inode *inode,\n\t\t\t\t struct ceph_mds_request *req,\n\t\t\t\t struct iattr *attr)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint boff = attr->ia_size % CEPH_FSCRYPT_BLOCK_SIZE;\n\tloff_t pos, orig_pos = round_down(attr->ia_size,\n\t\t\t\t\t  CEPH_FSCRYPT_BLOCK_SIZE);\n\tu64 block = orig_pos >> CEPH_FSCRYPT_BLOCK_SHIFT;\n\tstruct ceph_pagelist *pagelist = NULL;\n\tstruct kvec iov = {0};\n\tstruct iov_iter iter;\n\tstruct page *page = NULL;\n\tstruct ceph_fscrypt_truncate_size_header header;\n\tint retry_op = 0;\n\tint len = CEPH_FSCRYPT_BLOCK_SIZE;\n\tloff_t i_size = i_size_read(inode);\n\tint got, ret, issued;\n\tu64 objver;\n\n\tret = __ceph_get_caps(inode, NULL, CEPH_CAP_FILE_RD, 0, -1, &got);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tissued = __ceph_caps_issued(ci, NULL);\n\n\tdout(\"%s size %lld -> %lld got cap refs on %s, issued %s\\n\", __func__,\n\t     i_size, attr->ia_size, ceph_cap_string(got),\n\t     ceph_cap_string(issued));\n\n\t \n\tif (issued & (CEPH_CAP_FILE_BUFFER)) {\n\t\tloff_t lend = orig_pos + CEPH_FSCRYPT_BLOCK_SHIFT - 1;\n\n\t\tret = filemap_write_and_wait_range(inode->i_mapping,\n\t\t\t\t\t\t   orig_pos, lend);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tpage = __page_cache_alloc(GFP_KERNEL);\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpagelist = ceph_pagelist_alloc(GFP_KERNEL);\n\tif (!pagelist) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tiov.iov_base = kmap_local_page(page);\n\tiov.iov_len = len;\n\tiov_iter_kvec(&iter, READ, &iov, 1, len);\n\n\tpos = orig_pos;\n\tret = __ceph_sync_read(inode, &pos, &iter, &retry_op, &objver);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\theader.ver = 1;\n\theader.compat = 1;\n\theader.change_attr = cpu_to_le64(inode_peek_iversion_raw(inode));\n\n\t \n\theader.block_size = cpu_to_le32(CEPH_FSCRYPT_BLOCK_SIZE);\n\n\t \n\tif (!objver) {\n\t\tdout(\"%s hit hole, ppos %lld < size %lld\\n\", __func__,\n\t\t     pos, i_size);\n\n\t\theader.data_len = cpu_to_le32(8 + 8 + 4);\n\t\theader.file_offset = 0;\n\t\tret = 0;\n\t} else {\n\t\theader.data_len = cpu_to_le32(8 + 8 + 4 + CEPH_FSCRYPT_BLOCK_SIZE);\n\t\theader.file_offset = cpu_to_le64(orig_pos);\n\n\t\tdout(\"%s encrypt block boff/bsize %d/%lu\\n\", __func__,\n\t\t     boff, CEPH_FSCRYPT_BLOCK_SIZE);\n\n\t\t \n\t\tmemset(iov.iov_base + boff, 0, PAGE_SIZE - boff);\n\n\t\t \n\t\tret = ceph_fscrypt_encrypt_block_inplace(inode, page,\n\t\t\t\t\t\t    CEPH_FSCRYPT_BLOCK_SIZE,\n\t\t\t\t\t\t    0, block,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tret = ceph_pagelist_append(pagelist, &header, sizeof(header));\n\tif (ret)\n\t\tgoto out;\n\n\tif (header.block_size) {\n\t\t \n\t\tret = ceph_pagelist_append(pagelist, iov.iov_base,\n\t\t\t\t\t   CEPH_FSCRYPT_BLOCK_SIZE);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\treq->r_pagelist = pagelist;\nout:\n\tdout(\"%s %p size dropping cap refs on %s\\n\", __func__,\n\t     inode, ceph_cap_string(got));\n\tceph_put_cap_refs(ci, got);\n\tif (iov.iov_base)\n\t\tkunmap_local(iov.iov_base);\n\tif (page)\n\t\t__free_pages(page, 0);\n\tif (ret && pagelist)\n\t\tceph_pagelist_release(pagelist);\n\treturn ret;\n}\n\nint __ceph_setattr(struct inode *inode, struct iattr *attr,\n\t\t   struct ceph_iattr *cia)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tunsigned int ia_valid = attr->ia_valid;\n\tstruct ceph_mds_request *req;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_cap_flush *prealloc_cf;\n\tloff_t isize = i_size_read(inode);\n\tint issued;\n\tint release = 0, dirtied = 0;\n\tint mask = 0;\n\tint err = 0;\n\tint inode_dirty_flags = 0;\n\tbool lock_snap_rwsem = false;\n\tbool fill_fscrypt;\n\tint truncate_retry = 20;  \n\nretry:\n\tprealloc_cf = ceph_alloc_cap_flush();\n\tif (!prealloc_cf)\n\t\treturn -ENOMEM;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETATTR,\n\t\t\t\t       USE_AUTH_MDS);\n\tif (IS_ERR(req)) {\n\t\tceph_free_cap_flush(prealloc_cf);\n\t\treturn PTR_ERR(req);\n\t}\n\n\tfill_fscrypt = false;\n\tspin_lock(&ci->i_ceph_lock);\n\tissued = __ceph_caps_issued(ci, NULL);\n\n\tif (!ci->i_head_snapc &&\n\t    (issued & (CEPH_CAP_ANY_EXCL | CEPH_CAP_FILE_WR))) {\n\t\tlock_snap_rwsem = true;\n\t\tif (!down_read_trylock(&mdsc->snap_rwsem)) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tissued = __ceph_caps_issued(ci, NULL);\n\t\t}\n\t}\n\n\tdout(\"setattr %p issued %s\\n\", inode, ceph_cap_string(issued));\n#if IS_ENABLED(CONFIG_FS_ENCRYPTION)\n\tif (cia && cia->fscrypt_auth) {\n\t\tu32 len = ceph_fscrypt_auth_len(cia->fscrypt_auth);\n\n\t\tif (len > sizeof(*cia->fscrypt_auth)) {\n\t\t\terr = -EINVAL;\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdout(\"setattr %llx:%llx fscrypt_auth len %u to %u)\\n\",\n\t\t\tceph_vinop(inode), ci->fscrypt_auth_len, len);\n\n\t\t \n\t\tWARN_ON_ONCE(ci->fscrypt_auth);\n\n\t\tif (issued & CEPH_CAP_AUTH_EXCL) {\n\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t\tkfree(ci->fscrypt_auth);\n\t\t\tci->fscrypt_auth = (u8 *)cia->fscrypt_auth;\n\t\t\tci->fscrypt_auth_len = len;\n\t\t} else if ((issued & CEPH_CAP_AUTH_SHARED) == 0 ||\n\t\t\t   ci->fscrypt_auth_len != len ||\n\t\t\t   memcmp(ci->fscrypt_auth, cia->fscrypt_auth, len)) {\n\t\t\treq->r_fscrypt_auth = cia->fscrypt_auth;\n\t\t\tmask |= CEPH_SETATTR_FSCRYPT_AUTH;\n\t\t\trelease |= CEPH_CAP_AUTH_SHARED;\n\t\t}\n\t\tcia->fscrypt_auth = NULL;\n\t}\n#else\n\tif (cia && cia->fscrypt_auth) {\n\t\terr = -EINVAL;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tgoto out;\n\t}\n#endif  \n\n\tif (ia_valid & ATTR_UID) {\n\t\tdout(\"setattr %p uid %d -> %d\\n\", inode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kuid(&init_user_ns, attr->ia_uid));\n\t\tif (issued & CEPH_CAP_AUTH_EXCL) {\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t} else if ((issued & CEPH_CAP_AUTH_SHARED) == 0 ||\n\t\t\t   !uid_eq(attr->ia_uid, inode->i_uid)) {\n\t\t\treq->r_args.setattr.uid = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, attr->ia_uid));\n\t\t\tmask |= CEPH_SETATTR_UID;\n\t\t\trelease |= CEPH_CAP_AUTH_SHARED;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_GID) {\n\t\tdout(\"setattr %p gid %d -> %d\\n\", inode,\n\t\t     from_kgid(&init_user_ns, inode->i_gid),\n\t\t     from_kgid(&init_user_ns, attr->ia_gid));\n\t\tif (issued & CEPH_CAP_AUTH_EXCL) {\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t} else if ((issued & CEPH_CAP_AUTH_SHARED) == 0 ||\n\t\t\t   !gid_eq(attr->ia_gid, inode->i_gid)) {\n\t\t\treq->r_args.setattr.gid = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, attr->ia_gid));\n\t\t\tmask |= CEPH_SETATTR_GID;\n\t\t\trelease |= CEPH_CAP_AUTH_SHARED;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_MODE) {\n\t\tdout(\"setattr %p mode 0%o -> 0%o\\n\", inode, inode->i_mode,\n\t\t     attr->ia_mode);\n\t\tif (issued & CEPH_CAP_AUTH_EXCL) {\n\t\t\tinode->i_mode = attr->ia_mode;\n\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t} else if ((issued & CEPH_CAP_AUTH_SHARED) == 0 ||\n\t\t\t   attr->ia_mode != inode->i_mode) {\n\t\t\tinode->i_mode = attr->ia_mode;\n\t\t\treq->r_args.setattr.mode = cpu_to_le32(attr->ia_mode);\n\t\t\tmask |= CEPH_SETATTR_MODE;\n\t\t\trelease |= CEPH_CAP_AUTH_SHARED;\n\t\t}\n\t}\n\n\tif (ia_valid & ATTR_ATIME) {\n\t\tdout(\"setattr %p atime %lld.%ld -> %lld.%ld\\n\", inode,\n\t\t     inode->i_atime.tv_sec, inode->i_atime.tv_nsec,\n\t\t     attr->ia_atime.tv_sec, attr->ia_atime.tv_nsec);\n\t\tif (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\tci->i_time_warp_seq++;\n\t\t\tinode->i_atime = attr->ia_atime;\n\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t} else if ((issued & CEPH_CAP_FILE_WR) &&\n\t\t\t   timespec64_compare(&inode->i_atime,\n\t\t\t\t\t    &attr->ia_atime) < 0) {\n\t\t\tinode->i_atime = attr->ia_atime;\n\t\t\tdirtied |= CEPH_CAP_FILE_WR;\n\t\t} else if ((issued & CEPH_CAP_FILE_SHARED) == 0 ||\n\t\t\t   !timespec64_equal(&inode->i_atime, &attr->ia_atime)) {\n\t\t\tceph_encode_timespec64(&req->r_args.setattr.atime,\n\t\t\t\t\t       &attr->ia_atime);\n\t\t\tmask |= CEPH_SETATTR_ATIME;\n\t\t\trelease |= CEPH_CAP_FILE_SHARED |\n\t\t\t\t   CEPH_CAP_FILE_RD | CEPH_CAP_FILE_WR;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_SIZE) {\n\t\tdout(\"setattr %p size %lld -> %lld\\n\", inode, isize, attr->ia_size);\n\t\t \n\t\tif (IS_ENCRYPTED(inode) && attr->ia_size < isize &&\n\t\t    (attr->ia_size % CEPH_FSCRYPT_BLOCK_SIZE)) {\n\t\t\tmask |= CEPH_SETATTR_SIZE;\n\t\t\trelease |= CEPH_CAP_FILE_SHARED | CEPH_CAP_FILE_EXCL |\n\t\t\t\t   CEPH_CAP_FILE_RD | CEPH_CAP_FILE_WR;\n\t\t\tset_bit(CEPH_MDS_R_FSCRYPT_FILE, &req->r_req_flags);\n\t\t\tmask |= CEPH_SETATTR_FSCRYPT_FILE;\n\t\t\treq->r_args.setattr.size =\n\t\t\t\tcpu_to_le64(round_up(attr->ia_size,\n\t\t\t\t\t\t     CEPH_FSCRYPT_BLOCK_SIZE));\n\t\t\treq->r_args.setattr.old_size =\n\t\t\t\tcpu_to_le64(round_up(isize,\n\t\t\t\t\t\t     CEPH_FSCRYPT_BLOCK_SIZE));\n\t\t\treq->r_fscrypt_file = attr->ia_size;\n\t\t\tfill_fscrypt = true;\n\t\t} else if ((issued & CEPH_CAP_FILE_EXCL) && attr->ia_size >= isize) {\n\t\t\tif (attr->ia_size > isize) {\n\t\t\t\ti_size_write(inode, attr->ia_size);\n\t\t\t\tinode->i_blocks = calc_inode_blocks(attr->ia_size);\n\t\t\t\tci->i_reported_size = attr->ia_size;\n\t\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t\t\tia_valid |= ATTR_MTIME;\n\t\t\t}\n\t\t} else if ((issued & CEPH_CAP_FILE_SHARED) == 0 ||\n\t\t\t   attr->ia_size != isize) {\n\t\t\tmask |= CEPH_SETATTR_SIZE;\n\t\t\trelease |= CEPH_CAP_FILE_SHARED | CEPH_CAP_FILE_EXCL |\n\t\t\t\t   CEPH_CAP_FILE_RD | CEPH_CAP_FILE_WR;\n\t\t\tif (IS_ENCRYPTED(inode) && attr->ia_size) {\n\t\t\t\tset_bit(CEPH_MDS_R_FSCRYPT_FILE, &req->r_req_flags);\n\t\t\t\tmask |= CEPH_SETATTR_FSCRYPT_FILE;\n\t\t\t\treq->r_args.setattr.size =\n\t\t\t\t\tcpu_to_le64(round_up(attr->ia_size,\n\t\t\t\t\t\t\t     CEPH_FSCRYPT_BLOCK_SIZE));\n\t\t\t\treq->r_args.setattr.old_size =\n\t\t\t\t\tcpu_to_le64(round_up(isize,\n\t\t\t\t\t\t\t     CEPH_FSCRYPT_BLOCK_SIZE));\n\t\t\t\treq->r_fscrypt_file = attr->ia_size;\n\t\t\t} else {\n\t\t\t\treq->r_args.setattr.size = cpu_to_le64(attr->ia_size);\n\t\t\t\treq->r_args.setattr.old_size = cpu_to_le64(isize);\n\t\t\t\treq->r_fscrypt_file = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (ia_valid & ATTR_MTIME) {\n\t\tdout(\"setattr %p mtime %lld.%ld -> %lld.%ld\\n\", inode,\n\t\t     inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,\n\t\t     attr->ia_mtime.tv_sec, attr->ia_mtime.tv_nsec);\n\t\tif (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\tci->i_time_warp_seq++;\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t} else if ((issued & CEPH_CAP_FILE_WR) &&\n\t\t\t   timespec64_compare(&inode->i_mtime,\n\t\t\t\t\t    &attr->ia_mtime) < 0) {\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\t\tdirtied |= CEPH_CAP_FILE_WR;\n\t\t} else if ((issued & CEPH_CAP_FILE_SHARED) == 0 ||\n\t\t\t   !timespec64_equal(&inode->i_mtime, &attr->ia_mtime)) {\n\t\t\tceph_encode_timespec64(&req->r_args.setattr.mtime,\n\t\t\t\t\t       &attr->ia_mtime);\n\t\t\tmask |= CEPH_SETATTR_MTIME;\n\t\t\trelease |= CEPH_CAP_FILE_SHARED |\n\t\t\t\t   CEPH_CAP_FILE_RD | CEPH_CAP_FILE_WR;\n\t\t}\n\t}\n\n\t \n\tif (ia_valid & ATTR_CTIME) {\n\t\tbool only = (ia_valid & (ATTR_SIZE|ATTR_MTIME|ATTR_ATIME|\n\t\t\t\t\t ATTR_MODE|ATTR_UID|ATTR_GID)) == 0;\n\t\tdout(\"setattr %p ctime %lld.%ld -> %lld.%ld (%s)\\n\", inode,\n\t\t     inode_get_ctime(inode).tv_sec,\n\t\t     inode_get_ctime(inode).tv_nsec,\n\t\t     attr->ia_ctime.tv_sec, attr->ia_ctime.tv_nsec,\n\t\t     only ? \"ctime only\" : \"ignored\");\n\t\tif (only) {\n\t\t\t \n\t\t\tif (issued & CEPH_CAP_AUTH_EXCL)\n\t\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t\telse if (issued & CEPH_CAP_FILE_EXCL)\n\t\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t\telse if (issued & CEPH_CAP_XATTR_EXCL)\n\t\t\t\tdirtied |= CEPH_CAP_XATTR_EXCL;\n\t\t\telse\n\t\t\t\tmask |= CEPH_SETATTR_CTIME;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_FILE)\n\t\tdout(\"setattr %p ATTR_FILE ... hrm!\\n\", inode);\n\n\tif (dirtied) {\n\t\tinode_dirty_flags = __ceph_mark_dirty_caps(ci, dirtied,\n\t\t\t\t\t\t\t   &prealloc_cf);\n\t\tinode_set_ctime_to_ts(inode, attr->ia_ctime);\n\t\tinode_inc_iversion_raw(inode);\n\t}\n\n\trelease &= issued;\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (lock_snap_rwsem) {\n\t\tup_read(&mdsc->snap_rwsem);\n\t\tlock_snap_rwsem = false;\n\t}\n\n\tif (inode_dirty_flags)\n\t\t__mark_inode_dirty(inode, inode_dirty_flags);\n\n\tif (mask) {\n\t\treq->r_inode = inode;\n\t\tihold(inode);\n\t\treq->r_inode_drop = release;\n\t\treq->r_args.setattr.mask = cpu_to_le32(mask);\n\t\treq->r_num_caps = 1;\n\t\treq->r_stamp = attr->ia_ctime;\n\t\tif (fill_fscrypt) {\n\t\t\terr = fill_fscrypt_truncate(inode, req, attr);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\t\tif (err == -EAGAIN && truncate_retry--) {\n\t\t\tdout(\"setattr %p result=%d (%s locally, %d remote), retry it!\\n\",\n\t\t\t     inode, err, ceph_cap_string(dirtied), mask);\n\t\t\tceph_mdsc_put_request(req);\n\t\t\tceph_free_cap_flush(prealloc_cf);\n\t\t\tgoto retry;\n\t\t}\n\t}\nout:\n\tdout(\"setattr %p result=%d (%s locally, %d remote)\\n\", inode, err,\n\t     ceph_cap_string(dirtied), mask);\n\n\tceph_mdsc_put_request(req);\n\tceph_free_cap_flush(prealloc_cf);\n\n\tif (err >= 0 && (mask & CEPH_SETATTR_SIZE))\n\t\t__ceph_do_pending_vmtruncate(inode);\n\n\treturn err;\n}\n\n \nint ceph_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tint err;\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tif (ceph_inode_is_shutdown(inode))\n\t\treturn -ESTALE;\n\n\terr = fscrypt_prepare_setattr(dentry, attr);\n\tif (err)\n\t\treturn err;\n\n\terr = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\tif (err != 0)\n\t\treturn err;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size > max(i_size_read(inode), fsc->max_file_size))\n\t\treturn -EFBIG;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    ceph_quota_is_max_bytes_exceeded(inode, attr->ia_size))\n\t\treturn -EDQUOT;\n\n\terr = __ceph_setattr(inode, attr, NULL);\n\n\tif (err >= 0 && (attr->ia_valid & ATTR_MODE))\n\t\terr = posix_acl_chmod(&nop_mnt_idmap, dentry, attr->ia_mode);\n\n\treturn err;\n}\n\nint ceph_try_to_choose_auth_mds(struct inode *inode, int mask)\n{\n\tint issued = ceph_caps_issued(ceph_inode(inode));\n\n\t \n\tif (((mask & CEPH_CAP_ANY_SHARED) && (issued & CEPH_CAP_ANY_EXCL))\n\t    || (mask & (CEPH_STAT_RSTAT | CEPH_STAT_CAP_XATTR)))\n\t\treturn USE_AUTH_MDS;\n\telse\n\t\treturn USE_ANY_MDS;\n}\n\n \nint __ceph_do_getattr(struct inode *inode, struct page *locked_page,\n\t\t      int mask, bool force)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tint mode;\n\tint err;\n\n\tif (ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\tdout(\"do_getattr inode %p SNAPDIR\\n\", inode);\n\t\treturn 0;\n\t}\n\n\tdout(\"do_getattr inode %p mask %s mode 0%o\\n\",\n\t     inode, ceph_cap_string(mask), inode->i_mode);\n\tif (!force && ceph_caps_issued_mask_metric(ceph_inode(inode), mask, 1))\n\t\t\treturn 0;\n\n\tmode = ceph_try_to_choose_auth_mds(inode, mask);\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_GETATTR, mode);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\treq->r_args.getattr.mask = cpu_to_le32(mask);\n\treq->r_locked_page = locked_page;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (locked_page && err == 0) {\n\t\tu64 inline_version = req->r_reply_info.targeti.inline_version;\n\t\tif (inline_version == 0) {\n\t\t\t \n\t\t\terr = -EINVAL;\n\t\t} else if (inline_version == CEPH_INLINE_NONE ||\n\t\t\t   inline_version == 1) {\n\t\t\terr = -ENODATA;\n\t\t} else {\n\t\t\terr = req->r_reply_info.targeti.inline_len;\n\t\t}\n\t}\n\tceph_mdsc_put_request(req);\n\tdout(\"do_getattr result=%d\\n\", err);\n\treturn err;\n}\n\nint ceph_do_getvxattr(struct inode *inode, const char *name, void *value,\n\t\t      size_t size)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tint mode = USE_AUTH_MDS;\n\tint err;\n\tchar *xattr_value;\n\tsize_t xattr_value_len;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_GETVXATTR, mode);\n\tif (IS_ERR(req)) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\treq->r_feature_needed = CEPHFS_FEATURE_OP_GETVXATTR;\n\treq->r_path2 = kstrdup(name, GFP_NOFS);\n\tif (!req->r_path2) {\n\t\terr = -ENOMEM;\n\t\tgoto put;\n\t}\n\n\tihold(inode);\n\treq->r_inode = inode;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (err < 0)\n\t\tgoto put;\n\n\txattr_value = req->r_reply_info.xattr_info.xattr_value;\n\txattr_value_len = req->r_reply_info.xattr_info.xattr_value_len;\n\n\tdout(\"do_getvxattr xattr_value_len:%zu, size:%zu\\n\", xattr_value_len, size);\n\n\terr = (int)xattr_value_len;\n\tif (size == 0)\n\t\tgoto put;\n\n\tif (xattr_value_len > size) {\n\t\terr = -ERANGE;\n\t\tgoto put;\n\t}\n\n\tmemcpy(value, xattr_value, xattr_value_len);\nput:\n\tceph_mdsc_put_request(req);\nout:\n\tdout(\"do_getvxattr result=%d\\n\", err);\n\treturn err;\n}\n\n\n \nint ceph_permission(struct mnt_idmap *idmap, struct inode *inode,\n\t\t    int mask)\n{\n\tint err;\n\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\terr = ceph_do_getattr(inode, CEPH_CAP_AUTH_SHARED, false);\n\n\tif (!err)\n\t\terr = generic_permission(&nop_mnt_idmap, inode, mask);\n\treturn err;\n}\n\n \nstatic int statx_to_caps(u32 want, umode_t mode)\n{\n\tint mask = 0;\n\n\tif (want & (STATX_MODE|STATX_UID|STATX_GID|STATX_CTIME|STATX_BTIME|STATX_CHANGE_COOKIE))\n\t\tmask |= CEPH_CAP_AUTH_SHARED;\n\n\tif (want & (STATX_NLINK|STATX_CTIME|STATX_CHANGE_COOKIE)) {\n\t\t \n\t\tif (S_ISDIR(mode))\n\t\t\tmask |= CEPH_CAP_FILE_SHARED;\n\t\telse\n\t\t\tmask |= CEPH_CAP_LINK_SHARED;\n\t}\n\n\tif (want & (STATX_ATIME|STATX_MTIME|STATX_CTIME|STATX_SIZE|STATX_BLOCKS|STATX_CHANGE_COOKIE))\n\t\tmask |= CEPH_CAP_FILE_SHARED;\n\n\tif (want & (STATX_CTIME|STATX_CHANGE_COOKIE))\n\t\tmask |= CEPH_CAP_XATTR_SHARED;\n\n\treturn mask;\n}\n\n \nint ceph_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t struct kstat *stat, u32 request_mask, unsigned int flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu32 valid_mask = STATX_BASIC_STATS;\n\tint err = 0;\n\n\tif (ceph_inode_is_shutdown(inode))\n\t\treturn -ESTALE;\n\n\t \n\tif ((flags & AT_STATX_SYNC_TYPE) != AT_STATX_DONT_SYNC) {\n\t\terr = ceph_do_getattr(inode,\n\t\t\t\tstatx_to_caps(request_mask, inode->i_mode),\n\t\t\t\tflags & AT_STATX_FORCE_SYNC);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\tstat->ino = ceph_present_inode(inode);\n\n\t \n\tif (ci->i_btime.tv_sec || ci->i_btime.tv_nsec) {\n\t\tstat->btime = ci->i_btime;\n\t\tvalid_mask |= STATX_BTIME;\n\t}\n\n\tif (request_mask & STATX_CHANGE_COOKIE) {\n\t\tstat->change_cookie = inode_peek_iversion_raw(inode);\n\t\tvalid_mask |= STATX_CHANGE_COOKIE;\n\t}\n\n\tif (ceph_snap(inode) == CEPH_NOSNAP)\n\t\tstat->dev = sb->s_dev;\n\telse\n\t\tstat->dev = ci->i_snapid_map ? ci->i_snapid_map->dev : 0;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (ceph_test_mount_opt(ceph_sb_to_client(sb), RBYTES)) {\n\t\t\tstat->size = ci->i_rbytes;\n\t\t} else if (ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\t\tstruct ceph_inode_info *pci;\n\t\t\tstruct ceph_snap_realm *realm;\n\t\t\tstruct inode *parent;\n\n\t\t\tparent = ceph_lookup_inode(sb, ceph_ino(inode));\n\t\t\tif (IS_ERR(parent))\n\t\t\t\treturn PTR_ERR(parent);\n\n\t\t\tpci = ceph_inode(parent);\n\t\t\tspin_lock(&pci->i_ceph_lock);\n\t\t\trealm = pci->i_snap_realm;\n\t\t\tif (realm)\n\t\t\t\tstat->size = realm->num_snaps;\n\t\t\telse\n\t\t\t\tstat->size = 0;\n\t\t\tspin_unlock(&pci->i_ceph_lock);\n\t\t\tiput(parent);\n\t\t} else {\n\t\t\tstat->size = ci->i_files + ci->i_subdirs;\n\t\t}\n\t\tstat->blocks = 0;\n\t\tstat->blksize = 65536;\n\t\t \n\t\tif (stat->nlink == 1)\n\t\t\t \n\t\t\tstat->nlink = 1 + 1 + ci->i_subdirs;\n\t}\n\n\tstat->attributes |= STATX_ATTR_CHANGE_MONOTONIC;\n\tif (IS_ENCRYPTED(inode))\n\t\tstat->attributes |= STATX_ATTR_ENCRYPTED;\n\tstat->attributes_mask |= (STATX_ATTR_CHANGE_MONOTONIC |\n\t\t\t\t  STATX_ATTR_ENCRYPTED);\n\n\tstat->result_mask = request_mask & valid_mask;\n\treturn err;\n}\n\nvoid ceph_inode_shutdown(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct rb_node *p;\n\tint iputs = 0;\n\tbool invalidate = false;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tci->i_ceph_flags |= CEPH_I_SHUTDOWN;\n\tp = rb_first(&ci->i_caps);\n\twhile (p) {\n\t\tstruct ceph_cap *cap = rb_entry(p, struct ceph_cap, ci_node);\n\n\t\tp = rb_next(p);\n\t\tiputs += ceph_purge_inode_cap(inode, cap, &invalidate);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (invalidate)\n\t\tceph_queue_invalidate(inode);\n\twhile (iputs--)\n\t\tiput(inode);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}