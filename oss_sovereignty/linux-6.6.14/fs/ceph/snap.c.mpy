{
  "module_name": "snap.c",
  "hash_id": "f8052496a6ead34106797de591eafa2f2b2dbaab1609a7ad3b17289c8ff3e336",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/snap.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/iversion.h>\n#include \"super.h\"\n#include \"mds_client.h\"\n#include <linux/ceph/decode.h>\n\n \n#define CEPH_SNAPID_MAP_TIMEOUT\t(5 * 60 * HZ)\n\n \n \n\n\n \nvoid ceph_get_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tlockdep_assert_held(&mdsc->snap_rwsem);\n\n\t \n\tif (atomic_inc_not_zero(&realm->nref))\n\t\treturn;\n\n\tspin_lock(&mdsc->snap_empty_lock);\n\tif (atomic_inc_return(&realm->nref) == 1)\n\t\tlist_del_init(&realm->empty_item);\n\tspin_unlock(&mdsc->snap_empty_lock);\n}\n\nstatic void __insert_snap_realm(struct rb_root *root,\n\t\t\t\tstruct ceph_snap_realm *new)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_snap_realm *r = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tr = rb_entry(parent, struct ceph_snap_realm, node);\n\t\tif (new->ino < r->ino)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->ino > r->ino)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&new->node, parent, p);\n\trb_insert_color(&new->node, root);\n}\n\n \nstatic struct ceph_snap_realm *ceph_create_snap_realm(\n\tstruct ceph_mds_client *mdsc,\n\tu64 ino)\n{\n\tstruct ceph_snap_realm *realm;\n\n\tlockdep_assert_held_write(&mdsc->snap_rwsem);\n\n\trealm = kzalloc(sizeof(*realm), GFP_NOFS);\n\tif (!realm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tif (ino == CEPH_INO_GLOBAL_SNAPREALM)\n\t\tatomic_set(&realm->nref, 2);\n\telse\n\t\tatomic_set(&realm->nref, 1);\n\trealm->ino = ino;\n\tINIT_LIST_HEAD(&realm->children);\n\tINIT_LIST_HEAD(&realm->child_item);\n\tINIT_LIST_HEAD(&realm->empty_item);\n\tINIT_LIST_HEAD(&realm->dirty_item);\n\tINIT_LIST_HEAD(&realm->rebuild_item);\n\tINIT_LIST_HEAD(&realm->inodes_with_caps);\n\tspin_lock_init(&realm->inodes_with_caps_lock);\n\t__insert_snap_realm(&mdsc->snap_realms, realm);\n\tmdsc->num_snap_realms++;\n\n\tdout(\"%s %llx %p\\n\", __func__, realm->ino, realm);\n\treturn realm;\n}\n\n \nstatic struct ceph_snap_realm *__lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   u64 ino)\n{\n\tstruct rb_node *n = mdsc->snap_realms.rb_node;\n\tstruct ceph_snap_realm *r;\n\n\tlockdep_assert_held(&mdsc->snap_rwsem);\n\n\twhile (n) {\n\t\tr = rb_entry(n, struct ceph_snap_realm, node);\n\t\tif (ino < r->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (ino > r->ino)\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tdout(\"%s %llx %p\\n\", __func__, r->ino, r);\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstruct ceph_snap_realm *ceph_lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t       u64 ino)\n{\n\tstruct ceph_snap_realm *r;\n\tr = __lookup_snap_realm(mdsc, ino);\n\tif (r)\n\t\tceph_get_snap_realm(mdsc, r);\n\treturn r;\n}\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\n \nstatic void __destroy_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_snap_realm *realm)\n{\n\tlockdep_assert_held_write(&mdsc->snap_rwsem);\n\n\tdout(\"%s %p %llx\\n\", __func__, realm, realm->ino);\n\n\trb_erase(&realm->node, &mdsc->snap_realms);\n\tmdsc->num_snap_realms--;\n\n\tif (realm->parent) {\n\t\tlist_del_init(&realm->child_item);\n\t\t__put_snap_realm(mdsc, realm->parent);\n\t}\n\n\tkfree(realm->prior_parent_snaps);\n\tkfree(realm->snaps);\n\tceph_put_snap_context(realm->cached_context);\n\tkfree(realm);\n}\n\n \nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm)\n{\n\tlockdep_assert_held_write(&mdsc->snap_rwsem);\n\n\t \n\tif (atomic_dec_and_test(&realm->nref))\n\t\t__destroy_snap_realm(mdsc, realm);\n}\n\n \nvoid ceph_put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tif (!atomic_dec_and_lock(&realm->nref, &mdsc->snap_empty_lock))\n\t\treturn;\n\n\tif (down_write_trylock(&mdsc->snap_rwsem)) {\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tup_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tlist_add(&realm->empty_item, &mdsc->snap_empty);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}\n\n \nstatic void __cleanup_empty_realms(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_snap_realm *realm;\n\n\tlockdep_assert_held_write(&mdsc->snap_rwsem);\n\n\tspin_lock(&mdsc->snap_empty_lock);\n\twhile (!list_empty(&mdsc->snap_empty)) {\n\t\trealm = list_first_entry(&mdsc->snap_empty,\n\t\t\t\t   struct ceph_snap_realm, empty_item);\n\t\tlist_del(&realm->empty_item);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t}\n\tspin_unlock(&mdsc->snap_empty_lock);\n}\n\nvoid ceph_cleanup_global_and_empty_realms(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_snap_realm *global_realm;\n\n\tdown_write(&mdsc->snap_rwsem);\n\tglobal_realm = __lookup_snap_realm(mdsc, CEPH_INO_GLOBAL_SNAPREALM);\n\tif (global_realm)\n\t\tceph_put_snap_realm(mdsc, global_realm);\n\t__cleanup_empty_realms(mdsc);\n\tup_write(&mdsc->snap_rwsem);\n}\n\n \nstatic int adjust_snap_realm_parent(struct ceph_mds_client *mdsc,\n\t\t\t\t    struct ceph_snap_realm *realm,\n\t\t\t\t    u64 parentino)\n{\n\tstruct ceph_snap_realm *parent;\n\n\tlockdep_assert_held_write(&mdsc->snap_rwsem);\n\n\tif (realm->parent_ino == parentino)\n\t\treturn 0;\n\n\tparent = ceph_lookup_snap_realm(mdsc, parentino);\n\tif (!parent) {\n\t\tparent = ceph_create_snap_realm(mdsc, parentino);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t}\n\tdout(\"%s %llx %p: %llx %p -> %llx %p\\n\", __func__, realm->ino,\n\t     realm, realm->parent_ino, realm->parent, parentino, parent);\n\tif (realm->parent) {\n\t\tlist_del_init(&realm->child_item);\n\t\tceph_put_snap_realm(mdsc, realm->parent);\n\t}\n\trealm->parent_ino = parentino;\n\trealm->parent = parent;\n\tlist_add(&realm->child_item, &parent->children);\n\treturn 1;\n}\n\n\nstatic int cmpu64_rev(const void *a, const void *b)\n{\n\tif (*(u64 *)a < *(u64 *)b)\n\t\treturn 1;\n\tif (*(u64 *)a > *(u64 *)b)\n\t\treturn -1;\n\treturn 0;\n}\n\n\n \nstatic int build_snap_context(struct ceph_snap_realm *realm,\n\t\t\t      struct list_head *realm_queue,\n\t\t\t      struct list_head *dirty_realms)\n{\n\tstruct ceph_snap_realm *parent = realm->parent;\n\tstruct ceph_snap_context *snapc;\n\tint err = 0;\n\tu32 num = realm->num_prior_parent_snaps + realm->num_snaps;\n\n\t \n\tif (parent) {\n\t\tif (!parent->cached_context) {\n\t\t\t \n\t\t\tlist_add(&parent->rebuild_item, realm_queue);\n\t\t\treturn 1;\n\t\t}\n\t\tnum += parent->cached_context->num_snaps;\n\t}\n\n\t \n\tif (realm->cached_context &&\n\t    realm->cached_context->seq == realm->seq &&\n\t    (!parent ||\n\t     realm->cached_context->seq >= parent->cached_context->seq)) {\n\t\tdout(\"%s %llx %p: %p seq %lld (%u snaps) (unchanged)\\n\",\n\t\t     __func__, realm->ino, realm, realm->cached_context,\n\t\t     realm->cached_context->seq,\n\t\t     (unsigned int)realm->cached_context->num_snaps);\n\t\treturn 0;\n\t}\n\n\t \n\terr = -ENOMEM;\n\tif (num > (SIZE_MAX - sizeof(*snapc)) / sizeof(u64))\n\t\tgoto fail;\n\tsnapc = ceph_create_snap_context(num, GFP_NOFS);\n\tif (!snapc)\n\t\tgoto fail;\n\n\t \n\tnum = 0;\n\tsnapc->seq = realm->seq;\n\tif (parent) {\n\t\tu32 i;\n\n\t\t \n\t\tfor (i = 0; i < parent->cached_context->num_snaps; i++)\n\t\t\tif (parent->cached_context->snaps[i] >=\n\t\t\t    realm->parent_since)\n\t\t\t\tsnapc->snaps[num++] =\n\t\t\t\t\tparent->cached_context->snaps[i];\n\t\tif (parent->cached_context->seq > snapc->seq)\n\t\t\tsnapc->seq = parent->cached_context->seq;\n\t}\n\tmemcpy(snapc->snaps + num, realm->snaps,\n\t       sizeof(u64)*realm->num_snaps);\n\tnum += realm->num_snaps;\n\tmemcpy(snapc->snaps + num, realm->prior_parent_snaps,\n\t       sizeof(u64)*realm->num_prior_parent_snaps);\n\tnum += realm->num_prior_parent_snaps;\n\n\tsort(snapc->snaps, num, sizeof(u64), cmpu64_rev, NULL);\n\tsnapc->num_snaps = num;\n\tdout(\"%s %llx %p: %p seq %lld (%u snaps)\\n\", __func__, realm->ino,\n\t     realm, snapc, snapc->seq, (unsigned int) snapc->num_snaps);\n\n\tceph_put_snap_context(realm->cached_context);\n\trealm->cached_context = snapc;\n\t \n\tlist_add_tail(&realm->dirty_item, dirty_realms);\n\treturn 0;\n\nfail:\n\t \n\tif (realm->cached_context) {\n\t\tceph_put_snap_context(realm->cached_context);\n\t\trealm->cached_context = NULL;\n\t}\n\tpr_err(\"%s %llx %p fail %d\\n\", __func__, realm->ino, realm, err);\n\treturn err;\n}\n\n \nstatic void rebuild_snap_realms(struct ceph_snap_realm *realm,\n\t\t\t\tstruct list_head *dirty_realms)\n{\n\tLIST_HEAD(realm_queue);\n\tint last = 0;\n\tbool skip = false;\n\n\tlist_add_tail(&realm->rebuild_item, &realm_queue);\n\n\twhile (!list_empty(&realm_queue)) {\n\t\tstruct ceph_snap_realm *_realm, *child;\n\n\t\t_realm = list_first_entry(&realm_queue,\n\t\t\t\t\t  struct ceph_snap_realm,\n\t\t\t\t\t  rebuild_item);\n\n\t\t \n\t\tif (last < 0) {\n\t\t\tlist_del_init(&_realm->rebuild_item);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlast = build_snap_context(_realm, &realm_queue, dirty_realms);\n\t\tdout(\"%s %llx %p, %s\\n\", __func__, _realm->ino, _realm,\n\t\t     last > 0 ? \"is deferred\" : !last ? \"succeeded\" : \"failed\");\n\n\t\t \n\t\tlist_for_each_entry(child, &_realm->children, child_item) {\n\t\t\tif (!list_empty(&child->rebuild_item)) {\n\t\t\t\tskip = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!skip) {\n\t\t\tlist_for_each_entry(child, &_realm->children, child_item)\n\t\t\t\tlist_add_tail(&child->rebuild_item, &realm_queue);\n\t\t}\n\n\t\t \n\t\tif (last <= 0)\n\t\t\tlist_del_init(&_realm->rebuild_item);\n\t}\n}\n\n\n \nstatic int dup_array(u64 **dst, __le64 *src, u32 num)\n{\n\tu32 i;\n\n\tkfree(*dst);\n\tif (num) {\n\t\t*dst = kcalloc(num, sizeof(u64), GFP_NOFS);\n\t\tif (!*dst)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < num; i++)\n\t\t\t(*dst)[i] = get_unaligned_le64(src + i);\n\t} else {\n\t\t*dst = NULL;\n\t}\n\treturn 0;\n}\n\nstatic bool has_new_snaps(struct ceph_snap_context *o,\n\t\t\t  struct ceph_snap_context *n)\n{\n\tif (n->num_snaps == 0)\n\t\treturn false;\n\t \n\treturn n->snaps[0] > o->seq;\n}\n\n \nstatic void ceph_queue_cap_snap(struct ceph_inode_info *ci,\n\t\t\t\tstruct ceph_cap_snap **pcapsnap)\n{\n\tstruct inode *inode = &ci->netfs.inode;\n\tstruct ceph_snap_context *old_snapc, *new_snapc;\n\tstruct ceph_cap_snap *capsnap = *pcapsnap;\n\tstruct ceph_buffer *old_blob = NULL;\n\tint used, dirty;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tused = __ceph_caps_used(ci);\n\tdirty = __ceph_caps_dirty(ci);\n\n\told_snapc = ci->i_head_snapc;\n\tnew_snapc = ci->i_snap_realm->cached_context;\n\n\t \n\tif (used & CEPH_CAP_FILE_WR)\n\t\tdirty |= CEPH_CAP_FILE_WR;\n\n\tif (__ceph_have_pending_cap_snap(ci)) {\n\t\t \n\t\tdout(\"%s %p %llx.%llx already pending\\n\",\n\t\t     __func__, inode, ceph_vinop(inode));\n\t\tgoto update_snapc;\n\t}\n\tif (ci->i_wrbuffer_ref_head == 0 &&\n\t    !(dirty & (CEPH_CAP_ANY_EXCL|CEPH_CAP_FILE_WR))) {\n\t\tdout(\"%s %p %llx.%llx nothing dirty|writing\\n\",\n\t\t     __func__, inode, ceph_vinop(inode));\n\t\tgoto update_snapc;\n\t}\n\n\tBUG_ON(!old_snapc);\n\n\t \n\tif (has_new_snaps(old_snapc, new_snapc)) {\n\t\tif (dirty & (CEPH_CAP_ANY_EXCL|CEPH_CAP_FILE_WR))\n\t\t\tcapsnap->need_flush = true;\n\t} else {\n\t\tif (!(used & CEPH_CAP_FILE_WR) &&\n\t\t    ci->i_wrbuffer_ref_head == 0) {\n\t\t\tdout(\"%s %p %llx.%llx no new_snap|dirty_page|writing\\n\",\n\t\t\t     __func__, inode, ceph_vinop(inode));\n\t\t\tgoto update_snapc;\n\t\t}\n\t}\n\n\tdout(\"%s %p %llx.%llx cap_snap %p queuing under %p %s %s\\n\",\n\t     __func__, inode, ceph_vinop(inode), capsnap, old_snapc,\n\t     ceph_cap_string(dirty), capsnap->need_flush ? \"\" : \"no_flush\");\n\tihold(inode);\n\n\tcapsnap->follows = old_snapc->seq;\n\tcapsnap->issued = __ceph_caps_issued(ci, NULL);\n\tcapsnap->dirty = dirty;\n\n\tcapsnap->mode = inode->i_mode;\n\tcapsnap->uid = inode->i_uid;\n\tcapsnap->gid = inode->i_gid;\n\n\tif (dirty & CEPH_CAP_XATTR_EXCL) {\n\t\told_blob = __ceph_build_xattrs_blob(ci);\n\t\tcapsnap->xattr_blob =\n\t\t\tceph_buffer_get(ci->i_xattrs.blob);\n\t\tcapsnap->xattr_version = ci->i_xattrs.version;\n\t} else {\n\t\tcapsnap->xattr_blob = NULL;\n\t\tcapsnap->xattr_version = 0;\n\t}\n\n\tcapsnap->inline_data = ci->i_inline_version != CEPH_INLINE_NONE;\n\n\t \n\tcapsnap->dirty_pages = ci->i_wrbuffer_ref_head;\n\tci->i_wrbuffer_ref_head = 0;\n\tcapsnap->context = old_snapc;\n\tlist_add_tail(&capsnap->ci_item, &ci->i_cap_snaps);\n\n\tif (used & CEPH_CAP_FILE_WR) {\n\t\tdout(\"%s %p %llx.%llx cap_snap %p snapc %p seq %llu used WR,\"\n\t\t     \" now pending\\n\", __func__, inode, ceph_vinop(inode),\n\t\t     capsnap, old_snapc, old_snapc->seq);\n\t\tcapsnap->writing = 1;\n\t} else {\n\t\t \n\t\t__ceph_finish_cap_snap(ci, capsnap);\n\t}\n\t*pcapsnap = NULL;\n\told_snapc = NULL;\n\nupdate_snapc:\n\tif (ci->i_wrbuffer_ref_head == 0 &&\n\t    ci->i_wr_ref == 0 &&\n\t    ci->i_dirty_caps == 0 &&\n\t    ci->i_flushing_caps == 0) {\n\t\tci->i_head_snapc = NULL;\n\t} else {\n\t\tci->i_head_snapc = ceph_get_snap_context(new_snapc);\n\t\tdout(\" new snapc is %p\\n\", new_snapc);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tceph_buffer_put(old_blob);\n\tceph_put_snap_context(old_snapc);\n}\n\n \nint __ceph_finish_cap_snap(struct ceph_inode_info *ci,\n\t\t\t    struct ceph_cap_snap *capsnap)\n{\n\tstruct inode *inode = &ci->netfs.inode;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_mdsc(inode->i_sb);\n\n\tBUG_ON(capsnap->writing);\n\tcapsnap->size = i_size_read(inode);\n\tcapsnap->mtime = inode->i_mtime;\n\tcapsnap->atime = inode->i_atime;\n\tcapsnap->ctime = inode_get_ctime(inode);\n\tcapsnap->btime = ci->i_btime;\n\tcapsnap->change_attr = inode_peek_iversion_raw(inode);\n\tcapsnap->time_warp_seq = ci->i_time_warp_seq;\n\tcapsnap->truncate_size = ci->i_truncate_size;\n\tcapsnap->truncate_seq = ci->i_truncate_seq;\n\tif (capsnap->dirty_pages) {\n\t\tdout(\"%s %p %llx.%llx cap_snap %p snapc %p %llu %s s=%llu \"\n\t\t     \"still has %d dirty pages\\n\", __func__, inode,\n\t\t     ceph_vinop(inode), capsnap, capsnap->context,\n\t\t     capsnap->context->seq, ceph_cap_string(capsnap->dirty),\n\t\t     capsnap->size, capsnap->dirty_pages);\n\t\treturn 0;\n\t}\n\n\t \n\tif (ci->i_wrbuffer_ref) {\n\t\tdout(\"%s %p %llx.%llx cap_snap %p snapc %p %llu %s s=%llu \"\n\t\t     \"used WRBUFFER, delaying\\n\", __func__, inode,\n\t\t     ceph_vinop(inode), capsnap, capsnap->context,\n\t\t     capsnap->context->seq, ceph_cap_string(capsnap->dirty),\n\t\t     capsnap->size);\n\t\tceph_queue_writeback(inode);\n\t\treturn 0;\n\t}\n\n\tci->i_ceph_flags |= CEPH_I_FLUSH_SNAPS;\n\tdout(\"%s %p %llx.%llx cap_snap %p snapc %p %llu %s s=%llu\\n\",\n\t     __func__, inode, ceph_vinop(inode), capsnap, capsnap->context,\n\t     capsnap->context->seq, ceph_cap_string(capsnap->dirty),\n\t     capsnap->size);\n\n\tspin_lock(&mdsc->snap_flush_lock);\n\tif (list_empty(&ci->i_snap_flush_item)) {\n\t\tihold(inode);\n\t\tlist_add_tail(&ci->i_snap_flush_item, &mdsc->snap_flush_list);\n\t}\n\tspin_unlock(&mdsc->snap_flush_lock);\n\treturn 1;   \n}\n\n \nstatic void queue_realm_cap_snaps(struct ceph_snap_realm *realm)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct inode *lastinode = NULL;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tdout(\"%s %p %llx inode\\n\", __func__, realm, realm->ino);\n\n\tspin_lock(&realm->inodes_with_caps_lock);\n\tlist_for_each_entry(ci, &realm->inodes_with_caps, i_snap_realm_item) {\n\t\tstruct inode *inode = igrab(&ci->netfs.inode);\n\t\tif (!inode)\n\t\t\tcontinue;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tiput(lastinode);\n\t\tlastinode = inode;\n\n\t\t \n\t\tif (!capsnap) {\n\t\t\tcapsnap = kmem_cache_zalloc(ceph_cap_snap_cachep, GFP_NOFS);\n\t\t\tif (!capsnap) {\n\t\t\t\tpr_err(\"ENOMEM allocating ceph_cap_snap on %p\\n\",\n\t\t\t\t       inode);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcapsnap->cap_flush.is_capsnap = true;\n\t\trefcount_set(&capsnap->nref, 1);\n\t\tINIT_LIST_HEAD(&capsnap->cap_flush.i_list);\n\t\tINIT_LIST_HEAD(&capsnap->cap_flush.g_list);\n\t\tINIT_LIST_HEAD(&capsnap->ci_item);\n\n\t\tceph_queue_cap_snap(ci, &capsnap);\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t}\n\tspin_unlock(&realm->inodes_with_caps_lock);\n\tiput(lastinode);\n\n\tif (capsnap)\n\t\tkmem_cache_free(ceph_cap_snap_cachep, capsnap);\n\tdout(\"%s %p %llx done\\n\", __func__, realm, realm->ino);\n}\n\n \nint ceph_update_snap_trace(struct ceph_mds_client *mdsc,\n\t\t\t   void *p, void *e, bool deletion,\n\t\t\t   struct ceph_snap_realm **realm_ret)\n{\n\tstruct ceph_mds_snap_realm *ri;     \n\t__le64 *snaps;                      \n\t__le64 *prior_parent_snaps;         \n\tstruct ceph_snap_realm *realm;\n\tstruct ceph_snap_realm *first_realm = NULL;\n\tstruct ceph_snap_realm *realm_to_rebuild = NULL;\n\tstruct ceph_client *client = mdsc->fsc->client;\n\tint rebuild_snapcs;\n\tint err = -ENOMEM;\n\tint ret;\n\tLIST_HEAD(dirty_realms);\n\n\tlockdep_assert_held_write(&mdsc->snap_rwsem);\n\n\tdout(\"%s deletion=%d\\n\", __func__, deletion);\nmore:\n\trealm = NULL;\n\trebuild_snapcs = 0;\n\tceph_decode_need(&p, e, sizeof(*ri), bad);\n\tri = p;\n\tp += sizeof(*ri);\n\tceph_decode_need(&p, e, sizeof(u64)*(le32_to_cpu(ri->num_snaps) +\n\t\t\t    le32_to_cpu(ri->num_prior_parent_snaps)), bad);\n\tsnaps = p;\n\tp += sizeof(u64) * le32_to_cpu(ri->num_snaps);\n\tprior_parent_snaps = p;\n\tp += sizeof(u64) * le32_to_cpu(ri->num_prior_parent_snaps);\n\n\trealm = ceph_lookup_snap_realm(mdsc, le64_to_cpu(ri->ino));\n\tif (!realm) {\n\t\trealm = ceph_create_snap_realm(mdsc, le64_to_cpu(ri->ino));\n\t\tif (IS_ERR(realm)) {\n\t\t\terr = PTR_ERR(realm);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\terr = adjust_snap_realm_parent(mdsc, realm, le64_to_cpu(ri->parent));\n\tif (err < 0)\n\t\tgoto fail;\n\trebuild_snapcs += err;\n\n\tif (le64_to_cpu(ri->seq) > realm->seq) {\n\t\tdout(\"%s updating %llx %p %lld -> %lld\\n\", __func__,\n\t\t     realm->ino, realm, realm->seq, le64_to_cpu(ri->seq));\n\t\t \n\t\trealm->seq = le64_to_cpu(ri->seq);\n\t\trealm->created = le64_to_cpu(ri->created);\n\t\trealm->parent_since = le64_to_cpu(ri->parent_since);\n\n\t\trealm->num_snaps = le32_to_cpu(ri->num_snaps);\n\t\terr = dup_array(&realm->snaps, snaps, realm->num_snaps);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\trealm->num_prior_parent_snaps =\n\t\t\tle32_to_cpu(ri->num_prior_parent_snaps);\n\t\terr = dup_array(&realm->prior_parent_snaps, prior_parent_snaps,\n\t\t\t\trealm->num_prior_parent_snaps);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\tif (realm->seq > mdsc->last_snap_seq)\n\t\t\tmdsc->last_snap_seq = realm->seq;\n\n\t\trebuild_snapcs = 1;\n\t} else if (!realm->cached_context) {\n\t\tdout(\"%s %llx %p seq %lld new\\n\", __func__,\n\t\t     realm->ino, realm, realm->seq);\n\t\trebuild_snapcs = 1;\n\t} else {\n\t\tdout(\"%s %llx %p seq %lld unchanged\\n\", __func__,\n\t\t     realm->ino, realm, realm->seq);\n\t}\n\n\tdout(\"done with %llx %p, rebuild_snapcs=%d, %p %p\\n\", realm->ino,\n\t     realm, rebuild_snapcs, p, e);\n\n\t \n\tif (rebuild_snapcs)\n\t\trealm_to_rebuild = realm;\n\n\t \n\tif (realm_to_rebuild && p >= e)\n\t\trebuild_snap_realms(realm_to_rebuild, &dirty_realms);\n\n\tif (!first_realm)\n\t\tfirst_realm = realm;\n\telse\n\t\tceph_put_snap_realm(mdsc, realm);\n\n\tif (p < e)\n\t\tgoto more;\n\n\t \n\twhile (!list_empty(&dirty_realms)) {\n\t\trealm = list_first_entry(&dirty_realms, struct ceph_snap_realm,\n\t\t\t\t\t dirty_item);\n\t\tlist_del_init(&realm->dirty_item);\n\t\tqueue_realm_cap_snaps(realm);\n\t}\n\n\tif (realm_ret)\n\t\t*realm_ret = first_realm;\n\telse\n\t\tceph_put_snap_realm(mdsc, first_realm);\n\n\t__cleanup_empty_realms(mdsc);\n\treturn 0;\n\nbad:\n\terr = -EIO;\nfail:\n\tif (realm && !IS_ERR(realm))\n\t\tceph_put_snap_realm(mdsc, realm);\n\tif (first_realm)\n\t\tceph_put_snap_realm(mdsc, first_realm);\n\tpr_err(\"%s error %d\\n\", __func__, err);\n\n\t \n\tWRITE_ONCE(mdsc->fsc->mount_state, CEPH_MOUNT_FENCE_IO);\n\tret = ceph_monc_blocklist_add(&client->monc, &client->msgr.inst.addr);\n\tif (ret)\n\t\tpr_err(\"%s failed to blocklist %s: %d\\n\", __func__,\n\t\t       ceph_pr_addr(&client->msgr.inst.addr), ret);\n\n\tWARN(1, \"%s: %s%sdo remount to continue%s\",\n\t     __func__, ret ? \"\" : ceph_pr_addr(&client->msgr.inst.addr),\n\t     ret ? \"\" : \" was blocklisted, \",\n\t     err == -EIO ? \" after corrupted snaptrace is fixed\" : \"\");\n\n\treturn err;\n}\n\n\n \nstatic void flush_snaps(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct inode *inode;\n\tstruct ceph_mds_session *session = NULL;\n\n\tdout(\"%s\\n\", __func__);\n\tspin_lock(&mdsc->snap_flush_lock);\n\twhile (!list_empty(&mdsc->snap_flush_list)) {\n\t\tci = list_first_entry(&mdsc->snap_flush_list,\n\t\t\t\tstruct ceph_inode_info, i_snap_flush_item);\n\t\tinode = &ci->netfs.inode;\n\t\tihold(inode);\n\t\tspin_unlock(&mdsc->snap_flush_lock);\n\t\tceph_flush_snaps(ci, &session);\n\t\tiput(inode);\n\t\tspin_lock(&mdsc->snap_flush_lock);\n\t}\n\tspin_unlock(&mdsc->snap_flush_lock);\n\n\tceph_put_mds_session(session);\n\tdout(\"%s done\\n\", __func__);\n}\n\n \nvoid ceph_change_snap_realm(struct inode *inode, struct ceph_snap_realm *realm)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_snap_realm *oldrealm = ci->i_snap_realm;\n\n\tlockdep_assert_held(&ci->i_ceph_lock);\n\n\tif (oldrealm) {\n\t\tspin_lock(&oldrealm->inodes_with_caps_lock);\n\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\tif (oldrealm->ino == ci->i_vino.ino)\n\t\t\toldrealm->inode = NULL;\n\t\tspin_unlock(&oldrealm->inodes_with_caps_lock);\n\t\tceph_put_snap_realm(mdsc, oldrealm);\n\t}\n\n\tci->i_snap_realm = realm;\n\n\tif (realm) {\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\tlist_add(&ci->i_snap_realm_item, &realm->inodes_with_caps);\n\t\tif (realm->ino == ci->i_vino.ino)\n\t\t\trealm->inode = inode;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t}\n}\n\n \nvoid ceph_handle_snap(struct ceph_mds_client *mdsc,\n\t\t      struct ceph_mds_session *session,\n\t\t      struct ceph_msg *msg)\n{\n\tstruct super_block *sb = mdsc->fsc->sb;\n\tint mds = session->s_mds;\n\tu64 split;\n\tint op;\n\tint trace_len;\n\tstruct ceph_snap_realm *realm = NULL;\n\tvoid *p = msg->front.iov_base;\n\tvoid *e = p + msg->front.iov_len;\n\tstruct ceph_mds_snap_head *h;\n\tint num_split_inos, num_split_realms;\n\t__le64 *split_inos = NULL, *split_realms = NULL;\n\tint i;\n\tint locked_rwsem = 0;\n\tbool close_sessions = false;\n\n\tif (!ceph_inc_mds_stopping_blocker(mdsc, session))\n\t\treturn;\n\n\t \n\tif (msg->front.iov_len < sizeof(*h))\n\t\tgoto bad;\n\th = p;\n\top = le32_to_cpu(h->op);\n\tsplit = le64_to_cpu(h->split);    \n\tnum_split_inos = le32_to_cpu(h->num_split_inos);\n\tnum_split_realms = le32_to_cpu(h->num_split_realms);\n\ttrace_len = le32_to_cpu(h->trace_len);\n\tp += sizeof(*h);\n\n\tdout(\"%s from mds%d op %s split %llx tracelen %d\\n\", __func__,\n\t     mds, ceph_snap_op_name(op), split, trace_len);\n\n\tdown_write(&mdsc->snap_rwsem);\n\tlocked_rwsem = 1;\n\n\tif (op == CEPH_SNAP_OP_SPLIT) {\n\t\tstruct ceph_mds_snap_realm *ri;\n\n\t\t \n\t\tsplit_inos = p;\n\t\tp += sizeof(u64) * num_split_inos;\n\t\tsplit_realms = p;\n\t\tp += sizeof(u64) * num_split_realms;\n\t\tceph_decode_need(&p, e, sizeof(*ri), bad);\n\t\t \n\t\tri = p;\n\n\t\trealm = ceph_lookup_snap_realm(mdsc, split);\n\t\tif (!realm) {\n\t\t\trealm = ceph_create_snap_realm(mdsc, split);\n\t\t\tif (IS_ERR(realm))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tdout(\"splitting snap_realm %llx %p\\n\", realm->ino, realm);\n\t\tfor (i = 0; i < num_split_inos; i++) {\n\t\t\tstruct ceph_vino vino = {\n\t\t\t\t.ino = le64_to_cpu(split_inos[i]),\n\t\t\t\t.snap = CEPH_NOSNAP,\n\t\t\t};\n\t\t\tstruct inode *inode = ceph_find_inode(sb, vino);\n\t\t\tstruct ceph_inode_info *ci;\n\n\t\t\tif (!inode)\n\t\t\t\tcontinue;\n\t\t\tci = ceph_inode(inode);\n\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tif (!ci->i_snap_realm)\n\t\t\t\tgoto skip_inode;\n\t\t\t \n\t\t\tif (ci->i_snap_realm->created >\n\t\t\t    le64_to_cpu(ri->created)) {\n\t\t\t\tdout(\" leaving %p %llx.%llx in newer realm %llx %p\\n\",\n\t\t\t\t     inode, ceph_vinop(inode), ci->i_snap_realm->ino,\n\t\t\t\t     ci->i_snap_realm);\n\t\t\t\tgoto skip_inode;\n\t\t\t}\n\t\t\tdout(\" will move %p %llx.%llx to split realm %llx %p\\n\",\n\t\t\t     inode, ceph_vinop(inode), realm->ino, realm);\n\n\t\t\tceph_get_snap_realm(mdsc, realm);\n\t\t\tceph_change_snap_realm(inode, realm);\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tiput(inode);\n\t\t\tcontinue;\n\nskip_inode:\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tiput(inode);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < num_split_realms; i++) {\n\t\t\tstruct ceph_snap_realm *child =\n\t\t\t\t__lookup_snap_realm(mdsc,\n\t\t\t\t\t   le64_to_cpu(split_realms[i]));\n\t\t\tif (!child)\n\t\t\t\tcontinue;\n\t\t\tadjust_snap_realm_parent(mdsc, child, realm->ino);\n\t\t}\n\t} else {\n\t\t \n\t\tp += sizeof(u64) * num_split_inos;\n\t\tp += sizeof(u64) * num_split_realms;\n\t}\n\n\t \n\tif (ceph_update_snap_trace(mdsc, p, e,\n\t\t\t\t   op == CEPH_SNAP_OP_DESTROY,\n\t\t\t\t   NULL)) {\n\t\tclose_sessions = true;\n\t\tgoto bad;\n\t}\n\n\tif (op == CEPH_SNAP_OP_SPLIT)\n\t\t \n\t\tceph_put_snap_realm(mdsc, realm);\n\n\t__cleanup_empty_realms(mdsc);\n\n\tup_write(&mdsc->snap_rwsem);\n\n\tflush_snaps(mdsc);\n\tceph_dec_mds_stopping_blocker(mdsc);\n\treturn;\n\nbad:\n\tpr_err(\"%s corrupt snap message from mds%d\\n\", __func__, mds);\n\tceph_msg_dump(msg);\nout:\n\tif (locked_rwsem)\n\t\tup_write(&mdsc->snap_rwsem);\n\n\tceph_dec_mds_stopping_blocker(mdsc);\n\n\tif (close_sessions)\n\t\tceph_mdsc_close_sessions(mdsc);\n\treturn;\n}\n\nstruct ceph_snapid_map* ceph_get_snapid_map(struct ceph_mds_client *mdsc,\n\t\t\t\t\t    u64 snap)\n{\n\tstruct ceph_snapid_map *sm, *exist;\n\tstruct rb_node **p, *parent;\n\tint ret;\n\n\texist = NULL;\n\tspin_lock(&mdsc->snapid_map_lock);\n\tp = &mdsc->snapid_map_tree.rb_node;\n\twhile (*p) {\n\t\texist = rb_entry(*p, struct ceph_snapid_map, node);\n\t\tif (snap > exist->snap) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (snap < exist->snap) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tif (atomic_inc_return(&exist->ref) == 1)\n\t\t\t\tlist_del_init(&exist->lru);\n\t\t\tbreak;\n\t\t}\n\t\texist = NULL;\n\t}\n\tspin_unlock(&mdsc->snapid_map_lock);\n\tif (exist) {\n\t\tdout(\"%s found snapid map %llx -> %x\\n\", __func__,\n\t\t     exist->snap, exist->dev);\n\t\treturn exist;\n\t}\n\n\tsm = kmalloc(sizeof(*sm), GFP_NOFS);\n\tif (!sm)\n\t\treturn NULL;\n\n\tret = get_anon_bdev(&sm->dev);\n\tif (ret < 0) {\n\t\tkfree(sm);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&sm->lru);\n\tatomic_set(&sm->ref, 1);\n\tsm->snap = snap;\n\n\texist = NULL;\n\tparent = NULL;\n\tp = &mdsc->snapid_map_tree.rb_node;\n\tspin_lock(&mdsc->snapid_map_lock);\n\twhile (*p) {\n\t\tparent = *p;\n\t\texist = rb_entry(*p, struct ceph_snapid_map, node);\n\t\tif (snap > exist->snap)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (snap < exist->snap)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tbreak;\n\t\texist = NULL;\n\t}\n\tif (exist) {\n\t\tif (atomic_inc_return(&exist->ref) == 1)\n\t\t\tlist_del_init(&exist->lru);\n\t} else {\n\t\trb_link_node(&sm->node, parent, p);\n\t\trb_insert_color(&sm->node, &mdsc->snapid_map_tree);\n\t}\n\tspin_unlock(&mdsc->snapid_map_lock);\n\tif (exist) {\n\t\tfree_anon_bdev(sm->dev);\n\t\tkfree(sm);\n\t\tdout(\"%s found snapid map %llx -> %x\\n\", __func__,\n\t\t     exist->snap, exist->dev);\n\t\treturn exist;\n\t}\n\n\tdout(\"%s create snapid map %llx -> %x\\n\", __func__,\n\t     sm->snap, sm->dev);\n\treturn sm;\n}\n\nvoid ceph_put_snapid_map(struct ceph_mds_client* mdsc,\n\t\t\t struct ceph_snapid_map *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tif (atomic_dec_and_lock(&sm->ref, &mdsc->snapid_map_lock)) {\n\t\tif (!RB_EMPTY_NODE(&sm->node)) {\n\t\t\tsm->last_used = jiffies;\n\t\t\tlist_add_tail(&sm->lru, &mdsc->snapid_map_lru);\n\t\t\tspin_unlock(&mdsc->snapid_map_lock);\n\t\t} else {\n\t\t\t \n\t\t\tspin_unlock(&mdsc->snapid_map_lock);\n\t\t\tkfree(sm);\n\t\t}\n\t}\n}\n\nvoid ceph_trim_snapid_map(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_snapid_map *sm;\n\tunsigned long now;\n\tLIST_HEAD(to_free);\n\n\tspin_lock(&mdsc->snapid_map_lock);\n\tnow = jiffies;\n\n\twhile (!list_empty(&mdsc->snapid_map_lru)) {\n\t\tsm = list_first_entry(&mdsc->snapid_map_lru,\n\t\t\t\t      struct ceph_snapid_map, lru);\n\t\tif (time_after(sm->last_used + CEPH_SNAPID_MAP_TIMEOUT, now))\n\t\t\tbreak;\n\n\t\trb_erase(&sm->node, &mdsc->snapid_map_tree);\n\t\tlist_move(&sm->lru, &to_free);\n\t}\n\tspin_unlock(&mdsc->snapid_map_lock);\n\n\twhile (!list_empty(&to_free)) {\n\t\tsm = list_first_entry(&to_free, struct ceph_snapid_map, lru);\n\t\tlist_del(&sm->lru);\n\t\tdout(\"trim snapid map %llx -> %x\\n\", sm->snap, sm->dev);\n\t\tfree_anon_bdev(sm->dev);\n\t\tkfree(sm);\n\t}\n}\n\nvoid ceph_cleanup_snapid_map(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_snapid_map *sm;\n\tstruct rb_node *p;\n\tLIST_HEAD(to_free);\n\n\tspin_lock(&mdsc->snapid_map_lock);\n\twhile ((p = rb_first(&mdsc->snapid_map_tree))) {\n\t\tsm = rb_entry(p, struct ceph_snapid_map, node);\n\t\trb_erase(p, &mdsc->snapid_map_tree);\n\t\tRB_CLEAR_NODE(p);\n\t\tlist_move(&sm->lru, &to_free);\n\t}\n\tspin_unlock(&mdsc->snapid_map_lock);\n\n\twhile (!list_empty(&to_free)) {\n\t\tsm = list_first_entry(&to_free, struct ceph_snapid_map, lru);\n\t\tlist_del(&sm->lru);\n\t\tfree_anon_bdev(sm->dev);\n\t\tif (WARN_ON_ONCE(atomic_read(&sm->ref))) {\n\t\t\tpr_err(\"snapid map %llx -> %x still in use\\n\",\n\t\t\t       sm->snap, sm->dev);\n\t\t}\n\t\tkfree(sm);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}