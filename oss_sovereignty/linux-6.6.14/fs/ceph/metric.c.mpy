{
  "module_name": "metric.c",
  "hash_id": "3c38f323a8fd25c6ccde6c2d972a530f355840a04c04d6d7b64a4c5940b6c5ff",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/metric.c",
  "human_readable_source": " \n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/types.h>\n#include <linux/percpu_counter.h>\n#include <linux/math64.h>\n\n#include \"metric.h\"\n#include \"mds_client.h\"\n\nstatic void ktime_to_ceph_timespec(struct ceph_timespec *ts, ktime_t val)\n{\n\tstruct timespec64 t = ktime_to_timespec64(val);\n\tceph_encode_timespec64(ts, &t);\n}\n\nstatic bool ceph_mdsc_send_metrics(struct ceph_mds_client *mdsc,\n\t\t\t\t   struct ceph_mds_session *s)\n{\n\tstruct ceph_metric_head *head;\n\tstruct ceph_metric_cap *cap;\n\tstruct ceph_metric_read_latency *read;\n\tstruct ceph_metric_write_latency *write;\n\tstruct ceph_metric_metadata_latency *meta;\n\tstruct ceph_metric_dlease *dlease;\n\tstruct ceph_opened_files *files;\n\tstruct ceph_pinned_icaps *icaps;\n\tstruct ceph_opened_inodes *inodes;\n\tstruct ceph_read_io_size *rsize;\n\tstruct ceph_write_io_size *wsize;\n\tstruct ceph_client_metric *m = &mdsc->metric;\n\tu64 nr_caps = atomic64_read(&m->total_caps);\n\tu32 header_len = sizeof(struct ceph_metric_header);\n\tstruct ceph_msg *msg;\n\ts64 sum;\n\ts32 items = 0;\n\ts32 len;\n\n\t \n\tmutex_lock(&mdsc->mutex);\n\tif (ceph_mdsmap_get_state(mdsc->mdsmap, s->s_mds) != CEPH_MDS_STATE_ACTIVE) {\n\t\tmutex_unlock(&mdsc->mutex);\n\t\treturn false;\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\n\tlen = sizeof(*head) + sizeof(*cap) + sizeof(*read) + sizeof(*write)\n\t      + sizeof(*meta) + sizeof(*dlease) + sizeof(*files)\n\t      + sizeof(*icaps) + sizeof(*inodes) + sizeof(*rsize)\n\t      + sizeof(*wsize);\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_METRICS, len, GFP_NOFS, true);\n\tif (!msg) {\n\t\tpr_err(\"send metrics to mds%d, failed to allocate message\\n\",\n\t\t       s->s_mds);\n\t\treturn false;\n\t}\n\n\thead = msg->front.iov_base;\n\n\t \n\tcap = (struct ceph_metric_cap *)(head + 1);\n\tcap->header.type = cpu_to_le32(CLIENT_METRIC_TYPE_CAP_INFO);\n\tcap->header.ver = 1;\n\tcap->header.compat = 1;\n\tcap->header.data_len = cpu_to_le32(sizeof(*cap) - header_len);\n\tcap->hit = cpu_to_le64(percpu_counter_sum(&m->i_caps_hit));\n\tcap->mis = cpu_to_le64(percpu_counter_sum(&m->i_caps_mis));\n\tcap->total = cpu_to_le64(nr_caps);\n\titems++;\n\n\t \n\tread = (struct ceph_metric_read_latency *)(cap + 1);\n\tread->header.type = cpu_to_le32(CLIENT_METRIC_TYPE_READ_LATENCY);\n\tread->header.ver = 2;\n\tread->header.compat = 1;\n\tread->header.data_len = cpu_to_le32(sizeof(*read) - header_len);\n\tsum = m->metric[METRIC_READ].latency_sum;\n\tktime_to_ceph_timespec(&read->lat, sum);\n\tktime_to_ceph_timespec(&read->avg, m->metric[METRIC_READ].latency_avg);\n\tread->sq_sum = cpu_to_le64(m->metric[METRIC_READ].latency_sq_sum);\n\tread->count = cpu_to_le64(m->metric[METRIC_READ].total);\n\titems++;\n\n\t \n\twrite = (struct ceph_metric_write_latency *)(read + 1);\n\twrite->header.type = cpu_to_le32(CLIENT_METRIC_TYPE_WRITE_LATENCY);\n\twrite->header.ver = 2;\n\twrite->header.compat = 1;\n\twrite->header.data_len = cpu_to_le32(sizeof(*write) - header_len);\n\tsum = m->metric[METRIC_WRITE].latency_sum;\n\tktime_to_ceph_timespec(&write->lat, sum);\n\tktime_to_ceph_timespec(&write->avg, m->metric[METRIC_WRITE].latency_avg);\n\twrite->sq_sum = cpu_to_le64(m->metric[METRIC_WRITE].latency_sq_sum);\n\twrite->count = cpu_to_le64(m->metric[METRIC_WRITE].total);\n\titems++;\n\n\t \n\tmeta = (struct ceph_metric_metadata_latency *)(write + 1);\n\tmeta->header.type = cpu_to_le32(CLIENT_METRIC_TYPE_METADATA_LATENCY);\n\tmeta->header.ver = 2;\n\tmeta->header.compat = 1;\n\tmeta->header.data_len = cpu_to_le32(sizeof(*meta) - header_len);\n\tsum = m->metric[METRIC_METADATA].latency_sum;\n\tktime_to_ceph_timespec(&meta->lat, sum);\n\tktime_to_ceph_timespec(&meta->avg, m->metric[METRIC_METADATA].latency_avg);\n\tmeta->sq_sum = cpu_to_le64(m->metric[METRIC_METADATA].latency_sq_sum);\n\tmeta->count = cpu_to_le64(m->metric[METRIC_METADATA].total);\n\titems++;\n\n\t \n\tdlease = (struct ceph_metric_dlease *)(meta + 1);\n\tdlease->header.type = cpu_to_le32(CLIENT_METRIC_TYPE_DENTRY_LEASE);\n\tdlease->header.ver = 1;\n\tdlease->header.compat = 1;\n\tdlease->header.data_len = cpu_to_le32(sizeof(*dlease) - header_len);\n\tdlease->hit = cpu_to_le64(percpu_counter_sum(&m->d_lease_hit));\n\tdlease->mis = cpu_to_le64(percpu_counter_sum(&m->d_lease_mis));\n\tdlease->total = cpu_to_le64(atomic64_read(&m->total_dentries));\n\titems++;\n\n\tsum = percpu_counter_sum(&m->total_inodes);\n\n\t \n\tfiles = (struct ceph_opened_files *)(dlease + 1);\n\tfiles->header.type = cpu_to_le32(CLIENT_METRIC_TYPE_OPENED_FILES);\n\tfiles->header.ver = 1;\n\tfiles->header.compat = 1;\n\tfiles->header.data_len = cpu_to_le32(sizeof(*files) - header_len);\n\tfiles->opened_files = cpu_to_le64(atomic64_read(&m->opened_files));\n\tfiles->total = cpu_to_le64(sum);\n\titems++;\n\n\t \n\ticaps = (struct ceph_pinned_icaps *)(files + 1);\n\ticaps->header.type = cpu_to_le32(CLIENT_METRIC_TYPE_PINNED_ICAPS);\n\ticaps->header.ver = 1;\n\ticaps->header.compat = 1;\n\ticaps->header.data_len = cpu_to_le32(sizeof(*icaps) - header_len);\n\ticaps->pinned_icaps = cpu_to_le64(nr_caps);\n\ticaps->total = cpu_to_le64(sum);\n\titems++;\n\n\t \n\tinodes = (struct ceph_opened_inodes *)(icaps + 1);\n\tinodes->header.type = cpu_to_le32(CLIENT_METRIC_TYPE_OPENED_INODES);\n\tinodes->header.ver = 1;\n\tinodes->header.compat = 1;\n\tinodes->header.data_len = cpu_to_le32(sizeof(*inodes) - header_len);\n\tinodes->opened_inodes = cpu_to_le64(percpu_counter_sum(&m->opened_inodes));\n\tinodes->total = cpu_to_le64(sum);\n\titems++;\n\n\t \n\trsize = (struct ceph_read_io_size *)(inodes + 1);\n\trsize->header.type = cpu_to_le32(CLIENT_METRIC_TYPE_READ_IO_SIZES);\n\trsize->header.ver = 1;\n\trsize->header.compat = 1;\n\trsize->header.data_len = cpu_to_le32(sizeof(*rsize) - header_len);\n\trsize->total_ops = cpu_to_le64(m->metric[METRIC_READ].total);\n\trsize->total_size = cpu_to_le64(m->metric[METRIC_READ].size_sum);\n\titems++;\n\n\t \n\twsize = (struct ceph_write_io_size *)(rsize + 1);\n\twsize->header.type = cpu_to_le32(CLIENT_METRIC_TYPE_WRITE_IO_SIZES);\n\twsize->header.ver = 1;\n\twsize->header.compat = 1;\n\twsize->header.data_len = cpu_to_le32(sizeof(*wsize) - header_len);\n\twsize->total_ops = cpu_to_le64(m->metric[METRIC_WRITE].total);\n\twsize->total_size = cpu_to_le64(m->metric[METRIC_WRITE].size_sum);\n\titems++;\n\n\tput_unaligned_le32(items, &head->num);\n\tmsg->front.iov_len = len;\n\tmsg->hdr.version = cpu_to_le16(1);\n\tmsg->hdr.compat_version = cpu_to_le16(1);\n\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\tceph_con_send(&s->s_con, msg);\n\n\treturn true;\n}\n\n\nstatic void metric_get_session(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_mds_session *s;\n\tint i;\n\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\ts = __ceph_lookup_mds_session(mdsc, i);\n\t\tif (!s)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (check_session_state(s) &&\n\t\t    test_bit(CEPHFS_FEATURE_METRIC_COLLECT, &s->s_features)) {\n\t\t\tmdsc->metric.session = s;\n\t\t\tbreak;\n\t\t}\n\n\t\tceph_put_mds_session(s);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n}\n\nstatic void metric_delayed_work(struct work_struct *work)\n{\n\tstruct ceph_client_metric *m =\n\t\tcontainer_of(work, struct ceph_client_metric, delayed_work.work);\n\tstruct ceph_mds_client *mdsc =\n\t\tcontainer_of(m, struct ceph_mds_client, metric);\n\n\tif (mdsc->stopping || disable_send_metrics)\n\t\treturn;\n\n\tif (!m->session || !check_session_state(m->session)) {\n\t\tif (m->session) {\n\t\t\tceph_put_mds_session(m->session);\n\t\t\tm->session = NULL;\n\t\t}\n\t\tmetric_get_session(mdsc);\n\t}\n\tif (m->session) {\n\t\tceph_mdsc_send_metrics(mdsc, m->session);\n\t\tmetric_schedule_delayed(m);\n\t}\n}\n\nint ceph_metric_init(struct ceph_client_metric *m)\n{\n\tstruct ceph_metric *metric;\n\tint ret, i;\n\n\tif (!m)\n\t\treturn -EINVAL;\n\n\tatomic64_set(&m->total_dentries, 0);\n\tret = percpu_counter_init(&m->d_lease_hit, 0, GFP_KERNEL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = percpu_counter_init(&m->d_lease_mis, 0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto err_d_lease_mis;\n\n\tatomic64_set(&m->total_caps, 0);\n\tret = percpu_counter_init(&m->i_caps_hit, 0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto err_i_caps_hit;\n\n\tret = percpu_counter_init(&m->i_caps_mis, 0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto err_i_caps_mis;\n\n\tfor (i = 0; i < METRIC_MAX; i++) {\n\t\tmetric = &m->metric[i];\n\t\tspin_lock_init(&metric->lock);\n\t\tmetric->size_sum = 0;\n\t\tmetric->size_min = U64_MAX;\n\t\tmetric->size_max = 0;\n\t\tmetric->total = 0;\n\t\tmetric->latency_sum = 0;\n\t\tmetric->latency_avg = 0;\n\t\tmetric->latency_sq_sum = 0;\n\t\tmetric->latency_min = KTIME_MAX;\n\t\tmetric->latency_max = 0;\n\t}\n\n\tatomic64_set(&m->opened_files, 0);\n\tret = percpu_counter_init(&m->opened_inodes, 0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto err_opened_inodes;\n\tret = percpu_counter_init(&m->total_inodes, 0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto err_total_inodes;\n\n\tm->session = NULL;\n\tINIT_DELAYED_WORK(&m->delayed_work, metric_delayed_work);\n\n\treturn 0;\n\nerr_total_inodes:\n\tpercpu_counter_destroy(&m->opened_inodes);\nerr_opened_inodes:\n\tpercpu_counter_destroy(&m->i_caps_mis);\nerr_i_caps_mis:\n\tpercpu_counter_destroy(&m->i_caps_hit);\nerr_i_caps_hit:\n\tpercpu_counter_destroy(&m->d_lease_mis);\nerr_d_lease_mis:\n\tpercpu_counter_destroy(&m->d_lease_hit);\n\n\treturn ret;\n}\n\nvoid ceph_metric_destroy(struct ceph_client_metric *m)\n{\n\tif (!m)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&m->delayed_work);\n\n\tpercpu_counter_destroy(&m->total_inodes);\n\tpercpu_counter_destroy(&m->opened_inodes);\n\tpercpu_counter_destroy(&m->i_caps_mis);\n\tpercpu_counter_destroy(&m->i_caps_hit);\n\tpercpu_counter_destroy(&m->d_lease_mis);\n\tpercpu_counter_destroy(&m->d_lease_hit);\n\n\tceph_put_mds_session(m->session);\n}\n\n#define METRIC_UPDATE_MIN_MAX(min, max, new)\t\\\n{\t\t\t\t\t\t\\\n\tif (unlikely(new < min))\t\t\\\n\t\tmin = new;\t\t\t\\\n\tif (unlikely(new > max))\t\t\\\n\t\tmax = new;\t\t\t\\\n}\n\nstatic inline void __update_mean_and_stdev(ktime_t total, ktime_t *lavg,\n\t\t\t\t\t   ktime_t *sq_sump, ktime_t lat)\n{\n\tktime_t avg;\n\n\tif (unlikely(total == 1)) {\n\t\t*lavg = lat;\n\t} else {\n\t\t \n\t\tavg = *lavg + div64_s64(lat - *lavg, total);\n\t\t*sq_sump += (lat - *lavg)*(lat - avg);\n\t\t*lavg = avg;\n\t}\n}\n\nvoid ceph_update_metrics(struct ceph_metric *m,\n\t\t\t ktime_t r_start, ktime_t r_end,\n\t\t\t unsigned int size, int rc)\n{\n\tktime_t lat = ktime_sub(r_end, r_start);\n\tktime_t total;\n\n\tif (unlikely(rc < 0 && rc != -ENOENT && rc != -ETIMEDOUT))\n\t\treturn;\n\n\tspin_lock(&m->lock);\n\ttotal = ++m->total;\n\tm->size_sum += size;\n\tMETRIC_UPDATE_MIN_MAX(m->size_min, m->size_max, size);\n\tm->latency_sum += lat;\n\tMETRIC_UPDATE_MIN_MAX(m->latency_min, m->latency_max, lat);\n\t__update_mean_and_stdev(total, &m->latency_avg,\t&m->latency_sq_sum,\n\t\t\t\tlat);\n\tspin_unlock(&m->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}