{
  "module_name": "acl.c",
  "hash_id": "35c273597a0d357f05285dda3ab5542f5a309d918610a7758b240889322962dc",
  "original_prompt": "Ingested from linux-6.6.14/fs/ceph/acl.c",
  "human_readable_source": "\n \n\n#include <linux/ceph/ceph_debug.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include \"super.h\"\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask_metric(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\telse\n\t\tforget_cached_acl(inode, type);\n\tspin_unlock(&ci->i_ceph_lock);\n}\n\nstruct posix_acl *ceph_get_acl(struct inode *inode, int type, bool rcu)\n{\n\tint size;\n\tunsigned int retry_cnt = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\n\tif (rcu)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\nretry:\n\tsize = __ceph_getxattr(inode, name, \"\", 0);\n\tif (size > 0) {\n\t\tvalue = kzalloc(size, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = __ceph_getxattr(inode, name, value, size);\n\t}\n\n\tif (size == -ERANGE && retry_cnt < 10) {\n\t\tretry_cnt++;\n\t\tkfree(value);\n\t\tvalue = NULL;\n\t\tgoto retry;\n\t}\n\n\tif (size > 0) {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t} else if (size == -ENODATA || size == 0) {\n\t\tacl = NULL;\n\t} else {\n\t\tpr_err_ratelimited(\"get acl %llx.%llx failed, err=%d\\n\",\n\t\t\t\t   ceph_vinop(inode), size);\n\t\tacl = ERR_PTR(-EIO);\n\t}\n\n\tkfree(value);\n\n\tif (!IS_ERR(acl))\n\t\tceph_set_cached_acl(inode, type, acl);\n\n\treturn acl;\n}\n\nint ceph_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t struct posix_acl *acl, int type)\n{\n\tint ret = 0, size = 0;\n\tconst char *name = NULL;\n\tchar *value = NULL;\n\tstruct iattr newattrs;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct timespec64 old_ctime = inode_get_ctime(inode);\n\tumode_t new_mode = inode->i_mode, old_mode = inode->i_mode;\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP) {\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_update_mode(&nop_mnt_idmap, inode,\n\t\t\t\t\t\t    &new_mode, &acl);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tret = acl ? -EINVAL : 0;\n\t\t\tgoto out;\n\t\t}\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (new_mode != old_mode) {\n\t\tnewattrs.ia_ctime = current_time(inode);\n\t\tnewattrs.ia_mode = new_mode;\n\t\tnewattrs.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\tret = __ceph_setattr(inode, &newattrs, NULL);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\tret = __ceph_setxattr(inode, name, value, size, 0);\n\tif (ret) {\n\t\tif (new_mode != old_mode) {\n\t\t\tnewattrs.ia_ctime = old_ctime;\n\t\t\tnewattrs.ia_mode = old_mode;\n\t\t\tnewattrs.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\t\t__ceph_setattr(inode, &newattrs, NULL);\n\t\t}\n\t\tgoto out_free;\n\t}\n\n\tceph_set_cached_acl(inode, type, acl);\n\nout_free:\n\tkfree(value);\nout:\n\treturn ret;\n}\n\nint ceph_pre_init_acls(struct inode *dir, umode_t *mode,\n\t\t       struct ceph_acl_sec_ctx *as_ctx)\n{\n\tstruct posix_acl *acl, *default_acl;\n\tsize_t val_size1 = 0, val_size2 = 0;\n\tstruct ceph_pagelist *pagelist = NULL;\n\tvoid *tmp_buf = NULL;\n\tint err;\n\n\terr = posix_acl_create(dir, mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (acl) {\n\t\terr = posix_acl_equiv_mode(acl, mode);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t\tif (err == 0) {\n\t\t\tposix_acl_release(acl);\n\t\t\tacl = NULL;\n\t\t}\n\t}\n\n\tif (!default_acl && !acl)\n\t\treturn 0;\n\n\tif (acl)\n\t\tval_size1 = posix_acl_xattr_size(acl->a_count);\n\tif (default_acl)\n\t\tval_size2 = posix_acl_xattr_size(default_acl->a_count);\n\n\terr = -ENOMEM;\n\ttmp_buf = kmalloc(max(val_size1, val_size2), GFP_KERNEL);\n\tif (!tmp_buf)\n\t\tgoto out_err;\n\tpagelist = ceph_pagelist_alloc(GFP_KERNEL);\n\tif (!pagelist)\n\t\tgoto out_err;\n\n\terr = ceph_pagelist_reserve(pagelist, PAGE_SIZE);\n\tif (err)\n\t\tgoto out_err;\n\n\tceph_pagelist_encode_32(pagelist, acl && default_acl ? 2 : 1);\n\n\tif (acl) {\n\t\tsize_t len = strlen(XATTR_NAME_POSIX_ACL_ACCESS);\n\t\terr = ceph_pagelist_reserve(pagelist, len + val_size1 + 8);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_string(pagelist, XATTR_NAME_POSIX_ACL_ACCESS,\n\t\t\t\t\t    len);\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl,\n\t\t\t\t\t tmp_buf, val_size1);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_32(pagelist, val_size1);\n\t\tceph_pagelist_append(pagelist, tmp_buf, val_size1);\n\t}\n\tif (default_acl) {\n\t\tsize_t len = strlen(XATTR_NAME_POSIX_ACL_DEFAULT);\n\t\terr = ceph_pagelist_reserve(pagelist, len + val_size2 + 8);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_string(pagelist,\n\t\t\t\t\t  XATTR_NAME_POSIX_ACL_DEFAULT, len);\n\t\terr = posix_acl_to_xattr(&init_user_ns, default_acl,\n\t\t\t\t\t tmp_buf, val_size2);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_32(pagelist, val_size2);\n\t\tceph_pagelist_append(pagelist, tmp_buf, val_size2);\n\t}\n\n\tkfree(tmp_buf);\n\n\tas_ctx->acl = acl;\n\tas_ctx->default_acl = default_acl;\n\tas_ctx->pagelist = pagelist;\n\treturn 0;\n\nout_err:\n\tposix_acl_release(acl);\n\tposix_acl_release(default_acl);\n\tkfree(tmp_buf);\n\tif (pagelist)\n\t\tceph_pagelist_release(pagelist);\n\treturn err;\n}\n\nvoid ceph_init_inode_acls(struct inode *inode, struct ceph_acl_sec_ctx *as_ctx)\n{\n\tif (!inode)\n\t\treturn;\n\tceph_set_cached_acl(inode, ACL_TYPE_ACCESS, as_ctx->acl);\n\tceph_set_cached_acl(inode, ACL_TYPE_DEFAULT, as_ctx->default_acl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}