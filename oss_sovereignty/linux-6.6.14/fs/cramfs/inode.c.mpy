{
  "module_name": "inode.c",
  "hash_id": "1f794313f3690c9febbdb67af27da462fb401ab3b8ce57671a146bd51f17c713",
  "original_prompt": "Ingested from linux-6.6.14/fs/cramfs/inode.c",
  "human_readable_source": " \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/pfn_t.h>\n#include <linux/ramfs.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/blkdev.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/super.h>\n#include <linux/fs_context.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/mutex.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/uaccess.h>\n\n#include \"internal.h\"\n\n \nstruct cramfs_sb_info {\n\tunsigned long magic;\n\tunsigned long size;\n\tunsigned long blocks;\n\tunsigned long files;\n\tunsigned long flags;\n\tvoid *linear_virt_addr;\n\tresource_size_t linear_phys_addr;\n\tsize_t mtd_point_size;\n};\n\nstatic inline struct cramfs_sb_info *CRAMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\nstatic const struct super_operations cramfs_ops;\nstatic const struct inode_operations cramfs_dir_inode_operations;\nstatic const struct file_operations cramfs_directory_operations;\nstatic const struct file_operations cramfs_physmem_fops;\nstatic const struct address_space_operations cramfs_aops;\n\nstatic DEFINE_MUTEX(read_mutex);\n\n\n \n#define OFFSET(x)\t((x)->i_ino)\n\nstatic unsigned long cramino(const struct cramfs_inode *cino, unsigned int offset)\n{\n\tif (!cino->offset)\n\t\treturn offset + 1;\n\tif (!cino->size)\n\t\treturn offset + 1;\n\n\t \n\tswitch (cino->mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\tcase S_IFLNK:\n\t\treturn cino->offset << 2;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn offset + 1;\n}\n\nstatic struct inode *get_cramfs_inode(struct super_block *sb,\n\tconst struct cramfs_inode *cramfs_inode, unsigned int offset)\n{\n\tstruct inode *inode;\n\tstatic struct timespec64 zerotime;\n\n\tinode = iget_locked(sb, cramino(cramfs_inode, offset));\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tswitch (cramfs_inode->mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_data.a_ops = &cramfs_aops;\n\t\tif (IS_ENABLED(CONFIG_CRAMFS_MTD) &&\n\t\t    CRAMFS_SB(sb)->flags & CRAMFS_FLAG_EXT_BLOCK_POINTERS &&\n\t\t    CRAMFS_SB(sb)->linear_phys_addr)\n\t\t\tinode->i_fop = &cramfs_physmem_fops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &cramfs_dir_inode_operations;\n\t\tinode->i_fop = &cramfs_directory_operations;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_data.a_ops = &cramfs_aops;\n\t\tbreak;\n\tdefault:\n\t\tinit_special_inode(inode, cramfs_inode->mode,\n\t\t\t\told_decode_dev(cramfs_inode->size));\n\t}\n\n\tinode->i_mode = cramfs_inode->mode;\n\ti_uid_write(inode, cramfs_inode->uid);\n\ti_gid_write(inode, cramfs_inode->gid);\n\n\t \n\tif (!(inode->i_ino & 3)) {\n\t\tinode->i_size = cramfs_inode->size;\n\t\tinode->i_blocks = (cramfs_inode->size - 1) / 512 + 1;\n\t}\n\n\t \n\tinode->i_mtime = inode->i_atime = inode_set_ctime_to_ts(inode,\n\t\t\t\t\t\t\t\tzerotime);\n\t \n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}\n\n \n#define READ_BUFFERS (2)\n \n#define NEXT_BUFFER(_ix) ((_ix) ^ 1)\n\n \n#define BLKS_PER_BUF_SHIFT\t(2)\n#define BLKS_PER_BUF\t\t(1 << BLKS_PER_BUF_SHIFT)\n#define BUFFER_SIZE\t\t(BLKS_PER_BUF*PAGE_SIZE)\n\nstatic unsigned char read_buffers[READ_BUFFERS][BUFFER_SIZE];\nstatic unsigned buffer_blocknr[READ_BUFFERS];\nstatic struct super_block *buffer_dev[READ_BUFFERS];\nstatic int next_buffer;\n\n \nstatic void *cramfs_blkdev_read(struct super_block *sb, unsigned int offset,\n\t\t\t\tunsigned int len)\n{\n\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\tstruct file_ra_state ra = {};\n\tstruct page *pages[BLKS_PER_BUF];\n\tunsigned i, blocknr, buffer;\n\tunsigned long devsize;\n\tchar *data;\n\n\tif (!len)\n\t\treturn NULL;\n\tblocknr = offset >> PAGE_SHIFT;\n\toffset &= PAGE_SIZE - 1;\n\n\t \n\tfor (i = 0; i < READ_BUFFERS; i++) {\n\t\tunsigned int blk_offset;\n\n\t\tif (buffer_dev[i] != sb)\n\t\t\tcontinue;\n\t\tif (blocknr < buffer_blocknr[i])\n\t\t\tcontinue;\n\t\tblk_offset = (blocknr - buffer_blocknr[i]) << PAGE_SHIFT;\n\t\tblk_offset += offset;\n\t\tif (blk_offset > BUFFER_SIZE ||\n\t\t    blk_offset + len > BUFFER_SIZE)\n\t\t\tcontinue;\n\t\treturn read_buffers[i] + blk_offset;\n\t}\n\n\tdevsize = bdev_nr_bytes(sb->s_bdev) >> PAGE_SHIFT;\n\n\t \n\tfile_ra_state_init(&ra, mapping);\n\tpage_cache_sync_readahead(mapping, &ra, NULL, blocknr, BLKS_PER_BUF);\n\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = NULL;\n\n\t\tif (blocknr + i < devsize) {\n\t\t\tpage = read_mapping_page(mapping, blocknr + i, NULL);\n\t\t\t \n\t\t\tif (IS_ERR(page))\n\t\t\t\tpage = NULL;\n\t\t}\n\t\tpages[i] = page;\n\t}\n\n\tbuffer = next_buffer;\n\tnext_buffer = NEXT_BUFFER(buffer);\n\tbuffer_blocknr[buffer] = blocknr;\n\tbuffer_dev[buffer] = sb;\n\n\tdata = read_buffers[buffer];\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\tmemcpy_from_page(data, page, 0, PAGE_SIZE);\n\t\t\tput_page(page);\n\t\t} else\n\t\t\tmemset(data, 0, PAGE_SIZE);\n\t\tdata += PAGE_SIZE;\n\t}\n\treturn read_buffers[buffer] + offset;\n}\n\n \nstatic void *cramfs_direct_read(struct super_block *sb, unsigned int offset,\n\t\t\t\tunsigned int len)\n{\n\tstruct cramfs_sb_info *sbi = CRAMFS_SB(sb);\n\n\tif (!len)\n\t\treturn NULL;\n\tif (len > sbi->size || offset > sbi->size - len)\n\t\treturn page_address(ZERO_PAGE(0));\n\treturn sbi->linear_virt_addr + offset;\n}\n\n \nstatic void *cramfs_read(struct super_block *sb, unsigned int offset,\n\t\t\t unsigned int len)\n{\n\tstruct cramfs_sb_info *sbi = CRAMFS_SB(sb);\n\n\tif (IS_ENABLED(CONFIG_CRAMFS_MTD) && sbi->linear_virt_addr)\n\t\treturn cramfs_direct_read(sb, offset, len);\n\telse if (IS_ENABLED(CONFIG_CRAMFS_BLOCKDEV))\n\t\treturn cramfs_blkdev_read(sb, offset, len);\n\telse\n\t\treturn NULL;\n}\n\n \nstatic u32 cramfs_get_block_range(struct inode *inode, u32 pgoff, u32 *pages)\n{\n\tstruct cramfs_sb_info *sbi = CRAMFS_SB(inode->i_sb);\n\tint i;\n\tu32 *blockptrs, first_block_addr;\n\n\t \n\tblockptrs = (u32 *)(sbi->linear_virt_addr + OFFSET(inode) + pgoff * 4);\n\tfirst_block_addr = blockptrs[0] & ~CRAMFS_BLK_FLAGS;\n\ti = 0;\n\tdo {\n\t\tu32 block_off = i * (PAGE_SIZE >> CRAMFS_BLK_DIRECT_PTR_SHIFT);\n\t\tu32 expect = (first_block_addr + block_off) |\n\t\t\t     CRAMFS_BLK_FLAG_DIRECT_PTR |\n\t\t\t     CRAMFS_BLK_FLAG_UNCOMPRESSED;\n\t\tif (blockptrs[i] != expect) {\n\t\t\tpr_debug(\"range: block %d/%d got %#x expects %#x\\n\",\n\t\t\t\t pgoff+i, pgoff + *pages - 1,\n\t\t\t\t blockptrs[i], expect);\n\t\t\tif (i == 0)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\t} while (++i < *pages);\n\n\t*pages = i;\n\treturn first_block_addr << CRAMFS_BLK_DIRECT_PTR_SHIFT;\n}\n\n#ifdef CONFIG_MMU\n\n \nstatic bool cramfs_last_page_is_shared(struct inode *inode)\n{\n\tstruct cramfs_sb_info *sbi = CRAMFS_SB(inode->i_sb);\n\tu32 partial, last_page, blockaddr, *blockptrs;\n\tchar *tail_data;\n\n\tpartial = offset_in_page(inode->i_size);\n\tif (!partial)\n\t\treturn false;\n\tlast_page = inode->i_size >> PAGE_SHIFT;\n\tblockptrs = (u32 *)(sbi->linear_virt_addr + OFFSET(inode));\n\tblockaddr = blockptrs[last_page] & ~CRAMFS_BLK_FLAGS;\n\tblockaddr <<= CRAMFS_BLK_DIRECT_PTR_SHIFT;\n\ttail_data = sbi->linear_virt_addr + blockaddr + partial;\n\treturn memchr_inv(tail_data, 0, PAGE_SIZE - partial) ? true : false;\n}\n\nstatic int cramfs_physmem_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct cramfs_sb_info *sbi = CRAMFS_SB(inode->i_sb);\n\tunsigned int pages, max_pages, offset;\n\tunsigned long address, pgoff = vma->vm_pgoff;\n\tchar *bailout_reason;\n\tint ret;\n\n\tret = generic_file_readonly_mmap(file, vma);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\t \n\tbailout_reason = \"vma is writable\";\n\tif (vma->vm_flags & VM_WRITE)\n\t\tgoto bailout;\n\n\tmax_pages = (inode->i_size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tbailout_reason = \"beyond file limit\";\n\tif (pgoff >= max_pages)\n\t\tgoto bailout;\n\tpages = min(vma_pages(vma), max_pages - pgoff);\n\n\toffset = cramfs_get_block_range(inode, pgoff, &pages);\n\tbailout_reason = \"unsuitable block layout\";\n\tif (!offset)\n\t\tgoto bailout;\n\taddress = sbi->linear_phys_addr + offset;\n\tbailout_reason = \"data is not page aligned\";\n\tif (!PAGE_ALIGNED(address))\n\t\tgoto bailout;\n\n\t \n\tif (pgoff + pages == max_pages && cramfs_last_page_is_shared(inode)) {\n\t\tpr_debug(\"mmap: %pD: last page is shared\\n\", file);\n\t\tpages--;\n\t}\n\n\tif (!pages) {\n\t\tbailout_reason = \"no suitable block remaining\";\n\t\tgoto bailout;\n\t}\n\n\tif (pages == vma_pages(vma)) {\n\t\t \n\t\tret = remap_pfn_range(vma, vma->vm_start, address >> PAGE_SHIFT,\n\t\t\t\t      pages * PAGE_SIZE, vma->vm_page_prot);\n\t} else {\n\t\t \n\t\tint i;\n\t\tvm_flags_set(vma, VM_MIXEDMAP);\n\t\tfor (i = 0; i < pages && !ret; i++) {\n\t\t\tvm_fault_t vmf;\n\t\t\tunsigned long off = i * PAGE_SIZE;\n\t\t\tpfn_t pfn = phys_to_pfn_t(address + off, PFN_DEV);\n\t\t\tvmf = vmf_insert_mixed(vma, vma->vm_start + off, pfn);\n\t\t\tif (vmf & VM_FAULT_ERROR)\n\t\t\t\tret = vm_fault_to_errno(vmf, 0);\n\t\t}\n\t}\n\n\tif (!ret)\n\t\tpr_debug(\"mapped %pD[%lu] at 0x%08lx (%u/%lu pages) \"\n\t\t\t \"to vma 0x%08lx, page_prot 0x%llx\\n\", file,\n\t\t\t pgoff, address, pages, vma_pages(vma), vma->vm_start,\n\t\t\t (unsigned long long)pgprot_val(vma->vm_page_prot));\n\treturn ret;\n\nbailout:\n\tpr_debug(\"%pD[%lu]: direct mmap impossible: %s\\n\",\n\t\t file, pgoff, bailout_reason);\n\t \n\treturn 0;\n}\n\n#else  \n\nstatic int cramfs_physmem_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\treturn is_nommu_shared_mapping(vma->vm_flags) ? 0 : -ENOSYS;\n}\n\nstatic unsigned long cramfs_physmem_get_unmapped_area(struct file *file,\n\t\t\tunsigned long addr, unsigned long len,\n\t\t\tunsigned long pgoff, unsigned long flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cramfs_sb_info *sbi = CRAMFS_SB(sb);\n\tunsigned int pages, block_pages, max_pages, offset;\n\n\tpages = (len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tmax_pages = (inode->i_size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (pgoff >= max_pages || pages > max_pages - pgoff)\n\t\treturn -EINVAL;\n\tblock_pages = pages;\n\toffset = cramfs_get_block_range(inode, pgoff, &block_pages);\n\tif (!offset || block_pages != pages)\n\t\treturn -ENOSYS;\n\taddr = sbi->linear_phys_addr + offset;\n\tpr_debug(\"get_unmapped for %pD ofs %#lx siz %lu at 0x%08lx\\n\",\n\t\t file, pgoff*PAGE_SIZE, len, addr);\n\treturn addr;\n}\n\nstatic unsigned int cramfs_physmem_mmap_capabilities(struct file *file)\n{\n\treturn NOMMU_MAP_COPY | NOMMU_MAP_DIRECT |\n\t       NOMMU_MAP_READ | NOMMU_MAP_EXEC;\n}\n\n#endif  \n\nstatic const struct file_operations cramfs_physmem_fops = {\n\t.llseek\t\t\t= generic_file_llseek,\n\t.read_iter\t\t= generic_file_read_iter,\n\t.splice_read\t\t= filemap_splice_read,\n\t.mmap\t\t\t= cramfs_physmem_mmap,\n#ifndef CONFIG_MMU\n\t.get_unmapped_area\t= cramfs_physmem_get_unmapped_area,\n\t.mmap_capabilities\t= cramfs_physmem_mmap_capabilities,\n#endif\n};\n\nstatic void cramfs_kill_sb(struct super_block *sb)\n{\n\tstruct cramfs_sb_info *sbi = CRAMFS_SB(sb);\n\n\tgeneric_shutdown_super(sb);\n\n\tif (IS_ENABLED(CONFIG_CRAMFS_MTD) && sb->s_mtd) {\n\t\tif (sbi && sbi->mtd_point_size)\n\t\t\tmtd_unpoint(sb->s_mtd, 0, sbi->mtd_point_size);\n\t\tput_mtd_device(sb->s_mtd);\n\t\tsb->s_mtd = NULL;\n\t} else if (IS_ENABLED(CONFIG_CRAMFS_BLOCKDEV) && sb->s_bdev) {\n\t\tsync_blockdev(sb->s_bdev);\n\t\tblkdev_put(sb->s_bdev, sb);\n\t}\n\tkfree(sbi);\n}\n\nstatic int cramfs_reconfigure(struct fs_context *fc)\n{\n\tsync_filesystem(fc->root->d_sb);\n\tfc->sb_flags |= SB_RDONLY;\n\treturn 0;\n}\n\nstatic int cramfs_read_super(struct super_block *sb, struct fs_context *fc,\n\t\t\t     struct cramfs_super *super)\n{\n\tstruct cramfs_sb_info *sbi = CRAMFS_SB(sb);\n\tunsigned long root_offset;\n\tbool silent = fc->sb_flags & SB_SILENT;\n\n\t \n\tsbi->size = PAGE_SIZE;\n\n\t \n\tmutex_lock(&read_mutex);\n\tmemcpy(super, cramfs_read(sb, 0, sizeof(*super)), sizeof(*super));\n\tmutex_unlock(&read_mutex);\n\n\t \n\tif (super->magic != CRAMFS_MAGIC) {\n\t\t \n\t\tif (super->magic == CRAMFS_MAGIC_WEND) {\n\t\t\tif (!silent)\n\t\t\t\terrorfc(fc, \"wrong endianness\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tmutex_lock(&read_mutex);\n\t\tmemcpy(super,\n\t\t       cramfs_read(sb, 512, sizeof(*super)),\n\t\t       sizeof(*super));\n\t\tmutex_unlock(&read_mutex);\n\t\tif (super->magic != CRAMFS_MAGIC) {\n\t\t\tif (super->magic == CRAMFS_MAGIC_WEND && !silent)\n\t\t\t\terrorfc(fc, \"wrong endianness\");\n\t\t\telse if (!silent)\n\t\t\t\terrorfc(fc, \"wrong magic\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (super->flags & ~CRAMFS_SUPPORTED_FLAGS) {\n\t\terrorfc(fc, \"unsupported filesystem features\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!S_ISDIR(super->root.mode)) {\n\t\terrorfc(fc, \"root is not a directory\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tsuper->root.mode |= 0555;\n\n\troot_offset = super->root.offset << 2;\n\tif (super->flags & CRAMFS_FLAG_FSID_VERSION_2) {\n\t\tsbi->size = super->size;\n\t\tsbi->blocks = super->fsid.blocks;\n\t\tsbi->files = super->fsid.files;\n\t} else {\n\t\tsbi->size = 1<<28;\n\t\tsbi->blocks = 0;\n\t\tsbi->files = 0;\n\t}\n\tsbi->magic = super->magic;\n\tsbi->flags = super->flags;\n\tif (root_offset == 0)\n\t\tinfofc(fc, \"empty filesystem\");\n\telse if (!(super->flags & CRAMFS_FLAG_SHIFTED_ROOT_OFFSET) &&\n\t\t ((root_offset != sizeof(struct cramfs_super)) &&\n\t\t  (root_offset != 512 + sizeof(struct cramfs_super))))\n\t{\n\t\terrorfc(fc, \"bad root offset %lu\", root_offset);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cramfs_finalize_super(struct super_block *sb,\n\t\t\t\t struct cramfs_inode *cramfs_root)\n{\n\tstruct inode *root;\n\n\t \n\tsb->s_flags |= SB_RDONLY;\n\tsb->s_time_min = 0;\n\tsb->s_time_max = 0;\n\tsb->s_op = &cramfs_ops;\n\troot = get_cramfs_inode(sb, cramfs_root, 0);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int cramfs_blkdev_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct cramfs_sb_info *sbi;\n\tstruct cramfs_super super;\n\tint i, err;\n\n\tsbi = kzalloc(sizeof(struct cramfs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbi;\n\n\t \n\tfor (i = 0; i < READ_BUFFERS; i++)\n\t\tbuffer_blocknr[i] = -1;\n\n\terr = cramfs_read_super(sb, fc, &super);\n\tif (err)\n\t\treturn err;\n\treturn cramfs_finalize_super(sb, &super.root);\n}\n\nstatic int cramfs_mtd_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct cramfs_sb_info *sbi;\n\tstruct cramfs_super super;\n\tint err;\n\n\tsbi = kzalloc(sizeof(struct cramfs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbi;\n\n\t \n\terr = mtd_point(sb->s_mtd, 0, PAGE_SIZE, &sbi->mtd_point_size,\n\t\t\t&sbi->linear_virt_addr, &sbi->linear_phys_addr);\n\tif (err || sbi->mtd_point_size != PAGE_SIZE) {\n\t\tpr_err(\"unable to get direct memory access to mtd:%s\\n\",\n\t\t       sb->s_mtd->name);\n\t\treturn err ? : -ENODATA;\n\t}\n\n\tpr_info(\"checking physical address %pap for linear cramfs image\\n\",\n\t\t&sbi->linear_phys_addr);\n\terr = cramfs_read_super(sb, fc, &super);\n\tif (err)\n\t\treturn err;\n\n\t \n\tpr_info(\"linear cramfs image on mtd:%s appears to be %lu KB in size\\n\",\n\t\tsb->s_mtd->name, sbi->size/1024);\n\tmtd_unpoint(sb->s_mtd, 0, PAGE_SIZE);\n\terr = mtd_point(sb->s_mtd, 0, sbi->size, &sbi->mtd_point_size,\n\t\t\t&sbi->linear_virt_addr, &sbi->linear_phys_addr);\n\tif (err || sbi->mtd_point_size != sbi->size) {\n\t\tpr_err(\"unable to get direct memory access to mtd:%s\\n\",\n\t\t       sb->s_mtd->name);\n\t\treturn err ? : -ENODATA;\n\t}\n\n\treturn cramfs_finalize_super(sb, &super.root);\n}\n\nstatic int cramfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tu64 id = 0;\n\n\tif (sb->s_bdev)\n\t\tid = huge_encode_dev(sb->s_bdev->bd_dev);\n\telse if (sb->s_dev)\n\t\tid = huge_encode_dev(sb->s_dev);\n\n\tbuf->f_type = CRAMFS_MAGIC;\n\tbuf->f_bsize = PAGE_SIZE;\n\tbuf->f_blocks = CRAMFS_SB(sb)->blocks;\n\tbuf->f_bfree = 0;\n\tbuf->f_bavail = 0;\n\tbuf->f_files = CRAMFS_SB(sb)->files;\n\tbuf->f_ffree = 0;\n\tbuf->f_fsid = u64_to_fsid(id);\n\tbuf->f_namelen = CRAMFS_MAXPATHLEN;\n\treturn 0;\n}\n\n \nstatic int cramfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tchar *buf;\n\tunsigned int offset;\n\n\t \n\tif (ctx->pos >= inode->i_size)\n\t\treturn 0;\n\toffset = ctx->pos;\n\t \n\tif (offset & 3)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(CRAMFS_MAXPATHLEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\twhile (offset < inode->i_size) {\n\t\tstruct cramfs_inode *de;\n\t\tunsigned long nextoffset;\n\t\tchar *name;\n\t\tino_t ino;\n\t\tumode_t mode;\n\t\tint namelen;\n\n\t\tmutex_lock(&read_mutex);\n\t\tde = cramfs_read(sb, OFFSET(inode) + offset, sizeof(*de)+CRAMFS_MAXPATHLEN);\n\t\tname = (char *)(de+1);\n\n\t\t \n\t\tnamelen = de->namelen << 2;\n\t\tmemcpy(buf, name, namelen);\n\t\tino = cramino(de, OFFSET(inode) + offset);\n\t\tmode = de->mode;\n\t\tmutex_unlock(&read_mutex);\n\t\tnextoffset = offset + sizeof(*de) + namelen;\n\t\tfor (;;) {\n\t\t\tif (!namelen) {\n\t\t\t\tkfree(buf);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (buf[namelen-1])\n\t\t\t\tbreak;\n\t\t\tnamelen--;\n\t\t}\n\t\tif (!dir_emit(ctx, buf, namelen, ino, mode >> 12))\n\t\t\tbreak;\n\n\t\tctx->pos = offset = nextoffset;\n\t}\n\tkfree(buf);\n\treturn 0;\n}\n\n \nstatic struct dentry *cramfs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tunsigned int offset = 0;\n\tstruct inode *inode = NULL;\n\tint sorted;\n\n\tmutex_lock(&read_mutex);\n\tsorted = CRAMFS_SB(dir->i_sb)->flags & CRAMFS_FLAG_SORTED_DIRS;\n\twhile (offset < dir->i_size) {\n\t\tstruct cramfs_inode *de;\n\t\tchar *name;\n\t\tint namelen, retval;\n\t\tint dir_off = OFFSET(dir) + offset;\n\n\t\tde = cramfs_read(dir->i_sb, dir_off, sizeof(*de)+CRAMFS_MAXPATHLEN);\n\t\tname = (char *)(de+1);\n\n\t\t \n\t\tif (sorted && (dentry->d_name.name[0] < name[0]))\n\t\t\tbreak;\n\n\t\tnamelen = de->namelen << 2;\n\t\toffset += sizeof(*de) + namelen;\n\n\t\t \n\t\tif (((dentry->d_name.len + 3) & ~3) != namelen)\n\t\t\tcontinue;\n\n\t\tfor (;;) {\n\t\t\tif (!namelen) {\n\t\t\t\tinode = ERR_PTR(-EIO);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name[namelen-1])\n\t\t\t\tbreak;\n\t\t\tnamelen--;\n\t\t}\n\t\tif (namelen != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tretval = memcmp(dentry->d_name.name, name, namelen);\n\t\tif (retval > 0)\n\t\t\tcontinue;\n\t\tif (!retval) {\n\t\t\tinode = get_cramfs_inode(dir->i_sb, de, dir_off);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (sorted)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&read_mutex);\n\treturn d_splice_alias(inode, dentry);\n}\n\nstatic int cramfs_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct page *page = &folio->page;\n\tstruct inode *inode = page->mapping->host;\n\tu32 maxblock;\n\tint bytes_filled;\n\tvoid *pgdata;\n\n\tmaxblock = (inode->i_size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tbytes_filled = 0;\n\tpgdata = kmap_local_page(page);\n\n\tif (page->index < maxblock) {\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tu32 blkptr_offset = OFFSET(inode) + page->index * 4;\n\t\tu32 block_ptr, block_start, block_len;\n\t\tbool uncompressed, direct;\n\n\t\tmutex_lock(&read_mutex);\n\t\tblock_ptr = *(u32 *) cramfs_read(sb, blkptr_offset, 4);\n\t\tuncompressed = (block_ptr & CRAMFS_BLK_FLAG_UNCOMPRESSED);\n\t\tdirect = (block_ptr & CRAMFS_BLK_FLAG_DIRECT_PTR);\n\t\tblock_ptr &= ~CRAMFS_BLK_FLAGS;\n\n\t\tif (direct) {\n\t\t\t \n\t\t\tblock_start = block_ptr << CRAMFS_BLK_DIRECT_PTR_SHIFT;\n\t\t\tif (uncompressed) {\n\t\t\t\tblock_len = PAGE_SIZE;\n\t\t\t\t \n\t\t\t\tif (page->index == maxblock - 1)\n\t\t\t\t\tblock_len =\n\t\t\t\t\t\toffset_in_page(inode->i_size);\n\t\t\t} else {\n\t\t\t\tblock_len = *(u16 *)\n\t\t\t\t\tcramfs_read(sb, block_start, 2);\n\t\t\t\tblock_start += 2;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tblock_start = OFFSET(inode) + maxblock * 4;\n\t\t\tif (page->index)\n\t\t\t\tblock_start = *(u32 *)\n\t\t\t\t\tcramfs_read(sb, blkptr_offset - 4, 4);\n\t\t\t \n\t\t\tif (unlikely(block_start & CRAMFS_BLK_FLAG_DIRECT_PTR)) {\n\t\t\t\t \n\t\t\t\tu32 prev_start = block_start;\n\t\t\t\tblock_start = prev_start & ~CRAMFS_BLK_FLAGS;\n\t\t\t\tblock_start <<= CRAMFS_BLK_DIRECT_PTR_SHIFT;\n\t\t\t\tif (prev_start & CRAMFS_BLK_FLAG_UNCOMPRESSED) {\n\t\t\t\t\tblock_start += PAGE_SIZE;\n\t\t\t\t} else {\n\t\t\t\t\tblock_len = *(u16 *)\n\t\t\t\t\t\tcramfs_read(sb, block_start, 2);\n\t\t\t\t\tblock_start += 2 + block_len;\n\t\t\t\t}\n\t\t\t}\n\t\t\tblock_start &= ~CRAMFS_BLK_FLAGS;\n\t\t\tblock_len = block_ptr - block_start;\n\t\t}\n\n\t\tif (block_len == 0)\n\t\t\t;  \n\t\telse if (unlikely(block_len > 2*PAGE_SIZE ||\n\t\t\t\t  (uncompressed && block_len > PAGE_SIZE))) {\n\t\t\tmutex_unlock(&read_mutex);\n\t\t\tpr_err(\"bad data blocksize %u\\n\", block_len);\n\t\t\tgoto err;\n\t\t} else if (uncompressed) {\n\t\t\tmemcpy(pgdata,\n\t\t\t       cramfs_read(sb, block_start, block_len),\n\t\t\t       block_len);\n\t\t\tbytes_filled = block_len;\n\t\t} else {\n\t\t\tbytes_filled = cramfs_uncompress_block(pgdata,\n\t\t\t\t PAGE_SIZE,\n\t\t\t\t cramfs_read(sb, block_start, block_len),\n\t\t\t\t block_len);\n\t\t}\n\t\tmutex_unlock(&read_mutex);\n\t\tif (unlikely(bytes_filled < 0))\n\t\t\tgoto err;\n\t}\n\n\tmemset(pgdata + bytes_filled, 0, PAGE_SIZE - bytes_filled);\n\tflush_dcache_page(page);\n\tkunmap_local(pgdata);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn 0;\n\nerr:\n\tkunmap_local(pgdata);\n\tClearPageUptodate(page);\n\tSetPageError(page);\n\tunlock_page(page);\n\treturn 0;\n}\n\nstatic const struct address_space_operations cramfs_aops = {\n\t.read_folio = cramfs_read_folio\n};\n\n \n\n \nstatic const struct file_operations cramfs_directory_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= cramfs_readdir,\n};\n\nstatic const struct inode_operations cramfs_dir_inode_operations = {\n\t.lookup\t\t= cramfs_lookup,\n};\n\nstatic const struct super_operations cramfs_ops = {\n\t.statfs\t\t= cramfs_statfs,\n};\n\nstatic int cramfs_get_tree(struct fs_context *fc)\n{\n\tint ret = -ENOPROTOOPT;\n\n\tif (IS_ENABLED(CONFIG_CRAMFS_MTD)) {\n\t\tret = get_tree_mtd(fc, cramfs_mtd_fill_super);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\tif (IS_ENABLED(CONFIG_CRAMFS_BLOCKDEV))\n\t\tret = get_tree_bdev(fc, cramfs_blkdev_fill_super);\n\treturn ret;\n}\n\nstatic const struct fs_context_operations cramfs_context_ops = {\n\t.get_tree\t= cramfs_get_tree,\n\t.reconfigure\t= cramfs_reconfigure,\n};\n\n \nstatic int cramfs_init_fs_context(struct fs_context *fc)\n{\n\tfc->ops = &cramfs_context_ops;\n\treturn 0;\n}\n\nstatic struct file_system_type cramfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"cramfs\",\n\t.init_fs_context = cramfs_init_fs_context,\n\t.kill_sb\t= cramfs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"cramfs\");\n\nstatic int __init init_cramfs_fs(void)\n{\n\tint rv;\n\n\trv = cramfs_uncompress_init();\n\tif (rv < 0)\n\t\treturn rv;\n\trv = register_filesystem(&cramfs_fs_type);\n\tif (rv < 0)\n\t\tcramfs_uncompress_exit();\n\treturn rv;\n}\n\nstatic void __exit exit_cramfs_fs(void)\n{\n\tcramfs_uncompress_exit();\n\tunregister_filesystem(&cramfs_fs_type);\n}\n\nmodule_init(init_cramfs_fs)\nmodule_exit(exit_cramfs_fs)\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}