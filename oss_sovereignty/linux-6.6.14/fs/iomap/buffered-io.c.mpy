{
  "module_name": "buffered-io.c",
  "hash_id": "591ad435c0d71b7985bbac2fd8dbda103c5104f48409c436edc7ca150c02aa81",
  "original_prompt": "Ingested from linux-6.6.14/fs/iomap/buffered-io.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/fs.h>\n#include <linux/iomap.h>\n#include <linux/pagemap.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/writeback.h>\n#include <linux/list_sort.h>\n#include <linux/swap.h>\n#include <linux/bio.h>\n#include <linux/sched/signal.h>\n#include <linux/migrate.h>\n#include \"trace.h\"\n\n#include \"../internal.h\"\n\n#define IOEND_BATCH_SIZE\t4096\n\ntypedef int (*iomap_punch_t)(struct inode *inode, loff_t offset, loff_t length);\n \nstruct iomap_folio_state {\n\tatomic_t\t\tread_bytes_pending;\n\tatomic_t\t\twrite_bytes_pending;\n\tspinlock_t\t\tstate_lock;\n\n\t \n\tunsigned long\t\tstate[];\n};\n\nstatic struct bio_set iomap_ioend_bioset;\n\nstatic inline bool ifs_is_fully_uptodate(struct folio *folio,\n\t\tstruct iomap_folio_state *ifs)\n{\n\tstruct inode *inode = folio->mapping->host;\n\n\treturn bitmap_full(ifs->state, i_blocks_per_folio(inode, folio));\n}\n\nstatic inline bool ifs_block_is_uptodate(struct iomap_folio_state *ifs,\n\t\tunsigned int block)\n{\n\treturn test_bit(block, ifs->state);\n}\n\nstatic void ifs_set_range_uptodate(struct folio *folio,\n\t\tstruct iomap_folio_state *ifs, size_t off, size_t len)\n{\n\tstruct inode *inode = folio->mapping->host;\n\tunsigned int first_blk = off >> inode->i_blkbits;\n\tunsigned int last_blk = (off + len - 1) >> inode->i_blkbits;\n\tunsigned int nr_blks = last_blk - first_blk + 1;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ifs->state_lock, flags);\n\tbitmap_set(ifs->state, first_blk, nr_blks);\n\tif (ifs_is_fully_uptodate(folio, ifs))\n\t\tfolio_mark_uptodate(folio);\n\tspin_unlock_irqrestore(&ifs->state_lock, flags);\n}\n\nstatic void iomap_set_range_uptodate(struct folio *folio, size_t off,\n\t\tsize_t len)\n{\n\tstruct iomap_folio_state *ifs = folio->private;\n\n\tif (ifs)\n\t\tifs_set_range_uptodate(folio, ifs, off, len);\n\telse\n\t\tfolio_mark_uptodate(folio);\n}\n\nstatic inline bool ifs_block_is_dirty(struct folio *folio,\n\t\tstruct iomap_folio_state *ifs, int block)\n{\n\tstruct inode *inode = folio->mapping->host;\n\tunsigned int blks_per_folio = i_blocks_per_folio(inode, folio);\n\n\treturn test_bit(block + blks_per_folio, ifs->state);\n}\n\nstatic void ifs_clear_range_dirty(struct folio *folio,\n\t\tstruct iomap_folio_state *ifs, size_t off, size_t len)\n{\n\tstruct inode *inode = folio->mapping->host;\n\tunsigned int blks_per_folio = i_blocks_per_folio(inode, folio);\n\tunsigned int first_blk = (off >> inode->i_blkbits);\n\tunsigned int last_blk = (off + len - 1) >> inode->i_blkbits;\n\tunsigned int nr_blks = last_blk - first_blk + 1;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ifs->state_lock, flags);\n\tbitmap_clear(ifs->state, first_blk + blks_per_folio, nr_blks);\n\tspin_unlock_irqrestore(&ifs->state_lock, flags);\n}\n\nstatic void iomap_clear_range_dirty(struct folio *folio, size_t off, size_t len)\n{\n\tstruct iomap_folio_state *ifs = folio->private;\n\n\tif (ifs)\n\t\tifs_clear_range_dirty(folio, ifs, off, len);\n}\n\nstatic void ifs_set_range_dirty(struct folio *folio,\n\t\tstruct iomap_folio_state *ifs, size_t off, size_t len)\n{\n\tstruct inode *inode = folio->mapping->host;\n\tunsigned int blks_per_folio = i_blocks_per_folio(inode, folio);\n\tunsigned int first_blk = (off >> inode->i_blkbits);\n\tunsigned int last_blk = (off + len - 1) >> inode->i_blkbits;\n\tunsigned int nr_blks = last_blk - first_blk + 1;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ifs->state_lock, flags);\n\tbitmap_set(ifs->state, first_blk + blks_per_folio, nr_blks);\n\tspin_unlock_irqrestore(&ifs->state_lock, flags);\n}\n\nstatic void iomap_set_range_dirty(struct folio *folio, size_t off, size_t len)\n{\n\tstruct iomap_folio_state *ifs = folio->private;\n\n\tif (ifs)\n\t\tifs_set_range_dirty(folio, ifs, off, len);\n}\n\nstatic struct iomap_folio_state *ifs_alloc(struct inode *inode,\n\t\tstruct folio *folio, unsigned int flags)\n{\n\tstruct iomap_folio_state *ifs = folio->private;\n\tunsigned int nr_blocks = i_blocks_per_folio(inode, folio);\n\tgfp_t gfp;\n\n\tif (ifs || nr_blocks <= 1)\n\t\treturn ifs;\n\n\tif (flags & IOMAP_NOWAIT)\n\t\tgfp = GFP_NOWAIT;\n\telse\n\t\tgfp = GFP_NOFS | __GFP_NOFAIL;\n\n\t \n\tifs = kzalloc(struct_size(ifs, state,\n\t\t      BITS_TO_LONGS(2 * nr_blocks)), gfp);\n\tif (!ifs)\n\t\treturn ifs;\n\n\tspin_lock_init(&ifs->state_lock);\n\tif (folio_test_uptodate(folio))\n\t\tbitmap_set(ifs->state, 0, nr_blocks);\n\tif (folio_test_dirty(folio))\n\t\tbitmap_set(ifs->state, nr_blocks, nr_blocks);\n\tfolio_attach_private(folio, ifs);\n\n\treturn ifs;\n}\n\nstatic void ifs_free(struct folio *folio)\n{\n\tstruct iomap_folio_state *ifs = folio_detach_private(folio);\n\n\tif (!ifs)\n\t\treturn;\n\tWARN_ON_ONCE(atomic_read(&ifs->read_bytes_pending));\n\tWARN_ON_ONCE(atomic_read(&ifs->write_bytes_pending));\n\tWARN_ON_ONCE(ifs_is_fully_uptodate(folio, ifs) !=\n\t\t\tfolio_test_uptodate(folio));\n\tkfree(ifs);\n}\n\n \nstatic void iomap_adjust_read_range(struct inode *inode, struct folio *folio,\n\t\tloff_t *pos, loff_t length, size_t *offp, size_t *lenp)\n{\n\tstruct iomap_folio_state *ifs = folio->private;\n\tloff_t orig_pos = *pos;\n\tloff_t isize = i_size_read(inode);\n\tunsigned block_bits = inode->i_blkbits;\n\tunsigned block_size = (1 << block_bits);\n\tsize_t poff = offset_in_folio(folio, *pos);\n\tsize_t plen = min_t(loff_t, folio_size(folio) - poff, length);\n\tunsigned first = poff >> block_bits;\n\tunsigned last = (poff + plen - 1) >> block_bits;\n\n\t \n\tif (ifs) {\n\t\tunsigned int i;\n\n\t\t \n\t\tfor (i = first; i <= last; i++) {\n\t\t\tif (!ifs_block_is_uptodate(ifs, i))\n\t\t\t\tbreak;\n\t\t\t*pos += block_size;\n\t\t\tpoff += block_size;\n\t\t\tplen -= block_size;\n\t\t\tfirst++;\n\t\t}\n\n\t\t \n\t\tfor ( ; i <= last; i++) {\n\t\t\tif (ifs_block_is_uptodate(ifs, i)) {\n\t\t\t\tplen -= (last - i + 1) * block_size;\n\t\t\t\tlast = i - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (orig_pos <= isize && orig_pos + length > isize) {\n\t\tunsigned end = offset_in_folio(folio, isize - 1) >> block_bits;\n\n\t\tif (first <= end && last > end)\n\t\t\tplen -= (last - end) * block_size;\n\t}\n\n\t*offp = poff;\n\t*lenp = plen;\n}\n\nstatic void iomap_finish_folio_read(struct folio *folio, size_t offset,\n\t\tsize_t len, int error)\n{\n\tstruct iomap_folio_state *ifs = folio->private;\n\n\tif (unlikely(error)) {\n\t\tfolio_clear_uptodate(folio);\n\t\tfolio_set_error(folio);\n\t} else {\n\t\tiomap_set_range_uptodate(folio, offset, len);\n\t}\n\n\tif (!ifs || atomic_sub_and_test(len, &ifs->read_bytes_pending))\n\t\tfolio_unlock(folio);\n}\n\nstatic void iomap_read_end_io(struct bio *bio)\n{\n\tint error = blk_status_to_errno(bio->bi_status);\n\tstruct folio_iter fi;\n\n\tbio_for_each_folio_all(fi, bio)\n\t\tiomap_finish_folio_read(fi.folio, fi.offset, fi.length, error);\n\tbio_put(bio);\n}\n\nstruct iomap_readpage_ctx {\n\tstruct folio\t\t*cur_folio;\n\tbool\t\t\tcur_folio_in_bio;\n\tstruct bio\t\t*bio;\n\tstruct readahead_control *rac;\n};\n\n \nstatic int iomap_read_inline_data(const struct iomap_iter *iter,\n\t\tstruct folio *folio)\n{\n\tconst struct iomap *iomap = iomap_iter_srcmap(iter);\n\tsize_t size = i_size_read(iter->inode) - iomap->offset;\n\tsize_t poff = offset_in_page(iomap->offset);\n\tsize_t offset = offset_in_folio(folio, iomap->offset);\n\tvoid *addr;\n\n\tif (folio_test_uptodate(folio))\n\t\treturn 0;\n\n\tif (WARN_ON_ONCE(size > PAGE_SIZE - poff))\n\t\treturn -EIO;\n\tif (WARN_ON_ONCE(size > PAGE_SIZE -\n\t\t\t offset_in_page(iomap->inline_data)))\n\t\treturn -EIO;\n\tif (WARN_ON_ONCE(size > iomap->length))\n\t\treturn -EIO;\n\tif (offset > 0)\n\t\tifs_alloc(iter->inode, folio, iter->flags);\n\n\taddr = kmap_local_folio(folio, offset);\n\tmemcpy(addr, iomap->inline_data, size);\n\tmemset(addr + size, 0, PAGE_SIZE - poff - size);\n\tkunmap_local(addr);\n\tiomap_set_range_uptodate(folio, offset, PAGE_SIZE - poff);\n\treturn 0;\n}\n\nstatic inline bool iomap_block_needs_zeroing(const struct iomap_iter *iter,\n\t\tloff_t pos)\n{\n\tconst struct iomap *srcmap = iomap_iter_srcmap(iter);\n\n\treturn srcmap->type != IOMAP_MAPPED ||\n\t\t(srcmap->flags & IOMAP_F_NEW) ||\n\t\tpos >= i_size_read(iter->inode);\n}\n\nstatic loff_t iomap_readpage_iter(const struct iomap_iter *iter,\n\t\tstruct iomap_readpage_ctx *ctx, loff_t offset)\n{\n\tconst struct iomap *iomap = &iter->iomap;\n\tloff_t pos = iter->pos + offset;\n\tloff_t length = iomap_length(iter) - offset;\n\tstruct folio *folio = ctx->cur_folio;\n\tstruct iomap_folio_state *ifs;\n\tloff_t orig_pos = pos;\n\tsize_t poff, plen;\n\tsector_t sector;\n\n\tif (iomap->type == IOMAP_INLINE)\n\t\treturn iomap_read_inline_data(iter, folio);\n\n\t \n\tifs = ifs_alloc(iter->inode, folio, iter->flags);\n\tiomap_adjust_read_range(iter->inode, folio, &pos, length, &poff, &plen);\n\tif (plen == 0)\n\t\tgoto done;\n\n\tif (iomap_block_needs_zeroing(iter, pos)) {\n\t\tfolio_zero_range(folio, poff, plen);\n\t\tiomap_set_range_uptodate(folio, poff, plen);\n\t\tgoto done;\n\t}\n\n\tctx->cur_folio_in_bio = true;\n\tif (ifs)\n\t\tatomic_add(plen, &ifs->read_bytes_pending);\n\n\tsector = iomap_sector(iomap, pos);\n\tif (!ctx->bio ||\n\t    bio_end_sector(ctx->bio) != sector ||\n\t    !bio_add_folio(ctx->bio, folio, plen, poff)) {\n\t\tgfp_t gfp = mapping_gfp_constraint(folio->mapping, GFP_KERNEL);\n\t\tgfp_t orig_gfp = gfp;\n\t\tunsigned int nr_vecs = DIV_ROUND_UP(length, PAGE_SIZE);\n\n\t\tif (ctx->bio)\n\t\t\tsubmit_bio(ctx->bio);\n\n\t\tif (ctx->rac)  \n\t\t\tgfp |= __GFP_NORETRY | __GFP_NOWARN;\n\t\tctx->bio = bio_alloc(iomap->bdev, bio_max_segs(nr_vecs),\n\t\t\t\t     REQ_OP_READ, gfp);\n\t\t \n\t\tif (!ctx->bio) {\n\t\t\tctx->bio = bio_alloc(iomap->bdev, 1, REQ_OP_READ,\n\t\t\t\t\t     orig_gfp);\n\t\t}\n\t\tif (ctx->rac)\n\t\t\tctx->bio->bi_opf |= REQ_RAHEAD;\n\t\tctx->bio->bi_iter.bi_sector = sector;\n\t\tctx->bio->bi_end_io = iomap_read_end_io;\n\t\tbio_add_folio_nofail(ctx->bio, folio, plen, poff);\n\t}\n\ndone:\n\t \n\treturn pos - orig_pos + plen;\n}\n\nint iomap_read_folio(struct folio *folio, const struct iomap_ops *ops)\n{\n\tstruct iomap_iter iter = {\n\t\t.inode\t\t= folio->mapping->host,\n\t\t.pos\t\t= folio_pos(folio),\n\t\t.len\t\t= folio_size(folio),\n\t};\n\tstruct iomap_readpage_ctx ctx = {\n\t\t.cur_folio\t= folio,\n\t};\n\tint ret;\n\n\ttrace_iomap_readpage(iter.inode, 1);\n\n\twhile ((ret = iomap_iter(&iter, ops)) > 0)\n\t\titer.processed = iomap_readpage_iter(&iter, &ctx, 0);\n\n\tif (ret < 0)\n\t\tfolio_set_error(folio);\n\n\tif (ctx.bio) {\n\t\tsubmit_bio(ctx.bio);\n\t\tWARN_ON_ONCE(!ctx.cur_folio_in_bio);\n\t} else {\n\t\tWARN_ON_ONCE(ctx.cur_folio_in_bio);\n\t\tfolio_unlock(folio);\n\t}\n\n\t \n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(iomap_read_folio);\n\nstatic loff_t iomap_readahead_iter(const struct iomap_iter *iter,\n\t\tstruct iomap_readpage_ctx *ctx)\n{\n\tloff_t length = iomap_length(iter);\n\tloff_t done, ret;\n\n\tfor (done = 0; done < length; done += ret) {\n\t\tif (ctx->cur_folio &&\n\t\t    offset_in_folio(ctx->cur_folio, iter->pos + done) == 0) {\n\t\t\tif (!ctx->cur_folio_in_bio)\n\t\t\t\tfolio_unlock(ctx->cur_folio);\n\t\t\tctx->cur_folio = NULL;\n\t\t}\n\t\tif (!ctx->cur_folio) {\n\t\t\tctx->cur_folio = readahead_folio(ctx->rac);\n\t\t\tctx->cur_folio_in_bio = false;\n\t\t}\n\t\tret = iomap_readpage_iter(iter, ctx, done);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\t}\n\n\treturn done;\n}\n\n \nvoid iomap_readahead(struct readahead_control *rac, const struct iomap_ops *ops)\n{\n\tstruct iomap_iter iter = {\n\t\t.inode\t= rac->mapping->host,\n\t\t.pos\t= readahead_pos(rac),\n\t\t.len\t= readahead_length(rac),\n\t};\n\tstruct iomap_readpage_ctx ctx = {\n\t\t.rac\t= rac,\n\t};\n\n\ttrace_iomap_readahead(rac->mapping->host, readahead_count(rac));\n\n\twhile (iomap_iter(&iter, ops) > 0)\n\t\titer.processed = iomap_readahead_iter(&iter, &ctx);\n\n\tif (ctx.bio)\n\t\tsubmit_bio(ctx.bio);\n\tif (ctx.cur_folio) {\n\t\tif (!ctx.cur_folio_in_bio)\n\t\t\tfolio_unlock(ctx.cur_folio);\n\t}\n}\nEXPORT_SYMBOL_GPL(iomap_readahead);\n\n \nbool iomap_is_partially_uptodate(struct folio *folio, size_t from, size_t count)\n{\n\tstruct iomap_folio_state *ifs = folio->private;\n\tstruct inode *inode = folio->mapping->host;\n\tunsigned first, last, i;\n\n\tif (!ifs)\n\t\treturn false;\n\n\t \n\tcount = min(folio_size(folio) - from, count);\n\n\t \n\tfirst = from >> inode->i_blkbits;\n\tlast = (from + count - 1) >> inode->i_blkbits;\n\n\tfor (i = first; i <= last; i++)\n\t\tif (!ifs_block_is_uptodate(ifs, i))\n\t\t\treturn false;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(iomap_is_partially_uptodate);\n\n \nstruct folio *iomap_get_folio(struct iomap_iter *iter, loff_t pos, size_t len)\n{\n\tfgf_t fgp = FGP_WRITEBEGIN | FGP_NOFS;\n\n\tif (iter->flags & IOMAP_NOWAIT)\n\t\tfgp |= FGP_NOWAIT;\n\tfgp |= fgf_set_order(len);\n\n\treturn __filemap_get_folio(iter->inode->i_mapping, pos >> PAGE_SHIFT,\n\t\t\tfgp, mapping_gfp_mask(iter->inode->i_mapping));\n}\nEXPORT_SYMBOL_GPL(iomap_get_folio);\n\nbool iomap_release_folio(struct folio *folio, gfp_t gfp_flags)\n{\n\ttrace_iomap_release_folio(folio->mapping->host, folio_pos(folio),\n\t\t\tfolio_size(folio));\n\n\t \n\tif (folio_test_dirty(folio))\n\t\treturn false;\n\tifs_free(folio);\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(iomap_release_folio);\n\nvoid iomap_invalidate_folio(struct folio *folio, size_t offset, size_t len)\n{\n\ttrace_iomap_invalidate_folio(folio->mapping->host,\n\t\t\t\t\tfolio_pos(folio) + offset, len);\n\n\t \n\tif (offset == 0 && len == folio_size(folio)) {\n\t\tWARN_ON_ONCE(folio_test_writeback(folio));\n\t\tfolio_cancel_dirty(folio);\n\t\tifs_free(folio);\n\t}\n}\nEXPORT_SYMBOL_GPL(iomap_invalidate_folio);\n\nbool iomap_dirty_folio(struct address_space *mapping, struct folio *folio)\n{\n\tstruct inode *inode = mapping->host;\n\tsize_t len = folio_size(folio);\n\n\tifs_alloc(inode, folio, 0);\n\tiomap_set_range_dirty(folio, 0, len);\n\treturn filemap_dirty_folio(mapping, folio);\n}\nEXPORT_SYMBOL_GPL(iomap_dirty_folio);\n\nstatic void\niomap_write_failed(struct inode *inode, loff_t pos, unsigned len)\n{\n\tloff_t i_size = i_size_read(inode);\n\n\t \n\tif (pos + len > i_size)\n\t\ttruncate_pagecache_range(inode, max(pos, i_size),\n\t\t\t\t\t pos + len - 1);\n}\n\nstatic int iomap_read_folio_sync(loff_t block_start, struct folio *folio,\n\t\tsize_t poff, size_t plen, const struct iomap *iomap)\n{\n\tstruct bio_vec bvec;\n\tstruct bio bio;\n\n\tbio_init(&bio, iomap->bdev, &bvec, 1, REQ_OP_READ);\n\tbio.bi_iter.bi_sector = iomap_sector(iomap, block_start);\n\tbio_add_folio_nofail(&bio, folio, plen, poff);\n\treturn submit_bio_wait(&bio);\n}\n\nstatic int __iomap_write_begin(const struct iomap_iter *iter, loff_t pos,\n\t\tsize_t len, struct folio *folio)\n{\n\tconst struct iomap *srcmap = iomap_iter_srcmap(iter);\n\tstruct iomap_folio_state *ifs;\n\tloff_t block_size = i_blocksize(iter->inode);\n\tloff_t block_start = round_down(pos, block_size);\n\tloff_t block_end = round_up(pos + len, block_size);\n\tunsigned int nr_blocks = i_blocks_per_folio(iter->inode, folio);\n\tsize_t from = offset_in_folio(folio, pos), to = from + len;\n\tsize_t poff, plen;\n\n\t \n\tif (!(iter->flags & IOMAP_UNSHARE) && pos <= folio_pos(folio) &&\n\t    pos + len >= folio_pos(folio) + folio_size(folio))\n\t\treturn 0;\n\n\tifs = ifs_alloc(iter->inode, folio, iter->flags);\n\tif ((iter->flags & IOMAP_NOWAIT) && !ifs && nr_blocks > 1)\n\t\treturn -EAGAIN;\n\n\tif (folio_test_uptodate(folio))\n\t\treturn 0;\n\tfolio_clear_error(folio);\n\n\tdo {\n\t\tiomap_adjust_read_range(iter->inode, folio, &block_start,\n\t\t\t\tblock_end - block_start, &poff, &plen);\n\t\tif (plen == 0)\n\t\t\tbreak;\n\n\t\tif (!(iter->flags & IOMAP_UNSHARE) &&\n\t\t    (from <= poff || from >= poff + plen) &&\n\t\t    (to <= poff || to >= poff + plen))\n\t\t\tcontinue;\n\n\t\tif (iomap_block_needs_zeroing(iter, block_start)) {\n\t\t\tif (WARN_ON_ONCE(iter->flags & IOMAP_UNSHARE))\n\t\t\t\treturn -EIO;\n\t\t\tfolio_zero_segments(folio, poff, from, to, poff + plen);\n\t\t} else {\n\t\t\tint status;\n\n\t\t\tif (iter->flags & IOMAP_NOWAIT)\n\t\t\t\treturn -EAGAIN;\n\n\t\t\tstatus = iomap_read_folio_sync(block_start, folio,\n\t\t\t\t\tpoff, plen, srcmap);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t\tiomap_set_range_uptodate(folio, poff, plen);\n\t} while ((block_start += plen) < block_end);\n\n\treturn 0;\n}\n\nstatic struct folio *__iomap_get_folio(struct iomap_iter *iter, loff_t pos,\n\t\tsize_t len)\n{\n\tconst struct iomap_folio_ops *folio_ops = iter->iomap.folio_ops;\n\n\tif (folio_ops && folio_ops->get_folio)\n\t\treturn folio_ops->get_folio(iter, pos, len);\n\telse\n\t\treturn iomap_get_folio(iter, pos, len);\n}\n\nstatic void __iomap_put_folio(struct iomap_iter *iter, loff_t pos, size_t ret,\n\t\tstruct folio *folio)\n{\n\tconst struct iomap_folio_ops *folio_ops = iter->iomap.folio_ops;\n\n\tif (folio_ops && folio_ops->put_folio) {\n\t\tfolio_ops->put_folio(iter->inode, pos, ret, folio);\n\t} else {\n\t\tfolio_unlock(folio);\n\t\tfolio_put(folio);\n\t}\n}\n\nstatic int iomap_write_begin_inline(const struct iomap_iter *iter,\n\t\tstruct folio *folio)\n{\n\t \n\tif (WARN_ON_ONCE(iomap_iter_srcmap(iter)->offset != 0))\n\t\treturn -EIO;\n\treturn iomap_read_inline_data(iter, folio);\n}\n\nstatic int iomap_write_begin(struct iomap_iter *iter, loff_t pos,\n\t\tsize_t len, struct folio **foliop)\n{\n\tconst struct iomap_folio_ops *folio_ops = iter->iomap.folio_ops;\n\tconst struct iomap *srcmap = iomap_iter_srcmap(iter);\n\tstruct folio *folio;\n\tint status = 0;\n\n\tBUG_ON(pos + len > iter->iomap.offset + iter->iomap.length);\n\tif (srcmap != &iter->iomap)\n\t\tBUG_ON(pos + len > srcmap->offset + srcmap->length);\n\n\tif (fatal_signal_pending(current))\n\t\treturn -EINTR;\n\n\tif (!mapping_large_folio_support(iter->inode->i_mapping))\n\t\tlen = min_t(size_t, len, PAGE_SIZE - offset_in_page(pos));\n\n\tfolio = __iomap_get_folio(iter, pos, len);\n\tif (IS_ERR(folio))\n\t\treturn PTR_ERR(folio);\n\n\t \n\tif (folio_ops && folio_ops->iomap_valid) {\n\t\tbool iomap_valid = folio_ops->iomap_valid(iter->inode,\n\t\t\t\t\t\t\t &iter->iomap);\n\t\tif (!iomap_valid) {\n\t\t\titer->iomap.flags |= IOMAP_F_STALE;\n\t\t\tstatus = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (pos + len > folio_pos(folio) + folio_size(folio))\n\t\tlen = folio_pos(folio) + folio_size(folio) - pos;\n\n\tif (srcmap->type == IOMAP_INLINE)\n\t\tstatus = iomap_write_begin_inline(iter, folio);\n\telse if (srcmap->flags & IOMAP_F_BUFFER_HEAD)\n\t\tstatus = __block_write_begin_int(folio, pos, len, NULL, srcmap);\n\telse\n\t\tstatus = __iomap_write_begin(iter, pos, len, folio);\n\n\tif (unlikely(status))\n\t\tgoto out_unlock;\n\n\t*foliop = folio;\n\treturn 0;\n\nout_unlock:\n\t__iomap_put_folio(iter, pos, 0, folio);\n\tiomap_write_failed(iter->inode, pos, len);\n\n\treturn status;\n}\n\nstatic size_t __iomap_write_end(struct inode *inode, loff_t pos, size_t len,\n\t\tsize_t copied, struct folio *folio)\n{\n\tflush_dcache_folio(folio);\n\n\t \n\tif (unlikely(copied < len && !folio_test_uptodate(folio)))\n\t\treturn 0;\n\tiomap_set_range_uptodate(folio, offset_in_folio(folio, pos), len);\n\tiomap_set_range_dirty(folio, offset_in_folio(folio, pos), copied);\n\tfilemap_dirty_folio(inode->i_mapping, folio);\n\treturn copied;\n}\n\nstatic size_t iomap_write_end_inline(const struct iomap_iter *iter,\n\t\tstruct folio *folio, loff_t pos, size_t copied)\n{\n\tconst struct iomap *iomap = &iter->iomap;\n\tvoid *addr;\n\n\tWARN_ON_ONCE(!folio_test_uptodate(folio));\n\tBUG_ON(!iomap_inline_data_valid(iomap));\n\n\tflush_dcache_folio(folio);\n\taddr = kmap_local_folio(folio, pos);\n\tmemcpy(iomap_inline_data(iomap, pos), addr, copied);\n\tkunmap_local(addr);\n\n\tmark_inode_dirty(iter->inode);\n\treturn copied;\n}\n\n \nstatic size_t iomap_write_end(struct iomap_iter *iter, loff_t pos, size_t len,\n\t\tsize_t copied, struct folio *folio)\n{\n\tconst struct iomap *srcmap = iomap_iter_srcmap(iter);\n\tloff_t old_size = iter->inode->i_size;\n\tsize_t ret;\n\n\tif (srcmap->type == IOMAP_INLINE) {\n\t\tret = iomap_write_end_inline(iter, folio, pos, copied);\n\t} else if (srcmap->flags & IOMAP_F_BUFFER_HEAD) {\n\t\tret = block_write_end(NULL, iter->inode->i_mapping, pos, len,\n\t\t\t\tcopied, &folio->page, NULL);\n\t} else {\n\t\tret = __iomap_write_end(iter->inode, pos, len, copied, folio);\n\t}\n\n\t \n\tif (pos + ret > old_size) {\n\t\ti_size_write(iter->inode, pos + ret);\n\t\titer->iomap.flags |= IOMAP_F_SIZE_CHANGED;\n\t}\n\t__iomap_put_folio(iter, pos, ret, folio);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(iter->inode, old_size, pos);\n\tif (ret < len)\n\t\tiomap_write_failed(iter->inode, pos + ret, len - ret);\n\treturn ret;\n}\n\nstatic loff_t iomap_write_iter(struct iomap_iter *iter, struct iov_iter *i)\n{\n\tloff_t length = iomap_length(iter);\n\tsize_t chunk = PAGE_SIZE << MAX_PAGECACHE_ORDER;\n\tloff_t pos = iter->pos;\n\tssize_t written = 0;\n\tlong status = 0;\n\tstruct address_space *mapping = iter->inode->i_mapping;\n\tunsigned int bdp_flags = (iter->flags & IOMAP_NOWAIT) ? BDP_ASYNC : 0;\n\n\tdo {\n\t\tstruct folio *folio;\n\t\tsize_t offset;\t\t \n\t\tsize_t bytes;\t\t \n\t\tsize_t copied;\t\t \n\n\t\tbytes = iov_iter_count(i);\nretry:\n\t\toffset = pos & (chunk - 1);\n\t\tbytes = min(chunk - offset, bytes);\n\t\tstatus = balance_dirty_pages_ratelimited_flags(mapping,\n\t\t\t\t\t\t\t       bdp_flags);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\n\t\tif (bytes > length)\n\t\t\tbytes = length;\n\n\t\t \n\t\tif (unlikely(fault_in_iov_iter_readable(i, bytes) == bytes)) {\n\t\t\tstatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = iomap_write_begin(iter, pos, bytes, &folio);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\t\tif (iter->iomap.flags & IOMAP_F_STALE)\n\t\t\tbreak;\n\n\t\toffset = offset_in_folio(folio, pos);\n\t\tif (bytes > folio_size(folio) - offset)\n\t\t\tbytes = folio_size(folio) - offset;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_folio(folio);\n\n\t\tcopied = copy_folio_from_iter_atomic(folio, offset, bytes, i);\n\t\tstatus = iomap_write_end(iter, pos, bytes, copied, folio);\n\n\t\tif (unlikely(copied != status))\n\t\t\tiov_iter_revert(i, copied - status);\n\n\t\tcond_resched();\n\t\tif (unlikely(status == 0)) {\n\t\t\t \n\t\t\tif (chunk > PAGE_SIZE)\n\t\t\t\tchunk /= 2;\n\t\t\tif (copied) {\n\t\t\t\tbytes = copied;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t} else {\n\t\t\tpos += status;\n\t\t\twritten += status;\n\t\t\tlength -= status;\n\t\t}\n\t} while (iov_iter_count(i) && length);\n\n\tif (status == -EAGAIN) {\n\t\tiov_iter_revert(i, written);\n\t\treturn -EAGAIN;\n\t}\n\treturn written ? written : status;\n}\n\nssize_t\niomap_file_buffered_write(struct kiocb *iocb, struct iov_iter *i,\n\t\tconst struct iomap_ops *ops)\n{\n\tstruct iomap_iter iter = {\n\t\t.inode\t\t= iocb->ki_filp->f_mapping->host,\n\t\t.pos\t\t= iocb->ki_pos,\n\t\t.len\t\t= iov_iter_count(i),\n\t\t.flags\t\t= IOMAP_WRITE,\n\t};\n\tssize_t ret;\n\n\tif (iocb->ki_flags & IOCB_NOWAIT)\n\t\titer.flags |= IOMAP_NOWAIT;\n\n\twhile ((ret = iomap_iter(&iter, ops)) > 0)\n\t\titer.processed = iomap_write_iter(&iter, i);\n\n\tif (unlikely(iter.pos == iocb->ki_pos))\n\t\treturn ret;\n\tret = iter.pos - iocb->ki_pos;\n\tiocb->ki_pos = iter.pos;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iomap_file_buffered_write);\n\nstatic int iomap_write_delalloc_ifs_punch(struct inode *inode,\n\t\tstruct folio *folio, loff_t start_byte, loff_t end_byte,\n\t\tiomap_punch_t punch)\n{\n\tunsigned int first_blk, last_blk, i;\n\tloff_t last_byte;\n\tu8 blkbits = inode->i_blkbits;\n\tstruct iomap_folio_state *ifs;\n\tint ret = 0;\n\n\t \n\tifs = folio->private;\n\tif (!ifs)\n\t\treturn ret;\n\n\tlast_byte = min_t(loff_t, end_byte - 1,\n\t\t\tfolio_pos(folio) + folio_size(folio) - 1);\n\tfirst_blk = offset_in_folio(folio, start_byte) >> blkbits;\n\tlast_blk = offset_in_folio(folio, last_byte) >> blkbits;\n\tfor (i = first_blk; i <= last_blk; i++) {\n\t\tif (!ifs_block_is_dirty(folio, ifs, i)) {\n\t\t\tret = punch(inode, folio_pos(folio) + (i << blkbits),\n\t\t\t\t    1 << blkbits);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nstatic int iomap_write_delalloc_punch(struct inode *inode, struct folio *folio,\n\t\tloff_t *punch_start_byte, loff_t start_byte, loff_t end_byte,\n\t\tiomap_punch_t punch)\n{\n\tint ret = 0;\n\n\tif (!folio_test_dirty(folio))\n\t\treturn ret;\n\n\t \n\tif (start_byte > *punch_start_byte) {\n\t\tret = punch(inode, *punch_start_byte,\n\t\t\t\tstart_byte - *punch_start_byte);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = iomap_write_delalloc_ifs_punch(inode, folio, start_byte,\n\t\t\tend_byte, punch);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*punch_start_byte = min_t(loff_t, end_byte,\n\t\t\t\tfolio_pos(folio) + folio_size(folio));\n\n\treturn ret;\n}\n\n \nstatic int iomap_write_delalloc_scan(struct inode *inode,\n\t\tloff_t *punch_start_byte, loff_t start_byte, loff_t end_byte,\n\t\tiomap_punch_t punch)\n{\n\twhile (start_byte < end_byte) {\n\t\tstruct folio\t*folio;\n\t\tint ret;\n\n\t\t \n\t\tfolio = filemap_lock_folio(inode->i_mapping,\n\t\t\t\tstart_byte >> PAGE_SHIFT);\n\t\tif (IS_ERR(folio)) {\n\t\t\tstart_byte = ALIGN_DOWN(start_byte, PAGE_SIZE) +\n\t\t\t\t\tPAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = iomap_write_delalloc_punch(inode, folio, punch_start_byte,\n\t\t\t\t\t\t start_byte, end_byte, punch);\n\t\tif (ret) {\n\t\t\tfolio_unlock(folio);\n\t\t\tfolio_put(folio);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tstart_byte = folio_next_index(folio) << PAGE_SHIFT;\n\t\tfolio_unlock(folio);\n\t\tfolio_put(folio);\n\t}\n\treturn 0;\n}\n\n \nstatic int iomap_write_delalloc_release(struct inode *inode,\n\t\tloff_t start_byte, loff_t end_byte, iomap_punch_t punch)\n{\n\tloff_t punch_start_byte = start_byte;\n\tloff_t scan_end_byte = min(i_size_read(inode), end_byte);\n\tint error = 0;\n\n\t \n\tfilemap_invalidate_lock(inode->i_mapping);\n\twhile (start_byte < scan_end_byte) {\n\t\tloff_t\t\tdata_end;\n\n\t\tstart_byte = mapping_seek_hole_data(inode->i_mapping,\n\t\t\t\tstart_byte, scan_end_byte, SEEK_DATA);\n\t\t \n\t\tif (start_byte == -ENXIO || start_byte == scan_end_byte)\n\t\t\tbreak;\n\t\tif (start_byte < 0) {\n\t\t\terror = start_byte;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tWARN_ON_ONCE(start_byte < punch_start_byte);\n\t\tWARN_ON_ONCE(start_byte > scan_end_byte);\n\n\t\t \n\t\tdata_end = mapping_seek_hole_data(inode->i_mapping, start_byte,\n\t\t\t\tscan_end_byte, SEEK_HOLE);\n\t\tif (data_end < 0) {\n\t\t\terror = data_end;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tWARN_ON_ONCE(data_end <= start_byte);\n\t\tWARN_ON_ONCE(data_end > scan_end_byte);\n\n\t\terror = iomap_write_delalloc_scan(inode, &punch_start_byte,\n\t\t\t\tstart_byte, data_end, punch);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\n\t\t \n\t\tstart_byte = data_end;\n\t}\n\n\tif (punch_start_byte < end_byte)\n\t\terror = punch(inode, punch_start_byte,\n\t\t\t\tend_byte - punch_start_byte);\nout_unlock:\n\tfilemap_invalidate_unlock(inode->i_mapping);\n\treturn error;\n}\n\n \nint iomap_file_buffered_write_punch_delalloc(struct inode *inode,\n\t\tstruct iomap *iomap, loff_t pos, loff_t length,\n\t\tssize_t written, iomap_punch_t punch)\n{\n\tloff_t\t\t\tstart_byte;\n\tloff_t\t\t\tend_byte;\n\tunsigned int\t\tblocksize = i_blocksize(inode);\n\n\tif (iomap->type != IOMAP_DELALLOC)\n\t\treturn 0;\n\n\t \n\tif (!(iomap->flags & IOMAP_F_NEW))\n\t\treturn 0;\n\n\t \n\tif (unlikely(!written))\n\t\tstart_byte = round_down(pos, blocksize);\n\telse\n\t\tstart_byte = round_up(pos + written, blocksize);\n\tend_byte = round_up(pos + length, blocksize);\n\n\t \n\tif (start_byte >= end_byte)\n\t\treturn 0;\n\n\treturn iomap_write_delalloc_release(inode, start_byte, end_byte,\n\t\t\t\t\tpunch);\n}\nEXPORT_SYMBOL_GPL(iomap_file_buffered_write_punch_delalloc);\n\nstatic loff_t iomap_unshare_iter(struct iomap_iter *iter)\n{\n\tstruct iomap *iomap = &iter->iomap;\n\tconst struct iomap *srcmap = iomap_iter_srcmap(iter);\n\tloff_t pos = iter->pos;\n\tloff_t length = iomap_length(iter);\n\tloff_t written = 0;\n\n\t \n\tif (!(iomap->flags & IOMAP_F_SHARED))\n\t\treturn length;\n\t \n\tif (srcmap->type == IOMAP_HOLE || srcmap->type == IOMAP_UNWRITTEN)\n\t\treturn length;\n\n\tdo {\n\t\tstruct folio *folio;\n\t\tint status;\n\t\tsize_t offset;\n\t\tsize_t bytes = min_t(u64, SIZE_MAX, length);\n\n\t\tstatus = iomap_write_begin(iter, pos, bytes, &folio);\n\t\tif (unlikely(status))\n\t\t\treturn status;\n\t\tif (iomap->flags & IOMAP_F_STALE)\n\t\t\tbreak;\n\n\t\toffset = offset_in_folio(folio, pos);\n\t\tif (bytes > folio_size(folio) - offset)\n\t\t\tbytes = folio_size(folio) - offset;\n\n\t\tbytes = iomap_write_end(iter, pos, bytes, bytes, folio);\n\t\tif (WARN_ON_ONCE(bytes == 0))\n\t\t\treturn -EIO;\n\n\t\tcond_resched();\n\n\t\tpos += bytes;\n\t\twritten += bytes;\n\t\tlength -= bytes;\n\n\t\tbalance_dirty_pages_ratelimited(iter->inode->i_mapping);\n\t} while (length > 0);\n\n\treturn written;\n}\n\nint\niomap_file_unshare(struct inode *inode, loff_t pos, loff_t len,\n\t\tconst struct iomap_ops *ops)\n{\n\tstruct iomap_iter iter = {\n\t\t.inode\t\t= inode,\n\t\t.pos\t\t= pos,\n\t\t.len\t\t= len,\n\t\t.flags\t\t= IOMAP_WRITE | IOMAP_UNSHARE,\n\t};\n\tint ret;\n\n\twhile ((ret = iomap_iter(&iter, ops)) > 0)\n\t\titer.processed = iomap_unshare_iter(&iter);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iomap_file_unshare);\n\nstatic loff_t iomap_zero_iter(struct iomap_iter *iter, bool *did_zero)\n{\n\tconst struct iomap *srcmap = iomap_iter_srcmap(iter);\n\tloff_t pos = iter->pos;\n\tloff_t length = iomap_length(iter);\n\tloff_t written = 0;\n\n\t \n\tif (srcmap->type == IOMAP_HOLE || srcmap->type == IOMAP_UNWRITTEN)\n\t\treturn length;\n\n\tdo {\n\t\tstruct folio *folio;\n\t\tint status;\n\t\tsize_t offset;\n\t\tsize_t bytes = min_t(u64, SIZE_MAX, length);\n\n\t\tstatus = iomap_write_begin(iter, pos, bytes, &folio);\n\t\tif (status)\n\t\t\treturn status;\n\t\tif (iter->iomap.flags & IOMAP_F_STALE)\n\t\t\tbreak;\n\n\t\toffset = offset_in_folio(folio, pos);\n\t\tif (bytes > folio_size(folio) - offset)\n\t\t\tbytes = folio_size(folio) - offset;\n\n\t\tfolio_zero_range(folio, offset, bytes);\n\t\tfolio_mark_accessed(folio);\n\n\t\tbytes = iomap_write_end(iter, pos, bytes, bytes, folio);\n\t\tif (WARN_ON_ONCE(bytes == 0))\n\t\t\treturn -EIO;\n\n\t\tpos += bytes;\n\t\tlength -= bytes;\n\t\twritten += bytes;\n\t} while (length > 0);\n\n\tif (did_zero)\n\t\t*did_zero = true;\n\treturn written;\n}\n\nint\niomap_zero_range(struct inode *inode, loff_t pos, loff_t len, bool *did_zero,\n\t\tconst struct iomap_ops *ops)\n{\n\tstruct iomap_iter iter = {\n\t\t.inode\t\t= inode,\n\t\t.pos\t\t= pos,\n\t\t.len\t\t= len,\n\t\t.flags\t\t= IOMAP_ZERO,\n\t};\n\tint ret;\n\n\twhile ((ret = iomap_iter(&iter, ops)) > 0)\n\t\titer.processed = iomap_zero_iter(&iter, did_zero);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iomap_zero_range);\n\nint\niomap_truncate_page(struct inode *inode, loff_t pos, bool *did_zero,\n\t\tconst struct iomap_ops *ops)\n{\n\tunsigned int blocksize = i_blocksize(inode);\n\tunsigned int off = pos & (blocksize - 1);\n\n\t \n\tif (!off)\n\t\treturn 0;\n\treturn iomap_zero_range(inode, pos, blocksize - off, did_zero, ops);\n}\nEXPORT_SYMBOL_GPL(iomap_truncate_page);\n\nstatic loff_t iomap_folio_mkwrite_iter(struct iomap_iter *iter,\n\t\tstruct folio *folio)\n{\n\tloff_t length = iomap_length(iter);\n\tint ret;\n\n\tif (iter->iomap.flags & IOMAP_F_BUFFER_HEAD) {\n\t\tret = __block_write_begin_int(folio, iter->pos, length, NULL,\n\t\t\t\t\t      &iter->iomap);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tblock_commit_write(&folio->page, 0, length);\n\t} else {\n\t\tWARN_ON_ONCE(!folio_test_uptodate(folio));\n\t\tfolio_mark_dirty(folio);\n\t}\n\n\treturn length;\n}\n\nvm_fault_t iomap_page_mkwrite(struct vm_fault *vmf, const struct iomap_ops *ops)\n{\n\tstruct iomap_iter iter = {\n\t\t.inode\t\t= file_inode(vmf->vma->vm_file),\n\t\t.flags\t\t= IOMAP_WRITE | IOMAP_FAULT,\n\t};\n\tstruct folio *folio = page_folio(vmf->page);\n\tssize_t ret;\n\n\tfolio_lock(folio);\n\tret = folio_mkwrite_check_truncate(folio, iter.inode);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\titer.pos = folio_pos(folio);\n\titer.len = ret;\n\twhile ((ret = iomap_iter(&iter, ops)) > 0)\n\t\titer.processed = iomap_folio_mkwrite_iter(&iter, folio);\n\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\tfolio_wait_stable(folio);\n\treturn VM_FAULT_LOCKED;\nout_unlock:\n\tfolio_unlock(folio);\n\treturn vmf_fs_error(ret);\n}\nEXPORT_SYMBOL_GPL(iomap_page_mkwrite);\n\nstatic void iomap_finish_folio_write(struct inode *inode, struct folio *folio,\n\t\tsize_t len, int error)\n{\n\tstruct iomap_folio_state *ifs = folio->private;\n\n\tif (error) {\n\t\tfolio_set_error(folio);\n\t\tmapping_set_error(inode->i_mapping, error);\n\t}\n\n\tWARN_ON_ONCE(i_blocks_per_folio(inode, folio) > 1 && !ifs);\n\tWARN_ON_ONCE(ifs && atomic_read(&ifs->write_bytes_pending) <= 0);\n\n\tif (!ifs || atomic_sub_and_test(len, &ifs->write_bytes_pending))\n\t\tfolio_end_writeback(folio);\n}\n\n \nstatic u32\niomap_finish_ioend(struct iomap_ioend *ioend, int error)\n{\n\tstruct inode *inode = ioend->io_inode;\n\tstruct bio *bio = &ioend->io_inline_bio;\n\tstruct bio *last = ioend->io_bio, *next;\n\tu64 start = bio->bi_iter.bi_sector;\n\tloff_t offset = ioend->io_offset;\n\tbool quiet = bio_flagged(bio, BIO_QUIET);\n\tu32 folio_count = 0;\n\n\tfor (bio = &ioend->io_inline_bio; bio; bio = next) {\n\t\tstruct folio_iter fi;\n\n\t\t \n\t\tif (bio == last)\n\t\t\tnext = NULL;\n\t\telse\n\t\t\tnext = bio->bi_private;\n\n\t\t \n\t\tbio_for_each_folio_all(fi, bio) {\n\t\t\tiomap_finish_folio_write(inode, fi.folio, fi.length,\n\t\t\t\t\terror);\n\t\t\tfolio_count++;\n\t\t}\n\t\tbio_put(bio);\n\t}\n\t \n\n\tif (unlikely(error && !quiet)) {\n\t\tprintk_ratelimited(KERN_ERR\n\"%s: writeback error on inode %lu, offset %lld, sector %llu\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, offset, start);\n\t}\n\treturn folio_count;\n}\n\n \nvoid\niomap_finish_ioends(struct iomap_ioend *ioend, int error)\n{\n\tstruct list_head tmp;\n\tu32 completions;\n\n\tmight_sleep();\n\n\tlist_replace_init(&ioend->io_list, &tmp);\n\tcompletions = iomap_finish_ioend(ioend, error);\n\n\twhile (!list_empty(&tmp)) {\n\t\tif (completions > IOEND_BATCH_SIZE * 8) {\n\t\t\tcond_resched();\n\t\t\tcompletions = 0;\n\t\t}\n\t\tioend = list_first_entry(&tmp, struct iomap_ioend, io_list);\n\t\tlist_del_init(&ioend->io_list);\n\t\tcompletions += iomap_finish_ioend(ioend, error);\n\t}\n}\nEXPORT_SYMBOL_GPL(iomap_finish_ioends);\n\n \nstatic bool\niomap_ioend_can_merge(struct iomap_ioend *ioend, struct iomap_ioend *next)\n{\n\tif (ioend->io_bio->bi_status != next->io_bio->bi_status)\n\t\treturn false;\n\tif ((ioend->io_flags & IOMAP_F_SHARED) ^\n\t    (next->io_flags & IOMAP_F_SHARED))\n\t\treturn false;\n\tif ((ioend->io_type == IOMAP_UNWRITTEN) ^\n\t    (next->io_type == IOMAP_UNWRITTEN))\n\t\treturn false;\n\tif (ioend->io_offset + ioend->io_size != next->io_offset)\n\t\treturn false;\n\t \n\tif (ioend->io_sector + (ioend->io_size >> 9) != next->io_sector)\n\t\treturn false;\n\treturn true;\n}\n\nvoid\niomap_ioend_try_merge(struct iomap_ioend *ioend, struct list_head *more_ioends)\n{\n\tstruct iomap_ioend *next;\n\n\tINIT_LIST_HEAD(&ioend->io_list);\n\n\twhile ((next = list_first_entry_or_null(more_ioends, struct iomap_ioend,\n\t\t\tio_list))) {\n\t\tif (!iomap_ioend_can_merge(ioend, next))\n\t\t\tbreak;\n\t\tlist_move_tail(&next->io_list, &ioend->io_list);\n\t\tioend->io_size += next->io_size;\n\t}\n}\nEXPORT_SYMBOL_GPL(iomap_ioend_try_merge);\n\nstatic int\niomap_ioend_compare(void *priv, const struct list_head *a,\n\t\tconst struct list_head *b)\n{\n\tstruct iomap_ioend *ia = container_of(a, struct iomap_ioend, io_list);\n\tstruct iomap_ioend *ib = container_of(b, struct iomap_ioend, io_list);\n\n\tif (ia->io_offset < ib->io_offset)\n\t\treturn -1;\n\tif (ia->io_offset > ib->io_offset)\n\t\treturn 1;\n\treturn 0;\n}\n\nvoid\niomap_sort_ioends(struct list_head *ioend_list)\n{\n\tlist_sort(NULL, ioend_list, iomap_ioend_compare);\n}\nEXPORT_SYMBOL_GPL(iomap_sort_ioends);\n\nstatic void iomap_writepage_end_bio(struct bio *bio)\n{\n\tstruct iomap_ioend *ioend = bio->bi_private;\n\n\tiomap_finish_ioend(ioend, blk_status_to_errno(bio->bi_status));\n}\n\n \nstatic int\niomap_submit_ioend(struct iomap_writepage_ctx *wpc, struct iomap_ioend *ioend,\n\t\tint error)\n{\n\tioend->io_bio->bi_private = ioend;\n\tioend->io_bio->bi_end_io = iomap_writepage_end_bio;\n\n\tif (wpc->ops->prepare_ioend)\n\t\terror = wpc->ops->prepare_ioend(ioend, error);\n\tif (error) {\n\t\t \n\t\tioend->io_bio->bi_status = errno_to_blk_status(error);\n\t\tbio_endio(ioend->io_bio);\n\t\treturn error;\n\t}\n\n\tsubmit_bio(ioend->io_bio);\n\treturn 0;\n}\n\nstatic struct iomap_ioend *\niomap_alloc_ioend(struct inode *inode, struct iomap_writepage_ctx *wpc,\n\t\tloff_t offset, sector_t sector, struct writeback_control *wbc)\n{\n\tstruct iomap_ioend *ioend;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(wpc->iomap.bdev, BIO_MAX_VECS,\n\t\t\t       REQ_OP_WRITE | wbc_to_write_flags(wbc),\n\t\t\t       GFP_NOFS, &iomap_ioend_bioset);\n\tbio->bi_iter.bi_sector = sector;\n\twbc_init_bio(wbc, bio);\n\n\tioend = container_of(bio, struct iomap_ioend, io_inline_bio);\n\tINIT_LIST_HEAD(&ioend->io_list);\n\tioend->io_type = wpc->iomap.type;\n\tioend->io_flags = wpc->iomap.flags;\n\tioend->io_inode = inode;\n\tioend->io_size = 0;\n\tioend->io_folios = 0;\n\tioend->io_offset = offset;\n\tioend->io_bio = bio;\n\tioend->io_sector = sector;\n\treturn ioend;\n}\n\n \nstatic struct bio *\niomap_chain_bio(struct bio *prev)\n{\n\tstruct bio *new;\n\n\tnew = bio_alloc(prev->bi_bdev, BIO_MAX_VECS, prev->bi_opf, GFP_NOFS);\n\tbio_clone_blkg_association(new, prev);\n\tnew->bi_iter.bi_sector = bio_end_sector(prev);\n\n\tbio_chain(prev, new);\n\tbio_get(prev);\t\t \n\tsubmit_bio(prev);\n\treturn new;\n}\n\nstatic bool\niomap_can_add_to_ioend(struct iomap_writepage_ctx *wpc, loff_t offset,\n\t\tsector_t sector)\n{\n\tif ((wpc->iomap.flags & IOMAP_F_SHARED) !=\n\t    (wpc->ioend->io_flags & IOMAP_F_SHARED))\n\t\treturn false;\n\tif (wpc->iomap.type != wpc->ioend->io_type)\n\t\treturn false;\n\tif (offset != wpc->ioend->io_offset + wpc->ioend->io_size)\n\t\treturn false;\n\tif (sector != bio_end_sector(wpc->ioend->io_bio))\n\t\treturn false;\n\t \n\tif (wpc->ioend->io_folios >= IOEND_BATCH_SIZE)\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic void\niomap_add_to_ioend(struct inode *inode, loff_t pos, struct folio *folio,\n\t\tstruct iomap_folio_state *ifs, struct iomap_writepage_ctx *wpc,\n\t\tstruct writeback_control *wbc, struct list_head *iolist)\n{\n\tsector_t sector = iomap_sector(&wpc->iomap, pos);\n\tunsigned len = i_blocksize(inode);\n\tsize_t poff = offset_in_folio(folio, pos);\n\n\tif (!wpc->ioend || !iomap_can_add_to_ioend(wpc, pos, sector)) {\n\t\tif (wpc->ioend)\n\t\t\tlist_add(&wpc->ioend->io_list, iolist);\n\t\twpc->ioend = iomap_alloc_ioend(inode, wpc, pos, sector, wbc);\n\t}\n\n\tif (!bio_add_folio(wpc->ioend->io_bio, folio, len, poff)) {\n\t\twpc->ioend->io_bio = iomap_chain_bio(wpc->ioend->io_bio);\n\t\tbio_add_folio_nofail(wpc->ioend->io_bio, folio, len, poff);\n\t}\n\n\tif (ifs)\n\t\tatomic_add(len, &ifs->write_bytes_pending);\n\twpc->ioend->io_size += len;\n\twbc_account_cgroup_owner(wbc, &folio->page, len);\n}\n\n \nstatic int\niomap_writepage_map(struct iomap_writepage_ctx *wpc,\n\t\tstruct writeback_control *wbc, struct inode *inode,\n\t\tstruct folio *folio, u64 end_pos)\n{\n\tstruct iomap_folio_state *ifs = folio->private;\n\tstruct iomap_ioend *ioend, *next;\n\tunsigned len = i_blocksize(inode);\n\tunsigned nblocks = i_blocks_per_folio(inode, folio);\n\tu64 pos = folio_pos(folio);\n\tint error = 0, count = 0, i;\n\tLIST_HEAD(submit_list);\n\n\tWARN_ON_ONCE(end_pos <= pos);\n\n\tif (!ifs && nblocks > 1) {\n\t\tifs = ifs_alloc(inode, folio, 0);\n\t\tiomap_set_range_dirty(folio, 0, end_pos - pos);\n\t}\n\n\tWARN_ON_ONCE(ifs && atomic_read(&ifs->write_bytes_pending) != 0);\n\n\t \n\tfor (i = 0; i < nblocks && pos < end_pos; i++, pos += len) {\n\t\tif (ifs && !ifs_block_is_dirty(folio, ifs, i))\n\t\t\tcontinue;\n\n\t\terror = wpc->ops->map_blocks(wpc, inode, pos);\n\t\tif (error)\n\t\t\tbreak;\n\t\ttrace_iomap_writepage_map(inode, &wpc->iomap);\n\t\tif (WARN_ON_ONCE(wpc->iomap.type == IOMAP_INLINE))\n\t\t\tcontinue;\n\t\tif (wpc->iomap.type == IOMAP_HOLE)\n\t\t\tcontinue;\n\t\tiomap_add_to_ioend(inode, pos, folio, ifs, wpc, wbc,\n\t\t\t\t &submit_list);\n\t\tcount++;\n\t}\n\tif (count)\n\t\twpc->ioend->io_folios++;\n\n\tWARN_ON_ONCE(!wpc->ioend && !list_empty(&submit_list));\n\tWARN_ON_ONCE(!folio_test_locked(folio));\n\tWARN_ON_ONCE(folio_test_writeback(folio));\n\tWARN_ON_ONCE(folio_test_dirty(folio));\n\n\t \n\tif (unlikely(error)) {\n\t\t \n\t\tif (wpc->ops->discard_folio)\n\t\t\twpc->ops->discard_folio(folio, pos);\n\t\tif (!count) {\n\t\t\tfolio_unlock(folio);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tiomap_clear_range_dirty(folio, 0, folio_size(folio));\n\tfolio_start_writeback(folio);\n\tfolio_unlock(folio);\n\n\t \n\tlist_for_each_entry_safe(ioend, next, &submit_list, io_list) {\n\t\tint error2;\n\n\t\tlist_del_init(&ioend->io_list);\n\t\terror2 = iomap_submit_ioend(wpc, ioend, error);\n\t\tif (error2 && !error)\n\t\t\terror = error2;\n\t}\n\n\t \n\tif (!count)\n\t\tfolio_end_writeback(folio);\ndone:\n\tmapping_set_error(inode->i_mapping, error);\n\treturn error;\n}\n\n \nstatic int iomap_do_writepage(struct folio *folio,\n\t\tstruct writeback_control *wbc, void *data)\n{\n\tstruct iomap_writepage_ctx *wpc = data;\n\tstruct inode *inode = folio->mapping->host;\n\tu64 end_pos, isize;\n\n\ttrace_iomap_writepage(inode, folio_pos(folio), folio_size(folio));\n\n\t \n\tif (WARN_ON_ONCE((current->flags & (PF_MEMALLOC|PF_KSWAPD)) ==\n\t\t\tPF_MEMALLOC))\n\t\tgoto redirty;\n\n\t \n\tisize = i_size_read(inode);\n\tend_pos = folio_pos(folio) + folio_size(folio);\n\tif (end_pos > isize) {\n\t\t \n\t\tsize_t poff = offset_in_folio(folio, isize);\n\t\tpgoff_t end_index = isize >> PAGE_SHIFT;\n\n\t\t \n\t\tif (folio->index > end_index ||\n\t\t    (folio->index == end_index && poff == 0))\n\t\t\tgoto unlock;\n\n\t\t \n\t\tfolio_zero_segment(folio, poff, folio_size(folio));\n\t\tend_pos = isize;\n\t}\n\n\treturn iomap_writepage_map(wpc, wbc, inode, folio, end_pos);\n\nredirty:\n\tfolio_redirty_for_writepage(wbc, folio);\nunlock:\n\tfolio_unlock(folio);\n\treturn 0;\n}\n\nint\niomap_writepages(struct address_space *mapping, struct writeback_control *wbc,\n\t\tstruct iomap_writepage_ctx *wpc,\n\t\tconst struct iomap_writeback_ops *ops)\n{\n\tint\t\t\tret;\n\n\twpc->ops = ops;\n\tret = write_cache_pages(mapping, wbc, iomap_do_writepage, wpc);\n\tif (!wpc->ioend)\n\t\treturn ret;\n\treturn iomap_submit_ioend(wpc, wpc->ioend, ret);\n}\nEXPORT_SYMBOL_GPL(iomap_writepages);\n\nstatic int __init iomap_init(void)\n{\n\treturn bioset_init(&iomap_ioend_bioset, 4 * (PAGE_SIZE / SECTOR_SIZE),\n\t\t\t   offsetof(struct iomap_ioend, io_inline_bio),\n\t\t\t   BIOSET_NEED_BVECS);\n}\nfs_initcall(iomap_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}