{
  "module_name": "swapfile.c",
  "hash_id": "4cc17752fd3b7571efa18194247f2efd46b2e8641b95b81593a3ed4c7064857a",
  "original_prompt": "Ingested from linux-6.6.14/fs/iomap/swapfile.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/fs.h>\n#include <linux/iomap.h>\n#include <linux/swap.h>\n\n \n\nstruct iomap_swapfile_info {\n\tstruct iomap iomap;\t\t \n\tstruct swap_info_struct *sis;\n\tuint64_t lowest_ppage;\t\t \n\tuint64_t highest_ppage;\t\t \n\tunsigned long nr_pages;\t\t \n\tint nr_extents;\t\t\t \n\tstruct file *file;\n};\n\n \nstatic int iomap_swapfile_add_extent(struct iomap_swapfile_info *isi)\n{\n\tstruct iomap *iomap = &isi->iomap;\n\tunsigned long nr_pages;\n\tunsigned long max_pages;\n\tuint64_t first_ppage;\n\tuint64_t first_ppage_reported;\n\tuint64_t next_ppage;\n\tint error;\n\n\tif (unlikely(isi->nr_pages >= isi->sis->max))\n\t\treturn 0;\n\tmax_pages = isi->sis->max - isi->nr_pages;\n\n\t \n\tfirst_ppage = ALIGN(iomap->addr, PAGE_SIZE) >> PAGE_SHIFT;\n\tnext_ppage = ALIGN_DOWN(iomap->addr + iomap->length, PAGE_SIZE) >>\n\t\t\tPAGE_SHIFT;\n\n\t \n\tif (first_ppage >= next_ppage)\n\t\treturn 0;\n\tnr_pages = next_ppage - first_ppage;\n\tnr_pages = min(nr_pages, max_pages);\n\n\t \n\tfirst_ppage_reported = first_ppage;\n\tif (iomap->offset == 0)\n\t\tfirst_ppage_reported++;\n\tif (isi->lowest_ppage > first_ppage_reported)\n\t\tisi->lowest_ppage = first_ppage_reported;\n\tif (isi->highest_ppage < (next_ppage - 1))\n\t\tisi->highest_ppage = next_ppage - 1;\n\n\t \n\terror = add_swap_extent(isi->sis, isi->nr_pages, nr_pages, first_ppage);\n\tif (error < 0)\n\t\treturn error;\n\tisi->nr_extents += error;\n\tisi->nr_pages += nr_pages;\n\treturn 0;\n}\n\nstatic int iomap_swapfile_fail(struct iomap_swapfile_info *isi, const char *str)\n{\n\tchar *buf, *p = ERR_PTR(-ENOMEM);\n\n\tbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (buf)\n\t\tp = file_path(isi->file, buf, PATH_MAX);\n\tpr_err(\"swapon: file %s %s\\n\", IS_ERR(p) ? \"<unknown>\" : p, str);\n\tkfree(buf);\n\treturn -EINVAL;\n}\n\n \nstatic loff_t iomap_swapfile_iter(const struct iomap_iter *iter,\n\t\tstruct iomap *iomap, struct iomap_swapfile_info *isi)\n{\n\tswitch (iomap->type) {\n\tcase IOMAP_MAPPED:\n\tcase IOMAP_UNWRITTEN:\n\t\t \n\t\tbreak;\n\tcase IOMAP_INLINE:\n\t\t \n\t\treturn iomap_swapfile_fail(isi, \"is inline\");\n\tdefault:\n\t\treturn iomap_swapfile_fail(isi, \"has unallocated extents\");\n\t}\n\n\t \n\tif (iomap->flags & IOMAP_F_DIRTY)\n\t\treturn iomap_swapfile_fail(isi, \"is not committed\");\n\tif (iomap->flags & IOMAP_F_SHARED)\n\t\treturn iomap_swapfile_fail(isi, \"has shared extents\");\n\n\t \n\tif (iomap->bdev != isi->sis->bdev)\n\t\treturn iomap_swapfile_fail(isi, \"outside the main device\");\n\n\tif (isi->iomap.length == 0) {\n\t\t \n\t\tmemcpy(&isi->iomap, iomap, sizeof(isi->iomap));\n\t} else if (isi->iomap.addr + isi->iomap.length == iomap->addr) {\n\t\t \n\t\tisi->iomap.length += iomap->length;\n\t} else {\n\t\t \n\t\tint error = iomap_swapfile_add_extent(isi);\n\t\tif (error)\n\t\t\treturn error;\n\t\tmemcpy(&isi->iomap, iomap, sizeof(isi->iomap));\n\t}\n\treturn iomap_length(iter);\n}\n\n \nint iomap_swapfile_activate(struct swap_info_struct *sis,\n\t\tstruct file *swap_file, sector_t *pagespan,\n\t\tconst struct iomap_ops *ops)\n{\n\tstruct inode *inode = swap_file->f_mapping->host;\n\tstruct iomap_iter iter = {\n\t\t.inode\t= inode,\n\t\t.pos\t= 0,\n\t\t.len\t= ALIGN_DOWN(i_size_read(inode), PAGE_SIZE),\n\t\t.flags\t= IOMAP_REPORT,\n\t};\n\tstruct iomap_swapfile_info isi = {\n\t\t.sis = sis,\n\t\t.lowest_ppage = (sector_t)-1ULL,\n\t\t.file = swap_file,\n\t};\n\tint ret;\n\n\t \n\tret = vfs_fsync(swap_file, 1);\n\tif (ret)\n\t\treturn ret;\n\n\twhile ((ret = iomap_iter(&iter, ops)) > 0)\n\t\titer.processed = iomap_swapfile_iter(&iter, &iter.iomap, &isi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (isi.iomap.length) {\n\t\tret = iomap_swapfile_add_extent(&isi);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (isi.nr_pages == 0) {\n\t\tpr_warn(\"swapon: Cannot find a single usable page in file.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*pagespan = 1 + isi.highest_ppage - isi.lowest_ppage;\n\tsis->max = isi.nr_pages;\n\tsis->pages = isi.nr_pages - 1;\n\tsis->highest_bit = isi.nr_pages - 1;\n\treturn isi.nr_extents;\n}\nEXPORT_SYMBOL_GPL(iomap_swapfile_activate);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}