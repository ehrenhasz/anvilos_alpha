{
  "module_name": "seek.c",
  "hash_id": "70e07237920434d22593f1bb735b43e49ecba27c3779907690f5eeecdd23244f",
  "original_prompt": "Ingested from linux-6.6.14/fs/iomap/seek.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/fs.h>\n#include <linux/iomap.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n\nstatic loff_t iomap_seek_hole_iter(const struct iomap_iter *iter,\n\t\tloff_t *hole_pos)\n{\n\tloff_t length = iomap_length(iter);\n\n\tswitch (iter->iomap.type) {\n\tcase IOMAP_UNWRITTEN:\n\t\t*hole_pos = mapping_seek_hole_data(iter->inode->i_mapping,\n\t\t\t\titer->pos, iter->pos + length, SEEK_HOLE);\n\t\tif (*hole_pos == iter->pos + length)\n\t\t\treturn length;\n\t\treturn 0;\n\tcase IOMAP_HOLE:\n\t\t*hole_pos = iter->pos;\n\t\treturn 0;\n\tdefault:\n\t\treturn length;\n\t}\n}\n\nloff_t\niomap_seek_hole(struct inode *inode, loff_t pos, const struct iomap_ops *ops)\n{\n\tloff_t size = i_size_read(inode);\n\tstruct iomap_iter iter = {\n\t\t.inode\t= inode,\n\t\t.pos\t= pos,\n\t\t.flags\t= IOMAP_REPORT,\n\t};\n\tint ret;\n\n\t \n\tif (pos < 0 || pos >= size)\n\t\treturn -ENXIO;\n\n\titer.len = size - pos;\n\twhile ((ret = iomap_iter(&iter, ops)) > 0)\n\t\titer.processed = iomap_seek_hole_iter(&iter, &pos);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (iter.len)  \n\t\treturn pos;\n\treturn size;\n}\nEXPORT_SYMBOL_GPL(iomap_seek_hole);\n\nstatic loff_t iomap_seek_data_iter(const struct iomap_iter *iter,\n\t\tloff_t *hole_pos)\n{\n\tloff_t length = iomap_length(iter);\n\n\tswitch (iter->iomap.type) {\n\tcase IOMAP_HOLE:\n\t\treturn length;\n\tcase IOMAP_UNWRITTEN:\n\t\t*hole_pos = mapping_seek_hole_data(iter->inode->i_mapping,\n\t\t\t\titer->pos, iter->pos + length, SEEK_DATA);\n\t\tif (*hole_pos < 0)\n\t\t\treturn length;\n\t\treturn 0;\n\tdefault:\n\t\t*hole_pos = iter->pos;\n\t\treturn 0;\n\t}\n}\n\nloff_t\niomap_seek_data(struct inode *inode, loff_t pos, const struct iomap_ops *ops)\n{\n\tloff_t size = i_size_read(inode);\n\tstruct iomap_iter iter = {\n\t\t.inode\t= inode,\n\t\t.pos\t= pos,\n\t\t.flags\t= IOMAP_REPORT,\n\t};\n\tint ret;\n\n\t \n\tif (pos < 0 || pos >= size)\n\t\treturn -ENXIO;\n\n\titer.len = size - pos;\n\twhile ((ret = iomap_iter(&iter, ops)) > 0)\n\t\titer.processed = iomap_seek_data_iter(&iter, &pos);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (iter.len)  \n\t\treturn pos;\n\t \n\treturn -ENXIO;\n}\nEXPORT_SYMBOL_GPL(iomap_seek_data);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}