{
  "module_name": "fiemap.c",
  "hash_id": "10b19d6091e93ba4846b770dc5d29261dd28e42e5a04512aa2f31490334e2162",
  "original_prompt": "Ingested from linux-6.6.14/fs/iomap/fiemap.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/fs.h>\n#include <linux/iomap.h>\n#include <linux/fiemap.h>\n#include <linux/pagemap.h>\n\nstatic int iomap_to_fiemap(struct fiemap_extent_info *fi,\n\t\tconst struct iomap *iomap, u32 flags)\n{\n\tswitch (iomap->type) {\n\tcase IOMAP_HOLE:\n\t\t \n\t\treturn 0;\n\tcase IOMAP_DELALLOC:\n\t\tflags |= FIEMAP_EXTENT_DELALLOC | FIEMAP_EXTENT_UNKNOWN;\n\t\tbreak;\n\tcase IOMAP_MAPPED:\n\t\tbreak;\n\tcase IOMAP_UNWRITTEN:\n\t\tflags |= FIEMAP_EXTENT_UNWRITTEN;\n\t\tbreak;\n\tcase IOMAP_INLINE:\n\t\tflags |= FIEMAP_EXTENT_DATA_INLINE;\n\t\tbreak;\n\t}\n\n\tif (iomap->flags & IOMAP_F_MERGED)\n\t\tflags |= FIEMAP_EXTENT_MERGED;\n\tif (iomap->flags & IOMAP_F_SHARED)\n\t\tflags |= FIEMAP_EXTENT_SHARED;\n\n\treturn fiemap_fill_next_extent(fi, iomap->offset,\n\t\t\tiomap->addr != IOMAP_NULL_ADDR ? iomap->addr : 0,\n\t\t\tiomap->length, flags);\n}\n\nstatic loff_t iomap_fiemap_iter(const struct iomap_iter *iter,\n\t\tstruct fiemap_extent_info *fi, struct iomap *prev)\n{\n\tint ret;\n\n\tif (iter->iomap.type == IOMAP_HOLE)\n\t\treturn iomap_length(iter);\n\n\tret = iomap_to_fiemap(fi, prev, 0);\n\t*prev = iter->iomap;\n\tswitch (ret) {\n\tcase 0:\t\t \n\t\treturn iomap_length(iter);\n\tcase 1:\t\t \n\t\treturn 0;\n\tdefault:\t \n\t\treturn ret;\n\t}\n}\n\nint iomap_fiemap(struct inode *inode, struct fiemap_extent_info *fi,\n\t\tu64 start, u64 len, const struct iomap_ops *ops)\n{\n\tstruct iomap_iter iter = {\n\t\t.inode\t\t= inode,\n\t\t.pos\t\t= start,\n\t\t.len\t\t= len,\n\t\t.flags\t\t= IOMAP_REPORT,\n\t};\n\tstruct iomap prev = {\n\t\t.type\t\t= IOMAP_HOLE,\n\t};\n\tint ret;\n\n\tret = fiemap_prep(inode, fi, start, &iter.len, 0);\n\tif (ret)\n\t\treturn ret;\n\n\twhile ((ret = iomap_iter(&iter, ops)) > 0)\n\t\titer.processed = iomap_fiemap_iter(&iter, fi, &prev);\n\n\tif (prev.type != IOMAP_HOLE) {\n\t\tret = iomap_to_fiemap(fi, &prev, FIEMAP_EXTENT_LAST);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (ret < 0 && ret != -ENOENT)\n\t\treturn ret;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(iomap_fiemap);\n\n \nsector_t\niomap_bmap(struct address_space *mapping, sector_t bno,\n\t\tconst struct iomap_ops *ops)\n{\n\tstruct iomap_iter iter = {\n\t\t.inode\t= mapping->host,\n\t\t.pos\t= (loff_t)bno << mapping->host->i_blkbits,\n\t\t.len\t= i_blocksize(mapping->host),\n\t\t.flags\t= IOMAP_REPORT,\n\t};\n\tconst unsigned int blkshift = mapping->host->i_blkbits - SECTOR_SHIFT;\n\tint ret;\n\n\tif (filemap_write_and_wait(mapping))\n\t\treturn 0;\n\n\tbno = 0;\n\twhile ((ret = iomap_iter(&iter, ops)) > 0) {\n\t\tif (iter.iomap.type == IOMAP_MAPPED)\n\t\t\tbno = iomap_sector(&iter.iomap, iter.pos) >> blkshift;\n\t\t \n\t}\n\tif (ret)\n\t\treturn 0;\n\n\treturn bno;\n}\nEXPORT_SYMBOL_GPL(iomap_bmap);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}