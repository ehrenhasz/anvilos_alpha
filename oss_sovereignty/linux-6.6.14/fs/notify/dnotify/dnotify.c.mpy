{
  "module_name": "dnotify.c",
  "hash_id": "91f3206ef20052337fc6002268b5da997f528a524c3dda2a476a65805a8ceea4",
  "original_prompt": "Ingested from linux-6.6.14/fs/notify/dnotify/dnotify.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/sched/signal.h>\n#include <linux/dnotify.h>\n#include <linux/init.h>\n#include <linux/security.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/fdtable.h>\n#include <linux/fsnotify_backend.h>\n\nstatic int dir_notify_enable __read_mostly = 1;\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table dnotify_sysctls[] = {\n\t{\n\t\t.procname\t= \"dir-notify-enable\",\n\t\t.data\t\t= &dir_notify_enable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{}\n};\nstatic void __init dnotify_sysctl_init(void)\n{\n\tregister_sysctl_init(\"fs\", dnotify_sysctls);\n}\n#else\n#define dnotify_sysctl_init() do { } while (0)\n#endif\n\nstatic struct kmem_cache *dnotify_struct_cache __read_mostly;\nstatic struct kmem_cache *dnotify_mark_cache __read_mostly;\nstatic struct fsnotify_group *dnotify_group __read_mostly;\n\n \nstruct dnotify_mark {\n\tstruct fsnotify_mark fsn_mark;\n\tstruct dnotify_struct *dn;\n};\n\n \nstatic void dnotify_recalc_inode_mask(struct fsnotify_mark *fsn_mark)\n{\n\t__u32 new_mask = 0;\n\tstruct dnotify_struct *dn;\n\tstruct dnotify_mark *dn_mark  = container_of(fsn_mark,\n\t\t\t\t\t\t     struct dnotify_mark,\n\t\t\t\t\t\t     fsn_mark);\n\n\tassert_spin_locked(&fsn_mark->lock);\n\n\tfor (dn = dn_mark->dn; dn != NULL; dn = dn->dn_next)\n\t\tnew_mask |= (dn->dn_mask & ~FS_DN_MULTISHOT);\n\tif (fsn_mark->mask == new_mask)\n\t\treturn;\n\tfsn_mark->mask = new_mask;\n\n\tfsnotify_recalc_mask(fsn_mark->connector);\n}\n\n \nstatic int dnotify_handle_event(struct fsnotify_mark *inode_mark, u32 mask,\n\t\t\t\tstruct inode *inode, struct inode *dir,\n\t\t\t\tconst struct qstr *name, u32 cookie)\n{\n\tstruct dnotify_mark *dn_mark;\n\tstruct dnotify_struct *dn;\n\tstruct dnotify_struct **prev;\n\tstruct fown_struct *fown;\n\t__u32 test_mask = mask & ~FS_EVENT_ON_CHILD;\n\n\t \n\tif (!dir && !(mask & FS_ISDIR))\n\t\treturn 0;\n\n\tdn_mark = container_of(inode_mark, struct dnotify_mark, fsn_mark);\n\n\tspin_lock(&inode_mark->lock);\n\tprev = &dn_mark->dn;\n\twhile ((dn = *prev) != NULL) {\n\t\tif ((dn->dn_mask & test_mask) == 0) {\n\t\t\tprev = &dn->dn_next;\n\t\t\tcontinue;\n\t\t}\n\t\tfown = &dn->dn_filp->f_owner;\n\t\tsend_sigio(fown, dn->dn_fd, POLL_MSG);\n\t\tif (dn->dn_mask & FS_DN_MULTISHOT)\n\t\t\tprev = &dn->dn_next;\n\t\telse {\n\t\t\t*prev = dn->dn_next;\n\t\t\tkmem_cache_free(dnotify_struct_cache, dn);\n\t\t\tdnotify_recalc_inode_mask(inode_mark);\n\t\t}\n\t}\n\n\tspin_unlock(&inode_mark->lock);\n\n\treturn 0;\n}\n\nstatic void dnotify_free_mark(struct fsnotify_mark *fsn_mark)\n{\n\tstruct dnotify_mark *dn_mark = container_of(fsn_mark,\n\t\t\t\t\t\t    struct dnotify_mark,\n\t\t\t\t\t\t    fsn_mark);\n\n\tBUG_ON(dn_mark->dn);\n\n\tkmem_cache_free(dnotify_mark_cache, dn_mark);\n}\n\nstatic const struct fsnotify_ops dnotify_fsnotify_ops = {\n\t.handle_inode_event = dnotify_handle_event,\n\t.free_mark = dnotify_free_mark,\n};\n\n \nvoid dnotify_flush(struct file *filp, fl_owner_t id)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct dnotify_mark *dn_mark;\n\tstruct dnotify_struct *dn;\n\tstruct dnotify_struct **prev;\n\tstruct inode *inode;\n\tbool free = false;\n\n\tinode = file_inode(filp);\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tfsn_mark = fsnotify_find_mark(&inode->i_fsnotify_marks, dnotify_group);\n\tif (!fsn_mark)\n\t\treturn;\n\tdn_mark = container_of(fsn_mark, struct dnotify_mark, fsn_mark);\n\n\tfsnotify_group_lock(dnotify_group);\n\n\tspin_lock(&fsn_mark->lock);\n\tprev = &dn_mark->dn;\n\twhile ((dn = *prev) != NULL) {\n\t\tif ((dn->dn_owner == id) && (dn->dn_filp == filp)) {\n\t\t\t*prev = dn->dn_next;\n\t\t\tkmem_cache_free(dnotify_struct_cache, dn);\n\t\t\tdnotify_recalc_inode_mask(fsn_mark);\n\t\t\tbreak;\n\t\t}\n\t\tprev = &dn->dn_next;\n\t}\n\n\tspin_unlock(&fsn_mark->lock);\n\n\t \n\tif (dn_mark->dn == NULL) {\n\t\tfsnotify_detach_mark(fsn_mark);\n\t\tfree = true;\n\t}\n\n\tfsnotify_group_unlock(dnotify_group);\n\n\tif (free)\n\t\tfsnotify_free_mark(fsn_mark);\n\tfsnotify_put_mark(fsn_mark);\n}\n\n \nstatic __u32 convert_arg(unsigned int arg)\n{\n\t__u32 new_mask = FS_EVENT_ON_CHILD;\n\n\tif (arg & DN_MULTISHOT)\n\t\tnew_mask |= FS_DN_MULTISHOT;\n\tif (arg & DN_DELETE)\n\t\tnew_mask |= (FS_DELETE | FS_MOVED_FROM);\n\tif (arg & DN_MODIFY)\n\t\tnew_mask |= FS_MODIFY;\n\tif (arg & DN_ACCESS)\n\t\tnew_mask |= FS_ACCESS;\n\tif (arg & DN_ATTRIB)\n\t\tnew_mask |= FS_ATTRIB;\n\tif (arg & DN_RENAME)\n\t\tnew_mask |= FS_RENAME;\n\tif (arg & DN_CREATE)\n\t\tnew_mask |= (FS_CREATE | FS_MOVED_TO);\n\n\treturn new_mask;\n}\n\n \nstatic int attach_dn(struct dnotify_struct *dn, struct dnotify_mark *dn_mark,\n\t\t     fl_owner_t id, int fd, struct file *filp, __u32 mask)\n{\n\tstruct dnotify_struct *odn;\n\n\todn = dn_mark->dn;\n\twhile (odn != NULL) {\n\t\t \n\t\tif ((odn->dn_owner == id) && (odn->dn_filp == filp)) {\n\t\t\todn->dn_fd = fd;\n\t\t\todn->dn_mask |= mask;\n\t\t\treturn -EEXIST;\n\t\t}\n\t\todn = odn->dn_next;\n\t}\n\n\tdn->dn_mask = mask;\n\tdn->dn_fd = fd;\n\tdn->dn_filp = filp;\n\tdn->dn_owner = id;\n\tdn->dn_next = dn_mark->dn;\n\tdn_mark->dn = dn;\n\n\treturn 0;\n}\n\n \nint fcntl_dirnotify(int fd, struct file *filp, unsigned int arg)\n{\n\tstruct dnotify_mark *new_dn_mark, *dn_mark;\n\tstruct fsnotify_mark *new_fsn_mark, *fsn_mark;\n\tstruct dnotify_struct *dn;\n\tstruct inode *inode;\n\tfl_owner_t id = current->files;\n\tstruct file *f;\n\tint destroy = 0, error = 0;\n\t__u32 mask;\n\n\t \n\tnew_fsn_mark = NULL;\n\tdn = NULL;\n\n\tif (!dir_notify_enable) {\n\t\terror = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\t \n\tif ((arg & ~DN_MULTISHOT) == 0) {\n\t\tdnotify_flush(filp, id);\n\t\terror = 0;\n\t\tgoto out_err;\n\t}\n\n\t \n\tinode = file_inode(filp);\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\terror = -ENOTDIR;\n\t\tgoto out_err;\n\t}\n\n\t \n\tmask = convert_arg(arg);\n\n\terror = security_path_notify(&filp->f_path, mask,\n\t\t\tFSNOTIFY_OBJ_TYPE_INODE);\n\tif (error)\n\t\tgoto out_err;\n\n\t \n\tdn = kmem_cache_alloc(dnotify_struct_cache, GFP_KERNEL);\n\tif (!dn) {\n\t\terror = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\t \n\tnew_dn_mark = kmem_cache_alloc(dnotify_mark_cache, GFP_KERNEL);\n\tif (!new_dn_mark) {\n\t\terror = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\t \n\tnew_fsn_mark = &new_dn_mark->fsn_mark;\n\tfsnotify_init_mark(new_fsn_mark, dnotify_group);\n\tnew_fsn_mark->mask = mask;\n\tnew_dn_mark->dn = NULL;\n\n\t \n\tfsnotify_group_lock(dnotify_group);\n\n\t \n\tfsn_mark = fsnotify_find_mark(&inode->i_fsnotify_marks, dnotify_group);\n\tif (fsn_mark) {\n\t\tdn_mark = container_of(fsn_mark, struct dnotify_mark, fsn_mark);\n\t\tspin_lock(&fsn_mark->lock);\n\t} else {\n\t\terror = fsnotify_add_inode_mark_locked(new_fsn_mark, inode, 0);\n\t\tif (error) {\n\t\t\tfsnotify_group_unlock(dnotify_group);\n\t\t\tgoto out_err;\n\t\t}\n\t\tspin_lock(&new_fsn_mark->lock);\n\t\tfsn_mark = new_fsn_mark;\n\t\tdn_mark = new_dn_mark;\n\t\t \n\t\tnew_fsn_mark = NULL;\n\t}\n\n\trcu_read_lock();\n\tf = lookup_fd_rcu(fd);\n\trcu_read_unlock();\n\n\t \n\tif (f != filp) {\n\t\t \n\t\tif (dn_mark == new_dn_mark)\n\t\t\tdestroy = 1;\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\t__f_setown(filp, task_pid(current), PIDTYPE_TGID, 0);\n\n\terror = attach_dn(dn, dn_mark, id, fd, filp, mask);\n\t \n\tif (!error)\n\t\tdn = NULL;\n\t \n\telse if (error == -EEXIST)\n\t\terror = 0;\n\n\tdnotify_recalc_inode_mask(fsn_mark);\nout:\n\tspin_unlock(&fsn_mark->lock);\n\n\tif (destroy)\n\t\tfsnotify_detach_mark(fsn_mark);\n\tfsnotify_group_unlock(dnotify_group);\n\tif (destroy)\n\t\tfsnotify_free_mark(fsn_mark);\n\tfsnotify_put_mark(fsn_mark);\nout_err:\n\tif (new_fsn_mark)\n\t\tfsnotify_put_mark(new_fsn_mark);\n\tif (dn)\n\t\tkmem_cache_free(dnotify_struct_cache, dn);\n\treturn error;\n}\n\nstatic int __init dnotify_init(void)\n{\n\tdnotify_struct_cache = KMEM_CACHE(dnotify_struct,\n\t\t\t\t\t  SLAB_PANIC|SLAB_ACCOUNT);\n\tdnotify_mark_cache = KMEM_CACHE(dnotify_mark, SLAB_PANIC|SLAB_ACCOUNT);\n\n\tdnotify_group = fsnotify_alloc_group(&dnotify_fsnotify_ops,\n\t\t\t\t\t     FSNOTIFY_GROUP_NOFS);\n\tif (IS_ERR(dnotify_group))\n\t\tpanic(\"unable to allocate fsnotify group for dnotify\\n\");\n\tdnotify_sysctl_init();\n\treturn 0;\n}\n\nmodule_init(dnotify_init)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}