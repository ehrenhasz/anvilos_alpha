{
  "module_name": "notification.c",
  "hash_id": "6640578cadb563555708da6ebcf8cb8df05769da93cab708e8b0a8a7e1298bca",
  "original_prompt": "Ingested from linux-6.6.14/fs/notify/notification.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/namei.h>\n#include <linux/path.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <linux/atomic.h>\n\n#include <linux/fsnotify_backend.h>\n#include \"fsnotify.h\"\n\nstatic atomic_t fsnotify_sync_cookie = ATOMIC_INIT(0);\n\n \nu32 fsnotify_get_cookie(void)\n{\n\treturn atomic_inc_return(&fsnotify_sync_cookie);\n}\nEXPORT_SYMBOL_GPL(fsnotify_get_cookie);\n\nvoid fsnotify_destroy_event(struct fsnotify_group *group,\n\t\t\t    struct fsnotify_event *event)\n{\n\t \n\tif (!event || event == group->overflow_event)\n\t\treturn;\n\t \n\tif (!list_empty(&event->list)) {\n\t\tspin_lock(&group->notification_lock);\n\t\tWARN_ON(!list_empty(&event->list));\n\t\tspin_unlock(&group->notification_lock);\n\t}\n\tgroup->ops->free_event(group, event);\n}\n\n \nint fsnotify_insert_event(struct fsnotify_group *group,\n\t\t\t  struct fsnotify_event *event,\n\t\t\t  int (*merge)(struct fsnotify_group *,\n\t\t\t\t       struct fsnotify_event *),\n\t\t\t  void (*insert)(struct fsnotify_group *,\n\t\t\t\t\t struct fsnotify_event *))\n{\n\tint ret = 0;\n\tstruct list_head *list = &group->notification_list;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tspin_lock(&group->notification_lock);\n\n\tif (group->shutdown) {\n\t\tspin_unlock(&group->notification_lock);\n\t\treturn 2;\n\t}\n\n\tif (event == group->overflow_event ||\n\t    group->q_len >= group->max_events) {\n\t\tret = 2;\n\t\t \n\t\tif (!list_empty(&group->overflow_event->list)) {\n\t\t\tspin_unlock(&group->notification_lock);\n\t\t\treturn ret;\n\t\t}\n\t\tevent = group->overflow_event;\n\t\tgoto queue;\n\t}\n\n\tif (!list_empty(list) && merge) {\n\t\tret = merge(group, event);\n\t\tif (ret) {\n\t\t\tspin_unlock(&group->notification_lock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\nqueue:\n\tgroup->q_len++;\n\tlist_add_tail(&event->list, list);\n\tif (insert)\n\t\tinsert(group, event);\n\tspin_unlock(&group->notification_lock);\n\n\twake_up(&group->notification_waitq);\n\tkill_fasync(&group->fsn_fa, SIGIO, POLL_IN);\n\treturn ret;\n}\n\nvoid fsnotify_remove_queued_event(struct fsnotify_group *group,\n\t\t\t\t  struct fsnotify_event *event)\n{\n\tassert_spin_locked(&group->notification_lock);\n\t \n\tlist_del_init(&event->list);\n\tgroup->q_len--;\n}\n\n \nstruct fsnotify_event *fsnotify_peek_first_event(struct fsnotify_group *group)\n{\n\tassert_spin_locked(&group->notification_lock);\n\n\tif (fsnotify_notify_queue_is_empty(group))\n\t\treturn NULL;\n\n\treturn list_first_entry(&group->notification_list,\n\t\t\t\tstruct fsnotify_event, list);\n}\n\n \nstruct fsnotify_event *fsnotify_remove_first_event(struct fsnotify_group *group)\n{\n\tstruct fsnotify_event *event = fsnotify_peek_first_event(group);\n\n\tif (!event)\n\t\treturn NULL;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tfsnotify_remove_queued_event(group, event);\n\n\treturn event;\n}\n\n \nvoid fsnotify_flush_notify(struct fsnotify_group *group)\n{\n\tstruct fsnotify_event *event;\n\n\tspin_lock(&group->notification_lock);\n\twhile (!fsnotify_notify_queue_is_empty(group)) {\n\t\tevent = fsnotify_remove_first_event(group);\n\t\tspin_unlock(&group->notification_lock);\n\t\tfsnotify_destroy_event(group, event);\n\t\tspin_lock(&group->notification_lock);\n\t}\n\tspin_unlock(&group->notification_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}