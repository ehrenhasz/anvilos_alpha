{
  "module_name": "fanotify.c",
  "hash_id": "1f7e6e10f7a37be48d64648b8713ec0d2fdd44b9033f5fa03b8d92e24226f0fd",
  "original_prompt": "Ingested from linux-6.6.14/fs/notify/fanotify/fanotify.c",
  "human_readable_source": "\n#include <linux/fanotify.h>\n#include <linux/fdtable.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>  \n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/sched/user.h>\n#include <linux/sched/signal.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/audit.h>\n#include <linux/sched/mm.h>\n#include <linux/statfs.h>\n#include <linux/stringhash.h>\n\n#include \"fanotify.h\"\n\nstatic bool fanotify_path_equal(const struct path *p1, const struct path *p2)\n{\n\treturn p1->mnt == p2->mnt && p1->dentry == p2->dentry;\n}\n\nstatic unsigned int fanotify_hash_path(const struct path *path)\n{\n\treturn hash_ptr(path->dentry, FANOTIFY_EVENT_HASH_BITS) ^\n\t\thash_ptr(path->mnt, FANOTIFY_EVENT_HASH_BITS);\n}\n\nstatic inline bool fanotify_fsid_equal(__kernel_fsid_t *fsid1,\n\t\t\t\t       __kernel_fsid_t *fsid2)\n{\n\treturn fsid1->val[0] == fsid2->val[0] && fsid1->val[1] == fsid2->val[1];\n}\n\nstatic unsigned int fanotify_hash_fsid(__kernel_fsid_t *fsid)\n{\n\treturn hash_32(fsid->val[0], FANOTIFY_EVENT_HASH_BITS) ^\n\t\thash_32(fsid->val[1], FANOTIFY_EVENT_HASH_BITS);\n}\n\nstatic bool fanotify_fh_equal(struct fanotify_fh *fh1,\n\t\t\t      struct fanotify_fh *fh2)\n{\n\tif (fh1->type != fh2->type || fh1->len != fh2->len)\n\t\treturn false;\n\n\treturn !fh1->len ||\n\t\t!memcmp(fanotify_fh_buf(fh1), fanotify_fh_buf(fh2), fh1->len);\n}\n\nstatic unsigned int fanotify_hash_fh(struct fanotify_fh *fh)\n{\n\tlong salt = (long)fh->type | (long)fh->len << 8;\n\n\t \n\treturn full_name_hash((void *)salt, fanotify_fh_buf(fh), fh->len);\n}\n\nstatic bool fanotify_fid_event_equal(struct fanotify_fid_event *ffe1,\n\t\t\t\t     struct fanotify_fid_event *ffe2)\n{\n\t \n\tif (!ffe1->object_fh.len)\n\t\treturn false;\n\n\treturn fanotify_fsid_equal(&ffe1->fsid, &ffe2->fsid) &&\n\t\tfanotify_fh_equal(&ffe1->object_fh, &ffe2->object_fh);\n}\n\nstatic bool fanotify_info_equal(struct fanotify_info *info1,\n\t\t\t\tstruct fanotify_info *info2)\n{\n\tif (info1->dir_fh_totlen != info2->dir_fh_totlen ||\n\t    info1->dir2_fh_totlen != info2->dir2_fh_totlen ||\n\t    info1->file_fh_totlen != info2->file_fh_totlen ||\n\t    info1->name_len != info2->name_len ||\n\t    info1->name2_len != info2->name2_len)\n\t\treturn false;\n\n\tif (info1->dir_fh_totlen &&\n\t    !fanotify_fh_equal(fanotify_info_dir_fh(info1),\n\t\t\t       fanotify_info_dir_fh(info2)))\n\t\treturn false;\n\n\tif (info1->dir2_fh_totlen &&\n\t    !fanotify_fh_equal(fanotify_info_dir2_fh(info1),\n\t\t\t       fanotify_info_dir2_fh(info2)))\n\t\treturn false;\n\n\tif (info1->file_fh_totlen &&\n\t    !fanotify_fh_equal(fanotify_info_file_fh(info1),\n\t\t\t       fanotify_info_file_fh(info2)))\n\t\treturn false;\n\n\tif (info1->name_len &&\n\t    memcmp(fanotify_info_name(info1), fanotify_info_name(info2),\n\t\t   info1->name_len))\n\t\treturn false;\n\n\treturn !info1->name2_len ||\n\t\t!memcmp(fanotify_info_name2(info1), fanotify_info_name2(info2),\n\t\t\tinfo1->name2_len);\n}\n\nstatic bool fanotify_name_event_equal(struct fanotify_name_event *fne1,\n\t\t\t\t      struct fanotify_name_event *fne2)\n{\n\tstruct fanotify_info *info1 = &fne1->info;\n\tstruct fanotify_info *info2 = &fne2->info;\n\n\t \n\tif (!info1->dir_fh_totlen)\n\t\treturn false;\n\n\tif (!fanotify_fsid_equal(&fne1->fsid, &fne2->fsid))\n\t\treturn false;\n\n\treturn fanotify_info_equal(info1, info2);\n}\n\nstatic bool fanotify_error_event_equal(struct fanotify_error_event *fee1,\n\t\t\t\t       struct fanotify_error_event *fee2)\n{\n\t \n\tif (!fanotify_fsid_equal(&fee1->fsid, &fee2->fsid))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool fanotify_should_merge(struct fanotify_event *old,\n\t\t\t\t  struct fanotify_event *new)\n{\n\tpr_debug(\"%s: old=%p new=%p\\n\", __func__, old, new);\n\n\tif (old->hash != new->hash ||\n\t    old->type != new->type || old->pid != new->pid)\n\t\treturn false;\n\n\t \n\tif ((old->mask & FS_ISDIR) != (new->mask & FS_ISDIR))\n\t\treturn false;\n\n\t \n\tif ((old->mask & FAN_RENAME) != (new->mask & FAN_RENAME))\n\t\treturn false;\n\n\tswitch (old->type) {\n\tcase FANOTIFY_EVENT_TYPE_PATH:\n\t\treturn fanotify_path_equal(fanotify_event_path(old),\n\t\t\t\t\t   fanotify_event_path(new));\n\tcase FANOTIFY_EVENT_TYPE_FID:\n\t\treturn fanotify_fid_event_equal(FANOTIFY_FE(old),\n\t\t\t\t\t\tFANOTIFY_FE(new));\n\tcase FANOTIFY_EVENT_TYPE_FID_NAME:\n\t\treturn fanotify_name_event_equal(FANOTIFY_NE(old),\n\t\t\t\t\t\t FANOTIFY_NE(new));\n\tcase FANOTIFY_EVENT_TYPE_FS_ERROR:\n\t\treturn fanotify_error_event_equal(FANOTIFY_EE(old),\n\t\t\t\t\t\t  FANOTIFY_EE(new));\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\treturn false;\n}\n\n \n#define FANOTIFY_MAX_MERGE_EVENTS 128\n\n \nstatic int fanotify_merge(struct fsnotify_group *group,\n\t\t\t  struct fsnotify_event *event)\n{\n\tstruct fanotify_event *old, *new = FANOTIFY_E(event);\n\tunsigned int bucket = fanotify_event_hash_bucket(group, new);\n\tstruct hlist_head *hlist = &group->fanotify_data.merge_hash[bucket];\n\tint i = 0;\n\n\tpr_debug(\"%s: group=%p event=%p bucket=%u\\n\", __func__,\n\t\t group, event, bucket);\n\n\t \n\tif (fanotify_is_perm_event(new->mask))\n\t\treturn 0;\n\n\thlist_for_each_entry(old, hlist, merge_list) {\n\t\tif (++i > FANOTIFY_MAX_MERGE_EVENTS)\n\t\t\tbreak;\n\t\tif (fanotify_should_merge(old, new)) {\n\t\t\told->mask |= new->mask;\n\n\t\t\tif (fanotify_is_error_event(old->mask))\n\t\t\t\tFANOTIFY_EE(old)->err_count++;\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int fanotify_get_response(struct fsnotify_group *group,\n\t\t\t\t struct fanotify_perm_event *event,\n\t\t\t\t struct fsnotify_iter_info *iter_info)\n{\n\tint ret;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tret = wait_event_killable(group->fanotify_data.access_waitq,\n\t\t\t\t  event->state == FAN_EVENT_ANSWERED);\n\t \n\tif (ret < 0) {\n\t\tspin_lock(&group->notification_lock);\n\t\t \n\t\tif (event->state == FAN_EVENT_REPORTED) {\n\t\t\t \n\t\t\tevent->state = FAN_EVENT_CANCELED;\n\t\t\tspin_unlock(&group->notification_lock);\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tif (event->state == FAN_EVENT_INIT) {\n\t\t\tfsnotify_remove_queued_event(group, &event->fae.fse);\n\t\t\t \n\t\t\tWARN_ON_ONCE(!hlist_unhashed(&event->fae.merge_list));\n\t\t}\n\t\t \n\t\tspin_unlock(&group->notification_lock);\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (event->response & FANOTIFY_RESPONSE_ACCESS) {\n\tcase FAN_ALLOW:\n\t\tret = 0;\n\t\tbreak;\n\tcase FAN_DENY:\n\tdefault:\n\t\tret = -EPERM;\n\t}\n\n\t \n\tif (event->response & FAN_AUDIT)\n\t\taudit_fanotify(event->response & ~FAN_AUDIT,\n\t\t\t       &event->audit_rule);\n\n\tpr_debug(\"%s: group=%p event=%p about to return ret=%d\\n\", __func__,\n\t\t group, event, ret);\nout:\n\tfsnotify_destroy_event(group, &event->fae.fse);\n\n\treturn ret;\n}\n\n \nstatic u32 fanotify_group_event_mask(struct fsnotify_group *group,\n\t\t\t\t     struct fsnotify_iter_info *iter_info,\n\t\t\t\t     u32 *match_mask, u32 event_mask,\n\t\t\t\t     const void *data, int data_type,\n\t\t\t\t     struct inode *dir)\n{\n\t__u32 marks_mask = 0, marks_ignore_mask = 0;\n\t__u32 test_mask, user_mask = FANOTIFY_OUTGOING_EVENTS |\n\t\t\t\t     FANOTIFY_EVENT_FLAGS;\n\tconst struct path *path = fsnotify_data_path(data, data_type);\n\tunsigned int fid_mode = FAN_GROUP_FLAG(group, FANOTIFY_FID_BITS);\n\tstruct fsnotify_mark *mark;\n\tbool ondir = event_mask & FAN_ONDIR;\n\tint type;\n\n\tpr_debug(\"%s: report_mask=%x mask=%x data=%p data_type=%d\\n\",\n\t\t __func__, iter_info->report_mask, event_mask, data, data_type);\n\n\tif (!fid_mode) {\n\t\t \n\t\tif (!path)\n\t\t\treturn 0;\n\t\t \n\t\tif (!d_is_reg(path->dentry) && !d_can_lookup(path->dentry))\n\t\t\treturn 0;\n\t} else if (!(fid_mode & FAN_REPORT_FID)) {\n\t\t \n\t\tif (!dir && !ondir)\n\t\t\treturn 0;\n\t}\n\n\tfsnotify_foreach_iter_mark_type(iter_info, mark, type) {\n\t\t \n\t\tmarks_ignore_mask |=\n\t\t\tfsnotify_effective_ignore_mask(mark, ondir, type);\n\n\t\t \n\t\tif (!fsnotify_mask_applicable(mark->mask, ondir, type))\n\t\t\tcontinue;\n\n\t\tmarks_mask |= mark->mask;\n\n\t\t \n\t\t*match_mask |= 1U << type;\n\t}\n\n\ttest_mask = event_mask & marks_mask & ~marks_ignore_mask;\n\n\t \n\tif (fid_mode) {\n\t\t \n\t\tif (!(test_mask & ~FANOTIFY_EVENT_FLAGS))\n\t\t\treturn 0;\n\t} else {\n\t\tuser_mask &= ~FANOTIFY_EVENT_FLAGS;\n\t}\n\n\treturn test_mask & user_mask;\n}\n\n \nstatic int fanotify_encode_fh_len(struct inode *inode)\n{\n\tint dwords = 0;\n\tint fh_len;\n\n\tif (!inode)\n\t\treturn 0;\n\n\texportfs_encode_fid(inode, NULL, &dwords);\n\tfh_len = dwords << 2;\n\n\t \n\tif (WARN_ON_ONCE(fh_len > MAX_HANDLE_SZ))\n\t\treturn 0;\n\n\treturn fh_len;\n}\n\n \nstatic int fanotify_encode_fh(struct fanotify_fh *fh, struct inode *inode,\n\t\t\t      unsigned int fh_len, unsigned int *hash,\n\t\t\t      gfp_t gfp)\n{\n\tint dwords, type = 0;\n\tchar *ext_buf = NULL;\n\tvoid *buf = fh->buf;\n\tint err;\n\n\tfh->type = FILEID_ROOT;\n\tfh->len = 0;\n\tfh->flags = 0;\n\n\t \n\tif (!inode)\n\t\tgoto out;\n\n\t \n\terr = -ENOENT;\n\tif (fh_len < 4 || WARN_ON_ONCE(fh_len % 4) || fh_len > MAX_HANDLE_SZ)\n\t\tgoto out_err;\n\n\t \n\tif (gfp && fh_len > FANOTIFY_INLINE_FH_LEN) {\n\t\t \n\t\terr = -ENOMEM;\n\t\text_buf = kmalloc(fh_len, gfp);\n\t\tif (!ext_buf)\n\t\t\tgoto out_err;\n\n\t\t*fanotify_fh_ext_buf_ptr(fh) = ext_buf;\n\t\tbuf = ext_buf;\n\t\tfh->flags |= FANOTIFY_FH_FLAG_EXT_BUF;\n\t}\n\n\tdwords = fh_len >> 2;\n\ttype = exportfs_encode_fid(inode, buf, &dwords);\n\terr = -EINVAL;\n\tif (type <= 0 || type == FILEID_INVALID || fh_len != dwords << 2)\n\t\tgoto out_err;\n\n\tfh->type = type;\n\tfh->len = fh_len;\n\nout:\n\t \n\tif (hash)\n\t\t*hash ^= fanotify_hash_fh(fh);\n\n\treturn FANOTIFY_FH_HDR_LEN + fh_len;\n\nout_err:\n\tpr_warn_ratelimited(\"fanotify: failed to encode fid (type=%d, len=%d, err=%i)\\n\",\n\t\t\t    type, fh_len, err);\n\tkfree(ext_buf);\n\t*fanotify_fh_ext_buf_ptr(fh) = NULL;\n\t \n\tfh->type = FILEID_INVALID;\n\tfh->len = 0;\n\treturn 0;\n}\n\n \nstatic inline bool fanotify_report_child_fid(unsigned int fid_mode, u32 mask)\n{\n\tif (mask & ALL_FSNOTIFY_DIRENT_EVENTS)\n\t\treturn (fid_mode & FAN_REPORT_TARGET_FID);\n\n\treturn (fid_mode & FAN_REPORT_FID) && !(mask & FAN_ONDIR);\n}\n\n \nstatic struct inode *fanotify_fid_inode(u32 event_mask, const void *data,\n\t\t\t\t\tint data_type, struct inode *dir,\n\t\t\t\t\tunsigned int fid_mode)\n{\n\tif ((event_mask & ALL_FSNOTIFY_DIRENT_EVENTS) &&\n\t    !(fid_mode & FAN_REPORT_TARGET_FID))\n\t\treturn dir;\n\n\treturn fsnotify_data_inode(data, data_type);\n}\n\n \nstatic struct inode *fanotify_dfid_inode(u32 event_mask, const void *data,\n\t\t\t\t\t int data_type, struct inode *dir)\n{\n\tstruct inode *inode = fsnotify_data_inode(data, data_type);\n\n\tif (event_mask & ALL_FSNOTIFY_DIRENT_EVENTS)\n\t\treturn dir;\n\n\tif (inode && S_ISDIR(inode->i_mode))\n\t\treturn inode;\n\n\treturn dir;\n}\n\nstatic struct fanotify_event *fanotify_alloc_path_event(const struct path *path,\n\t\t\t\t\t\t\tunsigned int *hash,\n\t\t\t\t\t\t\tgfp_t gfp)\n{\n\tstruct fanotify_path_event *pevent;\n\n\tpevent = kmem_cache_alloc(fanotify_path_event_cachep, gfp);\n\tif (!pevent)\n\t\treturn NULL;\n\n\tpevent->fae.type = FANOTIFY_EVENT_TYPE_PATH;\n\tpevent->path = *path;\n\t*hash ^= fanotify_hash_path(path);\n\tpath_get(path);\n\n\treturn &pevent->fae;\n}\n\nstatic struct fanotify_event *fanotify_alloc_perm_event(const struct path *path,\n\t\t\t\t\t\t\tgfp_t gfp)\n{\n\tstruct fanotify_perm_event *pevent;\n\n\tpevent = kmem_cache_alloc(fanotify_perm_event_cachep, gfp);\n\tif (!pevent)\n\t\treturn NULL;\n\n\tpevent->fae.type = FANOTIFY_EVENT_TYPE_PATH_PERM;\n\tpevent->response = 0;\n\tpevent->hdr.type = FAN_RESPONSE_INFO_NONE;\n\tpevent->hdr.pad = 0;\n\tpevent->hdr.len = 0;\n\tpevent->state = FAN_EVENT_INIT;\n\tpevent->path = *path;\n\tpath_get(path);\n\n\treturn &pevent->fae;\n}\n\nstatic struct fanotify_event *fanotify_alloc_fid_event(struct inode *id,\n\t\t\t\t\t\t       __kernel_fsid_t *fsid,\n\t\t\t\t\t\t       unsigned int *hash,\n\t\t\t\t\t\t       gfp_t gfp)\n{\n\tstruct fanotify_fid_event *ffe;\n\n\tffe = kmem_cache_alloc(fanotify_fid_event_cachep, gfp);\n\tif (!ffe)\n\t\treturn NULL;\n\n\tffe->fae.type = FANOTIFY_EVENT_TYPE_FID;\n\tffe->fsid = *fsid;\n\t*hash ^= fanotify_hash_fsid(fsid);\n\tfanotify_encode_fh(&ffe->object_fh, id, fanotify_encode_fh_len(id),\n\t\t\t   hash, gfp);\n\n\treturn &ffe->fae;\n}\n\nstatic struct fanotify_event *fanotify_alloc_name_event(struct inode *dir,\n\t\t\t\t\t\t\t__kernel_fsid_t *fsid,\n\t\t\t\t\t\t\tconst struct qstr *name,\n\t\t\t\t\t\t\tstruct inode *child,\n\t\t\t\t\t\t\tstruct dentry *moved,\n\t\t\t\t\t\t\tunsigned int *hash,\n\t\t\t\t\t\t\tgfp_t gfp)\n{\n\tstruct fanotify_name_event *fne;\n\tstruct fanotify_info *info;\n\tstruct fanotify_fh *dfh, *ffh;\n\tstruct inode *dir2 = moved ? d_inode(moved->d_parent) : NULL;\n\tconst struct qstr *name2 = moved ? &moved->d_name : NULL;\n\tunsigned int dir_fh_len = fanotify_encode_fh_len(dir);\n\tunsigned int dir2_fh_len = fanotify_encode_fh_len(dir2);\n\tunsigned int child_fh_len = fanotify_encode_fh_len(child);\n\tunsigned long name_len = name ? name->len : 0;\n\tunsigned long name2_len = name2 ? name2->len : 0;\n\tunsigned int len, size;\n\n\t \n\tsize = sizeof(*fne) + name_len + name2_len + 2;\n\tif (dir_fh_len)\n\t\tsize += FANOTIFY_FH_HDR_LEN + dir_fh_len;\n\tif (dir2_fh_len)\n\t\tsize += FANOTIFY_FH_HDR_LEN + dir2_fh_len;\n\tif (child_fh_len)\n\t\tsize += FANOTIFY_FH_HDR_LEN + child_fh_len;\n\tfne = kmalloc(size, gfp);\n\tif (!fne)\n\t\treturn NULL;\n\n\tfne->fae.type = FANOTIFY_EVENT_TYPE_FID_NAME;\n\tfne->fsid = *fsid;\n\t*hash ^= fanotify_hash_fsid(fsid);\n\tinfo = &fne->info;\n\tfanotify_info_init(info);\n\tif (dir_fh_len) {\n\t\tdfh = fanotify_info_dir_fh(info);\n\t\tlen = fanotify_encode_fh(dfh, dir, dir_fh_len, hash, 0);\n\t\tfanotify_info_set_dir_fh(info, len);\n\t}\n\tif (dir2_fh_len) {\n\t\tdfh = fanotify_info_dir2_fh(info);\n\t\tlen = fanotify_encode_fh(dfh, dir2, dir2_fh_len, hash, 0);\n\t\tfanotify_info_set_dir2_fh(info, len);\n\t}\n\tif (child_fh_len) {\n\t\tffh = fanotify_info_file_fh(info);\n\t\tlen = fanotify_encode_fh(ffh, child, child_fh_len, hash, 0);\n\t\tfanotify_info_set_file_fh(info, len);\n\t}\n\tif (name_len) {\n\t\tfanotify_info_copy_name(info, name);\n\t\t*hash ^= full_name_hash((void *)name_len, name->name, name_len);\n\t}\n\tif (name2_len) {\n\t\tfanotify_info_copy_name2(info, name2);\n\t\t*hash ^= full_name_hash((void *)name2_len, name2->name,\n\t\t\t\t\tname2_len);\n\t}\n\n\tpr_debug(\"%s: size=%u dir_fh_len=%u child_fh_len=%u name_len=%u name='%.*s'\\n\",\n\t\t __func__, size, dir_fh_len, child_fh_len,\n\t\t info->name_len, info->name_len, fanotify_info_name(info));\n\n\tif (dir2_fh_len) {\n\t\tpr_debug(\"%s: dir2_fh_len=%u name2_len=%u name2='%.*s'\\n\",\n\t\t\t __func__, dir2_fh_len, info->name2_len,\n\t\t\t info->name2_len, fanotify_info_name2(info));\n\t}\n\n\treturn &fne->fae;\n}\n\nstatic struct fanotify_event *fanotify_alloc_error_event(\n\t\t\t\t\t\tstruct fsnotify_group *group,\n\t\t\t\t\t\t__kernel_fsid_t *fsid,\n\t\t\t\t\t\tconst void *data, int data_type,\n\t\t\t\t\t\tunsigned int *hash)\n{\n\tstruct fs_error_report *report =\n\t\t\tfsnotify_data_error_report(data, data_type);\n\tstruct inode *inode;\n\tstruct fanotify_error_event *fee;\n\tint fh_len;\n\n\tif (WARN_ON_ONCE(!report))\n\t\treturn NULL;\n\n\tfee = mempool_alloc(&group->fanotify_data.error_events_pool, GFP_NOFS);\n\tif (!fee)\n\t\treturn NULL;\n\n\tfee->fae.type = FANOTIFY_EVENT_TYPE_FS_ERROR;\n\tfee->error = report->error;\n\tfee->err_count = 1;\n\tfee->fsid = *fsid;\n\n\tinode = report->inode;\n\tfh_len = fanotify_encode_fh_len(inode);\n\n\t \n\tif (!fh_len && inode)\n\t\tinode = NULL;\n\n\tfanotify_encode_fh(&fee->object_fh, inode, fh_len, NULL, 0);\n\n\t*hash ^= fanotify_hash_fsid(fsid);\n\n\treturn &fee->fae;\n}\n\nstatic struct fanotify_event *fanotify_alloc_event(\n\t\t\t\tstruct fsnotify_group *group,\n\t\t\t\tu32 mask, const void *data, int data_type,\n\t\t\t\tstruct inode *dir, const struct qstr *file_name,\n\t\t\t\t__kernel_fsid_t *fsid, u32 match_mask)\n{\n\tstruct fanotify_event *event = NULL;\n\tgfp_t gfp = GFP_KERNEL_ACCOUNT;\n\tunsigned int fid_mode = FAN_GROUP_FLAG(group, FANOTIFY_FID_BITS);\n\tstruct inode *id = fanotify_fid_inode(mask, data, data_type, dir,\n\t\t\t\t\t      fid_mode);\n\tstruct inode *dirid = fanotify_dfid_inode(mask, data, data_type, dir);\n\tconst struct path *path = fsnotify_data_path(data, data_type);\n\tstruct mem_cgroup *old_memcg;\n\tstruct dentry *moved = NULL;\n\tstruct inode *child = NULL;\n\tbool name_event = false;\n\tunsigned int hash = 0;\n\tbool ondir = mask & FAN_ONDIR;\n\tstruct pid *pid;\n\n\tif ((fid_mode & FAN_REPORT_DIR_FID) && dirid) {\n\t\t \n\t\tif (fanotify_report_child_fid(fid_mode, mask) && id != dirid)\n\t\t\tchild = id;\n\n\t\tid = dirid;\n\n\t\t \n\t\tif (!(fid_mode & FAN_REPORT_NAME)) {\n\t\t\tname_event = !!child;\n\t\t\tfile_name = NULL;\n\t\t} else if ((mask & ALL_FSNOTIFY_DIRENT_EVENTS) || !ondir) {\n\t\t\tname_event = true;\n\t\t}\n\n\t\t \n\t\tif (mask & FAN_RENAME) {\n\t\t\tbool report_old, report_new;\n\n\t\t\tif (WARN_ON_ONCE(!match_mask))\n\t\t\t\treturn NULL;\n\n\t\t\t \n\t\t\treport_old = report_new =\n\t\t\t\tmatch_mask & (1U << FSNOTIFY_ITER_TYPE_SB);\n\t\t\treport_old |=\n\t\t\t\tmatch_mask & (1U << FSNOTIFY_ITER_TYPE_INODE);\n\t\t\treport_new |=\n\t\t\t\tmatch_mask & (1U << FSNOTIFY_ITER_TYPE_INODE2);\n\n\t\t\tif (!report_old) {\n\t\t\t\t \n\t\t\t\tdirid = NULL;\n\t\t\t\tfile_name = NULL;\n\t\t\t}\n\t\t\tif (report_new) {\n\t\t\t\t \n\t\t\t\tmoved = fsnotify_data_dentry(data, data_type);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (group->max_events == UINT_MAX)\n\t\tgfp |= __GFP_NOFAIL;\n\telse\n\t\tgfp |= __GFP_RETRY_MAYFAIL;\n\n\t \n\told_memcg = set_active_memcg(group->memcg);\n\n\tif (fanotify_is_perm_event(mask)) {\n\t\tevent = fanotify_alloc_perm_event(path, gfp);\n\t} else if (fanotify_is_error_event(mask)) {\n\t\tevent = fanotify_alloc_error_event(group, fsid, data,\n\t\t\t\t\t\t   data_type, &hash);\n\t} else if (name_event && (file_name || moved || child)) {\n\t\tevent = fanotify_alloc_name_event(dirid, fsid, file_name, child,\n\t\t\t\t\t\t  moved, &hash, gfp);\n\t} else if (fid_mode) {\n\t\tevent = fanotify_alloc_fid_event(id, fsid, &hash, gfp);\n\t} else {\n\t\tevent = fanotify_alloc_path_event(path, &hash, gfp);\n\t}\n\n\tif (!event)\n\t\tgoto out;\n\n\tif (FAN_GROUP_FLAG(group, FAN_REPORT_TID))\n\t\tpid = get_pid(task_pid(current));\n\telse\n\t\tpid = get_pid(task_tgid(current));\n\n\t \n\thash ^= hash_long((unsigned long)pid | ondir, FANOTIFY_EVENT_HASH_BITS);\n\tfanotify_init_event(event, hash, mask);\n\tevent->pid = pid;\n\nout:\n\tset_active_memcg(old_memcg);\n\treturn event;\n}\n\n \nstatic __kernel_fsid_t fanotify_get_fsid(struct fsnotify_iter_info *iter_info)\n{\n\tstruct fsnotify_mark *mark;\n\tint type;\n\t__kernel_fsid_t fsid = {};\n\n\tfsnotify_foreach_iter_mark_type(iter_info, mark, type) {\n\t\tstruct fsnotify_mark_connector *conn;\n\n\t\tconn = READ_ONCE(mark->connector);\n\t\t \n\t\tif (!conn)\n\t\t\tcontinue;\n\t\tif (!(conn->flags & FSNOTIFY_CONN_FLAG_HAS_FSID))\n\t\t\tcontinue;\n\t\t \n\t\tsmp_rmb();\n\t\tfsid = conn->fsid;\n\t\tif (WARN_ON_ONCE(!fsid.val[0] && !fsid.val[1]))\n\t\t\tcontinue;\n\t\treturn fsid;\n\t}\n\n\treturn fsid;\n}\n\n \nstatic void fanotify_insert_event(struct fsnotify_group *group,\n\t\t\t\t  struct fsnotify_event *fsn_event)\n{\n\tstruct fanotify_event *event = FANOTIFY_E(fsn_event);\n\tunsigned int bucket = fanotify_event_hash_bucket(group, event);\n\tstruct hlist_head *hlist = &group->fanotify_data.merge_hash[bucket];\n\n\tassert_spin_locked(&group->notification_lock);\n\n\tif (!fanotify_is_hashed_event(event->mask))\n\t\treturn;\n\n\tpr_debug(\"%s: group=%p event=%p bucket=%u\\n\", __func__,\n\t\t group, event, bucket);\n\n\thlist_add_head(&event->merge_list, hlist);\n}\n\nstatic int fanotify_handle_event(struct fsnotify_group *group, u32 mask,\n\t\t\t\t const void *data, int data_type,\n\t\t\t\t struct inode *dir,\n\t\t\t\t const struct qstr *file_name, u32 cookie,\n\t\t\t\t struct fsnotify_iter_info *iter_info)\n{\n\tint ret = 0;\n\tstruct fanotify_event *event;\n\tstruct fsnotify_event *fsn_event;\n\t__kernel_fsid_t fsid = {};\n\tu32 match_mask = 0;\n\n\tBUILD_BUG_ON(FAN_ACCESS != FS_ACCESS);\n\tBUILD_BUG_ON(FAN_MODIFY != FS_MODIFY);\n\tBUILD_BUG_ON(FAN_ATTRIB != FS_ATTRIB);\n\tBUILD_BUG_ON(FAN_CLOSE_NOWRITE != FS_CLOSE_NOWRITE);\n\tBUILD_BUG_ON(FAN_CLOSE_WRITE != FS_CLOSE_WRITE);\n\tBUILD_BUG_ON(FAN_OPEN != FS_OPEN);\n\tBUILD_BUG_ON(FAN_MOVED_TO != FS_MOVED_TO);\n\tBUILD_BUG_ON(FAN_MOVED_FROM != FS_MOVED_FROM);\n\tBUILD_BUG_ON(FAN_CREATE != FS_CREATE);\n\tBUILD_BUG_ON(FAN_DELETE != FS_DELETE);\n\tBUILD_BUG_ON(FAN_DELETE_SELF != FS_DELETE_SELF);\n\tBUILD_BUG_ON(FAN_MOVE_SELF != FS_MOVE_SELF);\n\tBUILD_BUG_ON(FAN_EVENT_ON_CHILD != FS_EVENT_ON_CHILD);\n\tBUILD_BUG_ON(FAN_Q_OVERFLOW != FS_Q_OVERFLOW);\n\tBUILD_BUG_ON(FAN_OPEN_PERM != FS_OPEN_PERM);\n\tBUILD_BUG_ON(FAN_ACCESS_PERM != FS_ACCESS_PERM);\n\tBUILD_BUG_ON(FAN_ONDIR != FS_ISDIR);\n\tBUILD_BUG_ON(FAN_OPEN_EXEC != FS_OPEN_EXEC);\n\tBUILD_BUG_ON(FAN_OPEN_EXEC_PERM != FS_OPEN_EXEC_PERM);\n\tBUILD_BUG_ON(FAN_FS_ERROR != FS_ERROR);\n\tBUILD_BUG_ON(FAN_RENAME != FS_RENAME);\n\n\tBUILD_BUG_ON(HWEIGHT32(ALL_FANOTIFY_EVENT_BITS) != 21);\n\n\tmask = fanotify_group_event_mask(group, iter_info, &match_mask,\n\t\t\t\t\t mask, data, data_type, dir);\n\tif (!mask)\n\t\treturn 0;\n\n\tpr_debug(\"%s: group=%p mask=%x report_mask=%x\\n\", __func__,\n\t\t group, mask, match_mask);\n\n\tif (fanotify_is_perm_event(mask)) {\n\t\t \n\t\tif (!fsnotify_prepare_user_wait(iter_info))\n\t\t\treturn 0;\n\t}\n\n\tif (FAN_GROUP_FLAG(group, FANOTIFY_FID_BITS)) {\n\t\tfsid = fanotify_get_fsid(iter_info);\n\t\t \n\t\tif (!fsid.val[0] && !fsid.val[1])\n\t\t\treturn 0;\n\t}\n\n\tevent = fanotify_alloc_event(group, mask, data, data_type, dir,\n\t\t\t\t     file_name, &fsid, match_mask);\n\tret = -ENOMEM;\n\tif (unlikely(!event)) {\n\t\t \n\t\tif (!fanotify_is_perm_event(mask))\n\t\t\tfsnotify_queue_overflow(group);\n\t\tgoto finish;\n\t}\n\n\tfsn_event = &event->fse;\n\tret = fsnotify_insert_event(group, fsn_event, fanotify_merge,\n\t\t\t\t    fanotify_insert_event);\n\tif (ret) {\n\t\t \n\t\tBUG_ON(ret == 1 && mask & FANOTIFY_PERM_EVENTS);\n\t\t \n\t\tfsnotify_destroy_event(group, fsn_event);\n\n\t\tret = 0;\n\t} else if (fanotify_is_perm_event(mask)) {\n\t\tret = fanotify_get_response(group, FANOTIFY_PERM(event),\n\t\t\t\t\t    iter_info);\n\t}\nfinish:\n\tif (fanotify_is_perm_event(mask))\n\t\tfsnotify_finish_user_wait(iter_info);\n\n\treturn ret;\n}\n\nstatic void fanotify_free_group_priv(struct fsnotify_group *group)\n{\n\tkfree(group->fanotify_data.merge_hash);\n\tif (group->fanotify_data.ucounts)\n\t\tdec_ucount(group->fanotify_data.ucounts,\n\t\t\t   UCOUNT_FANOTIFY_GROUPS);\n\n\tif (mempool_initialized(&group->fanotify_data.error_events_pool))\n\t\tmempool_exit(&group->fanotify_data.error_events_pool);\n}\n\nstatic void fanotify_free_path_event(struct fanotify_event *event)\n{\n\tpath_put(fanotify_event_path(event));\n\tkmem_cache_free(fanotify_path_event_cachep, FANOTIFY_PE(event));\n}\n\nstatic void fanotify_free_perm_event(struct fanotify_event *event)\n{\n\tpath_put(fanotify_event_path(event));\n\tkmem_cache_free(fanotify_perm_event_cachep, FANOTIFY_PERM(event));\n}\n\nstatic void fanotify_free_fid_event(struct fanotify_event *event)\n{\n\tstruct fanotify_fid_event *ffe = FANOTIFY_FE(event);\n\n\tif (fanotify_fh_has_ext_buf(&ffe->object_fh))\n\t\tkfree(fanotify_fh_ext_buf(&ffe->object_fh));\n\tkmem_cache_free(fanotify_fid_event_cachep, ffe);\n}\n\nstatic void fanotify_free_name_event(struct fanotify_event *event)\n{\n\tkfree(FANOTIFY_NE(event));\n}\n\nstatic void fanotify_free_error_event(struct fsnotify_group *group,\n\t\t\t\t      struct fanotify_event *event)\n{\n\tstruct fanotify_error_event *fee = FANOTIFY_EE(event);\n\n\tmempool_free(fee, &group->fanotify_data.error_events_pool);\n}\n\nstatic void fanotify_free_event(struct fsnotify_group *group,\n\t\t\t\tstruct fsnotify_event *fsn_event)\n{\n\tstruct fanotify_event *event;\n\n\tevent = FANOTIFY_E(fsn_event);\n\tput_pid(event->pid);\n\tswitch (event->type) {\n\tcase FANOTIFY_EVENT_TYPE_PATH:\n\t\tfanotify_free_path_event(event);\n\t\tbreak;\n\tcase FANOTIFY_EVENT_TYPE_PATH_PERM:\n\t\tfanotify_free_perm_event(event);\n\t\tbreak;\n\tcase FANOTIFY_EVENT_TYPE_FID:\n\t\tfanotify_free_fid_event(event);\n\t\tbreak;\n\tcase FANOTIFY_EVENT_TYPE_FID_NAME:\n\t\tfanotify_free_name_event(event);\n\t\tbreak;\n\tcase FANOTIFY_EVENT_TYPE_OVERFLOW:\n\t\tkfree(event);\n\t\tbreak;\n\tcase FANOTIFY_EVENT_TYPE_FS_ERROR:\n\t\tfanotify_free_error_event(group, event);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n}\n\nstatic void fanotify_freeing_mark(struct fsnotify_mark *mark,\n\t\t\t\t  struct fsnotify_group *group)\n{\n\tif (!FAN_GROUP_FLAG(group, FAN_UNLIMITED_MARKS))\n\t\tdec_ucount(group->fanotify_data.ucounts, UCOUNT_FANOTIFY_MARKS);\n}\n\nstatic void fanotify_free_mark(struct fsnotify_mark *fsn_mark)\n{\n\tkmem_cache_free(fanotify_mark_cache, fsn_mark);\n}\n\nconst struct fsnotify_ops fanotify_fsnotify_ops = {\n\t.handle_event = fanotify_handle_event,\n\t.free_group_priv = fanotify_free_group_priv,\n\t.free_event = fanotify_free_event,\n\t.freeing_mark = fanotify_freeing_mark,\n\t.free_mark = fanotify_free_mark,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}