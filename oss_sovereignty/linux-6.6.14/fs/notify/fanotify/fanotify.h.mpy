{
  "module_name": "fanotify.h",
  "hash_id": "d3c37b67f2558e69aa524366c71dfc2aad9801fa984b7afd1fec38855ca47f37",
  "original_prompt": "Ingested from linux-6.6.14/fs/notify/fanotify/fanotify.h",
  "human_readable_source": " \n#include <linux/fsnotify_backend.h>\n#include <linux/path.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/hashtable.h>\n\nextern struct kmem_cache *fanotify_mark_cache;\nextern struct kmem_cache *fanotify_fid_event_cachep;\nextern struct kmem_cache *fanotify_path_event_cachep;\nextern struct kmem_cache *fanotify_perm_event_cachep;\n\n \nenum {\n\tFAN_EVENT_INIT,\n\tFAN_EVENT_REPORTED,\n\tFAN_EVENT_ANSWERED,\n\tFAN_EVENT_CANCELED,\n};\n\n \n#define FANOTIFY_INLINE_FH_LEN\t(3 << 2)\n#define FANOTIFY_FH_HDR_LEN\toffsetof(struct fanotify_fh, buf)\n\n \nstruct fanotify_fh {\n\tu8 type;\n\tu8 len;\n#define FANOTIFY_FH_FLAG_EXT_BUF 1\n\tu8 flags;\n\tu8 pad;\n\tunsigned char buf[];\n} __aligned(4);\n\n \nstruct fanotify_info {\n\t \n\tu8 dir_fh_totlen;\n\tu8 dir2_fh_totlen;\n\tu8 file_fh_totlen;\n\tu8 name_len;\n\tu8 name2_len;\n\tu8 pad[3];\n\tunsigned char buf[];\n\t \n#define FANOTIFY_DIR_FH_SIZE(info)\t((info)->dir_fh_totlen)\n#define FANOTIFY_DIR2_FH_SIZE(info)\t((info)->dir2_fh_totlen)\n#define FANOTIFY_FILE_FH_SIZE(info)\t((info)->file_fh_totlen)\n#define FANOTIFY_NAME_SIZE(info)\t((info)->name_len + 1)\n#define FANOTIFY_NAME2_SIZE(info)\t((info)->name2_len + 1)\n\n#define FANOTIFY_DIR_FH_OFFSET(info)\t0\n#define FANOTIFY_DIR2_FH_OFFSET(info) \\\n\t(FANOTIFY_DIR_FH_OFFSET(info) + FANOTIFY_DIR_FH_SIZE(info))\n#define FANOTIFY_FILE_FH_OFFSET(info) \\\n\t(FANOTIFY_DIR2_FH_OFFSET(info) + FANOTIFY_DIR2_FH_SIZE(info))\n#define FANOTIFY_NAME_OFFSET(info) \\\n\t(FANOTIFY_FILE_FH_OFFSET(info) + FANOTIFY_FILE_FH_SIZE(info))\n#define FANOTIFY_NAME2_OFFSET(info) \\\n\t(FANOTIFY_NAME_OFFSET(info) + FANOTIFY_NAME_SIZE(info))\n\n#define FANOTIFY_DIR_FH_BUF(info) \\\n\t((info)->buf + FANOTIFY_DIR_FH_OFFSET(info))\n#define FANOTIFY_DIR2_FH_BUF(info) \\\n\t((info)->buf + FANOTIFY_DIR2_FH_OFFSET(info))\n#define FANOTIFY_FILE_FH_BUF(info) \\\n\t((info)->buf + FANOTIFY_FILE_FH_OFFSET(info))\n#define FANOTIFY_NAME_BUF(info) \\\n\t((info)->buf + FANOTIFY_NAME_OFFSET(info))\n#define FANOTIFY_NAME2_BUF(info) \\\n\t((info)->buf + FANOTIFY_NAME2_OFFSET(info))\n} __aligned(4);\n\nstatic inline bool fanotify_fh_has_ext_buf(struct fanotify_fh *fh)\n{\n\treturn (fh->flags & FANOTIFY_FH_FLAG_EXT_BUF);\n}\n\nstatic inline char **fanotify_fh_ext_buf_ptr(struct fanotify_fh *fh)\n{\n\tBUILD_BUG_ON(FANOTIFY_FH_HDR_LEN % 4);\n\tBUILD_BUG_ON(__alignof__(char *) - 4 + sizeof(char *) >\n\t\t     FANOTIFY_INLINE_FH_LEN);\n\treturn (char **)ALIGN((unsigned long)(fh->buf), __alignof__(char *));\n}\n\nstatic inline void *fanotify_fh_ext_buf(struct fanotify_fh *fh)\n{\n\treturn *fanotify_fh_ext_buf_ptr(fh);\n}\n\nstatic inline void *fanotify_fh_buf(struct fanotify_fh *fh)\n{\n\treturn fanotify_fh_has_ext_buf(fh) ? fanotify_fh_ext_buf(fh) : fh->buf;\n}\n\nstatic inline int fanotify_info_dir_fh_len(struct fanotify_info *info)\n{\n\tif (!info->dir_fh_totlen ||\n\t    WARN_ON_ONCE(info->dir_fh_totlen < FANOTIFY_FH_HDR_LEN))\n\t\treturn 0;\n\n\treturn info->dir_fh_totlen - FANOTIFY_FH_HDR_LEN;\n}\n\nstatic inline struct fanotify_fh *fanotify_info_dir_fh(struct fanotify_info *info)\n{\n\tBUILD_BUG_ON(offsetof(struct fanotify_info, buf) % 4);\n\n\treturn (struct fanotify_fh *)FANOTIFY_DIR_FH_BUF(info);\n}\n\nstatic inline int fanotify_info_dir2_fh_len(struct fanotify_info *info)\n{\n\tif (!info->dir2_fh_totlen ||\n\t    WARN_ON_ONCE(info->dir2_fh_totlen < FANOTIFY_FH_HDR_LEN))\n\t\treturn 0;\n\n\treturn info->dir2_fh_totlen - FANOTIFY_FH_HDR_LEN;\n}\n\nstatic inline struct fanotify_fh *fanotify_info_dir2_fh(struct fanotify_info *info)\n{\n\treturn (struct fanotify_fh *)FANOTIFY_DIR2_FH_BUF(info);\n}\n\nstatic inline int fanotify_info_file_fh_len(struct fanotify_info *info)\n{\n\tif (!info->file_fh_totlen ||\n\t    WARN_ON_ONCE(info->file_fh_totlen < FANOTIFY_FH_HDR_LEN))\n\t\treturn 0;\n\n\treturn info->file_fh_totlen - FANOTIFY_FH_HDR_LEN;\n}\n\nstatic inline struct fanotify_fh *fanotify_info_file_fh(struct fanotify_info *info)\n{\n\treturn (struct fanotify_fh *)FANOTIFY_FILE_FH_BUF(info);\n}\n\nstatic inline char *fanotify_info_name(struct fanotify_info *info)\n{\n\tif (!info->name_len)\n\t\treturn NULL;\n\n\treturn FANOTIFY_NAME_BUF(info);\n}\n\nstatic inline char *fanotify_info_name2(struct fanotify_info *info)\n{\n\tif (!info->name2_len)\n\t\treturn NULL;\n\n\treturn FANOTIFY_NAME2_BUF(info);\n}\n\nstatic inline void fanotify_info_init(struct fanotify_info *info)\n{\n\tBUILD_BUG_ON(FANOTIFY_FH_HDR_LEN + MAX_HANDLE_SZ > U8_MAX);\n\tBUILD_BUG_ON(NAME_MAX > U8_MAX);\n\n\tinfo->dir_fh_totlen = 0;\n\tinfo->dir2_fh_totlen = 0;\n\tinfo->file_fh_totlen = 0;\n\tinfo->name_len = 0;\n\tinfo->name2_len = 0;\n}\n\n \nstatic inline void fanotify_info_set_dir_fh(struct fanotify_info *info,\n\t\t\t\t\t    unsigned int totlen)\n{\n\tif (WARN_ON_ONCE(info->dir2_fh_totlen > 0) ||\n\t    WARN_ON_ONCE(info->file_fh_totlen > 0) ||\n\t    WARN_ON_ONCE(info->name_len > 0) ||\n\t    WARN_ON_ONCE(info->name2_len > 0))\n\t\treturn;\n\n\tinfo->dir_fh_totlen = totlen;\n}\n\nstatic inline void fanotify_info_set_dir2_fh(struct fanotify_info *info,\n\t\t\t\t\t     unsigned int totlen)\n{\n\tif (WARN_ON_ONCE(info->file_fh_totlen > 0) ||\n\t    WARN_ON_ONCE(info->name_len > 0) ||\n\t    WARN_ON_ONCE(info->name2_len > 0))\n\t\treturn;\n\n\tinfo->dir2_fh_totlen = totlen;\n}\n\nstatic inline void fanotify_info_set_file_fh(struct fanotify_info *info,\n\t\t\t\t\t     unsigned int totlen)\n{\n\tif (WARN_ON_ONCE(info->name_len > 0) ||\n\t    WARN_ON_ONCE(info->name2_len > 0))\n\t\treturn;\n\n\tinfo->file_fh_totlen = totlen;\n}\n\nstatic inline void fanotify_info_copy_name(struct fanotify_info *info,\n\t\t\t\t\t   const struct qstr *name)\n{\n\tif (WARN_ON_ONCE(name->len > NAME_MAX) ||\n\t    WARN_ON_ONCE(info->name2_len > 0))\n\t\treturn;\n\n\tinfo->name_len = name->len;\n\tstrcpy(fanotify_info_name(info), name->name);\n}\n\nstatic inline void fanotify_info_copy_name2(struct fanotify_info *info,\n\t\t\t\t\t    const struct qstr *name)\n{\n\tif (WARN_ON_ONCE(name->len > NAME_MAX))\n\t\treturn;\n\n\tinfo->name2_len = name->len;\n\tstrcpy(fanotify_info_name2(info), name->name);\n}\n\n \nenum fanotify_event_type {\n\tFANOTIFY_EVENT_TYPE_FID,  \n\tFANOTIFY_EVENT_TYPE_FID_NAME,  \n\tFANOTIFY_EVENT_TYPE_PATH,\n\tFANOTIFY_EVENT_TYPE_PATH_PERM,\n\tFANOTIFY_EVENT_TYPE_OVERFLOW,  \n\tFANOTIFY_EVENT_TYPE_FS_ERROR,  \n\t__FANOTIFY_EVENT_TYPE_NUM\n};\n\n#define FANOTIFY_EVENT_TYPE_BITS \\\n\t(ilog2(__FANOTIFY_EVENT_TYPE_NUM - 1) + 1)\n#define FANOTIFY_EVENT_HASH_BITS \\\n\t(32 - FANOTIFY_EVENT_TYPE_BITS)\n\nstruct fanotify_event {\n\tstruct fsnotify_event fse;\n\tstruct hlist_node merge_list;\t \n\tu32 mask;\n\tstruct {\n\t\tunsigned int type : FANOTIFY_EVENT_TYPE_BITS;\n\t\tunsigned int hash : FANOTIFY_EVENT_HASH_BITS;\n\t};\n\tstruct pid *pid;\n};\n\nstatic inline void fanotify_init_event(struct fanotify_event *event,\n\t\t\t\t       unsigned int hash, u32 mask)\n{\n\tfsnotify_init_event(&event->fse);\n\tINIT_HLIST_NODE(&event->merge_list);\n\tevent->hash = hash;\n\tevent->mask = mask;\n\tevent->pid = NULL;\n}\n\n#define FANOTIFY_INLINE_FH(name, size)\t\t\t\t\t\\\nstruct {\t\t\t\t\t\t\t\t\\\n\tstruct fanotify_fh (name);\t\t\t\t\t\\\n\t \t\\\n\tunsigned char _inline_fh_buf[(size)];\t\t\t\t\\\n}\n\nstruct fanotify_fid_event {\n\tstruct fanotify_event fae;\n\t__kernel_fsid_t fsid;\n\n\tFANOTIFY_INLINE_FH(object_fh, FANOTIFY_INLINE_FH_LEN);\n};\n\nstatic inline struct fanotify_fid_event *\nFANOTIFY_FE(struct fanotify_event *event)\n{\n\treturn container_of(event, struct fanotify_fid_event, fae);\n}\n\nstruct fanotify_name_event {\n\tstruct fanotify_event fae;\n\t__kernel_fsid_t fsid;\n\tstruct fanotify_info info;\n};\n\nstatic inline struct fanotify_name_event *\nFANOTIFY_NE(struct fanotify_event *event)\n{\n\treturn container_of(event, struct fanotify_name_event, fae);\n}\n\nstruct fanotify_error_event {\n\tstruct fanotify_event fae;\n\ts32 error;  \n\tu32 err_count;  \n\n\t__kernel_fsid_t fsid;  \n\n\tFANOTIFY_INLINE_FH(object_fh, MAX_HANDLE_SZ);\n};\n\nstatic inline struct fanotify_error_event *\nFANOTIFY_EE(struct fanotify_event *event)\n{\n\treturn container_of(event, struct fanotify_error_event, fae);\n}\n\nstatic inline __kernel_fsid_t *fanotify_event_fsid(struct fanotify_event *event)\n{\n\tif (event->type == FANOTIFY_EVENT_TYPE_FID)\n\t\treturn &FANOTIFY_FE(event)->fsid;\n\telse if (event->type == FANOTIFY_EVENT_TYPE_FID_NAME)\n\t\treturn &FANOTIFY_NE(event)->fsid;\n\telse if (event->type == FANOTIFY_EVENT_TYPE_FS_ERROR)\n\t\treturn &FANOTIFY_EE(event)->fsid;\n\telse\n\t\treturn NULL;\n}\n\nstatic inline struct fanotify_fh *fanotify_event_object_fh(\n\t\t\t\t\t\tstruct fanotify_event *event)\n{\n\tif (event->type == FANOTIFY_EVENT_TYPE_FID)\n\t\treturn &FANOTIFY_FE(event)->object_fh;\n\telse if (event->type == FANOTIFY_EVENT_TYPE_FID_NAME)\n\t\treturn fanotify_info_file_fh(&FANOTIFY_NE(event)->info);\n\telse if (event->type == FANOTIFY_EVENT_TYPE_FS_ERROR)\n\t\treturn &FANOTIFY_EE(event)->object_fh;\n\telse\n\t\treturn NULL;\n}\n\nstatic inline struct fanotify_info *fanotify_event_info(\n\t\t\t\t\t\tstruct fanotify_event *event)\n{\n\tif (event->type == FANOTIFY_EVENT_TYPE_FID_NAME)\n\t\treturn &FANOTIFY_NE(event)->info;\n\telse\n\t\treturn NULL;\n}\n\nstatic inline int fanotify_event_object_fh_len(struct fanotify_event *event)\n{\n\tstruct fanotify_info *info = fanotify_event_info(event);\n\tstruct fanotify_fh *fh = fanotify_event_object_fh(event);\n\n\tif (info)\n\t\treturn info->file_fh_totlen ? fh->len : 0;\n\telse\n\t\treturn fh ? fh->len : 0;\n}\n\nstatic inline int fanotify_event_dir_fh_len(struct fanotify_event *event)\n{\n\tstruct fanotify_info *info = fanotify_event_info(event);\n\n\treturn info ? fanotify_info_dir_fh_len(info) : 0;\n}\n\nstatic inline int fanotify_event_dir2_fh_len(struct fanotify_event *event)\n{\n\tstruct fanotify_info *info = fanotify_event_info(event);\n\n\treturn info ? fanotify_info_dir2_fh_len(info) : 0;\n}\n\nstatic inline bool fanotify_event_has_object_fh(struct fanotify_event *event)\n{\n\t \n\tif (event->type == FANOTIFY_EVENT_TYPE_FS_ERROR)\n\t\treturn true;\n\treturn fanotify_event_object_fh_len(event) > 0;\n}\n\nstatic inline bool fanotify_event_has_dir_fh(struct fanotify_event *event)\n{\n\treturn fanotify_event_dir_fh_len(event) > 0;\n}\n\nstatic inline bool fanotify_event_has_dir2_fh(struct fanotify_event *event)\n{\n\treturn fanotify_event_dir2_fh_len(event) > 0;\n}\n\nstatic inline bool fanotify_event_has_any_dir_fh(struct fanotify_event *event)\n{\n\treturn fanotify_event_has_dir_fh(event) ||\n\t\tfanotify_event_has_dir2_fh(event);\n}\n\nstruct fanotify_path_event {\n\tstruct fanotify_event fae;\n\tstruct path path;\n};\n\nstatic inline struct fanotify_path_event *\nFANOTIFY_PE(struct fanotify_event *event)\n{\n\treturn container_of(event, struct fanotify_path_event, fae);\n}\n\n \nstruct fanotify_perm_event {\n\tstruct fanotify_event fae;\n\tstruct path path;\n\tu32 response;\t\t\t \n\tunsigned short state;\t\t \n\tint fd;\t\t \n\tunion {\n\t\tstruct fanotify_response_info_header hdr;\n\t\tstruct fanotify_response_info_audit_rule audit_rule;\n\t};\n};\n\nstatic inline struct fanotify_perm_event *\nFANOTIFY_PERM(struct fanotify_event *event)\n{\n\treturn container_of(event, struct fanotify_perm_event, fae);\n}\n\nstatic inline bool fanotify_is_perm_event(u32 mask)\n{\n\treturn IS_ENABLED(CONFIG_FANOTIFY_ACCESS_PERMISSIONS) &&\n\t\tmask & FANOTIFY_PERM_EVENTS;\n}\n\nstatic inline struct fanotify_event *FANOTIFY_E(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct fanotify_event, fse);\n}\n\nstatic inline bool fanotify_is_error_event(u32 mask)\n{\n\treturn mask & FAN_FS_ERROR;\n}\n\nstatic inline const struct path *fanotify_event_path(struct fanotify_event *event)\n{\n\tif (event->type == FANOTIFY_EVENT_TYPE_PATH)\n\t\treturn &FANOTIFY_PE(event)->path;\n\telse if (event->type == FANOTIFY_EVENT_TYPE_PATH_PERM)\n\t\treturn &FANOTIFY_PERM(event)->path;\n\telse\n\t\treturn NULL;\n}\n\n \n#define FANOTIFY_HTABLE_BITS\t(7)\n#define FANOTIFY_HTABLE_SIZE\t(1 << FANOTIFY_HTABLE_BITS)\n#define FANOTIFY_HTABLE_MASK\t(FANOTIFY_HTABLE_SIZE - 1)\n\n \nstatic inline bool fanotify_is_hashed_event(u32 mask)\n{\n\treturn !(fanotify_is_perm_event(mask) ||\n\t\t fsnotify_is_overflow_event(mask));\n}\n\nstatic inline unsigned int fanotify_event_hash_bucket(\n\t\t\t\t\t\tstruct fsnotify_group *group,\n\t\t\t\t\t\tstruct fanotify_event *event)\n{\n\treturn event->hash & FANOTIFY_HTABLE_MASK;\n}\n\nstatic inline unsigned int fanotify_mark_user_flags(struct fsnotify_mark *mark)\n{\n\tunsigned int mflags = 0;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY)\n\t\tmflags |= FAN_MARK_IGNORED_SURV_MODIFY;\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_NO_IREF)\n\t\tmflags |= FAN_MARK_EVICTABLE;\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_HAS_IGNORE_FLAGS)\n\t\tmflags |= FAN_MARK_IGNORE;\n\n\treturn mflags;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}