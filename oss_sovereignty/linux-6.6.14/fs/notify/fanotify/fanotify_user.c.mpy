{
  "module_name": "fanotify_user.c",
  "hash_id": "1e088475071aada94ffa2f43e03507d2ad410514cc39b9fac2ac32ee4a8cb471",
  "original_prompt": "Ingested from linux-6.6.14/fs/notify/fanotify/fanotify_user.c",
  "human_readable_source": "\n#include <linux/fanotify.h>\n#include <linux/fcntl.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/anon_inodes.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/poll.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/sched/signal.h>\n#include <linux/memcontrol.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n\n#include <asm/ioctls.h>\n\n#include \"../../mount.h\"\n#include \"../fdinfo.h\"\n#include \"fanotify.h\"\n\n#define FANOTIFY_DEFAULT_MAX_EVENTS\t16384\n#define FANOTIFY_OLD_DEFAULT_MAX_MARKS\t8192\n#define FANOTIFY_DEFAULT_MAX_GROUPS\t128\n#define FANOTIFY_DEFAULT_FEE_POOL_SIZE\t32\n\n \n#define FANOTIFY_DEFAULT_MAX_USER_MARKS\t\\\n\t(FANOTIFY_OLD_DEFAULT_MAX_MARKS * FANOTIFY_DEFAULT_MAX_GROUPS)\n\n \n#define INODE_MARK_COST\t(2 * sizeof(struct inode))\n\n \nstatic int fanotify_max_queued_events __read_mostly;\n\n#ifdef CONFIG_SYSCTL\n\n#include <linux/sysctl.h>\n\nstatic long ft_zero = 0;\nstatic long ft_int_max = INT_MAX;\n\nstatic struct ctl_table fanotify_table[] = {\n\t{\n\t\t.procname\t= \"max_user_groups\",\n\t\t.data\t= &init_user_ns.ucount_max[UCOUNT_FANOTIFY_GROUPS],\n\t\t.maxlen\t\t= sizeof(long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t\t.extra1\t\t= &ft_zero,\n\t\t.extra2\t\t= &ft_int_max,\n\t},\n\t{\n\t\t.procname\t= \"max_user_marks\",\n\t\t.data\t= &init_user_ns.ucount_max[UCOUNT_FANOTIFY_MARKS],\n\t\t.maxlen\t\t= sizeof(long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t\t.extra1\t\t= &ft_zero,\n\t\t.extra2\t\t= &ft_int_max,\n\t},\n\t{\n\t\t.procname\t= \"max_queued_events\",\n\t\t.data\t\t= &fanotify_max_queued_events,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO\n\t},\n\t{ }\n};\n\nstatic void __init fanotify_sysctls_init(void)\n{\n\tregister_sysctl(\"fs/fanotify\", fanotify_table);\n}\n#else\n#define fanotify_sysctls_init() do { } while (0)\n#endif  \n\n \n#define\tFANOTIFY_INIT_ALL_EVENT_F_BITS\t\t\t\t( \\\n\t\tO_ACCMODE\t| O_APPEND\t| O_NONBLOCK\t| \\\n\t\t__O_SYNC\t| O_DSYNC\t| O_CLOEXEC     | \\\n\t\tO_LARGEFILE\t| O_NOATIME\t)\n\nextern const struct fsnotify_ops fanotify_fsnotify_ops;\n\nstruct kmem_cache *fanotify_mark_cache __read_mostly;\nstruct kmem_cache *fanotify_fid_event_cachep __read_mostly;\nstruct kmem_cache *fanotify_path_event_cachep __read_mostly;\nstruct kmem_cache *fanotify_perm_event_cachep __read_mostly;\n\n#define FANOTIFY_EVENT_ALIGN 4\n#define FANOTIFY_FID_INFO_HDR_LEN \\\n\t(sizeof(struct fanotify_event_info_fid) + sizeof(struct file_handle))\n#define FANOTIFY_PIDFD_INFO_HDR_LEN \\\n\tsizeof(struct fanotify_event_info_pidfd)\n#define FANOTIFY_ERROR_INFO_LEN \\\n\t(sizeof(struct fanotify_event_info_error))\n\nstatic int fanotify_fid_info_len(int fh_len, int name_len)\n{\n\tint info_len = fh_len;\n\n\tif (name_len)\n\t\tinfo_len += name_len + 1;\n\n\treturn roundup(FANOTIFY_FID_INFO_HDR_LEN + info_len,\n\t\t       FANOTIFY_EVENT_ALIGN);\n}\n\n \nstatic int fanotify_dir_name_info_len(struct fanotify_event *event)\n{\n\tstruct fanotify_info *info = fanotify_event_info(event);\n\tint dir_fh_len = fanotify_event_dir_fh_len(event);\n\tint dir2_fh_len = fanotify_event_dir2_fh_len(event);\n\tint info_len = 0;\n\n\tif (dir_fh_len)\n\t\tinfo_len += fanotify_fid_info_len(dir_fh_len,\n\t\t\t\t\t\t  info->name_len);\n\tif (dir2_fh_len)\n\t\tinfo_len += fanotify_fid_info_len(dir2_fh_len,\n\t\t\t\t\t\t  info->name2_len);\n\n\treturn info_len;\n}\n\nstatic size_t fanotify_event_len(unsigned int info_mode,\n\t\t\t\t struct fanotify_event *event)\n{\n\tsize_t event_len = FAN_EVENT_METADATA_LEN;\n\tint fh_len;\n\tint dot_len = 0;\n\n\tif (!info_mode)\n\t\treturn event_len;\n\n\tif (fanotify_is_error_event(event->mask))\n\t\tevent_len += FANOTIFY_ERROR_INFO_LEN;\n\n\tif (fanotify_event_has_any_dir_fh(event)) {\n\t\tevent_len += fanotify_dir_name_info_len(event);\n\t} else if ((info_mode & FAN_REPORT_NAME) &&\n\t\t   (event->mask & FAN_ONDIR)) {\n\t\t \n\t\tdot_len = 1;\n\t}\n\n\tif (info_mode & FAN_REPORT_PIDFD)\n\t\tevent_len += FANOTIFY_PIDFD_INFO_HDR_LEN;\n\n\tif (fanotify_event_has_object_fh(event)) {\n\t\tfh_len = fanotify_event_object_fh_len(event);\n\t\tevent_len += fanotify_fid_info_len(fh_len, dot_len);\n\t}\n\n\treturn event_len;\n}\n\n \nstatic void fanotify_unhash_event(struct fsnotify_group *group,\n\t\t\t\t  struct fanotify_event *event)\n{\n\tassert_spin_locked(&group->notification_lock);\n\n\tpr_debug(\"%s: group=%p event=%p bucket=%u\\n\", __func__,\n\t\t group, event, fanotify_event_hash_bucket(group, event));\n\n\tif (WARN_ON_ONCE(hlist_unhashed(&event->merge_list)))\n\t\treturn;\n\n\thlist_del_init(&event->merge_list);\n}\n\n \nstatic struct fanotify_event *get_one_event(struct fsnotify_group *group,\n\t\t\t\t\t    size_t count)\n{\n\tsize_t event_size;\n\tstruct fanotify_event *event = NULL;\n\tstruct fsnotify_event *fsn_event;\n\tunsigned int info_mode = FAN_GROUP_FLAG(group, FANOTIFY_INFO_MODES);\n\n\tpr_debug(\"%s: group=%p count=%zd\\n\", __func__, group, count);\n\n\tspin_lock(&group->notification_lock);\n\tfsn_event = fsnotify_peek_first_event(group);\n\tif (!fsn_event)\n\t\tgoto out;\n\n\tevent = FANOTIFY_E(fsn_event);\n\tevent_size = fanotify_event_len(info_mode, event);\n\n\tif (event_size > count) {\n\t\tevent = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\t \n\tfsnotify_remove_first_event(group);\n\tif (fanotify_is_perm_event(event->mask))\n\t\tFANOTIFY_PERM(event)->state = FAN_EVENT_REPORTED;\n\tif (fanotify_is_hashed_event(event->mask))\n\t\tfanotify_unhash_event(group, event);\nout:\n\tspin_unlock(&group->notification_lock);\n\treturn event;\n}\n\nstatic int create_fd(struct fsnotify_group *group, const struct path *path,\n\t\t     struct file **file)\n{\n\tint client_fd;\n\tstruct file *new_file;\n\n\tclient_fd = get_unused_fd_flags(group->fanotify_data.f_flags);\n\tif (client_fd < 0)\n\t\treturn client_fd;\n\n\t \n\tnew_file = dentry_open(path,\n\t\t\t       group->fanotify_data.f_flags | __FMODE_NONOTIFY,\n\t\t\t       current_cred());\n\tif (IS_ERR(new_file)) {\n\t\t \n\t\tput_unused_fd(client_fd);\n\t\tclient_fd = PTR_ERR(new_file);\n\t} else {\n\t\t*file = new_file;\n\t}\n\n\treturn client_fd;\n}\n\nstatic int process_access_response_info(const char __user *info,\n\t\t\t\t\tsize_t info_len,\n\t\t\t\tstruct fanotify_response_info_audit_rule *friar)\n{\n\tif (info_len != sizeof(*friar))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(friar, info, sizeof(*friar)))\n\t\treturn -EFAULT;\n\n\tif (friar->hdr.type != FAN_RESPONSE_INFO_AUDIT_RULE)\n\t\treturn -EINVAL;\n\tif (friar->hdr.pad != 0)\n\t\treturn -EINVAL;\n\tif (friar->hdr.len != sizeof(*friar))\n\t\treturn -EINVAL;\n\n\treturn info_len;\n}\n\n \nstatic void finish_permission_event(struct fsnotify_group *group,\n\t\t\t\t    struct fanotify_perm_event *event, u32 response,\n\t\t\t\t    struct fanotify_response_info_audit_rule *friar)\n\t\t\t\t    __releases(&group->notification_lock)\n{\n\tbool destroy = false;\n\n\tassert_spin_locked(&group->notification_lock);\n\tevent->response = response & ~FAN_INFO;\n\tif (response & FAN_INFO)\n\t\tmemcpy(&event->audit_rule, friar, sizeof(*friar));\n\n\tif (event->state == FAN_EVENT_CANCELED)\n\t\tdestroy = true;\n\telse\n\t\tevent->state = FAN_EVENT_ANSWERED;\n\tspin_unlock(&group->notification_lock);\n\tif (destroy)\n\t\tfsnotify_destroy_event(group, &event->fae.fse);\n}\n\nstatic int process_access_response(struct fsnotify_group *group,\n\t\t\t\t   struct fanotify_response *response_struct,\n\t\t\t\t   const char __user *info,\n\t\t\t\t   size_t info_len)\n{\n\tstruct fanotify_perm_event *event;\n\tint fd = response_struct->fd;\n\tu32 response = response_struct->response;\n\tint ret = info_len;\n\tstruct fanotify_response_info_audit_rule friar;\n\n\tpr_debug(\"%s: group=%p fd=%d response=%u buf=%p size=%zu\\n\", __func__,\n\t\t group, fd, response, info, info_len);\n\t \n\tif (response & ~FANOTIFY_RESPONSE_VALID_MASK)\n\t\treturn -EINVAL;\n\n\tswitch (response & FANOTIFY_RESPONSE_ACCESS) {\n\tcase FAN_ALLOW:\n\tcase FAN_DENY:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((response & FAN_AUDIT) && !FAN_GROUP_FLAG(group, FAN_ENABLE_AUDIT))\n\t\treturn -EINVAL;\n\n\tif (response & FAN_INFO) {\n\t\tret = process_access_response_info(info, info_len, &friar);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (fd == FAN_NOFD)\n\t\t\treturn ret;\n\t} else {\n\t\tret = 0;\n\t}\n\n\tif (fd < 0)\n\t\treturn -EINVAL;\n\n\tspin_lock(&group->notification_lock);\n\tlist_for_each_entry(event, &group->fanotify_data.access_list,\n\t\t\t    fae.fse.list) {\n\t\tif (event->fd != fd)\n\t\t\tcontinue;\n\n\t\tlist_del_init(&event->fae.fse.list);\n\t\tfinish_permission_event(group, event, response, &friar);\n\t\twake_up(&group->fanotify_data.access_waitq);\n\t\treturn ret;\n\t}\n\tspin_unlock(&group->notification_lock);\n\n\treturn -ENOENT;\n}\n\nstatic size_t copy_error_info_to_user(struct fanotify_event *event,\n\t\t\t\t      char __user *buf, int count)\n{\n\tstruct fanotify_event_info_error info = { };\n\tstruct fanotify_error_event *fee = FANOTIFY_EE(event);\n\n\tinfo.hdr.info_type = FAN_EVENT_INFO_TYPE_ERROR;\n\tinfo.hdr.len = FANOTIFY_ERROR_INFO_LEN;\n\n\tif (WARN_ON(count < info.hdr.len))\n\t\treturn -EFAULT;\n\n\tinfo.error = fee->error;\n\tinfo.error_count = fee->err_count;\n\n\tif (copy_to_user(buf, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\n\treturn info.hdr.len;\n}\n\nstatic int copy_fid_info_to_user(__kernel_fsid_t *fsid, struct fanotify_fh *fh,\n\t\t\t\t int info_type, const char *name,\n\t\t\t\t size_t name_len,\n\t\t\t\t char __user *buf, size_t count)\n{\n\tstruct fanotify_event_info_fid info = { };\n\tstruct file_handle handle = { };\n\tunsigned char bounce[FANOTIFY_INLINE_FH_LEN], *fh_buf;\n\tsize_t fh_len = fh ? fh->len : 0;\n\tsize_t info_len = fanotify_fid_info_len(fh_len, name_len);\n\tsize_t len = info_len;\n\n\tpr_debug(\"%s: fh_len=%zu name_len=%zu, info_len=%zu, count=%zu\\n\",\n\t\t __func__, fh_len, name_len, info_len, count);\n\n\tif (WARN_ON_ONCE(len < sizeof(info) || len > count))\n\t\treturn -EFAULT;\n\n\t \n\tswitch (info_type) {\n\tcase FAN_EVENT_INFO_TYPE_FID:\n\tcase FAN_EVENT_INFO_TYPE_DFID:\n\t\tif (WARN_ON_ONCE(name_len))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase FAN_EVENT_INFO_TYPE_DFID_NAME:\n\tcase FAN_EVENT_INFO_TYPE_OLD_DFID_NAME:\n\tcase FAN_EVENT_INFO_TYPE_NEW_DFID_NAME:\n\t\tif (WARN_ON_ONCE(!name || !name_len))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EFAULT;\n\t}\n\n\tinfo.hdr.info_type = info_type;\n\tinfo.hdr.len = len;\n\tinfo.fsid = *fsid;\n\tif (copy_to_user(buf, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tbuf += sizeof(info);\n\tlen -= sizeof(info);\n\tif (WARN_ON_ONCE(len < sizeof(handle)))\n\t\treturn -EFAULT;\n\n\thandle.handle_type = fh->type;\n\thandle.handle_bytes = fh_len;\n\n\t \n\tif (!fh_len)\n\t\thandle.handle_type = FILEID_INVALID;\n\n\tif (copy_to_user(buf, &handle, sizeof(handle)))\n\t\treturn -EFAULT;\n\n\tbuf += sizeof(handle);\n\tlen -= sizeof(handle);\n\tif (WARN_ON_ONCE(len < fh_len))\n\t\treturn -EFAULT;\n\n\t \n\tfh_buf = fanotify_fh_buf(fh);\n\tif (fh_len <= FANOTIFY_INLINE_FH_LEN) {\n\t\tmemcpy(bounce, fh_buf, fh_len);\n\t\tfh_buf = bounce;\n\t}\n\tif (copy_to_user(buf, fh_buf, fh_len))\n\t\treturn -EFAULT;\n\n\tbuf += fh_len;\n\tlen -= fh_len;\n\n\tif (name_len) {\n\t\t \n\t\tname_len++;\n\t\tif (WARN_ON_ONCE(len < name_len))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_to_user(buf, name, name_len))\n\t\t\treturn -EFAULT;\n\n\t\tbuf += name_len;\n\t\tlen -= name_len;\n\t}\n\n\t \n\tWARN_ON_ONCE(len < 0 || len >= FANOTIFY_EVENT_ALIGN);\n\tif (len > 0 && clear_user(buf, len))\n\t\treturn -EFAULT;\n\n\treturn info_len;\n}\n\nstatic int copy_pidfd_info_to_user(int pidfd,\n\t\t\t\t   char __user *buf,\n\t\t\t\t   size_t count)\n{\n\tstruct fanotify_event_info_pidfd info = { };\n\tsize_t info_len = FANOTIFY_PIDFD_INFO_HDR_LEN;\n\n\tif (WARN_ON_ONCE(info_len > count))\n\t\treturn -EFAULT;\n\n\tinfo.hdr.info_type = FAN_EVENT_INFO_TYPE_PIDFD;\n\tinfo.hdr.len = info_len;\n\tinfo.pidfd = pidfd;\n\n\tif (copy_to_user(buf, &info, info_len))\n\t\treturn -EFAULT;\n\n\treturn info_len;\n}\n\nstatic int copy_info_records_to_user(struct fanotify_event *event,\n\t\t\t\t     struct fanotify_info *info,\n\t\t\t\t     unsigned int info_mode, int pidfd,\n\t\t\t\t     char __user *buf, size_t count)\n{\n\tint ret, total_bytes = 0, info_type = 0;\n\tunsigned int fid_mode = info_mode & FANOTIFY_FID_BITS;\n\tunsigned int pidfd_mode = info_mode & FAN_REPORT_PIDFD;\n\n\t \n\tif (fanotify_event_has_dir_fh(event)) {\n\t\tinfo_type = info->name_len ? FAN_EVENT_INFO_TYPE_DFID_NAME :\n\t\t\t\t\t     FAN_EVENT_INFO_TYPE_DFID;\n\n\t\t \n\t\tif (event->mask & FAN_RENAME)\n\t\t\tinfo_type = FAN_EVENT_INFO_TYPE_OLD_DFID_NAME;\n\n\t\tret = copy_fid_info_to_user(fanotify_event_fsid(event),\n\t\t\t\t\t    fanotify_info_dir_fh(info),\n\t\t\t\t\t    info_type,\n\t\t\t\t\t    fanotify_info_name(info),\n\t\t\t\t\t    info->name_len, buf, count);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbuf += ret;\n\t\tcount -= ret;\n\t\ttotal_bytes += ret;\n\t}\n\n\t \n\tif (fanotify_event_has_dir2_fh(event)) {\n\t\tinfo_type = FAN_EVENT_INFO_TYPE_NEW_DFID_NAME;\n\t\tret = copy_fid_info_to_user(fanotify_event_fsid(event),\n\t\t\t\t\t    fanotify_info_dir2_fh(info),\n\t\t\t\t\t    info_type,\n\t\t\t\t\t    fanotify_info_name2(info),\n\t\t\t\t\t    info->name2_len, buf, count);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbuf += ret;\n\t\tcount -= ret;\n\t\ttotal_bytes += ret;\n\t}\n\n\tif (fanotify_event_has_object_fh(event)) {\n\t\tconst char *dot = NULL;\n\t\tint dot_len = 0;\n\n\t\tif (fid_mode == FAN_REPORT_FID || info_type) {\n\t\t\t \n\t\t\tinfo_type = FAN_EVENT_INFO_TYPE_FID;\n\t\t} else if ((fid_mode & FAN_REPORT_NAME) &&\n\t\t\t   (event->mask & FAN_ONDIR)) {\n\t\t\t \n\t\t\tinfo_type = FAN_EVENT_INFO_TYPE_DFID_NAME;\n\t\t\tdot = \".\";\n\t\t\tdot_len = 1;\n\t\t} else if ((event->mask & ALL_FSNOTIFY_DIRENT_EVENTS) ||\n\t\t\t   (event->mask & FAN_ONDIR)) {\n\t\t\t \n\t\t\tinfo_type = FAN_EVENT_INFO_TYPE_DFID;\n\t\t} else {\n\t\t\t \n\t\t\tinfo_type = FAN_EVENT_INFO_TYPE_FID;\n\t\t}\n\n\t\tret = copy_fid_info_to_user(fanotify_event_fsid(event),\n\t\t\t\t\t    fanotify_event_object_fh(event),\n\t\t\t\t\t    info_type, dot, dot_len,\n\t\t\t\t\t    buf, count);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbuf += ret;\n\t\tcount -= ret;\n\t\ttotal_bytes += ret;\n\t}\n\n\tif (pidfd_mode) {\n\t\tret = copy_pidfd_info_to_user(pidfd, buf, count);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbuf += ret;\n\t\tcount -= ret;\n\t\ttotal_bytes += ret;\n\t}\n\n\tif (fanotify_is_error_event(event->mask)) {\n\t\tret = copy_error_info_to_user(event, buf, count);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbuf += ret;\n\t\tcount -= ret;\n\t\ttotal_bytes += ret;\n\t}\n\n\treturn total_bytes;\n}\n\nstatic ssize_t copy_event_to_user(struct fsnotify_group *group,\n\t\t\t\t  struct fanotify_event *event,\n\t\t\t\t  char __user *buf, size_t count)\n{\n\tstruct fanotify_event_metadata metadata;\n\tconst struct path *path = fanotify_event_path(event);\n\tstruct fanotify_info *info = fanotify_event_info(event);\n\tunsigned int info_mode = FAN_GROUP_FLAG(group, FANOTIFY_INFO_MODES);\n\tunsigned int pidfd_mode = info_mode & FAN_REPORT_PIDFD;\n\tstruct file *f = NULL, *pidfd_file = NULL;\n\tint ret, pidfd = FAN_NOPIDFD, fd = FAN_NOFD;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tmetadata.event_len = fanotify_event_len(info_mode, event);\n\tmetadata.metadata_len = FAN_EVENT_METADATA_LEN;\n\tmetadata.vers = FANOTIFY_METADATA_VERSION;\n\tmetadata.reserved = 0;\n\tmetadata.mask = event->mask & FANOTIFY_OUTGOING_EVENTS;\n\tmetadata.pid = pid_vnr(event->pid);\n\t \n\tif (FAN_GROUP_FLAG(group, FANOTIFY_UNPRIV) &&\n\t    task_tgid(current) != event->pid)\n\t\tmetadata.pid = 0;\n\n\t \n\tif (!FAN_GROUP_FLAG(group, FANOTIFY_UNPRIV) &&\n\t    path && path->mnt && path->dentry) {\n\t\tfd = create_fd(group, path, &f);\n\t\tif (fd < 0)\n\t\t\treturn fd;\n\t}\n\tmetadata.fd = fd;\n\n\tif (pidfd_mode) {\n\t\t \n\t\tWARN_ON_ONCE(FAN_GROUP_FLAG(group, FAN_REPORT_TID));\n\n\t\t \n\t\tif (metadata.pid == 0 ||\n\t\t    !pid_has_task(event->pid, PIDTYPE_TGID)) {\n\t\t\tpidfd = FAN_NOPIDFD;\n\t\t} else {\n\t\t\tpidfd = pidfd_prepare(event->pid, 0, &pidfd_file);\n\t\t\tif (pidfd < 0)\n\t\t\t\tpidfd = FAN_EPIDFD;\n\t\t}\n\t}\n\n\tret = -EFAULT;\n\t \n\tif (WARN_ON_ONCE(metadata.event_len > count))\n\t\tgoto out_close_fd;\n\n\tif (copy_to_user(buf, &metadata, FAN_EVENT_METADATA_LEN))\n\t\tgoto out_close_fd;\n\n\tbuf += FAN_EVENT_METADATA_LEN;\n\tcount -= FAN_EVENT_METADATA_LEN;\n\n\tif (fanotify_is_perm_event(event->mask))\n\t\tFANOTIFY_PERM(event)->fd = fd;\n\n\tif (info_mode) {\n\t\tret = copy_info_records_to_user(event, info, info_mode, pidfd,\n\t\t\t\t\t\tbuf, count);\n\t\tif (ret < 0)\n\t\t\tgoto out_close_fd;\n\t}\n\n\tif (f)\n\t\tfd_install(fd, f);\n\n\tif (pidfd_file)\n\t\tfd_install(pidfd, pidfd_file);\n\n\treturn metadata.event_len;\n\nout_close_fd:\n\tif (fd != FAN_NOFD) {\n\t\tput_unused_fd(fd);\n\t\tfput(f);\n\t}\n\n\tif (pidfd >= 0) {\n\t\tput_unused_fd(pidfd);\n\t\tfput(pidfd_file);\n\t}\n\n\treturn ret;\n}\n\n \nstatic __poll_t fanotify_poll(struct file *file, poll_table *wait)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\t__poll_t ret = 0;\n\n\tpoll_wait(file, &group->notification_waitq, wait);\n\tspin_lock(&group->notification_lock);\n\tif (!fsnotify_notify_queue_is_empty(group))\n\t\tret = EPOLLIN | EPOLLRDNORM;\n\tspin_unlock(&group->notification_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t fanotify_read(struct file *file, char __user *buf,\n\t\t\t     size_t count, loff_t *pos)\n{\n\tstruct fsnotify_group *group;\n\tstruct fanotify_event *event;\n\tchar __user *start;\n\tint ret;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tstart = buf;\n\tgroup = file->private_data;\n\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\n\tadd_wait_queue(&group->notification_waitq, &wait);\n\twhile (1) {\n\t\t \n\t\tcond_resched();\n\t\tevent = get_one_event(group, count);\n\t\tif (IS_ERR(event)) {\n\t\t\tret = PTR_ERR(event);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!event) {\n\t\t\tret = -EAGAIN;\n\t\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\t\tbreak;\n\n\t\t\tret = -ERESTARTSYS;\n\t\t\tif (signal_pending(current))\n\t\t\t\tbreak;\n\n\t\t\tif (start != buf)\n\t\t\t\tbreak;\n\n\t\t\twait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = copy_event_to_user(group, event, buf, count);\n\t\tif (unlikely(ret == -EOPENSTALE)) {\n\t\t\t \n\t\t\tret = 0;\n\t\t}\n\n\t\t \n\t\tif (!fanotify_is_perm_event(event->mask)) {\n\t\t\tfsnotify_destroy_event(group, &event->fse);\n\t\t} else {\n\t\t\tif (ret <= 0) {\n\t\t\t\tspin_lock(&group->notification_lock);\n\t\t\t\tfinish_permission_event(group,\n\t\t\t\t\tFANOTIFY_PERM(event), FAN_DENY, NULL);\n\t\t\t\twake_up(&group->fanotify_data.access_waitq);\n\t\t\t} else {\n\t\t\t\tspin_lock(&group->notification_lock);\n\t\t\t\tlist_add_tail(&event->fse.list,\n\t\t\t\t\t&group->fanotify_data.access_list);\n\t\t\t\tspin_unlock(&group->notification_lock);\n\t\t\t}\n\t\t}\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tbuf += ret;\n\t\tcount -= ret;\n\t}\n\tremove_wait_queue(&group->notification_waitq, &wait);\n\n\tif (start != buf && ret != -EFAULT)\n\t\tret = buf - start;\n\treturn ret;\n}\n\nstatic ssize_t fanotify_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\n{\n\tstruct fanotify_response response;\n\tstruct fsnotify_group *group;\n\tint ret;\n\tconst char __user *info_buf = buf + sizeof(struct fanotify_response);\n\tsize_t info_len;\n\n\tif (!IS_ENABLED(CONFIG_FANOTIFY_ACCESS_PERMISSIONS))\n\t\treturn -EINVAL;\n\n\tgroup = file->private_data;\n\n\tpr_debug(\"%s: group=%p count=%zu\\n\", __func__, group, count);\n\n\tif (count < sizeof(response))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&response, buf, sizeof(response)))\n\t\treturn -EFAULT;\n\n\tinfo_len = count - sizeof(response);\n\n\tret = process_access_response(group, &response, info_buf, info_len);\n\tif (ret < 0)\n\t\tcount = ret;\n\telse\n\t\tcount = sizeof(response) + ret;\n\n\treturn count;\n}\n\nstatic int fanotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\tstruct fsnotify_event *fsn_event;\n\n\t \n\tfsnotify_group_stop_queueing(group);\n\n\t \n\tspin_lock(&group->notification_lock);\n\twhile (!list_empty(&group->fanotify_data.access_list)) {\n\t\tstruct fanotify_perm_event *event;\n\n\t\tevent = list_first_entry(&group->fanotify_data.access_list,\n\t\t\t\tstruct fanotify_perm_event, fae.fse.list);\n\t\tlist_del_init(&event->fae.fse.list);\n\t\tfinish_permission_event(group, event, FAN_ALLOW, NULL);\n\t\tspin_lock(&group->notification_lock);\n\t}\n\n\t \n\twhile ((fsn_event = fsnotify_remove_first_event(group))) {\n\t\tstruct fanotify_event *event = FANOTIFY_E(fsn_event);\n\n\t\tif (!(event->mask & FANOTIFY_PERM_EVENTS)) {\n\t\t\tspin_unlock(&group->notification_lock);\n\t\t\tfsnotify_destroy_event(group, fsn_event);\n\t\t} else {\n\t\t\tfinish_permission_event(group, FANOTIFY_PERM(event),\n\t\t\t\t\t\tFAN_ALLOW, NULL);\n\t\t}\n\t\tspin_lock(&group->notification_lock);\n\t}\n\tspin_unlock(&group->notification_lock);\n\n\t \n\twake_up(&group->fanotify_data.access_waitq);\n\n\t \n\tfsnotify_destroy_group(group);\n\n\treturn 0;\n}\n\nstatic long fanotify_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct fsnotify_group *group;\n\tstruct fsnotify_event *fsn_event;\n\tvoid __user *p;\n\tint ret = -ENOTTY;\n\tsize_t send_len = 0;\n\n\tgroup = file->private_data;\n\n\tp = (void __user *) arg;\n\n\tswitch (cmd) {\n\tcase FIONREAD:\n\t\tspin_lock(&group->notification_lock);\n\t\tlist_for_each_entry(fsn_event, &group->notification_list, list)\n\t\t\tsend_len += FAN_EVENT_METADATA_LEN;\n\t\tspin_unlock(&group->notification_lock);\n\t\tret = put_user(send_len, (int __user *) p);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct file_operations fanotify_fops = {\n\t.show_fdinfo\t= fanotify_show_fdinfo,\n\t.poll\t\t= fanotify_poll,\n\t.read\t\t= fanotify_read,\n\t.write\t\t= fanotify_write,\n\t.fasync\t\t= NULL,\n\t.release\t= fanotify_release,\n\t.unlocked_ioctl\t= fanotify_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int fanotify_find_path(int dfd, const char __user *filename,\n\t\t\t      struct path *path, unsigned int flags, __u64 mask,\n\t\t\t      unsigned int obj_type)\n{\n\tint ret;\n\n\tpr_debug(\"%s: dfd=%d filename=%p flags=%x\\n\", __func__,\n\t\t dfd, filename, flags);\n\n\tif (filename == NULL) {\n\t\tstruct fd f = fdget(dfd);\n\n\t\tret = -EBADF;\n\t\tif (!f.file)\n\t\t\tgoto out;\n\n\t\tret = -ENOTDIR;\n\t\tif ((flags & FAN_MARK_ONLYDIR) &&\n\t\t    !(S_ISDIR(file_inode(f.file)->i_mode))) {\n\t\t\tfdput(f);\n\t\t\tgoto out;\n\t\t}\n\n\t\t*path = f.file->f_path;\n\t\tpath_get(path);\n\t\tfdput(f);\n\t} else {\n\t\tunsigned int lookup_flags = 0;\n\n\t\tif (!(flags & FAN_MARK_DONT_FOLLOW))\n\t\t\tlookup_flags |= LOOKUP_FOLLOW;\n\t\tif (flags & FAN_MARK_ONLYDIR)\n\t\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\n\t\tret = user_path_at(dfd, filename, lookup_flags, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tret = path_permission(path, MAY_READ);\n\tif (ret) {\n\t\tpath_put(path);\n\t\tgoto out;\n\t}\n\n\tret = security_path_notify(path, mask, obj_type);\n\tif (ret)\n\t\tpath_put(path);\n\nout:\n\treturn ret;\n}\n\nstatic __u32 fanotify_mark_remove_from_mask(struct fsnotify_mark *fsn_mark,\n\t\t\t\t\t    __u32 mask, unsigned int flags,\n\t\t\t\t\t    __u32 umask, int *destroy)\n{\n\t__u32 oldmask, newmask;\n\n\t \n\tmask &= ~umask;\n\tspin_lock(&fsn_mark->lock);\n\toldmask = fsnotify_calc_mask(fsn_mark);\n\tif (!(flags & FANOTIFY_MARK_IGNORE_BITS)) {\n\t\tfsn_mark->mask &= ~mask;\n\t} else {\n\t\tfsn_mark->ignore_mask &= ~mask;\n\t}\n\tnewmask = fsnotify_calc_mask(fsn_mark);\n\t \n\t*destroy = !((fsn_mark->mask | fsn_mark->ignore_mask) & ~umask);\n\tspin_unlock(&fsn_mark->lock);\n\n\treturn oldmask & ~newmask;\n}\n\nstatic int fanotify_remove_mark(struct fsnotify_group *group,\n\t\t\t\tfsnotify_connp_t *connp, __u32 mask,\n\t\t\t\tunsigned int flags, __u32 umask)\n{\n\tstruct fsnotify_mark *fsn_mark = NULL;\n\t__u32 removed;\n\tint destroy_mark;\n\n\tfsnotify_group_lock(group);\n\tfsn_mark = fsnotify_find_mark(connp, group);\n\tif (!fsn_mark) {\n\t\tfsnotify_group_unlock(group);\n\t\treturn -ENOENT;\n\t}\n\n\tremoved = fanotify_mark_remove_from_mask(fsn_mark, mask, flags,\n\t\t\t\t\t\t umask, &destroy_mark);\n\tif (removed & fsnotify_conn_mask(fsn_mark->connector))\n\t\tfsnotify_recalc_mask(fsn_mark->connector);\n\tif (destroy_mark)\n\t\tfsnotify_detach_mark(fsn_mark);\n\tfsnotify_group_unlock(group);\n\tif (destroy_mark)\n\t\tfsnotify_free_mark(fsn_mark);\n\n\t \n\tfsnotify_put_mark(fsn_mark);\n\treturn 0;\n}\n\nstatic int fanotify_remove_vfsmount_mark(struct fsnotify_group *group,\n\t\t\t\t\t struct vfsmount *mnt, __u32 mask,\n\t\t\t\t\t unsigned int flags, __u32 umask)\n{\n\treturn fanotify_remove_mark(group, &real_mount(mnt)->mnt_fsnotify_marks,\n\t\t\t\t    mask, flags, umask);\n}\n\nstatic int fanotify_remove_sb_mark(struct fsnotify_group *group,\n\t\t\t\t   struct super_block *sb, __u32 mask,\n\t\t\t\t   unsigned int flags, __u32 umask)\n{\n\treturn fanotify_remove_mark(group, &sb->s_fsnotify_marks, mask,\n\t\t\t\t    flags, umask);\n}\n\nstatic int fanotify_remove_inode_mark(struct fsnotify_group *group,\n\t\t\t\t      struct inode *inode, __u32 mask,\n\t\t\t\t      unsigned int flags, __u32 umask)\n{\n\treturn fanotify_remove_mark(group, &inode->i_fsnotify_marks, mask,\n\t\t\t\t    flags, umask);\n}\n\nstatic bool fanotify_mark_update_flags(struct fsnotify_mark *fsn_mark,\n\t\t\t\t       unsigned int fan_flags)\n{\n\tbool want_iref = !(fan_flags & FAN_MARK_EVICTABLE);\n\tunsigned int ignore = fan_flags & FANOTIFY_MARK_IGNORE_BITS;\n\tbool recalc = false;\n\n\t \n\tif (ignore == FAN_MARK_IGNORE)\n\t\tfsn_mark->flags |= FSNOTIFY_MARK_FLAG_HAS_IGNORE_FLAGS;\n\n\t \n\tif (ignore && (fan_flags & FAN_MARK_IGNORED_SURV_MODIFY) &&\n\t    !(fsn_mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY)) {\n\t\tfsn_mark->flags |= FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY;\n\t\tif (!(fsn_mark->mask & FS_MODIFY))\n\t\t\trecalc = true;\n\t}\n\n\tif (fsn_mark->connector->type != FSNOTIFY_OBJ_TYPE_INODE ||\n\t    want_iref == !(fsn_mark->flags & FSNOTIFY_MARK_FLAG_NO_IREF))\n\t\treturn recalc;\n\n\t \n\tWARN_ON_ONCE(!want_iref);\n\tfsn_mark->flags &= ~FSNOTIFY_MARK_FLAG_NO_IREF;\n\n\treturn true;\n}\n\nstatic bool fanotify_mark_add_to_mask(struct fsnotify_mark *fsn_mark,\n\t\t\t\t      __u32 mask, unsigned int fan_flags)\n{\n\tbool recalc;\n\n\tspin_lock(&fsn_mark->lock);\n\tif (!(fan_flags & FANOTIFY_MARK_IGNORE_BITS))\n\t\tfsn_mark->mask |= mask;\n\telse\n\t\tfsn_mark->ignore_mask |= mask;\n\n\trecalc = fsnotify_calc_mask(fsn_mark) &\n\t\t~fsnotify_conn_mask(fsn_mark->connector);\n\n\trecalc |= fanotify_mark_update_flags(fsn_mark, fan_flags);\n\tspin_unlock(&fsn_mark->lock);\n\n\treturn recalc;\n}\n\nstatic struct fsnotify_mark *fanotify_add_new_mark(struct fsnotify_group *group,\n\t\t\t\t\t\t   fsnotify_connp_t *connp,\n\t\t\t\t\t\t   unsigned int obj_type,\n\t\t\t\t\t\t   unsigned int fan_flags,\n\t\t\t\t\t\t   __kernel_fsid_t *fsid)\n{\n\tstruct ucounts *ucounts = group->fanotify_data.ucounts;\n\tstruct fsnotify_mark *mark;\n\tint ret;\n\n\t \n\tif (!FAN_GROUP_FLAG(group, FAN_UNLIMITED_MARKS) &&\n\t    !inc_ucount(ucounts->ns, ucounts->uid, UCOUNT_FANOTIFY_MARKS))\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tmark = kmem_cache_alloc(fanotify_mark_cache, GFP_KERNEL);\n\tif (!mark) {\n\t\tret = -ENOMEM;\n\t\tgoto out_dec_ucounts;\n\t}\n\n\tfsnotify_init_mark(mark, group);\n\tif (fan_flags & FAN_MARK_EVICTABLE)\n\t\tmark->flags |= FSNOTIFY_MARK_FLAG_NO_IREF;\n\n\tret = fsnotify_add_mark_locked(mark, connp, obj_type, 0, fsid);\n\tif (ret) {\n\t\tfsnotify_put_mark(mark);\n\t\tgoto out_dec_ucounts;\n\t}\n\n\treturn mark;\n\nout_dec_ucounts:\n\tif (!FAN_GROUP_FLAG(group, FAN_UNLIMITED_MARKS))\n\t\tdec_ucount(ucounts, UCOUNT_FANOTIFY_MARKS);\n\treturn ERR_PTR(ret);\n}\n\nstatic int fanotify_group_init_error_pool(struct fsnotify_group *group)\n{\n\tif (mempool_initialized(&group->fanotify_data.error_events_pool))\n\t\treturn 0;\n\n\treturn mempool_init_kmalloc_pool(&group->fanotify_data.error_events_pool,\n\t\t\t\t\t FANOTIFY_DEFAULT_FEE_POOL_SIZE,\n\t\t\t\t\t sizeof(struct fanotify_error_event));\n}\n\nstatic int fanotify_may_update_existing_mark(struct fsnotify_mark *fsn_mark,\n\t\t\t\t\t      unsigned int fan_flags)\n{\n\t \n\tif (fan_flags & FAN_MARK_EVICTABLE &&\n\t    !(fsn_mark->flags & FSNOTIFY_MARK_FLAG_NO_IREF))\n\t\treturn -EEXIST;\n\n\t \n\tif (fan_flags & FAN_MARK_IGNORED_MASK &&\n\t    fsn_mark->flags & FSNOTIFY_MARK_FLAG_HAS_IGNORE_FLAGS)\n\t\treturn -EEXIST;\n\n\t \n\tif (fan_flags & FAN_MARK_IGNORE &&\n\t    !(fan_flags & FAN_MARK_IGNORED_SURV_MODIFY) &&\n\t    fsn_mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY)\n\t\treturn -EEXIST;\n\n\treturn 0;\n}\n\nstatic int fanotify_add_mark(struct fsnotify_group *group,\n\t\t\t     fsnotify_connp_t *connp, unsigned int obj_type,\n\t\t\t     __u32 mask, unsigned int fan_flags,\n\t\t\t     __kernel_fsid_t *fsid)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tbool recalc;\n\tint ret = 0;\n\n\tfsnotify_group_lock(group);\n\tfsn_mark = fsnotify_find_mark(connp, group);\n\tif (!fsn_mark) {\n\t\tfsn_mark = fanotify_add_new_mark(group, connp, obj_type,\n\t\t\t\t\t\t fan_flags, fsid);\n\t\tif (IS_ERR(fsn_mark)) {\n\t\t\tfsnotify_group_unlock(group);\n\t\t\treturn PTR_ERR(fsn_mark);\n\t\t}\n\t}\n\n\t \n\tret = fanotify_may_update_existing_mark(fsn_mark, fan_flags);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (!(fan_flags & FANOTIFY_MARK_IGNORE_BITS) &&\n\t    (mask & FAN_FS_ERROR)) {\n\t\tret = fanotify_group_init_error_pool(group);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\trecalc = fanotify_mark_add_to_mask(fsn_mark, mask, fan_flags);\n\tif (recalc)\n\t\tfsnotify_recalc_mask(fsn_mark->connector);\n\nout:\n\tfsnotify_group_unlock(group);\n\n\tfsnotify_put_mark(fsn_mark);\n\treturn ret;\n}\n\nstatic int fanotify_add_vfsmount_mark(struct fsnotify_group *group,\n\t\t\t\t      struct vfsmount *mnt, __u32 mask,\n\t\t\t\t      unsigned int flags, __kernel_fsid_t *fsid)\n{\n\treturn fanotify_add_mark(group, &real_mount(mnt)->mnt_fsnotify_marks,\n\t\t\t\t FSNOTIFY_OBJ_TYPE_VFSMOUNT, mask, flags, fsid);\n}\n\nstatic int fanotify_add_sb_mark(struct fsnotify_group *group,\n\t\t\t\tstruct super_block *sb, __u32 mask,\n\t\t\t\tunsigned int flags, __kernel_fsid_t *fsid)\n{\n\treturn fanotify_add_mark(group, &sb->s_fsnotify_marks,\n\t\t\t\t FSNOTIFY_OBJ_TYPE_SB, mask, flags, fsid);\n}\n\nstatic int fanotify_add_inode_mark(struct fsnotify_group *group,\n\t\t\t\t   struct inode *inode, __u32 mask,\n\t\t\t\t   unsigned int flags, __kernel_fsid_t *fsid)\n{\n\tpr_debug(\"%s: group=%p inode=%p\\n\", __func__, group, inode);\n\n\t \n\tif ((flags & FANOTIFY_MARK_IGNORE_BITS) &&\n\t    !(flags & FAN_MARK_IGNORED_SURV_MODIFY) &&\n\t    inode_is_open_for_write(inode))\n\t\treturn 0;\n\n\treturn fanotify_add_mark(group, &inode->i_fsnotify_marks,\n\t\t\t\t FSNOTIFY_OBJ_TYPE_INODE, mask, flags, fsid);\n}\n\nstatic struct fsnotify_event *fanotify_alloc_overflow_event(void)\n{\n\tstruct fanotify_event *oevent;\n\n\toevent = kmalloc(sizeof(*oevent), GFP_KERNEL_ACCOUNT);\n\tif (!oevent)\n\t\treturn NULL;\n\n\tfanotify_init_event(oevent, 0, FS_Q_OVERFLOW);\n\toevent->type = FANOTIFY_EVENT_TYPE_OVERFLOW;\n\n\treturn &oevent->fse;\n}\n\nstatic struct hlist_head *fanotify_alloc_merge_hash(void)\n{\n\tstruct hlist_head *hash;\n\n\thash = kmalloc(sizeof(struct hlist_head) << FANOTIFY_HTABLE_BITS,\n\t\t       GFP_KERNEL_ACCOUNT);\n\tif (!hash)\n\t\treturn NULL;\n\n\t__hash_init(hash, FANOTIFY_HTABLE_SIZE);\n\n\treturn hash;\n}\n\n \nSYSCALL_DEFINE2(fanotify_init, unsigned int, flags, unsigned int, event_f_flags)\n{\n\tstruct fsnotify_group *group;\n\tint f_flags, fd;\n\tunsigned int fid_mode = flags & FANOTIFY_FID_BITS;\n\tunsigned int class = flags & FANOTIFY_CLASS_BITS;\n\tunsigned int internal_flags = 0;\n\n\tpr_debug(\"%s: flags=%x event_f_flags=%x\\n\",\n\t\t __func__, flags, event_f_flags);\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t \n\t\tif ((flags & FANOTIFY_ADMIN_INIT_FLAGS) || !fid_mode)\n\t\t\treturn -EPERM;\n\n\t\t \n\t\tinternal_flags |= FANOTIFY_UNPRIV;\n\t}\n\n#ifdef CONFIG_AUDITSYSCALL\n\tif (flags & ~(FANOTIFY_INIT_FLAGS | FAN_ENABLE_AUDIT))\n#else\n\tif (flags & ~FANOTIFY_INIT_FLAGS)\n#endif\n\t\treturn -EINVAL;\n\n\t \n\tif ((flags & FAN_REPORT_PIDFD) && (flags & FAN_REPORT_TID))\n\t\treturn -EINVAL;\n\n\tif (event_f_flags & ~FANOTIFY_INIT_ALL_EVENT_F_BITS)\n\t\treturn -EINVAL;\n\n\tswitch (event_f_flags & O_ACCMODE) {\n\tcase O_RDONLY:\n\tcase O_RDWR:\n\tcase O_WRONLY:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (fid_mode && class != FAN_CLASS_NOTIF)\n\t\treturn -EINVAL;\n\n\t \n\tif ((fid_mode & FAN_REPORT_NAME) && !(fid_mode & FAN_REPORT_DIR_FID))\n\t\treturn -EINVAL;\n\n\t \n\tif ((fid_mode & FAN_REPORT_TARGET_FID) &&\n\t    (!(fid_mode & FAN_REPORT_NAME) || !(fid_mode & FAN_REPORT_FID)))\n\t\treturn -EINVAL;\n\n\tf_flags = O_RDWR | __FMODE_NONOTIFY;\n\tif (flags & FAN_CLOEXEC)\n\t\tf_flags |= O_CLOEXEC;\n\tif (flags & FAN_NONBLOCK)\n\t\tf_flags |= O_NONBLOCK;\n\n\t \n\tgroup = fsnotify_alloc_group(&fanotify_fsnotify_ops,\n\t\t\t\t     FSNOTIFY_GROUP_USER | FSNOTIFY_GROUP_NOFS);\n\tif (IS_ERR(group)) {\n\t\treturn PTR_ERR(group);\n\t}\n\n\t \n\tgroup->fanotify_data.ucounts = inc_ucount(current_user_ns(),\n\t\t\t\t\t\t  current_euid(),\n\t\t\t\t\t\t  UCOUNT_FANOTIFY_GROUPS);\n\tif (!group->fanotify_data.ucounts) {\n\t\tfd = -EMFILE;\n\t\tgoto out_destroy_group;\n\t}\n\n\tgroup->fanotify_data.flags = flags | internal_flags;\n\tgroup->memcg = get_mem_cgroup_from_mm(current->mm);\n\n\tgroup->fanotify_data.merge_hash = fanotify_alloc_merge_hash();\n\tif (!group->fanotify_data.merge_hash) {\n\t\tfd = -ENOMEM;\n\t\tgoto out_destroy_group;\n\t}\n\n\tgroup->overflow_event = fanotify_alloc_overflow_event();\n\tif (unlikely(!group->overflow_event)) {\n\t\tfd = -ENOMEM;\n\t\tgoto out_destroy_group;\n\t}\n\n\tif (force_o_largefile())\n\t\tevent_f_flags |= O_LARGEFILE;\n\tgroup->fanotify_data.f_flags = event_f_flags;\n\tinit_waitqueue_head(&group->fanotify_data.access_waitq);\n\tINIT_LIST_HEAD(&group->fanotify_data.access_list);\n\tswitch (class) {\n\tcase FAN_CLASS_NOTIF:\n\t\tgroup->priority = FS_PRIO_0;\n\t\tbreak;\n\tcase FAN_CLASS_CONTENT:\n\t\tgroup->priority = FS_PRIO_1;\n\t\tbreak;\n\tcase FAN_CLASS_PRE_CONTENT:\n\t\tgroup->priority = FS_PRIO_2;\n\t\tbreak;\n\tdefault:\n\t\tfd = -EINVAL;\n\t\tgoto out_destroy_group;\n\t}\n\n\tif (flags & FAN_UNLIMITED_QUEUE) {\n\t\tfd = -EPERM;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\tgoto out_destroy_group;\n\t\tgroup->max_events = UINT_MAX;\n\t} else {\n\t\tgroup->max_events = fanotify_max_queued_events;\n\t}\n\n\tif (flags & FAN_UNLIMITED_MARKS) {\n\t\tfd = -EPERM;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\tgoto out_destroy_group;\n\t}\n\n\tif (flags & FAN_ENABLE_AUDIT) {\n\t\tfd = -EPERM;\n\t\tif (!capable(CAP_AUDIT_WRITE))\n\t\t\tgoto out_destroy_group;\n\t}\n\n\tfd = anon_inode_getfd(\"[fanotify]\", &fanotify_fops, group, f_flags);\n\tif (fd < 0)\n\t\tgoto out_destroy_group;\n\n\treturn fd;\n\nout_destroy_group:\n\tfsnotify_destroy_group(group);\n\treturn fd;\n}\n\nstatic int fanotify_test_fsid(struct dentry *dentry, __kernel_fsid_t *fsid)\n{\n\t__kernel_fsid_t root_fsid;\n\tint err;\n\n\t \n\terr = vfs_get_fsid(dentry, fsid);\n\tif (err)\n\t\treturn err;\n\n\tif (!fsid->val[0] && !fsid->val[1])\n\t\treturn -ENODEV;\n\n\t \n\terr = vfs_get_fsid(dentry->d_sb->s_root, &root_fsid);\n\tif (err)\n\t\treturn err;\n\n\tif (root_fsid.val[0] != fsid->val[0] ||\n\t    root_fsid.val[1] != fsid->val[1])\n\t\treturn -EXDEV;\n\n\treturn 0;\n}\n\n \nstatic int fanotify_test_fid(struct dentry *dentry, unsigned int flags)\n{\n\tunsigned int mark_type = flags & FANOTIFY_MARK_TYPE_BITS;\n\tconst struct export_operations *nop = dentry->d_sb->s_export_op;\n\n\t \n\tif (!nop)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (mark_type != FAN_MARK_INODE && !nop->fh_to_dentry)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int fanotify_events_supported(struct fsnotify_group *group,\n\t\t\t\t     const struct path *path, __u64 mask,\n\t\t\t\t     unsigned int flags)\n{\n\tunsigned int mark_type = flags & FANOTIFY_MARK_TYPE_BITS;\n\t \n\tbool strict_dir_events = FAN_GROUP_FLAG(group, FAN_REPORT_TARGET_FID) ||\n\t\t\t\t (mask & FAN_RENAME) ||\n\t\t\t\t (flags & FAN_MARK_IGNORE);\n\n\t \n\tif (mask & FANOTIFY_PERM_EVENTS &&\n\t    path->mnt->mnt_sb->s_type->fs_flags & FS_DISALLOW_NOTIFY_PERM)\n\t\treturn -EINVAL;\n\n\t \n\tif (mark_type != FAN_MARK_INODE &&\n\t    path->mnt->mnt_sb->s_flags & SB_NOUSER)\n\t\treturn -EINVAL;\n\n\t \n\tif (strict_dir_events && mark_type == FAN_MARK_INODE &&\n\t    !d_is_dir(path->dentry) && (mask & FANOTIFY_DIRONLY_EVENT_BITS))\n\t\treturn -ENOTDIR;\n\n\treturn 0;\n}\n\nstatic int do_fanotify_mark(int fanotify_fd, unsigned int flags, __u64 mask,\n\t\t\t    int dfd, const char  __user *pathname)\n{\n\tstruct inode *inode = NULL;\n\tstruct vfsmount *mnt = NULL;\n\tstruct fsnotify_group *group;\n\tstruct fd f;\n\tstruct path path;\n\t__kernel_fsid_t __fsid, *fsid = NULL;\n\tu32 valid_mask = FANOTIFY_EVENTS | FANOTIFY_EVENT_FLAGS;\n\tunsigned int mark_type = flags & FANOTIFY_MARK_TYPE_BITS;\n\tunsigned int mark_cmd = flags & FANOTIFY_MARK_CMD_BITS;\n\tunsigned int ignore = flags & FANOTIFY_MARK_IGNORE_BITS;\n\tunsigned int obj_type, fid_mode;\n\tu32 umask = 0;\n\tint ret;\n\n\tpr_debug(\"%s: fanotify_fd=%d flags=%x dfd=%d pathname=%p mask=%llx\\n\",\n\t\t __func__, fanotify_fd, flags, dfd, pathname, mask);\n\n\t \n\tif (upper_32_bits(mask))\n\t\treturn -EINVAL;\n\n\tif (flags & ~FANOTIFY_MARK_FLAGS)\n\t\treturn -EINVAL;\n\n\tswitch (mark_type) {\n\tcase FAN_MARK_INODE:\n\t\tobj_type = FSNOTIFY_OBJ_TYPE_INODE;\n\t\tbreak;\n\tcase FAN_MARK_MOUNT:\n\t\tobj_type = FSNOTIFY_OBJ_TYPE_VFSMOUNT;\n\t\tbreak;\n\tcase FAN_MARK_FILESYSTEM:\n\t\tobj_type = FSNOTIFY_OBJ_TYPE_SB;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (mark_cmd) {\n\tcase FAN_MARK_ADD:\n\tcase FAN_MARK_REMOVE:\n\t\tif (!mask)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase FAN_MARK_FLUSH:\n\t\tif (flags & ~(FANOTIFY_MARK_TYPE_BITS | FAN_MARK_FLUSH))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ENABLED(CONFIG_FANOTIFY_ACCESS_PERMISSIONS))\n\t\tvalid_mask |= FANOTIFY_PERM_EVENTS;\n\n\tif (mask & ~valid_mask)\n\t\treturn -EINVAL;\n\n\n\t \n\tif (ignore == (FAN_MARK_IGNORE | FAN_MARK_IGNORED_MASK))\n\t\treturn -EINVAL;\n\n\t \n\tif (ignore == FAN_MARK_IGNORED_MASK) {\n\t\tmask &= ~FANOTIFY_EVENT_FLAGS;\n\t\tumask = FANOTIFY_EVENT_FLAGS;\n\t}\n\n\tf = fdget(fanotify_fd);\n\tif (unlikely(!f.file))\n\t\treturn -EBADF;\n\n\t \n\tret = -EINVAL;\n\tif (unlikely(f.file->f_op != &fanotify_fops))\n\t\tgoto fput_and_out;\n\tgroup = f.file->private_data;\n\n\t \n\tret = -EPERM;\n\tif ((!capable(CAP_SYS_ADMIN) ||\n\t     FAN_GROUP_FLAG(group, FANOTIFY_UNPRIV)) &&\n\t    mark_type != FAN_MARK_INODE)\n\t\tgoto fput_and_out;\n\n\t \n\tret = -EINVAL;\n\tif (mask & FANOTIFY_PERM_EVENTS &&\n\t    group->priority == FS_PRIO_0)\n\t\tgoto fput_and_out;\n\n\tif (mask & FAN_FS_ERROR &&\n\t    mark_type != FAN_MARK_FILESYSTEM)\n\t\tgoto fput_and_out;\n\n\t \n\tif (flags & FAN_MARK_EVICTABLE &&\n\t     mark_type != FAN_MARK_INODE)\n\t\tgoto fput_and_out;\n\n\t \n\tfid_mode = FAN_GROUP_FLAG(group, FANOTIFY_FID_BITS);\n\tif (mask & ~(FANOTIFY_FD_EVENTS|FANOTIFY_EVENT_FLAGS) &&\n\t    (!fid_mode || mark_type == FAN_MARK_MOUNT))\n\t\tgoto fput_and_out;\n\n\t \n\tif (mask & FAN_RENAME && !(fid_mode & FAN_REPORT_NAME))\n\t\tgoto fput_and_out;\n\n\tif (mark_cmd == FAN_MARK_FLUSH) {\n\t\tret = 0;\n\t\tif (mark_type == FAN_MARK_MOUNT)\n\t\t\tfsnotify_clear_vfsmount_marks_by_group(group);\n\t\telse if (mark_type == FAN_MARK_FILESYSTEM)\n\t\t\tfsnotify_clear_sb_marks_by_group(group);\n\t\telse\n\t\t\tfsnotify_clear_inode_marks_by_group(group);\n\t\tgoto fput_and_out;\n\t}\n\n\tret = fanotify_find_path(dfd, pathname, &path, flags,\n\t\t\t(mask & ALL_FSNOTIFY_EVENTS), obj_type);\n\tif (ret)\n\t\tgoto fput_and_out;\n\n\tif (mark_cmd == FAN_MARK_ADD) {\n\t\tret = fanotify_events_supported(group, &path, mask, flags);\n\t\tif (ret)\n\t\t\tgoto path_put_and_out;\n\t}\n\n\tif (fid_mode) {\n\t\tret = fanotify_test_fsid(path.dentry, &__fsid);\n\t\tif (ret)\n\t\t\tgoto path_put_and_out;\n\n\t\tret = fanotify_test_fid(path.dentry, flags);\n\t\tif (ret)\n\t\t\tgoto path_put_and_out;\n\n\t\tfsid = &__fsid;\n\t}\n\n\t \n\tif (mark_type == FAN_MARK_INODE)\n\t\tinode = path.dentry->d_inode;\n\telse\n\t\tmnt = path.mnt;\n\n\tret = mnt ? -EINVAL : -EISDIR;\n\t \n\tif (mark_cmd == FAN_MARK_ADD && ignore == FAN_MARK_IGNORE &&\n\t    (mnt || S_ISDIR(inode->i_mode)) &&\n\t    !(flags & FAN_MARK_IGNORED_SURV_MODIFY))\n\t\tgoto path_put_and_out;\n\n\t \n\tif (mnt || !S_ISDIR(inode->i_mode)) {\n\t\tmask &= ~FAN_EVENT_ON_CHILD;\n\t\tumask = FAN_EVENT_ON_CHILD;\n\t\t \n\t\tif ((fid_mode & FAN_REPORT_DIR_FID) &&\n\t\t    (flags & FAN_MARK_ADD) && !ignore)\n\t\t\tmask |= FAN_EVENT_ON_CHILD;\n\t}\n\n\t \n\tswitch (mark_cmd) {\n\tcase FAN_MARK_ADD:\n\t\tif (mark_type == FAN_MARK_MOUNT)\n\t\t\tret = fanotify_add_vfsmount_mark(group, mnt, mask,\n\t\t\t\t\t\t\t flags, fsid);\n\t\telse if (mark_type == FAN_MARK_FILESYSTEM)\n\t\t\tret = fanotify_add_sb_mark(group, mnt->mnt_sb, mask,\n\t\t\t\t\t\t   flags, fsid);\n\t\telse\n\t\t\tret = fanotify_add_inode_mark(group, inode, mask,\n\t\t\t\t\t\t      flags, fsid);\n\t\tbreak;\n\tcase FAN_MARK_REMOVE:\n\t\tif (mark_type == FAN_MARK_MOUNT)\n\t\t\tret = fanotify_remove_vfsmount_mark(group, mnt, mask,\n\t\t\t\t\t\t\t    flags, umask);\n\t\telse if (mark_type == FAN_MARK_FILESYSTEM)\n\t\t\tret = fanotify_remove_sb_mark(group, mnt->mnt_sb, mask,\n\t\t\t\t\t\t      flags, umask);\n\t\telse\n\t\t\tret = fanotify_remove_inode_mark(group, inode, mask,\n\t\t\t\t\t\t\t flags, umask);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\npath_put_and_out:\n\tpath_put(&path);\nfput_and_out:\n\tfdput(f);\n\treturn ret;\n}\n\n#ifndef CONFIG_ARCH_SPLIT_ARG64\nSYSCALL_DEFINE5(fanotify_mark, int, fanotify_fd, unsigned int, flags,\n\t\t\t      __u64, mask, int, dfd,\n\t\t\t      const char  __user *, pathname)\n{\n\treturn do_fanotify_mark(fanotify_fd, flags, mask, dfd, pathname);\n}\n#endif\n\n#if defined(CONFIG_ARCH_SPLIT_ARG64) || defined(CONFIG_COMPAT)\nSYSCALL32_DEFINE6(fanotify_mark,\n\t\t\t\tint, fanotify_fd, unsigned int, flags,\n\t\t\t\tSC_ARG64(mask), int, dfd,\n\t\t\t\tconst char  __user *, pathname)\n{\n\treturn do_fanotify_mark(fanotify_fd, flags, SC_VAL64(__u64, mask),\n\t\t\t\tdfd, pathname);\n}\n#endif\n\n \nstatic int __init fanotify_user_setup(void)\n{\n\tstruct sysinfo si;\n\tint max_marks;\n\n\tsi_meminfo(&si);\n\t \n\tmax_marks = (((si.totalram - si.totalhigh) / 100) << PAGE_SHIFT) /\n\t\t    INODE_MARK_COST;\n\tmax_marks = clamp(max_marks, FANOTIFY_OLD_DEFAULT_MAX_MARKS,\n\t\t\t\t     FANOTIFY_DEFAULT_MAX_USER_MARKS);\n\n\tBUILD_BUG_ON(FANOTIFY_INIT_FLAGS & FANOTIFY_INTERNAL_GROUP_FLAGS);\n\tBUILD_BUG_ON(HWEIGHT32(FANOTIFY_INIT_FLAGS) != 12);\n\tBUILD_BUG_ON(HWEIGHT32(FANOTIFY_MARK_FLAGS) != 11);\n\n\tfanotify_mark_cache = KMEM_CACHE(fsnotify_mark,\n\t\t\t\t\t SLAB_PANIC|SLAB_ACCOUNT);\n\tfanotify_fid_event_cachep = KMEM_CACHE(fanotify_fid_event,\n\t\t\t\t\t       SLAB_PANIC);\n\tfanotify_path_event_cachep = KMEM_CACHE(fanotify_path_event,\n\t\t\t\t\t\tSLAB_PANIC);\n\tif (IS_ENABLED(CONFIG_FANOTIFY_ACCESS_PERMISSIONS)) {\n\t\tfanotify_perm_event_cachep =\n\t\t\tKMEM_CACHE(fanotify_perm_event, SLAB_PANIC);\n\t}\n\n\tfanotify_max_queued_events = FANOTIFY_DEFAULT_MAX_EVENTS;\n\tinit_user_ns.ucount_max[UCOUNT_FANOTIFY_GROUPS] =\n\t\t\t\t\tFANOTIFY_DEFAULT_MAX_GROUPS;\n\tinit_user_ns.ucount_max[UCOUNT_FANOTIFY_MARKS] = max_marks;\n\tfanotify_sysctls_init();\n\n\treturn 0;\n}\ndevice_initcall(fanotify_user_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}