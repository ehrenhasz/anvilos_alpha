{
  "module_name": "mark.c",
  "hash_id": "713f4abbbced89153038ffb53147e5240e134f8bf0c7375821f67ac664012ac1",
  "original_prompt": "Ingested from linux-6.6.14/fs/notify/mark.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/srcu.h>\n#include <linux/ratelimit.h>\n\n#include <linux/atomic.h>\n\n#include <linux/fsnotify_backend.h>\n#include \"fsnotify.h\"\n\n#define FSNOTIFY_REAPER_DELAY\t(1)\t \n\nstruct srcu_struct fsnotify_mark_srcu;\nstruct kmem_cache *fsnotify_mark_connector_cachep;\n\nstatic DEFINE_SPINLOCK(destroy_lock);\nstatic LIST_HEAD(destroy_list);\nstatic struct fsnotify_mark_connector *connector_destroy_list;\n\nstatic void fsnotify_mark_destroy_workfn(struct work_struct *work);\nstatic DECLARE_DELAYED_WORK(reaper_work, fsnotify_mark_destroy_workfn);\n\nstatic void fsnotify_connector_destroy_workfn(struct work_struct *work);\nstatic DECLARE_WORK(connector_reaper_work, fsnotify_connector_destroy_workfn);\n\nvoid fsnotify_get_mark(struct fsnotify_mark *mark)\n{\n\tWARN_ON_ONCE(!refcount_read(&mark->refcnt));\n\trefcount_inc(&mark->refcnt);\n}\n\nstatic __u32 *fsnotify_conn_mask_p(struct fsnotify_mark_connector *conn)\n{\n\tif (conn->type == FSNOTIFY_OBJ_TYPE_INODE)\n\t\treturn &fsnotify_conn_inode(conn)->i_fsnotify_mask;\n\telse if (conn->type == FSNOTIFY_OBJ_TYPE_VFSMOUNT)\n\t\treturn &fsnotify_conn_mount(conn)->mnt_fsnotify_mask;\n\telse if (conn->type == FSNOTIFY_OBJ_TYPE_SB)\n\t\treturn &fsnotify_conn_sb(conn)->s_fsnotify_mask;\n\treturn NULL;\n}\n\n__u32 fsnotify_conn_mask(struct fsnotify_mark_connector *conn)\n{\n\tif (WARN_ON(!fsnotify_valid_obj_type(conn->type)))\n\t\treturn 0;\n\n\treturn *fsnotify_conn_mask_p(conn);\n}\n\nstatic void fsnotify_get_inode_ref(struct inode *inode)\n{\n\tihold(inode);\n\tatomic_long_inc(&inode->i_sb->s_fsnotify_connectors);\n}\n\n \nstatic struct inode *fsnotify_update_iref(struct fsnotify_mark_connector *conn,\n\t\t\t\t\t  bool want_iref)\n{\n\tbool has_iref = conn->flags & FSNOTIFY_CONN_FLAG_HAS_IREF;\n\tstruct inode *inode = NULL;\n\n\tif (conn->type != FSNOTIFY_OBJ_TYPE_INODE ||\n\t    want_iref == has_iref)\n\t\treturn NULL;\n\n\tif (want_iref) {\n\t\t \n\t\tfsnotify_get_inode_ref(fsnotify_conn_inode(conn));\n\t\tconn->flags |= FSNOTIFY_CONN_FLAG_HAS_IREF;\n\t} else {\n\t\t \n\t\tinode = fsnotify_conn_inode(conn);\n\t\tconn->flags &= ~FSNOTIFY_CONN_FLAG_HAS_IREF;\n\t}\n\n\treturn inode;\n}\n\nstatic void *__fsnotify_recalc_mask(struct fsnotify_mark_connector *conn)\n{\n\tu32 new_mask = 0;\n\tbool want_iref = false;\n\tstruct fsnotify_mark *mark;\n\n\tassert_spin_locked(&conn->lock);\n\t \n\tif (!fsnotify_valid_obj_type(conn->type))\n\t\treturn NULL;\n\thlist_for_each_entry(mark, &conn->list, obj_list) {\n\t\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ATTACHED))\n\t\t\tcontinue;\n\t\tnew_mask |= fsnotify_calc_mask(mark);\n\t\tif (conn->type == FSNOTIFY_OBJ_TYPE_INODE &&\n\t\t    !(mark->flags & FSNOTIFY_MARK_FLAG_NO_IREF))\n\t\t\twant_iref = true;\n\t}\n\t*fsnotify_conn_mask_p(conn) = new_mask;\n\n\treturn fsnotify_update_iref(conn, want_iref);\n}\n\n \nvoid fsnotify_recalc_mask(struct fsnotify_mark_connector *conn)\n{\n\tif (!conn)\n\t\treturn;\n\n\tspin_lock(&conn->lock);\n\t__fsnotify_recalc_mask(conn);\n\tspin_unlock(&conn->lock);\n\tif (conn->type == FSNOTIFY_OBJ_TYPE_INODE)\n\t\t__fsnotify_update_child_dentry_flags(\n\t\t\t\t\tfsnotify_conn_inode(conn));\n}\n\n \nstatic void fsnotify_connector_destroy_workfn(struct work_struct *work)\n{\n\tstruct fsnotify_mark_connector *conn, *free;\n\n\tspin_lock(&destroy_lock);\n\tconn = connector_destroy_list;\n\tconnector_destroy_list = NULL;\n\tspin_unlock(&destroy_lock);\n\n\tsynchronize_srcu(&fsnotify_mark_srcu);\n\twhile (conn) {\n\t\tfree = conn;\n\t\tconn = conn->destroy_next;\n\t\tkmem_cache_free(fsnotify_mark_connector_cachep, free);\n\t}\n}\n\nstatic void fsnotify_put_inode_ref(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tiput(inode);\n\tif (atomic_long_dec_and_test(&sb->s_fsnotify_connectors))\n\t\twake_up_var(&sb->s_fsnotify_connectors);\n}\n\nstatic void fsnotify_get_sb_connectors(struct fsnotify_mark_connector *conn)\n{\n\tstruct super_block *sb = fsnotify_connector_sb(conn);\n\n\tif (sb)\n\t\tatomic_long_inc(&sb->s_fsnotify_connectors);\n}\n\nstatic void fsnotify_put_sb_connectors(struct fsnotify_mark_connector *conn)\n{\n\tstruct super_block *sb = fsnotify_connector_sb(conn);\n\n\tif (sb && atomic_long_dec_and_test(&sb->s_fsnotify_connectors))\n\t\twake_up_var(&sb->s_fsnotify_connectors);\n}\n\nstatic void *fsnotify_detach_connector_from_object(\n\t\t\t\t\tstruct fsnotify_mark_connector *conn,\n\t\t\t\t\tunsigned int *type)\n{\n\tstruct inode *inode = NULL;\n\n\t*type = conn->type;\n\tif (conn->type == FSNOTIFY_OBJ_TYPE_DETACHED)\n\t\treturn NULL;\n\n\tif (conn->type == FSNOTIFY_OBJ_TYPE_INODE) {\n\t\tinode = fsnotify_conn_inode(conn);\n\t\tinode->i_fsnotify_mask = 0;\n\n\t\t \n\t\tif (!(conn->flags & FSNOTIFY_CONN_FLAG_HAS_IREF))\n\t\t\tinode = NULL;\n\t} else if (conn->type == FSNOTIFY_OBJ_TYPE_VFSMOUNT) {\n\t\tfsnotify_conn_mount(conn)->mnt_fsnotify_mask = 0;\n\t} else if (conn->type == FSNOTIFY_OBJ_TYPE_SB) {\n\t\tfsnotify_conn_sb(conn)->s_fsnotify_mask = 0;\n\t}\n\n\tfsnotify_put_sb_connectors(conn);\n\trcu_assign_pointer(*(conn->obj), NULL);\n\tconn->obj = NULL;\n\tconn->type = FSNOTIFY_OBJ_TYPE_DETACHED;\n\n\treturn inode;\n}\n\nstatic void fsnotify_final_mark_destroy(struct fsnotify_mark *mark)\n{\n\tstruct fsnotify_group *group = mark->group;\n\n\tif (WARN_ON_ONCE(!group))\n\t\treturn;\n\tgroup->ops->free_mark(mark);\n\tfsnotify_put_group(group);\n}\n\n \nstatic void fsnotify_drop_object(unsigned int type, void *objp)\n{\n\tif (!objp)\n\t\treturn;\n\t \n\tif (WARN_ON_ONCE(type != FSNOTIFY_OBJ_TYPE_INODE))\n\t\treturn;\n\tfsnotify_put_inode_ref(objp);\n}\n\nvoid fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tstruct fsnotify_mark_connector *conn = READ_ONCE(mark->connector);\n\tvoid *objp = NULL;\n\tunsigned int type = FSNOTIFY_OBJ_TYPE_DETACHED;\n\tbool free_conn = false;\n\n\t \n\tif (!conn) {\n\t\tif (refcount_dec_and_test(&mark->refcnt))\n\t\t\tfsnotify_final_mark_destroy(mark);\n\t\treturn;\n\t}\n\n\t \n\tif (!refcount_dec_and_lock(&mark->refcnt, &conn->lock))\n\t\treturn;\n\n\thlist_del_init_rcu(&mark->obj_list);\n\tif (hlist_empty(&conn->list)) {\n\t\tobjp = fsnotify_detach_connector_from_object(conn, &type);\n\t\tfree_conn = true;\n\t} else {\n\t\tobjp = __fsnotify_recalc_mask(conn);\n\t\ttype = conn->type;\n\t}\n\tWRITE_ONCE(mark->connector, NULL);\n\tspin_unlock(&conn->lock);\n\n\tfsnotify_drop_object(type, objp);\n\n\tif (free_conn) {\n\t\tspin_lock(&destroy_lock);\n\t\tconn->destroy_next = connector_destroy_list;\n\t\tconnector_destroy_list = conn;\n\t\tspin_unlock(&destroy_lock);\n\t\tqueue_work(system_unbound_wq, &connector_reaper_work);\n\t}\n\t \n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\tqueue_delayed_work(system_unbound_wq, &reaper_work,\n\t\t\t   FSNOTIFY_REAPER_DELAY);\n}\nEXPORT_SYMBOL_GPL(fsnotify_put_mark);\n\n \nstatic bool fsnotify_get_mark_safe(struct fsnotify_mark *mark)\n{\n\tif (!mark)\n\t\treturn true;\n\n\tif (refcount_inc_not_zero(&mark->refcnt)) {\n\t\tspin_lock(&mark->lock);\n\t\tif (mark->flags & FSNOTIFY_MARK_FLAG_ATTACHED) {\n\t\t\t \n\t\t\tatomic_inc(&mark->group->user_waits);\n\t\t\tspin_unlock(&mark->lock);\n\t\t\treturn true;\n\t\t}\n\t\tspin_unlock(&mark->lock);\n\t\tfsnotify_put_mark(mark);\n\t}\n\treturn false;\n}\n\n \nstatic void fsnotify_put_mark_wake(struct fsnotify_mark *mark)\n{\n\tif (mark) {\n\t\tstruct fsnotify_group *group = mark->group;\n\n\t\tfsnotify_put_mark(mark);\n\t\t \n\t\tif (atomic_dec_and_test(&group->user_waits) && group->shutdown)\n\t\t\twake_up(&group->notification_waitq);\n\t}\n}\n\nbool fsnotify_prepare_user_wait(struct fsnotify_iter_info *iter_info)\n\t__releases(&fsnotify_mark_srcu)\n{\n\tint type;\n\n\tfsnotify_foreach_iter_type(type) {\n\t\t \n\t\tif (!fsnotify_get_mark_safe(iter_info->marks[type])) {\n\t\t\t__release(&fsnotify_mark_srcu);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tsrcu_read_unlock(&fsnotify_mark_srcu, iter_info->srcu_idx);\n\n\treturn true;\n\nfail:\n\tfor (type--; type >= 0; type--)\n\t\tfsnotify_put_mark_wake(iter_info->marks[type]);\n\treturn false;\n}\n\nvoid fsnotify_finish_user_wait(struct fsnotify_iter_info *iter_info)\n\t__acquires(&fsnotify_mark_srcu)\n{\n\tint type;\n\n\titer_info->srcu_idx = srcu_read_lock(&fsnotify_mark_srcu);\n\tfsnotify_foreach_iter_type(type)\n\t\tfsnotify_put_mark_wake(iter_info->marks[type]);\n}\n\n \nvoid fsnotify_detach_mark(struct fsnotify_mark *mark)\n{\n\tfsnotify_group_assert_locked(mark->group);\n\tWARN_ON_ONCE(!srcu_read_lock_held(&fsnotify_mark_srcu) &&\n\t\t     refcount_read(&mark->refcnt) < 1 +\n\t\t\t!!(mark->flags & FSNOTIFY_MARK_FLAG_ATTACHED));\n\n\tspin_lock(&mark->lock);\n\t \n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ATTACHED)) {\n\t\tspin_unlock(&mark->lock);\n\t\treturn;\n\t}\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ATTACHED;\n\tlist_del_init(&mark->g_list);\n\tspin_unlock(&mark->lock);\n\n\t \n\tfsnotify_put_mark(mark);\n}\n\n \nvoid fsnotify_free_mark(struct fsnotify_mark *mark)\n{\n\tstruct fsnotify_group *group = mark->group;\n\n\tspin_lock(&mark->lock);\n\t \n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ALIVE)) {\n\t\tspin_unlock(&mark->lock);\n\t\treturn;\n\t}\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\tspin_unlock(&mark->lock);\n\n\t \n\tif (group->ops->freeing_mark)\n\t\tgroup->ops->freeing_mark(mark, group);\n}\n\nvoid fsnotify_destroy_mark(struct fsnotify_mark *mark,\n\t\t\t   struct fsnotify_group *group)\n{\n\tfsnotify_group_lock(group);\n\tfsnotify_detach_mark(mark);\n\tfsnotify_group_unlock(group);\n\tfsnotify_free_mark(mark);\n}\nEXPORT_SYMBOL_GPL(fsnotify_destroy_mark);\n\n \nint fsnotify_compare_groups(struct fsnotify_group *a, struct fsnotify_group *b)\n{\n\tif (a == b)\n\t\treturn 0;\n\tif (!a)\n\t\treturn 1;\n\tif (!b)\n\t\treturn -1;\n\tif (a->priority < b->priority)\n\t\treturn 1;\n\tif (a->priority > b->priority)\n\t\treturn -1;\n\tif (a < b)\n\t\treturn 1;\n\treturn -1;\n}\n\nstatic int fsnotify_attach_connector_to_object(fsnotify_connp_t *connp,\n\t\t\t\t\t       unsigned int obj_type,\n\t\t\t\t\t       __kernel_fsid_t *fsid)\n{\n\tstruct fsnotify_mark_connector *conn;\n\n\tconn = kmem_cache_alloc(fsnotify_mark_connector_cachep, GFP_KERNEL);\n\tif (!conn)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&conn->lock);\n\tINIT_HLIST_HEAD(&conn->list);\n\tconn->flags = 0;\n\tconn->type = obj_type;\n\tconn->obj = connp;\n\t \n\tif (fsid) {\n\t\tconn->fsid = *fsid;\n\t\tconn->flags = FSNOTIFY_CONN_FLAG_HAS_FSID;\n\t} else {\n\t\tconn->fsid.val[0] = conn->fsid.val[1] = 0;\n\t\tconn->flags = 0;\n\t}\n\tfsnotify_get_sb_connectors(conn);\n\n\t \n\tif (cmpxchg(connp, NULL, conn)) {\n\t\t \n\t\tfsnotify_put_sb_connectors(conn);\n\t\tkmem_cache_free(fsnotify_mark_connector_cachep, conn);\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct fsnotify_mark_connector *fsnotify_grab_connector(\n\t\t\t\t\t\tfsnotify_connp_t *connp)\n{\n\tstruct fsnotify_mark_connector *conn;\n\tint idx;\n\n\tidx = srcu_read_lock(&fsnotify_mark_srcu);\n\tconn = srcu_dereference(*connp, &fsnotify_mark_srcu);\n\tif (!conn)\n\t\tgoto out;\n\tspin_lock(&conn->lock);\n\tif (conn->type == FSNOTIFY_OBJ_TYPE_DETACHED) {\n\t\tspin_unlock(&conn->lock);\n\t\tsrcu_read_unlock(&fsnotify_mark_srcu, idx);\n\t\treturn NULL;\n\t}\nout:\n\tsrcu_read_unlock(&fsnotify_mark_srcu, idx);\n\treturn conn;\n}\n\n \nstatic int fsnotify_add_mark_list(struct fsnotify_mark *mark,\n\t\t\t\t  fsnotify_connp_t *connp,\n\t\t\t\t  unsigned int obj_type,\n\t\t\t\t  int add_flags, __kernel_fsid_t *fsid)\n{\n\tstruct fsnotify_mark *lmark, *last = NULL;\n\tstruct fsnotify_mark_connector *conn;\n\tint cmp;\n\tint err = 0;\n\n\tif (WARN_ON(!fsnotify_valid_obj_type(obj_type)))\n\t\treturn -EINVAL;\n\n\t \n\tif (fsid && WARN_ON_ONCE(!fsid->val[0] && !fsid->val[1]))\n\t\treturn -ENODEV;\n\nrestart:\n\tspin_lock(&mark->lock);\n\tconn = fsnotify_grab_connector(connp);\n\tif (!conn) {\n\t\tspin_unlock(&mark->lock);\n\t\terr = fsnotify_attach_connector_to_object(connp, obj_type,\n\t\t\t\t\t\t\t  fsid);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto restart;\n\t} else if (fsid && !(conn->flags & FSNOTIFY_CONN_FLAG_HAS_FSID)) {\n\t\tconn->fsid = *fsid;\n\t\t \n\t\tsmp_wmb();\n\t\tconn->flags |= FSNOTIFY_CONN_FLAG_HAS_FSID;\n\t} else if (fsid && (conn->flags & FSNOTIFY_CONN_FLAG_HAS_FSID) &&\n\t\t   (fsid->val[0] != conn->fsid.val[0] ||\n\t\t    fsid->val[1] != conn->fsid.val[1])) {\n\t\t \n\t\tpr_warn_ratelimited(\"%s: fsid mismatch on object of type %u: \"\n\t\t\t\t    \"%x.%x != %x.%x\\n\", __func__, conn->type,\n\t\t\t\t    fsid->val[0], fsid->val[1],\n\t\t\t\t    conn->fsid.val[0], conn->fsid.val[1]);\n\t\terr = -EXDEV;\n\t\tgoto out_err;\n\t}\n\n\t \n\tif (hlist_empty(&conn->list)) {\n\t\thlist_add_head_rcu(&mark->obj_list, &conn->list);\n\t\tgoto added;\n\t}\n\n\t \n\thlist_for_each_entry(lmark, &conn->list, obj_list) {\n\t\tlast = lmark;\n\n\t\tif ((lmark->group == mark->group) &&\n\t\t    (lmark->flags & FSNOTIFY_MARK_FLAG_ATTACHED) &&\n\t\t    !(mark->group->flags & FSNOTIFY_GROUP_DUPS)) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tcmp = fsnotify_compare_groups(lmark->group, mark->group);\n\t\tif (cmp >= 0) {\n\t\t\thlist_add_before_rcu(&mark->obj_list, &lmark->obj_list);\n\t\t\tgoto added;\n\t\t}\n\t}\n\n\tBUG_ON(last == NULL);\n\t \n\thlist_add_behind_rcu(&mark->obj_list, &last->obj_list);\nadded:\n\t \n\tWRITE_ONCE(mark->connector, conn);\nout_err:\n\tspin_unlock(&conn->lock);\n\tspin_unlock(&mark->lock);\n\treturn err;\n}\n\n \nint fsnotify_add_mark_locked(struct fsnotify_mark *mark,\n\t\t\t     fsnotify_connp_t *connp, unsigned int obj_type,\n\t\t\t     int add_flags, __kernel_fsid_t *fsid)\n{\n\tstruct fsnotify_group *group = mark->group;\n\tint ret = 0;\n\n\tfsnotify_group_assert_locked(group);\n\n\t \n\tspin_lock(&mark->lock);\n\tmark->flags |= FSNOTIFY_MARK_FLAG_ALIVE | FSNOTIFY_MARK_FLAG_ATTACHED;\n\n\tlist_add(&mark->g_list, &group->marks_list);\n\tfsnotify_get_mark(mark);  \n\tspin_unlock(&mark->lock);\n\n\tret = fsnotify_add_mark_list(mark, connp, obj_type, add_flags, fsid);\n\tif (ret)\n\t\tgoto err;\n\n\tfsnotify_recalc_mask(mark->connector);\n\n\treturn ret;\nerr:\n\tspin_lock(&mark->lock);\n\tmark->flags &= ~(FSNOTIFY_MARK_FLAG_ALIVE |\n\t\t\t FSNOTIFY_MARK_FLAG_ATTACHED);\n\tlist_del_init(&mark->g_list);\n\tspin_unlock(&mark->lock);\n\n\tfsnotify_put_mark(mark);\n\treturn ret;\n}\n\nint fsnotify_add_mark(struct fsnotify_mark *mark, fsnotify_connp_t *connp,\n\t\t      unsigned int obj_type, int add_flags,\n\t\t      __kernel_fsid_t *fsid)\n{\n\tint ret;\n\tstruct fsnotify_group *group = mark->group;\n\n\tfsnotify_group_lock(group);\n\tret = fsnotify_add_mark_locked(mark, connp, obj_type, add_flags, fsid);\n\tfsnotify_group_unlock(group);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(fsnotify_add_mark);\n\n \nstruct fsnotify_mark *fsnotify_find_mark(fsnotify_connp_t *connp,\n\t\t\t\t\t struct fsnotify_group *group)\n{\n\tstruct fsnotify_mark_connector *conn;\n\tstruct fsnotify_mark *mark;\n\n\tconn = fsnotify_grab_connector(connp);\n\tif (!conn)\n\t\treturn NULL;\n\n\thlist_for_each_entry(mark, &conn->list, obj_list) {\n\t\tif (mark->group == group &&\n\t\t    (mark->flags & FSNOTIFY_MARK_FLAG_ATTACHED)) {\n\t\t\tfsnotify_get_mark(mark);\n\t\t\tspin_unlock(&conn->lock);\n\t\t\treturn mark;\n\t\t}\n\t}\n\tspin_unlock(&conn->lock);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(fsnotify_find_mark);\n\n \nvoid fsnotify_clear_marks_by_group(struct fsnotify_group *group,\n\t\t\t\t   unsigned int obj_type)\n{\n\tstruct fsnotify_mark *lmark, *mark;\n\tLIST_HEAD(to_free);\n\tstruct list_head *head = &to_free;\n\n\t \n\tif (obj_type == FSNOTIFY_OBJ_TYPE_ANY) {\n\t\thead = &group->marks_list;\n\t\tgoto clear;\n\t}\n\t \n\tfsnotify_group_lock(group);\n\tlist_for_each_entry_safe(mark, lmark, &group->marks_list, g_list) {\n\t\tif (mark->connector->type == obj_type)\n\t\t\tlist_move(&mark->g_list, &to_free);\n\t}\n\tfsnotify_group_unlock(group);\n\nclear:\n\twhile (1) {\n\t\tfsnotify_group_lock(group);\n\t\tif (list_empty(head)) {\n\t\t\tfsnotify_group_unlock(group);\n\t\t\tbreak;\n\t\t}\n\t\tmark = list_first_entry(head, struct fsnotify_mark, g_list);\n\t\tfsnotify_get_mark(mark);\n\t\tfsnotify_detach_mark(mark);\n\t\tfsnotify_group_unlock(group);\n\t\tfsnotify_free_mark(mark);\n\t\tfsnotify_put_mark(mark);\n\t}\n}\n\n \nvoid fsnotify_destroy_marks(fsnotify_connp_t *connp)\n{\n\tstruct fsnotify_mark_connector *conn;\n\tstruct fsnotify_mark *mark, *old_mark = NULL;\n\tvoid *objp;\n\tunsigned int type;\n\n\tconn = fsnotify_grab_connector(connp);\n\tif (!conn)\n\t\treturn;\n\t \n\thlist_for_each_entry(mark, &conn->list, obj_list) {\n\t\tfsnotify_get_mark(mark);\n\t\tspin_unlock(&conn->lock);\n\t\tif (old_mark)\n\t\t\tfsnotify_put_mark(old_mark);\n\t\told_mark = mark;\n\t\tfsnotify_destroy_mark(mark, mark->group);\n\t\tspin_lock(&conn->lock);\n\t}\n\t \n\tobjp = fsnotify_detach_connector_from_object(conn, &type);\n\tspin_unlock(&conn->lock);\n\tif (old_mark)\n\t\tfsnotify_put_mark(old_mark);\n\tfsnotify_drop_object(type, objp);\n}\n\n \nvoid fsnotify_init_mark(struct fsnotify_mark *mark,\n\t\t\tstruct fsnotify_group *group)\n{\n\tmemset(mark, 0, sizeof(*mark));\n\tspin_lock_init(&mark->lock);\n\trefcount_set(&mark->refcnt, 1);\n\tfsnotify_get_group(group);\n\tmark->group = group;\n\tWRITE_ONCE(mark->connector, NULL);\n}\nEXPORT_SYMBOL_GPL(fsnotify_init_mark);\n\n \nstatic void fsnotify_mark_destroy_workfn(struct work_struct *work)\n{\n\tstruct fsnotify_mark *mark, *next;\n\tstruct list_head private_destroy_list;\n\n\tspin_lock(&destroy_lock);\n\t \n\tlist_replace_init(&destroy_list, &private_destroy_list);\n\tspin_unlock(&destroy_lock);\n\n\tsynchronize_srcu(&fsnotify_mark_srcu);\n\n\tlist_for_each_entry_safe(mark, next, &private_destroy_list, g_list) {\n\t\tlist_del_init(&mark->g_list);\n\t\tfsnotify_final_mark_destroy(mark);\n\t}\n}\n\n \nvoid fsnotify_wait_marks_destroyed(void)\n{\n\tflush_delayed_work(&reaper_work);\n}\nEXPORT_SYMBOL_GPL(fsnotify_wait_marks_destroyed);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}