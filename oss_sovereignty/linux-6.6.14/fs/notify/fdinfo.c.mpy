{
  "module_name": "fdinfo.c",
  "hash_id": "df09302445218d7191bac20d1f57117fb9445779bbbb3d721429446c0e890b25",
  "original_prompt": "Ingested from linux-6.6.14/fs/notify/fdinfo.c",
  "human_readable_source": "\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/inotify.h>\n#include <linux/fanotify.h>\n#include <linux/kernel.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/seq_file.h>\n#include <linux/exportfs.h>\n\n#include \"inotify/inotify.h\"\n#include \"fanotify/fanotify.h\"\n#include \"fdinfo.h\"\n#include \"fsnotify.h\"\n\n#if defined(CONFIG_PROC_FS)\n\n#if defined(CONFIG_INOTIFY_USER) || defined(CONFIG_FANOTIFY)\n\nstatic void show_fdinfo(struct seq_file *m, struct file *f,\n\t\t\tvoid (*show)(struct seq_file *m,\n\t\t\t\t     struct fsnotify_mark *mark))\n{\n\tstruct fsnotify_group *group = f->private_data;\n\tstruct fsnotify_mark *mark;\n\n\tfsnotify_group_lock(group);\n\tlist_for_each_entry(mark, &group->marks_list, g_list) {\n\t\tshow(m, mark);\n\t\tif (seq_has_overflowed(m))\n\t\t\tbreak;\n\t}\n\tfsnotify_group_unlock(group);\n}\n\n#if defined(CONFIG_EXPORTFS)\nstatic void show_mark_fhandle(struct seq_file *m, struct inode *inode)\n{\n\tstruct {\n\t\tstruct file_handle handle;\n\t\tu8 pad[MAX_HANDLE_SZ];\n\t} f;\n\tint size, ret, i;\n\n\tf.handle.handle_bytes = sizeof(f.pad);\n\tsize = f.handle.handle_bytes >> 2;\n\n\tret = exportfs_encode_fid(inode, (struct fid *)f.handle.f_handle, &size);\n\tif ((ret == FILEID_INVALID) || (ret < 0)) {\n\t\tWARN_ONCE(1, \"Can't encode file handler for inotify: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tf.handle.handle_type = ret;\n\tf.handle.handle_bytes = size * sizeof(u32);\n\n\tseq_printf(m, \"fhandle-bytes:%x fhandle-type:%x f_handle:\",\n\t\t   f.handle.handle_bytes, f.handle.handle_type);\n\n\tfor (i = 0; i < f.handle.handle_bytes; i++)\n\t\tseq_printf(m, \"%02x\", (int)f.handle.f_handle[i]);\n}\n#else\nstatic void show_mark_fhandle(struct seq_file *m, struct inode *inode)\n{\n}\n#endif\n\n#ifdef CONFIG_INOTIFY_USER\n\nstatic void inotify_fdinfo(struct seq_file *m, struct fsnotify_mark *mark)\n{\n\tstruct inotify_inode_mark *inode_mark;\n\tstruct inode *inode;\n\n\tif (mark->connector->type != FSNOTIFY_OBJ_TYPE_INODE)\n\t\treturn;\n\n\tinode_mark = container_of(mark, struct inotify_inode_mark, fsn_mark);\n\tinode = igrab(fsnotify_conn_inode(mark->connector));\n\tif (inode) {\n\t\tseq_printf(m, \"inotify wd:%x ino:%lx sdev:%x mask:%x ignored_mask:0 \",\n\t\t\t   inode_mark->wd, inode->i_ino, inode->i_sb->s_dev,\n\t\t\t   inotify_mark_user_mask(mark));\n\t\tshow_mark_fhandle(m, inode);\n\t\tseq_putc(m, '\\n');\n\t\tiput(inode);\n\t}\n}\n\nvoid inotify_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tshow_fdinfo(m, f, inotify_fdinfo);\n}\n\n#endif  \n\n#ifdef CONFIG_FANOTIFY\n\nstatic void fanotify_fdinfo(struct seq_file *m, struct fsnotify_mark *mark)\n{\n\tunsigned int mflags = fanotify_mark_user_flags(mark);\n\tstruct inode *inode;\n\n\tif (mark->connector->type == FSNOTIFY_OBJ_TYPE_INODE) {\n\t\tinode = igrab(fsnotify_conn_inode(mark->connector));\n\t\tif (!inode)\n\t\t\treturn;\n\t\tseq_printf(m, \"fanotify ino:%lx sdev:%x mflags:%x mask:%x ignored_mask:%x \",\n\t\t\t   inode->i_ino, inode->i_sb->s_dev,\n\t\t\t   mflags, mark->mask, mark->ignore_mask);\n\t\tshow_mark_fhandle(m, inode);\n\t\tseq_putc(m, '\\n');\n\t\tiput(inode);\n\t} else if (mark->connector->type == FSNOTIFY_OBJ_TYPE_VFSMOUNT) {\n\t\tstruct mount *mnt = fsnotify_conn_mount(mark->connector);\n\n\t\tseq_printf(m, \"fanotify mnt_id:%x mflags:%x mask:%x ignored_mask:%x\\n\",\n\t\t\t   mnt->mnt_id, mflags, mark->mask, mark->ignore_mask);\n\t} else if (mark->connector->type == FSNOTIFY_OBJ_TYPE_SB) {\n\t\tstruct super_block *sb = fsnotify_conn_sb(mark->connector);\n\n\t\tseq_printf(m, \"fanotify sdev:%x mflags:%x mask:%x ignored_mask:%x\\n\",\n\t\t\t   sb->s_dev, mflags, mark->mask, mark->ignore_mask);\n\t}\n}\n\nvoid fanotify_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct fsnotify_group *group = f->private_data;\n\n\tseq_printf(m, \"fanotify flags:%x event-flags:%x\\n\",\n\t\t   group->fanotify_data.flags & FANOTIFY_INIT_FLAGS,\n\t\t   group->fanotify_data.f_flags);\n\n\tshow_fdinfo(m, f, fanotify_fdinfo);\n}\n\n#endif  \n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}