{
  "module_name": "inotify_fsnotify.c",
  "hash_id": "bf280b6fabc3c9a2af91897d60c0ef7d658b20d8d5242245bfc04f709372760f",
  "original_prompt": "Ingested from linux-6.6.14/fs/notify/inotify/inotify_fsnotify.c",
  "human_readable_source": "\n \n\n#include <linux/dcache.h>  \n#include <linux/fs.h>  \n#include <linux/fsnotify_backend.h>\n#include <linux/inotify.h>\n#include <linux/path.h>  \n#include <linux/slab.h>  \n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n\n#include \"inotify.h\"\n\n \nstatic bool event_compare(struct fsnotify_event *old_fsn,\n\t\t\t  struct fsnotify_event *new_fsn)\n{\n\tstruct inotify_event_info *old, *new;\n\n\told = INOTIFY_E(old_fsn);\n\tnew = INOTIFY_E(new_fsn);\n\tif (old->mask & FS_IN_IGNORED)\n\t\treturn false;\n\tif ((old->mask == new->mask) &&\n\t    (old->wd == new->wd) &&\n\t    (old->name_len == new->name_len) &&\n\t    (!old->name_len || !strcmp(old->name, new->name)))\n\t\treturn true;\n\treturn false;\n}\n\nstatic int inotify_merge(struct fsnotify_group *group,\n\t\t\t struct fsnotify_event *event)\n{\n\tstruct list_head *list = &group->notification_list;\n\tstruct fsnotify_event *last_event;\n\n\tlast_event = list_entry(list->prev, struct fsnotify_event, list);\n\treturn event_compare(last_event, event);\n}\n\nint inotify_handle_inode_event(struct fsnotify_mark *inode_mark, u32 mask,\n\t\t\t       struct inode *inode, struct inode *dir,\n\t\t\t       const struct qstr *name, u32 cookie)\n{\n\tstruct inotify_inode_mark *i_mark;\n\tstruct inotify_event_info *event;\n\tstruct fsnotify_event *fsn_event;\n\tstruct fsnotify_group *group = inode_mark->group;\n\tint ret;\n\tint len = 0, wd;\n\tint alloc_len = sizeof(struct inotify_event_info);\n\tstruct mem_cgroup *old_memcg;\n\n\tif (name) {\n\t\tlen = name->len;\n\t\talloc_len += len + 1;\n\t}\n\n\tpr_debug(\"%s: group=%p mark=%p mask=%x\\n\", __func__, group, inode_mark,\n\t\t mask);\n\n\ti_mark = container_of(inode_mark, struct inotify_inode_mark,\n\t\t\t      fsn_mark);\n\n\t \n\twd = READ_ONCE(i_mark->wd);\n\tif (wd == -1)\n\t\treturn 0;\n\t \n\told_memcg = set_active_memcg(group->memcg);\n\tevent = kmalloc(alloc_len, GFP_KERNEL_ACCOUNT | __GFP_RETRY_MAYFAIL);\n\tset_active_memcg(old_memcg);\n\n\tif (unlikely(!event)) {\n\t\t \n\t\tfsnotify_queue_overflow(group);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (mask & (IN_MOVE_SELF | IN_DELETE_SELF))\n\t\tmask &= ~IN_ISDIR;\n\n\tfsn_event = &event->fse;\n\tfsnotify_init_event(fsn_event);\n\tevent->mask = mask;\n\tevent->wd = wd;\n\tevent->sync_cookie = cookie;\n\tevent->name_len = len;\n\tif (len)\n\t\tstrcpy(event->name, name->name);\n\n\tret = fsnotify_add_event(group, fsn_event, inotify_merge);\n\tif (ret) {\n\t\t \n\t\tfsnotify_destroy_event(group, fsn_event);\n\t}\n\n\tif (inode_mark->flags & FSNOTIFY_MARK_FLAG_IN_ONESHOT)\n\t\tfsnotify_destroy_mark(inode_mark, group);\n\n\treturn 0;\n}\n\nstatic void inotify_freeing_mark(struct fsnotify_mark *fsn_mark, struct fsnotify_group *group)\n{\n\tinotify_ignored_and_remove_idr(fsn_mark, group);\n}\n\n \nstatic int idr_callback(int id, void *p, void *data)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct inotify_inode_mark *i_mark;\n\tstatic bool warned = false;\n\n\tif (warned)\n\t\treturn 0;\n\n\twarned = true;\n\tfsn_mark = p;\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\n\tWARN(1, \"inotify closing but id=%d for fsn_mark=%p in group=%p still in \"\n\t\t\"idr.  Probably leaking memory\\n\", id, p, data);\n\n\t \n\tif (fsn_mark)\n\t\tprintk(KERN_WARNING \"fsn_mark->group=%p wd=%d\\n\",\n\t\t\tfsn_mark->group, i_mark->wd);\n\treturn 0;\n}\n\nstatic void inotify_free_group_priv(struct fsnotify_group *group)\n{\n\t \n\tidr_for_each(&group->inotify_data.idr, idr_callback, group);\n\tidr_destroy(&group->inotify_data.idr);\n\tif (group->inotify_data.ucounts)\n\t\tdec_inotify_instances(group->inotify_data.ucounts);\n}\n\nstatic void inotify_free_event(struct fsnotify_group *group,\n\t\t\t       struct fsnotify_event *fsn_event)\n{\n\tkfree(INOTIFY_E(fsn_event));\n}\n\n \nstatic void inotify_free_mark(struct fsnotify_mark *fsn_mark)\n{\n\tstruct inotify_inode_mark *i_mark;\n\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\n\tkmem_cache_free(inotify_inode_mark_cachep, i_mark);\n}\n\nconst struct fsnotify_ops inotify_fsnotify_ops = {\n\t.handle_inode_event = inotify_handle_inode_event,\n\t.free_group_priv = inotify_free_group_priv,\n\t.free_event = inotify_free_event,\n\t.freeing_mark = inotify_freeing_mark,\n\t.free_mark = inotify_free_mark,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}