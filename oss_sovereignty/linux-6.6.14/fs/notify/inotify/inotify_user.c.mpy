{
  "module_name": "inotify_user.c",
  "hash_id": "869705ba3bdaebc3477808c83f0cffc5ca1b3d62a4e2df0abcab16deedd58ace",
  "original_prompt": "Ingested from linux-6.6.14/fs/notify/inotify/inotify_user.c",
  "human_readable_source": "\n \n\n#include <linux/file.h>\n#include <linux/fs.h>  \n#include <linux/fsnotify_backend.h>\n#include <linux/idr.h>\n#include <linux/init.h>  \n#include <linux/inotify.h>\n#include <linux/kernel.h>  \n#include <linux/namei.h>  \n#include <linux/sched/signal.h>\n#include <linux/slab.h>  \n#include <linux/syscalls.h>\n#include <linux/types.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/memcontrol.h>\n#include <linux/security.h>\n\n#include \"inotify.h\"\n#include \"../fdinfo.h\"\n\n#include <asm/ioctls.h>\n\n \n#define INOTIFY_WATCH_COST\t(sizeof(struct inotify_inode_mark) + \\\n\t\t\t\t 2 * sizeof(struct inode))\n\n \nstatic int inotify_max_queued_events __read_mostly;\n\nstruct kmem_cache *inotify_inode_mark_cachep __read_mostly;\n\n#ifdef CONFIG_SYSCTL\n\n#include <linux/sysctl.h>\n\nstatic long it_zero = 0;\nstatic long it_int_max = INT_MAX;\n\nstatic struct ctl_table inotify_table[] = {\n\t{\n\t\t.procname\t= \"max_user_instances\",\n\t\t.data\t\t= &init_user_ns.ucount_max[UCOUNT_INOTIFY_INSTANCES],\n\t\t.maxlen\t\t= sizeof(long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t\t.extra1\t\t= &it_zero,\n\t\t.extra2\t\t= &it_int_max,\n\t},\n\t{\n\t\t.procname\t= \"max_user_watches\",\n\t\t.data\t\t= &init_user_ns.ucount_max[UCOUNT_INOTIFY_WATCHES],\n\t\t.maxlen\t\t= sizeof(long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t\t.extra1\t\t= &it_zero,\n\t\t.extra2\t\t= &it_int_max,\n\t},\n\t{\n\t\t.procname\t= \"max_queued_events\",\n\t\t.data\t\t= &inotify_max_queued_events,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO\n\t},\n\t{ }\n};\n\nstatic void __init inotify_sysctls_init(void)\n{\n\tregister_sysctl(\"fs/inotify\", inotify_table);\n}\n\n#else\n#define inotify_sysctls_init() do { } while (0)\n#endif  \n\nstatic inline __u32 inotify_arg_to_mask(struct inode *inode, u32 arg)\n{\n\t__u32 mask;\n\n\t \n\tmask = (FS_UNMOUNT);\n\tif (S_ISDIR(inode->i_mode))\n\t\tmask |= FS_EVENT_ON_CHILD;\n\n\t \n\tmask |= (arg & INOTIFY_USER_MASK);\n\n\treturn mask;\n}\n\n#define INOTIFY_MARK_FLAGS \\\n\t(FSNOTIFY_MARK_FLAG_EXCL_UNLINK | FSNOTIFY_MARK_FLAG_IN_ONESHOT)\n\nstatic inline unsigned int inotify_arg_to_flags(u32 arg)\n{\n\tunsigned int flags = 0;\n\n\tif (arg & IN_EXCL_UNLINK)\n\t\tflags |= FSNOTIFY_MARK_FLAG_EXCL_UNLINK;\n\tif (arg & IN_ONESHOT)\n\t\tflags |= FSNOTIFY_MARK_FLAG_IN_ONESHOT;\n\n\treturn flags;\n}\n\nstatic inline u32 inotify_mask_to_arg(__u32 mask)\n{\n\treturn mask & (IN_ALL_EVENTS | IN_ISDIR | IN_UNMOUNT | IN_IGNORED |\n\t\t       IN_Q_OVERFLOW);\n}\n\n \nstatic __poll_t inotify_poll(struct file *file, poll_table *wait)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\t__poll_t ret = 0;\n\n\tpoll_wait(file, &group->notification_waitq, wait);\n\tspin_lock(&group->notification_lock);\n\tif (!fsnotify_notify_queue_is_empty(group))\n\t\tret = EPOLLIN | EPOLLRDNORM;\n\tspin_unlock(&group->notification_lock);\n\n\treturn ret;\n}\n\nstatic int round_event_name_len(struct fsnotify_event *fsn_event)\n{\n\tstruct inotify_event_info *event;\n\n\tevent = INOTIFY_E(fsn_event);\n\tif (!event->name_len)\n\t\treturn 0;\n\treturn roundup(event->name_len + 1, sizeof(struct inotify_event));\n}\n\n \nstatic struct fsnotify_event *get_one_event(struct fsnotify_group *group,\n\t\t\t\t\t    size_t count)\n{\n\tsize_t event_size = sizeof(struct inotify_event);\n\tstruct fsnotify_event *event;\n\n\tevent = fsnotify_peek_first_event(group);\n\tif (!event)\n\t\treturn NULL;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tevent_size += round_event_name_len(event);\n\tif (event_size > count)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tfsnotify_remove_first_event(group);\n\n\treturn event;\n}\n\n \nstatic ssize_t copy_event_to_user(struct fsnotify_group *group,\n\t\t\t\t  struct fsnotify_event *fsn_event,\n\t\t\t\t  char __user *buf)\n{\n\tstruct inotify_event inotify_event;\n\tstruct inotify_event_info *event;\n\tsize_t event_size = sizeof(struct inotify_event);\n\tsize_t name_len;\n\tsize_t pad_name_len;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, fsn_event);\n\n\tevent = INOTIFY_E(fsn_event);\n\tname_len = event->name_len;\n\t \n\tpad_name_len = round_event_name_len(fsn_event);\n\tinotify_event.len = pad_name_len;\n\tinotify_event.mask = inotify_mask_to_arg(event->mask);\n\tinotify_event.wd = event->wd;\n\tinotify_event.cookie = event->sync_cookie;\n\n\t \n\tif (copy_to_user(buf, &inotify_event, event_size))\n\t\treturn -EFAULT;\n\n\tbuf += event_size;\n\n\t \n\tif (pad_name_len) {\n\t\t \n\t\tif (copy_to_user(buf, event->name, name_len))\n\t\t\treturn -EFAULT;\n\t\tbuf += name_len;\n\n\t\t \n\t\tif (clear_user(buf, pad_name_len - name_len))\n\t\t\treturn -EFAULT;\n\t\tevent_size += pad_name_len;\n\t}\n\n\treturn event_size;\n}\n\nstatic ssize_t inotify_read(struct file *file, char __user *buf,\n\t\t\t    size_t count, loff_t *pos)\n{\n\tstruct fsnotify_group *group;\n\tstruct fsnotify_event *kevent;\n\tchar __user *start;\n\tint ret;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tstart = buf;\n\tgroup = file->private_data;\n\n\tadd_wait_queue(&group->notification_waitq, &wait);\n\twhile (1) {\n\t\tspin_lock(&group->notification_lock);\n\t\tkevent = get_one_event(group, count);\n\t\tspin_unlock(&group->notification_lock);\n\n\t\tpr_debug(\"%s: group=%p kevent=%p\\n\", __func__, group, kevent);\n\n\t\tif (kevent) {\n\t\t\tret = PTR_ERR(kevent);\n\t\t\tif (IS_ERR(kevent))\n\t\t\t\tbreak;\n\t\t\tret = copy_event_to_user(group, kevent, buf);\n\t\t\tfsnotify_destroy_event(group, kevent);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tbuf += ret;\n\t\t\tcount -= ret;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = -EAGAIN;\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\t\tret = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tif (start != buf)\n\t\t\tbreak;\n\n\t\twait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t}\n\tremove_wait_queue(&group->notification_waitq, &wait);\n\n\tif (start != buf && ret != -EFAULT)\n\t\tret = buf - start;\n\treturn ret;\n}\n\nstatic int inotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\n\t \n\tfsnotify_destroy_group(group);\n\n\treturn 0;\n}\n\nstatic long inotify_ioctl(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct fsnotify_group *group;\n\tstruct fsnotify_event *fsn_event;\n\tvoid __user *p;\n\tint ret = -ENOTTY;\n\tsize_t send_len = 0;\n\n\tgroup = file->private_data;\n\tp = (void __user *) arg;\n\n\tpr_debug(\"%s: group=%p cmd=%u\\n\", __func__, group, cmd);\n\n\tswitch (cmd) {\n\tcase FIONREAD:\n\t\tspin_lock(&group->notification_lock);\n\t\tlist_for_each_entry(fsn_event, &group->notification_list,\n\t\t\t\t    list) {\n\t\t\tsend_len += sizeof(struct inotify_event);\n\t\t\tsend_len += round_event_name_len(fsn_event);\n\t\t}\n\t\tspin_unlock(&group->notification_lock);\n\t\tret = put_user(send_len, (int __user *) p);\n\t\tbreak;\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tcase INOTIFY_IOC_SETNEXTWD:\n\t\tret = -EINVAL;\n\t\tif (arg >= 1 && arg <= INT_MAX) {\n\t\t\tstruct inotify_group_private_data *data;\n\n\t\t\tdata = &group->inotify_data;\n\t\t\tspin_lock(&data->idr_lock);\n\t\t\tidr_set_cursor(&data->idr, (unsigned int)arg);\n\t\t\tspin_unlock(&data->idr_lock);\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n#endif  \n\t}\n\n\treturn ret;\n}\n\nstatic const struct file_operations inotify_fops = {\n\t.show_fdinfo\t= inotify_show_fdinfo,\n\t.poll\t\t= inotify_poll,\n\t.read\t\t= inotify_read,\n\t.fasync\t\t= fsnotify_fasync,\n\t.release\t= inotify_release,\n\t.unlocked_ioctl\t= inotify_ioctl,\n\t.compat_ioctl\t= inotify_ioctl,\n\t.llseek\t\t= noop_llseek,\n};\n\n\n \nstatic int inotify_find_inode(const char __user *dirname, struct path *path,\n\t\t\t\t\t\tunsigned int flags, __u64 mask)\n{\n\tint error;\n\n\terror = user_path_at(AT_FDCWD, dirname, flags, path);\n\tif (error)\n\t\treturn error;\n\t \n\terror = path_permission(path, MAY_READ);\n\tif (error) {\n\t\tpath_put(path);\n\t\treturn error;\n\t}\n\terror = security_path_notify(path, mask,\n\t\t\t\tFSNOTIFY_OBJ_TYPE_INODE);\n\tif (error)\n\t\tpath_put(path);\n\n\treturn error;\n}\n\nstatic int inotify_add_to_idr(struct idr *idr, spinlock_t *idr_lock,\n\t\t\t      struct inotify_inode_mark *i_mark)\n{\n\tint ret;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(idr_lock);\n\n\tret = idr_alloc_cyclic(idr, i_mark, 1, 0, GFP_NOWAIT);\n\tif (ret >= 0) {\n\t\t \n\t\ti_mark->wd = ret;\n\t\tfsnotify_get_mark(&i_mark->fsn_mark);\n\t}\n\n\tspin_unlock(idr_lock);\n\tidr_preload_end();\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic struct inotify_inode_mark *inotify_idr_find_locked(struct fsnotify_group *group,\n\t\t\t\t\t\t\t\tint wd)\n{\n\tstruct idr *idr = &group->inotify_data.idr;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tstruct inotify_inode_mark *i_mark;\n\n\tassert_spin_locked(idr_lock);\n\n\ti_mark = idr_find(idr, wd);\n\tif (i_mark) {\n\t\tstruct fsnotify_mark *fsn_mark = &i_mark->fsn_mark;\n\n\t\tfsnotify_get_mark(fsn_mark);\n\t\t \n\t\tBUG_ON(refcount_read(&fsn_mark->refcnt) < 2);\n\t}\n\n\treturn i_mark;\n}\n\nstatic struct inotify_inode_mark *inotify_idr_find(struct fsnotify_group *group,\n\t\t\t\t\t\t\t int wd)\n{\n\tstruct inotify_inode_mark *i_mark;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\n\tspin_lock(idr_lock);\n\ti_mark = inotify_idr_find_locked(group, wd);\n\tspin_unlock(idr_lock);\n\n\treturn i_mark;\n}\n\n \nstatic void inotify_remove_from_idr(struct fsnotify_group *group,\n\t\t\t\t    struct inotify_inode_mark *i_mark)\n{\n\tstruct idr *idr = &group->inotify_data.idr;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tstruct inotify_inode_mark *found_i_mark = NULL;\n\tint wd;\n\n\tspin_lock(idr_lock);\n\twd = i_mark->wd;\n\n\t \n\tif (wd == -1) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\\n\",\n\t\t\t__func__, i_mark, i_mark->wd, i_mark->fsn_mark.group);\n\t\tgoto out;\n\t}\n\n\t \n\tfound_i_mark = inotify_idr_find_locked(group, wd);\n\tif (unlikely(!found_i_mark)) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\\n\",\n\t\t\t__func__, i_mark, i_mark->wd, i_mark->fsn_mark.group);\n\t\tgoto out;\n\t}\n\n\t \n\tif (unlikely(found_i_mark != i_mark)) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p \"\n\t\t\t\"found_i_mark=%p found_i_mark->wd=%d \"\n\t\t\t\"found_i_mark->group=%p\\n\", __func__, i_mark,\n\t\t\ti_mark->wd, i_mark->fsn_mark.group, found_i_mark,\n\t\t\tfound_i_mark->wd, found_i_mark->fsn_mark.group);\n\t\tgoto out;\n\t}\n\n\t \n\tif (unlikely(refcount_read(&i_mark->fsn_mark.refcnt) < 2)) {\n\t\tprintk(KERN_ERR \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\\n\",\n\t\t\t __func__, i_mark, i_mark->wd, i_mark->fsn_mark.group);\n\t\t \n\t\tBUG();\n\t}\n\n\tidr_remove(idr, wd);\n\t \n\tfsnotify_put_mark(&i_mark->fsn_mark);\nout:\n\ti_mark->wd = -1;\n\tspin_unlock(idr_lock);\n\t \n\tif (found_i_mark)\n\t\tfsnotify_put_mark(&found_i_mark->fsn_mark);\n}\n\n \nvoid inotify_ignored_and_remove_idr(struct fsnotify_mark *fsn_mark,\n\t\t\t\t    struct fsnotify_group *group)\n{\n\tstruct inotify_inode_mark *i_mark;\n\n\t \n\tinotify_handle_inode_event(fsn_mark, FS_IN_IGNORED, NULL, NULL, NULL,\n\t\t\t\t   0);\n\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\t \n\tinotify_remove_from_idr(group, i_mark);\n\n\tdec_inotify_watches(group->inotify_data.ucounts);\n}\n\nstatic int inotify_update_existing_watch(struct fsnotify_group *group,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t u32 arg)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct inotify_inode_mark *i_mark;\n\t__u32 old_mask, new_mask;\n\tint replace = !(arg & IN_MASK_ADD);\n\tint create = (arg & IN_MASK_CREATE);\n\tint ret;\n\n\tfsn_mark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);\n\tif (!fsn_mark)\n\t\treturn -ENOENT;\n\telse if (create) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\n\tspin_lock(&fsn_mark->lock);\n\told_mask = fsn_mark->mask;\n\tif (replace) {\n\t\tfsn_mark->mask = 0;\n\t\tfsn_mark->flags &= ~INOTIFY_MARK_FLAGS;\n\t}\n\tfsn_mark->mask |= inotify_arg_to_mask(inode, arg);\n\tfsn_mark->flags |= inotify_arg_to_flags(arg);\n\tnew_mask = fsn_mark->mask;\n\tspin_unlock(&fsn_mark->lock);\n\n\tif (old_mask != new_mask) {\n\t\t \n\t\tint dropped = (old_mask & ~new_mask);\n\t\t \n\t\tint do_inode = (new_mask & ~inode->i_fsnotify_mask);\n\n\t\t \n\t\tif (dropped || do_inode)\n\t\t\tfsnotify_recalc_mask(inode->i_fsnotify_marks);\n\n\t}\n\n\t \n\tret = i_mark->wd;\n\nout:\n\t \n\tfsnotify_put_mark(fsn_mark);\n\n\treturn ret;\n}\n\nstatic int inotify_new_watch(struct fsnotify_group *group,\n\t\t\t     struct inode *inode,\n\t\t\t     u32 arg)\n{\n\tstruct inotify_inode_mark *tmp_i_mark;\n\tint ret;\n\tstruct idr *idr = &group->inotify_data.idr;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\n\ttmp_i_mark = kmem_cache_alloc(inotify_inode_mark_cachep, GFP_KERNEL);\n\tif (unlikely(!tmp_i_mark))\n\t\treturn -ENOMEM;\n\n\tfsnotify_init_mark(&tmp_i_mark->fsn_mark, group);\n\ttmp_i_mark->fsn_mark.mask = inotify_arg_to_mask(inode, arg);\n\ttmp_i_mark->fsn_mark.flags = inotify_arg_to_flags(arg);\n\ttmp_i_mark->wd = -1;\n\n\tret = inotify_add_to_idr(idr, idr_lock, tmp_i_mark);\n\tif (ret)\n\t\tgoto out_err;\n\n\t \n\tif (!inc_inotify_watches(group->inotify_data.ucounts)) {\n\t\tinotify_remove_from_idr(group, tmp_i_mark);\n\t\tret = -ENOSPC;\n\t\tgoto out_err;\n\t}\n\n\t \n\tret = fsnotify_add_inode_mark_locked(&tmp_i_mark->fsn_mark, inode, 0);\n\tif (ret) {\n\t\t \n\t\tinotify_remove_from_idr(group, tmp_i_mark);\n\t\tgoto out_err;\n\t}\n\n\n\t \n\tret = tmp_i_mark->wd;\n\nout_err:\n\t \n\tfsnotify_put_mark(&tmp_i_mark->fsn_mark);\n\n\treturn ret;\n}\n\nstatic int inotify_update_watch(struct fsnotify_group *group, struct inode *inode, u32 arg)\n{\n\tint ret = 0;\n\n\tfsnotify_group_lock(group);\n\t \n\tret = inotify_update_existing_watch(group, inode, arg);\n\t \n\tif (ret == -ENOENT)\n\t\tret = inotify_new_watch(group, inode, arg);\n\tfsnotify_group_unlock(group);\n\n\treturn ret;\n}\n\nstatic struct fsnotify_group *inotify_new_group(unsigned int max_events)\n{\n\tstruct fsnotify_group *group;\n\tstruct inotify_event_info *oevent;\n\n\tgroup = fsnotify_alloc_group(&inotify_fsnotify_ops,\n\t\t\t\t     FSNOTIFY_GROUP_USER);\n\tif (IS_ERR(group))\n\t\treturn group;\n\n\toevent = kmalloc(sizeof(struct inotify_event_info), GFP_KERNEL_ACCOUNT);\n\tif (unlikely(!oevent)) {\n\t\tfsnotify_destroy_group(group);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tgroup->overflow_event = &oevent->fse;\n\tfsnotify_init_event(group->overflow_event);\n\toevent->mask = FS_Q_OVERFLOW;\n\toevent->wd = -1;\n\toevent->sync_cookie = 0;\n\toevent->name_len = 0;\n\n\tgroup->max_events = max_events;\n\tgroup->memcg = get_mem_cgroup_from_mm(current->mm);\n\n\tspin_lock_init(&group->inotify_data.idr_lock);\n\tidr_init(&group->inotify_data.idr);\n\tgroup->inotify_data.ucounts = inc_ucount(current_user_ns(),\n\t\t\t\t\t\t current_euid(),\n\t\t\t\t\t\t UCOUNT_INOTIFY_INSTANCES);\n\n\tif (!group->inotify_data.ucounts) {\n\t\tfsnotify_destroy_group(group);\n\t\treturn ERR_PTR(-EMFILE);\n\t}\n\n\treturn group;\n}\n\n\n \nstatic int do_inotify_init(int flags)\n{\n\tstruct fsnotify_group *group;\n\tint ret;\n\n\t \n\tBUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~(IN_CLOEXEC | IN_NONBLOCK))\n\t\treturn -EINVAL;\n\n\t \n\tgroup = inotify_new_group(inotify_max_queued_events);\n\tif (IS_ERR(group))\n\t\treturn PTR_ERR(group);\n\n\tret = anon_inode_getfd(\"inotify\", &inotify_fops, group,\n\t\t\t\t  O_RDONLY | flags);\n\tif (ret < 0)\n\t\tfsnotify_destroy_group(group);\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE1(inotify_init1, int, flags)\n{\n\treturn do_inotify_init(flags);\n}\n\nSYSCALL_DEFINE0(inotify_init)\n{\n\treturn do_inotify_init(0);\n}\n\nSYSCALL_DEFINE3(inotify_add_watch, int, fd, const char __user *, pathname,\n\t\tu32, mask)\n{\n\tstruct fsnotify_group *group;\n\tstruct inode *inode;\n\tstruct path path;\n\tstruct fd f;\n\tint ret;\n\tunsigned flags = 0;\n\n\t \n\tif (unlikely(mask & ~ALL_INOTIFY_BITS))\n\t\treturn -EINVAL;\n\t \n\tif (unlikely(!(mask & ALL_INOTIFY_BITS)))\n\t\treturn -EINVAL;\n\n\tf = fdget(fd);\n\tif (unlikely(!f.file))\n\t\treturn -EBADF;\n\n\t \n\tif (unlikely((mask & IN_MASK_ADD) && (mask & IN_MASK_CREATE))) {\n\t\tret = -EINVAL;\n\t\tgoto fput_and_out;\n\t}\n\n\t \n\tif (unlikely(f.file->f_op != &inotify_fops)) {\n\t\tret = -EINVAL;\n\t\tgoto fput_and_out;\n\t}\n\n\tif (!(mask & IN_DONT_FOLLOW))\n\t\tflags |= LOOKUP_FOLLOW;\n\tif (mask & IN_ONLYDIR)\n\t\tflags |= LOOKUP_DIRECTORY;\n\n\tret = inotify_find_inode(pathname, &path, flags,\n\t\t\t(mask & IN_ALL_EVENTS));\n\tif (ret)\n\t\tgoto fput_and_out;\n\n\t \n\tinode = path.dentry->d_inode;\n\tgroup = f.file->private_data;\n\n\t \n\tret = inotify_update_watch(group, inode, mask);\n\tpath_put(&path);\nfput_and_out:\n\tfdput(f);\n\treturn ret;\n}\n\nSYSCALL_DEFINE2(inotify_rm_watch, int, fd, __s32, wd)\n{\n\tstruct fsnotify_group *group;\n\tstruct inotify_inode_mark *i_mark;\n\tstruct fd f;\n\tint ret = -EINVAL;\n\n\tf = fdget(fd);\n\tif (unlikely(!f.file))\n\t\treturn -EBADF;\n\n\t \n\tif (unlikely(f.file->f_op != &inotify_fops))\n\t\tgoto out;\n\n\tgroup = f.file->private_data;\n\n\ti_mark = inotify_idr_find(group, wd);\n\tif (unlikely(!i_mark))\n\t\tgoto out;\n\n\tret = 0;\n\n\tfsnotify_destroy_mark(&i_mark->fsn_mark, group);\n\n\t \n\tfsnotify_put_mark(&i_mark->fsn_mark);\n\nout:\n\tfdput(f);\n\treturn ret;\n}\n\n \nstatic int __init inotify_user_setup(void)\n{\n\tunsigned long watches_max;\n\tstruct sysinfo si;\n\n\tsi_meminfo(&si);\n\t \n\twatches_max = (((si.totalram - si.totalhigh) / 100) << PAGE_SHIFT) /\n\t\t\tINOTIFY_WATCH_COST;\n\twatches_max = clamp(watches_max, 8192UL, 1048576UL);\n\n\tBUILD_BUG_ON(IN_ACCESS != FS_ACCESS);\n\tBUILD_BUG_ON(IN_MODIFY != FS_MODIFY);\n\tBUILD_BUG_ON(IN_ATTRIB != FS_ATTRIB);\n\tBUILD_BUG_ON(IN_CLOSE_WRITE != FS_CLOSE_WRITE);\n\tBUILD_BUG_ON(IN_CLOSE_NOWRITE != FS_CLOSE_NOWRITE);\n\tBUILD_BUG_ON(IN_OPEN != FS_OPEN);\n\tBUILD_BUG_ON(IN_MOVED_FROM != FS_MOVED_FROM);\n\tBUILD_BUG_ON(IN_MOVED_TO != FS_MOVED_TO);\n\tBUILD_BUG_ON(IN_CREATE != FS_CREATE);\n\tBUILD_BUG_ON(IN_DELETE != FS_DELETE);\n\tBUILD_BUG_ON(IN_DELETE_SELF != FS_DELETE_SELF);\n\tBUILD_BUG_ON(IN_MOVE_SELF != FS_MOVE_SELF);\n\tBUILD_BUG_ON(IN_UNMOUNT != FS_UNMOUNT);\n\tBUILD_BUG_ON(IN_Q_OVERFLOW != FS_Q_OVERFLOW);\n\tBUILD_BUG_ON(IN_IGNORED != FS_IN_IGNORED);\n\tBUILD_BUG_ON(IN_ISDIR != FS_ISDIR);\n\n\tBUILD_BUG_ON(HWEIGHT32(ALL_INOTIFY_BITS) != 22);\n\n\tinotify_inode_mark_cachep = KMEM_CACHE(inotify_inode_mark,\n\t\t\t\t\t       SLAB_PANIC|SLAB_ACCOUNT);\n\n\tinotify_max_queued_events = 16384;\n\tinit_user_ns.ucount_max[UCOUNT_INOTIFY_INSTANCES] = 128;\n\tinit_user_ns.ucount_max[UCOUNT_INOTIFY_WATCHES] = watches_max;\n\tinotify_sysctls_init();\n\n\treturn 0;\n}\nfs_initcall(inotify_user_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}