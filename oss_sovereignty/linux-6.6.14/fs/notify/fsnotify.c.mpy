{
  "module_name": "fsnotify.c",
  "hash_id": "ece7b2ea4118d17d8edebc775252098543c26cdd4da8bddaa22f3f968ace86da",
  "original_prompt": "Ingested from linux-6.6.14/fs/notify/fsnotify.c",
  "human_readable_source": "\n \n\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/srcu.h>\n\n#include <linux/fsnotify_backend.h>\n#include \"fsnotify.h\"\n\n \nvoid __fsnotify_inode_delete(struct inode *inode)\n{\n\tfsnotify_clear_marks_by_inode(inode);\n}\nEXPORT_SYMBOL_GPL(__fsnotify_inode_delete);\n\nvoid __fsnotify_vfsmount_delete(struct vfsmount *mnt)\n{\n\tfsnotify_clear_marks_by_mount(mnt);\n}\n\n \nstatic void fsnotify_unmount_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *iput_inode = NULL;\n\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry(inode, &sb->s_inodes, i_sb_list) {\n\t\t \n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!atomic_read(&inode->i_count)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&sb->s_inode_list_lock);\n\n\t\tiput(iput_inode);\n\n\t\t \n\t\tfsnotify_inode(inode, FS_UNMOUNT);\n\n\t\tfsnotify_inode_delete(inode);\n\n\t\tiput_inode = inode;\n\n\t\tcond_resched();\n\t\tspin_lock(&sb->s_inode_list_lock);\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\tiput(iput_inode);\n}\n\nvoid fsnotify_sb_delete(struct super_block *sb)\n{\n\tfsnotify_unmount_inodes(sb);\n\tfsnotify_clear_marks_by_sb(sb);\n\t \n\twait_var_event(&sb->s_fsnotify_connectors,\n\t\t       !atomic_long_read(&sb->s_fsnotify_connectors));\n}\n\n \nvoid __fsnotify_update_child_dentry_flags(struct inode *inode)\n{\n\tstruct dentry *alias;\n\tint watched;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\t \n\twatched = fsnotify_inode_watches_children(inode);\n\n\tspin_lock(&inode->i_lock);\n\t \n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tstruct dentry *child;\n\n\t\t \n\t\tspin_lock(&alias->d_lock);\n\t\tlist_for_each_entry(child, &alias->d_subdirs, d_child) {\n\t\t\tif (!child->d_inode)\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\t\tif (watched)\n\t\t\t\tchild->d_flags |= DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\telse\n\t\t\t\tchild->d_flags &= ~DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\tspin_unlock(&child->d_lock);\n\t\t}\n\t\tspin_unlock(&alias->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}\n\n \nstatic bool fsnotify_event_needs_parent(struct inode *inode, struct mount *mnt,\n\t\t\t\t\t__u32 mask)\n{\n\t__u32 marks_mask = 0;\n\n\t \n\tif (mask & FS_ISDIR)\n\t\treturn false;\n\n\t \n\tBUILD_BUG_ON(FS_EVENTS_POSS_ON_CHILD & ~FS_EVENTS_POSS_TO_PARENT);\n\n\t \n\tmarks_mask |= fsnotify_parent_needed_mask(inode->i_fsnotify_mask);\n\tmarks_mask |= fsnotify_parent_needed_mask(inode->i_sb->s_fsnotify_mask);\n\tif (mnt)\n\t\tmarks_mask |= fsnotify_parent_needed_mask(mnt->mnt_fsnotify_mask);\n\n\t \n\treturn mask & marks_mask;\n}\n\n \nint __fsnotify_parent(struct dentry *dentry, __u32 mask, const void *data,\n\t\t      int data_type)\n{\n\tconst struct path *path = fsnotify_data_path(data, data_type);\n\tstruct mount *mnt = path ? real_mount(path->mnt) : NULL;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct dentry *parent;\n\tbool parent_watched = dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED;\n\tbool parent_needed, parent_interested;\n\t__u32 p_mask;\n\tstruct inode *p_inode = NULL;\n\tstruct name_snapshot name;\n\tstruct qstr *file_name = NULL;\n\tint ret = 0;\n\n\t \n\tif (!inode->i_fsnotify_marks && !inode->i_sb->s_fsnotify_marks &&\n\t    (!mnt || !mnt->mnt_fsnotify_marks) && !parent_watched)\n\t\treturn 0;\n\n\tparent = NULL;\n\tparent_needed = fsnotify_event_needs_parent(inode, mnt, mask);\n\tif (!parent_watched && !parent_needed)\n\t\tgoto notify;\n\n\t \n\tparent = dget_parent(dentry);\n\tp_inode = parent->d_inode;\n\tp_mask = fsnotify_inode_watches_children(p_inode);\n\tif (unlikely(parent_watched && !p_mask))\n\t\t__fsnotify_update_child_dentry_flags(p_inode);\n\n\t \n\tparent_interested = mask & p_mask & ALL_FSNOTIFY_EVENTS;\n\tif (parent_needed || parent_interested) {\n\t\t \n\t\tWARN_ON_ONCE(inode != fsnotify_data_inode(data, data_type));\n\n\t\t \n\t\ttake_dentry_name_snapshot(&name, dentry);\n\t\tfile_name = &name.name;\n\t\tif (parent_interested)\n\t\t\tmask |= FS_EVENT_ON_CHILD;\n\t}\n\nnotify:\n\tret = fsnotify(mask, data, data_type, p_inode, file_name, inode, 0);\n\n\tif (file_name)\n\t\trelease_dentry_name_snapshot(&name);\n\tdput(parent);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__fsnotify_parent);\n\nstatic int fsnotify_handle_inode_event(struct fsnotify_group *group,\n\t\t\t\t       struct fsnotify_mark *inode_mark,\n\t\t\t\t       u32 mask, const void *data, int data_type,\n\t\t\t\t       struct inode *dir, const struct qstr *name,\n\t\t\t\t       u32 cookie)\n{\n\tconst struct path *path = fsnotify_data_path(data, data_type);\n\tstruct inode *inode = fsnotify_data_inode(data, data_type);\n\tconst struct fsnotify_ops *ops = group->ops;\n\n\tif (WARN_ON_ONCE(!ops->handle_inode_event))\n\t\treturn 0;\n\n\tif (WARN_ON_ONCE(!inode && !dir))\n\t\treturn 0;\n\n\tif ((inode_mark->flags & FSNOTIFY_MARK_FLAG_EXCL_UNLINK) &&\n\t    path && d_unlinked(path->dentry))\n\t\treturn 0;\n\n\t \n\tif (!(mask & inode_mark->mask & ALL_FSNOTIFY_EVENTS))\n\t\treturn 0;\n\n\treturn ops->handle_inode_event(inode_mark, mask, inode, dir, name, cookie);\n}\n\nstatic int fsnotify_handle_event(struct fsnotify_group *group, __u32 mask,\n\t\t\t\t const void *data, int data_type,\n\t\t\t\t struct inode *dir, const struct qstr *name,\n\t\t\t\t u32 cookie, struct fsnotify_iter_info *iter_info)\n{\n\tstruct fsnotify_mark *inode_mark = fsnotify_iter_inode_mark(iter_info);\n\tstruct fsnotify_mark *parent_mark = fsnotify_iter_parent_mark(iter_info);\n\tint ret;\n\n\tif (WARN_ON_ONCE(fsnotify_iter_sb_mark(iter_info)) ||\n\t    WARN_ON_ONCE(fsnotify_iter_vfsmount_mark(iter_info)))\n\t\treturn 0;\n\n\t \n\tif (mask & FS_RENAME) {\n\t\tstruct dentry *moved = fsnotify_data_dentry(data, data_type);\n\n\t\tif (dir != moved->d_parent->d_inode)\n\t\t\treturn 0;\n\t}\n\n\tif (parent_mark) {\n\t\tret = fsnotify_handle_inode_event(group, parent_mark, mask,\n\t\t\t\t\t\t  data, data_type, dir, name, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!inode_mark)\n\t\treturn 0;\n\n\tif (mask & FS_EVENT_ON_CHILD) {\n\t\t \n\t\tmask &= ~FS_EVENT_ON_CHILD;\n\t\tdir = NULL;\n\t\tname = NULL;\n\t}\n\n\treturn fsnotify_handle_inode_event(group, inode_mark, mask, data, data_type,\n\t\t\t\t\t   dir, name, cookie);\n}\n\nstatic int send_to_group(__u32 mask, const void *data, int data_type,\n\t\t\t struct inode *dir, const struct qstr *file_name,\n\t\t\t u32 cookie, struct fsnotify_iter_info *iter_info)\n{\n\tstruct fsnotify_group *group = NULL;\n\t__u32 test_mask = (mask & ALL_FSNOTIFY_EVENTS);\n\t__u32 marks_mask = 0;\n\t__u32 marks_ignore_mask = 0;\n\tbool is_dir = mask & FS_ISDIR;\n\tstruct fsnotify_mark *mark;\n\tint type;\n\n\tif (!iter_info->report_mask)\n\t\treturn 0;\n\n\t \n\tif (mask & FS_MODIFY) {\n\t\tfsnotify_foreach_iter_mark_type(iter_info, mark, type) {\n\t\t\tif (!(mark->flags &\n\t\t\t      FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY))\n\t\t\t\tmark->ignore_mask = 0;\n\t\t}\n\t}\n\n\t \n\tfsnotify_foreach_iter_mark_type(iter_info, mark, type) {\n\t\tgroup = mark->group;\n\t\tmarks_mask |= mark->mask;\n\t\tmarks_ignore_mask |=\n\t\t\tfsnotify_effective_ignore_mask(mark, is_dir, type);\n\t}\n\n\tpr_debug(\"%s: group=%p mask=%x marks_mask=%x marks_ignore_mask=%x data=%p data_type=%d dir=%p cookie=%d\\n\",\n\t\t __func__, group, mask, marks_mask, marks_ignore_mask,\n\t\t data, data_type, dir, cookie);\n\n\tif (!(test_mask & marks_mask & ~marks_ignore_mask))\n\t\treturn 0;\n\n\tif (group->ops->handle_event) {\n\t\treturn group->ops->handle_event(group, mask, data, data_type, dir,\n\t\t\t\t\t\tfile_name, cookie, iter_info);\n\t}\n\n\treturn fsnotify_handle_event(group, mask, data, data_type, dir,\n\t\t\t\t     file_name, cookie, iter_info);\n}\n\nstatic struct fsnotify_mark *fsnotify_first_mark(struct fsnotify_mark_connector **connp)\n{\n\tstruct fsnotify_mark_connector *conn;\n\tstruct hlist_node *node = NULL;\n\n\tconn = srcu_dereference(*connp, &fsnotify_mark_srcu);\n\tif (conn)\n\t\tnode = srcu_dereference(conn->list.first, &fsnotify_mark_srcu);\n\n\treturn hlist_entry_safe(node, struct fsnotify_mark, obj_list);\n}\n\nstatic struct fsnotify_mark *fsnotify_next_mark(struct fsnotify_mark *mark)\n{\n\tstruct hlist_node *node = NULL;\n\n\tif (mark)\n\t\tnode = srcu_dereference(mark->obj_list.next,\n\t\t\t\t\t&fsnotify_mark_srcu);\n\n\treturn hlist_entry_safe(node, struct fsnotify_mark, obj_list);\n}\n\n \nstatic bool fsnotify_iter_select_report_types(\n\t\tstruct fsnotify_iter_info *iter_info)\n{\n\tstruct fsnotify_group *max_prio_group = NULL;\n\tstruct fsnotify_mark *mark;\n\tint type;\n\n\t \n\tfsnotify_foreach_iter_type(type) {\n\t\tmark = iter_info->marks[type];\n\t\tif (mark &&\n\t\t    fsnotify_compare_groups(max_prio_group, mark->group) > 0)\n\t\t\tmax_prio_group = mark->group;\n\t}\n\n\tif (!max_prio_group)\n\t\treturn false;\n\n\t \n\titer_info->current_group = max_prio_group;\n\titer_info->report_mask = 0;\n\tfsnotify_foreach_iter_type(type) {\n\t\tmark = iter_info->marks[type];\n\t\tif (mark && mark->group == iter_info->current_group) {\n\t\t\t \n\t\t\tif (type == FSNOTIFY_ITER_TYPE_PARENT &&\n\t\t\t    !(mark->mask & FS_EVENT_ON_CHILD) &&\n\t\t\t    !(fsnotify_ignore_mask(mark) & FS_EVENT_ON_CHILD))\n\t\t\t\tcontinue;\n\n\t\t\tfsnotify_iter_set_report_type(iter_info, type);\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nstatic void fsnotify_iter_next(struct fsnotify_iter_info *iter_info)\n{\n\tstruct fsnotify_mark *mark;\n\tint type;\n\n\t \n\tfsnotify_foreach_iter_type(type) {\n\t\tmark = iter_info->marks[type];\n\t\tif (mark && mark->group == iter_info->current_group)\n\t\t\titer_info->marks[type] =\n\t\t\t\tfsnotify_next_mark(iter_info->marks[type]);\n\t}\n}\n\n \nint fsnotify(__u32 mask, const void *data, int data_type, struct inode *dir,\n\t     const struct qstr *file_name, struct inode *inode, u32 cookie)\n{\n\tconst struct path *path = fsnotify_data_path(data, data_type);\n\tstruct super_block *sb = fsnotify_data_sb(data, data_type);\n\tstruct fsnotify_iter_info iter_info = {};\n\tstruct mount *mnt = NULL;\n\tstruct inode *inode2 = NULL;\n\tstruct dentry *moved;\n\tint inode2_type;\n\tint ret = 0;\n\t__u32 test_mask, marks_mask;\n\n\tif (path)\n\t\tmnt = real_mount(path->mnt);\n\n\tif (!inode) {\n\t\t \n\t\tinode = dir;\n\t\t \n\t\tif (mask & FS_RENAME) {\n\t\t\tmoved = fsnotify_data_dentry(data, data_type);\n\t\t\tinode2 = moved->d_parent->d_inode;\n\t\t\tinode2_type = FSNOTIFY_ITER_TYPE_INODE2;\n\t\t}\n\t} else if (mask & FS_EVENT_ON_CHILD) {\n\t\t \n\t\tinode2 = dir;\n\t\tinode2_type = FSNOTIFY_ITER_TYPE_PARENT;\n\t}\n\n\t \n\tif (!sb->s_fsnotify_marks &&\n\t    (!mnt || !mnt->mnt_fsnotify_marks) &&\n\t    (!inode || !inode->i_fsnotify_marks) &&\n\t    (!inode2 || !inode2->i_fsnotify_marks))\n\t\treturn 0;\n\n\tmarks_mask = sb->s_fsnotify_mask;\n\tif (mnt)\n\t\tmarks_mask |= mnt->mnt_fsnotify_mask;\n\tif (inode)\n\t\tmarks_mask |= inode->i_fsnotify_mask;\n\tif (inode2)\n\t\tmarks_mask |= inode2->i_fsnotify_mask;\n\n\n\t \n\ttest_mask = (mask & ALL_FSNOTIFY_EVENTS);\n\tif (!(test_mask & marks_mask))\n\t\treturn 0;\n\n\titer_info.srcu_idx = srcu_read_lock(&fsnotify_mark_srcu);\n\n\titer_info.marks[FSNOTIFY_ITER_TYPE_SB] =\n\t\tfsnotify_first_mark(&sb->s_fsnotify_marks);\n\tif (mnt) {\n\t\titer_info.marks[FSNOTIFY_ITER_TYPE_VFSMOUNT] =\n\t\t\tfsnotify_first_mark(&mnt->mnt_fsnotify_marks);\n\t}\n\tif (inode) {\n\t\titer_info.marks[FSNOTIFY_ITER_TYPE_INODE] =\n\t\t\tfsnotify_first_mark(&inode->i_fsnotify_marks);\n\t}\n\tif (inode2) {\n\t\titer_info.marks[inode2_type] =\n\t\t\tfsnotify_first_mark(&inode2->i_fsnotify_marks);\n\t}\n\n\t \n\twhile (fsnotify_iter_select_report_types(&iter_info)) {\n\t\tret = send_to_group(mask, data, data_type, dir, file_name,\n\t\t\t\t    cookie, &iter_info);\n\n\t\tif (ret && (mask & ALL_FSNOTIFY_PERM_EVENTS))\n\t\t\tgoto out;\n\n\t\tfsnotify_iter_next(&iter_info);\n\t}\n\tret = 0;\nout:\n\tsrcu_read_unlock(&fsnotify_mark_srcu, iter_info.srcu_idx);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(fsnotify);\n\nstatic __init int fsnotify_init(void)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(HWEIGHT32(ALL_FSNOTIFY_BITS) != 23);\n\n\tret = init_srcu_struct(&fsnotify_mark_srcu);\n\tif (ret)\n\t\tpanic(\"initializing fsnotify_mark_srcu\");\n\n\tfsnotify_mark_connector_cachep = KMEM_CACHE(fsnotify_mark_connector,\n\t\t\t\t\t\t    SLAB_PANIC);\n\n\treturn 0;\n}\ncore_initcall(fsnotify_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}