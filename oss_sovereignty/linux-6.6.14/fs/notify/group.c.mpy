{
  "module_name": "group.c",
  "hash_id": "a7f1eff94673fd76d884c4ee49a9989e4bb022221f0d4e683b63fb5be231e20a",
  "original_prompt": "Ingested from linux-6.6.14/fs/notify/group.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/rculist.h>\n#include <linux/wait.h>\n#include <linux/memcontrol.h>\n\n#include <linux/fsnotify_backend.h>\n#include \"fsnotify.h\"\n\n#include <linux/atomic.h>\n\n \nstatic void fsnotify_final_destroy_group(struct fsnotify_group *group)\n{\n\tif (group->ops->free_group_priv)\n\t\tgroup->ops->free_group_priv(group);\n\n\tmem_cgroup_put(group->memcg);\n\tmutex_destroy(&group->mark_mutex);\n\n\tkfree(group);\n}\n\n \nvoid fsnotify_group_stop_queueing(struct fsnotify_group *group)\n{\n\tspin_lock(&group->notification_lock);\n\tgroup->shutdown = true;\n\tspin_unlock(&group->notification_lock);\n}\n\n \nvoid fsnotify_destroy_group(struct fsnotify_group *group)\n{\n\t \n\tfsnotify_group_stop_queueing(group);\n\n\t \n\tfsnotify_clear_marks_by_group(group, FSNOTIFY_OBJ_TYPE_ANY);\n\n\t \n\twait_event(group->notification_waitq, !atomic_read(&group->user_waits));\n\n\t \n\tfsnotify_wait_marks_destroyed();\n\n\t \n\tfsnotify_flush_notify(group);\n\n\t \n\tif (group->overflow_event)\n\t\tgroup->ops->free_event(group, group->overflow_event);\n\n\tfsnotify_put_group(group);\n}\n\n \nvoid fsnotify_get_group(struct fsnotify_group *group)\n{\n\trefcount_inc(&group->refcnt);\n}\n\n \nvoid fsnotify_put_group(struct fsnotify_group *group)\n{\n\tif (refcount_dec_and_test(&group->refcnt))\n\t\tfsnotify_final_destroy_group(group);\n}\nEXPORT_SYMBOL_GPL(fsnotify_put_group);\n\nstatic struct fsnotify_group *__fsnotify_alloc_group(\n\t\t\t\tconst struct fsnotify_ops *ops,\n\t\t\t\tint flags, gfp_t gfp)\n{\n\tstatic struct lock_class_key nofs_marks_lock;\n\tstruct fsnotify_group *group;\n\n\tgroup = kzalloc(sizeof(struct fsnotify_group), gfp);\n\tif (!group)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\trefcount_set(&group->refcnt, 1);\n\tatomic_set(&group->user_waits, 0);\n\n\tspin_lock_init(&group->notification_lock);\n\tINIT_LIST_HEAD(&group->notification_list);\n\tinit_waitqueue_head(&group->notification_waitq);\n\tgroup->max_events = UINT_MAX;\n\n\tmutex_init(&group->mark_mutex);\n\tINIT_LIST_HEAD(&group->marks_list);\n\n\tgroup->ops = ops;\n\tgroup->flags = flags;\n\t \n\tif (flags & FSNOTIFY_GROUP_NOFS)\n\t\tlockdep_set_class(&group->mark_mutex, &nofs_marks_lock);\n\n\treturn group;\n}\n\n \nstruct fsnotify_group *fsnotify_alloc_group(const struct fsnotify_ops *ops,\n\t\t\t\t\t    int flags)\n{\n\tgfp_t gfp = (flags & FSNOTIFY_GROUP_USER) ? GFP_KERNEL_ACCOUNT :\n\t\t\t\t\t\t    GFP_KERNEL;\n\n\treturn __fsnotify_alloc_group(ops, flags, gfp);\n}\nEXPORT_SYMBOL_GPL(fsnotify_alloc_group);\n\nint fsnotify_fasync(int fd, struct file *file, int on)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\n\treturn fasync_helper(fd, file, on, &group->fsn_fa) >= 0 ? 0 : -EIO;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}