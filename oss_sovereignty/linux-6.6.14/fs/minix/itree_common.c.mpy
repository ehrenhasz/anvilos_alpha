{
  "module_name": "itree_common.c",
  "hash_id": "527e87ebab8bf064ee1929bd70114814894a0e091aba37baafa39d7bbb643c13",
  "original_prompt": "Ingested from linux-6.6.14/fs/minix/itree_common.c",
  "human_readable_source": "\n \n\ntypedef struct {\n\tblock_t\t*p;\n\tblock_t\tkey;\n\tstruct buffer_head *bh;\n} Indirect;\n\nstatic DEFINE_RWLOCK(pointers_lock);\n\nstatic inline void add_chain(Indirect *p, struct buffer_head *bh, block_t *v)\n{\n\tp->key = *(p->p = v);\n\tp->bh = bh;\n}\n\nstatic inline int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}\n\nstatic inline block_t *block_end(struct buffer_head *bh)\n{\n\treturn (block_t *)((char*)bh->b_data + bh->b_size);\n}\n\nstatic inline Indirect *get_branch(struct inode *inode,\n\t\t\t\t\tint depth,\n\t\t\t\t\tint *offsets,\n\t\t\t\t\tIndirect chain[DEPTH],\n\t\t\t\t\tint *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\t \n\tadd_chain (chain, NULL, i_data(inode) + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_bread(sb, block_to_cpu(p->key));\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\tread_lock(&pointers_lock);\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (block_t *)bh->b_data + *++offsets);\n\t\tread_unlock(&pointers_lock);\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tread_unlock(&pointers_lock);\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}\n\nstatic int alloc_branch(struct inode *inode,\n\t\t\t     int num,\n\t\t\t     int *offsets,\n\t\t\t     Indirect *branch)\n{\n\tint n = 0;\n\tint i;\n\tint parent = minix_new_block(inode);\n\tint err = -ENOSPC;\n\n\tbranch[0].key = cpu_to_block(parent);\n\tif (parent) for (n = 1; n < num; n++) {\n\t\tstruct buffer_head *bh;\n\t\t \n\t\tint nr = minix_new_block(inode);\n\t\tif (!nr)\n\t\t\tbreak;\n\t\tbranch[n].key = cpu_to_block(nr);\n\t\tbh = sb_getblk(inode->i_sb, parent);\n\t\tif (!bh) {\n\t\t\tminix_free_block(inode, nr);\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\tbranch[n].bh = bh;\n\t\tbranch[n].p = (block_t*) bh->b_data + offsets[n];\n\t\t*branch[n].p = branch[n].key;\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\tparent = nr;\n\t}\n\tif (n == num)\n\t\treturn 0;\n\n\t \n\tfor (i = 1; i < n; i++)\n\t\tbforget(branch[i].bh);\n\tfor (i = 0; i < n; i++)\n\t\tminix_free_block(inode, block_to_cpu(branch[i].key));\n\treturn err;\n}\n\nstatic inline int splice_branch(struct inode *inode,\n\t\t\t\t     Indirect chain[DEPTH],\n\t\t\t\t     Indirect *where,\n\t\t\t\t     int num)\n{\n\tint i;\n\n\twrite_lock(&pointers_lock);\n\n\t \n\tif (!verify_chain(chain, where-1) || *where->p)\n\t\tgoto changed;\n\n\t*where->p = where->key;\n\n\twrite_unlock(&pointers_lock);\n\n\t \n\n\tinode_set_ctime_current(inode);\n\n\t \n\tif (where->bh)\n\t\tmark_buffer_dirty_inode(where->bh, inode);\n\n\tmark_inode_dirty(inode);\n\treturn 0;\n\nchanged:\n\twrite_unlock(&pointers_lock);\n\tfor (i = 1; i < num; i++)\n\t\tbforget(where[i].bh);\n\tfor (i = 0; i < num; i++)\n\t\tminix_free_block(inode, block_to_cpu(where[i].key));\n\treturn -EAGAIN;\n}\n\nstatic int get_block(struct inode * inode, sector_t block,\n\t\t\tstruct buffer_head *bh, int create)\n{\n\tint err = -EIO;\n\tint offsets[DEPTH];\n\tIndirect chain[DEPTH];\n\tIndirect *partial;\n\tint left;\n\tint depth = block_to_path(inode, block, offsets);\n\n\tif (depth == 0)\n\t\tgoto out;\n\nreread:\n\tpartial = get_branch(inode, depth, offsets, chain, &err);\n\n\t \n\tif (!partial) {\ngot_it:\n\t\tmap_bh(bh, inode->i_sb, block_to_cpu(chain[depth-1].key));\n\t\t \n\t\tpartial = chain+depth-1;  \n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (!create || err == -EIO) {\ncleanup:\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\nout:\n\t\treturn err;\n\t}\n\n\t \n\tif (err == -EAGAIN)\n\t\tgoto changed;\n\n\tleft = (chain + depth) - partial;\n\terr = alloc_branch(inode, left, offsets+(partial-chain), partial);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (splice_branch(inode, chain, partial, left) < 0)\n\t\tgoto changed;\n\n\tset_buffer_new(bh);\n\tgoto got_it;\n\nchanged:\n\twhile (partial > chain) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\tgoto reread;\n}\n\nstatic inline int all_zeroes(block_t *p, block_t *q)\n{\n\twhile (p < q)\n\t\tif (*p++)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic Indirect *find_shared(struct inode *inode,\n\t\t\t\tint depth,\n\t\t\t\tint offsets[DEPTH],\n\t\t\t\tIndirect chain[DEPTH],\n\t\t\t\tblock_t *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\tpartial = get_branch(inode, k, offsets, chain, &err);\n\n\twrite_lock(&pointers_lock);\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\tif (!partial->key && *partial->p) {\n\t\twrite_unlock(&pointers_lock);\n\t\tgoto no_top;\n\t}\n\tfor (p=partial;p>chain && all_zeroes((block_t*)p->bh->b_data,p->p);p--)\n\t\t;\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t*p->p = 0;\n\t}\n\twrite_unlock(&pointers_lock);\n\n\twhile(partial > p)\n\t{\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}\n\nstatic inline void free_data(struct inode *inode, block_t *p, block_t *q)\n{\n\tunsigned long nr;\n\n\tfor ( ; p < q ; p++) {\n\t\tnr = block_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t*p = 0;\n\t\t\tminix_free_block(inode, nr);\n\t\t}\n\t}\n}\n\nstatic void free_branches(struct inode *inode, block_t *p, block_t *q, int depth)\n{\n\tstruct buffer_head * bh;\n\tunsigned long nr;\n\n\tif (depth--) {\n\t\tfor ( ; p < q ; p++) {\n\t\t\tnr = block_to_cpu(*p);\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\n\t\t\t*p = 0;\n\t\t\tbh = sb_bread(inode->i_sb, nr);\n\t\t\tif (!bh)\n\t\t\t\tcontinue;\n\t\t\tfree_branches(inode, (block_t*)bh->b_data,\n\t\t\t\t      block_end(bh), depth);\n\t\t\tbforget(bh);\n\t\t\tminix_free_block(inode, nr);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t} else\n\t\tfree_data(inode, p, q);\n}\n\nstatic inline void truncate (struct inode * inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tblock_t *idata = i_data(inode);\n\tint offsets[DEPTH];\n\tIndirect chain[DEPTH];\n\tIndirect *partial;\n\tblock_t nr = 0;\n\tint n;\n\tint first_whole;\n\tlong iblock;\n\n\tiblock = (inode->i_size + sb->s_blocksize -1) >> sb->s_blocksize_bits;\n\tblock_truncate_page(inode->i_mapping, inode->i_size, get_block);\n\n\tn = block_to_path(inode, iblock, offsets);\n\tif (!n)\n\t\treturn;\n\n\tif (n == 1) {\n\t\tfree_data(inode, idata+offsets[0], idata + DIRECT);\n\t\tfirst_whole = 0;\n\t\tgoto do_indirects;\n\t}\n\n\tfirst_whole = offsets[0] + 1 - DIRECT;\n\tpartial = find_shared(inode, n, offsets, chain, &nr);\n\tif (nr) {\n\t\tif (partial == chain)\n\t\t\tmark_inode_dirty(inode);\n\t\telse\n\t\t\tmark_buffer_dirty_inode(partial->bh, inode);\n\t\tfree_branches(inode, &nr, &nr+1, (chain+n-1) - partial);\n\t}\n\t \n\twhile (partial > chain) {\n\t\tfree_branches(inode, partial->p + 1, block_end(partial->bh),\n\t\t\t\t(chain+n-1) - partial);\n\t\tmark_buffer_dirty_inode(partial->bh, inode);\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t \n\twhile (first_whole < DEPTH-1) {\n\t\tnr = idata[DIRECT+first_whole];\n\t\tif (nr) {\n\t\t\tidata[DIRECT+first_whole] = 0;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tfree_branches(inode, &nr, &nr+1, first_whole+1);\n\t\t}\n\t\tfirst_whole++;\n\t}\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n}\n\nstatic inline unsigned nblocks(loff_t size, struct super_block *sb)\n{\n\tint k = sb->s_blocksize_bits - 10;\n\tunsigned blocks, res, direct = DIRECT, i = DEPTH;\n\tblocks = (size + sb->s_blocksize - 1) >> (BLOCK_SIZE_BITS + k);\n\tres = blocks;\n\twhile (--i && blocks > direct) {\n\t\tblocks -= direct;\n\t\tblocks += sb->s_blocksize/sizeof(block_t) - 1;\n\t\tblocks /= sb->s_blocksize/sizeof(block_t);\n\t\tres += blocks;\n\t\tdirect = 1;\n\t}\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}