{
  "module_name": "bitmap.c",
  "hash_id": "a092dd02392fde5c46e331b450ba76da8d1c3c231befe6176331a943f82b5b11",
  "original_prompt": "Ingested from linux-6.6.14/fs/minix/bitmap.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include \"minix.h\"\n#include <linux/buffer_head.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(bitmap_lock);\n\n \nstatic __u32 count_free(struct buffer_head *map[], unsigned blocksize, __u32 numbits)\n{\n\t__u32 sum = 0;\n\tunsigned blocks = DIV_ROUND_UP(numbits, blocksize * 8);\n\n\twhile (blocks--) {\n\t\tunsigned words = blocksize / 2;\n\t\t__u16 *p = (__u16 *)(*map++)->b_data;\n\t\twhile (words--)\n\t\t\tsum += 16 - hweight16(*p++);\n\t}\n\n\treturn sum;\n}\n\nvoid minix_free_block(struct inode *inode, unsigned long block)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct buffer_head *bh;\n\tint k = sb->s_blocksize_bits + 3;\n\tunsigned long bit, zone;\n\n\tif (block < sbi->s_firstdatazone || block >= sbi->s_nzones) {\n\t\tprintk(\"Trying to free block not in datazone\\n\");\n\t\treturn;\n\t}\n\tzone = block - sbi->s_firstdatazone + 1;\n\tbit = zone & ((1<<k) - 1);\n\tzone >>= k;\n\tif (zone >= sbi->s_zmap_blocks) {\n\t\tprintk(\"minix_free_block: nonexistent bitmap buffer\\n\");\n\t\treturn;\n\t}\n\tbh = sbi->s_zmap[zone];\n\tspin_lock(&bitmap_lock);\n\tif (!minix_test_and_clear_bit(bit, bh->b_data))\n\t\tprintk(\"minix_free_block (%s:%lu): bit already cleared\\n\",\n\t\t       sb->s_id, block);\n\tspin_unlock(&bitmap_lock);\n\tmark_buffer_dirty(bh);\n\treturn;\n}\n\nint minix_new_block(struct inode * inode)\n{\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tint bits_per_zone = 8 * inode->i_sb->s_blocksize;\n\tint i;\n\n\tfor (i = 0; i < sbi->s_zmap_blocks; i++) {\n\t\tstruct buffer_head *bh = sbi->s_zmap[i];\n\t\tint j;\n\n\t\tspin_lock(&bitmap_lock);\n\t\tj = minix_find_first_zero_bit(bh->b_data, bits_per_zone);\n\t\tif (j < bits_per_zone) {\n\t\t\tminix_set_bit(j, bh->b_data);\n\t\t\tspin_unlock(&bitmap_lock);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tj += i * bits_per_zone + sbi->s_firstdatazone-1;\n\t\t\tif (j < sbi->s_firstdatazone || j >= sbi->s_nzones)\n\t\t\t\tbreak;\n\t\t\treturn j;\n\t\t}\n\t\tspin_unlock(&bitmap_lock);\n\t}\n\treturn 0;\n}\n\nunsigned long minix_count_free_blocks(struct super_block *sb)\n{\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tu32 bits = sbi->s_nzones - sbi->s_firstdatazone + 1;\n\n\treturn (count_free(sbi->s_zmap, sb->s_blocksize, bits)\n\t\t<< sbi->s_log_zone_size);\n}\n\nstruct minix_inode *\nminix_V1_raw_inode(struct super_block *sb, ino_t ino, struct buffer_head **bh)\n{\n\tint block;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct minix_inode *p;\n\n\tif (!ino || ino > sbi->s_ninodes) {\n\t\tprintk(\"Bad inode number on dev %s: %ld is out of range\\n\",\n\t\t       sb->s_id, (long)ino);\n\t\treturn NULL;\n\t}\n\tino--;\n\tblock = 2 + sbi->s_imap_blocks + sbi->s_zmap_blocks +\n\t\t ino / MINIX_INODES_PER_BLOCK;\n\t*bh = sb_bread(sb, block);\n\tif (!*bh) {\n\t\tprintk(\"Unable to read inode block\\n\");\n\t\treturn NULL;\n\t}\n\tp = (void *)(*bh)->b_data;\n\treturn p + ino % MINIX_INODES_PER_BLOCK;\n}\n\nstruct minix2_inode *\nminix_V2_raw_inode(struct super_block *sb, ino_t ino, struct buffer_head **bh)\n{\n\tint block;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct minix2_inode *p;\n\tint minix2_inodes_per_block = sb->s_blocksize / sizeof(struct minix2_inode);\n\n\t*bh = NULL;\n\tif (!ino || ino > sbi->s_ninodes) {\n\t\tprintk(\"Bad inode number on dev %s: %ld is out of range\\n\",\n\t\t       sb->s_id, (long)ino);\n\t\treturn NULL;\n\t}\n\tino--;\n\tblock = 2 + sbi->s_imap_blocks + sbi->s_zmap_blocks +\n\t\t ino / minix2_inodes_per_block;\n\t*bh = sb_bread(sb, block);\n\tif (!*bh) {\n\t\tprintk(\"Unable to read inode block\\n\");\n\t\treturn NULL;\n\t}\n\tp = (void *)(*bh)->b_data;\n\treturn p + ino % minix2_inodes_per_block;\n}\n\n \n\nstatic void minix_clear_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\n\tif (INODE_VERSION(inode) == MINIX_V1) {\n\t\tstruct minix_inode *raw_inode;\n\t\traw_inode = minix_V1_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\t\tif (raw_inode) {\n\t\t\traw_inode->i_nlinks = 0;\n\t\t\traw_inode->i_mode = 0;\n\t\t}\n\t} else {\n\t\tstruct minix2_inode *raw_inode;\n\t\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\t\tif (raw_inode) {\n\t\t\traw_inode->i_nlinks = 0;\n\t\t\traw_inode->i_mode = 0;\n\t\t}\n\t}\n\tif (bh) {\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse (bh);\n\t}\n}\n\nvoid minix_free_inode(struct inode * inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tstruct buffer_head *bh;\n\tint k = sb->s_blocksize_bits + 3;\n\tunsigned long ino, bit;\n\n\tino = inode->i_ino;\n\tif (ino < 1 || ino > sbi->s_ninodes) {\n\t\tprintk(\"minix_free_inode: inode 0 or nonexistent inode\\n\");\n\t\treturn;\n\t}\n\tbit = ino & ((1<<k) - 1);\n\tino >>= k;\n\tif (ino >= sbi->s_imap_blocks) {\n\t\tprintk(\"minix_free_inode: nonexistent imap in superblock\\n\");\n\t\treturn;\n\t}\n\n\tminix_clear_inode(inode);\t \n\n\tbh = sbi->s_imap[ino];\n\tspin_lock(&bitmap_lock);\n\tif (!minix_test_and_clear_bit(bit, bh->b_data))\n\t\tprintk(\"minix_free_inode: bit %lu already cleared\\n\", bit);\n\tspin_unlock(&bitmap_lock);\n\tmark_buffer_dirty(bh);\n}\n\nstruct inode *minix_new_inode(const struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct inode *inode = new_inode(sb);\n\tstruct buffer_head * bh;\n\tint bits_per_zone = 8 * sb->s_blocksize;\n\tunsigned long j;\n\tint i;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tj = bits_per_zone;\n\tbh = NULL;\n\tspin_lock(&bitmap_lock);\n\tfor (i = 0; i < sbi->s_imap_blocks; i++) {\n\t\tbh = sbi->s_imap[i];\n\t\tj = minix_find_first_zero_bit(bh->b_data, bits_per_zone);\n\t\tif (j < bits_per_zone)\n\t\t\tbreak;\n\t}\n\tif (!bh || j >= bits_per_zone) {\n\t\tspin_unlock(&bitmap_lock);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOSPC);\n\t}\n\tif (minix_test_and_set_bit(j, bh->b_data)) {\t \n\t\tspin_unlock(&bitmap_lock);\n\t\tprintk(\"minix_new_inode: bit already set\\n\");\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOSPC);\n\t}\n\tspin_unlock(&bitmap_lock);\n\tmark_buffer_dirty(bh);\n\tj += i * bits_per_zone;\n\tif (!j || j > sbi->s_ninodes) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOSPC);\n\t}\n\tinode_init_owner(&nop_mnt_idmap, inode, dir, mode);\n\tinode->i_ino = j;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tinode->i_blocks = 0;\n\tmemset(&minix_i(inode)->u, 0, sizeof(minix_i(inode)->u));\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\n\treturn inode;\n}\n\nunsigned long minix_count_free_inodes(struct super_block *sb)\n{\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tu32 bits = sbi->s_ninodes + 1;\n\n\treturn count_free(sbi->s_imap, sb->s_blocksize, bits);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}