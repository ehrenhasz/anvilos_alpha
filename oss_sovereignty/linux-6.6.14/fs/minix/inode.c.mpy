{
  "module_name": "inode.c",
  "hash_id": "0cb74568b2cbffdf04c62e8cea0c25670fae32ea17fd390a8ee3ec12d7532bf0",
  "original_prompt": "Ingested from linux-6.6.14/fs/minix/inode.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include \"minix.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/highuid.h>\n#include <linux/vfs.h>\n#include <linux/writeback.h>\n\nstatic int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);\nstatic int minix_statfs(struct dentry *dentry, struct kstatfs *buf);\nstatic int minix_remount (struct super_block * sb, int * flags, char * data);\n\nstatic void minix_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (!inode->i_nlink) {\n\t\tinode->i_size = 0;\n\t\tminix_truncate(inode);\n\t}\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tif (!inode->i_nlink)\n\t\tminix_free_inode(inode);\n}\n\nstatic void minix_put_super(struct super_block *sb)\n{\n\tint i;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\n\tif (!sb_rdonly(sb)) {\n\t\tif (sbi->s_version != MINIX_V3)\t  \n\t\t\tsbi->s_ms->s_state = sbi->s_mount_state;\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t}\n\tfor (i = 0; i < sbi->s_imap_blocks; i++)\n\t\tbrelse(sbi->s_imap[i]);\n\tfor (i = 0; i < sbi->s_zmap_blocks; i++)\n\t\tbrelse(sbi->s_zmap[i]);\n\tbrelse (sbi->s_sbh);\n\tkfree(sbi->s_imap);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi);\n}\n\nstatic struct kmem_cache * minix_inode_cachep;\n\nstatic struct inode *minix_alloc_inode(struct super_block *sb)\n{\n\tstruct minix_inode_info *ei;\n\tei = alloc_inode_sb(sb, minix_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}\n\nstatic void minix_free_in_core_inode(struct inode *inode)\n{\n\tkmem_cache_free(minix_inode_cachep, minix_i(inode));\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct minix_inode_info *ei = (struct minix_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int __init init_inodecache(void)\n{\n\tminix_inode_cachep = kmem_cache_create(\"minix_inode_cache\",\n\t\t\t\t\t     sizeof(struct minix_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t     init_once);\n\tif (minix_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(minix_inode_cachep);\n}\n\nstatic const struct super_operations minix_sops = {\n\t.alloc_inode\t= minix_alloc_inode,\n\t.free_inode\t= minix_free_in_core_inode,\n\t.write_inode\t= minix_write_inode,\n\t.evict_inode\t= minix_evict_inode,\n\t.put_super\t= minix_put_super,\n\t.statfs\t\t= minix_statfs,\n\t.remount_fs\t= minix_remount,\n};\n\nstatic int minix_remount (struct super_block * sb, int * flags, char * data)\n{\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tstruct minix_super_block * ms;\n\n\tsync_filesystem(sb);\n\tms = sbi->s_ms;\n\tif ((bool)(*flags & SB_RDONLY) == sb_rdonly(sb))\n\t\treturn 0;\n\tif (*flags & SB_RDONLY) {\n\t\tif (ms->s_state & MINIX_VALID_FS ||\n\t\t    !(sbi->s_mount_state & MINIX_VALID_FS))\n\t\t\treturn 0;\n\t\t \n\t\tif (sbi->s_version != MINIX_V3)\n\t\t\tms->s_state = sbi->s_mount_state;\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t} else {\n\t  \t \n\t\tif (sbi->s_version != MINIX_V3) {\n\t\t\tsbi->s_mount_state = ms->s_state;\n\t\t\tms->s_state &= ~MINIX_VALID_FS;\n\t\t} else {\n\t\t\tsbi->s_mount_state = MINIX_VALID_FS;\n\t\t}\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\n\t\tif (!(sbi->s_mount_state & MINIX_VALID_FS))\n\t\t\tprintk(\"MINIX-fs warning: remounting unchecked fs, \"\n\t\t\t\t\"running fsck is recommended\\n\");\n\t\telse if ((sbi->s_mount_state & MINIX_ERROR_FS))\n\t\t\tprintk(\"MINIX-fs warning: remounting fs with errors, \"\n\t\t\t\t\"running fsck is recommended\\n\");\n\t}\n\treturn 0;\n}\n\nstatic bool minix_check_superblock(struct super_block *sb)\n{\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\n\tif (sbi->s_imap_blocks == 0 || sbi->s_zmap_blocks == 0)\n\t\treturn false;\n\n\t \n\tif (sbi->s_version == MINIX_V1 &&\n\t    sb->s_maxbytes > (7 + 512 + 512*512) * BLOCK_SIZE)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int minix_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head **map;\n\tstruct minix_super_block *ms;\n\tstruct minix3_super_block *m3s = NULL;\n\tunsigned long i, block;\n\tstruct inode *root_inode;\n\tstruct minix_sb_info *sbi;\n\tint ret = -EINVAL;\n\n\tsbi = kzalloc(sizeof(struct minix_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = sbi;\n\n\tBUILD_BUG_ON(32 != sizeof (struct minix_inode));\n\tBUILD_BUG_ON(64 != sizeof(struct minix2_inode));\n\n\tif (!sb_set_blocksize(s, BLOCK_SIZE))\n\t\tgoto out_bad_hblock;\n\n\tif (!(bh = sb_bread(s, 1)))\n\t\tgoto out_bad_sb;\n\n\tms = (struct minix_super_block *) bh->b_data;\n\tsbi->s_ms = ms;\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = ms->s_state;\n\tsbi->s_ninodes = ms->s_ninodes;\n\tsbi->s_nzones = ms->s_nzones;\n\tsbi->s_imap_blocks = ms->s_imap_blocks;\n\tsbi->s_zmap_blocks = ms->s_zmap_blocks;\n\tsbi->s_firstdatazone = ms->s_firstdatazone;\n\tsbi->s_log_zone_size = ms->s_log_zone_size;\n\ts->s_maxbytes = ms->s_max_size;\n\ts->s_magic = ms->s_magic;\n\tif (s->s_magic == MINIX_SUPER_MAGIC) {\n\t\tsbi->s_version = MINIX_V1;\n\t\tsbi->s_dirsize = 16;\n\t\tsbi->s_namelen = 14;\n\t\ts->s_max_links = MINIX_LINK_MAX;\n\t} else if (s->s_magic == MINIX_SUPER_MAGIC2) {\n\t\tsbi->s_version = MINIX_V1;\n\t\tsbi->s_dirsize = 32;\n\t\tsbi->s_namelen = 30;\n\t\ts->s_max_links = MINIX_LINK_MAX;\n\t} else if (s->s_magic == MINIX2_SUPER_MAGIC) {\n\t\tsbi->s_version = MINIX_V2;\n\t\tsbi->s_nzones = ms->s_zones;\n\t\tsbi->s_dirsize = 16;\n\t\tsbi->s_namelen = 14;\n\t\ts->s_max_links = MINIX2_LINK_MAX;\n\t} else if (s->s_magic == MINIX2_SUPER_MAGIC2) {\n\t\tsbi->s_version = MINIX_V2;\n\t\tsbi->s_nzones = ms->s_zones;\n\t\tsbi->s_dirsize = 32;\n\t\tsbi->s_namelen = 30;\n\t\ts->s_max_links = MINIX2_LINK_MAX;\n\t} else if ( *(__u16 *)(bh->b_data + 24) == MINIX3_SUPER_MAGIC) {\n\t\tm3s = (struct minix3_super_block *) bh->b_data;\n\t\ts->s_magic = m3s->s_magic;\n\t\tsbi->s_imap_blocks = m3s->s_imap_blocks;\n\t\tsbi->s_zmap_blocks = m3s->s_zmap_blocks;\n\t\tsbi->s_firstdatazone = m3s->s_firstdatazone;\n\t\tsbi->s_log_zone_size = m3s->s_log_zone_size;\n\t\ts->s_maxbytes = m3s->s_max_size;\n\t\tsbi->s_ninodes = m3s->s_ninodes;\n\t\tsbi->s_nzones = m3s->s_zones;\n\t\tsbi->s_dirsize = 64;\n\t\tsbi->s_namelen = 60;\n\t\tsbi->s_version = MINIX_V3;\n\t\tsbi->s_mount_state = MINIX_VALID_FS;\n\t\tsb_set_blocksize(s, m3s->s_blocksize);\n\t\ts->s_max_links = MINIX2_LINK_MAX;\n\t} else\n\t\tgoto out_no_fs;\n\n\tif (!minix_check_superblock(s))\n\t\tgoto out_illegal_sb;\n\n\t \n\ti = (sbi->s_imap_blocks + sbi->s_zmap_blocks) * sizeof(bh);\n\tmap = kzalloc(i, GFP_KERNEL);\n\tif (!map)\n\t\tgoto out_no_map;\n\tsbi->s_imap = &map[0];\n\tsbi->s_zmap = &map[sbi->s_imap_blocks];\n\n\tblock=2;\n\tfor (i=0 ; i < sbi->s_imap_blocks ; i++) {\n\t\tif (!(sbi->s_imap[i]=sb_bread(s, block)))\n\t\t\tgoto out_no_bitmap;\n\t\tblock++;\n\t}\n\tfor (i=0 ; i < sbi->s_zmap_blocks ; i++) {\n\t\tif (!(sbi->s_zmap[i]=sb_bread(s, block)))\n\t\t\tgoto out_no_bitmap;\n\t\tblock++;\n\t}\n\n\tminix_set_bit(0,sbi->s_imap[0]->b_data);\n\tminix_set_bit(0,sbi->s_zmap[0]->b_data);\n\n\t \n\tblock = minix_blocks_needed(sbi->s_ninodes, s->s_blocksize);\n\tif (sbi->s_imap_blocks < block) {\n\t\tprintk(\"MINIX-fs: file system does not have enough \"\n\t\t\t\t\"imap blocks allocated.  Refusing to mount.\\n\");\n\t\tgoto out_no_bitmap;\n\t}\n\n\tblock = minix_blocks_needed(\n\t\t\t(sbi->s_nzones - sbi->s_firstdatazone + 1),\n\t\t\ts->s_blocksize);\n\tif (sbi->s_zmap_blocks < block) {\n\t\tprintk(\"MINIX-fs: file system does not have enough \"\n\t\t\t\t\"zmap blocks allocated.  Refusing to mount.\\n\");\n\t\tgoto out_no_bitmap;\n\t}\n\n\t \n\ts->s_op = &minix_sops;\n\ts->s_time_min = 0;\n\ts->s_time_max = U32_MAX;\n\troot_inode = minix_iget(s, MINIX_ROOT_INO);\n\tif (IS_ERR(root_inode)) {\n\t\tret = PTR_ERR(root_inode);\n\t\tgoto out_no_root;\n\t}\n\n\tret = -ENOMEM;\n\ts->s_root = d_make_root(root_inode);\n\tif (!s->s_root)\n\t\tgoto out_no_root;\n\n\tif (!sb_rdonly(s)) {\n\t\tif (sbi->s_version != MINIX_V3)  \n\t\t\tms->s_state &= ~MINIX_VALID_FS;\n\t\tmark_buffer_dirty(bh);\n\t}\n\tif (!(sbi->s_mount_state & MINIX_VALID_FS))\n\t\tprintk(\"MINIX-fs: mounting unchecked file system, \"\n\t\t\t\"running fsck is recommended\\n\");\n\telse if (sbi->s_mount_state & MINIX_ERROR_FS)\n\t\tprintk(\"MINIX-fs: mounting file system with errors, \"\n\t\t\t\"running fsck is recommended\\n\");\n\n\treturn 0;\n\nout_no_root:\n\tif (!silent)\n\t\tprintk(\"MINIX-fs: get root inode failed\\n\");\n\tgoto out_freemap;\n\nout_no_bitmap:\n\tprintk(\"MINIX-fs: bad superblock or unable to read bitmaps\\n\");\nout_freemap:\n\tfor (i = 0; i < sbi->s_imap_blocks; i++)\n\t\tbrelse(sbi->s_imap[i]);\n\tfor (i = 0; i < sbi->s_zmap_blocks; i++)\n\t\tbrelse(sbi->s_zmap[i]);\n\tkfree(sbi->s_imap);\n\tgoto out_release;\n\nout_no_map:\n\tret = -ENOMEM;\n\tif (!silent)\n\t\tprintk(\"MINIX-fs: can't allocate map\\n\");\n\tgoto out_release;\n\nout_illegal_sb:\n\tif (!silent)\n\t\tprintk(\"MINIX-fs: bad superblock\\n\");\n\tgoto out_release;\n\nout_no_fs:\n\tif (!silent)\n\t\tprintk(\"VFS: Can't find a Minix filesystem V1 | V2 | V3 \"\n\t\t       \"on device %s.\\n\", s->s_id);\nout_release:\n\tbrelse(bh);\n\tgoto out;\n\nout_bad_hblock:\n\tprintk(\"MINIX-fs: blocksize too small for device\\n\");\n\tgoto out;\n\nout_bad_sb:\n\tprintk(\"MINIX-fs: unable to read superblock\\n\");\nout:\n\ts->s_fs_info = NULL;\n\tkfree(sbi);\n\treturn ret;\n}\n\nstatic int minix_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\tbuf->f_type = sb->s_magic;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = (sbi->s_nzones - sbi->s_firstdatazone) << sbi->s_log_zone_size;\n\tbuf->f_bfree = minix_count_free_blocks(sb);\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_files = sbi->s_ninodes;\n\tbuf->f_ffree = minix_count_free_inodes(sb);\n\tbuf->f_namelen = sbi->s_namelen;\n\tbuf->f_fsid = u64_to_fsid(id);\n\n\treturn 0;\n}\n\nstatic int minix_get_block(struct inode *inode, sector_t block,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\treturn V1_minix_get_block(inode, block, bh_result, create);\n\telse\n\t\treturn V2_minix_get_block(inode, block, bh_result, create);\n}\n\nstatic int minix_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, minix_get_block, wbc);\n}\n\nstatic int minix_read_folio(struct file *file, struct folio *folio)\n{\n\treturn block_read_full_folio(folio, minix_get_block);\n}\n\nint minix_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, minix_get_block);\n}\n\nstatic void minix_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tminix_truncate(inode);\n\t}\n}\n\nstatic int minix_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, pagep, minix_get_block);\n\tif (unlikely(ret))\n\t\tminix_write_failed(mapping, pos + len);\n\n\treturn ret;\n}\n\nstatic sector_t minix_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,minix_get_block);\n}\n\nstatic const struct address_space_operations minix_aops = {\n\t.dirty_folio\t= block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.read_folio = minix_read_folio,\n\t.writepage = minix_writepage,\n\t.write_begin = minix_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = minix_bmap,\n\t.direct_IO = noop_direct_IO\n};\n\nstatic const struct inode_operations minix_symlink_inode_operations = {\n\t.get_link\t= page_get_link,\n\t.getattr\t= minix_getattr,\n};\n\nvoid minix_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &minix_file_inode_operations;\n\t\tinode->i_fop = &minix_file_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &minix_dir_inode_operations;\n\t\tinode->i_fop = &minix_dir_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &minix_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}\n\n \nstatic struct inode *V1_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V1_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (raw_inode->i_nlinks == 0) {\n\t\tprintk(\"MINIX-fs: deleted inode referenced: %lu\\n\",\n\t\t       inode->i_ino);\n\t\tbrelse(bh);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime(inode, raw_inode->i_time, 0);\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 9; i++)\n\t\tminix_inode->u.i1_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}\n\n \nstatic struct inode *V2_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (raw_inode->i_nlinks == 0) {\n\t\tprintk(\"MINIX-fs: deleted inode referenced: %lu\\n\",\n\t\t       inode->i_ino);\n\t\tbrelse(bh);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = raw_inode->i_mtime;\n\tinode->i_atime.tv_sec = raw_inode->i_atime;\n\tinode_set_ctime(inode, raw_inode->i_ctime, 0);\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 10; i++)\n\t\tminix_inode->u.i2_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}\n\n \nstruct inode *minix_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\treturn V1_minix_iget(inode);\n\telse\n\t\treturn V2_minix_iget(inode);\n}\n\n \nstatic struct buffer_head * V1_minix_update_inode(struct inode * inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V1_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode)\n\t\treturn NULL;\n\traw_inode->i_mode = inode->i_mode;\n\traw_inode->i_uid = fs_high2lowuid(i_uid_read(inode));\n\traw_inode->i_gid = fs_high2lowgid(i_gid_read(inode));\n\traw_inode->i_nlinks = inode->i_nlink;\n\traw_inode->i_size = inode->i_size;\n\traw_inode->i_time = inode->i_mtime.tv_sec;\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_zone[0] = old_encode_dev(inode->i_rdev);\n\telse for (i = 0; i < 9; i++)\n\t\traw_inode->i_zone[i] = minix_inode->u.i1_data[i];\n\tmark_buffer_dirty(bh);\n\treturn bh;\n}\n\n \nstatic struct buffer_head * V2_minix_update_inode(struct inode * inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode)\n\t\treturn NULL;\n\traw_inode->i_mode = inode->i_mode;\n\traw_inode->i_uid = fs_high2lowuid(i_uid_read(inode));\n\traw_inode->i_gid = fs_high2lowgid(i_gid_read(inode));\n\traw_inode->i_nlinks = inode->i_nlink;\n\traw_inode->i_size = inode->i_size;\n\traw_inode->i_mtime = inode->i_mtime.tv_sec;\n\traw_inode->i_atime = inode->i_atime.tv_sec;\n\traw_inode->i_ctime = inode_get_ctime(inode).tv_sec;\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_zone[0] = old_encode_dev(inode->i_rdev);\n\telse for (i = 0; i < 10; i++)\n\t\traw_inode->i_zone[i] = minix_inode->u.i2_data[i];\n\tmark_buffer_dirty(bh);\n\treturn bh;\n}\n\nstatic int minix_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct buffer_head *bh;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tbh = V1_minix_update_inode(inode);\n\telse\n\t\tbh = V2_minix_update_inode(inode);\n\tif (!bh)\n\t\treturn -EIO;\n\tif (wbc->sync_mode == WB_SYNC_ALL && buffer_dirty(bh)) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk(\"IO error syncing minix inode [%s:%08lx]\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse (bh);\n\treturn err;\n}\n\nint minix_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t  struct kstat *stat, u32 request_mask, unsigned int flags)\n{\n\tstruct super_block *sb = path->dentry->d_sb;\n\tstruct inode *inode = d_inode(path->dentry);\n\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tstat->blocks = (BLOCK_SIZE / 512) * V1_minix_blocks(stat->size, sb);\n\telse\n\t\tstat->blocks = (sb->s_blocksize / 512) * V2_minix_blocks(stat->size, sb);\n\tstat->blksize = sb->s_blocksize;\n\treturn 0;\n}\n\n \nvoid minix_truncate(struct inode * inode)\n{\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)))\n\t\treturn;\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tV1_minix_truncate(inode);\n\telse\n\t\tV2_minix_truncate(inode);\n}\n\nstatic struct dentry *minix_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, minix_fill_super);\n}\n\nstatic struct file_system_type minix_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"minix\",\n\t.mount\t\t= minix_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"minix\");\n\nstatic int __init init_minix_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&minix_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}\n\nstatic void __exit exit_minix_fs(void)\n{\n        unregister_filesystem(&minix_fs_type);\n\tdestroy_inodecache();\n}\n\nmodule_init(init_minix_fs)\nmodule_exit(exit_minix_fs)\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}