{
  "module_name": "dir.c",
  "hash_id": "744b479e7a7047b6af598bf6393666ce658cfaa2bcd9010e4681ae3856c75268",
  "original_prompt": "Ingested from linux-6.6.14/fs/minix/dir.c",
  "human_readable_source": "\n \n\n#include \"minix.h\"\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n\ntypedef struct minix_dir_entry minix_dirent;\ntypedef struct minix3_dir_entry minix3_dirent;\n\nstatic int minix_readdir(struct file *, struct dir_context *);\n\nconst struct file_operations minix_dir_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= minix_readdir,\n\t.fsync\t\t= generic_file_fsync,\n};\n\nstatic inline void dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}\n\n \nstatic unsigned\nminix_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = PAGE_SIZE;\n\n\tif (page_nr == (inode->i_size >> PAGE_SHIFT))\n\t\tlast_byte = inode->i_size & (PAGE_SIZE - 1);\n\treturn last_byte;\n}\n\nstatic void dir_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tunlock_page(page);\n}\n\nstatic int minix_handle_dirsync(struct inode *dir)\n{\n\tint err;\n\n\terr = filemap_write_and_wait(dir->i_mapping);\n\tif (!err)\n\t\terr = sync_inode_metadata(dir, 1);\n\treturn err;\n}\n\nstatic struct page * dir_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page))\n\t\tkmap(page);\n\treturn page;\n}\n\nstatic inline void *minix_next_entry(void *de, struct minix_sb_info *sbi)\n{\n\treturn (void*)((char*)de + sbi->s_dirsize);\n}\n\nstatic int minix_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tunsigned chunk_size = sbi->s_dirsize;\n\tunsigned long npages = dir_pages(inode);\n\tunsigned long pos = ctx->pos;\n\tunsigned offset;\n\tunsigned long n;\n\n\tctx->pos = pos = ALIGN(pos, chunk_size);\n\tif (pos >= inode->i_size)\n\t\treturn 0;\n\n\toffset = pos & ~PAGE_MASK;\n\tn = pos >> PAGE_SHIFT;\n\n\tfor ( ; n < npages; n++, offset = 0) {\n\t\tchar *p, *kaddr, *limit;\n\t\tstruct page *page = dir_get_page(inode, n);\n\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\t\tkaddr = (char *)page_address(page);\n\t\tp = kaddr+offset;\n\t\tlimit = kaddr + minix_last_byte(inode, n) - chunk_size;\n\t\tfor ( ; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tconst char *name;\n\t\t\t__u32 inumber;\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tname = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t \t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tname = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (inumber) {\n\t\t\t\tunsigned l = strnlen(name, sbi->s_namelen);\n\t\t\t\tif (!dir_emit(ctx, name, l,\n\t\t\t\t\t      inumber, DT_UNKNOWN)) {\n\t\t\t\t\tdir_put_page(page);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->pos += chunk_size;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn 0;\n}\n\nstatic inline int namecompare(int len, int maxlen,\n\tconst char * name, const char * buffer)\n{\n\tif (len < maxlen && buffer[len])\n\t\treturn 0;\n\treturn !memcmp(name, buffer, len);\n}\n\n \nminix_dirent *minix_find_entry(struct dentry *dentry, struct page **res_page)\n{\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct inode * dir = d_inode(dentry->d_parent);\n\tstruct super_block * sb = dir->i_sb;\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tunsigned long n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tchar *p;\n\n\tchar *namx;\n\t__u32 inumber;\n\t*res_page = NULL;\n\n\tfor (n = 0; n < npages; n++) {\n\t\tchar *kaddr, *limit;\n\n\t\tpage = dir_get_page(dir, n);\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char*)page_address(page);\n\t\tlimit = kaddr + minix_last_byte(dir, n) - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tnamx = de3->name;\n\t\t\t\tinumber = de3->inode;\n \t\t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tnamx = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (!inumber)\n\t\t\t\tcontinue;\n\t\t\tif (namecompare(namelen, sbi->s_namelen, name, namx))\n\t\t\t\tgoto found;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\treturn (minix_dirent *)p;\n}\n\nint minix_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = d_inode(dentry->d_parent);\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tstruct page *page = NULL;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr, *p;\n\tminix_dirent *de;\n\tminix3_dirent *de3;\n\tloff_t pos;\n\tint err;\n\tchar *namx = NULL;\n\t__u32 inumber;\n\n\t \n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *limit, *dir_end;\n\n\t\tpage = dir_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = (char*)page_address(page);\n\t\tdir_end = kaddr + minix_last_byte(dir, n);\n\t\tlimit = kaddr + PAGE_SIZE - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tde = (minix_dirent *)p;\n\t\t\tde3 = (minix3_dirent *)p;\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tnamx = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t\t \t} else {\n  \t\t\t\tnamx = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (p == dir_end) {\n\t\t\t\t \n\t\t\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t\t\tde3->inode = 0;\n\t\t \t\telse\n\t\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (!inumber)\n\t\t\t\tgoto got_it;\n\t\t\terr = -EEXIST;\n\t\t\tif (namecompare(namelen, sbi->s_namelen, name, namx))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t\tunlock_page(page);\n\t\tdir_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) + p - (char *)page_address(page);\n\terr = minix_prepare_chunk(page, pos, sbi->s_dirsize);\n\tif (err)\n\t\tgoto out_unlock;\n\tmemcpy (namx, name, namelen);\n\tif (sbi->s_version == MINIX_V3) {\n\t\tmemset (namx + namelen, 0, sbi->s_dirsize - namelen - 4);\n\t\tde3->inode = inode->i_ino;\n\t} else {\n\t\tmemset (namx + namelen, 0, sbi->s_dirsize - namelen - 2);\n\t\tde->inode = inode->i_ino;\n\t}\n\tdir_commit_chunk(page, pos, sbi->s_dirsize);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tmark_inode_dirty(dir);\n\terr = minix_handle_dirsync(dir);\nout_put:\n\tdir_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}\n\nint minix_delete_entry(struct minix_dir_entry *de, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr = page_address(page);\n\tloff_t pos = page_offset(page) + (char*)de - kaddr;\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tunsigned len = sbi->s_dirsize;\n\tint err;\n\n\tlock_page(page);\n\terr = minix_prepare_chunk(page, pos, len);\n\tif (err) {\n\t\tunlock_page(page);\n\t\treturn err;\n\t}\n\tif (sbi->s_version == MINIX_V3)\n\t\t((minix3_dirent *)de)->inode = 0;\n\telse\n\t\tde->inode = 0;\n\tdir_commit_chunk(page, pos, len);\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n\treturn minix_handle_dirsync(inode);\n}\n\nint minix_make_empty(struct inode *inode, struct inode *dir)\n{\n\tstruct page *page = grab_cache_page(inode->i_mapping, 0);\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tchar *kaddr;\n\tint err;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\terr = minix_prepare_chunk(page, 0, 2 * sbi->s_dirsize);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tmemset(kaddr, 0, PAGE_SIZE);\n\n\tif (sbi->s_version == MINIX_V3) {\n\t\tminix3_dirent *de3 = (minix3_dirent *)kaddr;\n\n\t\tde3->inode = inode->i_ino;\n\t\tstrcpy(de3->name, \".\");\n\t\tde3 = minix_next_entry(de3, sbi);\n\t\tde3->inode = dir->i_ino;\n\t\tstrcpy(de3->name, \"..\");\n\t} else {\n\t\tminix_dirent *de = (minix_dirent *)kaddr;\n\n\t\tde->inode = inode->i_ino;\n\t\tstrcpy(de->name, \".\");\n\t\tde = minix_next_entry(de, sbi);\n\t\tde->inode = dir->i_ino;\n\t\tstrcpy(de->name, \"..\");\n\t}\n\tkunmap_atomic(kaddr);\n\n\tdir_commit_chunk(page, 0, 2 * sbi->s_dirsize);\n\terr = minix_handle_dirsync(inode);\nfail:\n\tput_page(page);\n\treturn err;\n}\n\n \nint minix_empty_dir(struct inode * inode)\n{\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tchar *name;\n\t__u32 inumber;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *p, *kaddr, *limit;\n\n\t\tpage = dir_get_page(inode, i);\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char *)page_address(page);\n\t\tlimit = kaddr + minix_last_byte(inode, i) - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tname = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t\t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tname = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\n\t\t\tif (inumber != 0) {\n\t\t\t\t \n\t\t\t\tif (name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (!name[1]) {\n\t\t\t\t\tif (inumber != inode->i_ino)\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\telse if (name[2])\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tdir_put_page(page);\n\treturn 0;\n}\n\n \nint minix_set_link(struct minix_dir_entry *de, struct page *page,\n\t\tstruct inode *inode)\n{\n\tstruct inode *dir = page->mapping->host;\n\tstruct minix_sb_info *sbi = minix_sb(dir->i_sb);\n\tloff_t pos = page_offset(page) +\n\t\t\t(char *)de-(char*)page_address(page);\n\tint err;\n\n\tlock_page(page);\n\terr = minix_prepare_chunk(page, pos, sbi->s_dirsize);\n\tif (err) {\n\t\tunlock_page(page);\n\t\treturn err;\n\t}\n\tif (sbi->s_version == MINIX_V3)\n\t\t((minix3_dirent *)de)->inode = inode->i_ino;\n\telse\n\t\tde->inode = inode->i_ino;\n\tdir_commit_chunk(page, pos, sbi->s_dirsize);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tmark_inode_dirty(dir);\n\treturn minix_handle_dirsync(dir);\n}\n\nstruct minix_dir_entry * minix_dotdot (struct inode *dir, struct page **p)\n{\n\tstruct page *page = dir_get_page(dir, 0);\n\tstruct minix_sb_info *sbi = minix_sb(dir->i_sb);\n\tstruct minix_dir_entry *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = minix_next_entry(page_address(page), sbi);\n\t\t*p = page;\n\t}\n\treturn de;\n}\n\nino_t minix_inode_by_name(struct dentry *dentry)\n{\n\tstruct page *page;\n\tstruct minix_dir_entry *de = minix_find_entry(dentry, &page);\n\tino_t res = 0;\n\n\tif (de) {\n\t\tstruct address_space *mapping = page->mapping;\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\n\t\tif (sbi->s_version == MINIX_V3)\n\t\t\tres = ((minix3_dirent *) de)->inode;\n\t\telse\n\t\t\tres = de->inode;\n\t\tdir_put_page(page);\n\t}\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}