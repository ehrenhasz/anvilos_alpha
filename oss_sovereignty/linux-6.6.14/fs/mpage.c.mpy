{
  "module_name": "mpage.c",
  "hash_id": "b83dd9e0936256fa25096a0f41e1b28a7c0f3ee65586e234951e32d3505b7e15",
  "original_prompt": "Ingested from linux-6.6.14/fs/mpage.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/kdev_t.h>\n#include <linux/gfp.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/prefetch.h>\n#include <linux/mpage.h>\n#include <linux/mm_inline.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/pagevec.h>\n#include \"internal.h\"\n\n \nstatic void mpage_read_end_io(struct bio *bio)\n{\n\tstruct folio_iter fi;\n\tint err = blk_status_to_errno(bio->bi_status);\n\n\tbio_for_each_folio_all(fi, bio) {\n\t\tif (err)\n\t\t\tfolio_set_error(fi.folio);\n\t\telse\n\t\t\tfolio_mark_uptodate(fi.folio);\n\t\tfolio_unlock(fi.folio);\n\t}\n\n\tbio_put(bio);\n}\n\nstatic void mpage_write_end_io(struct bio *bio)\n{\n\tstruct folio_iter fi;\n\tint err = blk_status_to_errno(bio->bi_status);\n\n\tbio_for_each_folio_all(fi, bio) {\n\t\tif (err) {\n\t\t\tfolio_set_error(fi.folio);\n\t\t\tmapping_set_error(fi.folio->mapping, err);\n\t\t}\n\t\tfolio_end_writeback(fi.folio);\n\t}\n\n\tbio_put(bio);\n}\n\nstatic struct bio *mpage_bio_submit_read(struct bio *bio)\n{\n\tbio->bi_end_io = mpage_read_end_io;\n\tguard_bio_eod(bio);\n\tsubmit_bio(bio);\n\treturn NULL;\n}\n\nstatic struct bio *mpage_bio_submit_write(struct bio *bio)\n{\n\tbio->bi_end_io = mpage_write_end_io;\n\tguard_bio_eod(bio);\n\tsubmit_bio(bio);\n\treturn NULL;\n}\n\n \nstatic void map_buffer_to_folio(struct folio *folio, struct buffer_head *bh,\n\t\tint page_block)\n{\n\tstruct inode *inode = folio->mapping->host;\n\tstruct buffer_head *page_bh, *head;\n\tint block = 0;\n\n\thead = folio_buffers(folio);\n\tif (!head) {\n\t\t \n\t\tif (inode->i_blkbits == PAGE_SHIFT &&\n\t\t    buffer_uptodate(bh)) {\n\t\t\tfolio_mark_uptodate(folio);\n\t\t\treturn;\n\t\t}\n\t\tcreate_empty_buffers(&folio->page, i_blocksize(inode), 0);\n\t\thead = folio_buffers(folio);\n\t}\n\n\tpage_bh = head;\n\tdo {\n\t\tif (block == page_block) {\n\t\t\tpage_bh->b_state = bh->b_state;\n\t\t\tpage_bh->b_bdev = bh->b_bdev;\n\t\t\tpage_bh->b_blocknr = bh->b_blocknr;\n\t\t\tbreak;\n\t\t}\n\t\tpage_bh = page_bh->b_this_page;\n\t\tblock++;\n\t} while (page_bh != head);\n}\n\nstruct mpage_readpage_args {\n\tstruct bio *bio;\n\tstruct folio *folio;\n\tunsigned int nr_pages;\n\tbool is_readahead;\n\tsector_t last_block_in_bio;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block;\n\tget_block_t *get_block;\n};\n\n \nstatic struct bio *do_mpage_readpage(struct mpage_readpage_args *args)\n{\n\tstruct folio *folio = args->folio;\n\tstruct inode *inode = folio->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocks_per_page = PAGE_SIZE >> blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tstruct buffer_head *map_bh = &args->map_bh;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_hole = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint length;\n\tint fully_mapped = 1;\n\tblk_opf_t opf = REQ_OP_READ;\n\tunsigned nblocks;\n\tunsigned relative_block;\n\tgfp_t gfp = mapping_gfp_constraint(folio->mapping, GFP_KERNEL);\n\n\t \n\tVM_BUG_ON_FOLIO(folio_test_large(folio), folio);\n\n\tif (args->is_readahead) {\n\t\topf |= REQ_RAHEAD;\n\t\tgfp |= __GFP_NORETRY | __GFP_NOWARN;\n\t}\n\n\tif (folio_buffers(folio))\n\t\tgoto confused;\n\n\tblock_in_file = (sector_t)folio->index << (PAGE_SHIFT - blkbits);\n\tlast_block = block_in_file + args->nr_pages * blocks_per_page;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >> blkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\tpage_block = 0;\n\n\t \n\tnblocks = map_bh->b_size >> blkbits;\n\tif (buffer_mapped(map_bh) &&\n\t\t\tblock_in_file > args->first_logical_block &&\n\t\t\tblock_in_file < (args->first_logical_block + nblocks)) {\n\t\tunsigned map_offset = block_in_file - args->first_logical_block;\n\t\tunsigned last = nblocks - map_offset;\n\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == last) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr + map_offset +\n\t\t\t\t\t\trelative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\t \n\tmap_bh->b_folio = folio;\n\twhile (page_block < blocks_per_page) {\n\t\tmap_bh->b_state = 0;\n\t\tmap_bh->b_size = 0;\n\n\t\tif (block_in_file < last_block) {\n\t\t\tmap_bh->b_size = (last_block-block_in_file) << blkbits;\n\t\t\tif (args->get_block(inode, block_in_file, map_bh, 0))\n\t\t\t\tgoto confused;\n\t\t\targs->first_logical_block = block_in_file;\n\t\t}\n\n\t\tif (!buffer_mapped(map_bh)) {\n\t\t\tfully_mapped = 0;\n\t\t\tif (first_hole == blocks_per_page)\n\t\t\t\tfirst_hole = page_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (buffer_uptodate(map_bh)) {\n\t\t\tmap_buffer_to_folio(folio, map_bh, page_block);\n\t\t\tgoto confused;\n\t\t}\n\t\n\t\tif (first_hole != blocks_per_page)\n\t\t\tgoto confused;\t\t \n\n\t\t \n\t\tif (page_block && blocks[page_block-1] != map_bh->b_blocknr-1)\n\t\t\tgoto confused;\n\t\tnblocks = map_bh->b_size >> blkbits;\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == nblocks) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t} else if (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr+relative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\tif (first_hole != blocks_per_page) {\n\t\tfolio_zero_segment(folio, first_hole << blkbits, PAGE_SIZE);\n\t\tif (first_hole == 0) {\n\t\t\tfolio_mark_uptodate(folio);\n\t\t\tfolio_unlock(folio);\n\t\t\tgoto out;\n\t\t}\n\t} else if (fully_mapped) {\n\t\tfolio_set_mappedtodisk(folio);\n\t}\n\n\t \n\tif (args->bio && (args->last_block_in_bio != blocks[0] - 1))\n\t\targs->bio = mpage_bio_submit_read(args->bio);\n\nalloc_new:\n\tif (args->bio == NULL) {\n\t\targs->bio = bio_alloc(bdev, bio_max_segs(args->nr_pages), opf,\n\t\t\t\t      gfp);\n\t\tif (args->bio == NULL)\n\t\t\tgoto confused;\n\t\targs->bio->bi_iter.bi_sector = blocks[0] << (blkbits - 9);\n\t}\n\n\tlength = first_hole << blkbits;\n\tif (!bio_add_folio(args->bio, folio, length, 0)) {\n\t\targs->bio = mpage_bio_submit_read(args->bio);\n\t\tgoto alloc_new;\n\t}\n\n\trelative_block = block_in_file - args->first_logical_block;\n\tnblocks = map_bh->b_size >> blkbits;\n\tif ((buffer_boundary(map_bh) && relative_block == nblocks) ||\n\t    (first_hole != blocks_per_page))\n\t\targs->bio = mpage_bio_submit_read(args->bio);\n\telse\n\t\targs->last_block_in_bio = blocks[blocks_per_page - 1];\nout:\n\treturn args->bio;\n\nconfused:\n\tif (args->bio)\n\t\targs->bio = mpage_bio_submit_read(args->bio);\n\tif (!folio_test_uptodate(folio))\n\t\tblock_read_full_folio(folio, args->get_block);\n\telse\n\t\tfolio_unlock(folio);\n\tgoto out;\n}\n\n \nvoid mpage_readahead(struct readahead_control *rac, get_block_t get_block)\n{\n\tstruct folio *folio;\n\tstruct mpage_readpage_args args = {\n\t\t.get_block = get_block,\n\t\t.is_readahead = true,\n\t};\n\n\twhile ((folio = readahead_folio(rac))) {\n\t\tprefetchw(&folio->flags);\n\t\targs.folio = folio;\n\t\targs.nr_pages = readahead_count(rac);\n\t\targs.bio = do_mpage_readpage(&args);\n\t}\n\tif (args.bio)\n\t\tmpage_bio_submit_read(args.bio);\n}\nEXPORT_SYMBOL(mpage_readahead);\n\n \nint mpage_read_folio(struct folio *folio, get_block_t get_block)\n{\n\tstruct mpage_readpage_args args = {\n\t\t.folio = folio,\n\t\t.nr_pages = 1,\n\t\t.get_block = get_block,\n\t};\n\n\targs.bio = do_mpage_readpage(&args);\n\tif (args.bio)\n\t\tmpage_bio_submit_read(args.bio);\n\treturn 0;\n}\nEXPORT_SYMBOL(mpage_read_folio);\n\n \n\nstruct mpage_data {\n\tstruct bio *bio;\n\tsector_t last_block_in_bio;\n\tget_block_t *get_block;\n};\n\n \nstatic void clean_buffers(struct page *page, unsigned first_unmapped)\n{\n\tunsigned buffer_counter = 0;\n\tstruct buffer_head *bh, *head;\n\tif (!page_has_buffers(page))\n\t\treturn;\n\thead = page_buffers(page);\n\tbh = head;\n\n\tdo {\n\t\tif (buffer_counter++ == first_unmapped)\n\t\t\tbreak;\n\t\tclear_buffer_dirty(bh);\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t \n\tif (buffer_heads_over_limit && PageUptodate(page))\n\t\ttry_to_free_buffers(page_folio(page));\n}\n\n \nvoid clean_page_buffers(struct page *page)\n{\n\tclean_buffers(page, ~0U);\n}\n\nstatic int __mpage_writepage(struct folio *folio, struct writeback_control *wbc,\n\t\t      void *data)\n{\n\tstruct mpage_data *mpd = data;\n\tstruct bio *bio = mpd->bio;\n\tstruct address_space *mapping = folio->mapping;\n\tstruct inode *inode = mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocks_per_page = PAGE_SIZE >> blkbits;\n\tsector_t last_block;\n\tsector_t block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_unmapped = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint boundary = 0;\n\tsector_t boundary_block = 0;\n\tstruct block_device *boundary_bdev = NULL;\n\tsize_t length;\n\tstruct buffer_head map_bh;\n\tloff_t i_size = i_size_read(inode);\n\tint ret = 0;\n\tstruct buffer_head *head = folio_buffers(folio);\n\n\tif (head) {\n\t\tstruct buffer_head *bh = head;\n\n\t\t \n\t\tpage_block = 0;\n\t\tdo {\n\t\t\tBUG_ON(buffer_locked(bh));\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\t \n\t\t\t\tif (buffer_dirty(bh))\n\t\t\t\t\tgoto confused;\n\t\t\t\tif (first_unmapped == blocks_per_page)\n\t\t\t\t\tfirst_unmapped = page_block;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (first_unmapped != blocks_per_page)\n\t\t\t\tgoto confused;\t \n\n\t\t\tif (!buffer_dirty(bh) || !buffer_uptodate(bh))\n\t\t\t\tgoto confused;\n\t\t\tif (page_block) {\n\t\t\t\tif (bh->b_blocknr != blocks[page_block-1] + 1)\n\t\t\t\t\tgoto confused;\n\t\t\t}\n\t\t\tblocks[page_block++] = bh->b_blocknr;\n\t\t\tboundary = buffer_boundary(bh);\n\t\t\tif (boundary) {\n\t\t\t\tboundary_block = bh->b_blocknr;\n\t\t\t\tboundary_bdev = bh->b_bdev;\n\t\t\t}\n\t\t\tbdev = bh->b_bdev;\n\t\t} while ((bh = bh->b_this_page) != head);\n\n\t\tif (first_unmapped)\n\t\t\tgoto page_is_mapped;\n\n\t\t \n\t\tgoto confused;\n\t}\n\n\t \n\tBUG_ON(!folio_test_uptodate(folio));\n\tblock_in_file = (sector_t)folio->index << (PAGE_SHIFT - blkbits);\n\t \n\tif (block_in_file >= (i_size + (1 << blkbits) - 1) >> blkbits)\n\t\tgoto page_is_mapped;\n\tlast_block = (i_size - 1) >> blkbits;\n\tmap_bh.b_folio = folio;\n\tfor (page_block = 0; page_block < blocks_per_page; ) {\n\n\t\tmap_bh.b_state = 0;\n\t\tmap_bh.b_size = 1 << blkbits;\n\t\tif (mpd->get_block(inode, block_in_file, &map_bh, 1))\n\t\t\tgoto confused;\n\t\tif (!buffer_mapped(&map_bh))\n\t\t\tgoto confused;\n\t\tif (buffer_new(&map_bh))\n\t\t\tclean_bdev_bh_alias(&map_bh);\n\t\tif (buffer_boundary(&map_bh)) {\n\t\t\tboundary_block = map_bh.b_blocknr;\n\t\t\tboundary_bdev = map_bh.b_bdev;\n\t\t}\n\t\tif (page_block) {\n\t\t\tif (map_bh.b_blocknr != blocks[page_block-1] + 1)\n\t\t\t\tgoto confused;\n\t\t}\n\t\tblocks[page_block++] = map_bh.b_blocknr;\n\t\tboundary = buffer_boundary(&map_bh);\n\t\tbdev = map_bh.b_bdev;\n\t\tif (block_in_file == last_block)\n\t\t\tbreak;\n\t\tblock_in_file++;\n\t}\n\tBUG_ON(page_block == 0);\n\n\tfirst_unmapped = page_block;\n\npage_is_mapped:\n\t \n\tif (folio_pos(folio) >= i_size)\n\t\tgoto confused;\n\tlength = folio_size(folio);\n\tif (folio_pos(folio) + length > i_size) {\n\t\t \n\t\tlength = i_size - folio_pos(folio);\n\t\tfolio_zero_segment(folio, length, folio_size(folio));\n\t}\n\n\t \n\tif (bio && mpd->last_block_in_bio != blocks[0] - 1)\n\t\tbio = mpage_bio_submit_write(bio);\n\nalloc_new:\n\tif (bio == NULL) {\n\t\tbio = bio_alloc(bdev, BIO_MAX_VECS,\n\t\t\t\tREQ_OP_WRITE | wbc_to_write_flags(wbc),\n\t\t\t\tGFP_NOFS);\n\t\tbio->bi_iter.bi_sector = blocks[0] << (blkbits - 9);\n\t\twbc_init_bio(wbc, bio);\n\t}\n\n\t \n\twbc_account_cgroup_owner(wbc, &folio->page, folio_size(folio));\n\tlength = first_unmapped << blkbits;\n\tif (!bio_add_folio(bio, folio, length, 0)) {\n\t\tbio = mpage_bio_submit_write(bio);\n\t\tgoto alloc_new;\n\t}\n\n\tclean_buffers(&folio->page, first_unmapped);\n\n\tBUG_ON(folio_test_writeback(folio));\n\tfolio_start_writeback(folio);\n\tfolio_unlock(folio);\n\tif (boundary || (first_unmapped != blocks_per_page)) {\n\t\tbio = mpage_bio_submit_write(bio);\n\t\tif (boundary_block) {\n\t\t\twrite_boundary_block(boundary_bdev,\n\t\t\t\t\tboundary_block, 1 << blkbits);\n\t\t}\n\t} else {\n\t\tmpd->last_block_in_bio = blocks[blocks_per_page - 1];\n\t}\n\tgoto out;\n\nconfused:\n\tif (bio)\n\t\tbio = mpage_bio_submit_write(bio);\n\n\t \n\tret = block_write_full_page(&folio->page, mpd->get_block, wbc);\n\tmapping_set_error(mapping, ret);\nout:\n\tmpd->bio = bio;\n\treturn ret;\n}\n\n \nint\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct mpage_data mpd = {\n\t\t.get_block\t= get_block,\n\t};\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\tif (mpd.bio)\n\t\tmpage_bio_submit_write(mpd.bio);\n\tblk_finish_plug(&plug);\n\treturn ret;\n}\nEXPORT_SYMBOL(mpage_writepages);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}