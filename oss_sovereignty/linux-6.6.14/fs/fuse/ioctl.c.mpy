{
  "module_name": "ioctl.c",
  "hash_id": "7e0c779b7a033a234956c63cc966e1c83ebe4282d6ddd7b338b3e9de025f9abf",
  "original_prompt": "Ingested from linux-6.6.14/fs/fuse/ioctl.c",
  "human_readable_source": "\n \n\n#include \"fuse_i.h\"\n\n#include <linux/uio.h>\n#include <linux/compat.h>\n#include <linux/fileattr.h>\n\nstatic ssize_t fuse_send_ioctl(struct fuse_mount *fm, struct fuse_args *args,\n\t\t\t       struct fuse_ioctl_out *outarg)\n{\n\tssize_t ret;\n\n\targs->out_args[0].size = sizeof(*outarg);\n\targs->out_args[0].value = outarg;\n\n\tret = fuse_simple_request(fm, args);\n\n\t \n\tif (ret == -ENOSYS)\n\t\tret = -ENOTTY;\n\n\tif (ret >= 0 && outarg->result == -ENOSYS)\n\t\toutarg->result = -ENOTTY;\n\n\treturn ret;\n}\n\n \nstatic int fuse_copy_ioctl_iovec_old(struct iovec *dst, void *src,\n\t\t\t\t     size_t transferred, unsigned count,\n\t\t\t\t     bool is_compat)\n{\n#ifdef CONFIG_COMPAT\n\tif (count * sizeof(struct compat_iovec) == transferred) {\n\t\tstruct compat_iovec *ciov = src;\n\t\tunsigned i;\n\n\t\t \n\t\tif (!is_compat)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tdst[i].iov_base = compat_ptr(ciov[i].iov_base);\n\t\t\tdst[i].iov_len = ciov[i].iov_len;\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\n\tif (count * sizeof(struct iovec) != transferred)\n\t\treturn -EIO;\n\n\tmemcpy(dst, src, transferred);\n\treturn 0;\n}\n\n \nstatic int fuse_verify_ioctl_iov(struct fuse_conn *fc, struct iovec *iov,\n\t\t\t\t size_t count)\n{\n\tsize_t n;\n\tu32 max = fc->max_pages << PAGE_SHIFT;\n\n\tfor (n = 0; n < count; n++, iov++) {\n\t\tif (iov->iov_len > (size_t) max)\n\t\t\treturn -ENOMEM;\n\t\tmax -= iov->iov_len;\n\t}\n\treturn 0;\n}\n\nstatic int fuse_copy_ioctl_iovec(struct fuse_conn *fc, struct iovec *dst,\n\t\t\t\t void *src, size_t transferred, unsigned count,\n\t\t\t\t bool is_compat)\n{\n\tunsigned i;\n\tstruct fuse_ioctl_iovec *fiov = src;\n\n\tif (fc->minor < 16) {\n\t\treturn fuse_copy_ioctl_iovec_old(dst, src, transferred,\n\t\t\t\t\t\t count, is_compat);\n\t}\n\n\tif (count * sizeof(struct fuse_ioctl_iovec) != transferred)\n\t\treturn -EIO;\n\n\tfor (i = 0; i < count; i++) {\n\t\t \n\t\tif (fiov[i].base != (unsigned long) fiov[i].base ||\n\t\t    fiov[i].len != (unsigned long) fiov[i].len)\n\t\t\treturn -EIO;\n\n\t\tdst[i].iov_base = (void __user *) (unsigned long) fiov[i].base;\n\t\tdst[i].iov_len = (size_t) fiov[i].len;\n\n#ifdef CONFIG_COMPAT\n\t\tif (is_compat &&\n\t\t    (ptr_to_compat(dst[i].iov_base) != fiov[i].base ||\n\t\t     (compat_size_t) dst[i].iov_len != fiov[i].len))\n\t\t\treturn -EIO;\n#endif\n\t}\n\n\treturn 0;\n}\n\n\n \nlong fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_mount *fm = ff->fm;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct iovec *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, max_pages;\n\tsize_t in_size, out_size, c;\n\tssize_t transferred;\n\tint err, i;\n\tstruct iov_iter ii;\n\tstruct fuse_args_pages ap = {};\n\n#if BITS_PER_LONG == 32\n\tinarg.flags |= FUSE_IOCTL_32BIT;\n#else\n\tif (flags & FUSE_IOCTL_COMPAT) {\n\t\tinarg.flags |= FUSE_IOCTL_32BIT;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall())\n\t\t\tinarg.flags |= FUSE_IOCTL_COMPAT_X32;\n#endif\n\t}\n#endif\n\n\t \n\tBUILD_BUG_ON(sizeof(struct fuse_ioctl_iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tap.pages = fuse_pages_alloc(fm->fc->max_pages, GFP_KERNEL, &ap.descs);\n\tiov_page = (struct iovec *) __get_free_page(GFP_KERNEL);\n\tif (!ap.pages || !iov_page)\n\t\tgoto out;\n\n\tfuse_page_descs_length_init(ap.descs, 0, fm->fc->max_pages);\n\n\t \n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = iov_page;\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t \n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t \n\terr = -ENOMEM;\n\tif (max_pages > fm->fc->max_pages)\n\t\tgoto out;\n\twhile (ap.num_pages < max_pages) {\n\t\tap.pages[ap.num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!ap.pages[ap.num_pages])\n\t\t\tgoto out;\n\t\tap.num_pages++;\n\t}\n\n\n\t \n\tap.args.opcode = FUSE_IOCTL;\n\tap.args.nodeid = ff->nodeid;\n\tap.args.in_numargs = 1;\n\tap.args.in_args[0].size = sizeof(inarg);\n\tap.args.in_args[0].value = &inarg;\n\tif (in_size) {\n\t\tap.args.in_numargs++;\n\t\tap.args.in_args[1].size = in_size;\n\t\tap.args.in_pages = true;\n\n\t\terr = -EFAULT;\n\t\tiov_iter_init(&ii, ITER_SOURCE, in_iov, in_iovs, in_size);\n\t\tfor (i = 0; iov_iter_count(&ii) && !WARN_ON(i >= ap.num_pages); i++) {\n\t\t\tc = copy_page_from_iter(ap.pages[i], 0, PAGE_SIZE, &ii);\n\t\t\tif (c != PAGE_SIZE && iov_iter_count(&ii))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tap.args.out_numargs = 2;\n\tap.args.out_args[1].size = out_size;\n\tap.args.out_pages = true;\n\tap.args.out_argvar = true;\n\n\ttransferred = fuse_send_ioctl(fm, &ap.args, &outarg);\n\terr = transferred;\n\tif (transferred < 0)\n\t\tgoto out;\n\n\t \n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tvoid *vaddr;\n\n\t\t \n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t \n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_local_page(ap.pages[0]);\n\t\terr = fuse_copy_ioctl_iovec(fm->fc, iov_page, vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_local(vaddr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tin_iov = iov_page;\n\t\tout_iov = in_iov + in_iovs;\n\n\t\terr = fuse_verify_ioctl_iov(fm->fc, in_iov, in_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = fuse_verify_ioctl_iov(fm->fc, out_iov, out_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tgoto retry;\n\t}\n\n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = -EFAULT;\n\tiov_iter_init(&ii, ITER_DEST, out_iov, out_iovs, transferred);\n\tfor (i = 0; iov_iter_count(&ii) && !WARN_ON(i >= ap.num_pages); i++) {\n\t\tc = copy_page_to_iter(ap.pages[i], 0, PAGE_SIZE, &ii);\n\t\tif (c != PAGE_SIZE && iov_iter_count(&ii))\n\t\t\tgoto out;\n\t}\n\terr = 0;\n out:\n\tfree_page((unsigned long) iov_page);\n\twhile (ap.num_pages)\n\t\t__free_page(ap.pages[--ap.num_pages]);\n\tkfree(ap.pages);\n\n\treturn err ? err : outarg.result;\n}\nEXPORT_SYMBOL_GPL(fuse_do_ioctl);\n\nlong fuse_ioctl_common(struct file *file, unsigned int cmd,\n\t\t       unsigned long arg, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\tif (fuse_is_bad(inode))\n\t\treturn -EIO;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}\n\nlong fuse_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\treturn fuse_ioctl_common(file, cmd, arg, 0);\n}\n\nlong fuse_file_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\treturn fuse_ioctl_common(file, cmd, arg, FUSE_IOCTL_COMPAT);\n}\n\nstatic int fuse_priv_ioctl(struct inode *inode, struct fuse_file *ff,\n\t\t\t   unsigned int cmd, void *ptr, size_t size)\n{\n\tstruct fuse_mount *fm = ff->fm;\n\tstruct fuse_ioctl_in inarg;\n\tstruct fuse_ioctl_out outarg;\n\tFUSE_ARGS(args);\n\tint err;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.cmd = cmd;\n\n#if BITS_PER_LONG == 32\n\tinarg.flags |= FUSE_IOCTL_32BIT;\n#endif\n\tif (S_ISDIR(inode->i_mode))\n\t\tinarg.flags |= FUSE_IOCTL_DIR;\n\n\tif (_IOC_DIR(cmd) & _IOC_READ)\n\t\tinarg.out_size = size;\n\tif (_IOC_DIR(cmd) & _IOC_WRITE)\n\t\tinarg.in_size = size;\n\n\targs.opcode = FUSE_IOCTL;\n\targs.nodeid = ff->nodeid;\n\targs.in_numargs = 2;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.in_args[1].size = inarg.in_size;\n\targs.in_args[1].value = ptr;\n\targs.out_numargs = 2;\n\targs.out_args[1].size = inarg.out_size;\n\targs.out_args[1].value = ptr;\n\n\terr = fuse_send_ioctl(fm, &args, &outarg);\n\tif (!err) {\n\t\tif (outarg.result < 0)\n\t\t\terr = outarg.result;\n\t\telse if (outarg.flags & FUSE_IOCTL_RETRY)\n\t\t\terr = -EIO;\n\t}\n\treturn err;\n}\n\nstatic struct fuse_file *fuse_priv_ioctl_prepare(struct inode *inode)\n{\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tbool isdir = S_ISDIR(inode->i_mode);\n\n\tif (!fuse_allow_current_process(fm->fc))\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (fuse_is_bad(inode))\n\t\treturn ERR_PTR(-EIO);\n\n\tif (!S_ISREG(inode->i_mode) && !isdir)\n\t\treturn ERR_PTR(-ENOTTY);\n\n\treturn fuse_file_open(fm, get_node_id(inode), O_RDONLY, isdir);\n}\n\nstatic void fuse_priv_ioctl_cleanup(struct inode *inode, struct fuse_file *ff)\n{\n\tfuse_file_release(inode, ff, O_RDONLY, NULL, S_ISDIR(inode->i_mode));\n}\n\nint fuse_fileattr_get(struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct fuse_file *ff;\n\tunsigned int flags;\n\tstruct fsxattr xfa;\n\tint err;\n\n\tff = fuse_priv_ioctl_prepare(inode);\n\tif (IS_ERR(ff))\n\t\treturn PTR_ERR(ff);\n\n\tif (fa->flags_valid) {\n\t\terr = fuse_priv_ioctl(inode, ff, FS_IOC_GETFLAGS,\n\t\t\t\t      &flags, sizeof(flags));\n\t\tif (err)\n\t\t\tgoto cleanup;\n\n\t\tfileattr_fill_flags(fa, flags);\n\t} else {\n\t\terr = fuse_priv_ioctl(inode, ff, FS_IOC_FSGETXATTR,\n\t\t\t\t      &xfa, sizeof(xfa));\n\t\tif (err)\n\t\t\tgoto cleanup;\n\n\t\tfileattr_fill_xflags(fa, xfa.fsx_xflags);\n\t\tfa->fsx_extsize = xfa.fsx_extsize;\n\t\tfa->fsx_nextents = xfa.fsx_nextents;\n\t\tfa->fsx_projid = xfa.fsx_projid;\n\t\tfa->fsx_cowextsize = xfa.fsx_cowextsize;\n\t}\ncleanup:\n\tfuse_priv_ioctl_cleanup(inode, ff);\n\n\treturn err;\n}\n\nint fuse_fileattr_set(struct mnt_idmap *idmap,\n\t\t      struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct fuse_file *ff;\n\tunsigned int flags = fa->flags;\n\tstruct fsxattr xfa;\n\tint err;\n\n\tff = fuse_priv_ioctl_prepare(inode);\n\tif (IS_ERR(ff))\n\t\treturn PTR_ERR(ff);\n\n\tif (fa->flags_valid) {\n\t\terr = fuse_priv_ioctl(inode, ff, FS_IOC_SETFLAGS,\n\t\t\t\t      &flags, sizeof(flags));\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t} else {\n\t\tmemset(&xfa, 0, sizeof(xfa));\n\t\txfa.fsx_xflags = fa->fsx_xflags;\n\t\txfa.fsx_extsize = fa->fsx_extsize;\n\t\txfa.fsx_nextents = fa->fsx_nextents;\n\t\txfa.fsx_projid = fa->fsx_projid;\n\t\txfa.fsx_cowextsize = fa->fsx_cowextsize;\n\n\t\terr = fuse_priv_ioctl(inode, ff, FS_IOC_FSSETXATTR,\n\t\t\t\t      &xfa, sizeof(xfa));\n\t}\n\ncleanup:\n\tfuse_priv_ioctl_cleanup(inode, ff);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}