{
  "module_name": "inode.c",
  "hash_id": "ff9011a4093a9ab1277dbfa8eff1c1fe44feee7b2caa20191dfdc8b179255e3e",
  "original_prompt": "Ingested from linux-6.6.14/fs/fuse/inode.c",
  "human_readable_source": " \n\n#include \"fuse_i.h\"\n\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/sched.h>\n#include <linux/exportfs.h>\n#include <linux/posix_acl.h>\n#include <linux/pid_namespace.h>\n#include <uapi/linux/magic.h>\n\nMODULE_AUTHOR(\"Miklos Szeredi <miklos@szeredi.hu>\");\nMODULE_DESCRIPTION(\"Filesystem in Userspace\");\nMODULE_LICENSE(\"GPL\");\n\nstatic struct kmem_cache *fuse_inode_cachep;\nstruct list_head fuse_conn_list;\nDEFINE_MUTEX(fuse_mutex);\n\nstatic int set_global_limit(const char *val, const struct kernel_param *kp);\n\nunsigned max_user_bgreq;\nmodule_param_call(max_user_bgreq, set_global_limit, param_get_uint,\n\t\t  &max_user_bgreq, 0644);\n__MODULE_PARM_TYPE(max_user_bgreq, \"uint\");\nMODULE_PARM_DESC(max_user_bgreq,\n \"Global limit for the maximum number of backgrounded requests an \"\n \"unprivileged user can set\");\n\nunsigned max_user_congthresh;\nmodule_param_call(max_user_congthresh, set_global_limit, param_get_uint,\n\t\t  &max_user_congthresh, 0644);\n__MODULE_PARM_TYPE(max_user_congthresh, \"uint\");\nMODULE_PARM_DESC(max_user_congthresh,\n \"Global limit for the maximum congestion threshold an \"\n \"unprivileged user can set\");\n\n#define FUSE_DEFAULT_BLKSIZE 512\n\n \n#define FUSE_DEFAULT_MAX_BACKGROUND 12\n\n \n#define FUSE_DEFAULT_CONGESTION_THRESHOLD (FUSE_DEFAULT_MAX_BACKGROUND * 3 / 4)\n\n#ifdef CONFIG_BLOCK\nstatic struct file_system_type fuseblk_fs_type;\n#endif\n\nstruct fuse_forget_link *fuse_alloc_forget(void)\n{\n\treturn kzalloc(sizeof(struct fuse_forget_link), GFP_KERNEL_ACCOUNT);\n}\n\nstatic struct fuse_submount_lookup *fuse_alloc_submount_lookup(void)\n{\n\tstruct fuse_submount_lookup *sl;\n\n\tsl = kzalloc(sizeof(struct fuse_submount_lookup), GFP_KERNEL_ACCOUNT);\n\tif (!sl)\n\t\treturn NULL;\n\tsl->forget = fuse_alloc_forget();\n\tif (!sl->forget)\n\t\tgoto out_free;\n\n\treturn sl;\n\nout_free:\n\tkfree(sl);\n\treturn NULL;\n}\n\nstatic struct inode *fuse_alloc_inode(struct super_block *sb)\n{\n\tstruct fuse_inode *fi;\n\n\tfi = alloc_inode_sb(sb, fuse_inode_cachep, GFP_KERNEL);\n\tif (!fi)\n\t\treturn NULL;\n\n\tfi->i_time = 0;\n\tfi->inval_mask = ~0;\n\tfi->nodeid = 0;\n\tfi->nlookup = 0;\n\tfi->attr_version = 0;\n\tfi->orig_ino = 0;\n\tfi->state = 0;\n\tfi->submount_lookup = NULL;\n\tmutex_init(&fi->mutex);\n\tspin_lock_init(&fi->lock);\n\tfi->forget = fuse_alloc_forget();\n\tif (!fi->forget)\n\t\tgoto out_free;\n\n\tif (IS_ENABLED(CONFIG_FUSE_DAX) && !fuse_dax_inode_alloc(sb, fi))\n\t\tgoto out_free_forget;\n\n\treturn &fi->inode;\n\nout_free_forget:\n\tkfree(fi->forget);\nout_free:\n\tkmem_cache_free(fuse_inode_cachep, fi);\n\treturn NULL;\n}\n\nstatic void fuse_free_inode(struct inode *inode)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tmutex_destroy(&fi->mutex);\n\tkfree(fi->forget);\n#ifdef CONFIG_FUSE_DAX\n\tkfree(fi->dax);\n#endif\n\tkmem_cache_free(fuse_inode_cachep, fi);\n}\n\nstatic void fuse_cleanup_submount_lookup(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_submount_lookup *sl)\n{\n\tif (!refcount_dec_and_test(&sl->count))\n\t\treturn;\n\n\tfuse_queue_forget(fc, sl->forget, sl->nodeid, 1);\n\tsl->forget = NULL;\n\tkfree(sl);\n}\n\nstatic void fuse_evict_inode(struct inode *inode)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t \n\tWARN_ON(inode->i_state & I_DIRTY_INODE);\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (inode->i_sb->s_flags & SB_ACTIVE) {\n\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\t\tif (FUSE_IS_DAX(inode))\n\t\t\tfuse_dax_inode_cleanup(inode);\n\t\tif (fi->nlookup) {\n\t\t\tfuse_queue_forget(fc, fi->forget, fi->nodeid,\n\t\t\t\t\t  fi->nlookup);\n\t\t\tfi->forget = NULL;\n\t\t}\n\n\t\tif (fi->submount_lookup) {\n\t\t\tfuse_cleanup_submount_lookup(fc, fi->submount_lookup);\n\t\t\tfi->submount_lookup = NULL;\n\t\t}\n\t}\n\tif (S_ISREG(inode->i_mode) && !fuse_is_bad(inode)) {\n\t\tWARN_ON(!list_empty(&fi->write_files));\n\t\tWARN_ON(!list_empty(&fi->queued_writes));\n\t}\n}\n\nstatic int fuse_reconfigure(struct fs_context *fsc)\n{\n\tstruct super_block *sb = fsc->root->d_sb;\n\n\tsync_filesystem(sb);\n\tif (fsc->sb_flags & SB_MANDLOCK)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic ino_t fuse_squash_ino(u64 ino64)\n{\n\tino_t ino = (ino_t) ino64;\n\tif (sizeof(ino_t) < sizeof(u64))\n\t\tino ^= ino64 >> (sizeof(u64) - sizeof(ino_t)) * 8;\n\treturn ino;\n}\n\nvoid fuse_change_attributes_common(struct inode *inode, struct fuse_attr *attr,\n\t\t\t\t   struct fuse_statx *sx,\n\t\t\t\t   u64 attr_valid, u32 cache_mask)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tlockdep_assert_held(&fi->lock);\n\n\tfi->attr_version = atomic64_inc_return(&fc->attr_version);\n\tfi->i_time = attr_valid;\n\t \n\tset_mask_bits(&fi->inval_mask, STATX_BASIC_STATS, 0);\n\n\tinode->i_ino     = fuse_squash_ino(attr->ino);\n\tinode->i_mode    = (inode->i_mode & S_IFMT) | (attr->mode & 07777);\n\tset_nlink(inode, attr->nlink);\n\tinode->i_uid     = make_kuid(fc->user_ns, attr->uid);\n\tinode->i_gid     = make_kgid(fc->user_ns, attr->gid);\n\tinode->i_blocks  = attr->blocks;\n\n\t \n\tattr->atimensec = min_t(u32, attr->atimensec, NSEC_PER_SEC - 1);\n\tattr->mtimensec = min_t(u32, attr->mtimensec, NSEC_PER_SEC - 1);\n\tattr->ctimensec = min_t(u32, attr->ctimensec, NSEC_PER_SEC - 1);\n\n\tinode->i_atime.tv_sec   = attr->atime;\n\tinode->i_atime.tv_nsec  = attr->atimensec;\n\t \n\tif (!(cache_mask & STATX_MTIME)) {\n\t\tinode->i_mtime.tv_sec   = attr->mtime;\n\t\tinode->i_mtime.tv_nsec  = attr->mtimensec;\n\t}\n\tif (!(cache_mask & STATX_CTIME)) {\n\t\tinode_set_ctime(inode, attr->ctime, attr->ctimensec);\n\t}\n\tif (sx) {\n\t\t \n\t\tsx->btime.tv_nsec =\n\t\t\tmin_t(u32, sx->btime.tv_nsec, NSEC_PER_SEC - 1);\n\n\t\t \n\t\tset_mask_bits(&fi->inval_mask, STATX_BTIME, 0);\n\t\tif (sx->mask & STATX_BTIME) {\n\t\t\tset_bit(FUSE_I_BTIME, &fi->state);\n\t\t\tfi->i_btime.tv_sec = sx->btime.tv_sec;\n\t\t\tfi->i_btime.tv_nsec = sx->btime.tv_nsec;\n\t\t}\n\t}\n\n\tif (attr->blksize != 0)\n\t\tinode->i_blkbits = ilog2(attr->blksize);\n\telse\n\t\tinode->i_blkbits = inode->i_sb->s_blocksize_bits;\n\n\t \n\tfi->orig_i_mode = inode->i_mode;\n\tif (!fc->default_permissions)\n\t\tinode->i_mode &= ~S_ISVTX;\n\n\tfi->orig_ino = attr->ino;\n\n\t \n\tinode->i_flags &= ~S_NOSEC;\n}\n\nu32 fuse_get_cache_mask(struct inode *inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fc->writeback_cache || !S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\treturn STATX_MTIME | STATX_CTIME | STATX_SIZE;\n}\n\nvoid fuse_change_attributes(struct inode *inode, struct fuse_attr *attr,\n\t\t\t    struct fuse_statx *sx,\n\t\t\t    u64 attr_valid, u64 attr_version)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tu32 cache_mask;\n\tloff_t oldsize;\n\tstruct timespec64 old_mtime;\n\n\tspin_lock(&fi->lock);\n\t \n\tcache_mask = fuse_get_cache_mask(inode);\n\tif (cache_mask & STATX_SIZE)\n\t\tattr->size = i_size_read(inode);\n\n\tif (cache_mask & STATX_MTIME) {\n\t\tattr->mtime = inode->i_mtime.tv_sec;\n\t\tattr->mtimensec = inode->i_mtime.tv_nsec;\n\t}\n\tif (cache_mask & STATX_CTIME) {\n\t\tattr->ctime = inode_get_ctime(inode).tv_sec;\n\t\tattr->ctimensec = inode_get_ctime(inode).tv_nsec;\n\t}\n\n\tif ((attr_version != 0 && fi->attr_version > attr_version) ||\n\t    test_bit(FUSE_I_SIZE_UNSTABLE, &fi->state)) {\n\t\tspin_unlock(&fi->lock);\n\t\treturn;\n\t}\n\n\told_mtime = inode->i_mtime;\n\tfuse_change_attributes_common(inode, attr, sx, attr_valid, cache_mask);\n\n\toldsize = inode->i_size;\n\t \n\tif (!(cache_mask & STATX_SIZE))\n\t\ti_size_write(inode, attr->size);\n\tspin_unlock(&fi->lock);\n\n\tif (!cache_mask && S_ISREG(inode->i_mode)) {\n\t\tbool inval = false;\n\n\t\tif (oldsize != attr->size) {\n\t\t\ttruncate_pagecache(inode, attr->size);\n\t\t\tif (!fc->explicit_inval_data)\n\t\t\t\tinval = true;\n\t\t} else if (fc->auto_inval_data) {\n\t\t\tstruct timespec64 new_mtime = {\n\t\t\t\t.tv_sec = attr->mtime,\n\t\t\t\t.tv_nsec = attr->mtimensec,\n\t\t\t};\n\n\t\t\t \n\t\t\tif (!timespec64_equal(&old_mtime, &new_mtime))\n\t\t\t\tinval = true;\n\t\t}\n\n\t\tif (inval)\n\t\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n\n\tif (IS_ENABLED(CONFIG_FUSE_DAX))\n\t\tfuse_dax_dontcache(inode, attr->flags);\n}\n\nstatic void fuse_init_submount_lookup(struct fuse_submount_lookup *sl,\n\t\t\t\t      u64 nodeid)\n{\n\tsl->nodeid = nodeid;\n\trefcount_set(&sl->count, 1);\n}\n\nstatic void fuse_init_inode(struct inode *inode, struct fuse_attr *attr,\n\t\t\t    struct fuse_conn *fc)\n{\n\tinode->i_mode = attr->mode & S_IFMT;\n\tinode->i_size = attr->size;\n\tinode->i_mtime.tv_sec  = attr->mtime;\n\tinode->i_mtime.tv_nsec = attr->mtimensec;\n\tinode_set_ctime(inode, attr->ctime, attr->ctimensec);\n\tif (S_ISREG(inode->i_mode)) {\n\t\tfuse_init_common(inode);\n\t\tfuse_init_file_inode(inode, attr->flags);\n\t} else if (S_ISDIR(inode->i_mode))\n\t\tfuse_init_dir(inode);\n\telse if (S_ISLNK(inode->i_mode))\n\t\tfuse_init_symlink(inode);\n\telse if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tfuse_init_common(inode);\n\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t   new_decode_dev(attr->rdev));\n\t} else\n\t\tBUG();\n\t \n\tif (!fc->posix_acl)\n\t\tinode->i_acl = inode->i_default_acl = ACL_DONT_CACHE;\n}\n\nstatic int fuse_inode_eq(struct inode *inode, void *_nodeidp)\n{\n\tu64 nodeid = *(u64 *) _nodeidp;\n\tif (get_node_id(inode) == nodeid)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int fuse_inode_set(struct inode *inode, void *_nodeidp)\n{\n\tu64 nodeid = *(u64 *) _nodeidp;\n\tget_fuse_inode(inode)->nodeid = nodeid;\n\treturn 0;\n}\n\nstruct inode *fuse_iget(struct super_block *sb, u64 nodeid,\n\t\t\tint generation, struct fuse_attr *attr,\n\t\t\tu64 attr_valid, u64 attr_version)\n{\n\tstruct inode *inode;\n\tstruct fuse_inode *fi;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n\t \n\tif (fc->auto_submounts && (attr->flags & FUSE_ATTR_SUBMOUNT) &&\n\t    S_ISDIR(attr->mode)) {\n\t\tstruct fuse_inode *fi;\n\n\t\tinode = new_inode(sb);\n\t\tif (!inode)\n\t\t\treturn NULL;\n\n\t\tfuse_init_inode(inode, attr, fc);\n\t\tfi = get_fuse_inode(inode);\n\t\tfi->nodeid = nodeid;\n\t\tfi->submount_lookup = fuse_alloc_submount_lookup();\n\t\tif (!fi->submount_lookup) {\n\t\t\tiput(inode);\n\t\t\treturn NULL;\n\t\t}\n\t\t \n\t\tfuse_init_submount_lookup(fi->submount_lookup, nodeid);\n\t\tinode->i_flags |= S_AUTOMOUNT;\n\t\tgoto done;\n\t}\n\nretry:\n\tinode = iget5_locked(sb, nodeid, fuse_inode_eq, fuse_inode_set, &nodeid);\n\tif (!inode)\n\t\treturn NULL;\n\n\tif ((inode->i_state & I_NEW)) {\n\t\tinode->i_flags |= S_NOATIME;\n\t\tif (!fc->writeback_cache || !S_ISREG(attr->mode))\n\t\t\tinode->i_flags |= S_NOCMTIME;\n\t\tinode->i_generation = generation;\n\t\tfuse_init_inode(inode, attr, fc);\n\t\tunlock_new_inode(inode);\n\t} else if (fuse_stale_inode(inode, generation, attr)) {\n\t\t \n\t\tfuse_make_bad(inode);\n\t\tiput(inode);\n\t\tgoto retry;\n\t}\n\tfi = get_fuse_inode(inode);\n\tspin_lock(&fi->lock);\n\tfi->nlookup++;\n\tspin_unlock(&fi->lock);\ndone:\n\tfuse_change_attributes(inode, attr, NULL, attr_valid, attr_version);\n\n\treturn inode;\n}\n\nstruct inode *fuse_ilookup(struct fuse_conn *fc, u64 nodeid,\n\t\t\t   struct fuse_mount **fm)\n{\n\tstruct fuse_mount *fm_iter;\n\tstruct inode *inode;\n\n\tWARN_ON(!rwsem_is_locked(&fc->killsb));\n\tlist_for_each_entry(fm_iter, &fc->mounts, fc_entry) {\n\t\tif (!fm_iter->sb)\n\t\t\tcontinue;\n\n\t\tinode = ilookup5(fm_iter->sb, nodeid, fuse_inode_eq, &nodeid);\n\t\tif (inode) {\n\t\t\tif (fm)\n\t\t\t\t*fm = fm_iter;\n\t\t\treturn inode;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nint fuse_reverse_inval_inode(struct fuse_conn *fc, u64 nodeid,\n\t\t\t     loff_t offset, loff_t len)\n{\n\tstruct fuse_inode *fi;\n\tstruct inode *inode;\n\tpgoff_t pg_start;\n\tpgoff_t pg_end;\n\n\tinode = fuse_ilookup(fc, nodeid, NULL);\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tfi = get_fuse_inode(inode);\n\tspin_lock(&fi->lock);\n\tfi->attr_version = atomic64_inc_return(&fc->attr_version);\n\tspin_unlock(&fi->lock);\n\n\tfuse_invalidate_attr(inode);\n\tforget_all_cached_acls(inode);\n\tif (offset >= 0) {\n\t\tpg_start = offset >> PAGE_SHIFT;\n\t\tif (len <= 0)\n\t\t\tpg_end = -1;\n\t\telse\n\t\t\tpg_end = (offset + len - 1) >> PAGE_SHIFT;\n\t\tinvalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t      pg_start, pg_end);\n\t}\n\tiput(inode);\n\treturn 0;\n}\n\nbool fuse_lock_inode(struct inode *inode)\n{\n\tbool locked = false;\n\n\tif (!get_fuse_conn(inode)->parallel_dirops) {\n\t\tmutex_lock(&get_fuse_inode(inode)->mutex);\n\t\tlocked = true;\n\t}\n\n\treturn locked;\n}\n\nvoid fuse_unlock_inode(struct inode *inode, bool locked)\n{\n\tif (locked)\n\t\tmutex_unlock(&get_fuse_inode(inode)->mutex);\n}\n\nstatic void fuse_umount_begin(struct super_block *sb)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n\tif (fc->no_force_umount)\n\t\treturn;\n\n\tfuse_abort_conn(fc);\n\n\t \n\tif (sb->s_bdev != NULL)\n\t\tretire_super(sb);\n}\n\nstatic void fuse_send_destroy(struct fuse_mount *fm)\n{\n\tif (fm->fc->conn_init) {\n\t\tFUSE_ARGS(args);\n\n\t\targs.opcode = FUSE_DESTROY;\n\t\targs.force = true;\n\t\targs.nocreds = true;\n\t\tfuse_simple_request(fm, &args);\n\t}\n}\n\nstatic void convert_fuse_statfs(struct kstatfs *stbuf, struct fuse_kstatfs *attr)\n{\n\tstbuf->f_type    = FUSE_SUPER_MAGIC;\n\tstbuf->f_bsize   = attr->bsize;\n\tstbuf->f_frsize  = attr->frsize;\n\tstbuf->f_blocks  = attr->blocks;\n\tstbuf->f_bfree   = attr->bfree;\n\tstbuf->f_bavail  = attr->bavail;\n\tstbuf->f_files   = attr->files;\n\tstbuf->f_ffree   = attr->ffree;\n\tstbuf->f_namelen = attr->namelen;\n\t \n}\n\nstatic int fuse_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct fuse_mount *fm = get_fuse_mount_super(sb);\n\tFUSE_ARGS(args);\n\tstruct fuse_statfs_out outarg;\n\tint err;\n\n\tif (!fuse_allow_current_process(fm->fc)) {\n\t\tbuf->f_type = FUSE_SUPER_MAGIC;\n\t\treturn 0;\n\t}\n\n\tmemset(&outarg, 0, sizeof(outarg));\n\targs.in_numargs = 0;\n\targs.opcode = FUSE_STATFS;\n\targs.nodeid = get_node_id(d_inode(dentry));\n\targs.out_numargs = 1;\n\targs.out_args[0].size = sizeof(outarg);\n\targs.out_args[0].value = &outarg;\n\terr = fuse_simple_request(fm, &args);\n\tif (!err)\n\t\tconvert_fuse_statfs(buf, &outarg.st);\n\treturn err;\n}\n\nstatic struct fuse_sync_bucket *fuse_sync_bucket_alloc(void)\n{\n\tstruct fuse_sync_bucket *bucket;\n\n\tbucket = kzalloc(sizeof(*bucket), GFP_KERNEL | __GFP_NOFAIL);\n\tif (bucket) {\n\t\tinit_waitqueue_head(&bucket->waitq);\n\t\t \n\t\tatomic_set(&bucket->count, 1);\n\t}\n\treturn bucket;\n}\n\nstatic void fuse_sync_fs_writes(struct fuse_conn *fc)\n{\n\tstruct fuse_sync_bucket *bucket, *new_bucket;\n\tint count;\n\n\tnew_bucket = fuse_sync_bucket_alloc();\n\tspin_lock(&fc->lock);\n\tbucket = rcu_dereference_protected(fc->curr_bucket, 1);\n\tcount = atomic_read(&bucket->count);\n\tWARN_ON(count < 1);\n\t \n\tif (count == 1) {\n\t\tspin_unlock(&fc->lock);\n\t\tkfree(new_bucket);\n\t\treturn;\n\t}\n\n\t \n\tatomic_inc(&new_bucket->count);\n\trcu_assign_pointer(fc->curr_bucket, new_bucket);\n\tspin_unlock(&fc->lock);\n\t \n\tatomic_dec(&bucket->count);\n\n\twait_event(bucket->waitq, atomic_read(&bucket->count) == 0);\n\n\t \n\tfuse_sync_bucket_dec(new_bucket);\n\tkfree_rcu(bucket, rcu);\n}\n\nstatic int fuse_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct fuse_mount *fm = get_fuse_mount_super(sb);\n\tstruct fuse_conn *fc = fm->fc;\n\tstruct fuse_syncfs_in inarg;\n\tFUSE_ARGS(args);\n\tint err;\n\n\t \n\tif (!wait)\n\t\treturn 0;\n\n\t \n\tif (!sb->s_root)\n\t\treturn 0;\n\n\tif (!fc->sync_fs)\n\t\treturn 0;\n\n\tfuse_sync_fs_writes(fc);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.opcode = FUSE_SYNCFS;\n\targs.nodeid = get_node_id(sb->s_root->d_inode);\n\targs.out_numargs = 0;\n\n\terr = fuse_simple_request(fm, &args);\n\tif (err == -ENOSYS) {\n\t\tfc->sync_fs = 0;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}\n\nenum {\n\tOPT_SOURCE,\n\tOPT_SUBTYPE,\n\tOPT_FD,\n\tOPT_ROOTMODE,\n\tOPT_USER_ID,\n\tOPT_GROUP_ID,\n\tOPT_DEFAULT_PERMISSIONS,\n\tOPT_ALLOW_OTHER,\n\tOPT_MAX_READ,\n\tOPT_BLKSIZE,\n\tOPT_ERR\n};\n\nstatic const struct fs_parameter_spec fuse_fs_parameters[] = {\n\tfsparam_string\t(\"source\",\t\tOPT_SOURCE),\n\tfsparam_u32\t(\"fd\",\t\t\tOPT_FD),\n\tfsparam_u32oct\t(\"rootmode\",\t\tOPT_ROOTMODE),\n\tfsparam_u32\t(\"user_id\",\t\tOPT_USER_ID),\n\tfsparam_u32\t(\"group_id\",\t\tOPT_GROUP_ID),\n\tfsparam_flag\t(\"default_permissions\",\tOPT_DEFAULT_PERMISSIONS),\n\tfsparam_flag\t(\"allow_other\",\t\tOPT_ALLOW_OTHER),\n\tfsparam_u32\t(\"max_read\",\t\tOPT_MAX_READ),\n\tfsparam_u32\t(\"blksize\",\t\tOPT_BLKSIZE),\n\tfsparam_string\t(\"subtype\",\t\tOPT_SUBTYPE),\n\t{}\n};\n\nstatic int fuse_parse_param(struct fs_context *fsc, struct fs_parameter *param)\n{\n\tstruct fs_parse_result result;\n\tstruct fuse_fs_context *ctx = fsc->fs_private;\n\tint opt;\n\n\tif (fsc->purpose == FS_CONTEXT_FOR_RECONFIGURE) {\n\t\t \n\t\tif (fsc->oldapi)\n\t\t\treturn 0;\n\n\t\treturn invalfc(fsc, \"No changes allowed in reconfigure\");\n\t}\n\n\topt = fs_parse(fsc, fuse_fs_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase OPT_SOURCE:\n\t\tif (fsc->source)\n\t\t\treturn invalfc(fsc, \"Multiple sources specified\");\n\t\tfsc->source = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\n\tcase OPT_SUBTYPE:\n\t\tif (ctx->subtype)\n\t\t\treturn invalfc(fsc, \"Multiple subtypes specified\");\n\t\tctx->subtype = param->string;\n\t\tparam->string = NULL;\n\t\treturn 0;\n\n\tcase OPT_FD:\n\t\tctx->fd = result.uint_32;\n\t\tctx->fd_present = true;\n\t\tbreak;\n\n\tcase OPT_ROOTMODE:\n\t\tif (!fuse_valid_type(result.uint_32))\n\t\t\treturn invalfc(fsc, \"Invalid rootmode\");\n\t\tctx->rootmode = result.uint_32;\n\t\tctx->rootmode_present = true;\n\t\tbreak;\n\n\tcase OPT_USER_ID:\n\t\tctx->user_id = make_kuid(fsc->user_ns, result.uint_32);\n\t\tif (!uid_valid(ctx->user_id))\n\t\t\treturn invalfc(fsc, \"Invalid user_id\");\n\t\tctx->user_id_present = true;\n\t\tbreak;\n\n\tcase OPT_GROUP_ID:\n\t\tctx->group_id = make_kgid(fsc->user_ns, result.uint_32);\n\t\tif (!gid_valid(ctx->group_id))\n\t\t\treturn invalfc(fsc, \"Invalid group_id\");\n\t\tctx->group_id_present = true;\n\t\tbreak;\n\n\tcase OPT_DEFAULT_PERMISSIONS:\n\t\tctx->default_permissions = true;\n\t\tbreak;\n\n\tcase OPT_ALLOW_OTHER:\n\t\tctx->allow_other = true;\n\t\tbreak;\n\n\tcase OPT_MAX_READ:\n\t\tctx->max_read = result.uint_32;\n\t\tbreak;\n\n\tcase OPT_BLKSIZE:\n\t\tif (!ctx->is_bdev)\n\t\t\treturn invalfc(fsc, \"blksize only supported for fuseblk\");\n\t\tctx->blksize = result.uint_32;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void fuse_free_fsc(struct fs_context *fsc)\n{\n\tstruct fuse_fs_context *ctx = fsc->fs_private;\n\n\tif (ctx) {\n\t\tkfree(ctx->subtype);\n\t\tkfree(ctx);\n\t}\n}\n\nstatic int fuse_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n\tif (fc->legacy_opts_show) {\n\t\tseq_printf(m, \",user_id=%u\",\n\t\t\t   from_kuid_munged(fc->user_ns, fc->user_id));\n\t\tseq_printf(m, \",group_id=%u\",\n\t\t\t   from_kgid_munged(fc->user_ns, fc->group_id));\n\t\tif (fc->default_permissions)\n\t\t\tseq_puts(m, \",default_permissions\");\n\t\tif (fc->allow_other)\n\t\t\tseq_puts(m, \",allow_other\");\n\t\tif (fc->max_read != ~0)\n\t\t\tseq_printf(m, \",max_read=%u\", fc->max_read);\n\t\tif (sb->s_bdev && sb->s_blocksize != FUSE_DEFAULT_BLKSIZE)\n\t\t\tseq_printf(m, \",blksize=%lu\", sb->s_blocksize);\n\t}\n#ifdef CONFIG_FUSE_DAX\n\tif (fc->dax_mode == FUSE_DAX_ALWAYS)\n\t\tseq_puts(m, \",dax=always\");\n\telse if (fc->dax_mode == FUSE_DAX_NEVER)\n\t\tseq_puts(m, \",dax=never\");\n\telse if (fc->dax_mode == FUSE_DAX_INODE_USER)\n\t\tseq_puts(m, \",dax=inode\");\n#endif\n\n\treturn 0;\n}\n\nstatic void fuse_iqueue_init(struct fuse_iqueue *fiq,\n\t\t\t     const struct fuse_iqueue_ops *ops,\n\t\t\t     void *priv)\n{\n\tmemset(fiq, 0, sizeof(struct fuse_iqueue));\n\tspin_lock_init(&fiq->lock);\n\tinit_waitqueue_head(&fiq->waitq);\n\tINIT_LIST_HEAD(&fiq->pending);\n\tINIT_LIST_HEAD(&fiq->interrupts);\n\tfiq->forget_list_tail = &fiq->forget_list_head;\n\tfiq->connected = 1;\n\tfiq->ops = ops;\n\tfiq->priv = priv;\n}\n\nstatic void fuse_pqueue_init(struct fuse_pqueue *fpq)\n{\n\tunsigned int i;\n\n\tspin_lock_init(&fpq->lock);\n\tfor (i = 0; i < FUSE_PQ_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&fpq->processing[i]);\n\tINIT_LIST_HEAD(&fpq->io);\n\tfpq->connected = 1;\n}\n\nvoid fuse_conn_init(struct fuse_conn *fc, struct fuse_mount *fm,\n\t\t    struct user_namespace *user_ns,\n\t\t    const struct fuse_iqueue_ops *fiq_ops, void *fiq_priv)\n{\n\tmemset(fc, 0, sizeof(*fc));\n\tspin_lock_init(&fc->lock);\n\tspin_lock_init(&fc->bg_lock);\n\tinit_rwsem(&fc->killsb);\n\trefcount_set(&fc->count, 1);\n\tatomic_set(&fc->dev_count, 1);\n\tinit_waitqueue_head(&fc->blocked_waitq);\n\tfuse_iqueue_init(&fc->iq, fiq_ops, fiq_priv);\n\tINIT_LIST_HEAD(&fc->bg_queue);\n\tINIT_LIST_HEAD(&fc->entry);\n\tINIT_LIST_HEAD(&fc->devices);\n\tatomic_set(&fc->num_waiting, 0);\n\tfc->max_background = FUSE_DEFAULT_MAX_BACKGROUND;\n\tfc->congestion_threshold = FUSE_DEFAULT_CONGESTION_THRESHOLD;\n\tatomic64_set(&fc->khctr, 0);\n\tfc->polled_files = RB_ROOT;\n\tfc->blocked = 0;\n\tfc->initialized = 0;\n\tfc->connected = 1;\n\tatomic64_set(&fc->attr_version, 1);\n\tget_random_bytes(&fc->scramble_key, sizeof(fc->scramble_key));\n\tfc->pid_ns = get_pid_ns(task_active_pid_ns(current));\n\tfc->user_ns = get_user_ns(user_ns);\n\tfc->max_pages = FUSE_DEFAULT_MAX_PAGES_PER_REQ;\n\tfc->max_pages_limit = FUSE_MAX_MAX_PAGES;\n\n\tINIT_LIST_HEAD(&fc->mounts);\n\tlist_add(&fm->fc_entry, &fc->mounts);\n\tfm->fc = fc;\n}\nEXPORT_SYMBOL_GPL(fuse_conn_init);\n\nvoid fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (refcount_dec_and_test(&fc->count)) {\n\t\tstruct fuse_iqueue *fiq = &fc->iq;\n\t\tstruct fuse_sync_bucket *bucket;\n\n\t\tif (IS_ENABLED(CONFIG_FUSE_DAX))\n\t\t\tfuse_dax_conn_free(fc);\n\t\tif (fiq->ops->release)\n\t\t\tfiq->ops->release(fiq);\n\t\tput_pid_ns(fc->pid_ns);\n\t\tput_user_ns(fc->user_ns);\n\t\tbucket = rcu_dereference_protected(fc->curr_bucket, 1);\n\t\tif (bucket) {\n\t\t\tWARN_ON(atomic_read(&bucket->count) != 1);\n\t\t\tkfree(bucket);\n\t\t}\n\t\tfc->release(fc);\n\t}\n}\nEXPORT_SYMBOL_GPL(fuse_conn_put);\n\nstruct fuse_conn *fuse_conn_get(struct fuse_conn *fc)\n{\n\trefcount_inc(&fc->count);\n\treturn fc;\n}\nEXPORT_SYMBOL_GPL(fuse_conn_get);\n\nstatic struct inode *fuse_get_root_inode(struct super_block *sb, unsigned mode)\n{\n\tstruct fuse_attr attr;\n\tmemset(&attr, 0, sizeof(attr));\n\n\tattr.mode = mode;\n\tattr.ino = FUSE_ROOT_ID;\n\tattr.nlink = 1;\n\treturn fuse_iget(sb, 1, 0, &attr, 0, 0);\n}\n\nstruct fuse_inode_handle {\n\tu64 nodeid;\n\tu32 generation;\n};\n\nstatic struct dentry *fuse_get_dentry(struct super_block *sb,\n\t\t\t\t      struct fuse_inode_handle *handle)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\tstruct inode *inode;\n\tstruct dentry *entry;\n\tint err = -ESTALE;\n\n\tif (handle->nodeid == 0)\n\t\tgoto out_err;\n\n\tinode = ilookup5(sb, handle->nodeid, fuse_inode_eq, &handle->nodeid);\n\tif (!inode) {\n\t\tstruct fuse_entry_out outarg;\n\t\tconst struct qstr name = QSTR_INIT(\".\", 1);\n\n\t\tif (!fc->export_support)\n\t\t\tgoto out_err;\n\n\t\terr = fuse_lookup_name(sb, handle->nodeid, &name, &outarg,\n\t\t\t\t       &inode);\n\t\tif (err && err != -ENOENT)\n\t\t\tgoto out_err;\n\t\tif (err || !inode) {\n\t\t\terr = -ESTALE;\n\t\t\tgoto out_err;\n\t\t}\n\t\terr = -EIO;\n\t\tif (get_node_id(inode) != handle->nodeid)\n\t\t\tgoto out_iput;\n\t}\n\terr = -ESTALE;\n\tif (inode->i_generation != handle->generation)\n\t\tgoto out_iput;\n\n\tentry = d_obtain_alias(inode);\n\tif (!IS_ERR(entry) && get_node_id(inode) != FUSE_ROOT_ID)\n\t\tfuse_invalidate_entry_cache(entry);\n\n\treturn entry;\n\n out_iput:\n\tiput(inode);\n out_err:\n\treturn ERR_PTR(err);\n}\n\nstatic int fuse_encode_fh(struct inode *inode, u32 *fh, int *max_len,\n\t\t\t   struct inode *parent)\n{\n\tint len = parent ? 6 : 3;\n\tu64 nodeid;\n\tu32 generation;\n\n\tif (*max_len < len) {\n\t\t*max_len = len;\n\t\treturn  FILEID_INVALID;\n\t}\n\n\tnodeid = get_fuse_inode(inode)->nodeid;\n\tgeneration = inode->i_generation;\n\n\tfh[0] = (u32)(nodeid >> 32);\n\tfh[1] = (u32)(nodeid & 0xffffffff);\n\tfh[2] = generation;\n\n\tif (parent) {\n\t\tnodeid = get_fuse_inode(parent)->nodeid;\n\t\tgeneration = parent->i_generation;\n\n\t\tfh[3] = (u32)(nodeid >> 32);\n\t\tfh[4] = (u32)(nodeid & 0xffffffff);\n\t\tfh[5] = generation;\n\t}\n\n\t*max_len = len;\n\treturn parent ? 0x82 : 0x81;\n}\n\nstatic struct dentry *fuse_fh_to_dentry(struct super_block *sb,\n\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\tstruct fuse_inode_handle handle;\n\n\tif ((fh_type != 0x81 && fh_type != 0x82) || fh_len < 3)\n\t\treturn NULL;\n\n\thandle.nodeid = (u64) fid->raw[0] << 32;\n\thandle.nodeid |= (u64) fid->raw[1];\n\thandle.generation = fid->raw[2];\n\treturn fuse_get_dentry(sb, &handle);\n}\n\nstatic struct dentry *fuse_fh_to_parent(struct super_block *sb,\n\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\tstruct fuse_inode_handle parent;\n\n\tif (fh_type != 0x82 || fh_len < 6)\n\t\treturn NULL;\n\n\tparent.nodeid = (u64) fid->raw[3] << 32;\n\tparent.nodeid |= (u64) fid->raw[4];\n\tparent.generation = fid->raw[5];\n\treturn fuse_get_dentry(sb, &parent);\n}\n\nstatic struct dentry *fuse_get_parent(struct dentry *child)\n{\n\tstruct inode *child_inode = d_inode(child);\n\tstruct fuse_conn *fc = get_fuse_conn(child_inode);\n\tstruct inode *inode;\n\tstruct dentry *parent;\n\tstruct fuse_entry_out outarg;\n\tint err;\n\n\tif (!fc->export_support)\n\t\treturn ERR_PTR(-ESTALE);\n\n\terr = fuse_lookup_name(child_inode->i_sb, get_node_id(child_inode),\n\t\t\t       &dotdot_name, &outarg, &inode);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\treturn ERR_PTR(-ESTALE);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tparent = d_obtain_alias(inode);\n\tif (!IS_ERR(parent) && get_node_id(inode) != FUSE_ROOT_ID)\n\t\tfuse_invalidate_entry_cache(parent);\n\n\treturn parent;\n}\n\nstatic const struct export_operations fuse_export_operations = {\n\t.fh_to_dentry\t= fuse_fh_to_dentry,\n\t.fh_to_parent\t= fuse_fh_to_parent,\n\t.encode_fh\t= fuse_encode_fh,\n\t.get_parent\t= fuse_get_parent,\n};\n\nstatic const struct super_operations fuse_super_operations = {\n\t.alloc_inode    = fuse_alloc_inode,\n\t.free_inode     = fuse_free_inode,\n\t.evict_inode\t= fuse_evict_inode,\n\t.write_inode\t= fuse_write_inode,\n\t.drop_inode\t= generic_delete_inode,\n\t.umount_begin\t= fuse_umount_begin,\n\t.statfs\t\t= fuse_statfs,\n\t.sync_fs\t= fuse_sync_fs,\n\t.show_options\t= fuse_show_options,\n};\n\nstatic void sanitize_global_limit(unsigned *limit)\n{\n\t \n\tif (*limit == 0)\n\t\t*limit = ((totalram_pages() << PAGE_SHIFT) >> 13) / 392;\n\n\tif (*limit >= 1 << 16)\n\t\t*limit = (1 << 16) - 1;\n}\n\nstatic int set_global_limit(const char *val, const struct kernel_param *kp)\n{\n\tint rv;\n\n\trv = param_set_uint(val, kp);\n\tif (rv)\n\t\treturn rv;\n\n\tsanitize_global_limit((unsigned *)kp->arg);\n\n\treturn 0;\n}\n\nstatic void process_init_limits(struct fuse_conn *fc, struct fuse_init_out *arg)\n{\n\tint cap_sys_admin = capable(CAP_SYS_ADMIN);\n\n\tif (arg->minor < 13)\n\t\treturn;\n\n\tsanitize_global_limit(&max_user_bgreq);\n\tsanitize_global_limit(&max_user_congthresh);\n\n\tspin_lock(&fc->bg_lock);\n\tif (arg->max_background) {\n\t\tfc->max_background = arg->max_background;\n\n\t\tif (!cap_sys_admin && fc->max_background > max_user_bgreq)\n\t\t\tfc->max_background = max_user_bgreq;\n\t}\n\tif (arg->congestion_threshold) {\n\t\tfc->congestion_threshold = arg->congestion_threshold;\n\n\t\tif (!cap_sys_admin &&\n\t\t    fc->congestion_threshold > max_user_congthresh)\n\t\t\tfc->congestion_threshold = max_user_congthresh;\n\t}\n\tspin_unlock(&fc->bg_lock);\n}\n\nstruct fuse_init_args {\n\tstruct fuse_args args;\n\tstruct fuse_init_in in;\n\tstruct fuse_init_out out;\n};\n\nstatic void process_init_reply(struct fuse_mount *fm, struct fuse_args *args,\n\t\t\t       int error)\n{\n\tstruct fuse_conn *fc = fm->fc;\n\tstruct fuse_init_args *ia = container_of(args, typeof(*ia), args);\n\tstruct fuse_init_out *arg = &ia->out;\n\tbool ok = true;\n\n\tif (error || arg->major != FUSE_KERNEL_VERSION)\n\t\tok = false;\n\telse {\n\t\tunsigned long ra_pages;\n\n\t\tprocess_init_limits(fc, arg);\n\n\t\tif (arg->minor >= 6) {\n\t\t\tu64 flags = arg->flags;\n\n\t\t\tif (flags & FUSE_INIT_EXT)\n\t\t\t\tflags |= (u64) arg->flags2 << 32;\n\n\t\t\tra_pages = arg->max_readahead / PAGE_SIZE;\n\t\t\tif (flags & FUSE_ASYNC_READ)\n\t\t\t\tfc->async_read = 1;\n\t\t\tif (!(flags & FUSE_POSIX_LOCKS))\n\t\t\t\tfc->no_lock = 1;\n\t\t\tif (arg->minor >= 17) {\n\t\t\t\tif (!(flags & FUSE_FLOCK_LOCKS))\n\t\t\t\t\tfc->no_flock = 1;\n\t\t\t} else {\n\t\t\t\tif (!(flags & FUSE_POSIX_LOCKS))\n\t\t\t\t\tfc->no_flock = 1;\n\t\t\t}\n\t\t\tif (flags & FUSE_ATOMIC_O_TRUNC)\n\t\t\t\tfc->atomic_o_trunc = 1;\n\t\t\tif (arg->minor >= 9) {\n\t\t\t\t \n\t\t\t\tif (flags & FUSE_EXPORT_SUPPORT)\n\t\t\t\t\tfc->export_support = 1;\n\t\t\t}\n\t\t\tif (flags & FUSE_BIG_WRITES)\n\t\t\t\tfc->big_writes = 1;\n\t\t\tif (flags & FUSE_DONT_MASK)\n\t\t\t\tfc->dont_mask = 1;\n\t\t\tif (flags & FUSE_AUTO_INVAL_DATA)\n\t\t\t\tfc->auto_inval_data = 1;\n\t\t\telse if (flags & FUSE_EXPLICIT_INVAL_DATA)\n\t\t\t\tfc->explicit_inval_data = 1;\n\t\t\tif (flags & FUSE_DO_READDIRPLUS) {\n\t\t\t\tfc->do_readdirplus = 1;\n\t\t\t\tif (flags & FUSE_READDIRPLUS_AUTO)\n\t\t\t\t\tfc->readdirplus_auto = 1;\n\t\t\t}\n\t\t\tif (flags & FUSE_ASYNC_DIO)\n\t\t\t\tfc->async_dio = 1;\n\t\t\tif (flags & FUSE_WRITEBACK_CACHE)\n\t\t\t\tfc->writeback_cache = 1;\n\t\t\tif (flags & FUSE_PARALLEL_DIROPS)\n\t\t\t\tfc->parallel_dirops = 1;\n\t\t\tif (flags & FUSE_HANDLE_KILLPRIV)\n\t\t\t\tfc->handle_killpriv = 1;\n\t\t\tif (arg->time_gran && arg->time_gran <= 1000000000)\n\t\t\t\tfm->sb->s_time_gran = arg->time_gran;\n\t\t\tif ((flags & FUSE_POSIX_ACL)) {\n\t\t\t\tfc->default_permissions = 1;\n\t\t\t\tfc->posix_acl = 1;\n\t\t\t}\n\t\t\tif (flags & FUSE_CACHE_SYMLINKS)\n\t\t\t\tfc->cache_symlinks = 1;\n\t\t\tif (flags & FUSE_ABORT_ERROR)\n\t\t\t\tfc->abort_err = 1;\n\t\t\tif (flags & FUSE_MAX_PAGES) {\n\t\t\t\tfc->max_pages =\n\t\t\t\t\tmin_t(unsigned int, fc->max_pages_limit,\n\t\t\t\t\tmax_t(unsigned int, arg->max_pages, 1));\n\t\t\t}\n\t\t\tif (IS_ENABLED(CONFIG_FUSE_DAX)) {\n\t\t\t\tif (flags & FUSE_MAP_ALIGNMENT &&\n\t\t\t\t    !fuse_dax_check_alignment(fc, arg->map_alignment)) {\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\tif (flags & FUSE_HAS_INODE_DAX)\n\t\t\t\t\tfc->inode_dax = 1;\n\t\t\t}\n\t\t\tif (flags & FUSE_HANDLE_KILLPRIV_V2) {\n\t\t\t\tfc->handle_killpriv_v2 = 1;\n\t\t\t\tfm->sb->s_flags |= SB_NOSEC;\n\t\t\t}\n\t\t\tif (flags & FUSE_SETXATTR_EXT)\n\t\t\t\tfc->setxattr_ext = 1;\n\t\t\tif (flags & FUSE_SECURITY_CTX)\n\t\t\t\tfc->init_security = 1;\n\t\t\tif (flags & FUSE_CREATE_SUPP_GROUP)\n\t\t\t\tfc->create_supp_group = 1;\n\t\t\tif (flags & FUSE_DIRECT_IO_ALLOW_MMAP)\n\t\t\t\tfc->direct_io_allow_mmap = 1;\n\t\t} else {\n\t\t\tra_pages = fc->max_read / PAGE_SIZE;\n\t\t\tfc->no_lock = 1;\n\t\t\tfc->no_flock = 1;\n\t\t}\n\n\t\tfm->sb->s_bdi->ra_pages =\n\t\t\t\tmin(fm->sb->s_bdi->ra_pages, ra_pages);\n\t\tfc->minor = arg->minor;\n\t\tfc->max_write = arg->minor < 5 ? 4096 : arg->max_write;\n\t\tfc->max_write = max_t(unsigned, 4096, fc->max_write);\n\t\tfc->conn_init = 1;\n\t}\n\tkfree(ia);\n\n\tif (!ok) {\n\t\tfc->conn_init = 0;\n\t\tfc->conn_error = 1;\n\t}\n\n\tfuse_set_initialized(fc);\n\twake_up_all(&fc->blocked_waitq);\n}\n\nvoid fuse_send_init(struct fuse_mount *fm)\n{\n\tstruct fuse_init_args *ia;\n\tu64 flags;\n\n\tia = kzalloc(sizeof(*ia), GFP_KERNEL | __GFP_NOFAIL);\n\n\tia->in.major = FUSE_KERNEL_VERSION;\n\tia->in.minor = FUSE_KERNEL_MINOR_VERSION;\n\tia->in.max_readahead = fm->sb->s_bdi->ra_pages * PAGE_SIZE;\n\tflags =\n\t\tFUSE_ASYNC_READ | FUSE_POSIX_LOCKS | FUSE_ATOMIC_O_TRUNC |\n\t\tFUSE_EXPORT_SUPPORT | FUSE_BIG_WRITES | FUSE_DONT_MASK |\n\t\tFUSE_SPLICE_WRITE | FUSE_SPLICE_MOVE | FUSE_SPLICE_READ |\n\t\tFUSE_FLOCK_LOCKS | FUSE_HAS_IOCTL_DIR | FUSE_AUTO_INVAL_DATA |\n\t\tFUSE_DO_READDIRPLUS | FUSE_READDIRPLUS_AUTO | FUSE_ASYNC_DIO |\n\t\tFUSE_WRITEBACK_CACHE | FUSE_NO_OPEN_SUPPORT |\n\t\tFUSE_PARALLEL_DIROPS | FUSE_HANDLE_KILLPRIV | FUSE_POSIX_ACL |\n\t\tFUSE_ABORT_ERROR | FUSE_MAX_PAGES | FUSE_CACHE_SYMLINKS |\n\t\tFUSE_NO_OPENDIR_SUPPORT | FUSE_EXPLICIT_INVAL_DATA |\n\t\tFUSE_HANDLE_KILLPRIV_V2 | FUSE_SETXATTR_EXT | FUSE_INIT_EXT |\n\t\tFUSE_SECURITY_CTX | FUSE_CREATE_SUPP_GROUP |\n\t\tFUSE_HAS_EXPIRE_ONLY | FUSE_DIRECT_IO_ALLOW_MMAP;\n#ifdef CONFIG_FUSE_DAX\n\tif (fm->fc->dax)\n\t\tflags |= FUSE_MAP_ALIGNMENT;\n\tif (fuse_is_inode_dax_mode(fm->fc->dax_mode))\n\t\tflags |= FUSE_HAS_INODE_DAX;\n#endif\n\tif (fm->fc->auto_submounts)\n\t\tflags |= FUSE_SUBMOUNTS;\n\n\tia->in.flags = flags;\n\tia->in.flags2 = flags >> 32;\n\n\tia->args.opcode = FUSE_INIT;\n\tia->args.in_numargs = 1;\n\tia->args.in_args[0].size = sizeof(ia->in);\n\tia->args.in_args[0].value = &ia->in;\n\tia->args.out_numargs = 1;\n\t \n\tia->args.out_argvar = true;\n\tia->args.out_args[0].size = sizeof(ia->out);\n\tia->args.out_args[0].value = &ia->out;\n\tia->args.force = true;\n\tia->args.nocreds = true;\n\tia->args.end = process_init_reply;\n\n\tif (fuse_simple_background(fm, &ia->args, GFP_KERNEL) != 0)\n\t\tprocess_init_reply(fm, &ia->args, -ENOTCONN);\n}\nEXPORT_SYMBOL_GPL(fuse_send_init);\n\nvoid fuse_free_conn(struct fuse_conn *fc)\n{\n\tWARN_ON(!list_empty(&fc->devices));\n\tkfree_rcu(fc, rcu);\n}\nEXPORT_SYMBOL_GPL(fuse_free_conn);\n\nstatic int fuse_bdi_init(struct fuse_conn *fc, struct super_block *sb)\n{\n\tint err;\n\tchar *suffix = \"\";\n\n\tif (sb->s_bdev) {\n\t\tsuffix = \"-fuseblk\";\n\t\t \n\t\tbdi_put(sb->s_bdi);\n\t\tsb->s_bdi = &noop_backing_dev_info;\n\t}\n\terr = super_setup_bdi_name(sb, \"%u:%u%s\", MAJOR(fc->dev),\n\t\t\t\t   MINOR(fc->dev), suffix);\n\tif (err)\n\t\treturn err;\n\n\t \n\tsb->s_bdi->capabilities &= ~BDI_CAP_WRITEBACK_ACCT;\n\tsb->s_bdi->capabilities |= BDI_CAP_STRICTLIMIT;\n\n\t \n\tbdi_set_max_ratio(sb->s_bdi, 1);\n\n\treturn 0;\n}\n\nstruct fuse_dev *fuse_dev_alloc(void)\n{\n\tstruct fuse_dev *fud;\n\tstruct list_head *pq;\n\n\tfud = kzalloc(sizeof(struct fuse_dev), GFP_KERNEL);\n\tif (!fud)\n\t\treturn NULL;\n\n\tpq = kcalloc(FUSE_PQ_HASH_SIZE, sizeof(struct list_head), GFP_KERNEL);\n\tif (!pq) {\n\t\tkfree(fud);\n\t\treturn NULL;\n\t}\n\n\tfud->pq.processing = pq;\n\tfuse_pqueue_init(&fud->pq);\n\n\treturn fud;\n}\nEXPORT_SYMBOL_GPL(fuse_dev_alloc);\n\nvoid fuse_dev_install(struct fuse_dev *fud, struct fuse_conn *fc)\n{\n\tfud->fc = fuse_conn_get(fc);\n\tspin_lock(&fc->lock);\n\tlist_add_tail(&fud->entry, &fc->devices);\n\tspin_unlock(&fc->lock);\n}\nEXPORT_SYMBOL_GPL(fuse_dev_install);\n\nstruct fuse_dev *fuse_dev_alloc_install(struct fuse_conn *fc)\n{\n\tstruct fuse_dev *fud;\n\n\tfud = fuse_dev_alloc();\n\tif (!fud)\n\t\treturn NULL;\n\n\tfuse_dev_install(fud, fc);\n\treturn fud;\n}\nEXPORT_SYMBOL_GPL(fuse_dev_alloc_install);\n\nvoid fuse_dev_free(struct fuse_dev *fud)\n{\n\tstruct fuse_conn *fc = fud->fc;\n\n\tif (fc) {\n\t\tspin_lock(&fc->lock);\n\t\tlist_del(&fud->entry);\n\t\tspin_unlock(&fc->lock);\n\n\t\tfuse_conn_put(fc);\n\t}\n\tkfree(fud->pq.processing);\n\tkfree(fud);\n}\nEXPORT_SYMBOL_GPL(fuse_dev_free);\n\nstatic void fuse_fill_attr_from_inode(struct fuse_attr *attr,\n\t\t\t\t      const struct fuse_inode *fi)\n{\n\tstruct timespec64 ctime = inode_get_ctime(&fi->inode);\n\n\t*attr = (struct fuse_attr){\n\t\t.ino\t\t= fi->inode.i_ino,\n\t\t.size\t\t= fi->inode.i_size,\n\t\t.blocks\t\t= fi->inode.i_blocks,\n\t\t.atime\t\t= fi->inode.i_atime.tv_sec,\n\t\t.mtime\t\t= fi->inode.i_mtime.tv_sec,\n\t\t.ctime\t\t= ctime.tv_sec,\n\t\t.atimensec\t= fi->inode.i_atime.tv_nsec,\n\t\t.mtimensec\t= fi->inode.i_mtime.tv_nsec,\n\t\t.ctimensec\t= ctime.tv_nsec,\n\t\t.mode\t\t= fi->inode.i_mode,\n\t\t.nlink\t\t= fi->inode.i_nlink,\n\t\t.uid\t\t= fi->inode.i_uid.val,\n\t\t.gid\t\t= fi->inode.i_gid.val,\n\t\t.rdev\t\t= fi->inode.i_rdev,\n\t\t.blksize\t= 1u << fi->inode.i_blkbits,\n\t};\n}\n\nstatic void fuse_sb_defaults(struct super_block *sb)\n{\n\tsb->s_magic = FUSE_SUPER_MAGIC;\n\tsb->s_op = &fuse_super_operations;\n\tsb->s_xattr = fuse_xattr_handlers;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_time_gran = 1;\n\tsb->s_export_op = &fuse_export_operations;\n\tsb->s_iflags |= SB_I_IMA_UNVERIFIABLE_SIGNATURE;\n\tif (sb->s_user_ns != &init_user_ns)\n\t\tsb->s_iflags |= SB_I_UNTRUSTED_MOUNTER;\n\tsb->s_flags &= ~(SB_NOSEC | SB_I_VERSION);\n}\n\nstatic int fuse_fill_super_submount(struct super_block *sb,\n\t\t\t\t    struct fuse_inode *parent_fi)\n{\n\tstruct fuse_mount *fm = get_fuse_mount_super(sb);\n\tstruct super_block *parent_sb = parent_fi->inode.i_sb;\n\tstruct fuse_attr root_attr;\n\tstruct inode *root;\n\tstruct fuse_submount_lookup *sl;\n\tstruct fuse_inode *fi;\n\n\tfuse_sb_defaults(sb);\n\tfm->sb = sb;\n\n\tWARN_ON(sb->s_bdi != &noop_backing_dev_info);\n\tsb->s_bdi = bdi_get(parent_sb->s_bdi);\n\n\tsb->s_xattr = parent_sb->s_xattr;\n\tsb->s_time_gran = parent_sb->s_time_gran;\n\tsb->s_blocksize = parent_sb->s_blocksize;\n\tsb->s_blocksize_bits = parent_sb->s_blocksize_bits;\n\tsb->s_subtype = kstrdup(parent_sb->s_subtype, GFP_KERNEL);\n\tif (parent_sb->s_subtype && !sb->s_subtype)\n\t\treturn -ENOMEM;\n\n\tfuse_fill_attr_from_inode(&root_attr, parent_fi);\n\troot = fuse_iget(sb, parent_fi->nodeid, 0, &root_attr, 0, 0);\n\t \n\tfi = get_fuse_inode(root);\n\tfi->nlookup--;\n\n\tsb->s_d_op = &fuse_dentry_operations;\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\t \n\tsl = parent_fi->submount_lookup;\n\tWARN_ON(!sl);\n\tif (sl) {\n\t\trefcount_inc(&sl->count);\n\t\tfi->submount_lookup = sl;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int fuse_get_tree_submount(struct fs_context *fsc)\n{\n\tstruct fuse_mount *fm;\n\tstruct fuse_inode *mp_fi = fsc->fs_private;\n\tstruct fuse_conn *fc = get_fuse_conn(&mp_fi->inode);\n\tstruct super_block *sb;\n\tint err;\n\n\tfm = kzalloc(sizeof(struct fuse_mount), GFP_KERNEL);\n\tif (!fm)\n\t\treturn -ENOMEM;\n\n\tfm->fc = fuse_conn_get(fc);\n\tfsc->s_fs_info = fm;\n\tsb = sget_fc(fsc, NULL, set_anon_super_fc);\n\tif (fsc->s_fs_info)\n\t\tfuse_mount_destroy(fm);\n\tif (IS_ERR(sb))\n\t\treturn PTR_ERR(sb);\n\n\t \n\terr = fuse_fill_super_submount(sb, mp_fi);\n\tif (err) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn err;\n\t}\n\n\tdown_write(&fc->killsb);\n\tlist_add_tail(&fm->fc_entry, &fc->mounts);\n\tup_write(&fc->killsb);\n\n\tsb->s_flags |= SB_ACTIVE;\n\tfsc->root = dget(sb->s_root);\n\n\treturn 0;\n}\n\nstatic const struct fs_context_operations fuse_context_submount_ops = {\n\t.get_tree\t= fuse_get_tree_submount,\n};\n\nint fuse_init_fs_context_submount(struct fs_context *fsc)\n{\n\tfsc->ops = &fuse_context_submount_ops;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fuse_init_fs_context_submount);\n\nint fuse_fill_super_common(struct super_block *sb, struct fuse_fs_context *ctx)\n{\n\tstruct fuse_dev *fud = NULL;\n\tstruct fuse_mount *fm = get_fuse_mount_super(sb);\n\tstruct fuse_conn *fc = fm->fc;\n\tstruct inode *root;\n\tstruct dentry *root_dentry;\n\tint err;\n\n\terr = -EINVAL;\n\tif (sb->s_flags & SB_MANDLOCK)\n\t\tgoto err;\n\n\trcu_assign_pointer(fc->curr_bucket, fuse_sync_bucket_alloc());\n\tfuse_sb_defaults(sb);\n\n\tif (ctx->is_bdev) {\n#ifdef CONFIG_BLOCK\n\t\terr = -EINVAL;\n\t\tif (!sb_set_blocksize(sb, ctx->blksize))\n\t\t\tgoto err;\n#endif\n\t} else {\n\t\tsb->s_blocksize = PAGE_SIZE;\n\t\tsb->s_blocksize_bits = PAGE_SHIFT;\n\t}\n\n\tsb->s_subtype = ctx->subtype;\n\tctx->subtype = NULL;\n\tif (IS_ENABLED(CONFIG_FUSE_DAX)) {\n\t\terr = fuse_dax_conn_alloc(fc, ctx->dax_mode, ctx->dax_dev);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tif (ctx->fudptr) {\n\t\terr = -ENOMEM;\n\t\tfud = fuse_dev_alloc_install(fc);\n\t\tif (!fud)\n\t\t\tgoto err_free_dax;\n\t}\n\n\tfc->dev = sb->s_dev;\n\tfm->sb = sb;\n\terr = fuse_bdi_init(fc, sb);\n\tif (err)\n\t\tgoto err_dev_free;\n\n\t \n\tif (sb->s_flags & SB_POSIXACL)\n\t\tfc->dont_mask = 1;\n\tsb->s_flags |= SB_POSIXACL;\n\n\tfc->default_permissions = ctx->default_permissions;\n\tfc->allow_other = ctx->allow_other;\n\tfc->user_id = ctx->user_id;\n\tfc->group_id = ctx->group_id;\n\tfc->legacy_opts_show = ctx->legacy_opts_show;\n\tfc->max_read = max_t(unsigned int, 4096, ctx->max_read);\n\tfc->destroy = ctx->destroy;\n\tfc->no_control = ctx->no_control;\n\tfc->no_force_umount = ctx->no_force_umount;\n\n\terr = -ENOMEM;\n\troot = fuse_get_root_inode(sb, ctx->rootmode);\n\tsb->s_d_op = &fuse_root_dentry_operations;\n\troot_dentry = d_make_root(root);\n\tif (!root_dentry)\n\t\tgoto err_dev_free;\n\t \n\tsb->s_d_op = &fuse_dentry_operations;\n\n\tmutex_lock(&fuse_mutex);\n\terr = -EINVAL;\n\tif (ctx->fudptr && *ctx->fudptr)\n\t\tgoto err_unlock;\n\n\terr = fuse_ctl_add_conn(fc);\n\tif (err)\n\t\tgoto err_unlock;\n\n\tlist_add_tail(&fc->entry, &fuse_conn_list);\n\tsb->s_root = root_dentry;\n\tif (ctx->fudptr)\n\t\t*ctx->fudptr = fud;\n\tmutex_unlock(&fuse_mutex);\n\treturn 0;\n\n err_unlock:\n\tmutex_unlock(&fuse_mutex);\n\tdput(root_dentry);\n err_dev_free:\n\tif (fud)\n\t\tfuse_dev_free(fud);\n err_free_dax:\n\tif (IS_ENABLED(CONFIG_FUSE_DAX))\n\t\tfuse_dax_conn_free(fc);\n err:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(fuse_fill_super_common);\n\nstatic int fuse_fill_super(struct super_block *sb, struct fs_context *fsc)\n{\n\tstruct fuse_fs_context *ctx = fsc->fs_private;\n\tint err;\n\n\tif (!ctx->file || !ctx->rootmode_present ||\n\t    !ctx->user_id_present || !ctx->group_id_present)\n\t\treturn -EINVAL;\n\n\t \n\tif ((ctx->file->f_op != &fuse_dev_operations) ||\n\t    (ctx->file->f_cred->user_ns != sb->s_user_ns))\n\t\treturn -EINVAL;\n\tctx->fudptr = &ctx->file->private_data;\n\n\terr = fuse_fill_super_common(sb, ctx);\n\tif (err)\n\t\treturn err;\n\t \n\tsmp_mb();\n\tfuse_send_init(get_fuse_mount_super(sb));\n\treturn 0;\n}\n\n \nstatic int fuse_set_no_super(struct super_block *sb, struct fs_context *fsc)\n{\n\treturn -ENOTCONN;\n}\n\nstatic int fuse_test_super(struct super_block *sb, struct fs_context *fsc)\n{\n\n\treturn fsc->sget_key == get_fuse_conn_super(sb);\n}\n\nstatic int fuse_get_tree(struct fs_context *fsc)\n{\n\tstruct fuse_fs_context *ctx = fsc->fs_private;\n\tstruct fuse_dev *fud;\n\tstruct fuse_conn *fc;\n\tstruct fuse_mount *fm;\n\tstruct super_block *sb;\n\tint err;\n\n\tfc = kmalloc(sizeof(*fc), GFP_KERNEL);\n\tif (!fc)\n\t\treturn -ENOMEM;\n\n\tfm = kzalloc(sizeof(*fm), GFP_KERNEL);\n\tif (!fm) {\n\t\tkfree(fc);\n\t\treturn -ENOMEM;\n\t}\n\n\tfuse_conn_init(fc, fm, fsc->user_ns, &fuse_dev_fiq_ops, NULL);\n\tfc->release = fuse_free_conn;\n\n\tfsc->s_fs_info = fm;\n\n\tif (ctx->fd_present)\n\t\tctx->file = fget(ctx->fd);\n\n\tif (IS_ENABLED(CONFIG_BLOCK) && ctx->is_bdev) {\n\t\terr = get_tree_bdev(fsc, fuse_fill_super);\n\t\tgoto out;\n\t}\n\t \n\terr = -EINVAL;\n\tif (!ctx->file)\n\t\tgoto out;\n\n\t \n\tfud = READ_ONCE(ctx->file->private_data);\n\tif (ctx->file->f_op == &fuse_dev_operations && fud) {\n\t\tfsc->sget_key = fud->fc;\n\t\tsb = sget_fc(fsc, fuse_test_super, fuse_set_no_super);\n\t\terr = PTR_ERR_OR_ZERO(sb);\n\t\tif (!IS_ERR(sb))\n\t\t\tfsc->root = dget(sb->s_root);\n\t} else {\n\t\terr = get_tree_nodev(fsc, fuse_fill_super);\n\t}\nout:\n\tif (fsc->s_fs_info)\n\t\tfuse_mount_destroy(fm);\n\tif (ctx->file)\n\t\tfput(ctx->file);\n\treturn err;\n}\n\nstatic const struct fs_context_operations fuse_context_ops = {\n\t.free\t\t= fuse_free_fsc,\n\t.parse_param\t= fuse_parse_param,\n\t.reconfigure\t= fuse_reconfigure,\n\t.get_tree\t= fuse_get_tree,\n};\n\n \nstatic int fuse_init_fs_context(struct fs_context *fsc)\n{\n\tstruct fuse_fs_context *ctx;\n\n\tctx = kzalloc(sizeof(struct fuse_fs_context), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->max_read = ~0;\n\tctx->blksize = FUSE_DEFAULT_BLKSIZE;\n\tctx->legacy_opts_show = true;\n\n#ifdef CONFIG_BLOCK\n\tif (fsc->fs_type == &fuseblk_fs_type) {\n\t\tctx->is_bdev = true;\n\t\tctx->destroy = true;\n\t}\n#endif\n\n\tfsc->fs_private = ctx;\n\tfsc->ops = &fuse_context_ops;\n\treturn 0;\n}\n\nbool fuse_mount_remove(struct fuse_mount *fm)\n{\n\tstruct fuse_conn *fc = fm->fc;\n\tbool last = false;\n\n\tdown_write(&fc->killsb);\n\tlist_del_init(&fm->fc_entry);\n\tif (list_empty(&fc->mounts))\n\t\tlast = true;\n\tup_write(&fc->killsb);\n\n\treturn last;\n}\nEXPORT_SYMBOL_GPL(fuse_mount_remove);\n\nvoid fuse_conn_destroy(struct fuse_mount *fm)\n{\n\tstruct fuse_conn *fc = fm->fc;\n\n\tif (fc->destroy)\n\t\tfuse_send_destroy(fm);\n\n\tfuse_abort_conn(fc);\n\tfuse_wait_aborted(fc);\n\n\tif (!list_empty(&fc->entry)) {\n\t\tmutex_lock(&fuse_mutex);\n\t\tlist_del(&fc->entry);\n\t\tfuse_ctl_remove_conn(fc);\n\t\tmutex_unlock(&fuse_mutex);\n\t}\n}\nEXPORT_SYMBOL_GPL(fuse_conn_destroy);\n\nstatic void fuse_sb_destroy(struct super_block *sb)\n{\n\tstruct fuse_mount *fm = get_fuse_mount_super(sb);\n\tbool last;\n\n\tif (sb->s_root) {\n\t\tlast = fuse_mount_remove(fm);\n\t\tif (last)\n\t\t\tfuse_conn_destroy(fm);\n\t}\n}\n\nvoid fuse_mount_destroy(struct fuse_mount *fm)\n{\n\tfuse_conn_put(fm->fc);\n\tkfree(fm);\n}\nEXPORT_SYMBOL(fuse_mount_destroy);\n\nstatic void fuse_kill_sb_anon(struct super_block *sb)\n{\n\tfuse_sb_destroy(sb);\n\tkill_anon_super(sb);\n\tfuse_mount_destroy(get_fuse_mount_super(sb));\n}\n\nstatic struct file_system_type fuse_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fuse\",\n\t.fs_flags\t= FS_HAS_SUBTYPE | FS_USERNS_MOUNT,\n\t.init_fs_context = fuse_init_fs_context,\n\t.parameters\t= fuse_fs_parameters,\n\t.kill_sb\t= fuse_kill_sb_anon,\n};\nMODULE_ALIAS_FS(\"fuse\");\n\n#ifdef CONFIG_BLOCK\nstatic void fuse_kill_sb_blk(struct super_block *sb)\n{\n\tfuse_sb_destroy(sb);\n\tkill_block_super(sb);\n\tfuse_mount_destroy(get_fuse_mount_super(sb));\n}\n\nstatic struct file_system_type fuseblk_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fuseblk\",\n\t.init_fs_context = fuse_init_fs_context,\n\t.parameters\t= fuse_fs_parameters,\n\t.kill_sb\t= fuse_kill_sb_blk,\n\t.fs_flags\t= FS_REQUIRES_DEV | FS_HAS_SUBTYPE,\n};\nMODULE_ALIAS_FS(\"fuseblk\");\n\nstatic inline int register_fuseblk(void)\n{\n\treturn register_filesystem(&fuseblk_fs_type);\n}\n\nstatic inline void unregister_fuseblk(void)\n{\n\tunregister_filesystem(&fuseblk_fs_type);\n}\n#else\nstatic inline int register_fuseblk(void)\n{\n\treturn 0;\n}\n\nstatic inline void unregister_fuseblk(void)\n{\n}\n#endif\n\nstatic void fuse_inode_init_once(void *foo)\n{\n\tstruct inode *inode = foo;\n\n\tinode_init_once(inode);\n}\n\nstatic int __init fuse_fs_init(void)\n{\n\tint err;\n\n\tfuse_inode_cachep = kmem_cache_create(\"fuse_inode\",\n\t\t\tsizeof(struct fuse_inode), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_ACCOUNT|SLAB_RECLAIM_ACCOUNT,\n\t\t\tfuse_inode_init_once);\n\terr = -ENOMEM;\n\tif (!fuse_inode_cachep)\n\t\tgoto out;\n\n\terr = register_fuseblk();\n\tif (err)\n\t\tgoto out2;\n\n\terr = register_filesystem(&fuse_fs_type);\n\tif (err)\n\t\tgoto out3;\n\n\treturn 0;\n\n out3:\n\tunregister_fuseblk();\n out2:\n\tkmem_cache_destroy(fuse_inode_cachep);\n out:\n\treturn err;\n}\n\nstatic void fuse_fs_cleanup(void)\n{\n\tunregister_filesystem(&fuse_fs_type);\n\tunregister_fuseblk();\n\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(fuse_inode_cachep);\n}\n\nstatic struct kobject *fuse_kobj;\n\nstatic int fuse_sysfs_init(void)\n{\n\tint err;\n\n\tfuse_kobj = kobject_create_and_add(\"fuse\", fs_kobj);\n\tif (!fuse_kobj) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\terr = sysfs_create_mount_point(fuse_kobj, \"connections\");\n\tif (err)\n\t\tgoto out_fuse_unregister;\n\n\treturn 0;\n\n out_fuse_unregister:\n\tkobject_put(fuse_kobj);\n out_err:\n\treturn err;\n}\n\nstatic void fuse_sysfs_cleanup(void)\n{\n\tsysfs_remove_mount_point(fuse_kobj, \"connections\");\n\tkobject_put(fuse_kobj);\n}\n\nstatic int __init fuse_init(void)\n{\n\tint res;\n\n\tpr_info(\"init (API version %i.%i)\\n\",\n\t\tFUSE_KERNEL_VERSION, FUSE_KERNEL_MINOR_VERSION);\n\n\tINIT_LIST_HEAD(&fuse_conn_list);\n\tres = fuse_fs_init();\n\tif (res)\n\t\tgoto err;\n\n\tres = fuse_dev_init();\n\tif (res)\n\t\tgoto err_fs_cleanup;\n\n\tres = fuse_sysfs_init();\n\tif (res)\n\t\tgoto err_dev_cleanup;\n\n\tres = fuse_ctl_init();\n\tif (res)\n\t\tgoto err_sysfs_cleanup;\n\n\tsanitize_global_limit(&max_user_bgreq);\n\tsanitize_global_limit(&max_user_congthresh);\n\n\treturn 0;\n\n err_sysfs_cleanup:\n\tfuse_sysfs_cleanup();\n err_dev_cleanup:\n\tfuse_dev_cleanup();\n err_fs_cleanup:\n\tfuse_fs_cleanup();\n err:\n\treturn res;\n}\n\nstatic void __exit fuse_exit(void)\n{\n\tpr_debug(\"exit\\n\");\n\n\tfuse_ctl_cleanup();\n\tfuse_sysfs_cleanup();\n\tfuse_fs_cleanup();\n\tfuse_dev_cleanup();\n}\n\nmodule_init(fuse_init);\nmodule_exit(fuse_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}