{
  "module_name": "cuse.c",
  "hash_id": "70c72aacd0f1280bbe64b66aba8dfa793eefc2b10aba9c254cfc06eb2a5fa2ca",
  "original_prompt": "Ingested from linux-6.6.14/fs/fuse/cuse.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"CUSE: \" fmt\n\n#include <linux/fuse.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/kdev_t.h>\n#include <linux/kthread.h>\n#include <linux/list.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/uio.h>\n#include <linux/user_namespace.h>\n\n#include \"fuse_i.h\"\n\n#define CUSE_CONNTBL_LEN\t64\n\nstruct cuse_conn {\n\tstruct list_head\tlist;\t \n\tstruct fuse_mount\tfm;\t \n\tstruct fuse_conn\tfc;\t \n\tstruct cdev\t\t*cdev;\t \n\tstruct device\t\t*dev;\t \n\n\t \n\tbool\t\t\tunrestricted_ioctl;\n};\n\nstatic DEFINE_MUTEX(cuse_lock);\t\t \nstatic struct list_head cuse_conntbl[CUSE_CONNTBL_LEN];\nstatic struct class *cuse_class;\n\nstatic struct cuse_conn *fc_to_cc(struct fuse_conn *fc)\n{\n\treturn container_of(fc, struct cuse_conn, fc);\n}\n\nstatic struct list_head *cuse_conntbl_head(dev_t devt)\n{\n\treturn &cuse_conntbl[(MAJOR(devt) + MINOR(devt)) % CUSE_CONNTBL_LEN];\n}\n\n\n \n\nstatic ssize_t cuse_read_iter(struct kiocb *kiocb, struct iov_iter *to)\n{\n\tstruct fuse_io_priv io = FUSE_IO_PRIV_SYNC(kiocb);\n\tloff_t pos = 0;\n\n\treturn fuse_direct_io(&io, to, &pos, FUSE_DIO_CUSE);\n}\n\nstatic ssize_t cuse_write_iter(struct kiocb *kiocb, struct iov_iter *from)\n{\n\tstruct fuse_io_priv io = FUSE_IO_PRIV_SYNC(kiocb);\n\tloff_t pos = 0;\n\t \n\treturn fuse_direct_io(&io, from, &pos,\n\t\t\t      FUSE_DIO_WRITE | FUSE_DIO_CUSE);\n}\n\nstatic int cuse_open(struct inode *inode, struct file *file)\n{\n\tdev_t devt = inode->i_cdev->dev;\n\tstruct cuse_conn *cc = NULL, *pos;\n\tint rc;\n\n\t \n\tmutex_lock(&cuse_lock);\n\tlist_for_each_entry(pos, cuse_conntbl_head(devt), list)\n\t\tif (pos->dev->devt == devt) {\n\t\t\tfuse_conn_get(&pos->fc);\n\t\t\tcc = pos;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&cuse_lock);\n\n\t \n\tif (!cc)\n\t\treturn -ENODEV;\n\n\t \n\trc = fuse_do_open(&cc->fm, 0, file, 0);\n\tif (rc)\n\t\tfuse_conn_put(&cc->fc);\n\treturn rc;\n}\n\nstatic int cuse_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_mount *fm = ff->fm;\n\n\tfuse_sync_release(NULL, ff, file->f_flags);\n\tfuse_conn_put(fm->fc);\n\n\treturn 0;\n}\n\nstatic long cuse_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(ff->fm->fc);\n\tunsigned int flags = 0;\n\n\tif (cc->unrestricted_ioctl)\n\t\tflags |= FUSE_IOCTL_UNRESTRICTED;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}\n\nstatic long cuse_file_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(ff->fm->fc);\n\tunsigned int flags = FUSE_IOCTL_COMPAT;\n\n\tif (cc->unrestricted_ioctl)\n\t\tflags |= FUSE_IOCTL_UNRESTRICTED;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}\n\nstatic const struct file_operations cuse_frontend_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.read_iter\t\t= cuse_read_iter,\n\t.write_iter\t\t= cuse_write_iter,\n\t.open\t\t\t= cuse_open,\n\t.release\t\t= cuse_release,\n\t.unlocked_ioctl\t\t= cuse_file_ioctl,\n\t.compat_ioctl\t\t= cuse_file_compat_ioctl,\n\t.poll\t\t\t= fuse_file_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\n\n \n\nstruct cuse_devinfo {\n\tconst char\t\t*name;\n};\n\n \nstatic int cuse_parse_one(char **pp, char *end, char **keyp, char **valp)\n{\n\tchar *p = *pp;\n\tchar *key, *val;\n\n\twhile (p < end && *p == '\\0')\n\t\tp++;\n\tif (p == end)\n\t\treturn 0;\n\n\tif (end[-1] != '\\0') {\n\t\tpr_err(\"info not properly terminated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tkey = val = p;\n\tp += strlen(p);\n\n\tif (valp) {\n\t\tstrsep(&val, \"=\");\n\t\tif (!val)\n\t\t\tval = key + strlen(key);\n\t\tkey = strstrip(key);\n\t\tval = strstrip(val);\n\t} else\n\t\tkey = strstrip(key);\n\n\tif (!strlen(key)) {\n\t\tpr_err(\"zero length info key specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*pp = p;\n\t*keyp = key;\n\tif (valp)\n\t\t*valp = val;\n\n\treturn 1;\n}\n\n \nstatic int cuse_parse_devinfo(char *p, size_t len, struct cuse_devinfo *devinfo)\n{\n\tchar *end = p + len;\n\tchar *key, *val;\n\tint rc;\n\n\twhile (true) {\n\t\trc = cuse_parse_one(&p, end, &key, &val);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tif (!rc)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"DEVNAME\") == 0)\n\t\t\tdevinfo->name = val;\n\t\telse\n\t\t\tpr_warn(\"unknown device info \\\"%s\\\"\\n\", key);\n\t}\n\n\tif (!devinfo->name || !strlen(devinfo->name)) {\n\t\tpr_err(\"DEVNAME unspecified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void cuse_gendev_release(struct device *dev)\n{\n\tkfree(dev);\n}\n\nstruct cuse_init_args {\n\tstruct fuse_args_pages ap;\n\tstruct cuse_init_in in;\n\tstruct cuse_init_out out;\n\tstruct page *page;\n\tstruct fuse_page_desc desc;\n};\n\n \nstatic void cuse_process_init_reply(struct fuse_mount *fm,\n\t\t\t\t    struct fuse_args *args, int error)\n{\n\tstruct fuse_conn *fc = fm->fc;\n\tstruct cuse_init_args *ia = container_of(args, typeof(*ia), ap.args);\n\tstruct fuse_args_pages *ap = &ia->ap;\n\tstruct cuse_conn *cc = fc_to_cc(fc), *pos;\n\tstruct cuse_init_out *arg = &ia->out;\n\tstruct page *page = ap->pages[0];\n\tstruct cuse_devinfo devinfo = { };\n\tstruct device *dev;\n\tstruct cdev *cdev;\n\tdev_t devt;\n\tint rc, i;\n\n\tif (error || arg->major != FUSE_KERNEL_VERSION || arg->minor < 11)\n\t\tgoto err;\n\n\tfc->minor = arg->minor;\n\tfc->max_read = max_t(unsigned, arg->max_read, 4096);\n\tfc->max_write = max_t(unsigned, arg->max_write, 4096);\n\n\t \n\tcc->unrestricted_ioctl = arg->flags & CUSE_UNRESTRICTED_IOCTL;\n\n\trc = cuse_parse_devinfo(page_address(page), ap->args.out_args[1].size,\n\t\t\t\t&devinfo);\n\tif (rc)\n\t\tgoto err;\n\n\t \n\tdevt = MKDEV(arg->dev_major, arg->dev_minor);\n\tif (!MAJOR(devt))\n\t\trc = alloc_chrdev_region(&devt, MINOR(devt), 1, devinfo.name);\n\telse\n\t\trc = register_chrdev_region(devt, 1, devinfo.name);\n\tif (rc) {\n\t\tpr_err(\"failed to register chrdev region\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\trc = -ENOMEM;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\tgoto err_region;\n\n\tdevice_initialize(dev);\n\tdev_set_uevent_suppress(dev, 1);\n\tdev->class = cuse_class;\n\tdev->devt = devt;\n\tdev->release = cuse_gendev_release;\n\tdev_set_drvdata(dev, cc);\n\tdev_set_name(dev, \"%s\", devinfo.name);\n\n\tmutex_lock(&cuse_lock);\n\n\t \n\tfor (i = 0; i < CUSE_CONNTBL_LEN; ++i) {\n\t\tlist_for_each_entry(pos, &cuse_conntbl[i], list)\n\t\t\tif (!strcmp(dev_name(pos->dev), dev_name(dev)))\n\t\t\t\tgoto err_unlock;\n\t}\n\n\trc = device_add(dev);\n\tif (rc)\n\t\tgoto err_unlock;\n\n\t \n\trc = -ENOMEM;\n\tcdev = cdev_alloc();\n\tif (!cdev)\n\t\tgoto err_unlock;\n\n\tcdev->owner = THIS_MODULE;\n\tcdev->ops = &cuse_frontend_fops;\n\n\trc = cdev_add(cdev, devt, 1);\n\tif (rc)\n\t\tgoto err_cdev;\n\n\tcc->dev = dev;\n\tcc->cdev = cdev;\n\n\t \n\tlist_add(&cc->list, cuse_conntbl_head(devt));\n\tmutex_unlock(&cuse_lock);\n\n\t \n\tdev_set_uevent_suppress(dev, 0);\n\tkobject_uevent(&dev->kobj, KOBJ_ADD);\nout:\n\tkfree(ia);\n\t__free_page(page);\n\treturn;\n\nerr_cdev:\n\tcdev_del(cdev);\nerr_unlock:\n\tmutex_unlock(&cuse_lock);\n\tput_device(dev);\nerr_region:\n\tunregister_chrdev_region(devt, 1);\nerr:\n\tfuse_abort_conn(fc);\n\tgoto out;\n}\n\nstatic int cuse_send_init(struct cuse_conn *cc)\n{\n\tint rc;\n\tstruct page *page;\n\tstruct fuse_mount *fm = &cc->fm;\n\tstruct cuse_init_args *ia;\n\tstruct fuse_args_pages *ap;\n\n\tBUILD_BUG_ON(CUSE_INIT_INFO_MAX > PAGE_SIZE);\n\n\trc = -ENOMEM;\n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!page)\n\t\tgoto err;\n\n\tia = kzalloc(sizeof(*ia), GFP_KERNEL);\n\tif (!ia)\n\t\tgoto err_free_page;\n\n\tap = &ia->ap;\n\tia->in.major = FUSE_KERNEL_VERSION;\n\tia->in.minor = FUSE_KERNEL_MINOR_VERSION;\n\tia->in.flags |= CUSE_UNRESTRICTED_IOCTL;\n\tap->args.opcode = CUSE_INIT;\n\tap->args.in_numargs = 1;\n\tap->args.in_args[0].size = sizeof(ia->in);\n\tap->args.in_args[0].value = &ia->in;\n\tap->args.out_numargs = 2;\n\tap->args.out_args[0].size = sizeof(ia->out);\n\tap->args.out_args[0].value = &ia->out;\n\tap->args.out_args[1].size = CUSE_INIT_INFO_MAX;\n\tap->args.out_argvar = true;\n\tap->args.out_pages = true;\n\tap->num_pages = 1;\n\tap->pages = &ia->page;\n\tap->descs = &ia->desc;\n\tia->page = page;\n\tia->desc.length = ap->args.out_args[1].size;\n\tap->args.end = cuse_process_init_reply;\n\n\trc = fuse_simple_background(fm, &ap->args, GFP_KERNEL);\n\tif (rc) {\n\t\tkfree(ia);\nerr_free_page:\n\t\t__free_page(page);\n\t}\nerr:\n\treturn rc;\n}\n\nstatic void cuse_fc_release(struct fuse_conn *fc)\n{\n\tstruct cuse_conn *cc = fc_to_cc(fc);\n\tkfree_rcu(cc, fc.rcu);\n}\n\n \nstatic int cuse_channel_open(struct inode *inode, struct file *file)\n{\n\tstruct fuse_dev *fud;\n\tstruct cuse_conn *cc;\n\tint rc;\n\n\t \n\tcc = kzalloc(sizeof(*cc), GFP_KERNEL);\n\tif (!cc)\n\t\treturn -ENOMEM;\n\n\t \n\tfuse_conn_init(&cc->fc, &cc->fm, file->f_cred->user_ns,\n\t\t       &fuse_dev_fiq_ops, NULL);\n\n\tcc->fc.release = cuse_fc_release;\n\tfud = fuse_dev_alloc_install(&cc->fc);\n\tfuse_conn_put(&cc->fc);\n\tif (!fud)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&cc->list);\n\n\tcc->fc.initialized = 1;\n\trc = cuse_send_init(cc);\n\tif (rc) {\n\t\tfuse_dev_free(fud);\n\t\treturn rc;\n\t}\n\tfile->private_data = fud;\n\n\treturn 0;\n}\n\n \nstatic int cuse_channel_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_dev *fud = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(fud->fc);\n\n\t \n\tmutex_lock(&cuse_lock);\n\tlist_del_init(&cc->list);\n\tmutex_unlock(&cuse_lock);\n\n\t \n\tif (cc->dev)\n\t\tdevice_unregister(cc->dev);\n\tif (cc->cdev) {\n\t\tunregister_chrdev_region(cc->cdev->dev, 1);\n\t\tcdev_del(cc->cdev);\n\t}\n\n\treturn fuse_dev_release(inode, file);\n}\n\nstatic struct file_operations cuse_channel_fops;  \n\n\n \n\nstatic ssize_t cuse_class_waiting_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct cuse_conn *cc = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", atomic_read(&cc->fc.num_waiting));\n}\nstatic DEVICE_ATTR(waiting, 0400, cuse_class_waiting_show, NULL);\n\nstatic ssize_t cuse_class_abort_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct cuse_conn *cc = dev_get_drvdata(dev);\n\n\tfuse_abort_conn(&cc->fc);\n\treturn count;\n}\nstatic DEVICE_ATTR(abort, 0200, NULL, cuse_class_abort_store);\n\nstatic struct attribute *cuse_class_dev_attrs[] = {\n\t&dev_attr_waiting.attr,\n\t&dev_attr_abort.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(cuse_class_dev);\n\nstatic struct miscdevice cuse_miscdev = {\n\t.minor\t\t= CUSE_MINOR,\n\t.name\t\t= \"cuse\",\n\t.fops\t\t= &cuse_channel_fops,\n};\n\nMODULE_ALIAS_MISCDEV(CUSE_MINOR);\nMODULE_ALIAS(\"devname:cuse\");\n\nstatic int __init cuse_init(void)\n{\n\tint i, rc;\n\n\t \n\tfor (i = 0; i < CUSE_CONNTBL_LEN; i++)\n\t\tINIT_LIST_HEAD(&cuse_conntbl[i]);\n\n\t \n\tcuse_channel_fops\t\t= fuse_dev_operations;\n\tcuse_channel_fops.owner\t\t= THIS_MODULE;\n\tcuse_channel_fops.open\t\t= cuse_channel_open;\n\tcuse_channel_fops.release\t= cuse_channel_release;\n\t \n\tcuse_channel_fops.unlocked_ioctl\t= NULL;\n\n\tcuse_class = class_create(\"cuse\");\n\tif (IS_ERR(cuse_class))\n\t\treturn PTR_ERR(cuse_class);\n\n\tcuse_class->dev_groups = cuse_class_dev_groups;\n\n\trc = misc_register(&cuse_miscdev);\n\tif (rc) {\n\t\tclass_destroy(cuse_class);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit cuse_exit(void)\n{\n\tmisc_deregister(&cuse_miscdev);\n\tclass_destroy(cuse_class);\n}\n\nmodule_init(cuse_init);\nmodule_exit(cuse_exit);\n\nMODULE_AUTHOR(\"Tejun Heo <tj@kernel.org>\");\nMODULE_DESCRIPTION(\"Character device in Userspace\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}