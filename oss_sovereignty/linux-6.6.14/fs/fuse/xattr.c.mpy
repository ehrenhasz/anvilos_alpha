{
  "module_name": "xattr.c",
  "hash_id": "bf88afb6735a10c8a335ad7c1e84f41e95ac7a816baedd83d9274be9a807e4d5",
  "original_prompt": "Ingested from linux-6.6.14/fs/fuse/xattr.c",
  "human_readable_source": " \n\n#include \"fuse_i.h\"\n\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n\nint fuse_setxattr(struct inode *inode, const char *name, const void *value,\n\t\t  size_t size, int flags, unsigned int extra_flags)\n{\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_setxattr_in inarg;\n\tint err;\n\n\tif (fm->fc->no_setxattr)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.size = size;\n\tinarg.flags = flags;\n\tinarg.setxattr_flags = extra_flags;\n\n\targs.opcode = FUSE_SETXATTR;\n\targs.nodeid = get_node_id(inode);\n\targs.in_numargs = 3;\n\targs.in_args[0].size = fm->fc->setxattr_ext ?\n\t\tsizeof(inarg) : FUSE_COMPAT_SETXATTR_IN_SIZE;\n\targs.in_args[0].value = &inarg;\n\targs.in_args[1].size = strlen(name) + 1;\n\targs.in_args[1].value = name;\n\targs.in_args[2].size = size;\n\targs.in_args[2].value = value;\n\terr = fuse_simple_request(fm, &args);\n\tif (err == -ENOSYS) {\n\t\tfm->fc->no_setxattr = 1;\n\t\terr = -EOPNOTSUPP;\n\t}\n\tif (!err)\n\t\tfuse_update_ctime(inode);\n\n\treturn err;\n}\n\nssize_t fuse_getxattr(struct inode *inode, const char *name, void *value,\n\t\t      size_t size)\n{\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_getxattr_in inarg;\n\tstruct fuse_getxattr_out outarg;\n\tssize_t ret;\n\n\tif (fm->fc->no_getxattr)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.size = size;\n\targs.opcode = FUSE_GETXATTR;\n\targs.nodeid = get_node_id(inode);\n\targs.in_numargs = 2;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.in_args[1].size = strlen(name) + 1;\n\targs.in_args[1].value = name;\n\t \n\targs.out_numargs = 1;\n\tif (size) {\n\t\targs.out_argvar = true;\n\t\targs.out_args[0].size = size;\n\t\targs.out_args[0].value = value;\n\t} else {\n\t\targs.out_args[0].size = sizeof(outarg);\n\t\targs.out_args[0].value = &outarg;\n\t}\n\tret = fuse_simple_request(fm, &args);\n\tif (!ret && !size)\n\t\tret = min_t(ssize_t, outarg.size, XATTR_SIZE_MAX);\n\tif (ret == -ENOSYS) {\n\t\tfm->fc->no_getxattr = 1;\n\t\tret = -EOPNOTSUPP;\n\t}\n\treturn ret;\n}\n\nstatic int fuse_verify_xattr_list(char *list, size_t size)\n{\n\tsize_t origsize = size;\n\n\twhile (size) {\n\t\tsize_t thislen = strnlen(list, size);\n\n\t\tif (!thislen || thislen == size)\n\t\t\treturn -EIO;\n\n\t\tsize -= thislen + 1;\n\t\tlist += thislen + 1;\n\t}\n\n\treturn origsize;\n}\n\nssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size)\n{\n\tstruct inode *inode = d_inode(entry);\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_getxattr_in inarg;\n\tstruct fuse_getxattr_out outarg;\n\tssize_t ret;\n\n\tif (fuse_is_bad(inode))\n\t\treturn -EIO;\n\n\tif (!fuse_allow_current_process(fm->fc))\n\t\treturn -EACCES;\n\n\tif (fm->fc->no_listxattr)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.size = size;\n\targs.opcode = FUSE_LISTXATTR;\n\targs.nodeid = get_node_id(inode);\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\t \n\targs.out_numargs = 1;\n\tif (size) {\n\t\targs.out_argvar = true;\n\t\targs.out_args[0].size = size;\n\t\targs.out_args[0].value = list;\n\t} else {\n\t\targs.out_args[0].size = sizeof(outarg);\n\t\targs.out_args[0].value = &outarg;\n\t}\n\tret = fuse_simple_request(fm, &args);\n\tif (!ret && !size)\n\t\tret = min_t(ssize_t, outarg.size, XATTR_LIST_MAX);\n\tif (ret > 0 && size)\n\t\tret = fuse_verify_xattr_list(list, ret);\n\tif (ret == -ENOSYS) {\n\t\tfm->fc->no_listxattr = 1;\n\t\tret = -EOPNOTSUPP;\n\t}\n\treturn ret;\n}\n\nint fuse_removexattr(struct inode *inode, const char *name)\n{\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tFUSE_ARGS(args);\n\tint err;\n\n\tif (fm->fc->no_removexattr)\n\t\treturn -EOPNOTSUPP;\n\n\targs.opcode = FUSE_REMOVEXATTR;\n\targs.nodeid = get_node_id(inode);\n\targs.in_numargs = 1;\n\targs.in_args[0].size = strlen(name) + 1;\n\targs.in_args[0].value = name;\n\terr = fuse_simple_request(fm, &args);\n\tif (err == -ENOSYS) {\n\t\tfm->fc->no_removexattr = 1;\n\t\terr = -EOPNOTSUPP;\n\t}\n\tif (!err)\n\t\tfuse_update_ctime(inode);\n\n\treturn err;\n}\n\nstatic int fuse_xattr_get(const struct xattr_handler *handler,\n\t\t\t struct dentry *dentry, struct inode *inode,\n\t\t\t const char *name, void *value, size_t size)\n{\n\tif (fuse_is_bad(inode))\n\t\treturn -EIO;\n\n\treturn fuse_getxattr(inode, name, value, size);\n}\n\nstatic int fuse_xattr_set(const struct xattr_handler *handler,\n\t\t\t  struct mnt_idmap *idmap,\n\t\t\t  struct dentry *dentry, struct inode *inode,\n\t\t\t  const char *name, const void *value, size_t size,\n\t\t\t  int flags)\n{\n\tif (fuse_is_bad(inode))\n\t\treturn -EIO;\n\n\tif (!value)\n\t\treturn fuse_removexattr(inode, name);\n\n\treturn fuse_setxattr(inode, name, value, size, flags, 0);\n}\n\nstatic const struct xattr_handler fuse_xattr_handler = {\n\t.prefix = \"\",\n\t.get    = fuse_xattr_get,\n\t.set    = fuse_xattr_set,\n};\n\nconst struct xattr_handler *fuse_xattr_handlers[] = {\n\t&fuse_xattr_handler,\n\tNULL\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}