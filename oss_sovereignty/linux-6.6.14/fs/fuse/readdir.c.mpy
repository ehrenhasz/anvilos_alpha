{
  "module_name": "readdir.c",
  "hash_id": "ab8e00beb32e662533b3811ab702f6544069522b0ecdc2c5b8de025142648221",
  "original_prompt": "Ingested from linux-6.6.14/fs/fuse/readdir.c",
  "human_readable_source": " \n\n\n#include \"fuse_i.h\"\n#include <linux/iversion.h>\n#include <linux/posix_acl.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n\nstatic bool fuse_use_readdirplus(struct inode *dir, struct dir_context *ctx)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tstruct fuse_inode *fi = get_fuse_inode(dir);\n\n\tif (!fc->do_readdirplus)\n\t\treturn false;\n\tif (!fc->readdirplus_auto)\n\t\treturn true;\n\tif (test_and_clear_bit(FUSE_I_ADVISE_RDPLUS, &fi->state))\n\t\treturn true;\n\tif (ctx->pos == 0)\n\t\treturn true;\n\treturn false;\n}\n\nstatic void fuse_add_dirent_to_cache(struct file *file,\n\t\t\t\t     struct fuse_dirent *dirent, loff_t pos)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(file_inode(file));\n\tsize_t reclen = FUSE_DIRENT_SIZE(dirent);\n\tpgoff_t index;\n\tstruct page *page;\n\tloff_t size;\n\tu64 version;\n\tunsigned int offset;\n\tvoid *addr;\n\n\tspin_lock(&fi->rdc.lock);\n\t \n\tif (fi->rdc.cached || pos != fi->rdc.pos) {\n\t\tspin_unlock(&fi->rdc.lock);\n\t\treturn;\n\t}\n\tversion = fi->rdc.version;\n\tsize = fi->rdc.size;\n\toffset = size & ~PAGE_MASK;\n\tindex = size >> PAGE_SHIFT;\n\t \n\tif (offset + reclen > PAGE_SIZE) {\n\t\tindex++;\n\t\toffset = 0;\n\t}\n\tspin_unlock(&fi->rdc.lock);\n\n\tif (offset) {\n\t\tpage = find_lock_page(file->f_mapping, index);\n\t} else {\n\t\tpage = find_or_create_page(file->f_mapping, index,\n\t\t\t\t\t   mapping_gfp_mask(file->f_mapping));\n\t}\n\tif (!page)\n\t\treturn;\n\n\tspin_lock(&fi->rdc.lock);\n\t \n\tif (fi->rdc.version != version || fi->rdc.size != size ||\n\t    WARN_ON(fi->rdc.pos != pos))\n\t\tgoto unlock;\n\n\taddr = kmap_local_page(page);\n\tif (!offset) {\n\t\tclear_page(addr);\n\t\tSetPageUptodate(page);\n\t}\n\tmemcpy(addr + offset, dirent, reclen);\n\tkunmap_local(addr);\n\tfi->rdc.size = (index << PAGE_SHIFT) + offset + reclen;\n\tfi->rdc.pos = dirent->off;\nunlock:\n\tspin_unlock(&fi->rdc.lock);\n\tunlock_page(page);\n\tput_page(page);\n}\n\nstatic void fuse_readdir_cache_end(struct file *file, loff_t pos)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(file_inode(file));\n\tloff_t end;\n\n\tspin_lock(&fi->rdc.lock);\n\t \n\tif (fi->rdc.pos != pos) {\n\t\tspin_unlock(&fi->rdc.lock);\n\t\treturn;\n\t}\n\n\tfi->rdc.cached = true;\n\tend = ALIGN(fi->rdc.size, PAGE_SIZE);\n\tspin_unlock(&fi->rdc.lock);\n\n\t \n\ttruncate_inode_pages(file->f_mapping, end);\n}\n\nstatic bool fuse_emit(struct file *file, struct dir_context *ctx,\n\t\t      struct fuse_dirent *dirent)\n{\n\tstruct fuse_file *ff = file->private_data;\n\n\tif (ff->open_flags & FOPEN_CACHE_DIR)\n\t\tfuse_add_dirent_to_cache(file, dirent, ctx->pos);\n\n\treturn dir_emit(ctx, dirent->name, dirent->namelen, dirent->ino,\n\t\t\tdirent->type);\n}\n\nstatic int parse_dirfile(char *buf, size_t nbytes, struct file *file,\n\t\t\t struct dir_context *ctx)\n{\n\twhile (nbytes >= FUSE_NAME_OFFSET) {\n\t\tstruct fuse_dirent *dirent = (struct fuse_dirent *) buf;\n\t\tsize_t reclen = FUSE_DIRENT_SIZE(dirent);\n\t\tif (!dirent->namelen || dirent->namelen > FUSE_NAME_MAX)\n\t\t\treturn -EIO;\n\t\tif (reclen > nbytes)\n\t\t\tbreak;\n\t\tif (memchr(dirent->name, '/', dirent->namelen) != NULL)\n\t\t\treturn -EIO;\n\n\t\tif (!fuse_emit(file, ctx, dirent))\n\t\t\tbreak;\n\n\t\tbuf += reclen;\n\t\tnbytes -= reclen;\n\t\tctx->pos = dirent->off;\n\t}\n\n\treturn 0;\n}\n\nstatic int fuse_direntplus_link(struct file *file,\n\t\t\t\tstruct fuse_direntplus *direntplus,\n\t\t\t\tu64 attr_version)\n{\n\tstruct fuse_entry_out *o = &direntplus->entry_out;\n\tstruct fuse_dirent *dirent = &direntplus->dirent;\n\tstruct dentry *parent = file->f_path.dentry;\n\tstruct qstr name = QSTR_INIT(dirent->name, dirent->namelen);\n\tstruct dentry *dentry;\n\tstruct dentry *alias;\n\tstruct inode *dir = d_inode(parent);\n\tstruct fuse_conn *fc;\n\tstruct inode *inode;\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\n\tif (!o->nodeid) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (name.name[0] == '.') {\n\t\t \n\t\tif (name.len == 1)\n\t\t\treturn 0;\n\t\tif (name.name[1] == '.' && name.len == 2)\n\t\t\treturn 0;\n\t}\n\n\tif (invalid_nodeid(o->nodeid))\n\t\treturn -EIO;\n\tif (fuse_invalid_attr(&o->attr))\n\t\treturn -EIO;\n\n\tfc = get_fuse_conn(dir);\n\n\tname.hash = full_name_hash(parent, name.name, name.len);\n\tdentry = d_lookup(parent, &name);\n\tif (!dentry) {\nretry:\n\t\tdentry = d_alloc_parallel(parent, &name, &wq);\n\t\tif (IS_ERR(dentry))\n\t\t\treturn PTR_ERR(dentry);\n\t}\n\tif (!d_in_lookup(dentry)) {\n\t\tstruct fuse_inode *fi;\n\t\tinode = d_inode(dentry);\n\t\tif (inode && get_node_id(inode) != o->nodeid)\n\t\t\tinode = NULL;\n\t\tif (!inode ||\n\t\t    fuse_stale_inode(inode, o->generation, &o->attr)) {\n\t\t\tif (inode)\n\t\t\t\tfuse_make_bad(inode);\n\t\t\td_invalidate(dentry);\n\t\t\tdput(dentry);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (fuse_is_bad(inode)) {\n\t\t\tdput(dentry);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tfi = get_fuse_inode(inode);\n\t\tspin_lock(&fi->lock);\n\t\tfi->nlookup++;\n\t\tspin_unlock(&fi->lock);\n\n\t\tforget_all_cached_acls(inode);\n\t\tfuse_change_attributes(inode, &o->attr, NULL,\n\t\t\t\t       ATTR_TIMEOUT(o),\n\t\t\t\t       attr_version);\n\t\t \n\t} else {\n\t\tinode = fuse_iget(dir->i_sb, o->nodeid, o->generation,\n\t\t\t\t  &o->attr, ATTR_TIMEOUT(o),\n\t\t\t\t  attr_version);\n\t\tif (!inode)\n\t\t\tinode = ERR_PTR(-ENOMEM);\n\n\t\talias = d_splice_alias(inode, dentry);\n\t\td_lookup_done(dentry);\n\t\tif (alias) {\n\t\t\tdput(dentry);\n\t\t\tdentry = alias;\n\t\t}\n\t\tif (IS_ERR(dentry)) {\n\t\t\tif (!IS_ERR(inode)) {\n\t\t\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\t\t\tspin_lock(&fi->lock);\n\t\t\t\tfi->nlookup--;\n\t\t\t\tspin_unlock(&fi->lock);\n\t\t\t}\n\t\t\treturn PTR_ERR(dentry);\n\t\t}\n\t}\n\tif (fc->readdirplus_auto)\n\t\tset_bit(FUSE_I_INIT_RDPLUS, &get_fuse_inode(inode)->state);\n\tfuse_change_entry_timeout(dentry, o);\n\n\tdput(dentry);\n\treturn 0;\n}\n\nstatic void fuse_force_forget(struct file *file, u64 nodeid)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tstruct fuse_forget_in inarg;\n\tFUSE_ARGS(args);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.nlookup = 1;\n\targs.opcode = FUSE_FORGET;\n\targs.nodeid = nodeid;\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.force = true;\n\targs.noreply = true;\n\n\tfuse_simple_request(fm, &args);\n\t \n}\n\nstatic int parse_dirplusfile(char *buf, size_t nbytes, struct file *file,\n\t\t\t     struct dir_context *ctx, u64 attr_version)\n{\n\tstruct fuse_direntplus *direntplus;\n\tstruct fuse_dirent *dirent;\n\tsize_t reclen;\n\tint over = 0;\n\tint ret;\n\n\twhile (nbytes >= FUSE_NAME_OFFSET_DIRENTPLUS) {\n\t\tdirentplus = (struct fuse_direntplus *) buf;\n\t\tdirent = &direntplus->dirent;\n\t\treclen = FUSE_DIRENTPLUS_SIZE(direntplus);\n\n\t\tif (!dirent->namelen || dirent->namelen > FUSE_NAME_MAX)\n\t\t\treturn -EIO;\n\t\tif (reclen > nbytes)\n\t\t\tbreak;\n\t\tif (memchr(dirent->name, '/', dirent->namelen) != NULL)\n\t\t\treturn -EIO;\n\n\t\tif (!over) {\n\t\t\t \n\t\t\tover = !fuse_emit(file, ctx, dirent);\n\t\t\tif (!over)\n\t\t\t\tctx->pos = dirent->off;\n\t\t}\n\n\t\tbuf += reclen;\n\t\tnbytes -= reclen;\n\n\t\tret = fuse_direntplus_link(file, direntplus, attr_version);\n\t\tif (ret)\n\t\t\tfuse_force_forget(file, direntplus->entry_out.nodeid);\n\t}\n\n\treturn 0;\n}\n\nstatic int fuse_readdir_uncached(struct file *file, struct dir_context *ctx)\n{\n\tint plus;\n\tssize_t res;\n\tstruct page *page;\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tstruct fuse_io_args ia = {};\n\tstruct fuse_args_pages *ap = &ia.ap;\n\tstruct fuse_page_desc desc = { .length = PAGE_SIZE };\n\tu64 attr_version = 0;\n\tbool locked;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tplus = fuse_use_readdirplus(inode, ctx);\n\tap->args.out_pages = true;\n\tap->num_pages = 1;\n\tap->pages = &page;\n\tap->descs = &desc;\n\tif (plus) {\n\t\tattr_version = fuse_get_attr_version(fm->fc);\n\t\tfuse_read_args_fill(&ia, file, ctx->pos, PAGE_SIZE,\n\t\t\t\t    FUSE_READDIRPLUS);\n\t} else {\n\t\tfuse_read_args_fill(&ia, file, ctx->pos, PAGE_SIZE,\n\t\t\t\t    FUSE_READDIR);\n\t}\n\tlocked = fuse_lock_inode(inode);\n\tres = fuse_simple_request(fm, &ap->args);\n\tfuse_unlock_inode(inode, locked);\n\tif (res >= 0) {\n\t\tif (!res) {\n\t\t\tstruct fuse_file *ff = file->private_data;\n\n\t\t\tif (ff->open_flags & FOPEN_CACHE_DIR)\n\t\t\t\tfuse_readdir_cache_end(file, ctx->pos);\n\t\t} else if (plus) {\n\t\t\tres = parse_dirplusfile(page_address(page), res,\n\t\t\t\t\t\tfile, ctx, attr_version);\n\t\t} else {\n\t\t\tres = parse_dirfile(page_address(page), res, file,\n\t\t\t\t\t    ctx);\n\t\t}\n\t}\n\n\t__free_page(page);\n\tfuse_invalidate_atime(inode);\n\treturn res;\n}\n\nenum fuse_parse_result {\n\tFOUND_ERR = -1,\n\tFOUND_NONE = 0,\n\tFOUND_SOME,\n\tFOUND_ALL,\n};\n\nstatic enum fuse_parse_result fuse_parse_cache(struct fuse_file *ff,\n\t\t\t\t\t       void *addr, unsigned int size,\n\t\t\t\t\t       struct dir_context *ctx)\n{\n\tunsigned int offset = ff->readdir.cache_off & ~PAGE_MASK;\n\tenum fuse_parse_result res = FOUND_NONE;\n\n\tWARN_ON(offset >= size);\n\n\tfor (;;) {\n\t\tstruct fuse_dirent *dirent = addr + offset;\n\t\tunsigned int nbytes = size - offset;\n\t\tsize_t reclen;\n\n\t\tif (nbytes < FUSE_NAME_OFFSET || !dirent->namelen)\n\t\t\tbreak;\n\n\t\treclen = FUSE_DIRENT_SIZE(dirent);  \n\n\t\tif (WARN_ON(dirent->namelen > FUSE_NAME_MAX))\n\t\t\treturn FOUND_ERR;\n\t\tif (WARN_ON(reclen > nbytes))\n\t\t\treturn FOUND_ERR;\n\t\tif (WARN_ON(memchr(dirent->name, '/', dirent->namelen) != NULL))\n\t\t\treturn FOUND_ERR;\n\n\t\tif (ff->readdir.pos == ctx->pos) {\n\t\t\tres = FOUND_SOME;\n\t\t\tif (!dir_emit(ctx, dirent->name, dirent->namelen,\n\t\t\t\t      dirent->ino, dirent->type))\n\t\t\t\treturn FOUND_ALL;\n\t\t\tctx->pos = dirent->off;\n\t\t}\n\t\tff->readdir.pos = dirent->off;\n\t\tff->readdir.cache_off += reclen;\n\n\t\toffset += reclen;\n\t}\n\n\treturn res;\n}\n\nstatic void fuse_rdc_reset(struct inode *inode)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tfi->rdc.cached = false;\n\tfi->rdc.version++;\n\tfi->rdc.size = 0;\n\tfi->rdc.pos = 0;\n}\n\n#define UNCACHED 1\n\nstatic int fuse_readdir_cached(struct file *file, struct dir_context *ctx)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tenum fuse_parse_result res;\n\tpgoff_t index;\n\tunsigned int size;\n\tstruct page *page;\n\tvoid *addr;\n\n\t \n\tif (ff->readdir.pos != ctx->pos) {\n\t\tff->readdir.pos = 0;\n\t\tff->readdir.cache_off = 0;\n\t}\n\n\t \n\tif (!ctx->pos && fc->auto_inval_data) {\n\t\tint err = fuse_update_attributes(inode, file, STATX_MTIME);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\nretry:\n\tspin_lock(&fi->rdc.lock);\nretry_locked:\n\tif (!fi->rdc.cached) {\n\t\t \n\t\tif (!ctx->pos && !fi->rdc.size) {\n\t\t\tfi->rdc.mtime = inode->i_mtime;\n\t\t\tfi->rdc.iversion = inode_query_iversion(inode);\n\t\t}\n\t\tspin_unlock(&fi->rdc.lock);\n\t\treturn UNCACHED;\n\t}\n\t \n\tif (!ctx->pos) {\n\t\tif (inode_peek_iversion(inode) != fi->rdc.iversion ||\n\t\t    !timespec64_equal(&fi->rdc.mtime, &inode->i_mtime)) {\n\t\t\tfuse_rdc_reset(inode);\n\t\t\tgoto retry_locked;\n\t\t}\n\t}\n\n\t \n\tif (ff->readdir.version != fi->rdc.version) {\n\t\tff->readdir.pos = 0;\n\t\tff->readdir.cache_off = 0;\n\t}\n\t \n\tif (ff->readdir.pos == 0)\n\t\tff->readdir.version = fi->rdc.version;\n\n\tWARN_ON(fi->rdc.size < ff->readdir.cache_off);\n\n\tindex = ff->readdir.cache_off >> PAGE_SHIFT;\n\n\tif (index == (fi->rdc.size >> PAGE_SHIFT))\n\t\tsize = fi->rdc.size & ~PAGE_MASK;\n\telse\n\t\tsize = PAGE_SIZE;\n\tspin_unlock(&fi->rdc.lock);\n\n\t \n\tif ((ff->readdir.cache_off & ~PAGE_MASK) == size)\n\t\treturn 0;\n\n\tpage = find_get_page_flags(file->f_mapping, index,\n\t\t\t\t   FGP_ACCESSED | FGP_LOCK);\n\t \n\tif (page && !PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\t}\n\tspin_lock(&fi->rdc.lock);\n\tif (!page) {\n\t\t \n\t\tif (fi->rdc.version == ff->readdir.version)\n\t\t\tfuse_rdc_reset(inode);\n\t\tgoto retry_locked;\n\t}\n\n\t \n\tif (ff->readdir.version != fi->rdc.version) {\n\t\tspin_unlock(&fi->rdc.lock);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tgoto retry;\n\t}\n\tspin_unlock(&fi->rdc.lock);\n\n\t \n\taddr = kmap_local_page(page);\n\tres = fuse_parse_cache(ff, addr, size, ctx);\n\tkunmap_local(addr);\n\tunlock_page(page);\n\tput_page(page);\n\n\tif (res == FOUND_ERR)\n\t\treturn -EIO;\n\n\tif (res == FOUND_ALL)\n\t\treturn 0;\n\n\tif (size == PAGE_SIZE) {\n\t\t \n\t\tff->readdir.cache_off = ALIGN(ff->readdir.cache_off, PAGE_SIZE);\n\t\tgoto retry;\n\t}\n\n\t \n\treturn res == FOUND_SOME ? 0 : UNCACHED;\n}\n\nint fuse_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tint err;\n\n\tif (fuse_is_bad(inode))\n\t\treturn -EIO;\n\n\tmutex_lock(&ff->readdir.lock);\n\n\terr = UNCACHED;\n\tif (ff->open_flags & FOPEN_CACHE_DIR)\n\t\terr = fuse_readdir_cached(file, ctx);\n\tif (err == UNCACHED)\n\t\terr = fuse_readdir_uncached(file, ctx);\n\n\tmutex_unlock(&ff->readdir.lock);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}