{
  "module_name": "fuse_i.h",
  "hash_id": "c9a99483ec2b096e0339025e8a9807612099e2030191ca6099a9eda131720287",
  "original_prompt": "Ingested from linux-6.6.14/fs/fuse/fuse_i.h",
  "human_readable_source": " \n\n#ifndef _FS_FUSE_I_H\n#define _FS_FUSE_I_H\n\n#ifndef pr_fmt\n# define pr_fmt(fmt) \"fuse: \" fmt\n#endif\n\n#include <linux/fuse.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/rwsem.h>\n#include <linux/rbtree.h>\n#include <linux/poll.h>\n#include <linux/workqueue.h>\n#include <linux/kref.h>\n#include <linux/xattr.h>\n#include <linux/pid_namespace.h>\n#include <linux/refcount.h>\n#include <linux/user_namespace.h>\n\n \n#define FUSE_DEFAULT_MAX_PAGES_PER_REQ 32\n\n \n#define FUSE_MAX_MAX_PAGES 256\n\n \n#define FUSE_NOWRITE INT_MIN\n\n \n#define FUSE_NAME_MAX 1024\n\n \n#define FUSE_CTL_NUM_DENTRIES 5\n\n \nextern struct list_head fuse_conn_list;\n\n \nextern struct mutex fuse_mutex;\n\n \nextern unsigned max_user_bgreq;\nextern unsigned max_user_congthresh;\n\n \nstruct fuse_forget_link {\n\tstruct fuse_forget_one forget_one;\n\tstruct fuse_forget_link *next;\n};\n\n \nstruct fuse_submount_lookup {\n\t \n\trefcount_t count;\n\n\t \n\tu64 nodeid;\n\n\t \n\tstruct fuse_forget_link *forget;\n};\n\n \nstruct fuse_inode {\n\t \n\tstruct inode inode;\n\n\t \n\tu64 nodeid;\n\n\t \n\tu64 nlookup;\n\n\t \n\tstruct fuse_forget_link *forget;\n\n\t \n\tu64 i_time;\n\n\t \n\tu32 inval_mask;\n\n\t \n\tumode_t orig_i_mode;\n\n\t \n\tstruct timespec64 i_btime;\n\n\t \n\tu64 orig_ino;\n\n\t \n\tu64 attr_version;\n\n\tunion {\n\t\t \n\t\tstruct {\n\t\t\t \n\t\t\tstruct list_head write_files;\n\n\t\t\t \n\t\t\tstruct list_head queued_writes;\n\n\t\t\t \n\t\t\tint writectr;\n\n\t\t\t \n\t\t\twait_queue_head_t page_waitq;\n\n\t\t\t \n\t\t\tstruct rb_root writepages;\n\t\t};\n\n\t\t \n\t\tstruct {\n\t\t\t \n\t\t\tbool cached;\n\n\t\t\t \n\t\t\tloff_t size;\n\n\t\t\t \n\t\t\tloff_t pos;\n\n\t\t\t \n\t\t\tu64 version;\n\n\t\t\t \n\t\t\tstruct timespec64 mtime;\n\n\t\t\t \n\t\t\tu64 iversion;\n\n\t\t\t \n\t\t\tspinlock_t lock;\n\t\t} rdc;\n\t};\n\n\t \n\tunsigned long state;\n\n\t \n\tstruct mutex mutex;\n\n\t \n\tspinlock_t lock;\n\n#ifdef CONFIG_FUSE_DAX\n\t \n\tstruct fuse_inode_dax *dax;\n#endif\n\t \n\tstruct fuse_submount_lookup *submount_lookup;\n};\n\n \nenum {\n\t \n\tFUSE_I_ADVISE_RDPLUS,\n\t \n\tFUSE_I_INIT_RDPLUS,\n\t \n\tFUSE_I_SIZE_UNSTABLE,\n\t \n\tFUSE_I_BAD,\n\t \n\tFUSE_I_BTIME,\n};\n\nstruct fuse_conn;\nstruct fuse_mount;\nstruct fuse_release_args;\n\n \nstruct fuse_file {\n\t \n\tstruct fuse_mount *fm;\n\n\t \n\tstruct fuse_release_args *release_args;\n\n\t \n\tu64 kh;\n\n\t \n\tu64 fh;\n\n\t \n\tu64 nodeid;\n\n\t \n\trefcount_t count;\n\n\t \n\tu32 open_flags;\n\n\t \n\tstruct list_head write_entry;\n\n\t \n\tstruct {\n\t\t \n\t\tstruct mutex lock;\n\n\t\t \n\t\tloff_t pos;\n\n\t\t \n\t\tloff_t cache_off;\n\n\t\t \n\t\tu64 version;\n\n\t} readdir;\n\n\t \n\tstruct rb_node polled_node;\n\n\t \n\twait_queue_head_t poll_wait;\n\n\t \n\tbool flock:1;\n};\n\n \nstruct fuse_in_arg {\n\tunsigned size;\n\tconst void *value;\n};\n\n \nstruct fuse_arg {\n\tunsigned size;\n\tvoid *value;\n};\n\n \nstruct fuse_page_desc {\n\tunsigned int length;\n\tunsigned int offset;\n};\n\nstruct fuse_args {\n\tuint64_t nodeid;\n\tuint32_t opcode;\n\tuint8_t in_numargs;\n\tuint8_t out_numargs;\n\tuint8_t ext_idx;\n\tbool force:1;\n\tbool noreply:1;\n\tbool nocreds:1;\n\tbool in_pages:1;\n\tbool out_pages:1;\n\tbool user_pages:1;\n\tbool out_argvar:1;\n\tbool page_zeroing:1;\n\tbool page_replace:1;\n\tbool may_block:1;\n\tbool is_ext:1;\n\tstruct fuse_in_arg in_args[3];\n\tstruct fuse_arg out_args[2];\n\tvoid (*end)(struct fuse_mount *fm, struct fuse_args *args, int error);\n};\n\nstruct fuse_args_pages {\n\tstruct fuse_args args;\n\tstruct page **pages;\n\tstruct fuse_page_desc *descs;\n\tunsigned int num_pages;\n};\n\n#define FUSE_ARGS(args) struct fuse_args args = {}\n\n \nstruct fuse_io_priv {\n\tstruct kref refcnt;\n\tint async;\n\tspinlock_t lock;\n\tunsigned reqs;\n\tssize_t bytes;\n\tsize_t size;\n\t__u64 offset;\n\tbool write;\n\tbool should_dirty;\n\tint err;\n\tstruct kiocb *iocb;\n\tstruct completion *done;\n\tbool blocking;\n};\n\n#define FUSE_IO_PRIV_SYNC(i) \\\n{\t\t\t\t\t\\\n\t.refcnt = KREF_INIT(1),\t\t\\\n\t.async = 0,\t\t\t\\\n\t.iocb = i,\t\t\t\\\n}\n\n \nenum fuse_req_flag {\n\tFR_ISREPLY,\n\tFR_FORCE,\n\tFR_BACKGROUND,\n\tFR_WAITING,\n\tFR_ABORTED,\n\tFR_INTERRUPTED,\n\tFR_LOCKED,\n\tFR_PENDING,\n\tFR_SENT,\n\tFR_FINISHED,\n\tFR_PRIVATE,\n\tFR_ASYNC,\n};\n\n \nstruct fuse_req {\n\t \n\tstruct list_head list;\n\n\t \n\tstruct list_head intr_entry;\n\n\t \n\tstruct fuse_args *args;\n\n\t \n\trefcount_t count;\n\n\t \n\tunsigned long flags;\n\n\t \n\tstruct {\n\t\tstruct fuse_in_header h;\n\t} in;\n\n\t \n\tstruct {\n\t\tstruct fuse_out_header h;\n\t} out;\n\n\t \n\twait_queue_head_t waitq;\n\n#if IS_ENABLED(CONFIG_VIRTIO_FS)\n\t \n\tvoid *argbuf;\n#endif\n\n\t \n\tstruct fuse_mount *fm;\n};\n\nstruct fuse_iqueue;\n\n \nstruct fuse_iqueue_ops {\n\t \n\tvoid (*wake_forget_and_unlock)(struct fuse_iqueue *fiq)\n\t\t__releases(fiq->lock);\n\n\t \n\tvoid (*wake_interrupt_and_unlock)(struct fuse_iqueue *fiq)\n\t\t__releases(fiq->lock);\n\n\t \n\tvoid (*wake_pending_and_unlock)(struct fuse_iqueue *fiq)\n\t\t__releases(fiq->lock);\n\n\t \n\tvoid (*release)(struct fuse_iqueue *fiq);\n};\n\n \nextern const struct fuse_iqueue_ops fuse_dev_fiq_ops;\n\nstruct fuse_iqueue {\n\t \n\tunsigned connected;\n\n\t \n\tspinlock_t lock;\n\n\t \n\twait_queue_head_t waitq;\n\n\t \n\tu64 reqctr;\n\n\t \n\tstruct list_head pending;\n\n\t \n\tstruct list_head interrupts;\n\n\t \n\tstruct fuse_forget_link forget_list_head;\n\tstruct fuse_forget_link *forget_list_tail;\n\n\t \n\tint forget_batch;\n\n\t \n\tstruct fasync_struct *fasync;\n\n\t \n\tconst struct fuse_iqueue_ops *ops;\n\n\t \n\tvoid *priv;\n};\n\n#define FUSE_PQ_HASH_BITS 8\n#define FUSE_PQ_HASH_SIZE (1 << FUSE_PQ_HASH_BITS)\n\nstruct fuse_pqueue {\n\t \n\tunsigned connected;\n\n\t \n\tspinlock_t lock;\n\n\t \n\tstruct list_head *processing;\n\n\t \n\tstruct list_head io;\n};\n\n \nstruct fuse_dev {\n\t \n\tstruct fuse_conn *fc;\n\n\t \n\tstruct fuse_pqueue pq;\n\n\t \n\tstruct list_head entry;\n};\n\nenum fuse_dax_mode {\n\tFUSE_DAX_INODE_DEFAULT,\t \n\tFUSE_DAX_ALWAYS,\t \n\tFUSE_DAX_NEVER,\t\t \n\tFUSE_DAX_INODE_USER,\t \n};\n\nstatic inline bool fuse_is_inode_dax_mode(enum fuse_dax_mode mode)\n{\n\treturn mode == FUSE_DAX_INODE_DEFAULT || mode == FUSE_DAX_INODE_USER;\n}\n\nstruct fuse_fs_context {\n\tint fd;\n\tstruct file *file;\n\tunsigned int rootmode;\n\tkuid_t user_id;\n\tkgid_t group_id;\n\tbool is_bdev:1;\n\tbool fd_present:1;\n\tbool rootmode_present:1;\n\tbool user_id_present:1;\n\tbool group_id_present:1;\n\tbool default_permissions:1;\n\tbool allow_other:1;\n\tbool destroy:1;\n\tbool no_control:1;\n\tbool no_force_umount:1;\n\tbool legacy_opts_show:1;\n\tenum fuse_dax_mode dax_mode;\n\tunsigned int max_read;\n\tunsigned int blksize;\n\tconst char *subtype;\n\n\t \n\tstruct dax_device *dax_dev;\n\n\t \n\tvoid **fudptr;\n};\n\nstruct fuse_sync_bucket {\n\t \n\tatomic_t count;\n\twait_queue_head_t waitq;\n\tstruct rcu_head rcu;\n};\n\n \nstruct fuse_conn {\n\t \n\tspinlock_t lock;\n\n\t \n\trefcount_t count;\n\n\t \n\tatomic_t dev_count;\n\n\tstruct rcu_head rcu;\n\n\t \n\tkuid_t user_id;\n\n\t \n\tkgid_t group_id;\n\n\t \n\tstruct pid_namespace *pid_ns;\n\n\t \n\tstruct user_namespace *user_ns;\n\n\t \n\tunsigned max_read;\n\n\t \n\tunsigned max_write;\n\n\t \n\tunsigned int max_pages;\n\n\t \n\tunsigned int max_pages_limit;\n\n\t \n\tstruct fuse_iqueue iq;\n\n\t \n\tatomic64_t khctr;\n\n\t \n\tstruct rb_root polled_files;\n\n\t \n\tunsigned max_background;\n\n\t \n\tunsigned congestion_threshold;\n\n\t \n\tunsigned num_background;\n\n\t \n\tunsigned active_background;\n\n\t \n\tstruct list_head bg_queue;\n\n\t \n\tspinlock_t bg_lock;\n\n\t \n\tint initialized;\n\n\t \n\tint blocked;\n\n\t \n\twait_queue_head_t blocked_waitq;\n\n\t \n\tunsigned connected;\n\n\t \n\tbool aborted;\n\n\t \n\tunsigned conn_error:1;\n\n\t \n\tunsigned conn_init:1;\n\n\t \n\tunsigned async_read:1;\n\n\t \n\tunsigned abort_err:1;\n\n\t \n\tunsigned atomic_o_trunc:1;\n\n\t \n\tunsigned export_support:1;\n\n\t \n\tunsigned writeback_cache:1;\n\n\t \n\tunsigned parallel_dirops:1;\n\n\t \n\tunsigned handle_killpriv:1;\n\n\t \n\tunsigned cache_symlinks:1;\n\n\t \n\tunsigned int legacy_opts_show:1;\n\n\t \n\tunsigned handle_killpriv_v2:1;\n\n\t \n\n\t \n\tunsigned no_open:1;\n\n\t \n\tunsigned no_opendir:1;\n\n\t \n\tunsigned no_fsync:1;\n\n\t \n\tunsigned no_fsyncdir:1;\n\n\t \n\tunsigned no_flush:1;\n\n\t \n\tunsigned no_setxattr:1;\n\n\t \n\tunsigned setxattr_ext:1;\n\n\t \n\tunsigned no_getxattr:1;\n\n\t \n\tunsigned no_listxattr:1;\n\n\t \n\tunsigned no_removexattr:1;\n\n\t \n\tunsigned no_lock:1;\n\n\t \n\tunsigned no_access:1;\n\n\t \n\tunsigned no_create:1;\n\n\t \n\tunsigned no_interrupt:1;\n\n\t \n\tunsigned no_bmap:1;\n\n\t \n\tunsigned no_poll:1;\n\n\t \n\tunsigned big_writes:1;\n\n\t \n\tunsigned dont_mask:1;\n\n\t \n\tunsigned no_flock:1;\n\n\t \n\tunsigned no_fallocate:1;\n\n\t \n\tunsigned no_rename2:1;\n\n\t \n\tunsigned auto_inval_data:1;\n\n\t \n\tunsigned explicit_inval_data:1;\n\n\t \n\tunsigned do_readdirplus:1;\n\n\t \n\tunsigned readdirplus_auto:1;\n\n\t \n\tunsigned async_dio:1;\n\n\t \n\tunsigned no_lseek:1;\n\n\t \n\tunsigned posix_acl:1;\n\n\t \n\tunsigned default_permissions:1;\n\n\t \n\tunsigned allow_other:1;\n\n\t \n\tunsigned no_copy_file_range:1;\n\n\t \n\tunsigned int destroy:1;\n\n\t \n\tunsigned int delete_stale:1;\n\n\t \n\tunsigned int no_control:1;\n\n\t \n\tunsigned int no_force_umount:1;\n\n\t \n\tunsigned int auto_submounts:1;\n\n\t \n\tunsigned int sync_fs:1;\n\n\t \n\tunsigned int init_security:1;\n\n\t \n\tunsigned int create_supp_group:1;\n\n\t \n\tunsigned int inode_dax:1;\n\n\t \n\tunsigned int no_tmpfile:1;\n\n\t \n\tunsigned int direct_io_allow_mmap:1;\n\n\t \n\tunsigned int no_statx:1;\n\n\t \n\tatomic_t num_waiting;\n\n\t \n\tunsigned minor;\n\n\t \n\tstruct list_head entry;\n\n\t \n\tdev_t dev;\n\n\t \n\tstruct dentry *ctl_dentry[FUSE_CTL_NUM_DENTRIES];\n\n\t \n\tint ctl_ndents;\n\n\t \n\tu32 scramble_key[4];\n\n\t \n\tatomic64_t attr_version;\n\n\t \n\tvoid (*release)(struct fuse_conn *);\n\n\t \n\tstruct rw_semaphore killsb;\n\n\t \n\tstruct list_head devices;\n\n#ifdef CONFIG_FUSE_DAX\n\t \n\tenum fuse_dax_mode dax_mode;\n\n\t \n\tstruct fuse_conn_dax *dax;\n#endif\n\n\t \n\tstruct list_head mounts;\n\n\t \n\tstruct fuse_sync_bucket __rcu *curr_bucket;\n};\n\n \nstruct fuse_mount {\n\t \n\tstruct fuse_conn *fc;\n\n\t \n\tstruct super_block *sb;\n\n\t \n\tstruct list_head fc_entry;\n};\n\nstatic inline struct fuse_mount *get_fuse_mount_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\nstatic inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn get_fuse_mount_super(sb)->fc;\n}\n\nstatic inline struct fuse_mount *get_fuse_mount(struct inode *inode)\n{\n\treturn get_fuse_mount_super(inode->i_sb);\n}\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_mount_super(inode->i_sb)->fc;\n}\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}\n\nstatic inline int invalid_nodeid(u64 nodeid)\n{\n\treturn !nodeid || nodeid == FUSE_ROOT_ID;\n}\n\nstatic inline u64 fuse_get_attr_version(struct fuse_conn *fc)\n{\n\treturn atomic64_read(&fc->attr_version);\n}\n\nstatic inline bool fuse_stale_inode(const struct inode *inode, int generation,\n\t\t\t\t    struct fuse_attr *attr)\n{\n\treturn inode->i_generation != generation ||\n\t\tinode_wrong_type(inode, attr->mode);\n}\n\nstatic inline void fuse_make_bad(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\tset_bit(FUSE_I_BAD, &get_fuse_inode(inode)->state);\n}\n\nstatic inline bool fuse_is_bad(struct inode *inode)\n{\n\treturn unlikely(test_bit(FUSE_I_BAD, &get_fuse_inode(inode)->state));\n}\n\nstatic inline struct page **fuse_pages_alloc(unsigned int npages, gfp_t flags,\n\t\t\t\t\t     struct fuse_page_desc **desc)\n{\n\tstruct page **pages;\n\n\tpages = kzalloc(npages * (sizeof(struct page *) +\n\t\t\t\t  sizeof(struct fuse_page_desc)), flags);\n\t*desc = (void *) (pages + npages);\n\n\treturn pages;\n}\n\nstatic inline void fuse_page_descs_length_init(struct fuse_page_desc *descs,\n\t\t\t\t\t       unsigned int index,\n\t\t\t\t\t       unsigned int nr_pages)\n{\n\tint i;\n\n\tfor (i = index; i < index + nr_pages; i++)\n\t\tdescs[i].length = PAGE_SIZE - descs[i].offset;\n}\n\nstatic inline void fuse_sync_bucket_dec(struct fuse_sync_bucket *bucket)\n{\n\t \n\trcu_read_lock();\n\tif (atomic_dec_and_test(&bucket->count))\n\t\twake_up(&bucket->waitq);\n\trcu_read_unlock();\n}\n\n \nextern const struct file_operations fuse_dev_operations;\n\nextern const struct dentry_operations fuse_dentry_operations;\nextern const struct dentry_operations fuse_root_dentry_operations;\n\n \nstruct inode *fuse_iget(struct super_block *sb, u64 nodeid,\n\t\t\tint generation, struct fuse_attr *attr,\n\t\t\tu64 attr_valid, u64 attr_version);\n\nint fuse_lookup_name(struct super_block *sb, u64 nodeid, const struct qstr *name,\n\t\t     struct fuse_entry_out *outarg, struct inode **inode);\n\n \nvoid fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,\n\t\t       u64 nodeid, u64 nlookup);\n\nstruct fuse_forget_link *fuse_alloc_forget(void);\n\nstruct fuse_forget_link *fuse_dequeue_forget(struct fuse_iqueue *fiq,\n\t\t\t\t\t     unsigned int max,\n\t\t\t\t\t     unsigned int *countp);\n\n \nstruct fuse_io_args {\n\tunion {\n\t\tstruct {\n\t\t\tstruct fuse_read_in in;\n\t\t\tu64 attr_ver;\n\t\t} read;\n\t\tstruct {\n\t\t\tstruct fuse_write_in in;\n\t\t\tstruct fuse_write_out out;\n\t\t\tbool page_locked;\n\t\t} write;\n\t};\n\tstruct fuse_args_pages ap;\n\tstruct fuse_io_priv *io;\n\tstruct fuse_file *ff;\n};\n\nvoid fuse_read_args_fill(struct fuse_io_args *ia, struct file *file, loff_t pos,\n\t\t\t size_t count, int opcode);\n\n\n \nint fuse_open_common(struct inode *inode, struct file *file, bool isdir);\n\nstruct fuse_file *fuse_file_alloc(struct fuse_mount *fm);\nvoid fuse_file_free(struct fuse_file *ff);\nvoid fuse_finish_open(struct inode *inode, struct file *file);\n\nvoid fuse_sync_release(struct fuse_inode *fi, struct fuse_file *ff,\n\t\t       unsigned int flags);\n\n \nvoid fuse_release_common(struct file *file, bool isdir);\n\n \nint fuse_fsync_common(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync, int opcode);\n\n \nint fuse_notify_poll_wakeup(struct fuse_conn *fc,\n\t\t\t    struct fuse_notify_poll_wakeup_out *outarg);\n\n \nvoid fuse_init_file_inode(struct inode *inode, unsigned int flags);\n\n \nvoid fuse_init_common(struct inode *inode);\n\n \nvoid fuse_init_dir(struct inode *inode);\n\n \nvoid fuse_init_symlink(struct inode *inode);\n\n \nvoid fuse_change_attributes(struct inode *inode, struct fuse_attr *attr,\n\t\t\t    struct fuse_statx *sx,\n\t\t\t    u64 attr_valid, u64 attr_version);\n\nvoid fuse_change_attributes_common(struct inode *inode, struct fuse_attr *attr,\n\t\t\t\t   struct fuse_statx *sx,\n\t\t\t\t   u64 attr_valid, u32 cache_mask);\n\nu32 fuse_get_cache_mask(struct inode *inode);\n\n \nint fuse_dev_init(void);\n\n \nvoid fuse_dev_cleanup(void);\n\nint fuse_ctl_init(void);\nvoid __exit fuse_ctl_cleanup(void);\n\n \nssize_t fuse_simple_request(struct fuse_mount *fm, struct fuse_args *args);\nint fuse_simple_background(struct fuse_mount *fm, struct fuse_args *args,\n\t\t\t   gfp_t gfp_flags);\n\n \nvoid fuse_request_end(struct fuse_req *req);\n\n \nvoid fuse_abort_conn(struct fuse_conn *fc);\nvoid fuse_wait_aborted(struct fuse_conn *fc);\n\n \n\n \n#define FUSE_STATX_MODIFY\t(STATX_MTIME | STATX_CTIME | STATX_BLOCKS)\n\n \n#define FUSE_STATX_MODSIZE\t(FUSE_STATX_MODIFY | STATX_SIZE)\n\nvoid fuse_invalidate_attr(struct inode *inode);\nvoid fuse_invalidate_attr_mask(struct inode *inode, u32 mask);\n\nvoid fuse_invalidate_entry_cache(struct dentry *entry);\n\nvoid fuse_invalidate_atime(struct inode *inode);\n\nu64 fuse_time_to_jiffies(u64 sec, u32 nsec);\n#define ATTR_TIMEOUT(o) \\\n\tfuse_time_to_jiffies((o)->attr_valid, (o)->attr_valid_nsec)\n\nvoid fuse_change_entry_timeout(struct dentry *entry, struct fuse_entry_out *o);\n\n \nstruct fuse_conn *fuse_conn_get(struct fuse_conn *fc);\n\n \nvoid fuse_conn_init(struct fuse_conn *fc, struct fuse_mount *fm,\n\t\t    struct user_namespace *user_ns,\n\t\t    const struct fuse_iqueue_ops *fiq_ops, void *fiq_priv);\n\n \nvoid fuse_conn_put(struct fuse_conn *fc);\n\nstruct fuse_dev *fuse_dev_alloc_install(struct fuse_conn *fc);\nstruct fuse_dev *fuse_dev_alloc(void);\nvoid fuse_dev_install(struct fuse_dev *fud, struct fuse_conn *fc);\nvoid fuse_dev_free(struct fuse_dev *fud);\nvoid fuse_send_init(struct fuse_mount *fm);\n\n \nint fuse_fill_super_common(struct super_block *sb, struct fuse_fs_context *ctx);\n\n \nbool fuse_mount_remove(struct fuse_mount *fm);\n\n \nint fuse_init_fs_context_submount(struct fs_context *fsc);\n\n \nvoid fuse_conn_destroy(struct fuse_mount *fm);\n\n \nvoid fuse_mount_destroy(struct fuse_mount *fm);\n\n \nint fuse_ctl_add_conn(struct fuse_conn *fc);\n\n \nvoid fuse_ctl_remove_conn(struct fuse_conn *fc);\n\n \nint fuse_valid_type(int m);\n\nbool fuse_invalid_attr(struct fuse_attr *attr);\n\n \nbool fuse_allow_current_process(struct fuse_conn *fc);\n\nu64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id);\n\nvoid fuse_flush_time_update(struct inode *inode);\nvoid fuse_update_ctime(struct inode *inode);\n\nint fuse_update_attributes(struct inode *inode, struct file *file, u32 mask);\n\nvoid fuse_flush_writepages(struct inode *inode);\n\nvoid fuse_set_nowrite(struct inode *inode);\nvoid fuse_release_nowrite(struct inode *inode);\n\n \nstruct inode *fuse_ilookup(struct fuse_conn *fc, u64 nodeid,\n\t\t\t   struct fuse_mount **fm);\n\n \nint fuse_reverse_inval_inode(struct fuse_conn *fc, u64 nodeid,\n\t\t\t     loff_t offset, loff_t len);\n\n \nint fuse_reverse_inval_entry(struct fuse_conn *fc, u64 parent_nodeid,\n\t\t\t     u64 child_nodeid, struct qstr *name, u32 flags);\n\nint fuse_do_open(struct fuse_mount *fm, u64 nodeid, struct file *file,\n\t\t bool isdir);\n\n \n\n \n#define FUSE_DIO_WRITE (1 << 0)\n\n \n#define FUSE_DIO_CUSE  (1 << 1)\n\nssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter *iter,\n\t\t       loff_t *ppos, int flags);\nlong fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags);\nlong fuse_ioctl_common(struct file *file, unsigned int cmd,\n\t\t       unsigned long arg, unsigned int flags);\n__poll_t fuse_file_poll(struct file *file, poll_table *wait);\nint fuse_dev_release(struct inode *inode, struct file *file);\n\nbool fuse_write_update_attr(struct inode *inode, loff_t pos, ssize_t written);\n\nint fuse_flush_times(struct inode *inode, struct fuse_file *ff);\nint fuse_write_inode(struct inode *inode, struct writeback_control *wbc);\n\nint fuse_do_setattr(struct dentry *dentry, struct iattr *attr,\n\t\t    struct file *file);\n\nvoid fuse_set_initialized(struct fuse_conn *fc);\n\nvoid fuse_unlock_inode(struct inode *inode, bool locked);\nbool fuse_lock_inode(struct inode *inode);\n\nint fuse_setxattr(struct inode *inode, const char *name, const void *value,\n\t\t  size_t size, int flags, unsigned int extra_flags);\nssize_t fuse_getxattr(struct inode *inode, const char *name, void *value,\n\t\t      size_t size);\nssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size);\nint fuse_removexattr(struct inode *inode, const char *name);\nextern const struct xattr_handler *fuse_xattr_handlers[];\n\nstruct posix_acl;\nstruct posix_acl *fuse_get_inode_acl(struct inode *inode, int type, bool rcu);\nstruct posix_acl *fuse_get_acl(struct mnt_idmap *idmap,\n\t\t\t       struct dentry *dentry, int type);\nint fuse_set_acl(struct mnt_idmap *, struct dentry *dentry,\n\t\t struct posix_acl *acl, int type);\n\n \nint fuse_readdir(struct file *file, struct dir_context *ctx);\n\n \nunsigned int fuse_len_args(unsigned int numargs, struct fuse_arg *args);\n\n \nu64 fuse_get_unique(struct fuse_iqueue *fiq);\nvoid fuse_free_conn(struct fuse_conn *fc);\n\n \n\n#define FUSE_IS_DAX(inode) (IS_ENABLED(CONFIG_FUSE_DAX) && IS_DAX(inode))\n\nssize_t fuse_dax_read_iter(struct kiocb *iocb, struct iov_iter *to);\nssize_t fuse_dax_write_iter(struct kiocb *iocb, struct iov_iter *from);\nint fuse_dax_mmap(struct file *file, struct vm_area_struct *vma);\nint fuse_dax_break_layouts(struct inode *inode, u64 dmap_start, u64 dmap_end);\nint fuse_dax_conn_alloc(struct fuse_conn *fc, enum fuse_dax_mode mode,\n\t\t\tstruct dax_device *dax_dev);\nvoid fuse_dax_conn_free(struct fuse_conn *fc);\nbool fuse_dax_inode_alloc(struct super_block *sb, struct fuse_inode *fi);\nvoid fuse_dax_inode_init(struct inode *inode, unsigned int flags);\nvoid fuse_dax_inode_cleanup(struct inode *inode);\nvoid fuse_dax_dontcache(struct inode *inode, unsigned int flags);\nbool fuse_dax_check_alignment(struct fuse_conn *fc, unsigned int map_alignment);\nvoid fuse_dax_cancel_work(struct fuse_conn *fc);\n\n \nlong fuse_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg);\nlong fuse_file_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg);\nint fuse_fileattr_get(struct dentry *dentry, struct fileattr *fa);\nint fuse_fileattr_set(struct mnt_idmap *idmap,\n\t\t      struct dentry *dentry, struct fileattr *fa);\n\n \n\nstruct fuse_file *fuse_file_open(struct fuse_mount *fm, u64 nodeid,\n\t\t\t\t unsigned int open_flags, bool isdir);\nvoid fuse_file_release(struct inode *inode, struct fuse_file *ff,\n\t\t       unsigned int open_flags, fl_owner_t id, bool isdir);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}