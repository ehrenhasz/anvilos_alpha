{
  "module_name": "acl.c",
  "hash_id": "f074f527ef36348e6016934b1bc9cd4a1ba1d810648e004c53e4c5ad2d1d67f8",
  "original_prompt": "Ingested from linux-6.6.14/fs/fuse/acl.c",
  "human_readable_source": " \n\n#include \"fuse_i.h\"\n\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n\nstatic struct posix_acl *__fuse_get_acl(struct fuse_conn *fc,\n\t\t\t\t\tstruct mnt_idmap *idmap,\n\t\t\t\t\tstruct inode *inode, int type, bool rcu)\n{\n\tint size;\n\tconst char *name;\n\tvoid *value = NULL;\n\tstruct posix_acl *acl;\n\n\tif (rcu)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tif (fuse_is_bad(inode))\n\t\treturn ERR_PTR(-EIO);\n\n\tif (fc->no_getxattr)\n\t\treturn NULL;\n\n\tif (type == ACL_TYPE_ACCESS)\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\telse if (type == ACL_TYPE_DEFAULT)\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\telse\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tvalue = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!value)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsize = fuse_getxattr(inode, name, value, PAGE_SIZE);\n\tif (size > 0)\n\t\tacl = posix_acl_from_xattr(fc->user_ns, value, size);\n\telse if ((size == 0) || (size == -ENODATA) ||\n\t\t (size == -EOPNOTSUPP && fc->no_getxattr))\n\t\tacl = NULL;\n\telse if (size == -ERANGE)\n\t\tacl = ERR_PTR(-E2BIG);\n\telse\n\t\tacl = ERR_PTR(size);\n\n\tkfree(value);\n\treturn acl;\n}\n\nstatic inline bool fuse_no_acl(const struct fuse_conn *fc,\n\t\t\t       const struct inode *inode)\n{\n\t \n\treturn !fc->posix_acl && (i_user_ns(inode) != &init_user_ns);\n}\n\nstruct posix_acl *fuse_get_acl(struct mnt_idmap *idmap,\n\t\t\t       struct dentry *dentry, int type)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (fuse_no_acl(fc, inode))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\treturn __fuse_get_acl(fc, idmap, inode, type, false);\n}\n\nstruct posix_acl *fuse_get_inode_acl(struct inode *inode, int type, bool rcu)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\t \n\tif (!fc->posix_acl)\n\t\treturn NULL;\n\n\treturn __fuse_get_acl(fc, &nop_mnt_idmap, inode, type, rcu);\n}\n\nint fuse_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t struct posix_acl *acl, int type)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tconst char *name;\n\tint ret;\n\n\tif (fuse_is_bad(inode))\n\t\treturn -EIO;\n\n\tif (fc->no_setxattr || fuse_no_acl(fc, inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (type == ACL_TYPE_ACCESS)\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\telse if (type == ACL_TYPE_DEFAULT)\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\telse\n\t\treturn -EINVAL;\n\n\tif (acl) {\n\t\tunsigned int extra_flags = 0;\n\t\t \n\t\tsize_t size = posix_acl_xattr_size(acl->a_count);\n\t\tvoid *value;\n\n\t\tif (size > PAGE_SIZE)\n\t\t\treturn -E2BIG;\n\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\n\t\tret = posix_acl_to_xattr(fc->user_ns, acl, value, size);\n\t\tif (ret < 0) {\n\t\t\tkfree(value);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (fc->posix_acl &&\n\t\t    !vfsgid_in_group_p(i_gid_into_vfsgid(&nop_mnt_idmap, inode)) &&\n\t\t    !capable_wrt_inode_uidgid(&nop_mnt_idmap, inode, CAP_FSETID))\n\t\t\textra_flags |= FUSE_SETXATTR_ACL_KILL_SGID;\n\n\t\tret = fuse_setxattr(inode, name, value, size, 0, extra_flags);\n\t\tkfree(value);\n\t} else {\n\t\tret = fuse_removexattr(inode, name);\n\t}\n\n\tif (fc->posix_acl) {\n\t\t \n\t\tforget_all_cached_acls(inode);\n\t\tfuse_invalidate_attr(inode);\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}