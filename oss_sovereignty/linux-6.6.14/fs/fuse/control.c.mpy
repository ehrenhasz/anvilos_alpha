{
  "module_name": "control.c",
  "hash_id": "45ac88bd3b0cfbcc1d5d7ffc8e0fdcfb1f7df1f8c771f38b0cff753c6820b009",
  "original_prompt": "Ingested from linux-6.6.14/fs/fuse/control.c",
  "human_readable_source": " \n\n#include \"fuse_i.h\"\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/fs_context.h>\n\n#define FUSE_CTL_SUPER_MAGIC 0x65735543\n\n \nstatic struct super_block *fuse_control_sb;\n\nstatic struct fuse_conn *fuse_ctl_file_conn_get(struct file *file)\n{\n\tstruct fuse_conn *fc;\n\tmutex_lock(&fuse_mutex);\n\tfc = file_inode(file)->i_private;\n\tif (fc)\n\t\tfc = fuse_conn_get(fc);\n\tmutex_unlock(&fuse_mutex);\n\treturn fc;\n}\n\nstatic ssize_t fuse_conn_abort_write(struct file *file, const char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct fuse_conn *fc = fuse_ctl_file_conn_get(file);\n\tif (fc) {\n\t\tif (fc->abort_err)\n\t\t\tfc->aborted = true;\n\t\tfuse_abort_conn(fc);\n\t\tfuse_conn_put(fc);\n\t}\n\treturn count;\n}\n\nstatic ssize_t fuse_conn_waiting_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t len, loff_t *ppos)\n{\n\tchar tmp[32];\n\tsize_t size;\n\n\tif (!*ppos) {\n\t\tlong value;\n\t\tstruct fuse_conn *fc = fuse_ctl_file_conn_get(file);\n\t\tif (!fc)\n\t\t\treturn 0;\n\n\t\tvalue = atomic_read(&fc->num_waiting);\n\t\tfile->private_data = (void *)value;\n\t\tfuse_conn_put(fc);\n\t}\n\tsize = sprintf(tmp, \"%ld\\n\", (long)file->private_data);\n\treturn simple_read_from_buffer(buf, len, ppos, tmp, size);\n}\n\nstatic ssize_t fuse_conn_limit_read(struct file *file, char __user *buf,\n\t\t\t\t    size_t len, loff_t *ppos, unsigned val)\n{\n\tchar tmp[32];\n\tsize_t size = sprintf(tmp, \"%u\\n\", val);\n\n\treturn simple_read_from_buffer(buf, len, ppos, tmp, size);\n}\n\nstatic ssize_t fuse_conn_limit_write(struct file *file, const char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos, unsigned *val,\n\t\t\t\t     unsigned global_limit)\n{\n\tunsigned long t;\n\tunsigned limit = (1 << 16) - 1;\n\tint err;\n\n\tif (*ppos)\n\t\treturn -EINVAL;\n\n\terr = kstrtoul_from_user(buf, count, 0, &t);\n\tif (err)\n\t\treturn err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tlimit = min(limit, global_limit);\n\n\tif (t > limit)\n\t\treturn -EINVAL;\n\n\t*val = t;\n\n\treturn count;\n}\n\nstatic ssize_t fuse_conn_max_background_read(struct file *file,\n\t\t\t\t\t     char __user *buf, size_t len,\n\t\t\t\t\t     loff_t *ppos)\n{\n\tstruct fuse_conn *fc;\n\tunsigned val;\n\n\tfc = fuse_ctl_file_conn_get(file);\n\tif (!fc)\n\t\treturn 0;\n\n\tval = READ_ONCE(fc->max_background);\n\tfuse_conn_put(fc);\n\n\treturn fuse_conn_limit_read(file, buf, len, ppos, val);\n}\n\nstatic ssize_t fuse_conn_max_background_write(struct file *file,\n\t\t\t\t\t      const char __user *buf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tunsigned val;\n\tssize_t ret;\n\n\tret = fuse_conn_limit_write(file, buf, count, ppos, &val,\n\t\t\t\t    max_user_bgreq);\n\tif (ret > 0) {\n\t\tstruct fuse_conn *fc = fuse_ctl_file_conn_get(file);\n\t\tif (fc) {\n\t\t\tspin_lock(&fc->bg_lock);\n\t\t\tfc->max_background = val;\n\t\t\tfc->blocked = fc->num_background >= fc->max_background;\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->bg_lock);\n\t\t\tfuse_conn_put(fc);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t fuse_conn_congestion_threshold_read(struct file *file,\n\t\t\t\t\t\t   char __user *buf, size_t len,\n\t\t\t\t\t\t   loff_t *ppos)\n{\n\tstruct fuse_conn *fc;\n\tunsigned val;\n\n\tfc = fuse_ctl_file_conn_get(file);\n\tif (!fc)\n\t\treturn 0;\n\n\tval = READ_ONCE(fc->congestion_threshold);\n\tfuse_conn_put(fc);\n\n\treturn fuse_conn_limit_read(file, buf, len, ppos, val);\n}\n\nstatic ssize_t fuse_conn_congestion_threshold_write(struct file *file,\n\t\t\t\t\t\t    const char __user *buf,\n\t\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tunsigned val;\n\tstruct fuse_conn *fc;\n\tssize_t ret;\n\n\tret = fuse_conn_limit_write(file, buf, count, ppos, &val,\n\t\t\t\t    max_user_congthresh);\n\tif (ret <= 0)\n\t\tgoto out;\n\tfc = fuse_ctl_file_conn_get(file);\n\tif (!fc)\n\t\tgoto out;\n\n\tdown_read(&fc->killsb);\n\tspin_lock(&fc->bg_lock);\n\tfc->congestion_threshold = val;\n\tspin_unlock(&fc->bg_lock);\n\tup_read(&fc->killsb);\n\tfuse_conn_put(fc);\nout:\n\treturn ret;\n}\n\nstatic const struct file_operations fuse_ctl_abort_ops = {\n\t.open = nonseekable_open,\n\t.write = fuse_conn_abort_write,\n\t.llseek = no_llseek,\n};\n\nstatic const struct file_operations fuse_ctl_waiting_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_waiting_read,\n\t.llseek = no_llseek,\n};\n\nstatic const struct file_operations fuse_conn_max_background_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_max_background_read,\n\t.write = fuse_conn_max_background_write,\n\t.llseek = no_llseek,\n};\n\nstatic const struct file_operations fuse_conn_congestion_threshold_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_congestion_threshold_read,\n\t.write = fuse_conn_congestion_threshold_write,\n\t.llseek = no_llseek,\n};\n\nstatic struct dentry *fuse_ctl_add_dentry(struct dentry *parent,\n\t\t\t\t\t  struct fuse_conn *fc,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  int mode, int nlink,\n\t\t\t\t\t  const struct inode_operations *iop,\n\t\t\t\t\t  const struct file_operations *fop)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tBUG_ON(fc->ctl_ndents >= FUSE_CTL_NUM_DENTRIES);\n\tdentry = d_alloc_name(parent, name);\n\tif (!dentry)\n\t\treturn NULL;\n\n\tinode = new_inode(fuse_control_sb);\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn NULL;\n\t}\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_uid = fc->user_id;\n\tinode->i_gid = fc->group_id;\n\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\t \n\tif (iop)\n\t\tinode->i_op = iop;\n\tinode->i_fop = fop;\n\tset_nlink(inode, nlink);\n\tinode->i_private = fc;\n\td_add(dentry, inode);\n\n\tfc->ctl_dentry[fc->ctl_ndents++] = dentry;\n\n\treturn dentry;\n}\n\n \nint fuse_ctl_add_conn(struct fuse_conn *fc)\n{\n\tstruct dentry *parent;\n\tchar name[32];\n\n\tif (!fuse_control_sb || fc->no_control)\n\t\treturn 0;\n\n\tparent = fuse_control_sb->s_root;\n\tinc_nlink(d_inode(parent));\n\tsprintf(name, \"%u\", fc->dev);\n\tparent = fuse_ctl_add_dentry(parent, fc, name, S_IFDIR | 0500, 2,\n\t\t\t\t     &simple_dir_inode_operations,\n\t\t\t\t     &simple_dir_operations);\n\tif (!parent)\n\t\tgoto err;\n\n\tif (!fuse_ctl_add_dentry(parent, fc, \"waiting\", S_IFREG | 0400, 1,\n\t\t\t\t NULL, &fuse_ctl_waiting_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"abort\", S_IFREG | 0200, 1,\n\t\t\t\t NULL, &fuse_ctl_abort_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"max_background\", S_IFREG | 0600,\n\t\t\t\t 1, NULL, &fuse_conn_max_background_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"congestion_threshold\",\n\t\t\t\t S_IFREG | 0600, 1, NULL,\n\t\t\t\t &fuse_conn_congestion_threshold_ops))\n\t\tgoto err;\n\n\treturn 0;\n\n err:\n\tfuse_ctl_remove_conn(fc);\n\treturn -ENOMEM;\n}\n\n \nvoid fuse_ctl_remove_conn(struct fuse_conn *fc)\n{\n\tint i;\n\n\tif (!fuse_control_sb || fc->no_control)\n\t\treturn;\n\n\tfor (i = fc->ctl_ndents - 1; i >= 0; i--) {\n\t\tstruct dentry *dentry = fc->ctl_dentry[i];\n\t\td_inode(dentry)->i_private = NULL;\n\t\tif (!i) {\n\t\t\t \n\t\t\td_invalidate(dentry);\n\t\t}\n\t\tdput(dentry);\n\t}\n\tdrop_nlink(d_inode(fuse_control_sb->s_root));\n}\n\nstatic int fuse_ctl_fill_super(struct super_block *sb, struct fs_context *fsc)\n{\n\tstatic const struct tree_descr empty_descr = {\"\"};\n\tstruct fuse_conn *fc;\n\tint err;\n\n\terr = simple_fill_super(sb, FUSE_CTL_SUPER_MAGIC, &empty_descr);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&fuse_mutex);\n\tBUG_ON(fuse_control_sb);\n\tfuse_control_sb = sb;\n\tlist_for_each_entry(fc, &fuse_conn_list, entry) {\n\t\terr = fuse_ctl_add_conn(fc);\n\t\tif (err) {\n\t\t\tfuse_control_sb = NULL;\n\t\t\tmutex_unlock(&fuse_mutex);\n\t\t\treturn err;\n\t\t}\n\t}\n\tmutex_unlock(&fuse_mutex);\n\n\treturn 0;\n}\n\nstatic int fuse_ctl_get_tree(struct fs_context *fsc)\n{\n\treturn get_tree_single(fsc, fuse_ctl_fill_super);\n}\n\nstatic const struct fs_context_operations fuse_ctl_context_ops = {\n\t.get_tree\t= fuse_ctl_get_tree,\n};\n\nstatic int fuse_ctl_init_fs_context(struct fs_context *fsc)\n{\n\tfsc->ops = &fuse_ctl_context_ops;\n\treturn 0;\n}\n\nstatic void fuse_ctl_kill_sb(struct super_block *sb)\n{\n\tstruct fuse_conn *fc;\n\n\tmutex_lock(&fuse_mutex);\n\tfuse_control_sb = NULL;\n\tlist_for_each_entry(fc, &fuse_conn_list, entry)\n\t\tfc->ctl_ndents = 0;\n\tmutex_unlock(&fuse_mutex);\n\n\tkill_litter_super(sb);\n}\n\nstatic struct file_system_type fuse_ctl_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fusectl\",\n\t.init_fs_context = fuse_ctl_init_fs_context,\n\t.kill_sb\t= fuse_ctl_kill_sb,\n};\nMODULE_ALIAS_FS(\"fusectl\");\n\nint __init fuse_ctl_init(void)\n{\n\treturn register_filesystem(&fuse_ctl_fs_type);\n}\n\nvoid __exit fuse_ctl_cleanup(void)\n{\n\tunregister_filesystem(&fuse_ctl_fs_type);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}