{
  "module_name": "file.c",
  "hash_id": "54ca563b595248c14e039b570537cb43075dbcf22823a084fa6ebd51f7994731",
  "original_prompt": "Ingested from linux-6.6.14/fs/fuse/file.c",
  "human_readable_source": " \n\n#include \"fuse_i.h\"\n\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/signal.h>\n#include <linux/module.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/uio.h>\n#include <linux/fs.h>\n#include <linux/filelock.h>\n\nstatic int fuse_send_open(struct fuse_mount *fm, u64 nodeid,\n\t\t\t  unsigned int open_flags, int opcode,\n\t\t\t  struct fuse_open_out *outargp)\n{\n\tstruct fuse_open_in inarg;\n\tFUSE_ARGS(args);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.flags = open_flags & ~(O_CREAT | O_EXCL | O_NOCTTY);\n\tif (!fm->fc->atomic_o_trunc)\n\t\tinarg.flags &= ~O_TRUNC;\n\n\tif (fm->fc->handle_killpriv_v2 &&\n\t    (inarg.flags & O_TRUNC) && !capable(CAP_FSETID)) {\n\t\tinarg.open_flags |= FUSE_OPEN_KILL_SUIDGID;\n\t}\n\n\targs.opcode = opcode;\n\targs.nodeid = nodeid;\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.out_numargs = 1;\n\targs.out_args[0].size = sizeof(*outargp);\n\targs.out_args[0].value = outargp;\n\n\treturn fuse_simple_request(fm, &args);\n}\n\nstruct fuse_release_args {\n\tstruct fuse_args args;\n\tstruct fuse_release_in inarg;\n\tstruct inode *inode;\n};\n\nstruct fuse_file *fuse_file_alloc(struct fuse_mount *fm)\n{\n\tstruct fuse_file *ff;\n\n\tff = kzalloc(sizeof(struct fuse_file), GFP_KERNEL_ACCOUNT);\n\tif (unlikely(!ff))\n\t\treturn NULL;\n\n\tff->fm = fm;\n\tff->release_args = kzalloc(sizeof(*ff->release_args),\n\t\t\t\t   GFP_KERNEL_ACCOUNT);\n\tif (!ff->release_args) {\n\t\tkfree(ff);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&ff->write_entry);\n\tmutex_init(&ff->readdir.lock);\n\trefcount_set(&ff->count, 1);\n\tRB_CLEAR_NODE(&ff->polled_node);\n\tinit_waitqueue_head(&ff->poll_wait);\n\n\tff->kh = atomic64_inc_return(&fm->fc->khctr);\n\n\treturn ff;\n}\n\nvoid fuse_file_free(struct fuse_file *ff)\n{\n\tkfree(ff->release_args);\n\tmutex_destroy(&ff->readdir.lock);\n\tkfree(ff);\n}\n\nstatic struct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\trefcount_inc(&ff->count);\n\treturn ff;\n}\n\nstatic void fuse_release_end(struct fuse_mount *fm, struct fuse_args *args,\n\t\t\t     int error)\n{\n\tstruct fuse_release_args *ra = container_of(args, typeof(*ra), args);\n\n\tiput(ra->inode);\n\tkfree(ra);\n}\n\nstatic void fuse_file_put(struct fuse_file *ff, bool sync, bool isdir)\n{\n\tif (refcount_dec_and_test(&ff->count)) {\n\t\tstruct fuse_args *args = &ff->release_args->args;\n\n\t\tif (isdir ? ff->fm->fc->no_opendir : ff->fm->fc->no_open) {\n\t\t\t \n\t\t\tfuse_release_end(ff->fm, args, 0);\n\t\t} else if (sync) {\n\t\t\tfuse_simple_request(ff->fm, args);\n\t\t\tfuse_release_end(ff->fm, args, 0);\n\t\t} else {\n\t\t\targs->end = fuse_release_end;\n\t\t\tif (fuse_simple_background(ff->fm, args,\n\t\t\t\t\t\t   GFP_KERNEL | __GFP_NOFAIL))\n\t\t\t\tfuse_release_end(ff->fm, args, -ENOTCONN);\n\t\t}\n\t\tkfree(ff);\n\t}\n}\n\nstruct fuse_file *fuse_file_open(struct fuse_mount *fm, u64 nodeid,\n\t\t\t\t unsigned int open_flags, bool isdir)\n{\n\tstruct fuse_conn *fc = fm->fc;\n\tstruct fuse_file *ff;\n\tint opcode = isdir ? FUSE_OPENDIR : FUSE_OPEN;\n\n\tff = fuse_file_alloc(fm);\n\tif (!ff)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tff->fh = 0;\n\t \n\tff->open_flags = FOPEN_KEEP_CACHE | (isdir ? FOPEN_CACHE_DIR : 0);\n\tif (isdir ? !fc->no_opendir : !fc->no_open) {\n\t\tstruct fuse_open_out outarg;\n\t\tint err;\n\n\t\terr = fuse_send_open(fm, nodeid, open_flags, opcode, &outarg);\n\t\tif (!err) {\n\t\t\tff->fh = outarg.fh;\n\t\t\tff->open_flags = outarg.open_flags;\n\n\t\t} else if (err != -ENOSYS) {\n\t\t\tfuse_file_free(ff);\n\t\t\treturn ERR_PTR(err);\n\t\t} else {\n\t\t\tif (isdir)\n\t\t\t\tfc->no_opendir = 1;\n\t\t\telse\n\t\t\t\tfc->no_open = 1;\n\t\t}\n\t}\n\n\tif (isdir)\n\t\tff->open_flags &= ~FOPEN_DIRECT_IO;\n\n\tff->nodeid = nodeid;\n\n\treturn ff;\n}\n\nint fuse_do_open(struct fuse_mount *fm, u64 nodeid, struct file *file,\n\t\t bool isdir)\n{\n\tstruct fuse_file *ff = fuse_file_open(fm, nodeid, file->f_flags, isdir);\n\n\tif (!IS_ERR(ff))\n\t\tfile->private_data = ff;\n\n\treturn PTR_ERR_OR_ZERO(ff);\n}\nEXPORT_SYMBOL_GPL(fuse_do_open);\n\nstatic void fuse_link_write_file(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_file *ff = file->private_data;\n\t \n\tspin_lock(&fi->lock);\n\tif (list_empty(&ff->write_entry))\n\t\tlist_add(&ff->write_entry, &fi->write_files);\n\tspin_unlock(&fi->lock);\n}\n\nvoid fuse_finish_open(struct inode *inode, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (ff->open_flags & FOPEN_STREAM)\n\t\tstream_open(inode, file);\n\telse if (ff->open_flags & FOPEN_NONSEEKABLE)\n\t\tnonseekable_open(inode, file);\n\n\tif (fc->atomic_o_trunc && (file->f_flags & O_TRUNC)) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\tspin_lock(&fi->lock);\n\t\tfi->attr_version = atomic64_inc_return(&fc->attr_version);\n\t\ti_size_write(inode, 0);\n\t\tspin_unlock(&fi->lock);\n\t\tfile_update_time(file);\n\t\tfuse_invalidate_attr_mask(inode, FUSE_STATX_MODSIZE);\n\t}\n\tif ((file->f_mode & FMODE_WRITE) && fc->writeback_cache)\n\t\tfuse_link_write_file(file);\n}\n\nint fuse_open_common(struct inode *inode, struct file *file, bool isdir)\n{\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tstruct fuse_conn *fc = fm->fc;\n\tint err;\n\tbool is_wb_truncate = (file->f_flags & O_TRUNC) &&\n\t\t\t  fc->atomic_o_trunc &&\n\t\t\t  fc->writeback_cache;\n\tbool dax_truncate = (file->f_flags & O_TRUNC) &&\n\t\t\t  fc->atomic_o_trunc && FUSE_IS_DAX(inode);\n\n\tif (fuse_is_bad(inode))\n\t\treturn -EIO;\n\n\terr = generic_file_open(inode, file);\n\tif (err)\n\t\treturn err;\n\n\tif (is_wb_truncate || dax_truncate)\n\t\tinode_lock(inode);\n\n\tif (dax_truncate) {\n\t\tfilemap_invalidate_lock(inode->i_mapping);\n\t\terr = fuse_dax_break_layouts(inode, 0, 0);\n\t\tif (err)\n\t\t\tgoto out_inode_unlock;\n\t}\n\n\tif (is_wb_truncate || dax_truncate)\n\t\tfuse_set_nowrite(inode);\n\n\terr = fuse_do_open(fm, get_node_id(inode), file, isdir);\n\tif (!err)\n\t\tfuse_finish_open(inode, file);\n\n\tif (is_wb_truncate || dax_truncate)\n\t\tfuse_release_nowrite(inode);\n\tif (!err) {\n\t\tstruct fuse_file *ff = file->private_data;\n\n\t\tif (fc->atomic_o_trunc && (file->f_flags & O_TRUNC))\n\t\t\ttruncate_pagecache(inode, 0);\n\t\telse if (!(ff->open_flags & FOPEN_KEEP_CACHE))\n\t\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n\tif (dax_truncate)\n\t\tfilemap_invalidate_unlock(inode->i_mapping);\nout_inode_unlock:\n\tif (is_wb_truncate || dax_truncate)\n\t\tinode_unlock(inode);\n\n\treturn err;\n}\n\nstatic void fuse_prepare_release(struct fuse_inode *fi, struct fuse_file *ff,\n\t\t\t\t unsigned int flags, int opcode)\n{\n\tstruct fuse_conn *fc = ff->fm->fc;\n\tstruct fuse_release_args *ra = ff->release_args;\n\n\t \n\tif (likely(fi)) {\n\t\tspin_lock(&fi->lock);\n\t\tlist_del(&ff->write_entry);\n\t\tspin_unlock(&fi->lock);\n\t}\n\tspin_lock(&fc->lock);\n\tif (!RB_EMPTY_NODE(&ff->polled_node))\n\t\trb_erase(&ff->polled_node, &fc->polled_files);\n\tspin_unlock(&fc->lock);\n\n\twake_up_interruptible_all(&ff->poll_wait);\n\n\tra->inarg.fh = ff->fh;\n\tra->inarg.flags = flags;\n\tra->args.in_numargs = 1;\n\tra->args.in_args[0].size = sizeof(struct fuse_release_in);\n\tra->args.in_args[0].value = &ra->inarg;\n\tra->args.opcode = opcode;\n\tra->args.nodeid = ff->nodeid;\n\tra->args.force = true;\n\tra->args.nocreds = true;\n}\n\nvoid fuse_file_release(struct inode *inode, struct fuse_file *ff,\n\t\t       unsigned int open_flags, fl_owner_t id, bool isdir)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_release_args *ra = ff->release_args;\n\tint opcode = isdir ? FUSE_RELEASEDIR : FUSE_RELEASE;\n\n\tfuse_prepare_release(fi, ff, open_flags, opcode);\n\n\tif (ff->flock) {\n\t\tra->inarg.release_flags |= FUSE_RELEASE_FLOCK_UNLOCK;\n\t\tra->inarg.lock_owner = fuse_lock_owner_id(ff->fm->fc, id);\n\t}\n\t \n\tra->inode = igrab(inode);\n\n\t \n\tfuse_file_put(ff, ff->fm->fc->destroy, isdir);\n}\n\nvoid fuse_release_common(struct file *file, bool isdir)\n{\n\tfuse_file_release(file_inode(file), file->private_data, file->f_flags,\n\t\t\t  (fl_owner_t) file, isdir);\n}\n\nstatic int fuse_open(struct inode *inode, struct file *file)\n{\n\treturn fuse_open_common(inode, file, false);\n}\n\nstatic int fuse_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\t \n\tif (fc->writeback_cache)\n\t\twrite_inode_now(inode, 1);\n\n\tfuse_release_common(file, false);\n\n\t \n\treturn 0;\n}\n\nvoid fuse_sync_release(struct fuse_inode *fi, struct fuse_file *ff,\n\t\t       unsigned int flags)\n{\n\tWARN_ON(refcount_read(&ff->count) > 1);\n\tfuse_prepare_release(fi, ff, flags, FUSE_RELEASE);\n\t \n\tfuse_file_put(ff, true, false);\n}\nEXPORT_SYMBOL_GPL(fuse_sync_release);\n\n \nu64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}\n\nstruct fuse_writepage_args {\n\tstruct fuse_io_args ia;\n\tstruct rb_node writepages_entry;\n\tstruct list_head queue_entry;\n\tstruct fuse_writepage_args *next;\n\tstruct inode *inode;\n\tstruct fuse_sync_bucket *bucket;\n};\n\nstatic struct fuse_writepage_args *fuse_find_writeback(struct fuse_inode *fi,\n\t\t\t\t\t    pgoff_t idx_from, pgoff_t idx_to)\n{\n\tstruct rb_node *n;\n\n\tn = fi->writepages.rb_node;\n\n\twhile (n) {\n\t\tstruct fuse_writepage_args *wpa;\n\t\tpgoff_t curr_index;\n\n\t\twpa = rb_entry(n, struct fuse_writepage_args, writepages_entry);\n\t\tWARN_ON(get_fuse_inode(wpa->inode) != fi);\n\t\tcurr_index = wpa->ia.write.in.offset >> PAGE_SHIFT;\n\t\tif (idx_from >= curr_index + wpa->ia.ap.num_pages)\n\t\t\tn = n->rb_right;\n\t\telse if (idx_to < curr_index)\n\t\t\tn = n->rb_left;\n\t\telse\n\t\t\treturn wpa;\n\t}\n\treturn NULL;\n}\n\n \nstatic bool fuse_range_is_writeback(struct inode *inode, pgoff_t idx_from,\n\t\t\t\t   pgoff_t idx_to)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool found;\n\n\tspin_lock(&fi->lock);\n\tfound = fuse_find_writeback(fi, idx_from, idx_to);\n\tspin_unlock(&fi->lock);\n\n\treturn found;\n}\n\nstatic inline bool fuse_page_is_writeback(struct inode *inode, pgoff_t index)\n{\n\treturn fuse_range_is_writeback(inode, index, index);\n}\n\n \nstatic void fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n}\n\n \nstatic void fuse_sync_writes(struct inode *inode)\n{\n\tfuse_set_nowrite(inode);\n\tfuse_release_nowrite(inode);\n}\n\nstatic int fuse_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_flush_in inarg;\n\tFUSE_ARGS(args);\n\tint err;\n\n\tif (fuse_is_bad(inode))\n\t\treturn -EIO;\n\n\tif (ff->open_flags & FOPEN_NOFLUSH && !fm->fc->writeback_cache)\n\t\treturn 0;\n\n\terr = write_inode_now(inode, 1);\n\tif (err)\n\t\treturn err;\n\n\tinode_lock(inode);\n\tfuse_sync_writes(inode);\n\tinode_unlock(inode);\n\n\terr = filemap_check_errors(file->f_mapping);\n\tif (err)\n\t\treturn err;\n\n\terr = 0;\n\tif (fm->fc->no_flush)\n\t\tgoto inval_attr_out;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.lock_owner = fuse_lock_owner_id(fm->fc, id);\n\targs.opcode = FUSE_FLUSH;\n\targs.nodeid = get_node_id(inode);\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.force = true;\n\n\terr = fuse_simple_request(fm, &args);\n\tif (err == -ENOSYS) {\n\t\tfm->fc->no_flush = 1;\n\t\terr = 0;\n\t}\n\ninval_attr_out:\n\t \n\tif (!err && fm->fc->writeback_cache)\n\t\tfuse_invalidate_attr_mask(inode, STATX_BLOCKS);\n\treturn err;\n}\n\nint fuse_fsync_common(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync, int opcode)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tFUSE_ARGS(args);\n\tstruct fuse_fsync_in inarg;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.fsync_flags = datasync ? FUSE_FSYNC_FDATASYNC : 0;\n\targs.opcode = opcode;\n\targs.nodeid = get_node_id(inode);\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\treturn fuse_simple_request(fm, &args);\n}\n\nstatic int fuse_fsync(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\n\tif (fuse_is_bad(inode))\n\t\treturn -EIO;\n\n\tinode_lock(inode);\n\n\t \n\terr = file_write_and_wait_range(file, start, end);\n\tif (err)\n\t\tgoto out;\n\n\tfuse_sync_writes(inode);\n\n\t \n\terr = file_check_and_advance_wb_err(file);\n\tif (err)\n\t\tgoto out;\n\n\terr = sync_inode_metadata(inode, 1);\n\tif (err)\n\t\tgoto out;\n\n\tif (fc->no_fsync)\n\t\tgoto out;\n\n\terr = fuse_fsync_common(file, start, end, datasync, FUSE_FSYNC);\n\tif (err == -ENOSYS) {\n\t\tfc->no_fsync = 1;\n\t\terr = 0;\n\t}\nout:\n\tinode_unlock(inode);\n\n\treturn err;\n}\n\nvoid fuse_read_args_fill(struct fuse_io_args *ia, struct file *file, loff_t pos,\n\t\t\t size_t count, int opcode)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_args *args = &ia->ap.args;\n\n\tia->read.in.fh = ff->fh;\n\tia->read.in.offset = pos;\n\tia->read.in.size = count;\n\tia->read.in.flags = file->f_flags;\n\targs->opcode = opcode;\n\targs->nodeid = ff->nodeid;\n\targs->in_numargs = 1;\n\targs->in_args[0].size = sizeof(ia->read.in);\n\targs->in_args[0].value = &ia->read.in;\n\targs->out_argvar = true;\n\targs->out_numargs = 1;\n\targs->out_args[0].size = count;\n}\n\nstatic void fuse_release_user_pages(struct fuse_args_pages *ap,\n\t\t\t\t    bool should_dirty)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ap->num_pages; i++) {\n\t\tif (should_dirty)\n\t\t\tset_page_dirty_lock(ap->pages[i]);\n\t\tput_page(ap->pages[i]);\n\t}\n}\n\nstatic void fuse_io_release(struct kref *kref)\n{\n\tkfree(container_of(kref, struct fuse_io_priv, refcnt));\n}\n\nstatic ssize_t fuse_get_res_by_io(struct fuse_io_priv *io)\n{\n\tif (io->err)\n\t\treturn io->err;\n\n\tif (io->bytes >= 0 && io->write)\n\t\treturn -EIO;\n\n\treturn io->bytes < 0 ? io->size : io->bytes;\n}\n\n \nstatic void fuse_aio_complete(struct fuse_io_priv *io, int err, ssize_t pos)\n{\n\tint left;\n\n\tspin_lock(&io->lock);\n\tif (err)\n\t\tio->err = io->err ? : err;\n\telse if (pos >= 0 && (io->bytes < 0 || pos < io->bytes))\n\t\tio->bytes = pos;\n\n\tleft = --io->reqs;\n\tif (!left && io->blocking)\n\t\tcomplete(io->done);\n\tspin_unlock(&io->lock);\n\n\tif (!left && !io->blocking) {\n\t\tssize_t res = fuse_get_res_by_io(io);\n\n\t\tif (res >= 0) {\n\t\t\tstruct inode *inode = file_inode(io->iocb->ki_filp);\n\t\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\t\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\t\tspin_lock(&fi->lock);\n\t\t\tfi->attr_version = atomic64_inc_return(&fc->attr_version);\n\t\t\tspin_unlock(&fi->lock);\n\t\t}\n\n\t\tio->iocb->ki_complete(io->iocb, res);\n\t}\n\n\tkref_put(&io->refcnt, fuse_io_release);\n}\n\nstatic struct fuse_io_args *fuse_io_alloc(struct fuse_io_priv *io,\n\t\t\t\t\t  unsigned int npages)\n{\n\tstruct fuse_io_args *ia;\n\n\tia = kzalloc(sizeof(*ia), GFP_KERNEL);\n\tif (ia) {\n\t\tia->io = io;\n\t\tia->ap.pages = fuse_pages_alloc(npages, GFP_KERNEL,\n\t\t\t\t\t\t&ia->ap.descs);\n\t\tif (!ia->ap.pages) {\n\t\t\tkfree(ia);\n\t\t\tia = NULL;\n\t\t}\n\t}\n\treturn ia;\n}\n\nstatic void fuse_io_free(struct fuse_io_args *ia)\n{\n\tkfree(ia->ap.pages);\n\tkfree(ia);\n}\n\nstatic void fuse_aio_complete_req(struct fuse_mount *fm, struct fuse_args *args,\n\t\t\t\t  int err)\n{\n\tstruct fuse_io_args *ia = container_of(args, typeof(*ia), ap.args);\n\tstruct fuse_io_priv *io = ia->io;\n\tssize_t pos = -1;\n\n\tfuse_release_user_pages(&ia->ap, io->should_dirty);\n\n\tif (err) {\n\t\t \n\t} else if (io->write) {\n\t\tif (ia->write.out.size > ia->write.in.size) {\n\t\t\terr = -EIO;\n\t\t} else if (ia->write.in.size != ia->write.out.size) {\n\t\t\tpos = ia->write.in.offset - io->offset +\n\t\t\t\tia->write.out.size;\n\t\t}\n\t} else {\n\t\tu32 outsize = args->out_args[0].size;\n\n\t\tif (ia->read.in.size != outsize)\n\t\t\tpos = ia->read.in.offset - io->offset + outsize;\n\t}\n\n\tfuse_aio_complete(io, err, pos);\n\tfuse_io_free(ia);\n}\n\nstatic ssize_t fuse_async_req_send(struct fuse_mount *fm,\n\t\t\t\t   struct fuse_io_args *ia, size_t num_bytes)\n{\n\tssize_t err;\n\tstruct fuse_io_priv *io = ia->io;\n\n\tspin_lock(&io->lock);\n\tkref_get(&io->refcnt);\n\tio->size += num_bytes;\n\tio->reqs++;\n\tspin_unlock(&io->lock);\n\n\tia->ap.args.end = fuse_aio_complete_req;\n\tia->ap.args.may_block = io->should_dirty;\n\terr = fuse_simple_background(fm, &ia->ap.args, GFP_KERNEL);\n\tif (err)\n\t\tfuse_aio_complete_req(fm, &ia->ap.args, err);\n\n\treturn num_bytes;\n}\n\nstatic ssize_t fuse_send_read(struct fuse_io_args *ia, loff_t pos, size_t count,\n\t\t\t      fl_owner_t owner)\n{\n\tstruct file *file = ia->io->iocb->ki_filp;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_mount *fm = ff->fm;\n\n\tfuse_read_args_fill(ia, file, pos, count, FUSE_READ);\n\tif (owner != NULL) {\n\t\tia->read.in.read_flags |= FUSE_READ_LOCKOWNER;\n\t\tia->read.in.lock_owner = fuse_lock_owner_id(fm->fc, owner);\n\t}\n\n\tif (ia->io->async)\n\t\treturn fuse_async_req_send(fm, ia, count);\n\n\treturn fuse_simple_request(fm, &ia->ap.args);\n}\n\nstatic void fuse_read_update_size(struct inode *inode, loff_t size,\n\t\t\t\t  u64 attr_ver)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tspin_lock(&fi->lock);\n\tif (attr_ver >= fi->attr_version && size < inode->i_size &&\n\t    !test_bit(FUSE_I_SIZE_UNSTABLE, &fi->state)) {\n\t\tfi->attr_version = atomic64_inc_return(&fc->attr_version);\n\t\ti_size_write(inode, size);\n\t}\n\tspin_unlock(&fi->lock);\n}\n\nstatic void fuse_short_read(struct inode *inode, u64 attr_ver, size_t num_read,\n\t\t\t    struct fuse_args_pages *ap)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\t \n\tif (!fc->writeback_cache) {\n\t\tloff_t pos = page_offset(ap->pages[0]) + num_read;\n\t\tfuse_read_update_size(inode, pos, attr_ver);\n\t}\n}\n\nstatic int fuse_do_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tloff_t pos = page_offset(page);\n\tstruct fuse_page_desc desc = { .length = PAGE_SIZE };\n\tstruct fuse_io_args ia = {\n\t\t.ap.args.page_zeroing = true,\n\t\t.ap.args.out_pages = true,\n\t\t.ap.num_pages = 1,\n\t\t.ap.pages = &page,\n\t\t.ap.descs = &desc,\n\t};\n\tssize_t res;\n\tu64 attr_ver;\n\n\t \n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\tattr_ver = fuse_get_attr_version(fm->fc);\n\n\t \n\tif (pos + (desc.length - 1) == LLONG_MAX)\n\t\tdesc.length--;\n\n\tfuse_read_args_fill(&ia, file, pos, desc.length, FUSE_READ);\n\tres = fuse_simple_request(fm, &ia.ap.args);\n\tif (res < 0)\n\t\treturn res;\n\t \n\tif (res < desc.length)\n\t\tfuse_short_read(inode, attr_ver, res, &ia.ap);\n\n\tSetPageUptodate(page);\n\n\treturn 0;\n}\n\nstatic int fuse_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct page *page = &folio->page;\n\tstruct inode *inode = page->mapping->host;\n\tint err;\n\n\terr = -EIO;\n\tif (fuse_is_bad(inode))\n\t\tgoto out;\n\n\terr = fuse_do_readpage(file, page);\n\tfuse_invalidate_atime(inode);\n out:\n\tunlock_page(page);\n\treturn err;\n}\n\nstatic void fuse_readpages_end(struct fuse_mount *fm, struct fuse_args *args,\n\t\t\t       int err)\n{\n\tint i;\n\tstruct fuse_io_args *ia = container_of(args, typeof(*ia), ap.args);\n\tstruct fuse_args_pages *ap = &ia->ap;\n\tsize_t count = ia->read.in.size;\n\tsize_t num_read = args->out_args[0].size;\n\tstruct address_space *mapping = NULL;\n\n\tfor (i = 0; mapping == NULL && i < ap->num_pages; i++)\n\t\tmapping = ap->pages[i]->mapping;\n\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\n\t\t \n\t\tif (!err && num_read < count)\n\t\t\tfuse_short_read(inode, ia->read.attr_ver, num_read, ap);\n\n\t\tfuse_invalidate_atime(inode);\n\t}\n\n\tfor (i = 0; i < ap->num_pages; i++) {\n\t\tstruct page *page = ap->pages[i];\n\n\t\tif (!err)\n\t\t\tSetPageUptodate(page);\n\t\telse\n\t\t\tSetPageError(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n\tif (ia->ff)\n\t\tfuse_file_put(ia->ff, false, false);\n\n\tfuse_io_free(ia);\n}\n\nstatic void fuse_send_readpages(struct fuse_io_args *ia, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_mount *fm = ff->fm;\n\tstruct fuse_args_pages *ap = &ia->ap;\n\tloff_t pos = page_offset(ap->pages[0]);\n\tsize_t count = ap->num_pages << PAGE_SHIFT;\n\tssize_t res;\n\tint err;\n\n\tap->args.out_pages = true;\n\tap->args.page_zeroing = true;\n\tap->args.page_replace = true;\n\n\t \n\tif (pos + (count - 1) == LLONG_MAX) {\n\t\tcount--;\n\t\tap->descs[ap->num_pages - 1].length--;\n\t}\n\tWARN_ON((loff_t) (pos + count) < 0);\n\n\tfuse_read_args_fill(ia, file, pos, count, FUSE_READ);\n\tia->read.attr_ver = fuse_get_attr_version(fm->fc);\n\tif (fm->fc->async_read) {\n\t\tia->ff = fuse_file_get(ff);\n\t\tap->args.end = fuse_readpages_end;\n\t\terr = fuse_simple_background(fm, &ap->args, GFP_KERNEL);\n\t\tif (!err)\n\t\t\treturn;\n\t} else {\n\t\tres = fuse_simple_request(fm, &ap->args);\n\t\terr = res < 0 ? res : 0;\n\t}\n\tfuse_readpages_end(fm, &ap->args, err);\n}\n\nstatic void fuse_readahead(struct readahead_control *rac)\n{\n\tstruct inode *inode = rac->mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tunsigned int i, max_pages, nr_pages = 0;\n\n\tif (fuse_is_bad(inode))\n\t\treturn;\n\n\tmax_pages = min_t(unsigned int, fc->max_pages,\n\t\t\tfc->max_read / PAGE_SIZE);\n\n\tfor (;;) {\n\t\tstruct fuse_io_args *ia;\n\t\tstruct fuse_args_pages *ap;\n\n\t\tif (fc->num_background >= fc->congestion_threshold &&\n\t\t    rac->ra->async_size >= readahead_count(rac))\n\t\t\t \n\t\t\tbreak;\n\n\t\tnr_pages = readahead_count(rac) - nr_pages;\n\t\tif (nr_pages > max_pages)\n\t\t\tnr_pages = max_pages;\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\t\tia = fuse_io_alloc(NULL, nr_pages);\n\t\tif (!ia)\n\t\t\treturn;\n\t\tap = &ia->ap;\n\t\tnr_pages = __readahead_batch(rac, ap->pages, nr_pages);\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tfuse_wait_on_page_writeback(inode,\n\t\t\t\t\t\t    readahead_index(rac) + i);\n\t\t\tap->descs[i].length = PAGE_SIZE;\n\t\t}\n\t\tap->num_pages = nr_pages;\n\t\tfuse_send_readpages(ia, rac->file);\n\t}\n}\n\nstatic ssize_t fuse_cache_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct inode *inode = iocb->ki_filp->f_mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\t \n\tif (fc->auto_inval_data ||\n\t    (iocb->ki_pos + iov_iter_count(to) > i_size_read(inode))) {\n\t\tint err;\n\t\terr = fuse_update_attributes(inode, iocb->ki_filp, STATX_SIZE);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn generic_file_read_iter(iocb, to);\n}\n\nstatic void fuse_write_args_fill(struct fuse_io_args *ia, struct fuse_file *ff,\n\t\t\t\t loff_t pos, size_t count)\n{\n\tstruct fuse_args *args = &ia->ap.args;\n\n\tia->write.in.fh = ff->fh;\n\tia->write.in.offset = pos;\n\tia->write.in.size = count;\n\targs->opcode = FUSE_WRITE;\n\targs->nodeid = ff->nodeid;\n\targs->in_numargs = 2;\n\tif (ff->fm->fc->minor < 9)\n\t\targs->in_args[0].size = FUSE_COMPAT_WRITE_IN_SIZE;\n\telse\n\t\targs->in_args[0].size = sizeof(ia->write.in);\n\targs->in_args[0].value = &ia->write.in;\n\targs->in_args[1].size = count;\n\targs->out_numargs = 1;\n\targs->out_args[0].size = sizeof(ia->write.out);\n\targs->out_args[0].value = &ia->write.out;\n}\n\nstatic unsigned int fuse_write_flags(struct kiocb *iocb)\n{\n\tunsigned int flags = iocb->ki_filp->f_flags;\n\n\tif (iocb_is_dsync(iocb))\n\t\tflags |= O_DSYNC;\n\tif (iocb->ki_flags & IOCB_SYNC)\n\t\tflags |= O_SYNC;\n\n\treturn flags;\n}\n\nstatic ssize_t fuse_send_write(struct fuse_io_args *ia, loff_t pos,\n\t\t\t       size_t count, fl_owner_t owner)\n{\n\tstruct kiocb *iocb = ia->io->iocb;\n\tstruct file *file = iocb->ki_filp;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_mount *fm = ff->fm;\n\tstruct fuse_write_in *inarg = &ia->write.in;\n\tssize_t err;\n\n\tfuse_write_args_fill(ia, ff, pos, count);\n\tinarg->flags = fuse_write_flags(iocb);\n\tif (owner != NULL) {\n\t\tinarg->write_flags |= FUSE_WRITE_LOCKOWNER;\n\t\tinarg->lock_owner = fuse_lock_owner_id(fm->fc, owner);\n\t}\n\n\tif (ia->io->async)\n\t\treturn fuse_async_req_send(fm, ia, count);\n\n\terr = fuse_simple_request(fm, &ia->ap.args);\n\tif (!err && ia->write.out.size > count)\n\t\terr = -EIO;\n\n\treturn err ?: ia->write.out.size;\n}\n\nbool fuse_write_update_attr(struct inode *inode, loff_t pos, ssize_t written)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool ret = false;\n\n\tspin_lock(&fi->lock);\n\tfi->attr_version = atomic64_inc_return(&fc->attr_version);\n\tif (written > 0 && pos > inode->i_size) {\n\t\ti_size_write(inode, pos);\n\t\tret = true;\n\t}\n\tspin_unlock(&fi->lock);\n\n\tfuse_invalidate_attr_mask(inode, FUSE_STATX_MODSIZE);\n\n\treturn ret;\n}\n\nstatic ssize_t fuse_send_write_pages(struct fuse_io_args *ia,\n\t\t\t\t     struct kiocb *iocb, struct inode *inode,\n\t\t\t\t     loff_t pos, size_t count)\n{\n\tstruct fuse_args_pages *ap = &ia->ap;\n\tstruct file *file = iocb->ki_filp;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_mount *fm = ff->fm;\n\tunsigned int offset, i;\n\tbool short_write;\n\tint err;\n\n\tfor (i = 0; i < ap->num_pages; i++)\n\t\tfuse_wait_on_page_writeback(inode, ap->pages[i]->index);\n\n\tfuse_write_args_fill(ia, ff, pos, count);\n\tia->write.in.flags = fuse_write_flags(iocb);\n\tif (fm->fc->handle_killpriv_v2 && !capable(CAP_FSETID))\n\t\tia->write.in.write_flags |= FUSE_WRITE_KILL_SUIDGID;\n\n\terr = fuse_simple_request(fm, &ap->args);\n\tif (!err && ia->write.out.size > count)\n\t\terr = -EIO;\n\n\tshort_write = ia->write.out.size < count;\n\toffset = ap->descs[0].offset;\n\tcount = ia->write.out.size;\n\tfor (i = 0; i < ap->num_pages; i++) {\n\t\tstruct page *page = ap->pages[i];\n\n\t\tif (err) {\n\t\t\tClearPageUptodate(page);\n\t\t} else {\n\t\t\tif (count >= PAGE_SIZE - offset)\n\t\t\t\tcount -= PAGE_SIZE - offset;\n\t\t\telse {\n\t\t\t\tif (short_write)\n\t\t\t\t\tClearPageUptodate(page);\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\toffset = 0;\n\t\t}\n\t\tif (ia->write.page_locked && (i == ap->num_pages - 1))\n\t\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n\n\treturn err;\n}\n\nstatic ssize_t fuse_fill_write_pages(struct fuse_io_args *ia,\n\t\t\t\t     struct address_space *mapping,\n\t\t\t\t     struct iov_iter *ii, loff_t pos,\n\t\t\t\t     unsigned int max_pages)\n{\n\tstruct fuse_args_pages *ap = &ia->ap;\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\n\tap->args.in_pages = true;\n\tap->descs[0].offset = offset;\n\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n\n again:\n\t\terr = -EFAULT;\n\t\tif (fault_in_iov_iter_readable(ii, bytes))\n\t\t\tbreak;\n\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\ttmp = copy_page_from_iter_atomic(page, offset, bytes, ii);\n\t\tflush_dcache_page(page);\n\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = 0;\n\t\tap->pages[ap->num_pages] = page;\n\t\tap->descs[ap->num_pages].length = tmp;\n\t\tap->num_pages++;\n\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_SIZE)\n\t\t\toffset = 0;\n\n\t\t \n\t\tif (tmp == PAGE_SIZE)\n\t\t\tSetPageUptodate(page);\n\n\t\tif (PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t} else {\n\t\t\tia->write.page_locked = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t ap->num_pages < max_pages && offset == 0);\n\n\treturn count > 0 ? count : err;\n}\n\nstatic inline unsigned int fuse_wr_pages(loff_t pos, size_t len,\n\t\t\t\t     unsigned int max_pages)\n{\n\treturn min_t(unsigned int,\n\t\t     ((pos + len - 1) >> PAGE_SHIFT) -\n\t\t     (pos >> PAGE_SHIFT) + 1,\n\t\t     max_pages);\n}\n\nstatic ssize_t fuse_perform_write(struct kiocb *iocb, struct iov_iter *ii)\n{\n\tstruct address_space *mapping = iocb->ki_filp->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tloff_t pos = iocb->ki_pos;\n\tint err = 0;\n\tssize_t res = 0;\n\n\tif (inode->i_size < pos + iov_iter_count(ii))\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tdo {\n\t\tssize_t count;\n\t\tstruct fuse_io_args ia = {};\n\t\tstruct fuse_args_pages *ap = &ia.ap;\n\t\tunsigned int nr_pages = fuse_wr_pages(pos, iov_iter_count(ii),\n\t\t\t\t\t\t      fc->max_pages);\n\n\t\tap->pages = fuse_pages_alloc(nr_pages, GFP_KERNEL, &ap->descs);\n\t\tif (!ap->pages) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = fuse_fill_write_pages(&ia, mapping, ii, pos, nr_pages);\n\t\tif (count <= 0) {\n\t\t\terr = count;\n\t\t} else {\n\t\t\terr = fuse_send_write_pages(&ia, iocb, inode,\n\t\t\t\t\t\t    pos, count);\n\t\t\tif (!err) {\n\t\t\t\tsize_t num_written = ia.write.out.size;\n\n\t\t\t\tres += num_written;\n\t\t\t\tpos += num_written;\n\n\t\t\t\t \n\t\t\t\tif (num_written != count)\n\t\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tkfree(ap->pages);\n\t} while (!err && iov_iter_count(ii));\n\n\tfuse_write_update_attr(inode, pos, res);\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tif (!res)\n\t\treturn err;\n\tiocb->ki_pos += res;\n\treturn res;\n}\n\nstatic ssize_t fuse_cache_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tssize_t written = 0;\n\tstruct inode *inode = mapping->host;\n\tssize_t err;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (fc->writeback_cache) {\n\t\t \n\t\terr = fuse_update_attributes(mapping->host, file,\n\t\t\t\t\t     STATX_SIZE | STATX_MODE);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (fc->handle_killpriv_v2 &&\n\t\t    setattr_should_drop_suidgid(&nop_mnt_idmap,\n\t\t\t\t\t\tfile_inode(file))) {\n\t\t\tgoto writethrough;\n\t\t}\n\n\t\treturn generic_file_write_iter(iocb, from);\n\t}\n\nwritethrough:\n\tinode_lock(inode);\n\n\terr = generic_write_checks(iocb, from);\n\tif (err <= 0)\n\t\tgoto out;\n\n\terr = file_remove_privs(file);\n\tif (err)\n\t\tgoto out;\n\n\terr = file_update_time(file);\n\tif (err)\n\t\tgoto out;\n\n\tif (iocb->ki_flags & IOCB_DIRECT) {\n\t\twritten = generic_file_direct_write(iocb, from);\n\t\tif (written < 0 || !iov_iter_count(from))\n\t\t\tgoto out;\n\t\twritten = direct_write_fallback(iocb, from, written,\n\t\t\t\tfuse_perform_write(iocb, from));\n\t} else {\n\t\twritten = fuse_perform_write(iocb, from);\n\t}\nout:\n\tinode_unlock(inode);\n\tif (written > 0)\n\t\twritten = generic_write_sync(iocb, written);\n\n\treturn written ? written : err;\n}\n\nstatic inline unsigned long fuse_get_user_addr(const struct iov_iter *ii)\n{\n\treturn (unsigned long)iter_iov(ii)->iov_base + ii->iov_offset;\n}\n\nstatic inline size_t fuse_get_frag_size(const struct iov_iter *ii,\n\t\t\t\t\tsize_t max_size)\n{\n\treturn min(iov_iter_single_seg_count(ii), max_size);\n}\n\nstatic int fuse_get_user_pages(struct fuse_args_pages *ap, struct iov_iter *ii,\n\t\t\t       size_t *nbytesp, int write,\n\t\t\t       unsigned int max_pages)\n{\n\tsize_t nbytes = 0;   \n\tssize_t ret = 0;\n\n\t \n\tif (iov_iter_is_kvec(ii)) {\n\t\tunsigned long user_addr = fuse_get_user_addr(ii);\n\t\tsize_t frag_size = fuse_get_frag_size(ii, *nbytesp);\n\n\t\tif (write)\n\t\t\tap->args.in_args[1].value = (void *) user_addr;\n\t\telse\n\t\t\tap->args.out_args[0].value = (void *) user_addr;\n\n\t\tiov_iter_advance(ii, frag_size);\n\t\t*nbytesp = frag_size;\n\t\treturn 0;\n\t}\n\n\twhile (nbytes < *nbytesp && ap->num_pages < max_pages) {\n\t\tunsigned npages;\n\t\tsize_t start;\n\t\tret = iov_iter_get_pages2(ii, &ap->pages[ap->num_pages],\n\t\t\t\t\t*nbytesp - nbytes,\n\t\t\t\t\tmax_pages - ap->num_pages,\n\t\t\t\t\t&start);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tnbytes += ret;\n\n\t\tret += start;\n\t\tnpages = DIV_ROUND_UP(ret, PAGE_SIZE);\n\n\t\tap->descs[ap->num_pages].offset = start;\n\t\tfuse_page_descs_length_init(ap->descs, ap->num_pages, npages);\n\n\t\tap->num_pages += npages;\n\t\tap->descs[ap->num_pages - 1].length -=\n\t\t\t(PAGE_SIZE - ret) & (PAGE_SIZE - 1);\n\t}\n\n\tap->args.user_pages = true;\n\tif (write)\n\t\tap->args.in_pages = true;\n\telse\n\t\tap->args.out_pages = true;\n\n\t*nbytesp = nbytes;\n\n\treturn ret < 0 ? ret : 0;\n}\n\nssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter *iter,\n\t\t       loff_t *ppos, int flags)\n{\n\tint write = flags & FUSE_DIO_WRITE;\n\tint cuse = flags & FUSE_DIO_CUSE;\n\tstruct file *file = io->iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fm->fc;\n\tsize_t nmax = write ? fc->max_write : fc->max_read;\n\tloff_t pos = *ppos;\n\tsize_t count = iov_iter_count(iter);\n\tpgoff_t idx_from = pos >> PAGE_SHIFT;\n\tpgoff_t idx_to = (pos + count - 1) >> PAGE_SHIFT;\n\tssize_t res = 0;\n\tint err = 0;\n\tstruct fuse_io_args *ia;\n\tunsigned int max_pages;\n\tbool fopen_direct_io = ff->open_flags & FOPEN_DIRECT_IO;\n\n\tmax_pages = iov_iter_npages(iter, fc->max_pages);\n\tia = fuse_io_alloc(io, max_pages);\n\tif (!ia)\n\t\treturn -ENOMEM;\n\n\tif (fopen_direct_io && fc->direct_io_allow_mmap) {\n\t\tres = filemap_write_and_wait_range(mapping, pos, pos + count - 1);\n\t\tif (res) {\n\t\t\tfuse_io_free(ia);\n\t\t\treturn res;\n\t\t}\n\t}\n\tif (!cuse && fuse_range_is_writeback(inode, idx_from, idx_to)) {\n\t\tif (!write)\n\t\t\tinode_lock(inode);\n\t\tfuse_sync_writes(inode);\n\t\tif (!write)\n\t\t\tinode_unlock(inode);\n\t}\n\n\tif (fopen_direct_io && write) {\n\t\tres = invalidate_inode_pages2_range(mapping, idx_from, idx_to);\n\t\tif (res) {\n\t\t\tfuse_io_free(ia);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tio->should_dirty = !write && user_backed_iter(iter);\n\twhile (count) {\n\t\tssize_t nres;\n\t\tfl_owner_t owner = current->files;\n\t\tsize_t nbytes = min(count, nmax);\n\n\t\terr = fuse_get_user_pages(&ia->ap, iter, &nbytes, write,\n\t\t\t\t\t  max_pages);\n\t\tif (err && !nbytes)\n\t\t\tbreak;\n\n\t\tif (write) {\n\t\t\tif (!capable(CAP_FSETID))\n\t\t\t\tia->write.in.write_flags |= FUSE_WRITE_KILL_SUIDGID;\n\n\t\t\tnres = fuse_send_write(ia, pos, nbytes, owner);\n\t\t} else {\n\t\t\tnres = fuse_send_read(ia, pos, nbytes, owner);\n\t\t}\n\n\t\tif (!io->async || nres < 0) {\n\t\t\tfuse_release_user_pages(&ia->ap, io->should_dirty);\n\t\t\tfuse_io_free(ia);\n\t\t}\n\t\tia = NULL;\n\t\tif (nres < 0) {\n\t\t\tiov_iter_revert(iter, nbytes);\n\t\t\terr = nres;\n\t\t\tbreak;\n\t\t}\n\t\tWARN_ON(nres > nbytes);\n\n\t\tcount -= nres;\n\t\tres += nres;\n\t\tpos += nres;\n\t\tif (nres != nbytes) {\n\t\t\tiov_iter_revert(iter, nbytes - nres);\n\t\t\tbreak;\n\t\t}\n\t\tif (count) {\n\t\t\tmax_pages = iov_iter_npages(iter, fc->max_pages);\n\t\t\tia = fuse_io_alloc(io, max_pages);\n\t\t\tif (!ia)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (ia)\n\t\tfuse_io_free(ia);\n\tif (res > 0)\n\t\t*ppos = pos;\n\n\treturn res > 0 ? res : err;\n}\nEXPORT_SYMBOL_GPL(fuse_direct_io);\n\nstatic ssize_t __fuse_direct_read(struct fuse_io_priv *io,\n\t\t\t\t  struct iov_iter *iter,\n\t\t\t\t  loff_t *ppos)\n{\n\tssize_t res;\n\tstruct inode *inode = file_inode(io->iocb->ki_filp);\n\n\tres = fuse_direct_io(io, iter, ppos, 0);\n\n\tfuse_invalidate_atime(inode);\n\n\treturn res;\n}\n\nstatic ssize_t fuse_direct_IO(struct kiocb *iocb, struct iov_iter *iter);\n\nstatic ssize_t fuse_direct_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tssize_t res;\n\n\tif (!is_sync_kiocb(iocb) && iocb->ki_flags & IOCB_DIRECT) {\n\t\tres = fuse_direct_IO(iocb, to);\n\t} else {\n\t\tstruct fuse_io_priv io = FUSE_IO_PRIV_SYNC(iocb);\n\n\t\tres = __fuse_direct_read(&io, to, &iocb->ki_pos);\n\t}\n\n\treturn res;\n}\n\nstatic bool fuse_direct_write_extending_i_size(struct kiocb *iocb,\n\t\t\t\t\t       struct iov_iter *iter)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\n\treturn iocb->ki_pos + iov_iter_count(iter) > i_size_read(inode);\n}\n\nstatic ssize_t fuse_direct_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tstruct file *file = iocb->ki_filp;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_io_priv io = FUSE_IO_PRIV_SYNC(iocb);\n\tssize_t res;\n\tbool exclusive_lock =\n\t\t!(ff->open_flags & FOPEN_PARALLEL_DIRECT_WRITES) ||\n\t\tget_fuse_conn(inode)->direct_io_allow_mmap ||\n\t\tiocb->ki_flags & IOCB_APPEND ||\n\t\tfuse_direct_write_extending_i_size(iocb, from);\n\n\t \n\tif (exclusive_lock)\n\t\tinode_lock(inode);\n\telse {\n\t\tinode_lock_shared(inode);\n\n\t\t \n\t\tif (fuse_direct_write_extending_i_size(iocb, from)) {\n\t\t\tinode_unlock_shared(inode);\n\t\t\tinode_lock(inode);\n\t\t\texclusive_lock = true;\n\t\t}\n\t}\n\n\tres = generic_write_checks(iocb, from);\n\tif (res > 0) {\n\t\tif (!is_sync_kiocb(iocb) && iocb->ki_flags & IOCB_DIRECT) {\n\t\t\tres = fuse_direct_IO(iocb, from);\n\t\t} else {\n\t\t\tres = fuse_direct_io(&io, from, &iocb->ki_pos,\n\t\t\t\t\t     FUSE_DIO_WRITE);\n\t\t\tfuse_write_update_attr(inode, iocb->ki_pos, res);\n\t\t}\n\t}\n\tif (exclusive_lock)\n\t\tinode_unlock(inode);\n\telse\n\t\tinode_unlock_shared(inode);\n\n\treturn res;\n}\n\nstatic ssize_t fuse_file_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\n\tif (fuse_is_bad(inode))\n\t\treturn -EIO;\n\n\tif (FUSE_IS_DAX(inode))\n\t\treturn fuse_dax_read_iter(iocb, to);\n\n\tif (!(ff->open_flags & FOPEN_DIRECT_IO))\n\t\treturn fuse_cache_read_iter(iocb, to);\n\telse\n\t\treturn fuse_direct_read_iter(iocb, to);\n}\n\nstatic ssize_t fuse_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\n\tif (fuse_is_bad(inode))\n\t\treturn -EIO;\n\n\tif (FUSE_IS_DAX(inode))\n\t\treturn fuse_dax_write_iter(iocb, from);\n\n\tif (!(ff->open_flags & FOPEN_DIRECT_IO))\n\t\treturn fuse_cache_write_iter(iocb, from);\n\telse\n\t\treturn fuse_direct_write_iter(iocb, from);\n}\n\nstatic void fuse_writepage_free(struct fuse_writepage_args *wpa)\n{\n\tstruct fuse_args_pages *ap = &wpa->ia.ap;\n\tint i;\n\n\tif (wpa->bucket)\n\t\tfuse_sync_bucket_dec(wpa->bucket);\n\n\tfor (i = 0; i < ap->num_pages; i++)\n\t\t__free_page(ap->pages[i]);\n\n\tif (wpa->ia.ff)\n\t\tfuse_file_put(wpa->ia.ff, false, false);\n\n\tkfree(ap->pages);\n\tkfree(wpa);\n}\n\nstatic void fuse_writepage_finish(struct fuse_mount *fm,\n\t\t\t\t  struct fuse_writepage_args *wpa)\n{\n\tstruct fuse_args_pages *ap = &wpa->ia.ap;\n\tstruct inode *inode = wpa->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tint i;\n\n\tfor (i = 0; i < ap->num_pages; i++) {\n\t\tdec_wb_stat(&bdi->wb, WB_WRITEBACK);\n\t\tdec_node_page_state(ap->pages[i], NR_WRITEBACK_TEMP);\n\t\twb_writeout_inc(&bdi->wb);\n\t}\n\twake_up(&fi->page_waitq);\n}\n\n \nstatic void fuse_send_writepage(struct fuse_mount *fm,\n\t\t\t\tstruct fuse_writepage_args *wpa, loff_t size)\n__releases(fi->lock)\n__acquires(fi->lock)\n{\n\tstruct fuse_writepage_args *aux, *next;\n\tstruct fuse_inode *fi = get_fuse_inode(wpa->inode);\n\tstruct fuse_write_in *inarg = &wpa->ia.write.in;\n\tstruct fuse_args *args = &wpa->ia.ap.args;\n\t__u64 data_size = wpa->ia.ap.num_pages * PAGE_SIZE;\n\tint err;\n\n\tfi->writectr++;\n\tif (inarg->offset + data_size <= size) {\n\t\tinarg->size = data_size;\n\t} else if (inarg->offset < size) {\n\t\tinarg->size = size - inarg->offset;\n\t} else {\n\t\t \n\t\tgoto out_free;\n\t}\n\n\targs->in_args[1].size = inarg->size;\n\targs->force = true;\n\targs->nocreds = true;\n\n\terr = fuse_simple_background(fm, args, GFP_ATOMIC);\n\tif (err == -ENOMEM) {\n\t\tspin_unlock(&fi->lock);\n\t\terr = fuse_simple_background(fm, args, GFP_NOFS | __GFP_NOFAIL);\n\t\tspin_lock(&fi->lock);\n\t}\n\n\t \n\tif (unlikely(err))\n\t\tgoto out_free;\n\n\treturn;\n\n out_free:\n\tfi->writectr--;\n\trb_erase(&wpa->writepages_entry, &fi->writepages);\n\tfuse_writepage_finish(fm, wpa);\n\tspin_unlock(&fi->lock);\n\n\t \n\tfor (aux = wpa->next; aux; aux = next) {\n\t\tnext = aux->next;\n\t\taux->next = NULL;\n\t\tfuse_writepage_free(aux);\n\t}\n\n\tfuse_writepage_free(wpa);\n\tspin_lock(&fi->lock);\n}\n\n \nvoid fuse_flush_writepages(struct inode *inode)\n__releases(fi->lock)\n__acquires(fi->lock)\n{\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tloff_t crop = i_size_read(inode);\n\tstruct fuse_writepage_args *wpa;\n\n\twhile (fi->writectr >= 0 && !list_empty(&fi->queued_writes)) {\n\t\twpa = list_entry(fi->queued_writes.next,\n\t\t\t\t struct fuse_writepage_args, queue_entry);\n\t\tlist_del_init(&wpa->queue_entry);\n\t\tfuse_send_writepage(fm, wpa, crop);\n\t}\n}\n\nstatic struct fuse_writepage_args *fuse_insert_writeback(struct rb_root *root,\n\t\t\t\t\t\tstruct fuse_writepage_args *wpa)\n{\n\tpgoff_t idx_from = wpa->ia.write.in.offset >> PAGE_SHIFT;\n\tpgoff_t idx_to = idx_from + wpa->ia.ap.num_pages - 1;\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node  *parent = NULL;\n\n\tWARN_ON(!wpa->ia.ap.num_pages);\n\twhile (*p) {\n\t\tstruct fuse_writepage_args *curr;\n\t\tpgoff_t curr_index;\n\n\t\tparent = *p;\n\t\tcurr = rb_entry(parent, struct fuse_writepage_args,\n\t\t\t\twritepages_entry);\n\t\tWARN_ON(curr->inode != wpa->inode);\n\t\tcurr_index = curr->ia.write.in.offset >> PAGE_SHIFT;\n\n\t\tif (idx_from >= curr_index + curr->ia.ap.num_pages)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (idx_to < curr_index)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\treturn curr;\n\t}\n\n\trb_link_node(&wpa->writepages_entry, parent, p);\n\trb_insert_color(&wpa->writepages_entry, root);\n\treturn NULL;\n}\n\nstatic void tree_insert(struct rb_root *root, struct fuse_writepage_args *wpa)\n{\n\tWARN_ON(fuse_insert_writeback(root, wpa));\n}\n\nstatic void fuse_writepage_end(struct fuse_mount *fm, struct fuse_args *args,\n\t\t\t       int error)\n{\n\tstruct fuse_writepage_args *wpa =\n\t\tcontainer_of(args, typeof(*wpa), ia.ap.args);\n\tstruct inode *inode = wpa->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tmapping_set_error(inode->i_mapping, error);\n\t \n\tif (!fc->writeback_cache)\n\t\tfuse_invalidate_attr_mask(inode, FUSE_STATX_MODIFY);\n\tspin_lock(&fi->lock);\n\trb_erase(&wpa->writepages_entry, &fi->writepages);\n\twhile (wpa->next) {\n\t\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\t\tstruct fuse_write_in *inarg = &wpa->ia.write.in;\n\t\tstruct fuse_writepage_args *next = wpa->next;\n\n\t\twpa->next = next->next;\n\t\tnext->next = NULL;\n\t\tnext->ia.ff = fuse_file_get(wpa->ia.ff);\n\t\ttree_insert(&fi->writepages, next);\n\n\t\t \n\t\tfuse_send_writepage(fm, next, inarg->offset + inarg->size);\n\t}\n\tfi->writectr--;\n\tfuse_writepage_finish(fm, wpa);\n\tspin_unlock(&fi->lock);\n\tfuse_writepage_free(wpa);\n}\n\nstatic struct fuse_file *__fuse_write_file_get(struct fuse_inode *fi)\n{\n\tstruct fuse_file *ff;\n\n\tspin_lock(&fi->lock);\n\tff = list_first_entry_or_null(&fi->write_files, struct fuse_file,\n\t\t\t\t      write_entry);\n\tif (ff)\n\t\tfuse_file_get(ff);\n\tspin_unlock(&fi->lock);\n\n\treturn ff;\n}\n\nstatic struct fuse_file *fuse_write_file_get(struct fuse_inode *fi)\n{\n\tstruct fuse_file *ff = __fuse_write_file_get(fi);\n\tWARN_ON(!ff);\n\treturn ff;\n}\n\nint fuse_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_file *ff;\n\tint err;\n\n\t \n\tWARN_ON(wbc->for_reclaim);\n\n\tff = __fuse_write_file_get(fi);\n\terr = fuse_flush_times(inode, ff);\n\tif (ff)\n\t\tfuse_file_put(ff, false, false);\n\n\treturn err;\n}\n\nstatic struct fuse_writepage_args *fuse_writepage_args_alloc(void)\n{\n\tstruct fuse_writepage_args *wpa;\n\tstruct fuse_args_pages *ap;\n\n\twpa = kzalloc(sizeof(*wpa), GFP_NOFS);\n\tif (wpa) {\n\t\tap = &wpa->ia.ap;\n\t\tap->num_pages = 0;\n\t\tap->pages = fuse_pages_alloc(1, GFP_NOFS, &ap->descs);\n\t\tif (!ap->pages) {\n\t\t\tkfree(wpa);\n\t\t\twpa = NULL;\n\t\t}\n\t}\n\treturn wpa;\n\n}\n\nstatic void fuse_writepage_add_to_bucket(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_writepage_args *wpa)\n{\n\tif (!fc->sync_fs)\n\t\treturn;\n\n\trcu_read_lock();\n\t \n\tdo {\n\t\twpa->bucket = rcu_dereference(fc->curr_bucket);\n\t} while (unlikely(!atomic_inc_not_zero(&wpa->bucket->count)));\n\trcu_read_unlock();\n}\n\nstatic int fuse_writepage_locked(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_writepage_args *wpa;\n\tstruct fuse_args_pages *ap;\n\tstruct page *tmp_page;\n\tint error = -ENOMEM;\n\n\tset_page_writeback(page);\n\n\twpa = fuse_writepage_args_alloc();\n\tif (!wpa)\n\t\tgoto err;\n\tap = &wpa->ia.ap;\n\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto err_free;\n\n\terror = -EIO;\n\twpa->ia.ff = fuse_write_file_get(fi);\n\tif (!wpa->ia.ff)\n\t\tgoto err_nofile;\n\n\tfuse_writepage_add_to_bucket(fc, wpa);\n\tfuse_write_args_fill(&wpa->ia, wpa->ia.ff, page_offset(page), 0);\n\n\tcopy_highpage(tmp_page, page);\n\twpa->ia.write.in.write_flags |= FUSE_WRITE_CACHE;\n\twpa->next = NULL;\n\tap->args.in_pages = true;\n\tap->num_pages = 1;\n\tap->pages[0] = tmp_page;\n\tap->descs[0].offset = 0;\n\tap->descs[0].length = PAGE_SIZE;\n\tap->args.end = fuse_writepage_end;\n\twpa->inode = inode;\n\n\tinc_wb_stat(&inode_to_bdi(inode)->wb, WB_WRITEBACK);\n\tinc_node_page_state(tmp_page, NR_WRITEBACK_TEMP);\n\n\tspin_lock(&fi->lock);\n\ttree_insert(&fi->writepages, wpa);\n\tlist_add_tail(&wpa->queue_entry, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fi->lock);\n\n\tend_page_writeback(page);\n\n\treturn 0;\n\nerr_nofile:\n\t__free_page(tmp_page);\nerr_free:\n\tkfree(wpa);\nerr:\n\tmapping_set_error(page->mapping, error);\n\tend_page_writeback(page);\n\treturn error;\n}\n\nstatic int fuse_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(page->mapping->host);\n\tint err;\n\n\tif (fuse_page_is_writeback(page->mapping->host, page->index)) {\n\t\t \n\t\tWARN_ON(wbc->sync_mode == WB_SYNC_ALL);\n\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\tif (wbc->sync_mode == WB_SYNC_NONE &&\n\t    fc->num_background >= fc->congestion_threshold)\n\t\treturn AOP_WRITEPAGE_ACTIVATE;\n\n\terr = fuse_writepage_locked(page);\n\tunlock_page(page);\n\n\treturn err;\n}\n\nstruct fuse_fill_wb_data {\n\tstruct fuse_writepage_args *wpa;\n\tstruct fuse_file *ff;\n\tstruct inode *inode;\n\tstruct page **orig_pages;\n\tunsigned int max_pages;\n};\n\nstatic bool fuse_pages_realloc(struct fuse_fill_wb_data *data)\n{\n\tstruct fuse_args_pages *ap = &data->wpa->ia.ap;\n\tstruct fuse_conn *fc = get_fuse_conn(data->inode);\n\tstruct page **pages;\n\tstruct fuse_page_desc *descs;\n\tunsigned int npages = min_t(unsigned int,\n\t\t\t\t    max_t(unsigned int, data->max_pages * 2,\n\t\t\t\t\t  FUSE_DEFAULT_MAX_PAGES_PER_REQ),\n\t\t\t\t    fc->max_pages);\n\tWARN_ON(npages <= data->max_pages);\n\n\tpages = fuse_pages_alloc(npages, GFP_NOFS, &descs);\n\tif (!pages)\n\t\treturn false;\n\n\tmemcpy(pages, ap->pages, sizeof(struct page *) * ap->num_pages);\n\tmemcpy(descs, ap->descs, sizeof(struct fuse_page_desc) * ap->num_pages);\n\tkfree(ap->pages);\n\tap->pages = pages;\n\tap->descs = descs;\n\tdata->max_pages = npages;\n\n\treturn true;\n}\n\nstatic void fuse_writepages_send(struct fuse_fill_wb_data *data)\n{\n\tstruct fuse_writepage_args *wpa = data->wpa;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint num_pages = wpa->ia.ap.num_pages;\n\tint i;\n\n\twpa->ia.ff = fuse_file_get(data->ff);\n\tspin_lock(&fi->lock);\n\tlist_add_tail(&wpa->queue_entry, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fi->lock);\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tend_page_writeback(data->orig_pages[i]);\n}\n\n \nstatic bool fuse_writepage_add(struct fuse_writepage_args *new_wpa,\n\t\t\t       struct page *page)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(new_wpa->inode);\n\tstruct fuse_writepage_args *tmp;\n\tstruct fuse_writepage_args *old_wpa;\n\tstruct fuse_args_pages *new_ap = &new_wpa->ia.ap;\n\n\tWARN_ON(new_ap->num_pages != 0);\n\tnew_ap->num_pages = 1;\n\n\tspin_lock(&fi->lock);\n\told_wpa = fuse_insert_writeback(&fi->writepages, new_wpa);\n\tif (!old_wpa) {\n\t\tspin_unlock(&fi->lock);\n\t\treturn true;\n\t}\n\n\tfor (tmp = old_wpa->next; tmp; tmp = tmp->next) {\n\t\tpgoff_t curr_index;\n\n\t\tWARN_ON(tmp->inode != new_wpa->inode);\n\t\tcurr_index = tmp->ia.write.in.offset >> PAGE_SHIFT;\n\t\tif (curr_index == page->index) {\n\t\t\tWARN_ON(tmp->ia.ap.num_pages != 1);\n\t\t\tswap(tmp->ia.ap.pages[0], new_ap->pages[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!tmp) {\n\t\tnew_wpa->next = old_wpa->next;\n\t\told_wpa->next = new_wpa;\n\t}\n\n\tspin_unlock(&fi->lock);\n\n\tif (tmp) {\n\t\tstruct backing_dev_info *bdi = inode_to_bdi(new_wpa->inode);\n\n\t\tdec_wb_stat(&bdi->wb, WB_WRITEBACK);\n\t\tdec_node_page_state(new_ap->pages[0], NR_WRITEBACK_TEMP);\n\t\twb_writeout_inc(&bdi->wb);\n\t\tfuse_writepage_free(new_wpa);\n\t}\n\n\treturn false;\n}\n\nstatic bool fuse_writepage_need_send(struct fuse_conn *fc, struct page *page,\n\t\t\t\t     struct fuse_args_pages *ap,\n\t\t\t\t     struct fuse_fill_wb_data *data)\n{\n\tWARN_ON(!ap->num_pages);\n\n\t \n\tif (fuse_page_is_writeback(data->inode, page->index))\n\t\treturn true;\n\n\t \n\tif (ap->num_pages == fc->max_pages)\n\t\treturn true;\n\n\t \n\tif ((ap->num_pages + 1) * PAGE_SIZE > fc->max_write)\n\t\treturn true;\n\n\t \n\tif (data->orig_pages[ap->num_pages - 1]->index + 1 != page->index)\n\t\treturn true;\n\n\t \n\tif (ap->num_pages == data->max_pages && !fuse_pages_realloc(data))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int fuse_writepages_fill(struct folio *folio,\n\t\tstruct writeback_control *wbc, void *_data)\n{\n\tstruct fuse_fill_wb_data *data = _data;\n\tstruct fuse_writepage_args *wpa = data->wpa;\n\tstruct fuse_args_pages *ap = &wpa->ia.ap;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct page *tmp_page;\n\tint err;\n\n\tif (!data->ff) {\n\t\terr = -EIO;\n\t\tdata->ff = fuse_write_file_get(fi);\n\t\tif (!data->ff)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (wpa && fuse_writepage_need_send(fc, &folio->page, ap, data)) {\n\t\tfuse_writepages_send(data);\n\t\tdata->wpa = NULL;\n\t}\n\n\terr = -ENOMEM;\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto out_unlock;\n\n\t \n\tif (data->wpa == NULL) {\n\t\terr = -ENOMEM;\n\t\twpa = fuse_writepage_args_alloc();\n\t\tif (!wpa) {\n\t\t\t__free_page(tmp_page);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tfuse_writepage_add_to_bucket(fc, wpa);\n\n\t\tdata->max_pages = 1;\n\n\t\tap = &wpa->ia.ap;\n\t\tfuse_write_args_fill(&wpa->ia, data->ff, folio_pos(folio), 0);\n\t\twpa->ia.write.in.write_flags |= FUSE_WRITE_CACHE;\n\t\twpa->next = NULL;\n\t\tap->args.in_pages = true;\n\t\tap->args.end = fuse_writepage_end;\n\t\tap->num_pages = 0;\n\t\twpa->inode = inode;\n\t}\n\tfolio_start_writeback(folio);\n\n\tcopy_highpage(tmp_page, &folio->page);\n\tap->pages[ap->num_pages] = tmp_page;\n\tap->descs[ap->num_pages].offset = 0;\n\tap->descs[ap->num_pages].length = PAGE_SIZE;\n\tdata->orig_pages[ap->num_pages] = &folio->page;\n\n\tinc_wb_stat(&inode_to_bdi(inode)->wb, WB_WRITEBACK);\n\tinc_node_page_state(tmp_page, NR_WRITEBACK_TEMP);\n\n\terr = 0;\n\tif (data->wpa) {\n\t\t \n\t\tspin_lock(&fi->lock);\n\t\tap->num_pages++;\n\t\tspin_unlock(&fi->lock);\n\t} else if (fuse_writepage_add(wpa, &folio->page)) {\n\t\tdata->wpa = wpa;\n\t} else {\n\t\tfolio_end_writeback(folio);\n\t}\nout_unlock:\n\tfolio_unlock(folio);\n\n\treturn err;\n}\n\nstatic int fuse_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_fill_wb_data data;\n\tint err;\n\n\terr = -EIO;\n\tif (fuse_is_bad(inode))\n\t\tgoto out;\n\n\tif (wbc->sync_mode == WB_SYNC_NONE &&\n\t    fc->num_background >= fc->congestion_threshold)\n\t\treturn 0;\n\n\tdata.inode = inode;\n\tdata.wpa = NULL;\n\tdata.ff = NULL;\n\n\terr = -ENOMEM;\n\tdata.orig_pages = kcalloc(fc->max_pages,\n\t\t\t\t  sizeof(struct page *),\n\t\t\t\t  GFP_NOFS);\n\tif (!data.orig_pages)\n\t\tgoto out;\n\n\terr = write_cache_pages(mapping, wbc, fuse_writepages_fill, &data);\n\tif (data.wpa) {\n\t\tWARN_ON(!data.wpa->ia.ap.num_pages);\n\t\tfuse_writepages_send(&data);\n\t}\n\tif (data.ff)\n\t\tfuse_file_put(data.ff, false, false);\n\n\tkfree(data.orig_pages);\nout:\n\treturn err;\n}\n\n \nstatic int fuse_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, struct page **pagep, void **fsdata)\n{\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tstruct fuse_conn *fc = get_fuse_conn(file_inode(file));\n\tstruct page *page;\n\tloff_t fsize;\n\tint err = -ENOMEM;\n\n\tWARN_ON(!fc->writeback_cache);\n\n\tpage = grab_cache_page_write_begin(mapping, index);\n\tif (!page)\n\t\tgoto error;\n\n\tfuse_wait_on_page_writeback(mapping->host, page->index);\n\n\tif (PageUptodate(page) || len == PAGE_SIZE)\n\t\tgoto success;\n\t \n\tfsize = i_size_read(mapping->host);\n\tif (fsize <= (pos & PAGE_MASK)) {\n\t\tsize_t off = pos & ~PAGE_MASK;\n\t\tif (off)\n\t\t\tzero_user_segment(page, 0, off);\n\t\tgoto success;\n\t}\n\terr = fuse_do_readpage(file, page);\n\tif (err)\n\t\tgoto cleanup;\nsuccess:\n\t*pagep = page;\n\treturn 0;\n\ncleanup:\n\tunlock_page(page);\n\tput_page(page);\nerror:\n\treturn err;\n}\n\nstatic int fuse_write_end(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned copied,\n\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\n\t \n\tif (!copied)\n\t\tgoto unlock;\n\n\tpos += copied;\n\tif (!PageUptodate(page)) {\n\t\t \n\t\tsize_t endoff = pos & ~PAGE_MASK;\n\t\tif (endoff)\n\t\t\tzero_user_segment(page, endoff, PAGE_SIZE);\n\t\tSetPageUptodate(page);\n\t}\n\n\tif (pos > inode->i_size)\n\t\ti_size_write(inode, pos);\n\n\tset_page_dirty(page);\n\nunlock:\n\tunlock_page(page);\n\tput_page(page);\n\n\treturn copied;\n}\n\nstatic int fuse_launder_folio(struct folio *folio)\n{\n\tint err = 0;\n\tif (folio_clear_dirty_for_io(folio)) {\n\t\tstruct inode *inode = folio->mapping->host;\n\n\t\t \n\t\tfuse_wait_on_page_writeback(inode, folio->index);\n\t\terr = fuse_writepage_locked(&folio->page);\n\t\tif (!err)\n\t\t\tfuse_wait_on_page_writeback(inode, folio->index);\n\t}\n\treturn err;\n}\n\n \nstatic void fuse_vma_close(struct vm_area_struct *vma)\n{\n\tint err;\n\n\terr = write_inode_now(vma->vm_file->f_mapping->host, 1);\n\tmapping_set_error(vma->vm_file->f_mapping, err);\n}\n\n \nstatic vm_fault_t fuse_page_mkwrite(struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\n\tfile_update_time(vmf->vma->vm_file);\n\tlock_page(page);\n\tif (page->mapping != inode->i_mapping) {\n\t\tunlock_page(page);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\n\tfuse_wait_on_page_writeback(inode, page->index);\n\treturn VM_FAULT_LOCKED;\n}\n\nstatic const struct vm_operations_struct fuse_file_vm_ops = {\n\t.close\t\t= fuse_vma_close,\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= fuse_page_mkwrite,\n};\n\nstatic int fuse_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fm->fc;\n\n\t \n\tif (FUSE_IS_DAX(file_inode(file)))\n\t\treturn fuse_dax_mmap(file, vma);\n\n\tif (ff->open_flags & FOPEN_DIRECT_IO) {\n\t\t \n\t\tif ((vma->vm_flags & VM_MAYSHARE) && !fc->direct_io_allow_mmap)\n\t\t\treturn -ENODEV;\n\n\t\tinvalidate_inode_pages2(file->f_mapping);\n\n\t\treturn generic_file_mmap(file, vma);\n\t}\n\n\tif ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))\n\t\tfuse_link_write_file(file);\n\n\tfile_accessed(file);\n\tvma->vm_ops = &fuse_file_vm_ops;\n\treturn 0;\n}\n\nstatic int convert_fuse_file_lock(struct fuse_conn *fc,\n\t\t\t\t  const struct fuse_file_lock *ffl,\n\t\t\t\t  struct file_lock *fl)\n{\n\tswitch (ffl->type) {\n\tcase F_UNLCK:\n\t\tbreak;\n\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (ffl->start > OFFSET_MAX || ffl->end > OFFSET_MAX ||\n\t\t    ffl->end < ffl->start)\n\t\t\treturn -EIO;\n\n\t\tfl->fl_start = ffl->start;\n\t\tfl->fl_end = ffl->end;\n\n\t\t \n\t\trcu_read_lock();\n\t\tfl->fl_pid = pid_nr_ns(find_pid_ns(ffl->pid, fc->pid_ns), &init_pid_ns);\n\t\trcu_read_unlock();\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EIO;\n\t}\n\tfl->fl_type = ffl->type;\n\treturn 0;\n}\n\nstatic void fuse_lk_fill(struct fuse_args *args, struct file *file,\n\t\t\t const struct file_lock *fl, int opcode, pid_t pid,\n\t\t\t int flock, struct fuse_lk_in *inarg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\n\tmemset(inarg, 0, sizeof(*inarg));\n\tinarg->fh = ff->fh;\n\tinarg->owner = fuse_lock_owner_id(fc, fl->fl_owner);\n\tinarg->lk.start = fl->fl_start;\n\tinarg->lk.end = fl->fl_end;\n\tinarg->lk.type = fl->fl_type;\n\tinarg->lk.pid = pid;\n\tif (flock)\n\t\tinarg->lk_flags |= FUSE_LK_FLOCK;\n\targs->opcode = opcode;\n\targs->nodeid = get_node_id(inode);\n\targs->in_numargs = 1;\n\targs->in_args[0].size = sizeof(*inarg);\n\targs->in_args[0].value = inarg;\n}\n\nstatic int fuse_getlk(struct file *file, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_lk_in inarg;\n\tstruct fuse_lk_out outarg;\n\tint err;\n\n\tfuse_lk_fill(&args, file, fl, FUSE_GETLK, 0, 0, &inarg);\n\targs.out_numargs = 1;\n\targs.out_args[0].size = sizeof(outarg);\n\targs.out_args[0].value = &outarg;\n\terr = fuse_simple_request(fm, &args);\n\tif (!err)\n\t\terr = convert_fuse_file_lock(fm->fc, &outarg.lk, fl);\n\n\treturn err;\n}\n\nstatic int fuse_setlk(struct file *file, struct file_lock *fl, int flock)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_lk_in inarg;\n\tint opcode = (fl->fl_flags & FL_SLEEP) ? FUSE_SETLKW : FUSE_SETLK;\n\tstruct pid *pid = fl->fl_type != F_UNLCK ? task_tgid(current) : NULL;\n\tpid_t pid_nr = pid_nr_ns(pid, fm->fc->pid_ns);\n\tint err;\n\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant) {\n\t\t \n\t\treturn -ENOLCK;\n\t}\n\n\t \n\tif ((fl->fl_flags & FL_CLOSE_POSIX) == FL_CLOSE_POSIX)\n\t\treturn 0;\n\n\tfuse_lk_fill(&args, file, fl, opcode, pid_nr, flock, &inarg);\n\terr = fuse_simple_request(fm, &args);\n\n\t \n\tif (err == -EINTR)\n\t\terr = -ERESTARTSYS;\n\n\treturn err;\n}\n\nstatic int fuse_file_lock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\n\tif (cmd == F_CANCELLK) {\n\t\terr = 0;\n\t} else if (cmd == F_GETLK) {\n\t\tif (fc->no_lock) {\n\t\t\tposix_test_lock(file, fl);\n\t\t\terr = 0;\n\t\t} else\n\t\t\terr = fuse_getlk(file, fl);\n\t} else {\n\t\tif (fc->no_lock)\n\t\t\terr = posix_lock_file(file, fl, NULL);\n\t\telse\n\t\t\terr = fuse_setlk(file, fl, 0);\n\t}\n\treturn err;\n}\n\nstatic int fuse_file_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\n\tif (fc->no_flock) {\n\t\terr = locks_lock_file_wait(file, fl);\n\t} else {\n\t\tstruct fuse_file *ff = file->private_data;\n\n\t\t \n\t\tff->flock = true;\n\t\terr = fuse_setlk(file, fl, 1);\n\t}\n\n\treturn err;\n}\n\nstatic sector_t fuse_bmap(struct address_space *mapping, sector_t block)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_bmap_in inarg;\n\tstruct fuse_bmap_out outarg;\n\tint err;\n\n\tif (!inode->i_sb->s_bdev || fm->fc->no_bmap)\n\t\treturn 0;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.block = block;\n\tinarg.blocksize = inode->i_sb->s_blocksize;\n\targs.opcode = FUSE_BMAP;\n\targs.nodeid = get_node_id(inode);\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.out_numargs = 1;\n\targs.out_args[0].size = sizeof(outarg);\n\targs.out_args[0].value = &outarg;\n\terr = fuse_simple_request(fm, &args);\n\tif (err == -ENOSYS)\n\t\tfm->fc->no_bmap = 1;\n\n\treturn err ? 0 : outarg.block;\n}\n\nstatic loff_t fuse_lseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tFUSE_ARGS(args);\n\tstruct fuse_lseek_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.offset = offset,\n\t\t.whence = whence\n\t};\n\tstruct fuse_lseek_out outarg;\n\tint err;\n\n\tif (fm->fc->no_lseek)\n\t\tgoto fallback;\n\n\targs.opcode = FUSE_LSEEK;\n\targs.nodeid = ff->nodeid;\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.out_numargs = 1;\n\targs.out_args[0].size = sizeof(outarg);\n\targs.out_args[0].value = &outarg;\n\terr = fuse_simple_request(fm, &args);\n\tif (err) {\n\t\tif (err == -ENOSYS) {\n\t\t\tfm->fc->no_lseek = 1;\n\t\t\tgoto fallback;\n\t\t}\n\t\treturn err;\n\t}\n\n\treturn vfs_setpos(file, outarg.offset, inode->i_sb->s_maxbytes);\n\nfallback:\n\terr = fuse_update_attributes(inode, file, STATX_SIZE);\n\tif (!err)\n\t\treturn generic_file_llseek(file, offset, whence);\n\telse\n\t\treturn err;\n}\n\nstatic loff_t fuse_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t retval;\n\tstruct inode *inode = file_inode(file);\n\n\tswitch (whence) {\n\tcase SEEK_SET:\n\tcase SEEK_CUR:\n\t\t  \n\t\tretval = generic_file_llseek(file, offset, whence);\n\t\tbreak;\n\tcase SEEK_END:\n\t\tinode_lock(inode);\n\t\tretval = fuse_update_attributes(inode, file, STATX_SIZE);\n\t\tif (!retval)\n\t\t\tretval = generic_file_llseek(file, offset, whence);\n\t\tinode_unlock(inode);\n\t\tbreak;\n\tcase SEEK_HOLE:\n\tcase SEEK_DATA:\n\t\tinode_lock(inode);\n\t\tretval = fuse_lseek(file, offset, whence);\n\t\tinode_unlock(inode);\n\t\tbreak;\n\tdefault:\n\t\tretval = -EINVAL;\n\t}\n\n\treturn retval;\n}\n\n \nstatic struct rb_node **fuse_find_polled_node(struct fuse_conn *fc, u64 kh,\n\t\t\t\t\t      struct rb_node **parent_out)\n{\n\tstruct rb_node **link = &fc->polled_files.rb_node;\n\tstruct rb_node *last = NULL;\n\n\twhile (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tlast = *link;\n\t\tff = rb_entry(last, struct fuse_file, polled_node);\n\n\t\tif (kh < ff->kh)\n\t\t\tlink = &last->rb_left;\n\t\telse if (kh > ff->kh)\n\t\t\tlink = &last->rb_right;\n\t\telse\n\t\t\treturn link;\n\t}\n\n\tif (parent_out)\n\t\t*parent_out = last;\n\treturn link;\n}\n\n \nstatic void fuse_register_polled_file(struct fuse_conn *fc,\n\t\t\t\t      struct fuse_file *ff)\n{\n\tspin_lock(&fc->lock);\n\tif (RB_EMPTY_NODE(&ff->polled_node)) {\n\t\tstruct rb_node **link, *parent;\n\n\t\tlink = fuse_find_polled_node(fc, ff->kh, &parent);\n\t\tBUG_ON(*link);\n\t\trb_link_node(&ff->polled_node, parent, link);\n\t\trb_insert_color(&ff->polled_node, &fc->polled_files);\n\t}\n\tspin_unlock(&fc->lock);\n}\n\n__poll_t fuse_file_poll(struct file *file, poll_table *wait)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_mount *fm = ff->fm;\n\tstruct fuse_poll_in inarg = { .fh = ff->fh, .kh = ff->kh };\n\tstruct fuse_poll_out outarg;\n\tFUSE_ARGS(args);\n\tint err;\n\n\tif (fm->fc->no_poll)\n\t\treturn DEFAULT_POLLMASK;\n\n\tpoll_wait(file, &ff->poll_wait, wait);\n\tinarg.events = mangle_poll(poll_requested_events(wait));\n\n\t \n\tif (waitqueue_active(&ff->poll_wait)) {\n\t\tinarg.flags |= FUSE_POLL_SCHEDULE_NOTIFY;\n\t\tfuse_register_polled_file(fm->fc, ff);\n\t}\n\n\targs.opcode = FUSE_POLL;\n\targs.nodeid = ff->nodeid;\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.out_numargs = 1;\n\targs.out_args[0].size = sizeof(outarg);\n\targs.out_args[0].value = &outarg;\n\terr = fuse_simple_request(fm, &args);\n\n\tif (!err)\n\t\treturn demangle_poll(outarg.revents);\n\tif (err == -ENOSYS) {\n\t\tfm->fc->no_poll = 1;\n\t\treturn DEFAULT_POLLMASK;\n\t}\n\treturn EPOLLERR;\n}\nEXPORT_SYMBOL_GPL(fuse_file_poll);\n\n \nint fuse_notify_poll_wakeup(struct fuse_conn *fc,\n\t\t\t    struct fuse_notify_poll_wakeup_out *outarg)\n{\n\tu64 kh = outarg->kh;\n\tstruct rb_node **link;\n\n\tspin_lock(&fc->lock);\n\n\tlink = fuse_find_polled_node(fc, kh, NULL);\n\tif (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tff = rb_entry(*link, struct fuse_file, polled_node);\n\t\twake_up_interruptible_sync(&ff->poll_wait);\n\t}\n\n\tspin_unlock(&fc->lock);\n\treturn 0;\n}\n\nstatic void fuse_do_truncate(struct file *file)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct iattr attr;\n\n\tattr.ia_valid = ATTR_SIZE;\n\tattr.ia_size = i_size_read(inode);\n\n\tattr.ia_file = file;\n\tattr.ia_valid |= ATTR_FILE;\n\n\tfuse_do_setattr(file_dentry(file), &attr, file);\n}\n\nstatic inline loff_t fuse_round_up(struct fuse_conn *fc, loff_t off)\n{\n\treturn round_up(off, fc->max_pages << PAGE_SHIFT);\n}\n\nstatic ssize_t\nfuse_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tDECLARE_COMPLETION_ONSTACK(wait);\n\tssize_t ret = 0;\n\tstruct file *file = iocb->ki_filp;\n\tstruct fuse_file *ff = file->private_data;\n\tloff_t pos = 0;\n\tstruct inode *inode;\n\tloff_t i_size;\n\tsize_t count = iov_iter_count(iter), shortened = 0;\n\tloff_t offset = iocb->ki_pos;\n\tstruct fuse_io_priv *io;\n\n\tpos = offset;\n\tinode = file->f_mapping->host;\n\ti_size = i_size_read(inode);\n\n\tif ((iov_iter_rw(iter) == READ) && (offset >= i_size))\n\t\treturn 0;\n\n\tio = kmalloc(sizeof(struct fuse_io_priv), GFP_KERNEL);\n\tif (!io)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&io->lock);\n\tkref_init(&io->refcnt);\n\tio->reqs = 1;\n\tio->bytes = -1;\n\tio->size = 0;\n\tio->offset = offset;\n\tio->write = (iov_iter_rw(iter) == WRITE);\n\tio->err = 0;\n\t \n\tio->async = ff->fm->fc->async_dio;\n\tio->iocb = iocb;\n\tio->blocking = is_sync_kiocb(iocb);\n\n\t \n\tif (io->async && !io->write && offset + count > i_size) {\n\t\tiov_iter_truncate(iter, fuse_round_up(ff->fm->fc, i_size - offset));\n\t\tshortened = count - iov_iter_count(iter);\n\t\tcount -= shortened;\n\t}\n\n\t \n\tif ((offset + count > i_size) && io->write)\n\t\tio->blocking = true;\n\n\tif (io->async && io->blocking) {\n\t\t \n\t\tkref_get(&io->refcnt);\n\t\tio->done = &wait;\n\t}\n\n\tif (iov_iter_rw(iter) == WRITE) {\n\t\tret = fuse_direct_io(io, iter, &pos, FUSE_DIO_WRITE);\n\t\tfuse_invalidate_attr_mask(inode, FUSE_STATX_MODSIZE);\n\t} else {\n\t\tret = __fuse_direct_read(io, iter, &pos);\n\t}\n\tiov_iter_reexpand(iter, iov_iter_count(iter) + shortened);\n\n\tif (io->async) {\n\t\tbool blocking = io->blocking;\n\n\t\tfuse_aio_complete(io, ret < 0 ? ret : 0, -1);\n\n\t\t \n\t\tif (!blocking)\n\t\t\treturn -EIOCBQUEUED;\n\n\t\twait_for_completion(&wait);\n\t\tret = fuse_get_res_by_io(io);\n\t}\n\n\tkref_put(&io->refcnt, fuse_io_release);\n\n\tif (iov_iter_rw(iter) == WRITE) {\n\t\tfuse_write_update_attr(inode, pos, ret);\n\t\t \n\t\tif (ret < 0 && offset + count > i_size)\n\t\t\tfuse_do_truncate(file);\n\t}\n\n\treturn ret;\n}\n\nstatic int fuse_writeback_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tint err = filemap_write_and_wait_range(inode->i_mapping, start, LLONG_MAX);\n\n\tif (!err)\n\t\tfuse_sync_writes(inode);\n\n\treturn err;\n}\n\nstatic long fuse_file_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\t\tloff_t length)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_mount *fm = ff->fm;\n\tFUSE_ARGS(args);\n\tstruct fuse_fallocate_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.offset = offset,\n\t\t.length = length,\n\t\t.mode = mode\n\t};\n\tint err;\n\tbool block_faults = FUSE_IS_DAX(inode) &&\n\t\t(!(mode & FALLOC_FL_KEEP_SIZE) ||\n\t\t (mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)));\n\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |\n\t\t     FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (fm->fc->no_fallocate)\n\t\treturn -EOPNOTSUPP;\n\n\tinode_lock(inode);\n\tif (block_faults) {\n\t\tfilemap_invalidate_lock(inode->i_mapping);\n\t\terr = fuse_dax_break_layouts(inode, 0, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) {\n\t\tloff_t endbyte = offset + length - 1;\n\n\t\terr = fuse_writeback_range(inode, offset, endbyte);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t    offset + length > i_size_read(inode)) {\n\t\terr = inode_newsize_ok(inode, offset + length);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = file_modified(file);\n\tif (err)\n\t\tgoto out;\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE))\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\targs.opcode = FUSE_FALLOCATE;\n\targs.nodeid = ff->nodeid;\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\terr = fuse_simple_request(fm, &args);\n\tif (err == -ENOSYS) {\n\t\tfm->fc->no_fallocate = 1;\n\t\terr = -EOPNOTSUPP;\n\t}\n\tif (err)\n\t\tgoto out;\n\n\t \n\tif (!(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\tif (fuse_write_update_attr(inode, offset + length, length))\n\t\t\tfile_update_time(file);\n\t}\n\n\tif (mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE))\n\t\ttruncate_pagecache_range(inode, offset, offset + length - 1);\n\n\tfuse_invalidate_attr_mask(inode, FUSE_STATX_MODSIZE);\n\nout:\n\tif (!(mode & FALLOC_FL_KEEP_SIZE))\n\t\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tif (block_faults)\n\t\tfilemap_invalidate_unlock(inode->i_mapping);\n\n\tinode_unlock(inode);\n\n\tfuse_flush_time_update(inode);\n\n\treturn err;\n}\n\nstatic ssize_t __fuse_copy_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t      struct file *file_out, loff_t pos_out,\n\t\t\t\t      size_t len, unsigned int flags)\n{\n\tstruct fuse_file *ff_in = file_in->private_data;\n\tstruct fuse_file *ff_out = file_out->private_data;\n\tstruct inode *inode_in = file_inode(file_in);\n\tstruct inode *inode_out = file_inode(file_out);\n\tstruct fuse_inode *fi_out = get_fuse_inode(inode_out);\n\tstruct fuse_mount *fm = ff_in->fm;\n\tstruct fuse_conn *fc = fm->fc;\n\tFUSE_ARGS(args);\n\tstruct fuse_copy_file_range_in inarg = {\n\t\t.fh_in = ff_in->fh,\n\t\t.off_in = pos_in,\n\t\t.nodeid_out = ff_out->nodeid,\n\t\t.fh_out = ff_out->fh,\n\t\t.off_out = pos_out,\n\t\t.len = len,\n\t\t.flags = flags\n\t};\n\tstruct fuse_write_out outarg;\n\tssize_t err;\n\t \n\tbool is_unstable = (!fc->writeback_cache) &&\n\t\t\t   ((pos_out + len) > inode_out->i_size);\n\n\tif (fc->no_copy_file_range)\n\t\treturn -EOPNOTSUPP;\n\n\tif (file_inode(file_in)->i_sb != file_inode(file_out)->i_sb)\n\t\treturn -EXDEV;\n\n\tinode_lock(inode_in);\n\terr = fuse_writeback_range(inode_in, pos_in, pos_in + len - 1);\n\tinode_unlock(inode_in);\n\tif (err)\n\t\treturn err;\n\n\tinode_lock(inode_out);\n\n\terr = file_modified(file_out);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = fuse_writeback_range(inode_out, pos_out, pos_out + len - 1);\n\tif (err)\n\t\tgoto out;\n\n\tif (is_unstable)\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi_out->state);\n\n\targs.opcode = FUSE_COPY_FILE_RANGE;\n\targs.nodeid = ff_in->nodeid;\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.out_numargs = 1;\n\targs.out_args[0].size = sizeof(outarg);\n\targs.out_args[0].value = &outarg;\n\terr = fuse_simple_request(fm, &args);\n\tif (err == -ENOSYS) {\n\t\tfc->no_copy_file_range = 1;\n\t\terr = -EOPNOTSUPP;\n\t}\n\tif (err)\n\t\tgoto out;\n\n\ttruncate_inode_pages_range(inode_out->i_mapping,\n\t\t\t\t   ALIGN_DOWN(pos_out, PAGE_SIZE),\n\t\t\t\t   ALIGN(pos_out + outarg.size, PAGE_SIZE) - 1);\n\n\tfile_update_time(file_out);\n\tfuse_write_update_attr(inode_out, pos_out + outarg.size, outarg.size);\n\n\terr = outarg.size;\nout:\n\tif (is_unstable)\n\t\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi_out->state);\n\n\tinode_unlock(inode_out);\n\tfile_accessed(file_in);\n\n\tfuse_flush_time_update(inode_out);\n\n\treturn err;\n}\n\nstatic ssize_t fuse_copy_file_range(struct file *src_file, loff_t src_off,\n\t\t\t\t    struct file *dst_file, loff_t dst_off,\n\t\t\t\t    size_t len, unsigned int flags)\n{\n\tssize_t ret;\n\n\tret = __fuse_copy_file_range(src_file, src_off, dst_file, dst_off,\n\t\t\t\t     len, flags);\n\n\tif (ret == -EOPNOTSUPP || ret == -EXDEV)\n\t\tret = generic_copy_file_range(src_file, src_off, dst_file,\n\t\t\t\t\t      dst_off, len, flags);\n\treturn ret;\n}\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.get_unmapped_area = thp_get_unmapped_area,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= filemap_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n\t.copy_file_range = fuse_copy_file_range,\n};\n\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.read_folio\t= fuse_read_folio,\n\t.readahead\t= fuse_readahead,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_folio\t= fuse_launder_folio,\n\t.dirty_folio\t= filemap_dirty_folio,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode, unsigned int flags)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n\n\tINIT_LIST_HEAD(&fi->write_files);\n\tINIT_LIST_HEAD(&fi->queued_writes);\n\tfi->writectr = 0;\n\tinit_waitqueue_head(&fi->page_waitq);\n\tfi->writepages = RB_ROOT;\n\n\tif (IS_ENABLED(CONFIG_FUSE_DAX))\n\t\tfuse_dax_inode_init(inode, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}