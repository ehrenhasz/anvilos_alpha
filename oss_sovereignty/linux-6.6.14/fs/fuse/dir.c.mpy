{
  "module_name": "dir.c",
  "hash_id": "884f0f708955a564cda3c38c68c48399287ce2d883ff0407e7cf6404650cbef6",
  "original_prompt": "Ingested from linux-6.6.14/fs/fuse/dir.c",
  "human_readable_source": " \n\n#include \"fuse_i.h\"\n\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs_context.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/iversion.h>\n#include <linux/posix_acl.h>\n#include <linux/security.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic bool __read_mostly allow_sys_admin_access;\nmodule_param(allow_sys_admin_access, bool, 0644);\nMODULE_PARM_DESC(allow_sys_admin_access,\n\t\t \"Allow users with CAP_SYS_ADMIN in initial userns to bypass allow_other access check\");\n\nstatic void fuse_advise_use_readdirplus(struct inode *dir)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(dir);\n\n\tset_bit(FUSE_I_ADVISE_RDPLUS, &fi->state);\n}\n\n#if BITS_PER_LONG >= 64\nstatic inline void __fuse_dentry_settime(struct dentry *entry, u64 time)\n{\n\tentry->d_fsdata = (void *) time;\n}\n\nstatic inline u64 fuse_dentry_time(const struct dentry *entry)\n{\n\treturn (u64)entry->d_fsdata;\n}\n\n#else\nunion fuse_dentry {\n\tu64 time;\n\tstruct rcu_head rcu;\n};\n\nstatic inline void __fuse_dentry_settime(struct dentry *dentry, u64 time)\n{\n\t((union fuse_dentry *) dentry->d_fsdata)->time = time;\n}\n\nstatic inline u64 fuse_dentry_time(const struct dentry *entry)\n{\n\treturn ((union fuse_dentry *) entry->d_fsdata)->time;\n}\n#endif\n\nstatic void fuse_dentry_settime(struct dentry *dentry, u64 time)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(dentry->d_sb);\n\tbool delete = !time && fc->delete_stale;\n\t \n\tif ((!delete && (dentry->d_flags & DCACHE_OP_DELETE)) ||\n\t    (delete && !(dentry->d_flags & DCACHE_OP_DELETE))) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (!delete)\n\t\t\tdentry->d_flags &= ~DCACHE_OP_DELETE;\n\t\telse\n\t\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\n\t__fuse_dentry_settime(dentry, time);\n}\n\n \n\n \nu64 fuse_time_to_jiffies(u64 sec, u32 nsec)\n{\n\tif (sec || nsec) {\n\t\tstruct timespec64 ts = {\n\t\t\tsec,\n\t\t\tmin_t(u32, nsec, NSEC_PER_SEC - 1)\n\t\t};\n\n\t\treturn get_jiffies_64() + timespec64_to_jiffies(&ts);\n\t} else\n\t\treturn 0;\n}\n\n \nvoid fuse_change_entry_timeout(struct dentry *entry, struct fuse_entry_out *o)\n{\n\tfuse_dentry_settime(entry,\n\t\tfuse_time_to_jiffies(o->entry_valid, o->entry_valid_nsec));\n}\n\nvoid fuse_invalidate_attr_mask(struct inode *inode, u32 mask)\n{\n\tset_mask_bits(&get_fuse_inode(inode)->inval_mask, 0, mask);\n}\n\n \nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tfuse_invalidate_attr_mask(inode, STATX_BASIC_STATS);\n}\n\nstatic void fuse_dir_changed(struct inode *dir)\n{\n\tfuse_invalidate_attr(dir);\n\tinode_maybe_inc_iversion(dir, false);\n}\n\n \nvoid fuse_invalidate_atime(struct inode *inode)\n{\n\tif (!IS_RDONLY(inode))\n\t\tfuse_invalidate_attr_mask(inode, STATX_ATIME);\n}\n\n \nvoid fuse_invalidate_entry_cache(struct dentry *entry)\n{\n\tfuse_dentry_settime(entry, 0);\n}\n\n \nstatic void fuse_invalidate_entry(struct dentry *entry)\n{\n\td_invalidate(entry);\n\tfuse_invalidate_entry_cache(entry);\n}\n\nstatic void fuse_lookup_init(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t     u64 nodeid, const struct qstr *name,\n\t\t\t     struct fuse_entry_out *outarg)\n{\n\tmemset(outarg, 0, sizeof(struct fuse_entry_out));\n\targs->opcode = FUSE_LOOKUP;\n\targs->nodeid = nodeid;\n\targs->in_numargs = 1;\n\targs->in_args[0].size = name->len + 1;\n\targs->in_args[0].value = name->name;\n\targs->out_numargs = 1;\n\targs->out_args[0].size = sizeof(struct fuse_entry_out);\n\targs->out_args[0].value = outarg;\n}\n\n \nstatic int fuse_dentry_revalidate(struct dentry *entry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct dentry *parent;\n\tstruct fuse_mount *fm;\n\tstruct fuse_inode *fi;\n\tint ret;\n\n\tinode = d_inode_rcu(entry);\n\tif (inode && fuse_is_bad(inode))\n\t\tgoto invalid;\n\telse if (time_before64(fuse_dentry_time(entry), get_jiffies_64()) ||\n\t\t (flags & (LOOKUP_EXCL | LOOKUP_REVAL | LOOKUP_RENAME_TARGET))) {\n\t\tstruct fuse_entry_out outarg;\n\t\tFUSE_ARGS(args);\n\t\tstruct fuse_forget_link *forget;\n\t\tu64 attr_version;\n\n\t\t \n\t\tif (!inode)\n\t\t\tgoto invalid;\n\n\t\tret = -ECHILD;\n\t\tif (flags & LOOKUP_RCU)\n\t\t\tgoto out;\n\n\t\tfm = get_fuse_mount(inode);\n\n\t\tforget = fuse_alloc_forget();\n\t\tret = -ENOMEM;\n\t\tif (!forget)\n\t\t\tgoto out;\n\n\t\tattr_version = fuse_get_attr_version(fm->fc);\n\n\t\tparent = dget_parent(entry);\n\t\tfuse_lookup_init(fm->fc, &args, get_node_id(d_inode(parent)),\n\t\t\t\t &entry->d_name, &outarg);\n\t\tret = fuse_simple_request(fm, &args);\n\t\tdput(parent);\n\t\t \n\t\tif (!ret && !outarg.nodeid)\n\t\t\tret = -ENOENT;\n\t\tif (!ret) {\n\t\t\tfi = get_fuse_inode(inode);\n\t\t\tif (outarg.nodeid != get_node_id(inode) ||\n\t\t\t    (bool) IS_AUTOMOUNT(inode) != (bool) (outarg.attr.flags & FUSE_ATTR_SUBMOUNT)) {\n\t\t\t\tfuse_queue_forget(fm->fc, forget,\n\t\t\t\t\t\t  outarg.nodeid, 1);\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tspin_lock(&fi->lock);\n\t\t\tfi->nlookup++;\n\t\t\tspin_unlock(&fi->lock);\n\t\t}\n\t\tkfree(forget);\n\t\tif (ret == -ENOMEM || ret == -EINTR)\n\t\t\tgoto out;\n\t\tif (ret || fuse_invalid_attr(&outarg.attr) ||\n\t\t    fuse_stale_inode(inode, outarg.generation, &outarg.attr))\n\t\t\tgoto invalid;\n\n\t\tforget_all_cached_acls(inode);\n\t\tfuse_change_attributes(inode, &outarg.attr, NULL,\n\t\t\t\t       ATTR_TIMEOUT(&outarg),\n\t\t\t\t       attr_version);\n\t\tfuse_change_entry_timeout(entry, &outarg);\n\t} else if (inode) {\n\t\tfi = get_fuse_inode(inode);\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tif (test_bit(FUSE_I_INIT_RDPLUS, &fi->state))\n\t\t\t\treturn -ECHILD;\n\t\t} else if (test_and_clear_bit(FUSE_I_INIT_RDPLUS, &fi->state)) {\n\t\t\tparent = dget_parent(entry);\n\t\t\tfuse_advise_use_readdirplus(d_inode(parent));\n\t\t\tdput(parent);\n\t\t}\n\t}\n\tret = 1;\nout:\n\treturn ret;\n\ninvalid:\n\tret = 0;\n\tgoto out;\n}\n\n#if BITS_PER_LONG < 64\nstatic int fuse_dentry_init(struct dentry *dentry)\n{\n\tdentry->d_fsdata = kzalloc(sizeof(union fuse_dentry),\n\t\t\t\t   GFP_KERNEL_ACCOUNT | __GFP_RECLAIMABLE);\n\n\treturn dentry->d_fsdata ? 0 : -ENOMEM;\n}\nstatic void fuse_dentry_release(struct dentry *dentry)\n{\n\tunion fuse_dentry *fd = dentry->d_fsdata;\n\n\tkfree_rcu(fd, rcu);\n}\n#endif\n\nstatic int fuse_dentry_delete(const struct dentry *dentry)\n{\n\treturn time_before64(fuse_dentry_time(dentry), get_jiffies_64());\n}\n\n \nstatic struct vfsmount *fuse_dentry_automount(struct path *path)\n{\n\tstruct fs_context *fsc;\n\tstruct vfsmount *mnt;\n\tstruct fuse_inode *mp_fi = get_fuse_inode(d_inode(path->dentry));\n\n\tfsc = fs_context_for_submount(path->mnt->mnt_sb->s_type, path->dentry);\n\tif (IS_ERR(fsc))\n\t\treturn ERR_CAST(fsc);\n\n\t \n\tfsc->fs_private = mp_fi;\n\n\t \n\tmnt = fc_mount(fsc);\n\tif (!IS_ERR(mnt))\n\t\tmntget(mnt);\n\n\tput_fs_context(fsc);\n\treturn mnt;\n}\n\nconst struct dentry_operations fuse_dentry_operations = {\n\t.d_revalidate\t= fuse_dentry_revalidate,\n\t.d_delete\t= fuse_dentry_delete,\n#if BITS_PER_LONG < 64\n\t.d_init\t\t= fuse_dentry_init,\n\t.d_release\t= fuse_dentry_release,\n#endif\n\t.d_automount\t= fuse_dentry_automount,\n};\n\nconst struct dentry_operations fuse_root_dentry_operations = {\n#if BITS_PER_LONG < 64\n\t.d_init\t\t= fuse_dentry_init,\n\t.d_release\t= fuse_dentry_release,\n#endif\n};\n\nint fuse_valid_type(int m)\n{\n\treturn S_ISREG(m) || S_ISDIR(m) || S_ISLNK(m) || S_ISCHR(m) ||\n\t\tS_ISBLK(m) || S_ISFIFO(m) || S_ISSOCK(m);\n}\n\nstatic bool fuse_valid_size(u64 size)\n{\n\treturn size <= LLONG_MAX;\n}\n\nbool fuse_invalid_attr(struct fuse_attr *attr)\n{\n\treturn !fuse_valid_type(attr->mode) || !fuse_valid_size(attr->size);\n}\n\nint fuse_lookup_name(struct super_block *sb, u64 nodeid, const struct qstr *name,\n\t\t     struct fuse_entry_out *outarg, struct inode **inode)\n{\n\tstruct fuse_mount *fm = get_fuse_mount_super(sb);\n\tFUSE_ARGS(args);\n\tstruct fuse_forget_link *forget;\n\tu64 attr_version;\n\tint err;\n\n\t*inode = NULL;\n\terr = -ENAMETOOLONG;\n\tif (name->len > FUSE_NAME_MAX)\n\t\tgoto out;\n\n\n\tforget = fuse_alloc_forget();\n\terr = -ENOMEM;\n\tif (!forget)\n\t\tgoto out;\n\n\tattr_version = fuse_get_attr_version(fm->fc);\n\n\tfuse_lookup_init(fm->fc, &args, nodeid, name, outarg);\n\terr = fuse_simple_request(fm, &args);\n\t \n\tif (err || !outarg->nodeid)\n\t\tgoto out_put_forget;\n\n\terr = -EIO;\n\tif (fuse_invalid_attr(&outarg->attr))\n\t\tgoto out_put_forget;\n\n\t*inode = fuse_iget(sb, outarg->nodeid, outarg->generation,\n\t\t\t   &outarg->attr, ATTR_TIMEOUT(outarg),\n\t\t\t   attr_version);\n\terr = -ENOMEM;\n\tif (!*inode) {\n\t\tfuse_queue_forget(fm->fc, forget, outarg->nodeid, 1);\n\t\tgoto out;\n\t}\n\terr = 0;\n\n out_put_forget:\n\tkfree(forget);\n out:\n\treturn err;\n}\n\nstatic struct dentry *fuse_lookup(struct inode *dir, struct dentry *entry,\n\t\t\t\t  unsigned int flags)\n{\n\tint err;\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tstruct dentry *newent;\n\tbool outarg_valid = true;\n\tbool locked;\n\n\tif (fuse_is_bad(dir))\n\t\treturn ERR_PTR(-EIO);\n\n\tlocked = fuse_lock_inode(dir);\n\terr = fuse_lookup_name(dir->i_sb, get_node_id(dir), &entry->d_name,\n\t\t\t       &outarg, &inode);\n\tfuse_unlock_inode(dir, locked);\n\tif (err == -ENOENT) {\n\t\toutarg_valid = false;\n\t\terr = 0;\n\t}\n\tif (err)\n\t\tgoto out_err;\n\n\terr = -EIO;\n\tif (inode && get_node_id(inode) == FUSE_ROOT_ID)\n\t\tgoto out_iput;\n\n\tnewent = d_splice_alias(inode, entry);\n\terr = PTR_ERR(newent);\n\tif (IS_ERR(newent))\n\t\tgoto out_err;\n\n\tentry = newent ? newent : entry;\n\tif (outarg_valid)\n\t\tfuse_change_entry_timeout(entry, &outarg);\n\telse\n\t\tfuse_invalidate_entry_cache(entry);\n\n\tif (inode)\n\t\tfuse_advise_use_readdirplus(dir);\n\treturn newent;\n\n out_iput:\n\tiput(inode);\n out_err:\n\treturn ERR_PTR(err);\n}\n\nstatic int get_security_context(struct dentry *entry, umode_t mode,\n\t\t\t\tstruct fuse_in_arg *ext)\n{\n\tstruct fuse_secctx *fctx;\n\tstruct fuse_secctx_header *header;\n\tvoid *ctx = NULL, *ptr;\n\tu32 ctxlen, total_len = sizeof(*header);\n\tint err, nr_ctx = 0;\n\tconst char *name;\n\tsize_t namelen;\n\n\terr = security_dentry_init_security(entry, mode, &entry->d_name,\n\t\t\t\t\t    &name, &ctx, &ctxlen);\n\tif (err) {\n\t\tif (err != -EOPNOTSUPP)\n\t\t\tgoto out_err;\n\t\t \n\t\tctxlen = 0;\n\t\tctx = NULL;\n\t}\n\n\tif (ctxlen) {\n\t\tnr_ctx = 1;\n\t\tnamelen = strlen(name) + 1;\n\t\terr = -EIO;\n\t\tif (WARN_ON(namelen > XATTR_NAME_MAX + 1 || ctxlen > S32_MAX))\n\t\t\tgoto out_err;\n\t\ttotal_len += FUSE_REC_ALIGN(sizeof(*fctx) + namelen + ctxlen);\n\t}\n\n\terr = -ENOMEM;\n\theader = ptr = kzalloc(total_len, GFP_KERNEL);\n\tif (!ptr)\n\t\tgoto out_err;\n\n\theader->nr_secctx = nr_ctx;\n\theader->size = total_len;\n\tptr += sizeof(*header);\n\tif (nr_ctx) {\n\t\tfctx = ptr;\n\t\tfctx->size = ctxlen;\n\t\tptr += sizeof(*fctx);\n\n\t\tstrcpy(ptr, name);\n\t\tptr += namelen;\n\n\t\tmemcpy(ptr, ctx, ctxlen);\n\t}\n\text->size = total_len;\n\text->value = header;\n\terr = 0;\nout_err:\n\tkfree(ctx);\n\treturn err;\n}\n\nstatic void *extend_arg(struct fuse_in_arg *buf, u32 bytes)\n{\n\tvoid *p;\n\tu32 newlen = buf->size + bytes;\n\n\tp = krealloc(buf->value, newlen, GFP_KERNEL);\n\tif (!p) {\n\t\tkfree(buf->value);\n\t\tbuf->size = 0;\n\t\tbuf->value = NULL;\n\t\treturn NULL;\n\t}\n\n\tmemset(p + buf->size, 0, bytes);\n\tbuf->value = p;\n\tbuf->size = newlen;\n\n\treturn p + newlen - bytes;\n}\n\nstatic u32 fuse_ext_size(size_t size)\n{\n\treturn FUSE_REC_ALIGN(sizeof(struct fuse_ext_header) + size);\n}\n\n \nstatic int get_create_supp_group(struct inode *dir, struct fuse_in_arg *ext)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tstruct fuse_ext_header *xh;\n\tstruct fuse_supp_groups *sg;\n\tkgid_t kgid = dir->i_gid;\n\tgid_t parent_gid = from_kgid(fc->user_ns, kgid);\n\tu32 sg_len = fuse_ext_size(sizeof(*sg) + sizeof(sg->groups[0]));\n\n\tif (parent_gid == (gid_t) -1 || gid_eq(kgid, current_fsgid()) ||\n\t    !in_group_p(kgid))\n\t\treturn 0;\n\n\txh = extend_arg(ext, sg_len);\n\tif (!xh)\n\t\treturn -ENOMEM;\n\n\txh->size = sg_len;\n\txh->type = FUSE_EXT_GROUPS;\n\n\tsg = (struct fuse_supp_groups *) &xh[1];\n\tsg->nr_groups = 1;\n\tsg->groups[0] = parent_gid;\n\n\treturn 0;\n}\n\nstatic int get_create_ext(struct fuse_args *args,\n\t\t\t  struct inode *dir, struct dentry *dentry,\n\t\t\t  umode_t mode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(dentry->d_sb);\n\tstruct fuse_in_arg ext = { .size = 0, .value = NULL };\n\tint err = 0;\n\n\tif (fc->init_security)\n\t\terr = get_security_context(dentry, mode, &ext);\n\tif (!err && fc->create_supp_group)\n\t\terr = get_create_supp_group(dir, &ext);\n\n\tif (!err && ext.size) {\n\t\tWARN_ON(args->in_numargs >= ARRAY_SIZE(args->in_args));\n\t\targs->is_ext = true;\n\t\targs->ext_idx = args->in_numargs++;\n\t\targs->in_args[args->ext_idx] = ext;\n\t} else {\n\t\tkfree(ext.value);\n\t}\n\n\treturn err;\n}\n\nstatic void free_ext_value(struct fuse_args *args)\n{\n\tif (args->is_ext)\n\t\tkfree(args->in_args[args->ext_idx].value);\n}\n\n \nstatic int fuse_create_open(struct inode *dir, struct dentry *entry,\n\t\t\t    struct file *file, unsigned int flags,\n\t\t\t    umode_t mode, u32 opcode)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct fuse_mount *fm = get_fuse_mount(dir);\n\tFUSE_ARGS(args);\n\tstruct fuse_forget_link *forget;\n\tstruct fuse_create_in inarg;\n\tstruct fuse_open_out outopen;\n\tstruct fuse_entry_out outentry;\n\tstruct fuse_inode *fi;\n\tstruct fuse_file *ff;\n\tbool trunc = flags & O_TRUNC;\n\n\t \n\tBUG_ON((mode & S_IFMT) != S_IFREG);\n\n\tforget = fuse_alloc_forget();\n\terr = -ENOMEM;\n\tif (!forget)\n\t\tgoto out_err;\n\n\terr = -ENOMEM;\n\tff = fuse_file_alloc(fm);\n\tif (!ff)\n\t\tgoto out_put_forget_req;\n\n\tif (!fm->fc->dont_mask)\n\t\tmode &= ~current_umask();\n\n\tflags &= ~O_NOCTTY;\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outentry, 0, sizeof(outentry));\n\tinarg.flags = flags;\n\tinarg.mode = mode;\n\tinarg.umask = current_umask();\n\n\tif (fm->fc->handle_killpriv_v2 && trunc &&\n\t    !(flags & O_EXCL) && !capable(CAP_FSETID)) {\n\t\tinarg.open_flags |= FUSE_OPEN_KILL_SUIDGID;\n\t}\n\n\targs.opcode = opcode;\n\targs.nodeid = get_node_id(dir);\n\targs.in_numargs = 2;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.in_args[1].size = entry->d_name.len + 1;\n\targs.in_args[1].value = entry->d_name.name;\n\targs.out_numargs = 2;\n\targs.out_args[0].size = sizeof(outentry);\n\targs.out_args[0].value = &outentry;\n\targs.out_args[1].size = sizeof(outopen);\n\targs.out_args[1].value = &outopen;\n\n\terr = get_create_ext(&args, dir, entry, mode);\n\tif (err)\n\t\tgoto out_put_forget_req;\n\n\terr = fuse_simple_request(fm, &args);\n\tfree_ext_value(&args);\n\tif (err)\n\t\tgoto out_free_ff;\n\n\terr = -EIO;\n\tif (!S_ISREG(outentry.attr.mode) || invalid_nodeid(outentry.nodeid) ||\n\t    fuse_invalid_attr(&outentry.attr))\n\t\tgoto out_free_ff;\n\n\tff->fh = outopen.fh;\n\tff->nodeid = outentry.nodeid;\n\tff->open_flags = outopen.open_flags;\n\tinode = fuse_iget(dir->i_sb, outentry.nodeid, outentry.generation,\n\t\t\t  &outentry.attr, ATTR_TIMEOUT(&outentry), 0);\n\tif (!inode) {\n\t\tflags &= ~(O_CREAT | O_EXCL | O_TRUNC);\n\t\tfuse_sync_release(NULL, ff, flags);\n\t\tfuse_queue_forget(fm->fc, forget, outentry.nodeid, 1);\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tkfree(forget);\n\td_instantiate(entry, inode);\n\tfuse_change_entry_timeout(entry, &outentry);\n\tfuse_dir_changed(dir);\n\terr = finish_open(file, entry, generic_file_open);\n\tif (err) {\n\t\tfi = get_fuse_inode(inode);\n\t\tfuse_sync_release(fi, ff, flags);\n\t} else {\n\t\tfile->private_data = ff;\n\t\tfuse_finish_open(inode, file);\n\t\tif (fm->fc->atomic_o_trunc && trunc)\n\t\t\ttruncate_pagecache(inode, 0);\n\t\telse if (!(ff->open_flags & FOPEN_KEEP_CACHE))\n\t\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n\treturn err;\n\nout_free_ff:\n\tfuse_file_free(ff);\nout_put_forget_req:\n\tkfree(forget);\nout_err:\n\treturn err;\n}\n\nstatic int fuse_mknod(struct mnt_idmap *, struct inode *, struct dentry *,\n\t\t      umode_t, dev_t);\nstatic int fuse_atomic_open(struct inode *dir, struct dentry *entry,\n\t\t\t    struct file *file, unsigned flags,\n\t\t\t    umode_t mode)\n{\n\tint err;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tstruct dentry *res = NULL;\n\n\tif (fuse_is_bad(dir))\n\t\treturn -EIO;\n\n\tif (d_in_lookup(entry)) {\n\t\tres = fuse_lookup(dir, entry, 0);\n\t\tif (IS_ERR(res))\n\t\t\treturn PTR_ERR(res);\n\n\t\tif (res)\n\t\t\tentry = res;\n\t}\n\n\tif (!(flags & O_CREAT) || d_really_is_positive(entry))\n\t\tgoto no_open;\n\n\t \n\tfile->f_mode |= FMODE_CREATED;\n\n\tif (fc->no_create)\n\t\tgoto mknod;\n\n\terr = fuse_create_open(dir, entry, file, flags, mode, FUSE_CREATE);\n\tif (err == -ENOSYS) {\n\t\tfc->no_create = 1;\n\t\tgoto mknod;\n\t} else if (err == -EEXIST)\n\t\tfuse_invalidate_entry(entry);\nout_dput:\n\tdput(res);\n\treturn err;\n\nmknod:\n\terr = fuse_mknod(&nop_mnt_idmap, dir, entry, mode, 0);\n\tif (err)\n\t\tgoto out_dput;\nno_open:\n\treturn finish_no_open(file, res);\n}\n\n \nstatic int create_new_entry(struct fuse_mount *fm, struct fuse_args *args,\n\t\t\t    struct inode *dir, struct dentry *entry,\n\t\t\t    umode_t mode)\n{\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tstruct dentry *d;\n\tint err;\n\tstruct fuse_forget_link *forget;\n\n\tif (fuse_is_bad(dir))\n\t\treturn -EIO;\n\n\tforget = fuse_alloc_forget();\n\tif (!forget)\n\t\treturn -ENOMEM;\n\n\tmemset(&outarg, 0, sizeof(outarg));\n\targs->nodeid = get_node_id(dir);\n\targs->out_numargs = 1;\n\targs->out_args[0].size = sizeof(outarg);\n\targs->out_args[0].value = &outarg;\n\n\tif (args->opcode != FUSE_LINK) {\n\t\terr = get_create_ext(args, dir, entry, mode);\n\t\tif (err)\n\t\t\tgoto out_put_forget_req;\n\t}\n\n\terr = fuse_simple_request(fm, args);\n\tfree_ext_value(args);\n\tif (err)\n\t\tgoto out_put_forget_req;\n\n\terr = -EIO;\n\tif (invalid_nodeid(outarg.nodeid) || fuse_invalid_attr(&outarg.attr))\n\t\tgoto out_put_forget_req;\n\n\tif ((outarg.attr.mode ^ mode) & S_IFMT)\n\t\tgoto out_put_forget_req;\n\n\tinode = fuse_iget(dir->i_sb, outarg.nodeid, outarg.generation,\n\t\t\t  &outarg.attr, ATTR_TIMEOUT(&outarg), 0);\n\tif (!inode) {\n\t\tfuse_queue_forget(fm->fc, forget, outarg.nodeid, 1);\n\t\treturn -ENOMEM;\n\t}\n\tkfree(forget);\n\n\td_drop(entry);\n\td = d_splice_alias(inode, entry);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\n\tif (d) {\n\t\tfuse_change_entry_timeout(d, &outarg);\n\t\tdput(d);\n\t} else {\n\t\tfuse_change_entry_timeout(entry, &outarg);\n\t}\n\tfuse_dir_changed(dir);\n\treturn 0;\n\n out_put_forget_req:\n\tif (err == -EEXIST)\n\t\tfuse_invalidate_entry(entry);\n\tkfree(forget);\n\treturn err;\n}\n\nstatic int fuse_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *entry, umode_t mode, dev_t rdev)\n{\n\tstruct fuse_mknod_in inarg;\n\tstruct fuse_mount *fm = get_fuse_mount(dir);\n\tFUSE_ARGS(args);\n\n\tif (!fm->fc->dont_mask)\n\t\tmode &= ~current_umask();\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.mode = mode;\n\tinarg.rdev = new_encode_dev(rdev);\n\tinarg.umask = current_umask();\n\targs.opcode = FUSE_MKNOD;\n\targs.in_numargs = 2;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.in_args[1].size = entry->d_name.len + 1;\n\targs.in_args[1].value = entry->d_name.name;\n\treturn create_new_entry(fm, &args, dir, entry, mode);\n}\n\nstatic int fuse_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *entry, umode_t mode, bool excl)\n{\n\treturn fuse_mknod(&nop_mnt_idmap, dir, entry, mode, 0);\n}\n\nstatic int fuse_tmpfile(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct file *file, umode_t mode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tint err;\n\n\tif (fc->no_tmpfile)\n\t\treturn -EOPNOTSUPP;\n\n\terr = fuse_create_open(dir, file->f_path.dentry, file, file->f_flags, mode, FUSE_TMPFILE);\n\tif (err == -ENOSYS) {\n\t\tfc->no_tmpfile = 1;\n\t\terr = -EOPNOTSUPP;\n\t}\n\treturn err;\n}\n\nstatic int fuse_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *entry, umode_t mode)\n{\n\tstruct fuse_mkdir_in inarg;\n\tstruct fuse_mount *fm = get_fuse_mount(dir);\n\tFUSE_ARGS(args);\n\n\tif (!fm->fc->dont_mask)\n\t\tmode &= ~current_umask();\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.mode = mode;\n\tinarg.umask = current_umask();\n\targs.opcode = FUSE_MKDIR;\n\targs.in_numargs = 2;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.in_args[1].size = entry->d_name.len + 1;\n\targs.in_args[1].value = entry->d_name.name;\n\treturn create_new_entry(fm, &args, dir, entry, S_IFDIR);\n}\n\nstatic int fuse_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct dentry *entry, const char *link)\n{\n\tstruct fuse_mount *fm = get_fuse_mount(dir);\n\tunsigned len = strlen(link) + 1;\n\tFUSE_ARGS(args);\n\n\targs.opcode = FUSE_SYMLINK;\n\targs.in_numargs = 2;\n\targs.in_args[0].size = entry->d_name.len + 1;\n\targs.in_args[0].value = entry->d_name.name;\n\targs.in_args[1].size = len;\n\targs.in_args[1].value = link;\n\treturn create_new_entry(fm, &args, dir, entry, S_IFLNK);\n}\n\nvoid fuse_flush_time_update(struct inode *inode)\n{\n\tint err = sync_inode_metadata(inode, 1);\n\n\tmapping_set_error(inode->i_mapping, err);\n}\n\nstatic void fuse_update_ctime_in_cache(struct inode *inode)\n{\n\tif (!IS_NOCMTIME(inode)) {\n\t\tinode_set_ctime_current(inode);\n\t\tmark_inode_dirty_sync(inode);\n\t\tfuse_flush_time_update(inode);\n\t}\n}\n\nvoid fuse_update_ctime(struct inode *inode)\n{\n\tfuse_invalidate_attr_mask(inode, STATX_CTIME);\n\tfuse_update_ctime_in_cache(inode);\n}\n\nstatic void fuse_entry_unlinked(struct dentry *entry)\n{\n\tstruct inode *inode = d_inode(entry);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tspin_lock(&fi->lock);\n\tfi->attr_version = atomic64_inc_return(&fc->attr_version);\n\t \n\tif (S_ISDIR(inode->i_mode))\n\t\tclear_nlink(inode);\n\telse if (inode->i_nlink > 0)\n\t\tdrop_nlink(inode);\n\tspin_unlock(&fi->lock);\n\tfuse_invalidate_entry_cache(entry);\n\tfuse_update_ctime(inode);\n}\n\nstatic int fuse_unlink(struct inode *dir, struct dentry *entry)\n{\n\tint err;\n\tstruct fuse_mount *fm = get_fuse_mount(dir);\n\tFUSE_ARGS(args);\n\n\tif (fuse_is_bad(dir))\n\t\treturn -EIO;\n\n\targs.opcode = FUSE_UNLINK;\n\targs.nodeid = get_node_id(dir);\n\targs.in_numargs = 1;\n\targs.in_args[0].size = entry->d_name.len + 1;\n\targs.in_args[0].value = entry->d_name.name;\n\terr = fuse_simple_request(fm, &args);\n\tif (!err) {\n\t\tfuse_dir_changed(dir);\n\t\tfuse_entry_unlinked(entry);\n\t} else if (err == -EINTR || err == -ENOENT)\n\t\tfuse_invalidate_entry(entry);\n\treturn err;\n}\n\nstatic int fuse_rmdir(struct inode *dir, struct dentry *entry)\n{\n\tint err;\n\tstruct fuse_mount *fm = get_fuse_mount(dir);\n\tFUSE_ARGS(args);\n\n\tif (fuse_is_bad(dir))\n\t\treturn -EIO;\n\n\targs.opcode = FUSE_RMDIR;\n\targs.nodeid = get_node_id(dir);\n\targs.in_numargs = 1;\n\targs.in_args[0].size = entry->d_name.len + 1;\n\targs.in_args[0].value = entry->d_name.name;\n\terr = fuse_simple_request(fm, &args);\n\tif (!err) {\n\t\tfuse_dir_changed(dir);\n\t\tfuse_entry_unlinked(entry);\n\t} else if (err == -EINTR || err == -ENOENT)\n\t\tfuse_invalidate_entry(entry);\n\treturn err;\n}\n\nstatic int fuse_rename_common(struct inode *olddir, struct dentry *oldent,\n\t\t\t      struct inode *newdir, struct dentry *newent,\n\t\t\t      unsigned int flags, int opcode, size_t argsize)\n{\n\tint err;\n\tstruct fuse_rename2_in inarg;\n\tstruct fuse_mount *fm = get_fuse_mount(olddir);\n\tFUSE_ARGS(args);\n\n\tmemset(&inarg, 0, argsize);\n\tinarg.newdir = get_node_id(newdir);\n\tinarg.flags = flags;\n\targs.opcode = opcode;\n\targs.nodeid = get_node_id(olddir);\n\targs.in_numargs = 3;\n\targs.in_args[0].size = argsize;\n\targs.in_args[0].value = &inarg;\n\targs.in_args[1].size = oldent->d_name.len + 1;\n\targs.in_args[1].value = oldent->d_name.name;\n\targs.in_args[2].size = newent->d_name.len + 1;\n\targs.in_args[2].value = newent->d_name.name;\n\terr = fuse_simple_request(fm, &args);\n\tif (!err) {\n\t\t \n\t\tfuse_update_ctime(d_inode(oldent));\n\n\t\tif (flags & RENAME_EXCHANGE)\n\t\t\tfuse_update_ctime(d_inode(newent));\n\n\t\tfuse_dir_changed(olddir);\n\t\tif (olddir != newdir)\n\t\t\tfuse_dir_changed(newdir);\n\n\t\t \n\t\tif (!(flags & RENAME_EXCHANGE) && d_really_is_positive(newent))\n\t\t\tfuse_entry_unlinked(newent);\n\t} else if (err == -EINTR || err == -ENOENT) {\n\t\t \n\t\tfuse_invalidate_entry(oldent);\n\t\tif (d_really_is_positive(newent))\n\t\t\tfuse_invalidate_entry(newent);\n\t}\n\n\treturn err;\n}\n\nstatic int fuse_rename2(struct mnt_idmap *idmap, struct inode *olddir,\n\t\t\tstruct dentry *oldent, struct inode *newdir,\n\t\t\tstruct dentry *newent, unsigned int flags)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(olddir);\n\tint err;\n\n\tif (fuse_is_bad(olddir))\n\t\treturn -EIO;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\treturn -EINVAL;\n\n\tif (flags) {\n\t\tif (fc->no_rename2 || fc->minor < 23)\n\t\t\treturn -EINVAL;\n\n\t\terr = fuse_rename_common(olddir, oldent, newdir, newent, flags,\n\t\t\t\t\t FUSE_RENAME2,\n\t\t\t\t\t sizeof(struct fuse_rename2_in));\n\t\tif (err == -ENOSYS) {\n\t\t\tfc->no_rename2 = 1;\n\t\t\terr = -EINVAL;\n\t\t}\n\t} else {\n\t\terr = fuse_rename_common(olddir, oldent, newdir, newent, 0,\n\t\t\t\t\t FUSE_RENAME,\n\t\t\t\t\t sizeof(struct fuse_rename_in));\n\t}\n\n\treturn err;\n}\n\nstatic int fuse_link(struct dentry *entry, struct inode *newdir,\n\t\t     struct dentry *newent)\n{\n\tint err;\n\tstruct fuse_link_in inarg;\n\tstruct inode *inode = d_inode(entry);\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tFUSE_ARGS(args);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.oldnodeid = get_node_id(inode);\n\targs.opcode = FUSE_LINK;\n\targs.in_numargs = 2;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.in_args[1].size = newent->d_name.len + 1;\n\targs.in_args[1].value = newent->d_name.name;\n\terr = create_new_entry(fm, &args, newdir, newent, inode->i_mode);\n\tif (!err)\n\t\tfuse_update_ctime_in_cache(inode);\n\telse if (err == -EINTR)\n\t\tfuse_invalidate_attr(inode);\n\n\treturn err;\n}\n\nstatic void fuse_fillattr(struct inode *inode, struct fuse_attr *attr,\n\t\t\t  struct kstat *stat)\n{\n\tunsigned int blkbits;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = attr->ino;\n\tstat->mode = (inode->i_mode & S_IFMT) | (attr->mode & 07777);\n\tstat->nlink = attr->nlink;\n\tstat->uid = make_kuid(fc->user_ns, attr->uid);\n\tstat->gid = make_kgid(fc->user_ns, attr->gid);\n\tstat->rdev = inode->i_rdev;\n\tstat->atime.tv_sec = attr->atime;\n\tstat->atime.tv_nsec = attr->atimensec;\n\tstat->mtime.tv_sec = attr->mtime;\n\tstat->mtime.tv_nsec = attr->mtimensec;\n\tstat->ctime.tv_sec = attr->ctime;\n\tstat->ctime.tv_nsec = attr->ctimensec;\n\tstat->size = attr->size;\n\tstat->blocks = attr->blocks;\n\n\tif (attr->blksize != 0)\n\t\tblkbits = ilog2(attr->blksize);\n\telse\n\t\tblkbits = inode->i_sb->s_blocksize_bits;\n\n\tstat->blksize = 1 << blkbits;\n}\n\nstatic void fuse_statx_to_attr(struct fuse_statx *sx, struct fuse_attr *attr)\n{\n\tmemset(attr, 0, sizeof(*attr));\n\tattr->ino = sx->ino;\n\tattr->size = sx->size;\n\tattr->blocks = sx->blocks;\n\tattr->atime = sx->atime.tv_sec;\n\tattr->mtime = sx->mtime.tv_sec;\n\tattr->ctime = sx->ctime.tv_sec;\n\tattr->atimensec = sx->atime.tv_nsec;\n\tattr->mtimensec = sx->mtime.tv_nsec;\n\tattr->ctimensec = sx->ctime.tv_nsec;\n\tattr->mode = sx->mode;\n\tattr->nlink = sx->nlink;\n\tattr->uid = sx->uid;\n\tattr->gid = sx->gid;\n\tattr->rdev = new_encode_dev(MKDEV(sx->rdev_major, sx->rdev_minor));\n\tattr->blksize = sx->blksize;\n}\n\nstatic int fuse_do_statx(struct inode *inode, struct file *file,\n\t\t\t struct kstat *stat)\n{\n\tint err;\n\tstruct fuse_attr attr;\n\tstruct fuse_statx *sx;\n\tstruct fuse_statx_in inarg;\n\tstruct fuse_statx_out outarg;\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tu64 attr_version = fuse_get_attr_version(fm->fc);\n\tFUSE_ARGS(args);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\t \n\tif (file && S_ISREG(inode->i_mode)) {\n\t\tstruct fuse_file *ff = file->private_data;\n\n\t\tinarg.getattr_flags |= FUSE_GETATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\t \n\tinarg.sx_flags = 0;\n\tinarg.sx_mask = STATX_BASIC_STATS | STATX_BTIME;\n\targs.opcode = FUSE_STATX;\n\targs.nodeid = get_node_id(inode);\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.out_numargs = 1;\n\targs.out_args[0].size = sizeof(outarg);\n\targs.out_args[0].value = &outarg;\n\terr = fuse_simple_request(fm, &args);\n\tif (err)\n\t\treturn err;\n\n\tsx = &outarg.stat;\n\tif (((sx->mask & STATX_SIZE) && !fuse_valid_size(sx->size)) ||\n\t    ((sx->mask & STATX_TYPE) && (!fuse_valid_type(sx->mode) ||\n\t\t\t\t\t inode_wrong_type(inode, sx->mode)))) {\n\t\tmake_bad_inode(inode);\n\t\treturn -EIO;\n\t}\n\n\tfuse_statx_to_attr(&outarg.stat, &attr);\n\tif ((sx->mask & STATX_BASIC_STATS) == STATX_BASIC_STATS) {\n\t\tfuse_change_attributes(inode, &attr, &outarg.stat,\n\t\t\t\t       ATTR_TIMEOUT(&outarg), attr_version);\n\t}\n\n\tif (stat) {\n\t\tstat->result_mask = sx->mask & (STATX_BASIC_STATS | STATX_BTIME);\n\t\tstat->btime.tv_sec = sx->btime.tv_sec;\n\t\tstat->btime.tv_nsec = min_t(u32, sx->btime.tv_nsec, NSEC_PER_SEC - 1);\n\t\tfuse_fillattr(inode, &attr, stat);\n\t\tstat->result_mask |= STATX_TYPE;\n\t}\n\n\treturn 0;\n}\n\nstatic int fuse_do_getattr(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file)\n{\n\tint err;\n\tstruct fuse_getattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tFUSE_ARGS(args);\n\tu64 attr_version;\n\n\tattr_version = fuse_get_attr_version(fm->fc);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\t \n\tif (file && S_ISREG(inode->i_mode)) {\n\t\tstruct fuse_file *ff = file->private_data;\n\n\t\tinarg.getattr_flags |= FUSE_GETATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\targs.opcode = FUSE_GETATTR;\n\targs.nodeid = get_node_id(inode);\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.out_numargs = 1;\n\targs.out_args[0].size = sizeof(outarg);\n\targs.out_args[0].value = &outarg;\n\terr = fuse_simple_request(fm, &args);\n\tif (!err) {\n\t\tif (fuse_invalid_attr(&outarg.attr) ||\n\t\t    inode_wrong_type(inode, outarg.attr.mode)) {\n\t\t\tfuse_make_bad(inode);\n\t\t\terr = -EIO;\n\t\t} else {\n\t\t\tfuse_change_attributes(inode, &outarg.attr, NULL,\n\t\t\t\t\t       ATTR_TIMEOUT(&outarg),\n\t\t\t\t\t       attr_version);\n\t\t\tif (stat)\n\t\t\t\tfuse_fillattr(inode, &outarg.attr, stat);\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int fuse_update_get_attr(struct inode *inode, struct file *file,\n\t\t\t\tstruct kstat *stat, u32 request_mask,\n\t\t\t\tunsigned int flags)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err = 0;\n\tbool sync;\n\tu32 inval_mask = READ_ONCE(fi->inval_mask);\n\tu32 cache_mask = fuse_get_cache_mask(inode);\n\n\n\t \n\trequest_mask &= STATX_BASIC_STATS | STATX_BTIME;\nretry:\n\tif (fc->no_statx)\n\t\trequest_mask &= STATX_BASIC_STATS;\n\n\tif (!request_mask)\n\t\tsync = false;\n\telse if (flags & AT_STATX_FORCE_SYNC)\n\t\tsync = true;\n\telse if (flags & AT_STATX_DONT_SYNC)\n\t\tsync = false;\n\telse if (request_mask & inval_mask & ~cache_mask)\n\t\tsync = true;\n\telse\n\t\tsync = time_before64(fi->i_time, get_jiffies_64());\n\n\tif (sync) {\n\t\tforget_all_cached_acls(inode);\n\t\t \n\t\tif (!fc->no_statx && (request_mask & ~STATX_BASIC_STATS)) {\n\t\t\terr = fuse_do_statx(inode, file, stat);\n\t\t\tif (err == -ENOSYS) {\n\t\t\t\tfc->no_statx = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t} else {\n\t\t\terr = fuse_do_getattr(inode, stat, file);\n\t\t}\n\t} else if (stat) {\n\t\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\t\tstat->mode = fi->orig_i_mode;\n\t\tstat->ino = fi->orig_ino;\n\t\tif (test_bit(FUSE_I_BTIME, &fi->state)) {\n\t\t\tstat->btime = fi->i_btime;\n\t\t\tstat->result_mask |= STATX_BTIME;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint fuse_update_attributes(struct inode *inode, struct file *file, u32 mask)\n{\n\treturn fuse_update_get_attr(inode, file, NULL, mask, 0);\n}\n\nint fuse_reverse_inval_entry(struct fuse_conn *fc, u64 parent_nodeid,\n\t\t\t     u64 child_nodeid, struct qstr *name, u32 flags)\n{\n\tint err = -ENOTDIR;\n\tstruct inode *parent;\n\tstruct dentry *dir;\n\tstruct dentry *entry;\n\n\tparent = fuse_ilookup(fc, parent_nodeid, NULL);\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\tinode_lock_nested(parent, I_MUTEX_PARENT);\n\tif (!S_ISDIR(parent->i_mode))\n\t\tgoto unlock;\n\n\terr = -ENOENT;\n\tdir = d_find_alias(parent);\n\tif (!dir)\n\t\tgoto unlock;\n\n\tname->hash = full_name_hash(dir, name->name, name->len);\n\tentry = d_lookup(dir, name);\n\tdput(dir);\n\tif (!entry)\n\t\tgoto unlock;\n\n\tfuse_dir_changed(parent);\n\tif (!(flags & FUSE_EXPIRE_ONLY))\n\t\td_invalidate(entry);\n\tfuse_invalidate_entry_cache(entry);\n\n\tif (child_nodeid != 0 && d_really_is_positive(entry)) {\n\t\tinode_lock(d_inode(entry));\n\t\tif (get_node_id(d_inode(entry)) != child_nodeid) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto badentry;\n\t\t}\n\t\tif (d_mountpoint(entry)) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto badentry;\n\t\t}\n\t\tif (d_is_dir(entry)) {\n\t\t\tshrink_dcache_parent(entry);\n\t\t\tif (!simple_empty(entry)) {\n\t\t\t\terr = -ENOTEMPTY;\n\t\t\t\tgoto badentry;\n\t\t\t}\n\t\t\td_inode(entry)->i_flags |= S_DEAD;\n\t\t}\n\t\tdont_mount(entry);\n\t\tclear_nlink(d_inode(entry));\n\t\terr = 0;\n badentry:\n\t\tinode_unlock(d_inode(entry));\n\t\tif (!err)\n\t\t\td_delete(entry);\n\t} else {\n\t\terr = 0;\n\t}\n\tdput(entry);\n\n unlock:\n\tinode_unlock(parent);\n\tiput(parent);\n\treturn err;\n}\n\nstatic inline bool fuse_permissible_uidgid(struct fuse_conn *fc)\n{\n\tconst struct cred *cred = current_cred();\n\n\treturn (uid_eq(cred->euid, fc->user_id) &&\n\t\tuid_eq(cred->suid, fc->user_id) &&\n\t\tuid_eq(cred->uid,  fc->user_id) &&\n\t\tgid_eq(cred->egid, fc->group_id) &&\n\t\tgid_eq(cred->sgid, fc->group_id) &&\n\t\tgid_eq(cred->gid,  fc->group_id));\n}\n\n \nbool fuse_allow_current_process(struct fuse_conn *fc)\n{\n\tbool allow;\n\n\tif (fc->allow_other)\n\t\tallow = current_in_userns(fc->user_ns);\n\telse\n\t\tallow = fuse_permissible_uidgid(fc);\n\n\tif (!allow && allow_sys_admin_access && capable(CAP_SYS_ADMIN))\n\t\tallow = true;\n\n\treturn allow;\n}\n\nstatic int fuse_access(struct inode *inode, int mask)\n{\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_access_in inarg;\n\tint err;\n\n\tBUG_ON(mask & MAY_NOT_BLOCK);\n\n\tif (fm->fc->no_access)\n\t\treturn 0;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.mask = mask & (MAY_READ | MAY_WRITE | MAY_EXEC);\n\targs.opcode = FUSE_ACCESS;\n\targs.nodeid = get_node_id(inode);\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\terr = fuse_simple_request(fm, &args);\n\tif (err == -ENOSYS) {\n\t\tfm->fc->no_access = 1;\n\t\terr = 0;\n\t}\n\treturn err;\n}\n\nstatic int fuse_perm_getattr(struct inode *inode, int mask)\n{\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\tforget_all_cached_acls(inode);\n\treturn fuse_do_getattr(inode, NULL, NULL);\n}\n\n \nstatic int fuse_permission(struct mnt_idmap *idmap,\n\t\t\t   struct inode *inode, int mask)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tbool refreshed = false;\n\tint err = 0;\n\n\tif (fuse_is_bad(inode))\n\t\treturn -EIO;\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\t \n\tif (fc->default_permissions ||\n\t    ((mask & MAY_EXEC) && S_ISREG(inode->i_mode))) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\t\tu32 perm_mask = STATX_MODE | STATX_UID | STATX_GID;\n\n\t\tif (perm_mask & READ_ONCE(fi->inval_mask) ||\n\t\t    time_before64(fi->i_time, get_jiffies_64())) {\n\t\t\trefreshed = true;\n\n\t\t\terr = fuse_perm_getattr(inode, mask);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (fc->default_permissions) {\n\t\terr = generic_permission(&nop_mnt_idmap, inode, mask);\n\n\t\t \n\t\tif (err == -EACCES && !refreshed) {\n\t\t\terr = fuse_perm_getattr(inode, mask);\n\t\t\tif (!err)\n\t\t\t\terr = generic_permission(&nop_mnt_idmap,\n\t\t\t\t\t\t\t inode, mask);\n\t\t}\n\n\t\t \n\t} else if (mask & (MAY_ACCESS | MAY_CHDIR)) {\n\t\terr = fuse_access(inode, mask);\n\t} else if ((mask & MAY_EXEC) && S_ISREG(inode->i_mode)) {\n\t\tif (!(inode->i_mode & S_IXUGO)) {\n\t\t\tif (refreshed)\n\t\t\t\treturn -EACCES;\n\n\t\t\terr = fuse_perm_getattr(inode, mask);\n\t\t\tif (!err && !(inode->i_mode & S_IXUGO))\n\t\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int fuse_readlink_page(struct inode *inode, struct page *page)\n{\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tstruct fuse_page_desc desc = { .length = PAGE_SIZE - 1 };\n\tstruct fuse_args_pages ap = {\n\t\t.num_pages = 1,\n\t\t.pages = &page,\n\t\t.descs = &desc,\n\t};\n\tchar *link;\n\tssize_t res;\n\n\tap.args.opcode = FUSE_READLINK;\n\tap.args.nodeid = get_node_id(inode);\n\tap.args.out_pages = true;\n\tap.args.out_argvar = true;\n\tap.args.page_zeroing = true;\n\tap.args.out_numargs = 1;\n\tap.args.out_args[0].size = desc.length;\n\tres = fuse_simple_request(fm, &ap.args);\n\n\tfuse_invalidate_atime(inode);\n\n\tif (res < 0)\n\t\treturn res;\n\n\tif (WARN_ON(res >= PAGE_SIZE))\n\t\treturn -EIO;\n\n\tlink = page_address(page);\n\tlink[res] = '\\0';\n\n\treturn 0;\n}\n\nstatic const char *fuse_get_link(struct dentry *dentry, struct inode *inode,\n\t\t\t\t struct delayed_call *callback)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct page *page;\n\tint err;\n\n\terr = -EIO;\n\tif (fuse_is_bad(inode))\n\t\tgoto out_err;\n\n\tif (fc->cache_symlinks)\n\t\treturn page_get_link(dentry, inode, callback);\n\n\terr = -ECHILD;\n\tif (!dentry)\n\t\tgoto out_err;\n\n\tpage = alloc_page(GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out_err;\n\n\terr = fuse_readlink_page(inode, page);\n\tif (err) {\n\t\t__free_page(page);\n\t\tgoto out_err;\n\t}\n\n\tset_delayed_call(callback, page_put_link, page);\n\n\treturn page_address(page);\n\nout_err:\n\treturn ERR_PTR(err);\n}\n\nstatic int fuse_dir_open(struct inode *inode, struct file *file)\n{\n\treturn fuse_open_common(inode, file, true);\n}\n\nstatic int fuse_dir_release(struct inode *inode, struct file *file)\n{\n\tfuse_release_common(file, true);\n\n\treturn 0;\n}\n\nstatic int fuse_dir_fsync(struct file *file, loff_t start, loff_t end,\n\t\t\t  int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\n\tif (fuse_is_bad(inode))\n\t\treturn -EIO;\n\n\tif (fc->no_fsyncdir)\n\t\treturn 0;\n\n\tinode_lock(inode);\n\terr = fuse_fsync_common(file, start, end, datasync, FUSE_FSYNCDIR);\n\tif (err == -ENOSYS) {\n\t\tfc->no_fsyncdir = 1;\n\t\terr = 0;\n\t}\n\tinode_unlock(inode);\n\n\treturn err;\n}\n\nstatic long fuse_dir_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(file->f_mapping->host);\n\n\t \n\tif (fc->minor < 18)\n\t\treturn -ENOTTY;\n\n\treturn fuse_ioctl_common(file, cmd, arg, FUSE_IOCTL_DIR);\n}\n\nstatic long fuse_dir_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(file->f_mapping->host);\n\n\tif (fc->minor < 18)\n\t\treturn -ENOTTY;\n\n\treturn fuse_ioctl_common(file, cmd, arg,\n\t\t\t\t FUSE_IOCTL_COMPAT | FUSE_IOCTL_DIR);\n}\n\nstatic bool update_mtime(unsigned ivalid, bool trust_local_mtime)\n{\n\t \n\tif (ivalid & ATTR_MTIME_SET)\n\t\treturn true;\n\n\t \n\tif (trust_local_mtime)\n\t\treturn true;\n\n\t \n\tif ((ivalid & ATTR_SIZE) && (ivalid & (ATTR_OPEN | ATTR_FILE)))\n\t\treturn false;\n\n\t \n\treturn true;\n}\n\nstatic void iattr_to_fattr(struct fuse_conn *fc, struct iattr *iattr,\n\t\t\t   struct fuse_setattr_in *arg, bool trust_local_cmtime)\n{\n\tunsigned ivalid = iattr->ia_valid;\n\n\tif (ivalid & ATTR_MODE)\n\t\targ->valid |= FATTR_MODE,   arg->mode = iattr->ia_mode;\n\tif (ivalid & ATTR_UID)\n\t\targ->valid |= FATTR_UID,    arg->uid = from_kuid(fc->user_ns, iattr->ia_uid);\n\tif (ivalid & ATTR_GID)\n\t\targ->valid |= FATTR_GID,    arg->gid = from_kgid(fc->user_ns, iattr->ia_gid);\n\tif (ivalid & ATTR_SIZE)\n\t\targ->valid |= FATTR_SIZE,   arg->size = iattr->ia_size;\n\tif (ivalid & ATTR_ATIME) {\n\t\targ->valid |= FATTR_ATIME;\n\t\targ->atime = iattr->ia_atime.tv_sec;\n\t\targ->atimensec = iattr->ia_atime.tv_nsec;\n\t\tif (!(ivalid & ATTR_ATIME_SET))\n\t\t\targ->valid |= FATTR_ATIME_NOW;\n\t}\n\tif ((ivalid & ATTR_MTIME) && update_mtime(ivalid, trust_local_cmtime)) {\n\t\targ->valid |= FATTR_MTIME;\n\t\targ->mtime = iattr->ia_mtime.tv_sec;\n\t\targ->mtimensec = iattr->ia_mtime.tv_nsec;\n\t\tif (!(ivalid & ATTR_MTIME_SET) && !trust_local_cmtime)\n\t\t\targ->valid |= FATTR_MTIME_NOW;\n\t}\n\tif ((ivalid & ATTR_CTIME) && trust_local_cmtime) {\n\t\targ->valid |= FATTR_CTIME;\n\t\targ->ctime = iattr->ia_ctime.tv_sec;\n\t\targ->ctimensec = iattr->ia_ctime.tv_nsec;\n\t}\n}\n\n \nvoid fuse_set_nowrite(struct inode *inode)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tBUG_ON(!inode_is_locked(inode));\n\n\tspin_lock(&fi->lock);\n\tBUG_ON(fi->writectr < 0);\n\tfi->writectr += FUSE_NOWRITE;\n\tspin_unlock(&fi->lock);\n\twait_event(fi->page_waitq, fi->writectr == FUSE_NOWRITE);\n}\n\n \nstatic void __fuse_release_nowrite(struct inode *inode)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tBUG_ON(fi->writectr != FUSE_NOWRITE);\n\tfi->writectr = 0;\n\tfuse_flush_writepages(inode);\n}\n\nvoid fuse_release_nowrite(struct inode *inode)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tspin_lock(&fi->lock);\n\t__fuse_release_nowrite(inode);\n\tspin_unlock(&fi->lock);\n}\n\nstatic void fuse_setattr_fill(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t      struct inode *inode,\n\t\t\t      struct fuse_setattr_in *inarg_p,\n\t\t\t      struct fuse_attr_out *outarg_p)\n{\n\targs->opcode = FUSE_SETATTR;\n\targs->nodeid = get_node_id(inode);\n\targs->in_numargs = 1;\n\targs->in_args[0].size = sizeof(*inarg_p);\n\targs->in_args[0].value = inarg_p;\n\targs->out_numargs = 1;\n\targs->out_args[0].size = sizeof(*outarg_p);\n\targs->out_args[0].value = outarg_p;\n}\n\n \nint fuse_flush_times(struct inode *inode, struct fuse_file *ff)\n{\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_setattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\n\tinarg.valid = FATTR_MTIME;\n\tinarg.mtime = inode->i_mtime.tv_sec;\n\tinarg.mtimensec = inode->i_mtime.tv_nsec;\n\tif (fm->fc->minor >= 23) {\n\t\tinarg.valid |= FATTR_CTIME;\n\t\tinarg.ctime = inode_get_ctime(inode).tv_sec;\n\t\tinarg.ctimensec = inode_get_ctime(inode).tv_nsec;\n\t}\n\tif (ff) {\n\t\tinarg.valid |= FATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\tfuse_setattr_fill(fm->fc, &args, inode, &inarg, &outarg);\n\n\treturn fuse_simple_request(fm, &args);\n}\n\n \nint fuse_do_setattr(struct dentry *dentry, struct iattr *attr,\n\t\t    struct file *file)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tstruct fuse_conn *fc = fm->fc;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct address_space *mapping = inode->i_mapping;\n\tFUSE_ARGS(args);\n\tstruct fuse_setattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tbool is_truncate = false;\n\tbool is_wb = fc->writeback_cache && S_ISREG(inode->i_mode);\n\tloff_t oldsize;\n\tint err;\n\tbool trust_local_cmtime = is_wb;\n\tbool fault_blocked = false;\n\n\tif (!fc->default_permissions)\n\t\tattr->ia_valid |= ATTR_FORCE;\n\n\terr = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\tif (err)\n\t\treturn err;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tif (WARN_ON(!S_ISREG(inode->i_mode)))\n\t\t\treturn -EIO;\n\t\tis_truncate = true;\n\t}\n\n\tif (FUSE_IS_DAX(inode) && is_truncate) {\n\t\tfilemap_invalidate_lock(mapping);\n\t\tfault_blocked = true;\n\t\terr = fuse_dax_break_layouts(inode, 0, 0);\n\t\tif (err) {\n\t\t\tfilemap_invalidate_unlock(mapping);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (attr->ia_valid & ATTR_OPEN) {\n\t\t \n\t\tWARN_ON(!(attr->ia_valid & ATTR_SIZE));\n\t\tWARN_ON(attr->ia_size != 0);\n\t\tif (fc->atomic_o_trunc) {\n\t\t\t \n\t\t\ti_size_write(inode, 0);\n\t\t\ttruncate_pagecache(inode, 0);\n\t\t\tgoto out;\n\t\t}\n\t\tfile = NULL;\n\t}\n\n\t \n\tif (is_wb &&\n\t    attr->ia_valid &\n\t\t\t(ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_MTIME_SET |\n\t\t\t ATTR_TIMES_SET)) {\n\t\terr = write_inode_now(inode, true);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfuse_set_nowrite(inode);\n\t\tfuse_release_nowrite(inode);\n\t}\n\n\tif (is_truncate) {\n\t\tfuse_set_nowrite(inode);\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\t\tif (trust_local_cmtime && attr->ia_size != inode->i_size)\n\t\t\tattr->ia_valid |= ATTR_MTIME | ATTR_CTIME;\n\t}\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\tiattr_to_fattr(fc, attr, &inarg, trust_local_cmtime);\n\tif (file) {\n\t\tstruct fuse_file *ff = file->private_data;\n\t\tinarg.valid |= FATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\n\t \n\tif (fc->handle_killpriv_v2 && !S_ISDIR(inode->i_mode) &&\n\t    attr->ia_valid & (ATTR_UID | ATTR_GID))\n\t\tinarg.valid |= FATTR_KILL_SUIDGID;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t \n\t\tinarg.valid |= FATTR_LOCKOWNER;\n\t\tinarg.lock_owner = fuse_lock_owner_id(fc, current->files);\n\n\t\t \n\t\tif (fc->handle_killpriv_v2 && !capable(CAP_FSETID))\n\t\t\tinarg.valid |= FATTR_KILL_SUIDGID;\n\t}\n\tfuse_setattr_fill(fc, &args, inode, &inarg, &outarg);\n\terr = fuse_simple_request(fm, &args);\n\tif (err) {\n\t\tif (err == -EINTR)\n\t\t\tfuse_invalidate_attr(inode);\n\t\tgoto error;\n\t}\n\n\tif (fuse_invalid_attr(&outarg.attr) ||\n\t    inode_wrong_type(inode, outarg.attr.mode)) {\n\t\tfuse_make_bad(inode);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\n\tspin_lock(&fi->lock);\n\t \n\tif (trust_local_cmtime) {\n\t\tif (attr->ia_valid & ATTR_MTIME)\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\tif (attr->ia_valid & ATTR_CTIME)\n\t\t\tinode_set_ctime_to_ts(inode, attr->ia_ctime);\n\t\t \n\t}\n\n\tfuse_change_attributes_common(inode, &outarg.attr, NULL,\n\t\t\t\t      ATTR_TIMEOUT(&outarg),\n\t\t\t\t      fuse_get_cache_mask(inode));\n\toldsize = inode->i_size;\n\t \n\tif (!is_wb || is_truncate)\n\t\ti_size_write(inode, outarg.attr.size);\n\n\tif (is_truncate) {\n\t\t \n\t\t__fuse_release_nowrite(inode);\n\t}\n\tspin_unlock(&fi->lock);\n\n\t \n\tif ((is_truncate || !is_wb) &&\n\t    S_ISREG(inode->i_mode) && oldsize != outarg.attr.size) {\n\t\ttruncate_pagecache(inode, outarg.attr.size);\n\t\tinvalidate_inode_pages2(mapping);\n\t}\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\nout:\n\tif (fault_blocked)\n\t\tfilemap_invalidate_unlock(mapping);\n\n\treturn 0;\n\nerror:\n\tif (is_truncate)\n\t\tfuse_release_nowrite(inode);\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tif (fault_blocked)\n\t\tfilemap_invalidate_unlock(mapping);\n\treturn err;\n}\n\nstatic int fuse_setattr(struct mnt_idmap *idmap, struct dentry *entry,\n\t\t\tstruct iattr *attr)\n{\n\tstruct inode *inode = d_inode(entry);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct file *file = (attr->ia_valid & ATTR_FILE) ? attr->ia_file : NULL;\n\tint ret;\n\n\tif (fuse_is_bad(inode))\n\t\treturn -EIO;\n\n\tif (!fuse_allow_current_process(get_fuse_conn(inode)))\n\t\treturn -EACCES;\n\n\tif (attr->ia_valid & (ATTR_KILL_SUID | ATTR_KILL_SGID)) {\n\t\tattr->ia_valid &= ~(ATTR_KILL_SUID | ATTR_KILL_SGID |\n\t\t\t\t    ATTR_MODE);\n\n\t\t \n\t\tif (!fc->handle_killpriv && !fc->handle_killpriv_v2) {\n\t\t\t \n\t\t\tret = fuse_do_getattr(inode, NULL, file);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\tif (inode->i_mode & S_ISUID) {\n\t\t\t\tattr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode &= ~S_ISUID;\n\t\t\t}\n\t\t\tif ((inode->i_mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\t\tattr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t\t}\n\t\t}\n\t}\n\tif (!attr->ia_valid)\n\t\treturn 0;\n\n\tret = fuse_do_setattr(entry, attr, file);\n\tif (!ret) {\n\t\t \n\t\tif (fc->posix_acl)\n\t\t\tforget_all_cached_acls(inode);\n\n\t\t \n\t\tif (d_is_dir(entry) && (attr->ia_valid & ATTR_MODE))\n\t\t\tfuse_invalidate_entry_cache(entry);\n\t}\n\treturn ret;\n}\n\nstatic int fuse_getattr(struct mnt_idmap *idmap,\n\t\t\tconst struct path *path, struct kstat *stat,\n\t\t\tu32 request_mask, unsigned int flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (fuse_is_bad(inode))\n\t\treturn -EIO;\n\n\tif (!fuse_allow_current_process(fc)) {\n\t\tif (!request_mask) {\n\t\t\t \n\t\t\tstat->result_mask = 0;\n\t\t\tstat->dev = inode->i_sb->s_dev;\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EACCES;\n\t}\n\n\treturn fuse_update_get_attr(inode, NULL, stat, request_mask, flags);\n}\n\nstatic const struct inode_operations fuse_dir_inode_operations = {\n\t.lookup\t\t= fuse_lookup,\n\t.mkdir\t\t= fuse_mkdir,\n\t.symlink\t= fuse_symlink,\n\t.unlink\t\t= fuse_unlink,\n\t.rmdir\t\t= fuse_rmdir,\n\t.rename\t\t= fuse_rename2,\n\t.link\t\t= fuse_link,\n\t.setattr\t= fuse_setattr,\n\t.create\t\t= fuse_create,\n\t.atomic_open\t= fuse_atomic_open,\n\t.tmpfile\t= fuse_tmpfile,\n\t.mknod\t\t= fuse_mknod,\n\t.permission\t= fuse_permission,\n\t.getattr\t= fuse_getattr,\n\t.listxattr\t= fuse_listxattr,\n\t.get_inode_acl\t= fuse_get_inode_acl,\n\t.get_acl\t= fuse_get_acl,\n\t.set_acl\t= fuse_set_acl,\n\t.fileattr_get\t= fuse_fileattr_get,\n\t.fileattr_set\t= fuse_fileattr_set,\n};\n\nstatic const struct file_operations fuse_dir_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= fuse_readdir,\n\t.open\t\t= fuse_dir_open,\n\t.release\t= fuse_dir_release,\n\t.fsync\t\t= fuse_dir_fsync,\n\t.unlocked_ioctl\t= fuse_dir_ioctl,\n\t.compat_ioctl\t= fuse_dir_compat_ioctl,\n};\n\nstatic const struct inode_operations fuse_common_inode_operations = {\n\t.setattr\t= fuse_setattr,\n\t.permission\t= fuse_permission,\n\t.getattr\t= fuse_getattr,\n\t.listxattr\t= fuse_listxattr,\n\t.get_inode_acl\t= fuse_get_inode_acl,\n\t.get_acl\t= fuse_get_acl,\n\t.set_acl\t= fuse_set_acl,\n\t.fileattr_get\t= fuse_fileattr_get,\n\t.fileattr_set\t= fuse_fileattr_set,\n};\n\nstatic const struct inode_operations fuse_symlink_inode_operations = {\n\t.setattr\t= fuse_setattr,\n\t.get_link\t= fuse_get_link,\n\t.getattr\t= fuse_getattr,\n\t.listxattr\t= fuse_listxattr,\n};\n\nvoid fuse_init_common(struct inode *inode)\n{\n\tinode->i_op = &fuse_common_inode_operations;\n}\n\nvoid fuse_init_dir(struct inode *inode)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tinode->i_op = &fuse_dir_inode_operations;\n\tinode->i_fop = &fuse_dir_operations;\n\n\tspin_lock_init(&fi->rdc.lock);\n\tfi->rdc.cached = false;\n\tfi->rdc.size = 0;\n\tfi->rdc.pos = 0;\n\tfi->rdc.version = 0;\n}\n\nstatic int fuse_symlink_read_folio(struct file *null, struct folio *folio)\n{\n\tint err = fuse_readlink_page(folio->mapping->host, &folio->page);\n\n\tif (!err)\n\t\tfolio_mark_uptodate(folio);\n\n\tfolio_unlock(folio);\n\n\treturn err;\n}\n\nstatic const struct address_space_operations fuse_symlink_aops = {\n\t.read_folio\t= fuse_symlink_read_folio,\n};\n\nvoid fuse_init_symlink(struct inode *inode)\n{\n\tinode->i_op = &fuse_symlink_inode_operations;\n\tinode->i_data.a_ops = &fuse_symlink_aops;\n\tinode_nohighmem(inode);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}