{
  "module_name": "volume.c",
  "hash_id": "d5433217007ba95eca528a98811b3a3d100be373ec52fea81ca296f85b3047b1",
  "original_prompt": "Ingested from linux-6.6.14/fs/fscache/volume.c",
  "human_readable_source": "\n \n\n#define FSCACHE_DEBUG_LEVEL COOKIE\n#include <linux/export.h>\n#include <linux/slab.h>\n#include \"internal.h\"\n\n#define fscache_volume_hash_shift 10\nstatic struct hlist_bl_head fscache_volume_hash[1 << fscache_volume_hash_shift];\nstatic atomic_t fscache_volume_debug_id;\nstatic LIST_HEAD(fscache_volumes);\n\nstatic void fscache_create_volume_work(struct work_struct *work);\n\nstruct fscache_volume *fscache_get_volume(struct fscache_volume *volume,\n\t\t\t\t\t  enum fscache_volume_trace where)\n{\n\tint ref;\n\n\t__refcount_inc(&volume->ref, &ref);\n\ttrace_fscache_volume(volume->debug_id, ref + 1, where);\n\treturn volume;\n}\n\nstatic void fscache_see_volume(struct fscache_volume *volume,\n\t\t\t       enum fscache_volume_trace where)\n{\n\tint ref = refcount_read(&volume->ref);\n\n\ttrace_fscache_volume(volume->debug_id, ref, where);\n}\n\n \nstatic void __fscache_begin_volume_access(struct fscache_volume *volume,\n\t\t\t\t\t  struct fscache_cookie *cookie,\n\t\t\t\t\t  enum fscache_access_trace why)\n{\n\tint n_accesses;\n\n\tn_accesses = atomic_inc_return(&volume->n_accesses);\n\tsmp_mb__after_atomic();\n\ttrace_fscache_access_volume(volume->debug_id, cookie ? cookie->debug_id : 0,\n\t\t\t\t    refcount_read(&volume->ref),\n\t\t\t\t    n_accesses, why);\n}\n\n \nbool fscache_begin_volume_access(struct fscache_volume *volume,\n\t\t\t\t struct fscache_cookie *cookie,\n\t\t\t\t enum fscache_access_trace why)\n{\n\tif (!fscache_cache_is_live(volume->cache))\n\t\treturn false;\n\t__fscache_begin_volume_access(volume, cookie, why);\n\tif (!fscache_cache_is_live(volume->cache)) {\n\t\tfscache_end_volume_access(volume, cookie, fscache_access_unlive);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nvoid fscache_end_volume_access(struct fscache_volume *volume,\n\t\t\t       struct fscache_cookie *cookie,\n\t\t\t       enum fscache_access_trace why)\n{\n\tint n_accesses;\n\n\tsmp_mb__before_atomic();\n\tn_accesses = atomic_dec_return(&volume->n_accesses);\n\ttrace_fscache_access_volume(volume->debug_id, cookie ? cookie->debug_id : 0,\n\t\t\t\t    refcount_read(&volume->ref),\n\t\t\t\t    n_accesses, why);\n\tif (n_accesses == 0)\n\t\twake_up_var(&volume->n_accesses);\n}\nEXPORT_SYMBOL(fscache_end_volume_access);\n\nstatic bool fscache_volume_same(const struct fscache_volume *a,\n\t\t\t\tconst struct fscache_volume *b)\n{\n\tsize_t klen;\n\n\tif (a->key_hash\t!= b->key_hash ||\n\t    a->cache\t!= b->cache ||\n\t    a->key[0]\t!= b->key[0])\n\t\treturn false;\n\n\tklen = round_up(a->key[0] + 1, sizeof(__le32));\n\treturn memcmp(a->key, b->key, klen) == 0;\n}\n\nstatic bool fscache_is_acquire_pending(struct fscache_volume *volume)\n{\n\treturn test_bit(FSCACHE_VOLUME_ACQUIRE_PENDING, &volume->flags);\n}\n\nstatic void fscache_wait_on_volume_collision(struct fscache_volume *candidate,\n\t\t\t\t\t     unsigned int collidee_debug_id)\n{\n\twait_on_bit_timeout(&candidate->flags, FSCACHE_VOLUME_ACQUIRE_PENDING,\n\t\t\t    TASK_UNINTERRUPTIBLE, 20 * HZ);\n\tif (fscache_is_acquire_pending(candidate)) {\n\t\tpr_notice(\"Potential volume collision new=%08x old=%08x\",\n\t\t\t  candidate->debug_id, collidee_debug_id);\n\t\tfscache_stat(&fscache_n_volumes_collision);\n\t\twait_on_bit(&candidate->flags, FSCACHE_VOLUME_ACQUIRE_PENDING,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t}\n}\n\n \nstatic bool fscache_hash_volume(struct fscache_volume *candidate)\n{\n\tstruct fscache_volume *cursor;\n\tstruct hlist_bl_head *h;\n\tstruct hlist_bl_node *p;\n\tunsigned int bucket, collidee_debug_id = 0;\n\n\tbucket = candidate->key_hash & (ARRAY_SIZE(fscache_volume_hash) - 1);\n\th = &fscache_volume_hash[bucket];\n\n\thlist_bl_lock(h);\n\thlist_bl_for_each_entry(cursor, p, h, hash_link) {\n\t\tif (fscache_volume_same(candidate, cursor)) {\n\t\t\tif (!test_bit(FSCACHE_VOLUME_RELINQUISHED, &cursor->flags))\n\t\t\t\tgoto collision;\n\t\t\tfscache_see_volume(cursor, fscache_volume_get_hash_collision);\n\t\t\tset_bit(FSCACHE_VOLUME_COLLIDED_WITH, &cursor->flags);\n\t\t\tset_bit(FSCACHE_VOLUME_ACQUIRE_PENDING, &candidate->flags);\n\t\t\tcollidee_debug_id = cursor->debug_id;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thlist_bl_add_head(&candidate->hash_link, h);\n\thlist_bl_unlock(h);\n\n\tif (fscache_is_acquire_pending(candidate))\n\t\tfscache_wait_on_volume_collision(candidate, collidee_debug_id);\n\treturn true;\n\ncollision:\n\tfscache_see_volume(cursor, fscache_volume_collision);\n\thlist_bl_unlock(h);\n\treturn false;\n}\n\n \nstatic struct fscache_volume *fscache_alloc_volume(const char *volume_key,\n\t\t\t\t\t\t   const char *cache_name,\n\t\t\t\t\t\t   const void *coherency_data,\n\t\t\t\t\t\t   size_t coherency_len)\n{\n\tstruct fscache_volume *volume;\n\tstruct fscache_cache *cache;\n\tsize_t klen, hlen;\n\tu8 *key;\n\n\tklen = strlen(volume_key);\n\tif (klen > NAME_MAX)\n\t\treturn NULL;\n\n\tif (!coherency_data)\n\t\tcoherency_len = 0;\n\n\tcache = fscache_lookup_cache(cache_name, false);\n\tif (IS_ERR(cache))\n\t\treturn NULL;\n\n\tvolume = kzalloc(struct_size(volume, coherency, coherency_len),\n\t\t\t GFP_KERNEL);\n\tif (!volume)\n\t\tgoto err_cache;\n\n\tvolume->cache = cache;\n\tvolume->coherency_len = coherency_len;\n\tif (coherency_data)\n\t\tmemcpy(volume->coherency, coherency_data, coherency_len);\n\tINIT_LIST_HEAD(&volume->proc_link);\n\tINIT_WORK(&volume->work, fscache_create_volume_work);\n\trefcount_set(&volume->ref, 1);\n\tspin_lock_init(&volume->lock);\n\n\t \n\thlen = round_up(1 + klen + 1, sizeof(__le32));\n\tkey = kzalloc(hlen, GFP_KERNEL);\n\tif (!key)\n\t\tgoto err_vol;\n\tkey[0] = klen;\n\tmemcpy(key + 1, volume_key, klen);\n\n\tvolume->key = key;\n\tvolume->key_hash = fscache_hash(0, key, hlen);\n\n\tvolume->debug_id = atomic_inc_return(&fscache_volume_debug_id);\n\tdown_write(&fscache_addremove_sem);\n\tatomic_inc(&cache->n_volumes);\n\tlist_add_tail(&volume->proc_link, &fscache_volumes);\n\tfscache_see_volume(volume, fscache_volume_new_acquire);\n\tfscache_stat(&fscache_n_volumes);\n\tup_write(&fscache_addremove_sem);\n\t_leave(\" = v=%x\", volume->debug_id);\n\treturn volume;\n\nerr_vol:\n\tkfree(volume);\nerr_cache:\n\tfscache_put_cache(cache, fscache_cache_put_alloc_volume);\n\tfscache_stat(&fscache_n_volumes_nomem);\n\treturn NULL;\n}\n\n \nstatic void fscache_create_volume_work(struct work_struct *work)\n{\n\tconst struct fscache_cache_ops *ops;\n\tstruct fscache_volume *volume =\n\t\tcontainer_of(work, struct fscache_volume, work);\n\n\tfscache_see_volume(volume, fscache_volume_see_create_work);\n\n\tops = volume->cache->ops;\n\tif (ops->acquire_volume)\n\t\tops->acquire_volume(volume);\n\tfscache_end_cache_access(volume->cache,\n\t\t\t\t fscache_access_acquire_volume_end);\n\n\tclear_and_wake_up_bit(FSCACHE_VOLUME_CREATING, &volume->flags);\n\tfscache_put_volume(volume, fscache_volume_put_create_work);\n}\n\n \nvoid fscache_create_volume(struct fscache_volume *volume, bool wait)\n{\n\tif (test_and_set_bit(FSCACHE_VOLUME_CREATING, &volume->flags))\n\t\tgoto maybe_wait;\n\tif (volume->cache_priv)\n\t\tgoto no_wait;  \n\tif (!fscache_begin_cache_access(volume->cache,\n\t\t\t\t\tfscache_access_acquire_volume))\n\t\tgoto no_wait;\n\n\tfscache_get_volume(volume, fscache_volume_get_create_work);\n\tif (!schedule_work(&volume->work))\n\t\tfscache_put_volume(volume, fscache_volume_put_create_work);\n\nmaybe_wait:\n\tif (wait) {\n\t\tfscache_see_volume(volume, fscache_volume_wait_create_work);\n\t\twait_on_bit(&volume->flags, FSCACHE_VOLUME_CREATING,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t}\n\treturn;\nno_wait:\n\tclear_bit_unlock(FSCACHE_VOLUME_CREATING, &volume->flags);\n\twake_up_bit(&volume->flags, FSCACHE_VOLUME_CREATING);\n}\n\n \nstruct fscache_volume *__fscache_acquire_volume(const char *volume_key,\n\t\t\t\t\t\tconst char *cache_name,\n\t\t\t\t\t\tconst void *coherency_data,\n\t\t\t\t\t\tsize_t coherency_len)\n{\n\tstruct fscache_volume *volume;\n\n\tvolume = fscache_alloc_volume(volume_key, cache_name,\n\t\t\t\t      coherency_data, coherency_len);\n\tif (!volume)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!fscache_hash_volume(volume)) {\n\t\tfscache_put_volume(volume, fscache_volume_put_hash_collision);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tfscache_create_volume(volume, false);\n\treturn volume;\n}\nEXPORT_SYMBOL(__fscache_acquire_volume);\n\nstatic void fscache_wake_pending_volume(struct fscache_volume *volume,\n\t\t\t\t\tstruct hlist_bl_head *h)\n{\n\tstruct fscache_volume *cursor;\n\tstruct hlist_bl_node *p;\n\n\thlist_bl_for_each_entry(cursor, p, h, hash_link) {\n\t\tif (fscache_volume_same(cursor, volume)) {\n\t\t\tfscache_see_volume(cursor, fscache_volume_see_hash_wake);\n\t\t\tclear_and_wake_up_bit(FSCACHE_VOLUME_ACQUIRE_PENDING,\n\t\t\t\t\t      &cursor->flags);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nstatic void fscache_unhash_volume(struct fscache_volume *volume)\n{\n\tstruct hlist_bl_head *h;\n\tunsigned int bucket;\n\n\tbucket = volume->key_hash & (ARRAY_SIZE(fscache_volume_hash) - 1);\n\th = &fscache_volume_hash[bucket];\n\n\thlist_bl_lock(h);\n\thlist_bl_del(&volume->hash_link);\n\tif (test_bit(FSCACHE_VOLUME_COLLIDED_WITH, &volume->flags))\n\t\tfscache_wake_pending_volume(volume, h);\n\thlist_bl_unlock(h);\n}\n\n \nstatic void fscache_free_volume(struct fscache_volume *volume)\n{\n\tstruct fscache_cache *cache = volume->cache;\n\n\tif (volume->cache_priv) {\n\t\t__fscache_begin_volume_access(volume, NULL,\n\t\t\t\t\t      fscache_access_relinquish_volume);\n\t\tif (volume->cache_priv)\n\t\t\tcache->ops->free_volume(volume);\n\t\tfscache_end_volume_access(volume, NULL,\n\t\t\t\t\t  fscache_access_relinquish_volume_end);\n\t}\n\n\tdown_write(&fscache_addremove_sem);\n\tlist_del_init(&volume->proc_link);\n\tatomic_dec(&volume->cache->n_volumes);\n\tup_write(&fscache_addremove_sem);\n\n\tif (!hlist_bl_unhashed(&volume->hash_link))\n\t\tfscache_unhash_volume(volume);\n\n\ttrace_fscache_volume(volume->debug_id, 0, fscache_volume_free);\n\tkfree(volume->key);\n\tkfree(volume);\n\tfscache_stat_d(&fscache_n_volumes);\n\tfscache_put_cache(cache, fscache_cache_put_volume);\n}\n\n \nvoid fscache_put_volume(struct fscache_volume *volume,\n\t\t\tenum fscache_volume_trace where)\n{\n\tif (volume) {\n\t\tunsigned int debug_id = volume->debug_id;\n\t\tbool zero;\n\t\tint ref;\n\n\t\tzero = __refcount_dec_and_test(&volume->ref, &ref);\n\t\ttrace_fscache_volume(debug_id, ref - 1, where);\n\t\tif (zero)\n\t\t\tfscache_free_volume(volume);\n\t}\n}\n\n \nvoid __fscache_relinquish_volume(struct fscache_volume *volume,\n\t\t\t\t const void *coherency_data,\n\t\t\t\t bool invalidate)\n{\n\tif (WARN_ON(test_and_set_bit(FSCACHE_VOLUME_RELINQUISHED, &volume->flags)))\n\t\treturn;\n\n\tif (invalidate) {\n\t\tset_bit(FSCACHE_VOLUME_INVALIDATE, &volume->flags);\n\t} else if (coherency_data) {\n\t\tmemcpy(volume->coherency, coherency_data, volume->coherency_len);\n\t}\n\n\tfscache_put_volume(volume, fscache_volume_put_relinquish);\n}\nEXPORT_SYMBOL(__fscache_relinquish_volume);\n\n \nvoid fscache_withdraw_volume(struct fscache_volume *volume)\n{\n\tint n_accesses;\n\n\t_debug(\"withdraw V=%x\", volume->debug_id);\n\n\t \n\tn_accesses = atomic_dec_return(&volume->n_accesses);\n\ttrace_fscache_access_volume(volume->debug_id, 0,\n\t\t\t\t    refcount_read(&volume->ref),\n\t\t\t\t    n_accesses, fscache_access_cache_unpin);\n\n\twait_var_event(&volume->n_accesses,\n\t\t       atomic_read(&volume->n_accesses) == 0);\n}\nEXPORT_SYMBOL(fscache_withdraw_volume);\n\n#ifdef CONFIG_PROC_FS\n \nstatic int fscache_volumes_seq_show(struct seq_file *m, void *v)\n{\n\tstruct fscache_volume *volume;\n\n\tif (v == &fscache_volumes) {\n\t\tseq_puts(m,\n\t\t\t \"VOLUME   REF   nCOOK ACC FL CACHE           KEY\\n\"\n\t\t\t \"======== ===== ===== === == =============== ================\\n\");\n\t\treturn 0;\n\t}\n\n\tvolume = list_entry(v, struct fscache_volume, proc_link);\n\tseq_printf(m,\n\t\t   \"%08x %5d %5d %3d %02lx %-15.15s %s\\n\",\n\t\t   volume->debug_id,\n\t\t   refcount_read(&volume->ref),\n\t\t   atomic_read(&volume->n_cookies),\n\t\t   atomic_read(&volume->n_accesses),\n\t\t   volume->flags,\n\t\t   volume->cache->name ?: \"-\",\n\t\t   volume->key + 1);\n\treturn 0;\n}\n\nstatic void *fscache_volumes_seq_start(struct seq_file *m, loff_t *_pos)\n\t__acquires(&fscache_addremove_sem)\n{\n\tdown_read(&fscache_addremove_sem);\n\treturn seq_list_start_head(&fscache_volumes, *_pos);\n}\n\nstatic void *fscache_volumes_seq_next(struct seq_file *m, void *v, loff_t *_pos)\n{\n\treturn seq_list_next(v, &fscache_volumes, _pos);\n}\n\nstatic void fscache_volumes_seq_stop(struct seq_file *m, void *v)\n\t__releases(&fscache_addremove_sem)\n{\n\tup_read(&fscache_addremove_sem);\n}\n\nconst struct seq_operations fscache_volumes_seq_ops = {\n\t.start  = fscache_volumes_seq_start,\n\t.next   = fscache_volumes_seq_next,\n\t.stop   = fscache_volumes_seq_stop,\n\t.show   = fscache_volumes_seq_show,\n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}