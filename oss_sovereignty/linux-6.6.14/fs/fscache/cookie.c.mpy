{
  "module_name": "cookie.c",
  "hash_id": "7abcb2c3e1b1d179764255efe533111a51d3d2dc0656d4190631ce8d4647a7cb",
  "original_prompt": "Ingested from linux-6.6.14/fs/fscache/cookie.c",
  "human_readable_source": "\n \n\n#define FSCACHE_DEBUG_LEVEL COOKIE\n#include <linux/module.h>\n#include <linux/slab.h>\n#include \"internal.h\"\n\nstruct kmem_cache *fscache_cookie_jar;\n\nstatic void fscache_cookie_lru_timed_out(struct timer_list *timer);\nstatic void fscache_cookie_lru_worker(struct work_struct *work);\nstatic void fscache_cookie_worker(struct work_struct *work);\nstatic void fscache_unhash_cookie(struct fscache_cookie *cookie);\nstatic void fscache_perform_invalidation(struct fscache_cookie *cookie);\n\n#define fscache_cookie_hash_shift 15\nstatic struct hlist_bl_head fscache_cookie_hash[1 << fscache_cookie_hash_shift];\nstatic LIST_HEAD(fscache_cookies);\nstatic DEFINE_RWLOCK(fscache_cookies_lock);\nstatic LIST_HEAD(fscache_cookie_lru);\nstatic DEFINE_SPINLOCK(fscache_cookie_lru_lock);\nDEFINE_TIMER(fscache_cookie_lru_timer, fscache_cookie_lru_timed_out);\nstatic DECLARE_WORK(fscache_cookie_lru_work, fscache_cookie_lru_worker);\nstatic const char fscache_cookie_states[FSCACHE_COOKIE_STATE__NR] = \"-LCAIFUWRD\";\nstatic unsigned int fscache_lru_cookie_timeout = 10 * HZ;\n\nvoid fscache_print_cookie(struct fscache_cookie *cookie, char prefix)\n{\n\tconst u8 *k;\n\n\tpr_err(\"%c-cookie c=%08x [fl=%lx na=%u nA=%u s=%c]\\n\",\n\t       prefix,\n\t       cookie->debug_id,\n\t       cookie->flags,\n\t       atomic_read(&cookie->n_active),\n\t       atomic_read(&cookie->n_accesses),\n\t       fscache_cookie_states[cookie->state]);\n\tpr_err(\"%c-cookie V=%08x [%s]\\n\",\n\t       prefix,\n\t       cookie->volume->debug_id,\n\t       cookie->volume->key);\n\n\tk = (cookie->key_len <= sizeof(cookie->inline_key)) ?\n\t\tcookie->inline_key : cookie->key;\n\tpr_err(\"%c-key=[%u] '%*phN'\\n\", prefix, cookie->key_len, cookie->key_len, k);\n}\n\nstatic void fscache_free_cookie(struct fscache_cookie *cookie)\n{\n\tif (WARN_ON_ONCE(!list_empty(&cookie->commit_link))) {\n\t\tspin_lock(&fscache_cookie_lru_lock);\n\t\tlist_del_init(&cookie->commit_link);\n\t\tspin_unlock(&fscache_cookie_lru_lock);\n\t\tfscache_stat_d(&fscache_n_cookies_lru);\n\t\tfscache_stat(&fscache_n_cookies_lru_removed);\n\t}\n\n\tif (WARN_ON_ONCE(test_bit(FSCACHE_COOKIE_IS_HASHED, &cookie->flags))) {\n\t\tfscache_print_cookie(cookie, 'F');\n\t\treturn;\n\t}\n\n\twrite_lock(&fscache_cookies_lock);\n\tlist_del(&cookie->proc_link);\n\twrite_unlock(&fscache_cookies_lock);\n\tif (cookie->aux_len > sizeof(cookie->inline_aux))\n\t\tkfree(cookie->aux);\n\tif (cookie->key_len > sizeof(cookie->inline_key))\n\t\tkfree(cookie->key);\n\tfscache_stat_d(&fscache_n_cookies);\n\tkmem_cache_free(fscache_cookie_jar, cookie);\n}\n\nstatic void __fscache_queue_cookie(struct fscache_cookie *cookie)\n{\n\tif (!queue_work(fscache_wq, &cookie->work))\n\t\tfscache_put_cookie(cookie, fscache_cookie_put_over_queued);\n}\n\nstatic void fscache_queue_cookie(struct fscache_cookie *cookie,\n\t\t\t\t enum fscache_cookie_trace where)\n{\n\tfscache_get_cookie(cookie, where);\n\t__fscache_queue_cookie(cookie);\n}\n\n \nstatic void fscache_init_access_gate(struct fscache_cookie *cookie)\n{\n\tint n_accesses;\n\n\tn_accesses = atomic_read(&cookie->n_accesses);\n\ttrace_fscache_access(cookie->debug_id, refcount_read(&cookie->ref),\n\t\t\t     n_accesses, fscache_access_cache_pin);\n\tset_bit(FSCACHE_COOKIE_NO_ACCESS_WAKE, &cookie->flags);\n}\n\n \nvoid fscache_end_cookie_access(struct fscache_cookie *cookie,\n\t\t\t       enum fscache_access_trace why)\n{\n\tint n_accesses;\n\n\tsmp_mb__before_atomic();\n\tn_accesses = atomic_dec_return(&cookie->n_accesses);\n\ttrace_fscache_access(cookie->debug_id, refcount_read(&cookie->ref),\n\t\t\t     n_accesses, why);\n\tif (n_accesses == 0 &&\n\t    !test_bit(FSCACHE_COOKIE_NO_ACCESS_WAKE, &cookie->flags))\n\t\tfscache_queue_cookie(cookie, fscache_cookie_get_end_access);\n}\nEXPORT_SYMBOL(fscache_end_cookie_access);\n\n \nstatic void __fscache_begin_cookie_access(struct fscache_cookie *cookie,\n\t\t\t\t\t  enum fscache_access_trace why)\n{\n\tint n_accesses;\n\n\tn_accesses = atomic_inc_return(&cookie->n_accesses);\n\tsmp_mb__after_atomic();  \n\ttrace_fscache_access(cookie->debug_id, refcount_read(&cookie->ref),\n\t\t\t     n_accesses, why);\n}\n\n \nbool fscache_begin_cookie_access(struct fscache_cookie *cookie,\n\t\t\t\t enum fscache_access_trace why)\n{\n\tif (!test_bit(FSCACHE_COOKIE_IS_CACHING, &cookie->flags))\n\t\treturn false;\n\t__fscache_begin_cookie_access(cookie, why);\n\tif (!test_bit(FSCACHE_COOKIE_IS_CACHING, &cookie->flags) ||\n\t    !fscache_cache_is_live(cookie->volume->cache)) {\n\t\tfscache_end_cookie_access(cookie, fscache_access_unlive);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic inline void wake_up_cookie_state(struct fscache_cookie *cookie)\n{\n\t \n\tsmp_mb();\n\twake_up_var(&cookie->state);\n}\n\n \nstatic void __fscache_set_cookie_state(struct fscache_cookie *cookie,\n\t\t\t\t       enum fscache_cookie_state state)\n{\n\tsmp_store_release(&cookie->state, state);\n}\n\nstatic void fscache_set_cookie_state(struct fscache_cookie *cookie,\n\t\t\t\t     enum fscache_cookie_state state)\n{\n\tspin_lock(&cookie->lock);\n\t__fscache_set_cookie_state(cookie, state);\n\tspin_unlock(&cookie->lock);\n\twake_up_cookie_state(cookie);\n}\n\n \nvoid fscache_cookie_lookup_negative(struct fscache_cookie *cookie)\n{\n\tset_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &cookie->flags);\n\tfscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_CREATING);\n}\nEXPORT_SYMBOL(fscache_cookie_lookup_negative);\n\n \nvoid fscache_resume_after_invalidation(struct fscache_cookie *cookie)\n{\n\tfscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_ACTIVE);\n}\nEXPORT_SYMBOL(fscache_resume_after_invalidation);\n\n \nvoid fscache_caching_failed(struct fscache_cookie *cookie)\n{\n\tclear_bit(FSCACHE_COOKIE_IS_CACHING, &cookie->flags);\n\tfscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_FAILED);\n\ttrace_fscache_cookie(cookie->debug_id, refcount_read(&cookie->ref),\n\t\t\t\tfscache_cookie_failed);\n}\nEXPORT_SYMBOL(fscache_caching_failed);\n\n \nstatic int fscache_set_key(struct fscache_cookie *cookie,\n\t\t\t   const void *index_key, size_t index_key_len)\n{\n\tvoid *buf;\n\tsize_t buf_size;\n\n\tbuf_size = round_up(index_key_len, sizeof(__le32));\n\n\tif (index_key_len > sizeof(cookie->inline_key)) {\n\t\tbuf = kzalloc(buf_size, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tcookie->key = buf;\n\t} else {\n\t\tbuf = cookie->inline_key;\n\t}\n\n\tmemcpy(buf, index_key, index_key_len);\n\tcookie->key_hash = fscache_hash(cookie->volume->key_hash,\n\t\t\t\t\tbuf, buf_size);\n\treturn 0;\n}\n\nstatic bool fscache_cookie_same(const struct fscache_cookie *a,\n\t\t\t\tconst struct fscache_cookie *b)\n{\n\tconst void *ka, *kb;\n\n\tif (a->key_hash\t!= b->key_hash ||\n\t    a->volume\t!= b->volume ||\n\t    a->key_len\t!= b->key_len)\n\t\treturn false;\n\n\tif (a->key_len <= sizeof(a->inline_key)) {\n\t\tka = &a->inline_key;\n\t\tkb = &b->inline_key;\n\t} else {\n\t\tka = a->key;\n\t\tkb = b->key;\n\t}\n\treturn memcmp(ka, kb, a->key_len) == 0;\n}\n\nstatic atomic_t fscache_cookie_debug_id = ATOMIC_INIT(1);\n\n \nstatic struct fscache_cookie *fscache_alloc_cookie(\n\tstruct fscache_volume *volume,\n\tu8 advice,\n\tconst void *index_key, size_t index_key_len,\n\tconst void *aux_data, size_t aux_data_len,\n\tloff_t object_size)\n{\n\tstruct fscache_cookie *cookie;\n\n\t \n\tcookie = kmem_cache_zalloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie)\n\t\treturn NULL;\n\tfscache_stat(&fscache_n_cookies);\n\n\tcookie->volume\t\t= volume;\n\tcookie->advice\t\t= advice;\n\tcookie->key_len\t\t= index_key_len;\n\tcookie->aux_len\t\t= aux_data_len;\n\tcookie->object_size\t= object_size;\n\tif (object_size == 0)\n\t\t__set_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &cookie->flags);\n\n\tif (fscache_set_key(cookie, index_key, index_key_len) < 0)\n\t\tgoto nomem;\n\n\tif (cookie->aux_len <= sizeof(cookie->inline_aux)) {\n\t\tmemcpy(cookie->inline_aux, aux_data, cookie->aux_len);\n\t} else {\n\t\tcookie->aux = kmemdup(aux_data, cookie->aux_len, GFP_KERNEL);\n\t\tif (!cookie->aux)\n\t\t\tgoto nomem;\n\t}\n\n\trefcount_set(&cookie->ref, 1);\n\tcookie->debug_id = atomic_inc_return(&fscache_cookie_debug_id);\n\tspin_lock_init(&cookie->lock);\n\tINIT_LIST_HEAD(&cookie->commit_link);\n\tINIT_WORK(&cookie->work, fscache_cookie_worker);\n\t__fscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_QUIESCENT);\n\n\twrite_lock(&fscache_cookies_lock);\n\tlist_add_tail(&cookie->proc_link, &fscache_cookies);\n\twrite_unlock(&fscache_cookies_lock);\n\tfscache_see_cookie(cookie, fscache_cookie_new_acquire);\n\treturn cookie;\n\nnomem:\n\tfscache_free_cookie(cookie);\n\treturn NULL;\n}\n\nstatic inline bool fscache_cookie_is_dropped(struct fscache_cookie *cookie)\n{\n\treturn READ_ONCE(cookie->state) == FSCACHE_COOKIE_STATE_DROPPED;\n}\n\nstatic void fscache_wait_on_collision(struct fscache_cookie *candidate,\n\t\t\t\t      struct fscache_cookie *wait_for)\n{\n\tenum fscache_cookie_state *statep = &wait_for->state;\n\n\twait_var_event_timeout(statep, fscache_cookie_is_dropped(wait_for),\n\t\t\t       20 * HZ);\n\tif (!fscache_cookie_is_dropped(wait_for)) {\n\t\tpr_notice(\"Potential collision c=%08x old: c=%08x\",\n\t\t\t  candidate->debug_id, wait_for->debug_id);\n\t\twait_var_event(statep, fscache_cookie_is_dropped(wait_for));\n\t}\n}\n\n \nstatic bool fscache_hash_cookie(struct fscache_cookie *candidate)\n{\n\tstruct fscache_cookie *cursor, *wait_for = NULL;\n\tstruct hlist_bl_head *h;\n\tstruct hlist_bl_node *p;\n\tunsigned int bucket;\n\n\tbucket = candidate->key_hash & (ARRAY_SIZE(fscache_cookie_hash) - 1);\n\th = &fscache_cookie_hash[bucket];\n\n\thlist_bl_lock(h);\n\thlist_bl_for_each_entry(cursor, p, h, hash_link) {\n\t\tif (fscache_cookie_same(candidate, cursor)) {\n\t\t\tif (!test_bit(FSCACHE_COOKIE_RELINQUISHED, &cursor->flags))\n\t\t\t\tgoto collision;\n\t\t\twait_for = fscache_get_cookie(cursor,\n\t\t\t\t\t\t      fscache_cookie_get_hash_collision);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfscache_get_volume(candidate->volume, fscache_volume_get_cookie);\n\tatomic_inc(&candidate->volume->n_cookies);\n\thlist_bl_add_head(&candidate->hash_link, h);\n\tset_bit(FSCACHE_COOKIE_IS_HASHED, &candidate->flags);\n\thlist_bl_unlock(h);\n\n\tif (wait_for) {\n\t\tfscache_wait_on_collision(candidate, wait_for);\n\t\tfscache_put_cookie(wait_for, fscache_cookie_put_hash_collision);\n\t}\n\treturn true;\n\ncollision:\n\ttrace_fscache_cookie(cursor->debug_id, refcount_read(&cursor->ref),\n\t\t\t     fscache_cookie_collision);\n\tpr_err(\"Duplicate cookie detected\\n\");\n\tfscache_print_cookie(cursor, 'O');\n\tfscache_print_cookie(candidate, 'N');\n\thlist_bl_unlock(h);\n\treturn false;\n}\n\n \nstruct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_volume *volume,\n\tu8 advice,\n\tconst void *index_key, size_t index_key_len,\n\tconst void *aux_data, size_t aux_data_len,\n\tloff_t object_size)\n{\n\tstruct fscache_cookie *cookie;\n\n\t_enter(\"V=%x\", volume->debug_id);\n\n\tif (!index_key || !index_key_len || index_key_len > 255 || aux_data_len > 255)\n\t\treturn NULL;\n\tif (!aux_data || !aux_data_len) {\n\t\taux_data = NULL;\n\t\taux_data_len = 0;\n\t}\n\n\tfscache_stat(&fscache_n_acquires);\n\n\tcookie = fscache_alloc_cookie(volume, advice,\n\t\t\t\t      index_key, index_key_len,\n\t\t\t\t      aux_data, aux_data_len,\n\t\t\t\t      object_size);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\treturn NULL;\n\t}\n\n\tif (!fscache_hash_cookie(cookie)) {\n\t\tfscache_see_cookie(cookie, fscache_cookie_discard);\n\t\tfscache_free_cookie(cookie);\n\t\treturn NULL;\n\t}\n\n\ttrace_fscache_acquire(cookie);\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = c=%08x\", cookie->debug_id);\n\treturn cookie;\n}\nEXPORT_SYMBOL(__fscache_acquire_cookie);\n\n \nstatic void fscache_prepare_to_write(struct fscache_cookie *cookie)\n{\n\tcookie->volume->cache->ops->prepare_to_write(cookie);\n}\n\n \nstatic void fscache_perform_lookup(struct fscache_cookie *cookie)\n{\n\tenum fscache_access_trace trace = fscache_access_lookup_cookie_end_failed;\n\tbool need_withdraw = false;\n\n\t_enter(\"\");\n\n\tif (!cookie->volume->cache_priv) {\n\t\tfscache_create_volume(cookie->volume, true);\n\t\tif (!cookie->volume->cache_priv) {\n\t\t\tfscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_QUIESCENT);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!cookie->volume->cache->ops->lookup_cookie(cookie)) {\n\t\tif (cookie->state != FSCACHE_COOKIE_STATE_FAILED)\n\t\t\tfscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_QUIESCENT);\n\t\tneed_withdraw = true;\n\t\t_leave(\" [fail]\");\n\t\tgoto out;\n\t}\n\n\tfscache_see_cookie(cookie, fscache_cookie_see_active);\n\tspin_lock(&cookie->lock);\n\tif (test_and_clear_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags))\n\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t   FSCACHE_COOKIE_STATE_INVALIDATING);\n\telse\n\t\t__fscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_ACTIVE);\n\tspin_unlock(&cookie->lock);\n\twake_up_cookie_state(cookie);\n\ttrace = fscache_access_lookup_cookie_end;\n\nout:\n\tfscache_end_cookie_access(cookie, trace);\n\tif (need_withdraw)\n\t\tfscache_withdraw_cookie(cookie);\n\tfscache_end_volume_access(cookie->volume, cookie, trace);\n}\n\n \nstatic bool fscache_begin_lookup(struct fscache_cookie *cookie, bool will_modify)\n{\n\tif (will_modify) {\n\t\tset_bit(FSCACHE_COOKIE_LOCAL_WRITE, &cookie->flags);\n\t\tset_bit(FSCACHE_COOKIE_DO_PREP_TO_WRITE, &cookie->flags);\n\t}\n\tif (!fscache_begin_volume_access(cookie->volume, cookie,\n\t\t\t\t\t fscache_access_lookup_cookie))\n\t\treturn false;\n\n\t__fscache_begin_cookie_access(cookie, fscache_access_lookup_cookie);\n\t__fscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_LOOKING_UP);\n\tset_bit(FSCACHE_COOKIE_IS_CACHING, &cookie->flags);\n\tset_bit(FSCACHE_COOKIE_HAS_BEEN_CACHED, &cookie->flags);\n\treturn true;\n}\n\n \nvoid __fscache_use_cookie(struct fscache_cookie *cookie, bool will_modify)\n{\n\tenum fscache_cookie_state state;\n\tbool queue = false;\n\tint n_active;\n\n\t_enter(\"c=%08x\", cookie->debug_id);\n\n\tif (WARN(test_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags),\n\t\t \"Trying to use relinquished cookie\\n\"))\n\t\treturn;\n\n\tspin_lock(&cookie->lock);\n\n\tn_active = atomic_inc_return(&cookie->n_active);\n\ttrace_fscache_active(cookie->debug_id, refcount_read(&cookie->ref),\n\t\t\t     n_active, atomic_read(&cookie->n_accesses),\n\t\t\t     will_modify ?\n\t\t\t     fscache_active_use_modify : fscache_active_use);\n\nagain:\n\tstate = fscache_cookie_state(cookie);\n\tswitch (state) {\n\tcase FSCACHE_COOKIE_STATE_QUIESCENT:\n\t\tqueue = fscache_begin_lookup(cookie, will_modify);\n\t\tbreak;\n\n\tcase FSCACHE_COOKIE_STATE_LOOKING_UP:\n\tcase FSCACHE_COOKIE_STATE_CREATING:\n\t\tif (will_modify)\n\t\t\tset_bit(FSCACHE_COOKIE_LOCAL_WRITE, &cookie->flags);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_STATE_ACTIVE:\n\tcase FSCACHE_COOKIE_STATE_INVALIDATING:\n\t\tif (will_modify &&\n\t\t    !test_and_set_bit(FSCACHE_COOKIE_LOCAL_WRITE, &cookie->flags)) {\n\t\t\tset_bit(FSCACHE_COOKIE_DO_PREP_TO_WRITE, &cookie->flags);\n\t\t\tqueue = true;\n\t\t}\n\t\t \n\t\tif (test_and_clear_bit(FSCACHE_COOKIE_DO_LRU_DISCARD, &cookie->flags))\n\t\t\tfscache_see_cookie(cookie, fscache_cookie_see_lru_discard_clear);\n\t\tbreak;\n\n\tcase FSCACHE_COOKIE_STATE_FAILED:\n\tcase FSCACHE_COOKIE_STATE_WITHDRAWING:\n\t\tbreak;\n\n\tcase FSCACHE_COOKIE_STATE_LRU_DISCARDING:\n\t\tspin_unlock(&cookie->lock);\n\t\twait_var_event(&cookie->state,\n\t\t\t       fscache_cookie_state(cookie) !=\n\t\t\t       FSCACHE_COOKIE_STATE_LRU_DISCARDING);\n\t\tspin_lock(&cookie->lock);\n\t\tgoto again;\n\n\tcase FSCACHE_COOKIE_STATE_DROPPED:\n\tcase FSCACHE_COOKIE_STATE_RELINQUISHING:\n\t\tWARN(1, \"Can't use cookie in state %u\\n\", state);\n\t\tbreak;\n\t}\n\n\tspin_unlock(&cookie->lock);\n\tif (queue)\n\t\tfscache_queue_cookie(cookie, fscache_cookie_get_use_work);\n\t_leave(\"\");\n}\nEXPORT_SYMBOL(__fscache_use_cookie);\n\nstatic void fscache_unuse_cookie_locked(struct fscache_cookie *cookie)\n{\n\tclear_bit(FSCACHE_COOKIE_DISABLED, &cookie->flags);\n\tif (!test_bit(FSCACHE_COOKIE_IS_CACHING, &cookie->flags))\n\t\treturn;\n\n\tcookie->unused_at = jiffies;\n\tspin_lock(&fscache_cookie_lru_lock);\n\tif (list_empty(&cookie->commit_link)) {\n\t\tfscache_get_cookie(cookie, fscache_cookie_get_lru);\n\t\tfscache_stat(&fscache_n_cookies_lru);\n\t}\n\tlist_move_tail(&cookie->commit_link, &fscache_cookie_lru);\n\n\tspin_unlock(&fscache_cookie_lru_lock);\n\ttimer_reduce(&fscache_cookie_lru_timer,\n\t\t     jiffies + fscache_lru_cookie_timeout);\n}\n\n \nvoid __fscache_unuse_cookie(struct fscache_cookie *cookie,\n\t\t\t    const void *aux_data, const loff_t *object_size)\n{\n\tunsigned int debug_id = cookie->debug_id;\n\tunsigned int r = refcount_read(&cookie->ref);\n\tunsigned int a = atomic_read(&cookie->n_accesses);\n\tunsigned int c;\n\n\tif (aux_data || object_size)\n\t\t__fscache_update_cookie(cookie, aux_data, object_size);\n\n\t \n\tc = atomic_fetch_add_unless(&cookie->n_active, -1, 1);\n\tif (c != 1) {\n\t\ttrace_fscache_active(debug_id, r, c - 1, a, fscache_active_unuse);\n\t\treturn;\n\t}\n\n\tspin_lock(&cookie->lock);\n\tr = refcount_read(&cookie->ref);\n\ta = atomic_read(&cookie->n_accesses);\n\tc = atomic_dec_return(&cookie->n_active);\n\ttrace_fscache_active(debug_id, r, c, a, fscache_active_unuse);\n\tif (c == 0)\n\t\tfscache_unuse_cookie_locked(cookie);\n\tspin_unlock(&cookie->lock);\n}\nEXPORT_SYMBOL(__fscache_unuse_cookie);\n\n \nstatic void fscache_cookie_state_machine(struct fscache_cookie *cookie)\n{\n\tenum fscache_cookie_state state;\n\tbool wake = false;\n\n\t_enter(\"c=%x\", cookie->debug_id);\n\nagain:\n\tspin_lock(&cookie->lock);\nagain_locked:\n\tstate = cookie->state;\n\tswitch (state) {\n\tcase FSCACHE_COOKIE_STATE_QUIESCENT:\n\t\t \n\n\t\tif (atomic_read(&cookie->n_accesses) == 0 &&\n\t\t    test_bit(FSCACHE_COOKIE_DO_RELINQUISH, &cookie->flags)) {\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_RELINQUISHING);\n\t\t\twake = true;\n\t\t\tgoto again_locked;\n\t\t}\n\t\tbreak;\n\n\tcase FSCACHE_COOKIE_STATE_LOOKING_UP:\n\t\tspin_unlock(&cookie->lock);\n\t\tfscache_init_access_gate(cookie);\n\t\tfscache_perform_lookup(cookie);\n\t\tgoto again;\n\n\tcase FSCACHE_COOKIE_STATE_INVALIDATING:\n\t\tspin_unlock(&cookie->lock);\n\t\tfscache_perform_invalidation(cookie);\n\t\tgoto again;\n\n\tcase FSCACHE_COOKIE_STATE_ACTIVE:\n\t\tif (test_and_clear_bit(FSCACHE_COOKIE_DO_PREP_TO_WRITE, &cookie->flags)) {\n\t\t\tspin_unlock(&cookie->lock);\n\t\t\tfscache_prepare_to_write(cookie);\n\t\t\tspin_lock(&cookie->lock);\n\t\t}\n\t\tif (test_bit(FSCACHE_COOKIE_DO_LRU_DISCARD, &cookie->flags)) {\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_LRU_DISCARDING);\n\t\t\twake = true;\n\t\t\tgoto again_locked;\n\t\t}\n\t\tfallthrough;\n\n\tcase FSCACHE_COOKIE_STATE_FAILED:\n\t\tif (test_and_clear_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags))\n\t\t\tfscache_end_cookie_access(cookie, fscache_access_invalidate_cookie_end);\n\n\t\tif (atomic_read(&cookie->n_accesses) != 0)\n\t\t\tbreak;\n\t\tif (test_bit(FSCACHE_COOKIE_DO_RELINQUISH, &cookie->flags)) {\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_RELINQUISHING);\n\t\t\twake = true;\n\t\t\tgoto again_locked;\n\t\t}\n\t\tif (test_bit(FSCACHE_COOKIE_DO_WITHDRAW, &cookie->flags)) {\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_WITHDRAWING);\n\t\t\twake = true;\n\t\t\tgoto again_locked;\n\t\t}\n\t\tbreak;\n\n\tcase FSCACHE_COOKIE_STATE_LRU_DISCARDING:\n\tcase FSCACHE_COOKIE_STATE_RELINQUISHING:\n\tcase FSCACHE_COOKIE_STATE_WITHDRAWING:\n\t\tif (cookie->cache_priv) {\n\t\t\tspin_unlock(&cookie->lock);\n\t\t\tcookie->volume->cache->ops->withdraw_cookie(cookie);\n\t\t\tspin_lock(&cookie->lock);\n\t\t}\n\n\t\tif (test_and_clear_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags))\n\t\t\tfscache_end_cookie_access(cookie, fscache_access_invalidate_cookie_end);\n\n\t\tswitch (state) {\n\t\tcase FSCACHE_COOKIE_STATE_RELINQUISHING:\n\t\t\tfscache_see_cookie(cookie, fscache_cookie_see_relinquish);\n\t\t\tfscache_unhash_cookie(cookie);\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_DROPPED);\n\t\t\twake = true;\n\t\t\tgoto out;\n\t\tcase FSCACHE_COOKIE_STATE_LRU_DISCARDING:\n\t\t\tfscache_see_cookie(cookie, fscache_cookie_see_lru_discard);\n\t\t\tbreak;\n\t\tcase FSCACHE_COOKIE_STATE_WITHDRAWING:\n\t\t\tfscache_see_cookie(cookie, fscache_cookie_see_withdraw);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_bit(FSCACHE_COOKIE_NEEDS_UPDATE, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_DO_WITHDRAW, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_DO_LRU_DISCARD, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_DO_PREP_TO_WRITE, &cookie->flags);\n\t\tset_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &cookie->flags);\n\t\t__fscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_QUIESCENT);\n\t\twake = true;\n\t\tgoto again_locked;\n\n\tcase FSCACHE_COOKIE_STATE_DROPPED:\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ONCE(1, \"Cookie %x in unexpected state %u\\n\",\n\t\t\t  cookie->debug_id, state);\n\t\tbreak;\n\t}\n\nout:\n\tspin_unlock(&cookie->lock);\n\tif (wake)\n\t\twake_up_cookie_state(cookie);\n\t_leave(\"\");\n}\n\nstatic void fscache_cookie_worker(struct work_struct *work)\n{\n\tstruct fscache_cookie *cookie = container_of(work, struct fscache_cookie, work);\n\n\tfscache_see_cookie(cookie, fscache_cookie_see_work);\n\tfscache_cookie_state_machine(cookie);\n\tfscache_put_cookie(cookie, fscache_cookie_put_work);\n}\n\n \nstatic void __fscache_withdraw_cookie(struct fscache_cookie *cookie)\n{\n\tint n_accesses;\n\tbool unpinned;\n\n\tunpinned = test_and_clear_bit(FSCACHE_COOKIE_NO_ACCESS_WAKE, &cookie->flags);\n\n\t \n\tn_accesses = atomic_read(&cookie->n_accesses);\n\tif (unpinned)\n\t\ttrace_fscache_access(cookie->debug_id, refcount_read(&cookie->ref),\n\t\t\t\t     n_accesses, fscache_access_cache_unpin);\n\tif (n_accesses == 0)\n\t\tfscache_queue_cookie(cookie, fscache_cookie_get_end_access);\n}\n\nstatic void fscache_cookie_lru_do_one(struct fscache_cookie *cookie)\n{\n\tfscache_see_cookie(cookie, fscache_cookie_see_lru_do_one);\n\n\tspin_lock(&cookie->lock);\n\tif (cookie->state != FSCACHE_COOKIE_STATE_ACTIVE ||\n\t    time_before(jiffies, cookie->unused_at + fscache_lru_cookie_timeout) ||\n\t    atomic_read(&cookie->n_active) > 0) {\n\t\tspin_unlock(&cookie->lock);\n\t\tfscache_stat(&fscache_n_cookies_lru_removed);\n\t} else {\n\t\tset_bit(FSCACHE_COOKIE_DO_LRU_DISCARD, &cookie->flags);\n\t\tspin_unlock(&cookie->lock);\n\t\tfscache_stat(&fscache_n_cookies_lru_expired);\n\t\t_debug(\"lru c=%x\", cookie->debug_id);\n\t\t__fscache_withdraw_cookie(cookie);\n\t}\n\n\tfscache_put_cookie(cookie, fscache_cookie_put_lru);\n}\n\nstatic void fscache_cookie_lru_worker(struct work_struct *work)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned long unused_at;\n\n\tspin_lock(&fscache_cookie_lru_lock);\n\n\twhile (!list_empty(&fscache_cookie_lru)) {\n\t\tcookie = list_first_entry(&fscache_cookie_lru,\n\t\t\t\t\t  struct fscache_cookie, commit_link);\n\t\tunused_at = cookie->unused_at + fscache_lru_cookie_timeout;\n\t\tif (time_before(jiffies, unused_at)) {\n\t\t\ttimer_reduce(&fscache_cookie_lru_timer, unused_at);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_del_init(&cookie->commit_link);\n\t\tfscache_stat_d(&fscache_n_cookies_lru);\n\t\tspin_unlock(&fscache_cookie_lru_lock);\n\t\tfscache_cookie_lru_do_one(cookie);\n\t\tspin_lock(&fscache_cookie_lru_lock);\n\t}\n\n\tspin_unlock(&fscache_cookie_lru_lock);\n}\n\nstatic void fscache_cookie_lru_timed_out(struct timer_list *timer)\n{\n\tqueue_work(fscache_wq, &fscache_cookie_lru_work);\n}\n\nstatic void fscache_cookie_drop_from_lru(struct fscache_cookie *cookie)\n{\n\tbool need_put = false;\n\n\tif (!list_empty(&cookie->commit_link)) {\n\t\tspin_lock(&fscache_cookie_lru_lock);\n\t\tif (!list_empty(&cookie->commit_link)) {\n\t\t\tlist_del_init(&cookie->commit_link);\n\t\t\tfscache_stat_d(&fscache_n_cookies_lru);\n\t\t\tfscache_stat(&fscache_n_cookies_lru_dropped);\n\t\t\tneed_put = true;\n\t\t}\n\t\tspin_unlock(&fscache_cookie_lru_lock);\n\t\tif (need_put)\n\t\t\tfscache_put_cookie(cookie, fscache_cookie_put_lru);\n\t}\n}\n\n \nstatic void fscache_unhash_cookie(struct fscache_cookie *cookie)\n{\n\tstruct hlist_bl_head *h;\n\tunsigned int bucket;\n\n\tbucket = cookie->key_hash & (ARRAY_SIZE(fscache_cookie_hash) - 1);\n\th = &fscache_cookie_hash[bucket];\n\n\thlist_bl_lock(h);\n\thlist_bl_del(&cookie->hash_link);\n\tclear_bit(FSCACHE_COOKIE_IS_HASHED, &cookie->flags);\n\thlist_bl_unlock(h);\n\tfscache_stat(&fscache_n_relinquishes_dropped);\n}\n\nstatic void fscache_drop_withdraw_cookie(struct fscache_cookie *cookie)\n{\n\tfscache_cookie_drop_from_lru(cookie);\n\t__fscache_withdraw_cookie(cookie);\n}\n\n \nvoid fscache_withdraw_cookie(struct fscache_cookie *cookie)\n{\n\tset_bit(FSCACHE_COOKIE_DO_WITHDRAW, &cookie->flags);\n\tfscache_drop_withdraw_cookie(cookie);\n}\nEXPORT_SYMBOL(fscache_withdraw_cookie);\n\n \nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\t_enter(\"c=%08x{%d},%d\",\n\t       cookie->debug_id, atomic_read(&cookie->n_active), retire);\n\n\tif (WARN(test_and_set_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags),\n\t\t \"Cookie c=%x already relinquished\\n\", cookie->debug_id))\n\t\treturn;\n\n\tif (retire)\n\t\tset_bit(FSCACHE_COOKIE_RETIRED, &cookie->flags);\n\ttrace_fscache_relinquish(cookie, retire);\n\n\tASSERTCMP(atomic_read(&cookie->n_active), ==, 0);\n\tASSERTCMP(atomic_read(&cookie->volume->n_cookies), >, 0);\n\tatomic_dec(&cookie->volume->n_cookies);\n\n\tif (test_bit(FSCACHE_COOKIE_HAS_BEEN_CACHED, &cookie->flags)) {\n\t\tset_bit(FSCACHE_COOKIE_DO_RELINQUISH, &cookie->flags);\n\t\tfscache_drop_withdraw_cookie(cookie);\n\t} else {\n\t\tfscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_DROPPED);\n\t\tfscache_unhash_cookie(cookie);\n\t}\n\tfscache_put_cookie(cookie, fscache_cookie_put_relinquish);\n}\nEXPORT_SYMBOL(__fscache_relinquish_cookie);\n\n \nvoid fscache_put_cookie(struct fscache_cookie *cookie,\n\t\t\tenum fscache_cookie_trace where)\n{\n\tstruct fscache_volume *volume = cookie->volume;\n\tunsigned int cookie_debug_id = cookie->debug_id;\n\tbool zero;\n\tint ref;\n\n\tzero = __refcount_dec_and_test(&cookie->ref, &ref);\n\ttrace_fscache_cookie(cookie_debug_id, ref - 1, where);\n\tif (zero) {\n\t\tfscache_free_cookie(cookie);\n\t\tfscache_put_volume(volume, fscache_volume_put_cookie);\n\t}\n}\nEXPORT_SYMBOL(fscache_put_cookie);\n\n \nstruct fscache_cookie *fscache_get_cookie(struct fscache_cookie *cookie,\n\t\t\t\t\t  enum fscache_cookie_trace where)\n{\n\tint ref;\n\n\t__refcount_inc(&cookie->ref, &ref);\n\ttrace_fscache_cookie(cookie->debug_id, ref + 1, where);\n\treturn cookie;\n}\nEXPORT_SYMBOL(fscache_get_cookie);\n\n \nstatic void fscache_perform_invalidation(struct fscache_cookie *cookie)\n{\n\tif (!cookie->volume->cache->ops->invalidate_cookie(cookie))\n\t\tfscache_caching_failed(cookie);\n\tfscache_end_cookie_access(cookie, fscache_access_invalidate_cookie_end);\n}\n\n \nvoid __fscache_invalidate(struct fscache_cookie *cookie,\n\t\t\t  const void *aux_data, loff_t new_size,\n\t\t\t  unsigned int flags)\n{\n\tbool is_caching;\n\n\t_enter(\"c=%x\", cookie->debug_id);\n\n\tfscache_stat(&fscache_n_invalidates);\n\n\tif (WARN(test_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags),\n\t\t \"Trying to invalidate relinquished cookie\\n\"))\n\t\treturn;\n\n\tif ((flags & FSCACHE_INVAL_DIO_WRITE) &&\n\t    test_and_set_bit(FSCACHE_COOKIE_DISABLED, &cookie->flags))\n\t\treturn;\n\n\tspin_lock(&cookie->lock);\n\tset_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &cookie->flags);\n\tfscache_update_aux(cookie, aux_data, &new_size);\n\tcookie->inval_counter++;\n\ttrace_fscache_invalidate(cookie, new_size);\n\n\tswitch (cookie->state) {\n\tcase FSCACHE_COOKIE_STATE_INVALIDATING:  \n\tdefault:\n\t\tspin_unlock(&cookie->lock);\n\t\t_leave(\" [no %u]\", cookie->state);\n\t\treturn;\n\n\tcase FSCACHE_COOKIE_STATE_LOOKING_UP:\n\t\tif (!test_and_set_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags))\n\t\t\t__fscache_begin_cookie_access(cookie, fscache_access_invalidate_cookie);\n\t\tfallthrough;\n\tcase FSCACHE_COOKIE_STATE_CREATING:\n\t\tspin_unlock(&cookie->lock);\n\t\t_leave(\" [look %x]\", cookie->inval_counter);\n\t\treturn;\n\n\tcase FSCACHE_COOKIE_STATE_ACTIVE:\n\t\tis_caching = fscache_begin_cookie_access(\n\t\t\tcookie, fscache_access_invalidate_cookie);\n\t\tif (is_caching)\n\t\t\t__fscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_INVALIDATING);\n\t\tspin_unlock(&cookie->lock);\n\t\twake_up_cookie_state(cookie);\n\n\t\tif (is_caching)\n\t\t\tfscache_queue_cookie(cookie, fscache_cookie_get_inval_work);\n\t\t_leave(\" [inv]\");\n\t\treturn;\n\t}\n}\nEXPORT_SYMBOL(__fscache_invalidate);\n\n#ifdef CONFIG_PROC_FS\n \nstatic int fscache_cookies_seq_show(struct seq_file *m, void *v)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned int keylen = 0, auxlen = 0;\n\tu8 *p;\n\n\tif (v == &fscache_cookies) {\n\t\tseq_puts(m,\n\t\t\t \"COOKIE   VOLUME   REF ACT ACC S FL DEF             \\n\"\n\t\t\t \"======== ======== === === === = == ================\\n\"\n\t\t\t );\n\t\treturn 0;\n\t}\n\n\tcookie = list_entry(v, struct fscache_cookie, proc_link);\n\n\tseq_printf(m,\n\t\t   \"%08x %08x %3d %3d %3d %c %02lx\",\n\t\t   cookie->debug_id,\n\t\t   cookie->volume->debug_id,\n\t\t   refcount_read(&cookie->ref),\n\t\t   atomic_read(&cookie->n_active),\n\t\t   atomic_read(&cookie->n_accesses),\n\t\t   fscache_cookie_states[cookie->state],\n\t\t   cookie->flags);\n\n\tkeylen = cookie->key_len;\n\tauxlen = cookie->aux_len;\n\n\tif (keylen > 0 || auxlen > 0) {\n\t\tseq_puts(m, \" \");\n\t\tp = keylen <= sizeof(cookie->inline_key) ?\n\t\t\tcookie->inline_key : cookie->key;\n\t\tfor (; keylen > 0; keylen--)\n\t\t\tseq_printf(m, \"%02x\", *p++);\n\t\tif (auxlen > 0) {\n\t\t\tseq_puts(m, \", \");\n\t\t\tp = auxlen <= sizeof(cookie->inline_aux) ?\n\t\t\t\tcookie->inline_aux : cookie->aux;\n\t\t\tfor (; auxlen > 0; auxlen--)\n\t\t\t\tseq_printf(m, \"%02x\", *p++);\n\t\t}\n\t}\n\n\tseq_puts(m, \"\\n\");\n\treturn 0;\n}\n\nstatic void *fscache_cookies_seq_start(struct seq_file *m, loff_t *_pos)\n\t__acquires(fscache_cookies_lock)\n{\n\tread_lock(&fscache_cookies_lock);\n\treturn seq_list_start_head(&fscache_cookies, *_pos);\n}\n\nstatic void *fscache_cookies_seq_next(struct seq_file *m, void *v, loff_t *_pos)\n{\n\treturn seq_list_next(v, &fscache_cookies, _pos);\n}\n\nstatic void fscache_cookies_seq_stop(struct seq_file *m, void *v)\n\t__releases(rcu)\n{\n\tread_unlock(&fscache_cookies_lock);\n}\n\n\nconst struct seq_operations fscache_cookies_seq_ops = {\n\t.start  = fscache_cookies_seq_start,\n\t.next   = fscache_cookies_seq_next,\n\t.stop   = fscache_cookies_seq_stop,\n\t.show   = fscache_cookies_seq_show,\n};\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}