{
  "module_name": "cache.c",
  "hash_id": "1e5f81da005db084a094648d08da5a5472131bfb40c8967ca9b6117287400932",
  "original_prompt": "Ingested from linux-6.6.14/fs/fscache/cache.c",
  "human_readable_source": "\n \n\n#define FSCACHE_DEBUG_LEVEL CACHE\n#include <linux/export.h>\n#include <linux/slab.h>\n#include \"internal.h\"\n\nstatic LIST_HEAD(fscache_caches);\nDECLARE_RWSEM(fscache_addremove_sem);\nEXPORT_SYMBOL(fscache_addremove_sem);\nDECLARE_WAIT_QUEUE_HEAD(fscache_clearance_waiters);\nEXPORT_SYMBOL(fscache_clearance_waiters);\n\nstatic atomic_t fscache_cache_debug_id;\n\n \nstatic struct fscache_cache *fscache_alloc_cache(const char *name)\n{\n\tstruct fscache_cache *cache;\n\n\tcache = kzalloc(sizeof(*cache), GFP_KERNEL);\n\tif (cache) {\n\t\tif (name) {\n\t\t\tcache->name = kstrdup(name, GFP_KERNEL);\n\t\t\tif (!cache->name) {\n\t\t\t\tkfree(cache);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\trefcount_set(&cache->ref, 1);\n\t\tINIT_LIST_HEAD(&cache->cache_link);\n\t\tcache->debug_id = atomic_inc_return(&fscache_cache_debug_id);\n\t}\n\treturn cache;\n}\n\nstatic bool fscache_get_cache_maybe(struct fscache_cache *cache,\n\t\t\t\t    enum fscache_cache_trace where)\n{\n\tbool success;\n\tint ref;\n\n\tsuccess = __refcount_inc_not_zero(&cache->ref, &ref);\n\tif (success)\n\t\ttrace_fscache_cache(cache->debug_id, ref + 1, where);\n\treturn success;\n}\n\n \nstruct fscache_cache *fscache_lookup_cache(const char *name, bool is_cache)\n{\n\tstruct fscache_cache *candidate, *cache, *unnamed = NULL;\n\n\t \n\tdown_read(&fscache_addremove_sem);\n\n\tlist_for_each_entry(cache, &fscache_caches, cache_link) {\n\t\tif (cache->name && name && strcmp(cache->name, name) == 0 &&\n\t\t    fscache_get_cache_maybe(cache, fscache_cache_get_acquire))\n\t\t\tgoto got_cache_r;\n\t\tif (!cache->name && !name &&\n\t\t    fscache_get_cache_maybe(cache, fscache_cache_get_acquire))\n\t\t\tgoto got_cache_r;\n\t}\n\n\tif (!name) {\n\t\tlist_for_each_entry(cache, &fscache_caches, cache_link) {\n\t\t\tif (cache->name &&\n\t\t\t    fscache_get_cache_maybe(cache, fscache_cache_get_acquire))\n\t\t\t\tgoto got_cache_r;\n\t\t}\n\t}\n\n\tup_read(&fscache_addremove_sem);\n\n\t \n\tcandidate = fscache_alloc_cache(name);\n\tif (!candidate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tdown_write(&fscache_addremove_sem);\n\n\tlist_for_each_entry(cache, &fscache_caches, cache_link) {\n\t\tif (cache->name && name && strcmp(cache->name, name) == 0 &&\n\t\t    fscache_get_cache_maybe(cache, fscache_cache_get_acquire))\n\t\t\tgoto got_cache_w;\n\t\tif (!cache->name) {\n\t\t\tunnamed = cache;\n\t\t\tif (!name &&\n\t\t\t    fscache_get_cache_maybe(cache, fscache_cache_get_acquire))\n\t\t\t\tgoto got_cache_w;\n\t\t}\n\t}\n\n\tif (unnamed && is_cache &&\n\t    fscache_get_cache_maybe(unnamed, fscache_cache_get_acquire))\n\t\tgoto use_unnamed_cache;\n\n\tif (!name) {\n\t\tlist_for_each_entry(cache, &fscache_caches, cache_link) {\n\t\t\tif (cache->name &&\n\t\t\t    fscache_get_cache_maybe(cache, fscache_cache_get_acquire))\n\t\t\t\tgoto got_cache_w;\n\t\t}\n\t}\n\n\tlist_add_tail(&candidate->cache_link, &fscache_caches);\n\ttrace_fscache_cache(candidate->debug_id,\n\t\t\t    refcount_read(&candidate->ref),\n\t\t\t    fscache_cache_new_acquire);\n\tup_write(&fscache_addremove_sem);\n\treturn candidate;\n\ngot_cache_r:\n\tup_read(&fscache_addremove_sem);\n\treturn cache;\nuse_unnamed_cache:\n\tcache = unnamed;\n\tcache->name = candidate->name;\n\tcandidate->name = NULL;\ngot_cache_w:\n\tup_write(&fscache_addremove_sem);\n\tkfree(candidate->name);\n\tkfree(candidate);\n\treturn cache;\n}\n\n \nstruct fscache_cache *fscache_acquire_cache(const char *name)\n{\n\tstruct fscache_cache *cache;\n\n\tASSERT(name);\n\tcache = fscache_lookup_cache(name, true);\n\tif (IS_ERR(cache))\n\t\treturn cache;\n\n\tif (!fscache_set_cache_state_maybe(cache,\n\t\t\t\t\t   FSCACHE_CACHE_IS_NOT_PRESENT,\n\t\t\t\t\t   FSCACHE_CACHE_IS_PREPARING)) {\n\t\tpr_warn(\"Cache tag %s in use\\n\", name);\n\t\tfscache_put_cache(cache, fscache_cache_put_cache);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\treturn cache;\n}\nEXPORT_SYMBOL(fscache_acquire_cache);\n\n \nvoid fscache_put_cache(struct fscache_cache *cache,\n\t\t       enum fscache_cache_trace where)\n{\n\tunsigned int debug_id = cache->debug_id;\n\tbool zero;\n\tint ref;\n\n\tif (IS_ERR_OR_NULL(cache))\n\t\treturn;\n\n\tzero = __refcount_dec_and_test(&cache->ref, &ref);\n\ttrace_fscache_cache(debug_id, ref - 1, where);\n\n\tif (zero) {\n\t\tdown_write(&fscache_addremove_sem);\n\t\tlist_del_init(&cache->cache_link);\n\t\tup_write(&fscache_addremove_sem);\n\t\tkfree(cache->name);\n\t\tkfree(cache);\n\t}\n}\n\n \nvoid fscache_relinquish_cache(struct fscache_cache *cache)\n{\n\tenum fscache_cache_trace where =\n\t\t(cache->state == FSCACHE_CACHE_IS_PREPARING) ?\n\t\tfscache_cache_put_prep_failed :\n\t\tfscache_cache_put_relinquish;\n\n\tcache->ops = NULL;\n\tcache->cache_priv = NULL;\n\tfscache_set_cache_state(cache, FSCACHE_CACHE_IS_NOT_PRESENT);\n\tfscache_put_cache(cache, where);\n}\nEXPORT_SYMBOL(fscache_relinquish_cache);\n\n \nint fscache_add_cache(struct fscache_cache *cache,\n\t\t      const struct fscache_cache_ops *ops,\n\t\t      void *cache_priv)\n{\n\tint n_accesses;\n\n\t_enter(\"{%s,%s}\", ops->name, cache->name);\n\n\tBUG_ON(fscache_cache_state(cache) != FSCACHE_CACHE_IS_PREPARING);\n\n\t \n\tn_accesses = atomic_inc_return(&cache->n_accesses);\n\ttrace_fscache_access_cache(cache->debug_id, refcount_read(&cache->ref),\n\t\t\t\t   n_accesses, fscache_access_cache_pin);\n\n\tdown_write(&fscache_addremove_sem);\n\n\tcache->ops = ops;\n\tcache->cache_priv = cache_priv;\n\tfscache_set_cache_state(cache, FSCACHE_CACHE_IS_ACTIVE);\n\n\tup_write(&fscache_addremove_sem);\n\tpr_notice(\"Cache \\\"%s\\\" added (type %s)\\n\", cache->name, ops->name);\n\t_leave(\" = 0 [%s]\", cache->name);\n\treturn 0;\n}\nEXPORT_SYMBOL(fscache_add_cache);\n\n \nbool fscache_begin_cache_access(struct fscache_cache *cache, enum fscache_access_trace why)\n{\n\tint n_accesses;\n\n\tif (!fscache_cache_is_live(cache))\n\t\treturn false;\n\n\tn_accesses = atomic_inc_return(&cache->n_accesses);\n\tsmp_mb__after_atomic();  \n\ttrace_fscache_access_cache(cache->debug_id, refcount_read(&cache->ref),\n\t\t\t\t   n_accesses, why);\n\tif (!fscache_cache_is_live(cache)) {\n\t\tfscache_end_cache_access(cache, fscache_access_unlive);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nvoid fscache_end_cache_access(struct fscache_cache *cache, enum fscache_access_trace why)\n{\n\tint n_accesses;\n\n\tsmp_mb__before_atomic();\n\tn_accesses = atomic_dec_return(&cache->n_accesses);\n\ttrace_fscache_access_cache(cache->debug_id, refcount_read(&cache->ref),\n\t\t\t\t   n_accesses, why);\n\tif (n_accesses == 0)\n\t\twake_up_var(&cache->n_accesses);\n}\n\n \nvoid fscache_io_error(struct fscache_cache *cache)\n{\n\tif (fscache_set_cache_state_maybe(cache,\n\t\t\t\t\t  FSCACHE_CACHE_IS_ACTIVE,\n\t\t\t\t\t  FSCACHE_CACHE_GOT_IOERROR))\n\t\tpr_err(\"Cache '%s' stopped due to I/O error\\n\",\n\t\t       cache->name);\n}\nEXPORT_SYMBOL(fscache_io_error);\n\n \nvoid fscache_withdraw_cache(struct fscache_cache *cache)\n{\n\tint n_accesses;\n\n\tpr_notice(\"Withdrawing cache \\\"%s\\\" (%u objs)\\n\",\n\t\t  cache->name, atomic_read(&cache->object_count));\n\n\tfscache_set_cache_state(cache, FSCACHE_CACHE_IS_WITHDRAWN);\n\n\t \n\tn_accesses = atomic_dec_return(&cache->n_accesses);\n\ttrace_fscache_access_cache(cache->debug_id, refcount_read(&cache->ref),\n\t\t\t\t   n_accesses, fscache_access_cache_unpin);\n\n\twait_var_event(&cache->n_accesses,\n\t\t       atomic_read(&cache->n_accesses) == 0);\n}\nEXPORT_SYMBOL(fscache_withdraw_cache);\n\n#ifdef CONFIG_PROC_FS\nstatic const char fscache_cache_states[NR__FSCACHE_CACHE_STATE] = \"-PAEW\";\n\n \nstatic int fscache_caches_seq_show(struct seq_file *m, void *v)\n{\n\tstruct fscache_cache *cache;\n\n\tif (v == &fscache_caches) {\n\t\tseq_puts(m,\n\t\t\t \"CACHE    REF   VOLS  OBJS  ACCES S NAME\\n\"\n\t\t\t \"======== ===== ===== ===== ===== = ===============\\n\"\n\t\t\t );\n\t\treturn 0;\n\t}\n\n\tcache = list_entry(v, struct fscache_cache, cache_link);\n\tseq_printf(m,\n\t\t   \"%08x %5d %5d %5d %5d %c %s\\n\",\n\t\t   cache->debug_id,\n\t\t   refcount_read(&cache->ref),\n\t\t   atomic_read(&cache->n_volumes),\n\t\t   atomic_read(&cache->object_count),\n\t\t   atomic_read(&cache->n_accesses),\n\t\t   fscache_cache_states[cache->state],\n\t\t   cache->name ?: \"-\");\n\treturn 0;\n}\n\nstatic void *fscache_caches_seq_start(struct seq_file *m, loff_t *_pos)\n\t__acquires(fscache_addremove_sem)\n{\n\tdown_read(&fscache_addremove_sem);\n\treturn seq_list_start_head(&fscache_caches, *_pos);\n}\n\nstatic void *fscache_caches_seq_next(struct seq_file *m, void *v, loff_t *_pos)\n{\n\treturn seq_list_next(v, &fscache_caches, _pos);\n}\n\nstatic void fscache_caches_seq_stop(struct seq_file *m, void *v)\n\t__releases(fscache_addremove_sem)\n{\n\tup_read(&fscache_addremove_sem);\n}\n\nconst struct seq_operations fscache_caches_seq_ops = {\n\t.start  = fscache_caches_seq_start,\n\t.next   = fscache_caches_seq_next,\n\t.stop   = fscache_caches_seq_stop,\n\t.show   = fscache_caches_seq_show,\n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}