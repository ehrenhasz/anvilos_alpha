{
  "module_name": "io.c",
  "hash_id": "c8bfcbf18aebfe8a9d39ad5a13c83d66976c25d60969f323e5ae7ea340bfd8d6",
  "original_prompt": "Ingested from linux-6.6.14/fs/fscache/io.c",
  "human_readable_source": "\n \n#define FSCACHE_DEBUG_LEVEL OPERATION\n#include <linux/fscache-cache.h>\n#include <linux/uio.h>\n#include <linux/bvec.h>\n#include <linux/slab.h>\n#include <linux/uio.h>\n#include \"internal.h\"\n\n \nbool fscache_wait_for_operation(struct netfs_cache_resources *cres,\n\t\t\t\tenum fscache_want_state want_state)\n{\n\tstruct fscache_cookie *cookie = fscache_cres_cookie(cres);\n\tenum fscache_cookie_state state;\n\nagain:\n\tif (!fscache_cache_is_live(cookie->volume->cache)) {\n\t\t_leave(\" [broken]\");\n\t\treturn false;\n\t}\n\n\tstate = fscache_cookie_state(cookie);\n\t_enter(\"c=%08x{%u},%x\", cookie->debug_id, state, want_state);\n\n\tswitch (state) {\n\tcase FSCACHE_COOKIE_STATE_CREATING:\n\tcase FSCACHE_COOKIE_STATE_INVALIDATING:\n\t\tif (want_state == FSCACHE_WANT_PARAMS)\n\t\t\tgoto ready;  \n\t\tfallthrough;\n\tcase FSCACHE_COOKIE_STATE_LOOKING_UP:\n\tcase FSCACHE_COOKIE_STATE_LRU_DISCARDING:\n\t\twait_var_event(&cookie->state,\n\t\t\t       fscache_cookie_state(cookie) != state);\n\t\tgoto again;\n\n\tcase FSCACHE_COOKIE_STATE_ACTIVE:\n\t\tgoto ready;\n\tcase FSCACHE_COOKIE_STATE_DROPPED:\n\tcase FSCACHE_COOKIE_STATE_RELINQUISHING:\n\tdefault:\n\t\t_leave(\" [not live]\");\n\t\treturn false;\n\t}\n\nready:\n\tif (!cres->cache_priv2)\n\t\treturn cookie->volume->cache->ops->begin_operation(cres, want_state);\n\treturn true;\n}\nEXPORT_SYMBOL(fscache_wait_for_operation);\n\n \nstatic int fscache_begin_operation(struct netfs_cache_resources *cres,\n\t\t\t\t   struct fscache_cookie *cookie,\n\t\t\t\t   enum fscache_want_state want_state,\n\t\t\t\t   enum fscache_access_trace why)\n{\n\tenum fscache_cookie_state state;\n\tlong timeo;\n\tbool once_only = false;\n\n\tcres->ops\t\t= NULL;\n\tcres->cache_priv\t= cookie;\n\tcres->cache_priv2\t= NULL;\n\tcres->debug_id\t\t= cookie->debug_id;\n\tcres->inval_counter\t= cookie->inval_counter;\n\n\tif (!fscache_begin_cookie_access(cookie, why))\n\t\treturn -ENOBUFS;\n\nagain:\n\tspin_lock(&cookie->lock);\n\n\tstate = fscache_cookie_state(cookie);\n\t_enter(\"c=%08x{%u},%x\", cookie->debug_id, state, want_state);\n\n\tswitch (state) {\n\tcase FSCACHE_COOKIE_STATE_LOOKING_UP:\n\tcase FSCACHE_COOKIE_STATE_LRU_DISCARDING:\n\tcase FSCACHE_COOKIE_STATE_INVALIDATING:\n\t\tgoto wait_for_file_wrangling;\n\tcase FSCACHE_COOKIE_STATE_CREATING:\n\t\tif (want_state == FSCACHE_WANT_PARAMS)\n\t\t\tgoto ready;  \n\t\tgoto wait_for_file_wrangling;\n\tcase FSCACHE_COOKIE_STATE_ACTIVE:\n\t\tgoto ready;\n\tcase FSCACHE_COOKIE_STATE_DROPPED:\n\tcase FSCACHE_COOKIE_STATE_RELINQUISHING:\n\t\tWARN(1, \"Can't use cookie in state %u\\n\", cookie->state);\n\t\tgoto not_live;\n\tdefault:\n\t\tgoto not_live;\n\t}\n\nready:\n\tspin_unlock(&cookie->lock);\n\tif (!cookie->volume->cache->ops->begin_operation(cres, want_state))\n\t\tgoto failed;\n\treturn 0;\n\nwait_for_file_wrangling:\n\tspin_unlock(&cookie->lock);\n\ttrace_fscache_access(cookie->debug_id, refcount_read(&cookie->ref),\n\t\t\t     atomic_read(&cookie->n_accesses),\n\t\t\t     fscache_access_io_wait);\n\ttimeo = wait_var_event_timeout(&cookie->state,\n\t\t\t\t       fscache_cookie_state(cookie) != state, 20 * HZ);\n\tif (timeo <= 1 && !once_only) {\n\t\tpr_warn(\"%s: cookie state change wait timed out: cookie->state=%u state=%u\",\n\t\t\t__func__, fscache_cookie_state(cookie), state);\n\t\tfscache_print_cookie(cookie, 'O');\n\t\tonce_only = true;\n\t}\n\tgoto again;\n\nnot_live:\n\tspin_unlock(&cookie->lock);\nfailed:\n\tcres->cache_priv = NULL;\n\tcres->ops = NULL;\n\tfscache_end_cookie_access(cookie, fscache_access_io_not_live);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}\n\nint __fscache_begin_read_operation(struct netfs_cache_resources *cres,\n\t\t\t\t   struct fscache_cookie *cookie)\n{\n\treturn fscache_begin_operation(cres, cookie, FSCACHE_WANT_PARAMS,\n\t\t\t\t       fscache_access_io_read);\n}\nEXPORT_SYMBOL(__fscache_begin_read_operation);\n\nint __fscache_begin_write_operation(struct netfs_cache_resources *cres,\n\t\t\t\t    struct fscache_cookie *cookie)\n{\n\treturn fscache_begin_operation(cres, cookie, FSCACHE_WANT_PARAMS,\n\t\t\t\t       fscache_access_io_write);\n}\nEXPORT_SYMBOL(__fscache_begin_write_operation);\n\n \nbool fscache_dirty_folio(struct address_space *mapping, struct folio *folio,\n\t\t\t\tstruct fscache_cookie *cookie)\n{\n\tstruct inode *inode = mapping->host;\n\tbool need_use = false;\n\n\t_enter(\"\");\n\n\tif (!filemap_dirty_folio(mapping, folio))\n\t\treturn false;\n\tif (!fscache_cookie_valid(cookie))\n\t\treturn true;\n\n\tif (!(inode->i_state & I_PINNING_FSCACHE_WB)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif (!(inode->i_state & I_PINNING_FSCACHE_WB)) {\n\t\t\tinode->i_state |= I_PINNING_FSCACHE_WB;\n\t\t\tneed_use = true;\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tif (need_use)\n\t\t\tfscache_use_cookie(cookie, true);\n\t}\n\treturn true;\n}\nEXPORT_SYMBOL(fscache_dirty_folio);\n\nstruct fscache_write_request {\n\tstruct netfs_cache_resources cache_resources;\n\tstruct address_space\t*mapping;\n\tloff_t\t\t\tstart;\n\tsize_t\t\t\tlen;\n\tbool\t\t\tset_bits;\n\tnetfs_io_terminated_t\tterm_func;\n\tvoid\t\t\t*term_func_priv;\n};\n\nvoid __fscache_clear_page_bits(struct address_space *mapping,\n\t\t\t       loff_t start, size_t len)\n{\n\tpgoff_t first = start / PAGE_SIZE;\n\tpgoff_t last = (start + len - 1) / PAGE_SIZE;\n\tstruct page *page;\n\n\tif (len) {\n\t\tXA_STATE(xas, &mapping->i_pages, first);\n\n\t\trcu_read_lock();\n\t\txas_for_each(&xas, page, last) {\n\t\t\tend_page_fscache(page);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n}\nEXPORT_SYMBOL(__fscache_clear_page_bits);\n\n \nstatic void fscache_wreq_done(void *priv, ssize_t transferred_or_error,\n\t\t\t      bool was_async)\n{\n\tstruct fscache_write_request *wreq = priv;\n\n\tfscache_clear_page_bits(wreq->mapping, wreq->start, wreq->len,\n\t\t\t\twreq->set_bits);\n\n\tif (wreq->term_func)\n\t\twreq->term_func(wreq->term_func_priv, transferred_or_error,\n\t\t\t\twas_async);\n\tfscache_end_operation(&wreq->cache_resources);\n\tkfree(wreq);\n}\n\nvoid __fscache_write_to_cache(struct fscache_cookie *cookie,\n\t\t\t      struct address_space *mapping,\n\t\t\t      loff_t start, size_t len, loff_t i_size,\n\t\t\t      netfs_io_terminated_t term_func,\n\t\t\t      void *term_func_priv,\n\t\t\t      bool cond)\n{\n\tstruct fscache_write_request *wreq;\n\tstruct netfs_cache_resources *cres;\n\tstruct iov_iter iter;\n\tint ret = -ENOBUFS;\n\n\tif (len == 0)\n\t\tgoto abandon;\n\n\t_enter(\"%llx,%zx\", start, len);\n\n\twreq = kzalloc(sizeof(struct fscache_write_request), GFP_NOFS);\n\tif (!wreq)\n\t\tgoto abandon;\n\twreq->mapping\t\t= mapping;\n\twreq->start\t\t= start;\n\twreq->len\t\t= len;\n\twreq->set_bits\t\t= cond;\n\twreq->term_func\t\t= term_func;\n\twreq->term_func_priv\t= term_func_priv;\n\n\tcres = &wreq->cache_resources;\n\tif (fscache_begin_operation(cres, cookie, FSCACHE_WANT_WRITE,\n\t\t\t\t    fscache_access_io_write) < 0)\n\t\tgoto abandon_free;\n\n\tret = cres->ops->prepare_write(cres, &start, &len, i_size, false);\n\tif (ret < 0)\n\t\tgoto abandon_end;\n\n\t \n\n\tiov_iter_xarray(&iter, ITER_SOURCE, &mapping->i_pages, start, len);\n\tfscache_write(cres, start, &iter, fscache_wreq_done, wreq);\n\treturn;\n\nabandon_end:\n\treturn fscache_wreq_done(wreq, ret, false);\nabandon_free:\n\tkfree(wreq);\nabandon:\n\tfscache_clear_page_bits(mapping, start, len, cond);\n\tif (term_func)\n\t\tterm_func(term_func_priv, ret, false);\n}\nEXPORT_SYMBOL(__fscache_write_to_cache);\n\n \nvoid __fscache_resize_cookie(struct fscache_cookie *cookie, loff_t new_size)\n{\n\tstruct netfs_cache_resources cres;\n\n\ttrace_fscache_resize(cookie, new_size);\n\tif (fscache_begin_operation(&cres, cookie, FSCACHE_WANT_WRITE,\n\t\t\t\t    fscache_access_io_resize) == 0) {\n\t\tfscache_stat(&fscache_n_resizes);\n\t\tset_bit(FSCACHE_COOKIE_NEEDS_UPDATE, &cookie->flags);\n\n\t\t \n\t\tcookie->volume->cache->ops->resize_cookie(&cres, new_size);\n\t\tfscache_end_operation(&cres);\n\t} else {\n\t\tfscache_stat(&fscache_n_resizes_null);\n\t}\n}\nEXPORT_SYMBOL(__fscache_resize_cookie);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}