{
  "module_name": "libfs.c",
  "hash_id": "cd0ada28518ab62c5ed283167fa404865b6ab4cd02bf3e092d03b39930aabb29",
  "original_prompt": "Ingested from linux-6.6.14/fs/libfs.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/mutex.h>\n#include <linux/namei.h>\n#include <linux/exportfs.h>\n#include <linux/iversion.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>  \n#include <linux/fs_context.h>\n#include <linux/pseudo_fs.h>\n#include <linux/fsnotify.h>\n#include <linux/unicode.h>\n#include <linux/fscrypt.h>\n\n#include <linux/uaccess.h>\n\n#include \"internal.h\"\n\nint simple_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t   struct kstat *stat, u32 request_mask,\n\t\t   unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\tstat->blocks = inode->i_mapping->nrpages << (PAGE_SHIFT - 9);\n\treturn 0;\n}\nEXPORT_SYMBOL(simple_getattr);\n\nint simple_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tbuf->f_type = dentry->d_sb->s_magic;\n\tbuf->f_bsize = PAGE_SIZE;\n\tbuf->f_namelen = NAME_MAX;\n\treturn 0;\n}\nEXPORT_SYMBOL(simple_statfs);\n\n \nint always_delete_dentry(const struct dentry *dentry)\n{\n\treturn 1;\n}\nEXPORT_SYMBOL(always_delete_dentry);\n\nconst struct dentry_operations simple_dentry_operations = {\n\t.d_delete = always_delete_dentry,\n};\nEXPORT_SYMBOL(simple_dentry_operations);\n\n \nstruct dentry *simple_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tif (dentry->d_name.len > NAME_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\tif (!dentry->d_sb->s_d_op)\n\t\td_set_d_op(dentry, &simple_dentry_operations);\n\td_add(dentry, NULL);\n\treturn NULL;\n}\nEXPORT_SYMBOL(simple_lookup);\n\nint dcache_dir_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = d_alloc_cursor(file->f_path.dentry);\n\n\treturn file->private_data ? 0 : -ENOMEM;\n}\nEXPORT_SYMBOL(dcache_dir_open);\n\nint dcache_dir_close(struct inode *inode, struct file *file)\n{\n\tdput(file->private_data);\n\treturn 0;\n}\nEXPORT_SYMBOL(dcache_dir_close);\n\n \n \nstatic struct dentry *scan_positives(struct dentry *cursor,\n\t\t\t\t\tstruct list_head *p,\n\t\t\t\t\tloff_t count,\n\t\t\t\t\tstruct dentry *last)\n{\n\tstruct dentry *dentry = cursor->d_parent, *found = NULL;\n\n\tspin_lock(&dentry->d_lock);\n\twhile ((p = p->next) != &dentry->d_subdirs) {\n\t\tstruct dentry *d = list_entry(p, struct dentry, d_child);\n\t\t\n\t\tif (d->d_flags & DCACHE_DENTRY_CURSOR)\n\t\t\tcontinue;\n\t\tif (simple_positive(d) && !--count) {\n\t\t\tspin_lock_nested(&d->d_lock, DENTRY_D_LOCK_NESTED);\n\t\t\tif (simple_positive(d))\n\t\t\t\tfound = dget_dlock(d);\n\t\t\tspin_unlock(&d->d_lock);\n\t\t\tif (likely(found))\n\t\t\t\tbreak;\n\t\t\tcount = 1;\n\t\t}\n\t\tif (need_resched()) {\n\t\t\tlist_move(&cursor->d_child, p);\n\t\t\tp = &cursor->d_child;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t}\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tdput(last);\n\treturn found;\n}\n\nloff_t dcache_dir_lseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tswitch (whence) {\n\t\tcase 1:\n\t\t\toffset += file->f_pos;\n\t\t\tfallthrough;\n\t\tcase 0:\n\t\t\tif (offset >= 0)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\tif (offset != file->f_pos) {\n\t\tstruct dentry *cursor = file->private_data;\n\t\tstruct dentry *to = NULL;\n\n\t\tinode_lock_shared(dentry->d_inode);\n\n\t\tif (offset > 2)\n\t\t\tto = scan_positives(cursor, &dentry->d_subdirs,\n\t\t\t\t\t    offset - 2, NULL);\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (to)\n\t\t\tlist_move(&cursor->d_child, &to->d_child);\n\t\telse\n\t\t\tlist_del_init(&cursor->d_child);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdput(to);\n\n\t\tfile->f_pos = offset;\n\n\t\tinode_unlock_shared(dentry->d_inode);\n\t}\n\treturn offset;\n}\nEXPORT_SYMBOL(dcache_dir_lseek);\n\n \n\nint dcache_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct dentry *cursor = file->private_data;\n\tstruct list_head *anchor = &dentry->d_subdirs;\n\tstruct dentry *next = NULL;\n\tstruct list_head *p;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\tif (ctx->pos == 2)\n\t\tp = anchor;\n\telse if (!list_empty(&cursor->d_child))\n\t\tp = &cursor->d_child;\n\telse\n\t\treturn 0;\n\n\twhile ((next = scan_positives(cursor, p, 1, next)) != NULL) {\n\t\tif (!dir_emit(ctx, next->d_name.name, next->d_name.len,\n\t\t\t      d_inode(next)->i_ino,\n\t\t\t      fs_umode_to_dtype(d_inode(next)->i_mode)))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t\tp = &next->d_child;\n\t}\n\tspin_lock(&dentry->d_lock);\n\tif (next)\n\t\tlist_move_tail(&cursor->d_child, &next->d_child);\n\telse\n\t\tlist_del_init(&cursor->d_child);\n\tspin_unlock(&dentry->d_lock);\n\tdput(next);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dcache_readdir);\n\nssize_t generic_read_dir(struct file *filp, char __user *buf, size_t siz, loff_t *ppos)\n{\n\treturn -EISDIR;\n}\nEXPORT_SYMBOL(generic_read_dir);\n\nconst struct file_operations simple_dir_operations = {\n\t.open\t\t= dcache_dir_open,\n\t.release\t= dcache_dir_close,\n\t.llseek\t\t= dcache_dir_lseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= dcache_readdir,\n\t.fsync\t\t= noop_fsync,\n};\nEXPORT_SYMBOL(simple_dir_operations);\n\nconst struct inode_operations simple_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n};\nEXPORT_SYMBOL(simple_dir_inode_operations);\n\nstatic void offset_set(struct dentry *dentry, u32 offset)\n{\n\tdentry->d_fsdata = (void *)((uintptr_t)(offset));\n}\n\nstatic u32 dentry2offset(struct dentry *dentry)\n{\n\treturn (u32)((uintptr_t)(dentry->d_fsdata));\n}\n\nstatic struct lock_class_key simple_offset_xa_lock;\n\n \nvoid simple_offset_init(struct offset_ctx *octx)\n{\n\txa_init_flags(&octx->xa, XA_FLAGS_ALLOC1);\n\tlockdep_set_class(&octx->xa.xa_lock, &simple_offset_xa_lock);\n\n\t \n\toctx->next_offset = 2;\n}\n\n \nint simple_offset_add(struct offset_ctx *octx, struct dentry *dentry)\n{\n\tstatic const struct xa_limit limit = XA_LIMIT(2, U32_MAX);\n\tu32 offset;\n\tint ret;\n\n\tif (dentry2offset(dentry) != 0)\n\t\treturn -EBUSY;\n\n\tret = xa_alloc_cyclic(&octx->xa, &offset, dentry, limit,\n\t\t\t      &octx->next_offset, GFP_KERNEL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\toffset_set(dentry, offset);\n\treturn 0;\n}\n\n \nvoid simple_offset_remove(struct offset_ctx *octx, struct dentry *dentry)\n{\n\tu32 offset;\n\n\toffset = dentry2offset(dentry);\n\tif (offset == 0)\n\t\treturn;\n\n\txa_erase(&octx->xa, offset);\n\toffset_set(dentry, 0);\n}\n\n \nint simple_offset_rename_exchange(struct inode *old_dir,\n\t\t\t\t  struct dentry *old_dentry,\n\t\t\t\t  struct inode *new_dir,\n\t\t\t\t  struct dentry *new_dentry)\n{\n\tstruct offset_ctx *old_ctx = old_dir->i_op->get_offset_ctx(old_dir);\n\tstruct offset_ctx *new_ctx = new_dir->i_op->get_offset_ctx(new_dir);\n\tu32 old_index = dentry2offset(old_dentry);\n\tu32 new_index = dentry2offset(new_dentry);\n\tint ret;\n\n\tsimple_offset_remove(old_ctx, old_dentry);\n\tsimple_offset_remove(new_ctx, new_dentry);\n\n\tret = simple_offset_add(new_ctx, old_dentry);\n\tif (ret)\n\t\tgoto out_restore;\n\n\tret = simple_offset_add(old_ctx, new_dentry);\n\tif (ret) {\n\t\tsimple_offset_remove(new_ctx, old_dentry);\n\t\tgoto out_restore;\n\t}\n\n\tret = simple_rename_exchange(old_dir, old_dentry, new_dir, new_dentry);\n\tif (ret) {\n\t\tsimple_offset_remove(new_ctx, old_dentry);\n\t\tsimple_offset_remove(old_ctx, new_dentry);\n\t\tgoto out_restore;\n\t}\n\treturn 0;\n\nout_restore:\n\toffset_set(old_dentry, old_index);\n\txa_store(&old_ctx->xa, old_index, old_dentry, GFP_KERNEL);\n\toffset_set(new_dentry, new_index);\n\txa_store(&new_ctx->xa, new_index, new_dentry, GFP_KERNEL);\n\treturn ret;\n}\n\n \nvoid simple_offset_destroy(struct offset_ctx *octx)\n{\n\txa_destroy(&octx->xa);\n}\n\n \nstatic loff_t offset_dir_llseek(struct file *file, loff_t offset, int whence)\n{\n\tswitch (whence) {\n\tcase SEEK_CUR:\n\t\toffset += file->f_pos;\n\t\tfallthrough;\n\tcase SEEK_SET:\n\t\tif (offset >= 0)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfile->private_data = NULL;\n\treturn vfs_setpos(file, offset, U32_MAX);\n}\n\nstatic struct dentry *offset_find_next(struct xa_state *xas)\n{\n\tstruct dentry *child, *found = NULL;\n\n\trcu_read_lock();\n\tchild = xas_next_entry(xas, U32_MAX);\n\tif (!child)\n\t\tgoto out;\n\tspin_lock(&child->d_lock);\n\tif (simple_positive(child))\n\t\tfound = dget_dlock(child);\n\tspin_unlock(&child->d_lock);\nout:\n\trcu_read_unlock();\n\treturn found;\n}\n\nstatic bool offset_dir_emit(struct dir_context *ctx, struct dentry *dentry)\n{\n\tu32 offset = dentry2offset(dentry);\n\tstruct inode *inode = d_inode(dentry);\n\n\treturn ctx->actor(ctx, dentry->d_name.name, dentry->d_name.len, offset,\n\t\t\t  inode->i_ino, fs_umode_to_dtype(inode->i_mode));\n}\n\nstatic void *offset_iterate_dir(struct inode *inode, struct dir_context *ctx)\n{\n\tstruct offset_ctx *so_ctx = inode->i_op->get_offset_ctx(inode);\n\tXA_STATE(xas, &so_ctx->xa, ctx->pos);\n\tstruct dentry *dentry;\n\n\twhile (true) {\n\t\tdentry = offset_find_next(&xas);\n\t\tif (!dentry)\n\t\t\treturn ERR_PTR(-ENOENT);\n\n\t\tif (!offset_dir_emit(ctx, dentry)) {\n\t\t\tdput(dentry);\n\t\t\tbreak;\n\t\t}\n\n\t\tdput(dentry);\n\t\tctx->pos = xas.xa_index + 1;\n\t}\n\treturn NULL;\n}\n\n \nstatic int offset_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dentry *dir = file->f_path.dentry;\n\n\tlockdep_assert_held(&d_inode(dir)->i_rwsem);\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\t \n\tif (ctx->pos == 2)\n\t\tfile->private_data = NULL;\n\telse if (file->private_data == ERR_PTR(-ENOENT))\n\t\treturn 0;\n\tfile->private_data = offset_iterate_dir(d_inode(dir), ctx);\n\treturn 0;\n}\n\nconst struct file_operations simple_offset_dir_operations = {\n\t.llseek\t\t= offset_dir_llseek,\n\t.iterate_shared\t= offset_readdir,\n\t.read\t\t= generic_read_dir,\n\t.fsync\t\t= noop_fsync,\n};\n\nstatic struct dentry *find_next_child(struct dentry *parent, struct dentry *prev)\n{\n\tstruct dentry *child = NULL;\n\tstruct list_head *p = prev ? &prev->d_child : &parent->d_subdirs;\n\n\tspin_lock(&parent->d_lock);\n\twhile ((p = p->next) != &parent->d_subdirs) {\n\t\tstruct dentry *d = container_of(p, struct dentry, d_child);\n\t\tif (simple_positive(d)) {\n\t\t\tspin_lock_nested(&d->d_lock, DENTRY_D_LOCK_NESTED);\n\t\t\tif (simple_positive(d))\n\t\t\t\tchild = dget_dlock(d);\n\t\t\tspin_unlock(&d->d_lock);\n\t\t\tif (likely(child))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&parent->d_lock);\n\tdput(prev);\n\treturn child;\n}\n\nvoid simple_recursive_removal(struct dentry *dentry,\n                              void (*callback)(struct dentry *))\n{\n\tstruct dentry *this = dget(dentry);\n\twhile (true) {\n\t\tstruct dentry *victim = NULL, *child;\n\t\tstruct inode *inode = this->d_inode;\n\n\t\tinode_lock(inode);\n\t\tif (d_is_dir(this))\n\t\t\tinode->i_flags |= S_DEAD;\n\t\twhile ((child = find_next_child(this, victim)) == NULL) {\n\t\t\t\n\t\t\t\n\t\t\tinode_set_ctime_current(inode);\n\t\t\tclear_nlink(inode);\n\t\t\tinode_unlock(inode);\n\t\t\tvictim = this;\n\t\t\tthis = this->d_parent;\n\t\t\tinode = this->d_inode;\n\t\t\tinode_lock(inode);\n\t\t\tif (simple_positive(victim)) {\n\t\t\t\td_invalidate(victim);\t\n\t\t\t\tif (d_is_dir(victim))\n\t\t\t\t\tfsnotify_rmdir(inode, victim);\n\t\t\t\telse\n\t\t\t\t\tfsnotify_unlink(inode, victim);\n\t\t\t\tif (callback)\n\t\t\t\t\tcallback(victim);\n\t\t\t\tdput(victim);\t\t\n\t\t\t}\n\t\t\tif (victim == dentry) {\n\t\t\t\tinode_set_mtime_to_ts(inode,\n\t\t\t\t\t\t      inode_set_ctime_current(inode));\n\t\t\t\tif (d_is_dir(dentry))\n\t\t\t\t\tdrop_nlink(inode);\n\t\t\t\tinode_unlock(inode);\n\t\t\t\tdput(dentry);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tinode_unlock(inode);\n\t\tthis = child;\n\t}\n}\nEXPORT_SYMBOL(simple_recursive_removal);\n\nstatic const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};\n\nstatic int pseudo_fs_fill_super(struct super_block *s, struct fs_context *fc)\n{\n\tstruct pseudo_fs_context *ctx = fc->fs_private;\n\tstruct inode *root;\n\n\ts->s_maxbytes = MAX_LFS_FILESIZE;\n\ts->s_blocksize = PAGE_SIZE;\n\ts->s_blocksize_bits = PAGE_SHIFT;\n\ts->s_magic = ctx->magic;\n\ts->s_op = ctx->ops ?: &simple_super_operations;\n\ts->s_xattr = ctx->xattr;\n\ts->s_time_gran = 1;\n\troot = new_inode(s);\n\tif (!root)\n\t\treturn -ENOMEM;\n\n\t \n\troot->i_ino = 1;\n\troot->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;\n\tsimple_inode_init_ts(root);\n\ts->s_root = d_make_root(root);\n\tif (!s->s_root)\n\t\treturn -ENOMEM;\n\ts->s_d_op = ctx->dops;\n\treturn 0;\n}\n\nstatic int pseudo_fs_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_nodev(fc, pseudo_fs_fill_super);\n}\n\nstatic void pseudo_fs_free(struct fs_context *fc)\n{\n\tkfree(fc->fs_private);\n}\n\nstatic const struct fs_context_operations pseudo_fs_context_ops = {\n\t.free\t\t= pseudo_fs_free,\n\t.get_tree\t= pseudo_fs_get_tree,\n};\n\n \nstruct pseudo_fs_context *init_pseudo(struct fs_context *fc,\n\t\t\t\t\tunsigned long magic)\n{\n\tstruct pseudo_fs_context *ctx;\n\n\tctx = kzalloc(sizeof(struct pseudo_fs_context), GFP_KERNEL);\n\tif (likely(ctx)) {\n\t\tctx->magic = magic;\n\t\tfc->fs_private = ctx;\n\t\tfc->ops = &pseudo_fs_context_ops;\n\t\tfc->sb_flags |= SB_NOUSER;\n\t\tfc->global = true;\n\t}\n\treturn ctx;\n}\nEXPORT_SYMBOL(init_pseudo);\n\nint simple_open(struct inode *inode, struct file *file)\n{\n\tif (inode->i_private)\n\t\tfile->private_data = inode->i_private;\n\treturn 0;\n}\nEXPORT_SYMBOL(simple_open);\n\nint simple_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(old_dentry);\n\n\tinode_set_mtime_to_ts(dir,\n\t\t\t      inode_set_ctime_to_ts(dir, inode_set_ctime_current(inode)));\n\tinc_nlink(inode);\n\tihold(inode);\n\tdget(dentry);\n\td_instantiate(dentry, inode);\n\treturn 0;\n}\nEXPORT_SYMBOL(simple_link);\n\nint simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(simple_empty);\n\nint simple_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tinode_set_mtime_to_ts(dir,\n\t\t\t      inode_set_ctime_to_ts(dir, inode_set_ctime_current(inode)));\n\tdrop_nlink(inode);\n\tdput(dentry);\n\treturn 0;\n}\nEXPORT_SYMBOL(simple_unlink);\n\nint simple_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tif (!simple_empty(dentry))\n\t\treturn -ENOTEMPTY;\n\n\tdrop_nlink(d_inode(dentry));\n\tsimple_unlink(dir, dentry);\n\tdrop_nlink(dir);\n\treturn 0;\n}\nEXPORT_SYMBOL(simple_rmdir);\n\n \nvoid simple_rename_timestamp(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct inode *newino = d_inode(new_dentry);\n\n\tinode_set_mtime_to_ts(old_dir, inode_set_ctime_current(old_dir));\n\tif (new_dir != old_dir)\n\t\tinode_set_mtime_to_ts(new_dir,\n\t\t\t\t      inode_set_ctime_current(new_dir));\n\tinode_set_ctime_current(d_inode(old_dentry));\n\tif (newino)\n\t\tinode_set_ctime_current(newino);\n}\nEXPORT_SYMBOL_GPL(simple_rename_timestamp);\n\nint simple_rename_exchange(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t   struct inode *new_dir, struct dentry *new_dentry)\n{\n\tbool old_is_dir = d_is_dir(old_dentry);\n\tbool new_is_dir = d_is_dir(new_dentry);\n\n\tif (old_dir != new_dir && old_is_dir != new_is_dir) {\n\t\tif (old_is_dir) {\n\t\t\tdrop_nlink(old_dir);\n\t\t\tinc_nlink(new_dir);\n\t\t} else {\n\t\t\tdrop_nlink(new_dir);\n\t\t\tinc_nlink(old_dir);\n\t\t}\n\t}\n\tsimple_rename_timestamp(old_dir, old_dentry, new_dir, new_dentry);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(simple_rename_exchange);\n\nint simple_rename(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\t  struct dentry *old_dentry, struct inode *new_dir,\n\t\t  struct dentry *new_dentry, unsigned int flags)\n{\n\tint they_are_dirs = d_is_dir(old_dentry);\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\n\tif (flags & RENAME_EXCHANGE)\n\t\treturn simple_rename_exchange(old_dir, old_dentry, new_dir, new_dentry);\n\n\tif (!simple_empty(new_dentry))\n\t\treturn -ENOTEMPTY;\n\n\tif (d_really_is_positive(new_dentry)) {\n\t\tsimple_unlink(new_dir, new_dentry);\n\t\tif (they_are_dirs) {\n\t\t\tdrop_nlink(d_inode(new_dentry));\n\t\t\tdrop_nlink(old_dir);\n\t\t}\n\t} else if (they_are_dirs) {\n\t\tdrop_nlink(old_dir);\n\t\tinc_nlink(new_dir);\n\t}\n\n\tsimple_rename_timestamp(old_dir, old_dentry, new_dir, new_dentry);\n\treturn 0;\n}\nEXPORT_SYMBOL(simple_rename);\n\n \nint simple_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t   struct iattr *iattr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint error;\n\n\terror = setattr_prepare(idmap, dentry, iattr);\n\tif (error)\n\t\treturn error;\n\n\tif (iattr->ia_valid & ATTR_SIZE)\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\tsetattr_copy(idmap, inode, iattr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}\nEXPORT_SYMBOL(simple_setattr);\n\nstatic int simple_read_folio(struct file *file, struct folio *folio)\n{\n\tfolio_zero_range(folio, 0, folio_size(folio));\n\tflush_dcache_folio(folio);\n\tfolio_mark_uptodate(folio);\n\tfolio_unlock(folio);\n\treturn 0;\n}\n\nint simple_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tstruct folio *folio;\n\n\tfolio = __filemap_get_folio(mapping, pos / PAGE_SIZE, FGP_WRITEBEGIN,\n\t\t\tmapping_gfp_mask(mapping));\n\tif (IS_ERR(folio))\n\t\treturn PTR_ERR(folio);\n\n\t*pagep = &folio->page;\n\n\tif (!folio_test_uptodate(folio) && (len != folio_size(folio))) {\n\t\tsize_t from = offset_in_folio(folio, pos);\n\n\t\tfolio_zero_segments(folio, 0, from,\n\t\t\t\tfrom + len, folio_size(folio));\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(simple_write_begin);\n\n \nstatic int simple_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct folio *folio = page_folio(page);\n\tstruct inode *inode = folio->mapping->host;\n\tloff_t last_pos = pos + copied;\n\n\t \n\tif (!folio_test_uptodate(folio)) {\n\t\tif (copied < len) {\n\t\t\tsize_t from = offset_in_folio(folio, pos);\n\n\t\t\tfolio_zero_range(folio, from + copied, len - copied);\n\t\t}\n\t\tfolio_mark_uptodate(folio);\n\t}\n\t \n\tif (last_pos > inode->i_size)\n\t\ti_size_write(inode, last_pos);\n\n\tfolio_mark_dirty(folio);\n\tfolio_unlock(folio);\n\tfolio_put(folio);\n\n\treturn copied;\n}\n\n \nconst struct address_space_operations ram_aops = {\n\t.read_folio\t= simple_read_folio,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n\t.dirty_folio\t= noop_dirty_folio,\n};\nEXPORT_SYMBOL(ram_aops);\n\n \nint simple_fill_super(struct super_block *s, unsigned long magic,\n\t\t      const struct tree_descr *files)\n{\n\tstruct inode *inode;\n\tstruct dentry *root;\n\tstruct dentry *dentry;\n\tint i;\n\n\ts->s_blocksize = PAGE_SIZE;\n\ts->s_blocksize_bits = PAGE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = &simple_super_operations;\n\ts->s_time_gran = 1;\n\n\tinode = new_inode(s);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\t \n\tinode->i_ino = 1;\n\tinode->i_mode = S_IFDIR | 0755;\n\tsimple_inode_init_ts(inode);\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tset_nlink(inode, 2);\n\troot = d_make_root(inode);\n\tif (!root)\n\t\treturn -ENOMEM;\n\tfor (i = 0; !files->name || files->name[0]; i++, files++) {\n\t\tif (!files->name)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (unlikely(i == 1))\n\t\t\tprintk(KERN_WARNING \"%s: %s passed in a files array\"\n\t\t\t\t\"with an index of 1!\\n\", __func__,\n\t\t\t\ts->s_type->name);\n\n\t\tdentry = d_alloc_name(root, files->name);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\t\tinode = new_inode(s);\n\t\tif (!inode) {\n\t\t\tdput(dentry);\n\t\t\tgoto out;\n\t\t}\n\t\tinode->i_mode = S_IFREG | files->mode;\n\t\tsimple_inode_init_ts(inode);\n\t\tinode->i_fop = files->ops;\n\t\tinode->i_ino = i;\n\t\td_add(dentry, inode);\n\t}\n\ts->s_root = root;\n\treturn 0;\nout:\n\td_genocide(root);\n\tshrink_dcache_parent(root);\n\tdput(root);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(simple_fill_super);\n\nstatic DEFINE_SPINLOCK(pin_fs_lock);\n\nint simple_pin_fs(struct file_system_type *type, struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt = NULL;\n\tspin_lock(&pin_fs_lock);\n\tif (unlikely(!*mount)) {\n\t\tspin_unlock(&pin_fs_lock);\n\t\tmnt = vfs_kern_mount(type, SB_KERNMOUNT, type->name, NULL);\n\t\tif (IS_ERR(mnt))\n\t\t\treturn PTR_ERR(mnt);\n\t\tspin_lock(&pin_fs_lock);\n\t\tif (!*mount)\n\t\t\t*mount = mnt;\n\t}\n\tmntget(*mount);\n\t++*count;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n\treturn 0;\n}\nEXPORT_SYMBOL(simple_pin_fs);\n\nvoid simple_release_fs(struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt;\n\tspin_lock(&pin_fs_lock);\n\tmnt = *mount;\n\tif (!--*count)\n\t\t*mount = NULL;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n}\nEXPORT_SYMBOL(simple_release_fs);\n\n \nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}\nEXPORT_SYMBOL(simple_read_from_buffer);\n\n \nssize_t simple_write_to_buffer(void *to, size_t available, loff_t *ppos,\n\t\tconst void __user *from, size_t count)\n{\n\tloff_t pos = *ppos;\n\tsize_t res;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tres = copy_from_user(to + pos, from, count);\n\tif (res == count)\n\t\treturn -EFAULT;\n\tcount -= res;\n\t*ppos = pos + count;\n\treturn count;\n}\nEXPORT_SYMBOL(simple_write_to_buffer);\n\n \nssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tmemcpy(to, from + pos, count);\n\t*ppos = pos + count;\n\n\treturn count;\n}\nEXPORT_SYMBOL(memory_read_from_buffer);\n\n \n\nvoid simple_transaction_set(struct file *file, size_t n)\n{\n\tstruct simple_transaction_argresp *ar = file->private_data;\n\n\tBUG_ON(n > SIMPLE_TRANSACTION_LIMIT);\n\n\t \n\tsmp_mb();\n\tar->size = n;\n}\nEXPORT_SYMBOL(simple_transaction_set);\n\nchar *simple_transaction_get(struct file *file, const char __user *buf, size_t size)\n{\n\tstruct simple_transaction_argresp *ar;\n\tstatic DEFINE_SPINLOCK(simple_transaction_lock);\n\n\tif (size > SIMPLE_TRANSACTION_LIMIT - 1)\n\t\treturn ERR_PTR(-EFBIG);\n\n\tar = (struct simple_transaction_argresp *)get_zeroed_page(GFP_KERNEL);\n\tif (!ar)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock(&simple_transaction_lock);\n\n\t \n\tif (file->private_data) {\n\t\tspin_unlock(&simple_transaction_lock);\n\t\tfree_page((unsigned long)ar);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tfile->private_data = ar;\n\n\tspin_unlock(&simple_transaction_lock);\n\n\tif (copy_from_user(ar->data, buf, size))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn ar->data;\n}\nEXPORT_SYMBOL(simple_transaction_get);\n\nssize_t simple_transaction_read(struct file *file, char __user *buf, size_t size, loff_t *pos)\n{\n\tstruct simple_transaction_argresp *ar = file->private_data;\n\n\tif (!ar)\n\t\treturn 0;\n\treturn simple_read_from_buffer(buf, size, pos, ar->data, ar->size);\n}\nEXPORT_SYMBOL(simple_transaction_read);\n\nint simple_transaction_release(struct inode *inode, struct file *file)\n{\n\tfree_page((unsigned long)file->private_data);\n\treturn 0;\n}\nEXPORT_SYMBOL(simple_transaction_release);\n\n \n\nstruct simple_attr {\n\tint (*get)(void *, u64 *);\n\tint (*set)(void *, u64);\n\tchar get_buf[24];\t \n\tchar set_buf[24];\n\tvoid *data;\n\tconst char *fmt;\t \n\tstruct mutex mutex;\t \n};\n\n \nint simple_attr_open(struct inode *inode, struct file *file,\n\t\t     int (*get)(void *, u64 *), int (*set)(void *, u64),\n\t\t     const char *fmt)\n{\n\tstruct simple_attr *attr;\n\n\tattr = kzalloc(sizeof(*attr), GFP_KERNEL);\n\tif (!attr)\n\t\treturn -ENOMEM;\n\n\tattr->get = get;\n\tattr->set = set;\n\tattr->data = inode->i_private;\n\tattr->fmt = fmt;\n\tmutex_init(&attr->mutex);\n\n\tfile->private_data = attr;\n\n\treturn nonseekable_open(inode, file);\n}\nEXPORT_SYMBOL_GPL(simple_attr_open);\n\nint simple_attr_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(simple_attr_release);\t \n\n \nssize_t simple_attr_read(struct file *file, char __user *buf,\n\t\t\t size_t len, loff_t *ppos)\n{\n\tstruct simple_attr *attr;\n\tsize_t size;\n\tssize_t ret;\n\n\tattr = file->private_data;\n\n\tif (!attr->get)\n\t\treturn -EACCES;\n\n\tret = mutex_lock_interruptible(&attr->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tif (*ppos && attr->get_buf[0]) {\n\t\t \n\t\tsize = strlen(attr->get_buf);\n\t} else {\n\t\t \n\t\tu64 val;\n\t\tret = attr->get(attr->data, &val);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tsize = scnprintf(attr->get_buf, sizeof(attr->get_buf),\n\t\t\t\t attr->fmt, (unsigned long long)val);\n\t}\n\n\tret = simple_read_from_buffer(buf, len, ppos, attr->get_buf, size);\nout:\n\tmutex_unlock(&attr->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(simple_attr_read);\n\n \nstatic ssize_t simple_attr_write_xsigned(struct file *file, const char __user *buf,\n\t\t\t  size_t len, loff_t *ppos, bool is_signed)\n{\n\tstruct simple_attr *attr;\n\tunsigned long long val;\n\tsize_t size;\n\tssize_t ret;\n\n\tattr = file->private_data;\n\tif (!attr->set)\n\t\treturn -EACCES;\n\n\tret = mutex_lock_interruptible(&attr->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tsize = min(sizeof(attr->set_buf) - 1, len);\n\tif (copy_from_user(attr->set_buf, buf, size))\n\t\tgoto out;\n\n\tattr->set_buf[size] = '\\0';\n\tif (is_signed)\n\t\tret = kstrtoll(attr->set_buf, 0, &val);\n\telse\n\t\tret = kstrtoull(attr->set_buf, 0, &val);\n\tif (ret)\n\t\tgoto out;\n\tret = attr->set(attr->data, val);\n\tif (ret == 0)\n\t\tret = len;  \nout:\n\tmutex_unlock(&attr->mutex);\n\treturn ret;\n}\n\nssize_t simple_attr_write(struct file *file, const char __user *buf,\n\t\t\t  size_t len, loff_t *ppos)\n{\n\treturn simple_attr_write_xsigned(file, buf, len, ppos, false);\n}\nEXPORT_SYMBOL_GPL(simple_attr_write);\n\nssize_t simple_attr_write_signed(struct file *file, const char __user *buf,\n\t\t\t  size_t len, loff_t *ppos)\n{\n\treturn simple_attr_write_xsigned(file, buf, len, ppos, true);\n}\nEXPORT_SYMBOL_GPL(simple_attr_write_signed);\n\n \nstruct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}\nEXPORT_SYMBOL_GPL(generic_fh_to_dentry);\n\n \nstruct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}\nEXPORT_SYMBOL_GPL(generic_fh_to_parent);\n\n \nint __generic_file_fsync(struct file *file, loff_t start, loff_t end,\n\t\t\t\t int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint err;\n\tint ret;\n\n\terr = file_write_and_wait_range(file, start, end);\n\tif (err)\n\t\treturn err;\n\n\tinode_lock(inode);\n\tret = sync_mapping_buffers(inode->i_mapping);\n\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\tgoto out;\n\tif (datasync && !(inode->i_state & I_DIRTY_DATASYNC))\n\t\tgoto out;\n\n\terr = sync_inode_metadata(inode, 1);\n\tif (ret == 0)\n\t\tret = err;\n\nout:\n\tinode_unlock(inode);\n\t \n\terr = file_check_and_advance_wb_err(file);\n\tif (ret == 0)\n\t\tret = err;\n\treturn ret;\n}\nEXPORT_SYMBOL(__generic_file_fsync);\n\n \n\nint generic_file_fsync(struct file *file, loff_t start, loff_t end,\n\t\t       int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint err;\n\n\terr = __generic_file_fsync(file, start, end, datasync);\n\tif (err)\n\t\treturn err;\n\treturn blkdev_issue_flush(inode->i_sb->s_bdev);\n}\nEXPORT_SYMBOL(generic_file_fsync);\n\n \nint generic_check_addressable(unsigned blocksize_bits, u64 num_blocks)\n{\n\tu64 last_fs_block = num_blocks - 1;\n\tu64 last_fs_page =\n\t\tlast_fs_block >> (PAGE_SHIFT - blocksize_bits);\n\n\tif (unlikely(num_blocks == 0))\n\t\treturn 0;\n\n\tif ((blocksize_bits < 9) || (blocksize_bits > PAGE_SHIFT))\n\t\treturn -EINVAL;\n\n\tif ((last_fs_block > (sector_t)(~0ULL) >> (blocksize_bits - 9)) ||\n\t    (last_fs_page > (pgoff_t)(~0ULL))) {\n\t\treturn -EFBIG;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(generic_check_addressable);\n\n \nint noop_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL(noop_fsync);\n\nssize_t noop_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\t \n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(noop_direct_IO);\n\n \nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}\nEXPORT_SYMBOL(kfree_link);\n\nstruct inode *alloc_anon_inode(struct super_block *s)\n{\n\tstatic const struct address_space_operations anon_aops = {\n\t\t.dirty_folio\t= noop_dirty_folio,\n\t};\n\tstruct inode *inode = new_inode_pseudo(s);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mapping->a_ops = &anon_aops;\n\n\t \n\tinode->i_state = I_DIRTY;\n\tinode->i_mode = S_IRUSR | S_IWUSR;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_flags |= S_PRIVATE;\n\tsimple_inode_init_ts(inode);\n\treturn inode;\n}\nEXPORT_SYMBOL(alloc_anon_inode);\n\n \nint\nsimple_nosetlease(struct file *filp, int arg, struct file_lock **flp,\n\t\t  void **priv)\n{\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(simple_nosetlease);\n\n \nconst char *simple_get_link(struct dentry *dentry, struct inode *inode,\n\t\t\t    struct delayed_call *done)\n{\n\treturn inode->i_link;\n}\nEXPORT_SYMBOL(simple_get_link);\n\nconst struct inode_operations simple_symlink_inode_operations = {\n\t.get_link = simple_get_link,\n};\nEXPORT_SYMBOL(simple_symlink_inode_operations);\n\n \nstatic struct dentry *empty_dir_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic int empty_dir_getattr(struct mnt_idmap *idmap,\n\t\t\t     const struct path *path, struct kstat *stat,\n\t\t\t     u32 request_mask, unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\treturn 0;\n}\n\nstatic int empty_dir_setattr(struct mnt_idmap *idmap,\n\t\t\t     struct dentry *dentry, struct iattr *attr)\n{\n\treturn -EPERM;\n}\n\nstatic ssize_t empty_dir_listxattr(struct dentry *dentry, char *list, size_t size)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct inode_operations empty_dir_inode_operations = {\n\t.lookup\t\t= empty_dir_lookup,\n\t.permission\t= generic_permission,\n\t.setattr\t= empty_dir_setattr,\n\t.getattr\t= empty_dir_getattr,\n\t.listxattr\t= empty_dir_listxattr,\n};\n\nstatic loff_t empty_dir_llseek(struct file *file, loff_t offset, int whence)\n{\n\t \n\treturn generic_file_llseek_size(file, offset, whence, 2, 2);\n}\n\nstatic int empty_dir_readdir(struct file *file, struct dir_context *ctx)\n{\n\tdir_emit_dots(file, ctx);\n\treturn 0;\n}\n\nstatic const struct file_operations empty_dir_operations = {\n\t.llseek\t\t= empty_dir_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= empty_dir_readdir,\n\t.fsync\t\t= noop_fsync,\n};\n\n\nvoid make_empty_dir_inode(struct inode *inode)\n{\n\tset_nlink(inode, 2);\n\tinode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\tinode->i_uid = GLOBAL_ROOT_UID;\n\tinode->i_gid = GLOBAL_ROOT_GID;\n\tinode->i_rdev = 0;\n\tinode->i_size = 0;\n\tinode->i_blkbits = PAGE_SHIFT;\n\tinode->i_blocks = 0;\n\n\tinode->i_op = &empty_dir_inode_operations;\n\tinode->i_opflags &= ~IOP_XATTR;\n\tinode->i_fop = &empty_dir_operations;\n}\n\nbool is_empty_dir_inode(struct inode *inode)\n{\n\treturn (inode->i_fop == &empty_dir_operations) &&\n\t\t(inode->i_op == &empty_dir_inode_operations);\n}\n\n#if IS_ENABLED(CONFIG_UNICODE)\n \nstatic int generic_ci_d_compare(const struct dentry *dentry, unsigned int len,\n\t\t\t\tconst char *str, const struct qstr *name)\n{\n\tconst struct dentry *parent = READ_ONCE(dentry->d_parent);\n\tconst struct inode *dir = READ_ONCE(parent->d_inode);\n\tconst struct super_block *sb = dentry->d_sb;\n\tconst struct unicode_map *um = sb->s_encoding;\n\tstruct qstr qstr = QSTR_INIT(str, len);\n\tchar strbuf[DNAME_INLINE_LEN];\n\tint ret;\n\n\tif (!dir || !IS_CASEFOLDED(dir))\n\t\tgoto fallback;\n\t \n\tif (len <= DNAME_INLINE_LEN - 1) {\n\t\tmemcpy(strbuf, str, len);\n\t\tstrbuf[len] = 0;\n\t\tqstr.name = strbuf;\n\t\t \n\t\tbarrier();\n\t}\n\tret = utf8_strncasecmp(um, name, &qstr);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\tif (sb_has_strict_encoding(sb))\n\t\treturn -EINVAL;\nfallback:\n\tif (len != name->len)\n\t\treturn 1;\n\treturn !!memcmp(str, name->name, len);\n}\n\n \nstatic int generic_ci_d_hash(const struct dentry *dentry, struct qstr *str)\n{\n\tconst struct inode *dir = READ_ONCE(dentry->d_inode);\n\tstruct super_block *sb = dentry->d_sb;\n\tconst struct unicode_map *um = sb->s_encoding;\n\tint ret = 0;\n\n\tif (!dir || !IS_CASEFOLDED(dir))\n\t\treturn 0;\n\n\tret = utf8_casefold_hash(um, dentry, str);\n\tif (ret < 0 && sb_has_strict_encoding(sb))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic const struct dentry_operations generic_ci_dentry_ops = {\n\t.d_hash = generic_ci_d_hash,\n\t.d_compare = generic_ci_d_compare,\n};\n#endif\n\n#ifdef CONFIG_FS_ENCRYPTION\nstatic const struct dentry_operations generic_encrypted_dentry_ops = {\n\t.d_revalidate = fscrypt_d_revalidate,\n};\n#endif\n\n#if defined(CONFIG_FS_ENCRYPTION) && IS_ENABLED(CONFIG_UNICODE)\nstatic const struct dentry_operations generic_encrypted_ci_dentry_ops = {\n\t.d_hash = generic_ci_d_hash,\n\t.d_compare = generic_ci_d_compare,\n\t.d_revalidate = fscrypt_d_revalidate,\n};\n#endif\n\n \nvoid generic_set_encrypted_ci_d_ops(struct dentry *dentry)\n{\n#ifdef CONFIG_FS_ENCRYPTION\n\tbool needs_encrypt_ops = dentry->d_flags & DCACHE_NOKEY_NAME;\n#endif\n#if IS_ENABLED(CONFIG_UNICODE)\n\tbool needs_ci_ops = dentry->d_sb->s_encoding;\n#endif\n#if defined(CONFIG_FS_ENCRYPTION) && IS_ENABLED(CONFIG_UNICODE)\n\tif (needs_encrypt_ops && needs_ci_ops) {\n\t\td_set_d_op(dentry, &generic_encrypted_ci_dentry_ops);\n\t\treturn;\n\t}\n#endif\n#ifdef CONFIG_FS_ENCRYPTION\n\tif (needs_encrypt_ops) {\n\t\td_set_d_op(dentry, &generic_encrypted_dentry_ops);\n\t\treturn;\n\t}\n#endif\n#if IS_ENABLED(CONFIG_UNICODE)\n\tif (needs_ci_ops) {\n\t\td_set_d_op(dentry, &generic_ci_dentry_ops);\n\t\treturn;\n\t}\n#endif\n}\nEXPORT_SYMBOL(generic_set_encrypted_ci_d_ops);\n\n \nbool inode_maybe_inc_iversion(struct inode *inode, bool force)\n{\n\tu64 cur, new;\n\n\t \n\tsmp_mb();\n\tcur = inode_peek_iversion_raw(inode);\n\tdo {\n\t\t \n\t\tif (!force && !(cur & I_VERSION_QUERIED))\n\t\t\treturn false;\n\n\t\t \n\t\tnew = (cur & ~I_VERSION_QUERIED) + I_VERSION_INCREMENT;\n\t} while (!atomic64_try_cmpxchg(&inode->i_version, &cur, new));\n\treturn true;\n}\nEXPORT_SYMBOL(inode_maybe_inc_iversion);\n\n \nu64 inode_query_iversion(struct inode *inode)\n{\n\tu64 cur, new;\n\n\tcur = inode_peek_iversion_raw(inode);\n\tdo {\n\t\t \n\t\tif (cur & I_VERSION_QUERIED) {\n\t\t\t \n\t\t\tsmp_mb();\n\t\t\tbreak;\n\t\t}\n\n\t\tnew = cur | I_VERSION_QUERIED;\n\t} while (!atomic64_try_cmpxchg(&inode->i_version, &cur, new));\n\treturn cur >> I_VERSION_QUERIED_SHIFT;\n}\nEXPORT_SYMBOL(inode_query_iversion);\n\nssize_t direct_write_fallback(struct kiocb *iocb, struct iov_iter *iter,\n\t\tssize_t direct_written, ssize_t buffered_written)\n{\n\tstruct address_space *mapping = iocb->ki_filp->f_mapping;\n\tloff_t pos = iocb->ki_pos - buffered_written;\n\tloff_t end = iocb->ki_pos - 1;\n\tint err;\n\n\t \n\tif (unlikely(buffered_written < 0)) {\n\t\tif (direct_written)\n\t\t\treturn direct_written;\n\t\treturn buffered_written;\n\t}\n\n\t \n\terr = filemap_write_and_wait_range(mapping, pos, end);\n\tif (err < 0) {\n\t\t \n\t\tiocb->ki_pos -= buffered_written;\n\t\tif (direct_written)\n\t\t\treturn direct_written;\n\t\treturn err;\n\t}\n\tinvalidate_mapping_pages(mapping, pos >> PAGE_SHIFT, end >> PAGE_SHIFT);\n\treturn direct_written + buffered_written;\n}\nEXPORT_SYMBOL_GPL(direct_write_fallback);\n\n \nstruct timespec64 simple_inode_init_ts(struct inode *inode)\n{\n\tstruct timespec64 ts = inode_set_ctime_current(inode);\n\n\tinode_set_atime_to_ts(inode, ts);\n\tinode_set_mtime_to_ts(inode, ts);\n\treturn ts;\n}\nEXPORT_SYMBOL(simple_inode_init_ts);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}