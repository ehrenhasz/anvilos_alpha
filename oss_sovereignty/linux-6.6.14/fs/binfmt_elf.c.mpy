{
  "module_name": "binfmt_elf.c",
  "hash_id": "ac4cdb5b9054ed2f12e370fb61aae413f8741dcb86568df462a5a39b0eb7ad17",
  "original_prompt": "Ingested from linux-6.6.14/fs/binfmt_elf.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/log2.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/binfmts.h>\n#include <linux/string.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/personality.h>\n#include <linux/elfcore.h>\n#include <linux/init.h>\n#include <linux/highuid.h>\n#include <linux/compiler.h>\n#include <linux/highmem.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/random.h>\n#include <linux/elf.h>\n#include <linux/elf-randomize.h>\n#include <linux/utsname.h>\n#include <linux/coredump.h>\n#include <linux/sched.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/cputime.h>\n#include <linux/sizes.h>\n#include <linux/types.h>\n#include <linux/cred.h>\n#include <linux/dax.h>\n#include <linux/uaccess.h>\n#include <linux/rseq.h>\n#include <asm/param.h>\n#include <asm/page.h>\n\n#ifndef ELF_COMPAT\n#define ELF_COMPAT 0\n#endif\n\n#ifndef user_long_t\n#define user_long_t long\n#endif\n#ifndef user_siginfo_t\n#define user_siginfo_t siginfo_t\n#endif\n\n \n#ifndef elf_check_fdpic\n#define elf_check_fdpic(ex) false\n#endif\n\nstatic int load_elf_binary(struct linux_binprm *bprm);\n\n#ifdef CONFIG_USELIB\nstatic int load_elf_library(struct file *);\n#else\n#define load_elf_library NULL\n#endif\n\n \n#ifdef CONFIG_ELF_CORE\nstatic int elf_core_dump(struct coredump_params *cprm);\n#else\n#define elf_core_dump\tNULL\n#endif\n\n#if ELF_EXEC_PAGESIZE > PAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n#else\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#endif\n\n#ifndef ELF_CORE_EFLAGS\n#define ELF_CORE_EFLAGS\t0\n#endif\n\n#define ELF_PAGESTART(_v) ((_v) & ~(int)(ELF_MIN_ALIGN-1))\n#define ELF_PAGEOFFSET(_v) ((_v) & (ELF_MIN_ALIGN-1))\n#define ELF_PAGEALIGN(_v) (((_v) + ELF_MIN_ALIGN - 1) & ~(ELF_MIN_ALIGN - 1))\n\nstatic struct linux_binfmt elf_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_binary,\n\t.load_shlib\t= load_elf_library,\n#ifdef CONFIG_COREDUMP\n\t.core_dump\t= elf_core_dump,\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n#endif\n};\n\n#define BAD_ADDR(x) (unlikely((unsigned long)(x) >= TASK_SIZE))\n\nstatic int set_brk(unsigned long start, unsigned long end, int prot)\n{\n\tstart = ELF_PAGEALIGN(start);\n\tend = ELF_PAGEALIGN(end);\n\tif (end > start) {\n\t\t \n\t\tint error = vm_brk_flags(start, end - start,\n\t\t\t\tprot & PROT_EXEC ? VM_EXEC : 0);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tcurrent->mm->start_brk = current->mm->brk = end;\n\treturn 0;\n}\n\n \nstatic int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n \n#ifdef CONFIG_STACK_GROWSUP\n#define STACK_ADD(sp, items) ((elf_addr_t __user *)(sp) + (items))\n#define STACK_ROUND(sp, items) \\\n\t((15 + (unsigned long) ((sp) + (items))) &~ 15UL)\n#define STACK_ALLOC(sp, len) ({ \\\n\telf_addr_t __user *old_sp = (elf_addr_t __user *)sp; sp += len; \\\n\told_sp; })\n#else\n#define STACK_ADD(sp, items) ((elf_addr_t __user *)(sp) - (items))\n#define STACK_ROUND(sp, items) \\\n\t(((unsigned long) (sp - items)) &~ 15UL)\n#define STACK_ALLOC(sp, len) (sp -= len)\n#endif\n\n#ifndef ELF_BASE_PLATFORM\n \n#define ELF_BASE_PLATFORM NULL\n#endif\n\nstatic int\ncreate_elf_tables(struct linux_binprm *bprm, const struct elfhdr *exec,\n\t\tunsigned long interp_load_addr,\n\t\tunsigned long e_entry, unsigned long phdr_addr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long p = bprm->p;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\telf_addr_t __user *sp;\n\telf_addr_t __user *u_platform;\n\telf_addr_t __user *u_base_platform;\n\telf_addr_t __user *u_rand_bytes;\n\tconst char *k_platform = ELF_PLATFORM;\n\tconst char *k_base_platform = ELF_BASE_PLATFORM;\n\tunsigned char k_rand_bytes[16];\n\tint items;\n\telf_addr_t *elf_info;\n\telf_addr_t flags = 0;\n\tint ei_index;\n\tconst struct cred *cred = current_cred();\n\tstruct vm_area_struct *vma;\n\n\t \n\n\tp = arch_align_stack(p);\n\n\t \n\tu_platform = NULL;\n\tif (k_platform) {\n\t\tsize_t len = strlen(k_platform) + 1;\n\n\t\tu_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (copy_to_user(u_platform, k_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t \n\tu_base_platform = NULL;\n\tif (k_base_platform) {\n\t\tsize_t len = strlen(k_base_platform) + 1;\n\n\t\tu_base_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (copy_to_user(u_base_platform, k_base_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t \n\tget_random_bytes(k_rand_bytes, sizeof(k_rand_bytes));\n\tu_rand_bytes = (elf_addr_t __user *)\n\t\t       STACK_ALLOC(p, sizeof(k_rand_bytes));\n\tif (copy_to_user(u_rand_bytes, k_rand_bytes, sizeof(k_rand_bytes)))\n\t\treturn -EFAULT;\n\n\t \n\telf_info = (elf_addr_t *)mm->saved_auxv;\n\t \n#define NEW_AUX_ENT(id, val) \\\n\tdo { \\\n\t\t*elf_info++ = id; \\\n\t\t*elf_info++ = val; \\\n\t} while (0)\n\n#ifdef ARCH_DLINFO\n\t \n\tARCH_DLINFO;\n#endif\n\tNEW_AUX_ENT(AT_HWCAP, ELF_HWCAP);\n\tNEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE);\n\tNEW_AUX_ENT(AT_CLKTCK, CLOCKS_PER_SEC);\n\tNEW_AUX_ENT(AT_PHDR, phdr_addr);\n\tNEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr));\n\tNEW_AUX_ENT(AT_PHNUM, exec->e_phnum);\n\tNEW_AUX_ENT(AT_BASE, interp_load_addr);\n\tif (bprm->interp_flags & BINPRM_FLAGS_PRESERVE_ARGV0)\n\t\tflags |= AT_FLAGS_PRESERVE_ARGV0;\n\tNEW_AUX_ENT(AT_FLAGS, flags);\n\tNEW_AUX_ENT(AT_ENTRY, e_entry);\n\tNEW_AUX_ENT(AT_UID, from_kuid_munged(cred->user_ns, cred->uid));\n\tNEW_AUX_ENT(AT_EUID, from_kuid_munged(cred->user_ns, cred->euid));\n\tNEW_AUX_ENT(AT_GID, from_kgid_munged(cred->user_ns, cred->gid));\n\tNEW_AUX_ENT(AT_EGID, from_kgid_munged(cred->user_ns, cred->egid));\n\tNEW_AUX_ENT(AT_SECURE, bprm->secureexec);\n\tNEW_AUX_ENT(AT_RANDOM, (elf_addr_t)(unsigned long)u_rand_bytes);\n#ifdef ELF_HWCAP2\n\tNEW_AUX_ENT(AT_HWCAP2, ELF_HWCAP2);\n#endif\n\tNEW_AUX_ENT(AT_EXECFN, bprm->exec);\n\tif (k_platform) {\n\t\tNEW_AUX_ENT(AT_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_platform);\n\t}\n\tif (k_base_platform) {\n\t\tNEW_AUX_ENT(AT_BASE_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_base_platform);\n\t}\n\tif (bprm->have_execfd) {\n\t\tNEW_AUX_ENT(AT_EXECFD, bprm->execfd);\n\t}\n#ifdef CONFIG_RSEQ\n\tNEW_AUX_ENT(AT_RSEQ_FEATURE_SIZE, offsetof(struct rseq, end));\n\tNEW_AUX_ENT(AT_RSEQ_ALIGN, __alignof__(struct rseq));\n#endif\n#undef NEW_AUX_ENT\n\t \n\tmemset(elf_info, 0, (char *)mm->saved_auxv +\n\t\t\tsizeof(mm->saved_auxv) - (char *)elf_info);\n\n\t \n\telf_info += 2;\n\n\tei_index = elf_info - (elf_addr_t *)mm->saved_auxv;\n\tsp = STACK_ADD(p, ei_index);\n\n\titems = (argc + 1) + (envc + 1) + 1;\n\tbprm->p = STACK_ROUND(sp, items);\n\n\t \n#ifdef CONFIG_STACK_GROWSUP\n\tsp = (elf_addr_t __user *)bprm->p - items - ei_index;\n\tbprm->exec = (unsigned long)sp;  \n#else\n\tsp = (elf_addr_t __user *)bprm->p;\n#endif\n\n\n\t \n\tif (mmap_write_lock_killable(mm))\n\t\treturn -EINTR;\n\tvma = find_extend_vma_locked(mm, bprm->p);\n\tmmap_write_unlock(mm);\n\tif (!vma)\n\t\treturn -EFAULT;\n\n\t \n\tif (put_user(argc, sp++))\n\t\treturn -EFAULT;\n\n\t \n\tp = mm->arg_end = mm->arg_start;\n\twhile (argc-- > 0) {\n\t\tsize_t len;\n\t\tif (put_user((elf_addr_t)p, sp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (put_user(0, sp++))\n\t\treturn -EFAULT;\n\tmm->arg_end = p;\n\n\t \n\tmm->env_end = mm->env_start = p;\n\twhile (envc-- > 0) {\n\t\tsize_t len;\n\t\tif (put_user((elf_addr_t)p, sp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (put_user(0, sp++))\n\t\treturn -EFAULT;\n\tmm->env_end = p;\n\n\t \n\tif (copy_to_user(sp, mm->saved_auxv, ei_index * sizeof(elf_addr_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tconst struct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t \n\tif (!size)\n\t\treturn addr;\n\n\t \n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = vm_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tvm_munmap(map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = vm_mmap(filep, addr, size, prot, type, off);\n\n\tif ((type & MAP_FIXED_NOREPLACE) &&\n\t    PTR_ERR((void *)map_addr) == -EEXIST)\n\t\tpr_info(\"%d (%s): Uhuuh, elf segment at %px requested but the memory is mapped already\\n\",\n\t\t\ttask_pid_nr(current), current->comm, (void *)addr);\n\n\treturn(map_addr);\n}\n\nstatic unsigned long total_mapping_size(const struct elf_phdr *phdr, int nr)\n{\n\telf_addr_t min_addr = -1;\n\telf_addr_t max_addr = 0;\n\tbool pt_load = false;\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (phdr[i].p_type == PT_LOAD) {\n\t\t\tmin_addr = min(min_addr, ELF_PAGESTART(phdr[i].p_vaddr));\n\t\t\tmax_addr = max(max_addr, phdr[i].p_vaddr + phdr[i].p_memsz);\n\t\t\tpt_load = true;\n\t\t}\n\t}\n\treturn pt_load ? (max_addr - min_addr) : 0;\n}\n\nstatic int elf_read(struct file *file, void *buf, size_t len, loff_t pos)\n{\n\tssize_t rv;\n\n\trv = kernel_read(file, buf, len, &pos);\n\tif (unlikely(rv != len)) {\n\t\treturn (rv < 0) ? rv : -EIO;\n\t}\n\treturn 0;\n}\n\nstatic unsigned long maximum_alignment(struct elf_phdr *cmds, int nr)\n{\n\tunsigned long alignment = 0;\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (cmds[i].p_type == PT_LOAD) {\n\t\t\tunsigned long p_align = cmds[i].p_align;\n\n\t\t\t \n\t\t\tif (!is_power_of_2(p_align))\n\t\t\t\tcontinue;\n\t\t\talignment = max(alignment, p_align);\n\t\t}\n\t}\n\n\t \n\treturn ELF_PAGEALIGN(alignment);\n}\n\n \nstatic struct elf_phdr *load_elf_phdrs(const struct elfhdr *elf_ex,\n\t\t\t\t       struct file *elf_file)\n{\n\tstruct elf_phdr *elf_phdata = NULL;\n\tint retval = -1;\n\tunsigned int size;\n\n\t \n\tif (elf_ex->e_phentsize != sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t \n\t \n\tsize = sizeof(struct elf_phdr) * elf_ex->e_phnum;\n\tif (size == 0 || size > 65536 || size > ELF_MIN_ALIGN)\n\t\tgoto out;\n\n\telf_phdata = kmalloc(size, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\t \n\tretval = elf_read(elf_file, elf_phdata, size, elf_ex->e_phoff);\n\nout:\n\tif (retval) {\n\t\tkfree(elf_phdata);\n\t\telf_phdata = NULL;\n\t}\n\treturn elf_phdata;\n}\n\n#ifndef CONFIG_ARCH_BINFMT_ELF_STATE\n\n \nstruct arch_elf_state {\n};\n\n#define INIT_ARCH_ELF_STATE {}\n\n \nstatic inline int arch_elf_pt_proc(struct elfhdr *ehdr,\n\t\t\t\t   struct elf_phdr *phdr,\n\t\t\t\t   struct file *elf, bool is_interp,\n\t\t\t\t   struct arch_elf_state *state)\n{\n\t \n\treturn 0;\n}\n\n \nstatic inline int arch_check_elf(struct elfhdr *ehdr, bool has_interp,\n\t\t\t\t struct elfhdr *interp_ehdr,\n\t\t\t\t struct arch_elf_state *state)\n{\n\t \n\treturn 0;\n}\n\n#endif  \n\nstatic inline int make_prot(u32 p_flags, struct arch_elf_state *arch_state,\n\t\t\t    bool has_interp, bool is_interp)\n{\n\tint prot = 0;\n\n\tif (p_flags & PF_R)\n\t\tprot |= PROT_READ;\n\tif (p_flags & PF_W)\n\t\tprot |= PROT_WRITE;\n\tif (p_flags & PF_X)\n\t\tprot |= PROT_EXEC;\n\n\treturn arch_elf_adjust_prot(prot, arch_state, has_interp, is_interp);\n}\n\n \n\nstatic unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n\t\tstruct file *interpreter,\n\t\tunsigned long no_base, struct elf_phdr *interp_elf_phdata,\n\t\tstruct arch_elf_state *arch_state)\n{\n\tstruct elf_phdr *eppnt;\n\tunsigned long load_addr = 0;\n\tint load_addr_set = 0;\n\tunsigned long last_bss = 0, elf_bss = 0;\n\tint bss_prot = 0;\n\tunsigned long error = ~0UL;\n\tunsigned long total_size;\n\tint i;\n\n\t \n\tif (interp_elf_ex->e_type != ET_EXEC &&\n\t    interp_elf_ex->e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(interp_elf_ex) ||\n\t    elf_check_fdpic(interp_elf_ex))\n\t\tgoto out;\n\tif (!interpreter->f_op->mmap)\n\t\tgoto out;\n\n\ttotal_size = total_mapping_size(interp_elf_phdata,\n\t\t\t\t\tinterp_elf_ex->e_phnum);\n\tif (!total_size) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\teppnt = interp_elf_phdata;\n\tfor (i = 0; i < interp_elf_ex->e_phnum; i++, eppnt++) {\n\t\tif (eppnt->p_type == PT_LOAD) {\n\t\t\tint elf_type = MAP_PRIVATE;\n\t\t\tint elf_prot = make_prot(eppnt->p_flags, arch_state,\n\t\t\t\t\t\t true, true);\n\t\t\tunsigned long vaddr = 0;\n\t\t\tunsigned long k, map_addr;\n\n\t\t\tvaddr = eppnt->p_vaddr;\n\t\t\tif (interp_elf_ex->e_type == ET_EXEC || load_addr_set)\n\t\t\t\telf_type |= MAP_FIXED;\n\t\t\telse if (no_base && interp_elf_ex->e_type == ET_DYN)\n\t\t\t\tload_addr = -vaddr;\n\n\t\t\tmap_addr = elf_map(interpreter, load_addr + vaddr,\n\t\t\t\t\teppnt, elf_prot, elf_type, total_size);\n\t\t\ttotal_size = 0;\n\t\t\terror = map_addr;\n\t\t\tif (BAD_ADDR(map_addr))\n\t\t\t\tgoto out;\n\n\t\t\tif (!load_addr_set &&\n\t\t\t    interp_elf_ex->e_type == ET_DYN) {\n\t\t\t\tload_addr = map_addr - ELF_PAGESTART(vaddr);\n\t\t\t\tload_addr_set = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tk = load_addr + eppnt->p_vaddr;\n\t\t\tif (BAD_ADDR(k) ||\n\t\t\t    eppnt->p_filesz > eppnt->p_memsz ||\n\t\t\t    eppnt->p_memsz > TASK_SIZE ||\n\t\t\t    TASK_SIZE - eppnt->p_memsz < k) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_filesz;\n\t\t\tif (k > elf_bss)\n\t\t\t\telf_bss = k;\n\n\t\t\t \n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_memsz;\n\t\t\tif (k > last_bss) {\n\t\t\t\tlast_bss = k;\n\t\t\t\tbss_prot = elf_prot;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (padzero(elf_bss)) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\t \n\telf_bss = ELF_PAGEALIGN(elf_bss);\n\tlast_bss = ELF_PAGEALIGN(last_bss);\n\t \n\tif (last_bss > elf_bss) {\n\t\terror = vm_brk_flags(elf_bss, last_bss - elf_bss,\n\t\t\t\tbss_prot & PROT_EXEC ? VM_EXEC : 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = load_addr;\nout:\n\treturn error;\n}\n\n \n\nstatic int parse_elf_property(const char *data, size_t *off, size_t datasz,\n\t\t\t      struct arch_elf_state *arch,\n\t\t\t      bool have_prev_type, u32 *prev_type)\n{\n\tsize_t o, step;\n\tconst struct gnu_property *pr;\n\tint ret;\n\n\tif (*off == datasz)\n\t\treturn -ENOENT;\n\n\tif (WARN_ON_ONCE(*off > datasz || *off % ELF_GNU_PROPERTY_ALIGN))\n\t\treturn -EIO;\n\to = *off;\n\tdatasz -= *off;\n\n\tif (datasz < sizeof(*pr))\n\t\treturn -ENOEXEC;\n\tpr = (const struct gnu_property *)(data + o);\n\to += sizeof(*pr);\n\tdatasz -= sizeof(*pr);\n\n\tif (pr->pr_datasz > datasz)\n\t\treturn -ENOEXEC;\n\n\tWARN_ON_ONCE(o % ELF_GNU_PROPERTY_ALIGN);\n\tstep = round_up(pr->pr_datasz, ELF_GNU_PROPERTY_ALIGN);\n\tif (step > datasz)\n\t\treturn -ENOEXEC;\n\n\t \n\tif (have_prev_type && pr->pr_type <= *prev_type)\n\t\treturn -ENOEXEC;\n\t*prev_type = pr->pr_type;\n\n\tret = arch_parse_elf_property(pr->pr_type, data + o,\n\t\t\t\t      pr->pr_datasz, ELF_COMPAT, arch);\n\tif (ret)\n\t\treturn ret;\n\n\t*off = o + step;\n\treturn 0;\n}\n\n#define NOTE_DATA_SZ SZ_1K\n#define GNU_PROPERTY_TYPE_0_NAME \"GNU\"\n#define NOTE_NAME_SZ (sizeof(GNU_PROPERTY_TYPE_0_NAME))\n\nstatic int parse_elf_properties(struct file *f, const struct elf_phdr *phdr,\n\t\t\t\tstruct arch_elf_state *arch)\n{\n\tunion {\n\t\tstruct elf_note nhdr;\n\t\tchar data[NOTE_DATA_SZ];\n\t} note;\n\tloff_t pos;\n\tssize_t n;\n\tsize_t off, datasz;\n\tint ret;\n\tbool have_prev_type;\n\tu32 prev_type;\n\n\tif (!IS_ENABLED(CONFIG_ARCH_USE_GNU_PROPERTY) || !phdr)\n\t\treturn 0;\n\n\t \n\tif (WARN_ON_ONCE(phdr->p_type != PT_GNU_PROPERTY))\n\t\treturn -ENOEXEC;\n\n\t \n\tif (phdr->p_filesz > sizeof(note))\n\t\treturn -ENOEXEC;\n\n\tpos = phdr->p_offset;\n\tn = kernel_read(f, &note, phdr->p_filesz, &pos);\n\n\tBUILD_BUG_ON(sizeof(note) < sizeof(note.nhdr) + NOTE_NAME_SZ);\n\tif (n < 0 || n < sizeof(note.nhdr) + NOTE_NAME_SZ)\n\t\treturn -EIO;\n\n\tif (note.nhdr.n_type != NT_GNU_PROPERTY_TYPE_0 ||\n\t    note.nhdr.n_namesz != NOTE_NAME_SZ ||\n\t    strncmp(note.data + sizeof(note.nhdr),\n\t\t    GNU_PROPERTY_TYPE_0_NAME, n - sizeof(note.nhdr)))\n\t\treturn -ENOEXEC;\n\n\toff = round_up(sizeof(note.nhdr) + NOTE_NAME_SZ,\n\t\t       ELF_GNU_PROPERTY_ALIGN);\n\tif (off > n)\n\t\treturn -ENOEXEC;\n\n\tif (note.nhdr.n_descsz > n - off)\n\t\treturn -ENOEXEC;\n\tdatasz = off + note.nhdr.n_descsz;\n\n\thave_prev_type = false;\n\tdo {\n\t\tret = parse_elf_property(note.data, &off, datasz, arch,\n\t\t\t\t\t have_prev_type, &prev_type);\n\t\thave_prev_type = true;\n\t} while (!ret);\n\n\treturn ret == -ENOENT ? 0 : ret;\n}\n\nstatic int load_elf_binary(struct linux_binprm *bprm)\n{\n\tstruct file *interpreter = NULL;  \n\tunsigned long load_bias = 0, phdr_addr = 0;\n\tint first_pt_load = 1;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\n\tstruct elf_phdr *elf_property_phdata = NULL;\n\tunsigned long elf_bss, elf_brk;\n\tint bss_prot = 0;\n\tint retval, i;\n\tunsigned long elf_entry;\n\tunsigned long e_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tstruct elfhdr *elf_ex = (struct elfhdr *)bprm->buf;\n\tstruct elfhdr *interp_elf_ex = NULL;\n\tstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\n\tstruct mm_struct *mm;\n\tstruct pt_regs *regs;\n\n\tretval = -ENOEXEC;\n\t \n\tif (memcmp(elf_ex->e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (elf_ex->e_type != ET_EXEC && elf_ex->e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(elf_ex))\n\t\tgoto out;\n\tif (elf_check_fdpic(elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\telf_phdata = load_elf_phdrs(elf_ex, bprm->file);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < elf_ex->e_phnum; i++, elf_ppnt++) {\n\t\tchar *elf_interpreter;\n\n\t\tif (elf_ppnt->p_type == PT_GNU_PROPERTY) {\n\t\t\telf_property_phdata = elf_ppnt;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (elf_ppnt->p_type != PT_INTERP)\n\t\t\tcontinue;\n\n\t\t \n\t\tretval = -ENOEXEC;\n\t\tif (elf_ppnt->p_filesz > PATH_MAX || elf_ppnt->p_filesz < 2)\n\t\t\tgoto out_free_ph;\n\n\t\tretval = -ENOMEM;\n\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz, GFP_KERNEL);\n\t\tif (!elf_interpreter)\n\t\t\tgoto out_free_ph;\n\n\t\tretval = elf_read(bprm->file, elf_interpreter, elf_ppnt->p_filesz,\n\t\t\t\t  elf_ppnt->p_offset);\n\t\tif (retval < 0)\n\t\t\tgoto out_free_interp;\n\t\t \n\t\tretval = -ENOEXEC;\n\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\tgoto out_free_interp;\n\n\t\tinterpreter = open_exec(elf_interpreter);\n\t\tkfree(elf_interpreter);\n\t\tretval = PTR_ERR(interpreter);\n\t\tif (IS_ERR(interpreter))\n\t\t\tgoto out_free_ph;\n\n\t\t \n\t\twould_dump(bprm, interpreter);\n\n\t\tinterp_elf_ex = kmalloc(sizeof(*interp_elf_ex), GFP_KERNEL);\n\t\tif (!interp_elf_ex) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_free_file;\n\t\t}\n\n\t\t \n\t\tretval = elf_read(interpreter, interp_elf_ex,\n\t\t\t\t  sizeof(*interp_elf_ex), 0);\n\t\tif (retval < 0)\n\t\t\tgoto out_free_dentry;\n\n\t\tbreak;\n\nout_free_interp:\n\t\tkfree(elf_interpreter);\n\t\tgoto out_free_ph;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < elf_ex->e_phnum; i++, elf_ppnt++)\n\t\tswitch (elf_ppnt->p_type) {\n\t\tcase PT_GNU_STACK:\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\n\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\tretval = arch_elf_pt_proc(elf_ex, elf_ppnt,\n\t\t\t\t\t\t  bprm->file, false,\n\t\t\t\t\t\t  &arch_state);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tbreak;\n\t\t}\n\n\t \n\tif (interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t \n\t\tif (memcmp(interp_elf_ex->e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t \n\t\tif (!elf_check_arch(interp_elf_ex) ||\n\t\t    elf_check_fdpic(interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\n\t\t \n\t\tinterp_elf_phdata = load_elf_phdrs(interp_elf_ex,\n\t\t\t\t\t\t   interpreter);\n\t\tif (!interp_elf_phdata)\n\t\t\tgoto out_free_dentry;\n\n\t\t \n\t\telf_property_phdata = NULL;\n\t\telf_ppnt = interp_elf_phdata;\n\t\tfor (i = 0; i < interp_elf_ex->e_phnum; i++, elf_ppnt++)\n\t\t\tswitch (elf_ppnt->p_type) {\n\t\t\tcase PT_GNU_PROPERTY:\n\t\t\t\telf_property_phdata = elf_ppnt;\n\t\t\t\tbreak;\n\n\t\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\t\tretval = arch_elf_pt_proc(interp_elf_ex,\n\t\t\t\t\t\t\t  elf_ppnt, interpreter,\n\t\t\t\t\t\t\t  true, &arch_state);\n\t\t\t\tif (retval)\n\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\tretval = parse_elf_properties(interpreter ?: bprm->file,\n\t\t\t\t      elf_property_phdata, &arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t \n\tretval = arch_check_elf(elf_ex,\n\t\t\t\t!!interpreter, interp_elf_ex,\n\t\t\t\t&arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t \n\tretval = begin_new_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t \n\tSET_PERSONALITY2(*elf_ex, &arch_state);\n\tif (elf_read_implies_exec(*elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\n\t \n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto out_free_dentry;\n\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\t \n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < elf_ex->e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot, elf_flags;\n\t\tunsigned long k, vaddr;\n\t\tunsigned long total_size = 0;\n\t\tunsigned long alignment;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\n\t\t\t \n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias,\n\t\t\t\t\t bss_prot);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telf_prot = make_prot(elf_ppnt->p_flags, &arch_state,\n\t\t\t\t     !!interpreter, false);\n\n\t\telf_flags = MAP_PRIVATE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\t \n\t\tif (!first_pt_load) {\n\t\t\telf_flags |= MAP_FIXED;\n\t\t} else if (elf_ex->e_type == ET_EXEC) {\n\t\t\t \n\t\t\telf_flags |= MAP_FIXED_NOREPLACE;\n\t\t} else if (elf_ex->e_type == ET_DYN) {\n\t\t\t \n\t\t\tif (interpreter) {\n\t\t\t\tload_bias = ELF_ET_DYN_BASE;\n\t\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\t\tload_bias += arch_mmap_rnd();\n\t\t\t\talignment = maximum_alignment(elf_phdata, elf_ex->e_phnum);\n\t\t\t\tif (alignment)\n\t\t\t\t\tload_bias &= ~(alignment - 1);\n\t\t\t\telf_flags |= MAP_FIXED_NOREPLACE;\n\t\t\t} else\n\t\t\t\tload_bias = 0;\n\n\t\t\t \n\t\t\tload_bias = ELF_PAGESTART(load_bias - vaddr);\n\n\t\t\t \n\t\t\ttotal_size = total_mapping_size(elf_phdata,\n\t\t\t\t\t\t\telf_ex->e_phnum);\n\t\t\tif (!total_size) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, total_size);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tretval = IS_ERR_VALUE(error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (first_pt_load) {\n\t\t\tfirst_pt_load = 0;\n\t\t\tif (elf_ex->e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (elf_ppnt->p_offset <= elf_ex->e_phoff &&\n\t\t    elf_ex->e_phoff < elf_ppnt->p_offset + elf_ppnt->p_filesz) {\n\t\t\tphdr_addr = elf_ex->e_phoff - elf_ppnt->p_offset +\n\t\t\t\t    elf_ppnt->p_vaddr;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif ((elf_ppnt->p_flags & PF_X) && k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t \n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t \n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk) {\n\t\t\tbss_prot = elf_prot;\n\t\t\telf_brk = k;\n\t\t}\n\t}\n\n\te_entry = elf_ex->e_entry + load_bias;\n\tphdr_addr += load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t \n\tretval = set_brk(elf_bss, elf_brk, bss_prot);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tretval = -EFAULT;  \n\t\tgoto out_free_dentry;\n\t}\n\n\tif (interpreter) {\n\t\telf_entry = load_elf_interp(interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    load_bias, interp_elf_phdata,\n\t\t\t\t\t    &arch_state);\n\t\tif (!IS_ERR_VALUE(elf_entry)) {\n\t\t\t \n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += interp_elf_ex->e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = IS_ERR_VALUE(elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\n\t\tkfree(interp_elf_ex);\n\t\tkfree(interp_elf_phdata);\n\t} else {\n\t\telf_entry = e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = ARCH_SETUP_ADDITIONAL_PAGES(bprm, elf_ex, !!interpreter);\n\tif (retval < 0)\n\t\tgoto out;\n#endif  \n\n\tretval = create_elf_tables(bprm, elf_ex, interp_load_addr,\n\t\t\t\t   e_entry, phdr_addr);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tmm = current->mm;\n\tmm->end_code = end_code;\n\tmm->start_code = start_code;\n\tmm->start_data = start_data;\n\tmm->end_data = end_data;\n\tmm->start_stack = bprm->p;\n\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\t \n\t\tif (IS_ENABLED(CONFIG_ARCH_HAS_ELF_RANDOMIZE) &&\n\t\t    elf_ex->e_type == ET_DYN && !interpreter) {\n\t\t\tmm->brk = mm->start_brk = ELF_ET_DYN_BASE;\n\t\t}\n\n\t\tmm->brk = mm->start_brk = arch_randomize_brk(mm);\n#ifdef compat_brk_randomized\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t \n\t\terror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t}\n\n\tregs = current_pt_regs();\n#ifdef ELF_PLAT_INIT\n\t \n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tfinalize_exec(bprm);\n\tSTART_THREAD(elf_ex, regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\treturn retval;\n\n\t \nout_free_dentry:\n\tkfree(interp_elf_ex);\n\tkfree(interp_elf_phdata);\nout_free_file:\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}\n\n#ifdef CONFIG_USELIB\n \nstatic int load_elf_library(struct file *file)\n{\n\tstruct elf_phdr *elf_phdata;\n\tstruct elf_phdr *eppnt;\n\tunsigned long elf_bss, bss, len;\n\tint retval, error, i, j;\n\tstruct elfhdr elf_ex;\n\n\terror = -ENOEXEC;\n\tretval = elf_read(file, &elf_ex, sizeof(elf_ex), 0);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tif (memcmp(elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\t \n\tif (elf_ex.e_type != ET_EXEC || elf_ex.e_phnum > 2 ||\n\t    !elf_check_arch(&elf_ex) || !file->f_op->mmap)\n\t\tgoto out;\n\tif (elf_check_fdpic(&elf_ex))\n\t\tgoto out;\n\n\t \n\n\tj = sizeof(struct elf_phdr) * elf_ex.e_phnum;\n\t \n\n\terror = -ENOMEM;\n\telf_phdata = kmalloc(j, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\teppnt = elf_phdata;\n\terror = -ENOEXEC;\n\tretval = elf_read(file, eppnt, j, elf_ex.e_phoff);\n\tif (retval < 0)\n\t\tgoto out_free_ph;\n\n\tfor (j = 0, i = 0; i<elf_ex.e_phnum; i++)\n\t\tif ((eppnt + i)->p_type == PT_LOAD)\n\t\t\tj++;\n\tif (j != 1)\n\t\tgoto out_free_ph;\n\n\twhile (eppnt->p_type != PT_LOAD)\n\t\teppnt++;\n\n\t \n\terror = vm_mmap(file,\n\t\t\tELF_PAGESTART(eppnt->p_vaddr),\n\t\t\t(eppnt->p_filesz +\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr)),\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED_NOREPLACE | MAP_PRIVATE,\n\t\t\t(eppnt->p_offset -\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr)));\n\tif (error != ELF_PAGESTART(eppnt->p_vaddr))\n\t\tgoto out_free_ph;\n\n\telf_bss = eppnt->p_vaddr + eppnt->p_filesz;\n\tif (padzero(elf_bss)) {\n\t\terror = -EFAULT;\n\t\tgoto out_free_ph;\n\t}\n\n\tlen = ELF_PAGEALIGN(eppnt->p_filesz + eppnt->p_vaddr);\n\tbss = ELF_PAGEALIGN(eppnt->p_memsz + eppnt->p_vaddr);\n\tif (bss > len) {\n\t\terror = vm_brk(len, bss - len);\n\t\tif (error)\n\t\t\tgoto out_free_ph;\n\t}\n\terror = 0;\n\nout_free_ph:\n\tkfree(elf_phdata);\nout:\n\treturn error;\n}\n#endif  \n\n#ifdef CONFIG_ELF_CORE\n \n\n \nstruct memelfnote\n{\n\tconst char *name;\n\tint type;\n\tunsigned int datasz;\n\tvoid *data;\n};\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}\n\nstatic int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t    dump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t    dump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}\n\nstatic void fill_elf_header(struct elfhdr *elf, int segs,\n\t\t\t    u16 machine, u32 flags)\n{\n\tmemset(elf, 0, sizeof(*elf));\n\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = machine;\n\telf->e_version = EV_CURRENT;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_flags = flags;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n}\n\nstatic void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 4;\n}\n\nstatic void fill_note(struct memelfnote *note, const char *name, int type,\n\t\tunsigned int sz, void *data)\n{\n\tnote->name = name;\n\tnote->type = type;\n\tnote->datasz = sz;\n\tnote->data = data;\n}\n\n \nstatic void fill_prstatus(struct elf_prstatus_common *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t \n\t\tthread_group_cputime(p, &cputime);\n\t\tprstatus->pr_utime = ns_to_kernel_old_timeval(cputime.utime);\n\t\tprstatus->pr_stime = ns_to_kernel_old_timeval(cputime.stime);\n\t} else {\n\t\tu64 utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tprstatus->pr_utime = ns_to_kernel_old_timeval(utime);\n\t\tprstatus->pr_stime = ns_to_kernel_old_timeval(stime);\n\t}\n\n\tprstatus->pr_cutime = ns_to_kernel_old_timeval(p->signal->cutime);\n\tprstatus->pr_cstime = ns_to_kernel_old_timeval(p->signal->cstime);\n}\n\nstatic int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\tunsigned int state;\n\n\t \n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ-1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *)mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor(i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\tstate = READ_ONCE(p->__state);\n\ti = state ? ffz(~state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tget_task_comm(psinfo->pr_fname, p);\n\n\treturn 0;\n}\n\nstatic void fill_auxv_note(struct memelfnote *note, struct mm_struct *mm)\n{\n\telf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;\n\tint i = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(note, \"CORE\", NT_AUXV, i * sizeof(elf_addr_t), auxv);\n}\n\nstatic void fill_siginfo_note(struct memelfnote *note, user_siginfo_t *csigdata,\n\t\tconst kernel_siginfo_t *siginfo)\n{\n\tcopy_siginfo_to_external(csigdata, siginfo);\n\tfill_note(note, \"CORE\", NT_SIGINFO, sizeof(*csigdata), csigdata);\n}\n\n#define MAX_FILE_NOTE_SIZE (4*1024*1024)\n \nstatic int fill_files_note(struct memelfnote *note, struct coredump_params *cprm)\n{\n\tunsigned count, size, names_ofs, remaining, n;\n\tuser_long_t *data;\n\tuser_long_t *start_end_ofs;\n\tchar *name_base, *name_curpos;\n\tint i;\n\n\t \n\tcount = cprm->vma_count;\n\tif (count > UINT_MAX / 64)\n\t\treturn -EINVAL;\n\tsize = count * 64;\n\n\tnames_ofs = (2 + 3 * count) * sizeof(data[0]);\n alloc:\n\tif (size >= MAX_FILE_NOTE_SIZE)  \n\t\treturn -EINVAL;\n\tsize = round_up(size, PAGE_SIZE);\n\t \n\tdata = kvmalloc(size, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(data))\n\t\treturn -ENOMEM;\n\n\tstart_end_ofs = data + 2;\n\tname_base = name_curpos = ((char *)data) + names_ofs;\n\tremaining = size - names_ofs;\n\tcount = 0;\n\tfor (i = 0; i < cprm->vma_count; i++) {\n\t\tstruct core_vma_metadata *m = &cprm->vma_meta[i];\n\t\tstruct file *file;\n\t\tconst char *filename;\n\n\t\tfile = m->file;\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tfilename = file_path(file, name_curpos, remaining);\n\t\tif (IS_ERR(filename)) {\n\t\t\tif (PTR_ERR(filename) == -ENAMETOOLONG) {\n\t\t\t\tkvfree(data);\n\t\t\t\tsize = size * 5 / 4;\n\t\t\t\tgoto alloc;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\t \n\t\tn = (name_curpos + remaining) - filename;\n\t\tremaining = filename - name_curpos;\n\t\tmemmove(name_curpos, filename, n);\n\t\tname_curpos += n;\n\n\t\t*start_end_ofs++ = m->start;\n\t\t*start_end_ofs++ = m->end;\n\t\t*start_end_ofs++ = m->pgoff;\n\t\tcount++;\n\t}\n\n\t \n\tdata[0] = count;\n\tdata[1] = PAGE_SIZE;\n\t \n\tn = cprm->vma_count - count;\n\tif (n != 0) {\n\t\tunsigned shift_bytes = n * 3 * sizeof(data[0]);\n\t\tmemmove(name_base - shift_bytes, name_base,\n\t\t\tname_curpos - name_base);\n\t\tname_curpos -= shift_bytes;\n\t}\n\n\tsize = name_curpos - (char *)data;\n\tfill_note(note, \"CORE\", NT_FILE, size, data);\n\treturn 0;\n}\n\n#include <linux/regset.h>\n\nstruct elf_thread_core_info {\n\tstruct elf_thread_core_info *next;\n\tstruct task_struct *task;\n\tstruct elf_prstatus prstatus;\n\tstruct memelfnote notes[];\n};\n\nstruct elf_note_info {\n\tstruct elf_thread_core_info *thread;\n\tstruct memelfnote psinfo;\n\tstruct memelfnote signote;\n\tstruct memelfnote auxv;\n\tstruct memelfnote files;\n\tuser_siginfo_t csigdata;\n\tsize_t size;\n\tint thread_notes;\n};\n\n#ifdef CORE_DUMP_USE_REGSET\n \nstatic void do_thread_regset_writeback(struct task_struct *task,\n\t\t\t\t       const struct user_regset *regset)\n{\n\tif (regset->writeback)\n\t\tregset->writeback(task, regset, 1);\n}\n\n#ifndef PRSTATUS_SIZE\n#define PRSTATUS_SIZE sizeof(struct elf_prstatus)\n#endif\n\n#ifndef SET_PR_FPVALID\n#define SET_PR_FPVALID(S) ((S)->pr_fpvalid = 1)\n#endif\n\nstatic int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, struct elf_note_info *info)\n{\n\tunsigned int note_iter, view_iter;\n\n\t \n\tfill_prstatus(&t->prstatus.common, t->task, signr);\n\tregset_get(t->task, &view->regsets[0],\n\t\t   sizeof(t->prstatus.pr_reg), &t->prstatus.pr_reg);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  PRSTATUS_SIZE, &t->prstatus);\n\tinfo->size += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t \n\tnote_iter = 1;\n\tfor (view_iter = 1; view_iter < view->n; ++view_iter) {\n\t\tconst struct user_regset *regset = &view->regsets[view_iter];\n\t\tint note_type = regset->core_note_type;\n\t\tbool is_fpreg = note_type == NT_PRFPREG;\n\t\tvoid *data;\n\t\tint ret;\n\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (!note_type) \n\t\t\tcontinue;\n\t\tif (regset->active && regset->active(t->task, regset) <= 0)\n\t\t\tcontinue;\n\n\t\tret = regset_get_alloc(t->task, regset, ~0U, &data);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tif (WARN_ON_ONCE(note_iter >= info->thread_notes))\n\t\t\tbreak;\n\n\t\tif (is_fpreg)\n\t\t\tSET_PR_FPVALID(&t->prstatus);\n\n\t\tfill_note(&t->notes[note_iter], is_fpreg ? \"CORE\" : \"LINUX\",\n\t\t\t  note_type, ret, data);\n\n\t\tinfo->size += notesize(&t->notes[note_iter]);\n\t\tnote_iter++;\n\t}\n\n\treturn 1;\n}\n#else\nstatic int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, struct elf_note_info *info)\n{\n\tstruct task_struct *p = t->task;\n\telf_fpregset_t *fpu;\n\n\tfill_prstatus(&t->prstatus.common, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &(t->prstatus));\n\tinfo->size += notesize(&t->notes[0]);\n\n\tfpu = kzalloc(sizeof(elf_fpregset_t), GFP_KERNEL);\n\tif (!fpu || !elf_core_copy_task_fpregs(p, fpu)) {\n\t\tkfree(fpu);\n\t\treturn 1;\n\t}\n\n\tt->prstatus.pr_fpvalid = 1;\n\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(*fpu), fpu);\n\tinfo->size += notesize(&t->notes[1]);\n\n\treturn 1;\n}\n#endif\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  struct coredump_params *cprm)\n{\n\tstruct task_struct *dump_task = current;\n\tconst struct user_regset_view *view;\n\tstruct elf_thread_core_info *t;\n\tstruct elf_prpsinfo *psinfo;\n\tstruct core_thread *ct;\n\n\tpsinfo = kmalloc(sizeof(*psinfo), GFP_KERNEL);\n\tif (!psinfo)\n\t\treturn 0;\n\tfill_note(&info->psinfo, \"CORE\", NT_PRPSINFO, sizeof(*psinfo), psinfo);\n\n#ifdef CORE_DUMP_USE_REGSET\n\tview = task_user_regset_view(dump_task);\n\n\t \n\tinfo->thread_notes = 0;\n\tfor (int i = 0; i < view->n; ++i)\n\t\tif (view->regsets[i].core_note_type != 0)\n\t\t\t++info->thread_notes;\n\n\t \n\tif (unlikely(info->thread_notes == 0) ||\n\t    unlikely(view->regsets[0].core_note_type != NT_PRSTATUS)) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\t \n\tfill_elf_header(elf, phdrs,\n\t\t\tview->e_machine, view->e_flags);\n#else\n\tview = NULL;\n\tinfo->thread_notes = 2;\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n#endif\n\n\t \n\tinfo->thread = kzalloc(offsetof(struct elf_thread_core_info,\n\t\t\t\t     notes[info->thread_notes]),\n\t\t\t    GFP_KERNEL);\n\tif (unlikely(!info->thread))\n\t\treturn 0;\n\n\tinfo->thread->task = dump_task;\n\tfor (ct = dump_task->signal->core_state->dumper.next; ct; ct = ct->next) {\n\t\tt = kzalloc(offsetof(struct elf_thread_core_info,\n\t\t\t\t     notes[info->thread_notes]),\n\t\t\t    GFP_KERNEL);\n\t\tif (unlikely(!t))\n\t\t\treturn 0;\n\n\t\tt->task = ct->task;\n\t\tt->next = info->thread->next;\n\t\tinfo->thread->next = t;\n\t}\n\n\t \n\tfor (t = info->thread; t != NULL; t = t->next)\n\t\tif (!fill_thread_core_info(t, view, cprm->siginfo->si_signo, info))\n\t\t\treturn 0;\n\n\t \n\tfill_psinfo(psinfo, dump_task->group_leader, dump_task->mm);\n\tinfo->size += notesize(&info->psinfo);\n\n\tfill_siginfo_note(&info->signote, &info->csigdata, cprm->siginfo);\n\tinfo->size += notesize(&info->signote);\n\n\tfill_auxv_note(&info->auxv, current->mm);\n\tinfo->size += notesize(&info->auxv);\n\n\tif (fill_files_note(&info->files, cprm) == 0)\n\t\tinfo->size += notesize(&info->files);\n\n\treturn 1;\n}\n\n \nstatic int write_note_info(struct elf_note_info *info,\n\t\t\t   struct coredump_params *cprm)\n{\n\tbool first = true;\n\tstruct elf_thread_core_info *t = info->thread;\n\n\tdo {\n\t\tint i;\n\n\t\tif (!writenote(&t->notes[0], cprm))\n\t\t\treturn 0;\n\n\t\tif (first && !writenote(&info->psinfo, cprm))\n\t\t\treturn 0;\n\t\tif (first && !writenote(&info->signote, cprm))\n\t\t\treturn 0;\n\t\tif (first && !writenote(&info->auxv, cprm))\n\t\t\treturn 0;\n\t\tif (first && info->files.data &&\n\t\t\t\t!writenote(&info->files, cprm))\n\t\t\treturn 0;\n\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tif (t->notes[i].data &&\n\t\t\t    !writenote(&t->notes[i], cprm))\n\t\t\t\treturn 0;\n\n\t\tfirst = false;\n\t\tt = t->next;\n\t} while (t);\n\n\treturn 1;\n}\n\nstatic void free_note_info(struct elf_note_info *info)\n{\n\tstruct elf_thread_core_info *threads = info->thread;\n\twhile (threads) {\n\t\tunsigned int i;\n\t\tstruct elf_thread_core_info *t = threads;\n\t\tthreads = t->next;\n\t\tWARN_ON(t->notes[0].data && t->notes[0].data != &t->prstatus);\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tkfree(t->notes[i].data);\n\t\tkfree(t);\n\t}\n\tkfree(info->psinfo.data);\n\tkvfree(info->files.data);\n}\n\nstatic void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\n\t\t\t     elf_addr_t e_shoff, int segs)\n{\n\telf->e_shoff = e_shoff;\n\telf->e_shentsize = sizeof(*shdr4extnum);\n\telf->e_shnum = 1;\n\telf->e_shstrndx = SHN_UNDEF;\n\n\tmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\n\n\tshdr4extnum->sh_type = SHT_NULL;\n\tshdr4extnum->sh_size = elf->e_shnum;\n\tshdr4extnum->sh_link = elf->e_shstrndx;\n\tshdr4extnum->sh_info = segs;\n}\n\n \nstatic int elf_core_dump(struct coredump_params *cprm)\n{\n\tint has_dumped = 0;\n\tint segs, i;\n\tstruct elfhdr elf;\n\tloff_t offset = 0, dataoff;\n\tstruct elf_note_info info = { };\n\tstruct elf_phdr *phdr4note = NULL;\n\tstruct elf_shdr *shdr4extnum = NULL;\n\tElf_Half e_phnum;\n\telf_addr_t e_shoff;\n\n\t \n\tsegs = cprm->vma_count + elf_core_extra_phdrs(cprm);\n\n\t \n\tsegs++;\n\n\t \n\te_phnum = segs > PN_XNUM ? PN_XNUM : segs;\n\n\t \n\tif (!fill_note_info(&elf, e_phnum, &info, cprm))\n\t\tgoto end_coredump;\n\n\thas_dumped = 1;\n\n\toffset += sizeof(elf);\t\t\t\t \n\toffset += segs * sizeof(struct elf_phdr);\t \n\n\t \n\t{\n\t\tsize_t sz = info.size;\n\n\t\t \n\t\tsz += elf_coredump_extra_notes_size();\n\n\t\tphdr4note = kmalloc(sizeof(*phdr4note), GFP_KERNEL);\n\t\tif (!phdr4note)\n\t\t\tgoto end_coredump;\n\n\t\tfill_elf_note_phdr(phdr4note, sz, offset);\n\t\toffset += sz;\n\t}\n\n\tdataoff = offset = roundup(offset, ELF_EXEC_PAGESIZE);\n\n\toffset += cprm->vma_data_size;\n\toffset += elf_core_extra_data_size(cprm);\n\te_shoff = offset;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tshdr4extnum = kmalloc(sizeof(*shdr4extnum), GFP_KERNEL);\n\t\tif (!shdr4extnum)\n\t\t\tgoto end_coredump;\n\t\tfill_extnum_info(&elf, shdr4extnum, e_shoff, segs);\n\t}\n\n\toffset = dataoff;\n\n\tif (!dump_emit(cprm, &elf, sizeof(elf)))\n\t\tgoto end_coredump;\n\n\tif (!dump_emit(cprm, phdr4note, sizeof(*phdr4note)))\n\t\tgoto end_coredump;\n\n\t \n\tfor (i = 0; i < cprm->vma_count; i++) {\n\t\tstruct core_vma_metadata *meta = cprm->vma_meta + i;\n\t\tstruct elf_phdr phdr;\n\n\t\tphdr.p_type = PT_LOAD;\n\t\tphdr.p_offset = offset;\n\t\tphdr.p_vaddr = meta->start;\n\t\tphdr.p_paddr = 0;\n\t\tphdr.p_filesz = meta->dump_size;\n\t\tphdr.p_memsz = meta->end - meta->start;\n\t\toffset += phdr.p_filesz;\n\t\tphdr.p_flags = 0;\n\t\tif (meta->flags & VM_READ)\n\t\t\tphdr.p_flags |= PF_R;\n\t\tif (meta->flags & VM_WRITE)\n\t\t\tphdr.p_flags |= PF_W;\n\t\tif (meta->flags & VM_EXEC)\n\t\t\tphdr.p_flags |= PF_X;\n\t\tphdr.p_align = ELF_EXEC_PAGESIZE;\n\n\t\tif (!dump_emit(cprm, &phdr, sizeof(phdr)))\n\t\t\tgoto end_coredump;\n\t}\n\n\tif (!elf_core_write_extra_phdrs(cprm, offset))\n\t\tgoto end_coredump;\n\n\t \n\tif (!write_note_info(&info, cprm))\n\t\tgoto end_coredump;\n\n\t \n\tif (elf_coredump_extra_notes_write(cprm))\n\t\tgoto end_coredump;\n\n\t \n\tdump_skip_to(cprm, dataoff);\n\n\tfor (i = 0; i < cprm->vma_count; i++) {\n\t\tstruct core_vma_metadata *meta = cprm->vma_meta + i;\n\n\t\tif (!dump_user_range(cprm, meta->start, meta->dump_size))\n\t\t\tgoto end_coredump;\n\t}\n\n\tif (!elf_core_write_extra_data(cprm))\n\t\tgoto end_coredump;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tif (!dump_emit(cprm, shdr4extnum, sizeof(*shdr4extnum)))\n\t\t\tgoto end_coredump;\n\t}\n\nend_coredump:\n\tfree_note_info(&info);\n\tkfree(shdr4extnum);\n\tkfree(phdr4note);\n\treturn has_dumped;\n}\n\n#endif\t\t \n\nstatic int __init init_elf_binfmt(void)\n{\n\tregister_binfmt(&elf_format);\n\treturn 0;\n}\n\nstatic void __exit exit_elf_binfmt(void)\n{\n\t \n\tunregister_binfmt(&elf_format);\n}\n\ncore_initcall(init_elf_binfmt);\nmodule_exit(exit_elf_binfmt);\n\n#ifdef CONFIG_BINFMT_ELF_KUNIT_TEST\n#include \"binfmt_elf_test.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}