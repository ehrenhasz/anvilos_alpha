{
  "module_name": "timerfd.c",
  "hash_id": "3d7411c3dfc062b64b55fcea9db2ab259586a763cc75df70f63e45797fd735c8",
  "original_prompt": "Ingested from linux-6.6.14/fs/timerfd.c",
  "human_readable_source": "\n \n\n#include <linux/alarmtimer.h>\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/time.h>\n#include <linux/hrtimer.h>\n#include <linux/anon_inodes.h>\n#include <linux/timerfd.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/rcupdate.h>\n#include <linux/time_namespace.h>\n\nstruct timerfd_ctx {\n\tunion {\n\t\tstruct hrtimer tmr;\n\t\tstruct alarm alarm;\n\t} t;\n\tktime_t tintv;\n\tktime_t moffs;\n\twait_queue_head_t wqh;\n\tu64 ticks;\n\tint clockid;\n\tshort unsigned expired;\n\tshort unsigned settime_flags;\t \n\tstruct rcu_head rcu;\n\tstruct list_head clist;\n\tspinlock_t cancel_lock;\n\tbool might_cancel;\n};\n\nstatic LIST_HEAD(cancel_list);\nstatic DEFINE_SPINLOCK(cancel_lock);\n\nstatic inline bool isalarm(struct timerfd_ctx *ctx)\n{\n\treturn ctx->clockid == CLOCK_REALTIME_ALARM ||\n\t\tctx->clockid == CLOCK_BOOTTIME_ALARM;\n}\n\n \nstatic void timerfd_triggered(struct timerfd_ctx *ctx)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\tctx->expired = 1;\n\tctx->ticks++;\n\twake_up_locked_poll(&ctx->wqh, EPOLLIN);\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n}\n\nstatic enum hrtimer_restart timerfd_tmrproc(struct hrtimer *htmr)\n{\n\tstruct timerfd_ctx *ctx = container_of(htmr, struct timerfd_ctx,\n\t\t\t\t\t       t.tmr);\n\ttimerfd_triggered(ctx);\n\treturn HRTIMER_NORESTART;\n}\n\nstatic enum alarmtimer_restart timerfd_alarmproc(struct alarm *alarm,\n\tktime_t now)\n{\n\tstruct timerfd_ctx *ctx = container_of(alarm, struct timerfd_ctx,\n\t\t\t\t\t       t.alarm);\n\ttimerfd_triggered(ctx);\n\treturn ALARMTIMER_NORESTART;\n}\n\n \nvoid timerfd_clock_was_set(void)\n{\n\tktime_t moffs = ktime_mono_to_real(0);\n\tstruct timerfd_ctx *ctx;\n\tunsigned long flags;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ctx, &cancel_list, clist) {\n\t\tif (!ctx->might_cancel)\n\t\t\tcontinue;\n\t\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\t\tif (ctx->moffs != moffs) {\n\t\t\tctx->moffs = KTIME_MAX;\n\t\t\tctx->ticks++;\n\t\t\twake_up_locked_poll(&ctx->wqh, EPOLLIN);\n\t\t}\n\t\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\t}\n\trcu_read_unlock();\n}\n\nstatic void timerfd_resume_work(struct work_struct *work)\n{\n\ttimerfd_clock_was_set();\n}\n\nstatic DECLARE_WORK(timerfd_work, timerfd_resume_work);\n\n \nvoid timerfd_resume(void)\n{\n\tschedule_work(&timerfd_work);\n}\n\nstatic void __timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}\n\nstatic void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tspin_lock(&ctx->cancel_lock);\n\t__timerfd_remove_cancel(ctx);\n\tspin_unlock(&ctx->cancel_lock);\n}\n\nstatic bool timerfd_canceled(struct timerfd_ctx *ctx)\n{\n\tif (!ctx->might_cancel || ctx->moffs != KTIME_MAX)\n\t\treturn false;\n\tctx->moffs = ktime_mono_to_real(0);\n\treturn true;\n}\n\nstatic void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)\n{\n\tspin_lock(&ctx->cancel_lock);\n\tif ((ctx->clockid == CLOCK_REALTIME ||\n\t     ctx->clockid == CLOCK_REALTIME_ALARM) &&\n\t    (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {\n\t\tif (!ctx->might_cancel) {\n\t\t\tctx->might_cancel = true;\n\t\t\tspin_lock(&cancel_lock);\n\t\t\tlist_add_rcu(&ctx->clist, &cancel_list);\n\t\t\tspin_unlock(&cancel_lock);\n\t\t}\n\t} else {\n\t\t__timerfd_remove_cancel(ctx);\n\t}\n\tspin_unlock(&ctx->cancel_lock);\n}\n\nstatic ktime_t timerfd_get_remaining(struct timerfd_ctx *ctx)\n{\n\tktime_t remaining;\n\n\tif (isalarm(ctx))\n\t\tremaining = alarm_expires_remaining(&ctx->t.alarm);\n\telse\n\t\tremaining = hrtimer_expires_remaining_adjusted(&ctx->t.tmr);\n\n\treturn remaining < 0 ? 0: remaining;\n}\n\nstatic int timerfd_setup(struct timerfd_ctx *ctx, int flags,\n\t\t\t const struct itimerspec64 *ktmr)\n{\n\tenum hrtimer_mode htmode;\n\tktime_t texp;\n\tint clockid = ctx->clockid;\n\n\thtmode = (flags & TFD_TIMER_ABSTIME) ?\n\t\tHRTIMER_MODE_ABS: HRTIMER_MODE_REL;\n\n\ttexp = timespec64_to_ktime(ktmr->it_value);\n\tctx->expired = 0;\n\tctx->ticks = 0;\n\tctx->tintv = timespec64_to_ktime(ktmr->it_interval);\n\n\tif (isalarm(ctx)) {\n\t\talarm_init(&ctx->t.alarm,\n\t\t\t   ctx->clockid == CLOCK_REALTIME_ALARM ?\n\t\t\t   ALARM_REALTIME : ALARM_BOOTTIME,\n\t\t\t   timerfd_alarmproc);\n\t} else {\n\t\thrtimer_init(&ctx->t.tmr, clockid, htmode);\n\t\thrtimer_set_expires(&ctx->t.tmr, texp);\n\t\tctx->t.tmr.function = timerfd_tmrproc;\n\t}\n\n\tif (texp != 0) {\n\t\tif (flags & TFD_TIMER_ABSTIME)\n\t\t\ttexp = timens_ktime_to_host(clockid, texp);\n\t\tif (isalarm(ctx)) {\n\t\t\tif (flags & TFD_TIMER_ABSTIME)\n\t\t\t\talarm_start(&ctx->t.alarm, texp);\n\t\t\telse\n\t\t\t\talarm_start_relative(&ctx->t.alarm, texp);\n\t\t} else {\n\t\t\thrtimer_start(&ctx->t.tmr, texp, htmode);\n\t\t}\n\n\t\tif (timerfd_canceled(ctx))\n\t\t\treturn -ECANCELED;\n\t}\n\n\tctx->settime_flags = flags & TFD_SETTIME_FLAGS;\n\treturn 0;\n}\n\nstatic int timerfd_release(struct inode *inode, struct file *file)\n{\n\tstruct timerfd_ctx *ctx = file->private_data;\n\n\ttimerfd_remove_cancel(ctx);\n\n\tif (isalarm(ctx))\n\t\talarm_cancel(&ctx->t.alarm);\n\telse\n\t\thrtimer_cancel(&ctx->t.tmr);\n\tkfree_rcu(ctx, rcu);\n\treturn 0;\n}\n\nstatic __poll_t timerfd_poll(struct file *file, poll_table *wait)\n{\n\tstruct timerfd_ctx *ctx = file->private_data;\n\t__poll_t events = 0;\n\tunsigned long flags;\n\n\tpoll_wait(file, &ctx->wqh, wait);\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\tif (ctx->ticks)\n\t\tevents |= EPOLLIN;\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\n\treturn events;\n}\n\nstatic ssize_t timerfd_read(struct file *file, char __user *buf, size_t count,\n\t\t\t    loff_t *ppos)\n{\n\tstruct timerfd_ctx *ctx = file->private_data;\n\tssize_t res;\n\tu64 ticks = 0;\n\n\tif (count < sizeof(ticks))\n\t\treturn -EINVAL;\n\tspin_lock_irq(&ctx->wqh.lock);\n\tif (file->f_flags & O_NONBLOCK)\n\t\tres = -EAGAIN;\n\telse\n\t\tres = wait_event_interruptible_locked_irq(ctx->wqh, ctx->ticks);\n\n\t \n\tif (timerfd_canceled(ctx)) {\n\t\tctx->ticks = 0;\n\t\tctx->expired = 0;\n\t\tres = -ECANCELED;\n\t}\n\n\tif (ctx->ticks) {\n\t\tticks = ctx->ticks;\n\n\t\tif (ctx->expired && ctx->tintv) {\n\t\t\t \n\t\t\tif (isalarm(ctx)) {\n\t\t\t\tticks += alarm_forward_now(\n\t\t\t\t\t&ctx->t.alarm, ctx->tintv) - 1;\n\t\t\t\talarm_restart(&ctx->t.alarm);\n\t\t\t} else {\n\t\t\t\tticks += hrtimer_forward_now(&ctx->t.tmr,\n\t\t\t\t\t\t\t     ctx->tintv) - 1;\n\t\t\t\thrtimer_restart(&ctx->t.tmr);\n\t\t\t}\n\t\t}\n\t\tctx->expired = 0;\n\t\tctx->ticks = 0;\n\t}\n\tspin_unlock_irq(&ctx->wqh.lock);\n\tif (ticks)\n\t\tres = put_user(ticks, (u64 __user *) buf) ? -EFAULT: sizeof(ticks);\n\treturn res;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic void timerfd_show(struct seq_file *m, struct file *file)\n{\n\tstruct timerfd_ctx *ctx = file->private_data;\n\tstruct timespec64 value, interval;\n\n\tspin_lock_irq(&ctx->wqh.lock);\n\tvalue = ktime_to_timespec64(timerfd_get_remaining(ctx));\n\tinterval = ktime_to_timespec64(ctx->tintv);\n\tspin_unlock_irq(&ctx->wqh.lock);\n\n\tseq_printf(m,\n\t\t   \"clockid: %d\\n\"\n\t\t   \"ticks: %llu\\n\"\n\t\t   \"settime flags: 0%o\\n\"\n\t\t   \"it_value: (%llu, %llu)\\n\"\n\t\t   \"it_interval: (%llu, %llu)\\n\",\n\t\t   ctx->clockid,\n\t\t   (unsigned long long)ctx->ticks,\n\t\t   ctx->settime_flags,\n\t\t   (unsigned long long)value.tv_sec,\n\t\t   (unsigned long long)value.tv_nsec,\n\t\t   (unsigned long long)interval.tv_sec,\n\t\t   (unsigned long long)interval.tv_nsec);\n}\n#else\n#define timerfd_show NULL\n#endif\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\nstatic long timerfd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct timerfd_ctx *ctx = file->private_data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase TFD_IOC_SET_TICKS: {\n\t\tu64 ticks;\n\n\t\tif (copy_from_user(&ticks, (u64 __user *)arg, sizeof(ticks)))\n\t\t\treturn -EFAULT;\n\t\tif (!ticks)\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_irq(&ctx->wqh.lock);\n\t\tif (!timerfd_canceled(ctx)) {\n\t\t\tctx->ticks = ticks;\n\t\t\twake_up_locked_poll(&ctx->wqh, EPOLLIN);\n\t\t} else\n\t\t\tret = -ECANCELED;\n\t\tspin_unlock_irq(&ctx->wqh.lock);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tret = -ENOTTY;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n#else\n#define timerfd_ioctl NULL\n#endif\n\nstatic const struct file_operations timerfd_fops = {\n\t.release\t= timerfd_release,\n\t.poll\t\t= timerfd_poll,\n\t.read\t\t= timerfd_read,\n\t.llseek\t\t= noop_llseek,\n\t.show_fdinfo\t= timerfd_show,\n\t.unlocked_ioctl\t= timerfd_ioctl,\n};\n\nstatic int timerfd_fget(int fd, struct fd *p)\n{\n\tstruct fd f = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\tif (f.file->f_op != &timerfd_fops) {\n\t\tfdput(f);\n\t\treturn -EINVAL;\n\t}\n\t*p = f;\n\treturn 0;\n}\n\nSYSCALL_DEFINE2(timerfd_create, int, clockid, int, flags)\n{\n\tint ufd;\n\tstruct timerfd_ctx *ctx;\n\n\t \n\tBUILD_BUG_ON(TFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(TFD_NONBLOCK != O_NONBLOCK);\n\n\tif ((flags & ~TFD_CREATE_FLAGS) ||\n\t    (clockid != CLOCK_MONOTONIC &&\n\t     clockid != CLOCK_REALTIME &&\n\t     clockid != CLOCK_REALTIME_ALARM &&\n\t     clockid != CLOCK_BOOTTIME &&\n\t     clockid != CLOCK_BOOTTIME_ALARM))\n\t\treturn -EINVAL;\n\n\tif ((clockid == CLOCK_REALTIME_ALARM ||\n\t     clockid == CLOCK_BOOTTIME_ALARM) &&\n\t    !capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head(&ctx->wqh);\n\tspin_lock_init(&ctx->cancel_lock);\n\tctx->clockid = clockid;\n\n\tif (isalarm(ctx))\n\t\talarm_init(&ctx->t.alarm,\n\t\t\t   ctx->clockid == CLOCK_REALTIME_ALARM ?\n\t\t\t   ALARM_REALTIME : ALARM_BOOTTIME,\n\t\t\t   timerfd_alarmproc);\n\telse\n\t\thrtimer_init(&ctx->t.tmr, clockid, HRTIMER_MODE_ABS);\n\n\tctx->moffs = ktime_mono_to_real(0);\n\n\tufd = anon_inode_getfd(\"[timerfd]\", &timerfd_fops, ctx,\n\t\t\t       O_RDWR | (flags & TFD_SHARED_FCNTL_FLAGS));\n\tif (ufd < 0)\n\t\tkfree(ctx);\n\n\treturn ufd;\n}\n\nstatic int do_timerfd_settime(int ufd, int flags, \n\t\tconst struct itimerspec64 *new,\n\t\tstruct itimerspec64 *old)\n{\n\tstruct fd f;\n\tstruct timerfd_ctx *ctx;\n\tint ret;\n\n\tif ((flags & ~TFD_SETTIME_FLAGS) ||\n\t\t !itimerspec64_valid(new))\n\t\treturn -EINVAL;\n\n\tret = timerfd_fget(ufd, &f);\n\tif (ret)\n\t\treturn ret;\n\tctx = f.file->private_data;\n\n\tif (isalarm(ctx) && !capable(CAP_WAKE_ALARM)) {\n\t\tfdput(f);\n\t\treturn -EPERM;\n\t}\n\n\ttimerfd_setup_cancel(ctx, flags);\n\n\t \n\tfor (;;) {\n\t\tspin_lock_irq(&ctx->wqh.lock);\n\n\t\tif (isalarm(ctx)) {\n\t\t\tif (alarm_try_to_cancel(&ctx->t.alarm) >= 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (hrtimer_try_to_cancel(&ctx->t.tmr) >= 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irq(&ctx->wqh.lock);\n\n\t\tif (isalarm(ctx))\n\t\t\thrtimer_cancel_wait_running(&ctx->t.alarm.timer);\n\t\telse\n\t\t\thrtimer_cancel_wait_running(&ctx->t.tmr);\n\t}\n\n\t \n\tif (ctx->expired && ctx->tintv) {\n\t\tif (isalarm(ctx))\n\t\t\talarm_forward_now(&ctx->t.alarm, ctx->tintv);\n\t\telse\n\t\t\thrtimer_forward_now(&ctx->t.tmr, ctx->tintv);\n\t}\n\n\told->it_value = ktime_to_timespec64(timerfd_get_remaining(ctx));\n\told->it_interval = ktime_to_timespec64(ctx->tintv);\n\n\t \n\tret = timerfd_setup(ctx, flags, new);\n\n\tspin_unlock_irq(&ctx->wqh.lock);\n\tfdput(f);\n\treturn ret;\n}\n\nstatic int do_timerfd_gettime(int ufd, struct itimerspec64 *t)\n{\n\tstruct fd f;\n\tstruct timerfd_ctx *ctx;\n\tint ret = timerfd_fget(ufd, &f);\n\tif (ret)\n\t\treturn ret;\n\tctx = f.file->private_data;\n\n\tspin_lock_irq(&ctx->wqh.lock);\n\tif (ctx->expired && ctx->tintv) {\n\t\tctx->expired = 0;\n\n\t\tif (isalarm(ctx)) {\n\t\t\tctx->ticks +=\n\t\t\t\talarm_forward_now(\n\t\t\t\t\t&ctx->t.alarm, ctx->tintv) - 1;\n\t\t\talarm_restart(&ctx->t.alarm);\n\t\t} else {\n\t\t\tctx->ticks +=\n\t\t\t\thrtimer_forward_now(&ctx->t.tmr, ctx->tintv)\n\t\t\t\t- 1;\n\t\t\thrtimer_restart(&ctx->t.tmr);\n\t\t}\n\t}\n\tt->it_value = ktime_to_timespec64(timerfd_get_remaining(ctx));\n\tt->it_interval = ktime_to_timespec64(ctx->tintv);\n\tspin_unlock_irq(&ctx->wqh.lock);\n\tfdput(f);\n\treturn 0;\n}\n\nSYSCALL_DEFINE4(timerfd_settime, int, ufd, int, flags,\n\t\tconst struct __kernel_itimerspec __user *, utmr,\n\t\tstruct __kernel_itimerspec __user *, otmr)\n{\n\tstruct itimerspec64 new, old;\n\tint ret;\n\n\tif (get_itimerspec64(&new, utmr))\n\t\treturn -EFAULT;\n\tret = do_timerfd_settime(ufd, flags, &new, &old);\n\tif (ret)\n\t\treturn ret;\n\tif (otmr && put_itimerspec64(&old, otmr))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE2(timerfd_gettime, int, ufd, struct __kernel_itimerspec __user *, otmr)\n{\n\tstruct itimerspec64 kotmr;\n\tint ret = do_timerfd_gettime(ufd, &kotmr);\n\tif (ret)\n\t\treturn ret;\n\treturn put_itimerspec64(&kotmr, otmr) ? -EFAULT : 0;\n}\n\n#ifdef CONFIG_COMPAT_32BIT_TIME\nSYSCALL_DEFINE4(timerfd_settime32, int, ufd, int, flags,\n\t\tconst struct old_itimerspec32 __user *, utmr,\n\t\tstruct old_itimerspec32 __user *, otmr)\n{\n\tstruct itimerspec64 new, old;\n\tint ret;\n\n\tif (get_old_itimerspec32(&new, utmr))\n\t\treturn -EFAULT;\n\tret = do_timerfd_settime(ufd, flags, &new, &old);\n\tif (ret)\n\t\treturn ret;\n\tif (otmr && put_old_itimerspec32(&old, otmr))\n\t\treturn -EFAULT;\n\treturn ret;\n}\n\nSYSCALL_DEFINE2(timerfd_gettime32, int, ufd,\n\t\tstruct old_itimerspec32 __user *, otmr)\n{\n\tstruct itimerspec64 kotmr;\n\tint ret = do_timerfd_gettime(ufd, &kotmr);\n\tif (ret)\n\t\treturn ret;\n\treturn put_old_itimerspec32(&kotmr, otmr) ? -EFAULT : 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}