{
  "module_name": "binfmt_flat.c",
  "hash_id": "8d0314417be3cbec983b845f2f4763fb0dde764aeeb8d6a5d12064a6e2213dfd",
  "original_prompt": "Ingested from linux-6.6.14/fs/binfmt_flat.c",
  "human_readable_source": "\n \n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/task_stack.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/ptrace.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/init.h>\n#include <linux/flat.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <asm/page.h>\n#include <asm/flat.h>\n\n#ifndef flat_get_relocate_addr\n#define flat_get_relocate_addr(rel)\t(rel)\n#endif\n\n \n\n \n#define FLAT_DATA_ALIGN\t(0x20)\n\n \n#define FLAT_STACK_ALIGN\tmax_t(unsigned long, sizeof(void *), ARCH_SLAB_MINALIGN)\n\n#define RELOC_FAILED 0xff00ff01\t\t \n#define UNLOADED_LIB 0x7ff000ff\t\t \n\n#define MAX_SHARED_LIBS\t\t\t(1)\n\n#ifdef CONFIG_BINFMT_FLAT_NO_DATA_START_OFFSET\n#define DATA_START_OFFSET_WORDS\t\t(0)\n#else\n#define DATA_START_OFFSET_WORDS\t\t(MAX_SHARED_LIBS)\n#endif\n\nstruct lib_info {\n\tstruct {\n\t\tunsigned long start_code;\t\t \n\t\tunsigned long start_data;\t\t \n\t\tunsigned long start_brk;\t\t \n\t\tunsigned long text_len;\t\t\t \n\t\tunsigned long entry;\t\t\t \n\t\tunsigned long build_date;\t\t \n\t\tbool loaded;\t\t\t\t \n\t} lib_list[MAX_SHARED_LIBS];\n};\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic struct linux_binfmt flat_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_flat_binary,\n};\n\n\n \n \n\nstatic int create_flat_tables(struct linux_binprm *bprm, unsigned long arg_start)\n{\n\tchar __user *p;\n\tunsigned long __user *sp;\n\tlong i, len;\n\n\tp = (char __user *)arg_start;\n\tsp = (unsigned long __user *)current->mm->start_stack;\n\n\tsp -= bprm->envc + 1;\n\tsp -= bprm->argc + 1;\n\tif (IS_ENABLED(CONFIG_BINFMT_FLAT_ARGVP_ENVP_ON_STACK))\n\t\tsp -= 2;  \n\tsp -= 1;   \n\n\tcurrent->mm->start_stack = (unsigned long)sp & -FLAT_STACK_ALIGN;\n\tsp = (unsigned long __user *)current->mm->start_stack;\n\n\tif (put_user(bprm->argc, sp++))\n\t\treturn -EFAULT;\n\tif (IS_ENABLED(CONFIG_BINFMT_FLAT_ARGVP_ENVP_ON_STACK)) {\n\t\tunsigned long argv, envp;\n\t\targv = (unsigned long)(sp + 2);\n\t\tenvp = (unsigned long)(sp + 2 + bprm->argc + 1);\n\t\tif (put_user(argv, sp++) || put_user(envp, sp++))\n\t\t\treturn -EFAULT;\n\t}\n\n\tcurrent->mm->arg_start = (unsigned long)p;\n\tfor (i = bprm->argc; i > 0; i--) {\n\t\tif (put_user((unsigned long)p, sp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (put_user(0, sp++))\n\t\treturn -EFAULT;\n\tcurrent->mm->arg_end = (unsigned long)p;\n\n\tcurrent->mm->env_start = (unsigned long) p;\n\tfor (i = bprm->envc; i > 0; i--) {\n\t\tif (put_user((unsigned long)p, sp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (put_user(0, sp++))\n\t\treturn -EFAULT;\n\tcurrent->mm->env_end = (unsigned long)p;\n\n\treturn 0;\n}\n\n \n\n#ifdef CONFIG_BINFMT_ZFLAT\n\n#include <linux/zlib.h>\n\n#define LBUFSIZE\t4000\n\n \n#define ASCII_FLAG   0x01  \n#define CONTINUATION 0x02  \n#define EXTRA_FIELD  0x04  \n#define ORIG_NAME    0x08  \n#define COMMENT      0x10  \n#define ENCRYPTED    0x20  \n#define RESERVED     0xC0  \n\nstatic int decompress_exec(struct linux_binprm *bprm, loff_t fpos, char *dst,\n\t\tlong len, int fd)\n{\n\tunsigned char *buf;\n\tz_stream strm;\n\tint ret, retval;\n\n\tpr_debug(\"decompress_exec(offset=%llx,buf=%p,len=%lx)\\n\", fpos, dst, len);\n\n\tmemset(&strm, 0, sizeof(strm));\n\tstrm.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (!strm.workspace)\n\t\treturn -ENOMEM;\n\n\tbuf = kmalloc(LBUFSIZE, GFP_KERNEL);\n\tif (!buf) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t \n\tret = kernel_read(bprm->file, buf, LBUFSIZE, &fpos);\n\n\tstrm.next_in = buf;\n\tstrm.avail_in = ret;\n\tstrm.total_in = 0;\n\n\tretval = -ENOEXEC;\n\n\t \n\tif (ret < 10) {\n\t\tpr_debug(\"file too small?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\t \n\tif ((buf[0] != 037) || ((buf[1] != 0213) && (buf[1] != 0236))) {\n\t\tpr_debug(\"unknown compression magic?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\t \n\tif (buf[2] != 8) {\n\t\tpr_debug(\"unknown compression method?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\t \n\tif ((buf[3] & ENCRYPTED) || (buf[3] & CONTINUATION) ||\n\t    (buf[3] & RESERVED)) {\n\t\tpr_debug(\"unknown flags?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\tret = 10;\n\tif (buf[3] & EXTRA_FIELD) {\n\t\tret += 2 + buf[10] + (buf[11] << 8);\n\t\tif (unlikely(ret >= LBUFSIZE)) {\n\t\t\tpr_debug(\"buffer overflow (EXTRA)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\tif (buf[3] & ORIG_NAME) {\n\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)\n\t\t\t;\n\t\tif (unlikely(ret == LBUFSIZE)) {\n\t\t\tpr_debug(\"buffer overflow (ORIG_NAME)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\tif (buf[3] & COMMENT) {\n\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)\n\t\t\t;\n\t\tif (unlikely(ret == LBUFSIZE)) {\n\t\t\tpr_debug(\"buffer overflow (COMMENT)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\n\tstrm.next_in += ret;\n\tstrm.avail_in -= ret;\n\n\tstrm.next_out = dst;\n\tstrm.avail_out = len;\n\tstrm.total_out = 0;\n\n\tif (zlib_inflateInit2(&strm, -MAX_WBITS) != Z_OK) {\n\t\tpr_debug(\"zlib init failed?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\twhile ((ret = zlib_inflate(&strm, Z_NO_FLUSH)) == Z_OK) {\n\t\tret = kernel_read(bprm->file, buf, LBUFSIZE, &fpos);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tlen -= ret;\n\n\t\tstrm.next_in = buf;\n\t\tstrm.avail_in = ret;\n\t\tstrm.total_in = 0;\n\t}\n\n\tif (ret < 0) {\n\t\tpr_debug(\"decompression failed (%d), %s\\n\",\n\t\t\tret, strm.msg);\n\t\tgoto out_zlib;\n\t}\n\n\tretval = 0;\nout_zlib:\n\tzlib_inflateEnd(&strm);\nout_free_buf:\n\tkfree(buf);\nout_free:\n\tkfree(strm.workspace);\n\treturn retval;\n}\n\n#endif  \n\n \n\nstatic unsigned long\ncalc_reloc(unsigned long r, struct lib_info *p)\n{\n\tunsigned long addr;\n\tunsigned long start_brk;\n\tunsigned long start_data;\n\tunsigned long text_len;\n\tunsigned long start_code;\n\n\tstart_brk = p->lib_list[0].start_brk;\n\tstart_data = p->lib_list[0].start_data;\n\tstart_code = p->lib_list[0].start_code;\n\ttext_len = p->lib_list[0].text_len;\n\n\tif (r > start_brk - start_data + text_len) {\n\t\tpr_err(\"reloc outside program 0x%lx (0 - 0x%lx/0x%lx)\",\n\t\t       r, start_brk-start_data+text_len, text_len);\n\t\tgoto failed;\n\t}\n\n\tif (r < text_len)\t\t\t \n\t\taddr = r + start_code;\n\telse\t\t\t\t\t \n\t\taddr = r - text_len + start_data;\n\n\t \n\treturn addr;\n\nfailed:\n\tpr_cont(\", killing %s!\\n\", current->comm);\n\tsend_sig(SIGSEGV, current, 0);\n\n\treturn RELOC_FAILED;\n}\n\n \n\n#ifdef CONFIG_BINFMT_FLAT_OLD\nstatic void old_reloc(unsigned long rl)\n{\n\tstatic const char *segment[] = { \"TEXT\", \"DATA\", \"BSS\", \"*UNKNOWN*\" };\n\tflat_v2_reloc_t\tr;\n\tunsigned long __user *ptr;\n\tunsigned long val;\n\n\tr.value = rl;\n#if defined(CONFIG_COLDFIRE)\n\tptr = (unsigned long __user *)(current->mm->start_code + r.reloc.offset);\n#else\n\tptr = (unsigned long __user *)(current->mm->start_data + r.reloc.offset);\n#endif\n\tget_user(val, ptr);\n\n\tpr_debug(\"Relocation of variable at DATASEG+%x \"\n\t\t \"(address %p, currently %lx) into segment %s\\n\",\n\t\t r.reloc.offset, ptr, val, segment[r.reloc.type]);\n\n\tswitch (r.reloc.type) {\n\tcase OLD_FLAT_RELOC_TYPE_TEXT:\n\t\tval += current->mm->start_code;\n\t\tbreak;\n\tcase OLD_FLAT_RELOC_TYPE_DATA:\n\t\tval += current->mm->start_data;\n\t\tbreak;\n\tcase OLD_FLAT_RELOC_TYPE_BSS:\n\t\tval += current->mm->end_data;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown relocation type=%x\\n\", r.reloc.type);\n\t\tbreak;\n\t}\n\tput_user(val, ptr);\n\n\tpr_debug(\"Relocation became %lx\\n\", val);\n}\n#endif  \n\n \n\nstatic inline u32 __user *skip_got_header(u32 __user *rp)\n{\n\tif (IS_ENABLED(CONFIG_RISCV)) {\n\t\t \n\t\tu32 rp_val0, rp_val1;\n\n\t\tif (get_user(rp_val0, rp))\n\t\t\treturn rp;\n\t\tif (get_user(rp_val1, rp + 1))\n\t\t\treturn rp;\n\n\t\tif (rp_val0 == 0xffffffff && rp_val1 == 0xffffffff)\n\t\t\trp += 4;\n\t\telse if (rp_val0 == 0xffffffff)\n\t\t\trp += 2;\n\t}\n\treturn rp;\n}\n\nstatic int load_flat_file(struct linux_binprm *bprm,\n\t\tstruct lib_info *libinfo, unsigned long *extra_stack)\n{\n\tstruct flat_hdr *hdr;\n\tunsigned long textpos, datapos, realdatastart;\n\tu32 text_len, data_len, bss_len, stack_len, full_data, flags;\n\tunsigned long len, memp, memp_size, extra, rlim;\n\t__be32 __user *reloc;\n\tu32 __user *rp;\n\tint i, rev, relocs;\n\tloff_t fpos;\n\tunsigned long start_code, end_code;\n\tssize_t result;\n\tint ret;\n\n\thdr = ((struct flat_hdr *) bprm->buf);\t\t \n\n\ttext_len  = ntohl(hdr->data_start);\n\tdata_len  = ntohl(hdr->data_end) - ntohl(hdr->data_start);\n\tbss_len   = ntohl(hdr->bss_end) - ntohl(hdr->data_end);\n\tstack_len = ntohl(hdr->stack_size);\n\tif (extra_stack) {\n\t\tstack_len += *extra_stack;\n\t\t*extra_stack = stack_len;\n\t}\n\trelocs    = ntohl(hdr->reloc_count);\n\tflags     = ntohl(hdr->flags);\n\trev       = ntohl(hdr->rev);\n\tfull_data = data_len + relocs * sizeof(unsigned long);\n\n\tif (strncmp(hdr->magic, \"bFLT\", 4)) {\n\t\t \n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tpr_info(\"Loading file: %s\\n\", bprm->filename);\n\n#ifdef CONFIG_BINFMT_FLAT_OLD\n\tif (rev != FLAT_VERSION && rev != OLD_FLAT_VERSION) {\n\t\tpr_err(\"bad flat file version 0x%x (supported 0x%lx and 0x%lx)\\n\",\n\t\t       rev, FLAT_VERSION, OLD_FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t \n\tif (rev == OLD_FLAT_VERSION &&\n\t   (flags || IS_ENABLED(CONFIG_BINFMT_FLAT_OLD_ALWAYS_RAM)))\n\t\tflags = FLAT_FLAG_RAM;\n\n#else  \n\tif (rev != FLAT_VERSION) {\n\t\tpr_err(\"bad flat file version 0x%x (supported 0x%lx)\\n\",\n\t\t       rev, FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n#endif  \n\n\t \n\tif ((text_len | data_len | bss_len | stack_len | full_data) >> 28) {\n\t\tpr_err(\"bad header\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n#ifndef CONFIG_BINFMT_ZFLAT\n\tif (flags & (FLAT_FLAG_GZIP|FLAT_FLAG_GZDATA)) {\n\t\tpr_err(\"Support for ZFLAT executables is not enabled.\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n#endif\n\n\t \n\trlim = rlimit(RLIMIT_DATA);\n\tif (rlim >= RLIM_INFINITY)\n\t\trlim = ~0;\n\tif (data_len + bss_len > rlim) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\tret = begin_new_exec(bprm);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tset_personality(PER_LINUX_32BIT);\n\tsetup_new_exec(bprm);\n\n\t \n\textra = max_t(unsigned long, bss_len + stack_len,\n\t\t\trelocs * sizeof(unsigned long));\n\n\t \n\tif (!IS_ENABLED(CONFIG_MMU) && !(flags & (FLAT_FLAG_RAM|FLAT_FLAG_GZIP))) {\n\t\t \n\t\tpr_debug(\"ROM mapping of file (we hope)\\n\");\n\n\t\ttextpos = vm_mmap(bprm->file, 0, text_len, PROT_READ|PROT_EXEC,\n\t\t\t\t  MAP_PRIVATE, 0);\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tret = textpos;\n\t\t\tif (!textpos)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to mmap process text, errno %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tlen = data_len + extra +\n\t\t\tDATA_START_OFFSET_WORDS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\trealdatastart = vm_mmap(NULL, 0, len,\n\t\t\tPROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE, 0);\n\n\t\tif (realdatastart == 0 || IS_ERR_VALUE(realdatastart)) {\n\t\t\tret = realdatastart;\n\t\t\tif (!realdatastart)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to allocate RAM for process data, \"\n\t\t\t       \"errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tgoto err;\n\t\t}\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tDATA_START_OFFSET_WORDS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\tpr_debug(\"Allocated data+bss+stack (%u bytes): %lx\\n\",\n\t\t\t data_len + bss_len + stack_len, datapos);\n\n\t\tfpos = ntohl(hdr->data_start);\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\tif (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = decompress_exec(bprm, fpos, (char *)datapos,\n\t\t\t\t\t\t full_data, 0);\n\t\t} else\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, datapos, fpos,\n\t\t\t\t\tfull_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tret = result;\n\t\t\tpr_err(\"Unable to read data+bss, errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tvm_munmap(realdatastart, len);\n\t\t\tgoto err;\n\t\t}\n\n\t\treloc = (__be32 __user *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = realdatastart;\n\t\tmemp_size = len;\n\t} else {\n\n\t\tlen = text_len + data_len + extra +\n\t\t\tDATA_START_OFFSET_WORDS * sizeof(u32);\n\t\tlen = PAGE_ALIGN(len);\n\t\ttextpos = vm_mmap(NULL, 0, len,\n\t\t\tPROT_READ | PROT_EXEC | PROT_WRITE, MAP_PRIVATE, 0);\n\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tret = textpos;\n\t\t\tif (!textpos)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to allocate RAM for process text/data, \"\n\t\t\t       \"errno %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\trealdatastart = textpos + ntohl(hdr->data_start);\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tDATA_START_OFFSET_WORDS * sizeof(u32),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\treloc = (__be32 __user *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = textpos;\n\t\tmemp_size = len;\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\t \n\t\tif (flags & FLAT_FLAG_GZIP) {\n#ifndef CONFIG_MMU\n\t\t\tresult = decompress_exec(bprm, sizeof(struct flat_hdr),\n\t\t\t\t\t (((char *)textpos) + sizeof(struct flat_hdr)),\n\t\t\t\t\t (text_len + full_data\n\t\t\t\t\t\t  - sizeof(struct flat_hdr)),\n\t\t\t\t\t 0);\n\t\t\tmemmove((void *) datapos, (void *) realdatastart,\n\t\t\t\t\tfull_data);\n#else\n\t\t\t \n\t\t\tlong unz_text_len = text_len - sizeof(struct flat_hdr);\n\t\t\tlong unz_len = unz_text_len + full_data;\n\t\t\tchar *unz_data = vmalloc(unz_len);\n\t\t\tif (!unz_data) {\n\t\t\t\tresult = -ENOMEM;\n\t\t\t} else {\n\t\t\t\tresult = decompress_exec(bprm, sizeof(struct flat_hdr),\n\t\t\t\t\t\t\t unz_data, unz_len, 0);\n\t\t\t\tif (result == 0 &&\n\t\t\t\t    (copy_to_user((void __user *)textpos + sizeof(struct flat_hdr),\n\t\t\t\t\t\t  unz_data, unz_text_len) ||\n\t\t\t\t     copy_to_user((void __user *)datapos,\n\t\t\t\t\t\t  unz_data + unz_text_len, full_data)))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t\tvfree(unz_data);\n\t\t\t}\n#endif\n\t\t} else if (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result)) {\n#ifndef CONFIG_MMU\n\t\t\t\tresult = decompress_exec(bprm, text_len, (char *) datapos,\n\t\t\t\t\t\t full_data, 0);\n#else\n\t\t\t\tchar *unz_data = vmalloc(full_data);\n\t\t\t\tif (!unz_data) {\n\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t} else {\n\t\t\t\t\tresult = decompress_exec(bprm, text_len,\n\t\t\t\t\t\t       unz_data, full_data, 0);\n\t\t\t\t\tif (result == 0 &&\n\t\t\t\t\t    copy_to_user((void __user *)datapos,\n\t\t\t\t\t\t\t unz_data, full_data))\n\t\t\t\t\t\tresult = -EFAULT;\n\t\t\t\t\tvfree(unz_data);\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t} else\n#endif  \n\t\t{\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = read_code(bprm->file, datapos,\n\t\t\t\t\t\t   ntohl(hdr->data_start),\n\t\t\t\t\t\t   full_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tret = result;\n\t\t\tpr_err(\"Unable to read code+data+bss, errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len + data_len + extra +\n\t\t\t\t  DATA_START_OFFSET_WORDS * sizeof(u32));\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tstart_code = textpos + sizeof(struct flat_hdr);\n\tend_code = textpos + text_len;\n\ttext_len -= sizeof(struct flat_hdr);  \n\n\t \n\tcurrent->mm->start_code = start_code;\n\tcurrent->mm->end_code = end_code;\n\tcurrent->mm->start_data = datapos;\n\tcurrent->mm->end_data = datapos + data_len;\n\t \n\tcurrent->mm->start_brk = datapos + data_len + bss_len;\n\tcurrent->mm->brk = (current->mm->start_brk + 3) & ~3;\n#ifndef CONFIG_MMU\n\tcurrent->mm->context.end_brk = memp + memp_size - stack_len;\n#endif\n\n\tif (flags & FLAT_FLAG_KTRACE) {\n\t\tpr_info(\"Mapping is %lx, Entry point is %x, data_start is %x\\n\",\n\t\t\ttextpos, 0x00ffffff&ntohl(hdr->entry), ntohl(hdr->data_start));\n\t\tpr_info(\"%s %s: TEXT=%lx-%lx DATA=%lx-%lx BSS=%lx-%lx\\n\",\n\t\t\t\"Load\", bprm->filename,\n\t\t\tstart_code, end_code, datapos, datapos + data_len,\n\t\t\tdatapos + data_len, (datapos + data_len + bss_len + 3) & ~3);\n\t}\n\n\t \n\tlibinfo->lib_list[0].start_code = start_code;\n\tlibinfo->lib_list[0].start_data = datapos;\n\tlibinfo->lib_list[0].start_brk = datapos + data_len + bss_len;\n\tlibinfo->lib_list[0].text_len = text_len;\n\tlibinfo->lib_list[0].loaded = 1;\n\tlibinfo->lib_list[0].entry = (0x00ffffff & ntohl(hdr->entry)) + textpos;\n\tlibinfo->lib_list[0].build_date = ntohl(hdr->build_date);\n\n\t \n\tif (flags & FLAT_FLAG_GOTPIC) {\n\t\trp = skip_got_header((u32 __user *) datapos);\n\t\tfor (; ; rp++) {\n\t\t\tu32 addr, rp_val;\n\t\t\tif (get_user(rp_val, rp))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (rp_val == 0xffffffff)\n\t\t\t\tbreak;\n\t\t\tif (rp_val) {\n\t\t\t\taddr = calc_reloc(rp_val, libinfo);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif (put_user(addr, rp))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (rev > OLD_FLAT_VERSION) {\n\t\tfor (i = 0; i < relocs; i++) {\n\t\t\tu32 addr, relval;\n\t\t\t__be32 tmp;\n\n\t\t\t \n\t\t\tif (get_user(tmp, reloc + i))\n\t\t\t\treturn -EFAULT;\n\t\t\trelval = ntohl(tmp);\n\t\t\taddr = flat_get_relocate_addr(relval);\n\t\t\trp = (u32 __user *)calc_reloc(addr, libinfo);\n\t\t\tif (rp == (u32 __user *)RELOC_FAILED) {\n\t\t\t\tret = -ENOEXEC;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = flat_get_addr_from_rp(rp, relval, flags, &addr);\n\t\t\tif (unlikely(ret))\n\t\t\t\tgoto err;\n\n\t\t\tif (addr != 0) {\n\t\t\t\t \n\t\t\t\tif ((flags & FLAT_FLAG_GOTPIC) == 0) {\n\t\t\t\t\t \n\t\t\t\t\taddr = ntohl((__force __be32)addr);\n\t\t\t\t}\n\t\t\t\taddr = calc_reloc(addr, libinfo);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tret = flat_put_addr_at_rp(rp, addr, relval);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifdef CONFIG_BINFMT_FLAT_OLD\n\t} else {\n\t\tfor (i = 0; i < relocs; i++) {\n\t\t\t__be32 relval;\n\t\t\tif (get_user(relval, reloc + i))\n\t\t\t\treturn -EFAULT;\n\t\t\told_reloc(ntohl(relval));\n\t\t}\n#endif  \n\t}\n\n\tflush_icache_user_range(start_code, end_code);\n\n\t \n\tif (clear_user((void __user *)(datapos + data_len), bss_len +\n\t\t       (memp + memp_size - stack_len -\t\t \n\t\t       libinfo->lib_list[0].start_brk) +\t \n\t\t       stack_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\n\n \n\n \n\nstatic int load_flat_binary(struct linux_binprm *bprm)\n{\n\tstruct lib_info libinfo;\n\tstruct pt_regs *regs = current_pt_regs();\n\tunsigned long stack_len = 0;\n\tunsigned long start_addr;\n\tint res;\n\tint i, j;\n\n\tmemset(&libinfo, 0, sizeof(libinfo));\n\n\t \n#ifndef CONFIG_MMU\n\tstack_len += PAGE_SIZE * MAX_ARG_PAGES - bprm->p;  \n#endif\n\tstack_len += (bprm->argc + 1) * sizeof(char *);    \n\tstack_len += (bprm->envc + 1) * sizeof(char *);    \n\tstack_len = ALIGN(stack_len, FLAT_STACK_ALIGN);\n\n\tres = load_flat_file(bprm, &libinfo, &stack_len);\n\tif (res < 0)\n\t\treturn res;\n\n\t \n\tfor (i = 0; i < MAX_SHARED_LIBS; i++) {\n\t\tif (!libinfo.lib_list[i].loaded)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < MAX_SHARED_LIBS; j++) {\n\t\t\tunsigned long val = libinfo.lib_list[j].loaded ?\n\t\t\t\tlibinfo.lib_list[j].start_data : UNLOADED_LIB;\n\t\t\tunsigned long __user *p = (unsigned long __user *)\n\t\t\t\tlibinfo.lib_list[i].start_data;\n\t\t\tp -= j + 1;\n\t\t\tif (put_user(val, p))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tset_binfmt(&flat_format);\n\n#ifdef CONFIG_MMU\n\tres = setup_arg_pages(bprm, STACK_TOP, EXSTACK_DEFAULT);\n\tif (!res)\n\t\tres = create_flat_tables(bprm, bprm->p);\n#else\n\t \n\tcurrent->mm->start_stack =\n\t\t((current->mm->context.end_brk + stack_len + 3) & ~3) - 4;\n\tpr_debug(\"sp=%lx\\n\", current->mm->start_stack);\n\n\t \n\tres = transfer_args_to_stack(bprm, &current->mm->start_stack);\n\tif (!res)\n\t\tres = create_flat_tables(bprm, current->mm->start_stack);\n#endif\n\tif (res)\n\t\treturn res;\n\n\t \n\tstart_addr = libinfo.lib_list[0].entry;\n\n#ifdef FLAT_PLAT_INIT\n\tFLAT_PLAT_INIT(regs);\n#endif\n\n\tfinalize_exec(bprm);\n\tpr_debug(\"start_thread(regs=0x%p, entry=0x%lx, start_stack=0x%lx)\\n\",\n\t\t regs, start_addr, current->mm->start_stack);\n\tstart_thread(regs, start_addr, current->mm->start_stack);\n\n\treturn 0;\n}\n\n \n\nstatic int __init init_flat_binfmt(void)\n{\n\tregister_binfmt(&flat_format);\n\treturn 0;\n}\ncore_initcall(init_flat_binfmt);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}