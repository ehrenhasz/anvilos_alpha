{
  "module_name": "stat.c",
  "hash_id": "14fd4601f8b67715094799c2b2f822ff2a9dd3f348fef39d536f820008f75557",
  "original_prompt": "Ingested from linux-6.6.14/fs/stat.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/file.h>\n#include <linux/highuid.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/security.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/compat.h>\n#include <linux/iversion.h>\n\n#include <linux/uaccess.h>\n#include <asm/unistd.h>\n\n#include \"internal.h\"\n#include \"mount.h\"\n\n \nvoid generic_fillattr(struct mnt_idmap *idmap, u32 request_mask,\n\t\t      struct inode *inode, struct kstat *stat)\n{\n\tvfsuid_t vfsuid = i_uid_into_vfsuid(idmap, inode);\n\tvfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode);\n\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = vfsuid_into_kuid(vfsuid);\n\tstat->gid = vfsgid_into_kgid(vfsgid);\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode_get_ctime(inode);\n\tstat->blksize = i_blocksize(inode);\n\tstat->blocks = inode->i_blocks;\n\n\tif ((request_mask & STATX_CHANGE_COOKIE) && IS_I_VERSION(inode)) {\n\t\tstat->result_mask |= STATX_CHANGE_COOKIE;\n\t\tstat->change_cookie = inode_query_iversion(inode);\n\t}\n\n}\nEXPORT_SYMBOL(generic_fillattr);\n\n \nvoid generic_fill_statx_attr(struct inode *inode, struct kstat *stat)\n{\n\tif (inode->i_flags & S_IMMUTABLE)\n\t\tstat->attributes |= STATX_ATTR_IMMUTABLE;\n\tif (inode->i_flags & S_APPEND)\n\t\tstat->attributes |= STATX_ATTR_APPEND;\n\tstat->attributes_mask |= KSTAT_ATTR_VFS_FLAGS;\n}\nEXPORT_SYMBOL(generic_fill_statx_attr);\n\n \nint vfs_getattr_nosec(const struct path *path, struct kstat *stat,\n\t\t      u32 request_mask, unsigned int query_flags)\n{\n\tstruct mnt_idmap *idmap;\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\n\tmemset(stat, 0, sizeof(*stat));\n\tstat->result_mask |= STATX_BASIC_STATS;\n\tquery_flags &= AT_STATX_SYNC_TYPE;\n\n\t \n\t \n\tif (inode->i_sb->s_flags & SB_NOATIME)\n\t\tstat->result_mask &= ~STATX_ATIME;\n\n\t \n\tif (IS_AUTOMOUNT(inode))\n\t\tstat->attributes |= STATX_ATTR_AUTOMOUNT;\n\n\tif (IS_DAX(inode))\n\t\tstat->attributes |= STATX_ATTR_DAX;\n\n\tstat->attributes_mask |= (STATX_ATTR_AUTOMOUNT |\n\t\t\t\t  STATX_ATTR_DAX);\n\n\tidmap = mnt_idmap(path->mnt);\n\tif (inode->i_op->getattr)\n\t\treturn inode->i_op->getattr(idmap, path, stat,\n\t\t\t\t\t    request_mask,\n\t\t\t\t\t    query_flags | AT_GETATTR_NOSEC);\n\n\tgeneric_fillattr(idmap, request_mask, inode, stat);\n\treturn 0;\n}\nEXPORT_SYMBOL(vfs_getattr_nosec);\n\n \nint vfs_getattr(const struct path *path, struct kstat *stat,\n\t\tu32 request_mask, unsigned int query_flags)\n{\n\tint retval;\n\n\tif (WARN_ON_ONCE(query_flags & AT_GETATTR_NOSEC))\n\t\treturn -EPERM;\n\n\tretval = security_inode_getattr(path);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat, request_mask, query_flags);\n}\nEXPORT_SYMBOL(vfs_getattr);\n\n \nint vfs_fstat(int fd, struct kstat *stat)\n{\n\tstruct fd f;\n\tint error;\n\n\tf = fdget_raw(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\terror = vfs_getattr(&f.file->f_path, stat, STATX_BASIC_STATS, 0);\n\tfdput(f);\n\treturn error;\n}\n\nint getname_statx_lookup_flags(int flags)\n{\n\tint lookup_flags = 0;\n\n\tif (!(flags & AT_SYMLINK_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\tif (!(flags & AT_NO_AUTOMOUNT))\n\t\tlookup_flags |= LOOKUP_AUTOMOUNT;\n\tif (flags & AT_EMPTY_PATH)\n\t\tlookup_flags |= LOOKUP_EMPTY;\n\n\treturn lookup_flags;\n}\n\n \nstatic int vfs_statx(int dfd, struct filename *filename, int flags,\n\t      struct kstat *stat, u32 request_mask)\n{\n\tstruct path path;\n\tunsigned int lookup_flags = getname_statx_lookup_flags(flags);\n\tint error;\n\n\tif (flags & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT | AT_EMPTY_PATH |\n\t\t      AT_STATX_SYNC_TYPE))\n\t\treturn -EINVAL;\n\nretry:\n\terror = filename_lookup(dfd, filename, lookup_flags, &path, NULL);\n\tif (error)\n\t\tgoto out;\n\n\terror = vfs_getattr(&path, stat, request_mask, flags);\n\n\tstat->mnt_id = real_mount(path.mnt)->mnt_id;\n\tstat->result_mask |= STATX_MNT_ID;\n\n\tif (path.mnt->mnt_root == path.dentry)\n\t\tstat->attributes |= STATX_ATTR_MOUNT_ROOT;\n\tstat->attributes_mask |= STATX_ATTR_MOUNT_ROOT;\n\n\t \n\tif (request_mask & STATX_DIOALIGN) {\n\t\tstruct inode *inode = d_backing_inode(path.dentry);\n\n\t\tif (S_ISBLK(inode->i_mode))\n\t\t\tbdev_statx_dioalign(inode, stat);\n\t}\n\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\treturn error;\n}\n\nint vfs_fstatat(int dfd, const char __user *filename,\n\t\t\t      struct kstat *stat, int flags)\n{\n\tint ret;\n\tint statx_flags = flags | AT_NO_AUTOMOUNT;\n\tstruct filename *name;\n\n\t \n\tif (dfd >= 0 && flags == AT_EMPTY_PATH) {\n\t\tchar c;\n\n\t\tret = get_user(c, filename);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\tif (likely(!c))\n\t\t\treturn vfs_fstat(dfd, stat);\n\t}\n\n\tname = getname_flags(filename, getname_statx_lookup_flags(statx_flags), NULL);\n\tret = vfs_statx(dfd, name, statx_flags, stat, STATX_BASIC_STATS);\n\tputname(name);\n\n\treturn ret;\n}\n\n#ifdef __ARCH_WANT_OLD_STAT\n\n \nstatic int cp_old_stat(struct kstat *stat, struct __old_kernel_stat __user * statbuf)\n{\n\tstatic int warncount = 5;\n\tstruct __old_kernel_stat tmp;\n\n\tif (warncount > 0) {\n\t\twarncount--;\n\t\tprintk(KERN_WARNING \"VFS: Warning: %s using old stat() call. Recompile your binary.\\n\",\n\t\t\tcurrent->comm);\n\t} else if (warncount < 0) {\n\t\t \n\t\twarncount = 0;\n\t}\n\n\tmemset(&tmp, 0, sizeof(struct __old_kernel_stat));\n\ttmp.st_dev = old_encode_dev(stat->dev);\n\ttmp.st_ino = stat->ino;\n\tif (sizeof(tmp.st_ino) < sizeof(stat->ino) && tmp.st_ino != stat->ino)\n\t\treturn -EOVERFLOW;\n\ttmp.st_mode = stat->mode;\n\ttmp.st_nlink = stat->nlink;\n\tif (tmp.st_nlink != stat->nlink)\n\t\treturn -EOVERFLOW;\n\tSET_UID(tmp.st_uid, from_kuid_munged(current_user_ns(), stat->uid));\n\tSET_GID(tmp.st_gid, from_kgid_munged(current_user_ns(), stat->gid));\n\ttmp.st_rdev = old_encode_dev(stat->rdev);\n#if BITS_PER_LONG == 32\n\tif (stat->size > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n#endif\n\ttmp.st_size = stat->size;\n\ttmp.st_atime = stat->atime.tv_sec;\n\ttmp.st_mtime = stat->mtime.tv_sec;\n\ttmp.st_ctime = stat->ctime.tv_sec;\n\treturn copy_to_user(statbuf,&tmp,sizeof(tmp)) ? -EFAULT : 0;\n}\n\nSYSCALL_DEFINE2(stat, const char __user *, filename,\n\t\tstruct __old_kernel_stat __user *, statbuf)\n{\n\tstruct kstat stat;\n\tint error;\n\n\terror = vfs_stat(filename, &stat);\n\tif (error)\n\t\treturn error;\n\n\treturn cp_old_stat(&stat, statbuf);\n}\n\nSYSCALL_DEFINE2(lstat, const char __user *, filename,\n\t\tstruct __old_kernel_stat __user *, statbuf)\n{\n\tstruct kstat stat;\n\tint error;\n\n\terror = vfs_lstat(filename, &stat);\n\tif (error)\n\t\treturn error;\n\n\treturn cp_old_stat(&stat, statbuf);\n}\n\nSYSCALL_DEFINE2(fstat, unsigned int, fd, struct __old_kernel_stat __user *, statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_fstat(fd, &stat);\n\n\tif (!error)\n\t\terror = cp_old_stat(&stat, statbuf);\n\n\treturn error;\n}\n\n#endif  \n\n#ifdef __ARCH_WANT_NEW_STAT\n\n#ifndef INIT_STRUCT_STAT_PADDING\n#  define INIT_STRUCT_STAT_PADDING(st) memset(&st, 0, sizeof(st))\n#endif\n\nstatic int cp_new_stat(struct kstat *stat, struct stat __user *statbuf)\n{\n\tstruct stat tmp;\n\n\tif (sizeof(tmp.st_dev) < 4 && !old_valid_dev(stat->dev))\n\t\treturn -EOVERFLOW;\n\tif (sizeof(tmp.st_rdev) < 4 && !old_valid_dev(stat->rdev))\n\t\treturn -EOVERFLOW;\n#if BITS_PER_LONG == 32\n\tif (stat->size > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n#endif\n\n\tINIT_STRUCT_STAT_PADDING(tmp);\n\ttmp.st_dev = new_encode_dev(stat->dev);\n\ttmp.st_ino = stat->ino;\n\tif (sizeof(tmp.st_ino) < sizeof(stat->ino) && tmp.st_ino != stat->ino)\n\t\treturn -EOVERFLOW;\n\ttmp.st_mode = stat->mode;\n\ttmp.st_nlink = stat->nlink;\n\tif (tmp.st_nlink != stat->nlink)\n\t\treturn -EOVERFLOW;\n\tSET_UID(tmp.st_uid, from_kuid_munged(current_user_ns(), stat->uid));\n\tSET_GID(tmp.st_gid, from_kgid_munged(current_user_ns(), stat->gid));\n\ttmp.st_rdev = new_encode_dev(stat->rdev);\n\ttmp.st_size = stat->size;\n\ttmp.st_atime = stat->atime.tv_sec;\n\ttmp.st_mtime = stat->mtime.tv_sec;\n\ttmp.st_ctime = stat->ctime.tv_sec;\n#ifdef STAT_HAVE_NSEC\n\ttmp.st_atime_nsec = stat->atime.tv_nsec;\n\ttmp.st_mtime_nsec = stat->mtime.tv_nsec;\n\ttmp.st_ctime_nsec = stat->ctime.tv_nsec;\n#endif\n\ttmp.st_blocks = stat->blocks;\n\ttmp.st_blksize = stat->blksize;\n\treturn copy_to_user(statbuf,&tmp,sizeof(tmp)) ? -EFAULT : 0;\n}\n\nSYSCALL_DEFINE2(newstat, const char __user *, filename,\n\t\tstruct stat __user *, statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_stat(filename, &stat);\n\n\tif (error)\n\t\treturn error;\n\treturn cp_new_stat(&stat, statbuf);\n}\n\nSYSCALL_DEFINE2(newlstat, const char __user *, filename,\n\t\tstruct stat __user *, statbuf)\n{\n\tstruct kstat stat;\n\tint error;\n\n\terror = vfs_lstat(filename, &stat);\n\tif (error)\n\t\treturn error;\n\n\treturn cp_new_stat(&stat, statbuf);\n}\n\n#if !defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_SYS_NEWFSTATAT)\nSYSCALL_DEFINE4(newfstatat, int, dfd, const char __user *, filename,\n\t\tstruct stat __user *, statbuf, int, flag)\n{\n\tstruct kstat stat;\n\tint error;\n\n\terror = vfs_fstatat(dfd, filename, &stat, flag);\n\tif (error)\n\t\treturn error;\n\treturn cp_new_stat(&stat, statbuf);\n}\n#endif\n\nSYSCALL_DEFINE2(newfstat, unsigned int, fd, struct stat __user *, statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_fstat(fd, &stat);\n\n\tif (!error)\n\t\terror = cp_new_stat(&stat, statbuf);\n\n\treturn error;\n}\n#endif\n\nstatic int do_readlinkat(int dfd, const char __user *pathname,\n\t\t\t char __user *buf, int bufsiz)\n{\n\tstruct path path;\n\tint error;\n\tint empty = 0;\n\tunsigned int lookup_flags = LOOKUP_EMPTY;\n\n\tif (bufsiz <= 0)\n\t\treturn -EINVAL;\n\nretry:\n\terror = user_path_at_empty(dfd, pathname, lookup_flags, &path, &empty);\n\tif (!error) {\n\t\tstruct inode *inode = d_backing_inode(path.dentry);\n\n\t\terror = empty ? -ENOENT : -EINVAL;\n\t\t \n\t\tif (d_is_symlink(path.dentry) || inode->i_op->readlink) {\n\t\t\terror = security_inode_readlink(path.dentry);\n\t\t\tif (!error) {\n\t\t\t\ttouch_atime(&path);\n\t\t\t\terror = vfs_readlink(path.dentry, buf, bufsiz);\n\t\t\t}\n\t\t}\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE4(readlinkat, int, dfd, const char __user *, pathname,\n\t\tchar __user *, buf, int, bufsiz)\n{\n\treturn do_readlinkat(dfd, pathname, buf, bufsiz);\n}\n\nSYSCALL_DEFINE3(readlink, const char __user *, path, char __user *, buf,\n\t\tint, bufsiz)\n{\n\treturn do_readlinkat(AT_FDCWD, path, buf, bufsiz);\n}\n\n\n \n#if defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64)\n\n#ifndef INIT_STRUCT_STAT64_PADDING\n#  define INIT_STRUCT_STAT64_PADDING(st) memset(&st, 0, sizeof(st))\n#endif\n\nstatic long cp_new_stat64(struct kstat *stat, struct stat64 __user *statbuf)\n{\n\tstruct stat64 tmp;\n\n\tINIT_STRUCT_STAT64_PADDING(tmp);\n#ifdef CONFIG_MIPS\n\t \n\ttmp.st_dev = new_encode_dev(stat->dev);\n\ttmp.st_rdev = new_encode_dev(stat->rdev);\n#else\n\ttmp.st_dev = huge_encode_dev(stat->dev);\n\ttmp.st_rdev = huge_encode_dev(stat->rdev);\n#endif\n\ttmp.st_ino = stat->ino;\n\tif (sizeof(tmp.st_ino) < sizeof(stat->ino) && tmp.st_ino != stat->ino)\n\t\treturn -EOVERFLOW;\n#ifdef STAT64_HAS_BROKEN_ST_INO\n\ttmp.__st_ino = stat->ino;\n#endif\n\ttmp.st_mode = stat->mode;\n\ttmp.st_nlink = stat->nlink;\n\ttmp.st_uid = from_kuid_munged(current_user_ns(), stat->uid);\n\ttmp.st_gid = from_kgid_munged(current_user_ns(), stat->gid);\n\ttmp.st_atime = stat->atime.tv_sec;\n\ttmp.st_atime_nsec = stat->atime.tv_nsec;\n\ttmp.st_mtime = stat->mtime.tv_sec;\n\ttmp.st_mtime_nsec = stat->mtime.tv_nsec;\n\ttmp.st_ctime = stat->ctime.tv_sec;\n\ttmp.st_ctime_nsec = stat->ctime.tv_nsec;\n\ttmp.st_size = stat->size;\n\ttmp.st_blocks = stat->blocks;\n\ttmp.st_blksize = stat->blksize;\n\treturn copy_to_user(statbuf,&tmp,sizeof(tmp)) ? -EFAULT : 0;\n}\n\nSYSCALL_DEFINE2(stat64, const char __user *, filename,\n\t\tstruct stat64 __user *, statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_stat(filename, &stat);\n\n\tif (!error)\n\t\terror = cp_new_stat64(&stat, statbuf);\n\n\treturn error;\n}\n\nSYSCALL_DEFINE2(lstat64, const char __user *, filename,\n\t\tstruct stat64 __user *, statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_lstat(filename, &stat);\n\n\tif (!error)\n\t\terror = cp_new_stat64(&stat, statbuf);\n\n\treturn error;\n}\n\nSYSCALL_DEFINE2(fstat64, unsigned long, fd, struct stat64 __user *, statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_fstat(fd, &stat);\n\n\tif (!error)\n\t\terror = cp_new_stat64(&stat, statbuf);\n\n\treturn error;\n}\n\nSYSCALL_DEFINE4(fstatat64, int, dfd, const char __user *, filename,\n\t\tstruct stat64 __user *, statbuf, int, flag)\n{\n\tstruct kstat stat;\n\tint error;\n\n\terror = vfs_fstatat(dfd, filename, &stat, flag);\n\tif (error)\n\t\treturn error;\n\treturn cp_new_stat64(&stat, statbuf);\n}\n#endif  \n\nstatic noinline_for_stack int\ncp_statx(const struct kstat *stat, struct statx __user *buffer)\n{\n\tstruct statx tmp;\n\n\tmemset(&tmp, 0, sizeof(tmp));\n\n\t \n\ttmp.stx_mask = stat->result_mask & ~STATX_CHANGE_COOKIE;\n\ttmp.stx_blksize = stat->blksize;\n\t \n\ttmp.stx_attributes = stat->attributes & ~STATX_ATTR_CHANGE_MONOTONIC;\n\ttmp.stx_nlink = stat->nlink;\n\ttmp.stx_uid = from_kuid_munged(current_user_ns(), stat->uid);\n\ttmp.stx_gid = from_kgid_munged(current_user_ns(), stat->gid);\n\ttmp.stx_mode = stat->mode;\n\ttmp.stx_ino = stat->ino;\n\ttmp.stx_size = stat->size;\n\ttmp.stx_blocks = stat->blocks;\n\ttmp.stx_attributes_mask = stat->attributes_mask;\n\ttmp.stx_atime.tv_sec = stat->atime.tv_sec;\n\ttmp.stx_atime.tv_nsec = stat->atime.tv_nsec;\n\ttmp.stx_btime.tv_sec = stat->btime.tv_sec;\n\ttmp.stx_btime.tv_nsec = stat->btime.tv_nsec;\n\ttmp.stx_ctime.tv_sec = stat->ctime.tv_sec;\n\ttmp.stx_ctime.tv_nsec = stat->ctime.tv_nsec;\n\ttmp.stx_mtime.tv_sec = stat->mtime.tv_sec;\n\ttmp.stx_mtime.tv_nsec = stat->mtime.tv_nsec;\n\ttmp.stx_rdev_major = MAJOR(stat->rdev);\n\ttmp.stx_rdev_minor = MINOR(stat->rdev);\n\ttmp.stx_dev_major = MAJOR(stat->dev);\n\ttmp.stx_dev_minor = MINOR(stat->dev);\n\ttmp.stx_mnt_id = stat->mnt_id;\n\ttmp.stx_dio_mem_align = stat->dio_mem_align;\n\ttmp.stx_dio_offset_align = stat->dio_offset_align;\n\n\treturn copy_to_user(buffer, &tmp, sizeof(tmp)) ? -EFAULT : 0;\n}\n\nint do_statx(int dfd, struct filename *filename, unsigned int flags,\n\t     unsigned int mask, struct statx __user *buffer)\n{\n\tstruct kstat stat;\n\tint error;\n\n\tif (mask & STATX__RESERVED)\n\t\treturn -EINVAL;\n\tif ((flags & AT_STATX_SYNC_TYPE) == AT_STATX_SYNC_TYPE)\n\t\treturn -EINVAL;\n\n\t \n\tmask &= ~STATX_CHANGE_COOKIE;\n\n\terror = vfs_statx(dfd, filename, flags, &stat, mask);\n\tif (error)\n\t\treturn error;\n\n\treturn cp_statx(&stat, buffer);\n}\n\n \nSYSCALL_DEFINE5(statx,\n\t\tint, dfd, const char __user *, filename, unsigned, flags,\n\t\tunsigned int, mask,\n\t\tstruct statx __user *, buffer)\n{\n\tint ret;\n\tstruct filename *name;\n\n\tname = getname_flags(filename, getname_statx_lookup_flags(flags), NULL);\n\tret = do_statx(dfd, name, flags, mask, buffer);\n\tputname(name);\n\n\treturn ret;\n}\n\n#if defined(CONFIG_COMPAT) && defined(__ARCH_WANT_COMPAT_STAT)\nstatic int cp_compat_stat(struct kstat *stat, struct compat_stat __user *ubuf)\n{\n\tstruct compat_stat tmp;\n\n\tif (sizeof(tmp.st_dev) < 4 && !old_valid_dev(stat->dev))\n\t\treturn -EOVERFLOW;\n\tif (sizeof(tmp.st_rdev) < 4 && !old_valid_dev(stat->rdev))\n\t\treturn -EOVERFLOW;\n\n\tmemset(&tmp, 0, sizeof(tmp));\n\ttmp.st_dev = new_encode_dev(stat->dev);\n\ttmp.st_ino = stat->ino;\n\tif (sizeof(tmp.st_ino) < sizeof(stat->ino) && tmp.st_ino != stat->ino)\n\t\treturn -EOVERFLOW;\n\ttmp.st_mode = stat->mode;\n\ttmp.st_nlink = stat->nlink;\n\tif (tmp.st_nlink != stat->nlink)\n\t\treturn -EOVERFLOW;\n\tSET_UID(tmp.st_uid, from_kuid_munged(current_user_ns(), stat->uid));\n\tSET_GID(tmp.st_gid, from_kgid_munged(current_user_ns(), stat->gid));\n\ttmp.st_rdev = new_encode_dev(stat->rdev);\n\tif ((u64) stat->size > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n\ttmp.st_size = stat->size;\n\ttmp.st_atime = stat->atime.tv_sec;\n\ttmp.st_atime_nsec = stat->atime.tv_nsec;\n\ttmp.st_mtime = stat->mtime.tv_sec;\n\ttmp.st_mtime_nsec = stat->mtime.tv_nsec;\n\ttmp.st_ctime = stat->ctime.tv_sec;\n\ttmp.st_ctime_nsec = stat->ctime.tv_nsec;\n\ttmp.st_blocks = stat->blocks;\n\ttmp.st_blksize = stat->blksize;\n\treturn copy_to_user(ubuf, &tmp, sizeof(tmp)) ? -EFAULT : 0;\n}\n\nCOMPAT_SYSCALL_DEFINE2(newstat, const char __user *, filename,\n\t\t       struct compat_stat __user *, statbuf)\n{\n\tstruct kstat stat;\n\tint error;\n\n\terror = vfs_stat(filename, &stat);\n\tif (error)\n\t\treturn error;\n\treturn cp_compat_stat(&stat, statbuf);\n}\n\nCOMPAT_SYSCALL_DEFINE2(newlstat, const char __user *, filename,\n\t\t       struct compat_stat __user *, statbuf)\n{\n\tstruct kstat stat;\n\tint error;\n\n\terror = vfs_lstat(filename, &stat);\n\tif (error)\n\t\treturn error;\n\treturn cp_compat_stat(&stat, statbuf);\n}\n\n#ifndef __ARCH_WANT_STAT64\nCOMPAT_SYSCALL_DEFINE4(newfstatat, unsigned int, dfd,\n\t\t       const char __user *, filename,\n\t\t       struct compat_stat __user *, statbuf, int, flag)\n{\n\tstruct kstat stat;\n\tint error;\n\n\terror = vfs_fstatat(dfd, filename, &stat, flag);\n\tif (error)\n\t\treturn error;\n\treturn cp_compat_stat(&stat, statbuf);\n}\n#endif\n\nCOMPAT_SYSCALL_DEFINE2(newfstat, unsigned int, fd,\n\t\t       struct compat_stat __user *, statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_fstat(fd, &stat);\n\n\tif (!error)\n\t\terror = cp_compat_stat(&stat, statbuf);\n\treturn error;\n}\n#endif\n\n \nvoid __inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tinode->i_blocks += bytes >> 9;\n\tbytes &= 511;\n\tinode->i_bytes += bytes;\n\tif (inode->i_bytes >= 512) {\n\t\tinode->i_blocks++;\n\t\tinode->i_bytes -= 512;\n\t}\n}\nEXPORT_SYMBOL(__inode_add_bytes);\n\nvoid inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}\n\nEXPORT_SYMBOL(inode_add_bytes);\n\nvoid __inode_sub_bytes(struct inode *inode, loff_t bytes)\n{\n\tinode->i_blocks -= bytes >> 9;\n\tbytes &= 511;\n\tif (inode->i_bytes < bytes) {\n\t\tinode->i_blocks--;\n\t\tinode->i_bytes += 512;\n\t}\n\tinode->i_bytes -= bytes;\n}\n\nEXPORT_SYMBOL(__inode_sub_bytes);\n\nvoid inode_sub_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_sub_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}\n\nEXPORT_SYMBOL(inode_sub_bytes);\n\nloff_t inode_get_bytes(struct inode *inode)\n{\n\tloff_t ret;\n\n\tspin_lock(&inode->i_lock);\n\tret = __inode_get_bytes(inode);\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}\n\nEXPORT_SYMBOL(inode_get_bytes);\n\nvoid inode_set_bytes(struct inode *inode, loff_t bytes)\n{\n\t \n\tinode->i_blocks = bytes >> 9;\n\tinode->i_bytes = bytes & 511;\n}\n\nEXPORT_SYMBOL(inode_set_bytes);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}