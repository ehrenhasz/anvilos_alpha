{
  "module_name": "autofs_i.h",
  "hash_id": "4637fac007ab01c2add3eebfbd4a554b0eb44b58f85df4e7b6c94585b723c465",
  "original_prompt": "Ingested from linux-6.6.14/fs/autofs/autofs_i.h",
  "human_readable_source": " \n \n\n \n\n#include <linux/auto_fs.h>\n#include <linux/auto_dev-ioctl.h>\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/sched/signal.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/completion.h>\n#include <linux/file.h>\n#include <linux/magic.h>\n\n \n#define AUTOFS_IOC_FIRST     AUTOFS_IOC_READY\n#define AUTOFS_IOC_COUNT     32\n\n#define AUTOFS_DEV_IOCTL_IOC_FIRST\t(AUTOFS_DEV_IOCTL_VERSION)\n#define AUTOFS_DEV_IOCTL_IOC_COUNT \\\n\t(AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD - AUTOFS_DEV_IOCTL_VERSION_CMD)\n\n#ifdef pr_fmt\n#undef pr_fmt\n#endif\n#define pr_fmt(fmt) KBUILD_MODNAME \":pid:%d:%s: \" fmt, current->pid, __func__\n\nextern struct file_system_type autofs_fs_type;\n\n \nstruct autofs_info {\n\tstruct dentry\t*dentry;\n\tint\t\tflags;\n\n\tstruct completion expire_complete;\n\n\tstruct list_head active;\n\n\tstruct list_head expiring;\n\n\tstruct autofs_sb_info *sbi;\n\tunsigned long last_used;\n\tint count;\n\n\tkuid_t uid;\n\tkgid_t gid;\n\tstruct rcu_head rcu;\n};\n\n#define AUTOFS_INF_EXPIRING\t(1<<0)  \n#define AUTOFS_INF_WANT_EXPIRE\t(1<<1)  \n#define AUTOFS_INF_PENDING\t(1<<2)  \n\nstruct autofs_wait_queue {\n\twait_queue_head_t queue;\n\tstruct autofs_wait_queue *next;\n\tautofs_wqt_t wait_queue_token;\n\t \n\tstruct qstr name;\n\tu32 offset;\n\tu32 dev;\n\tu64 ino;\n\tkuid_t uid;\n\tkgid_t gid;\n\tpid_t pid;\n\tpid_t tgid;\n\t \n\tint status;\n\tunsigned int wait_ctr;\n};\n\n#define AUTOFS_SBI_MAGIC 0x6d4a556d\n\n#define AUTOFS_SBI_CATATONIC\t0x0001\n#define AUTOFS_SBI_STRICTEXPIRE 0x0002\n#define AUTOFS_SBI_IGNORE\t0x0004\n\nstruct autofs_sb_info {\n\tu32 magic;\n\tint pipefd;\n\tstruct file *pipe;\n\tstruct pid *oz_pgrp;\n\tint version;\n\tint sub_version;\n\tint min_proto;\n\tint max_proto;\n\tunsigned int flags;\n\tunsigned long exp_timeout;\n\tunsigned int type;\n\tstruct super_block *sb;\n\tstruct mutex wq_mutex;\n\tstruct mutex pipe_mutex;\n\tspinlock_t fs_lock;\n\tstruct autofs_wait_queue *queues;  \n\tspinlock_t lookup_lock;\n\tstruct list_head active_list;\n\tstruct list_head expiring_list;\n\tstruct rcu_head rcu;\n};\n\nstatic inline struct autofs_sb_info *autofs_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}\n\nstatic inline struct autofs_info *autofs_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}\n\n \nstatic inline int autofs_oz_mode(struct autofs_sb_info *sbi)\n{\n\treturn ((sbi->flags & AUTOFS_SBI_CATATONIC) ||\n\t\t task_pgrp(current) == sbi->oz_pgrp);\n}\n\nstatic inline bool autofs_empty(struct autofs_info *ino)\n{\n\treturn ino->count < 2;\n}\n\nstruct inode *autofs_get_inode(struct super_block *, umode_t);\nvoid autofs_free_ino(struct autofs_info *);\n\n \nint is_autofs_dentry(struct dentry *);\nint autofs_expire_wait(const struct path *path, int rcu_walk);\nint autofs_expire_run(struct super_block *, struct vfsmount *,\n\t\t      struct autofs_sb_info *,\n\t\t      struct autofs_packet_expire __user *);\nint autofs_do_expire_multi(struct super_block *sb, struct vfsmount *mnt,\n\t\t\t   struct autofs_sb_info *sbi, unsigned int how);\nint autofs_expire_multi(struct super_block *, struct vfsmount *,\n\t\t\tstruct autofs_sb_info *, int __user *);\n\n \n\nint autofs_dev_ioctl_init(void);\nvoid autofs_dev_ioctl_exit(void);\n\n \n\nextern const struct inode_operations autofs_symlink_inode_operations;\nextern const struct inode_operations autofs_dir_inode_operations;\nextern const struct file_operations autofs_dir_operations;\nextern const struct file_operations autofs_root_operations;\nextern const struct dentry_operations autofs_dentry_operations;\n\n \nstatic inline void __managed_dentry_set_managed(struct dentry *dentry)\n{\n\tdentry->d_flags |= (DCACHE_NEED_AUTOMOUNT|DCACHE_MANAGE_TRANSIT);\n}\n\nstatic inline void managed_dentry_set_managed(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\t__managed_dentry_set_managed(dentry);\n\tspin_unlock(&dentry->d_lock);\n}\n\nstatic inline void __managed_dentry_clear_managed(struct dentry *dentry)\n{\n\tdentry->d_flags &= ~(DCACHE_NEED_AUTOMOUNT|DCACHE_MANAGE_TRANSIT);\n}\n\nstatic inline void managed_dentry_clear_managed(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\t__managed_dentry_clear_managed(dentry);\n\tspin_unlock(&dentry->d_lock);\n}\n\n \n\nint autofs_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs_new_ino(struct autofs_sb_info *);\nvoid autofs_clean_ino(struct autofs_info *);\n\nstatic inline int autofs_prepare_pipe(struct file *pipe)\n{\n\tif (!(pipe->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\tif (!S_ISFIFO(file_inode(pipe)->i_mode))\n\t\treturn -EINVAL;\n\t \n\tpipe->f_flags |= O_DIRECT;\n\t \n\tpipe->f_flags &= ~O_NONBLOCK;\n\treturn 0;\n}\n\n \n\nint autofs_wait(struct autofs_sb_info *,\n\t\t const struct path *, enum autofs_notify);\nint autofs_wait_release(struct autofs_sb_info *, autofs_wqt_t, int);\nvoid autofs_catatonic_mode(struct autofs_sb_info *);\n\nstatic inline u32 autofs_get_dev(struct autofs_sb_info *sbi)\n{\n\treturn new_encode_dev(sbi->sb->s_dev);\n}\n\nstatic inline u64 autofs_get_ino(struct autofs_sb_info *sbi)\n{\n\treturn d_inode(sbi->sb->s_root)->i_ino;\n}\n\nstatic inline void __autofs_add_expiring(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs_dentry_ino(dentry);\n\n\tif (ino) {\n\t\tif (list_empty(&ino->expiring))\n\t\t\tlist_add(&ino->expiring, &sbi->expiring_list);\n\t}\n}\n\nstatic inline void autofs_add_expiring(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs_dentry_ino(dentry);\n\n\tif (ino) {\n\t\tspin_lock(&sbi->lookup_lock);\n\t\tif (list_empty(&ino->expiring))\n\t\t\tlist_add(&ino->expiring, &sbi->expiring_list);\n\t\tspin_unlock(&sbi->lookup_lock);\n\t}\n}\n\nstatic inline void autofs_del_expiring(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs_dentry_ino(dentry);\n\n\tif (ino) {\n\t\tspin_lock(&sbi->lookup_lock);\n\t\tif (!list_empty(&ino->expiring))\n\t\t\tlist_del_init(&ino->expiring);\n\t\tspin_unlock(&sbi->lookup_lock);\n\t}\n}\n\nvoid autofs_kill_sb(struct super_block *);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}