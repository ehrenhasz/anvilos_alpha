{
  "module_name": "waitq.c",
  "hash_id": "55966aad3de7ed10357cb88d1bd6df077b83f62852faee0eadd7e9088f97f37d",
  "original_prompt": "Ingested from linux-6.6.14/fs/autofs/waitq.c",
  "human_readable_source": "\n \n\n#include <linux/sched/signal.h>\n#include \"autofs_i.h\"\n\n \nstatic autofs_wqt_t autofs_next_wait_queue = 1;\n\nvoid autofs_catatonic_mode(struct autofs_sb_info *sbi)\n{\n\tstruct autofs_wait_queue *wq, *nwq;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tif (sbi->flags & AUTOFS_SBI_CATATONIC) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn;\n\t}\n\n\tpr_debug(\"entering catatonic mode\\n\");\n\n\tsbi->flags |= AUTOFS_SBI_CATATONIC;\n\twq = sbi->queues;\n\tsbi->queues = NULL;\t \n\twhile (wq) {\n\t\tnwq = wq->next;\n\t\twq->status = -ENOENT;  \n\t\tkfree(wq->name.name - wq->offset);\n\t\twq->name.name = NULL;\n\t\twake_up(&wq->queue);\n\t\tif (!--wq->wait_ctr)\n\t\t\tkfree(wq);\n\t\twq = nwq;\n\t}\n\tfput(sbi->pipe);\t \n\tsbi->pipe = NULL;\n\tsbi->pipefd = -1;\n\tmutex_unlock(&sbi->wq_mutex);\n}\n\nstatic int autofs_write(struct autofs_sb_info *sbi,\n\t\t\tstruct file *file, const void *addr, int bytes)\n{\n\tunsigned long sigpipe, flags;\n\tconst char *data = (const char *)addr;\n\tssize_t wr = 0;\n\n\tsigpipe = sigismember(&current->pending.signal, SIGPIPE);\n\n\tmutex_lock(&sbi->pipe_mutex);\n\twhile (bytes) {\n\t\twr = __kernel_write(file, data, bytes, NULL);\n\t\tif (wr <= 0)\n\t\t\tbreak;\n\t\tdata += wr;\n\t\tbytes -= wr;\n\t}\n\tmutex_unlock(&sbi->pipe_mutex);\n\n\t \n\tif (wr == -EPIPE && !sigpipe) {\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\tsigdelset(&current->pending.signal, SIGPIPE);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t}\n\n\t \n\treturn bytes == 0 ? 0 : wr < 0 ? wr : -EIO;\n}\n\nstatic void autofs_notify_daemon(struct autofs_sb_info *sbi,\n\t\t\t\t struct autofs_wait_queue *wq,\n\t\t\t\t int type)\n{\n\tunion {\n\t\tstruct autofs_packet_hdr hdr;\n\t\tunion autofs_packet_union v4_pkt;\n\t\tunion autofs_v5_packet_union v5_pkt;\n\t} pkt;\n\tstruct file *pipe = NULL;\n\tsize_t pktsz;\n\tint ret;\n\n\tpr_debug(\"wait id = 0x%08lx, name = %.*s, type=%d\\n\",\n\t\t (unsigned long) wq->wait_queue_token,\n\t\t wq->name.len, wq->name.name, type);\n\n\tmemset(&pkt, 0, sizeof(pkt));  \n\n\tpkt.hdr.proto_version = sbi->version;\n\tpkt.hdr.type = type;\n\n\tswitch (type) {\n\t \n\tcase autofs_ptype_missing:\n\t{\n\t\tstruct autofs_packet_missing *mp = &pkt.v4_pkt.missing;\n\n\t\tpktsz = sizeof(*mp);\n\n\t\tmp->wait_queue_token = wq->wait_queue_token;\n\t\tmp->len = wq->name.len;\n\t\tmemcpy(mp->name, wq->name.name, wq->name.len);\n\t\tmp->name[wq->name.len] = '\\0';\n\t\tbreak;\n\t}\n\tcase autofs_ptype_expire_multi:\n\t{\n\t\tstruct autofs_packet_expire_multi *ep =\n\t\t\t\t\t&pkt.v4_pkt.expire_multi;\n\n\t\tpktsz = sizeof(*ep);\n\n\t\tep->wait_queue_token = wq->wait_queue_token;\n\t\tep->len = wq->name.len;\n\t\tmemcpy(ep->name, wq->name.name, wq->name.len);\n\t\tep->name[wq->name.len] = '\\0';\n\t\tbreak;\n\t}\n\t \n\tcase autofs_ptype_missing_indirect:\n\tcase autofs_ptype_expire_indirect:\n\tcase autofs_ptype_missing_direct:\n\tcase autofs_ptype_expire_direct:\n\t{\n\t\tstruct autofs_v5_packet *packet = &pkt.v5_pkt.v5_packet;\n\t\tstruct user_namespace *user_ns = sbi->pipe->f_cred->user_ns;\n\n\t\tpktsz = sizeof(*packet);\n\n\t\tpacket->wait_queue_token = wq->wait_queue_token;\n\t\tpacket->len = wq->name.len;\n\t\tmemcpy(packet->name, wq->name.name, wq->name.len);\n\t\tpacket->name[wq->name.len] = '\\0';\n\t\tpacket->dev = wq->dev;\n\t\tpacket->ino = wq->ino;\n\t\tpacket->uid = from_kuid_munged(user_ns, wq->uid);\n\t\tpacket->gid = from_kgid_munged(user_ns, wq->gid);\n\t\tpacket->pid = wq->pid;\n\t\tpacket->tgid = wq->tgid;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpr_warn(\"bad type %d!\\n\", type);\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn;\n\t}\n\n\tpipe = get_file(sbi->pipe);\n\n\tmutex_unlock(&sbi->wq_mutex);\n\n\tswitch (ret = autofs_write(sbi, pipe, &pkt, pktsz)) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOMEM:\n\tcase -ERESTARTSYS:\n\t\t \n\t\tautofs_wait_release(sbi, wq->wait_queue_token, ret);\n\t\tbreak;\n\tdefault:\n\t\tautofs_catatonic_mode(sbi);\n\t\tbreak;\n\t}\n\tfput(pipe);\n}\n\nstatic struct autofs_wait_queue *\nautofs_find_wait(struct autofs_sb_info *sbi, const struct qstr *qstr)\n{\n\tstruct autofs_wait_queue *wq;\n\n\tfor (wq = sbi->queues; wq; wq = wq->next) {\n\t\tif (wq->name.hash == qstr->hash &&\n\t\t    wq->name.len == qstr->len &&\n\t\t    wq->name.name &&\n\t\t    !memcmp(wq->name.name, qstr->name, qstr->len))\n\t\t\tbreak;\n\t}\n\treturn wq;\n}\n\n \nstatic int validate_request(struct autofs_wait_queue **wait,\n\t\t\t    struct autofs_sb_info *sbi,\n\t\t\t    const struct qstr *qstr,\n\t\t\t    const struct path *path, enum autofs_notify notify)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct autofs_wait_queue *wq;\n\tstruct autofs_info *ino;\n\n\tif (sbi->flags & AUTOFS_SBI_CATATONIC)\n\t\treturn -ENOENT;\n\n\t \n\twq = autofs_find_wait(sbi, qstr);\n\tif (wq) {\n\t\t*wait = wq;\n\t\treturn 1;\n\t}\n\n\t*wait = NULL;\n\n\t \n\tino = autofs_dentry_ino(dentry);\n\tif (!ino)\n\t\treturn 1;\n\n\t \n\tif (notify == NFY_NONE) {\n\t\t \n\n\t\twhile (ino->flags & AUTOFS_INF_EXPIRING) {\n\t\t\tmutex_unlock(&sbi->wq_mutex);\n\t\t\tschedule_timeout_interruptible(HZ/10);\n\t\t\tif (mutex_lock_interruptible(&sbi->wq_mutex))\n\t\t\t\treturn -EINTR;\n\n\t\t\tif (sbi->flags & AUTOFS_SBI_CATATONIC)\n\t\t\t\treturn -ENOENT;\n\n\t\t\twq = autofs_find_wait(sbi, qstr);\n\t\t\tif (wq) {\n\t\t\t\t*wait = wq;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tif (notify == NFY_MOUNT) {\n\t\tstruct dentry *new = NULL;\n\t\tstruct path this;\n\t\tint valid = 1;\n\n\t\t \n\t\tif (!IS_ROOT(dentry)) {\n\t\t\tif (d_unhashed(dentry) &&\n\t\t\t    d_really_is_positive(dentry)) {\n\t\t\t\tstruct dentry *parent = dentry->d_parent;\n\n\t\t\t\tnew = d_lookup(parent, &dentry->d_name);\n\t\t\t\tif (new)\n\t\t\t\t\tdentry = new;\n\t\t\t}\n\t\t}\n\t\tthis.mnt = path->mnt;\n\t\tthis.dentry = dentry;\n\t\tif (path_has_submounts(&this))\n\t\t\tvalid = 0;\n\n\t\tif (new)\n\t\t\tdput(new);\n\t\treturn valid;\n\t}\n\n\treturn 1;\n}\n\nint autofs_wait(struct autofs_sb_info *sbi,\n\t\t const struct path *path, enum autofs_notify notify)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct autofs_wait_queue *wq;\n\tstruct qstr qstr;\n\tchar *name;\n\tint status, ret, type;\n\tunsigned int offset = 0;\n\tpid_t pid;\n\tpid_t tgid;\n\n\t \n\tif (sbi->flags & AUTOFS_SBI_CATATONIC)\n\t\treturn -ENOENT;\n\n\t \n\tpid = task_pid_nr_ns(current, ns_of_pid(sbi->oz_pgrp));\n\ttgid = task_tgid_nr_ns(current, ns_of_pid(sbi->oz_pgrp));\n\tif (pid == 0 || tgid == 0)\n\t\treturn -ENOENT;\n\n\tif (d_really_is_negative(dentry)) {\n\t\t \n\t\tif (autofs_type_trigger(sbi->type))\n\t\t\treturn -ENOENT;\n\t\telse if (!IS_ROOT(dentry->d_parent))\n\t\t\treturn -ENOENT;\n\t}\n\n\tname = kmalloc(NAME_MAX + 1, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\t \n\tif (IS_ROOT(dentry) && autofs_type_trigger(sbi->type)) {\n\t\tqstr.name = name;\n\t\tqstr.len = sprintf(name, \"%p\", dentry);\n\t} else {\n\t\tchar *p = dentry_path_raw(dentry, name, NAME_MAX);\n\t\tif (IS_ERR(p)) {\n\t\t\tkfree(name);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tqstr.name = ++p; \n\t\tqstr.len = strlen(p);\n\t\toffset = p - name;\n\t}\n\tqstr.hash = full_name_hash(dentry, qstr.name, qstr.len);\n\n\tif (mutex_lock_interruptible(&sbi->wq_mutex)) {\n\t\tkfree(name);\n\t\treturn -EINTR;\n\t}\n\n\tret = validate_request(&wq, sbi, &qstr, path, notify);\n\tif (ret <= 0) {\n\t\tif (ret != -EINTR)\n\t\t\tmutex_unlock(&sbi->wq_mutex);\n\t\tkfree(name);\n\t\treturn ret;\n\t}\n\n\tif (!wq) {\n\t\t \n\t\twq = kmalloc(sizeof(struct autofs_wait_queue), GFP_KERNEL);\n\t\tif (!wq) {\n\t\t\tkfree(name);\n\t\t\tmutex_unlock(&sbi->wq_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\twq->wait_queue_token = autofs_next_wait_queue;\n\t\tif (++autofs_next_wait_queue == 0)\n\t\t\tautofs_next_wait_queue = 1;\n\t\twq->next = sbi->queues;\n\t\tsbi->queues = wq;\n\t\tinit_waitqueue_head(&wq->queue);\n\t\tmemcpy(&wq->name, &qstr, sizeof(struct qstr));\n\t\twq->offset = offset;\n\t\twq->dev = autofs_get_dev(sbi);\n\t\twq->ino = autofs_get_ino(sbi);\n\t\twq->uid = current_uid();\n\t\twq->gid = current_gid();\n\t\twq->pid = pid;\n\t\twq->tgid = tgid;\n\t\twq->status = -EINTR;  \n\t\twq->wait_ctr = 2;\n\n\t\tif (sbi->version < 5) {\n\t\t\tif (notify == NFY_MOUNT)\n\t\t\t\ttype = autofs_ptype_missing;\n\t\t\telse\n\t\t\t\ttype = autofs_ptype_expire_multi;\n\t\t} else {\n\t\t\tif (notify == NFY_MOUNT)\n\t\t\t\ttype = autofs_type_trigger(sbi->type) ?\n\t\t\t\t\tautofs_ptype_missing_direct :\n\t\t\t\t\t autofs_ptype_missing_indirect;\n\t\t\telse\n\t\t\t\ttype = autofs_type_trigger(sbi->type) ?\n\t\t\t\t\tautofs_ptype_expire_direct :\n\t\t\t\t\tautofs_ptype_expire_indirect;\n\t\t}\n\n\t\tpr_debug(\"new wait id = 0x%08lx, name = %.*s, nfy=%d\\n\",\n\t\t\t (unsigned long) wq->wait_queue_token, wq->name.len,\n\t\t\t wq->name.name, notify);\n\n\t\t \n\t\tautofs_notify_daemon(sbi, wq, type);\n\t} else {\n\t\twq->wait_ctr++;\n\t\tpr_debug(\"existing wait id = 0x%08lx, name = %.*s, nfy=%d\\n\",\n\t\t\t (unsigned long) wq->wait_queue_token, wq->name.len,\n\t\t\t wq->name.name, notify);\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\tkfree(name);\n\t}\n\n\t \n\twait_event_killable(wq->queue, wq->name.name == NULL);\n\tstatus = wq->status;\n\n\t \n\tif (!status) {\n\t\tstruct autofs_info *ino;\n\t\tstruct dentry *de = NULL;\n\n\t\t \n\t\tino = autofs_dentry_ino(dentry);\n\t\tif (!ino) {\n\t\t\t \n\t\t\tde = d_lookup(dentry->d_parent, &dentry->d_name);\n\t\t\tif (de)\n\t\t\t\tino = autofs_dentry_ino(de);\n\t\t}\n\n\t\t \n\t\tif (ino) {\n\t\t\tspin_lock(&sbi->fs_lock);\n\t\t\tino->uid = wq->uid;\n\t\t\tino->gid = wq->gid;\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t}\n\n\t\tif (de)\n\t\t\tdput(de);\n\t}\n\n\t \n\tmutex_lock(&sbi->wq_mutex);\n\tif (!--wq->wait_ctr)\n\t\tkfree(wq);\n\tmutex_unlock(&sbi->wq_mutex);\n\n\treturn status;\n}\n\n\nint autofs_wait_release(struct autofs_sb_info *sbi,\n\t\t\tautofs_wqt_t wait_queue_token, int status)\n{\n\tstruct autofs_wait_queue *wq, **wql;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tfor (wql = &sbi->queues; (wq = *wql) != NULL; wql = &wq->next) {\n\t\tif (wq->wait_queue_token == wait_queue_token)\n\t\t\tbreak;\n\t}\n\n\tif (!wq) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t*wql = wq->next;\t \n\tkfree(wq->name.name - wq->offset);\n\twq->name.name = NULL;\t \n\twq->status = status;\n\twake_up(&wq->queue);\n\tif (!--wq->wait_ctr)\n\t\tkfree(wq);\n\tmutex_unlock(&sbi->wq_mutex);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}