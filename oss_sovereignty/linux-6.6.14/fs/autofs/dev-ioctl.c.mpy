{
  "module_name": "dev-ioctl.c",
  "hash_id": "b4e7477e163250b3ce2ed4d813b6358d040e40981bd7712ef3a9ab94c7e7d217",
  "original_prompt": "Ingested from linux-6.6.14/fs/autofs/dev-ioctl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/miscdevice.h>\n#include <linux/compat.h>\n#include <linux/fdtable.h>\n#include <linux/magic.h>\n#include <linux/nospec.h>\n\n#include \"autofs_i.h\"\n\n \n\ntypedef int (*ioctl_fn)(struct file *, struct autofs_sb_info *,\n\t\t\tstruct autofs_dev_ioctl *);\n\nstatic int check_name(const char *name)\n{\n\tif (!strchr(name, '/'))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic int invalid_str(char *str, size_t size)\n{\n\tif (memchr(str, 0, size))\n\t\treturn 0;\n\treturn -EINVAL;\n}\n\n \nstatic int check_dev_ioctl_version(int cmd, struct autofs_dev_ioctl *param)\n{\n\tint err = 0;\n\n\tif ((param->ver_major != AUTOFS_DEV_IOCTL_VERSION_MAJOR) ||\n\t    (param->ver_minor > AUTOFS_DEV_IOCTL_VERSION_MINOR)) {\n\t\tpr_warn(\"ioctl control interface version mismatch: \"\n\t\t\t\"kernel(%u.%u), user(%u.%u), cmd(0x%08x)\\n\",\n\t\t\tAUTOFS_DEV_IOCTL_VERSION_MAJOR,\n\t\t\tAUTOFS_DEV_IOCTL_VERSION_MINOR,\n\t\t\tparam->ver_major, param->ver_minor, cmd);\n\t\terr = -EINVAL;\n\t}\n\n\t \n\tparam->ver_major = AUTOFS_DEV_IOCTL_VERSION_MAJOR;\n\tparam->ver_minor = AUTOFS_DEV_IOCTL_VERSION_MINOR;\n\n\treturn err;\n}\n\n \nstatic struct autofs_dev_ioctl *\ncopy_dev_ioctl(struct autofs_dev_ioctl __user *in)\n{\n\tstruct autofs_dev_ioctl tmp, *res;\n\n\tif (copy_from_user(&tmp, in, AUTOFS_DEV_IOCTL_SIZE))\n\t\treturn ERR_PTR(-EFAULT);\n\n\tif (tmp.size < AUTOFS_DEV_IOCTL_SIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (tmp.size > AUTOFS_DEV_IOCTL_SIZE + PATH_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tres = memdup_user(in, tmp.size);\n\tif (!IS_ERR(res))\n\t\tres->size = tmp.size;\n\n\treturn res;\n}\n\nstatic inline void free_dev_ioctl(struct autofs_dev_ioctl *param)\n{\n\tkfree(param);\n}\n\n \nstatic int validate_dev_ioctl(int cmd, struct autofs_dev_ioctl *param)\n{\n\tint err;\n\n\terr = check_dev_ioctl_version(cmd, param);\n\tif (err) {\n\t\tpr_warn(\"invalid device control module version \"\n\t\t\t\"supplied for cmd(0x%08x)\\n\", cmd);\n\t\tgoto out;\n\t}\n\n\tif (param->size > AUTOFS_DEV_IOCTL_SIZE) {\n\t\terr = invalid_str(param->path, param->size - AUTOFS_DEV_IOCTL_SIZE);\n\t\tif (err) {\n\t\t\tpr_warn(\n\t\t\t  \"path string terminator missing for cmd(0x%08x)\\n\",\n\t\t\t  cmd);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = check_name(param->path);\n\t\tif (err) {\n\t\t\tpr_warn(\"invalid path supplied for cmd(0x%08x)\\n\",\n\t\t\t\tcmd);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tunsigned int inr = _IOC_NR(cmd);\n\n\t\tif (inr == AUTOFS_DEV_IOCTL_OPENMOUNT_CMD ||\n\t\t    inr == AUTOFS_DEV_IOCTL_REQUESTER_CMD ||\n\t\t    inr == AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = 0;\nout:\n\treturn err;\n}\n\n \nstatic int autofs_dev_ioctl_version(struct file *fp,\n\t\t\t\t    struct autofs_sb_info *sbi,\n\t\t\t\t    struct autofs_dev_ioctl *param)\n{\n\t \n\tparam->ver_major = AUTOFS_DEV_IOCTL_VERSION_MAJOR;\n\tparam->ver_minor = AUTOFS_DEV_IOCTL_VERSION_MINOR;\n\treturn 0;\n}\n\n \nstatic int autofs_dev_ioctl_protover(struct file *fp,\n\t\t\t\t     struct autofs_sb_info *sbi,\n\t\t\t\t     struct autofs_dev_ioctl *param)\n{\n\tparam->protover.version = sbi->version;\n\treturn 0;\n}\n\n \nstatic int autofs_dev_ioctl_protosubver(struct file *fp,\n\t\t\t\t\tstruct autofs_sb_info *sbi,\n\t\t\t\t\tstruct autofs_dev_ioctl *param)\n{\n\tparam->protosubver.sub_version = sbi->sub_version;\n\treturn 0;\n}\n\n \nstatic int find_autofs_mount(const char *pathname,\n\t\t\t     struct path *res,\n\t\t\t     int test(const struct path *path, void *data),\n\t\t\t     void *data)\n{\n\tstruct path path;\n\tint err;\n\n\terr = kern_path(pathname, LOOKUP_MOUNTPOINT, &path);\n\tif (err)\n\t\treturn err;\n\terr = -ENOENT;\n\twhile (path.dentry == path.mnt->mnt_root) {\n\t\tif (path.dentry->d_sb->s_magic == AUTOFS_SUPER_MAGIC) {\n\t\t\tif (test(&path, data)) {\n\t\t\t\tpath_get(&path);\n\t\t\t\t*res = path;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!follow_up(&path))\n\t\t\tbreak;\n\t}\n\tpath_put(&path);\n\treturn err;\n}\n\nstatic int test_by_dev(const struct path *path, void *p)\n{\n\treturn path->dentry->d_sb->s_dev == *(dev_t *)p;\n}\n\nstatic int test_by_type(const struct path *path, void *p)\n{\n\tstruct autofs_info *ino = autofs_dentry_ino(path->dentry);\n\n\treturn ino && ino->sbi->type & *(unsigned *)p;\n}\n\n \nstatic int autofs_dev_ioctl_open_mountpoint(const char *name, dev_t devid)\n{\n\tint err, fd;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (likely(fd >= 0)) {\n\t\tstruct file *filp;\n\t\tstruct path path;\n\n\t\terr = find_autofs_mount(name, &path, test_by_dev, &devid);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tfilp = dentry_open(&path, O_RDONLY, current_cred());\n\t\tpath_put(&path);\n\t\tif (IS_ERR(filp)) {\n\t\t\terr = PTR_ERR(filp);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfd_install(fd, filp);\n\t}\n\n\treturn fd;\n\nout:\n\tput_unused_fd(fd);\n\treturn err;\n}\n\n \nstatic int autofs_dev_ioctl_openmount(struct file *fp,\n\t\t\t\t      struct autofs_sb_info *sbi,\n\t\t\t\t      struct autofs_dev_ioctl *param)\n{\n\tconst char *path;\n\tdev_t devid;\n\tint err, fd;\n\n\t \n\n\tif (!param->openmount.devid)\n\t\treturn -EINVAL;\n\n\tparam->ioctlfd = -1;\n\n\tpath = param->path;\n\tdevid = new_decode_dev(param->openmount.devid);\n\n\terr = 0;\n\tfd = autofs_dev_ioctl_open_mountpoint(path, devid);\n\tif (unlikely(fd < 0)) {\n\t\terr = fd;\n\t\tgoto out;\n\t}\n\n\tparam->ioctlfd = fd;\nout:\n\treturn err;\n}\n\n \nstatic int autofs_dev_ioctl_closemount(struct file *fp,\n\t\t\t\t       struct autofs_sb_info *sbi,\n\t\t\t\t       struct autofs_dev_ioctl *param)\n{\n\treturn close_fd(param->ioctlfd);\n}\n\n \nstatic int autofs_dev_ioctl_ready(struct file *fp,\n\t\t\t\t  struct autofs_sb_info *sbi,\n\t\t\t\t  struct autofs_dev_ioctl *param)\n{\n\tautofs_wqt_t token;\n\n\ttoken = (autofs_wqt_t) param->ready.token;\n\treturn autofs_wait_release(sbi, token, 0);\n}\n\n \nstatic int autofs_dev_ioctl_fail(struct file *fp,\n\t\t\t\t struct autofs_sb_info *sbi,\n\t\t\t\t struct autofs_dev_ioctl *param)\n{\n\tautofs_wqt_t token;\n\tint status;\n\n\ttoken = (autofs_wqt_t) param->fail.token;\n\tstatus = param->fail.status < 0 ? param->fail.status : -ENOENT;\n\treturn autofs_wait_release(sbi, token, status);\n}\n\n \nstatic int autofs_dev_ioctl_setpipefd(struct file *fp,\n\t\t\t\t      struct autofs_sb_info *sbi,\n\t\t\t\t      struct autofs_dev_ioctl *param)\n{\n\tint pipefd;\n\tint err = 0;\n\tstruct pid *new_pid = NULL;\n\n\tif (param->setpipefd.pipefd == -1)\n\t\treturn -EINVAL;\n\n\tpipefd = param->setpipefd.pipefd;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tif (!(sbi->flags & AUTOFS_SBI_CATATONIC)) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn -EBUSY;\n\t} else {\n\t\tstruct file *pipe;\n\n\t\tnew_pid = get_task_pid(current, PIDTYPE_PGID);\n\n\t\tif (ns_of_pid(new_pid) != ns_of_pid(sbi->oz_pgrp)) {\n\t\t\tpr_warn(\"not allowed to change PID namespace\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpipe = fget(pipefd);\n\t\tif (!pipe) {\n\t\t\terr = -EBADF;\n\t\t\tgoto out;\n\t\t}\n\t\tif (autofs_prepare_pipe(pipe) < 0) {\n\t\t\terr = -EPIPE;\n\t\t\tfput(pipe);\n\t\t\tgoto out;\n\t\t}\n\t\tswap(sbi->oz_pgrp, new_pid);\n\t\tsbi->pipefd = pipefd;\n\t\tsbi->pipe = pipe;\n\t\tsbi->flags &= ~AUTOFS_SBI_CATATONIC;\n\t}\nout:\n\tput_pid(new_pid);\n\tmutex_unlock(&sbi->wq_mutex);\n\treturn err;\n}\n\n \nstatic int autofs_dev_ioctl_catatonic(struct file *fp,\n\t\t\t\t      struct autofs_sb_info *sbi,\n\t\t\t\t      struct autofs_dev_ioctl *param)\n{\n\tautofs_catatonic_mode(sbi);\n\treturn 0;\n}\n\n \nstatic int autofs_dev_ioctl_timeout(struct file *fp,\n\t\t\t\t    struct autofs_sb_info *sbi,\n\t\t\t\t    struct autofs_dev_ioctl *param)\n{\n\tunsigned long timeout;\n\n\ttimeout = param->timeout.timeout;\n\tparam->timeout.timeout = sbi->exp_timeout / HZ;\n\tsbi->exp_timeout = timeout * HZ;\n\treturn 0;\n}\n\n \nstatic int autofs_dev_ioctl_requester(struct file *fp,\n\t\t\t\t      struct autofs_sb_info *sbi,\n\t\t\t\t      struct autofs_dev_ioctl *param)\n{\n\tstruct autofs_info *ino;\n\tstruct path path;\n\tdev_t devid;\n\tint err = -ENOENT;\n\n\t \n\n\tdevid = sbi->sb->s_dev;\n\n\tparam->requester.uid = param->requester.gid = -1;\n\n\terr = find_autofs_mount(param->path, &path, test_by_dev, &devid);\n\tif (err)\n\t\tgoto out;\n\n\tino = autofs_dentry_ino(path.dentry);\n\tif (ino) {\n\t\terr = 0;\n\t\tautofs_expire_wait(&path, 0);\n\t\tspin_lock(&sbi->fs_lock);\n\t\tparam->requester.uid =\n\t\t\tfrom_kuid_munged(current_user_ns(), ino->uid);\n\t\tparam->requester.gid =\n\t\t\tfrom_kgid_munged(current_user_ns(), ino->gid);\n\t\tspin_unlock(&sbi->fs_lock);\n\t}\n\tpath_put(&path);\nout:\n\treturn err;\n}\n\n \nstatic int autofs_dev_ioctl_expire(struct file *fp,\n\t\t\t\t   struct autofs_sb_info *sbi,\n\t\t\t\t   struct autofs_dev_ioctl *param)\n{\n\tstruct vfsmount *mnt;\n\tint how;\n\n\thow = param->expire.how;\n\tmnt = fp->f_path.mnt;\n\n\treturn autofs_do_expire_multi(sbi->sb, mnt, sbi, how);\n}\n\n \nstatic int autofs_dev_ioctl_askumount(struct file *fp,\n\t\t\t\t      struct autofs_sb_info *sbi,\n\t\t\t\t      struct autofs_dev_ioctl *param)\n{\n\tparam->askumount.may_umount = 0;\n\tif (may_umount(fp->f_path.mnt))\n\t\tparam->askumount.may_umount = 1;\n\treturn 0;\n}\n\n \nstatic int autofs_dev_ioctl_ismountpoint(struct file *fp,\n\t\t\t\t\t struct autofs_sb_info *sbi,\n\t\t\t\t\t struct autofs_dev_ioctl *param)\n{\n\tstruct path path;\n\tconst char *name;\n\tunsigned int type;\n\tunsigned int devid, magic;\n\tint err = -ENOENT;\n\n\t \n\n\tname = param->path;\n\ttype = param->ismountpoint.in.type;\n\n\tparam->ismountpoint.out.devid = devid = 0;\n\tparam->ismountpoint.out.magic = magic = 0;\n\n\tif (!fp || param->ioctlfd == -1) {\n\t\tif (autofs_type_any(type))\n\t\t\terr = kern_path(name, LOOKUP_FOLLOW | LOOKUP_MOUNTPOINT,\n\t\t\t\t\t&path);\n\t\telse\n\t\t\terr = find_autofs_mount(name, &path,\n\t\t\t\t\t\ttest_by_type, &type);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tdevid = new_encode_dev(path.dentry->d_sb->s_dev);\n\t\terr = 0;\n\t\tif (path.mnt->mnt_root == path.dentry) {\n\t\t\terr = 1;\n\t\t\tmagic = path.dentry->d_sb->s_magic;\n\t\t}\n\t} else {\n\t\tdev_t dev = sbi->sb->s_dev;\n\n\t\terr = find_autofs_mount(name, &path, test_by_dev, &dev);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tdevid = new_encode_dev(dev);\n\n\t\terr = path_has_submounts(&path);\n\n\t\tif (follow_down_one(&path))\n\t\t\tmagic = path.dentry->d_sb->s_magic;\n\t}\n\n\tparam->ismountpoint.out.devid = devid;\n\tparam->ismountpoint.out.magic = magic;\n\tpath_put(&path);\nout:\n\treturn err;\n}\n\n \n#define cmd_idx(cmd)\t(cmd - _IOC_NR(AUTOFS_DEV_IOCTL_IOC_FIRST))\n\nstatic ioctl_fn lookup_dev_ioctl(unsigned int cmd)\n{\n\tstatic const ioctl_fn _ioctls[] = {\n\t\tautofs_dev_ioctl_version,\n\t\tautofs_dev_ioctl_protover,\n\t\tautofs_dev_ioctl_protosubver,\n\t\tautofs_dev_ioctl_openmount,\n\t\tautofs_dev_ioctl_closemount,\n\t\tautofs_dev_ioctl_ready,\n\t\tautofs_dev_ioctl_fail,\n\t\tautofs_dev_ioctl_setpipefd,\n\t\tautofs_dev_ioctl_catatonic,\n\t\tautofs_dev_ioctl_timeout,\n\t\tautofs_dev_ioctl_requester,\n\t\tautofs_dev_ioctl_expire,\n\t\tautofs_dev_ioctl_askumount,\n\t\tautofs_dev_ioctl_ismountpoint,\n\t};\n\tunsigned int idx = cmd_idx(cmd);\n\n\tif (idx >= ARRAY_SIZE(_ioctls))\n\t\treturn NULL;\n\tidx = array_index_nospec(idx, ARRAY_SIZE(_ioctls));\n\treturn _ioctls[idx];\n}\n\n \nstatic int _autofs_dev_ioctl(unsigned int command,\n\t\t\t     struct autofs_dev_ioctl __user *user)\n{\n\tstruct autofs_dev_ioctl *param;\n\tstruct file *fp;\n\tstruct autofs_sb_info *sbi;\n\tunsigned int cmd_first, cmd;\n\tioctl_fn fn = NULL;\n\tint err = 0;\n\n\tcmd_first = _IOC_NR(AUTOFS_DEV_IOCTL_IOC_FIRST);\n\tcmd = _IOC_NR(command);\n\n\tif (_IOC_TYPE(command) != _IOC_TYPE(AUTOFS_DEV_IOCTL_IOC_FIRST) ||\n\t    cmd - cmd_first > AUTOFS_DEV_IOCTL_IOC_COUNT) {\n\t\treturn -ENOTTY;\n\t}\n\n\t \n\tif (cmd != AUTOFS_DEV_IOCTL_VERSION_CMD &&\n\t    cmd != AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t \n\tparam = copy_dev_ioctl(user);\n\tif (IS_ERR(param))\n\t\treturn PTR_ERR(param);\n\n\terr = validate_dev_ioctl(command, param);\n\tif (err)\n\t\tgoto out;\n\n\tfn = lookup_dev_ioctl(cmd);\n\tif (!fn) {\n\t\tpr_warn(\"unknown command 0x%08x\\n\", command);\n\t\terr = -ENOTTY;\n\t\tgoto out;\n\t}\n\n\tfp = NULL;\n\tsbi = NULL;\n\n\t \n\tif (cmd != AUTOFS_DEV_IOCTL_VERSION_CMD &&\n\t    cmd != AUTOFS_DEV_IOCTL_OPENMOUNT_CMD &&\n\t    cmd != AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD) {\n\t\tstruct super_block *sb;\n\n\t\tfp = fget(param->ioctlfd);\n\t\tif (!fp) {\n\t\t\tif (cmd == AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD)\n\t\t\t\tgoto cont;\n\t\t\terr = -EBADF;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsb = file_inode(fp)->i_sb;\n\t\tif (sb->s_type != &autofs_fs_type) {\n\t\t\terr = -EINVAL;\n\t\t\tfput(fp);\n\t\t\tgoto out;\n\t\t}\n\t\tsbi = autofs_sbi(sb);\n\n\t\t \n\t\tif (!autofs_oz_mode(sbi) &&\n\t\t    cmd != AUTOFS_DEV_IOCTL_CATATONIC_CMD) {\n\t\t\terr = -EACCES;\n\t\t\tfput(fp);\n\t\t\tgoto out;\n\t\t}\n\t}\ncont:\n\terr = fn(fp, sbi, param);\n\n\tif (fp)\n\t\tfput(fp);\n\tif (err >= 0 && copy_to_user(user, param, AUTOFS_DEV_IOCTL_SIZE))\n\t\terr = -EFAULT;\nout:\n\tfree_dev_ioctl(param);\n\treturn err;\n}\n\nstatic long autofs_dev_ioctl(struct file *file, unsigned int command,\n\t\t\t     unsigned long u)\n{\n\tint err;\n\n\terr = _autofs_dev_ioctl(command, (struct autofs_dev_ioctl __user *) u);\n\treturn (long) err;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long autofs_dev_ioctl_compat(struct file *file, unsigned int command,\n\t\t\t\t    unsigned long u)\n{\n\treturn autofs_dev_ioctl(file, command, (unsigned long) compat_ptr(u));\n}\n#else\n#define autofs_dev_ioctl_compat NULL\n#endif\n\nstatic const struct file_operations _dev_ioctl_fops = {\n\t.unlocked_ioctl\t = autofs_dev_ioctl,\n\t.compat_ioctl = autofs_dev_ioctl_compat,\n\t.owner\t = THIS_MODULE,\n\t.llseek = noop_llseek,\n};\n\nstatic struct miscdevice _autofs_dev_ioctl_misc = {\n\t.minor\t\t= AUTOFS_MINOR,\n\t.name\t\t= AUTOFS_DEVICE_NAME,\n\t.fops\t\t= &_dev_ioctl_fops,\n\t.mode           = 0644,\n};\n\nMODULE_ALIAS_MISCDEV(AUTOFS_MINOR);\nMODULE_ALIAS(\"devname:autofs\");\n\n \nint __init autofs_dev_ioctl_init(void)\n{\n\tint r;\n\n\tr = misc_register(&_autofs_dev_ioctl_misc);\n\tif (r) {\n\t\tpr_err(\"misc_register failed for control device\\n\");\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nvoid autofs_dev_ioctl_exit(void)\n{\n\tmisc_deregister(&_autofs_dev_ioctl_misc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}