{
  "module_name": "expire.c",
  "hash_id": "30049b4e06d32168678b403842ab1efd094d1f4ea4e835c51dc6f86f01ca9037",
  "original_prompt": "Ingested from linux-6.6.14/fs/autofs/expire.c",
  "human_readable_source": "\n \n\n#include \"autofs_i.h\"\n\n \nstatic inline int autofs_can_expire(struct dentry *dentry,\n\t\t\t\t    unsigned long timeout, unsigned int how)\n{\n\tstruct autofs_info *ino = autofs_dentry_ino(dentry);\n\n\t \n\tif (ino == NULL)\n\t\treturn 0;\n\n\tif (!(how & AUTOFS_EXP_IMMEDIATE)) {\n\t\t \n\t\tif (!timeout || time_after(ino->last_used + timeout, jiffies))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nstatic int autofs_mount_busy(struct vfsmount *mnt,\n\t\t\t     struct dentry *dentry, unsigned int how)\n{\n\tstruct dentry *top = dentry;\n\tstruct path path = {.mnt = mnt, .dentry = dentry};\n\tint status = 1;\n\n\tpr_debug(\"dentry %p %pd\\n\", dentry, dentry);\n\n\tpath_get(&path);\n\n\tif (!follow_down_one(&path))\n\t\tgoto done;\n\n\tif (is_autofs_dentry(path.dentry)) {\n\t\tstruct autofs_sb_info *sbi = autofs_sbi(path.dentry->d_sb);\n\n\t\t \n\t\tif (autofs_type_indirect(sbi->type))\n\t\t\tgoto done;\n\t}\n\n\t \n\tif (how & AUTOFS_EXP_FORCED) {\n\t\tstatus = 0;\n\t\tgoto done;\n\t}\n\n\t \n\tif (!may_umount_tree(path.mnt)) {\n\t\tstruct autofs_info *ino;\n\n\t\tino = autofs_dentry_ino(top);\n\t\tino->last_used = jiffies;\n\t\tgoto done;\n\t}\n\n\tstatus = 0;\ndone:\n\tpr_debug(\"returning = %d\\n\", status);\n\tpath_put(&path);\n\treturn status;\n}\n\n \nstatic struct dentry *positive_after(struct dentry *p, struct dentry *child)\n{\n\tif (child)\n\t\tchild = list_next_entry(child, d_child);\n\telse\n\t\tchild = list_first_entry(&p->d_subdirs, struct dentry, d_child);\n\n\tlist_for_each_entry_from(child, &p->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tdget_dlock(child);\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\treturn child;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct dentry *get_next_positive_subdir(struct dentry *prev,\n\t\t\t\t\t       struct dentry *root)\n{\n\tstruct autofs_sb_info *sbi = autofs_sbi(root->d_sb);\n\tstruct dentry *q;\n\n\tspin_lock(&sbi->lookup_lock);\n\tspin_lock(&root->d_lock);\n\tq = positive_after(root, prev);\n\tspin_unlock(&root->d_lock);\n\tspin_unlock(&sbi->lookup_lock);\n\tdput(prev);\n\treturn q;\n}\n\n \nstatic struct dentry *get_next_positive_dentry(struct dentry *prev,\n\t\t\t\t\t       struct dentry *root)\n{\n\tstruct autofs_sb_info *sbi = autofs_sbi(root->d_sb);\n\tstruct dentry *p = prev, *ret = NULL, *d = NULL;\n\n\tif (prev == NULL)\n\t\treturn dget(root);\n\n\tspin_lock(&sbi->lookup_lock);\n\tspin_lock(&p->d_lock);\n\twhile (1) {\n\t\tstruct dentry *parent;\n\n\t\tret = positive_after(p, d);\n\t\tif (ret || p == root)\n\t\t\tbreak;\n\t\tparent = p->d_parent;\n\t\tspin_unlock(&p->d_lock);\n\t\tspin_lock(&parent->d_lock);\n\t\td = p;\n\t\tp = parent;\n\t}\n\tspin_unlock(&p->d_lock);\n\tspin_unlock(&sbi->lookup_lock);\n\tdput(prev);\n\treturn ret;\n}\n\n \nstatic int autofs_direct_busy(struct vfsmount *mnt,\n\t\t\t      struct dentry *top,\n\t\t\t      unsigned long timeout,\n\t\t\t      unsigned int how)\n{\n\tpr_debug(\"top %p %pd\\n\", top, top);\n\n\t \n\tif (how & AUTOFS_EXP_FORCED)\n\t\treturn 0;\n\n\t \n\tif (!may_umount_tree(mnt)) {\n\t\tstruct autofs_info *ino;\n\n\t\tino = autofs_dentry_ino(top);\n\t\tif (ino)\n\t\t\tino->last_used = jiffies;\n\t\treturn 1;\n\t}\n\n\t \n\tif (!autofs_can_expire(top, timeout, how))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic int autofs_tree_busy(struct vfsmount *mnt,\n\t\t\t    struct dentry *top,\n\t\t\t    unsigned long timeout,\n\t\t\t    unsigned int how)\n{\n\tstruct autofs_info *top_ino = autofs_dentry_ino(top);\n\tstruct dentry *p;\n\n\tpr_debug(\"top %p %pd\\n\", top, top);\n\n\t \n\tif (!simple_positive(top))\n\t\treturn 1;\n\n\tp = NULL;\n\twhile ((p = get_next_positive_dentry(p, top))) {\n\t\tpr_debug(\"dentry %p %pd\\n\", p, p);\n\n\t\t \n\t\tif (d_mountpoint(p)) {\n\t\t\tif (autofs_mount_busy(mnt, p, how)) {\n\t\t\t\ttop_ino->last_used = jiffies;\n\t\t\t\tdput(p);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct autofs_info *ino = autofs_dentry_ino(p);\n\t\t\tunsigned int ino_count = READ_ONCE(ino->count);\n\n\t\t\t \n\t\t\tif (p == top)\n\t\t\t\tino_count += 2;\n\t\t\telse\n\t\t\t\tino_count++;\n\n\t\t\tif (d_count(p) > ino_count) {\n\t\t\t\ttop_ino->last_used = jiffies;\n\t\t\t\tdput(p);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (how & AUTOFS_EXP_FORCED)\n\t\treturn 0;\n\n\t \n\tif (!autofs_can_expire(top, timeout, how))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct dentry *autofs_check_leaves(struct vfsmount *mnt,\n\t\t\t\t\t  struct dentry *parent,\n\t\t\t\t\t  unsigned long timeout,\n\t\t\t\t\t  unsigned int how)\n{\n\tstruct dentry *p;\n\n\tpr_debug(\"parent %p %pd\\n\", parent, parent);\n\n\tp = NULL;\n\twhile ((p = get_next_positive_dentry(p, parent))) {\n\t\tpr_debug(\"dentry %p %pd\\n\", p, p);\n\n\t\tif (d_mountpoint(p)) {\n\t\t\t \n\t\t\tif (autofs_mount_busy(mnt, p, how))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (how & AUTOFS_EXP_FORCED)\n\t\t\t\treturn p;\n\n\t\t\t \n\t\t\tif (autofs_can_expire(p, timeout, how))\n\t\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic struct dentry *autofs_expire_direct(struct super_block *sb,\n\t\t\t\t\t   struct vfsmount *mnt,\n\t\t\t\t\t   struct autofs_sb_info *sbi,\n\t\t\t\t\t   unsigned int how)\n{\n\tstruct dentry *root = dget(sb->s_root);\n\tstruct autofs_info *ino;\n\tunsigned long timeout;\n\n\tif (!root)\n\t\treturn NULL;\n\n\ttimeout = sbi->exp_timeout;\n\n\tif (!autofs_direct_busy(mnt, root, timeout, how)) {\n\t\tspin_lock(&sbi->fs_lock);\n\t\tino = autofs_dentry_ino(root);\n\t\t \n\t\tif (ino->flags & AUTOFS_INF_PENDING) {\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tino->flags |= AUTOFS_INF_WANT_EXPIRE;\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tsynchronize_rcu();\n\t\tif (!autofs_direct_busy(mnt, root, timeout, how)) {\n\t\t\tspin_lock(&sbi->fs_lock);\n\t\t\tino->flags |= AUTOFS_INF_EXPIRING;\n\t\t\tinit_completion(&ino->expire_complete);\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\treturn root;\n\t\t}\n\t\tspin_lock(&sbi->fs_lock);\n\t\tino->flags &= ~AUTOFS_INF_WANT_EXPIRE;\n\t\tspin_unlock(&sbi->fs_lock);\n\t}\nout:\n\tdput(root);\n\n\treturn NULL;\n}\n\n \nstatic struct dentry *should_expire(struct dentry *dentry,\n\t\t\t\t    struct vfsmount *mnt,\n\t\t\t\t    unsigned long timeout,\n\t\t\t\t    unsigned int how)\n{\n\tstruct autofs_info *ino = autofs_dentry_ino(dentry);\n\tunsigned int ino_count;\n\n\t \n\tif (ino->flags & AUTOFS_INF_PENDING)\n\t\treturn NULL;\n\n\t \n\tif (d_mountpoint(dentry)) {\n\t\tpr_debug(\"checking mountpoint %p %pd\\n\", dentry, dentry);\n\n\t\t \n\t\tif (autofs_mount_busy(mnt, dentry, how))\n\t\t\treturn NULL;\n\n\t\t \n\t\tif (how & AUTOFS_EXP_FORCED)\n\t\t\treturn dentry;\n\n\t\t \n\t\tif (autofs_can_expire(dentry, timeout, how))\n\t\t\treturn dentry;\n\t\treturn NULL;\n\t}\n\n\tif (d_is_symlink(dentry)) {\n\t\tpr_debug(\"checking symlink %p %pd\\n\", dentry, dentry);\n\n\t\t \n\t\tif (how & AUTOFS_EXP_FORCED)\n\t\t\treturn dentry;\n\n\t\t \n\t\tif (autofs_can_expire(dentry, timeout, how))\n\t\t\treturn dentry;\n\t\treturn NULL;\n\t}\n\n\tif (autofs_empty(ino))\n\t\treturn NULL;\n\n\t \n\tif (!(how & AUTOFS_EXP_LEAVES)) {\n\t\t \n\t\tif (!(how & AUTOFS_EXP_FORCED)) {\n\t\t\t \n\t\t\tino_count = READ_ONCE(ino->count) + 1;\n\t\t\tif (d_count(dentry) > ino_count)\n\t\t\t\treturn NULL;\n\t\t}\n\n\t\tif (!autofs_tree_busy(mnt, dentry, timeout, how))\n\t\t\treturn dentry;\n\t \n\t} else {\n\t\tstruct dentry *expired;\n\n\t\t \n\t\tif (!(how & AUTOFS_EXP_FORCED)) {\n\t\t\t \n\t\t\tino_count = READ_ONCE(ino->count) + 1;\n\t\t\tif (d_count(dentry) > ino_count)\n\t\t\t\treturn NULL;\n\t\t}\n\n\t\texpired = autofs_check_leaves(mnt, dentry, timeout, how);\n\t\tif (expired) {\n\t\t\tif (expired == dentry)\n\t\t\t\tdput(dentry);\n\t\t\treturn expired;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic struct dentry *autofs_expire_indirect(struct super_block *sb,\n\t\t\t\t\t     struct vfsmount *mnt,\n\t\t\t\t\t     struct autofs_sb_info *sbi,\n\t\t\t\t\t     unsigned int how)\n{\n\tunsigned long timeout;\n\tstruct dentry *root = sb->s_root;\n\tstruct dentry *dentry;\n\tstruct dentry *expired;\n\tstruct dentry *found;\n\tstruct autofs_info *ino;\n\n\tif (!root)\n\t\treturn NULL;\n\n\ttimeout = sbi->exp_timeout;\n\n\tdentry = NULL;\n\twhile ((dentry = get_next_positive_subdir(dentry, root))) {\n\t\tspin_lock(&sbi->fs_lock);\n\t\tino = autofs_dentry_ino(dentry);\n\t\tif (ino->flags & AUTOFS_INF_WANT_EXPIRE) {\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&sbi->fs_lock);\n\n\t\texpired = should_expire(dentry, mnt, timeout, how);\n\t\tif (!expired)\n\t\t\tcontinue;\n\n\t\tspin_lock(&sbi->fs_lock);\n\t\tino = autofs_dentry_ino(expired);\n\t\tino->flags |= AUTOFS_INF_WANT_EXPIRE;\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tsynchronize_rcu();\n\n\t\t \n\t\thow &= ~AUTOFS_EXP_LEAVES;\n\t\tfound = should_expire(expired, mnt, timeout, how);\n\t\tif (found != expired) { \n\t\t\tdput(found);\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (expired != dentry)\n\t\t\tdput(dentry);\n\n\t\tspin_lock(&sbi->fs_lock);\n\t\tgoto found;\nnext:\n\t\tspin_lock(&sbi->fs_lock);\n\t\tino->flags &= ~AUTOFS_INF_WANT_EXPIRE;\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tif (expired != dentry)\n\t\t\tdput(expired);\n\t}\n\treturn NULL;\n\nfound:\n\tpr_debug(\"returning %p %pd\\n\", expired, expired);\n\tino->flags |= AUTOFS_INF_EXPIRING;\n\tinit_completion(&ino->expire_complete);\n\tspin_unlock(&sbi->fs_lock);\n\treturn expired;\n}\n\nint autofs_expire_wait(const struct path *path, int rcu_walk)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct autofs_sb_info *sbi = autofs_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs_dentry_ino(dentry);\n\tint status;\n\tint state;\n\n\t \n\tif (!(ino->flags & AUTOFS_INF_WANT_EXPIRE))\n\t\treturn 0;\n\tif (rcu_walk)\n\t\treturn -ECHILD;\n\nretry:\n\tspin_lock(&sbi->fs_lock);\n\tstate = ino->flags & (AUTOFS_INF_WANT_EXPIRE | AUTOFS_INF_EXPIRING);\n\tif (state == AUTOFS_INF_WANT_EXPIRE) {\n\t\tspin_unlock(&sbi->fs_lock);\n\t\t \n\t\tschedule_timeout_uninterruptible(HZ/10);\n\t\tgoto retry;\n\t}\n\tif (state & AUTOFS_INF_EXPIRING) {\n\t\tspin_unlock(&sbi->fs_lock);\n\n\t\tpr_debug(\"waiting for expire %p name=%pd\\n\", dentry, dentry);\n\n\t\tstatus = autofs_wait(sbi, path, NFY_NONE);\n\t\twait_for_completion(&ino->expire_complete);\n\n\t\tpr_debug(\"expire done status=%d\\n\", status);\n\n\t\tif (d_unhashed(dentry))\n\t\t\treturn -EAGAIN;\n\n\t\treturn status;\n\t}\n\tspin_unlock(&sbi->fs_lock);\n\n\treturn 0;\n}\n\n \nint autofs_expire_run(struct super_block *sb,\n\t\t      struct vfsmount *mnt,\n\t\t      struct autofs_sb_info *sbi,\n\t\t      struct autofs_packet_expire __user *pkt_p)\n{\n\tstruct autofs_packet_expire pkt;\n\tstruct autofs_info *ino;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.hdr.proto_version = sbi->version;\n\tpkt.hdr.type = autofs_ptype_expire;\n\n\tdentry = autofs_expire_indirect(sb, mnt, sbi, 0);\n\tif (!dentry)\n\t\treturn -EAGAIN;\n\n\tpkt.len = dentry->d_name.len;\n\tmemcpy(pkt.name, dentry->d_name.name, pkt.len);\n\tpkt.name[pkt.len] = '\\0';\n\n\tif (copy_to_user(pkt_p, &pkt, sizeof(struct autofs_packet_expire)))\n\t\tret = -EFAULT;\n\n\tspin_lock(&sbi->fs_lock);\n\tino = autofs_dentry_ino(dentry);\n\t \n\tino->last_used = jiffies;\n\tino->flags &= ~(AUTOFS_INF_EXPIRING|AUTOFS_INF_WANT_EXPIRE);\n\tcomplete_all(&ino->expire_complete);\n\tspin_unlock(&sbi->fs_lock);\n\n\tdput(dentry);\n\n\treturn ret;\n}\n\nint autofs_do_expire_multi(struct super_block *sb, struct vfsmount *mnt,\n\t\t\t   struct autofs_sb_info *sbi, unsigned int how)\n{\n\tstruct dentry *dentry;\n\tint ret = -EAGAIN;\n\n\tif (autofs_type_trigger(sbi->type))\n\t\tdentry = autofs_expire_direct(sb, mnt, sbi, how);\n\telse\n\t\tdentry = autofs_expire_indirect(sb, mnt, sbi, how);\n\n\tif (dentry) {\n\t\tstruct autofs_info *ino = autofs_dentry_ino(dentry);\n\t\tconst struct path path = { .mnt = mnt, .dentry = dentry };\n\n\t\t \n\t\tret = autofs_wait(sbi, &path, NFY_EXPIRE);\n\n\t\tspin_lock(&sbi->fs_lock);\n\t\t \n\t\tino->last_used = jiffies;\n\t\tino->flags &= ~(AUTOFS_INF_EXPIRING|AUTOFS_INF_WANT_EXPIRE);\n\t\tcomplete_all(&ino->expire_complete);\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tdput(dentry);\n\t}\n\n\treturn ret;\n}\n\n \nint autofs_expire_multi(struct super_block *sb, struct vfsmount *mnt,\n\t\t\tstruct autofs_sb_info *sbi, int __user *arg)\n{\n\tunsigned int how = 0;\n\n\tif (arg && get_user(how, arg))\n\t\treturn -EFAULT;\n\n\treturn autofs_do_expire_multi(sb, mnt, sbi, how);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}