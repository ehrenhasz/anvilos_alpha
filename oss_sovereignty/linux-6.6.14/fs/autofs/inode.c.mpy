{
  "module_name": "inode.c",
  "hash_id": "82116d0ff999f21d94c3c382ceafe58bc8a83e24a3a87fd3d2d652d49a55b48f",
  "original_prompt": "Ingested from linux-6.6.14/fs/autofs/inode.c",
  "human_readable_source": "\n \n\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/parser.h>\n\n#include \"autofs_i.h\"\n\nstruct autofs_info *autofs_new_ino(struct autofs_sb_info *sbi)\n{\n\tstruct autofs_info *ino;\n\n\tino = kzalloc(sizeof(*ino), GFP_KERNEL);\n\tif (ino) {\n\t\tINIT_LIST_HEAD(&ino->active);\n\t\tINIT_LIST_HEAD(&ino->expiring);\n\t\tino->last_used = jiffies;\n\t\tino->sbi = sbi;\n\t\tino->count = 1;\n\t}\n\treturn ino;\n}\n\nvoid autofs_clean_ino(struct autofs_info *ino)\n{\n\tino->uid = GLOBAL_ROOT_UID;\n\tino->gid = GLOBAL_ROOT_GID;\n\tino->last_used = jiffies;\n}\n\nvoid autofs_free_ino(struct autofs_info *ino)\n{\n\tkfree_rcu(ino, rcu);\n}\n\nvoid autofs_kill_sb(struct super_block *sb)\n{\n\tstruct autofs_sb_info *sbi = autofs_sbi(sb);\n\n\t \n\tif (sbi) {\n\t\t \n\t\tautofs_catatonic_mode(sbi);\n\t\tput_pid(sbi->oz_pgrp);\n\t}\n\n\tpr_debug(\"shutting down\\n\");\n\tkill_litter_super(sb);\n\tif (sbi)\n\t\tkfree_rcu(sbi, rcu);\n}\n\nstatic int autofs_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct autofs_sb_info *sbi = autofs_sbi(root->d_sb);\n\tstruct inode *root_inode = d_inode(root->d_sb->s_root);\n\n\tif (!sbi)\n\t\treturn 0;\n\n\tseq_printf(m, \",fd=%d\", sbi->pipefd);\n\tif (!uid_eq(root_inode->i_uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(m, \",uid=%u\",\n\t\t\tfrom_kuid_munged(&init_user_ns, root_inode->i_uid));\n\tif (!gid_eq(root_inode->i_gid, GLOBAL_ROOT_GID))\n\t\tseq_printf(m, \",gid=%u\",\n\t\t\tfrom_kgid_munged(&init_user_ns, root_inode->i_gid));\n\tseq_printf(m, \",pgrp=%d\", pid_vnr(sbi->oz_pgrp));\n\tseq_printf(m, \",timeout=%lu\", sbi->exp_timeout/HZ);\n\tseq_printf(m, \",minproto=%d\", sbi->min_proto);\n\tseq_printf(m, \",maxproto=%d\", sbi->max_proto);\n\n\tif (autofs_type_offset(sbi->type))\n\t\tseq_puts(m, \",offset\");\n\telse if (autofs_type_direct(sbi->type))\n\t\tseq_puts(m, \",direct\");\n\telse\n\t\tseq_puts(m, \",indirect\");\n\tif (sbi->flags & AUTOFS_SBI_STRICTEXPIRE)\n\t\tseq_puts(m, \",strictexpire\");\n\tif (sbi->flags & AUTOFS_SBI_IGNORE)\n\t\tseq_puts(m, \",ignore\");\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tif (sbi->pipe)\n\t\tseq_printf(m, \",pipe_ino=%ld\", file_inode(sbi->pipe)->i_ino);\n\telse\n\t\tseq_puts(m, \",pipe_ino=-1\");\n#endif\n\treturn 0;\n}\n\nstatic void autofs_evict_inode(struct inode *inode)\n{\n\tclear_inode(inode);\n\tkfree(inode->i_private);\n}\n\nstatic const struct super_operations autofs_sops = {\n\t.statfs\t\t= simple_statfs,\n\t.show_options\t= autofs_show_options,\n\t.evict_inode\t= autofs_evict_inode,\n};\n\nenum {Opt_err, Opt_fd, Opt_uid, Opt_gid, Opt_pgrp, Opt_minproto, Opt_maxproto,\n\tOpt_indirect, Opt_direct, Opt_offset, Opt_strictexpire,\n\tOpt_ignore};\n\nstatic const match_table_t tokens = {\n\t{Opt_fd, \"fd=%u\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_pgrp, \"pgrp=%u\"},\n\t{Opt_minproto, \"minproto=%u\"},\n\t{Opt_maxproto, \"maxproto=%u\"},\n\t{Opt_indirect, \"indirect\"},\n\t{Opt_direct, \"direct\"},\n\t{Opt_offset, \"offset\"},\n\t{Opt_strictexpire, \"strictexpire\"},\n\t{Opt_ignore, \"ignore\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options,\n\t\t\t struct inode *root, int *pgrp, bool *pgrp_set,\n\t\t\t struct autofs_sb_info *sbi)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tint pipefd = -1;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\troot->i_uid = current_uid();\n\troot->i_gid = current_gid();\n\n\tsbi->min_proto = AUTOFS_MIN_PROTO_VERSION;\n\tsbi->max_proto = AUTOFS_MAX_PROTO_VERSION;\n\n\tsbi->pipefd = -1;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_fd:\n\t\t\tif (match_int(args, &pipefd))\n\t\t\t\treturn 1;\n\t\t\tsbi->pipefd = pipefd;\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\treturn 1;\n\t\t\troot->i_uid = uid;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid))\n\t\t\t\treturn 1;\n\t\t\troot->i_gid = gid;\n\t\t\tbreak;\n\t\tcase Opt_pgrp:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\t*pgrp = option;\n\t\t\t*pgrp_set = true;\n\t\t\tbreak;\n\t\tcase Opt_minproto:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\tsbi->min_proto = option;\n\t\t\tbreak;\n\t\tcase Opt_maxproto:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 1;\n\t\t\tsbi->max_proto = option;\n\t\t\tbreak;\n\t\tcase Opt_indirect:\n\t\t\tset_autofs_type_indirect(&sbi->type);\n\t\t\tbreak;\n\t\tcase Opt_direct:\n\t\t\tset_autofs_type_direct(&sbi->type);\n\t\t\tbreak;\n\t\tcase Opt_offset:\n\t\t\tset_autofs_type_offset(&sbi->type);\n\t\t\tbreak;\n\t\tcase Opt_strictexpire:\n\t\t\tsbi->flags |= AUTOFS_SBI_STRICTEXPIRE;\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tsbi->flags |= AUTOFS_SBI_IGNORE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn (sbi->pipefd < 0);\n}\n\nint autofs_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct inode *root_inode;\n\tstruct dentry *root;\n\tstruct file *pipe;\n\tstruct autofs_sb_info *sbi;\n\tstruct autofs_info *ino;\n\tint pgrp = 0;\n\tbool pgrp_set = false;\n\tint ret = -EINVAL;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tpr_debug(\"starting up, sbi = %p\\n\", sbi);\n\n\ts->s_fs_info = sbi;\n\tsbi->magic = AUTOFS_SBI_MAGIC;\n\tsbi->pipefd = -1;\n\tsbi->pipe = NULL;\n\tsbi->exp_timeout = 0;\n\tsbi->oz_pgrp = NULL;\n\tsbi->sb = s;\n\tsbi->version = 0;\n\tsbi->sub_version = 0;\n\tsbi->flags = AUTOFS_SBI_CATATONIC;\n\tset_autofs_type_indirect(&sbi->type);\n\tsbi->min_proto = 0;\n\tsbi->max_proto = 0;\n\tmutex_init(&sbi->wq_mutex);\n\tmutex_init(&sbi->pipe_mutex);\n\tspin_lock_init(&sbi->fs_lock);\n\tsbi->queues = NULL;\n\tspin_lock_init(&sbi->lookup_lock);\n\tINIT_LIST_HEAD(&sbi->active_list);\n\tINIT_LIST_HEAD(&sbi->expiring_list);\n\ts->s_blocksize = 1024;\n\ts->s_blocksize_bits = 10;\n\ts->s_magic = AUTOFS_SUPER_MAGIC;\n\ts->s_op = &autofs_sops;\n\ts->s_d_op = &autofs_dentry_operations;\n\ts->s_time_gran = 1;\n\n\t \n\tino = autofs_new_ino(sbi);\n\tif (!ino) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_free;\n\t}\n\troot_inode = autofs_get_inode(s, S_IFDIR | 0755);\n\troot = d_make_root(root_inode);\n\tif (!root) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_ino;\n\t}\n\tpipe = NULL;\n\n\troot->d_fsdata = ino;\n\n\t \n\tif (parse_options(data, root_inode, &pgrp, &pgrp_set, sbi)) {\n\t\tpr_err(\"called with bogus options\\n\");\n\t\tgoto fail_dput;\n\t}\n\n\t \n\tif (sbi->max_proto < AUTOFS_MIN_PROTO_VERSION ||\n\t    sbi->min_proto > AUTOFS_MAX_PROTO_VERSION) {\n\t\tpr_err(\"kernel does not match daemon version \"\n\t\t       \"daemon (%d, %d) kernel (%d, %d)\\n\",\n\t\t       sbi->min_proto, sbi->max_proto,\n\t\t       AUTOFS_MIN_PROTO_VERSION, AUTOFS_MAX_PROTO_VERSION);\n\t\tgoto fail_dput;\n\t}\n\n\t \n\tif (sbi->max_proto > AUTOFS_MAX_PROTO_VERSION)\n\t\tsbi->version = AUTOFS_MAX_PROTO_VERSION;\n\telse\n\t\tsbi->version = sbi->max_proto;\n\tsbi->sub_version = AUTOFS_PROTO_SUBVERSION;\n\n\tif (pgrp_set) {\n\t\tsbi->oz_pgrp = find_get_pid(pgrp);\n\t\tif (!sbi->oz_pgrp) {\n\t\t\tpr_err(\"could not find process group %d\\n\",\n\t\t\t\tpgrp);\n\t\t\tgoto fail_dput;\n\t\t}\n\t} else {\n\t\tsbi->oz_pgrp = get_task_pid(current, PIDTYPE_PGID);\n\t}\n\n\tif (autofs_type_trigger(sbi->type))\n\t\t__managed_dentry_set_managed(root);\n\n\troot_inode->i_fop = &autofs_root_operations;\n\troot_inode->i_op = &autofs_dir_inode_operations;\n\n\tpr_debug(\"pipe fd = %d, pgrp = %u\\n\",\n\t\t sbi->pipefd, pid_nr(sbi->oz_pgrp));\n\tpipe = fget(sbi->pipefd);\n\n\tif (!pipe) {\n\t\tpr_err(\"could not open pipe file descriptor\\n\");\n\t\tgoto fail_put_pid;\n\t}\n\tret = autofs_prepare_pipe(pipe);\n\tif (ret < 0)\n\t\tgoto fail_fput;\n\tsbi->pipe = pipe;\n\tsbi->flags &= ~AUTOFS_SBI_CATATONIC;\n\n\t \n\ts->s_root = root;\n\treturn 0;\n\n\t \nfail_fput:\n\tpr_err(\"pipe file descriptor does not contain proper ops\\n\");\n\tfput(pipe);\nfail_put_pid:\n\tput_pid(sbi->oz_pgrp);\nfail_dput:\n\tdput(root);\n\tgoto fail_free;\nfail_ino:\n\tautofs_free_ino(ino);\nfail_free:\n\tkfree(sbi);\n\ts->s_fs_info = NULL;\n\treturn ret;\n}\n\nstruct inode *autofs_get_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode == NULL)\n\t\treturn NULL;\n\n\tinode->i_mode = mode;\n\tif (sb->s_root) {\n\t\tinode->i_uid = d_inode(sb->s_root)->i_uid;\n\t\tinode->i_gid = d_inode(sb->s_root)->i_gid;\n\t}\n\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\tinode->i_ino = get_next_ino();\n\n\tif (S_ISDIR(mode)) {\n\t\tset_nlink(inode, 2);\n\t\tinode->i_op = &autofs_dir_inode_operations;\n\t\tinode->i_fop = &autofs_dir_operations;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &autofs_symlink_inode_operations;\n\t} else\n\t\tWARN_ON(1);\n\n\treturn inode;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}