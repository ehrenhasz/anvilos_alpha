{
  "module_name": "root.c",
  "hash_id": "33b6062a17338b82e2f3f723c13bf5eff7c30f40c28245bc7068b9e13997a21a",
  "original_prompt": "Ingested from linux-6.6.14/fs/autofs/root.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/compat.h>\n\n#include \"autofs_i.h\"\n\nstatic int autofs_dir_permission(struct mnt_idmap *, struct inode *, int);\nstatic int autofs_dir_symlink(struct mnt_idmap *, struct inode *,\n\t\t\t      struct dentry *, const char *);\nstatic int autofs_dir_unlink(struct inode *, struct dentry *);\nstatic int autofs_dir_rmdir(struct inode *, struct dentry *);\nstatic int autofs_dir_mkdir(struct mnt_idmap *, struct inode *,\n\t\t\t    struct dentry *, umode_t);\nstatic long autofs_root_ioctl(struct file *, unsigned int, unsigned long);\n#ifdef CONFIG_COMPAT\nstatic long autofs_root_compat_ioctl(struct file *,\n\t\t\t\t     unsigned int, unsigned long);\n#endif\nstatic int autofs_dir_open(struct inode *inode, struct file *file);\nstatic struct dentry *autofs_lookup(struct inode *,\n\t\t\t\t    struct dentry *, unsigned int);\nstatic struct vfsmount *autofs_d_automount(struct path *);\nstatic int autofs_d_manage(const struct path *, bool);\nstatic void autofs_dentry_release(struct dentry *);\n\nconst struct file_operations autofs_root_operations = {\n\t.open\t\t= dcache_dir_open,\n\t.release\t= dcache_dir_close,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= dcache_readdir,\n\t.llseek\t\t= dcache_dir_lseek,\n\t.unlocked_ioctl\t= autofs_root_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= autofs_root_compat_ioctl,\n#endif\n};\n\nconst struct file_operations autofs_dir_operations = {\n\t.open\t\t= autofs_dir_open,\n\t.release\t= dcache_dir_close,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= dcache_readdir,\n\t.llseek\t\t= dcache_dir_lseek,\n};\n\nconst struct inode_operations autofs_dir_inode_operations = {\n\t.lookup\t\t= autofs_lookup,\n\t.permission\t= autofs_dir_permission,\n\t.unlink\t\t= autofs_dir_unlink,\n\t.symlink\t= autofs_dir_symlink,\n\t.mkdir\t\t= autofs_dir_mkdir,\n\t.rmdir\t\t= autofs_dir_rmdir,\n};\n\nconst struct dentry_operations autofs_dentry_operations = {\n\t.d_automount\t= autofs_d_automount,\n\t.d_manage\t= autofs_d_manage,\n\t.d_release\t= autofs_dentry_release,\n};\n\nstatic void autofs_del_active(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs_sbi(dentry->d_sb);\n\tstruct autofs_info *ino;\n\n\tino = autofs_dentry_ino(dentry);\n\tspin_lock(&sbi->lookup_lock);\n\tlist_del_init(&ino->active);\n\tspin_unlock(&sbi->lookup_lock);\n}\n\nstatic int autofs_dir_open(struct inode *inode, struct file *file)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct autofs_sb_info *sbi = autofs_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs_dentry_ino(dentry);\n\n\tpr_debug(\"file=%p dentry=%p %pd\\n\", file, dentry, dentry);\n\n\tif (autofs_oz_mode(sbi))\n\t\tgoto out;\n\n\t \n\tspin_lock(&sbi->lookup_lock);\n\tif (!path_is_mountpoint(&file->f_path) && autofs_empty(ino)) {\n\t\tspin_unlock(&sbi->lookup_lock);\n\t\treturn -ENOENT;\n\t}\n\tspin_unlock(&sbi->lookup_lock);\n\nout:\n\treturn dcache_dir_open(inode, file);\n}\n\nstatic void autofs_dentry_release(struct dentry *de)\n{\n\tstruct autofs_info *ino = autofs_dentry_ino(de);\n\tstruct autofs_sb_info *sbi = autofs_sbi(de->d_sb);\n\n\tpr_debug(\"releasing %p\\n\", de);\n\n\tif (!ino)\n\t\treturn;\n\n\tif (sbi) {\n\t\tspin_lock(&sbi->lookup_lock);\n\t\tif (!list_empty(&ino->active))\n\t\t\tlist_del(&ino->active);\n\t\tif (!list_empty(&ino->expiring))\n\t\t\tlist_del(&ino->expiring);\n\t\tspin_unlock(&sbi->lookup_lock);\n\t}\n\n\tautofs_free_ino(ino);\n}\n\nstatic struct dentry *autofs_lookup_active(struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs_sbi(dentry->d_sb);\n\tstruct dentry *parent = dentry->d_parent;\n\tconst struct qstr *name = &dentry->d_name;\n\tunsigned int len = name->len;\n\tunsigned int hash = name->hash;\n\tconst unsigned char *str = name->name;\n\tstruct list_head *p, *head;\n\n\thead = &sbi->active_list;\n\tif (list_empty(head))\n\t\treturn NULL;\n\tspin_lock(&sbi->lookup_lock);\n\tlist_for_each(p, head) {\n\t\tstruct autofs_info *ino;\n\t\tstruct dentry *active;\n\t\tconst struct qstr *qstr;\n\n\t\tino = list_entry(p, struct autofs_info, active);\n\t\tactive = ino->dentry;\n\n\t\tspin_lock(&active->d_lock);\n\n\t\t \n\t\tif ((int) d_count(active) <= 0)\n\t\t\tgoto next;\n\n\t\tqstr = &active->d_name;\n\n\t\tif (active->d_name.hash != hash)\n\t\t\tgoto next;\n\t\tif (active->d_parent != parent)\n\t\t\tgoto next;\n\n\t\tif (qstr->len != len)\n\t\t\tgoto next;\n\t\tif (memcmp(qstr->name, str, len))\n\t\t\tgoto next;\n\n\t\tif (d_unhashed(active)) {\n\t\t\tdget_dlock(active);\n\t\t\tspin_unlock(&active->d_lock);\n\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\treturn active;\n\t\t}\nnext:\n\t\tspin_unlock(&active->d_lock);\n\t}\n\tspin_unlock(&sbi->lookup_lock);\n\n\treturn NULL;\n}\n\nstatic struct dentry *autofs_lookup_expiring(struct dentry *dentry,\n\t\t\t\t\t     bool rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs_sbi(dentry->d_sb);\n\tstruct dentry *parent = dentry->d_parent;\n\tconst struct qstr *name = &dentry->d_name;\n\tunsigned int len = name->len;\n\tunsigned int hash = name->hash;\n\tconst unsigned char *str = name->name;\n\tstruct list_head *p, *head;\n\n\thead = &sbi->expiring_list;\n\tif (list_empty(head))\n\t\treturn NULL;\n\tspin_lock(&sbi->lookup_lock);\n\tlist_for_each(p, head) {\n\t\tstruct autofs_info *ino;\n\t\tstruct dentry *expiring;\n\t\tconst struct qstr *qstr;\n\n\t\tif (rcu_walk) {\n\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\t}\n\n\t\tino = list_entry(p, struct autofs_info, expiring);\n\t\texpiring = ino->dentry;\n\n\t\tspin_lock(&expiring->d_lock);\n\n\t\t \n\t\tif (d_really_is_negative(expiring))\n\t\t\tgoto next;\n\n\t\tqstr = &expiring->d_name;\n\n\t\tif (expiring->d_name.hash != hash)\n\t\t\tgoto next;\n\t\tif (expiring->d_parent != parent)\n\t\t\tgoto next;\n\n\t\tif (qstr->len != len)\n\t\t\tgoto next;\n\t\tif (memcmp(qstr->name, str, len))\n\t\t\tgoto next;\n\n\t\tif (d_unhashed(expiring)) {\n\t\t\tdget_dlock(expiring);\n\t\t\tspin_unlock(&expiring->d_lock);\n\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\treturn expiring;\n\t\t}\nnext:\n\t\tspin_unlock(&expiring->d_lock);\n\t}\n\tspin_unlock(&sbi->lookup_lock);\n\n\treturn NULL;\n}\n\nstatic int autofs_mount_wait(const struct path *path, bool rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs_sbi(path->dentry->d_sb);\n\tstruct autofs_info *ino = autofs_dentry_ino(path->dentry);\n\tint status = 0;\n\n\tif (ino->flags & AUTOFS_INF_PENDING) {\n\t\tif (rcu_walk)\n\t\t\treturn -ECHILD;\n\t\tpr_debug(\"waiting for mount name=%pd\\n\", path->dentry);\n\t\tstatus = autofs_wait(sbi, path, NFY_MOUNT);\n\t\tpr_debug(\"mount wait done status=%d\\n\", status);\n\t\tino->last_used = jiffies;\n\t\treturn status;\n\t}\n\tif (!(sbi->flags & AUTOFS_SBI_STRICTEXPIRE))\n\t\tino->last_used = jiffies;\n\treturn status;\n}\n\nstatic int do_expire_wait(const struct path *path, bool rcu_walk)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct dentry *expiring;\n\n\texpiring = autofs_lookup_expiring(dentry, rcu_walk);\n\tif (IS_ERR(expiring))\n\t\treturn PTR_ERR(expiring);\n\tif (!expiring)\n\t\treturn autofs_expire_wait(path, rcu_walk);\n\telse {\n\t\tconst struct path this = { .mnt = path->mnt, .dentry = expiring };\n\t\t \n\t\tautofs_expire_wait(&this, 0);\n\t\tautofs_del_expiring(expiring);\n\t\tdput(expiring);\n\t}\n\treturn 0;\n}\n\nstatic struct dentry *autofs_mountpoint_changed(struct path *path)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct autofs_sb_info *sbi = autofs_sbi(dentry->d_sb);\n\n\t \n\tif (autofs_type_indirect(sbi->type) && d_unhashed(dentry)) {\n\t\tstruct dentry *parent = dentry->d_parent;\n\t\tstruct autofs_info *ino;\n\t\tstruct dentry *new;\n\n\t\tnew = d_lookup(parent, &dentry->d_name);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tino = autofs_dentry_ino(new);\n\t\tino->last_used = jiffies;\n\t\tdput(path->dentry);\n\t\tpath->dentry = new;\n\t}\n\treturn path->dentry;\n}\n\nstatic struct vfsmount *autofs_d_automount(struct path *path)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct autofs_sb_info *sbi = autofs_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs_dentry_ino(dentry);\n\tint status;\n\n\tpr_debug(\"dentry=%p %pd\\n\", dentry, dentry);\n\n\t \n\tif (autofs_oz_mode(sbi))\n\t\treturn NULL;\n\n\t \n\tstatus = do_expire_wait(path, 0);\n\tif (status && status != -EAGAIN)\n\t\treturn NULL;\n\n\t \n\tspin_lock(&sbi->fs_lock);\n\tif (ino->flags & AUTOFS_INF_PENDING) {\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tstatus = autofs_mount_wait(path, 0);\n\t\tif (status)\n\t\t\treturn ERR_PTR(status);\n\t\tgoto done;\n\t}\n\n\t \n\tif (d_really_is_positive(dentry) && d_is_symlink(dentry)) {\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tgoto done;\n\t}\n\n\tif (!path_is_mountpoint(path)) {\n\t\t \n\t\tif (sbi->version > 4) {\n\t\t\tif (path_has_submounts(path)) {\n\t\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!autofs_empty(ino)) {\n\t\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tino->flags |= AUTOFS_INF_PENDING;\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tstatus = autofs_mount_wait(path, 0);\n\t\tspin_lock(&sbi->fs_lock);\n\t\tino->flags &= ~AUTOFS_INF_PENDING;\n\t\tif (status) {\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\treturn ERR_PTR(status);\n\t\t}\n\t}\n\tspin_unlock(&sbi->fs_lock);\ndone:\n\t \n\tdentry = autofs_mountpoint_changed(path);\n\tif (!dentry)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn NULL;\n}\n\nstatic int autofs_d_manage(const struct path *path, bool rcu_walk)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct autofs_sb_info *sbi = autofs_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs_dentry_ino(dentry);\n\tint status;\n\n\tpr_debug(\"dentry=%p %pd\\n\", dentry, dentry);\n\n\t \n\tif (autofs_oz_mode(sbi)) {\n\t\tif (!path_is_mountpoint(path))\n\t\t\treturn -EISDIR;\n\t\treturn 0;\n\t}\n\n\t \n\tif (do_expire_wait(path, rcu_walk) == -ECHILD)\n\t\treturn -ECHILD;\n\n\t \n\tstatus = autofs_mount_wait(path, rcu_walk);\n\tif (status)\n\t\treturn status;\n\n\tif (rcu_walk) {\n\t\t \n\t\tstruct inode *inode;\n\n\t\tif (ino->flags & AUTOFS_INF_WANT_EXPIRE)\n\t\t\treturn 0;\n\t\tif (path_is_mountpoint(path))\n\t\t\treturn 0;\n\t\tinode = d_inode_rcu(dentry);\n\t\tif (inode && S_ISLNK(inode->i_mode))\n\t\t\treturn -EISDIR;\n\t\tif (!autofs_empty(ino))\n\t\t\treturn -EISDIR;\n\t\treturn 0;\n\t}\n\n\tspin_lock(&sbi->fs_lock);\n\t \n\tif (!(ino->flags & AUTOFS_INF_EXPIRING)) {\n\t\t \n\t\tif ((!path_is_mountpoint(path) && !autofs_empty(ino)) ||\n\t\t    (d_really_is_positive(dentry) && d_is_symlink(dentry)))\n\t\t\tstatus = -EISDIR;\n\t}\n\tspin_unlock(&sbi->fs_lock);\n\n\treturn status;\n}\n\n \nstatic struct dentry *autofs_lookup(struct inode *dir,\n\t\t\t\t    struct dentry *dentry, unsigned int flags)\n{\n\tstruct autofs_sb_info *sbi;\n\tstruct autofs_info *ino;\n\tstruct dentry *active;\n\n\tpr_debug(\"name = %pd\\n\", dentry);\n\n\t \n\tif (dentry->d_name.len > NAME_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tsbi = autofs_sbi(dir->i_sb);\n\n\tpr_debug(\"pid = %u, pgrp = %u, catatonic = %d, oz_mode = %d\\n\",\n\t\t current->pid, task_pgrp_nr(current),\n\t\t sbi->flags & AUTOFS_SBI_CATATONIC,\n\t\t autofs_oz_mode(sbi));\n\n\tactive = autofs_lookup_active(dentry);\n\tif (active)\n\t\treturn active;\n\telse {\n\t\t \n\t\tif (!autofs_oz_mode(sbi) && !IS_ROOT(dentry->d_parent))\n\t\t\treturn ERR_PTR(-ENOENT);\n\n\t\tino = autofs_new_ino(sbi);\n\t\tif (!ino)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tspin_lock(&sbi->lookup_lock);\n\t\tspin_lock(&dentry->d_lock);\n\t\t \n\t\tif (IS_ROOT(dentry->d_parent) &&\n\t\t    autofs_type_indirect(sbi->type))\n\t\t\t__managed_dentry_set_managed(dentry);\n\t\tdentry->d_fsdata = ino;\n\t\tino->dentry = dentry;\n\n\t\tlist_add(&ino->active, &sbi->active_list);\n\t\tspin_unlock(&sbi->lookup_lock);\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\treturn NULL;\n}\n\nstatic int autofs_dir_permission(struct mnt_idmap *idmap,\n\t\t\t\t struct inode *inode, int mask)\n{\n\tif (mask & MAY_WRITE) {\n\t\tstruct autofs_sb_info *sbi = autofs_sbi(inode->i_sb);\n\n\t\tif (!autofs_oz_mode(sbi))\n\t\t\treturn -EACCES;\n\n\t\t \n\t\tif (sbi->flags & AUTOFS_SBI_CATATONIC)\n\t\t\treturn -EACCES;\n\t}\n\n\treturn generic_permission(idmap, inode, mask);\n}\n\nstatic int autofs_dir_symlink(struct mnt_idmap *idmap,\n\t\t\t      struct inode *dir, struct dentry *dentry,\n\t\t\t      const char *symname)\n{\n\tstruct autofs_info *ino = autofs_dentry_ino(dentry);\n\tstruct autofs_info *p_ino;\n\tstruct inode *inode;\n\tsize_t size = strlen(symname);\n\tchar *cp;\n\n\tpr_debug(\"%s <- %pd\\n\", symname, dentry);\n\n\tBUG_ON(!ino);\n\n\tautofs_clean_ino(ino);\n\n\tautofs_del_active(dentry);\n\n\tcp = kmalloc(size + 1, GFP_KERNEL);\n\tif (!cp)\n\t\treturn -ENOMEM;\n\n\tstrcpy(cp, symname);\n\n\tinode = autofs_get_inode(dir->i_sb, S_IFLNK | 0555);\n\tif (!inode) {\n\t\tkfree(cp);\n\t\treturn -ENOMEM;\n\t}\n\tinode->i_private = cp;\n\tinode->i_size = size;\n\td_add(dentry, inode);\n\n\tdget(dentry);\n\tp_ino = autofs_dentry_ino(dentry->d_parent);\n\tp_ino->count++;\n\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\n\treturn 0;\n}\n\n \nstatic int autofs_dir_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs_sbi(dir->i_sb);\n\tstruct autofs_info *ino = autofs_dentry_ino(dentry);\n\tstruct autofs_info *p_ino;\n\n\tp_ino = autofs_dentry_ino(dentry->d_parent);\n\tp_ino->count--;\n\tdput(ino->dentry);\n\n\td_inode(dentry)->i_size = 0;\n\tclear_nlink(d_inode(dentry));\n\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\n\tspin_lock(&sbi->lookup_lock);\n\t__autofs_add_expiring(dentry);\n\td_drop(dentry);\n\tspin_unlock(&sbi->lookup_lock);\n\n\treturn 0;\n}\n\n \nstatic void autofs_set_leaf_automount_flags(struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\n\t \n\tif (IS_ROOT(dentry->d_parent))\n\t\treturn;\n\n\tmanaged_dentry_set_managed(dentry);\n\n\tparent = dentry->d_parent;\n\t \n\tif (IS_ROOT(parent->d_parent))\n\t\treturn;\n\tmanaged_dentry_clear_managed(parent);\n}\n\nstatic void autofs_clear_leaf_automount_flags(struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\n\t \n\tif (IS_ROOT(dentry->d_parent))\n\t\treturn;\n\n\tmanaged_dentry_clear_managed(dentry);\n\n\tparent = dentry->d_parent;\n\t \n\tif (IS_ROOT(parent->d_parent))\n\t\treturn;\n\tif (autofs_dentry_ino(parent)->count == 2)\n\t\tmanaged_dentry_set_managed(parent);\n}\n\nstatic int autofs_dir_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct autofs_sb_info *sbi = autofs_sbi(dir->i_sb);\n\tstruct autofs_info *ino = autofs_dentry_ino(dentry);\n\tstruct autofs_info *p_ino;\n\n\tpr_debug(\"dentry %p, removing %pd\\n\", dentry, dentry);\n\n\tif (ino->count != 1)\n\t\treturn -ENOTEMPTY;\n\n\tspin_lock(&sbi->lookup_lock);\n\t__autofs_add_expiring(dentry);\n\td_drop(dentry);\n\tspin_unlock(&sbi->lookup_lock);\n\n\tif (sbi->version < 5)\n\t\tautofs_clear_leaf_automount_flags(dentry);\n\n\tp_ino = autofs_dentry_ino(dentry->d_parent);\n\tp_ino->count--;\n\tdput(ino->dentry);\n\td_inode(dentry)->i_size = 0;\n\tclear_nlink(d_inode(dentry));\n\n\tif (dir->i_nlink)\n\t\tdrop_nlink(dir);\n\n\treturn 0;\n}\n\nstatic int autofs_dir_mkdir(struct mnt_idmap *idmap,\n\t\t\t    struct inode *dir, struct dentry *dentry,\n\t\t\t    umode_t mode)\n{\n\tstruct autofs_sb_info *sbi = autofs_sbi(dir->i_sb);\n\tstruct autofs_info *ino = autofs_dentry_ino(dentry);\n\tstruct autofs_info *p_ino;\n\tstruct inode *inode;\n\n\tpr_debug(\"dentry %p, creating %pd\\n\", dentry, dentry);\n\n\tBUG_ON(!ino);\n\n\tautofs_clean_ino(ino);\n\n\tautofs_del_active(dentry);\n\n\tinode = autofs_get_inode(dir->i_sb, S_IFDIR | mode);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\td_add(dentry, inode);\n\n\tif (sbi->version < 5)\n\t\tautofs_set_leaf_automount_flags(dentry);\n\n\tdget(dentry);\n\tp_ino = autofs_dentry_ino(dentry->d_parent);\n\tp_ino->count++;\n\tinc_nlink(dir);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\n\treturn 0;\n}\n\n \n#ifdef CONFIG_COMPAT\nstatic inline int autofs_compat_get_set_timeout(struct autofs_sb_info *sbi,\n\t\t\t\t\t\t compat_ulong_t __user *p)\n{\n\tunsigned long ntimeout;\n\tint rv;\n\n\trv = get_user(ntimeout, p);\n\tif (rv)\n\t\tgoto error;\n\n\trv = put_user(sbi->exp_timeout/HZ, p);\n\tif (rv)\n\t\tgoto error;\n\n\tif (ntimeout > UINT_MAX/HZ)\n\t\tsbi->exp_timeout = 0;\n\telse\n\t\tsbi->exp_timeout = ntimeout * HZ;\n\n\treturn 0;\nerror:\n\treturn rv;\n}\n#endif\n\nstatic inline int autofs_get_set_timeout(struct autofs_sb_info *sbi,\n\t\t\t\t\t  unsigned long __user *p)\n{\n\tunsigned long ntimeout;\n\tint rv;\n\n\trv = get_user(ntimeout, p);\n\tif (rv)\n\t\tgoto error;\n\n\trv = put_user(sbi->exp_timeout/HZ, p);\n\tif (rv)\n\t\tgoto error;\n\n\tif (ntimeout > ULONG_MAX/HZ)\n\t\tsbi->exp_timeout = 0;\n\telse\n\t\tsbi->exp_timeout = ntimeout * HZ;\n\n\treturn 0;\nerror:\n\treturn rv;\n}\n\n \nstatic inline int autofs_get_protover(struct autofs_sb_info *sbi,\n\t\t\t\t       int __user *p)\n{\n\treturn put_user(sbi->version, p);\n}\n\n \nstatic inline int autofs_get_protosubver(struct autofs_sb_info *sbi,\n\t\t\t\t\t  int __user *p)\n{\n\treturn put_user(sbi->sub_version, p);\n}\n\n \nstatic inline int autofs_ask_umount(struct vfsmount *mnt, int __user *p)\n{\n\tint status = 0;\n\n\tif (may_umount(mnt))\n\t\tstatus = 1;\n\n\tpr_debug(\"may umount %d\\n\", status);\n\n\tstatus = put_user(status, p);\n\n\treturn status;\n}\n\n \nint is_autofs_dentry(struct dentry *dentry)\n{\n\treturn dentry && d_really_is_positive(dentry) &&\n\t\tdentry->d_op == &autofs_dentry_operations &&\n\t\tdentry->d_fsdata != NULL;\n}\n\n \nstatic int autofs_root_ioctl_unlocked(struct inode *inode, struct file *filp,\n\t\t\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct autofs_sb_info *sbi = autofs_sbi(inode->i_sb);\n\tvoid __user *p = (void __user *)arg;\n\n\tpr_debug(\"cmd = 0x%08x, arg = 0x%08lx, sbi = %p, pgrp = %u\\n\",\n\t\t cmd, arg, sbi, task_pgrp_nr(current));\n\n\tif (_IOC_TYPE(cmd) != _IOC_TYPE(AUTOFS_IOC_FIRST) ||\n\t     _IOC_NR(cmd) - _IOC_NR(AUTOFS_IOC_FIRST) >= AUTOFS_IOC_COUNT)\n\t\treturn -ENOTTY;\n\n\tif (!autofs_oz_mode(sbi) && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase AUTOFS_IOC_READY:\t \n\t\treturn autofs_wait_release(sbi, (autofs_wqt_t) arg, 0);\n\tcase AUTOFS_IOC_FAIL:\t \n\t\treturn autofs_wait_release(sbi, (autofs_wqt_t) arg, -ENOENT);\n\tcase AUTOFS_IOC_CATATONIC:  \n\t\tautofs_catatonic_mode(sbi);\n\t\treturn 0;\n\tcase AUTOFS_IOC_PROTOVER:  \n\t\treturn autofs_get_protover(sbi, p);\n\tcase AUTOFS_IOC_PROTOSUBVER:  \n\t\treturn autofs_get_protosubver(sbi, p);\n\tcase AUTOFS_IOC_SETTIMEOUT:\n\t\treturn autofs_get_set_timeout(sbi, p);\n#ifdef CONFIG_COMPAT\n\tcase AUTOFS_IOC_SETTIMEOUT32:\n\t\treturn autofs_compat_get_set_timeout(sbi, p);\n#endif\n\n\tcase AUTOFS_IOC_ASKUMOUNT:\n\t\treturn autofs_ask_umount(filp->f_path.mnt, p);\n\n\t \n\tcase AUTOFS_IOC_EXPIRE:\n\t\treturn autofs_expire_run(inode->i_sb, filp->f_path.mnt, sbi, p);\n\t \n\tcase AUTOFS_IOC_EXPIRE_MULTI:\n\t\treturn autofs_expire_multi(inode->i_sb,\n\t\t\t\t\t   filp->f_path.mnt, sbi, p);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic long autofs_root_ioctl(struct file *filp,\n\t\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\treturn autofs_root_ioctl_unlocked(inode, filp, cmd, arg);\n}\n\n#ifdef CONFIG_COMPAT\nstatic long autofs_root_compat_ioctl(struct file *filp,\n\t\t\t\t      unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint ret;\n\n\tif (cmd == AUTOFS_IOC_READY || cmd == AUTOFS_IOC_FAIL)\n\t\tret = autofs_root_ioctl_unlocked(inode, filp, cmd, arg);\n\telse\n\t\tret = autofs_root_ioctl_unlocked(inode, filp, cmd,\n\t\t\t\t\t      (unsigned long) compat_ptr(arg));\n\n\treturn ret;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}