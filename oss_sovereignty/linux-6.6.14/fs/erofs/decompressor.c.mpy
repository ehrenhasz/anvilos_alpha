{
  "module_name": "decompressor.c",
  "hash_id": "93f80e1e7a53f1b6bf2a169823ac2d95ffb58ea94c2a915cbe3325657c8f623c",
  "original_prompt": "Ingested from linux-6.6.14/fs/erofs/decompressor.c",
  "human_readable_source": "\n \n#include \"compress.h\"\n#include <linux/module.h>\n#include <linux/lz4.h>\n\n#ifndef LZ4_DISTANCE_MAX\t \n#define LZ4_DISTANCE_MAX 65535\t \n#endif\n\n#define LZ4_MAX_DISTANCE_PAGES\t(DIV_ROUND_UP(LZ4_DISTANCE_MAX, PAGE_SIZE) + 1)\n#ifndef LZ4_DECOMPRESS_INPLACE_MARGIN\n#define LZ4_DECOMPRESS_INPLACE_MARGIN(srcsize)  (((srcsize) >> 8) + 32)\n#endif\n\nstruct z_erofs_lz4_decompress_ctx {\n\tstruct z_erofs_decompress_req *rq;\n\t \n\tunsigned int inpages, outpages;\n\t \n\tunsigned int oend;\n};\n\nstatic int z_erofs_load_lz4_config(struct super_block *sb,\n\t\t\t    struct erofs_super_block *dsb, void *data, int size)\n{\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\tstruct z_erofs_lz4_cfgs *lz4 = data;\n\tu16 distance;\n\n\tif (lz4) {\n\t\tif (size < sizeof(struct z_erofs_lz4_cfgs)) {\n\t\t\terofs_err(sb, \"invalid lz4 cfgs, size=%u\", size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdistance = le16_to_cpu(lz4->max_distance);\n\n\t\tsbi->lz4.max_pclusterblks = le16_to_cpu(lz4->max_pclusterblks);\n\t\tif (!sbi->lz4.max_pclusterblks) {\n\t\t\tsbi->lz4.max_pclusterblks = 1;\t \n\t\t} else if (sbi->lz4.max_pclusterblks >\n\t\t\t   erofs_blknr(sb, Z_EROFS_PCLUSTER_MAX_SIZE)) {\n\t\t\terofs_err(sb, \"too large lz4 pclusterblks %u\",\n\t\t\t\t  sbi->lz4.max_pclusterblks);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tdistance = le16_to_cpu(dsb->u1.lz4_max_distance);\n\t\tsbi->lz4.max_pclusterblks = 1;\n\t}\n\n\tsbi->lz4.max_distance_pages = distance ?\n\t\t\t\t\tDIV_ROUND_UP(distance, PAGE_SIZE) + 1 :\n\t\t\t\t\tLZ4_MAX_DISTANCE_PAGES;\n\treturn erofs_pcpubuf_growsize(sbi->lz4.max_pclusterblks);\n}\n\n \nstatic int z_erofs_lz4_prepare_dstpages(struct z_erofs_lz4_decompress_ctx *ctx,\n\t\t\t\t\tstruct page **pagepool)\n{\n\tstruct z_erofs_decompress_req *rq = ctx->rq;\n\tstruct page *availables[LZ4_MAX_DISTANCE_PAGES] = { NULL };\n\tunsigned long bounced[DIV_ROUND_UP(LZ4_MAX_DISTANCE_PAGES,\n\t\t\t\t\t   BITS_PER_LONG)] = { 0 };\n\tunsigned int lz4_max_distance_pages =\n\t\t\t\tEROFS_SB(rq->sb)->lz4.max_distance_pages;\n\tvoid *kaddr = NULL;\n\tunsigned int i, j, top;\n\n\ttop = 0;\n\tfor (i = j = 0; i < ctx->outpages; ++i, ++j) {\n\t\tstruct page *const page = rq->out[i];\n\t\tstruct page *victim;\n\n\t\tif (j >= lz4_max_distance_pages)\n\t\t\tj = 0;\n\n\t\t \n\t\tif (!rq->fillgaps && test_bit(j, bounced)) {\n\t\t\tDBG_BUGON(i < lz4_max_distance_pages);\n\t\t\tDBG_BUGON(top >= lz4_max_distance_pages);\n\t\t\tavailables[top++] = rq->out[i - lz4_max_distance_pages];\n\t\t}\n\n\t\tif (page) {\n\t\t\t__clear_bit(j, bounced);\n\t\t\tif (!PageHighMem(page)) {\n\t\t\t\tif (!i) {\n\t\t\t\t\tkaddr = page_address(page);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (kaddr &&\n\t\t\t\t    kaddr + PAGE_SIZE == page_address(page)) {\n\t\t\t\t\tkaddr += PAGE_SIZE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tkaddr = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tkaddr = NULL;\n\t\t__set_bit(j, bounced);\n\n\t\tif (top) {\n\t\t\tvictim = availables[--top];\n\t\t\tget_page(victim);\n\t\t} else {\n\t\t\tvictim = erofs_allocpage(pagepool,\n\t\t\t\t\t\t GFP_KERNEL | __GFP_NOFAIL);\n\t\t\tset_page_private(victim, Z_EROFS_SHORTLIVED_PAGE);\n\t\t}\n\t\trq->out[i] = victim;\n\t}\n\treturn kaddr ? 1 : 0;\n}\n\nstatic void *z_erofs_lz4_handle_overlap(struct z_erofs_lz4_decompress_ctx *ctx,\n\t\t\tvoid *inpage, unsigned int *inputmargin, int *maptype,\n\t\t\tbool may_inplace)\n{\n\tstruct z_erofs_decompress_req *rq = ctx->rq;\n\tunsigned int omargin, total, i, j;\n\tstruct page **in;\n\tvoid *src, *tmp;\n\n\tif (rq->inplace_io) {\n\t\tomargin = PAGE_ALIGN(ctx->oend) - ctx->oend;\n\t\tif (rq->partial_decoding || !may_inplace ||\n\t\t    omargin < LZ4_DECOMPRESS_INPLACE_MARGIN(rq->inputsize))\n\t\t\tgoto docopy;\n\n\t\tfor (i = 0; i < ctx->inpages; ++i) {\n\t\t\tDBG_BUGON(rq->in[i] == NULL);\n\t\t\tfor (j = 0; j < ctx->outpages - ctx->inpages + i; ++j)\n\t\t\t\tif (rq->out[j] == rq->in[i])\n\t\t\t\t\tgoto docopy;\n\t\t}\n\t}\n\n\tif (ctx->inpages <= 1) {\n\t\t*maptype = 0;\n\t\treturn inpage;\n\t}\n\tkunmap_local(inpage);\n\tmight_sleep();\n\tsrc = erofs_vm_map_ram(rq->in, ctx->inpages);\n\tif (!src)\n\t\treturn ERR_PTR(-ENOMEM);\n\t*maptype = 1;\n\treturn src;\n\ndocopy:\n\t \n\tin = rq->in;\n\tsrc = erofs_get_pcpubuf(ctx->inpages);\n\tif (!src) {\n\t\tDBG_BUGON(1);\n\t\tkunmap_local(inpage);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\ttmp = src;\n\ttotal = rq->inputsize;\n\twhile (total) {\n\t\tunsigned int page_copycnt =\n\t\t\tmin_t(unsigned int, total, PAGE_SIZE - *inputmargin);\n\n\t\tif (!inpage)\n\t\t\tinpage = kmap_local_page(*in);\n\t\tmemcpy(tmp, inpage + *inputmargin, page_copycnt);\n\t\tkunmap_local(inpage);\n\t\tinpage = NULL;\n\t\ttmp += page_copycnt;\n\t\ttotal -= page_copycnt;\n\t\t++in;\n\t\t*inputmargin = 0;\n\t}\n\t*maptype = 2;\n\treturn src;\n}\n\n \nint z_erofs_fixup_insize(struct z_erofs_decompress_req *rq, const char *padbuf,\n\t\t\t unsigned int padbufsize)\n{\n\tconst char *padend;\n\n\tpadend = memchr_inv(padbuf, 0, padbufsize);\n\tif (!padend)\n\t\treturn -EFSCORRUPTED;\n\trq->inputsize -= padend - padbuf;\n\trq->pageofs_in += padend - padbuf;\n\treturn 0;\n}\n\nstatic int z_erofs_lz4_decompress_mem(struct z_erofs_lz4_decompress_ctx *ctx,\n\t\t\t\t      u8 *out)\n{\n\tstruct z_erofs_decompress_req *rq = ctx->rq;\n\tbool support_0padding = false, may_inplace = false;\n\tunsigned int inputmargin;\n\tu8 *headpage, *src;\n\tint ret, maptype;\n\n\tDBG_BUGON(*rq->in == NULL);\n\theadpage = kmap_local_page(*rq->in);\n\n\t \n\tif (erofs_sb_has_zero_padding(EROFS_SB(rq->sb))) {\n\t\tsupport_0padding = true;\n\t\tret = z_erofs_fixup_insize(rq, headpage + rq->pageofs_in,\n\t\t\t\tmin_t(unsigned int, rq->inputsize,\n\t\t\t\t      rq->sb->s_blocksize - rq->pageofs_in));\n\t\tif (ret) {\n\t\t\tkunmap_local(headpage);\n\t\t\treturn ret;\n\t\t}\n\t\tmay_inplace = !((rq->pageofs_in + rq->inputsize) &\n\t\t\t\t(rq->sb->s_blocksize - 1));\n\t}\n\n\tinputmargin = rq->pageofs_in;\n\tsrc = z_erofs_lz4_handle_overlap(ctx, headpage, &inputmargin,\n\t\t\t\t\t &maptype, may_inplace);\n\tif (IS_ERR(src))\n\t\treturn PTR_ERR(src);\n\n\t \n\tif (rq->partial_decoding || !support_0padding)\n\t\tret = LZ4_decompress_safe_partial(src + inputmargin, out,\n\t\t\t\trq->inputsize, rq->outputsize, rq->outputsize);\n\telse\n\t\tret = LZ4_decompress_safe(src + inputmargin, out,\n\t\t\t\t\t  rq->inputsize, rq->outputsize);\n\n\tif (ret != rq->outputsize) {\n\t\terofs_err(rq->sb, \"failed to decompress %d in[%u, %u] out[%u]\",\n\t\t\t  ret, rq->inputsize, inputmargin, rq->outputsize);\n\n\t\tprint_hex_dump(KERN_DEBUG, \"[ in]: \", DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, src + inputmargin, rq->inputsize, true);\n\t\tprint_hex_dump(KERN_DEBUG, \"[out]: \", DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, out, rq->outputsize, true);\n\n\t\tif (ret >= 0)\n\t\t\tmemset(out + ret, 0, rq->outputsize - ret);\n\t\tret = -EIO;\n\t} else {\n\t\tret = 0;\n\t}\n\n\tif (maptype == 0) {\n\t\tkunmap_local(headpage);\n\t} else if (maptype == 1) {\n\t\tvm_unmap_ram(src, ctx->inpages);\n\t} else if (maptype == 2) {\n\t\terofs_put_pcpubuf(src);\n\t} else {\n\t\tDBG_BUGON(1);\n\t\treturn -EFAULT;\n\t}\n\treturn ret;\n}\n\nstatic int z_erofs_lz4_decompress(struct z_erofs_decompress_req *rq,\n\t\t\t\t  struct page **pagepool)\n{\n\tstruct z_erofs_lz4_decompress_ctx ctx;\n\tunsigned int dst_maptype;\n\tvoid *dst;\n\tint ret;\n\n\tctx.rq = rq;\n\tctx.oend = rq->pageofs_out + rq->outputsize;\n\tctx.outpages = PAGE_ALIGN(ctx.oend) >> PAGE_SHIFT;\n\tctx.inpages = PAGE_ALIGN(rq->inputsize) >> PAGE_SHIFT;\n\n\t \n\tif (ctx.inpages == 1 && ctx.outpages == 1 && !rq->inplace_io) {\n\t\tDBG_BUGON(!*rq->out);\n\t\tdst = kmap_local_page(*rq->out);\n\t\tdst_maptype = 0;\n\t\tgoto dstmap_out;\n\t}\n\n\t \n\tret = z_erofs_lz4_prepare_dstpages(&ctx, pagepool);\n\tif (ret < 0) {\n\t\treturn ret;\n\t} else if (ret > 0) {\n\t\tdst = page_address(*rq->out);\n\t\tdst_maptype = 1;\n\t} else {\n\t\tdst = erofs_vm_map_ram(rq->out, ctx.outpages);\n\t\tif (!dst)\n\t\t\treturn -ENOMEM;\n\t\tdst_maptype = 2;\n\t}\n\ndstmap_out:\n\tret = z_erofs_lz4_decompress_mem(&ctx, dst + rq->pageofs_out);\n\tif (!dst_maptype)\n\t\tkunmap_local(dst);\n\telse if (dst_maptype == 2)\n\t\tvm_unmap_ram(dst, ctx.outpages);\n\treturn ret;\n}\n\nstatic int z_erofs_transform_plain(struct z_erofs_decompress_req *rq,\n\t\t\t\t   struct page **pagepool)\n{\n\tconst unsigned int inpages = PAGE_ALIGN(rq->inputsize) >> PAGE_SHIFT;\n\tconst unsigned int outpages =\n\t\tPAGE_ALIGN(rq->pageofs_out + rq->outputsize) >> PAGE_SHIFT;\n\tconst unsigned int righthalf = min_t(unsigned int, rq->outputsize,\n\t\t\t\t\t     PAGE_SIZE - rq->pageofs_out);\n\tconst unsigned int lefthalf = rq->outputsize - righthalf;\n\tconst unsigned int interlaced_offset =\n\t\trq->alg == Z_EROFS_COMPRESSION_SHIFTED ? 0 : rq->pageofs_out;\n\tu8 *src;\n\n\tif (outpages > 2 && rq->alg == Z_EROFS_COMPRESSION_SHIFTED) {\n\t\tDBG_BUGON(1);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (rq->out[0] == *rq->in) {\n\t\tDBG_BUGON(rq->pageofs_out);\n\t\treturn 0;\n\t}\n\n\tsrc = kmap_local_page(rq->in[inpages - 1]) + rq->pageofs_in;\n\tif (rq->out[0])\n\t\tmemcpy_to_page(rq->out[0], rq->pageofs_out,\n\t\t\t       src + interlaced_offset, righthalf);\n\n\tif (outpages > inpages) {\n\t\tDBG_BUGON(!rq->out[outpages - 1]);\n\t\tif (rq->out[outpages - 1] != rq->in[inpages - 1]) {\n\t\t\tmemcpy_to_page(rq->out[outpages - 1], 0, src +\n\t\t\t\t\t(interlaced_offset ? 0 : righthalf),\n\t\t\t\t       lefthalf);\n\t\t} else if (!interlaced_offset) {\n\t\t\tmemmove(src, src + righthalf, lefthalf);\n\t\t\tflush_dcache_page(rq->in[inpages - 1]);\n\t\t}\n\t}\n\tkunmap_local(src);\n\treturn 0;\n}\n\nconst struct z_erofs_decompressor erofs_decompressors[] = {\n\t[Z_EROFS_COMPRESSION_SHIFTED] = {\n\t\t.decompress = z_erofs_transform_plain,\n\t\t.name = \"shifted\"\n\t},\n\t[Z_EROFS_COMPRESSION_INTERLACED] = {\n\t\t.decompress = z_erofs_transform_plain,\n\t\t.name = \"interlaced\"\n\t},\n\t[Z_EROFS_COMPRESSION_LZ4] = {\n\t\t.config = z_erofs_load_lz4_config,\n\t\t.decompress = z_erofs_lz4_decompress,\n\t\t.name = \"lz4\"\n\t},\n#ifdef CONFIG_EROFS_FS_ZIP_LZMA\n\t[Z_EROFS_COMPRESSION_LZMA] = {\n\t\t.config = z_erofs_load_lzma_config,\n\t\t.decompress = z_erofs_lzma_decompress,\n\t\t.name = \"lzma\"\n\t},\n#endif\n#ifdef CONFIG_EROFS_FS_ZIP_DEFLATE\n\t[Z_EROFS_COMPRESSION_DEFLATE] = {\n\t\t.config = z_erofs_load_deflate_config,\n\t\t.decompress = z_erofs_deflate_decompress,\n\t\t.name = \"deflate\"\n\t},\n#endif\n};\n\nint z_erofs_parse_cfgs(struct super_block *sb, struct erofs_super_block *dsb)\n{\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\tstruct erofs_buf buf = __EROFS_BUF_INITIALIZER;\n\tunsigned int algs, alg;\n\terofs_off_t offset;\n\tint size, ret = 0;\n\n\tif (!erofs_sb_has_compr_cfgs(sbi)) {\n\t\tsbi->available_compr_algs = 1 << Z_EROFS_COMPRESSION_LZ4;\n\t\treturn z_erofs_load_lz4_config(sb, dsb, NULL, 0);\n\t}\n\n\tsbi->available_compr_algs = le16_to_cpu(dsb->u1.available_compr_algs);\n\tif (sbi->available_compr_algs & ~Z_EROFS_ALL_COMPR_ALGS) {\n\t\terofs_err(sb, \"unidentified algorithms %x, please upgrade kernel\",\n\t\t\t  sbi->available_compr_algs & ~Z_EROFS_ALL_COMPR_ALGS);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terofs_init_metabuf(&buf, sb);\n\toffset = EROFS_SUPER_OFFSET + sbi->sb_size;\n\talg = 0;\n\tfor (algs = sbi->available_compr_algs; algs; algs >>= 1, ++alg) {\n\t\tvoid *data;\n\n\t\tif (!(algs & 1))\n\t\t\tcontinue;\n\n\t\tdata = erofs_read_metadata(sb, &buf, &offset, &size);\n\t\tif (IS_ERR(data)) {\n\t\t\tret = PTR_ERR(data);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (alg >= ARRAY_SIZE(erofs_decompressors) ||\n\t\t    !erofs_decompressors[alg].config) {\n\t\t\terofs_err(sb, \"algorithm %d isn't enabled on this kernel\",\n\t\t\t\t  alg);\n\t\t\tret = -EOPNOTSUPP;\n\t\t} else {\n\t\t\tret = erofs_decompressors[alg].config(sb,\n\t\t\t\t\tdsb, data, size);\n\t\t}\n\n\t\tkfree(data);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\terofs_put_metabuf(&buf);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}