{
  "module_name": "pcpubuf.c",
  "hash_id": "030f98d16badeb8dc237134303d7171663292cac635856e40a5d00d7ea6ee38d",
  "original_prompt": "Ingested from linux-6.6.14/fs/erofs/pcpubuf.c",
  "human_readable_source": "\n \n#include \"internal.h\"\n\nstruct erofs_pcpubuf {\n\traw_spinlock_t lock;\n\tvoid *ptr;\n\tstruct page **pages;\n\tunsigned int nrpages;\n};\n\nstatic DEFINE_PER_CPU(struct erofs_pcpubuf, erofs_pcb);\n\nvoid *erofs_get_pcpubuf(unsigned int requiredpages)\n\t__acquires(pcb->lock)\n{\n\tstruct erofs_pcpubuf *pcb = &get_cpu_var(erofs_pcb);\n\n\traw_spin_lock(&pcb->lock);\n\t \n\tif (requiredpages > pcb->nrpages) {\n\t\traw_spin_unlock(&pcb->lock);\n\t\tput_cpu_var(erofs_pcb);\n\t\t \n\t\t__acquire(pcb->lock);\n\t\treturn NULL;\n\t}\n\treturn pcb->ptr;\n}\n\nvoid erofs_put_pcpubuf(void *ptr) __releases(pcb->lock)\n{\n\tstruct erofs_pcpubuf *pcb = &per_cpu(erofs_pcb, smp_processor_id());\n\n\tDBG_BUGON(pcb->ptr != ptr);\n\traw_spin_unlock(&pcb->lock);\n\tput_cpu_var(erofs_pcb);\n}\n\n \nint erofs_pcpubuf_growsize(unsigned int nrpages)\n{\n\tstatic DEFINE_MUTEX(pcb_resize_mutex);\n\tstatic unsigned int pcb_nrpages;\n\tstruct page *pagepool = NULL;\n\tint delta, cpu, ret, i;\n\n\tmutex_lock(&pcb_resize_mutex);\n\tdelta = nrpages - pcb_nrpages;\n\tret = 0;\n\t \n\tif (delta <= 0)\n\t\tgoto out;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct erofs_pcpubuf *pcb = &per_cpu(erofs_pcb, cpu);\n\t\tstruct page **pages, **oldpages;\n\t\tvoid *ptr, *old_ptr;\n\n\t\tpages = kmalloc_array(nrpages, sizeof(*pages), GFP_KERNEL);\n\t\tif (!pages) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nrpages; ++i) {\n\t\t\tpages[i] = erofs_allocpage(&pagepool, GFP_KERNEL);\n\t\t\tif (!pages[i]) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\toldpages = pages;\n\t\t\t\tgoto free_pagearray;\n\t\t\t}\n\t\t}\n\t\tptr = vmap(pages, nrpages, VM_MAP, PAGE_KERNEL);\n\t\tif (!ptr) {\n\t\t\tret = -ENOMEM;\n\t\t\toldpages = pages;\n\t\t\tgoto free_pagearray;\n\t\t}\n\t\traw_spin_lock(&pcb->lock);\n\t\told_ptr = pcb->ptr;\n\t\tpcb->ptr = ptr;\n\t\toldpages = pcb->pages;\n\t\tpcb->pages = pages;\n\t\ti = pcb->nrpages;\n\t\tpcb->nrpages = nrpages;\n\t\traw_spin_unlock(&pcb->lock);\n\n\t\tif (!oldpages) {\n\t\t\tDBG_BUGON(old_ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (old_ptr)\n\t\t\tvunmap(old_ptr);\nfree_pagearray:\n\t\twhile (i)\n\t\t\terofs_pagepool_add(&pagepool, oldpages[--i]);\n\t\tkfree(oldpages);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tpcb_nrpages = nrpages;\n\terofs_release_pages(&pagepool);\nout:\n\tmutex_unlock(&pcb_resize_mutex);\n\treturn ret;\n}\n\nvoid __init erofs_pcpubuf_init(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct erofs_pcpubuf *pcb = &per_cpu(erofs_pcb, cpu);\n\n\t\traw_spin_lock_init(&pcb->lock);\n\t}\n}\n\nvoid erofs_pcpubuf_exit(void)\n{\n\tint cpu, i;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct erofs_pcpubuf *pcb = &per_cpu(erofs_pcb, cpu);\n\n\t\tif (pcb->ptr) {\n\t\t\tvunmap(pcb->ptr);\n\t\t\tpcb->ptr = NULL;\n\t\t}\n\t\tif (!pcb->pages)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < pcb->nrpages; ++i)\n\t\t\tif (pcb->pages[i])\n\t\t\t\tput_page(pcb->pages[i]);\n\t\tkfree(pcb->pages);\n\t\tpcb->pages = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}