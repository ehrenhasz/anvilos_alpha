{
  "module_name": "inode.c",
  "hash_id": "208fb28d59f5a68e2955bf43d861d330b2183bc4c3472b8d9d410e40f126a0e3",
  "original_prompt": "Ingested from linux-6.6.14/fs/erofs/inode.c",
  "human_readable_source": "\n \n#include \"xattr.h\"\n\n#include <trace/events/erofs.h>\n\nstatic void *erofs_read_inode(struct erofs_buf *buf,\n\t\t\t      struct inode *inode, unsigned int *ofs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\tstruct erofs_inode *vi = EROFS_I(inode);\n\tconst erofs_off_t inode_loc = erofs_iloc(inode);\n\n\terofs_blk_t blkaddr, nblks = 0;\n\tvoid *kaddr;\n\tstruct erofs_inode_compact *dic;\n\tstruct erofs_inode_extended *die, *copied = NULL;\n\tunsigned int ifmt;\n\tint err;\n\n\tblkaddr = erofs_blknr(sb, inode_loc);\n\t*ofs = erofs_blkoff(sb, inode_loc);\n\n\tkaddr = erofs_read_metabuf(buf, sb, blkaddr, EROFS_KMAP);\n\tif (IS_ERR(kaddr)) {\n\t\terofs_err(sb, \"failed to get inode (nid: %llu) page, err %ld\",\n\t\t\t  vi->nid, PTR_ERR(kaddr));\n\t\treturn kaddr;\n\t}\n\n\tdic = kaddr + *ofs;\n\tifmt = le16_to_cpu(dic->i_format);\n\n\tif (ifmt & ~EROFS_I_ALL) {\n\t\terofs_err(inode->i_sb, \"unsupported i_format %u of nid %llu\",\n\t\t\t  ifmt, vi->nid);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_out;\n\t}\n\n\tvi->datalayout = erofs_inode_datalayout(ifmt);\n\tif (vi->datalayout >= EROFS_INODE_DATALAYOUT_MAX) {\n\t\terofs_err(inode->i_sb, \"unsupported datalayout %u of nid %llu\",\n\t\t\t  vi->datalayout, vi->nid);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_out;\n\t}\n\n\tswitch (erofs_inode_version(ifmt)) {\n\tcase EROFS_INODE_LAYOUT_EXTENDED:\n\t\tvi->inode_isize = sizeof(struct erofs_inode_extended);\n\t\t \n\t\tif (*ofs + vi->inode_isize <= sb->s_blocksize) {\n\t\t\t*ofs += vi->inode_isize;\n\t\t\tdie = (struct erofs_inode_extended *)dic;\n\t\t} else {\n\t\t\tconst unsigned int gotten = sb->s_blocksize - *ofs;\n\n\t\t\tcopied = kmalloc(vi->inode_isize, GFP_NOFS);\n\t\t\tif (!copied) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tmemcpy(copied, dic, gotten);\n\t\t\tkaddr = erofs_read_metabuf(buf, sb, blkaddr + 1,\n\t\t\t\t\t\t   EROFS_KMAP);\n\t\t\tif (IS_ERR(kaddr)) {\n\t\t\t\terofs_err(sb, \"failed to get inode payload block (nid: %llu), err %ld\",\n\t\t\t\t\t  vi->nid, PTR_ERR(kaddr));\n\t\t\t\tkfree(copied);\n\t\t\t\treturn kaddr;\n\t\t\t}\n\t\t\t*ofs = vi->inode_isize - gotten;\n\t\t\tmemcpy((u8 *)copied + gotten, kaddr, *ofs);\n\t\t\tdie = copied;\n\t\t}\n\t\tvi->xattr_isize = erofs_xattr_ibody_size(die->i_xattr_icount);\n\n\t\tinode->i_mode = le16_to_cpu(die->i_mode);\n\t\tswitch (inode->i_mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\tcase S_IFDIR:\n\t\tcase S_IFLNK:\n\t\t\tvi->raw_blkaddr = le32_to_cpu(die->i_u.raw_blkaddr);\n\t\t\tbreak;\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\t\tinode->i_rdev =\n\t\t\t\tnew_decode_dev(le32_to_cpu(die->i_u.rdev));\n\t\t\tbreak;\n\t\tcase S_IFIFO:\n\t\tcase S_IFSOCK:\n\t\t\tinode->i_rdev = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto bogusimode;\n\t\t}\n\t\ti_uid_write(inode, le32_to_cpu(die->i_uid));\n\t\ti_gid_write(inode, le32_to_cpu(die->i_gid));\n\t\tset_nlink(inode, le32_to_cpu(die->i_nlink));\n\n\t\t \n\t\tinode_set_ctime(inode, le64_to_cpu(die->i_mtime),\n\t\t\t\tle32_to_cpu(die->i_mtime_nsec));\n\n\t\tinode->i_size = le64_to_cpu(die->i_size);\n\n\t\t \n\t\tif (erofs_inode_is_data_compressed(vi->datalayout))\n\t\t\tnblks = le32_to_cpu(die->i_u.compressed_blocks);\n\t\telse if (vi->datalayout == EROFS_INODE_CHUNK_BASED)\n\t\t\t \n\t\t\tvi->chunkformat = le16_to_cpu(die->i_u.c.format);\n\t\tkfree(copied);\n\t\tcopied = NULL;\n\t\tbreak;\n\tcase EROFS_INODE_LAYOUT_COMPACT:\n\t\tvi->inode_isize = sizeof(struct erofs_inode_compact);\n\t\t*ofs += vi->inode_isize;\n\t\tvi->xattr_isize = erofs_xattr_ibody_size(dic->i_xattr_icount);\n\n\t\tinode->i_mode = le16_to_cpu(dic->i_mode);\n\t\tswitch (inode->i_mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\tcase S_IFDIR:\n\t\tcase S_IFLNK:\n\t\t\tvi->raw_blkaddr = le32_to_cpu(dic->i_u.raw_blkaddr);\n\t\t\tbreak;\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\t\tinode->i_rdev =\n\t\t\t\tnew_decode_dev(le32_to_cpu(dic->i_u.rdev));\n\t\t\tbreak;\n\t\tcase S_IFIFO:\n\t\tcase S_IFSOCK:\n\t\t\tinode->i_rdev = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto bogusimode;\n\t\t}\n\t\ti_uid_write(inode, le16_to_cpu(dic->i_uid));\n\t\ti_gid_write(inode, le16_to_cpu(dic->i_gid));\n\t\tset_nlink(inode, le16_to_cpu(dic->i_nlink));\n\n\t\t \n\t\tinode_set_ctime(inode, sbi->build_time, sbi->build_time_nsec);\n\n\t\tinode->i_size = le32_to_cpu(dic->i_size);\n\t\tif (erofs_inode_is_data_compressed(vi->datalayout))\n\t\t\tnblks = le32_to_cpu(dic->i_u.compressed_blocks);\n\t\telse if (vi->datalayout == EROFS_INODE_CHUNK_BASED)\n\t\t\tvi->chunkformat = le16_to_cpu(dic->i_u.c.format);\n\t\tbreak;\n\tdefault:\n\t\terofs_err(inode->i_sb,\n\t\t\t  \"unsupported on-disk inode version %u of nid %llu\",\n\t\t\t  erofs_inode_version(ifmt), vi->nid);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_out;\n\t}\n\n\tif (vi->datalayout == EROFS_INODE_CHUNK_BASED) {\n\t\tif (vi->chunkformat & ~EROFS_CHUNK_FORMAT_ALL) {\n\t\t\terofs_err(inode->i_sb,\n\t\t\t\t  \"unsupported chunk format %x of nid %llu\",\n\t\t\t\t  vi->chunkformat, vi->nid);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_out;\n\t\t}\n\t\tvi->chunkbits = sb->s_blocksize_bits +\n\t\t\t(vi->chunkformat & EROFS_CHUNK_FORMAT_BLKBITS_MASK);\n\t}\n\tinode->i_mtime = inode->i_atime = inode_get_ctime(inode);\n\n\tinode->i_flags &= ~S_DAX;\n\tif (test_opt(&sbi->opt, DAX_ALWAYS) && S_ISREG(inode->i_mode) &&\n\t    (vi->datalayout == EROFS_INODE_FLAT_PLAIN ||\n\t     vi->datalayout == EROFS_INODE_CHUNK_BASED))\n\t\tinode->i_flags |= S_DAX;\n\n\tif (!nblks)\n\t\t \n\t\tinode->i_blocks = round_up(inode->i_size, sb->s_blocksize) >> 9;\n\telse\n\t\tinode->i_blocks = nblks << (sb->s_blocksize_bits - 9);\n\treturn kaddr;\n\nbogusimode:\n\terofs_err(inode->i_sb, \"bogus i_mode (%o) @ nid %llu\",\n\t\t  inode->i_mode, vi->nid);\n\terr = -EFSCORRUPTED;\nerr_out:\n\tDBG_BUGON(1);\n\tkfree(copied);\n\terofs_put_metabuf(buf);\n\treturn ERR_PTR(err);\n}\n\nstatic int erofs_fill_symlink(struct inode *inode, void *kaddr,\n\t\t\t      unsigned int m_pofs)\n{\n\tstruct erofs_inode *vi = EROFS_I(inode);\n\tunsigned int bsz = i_blocksize(inode);\n\tchar *lnk;\n\n\t \n\tif (vi->datalayout != EROFS_INODE_FLAT_INLINE ||\n\t    inode->i_size >= bsz || inode->i_size < 0) {\n\t\tinode->i_op = &erofs_symlink_iops;\n\t\treturn 0;\n\t}\n\n\tlnk = kmalloc(inode->i_size + 1, GFP_KERNEL);\n\tif (!lnk)\n\t\treturn -ENOMEM;\n\n\tm_pofs += vi->xattr_isize;\n\t \n\tif (m_pofs + inode->i_size > bsz) {\n\t\tkfree(lnk);\n\t\terofs_err(inode->i_sb,\n\t\t\t  \"inline data cross block boundary @ nid %llu\",\n\t\t\t  vi->nid);\n\t\tDBG_BUGON(1);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tmemcpy(lnk, kaddr + m_pofs, inode->i_size);\n\tlnk[inode->i_size] = '\\0';\n\n\tinode->i_link = lnk;\n\tinode->i_op = &erofs_fast_symlink_iops;\n\treturn 0;\n}\n\nstatic int erofs_fill_inode(struct inode *inode)\n{\n\tstruct erofs_inode *vi = EROFS_I(inode);\n\tstruct erofs_buf buf = __EROFS_BUF_INITIALIZER;\n\tvoid *kaddr;\n\tunsigned int ofs;\n\tint err = 0;\n\n\ttrace_erofs_fill_inode(inode);\n\n\t \n\tkaddr = erofs_read_inode(&buf, inode, &ofs);\n\tif (IS_ERR(kaddr))\n\t\treturn PTR_ERR(kaddr);\n\n\t \n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_op = &erofs_generic_iops;\n\t\tif (erofs_inode_is_data_compressed(vi->datalayout))\n\t\t\tinode->i_fop = &generic_ro_fops;\n\t\telse\n\t\t\tinode->i_fop = &erofs_file_fops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &erofs_dir_iops;\n\t\tinode->i_fop = &erofs_dir_fops;\n\t\tinode_nohighmem(inode);\n\t\tbreak;\n\tcase S_IFLNK:\n\t\terr = erofs_fill_symlink(inode, kaddr, ofs);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t\tinode_nohighmem(inode);\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tinode->i_op = &erofs_generic_iops;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tgoto out_unlock;\n\tdefault:\n\t\terr = -EFSCORRUPTED;\n\t\tgoto out_unlock;\n\t}\n\n\tif (erofs_inode_is_data_compressed(vi->datalayout)) {\n#ifdef CONFIG_EROFS_FS_ZIP\n\t\tif (!erofs_is_fscache_mode(inode->i_sb) &&\n\t\t    inode->i_sb->s_blocksize_bits == PAGE_SHIFT) {\n\t\t\tinode->i_mapping->a_ops = &z_erofs_aops;\n\t\t\terr = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n#endif\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_unlock;\n\t}\n\tinode->i_mapping->a_ops = &erofs_raw_access_aops;\n\tmapping_set_large_folios(inode->i_mapping);\n#ifdef CONFIG_EROFS_FS_ONDEMAND\n\tif (erofs_is_fscache_mode(inode->i_sb))\n\t\tinode->i_mapping->a_ops = &erofs_fscache_access_aops;\n#endif\n\nout_unlock:\n\terofs_put_metabuf(&buf);\n\treturn err;\n}\n\n \nstatic ino_t erofs_squash_ino(erofs_nid_t nid)\n{\n\tino_t ino = (ino_t)nid;\n\n\tif (sizeof(ino_t) < sizeof(erofs_nid_t))\n\t\tino ^= nid >> (sizeof(erofs_nid_t) - sizeof(ino_t)) * 8;\n\treturn ino;\n}\n\nstatic int erofs_iget5_eq(struct inode *inode, void *opaque)\n{\n\treturn EROFS_I(inode)->nid == *(erofs_nid_t *)opaque;\n}\n\nstatic int erofs_iget5_set(struct inode *inode, void *opaque)\n{\n\tconst erofs_nid_t nid = *(erofs_nid_t *)opaque;\n\n\tinode->i_ino = erofs_squash_ino(nid);\n\tEROFS_I(inode)->nid = nid;\n\treturn 0;\n}\n\nstruct inode *erofs_iget(struct super_block *sb, erofs_nid_t nid)\n{\n\tstruct inode *inode;\n\n\tinode = iget5_locked(sb, erofs_squash_ino(nid), erofs_iget5_eq,\n\t\t\t     erofs_iget5_set, &nid);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tint err = erofs_fill_inode(inode);\n\n\t\tif (err) {\n\t\t\tiget_failed(inode);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\tunlock_new_inode(inode);\n\t}\n\treturn inode;\n}\n\nint erofs_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t  struct kstat *stat, u32 request_mask,\n\t\t  unsigned int query_flags)\n{\n\tstruct inode *const inode = d_inode(path->dentry);\n\n\tif (erofs_inode_is_data_compressed(EROFS_I(inode)->datalayout))\n\t\tstat->attributes |= STATX_ATTR_COMPRESSED;\n\n\tstat->attributes |= STATX_ATTR_IMMUTABLE;\n\tstat->attributes_mask |= (STATX_ATTR_COMPRESSED |\n\t\t\t\t  STATX_ATTR_IMMUTABLE);\n\n\tgeneric_fillattr(idmap, request_mask, inode, stat);\n\treturn 0;\n}\n\nconst struct inode_operations erofs_generic_iops = {\n\t.getattr = erofs_getattr,\n\t.listxattr = erofs_listxattr,\n\t.get_inode_acl = erofs_get_acl,\n\t.fiemap = erofs_fiemap,\n};\n\nconst struct inode_operations erofs_symlink_iops = {\n\t.get_link = page_get_link,\n\t.getattr = erofs_getattr,\n\t.listxattr = erofs_listxattr,\n\t.get_inode_acl = erofs_get_acl,\n};\n\nconst struct inode_operations erofs_fast_symlink_iops = {\n\t.get_link = simple_get_link,\n\t.getattr = erofs_getattr,\n\t.listxattr = erofs_listxattr,\n\t.get_inode_acl = erofs_get_acl,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}