{
  "module_name": "zmap.c",
  "hash_id": "b1da8d80c71ea1bf6c6f578aa2ed68d3605d69da5a0da8157faea8d658fb23ae",
  "original_prompt": "Ingested from linux-6.6.14/fs/erofs/zmap.c",
  "human_readable_source": "\n \n#include \"internal.h\"\n#include <asm/unaligned.h>\n#include <trace/events/erofs.h>\n\nstruct z_erofs_maprecorder {\n\tstruct inode *inode;\n\tstruct erofs_map_blocks *map;\n\tvoid *kaddr;\n\n\tunsigned long lcn;\n\t \n\tu8  type, headtype;\n\tu16 clusterofs;\n\tu16 delta[2];\n\terofs_blk_t pblk, compressedblks;\n\terofs_off_t nextpackoff;\n\tbool partialref;\n};\n\nstatic int z_erofs_load_full_lcluster(struct z_erofs_maprecorder *m,\n\t\t\t\t      unsigned long lcn)\n{\n\tstruct inode *const inode = m->inode;\n\tstruct erofs_inode *const vi = EROFS_I(inode);\n\tconst erofs_off_t pos = Z_EROFS_FULL_INDEX_ALIGN(erofs_iloc(inode) +\n\t\t\tvi->inode_isize + vi->xattr_isize) +\n\t\t\tlcn * sizeof(struct z_erofs_lcluster_index);\n\tstruct z_erofs_lcluster_index *di;\n\tunsigned int advise, type;\n\n\tm->kaddr = erofs_read_metabuf(&m->map->buf, inode->i_sb,\n\t\t\t\t      erofs_blknr(inode->i_sb, pos), EROFS_KMAP);\n\tif (IS_ERR(m->kaddr))\n\t\treturn PTR_ERR(m->kaddr);\n\n\tm->nextpackoff = pos + sizeof(struct z_erofs_lcluster_index);\n\tm->lcn = lcn;\n\tdi = m->kaddr + erofs_blkoff(inode->i_sb, pos);\n\n\tadvise = le16_to_cpu(di->di_advise);\n\ttype = (advise >> Z_EROFS_LI_LCLUSTER_TYPE_BIT) &\n\t\t((1 << Z_EROFS_LI_LCLUSTER_TYPE_BITS) - 1);\n\tswitch (type) {\n\tcase Z_EROFS_LCLUSTER_TYPE_NONHEAD:\n\t\tm->clusterofs = 1 << vi->z_logical_clusterbits;\n\t\tm->delta[0] = le16_to_cpu(di->di_u.delta[0]);\n\t\tif (m->delta[0] & Z_EROFS_LI_D0_CBLKCNT) {\n\t\t\tif (!(vi->z_advise & (Z_EROFS_ADVISE_BIG_PCLUSTER_1 |\n\t\t\t\t\tZ_EROFS_ADVISE_BIG_PCLUSTER_2))) {\n\t\t\t\tDBG_BUGON(1);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\t\t\tm->compressedblks = m->delta[0] &\n\t\t\t\t~Z_EROFS_LI_D0_CBLKCNT;\n\t\t\tm->delta[0] = 1;\n\t\t}\n\t\tm->delta[1] = le16_to_cpu(di->di_u.delta[1]);\n\t\tbreak;\n\tcase Z_EROFS_LCLUSTER_TYPE_PLAIN:\n\tcase Z_EROFS_LCLUSTER_TYPE_HEAD1:\n\tcase Z_EROFS_LCLUSTER_TYPE_HEAD2:\n\t\tif (advise & Z_EROFS_LI_PARTIAL_REF)\n\t\t\tm->partialref = true;\n\t\tm->clusterofs = le16_to_cpu(di->di_clusterofs);\n\t\tif (m->clusterofs >= 1 << vi->z_logical_clusterbits) {\n\t\t\tDBG_BUGON(1);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tm->pblk = le32_to_cpu(di->di_u.blkaddr);\n\t\tbreak;\n\tdefault:\n\t\tDBG_BUGON(1);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tm->type = type;\n\treturn 0;\n}\n\nstatic unsigned int decode_compactedbits(unsigned int lobits,\n\t\t\t\t\t unsigned int lomask,\n\t\t\t\t\t u8 *in, unsigned int pos, u8 *type)\n{\n\tconst unsigned int v = get_unaligned_le32(in + pos / 8) >> (pos & 7);\n\tconst unsigned int lo = v & lomask;\n\n\t*type = (v >> lobits) & 3;\n\treturn lo;\n}\n\nstatic int get_compacted_la_distance(unsigned int lclusterbits,\n\t\t\t\t     unsigned int encodebits,\n\t\t\t\t     unsigned int vcnt, u8 *in, int i)\n{\n\tconst unsigned int lomask = (1 << lclusterbits) - 1;\n\tunsigned int lo, d1 = 0;\n\tu8 type;\n\n\tDBG_BUGON(i >= vcnt);\n\n\tdo {\n\t\tlo = decode_compactedbits(lclusterbits, lomask,\n\t\t\t\t\t  in, encodebits * i, &type);\n\n\t\tif (type != Z_EROFS_LCLUSTER_TYPE_NONHEAD)\n\t\t\treturn d1;\n\t\t++d1;\n\t} while (++i < vcnt);\n\n\t \n\tif (!(lo & Z_EROFS_LI_D0_CBLKCNT))\n\t\td1 += lo - 1;\n\treturn d1;\n}\n\nstatic int unpack_compacted_index(struct z_erofs_maprecorder *m,\n\t\t\t\t  unsigned int amortizedshift,\n\t\t\t\t  erofs_off_t pos, bool lookahead)\n{\n\tstruct erofs_inode *const vi = EROFS_I(m->inode);\n\tconst unsigned int lclusterbits = vi->z_logical_clusterbits;\n\tconst unsigned int lomask = (1 << lclusterbits) - 1;\n\tunsigned int vcnt, base, lo, encodebits, nblk, eofs;\n\tint i;\n\tu8 *in, type;\n\tbool big_pcluster;\n\n\tif (1 << amortizedshift == 4 && lclusterbits <= 14)\n\t\tvcnt = 2;\n\telse if (1 << amortizedshift == 2 && lclusterbits == 12)\n\t\tvcnt = 16;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tm->nextpackoff = round_down(pos, vcnt << amortizedshift) +\n\t\t\t (vcnt << amortizedshift);\n\tbig_pcluster = vi->z_advise & Z_EROFS_ADVISE_BIG_PCLUSTER_1;\n\tencodebits = ((vcnt << amortizedshift) - sizeof(__le32)) * 8 / vcnt;\n\teofs = erofs_blkoff(m->inode->i_sb, pos);\n\tbase = round_down(eofs, vcnt << amortizedshift);\n\tin = m->kaddr + base;\n\n\ti = (eofs - base) >> amortizedshift;\n\n\tlo = decode_compactedbits(lclusterbits, lomask,\n\t\t\t\t  in, encodebits * i, &type);\n\tm->type = type;\n\tif (type == Z_EROFS_LCLUSTER_TYPE_NONHEAD) {\n\t\tm->clusterofs = 1 << lclusterbits;\n\n\t\t \n\t\tif (lookahead)\n\t\t\tm->delta[1] = get_compacted_la_distance(lclusterbits,\n\t\t\t\t\t\tencodebits, vcnt, in, i);\n\t\tif (lo & Z_EROFS_LI_D0_CBLKCNT) {\n\t\t\tif (!big_pcluster) {\n\t\t\t\tDBG_BUGON(1);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\t\t\tm->compressedblks = lo & ~Z_EROFS_LI_D0_CBLKCNT;\n\t\t\tm->delta[0] = 1;\n\t\t\treturn 0;\n\t\t} else if (i + 1 != (int)vcnt) {\n\t\t\tm->delta[0] = lo;\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tlo = decode_compactedbits(lclusterbits, lomask,\n\t\t\t\t\t  in, encodebits * (i - 1), &type);\n\t\tif (type != Z_EROFS_LCLUSTER_TYPE_NONHEAD)\n\t\t\tlo = 0;\n\t\telse if (lo & Z_EROFS_LI_D0_CBLKCNT)\n\t\t\tlo = 1;\n\t\tm->delta[0] = lo + 1;\n\t\treturn 0;\n\t}\n\tm->clusterofs = lo;\n\tm->delta[0] = 0;\n\t \n\tif (!big_pcluster) {\n\t\tnblk = 1;\n\t\twhile (i > 0) {\n\t\t\t--i;\n\t\t\tlo = decode_compactedbits(lclusterbits, lomask,\n\t\t\t\t\t\t  in, encodebits * i, &type);\n\t\t\tif (type == Z_EROFS_LCLUSTER_TYPE_NONHEAD)\n\t\t\t\ti -= lo;\n\n\t\t\tif (i >= 0)\n\t\t\t\t++nblk;\n\t\t}\n\t} else {\n\t\tnblk = 0;\n\t\twhile (i > 0) {\n\t\t\t--i;\n\t\t\tlo = decode_compactedbits(lclusterbits, lomask,\n\t\t\t\t\t\t  in, encodebits * i, &type);\n\t\t\tif (type == Z_EROFS_LCLUSTER_TYPE_NONHEAD) {\n\t\t\t\tif (lo & Z_EROFS_LI_D0_CBLKCNT) {\n\t\t\t\t\t--i;\n\t\t\t\t\tnblk += lo & ~Z_EROFS_LI_D0_CBLKCNT;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (lo <= 1) {\n\t\t\t\t\tDBG_BUGON(1);\n\t\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t\t}\n\t\t\t\ti -= lo - 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t++nblk;\n\t\t}\n\t}\n\tin += (vcnt << amortizedshift) - sizeof(__le32);\n\tm->pblk = le32_to_cpu(*(__le32 *)in) + nblk;\n\treturn 0;\n}\n\nstatic int z_erofs_load_compact_lcluster(struct z_erofs_maprecorder *m,\n\t\t\t\t\t unsigned long lcn, bool lookahead)\n{\n\tstruct inode *const inode = m->inode;\n\tstruct erofs_inode *const vi = EROFS_I(inode);\n\tconst erofs_off_t ebase = sizeof(struct z_erofs_map_header) +\n\t\tALIGN(erofs_iloc(inode) + vi->inode_isize + vi->xattr_isize, 8);\n\tunsigned int totalidx = erofs_iblks(inode);\n\tunsigned int compacted_4b_initial, compacted_2b;\n\tunsigned int amortizedshift;\n\terofs_off_t pos;\n\n\tif (lcn >= totalidx)\n\t\treturn -EINVAL;\n\n\tm->lcn = lcn;\n\t \n\tcompacted_4b_initial = (32 - ebase % 32) / 4;\n\tif (compacted_4b_initial == 32 / 4)\n\t\tcompacted_4b_initial = 0;\n\n\tif ((vi->z_advise & Z_EROFS_ADVISE_COMPACTED_2B) &&\n\t    compacted_4b_initial < totalidx)\n\t\tcompacted_2b = rounddown(totalidx - compacted_4b_initial, 16);\n\telse\n\t\tcompacted_2b = 0;\n\n\tpos = ebase;\n\tif (lcn < compacted_4b_initial) {\n\t\tamortizedshift = 2;\n\t\tgoto out;\n\t}\n\tpos += compacted_4b_initial * 4;\n\tlcn -= compacted_4b_initial;\n\n\tif (lcn < compacted_2b) {\n\t\tamortizedshift = 1;\n\t\tgoto out;\n\t}\n\tpos += compacted_2b * 2;\n\tlcn -= compacted_2b;\n\tamortizedshift = 2;\nout:\n\tpos += lcn * (1 << amortizedshift);\n\tm->kaddr = erofs_read_metabuf(&m->map->buf, inode->i_sb,\n\t\t\t\t      erofs_blknr(inode->i_sb, pos), EROFS_KMAP);\n\tif (IS_ERR(m->kaddr))\n\t\treturn PTR_ERR(m->kaddr);\n\treturn unpack_compacted_index(m, amortizedshift, pos, lookahead);\n}\n\nstatic int z_erofs_load_lcluster_from_disk(struct z_erofs_maprecorder *m,\n\t\t\t\t\t   unsigned int lcn, bool lookahead)\n{\n\tswitch (EROFS_I(m->inode)->datalayout) {\n\tcase EROFS_INODE_COMPRESSED_FULL:\n\t\treturn z_erofs_load_full_lcluster(m, lcn);\n\tcase EROFS_INODE_COMPRESSED_COMPACT:\n\t\treturn z_erofs_load_compact_lcluster(m, lcn, lookahead);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int z_erofs_extent_lookback(struct z_erofs_maprecorder *m,\n\t\t\t\t   unsigned int lookback_distance)\n{\n\tstruct super_block *sb = m->inode->i_sb;\n\tstruct erofs_inode *const vi = EROFS_I(m->inode);\n\tconst unsigned int lclusterbits = vi->z_logical_clusterbits;\n\n\twhile (m->lcn >= lookback_distance) {\n\t\tunsigned long lcn = m->lcn - lookback_distance;\n\t\tint err;\n\n\t\terr = z_erofs_load_lcluster_from_disk(m, lcn, false);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tswitch (m->type) {\n\t\tcase Z_EROFS_LCLUSTER_TYPE_NONHEAD:\n\t\t\tlookback_distance = m->delta[0];\n\t\t\tif (!lookback_distance)\n\t\t\t\tgoto err_bogus;\n\t\t\tcontinue;\n\t\tcase Z_EROFS_LCLUSTER_TYPE_PLAIN:\n\t\tcase Z_EROFS_LCLUSTER_TYPE_HEAD1:\n\t\tcase Z_EROFS_LCLUSTER_TYPE_HEAD2:\n\t\t\tm->headtype = m->type;\n\t\t\tm->map->m_la = (lcn << lclusterbits) | m->clusterofs;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\terofs_err(sb, \"unknown type %u @ lcn %lu of nid %llu\",\n\t\t\t\t  m->type, lcn, vi->nid);\n\t\t\tDBG_BUGON(1);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\nerr_bogus:\n\terofs_err(sb, \"bogus lookback distance %u @ lcn %lu of nid %llu\",\n\t\t  lookback_distance, m->lcn, vi->nid);\n\tDBG_BUGON(1);\n\treturn -EFSCORRUPTED;\n}\n\nstatic int z_erofs_get_extent_compressedlen(struct z_erofs_maprecorder *m,\n\t\t\t\t\t    unsigned int initial_lcn)\n{\n\tstruct super_block *sb = m->inode->i_sb;\n\tstruct erofs_inode *const vi = EROFS_I(m->inode);\n\tstruct erofs_map_blocks *const map = m->map;\n\tconst unsigned int lclusterbits = vi->z_logical_clusterbits;\n\tunsigned long lcn;\n\tint err;\n\n\tDBG_BUGON(m->type != Z_EROFS_LCLUSTER_TYPE_PLAIN &&\n\t\t  m->type != Z_EROFS_LCLUSTER_TYPE_HEAD1 &&\n\t\t  m->type != Z_EROFS_LCLUSTER_TYPE_HEAD2);\n\tDBG_BUGON(m->type != m->headtype);\n\n\tif (m->headtype == Z_EROFS_LCLUSTER_TYPE_PLAIN ||\n\t    ((m->headtype == Z_EROFS_LCLUSTER_TYPE_HEAD1) &&\n\t     !(vi->z_advise & Z_EROFS_ADVISE_BIG_PCLUSTER_1)) ||\n\t    ((m->headtype == Z_EROFS_LCLUSTER_TYPE_HEAD2) &&\n\t     !(vi->z_advise & Z_EROFS_ADVISE_BIG_PCLUSTER_2))) {\n\t\tmap->m_plen = 1ULL << lclusterbits;\n\t\treturn 0;\n\t}\n\tlcn = m->lcn + 1;\n\tif (m->compressedblks)\n\t\tgoto out;\n\n\terr = z_erofs_load_lcluster_from_disk(m, lcn, false);\n\tif (err)\n\t\treturn err;\n\n\t \n\tDBG_BUGON(lcn == initial_lcn &&\n\t\t  m->type == Z_EROFS_LCLUSTER_TYPE_NONHEAD);\n\n\tswitch (m->type) {\n\tcase Z_EROFS_LCLUSTER_TYPE_PLAIN:\n\tcase Z_EROFS_LCLUSTER_TYPE_HEAD1:\n\tcase Z_EROFS_LCLUSTER_TYPE_HEAD2:\n\t\t \n\t\tm->compressedblks = 1 << (lclusterbits - sb->s_blocksize_bits);\n\t\tbreak;\n\tcase Z_EROFS_LCLUSTER_TYPE_NONHEAD:\n\t\tif (m->delta[0] != 1)\n\t\t\tgoto err_bonus_cblkcnt;\n\t\tif (m->compressedblks)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\terofs_err(sb, \"cannot found CBLKCNT @ lcn %lu of nid %llu\", lcn,\n\t\t\t  vi->nid);\n\t\tDBG_BUGON(1);\n\t\treturn -EFSCORRUPTED;\n\t}\nout:\n\tmap->m_plen = erofs_pos(sb, m->compressedblks);\n\treturn 0;\nerr_bonus_cblkcnt:\n\terofs_err(sb, \"bogus CBLKCNT @ lcn %lu of nid %llu\", lcn, vi->nid);\n\tDBG_BUGON(1);\n\treturn -EFSCORRUPTED;\n}\n\nstatic int z_erofs_get_extent_decompressedlen(struct z_erofs_maprecorder *m)\n{\n\tstruct inode *inode = m->inode;\n\tstruct erofs_inode *vi = EROFS_I(inode);\n\tstruct erofs_map_blocks *map = m->map;\n\tunsigned int lclusterbits = vi->z_logical_clusterbits;\n\tu64 lcn = m->lcn, headlcn = map->m_la >> lclusterbits;\n\tint err;\n\n\tdo {\n\t\t \n\t\tif ((lcn << lclusterbits) >= inode->i_size) {\n\t\t\tmap->m_llen = inode->i_size - map->m_la;\n\t\t\treturn 0;\n\t\t}\n\n\t\terr = z_erofs_load_lcluster_from_disk(m, lcn, true);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (m->type == Z_EROFS_LCLUSTER_TYPE_NONHEAD) {\n\t\t\tDBG_BUGON(!m->delta[1] &&\n\t\t\t\t  m->clusterofs != 1 << lclusterbits);\n\t\t} else if (m->type == Z_EROFS_LCLUSTER_TYPE_PLAIN ||\n\t\t\t   m->type == Z_EROFS_LCLUSTER_TYPE_HEAD1 ||\n\t\t\t   m->type == Z_EROFS_LCLUSTER_TYPE_HEAD2) {\n\t\t\t \n\t\t\tif (lcn != headlcn)\n\t\t\t\tbreak;\n\t\t\tm->delta[1] = 1;\n\t\t} else {\n\t\t\terofs_err(inode->i_sb, \"unknown type %u @ lcn %llu of nid %llu\",\n\t\t\t\t  m->type, lcn, vi->nid);\n\t\t\tDBG_BUGON(1);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tlcn += m->delta[1];\n\t} while (m->delta[1]);\n\n\tmap->m_llen = (lcn << lclusterbits) + m->clusterofs - map->m_la;\n\treturn 0;\n}\n\nstatic int z_erofs_do_map_blocks(struct inode *inode,\n\t\t\t\t struct erofs_map_blocks *map, int flags)\n{\n\tstruct erofs_inode *const vi = EROFS_I(inode);\n\tbool ztailpacking = vi->z_advise & Z_EROFS_ADVISE_INLINE_PCLUSTER;\n\tbool fragment = vi->z_advise & Z_EROFS_ADVISE_FRAGMENT_PCLUSTER;\n\tstruct z_erofs_maprecorder m = {\n\t\t.inode = inode,\n\t\t.map = map,\n\t};\n\tint err = 0;\n\tunsigned int lclusterbits, endoff, afmt;\n\tunsigned long initial_lcn;\n\tunsigned long long ofs, end;\n\n\tlclusterbits = vi->z_logical_clusterbits;\n\tofs = flags & EROFS_GET_BLOCKS_FINDTAIL ? inode->i_size - 1 : map->m_la;\n\tinitial_lcn = ofs >> lclusterbits;\n\tendoff = ofs & ((1 << lclusterbits) - 1);\n\n\terr = z_erofs_load_lcluster_from_disk(&m, initial_lcn, false);\n\tif (err)\n\t\tgoto unmap_out;\n\n\tif (ztailpacking && (flags & EROFS_GET_BLOCKS_FINDTAIL))\n\t\tvi->z_idataoff = m.nextpackoff;\n\n\tmap->m_flags = EROFS_MAP_MAPPED | EROFS_MAP_ENCODED;\n\tend = (m.lcn + 1ULL) << lclusterbits;\n\n\tswitch (m.type) {\n\tcase Z_EROFS_LCLUSTER_TYPE_PLAIN:\n\tcase Z_EROFS_LCLUSTER_TYPE_HEAD1:\n\tcase Z_EROFS_LCLUSTER_TYPE_HEAD2:\n\t\tif (endoff >= m.clusterofs) {\n\t\t\tm.headtype = m.type;\n\t\t\tmap->m_la = (m.lcn << lclusterbits) | m.clusterofs;\n\t\t\t \n\t\t\tif (ztailpacking && end > inode->i_size)\n\t\t\t\tend = inode->i_size;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (!m.lcn) {\n\t\t\terofs_err(inode->i_sb,\n\t\t\t\t  \"invalid logical cluster 0 at nid %llu\",\n\t\t\t\t  vi->nid);\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto unmap_out;\n\t\t}\n\t\tend = (m.lcn << lclusterbits) | m.clusterofs;\n\t\tmap->m_flags |= EROFS_MAP_FULL_MAPPED;\n\t\tm.delta[0] = 1;\n\t\tfallthrough;\n\tcase Z_EROFS_LCLUSTER_TYPE_NONHEAD:\n\t\t \n\t\terr = z_erofs_extent_lookback(&m, m.delta[0]);\n\t\tif (err)\n\t\t\tgoto unmap_out;\n\t\tbreak;\n\tdefault:\n\t\terofs_err(inode->i_sb,\n\t\t\t  \"unknown type %u @ offset %llu of nid %llu\",\n\t\t\t  m.type, ofs, vi->nid);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unmap_out;\n\t}\n\tif (m.partialref)\n\t\tmap->m_flags |= EROFS_MAP_PARTIAL_REF;\n\tmap->m_llen = end - map->m_la;\n\n\tif (flags & EROFS_GET_BLOCKS_FINDTAIL) {\n\t\tvi->z_tailextent_headlcn = m.lcn;\n\t\t \n\t\tif (fragment && vi->datalayout == EROFS_INODE_COMPRESSED_FULL)\n\t\t\tvi->z_fragmentoff |= (u64)m.pblk << 32;\n\t}\n\tif (ztailpacking && m.lcn == vi->z_tailextent_headlcn) {\n\t\tmap->m_flags |= EROFS_MAP_META;\n\t\tmap->m_pa = vi->z_idataoff;\n\t\tmap->m_plen = vi->z_idata_size;\n\t} else if (fragment && m.lcn == vi->z_tailextent_headlcn) {\n\t\tmap->m_flags |= EROFS_MAP_FRAGMENT;\n\t} else {\n\t\tmap->m_pa = erofs_pos(inode->i_sb, m.pblk);\n\t\terr = z_erofs_get_extent_compressedlen(&m, initial_lcn);\n\t\tif (err)\n\t\t\tgoto unmap_out;\n\t}\n\n\tif (m.headtype == Z_EROFS_LCLUSTER_TYPE_PLAIN) {\n\t\tif (map->m_llen > map->m_plen) {\n\t\t\tDBG_BUGON(1);\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto unmap_out;\n\t\t}\n\t\tafmt = vi->z_advise & Z_EROFS_ADVISE_INTERLACED_PCLUSTER ?\n\t\t\tZ_EROFS_COMPRESSION_INTERLACED :\n\t\t\tZ_EROFS_COMPRESSION_SHIFTED;\n\t} else {\n\t\tafmt = m.headtype == Z_EROFS_LCLUSTER_TYPE_HEAD2 ?\n\t\t\tvi->z_algorithmtype[1] : vi->z_algorithmtype[0];\n\t\tif (!(EROFS_I_SB(inode)->available_compr_algs & (1 << afmt))) {\n\t\t\terofs_err(inode->i_sb, \"inconsistent algorithmtype %u for nid %llu\",\n\t\t\t\t  afmt, vi->nid);\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto unmap_out;\n\t\t}\n\t}\n\tmap->m_algorithmformat = afmt;\n\n\tif ((flags & EROFS_GET_BLOCKS_FIEMAP) ||\n\t    ((flags & EROFS_GET_BLOCKS_READMORE) &&\n\t     (map->m_algorithmformat == Z_EROFS_COMPRESSION_LZMA ||\n\t      map->m_algorithmformat == Z_EROFS_COMPRESSION_DEFLATE) &&\n\t      map->m_llen >= i_blocksize(inode))) {\n\t\terr = z_erofs_get_extent_decompressedlen(&m);\n\t\tif (!err)\n\t\t\tmap->m_flags |= EROFS_MAP_FULL_MAPPED;\n\t}\n\nunmap_out:\n\terofs_unmap_metabuf(&m.map->buf);\n\treturn err;\n}\n\nstatic int z_erofs_fill_inode_lazy(struct inode *inode)\n{\n\tstruct erofs_inode *const vi = EROFS_I(inode);\n\tstruct super_block *const sb = inode->i_sb;\n\tint err, headnr;\n\terofs_off_t pos;\n\tstruct erofs_buf buf = __EROFS_BUF_INITIALIZER;\n\tvoid *kaddr;\n\tstruct z_erofs_map_header *h;\n\n\tif (test_bit(EROFS_I_Z_INITED_BIT, &vi->flags)) {\n\t\t \n\t\tsmp_mb();\n\t\treturn 0;\n\t}\n\n\tif (wait_on_bit_lock(&vi->flags, EROFS_I_BL_Z_BIT, TASK_KILLABLE))\n\t\treturn -ERESTARTSYS;\n\n\terr = 0;\n\tif (test_bit(EROFS_I_Z_INITED_BIT, &vi->flags))\n\t\tgoto out_unlock;\n\n\tpos = ALIGN(erofs_iloc(inode) + vi->inode_isize + vi->xattr_isize, 8);\n\tkaddr = erofs_read_metabuf(&buf, sb, erofs_blknr(sb, pos), EROFS_KMAP);\n\tif (IS_ERR(kaddr)) {\n\t\terr = PTR_ERR(kaddr);\n\t\tgoto out_unlock;\n\t}\n\n\th = kaddr + erofs_blkoff(sb, pos);\n\t \n\tif (h->h_clusterbits >> Z_EROFS_FRAGMENT_INODE_BIT) {\n\t\tvi->z_advise = Z_EROFS_ADVISE_FRAGMENT_PCLUSTER;\n\t\tvi->z_fragmentoff = le64_to_cpu(*(__le64 *)h) ^ (1ULL << 63);\n\t\tvi->z_tailextent_headlcn = 0;\n\t\tgoto done;\n\t}\n\tvi->z_advise = le16_to_cpu(h->h_advise);\n\tvi->z_algorithmtype[0] = h->h_algorithmtype & 15;\n\tvi->z_algorithmtype[1] = h->h_algorithmtype >> 4;\n\n\theadnr = 0;\n\tif (vi->z_algorithmtype[0] >= Z_EROFS_COMPRESSION_MAX ||\n\t    vi->z_algorithmtype[++headnr] >= Z_EROFS_COMPRESSION_MAX) {\n\t\terofs_err(sb, \"unknown HEAD%u format %u for nid %llu, please upgrade kernel\",\n\t\t\t  headnr + 1, vi->z_algorithmtype[headnr], vi->nid);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_put_metabuf;\n\t}\n\n\tvi->z_logical_clusterbits = sb->s_blocksize_bits + (h->h_clusterbits & 7);\n\tif (!erofs_sb_has_big_pcluster(EROFS_SB(sb)) &&\n\t    vi->z_advise & (Z_EROFS_ADVISE_BIG_PCLUSTER_1 |\n\t\t\t    Z_EROFS_ADVISE_BIG_PCLUSTER_2)) {\n\t\terofs_err(sb, \"per-inode big pcluster without sb feature for nid %llu\",\n\t\t\t  vi->nid);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto out_put_metabuf;\n\t}\n\tif (vi->datalayout == EROFS_INODE_COMPRESSED_COMPACT &&\n\t    !(vi->z_advise & Z_EROFS_ADVISE_BIG_PCLUSTER_1) ^\n\t    !(vi->z_advise & Z_EROFS_ADVISE_BIG_PCLUSTER_2)) {\n\t\terofs_err(sb, \"big pcluster head1/2 of compact indexes should be consistent for nid %llu\",\n\t\t\t  vi->nid);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto out_put_metabuf;\n\t}\n\n\tif (vi->z_advise & Z_EROFS_ADVISE_INLINE_PCLUSTER) {\n\t\tstruct erofs_map_blocks map = {\n\t\t\t.buf = __EROFS_BUF_INITIALIZER\n\t\t};\n\n\t\tvi->z_idata_size = le16_to_cpu(h->h_idata_size);\n\t\terr = z_erofs_do_map_blocks(inode, &map,\n\t\t\t\t\t    EROFS_GET_BLOCKS_FINDTAIL);\n\t\terofs_put_metabuf(&map.buf);\n\n\t\tif (!map.m_plen ||\n\t\t    erofs_blkoff(sb, map.m_pa) + map.m_plen > sb->s_blocksize) {\n\t\t\terofs_err(sb, \"invalid tail-packing pclustersize %llu\",\n\t\t\t\t  map.m_plen);\n\t\t\terr = -EFSCORRUPTED;\n\t\t}\n\t\tif (err < 0)\n\t\t\tgoto out_put_metabuf;\n\t}\n\n\tif (vi->z_advise & Z_EROFS_ADVISE_FRAGMENT_PCLUSTER &&\n\t    !(h->h_clusterbits >> Z_EROFS_FRAGMENT_INODE_BIT)) {\n\t\tstruct erofs_map_blocks map = {\n\t\t\t.buf = __EROFS_BUF_INITIALIZER\n\t\t};\n\n\t\tvi->z_fragmentoff = le32_to_cpu(h->h_fragmentoff);\n\t\terr = z_erofs_do_map_blocks(inode, &map,\n\t\t\t\t\t    EROFS_GET_BLOCKS_FINDTAIL);\n\t\terofs_put_metabuf(&map.buf);\n\t\tif (err < 0)\n\t\t\tgoto out_put_metabuf;\n\t}\ndone:\n\t \n\tsmp_mb();\n\tset_bit(EROFS_I_Z_INITED_BIT, &vi->flags);\nout_put_metabuf:\n\terofs_put_metabuf(&buf);\nout_unlock:\n\tclear_and_wake_up_bit(EROFS_I_BL_Z_BIT, &vi->flags);\n\treturn err;\n}\n\nint z_erofs_map_blocks_iter(struct inode *inode, struct erofs_map_blocks *map,\n\t\t\t    int flags)\n{\n\tstruct erofs_inode *const vi = EROFS_I(inode);\n\tint err = 0;\n\n\ttrace_z_erofs_map_blocks_iter_enter(inode, map, flags);\n\n\t \n\tif (map->m_la >= inode->i_size) {\n\t\tmap->m_llen = map->m_la + 1 - inode->i_size;\n\t\tmap->m_la = inode->i_size;\n\t\tmap->m_flags = 0;\n\t\tgoto out;\n\t}\n\n\terr = z_erofs_fill_inode_lazy(inode);\n\tif (err)\n\t\tgoto out;\n\n\tif ((vi->z_advise & Z_EROFS_ADVISE_FRAGMENT_PCLUSTER) &&\n\t    !vi->z_tailextent_headlcn) {\n\t\tmap->m_la = 0;\n\t\tmap->m_llen = inode->i_size;\n\t\tmap->m_flags = EROFS_MAP_MAPPED | EROFS_MAP_FULL_MAPPED |\n\t\t\t\tEROFS_MAP_FRAGMENT;\n\t\tgoto out;\n\t}\n\n\terr = z_erofs_do_map_blocks(inode, map, flags);\nout:\n\ttrace_z_erofs_map_blocks_iter_exit(inode, map, flags, err);\n\treturn err;\n}\n\nstatic int z_erofs_iomap_begin_report(struct inode *inode, loff_t offset,\n\t\t\t\tloff_t length, unsigned int flags,\n\t\t\t\tstruct iomap *iomap, struct iomap *srcmap)\n{\n\tint ret;\n\tstruct erofs_map_blocks map = { .m_la = offset };\n\n\tret = z_erofs_map_blocks_iter(inode, &map, EROFS_GET_BLOCKS_FIEMAP);\n\terofs_put_metabuf(&map.buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tiomap->bdev = inode->i_sb->s_bdev;\n\tiomap->offset = map.m_la;\n\tiomap->length = map.m_llen;\n\tif (map.m_flags & EROFS_MAP_MAPPED) {\n\t\tiomap->type = IOMAP_MAPPED;\n\t\tiomap->addr = map.m_flags & EROFS_MAP_FRAGMENT ?\n\t\t\t      IOMAP_NULL_ADDR : map.m_pa;\n\t} else {\n\t\tiomap->type = IOMAP_HOLE;\n\t\tiomap->addr = IOMAP_NULL_ADDR;\n\t\t \n\t\tif (iomap->offset >= inode->i_size)\n\t\t\tiomap->length = length + offset - map.m_la;\n\t}\n\tiomap->flags = 0;\n\treturn 0;\n}\n\nconst struct iomap_ops z_erofs_iomap_report_ops = {\n\t.iomap_begin = z_erofs_iomap_begin_report,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}