{
  "module_name": "decompressor_lzma.c",
  "hash_id": "2b0349b9ad82b49e0e94985a0e9598715e46ba8326af37cd5346b7120d6c9010",
  "original_prompt": "Ingested from linux-6.6.14/fs/erofs/decompressor_lzma.c",
  "human_readable_source": "\n#include <linux/xz.h>\n#include <linux/module.h>\n#include \"compress.h\"\n\nstruct z_erofs_lzma {\n\tstruct z_erofs_lzma *next;\n\tstruct xz_dec_microlzma *state;\n\tstruct xz_buf buf;\n\tu8 bounce[PAGE_SIZE];\n};\n\n \nstatic DEFINE_SPINLOCK(z_erofs_lzma_lock);\nstatic unsigned int z_erofs_lzma_max_dictsize;\nstatic unsigned int z_erofs_lzma_nstrms, z_erofs_lzma_avail_strms;\nstatic struct z_erofs_lzma *z_erofs_lzma_head;\nstatic DECLARE_WAIT_QUEUE_HEAD(z_erofs_lzma_wq);\n\nmodule_param_named(lzma_streams, z_erofs_lzma_nstrms, uint, 0444);\n\nvoid z_erofs_lzma_exit(void)\n{\n\t \n\twhile (z_erofs_lzma_avail_strms) {\n\t\tstruct z_erofs_lzma *strm;\n\n\t\tspin_lock(&z_erofs_lzma_lock);\n\t\tstrm = z_erofs_lzma_head;\n\t\tif (!strm) {\n\t\t\tspin_unlock(&z_erofs_lzma_lock);\n\t\t\tDBG_BUGON(1);\n\t\t\treturn;\n\t\t}\n\t\tz_erofs_lzma_head = NULL;\n\t\tspin_unlock(&z_erofs_lzma_lock);\n\n\t\twhile (strm) {\n\t\t\tstruct z_erofs_lzma *n = strm->next;\n\n\t\t\tif (strm->state)\n\t\t\t\txz_dec_microlzma_end(strm->state);\n\t\t\tkfree(strm);\n\t\t\t--z_erofs_lzma_avail_strms;\n\t\t\tstrm = n;\n\t\t}\n\t}\n}\n\nint __init z_erofs_lzma_init(void)\n{\n\tunsigned int i;\n\n\t \n\tif (!z_erofs_lzma_nstrms)\n\t\tz_erofs_lzma_nstrms = num_possible_cpus();\n\n\tfor (i = 0; i < z_erofs_lzma_nstrms; ++i) {\n\t\tstruct z_erofs_lzma *strm = kzalloc(sizeof(*strm), GFP_KERNEL);\n\n\t\tif (!strm) {\n\t\t\tz_erofs_lzma_exit();\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tspin_lock(&z_erofs_lzma_lock);\n\t\tstrm->next = z_erofs_lzma_head;\n\t\tz_erofs_lzma_head = strm;\n\t\tspin_unlock(&z_erofs_lzma_lock);\n\t\t++z_erofs_lzma_avail_strms;\n\t}\n\treturn 0;\n}\n\nint z_erofs_load_lzma_config(struct super_block *sb,\n\t\t\tstruct erofs_super_block *dsb, void *data, int size)\n{\n\tstatic DEFINE_MUTEX(lzma_resize_mutex);\n\tstruct z_erofs_lzma_cfgs *lzma = data;\n\tunsigned int dict_size, i;\n\tstruct z_erofs_lzma *strm, *head = NULL;\n\tint err;\n\n\tif (!lzma || size < sizeof(struct z_erofs_lzma_cfgs)) {\n\t\terofs_err(sb, \"invalid lzma cfgs, size=%u\", size);\n\t\treturn -EINVAL;\n\t}\n\tif (lzma->format) {\n\t\terofs_err(sb, \"unidentified lzma format %x, please check kernel version\",\n\t\t\t  le16_to_cpu(lzma->format));\n\t\treturn -EINVAL;\n\t}\n\tdict_size = le32_to_cpu(lzma->dict_size);\n\tif (dict_size > Z_EROFS_LZMA_MAX_DICT_SIZE || dict_size < 4096) {\n\t\terofs_err(sb, \"unsupported lzma dictionary size %u\",\n\t\t\t  dict_size);\n\t\treturn -EINVAL;\n\t}\n\n\terofs_info(sb, \"EXPERIMENTAL MicroLZMA in use. Use at your own risk!\");\n\n\t \n\tmutex_lock(&lzma_resize_mutex);\n\n\tif (z_erofs_lzma_max_dictsize >= dict_size) {\n\t\tmutex_unlock(&lzma_resize_mutex);\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < z_erofs_lzma_avail_strms; ++i) {\n\t\tstruct z_erofs_lzma *last;\n\nagain:\n\t\tspin_lock(&z_erofs_lzma_lock);\n\t\tstrm = z_erofs_lzma_head;\n\t\tif (!strm) {\n\t\t\tspin_unlock(&z_erofs_lzma_lock);\n\t\t\twait_event(z_erofs_lzma_wq,\n\t\t\t\t   READ_ONCE(z_erofs_lzma_head));\n\t\t\tgoto again;\n\t\t}\n\t\tz_erofs_lzma_head = NULL;\n\t\tspin_unlock(&z_erofs_lzma_lock);\n\n\t\tfor (last = strm; last->next; last = last->next)\n\t\t\t++i;\n\t\tlast->next = head;\n\t\thead = strm;\n\t}\n\n\terr = 0;\n\t \n\tfor (strm = head; strm; strm = strm->next) {\n\t\tif (strm->state)\n\t\t\txz_dec_microlzma_end(strm->state);\n\t\tstrm->state = xz_dec_microlzma_alloc(XZ_PREALLOC, dict_size);\n\t\tif (!strm->state)\n\t\t\terr = -ENOMEM;\n\t}\n\n\t \n\tspin_lock(&z_erofs_lzma_lock);\n\tDBG_BUGON(z_erofs_lzma_head);\n\tz_erofs_lzma_head = head;\n\tspin_unlock(&z_erofs_lzma_lock);\n\twake_up_all(&z_erofs_lzma_wq);\n\n\tz_erofs_lzma_max_dictsize = dict_size;\n\tmutex_unlock(&lzma_resize_mutex);\n\treturn err;\n}\n\nint z_erofs_lzma_decompress(struct z_erofs_decompress_req *rq,\n\t\t\t    struct page **pagepool)\n{\n\tconst unsigned int nrpages_out =\n\t\tPAGE_ALIGN(rq->pageofs_out + rq->outputsize) >> PAGE_SHIFT;\n\tconst unsigned int nrpages_in =\n\t\tPAGE_ALIGN(rq->inputsize) >> PAGE_SHIFT;\n\tunsigned int inlen, outlen, pageofs;\n\tstruct z_erofs_lzma *strm;\n\tu8 *kin;\n\tbool bounced = false;\n\tint no, ni, j, err = 0;\n\n\t \n\tkin = kmap(*rq->in);\n\terr = z_erofs_fixup_insize(rq, kin + rq->pageofs_in,\n\t\t\tmin_t(unsigned int, rq->inputsize,\n\t\t\t      rq->sb->s_blocksize - rq->pageofs_in));\n\tif (err) {\n\t\tkunmap(*rq->in);\n\t\treturn err;\n\t}\n\n\t \nagain:\n\tspin_lock(&z_erofs_lzma_lock);\n\tstrm = z_erofs_lzma_head;\n\tif (!strm) {\n\t\tspin_unlock(&z_erofs_lzma_lock);\n\t\twait_event(z_erofs_lzma_wq, READ_ONCE(z_erofs_lzma_head));\n\t\tgoto again;\n\t}\n\tz_erofs_lzma_head = strm->next;\n\tspin_unlock(&z_erofs_lzma_lock);\n\n\t \n\tinlen = rq->inputsize;\n\toutlen = rq->outputsize;\n\txz_dec_microlzma_reset(strm->state, inlen, outlen,\n\t\t\t       !rq->partial_decoding);\n\tpageofs = rq->pageofs_out;\n\tstrm->buf.in = kin + rq->pageofs_in;\n\tstrm->buf.in_pos = 0;\n\tstrm->buf.in_size = min_t(u32, inlen, PAGE_SIZE - rq->pageofs_in);\n\tinlen -= strm->buf.in_size;\n\tstrm->buf.out = NULL;\n\tstrm->buf.out_pos = 0;\n\tstrm->buf.out_size = 0;\n\n\tfor (ni = 0, no = -1;;) {\n\t\tenum xz_ret xz_err;\n\n\t\tif (strm->buf.out_pos == strm->buf.out_size) {\n\t\t\tif (strm->buf.out) {\n\t\t\t\tkunmap(rq->out[no]);\n\t\t\t\tstrm->buf.out = NULL;\n\t\t\t}\n\n\t\t\tif (++no >= nrpages_out || !outlen) {\n\t\t\t\terofs_err(rq->sb, \"decompressed buf out of bound\");\n\t\t\t\terr = -EFSCORRUPTED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrm->buf.out_pos = 0;\n\t\t\tstrm->buf.out_size = min_t(u32, outlen,\n\t\t\t\t\t\t   PAGE_SIZE - pageofs);\n\t\t\toutlen -= strm->buf.out_size;\n\t\t\tif (!rq->out[no] && rq->fillgaps) {\t \n\t\t\t\trq->out[no] = erofs_allocpage(pagepool,\n\t\t\t\t\t\tGFP_KERNEL | __GFP_NOFAIL);\n\t\t\t\tset_page_private(rq->out[no],\n\t\t\t\t\t\t Z_EROFS_SHORTLIVED_PAGE);\n\t\t\t}\n\t\t\tif (rq->out[no])\n\t\t\t\tstrm->buf.out = kmap(rq->out[no]) + pageofs;\n\t\t\tpageofs = 0;\n\t\t} else if (strm->buf.in_pos == strm->buf.in_size) {\n\t\t\tkunmap(rq->in[ni]);\n\n\t\t\tif (++ni >= nrpages_in || !inlen) {\n\t\t\t\terofs_err(rq->sb, \"compressed buf out of bound\");\n\t\t\t\terr = -EFSCORRUPTED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrm->buf.in_pos = 0;\n\t\t\tstrm->buf.in_size = min_t(u32, inlen, PAGE_SIZE);\n\t\t\tinlen -= strm->buf.in_size;\n\t\t\tkin = kmap(rq->in[ni]);\n\t\t\tstrm->buf.in = kin;\n\t\t\tbounced = false;\n\t\t}\n\n\t\t \n\t\tif (!bounced && rq->out[no] == rq->in[ni]) {\n\t\t\tmemcpy(strm->bounce, strm->buf.in, strm->buf.in_size);\n\t\t\tstrm->buf.in = strm->bounce;\n\t\t\tbounced = true;\n\t\t}\n\t\tfor (j = ni + 1; j < nrpages_in; ++j) {\n\t\t\tstruct page *tmppage;\n\n\t\t\tif (rq->out[no] != rq->in[j])\n\t\t\t\tcontinue;\n\n\t\t\tDBG_BUGON(erofs_page_is_managed(EROFS_SB(rq->sb),\n\t\t\t\t\t\t\trq->in[j]));\n\t\t\ttmppage = erofs_allocpage(pagepool,\n\t\t\t\t\t\t  GFP_KERNEL | __GFP_NOFAIL);\n\t\t\tset_page_private(tmppage, Z_EROFS_SHORTLIVED_PAGE);\n\t\t\tcopy_highpage(tmppage, rq->in[j]);\n\t\t\trq->in[j] = tmppage;\n\t\t}\n\t\txz_err = xz_dec_microlzma_run(strm->state, &strm->buf);\n\t\tDBG_BUGON(strm->buf.out_pos > strm->buf.out_size);\n\t\tDBG_BUGON(strm->buf.in_pos > strm->buf.in_size);\n\n\t\tif (xz_err != XZ_OK) {\n\t\t\tif (xz_err == XZ_STREAM_END && !outlen)\n\t\t\t\tbreak;\n\t\t\terofs_err(rq->sb, \"failed to decompress %d in[%u] out[%u]\",\n\t\t\t\t  xz_err, rq->inputsize, rq->outputsize);\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (no < nrpages_out && strm->buf.out)\n\t\tkunmap(rq->out[no]);\n\tif (ni < nrpages_in)\n\t\tkunmap(rq->in[ni]);\n\t \n\tspin_lock(&z_erofs_lzma_lock);\n\tstrm->next = z_erofs_lzma_head;\n\tz_erofs_lzma_head = strm;\n\tspin_unlock(&z_erofs_lzma_lock);\n\twake_up(&z_erofs_lzma_wq);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}