{
  "module_name": "sysfs.c",
  "hash_id": "d1ab1d4357b860270b8f7abee81b134e3eb73bd83a91c78a898df92ab1fbadaa",
  "original_prompt": "Ingested from linux-6.6.14/fs/erofs/sysfs.c",
  "human_readable_source": "\n \n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n\n#include \"internal.h\"\n\nenum {\n\tattr_feature,\n\tattr_pointer_ui,\n\tattr_pointer_bool,\n};\n\nenum {\n\tstruct_erofs_sb_info,\n\tstruct_erofs_mount_opts,\n};\n\nstruct erofs_attr {\n\tstruct attribute attr;\n\tshort attr_id;\n\tint struct_type, offset;\n};\n\n#define EROFS_ATTR(_name, _mode, _id)\t\t\t\t\t\\\nstatic struct erofs_attr erofs_attr_##_name = {\t\t\t\t\\\n\t.attr = {.name = __stringify(_name), .mode = _mode },\t\t\\\n\t.attr_id = attr_##_id,\t\t\t\t\t\t\\\n}\n#define EROFS_ATTR_FUNC(_name, _mode)\tEROFS_ATTR(_name, _mode, _name)\n#define EROFS_ATTR_FEATURE(_name)\tEROFS_ATTR(_name, 0444, feature)\n\n#define EROFS_ATTR_OFFSET(_name, _mode, _id, _struct)\t\\\nstatic struct erofs_attr erofs_attr_##_name = {\t\t\t\\\n\t.attr = {.name = __stringify(_name), .mode = _mode },\t\\\n\t.attr_id = attr_##_id,\t\t\t\t\t\\\n\t.struct_type = struct_##_struct,\t\t\t\\\n\t.offset = offsetof(struct _struct, _name),\\\n}\n\n#define EROFS_ATTR_RW(_name, _id, _struct)\t\\\n\tEROFS_ATTR_OFFSET(_name, 0644, _id, _struct)\n\n#define EROFS_RO_ATTR(_name, _id, _struct)\t\\\n\tEROFS_ATTR_OFFSET(_name, 0444, _id, _struct)\n\n#define EROFS_ATTR_RW_UI(_name, _struct)\t\\\n\tEROFS_ATTR_RW(_name, pointer_ui, _struct)\n\n#define EROFS_ATTR_RW_BOOL(_name, _struct)\t\\\n\tEROFS_ATTR_RW(_name, pointer_bool, _struct)\n\n#define ATTR_LIST(name) (&erofs_attr_##name.attr)\n\n#ifdef CONFIG_EROFS_FS_ZIP\nEROFS_ATTR_RW_UI(sync_decompress, erofs_mount_opts);\n#endif\n\nstatic struct attribute *erofs_attrs[] = {\n#ifdef CONFIG_EROFS_FS_ZIP\n\tATTR_LIST(sync_decompress),\n#endif\n\tNULL,\n};\nATTRIBUTE_GROUPS(erofs);\n\n \nEROFS_ATTR_FEATURE(zero_padding);\nEROFS_ATTR_FEATURE(compr_cfgs);\nEROFS_ATTR_FEATURE(big_pcluster);\nEROFS_ATTR_FEATURE(chunked_file);\nEROFS_ATTR_FEATURE(device_table);\nEROFS_ATTR_FEATURE(compr_head2);\nEROFS_ATTR_FEATURE(sb_chksum);\nEROFS_ATTR_FEATURE(ztailpacking);\nEROFS_ATTR_FEATURE(fragments);\nEROFS_ATTR_FEATURE(dedupe);\n\nstatic struct attribute *erofs_feat_attrs[] = {\n\tATTR_LIST(zero_padding),\n\tATTR_LIST(compr_cfgs),\n\tATTR_LIST(big_pcluster),\n\tATTR_LIST(chunked_file),\n\tATTR_LIST(device_table),\n\tATTR_LIST(compr_head2),\n\tATTR_LIST(sb_chksum),\n\tATTR_LIST(ztailpacking),\n\tATTR_LIST(fragments),\n\tATTR_LIST(dedupe),\n\tNULL,\n};\nATTRIBUTE_GROUPS(erofs_feat);\n\nstatic unsigned char *__struct_ptr(struct erofs_sb_info *sbi,\n\t\t\t\t\t  int struct_type, int offset)\n{\n\tif (struct_type == struct_erofs_sb_info)\n\t\treturn (unsigned char *)sbi + offset;\n\tif (struct_type == struct_erofs_mount_opts)\n\t\treturn (unsigned char *)&sbi->opt + offset;\n\treturn NULL;\n}\n\nstatic ssize_t erofs_attr_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr, char *buf)\n{\n\tstruct erofs_sb_info *sbi = container_of(kobj, struct erofs_sb_info,\n\t\t\t\t\t\ts_kobj);\n\tstruct erofs_attr *a = container_of(attr, struct erofs_attr, attr);\n\tunsigned char *ptr = __struct_ptr(sbi, a->struct_type, a->offset);\n\n\tswitch (a->attr_id) {\n\tcase attr_feature:\n\t\treturn sysfs_emit(buf, \"supported\\n\");\n\tcase attr_pointer_ui:\n\t\tif (!ptr)\n\t\t\treturn 0;\n\t\treturn sysfs_emit(buf, \"%u\\n\", *(unsigned int *)ptr);\n\tcase attr_pointer_bool:\n\t\tif (!ptr)\n\t\t\treturn 0;\n\t\treturn sysfs_emit(buf, \"%d\\n\", *(bool *)ptr);\n\t}\n\treturn 0;\n}\n\nstatic ssize_t erofs_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct erofs_sb_info *sbi = container_of(kobj, struct erofs_sb_info,\n\t\t\t\t\t\ts_kobj);\n\tstruct erofs_attr *a = container_of(attr, struct erofs_attr, attr);\n\tunsigned char *ptr = __struct_ptr(sbi, a->struct_type, a->offset);\n\tunsigned long t;\n\tint ret;\n\n\tswitch (a->attr_id) {\n\tcase attr_pointer_ui:\n\t\tif (!ptr)\n\t\t\treturn 0;\n\t\tret = kstrtoul(skip_spaces(buf), 0, &t);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (t != (unsigned int)t)\n\t\t\treturn -ERANGE;\n#ifdef CONFIG_EROFS_FS_ZIP\n\t\tif (!strcmp(a->attr.name, \"sync_decompress\") &&\n\t\t    (t > EROFS_SYNC_DECOMPRESS_FORCE_OFF))\n\t\t\treturn -EINVAL;\n#endif\n\t\t*(unsigned int *)ptr = t;\n\t\treturn len;\n\tcase attr_pointer_bool:\n\t\tif (!ptr)\n\t\t\treturn 0;\n\t\tret = kstrtoul(skip_spaces(buf), 0, &t);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (t != 0 && t != 1)\n\t\t\treturn -EINVAL;\n\t\t*(bool *)ptr = !!t;\n\t\treturn len;\n\t}\n\treturn 0;\n}\n\nstatic void erofs_sb_release(struct kobject *kobj)\n{\n\tstruct erofs_sb_info *sbi = container_of(kobj, struct erofs_sb_info,\n\t\t\t\t\t\t s_kobj);\n\tcomplete(&sbi->s_kobj_unregister);\n}\n\nstatic const struct sysfs_ops erofs_attr_ops = {\n\t.show\t= erofs_attr_show,\n\t.store\t= erofs_attr_store,\n};\n\nstatic const struct kobj_type erofs_sb_ktype = {\n\t.default_groups = erofs_groups,\n\t.sysfs_ops\t= &erofs_attr_ops,\n\t.release\t= erofs_sb_release,\n};\n\nstatic const struct kobj_type erofs_ktype = {\n\t.sysfs_ops\t= &erofs_attr_ops,\n};\n\nstatic struct kset erofs_root = {\n\t.kobj\t= {.ktype = &erofs_ktype},\n};\n\nstatic const struct kobj_type erofs_feat_ktype = {\n\t.default_groups = erofs_feat_groups,\n\t.sysfs_ops\t= &erofs_attr_ops,\n};\n\nstatic struct kobject erofs_feat = {\n\t.kset\t= &erofs_root,\n};\n\nint erofs_register_sysfs(struct super_block *sb)\n{\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\tchar *name;\n\tchar *str = NULL;\n\tint err;\n\n\tif (erofs_is_fscache_mode(sb)) {\n\t\tif (sbi->domain_id) {\n\t\t\tstr = kasprintf(GFP_KERNEL, \"%s,%s\", sbi->domain_id,\n\t\t\t\t\tsbi->fsid);\n\t\t\tif (!str)\n\t\t\t\treturn -ENOMEM;\n\t\t\tname = str;\n\t\t} else {\n\t\t\tname = sbi->fsid;\n\t\t}\n\t} else {\n\t\tname = sb->s_id;\n\t}\n\tsbi->s_kobj.kset = &erofs_root;\n\tinit_completion(&sbi->s_kobj_unregister);\n\terr = kobject_init_and_add(&sbi->s_kobj, &erofs_sb_ktype, NULL, \"%s\", name);\n\tkfree(str);\n\tif (err)\n\t\tgoto put_sb_kobj;\n\treturn 0;\n\nput_sb_kobj:\n\tkobject_put(&sbi->s_kobj);\n\twait_for_completion(&sbi->s_kobj_unregister);\n\treturn err;\n}\n\nvoid erofs_unregister_sysfs(struct super_block *sb)\n{\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\n\tif (sbi->s_kobj.state_in_sysfs) {\n\t\tkobject_del(&sbi->s_kobj);\n\t\tkobject_put(&sbi->s_kobj);\n\t\twait_for_completion(&sbi->s_kobj_unregister);\n\t}\n}\n\nint __init erofs_init_sysfs(void)\n{\n\tint ret;\n\n\tkobject_set_name(&erofs_root.kobj, \"erofs\");\n\terofs_root.kobj.parent = fs_kobj;\n\tret = kset_register(&erofs_root);\n\tif (ret)\n\t\tgoto root_err;\n\n\tret = kobject_init_and_add(&erofs_feat, &erofs_feat_ktype,\n\t\t\t\t   NULL, \"features\");\n\tif (ret)\n\t\tgoto feat_err;\n\treturn ret;\n\nfeat_err:\n\tkobject_put(&erofs_feat);\n\tkset_unregister(&erofs_root);\nroot_err:\n\treturn ret;\n}\n\nvoid erofs_exit_sysfs(void)\n{\n\tkobject_put(&erofs_feat);\n\tkset_unregister(&erofs_root);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}