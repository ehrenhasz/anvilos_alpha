{
  "module_name": "super.c",
  "hash_id": "2e1ee20060cd22dabf60cecfad1b01f658e488827f8198e0c7e79c580c449fa3",
  "original_prompt": "Ingested from linux-6.6.14/fs/erofs/super.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/crc32c.h>\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n#include <linux/dax.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/erofs.h>\n\nstatic struct kmem_cache *erofs_inode_cachep __read_mostly;\n\nvoid _erofs_err(struct super_block *sb, const char *func, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"(device %s): %s: %pV\", sb->s_id, func, &vaf);\n\tva_end(args);\n}\n\nvoid _erofs_info(struct super_block *sb, const char *func, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_info(\"(device %s): %pV\", sb->s_id, &vaf);\n\tva_end(args);\n}\n\nstatic int erofs_superblock_csum_verify(struct super_block *sb, void *sbdata)\n{\n\tsize_t len = 1 << EROFS_SB(sb)->blkszbits;\n\tstruct erofs_super_block *dsb;\n\tu32 expected_crc, crc;\n\n\tif (len > EROFS_SUPER_OFFSET)\n\t\tlen -= EROFS_SUPER_OFFSET;\n\n\tdsb = kmemdup(sbdata + EROFS_SUPER_OFFSET, len, GFP_KERNEL);\n\tif (!dsb)\n\t\treturn -ENOMEM;\n\n\texpected_crc = le32_to_cpu(dsb->checksum);\n\tdsb->checksum = 0;\n\t \n\tcrc = crc32c(~0, dsb, len);\n\tkfree(dsb);\n\n\tif (crc != expected_crc) {\n\t\terofs_err(sb, \"invalid checksum 0x%08x, 0x%08x expected\",\n\t\t\t  crc, expected_crc);\n\t\treturn -EBADMSG;\n\t}\n\treturn 0;\n}\n\nstatic void erofs_inode_init_once(void *ptr)\n{\n\tstruct erofs_inode *vi = ptr;\n\n\tinode_init_once(&vi->vfs_inode);\n}\n\nstatic struct inode *erofs_alloc_inode(struct super_block *sb)\n{\n\tstruct erofs_inode *vi =\n\t\talloc_inode_sb(sb, erofs_inode_cachep, GFP_KERNEL);\n\n\tif (!vi)\n\t\treturn NULL;\n\n\t \n\tmemset(vi, 0, offsetof(struct erofs_inode, vfs_inode));\n\treturn &vi->vfs_inode;\n}\n\nstatic void erofs_free_inode(struct inode *inode)\n{\n\tstruct erofs_inode *vi = EROFS_I(inode);\n\n\tif (inode->i_op == &erofs_fast_symlink_iops)\n\t\tkfree(inode->i_link);\n\tkfree(vi->xattr_shared_xattrs);\n\tkmem_cache_free(erofs_inode_cachep, vi);\n}\n\nstatic bool check_layout_compatibility(struct super_block *sb,\n\t\t\t\t       struct erofs_super_block *dsb)\n{\n\tconst unsigned int feature = le32_to_cpu(dsb->feature_incompat);\n\n\tEROFS_SB(sb)->feature_incompat = feature;\n\n\t \n\tif (feature & (~EROFS_ALL_FEATURE_INCOMPAT)) {\n\t\terofs_err(sb, \"unidentified incompatible feature %x, please upgrade kernel\",\n\t\t\t   feature & ~EROFS_ALL_FEATURE_INCOMPAT);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nvoid *erofs_read_metadata(struct super_block *sb, struct erofs_buf *buf,\n\t\t\t  erofs_off_t *offset, int *lengthp)\n{\n\tu8 *buffer, *ptr;\n\tint len, i, cnt;\n\n\t*offset = round_up(*offset, 4);\n\tptr = erofs_bread(buf, erofs_blknr(sb, *offset), EROFS_KMAP);\n\tif (IS_ERR(ptr))\n\t\treturn ptr;\n\n\tlen = le16_to_cpu(*(__le16 *)&ptr[erofs_blkoff(sb, *offset)]);\n\tif (!len)\n\t\tlen = U16_MAX + 1;\n\tbuffer = kmalloc(len, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn ERR_PTR(-ENOMEM);\n\t*offset += sizeof(__le16);\n\t*lengthp = len;\n\n\tfor (i = 0; i < len; i += cnt) {\n\t\tcnt = min_t(int, sb->s_blocksize - erofs_blkoff(sb, *offset),\n\t\t\t    len - i);\n\t\tptr = erofs_bread(buf, erofs_blknr(sb, *offset), EROFS_KMAP);\n\t\tif (IS_ERR(ptr)) {\n\t\t\tkfree(buffer);\n\t\t\treturn ptr;\n\t\t}\n\t\tmemcpy(buffer + i, ptr + erofs_blkoff(sb, *offset), cnt);\n\t\t*offset += cnt;\n\t}\n\treturn buffer;\n}\n\n#ifndef CONFIG_EROFS_FS_ZIP\nstatic int z_erofs_parse_cfgs(struct super_block *sb,\n\t\t\t      struct erofs_super_block *dsb)\n{\n\tif (!dsb->u1.available_compr_algs)\n\t\treturn 0;\n\n\terofs_err(sb, \"compression disabled, unable to mount compressed EROFS\");\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nstatic int erofs_init_device(struct erofs_buf *buf, struct super_block *sb,\n\t\t\t     struct erofs_device_info *dif, erofs_off_t *pos)\n{\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\tstruct erofs_fscache *fscache;\n\tstruct erofs_deviceslot *dis;\n\tstruct block_device *bdev;\n\tvoid *ptr;\n\n\tptr = erofs_read_metabuf(buf, sb, erofs_blknr(sb, *pos), EROFS_KMAP);\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\tdis = ptr + erofs_blkoff(sb, *pos);\n\n\tif (!sbi->devs->flatdev && !dif->path) {\n\t\tif (!dis->tag[0]) {\n\t\t\terofs_err(sb, \"empty device tag @ pos %llu\", *pos);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdif->path = kmemdup_nul(dis->tag, sizeof(dis->tag), GFP_KERNEL);\n\t\tif (!dif->path)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (erofs_is_fscache_mode(sb)) {\n\t\tfscache = erofs_fscache_register_cookie(sb, dif->path, 0);\n\t\tif (IS_ERR(fscache))\n\t\t\treturn PTR_ERR(fscache);\n\t\tdif->fscache = fscache;\n\t} else if (!sbi->devs->flatdev) {\n\t\tbdev = blkdev_get_by_path(dif->path, BLK_OPEN_READ, sb->s_type,\n\t\t\t\t\t  NULL);\n\t\tif (IS_ERR(bdev))\n\t\t\treturn PTR_ERR(bdev);\n\t\tdif->bdev = bdev;\n\t\tdif->dax_dev = fs_dax_get_by_bdev(bdev, &dif->dax_part_off,\n\t\t\t\t\t\t  NULL, NULL);\n\t}\n\n\tdif->blocks = le32_to_cpu(dis->blocks);\n\tdif->mapped_blkaddr = le32_to_cpu(dis->mapped_blkaddr);\n\tsbi->total_blocks += dif->blocks;\n\t*pos += EROFS_DEVT_SLOT_SIZE;\n\treturn 0;\n}\n\nstatic int erofs_scan_devices(struct super_block *sb,\n\t\t\t      struct erofs_super_block *dsb)\n{\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\tunsigned int ondisk_extradevs;\n\terofs_off_t pos;\n\tstruct erofs_buf buf = __EROFS_BUF_INITIALIZER;\n\tstruct erofs_device_info *dif;\n\tint id, err = 0;\n\n\tsbi->total_blocks = sbi->primarydevice_blocks;\n\tif (!erofs_sb_has_device_table(sbi))\n\t\tondisk_extradevs = 0;\n\telse\n\t\tondisk_extradevs = le16_to_cpu(dsb->extra_devices);\n\n\tif (sbi->devs->extra_devices &&\n\t    ondisk_extradevs != sbi->devs->extra_devices) {\n\t\terofs_err(sb, \"extra devices don't match (ondisk %u, given %u)\",\n\t\t\t  ondisk_extradevs, sbi->devs->extra_devices);\n\t\treturn -EINVAL;\n\t}\n\tif (!ondisk_extradevs)\n\t\treturn 0;\n\n\tif (!sbi->devs->extra_devices && !erofs_is_fscache_mode(sb))\n\t\tsbi->devs->flatdev = true;\n\n\tsbi->device_id_mask = roundup_pow_of_two(ondisk_extradevs + 1) - 1;\n\tpos = le16_to_cpu(dsb->devt_slotoff) * EROFS_DEVT_SLOT_SIZE;\n\tdown_read(&sbi->devs->rwsem);\n\tif (sbi->devs->extra_devices) {\n\t\tidr_for_each_entry(&sbi->devs->tree, dif, id) {\n\t\t\terr = erofs_init_device(&buf, sb, dif, &pos);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tfor (id = 0; id < ondisk_extradevs; id++) {\n\t\t\tdif = kzalloc(sizeof(*dif), GFP_KERNEL);\n\t\t\tif (!dif) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\terr = idr_alloc(&sbi->devs->tree, dif, 0, 0, GFP_KERNEL);\n\t\t\tif (err < 0) {\n\t\t\t\tkfree(dif);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++sbi->devs->extra_devices;\n\n\t\t\terr = erofs_init_device(&buf, sb, dif, &pos);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&sbi->devs->rwsem);\n\terofs_put_metabuf(&buf);\n\treturn err;\n}\n\nstatic int erofs_read_superblock(struct super_block *sb)\n{\n\tstruct erofs_sb_info *sbi;\n\tstruct erofs_buf buf = __EROFS_BUF_INITIALIZER;\n\tstruct erofs_super_block *dsb;\n\tvoid *data;\n\tint ret;\n\n\tdata = erofs_read_metabuf(&buf, sb, 0, EROFS_KMAP);\n\tif (IS_ERR(data)) {\n\t\terofs_err(sb, \"cannot read erofs superblock\");\n\t\treturn PTR_ERR(data);\n\t}\n\n\tsbi = EROFS_SB(sb);\n\tdsb = (struct erofs_super_block *)(data + EROFS_SUPER_OFFSET);\n\n\tret = -EINVAL;\n\tif (le32_to_cpu(dsb->magic) != EROFS_SUPER_MAGIC_V1) {\n\t\terofs_err(sb, \"cannot find valid erofs superblock\");\n\t\tgoto out;\n\t}\n\n\tsbi->blkszbits  = dsb->blkszbits;\n\tif (sbi->blkszbits < 9 || sbi->blkszbits > PAGE_SHIFT) {\n\t\terofs_err(sb, \"blkszbits %u isn't supported\", sbi->blkszbits);\n\t\tgoto out;\n\t}\n\tif (dsb->dirblkbits) {\n\t\terofs_err(sb, \"dirblkbits %u isn't supported\", dsb->dirblkbits);\n\t\tgoto out;\n\t}\n\n\tsbi->feature_compat = le32_to_cpu(dsb->feature_compat);\n\tif (erofs_sb_has_sb_chksum(sbi)) {\n\t\tret = erofs_superblock_csum_verify(sb, data);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = -EINVAL;\n\tif (!check_layout_compatibility(sb, dsb))\n\t\tgoto out;\n\n\tsbi->sb_size = 128 + dsb->sb_extslots * EROFS_SB_EXTSLOT_SIZE;\n\tif (sbi->sb_size > PAGE_SIZE - EROFS_SUPER_OFFSET) {\n\t\terofs_err(sb, \"invalid sb_extslots %u (more than a fs block)\",\n\t\t\t  sbi->sb_size);\n\t\tgoto out;\n\t}\n\tsbi->primarydevice_blocks = le32_to_cpu(dsb->blocks);\n\tsbi->meta_blkaddr = le32_to_cpu(dsb->meta_blkaddr);\n#ifdef CONFIG_EROFS_FS_XATTR\n\tsbi->xattr_blkaddr = le32_to_cpu(dsb->xattr_blkaddr);\n\tsbi->xattr_prefix_start = le32_to_cpu(dsb->xattr_prefix_start);\n\tsbi->xattr_prefix_count = dsb->xattr_prefix_count;\n\tsbi->xattr_filter_reserved = dsb->xattr_filter_reserved;\n#endif\n\tsbi->islotbits = ilog2(sizeof(struct erofs_inode_compact));\n\tsbi->root_nid = le16_to_cpu(dsb->root_nid);\n\tsbi->packed_nid = le64_to_cpu(dsb->packed_nid);\n\tsbi->inos = le64_to_cpu(dsb->inos);\n\n\tsbi->build_time = le64_to_cpu(dsb->build_time);\n\tsbi->build_time_nsec = le32_to_cpu(dsb->build_time_nsec);\n\n\tmemcpy(&sb->s_uuid, dsb->uuid, sizeof(dsb->uuid));\n\n\tret = strscpy(sbi->volume_name, dsb->volume_name,\n\t\t      sizeof(dsb->volume_name));\n\tif (ret < 0) {\t \n\t\terofs_err(sb, \"bad volume name without NIL terminator\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\n\t \n\tret = z_erofs_parse_cfgs(sb, dsb);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = erofs_scan_devices(sb, dsb);\n\n\tif (erofs_is_fscache_mode(sb))\n\t\terofs_info(sb, \"EXPERIMENTAL fscache-based on-demand read feature in use. Use at your own risk!\");\nout:\n\terofs_put_metabuf(&buf);\n\treturn ret;\n}\n\nstatic void erofs_default_options(struct erofs_fs_context *ctx)\n{\n#ifdef CONFIG_EROFS_FS_ZIP\n\tctx->opt.cache_strategy = EROFS_ZIP_CACHE_READAROUND;\n\tctx->opt.max_sync_decompress_pages = 3;\n\tctx->opt.sync_decompress = EROFS_SYNC_DECOMPRESS_AUTO;\n#endif\n#ifdef CONFIG_EROFS_FS_XATTR\n\tset_opt(&ctx->opt, XATTR_USER);\n#endif\n#ifdef CONFIG_EROFS_FS_POSIX_ACL\n\tset_opt(&ctx->opt, POSIX_ACL);\n#endif\n}\n\nenum {\n\tOpt_user_xattr,\n\tOpt_acl,\n\tOpt_cache_strategy,\n\tOpt_dax,\n\tOpt_dax_enum,\n\tOpt_device,\n\tOpt_fsid,\n\tOpt_domain_id,\n\tOpt_err\n};\n\nstatic const struct constant_table erofs_param_cache_strategy[] = {\n\t{\"disabled\",\tEROFS_ZIP_CACHE_DISABLED},\n\t{\"readahead\",\tEROFS_ZIP_CACHE_READAHEAD},\n\t{\"readaround\",\tEROFS_ZIP_CACHE_READAROUND},\n\t{}\n};\n\nstatic const struct constant_table erofs_dax_param_enums[] = {\n\t{\"always\",\tEROFS_MOUNT_DAX_ALWAYS},\n\t{\"never\",\tEROFS_MOUNT_DAX_NEVER},\n\t{}\n};\n\nstatic const struct fs_parameter_spec erofs_fs_parameters[] = {\n\tfsparam_flag_no(\"user_xattr\",\tOpt_user_xattr),\n\tfsparam_flag_no(\"acl\",\t\tOpt_acl),\n\tfsparam_enum(\"cache_strategy\",\tOpt_cache_strategy,\n\t\t     erofs_param_cache_strategy),\n\tfsparam_flag(\"dax\",             Opt_dax),\n\tfsparam_enum(\"dax\",\t\tOpt_dax_enum, erofs_dax_param_enums),\n\tfsparam_string(\"device\",\tOpt_device),\n\tfsparam_string(\"fsid\",\t\tOpt_fsid),\n\tfsparam_string(\"domain_id\",\tOpt_domain_id),\n\t{}\n};\n\nstatic bool erofs_fc_set_dax_mode(struct fs_context *fc, unsigned int mode)\n{\n#ifdef CONFIG_FS_DAX\n\tstruct erofs_fs_context *ctx = fc->fs_private;\n\n\tswitch (mode) {\n\tcase EROFS_MOUNT_DAX_ALWAYS:\n\t\twarnfc(fc, \"DAX enabled. Warning: EXPERIMENTAL, use at your own risk\");\n\t\tset_opt(&ctx->opt, DAX_ALWAYS);\n\t\tclear_opt(&ctx->opt, DAX_NEVER);\n\t\treturn true;\n\tcase EROFS_MOUNT_DAX_NEVER:\n\t\tset_opt(&ctx->opt, DAX_NEVER);\n\t\tclear_opt(&ctx->opt, DAX_ALWAYS);\n\t\treturn true;\n\tdefault:\n\t\tDBG_BUGON(1);\n\t\treturn false;\n\t}\n#else\n\terrorfc(fc, \"dax options not supported\");\n\treturn false;\n#endif\n}\n\nstatic int erofs_fc_parse_param(struct fs_context *fc,\n\t\t\t\tstruct fs_parameter *param)\n{\n\tstruct erofs_fs_context *ctx = fc->fs_private;\n\tstruct fs_parse_result result;\n\tstruct erofs_device_info *dif;\n\tint opt, ret;\n\n\topt = fs_parse(fc, erofs_fs_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_user_xattr:\n#ifdef CONFIG_EROFS_FS_XATTR\n\t\tif (result.boolean)\n\t\t\tset_opt(&ctx->opt, XATTR_USER);\n\t\telse\n\t\t\tclear_opt(&ctx->opt, XATTR_USER);\n#else\n\t\terrorfc(fc, \"{,no}user_xattr options not supported\");\n#endif\n\t\tbreak;\n\tcase Opt_acl:\n#ifdef CONFIG_EROFS_FS_POSIX_ACL\n\t\tif (result.boolean)\n\t\t\tset_opt(&ctx->opt, POSIX_ACL);\n\t\telse\n\t\t\tclear_opt(&ctx->opt, POSIX_ACL);\n#else\n\t\terrorfc(fc, \"{,no}acl options not supported\");\n#endif\n\t\tbreak;\n\tcase Opt_cache_strategy:\n#ifdef CONFIG_EROFS_FS_ZIP\n\t\tctx->opt.cache_strategy = result.uint_32;\n#else\n\t\terrorfc(fc, \"compression not supported, cache_strategy ignored\");\n#endif\n\t\tbreak;\n\tcase Opt_dax:\n\t\tif (!erofs_fc_set_dax_mode(fc, EROFS_MOUNT_DAX_ALWAYS))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase Opt_dax_enum:\n\t\tif (!erofs_fc_set_dax_mode(fc, result.uint_32))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase Opt_device:\n\t\tdif = kzalloc(sizeof(*dif), GFP_KERNEL);\n\t\tif (!dif)\n\t\t\treturn -ENOMEM;\n\t\tdif->path = kstrdup(param->string, GFP_KERNEL);\n\t\tif (!dif->path) {\n\t\t\tkfree(dif);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdown_write(&ctx->devs->rwsem);\n\t\tret = idr_alloc(&ctx->devs->tree, dif, 0, 0, GFP_KERNEL);\n\t\tup_write(&ctx->devs->rwsem);\n\t\tif (ret < 0) {\n\t\t\tkfree(dif->path);\n\t\t\tkfree(dif);\n\t\t\treturn ret;\n\t\t}\n\t\t++ctx->devs->extra_devices;\n\t\tbreak;\n#ifdef CONFIG_EROFS_FS_ONDEMAND\n\tcase Opt_fsid:\n\t\tkfree(ctx->fsid);\n\t\tctx->fsid = kstrdup(param->string, GFP_KERNEL);\n\t\tif (!ctx->fsid)\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase Opt_domain_id:\n\t\tkfree(ctx->domain_id);\n\t\tctx->domain_id = kstrdup(param->string, GFP_KERNEL);\n\t\tif (!ctx->domain_id)\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n#else\n\tcase Opt_fsid:\n\tcase Opt_domain_id:\n\t\terrorfc(fc, \"%s option not supported\", erofs_fs_parameters[opt].name);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -ENOPARAM;\n\t}\n\treturn 0;\n}\n\nstatic struct inode *erofs_nfs_get_inode(struct super_block *sb,\n\t\t\t\t\t u64 ino, u32 generation)\n{\n\treturn erofs_iget(sb, ino);\n}\n\nstatic struct dentry *erofs_fh_to_dentry(struct super_block *sb,\n\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    erofs_nfs_get_inode);\n}\n\nstatic struct dentry *erofs_fh_to_parent(struct super_block *sb,\n\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    erofs_nfs_get_inode);\n}\n\nstatic struct dentry *erofs_get_parent(struct dentry *child)\n{\n\terofs_nid_t nid;\n\tunsigned int d_type;\n\tint err;\n\n\terr = erofs_namei(d_inode(child), &dotdot_name, &nid, &d_type);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn d_obtain_alias(erofs_iget(child->d_sb, nid));\n}\n\nstatic const struct export_operations erofs_export_ops = {\n\t.fh_to_dentry = erofs_fh_to_dentry,\n\t.fh_to_parent = erofs_fh_to_parent,\n\t.get_parent = erofs_get_parent,\n};\n\nstatic int erofs_fc_fill_pseudo_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstatic const struct tree_descr empty_descr = {\"\"};\n\n\treturn simple_fill_super(sb, EROFS_SUPER_MAGIC, &empty_descr);\n}\n\nstatic int erofs_fc_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct inode *inode;\n\tstruct erofs_sb_info *sbi;\n\tstruct erofs_fs_context *ctx = fc->fs_private;\n\tint err;\n\n\tsb->s_magic = EROFS_SUPER_MAGIC;\n\tsb->s_flags |= SB_RDONLY | SB_NOATIME;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_op = &erofs_sops;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = sbi;\n\tsbi->opt = ctx->opt;\n\tsbi->devs = ctx->devs;\n\tctx->devs = NULL;\n\tsbi->fsid = ctx->fsid;\n\tctx->fsid = NULL;\n\tsbi->domain_id = ctx->domain_id;\n\tctx->domain_id = NULL;\n\n\tsbi->blkszbits = PAGE_SHIFT;\n\tif (erofs_is_fscache_mode(sb)) {\n\t\tsb->s_blocksize = PAGE_SIZE;\n\t\tsb->s_blocksize_bits = PAGE_SHIFT;\n\n\t\terr = erofs_fscache_register_fs(sb);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = super_setup_bdi(sb);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tif (!sb_set_blocksize(sb, PAGE_SIZE)) {\n\t\t\terrorfc(fc, \"failed to set initial blksize\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsbi->dax_dev = fs_dax_get_by_bdev(sb->s_bdev,\n\t\t\t\t\t\t  &sbi->dax_part_off,\n\t\t\t\t\t\t  NULL, NULL);\n\t}\n\n\terr = erofs_read_superblock(sb);\n\tif (err)\n\t\treturn err;\n\n\tif (sb->s_blocksize_bits != sbi->blkszbits) {\n\t\tif (erofs_is_fscache_mode(sb)) {\n\t\t\terrorfc(fc, \"unsupported blksize for fscache mode\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!sb_set_blocksize(sb, 1 << sbi->blkszbits)) {\n\t\t\terrorfc(fc, \"failed to set erofs blksize\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (test_opt(&sbi->opt, DAX_ALWAYS)) {\n\t\tif (!sbi->dax_dev) {\n\t\t\terrorfc(fc, \"DAX unsupported by block device. Turning off DAX.\");\n\t\t\tclear_opt(&sbi->opt, DAX_ALWAYS);\n\t\t} else if (sbi->blkszbits != PAGE_SHIFT) {\n\t\t\terrorfc(fc, \"unsupported blocksize for DAX\");\n\t\t\tclear_opt(&sbi->opt, DAX_ALWAYS);\n\t\t}\n\t}\n\n\tsb->s_time_gran = 1;\n\tsb->s_xattr = erofs_xattr_handlers;\n\tsb->s_export_op = &erofs_export_ops;\n\n\tif (test_opt(&sbi->opt, POSIX_ACL))\n\t\tsb->s_flags |= SB_POSIXACL;\n\telse\n\t\tsb->s_flags &= ~SB_POSIXACL;\n\n#ifdef CONFIG_EROFS_FS_ZIP\n\txa_init(&sbi->managed_pslots);\n#endif\n\n\tinode = erofs_iget(sb, ROOT_NID(sbi));\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\terofs_err(sb, \"rootino(nid %llu) is not a directory(i_mode %o)\",\n\t\t\t  ROOT_NID(sbi), inode->i_mode);\n\t\tiput(inode);\n\t\treturn -EINVAL;\n\t}\n\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\terofs_shrinker_register(sb);\n\tif (erofs_sb_has_fragments(sbi) && sbi->packed_nid) {\n\t\tsbi->packed_inode = erofs_iget(sb, sbi->packed_nid);\n\t\tif (IS_ERR(sbi->packed_inode)) {\n\t\t\terr = PTR_ERR(sbi->packed_inode);\n\t\t\tsbi->packed_inode = NULL;\n\t\t\treturn err;\n\t\t}\n\t}\n\terr = erofs_init_managed_cache(sb);\n\tif (err)\n\t\treturn err;\n\n\terr = erofs_xattr_prefixes_init(sb);\n\tif (err)\n\t\treturn err;\n\n\terr = erofs_register_sysfs(sb);\n\tif (err)\n\t\treturn err;\n\n\terofs_info(sb, \"mounted with root inode @ nid %llu.\", ROOT_NID(sbi));\n\treturn 0;\n}\n\nstatic int erofs_fc_anon_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_nodev(fc, erofs_fc_fill_pseudo_super);\n}\n\nstatic int erofs_fc_get_tree(struct fs_context *fc)\n{\n\tstruct erofs_fs_context *ctx = fc->fs_private;\n\n\tif (IS_ENABLED(CONFIG_EROFS_FS_ONDEMAND) && ctx->fsid)\n\t\treturn get_tree_nodev(fc, erofs_fc_fill_super);\n\n\treturn get_tree_bdev(fc, erofs_fc_fill_super);\n}\n\nstatic int erofs_fc_reconfigure(struct fs_context *fc)\n{\n\tstruct super_block *sb = fc->root->d_sb;\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\tstruct erofs_fs_context *ctx = fc->fs_private;\n\n\tDBG_BUGON(!sb_rdonly(sb));\n\n\tif (ctx->fsid || ctx->domain_id)\n\t\terofs_info(sb, \"ignoring reconfiguration for fsid|domain_id.\");\n\n\tif (test_opt(&ctx->opt, POSIX_ACL))\n\t\tfc->sb_flags |= SB_POSIXACL;\n\telse\n\t\tfc->sb_flags &= ~SB_POSIXACL;\n\n\tsbi->opt = ctx->opt;\n\n\tfc->sb_flags |= SB_RDONLY;\n\treturn 0;\n}\n\nstatic int erofs_release_device_info(int id, void *ptr, void *data)\n{\n\tstruct erofs_device_info *dif = ptr;\n\n\tfs_put_dax(dif->dax_dev, NULL);\n\tif (dif->bdev)\n\t\tblkdev_put(dif->bdev, &erofs_fs_type);\n\terofs_fscache_unregister_cookie(dif->fscache);\n\tdif->fscache = NULL;\n\tkfree(dif->path);\n\tkfree(dif);\n\treturn 0;\n}\n\nstatic void erofs_free_dev_context(struct erofs_dev_context *devs)\n{\n\tif (!devs)\n\t\treturn;\n\tidr_for_each(&devs->tree, &erofs_release_device_info, NULL);\n\tidr_destroy(&devs->tree);\n\tkfree(devs);\n}\n\nstatic void erofs_fc_free(struct fs_context *fc)\n{\n\tstruct erofs_fs_context *ctx = fc->fs_private;\n\n\terofs_free_dev_context(ctx->devs);\n\tkfree(ctx->fsid);\n\tkfree(ctx->domain_id);\n\tkfree(ctx);\n}\n\nstatic const struct fs_context_operations erofs_context_ops = {\n\t.parse_param\t= erofs_fc_parse_param,\n\t.get_tree       = erofs_fc_get_tree,\n\t.reconfigure    = erofs_fc_reconfigure,\n\t.free\t\t= erofs_fc_free,\n};\n\nstatic const struct fs_context_operations erofs_anon_context_ops = {\n\t.get_tree       = erofs_fc_anon_get_tree,\n};\n\nstatic int erofs_init_fs_context(struct fs_context *fc)\n{\n\tstruct erofs_fs_context *ctx;\n\n\t \n\tif (fc->sb_flags & SB_KERNMOUNT) {\n\t\tfc->ops = &erofs_anon_context_ops;\n\t\treturn 0;\n\t}\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->devs = kzalloc(sizeof(struct erofs_dev_context), GFP_KERNEL);\n\tif (!ctx->devs) {\n\t\tkfree(ctx);\n\t\treturn -ENOMEM;\n\t}\n\tfc->fs_private = ctx;\n\n\tidr_init(&ctx->devs->tree);\n\tinit_rwsem(&ctx->devs->rwsem);\n\terofs_default_options(ctx);\n\tfc->ops = &erofs_context_ops;\n\treturn 0;\n}\n\nstatic void erofs_kill_sb(struct super_block *sb)\n{\n\tstruct erofs_sb_info *sbi;\n\n\t \n\tif (sb->s_flags & SB_KERNMOUNT) {\n\t\tkill_anon_super(sb);\n\t\treturn;\n\t}\n\n\tif (erofs_is_fscache_mode(sb))\n\t\tkill_anon_super(sb);\n\telse\n\t\tkill_block_super(sb);\n\n\tsbi = EROFS_SB(sb);\n\tif (!sbi)\n\t\treturn;\n\n\terofs_free_dev_context(sbi->devs);\n\tfs_put_dax(sbi->dax_dev, NULL);\n\terofs_fscache_unregister_fs(sb);\n\tkfree(sbi->fsid);\n\tkfree(sbi->domain_id);\n\tkfree(sbi);\n\tsb->s_fs_info = NULL;\n}\n\nstatic void erofs_put_super(struct super_block *sb)\n{\n\tstruct erofs_sb_info *const sbi = EROFS_SB(sb);\n\n\tDBG_BUGON(!sbi);\n\n\terofs_unregister_sysfs(sb);\n\terofs_shrinker_unregister(sb);\n\terofs_xattr_prefixes_cleanup(sb);\n#ifdef CONFIG_EROFS_FS_ZIP\n\tiput(sbi->managed_cache);\n\tsbi->managed_cache = NULL;\n#endif\n\tiput(sbi->packed_inode);\n\tsbi->packed_inode = NULL;\n\terofs_free_dev_context(sbi->devs);\n\tsbi->devs = NULL;\n\terofs_fscache_unregister_fs(sb);\n}\n\nstruct file_system_type erofs_fs_type = {\n\t.owner          = THIS_MODULE,\n\t.name           = \"erofs\",\n\t.init_fs_context = erofs_init_fs_context,\n\t.kill_sb        = erofs_kill_sb,\n\t.fs_flags       = FS_REQUIRES_DEV | FS_ALLOW_IDMAP,\n};\nMODULE_ALIAS_FS(\"erofs\");\n\nstatic int __init erofs_module_init(void)\n{\n\tint err;\n\n\terofs_check_ondisk_layout_definitions();\n\n\terofs_inode_cachep = kmem_cache_create(\"erofs_inode\",\n\t\t\tsizeof(struct erofs_inode), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD | SLAB_ACCOUNT,\n\t\t\terofs_inode_init_once);\n\tif (!erofs_inode_cachep)\n\t\treturn -ENOMEM;\n\n\terr = erofs_init_shrinker();\n\tif (err)\n\t\tgoto shrinker_err;\n\n\terr = z_erofs_lzma_init();\n\tif (err)\n\t\tgoto lzma_err;\n\n\terr = z_erofs_deflate_init();\n\tif (err)\n\t\tgoto deflate_err;\n\n\terofs_pcpubuf_init();\n\terr = z_erofs_init_zip_subsystem();\n\tif (err)\n\t\tgoto zip_err;\n\n\terr = erofs_init_sysfs();\n\tif (err)\n\t\tgoto sysfs_err;\n\n\terr = register_filesystem(&erofs_fs_type);\n\tif (err)\n\t\tgoto fs_err;\n\n\treturn 0;\n\nfs_err:\n\terofs_exit_sysfs();\nsysfs_err:\n\tz_erofs_exit_zip_subsystem();\nzip_err:\n\tz_erofs_deflate_exit();\ndeflate_err:\n\tz_erofs_lzma_exit();\nlzma_err:\n\terofs_exit_shrinker();\nshrinker_err:\n\tkmem_cache_destroy(erofs_inode_cachep);\n\treturn err;\n}\n\nstatic void __exit erofs_module_exit(void)\n{\n\tunregister_filesystem(&erofs_fs_type);\n\n\t \n\trcu_barrier();\n\n\terofs_exit_sysfs();\n\tz_erofs_exit_zip_subsystem();\n\tz_erofs_deflate_exit();\n\tz_erofs_lzma_exit();\n\terofs_exit_shrinker();\n\tkmem_cache_destroy(erofs_inode_cachep);\n\terofs_pcpubuf_exit();\n}\n\nstatic int erofs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\tu64 id = 0;\n\n\tif (!erofs_is_fscache_mode(sb))\n\t\tid = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type = sb->s_magic;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = sbi->total_blocks;\n\tbuf->f_bfree = buf->f_bavail = 0;\n\n\tbuf->f_files = ULLONG_MAX;\n\tbuf->f_ffree = ULLONG_MAX - sbi->inos;\n\n\tbuf->f_namelen = EROFS_NAME_LEN;\n\n\tbuf->f_fsid    = u64_to_fsid(id);\n\treturn 0;\n}\n\nstatic int erofs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct erofs_sb_info *sbi = EROFS_SB(root->d_sb);\n\tstruct erofs_mount_opts *opt = &sbi->opt;\n\n#ifdef CONFIG_EROFS_FS_XATTR\n\tif (test_opt(opt, XATTR_USER))\n\t\tseq_puts(seq, \",user_xattr\");\n\telse\n\t\tseq_puts(seq, \",nouser_xattr\");\n#endif\n#ifdef CONFIG_EROFS_FS_POSIX_ACL\n\tif (test_opt(opt, POSIX_ACL))\n\t\tseq_puts(seq, \",acl\");\n\telse\n\t\tseq_puts(seq, \",noacl\");\n#endif\n#ifdef CONFIG_EROFS_FS_ZIP\n\tif (opt->cache_strategy == EROFS_ZIP_CACHE_DISABLED)\n\t\tseq_puts(seq, \",cache_strategy=disabled\");\n\telse if (opt->cache_strategy == EROFS_ZIP_CACHE_READAHEAD)\n\t\tseq_puts(seq, \",cache_strategy=readahead\");\n\telse if (opt->cache_strategy == EROFS_ZIP_CACHE_READAROUND)\n\t\tseq_puts(seq, \",cache_strategy=readaround\");\n#endif\n\tif (test_opt(opt, DAX_ALWAYS))\n\t\tseq_puts(seq, \",dax=always\");\n\tif (test_opt(opt, DAX_NEVER))\n\t\tseq_puts(seq, \",dax=never\");\n#ifdef CONFIG_EROFS_FS_ONDEMAND\n\tif (sbi->fsid)\n\t\tseq_printf(seq, \",fsid=%s\", sbi->fsid);\n\tif (sbi->domain_id)\n\t\tseq_printf(seq, \",domain_id=%s\", sbi->domain_id);\n#endif\n\treturn 0;\n}\n\nconst struct super_operations erofs_sops = {\n\t.put_super = erofs_put_super,\n\t.alloc_inode = erofs_alloc_inode,\n\t.free_inode = erofs_free_inode,\n\t.statfs = erofs_statfs,\n\t.show_options = erofs_show_options,\n};\n\nmodule_init(erofs_module_init);\nmodule_exit(erofs_module_exit);\n\nMODULE_DESCRIPTION(\"Enhanced ROM File System\");\nMODULE_AUTHOR(\"Gao Xiang, Chao Yu, Miao Xie, CONSUMER BG, HUAWEI Inc.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}