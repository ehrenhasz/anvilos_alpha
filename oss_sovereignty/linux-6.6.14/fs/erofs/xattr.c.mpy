{
  "module_name": "xattr.c",
  "hash_id": "2102d7c53f36ae73995a35dbf4f1dbf66b3008e843f0c46356cdebd2df6b0e19",
  "original_prompt": "Ingested from linux-6.6.14/fs/erofs/xattr.c",
  "human_readable_source": "\n \n#include <linux/security.h>\n#include <linux/xxhash.h>\n#include \"xattr.h\"\n\nstruct erofs_xattr_iter {\n\tstruct super_block *sb;\n\tstruct erofs_buf buf;\n\terofs_off_t pos;\n\tvoid *kaddr;\n\n\tchar *buffer;\n\tint buffer_size, buffer_ofs;\n\n\t \n\tint index, infix_len;\n\tstruct qstr name;\n\n\t \n\tstruct dentry *dentry;\n};\n\nstatic int erofs_init_inode_xattrs(struct inode *inode)\n{\n\tstruct erofs_inode *const vi = EROFS_I(inode);\n\tstruct erofs_xattr_iter it;\n\tunsigned int i;\n\tstruct erofs_xattr_ibody_header *ih;\n\tstruct super_block *sb = inode->i_sb;\n\tint ret = 0;\n\n\t \n\tif (test_bit(EROFS_I_EA_INITED_BIT, &vi->flags)) {\n\t\t \n\t\tsmp_mb();\n\t\treturn 0;\n\t}\n\n\tif (wait_on_bit_lock(&vi->flags, EROFS_I_BL_XATTR_BIT, TASK_KILLABLE))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tif (test_bit(EROFS_I_EA_INITED_BIT, &vi->flags))\n\t\tgoto out_unlock;\n\n\t \n\tif (vi->xattr_isize == sizeof(struct erofs_xattr_ibody_header)) {\n\t\terofs_err(sb,\n\t\t\t  \"xattr_isize %d of nid %llu is not supported yet\",\n\t\t\t  vi->xattr_isize, vi->nid);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_unlock;\n\t} else if (vi->xattr_isize < sizeof(struct erofs_xattr_ibody_header)) {\n\t\tif (vi->xattr_isize) {\n\t\t\terofs_err(sb, \"bogus xattr ibody @ nid %llu\", vi->nid);\n\t\t\tDBG_BUGON(1);\n\t\t\tret = -EFSCORRUPTED;\n\t\t\tgoto out_unlock;\t \n\t\t}\n\t\tret = -ENOATTR;\n\t\tgoto out_unlock;\n\t}\n\n\tit.buf = __EROFS_BUF_INITIALIZER;\n\terofs_init_metabuf(&it.buf, sb);\n\tit.pos = erofs_iloc(inode) + vi->inode_isize;\n\n\t \n\tit.kaddr = erofs_bread(&it.buf, erofs_blknr(sb, it.pos), EROFS_KMAP);\n\tif (IS_ERR(it.kaddr)) {\n\t\tret = PTR_ERR(it.kaddr);\n\t\tgoto out_unlock;\n\t}\n\n\tih = it.kaddr + erofs_blkoff(sb, it.pos);\n\tvi->xattr_name_filter = le32_to_cpu(ih->h_name_filter);\n\tvi->xattr_shared_count = ih->h_shared_count;\n\tvi->xattr_shared_xattrs = kmalloc_array(vi->xattr_shared_count,\n\t\t\t\t\t\tsizeof(uint), GFP_KERNEL);\n\tif (!vi->xattr_shared_xattrs) {\n\t\terofs_put_metabuf(&it.buf);\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tit.pos += sizeof(struct erofs_xattr_ibody_header);\n\n\tfor (i = 0; i < vi->xattr_shared_count; ++i) {\n\t\tit.kaddr = erofs_bread(&it.buf, erofs_blknr(sb, it.pos),\n\t\t\t\t       EROFS_KMAP);\n\t\tif (IS_ERR(it.kaddr)) {\n\t\t\tkfree(vi->xattr_shared_xattrs);\n\t\t\tvi->xattr_shared_xattrs = NULL;\n\t\t\tret = PTR_ERR(it.kaddr);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tvi->xattr_shared_xattrs[i] = le32_to_cpu(*(__le32 *)\n\t\t\t\t(it.kaddr + erofs_blkoff(sb, it.pos)));\n\t\tit.pos += sizeof(__le32);\n\t}\n\terofs_put_metabuf(&it.buf);\n\n\t \n\tsmp_mb();\n\tset_bit(EROFS_I_EA_INITED_BIT, &vi->flags);\n\nout_unlock:\n\tclear_and_wake_up_bit(EROFS_I_BL_XATTR_BIT, &vi->flags);\n\treturn ret;\n}\n\nstatic bool erofs_xattr_user_list(struct dentry *dentry)\n{\n\treturn test_opt(&EROFS_SB(dentry->d_sb)->opt, XATTR_USER);\n}\n\nstatic bool erofs_xattr_trusted_list(struct dentry *dentry)\n{\n\treturn capable(CAP_SYS_ADMIN);\n}\n\nstatic int erofs_xattr_generic_get(const struct xattr_handler *handler,\n\t\t\t\t   struct dentry *unused, struct inode *inode,\n\t\t\t\t   const char *name, void *buffer, size_t size)\n{\n\tif (handler->flags == EROFS_XATTR_INDEX_USER &&\n\t    !test_opt(&EROFS_I_SB(inode)->opt, XATTR_USER))\n\t\treturn -EOPNOTSUPP;\n\n\treturn erofs_getxattr(inode, handler->flags, name, buffer, size);\n}\n\nconst struct xattr_handler erofs_xattr_user_handler = {\n\t.prefix\t= XATTR_USER_PREFIX,\n\t.flags\t= EROFS_XATTR_INDEX_USER,\n\t.list\t= erofs_xattr_user_list,\n\t.get\t= erofs_xattr_generic_get,\n};\n\nconst struct xattr_handler erofs_xattr_trusted_handler = {\n\t.prefix\t= XATTR_TRUSTED_PREFIX,\n\t.flags\t= EROFS_XATTR_INDEX_TRUSTED,\n\t.list\t= erofs_xattr_trusted_list,\n\t.get\t= erofs_xattr_generic_get,\n};\n\n#ifdef CONFIG_EROFS_FS_SECURITY\nconst struct xattr_handler __maybe_unused erofs_xattr_security_handler = {\n\t.prefix\t= XATTR_SECURITY_PREFIX,\n\t.flags\t= EROFS_XATTR_INDEX_SECURITY,\n\t.get\t= erofs_xattr_generic_get,\n};\n#endif\n\nconst struct xattr_handler *erofs_xattr_handlers[] = {\n\t&erofs_xattr_user_handler,\n\t&erofs_xattr_trusted_handler,\n#ifdef CONFIG_EROFS_FS_SECURITY\n\t&erofs_xattr_security_handler,\n#endif\n\tNULL,\n};\n\nstatic int erofs_xattr_copy_to_buffer(struct erofs_xattr_iter *it,\n\t\t\t\t      unsigned int len)\n{\n\tunsigned int slice, processed;\n\tstruct super_block *sb = it->sb;\n\tvoid *src;\n\n\tfor (processed = 0; processed < len; processed += slice) {\n\t\tit->kaddr = erofs_bread(&it->buf, erofs_blknr(sb, it->pos),\n\t\t\t\t\tEROFS_KMAP);\n\t\tif (IS_ERR(it->kaddr))\n\t\t\treturn PTR_ERR(it->kaddr);\n\n\t\tsrc = it->kaddr + erofs_blkoff(sb, it->pos);\n\t\tslice = min_t(unsigned int, sb->s_blocksize -\n\t\t\t\terofs_blkoff(sb, it->pos), len - processed);\n\t\tmemcpy(it->buffer + it->buffer_ofs, src, slice);\n\t\tit->buffer_ofs += slice;\n\t\tit->pos += slice;\n\t}\n\treturn 0;\n}\n\nstatic int erofs_listxattr_foreach(struct erofs_xattr_iter *it)\n{\n\tstruct erofs_xattr_entry entry;\n\tunsigned int base_index, name_total, prefix_len, infix_len = 0;\n\tconst char *prefix, *infix = NULL;\n\tint err;\n\n\t \n\tentry = *(struct erofs_xattr_entry *)\n\t\t\t(it->kaddr + erofs_blkoff(it->sb, it->pos));\n\tit->pos += sizeof(struct erofs_xattr_entry);\n\n\tbase_index = entry.e_name_index;\n\tif (entry.e_name_index & EROFS_XATTR_LONG_PREFIX) {\n\t\tstruct erofs_sb_info *sbi = EROFS_SB(it->sb);\n\t\tstruct erofs_xattr_prefix_item *pf = sbi->xattr_prefixes +\n\t\t\t(entry.e_name_index & EROFS_XATTR_LONG_PREFIX_MASK);\n\n\t\tif (pf >= sbi->xattr_prefixes + sbi->xattr_prefix_count)\n\t\t\treturn 0;\n\t\tinfix = pf->prefix->infix;\n\t\tinfix_len = pf->infix_len;\n\t\tbase_index = pf->prefix->base_index;\n\t}\n\n\tprefix = erofs_xattr_prefix(base_index, it->dentry);\n\tif (!prefix)\n\t\treturn 0;\n\tprefix_len = strlen(prefix);\n\tname_total = prefix_len + infix_len + entry.e_name_len + 1;\n\n\tif (!it->buffer) {\n\t\tit->buffer_ofs += name_total;\n\t\treturn 0;\n\t}\n\n\tif (it->buffer_ofs + name_total > it->buffer_size)\n\t\treturn -ERANGE;\n\n\tmemcpy(it->buffer + it->buffer_ofs, prefix, prefix_len);\n\tmemcpy(it->buffer + it->buffer_ofs + prefix_len, infix, infix_len);\n\tit->buffer_ofs += prefix_len + infix_len;\n\n\t \n\terr = erofs_xattr_copy_to_buffer(it, entry.e_name_len);\n\tif (err)\n\t\treturn err;\n\n\tit->buffer[it->buffer_ofs++] = '\\0';\n\treturn 0;\n}\n\nstatic int erofs_getxattr_foreach(struct erofs_xattr_iter *it)\n{\n\tstruct super_block *sb = it->sb;\n\tstruct erofs_xattr_entry entry;\n\tunsigned int slice, processed, value_sz;\n\n\t \n\tentry = *(struct erofs_xattr_entry *)\n\t\t\t(it->kaddr + erofs_blkoff(sb, it->pos));\n\tit->pos += sizeof(struct erofs_xattr_entry);\n\tvalue_sz = le16_to_cpu(entry.e_value_size);\n\n\t \n\tif (entry.e_name_index & EROFS_XATTR_LONG_PREFIX) {\n\t\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\t\tstruct erofs_xattr_prefix_item *pf = sbi->xattr_prefixes +\n\t\t\t(entry.e_name_index & EROFS_XATTR_LONG_PREFIX_MASK);\n\n\t\tif (pf >= sbi->xattr_prefixes + sbi->xattr_prefix_count)\n\t\t\treturn -ENOATTR;\n\n\t\tif (it->index != pf->prefix->base_index ||\n\t\t    it->name.len != entry.e_name_len + pf->infix_len)\n\t\t\treturn -ENOATTR;\n\n\t\tif (memcmp(it->name.name, pf->prefix->infix, pf->infix_len))\n\t\t\treturn -ENOATTR;\n\n\t\tit->infix_len = pf->infix_len;\n\t} else {\n\t\tif (it->index != entry.e_name_index ||\n\t\t    it->name.len != entry.e_name_len)\n\t\t\treturn -ENOATTR;\n\n\t\tit->infix_len = 0;\n\t}\n\n\t \n\tfor (processed = 0; processed < entry.e_name_len; processed += slice) {\n\t\tit->kaddr = erofs_bread(&it->buf, erofs_blknr(sb, it->pos),\n\t\t\t\t\tEROFS_KMAP);\n\t\tif (IS_ERR(it->kaddr))\n\t\t\treturn PTR_ERR(it->kaddr);\n\n\t\tslice = min_t(unsigned int,\n\t\t\t\tsb->s_blocksize - erofs_blkoff(sb, it->pos),\n\t\t\t\tentry.e_name_len - processed);\n\t\tif (memcmp(it->name.name + it->infix_len + processed,\n\t\t\t   it->kaddr + erofs_blkoff(sb, it->pos), slice))\n\t\t\treturn -ENOATTR;\n\t\tit->pos += slice;\n\t}\n\n\t \n\tif (!it->buffer) {\n\t\tit->buffer_ofs = value_sz;\n\t\treturn 0;\n\t}\n\n\tif (it->buffer_size < value_sz)\n\t\treturn -ERANGE;\n\n\treturn erofs_xattr_copy_to_buffer(it, value_sz);\n}\n\nstatic int erofs_xattr_iter_inline(struct erofs_xattr_iter *it,\n\t\t\t\t   struct inode *inode, bool getxattr)\n{\n\tstruct erofs_inode *const vi = EROFS_I(inode);\n\tunsigned int xattr_header_sz, remaining, entry_sz;\n\terofs_off_t next_pos;\n\tint ret;\n\n\txattr_header_sz = sizeof(struct erofs_xattr_ibody_header) +\n\t\t\t  sizeof(u32) * vi->xattr_shared_count;\n\tif (xattr_header_sz >= vi->xattr_isize) {\n\t\tDBG_BUGON(xattr_header_sz > vi->xattr_isize);\n\t\treturn -ENOATTR;\n\t}\n\n\tremaining = vi->xattr_isize - xattr_header_sz;\n\tit->pos = erofs_iloc(inode) + vi->inode_isize + xattr_header_sz;\n\n\twhile (remaining) {\n\t\tit->kaddr = erofs_bread(&it->buf, erofs_blknr(it->sb, it->pos),\n\t\t\t\t\tEROFS_KMAP);\n\t\tif (IS_ERR(it->kaddr))\n\t\t\treturn PTR_ERR(it->kaddr);\n\n\t\tentry_sz = erofs_xattr_entry_size(it->kaddr +\n\t\t\t\terofs_blkoff(it->sb, it->pos));\n\t\t \n\t\tif (remaining < entry_sz) {\n\t\t\tDBG_BUGON(1);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tremaining -= entry_sz;\n\t\tnext_pos = it->pos + entry_sz;\n\n\t\tif (getxattr)\n\t\t\tret = erofs_getxattr_foreach(it);\n\t\telse\n\t\t\tret = erofs_listxattr_foreach(it);\n\t\tif ((getxattr && ret != -ENOATTR) || (!getxattr && ret))\n\t\t\tbreak;\n\n\t\tit->pos = next_pos;\n\t}\n\treturn ret;\n}\n\nstatic int erofs_xattr_iter_shared(struct erofs_xattr_iter *it,\n\t\t\t\t   struct inode *inode, bool getxattr)\n{\n\tstruct erofs_inode *const vi = EROFS_I(inode);\n\tstruct super_block *const sb = it->sb;\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\tunsigned int i;\n\tint ret = -ENOATTR;\n\n\tfor (i = 0; i < vi->xattr_shared_count; ++i) {\n\t\tit->pos = erofs_pos(sb, sbi->xattr_blkaddr) +\n\t\t\t\tvi->xattr_shared_xattrs[i] * sizeof(__le32);\n\t\tit->kaddr = erofs_bread(&it->buf, erofs_blknr(sb, it->pos),\n\t\t\t\t\tEROFS_KMAP);\n\t\tif (IS_ERR(it->kaddr))\n\t\t\treturn PTR_ERR(it->kaddr);\n\n\t\tif (getxattr)\n\t\t\tret = erofs_getxattr_foreach(it);\n\t\telse\n\t\t\tret = erofs_listxattr_foreach(it);\n\t\tif ((getxattr && ret != -ENOATTR) || (!getxattr && ret))\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nint erofs_getxattr(struct inode *inode, int index, const char *name,\n\t\t   void *buffer, size_t buffer_size)\n{\n\tint ret;\n\tunsigned int hashbit;\n\tstruct erofs_xattr_iter it;\n\tstruct erofs_inode *vi = EROFS_I(inode);\n\tstruct erofs_sb_info *sbi = EROFS_SB(inode->i_sb);\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tret = erofs_init_inode_xattrs(inode);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (erofs_sb_has_xattr_filter(sbi) && !sbi->xattr_filter_reserved) {\n\t\thashbit = xxh32(name, strlen(name),\n\t\t\t\tEROFS_XATTR_FILTER_SEED + index);\n\t\thashbit &= EROFS_XATTR_FILTER_BITS - 1;\n\t\tif (vi->xattr_name_filter & (1U << hashbit))\n\t\t\treturn -ENOATTR;\n\t}\n\n\tit.index = index;\n\tit.name = (struct qstr)QSTR_INIT(name, strlen(name));\n\tif (it.name.len > EROFS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tit.sb = inode->i_sb;\n\tit.buf = __EROFS_BUF_INITIALIZER;\n\terofs_init_metabuf(&it.buf, it.sb);\n\tit.buffer = buffer;\n\tit.buffer_size = buffer_size;\n\tit.buffer_ofs = 0;\n\n\tret = erofs_xattr_iter_inline(&it, inode, true);\n\tif (ret == -ENOATTR)\n\t\tret = erofs_xattr_iter_shared(&it, inode, true);\n\terofs_put_metabuf(&it.buf);\n\treturn ret ? ret : it.buffer_ofs;\n}\n\nssize_t erofs_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tint ret;\n\tstruct erofs_xattr_iter it;\n\tstruct inode *inode = d_inode(dentry);\n\n\tret = erofs_init_inode_xattrs(inode);\n\tif (ret == -ENOATTR)\n\t\treturn 0;\n\tif (ret)\n\t\treturn ret;\n\n\tit.sb = dentry->d_sb;\n\tit.buf = __EROFS_BUF_INITIALIZER;\n\terofs_init_metabuf(&it.buf, it.sb);\n\tit.dentry = dentry;\n\tit.buffer = buffer;\n\tit.buffer_size = buffer_size;\n\tit.buffer_ofs = 0;\n\n\tret = erofs_xattr_iter_inline(&it, inode, false);\n\tif (!ret || ret == -ENOATTR)\n\t\tret = erofs_xattr_iter_shared(&it, inode, false);\n\tif (ret == -ENOATTR)\n\t\tret = 0;\n\terofs_put_metabuf(&it.buf);\n\treturn ret ? ret : it.buffer_ofs;\n}\n\nvoid erofs_xattr_prefixes_cleanup(struct super_block *sb)\n{\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\tint i;\n\n\tif (sbi->xattr_prefixes) {\n\t\tfor (i = 0; i < sbi->xattr_prefix_count; i++)\n\t\t\tkfree(sbi->xattr_prefixes[i].prefix);\n\t\tkfree(sbi->xattr_prefixes);\n\t\tsbi->xattr_prefixes = NULL;\n\t}\n}\n\nint erofs_xattr_prefixes_init(struct super_block *sb)\n{\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\tstruct erofs_buf buf = __EROFS_BUF_INITIALIZER;\n\terofs_off_t pos = (erofs_off_t)sbi->xattr_prefix_start << 2;\n\tstruct erofs_xattr_prefix_item *pfs;\n\tint ret = 0, i, len;\n\n\tif (!sbi->xattr_prefix_count)\n\t\treturn 0;\n\n\tpfs = kzalloc(sbi->xattr_prefix_count * sizeof(*pfs), GFP_KERNEL);\n\tif (!pfs)\n\t\treturn -ENOMEM;\n\n\tif (sbi->packed_inode)\n\t\tbuf.inode = sbi->packed_inode;\n\telse\n\t\terofs_init_metabuf(&buf, sb);\n\n\tfor (i = 0; i < sbi->xattr_prefix_count; i++) {\n\t\tvoid *ptr = erofs_read_metadata(sb, &buf, &pos, &len);\n\n\t\tif (IS_ERR(ptr)) {\n\t\t\tret = PTR_ERR(ptr);\n\t\t\tbreak;\n\t\t} else if (len < sizeof(*pfs->prefix) ||\n\t\t\t   len > EROFS_NAME_LEN + sizeof(*pfs->prefix)) {\n\t\t\tkfree(ptr);\n\t\t\tret = -EFSCORRUPTED;\n\t\t\tbreak;\n\t\t}\n\t\tpfs[i].prefix = ptr;\n\t\tpfs[i].infix_len = len - sizeof(struct erofs_xattr_long_prefix);\n\t}\n\n\terofs_put_metabuf(&buf);\n\tsbi->xattr_prefixes = pfs;\n\tif (ret)\n\t\terofs_xattr_prefixes_cleanup(sb);\n\treturn ret;\n}\n\n#ifdef CONFIG_EROFS_FS_POSIX_ACL\nstruct posix_acl *erofs_get_acl(struct inode *inode, int type, bool rcu)\n{\n\tstruct posix_acl *acl;\n\tint prefix, rc;\n\tchar *value = NULL;\n\n\tif (rcu)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tprefix = EROFS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tprefix = EROFS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\trc = erofs_getxattr(inode, prefix, \"\", NULL, 0);\n\tif (rc > 0) {\n\t\tvalue = kmalloc(rc, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\trc = erofs_getxattr(inode, prefix, \"\", value, rc);\n\t}\n\n\tif (rc == -ENOATTR)\n\t\tacl = NULL;\n\telse if (rc < 0)\n\t\tacl = ERR_PTR(rc);\n\telse\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, rc);\n\tkfree(value);\n\treturn acl;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}