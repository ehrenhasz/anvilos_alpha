{
  "module_name": "erofs_fs.h",
  "hash_id": "c0a786c764cf6ffa3b24a0769ac46a674ede7135d8ab68cc02cf90096a266d8a",
  "original_prompt": "Ingested from linux-6.6.14/fs/erofs/erofs_fs.h",
  "human_readable_source": " \n \n#ifndef __EROFS_FS_H\n#define __EROFS_FS_H\n\n#define EROFS_SUPER_OFFSET      1024\n\n#define EROFS_FEATURE_COMPAT_SB_CHKSUM          0x00000001\n#define EROFS_FEATURE_COMPAT_MTIME              0x00000002\n#define EROFS_FEATURE_COMPAT_XATTR_FILTER\t0x00000004\n\n \n#define EROFS_FEATURE_INCOMPAT_ZERO_PADDING\t0x00000001\n#define EROFS_FEATURE_INCOMPAT_COMPR_CFGS\t0x00000002\n#define EROFS_FEATURE_INCOMPAT_BIG_PCLUSTER\t0x00000002\n#define EROFS_FEATURE_INCOMPAT_CHUNKED_FILE\t0x00000004\n#define EROFS_FEATURE_INCOMPAT_DEVICE_TABLE\t0x00000008\n#define EROFS_FEATURE_INCOMPAT_COMPR_HEAD2\t0x00000008\n#define EROFS_FEATURE_INCOMPAT_ZTAILPACKING\t0x00000010\n#define EROFS_FEATURE_INCOMPAT_FRAGMENTS\t0x00000020\n#define EROFS_FEATURE_INCOMPAT_DEDUPE\t\t0x00000020\n#define EROFS_FEATURE_INCOMPAT_XATTR_PREFIXES\t0x00000040\n#define EROFS_ALL_FEATURE_INCOMPAT\t\t\\\n\t(EROFS_FEATURE_INCOMPAT_ZERO_PADDING | \\\n\t EROFS_FEATURE_INCOMPAT_COMPR_CFGS | \\\n\t EROFS_FEATURE_INCOMPAT_BIG_PCLUSTER | \\\n\t EROFS_FEATURE_INCOMPAT_CHUNKED_FILE | \\\n\t EROFS_FEATURE_INCOMPAT_DEVICE_TABLE | \\\n\t EROFS_FEATURE_INCOMPAT_COMPR_HEAD2 | \\\n\t EROFS_FEATURE_INCOMPAT_ZTAILPACKING | \\\n\t EROFS_FEATURE_INCOMPAT_FRAGMENTS | \\\n\t EROFS_FEATURE_INCOMPAT_DEDUPE | \\\n\t EROFS_FEATURE_INCOMPAT_XATTR_PREFIXES)\n\n#define EROFS_SB_EXTSLOT_SIZE\t16\n\nstruct erofs_deviceslot {\n\tu8 tag[64];\t\t \n\t__le32 blocks;\t\t \n\t__le32 mapped_blkaddr;\t \n\tu8 reserved[56];\n};\n#define EROFS_DEVT_SLOT_SIZE\tsizeof(struct erofs_deviceslot)\n\n \nstruct erofs_super_block {\n\t__le32 magic;            \n\t__le32 checksum;         \n\t__le32 feature_compat;\n\t__u8 blkszbits;          \n\t__u8 sb_extslots;\t \n\n\t__le16 root_nid;\t \n\t__le64 inos;             \n\n\t__le64 build_time;       \n\t__le32 build_time_nsec;\t \n\t__le32 blocks;           \n\t__le32 meta_blkaddr;\t \n\t__le32 xattr_blkaddr;\t \n\t__u8 uuid[16];           \n\t__u8 volume_name[16];    \n\t__le32 feature_incompat;\n\tunion {\n\t\t \n\t\t__le16 available_compr_algs;\n\t\t \n\t\t__le16 lz4_max_distance;\n\t} __packed u1;\n\t__le16 extra_devices;\t \n\t__le16 devt_slotoff;\t \n\t__u8 dirblkbits;\t \n\t__u8 xattr_prefix_count;\t \n\t__le32 xattr_prefix_start;\t \n\t__le64 packed_nid;\t \n\t__u8 xattr_filter_reserved;  \n\t__u8 reserved2[23];\n};\n\n \nenum {\n\tEROFS_INODE_FLAT_PLAIN\t\t\t= 0,\n\tEROFS_INODE_COMPRESSED_FULL\t\t= 1,\n\tEROFS_INODE_FLAT_INLINE\t\t\t= 2,\n\tEROFS_INODE_COMPRESSED_COMPACT\t\t= 3,\n\tEROFS_INODE_CHUNK_BASED\t\t\t= 4,\n\tEROFS_INODE_DATALAYOUT_MAX\n};\n\nstatic inline bool erofs_inode_is_data_compressed(unsigned int datamode)\n{\n\treturn datamode == EROFS_INODE_COMPRESSED_COMPACT ||\n\t\tdatamode == EROFS_INODE_COMPRESSED_FULL;\n}\n\n \n#define EROFS_I_VERSION_MASK            0x01\n#define EROFS_I_DATALAYOUT_MASK         0x07\n\n#define EROFS_I_VERSION_BIT             0\n#define EROFS_I_DATALAYOUT_BIT          1\n#define EROFS_I_ALL_BIT\t\t\t4\n\n#define EROFS_I_ALL\t((1 << EROFS_I_ALL_BIT) - 1)\n\n \n#define EROFS_CHUNK_FORMAT_BLKBITS_MASK\t\t0x001F\n \n#define EROFS_CHUNK_FORMAT_INDEXES\t\t0x0020\n\n#define EROFS_CHUNK_FORMAT_ALL\t\\\n\t(EROFS_CHUNK_FORMAT_BLKBITS_MASK | EROFS_CHUNK_FORMAT_INDEXES)\n\n \n#define EROFS_INODE_LAYOUT_COMPACT\t0\n \n#define EROFS_INODE_LAYOUT_EXTENDED\t1\n\nstruct erofs_inode_chunk_info {\n\t__le16 format;\t\t \n\t__le16 reserved;\n};\n\nunion erofs_inode_i_u {\n\t \n\t__le32 compressed_blocks;\n\n\t \n\t__le32 raw_blkaddr;\n\n\t \n\t__le32 rdev;\n\n\t \n\tstruct erofs_inode_chunk_info c;\n};\n\n \nstruct erofs_inode_compact {\n\t__le16 i_format;\t \n\n \n\t__le16 i_xattr_icount;\n\t__le16 i_mode;\n\t__le16 i_nlink;\n\t__le32 i_size;\n\t__le32 i_reserved;\n\tunion erofs_inode_i_u i_u;\n\n\t__le32 i_ino;\t\t \n\t__le16 i_uid;\n\t__le16 i_gid;\n\t__le32 i_reserved2;\n};\n\n \nstruct erofs_inode_extended {\n\t__le16 i_format;\t \n\n \n\t__le16 i_xattr_icount;\n\t__le16 i_mode;\n\t__le16 i_reserved;\n\t__le64 i_size;\n\tunion erofs_inode_i_u i_u;\n\n\t__le32 i_ino;\t\t \n\t__le32 i_uid;\n\t__le32 i_gid;\n\t__le64 i_mtime;\n\t__le32 i_mtime_nsec;\n\t__le32 i_nlink;\n\t__u8   i_reserved2[16];\n};\n\n \nstruct erofs_xattr_ibody_header {\n\t__le32 h_name_filter;\t\t \n\t__u8   h_shared_count;\n\t__u8   h_reserved2[7];\n\t__le32 h_shared_xattrs[];        \n};\n\n \n#define EROFS_XATTR_INDEX_USER              1\n#define EROFS_XATTR_INDEX_POSIX_ACL_ACCESS  2\n#define EROFS_XATTR_INDEX_POSIX_ACL_DEFAULT 3\n#define EROFS_XATTR_INDEX_TRUSTED           4\n#define EROFS_XATTR_INDEX_LUSTRE            5\n#define EROFS_XATTR_INDEX_SECURITY          6\n\n \n#define EROFS_XATTR_LONG_PREFIX\t\t0x80\n#define EROFS_XATTR_LONG_PREFIX_MASK\t0x7f\n\n#define EROFS_XATTR_FILTER_BITS\t\t32\n#define EROFS_XATTR_FILTER_DEFAULT\tUINT32_MAX\n#define EROFS_XATTR_FILTER_SEED\t\t0x25BBE08F\n\n \nstruct erofs_xattr_entry {\n\t__u8   e_name_len;       \n\t__u8   e_name_index;     \n\t__le16 e_value_size;     \n\t \n\tchar   e_name[];         \n};\n\n \nstruct erofs_xattr_long_prefix {\n\t__u8   base_index;\t \n\tchar   infix[];\t\t \n};\n\nstatic inline unsigned int erofs_xattr_ibody_size(__le16 i_xattr_icount)\n{\n\tif (!i_xattr_icount)\n\t\treturn 0;\n\n\treturn sizeof(struct erofs_xattr_ibody_header) +\n\t\tsizeof(__u32) * (le16_to_cpu(i_xattr_icount) - 1);\n}\n\n#define EROFS_XATTR_ALIGN(size) round_up(size, sizeof(struct erofs_xattr_entry))\n\nstatic inline unsigned int erofs_xattr_entry_size(struct erofs_xattr_entry *e)\n{\n\treturn EROFS_XATTR_ALIGN(sizeof(struct erofs_xattr_entry) +\n\t\t\t\t e->e_name_len + le16_to_cpu(e->e_value_size));\n}\n\n \n#define EROFS_NULL_ADDR\t\t\t-1\n\n \n#define EROFS_BLOCK_MAP_ENTRY_SIZE\tsizeof(__le32)\n\n \nstruct erofs_inode_chunk_index {\n\t__le16 advise;\t\t \n\t__le16 device_id;\t \n\t__le32 blkaddr;\t\t \n};\n\n \nstruct erofs_dirent {\n\t__le64 nid;      \n\t__le16 nameoff;  \n\t__u8 file_type;  \n\t__u8 reserved;   \n} __packed;\n\n \n\n#define EROFS_NAME_LEN      255\n\n \n#define Z_EROFS_PCLUSTER_MAX_SIZE\t(1024 * 1024)\n\n \nenum {\n\tZ_EROFS_COMPRESSION_LZ4\t\t= 0,\n\tZ_EROFS_COMPRESSION_LZMA\t= 1,\n\tZ_EROFS_COMPRESSION_DEFLATE\t= 2,\n\tZ_EROFS_COMPRESSION_MAX\n};\n#define Z_EROFS_ALL_COMPR_ALGS\t\t((1 << Z_EROFS_COMPRESSION_MAX) - 1)\n\n \nstruct z_erofs_lz4_cfgs {\n\t__le16 max_distance;\n\t__le16 max_pclusterblks;\n\tu8 reserved[10];\n} __packed;\n\n \nstruct z_erofs_lzma_cfgs {\n\t__le32 dict_size;\n\t__le16 format;\n\tu8 reserved[8];\n} __packed;\n\n#define Z_EROFS_LZMA_MAX_DICT_SIZE\t(8 * Z_EROFS_PCLUSTER_MAX_SIZE)\n\n \nstruct z_erofs_deflate_cfgs {\n\tu8 windowbits;\t\t\t \n\tu8 reserved[5];\n} __packed;\n\n \n#define Z_EROFS_ADVISE_COMPACTED_2B\t\t0x0001\n#define Z_EROFS_ADVISE_BIG_PCLUSTER_1\t\t0x0002\n#define Z_EROFS_ADVISE_BIG_PCLUSTER_2\t\t0x0004\n#define Z_EROFS_ADVISE_INLINE_PCLUSTER\t\t0x0008\n#define Z_EROFS_ADVISE_INTERLACED_PCLUSTER\t0x0010\n#define Z_EROFS_ADVISE_FRAGMENT_PCLUSTER\t0x0020\n\n#define Z_EROFS_FRAGMENT_INODE_BIT              7\nstruct z_erofs_map_header {\n\tunion {\n\t\t \n\t\t__le32  h_fragmentoff;\n\t\tstruct {\n\t\t\t__le16  h_reserved1;\n\t\t\t \n\t\t\t__le16  h_idata_size;\n\t\t};\n\t};\n\t__le16\th_advise;\n\t \n\t__u8\th_algorithmtype;\n\t \n\t__u8\th_clusterbits;\n};\n\n \nenum {\n\tZ_EROFS_LCLUSTER_TYPE_PLAIN\t= 0,\n\tZ_EROFS_LCLUSTER_TYPE_HEAD1\t= 1,\n\tZ_EROFS_LCLUSTER_TYPE_NONHEAD\t= 2,\n\tZ_EROFS_LCLUSTER_TYPE_HEAD2\t= 3,\n\tZ_EROFS_LCLUSTER_TYPE_MAX\n};\n\n#define Z_EROFS_LI_LCLUSTER_TYPE_BITS        2\n#define Z_EROFS_LI_LCLUSTER_TYPE_BIT         0\n\n \n#define Z_EROFS_LI_PARTIAL_REF\t\t(1 << 15)\n\n \n#define Z_EROFS_LI_D0_CBLKCNT\t\t(1 << 11)\n\nstruct z_erofs_lcluster_index {\n\t__le16 di_advise;\n\t \n\t__le16 di_clusterofs;\n\n\tunion {\n\t\t \n\t\t__le32 blkaddr;\n\t\t \n\t\t__le16 delta[2];\n\t} di_u;\n};\n\n#define Z_EROFS_FULL_INDEX_ALIGN(end)\t\\\n\t(ALIGN(end, 8) + sizeof(struct z_erofs_map_header) + 8)\n\n \nstatic inline void erofs_check_ondisk_layout_definitions(void)\n{\n\tconst __le64 fmh = *(__le64 *)&(struct z_erofs_map_header) {\n\t\t.h_clusterbits = 1 << Z_EROFS_FRAGMENT_INODE_BIT\n\t};\n\n\tBUILD_BUG_ON(sizeof(struct erofs_super_block) != 128);\n\tBUILD_BUG_ON(sizeof(struct erofs_inode_compact) != 32);\n\tBUILD_BUG_ON(sizeof(struct erofs_inode_extended) != 64);\n\tBUILD_BUG_ON(sizeof(struct erofs_xattr_ibody_header) != 12);\n\tBUILD_BUG_ON(sizeof(struct erofs_xattr_entry) != 4);\n\tBUILD_BUG_ON(sizeof(struct erofs_inode_chunk_info) != 4);\n\tBUILD_BUG_ON(sizeof(struct erofs_inode_chunk_index) != 8);\n\tBUILD_BUG_ON(sizeof(struct z_erofs_map_header) != 8);\n\tBUILD_BUG_ON(sizeof(struct z_erofs_lcluster_index) != 8);\n\tBUILD_BUG_ON(sizeof(struct erofs_dirent) != 12);\n\t \n\tBUILD_BUG_ON(sizeof(struct erofs_inode_chunk_index) !=\n\t\t     sizeof(struct z_erofs_lcluster_index));\n\tBUILD_BUG_ON(sizeof(struct erofs_deviceslot) != 128);\n\n\tBUILD_BUG_ON(BIT(Z_EROFS_LI_LCLUSTER_TYPE_BITS) <\n\t\t     Z_EROFS_LCLUSTER_TYPE_MAX - 1);\n\t \n\tBUILD_BUG_ON(__builtin_constant_p(fmh) ?\n\t\t     fmh != cpu_to_le64(1ULL << 63) : 0);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}