{
  "module_name": "dir.c",
  "hash_id": "5909e31b62d40eacee49163bf1d40e56fe16fae6b03f177c377f3d877a84ff44",
  "original_prompt": "Ingested from linux-6.6.14/fs/erofs/dir.c",
  "human_readable_source": "\n \n#include \"internal.h\"\n\nstatic int erofs_fill_dentries(struct inode *dir, struct dir_context *ctx,\n\t\t\t       void *dentry_blk, struct erofs_dirent *de,\n\t\t\t       unsigned int nameoff, unsigned int maxsize)\n{\n\tconst struct erofs_dirent *end = dentry_blk + nameoff;\n\n\twhile (de < end) {\n\t\tconst char *de_name;\n\t\tunsigned int de_namelen;\n\t\tunsigned char d_type;\n\n\t\td_type = fs_ftype_to_dtype(de->file_type);\n\n\t\tnameoff = le16_to_cpu(de->nameoff);\n\t\tde_name = (char *)dentry_blk + nameoff;\n\n\t\t \n\t\tif (de + 1 >= end)\n\t\t\tde_namelen = strnlen(de_name, maxsize - nameoff);\n\t\telse\n\t\t\tde_namelen = le16_to_cpu(de[1].nameoff) - nameoff;\n\n\t\t \n\t\tif (nameoff + de_namelen > maxsize ||\n\t\t    de_namelen > EROFS_NAME_LEN) {\n\t\t\terofs_err(dir->i_sb, \"bogus dirent @ nid %llu\",\n\t\t\t\t  EROFS_I(dir)->nid);\n\t\t\tDBG_BUGON(1);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tif (!dir_emit(ctx, de_name, de_namelen,\n\t\t\t      le64_to_cpu(de->nid), d_type))\n\t\t\treturn 1;\n\t\t++de;\n\t\tctx->pos += sizeof(struct erofs_dirent);\n\t}\n\treturn 0;\n}\n\nstatic int erofs_readdir(struct file *f, struct dir_context *ctx)\n{\n\tstruct inode *dir = file_inode(f);\n\tstruct erofs_buf buf = __EROFS_BUF_INITIALIZER;\n\tstruct super_block *sb = dir->i_sb;\n\tunsigned long bsz = sb->s_blocksize;\n\tconst size_t dirsize = i_size_read(dir);\n\tunsigned int i = erofs_blknr(sb, ctx->pos);\n\tunsigned int ofs = erofs_blkoff(sb, ctx->pos);\n\tint err = 0;\n\tbool initial = true;\n\n\tbuf.inode = dir;\n\twhile (ctx->pos < dirsize) {\n\t\tstruct erofs_dirent *de;\n\t\tunsigned int nameoff, maxsize;\n\n\t\tde = erofs_bread(&buf, i, EROFS_KMAP);\n\t\tif (IS_ERR(de)) {\n\t\t\terofs_err(sb, \"fail to readdir of logical block %u of nid %llu\",\n\t\t\t\t  i, EROFS_I(dir)->nid);\n\t\t\terr = PTR_ERR(de);\n\t\t\tbreak;\n\t\t}\n\n\t\tnameoff = le16_to_cpu(de->nameoff);\n\t\tif (nameoff < sizeof(struct erofs_dirent) || nameoff >= bsz) {\n\t\t\terofs_err(sb, \"invalid de[0].nameoff %u @ nid %llu\",\n\t\t\t\t  nameoff, EROFS_I(dir)->nid);\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tmaxsize = min_t(unsigned int, dirsize - ctx->pos + ofs, bsz);\n\n\t\t \n\t\tif (initial) {\n\t\t\tinitial = false;\n\n\t\t\tofs = roundup(ofs, sizeof(struct erofs_dirent));\n\t\t\tctx->pos = erofs_pos(sb, i) + ofs;\n\t\t\tif (ofs >= nameoff)\n\t\t\t\tgoto skip_this;\n\t\t}\n\n\t\terr = erofs_fill_dentries(dir, ctx, de, (void *)de + ofs,\n\t\t\t\t\t  nameoff, maxsize);\n\t\tif (err)\n\t\t\tbreak;\nskip_this:\n\t\tctx->pos = erofs_pos(sb, i) + maxsize;\n\t\t++i;\n\t\tofs = 0;\n\t}\n\terofs_put_metabuf(&buf);\n\treturn err < 0 ? err : 0;\n}\n\nconst struct file_operations erofs_dir_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= erofs_readdir,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}