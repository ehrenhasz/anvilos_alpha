{
  "module_name": "utils.c",
  "hash_id": "8fe16255bdbe92981300c2cec2ee52668f95fbc1ea42ec6386719bc9bdc44cfc",
  "original_prompt": "Ingested from linux-6.6.14/fs/erofs/utils.c",
  "human_readable_source": "\n \n#include \"internal.h\"\n\nstruct page *erofs_allocpage(struct page **pagepool, gfp_t gfp)\n{\n\tstruct page *page = *pagepool;\n\n\tif (page) {\n\t\tDBG_BUGON(page_ref_count(page) != 1);\n\t\t*pagepool = (struct page *)page_private(page);\n\t} else {\n\t\tpage = alloc_page(gfp);\n\t}\n\treturn page;\n}\n\nvoid erofs_release_pages(struct page **pagepool)\n{\n\twhile (*pagepool) {\n\t\tstruct page *page = *pagepool;\n\n\t\t*pagepool = (struct page *)page_private(page);\n\t\tput_page(page);\n\t}\n}\n\n#ifdef CONFIG_EROFS_FS_ZIP\n \nstatic atomic_long_t erofs_global_shrink_cnt;\n\nstatic bool erofs_workgroup_get(struct erofs_workgroup *grp)\n{\n\tif (lockref_get_not_zero(&grp->lockref))\n\t\treturn true;\n\n\tspin_lock(&grp->lockref.lock);\n\tif (__lockref_is_dead(&grp->lockref)) {\n\t\tspin_unlock(&grp->lockref.lock);\n\t\treturn false;\n\t}\n\n\tif (!grp->lockref.count++)\n\t\tatomic_long_dec(&erofs_global_shrink_cnt);\n\tspin_unlock(&grp->lockref.lock);\n\treturn true;\n}\n\nstruct erofs_workgroup *erofs_find_workgroup(struct super_block *sb,\n\t\t\t\t\t     pgoff_t index)\n{\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\tstruct erofs_workgroup *grp;\n\nrepeat:\n\trcu_read_lock();\n\tgrp = xa_load(&sbi->managed_pslots, index);\n\tif (grp) {\n\t\tif (!erofs_workgroup_get(grp)) {\n\t\t\t \n\t\t\trcu_read_unlock();\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tDBG_BUGON(index != grp->index);\n\t}\n\trcu_read_unlock();\n\treturn grp;\n}\n\nstruct erofs_workgroup *erofs_insert_workgroup(struct super_block *sb,\n\t\t\t\t\t       struct erofs_workgroup *grp)\n{\n\tstruct erofs_sb_info *const sbi = EROFS_SB(sb);\n\tstruct erofs_workgroup *pre;\n\n\tDBG_BUGON(grp->lockref.count < 1);\nrepeat:\n\txa_lock(&sbi->managed_pslots);\n\tpre = __xa_cmpxchg(&sbi->managed_pslots, grp->index,\n\t\t\t   NULL, grp, GFP_NOFS);\n\tif (pre) {\n\t\tif (xa_is_err(pre)) {\n\t\t\tpre = ERR_PTR(xa_err(pre));\n\t\t} else if (!erofs_workgroup_get(pre)) {\n\t\t\t \n\t\t\txa_unlock(&sbi->managed_pslots);\n\t\t\tcond_resched();\n\t\t\tgoto repeat;\n\t\t}\n\t\tgrp = pre;\n\t}\n\txa_unlock(&sbi->managed_pslots);\n\treturn grp;\n}\n\nstatic void  __erofs_workgroup_free(struct erofs_workgroup *grp)\n{\n\tatomic_long_dec(&erofs_global_shrink_cnt);\n\terofs_workgroup_free_rcu(grp);\n}\n\nvoid erofs_workgroup_put(struct erofs_workgroup *grp)\n{\n\tif (lockref_put_or_lock(&grp->lockref))\n\t\treturn;\n\n\tDBG_BUGON(__lockref_is_dead(&grp->lockref));\n\tif (grp->lockref.count == 1)\n\t\tatomic_long_inc(&erofs_global_shrink_cnt);\n\t--grp->lockref.count;\n\tspin_unlock(&grp->lockref.lock);\n}\n\nstatic bool erofs_try_to_release_workgroup(struct erofs_sb_info *sbi,\n\t\t\t\t\t   struct erofs_workgroup *grp)\n{\n\tint free = false;\n\n\tspin_lock(&grp->lockref.lock);\n\tif (grp->lockref.count)\n\t\tgoto out;\n\n\t \n\tif (erofs_try_to_free_all_cached_pages(sbi, grp))\n\t\tgoto out;\n\n\t \n\tDBG_BUGON(__xa_erase(&sbi->managed_pslots, grp->index) != grp);\n\n\tlockref_mark_dead(&grp->lockref);\n\tfree = true;\nout:\n\tspin_unlock(&grp->lockref.lock);\n\tif (free)\n\t\t__erofs_workgroup_free(grp);\n\treturn free;\n}\n\nstatic unsigned long erofs_shrink_workstation(struct erofs_sb_info *sbi,\n\t\t\t\t\t      unsigned long nr_shrink)\n{\n\tstruct erofs_workgroup *grp;\n\tunsigned int freed = 0;\n\tunsigned long index;\n\n\txa_lock(&sbi->managed_pslots);\n\txa_for_each(&sbi->managed_pslots, index, grp) {\n\t\t \n\t\tif (!erofs_try_to_release_workgroup(sbi, grp))\n\t\t\tcontinue;\n\t\txa_unlock(&sbi->managed_pslots);\n\n\t\t++freed;\n\t\tif (!--nr_shrink)\n\t\t\treturn freed;\n\t\txa_lock(&sbi->managed_pslots);\n\t}\n\txa_unlock(&sbi->managed_pslots);\n\treturn freed;\n}\n\n \nstatic unsigned int shrinker_run_no;\n\n \nstatic DEFINE_SPINLOCK(erofs_sb_list_lock);\nstatic LIST_HEAD(erofs_sb_list);\n\nvoid erofs_shrinker_register(struct super_block *sb)\n{\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\n\tmutex_init(&sbi->umount_mutex);\n\n\tspin_lock(&erofs_sb_list_lock);\n\tlist_add(&sbi->list, &erofs_sb_list);\n\tspin_unlock(&erofs_sb_list_lock);\n}\n\nvoid erofs_shrinker_unregister(struct super_block *sb)\n{\n\tstruct erofs_sb_info *const sbi = EROFS_SB(sb);\n\n\tmutex_lock(&sbi->umount_mutex);\n\t \n\terofs_shrink_workstation(sbi, ~0UL);\n\n\tspin_lock(&erofs_sb_list_lock);\n\tlist_del(&sbi->list);\n\tspin_unlock(&erofs_sb_list_lock);\n\tmutex_unlock(&sbi->umount_mutex);\n}\n\nstatic unsigned long erofs_shrink_count(struct shrinker *shrink,\n\t\t\t\t\tstruct shrink_control *sc)\n{\n\treturn atomic_long_read(&erofs_global_shrink_cnt);\n}\n\nstatic unsigned long erofs_shrink_scan(struct shrinker *shrink,\n\t\t\t\t       struct shrink_control *sc)\n{\n\tstruct erofs_sb_info *sbi;\n\tstruct list_head *p;\n\n\tunsigned long nr = sc->nr_to_scan;\n\tunsigned int run_no;\n\tunsigned long freed = 0;\n\n\tspin_lock(&erofs_sb_list_lock);\n\tdo {\n\t\trun_no = ++shrinker_run_no;\n\t} while (run_no == 0);\n\n\t \n\tp = erofs_sb_list.next;\n\twhile (p != &erofs_sb_list) {\n\t\tsbi = list_entry(p, struct erofs_sb_info, list);\n\n\t\t \n\t\tif (sbi->shrinker_run_no == run_no)\n\t\t\tbreak;\n\n\t\tif (!mutex_trylock(&sbi->umount_mutex)) {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_unlock(&erofs_sb_list_lock);\n\t\tsbi->shrinker_run_no = run_no;\n\n\t\tfreed += erofs_shrink_workstation(sbi, nr - freed);\n\n\t\tspin_lock(&erofs_sb_list_lock);\n\t\t \n\t\tp = p->next;\n\n\t\t \n\t\tlist_move_tail(&sbi->list, &erofs_sb_list);\n\t\tmutex_unlock(&sbi->umount_mutex);\n\n\t\tif (freed >= nr)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&erofs_sb_list_lock);\n\treturn freed;\n}\n\nstatic struct shrinker erofs_shrinker_info = {\n\t.scan_objects = erofs_shrink_scan,\n\t.count_objects = erofs_shrink_count,\n\t.seeks = DEFAULT_SEEKS,\n};\n\nint __init erofs_init_shrinker(void)\n{\n\treturn register_shrinker(&erofs_shrinker_info, \"erofs-shrinker\");\n}\n\nvoid erofs_exit_shrinker(void)\n{\n\tunregister_shrinker(&erofs_shrinker_info);\n}\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}