{
  "module_name": "namei.c",
  "hash_id": "8c1ae70ae479e8cf994579133f445cd04b7b64c60f2ba198b0334c7686659d99",
  "original_prompt": "Ingested from linux-6.6.14/fs/erofs/namei.c",
  "human_readable_source": "\n \n#include \"xattr.h\"\n#include <trace/events/erofs.h>\n\nstruct erofs_qstr {\n\tconst unsigned char *name;\n\tconst unsigned char *end;\n};\n\n \nstatic inline int erofs_dirnamecmp(const struct erofs_qstr *qn,\n\t\t\t\t   const struct erofs_qstr *qd,\n\t\t\t\t   unsigned int *matched)\n{\n\tunsigned int i = *matched;\n\n\t \n\tDBG_BUGON(qd->name > qd->end);\n\n\t \n\t \n\twhile (qd->name + i < qd->end && qd->name[i] != '\\0') {\n\t\tif (qn->name[i] != qd->name[i]) {\n\t\t\t*matched = i;\n\t\t\treturn qn->name[i] > qd->name[i] ? 1 : -1;\n\t\t}\n\t\t++i;\n\t}\n\t*matched = i;\n\t \n\treturn qn->name[i] == '\\0' ? 0 : 1;\n}\n\n#define nameoff_from_disk(off, sz)\t(le16_to_cpu(off) & ((sz) - 1))\n\nstatic struct erofs_dirent *find_target_dirent(struct erofs_qstr *name,\n\t\t\t\t\t       u8 *data,\n\t\t\t\t\t       unsigned int dirblksize,\n\t\t\t\t\t       const int ndirents)\n{\n\tint head, back;\n\tunsigned int startprfx, endprfx;\n\tstruct erofs_dirent *const de = (struct erofs_dirent *)data;\n\n\t \n\thead = 1;\n\tback = ndirents - 1;\n\tstartprfx = endprfx = 0;\n\n\twhile (head <= back) {\n\t\tconst int mid = head + (back - head) / 2;\n\t\tconst int nameoff = nameoff_from_disk(de[mid].nameoff,\n\t\t\t\t\t\t      dirblksize);\n\t\tunsigned int matched = min(startprfx, endprfx);\n\t\tstruct erofs_qstr dname = {\n\t\t\t.name = data + nameoff,\n\t\t\t.end = mid >= ndirents - 1 ?\n\t\t\t\tdata + dirblksize :\n\t\t\t\tdata + nameoff_from_disk(de[mid + 1].nameoff,\n\t\t\t\t\t\t\t dirblksize)\n\t\t};\n\n\t\t \n\t\tint ret = erofs_dirnamecmp(name, &dname, &matched);\n\n\t\tif (!ret) {\n\t\t\treturn de + mid;\n\t\t} else if (ret > 0) {\n\t\t\thead = mid + 1;\n\t\t\tstartprfx = matched;\n\t\t} else {\n\t\t\tback = mid - 1;\n\t\t\tendprfx = matched;\n\t\t}\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic void *erofs_find_target_block(struct erofs_buf *target,\n\t\tstruct inode *dir, struct erofs_qstr *name, int *_ndirents)\n{\n\tunsigned int bsz = i_blocksize(dir);\n\tint head = 0, back = erofs_iblks(dir) - 1;\n\tunsigned int startprfx = 0, endprfx = 0;\n\tvoid *candidate = ERR_PTR(-ENOENT);\n\n\twhile (head <= back) {\n\t\tconst int mid = head + (back - head) / 2;\n\t\tstruct erofs_buf buf = __EROFS_BUF_INITIALIZER;\n\t\tstruct erofs_dirent *de;\n\n\t\tbuf.inode = dir;\n\t\tde = erofs_bread(&buf, mid, EROFS_KMAP);\n\t\tif (!IS_ERR(de)) {\n\t\t\tconst int nameoff = nameoff_from_disk(de->nameoff, bsz);\n\t\t\tconst int ndirents = nameoff / sizeof(*de);\n\t\t\tint diff;\n\t\t\tunsigned int matched;\n\t\t\tstruct erofs_qstr dname;\n\n\t\t\tif (!ndirents) {\n\t\t\t\terofs_put_metabuf(&buf);\n\t\t\t\terofs_err(dir->i_sb,\n\t\t\t\t\t  \"corrupted dir block %d @ nid %llu\",\n\t\t\t\t\t  mid, EROFS_I(dir)->nid);\n\t\t\t\tDBG_BUGON(1);\n\t\t\t\tde = ERR_PTR(-EFSCORRUPTED);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmatched = min(startprfx, endprfx);\n\n\t\t\tdname.name = (u8 *)de + nameoff;\n\t\t\tif (ndirents == 1)\n\t\t\t\tdname.end = (u8 *)de + bsz;\n\t\t\telse\n\t\t\t\tdname.end = (u8 *)de +\n\t\t\t\t\tnameoff_from_disk(de[1].nameoff, bsz);\n\n\t\t\t \n\t\t\tdiff = erofs_dirnamecmp(name, &dname, &matched);\n\n\t\t\tif (!diff) {\n\t\t\t\t*_ndirents = 0;\n\t\t\t\tgoto out;\n\t\t\t} else if (diff > 0) {\n\t\t\t\thead = mid + 1;\n\t\t\t\tstartprfx = matched;\n\n\t\t\t\tif (!IS_ERR(candidate))\n\t\t\t\t\terofs_put_metabuf(target);\n\t\t\t\t*target = buf;\n\t\t\t\tcandidate = de;\n\t\t\t\t*_ndirents = ndirents;\n\t\t\t} else {\n\t\t\t\terofs_put_metabuf(&buf);\n\n\t\t\t\tback = mid - 1;\n\t\t\t\tendprfx = matched;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\nout:\t\t \n\t\tif (!IS_ERR(candidate))\n\t\t\terofs_put_metabuf(target);\n\t\treturn de;\n\t}\n\treturn candidate;\n}\n\nint erofs_namei(struct inode *dir, const struct qstr *name, erofs_nid_t *nid,\n\t\tunsigned int *d_type)\n{\n\tint ndirents;\n\tstruct erofs_buf buf = __EROFS_BUF_INITIALIZER;\n\tstruct erofs_dirent *de;\n\tstruct erofs_qstr qn;\n\n\tif (!dir->i_size)\n\t\treturn -ENOENT;\n\n\tqn.name = name->name;\n\tqn.end = name->name + name->len;\n\tbuf.inode = dir;\n\n\tndirents = 0;\n\tde = erofs_find_target_block(&buf, dir, &qn, &ndirents);\n\tif (IS_ERR(de))\n\t\treturn PTR_ERR(de);\n\n\tif (ndirents)\n\t\tde = find_target_dirent(&qn, (u8 *)de, i_blocksize(dir),\n\t\t\t\t\tndirents);\n\n\tif (!IS_ERR(de)) {\n\t\t*nid = le64_to_cpu(de->nid);\n\t\t*d_type = de->file_type;\n\t}\n\terofs_put_metabuf(&buf);\n\treturn PTR_ERR_OR_ZERO(de);\n}\n\nstatic struct dentry *erofs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t   unsigned int flags)\n{\n\tint err;\n\terofs_nid_t nid;\n\tunsigned int d_type;\n\tstruct inode *inode;\n\n\ttrace_erofs_lookup(dir, dentry, flags);\n\n\tif (dentry->d_name.len > EROFS_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\terr = erofs_namei(dir, &dentry->d_name, &nid, &d_type);\n\n\tif (err == -ENOENT)\n\t\t \n\t\tinode = NULL;\n\telse if (err)\n\t\tinode = ERR_PTR(err);\n\telse\n\t\tinode = erofs_iget(dir->i_sb, nid);\n\treturn d_splice_alias(inode, dentry);\n}\n\nconst struct inode_operations erofs_dir_iops = {\n\t.lookup = erofs_lookup,\n\t.getattr = erofs_getattr,\n\t.listxattr = erofs_listxattr,\n\t.get_inode_acl = erofs_get_acl,\n\t.fiemap = erofs_fiemap,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}