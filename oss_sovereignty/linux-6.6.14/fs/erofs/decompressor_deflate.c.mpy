{
  "module_name": "decompressor_deflate.c",
  "hash_id": "fe331ea10cc6475319d37835068a51ff84b4e621a1fce544105c1f9ac4cd2598",
  "original_prompt": "Ingested from linux-6.6.14/fs/erofs/decompressor_deflate.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/zlib.h>\n#include \"compress.h\"\n\nstruct z_erofs_deflate {\n\tstruct z_erofs_deflate *next;\n\tstruct z_stream_s z;\n\tu8 bounce[PAGE_SIZE];\n};\n\nstatic DEFINE_SPINLOCK(z_erofs_deflate_lock);\nstatic unsigned int z_erofs_deflate_nstrms, z_erofs_deflate_avail_strms;\nstatic struct z_erofs_deflate *z_erofs_deflate_head;\nstatic DECLARE_WAIT_QUEUE_HEAD(z_erofs_deflate_wq);\n\nmodule_param_named(deflate_streams, z_erofs_deflate_nstrms, uint, 0444);\n\nvoid z_erofs_deflate_exit(void)\n{\n\t \n\twhile (z_erofs_deflate_avail_strms) {\n\t\tstruct z_erofs_deflate *strm;\n\n\t\tspin_lock(&z_erofs_deflate_lock);\n\t\tstrm = z_erofs_deflate_head;\n\t\tif (!strm) {\n\t\t\tspin_unlock(&z_erofs_deflate_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tz_erofs_deflate_head = NULL;\n\t\tspin_unlock(&z_erofs_deflate_lock);\n\n\t\twhile (strm) {\n\t\t\tstruct z_erofs_deflate *n = strm->next;\n\n\t\t\tvfree(strm->z.workspace);\n\t\t\tkfree(strm);\n\t\t\t--z_erofs_deflate_avail_strms;\n\t\t\tstrm = n;\n\t\t}\n\t}\n}\n\nint __init z_erofs_deflate_init(void)\n{\n\t \n\tif (!z_erofs_deflate_nstrms)\n\t\tz_erofs_deflate_nstrms = num_possible_cpus();\n\n\tfor (; z_erofs_deflate_avail_strms < z_erofs_deflate_nstrms;\n\t     ++z_erofs_deflate_avail_strms) {\n\t\tstruct z_erofs_deflate *strm;\n\n\t\tstrm = kzalloc(sizeof(*strm), GFP_KERNEL);\n\t\tif (!strm)\n\t\t\tgoto out_failed;\n\n\t\t \n\t\tstrm->z.workspace = vmalloc(zlib_inflate_workspacesize());\n\t\tif (!strm->z.workspace) {\n\t\t\tkfree(strm);\n\t\t\tgoto out_failed;\n\t\t}\n\n\t\tspin_lock(&z_erofs_deflate_lock);\n\t\tstrm->next = z_erofs_deflate_head;\n\t\tz_erofs_deflate_head = strm;\n\t\tspin_unlock(&z_erofs_deflate_lock);\n\t}\n\treturn 0;\n\nout_failed:\n\tpr_err(\"failed to allocate zlib workspace\\n\");\n\tz_erofs_deflate_exit();\n\treturn -ENOMEM;\n}\n\nint z_erofs_load_deflate_config(struct super_block *sb,\n\t\t\tstruct erofs_super_block *dsb, void *data, int size)\n{\n\tstruct z_erofs_deflate_cfgs *dfl = data;\n\n\tif (!dfl || size < sizeof(struct z_erofs_deflate_cfgs)) {\n\t\terofs_err(sb, \"invalid deflate cfgs, size=%u\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (dfl->windowbits > MAX_WBITS) {\n\t\terofs_err(sb, \"unsupported windowbits %u\", dfl->windowbits);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terofs_info(sb, \"EXPERIMENTAL DEFLATE feature in use. Use at your own risk!\");\n\treturn 0;\n}\n\nint z_erofs_deflate_decompress(struct z_erofs_decompress_req *rq,\n\t\t\t       struct page **pagepool)\n{\n\tconst unsigned int nrpages_out =\n\t\tPAGE_ALIGN(rq->pageofs_out + rq->outputsize) >> PAGE_SHIFT;\n\tconst unsigned int nrpages_in =\n\t\tPAGE_ALIGN(rq->inputsize) >> PAGE_SHIFT;\n\tstruct super_block *sb = rq->sb;\n\tunsigned int insz, outsz, pofs;\n\tstruct z_erofs_deflate *strm;\n\tu8 *kin, *kout = NULL;\n\tbool bounced = false;\n\tint no = -1, ni = 0, j = 0, zerr, err;\n\n\t \n\tkin = kmap_local_page(*rq->in);\n\terr = z_erofs_fixup_insize(rq, kin + rq->pageofs_in,\n\t\t\tmin_t(unsigned int, rq->inputsize,\n\t\t\t      sb->s_blocksize - rq->pageofs_in));\n\tif (err) {\n\t\tkunmap_local(kin);\n\t\treturn err;\n\t}\n\n\t \nagain:\n\tspin_lock(&z_erofs_deflate_lock);\n\tstrm = z_erofs_deflate_head;\n\tif (!strm) {\n\t\tspin_unlock(&z_erofs_deflate_lock);\n\t\twait_event(z_erofs_deflate_wq, READ_ONCE(z_erofs_deflate_head));\n\t\tgoto again;\n\t}\n\tz_erofs_deflate_head = strm->next;\n\tspin_unlock(&z_erofs_deflate_lock);\n\n\t \n\tinsz = rq->inputsize;\n\toutsz = rq->outputsize;\n\tzerr = zlib_inflateInit2(&strm->z, -MAX_WBITS);\n\tif (zerr != Z_OK) {\n\t\terr = -EIO;\n\t\tgoto failed_zinit;\n\t}\n\n\tpofs = rq->pageofs_out;\n\tstrm->z.avail_in = min_t(u32, insz, PAGE_SIZE - rq->pageofs_in);\n\tinsz -= strm->z.avail_in;\n\tstrm->z.next_in = kin + rq->pageofs_in;\n\tstrm->z.avail_out = 0;\n\n\twhile (1) {\n\t\tif (!strm->z.avail_out) {\n\t\t\tif (++no >= nrpages_out || !outsz) {\n\t\t\t\terofs_err(sb, \"insufficient space for decompressed data\");\n\t\t\t\terr = -EFSCORRUPTED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (kout)\n\t\t\t\tkunmap_local(kout);\n\t\t\tstrm->z.avail_out = min_t(u32, outsz, PAGE_SIZE - pofs);\n\t\t\toutsz -= strm->z.avail_out;\n\t\t\tif (!rq->out[no]) {\n\t\t\t\trq->out[no] = erofs_allocpage(pagepool,\n\t\t\t\t\t\tGFP_KERNEL | __GFP_NOFAIL);\n\t\t\t\tset_page_private(rq->out[no],\n\t\t\t\t\t\t Z_EROFS_SHORTLIVED_PAGE);\n\t\t\t}\n\t\t\tkout = kmap_local_page(rq->out[no]);\n\t\t\tstrm->z.next_out = kout + pofs;\n\t\t\tpofs = 0;\n\t\t}\n\n\t\tif (!strm->z.avail_in && insz) {\n\t\t\tif (++ni >= nrpages_in) {\n\t\t\t\terofs_err(sb, \"invalid compressed data\");\n\t\t\t\terr = -EFSCORRUPTED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (kout) {  \n\t\t\t\tj = strm->z.next_out - kout;\n\t\t\t\tkunmap_local(kout);\n\t\t\t}\n\t\t\tkunmap_local(kin);\n\t\t\tstrm->z.avail_in = min_t(u32, insz, PAGE_SIZE);\n\t\t\tinsz -= strm->z.avail_in;\n\t\t\tkin = kmap_local_page(rq->in[ni]);\n\t\t\tstrm->z.next_in = kin;\n\t\t\tbounced = false;\n\t\t\tif (kout) {\n\t\t\t\tkout = kmap_local_page(rq->out[no]);\n\t\t\t\tstrm->z.next_out = kout + j;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!bounced && rq->out[no] == rq->in[ni]) {\n\t\t\tmemcpy(strm->bounce, strm->z.next_in, strm->z.avail_in);\n\t\t\tstrm->z.next_in = strm->bounce;\n\t\t\tbounced = true;\n\t\t}\n\n\t\tfor (j = ni + 1; j < nrpages_in; ++j) {\n\t\t\tstruct page *tmppage;\n\n\t\t\tif (rq->out[no] != rq->in[j])\n\t\t\t\tcontinue;\n\n\t\t\tDBG_BUGON(erofs_page_is_managed(EROFS_SB(sb),\n\t\t\t\t\t\t\trq->in[j]));\n\t\t\ttmppage = erofs_allocpage(pagepool,\n\t\t\t\t\t\t  GFP_KERNEL | __GFP_NOFAIL);\n\t\t\tset_page_private(tmppage, Z_EROFS_SHORTLIVED_PAGE);\n\t\t\tcopy_highpage(tmppage, rq->in[j]);\n\t\t\trq->in[j] = tmppage;\n\t\t}\n\n\t\tzerr = zlib_inflate(&strm->z, Z_SYNC_FLUSH);\n\t\tif (zerr != Z_OK || !(outsz + strm->z.avail_out)) {\n\t\t\tif (zerr == Z_OK && rq->partial_decoding)\n\t\t\t\tbreak;\n\t\t\tif (zerr == Z_STREAM_END && !outsz)\n\t\t\t\tbreak;\n\t\t\terofs_err(sb, \"failed to decompress %d in[%u] out[%u]\",\n\t\t\t\t  zerr, rq->inputsize, rq->outputsize);\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (zlib_inflateEnd(&strm->z) != Z_OK && !err)\n\t\terr = -EIO;\n\tif (kout)\n\t\tkunmap_local(kout);\nfailed_zinit:\n\tkunmap_local(kin);\n\t \n\tspin_lock(&z_erofs_deflate_lock);\n\tstrm->next = z_erofs_deflate_head;\n\tz_erofs_deflate_head = strm;\n\tspin_unlock(&z_erofs_deflate_lock);\n\twake_up(&z_erofs_deflate_wq);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}