{
  "module_name": "fscache.c",
  "hash_id": "0519e3e3f4314532d7ac337043f0f0f8001076d88f15e3669a4dff1021fea8b2",
  "original_prompt": "Ingested from linux-6.6.14/fs/erofs/fscache.c",
  "human_readable_source": "\n \n#include <linux/fscache.h>\n#include \"internal.h\"\n\nstatic DEFINE_MUTEX(erofs_domain_list_lock);\nstatic DEFINE_MUTEX(erofs_domain_cookies_lock);\nstatic LIST_HEAD(erofs_domain_list);\nstatic LIST_HEAD(erofs_domain_cookies_list);\nstatic struct vfsmount *erofs_pseudo_mnt;\n\nstruct erofs_fscache_request {\n\tstruct erofs_fscache_request *primary;\n\tstruct netfs_cache_resources cache_resources;\n\tstruct address_space\t*mapping;\t \n\tloff_t\t\t\tstart;\t\t \n\tsize_t\t\t\tlen;\t\t \n\tsize_t\t\t\tsubmitted;\t \n\tshort\t\t\terror;\t\t \n\trefcount_t\t\tref;\n};\n\nstatic struct erofs_fscache_request *erofs_fscache_req_alloc(struct address_space *mapping,\n\t\t\t\t\t     loff_t start, size_t len)\n{\n\tstruct erofs_fscache_request *req;\n\n\treq = kzalloc(sizeof(struct erofs_fscache_request), GFP_KERNEL);\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treq->mapping = mapping;\n\treq->start   = start;\n\treq->len     = len;\n\trefcount_set(&req->ref, 1);\n\n\treturn req;\n}\n\nstatic struct erofs_fscache_request *erofs_fscache_req_chain(struct erofs_fscache_request *primary,\n\t\t\t\t\t     size_t len)\n{\n\tstruct erofs_fscache_request *req;\n\n\t \n\tif (!primary->submitted) {\n\t\trefcount_inc(&primary->ref);\n\t\treturn primary;\n\t}\n\n\treq = erofs_fscache_req_alloc(primary->mapping,\n\t\t\tprimary->start + primary->submitted, len);\n\tif (!IS_ERR(req)) {\n\t\treq->primary = primary;\n\t\trefcount_inc(&primary->ref);\n\t}\n\treturn req;\n}\n\nstatic void erofs_fscache_req_complete(struct erofs_fscache_request *req)\n{\n\tstruct folio *folio;\n\tbool failed = req->error;\n\tpgoff_t start_page = req->start / PAGE_SIZE;\n\tpgoff_t last_page = ((req->start + req->len) / PAGE_SIZE) - 1;\n\n\tXA_STATE(xas, &req->mapping->i_pages, start_page);\n\n\trcu_read_lock();\n\txas_for_each(&xas, folio, last_page) {\n\t\tif (xas_retry(&xas, folio))\n\t\t\tcontinue;\n\t\tif (!failed)\n\t\t\tfolio_mark_uptodate(folio);\n\t\tfolio_unlock(folio);\n\t}\n\trcu_read_unlock();\n}\n\nstatic void erofs_fscache_req_put(struct erofs_fscache_request *req)\n{\n\tif (refcount_dec_and_test(&req->ref)) {\n\t\tif (req->cache_resources.ops)\n\t\t\treq->cache_resources.ops->end_operation(&req->cache_resources);\n\t\tif (!req->primary)\n\t\t\terofs_fscache_req_complete(req);\n\t\telse\n\t\t\terofs_fscache_req_put(req->primary);\n\t\tkfree(req);\n\t}\n}\n\nstatic void erofs_fscache_subreq_complete(void *priv,\n\t\tssize_t transferred_or_error, bool was_async)\n{\n\tstruct erofs_fscache_request *req = priv;\n\n\tif (IS_ERR_VALUE(transferred_or_error)) {\n\t\tif (req->primary)\n\t\t\treq->primary->error = transferred_or_error;\n\t\telse\n\t\t\treq->error = transferred_or_error;\n\t}\n\terofs_fscache_req_put(req);\n}\n\n \nstatic int erofs_fscache_read_folios_async(struct fscache_cookie *cookie,\n\t\tstruct erofs_fscache_request *req, loff_t pstart, size_t len)\n{\n\tenum netfs_io_source source;\n\tstruct super_block *sb = req->mapping->host->i_sb;\n\tstruct netfs_cache_resources *cres = &req->cache_resources;\n\tstruct iov_iter iter;\n\tloff_t lstart = req->start + req->submitted;\n\tsize_t done = 0;\n\tint ret;\n\n\tDBG_BUGON(len > req->len - req->submitted);\n\n\tret = fscache_begin_read_operation(cres, cookie);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (done < len) {\n\t\tloff_t sstart = pstart + done;\n\t\tsize_t slen = len - done;\n\t\tunsigned long flags = 1 << NETFS_SREQ_ONDEMAND;\n\n\t\tsource = cres->ops->prepare_ondemand_read(cres,\n\t\t\t\tsstart, &slen, LLONG_MAX, &flags, 0);\n\t\tif (WARN_ON(slen == 0))\n\t\t\tsource = NETFS_INVALID_READ;\n\t\tif (source != NETFS_READ_FROM_CACHE) {\n\t\t\terofs_err(sb, \"failed to fscache prepare_read (source %d)\", source);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\trefcount_inc(&req->ref);\n\t\tiov_iter_xarray(&iter, ITER_DEST, &req->mapping->i_pages,\n\t\t\t\tlstart + done, slen);\n\n\t\tret = fscache_read(cres, sstart, &iter, NETFS_READ_HOLE_FAIL,\n\t\t\t\t   erofs_fscache_subreq_complete, req);\n\t\tif (ret == -EIOCBQUEUED)\n\t\t\tret = 0;\n\t\tif (ret) {\n\t\t\terofs_err(sb, \"failed to fscache_read (ret %d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdone += slen;\n\t}\n\tDBG_BUGON(done != len);\n\treturn 0;\n}\n\nstatic int erofs_fscache_meta_read_folio(struct file *data, struct folio *folio)\n{\n\tint ret;\n\tstruct erofs_fscache *ctx = folio_mapping(folio)->host->i_private;\n\tstruct erofs_fscache_request *req;\n\n\treq = erofs_fscache_req_alloc(folio_mapping(folio),\n\t\t\t\tfolio_pos(folio), folio_size(folio));\n\tif (IS_ERR(req)) {\n\t\tfolio_unlock(folio);\n\t\treturn PTR_ERR(req);\n\t}\n\n\tret = erofs_fscache_read_folios_async(ctx->cookie, req,\n\t\t\t\tfolio_pos(folio), folio_size(folio));\n\tif (ret)\n\t\treq->error = ret;\n\n\terofs_fscache_req_put(req);\n\treturn ret;\n}\n\nstatic int erofs_fscache_data_read_slice(struct erofs_fscache_request *primary)\n{\n\tstruct address_space *mapping = primary->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct erofs_fscache_request *req;\n\tstruct erofs_map_blocks map;\n\tstruct erofs_map_dev mdev;\n\tstruct iov_iter iter;\n\tloff_t pos = primary->start + primary->submitted;\n\tsize_t count;\n\tint ret;\n\n\tmap.m_la = pos;\n\tret = erofs_map_blocks(inode, &map);\n\tif (ret)\n\t\treturn ret;\n\n\tif (map.m_flags & EROFS_MAP_META) {\n\t\tstruct erofs_buf buf = __EROFS_BUF_INITIALIZER;\n\t\terofs_blk_t blknr;\n\t\tsize_t offset, size;\n\t\tvoid *src;\n\n\t\t \n\t\toffset = erofs_blkoff(sb, map.m_pa);\n\t\tblknr = erofs_blknr(sb, map.m_pa);\n\t\tsize = map.m_llen;\n\n\t\tsrc = erofs_read_metabuf(&buf, sb, blknr, EROFS_KMAP);\n\t\tif (IS_ERR(src))\n\t\t\treturn PTR_ERR(src);\n\n\t\tiov_iter_xarray(&iter, ITER_DEST, &mapping->i_pages, pos, PAGE_SIZE);\n\t\tif (copy_to_iter(src + offset, size, &iter) != size) {\n\t\t\terofs_put_metabuf(&buf);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tiov_iter_zero(PAGE_SIZE - size, &iter);\n\t\terofs_put_metabuf(&buf);\n\t\tprimary->submitted += PAGE_SIZE;\n\t\treturn 0;\n\t}\n\n\tcount = primary->len - primary->submitted;\n\tif (!(map.m_flags & EROFS_MAP_MAPPED)) {\n\t\tiov_iter_xarray(&iter, ITER_DEST, &mapping->i_pages, pos, count);\n\t\tiov_iter_zero(count, &iter);\n\t\tprimary->submitted += count;\n\t\treturn 0;\n\t}\n\n\tcount = min_t(size_t, map.m_llen - (pos - map.m_la), count);\n\tDBG_BUGON(!count || count % PAGE_SIZE);\n\n\tmdev = (struct erofs_map_dev) {\n\t\t.m_deviceid = map.m_deviceid,\n\t\t.m_pa = map.m_pa,\n\t};\n\tret = erofs_map_dev(sb, &mdev);\n\tif (ret)\n\t\treturn ret;\n\n\treq = erofs_fscache_req_chain(primary, count);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tret = erofs_fscache_read_folios_async(mdev.m_fscache->cookie,\n\t\t\treq, mdev.m_pa + (pos - map.m_la), count);\n\terofs_fscache_req_put(req);\n\tprimary->submitted += count;\n\treturn ret;\n}\n\nstatic int erofs_fscache_data_read(struct erofs_fscache_request *req)\n{\n\tint ret;\n\n\tdo {\n\t\tret = erofs_fscache_data_read_slice(req);\n\t\tif (ret)\n\t\t\treq->error = ret;\n\t} while (!ret && req->submitted < req->len);\n\n\treturn ret;\n}\n\nstatic int erofs_fscache_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct erofs_fscache_request *req;\n\tint ret;\n\n\treq = erofs_fscache_req_alloc(folio_mapping(folio),\n\t\t\tfolio_pos(folio), folio_size(folio));\n\tif (IS_ERR(req)) {\n\t\tfolio_unlock(folio);\n\t\treturn PTR_ERR(req);\n\t}\n\n\tret = erofs_fscache_data_read(req);\n\terofs_fscache_req_put(req);\n\treturn ret;\n}\n\nstatic void erofs_fscache_readahead(struct readahead_control *rac)\n{\n\tstruct erofs_fscache_request *req;\n\n\tif (!readahead_count(rac))\n\t\treturn;\n\n\treq = erofs_fscache_req_alloc(rac->mapping,\n\t\t\treadahead_pos(rac), readahead_length(rac));\n\tif (IS_ERR(req))\n\t\treturn;\n\n\t \n\twhile (readahead_folio(rac))\n\t\t;\n\n\terofs_fscache_data_read(req);\n\terofs_fscache_req_put(req);\n}\n\nstatic const struct address_space_operations erofs_fscache_meta_aops = {\n\t.read_folio = erofs_fscache_meta_read_folio,\n};\n\nconst struct address_space_operations erofs_fscache_access_aops = {\n\t.read_folio = erofs_fscache_read_folio,\n\t.readahead = erofs_fscache_readahead,\n};\n\nstatic void erofs_fscache_domain_put(struct erofs_domain *domain)\n{\n\tmutex_lock(&erofs_domain_list_lock);\n\tif (refcount_dec_and_test(&domain->ref)) {\n\t\tlist_del(&domain->list);\n\t\tif (list_empty(&erofs_domain_list)) {\n\t\t\tkern_unmount(erofs_pseudo_mnt);\n\t\t\terofs_pseudo_mnt = NULL;\n\t\t}\n\t\tfscache_relinquish_volume(domain->volume, NULL, false);\n\t\tmutex_unlock(&erofs_domain_list_lock);\n\t\tkfree(domain->domain_id);\n\t\tkfree(domain);\n\t\treturn;\n\t}\n\tmutex_unlock(&erofs_domain_list_lock);\n}\n\nstatic int erofs_fscache_register_volume(struct super_block *sb)\n{\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\tchar *domain_id = sbi->domain_id;\n\tstruct fscache_volume *volume;\n\tchar *name;\n\tint ret = 0;\n\n\tname = kasprintf(GFP_KERNEL, \"erofs,%s\",\n\t\t\t domain_id ? domain_id : sbi->fsid);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tvolume = fscache_acquire_volume(name, NULL, NULL, 0);\n\tif (IS_ERR_OR_NULL(volume)) {\n\t\terofs_err(sb, \"failed to register volume for %s\", name);\n\t\tret = volume ? PTR_ERR(volume) : -EOPNOTSUPP;\n\t\tvolume = NULL;\n\t}\n\n\tsbi->volume = volume;\n\tkfree(name);\n\treturn ret;\n}\n\nstatic int erofs_fscache_init_domain(struct super_block *sb)\n{\n\tint err;\n\tstruct erofs_domain *domain;\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\n\tdomain = kzalloc(sizeof(struct erofs_domain), GFP_KERNEL);\n\tif (!domain)\n\t\treturn -ENOMEM;\n\n\tdomain->domain_id = kstrdup(sbi->domain_id, GFP_KERNEL);\n\tif (!domain->domain_id) {\n\t\tkfree(domain);\n\t\treturn -ENOMEM;\n\t}\n\n\terr = erofs_fscache_register_volume(sb);\n\tif (err)\n\t\tgoto out;\n\n\tif (!erofs_pseudo_mnt) {\n\t\terofs_pseudo_mnt = kern_mount(&erofs_fs_type);\n\t\tif (IS_ERR(erofs_pseudo_mnt)) {\n\t\t\terr = PTR_ERR(erofs_pseudo_mnt);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdomain->volume = sbi->volume;\n\trefcount_set(&domain->ref, 1);\n\tlist_add(&domain->list, &erofs_domain_list);\n\tsbi->domain = domain;\n\treturn 0;\nout:\n\tkfree(domain->domain_id);\n\tkfree(domain);\n\treturn err;\n}\n\nstatic int erofs_fscache_register_domain(struct super_block *sb)\n{\n\tint err;\n\tstruct erofs_domain *domain;\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\n\tmutex_lock(&erofs_domain_list_lock);\n\tlist_for_each_entry(domain, &erofs_domain_list, list) {\n\t\tif (!strcmp(domain->domain_id, sbi->domain_id)) {\n\t\t\tsbi->domain = domain;\n\t\t\tsbi->volume = domain->volume;\n\t\t\trefcount_inc(&domain->ref);\n\t\t\tmutex_unlock(&erofs_domain_list_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\terr = erofs_fscache_init_domain(sb);\n\tmutex_unlock(&erofs_domain_list_lock);\n\treturn err;\n}\n\nstatic struct erofs_fscache *erofs_fscache_acquire_cookie(struct super_block *sb,\n\t\t\t\t\t\tchar *name, unsigned int flags)\n{\n\tstruct fscache_volume *volume = EROFS_SB(sb)->volume;\n\tstruct erofs_fscache *ctx;\n\tstruct fscache_cookie *cookie;\n\tstruct super_block *isb;\n\tstruct inode *inode;\n\tint ret;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\tINIT_LIST_HEAD(&ctx->node);\n\trefcount_set(&ctx->ref, 1);\n\n\tcookie = fscache_acquire_cookie(volume, FSCACHE_ADV_WANT_CACHE_SIZE,\n\t\t\t\t\tname, strlen(name), NULL, 0, 0);\n\tif (!cookie) {\n\t\terofs_err(sb, \"failed to get cookie for %s\", name);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tfscache_use_cookie(cookie, false);\n\n\t \n\tisb = flags & EROFS_REG_COOKIE_SHARE ? erofs_pseudo_mnt->mnt_sb : sb;\n\tinode = new_inode(isb);\n\tif (!inode) {\n\t\terofs_err(sb, \"failed to get anon inode for %s\", name);\n\t\tret = -ENOMEM;\n\t\tgoto err_cookie;\n\t}\n\n\tinode->i_size = OFFSET_MAX;\n\tinode->i_mapping->a_ops = &erofs_fscache_meta_aops;\n\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\tinode->i_blkbits = EROFS_SB(sb)->blkszbits;\n\tinode->i_private = ctx;\n\n\tctx->cookie = cookie;\n\tctx->inode = inode;\n\treturn ctx;\n\nerr_cookie:\n\tfscache_unuse_cookie(cookie, NULL, NULL);\n\tfscache_relinquish_cookie(cookie, false);\nerr:\n\tkfree(ctx);\n\treturn ERR_PTR(ret);\n}\n\nstatic void erofs_fscache_relinquish_cookie(struct erofs_fscache *ctx)\n{\n\tfscache_unuse_cookie(ctx->cookie, NULL, NULL);\n\tfscache_relinquish_cookie(ctx->cookie, false);\n\tiput(ctx->inode);\n\tkfree(ctx->name);\n\tkfree(ctx);\n}\n\nstatic struct erofs_fscache *erofs_domain_init_cookie(struct super_block *sb,\n\t\t\t\t\t\tchar *name, unsigned int flags)\n{\n\tstruct erofs_fscache *ctx;\n\tstruct erofs_domain *domain = EROFS_SB(sb)->domain;\n\n\tctx = erofs_fscache_acquire_cookie(sb, name, flags);\n\tif (IS_ERR(ctx))\n\t\treturn ctx;\n\n\tctx->name = kstrdup(name, GFP_KERNEL);\n\tif (!ctx->name) {\n\t\terofs_fscache_relinquish_cookie(ctx);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\trefcount_inc(&domain->ref);\n\tctx->domain = domain;\n\tlist_add(&ctx->node, &erofs_domain_cookies_list);\n\treturn ctx;\n}\n\nstatic struct erofs_fscache *erofs_domain_register_cookie(struct super_block *sb,\n\t\t\t\t\t\tchar *name, unsigned int flags)\n{\n\tstruct erofs_fscache *ctx;\n\tstruct erofs_domain *domain = EROFS_SB(sb)->domain;\n\n\tflags |= EROFS_REG_COOKIE_SHARE;\n\tmutex_lock(&erofs_domain_cookies_lock);\n\tlist_for_each_entry(ctx, &erofs_domain_cookies_list, node) {\n\t\tif (ctx->domain != domain || strcmp(ctx->name, name))\n\t\t\tcontinue;\n\t\tif (!(flags & EROFS_REG_COOKIE_NEED_NOEXIST)) {\n\t\t\trefcount_inc(&ctx->ref);\n\t\t} else {\n\t\t\terofs_err(sb, \"%s already exists in domain %s\", name,\n\t\t\t\t  domain->domain_id);\n\t\t\tctx = ERR_PTR(-EEXIST);\n\t\t}\n\t\tmutex_unlock(&erofs_domain_cookies_lock);\n\t\treturn ctx;\n\t}\n\tctx = erofs_domain_init_cookie(sb, name, flags);\n\tmutex_unlock(&erofs_domain_cookies_lock);\n\treturn ctx;\n}\n\nstruct erofs_fscache *erofs_fscache_register_cookie(struct super_block *sb,\n\t\t\t\t\t\t    char *name,\n\t\t\t\t\t\t    unsigned int flags)\n{\n\tif (EROFS_SB(sb)->domain_id)\n\t\treturn erofs_domain_register_cookie(sb, name, flags);\n\treturn erofs_fscache_acquire_cookie(sb, name, flags);\n}\n\nvoid erofs_fscache_unregister_cookie(struct erofs_fscache *ctx)\n{\n\tstruct erofs_domain *domain = NULL;\n\n\tif (!ctx)\n\t\treturn;\n\tif (!ctx->domain)\n\t\treturn erofs_fscache_relinquish_cookie(ctx);\n\n\tmutex_lock(&erofs_domain_cookies_lock);\n\tif (refcount_dec_and_test(&ctx->ref)) {\n\t\tdomain = ctx->domain;\n\t\tlist_del(&ctx->node);\n\t\terofs_fscache_relinquish_cookie(ctx);\n\t}\n\tmutex_unlock(&erofs_domain_cookies_lock);\n\tif (domain)\n\t\terofs_fscache_domain_put(domain);\n}\n\nint erofs_fscache_register_fs(struct super_block *sb)\n{\n\tint ret;\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\tstruct erofs_fscache *fscache;\n\tunsigned int flags = 0;\n\n\tif (sbi->domain_id)\n\t\tret = erofs_fscache_register_domain(sb);\n\telse\n\t\tret = erofs_fscache_register_volume(sb);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (sbi->domain_id)\n\t\tflags |= EROFS_REG_COOKIE_NEED_NOEXIST;\n\tfscache = erofs_fscache_register_cookie(sb, sbi->fsid, flags);\n\tif (IS_ERR(fscache))\n\t\treturn PTR_ERR(fscache);\n\n\tsbi->s_fscache = fscache;\n\treturn 0;\n}\n\nvoid erofs_fscache_unregister_fs(struct super_block *sb)\n{\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\n\terofs_fscache_unregister_cookie(sbi->s_fscache);\n\n\tif (sbi->domain)\n\t\terofs_fscache_domain_put(sbi->domain);\n\telse\n\t\tfscache_relinquish_volume(sbi->volume, NULL, false);\n\n\tsbi->s_fscache = NULL;\n\tsbi->volume = NULL;\n\tsbi->domain = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}