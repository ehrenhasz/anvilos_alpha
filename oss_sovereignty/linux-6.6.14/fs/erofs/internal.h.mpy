{
  "module_name": "internal.h",
  "hash_id": "4acaf641c07c000864e39185054941bc86b1a78668903a52aa365fc56a8dad22",
  "original_prompt": "Ingested from linux-6.6.14/fs/erofs/internal.h",
  "human_readable_source": " \n \n#ifndef __EROFS_INTERNAL_H\n#define __EROFS_INTERNAL_H\n\n#include <linux/fs.h>\n#include <linux/dcache.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/iomap.h>\n#include \"erofs_fs.h\"\n\n \n#undef pr_fmt\n#define pr_fmt(fmt) \"erofs: \" fmt\n\n__printf(3, 4) void _erofs_err(struct super_block *sb,\n\t\t\t       const char *function, const char *fmt, ...);\n#define erofs_err(sb, fmt, ...)\t\\\n\t_erofs_err(sb, __func__, fmt \"\\n\", ##__VA_ARGS__)\n__printf(3, 4) void _erofs_info(struct super_block *sb,\n\t\t\t       const char *function, const char *fmt, ...);\n#define erofs_info(sb, fmt, ...) \\\n\t_erofs_info(sb, __func__, fmt \"\\n\", ##__VA_ARGS__)\n#ifdef CONFIG_EROFS_FS_DEBUG\n#define DBG_BUGON               BUG_ON\n#else\n#define DBG_BUGON(x)            ((void)(x))\n#endif\t \n\n \n#define EROFS_SUPER_MAGIC   EROFS_SUPER_MAGIC_V1\n\ntypedef u64 erofs_nid_t;\ntypedef u64 erofs_off_t;\n \ntypedef u32 erofs_blk_t;\n\nstruct erofs_device_info {\n\tchar *path;\n\tstruct erofs_fscache *fscache;\n\tstruct block_device *bdev;\n\tstruct dax_device *dax_dev;\n\tu64 dax_part_off;\n\n\tu32 blocks;\n\tu32 mapped_blkaddr;\n};\n\nenum {\n\tEROFS_SYNC_DECOMPRESS_AUTO,\n\tEROFS_SYNC_DECOMPRESS_FORCE_ON,\n\tEROFS_SYNC_DECOMPRESS_FORCE_OFF\n};\n\nstruct erofs_mount_opts {\n#ifdef CONFIG_EROFS_FS_ZIP\n\t \n\tunsigned char cache_strategy;\n\t \n\tunsigned int sync_decompress;\n\n\t \n\tunsigned int max_sync_decompress_pages;\n#endif\n\tunsigned int mount_opt;\n};\n\nstruct erofs_dev_context {\n\tstruct idr tree;\n\tstruct rw_semaphore rwsem;\n\n\tunsigned int extra_devices;\n\tbool flatdev;\n};\n\nstruct erofs_fs_context {\n\tstruct erofs_mount_opts opt;\n\tstruct erofs_dev_context *devs;\n\tchar *fsid;\n\tchar *domain_id;\n};\n\n \nstruct erofs_sb_lz4_info {\n\t \n\tu16 max_distance_pages;\n\t \n\tu16 max_pclusterblks;\n};\n\nstruct erofs_domain {\n\trefcount_t ref;\n\tstruct list_head list;\n\tstruct fscache_volume *volume;\n\tchar *domain_id;\n};\n\nstruct erofs_fscache {\n\tstruct fscache_cookie *cookie;\n\tstruct inode *inode;\t \n\n\t \n\tstruct erofs_domain *domain;\n\tstruct list_head node;\n\trefcount_t ref;\n\tchar *name;\n};\n\nstruct erofs_xattr_prefix_item {\n\tstruct erofs_xattr_long_prefix *prefix;\n\tu8 infix_len;\n};\n\nstruct erofs_sb_info {\n\tstruct erofs_mount_opts opt;\t \n#ifdef CONFIG_EROFS_FS_ZIP\n\t \n\tstruct list_head list;\n\tstruct mutex umount_mutex;\n\n\t \n\tstruct xarray managed_pslots;\n\n\tunsigned int shrinker_run_no;\n\tu16 available_compr_algs;\n\n\t \n\tstruct inode *managed_cache;\n\n\tstruct erofs_sb_lz4_info lz4;\n#endif\t \n\tstruct inode *packed_inode;\n\tstruct erofs_dev_context *devs;\n\tstruct dax_device *dax_dev;\n\tu64 dax_part_off;\n\tu64 total_blocks;\n\tu32 primarydevice_blocks;\n\n\tu32 meta_blkaddr;\n#ifdef CONFIG_EROFS_FS_XATTR\n\tu32 xattr_blkaddr;\n\tu32 xattr_prefix_start;\n\tu8 xattr_prefix_count;\n\tstruct erofs_xattr_prefix_item *xattr_prefixes;\n\tunsigned int xattr_filter_reserved;\n#endif\n\tu16 device_id_mask;\t \n\n\tunsigned char islotbits;\t \n\tunsigned char blkszbits;\t \n\n\tu32 sb_size;\t\t\t \n\tu32 build_time_nsec;\n\tu64 build_time;\n\n\t \n\terofs_nid_t root_nid;\n\terofs_nid_t packed_nid;\n\t \n\tu64 inos;\n\n\tu8 uuid[16];                     \n\tu8 volume_name[16];              \n\tu32 feature_compat;\n\tu32 feature_incompat;\n\n\t \n\tstruct kobject s_kobj;\t\t \n\tstruct completion s_kobj_unregister;\n\n\t \n\tstruct fscache_volume *volume;\n\tstruct erofs_fscache *s_fscache;\n\tstruct erofs_domain *domain;\n\tchar *fsid;\n\tchar *domain_id;\n};\n\n#define EROFS_SB(sb) ((struct erofs_sb_info *)(sb)->s_fs_info)\n#define EROFS_I_SB(inode) ((struct erofs_sb_info *)(inode)->i_sb->s_fs_info)\n\n \n#define EROFS_MOUNT_XATTR_USER\t\t0x00000010\n#define EROFS_MOUNT_POSIX_ACL\t\t0x00000020\n#define EROFS_MOUNT_DAX_ALWAYS\t\t0x00000040\n#define EROFS_MOUNT_DAX_NEVER\t\t0x00000080\n\n#define clear_opt(opt, option)\t((opt)->mount_opt &= ~EROFS_MOUNT_##option)\n#define set_opt(opt, option)\t((opt)->mount_opt |= EROFS_MOUNT_##option)\n#define test_opt(opt, option)\t((opt)->mount_opt & EROFS_MOUNT_##option)\n\nstatic inline bool erofs_is_fscache_mode(struct super_block *sb)\n{\n\treturn IS_ENABLED(CONFIG_EROFS_FS_ONDEMAND) && !sb->s_bdev;\n}\n\nenum {\n\tEROFS_ZIP_CACHE_DISABLED,\n\tEROFS_ZIP_CACHE_READAHEAD,\n\tEROFS_ZIP_CACHE_READAROUND\n};\n\n \nstruct erofs_workgroup {\n\tpgoff_t index;\n\tstruct lockref lockref;\n};\n\nenum erofs_kmap_type {\n\tEROFS_NO_KMAP,\t\t \n\tEROFS_KMAP,\t\t \n};\n\nstruct erofs_buf {\n\tstruct inode *inode;\n\tstruct page *page;\n\tvoid *base;\n\tenum erofs_kmap_type kmap_type;\n};\n#define __EROFS_BUF_INITIALIZER\t((struct erofs_buf){ .page = NULL })\n\n#define ROOT_NID(sb)\t\t((sb)->root_nid)\n\n#define erofs_blknr(sb, addr)\t((addr) >> (sb)->s_blocksize_bits)\n#define erofs_blkoff(sb, addr)\t((addr) & ((sb)->s_blocksize - 1))\n#define erofs_pos(sb, blk)\t((erofs_off_t)(blk) << (sb)->s_blocksize_bits)\n#define erofs_iblks(i)\t(round_up((i)->i_size, i_blocksize(i)) >> (i)->i_blkbits)\n\n#define EROFS_FEATURE_FUNCS(name, compat, feature) \\\nstatic inline bool erofs_sb_has_##name(struct erofs_sb_info *sbi) \\\n{ \\\n\treturn sbi->feature_##compat & EROFS_FEATURE_##feature; \\\n}\n\nEROFS_FEATURE_FUNCS(zero_padding, incompat, INCOMPAT_ZERO_PADDING)\nEROFS_FEATURE_FUNCS(compr_cfgs, incompat, INCOMPAT_COMPR_CFGS)\nEROFS_FEATURE_FUNCS(big_pcluster, incompat, INCOMPAT_BIG_PCLUSTER)\nEROFS_FEATURE_FUNCS(chunked_file, incompat, INCOMPAT_CHUNKED_FILE)\nEROFS_FEATURE_FUNCS(device_table, incompat, INCOMPAT_DEVICE_TABLE)\nEROFS_FEATURE_FUNCS(compr_head2, incompat, INCOMPAT_COMPR_HEAD2)\nEROFS_FEATURE_FUNCS(ztailpacking, incompat, INCOMPAT_ZTAILPACKING)\nEROFS_FEATURE_FUNCS(fragments, incompat, INCOMPAT_FRAGMENTS)\nEROFS_FEATURE_FUNCS(dedupe, incompat, INCOMPAT_DEDUPE)\nEROFS_FEATURE_FUNCS(xattr_prefixes, incompat, INCOMPAT_XATTR_PREFIXES)\nEROFS_FEATURE_FUNCS(sb_chksum, compat, COMPAT_SB_CHKSUM)\nEROFS_FEATURE_FUNCS(xattr_filter, compat, COMPAT_XATTR_FILTER)\n\n \n#define EROFS_I_EA_INITED_BIT\t0\n#define EROFS_I_Z_INITED_BIT\t1\n\n \n#define EROFS_I_BL_XATTR_BIT\t(BITS_PER_LONG - 1)\n#define EROFS_I_BL_Z_BIT\t(BITS_PER_LONG - 2)\n\nstruct erofs_inode {\n\terofs_nid_t nid;\n\n\t \n\tunsigned long flags;\n\n\tunsigned char datalayout;\n\tunsigned char inode_isize;\n\tunsigned int xattr_isize;\n\n\tunsigned int xattr_name_filter;\n\tunsigned int xattr_shared_count;\n\tunsigned int *xattr_shared_xattrs;\n\n\tunion {\n\t\terofs_blk_t raw_blkaddr;\n\t\tstruct {\n\t\t\tunsigned short\tchunkformat;\n\t\t\tunsigned char\tchunkbits;\n\t\t};\n#ifdef CONFIG_EROFS_FS_ZIP\n\t\tstruct {\n\t\t\tunsigned short z_advise;\n\t\t\tunsigned char  z_algorithmtype[2];\n\t\t\tunsigned char  z_logical_clusterbits;\n\t\t\tunsigned long  z_tailextent_headlcn;\n\t\t\tunion {\n\t\t\t\tstruct {\n\t\t\t\t\terofs_off_t    z_idataoff;\n\t\t\t\t\tunsigned short z_idata_size;\n\t\t\t\t};\n\t\t\t\terofs_off_t z_fragmentoff;\n\t\t\t};\n\t\t};\n#endif\t \n\t};\n\t \n\tstruct inode vfs_inode;\n};\n\n#define EROFS_I(ptr)\tcontainer_of(ptr, struct erofs_inode, vfs_inode)\n\nstatic inline erofs_off_t erofs_iloc(struct inode *inode)\n{\n\tstruct erofs_sb_info *sbi = EROFS_I_SB(inode);\n\n\treturn erofs_pos(inode->i_sb, sbi->meta_blkaddr) +\n\t\t(EROFS_I(inode)->nid << sbi->islotbits);\n}\n\nstatic inline unsigned int erofs_inode_version(unsigned int ifmt)\n{\n\treturn (ifmt >> EROFS_I_VERSION_BIT) & EROFS_I_VERSION_MASK;\n}\n\nstatic inline unsigned int erofs_inode_datalayout(unsigned int ifmt)\n{\n\treturn (ifmt >> EROFS_I_DATALAYOUT_BIT) & EROFS_I_DATALAYOUT_MASK;\n}\n\n \nstatic inline\nstruct page *erofs_grab_cache_page_nowait(struct address_space *mapping,\n\t\t\t\t\t  pgoff_t index)\n{\n\treturn pagecache_get_page(mapping, index,\n\t\t\tFGP_LOCK|FGP_CREAT|FGP_NOFS|FGP_NOWAIT,\n\t\t\treadahead_gfp_mask(mapping) & ~__GFP_RECLAIM);\n}\n\n \n#define EROFS_MAP_MAPPED\t0x0001\n \n#define EROFS_MAP_META\t\t0x0002\n \n#define EROFS_MAP_ENCODED\t0x0004\n \n#define EROFS_MAP_FULL_MAPPED\t0x0008\n \n#define EROFS_MAP_FRAGMENT\t0x0010\n \n#define EROFS_MAP_PARTIAL_REF\t0x0020\n\nstruct erofs_map_blocks {\n\tstruct erofs_buf buf;\n\n\terofs_off_t m_pa, m_la;\n\tu64 m_plen, m_llen;\n\n\tunsigned short m_deviceid;\n\tchar m_algorithmformat;\n\tunsigned int m_flags;\n};\n\n \n#define EROFS_GET_BLOCKS_FIEMAP\t\t0x0001\n \n#define EROFS_GET_BLOCKS_READMORE\t0x0002\n \n#define EROFS_GET_BLOCKS_FINDTAIL\t0x0004\n\nenum {\n\tZ_EROFS_COMPRESSION_SHIFTED = Z_EROFS_COMPRESSION_MAX,\n\tZ_EROFS_COMPRESSION_INTERLACED,\n\tZ_EROFS_COMPRESSION_RUNTIME_MAX\n};\n\nstruct erofs_map_dev {\n\tstruct erofs_fscache *m_fscache;\n\tstruct block_device *m_bdev;\n\tstruct dax_device *m_daxdev;\n\tu64 m_dax_part_off;\n\n\terofs_off_t m_pa;\n\tunsigned int m_deviceid;\n};\n\nextern struct file_system_type erofs_fs_type;\nextern const struct super_operations erofs_sops;\n\nextern const struct address_space_operations erofs_raw_access_aops;\nextern const struct address_space_operations z_erofs_aops;\nextern const struct address_space_operations erofs_fscache_access_aops;\n\nextern const struct inode_operations erofs_generic_iops;\nextern const struct inode_operations erofs_symlink_iops;\nextern const struct inode_operations erofs_fast_symlink_iops;\nextern const struct inode_operations erofs_dir_iops;\n\nextern const struct file_operations erofs_file_fops;\nextern const struct file_operations erofs_dir_fops;\n\nextern const struct iomap_ops z_erofs_iomap_report_ops;\n\n \n#define EROFS_REG_COOKIE_SHARE\t\t0x0001\n#define EROFS_REG_COOKIE_NEED_NOEXIST\t0x0002\n\nvoid *erofs_read_metadata(struct super_block *sb, struct erofs_buf *buf,\n\t\t\t  erofs_off_t *offset, int *lengthp);\nvoid erofs_unmap_metabuf(struct erofs_buf *buf);\nvoid erofs_put_metabuf(struct erofs_buf *buf);\nvoid *erofs_bread(struct erofs_buf *buf, erofs_blk_t blkaddr,\n\t\t  enum erofs_kmap_type type);\nvoid erofs_init_metabuf(struct erofs_buf *buf, struct super_block *sb);\nvoid *erofs_read_metabuf(struct erofs_buf *buf, struct super_block *sb,\n\t\t\t erofs_blk_t blkaddr, enum erofs_kmap_type type);\nint erofs_map_dev(struct super_block *sb, struct erofs_map_dev *dev);\nint erofs_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t u64 start, u64 len);\nint erofs_map_blocks(struct inode *inode, struct erofs_map_blocks *map);\nstruct inode *erofs_iget(struct super_block *sb, erofs_nid_t nid);\nint erofs_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t  struct kstat *stat, u32 request_mask,\n\t\t  unsigned int query_flags);\nint erofs_namei(struct inode *dir, const struct qstr *name,\n\t\terofs_nid_t *nid, unsigned int *d_type);\n\nstatic inline void *erofs_vm_map_ram(struct page **pages, unsigned int count)\n{\n\tint retried = 0;\n\n\twhile (1) {\n\t\tvoid *p = vm_map_ram(pages, count, -1);\n\n\t\t \n\t\tif (p || ++retried >= 3)\n\t\t\treturn p;\n\t\tvm_unmap_aliases();\n\t}\n\treturn NULL;\n}\n\nint erofs_register_sysfs(struct super_block *sb);\nvoid erofs_unregister_sysfs(struct super_block *sb);\nint __init erofs_init_sysfs(void);\nvoid erofs_exit_sysfs(void);\n\nstruct page *erofs_allocpage(struct page **pagepool, gfp_t gfp);\nstatic inline void erofs_pagepool_add(struct page **pagepool, struct page *page)\n{\n\tset_page_private(page, (unsigned long)*pagepool);\n\t*pagepool = page;\n}\nvoid erofs_release_pages(struct page **pagepool);\n\n#ifdef CONFIG_EROFS_FS_ZIP\nvoid erofs_workgroup_put(struct erofs_workgroup *grp);\nstruct erofs_workgroup *erofs_find_workgroup(struct super_block *sb,\n\t\t\t\t\t     pgoff_t index);\nstruct erofs_workgroup *erofs_insert_workgroup(struct super_block *sb,\n\t\t\t\t\t       struct erofs_workgroup *grp);\nvoid erofs_workgroup_free_rcu(struct erofs_workgroup *grp);\nvoid erofs_shrinker_register(struct super_block *sb);\nvoid erofs_shrinker_unregister(struct super_block *sb);\nint __init erofs_init_shrinker(void);\nvoid erofs_exit_shrinker(void);\nint __init z_erofs_init_zip_subsystem(void);\nvoid z_erofs_exit_zip_subsystem(void);\nint erofs_try_to_free_all_cached_pages(struct erofs_sb_info *sbi,\n\t\t\t\t       struct erofs_workgroup *egrp);\nint z_erofs_map_blocks_iter(struct inode *inode, struct erofs_map_blocks *map,\n\t\t\t    int flags);\nvoid *erofs_get_pcpubuf(unsigned int requiredpages);\nvoid erofs_put_pcpubuf(void *ptr);\nint erofs_pcpubuf_growsize(unsigned int nrpages);\nvoid __init erofs_pcpubuf_init(void);\nvoid erofs_pcpubuf_exit(void);\nint erofs_init_managed_cache(struct super_block *sb);\nint z_erofs_parse_cfgs(struct super_block *sb, struct erofs_super_block *dsb);\n#else\nstatic inline void erofs_shrinker_register(struct super_block *sb) {}\nstatic inline void erofs_shrinker_unregister(struct super_block *sb) {}\nstatic inline int erofs_init_shrinker(void) { return 0; }\nstatic inline void erofs_exit_shrinker(void) {}\nstatic inline int z_erofs_init_zip_subsystem(void) { return 0; }\nstatic inline void z_erofs_exit_zip_subsystem(void) {}\nstatic inline void erofs_pcpubuf_init(void) {}\nstatic inline void erofs_pcpubuf_exit(void) {}\nstatic inline int erofs_init_managed_cache(struct super_block *sb) { return 0; }\n#endif\t \n\n#ifdef CONFIG_EROFS_FS_ZIP_LZMA\nint __init z_erofs_lzma_init(void);\nvoid z_erofs_lzma_exit(void);\n#else\nstatic inline int z_erofs_lzma_init(void) { return 0; }\nstatic inline int z_erofs_lzma_exit(void) { return 0; }\n#endif\t \n\n#ifdef CONFIG_EROFS_FS_ZIP_DEFLATE\nint __init z_erofs_deflate_init(void);\nvoid z_erofs_deflate_exit(void);\n#else\nstatic inline int z_erofs_deflate_init(void) { return 0; }\nstatic inline int z_erofs_deflate_exit(void) { return 0; }\n#endif\t \n\n#ifdef CONFIG_EROFS_FS_ONDEMAND\nint erofs_fscache_register_fs(struct super_block *sb);\nvoid erofs_fscache_unregister_fs(struct super_block *sb);\n\nstruct erofs_fscache *erofs_fscache_register_cookie(struct super_block *sb,\n\t\t\t\t\tchar *name, unsigned int flags);\nvoid erofs_fscache_unregister_cookie(struct erofs_fscache *fscache);\n#else\nstatic inline int erofs_fscache_register_fs(struct super_block *sb)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline void erofs_fscache_unregister_fs(struct super_block *sb) {}\n\nstatic inline\nstruct erofs_fscache *erofs_fscache_register_cookie(struct super_block *sb,\n\t\t\t\t\tchar *name, unsigned int flags)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}\n\nstatic inline void erofs_fscache_unregister_cookie(struct erofs_fscache *fscache)\n{\n}\n#endif\n\n#define EFSCORRUPTED    EUCLEAN          \n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}