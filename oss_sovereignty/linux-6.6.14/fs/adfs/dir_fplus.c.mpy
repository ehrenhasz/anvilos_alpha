{
  "module_name": "dir_fplus.c",
  "hash_id": "743e6c01927118c823bcfbd649c79ba69c81022871c78ce0ce1c890eec694ac9",
  "original_prompt": "Ingested from linux-6.6.14/fs/adfs/dir_fplus.c",
  "human_readable_source": "\n \n#include \"adfs.h\"\n#include \"dir_fplus.h\"\n\n \nstatic unsigned int adfs_fplus_offset(const struct adfs_bigdirheader *h,\n\t\t\t\t      unsigned int pos)\n{\n\treturn offsetof(struct adfs_bigdirheader, bigdirname) +\n\t       ALIGN(le32_to_cpu(h->bigdirnamelen), 4) +\n\t       pos * sizeof(struct adfs_bigdirentry);\n}\n\nstatic int adfs_fplus_validate_header(const struct adfs_bigdirheader *h)\n{\n\tunsigned int size = le32_to_cpu(h->bigdirsize);\n\tunsigned int len;\n\n\tif (h->bigdirversion[0] != 0 || h->bigdirversion[1] != 0 ||\n\t    h->bigdirversion[2] != 0 ||\n\t    h->bigdirstartname != cpu_to_le32(BIGDIRSTARTNAME) ||\n\t    !size || size & 2047 || size > SZ_4M)\n\t\treturn -EIO;\n\n\tsize -= sizeof(struct adfs_bigdirtail) +\n\t\toffsetof(struct adfs_bigdirheader, bigdirname);\n\n\t \n\tlen = ALIGN(le32_to_cpu(h->bigdirnamelen), 4);\n\tif (len > size)\n\t\treturn -EIO;\n\n\tsize -= len;\n\n\t \n\tlen = le32_to_cpu(h->bigdirnamesize);\n\tif (len > size)\n\t\treturn -EIO;\n\n\tsize -= len;\n\n\t \n\tlen = le32_to_cpu(h->bigdirentries);\n\tif (len > SZ_4M / sizeof(struct adfs_bigdirentry) ||\n\t    len * sizeof(struct adfs_bigdirentry) > size)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int adfs_fplus_validate_tail(const struct adfs_bigdirheader *h,\n\t\t\t\t    const struct adfs_bigdirtail *t)\n{\n\tif (t->bigdirendname != cpu_to_le32(BIGDIRENDNAME) ||\n\t    t->bigdirendmasseq != h->startmasseq ||\n\t    t->reserved[0] != 0 || t->reserved[1] != 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic u8 adfs_fplus_checkbyte(struct adfs_dir *dir)\n{\n\tstruct adfs_bigdirheader *h = dir->bighead;\n\tstruct adfs_bigdirtail *t = dir->bigtail;\n\tunsigned int end, bs, bi, i;\n\t__le32 *bp;\n\tu32 dircheck;\n\n\tend = adfs_fplus_offset(h, le32_to_cpu(h->bigdirentries)) +\n\t\tle32_to_cpu(h->bigdirnamesize);\n\n\t \n\tfor (dircheck = 0, bi = 0; end; bi++) {\n\t\tbp = (void *)dir->bhs[bi]->b_data;\n\t\tbs = dir->bhs[bi]->b_size;\n\t\tif (bs > end)\n\t\t\tbs = end;\n\n\t\tfor (i = 0; i < bs; i += sizeof(u32))\n\t\t\tdircheck = ror32(dircheck, 13) ^ le32_to_cpup(bp++);\n\n\t\tend -= bs;\n\t}\n\n\t \n\tdircheck = ror32(dircheck, 13) ^ le32_to_cpu(t->bigdirendname);\n\tdircheck = ror32(dircheck, 13) ^ t->bigdirendmasseq;\n\tdircheck = ror32(dircheck, 13) ^ t->reserved[0];\n\tdircheck = ror32(dircheck, 13) ^ t->reserved[1];\n\n\treturn dircheck ^ dircheck >> 8 ^ dircheck >> 16 ^ dircheck >> 24;\n}\n\nstatic int adfs_fplus_read(struct super_block *sb, u32 indaddr,\n\t\t\t   unsigned int size, struct adfs_dir *dir)\n{\n\tstruct adfs_bigdirheader *h;\n\tstruct adfs_bigdirtail *t;\n\tunsigned int dirsize;\n\tint ret;\n\n\t \n\tret = adfs_dir_read_buffers(sb, indaddr, sb->s_blocksize, dir);\n\tif (ret)\n\t\treturn ret;\n\n\tdir->bighead = h = (void *)dir->bhs[0]->b_data;\n\tret = adfs_fplus_validate_header(h);\n\tif (ret) {\n\t\tadfs_error(sb, \"dir %06x has malformed header\", indaddr);\n\t\tgoto out;\n\t}\n\n\tdirsize = le32_to_cpu(h->bigdirsize);\n\tif (size && dirsize != size) {\n\t\tadfs_msg(sb, KERN_WARNING,\n\t\t\t \"dir %06x header size %X does not match directory size %X\",\n\t\t\t indaddr, dirsize, size);\n\t}\n\n\t \n\tret = adfs_dir_read_buffers(sb, indaddr, dirsize, dir);\n\tif (ret)\n\t\treturn ret;\n\n\tdir->bigtail = t = (struct adfs_bigdirtail *)\n\t\t(dir->bhs[dir->nr_buffers - 1]->b_data + (sb->s_blocksize - 8));\n\n\tret = adfs_fplus_validate_tail(h, t);\n\tif (ret) {\n\t\tadfs_error(sb, \"dir %06x has malformed tail\", indaddr);\n\t\tgoto out;\n\t}\n\n\tif (adfs_fplus_checkbyte(dir) != t->bigdircheckbyte) {\n\t\tadfs_error(sb, \"dir %06x checkbyte mismatch\\n\", indaddr);\n\t\tgoto out;\n\t}\n\n\tdir->parent_id = le32_to_cpu(h->bigdirparent);\n\treturn 0;\n\nout:\n\tadfs_dir_relse(dir);\n\n\treturn ret;\n}\n\nstatic int\nadfs_fplus_setpos(struct adfs_dir *dir, unsigned int fpos)\n{\n\tint ret = -ENOENT;\n\n\tif (fpos <= le32_to_cpu(dir->bighead->bigdirentries)) {\n\t\tdir->pos = fpos;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nadfs_fplus_getnext(struct adfs_dir *dir, struct object_info *obj)\n{\n\tstruct adfs_bigdirheader *h = dir->bighead;\n\tstruct adfs_bigdirentry bde;\n\tunsigned int offset;\n\tint ret;\n\n\tif (dir->pos >= le32_to_cpu(h->bigdirentries))\n\t\treturn -ENOENT;\n\n\toffset = adfs_fplus_offset(h, dir->pos);\n\n\tret = adfs_dir_copyfrom(&bde, dir, offset,\n\t\t\t\tsizeof(struct adfs_bigdirentry));\n\tif (ret)\n\t\treturn ret;\n\n\tobj->loadaddr = le32_to_cpu(bde.bigdirload);\n\tobj->execaddr = le32_to_cpu(bde.bigdirexec);\n\tobj->size     = le32_to_cpu(bde.bigdirlen);\n\tobj->indaddr  = le32_to_cpu(bde.bigdirindaddr);\n\tobj->attr     = le32_to_cpu(bde.bigdirattr);\n\tobj->name_len = le32_to_cpu(bde.bigdirobnamelen);\n\n\toffset = adfs_fplus_offset(h, le32_to_cpu(h->bigdirentries));\n\toffset += le32_to_cpu(bde.bigdirobnameptr);\n\n\tret = adfs_dir_copyfrom(obj->name, dir, offset, obj->name_len);\n\tif (ret)\n\t\treturn ret;\n\n\tadfs_object_fixup(dir, obj);\n\n\tdir->pos += 1;\n\n\treturn 0;\n}\n\nstatic int adfs_fplus_iterate(struct adfs_dir *dir, struct dir_context *ctx)\n{\n\tstruct object_info obj;\n\n\tif ((ctx->pos - 2) >> 32)\n\t\treturn 0;\n\n\tif (adfs_fplus_setpos(dir, ctx->pos - 2))\n\t\treturn 0;\n\n\twhile (!adfs_fplus_getnext(dir, &obj)) {\n\t\tif (!dir_emit(ctx, obj.name, obj.name_len,\n\t\t\t      obj.indaddr, DT_UNKNOWN))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\n\n\treturn 0;\n}\n\nstatic int adfs_fplus_update(struct adfs_dir *dir, struct object_info *obj)\n{\n\tstruct adfs_bigdirheader *h = dir->bighead;\n\tstruct adfs_bigdirentry bde;\n\tint offset, end, ret;\n\n\toffset = adfs_fplus_offset(h, 0) - sizeof(bde);\n\tend = adfs_fplus_offset(h, le32_to_cpu(h->bigdirentries));\n\n\tdo {\n\t\toffset += sizeof(bde);\n\t\tif (offset >= end) {\n\t\t\tadfs_error(dir->sb, \"unable to locate entry to update\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tret = adfs_dir_copyfrom(&bde, dir, offset, sizeof(bde));\n\t\tif (ret) {\n\t\t\tadfs_error(dir->sb, \"error reading directory entry\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t} while (le32_to_cpu(bde.bigdirindaddr) != obj->indaddr);\n\n\tbde.bigdirload    = cpu_to_le32(obj->loadaddr);\n\tbde.bigdirexec    = cpu_to_le32(obj->execaddr);\n\tbde.bigdirlen     = cpu_to_le32(obj->size);\n\tbde.bigdirindaddr = cpu_to_le32(obj->indaddr);\n\tbde.bigdirattr    = cpu_to_le32(obj->attr);\n\n\treturn adfs_dir_copyto(dir, offset, &bde, sizeof(bde));\n}\n\nstatic int adfs_fplus_commit(struct adfs_dir *dir)\n{\n\tint ret;\n\n\t \n\tdir->bighead->startmasseq += 1;\n\tdir->bigtail->bigdirendmasseq += 1;\n\n\t \n\tdir->bigtail->bigdircheckbyte = adfs_fplus_checkbyte(dir);\n\n\t \n\tret = adfs_fplus_validate_header(dir->bighead);\n\tif (ret == 0)\n\t\tret = adfs_fplus_validate_tail(dir->bighead, dir->bigtail);\n\n\treturn ret;\n}\n\nconst struct adfs_dir_ops adfs_fplus_dir_ops = {\n\t.read\t\t= adfs_fplus_read,\n\t.iterate\t= adfs_fplus_iterate,\n\t.setpos\t\t= adfs_fplus_setpos,\n\t.getnext\t= adfs_fplus_getnext,\n\t.update\t\t= adfs_fplus_update,\n\t.commit\t\t= adfs_fplus_commit,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}