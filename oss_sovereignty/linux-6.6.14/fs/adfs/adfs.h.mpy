{
  "module_name": "adfs.h",
  "hash_id": "9f66310d4b2706971d8e66140efbf60c61c1c4b074b859f5488d495f18180094",
  "original_prompt": "Ingested from linux-6.6.14/fs/adfs/adfs.h",
  "human_readable_source": " \n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/adfs_fs.h>\n\n \n\n#define ADFS_FREE_FRAG\t\t 0\n#define ADFS_BAD_FRAG\t\t 1\n#define ADFS_ROOT_FRAG\t\t 2\n\n#define ADFS_FILETYPE_NONE\t((u16)~0)\n\n \nstatic inline u16 adfs_filetype(u32 loadaddr)\n{\n\treturn (loadaddr & 0xfff00000) == 0xfff00000 ?\n\t       (loadaddr >> 8) & 0xfff : ADFS_FILETYPE_NONE;\n}\n\n#define ADFS_NDA_OWNER_READ\t(1 << 0)\n#define ADFS_NDA_OWNER_WRITE\t(1 << 1)\n#define ADFS_NDA_LOCKED\t\t(1 << 2)\n#define ADFS_NDA_DIRECTORY\t(1 << 3)\n#define ADFS_NDA_EXECUTE\t(1 << 4)\n#define ADFS_NDA_PUBLIC_READ\t(1 << 5)\n#define ADFS_NDA_PUBLIC_WRITE\t(1 << 6)\n\n \nstruct adfs_inode_info {\n\tloff_t\t\tmmu_private;\n\t__u32\t\tparent_id;\t \n\t__u32\t\tindaddr;\t \n\t__u32\t\tloadaddr;\t \n\t__u32\t\texecaddr;\t \n\tunsigned int\tattr;\t\t \n\tstruct inode vfs_inode;\n};\n\nstatic inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}\n\nstatic inline bool adfs_inode_is_stamped(struct inode *inode)\n{\n\treturn (ADFS_I(inode)->loadaddr & 0xfff00000) == 0xfff00000;\n}\n\n \nstruct adfs_discmap;\nstruct adfs_dir_ops;\n\n \nstruct adfs_sb_info {\n\tunion { struct {\n\t\tstruct adfs_discmap *s_map;\t \n\t\tconst struct adfs_dir_ops *s_dir;  \n\t\t};\n\t\tstruct rcu_head rcu;\t \n\t};\n\tkuid_t\t\ts_uid;\t\t \n\tkgid_t\t\ts_gid;\t\t \n\tumode_t\t\ts_owner_mask;\t \n\tumode_t\t\ts_other_mask;\t \n\tint\t\ts_ftsuffix;\t \n\n\t__u32\t\ts_ids_per_zone;\t \n\t__u32\t\ts_idlen;\t \n\t__u32\t\ts_map_size;\t \n\tsigned int\ts_map2blk;\t \n\tunsigned int\ts_log2sharesize; \n\tunsigned int\ts_namelen;\t \n};\n\nstatic inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\n \nstruct adfs_dir {\n\tstruct super_block\t*sb;\n\n\tint\t\t\tnr_buffers;\n\tstruct buffer_head\t*bh[4];\n\tstruct buffer_head\t**bhs;\n\n\tunsigned int\t\tpos;\n\t__u32\t\t\tparent_id;\n\n\tunion {\n\t\tstruct adfs_dirheader\t*dirhead;\n\t\tstruct adfs_bigdirheader *bighead;\n\t};\n\tunion {\n\t\tstruct adfs_newdirtail\t*newtail;\n\t\tstruct adfs_bigdirtail\t*bigtail;\n\t};\n};\n\n \n#define ADFS_MAX_NAME_LEN\t(256 + 4)  \nstruct object_info {\n\t__u32\t\tparent_id;\t\t \n\t__u32\t\tindaddr;\t\t \n\t__u32\t\tloadaddr;\t\t \n\t__u32\t\texecaddr;\t\t \n\t__u32\t\tsize;\t\t\t \n\t__u8\t\tattr;\t\t\t \n\tunsigned int\tname_len;\t\t \n\tchar\t\tname[ADFS_MAX_NAME_LEN]; \n};\n\nstruct adfs_dir_ops {\n\tint\t(*read)(struct super_block *sb, unsigned int indaddr,\n\t\t\tunsigned int size, struct adfs_dir *dir);\n\tint\t(*iterate)(struct adfs_dir *dir, struct dir_context *ctx);\n\tint\t(*setpos)(struct adfs_dir *dir, unsigned int fpos);\n\tint\t(*getnext)(struct adfs_dir *dir, struct object_info *obj);\n\tint\t(*update)(struct adfs_dir *dir, struct object_info *obj);\n\tint\t(*create)(struct adfs_dir *dir, struct object_info *obj);\n\tint\t(*remove)(struct adfs_dir *dir, struct object_info *obj);\n\tint\t(*commit)(struct adfs_dir *dir);\n};\n\nstruct adfs_discmap {\n\tstruct buffer_head\t*dm_bh;\n\t__u32\t\t\tdm_startblk;\n\tunsigned int\t\tdm_startbit;\n\tunsigned int\t\tdm_endbit;\n};\n\n \nstruct inode *adfs_iget(struct super_block *sb, struct object_info *obj);\nint adfs_write_inode(struct inode *inode, struct writeback_control *wbc);\nint adfs_notify_change(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t       struct iattr *attr);\n\n \nint adfs_map_lookup(struct super_block *sb, u32 frag_id, unsigned int offset);\nvoid adfs_map_statfs(struct super_block *sb, struct kstatfs *buf);\nstruct adfs_discmap *adfs_read_map(struct super_block *sb, struct adfs_discrecord *dr);\nvoid adfs_free_map(struct super_block *sb);\n\n \n__printf(3, 4)\nvoid __adfs_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...);\n#define adfs_error(sb, fmt...) __adfs_error(sb, __func__, fmt)\nvoid adfs_msg(struct super_block *sb, const char *pfx, const char *fmt, ...);\n\n \n\n \n\n \nextern const struct inode_operations adfs_dir_inode_operations;\nextern const struct file_operations adfs_dir_operations;\nextern const struct dentry_operations adfs_dentry_operations;\nextern const struct adfs_dir_ops adfs_f_dir_ops;\nextern const struct adfs_dir_ops adfs_fplus_dir_ops;\n\nint adfs_dir_copyfrom(void *dst, struct adfs_dir *dir, unsigned int offset,\n\t\t      size_t len);\nint adfs_dir_copyto(struct adfs_dir *dir, unsigned int offset, const void *src,\n\t\t    size_t len);\nvoid adfs_dir_relse(struct adfs_dir *dir);\nint adfs_dir_read_buffers(struct super_block *sb, u32 indaddr,\n\t\t\t  unsigned int size, struct adfs_dir *dir);\nvoid adfs_object_fixup(struct adfs_dir *dir, struct object_info *obj);\nextern int adfs_dir_update(struct super_block *sb, struct object_info *obj,\n\t\t\t   int wait);\n\n \nextern const struct inode_operations adfs_file_inode_operations;\nextern const struct file_operations adfs_file_operations;\n\nstatic inline __u32 signed_asl(__u32 val, signed int shift)\n{\n\tif (shift >= 0)\n\t\tval <<= shift;\n\telse\n\t\tval >>= -shift;\n\treturn val;\n}\n\n \nstatic inline int __adfs_block_map(struct super_block *sb, u32 indaddr,\n\t\t\t\t   unsigned int block)\n{\n\tif (indaddr & 255) {\n\t\tunsigned int off;\n\n\t\toff = (indaddr & 255) - 1;\n\t\tblock += off << ADFS_SB(sb)->s_log2sharesize;\n\t}\n\n\treturn adfs_map_lookup(sb, indaddr >> 8, block);\n}\n\n \nstatic inline\nstruct adfs_discrecord *adfs_map_discrecord(struct adfs_discmap *dm)\n{\n\treturn (void *)(dm[0].dm_bh->b_data + 4);\n}\n\nstatic inline u64 adfs_disc_size(const struct adfs_discrecord *dr)\n{\n\treturn (u64)le32_to_cpu(dr->disc_size_high) << 32 |\n\t\t    le32_to_cpu(dr->disc_size);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}