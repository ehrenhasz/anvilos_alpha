{
  "module_name": "dir_f.c",
  "hash_id": "8acee7adb8bbfd5d6234da5e4374934ac31ed2bd802b5e7eadcc78de4093628b",
  "original_prompt": "Ingested from linux-6.6.14/fs/adfs/dir_f.c",
  "human_readable_source": "\n \n#include \"adfs.h\"\n#include \"dir_f.h\"\n\n \nstatic inline unsigned int adfs_readval(unsigned char *p, int len)\n{\n\tunsigned int val = 0;\n\n\tswitch (len) {\n\tcase 4:\t\tval |= p[3] << 24;\n\t\tfallthrough;\n\tcase 3:\t\tval |= p[2] << 16;\n\t\tfallthrough;\n\tcase 2:\t\tval |= p[1] << 8;\n\t\tfallthrough;\n\tdefault:\tval |= p[0];\n\t}\n\treturn val;\n}\n\nstatic inline void adfs_writeval(unsigned char *p, int len, unsigned int val)\n{\n\tswitch (len) {\n\tcase 4:\t\tp[3] = val >> 24;\n\t\tfallthrough;\n\tcase 3:\t\tp[2] = val >> 16;\n\t\tfallthrough;\n\tcase 2:\t\tp[1] = val >> 8;\n\t\tfallthrough;\n\tdefault:\tp[0] = val;\n\t}\n}\n\n#define ror13(v) ((v >> 13) | (v << 19))\n\n#define dir_u8(idx)\t\t\t\t\\\n\t({ int _buf = idx >> blocksize_bits;\t\\\n\t   int _off = idx - (_buf << blocksize_bits);\\\n\t  *(u8 *)(bh[_buf]->b_data + _off);\t\\\n\t})\n\n#define dir_u32(idx)\t\t\t\t\\\n\t({ int _buf = idx >> blocksize_bits;\t\\\n\t   int _off = idx - (_buf << blocksize_bits);\\\n\t  *(__le32 *)(bh[_buf]->b_data + _off);\t\\\n\t})\n\n#define bufoff(_bh,_idx)\t\t\t\\\n\t({ int _buf = _idx >> blocksize_bits;\t\\\n\t   int _off = _idx - (_buf << blocksize_bits);\\\n\t  (void *)(_bh[_buf]->b_data + _off);\t\\\n\t})\n\n \nstatic u8\nadfs_dir_checkbyte(const struct adfs_dir *dir)\n{\n\tstruct buffer_head * const *bh = dir->bh;\n\tconst int blocksize_bits = dir->sb->s_blocksize_bits;\n\tunion { __le32 *ptr32; u8 *ptr8; } ptr, end;\n\tu32 dircheck = 0;\n\tint last = 5 - 26;\n\tint i = 0;\n\n\t \n\tdo {\n\t\tlast += 26;\n\t\tdo {\n\t\t\tdircheck = le32_to_cpu(dir_u32(i)) ^ ror13(dircheck);\n\n\t\t\ti += sizeof(u32);\n\t\t} while (i < (last & ~3));\n\t} while (dir_u8(last) != 0);\n\n\t \n\tif (i != last) {\n\t\tptr.ptr8 = bufoff(bh, i);\n\t\tend.ptr8 = ptr.ptr8 + last - i;\n\n\t\tdo {\n\t\t\tdircheck = *ptr.ptr8++ ^ ror13(dircheck);\n\t\t} while (ptr.ptr8 < end.ptr8);\n\t}\n\n\t \n\tptr.ptr8 = bufoff(bh, 2008);\n\tend.ptr8 = ptr.ptr8 + 36;\n\n\tdo {\n\t\t__le32 v = *ptr.ptr32++;\n\t\tdircheck = le32_to_cpu(v) ^ ror13(dircheck);\n\t} while (ptr.ptr32 < end.ptr32);\n\n\treturn (dircheck ^ (dircheck >> 8) ^ (dircheck >> 16) ^ (dircheck >> 24)) & 0xff;\n}\n\nstatic int adfs_f_validate(struct adfs_dir *dir)\n{\n\tstruct adfs_dirheader *head = dir->dirhead;\n\tstruct adfs_newdirtail *tail = dir->newtail;\n\n\tif (head->startmasseq != tail->endmasseq ||\n\t    tail->dirlastmask || tail->reserved[0] || tail->reserved[1] ||\n\t    (memcmp(&head->startname, \"Nick\", 4) &&\n\t     memcmp(&head->startname, \"Hugo\", 4)) ||\n\t    memcmp(&head->startname, &tail->endname, 4) ||\n\t    adfs_dir_checkbyte(dir) != tail->dircheckbyte)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic int adfs_f_read(struct super_block *sb, u32 indaddr, unsigned int size,\n\t\t       struct adfs_dir *dir)\n{\n\tconst unsigned int blocksize_bits = sb->s_blocksize_bits;\n\tint ret;\n\n\tif (size && size != ADFS_NEWDIR_SIZE)\n\t\treturn -EIO;\n\n\tret = adfs_dir_read_buffers(sb, indaddr, ADFS_NEWDIR_SIZE, dir);\n\tif (ret)\n\t\treturn ret;\n\n\tdir->dirhead = bufoff(dir->bh, 0);\n\tdir->newtail = bufoff(dir->bh, 2007);\n\n\tif (adfs_f_validate(dir))\n\t\tgoto bad_dir;\n\n\tdir->parent_id = adfs_readval(dir->newtail->dirparent, 3);\n\n\treturn 0;\n\nbad_dir:\n\tadfs_error(sb, \"dir %06x is corrupted\", indaddr);\n\tadfs_dir_relse(dir);\n\n\treturn -EIO;\n}\n\n \nstatic inline void\nadfs_dir2obj(struct adfs_dir *dir, struct object_info *obj,\n\tstruct adfs_direntry *de)\n{\n\tunsigned int name_len;\n\n\tfor (name_len = 0; name_len < ADFS_F_NAME_LEN; name_len++) {\n\t\tif (de->dirobname[name_len] < ' ')\n\t\t\tbreak;\n\n\t\tobj->name[name_len] = de->dirobname[name_len];\n\t}\n\n\tobj->name_len =\tname_len;\n\tobj->indaddr  = adfs_readval(de->dirinddiscadd, 3);\n\tobj->loadaddr = adfs_readval(de->dirload, 4);\n\tobj->execaddr = adfs_readval(de->direxec, 4);\n\tobj->size     = adfs_readval(de->dirlen,  4);\n\tobj->attr     = de->newdiratts;\n\n\tadfs_object_fixup(dir, obj);\n}\n\n \nstatic inline void\nadfs_obj2dir(struct adfs_direntry *de, struct object_info *obj)\n{\n\tadfs_writeval(de->dirinddiscadd, 3, obj->indaddr);\n\tadfs_writeval(de->dirload, 4, obj->loadaddr);\n\tadfs_writeval(de->direxec, 4, obj->execaddr);\n\tadfs_writeval(de->dirlen,  4, obj->size);\n\tde->newdiratts = obj->attr;\n}\n\n \nstatic int\n__adfs_dir_get(struct adfs_dir *dir, int pos, struct object_info *obj)\n{\n\tstruct adfs_direntry de;\n\tint ret;\n\n\tret = adfs_dir_copyfrom(&de, dir, pos, 26);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!de.dirobname[0])\n\t\treturn -ENOENT;\n\n\tadfs_dir2obj(dir, obj, &de);\n\n\treturn 0;\n}\n\nstatic int\nadfs_f_setpos(struct adfs_dir *dir, unsigned int fpos)\n{\n\tif (fpos >= ADFS_NUM_DIR_ENTRIES)\n\t\treturn -ENOENT;\n\n\tdir->pos = 5 + fpos * 26;\n\treturn 0;\n}\n\nstatic int\nadfs_f_getnext(struct adfs_dir *dir, struct object_info *obj)\n{\n\tunsigned int ret;\n\n\tret = __adfs_dir_get(dir, dir->pos, obj);\n\tif (ret == 0)\n\t\tdir->pos += 26;\n\n\treturn ret;\n}\n\nstatic int adfs_f_iterate(struct adfs_dir *dir, struct dir_context *ctx)\n{\n\tstruct object_info obj;\n\tint pos = 5 + (ctx->pos - 2) * 26;\n\n\twhile (ctx->pos < 2 + ADFS_NUM_DIR_ENTRIES) {\n\t\tif (__adfs_dir_get(dir, pos, &obj))\n\t\t\tbreak;\n\t\tif (!dir_emit(ctx, obj.name, obj.name_len,\n\t\t\t      obj.indaddr, DT_UNKNOWN))\n\t\t\tbreak;\n\t\tpos += 26;\n\t\tctx->pos++;\n\t}\n\treturn 0;\n}\n\nstatic int adfs_f_update(struct adfs_dir *dir, struct object_info *obj)\n{\n\tstruct adfs_direntry de;\n\tint offset, ret;\n\n\toffset = 5 - (int)sizeof(de);\n\n\tdo {\n\t\toffset += sizeof(de);\n\t\tret = adfs_dir_copyfrom(&de, dir, offset, sizeof(de));\n\t\tif (ret) {\n\t\t\tadfs_error(dir->sb, \"error reading directory entry\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif (!de.dirobname[0]) {\n\t\t\tadfs_error(dir->sb, \"unable to locate entry to update\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t} while (adfs_readval(de.dirinddiscadd, 3) != obj->indaddr);\n\n\t \n\tadfs_obj2dir(&de, obj);\n\n\t \n\treturn adfs_dir_copyto(dir, offset, &de, 26);\n}\n\nstatic int adfs_f_commit(struct adfs_dir *dir)\n{\n\tint ret;\n\n\t \n\tdir->dirhead->startmasseq += 1;\n\tdir->newtail->endmasseq += 1;\n\n\t \n\tdir->newtail->dircheckbyte = adfs_dir_checkbyte(dir);\n\n\t \n\tret = adfs_f_validate(dir);\n\tif (ret)\n\t\tadfs_msg(dir->sb, KERN_ERR, \"error: update broke directory\");\n\n\treturn ret;\n}\n\nconst struct adfs_dir_ops adfs_f_dir_ops = {\n\t.read\t\t= adfs_f_read,\n\t.iterate\t= adfs_f_iterate,\n\t.setpos\t\t= adfs_f_setpos,\n\t.getnext\t= adfs_f_getnext,\n\t.update\t\t= adfs_f_update,\n\t.commit\t\t= adfs_f_commit,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}