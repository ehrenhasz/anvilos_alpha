{
  "module_name": "inode.c",
  "hash_id": "2aadd995f2663e98ad541154f5c0aefbf263d76dcf691c25355c31d697948547",
  "original_prompt": "Ingested from linux-6.6.14/fs/adfs/inode.c",
  "human_readable_source": "\n \n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include \"adfs.h\"\n\n \nstatic int\nadfs_get_block(struct inode *inode, sector_t block, struct buffer_head *bh,\n\t       int create)\n{\n\tif (!create) {\n\t\tif (block >= inode->i_blocks)\n\t\t\tgoto abort_toobig;\n\n\t\tblock = __adfs_block_map(inode->i_sb, ADFS_I(inode)->indaddr,\n\t\t\t\t\t block);\n\t\tif (block)\n\t\t\tmap_bh(bh, inode->i_sb, block);\n\t\treturn 0;\n\t}\n\t \n\treturn -EIO;\n\nabort_toobig:\n\treturn 0;\n}\n\nstatic int adfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, adfs_get_block, wbc);\n}\n\nstatic int adfs_read_folio(struct file *file, struct folio *folio)\n{\n\treturn block_read_full_folio(folio, adfs_get_block);\n}\n\nstatic void adfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}\n\nstatic int adfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\t*pagep = NULL;\n\tret = cont_write_begin(file, mapping, pos, len, pagep, fsdata,\n\t\t\t\tadfs_get_block,\n\t\t\t\t&ADFS_I(mapping->host)->mmu_private);\n\tif (unlikely(ret))\n\t\tadfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}\n\nstatic sector_t _adfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, adfs_get_block);\n}\n\nstatic const struct address_space_operations adfs_aops = {\n\t.dirty_folio\t= block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.read_folio\t= adfs_read_folio,\n\t.writepage\t= adfs_writepage,\n\t.write_begin\t= adfs_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= _adfs_bmap\n};\n\n \nstatic umode_t\nadfs_atts2mode(struct super_block *sb, struct inode *inode)\n{\n\tunsigned int attr = ADFS_I(inode)->attr;\n\tumode_t mode, rmask;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\tif (attr & ADFS_NDA_DIRECTORY) {\n\t\tmode = S_IRUGO & asb->s_owner_mask;\n\t\treturn S_IFDIR | S_IXUGO | mode;\n\t}\n\n\tswitch (adfs_filetype(ADFS_I(inode)->loadaddr)) {\n\tcase 0xfc0:\t \n\t\treturn S_IFLNK|S_IRWXUGO;\n\n\tcase 0xfe6:\t \n\t\trmask = S_IRUGO | S_IXUGO;\n\t\tbreak;\n\n\tdefault:\n\t\trmask = S_IRUGO;\n\t}\n\n\tmode = S_IFREG;\n\n\tif (attr & ADFS_NDA_OWNER_READ)\n\t\tmode |= rmask & asb->s_owner_mask;\n\n\tif (attr & ADFS_NDA_OWNER_WRITE)\n\t\tmode |= S_IWUGO & asb->s_owner_mask;\n\n\tif (attr & ADFS_NDA_PUBLIC_READ)\n\t\tmode |= rmask & asb->s_other_mask;\n\n\tif (attr & ADFS_NDA_PUBLIC_WRITE)\n\t\tmode |= S_IWUGO & asb->s_other_mask;\n\treturn mode;\n}\n\n \nstatic int adfs_mode2atts(struct super_block *sb, struct inode *inode,\n\t\t\t  umode_t ia_mode)\n{\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\tumode_t mode;\n\tint attr;\n\n\t \n\tif (S_ISLNK(inode->i_mode))\n\t\treturn ADFS_I(inode)->attr;\n\n\t \n\tif (S_ISDIR(inode->i_mode))\n\t\treturn ADFS_NDA_DIRECTORY;\n\n\tattr = 0;\n\tmode = ia_mode & asb->s_owner_mask;\n\tif (mode & S_IRUGO)\n\t\tattr |= ADFS_NDA_OWNER_READ;\n\tif (mode & S_IWUGO)\n\t\tattr |= ADFS_NDA_OWNER_WRITE;\n\n\tmode = ia_mode & asb->s_other_mask;\n\tmode &= ~asb->s_owner_mask;\n\tif (mode & S_IRUGO)\n\t\tattr |= ADFS_NDA_PUBLIC_READ;\n\tif (mode & S_IWUGO)\n\t\tattr |= ADFS_NDA_PUBLIC_WRITE;\n\n\treturn attr;\n}\n\nstatic const s64 nsec_unix_epoch_diff_risc_os_epoch = 2208988800000000000LL;\n\n \nstatic void\nadfs_adfs2unix_time(struct timespec64 *tv, struct inode *inode)\n{\n\tunsigned int high, low;\n\t \n\ts64 nsec;\n\n\tif (!adfs_inode_is_stamped(inode))\n\t\tgoto cur_time;\n\n\thigh = ADFS_I(inode)->loadaddr & 0xFF;  \n\tlow  = ADFS_I(inode)->execaddr;     \n\n\t \n\tnsec = (((s64) high << 32) | (s64) low) * 10000000;  \n\n\t \n\tif (nsec < nsec_unix_epoch_diff_risc_os_epoch)\n\t\tgoto too_early;\n\n\t \n\tnsec -= nsec_unix_epoch_diff_risc_os_epoch;\n\n\t*tv = ns_to_timespec64(nsec);\n\treturn;\n\n cur_time:\n\t*tv = current_time(inode);\n\treturn;\n\n too_early:\n\ttv->tv_sec = tv->tv_nsec = 0;\n\treturn;\n}\n\n \nstatic void adfs_unix2adfs_time(struct inode *inode,\n\t\t\t\tconst struct timespec64 *ts)\n{\n\ts64 cs, nsec = timespec64_to_ns(ts);\n\n\t \n\tnsec += nsec_unix_epoch_diff_risc_os_epoch;\n\n\t \n\tcs = div_s64(nsec, 10000000);\n\n\tcs = clamp_t(s64, cs, 0, 0xffffffffff);\n\n\tADFS_I(inode)->loadaddr &= ~0xff;\n\tADFS_I(inode)->loadaddr |= (cs >> 32) & 0xff;\n\tADFS_I(inode)->execaddr = cs;\n}\n\n \nstruct inode *\nadfs_iget(struct super_block *sb, struct object_info *obj)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_uid\t = ADFS_SB(sb)->s_uid;\n\tinode->i_gid\t = ADFS_SB(sb)->s_gid;\n\tinode->i_ino\t = obj->indaddr;\n\tinode->i_size\t = obj->size;\n\tset_nlink(inode, 2);\n\tinode->i_blocks\t = (inode->i_size + sb->s_blocksize - 1) >>\n\t\t\t    sb->s_blocksize_bits;\n\n\t \n\tADFS_I(inode)->parent_id = obj->parent_id;\n\tADFS_I(inode)->indaddr   = obj->indaddr;\n\tADFS_I(inode)->loadaddr  = obj->loadaddr;\n\tADFS_I(inode)->execaddr  = obj->execaddr;\n\tADFS_I(inode)->attr      = obj->attr;\n\n\tinode->i_mode\t = adfs_atts2mode(sb, inode);\n\tadfs_adfs2unix_time(&inode->i_mtime, inode);\n\tinode->i_atime = inode->i_mtime;\n\tinode_set_ctime_to_ts(inode, inode->i_mtime);\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op\t= &adfs_dir_inode_operations;\n\t\tinode->i_fop\t= &adfs_dir_operations;\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op\t= &adfs_file_inode_operations;\n\t\tinode->i_fop\t= &adfs_file_operations;\n\t\tinode->i_mapping->a_ops = &adfs_aops;\n\t\tADFS_I(inode)->mmu_private = inode->i_size;\n\t}\n\n\tinode_fake_hash(inode);\n\nout:\n\treturn inode;\n}\n\n \nint\nadfs_notify_change(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t   struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned int ia_valid = attr->ia_valid;\n\tint error;\n\t\n\terror = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\n\t \n\tif ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, ADFS_SB(sb)->s_uid)) ||\n\t    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, ADFS_SB(sb)->s_gid)))\n\t\terror = -EPERM;\n\n\tif (error)\n\t\tgoto out;\n\n\t \n\tif (ia_valid & ATTR_SIZE)\n\t\ttruncate_setsize(inode, attr->ia_size);\n\n\tif (ia_valid & ATTR_MTIME && adfs_inode_is_stamped(inode)) {\n\t\tadfs_unix2adfs_time(inode, &attr->ia_mtime);\n\t\tadfs_adfs2unix_time(&inode->i_mtime, inode);\n\t}\n\n\t \n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = attr->ia_atime;\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode_set_ctime_to_ts(inode, attr->ia_ctime);\n\tif (ia_valid & ATTR_MODE) {\n\t\tADFS_I(inode)->attr = adfs_mode2atts(sb, inode, attr->ia_mode);\n\t\tinode->i_mode = adfs_atts2mode(sb, inode);\n\t}\n\n\t \n\tif (ia_valid & (ATTR_SIZE | ATTR_MTIME | ATTR_MODE))\n\t\tmark_inode_dirty(inode);\nout:\n\treturn error;\n}\n\n \nint adfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct object_info obj;\n\n\tobj.indaddr\t= ADFS_I(inode)->indaddr;\n\tobj.name_len\t= 0;\n\tobj.parent_id\t= ADFS_I(inode)->parent_id;\n\tobj.loadaddr\t= ADFS_I(inode)->loadaddr;\n\tobj.execaddr\t= ADFS_I(inode)->execaddr;\n\tobj.attr\t= ADFS_I(inode)->attr;\n\tobj.size\t= inode->i_size;\n\n\treturn adfs_dir_update(sb, &obj, wbc->sync_mode == WB_SYNC_ALL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}