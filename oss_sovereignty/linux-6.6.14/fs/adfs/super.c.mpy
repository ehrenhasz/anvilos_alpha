{
  "module_name": "super.c",
  "hash_id": "f3a4d8053021661c5675631b53b5e28a4de7cbd6d699f12fbffe00584b7a7fd9",
  "original_prompt": "Ingested from linux-6.6.14/fs/adfs/super.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/user_namespace.h>\n#include <linux/blkdev.h>\n#include \"adfs.h\"\n#include \"dir_f.h\"\n#include \"dir_fplus.h\"\n\n#define ADFS_SB_FLAGS SB_NOATIME\n\n#define ADFS_DEFAULT_OWNER_MASK S_IRWXU\n#define ADFS_DEFAULT_OTHER_MASK (S_IRWXG | S_IRWXO)\n\nvoid __adfs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"ADFS-fs error (device %s)%s%s: %pV\\n\",\n\t\tsb->s_id, function ? \": \" : \"\",\n\t\tfunction ? function : \"\", &vaf);\n\n\tva_end(args);\n}\n\nvoid adfs_msg(struct super_block *sb, const char *pfx, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sADFS-fs (%s): %pV\\n\", pfx, sb->s_id, &vaf);\n\tva_end(args);\n}\n\nstatic int adfs_checkdiscrecord(struct adfs_discrecord *dr)\n{\n\tunsigned int max_idlen;\n\tint i;\n\n\t \n\tif (dr->log2secsize != 8 &&\n\t    dr->log2secsize != 9 &&\n\t    dr->log2secsize != 10)\n\t\treturn 1;\n\n\t \n\tif (dr->idlen < dr->log2secsize + 3)\n\t\treturn 1;\n\n\t \n\tif (le32_to_cpu(dr->disc_size_high) >> dr->log2secsize)\n\t\treturn 1;\n\n\t \n\tmax_idlen = dr->format_version ? 19 : 16;\n\tif (dr->idlen > max_idlen)\n\t\treturn 1;\n\n\t \n\tfor (i = 0; i < sizeof(dr->unused52); i++)\n\t\tif (dr->unused52[i] != 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void adfs_put_super(struct super_block *sb)\n{\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\tadfs_free_map(sb);\n\tkfree_rcu(asb, rcu);\n}\n\nstatic int adfs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct adfs_sb_info *asb = ADFS_SB(root->d_sb);\n\n\tif (!uid_eq(asb->s_uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(seq, \",uid=%u\", from_kuid_munged(&init_user_ns, asb->s_uid));\n\tif (!gid_eq(asb->s_gid, GLOBAL_ROOT_GID))\n\t\tseq_printf(seq, \",gid=%u\", from_kgid_munged(&init_user_ns, asb->s_gid));\n\tif (asb->s_owner_mask != ADFS_DEFAULT_OWNER_MASK)\n\t\tseq_printf(seq, \",ownmask=%o\", asb->s_owner_mask);\n\tif (asb->s_other_mask != ADFS_DEFAULT_OTHER_MASK)\n\t\tseq_printf(seq, \",othmask=%o\", asb->s_other_mask);\n\tif (asb->s_ftsuffix != 0)\n\t\tseq_printf(seq, \",ftsuffix=%u\", asb->s_ftsuffix);\n\n\treturn 0;\n}\n\nenum {Opt_uid, Opt_gid, Opt_ownmask, Opt_othmask, Opt_ftsuffix, Opt_err};\n\nstatic const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_ownmask, \"ownmask=%o\"},\n\t{Opt_othmask, \"othmask=%o\"},\n\t{Opt_ftsuffix, \"ftsuffix=%u\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(struct super_block *sb, struct adfs_sb_info *asb,\n\t\t\t char *options)\n{\n\tchar *p;\n\tint option;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(asb->s_uid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(asb->s_gid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_ownmask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_owner_mask = option;\n\t\t\tbreak;\n\t\tcase Opt_othmask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_other_mask = option;\n\t\t\tbreak;\n\t\tcase Opt_ftsuffix:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_ftsuffix = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tadfs_msg(sb, KERN_ERR,\n\t\t\t\t \"unrecognised mount option \\\"%s\\\" or missing value\",\n\t\t\t\t p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int adfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct adfs_sb_info temp_asb;\n\tint ret;\n\n\tsync_filesystem(sb);\n\t*flags |= ADFS_SB_FLAGS;\n\n\ttemp_asb = *ADFS_SB(sb);\n\tret = parse_options(sb, &temp_asb, data);\n\tif (ret == 0)\n\t\t*ADFS_SB(sb) = temp_asb;\n\n\treturn ret;\n}\n\nstatic int adfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct adfs_sb_info *sbi = ADFS_SB(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tadfs_map_statfs(sb, buf);\n\n\tbuf->f_type    = ADFS_SUPER_MAGIC;\n\tbuf->f_namelen = sbi->s_namelen;\n\tbuf->f_bsize   = sb->s_blocksize;\n\tbuf->f_ffree   = (long)(buf->f_bfree * buf->f_files) / (long)buf->f_blocks;\n\tbuf->f_fsid    = u64_to_fsid(id);\n\n\treturn 0;\n}\n\nstatic struct kmem_cache *adfs_inode_cachep;\n\nstatic struct inode *adfs_alloc_inode(struct super_block *sb)\n{\n\tstruct adfs_inode_info *ei;\n\tei = alloc_inode_sb(sb, adfs_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}\n\nstatic void adfs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(adfs_inode_cachep, ADFS_I(inode));\n}\n\nstatic int adfs_drop_inode(struct inode *inode)\n{\n\t \n\treturn !IS_ENABLED(CONFIG_ADFS_FS_RW) || IS_RDONLY(inode);\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct adfs_inode_info *ei = (struct adfs_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int __init init_inodecache(void)\n{\n\tadfs_inode_cachep = kmem_cache_create(\"adfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct adfs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t     init_once);\n\tif (adfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(adfs_inode_cachep);\n}\n\nstatic const struct super_operations adfs_sops = {\n\t.alloc_inode\t= adfs_alloc_inode,\n\t.free_inode\t= adfs_free_inode,\n\t.drop_inode\t= adfs_drop_inode,\n\t.write_inode\t= adfs_write_inode,\n\t.put_super\t= adfs_put_super,\n\t.statfs\t\t= adfs_statfs,\n\t.remount_fs\t= adfs_remount,\n\t.show_options\t= adfs_show_options,\n};\n\nstatic int adfs_probe(struct super_block *sb, unsigned int offset, int silent,\n\t\t      int (*validate)(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      struct adfs_discrecord **bhp))\n{\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\tstruct adfs_discrecord *dr;\n\tstruct buffer_head *bh;\n\tunsigned int blocksize = BLOCK_SIZE;\n\tint ret, try;\n\n\tfor (try = 0; try < 2; try++) {\n\t\t \n\t\tif (sb->s_blocksize != blocksize &&\n\t\t    !sb_set_blocksize(sb, blocksize)) {\n\t\t\tif (!silent)\n\t\t\t\tadfs_msg(sb, KERN_ERR,\n\t\t\t\t\t \"error: unsupported blocksize\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tbh = sb_bread(sb, offset >> sb->s_blocksize_bits);\n\t\tif (!bh) {\n\t\t\tadfs_msg(sb, KERN_ERR,\n\t\t\t\t \"error: unable to read block %u, try %d\",\n\t\t\t\t offset >> sb->s_blocksize_bits, try);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tret = validate(sb, bh, &dr);\n\t\tif (ret) {\n\t\t\tbrelse(bh);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tblocksize = 1 << dr->log2secsize;\n\t\tif (sb->s_blocksize == blocksize) {\n\t\t\tasb->s_map = adfs_read_map(sb, dr);\n\t\t\tbrelse(bh);\n\t\t\treturn PTR_ERR_OR_ZERO(asb->s_map);\n\t\t}\n\n\t\tbrelse(bh);\n\t}\n\n\treturn -EIO;\n}\n\nstatic int adfs_validate_bblk(struct super_block *sb, struct buffer_head *bh,\n\t\t\t      struct adfs_discrecord **drp)\n{\n\tstruct adfs_discrecord *dr;\n\tunsigned char *b_data;\n\n\tb_data = bh->b_data + (ADFS_DISCRECORD % sb->s_blocksize);\n\tif (adfs_checkbblk(b_data))\n\t\treturn -EILSEQ;\n\n\t \n\tdr = (struct adfs_discrecord *)(b_data + ADFS_DR_OFFSET);\n\tif (adfs_checkdiscrecord(dr))\n\t\treturn -EILSEQ;\n\n\t*drp = dr;\n\treturn 0;\n}\n\nstatic int adfs_validate_dr0(struct super_block *sb, struct buffer_head *bh,\n\t\t\t      struct adfs_discrecord **drp)\n{\n\tstruct adfs_discrecord *dr;\n\n\t \n\tdr = (struct adfs_discrecord *)(bh->b_data + 4);\n\tif (adfs_checkdiscrecord(dr) || dr->nzones_high || dr->nzones != 1)\n\t\treturn -EILSEQ;\n\n\t*drp = dr;\n\treturn 0;\n}\n\nstatic int adfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct adfs_discrecord *dr;\n\tstruct object_info root_obj;\n\tstruct adfs_sb_info *asb;\n\tstruct inode *root;\n\tint ret = -EINVAL;\n\n\tsb->s_flags |= ADFS_SB_FLAGS;\n\n\tasb = kzalloc(sizeof(*asb), GFP_KERNEL);\n\tif (!asb)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = asb;\n\tsb->s_magic = ADFS_SUPER_MAGIC;\n\tsb->s_time_gran = 10000000;\n\n\t \n\tasb->s_uid = GLOBAL_ROOT_UID;\n\tasb->s_gid = GLOBAL_ROOT_GID;\n\tasb->s_owner_mask = ADFS_DEFAULT_OWNER_MASK;\n\tasb->s_other_mask = ADFS_DEFAULT_OTHER_MASK;\n\tasb->s_ftsuffix = 0;\n\n\tif (parse_options(sb, asb, data))\n\t\tgoto error;\n\n\t \n\tret = adfs_probe(sb, ADFS_DISCRECORD, 1, adfs_validate_bblk);\n\tif (ret == -EILSEQ)\n\t\tret = adfs_probe(sb, 0, silent, adfs_validate_dr0);\n\tif (ret == -EILSEQ) {\n\t\tif (!silent)\n\t\t\tadfs_msg(sb, KERN_ERR,\n\t\t\t\t \"error: can't find an ADFS filesystem on dev %s.\",\n\t\t\t\t sb->s_id);\n\t\tret = -EINVAL;\n\t}\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tsb->s_op = &adfs_sops;\n\n\tdr = adfs_map_discrecord(asb->s_map);\n\n\troot_obj.parent_id = root_obj.indaddr = le32_to_cpu(dr->root);\n\troot_obj.name_len  = 0;\n\t \n\troot_obj.loadaddr  = 0xfff0003f;\n\troot_obj.execaddr  = 0xec22c000;\n\troot_obj.size\t   = ADFS_NEWDIR_SIZE;\n\troot_obj.attr\t   = ADFS_NDA_DIRECTORY   | ADFS_NDA_OWNER_READ |\n\t\t\t     ADFS_NDA_OWNER_WRITE | ADFS_NDA_PUBLIC_READ;\n\n\t \n\tif (dr->format_version) {\n\t\troot_obj.size = le32_to_cpu(dr->root_size);\n\t\tasb->s_dir     = &adfs_fplus_dir_ops;\n\t\tasb->s_namelen = ADFS_FPLUS_NAME_LEN;\n\t} else {\n\t\tasb->s_dir     = &adfs_f_dir_ops;\n\t\tasb->s_namelen = ADFS_F_NAME_LEN;\n\t}\n\t \n\tif (asb->s_ftsuffix)\n\t\tasb->s_namelen += 4;\n\n\tsb->s_d_op = &adfs_dentry_operations;\n\troot = adfs_iget(sb, &root_obj);\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\tadfs_free_map(sb);\n\t\tadfs_error(sb, \"get root inode failed\\n\");\n\t\tret = -EIO;\n\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\tsb->s_fs_info = NULL;\n\tkfree(asb);\n\treturn ret;\n}\n\nstatic struct dentry *adfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, adfs_fill_super);\n}\n\nstatic struct file_system_type adfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"adfs\",\n\t.mount\t\t= adfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"adfs\");\n\nstatic int __init init_adfs_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&adfs_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}\n\nstatic void __exit exit_adfs_fs(void)\n{\n\tunregister_filesystem(&adfs_fs_type);\n\tdestroy_inodecache();\n}\n\nmodule_init(init_adfs_fs)\nmodule_exit(exit_adfs_fs)\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}