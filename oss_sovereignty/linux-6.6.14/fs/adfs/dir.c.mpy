{
  "module_name": "dir.c",
  "hash_id": "ef35c132b7735ab1eeaaf2b2dd90d093a3c2be21f602911f693a10dad0a291c7",
  "original_prompt": "Ingested from linux-6.6.14/fs/adfs/dir.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include \"adfs.h\"\n\n \nstatic DECLARE_RWSEM(adfs_dir_rwsem);\n\nint adfs_dir_copyfrom(void *dst, struct adfs_dir *dir, unsigned int offset,\n\t\t      size_t len)\n{\n\tstruct super_block *sb = dir->sb;\n\tunsigned int index, remain;\n\n\tindex = offset >> sb->s_blocksize_bits;\n\toffset &= sb->s_blocksize - 1;\n\tremain = sb->s_blocksize - offset;\n\tif (index + (remain < len) >= dir->nr_buffers)\n\t\treturn -EINVAL;\n\n\tif (remain < len) {\n\t\tmemcpy(dst, dir->bhs[index]->b_data + offset, remain);\n\t\tdst += remain;\n\t\tlen -= remain;\n\t\tindex += 1;\n\t\toffset = 0;\n\t}\n\n\tmemcpy(dst, dir->bhs[index]->b_data + offset, len);\n\n\treturn 0;\n}\n\nint adfs_dir_copyto(struct adfs_dir *dir, unsigned int offset, const void *src,\n\t\t    size_t len)\n{\n\tstruct super_block *sb = dir->sb;\n\tunsigned int index, remain;\n\n\tindex = offset >> sb->s_blocksize_bits;\n\toffset &= sb->s_blocksize - 1;\n\tremain = sb->s_blocksize - offset;\n\tif (index + (remain < len) >= dir->nr_buffers)\n\t\treturn -EINVAL;\n\n\tif (remain < len) {\n\t\tmemcpy(dir->bhs[index]->b_data + offset, src, remain);\n\t\tsrc += remain;\n\t\tlen -= remain;\n\t\tindex += 1;\n\t\toffset = 0;\n\t}\n\n\tmemcpy(dir->bhs[index]->b_data + offset, src, len);\n\n\treturn 0;\n}\n\nstatic void __adfs_dir_cleanup(struct adfs_dir *dir)\n{\n\tdir->nr_buffers = 0;\n\n\tif (dir->bhs != dir->bh)\n\t\tkfree(dir->bhs);\n\tdir->bhs = NULL;\n\tdir->sb = NULL;\n}\n\nvoid adfs_dir_relse(struct adfs_dir *dir)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < dir->nr_buffers; i++)\n\t\tbrelse(dir->bhs[i]);\n\n\t__adfs_dir_cleanup(dir);\n}\n\nstatic void adfs_dir_forget(struct adfs_dir *dir)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < dir->nr_buffers; i++)\n\t\tbforget(dir->bhs[i]);\n\n\t__adfs_dir_cleanup(dir);\n}\n\nint adfs_dir_read_buffers(struct super_block *sb, u32 indaddr,\n\t\t\t  unsigned int size, struct adfs_dir *dir)\n{\n\tstruct buffer_head **bhs;\n\tunsigned int i, num;\n\tint block;\n\n\tnum = ALIGN(size, sb->s_blocksize) >> sb->s_blocksize_bits;\n\tif (num > ARRAY_SIZE(dir->bh)) {\n\t\t \n\t\tif (dir->bhs != dir->bh)\n\t\t\treturn -EINVAL;\n\n\t\tbhs = kcalloc(num, sizeof(*bhs), GFP_KERNEL);\n\t\tif (!bhs)\n\t\t\treturn -ENOMEM;\n\n\t\tif (dir->nr_buffers)\n\t\t\tmemcpy(bhs, dir->bhs, dir->nr_buffers * sizeof(*bhs));\n\n\t\tdir->bhs = bhs;\n\t}\n\n\tfor (i = dir->nr_buffers; i < num; i++) {\n\t\tblock = __adfs_block_map(sb, indaddr, i);\n\t\tif (!block) {\n\t\t\tadfs_error(sb, \"dir %06x has a hole at offset %u\",\n\t\t\t\t   indaddr, i);\n\t\t\tgoto error;\n\t\t}\n\n\t\tdir->bhs[i] = sb_bread(sb, block);\n\t\tif (!dir->bhs[i]) {\n\t\t\tadfs_error(sb,\n\t\t\t\t   \"dir %06x failed read at offset %u, mapped block 0x%08x\",\n\t\t\t\t   indaddr, i, block);\n\t\t\tgoto error;\n\t\t}\n\n\t\tdir->nr_buffers++;\n\t}\n\treturn 0;\n\nerror:\n\tadfs_dir_relse(dir);\n\n\treturn -EIO;\n}\n\nstatic int adfs_dir_read(struct super_block *sb, u32 indaddr,\n\t\t\t unsigned int size, struct adfs_dir *dir)\n{\n\tdir->sb = sb;\n\tdir->bhs = dir->bh;\n\tdir->nr_buffers = 0;\n\n\treturn ADFS_SB(sb)->s_dir->read(sb, indaddr, size, dir);\n}\n\nstatic int adfs_dir_read_inode(struct super_block *sb, struct inode *inode,\n\t\t\t       struct adfs_dir *dir)\n{\n\tint ret;\n\n\tret = adfs_dir_read(sb, ADFS_I(inode)->indaddr, inode->i_size, dir);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ADFS_I(inode)->parent_id != dir->parent_id) {\n\t\tadfs_error(sb,\n\t\t\t   \"parent directory id changed under me! (%06x but got %06x)\\n\",\n\t\t\t   ADFS_I(inode)->parent_id, dir->parent_id);\n\t\tadfs_dir_relse(dir);\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic void adfs_dir_mark_dirty(struct adfs_dir *dir)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < dir->nr_buffers; i++)\n\t\tmark_buffer_dirty(dir->bhs[i]);\n}\n\nstatic int adfs_dir_sync(struct adfs_dir *dir)\n{\n\tint err = 0;\n\tint i;\n\n\tfor (i = dir->nr_buffers - 1; i >= 0; i--) {\n\t\tstruct buffer_head *bh = dir->bhs[i];\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh))\n\t\t\terr = -EIO;\n\t}\n\n\treturn err;\n}\n\nvoid adfs_object_fixup(struct adfs_dir *dir, struct object_info *obj)\n{\n\tunsigned int dots, i;\n\n\t \n\tfor (i = dots = 0; i < obj->name_len; i++)\n\t\tif (obj->name[i] == '/') {\n\t\t\tobj->name[i] = '.';\n\t\t\tdots++;\n\t\t}\n\n\tif (obj->name_len <= 2 && dots == obj->name_len)\n\t\tobj->name[0] = '^';\n\n\t \n\tif (!(obj->attr & ADFS_NDA_DIRECTORY) && ADFS_SB(dir->sb)->s_ftsuffix) {\n\t\tu16 filetype = adfs_filetype(obj->loadaddr);\n\n\t\tif (filetype != ADFS_FILETYPE_NONE) {\n\t\t\tobj->name[obj->name_len++] = ',';\n\t\t\tobj->name[obj->name_len++] = hex_asc_lo(filetype >> 8);\n\t\t\tobj->name[obj->name_len++] = hex_asc_lo(filetype >> 4);\n\t\t\tobj->name[obj->name_len++] = hex_asc_lo(filetype >> 0);\n\t\t}\n\t}\n}\n\nstatic int adfs_iterate(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tconst struct adfs_dir_ops *ops = ADFS_SB(sb)->s_dir;\n\tstruct adfs_dir dir;\n\tint ret;\n\n\tdown_read(&adfs_dir_rwsem);\n\tret = adfs_dir_read_inode(sb, inode, &dir);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (ctx->pos == 0) {\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\tgoto unlock_relse;\n\t\tctx->pos = 1;\n\t}\n\tif (ctx->pos == 1) {\n\t\tif (!dir_emit(ctx, \"..\", 2, dir.parent_id, DT_DIR))\n\t\t\tgoto unlock_relse;\n\t\tctx->pos = 2;\n\t}\n\n\tret = ops->iterate(&dir, ctx);\n\nunlock_relse:\n\tup_read(&adfs_dir_rwsem);\n\tadfs_dir_relse(&dir);\n\treturn ret;\n\nunlock:\n\tup_read(&adfs_dir_rwsem);\n\treturn ret;\n}\n\nint\nadfs_dir_update(struct super_block *sb, struct object_info *obj, int wait)\n{\n\tconst struct adfs_dir_ops *ops = ADFS_SB(sb)->s_dir;\n\tstruct adfs_dir dir;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_ADFS_FS_RW))\n\t\treturn -EINVAL;\n\n\tif (!ops->update)\n\t\treturn -EINVAL;\n\n\tdown_write(&adfs_dir_rwsem);\n\tret = adfs_dir_read(sb, obj->parent_id, 0, &dir);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = ops->update(&dir, obj);\n\tif (ret)\n\t\tgoto forget;\n\n\tret = ops->commit(&dir);\n\tif (ret)\n\t\tgoto forget;\n\tup_write(&adfs_dir_rwsem);\n\n\tadfs_dir_mark_dirty(&dir);\n\n\tif (wait)\n\t\tret = adfs_dir_sync(&dir);\n\n\tadfs_dir_relse(&dir);\n\treturn ret;\n\n\t \nforget:\n\tif (ret == -ENOENT)\n\t\tadfs_dir_relse(&dir);\n\telse\n\t\tadfs_dir_forget(&dir);\nunlock:\n\tup_write(&adfs_dir_rwsem);\n\n\treturn ret;\n}\n\nstatic unsigned char adfs_tolower(unsigned char c)\n{\n\tif (c >= 'A' && c <= 'Z')\n\t\tc += 'a' - 'A';\n\treturn c;\n}\n\nstatic int __adfs_compare(const unsigned char *qstr, u32 qlen,\n\t\t\t  const char *str, u32 len)\n{\n\tu32 i;\n\n\tif (qlen != len)\n\t\treturn 1;\n\n\tfor (i = 0; i < qlen; i++)\n\t\tif (adfs_tolower(qstr[i]) != adfs_tolower(str[i]))\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int adfs_dir_lookup_byname(struct inode *inode, const struct qstr *qstr,\n\t\t\t\t  struct object_info *obj)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst struct adfs_dir_ops *ops = ADFS_SB(sb)->s_dir;\n\tconst unsigned char *name;\n\tstruct adfs_dir dir;\n\tu32 name_len;\n\tint ret;\n\n\tdown_read(&adfs_dir_rwsem);\n\tret = adfs_dir_read_inode(sb, inode, &dir);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = ops->setpos(&dir, 0);\n\tif (ret)\n\t\tgoto unlock_relse;\n\n\tret = -ENOENT;\n\tname = qstr->name;\n\tname_len = qstr->len;\n\twhile (ops->getnext(&dir, obj) == 0) {\n\t\tif (!__adfs_compare(name, name_len, obj->name, obj->name_len)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tobj->parent_id = ADFS_I(inode)->indaddr;\n\nunlock_relse:\n\tup_read(&adfs_dir_rwsem);\n\tadfs_dir_relse(&dir);\n\treturn ret;\n\nunlock:\n\tup_read(&adfs_dir_rwsem);\n\treturn ret;\n}\n\nconst struct file_operations adfs_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.llseek\t\t= generic_file_llseek,\n\t.iterate_shared\t= adfs_iterate,\n\t.fsync\t\t= generic_file_fsync,\n};\n\nstatic int\nadfs_hash(const struct dentry *parent, struct qstr *qstr)\n{\n\tconst unsigned char *name;\n\tunsigned long hash;\n\tu32 len;\n\n\tif (qstr->len > ADFS_SB(parent->d_sb)->s_namelen)\n\t\treturn -ENAMETOOLONG;\n\n\tlen = qstr->len;\n\tname = qstr->name;\n\thash = init_name_hash(parent);\n\twhile (len--)\n\t\thash = partial_name_hash(adfs_tolower(*name++), hash);\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}\n\n \nstatic int adfs_compare(const struct dentry *dentry, unsigned int len,\n\t\t\tconst char *str, const struct qstr *qstr)\n{\n\treturn __adfs_compare(qstr->name, qstr->len, str, len);\n}\n\nconst struct dentry_operations adfs_dentry_operations = {\n\t.d_hash\t\t= adfs_hash,\n\t.d_compare\t= adfs_compare,\n};\n\nstatic struct dentry *\nadfs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\tstruct object_info obj;\n\tint error;\n\n\terror = adfs_dir_lookup_byname(dir, &dentry->d_name, &obj);\n\tif (error == 0) {\n\t\t \n\t\tinode = adfs_iget(dir->i_sb, &obj);\n\t\tif (!inode)\n\t\t\tinode = ERR_PTR(-EACCES);\n\t} else if (error != -ENOENT) {\n\t\tinode = ERR_PTR(error);\n\t}\n\treturn d_splice_alias(inode, dentry);\n}\n\n \nconst struct inode_operations adfs_dir_inode_operations = {\n\t.lookup\t\t= adfs_lookup,\n\t.setattr\t= adfs_notify_change,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}