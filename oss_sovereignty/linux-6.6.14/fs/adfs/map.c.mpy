{
  "module_name": "map.c",
  "hash_id": "0437a45f5d32d1106932f1810e5edf721da028f51a4f1464819910780bfc8b3d",
  "original_prompt": "Ingested from linux-6.6.14/fs/adfs/map.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <asm/unaligned.h>\n#include \"adfs.h\"\n\n \n\n \nstatic DEFINE_RWLOCK(adfs_map_lock);\n\n \n#define GET_FRAG_ID(_map,_start,_idmask)\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tunsigned char *_m = _map + (_start >> 3);\t\t\\\n\t\tu32 _frag = get_unaligned_le32(_m);\t\t\t\\\n\t\t_frag >>= (_start & 7);\t\t\t\t\t\\\n\t\t_frag & _idmask;\t\t\t\t\t\\\n\t})\n\n \nstatic int lookup_zone(const struct adfs_discmap *dm, const unsigned int idlen,\n\t\t       const u32 frag_id, unsigned int *offset)\n{\n\tconst unsigned int endbit = dm->dm_endbit;\n\tconst u32 idmask = (1 << idlen) - 1;\n\tunsigned char *map = dm->dm_bh->b_data;\n\tunsigned int start = dm->dm_startbit;\n\tunsigned int freelink, fragend;\n\tu32 frag;\n\n\tfrag = GET_FRAG_ID(map, 8, idmask & 0x7fff);\n\tfreelink = frag ? 8 + frag : 0;\n\n\tdo {\n\t\tfrag = GET_FRAG_ID(map, start, idmask);\n\n\t\tfragend = find_next_bit_le(map, endbit, start + idlen);\n\t\tif (fragend >= endbit)\n\t\t\tgoto error;\n\n\t\tif (start == freelink) {\n\t\t\tfreelink += frag & 0x7fff;\n\t\t} else if (frag == frag_id) {\n\t\t\tunsigned int length = fragend + 1 - start;\n\n\t\t\tif (*offset < length)\n\t\t\t\treturn start + *offset;\n\t\t\t*offset -= length;\n\t\t}\n\n\t\tstart = fragend + 1;\n\t} while (start < endbit);\n\treturn -1;\n\nerror:\n\tprintk(KERN_ERR \"adfs: oversized fragment 0x%x at 0x%x-0x%x\\n\",\n\t\tfrag, start, fragend);\n\treturn -1;\n}\n\n \nstatic unsigned int\nscan_free_map(struct adfs_sb_info *asb, struct adfs_discmap *dm)\n{\n\tconst unsigned int endbit = dm->dm_endbit;\n\tconst unsigned int idlen  = asb->s_idlen;\n\tconst unsigned int frag_idlen = idlen <= 15 ? idlen : 15;\n\tconst u32 idmask = (1 << frag_idlen) - 1;\n\tunsigned char *map = dm->dm_bh->b_data;\n\tunsigned int start = 8, fragend;\n\tu32 frag;\n\tunsigned long total = 0;\n\n\t \n\tfrag = GET_FRAG_ID(map, start, idmask);\n\n\t \n\tif (frag == 0)\n\t\treturn 0;\n\n\tdo {\n\t\tstart += frag;\n\n\t\tfrag = GET_FRAG_ID(map, start, idmask);\n\n\t\tfragend = find_next_bit_le(map, endbit, start + idlen);\n\t\tif (fragend >= endbit)\n\t\t\tgoto error;\n\n\t\ttotal += fragend + 1 - start;\n\t} while (frag >= idlen + 1);\n\n\tif (frag != 0)\n\t\tprintk(KERN_ERR \"adfs: undersized free fragment\\n\");\n\n\treturn total;\nerror:\n\tprintk(KERN_ERR \"adfs: oversized free fragment\\n\");\n\treturn 0;\n}\n\nstatic int scan_map(struct adfs_sb_info *asb, unsigned int zone,\n\t\t    const u32 frag_id, unsigned int mapoff)\n{\n\tconst unsigned int idlen = asb->s_idlen;\n\tstruct adfs_discmap *dm, *dm_end;\n\tint result;\n\n\tdm\t= asb->s_map + zone;\n\tzone\t= asb->s_map_size;\n\tdm_end\t= asb->s_map + zone;\n\n\tdo {\n\t\tresult = lookup_zone(dm, idlen, frag_id, &mapoff);\n\n\t\tif (result != -1)\n\t\t\tgoto found;\n\n\t\tdm ++;\n\t\tif (dm == dm_end)\n\t\t\tdm = asb->s_map;\n\t} while (--zone > 0);\n\n\treturn -1;\nfound:\n\tresult -= dm->dm_startbit;\n\tresult += dm->dm_startblk;\n\n\treturn result;\n}\n\n \nvoid adfs_map_statfs(struct super_block *sb, struct kstatfs *buf)\n{\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\tstruct adfs_discrecord *dr = adfs_map_discrecord(asb->s_map);\n\tstruct adfs_discmap *dm;\n\tunsigned int total = 0;\n\tunsigned int zone;\n\n\tdm   = asb->s_map;\n\tzone = asb->s_map_size;\n\n\tdo {\n\t\ttotal += scan_free_map(asb, dm++);\n\t} while (--zone > 0);\n\n\tbuf->f_blocks  = adfs_disc_size(dr) >> sb->s_blocksize_bits;\n\tbuf->f_files   = asb->s_ids_per_zone * asb->s_map_size;\n\tbuf->f_bavail  =\n\tbuf->f_bfree   = signed_asl(total, asb->s_map2blk);\n}\n\nint adfs_map_lookup(struct super_block *sb, u32 frag_id, unsigned int offset)\n{\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\tunsigned int zone, mapoff;\n\tint result;\n\n\t \n\tif (frag_id == ADFS_ROOT_FRAG)\n\t\tzone = asb->s_map_size >> 1;\n\telse\n\t\tzone = frag_id / asb->s_ids_per_zone;\n\n\tif (zone >= asb->s_map_size)\n\t\tgoto bad_fragment;\n\n\t \n\tmapoff = signed_asl(offset, -asb->s_map2blk);\n\n\tread_lock(&adfs_map_lock);\n\tresult = scan_map(asb, zone, frag_id, mapoff);\n\tread_unlock(&adfs_map_lock);\n\n\tif (result > 0) {\n\t\tunsigned int secoff;\n\n\t\t \n\t\tsecoff = offset - signed_asl(mapoff, asb->s_map2blk);\n\t\treturn secoff + signed_asl(result, asb->s_map2blk);\n\t}\n\n\tadfs_error(sb, \"fragment 0x%04x at offset %d not found in map\",\n\t\t   frag_id, offset);\n\treturn 0;\n\nbad_fragment:\n\tadfs_error(sb, \"invalid fragment 0x%04x (zone = %d, max = %d)\",\n\t\t   frag_id, zone, asb->s_map_size);\n\treturn 0;\n}\n\nstatic unsigned char adfs_calczonecheck(struct super_block *sb, unsigned char *map)\n{\n\tunsigned int v0, v1, v2, v3;\n\tint i;\n\n\tv0 = v1 = v2 = v3 = 0;\n\tfor (i = sb->s_blocksize - 4; i; i -= 4) {\n\t\tv0 += map[i]     + (v3 >> 8);\n\t\tv3 &= 0xff;\n\t\tv1 += map[i + 1] + (v0 >> 8);\n\t\tv0 &= 0xff;\n\t\tv2 += map[i + 2] + (v1 >> 8);\n\t\tv1 &= 0xff;\n\t\tv3 += map[i + 3] + (v2 >> 8);\n\t\tv2 &= 0xff;\n\t}\n\tv0 +=           v3 >> 8;\n\tv1 += map[1] + (v0 >> 8);\n\tv2 += map[2] + (v1 >> 8);\n\tv3 += map[3] + (v2 >> 8);\n\n\treturn v0 ^ v1 ^ v2 ^ v3;\n}\n\nstatic int adfs_checkmap(struct super_block *sb, struct adfs_discmap *dm)\n{\n\tunsigned char crosscheck = 0, zonecheck = 1;\n\tint i;\n\n\tfor (i = 0; i < ADFS_SB(sb)->s_map_size; i++) {\n\t\tunsigned char *map;\n\n\t\tmap = dm[i].dm_bh->b_data;\n\n\t\tif (adfs_calczonecheck(sb, map) != map[0]) {\n\t\t\tadfs_error(sb, \"zone %d fails zonecheck\", i);\n\t\t\tzonecheck = 0;\n\t\t}\n\t\tcrosscheck ^= map[3];\n\t}\n\tif (crosscheck != 0xff)\n\t\tadfs_error(sb, \"crosscheck != 0xff\");\n\treturn crosscheck == 0xff && zonecheck;\n}\n\n \nstatic void adfs_map_layout(struct adfs_discmap *dm, unsigned int nzones,\n\t\t\t    struct adfs_discrecord *dr)\n{\n\tunsigned int zone, zone_size;\n\tu64 size;\n\n\tzone_size = (8 << dr->log2secsize) - le16_to_cpu(dr->zone_spare);\n\n\tdm[0].dm_bh       = NULL;\n\tdm[0].dm_startblk = 0;\n\tdm[0].dm_startbit = 32 + ADFS_DR_SIZE_BITS;\n\tdm[0].dm_endbit   = 32 + zone_size;\n\n\tfor (zone = 1; zone < nzones; zone++) {\n\t\tdm[zone].dm_bh       = NULL;\n\t\tdm[zone].dm_startblk = zone * zone_size - ADFS_DR_SIZE_BITS;\n\t\tdm[zone].dm_startbit = 32;\n\t\tdm[zone].dm_endbit   = 32 + zone_size;\n\t}\n\n\tsize = adfs_disc_size(dr) >> dr->log2bpmb;\n\tsize -= (nzones - 1) * zone_size - ADFS_DR_SIZE_BITS;\n\tdm[nzones - 1].dm_endbit = 32 + size;\n}\n\nstatic int adfs_map_read(struct adfs_discmap *dm, struct super_block *sb,\n\t\t\t unsigned int map_addr, unsigned int nzones)\n{\n\tunsigned int zone;\n\n\tfor (zone = 0; zone < nzones; zone++) {\n\t\tdm[zone].dm_bh = sb_bread(sb, map_addr + zone);\n\t\tif (!dm[zone].dm_bh)\n\t\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void adfs_map_relse(struct adfs_discmap *dm, unsigned int nzones)\n{\n\tunsigned int zone;\n\n\tfor (zone = 0; zone < nzones; zone++)\n\t\tbrelse(dm[zone].dm_bh);\n}\n\nstruct adfs_discmap *adfs_read_map(struct super_block *sb, struct adfs_discrecord *dr)\n{\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\tstruct adfs_discmap *dm;\n\tunsigned int map_addr, zone_size, nzones;\n\tint ret;\n\n\tnzones    = dr->nzones | dr->nzones_high << 8;\n\tzone_size = (8 << dr->log2secsize) - le16_to_cpu(dr->zone_spare);\n\n\tasb->s_idlen = dr->idlen;\n\tasb->s_map_size = nzones;\n\tasb->s_map2blk = dr->log2bpmb - dr->log2secsize;\n\tasb->s_log2sharesize = dr->log2sharesize;\n\tasb->s_ids_per_zone = zone_size / (asb->s_idlen + 1);\n\n\tmap_addr = (nzones >> 1) * zone_size -\n\t\t     ((nzones > 1) ? ADFS_DR_SIZE_BITS : 0);\n\tmap_addr = signed_asl(map_addr, asb->s_map2blk);\n\n\tdm = kmalloc_array(nzones, sizeof(*dm), GFP_KERNEL);\n\tif (dm == NULL) {\n\t\tadfs_error(sb, \"not enough memory\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tadfs_map_layout(dm, nzones, dr);\n\n\tret = adfs_map_read(dm, sb, map_addr, nzones);\n\tif (ret) {\n\t\tadfs_error(sb, \"unable to read map\");\n\t\tgoto error_free;\n\t}\n\n\tif (adfs_checkmap(sb, dm))\n\t\treturn dm;\n\n\tadfs_error(sb, \"map corrupted\");\n\nerror_free:\n\tadfs_map_relse(dm, nzones);\n\tkfree(dm);\n\treturn ERR_PTR(-EIO);\n}\n\nvoid adfs_free_map(struct super_block *sb)\n{\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\tadfs_map_relse(asb->s_map, asb->s_map_size);\n\tkfree(asb->s_map);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}