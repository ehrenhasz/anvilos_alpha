{
  "module_name": "inode.c",
  "hash_id": "0ebcad4ff777bb037f6674d2d22484bc8d46f327710b657209c474116b8d9fbb",
  "original_prompt": "Ingested from linux-6.6.14/fs/tracefs/inode.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/kobject.h>\n#include <linux/namei.h>\n#include <linux/tracefs.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include \"internal.h\"\n\n#define TRACEFS_DEFAULT_MODE\t0700\nstatic struct kmem_cache *tracefs_inode_cachep __ro_after_init;\n\nstatic struct vfsmount *tracefs_mount;\nstatic int tracefs_mount_count;\nstatic bool tracefs_registered;\n\nstatic struct inode *tracefs_alloc_inode(struct super_block *sb)\n{\n\tstruct tracefs_inode *ti;\n\n\tti = kmem_cache_alloc(tracefs_inode_cachep, GFP_KERNEL);\n\tif (!ti)\n\t\treturn NULL;\n\n\tti->flags = 0;\n\n\treturn &ti->vfs_inode;\n}\n\nstatic void tracefs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(tracefs_inode_cachep, get_tracefs(inode));\n}\n\nstatic ssize_t default_read_file(struct file *file, char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\treturn 0;\n}\n\nstatic ssize_t default_write_file(struct file *file, const char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\treturn count;\n}\n\nstatic const struct file_operations tracefs_file_operations = {\n\t.read =\t\tdefault_read_file,\n\t.write =\tdefault_write_file,\n\t.open =\t\tsimple_open,\n\t.llseek =\tnoop_llseek,\n};\n\nstatic struct tracefs_dir_ops {\n\tint (*mkdir)(const char *name);\n\tint (*rmdir)(const char *name);\n} tracefs_ops __ro_after_init;\n\nstatic char *get_dname(struct dentry *dentry)\n{\n\tconst char *dname;\n\tchar *name;\n\tint len = dentry->d_name.len;\n\n\tdname = dentry->d_name.name;\n\tname = kmalloc(len + 1, GFP_KERNEL);\n\tif (!name)\n\t\treturn NULL;\n\tmemcpy(name, dname, len);\n\tname[len] = 0;\n\treturn name;\n}\n\nstatic int tracefs_syscall_mkdir(struct mnt_idmap *idmap,\n\t\t\t\t struct inode *inode, struct dentry *dentry,\n\t\t\t\t umode_t mode)\n{\n\tchar *name;\n\tint ret;\n\n\tname = get_dname(dentry);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\t \n\tinode_unlock(inode);\n\tret = tracefs_ops.mkdir(name);\n\tinode_lock(inode);\n\n\tkfree(name);\n\n\treturn ret;\n}\n\nstatic int tracefs_syscall_rmdir(struct inode *inode, struct dentry *dentry)\n{\n\tchar *name;\n\tint ret;\n\n\tname = get_dname(dentry);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\t \n\tinode_unlock(inode);\n\tinode_unlock(d_inode(dentry));\n\n\tret = tracefs_ops.rmdir(name);\n\n\tinode_lock_nested(inode, I_MUTEX_PARENT);\n\tinode_lock(d_inode(dentry));\n\n\tkfree(name);\n\n\treturn ret;\n}\n\nstatic const struct inode_operations tracefs_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n\t.mkdir\t\t= tracefs_syscall_mkdir,\n\t.rmdir\t\t= tracefs_syscall_rmdir,\n};\n\nstruct inode *tracefs_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\t}\n\treturn inode;\n}\n\nstruct tracefs_mount_opts {\n\tkuid_t uid;\n\tkgid_t gid;\n\tumode_t mode;\n\t \n\tunsigned int opts;\n};\n\nenum {\n\tOpt_uid,\n\tOpt_gid,\n\tOpt_mode,\n\tOpt_err\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_err, NULL}\n};\n\nstruct tracefs_fs_info {\n\tstruct tracefs_mount_opts mount_opts;\n};\n\nstatic void change_gid(struct dentry *dentry, kgid_t gid)\n{\n\tif (!dentry->d_inode)\n\t\treturn;\n\tdentry->d_inode->i_gid = gid;\n}\n\n \nstatic void set_gid(struct dentry *parent, kgid_t gid)\n{\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\n\tthis_parent = parent;\n\tspin_lock(&this_parent->d_lock);\n\n\tchange_gid(this_parent, gid);\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry, d_child);\n\t\tnext = tmp->next;\n\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\n\t\tchange_gid(dentry, gid);\n\n\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\tspin_release(&dentry->d_lock.dep_map, _RET_IP_);\n\t\t\tthis_parent = dentry;\n\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1, _RET_IP_);\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\t \n\trcu_read_lock();\nascend:\n\tif (this_parent != parent) {\n\t\tstruct dentry *child = this_parent;\n\t\tthis_parent = child->d_parent;\n\n\t\tspin_unlock(&child->d_lock);\n\t\tspin_lock(&this_parent->d_lock);\n\n\t\t \n\t\tdo {\n\t\t\tnext = child->d_child.next;\n\t\t\tif (next == &this_parent->d_subdirs)\n\t\t\t\tgoto ascend;\n\t\t\tchild = list_entry(next, struct dentry, d_child);\n\t\t} while (unlikely(child->d_flags & DCACHE_DENTRY_KILLED));\n\t\trcu_read_unlock();\n\t\tgoto resume;\n\t}\n\trcu_read_unlock();\n\tspin_unlock(&this_parent->d_lock);\n\treturn;\n}\n\nstatic int tracefs_parse_options(char *data, struct tracefs_mount_opts *opts)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tint token;\n\tkuid_t uid;\n\tkgid_t gid;\n\tchar *p;\n\n\topts->opts = 0;\n\topts->mode = TRACEFS_DEFAULT_MODE;\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->uid = uid;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->gid = gid;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\t \n\t\t}\n\n\t\topts->opts |= BIT(token);\n\t}\n\n\treturn 0;\n}\n\nstatic int tracefs_apply_options(struct super_block *sb, bool remount)\n{\n\tstruct tracefs_fs_info *fsi = sb->s_fs_info;\n\tstruct inode *inode = d_inode(sb->s_root);\n\tstruct tracefs_mount_opts *opts = &fsi->mount_opts;\n\tumode_t tmp_mode;\n\n\t \n\n\tif (!remount || opts->opts & BIT(Opt_mode)) {\n\t\ttmp_mode = READ_ONCE(inode->i_mode) & ~S_IALLUGO;\n\t\ttmp_mode |= opts->mode;\n\t\tWRITE_ONCE(inode->i_mode, tmp_mode);\n\t}\n\n\tif (!remount || opts->opts & BIT(Opt_uid))\n\t\tinode->i_uid = opts->uid;\n\n\tif (!remount || opts->opts & BIT(Opt_gid)) {\n\t\t \n\t\tset_gid(sb->s_root, opts->gid);\n\t}\n\n\treturn 0;\n}\n\nstatic int tracefs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tint err;\n\tstruct tracefs_fs_info *fsi = sb->s_fs_info;\n\n\tsync_filesystem(sb);\n\terr = tracefs_parse_options(data, &fsi->mount_opts);\n\tif (err)\n\t\tgoto fail;\n\n\ttracefs_apply_options(sb, true);\n\nfail:\n\treturn err;\n}\n\nstatic int tracefs_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct tracefs_fs_info *fsi = root->d_sb->s_fs_info;\n\tstruct tracefs_mount_opts *opts = &fsi->mount_opts;\n\n\tif (!uid_eq(opts->uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(m, \",uid=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns, opts->uid));\n\tif (!gid_eq(opts->gid, GLOBAL_ROOT_GID))\n\t\tseq_printf(m, \",gid=%u\",\n\t\t\t   from_kgid_munged(&init_user_ns, opts->gid));\n\tif (opts->mode != TRACEFS_DEFAULT_MODE)\n\t\tseq_printf(m, \",mode=%o\", opts->mode);\n\n\treturn 0;\n}\n\nstatic const struct super_operations tracefs_super_operations = {\n\t.alloc_inode    = tracefs_alloc_inode,\n\t.free_inode     = tracefs_free_inode,\n\t.drop_inode     = generic_delete_inode,\n\t.statfs\t\t= simple_statfs,\n\t.remount_fs\t= tracefs_remount,\n\t.show_options\t= tracefs_show_options,\n};\n\nstatic void tracefs_dentry_iput(struct dentry *dentry, struct inode *inode)\n{\n\tstruct tracefs_inode *ti;\n\n\tif (!dentry || !inode)\n\t\treturn;\n\n\tti = get_tracefs(inode);\n\tif (ti && ti->flags & TRACEFS_EVENT_INODE)\n\t\teventfs_set_ef_status_free(ti, dentry);\n\tiput(inode);\n}\n\nstatic const struct dentry_operations tracefs_dentry_operations = {\n\t.d_iput = tracefs_dentry_iput,\n};\n\nstatic int trace_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstatic const struct tree_descr trace_files[] = {{\"\"}};\n\tstruct tracefs_fs_info *fsi;\n\tint err;\n\n\tfsi = kzalloc(sizeof(struct tracefs_fs_info), GFP_KERNEL);\n\tsb->s_fs_info = fsi;\n\tif (!fsi) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\terr = tracefs_parse_options(data, &fsi->mount_opts);\n\tif (err)\n\t\tgoto fail;\n\n\terr  =  simple_fill_super(sb, TRACEFS_MAGIC, trace_files);\n\tif (err)\n\t\tgoto fail;\n\n\tsb->s_op = &tracefs_super_operations;\n\tsb->s_d_op = &tracefs_dentry_operations;\n\n\ttracefs_apply_options(sb, false);\n\n\treturn 0;\n\nfail:\n\tkfree(fsi);\n\tsb->s_fs_info = NULL;\n\treturn err;\n}\n\nstatic struct dentry *trace_mount(struct file_system_type *fs_type,\n\t\t\tint flags, const char *dev_name,\n\t\t\tvoid *data)\n{\n\treturn mount_single(fs_type, flags, data, trace_fill_super);\n}\n\nstatic struct file_system_type trace_fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"tracefs\",\n\t.mount =\ttrace_mount,\n\t.kill_sb =\tkill_litter_super,\n};\nMODULE_ALIAS_FS(\"tracefs\");\n\nstruct dentry *tracefs_start_creating(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tpr_debug(\"tracefs: creating file '%s'\\n\",name);\n\n\terror = simple_pin_fs(&trace_fs_type, &tracefs_mount,\n\t\t\t      &tracefs_mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t \n\tif (!parent)\n\t\tparent = tracefs_mount->mnt_root;\n\n\tinode_lock(d_inode(parent));\n\tif (unlikely(IS_DEADDIR(d_inode(parent))))\n\t\tdentry = ERR_PTR(-ENOENT);\n\telse\n\t\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (!IS_ERR(dentry) && d_inode(dentry)) {\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(-EEXIST);\n\t}\n\n\tif (IS_ERR(dentry)) {\n\t\tinode_unlock(d_inode(parent));\n\t\tsimple_release_fs(&tracefs_mount, &tracefs_mount_count);\n\t}\n\n\treturn dentry;\n}\n\nstruct dentry *tracefs_failed_creating(struct dentry *dentry)\n{\n\tinode_unlock(d_inode(dentry->d_parent));\n\tdput(dentry);\n\tsimple_release_fs(&tracefs_mount, &tracefs_mount_count);\n\treturn NULL;\n}\n\nstruct dentry *tracefs_end_creating(struct dentry *dentry)\n{\n\tinode_unlock(d_inode(dentry->d_parent));\n\treturn dentry;\n}\n\n \nstruct dentry *eventfs_start_creating(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\t \n\tif (WARN_ON_ONCE(!parent))\n\t\treturn ERR_PTR(-EINVAL);\n\n\terror = simple_pin_fs(&trace_fs_type, &tracefs_mount,\n\t\t\t      &tracefs_mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tif (unlikely(IS_DEADDIR(parent->d_inode)))\n\t\tdentry = ERR_PTR(-ENOENT);\n\telse\n\t\tdentry = lookup_one_len(name, parent, strlen(name));\n\n\tif (!IS_ERR(dentry) && dentry->d_inode) {\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(-EEXIST);\n\t}\n\n\tif (IS_ERR(dentry))\n\t\tsimple_release_fs(&tracefs_mount, &tracefs_mount_count);\n\n\treturn dentry;\n}\n\n \nstruct dentry *eventfs_failed_creating(struct dentry *dentry)\n{\n\tdput(dentry);\n\tsimple_release_fs(&tracefs_mount, &tracefs_mount_count);\n\treturn NULL;\n}\n\n \nstruct dentry *eventfs_end_creating(struct dentry *dentry)\n{\n\treturn dentry;\n}\n\n \nstruct dentry *tracefs_create_file(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS))\n\t\treturn NULL;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = tracefs_start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = tracefs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn tracefs_failed_creating(dentry);\n\n\tinode->i_mode = mode;\n\tinode->i_fop = fops ? fops : &tracefs_file_operations;\n\tinode->i_private = data;\n\tinode->i_uid = d_inode(dentry->d_parent)->i_uid;\n\tinode->i_gid = d_inode(dentry->d_parent)->i_gid;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(d_inode(dentry->d_parent), dentry);\n\treturn tracefs_end_creating(dentry);\n}\n\nstatic struct dentry *__create_dir(const char *name, struct dentry *parent,\n\t\t\t\t   const struct inode_operations *ops)\n{\n\tstruct dentry *dentry = tracefs_start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = tracefs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn tracefs_failed_creating(dentry);\n\n\t \n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUSR| S_IRGRP | S_IXUSR | S_IXGRP;\n\tinode->i_op = ops;\n\tinode->i_fop = &simple_dir_operations;\n\tinode->i_uid = d_inode(dentry->d_parent)->i_uid;\n\tinode->i_gid = d_inode(dentry->d_parent)->i_gid;\n\n\t \n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(d_inode(dentry->d_parent));\n\tfsnotify_mkdir(d_inode(dentry->d_parent), dentry);\n\treturn tracefs_end_creating(dentry);\n}\n\n \nstruct dentry *tracefs_create_dir(const char *name, struct dentry *parent)\n{\n\tif (security_locked_down(LOCKDOWN_TRACEFS))\n\t\treturn NULL;\n\n\treturn __create_dir(name, parent, &simple_dir_inode_operations);\n}\n\n \n__init struct dentry *tracefs_create_instance_dir(const char *name,\n\t\t\t\t\t  struct dentry *parent,\n\t\t\t\t\t  int (*mkdir)(const char *name),\n\t\t\t\t\t  int (*rmdir)(const char *name))\n{\n\tstruct dentry *dentry;\n\n\t \n\tif (WARN_ON(tracefs_ops.mkdir || tracefs_ops.rmdir))\n\t\treturn NULL;\n\n\tdentry = __create_dir(name, parent, &tracefs_dir_inode_operations);\n\tif (!dentry)\n\t\treturn NULL;\n\n\ttracefs_ops.mkdir = mkdir;\n\ttracefs_ops.rmdir = rmdir;\n\n\treturn dentry;\n}\n\nstatic void remove_one(struct dentry *victim)\n{\n\tsimple_release_fs(&tracefs_mount, &tracefs_mount_count);\n}\n\n \nvoid tracefs_remove(struct dentry *dentry)\n{\n\tif (IS_ERR_OR_NULL(dentry))\n\t\treturn;\n\n\tsimple_pin_fs(&trace_fs_type, &tracefs_mount, &tracefs_mount_count);\n\tsimple_recursive_removal(dentry, remove_one);\n\tsimple_release_fs(&tracefs_mount, &tracefs_mount_count);\n}\n\n \nbool tracefs_initialized(void)\n{\n\treturn tracefs_registered;\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct tracefs_inode *ti = (struct tracefs_inode *) foo;\n\n\tinode_init_once(&ti->vfs_inode);\n}\n\nstatic int __init tracefs_init(void)\n{\n\tint retval;\n\n\ttracefs_inode_cachep = kmem_cache_create(\"tracefs_inode_cache\",\n\t\t\t\t\t\t sizeof(struct tracefs_inode),\n\t\t\t\t\t\t 0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\t     SLAB_MEM_SPREAD|\n\t\t\t\t\t\t     SLAB_ACCOUNT),\n\t\t\t\t\t\t init_once);\n\tif (!tracefs_inode_cachep)\n\t\treturn -ENOMEM;\n\n\tretval = sysfs_create_mount_point(kernel_kobj, \"tracing\");\n\tif (retval)\n\t\treturn -EINVAL;\n\n\tretval = register_filesystem(&trace_fs_type);\n\tif (!retval)\n\t\ttracefs_registered = true;\n\n\treturn retval;\n}\ncore_initcall(tracefs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}