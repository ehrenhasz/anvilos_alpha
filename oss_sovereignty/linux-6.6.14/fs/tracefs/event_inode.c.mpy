{
  "module_name": "event_inode.c",
  "hash_id": "496a5428ac9697f4e125655aafefe589d111258fec07d7f54119e1ee53fd9b71",
  "original_prompt": "Ingested from linux-6.6.14/fs/tracefs/event_inode.c",
  "human_readable_source": "\n \n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/tracefs.h>\n#include <linux/kref.h>\n#include <linux/delay.h>\n#include \"internal.h\"\n\nstruct eventfs_inode {\n\tstruct list_head\te_top_files;\n};\n\n \nstruct eventfs_file {\n\tconst char\t\t\t*name;\n\tstruct dentry\t\t\t*d_parent;\n\tstruct dentry\t\t\t*dentry;\n\tstruct list_head\t\tlist;\n\tstruct eventfs_inode\t\t*ei;\n\tconst struct file_operations\t*fop;\n\tconst struct inode_operations\t*iop;\n\t \n\tunion {\n\t\tstruct llist_node\tllist;\n\t\tstruct rcu_head\t\trcu;\n\t};\n\tvoid\t\t\t\t*data;\n\tunsigned int\t\t\tis_freed:1;\n\tunsigned int\t\t\tmode:31;\n\tkuid_t\t\t\t\tuid;\n\tkgid_t\t\t\t\tgid;\n};\n\nstatic DEFINE_MUTEX(eventfs_mutex);\nDEFINE_STATIC_SRCU(eventfs_srcu);\n\n \nenum {\n\tEVENTFS_SAVE_MODE\t= BIT(16),\n\tEVENTFS_SAVE_UID\t= BIT(17),\n\tEVENTFS_SAVE_GID\t= BIT(18),\n};\n\n#define EVENTFS_MODE_MASK\t(EVENTFS_SAVE_MODE - 1)\n\nstatic struct dentry *eventfs_root_lookup(struct inode *dir,\n\t\t\t\t\t  struct dentry *dentry,\n\t\t\t\t\t  unsigned int flags);\nstatic int dcache_dir_open_wrapper(struct inode *inode, struct file *file);\nstatic int dcache_readdir_wrapper(struct file *file, struct dir_context *ctx);\nstatic int eventfs_release(struct inode *inode, struct file *file);\n\nstatic void update_attr(struct eventfs_file *ef, struct iattr *iattr)\n{\n\tunsigned int ia_valid = iattr->ia_valid;\n\n\tif (ia_valid & ATTR_MODE) {\n\t\tef->mode = (ef->mode & ~EVENTFS_MODE_MASK) |\n\t\t\t(iattr->ia_mode & EVENTFS_MODE_MASK) |\n\t\t\tEVENTFS_SAVE_MODE;\n\t}\n\tif (ia_valid & ATTR_UID) {\n\t\tef->mode |= EVENTFS_SAVE_UID;\n\t\tef->uid = iattr->ia_uid;\n\t}\n\tif (ia_valid & ATTR_GID) {\n\t\tef->mode |= EVENTFS_SAVE_GID;\n\t\tef->gid = iattr->ia_gid;\n\t}\n}\n\nstatic int eventfs_set_attr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t\t     struct iattr *iattr)\n{\n\tstruct eventfs_file *ef;\n\tint ret;\n\n\tmutex_lock(&eventfs_mutex);\n\tef = dentry->d_fsdata;\n\tif (ef && ef->is_freed) {\n\t\t \n\t\tmutex_unlock(&eventfs_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tret = simple_setattr(idmap, dentry, iattr);\n\tif (!ret && ef)\n\t\tupdate_attr(ef, iattr);\n\tmutex_unlock(&eventfs_mutex);\n\treturn ret;\n}\n\nstatic const struct inode_operations eventfs_root_dir_inode_operations = {\n\t.lookup\t\t= eventfs_root_lookup,\n\t.setattr\t= eventfs_set_attr,\n};\n\nstatic const struct inode_operations eventfs_file_inode_operations = {\n\t.setattr\t= eventfs_set_attr,\n};\n\nstatic const struct file_operations eventfs_file_operations = {\n\t.open\t\t= dcache_dir_open_wrapper,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= dcache_readdir_wrapper,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= eventfs_release,\n};\n\nstatic void update_inode_attr(struct inode *inode, struct eventfs_file *ef)\n{\n\tinode->i_mode = ef->mode & EVENTFS_MODE_MASK;\n\n\tif (ef->mode & EVENTFS_SAVE_UID)\n\t\tinode->i_uid = ef->uid;\n\n\tif (ef->mode & EVENTFS_SAVE_GID)\n\t\tinode->i_gid = ef->gid;\n}\n\n \nstatic struct dentry *create_file(struct eventfs_file *ef,\n\t\t\t\t  struct dentry *parent, void *data,\n\t\t\t\t  const struct file_operations *fop)\n{\n\tstruct tracefs_inode *ti;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(ef->mode & S_IFMT))\n\t\tef->mode |= S_IFREG;\n\n\tif (WARN_ON_ONCE(!S_ISREG(ef->mode)))\n\t\treturn NULL;\n\n\tdentry = eventfs_start_creating(ef->name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn dentry;\n\n\tinode = tracefs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn eventfs_failed_creating(dentry);\n\n\t \n\tupdate_inode_attr(inode, ef);\n\n\tinode->i_op = &eventfs_file_inode_operations;\n\tinode->i_fop = fop;\n\tinode->i_private = data;\n\n\tti = get_tracefs(inode);\n\tti->flags |= TRACEFS_EVENT_INODE;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(dentry->d_parent->d_inode, dentry);\n\treturn eventfs_end_creating(dentry);\n};\n\n \nstatic struct dentry *create_dir(struct eventfs_file *ef,\n\t\t\t\t struct dentry *parent, void *data)\n{\n\tstruct tracefs_inode *ti;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tdentry = eventfs_start_creating(ef->name, parent);\n\tif (IS_ERR(dentry))\n\t\treturn dentry;\n\n\tinode = tracefs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn eventfs_failed_creating(dentry);\n\n\tupdate_inode_attr(inode, ef);\n\n\tinode->i_op = &eventfs_root_dir_inode_operations;\n\tinode->i_fop = &eventfs_file_operations;\n\tinode->i_private = data;\n\n\tti = get_tracefs(inode);\n\tti->flags |= TRACEFS_EVENT_INODE;\n\n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(dentry->d_parent->d_inode);\n\tfsnotify_mkdir(dentry->d_parent->d_inode, dentry);\n\treturn eventfs_end_creating(dentry);\n}\n\nstatic void free_ef(struct eventfs_file *ef)\n{\n\tkfree(ef->name);\n\tkfree(ef->ei);\n\tkfree(ef);\n}\n\n \nvoid eventfs_set_ef_status_free(struct tracefs_inode *ti, struct dentry *dentry)\n{\n\tstruct eventfs_inode *ei;\n\tstruct eventfs_file *ef;\n\n\t \n\tif (unlikely(ti->flags & TRACEFS_EVENT_TOP_INODE)) {\n\t\tmutex_lock(&eventfs_mutex);\n\t\tei = ti->private;\n\n\t\t \n\t\tti->private = NULL;\n\t\tmutex_unlock(&eventfs_mutex);\n\n\t\tef = dentry->d_fsdata;\n\t\tif (ef)\n\t\t\tfree_ef(ef);\n\t\treturn;\n\t}\n\n\tmutex_lock(&eventfs_mutex);\n\n\tef = dentry->d_fsdata;\n\tif (!ef)\n\t\tgoto out;\n\n\tif (ef->is_freed) {\n\t\tfree_ef(ef);\n\t} else {\n\t\tef->dentry = NULL;\n\t}\n\n\tdentry->d_fsdata = NULL;\nout:\n\tmutex_unlock(&eventfs_mutex);\n}\n\n \nstatic void eventfs_post_create_dir(struct eventfs_file *ef)\n{\n\tstruct eventfs_file *ef_child;\n\tstruct tracefs_inode *ti;\n\n\t \n\t \n\tlist_for_each_entry_srcu(ef_child, &ef->ei->e_top_files, list,\n\t\t\t\t srcu_read_lock_held(&eventfs_srcu)) {\n\t\tef_child->d_parent = ef->dentry;\n\t}\n\n\tti = get_tracefs(ef->dentry->d_inode);\n\tti->private = ef->ei;\n}\n\n \nstatic struct dentry *\ncreate_dentry(struct eventfs_file *ef, struct dentry *parent, bool lookup)\n{\n\tbool invalidate = false;\n\tstruct dentry *dentry;\n\n\tmutex_lock(&eventfs_mutex);\n\tif (ef->is_freed) {\n\t\tmutex_unlock(&eventfs_mutex);\n\t\treturn NULL;\n\t}\n\tif (ef->dentry) {\n\t\tdentry = ef->dentry;\n\t\t \n\t\tif (!lookup)\n\t\t\tdget(dentry);\n\t\tmutex_unlock(&eventfs_mutex);\n\t\treturn dentry;\n\t}\n\tmutex_unlock(&eventfs_mutex);\n\n\tif (!lookup)\n\t\tinode_lock(parent->d_inode);\n\n\tif (ef->ei)\n\t\tdentry = create_dir(ef, parent, ef->data);\n\telse\n\t\tdentry = create_file(ef, parent, ef->data, ef->fop);\n\n\tif (!lookup)\n\t\tinode_unlock(parent->d_inode);\n\n\tmutex_lock(&eventfs_mutex);\n\tif (IS_ERR_OR_NULL(dentry)) {\n\t\t \n\t\tdentry = ef->dentry;\n\t\tif (dentry && !lookup)\n\t\t\tdget(dentry);\n\t\tmutex_unlock(&eventfs_mutex);\n\t\treturn dentry;\n\t}\n\n\tif (!ef->dentry && !ef->is_freed) {\n\t\tef->dentry = dentry;\n\t\tif (ef->ei)\n\t\t\teventfs_post_create_dir(ef);\n\t\tdentry->d_fsdata = ef;\n\t} else {\n\t\t \n\t\tinvalidate = true;\n\n\t\t \n\t\tWARN_ON_ONCE(!ef->is_freed);\n\t}\n\tmutex_unlock(&eventfs_mutex);\n\tif (invalidate)\n\t\td_invalidate(dentry);\n\n\tif (lookup || invalidate)\n\t\tdput(dentry);\n\n\treturn invalidate ? NULL : dentry;\n}\n\nstatic bool match_event_file(struct eventfs_file *ef, const char *name)\n{\n\tbool ret;\n\n\tmutex_lock(&eventfs_mutex);\n\tret = !ef->is_freed && strcmp(ef->name, name) == 0;\n\tmutex_unlock(&eventfs_mutex);\n\n\treturn ret;\n}\n\n \nstatic struct dentry *eventfs_root_lookup(struct inode *dir,\n\t\t\t\t\t  struct dentry *dentry,\n\t\t\t\t\t  unsigned int flags)\n{\n\tstruct tracefs_inode *ti;\n\tstruct eventfs_inode *ei;\n\tstruct eventfs_file *ef;\n\tstruct dentry *ret = NULL;\n\tint idx;\n\n\tti = get_tracefs(dir);\n\tif (!(ti->flags & TRACEFS_EVENT_INODE))\n\t\treturn NULL;\n\n\tei = ti->private;\n\tidx = srcu_read_lock(&eventfs_srcu);\n\tlist_for_each_entry_srcu(ef, &ei->e_top_files, list,\n\t\t\t\t srcu_read_lock_held(&eventfs_srcu)) {\n\t\tif (!match_event_file(ef, dentry->d_name.name))\n\t\t\tcontinue;\n\t\tret = simple_lookup(dir, dentry, flags);\n\t\tcreate_dentry(ef, ef->d_parent, true);\n\t\tbreak;\n\t}\n\tsrcu_read_unlock(&eventfs_srcu, idx);\n\treturn ret;\n}\n\nstruct dentry_list {\n\tvoid\t\t\t*cursor;\n\tstruct dentry\t\t**dentries;\n};\n\n \nstatic int eventfs_release(struct inode *inode, struct file *file)\n{\n\tstruct tracefs_inode *ti;\n\tstruct dentry_list *dlist = file->private_data;\n\tvoid *cursor;\n\tint i;\n\n\tti = get_tracefs(inode);\n\tif (!(ti->flags & TRACEFS_EVENT_INODE))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON_ONCE(!dlist))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; dlist->dentries && dlist->dentries[i]; i++) {\n\t\tdput(dlist->dentries[i]);\n\t}\n\n\tcursor = dlist->cursor;\n\tkfree(dlist->dentries);\n\tkfree(dlist);\n\tfile->private_data = cursor;\n\treturn dcache_dir_close(inode, file);\n}\n\n \nstatic int dcache_dir_open_wrapper(struct inode *inode, struct file *file)\n{\n\tstruct tracefs_inode *ti;\n\tstruct eventfs_inode *ei;\n\tstruct eventfs_file *ef;\n\tstruct dentry_list *dlist;\n\tstruct dentry **dentries = NULL;\n\tstruct dentry *dentry = file_dentry(file);\n\tstruct dentry *d;\n\tstruct inode *f_inode = file_inode(file);\n\tint cnt = 0;\n\tint idx;\n\tint ret;\n\n\tti = get_tracefs(f_inode);\n\tif (!(ti->flags & TRACEFS_EVENT_INODE))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON_ONCE(file->private_data))\n\t\treturn -EINVAL;\n\n\tdlist = kmalloc(sizeof(*dlist), GFP_KERNEL);\n\tif (!dlist)\n\t\treturn -ENOMEM;\n\n\tei = ti->private;\n\tidx = srcu_read_lock(&eventfs_srcu);\n\tlist_for_each_entry_srcu(ef, &ei->e_top_files, list,\n\t\t\t\t srcu_read_lock_held(&eventfs_srcu)) {\n\t\td = create_dentry(ef, dentry, false);\n\t\tif (d) {\n\t\t\tstruct dentry **tmp;\n\n\n\t\t\ttmp = krealloc(dentries, sizeof(d) * (cnt + 2), GFP_KERNEL);\n\t\t\tif (!tmp)\n\t\t\t\tbreak;\n\t\t\ttmp[cnt] = d;\n\t\t\ttmp[cnt + 1] = NULL;\n\t\t\tcnt++;\n\t\t\tdentries = tmp;\n\t\t}\n\t}\n\tsrcu_read_unlock(&eventfs_srcu, idx);\n\tret = dcache_dir_open(inode, file);\n\n\t \n\tdlist->cursor = file->private_data;\n\tdlist->dentries = dentries;\n\tfile->private_data = dlist;\n\treturn ret;\n}\n\n \nstatic int dcache_readdir_wrapper(struct file *file, struct dir_context *ctx)\n{\n\tstruct dentry_list *dlist = file->private_data;\n\tint ret;\n\n\tfile->private_data = dlist->cursor;\n\tret = dcache_readdir(file, ctx);\n\tdlist->cursor = file->private_data;\n\tfile->private_data = dlist;\n\treturn ret;\n}\n\n \nstatic struct eventfs_file *eventfs_prepare_ef(const char *name, umode_t mode,\n\t\t\t\t\tconst struct file_operations *fop,\n\t\t\t\t\tconst struct inode_operations *iop,\n\t\t\t\t\tvoid *data)\n{\n\tstruct eventfs_file *ef;\n\n\tef = kzalloc(sizeof(*ef), GFP_KERNEL);\n\tif (!ef)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tef->name = kstrdup(name, GFP_KERNEL);\n\tif (!ef->name) {\n\t\tkfree(ef);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\tef->ei = kzalloc(sizeof(*ef->ei), GFP_KERNEL);\n\t\tif (!ef->ei) {\n\t\t\tkfree(ef->name);\n\t\t\tkfree(ef);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\tINIT_LIST_HEAD(&ef->ei->e_top_files);\n\t\tef->mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\t} else {\n\t\tef->ei = NULL;\n\t\tef->mode = mode;\n\t}\n\n\tef->iop = iop;\n\tef->fop = fop;\n\tef->data = data;\n\treturn ef;\n}\n\n \nstruct dentry *eventfs_create_events_dir(const char *name,\n\t\t\t\t\t struct dentry *parent)\n{\n\tstruct dentry *dentry = tracefs_start_creating(name, parent);\n\tstruct eventfs_inode *ei;\n\tstruct tracefs_inode *ti;\n\tstruct inode *inode;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS))\n\t\treturn NULL;\n\n\tif (IS_ERR(dentry))\n\t\treturn dentry;\n\n\tei = kzalloc(sizeof(*ei), GFP_KERNEL);\n\tif (!ei)\n\t\treturn ERR_PTR(-ENOMEM);\n\tinode = tracefs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode)) {\n\t\tkfree(ei);\n\t\ttracefs_failed_creating(dentry);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tINIT_LIST_HEAD(&ei->e_top_files);\n\n\tti = get_tracefs(inode);\n\tti->flags |= TRACEFS_EVENT_INODE | TRACEFS_EVENT_TOP_INODE;\n\tti->private = ei;\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_op = &eventfs_root_dir_inode_operations;\n\tinode->i_fop = &eventfs_file_operations;\n\n\t \n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(dentry->d_parent->d_inode);\n\tfsnotify_mkdir(dentry->d_parent->d_inode, dentry);\n\treturn tracefs_end_creating(dentry);\n}\n\n \nstruct eventfs_file *eventfs_add_subsystem_dir(const char *name,\n\t\t\t\t\t       struct dentry *parent)\n{\n\tstruct tracefs_inode *ti_parent;\n\tstruct eventfs_inode *ei_parent;\n\tstruct eventfs_file *ef;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS))\n\t\treturn NULL;\n\n\tif (!parent)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tti_parent = get_tracefs(parent->d_inode);\n\tei_parent = ti_parent->private;\n\n\tef = eventfs_prepare_ef(name, S_IFDIR, NULL, NULL, NULL);\n\tif (IS_ERR(ef))\n\t\treturn ef;\n\n\tmutex_lock(&eventfs_mutex);\n\tlist_add_tail(&ef->list, &ei_parent->e_top_files);\n\tef->d_parent = parent;\n\tmutex_unlock(&eventfs_mutex);\n\treturn ef;\n}\n\n \nstruct eventfs_file *eventfs_add_dir(const char *name,\n\t\t\t\t     struct eventfs_file *ef_parent)\n{\n\tstruct eventfs_file *ef;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS))\n\t\treturn NULL;\n\n\tif (!ef_parent)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tef = eventfs_prepare_ef(name, S_IFDIR, NULL, NULL, NULL);\n\tif (IS_ERR(ef))\n\t\treturn ef;\n\n\tmutex_lock(&eventfs_mutex);\n\tlist_add_tail(&ef->list, &ef_parent->ei->e_top_files);\n\tef->d_parent = ef_parent->dentry;\n\tmutex_unlock(&eventfs_mutex);\n\treturn ef;\n}\n\n \nint eventfs_add_events_file(const char *name, umode_t mode,\n\t\t\t struct dentry *parent, void *data,\n\t\t\t const struct file_operations *fop)\n{\n\tstruct tracefs_inode *ti;\n\tstruct eventfs_inode *ei;\n\tstruct eventfs_file *ef;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS))\n\t\treturn -ENODEV;\n\n\tif (!parent)\n\t\treturn -EINVAL;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\n\tif (!parent->d_inode)\n\t\treturn -EINVAL;\n\n\tti = get_tracefs(parent->d_inode);\n\tif (!(ti->flags & TRACEFS_EVENT_INODE))\n\t\treturn -EINVAL;\n\n\tei = ti->private;\n\tef = eventfs_prepare_ef(name, mode, fop, NULL, data);\n\n\tif (IS_ERR(ef))\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&eventfs_mutex);\n\tlist_add_tail(&ef->list, &ei->e_top_files);\n\tef->d_parent = parent;\n\tmutex_unlock(&eventfs_mutex);\n\treturn 0;\n}\n\n \nint eventfs_add_file(const char *name, umode_t mode,\n\t\t     struct eventfs_file *ef_parent,\n\t\t     void *data,\n\t\t     const struct file_operations *fop)\n{\n\tstruct eventfs_file *ef;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS))\n\t\treturn -ENODEV;\n\n\tif (!ef_parent)\n\t\treturn -EINVAL;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\n\tef = eventfs_prepare_ef(name, mode, fop, NULL, data);\n\tif (IS_ERR(ef))\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&eventfs_mutex);\n\tlist_add_tail(&ef->list, &ef_parent->ei->e_top_files);\n\tef->d_parent = ef_parent->dentry;\n\tmutex_unlock(&eventfs_mutex);\n\treturn 0;\n}\n\nstatic LLIST_HEAD(free_list);\n\nstatic void eventfs_workfn(struct work_struct *work)\n{\n        struct eventfs_file *ef, *tmp;\n        struct llist_node *llnode;\n\n\tllnode = llist_del_all(&free_list);\n        llist_for_each_entry_safe(ef, tmp, llnode, llist) {\n\t\t \n\t\tif (!WARN_ON_ONCE(!ef->dentry))\n\t\t\tdput(ef->dentry);\n        }\n}\n\nstatic DECLARE_WORK(eventfs_work, eventfs_workfn);\n\nstatic void free_rcu_ef(struct rcu_head *head)\n{\n\tstruct eventfs_file *ef = container_of(head, struct eventfs_file, rcu);\n\n\tif (ef->dentry) {\n\t\t \n\t\tif (llist_add(&ef->llist, &free_list))\n\t\t\tqueue_work(system_unbound_wq, &eventfs_work);\n\t\treturn;\n\t}\n\n\tfree_ef(ef);\n}\n\nstatic void unhook_dentry(struct dentry *dentry)\n{\n\tif (!dentry)\n\t\treturn;\n\t \n\tdget(dentry);\n\n\t \n\tdget(dentry);\n}\n\n \nstatic void eventfs_remove_rec(struct eventfs_file *ef, int level)\n{\n\tstruct eventfs_file *ef_child;\n\n\tif (!ef)\n\t\treturn;\n\t \n\tif (WARN_ON_ONCE(level > 3))\n\t\treturn;\n\n\tif (ef->ei) {\n\t\t \n\t\tlist_for_each_entry_srcu(ef_child, &ef->ei->e_top_files, list,\n\t\t\t\t\t lockdep_is_held(&eventfs_mutex)) {\n\t\t\teventfs_remove_rec(ef_child, level + 1);\n\t\t}\n\t}\n\n\tef->is_freed = 1;\n\n\tunhook_dentry(ef->dentry);\n\n\tlist_del_rcu(&ef->list);\n\tcall_srcu(&eventfs_srcu, &ef->rcu, free_rcu_ef);\n}\n\n \nvoid eventfs_remove(struct eventfs_file *ef)\n{\n\tstruct dentry *dentry;\n\n\tif (!ef)\n\t\treturn;\n\n\tmutex_lock(&eventfs_mutex);\n\tdentry = ef->dentry;\n\teventfs_remove_rec(ef, 0);\n\tmutex_unlock(&eventfs_mutex);\n\n\t \n\tif (dentry)\n\t\tsimple_recursive_removal(dentry, NULL);\n}\n\n \nvoid eventfs_remove_events_dir(struct dentry *dentry)\n{\n\tstruct eventfs_file *ef_child;\n\tstruct eventfs_inode *ei;\n\tstruct tracefs_inode *ti;\n\n\tif (!dentry || !dentry->d_inode)\n\t\treturn;\n\n\tti = get_tracefs(dentry->d_inode);\n\tif (!ti || !(ti->flags & TRACEFS_EVENT_INODE))\n\t\treturn;\n\n\tmutex_lock(&eventfs_mutex);\n\tei = ti->private;\n\tlist_for_each_entry_srcu(ef_child, &ei->e_top_files, list,\n\t\t\t\t lockdep_is_held(&eventfs_mutex)) {\n\t\teventfs_remove_rec(ef_child, 0);\n\t}\n\tmutex_unlock(&eventfs_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}