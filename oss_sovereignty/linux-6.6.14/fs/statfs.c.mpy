{
  "module_name": "statfs.c",
  "hash_id": "856f3b32e5e1082968dfd0310863cddc14bdd28f4ec57bd5df19e95f4eba70d1",
  "original_prompt": "Ingested from linux-6.6.14/fs/statfs.c",
  "human_readable_source": "\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/statfs.h>\n#include <linux/security.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include \"internal.h\"\n\nstatic int flags_by_mnt(int mnt_flags)\n{\n\tint flags = 0;\n\n\tif (mnt_flags & MNT_READONLY)\n\t\tflags |= ST_RDONLY;\n\tif (mnt_flags & MNT_NOSUID)\n\t\tflags |= ST_NOSUID;\n\tif (mnt_flags & MNT_NODEV)\n\t\tflags |= ST_NODEV;\n\tif (mnt_flags & MNT_NOEXEC)\n\t\tflags |= ST_NOEXEC;\n\tif (mnt_flags & MNT_NOATIME)\n\t\tflags |= ST_NOATIME;\n\tif (mnt_flags & MNT_NODIRATIME)\n\t\tflags |= ST_NODIRATIME;\n\tif (mnt_flags & MNT_RELATIME)\n\t\tflags |= ST_RELATIME;\n\tif (mnt_flags & MNT_NOSYMFOLLOW)\n\t\tflags |= ST_NOSYMFOLLOW;\n\treturn flags;\n}\n\nstatic int flags_by_sb(int s_flags)\n{\n\tint flags = 0;\n\tif (s_flags & SB_SYNCHRONOUS)\n\t\tflags |= ST_SYNCHRONOUS;\n\tif (s_flags & SB_MANDLOCK)\n\t\tflags |= ST_MANDLOCK;\n\tif (s_flags & SB_RDONLY)\n\t\tflags |= ST_RDONLY;\n\treturn flags;\n}\n\nstatic int calculate_f_flags(struct vfsmount *mnt)\n{\n\treturn ST_VALID | flags_by_mnt(mnt->mnt_flags) |\n\t\tflags_by_sb(mnt->mnt_sb->s_flags);\n}\n\nstatic int statfs_by_dentry(struct dentry *dentry, struct kstatfs *buf)\n{\n\tint retval;\n\n\tif (!dentry->d_sb->s_op->statfs)\n\t\treturn -ENOSYS;\n\n\tmemset(buf, 0, sizeof(*buf));\n\tretval = security_sb_statfs(dentry);\n\tif (retval)\n\t\treturn retval;\n\tretval = dentry->d_sb->s_op->statfs(dentry, buf);\n\tif (retval == 0 && buf->f_frsize == 0)\n\t\tbuf->f_frsize = buf->f_bsize;\n\treturn retval;\n}\n\nint vfs_get_fsid(struct dentry *dentry, __kernel_fsid_t *fsid)\n{\n\tstruct kstatfs st;\n\tint error;\n\n\terror = statfs_by_dentry(dentry, &st);\n\tif (error)\n\t\treturn error;\n\n\t*fsid = st.f_fsid;\n\treturn 0;\n}\nEXPORT_SYMBOL(vfs_get_fsid);\n\nint vfs_statfs(const struct path *path, struct kstatfs *buf)\n{\n\tint error;\n\n\terror = statfs_by_dentry(path->dentry, buf);\n\tif (!error)\n\t\tbuf->f_flags = calculate_f_flags(path->mnt);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_statfs);\n\nint user_statfs(const char __user *pathname, struct kstatfs *st)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (!error) {\n\t\terror = vfs_statfs(&path, st);\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\treturn error;\n}\n\nint fd_statfs(int fd, struct kstatfs *st)\n{\n\tstruct fd f = fdget_raw(fd);\n\tint error = -EBADF;\n\tif (f.file) {\n\t\terror = vfs_statfs(&f.file->f_path, st);\n\t\tfdput(f);\n\t}\n\treturn error;\n}\n\nstatic int do_statfs_native(struct kstatfs *st, struct statfs __user *p)\n{\n\tstruct statfs buf;\n\n\tif (sizeof(buf) == sizeof(*st))\n\t\tmemcpy(&buf, st, sizeof(*st));\n\telse {\n\t\tmemset(&buf, 0, sizeof(buf));\n\t\tif (sizeof buf.f_blocks == 4) {\n\t\t\tif ((st->f_blocks | st->f_bfree | st->f_bavail |\n\t\t\t     st->f_bsize | st->f_frsize) &\n\t\t\t    0xffffffff00000000ULL)\n\t\t\t\treturn -EOVERFLOW;\n\t\t\t \n\t\t\tif (st->f_files != -1 &&\n\t\t\t    (st->f_files & 0xffffffff00000000ULL))\n\t\t\t\treturn -EOVERFLOW;\n\t\t\tif (st->f_ffree != -1 &&\n\t\t\t    (st->f_ffree & 0xffffffff00000000ULL))\n\t\t\t\treturn -EOVERFLOW;\n\t\t}\n\n\t\tbuf.f_type = st->f_type;\n\t\tbuf.f_bsize = st->f_bsize;\n\t\tbuf.f_blocks = st->f_blocks;\n\t\tbuf.f_bfree = st->f_bfree;\n\t\tbuf.f_bavail = st->f_bavail;\n\t\tbuf.f_files = st->f_files;\n\t\tbuf.f_ffree = st->f_ffree;\n\t\tbuf.f_fsid = st->f_fsid;\n\t\tbuf.f_namelen = st->f_namelen;\n\t\tbuf.f_frsize = st->f_frsize;\n\t\tbuf.f_flags = st->f_flags;\n\t}\n\tif (copy_to_user(p, &buf, sizeof(buf)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int do_statfs64(struct kstatfs *st, struct statfs64 __user *p)\n{\n\tstruct statfs64 buf;\n\tif (sizeof(buf) == sizeof(*st))\n\t\tmemcpy(&buf, st, sizeof(*st));\n\telse {\n\t\tmemset(&buf, 0, sizeof(buf));\n\t\tbuf.f_type = st->f_type;\n\t\tbuf.f_bsize = st->f_bsize;\n\t\tbuf.f_blocks = st->f_blocks;\n\t\tbuf.f_bfree = st->f_bfree;\n\t\tbuf.f_bavail = st->f_bavail;\n\t\tbuf.f_files = st->f_files;\n\t\tbuf.f_ffree = st->f_ffree;\n\t\tbuf.f_fsid = st->f_fsid;\n\t\tbuf.f_namelen = st->f_namelen;\n\t\tbuf.f_frsize = st->f_frsize;\n\t\tbuf.f_flags = st->f_flags;\n\t}\n\tif (copy_to_user(p, &buf, sizeof(buf)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nSYSCALL_DEFINE2(statfs, const char __user *, pathname, struct statfs __user *, buf)\n{\n\tstruct kstatfs st;\n\tint error = user_statfs(pathname, &st);\n\tif (!error)\n\t\terror = do_statfs_native(&st, buf);\n\treturn error;\n}\n\nSYSCALL_DEFINE3(statfs64, const char __user *, pathname, size_t, sz, struct statfs64 __user *, buf)\n{\n\tstruct kstatfs st;\n\tint error;\n\tif (sz != sizeof(*buf))\n\t\treturn -EINVAL;\n\terror = user_statfs(pathname, &st);\n\tif (!error)\n\t\terror = do_statfs64(&st, buf);\n\treturn error;\n}\n\nSYSCALL_DEFINE2(fstatfs, unsigned int, fd, struct statfs __user *, buf)\n{\n\tstruct kstatfs st;\n\tint error = fd_statfs(fd, &st);\n\tif (!error)\n\t\terror = do_statfs_native(&st, buf);\n\treturn error;\n}\n\nSYSCALL_DEFINE3(fstatfs64, unsigned int, fd, size_t, sz, struct statfs64 __user *, buf)\n{\n\tstruct kstatfs st;\n\tint error;\n\n\tif (sz != sizeof(*buf))\n\t\treturn -EINVAL;\n\n\terror = fd_statfs(fd, &st);\n\tif (!error)\n\t\terror = do_statfs64(&st, buf);\n\treturn error;\n}\n\nstatic int vfs_ustat(dev_t dev, struct kstatfs *sbuf)\n{\n\tstruct super_block *s = user_get_super(dev, false);\n\tint err;\n\tif (!s)\n\t\treturn -EINVAL;\n\n\terr = statfs_by_dentry(s->s_root, sbuf);\n\tdrop_super(s);\n\treturn err;\n}\n\nSYSCALL_DEFINE2(ustat, unsigned, dev, struct ustat __user *, ubuf)\n{\n\tstruct ustat tmp;\n\tstruct kstatfs sbuf;\n\tint err = vfs_ustat(new_decode_dev(dev), &sbuf);\n\tif (err)\n\t\treturn err;\n\n\tmemset(&tmp,0,sizeof(struct ustat));\n\ttmp.f_tfree = sbuf.f_bfree;\n\tif (IS_ENABLED(CONFIG_ARCH_32BIT_USTAT_F_TINODE))\n\t\ttmp.f_tinode = min_t(u64, sbuf.f_ffree, UINT_MAX);\n\telse\n\t\ttmp.f_tinode = sbuf.f_ffree;\n\n\treturn copy_to_user(ubuf, &tmp, sizeof(struct ustat)) ? -EFAULT : 0;\n}\n\n#ifdef CONFIG_COMPAT\nstatic int put_compat_statfs(struct compat_statfs __user *ubuf, struct kstatfs *kbuf)\n{\n\tstruct compat_statfs buf;\n\tif (sizeof ubuf->f_blocks == 4) {\n\t\tif ((kbuf->f_blocks | kbuf->f_bfree | kbuf->f_bavail |\n\t\t     kbuf->f_bsize | kbuf->f_frsize) & 0xffffffff00000000ULL)\n\t\t\treturn -EOVERFLOW;\n\t\t \n\t\tif (kbuf->f_files != 0xffffffffffffffffULL\n\t\t && (kbuf->f_files & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t\tif (kbuf->f_ffree != 0xffffffffffffffffULL\n\t\t && (kbuf->f_ffree & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t}\n\tmemset(&buf, 0, sizeof(struct compat_statfs));\n\tbuf.f_type = kbuf->f_type;\n\tbuf.f_bsize = kbuf->f_bsize;\n\tbuf.f_blocks = kbuf->f_blocks;\n\tbuf.f_bfree = kbuf->f_bfree;\n\tbuf.f_bavail = kbuf->f_bavail;\n\tbuf.f_files = kbuf->f_files;\n\tbuf.f_ffree = kbuf->f_ffree;\n\tbuf.f_namelen = kbuf->f_namelen;\n\tbuf.f_fsid.val[0] = kbuf->f_fsid.val[0];\n\tbuf.f_fsid.val[1] = kbuf->f_fsid.val[1];\n\tbuf.f_frsize = kbuf->f_frsize;\n\tbuf.f_flags = kbuf->f_flags;\n\tif (copy_to_user(ubuf, &buf, sizeof(struct compat_statfs)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nCOMPAT_SYSCALL_DEFINE2(statfs, const char __user *, pathname, struct compat_statfs __user *, buf)\n{\n\tstruct kstatfs tmp;\n\tint error = user_statfs(pathname, &tmp);\n\tif (!error)\n\t\terror = put_compat_statfs(buf, &tmp);\n\treturn error;\n}\n\nCOMPAT_SYSCALL_DEFINE2(fstatfs, unsigned int, fd, struct compat_statfs __user *, buf)\n{\n\tstruct kstatfs tmp;\n\tint error = fd_statfs(fd, &tmp);\n\tif (!error)\n\t\terror = put_compat_statfs(buf, &tmp);\n\treturn error;\n}\n\nstatic int put_compat_statfs64(struct compat_statfs64 __user *ubuf, struct kstatfs *kbuf)\n{\n\tstruct compat_statfs64 buf;\n\n\tif ((kbuf->f_bsize | kbuf->f_frsize) & 0xffffffff00000000ULL)\n\t\treturn -EOVERFLOW;\n\n\tmemset(&buf, 0, sizeof(struct compat_statfs64));\n\tbuf.f_type = kbuf->f_type;\n\tbuf.f_bsize = kbuf->f_bsize;\n\tbuf.f_blocks = kbuf->f_blocks;\n\tbuf.f_bfree = kbuf->f_bfree;\n\tbuf.f_bavail = kbuf->f_bavail;\n\tbuf.f_files = kbuf->f_files;\n\tbuf.f_ffree = kbuf->f_ffree;\n\tbuf.f_namelen = kbuf->f_namelen;\n\tbuf.f_fsid.val[0] = kbuf->f_fsid.val[0];\n\tbuf.f_fsid.val[1] = kbuf->f_fsid.val[1];\n\tbuf.f_frsize = kbuf->f_frsize;\n\tbuf.f_flags = kbuf->f_flags;\n\tif (copy_to_user(ubuf, &buf, sizeof(struct compat_statfs64)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nint kcompat_sys_statfs64(const char __user * pathname, compat_size_t sz, struct compat_statfs64 __user * buf)\n{\n\tstruct kstatfs tmp;\n\tint error;\n\n\tif (sz != sizeof(*buf))\n\t\treturn -EINVAL;\n\n\terror = user_statfs(pathname, &tmp);\n\tif (!error)\n\t\terror = put_compat_statfs64(buf, &tmp);\n\treturn error;\n}\n\nCOMPAT_SYSCALL_DEFINE3(statfs64, const char __user *, pathname, compat_size_t, sz, struct compat_statfs64 __user *, buf)\n{\n\treturn kcompat_sys_statfs64(pathname, sz, buf);\n}\n\nint kcompat_sys_fstatfs64(unsigned int fd, compat_size_t sz, struct compat_statfs64 __user * buf)\n{\n\tstruct kstatfs tmp;\n\tint error;\n\n\tif (sz != sizeof(*buf))\n\t\treturn -EINVAL;\n\n\terror = fd_statfs(fd, &tmp);\n\tif (!error)\n\t\terror = put_compat_statfs64(buf, &tmp);\n\treturn error;\n}\n\nCOMPAT_SYSCALL_DEFINE3(fstatfs64, unsigned int, fd, compat_size_t, sz, struct compat_statfs64 __user *, buf)\n{\n\treturn kcompat_sys_fstatfs64(fd, sz, buf);\n}\n\n \nCOMPAT_SYSCALL_DEFINE2(ustat, unsigned, dev, struct compat_ustat __user *, u)\n{\n\tstruct compat_ustat tmp;\n\tstruct kstatfs sbuf;\n\tint err = vfs_ustat(new_decode_dev(dev), &sbuf);\n\tif (err)\n\t\treturn err;\n\n\tmemset(&tmp, 0, sizeof(struct compat_ustat));\n\ttmp.f_tfree = sbuf.f_bfree;\n\ttmp.f_tinode = sbuf.f_ffree;\n\tif (copy_to_user(u, &tmp, sizeof(struct compat_ustat)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}