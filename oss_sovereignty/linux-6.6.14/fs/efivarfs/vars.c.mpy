{
  "module_name": "vars.c",
  "hash_id": "ff6ea535e8cd702773ff5c07348a9ae2b3e91902313b61cbe7d5a90d259354af",
  "original_prompt": "Ingested from linux-6.6.14/fs/efivarfs/vars.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/smp.h>\n#include <linux/efi.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/ucs2_string.h>\n\n#include \"internal.h\"\n\nMODULE_IMPORT_NS(EFIVAR);\n\nstatic bool\nvalidate_device_path(efi_char16_t *var_name, int match, u8 *buffer,\n\t\t     unsigned long len)\n{\n\tstruct efi_generic_dev_path *node;\n\tint offset = 0;\n\n\tnode = (struct efi_generic_dev_path *)buffer;\n\n\tif (len < sizeof(*node))\n\t\treturn false;\n\n\twhile (offset <= len - sizeof(*node) &&\n\t       node->length >= sizeof(*node) &&\n\t\tnode->length <= len - offset) {\n\t\toffset += node->length;\n\n\t\tif ((node->type == EFI_DEV_END_PATH ||\n\t\t     node->type == EFI_DEV_END_PATH2) &&\n\t\t    node->sub_type == EFI_DEV_END_ENTIRE)\n\t\t\treturn true;\n\n\t\tnode = (struct efi_generic_dev_path *)(buffer + offset);\n\t}\n\n\t \n\treturn false;\n}\n\nstatic bool\nvalidate_boot_order(efi_char16_t *var_name, int match, u8 *buffer,\n\t\t    unsigned long len)\n{\n\t \n\tif ((len % 2) != 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nvalidate_load_option(efi_char16_t *var_name, int match, u8 *buffer,\n\t\t     unsigned long len)\n{\n\tu16 filepathlength;\n\tint i, desclength = 0, namelen;\n\n\tnamelen = ucs2_strnlen(var_name, EFI_VAR_NAME_LEN);\n\n\t \n\tfor (i = match; i < match+4; i++) {\n\t\tif (var_name[i] > 127 ||\n\t\t    hex_to_bin(var_name[i] & 0xff) < 0)\n\t\t\treturn true;\n\t}\n\n\t \n\tif (namelen > match + 4)\n\t\treturn false;\n\n\t \n\tif (len < 8)\n\t\treturn false;\n\n\tfilepathlength = buffer[4] | buffer[5] << 8;\n\n\t \n\tdesclength = ucs2_strsize((efi_char16_t *)(buffer + 6), len - 6) + 2;\n\n\t \n\tif (!desclength)\n\t\treturn false;\n\n\t \n\tif ((desclength + filepathlength + 6) > len)\n\t\treturn false;\n\n\t \n\treturn validate_device_path(var_name, match, buffer + desclength + 6,\n\t\t\t\t    filepathlength);\n}\n\nstatic bool\nvalidate_uint16(efi_char16_t *var_name, int match, u8 *buffer,\n\t\tunsigned long len)\n{\n\t \n\tif (len != 2)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nvalidate_ascii_string(efi_char16_t *var_name, int match, u8 *buffer,\n\t\t      unsigned long len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buffer[i] > 127)\n\t\t\treturn false;\n\n\t\tif (buffer[i] == 0)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstruct variable_validate {\n\tefi_guid_t vendor;\n\tchar *name;\n\tbool (*validate)(efi_char16_t *var_name, int match, u8 *data,\n\t\t\t unsigned long len);\n};\n\n \nstatic const struct variable_validate variable_validate[] = {\n\t{ EFI_GLOBAL_VARIABLE_GUID, \"BootNext\", validate_uint16 },\n\t{ EFI_GLOBAL_VARIABLE_GUID, \"BootOrder\", validate_boot_order },\n\t{ EFI_GLOBAL_VARIABLE_GUID, \"Boot*\", validate_load_option },\n\t{ EFI_GLOBAL_VARIABLE_GUID, \"DriverOrder\", validate_boot_order },\n\t{ EFI_GLOBAL_VARIABLE_GUID, \"Driver*\", validate_load_option },\n\t{ EFI_GLOBAL_VARIABLE_GUID, \"ConIn\", validate_device_path },\n\t{ EFI_GLOBAL_VARIABLE_GUID, \"ConInDev\", validate_device_path },\n\t{ EFI_GLOBAL_VARIABLE_GUID, \"ConOut\", validate_device_path },\n\t{ EFI_GLOBAL_VARIABLE_GUID, \"ConOutDev\", validate_device_path },\n\t{ EFI_GLOBAL_VARIABLE_GUID, \"ErrOut\", validate_device_path },\n\t{ EFI_GLOBAL_VARIABLE_GUID, \"ErrOutDev\", validate_device_path },\n\t{ EFI_GLOBAL_VARIABLE_GUID, \"Lang\", validate_ascii_string },\n\t{ EFI_GLOBAL_VARIABLE_GUID, \"OsIndications\", NULL },\n\t{ EFI_GLOBAL_VARIABLE_GUID, \"PlatformLang\", validate_ascii_string },\n\t{ EFI_GLOBAL_VARIABLE_GUID, \"Timeout\", validate_uint16 },\n\t{ LINUX_EFI_CRASH_GUID, \"*\", NULL },\n\t{ NULL_GUID, \"\", NULL },\n};\n\n \nstatic bool\nvariable_matches(const char *var_name, size_t len, const char *match_name,\n\t\t int *match)\n{\n\tfor (*match = 0; ; (*match)++) {\n\t\tchar c = match_name[*match];\n\n\t\tswitch (c) {\n\t\tcase '*':\n\t\t\t \n\t\t\treturn true;\n\n\t\tcase '\\0':\n\t\t\t \n\t\t\treturn (*match == len);\n\n\t\tdefault:\n\t\t\t \n\t\t\tif (*match < len && c == var_name[*match])\n\t\t\t\tcontinue;\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nbool\nefivar_validate(efi_guid_t vendor, efi_char16_t *var_name, u8 *data,\n\t\tunsigned long data_size)\n{\n\tint i;\n\tunsigned long utf8_size;\n\tu8 *utf8_name;\n\n\tutf8_size = ucs2_utf8size(var_name);\n\tutf8_name = kmalloc(utf8_size + 1, GFP_KERNEL);\n\tif (!utf8_name)\n\t\treturn false;\n\n\tucs2_as_utf8(utf8_name, var_name, utf8_size);\n\tutf8_name[utf8_size] = '\\0';\n\n\tfor (i = 0; variable_validate[i].name[0] != '\\0'; i++) {\n\t\tconst char *name = variable_validate[i].name;\n\t\tint match = 0;\n\n\t\tif (efi_guidcmp(vendor, variable_validate[i].vendor))\n\t\t\tcontinue;\n\n\t\tif (variable_matches(utf8_name, utf8_size+1, name, &match)) {\n\t\t\tif (variable_validate[i].validate == NULL)\n\t\t\t\tbreak;\n\t\t\tkfree(utf8_name);\n\t\t\treturn variable_validate[i].validate(var_name, match,\n\t\t\t\t\t\t\t     data, data_size);\n\t\t}\n\t}\n\tkfree(utf8_name);\n\treturn true;\n}\n\nbool\nefivar_variable_is_removable(efi_guid_t vendor, const char *var_name,\n\t\t\t     size_t len)\n{\n\tint i;\n\tbool found = false;\n\tint match = 0;\n\n\t \n\tfor (i = 0; variable_validate[i].name[0] != '\\0'; i++) {\n\t\tif (efi_guidcmp(variable_validate[i].vendor, vendor))\n\t\t\tcontinue;\n\n\t\tif (variable_matches(var_name, len,\n\t\t\t\t     variable_validate[i].name, &match)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\treturn found;\n}\n\nstatic bool variable_is_present(efi_char16_t *variable_name, efi_guid_t *vendor,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct efivar_entry *entry, *n;\n\tunsigned long strsize1, strsize2;\n\tbool found = false;\n\n\tstrsize1 = ucs2_strsize(variable_name, 1024);\n\tlist_for_each_entry_safe(entry, n, head, list) {\n\t\tstrsize2 = ucs2_strsize(entry->var.VariableName, 1024);\n\t\tif (strsize1 == strsize2 &&\n\t\t\t!memcmp(variable_name, &(entry->var.VariableName),\n\t\t\t\tstrsize2) &&\n\t\t\t!efi_guidcmp(entry->var.VendorGuid,\n\t\t\t\t*vendor)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}\n\n \nstatic unsigned long var_name_strnsize(efi_char16_t *variable_name,\n\t\t\t\t       unsigned long variable_name_size)\n{\n\tunsigned long len;\n\tefi_char16_t c;\n\n\t \n\tfor (len = 2; len <= variable_name_size; len += sizeof(c)) {\n\t\tc = variable_name[(len / sizeof(c)) - 1];\n\t\tif (!c)\n\t\t\tbreak;\n\t}\n\n\treturn min(len, variable_name_size);\n}\n\n \nstatic void dup_variable_bug(efi_char16_t *str16, efi_guid_t *vendor_guid,\n\t\t\t     unsigned long len16)\n{\n\tsize_t i, len8 = len16 / sizeof(efi_char16_t);\n\tchar *str8;\n\n\tstr8 = kzalloc(len8, GFP_KERNEL);\n\tif (!str8)\n\t\treturn;\n\n\tfor (i = 0; i < len8; i++)\n\t\tstr8[i] = str16[i];\n\n\tprintk(KERN_WARNING \"efivars: duplicate variable: %s-%pUl\\n\",\n\t       str8, vendor_guid);\n\tkfree(str8);\n}\n\n \nint efivar_init(int (*func)(efi_char16_t *, efi_guid_t, unsigned long, void *),\n\t\tvoid *data, bool duplicates, struct list_head *head)\n{\n\tunsigned long variable_name_size = 1024;\n\tefi_char16_t *variable_name;\n\tefi_status_t status;\n\tefi_guid_t vendor_guid;\n\tint err = 0;\n\n\tvariable_name = kzalloc(variable_name_size, GFP_KERNEL);\n\tif (!variable_name) {\n\t\tprintk(KERN_ERR \"efivars: Memory allocation failed.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\terr = efivar_lock();\n\tif (err)\n\t\tgoto free;\n\n\t \n\n\tdo {\n\t\tvariable_name_size = 1024;\n\n\t\tstatus = efivar_get_next_variable(&variable_name_size,\n\t\t\t\t\t\t  variable_name,\n\t\t\t\t\t\t  &vendor_guid);\n\t\tswitch (status) {\n\t\tcase EFI_SUCCESS:\n\t\t\tvariable_name_size = var_name_strnsize(variable_name,\n\t\t\t\t\t\t\t       variable_name_size);\n\n\t\t\t \n\t\t\tif (duplicates &&\n\t\t\t    variable_is_present(variable_name, &vendor_guid,\n\t\t\t\t\t\thead)) {\n\t\t\t\tdup_variable_bug(variable_name, &vendor_guid,\n\t\t\t\t\t\t variable_name_size);\n\t\t\t\tstatus = EFI_NOT_FOUND;\n\t\t\t} else {\n\t\t\t\terr = func(variable_name, vendor_guid,\n\t\t\t\t\t   variable_name_size, data);\n\t\t\t\tif (err)\n\t\t\t\t\tstatus = EFI_NOT_FOUND;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EFI_UNSUPPORTED:\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tstatus = EFI_NOT_FOUND;\n\t\t\tbreak;\n\t\tcase EFI_NOT_FOUND:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_WARNING \"efivars: get_next_variable: status=%lx\\n\",\n\t\t\t\tstatus);\n\t\t\tstatus = EFI_NOT_FOUND;\n\t\t\tbreak;\n\t\t}\n\n\t} while (status != EFI_NOT_FOUND);\n\n\tefivar_unlock();\nfree:\n\tkfree(variable_name);\n\n\treturn err;\n}\n\n \nint efivar_entry_add(struct efivar_entry *entry, struct list_head *head)\n{\n\tint err;\n\n\terr = efivar_lock();\n\tif (err)\n\t\treturn err;\n\tlist_add(&entry->list, head);\n\tefivar_unlock();\n\n\treturn 0;\n}\n\n \nvoid __efivar_entry_add(struct efivar_entry *entry, struct list_head *head)\n{\n\tlist_add(&entry->list, head);\n}\n\n \nvoid efivar_entry_remove(struct efivar_entry *entry)\n{\n\tlist_del(&entry->list);\n}\n\n \nstatic void efivar_entry_list_del_unlock(struct efivar_entry *entry)\n{\n\tlist_del(&entry->list);\n\tefivar_unlock();\n}\n\n \nint efivar_entry_delete(struct efivar_entry *entry)\n{\n\tefi_status_t status;\n\tint err;\n\n\terr = efivar_lock();\n\tif (err)\n\t\treturn err;\n\n\tstatus = efivar_set_variable_locked(entry->var.VariableName,\n\t\t\t\t\t    &entry->var.VendorGuid,\n\t\t\t\t\t    0, 0, NULL, false);\n\tif (!(status == EFI_SUCCESS || status == EFI_NOT_FOUND)) {\n\t\tefivar_unlock();\n\t\treturn efi_status_to_err(status);\n\t}\n\n\tefivar_entry_list_del_unlock(entry);\n\treturn 0;\n}\n\n \nint efivar_entry_size(struct efivar_entry *entry, unsigned long *size)\n{\n\tefi_status_t status;\n\tint err;\n\n\t*size = 0;\n\n\terr = efivar_lock();\n\tif (err)\n\t\treturn err;\n\n\tstatus = efivar_get_variable(entry->var.VariableName,\n\t\t\t\t     &entry->var.VendorGuid, NULL, size, NULL);\n\tefivar_unlock();\n\n\tif (status != EFI_BUFFER_TOO_SMALL)\n\t\treturn efi_status_to_err(status);\n\n\treturn 0;\n}\n\n \nint __efivar_entry_get(struct efivar_entry *entry, u32 *attributes,\n\t\t       unsigned long *size, void *data)\n{\n\tefi_status_t status;\n\n\tstatus = efivar_get_variable(entry->var.VariableName,\n\t\t\t\t     &entry->var.VendorGuid,\n\t\t\t\t     attributes, size, data);\n\n\treturn efi_status_to_err(status);\n}\n\n \nint efivar_entry_get(struct efivar_entry *entry, u32 *attributes,\n\t\t     unsigned long *size, void *data)\n{\n\tint err;\n\n\terr = efivar_lock();\n\tif (err)\n\t\treturn err;\n\terr = __efivar_entry_get(entry, attributes, size, data);\n\tefivar_unlock();\n\n\treturn 0;\n}\n\n \nint efivar_entry_set_get_size(struct efivar_entry *entry, u32 attributes,\n\t\t\t      unsigned long *size, void *data, bool *set)\n{\n\tefi_char16_t *name = entry->var.VariableName;\n\tefi_guid_t *vendor = &entry->var.VendorGuid;\n\tefi_status_t status;\n\tint err;\n\n\t*set = false;\n\n\tif (efivar_validate(*vendor, name, data, *size) == false)\n\t\treturn -EINVAL;\n\n\t \n\terr = efivar_lock();\n\tif (err)\n\t\treturn err;\n\n\tstatus = efivar_set_variable_locked(name, vendor, attributes, *size,\n\t\t\t\t\t    data, false);\n\tif (status != EFI_SUCCESS) {\n\t\terr = efi_status_to_err(status);\n\t\tgoto out;\n\t}\n\n\t*set = true;\n\n\t \n\t*size = 0;\n\tstatus = efivar_get_variable(entry->var.VariableName,\n\t\t\t\t    &entry->var.VendorGuid,\n\t\t\t\t    NULL, size, NULL);\n\n\tif (status == EFI_NOT_FOUND)\n\t\tefivar_entry_list_del_unlock(entry);\n\telse\n\t\tefivar_unlock();\n\n\tif (status && status != EFI_BUFFER_TOO_SMALL)\n\t\treturn efi_status_to_err(status);\n\n\treturn 0;\n\nout:\n\tefivar_unlock();\n\treturn err;\n\n}\n\n \nint efivar_entry_iter(int (*func)(struct efivar_entry *, void *),\n\t\t      struct list_head *head, void *data)\n{\n\tstruct efivar_entry *entry, *n;\n\tint err = 0;\n\n\terr = efivar_lock();\n\tif (err)\n\t\treturn err;\n\n\tlist_for_each_entry_safe(entry, n, head, list) {\n\t\terr = func(entry, data);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tefivar_unlock();\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}