{
  "module_name": "super.c",
  "hash_id": "1d7eb746b8816a1da00894cc874df6bc57f49ba14134a3976ad74b853d93585b",
  "original_prompt": "Ingested from linux-6.6.14/fs/efivarfs/super.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/efi.h>\n#include <linux/fs.h>\n#include <linux/fs_context.h>\n#include <linux/module.h>\n#include <linux/pagemap.h>\n#include <linux/ucs2_string.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/printk.h>\n\n#include \"internal.h\"\n\nLIST_HEAD(efivarfs_list);\n\nstatic void efivarfs_evict_inode(struct inode *inode)\n{\n\tclear_inode(inode);\n}\n\nstatic int efivarfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tconst u32 attr = EFI_VARIABLE_NON_VOLATILE |\n\t\t\t EFI_VARIABLE_BOOTSERVICE_ACCESS |\n\t\t\t EFI_VARIABLE_RUNTIME_ACCESS;\n\tu64 storage_space, remaining_space, max_variable_size;\n\tefi_status_t status;\n\n\t \n\tstorage_space = remaining_space = 0;\n\tif (efi_rt_services_supported(EFI_RT_SUPPORTED_QUERY_VARIABLE_INFO)) {\n\t\tstatus = efivar_query_variable_info(attr, &storage_space,\n\t\t\t\t\t\t    &remaining_space,\n\t\t\t\t\t\t    &max_variable_size);\n\t\tif (status != EFI_SUCCESS && status != EFI_UNSUPPORTED)\n\t\t\tpr_warn_ratelimited(\"query_variable_info() failed: 0x%lx\\n\",\n\t\t\t\t\t    status);\n\t}\n\n\t \n\tbuf->f_bsize\t= 1;\n\tbuf->f_namelen\t= NAME_MAX;\n\tbuf->f_blocks\t= storage_space;\n\tbuf->f_bfree\t= remaining_space;\n\tbuf->f_type\t= dentry->d_sb->s_magic;\n\n\t \n\tif (remaining_space > efivar_reserved_space())\n\t\tbuf->f_bavail = remaining_space - efivar_reserved_space();\n\telse\n\t\tbuf->f_bavail = 0;\n\n\treturn 0;\n}\nstatic const struct super_operations efivarfs_ops = {\n\t.statfs = efivarfs_statfs,\n\t.drop_inode = generic_delete_inode,\n\t.evict_inode = efivarfs_evict_inode,\n};\n\n \nstatic int efivarfs_d_compare(const struct dentry *dentry,\n\t\t\t      unsigned int len, const char *str,\n\t\t\t      const struct qstr *name)\n{\n\tint guid = len - EFI_VARIABLE_GUID_LEN;\n\n\tif (name->len != len)\n\t\treturn 1;\n\n\t \n\tif (memcmp(str, name->name, guid))\n\t\treturn 1;\n\n\t \n\treturn strncasecmp(name->name + guid, str + guid, EFI_VARIABLE_GUID_LEN);\n}\n\nstatic int efivarfs_d_hash(const struct dentry *dentry, struct qstr *qstr)\n{\n\tunsigned long hash = init_name_hash(dentry);\n\tconst unsigned char *s = qstr->name;\n\tunsigned int len = qstr->len;\n\n\tif (!efivarfs_valid_name(s, len))\n\t\treturn -EINVAL;\n\n\twhile (len-- > EFI_VARIABLE_GUID_LEN)\n\t\thash = partial_name_hash(*s++, hash);\n\n\t \n\twhile (len--)\n\t\thash = partial_name_hash(tolower(*s++), hash);\n\n\tqstr->hash = end_name_hash(hash);\n\treturn 0;\n}\n\nstatic const struct dentry_operations efivarfs_d_ops = {\n\t.d_compare = efivarfs_d_compare,\n\t.d_hash = efivarfs_d_hash,\n\t.d_delete = always_delete_dentry,\n};\n\nstatic struct dentry *efivarfs_alloc_dentry(struct dentry *parent, char *name)\n{\n\tstruct dentry *d;\n\tstruct qstr q;\n\tint err;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\n\terr = efivarfs_d_hash(parent, &q);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\td = d_alloc(parent, &q);\n\tif (d)\n\t\treturn d;\n\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic int efivarfs_callback(efi_char16_t *name16, efi_guid_t vendor,\n\t\t\t     unsigned long name_size, void *data)\n{\n\tstruct super_block *sb = (struct super_block *)data;\n\tstruct efivar_entry *entry;\n\tstruct inode *inode = NULL;\n\tstruct dentry *dentry, *root = sb->s_root;\n\tunsigned long size = 0;\n\tchar *name;\n\tint len;\n\tint err = -ENOMEM;\n\tbool is_removable = false;\n\n\tif (guid_equal(&vendor, &LINUX_EFI_RANDOM_SEED_TABLE_GUID))\n\t\treturn 0;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn err;\n\n\tmemcpy(entry->var.VariableName, name16, name_size);\n\tmemcpy(&(entry->var.VendorGuid), &vendor, sizeof(efi_guid_t));\n\n\tlen = ucs2_utf8size(entry->var.VariableName);\n\n\t \n\tname = kmalloc(len + 1 + EFI_VARIABLE_GUID_LEN + 1, GFP_KERNEL);\n\tif (!name)\n\t\tgoto fail;\n\n\tucs2_as_utf8(name, entry->var.VariableName, len);\n\n\tif (efivar_variable_is_removable(entry->var.VendorGuid, name, len))\n\t\tis_removable = true;\n\n\tname[len] = '-';\n\n\tefi_guid_to_str(&entry->var.VendorGuid, name + len + 1);\n\n\tname[len + EFI_VARIABLE_GUID_LEN+1] = '\\0';\n\n\t \n\tstrreplace(name, '/', '!');\n\n\tinode = efivarfs_get_inode(sb, d_inode(root), S_IFREG | 0644, 0,\n\t\t\t\t   is_removable);\n\tif (!inode)\n\t\tgoto fail_name;\n\n\tdentry = efivarfs_alloc_dentry(root, name);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto fail_inode;\n\t}\n\n\t__efivar_entry_get(entry, NULL, &size, NULL);\n\t__efivar_entry_add(entry, &efivarfs_list);\n\n\t \n\tkfree(name);\n\n\tinode_lock(inode);\n\tinode->i_private = entry;\n\ti_size_write(inode, size + sizeof(entry->var.Attributes));\n\tinode_unlock(inode);\n\td_add(dentry, inode);\n\n\treturn 0;\n\nfail_inode:\n\tiput(inode);\nfail_name:\n\tkfree(name);\nfail:\n\tkfree(entry);\n\treturn err;\n}\n\nstatic int efivarfs_destroy(struct efivar_entry *entry, void *data)\n{\n\tefivar_entry_remove(entry);\n\tkfree(entry);\n\treturn 0;\n}\n\nstatic int efivarfs_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct inode *inode = NULL;\n\tstruct dentry *root;\n\tint err;\n\n\tif (!efivar_is_available())\n\t\treturn -EOPNOTSUPP;\n\n\tsb->s_maxbytes          = MAX_LFS_FILESIZE;\n\tsb->s_blocksize         = PAGE_SIZE;\n\tsb->s_blocksize_bits    = PAGE_SHIFT;\n\tsb->s_magic             = EFIVARFS_MAGIC;\n\tsb->s_op                = &efivarfs_ops;\n\tsb->s_d_op\t\t= &efivarfs_d_ops;\n\tsb->s_time_gran         = 1;\n\n\tif (!efivar_supports_writes())\n\t\tsb->s_flags |= SB_RDONLY;\n\n\tinode = efivarfs_get_inode(sb, NULL, S_IFDIR | 0755, 0, true);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\tinode->i_op = &efivarfs_dir_inode_operations;\n\n\troot = d_make_root(inode);\n\tsb->s_root = root;\n\tif (!root)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&efivarfs_list);\n\n\terr = efivar_init(efivarfs_callback, (void *)sb, true, &efivarfs_list);\n\tif (err)\n\t\tefivar_entry_iter(efivarfs_destroy, &efivarfs_list, NULL);\n\n\treturn err;\n}\n\nstatic int efivarfs_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_single(fc, efivarfs_fill_super);\n}\n\nstatic int efivarfs_reconfigure(struct fs_context *fc)\n{\n\tif (!efivar_supports_writes() && !(fc->sb_flags & SB_RDONLY)) {\n\t\tpr_err(\"Firmware does not support SetVariableRT. Can not remount with rw\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct fs_context_operations efivarfs_context_ops = {\n\t.get_tree\t= efivarfs_get_tree,\n\t.reconfigure\t= efivarfs_reconfigure,\n};\n\nstatic int efivarfs_init_fs_context(struct fs_context *fc)\n{\n\tfc->ops = &efivarfs_context_ops;\n\treturn 0;\n}\n\nstatic void efivarfs_kill_sb(struct super_block *sb)\n{\n\tstruct efivarfs_fs_info *sfi = sb->s_fs_info;\n\n\tkill_litter_super(sb);\n\n\tif (!efivar_is_available())\n\t\treturn;\n\n\t \n\tefivar_entry_iter(efivarfs_destroy, &efivarfs_list, NULL);\n\tkfree(sfi);\n}\n\nstatic struct file_system_type efivarfs_type = {\n\t.owner   = THIS_MODULE,\n\t.name    = \"efivarfs\",\n\t.init_fs_context = efivarfs_init_fs_context,\n\t.kill_sb = efivarfs_kill_sb,\n};\n\nstatic __init int efivarfs_init(void)\n{\n\treturn register_filesystem(&efivarfs_type);\n}\n\nstatic __exit void efivarfs_exit(void)\n{\n\tunregister_filesystem(&efivarfs_type);\n}\n\nMODULE_AUTHOR(\"Matthew Garrett, Jeremy Kerr\");\nMODULE_DESCRIPTION(\"EFI Variable Filesystem\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_FS(\"efivarfs\");\n\nmodule_init(efivarfs_init);\nmodule_exit(efivarfs_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}