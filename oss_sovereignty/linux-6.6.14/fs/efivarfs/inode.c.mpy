{
  "module_name": "inode.c",
  "hash_id": "209184be4bd45fce4d4a36c178d4ac6786736e83b698c448acb561bde22062b2",
  "original_prompt": "Ingested from linux-6.6.14/fs/efivarfs/inode.c",
  "human_readable_source": "\n \n\n#include <linux/efi.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/kmemleak.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/fileattr.h>\n\n#include \"internal.h\"\n\nstatic const struct inode_operations efivarfs_file_inode_operations;\n\nstruct inode *efivarfs_get_inode(struct super_block *sb,\n\t\t\t\tconst struct inode *dir, int mode,\n\t\t\t\tdev_t dev, bool is_removable)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\t\tinode->i_flags = is_removable ? 0 : S_IMMUTABLE;\n\t\tswitch (mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &efivarfs_file_inode_operations;\n\t\t\tinode->i_fop = &efivarfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &efivarfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn inode;\n}\n\n \nbool efivarfs_valid_name(const char *str, int len)\n{\n\tconst char *s = str + len - EFI_VARIABLE_GUID_LEN;\n\n\t \n\tif (len < EFI_VARIABLE_GUID_LEN + 2)\n\t\treturn false;\n\n\t \n\tif (*(s - 1) != '-')\n\t\treturn false;\n\n\t \n\treturn uuid_is_valid(s);\n}\n\nstatic int efivarfs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t   struct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct inode *inode = NULL;\n\tstruct efivar_entry *var;\n\tint namelen, i = 0, err = 0;\n\tbool is_removable = false;\n\n\tif (!efivarfs_valid_name(dentry->d_name.name, dentry->d_name.len))\n\t\treturn -EINVAL;\n\n\tvar = kzalloc(sizeof(struct efivar_entry), GFP_KERNEL);\n\tif (!var)\n\t\treturn -ENOMEM;\n\n\t \n\tnamelen = dentry->d_name.len - EFI_VARIABLE_GUID_LEN - 1;\n\n\terr = guid_parse(dentry->d_name.name + namelen + 1, &var->var.VendorGuid);\n\tif (err)\n\t\tgoto out;\n\tif (guid_equal(&var->var.VendorGuid, &LINUX_EFI_RANDOM_SEED_TABLE_GUID)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (efivar_variable_is_removable(var->var.VendorGuid,\n\t\t\t\t\t dentry->d_name.name, namelen))\n\t\tis_removable = true;\n\n\tinode = efivarfs_get_inode(dir->i_sb, dir, mode, 0, is_removable);\n\tif (!inode) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < namelen; i++)\n\t\tvar->var.VariableName[i] = dentry->d_name.name[i];\n\n\tvar->var.VariableName[i] = '\\0';\n\n\tinode->i_private = var;\n\tkmemleak_ignore(var);\n\n\terr = efivar_entry_add(var, &efivarfs_list);\n\tif (err)\n\t\tgoto out;\n\n\td_instantiate(dentry, inode);\n\tdget(dentry);\nout:\n\tif (err) {\n\t\tkfree(var);\n\t\tif (inode)\n\t\t\tiput(inode);\n\t}\n\treturn err;\n}\n\nstatic int efivarfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct efivar_entry *var = d_inode(dentry)->i_private;\n\n\tif (efivar_entry_delete(var))\n\t\treturn -EINVAL;\n\n\tdrop_nlink(d_inode(dentry));\n\tdput(dentry);\n\treturn 0;\n};\n\nconst struct inode_operations efivarfs_dir_inode_operations = {\n\t.lookup = simple_lookup,\n\t.unlink = efivarfs_unlink,\n\t.create = efivarfs_create,\n};\n\nstatic int\nefivarfs_fileattr_get(struct dentry *dentry, struct fileattr *fa)\n{\n\tunsigned int i_flags;\n\tunsigned int flags = 0;\n\n\ti_flags = d_inode(dentry)->i_flags;\n\tif (i_flags & S_IMMUTABLE)\n\t\tflags |= FS_IMMUTABLE_FL;\n\n\tfileattr_fill_flags(fa, flags);\n\n\treturn 0;\n}\n\nstatic int\nefivarfs_fileattr_set(struct mnt_idmap *idmap,\n\t\t      struct dentry *dentry, struct fileattr *fa)\n{\n\tunsigned int i_flags = 0;\n\n\tif (fileattr_has_fsx(fa))\n\t\treturn -EOPNOTSUPP;\n\n\tif (fa->flags & ~FS_IMMUTABLE_FL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (fa->flags & FS_IMMUTABLE_FL)\n\t\ti_flags |= S_IMMUTABLE;\n\n\tinode_set_flags(d_inode(dentry), i_flags, S_IMMUTABLE);\n\n\treturn 0;\n}\n\nstatic const struct inode_operations efivarfs_file_inode_operations = {\n\t.fileattr_get = efivarfs_fileattr_get,\n\t.fileattr_set = efivarfs_fileattr_set,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}