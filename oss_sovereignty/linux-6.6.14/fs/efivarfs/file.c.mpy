{
  "module_name": "file.c",
  "hash_id": "3b6bf0089bcc2a381c74cc067976263bb8cb6ddb4327c428f6174cb60a281d91",
  "original_prompt": "Ingested from linux-6.6.14/fs/efivarfs/file.c",
  "human_readable_source": "\n \n\n#include <linux/efi.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n\n#include \"internal.h\"\n\nstatic ssize_t efivarfs_file_write(struct file *file,\n\t\tconst char __user *userbuf, size_t count, loff_t *ppos)\n{\n\tstruct efivar_entry *var = file->private_data;\n\tvoid *data;\n\tu32 attributes;\n\tstruct inode *inode = file->f_mapping->host;\n\tunsigned long datasize = count - sizeof(attributes);\n\tssize_t bytes;\n\tbool set = false;\n\n\tif (count < sizeof(attributes))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&attributes, userbuf, sizeof(attributes)))\n\t\treturn -EFAULT;\n\n\tif (attributes & ~(EFI_VARIABLE_MASK))\n\t\treturn -EINVAL;\n\n\tdata = memdup_user(userbuf + sizeof(attributes), datasize);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tbytes = efivar_entry_set_get_size(var, attributes, &datasize,\n\t\t\t\t\t  data, &set);\n\tif (!set && bytes) {\n\t\tif (bytes == -ENOENT)\n\t\t\tbytes = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (bytes == -ENOENT) {\n\t\tdrop_nlink(inode);\n\t\td_delete(file->f_path.dentry);\n\t\tdput(file->f_path.dentry);\n\t} else {\n\t\tinode_lock(inode);\n\t\ti_size_write(inode, datasize + sizeof(attributes));\n\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\tinode_unlock(inode);\n\t}\n\n\tbytes = count;\n\nout:\n\tkfree(data);\n\n\treturn bytes;\n}\n\nstatic ssize_t efivarfs_file_read(struct file *file, char __user *userbuf,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct efivar_entry *var = file->private_data;\n\tunsigned long datasize = 0;\n\tu32 attributes;\n\tvoid *data;\n\tssize_t size = 0;\n\tint err;\n\n\twhile (!__ratelimit(&file->f_cred->user->ratelimit))\n\t\tmsleep(50);\n\n\terr = efivar_entry_size(var, &datasize);\n\n\t \n\tif (err == -ENOENT)\n\t\treturn 0;\n\telse if (err)\n\t\treturn err;\n\n\tdata = kmalloc(datasize + sizeof(attributes), GFP_KERNEL);\n\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tsize = efivar_entry_get(var, &attributes, &datasize,\n\t\t\t\tdata + sizeof(attributes));\n\tif (size)\n\t\tgoto out_free;\n\n\tmemcpy(data, &attributes, sizeof(attributes));\n\tsize = simple_read_from_buffer(userbuf, count, ppos,\n\t\t\t\t       data, datasize + sizeof(attributes));\nout_free:\n\tkfree(data);\n\n\treturn size;\n}\n\nconst struct file_operations efivarfs_file_operations = {\n\t.open\t= simple_open,\n\t.read\t= efivarfs_file_read,\n\t.write\t= efivarfs_file_write,\n\t.llseek\t= no_llseek,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}