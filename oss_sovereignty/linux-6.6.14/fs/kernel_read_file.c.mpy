{
  "module_name": "kernel_read_file.c",
  "hash_id": "9333a2e288c25cae218dd858df9a796c935551c0adbf366ec323096db8c333ae",
  "original_prompt": "Ingested from linux-6.6.14/fs/kernel_read_file.c",
  "human_readable_source": "\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/kernel_read_file.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n\n \nssize_t kernel_read_file(struct file *file, loff_t offset, void **buf,\n\t\t\t size_t buf_size, size_t *file_size,\n\t\t\t enum kernel_read_file_id id)\n{\n\tloff_t i_size, pos;\n\tssize_t copied;\n\tvoid *allocated = NULL;\n\tbool whole_file;\n\tint ret;\n\n\tif (offset != 0 && (!*buf || !file_size))\n\t\treturn -EINVAL;\n\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn -EINVAL;\n\n\tret = deny_write_access(file);\n\tif (ret)\n\t\treturn ret;\n\n\ti_size = i_size_read(file_inode(file));\n\tif (i_size <= 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\t \n\tif (i_size > SSIZE_MAX) {\n\t\tret = -EFBIG;\n\t\tgoto out;\n\t}\n\t \n\tif (!file_size && offset == 0 && i_size > buf_size) {\n\t\tret = -EFBIG;\n\t\tgoto out;\n\t}\n\n\twhole_file = (offset == 0 && i_size <= buf_size);\n\tret = security_kernel_read_file(file, id, whole_file);\n\tif (ret)\n\t\tgoto out;\n\n\tif (file_size)\n\t\t*file_size = i_size;\n\n\tif (!*buf)\n\t\t*buf = allocated = vmalloc(i_size);\n\tif (!*buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpos = offset;\n\tcopied = 0;\n\twhile (copied < buf_size) {\n\t\tssize_t bytes;\n\t\tsize_t wanted = min_t(size_t, buf_size - copied,\n\t\t\t\t\t      i_size - pos);\n\n\t\tbytes = kernel_read(file, *buf + copied, wanted, &pos);\n\t\tif (bytes < 0) {\n\t\t\tret = bytes;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tif (bytes == 0)\n\t\t\tbreak;\n\t\tcopied += bytes;\n\t}\n\n\tif (whole_file) {\n\t\tif (pos != i_size) {\n\t\t\tret = -EIO;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tret = security_kernel_post_read_file(file, *buf, i_size, id);\n\t}\n\nout_free:\n\tif (ret < 0) {\n\t\tif (allocated) {\n\t\t\tvfree(*buf);\n\t\t\t*buf = NULL;\n\t\t}\n\t}\n\nout:\n\tallow_write_access(file);\n\treturn ret == 0 ? copied : ret;\n}\nEXPORT_SYMBOL_GPL(kernel_read_file);\n\nssize_t kernel_read_file_from_path(const char *path, loff_t offset, void **buf,\n\t\t\t\t   size_t buf_size, size_t *file_size,\n\t\t\t\t   enum kernel_read_file_id id)\n{\n\tstruct file *file;\n\tssize_t ret;\n\n\tif (!path || !*path)\n\t\treturn -EINVAL;\n\n\tfile = filp_open(path, O_RDONLY, 0);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tret = kernel_read_file(file, offset, buf, buf_size, file_size, id);\n\tfput(file);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(kernel_read_file_from_path);\n\nssize_t kernel_read_file_from_path_initns(const char *path, loff_t offset,\n\t\t\t\t\t  void **buf, size_t buf_size,\n\t\t\t\t\t  size_t *file_size,\n\t\t\t\t\t  enum kernel_read_file_id id)\n{\n\tstruct file *file;\n\tstruct path root;\n\tssize_t ret;\n\n\tif (!path || !*path)\n\t\treturn -EINVAL;\n\n\ttask_lock(&init_task);\n\tget_fs_root(init_task.fs, &root);\n\ttask_unlock(&init_task);\n\n\tfile = file_open_root(&root, path, O_RDONLY, 0);\n\tpath_put(&root);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tret = kernel_read_file(file, offset, buf, buf_size, file_size, id);\n\tfput(file);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(kernel_read_file_from_path_initns);\n\nssize_t kernel_read_file_from_fd(int fd, loff_t offset, void **buf,\n\t\t\t\t size_t buf_size, size_t *file_size,\n\t\t\t\t enum kernel_read_file_id id)\n{\n\tstruct fd f = fdget(fd);\n\tssize_t ret = -EBADF;\n\n\tif (!f.file || !(f.file->f_mode & FMODE_READ))\n\t\tgoto out;\n\n\tret = kernel_read_file(f.file, offset, buf, buf_size, file_size, id);\nout:\n\tfdput(f);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(kernel_read_file_from_fd);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}