{
  "module_name": "affs.h",
  "hash_id": "07c27258c28495a750ce7b4fa7cc00dde7a0a2007dc6c504cd33fb3905486cc0",
  "original_prompt": "Ingested from linux-6.6.14/fs/affs/affs.h",
  "human_readable_source": " \n#ifdef pr_fmt\n#undef pr_fmt\n#endif\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include \"amigaffs.h\"\n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n\n \n\n#define GET_END_PTR(st,p,sz)\t\t ((st *)((char *)(p)+((sz)-sizeof(st))))\n#define AFFS_GET_HASHENTRY(data,hashkey) be32_to_cpu(((struct dir_front *)data)->hashtable[hashkey])\n#define AFFS_BLOCK(sb, bh, blk)\t\t(AFFS_HEAD(bh)->table[AFFS_SB(sb)->s_hashsize-1-(blk)])\n\n#define AFFS_HEAD(bh)\t\t((struct affs_head *)(bh)->b_data)\n#define AFFS_TAIL(sb, bh)\t((struct affs_tail *)((bh)->b_data+(sb)->s_blocksize-sizeof(struct affs_tail)))\n#define AFFS_ROOT_HEAD(bh)\t((struct affs_root_head *)(bh)->b_data)\n#define AFFS_ROOT_TAIL(sb, bh)\t((struct affs_root_tail *)((bh)->b_data+(sb)->s_blocksize-sizeof(struct affs_root_tail)))\n#define AFFS_DATA_HEAD(bh)\t((struct affs_data_head *)(bh)->b_data)\n#define AFFS_DATA(bh)\t\t(((struct affs_data_head *)(bh)->b_data)->data)\n\n#define AFFS_CACHE_SIZE\t\tPAGE_SIZE\n\n#define AFFS_LC_SIZE\t\t(AFFS_CACHE_SIZE/sizeof(u32)/2)\n#define AFFS_AC_SIZE\t\t(AFFS_CACHE_SIZE/sizeof(struct affs_ext_key)/2)\n#define AFFS_AC_MASK\t\t(AFFS_AC_SIZE-1)\n\n#define AFFSNAMEMAX 30U\n\nstruct affs_ext_key {\n\tu32\text;\t\t\t\t \n\tu32\tkey;\t\t\t\t \n};\n\n \nstruct affs_inode_info {\n\tatomic_t i_opencnt;\n\tstruct mutex i_link_lock;\t\t \n\tstruct mutex i_ext_lock;\t\t \n#define i_hash_lock i_ext_lock\n\tu32\t i_blkcnt;\t\t\t \n\tu32\t i_extcnt;\t\t\t \n\tu32\t*i_lc;\t\t\t\t \n\tu32\t i_lc_size;\n\tu32\t i_lc_shift;\n\tu32\t i_lc_mask;\n\tstruct affs_ext_key *i_ac;\t\t \n\tu32\t i_ext_last;\t\t\t \n\tstruct buffer_head *i_ext_bh;\t\t \n\tloff_t\t mmu_private;\n\tu32\t i_protect;\t\t\t \n\tu32\t i_lastalloc;\t\t\t \n\tint\t i_pa_cnt;\t\t\t \n\tstruct inode vfs_inode;\n};\n\n \nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct affs_inode_info, vfs_inode);\n}\n\n \n\nstruct affs_bm_info {\n\tu32 bm_key;\t\t\t \n\tu32 bm_free;\t\t\t \n};\n\nstruct affs_sb_info {\n\tint s_partition_size;\t\t \n\tint s_reserved;\t\t\t \n\t\n\tu32 s_data_blksize;\t\t \n\tu32 s_root_block;\t\t \n\tint s_hashsize;\t\t\t \n\tunsigned long s_flags;\t\t \n\tkuid_t s_uid;\t\t\t \n\tkgid_t s_gid;\t\t\t \n\tumode_t s_mode;\t\t\t \n\tstruct buffer_head *s_root_bh;\t \n\tstruct mutex s_bmlock;\t\t \n\tstruct affs_bm_info *s_bitmap;\t \n\tu32 s_bmap_count;\t\t \n\tu32 s_bmap_bits;\t\t \n\tu32 s_last_bmap;\n\tstruct buffer_head *s_bmap_bh;\n\tchar *s_prefix;\t\t\t \n\tchar s_volume[32];\t\t \n\tspinlock_t symlink_lock;\t \n\tstruct super_block *sb;\t\t \n\tint work_queued;\t\t \n\tstruct delayed_work sb_work;\t \n\tspinlock_t work_lock;\t\t \n};\n\n#define AFFS_MOUNT_SF_INTL\t\t0x0001  \n#define AFFS_MOUNT_SF_BM_VALID\t\t0x0002  \n#define AFFS_MOUNT_SF_IMMUTABLE\t\t0x0004  \n#define AFFS_MOUNT_SF_QUIET\t\t0x0008  \n#define AFFS_MOUNT_SF_SETUID\t\t0x0010  \n#define AFFS_MOUNT_SF_SETGID\t\t0x0020  \n#define AFFS_MOUNT_SF_SETMODE\t\t0x0040  \n#define AFFS_MOUNT_SF_MUFS\t\t0x0100  \n#define AFFS_MOUNT_SF_OFS\t\t0x0200  \n#define AFFS_MOUNT_SF_PREFIX\t\t0x0400  \n#define AFFS_MOUNT_SF_VERBOSE\t\t0x0800  \n#define AFFS_MOUNT_SF_NO_TRUNCATE\t0x1000  \n\n#define affs_clear_opt(o, opt)    (o &= ~AFFS_MOUNT_##opt)\n#define affs_set_opt(o, opt)      (o |= AFFS_MOUNT_##opt)\n#define affs_test_opt(o, opt)     ((o) & AFFS_MOUNT_##opt)\n\n \nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\n\n \n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern int\taffs_remove_hash(struct inode *dir, struct buffer_head *rem_bh);\nextern int\taffs_remove_header(struct dentry *dentry);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_secs_to_datestamp(time64_t secs, struct affs_date *ds);\nextern umode_t\taffs_prot_to_mode(u32 prot);\nextern void\taffs_mode_to_prot(struct inode *inode);\n__printf(3, 4)\nextern void\taffs_error(struct super_block *sb, const char *function,\n\t\t\t   const char *fmt, ...);\n__printf(3, 4)\nextern void\taffs_warning(struct super_block *sb, const char *function,\n\t\t\t     const char *fmt, ...);\nextern bool\taffs_nofilenametruncate(const struct dentry *dentry);\nextern int\taffs_check_name(const unsigned char *name, int len,\n\t\t\t\tbool notruncate);\nextern int\taffs_copy_name(unsigned char *bstr, struct dentry *dentry);\n\n \n\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern u32\taffs_alloc_block(struct inode *inode, u32 goal);\nextern int\taffs_init_bitmap(struct super_block *sb, int *flags);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\n \n\nextern const struct export_operations affs_export_ops;\nextern int\taffs_hash_name(struct super_block *sb, const u8 *name, unsigned int len);\nextern struct dentry *affs_lookup(struct inode *dir, struct dentry *dentry, unsigned int);\nextern int\taffs_unlink(struct inode *dir, struct dentry *dentry);\nextern int\taffs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct dentry *dentry, umode_t mode, bool);\nextern int\taffs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct dentry *dentry, umode_t mode);\nextern int\taffs_rmdir(struct inode *dir, struct dentry *dentry);\nextern int\taffs_link(struct dentry *olddentry, struct inode *dir,\n\t\t\t  struct dentry *dentry);\nextern int\taffs_symlink(struct mnt_idmap *idmap,\n\t\t\tstruct inode *dir, struct dentry *dentry,\n\t\t\tconst char *symname);\nextern int\taffs_rename2(struct mnt_idmap *idmap,\n\t\t\tstruct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry,\n\t\t\tunsigned int flags);\n\n \n\nextern struct inode\t\t*affs_new_inode(struct inode *dir);\nextern int\t\t\t affs_notify_change(struct mnt_idmap *idmap,\n\t\t\t\t\tstruct dentry *dentry, struct iattr *attr);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nextern struct inode\t\t*affs_iget(struct super_block *sb,\n\t\t\t\t\tunsigned long ino);\nextern int\t\t\t affs_write_inode(struct inode *inode,\n\t\t\t\t\tstruct writeback_control *wbc);\nextern int\t\t\t affs_add_entry(struct inode *dir, struct inode *inode,\n\t\t\t\t\tstruct dentry *dentry, s32 type);\n\n \n\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nint\t\taffs_file_fsync(struct file *, loff_t, loff_t, int);\n\n \n\nextern void   affs_dir_truncate(struct inode *);\n\n \n\nextern const struct inode_operations\t affs_file_inode_operations;\nextern const struct inode_operations\t affs_dir_inode_operations;\nextern const struct inode_operations   affs_symlink_inode_operations;\nextern const struct file_operations\t affs_file_operations;\nextern const struct file_operations\t affs_file_operations_ofs;\nextern const struct file_operations\t affs_dir_operations;\nextern const struct address_space_operations\t affs_symlink_aops;\nextern const struct address_space_operations\t affs_aops;\nextern const struct address_space_operations\t affs_aops_ofs;\n\nextern const struct dentry_operations\t affs_dentry_operations;\nextern const struct dentry_operations\t affs_intl_dentry_operations;\n\nstatic inline bool affs_validblock(struct super_block *sb, int block)\n{\n\treturn(block >= AFFS_SB(sb)->s_reserved &&\n\t       block < AFFS_SB(sb)->s_partition_size);\n}\n\nstatic inline void\naffs_set_blocksize(struct super_block *sb, int size)\n{\n\tsb_set_blocksize(sb, size);\n}\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (affs_validblock(sb, block))\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}\nstatic inline struct buffer_head *\naffs_getblk(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (affs_validblock(sb, block))\n\t\treturn sb_getblk(sb, block);\n\treturn NULL;\n}\nstatic inline struct buffer_head *\naffs_getzeroblk(struct super_block *sb, int block)\n{\n\tstruct buffer_head *bh;\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (affs_validblock(sb, block)) {\n\t\tbh = sb_getblk(sb, block);\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0 , sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\treturn bh;\n\t}\n\treturn NULL;\n}\nstatic inline struct buffer_head *\naffs_getemptyblk(struct super_block *sb, int block)\n{\n\tstruct buffer_head *bh;\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (affs_validblock(sb, block)) {\n\t\tbh = sb_getblk(sb, block);\n\t\twait_on_buffer(bh);\n\t\tset_buffer_uptodate(bh);\n\t\treturn bh;\n\t}\n\treturn NULL;\n}\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}\n\nstatic inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}\nstatic inline void\naffs_adjust_bitmapchecksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[0]);\n\t((__be32 *)bh->b_data)[0] = cpu_to_be32(tmp - val);\n}\n\nstatic inline void\naffs_lock_link(struct inode *inode)\n{\n\tmutex_lock(&AFFS_I(inode)->i_link_lock);\n}\nstatic inline void\naffs_unlock_link(struct inode *inode)\n{\n\tmutex_unlock(&AFFS_I(inode)->i_link_lock);\n}\nstatic inline void\naffs_lock_dir(struct inode *inode)\n{\n\tmutex_lock_nested(&AFFS_I(inode)->i_hash_lock, SINGLE_DEPTH_NESTING);\n}\nstatic inline void\naffs_unlock_dir(struct inode *inode)\n{\n\tmutex_unlock(&AFFS_I(inode)->i_hash_lock);\n}\nstatic inline void\naffs_lock_ext(struct inode *inode)\n{\n\tmutex_lock(&AFFS_I(inode)->i_ext_lock);\n}\nstatic inline void\naffs_unlock_ext(struct inode *inode)\n{\n\tmutex_unlock(&AFFS_I(inode)->i_ext_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}