{
  "module_name": "file.c",
  "hash_id": "84d0a614005f50b74b01619547ff0b2ef886dfab0c2b244f65099f7ccb59a18e",
  "original_prompt": "Ingested from linux-6.6.14/fs/affs/file.c",
  "human_readable_source": "\n \n\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/mpage.h>\n#include \"affs.h\"\n\nstatic struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);\n\nstatic int\naffs_file_open(struct inode *inode, struct file *filp)\n{\n\tpr_debug(\"open(%lu,%d)\\n\",\n\t\t inode->i_ino, atomic_read(&AFFS_I(inode)->i_opencnt));\n\tatomic_inc(&AFFS_I(inode)->i_opencnt);\n\treturn 0;\n}\n\nstatic int\naffs_file_release(struct inode *inode, struct file *filp)\n{\n\tpr_debug(\"release(%lu, %d)\\n\",\n\t\t inode->i_ino, atomic_read(&AFFS_I(inode)->i_opencnt));\n\n\tif (atomic_dec_and_test(&AFFS_I(inode)->i_opencnt)) {\n\t\tinode_lock(inode);\n\t\tif (inode->i_size != AFFS_I(inode)->mmu_private)\n\t\t\taffs_truncate(inode);\n\t\taffs_free_prealloc(inode);\n\t\tinode_unlock(inode);\n\t}\n\n\treturn 0;\n}\n\nstatic int\naffs_grow_extcache(struct inode *inode, u32 lc_idx)\n{\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*bh;\n\tu32 lc_max;\n\tint i, j, key;\n\n\tif (!AFFS_I(inode)->i_lc) {\n\t\tchar *ptr = (char *)get_zeroed_page(GFP_NOFS);\n\t\tif (!ptr)\n\t\t\treturn -ENOMEM;\n\t\tAFFS_I(inode)->i_lc = (u32 *)ptr;\n\t\tAFFS_I(inode)->i_ac = (struct affs_ext_key *)(ptr + AFFS_CACHE_SIZE / 2);\n\t}\n\n\tlc_max = AFFS_LC_SIZE << AFFS_I(inode)->i_lc_shift;\n\n\tif (AFFS_I(inode)->i_extcnt > lc_max) {\n\t\tu32 lc_shift, lc_mask, tmp, off;\n\n\t\t \n\t\tlc_shift = AFFS_I(inode)->i_lc_shift;\n\t\ttmp = (AFFS_I(inode)->i_extcnt / AFFS_LC_SIZE) >> lc_shift;\n\t\tfor (; tmp; tmp >>= 1)\n\t\t\tlc_shift++;\n\t\tlc_mask = (1 << lc_shift) - 1;\n\n\t\t \n\t\tlc_idx >>= (lc_shift - AFFS_I(inode)->i_lc_shift);\n\t\tAFFS_I(inode)->i_lc_size >>= (lc_shift - AFFS_I(inode)->i_lc_shift);\n\n\t\t \n\t\toff = 1 << (lc_shift - AFFS_I(inode)->i_lc_shift);\n\t\tfor (i = 1, j = off; j < AFFS_LC_SIZE; i++, j += off)\n\t\t\tAFFS_I(inode)->i_ac[i] = AFFS_I(inode)->i_ac[j];\n\n\t\tAFFS_I(inode)->i_lc_shift = lc_shift;\n\t\tAFFS_I(inode)->i_lc_mask = lc_mask;\n\t}\n\n\t \n\ti = AFFS_I(inode)->i_lc_size;\n\tAFFS_I(inode)->i_lc_size = lc_idx + 1;\n\tfor (; i <= lc_idx; i++) {\n\t\tif (!i) {\n\t\t\tAFFS_I(inode)->i_lc[0] = inode->i_ino;\n\t\t\tcontinue;\n\t\t}\n\t\tkey = AFFS_I(inode)->i_lc[i - 1];\n\t\tj = AFFS_I(inode)->i_lc_mask + 1;\n\t\t\n\t\tfor (; j > 0; j--) {\n\t\t\tbh = affs_bread(sb, key);\n\t\t\tif (!bh)\n\t\t\t\tgoto err;\n\t\t\tkey = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\t\taffs_brelse(bh);\n\t\t}\n\t\t\n\t\tAFFS_I(inode)->i_lc[i] = key;\n\t}\n\n\treturn 0;\n\nerr:\n\t\n\treturn -EIO;\n}\n\nstatic struct buffer_head *\naffs_alloc_extblock(struct inode *inode, struct buffer_head *bh, u32 ext)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh;\n\tu32 blocknr, tmp;\n\n\tblocknr = affs_alloc_block(inode, bh->b_blocknr);\n\tif (!blocknr)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tnew_bh = affs_getzeroblk(sb, blocknr);\n\tif (!new_bh) {\n\t\taffs_free_block(sb, blocknr);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tAFFS_HEAD(new_bh)->ptype = cpu_to_be32(T_LIST);\n\tAFFS_HEAD(new_bh)->key = cpu_to_be32(blocknr);\n\tAFFS_TAIL(sb, new_bh)->stype = cpu_to_be32(ST_FILE);\n\tAFFS_TAIL(sb, new_bh)->parent = cpu_to_be32(inode->i_ino);\n\taffs_fix_checksum(sb, new_bh);\n\n\tmark_buffer_dirty_inode(new_bh, inode);\n\n\ttmp = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\tif (tmp)\n\t\taffs_warning(sb, \"alloc_ext\", \"previous extension set (%x)\", tmp);\n\tAFFS_TAIL(sb, bh)->extension = cpu_to_be32(blocknr);\n\taffs_adjust_checksum(bh, blocknr - tmp);\n\tmark_buffer_dirty_inode(bh, inode);\n\n\tAFFS_I(inode)->i_extcnt++;\n\tmark_inode_dirty(inode);\n\n\treturn new_bh;\n}\n\nstatic inline struct buffer_head *\naffs_get_extblock(struct inode *inode, u32 ext)\n{\n\t \n\tstruct buffer_head *bh = AFFS_I(inode)->i_ext_bh;\n\tif (ext == AFFS_I(inode)->i_ext_last)\n\t\tget_bh(bh);\n\telse\n\t\t \n\t\tbh = affs_get_extblock_slow(inode, ext);\n\n\treturn bh;\n}\n\nstatic struct buffer_head *\naffs_get_extblock_slow(struct inode *inode, u32 ext)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tu32 ext_key;\n\tu32 lc_idx, lc_off, ac_idx;\n\tu32 tmp, idx;\n\n\tif (ext == AFFS_I(inode)->i_ext_last + 1) {\n\t\t \n\t\tbh = AFFS_I(inode)->i_ext_bh;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\tif (ext < AFFS_I(inode)->i_extcnt)\n\t\t\tgoto read_ext;\n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\t\tbh = affs_alloc_extblock(inode, bh, ext);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\n\tif (ext == 0) {\n\t\t \n\t\text_key = inode->i_ino;\n\t\tgoto read_ext;\n\t}\n\n\tif (ext >= AFFS_I(inode)->i_extcnt) {\n\t\tstruct buffer_head *prev_bh;\n\n\t\t \n\t\tBUG_ON(ext > AFFS_I(inode)->i_extcnt);\n\n\t\t \n\t\tprev_bh = affs_get_extblock(inode, ext - 1);\n\t\tif (IS_ERR(prev_bh))\n\t\t\treturn prev_bh;\n\t\tbh = affs_alloc_extblock(inode, prev_bh, ext);\n\t\taffs_brelse(prev_bh);\n\t\tif (IS_ERR(bh))\n\t\t\treturn bh;\n\t\tgoto store_ext;\n\t}\n\nagain:\n\t \n\tlc_idx = ext >> AFFS_I(inode)->i_lc_shift;\n\tlc_off = ext & AFFS_I(inode)->i_lc_mask;\n\n\tif (lc_idx >= AFFS_I(inode)->i_lc_size) {\n\t\tint err;\n\n\t\terr = affs_grow_extcache(inode, lc_idx);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tgoto again;\n\t}\n\n\t \n\tif (!lc_off) {\n\t\text_key = AFFS_I(inode)->i_lc[lc_idx];\n\t\tgoto read_ext;\n\t}\n\n\t \n\tac_idx = (ext - lc_idx - 1) & AFFS_AC_MASK;\n\tif (AFFS_I(inode)->i_ac[ac_idx].ext == ext) {\n\t\text_key = AFFS_I(inode)->i_ac[ac_idx].key;\n\t\tgoto read_ext;\n\t}\n\n\t \n\ttmp = ext;\n\tidx = ac_idx;\n\twhile (--tmp, --lc_off > 0) {\n\t\tidx = (idx - 1) & AFFS_AC_MASK;\n\t\tif (AFFS_I(inode)->i_ac[idx].ext == tmp) {\n\t\t\text_key = AFFS_I(inode)->i_ac[idx].key;\n\t\t\tgoto find_ext;\n\t\t}\n\t}\n\n\t \n\text_key = AFFS_I(inode)->i_lc[lc_idx];\nfind_ext:\n\t \n\t \n\tdo {\n\t\tbh = affs_bread(sb, ext_key);\n\t\tif (!bh)\n\t\t\tgoto err_bread;\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, bh)->extension);\n\t\taffs_brelse(bh);\n\t\ttmp++;\n\t} while (tmp < ext);\n\t \n\n\t \n\t \n\tAFFS_I(inode)->i_ac[ac_idx].ext = ext;\n\tAFFS_I(inode)->i_ac[ac_idx].key = ext_key;\n\nread_ext:\n\t \n\t \n\tbh = affs_bread(sb, ext_key);\n\tif (!bh)\n\t\tgoto err_bread;\n\t \n\nstore_ext:\n\t \n\taffs_brelse(AFFS_I(inode)->i_ext_bh);\n\tAFFS_I(inode)->i_ext_last = ext;\n\tAFFS_I(inode)->i_ext_bh = bh;\n\tget_bh(bh);\n\n\treturn bh;\n\nerr_bread:\n\taffs_brelse(bh);\n\treturn ERR_PTR(-EIO);\n}\n\nstatic int\naffs_get_block(struct inode *inode, sector_t block, struct buffer_head *bh_result, int create)\n{\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*ext_bh;\n\tu32\t\t\t ext;\n\n\tpr_debug(\"%s(%lu, %llu)\\n\", __func__, inode->i_ino,\n\t\t (unsigned long long)block);\n\n\tBUG_ON(block > (sector_t)0x7fffffffUL);\n\n\tif (block >= AFFS_I(inode)->i_blkcnt) {\n\t\tif (block > AFFS_I(inode)->i_blkcnt || !create)\n\t\t\tgoto err_big;\n\t} else\n\t\tcreate = 0;\n\n\t \n\taffs_lock_ext(inode);\n\n\text = (u32)block / AFFS_SB(sb)->s_hashsize;\n\tblock -= ext * AFFS_SB(sb)->s_hashsize;\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh))\n\t\tgoto err_ext;\n\tmap_bh(bh_result, sb, (sector_t)be32_to_cpu(AFFS_BLOCK(sb, ext_bh, block)));\n\n\tif (create) {\n\t\tu32 blocknr = affs_alloc_block(inode, ext_bh->b_blocknr);\n\t\tif (!blocknr)\n\t\t\tgoto err_alloc;\n\t\tset_buffer_new(bh_result);\n\t\tAFFS_I(inode)->mmu_private += AFFS_SB(sb)->s_data_blksize;\n\t\tAFFS_I(inode)->i_blkcnt++;\n\n\t\t \n\t\tif (bh_result->b_blocknr)\n\t\t\taffs_warning(sb, \"get_block\",\n\t\t\t\t     \"block already set (%llx)\",\n\t\t\t\t     (unsigned long long)bh_result->b_blocknr);\n\t\tAFFS_BLOCK(sb, ext_bh, block) = cpu_to_be32(blocknr);\n\t\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(block + 1);\n\t\taffs_adjust_checksum(ext_bh, blocknr - bh_result->b_blocknr + 1);\n\t\tbh_result->b_blocknr = blocknr;\n\n\t\tif (!block) {\n\t\t\t \n\t\t\tu32 tmp = be32_to_cpu(AFFS_HEAD(ext_bh)->first_data);\n\t\t\tif (tmp)\n\t\t\t\taffs_warning(sb, \"get_block\", \"first block already set (%d)\", tmp);\n\t\t\tAFFS_HEAD(ext_bh)->first_data = cpu_to_be32(blocknr);\n\t\t\taffs_adjust_checksum(ext_bh, blocknr - tmp);\n\t\t}\n\t}\n\n\taffs_brelse(ext_bh);\n\t \n\taffs_unlock_ext(inode);\n\treturn 0;\n\nerr_big:\n\taffs_error(inode->i_sb, \"get_block\", \"strange block request %llu\",\n\t\t   (unsigned long long)block);\n\treturn -EIO;\nerr_ext:\n\t \n\taffs_unlock_ext(inode);\n\treturn PTR_ERR(ext_bh);\nerr_alloc:\n\tbrelse(ext_bh);\n\tclear_buffer_mapped(bh_result);\n\tbh_result->b_bdev = NULL;\n\t \n\taffs_unlock_ext(inode);\n\treturn -ENOSPC;\n}\n\nstatic int affs_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, affs_get_block);\n}\n\nstatic int affs_read_folio(struct file *file, struct folio *folio)\n{\n\treturn block_read_full_folio(folio, affs_get_block);\n}\n\nstatic void affs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\taffs_truncate(inode);\n\t}\n}\n\nstatic ssize_t\naffs_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tloff_t offset = iocb->ki_pos;\n\tssize_t ret;\n\n\tif (iov_iter_rw(iter) == WRITE) {\n\t\tloff_t size = offset + count;\n\n\t\tif (AFFS_I(inode)->mmu_private < size)\n\t\t\treturn 0;\n\t}\n\n\tret = blockdev_direct_IO(iocb, inode, iter, affs_get_block);\n\tif (ret < 0 && iov_iter_rw(iter) == WRITE)\n\t\taffs_write_failed(mapping, offset + count);\n\treturn ret;\n}\n\nstatic int affs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\t*pagep = NULL;\n\tret = cont_write_begin(file, mapping, pos, len, pagep, fsdata,\n\t\t\t\taffs_get_block,\n\t\t\t\t&AFFS_I(mapping->host)->mmu_private);\n\tif (unlikely(ret))\n\t\taffs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}\n\nstatic int affs_write_end(struct file *file, struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned int len, unsigned int copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret;\n\n\tret = generic_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t \n\tif (AFFS_I(inode)->i_protect & FIBF_ARCHIVED) {\n\t\tAFFS_I(inode)->i_protect &= ~FIBF_ARCHIVED;\n\t\tmark_inode_dirty(inode);\n\t}\n\n\treturn ret;\n}\n\nstatic sector_t _affs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,affs_get_block);\n}\n\nconst struct address_space_operations affs_aops = {\n\t.dirty_folio\t= block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.read_folio = affs_read_folio,\n\t.writepages = affs_writepages,\n\t.write_begin = affs_write_begin,\n\t.write_end = affs_write_end,\n\t.direct_IO = affs_direct_IO,\n\t.migrate_folio = buffer_migrate_folio,\n\t.bmap = _affs_bmap\n};\n\nstatic inline struct buffer_head *\naffs_bread_ino(struct inode *inode, int block, int create)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, create);\n\tif (!err) {\n\t\tbh = affs_bread(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}\n\nstatic inline struct buffer_head *\naffs_getzeroblk_ino(struct inode *inode, int block)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n\tif (!err) {\n\t\tbh = affs_getzeroblk(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}\n\nstatic inline struct buffer_head *\naffs_getemptyblk_ino(struct inode *inode, int block)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n\tif (!err) {\n\t\tbh = affs_getemptyblk(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}\n\nstatic int affs_do_read_folio_ofs(struct folio *folio, size_t to, int create)\n{\n\tstruct inode *inode = folio->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tsize_t pos = 0;\n\tsize_t bidx, boff, bsize;\n\tu32 tmp;\n\n\tpr_debug(\"%s(%lu, %ld, 0, %zu)\\n\", __func__, inode->i_ino,\n\t\t folio->index, to);\n\tBUG_ON(to > folio_size(folio));\n\tbsize = AFFS_SB(sb)->s_data_blksize;\n\ttmp = folio_pos(folio);\n\tbidx = tmp / bsize;\n\tboff = tmp % bsize;\n\n\twhile (pos < to) {\n\t\tbh = affs_bread_ino(inode, bidx, create);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\ttmp = min(bsize - boff, to - pos);\n\t\tBUG_ON(pos + tmp > to || tmp > bsize);\n\t\tmemcpy_to_folio(folio, pos, AFFS_DATA(bh) + boff, tmp);\n\t\taffs_brelse(bh);\n\t\tbidx++;\n\t\tpos += tmp;\n\t\tboff = 0;\n\t}\n\treturn 0;\n}\n\nstatic int\naffs_extent_file_ofs(struct inode *inode, u32 newsize)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh, *prev_bh;\n\tu32 bidx, boff;\n\tu32 size, bsize;\n\tu32 tmp;\n\n\tpr_debug(\"%s(%lu, %d)\\n\", __func__, inode->i_ino, newsize);\n\tbsize = AFFS_SB(sb)->s_data_blksize;\n\tbh = NULL;\n\tsize = AFFS_I(inode)->mmu_private;\n\tbidx = size / bsize;\n\tboff = size % bsize;\n\tif (boff) {\n\t\tbh = affs_bread_ino(inode, bidx, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\ttmp = min(bsize - boff, newsize - size);\n\t\tBUG_ON(boff + tmp > bsize || tmp > bsize);\n\t\tmemset(AFFS_DATA(bh) + boff, 0, tmp);\n\t\tbe32_add_cpu(&AFFS_DATA_HEAD(bh)->size, tmp);\n\t\taffs_fix_checksum(sb, bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\tsize += tmp;\n\t\tbidx++;\n\t} else if (bidx) {\n\t\tbh = affs_bread_ino(inode, bidx - 1, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t}\n\n\twhile (size < newsize) {\n\t\tprev_bh = bh;\n\t\tbh = affs_getzeroblk_ino(inode, bidx);\n\t\tif (IS_ERR(bh))\n\t\t\tgoto out;\n\t\ttmp = min(bsize, newsize - size);\n\t\tBUG_ON(tmp > bsize);\n\t\tAFFS_DATA_HEAD(bh)->ptype = cpu_to_be32(T_DATA);\n\t\tAFFS_DATA_HEAD(bh)->key = cpu_to_be32(inode->i_ino);\n\t\tAFFS_DATA_HEAD(bh)->sequence = cpu_to_be32(bidx);\n\t\tAFFS_DATA_HEAD(bh)->size = cpu_to_be32(tmp);\n\t\taffs_fix_checksum(sb, bh);\n\t\tbh->b_state &= ~(1UL << BH_New);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\tif (prev_bh) {\n\t\t\tu32 tmp_next = be32_to_cpu(AFFS_DATA_HEAD(prev_bh)->next);\n\n\t\t\tif (tmp_next)\n\t\t\t\taffs_warning(sb, \"extent_file_ofs\",\n\t\t\t\t\t     \"next block already set for %d (%d)\",\n\t\t\t\t\t     bidx, tmp_next);\n\t\t\tAFFS_DATA_HEAD(prev_bh)->next = cpu_to_be32(bh->b_blocknr);\n\t\t\taffs_adjust_checksum(prev_bh, bh->b_blocknr - tmp_next);\n\t\t\tmark_buffer_dirty_inode(prev_bh, inode);\n\t\t\taffs_brelse(prev_bh);\n\t\t}\n\t\tsize += bsize;\n\t\tbidx++;\n\t}\n\taffs_brelse(bh);\n\tinode->i_size = AFFS_I(inode)->mmu_private = newsize;\n\treturn 0;\n\nout:\n\tinode->i_size = AFFS_I(inode)->mmu_private = newsize;\n\treturn PTR_ERR(bh);\n}\n\nstatic int affs_read_folio_ofs(struct file *file, struct folio *folio)\n{\n\tstruct inode *inode = folio->mapping->host;\n\tsize_t to;\n\tint err;\n\n\tpr_debug(\"%s(%lu, %ld)\\n\", __func__, inode->i_ino, folio->index);\n\tto = folio_size(folio);\n\tif (folio_pos(folio) + to > inode->i_size) {\n\t\tto = inode->i_size - folio_pos(folio);\n\t\tfolio_zero_segment(folio, to, folio_size(folio));\n\t}\n\n\terr = affs_do_read_folio_ofs(folio, to, 0);\n\tif (!err)\n\t\tfolio_mark_uptodate(folio);\n\tfolio_unlock(folio);\n\treturn err;\n}\n\nstatic int affs_write_begin_ofs(struct file *file, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len,\n\t\t\t\tstruct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct folio *folio;\n\tpgoff_t index;\n\tint err = 0;\n\n\tpr_debug(\"%s(%lu, %llu, %llu)\\n\", __func__, inode->i_ino, pos,\n\t\t pos + len);\n\tif (pos > AFFS_I(inode)->mmu_private) {\n\t\t \n\t\terr = affs_extent_file_ofs(inode, pos);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tindex = pos >> PAGE_SHIFT;\n\tfolio = __filemap_get_folio(mapping, index, FGP_WRITEBEGIN,\n\t\t\tmapping_gfp_mask(mapping));\n\tif (IS_ERR(folio))\n\t\treturn PTR_ERR(folio);\n\t*pagep = &folio->page;\n\n\tif (folio_test_uptodate(folio))\n\t\treturn 0;\n\n\t \n\terr = affs_do_read_folio_ofs(folio, folio_size(folio), 1);\n\tif (err) {\n\t\tfolio_unlock(folio);\n\t\tfolio_put(folio);\n\t}\n\treturn err;\n}\n\nstatic int affs_write_end_ofs(struct file *file, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct folio *folio = page_folio(page);\n\tstruct inode *inode = mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh, *prev_bh;\n\tchar *data;\n\tu32 bidx, boff, bsize;\n\tunsigned from, to;\n\tu32 tmp;\n\tint written;\n\n\tfrom = pos & (PAGE_SIZE - 1);\n\tto = from + len;\n\t \n\n\tpr_debug(\"%s(%lu, %llu, %llu)\\n\", __func__, inode->i_ino, pos,\n\t\t pos + len);\n\tbsize = AFFS_SB(sb)->s_data_blksize;\n\tdata = folio_address(folio);\n\n\tbh = NULL;\n\twritten = 0;\n\ttmp = (folio->index << PAGE_SHIFT) + from;\n\tbidx = tmp / bsize;\n\tboff = tmp % bsize;\n\tif (boff) {\n\t\tbh = affs_bread_ino(inode, bidx, 0);\n\t\tif (IS_ERR(bh)) {\n\t\t\twritten = PTR_ERR(bh);\n\t\t\tgoto err_first_bh;\n\t\t}\n\t\ttmp = min(bsize - boff, to - from);\n\t\tBUG_ON(boff + tmp > bsize || tmp > bsize);\n\t\tmemcpy(AFFS_DATA(bh) + boff, data + from, tmp);\n\t\tbe32_add_cpu(&AFFS_DATA_HEAD(bh)->size, tmp);\n\t\taffs_fix_checksum(sb, bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\twritten += tmp;\n\t\tfrom += tmp;\n\t\tbidx++;\n\t} else if (bidx) {\n\t\tbh = affs_bread_ino(inode, bidx - 1, 0);\n\t\tif (IS_ERR(bh)) {\n\t\t\twritten = PTR_ERR(bh);\n\t\t\tgoto err_first_bh;\n\t\t}\n\t}\n\twhile (from + bsize <= to) {\n\t\tprev_bh = bh;\n\t\tbh = affs_getemptyblk_ino(inode, bidx);\n\t\tif (IS_ERR(bh))\n\t\t\tgoto err_bh;\n\t\tmemcpy(AFFS_DATA(bh), data + from, bsize);\n\t\tif (buffer_new(bh)) {\n\t\t\tAFFS_DATA_HEAD(bh)->ptype = cpu_to_be32(T_DATA);\n\t\t\tAFFS_DATA_HEAD(bh)->key = cpu_to_be32(inode->i_ino);\n\t\t\tAFFS_DATA_HEAD(bh)->sequence = cpu_to_be32(bidx);\n\t\t\tAFFS_DATA_HEAD(bh)->size = cpu_to_be32(bsize);\n\t\t\tAFFS_DATA_HEAD(bh)->next = 0;\n\t\t\tbh->b_state &= ~(1UL << BH_New);\n\t\t\tif (prev_bh) {\n\t\t\t\tu32 tmp_next = be32_to_cpu(AFFS_DATA_HEAD(prev_bh)->next);\n\n\t\t\t\tif (tmp_next)\n\t\t\t\t\taffs_warning(sb, \"commit_write_ofs\",\n\t\t\t\t\t\t     \"next block already set for %d (%d)\",\n\t\t\t\t\t\t     bidx, tmp_next);\n\t\t\t\tAFFS_DATA_HEAD(prev_bh)->next = cpu_to_be32(bh->b_blocknr);\n\t\t\t\taffs_adjust_checksum(prev_bh, bh->b_blocknr - tmp_next);\n\t\t\t\tmark_buffer_dirty_inode(prev_bh, inode);\n\t\t\t}\n\t\t}\n\t\taffs_brelse(prev_bh);\n\t\taffs_fix_checksum(sb, bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\twritten += bsize;\n\t\tfrom += bsize;\n\t\tbidx++;\n\t}\n\tif (from < to) {\n\t\tprev_bh = bh;\n\t\tbh = affs_bread_ino(inode, bidx, 1);\n\t\tif (IS_ERR(bh))\n\t\t\tgoto err_bh;\n\t\ttmp = min(bsize, to - from);\n\t\tBUG_ON(tmp > bsize);\n\t\tmemcpy(AFFS_DATA(bh), data + from, tmp);\n\t\tif (buffer_new(bh)) {\n\t\t\tAFFS_DATA_HEAD(bh)->ptype = cpu_to_be32(T_DATA);\n\t\t\tAFFS_DATA_HEAD(bh)->key = cpu_to_be32(inode->i_ino);\n\t\t\tAFFS_DATA_HEAD(bh)->sequence = cpu_to_be32(bidx);\n\t\t\tAFFS_DATA_HEAD(bh)->size = cpu_to_be32(tmp);\n\t\t\tAFFS_DATA_HEAD(bh)->next = 0;\n\t\t\tbh->b_state &= ~(1UL << BH_New);\n\t\t\tif (prev_bh) {\n\t\t\t\tu32 tmp_next = be32_to_cpu(AFFS_DATA_HEAD(prev_bh)->next);\n\n\t\t\t\tif (tmp_next)\n\t\t\t\t\taffs_warning(sb, \"commit_write_ofs\",\n\t\t\t\t\t\t     \"next block already set for %d (%d)\",\n\t\t\t\t\t\t     bidx, tmp_next);\n\t\t\t\tAFFS_DATA_HEAD(prev_bh)->next = cpu_to_be32(bh->b_blocknr);\n\t\t\t\taffs_adjust_checksum(prev_bh, bh->b_blocknr - tmp_next);\n\t\t\t\tmark_buffer_dirty_inode(prev_bh, inode);\n\t\t\t}\n\t\t} else if (be32_to_cpu(AFFS_DATA_HEAD(bh)->size) < tmp)\n\t\t\tAFFS_DATA_HEAD(bh)->size = cpu_to_be32(tmp);\n\t\taffs_brelse(prev_bh);\n\t\taffs_fix_checksum(sb, bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\twritten += tmp;\n\t\tfrom += tmp;\n\t\tbidx++;\n\t}\n\tfolio_mark_uptodate(folio);\n\ndone:\n\taffs_brelse(bh);\n\ttmp = (folio->index << PAGE_SHIFT) + from;\n\tif (tmp > inode->i_size)\n\t\tinode->i_size = AFFS_I(inode)->mmu_private = tmp;\n\n\t \n\tif (AFFS_I(inode)->i_protect & FIBF_ARCHIVED) {\n\t\tAFFS_I(inode)->i_protect &= ~FIBF_ARCHIVED;\n\t\tmark_inode_dirty(inode);\n\t}\n\nerr_first_bh:\n\tfolio_unlock(folio);\n\tfolio_put(folio);\n\n\treturn written;\n\nerr_bh:\n\tbh = prev_bh;\n\tif (!written)\n\t\twritten = PTR_ERR(bh);\n\tgoto done;\n}\n\nconst struct address_space_operations affs_aops_ofs = {\n\t.dirty_folio\t= block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.read_folio = affs_read_folio_ofs,\n\t\n\t.write_begin = affs_write_begin_ofs,\n\t.write_end = affs_write_end_ofs,\n\t.migrate_folio = filemap_migrate_folio,\n};\n\n \n\nvoid\naffs_free_prealloc(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tpr_debug(\"free_prealloc(ino=%lu)\\n\", inode->i_ino);\n\n\twhile (AFFS_I(inode)->i_pa_cnt) {\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\taffs_free_block(sb, ++AFFS_I(inode)->i_lastalloc);\n\t}\n}\n\n \n\nvoid\naffs_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu32 ext, ext_key;\n\tu32 last_blk, blkcnt, blk;\n\tu32 size;\n\tstruct buffer_head *ext_bh;\n\tint i;\n\n\tpr_debug(\"truncate(inode=%lu, oldsize=%llu, newsize=%llu)\\n\",\n\t\t inode->i_ino, AFFS_I(inode)->mmu_private, inode->i_size);\n\n\tlast_blk = 0;\n\text = 0;\n\tif (inode->i_size) {\n\t\tlast_blk = ((u32)inode->i_size - 1) / AFFS_SB(sb)->s_data_blksize;\n\t\text = last_blk / AFFS_SB(sb)->s_hashsize;\n\t}\n\n\tif (inode->i_size > AFFS_I(inode)->mmu_private) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata = NULL;\n\t\tloff_t isize = inode->i_size;\n\t\tint res;\n\n\t\tres = mapping->a_ops->write_begin(NULL, mapping, isize, 0, &page, &fsdata);\n\t\tif (!res)\n\t\t\tres = mapping->a_ops->write_end(NULL, mapping, isize, 0, 0, page, fsdata);\n\t\telse\n\t\t\tinode->i_size = AFFS_I(inode)->mmu_private;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == AFFS_I(inode)->mmu_private)\n\t\treturn;\n\n\t\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh)) {\n\t\taffs_warning(sb, \"truncate\",\n\t\t\t     \"unexpected read error for ext block %u (%ld)\",\n\t\t\t     ext, PTR_ERR(ext_bh));\n\t\treturn;\n\t}\n\tif (AFFS_I(inode)->i_lc) {\n\t\t \n\t\ti = (ext + 1) >> AFFS_I(inode)->i_lc_shift;\n\t\tif (AFFS_I(inode)->i_lc_size > i) {\n\t\t\tAFFS_I(inode)->i_lc_size = i;\n\t\t\tfor (; i < AFFS_LC_SIZE; i++)\n\t\t\t\tAFFS_I(inode)->i_lc[i] = 0;\n\t\t}\n\t\t \n\t\tfor (i = 0; i < AFFS_AC_SIZE; i++)\n\t\t\tif (AFFS_I(inode)->i_ac[i].ext >= ext)\n\t\t\t\tAFFS_I(inode)->i_ac[i].ext = 0;\n\t}\n\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\n\tblkcnt = AFFS_I(inode)->i_blkcnt;\n\ti = 0;\n\tblk = last_blk;\n\tif (inode->i_size) {\n\t\ti = last_blk % AFFS_SB(sb)->s_hashsize + 1;\n\t\tblk++;\n\t} else\n\t\tAFFS_HEAD(ext_bh)->first_data = 0;\n\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(i);\n\tsize = AFFS_SB(sb)->s_hashsize;\n\tif (size > blkcnt - blk + i)\n\t\tsize = blkcnt - blk + i;\n\tfor (; i < size; i++, blk++) {\n\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\tAFFS_BLOCK(sb, ext_bh, i) = 0;\n\t}\n\tAFFS_TAIL(sb, ext_bh)->extension = 0;\n\taffs_fix_checksum(sb, ext_bh);\n\tmark_buffer_dirty_inode(ext_bh, inode);\n\taffs_brelse(ext_bh);\n\n\tif (inode->i_size) {\n\t\tAFFS_I(inode)->i_blkcnt = last_blk + 1;\n\t\tAFFS_I(inode)->i_extcnt = ext + 1;\n\t\tif (affs_test_opt(AFFS_SB(sb)->s_flags, SF_OFS)) {\n\t\t\tstruct buffer_head *bh = affs_bread_ino(inode, last_blk, 0);\n\t\t\tu32 tmp;\n\t\t\tif (IS_ERR(bh)) {\n\t\t\t\taffs_warning(sb, \"truncate\",\n\t\t\t\t\t     \"unexpected read error for last block %u (%ld)\",\n\t\t\t\t\t     ext, PTR_ERR(bh));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttmp = be32_to_cpu(AFFS_DATA_HEAD(bh)->next);\n\t\t\tAFFS_DATA_HEAD(bh)->next = 0;\n\t\t\taffs_adjust_checksum(bh, -tmp);\n\t\t\taffs_brelse(bh);\n\t\t}\n\t} else {\n\t\tAFFS_I(inode)->i_blkcnt = 0;\n\t\tAFFS_I(inode)->i_extcnt = 1;\n\t}\n\tAFFS_I(inode)->mmu_private = inode->i_size;\n\t\n\n\twhile (ext_key) {\n\t\text_bh = affs_bread(sb, ext_key);\n\t\tsize = AFFS_SB(sb)->s_hashsize;\n\t\tif (size > blkcnt - blk)\n\t\t\tsize = blkcnt - blk;\n\t\tfor (i = 0; i < size; i++, blk++)\n\t\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\taffs_free_block(sb, ext_key);\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\t\taffs_brelse(ext_bh);\n\t}\n\taffs_free_prealloc(inode);\n}\n\nint affs_file_fsync(struct file *filp, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint ret, err;\n\n\terr = file_write_and_wait_range(filp, start, end);\n\tif (err)\n\t\treturn err;\n\n\tinode_lock(inode);\n\tret = write_inode_now(inode, 0);\n\terr = sync_blockdev(inode->i_sb->s_bdev);\n\tif (!ret)\n\t\tret = err;\n\tinode_unlock(inode);\n\treturn ret;\n}\nconst struct file_operations affs_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.open\t\t= affs_file_open,\n\t.release\t= affs_file_release,\n\t.fsync\t\t= affs_file_fsync,\n\t.splice_read\t= filemap_splice_read,\n};\n\nconst struct inode_operations affs_file_inode_operations = {\n\t.setattr\t= affs_notify_change,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}