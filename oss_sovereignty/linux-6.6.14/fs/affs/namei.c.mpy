{
  "module_name": "namei.c",
  "hash_id": "285370767efdb4f88caed372af4df3cb8f56cf2f5c6f6136f7932f2e037d8459",
  "original_prompt": "Ingested from linux-6.6.14/fs/affs/namei.c",
  "human_readable_source": "\n \n\n#include \"affs.h\"\n#include <linux/exportfs.h>\n\ntypedef int (*toupper_t)(int);\n\n \n\nstatic int\naffs_toupper(int ch)\n{\n\treturn ch >= 'a' && ch <= 'z' ? ch -= ('a' - 'A') : ch;\n}\n\n \n\nstatic int\naffs_intl_toupper(int ch)\n{\n\treturn (ch >= 'a' && ch <= 'z') || (ch >= 0xE0\n\t\t&& ch <= 0xFE && ch != 0xF7) ?\n\t\tch - ('a' - 'A') : ch;\n}\n\nstatic inline toupper_t\naffs_get_toupper(struct super_block *sb)\n{\n\treturn affs_test_opt(AFFS_SB(sb)->s_flags, SF_INTL) ?\n\t       affs_intl_toupper : affs_toupper;\n}\n\n \nstatic inline int\n__affs_hash_dentry(const struct dentry *dentry, struct qstr *qstr, toupper_t fn, bool notruncate)\n{\n\tconst u8 *name = qstr->name;\n\tunsigned long hash;\n\tint retval;\n\tu32 len;\n\n\tretval = affs_check_name(qstr->name, qstr->len, notruncate);\n\tif (retval)\n\t\treturn retval;\n\n\thash = init_name_hash(dentry);\n\tlen = min(qstr->len, AFFSNAMEMAX);\n\tfor (; len > 0; name++, len--)\n\t\thash = partial_name_hash(fn(*name), hash);\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}\n\nstatic int\naffs_hash_dentry(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn __affs_hash_dentry(dentry, qstr, affs_toupper,\n\t\t\t\t  affs_nofilenametruncate(dentry));\n\n}\n\nstatic int\naffs_intl_hash_dentry(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn __affs_hash_dentry(dentry, qstr, affs_intl_toupper,\n\t\t\t\t  affs_nofilenametruncate(dentry));\n\n}\n\nstatic inline int __affs_compare_dentry(unsigned int len,\n\t\tconst char *str, const struct qstr *name, toupper_t fn,\n\t\tbool notruncate)\n{\n\tconst u8 *aname = str;\n\tconst u8 *bname = name->name;\n\n\t \n\n\tif (affs_check_name(name->name, name->len, notruncate))\n\t\treturn 1;\n\n\t \n\tif (len >= AFFSNAMEMAX) {\n\t\tif (name->len < AFFSNAMEMAX)\n\t\t\treturn 1;\n\t\tlen = AFFSNAMEMAX;\n\t} else if (len != name->len)\n\t\treturn 1;\n\n\tfor (; len > 0; len--)\n\t\tif (fn(*aname++) != fn(*bname++))\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int\naffs_compare_dentry(const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\n\treturn __affs_compare_dentry(len, str, name, affs_toupper,\n\t\t\t\t     affs_nofilenametruncate(dentry));\n}\n\nstatic int\naffs_intl_compare_dentry(const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn __affs_compare_dentry(len, str, name, affs_intl_toupper,\n\t\t\t\t     affs_nofilenametruncate(dentry));\n\n}\n\n \n\nstatic inline int\naffs_match(struct dentry *dentry, const u8 *name2, toupper_t fn)\n{\n\tconst u8 *name = dentry->d_name.name;\n\tint len = dentry->d_name.len;\n\n\tif (len >= AFFSNAMEMAX) {\n\t\tif (*name2 < AFFSNAMEMAX)\n\t\t\treturn 0;\n\t\tlen = AFFSNAMEMAX;\n\t} else if (len != *name2)\n\t\treturn 0;\n\n\tfor (name2++; len > 0; len--)\n\t\tif (fn(*name++) != fn(*name2++))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint\naffs_hash_name(struct super_block *sb, const u8 *name, unsigned int len)\n{\n\ttoupper_t fn = affs_get_toupper(sb);\n\tu32 hash;\n\n\thash = len = min(len, AFFSNAMEMAX);\n\tfor (; len > 0; len--)\n\t\thash = (hash * 13 + fn(*name++)) & 0x7ff;\n\n\treturn hash % AFFS_SB(sb)->s_hashsize;\n}\n\nstatic struct buffer_head *\naffs_find_entry(struct inode *dir, struct dentry *dentry)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *bh;\n\ttoupper_t fn = affs_get_toupper(sb);\n\tu32 key;\n\n\tpr_debug(\"%s(\\\"%pd\\\")\\n\", __func__, dentry);\n\n\tbh = affs_bread(sb, dir->i_ino);\n\tif (!bh)\n\t\treturn ERR_PTR(-EIO);\n\n\tkey = be32_to_cpu(AFFS_HEAD(bh)->table[affs_hash_name(sb, dentry->d_name.name, dentry->d_name.len)]);\n\n\tfor (;;) {\n\t\taffs_brelse(bh);\n\t\tif (key == 0)\n\t\t\treturn NULL;\n\t\tbh = affs_bread(sb, key);\n\t\tif (!bh)\n\t\t\treturn ERR_PTR(-EIO);\n\t\tif (affs_match(dentry, AFFS_TAIL(sb, bh)->name, fn))\n\t\t\treturn bh;\n\t\tkey = be32_to_cpu(AFFS_TAIL(sb, bh)->hash_chain);\n\t}\n}\n\nstruct dentry *\naffs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *bh;\n\tstruct inode *inode = NULL;\n\tstruct dentry *res;\n\n\tpr_debug(\"%s(\\\"%pd\\\")\\n\", __func__, dentry);\n\n\taffs_lock_dir(dir);\n\tbh = affs_find_entry(dir, dentry);\n\tif (IS_ERR(bh)) {\n\t\taffs_unlock_dir(dir);\n\t\treturn ERR_CAST(bh);\n\t}\n\tif (bh) {\n\t\tu32 ino = bh->b_blocknr;\n\n\t\t \n\t\tdentry->d_fsdata = (void *)(long)ino;\n\t\tswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\n\t\t\n\t\t\n\t\tcase ST_LINKFILE:\n\t\t\tino = be32_to_cpu(AFFS_TAIL(sb, bh)->original);\n\t\t}\n\t\taffs_brelse(bh);\n\t\tinode = affs_iget(sb, ino);\n\t}\n\tres = d_splice_alias(inode, dentry);\n\tif (!IS_ERR_OR_NULL(res))\n\t\tres->d_fsdata = dentry->d_fsdata;\n\taffs_unlock_dir(dir);\n\treturn res;\n}\n\nint\naffs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tpr_debug(\"%s(dir=%lu, %lu \\\"%pd\\\")\\n\", __func__, dir->i_ino,\n\t\t d_inode(dentry)->i_ino, dentry);\n\n\treturn affs_remove_header(dentry);\n}\n\nint\naffs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t    struct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode\t*inode;\n\tint\t\t error;\n\n\tpr_debug(\"%s(%lu,\\\"%pd\\\",0%ho)\\n\",\n\t\t __func__, dir->i_ino, dentry, mode);\n\n\tinode = affs_new_inode(dir);\n\tif (!inode)\n\t\treturn -ENOSPC;\n\n\tinode->i_mode = mode;\n\taffs_mode_to_prot(inode);\n\tmark_inode_dirty(inode);\n\n\tinode->i_op = &affs_file_inode_operations;\n\tinode->i_fop = &affs_file_operations;\n\tinode->i_mapping->a_ops = affs_test_opt(AFFS_SB(sb)->s_flags, SF_OFS) ?\n\t\t\t\t  &affs_aops_ofs : &affs_aops;\n\terror = affs_add_entry(dir, inode, dentry, ST_FILE);\n\tif (error) {\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t\treturn error;\n\t}\n\treturn 0;\n}\n\nint\naffs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t   struct dentry *dentry, umode_t mode)\n{\n\tstruct inode\t\t*inode;\n\tint\t\t\t error;\n\n\tpr_debug(\"%s(%lu,\\\"%pd\\\",0%ho)\\n\",\n\t\t __func__, dir->i_ino, dentry, mode);\n\n\tinode = affs_new_inode(dir);\n\tif (!inode)\n\t\treturn -ENOSPC;\n\n\tinode->i_mode = S_IFDIR | mode;\n\taffs_mode_to_prot(inode);\n\n\tinode->i_op = &affs_dir_inode_operations;\n\tinode->i_fop = &affs_dir_operations;\n\n\terror = affs_add_entry(dir, inode, dentry, ST_USERDIR);\n\tif (error) {\n\t\tclear_nlink(inode);\n\t\tmark_inode_dirty(inode);\n\t\tiput(inode);\n\t\treturn error;\n\t}\n\treturn 0;\n}\n\nint\naffs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tpr_debug(\"%s(dir=%lu, %lu \\\"%pd\\\")\\n\", __func__, dir->i_ino,\n\t\t d_inode(dentry)->i_ino, dentry);\n\n\treturn affs_remove_header(dentry);\n}\n\nint\naffs_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t     struct dentry *dentry, const char *symname)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct buffer_head\t*bh;\n\tstruct inode\t\t*inode;\n\tchar\t\t\t*p;\n\tint\t\t\t i, maxlen, error;\n\tchar\t\t\t c, lc;\n\n\tpr_debug(\"%s(%lu,\\\"%pd\\\" -> \\\"%s\\\")\\n\",\n\t\t __func__, dir->i_ino, dentry, symname);\n\n\tmaxlen = AFFS_SB(sb)->s_hashsize * sizeof(u32) - 1;\n\tinode  = affs_new_inode(dir);\n\tif (!inode)\n\t\treturn -ENOSPC;\n\n\tinode->i_op = &affs_symlink_inode_operations;\n\tinode_nohighmem(inode);\n\tinode->i_data.a_ops = &affs_symlink_aops;\n\tinode->i_mode = S_IFLNK | 0777;\n\taffs_mode_to_prot(inode);\n\n\terror = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto err;\n\ti  = 0;\n\tp  = (char *)AFFS_HEAD(bh)->table;\n\tlc = '/';\n\tif (*symname == '/') {\n\t\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\t\twhile (*symname == '/')\n\t\t\tsymname++;\n\t\tspin_lock(&sbi->symlink_lock);\n\t\twhile (sbi->s_volume[i])\t \n\t\t\t*p++ = sbi->s_volume[i++];\n\t\tspin_unlock(&sbi->symlink_lock);\n\t}\n\twhile (i < maxlen && (c = *symname++)) {\n\t\tif (c == '.' && lc == '/' && *symname == '.' && symname[1] == '/') {\n\t\t\t*p++ = '/';\n\t\t\ti++;\n\t\t\tsymname += 2;\n\t\t\tlc = '/';\n\t\t} else if (c == '.' && lc == '/' && *symname == '/') {\n\t\t\tsymname++;\n\t\t\tlc = '/';\n\t\t} else {\n\t\t\t*p++ = c;\n\t\t\tlc   = c;\n\t\t\ti++;\n\t\t}\n\t\tif (lc == '/')\n\t\t\twhile (*symname == '/')\n\t\t\t\tsymname++;\n\t}\n\t*p = 0;\n\tinode->i_size = i + 1;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\tmark_inode_dirty(inode);\n\n\terror = affs_add_entry(dir, inode, dentry, ST_SOFTLINK);\n\tif (error)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tclear_nlink(inode);\n\tmark_inode_dirty(inode);\n\tiput(inode);\n\treturn error;\n}\n\nint\naffs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(old_dentry);\n\n\tpr_debug(\"%s(%lu, %lu, \\\"%pd\\\")\\n\", __func__, inode->i_ino, dir->i_ino,\n\t\t dentry);\n\n\treturn affs_add_entry(dir, inode, dentry, ST_LINKFILE);\n}\n\nstatic int\naffs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t    struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct super_block *sb = old_dir->i_sb;\n\tstruct buffer_head *bh = NULL;\n\tint retval;\n\n\tretval = affs_check_name(new_dentry->d_name.name,\n\t\t\t\t new_dentry->d_name.len,\n\t\t\t\t affs_nofilenametruncate(old_dentry));\n\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tif (d_really_is_positive(new_dentry)) {\n\t\tretval = affs_remove_header(new_dentry);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tbh = affs_bread(sb, d_inode(old_dentry)->i_ino);\n\tif (!bh)\n\t\treturn -EIO;\n\n\t \n\taffs_lock_dir(old_dir);\n\tretval = affs_remove_hash(old_dir, bh);\n\taffs_unlock_dir(old_dir);\n\tif (retval)\n\t\tgoto done;\n\n\t \n\taffs_copy_name(AFFS_TAIL(sb, bh)->name, new_dentry);\n\taffs_fix_checksum(sb, bh);\n\taffs_lock_dir(new_dir);\n\tretval = affs_insert_hash(new_dir, bh);\n\taffs_unlock_dir(new_dir);\n\t \n\ndone:\n\tmark_buffer_dirty_inode(bh, retval ? old_dir : new_dir);\n\taffs_brelse(bh);\n\treturn retval;\n}\n\nstatic int\naffs_xrename(struct inode *old_dir, struct dentry *old_dentry,\n\t     struct inode *new_dir, struct dentry *new_dentry)\n{\n\n\tstruct super_block *sb = old_dir->i_sb;\n\tstruct buffer_head *bh_old = NULL;\n\tstruct buffer_head *bh_new = NULL;\n\tint retval;\n\n\tbh_old = affs_bread(sb, d_inode(old_dentry)->i_ino);\n\tif (!bh_old)\n\t\treturn -EIO;\n\n\tbh_new = affs_bread(sb, d_inode(new_dentry)->i_ino);\n\tif (!bh_new) {\n\t\taffs_brelse(bh_old);\n\t\treturn -EIO;\n\t}\n\n\t \n\taffs_lock_dir(old_dir);\n\tretval = affs_remove_hash(old_dir, bh_old);\n\taffs_unlock_dir(old_dir);\n\tif (retval)\n\t\tgoto done;\n\n\t \n\taffs_lock_dir(new_dir);\n\tretval = affs_remove_hash(new_dir, bh_new);\n\taffs_unlock_dir(new_dir);\n\tif (retval)\n\t\tgoto done;\n\n\t \n\taffs_copy_name(AFFS_TAIL(sb, bh_old)->name, new_dentry);\n\taffs_fix_checksum(sb, bh_old);\n\taffs_lock_dir(new_dir);\n\tretval = affs_insert_hash(new_dir, bh_old);\n\taffs_unlock_dir(new_dir);\n\n\t \n\taffs_copy_name(AFFS_TAIL(sb, bh_new)->name, old_dentry);\n\taffs_fix_checksum(sb, bh_new);\n\taffs_lock_dir(old_dir);\n\tretval = affs_insert_hash(old_dir, bh_new);\n\taffs_unlock_dir(old_dir);\ndone:\n\tmark_buffer_dirty_inode(bh_old, new_dir);\n\tmark_buffer_dirty_inode(bh_new, old_dir);\n\taffs_brelse(bh_old);\n\taffs_brelse(bh_new);\n\treturn retval;\n}\n\nint affs_rename2(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\t struct dentry *old_dentry, struct inode *new_dir,\n\t\t struct dentry *new_dentry, unsigned int flags)\n{\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\n\tpr_debug(\"%s(old=%lu,\\\"%pd\\\" to new=%lu,\\\"%pd\\\")\\n\", __func__,\n\t\t old_dir->i_ino, old_dentry, new_dir->i_ino, new_dentry);\n\n\tif (flags & RENAME_EXCHANGE)\n\t\treturn affs_xrename(old_dir, old_dentry, new_dir, new_dentry);\n\n\treturn affs_rename(old_dir, old_dentry, new_dir, new_dentry);\n}\n\nstatic struct dentry *affs_get_parent(struct dentry *child)\n{\n\tstruct inode *parent;\n\tstruct buffer_head *bh;\n\n\tbh = affs_bread(child->d_sb, d_inode(child)->i_ino);\n\tif (!bh)\n\t\treturn ERR_PTR(-EIO);\n\n\tparent = affs_iget(child->d_sb,\n\t\t\t   be32_to_cpu(AFFS_TAIL(child->d_sb, bh)->parent));\n\tbrelse(bh);\n\tif (IS_ERR(parent))\n\t\treturn ERR_CAST(parent);\n\n\treturn d_obtain_alias(parent);\n}\n\nstatic struct inode *affs_nfs_get_inode(struct super_block *sb, u64 ino,\n\t\t\t\t\tu32 generation)\n{\n\tstruct inode *inode;\n\n\tif (!affs_validblock(sb, ino))\n\t\treturn ERR_PTR(-ESTALE);\n\n\tinode = affs_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\treturn inode;\n}\n\nstatic struct dentry *affs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t\t\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    affs_nfs_get_inode);\n}\n\nstatic struct dentry *affs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\t\t\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    affs_nfs_get_inode);\n}\n\nconst struct export_operations affs_export_ops = {\n\t.fh_to_dentry = affs_fh_to_dentry,\n\t.fh_to_parent = affs_fh_to_parent,\n\t.get_parent = affs_get_parent,\n};\n\nconst struct dentry_operations affs_dentry_operations = {\n\t.d_hash\t\t= affs_hash_dentry,\n\t.d_compare\t= affs_compare_dentry,\n};\n\nconst struct dentry_operations affs_intl_dentry_operations = {\n\t.d_hash\t\t= affs_intl_hash_dentry,\n\t.d_compare\t= affs_intl_compare_dentry,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}