{
  "module_name": "inode.c",
  "hash_id": "a9f472ec14c22b07b4480cab4422505438ec0c4579ac1a5d1249ab6a8f73b10e",
  "original_prompt": "Ingested from linux-6.6.14/fs/affs/inode.c",
  "human_readable_source": "\n \n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/gfp.h>\n#include \"affs.h\"\n\nstruct inode *affs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct affs_sb_info\t*sbi = AFFS_SB(sb);\n\tstruct buffer_head\t*bh;\n\tstruct affs_tail\t*tail;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tu32\t\t\t size;\n\tu32\t\t\t prot;\n\tu16\t\t\t id;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tpr_debug(\"affs_iget(%lu)\\n\", inode->i_ino);\n\n\tblock = inode->i_ino;\n\tbh = affs_bread(sb, block);\n\tif (!bh) {\n\t\taffs_warning(sb, \"read_inode\", \"Cannot read block %d\", block);\n\t\tgoto bad_inode;\n\t}\n\tif (affs_checksum_block(sb, bh) || be32_to_cpu(AFFS_HEAD(bh)->ptype) != T_SHORT) {\n\t\taffs_warning(sb,\"read_inode\",\n\t\t\t   \"Checksum or type (ptype=%d) error on inode %d\",\n\t\t\t   AFFS_HEAD(bh)->ptype, block);\n\t\tgoto bad_inode;\n\t}\n\n\ttail = AFFS_TAIL(sb, bh);\n\tprot = be32_to_cpu(tail->protect);\n\n\tinode->i_size = 0;\n\tset_nlink(inode, 1);\n\tinode->i_mode = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\tAFFS_I(inode)->i_protect = prot;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\n\tif (affs_test_opt(sbi->s_flags, SF_SETMODE))\n\t\tinode->i_mode = sbi->s_mode;\n\telse\n\t\tinode->i_mode = affs_prot_to_mode(prot);\n\n\tid = be16_to_cpu(tail->uid);\n\tif (id == 0 || affs_test_opt(sbi->s_flags, SF_SETUID))\n\t\tinode->i_uid = sbi->s_uid;\n\telse if (id == 0xFFFF && affs_test_opt(sbi->s_flags, SF_MUFS))\n\t\ti_uid_write(inode, 0);\n\telse\n\t\ti_uid_write(inode, id);\n\n\tid = be16_to_cpu(tail->gid);\n\tif (id == 0 || affs_test_opt(sbi->s_flags, SF_SETGID))\n\t\tinode->i_gid = sbi->s_gid;\n\telse if (id == 0xFFFF && affs_test_opt(sbi->s_flags, SF_MUFS))\n\t\ti_gid_write(inode, 0);\n\telse\n\t\ti_gid_write(inode, id);\n\n\tswitch (be32_to_cpu(tail->stype)) {\n\tcase ST_ROOT:\n\t\tinode->i_uid = sbi->s_uid;\n\t\tinode->i_gid = sbi->s_gid;\n\t\tfallthrough;\n\tcase ST_USERDIR:\n\t\tif (be32_to_cpu(tail->stype) == ST_USERDIR ||\n\t\t    affs_test_opt(sbi->s_flags, SF_SETMODE)) {\n\t\t\tif (inode->i_mode & S_IRUSR)\n\t\t\t\tinode->i_mode |= S_IXUSR;\n\t\t\tif (inode->i_mode & S_IRGRP)\n\t\t\t\tinode->i_mode |= S_IXGRP;\n\t\t\tif (inode->i_mode & S_IROTH)\n\t\t\t\tinode->i_mode |= S_IXOTH;\n\t\t\tinode->i_mode |= S_IFDIR;\n\t\t} else\n\t\t\tinode->i_mode = S_IRUGO | S_IXUGO | S_IWUSR | S_IFDIR;\n\t\t \n\t\t\n\t\tinode->i_op = &affs_dir_inode_operations;\n\t\tinode->i_fop = &affs_dir_operations;\n\t\tbreak;\n\tcase ST_LINKDIR:\n#if 0\n\t\taffs_warning(sb, \"read_inode\", \"inode is LINKDIR\");\n\t\tgoto bad_inode;\n#else\n\t\tinode->i_mode |= S_IFDIR;\n\t\t \n\t\tbreak;\n#endif\n\tcase ST_LINKFILE:\n\t\taffs_warning(sb, \"read_inode\", \"inode is LINKFILE\");\n\t\tgoto bad_inode;\n\tcase ST_FILE:\n\t\tsize = be32_to_cpu(tail->size);\n\t\tinode->i_mode |= S_IFREG;\n\t\tAFFS_I(inode)->mmu_private = inode->i_size = size;\n\t\tif (inode->i_size) {\n\t\t\tAFFS_I(inode)->i_blkcnt = (size - 1) /\n\t\t\t\t\t       sbi->s_data_blksize + 1;\n\t\t\tAFFS_I(inode)->i_extcnt = (AFFS_I(inode)->i_blkcnt - 1) /\n\t\t\t\t\t       sbi->s_hashsize + 1;\n\t\t}\n\t\tif (tail->link_chain)\n\t\t\tset_nlink(inode, 2);\n\t\tinode->i_mapping->a_ops = affs_test_opt(sbi->s_flags, SF_OFS) ?\n\t\t\t\t\t  &affs_aops_ofs : &affs_aops;\n\t\tinode->i_op = &affs_file_inode_operations;\n\t\tinode->i_fop = &affs_file_operations;\n\t\tbreak;\n\tcase ST_SOFTLINK:\n\t\tinode->i_size = strlen((char *)AFFS_HEAD(bh)->table);\n\t\tinode->i_mode |= S_IFLNK;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_op = &affs_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &affs_symlink_aops;\n\t\tbreak;\n\t}\n\n\tinode->i_mtime.tv_sec = inode->i_atime.tv_sec =\n\t\tinode_set_ctime(inode,\n\t\t\t\t(be32_to_cpu(tail->change.days) * 86400LL +\n\t\t\t\t be32_to_cpu(tail->change.mins) * 60 +\n\t\t\t\t be32_to_cpu(tail->change.ticks) / 50 + AFFS_EPOCH_DELTA)\n\t\t\t\t+ sys_tz.tz_minuteswest * 60, 0).tv_sec;\n\tinode->i_mtime.tv_nsec = inode->i_atime.tv_nsec = 0;\n\taffs_brelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\taffs_brelse(bh);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}\n\nint\naffs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*bh;\n\tstruct affs_tail\t*tail;\n\tuid_t\t\t\t uid;\n\tgid_t\t\t\t gid;\n\n\tpr_debug(\"write_inode(%lu)\\n\", inode->i_ino);\n\n\tif (!inode->i_nlink)\n\t\t\n\t\treturn 0;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh) {\n\t\taffs_error(sb,\"write_inode\",\"Cannot read block %lu\",inode->i_ino);\n\t\treturn -EIO;\n\t}\n\ttail = AFFS_TAIL(sb, bh);\n\tif (tail->stype == cpu_to_be32(ST_ROOT)) {\n\t\taffs_secs_to_datestamp(inode->i_mtime.tv_sec,\n\t\t\t\t       &AFFS_ROOT_TAIL(sb, bh)->root_change);\n\t} else {\n\t\ttail->protect = cpu_to_be32(AFFS_I(inode)->i_protect);\n\t\ttail->size = cpu_to_be32(inode->i_size);\n\t\taffs_secs_to_datestamp(inode->i_mtime.tv_sec, &tail->change);\n\t\tif (!(inode->i_ino == AFFS_SB(sb)->s_root_block)) {\n\t\t\tuid = i_uid_read(inode);\n\t\t\tgid = i_gid_read(inode);\n\t\t\tif (affs_test_opt(AFFS_SB(sb)->s_flags, SF_MUFS)) {\n\t\t\t\tif (uid == 0 || uid == 0xFFFF)\n\t\t\t\t\tuid = uid ^ ~0;\n\t\t\t\tif (gid == 0 || gid == 0xFFFF)\n\t\t\t\t\tgid = gid ^ ~0;\n\t\t\t}\n\t\t\tif (!affs_test_opt(AFFS_SB(sb)->s_flags, SF_SETUID))\n\t\t\t\ttail->uid = cpu_to_be16(uid);\n\t\t\tif (!affs_test_opt(AFFS_SB(sb)->s_flags, SF_SETGID))\n\t\t\t\ttail->gid = cpu_to_be16(gid);\n\t\t}\n\t}\n\taffs_fix_checksum(sb, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\taffs_free_prealloc(inode);\n\treturn 0;\n}\n\nint\naffs_notify_change(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t   struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint error;\n\n\tpr_debug(\"notify_change(%lu,0x%x)\\n\", inode->i_ino, attr->ia_valid);\n\n\terror = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\tif (error)\n\t\tgoto out;\n\n\tif (((attr->ia_valid & ATTR_UID) &&\n\t      affs_test_opt(AFFS_SB(inode->i_sb)->s_flags, SF_SETUID)) ||\n\t    ((attr->ia_valid & ATTR_GID) &&\n\t      affs_test_opt(AFFS_SB(inode->i_sb)->s_flags, SF_SETGID)) ||\n\t    ((attr->ia_valid & ATTR_MODE) &&\n\t     (AFFS_SB(inode->i_sb)->s_flags &\n\t      (AFFS_MOUNT_SF_SETMODE | AFFS_MOUNT_SF_IMMUTABLE)))) {\n\t\tif (!affs_test_opt(AFFS_SB(inode->i_sb)->s_flags, SF_QUIET))\n\t\t\terror = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\taffs_truncate(inode);\n\t}\n\n\tsetattr_copy(&nop_mnt_idmap, inode, attr);\n\tmark_inode_dirty(inode);\n\n\tif (attr->ia_valid & ATTR_MODE)\n\t\taffs_mode_to_prot(inode);\nout:\n\treturn error;\n}\n\nvoid\naffs_evict_inode(struct inode *inode)\n{\n\tunsigned long cache_page;\n\tpr_debug(\"evict_inode(ino=%lu, nlink=%u)\\n\",\n\t\t inode->i_ino, inode->i_nlink);\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\tif (!inode->i_nlink) {\n\t\tinode->i_size = 0;\n\t\taffs_truncate(inode);\n\t}\n\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\taffs_free_prealloc(inode);\n\tcache_page = (unsigned long)AFFS_I(inode)->i_lc;\n\tif (cache_page) {\n\t\tpr_debug(\"freeing ext cache\\n\");\n\t\tAFFS_I(inode)->i_lc = NULL;\n\t\tAFFS_I(inode)->i_ac = NULL;\n\t\tfree_page(cache_page);\n\t}\n\taffs_brelse(AFFS_I(inode)->i_ext_bh);\n\tAFFS_I(inode)->i_ext_last = ~1;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\n\tif (!inode->i_nlink)\n\t\taffs_free_block(inode->i_sb, inode->i_ino);\n}\n\nstruct inode *\naffs_new_inode(struct inode *dir)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tstruct buffer_head\t*bh;\n\n\tif (!(inode = new_inode(sb)))\n\t\tgoto err_inode;\n\n\tif (!(block = affs_alloc_block(dir, dir->i_ino)))\n\t\tgoto err_block;\n\n\tbh = affs_getzeroblk(sb, block);\n\tif (!bh)\n\t\tgoto err_bh;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\n\tinode->i_uid     = current_fsuid();\n\tinode->i_gid     = current_fsgid();\n\tinode->i_ino     = block;\n\tset_nlink(inode, 1);\n\tinode->i_mtime   = inode->i_atime = inode_set_ctime_current(inode);\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_protect = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nerr_bh:\n\taffs_free_block(sb, block);\nerr_block:\n\tiput(inode);\nerr_inode:\n\treturn NULL;\n}\n\n \n\nint\naffs_add_entry(struct inode *dir, struct inode *inode, struct dentry *dentry, s32 type)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *inode_bh = NULL;\n\tstruct buffer_head *bh;\n\tu32 block = 0;\n\tint retval;\n\n\tpr_debug(\"%s(dir=%lu, inode=%lu, \\\"%pd\\\", type=%d)\\n\", __func__,\n\t\t dir->i_ino, inode->i_ino, dentry, type);\n\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\tswitch (type) {\n\tcase ST_LINKFILE:\n\tcase ST_LINKDIR:\n\t\tretval = -ENOSPC;\n\t\tblock = affs_alloc_block(dir, dir->i_ino);\n\t\tif (!block)\n\t\t\tgoto err;\n\t\tretval = -EIO;\n\t\tinode_bh = bh;\n\t\tbh = affs_getzeroblk(sb, block);\n\t\tif (!bh)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tAFFS_HEAD(bh)->ptype = cpu_to_be32(T_SHORT);\n\tAFFS_HEAD(bh)->key = cpu_to_be32(bh->b_blocknr);\n\taffs_copy_name(AFFS_TAIL(sb, bh)->name, dentry);\n\tAFFS_TAIL(sb, bh)->stype = cpu_to_be32(type);\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\n\tif (inode_bh) {\n\t\t__be32 chain;\n\t       \tchain = AFFS_TAIL(sb, inode_bh)->link_chain;\n\t\tAFFS_TAIL(sb, bh)->original = cpu_to_be32(inode->i_ino);\n\t\tAFFS_TAIL(sb, bh)->link_chain = chain;\n\t\tAFFS_TAIL(sb, inode_bh)->link_chain = cpu_to_be32(block);\n\t\taffs_adjust_checksum(inode_bh, block - be32_to_cpu(chain));\n\t\tmark_buffer_dirty_inode(inode_bh, inode);\n\t\tset_nlink(inode, 2);\n\t\tihold(inode);\n\t}\n\taffs_fix_checksum(sb, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\tdentry->d_fsdata = (void *)(long)bh->b_blocknr;\n\n\taffs_lock_dir(dir);\n\tretval = affs_insert_hash(dir, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\n\td_instantiate(dentry, inode);\ndone:\n\taffs_brelse(inode_bh);\n\taffs_brelse(bh);\n\treturn retval;\nerr:\n\tif (block)\n\t\taffs_free_block(sb, block);\n\taffs_unlock_link(inode);\n\tgoto done;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}