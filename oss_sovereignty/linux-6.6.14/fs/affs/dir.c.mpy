{
  "module_name": "dir.c",
  "hash_id": "e6a9dbb690fd05d76261f24ca410bfacec01552863aea91a437e8b348ed9603d",
  "original_prompt": "Ingested from linux-6.6.14/fs/affs/dir.c",
  "human_readable_source": "\n \n\n#include <linux/iversion.h>\n#include \"affs.h\"\n\nstatic int affs_readdir(struct file *, struct dir_context *);\n\nconst struct file_operations affs_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.llseek\t\t= generic_file_llseek,\n\t.iterate_shared\t= affs_readdir,\n\t.fsync\t\t= affs_file_fsync,\n};\n\n \nconst struct inode_operations affs_dir_inode_operations = {\n\t.create\t\t= affs_create,\n\t.lookup\t\t= affs_lookup,\n\t.link\t\t= affs_link,\n\t.unlink\t\t= affs_unlink,\n\t.symlink\t= affs_symlink,\n\t.mkdir\t\t= affs_mkdir,\n\t.rmdir\t\t= affs_rmdir,\n\t.rename\t\t= affs_rename2,\n\t.setattr\t= affs_notify_change,\n};\n\nstatic int\naffs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode\t\t*inode = file_inode(file);\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*dir_bh = NULL;\n\tstruct buffer_head\t*fh_bh = NULL;\n\tunsigned char\t\t*name;\n\tint\t\t\t namelen;\n\tu32\t\t\t i;\n\tint\t\t\t hash_pos;\n\tint\t\t\t chain_pos;\n\tu32\t\t\t ino;\n\tint\t\t\t error = 0;\n\n\tpr_debug(\"%s(ino=%lu,f_pos=%llx)\\n\", __func__, inode->i_ino, ctx->pos);\n\n\tif (ctx->pos < 2) {\n\t\tfile->private_data = (void *)0;\n\t\tif (!dir_emit_dots(file, ctx))\n\t\t\treturn 0;\n\t}\n\n\taffs_lock_dir(inode);\n\tchain_pos = (ctx->pos - 2) & 0xffff;\n\thash_pos  = (ctx->pos - 2) >> 16;\n\tif (chain_pos == 0xffff) {\n\t\taffs_warning(sb, \"readdir\", \"More than 65535 entries in chain\");\n\t\tchain_pos = 0;\n\t\thash_pos++;\n\t\tctx->pos = ((hash_pos << 16) | chain_pos) + 2;\n\t}\n\tdir_bh = affs_bread(sb, inode->i_ino);\n\tif (!dir_bh)\n\t\tgoto out_unlock_dir;\n\n\t \n\tino = (u32)(long)file->private_data;\n\tif (ino && inode_eq_iversion(inode, file->f_version)) {\n\t\tpr_debug(\"readdir() left off=%d\\n\", ino);\n\t\tgoto inside;\n\t}\n\n\tino = be32_to_cpu(AFFS_HEAD(dir_bh)->table[hash_pos]);\n\tfor (i = 0; ino && i < chain_pos; i++) {\n\t\tfh_bh = affs_bread(sb, ino);\n\t\tif (!fh_bh) {\n\t\t\taffs_error(sb, \"readdir\",\"Cannot read block %d\", i);\n\t\t\terror = -EIO;\n\t\t\tgoto out_brelse_dir;\n\t\t}\n\t\tino = be32_to_cpu(AFFS_TAIL(sb, fh_bh)->hash_chain);\n\t\taffs_brelse(fh_bh);\n\t\tfh_bh = NULL;\n\t}\n\tif (ino)\n\t\tgoto inside;\n\thash_pos++;\n\n\tfor (; hash_pos < AFFS_SB(sb)->s_hashsize; hash_pos++) {\n\t\tino = be32_to_cpu(AFFS_HEAD(dir_bh)->table[hash_pos]);\n\t\tif (!ino)\n\t\t\tcontinue;\n\t\tctx->pos = (hash_pos << 16) + 2;\ninside:\n\t\tdo {\n\t\t\tfh_bh = affs_bread(sb, ino);\n\t\t\tif (!fh_bh) {\n\t\t\t\taffs_error(sb, \"readdir\",\n\t\t\t\t\t   \"Cannot read block %d\", ino);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnamelen = min(AFFS_TAIL(sb, fh_bh)->name[0],\n\t\t\t\t      (u8)AFFSNAMEMAX);\n\t\t\tname = AFFS_TAIL(sb, fh_bh)->name + 1;\n\t\t\tpr_debug(\"readdir(): dir_emit(\\\"%.*s\\\", ino=%u), hash=%d, f_pos=%llx\\n\",\n\t\t\t\t namelen, name, ino, hash_pos, ctx->pos);\n\n\t\t\tif (!dir_emit(ctx, name, namelen, ino, DT_UNKNOWN))\n\t\t\t\tgoto done;\n\t\t\tctx->pos++;\n\t\t\tino = be32_to_cpu(AFFS_TAIL(sb, fh_bh)->hash_chain);\n\t\t\taffs_brelse(fh_bh);\n\t\t\tfh_bh = NULL;\n\t\t} while (ino);\n\t}\ndone:\n\tfile->f_version = inode_query_iversion(inode);\n\tfile->private_data = (void *)(long)ino;\n\taffs_brelse(fh_bh);\n\nout_brelse_dir:\n\taffs_brelse(dir_bh);\n\nout_unlock_dir:\n\taffs_unlock_dir(inode);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}