{
  "module_name": "super.c",
  "hash_id": "7411d8eff9993723309b0afdf250b329ec541d6c68a8d1c468f8c91138d36b26",
  "original_prompt": "Ingested from linux-6.6.14/fs/affs/super.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <linux/iversion.h>\n#include \"affs.h\"\n\nstatic int affs_statfs(struct dentry *dentry, struct kstatfs *buf);\nstatic int affs_show_options(struct seq_file *m, struct dentry *root);\nstatic int affs_remount (struct super_block *sb, int *flags, char *data);\n\nstatic void\naffs_commit_super(struct super_block *sb, int wait)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct buffer_head *bh = sbi->s_root_bh;\n\tstruct affs_root_tail *tail = AFFS_ROOT_TAIL(sb, bh);\n\n\tlock_buffer(bh);\n\taffs_secs_to_datestamp(ktime_get_real_seconds(), &tail->disk_change);\n\taffs_fix_checksum(sb, bh);\n\tunlock_buffer(bh);\n\n\tmark_buffer_dirty(bh);\n\tif (wait)\n\t\tsync_dirty_buffer(bh);\n}\n\nstatic void\naffs_put_super(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tpr_debug(\"%s()\\n\", __func__);\n\n\tcancel_delayed_work_sync(&sbi->sb_work);\n}\n\nstatic int\naffs_sync_fs(struct super_block *sb, int wait)\n{\n\taffs_commit_super(sb, wait);\n\treturn 0;\n}\n\nstatic void flush_superblock(struct work_struct *work)\n{\n\tstruct affs_sb_info *sbi;\n\tstruct super_block *sb;\n\n\tsbi = container_of(work, struct affs_sb_info, sb_work.work);\n\tsb = sbi->sb;\n\n\tspin_lock(&sbi->work_lock);\n\tsbi->work_queued = 0;\n\tspin_unlock(&sbi->work_lock);\n\n\taffs_commit_super(sb, 1);\n}\n\nvoid affs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb_rdonly(sb))\n\t       return;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t       delay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t       queue_delayed_work(system_long_wq, &sbi->sb_work, delay);\n\t       sbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}\n\nstatic struct kmem_cache * affs_inode_cachep;\n\nstatic struct inode *affs_alloc_inode(struct super_block *sb)\n{\n\tstruct affs_inode_info *i;\n\n\ti = alloc_inode_sb(sb, affs_inode_cachep, GFP_KERNEL);\n\tif (!i)\n\t\treturn NULL;\n\n\tinode_set_iversion(&i->vfs_inode, 1);\n\ti->i_lc = NULL;\n\ti->i_ext_bh = NULL;\n\ti->i_pa_cnt = 0;\n\n\treturn &i->vfs_inode;\n}\n\nstatic void affs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(affs_inode_cachep, AFFS_I(inode));\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct affs_inode_info *ei = (struct affs_inode_info *) foo;\n\n\tmutex_init(&ei->i_link_lock);\n\tmutex_init(&ei->i_ext_lock);\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int __init init_inodecache(void)\n{\n\taffs_inode_cachep = kmem_cache_create(\"affs_inode_cache\",\n\t\t\t\t\t     sizeof(struct affs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t     init_once);\n\tif (affs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(affs_inode_cachep);\n}\n\nstatic const struct super_operations affs_sops = {\n\t.alloc_inode\t= affs_alloc_inode,\n\t.free_inode\t= affs_free_inode,\n\t.write_inode\t= affs_write_inode,\n\t.evict_inode\t= affs_evict_inode,\n\t.put_super\t= affs_put_super,\n\t.sync_fs\t= affs_sync_fs,\n\t.statfs\t\t= affs_statfs,\n\t.remount_fs\t= affs_remount,\n\t.show_options\t= affs_show_options,\n};\n\nenum {\n\tOpt_bs, Opt_mode, Opt_mufs, Opt_notruncate, Opt_prefix, Opt_protect,\n\tOpt_reserved, Opt_root, Opt_setgid, Opt_setuid,\n\tOpt_verbose, Opt_volume, Opt_ignore, Opt_err,\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_bs, \"bs=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_mufs, \"mufs\"},\n\t{Opt_notruncate, \"nofilenametruncate\"},\n\t{Opt_prefix, \"prefix=%s\"},\n\t{Opt_protect, \"protect\"},\n\t{Opt_reserved, \"reserved=%u\"},\n\t{Opt_root, \"root=%u\"},\n\t{Opt_setgid, \"setgid=%u\"},\n\t{Opt_setuid, \"setuid=%u\"},\n\t{Opt_verbose, \"verbose\"},\n\t{Opt_volume, \"volume=%s\"},\n\t{Opt_ignore, \"grpquota\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_ignore, \"quota\"},\n\t{Opt_ignore, \"usrquota\"},\n\t{Opt_err, NULL},\n};\n\nstatic int\nparse_options(char *options, kuid_t *uid, kgid_t *gid, int *mode, int *reserved, s32 *root,\n\t\tint *blocksize, char **prefix, char *volume, unsigned long *mount_opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\t \n\n\t*uid        = current_uid();\n\t*gid        = current_gid();\n\t*reserved   = 2;\n\t*root       = -1;\n\t*blocksize  = -1;\n\tvolume[0]   = ':';\n\tvolume[1]   = 0;\n\t*mount_opts = 0;\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, n, option;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bs:\n\t\t\tif (match_int(&args[0], &n))\n\t\t\t\treturn 0;\n\t\t\tif (n != 512 && n != 1024 && n != 2048\n\t\t\t    && n != 4096) {\n\t\t\t\tpr_warn(\"Invalid blocksize (512, 1024, 2048, 4096 allowed)\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*blocksize = n;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*mode = option & 0777;\n\t\t\taffs_set_opt(*mount_opts, SF_SETMODE);\n\t\t\tbreak;\n\t\tcase Opt_mufs:\n\t\t\taffs_set_opt(*mount_opts, SF_MUFS);\n\t\t\tbreak;\n\t\tcase Opt_notruncate:\n\t\t\taffs_set_opt(*mount_opts, SF_NO_TRUNCATE);\n\t\t\tbreak;\n\t\tcase Opt_prefix:\n\t\t\tkfree(*prefix);\n\t\t\t*prefix = match_strdup(&args[0]);\n\t\t\tif (!*prefix)\n\t\t\t\treturn 0;\n\t\t\taffs_set_opt(*mount_opts, SF_PREFIX);\n\t\t\tbreak;\n\t\tcase Opt_protect:\n\t\t\taffs_set_opt(*mount_opts, SF_IMMUTABLE);\n\t\t\tbreak;\n\t\tcase Opt_reserved:\n\t\t\tif (match_int(&args[0], reserved))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_root:\n\t\t\tif (match_int(&args[0], root))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_setgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(*gid))\n\t\t\t\treturn 0;\n\t\t\taffs_set_opt(*mount_opts, SF_SETGID);\n\t\t\tbreak;\n\t\tcase Opt_setuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(*uid))\n\t\t\t\treturn 0;\n\t\t\taffs_set_opt(*mount_opts, SF_SETUID);\n\t\t\tbreak;\n\t\tcase Opt_verbose:\n\t\t\taffs_set_opt(*mount_opts, SF_VERBOSE);\n\t\t\tbreak;\n\t\tcase Opt_volume: {\n\t\t\tchar *vol = match_strdup(&args[0]);\n\t\t\tif (!vol)\n\t\t\t\treturn 0;\n\t\t\tstrscpy(volume, vol, 32);\n\t\t\tkfree(vol);\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_ignore:\n\t\t \t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Unrecognized mount option \\\"%s\\\" or missing value\\n\",\n\t\t\t\tp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int affs_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\n\tif (sb->s_blocksize)\n\t\tseq_printf(m, \",bs=%lu\", sb->s_blocksize);\n\tif (affs_test_opt(sbi->s_flags, SF_SETMODE))\n\t\tseq_printf(m, \",mode=%o\", sbi->s_mode);\n\tif (affs_test_opt(sbi->s_flags, SF_MUFS))\n\t\tseq_puts(m, \",mufs\");\n\tif (affs_test_opt(sbi->s_flags, SF_NO_TRUNCATE))\n\t\tseq_puts(m, \",nofilenametruncate\");\n\tif (affs_test_opt(sbi->s_flags, SF_PREFIX))\n\t\tseq_printf(m, \",prefix=%s\", sbi->s_prefix);\n\tif (affs_test_opt(sbi->s_flags, SF_IMMUTABLE))\n\t\tseq_puts(m, \",protect\");\n\tif (sbi->s_reserved != 2)\n\t\tseq_printf(m, \",reserved=%u\", sbi->s_reserved);\n\tif (sbi->s_root_block != (sbi->s_reserved + sbi->s_partition_size - 1) / 2)\n\t\tseq_printf(m, \",root=%u\", sbi->s_root_block);\n\tif (affs_test_opt(sbi->s_flags, SF_SETGID))\n\t\tseq_printf(m, \",setgid=%u\",\n\t\t\t   from_kgid_munged(&init_user_ns, sbi->s_gid));\n\tif (affs_test_opt(sbi->s_flags, SF_SETUID))\n\t\tseq_printf(m, \",setuid=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns, sbi->s_uid));\n\tif (affs_test_opt(sbi->s_flags, SF_VERBOSE))\n\t\tseq_puts(m, \",verbose\");\n\tif (sbi->s_volume[0])\n\t\tseq_printf(m, \",volume=%s\", sbi->s_volume);\n\treturn 0;\n}\n\n \n\nstatic int affs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct affs_sb_info\t*sbi;\n\tstruct buffer_head\t*root_bh = NULL;\n\tstruct buffer_head\t*boot_bh;\n\tstruct inode\t\t*root_inode = NULL;\n\ts32\t\t\t root_block;\n\tint\t\t\t size, blocksize;\n\tu32\t\t\t chksum;\n\tint\t\t\t num_bm;\n\tint\t\t\t i, j;\n\tkuid_t\t\t\t uid;\n\tkgid_t\t\t\t gid;\n\tint\t\t\t reserved;\n\tunsigned long\t\t mount_flags;\n\tint\t\t\t tmp_flags;\t \n\tu8\t\t\t sig[4];\n\tint\t\t\t ret;\n\n\tpr_debug(\"read_super(%s)\\n\", data ? (const char *)data : \"no options\");\n\n\tsb->s_magic             = AFFS_SUPER_MAGIC;\n\tsb->s_op                = &affs_sops;\n\tsb->s_flags |= SB_NODIRATIME;\n\n\tsb->s_time_gran = NSEC_PER_SEC;\n\tsb->s_time_min = sys_tz.tz_minuteswest * 60 + AFFS_EPOCH_DELTA;\n\tsb->s_time_max = 86400LL * U32_MAX + 86400 + sb->s_time_min;\n\n\tsbi = kzalloc(sizeof(struct affs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = sbi;\n\tsbi->sb = sb;\n\tmutex_init(&sbi->s_bmlock);\n\tspin_lock_init(&sbi->symlink_lock);\n\tspin_lock_init(&sbi->work_lock);\n\tINIT_DELAYED_WORK(&sbi->sb_work, flush_superblock);\n\n\tif (!parse_options(data,&uid,&gid,&i,&reserved,&root_block,\n\t\t\t\t&blocksize,&sbi->s_prefix,\n\t\t\t\tsbi->s_volume, &mount_flags)) {\n\t\tpr_err(\"Error parsing options\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\n\tsbi->s_flags   = mount_flags;\n\tsbi->s_mode    = i;\n\tsbi->s_uid     = uid;\n\tsbi->s_gid     = gid;\n\tsbi->s_reserved= reserved;\n\n\t \n\n\tsize = bdev_nr_sectors(sb->s_bdev);\n\tpr_debug(\"initial blocksize=%d, #blocks=%d\\n\", 512, size);\n\n\taffs_set_blocksize(sb, PAGE_SIZE);\n\t \n\n\ti = bdev_logical_block_size(sb->s_bdev);\n\tj = PAGE_SIZE;\n\tif (blocksize > 0) {\n\t\ti = j = blocksize;\n\t\tsize = size / (blocksize / 512);\n\t}\n\n\tfor (blocksize = i; blocksize <= j; blocksize <<= 1, size >>= 1) {\n\t\tsbi->s_root_block = root_block;\n\t\tif (root_block < 0)\n\t\t\tsbi->s_root_block = (reserved + size - 1) / 2;\n\t\tpr_debug(\"setting blocksize to %d\\n\", blocksize);\n\t\taffs_set_blocksize(sb, blocksize);\n\t\tsbi->s_partition_size = size;\n\n\t\t \n\t\tfor (num_bm = 0; num_bm < 2; num_bm++) {\n\t\t\tpr_debug(\"Dev %s, trying root=%u, bs=%d, \"\n\t\t\t\t\"size=%d, reserved=%d\\n\",\n\t\t\t\tsb->s_id,\n\t\t\t\tsbi->s_root_block + num_bm,\n\t\t\t\tblocksize, size, reserved);\n\t\t\troot_bh = affs_bread(sb, sbi->s_root_block + num_bm);\n\t\t\tif (!root_bh)\n\t\t\t\tcontinue;\n\t\t\tif (!affs_checksum_block(sb, root_bh) &&\n\t\t\t    be32_to_cpu(AFFS_ROOT_HEAD(root_bh)->ptype) == T_SHORT &&\n\t\t\t    be32_to_cpu(AFFS_ROOT_TAIL(sb, root_bh)->stype) == ST_ROOT) {\n\t\t\t\tsbi->s_hashsize    = blocksize / 4 - 56;\n\t\t\t\tsbi->s_root_block += num_bm;\n\t\t\t\tgoto got_root;\n\t\t\t}\n\t\t\taffs_brelse(root_bh);\n\t\t\troot_bh = NULL;\n\t\t}\n\t}\n\tif (!silent)\n\t\tpr_err(\"No valid root block on device %s\\n\", sb->s_id);\n\treturn -EINVAL;\n\n\t \ngot_root:\n\t \n\tsbi->s_root_bh = root_bh;\n\troot_block = sbi->s_root_block;\n\n\t \n\tboot_bh = sb_bread(sb, 0);\n\tif (!boot_bh) {\n\t\tpr_err(\"Cannot read boot block\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(sig, boot_bh->b_data, 4);\n\tbrelse(boot_bh);\n\tchksum = be32_to_cpu(*(__be32 *)sig);\n\n\t \n\tif ((chksum == FS_DCFFS || chksum == MUFS_DCFFS || chksum == FS_DCOFS\n\t     || chksum == MUFS_DCOFS) && !sb_rdonly(sb)) {\n\t\tpr_notice(\"Dircache FS - mounting %s read only\\n\", sb->s_id);\n\t\tsb->s_flags |= SB_RDONLY;\n\t}\n\tswitch (chksum) {\n\tcase MUFS_FS:\n\tcase MUFS_INTLFFS:\n\tcase MUFS_DCFFS:\n\t\taffs_set_opt(sbi->s_flags, SF_MUFS);\n\t\tfallthrough;\n\tcase FS_INTLFFS:\n\tcase FS_DCFFS:\n\t\taffs_set_opt(sbi->s_flags, SF_INTL);\n\t\tbreak;\n\tcase MUFS_FFS:\n\t\taffs_set_opt(sbi->s_flags, SF_MUFS);\n\t\tbreak;\n\tcase FS_FFS:\n\t\tbreak;\n\tcase MUFS_OFS:\n\t\taffs_set_opt(sbi->s_flags, SF_MUFS);\n\t\tfallthrough;\n\tcase FS_OFS:\n\t\taffs_set_opt(sbi->s_flags, SF_OFS);\n\t\tsb->s_flags |= SB_NOEXEC;\n\t\tbreak;\n\tcase MUFS_DCOFS:\n\tcase MUFS_INTLOFS:\n\t\taffs_set_opt(sbi->s_flags, SF_MUFS);\n\t\tfallthrough;\n\tcase FS_DCOFS:\n\tcase FS_INTLOFS:\n\t\taffs_set_opt(sbi->s_flags, SF_INTL);\n\t\taffs_set_opt(sbi->s_flags, SF_OFS);\n\t\tsb->s_flags |= SB_NOEXEC;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown filesystem on device %s: %08X\\n\",\n\t\t       sb->s_id, chksum);\n\t\treturn -EINVAL;\n\t}\n\n\tif (affs_test_opt(mount_flags, SF_VERBOSE)) {\n\t\tu8 len = AFFS_ROOT_TAIL(sb, root_bh)->disk_name[0];\n\t\tpr_notice(\"Mounting volume \\\"%.*s\\\": Type=%.3s\\\\%c, Blocksize=%d\\n\",\n\t\t\tlen > 31 ? 31 : len,\n\t\t\tAFFS_ROOT_TAIL(sb, root_bh)->disk_name + 1,\n\t\t\tsig, sig[3] + '0', blocksize);\n\t}\n\n\tsb->s_flags |= SB_NODEV | SB_NOSUID;\n\n\tsbi->s_data_blksize = sb->s_blocksize;\n\tif (affs_test_opt(sbi->s_flags, SF_OFS))\n\t\tsbi->s_data_blksize -= 24;\n\n\ttmp_flags = sb->s_flags;\n\tret = affs_init_bitmap(sb, &tmp_flags);\n\tif (ret)\n\t\treturn ret;\n\tsb->s_flags = tmp_flags;\n\n\t \n\n\troot_inode = affs_iget(sb, root_block);\n\tif (IS_ERR(root_inode))\n\t\treturn PTR_ERR(root_inode);\n\n\tif (affs_test_opt(AFFS_SB(sb)->s_flags, SF_INTL))\n\t\tsb->s_d_op = &affs_intl_dentry_operations;\n\telse\n\t\tsb->s_d_op = &affs_dentry_operations;\n\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\tpr_err(\"AFFS: Get root inode failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsb->s_export_op = &affs_export_ops;\n\tpr_debug(\"s_flags=%lX\\n\", sb->s_flags);\n\treturn 0;\n}\n\nstatic int\naffs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct affs_sb_info\t*sbi = AFFS_SB(sb);\n\tint\t\t\t blocksize;\n\tkuid_t\t\t\t uid;\n\tkgid_t\t\t\t gid;\n\tint\t\t\t mode;\n\tint\t\t\t reserved;\n\tint\t\t\t root_block;\n\tunsigned long\t\t mount_flags;\n\tint\t\t\t res = 0;\n\tchar\t\t\t volume[32];\n\tchar\t\t\t*prefix = NULL;\n\n\tpr_debug(\"%s(flags=0x%x,opts=\\\"%s\\\")\\n\", __func__, *flags, data);\n\n\tsync_filesystem(sb);\n\t*flags |= SB_NODIRATIME;\n\n\tmemcpy(volume, sbi->s_volume, 32);\n\tif (!parse_options(data, &uid, &gid, &mode, &reserved, &root_block,\n\t\t\t   &blocksize, &prefix, volume,\n\t\t\t   &mount_flags)) {\n\t\tkfree(prefix);\n\t\treturn -EINVAL;\n\t}\n\n\tflush_delayed_work(&sbi->sb_work);\n\n\tsbi->s_flags = mount_flags;\n\tsbi->s_mode  = mode;\n\tsbi->s_uid   = uid;\n\tsbi->s_gid   = gid;\n\t \n\tspin_lock(&sbi->symlink_lock);\n\tif (prefix) {\n\t\tkfree(sbi->s_prefix);\n\t\tsbi->s_prefix = prefix;\n\t}\n\tmemcpy(sbi->s_volume, volume, 32);\n\tspin_unlock(&sbi->symlink_lock);\n\n\tif ((bool)(*flags & SB_RDONLY) == sb_rdonly(sb))\n\t\treturn 0;\n\n\tif (*flags & SB_RDONLY)\n\t\taffs_free_bitmap(sb);\n\telse\n\t\tres = affs_init_bitmap(sb, flags);\n\n\treturn res;\n}\n\nstatic int\naffs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tint\t\t free;\n\tu64\t\t id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tpr_debug(\"%s() partsize=%d, reserved=%d\\n\",\n\t\t __func__, AFFS_SB(sb)->s_partition_size,\n\t\t AFFS_SB(sb)->s_reserved);\n\n\tfree          = affs_count_free_blocks(sb);\n\tbuf->f_type    = AFFS_SUPER_MAGIC;\n\tbuf->f_bsize   = sb->s_blocksize;\n\tbuf->f_blocks  = AFFS_SB(sb)->s_partition_size - AFFS_SB(sb)->s_reserved;\n\tbuf->f_bfree   = free;\n\tbuf->f_bavail  = free;\n\tbuf->f_fsid    = u64_to_fsid(id);\n\tbuf->f_namelen = AFFSNAMEMAX;\n\treturn 0;\n}\n\nstatic struct dentry *affs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, affs_fill_super);\n}\n\nstatic void affs_kill_sb(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tkill_block_super(sb);\n\tif (sbi) {\n\t\taffs_free_bitmap(sb);\n\t\taffs_brelse(sbi->s_root_bh);\n\t\tkfree(sbi->s_prefix);\n\t\tmutex_destroy(&sbi->s_bmlock);\n\t\tkfree(sbi);\n\t}\n}\n\nstatic struct file_system_type affs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"affs\",\n\t.mount\t\t= affs_mount,\n\t.kill_sb\t= affs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"affs\");\n\nstatic int __init init_affs_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&affs_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}\n\nstatic void __exit exit_affs_fs(void)\n{\n\tunregister_filesystem(&affs_fs_type);\n\tdestroy_inodecache();\n}\n\nMODULE_DESCRIPTION(\"Amiga filesystem support for Linux\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(init_affs_fs)\nmodule_exit(exit_affs_fs)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}