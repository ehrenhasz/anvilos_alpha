{
  "module_name": "bitmap.c",
  "hash_id": "71b4965ac73f938f4993949990c4b7b81c079fb2826daba203e1e94dda22a488",
  "original_prompt": "Ingested from linux-6.6.14/fs/affs/bitmap.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include \"affs.h\"\n\nu32\naffs_count_free_blocks(struct super_block *sb)\n{\n\tstruct affs_bm_info *bm;\n\tu32 free;\n\tint i;\n\n\tpr_debug(\"%s()\\n\", __func__);\n\n\tif (sb_rdonly(sb))\n\t\treturn 0;\n\n\tmutex_lock(&AFFS_SB(sb)->s_bmlock);\n\n\tbm = AFFS_SB(sb)->s_bitmap;\n\tfree = 0;\n\tfor (i = AFFS_SB(sb)->s_bmap_count; i > 0; bm++, i--)\n\t\tfree += bm->bm_free;\n\n\tmutex_unlock(&AFFS_SB(sb)->s_bmlock);\n\n\treturn free;\n}\n\nvoid\naffs_free_block(struct super_block *sb, u32 block)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\tu32 blk, bmap, bit, mask, tmp;\n\t__be32 *data;\n\n\tpr_debug(\"%s(%u)\\n\", __func__, block);\n\n\tif (block > sbi->s_partition_size)\n\t\tgoto err_range;\n\n\tblk     = block - sbi->s_reserved;\n\tbmap    = blk / sbi->s_bmap_bits;\n\tbit     = blk % sbi->s_bmap_bits;\n\tbm      = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\tmask = 1 << (bit & 31);\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\n\t \n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto err_free;\n\t*data = cpu_to_be32(tmp | mask);\n\n\t \n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp - mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\tbm->bm_free++;\n\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_free:\n\taffs_warning(sb,\"affs_free_block\",\"Trying to free block %u which is already free\", block);\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_free_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_range:\n\taffs_error(sb, \"affs_free_block\",\"Block %u outside partition\", block);\n}\n\n \n\nu32\naffs_alloc_block(struct inode *inode, u32 goal)\n{\n\tstruct super_block *sb;\n\tstruct affs_sb_info *sbi;\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\t__be32 *data, *enddata;\n\tu32 blk, bmap, bit, mask, mask2, tmp;\n\tint i;\n\n\tsb = inode->i_sb;\n\tsbi = AFFS_SB(sb);\n\n\tpr_debug(\"balloc(inode=%lu,goal=%u): \", inode->i_ino, goal);\n\n\tif (AFFS_I(inode)->i_pa_cnt) {\n\t\tpr_debug(\"%d\\n\", AFFS_I(inode)->i_lastalloc+1);\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\treturn ++AFFS_I(inode)->i_lastalloc;\n\t}\n\n\tif (!goal || goal > sbi->s_partition_size) {\n\t\tif (goal)\n\t\t\taffs_warning(sb, \"affs_balloc\", \"invalid goal %d\", goal);\n\t\t\n\t\t\n\t\tgoal = sbi->s_reserved;\n\t}\n\n\tblk = goal - sbi->s_reserved;\n\tbmap = blk / sbi->s_bmap_bits;\n\tbm = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tif (bm->bm_free)\n\t\tgoto find_bmap_bit;\n\nfind_bmap:\n\t \n\ti = sbi->s_bmap_count;\n\tdo {\n\t\tif (--i < 0)\n\t\t\tgoto err_full;\n\t\tbmap++;\n\t\tbm++;\n\t\tif (bmap < sbi->s_bmap_count)\n\t\t\tcontinue;\n\t\t \n\t\tbmap = 0;\n\t\tbm = sbi->s_bitmap;\n\t} while (!bm->bm_free);\n\tblk = bmap * sbi->s_bmap_bits;\n\nfind_bmap_bit:\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\t \n\tbit = blk % sbi->s_bmap_bits;\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\tenddata = (__be32 *)((u8 *)bh->b_data + sb->s_blocksize);\n\tmask = ~0UL << (bit & 31);\n\tblk &= ~31UL;\n\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto find_bit;\n\n\t \n\tdo {\n\t\tblk += 32;\n\t\tif (++data >= enddata)\n\t\t\t \n\t\t\tgoto find_bmap;\n\t} while (!*data);\n\ttmp = be32_to_cpu(*data);\n\tmask = ~0;\n\nfind_bit:\n\t \n\tbit = ffs(tmp & mask) - 1;\n\tblk += bit + sbi->s_reserved;\n\tmask2 = mask = 1 << (bit & 31);\n\tAFFS_I(inode)->i_lastalloc = blk;\n\n\t \n\twhile ((mask2 <<= 1)) {\n\t\tif (!(tmp & mask2))\n\t\t\tbreak;\n\t\tAFFS_I(inode)->i_pa_cnt++;\n\t\tmask |= mask2;\n\t}\n\tbm->bm_free -= AFFS_I(inode)->i_pa_cnt + 1;\n\n\t*data = cpu_to_be32(tmp & ~mask);\n\n\t \n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp + mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\n\tmutex_unlock(&sbi->s_bmlock);\n\n\tpr_debug(\"%d\\n\", blk);\n\treturn blk;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_read_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\nerr_full:\n\tmutex_unlock(&sbi->s_bmlock);\n\tpr_debug(\"failed\\n\");\n\treturn 0;\n}\n\nint affs_init_bitmap(struct super_block *sb, int *flags)\n{\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bmap_bh = NULL, *bh = NULL;\n\t__be32 *bmap_blk;\n\tu32 size, blk, end, offset, mask;\n\tint i, res = 0;\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\n\tif (*flags & SB_RDONLY)\n\t\treturn 0;\n\n\tif (!AFFS_ROOT_TAIL(sb, sbi->s_root_bh)->bm_flag) {\n\t\tpr_notice(\"Bitmap invalid - mounting %s read only\\n\", sb->s_id);\n\t\t*flags |= SB_RDONLY;\n\t\treturn 0;\n\t}\n\n\tsbi->s_last_bmap = ~0;\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_bmap_bits = sb->s_blocksize * 8 - 32;\n\tsbi->s_bmap_count = (sbi->s_partition_size - sbi->s_reserved +\n\t\t\t\t sbi->s_bmap_bits - 1) / sbi->s_bmap_bits;\n\tsize = sbi->s_bmap_count * sizeof(*bm);\n\tbm = sbi->s_bitmap = kzalloc(size, GFP_KERNEL);\n\tif (!sbi->s_bitmap) {\n\t\tpr_err(\"Bitmap allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbmap_blk = (__be32 *)sbi->s_root_bh->b_data;\n\tblk = sb->s_blocksize / 4 - 49;\n\tend = blk + 25;\n\n\tfor (i = sbi->s_bmap_count; i > 0; bm++, i--) {\n\t\taffs_brelse(bh);\n\n\t\tbm->bm_key = be32_to_cpu(bmap_blk[blk]);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh) {\n\t\t\tpr_err(\"Cannot read bitmap\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (affs_checksum_block(sb, bh)) {\n\t\t\tpr_warn(\"Bitmap %u invalid - mounting %s read only.\\n\",\n\t\t\t\tbm->bm_key, sb->s_id);\n\t\t\t*flags |= SB_RDONLY;\n\t\t\tgoto out;\n\t\t}\n\t\tpr_debug(\"read bitmap block %d: %d\\n\", blk, bm->bm_key);\n\t\tbm->bm_free = memweight(bh->b_data + 4, sb->s_blocksize - 4);\n\n\t\t \n\t\tif (++blk < end || i == 1)\n\t\t\tcontinue;\n\t\tif (bmap_bh)\n\t\t\taffs_brelse(bmap_bh);\n\t\tbmap_bh = affs_bread(sb, be32_to_cpu(bmap_blk[blk]));\n\t\tif (!bmap_bh) {\n\t\t\tpr_err(\"Cannot read bitmap extension\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbmap_blk = (__be32 *)bmap_bh->b_data;\n\t\tblk = 0;\n\t\tend = sb->s_blocksize / 4 - 1;\n\t}\n\n\toffset = (sbi->s_partition_size - sbi->s_reserved) % sbi->s_bmap_bits;\n\tmask = ~(0xFFFFFFFFU << (offset & 31));\n\tpr_debug(\"last word: %d %d %d\\n\", offset, offset / 32 + 1, mask);\n\toffset = offset / 32 + 1;\n\n\tif (mask) {\n\t\tu32 old, new;\n\n\t\t \n\t\told = be32_to_cpu(((__be32 *)bh->b_data)[offset]);\n\t\tnew = old & mask;\n\t\t\n\t\t\t((__be32 *)bh->b_data)[offset] = cpu_to_be32(new);\n\t\t\t \n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t\t \n\t\t\n\t}\n\twhile (++offset < sb->s_blocksize / 4)\n\t\t((__be32 *)bh->b_data)[offset] = 0;\n\t((__be32 *)bh->b_data)[0] = 0;\n\t((__be32 *)bh->b_data)[0] = cpu_to_be32(-affs_checksum_block(sb, bh));\n\tmark_buffer_dirty(bh);\n\n\t \n\tbm--;\n\tbm->bm_free = memweight(bh->b_data + 4, sb->s_blocksize - 4);\n\nout:\n\taffs_brelse(bh);\n\taffs_brelse(bmap_bh);\n\treturn res;\n}\n\nvoid affs_free_bitmap(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\n\tif (!sbi->s_bitmap)\n\t\treturn;\n\n\taffs_brelse(sbi->s_bmap_bh);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tkfree(sbi->s_bitmap);\n\tsbi->s_bitmap = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}