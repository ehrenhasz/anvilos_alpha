{
  "module_name": "amigaffs.c",
  "hash_id": "8d8208242f65c462d56a64972af75a9cb8b2071f2658c7a44eb4a17985250b6e",
  "original_prompt": "Ingested from linux-6.6.14/fs/affs/amigaffs.c",
  "human_readable_source": "\n \n\n#include <linux/math64.h>\n#include <linux/iversion.h>\n#include \"affs.h\"\n\n \n\n\n \n\nint\naffs_insert_hash(struct inode *dir, struct buffer_head *bh)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *dir_bh;\n\tu32 ino, hash_ino;\n\tint offset;\n\n\tino = bh->b_blocknr;\n\toffset = affs_hash_name(sb, AFFS_TAIL(sb, bh)->name + 1, AFFS_TAIL(sb, bh)->name[0]);\n\n\tpr_debug(\"%s(dir=%lu, ino=%d)\\n\", __func__, dir->i_ino, ino);\n\n\tdir_bh = affs_bread(sb, dir->i_ino);\n\tif (!dir_bh)\n\t\treturn -EIO;\n\n\thash_ino = be32_to_cpu(AFFS_HEAD(dir_bh)->table[offset]);\n\twhile (hash_ino) {\n\t\taffs_brelse(dir_bh);\n\t\tdir_bh = affs_bread(sb, hash_ino);\n\t\tif (!dir_bh)\n\t\t\treturn -EIO;\n\t\thash_ino = be32_to_cpu(AFFS_TAIL(sb, dir_bh)->hash_chain);\n\t}\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\tAFFS_TAIL(sb, bh)->hash_chain = 0;\n\taffs_fix_checksum(sb, bh);\n\n\tif (dir->i_ino == dir_bh->b_blocknr)\n\t\tAFFS_HEAD(dir_bh)->table[offset] = cpu_to_be32(ino);\n\telse\n\t\tAFFS_TAIL(sb, dir_bh)->hash_chain = cpu_to_be32(ino);\n\n\taffs_adjust_checksum(dir_bh, ino);\n\tmark_buffer_dirty_inode(dir_bh, dir);\n\taffs_brelse(dir_bh);\n\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tinode_inc_iversion(dir);\n\tmark_inode_dirty(dir);\n\n\treturn 0;\n}\n\n \n\nint\naffs_remove_hash(struct inode *dir, struct buffer_head *rem_bh)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh;\n\tu32 rem_ino, hash_ino;\n\t__be32 ino;\n\tint offset, retval;\n\n\tsb = dir->i_sb;\n\trem_ino = rem_bh->b_blocknr;\n\toffset = affs_hash_name(sb, AFFS_TAIL(sb, rem_bh)->name+1, AFFS_TAIL(sb, rem_bh)->name[0]);\n\tpr_debug(\"%s(dir=%lu, ino=%d, hashval=%d)\\n\", __func__, dir->i_ino,\n\t\t rem_ino, offset);\n\n\tbh = affs_bread(sb, dir->i_ino);\n\tif (!bh)\n\t\treturn -EIO;\n\n\tretval = -ENOENT;\n\thash_ino = be32_to_cpu(AFFS_HEAD(bh)->table[offset]);\n\twhile (hash_ino) {\n\t\tif (hash_ino == rem_ino) {\n\t\t\tino = AFFS_TAIL(sb, rem_bh)->hash_chain;\n\t\t\tif (dir->i_ino == bh->b_blocknr)\n\t\t\t\tAFFS_HEAD(bh)->table[offset] = ino;\n\t\t\telse\n\t\t\t\tAFFS_TAIL(sb, bh)->hash_chain = ino;\n\t\t\taffs_adjust_checksum(bh, be32_to_cpu(ino) - hash_ino);\n\t\t\tmark_buffer_dirty_inode(bh, dir);\n\t\t\tAFFS_TAIL(sb, rem_bh)->parent = 0;\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, hash_ino);\n\t\tif (!bh)\n\t\t\treturn -EIO;\n\t\thash_ino = be32_to_cpu(AFFS_TAIL(sb, bh)->hash_chain);\n\t}\n\n\taffs_brelse(bh);\n\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tinode_inc_iversion(dir);\n\tmark_inode_dirty(dir);\n\n\treturn retval;\n}\n\nstatic void\naffs_fix_dcache(struct inode *inode, u32 entry_ino)\n{\n\tstruct dentry *dentry;\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tif (entry_ino == (u32)(long)dentry->d_fsdata) {\n\t\t\tdentry->d_fsdata = (void *)inode->i_ino;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n}\n\n\n \n\nstatic int\naffs_remove_link(struct dentry *dentry)\n{\n\tstruct inode *dir, *inode = d_inode(dentry);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh, *link_bh = NULL;\n\tu32 link_ino, ino;\n\tint retval;\n\n\tpr_debug(\"%s(key=%ld)\\n\", __func__, inode->i_ino);\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\tlink_ino = (u32)(long)dentry->d_fsdata;\n\tif (inode->i_ino == link_ino) {\n\t\t  \n\t\tlink_ino = be32_to_cpu(AFFS_TAIL(sb, bh)->link_chain);\n\t\tlink_bh = affs_bread(sb, link_ino);\n\t\tif (!link_bh)\n\t\t\tgoto done;\n\n\t\tdir = affs_iget(sb, be32_to_cpu(AFFS_TAIL(sb, link_bh)->parent));\n\t\tif (IS_ERR(dir)) {\n\t\t\tretval = PTR_ERR(dir);\n\t\t\tgoto done;\n\t\t}\n\n\t\taffs_lock_dir(dir);\n\t\t \n\t\taffs_fix_dcache(inode, link_ino);\n\t\tretval = affs_remove_hash(dir, link_bh);\n\t\tif (retval) {\n\t\t\taffs_unlock_dir(dir);\n\t\t\tgoto done;\n\t\t}\n\t\tmark_buffer_dirty_inode(link_bh, inode);\n\n\t\tmemcpy(AFFS_TAIL(sb, bh)->name, AFFS_TAIL(sb, link_bh)->name, 32);\n\t\tretval = affs_insert_hash(dir, bh);\n\t\tif (retval) {\n\t\t\taffs_unlock_dir(dir);\n\t\t\tgoto done;\n\t\t}\n\t\tmark_buffer_dirty_inode(bh, inode);\n\n\t\taffs_unlock_dir(dir);\n\t\tiput(dir);\n\t} else {\n\t\tlink_bh = affs_bread(sb, link_ino);\n\t\tif (!link_bh)\n\t\t\tgoto done;\n\t}\n\n\twhile ((ino = be32_to_cpu(AFFS_TAIL(sb, bh)->link_chain)) != 0) {\n\t\tif (ino == link_ino) {\n\t\t\t__be32 ino2 = AFFS_TAIL(sb, link_bh)->link_chain;\n\t\t\tAFFS_TAIL(sb, bh)->link_chain = ino2;\n\t\t\taffs_adjust_checksum(bh, be32_to_cpu(ino2) - link_ino);\n\t\t\tmark_buffer_dirty_inode(bh, inode);\n\t\t\tretval = 0;\n\t\t\t \n\t\t\tswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\n\t\t\tcase ST_LINKDIR:\n\t\t\tcase ST_LINKFILE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!AFFS_TAIL(sb, bh)->link_chain)\n\t\t\t\t\tset_nlink(inode, 1);\n\t\t\t}\n\t\t\taffs_free_block(sb, link_ino);\n\t\t\tgoto done;\n\t\t}\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, ino);\n\t\tif (!bh)\n\t\t\tgoto done;\n\t}\n\tretval = -ENOENT;\ndone:\n\taffs_brelse(link_bh);\n\taffs_brelse(bh);\n\treturn retval;\n}\n\n\nstatic int\naffs_empty_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tint retval, size;\n\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\tretval = -ENOTEMPTY;\n\tfor (size = AFFS_SB(sb)->s_hashsize - 1; size >= 0; size--)\n\t\tif (AFFS_HEAD(bh)->table[size])\n\t\t\tgoto not_empty;\n\tretval = 0;\nnot_empty:\n\taffs_brelse(bh);\ndone:\n\treturn retval;\n}\n\n\n \n\nint\naffs_remove_header(struct dentry *dentry)\n{\n\tstruct super_block *sb;\n\tstruct inode *inode, *dir;\n\tstruct buffer_head *bh = NULL;\n\tint retval;\n\n\tdir = d_inode(dentry->d_parent);\n\tsb = dir->i_sb;\n\n\tretval = -ENOENT;\n\tinode = d_inode(dentry);\n\tif (!inode)\n\t\tgoto done;\n\n\tpr_debug(\"%s(key=%ld)\\n\", __func__, inode->i_ino);\n\tretval = -EIO;\n\tbh = affs_bread(sb, (u32)(long)dentry->d_fsdata);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\taffs_lock_dir(dir);\n\tswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\n\tcase ST_USERDIR:\n\t\t \n\t\taffs_lock_dir(inode);\n\t\tretval = affs_empty_dir(inode);\n\t\taffs_unlock_dir(inode);\n\t\tif (retval)\n\t\t\tgoto done_unlock;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tretval = affs_remove_hash(dir, bh);\n\tif (retval)\n\t\tgoto done_unlock;\n\tmark_buffer_dirty_inode(bh, inode);\n\n\taffs_unlock_dir(dir);\n\n\tif (inode->i_nlink > 1)\n\t\tretval = affs_remove_link(dentry);\n\telse\n\t\tclear_nlink(inode);\n\taffs_unlock_link(inode);\n\tinode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n\ndone:\n\taffs_brelse(bh);\n\treturn retval;\n\ndone_unlock:\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\tgoto done;\n}\n\n \n\nu32\naffs_checksum_block(struct super_block *sb, struct buffer_head *bh)\n{\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 sum;\n\tint bsize;\n\n\tsum = 0;\n\tfor (bsize = sb->s_blocksize / sizeof(__be32); bsize > 0; bsize--)\n\t\tsum += be32_to_cpu(*ptr++);\n\treturn sum;\n}\n\n \n\nvoid\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}\n\nvoid\naffs_secs_to_datestamp(time64_t secs, struct affs_date *ds)\n{\n\tu32\t days;\n\tu32\t minute;\n\ts32\t rem;\n\n\tsecs -= sys_tz.tz_minuteswest * 60 + AFFS_EPOCH_DELTA;\n\tif (secs < 0)\n\t\tsecs = 0;\n\tdays    = div_s64_rem(secs, 86400, &rem);\n\tminute  = rem / 60;\n\trem    -= minute * 60;\n\n\tds->days = cpu_to_be32(days);\n\tds->mins = cpu_to_be32(minute);\n\tds->ticks = cpu_to_be32(rem * 50);\n}\n\numode_t\naffs_prot_to_mode(u32 prot)\n{\n\tumode_t mode = 0;\n\n\tif (!(prot & FIBF_NOWRITE))\n\t\tmode |= 0200;\n\tif (!(prot & FIBF_NOREAD))\n\t\tmode |= 0400;\n\tif (!(prot & FIBF_NOEXECUTE))\n\t\tmode |= 0100;\n\tif (prot & FIBF_GRP_WRITE)\n\t\tmode |= 0020;\n\tif (prot & FIBF_GRP_READ)\n\t\tmode |= 0040;\n\tif (prot & FIBF_GRP_EXECUTE)\n\t\tmode |= 0010;\n\tif (prot & FIBF_OTR_WRITE)\n\t\tmode |= 0002;\n\tif (prot & FIBF_OTR_READ)\n\t\tmode |= 0004;\n\tif (prot & FIBF_OTR_EXECUTE)\n\t\tmode |= 0001;\n\n\treturn mode;\n}\n\nvoid\naffs_mode_to_prot(struct inode *inode)\n{\n\tu32 prot = AFFS_I(inode)->i_protect;\n\tumode_t mode = inode->i_mode;\n\n\t \n\tprot &= ~(FIBF_NOEXECUTE | FIBF_NOREAD\n\t\t  | FIBF_NOWRITE | FIBF_NODELETE\n\t\t  | FIBF_GRP_EXECUTE | FIBF_GRP_READ\n\t\t  | FIBF_GRP_WRITE   | FIBF_GRP_DELETE\n\t\t  | FIBF_OTR_EXECUTE | FIBF_OTR_READ\n\t\t  | FIBF_OTR_WRITE   | FIBF_OTR_DELETE);\n\n\t \n\tif (!(mode & 0100))\n\t\tprot |= FIBF_NOEXECUTE;\n\tif (!(mode & 0400))\n\t\tprot |= FIBF_NOREAD;\n\tif (!(mode & 0200))\n\t\tprot |= FIBF_NOWRITE;\n\n\t \n\tif (mode & 0010)\n\t\tprot |= FIBF_GRP_EXECUTE;\n\tif (mode & 0040)\n\t\tprot |= FIBF_GRP_READ;\n\tif (mode & 0020)\n\t\tprot |= FIBF_GRP_WRITE;\n\tif (mode & 0070)\n\t\tprot |= FIBF_GRP_DELETE;\n\n\tif (mode & 0001)\n\t\tprot |= FIBF_OTR_EXECUTE;\n\tif (mode & 0004)\n\t\tprot |= FIBF_OTR_READ;\n\tif (mode & 0002)\n\t\tprot |= FIBF_OTR_WRITE;\n\tif (mode & 0007)\n\t\tprot |= FIBF_OTR_DELETE;\n\n\tAFFS_I(inode)->i_protect = prot;\n}\n\nvoid\naffs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_crit(\"error (device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tif (!sb_rdonly(sb))\n\t\tpr_warn(\"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= SB_RDONLY;\n\tva_end(args);\n}\n\nvoid\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}\n\nbool\naffs_nofilenametruncate(const struct dentry *dentry)\n{\n\treturn affs_test_opt(AFFS_SB(dentry->d_sb)->s_flags, SF_NO_TRUNCATE);\n}\n\n \n\nint\naffs_check_name(const unsigned char *name, int len, bool notruncate)\n{\n\tint\t i;\n\n\tif (len > AFFSNAMEMAX) {\n\t\tif (notruncate)\n\t\t\treturn -ENAMETOOLONG;\n\t\tlen = AFFSNAMEMAX;\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tif (name[i] < ' ' || name[i] == ':'\n\t\t    || (name[i] > 0x7e && name[i] < 0xa0))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \n\nint\naffs_copy_name(unsigned char *bstr, struct dentry *dentry)\n{\n\tu32 len = min(dentry->d_name.len, AFFSNAMEMAX);\n\n\t*bstr++ = len;\n\tmemcpy(bstr, dentry->d_name.name, len);\n\treturn len;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}