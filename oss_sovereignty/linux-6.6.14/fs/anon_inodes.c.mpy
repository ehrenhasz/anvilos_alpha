{
  "module_name": "anon_inodes.c",
  "hash_id": "6c019db09c03ad4169e375f633931dce6f9ca2f47d9dcc1c0a7eb36b0d0a44c0",
  "original_prompt": "Ingested from linux-6.6.14/fs/anon_inodes.c",
  "human_readable_source": "\n \n\n#include <linux/cred.h>\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/magic.h>\n#include <linux/anon_inodes.h>\n#include <linux/pseudo_fs.h>\n\n#include <linux/uaccess.h>\n\nstatic struct vfsmount *anon_inode_mnt __read_mostly;\nstatic struct inode *anon_inode_inode;\n\n \nstatic char *anon_inodefs_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\treturn dynamic_dname(buffer, buflen, \"anon_inode:%s\",\n\t\t\t\tdentry->d_name.name);\n}\n\nstatic const struct dentry_operations anon_inodefs_dentry_operations = {\n\t.d_dname\t= anon_inodefs_dname,\n};\n\nstatic int anon_inodefs_init_fs_context(struct fs_context *fc)\n{\n\tstruct pseudo_fs_context *ctx = init_pseudo(fc, ANON_INODE_FS_MAGIC);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->dops = &anon_inodefs_dentry_operations;\n\treturn 0;\n}\n\nstatic struct file_system_type anon_inode_fs_type = {\n\t.name\t\t= \"anon_inodefs\",\n\t.init_fs_context = anon_inodefs_init_fs_context,\n\t.kill_sb\t= kill_anon_super,\n};\n\nstatic struct inode *anon_inode_make_secure_inode(\n\tconst char *name,\n\tconst struct inode *context_inode)\n{\n\tstruct inode *inode;\n\tconst struct qstr qname = QSTR_INIT(name, strlen(name));\n\tint error;\n\n\tinode = alloc_anon_inode(anon_inode_mnt->mnt_sb);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\tinode->i_flags &= ~S_PRIVATE;\n\terror =\tsecurity_inode_init_security_anon(inode, &qname, context_inode);\n\tif (error) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn inode;\n}\n\nstatic struct file *__anon_inode_getfile(const char *name,\n\t\t\t\t\t const struct file_operations *fops,\n\t\t\t\t\t void *priv, int flags,\n\t\t\t\t\t const struct inode *context_inode,\n\t\t\t\t\t bool secure)\n{\n\tstruct inode *inode;\n\tstruct file *file;\n\n\tif (fops->owner && !try_module_get(fops->owner))\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (secure) {\n\t\tinode =\tanon_inode_make_secure_inode(name, context_inode);\n\t\tif (IS_ERR(inode)) {\n\t\t\tfile = ERR_CAST(inode);\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tinode =\tanon_inode_inode;\n\t\tif (IS_ERR(inode)) {\n\t\t\tfile = ERR_PTR(-ENODEV);\n\t\t\tgoto err;\n\t\t}\n\t\t \n\t\tihold(inode);\n\t}\n\n\tfile = alloc_file_pseudo(inode, anon_inode_mnt, name,\n\t\t\t\t flags & (O_ACCMODE | O_NONBLOCK), fops);\n\tif (IS_ERR(file))\n\t\tgoto err_iput;\n\n\tfile->f_mapping = inode->i_mapping;\n\n\tfile->private_data = priv;\n\n\treturn file;\n\nerr_iput:\n\tiput(inode);\nerr:\n\tmodule_put(fops->owner);\n\treturn file;\n}\n\n \nstruct file *anon_inode_getfile(const char *name,\n\t\t\t\tconst struct file_operations *fops,\n\t\t\t\tvoid *priv, int flags)\n{\n\treturn __anon_inode_getfile(name, fops, priv, flags, NULL, false);\n}\nEXPORT_SYMBOL_GPL(anon_inode_getfile);\n\n \nstruct file *anon_inode_getfile_secure(const char *name,\n\t\t\t\t       const struct file_operations *fops,\n\t\t\t\t       void *priv, int flags,\n\t\t\t\t       const struct inode *context_inode)\n{\n\treturn __anon_inode_getfile(name, fops, priv, flags,\n\t\t\t\t    context_inode, true);\n}\n\nstatic int __anon_inode_getfd(const char *name,\n\t\t\t      const struct file_operations *fops,\n\t\t\t      void *priv, int flags,\n\t\t\t      const struct inode *context_inode,\n\t\t\t      bool secure)\n{\n\tint error, fd;\n\tstruct file *file;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\treturn error;\n\tfd = error;\n\n\tfile = __anon_inode_getfile(name, fops, priv, flags, context_inode,\n\t\t\t\t    secure);\n\tif (IS_ERR(file)) {\n\t\terror = PTR_ERR(file);\n\t\tgoto err_put_unused_fd;\n\t}\n\tfd_install(fd, file);\n\n\treturn fd;\n\nerr_put_unused_fd:\n\tput_unused_fd(fd);\n\treturn error;\n}\n\n \nint anon_inode_getfd(const char *name, const struct file_operations *fops,\n\t\t     void *priv, int flags)\n{\n\treturn __anon_inode_getfd(name, fops, priv, flags, NULL, false);\n}\nEXPORT_SYMBOL_GPL(anon_inode_getfd);\n\n \nint anon_inode_getfd_secure(const char *name, const struct file_operations *fops,\n\t\t\t    void *priv, int flags,\n\t\t\t    const struct inode *context_inode)\n{\n\treturn __anon_inode_getfd(name, fops, priv, flags, context_inode, true);\n}\nEXPORT_SYMBOL_GPL(anon_inode_getfd_secure);\n\nstatic int __init anon_inode_init(void)\n{\n\tanon_inode_mnt = kern_mount(&anon_inode_fs_type);\n\tif (IS_ERR(anon_inode_mnt))\n\t\tpanic(\"anon_inode_init() kernel mount failed (%ld)\\n\", PTR_ERR(anon_inode_mnt));\n\n\tanon_inode_inode = alloc_anon_inode(anon_inode_mnt->mnt_sb);\n\tif (IS_ERR(anon_inode_inode))\n\t\tpanic(\"anon_inode_init() inode allocation failed (%ld)\\n\", PTR_ERR(anon_inode_inode));\n\n\treturn 0;\n}\n\nfs_initcall(anon_inode_init);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}