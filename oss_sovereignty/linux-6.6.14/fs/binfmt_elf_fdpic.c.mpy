{
  "module_name": "binfmt_elf_fdpic.c",
  "hash_id": "0774bbd57f5fd5ab9a0264c379350aeb50f3e6b053bdb6e0f07ad9d548d4a022",
  "original_prompt": "Ingested from linux-6.6.14/fs/binfmt_elf_fdpic.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include <linux/fs.h>\n#include <linux/stat.h>\n#include <linux/sched.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/cputime.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/binfmts.h>\n#include <linux/string.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/highuid.h>\n#include <linux/personality.h>\n#include <linux/ptrace.h>\n#include <linux/init.h>\n#include <linux/elf.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elfcore.h>\n#include <linux/coredump.h>\n#include <linux/dax.h>\n#include <linux/regset.h>\n\n#include <linux/uaccess.h>\n#include <asm/param.h>\n\ntypedef char *elf_caddr_t;\n\n#if 0\n#define kdebug(fmt, ...) printk(\"FDPIC \"fmt\"\\n\" ,##__VA_ARGS__ )\n#else\n#define kdebug(fmt, ...) do {} while(0)\n#endif\n\n#if 0\n#define kdcore(fmt, ...) printk(\"FDPIC \"fmt\"\\n\" ,##__VA_ARGS__ )\n#else\n#define kdcore(fmt, ...) do {} while(0)\n#endif\n\nMODULE_LICENSE(\"GPL\");\n\nstatic int load_elf_fdpic_binary(struct linux_binprm *);\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);\nstatic int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);\n\nstatic int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);\n\n#ifndef CONFIG_MMU\nstatic int elf_fdpic_map_file_constdisp_on_uclinux(struct elf_fdpic_params *,\n\t\t\t\t\t\t   struct file *,\n\t\t\t\t\t\t   struct mm_struct *);\n#endif\n\nstatic int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);\n\n#ifdef CONFIG_ELF_CORE\nstatic int elf_fdpic_core_dump(struct coredump_params *cprm);\n#endif\n\nstatic struct linux_binfmt elf_fdpic_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_fdpic_binary,\n#ifdef CONFIG_ELF_CORE\n\t.core_dump\t= elf_fdpic_core_dump,\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n#endif\n};\n\nstatic int __init init_elf_fdpic_binfmt(void)\n{\n\tregister_binfmt(&elf_fdpic_format);\n\treturn 0;\n}\n\nstatic void __exit exit_elf_fdpic_binfmt(void)\n{\n\tunregister_binfmt(&elf_fdpic_format);\n}\n\ncore_initcall(init_elf_fdpic_binfmt);\nmodule_exit(exit_elf_fdpic_binfmt);\n\nstatic int is_elf(struct elfhdr *hdr, struct file *file)\n{\n\tif (memcmp(hdr->e_ident, ELFMAG, SELFMAG) != 0)\n\t\treturn 0;\n\tif (hdr->e_type != ET_EXEC && hdr->e_type != ET_DYN)\n\t\treturn 0;\n\tif (!elf_check_arch(hdr))\n\t\treturn 0;\n\tif (!file->f_op->mmap)\n\t\treturn 0;\n\treturn 1;\n}\n\n#ifndef elf_check_fdpic\n#define elf_check_fdpic(x) 0\n#endif\n\n#ifndef elf_check_const_displacement\n#define elf_check_const_displacement(x) 0\n#endif\n\nstatic int is_constdisp(struct elfhdr *hdr)\n{\n\tif (!elf_check_fdpic(hdr))\n\t\treturn 1;\n\tif (elf_check_const_displacement(hdr))\n\t\treturn 1;\n\treturn 0;\n}\n\n \n \nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *params,\n\t\t\t\t struct file *file)\n{\n\tstruct elf_phdr *phdr;\n\tunsigned long size;\n\tint retval, loop;\n\tloff_t pos = params->hdr.e_phoff;\n\n\tif (params->hdr.e_phentsize != sizeof(struct elf_phdr))\n\t\treturn -ENOMEM;\n\tif (params->hdr.e_phnum > 65536U / sizeof(struct elf_phdr))\n\t\treturn -ENOMEM;\n\n\tsize = params->hdr.e_phnum * sizeof(struct elf_phdr);\n\tparams->phdrs = kmalloc(size, GFP_KERNEL);\n\tif (!params->phdrs)\n\t\treturn -ENOMEM;\n\n\tretval = kernel_read(file, params->phdrs, size, &pos);\n\tif (unlikely(retval != size))\n\t\treturn retval < 0 ? retval : -ENOEXEC;\n\n\t \n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (phdr->p_type != PT_GNU_STACK)\n\t\t\tcontinue;\n\n\t\tif (phdr->p_flags & PF_X)\n\t\t\tparams->flags |= ELF_FDPIC_FLAG_EXEC_STACK;\n\t\telse\n\t\t\tparams->flags |= ELF_FDPIC_FLAG_NOEXEC_STACK;\n\n\t\tparams->stack_size = phdr->p_memsz;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \n \nstatic int load_elf_fdpic_binary(struct linux_binprm *bprm)\n{\n\tstruct elf_fdpic_params exec_params, interp_params;\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct elf_phdr *phdr;\n\tunsigned long stack_size, entryaddr;\n#ifdef ELF_FDPIC_PLAT_INIT\n\tunsigned long dynaddr;\n#endif\n#ifndef CONFIG_MMU\n\tunsigned long stack_prot;\n#endif\n\tstruct file *interpreter = NULL;  \n\tchar *interpreter_name = NULL;\n\tint executable_stack;\n\tint retval, i;\n\tloff_t pos;\n\n\tkdebug(\"____ LOAD %d ____\", current->pid);\n\n\tmemset(&exec_params, 0, sizeof(exec_params));\n\tmemset(&interp_params, 0, sizeof(interp_params));\n\n\texec_params.hdr = *(struct elfhdr *) bprm->buf;\n\texec_params.flags = ELF_FDPIC_FLAG_PRESENT | ELF_FDPIC_FLAG_EXECUTABLE;\n\n\t \n\tretval = -ENOEXEC;\n\tif (!is_elf(&exec_params.hdr, bprm->file))\n\t\tgoto error;\n\tif (!elf_check_fdpic(&exec_params.hdr)) {\n#ifdef CONFIG_MMU\n\t\t \n\t\tgoto error;\n#else\n\t\t \n\t\tif (exec_params.hdr.e_type != ET_DYN)\n\t\t\tgoto error;\n#endif\n\t}\n\n\t \n\tretval = elf_fdpic_fetch_phdrs(&exec_params, bprm->file);\n\tif (retval < 0)\n\t\tgoto error;\n\n\t \n\tphdr = exec_params.phdrs;\n\n\tfor (i = 0; i < exec_params.hdr.e_phnum; i++, phdr++) {\n\t\tswitch (phdr->p_type) {\n\t\tcase PT_INTERP:\n\t\t\tretval = -ENOMEM;\n\t\t\tif (phdr->p_filesz > PATH_MAX)\n\t\t\t\tgoto error;\n\t\t\tretval = -ENOENT;\n\t\t\tif (phdr->p_filesz < 2)\n\t\t\t\tgoto error;\n\n\t\t\t \n\t\t\tinterpreter_name = kmalloc(phdr->p_filesz, GFP_KERNEL);\n\t\t\tif (!interpreter_name)\n\t\t\t\tgoto error;\n\n\t\t\tpos = phdr->p_offset;\n\t\t\tretval = kernel_read(bprm->file, interpreter_name,\n\t\t\t\t\t     phdr->p_filesz, &pos);\n\t\t\tif (unlikely(retval != phdr->p_filesz)) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -ENOEXEC;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tretval = -ENOENT;\n\t\t\tif (interpreter_name[phdr->p_filesz - 1] != '\\0')\n\t\t\t\tgoto error;\n\n\t\t\tkdebug(\"Using ELF interpreter %s\", interpreter_name);\n\n\t\t\t \n\t\t\tinterpreter = open_exec(interpreter_name);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter)) {\n\t\t\t\tinterpreter = NULL;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t \n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\tpos = 0;\n\t\t\tretval = kernel_read(interpreter, bprm->buf,\n\t\t\t\t\tBINPRM_BUF_SIZE, &pos);\n\t\t\tif (unlikely(retval != BINPRM_BUF_SIZE)) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -ENOEXEC;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tinterp_params.hdr = *((struct elfhdr *) bprm->buf);\n\t\t\tbreak;\n\n\t\tcase PT_LOAD:\n#ifdef CONFIG_MMU\n\t\t\tif (exec_params.load_addr == 0)\n\t\t\t\texec_params.load_addr = phdr->p_vaddr;\n#endif\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tif (is_constdisp(&exec_params.hdr))\n\t\texec_params.flags |= ELF_FDPIC_FLAG_CONSTDISP;\n\n\t \n\tif (interpreter_name) {\n\t\tretval = -ELIBBAD;\n\t\tif (!is_elf(&interp_params.hdr, interpreter))\n\t\t\tgoto error;\n\n\t\tinterp_params.flags = ELF_FDPIC_FLAG_PRESENT;\n\n\t\t \n\t\tretval = elf_fdpic_fetch_phdrs(&interp_params, interpreter);\n\t\tif (retval < 0)\n\t\t\tgoto error;\n\t}\n\n\tstack_size = exec_params.stack_size;\n\tif (exec_params.flags & ELF_FDPIC_FLAG_EXEC_STACK)\n\t\texecutable_stack = EXSTACK_ENABLE_X;\n\telse if (exec_params.flags & ELF_FDPIC_FLAG_NOEXEC_STACK)\n\t\texecutable_stack = EXSTACK_DISABLE_X;\n\telse\n\t\texecutable_stack = EXSTACK_DEFAULT;\n\n\tif (stack_size == 0) {\n\t\tstack_size = interp_params.stack_size;\n\t\tif (interp_params.flags & ELF_FDPIC_FLAG_EXEC_STACK)\n\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\telse if (interp_params.flags & ELF_FDPIC_FLAG_NOEXEC_STACK)\n\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\telse\n\t\t\texecutable_stack = EXSTACK_DEFAULT;\n\t}\n\n\tretval = -ENOEXEC;\n\tif (stack_size == 0)\n\t\tstack_size = 131072UL;  \n\n\tif (is_constdisp(&interp_params.hdr))\n\t\tinterp_params.flags |= ELF_FDPIC_FLAG_CONSTDISP;\n\n\t \n\tretval = begin_new_exec(bprm);\n\tif (retval)\n\t\tgoto error;\n\n\t \n\tSET_PERSONALITY(exec_params.hdr);\n\tif (elf_check_fdpic(&exec_params.hdr))\n\t\tcurrent->personality |= PER_LINUX_FDPIC;\n\tif (elf_read_implies_exec(&exec_params.hdr, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tsetup_new_exec(bprm);\n\n\tset_binfmt(&elf_fdpic_format);\n\n\tcurrent->mm->start_code = 0;\n\tcurrent->mm->end_code = 0;\n\tcurrent->mm->start_stack = 0;\n\tcurrent->mm->start_data = 0;\n\tcurrent->mm->end_data = 0;\n\tcurrent->mm->context.exec_fdpic_loadmap = 0;\n\tcurrent->mm->context.interp_fdpic_loadmap = 0;\n\n#ifdef CONFIG_MMU\n\telf_fdpic_arch_lay_out_mm(&exec_params,\n\t\t\t\t  &interp_params,\n\t\t\t\t  &current->mm->start_stack,\n\t\t\t\t  &current->mm->start_brk);\n\n\tretval = setup_arg_pages(bprm, current->mm->start_stack,\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto error;\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!interpreter_name);\n\tif (retval < 0)\n\t\tgoto error;\n#endif\n#endif\n\n\t \n\tretval = elf_fdpic_map_file(&exec_params, bprm->file, current->mm,\n\t\t\t\t    \"executable\");\n\tif (retval < 0)\n\t\tgoto error;\n\n\tif (interpreter_name) {\n\t\tretval = elf_fdpic_map_file(&interp_params, interpreter,\n\t\t\t\t\t    current->mm, \"interpreter\");\n\t\tif (retval < 0) {\n\t\t\tprintk(KERN_ERR \"Unable to load interpreter\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tinterpreter = NULL;\n\t}\n\n#ifdef CONFIG_MMU\n\tif (!current->mm->start_brk)\n\t\tcurrent->mm->start_brk = current->mm->end_data;\n\n\tcurrent->mm->brk = current->mm->start_brk =\n\t\tPAGE_ALIGN(current->mm->start_brk);\n\n#else\n\t \n\tstack_size = (stack_size + PAGE_SIZE - 1) & PAGE_MASK;\n\tif (stack_size < PAGE_SIZE * 2)\n\t\tstack_size = PAGE_SIZE * 2;\n\n\tstack_prot = PROT_READ | PROT_WRITE;\n\tif (executable_stack == EXSTACK_ENABLE_X ||\n\t    (executable_stack == EXSTACK_DEFAULT && VM_STACK_FLAGS & VM_EXEC))\n\t\tstack_prot |= PROT_EXEC;\n\n\tcurrent->mm->start_brk = vm_mmap(NULL, 0, stack_size, stack_prot,\n\t\t\t\t\t MAP_PRIVATE | MAP_ANONYMOUS |\n\t\t\t\t\t MAP_UNINITIALIZED | MAP_GROWSDOWN,\n\t\t\t\t\t 0);\n\n\tif (IS_ERR_VALUE(current->mm->start_brk)) {\n\t\tretval = current->mm->start_brk;\n\t\tcurrent->mm->start_brk = 0;\n\t\tgoto error;\n\t}\n\n\tcurrent->mm->brk = current->mm->start_brk;\n\tcurrent->mm->context.end_brk = current->mm->start_brk;\n\tcurrent->mm->start_stack = current->mm->start_brk + stack_size;\n#endif\n\n\tretval = create_elf_fdpic_tables(bprm, current->mm, &exec_params,\n\t\t\t\t\t &interp_params);\n\tif (retval < 0)\n\t\tgoto error;\n\n\tkdebug(\"- start_code  %lx\", current->mm->start_code);\n\tkdebug(\"- end_code    %lx\", current->mm->end_code);\n\tkdebug(\"- start_data  %lx\", current->mm->start_data);\n\tkdebug(\"- end_data    %lx\", current->mm->end_data);\n\tkdebug(\"- start_brk   %lx\", current->mm->start_brk);\n\tkdebug(\"- brk         %lx\", current->mm->brk);\n\tkdebug(\"- start_stack %lx\", current->mm->start_stack);\n\n#ifdef ELF_FDPIC_PLAT_INIT\n\t \n\tdynaddr = interp_params.dynamic_addr ?: exec_params.dynamic_addr;\n\tELF_FDPIC_PLAT_INIT(regs, exec_params.map_addr, interp_params.map_addr,\n\t\t\t    dynaddr);\n#endif\n\n\tfinalize_exec(bprm);\n\t \n\tentryaddr = interp_params.entry_addr ?: exec_params.entry_addr;\n\tstart_thread(regs, entryaddr, current->mm->start_stack);\n\n\tretval = 0;\n\nerror:\n\tif (interpreter) {\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t}\n\tkfree(interpreter_name);\n\tkfree(exec_params.phdrs);\n\tkfree(exec_params.loadmap);\n\tkfree(interp_params.phdrs);\n\tkfree(interp_params.loadmap);\n\treturn retval;\n}\n\n \n\n#ifndef ELF_BASE_PLATFORM\n \n#define ELF_BASE_PLATFORM NULL\n#endif\n\n \nstatic int create_elf_fdpic_tables(struct linux_binprm *bprm,\n\t\t\t\t   struct mm_struct *mm,\n\t\t\t\t   struct elf_fdpic_params *exec_params,\n\t\t\t\t   struct elf_fdpic_params *interp_params)\n{\n\tconst struct cred *cred = current_cred();\n\tunsigned long sp, csp, nitems;\n\telf_caddr_t __user *argv, *envp;\n\tsize_t platform_len = 0, len;\n\tchar *k_platform, *k_base_platform;\n\tchar __user *u_platform, *u_base_platform, *p;\n\tint loop;\n\tint nr;\t \n\tunsigned long flags = 0;\n\n#ifdef CONFIG_MMU\n\t \n\tsp = arch_align_stack(bprm->p);\n#else\n\tsp = mm->start_stack;\n\n\t \n\tif (transfer_args_to_stack(bprm, &sp) < 0)\n\t\treturn -EFAULT;\n\tsp &= ~15;\n#endif\n\n\t \n\tk_platform = ELF_PLATFORM;\n\tu_platform = NULL;\n\n\tif (k_platform) {\n\t\tplatform_len = strlen(k_platform) + 1;\n\t\tsp -= platform_len;\n\t\tu_platform = (char __user *) sp;\n\t\tif (copy_to_user(u_platform, k_platform, platform_len) != 0)\n\t\t\treturn -EFAULT;\n\t}\n\n\t \n\tk_base_platform = ELF_BASE_PLATFORM;\n\tu_base_platform = NULL;\n\n\tif (k_base_platform) {\n\t\tplatform_len = strlen(k_base_platform) + 1;\n\t\tsp -= platform_len;\n\t\tu_base_platform = (char __user *) sp;\n\t\tif (copy_to_user(u_base_platform, k_base_platform, platform_len) != 0)\n\t\t\treturn -EFAULT;\n\t}\n\n\tsp &= ~7UL;\n\n\t \n\tlen = sizeof(struct elf_fdpic_loadmap);\n\tlen += sizeof(struct elf_fdpic_loadseg) * exec_params->loadmap->nsegs;\n\tsp = (sp - len) & ~7UL;\n\texec_params->map_addr = sp;\n\n\tif (copy_to_user((void __user *) sp, exec_params->loadmap, len) != 0)\n\t\treturn -EFAULT;\n\n\tcurrent->mm->context.exec_fdpic_loadmap = (unsigned long) sp;\n\n\tif (interp_params->loadmap) {\n\t\tlen = sizeof(struct elf_fdpic_loadmap);\n\t\tlen += sizeof(struct elf_fdpic_loadseg) *\n\t\t\tinterp_params->loadmap->nsegs;\n\t\tsp = (sp - len) & ~7UL;\n\t\tinterp_params->map_addr = sp;\n\n\t\tif (copy_to_user((void __user *) sp, interp_params->loadmap,\n\t\t\t\t len) != 0)\n\t\t\treturn -EFAULT;\n\n\t\tcurrent->mm->context.interp_fdpic_loadmap = (unsigned long) sp;\n\t}\n\n\t \n#define DLINFO_ITEMS 15\n\n\tnitems = 1 + DLINFO_ITEMS + (k_platform ? 1 : 0) +\n\t\t(k_base_platform ? 1 : 0) + AT_VECTOR_SIZE_ARCH;\n\n\tif (bprm->have_execfd)\n\t\tnitems++;\n\n\tcsp = sp;\n\tsp -= nitems * 2 * sizeof(unsigned long);\n\tsp -= (bprm->envc + 1) * sizeof(char *);\t \n\tsp -= (bprm->argc + 1) * sizeof(char *);\t \n\tsp -= 1 * sizeof(unsigned long);\t\t \n\n\tcsp -= sp & 15UL;\n\tsp -= sp & 15UL;\n\n\t \n#define NEW_AUX_ENT(id, val)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct { unsigned long _id, _val; } __user *ent, v;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tent = (void __user *) csp;\t\t\t\t\\\n\t\tv._id = (id);\t\t\t\t\t\t\\\n\t\tv._val = (val);\t\t\t\t\t\t\\\n\t\tif (copy_to_user(ent + nr, &v, sizeof(v)))\t\t\\\n\t\t\treturn -EFAULT;\t\t\t\t\t\\\n\t\tnr++;\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tnr = 0;\n\tcsp -= 2 * sizeof(unsigned long);\n\tNEW_AUX_ENT(AT_NULL, 0);\n\tif (k_platform) {\n\t\tnr = 0;\n\t\tcsp -= 2 * sizeof(unsigned long);\n\t\tNEW_AUX_ENT(AT_PLATFORM,\n\t\t\t    (elf_addr_t) (unsigned long) u_platform);\n\t}\n\n\tif (k_base_platform) {\n\t\tnr = 0;\n\t\tcsp -= 2 * sizeof(unsigned long);\n\t\tNEW_AUX_ENT(AT_BASE_PLATFORM,\n\t\t\t    (elf_addr_t) (unsigned long) u_base_platform);\n\t}\n\n\tif (bprm->have_execfd) {\n\t\tnr = 0;\n\t\tcsp -= 2 * sizeof(unsigned long);\n\t\tNEW_AUX_ENT(AT_EXECFD, bprm->execfd);\n\t}\n\n\tnr = 0;\n\tcsp -= DLINFO_ITEMS * 2 * sizeof(unsigned long);\n\tNEW_AUX_ENT(AT_HWCAP,\tELF_HWCAP);\n#ifdef ELF_HWCAP2\n\tNEW_AUX_ENT(AT_HWCAP2,\tELF_HWCAP2);\n#endif\n\tNEW_AUX_ENT(AT_PAGESZ,\tPAGE_SIZE);\n\tNEW_AUX_ENT(AT_CLKTCK,\tCLOCKS_PER_SEC);\n\tNEW_AUX_ENT(AT_PHDR,\texec_params->ph_addr);\n\tNEW_AUX_ENT(AT_PHENT,\tsizeof(struct elf_phdr));\n\tNEW_AUX_ENT(AT_PHNUM,\texec_params->hdr.e_phnum);\n\tNEW_AUX_ENT(AT_BASE,\tinterp_params->elfhdr_addr);\n\tif (bprm->interp_flags & BINPRM_FLAGS_PRESERVE_ARGV0)\n\t\tflags |= AT_FLAGS_PRESERVE_ARGV0;\n\tNEW_AUX_ENT(AT_FLAGS,\tflags);\n\tNEW_AUX_ENT(AT_ENTRY,\texec_params->entry_addr);\n\tNEW_AUX_ENT(AT_UID,\t(elf_addr_t) from_kuid_munged(cred->user_ns, cred->uid));\n\tNEW_AUX_ENT(AT_EUID,\t(elf_addr_t) from_kuid_munged(cred->user_ns, cred->euid));\n\tNEW_AUX_ENT(AT_GID,\t(elf_addr_t) from_kgid_munged(cred->user_ns, cred->gid));\n\tNEW_AUX_ENT(AT_EGID,\t(elf_addr_t) from_kgid_munged(cred->user_ns, cred->egid));\n\tNEW_AUX_ENT(AT_SECURE,\tbprm->secureexec);\n\tNEW_AUX_ENT(AT_EXECFN,\tbprm->exec);\n\n#ifdef ARCH_DLINFO\n\tnr = 0;\n\tcsp -= AT_VECTOR_SIZE_ARCH * 2 * sizeof(unsigned long);\n\n\t \n\tARCH_DLINFO;\n#endif\n#undef NEW_AUX_ENT\n\n\t \n\tcsp -= (bprm->envc + 1) * sizeof(elf_caddr_t);\n\tenvp = (elf_caddr_t __user *) csp;\n\tcsp -= (bprm->argc + 1) * sizeof(elf_caddr_t);\n\targv = (elf_caddr_t __user *) csp;\n\n\t \n\tcsp -= sizeof(unsigned long);\n\tif (put_user(bprm->argc, (unsigned long __user *) csp))\n\t\treturn -EFAULT;\n\n\tBUG_ON(csp != sp);\n\n\t \n#ifdef CONFIG_MMU\n\tcurrent->mm->arg_start = bprm->p;\n#else\n\tcurrent->mm->arg_start = current->mm->start_stack -\n\t\t(MAX_ARG_PAGES * PAGE_SIZE - bprm->p);\n#endif\n\n\tp = (char __user *) current->mm->arg_start;\n\tfor (loop = bprm->argc; loop > 0; loop--) {\n\t\tif (put_user((elf_caddr_t) p, argv++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (put_user(NULL, argv))\n\t\treturn -EFAULT;\n\tcurrent->mm->arg_end = (unsigned long) p;\n\n\t \n\tcurrent->mm->env_start = (unsigned long) p;\n\tfor (loop = bprm->envc; loop > 0; loop--) {\n\t\tif (put_user((elf_caddr_t)(unsigned long) p, envp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (put_user(NULL, envp))\n\t\treturn -EFAULT;\n\tcurrent->mm->env_end = (unsigned long) p;\n\n\tmm->start_stack = (unsigned long) sp;\n\treturn 0;\n}\n\n \n \nstatic int elf_fdpic_map_file(struct elf_fdpic_params *params,\n\t\t\t      struct file *file,\n\t\t\t      struct mm_struct *mm,\n\t\t\t      const char *what)\n{\n\tstruct elf_fdpic_loadmap *loadmap;\n#ifdef CONFIG_MMU\n\tstruct elf_fdpic_loadseg *mseg;\n\tunsigned long load_addr;\n#endif\n\tstruct elf_fdpic_loadseg *seg;\n\tstruct elf_phdr *phdr;\n\tunsigned nloads, tmp;\n\tunsigned long stop;\n\tint loop, ret;\n\n\t \n\tnloads = 0;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++)\n\t\tif (params->phdrs[loop].p_type == PT_LOAD)\n\t\t\tnloads++;\n\n\tif (nloads == 0)\n\t\treturn -ELIBBAD;\n\n\tloadmap = kzalloc(struct_size(loadmap, segs, nloads), GFP_KERNEL);\n\tif (!loadmap)\n\t\treturn -ENOMEM;\n\n\tparams->loadmap = loadmap;\n\n\tloadmap->version = ELF_FDPIC_LOADMAP_VERSION;\n\tloadmap->nsegs = nloads;\n\n\t \n\tswitch (params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) {\n\tcase ELF_FDPIC_FLAG_CONSTDISP:\n\tcase ELF_FDPIC_FLAG_CONTIGUOUS:\n#ifndef CONFIG_MMU\n\t\tret = elf_fdpic_map_file_constdisp_on_uclinux(params, file, mm);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tret = elf_fdpic_map_file_by_direct_mmap(params, file, mm);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\t \n\tif (params->hdr.e_entry) {\n\t\tseg = loadmap->segs;\n\t\tfor (loop = loadmap->nsegs; loop > 0; loop--, seg++) {\n\t\t\tif (params->hdr.e_entry >= seg->p_vaddr &&\n\t\t\t    params->hdr.e_entry < seg->p_vaddr + seg->p_memsz) {\n\t\t\t\tparams->entry_addr =\n\t\t\t\t\t(params->hdr.e_entry - seg->p_vaddr) +\n\t\t\t\t\tseg->addr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tstop = params->hdr.e_phoff;\n\tstop += params->hdr.e_phnum * sizeof (struct elf_phdr);\n\tphdr = params->phdrs;\n\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (phdr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (phdr->p_offset > params->hdr.e_phoff ||\n\t\t    phdr->p_offset + phdr->p_filesz < stop)\n\t\t\tcontinue;\n\n\t\tseg = loadmap->segs;\n\t\tfor (loop = loadmap->nsegs; loop > 0; loop--, seg++) {\n\t\t\tif (phdr->p_vaddr >= seg->p_vaddr &&\n\t\t\t    phdr->p_vaddr + phdr->p_filesz <=\n\t\t\t    seg->p_vaddr + seg->p_memsz) {\n\t\t\t\tparams->ph_addr =\n\t\t\t\t\t(phdr->p_vaddr - seg->p_vaddr) +\n\t\t\t\t\tseg->addr +\n\t\t\t\t\tparams->hdr.e_phoff - phdr->p_offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (phdr->p_type != PT_DYNAMIC)\n\t\t\tcontinue;\n\n\t\tseg = loadmap->segs;\n\t\tfor (loop = loadmap->nsegs; loop > 0; loop--, seg++) {\n\t\t\tif (phdr->p_vaddr >= seg->p_vaddr &&\n\t\t\t    phdr->p_vaddr + phdr->p_memsz <=\n\t\t\t    seg->p_vaddr + seg->p_memsz) {\n\t\t\t\tElf_Dyn __user *dyn;\n\t\t\t\tElf_Sword d_tag;\n\n\t\t\t\tparams->dynamic_addr =\n\t\t\t\t\t(phdr->p_vaddr - seg->p_vaddr) +\n\t\t\t\t\tseg->addr;\n\n\t\t\t\t \n\t\t\t\tif (phdr->p_memsz == 0 ||\n\t\t\t\t    phdr->p_memsz % sizeof(Elf_Dyn) != 0)\n\t\t\t\t\tgoto dynamic_error;\n\n\t\t\t\ttmp = phdr->p_memsz / sizeof(Elf_Dyn);\n\t\t\t\tdyn = (Elf_Dyn __user *)params->dynamic_addr;\n\t\t\t\tif (get_user(d_tag, &dyn[tmp - 1].d_tag) ||\n\t\t\t\t    d_tag != 0)\n\t\t\t\t\tgoto dynamic_error;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n#ifdef CONFIG_MMU\n\tnloads = loadmap->nsegs;\n\tmseg = loadmap->segs;\n\tseg = mseg + 1;\n\tfor (loop = 1; loop < nloads; loop++) {\n\t\t \n\t\tif (seg->p_vaddr - mseg->p_vaddr == seg->addr - mseg->addr) {\n\t\t\tload_addr = PAGE_ALIGN(mseg->addr + mseg->p_memsz);\n\t\t\tif (load_addr == (seg->addr & PAGE_MASK)) {\n\t\t\t\tmseg->p_memsz +=\n\t\t\t\t\tload_addr -\n\t\t\t\t\t(mseg->addr + mseg->p_memsz);\n\t\t\t\tmseg->p_memsz += seg->addr & ~PAGE_MASK;\n\t\t\t\tmseg->p_memsz += seg->p_memsz;\n\t\t\t\tloadmap->nsegs--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmseg++;\n\t\tif (mseg != seg)\n\t\t\t*mseg = *seg;\n\t}\n#endif\n\n\tkdebug(\"Mapped Object [%s]:\", what);\n\tkdebug(\"- elfhdr   : %lx\", params->elfhdr_addr);\n\tkdebug(\"- entry    : %lx\", params->entry_addr);\n\tkdebug(\"- PHDR[]   : %lx\", params->ph_addr);\n\tkdebug(\"- DYNAMIC[]: %lx\", params->dynamic_addr);\n\tseg = loadmap->segs;\n\tfor (loop = 0; loop < loadmap->nsegs; loop++, seg++)\n\t\tkdebug(\"- LOAD[%d] : %08x-%08x [va=%x ms=%x]\",\n\t\t       loop,\n\t\t       seg->addr, seg->addr + seg->p_memsz - 1,\n\t\t       seg->p_vaddr, seg->p_memsz);\n\n\treturn 0;\n\ndynamic_error:\n\tprintk(\"ELF FDPIC %s with invalid DYNAMIC section (inode=%lu)\\n\",\n\t       what, file_inode(file)->i_ino);\n\treturn -ELIBBAD;\n}\n\n \n \n#ifndef CONFIG_MMU\nstatic int elf_fdpic_map_file_constdisp_on_uclinux(\n\tstruct elf_fdpic_params *params,\n\tstruct file *file,\n\tstruct mm_struct *mm)\n{\n\tstruct elf_fdpic_loadseg *seg;\n\tstruct elf_phdr *phdr;\n\tunsigned long load_addr, base = ULONG_MAX, top = 0, maddr = 0;\n\tint loop, ret;\n\n\tload_addr = params->load_addr;\n\tseg = params->loadmap->segs;\n\n\t \n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (params->phdrs[loop].p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (base > phdr->p_vaddr)\n\t\t\tbase = phdr->p_vaddr;\n\t\tif (top < phdr->p_vaddr + phdr->p_memsz)\n\t\t\ttop = phdr->p_vaddr + phdr->p_memsz;\n\t}\n\n\t \n\tmaddr = vm_mmap(NULL, load_addr, top - base,\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE, 0);\n\tif (IS_ERR_VALUE(maddr))\n\t\treturn (int) maddr;\n\n\tif (load_addr != 0)\n\t\tload_addr += PAGE_ALIGN(top - base);\n\n\t \n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (params->phdrs[loop].p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tseg->addr = maddr + (phdr->p_vaddr - base);\n\t\tseg->p_vaddr = phdr->p_vaddr;\n\t\tseg->p_memsz = phdr->p_memsz;\n\n\t\tret = read_code(file, seg->addr, phdr->p_offset,\n\t\t\t\t       phdr->p_filesz);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (phdr->p_offset == 0)\n\t\t\tparams->elfhdr_addr = seg->addr;\n\n\t\t \n\t\tif (phdr->p_filesz < phdr->p_memsz) {\n\t\t\tif (clear_user((void *) (seg->addr + phdr->p_filesz),\n\t\t\t\t       phdr->p_memsz - phdr->p_filesz))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (mm) {\n\t\t\tif (phdr->p_flags & PF_X) {\n\t\t\t\tif (!mm->start_code) {\n\t\t\t\t\tmm->start_code = seg->addr;\n\t\t\t\t\tmm->end_code = seg->addr +\n\t\t\t\t\t\tphdr->p_memsz;\n\t\t\t\t}\n\t\t\t} else if (!mm->start_data) {\n\t\t\t\tmm->start_data = seg->addr;\n\t\t\t\tmm->end_data = seg->addr + phdr->p_memsz;\n\t\t\t}\n\t\t}\n\n\t\tseg++;\n\t}\n\n\treturn 0;\n}\n#endif\n\n \n \nstatic int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *params,\n\t\t\t\t\t     struct file *file,\n\t\t\t\t\t     struct mm_struct *mm)\n{\n\tstruct elf_fdpic_loadseg *seg;\n\tstruct elf_phdr *phdr;\n\tunsigned long load_addr, delta_vaddr;\n\tint loop, dvset;\n\n\tload_addr = params->load_addr;\n\tdelta_vaddr = 0;\n\tdvset = 0;\n\n\tseg = params->loadmap->segs;\n\n\t \n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tunsigned long maddr, disp, excess, excess1;\n\t\tint prot = 0, flags;\n\n\t\tif (phdr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tkdebug(\"[LOAD] va=%lx of=%lx fs=%lx ms=%lx\",\n\t\t       (unsigned long) phdr->p_vaddr,\n\t\t       (unsigned long) phdr->p_offset,\n\t\t       (unsigned long) phdr->p_filesz,\n\t\t       (unsigned long) phdr->p_memsz);\n\n\t\t \n\t\tif (phdr->p_flags & PF_R) prot |= PROT_READ;\n\t\tif (phdr->p_flags & PF_W) prot |= PROT_WRITE;\n\t\tif (phdr->p_flags & PF_X) prot |= PROT_EXEC;\n\n\t\tflags = MAP_PRIVATE;\n\t\tmaddr = 0;\n\n\t\tswitch (params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) {\n\t\tcase ELF_FDPIC_FLAG_INDEPENDENT:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase ELF_FDPIC_FLAG_HONOURVADDR:\n\t\t\t \n\t\t\tmaddr = phdr->p_vaddr;\n\t\t\tflags |= MAP_FIXED;\n\t\t\tbreak;\n\n\t\tcase ELF_FDPIC_FLAG_CONSTDISP:\n\t\t\t \n\t\t\tif (!dvset) {\n\t\t\t\tmaddr = load_addr;\n\t\t\t\tdelta_vaddr = phdr->p_vaddr;\n\t\t\t\tdvset = 1;\n\t\t\t} else {\n\t\t\t\tmaddr = load_addr + phdr->p_vaddr - delta_vaddr;\n\t\t\t\tflags |= MAP_FIXED;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ELF_FDPIC_FLAG_CONTIGUOUS:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tmaddr &= PAGE_MASK;\n\n\t\t \n\t\tdisp = phdr->p_vaddr & ~PAGE_MASK;\n\t\tmaddr = vm_mmap(file, maddr, phdr->p_memsz + disp, prot, flags,\n\t\t\t\tphdr->p_offset - disp);\n\n\t\tkdebug(\"mmap[%d] <file> sz=%lx pr=%x fl=%x of=%lx --> %08lx\",\n\t\t       loop, phdr->p_memsz + disp, prot, flags,\n\t\t       phdr->p_offset - disp, maddr);\n\n\t\tif (IS_ERR_VALUE(maddr))\n\t\t\treturn (int) maddr;\n\n\t\tif ((params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) ==\n\t\t    ELF_FDPIC_FLAG_CONTIGUOUS)\n\t\t\tload_addr += PAGE_ALIGN(phdr->p_memsz + disp);\n\n\t\tseg->addr = maddr + disp;\n\t\tseg->p_vaddr = phdr->p_vaddr;\n\t\tseg->p_memsz = phdr->p_memsz;\n\n\t\t \n\t\tif (phdr->p_offset == 0)\n\t\t\tparams->elfhdr_addr = seg->addr;\n\n\t\t \n\t\tif (prot & PROT_WRITE && disp > 0) {\n\t\t\tkdebug(\"clear[%d] ad=%lx sz=%lx\", loop, maddr, disp);\n\t\t\tif (clear_user((void __user *) maddr, disp))\n\t\t\t\treturn -EFAULT;\n\t\t\tmaddr += disp;\n\t\t}\n\n\t\t \n\t\texcess = phdr->p_memsz - phdr->p_filesz;\n\t\texcess1 = PAGE_SIZE - ((maddr + phdr->p_filesz) & ~PAGE_MASK);\n\n#ifdef CONFIG_MMU\n\t\tif (excess > excess1) {\n\t\t\tunsigned long xaddr = maddr + phdr->p_filesz + excess1;\n\t\t\tunsigned long xmaddr;\n\n\t\t\tflags |= MAP_FIXED | MAP_ANONYMOUS;\n\t\t\txmaddr = vm_mmap(NULL, xaddr, excess - excess1,\n\t\t\t\t\t prot, flags, 0);\n\n\t\t\tkdebug(\"mmap[%d] <anon>\"\n\t\t\t       \" ad=%lx sz=%lx pr=%x fl=%x of=0 --> %08lx\",\n\t\t\t       loop, xaddr, excess - excess1, prot, flags,\n\t\t\t       xmaddr);\n\n\t\t\tif (xmaddr != xaddr)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (prot & PROT_WRITE && excess1 > 0) {\n\t\t\tkdebug(\"clear[%d] ad=%lx sz=%lx\",\n\t\t\t       loop, maddr + phdr->p_filesz, excess1);\n\t\t\tif (clear_user((void __user *) maddr + phdr->p_filesz,\n\t\t\t\t       excess1))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n#else\n\t\tif (excess > 0) {\n\t\t\tkdebug(\"clear[%d] ad=%lx sz=%lx\",\n\t\t\t       loop, maddr + phdr->p_filesz, excess);\n\t\t\tif (clear_user((void *) maddr + phdr->p_filesz, excess))\n\t\t\t\treturn -EFAULT;\n\t\t}\n#endif\n\n\t\tif (mm) {\n\t\t\tif (phdr->p_flags & PF_X) {\n\t\t\t\tif (!mm->start_code) {\n\t\t\t\t\tmm->start_code = maddr;\n\t\t\t\t\tmm->end_code = maddr + phdr->p_memsz;\n\t\t\t\t}\n\t\t\t} else if (!mm->start_data) {\n\t\t\t\tmm->start_data = maddr;\n\t\t\t\tmm->end_data = maddr + phdr->p_memsz;\n\t\t\t}\n\t\t}\n\n\t\tseg++;\n\t}\n\n\treturn 0;\n}\n\n \n \n#ifdef CONFIG_ELF_CORE\n\nstruct elf_prstatus_fdpic\n{\n\tstruct elf_prstatus_common\tcommon;\n\telf_gregset_t pr_reg;\t \n\t \n\tunsigned long pr_exec_fdpic_loadmap;\n\tunsigned long pr_interp_fdpic_loadmap;\n\tint pr_fpvalid;\t\t \n};\n\n \nstruct memelfnote\n{\n\tconst char *name;\n\tint type;\n\tunsigned int datasz;\n\tvoid *data;\n};\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}\n\n \n\nstatic int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t\tdump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t\tdump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}\n\nstatic inline void fill_elf_fdpic_header(struct elfhdr *elf, int segs)\n{\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\tmemset(elf->e_ident+EI_PAD, 0, EI_NIDENT-EI_PAD);\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = ELF_ARCH;\n\telf->e_version = EV_CURRENT;\n\telf->e_entry = 0;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_shoff = 0;\n\telf->e_flags = ELF_FDPIC_CORE_EFLAGS;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\telf->e_shentsize = 0;\n\telf->e_shnum = 0;\n\telf->e_shstrndx = 0;\n\treturn;\n}\n\nstatic inline void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 4;\n\treturn;\n}\n\nstatic inline void fill_note(struct memelfnote *note, const char *name, int type,\n\t\tunsigned int sz, void *data)\n{\n\tnote->name = name;\n\tnote->type = type;\n\tnote->datasz = sz;\n\tnote->data = data;\n\treturn;\n}\n\n \nstatic void fill_prstatus(struct elf_prstatus_common *prstatus,\n\t\t\t  struct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t \n\t\tthread_group_cputime(p, &cputime);\n\t\tprstatus->pr_utime = ns_to_kernel_old_timeval(cputime.utime);\n\t\tprstatus->pr_stime = ns_to_kernel_old_timeval(cputime.stime);\n\t} else {\n\t\tu64 utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tprstatus->pr_utime = ns_to_kernel_old_timeval(utime);\n\t\tprstatus->pr_stime = ns_to_kernel_old_timeval(stime);\n\t}\n\tprstatus->pr_cutime = ns_to_kernel_old_timeval(p->signal->cutime);\n\tprstatus->pr_cstime = ns_to_kernel_old_timeval(p->signal->cstime);\n}\n\nstatic int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\tunsigned int state;\n\n\t \n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ - 1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *) mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor (i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\tstate = READ_ONCE(p->__state);\n\ti = state ? ffz(~state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\n\treturn 0;\n}\n\n \nstruct elf_thread_status\n{\n\tstruct elf_thread_status *next;\n\tstruct elf_prstatus_fdpic prstatus;\t \n\telf_fpregset_t fpu;\t\t \n\tstruct memelfnote notes[2];\n\tint num_notes;\n};\n\n \nstatic struct elf_thread_status *elf_dump_thread_status(long signr, struct task_struct *p, int *sz)\n{\n\tconst struct user_regset_view *view = task_user_regset_view(p);\n\tstruct elf_thread_status *t;\n\tint i, ret;\n\n\tt = kzalloc(sizeof(struct elf_thread_status), GFP_KERNEL);\n\tif (!t)\n\t\treturn t;\n\n\tfill_prstatus(&t->prstatus.common, p, signr);\n\tt->prstatus.pr_exec_fdpic_loadmap = p->mm->context.exec_fdpic_loadmap;\n\tt->prstatus.pr_interp_fdpic_loadmap = p->mm->context.interp_fdpic_loadmap;\n\tregset_get(p, &view->regsets[0],\n\t\t   sizeof(t->prstatus.pr_reg), &t->prstatus.pr_reg);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &t->prstatus);\n\tt->num_notes++;\n\t*sz += notesize(&t->notes[0]);\n\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\tcontinue;\n\t\tif (regset->active && regset->active(p, regset) <= 0)\n\t\t\tcontinue;\n\t\tret = regset_get(p, regset, sizeof(t->fpu), &t->fpu);\n\t\tif (ret >= 0)\n\t\t\tt->prstatus.pr_fpvalid = 1;\n\t\tbreak;\n\t}\n\n\tif (t->prstatus.pr_fpvalid) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &t->fpu);\n\t\tt->num_notes++;\n\t\t*sz += notesize(&t->notes[1]);\n\t}\n\treturn t;\n}\n\nstatic void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\n\t\t\t     elf_addr_t e_shoff, int segs)\n{\n\telf->e_shoff = e_shoff;\n\telf->e_shentsize = sizeof(*shdr4extnum);\n\telf->e_shnum = 1;\n\telf->e_shstrndx = SHN_UNDEF;\n\n\tmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\n\n\tshdr4extnum->sh_type = SHT_NULL;\n\tshdr4extnum->sh_size = elf->e_shnum;\n\tshdr4extnum->sh_link = elf->e_shstrndx;\n\tshdr4extnum->sh_info = segs;\n}\n\n \nstatic bool elf_fdpic_dump_segments(struct coredump_params *cprm,\n\t\t\t\t    struct core_vma_metadata *vma_meta,\n\t\t\t\t    int vma_count)\n{\n\tint i;\n\n\tfor (i = 0; i < vma_count; i++) {\n\t\tstruct core_vma_metadata *meta = vma_meta + i;\n\n\t\tif (!dump_user_range(cprm, meta->start, meta->dump_size))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic int elf_fdpic_core_dump(struct coredump_params *cprm)\n{\n\tint has_dumped = 0;\n\tint segs;\n\tint i;\n\tstruct elfhdr *elf = NULL;\n\tloff_t offset = 0, dataoff;\n\tstruct memelfnote psinfo_note, auxv_note;\n\tstruct elf_prpsinfo *psinfo = NULL;\t \n\tstruct elf_thread_status *thread_list = NULL;\n\tint thread_status_size = 0;\n\telf_addr_t *auxv;\n\tstruct elf_phdr *phdr4note = NULL;\n\tstruct elf_shdr *shdr4extnum = NULL;\n\tElf_Half e_phnum;\n\telf_addr_t e_shoff;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *tmp;\n\n\t \n\telf = kmalloc(sizeof(*elf), GFP_KERNEL);\n\tif (!elf)\n\t\tgoto end_coredump;\n\tpsinfo = kmalloc(sizeof(*psinfo), GFP_KERNEL);\n\tif (!psinfo)\n\t\tgoto end_coredump;\n\n\tfor (ct = current->signal->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\ttmp = elf_dump_thread_status(cprm->siginfo->si_signo,\n\t\t\t\t\t     ct->task, &thread_status_size);\n\t\tif (!tmp)\n\t\t\tgoto end_coredump;\n\n\t\ttmp->next = thread_list;\n\t\tthread_list = tmp;\n\t}\n\n\t \n\ttmp = elf_dump_thread_status(cprm->siginfo->si_signo,\n\t\t\t\t     current, &thread_status_size);\n\tif (!tmp)\n\t\tgoto end_coredump;\n\ttmp->next = thread_list;\n\tthread_list = tmp;\n\n\tsegs = cprm->vma_count + elf_core_extra_phdrs(cprm);\n\n\t \n\tsegs++;\n\n\t \n\te_phnum = segs > PN_XNUM ? PN_XNUM : segs;\n\n\t \n\tfill_elf_fdpic_header(elf, e_phnum);\n\n\thas_dumped = 1;\n\t \n\n\tfill_psinfo(psinfo, current->group_leader, current->mm);\n\tfill_note(&psinfo_note, \"CORE\", NT_PRPSINFO, sizeof(*psinfo), psinfo);\n\tthread_status_size += notesize(&psinfo_note);\n\n\tauxv = (elf_addr_t *) current->mm->saved_auxv;\n\ti = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(&auxv_note, \"CORE\", NT_AUXV, i * sizeof(elf_addr_t), auxv);\n\tthread_status_size += notesize(&auxv_note);\n\n\toffset = sizeof(*elf);\t\t\t\t \n\toffset += segs * sizeof(struct elf_phdr);\t \n\n\t \n\tphdr4note = kmalloc(sizeof(*phdr4note), GFP_KERNEL);\n\tif (!phdr4note)\n\t\tgoto end_coredump;\n\n\tfill_elf_note_phdr(phdr4note, thread_status_size, offset);\n\toffset += thread_status_size;\n\n\t \n\tdataoff = offset = roundup(offset, ELF_EXEC_PAGESIZE);\n\n\toffset += cprm->vma_data_size;\n\toffset += elf_core_extra_data_size(cprm);\n\te_shoff = offset;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tshdr4extnum = kmalloc(sizeof(*shdr4extnum), GFP_KERNEL);\n\t\tif (!shdr4extnum)\n\t\t\tgoto end_coredump;\n\t\tfill_extnum_info(elf, shdr4extnum, e_shoff, segs);\n\t}\n\n\toffset = dataoff;\n\n\tif (!dump_emit(cprm, elf, sizeof(*elf)))\n\t\tgoto end_coredump;\n\n\tif (!dump_emit(cprm, phdr4note, sizeof(*phdr4note)))\n\t\tgoto end_coredump;\n\n\t \n\tfor (i = 0; i < cprm->vma_count; i++) {\n\t\tstruct core_vma_metadata *meta = cprm->vma_meta + i;\n\t\tstruct elf_phdr phdr;\n\t\tsize_t sz;\n\n\t\tsz = meta->end - meta->start;\n\n\t\tphdr.p_type = PT_LOAD;\n\t\tphdr.p_offset = offset;\n\t\tphdr.p_vaddr = meta->start;\n\t\tphdr.p_paddr = 0;\n\t\tphdr.p_filesz = meta->dump_size;\n\t\tphdr.p_memsz = sz;\n\t\toffset += phdr.p_filesz;\n\t\tphdr.p_flags = 0;\n\t\tif (meta->flags & VM_READ)\n\t\t\tphdr.p_flags |= PF_R;\n\t\tif (meta->flags & VM_WRITE)\n\t\t\tphdr.p_flags |= PF_W;\n\t\tif (meta->flags & VM_EXEC)\n\t\t\tphdr.p_flags |= PF_X;\n\t\tphdr.p_align = ELF_EXEC_PAGESIZE;\n\n\t\tif (!dump_emit(cprm, &phdr, sizeof(phdr)))\n\t\t\tgoto end_coredump;\n\t}\n\n\tif (!elf_core_write_extra_phdrs(cprm, offset))\n\t\tgoto end_coredump;\n\n\t \n\tif (!writenote(thread_list->notes, cprm))\n\t\tgoto end_coredump;\n\tif (!writenote(&psinfo_note, cprm))\n\t\tgoto end_coredump;\n\tif (!writenote(&auxv_note, cprm))\n\t\tgoto end_coredump;\n\tfor (i = 1; i < thread_list->num_notes; i++)\n\t\tif (!writenote(thread_list->notes + i, cprm))\n\t\t\tgoto end_coredump;\n\n\t \n\tfor (tmp = thread_list->next; tmp; tmp = tmp->next) {\n\t\tfor (i = 0; i < tmp->num_notes; i++)\n\t\t\tif (!writenote(&tmp->notes[i], cprm))\n\t\t\t\tgoto end_coredump;\n\t}\n\n\tdump_skip_to(cprm, dataoff);\n\n\tif (!elf_fdpic_dump_segments(cprm, cprm->vma_meta, cprm->vma_count))\n\t\tgoto end_coredump;\n\n\tif (!elf_core_write_extra_data(cprm))\n\t\tgoto end_coredump;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tif (!dump_emit(cprm, shdr4extnum, sizeof(*shdr4extnum)))\n\t\t\tgoto end_coredump;\n\t}\n\n\tif (cprm->file->f_pos != offset) {\n\t\t \n\t\tprintk(KERN_WARNING\n\t\t       \"elf_core_dump: file->f_pos (%lld) != offset (%lld)\\n\",\n\t\t       cprm->file->f_pos, offset);\n\t}\n\nend_coredump:\n\twhile (thread_list) {\n\t\ttmp = thread_list;\n\t\tthread_list = thread_list->next;\n\t\tkfree(tmp);\n\t}\n\tkfree(phdr4note);\n\tkfree(elf);\n\tkfree(psinfo);\n\tkfree(shdr4extnum);\n\treturn has_dumped;\n}\n\n#endif\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}