{
  "module_name": "dir.c",
  "hash_id": "cdf6ead5d6d8aef44bcd345f2b74bd123afb0df9a3000ffb8e53aa902b5f6fcb",
  "original_prompt": "Ingested from linux-6.6.14/fs/kernfs/dir.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/hash.h>\n\n#include \"kernfs-internal.h\"\n\nstatic DEFINE_RWLOCK(kernfs_rename_lock);\t \n \nstatic DEFINE_SPINLOCK(kernfs_pr_cont_lock);\nstatic char kernfs_pr_cont_buf[PATH_MAX];\t \nstatic DEFINE_SPINLOCK(kernfs_idr_lock);\t \n\n#define rb_to_kn(X) rb_entry((X), struct kernfs_node, rb)\n\nstatic bool __kernfs_active(struct kernfs_node *kn)\n{\n\treturn atomic_read(&kn->active) >= 0;\n}\n\nstatic bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_root(kn)->kernfs_rwsem);\n\treturn __kernfs_active(kn);\n}\n\nstatic bool kernfs_lockdep(struct kernfs_node *kn)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\treturn kn->flags & KERNFS_LOCKDEP;\n#else\n\treturn false;\n#endif\n}\n\nstatic int kernfs_name_locked(struct kernfs_node *kn, char *buf, size_t buflen)\n{\n\tif (!kn)\n\t\treturn strlcpy(buf, \"(null)\", buflen);\n\n\treturn strlcpy(buf, kn->parent ? kn->name : \"/\", buflen);\n}\n\n \nstatic size_t kernfs_depth(struct kernfs_node *from, struct kernfs_node *to)\n{\n\tsize_t depth = 0;\n\n\twhile (to->parent && to != from) {\n\t\tdepth++;\n\t\tto = to->parent;\n\t}\n\treturn depth;\n}\n\nstatic struct kernfs_node *kernfs_common_ancestor(struct kernfs_node *a,\n\t\t\t\t\t\t  struct kernfs_node *b)\n{\n\tsize_t da, db;\n\tstruct kernfs_root *ra = kernfs_root(a), *rb = kernfs_root(b);\n\n\tif (ra != rb)\n\t\treturn NULL;\n\n\tda = kernfs_depth(ra->kn, a);\n\tdb = kernfs_depth(rb->kn, b);\n\n\twhile (da > db) {\n\t\ta = a->parent;\n\t\tda--;\n\t}\n\twhile (db > da) {\n\t\tb = b->parent;\n\t\tdb--;\n\t}\n\n\t \n\twhile (b != a) {\n\t\tb = b->parent;\n\t\ta = a->parent;\n\t}\n\n\treturn a;\n}\n\n \nstatic int kernfs_path_from_node_locked(struct kernfs_node *kn_to,\n\t\t\t\t\tstruct kernfs_node *kn_from,\n\t\t\t\t\tchar *buf, size_t buflen)\n{\n\tstruct kernfs_node *kn, *common;\n\tconst char parent_str[] = \"/..\";\n\tsize_t depth_from, depth_to, len = 0;\n\tint i, j;\n\n\tif (!kn_to)\n\t\treturn strlcpy(buf, \"(null)\", buflen);\n\n\tif (!kn_from)\n\t\tkn_from = kernfs_root(kn_to)->kn;\n\n\tif (kn_from == kn_to)\n\t\treturn strlcpy(buf, \"/\", buflen);\n\n\tcommon = kernfs_common_ancestor(kn_from, kn_to);\n\tif (WARN_ON(!common))\n\t\treturn -EINVAL;\n\n\tdepth_to = kernfs_depth(common, kn_to);\n\tdepth_from = kernfs_depth(common, kn_from);\n\n\tbuf[0] = '\\0';\n\n\tfor (i = 0; i < depth_from; i++)\n\t\tlen += strlcpy(buf + len, parent_str,\n\t\t\t       len < buflen ? buflen - len : 0);\n\n\t \n\tfor (i = depth_to - 1; i >= 0; i--) {\n\t\tfor (kn = kn_to, j = 0; j < i; j++)\n\t\t\tkn = kn->parent;\n\t\tlen += strlcpy(buf + len, \"/\",\n\t\t\t       len < buflen ? buflen - len : 0);\n\t\tlen += strlcpy(buf + len, kn->name,\n\t\t\t       len < buflen ? buflen - len : 0);\n\t}\n\n\treturn len;\n}\n\n \nint kernfs_name(struct kernfs_node *kn, char *buf, size_t buflen)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tread_lock_irqsave(&kernfs_rename_lock, flags);\n\tret = kernfs_name_locked(kn, buf, buflen);\n\tread_unlock_irqrestore(&kernfs_rename_lock, flags);\n\treturn ret;\n}\n\n \nint kernfs_path_from_node(struct kernfs_node *to, struct kernfs_node *from,\n\t\t\t  char *buf, size_t buflen)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tread_lock_irqsave(&kernfs_rename_lock, flags);\n\tret = kernfs_path_from_node_locked(to, from, buf, buflen);\n\tread_unlock_irqrestore(&kernfs_rename_lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(kernfs_path_from_node);\n\n \nvoid pr_cont_kernfs_name(struct kernfs_node *kn)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kernfs_pr_cont_lock, flags);\n\n\tkernfs_name(kn, kernfs_pr_cont_buf, sizeof(kernfs_pr_cont_buf));\n\tpr_cont(\"%s\", kernfs_pr_cont_buf);\n\n\tspin_unlock_irqrestore(&kernfs_pr_cont_lock, flags);\n}\n\n \nvoid pr_cont_kernfs_path(struct kernfs_node *kn)\n{\n\tunsigned long flags;\n\tint sz;\n\n\tspin_lock_irqsave(&kernfs_pr_cont_lock, flags);\n\n\tsz = kernfs_path_from_node(kn, NULL, kernfs_pr_cont_buf,\n\t\t\t\t   sizeof(kernfs_pr_cont_buf));\n\tif (sz < 0) {\n\t\tpr_cont(\"(error)\");\n\t\tgoto out;\n\t}\n\n\tif (sz >= sizeof(kernfs_pr_cont_buf)) {\n\t\tpr_cont(\"(name too long)\");\n\t\tgoto out;\n\t}\n\n\tpr_cont(\"%s\", kernfs_pr_cont_buf);\n\nout:\n\tspin_unlock_irqrestore(&kernfs_pr_cont_lock, flags);\n}\n\n \nstruct kernfs_node *kernfs_get_parent(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tunsigned long flags;\n\n\tread_lock_irqsave(&kernfs_rename_lock, flags);\n\tparent = kn->parent;\n\tkernfs_get(parent);\n\tread_unlock_irqrestore(&kernfs_rename_lock, flags);\n\n\treturn parent;\n}\n\n \nstatic unsigned int kernfs_name_hash(const char *name, const void *ns)\n{\n\tunsigned long hash = init_name_hash(ns);\n\tunsigned int len = strlen(name);\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\thash = end_name_hash(hash);\n\thash &= 0x7fffffffU;\n\t \n\tif (hash < 2)\n\t\thash += 2;\n\tif (hash >= INT_MAX)\n\t\thash = INT_MAX - 1;\n\treturn hash;\n}\n\nstatic int kernfs_name_compare(unsigned int hash, const char *name,\n\t\t\t       const void *ns, const struct kernfs_node *kn)\n{\n\tif (hash < kn->hash)\n\t\treturn -1;\n\tif (hash > kn->hash)\n\t\treturn 1;\n\tif (ns < kn->ns)\n\t\treturn -1;\n\tif (ns > kn->ns)\n\t\treturn 1;\n\treturn strcmp(name, kn->name);\n}\n\nstatic int kernfs_sd_compare(const struct kernfs_node *left,\n\t\t\t     const struct kernfs_node *right)\n{\n\treturn kernfs_name_compare(left->hash, left->name, left->ns, right);\n}\n\n \nstatic int kernfs_link_sibling(struct kernfs_node *kn)\n{\n\tstruct rb_node **node = &kn->parent->dir.children.rb_node;\n\tstruct rb_node *parent = NULL;\n\n\twhile (*node) {\n\t\tstruct kernfs_node *pos;\n\t\tint result;\n\n\t\tpos = rb_to_kn(*node);\n\t\tparent = *node;\n\t\tresult = kernfs_sd_compare(kn, pos);\n\t\tif (result < 0)\n\t\t\tnode = &pos->rb.rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = &pos->rb.rb_right;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\t \n\trb_link_node(&kn->rb, parent, node);\n\trb_insert_color(&kn->rb, &kn->parent->dir.children);\n\n\t \n\tdown_write(&kernfs_root(kn)->kernfs_iattr_rwsem);\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tkn->parent->dir.subdirs++;\n\tkernfs_inc_rev(kn->parent);\n\tup_write(&kernfs_root(kn)->kernfs_iattr_rwsem);\n\n\treturn 0;\n}\n\n \nstatic bool kernfs_unlink_sibling(struct kernfs_node *kn)\n{\n\tif (RB_EMPTY_NODE(&kn->rb))\n\t\treturn false;\n\n\tdown_write(&kernfs_root(kn)->kernfs_iattr_rwsem);\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tkn->parent->dir.subdirs--;\n\tkernfs_inc_rev(kn->parent);\n\tup_write(&kernfs_root(kn)->kernfs_iattr_rwsem);\n\n\trb_erase(&kn->rb, &kn->parent->dir.children);\n\tRB_CLEAR_NODE(&kn->rb);\n\treturn true;\n}\n\n \nstruct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}\n\n \nvoid kernfs_put_active(struct kernfs_node *kn)\n{\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&kernfs_root(kn)->deactivate_waitq);\n}\n\n \nstatic void kernfs_drain(struct kernfs_node *kn)\n\t__releases(&kernfs_root(kn)->kernfs_rwsem)\n\t__acquires(&kernfs_root(kn)->kernfs_rwsem)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\n\tlockdep_assert_held_write(&root->kernfs_rwsem);\n\tWARN_ON_ONCE(kernfs_active(kn));\n\n\t \n\tif (atomic_read(&kn->active) == KN_DEACTIVATED_BIAS &&\n\t    !kernfs_should_drain_open_files(kn))\n\t\treturn;\n\n\tup_write(&root->kernfs_rwsem);\n\n\tif (kernfs_lockdep(kn)) {\n\t\trwsem_acquire(&kn->dep_map, 0, 0, _RET_IP_);\n\t\tif (atomic_read(&kn->active) != KN_DEACTIVATED_BIAS)\n\t\t\tlock_contended(&kn->dep_map, _RET_IP_);\n\t}\n\n\twait_event(root->deactivate_waitq,\n\t\t   atomic_read(&kn->active) == KN_DEACTIVATED_BIAS);\n\n\tif (kernfs_lockdep(kn)) {\n\t\tlock_acquired(&kn->dep_map, _RET_IP_);\n\t\trwsem_release(&kn->dep_map, _RET_IP_);\n\t}\n\n\tif (kernfs_should_drain_open_files(kn))\n\t\tkernfs_drain_open_files(kn);\n\n\tdown_write(&root->kernfs_rwsem);\n}\n\n \nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}\nEXPORT_SYMBOL_GPL(kernfs_get);\n\n \nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t \n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tsimple_xattrs_free(&kn->iattr->xattrs, NULL);\n\t\tkmem_cache_free(kernfs_iattrs_cache, kn->iattr);\n\t}\n\tspin_lock(&kernfs_idr_lock);\n\tidr_remove(&root->ino_idr, (u32)kernfs_ino(kn));\n\tspin_unlock(&kernfs_idr_lock);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t \n\t\tidr_destroy(&root->ino_idr);\n\t\tkfree(root);\n\t}\n}\nEXPORT_SYMBOL_GPL(kernfs_put);\n\n \nstruct kernfs_node *kernfs_node_from_dentry(struct dentry *dentry)\n{\n\tif (dentry->d_sb->s_op == &kernfs_sops)\n\t\treturn kernfs_dentry_node(dentry);\n\treturn NULL;\n}\n\nstatic struct kernfs_node *__kernfs_new_node(struct kernfs_root *root,\n\t\t\t\t\t     struct kernfs_node *parent,\n\t\t\t\t\t     const char *name, umode_t mode,\n\t\t\t\t\t     kuid_t uid, kgid_t gid,\n\t\t\t\t\t     unsigned flags)\n{\n\tstruct kernfs_node *kn;\n\tu32 id_highbits;\n\tint ret;\n\n\tname = kstrdup_const(name, GFP_KERNEL);\n\tif (!name)\n\t\treturn NULL;\n\n\tkn = kmem_cache_zalloc(kernfs_node_cache, GFP_KERNEL);\n\tif (!kn)\n\t\tgoto err_out1;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&kernfs_idr_lock);\n\tret = idr_alloc_cyclic(&root->ino_idr, kn, 1, 0, GFP_ATOMIC);\n\tif (ret >= 0 && ret < root->last_id_lowbits)\n\t\troot->id_highbits++;\n\tid_highbits = root->id_highbits;\n\troot->last_id_lowbits = ret;\n\tspin_unlock(&kernfs_idr_lock);\n\tidr_preload_end();\n\tif (ret < 0)\n\t\tgoto err_out2;\n\n\tkn->id = (u64)id_highbits << 32 | ret;\n\n\tatomic_set(&kn->count, 1);\n\tatomic_set(&kn->active, KN_DEACTIVATED_BIAS);\n\tRB_CLEAR_NODE(&kn->rb);\n\n\tkn->name = name;\n\tkn->mode = mode;\n\tkn->flags = flags;\n\n\tif (!uid_eq(uid, GLOBAL_ROOT_UID) || !gid_eq(gid, GLOBAL_ROOT_GID)) {\n\t\tstruct iattr iattr = {\n\t\t\t.ia_valid = ATTR_UID | ATTR_GID,\n\t\t\t.ia_uid = uid,\n\t\t\t.ia_gid = gid,\n\t\t};\n\n\t\tret = __kernfs_setattr(kn, &iattr);\n\t\tif (ret < 0)\n\t\t\tgoto err_out3;\n\t}\n\n\tif (parent) {\n\t\tret = security_kernfs_init_security(parent, kn);\n\t\tif (ret)\n\t\t\tgoto err_out3;\n\t}\n\n\treturn kn;\n\n err_out3:\n\tspin_lock(&kernfs_idr_lock);\n\tidr_remove(&root->ino_idr, (u32)kernfs_ino(kn));\n\tspin_unlock(&kernfs_idr_lock);\n err_out2:\n\tkmem_cache_free(kernfs_node_cache, kn);\n err_out1:\n\tkfree_const(name);\n\treturn NULL;\n}\n\nstruct kernfs_node *kernfs_new_node(struct kernfs_node *parent,\n\t\t\t\t    const char *name, umode_t mode,\n\t\t\t\t    kuid_t uid, kgid_t gid,\n\t\t\t\t    unsigned flags)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = __kernfs_new_node(kernfs_root(parent), parent,\n\t\t\t       name, mode, uid, gid, flags);\n\tif (kn) {\n\t\tkernfs_get(parent);\n\t\tkn->parent = parent;\n\t}\n\treturn kn;\n}\n\n \nstruct kernfs_node *kernfs_find_and_get_node_by_id(struct kernfs_root *root,\n\t\t\t\t\t\t   u64 id)\n{\n\tstruct kernfs_node *kn;\n\tino_t ino = kernfs_id_ino(id);\n\tu32 gen = kernfs_id_gen(id);\n\n\tspin_lock(&kernfs_idr_lock);\n\n\tkn = idr_find(&root->ino_idr, (u32)ino);\n\tif (!kn)\n\t\tgoto err_unlock;\n\n\tif (sizeof(ino_t) >= sizeof(u64)) {\n\t\t \n\t\tif (kernfs_ino(kn) != ino)\n\t\t\tgoto err_unlock;\n\t} else {\n\t\t \n\t\tif (unlikely(gen && kernfs_gen(kn) != gen))\n\t\t\tgoto err_unlock;\n\t}\n\n\t \n\tif (unlikely(!__kernfs_active(kn) || !atomic_inc_not_zero(&kn->count)))\n\t\tgoto err_unlock;\n\n\tspin_unlock(&kernfs_idr_lock);\n\treturn kn;\nerr_unlock:\n\tspin_unlock(&kernfs_idr_lock);\n\treturn NULL;\n}\n\n \nint kernfs_add_one(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent = kn->parent;\n\tstruct kernfs_root *root = kernfs_root(parent);\n\tstruct kernfs_iattrs *ps_iattr;\n\tbool has_ns;\n\tint ret;\n\n\tdown_write(&root->kernfs_rwsem);\n\n\tret = -EINVAL;\n\thas_ns = kernfs_ns_enabled(parent);\n\tif (WARN(has_ns != (bool)kn->ns, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t has_ns ? \"required\" : \"invalid\", parent->name, kn->name))\n\t\tgoto out_unlock;\n\n\tif (kernfs_type(parent) != KERNFS_DIR)\n\t\tgoto out_unlock;\n\n\tret = -ENOENT;\n\tif (parent->flags & (KERNFS_REMOVING | KERNFS_EMPTY_DIR))\n\t\tgoto out_unlock;\n\n\tkn->hash = kernfs_name_hash(kn->name, kn->ns);\n\n\tret = kernfs_link_sibling(kn);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tdown_write(&root->kernfs_iattr_rwsem);\n\n\tps_iattr = parent->iattr;\n\tif (ps_iattr) {\n\t\tktime_get_real_ts64(&ps_iattr->ia_ctime);\n\t\tps_iattr->ia_mtime = ps_iattr->ia_ctime;\n\t}\n\n\tup_write(&root->kernfs_iattr_rwsem);\n\tup_write(&root->kernfs_rwsem);\n\n\t \n\tif (!(kernfs_root(kn)->flags & KERNFS_ROOT_CREATE_DEACTIVATED))\n\t\tkernfs_activate(kn);\n\treturn 0;\n\nout_unlock:\n\tup_write(&root->kernfs_rwsem);\n\treturn ret;\n}\n\n \nstatic struct kernfs_node *kernfs_find_ns(struct kernfs_node *parent,\n\t\t\t\t\t  const unsigned char *name,\n\t\t\t\t\t  const void *ns)\n{\n\tstruct rb_node *node = parent->dir.children.rb_node;\n\tbool has_ns = kernfs_ns_enabled(parent);\n\tunsigned int hash;\n\n\tlockdep_assert_held(&kernfs_root(parent)->kernfs_rwsem);\n\n\tif (has_ns != (bool)ns) {\n\t\tWARN(1, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t     has_ns ? \"required\" : \"invalid\", parent->name, name);\n\t\treturn NULL;\n\t}\n\n\thash = kernfs_name_hash(name, ns);\n\twhile (node) {\n\t\tstruct kernfs_node *kn;\n\t\tint result;\n\n\t\tkn = rb_to_kn(node);\n\t\tresult = kernfs_name_compare(hash, name, ns, kn);\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn kn;\n\t}\n\treturn NULL;\n}\n\nstatic struct kernfs_node *kernfs_walk_ns(struct kernfs_node *parent,\n\t\t\t\t\t  const unsigned char *path,\n\t\t\t\t\t  const void *ns)\n{\n\tsize_t len;\n\tchar *p, *name;\n\n\tlockdep_assert_held_read(&kernfs_root(parent)->kernfs_rwsem);\n\n\tspin_lock_irq(&kernfs_pr_cont_lock);\n\n\tlen = strlcpy(kernfs_pr_cont_buf, path, sizeof(kernfs_pr_cont_buf));\n\n\tif (len >= sizeof(kernfs_pr_cont_buf)) {\n\t\tspin_unlock_irq(&kernfs_pr_cont_lock);\n\t\treturn NULL;\n\t}\n\n\tp = kernfs_pr_cont_buf;\n\n\twhile ((name = strsep(&p, \"/\")) && parent) {\n\t\tif (*name == '\\0')\n\t\t\tcontinue;\n\t\tparent = kernfs_find_ns(parent, name, ns);\n\t}\n\n\tspin_unlock_irq(&kernfs_pr_cont_lock);\n\n\treturn parent;\n}\n\n \nstruct kernfs_node *kernfs_find_and_get_ns(struct kernfs_node *parent,\n\t\t\t\t\t   const char *name, const void *ns)\n{\n\tstruct kernfs_node *kn;\n\tstruct kernfs_root *root = kernfs_root(parent);\n\n\tdown_read(&root->kernfs_rwsem);\n\tkn = kernfs_find_ns(parent, name, ns);\n\tkernfs_get(kn);\n\tup_read(&root->kernfs_rwsem);\n\n\treturn kn;\n}\nEXPORT_SYMBOL_GPL(kernfs_find_and_get_ns);\n\n \nstruct kernfs_node *kernfs_walk_and_get_ns(struct kernfs_node *parent,\n\t\t\t\t\t   const char *path, const void *ns)\n{\n\tstruct kernfs_node *kn;\n\tstruct kernfs_root *root = kernfs_root(parent);\n\n\tdown_read(&root->kernfs_rwsem);\n\tkn = kernfs_walk_ns(parent, path, ns);\n\tkernfs_get(kn);\n\tup_read(&root->kernfs_rwsem);\n\n\treturn kn;\n}\n\n \nstruct kernfs_root *kernfs_create_root(struct kernfs_syscall_ops *scops,\n\t\t\t\t       unsigned int flags, void *priv)\n{\n\tstruct kernfs_root *root;\n\tstruct kernfs_node *kn;\n\n\troot = kzalloc(sizeof(*root), GFP_KERNEL);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tidr_init(&root->ino_idr);\n\tinit_rwsem(&root->kernfs_rwsem);\n\tinit_rwsem(&root->kernfs_iattr_rwsem);\n\tinit_rwsem(&root->kernfs_supers_rwsem);\n\tINIT_LIST_HEAD(&root->supers);\n\n\t \n\tif (sizeof(ino_t) >= sizeof(u64))\n\t\troot->id_highbits = 0;\n\telse\n\t\troot->id_highbits = 1;\n\n\tkn = __kernfs_new_node(root, NULL, \"\", S_IFDIR | S_IRUGO | S_IXUGO,\n\t\t\t       GLOBAL_ROOT_UID, GLOBAL_ROOT_GID,\n\t\t\t       KERNFS_DIR);\n\tif (!kn) {\n\t\tidr_destroy(&root->ino_idr);\n\t\tkfree(root);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tkn->priv = priv;\n\tkn->dir.root = root;\n\n\troot->syscall_ops = scops;\n\troot->flags = flags;\n\troot->kn = kn;\n\tinit_waitqueue_head(&root->deactivate_waitq);\n\n\tif (!(root->flags & KERNFS_ROOT_CREATE_DEACTIVATED))\n\t\tkernfs_activate(kn);\n\n\treturn root;\n}\n\n \nvoid kernfs_destroy_root(struct kernfs_root *root)\n{\n\t \n\tkernfs_get(root->kn);\n\tkernfs_remove(root->kn);\n\tkernfs_put(root->kn);  \n}\n\n \nstruct kernfs_node *kernfs_root_to_node(struct kernfs_root *root)\n{\n\treturn root->kn;\n}\n\n \nstruct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,\n\t\t\t\t\t const char *name, umode_t mode,\n\t\t\t\t\t kuid_t uid, kgid_t gid,\n\t\t\t\t\t void *priv, const void *ns)\n{\n\tstruct kernfs_node *kn;\n\tint rc;\n\n\t \n\tkn = kernfs_new_node(parent, name, mode | S_IFDIR,\n\t\t\t     uid, gid, KERNFS_DIR);\n\tif (!kn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkn->dir.root = parent->dir.root;\n\tkn->ns = ns;\n\tkn->priv = priv;\n\n\t \n\trc = kernfs_add_one(kn);\n\tif (!rc)\n\t\treturn kn;\n\n\tkernfs_put(kn);\n\treturn ERR_PTR(rc);\n}\n\n \nstruct kernfs_node *kernfs_create_empty_dir(struct kernfs_node *parent,\n\t\t\t\t\t    const char *name)\n{\n\tstruct kernfs_node *kn;\n\tint rc;\n\n\t \n\tkn = kernfs_new_node(parent, name, S_IRUGO|S_IXUGO|S_IFDIR,\n\t\t\t     GLOBAL_ROOT_UID, GLOBAL_ROOT_GID, KERNFS_DIR);\n\tif (!kn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkn->flags |= KERNFS_EMPTY_DIR;\n\tkn->dir.root = parent->dir.root;\n\tkn->ns = NULL;\n\tkn->priv = NULL;\n\n\t \n\trc = kernfs_add_one(kn);\n\tif (!rc)\n\t\treturn kn;\n\n\tkernfs_put(kn);\n\treturn ERR_PTR(rc);\n}\n\nstatic int kernfs_dop_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct kernfs_node *kn;\n\tstruct kernfs_root *root;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\t \n\tif (d_really_is_negative(dentry)) {\n\t\tstruct kernfs_node *parent;\n\n\t\t \n\t\troot = kernfs_root_from_sb(dentry->d_sb);\n\t\tdown_read(&root->kernfs_rwsem);\n\t\tparent = kernfs_dentry_node(dentry->d_parent);\n\t\tif (parent) {\n\t\t\tif (kernfs_dir_changed(parent, dentry)) {\n\t\t\t\tup_read(&root->kernfs_rwsem);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tup_read(&root->kernfs_rwsem);\n\n\t\t \n\t\treturn 1;\n\t}\n\n\tkn = kernfs_dentry_node(dentry);\n\troot = kernfs_root(kn);\n\tdown_read(&root->kernfs_rwsem);\n\n\t \n\tif (!kernfs_active(kn))\n\t\tgoto out_bad;\n\n\t \n\tif (kernfs_dentry_node(dentry->d_parent) != kn->parent)\n\t\tgoto out_bad;\n\n\t \n\tif (strcmp(dentry->d_name.name, kn->name) != 0)\n\t\tgoto out_bad;\n\n\t \n\tif (kn->parent && kernfs_ns_enabled(kn->parent) &&\n\t    kernfs_info(dentry->d_sb)->ns != kn->ns)\n\t\tgoto out_bad;\n\n\tup_read(&root->kernfs_rwsem);\n\treturn 1;\nout_bad:\n\tup_read(&root->kernfs_rwsem);\n\treturn 0;\n}\n\nconst struct dentry_operations kernfs_dops = {\n\t.d_revalidate\t= kernfs_dop_revalidate,\n};\n\nstatic struct dentry *kernfs_iop_lookup(struct inode *dir,\n\t\t\t\t\tstruct dentry *dentry,\n\t\t\t\t\tunsigned int flags)\n{\n\tstruct kernfs_node *parent = dir->i_private;\n\tstruct kernfs_node *kn;\n\tstruct kernfs_root *root;\n\tstruct inode *inode = NULL;\n\tconst void *ns = NULL;\n\n\troot = kernfs_root(parent);\n\tdown_read(&root->kernfs_rwsem);\n\tif (kernfs_ns_enabled(parent))\n\t\tns = kernfs_info(dir->i_sb)->ns;\n\n\tkn = kernfs_find_ns(parent, dentry->d_name.name, ns);\n\t \n\tif (kn) {\n\t\t \n\t\tif (!kernfs_active(kn)) {\n\t\t\tup_read(&root->kernfs_rwsem);\n\t\t\treturn NULL;\n\t\t}\n\t\tinode = kernfs_get_inode(dir->i_sb, kn);\n\t\tif (!inode)\n\t\t\tinode = ERR_PTR(-ENOMEM);\n\t}\n\t \n\tif (!IS_ERR(inode))\n\t\tkernfs_set_rev(parent, dentry);\n\tup_read(&root->kernfs_rwsem);\n\n\t \n\treturn d_splice_alias(inode, dentry);\n}\n\nstatic int kernfs_iop_mkdir(struct mnt_idmap *idmap,\n\t\t\t    struct inode *dir, struct dentry *dentry,\n\t\t\t    umode_t mode)\n{\n\tstruct kernfs_node *parent = dir->i_private;\n\tstruct kernfs_syscall_ops *scops = kernfs_root(parent)->syscall_ops;\n\tint ret;\n\n\tif (!scops || !scops->mkdir)\n\t\treturn -EPERM;\n\n\tif (!kernfs_get_active(parent))\n\t\treturn -ENODEV;\n\n\tret = scops->mkdir(parent, dentry->d_name.name, mode);\n\n\tkernfs_put_active(parent);\n\treturn ret;\n}\n\nstatic int kernfs_iop_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct kernfs_node *kn  = kernfs_dentry_node(dentry);\n\tstruct kernfs_syscall_ops *scops = kernfs_root(kn)->syscall_ops;\n\tint ret;\n\n\tif (!scops || !scops->rmdir)\n\t\treturn -EPERM;\n\n\tif (!kernfs_get_active(kn))\n\t\treturn -ENODEV;\n\n\tret = scops->rmdir(kn);\n\n\tkernfs_put_active(kn);\n\treturn ret;\n}\n\nstatic int kernfs_iop_rename(struct mnt_idmap *idmap,\n\t\t\t     struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry,\n\t\t\t     unsigned int flags)\n{\n\tstruct kernfs_node *kn = kernfs_dentry_node(old_dentry);\n\tstruct kernfs_node *new_parent = new_dir->i_private;\n\tstruct kernfs_syscall_ops *scops = kernfs_root(kn)->syscall_ops;\n\tint ret;\n\n\tif (flags)\n\t\treturn -EINVAL;\n\n\tif (!scops || !scops->rename)\n\t\treturn -EPERM;\n\n\tif (!kernfs_get_active(kn))\n\t\treturn -ENODEV;\n\n\tif (!kernfs_get_active(new_parent)) {\n\t\tkernfs_put_active(kn);\n\t\treturn -ENODEV;\n\t}\n\n\tret = scops->rename(kn, new_parent, new_dentry->d_name.name);\n\n\tkernfs_put_active(new_parent);\n\tkernfs_put_active(kn);\n\treturn ret;\n}\n\nconst struct inode_operations kernfs_dir_iops = {\n\t.lookup\t\t= kernfs_iop_lookup,\n\t.permission\t= kernfs_iop_permission,\n\t.setattr\t= kernfs_iop_setattr,\n\t.getattr\t= kernfs_iop_getattr,\n\t.listxattr\t= kernfs_iop_listxattr,\n\n\t.mkdir\t\t= kernfs_iop_mkdir,\n\t.rmdir\t\t= kernfs_iop_rmdir,\n\t.rename\t\t= kernfs_iop_rename,\n};\n\nstatic struct kernfs_node *kernfs_leftmost_descendant(struct kernfs_node *pos)\n{\n\tstruct kernfs_node *last;\n\n\twhile (true) {\n\t\tstruct rb_node *rbn;\n\n\t\tlast = pos;\n\n\t\tif (kernfs_type(pos) != KERNFS_DIR)\n\t\t\tbreak;\n\n\t\trbn = rb_first(&pos->dir.children);\n\t\tif (!rbn)\n\t\t\tbreak;\n\n\t\tpos = rb_to_kn(rbn);\n\t}\n\n\treturn last;\n}\n\n \nstatic struct kernfs_node *kernfs_next_descendant_post(struct kernfs_node *pos,\n\t\t\t\t\t\t       struct kernfs_node *root)\n{\n\tstruct rb_node *rbn;\n\n\tlockdep_assert_held_write(&kernfs_root(root)->kernfs_rwsem);\n\n\t \n\tif (!pos)\n\t\treturn kernfs_leftmost_descendant(root);\n\n\t \n\tif (pos == root)\n\t\treturn NULL;\n\n\t \n\trbn = rb_next(&pos->rb);\n\tif (rbn)\n\t\treturn kernfs_leftmost_descendant(rb_to_kn(rbn));\n\n\t \n\treturn pos->parent;\n}\n\nstatic void kernfs_activate_one(struct kernfs_node *kn)\n{\n\tlockdep_assert_held_write(&kernfs_root(kn)->kernfs_rwsem);\n\n\tkn->flags |= KERNFS_ACTIVATED;\n\n\tif (kernfs_active(kn) || (kn->flags & (KERNFS_HIDDEN | KERNFS_REMOVING)))\n\t\treturn;\n\n\tWARN_ON_ONCE(kn->parent && RB_EMPTY_NODE(&kn->rb));\n\tWARN_ON_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS);\n\n\tatomic_sub(KN_DEACTIVATED_BIAS, &kn->active);\n}\n\n \nvoid kernfs_activate(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *pos;\n\tstruct kernfs_root *root = kernfs_root(kn);\n\n\tdown_write(&root->kernfs_rwsem);\n\n\tpos = NULL;\n\twhile ((pos = kernfs_next_descendant_post(pos, kn)))\n\t\tkernfs_activate_one(pos);\n\n\tup_write(&root->kernfs_rwsem);\n}\n\n \nvoid kernfs_show(struct kernfs_node *kn, bool show)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\n\tif (WARN_ON_ONCE(kernfs_type(kn) == KERNFS_DIR))\n\t\treturn;\n\n\tdown_write(&root->kernfs_rwsem);\n\n\tif (show) {\n\t\tkn->flags &= ~KERNFS_HIDDEN;\n\t\tif (kn->flags & KERNFS_ACTIVATED)\n\t\t\tkernfs_activate_one(kn);\n\t} else {\n\t\tkn->flags |= KERNFS_HIDDEN;\n\t\tif (kernfs_active(kn))\n\t\t\tatomic_add(KN_DEACTIVATED_BIAS, &kn->active);\n\t\tkernfs_drain(kn);\n\t}\n\n\tup_write(&root->kernfs_rwsem);\n}\n\nstatic void __kernfs_remove(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *pos;\n\n\t \n\tif (!kn)\n\t\treturn;\n\n\tlockdep_assert_held_write(&kernfs_root(kn)->kernfs_rwsem);\n\n\t \n\tif (kn->parent && RB_EMPTY_NODE(&kn->rb))\n\t\treturn;\n\n\tpr_debug(\"kernfs %s: removing\\n\", kn->name);\n\n\t \n\tpos = NULL;\n\twhile ((pos = kernfs_next_descendant_post(pos, kn))) {\n\t\tpos->flags |= KERNFS_REMOVING;\n\t\tif (kernfs_active(pos))\n\t\t\tatomic_add(KN_DEACTIVATED_BIAS, &pos->active);\n\t}\n\n\t \n\tdo {\n\t\tpos = kernfs_leftmost_descendant(kn);\n\n\t\t \n\t\tkernfs_get(pos);\n\n\t\tkernfs_drain(pos);\n\n\t\t \n\t\tif (!pos->parent || kernfs_unlink_sibling(pos)) {\n\t\t\tstruct kernfs_iattrs *ps_iattr =\n\t\t\t\tpos->parent ? pos->parent->iattr : NULL;\n\n\t\t\t \n\t\t\tdown_write(&kernfs_root(kn)->kernfs_iattr_rwsem);\n\n\t\t\tif (ps_iattr) {\n\t\t\t\tktime_get_real_ts64(&ps_iattr->ia_ctime);\n\t\t\t\tps_iattr->ia_mtime = ps_iattr->ia_ctime;\n\t\t\t}\n\n\t\t\tup_write(&kernfs_root(kn)->kernfs_iattr_rwsem);\n\t\t\tkernfs_put(pos);\n\t\t}\n\n\t\tkernfs_put(pos);\n\t} while (pos != kn);\n}\n\n \nvoid kernfs_remove(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root;\n\n\tif (!kn)\n\t\treturn;\n\n\troot = kernfs_root(kn);\n\n\tdown_write(&root->kernfs_rwsem);\n\t__kernfs_remove(kn);\n\tup_write(&root->kernfs_rwsem);\n}\n\n \nvoid kernfs_break_active_protection(struct kernfs_node *kn)\n{\n\t \n\tkernfs_put_active(kn);\n}\n\n \nvoid kernfs_unbreak_active_protection(struct kernfs_node *kn)\n{\n\t \n\tatomic_inc(&kn->active);\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire(&kn->dep_map, 0, 1, _RET_IP_);\n}\n\n \nbool kernfs_remove_self(struct kernfs_node *kn)\n{\n\tbool ret;\n\tstruct kernfs_root *root = kernfs_root(kn);\n\n\tdown_write(&root->kernfs_rwsem);\n\tkernfs_break_active_protection(kn);\n\n\t \n\tif (!(kn->flags & KERNFS_SUICIDAL)) {\n\t\tkn->flags |= KERNFS_SUICIDAL;\n\t\t__kernfs_remove(kn);\n\t\tkn->flags |= KERNFS_SUICIDED;\n\t\tret = true;\n\t} else {\n\t\twait_queue_head_t *waitq = &kernfs_root(kn)->deactivate_waitq;\n\t\tDEFINE_WAIT(wait);\n\n\t\twhile (true) {\n\t\t\tprepare_to_wait(waitq, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\t\tif ((kn->flags & KERNFS_SUICIDED) &&\n\t\t\t    atomic_read(&kn->active) == KN_DEACTIVATED_BIAS)\n\t\t\t\tbreak;\n\n\t\t\tup_write(&root->kernfs_rwsem);\n\t\t\tschedule();\n\t\t\tdown_write(&root->kernfs_rwsem);\n\t\t}\n\t\tfinish_wait(waitq, &wait);\n\t\tWARN_ON_ONCE(!RB_EMPTY_NODE(&kn->rb));\n\t\tret = false;\n\t}\n\n\t \n\tkernfs_unbreak_active_protection(kn);\n\n\tup_write(&root->kernfs_rwsem);\n\treturn ret;\n}\n\n \nint kernfs_remove_by_name_ns(struct kernfs_node *parent, const char *name,\n\t\t\t     const void *ns)\n{\n\tstruct kernfs_node *kn;\n\tstruct kernfs_root *root;\n\n\tif (!parent) {\n\t\tWARN(1, KERN_WARNING \"kernfs: can not remove '%s', no directory\\n\",\n\t\t\tname);\n\t\treturn -ENOENT;\n\t}\n\n\troot = kernfs_root(parent);\n\tdown_write(&root->kernfs_rwsem);\n\n\tkn = kernfs_find_ns(parent, name, ns);\n\tif (kn) {\n\t\tkernfs_get(kn);\n\t\t__kernfs_remove(kn);\n\t\tkernfs_put(kn);\n\t}\n\n\tup_write(&root->kernfs_rwsem);\n\n\tif (kn)\n\t\treturn 0;\n\telse\n\t\treturn -ENOENT;\n}\n\n \nint kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,\n\t\t     const char *new_name, const void *new_ns)\n{\n\tstruct kernfs_node *old_parent;\n\tstruct kernfs_root *root;\n\tconst char *old_name = NULL;\n\tint error;\n\n\t \n\tif (!kn->parent)\n\t\treturn -EINVAL;\n\n\troot = kernfs_root(kn);\n\tdown_write(&root->kernfs_rwsem);\n\n\terror = -ENOENT;\n\tif (!kernfs_active(kn) || !kernfs_active(new_parent) ||\n\t    (new_parent->flags & KERNFS_EMPTY_DIR))\n\t\tgoto out;\n\n\terror = 0;\n\tif ((kn->parent == new_parent) && (kn->ns == new_ns) &&\n\t    (strcmp(kn->name, new_name) == 0))\n\t\tgoto out;\t \n\n\terror = -EEXIST;\n\tif (kernfs_find_ns(new_parent, new_name, new_ns))\n\t\tgoto out;\n\n\t \n\tif (strcmp(kn->name, new_name) != 0) {\n\t\terror = -ENOMEM;\n\t\tnew_name = kstrdup_const(new_name, GFP_KERNEL);\n\t\tif (!new_name)\n\t\t\tgoto out;\n\t} else {\n\t\tnew_name = NULL;\n\t}\n\n\t \n\tkernfs_unlink_sibling(kn);\n\tkernfs_get(new_parent);\n\n\t \n\twrite_lock_irq(&kernfs_rename_lock);\n\n\told_parent = kn->parent;\n\tkn->parent = new_parent;\n\n\tkn->ns = new_ns;\n\tif (new_name) {\n\t\told_name = kn->name;\n\t\tkn->name = new_name;\n\t}\n\n\twrite_unlock_irq(&kernfs_rename_lock);\n\n\tkn->hash = kernfs_name_hash(kn->name, kn->ns);\n\tkernfs_link_sibling(kn);\n\n\tkernfs_put(old_parent);\n\tkfree_const(old_name);\n\n\terror = 0;\n out:\n\tup_write(&root->kernfs_rwsem);\n\treturn error;\n}\n\nstatic int kernfs_dir_fop_release(struct inode *inode, struct file *filp)\n{\n\tkernfs_put(filp->private_data);\n\treturn 0;\n}\n\nstatic struct kernfs_node *kernfs_dir_pos(const void *ns,\n\tstruct kernfs_node *parent, loff_t hash, struct kernfs_node *pos)\n{\n\tif (pos) {\n\t\tint valid = kernfs_active(pos) &&\n\t\t\tpos->parent == parent && hash == pos->hash;\n\t\tkernfs_put(pos);\n\t\tif (!valid)\n\t\t\tpos = NULL;\n\t}\n\tif (!pos && (hash > 1) && (hash < INT_MAX)) {\n\t\tstruct rb_node *node = parent->dir.children.rb_node;\n\t\twhile (node) {\n\t\t\tpos = rb_to_kn(node);\n\n\t\t\tif (hash < pos->hash)\n\t\t\t\tnode = node->rb_left;\n\t\t\telse if (hash > pos->hash)\n\t\t\t\tnode = node->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t \n\twhile (pos && (!kernfs_active(pos) || pos->ns != ns)) {\n\t\tstruct rb_node *node = rb_next(&pos->rb);\n\t\tif (!node)\n\t\t\tpos = NULL;\n\t\telse\n\t\t\tpos = rb_to_kn(node);\n\t}\n\treturn pos;\n}\n\nstatic struct kernfs_node *kernfs_dir_next_pos(const void *ns,\n\tstruct kernfs_node *parent, ino_t ino, struct kernfs_node *pos)\n{\n\tpos = kernfs_dir_pos(ns, parent, ino, pos);\n\tif (pos) {\n\t\tdo {\n\t\t\tstruct rb_node *node = rb_next(&pos->rb);\n\t\t\tif (!node)\n\t\t\t\tpos = NULL;\n\t\t\telse\n\t\t\t\tpos = rb_to_kn(node);\n\t\t} while (pos && (!kernfs_active(pos) || pos->ns != ns));\n\t}\n\treturn pos;\n}\n\nstatic int kernfs_fop_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct kernfs_node *parent = kernfs_dentry_node(dentry);\n\tstruct kernfs_node *pos = file->private_data;\n\tstruct kernfs_root *root;\n\tconst void *ns = NULL;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\troot = kernfs_root(parent);\n\tdown_read(&root->kernfs_rwsem);\n\n\tif (kernfs_ns_enabled(parent))\n\t\tns = kernfs_info(dentry->d_sb)->ns;\n\n\tfor (pos = kernfs_dir_pos(ns, parent, ctx->pos, pos);\n\t     pos;\n\t     pos = kernfs_dir_next_pos(ns, parent, ctx->pos, pos)) {\n\t\tconst char *name = pos->name;\n\t\tunsigned int type = fs_umode_to_dtype(pos->mode);\n\t\tint len = strlen(name);\n\t\tino_t ino = kernfs_ino(pos);\n\n\t\tctx->pos = pos->hash;\n\t\tfile->private_data = pos;\n\t\tkernfs_get(pos);\n\n\t\tup_read(&root->kernfs_rwsem);\n\t\tif (!dir_emit(ctx, name, len, ino, type))\n\t\t\treturn 0;\n\t\tdown_read(&root->kernfs_rwsem);\n\t}\n\tup_read(&root->kernfs_rwsem);\n\tfile->private_data = NULL;\n\tctx->pos = INT_MAX;\n\treturn 0;\n}\n\nconst struct file_operations kernfs_dir_fops = {\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= kernfs_fop_readdir,\n\t.release\t= kernfs_dir_fop_release,\n\t.llseek\t\t= generic_file_llseek,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}