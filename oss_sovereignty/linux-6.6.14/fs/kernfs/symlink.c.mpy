{
  "module_name": "symlink.c",
  "hash_id": "0ceeda0e998fa9af7c68358c707d668c111cdccf22216a166f06bba5d2c5a5ce",
  "original_prompt": "Ingested from linux-6.6.14/fs/kernfs/symlink.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/namei.h>\n\n#include \"kernfs-internal.h\"\n\n \nstruct kernfs_node *kernfs_create_link(struct kernfs_node *parent,\n\t\t\t\t       const char *name,\n\t\t\t\t       struct kernfs_node *target)\n{\n\tstruct kernfs_node *kn;\n\tint error;\n\tkuid_t uid = GLOBAL_ROOT_UID;\n\tkgid_t gid = GLOBAL_ROOT_GID;\n\n\tif (target->iattr) {\n\t\tuid = target->iattr->ia_uid;\n\t\tgid = target->iattr->ia_gid;\n\t}\n\n\tkn = kernfs_new_node(parent, name, S_IFLNK|0777, uid, gid, KERNFS_LINK);\n\tif (!kn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (kernfs_ns_enabled(parent))\n\t\tkn->ns = target->ns;\n\tkn->symlink.target_kn = target;\n\tkernfs_get(target);\t \n\n\terror = kernfs_add_one(kn);\n\tif (!error)\n\t\treturn kn;\n\n\tkernfs_put(kn);\n\treturn ERR_PTR(error);\n}\n\nstatic int kernfs_get_target_path(struct kernfs_node *parent,\n\t\t\t\t  struct kernfs_node *target, char *path)\n{\n\tstruct kernfs_node *base, *kn;\n\tchar *s = path;\n\tint len = 0;\n\n\t \n\tbase = parent;\n\twhile (base->parent) {\n\t\tkn = target->parent;\n\t\twhile (kn->parent && base != kn)\n\t\t\tkn = kn->parent;\n\n\t\tif (base == kn)\n\t\t\tbreak;\n\n\t\tif ((s - path) + 3 >= PATH_MAX)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\tstrcpy(s, \"../\");\n\t\ts += 3;\n\t\tbase = base->parent;\n\t}\n\n\t \n\tkn = target;\n\twhile (kn->parent && kn != base) {\n\t\tlen += strlen(kn->name) + 1;\n\t\tkn = kn->parent;\n\t}\n\n\t \n\tif (len < 2)\n\t\treturn -EINVAL;\n\tlen--;\n\tif ((s - path) + len >= PATH_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\t \n\tkn = target;\n\twhile (kn->parent && kn != base) {\n\t\tint slen = strlen(kn->name);\n\n\t\tlen -= slen;\n\t\tmemcpy(s + len, kn->name, slen);\n\t\tif (len)\n\t\t\ts[--len] = '/';\n\n\t\tkn = kn->parent;\n\t}\n\n\treturn 0;\n}\n\nstatic int kernfs_getlink(struct inode *inode, char *path)\n{\n\tstruct kernfs_node *kn = inode->i_private;\n\tstruct kernfs_node *parent = kn->parent;\n\tstruct kernfs_node *target = kn->symlink.target_kn;\n\tstruct kernfs_root *root = kernfs_root(parent);\n\tint error;\n\n\tdown_read(&root->kernfs_rwsem);\n\terror = kernfs_get_target_path(parent, target, path);\n\tup_read(&root->kernfs_rwsem);\n\n\treturn error;\n}\n\nstatic const char *kernfs_iop_get_link(struct dentry *dentry,\n\t\t\t\t       struct inode *inode,\n\t\t\t\t       struct delayed_call *done)\n{\n\tchar *body;\n\tint error;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\tbody = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!body)\n\t\treturn ERR_PTR(-ENOMEM);\n\terror = kernfs_getlink(inode, body);\n\tif (unlikely(error < 0)) {\n\t\tkfree(body);\n\t\treturn ERR_PTR(error);\n\t}\n\tset_delayed_call(done, kfree_link, body);\n\treturn body;\n}\n\nconst struct inode_operations kernfs_symlink_iops = {\n\t.listxattr\t= kernfs_iop_listxattr,\n\t.get_link\t= kernfs_iop_get_link,\n\t.setattr\t= kernfs_iop_setattr,\n\t.getattr\t= kernfs_iop_getattr,\n\t.permission\t= kernfs_iop_permission,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}