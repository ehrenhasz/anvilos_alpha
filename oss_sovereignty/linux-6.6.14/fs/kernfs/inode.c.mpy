{
  "module_name": "inode.c",
  "hash_id": "bc0145389d9a425469f347541c13d09fe16a7ad06af8524e27e65bfee5cee9c7",
  "original_prompt": "Ingested from linux-6.6.14/fs/kernfs/inode.c",
  "human_readable_source": "\n \n\n#include <linux/pagemap.h>\n#include <linux/backing-dev.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n\n#include \"kernfs-internal.h\"\n\nstatic const struct inode_operations kernfs_iops = {\n\t.permission\t= kernfs_iop_permission,\n\t.setattr\t= kernfs_iop_setattr,\n\t.getattr\t= kernfs_iop_getattr,\n\t.listxattr\t= kernfs_iop_listxattr,\n};\n\nstatic struct kernfs_iattrs *__kernfs_iattrs(struct kernfs_node *kn, int alloc)\n{\n\tstatic DEFINE_MUTEX(iattr_mutex);\n\tstruct kernfs_iattrs *ret;\n\n\tmutex_lock(&iattr_mutex);\n\n\tif (kn->iattr || !alloc)\n\t\tgoto out_unlock;\n\n\tkn->iattr = kmem_cache_zalloc(kernfs_iattrs_cache, GFP_KERNEL);\n\tif (!kn->iattr)\n\t\tgoto out_unlock;\n\n\t \n\tkn->iattr->ia_uid = GLOBAL_ROOT_UID;\n\tkn->iattr->ia_gid = GLOBAL_ROOT_GID;\n\n\tktime_get_real_ts64(&kn->iattr->ia_atime);\n\tkn->iattr->ia_mtime = kn->iattr->ia_atime;\n\tkn->iattr->ia_ctime = kn->iattr->ia_atime;\n\n\tsimple_xattrs_init(&kn->iattr->xattrs);\n\tatomic_set(&kn->iattr->nr_user_xattrs, 0);\n\tatomic_set(&kn->iattr->user_xattr_size, 0);\nout_unlock:\n\tret = kn->iattr;\n\tmutex_unlock(&iattr_mutex);\n\treturn ret;\n}\n\nstatic struct kernfs_iattrs *kernfs_iattrs(struct kernfs_node *kn)\n{\n\treturn __kernfs_iattrs(kn, 1);\n}\n\nstatic struct kernfs_iattrs *kernfs_iattrs_noalloc(struct kernfs_node *kn)\n{\n\treturn __kernfs_iattrs(kn, 0);\n}\n\nint __kernfs_setattr(struct kernfs_node *kn, const struct iattr *iattr)\n{\n\tstruct kernfs_iattrs *attrs;\n\tunsigned int ia_valid = iattr->ia_valid;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\tif (ia_valid & ATTR_UID)\n\t\tattrs->ia_uid = iattr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tattrs->ia_gid = iattr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tattrs->ia_atime = iattr->ia_atime;\n\tif (ia_valid & ATTR_MTIME)\n\t\tattrs->ia_mtime = iattr->ia_mtime;\n\tif (ia_valid & ATTR_CTIME)\n\t\tattrs->ia_ctime = iattr->ia_ctime;\n\tif (ia_valid & ATTR_MODE)\n\t\tkn->mode = iattr->ia_mode;\n\treturn 0;\n}\n\n \nint kernfs_setattr(struct kernfs_node *kn, const struct iattr *iattr)\n{\n\tint ret;\n\tstruct kernfs_root *root = kernfs_root(kn);\n\n\tdown_write(&root->kernfs_iattr_rwsem);\n\tret = __kernfs_setattr(kn, iattr);\n\tup_write(&root->kernfs_iattr_rwsem);\n\treturn ret;\n}\n\nint kernfs_iop_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t       struct iattr *iattr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct kernfs_node *kn = inode->i_private;\n\tstruct kernfs_root *root;\n\tint error;\n\n\tif (!kn)\n\t\treturn -EINVAL;\n\n\troot = kernfs_root(kn);\n\tdown_write(&root->kernfs_iattr_rwsem);\n\terror = setattr_prepare(&nop_mnt_idmap, dentry, iattr);\n\tif (error)\n\t\tgoto out;\n\n\terror = __kernfs_setattr(kn, iattr);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tsetattr_copy(&nop_mnt_idmap, inode, iattr);\n\nout:\n\tup_write(&root->kernfs_iattr_rwsem);\n\treturn error;\n}\n\nssize_t kernfs_iop_listxattr(struct dentry *dentry, char *buf, size_t size)\n{\n\tstruct kernfs_node *kn = kernfs_dentry_node(dentry);\n\tstruct kernfs_iattrs *attrs;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\treturn simple_xattr_list(d_inode(dentry), &attrs->xattrs, buf, size);\n}\n\nstatic inline void set_default_inode_attr(struct inode *inode, umode_t mode)\n{\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n}\n\nstatic inline void set_inode_attr(struct inode *inode,\n\t\t\t\t  struct kernfs_iattrs *attrs)\n{\n\tinode->i_uid = attrs->ia_uid;\n\tinode->i_gid = attrs->ia_gid;\n\tinode->i_atime = attrs->ia_atime;\n\tinode->i_mtime = attrs->ia_mtime;\n\tinode_set_ctime_to_ts(inode, attrs->ia_ctime);\n}\n\nstatic void kernfs_refresh_inode(struct kernfs_node *kn, struct inode *inode)\n{\n\tstruct kernfs_iattrs *attrs = kn->iattr;\n\n\tinode->i_mode = kn->mode;\n\tif (attrs)\n\t\t \n\t\tset_inode_attr(inode, attrs);\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tset_nlink(inode, kn->dir.subdirs + 2);\n}\n\nint kernfs_iop_getattr(struct mnt_idmap *idmap,\n\t\t       const struct path *path, struct kstat *stat,\n\t\t       u32 request_mask, unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct kernfs_node *kn = inode->i_private;\n\tstruct kernfs_root *root = kernfs_root(kn);\n\n\tdown_read(&root->kernfs_iattr_rwsem);\n\tkernfs_refresh_inode(kn, inode);\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\tup_read(&root->kernfs_iattr_rwsem);\n\n\treturn 0;\n}\n\nstatic void kernfs_init_inode(struct kernfs_node *kn, struct inode *inode)\n{\n\tkernfs_get(kn);\n\tinode->i_private = kn;\n\tinode->i_mapping->a_ops = &ram_aops;\n\tinode->i_op = &kernfs_iops;\n\tinode->i_generation = kernfs_gen(kn);\n\n\tset_default_inode_attr(inode, kn->mode);\n\tkernfs_refresh_inode(kn, inode);\n\n\t \n\tswitch (kernfs_type(kn)) {\n\tcase KERNFS_DIR:\n\t\tinode->i_op = &kernfs_dir_iops;\n\t\tinode->i_fop = &kernfs_dir_fops;\n\t\tif (kn->flags & KERNFS_EMPTY_DIR)\n\t\t\tmake_empty_dir_inode(inode);\n\t\tbreak;\n\tcase KERNFS_FILE:\n\t\tinode->i_size = kn->attr.size;\n\t\tinode->i_fop = &kernfs_file_fops;\n\t\tbreak;\n\tcase KERNFS_LINK:\n\t\tinode->i_op = &kernfs_symlink_iops;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tunlock_new_inode(inode);\n}\n\n \nstruct inode *kernfs_get_inode(struct super_block *sb, struct kernfs_node *kn)\n{\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, kernfs_ino(kn));\n\tif (inode && (inode->i_state & I_NEW))\n\t\tkernfs_init_inode(kn, inode);\n\n\treturn inode;\n}\n\n \nvoid kernfs_evict_inode(struct inode *inode)\n{\n\tstruct kernfs_node *kn = inode->i_private;\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tkernfs_put(kn);\n}\n\nint kernfs_iop_permission(struct mnt_idmap *idmap,\n\t\t\t  struct inode *inode, int mask)\n{\n\tstruct kernfs_node *kn;\n\tstruct kernfs_root *root;\n\tint ret;\n\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\tkn = inode->i_private;\n\troot = kernfs_root(kn);\n\n\tdown_read(&root->kernfs_iattr_rwsem);\n\tkernfs_refresh_inode(kn, inode);\n\tret = generic_permission(&nop_mnt_idmap, inode, mask);\n\tup_read(&root->kernfs_iattr_rwsem);\n\n\treturn ret;\n}\n\nint kernfs_xattr_get(struct kernfs_node *kn, const char *name,\n\t\t     void *value, size_t size)\n{\n\tstruct kernfs_iattrs *attrs = kernfs_iattrs_noalloc(kn);\n\tif (!attrs)\n\t\treturn -ENODATA;\n\n\treturn simple_xattr_get(&attrs->xattrs, name, value, size);\n}\n\nint kernfs_xattr_set(struct kernfs_node *kn, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tstruct simple_xattr *old_xattr;\n\tstruct kernfs_iattrs *attrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\told_xattr = simple_xattr_set(&attrs->xattrs, name, value, size, flags);\n\tif (IS_ERR(old_xattr))\n\t\treturn PTR_ERR(old_xattr);\n\n\tsimple_xattr_free(old_xattr);\n\treturn 0;\n}\n\nstatic int kernfs_vfs_xattr_get(const struct xattr_handler *handler,\n\t\t\t\tstruct dentry *unused, struct inode *inode,\n\t\t\t\tconst char *suffix, void *value, size_t size)\n{\n\tconst char *name = xattr_full_name(handler, suffix);\n\tstruct kernfs_node *kn = inode->i_private;\n\n\treturn kernfs_xattr_get(kn, name, value, size);\n}\n\nstatic int kernfs_vfs_xattr_set(const struct xattr_handler *handler,\n\t\t\t\tstruct mnt_idmap *idmap,\n\t\t\t\tstruct dentry *unused, struct inode *inode,\n\t\t\t\tconst char *suffix, const void *value,\n\t\t\t\tsize_t size, int flags)\n{\n\tconst char *name = xattr_full_name(handler, suffix);\n\tstruct kernfs_node *kn = inode->i_private;\n\n\treturn kernfs_xattr_set(kn, name, value, size, flags);\n}\n\nstatic int kernfs_vfs_user_xattr_add(struct kernfs_node *kn,\n\t\t\t\t     const char *full_name,\n\t\t\t\t     struct simple_xattrs *xattrs,\n\t\t\t\t     const void *value, size_t size, int flags)\n{\n\tatomic_t *sz = &kn->iattr->user_xattr_size;\n\tatomic_t *nr = &kn->iattr->nr_user_xattrs;\n\tstruct simple_xattr *old_xattr;\n\tint ret;\n\n\tif (atomic_inc_return(nr) > KERNFS_MAX_USER_XATTRS) {\n\t\tret = -ENOSPC;\n\t\tgoto dec_count_out;\n\t}\n\n\tif (atomic_add_return(size, sz) > KERNFS_USER_XATTR_SIZE_LIMIT) {\n\t\tret = -ENOSPC;\n\t\tgoto dec_size_out;\n\t}\n\n\told_xattr = simple_xattr_set(xattrs, full_name, value, size, flags);\n\tif (!old_xattr)\n\t\treturn 0;\n\n\tif (IS_ERR(old_xattr)) {\n\t\tret = PTR_ERR(old_xattr);\n\t\tgoto dec_size_out;\n\t}\n\n\tret = 0;\n\tsize = old_xattr->size;\n\tsimple_xattr_free(old_xattr);\ndec_size_out:\n\tatomic_sub(size, sz);\ndec_count_out:\n\tatomic_dec(nr);\n\treturn ret;\n}\n\nstatic int kernfs_vfs_user_xattr_rm(struct kernfs_node *kn,\n\t\t\t\t    const char *full_name,\n\t\t\t\t    struct simple_xattrs *xattrs,\n\t\t\t\t    const void *value, size_t size, int flags)\n{\n\tatomic_t *sz = &kn->iattr->user_xattr_size;\n\tatomic_t *nr = &kn->iattr->nr_user_xattrs;\n\tstruct simple_xattr *old_xattr;\n\n\told_xattr = simple_xattr_set(xattrs, full_name, value, size, flags);\n\tif (!old_xattr)\n\t\treturn 0;\n\n\tif (IS_ERR(old_xattr))\n\t\treturn PTR_ERR(old_xattr);\n\n\tatomic_sub(old_xattr->size, sz);\n\tatomic_dec(nr);\n\tsimple_xattr_free(old_xattr);\n\treturn 0;\n}\n\nstatic int kernfs_vfs_user_xattr_set(const struct xattr_handler *handler,\n\t\t\t\t     struct mnt_idmap *idmap,\n\t\t\t\t     struct dentry *unused, struct inode *inode,\n\t\t\t\t     const char *suffix, const void *value,\n\t\t\t\t     size_t size, int flags)\n{\n\tconst char *full_name = xattr_full_name(handler, suffix);\n\tstruct kernfs_node *kn = inode->i_private;\n\tstruct kernfs_iattrs *attrs;\n\n\tif (!(kernfs_root(kn)->flags & KERNFS_ROOT_SUPPORT_USER_XATTR))\n\t\treturn -EOPNOTSUPP;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\tif (value)\n\t\treturn kernfs_vfs_user_xattr_add(kn, full_name, &attrs->xattrs,\n\t\t\t\t\t\t value, size, flags);\n\telse\n\t\treturn kernfs_vfs_user_xattr_rm(kn, full_name, &attrs->xattrs,\n\t\t\t\t\t\tvalue, size, flags);\n\n}\n\nstatic const struct xattr_handler kernfs_trusted_xattr_handler = {\n\t.prefix = XATTR_TRUSTED_PREFIX,\n\t.get = kernfs_vfs_xattr_get,\n\t.set = kernfs_vfs_xattr_set,\n};\n\nstatic const struct xattr_handler kernfs_security_xattr_handler = {\n\t.prefix = XATTR_SECURITY_PREFIX,\n\t.get = kernfs_vfs_xattr_get,\n\t.set = kernfs_vfs_xattr_set,\n};\n\nstatic const struct xattr_handler kernfs_user_xattr_handler = {\n\t.prefix = XATTR_USER_PREFIX,\n\t.get = kernfs_vfs_xattr_get,\n\t.set = kernfs_vfs_user_xattr_set,\n};\n\nconst struct xattr_handler *kernfs_xattr_handlers[] = {\n\t&kernfs_trusted_xattr_handler,\n\t&kernfs_security_xattr_handler,\n\t&kernfs_user_xattr_handler,\n\tNULL\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}