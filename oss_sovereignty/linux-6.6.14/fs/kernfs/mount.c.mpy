{
  "module_name": "mount.c",
  "hash_id": "0fad44013fce436abc122fc49208ed7256bda84c469d1312b55d13986fd58810",
  "original_prompt": "Ingested from linux-6.6.14/fs/kernfs/mount.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/exportfs.h>\n#include <linux/uuid.h>\n#include <linux/statfs.h>\n\n#include \"kernfs-internal.h\"\n\nstruct kmem_cache *kernfs_node_cache, *kernfs_iattrs_cache;\nstruct kernfs_global_locks *kernfs_locks;\n\nstatic int kernfs_sop_show_options(struct seq_file *sf, struct dentry *dentry)\n{\n\tstruct kernfs_root *root = kernfs_root(kernfs_dentry_node(dentry));\n\tstruct kernfs_syscall_ops *scops = root->syscall_ops;\n\n\tif (scops && scops->show_options)\n\t\treturn scops->show_options(sf, root);\n\treturn 0;\n}\n\nstatic int kernfs_sop_show_path(struct seq_file *sf, struct dentry *dentry)\n{\n\tstruct kernfs_node *node = kernfs_dentry_node(dentry);\n\tstruct kernfs_root *root = kernfs_root(node);\n\tstruct kernfs_syscall_ops *scops = root->syscall_ops;\n\n\tif (scops && scops->show_path)\n\t\treturn scops->show_path(sf, node, root);\n\n\tseq_dentry(sf, dentry, \" \\t\\n\\\\\");\n\treturn 0;\n}\n\nstatic int kernfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tsimple_statfs(dentry, buf);\n\tbuf->f_fsid = uuid_to_fsid(dentry->d_sb->s_uuid.b);\n\treturn 0;\n}\n\nconst struct super_operations kernfs_sops = {\n\t.statfs\t\t= kernfs_statfs,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= kernfs_evict_inode,\n\n\t.show_options\t= kernfs_sop_show_options,\n\t.show_path\t= kernfs_sop_show_path,\n};\n\nstatic int kernfs_encode_fh(struct inode *inode, __u32 *fh, int *max_len,\n\t\t\t    struct inode *parent)\n{\n\tstruct kernfs_node *kn = inode->i_private;\n\n\tif (*max_len < 2) {\n\t\t*max_len = 2;\n\t\treturn FILEID_INVALID;\n\t}\n\n\t*max_len = 2;\n\t*(u64 *)fh = kn->id;\n\treturn FILEID_KERNFS;\n}\n\nstatic struct dentry *__kernfs_fh_to_dentry(struct super_block *sb,\n\t\t\t\t\t    struct fid *fid, int fh_len,\n\t\t\t\t\t    int fh_type, bool get_parent)\n{\n\tstruct kernfs_super_info *info = kernfs_info(sb);\n\tstruct kernfs_node *kn;\n\tstruct inode *inode;\n\tu64 id;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_KERNFS:\n\t\tid = *(u64 *)fid;\n\t\tbreak;\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\t \n\t\tid = ((u64)fid->i32.gen << 32) | fid->i32.ino;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tkn = kernfs_find_and_get_node_by_id(info->root, id);\n\tif (!kn)\n\t\treturn ERR_PTR(-ESTALE);\n\n\tif (get_parent) {\n\t\tstruct kernfs_node *parent;\n\n\t\tparent = kernfs_get_parent(kn);\n\t\tkernfs_put(kn);\n\t\tkn = parent;\n\t\tif (!kn)\n\t\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\tinode = kernfs_get_inode(sb, kn);\n\tkernfs_put(kn);\n\tif (!inode)\n\t\treturn ERR_PTR(-ESTALE);\n\n\treturn d_obtain_alias(inode);\n}\n\nstatic struct dentry *kernfs_fh_to_dentry(struct super_block *sb,\n\t\t\t\t\t  struct fid *fid, int fh_len,\n\t\t\t\t\t  int fh_type)\n{\n\treturn __kernfs_fh_to_dentry(sb, fid, fh_len, fh_type, false);\n}\n\nstatic struct dentry *kernfs_fh_to_parent(struct super_block *sb,\n\t\t\t\t\t  struct fid *fid, int fh_len,\n\t\t\t\t\t  int fh_type)\n{\n\treturn __kernfs_fh_to_dentry(sb, fid, fh_len, fh_type, true);\n}\n\nstatic struct dentry *kernfs_get_parent_dentry(struct dentry *child)\n{\n\tstruct kernfs_node *kn = kernfs_dentry_node(child);\n\n\treturn d_obtain_alias(kernfs_get_inode(child->d_sb, kn->parent));\n}\n\nstatic const struct export_operations kernfs_export_ops = {\n\t.encode_fh\t= kernfs_encode_fh,\n\t.fh_to_dentry\t= kernfs_fh_to_dentry,\n\t.fh_to_parent\t= kernfs_fh_to_parent,\n\t.get_parent\t= kernfs_get_parent_dentry,\n};\n\n \nstruct kernfs_root *kernfs_root_from_sb(struct super_block *sb)\n{\n\tif (sb->s_op == &kernfs_sops)\n\t\treturn kernfs_info(sb)->root;\n\treturn NULL;\n}\n\n \nstatic struct kernfs_node *find_next_ancestor(struct kernfs_node *child,\n\t\t\t\t\t      struct kernfs_node *parent)\n{\n\tif (child == parent) {\n\t\tpr_crit_once(\"BUG in find_next_ancestor: called with parent == child\");\n\t\treturn NULL;\n\t}\n\n\twhile (child->parent != parent) {\n\t\tif (!child->parent)\n\t\t\treturn NULL;\n\t\tchild = child->parent;\n\t}\n\n\treturn child;\n}\n\n \nstruct dentry *kernfs_node_dentry(struct kernfs_node *kn,\n\t\t\t\t  struct super_block *sb)\n{\n\tstruct dentry *dentry;\n\tstruct kernfs_node *knparent = NULL;\n\n\tBUG_ON(sb->s_op != &kernfs_sops);\n\n\tdentry = dget(sb->s_root);\n\n\t \n\tif (!kn->parent)\n\t\treturn dentry;\n\n\tknparent = find_next_ancestor(kn, NULL);\n\tif (WARN_ON(!knparent)) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tdo {\n\t\tstruct dentry *dtmp;\n\t\tstruct kernfs_node *kntmp;\n\n\t\tif (kn == knparent)\n\t\t\treturn dentry;\n\t\tkntmp = find_next_ancestor(kn, knparent);\n\t\tif (WARN_ON(!kntmp)) {\n\t\t\tdput(dentry);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdtmp = lookup_positive_unlocked(kntmp->name, dentry,\n\t\t\t\t\t       strlen(kntmp->name));\n\t\tdput(dentry);\n\t\tif (IS_ERR(dtmp))\n\t\t\treturn dtmp;\n\t\tknparent = kntmp;\n\t\tdentry = dtmp;\n\t} while (true);\n}\n\nstatic int kernfs_fill_super(struct super_block *sb, struct kernfs_fs_context *kfc)\n{\n\tstruct kernfs_super_info *info = kernfs_info(sb);\n\tstruct kernfs_root *kf_root = kfc->root;\n\tstruct inode *inode;\n\tstruct dentry *root;\n\n\tinfo->sb = sb;\n\t \n\tsb->s_iflags |= SB_I_NOEXEC | SB_I_NODEV;\n\tsb->s_blocksize = PAGE_SIZE;\n\tsb->s_blocksize_bits = PAGE_SHIFT;\n\tsb->s_magic = kfc->magic;\n\tsb->s_op = &kernfs_sops;\n\tsb->s_xattr = kernfs_xattr_handlers;\n\tif (info->root->flags & KERNFS_ROOT_SUPPORT_EXPORTOP)\n\t\tsb->s_export_op = &kernfs_export_ops;\n\tsb->s_time_gran = 1;\n\n\t \n\tsb->s_shrink.seeks = 0;\n\n\t \n\tdown_read(&kf_root->kernfs_rwsem);\n\tinode = kernfs_get_inode(sb, info->root->kn);\n\tup_read(&kf_root->kernfs_rwsem);\n\tif (!inode) {\n\t\tpr_debug(\"kernfs: could not get root inode\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tpr_debug(\"%s: could not get root dentry!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tsb->s_root = root;\n\tsb->s_d_op = &kernfs_dops;\n\treturn 0;\n}\n\nstatic int kernfs_test_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct kernfs_super_info *sb_info = kernfs_info(sb);\n\tstruct kernfs_super_info *info = fc->s_fs_info;\n\n\treturn sb_info->root == info->root && sb_info->ns == info->ns;\n}\n\nstatic int kernfs_set_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct kernfs_fs_context *kfc = fc->fs_private;\n\n\tkfc->ns_tag = NULL;\n\treturn set_anon_super_fc(sb, fc);\n}\n\n \nconst void *kernfs_super_ns(struct super_block *sb)\n{\n\tstruct kernfs_super_info *info = kernfs_info(sb);\n\n\treturn info->ns;\n}\n\n \nint kernfs_get_tree(struct fs_context *fc)\n{\n\tstruct kernfs_fs_context *kfc = fc->fs_private;\n\tstruct super_block *sb;\n\tstruct kernfs_super_info *info;\n\tint error;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->root = kfc->root;\n\tinfo->ns = kfc->ns_tag;\n\tINIT_LIST_HEAD(&info->node);\n\n\tfc->s_fs_info = info;\n\tsb = sget_fc(fc, kernfs_test_super, kernfs_set_super);\n\tif (IS_ERR(sb))\n\t\treturn PTR_ERR(sb);\n\n\tif (!sb->s_root) {\n\t\tstruct kernfs_super_info *info = kernfs_info(sb);\n\t\tstruct kernfs_root *root = kfc->root;\n\n\t\tkfc->new_sb_created = true;\n\n\t\terror = kernfs_fill_super(sb, kfc);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn error;\n\t\t}\n\t\tsb->s_flags |= SB_ACTIVE;\n\n\t\tuuid_gen(&sb->s_uuid);\n\n\t\tdown_write(&root->kernfs_supers_rwsem);\n\t\tlist_add(&info->node, &info->root->supers);\n\t\tup_write(&root->kernfs_supers_rwsem);\n\t}\n\n\tfc->root = dget(sb->s_root);\n\treturn 0;\n}\n\nvoid kernfs_free_fs_context(struct fs_context *fc)\n{\n\t \n\tkfree(fc->s_fs_info);\n\tfc->s_fs_info = NULL;\n}\n\n \nvoid kernfs_kill_sb(struct super_block *sb)\n{\n\tstruct kernfs_super_info *info = kernfs_info(sb);\n\tstruct kernfs_root *root = info->root;\n\n\tdown_write(&root->kernfs_supers_rwsem);\n\tlist_del(&info->node);\n\tup_write(&root->kernfs_supers_rwsem);\n\n\t \n\tkill_anon_super(sb);\n\tkfree(info);\n}\n\nstatic void __init kernfs_mutex_init(void)\n{\n\tint count;\n\n\tfor (count = 0; count < NR_KERNFS_LOCKS; count++)\n\t\tmutex_init(&kernfs_locks->open_file_mutex[count]);\n}\n\nstatic void __init kernfs_lock_init(void)\n{\n\tkernfs_locks = kmalloc(sizeof(struct kernfs_global_locks), GFP_KERNEL);\n\tWARN_ON(!kernfs_locks);\n\n\tkernfs_mutex_init();\n}\n\nvoid __init kernfs_init(void)\n{\n\tkernfs_node_cache = kmem_cache_create(\"kernfs_node_cache\",\n\t\t\t\t\t      sizeof(struct kernfs_node),\n\t\t\t\t\t      0, SLAB_PANIC, NULL);\n\n\t \n\tkernfs_iattrs_cache  = kmem_cache_create(\"kernfs_iattrs_cache\",\n\t\t\t\t\t      sizeof(struct kernfs_iattrs),\n\t\t\t\t\t      0, SLAB_PANIC, NULL);\n\n\tkernfs_lock_init();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}