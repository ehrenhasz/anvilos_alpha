{
  "module_name": "space-info.h",
  "hash_id": "99f5463c3e2c9c27f084a9e2f014b232cf1a4f20928f3dc6a40e87eccfa4c454",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/space-info.h",
  "human_readable_source": " \n\n#ifndef BTRFS_SPACE_INFO_H\n#define BTRFS_SPACE_INFO_H\n\n#include \"volumes.h\"\n\n \nenum btrfs_reserve_flush_enum {\n\t \n\tBTRFS_RESERVE_NO_FLUSH,\n\n\t \n\tBTRFS_RESERVE_FLUSH_LIMIT,\n\n\t \n\tBTRFS_RESERVE_FLUSH_EVICT,\n\n\t \n\tBTRFS_RESERVE_FLUSH_DATA,\n\tBTRFS_RESERVE_FLUSH_FREE_SPACE_INODE,\n\tBTRFS_RESERVE_FLUSH_ALL,\n\n\t \n\tBTRFS_RESERVE_FLUSH_ALL_STEAL,\n\n\t \n\tBTRFS_RESERVE_FLUSH_EMERGENCY,\n};\n\nenum btrfs_flush_state {\n\tFLUSH_DELAYED_ITEMS_NR\t= 1,\n\tFLUSH_DELAYED_ITEMS\t= 2,\n\tFLUSH_DELAYED_REFS_NR\t= 3,\n\tFLUSH_DELAYED_REFS\t= 4,\n\tFLUSH_DELALLOC\t\t= 5,\n\tFLUSH_DELALLOC_WAIT\t= 6,\n\tFLUSH_DELALLOC_FULL\t= 7,\n\tALLOC_CHUNK\t\t= 8,\n\tALLOC_CHUNK_FORCE\t= 9,\n\tRUN_DELAYED_IPUTS\t= 10,\n\tCOMMIT_TRANS\t\t= 11,\n};\n\nstruct btrfs_space_info {\n\tspinlock_t lock;\n\n\tu64 total_bytes;\t \n\tu64 bytes_used;\t\t \n\tu64 bytes_pinned;\t \n\tu64 bytes_reserved;\t \n\tu64 bytes_may_use;\t \n\tu64 bytes_readonly;\t \n\tu64 bytes_zone_unusable;\t \n\n\tu64 max_extent_size;\t \n\t \n\tu64 chunk_size;\n\n\t \n\tint bg_reclaim_threshold;\n\n\tint clamp;\t\t \n\n\tunsigned int full:1;\t \n\tunsigned int chunk_alloc:1;\t \n\n\tunsigned int flush:1;\t\t \n\n\tunsigned int force_alloc;\t \n\n\tu64 disk_used;\t\t \n\tu64 disk_total;\t\t \n\n\tu64 flags;\n\n\tstruct list_head list;\n\t \n\tstruct list_head ro_bgs;\n\tstruct list_head priority_tickets;\n\tstruct list_head tickets;\n\n\t \n\tu64 reclaim_size;\n\n\t \n\tu64 tickets_id;\n\n\tstruct rw_semaphore groups_sem;\n\t \n\tstruct list_head block_groups[BTRFS_NR_RAID_TYPES];\n\n\tstruct kobject kobj;\n\tstruct kobject *block_group_kobjs[BTRFS_NR_RAID_TYPES];\n};\n\nstruct reserve_ticket {\n\tu64 bytes;\n\tint error;\n\tbool steal;\n\tstruct list_head list;\n\twait_queue_head_t wait;\n};\n\nstatic inline bool btrfs_mixed_space_info(struct btrfs_space_info *space_info)\n{\n\treturn ((space_info->flags & BTRFS_BLOCK_GROUP_METADATA) &&\n\t\t(space_info->flags & BTRFS_BLOCK_GROUP_DATA));\n}\n\n \n#define DECLARE_SPACE_INFO_UPDATE(name, trace_name)\t\t\t\\\nstatic inline void\t\t\t\t\t\t\t\\\nbtrfs_space_info_update_##name(struct btrfs_fs_info *fs_info,\t\t\\\n\t\t\t       struct btrfs_space_info *sinfo,\t\t\\\n\t\t\t       s64 bytes)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tconst u64 abs_bytes = (bytes < 0) ? -bytes : bytes;\t\t\\\n\tlockdep_assert_held(&sinfo->lock);\t\t\t\t\\\n\ttrace_update_##name(fs_info, sinfo, sinfo->name, bytes);\t\\\n\ttrace_btrfs_space_reservation(fs_info, trace_name,\t\t\\\n\t\t\t\t      sinfo->flags, abs_bytes,\t\t\\\n\t\t\t\t      bytes > 0);\t\t\t\\\n\tif (bytes < 0 && sinfo->name < -bytes) {\t\t\t\\\n\t\tWARN_ON(1);\t\t\t\t\t\t\\\n\t\tsinfo->name = 0;\t\t\t\t\t\\\n\t\treturn;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tsinfo->name += bytes;\t\t\t\t\t\t\\\n}\n\nDECLARE_SPACE_INFO_UPDATE(bytes_may_use, \"space_info\");\nDECLARE_SPACE_INFO_UPDATE(bytes_pinned, \"pinned\");\n\nint btrfs_init_space_info(struct btrfs_fs_info *fs_info);\nvoid btrfs_add_bg_to_space_info(struct btrfs_fs_info *info,\n\t\t\t\tstruct btrfs_block_group *block_group);\nvoid btrfs_update_space_info_chunk_size(struct btrfs_space_info *space_info,\n\t\t\t\t\tu64 chunk_size);\nstruct btrfs_space_info *btrfs_find_space_info(struct btrfs_fs_info *info,\n\t\t\t\t\t       u64 flags);\nu64 __pure btrfs_space_info_used(struct btrfs_space_info *s_info,\n\t\t\t  bool may_use_included);\nvoid btrfs_clear_space_info_full(struct btrfs_fs_info *info);\nvoid btrfs_dump_space_info(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_space_info *info, u64 bytes,\n\t\t\t   int dump_block_groups);\nint btrfs_reserve_metadata_bytes(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct btrfs_block_rsv *block_rsv,\n\t\t\t\t u64 orig_bytes,\n\t\t\t\t enum btrfs_reserve_flush_enum flush);\nvoid btrfs_try_granting_tickets(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_space_info *space_info);\nint btrfs_can_overcommit(struct btrfs_fs_info *fs_info,\n\t\t\t struct btrfs_space_info *space_info, u64 bytes,\n\t\t\t enum btrfs_reserve_flush_enum flush);\n\nstatic inline void btrfs_space_info_free_bytes_may_use(\n\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_space_info *space_info,\n\t\t\t\tu64 num_bytes)\n{\n\tspin_lock(&space_info->lock);\n\tbtrfs_space_info_update_bytes_may_use(fs_info, space_info, -num_bytes);\n\tbtrfs_try_granting_tickets(fs_info, space_info);\n\tspin_unlock(&space_info->lock);\n}\nint btrfs_reserve_data_bytes(struct btrfs_fs_info *fs_info, u64 bytes,\n\t\t\t     enum btrfs_reserve_flush_enum flush);\nvoid btrfs_dump_space_info_for_trans_abort(struct btrfs_fs_info *fs_info);\nvoid btrfs_init_async_reclaim_work(struct btrfs_fs_info *fs_info);\nu64 btrfs_account_ro_block_groups_free_space(struct btrfs_space_info *sinfo);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}