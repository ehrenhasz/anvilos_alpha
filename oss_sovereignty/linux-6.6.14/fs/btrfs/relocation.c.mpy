{
  "module_name": "relocation.c",
  "hash_id": "9aaa90b3e51f8495c8c7454ef653ce9fabb4c1d0f0bacc3552352cccc4a14a52",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/relocation.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/error-injection.h>\n#include \"ctree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"btrfs_inode.h\"\n#include \"async-thread.h\"\n#include \"free-space-cache.h\"\n#include \"qgroup.h\"\n#include \"print-tree.h\"\n#include \"delalloc-space.h\"\n#include \"block-group.h\"\n#include \"backref.h\"\n#include \"misc.h\"\n#include \"subpage.h\"\n#include \"zoned.h\"\n#include \"inode-item.h\"\n#include \"space-info.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n#include \"extent-tree.h\"\n#include \"root-tree.h\"\n#include \"file-item.h\"\n#include \"relocation.h\"\n#include \"super.h\"\n#include \"tree-checker.h\"\n\n \n\n#define RELOCATION_RESERVED_NODES\t256\n \nstruct mapping_node {\n\tstruct {\n\t\tstruct rb_node rb_node;\n\t\tu64 bytenr;\n\t};  \n\tvoid *data;\n};\n\nstruct mapping_tree {\n\tstruct rb_root rb_root;\n\tspinlock_t lock;\n};\n\n \nstruct tree_block {\n\tstruct {\n\t\tstruct rb_node rb_node;\n\t\tu64 bytenr;\n\t};  \n\tu64 owner;\n\tstruct btrfs_key key;\n\tunsigned int level:8;\n\tunsigned int key_ready:1;\n};\n\n#define MAX_EXTENTS 128\n\nstruct file_extent_cluster {\n\tu64 start;\n\tu64 end;\n\tu64 boundary[MAX_EXTENTS];\n\tunsigned int nr;\n};\n\nstruct reloc_control {\n\t \n\tstruct btrfs_block_group *block_group;\n\t \n\tstruct btrfs_root *extent_root;\n\t \n\tstruct inode *data_inode;\n\n\tstruct btrfs_block_rsv *block_rsv;\n\n\tstruct btrfs_backref_cache backref_cache;\n\n\tstruct file_extent_cluster cluster;\n\t \n\tstruct extent_io_tree processed_blocks;\n\t \n\tstruct mapping_tree reloc_root_tree;\n\t \n\tstruct list_head reloc_roots;\n\t \n\tstruct list_head dirty_subvol_roots;\n\t \n\tu64 merging_rsv_size;\n\t \n\tu64 nodes_relocated;\n\t \n\tu64 reserved_bytes;\n\n\tu64 search_start;\n\tu64 extents_found;\n\n\tunsigned int stage:8;\n\tunsigned int create_reloc_tree:1;\n\tunsigned int merge_reloc_tree:1;\n\tunsigned int found_file_extent:1;\n};\n\n \n#define MOVE_DATA_EXTENTS\t0\n#define UPDATE_DATA_PTRS\t1\n\nstatic void mark_block_processed(struct reloc_control *rc,\n\t\t\t\t struct btrfs_backref_node *node)\n{\n\tu32 blocksize;\n\n\tif (node->level == 0 ||\n\t    in_range(node->bytenr, rc->block_group->start,\n\t\t     rc->block_group->length)) {\n\t\tblocksize = rc->extent_root->fs_info->nodesize;\n\t\tset_extent_bit(&rc->processed_blocks, node->bytenr,\n\t\t\t       node->bytenr + blocksize - 1, EXTENT_DIRTY, NULL);\n\t}\n\tnode->processed = 1;\n}\n\n\nstatic void mapping_tree_init(struct mapping_tree *tree)\n{\n\ttree->rb_root = RB_ROOT;\n\tspin_lock_init(&tree->lock);\n}\n\n \nstatic struct btrfs_backref_node *walk_up_backref(\n\t\tstruct btrfs_backref_node *node,\n\t\tstruct btrfs_backref_edge *edges[], int *index)\n{\n\tstruct btrfs_backref_edge *edge;\n\tint idx = *index;\n\n\twhile (!list_empty(&node->upper)) {\n\t\tedge = list_entry(node->upper.next,\n\t\t\t\t  struct btrfs_backref_edge, list[LOWER]);\n\t\tedges[idx++] = edge;\n\t\tnode = edge->node[UPPER];\n\t}\n\tBUG_ON(node->detached);\n\t*index = idx;\n\treturn node;\n}\n\n \nstatic struct btrfs_backref_node *walk_down_backref(\n\t\tstruct btrfs_backref_edge *edges[], int *index)\n{\n\tstruct btrfs_backref_edge *edge;\n\tstruct btrfs_backref_node *lower;\n\tint idx = *index;\n\n\twhile (idx > 0) {\n\t\tedge = edges[idx - 1];\n\t\tlower = edge->node[LOWER];\n\t\tif (list_is_last(&edge->list[LOWER], &lower->upper)) {\n\t\t\tidx--;\n\t\t\tcontinue;\n\t\t}\n\t\tedge = list_entry(edge->list[LOWER].next,\n\t\t\t\t  struct btrfs_backref_edge, list[LOWER]);\n\t\tedges[idx - 1] = edge;\n\t\t*index = idx;\n\t\treturn edge->node[UPPER];\n\t}\n\t*index = 0;\n\treturn NULL;\n}\n\nstatic void update_backref_node(struct btrfs_backref_cache *cache,\n\t\t\t\tstruct btrfs_backref_node *node, u64 bytenr)\n{\n\tstruct rb_node *rb_node;\n\trb_erase(&node->rb_node, &cache->rb_root);\n\tnode->bytenr = bytenr;\n\trb_node = rb_simple_insert(&cache->rb_root, node->bytenr, &node->rb_node);\n\tif (rb_node)\n\t\tbtrfs_backref_panic(cache->fs_info, bytenr, -EEXIST);\n}\n\n \nstatic int update_backref_cache(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_backref_cache *cache)\n{\n\tstruct btrfs_backref_node *node;\n\tint level = 0;\n\n\tif (cache->last_trans == 0) {\n\t\tcache->last_trans = trans->transid;\n\t\treturn 0;\n\t}\n\n\tif (cache->last_trans == trans->transid)\n\t\treturn 0;\n\n\t \n\twhile (!list_empty(&cache->detached)) {\n\t\tnode = list_entry(cache->detached.next,\n\t\t\t\t  struct btrfs_backref_node, list);\n\t\tbtrfs_backref_cleanup_node(cache, node);\n\t}\n\n\twhile (!list_empty(&cache->changed)) {\n\t\tnode = list_entry(cache->changed.next,\n\t\t\t\t  struct btrfs_backref_node, list);\n\t\tlist_del_init(&node->list);\n\t\tBUG_ON(node->pending);\n\t\tupdate_backref_node(cache, node, node->new_bytenr);\n\t}\n\n\t \n\tfor (level = 0; level < BTRFS_MAX_LEVEL; level++) {\n\t\tlist_for_each_entry(node, &cache->pending[level], list) {\n\t\t\tBUG_ON(!node->pending);\n\t\t\tif (node->bytenr == node->new_bytenr)\n\t\t\t\tcontinue;\n\t\t\tupdate_backref_node(cache, node, node->new_bytenr);\n\t\t}\n\t}\n\n\tcache->last_trans = 0;\n\treturn 1;\n}\n\nstatic bool reloc_root_is_dead(struct btrfs_root *root)\n{\n\t \n\tsmp_rmb();\n\tif (test_bit(BTRFS_ROOT_DEAD_RELOC_TREE, &root->state))\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic bool have_reloc_root(struct btrfs_root *root)\n{\n\tif (reloc_root_is_dead(root))\n\t\treturn false;\n\tif (!root->reloc_root)\n\t\treturn false;\n\treturn true;\n}\n\nint btrfs_should_ignore_reloc_root(struct btrfs_root *root)\n{\n\tstruct btrfs_root *reloc_root;\n\n\tif (!test_bit(BTRFS_ROOT_SHAREABLE, &root->state))\n\t\treturn 0;\n\n\t \n\tif (reloc_root_is_dead(root))\n\t\treturn 1;\n\n\treloc_root = root->reloc_root;\n\tif (!reloc_root)\n\t\treturn 0;\n\n\tif (btrfs_header_generation(reloc_root->commit_root) ==\n\t    root->fs_info->running_transaction->transid)\n\t\treturn 0;\n\t \n\treturn 1;\n}\n\n \nstruct btrfs_root *find_reloc_root(struct btrfs_fs_info *fs_info, u64 bytenr)\n{\n\tstruct reloc_control *rc = fs_info->reloc_ctl;\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node;\n\tstruct btrfs_root *root = NULL;\n\n\tASSERT(rc);\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = rb_simple_search(&rc->reloc_root_tree.rb_root, bytenr);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct mapping_node, rb_node);\n\t\troot = node->data;\n\t}\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\treturn btrfs_grab_root(root);\n}\n\n \nstatic bool handle_useless_nodes(struct reloc_control *rc,\n\t\t\t\t struct btrfs_backref_node *node)\n{\n\tstruct btrfs_backref_cache *cache = &rc->backref_cache;\n\tstruct list_head *useless_node = &cache->useless_node;\n\tbool ret = false;\n\n\twhile (!list_empty(useless_node)) {\n\t\tstruct btrfs_backref_node *cur;\n\n\t\tcur = list_first_entry(useless_node, struct btrfs_backref_node,\n\t\t\t\t list);\n\t\tlist_del_init(&cur->list);\n\n\t\t \n\t\tASSERT(list_empty(&cur->upper));\n\n\t\tif (cur == node)\n\t\t\tret = true;\n\n\t\t \n\t\tif (cur->lowest) {\n\t\t\tlist_del_init(&cur->lower);\n\t\t\tcur->lowest = 0;\n\t\t}\n\n\t\t \n\t\twhile (!list_empty(&cur->lower)) {\n\t\t\tstruct btrfs_backref_edge *edge;\n\t\t\tstruct btrfs_backref_node *lower;\n\n\t\t\tedge = list_entry(cur->lower.next,\n\t\t\t\t\tstruct btrfs_backref_edge, list[UPPER]);\n\t\t\tlist_del(&edge->list[UPPER]);\n\t\t\tlist_del(&edge->list[LOWER]);\n\t\t\tlower = edge->node[LOWER];\n\t\t\tbtrfs_backref_free_edge(cache, edge);\n\n\t\t\t \n\t\t\tif (list_empty(&lower->upper))\n\t\t\t\tlist_add(&lower->list, useless_node);\n\t\t}\n\t\t \n\t\tmark_block_processed(rc, cur);\n\n\t\t \n\t\tif (cur->level > 0) {\n\t\t\tlist_add(&cur->list, &cache->detached);\n\t\t\tcur->detached = 1;\n\t\t} else {\n\t\t\trb_erase(&cur->rb_node, &cache->rb_root);\n\t\t\tbtrfs_backref_free_node(cache, cur);\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nstatic noinline_for_stack struct btrfs_backref_node *build_backref_tree(\n\t\t\tstruct btrfs_trans_handle *trans,\n\t\t\tstruct reloc_control *rc, struct btrfs_key *node_key,\n\t\t\tint level, u64 bytenr)\n{\n\tstruct btrfs_backref_iter *iter;\n\tstruct btrfs_backref_cache *cache = &rc->backref_cache;\n\t \n\tstruct btrfs_path *path;\n\tstruct btrfs_backref_node *cur;\n\tstruct btrfs_backref_node *node = NULL;\n\tstruct btrfs_backref_edge *edge;\n\tint ret;\n\tint err = 0;\n\n\titer = btrfs_backref_iter_alloc(rc->extent_root->fs_info);\n\tif (!iter)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnode = btrfs_backref_alloc_node(cache, bytenr, level);\n\tif (!node) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnode->lowest = 1;\n\tcur = node;\n\n\t \n\tdo {\n\t\tret = btrfs_backref_add_tree_node(trans, cache, path, iter,\n\t\t\t\t\t\t  node_key, cur);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tedge = list_first_entry_or_null(&cache->pending_edge,\n\t\t\t\tstruct btrfs_backref_edge, list[UPPER]);\n\t\t \n\t\tif (edge) {\n\t\t\tlist_del_init(&edge->list[UPPER]);\n\t\t\tcur = edge->node[UPPER];\n\t\t}\n\t} while (edge);\n\n\t \n\tret = btrfs_backref_finish_upper_links(cache, node);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\n\tif (handle_useless_nodes(rc, node))\n\t\tnode = NULL;\nout:\n\tbtrfs_backref_iter_free(iter);\n\tbtrfs_free_path(path);\n\tif (err) {\n\t\tbtrfs_backref_error_cleanup(cache, node);\n\t\treturn ERR_PTR(err);\n\t}\n\tASSERT(!node || !node->detached);\n\tASSERT(list_empty(&cache->useless_node) &&\n\t       list_empty(&cache->pending_edge));\n\treturn node;\n}\n\n \nstatic int clone_backref_node(struct btrfs_trans_handle *trans,\n\t\t\t      struct reloc_control *rc,\n\t\t\t      struct btrfs_root *src,\n\t\t\t      struct btrfs_root *dest)\n{\n\tstruct btrfs_root *reloc_root = src->reloc_root;\n\tstruct btrfs_backref_cache *cache = &rc->backref_cache;\n\tstruct btrfs_backref_node *node = NULL;\n\tstruct btrfs_backref_node *new_node;\n\tstruct btrfs_backref_edge *edge;\n\tstruct btrfs_backref_edge *new_edge;\n\tstruct rb_node *rb_node;\n\n\tif (cache->last_trans > 0)\n\t\tupdate_backref_cache(trans, cache);\n\n\trb_node = rb_simple_search(&cache->rb_root, src->commit_root->start);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct btrfs_backref_node, rb_node);\n\t\tif (node->detached)\n\t\t\tnode = NULL;\n\t\telse\n\t\t\tBUG_ON(node->new_bytenr != reloc_root->node->start);\n\t}\n\n\tif (!node) {\n\t\trb_node = rb_simple_search(&cache->rb_root,\n\t\t\t\t\t   reloc_root->commit_root->start);\n\t\tif (rb_node) {\n\t\t\tnode = rb_entry(rb_node, struct btrfs_backref_node,\n\t\t\t\t\trb_node);\n\t\t\tBUG_ON(node->detached);\n\t\t}\n\t}\n\n\tif (!node)\n\t\treturn 0;\n\n\tnew_node = btrfs_backref_alloc_node(cache, dest->node->start,\n\t\t\t\t\t    node->level);\n\tif (!new_node)\n\t\treturn -ENOMEM;\n\n\tnew_node->lowest = node->lowest;\n\tnew_node->checked = 1;\n\tnew_node->root = btrfs_grab_root(dest);\n\tASSERT(new_node->root);\n\n\tif (!node->lowest) {\n\t\tlist_for_each_entry(edge, &node->lower, list[UPPER]) {\n\t\t\tnew_edge = btrfs_backref_alloc_edge(cache);\n\t\t\tif (!new_edge)\n\t\t\t\tgoto fail;\n\n\t\t\tbtrfs_backref_link_edge(new_edge, edge->node[LOWER],\n\t\t\t\t\t\tnew_node, LINK_UPPER);\n\t\t}\n\t} else {\n\t\tlist_add_tail(&new_node->lower, &cache->leaves);\n\t}\n\n\trb_node = rb_simple_insert(&cache->rb_root, new_node->bytenr,\n\t\t\t\t   &new_node->rb_node);\n\tif (rb_node)\n\t\tbtrfs_backref_panic(trans->fs_info, new_node->bytenr, -EEXIST);\n\n\tif (!new_node->lowest) {\n\t\tlist_for_each_entry(new_edge, &new_node->lower, list[UPPER]) {\n\t\t\tlist_add_tail(&new_edge->list[LOWER],\n\t\t\t\t      &new_edge->node[LOWER]->upper);\n\t\t}\n\t}\n\treturn 0;\nfail:\n\twhile (!list_empty(&new_node->lower)) {\n\t\tnew_edge = list_entry(new_node->lower.next,\n\t\t\t\t      struct btrfs_backref_edge, list[UPPER]);\n\t\tlist_del(&new_edge->list[UPPER]);\n\t\tbtrfs_backref_free_edge(cache, new_edge);\n\t}\n\tbtrfs_backref_free_node(cache, new_node);\n\treturn -ENOMEM;\n}\n\n \nstatic int __must_check __add_reloc_root(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node;\n\tstruct reloc_control *rc = fs_info->reloc_ctl;\n\n\tnode = kmalloc(sizeof(*node), GFP_NOFS);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tnode->bytenr = root->commit_root->start;\n\tnode->data = root;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = rb_simple_insert(&rc->reloc_root_tree.rb_root,\n\t\t\t\t   node->bytenr, &node->rb_node);\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\tif (rb_node) {\n\t\tbtrfs_err(fs_info,\n\t\t\t    \"Duplicate root found for start=%llu while inserting into relocation tree\",\n\t\t\t    node->bytenr);\n\t\treturn -EEXIST;\n\t}\n\n\tlist_add_tail(&root->root_list, &rc->reloc_roots);\n\treturn 0;\n}\n\n \nstatic void __del_reloc_root(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node = NULL;\n\tstruct reloc_control *rc = fs_info->reloc_ctl;\n\tbool put_ref = false;\n\n\tif (rc && root->node) {\n\t\tspin_lock(&rc->reloc_root_tree.lock);\n\t\trb_node = rb_simple_search(&rc->reloc_root_tree.rb_root,\n\t\t\t\t\t   root->commit_root->start);\n\t\tif (rb_node) {\n\t\t\tnode = rb_entry(rb_node, struct mapping_node, rb_node);\n\t\t\trb_erase(&node->rb_node, &rc->reloc_root_tree.rb_root);\n\t\t\tRB_CLEAR_NODE(&node->rb_node);\n\t\t}\n\t\tspin_unlock(&rc->reloc_root_tree.lock);\n\t\tASSERT(!node || (struct btrfs_root *)node->data == root);\n\t}\n\n\t \n\tspin_lock(&fs_info->trans_lock);\n\tif (!list_empty(&root->root_list)) {\n\t\tput_ref = true;\n\t\tlist_del_init(&root->root_list);\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n\tif (put_ref)\n\t\tbtrfs_put_root(root);\n\tkfree(node);\n}\n\n \nstatic int __update_reloc_root(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node = NULL;\n\tstruct reloc_control *rc = fs_info->reloc_ctl;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = rb_simple_search(&rc->reloc_root_tree.rb_root,\n\t\t\t\t   root->commit_root->start);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct mapping_node, rb_node);\n\t\trb_erase(&node->rb_node, &rc->reloc_root_tree.rb_root);\n\t}\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\n\tif (!node)\n\t\treturn 0;\n\tBUG_ON((struct btrfs_root *)node->data != root);\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\tnode->bytenr = root->node->start;\n\trb_node = rb_simple_insert(&rc->reloc_root_tree.rb_root,\n\t\t\t\t   node->bytenr, &node->rb_node);\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\tif (rb_node)\n\t\tbtrfs_backref_panic(fs_info, node->bytenr, -EEXIST);\n\treturn 0;\n}\n\nstatic struct btrfs_root *create_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root, u64 objectid)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_root *reloc_root;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_key root_key;\n\tint ret = 0;\n\tbool must_abort = false;\n\n\troot_item = kmalloc(sizeof(*root_item), GFP_NOFS);\n\tif (!root_item)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\troot_key.objectid = BTRFS_TREE_RELOC_OBJECTID;\n\troot_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot_key.offset = objectid;\n\n\tif (root->root_key.objectid == objectid) {\n\t\tu64 commit_root_gen;\n\n\t\t \n\t\tret = btrfs_copy_root(trans, root, root->commit_root, &eb,\n\t\t\t\t      BTRFS_TREE_RELOC_OBJECTID);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\t \n\t\tcommit_root_gen = btrfs_header_generation(root->commit_root);\n\t\tbtrfs_set_root_last_snapshot(&root->root_item, commit_root_gen);\n\t} else {\n\t\t \n\t\tret = btrfs_copy_root(trans, root, root->node, &eb,\n\t\t\t\t      BTRFS_TREE_RELOC_OBJECTID);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\t \n\tmust_abort = true;\n\n\tmemcpy(root_item, &root->root_item, sizeof(*root_item));\n\tbtrfs_set_root_bytenr(root_item, eb->start);\n\tbtrfs_set_root_level(root_item, btrfs_header_level(eb));\n\tbtrfs_set_root_generation(root_item, trans->transid);\n\n\tif (root->root_key.objectid == objectid) {\n\t\tbtrfs_set_root_refs(root_item, 0);\n\t\tmemset(&root_item->drop_progress, 0,\n\t\t       sizeof(struct btrfs_disk_key));\n\t\tbtrfs_set_root_drop_level(root_item, 0);\n\t}\n\n\tbtrfs_tree_unlock(eb);\n\tfree_extent_buffer(eb);\n\n\tret = btrfs_insert_root(trans, fs_info->tree_root,\n\t\t\t\t&root_key, root_item);\n\tif (ret)\n\t\tgoto fail;\n\n\tkfree(root_item);\n\n\treloc_root = btrfs_read_tree_root(fs_info->tree_root, &root_key);\n\tif (IS_ERR(reloc_root)) {\n\t\tret = PTR_ERR(reloc_root);\n\t\tgoto abort;\n\t}\n\tset_bit(BTRFS_ROOT_SHAREABLE, &reloc_root->state);\n\treloc_root->last_trans = trans->transid;\n\treturn reloc_root;\nfail:\n\tkfree(root_item);\nabort:\n\tif (must_abort)\n\t\tbtrfs_abort_transaction(trans, ret);\n\treturn ERR_PTR(ret);\n}\n\n \nint btrfs_init_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_root *reloc_root;\n\tstruct reloc_control *rc = fs_info->reloc_ctl;\n\tstruct btrfs_block_rsv *rsv;\n\tint clear_rsv = 0;\n\tint ret;\n\n\tif (!rc)\n\t\treturn 0;\n\n\t \n\tif (reloc_root_is_dead(root))\n\t\treturn 0;\n\n\t \n\tif (root->reloc_root) {\n\t\treloc_root = root->reloc_root;\n\t\treloc_root->last_trans = trans->transid;\n\t\treturn 0;\n\t}\n\n\t \n\tif (!rc->create_reloc_tree ||\n\t    root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\treturn 0;\n\n\tif (!trans->reloc_reserved) {\n\t\trsv = trans->block_rsv;\n\t\ttrans->block_rsv = rc->block_rsv;\n\t\tclear_rsv = 1;\n\t}\n\treloc_root = create_reloc_root(trans, root, root->root_key.objectid);\n\tif (clear_rsv)\n\t\ttrans->block_rsv = rsv;\n\tif (IS_ERR(reloc_root))\n\t\treturn PTR_ERR(reloc_root);\n\n\tret = __add_reloc_root(reloc_root);\n\tASSERT(ret != -EEXIST);\n\tif (ret) {\n\t\t \n\t\tbtrfs_put_root(reloc_root);\n\t\treturn ret;\n\t}\n\troot->reloc_root = btrfs_grab_root(reloc_root);\n\treturn 0;\n}\n\n \nint btrfs_update_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root_item *root_item;\n\tint ret;\n\n\tif (!have_reloc_root(root))\n\t\treturn 0;\n\n\treloc_root = root->reloc_root;\n\troot_item = &reloc_root->root_item;\n\n\t \n\tbtrfs_grab_root(reloc_root);\n\n\t \n\tif (fs_info->reloc_ctl->merge_reloc_tree &&\n\t    btrfs_root_refs(root_item) == 0) {\n\t\tset_bit(BTRFS_ROOT_DEAD_RELOC_TREE, &root->state);\n\t\t \n\t\tsmp_wmb();\n\t\t__del_reloc_root(reloc_root);\n\t}\n\n\tif (reloc_root->commit_root != reloc_root->node) {\n\t\t__update_reloc_root(reloc_root);\n\t\tbtrfs_set_root_node(root_item, reloc_root->node);\n\t\tfree_extent_buffer(reloc_root->commit_root);\n\t\treloc_root->commit_root = btrfs_root_node(reloc_root);\n\t}\n\n\tret = btrfs_update_root(trans, fs_info->tree_root,\n\t\t\t\t&reloc_root->root_key, root_item);\n\tbtrfs_put_root(reloc_root);\n\treturn ret;\n}\n\n \nstatic struct inode *find_next_inode(struct btrfs_root *root, u64 objectid)\n{\n\tstruct rb_node *node;\n\tstruct rb_node *prev;\n\tstruct btrfs_inode *entry;\n\tstruct inode *inode;\n\n\tspin_lock(&root->inode_lock);\nagain:\n\tnode = root->inode_tree.rb_node;\n\tprev = NULL;\n\twhile (node) {\n\t\tprev = node;\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\n\t\tif (objectid < btrfs_ino(entry))\n\t\t\tnode = node->rb_left;\n\t\telse if (objectid > btrfs_ino(entry))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!node) {\n\t\twhile (prev) {\n\t\t\tentry = rb_entry(prev, struct btrfs_inode, rb_node);\n\t\t\tif (objectid <= btrfs_ino(entry)) {\n\t\t\t\tnode = prev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprev = rb_next(prev);\n\t\t}\n\t}\n\twhile (node) {\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\t\tinode = igrab(&entry->vfs_inode);\n\t\tif (inode) {\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn inode;\n\t\t}\n\n\t\tobjectid = btrfs_ino(entry) + 1;\n\t\tif (cond_resched_lock(&root->inode_lock))\n\t\t\tgoto again;\n\n\t\tnode = rb_next(node);\n\t}\n\tspin_unlock(&root->inode_lock);\n\treturn NULL;\n}\n\n \nstatic int get_new_location(struct inode *reloc_inode, u64 *new_bytenr,\n\t\t\t    u64 bytenr, u64 num_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(reloc_inode)->root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tbytenr -= BTRFS_I(reloc_inode)->index_cnt;\n\tret = btrfs_lookup_file_extent(NULL, root, path,\n\t\t\tbtrfs_ino(BTRFS_I(reloc_inode)), bytenr, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\n\tBUG_ON(btrfs_file_extent_offset(leaf, fi) ||\n\t       btrfs_file_extent_compression(leaf, fi) ||\n\t       btrfs_file_extent_encryption(leaf, fi) ||\n\t       btrfs_file_extent_other_encoding(leaf, fi));\n\n\tif (num_bytes != btrfs_file_extent_disk_num_bytes(leaf, fi)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*new_bytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nstatic noinline_for_stack\nint replace_file_extents(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc,\n\t\t\t struct btrfs_root *root,\n\t\t\t struct extent_buffer *leaf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_key key;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct inode *inode = NULL;\n\tu64 parent;\n\tu64 bytenr;\n\tu64 new_bytenr = 0;\n\tu64 num_bytes;\n\tu64 end;\n\tu32 nritems;\n\tu32 i;\n\tint ret = 0;\n\tint first = 1;\n\tint dirty = 0;\n\n\tif (rc->stage != UPDATE_DATA_PTRS)\n\t\treturn 0;\n\n\t \n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tparent = leaf->start;\n\telse\n\t\tparent = 0;\n\n\tnritems = btrfs_header_nritems(leaf);\n\tfor (i = 0; i < nritems; i++) {\n\t\tstruct btrfs_ref ref = { 0 };\n\n\t\tcond_resched();\n\t\tbtrfs_item_key_to_cpu(leaf, &key, i);\n\t\tif (key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tcontinue;\n\t\tfi = btrfs_item_ptr(leaf, i, struct btrfs_file_extent_item);\n\t\tif (btrfs_file_extent_type(leaf, fi) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE)\n\t\t\tcontinue;\n\t\tbytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\tnum_bytes = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\tif (bytenr == 0)\n\t\t\tcontinue;\n\t\tif (!in_range(bytenr, rc->block_group->start,\n\t\t\t      rc->block_group->length))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID) {\n\t\t\tif (first) {\n\t\t\t\tinode = find_next_inode(root, key.objectid);\n\t\t\t\tfirst = 0;\n\t\t\t} else if (inode && btrfs_ino(BTRFS_I(inode)) < key.objectid) {\n\t\t\t\tbtrfs_add_delayed_iput(BTRFS_I(inode));\n\t\t\t\tinode = find_next_inode(root, key.objectid);\n\t\t\t}\n\t\t\tif (inode && btrfs_ino(BTRFS_I(inode)) == key.objectid) {\n\t\t\t\tstruct extent_state *cached_state = NULL;\n\n\t\t\t\tend = key.offset +\n\t\t\t\t      btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\tWARN_ON(!IS_ALIGNED(key.offset,\n\t\t\t\t\t\t    fs_info->sectorsize));\n\t\t\t\tWARN_ON(!IS_ALIGNED(end, fs_info->sectorsize));\n\t\t\t\tend--;\n\t\t\t\tret = try_lock_extent(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t\t      key.offset, end,\n\t\t\t\t\t\t      &cached_state);\n\t\t\t\tif (!ret)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbtrfs_drop_extent_map_range(BTRFS_I(inode),\n\t\t\t\t\t\t\t    key.offset, end, true);\n\t\t\t\tunlock_extent(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t      key.offset, end, &cached_state);\n\t\t\t}\n\t\t}\n\n\t\tret = get_new_location(rc->data_inode, &new_bytenr,\n\t\t\t\t       bytenr, num_bytes);\n\t\tif (ret) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_set_file_extent_disk_bytenr(leaf, fi, new_bytenr);\n\t\tdirty = 1;\n\n\t\tkey.offset -= btrfs_file_extent_offset(leaf, fi);\n\t\tbtrfs_init_generic_ref(&ref, BTRFS_ADD_DELAYED_REF, new_bytenr,\n\t\t\t\t       num_bytes, parent);\n\t\tbtrfs_init_data_ref(&ref, btrfs_header_owner(leaf),\n\t\t\t\t    key.objectid, key.offset,\n\t\t\t\t    root->root_key.objectid, false);\n\t\tret = btrfs_inc_extent_ref(trans, &ref);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_init_generic_ref(&ref, BTRFS_DROP_DELAYED_REF, bytenr,\n\t\t\t\t       num_bytes, parent);\n\t\tbtrfs_init_data_ref(&ref, btrfs_header_owner(leaf),\n\t\t\t\t    key.objectid, key.offset,\n\t\t\t\t    root->root_key.objectid, false);\n\t\tret = btrfs_free_extent(trans, &ref);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (dirty)\n\t\tbtrfs_mark_buffer_dirty(trans, leaf);\n\tif (inode)\n\t\tbtrfs_add_delayed_iput(BTRFS_I(inode));\n\treturn ret;\n}\n\nstatic noinline_for_stack\nint memcmp_node_keys(struct extent_buffer *eb, int slot,\n\t\t     struct btrfs_path *path, int level)\n{\n\tstruct btrfs_disk_key key1;\n\tstruct btrfs_disk_key key2;\n\tbtrfs_node_key(eb, &key1, slot);\n\tbtrfs_node_key(path->nodes[level], &key2, path->slots[level]);\n\treturn memcmp(&key1, &key2, sizeof(key1));\n}\n\n \nstatic noinline_for_stack\nint replace_path(struct btrfs_trans_handle *trans, struct reloc_control *rc,\n\t\t struct btrfs_root *dest, struct btrfs_root *src,\n\t\t struct btrfs_path *path, struct btrfs_key *next_key,\n\t\t int lowest_level, int max_level)\n{\n\tstruct btrfs_fs_info *fs_info = dest->fs_info;\n\tstruct extent_buffer *eb;\n\tstruct extent_buffer *parent;\n\tstruct btrfs_ref ref = { 0 };\n\tstruct btrfs_key key;\n\tu64 old_bytenr;\n\tu64 new_bytenr;\n\tu64 old_ptr_gen;\n\tu64 new_ptr_gen;\n\tu64 last_snapshot;\n\tu32 blocksize;\n\tint cow = 0;\n\tint level;\n\tint ret;\n\tint slot;\n\n\tASSERT(src->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID);\n\tASSERT(dest->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID);\n\n\tlast_snapshot = btrfs_root_last_snapshot(&src->root_item);\nagain:\n\tslot = path->slots[lowest_level];\n\tbtrfs_node_key_to_cpu(path->nodes[lowest_level], &key, slot);\n\n\teb = btrfs_lock_root_node(dest);\n\tlevel = btrfs_header_level(eb);\n\n\tif (level < lowest_level) {\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t\treturn 0;\n\t}\n\n\tif (cow) {\n\t\tret = btrfs_cow_block(trans, dest, eb, NULL, 0, &eb,\n\t\t\t\t      BTRFS_NESTING_COW);\n\t\tif (ret) {\n\t\t\tbtrfs_tree_unlock(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (next_key) {\n\t\tnext_key->objectid = (u64)-1;\n\t\tnext_key->type = (u8)-1;\n\t\tnext_key->offset = (u64)-1;\n\t}\n\n\tparent = eb;\n\twhile (1) {\n\t\tlevel = btrfs_header_level(parent);\n\t\tASSERT(level >= lowest_level);\n\n\t\tret = btrfs_bin_search(parent, 0, &key, &slot);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && slot > 0)\n\t\t\tslot--;\n\n\t\tif (next_key && slot + 1 < btrfs_header_nritems(parent))\n\t\t\tbtrfs_node_key_to_cpu(parent, next_key, slot + 1);\n\n\t\told_bytenr = btrfs_node_blockptr(parent, slot);\n\t\tblocksize = fs_info->nodesize;\n\t\told_ptr_gen = btrfs_node_ptr_generation(parent, slot);\n\n\t\tif (level <= max_level) {\n\t\t\teb = path->nodes[level];\n\t\t\tnew_bytenr = btrfs_node_blockptr(eb,\n\t\t\t\t\t\t\tpath->slots[level]);\n\t\t\tnew_ptr_gen = btrfs_node_ptr_generation(eb,\n\t\t\t\t\t\t\tpath->slots[level]);\n\t\t} else {\n\t\t\tnew_bytenr = 0;\n\t\t\tnew_ptr_gen = 0;\n\t\t}\n\n\t\tif (WARN_ON(new_bytenr > 0 && new_bytenr == old_bytenr)) {\n\t\t\tret = level;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (new_bytenr == 0 || old_ptr_gen > last_snapshot ||\n\t\t    memcmp_node_keys(parent, slot, path, level)) {\n\t\t\tif (level <= lowest_level) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\teb = btrfs_read_node_slot(parent, slot);\n\t\t\tif (IS_ERR(eb)) {\n\t\t\t\tret = PTR_ERR(eb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_tree_lock(eb);\n\t\t\tif (cow) {\n\t\t\t\tret = btrfs_cow_block(trans, dest, eb, parent,\n\t\t\t\t\t\t      slot, &eb,\n\t\t\t\t\t\t      BTRFS_NESTING_COW);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_tree_unlock(eb);\n\t\t\t\t\tfree_extent_buffer(eb);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbtrfs_tree_unlock(parent);\n\t\t\tfree_extent_buffer(parent);\n\n\t\t\tparent = eb;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!cow) {\n\t\t\tbtrfs_tree_unlock(parent);\n\t\t\tfree_extent_buffer(parent);\n\t\t\tcow = 1;\n\t\t\tgoto again;\n\t\t}\n\n\t\tbtrfs_node_key_to_cpu(path->nodes[level], &key,\n\t\t\t\t      path->slots[level]);\n\t\tbtrfs_release_path(path);\n\n\t\tpath->lowest_level = level;\n\t\tset_bit(BTRFS_ROOT_RESET_LOCKDEP_CLASS, &src->state);\n\t\tret = btrfs_search_slot(trans, src, &key, path, 0, 1);\n\t\tclear_bit(BTRFS_ROOT_RESET_LOCKDEP_CLASS, &src->state);\n\t\tpath->lowest_level = 0;\n\t\tif (ret) {\n\t\t\tif (ret > 0)\n\t\t\t\tret = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tret = btrfs_qgroup_add_swapped_blocks(trans, dest,\n\t\t\t\trc->block_group, parent, slot,\n\t\t\t\tpath->nodes[level], path->slots[level],\n\t\t\t\tlast_snapshot);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\t \n\t\tbtrfs_set_node_blockptr(parent, slot, new_bytenr);\n\t\tbtrfs_set_node_ptr_generation(parent, slot, new_ptr_gen);\n\t\tbtrfs_mark_buffer_dirty(trans, parent);\n\n\t\tbtrfs_set_node_blockptr(path->nodes[level],\n\t\t\t\t\tpath->slots[level], old_bytenr);\n\t\tbtrfs_set_node_ptr_generation(path->nodes[level],\n\t\t\t\t\t      path->slots[level], old_ptr_gen);\n\t\tbtrfs_mark_buffer_dirty(trans, path->nodes[level]);\n\n\t\tbtrfs_init_generic_ref(&ref, BTRFS_ADD_DELAYED_REF, old_bytenr,\n\t\t\t\t       blocksize, path->nodes[level]->start);\n\t\tbtrfs_init_tree_ref(&ref, level - 1, src->root_key.objectid,\n\t\t\t\t    0, true);\n\t\tret = btrfs_inc_extent_ref(trans, &ref);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_init_generic_ref(&ref, BTRFS_ADD_DELAYED_REF, new_bytenr,\n\t\t\t\t       blocksize, 0);\n\t\tbtrfs_init_tree_ref(&ref, level - 1, dest->root_key.objectid, 0,\n\t\t\t\t    true);\n\t\tret = btrfs_inc_extent_ref(trans, &ref);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_init_generic_ref(&ref, BTRFS_DROP_DELAYED_REF, new_bytenr,\n\t\t\t\t       blocksize, path->nodes[level]->start);\n\t\tbtrfs_init_tree_ref(&ref, level - 1, src->root_key.objectid,\n\t\t\t\t    0, true);\n\t\tret = btrfs_free_extent(trans, &ref);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_init_generic_ref(&ref, BTRFS_DROP_DELAYED_REF, old_bytenr,\n\t\t\t\t       blocksize, 0);\n\t\tbtrfs_init_tree_ref(&ref, level - 1, dest->root_key.objectid,\n\t\t\t\t    0, true);\n\t\tret = btrfs_free_extent(trans, &ref);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_unlock_up_safe(path, 0);\n\n\t\tret = level;\n\t\tbreak;\n\t}\n\tbtrfs_tree_unlock(parent);\n\tfree_extent_buffer(parent);\n\treturn ret;\n}\n\n \nstatic noinline_for_stack\nint walk_up_reloc_tree(struct btrfs_root *root, struct btrfs_path *path,\n\t\t       int *level)\n{\n\tstruct extent_buffer *eb;\n\tint i;\n\tu64 last_snapshot;\n\tu32 nritems;\n\n\tlast_snapshot = btrfs_root_last_snapshot(&root->root_item);\n\n\tfor (i = 0; i < *level; i++) {\n\t\tfree_extent_buffer(path->nodes[i]);\n\t\tpath->nodes[i] = NULL;\n\t}\n\n\tfor (i = *level; i < BTRFS_MAX_LEVEL && path->nodes[i]; i++) {\n\t\teb = path->nodes[i];\n\t\tnritems = btrfs_header_nritems(eb);\n\t\twhile (path->slots[i] + 1 < nritems) {\n\t\t\tpath->slots[i]++;\n\t\t\tif (btrfs_node_ptr_generation(eb, path->slots[i]) <=\n\t\t\t    last_snapshot)\n\t\t\t\tcontinue;\n\n\t\t\t*level = i;\n\t\t\treturn 0;\n\t\t}\n\t\tfree_extent_buffer(path->nodes[i]);\n\t\tpath->nodes[i] = NULL;\n\t}\n\treturn 1;\n}\n\n \nstatic noinline_for_stack\nint walk_down_reloc_tree(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t int *level)\n{\n\tstruct extent_buffer *eb = NULL;\n\tint i;\n\tu64 ptr_gen = 0;\n\tu64 last_snapshot;\n\tu32 nritems;\n\n\tlast_snapshot = btrfs_root_last_snapshot(&root->root_item);\n\n\tfor (i = *level; i > 0; i--) {\n\t\teb = path->nodes[i];\n\t\tnritems = btrfs_header_nritems(eb);\n\t\twhile (path->slots[i] < nritems) {\n\t\t\tptr_gen = btrfs_node_ptr_generation(eb, path->slots[i]);\n\t\t\tif (ptr_gen > last_snapshot)\n\t\t\t\tbreak;\n\t\t\tpath->slots[i]++;\n\t\t}\n\t\tif (path->slots[i] >= nritems) {\n\t\t\tif (i == *level)\n\t\t\t\tbreak;\n\t\t\t*level = i + 1;\n\t\t\treturn 0;\n\t\t}\n\t\tif (i == 1) {\n\t\t\t*level = i;\n\t\t\treturn 0;\n\t\t}\n\n\t\teb = btrfs_read_node_slot(eb, path->slots[i]);\n\t\tif (IS_ERR(eb))\n\t\t\treturn PTR_ERR(eb);\n\t\tBUG_ON(btrfs_header_level(eb) != i - 1);\n\t\tpath->nodes[i - 1] = eb;\n\t\tpath->slots[i - 1] = 0;\n\t}\n\treturn 1;\n}\n\n \nstatic int invalidate_extent_cache(struct btrfs_root *root,\n\t\t\t\t   struct btrfs_key *min_key,\n\t\t\t\t   struct btrfs_key *max_key)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct inode *inode = NULL;\n\tu64 objectid;\n\tu64 start, end;\n\tu64 ino;\n\n\tobjectid = min_key->objectid;\n\twhile (1) {\n\t\tstruct extent_state *cached_state = NULL;\n\n\t\tcond_resched();\n\t\tiput(inode);\n\n\t\tif (objectid > max_key->objectid)\n\t\t\tbreak;\n\n\t\tinode = find_next_inode(root, objectid);\n\t\tif (!inode)\n\t\t\tbreak;\n\t\tino = btrfs_ino(BTRFS_I(inode));\n\n\t\tif (ino > max_key->objectid) {\n\t\t\tiput(inode);\n\t\t\tbreak;\n\t\t}\n\n\t\tobjectid = ino + 1;\n\t\tif (!S_ISREG(inode->i_mode))\n\t\t\tcontinue;\n\n\t\tif (unlikely(min_key->objectid == ino)) {\n\t\t\tif (min_key->type > BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tcontinue;\n\t\t\tif (min_key->type < BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tstart = 0;\n\t\t\telse {\n\t\t\t\tstart = min_key->offset;\n\t\t\t\tWARN_ON(!IS_ALIGNED(start, fs_info->sectorsize));\n\t\t\t}\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\n\t\tif (unlikely(max_key->objectid == ino)) {\n\t\t\tif (max_key->type < BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tcontinue;\n\t\t\tif (max_key->type > BTRFS_EXTENT_DATA_KEY) {\n\t\t\t\tend = (u64)-1;\n\t\t\t} else {\n\t\t\t\tif (max_key->offset == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tend = max_key->offset;\n\t\t\t\tWARN_ON(!IS_ALIGNED(end, fs_info->sectorsize));\n\t\t\t\tend--;\n\t\t\t}\n\t\t} else {\n\t\t\tend = (u64)-1;\n\t\t}\n\n\t\t \n\t\tlock_extent(&BTRFS_I(inode)->io_tree, start, end, &cached_state);\n\t\tbtrfs_drop_extent_map_range(BTRFS_I(inode), start, end, true);\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, start, end, &cached_state);\n\t}\n\treturn 0;\n}\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key)\n\n{\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level])\n\t\t\tbreak;\n\t\tif (path->slots[level] + 1 <\n\t\t    btrfs_header_nritems(path->nodes[level])) {\n\t\t\tbtrfs_node_key_to_cpu(path->nodes[level], key,\n\t\t\t\t\t      path->slots[level] + 1);\n\t\t\treturn 0;\n\t\t}\n\t\tlevel++;\n\t}\n\treturn 1;\n}\n\n \nstatic int insert_dirty_subvol(struct btrfs_trans_handle *trans,\n\t\t\t       struct reloc_control *rc,\n\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_root *reloc_root = root->reloc_root;\n\tstruct btrfs_root_item *reloc_root_item;\n\tint ret;\n\n\t \n\tASSERT(root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID);\n\tASSERT(reloc_root);\n\n\treloc_root_item = &reloc_root->root_item;\n\tmemset(&reloc_root_item->drop_progress, 0,\n\t\tsizeof(reloc_root_item->drop_progress));\n\tbtrfs_set_root_drop_level(reloc_root_item, 0);\n\tbtrfs_set_root_refs(reloc_root_item, 0);\n\tret = btrfs_update_reloc_root(trans, root);\n\tif (ret)\n\t\treturn ret;\n\n\tif (list_empty(&root->reloc_dirty_list)) {\n\t\tbtrfs_grab_root(root);\n\t\tlist_add_tail(&root->reloc_dirty_list, &rc->dirty_subvol_roots);\n\t}\n\n\treturn 0;\n}\n\nstatic int clean_dirty_subvols(struct reloc_control *rc)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *next;\n\tint ret = 0;\n\tint ret2;\n\n\tlist_for_each_entry_safe(root, next, &rc->dirty_subvol_roots,\n\t\t\t\t reloc_dirty_list) {\n\t\tif (root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID) {\n\t\t\t \n\t\t\tstruct btrfs_root *reloc_root = root->reloc_root;\n\n\t\t\tlist_del_init(&root->reloc_dirty_list);\n\t\t\troot->reloc_root = NULL;\n\t\t\t \n\t\t\tsmp_wmb();\n\t\t\tclear_bit(BTRFS_ROOT_DEAD_RELOC_TREE, &root->state);\n\t\t\tif (reloc_root) {\n\t\t\t\t \n\t\t\t\tret2 = btrfs_drop_snapshot(reloc_root, 0, 1);\n\t\t\t\tif (ret2 < 0) {\n\t\t\t\t\tbtrfs_put_root(reloc_root);\n\t\t\t\t\tif (!ret)\n\t\t\t\t\t\tret = ret2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbtrfs_put_root(root);\n\t\t} else {\n\t\t\t \n\t\t\tret2 = btrfs_drop_snapshot(root, 0, 1);\n\t\t\tif (ret2 < 0) {\n\t\t\t\tbtrfs_put_root(root);\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = ret2;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nstatic noinline_for_stack int merge_reloc_root(struct reloc_control *rc,\n\t\t\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\tstruct btrfs_key key;\n\tstruct btrfs_key next_key;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tint reserve_level;\n\tint level;\n\tint max_level;\n\tint replaced = 0;\n\tint ret = 0;\n\tu32 min_reserved;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = READA_FORWARD;\n\n\treloc_root = root->reloc_root;\n\troot_item = &reloc_root->root_item;\n\n\tif (btrfs_disk_key_objectid(&root_item->drop_progress) == 0) {\n\t\tlevel = btrfs_root_level(root_item);\n\t\tatomic_inc(&reloc_root->node->refs);\n\t\tpath->nodes[level] = reloc_root->node;\n\t\tpath->slots[level] = 0;\n\t} else {\n\t\tbtrfs_disk_key_to_cpu(&key, &root_item->drop_progress);\n\n\t\tlevel = btrfs_root_drop_level(root_item);\n\t\tBUG_ON(level == 0);\n\t\tpath->lowest_level = level;\n\t\tret = btrfs_search_slot(NULL, reloc_root, &key, path, 0, 0);\n\t\tpath->lowest_level = 0;\n\t\tif (ret < 0) {\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbtrfs_node_key_to_cpu(path->nodes[level], &next_key,\n\t\t\t\t      path->slots[level]);\n\t\tWARN_ON(memcmp(&key, &next_key, sizeof(key)));\n\n\t\tbtrfs_unlock_up_safe(path, 0);\n\t}\n\n\t \n\treserve_level = max_t(int, 1, btrfs_root_level(root_item));\n\tmin_reserved = fs_info->nodesize * reserve_level * 2;\n\tmemset(&next_key, 0, sizeof(next_key));\n\n\twhile (1) {\n\t\tret = btrfs_block_rsv_refill(fs_info, rc->block_rsv,\n\t\t\t\t\t     min_reserved,\n\t\t\t\t\t     BTRFS_RESERVE_FLUSH_LIMIT);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\treloc_root->last_trans = trans->transid;\n\t\ttrans->block_rsv = rc->block_rsv;\n\n\t\treplaced = 0;\n\t\tmax_level = level;\n\n\t\tret = walk_down_reloc_tree(reloc_root, path, &level);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret > 0)\n\t\t\tbreak;\n\n\t\tif (!find_next_key(path, level, &key) &&\n\t\t    btrfs_comp_cpu_keys(&next_key, &key) >= 0) {\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tret = replace_path(trans, rc, root, reloc_root, path,\n\t\t\t\t\t   &next_key, level, max_level);\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret > 0) {\n\t\t\tlevel = ret;\n\t\t\tbtrfs_node_key_to_cpu(path->nodes[level], &key,\n\t\t\t\t\t      path->slots[level]);\n\t\t\treplaced = 1;\n\t\t}\n\n\t\tret = walk_up_reloc_tree(reloc_root, path, &level);\n\t\tif (ret > 0)\n\t\t\tbreak;\n\n\t\tBUG_ON(level == 0);\n\t\t \n\t\tbtrfs_node_key(path->nodes[level], &root_item->drop_progress,\n\t\t\t       path->slots[level]);\n\t\tbtrfs_set_root_drop_level(root_item, level);\n\n\t\tbtrfs_end_transaction_throttle(trans);\n\t\ttrans = NULL;\n\n\t\tbtrfs_btree_balance_dirty(fs_info);\n\n\t\tif (replaced && rc->stage == UPDATE_DATA_PTRS)\n\t\t\tinvalidate_extent_cache(root, &key, &next_key);\n\t}\n\n\t \n\tleaf = btrfs_lock_root_node(root);\n\tret = btrfs_cow_block(trans, root, leaf, NULL, 0, &leaf,\n\t\t\t      BTRFS_NESTING_COW);\n\tbtrfs_tree_unlock(leaf);\n\tfree_extent_buffer(leaf);\nout:\n\tbtrfs_free_path(path);\n\n\tif (ret == 0) {\n\t\tret = insert_dirty_subvol(trans, rc, root);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t}\n\n\tif (trans)\n\t\tbtrfs_end_transaction_throttle(trans);\n\n\tbtrfs_btree_balance_dirty(fs_info);\n\n\tif (replaced && rc->stage == UPDATE_DATA_PTRS)\n\t\tinvalidate_extent_cache(root, &key, &next_key);\n\n\treturn ret;\n}\n\nstatic noinline_for_stack\nint prepare_to_merge(struct reloc_control *rc, int err)\n{\n\tstruct btrfs_root *root = rc->extent_root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_trans_handle *trans;\n\tLIST_HEAD(reloc_roots);\n\tu64 num_bytes = 0;\n\tint ret;\n\n\tmutex_lock(&fs_info->reloc_mutex);\n\trc->merging_rsv_size += fs_info->nodesize * (BTRFS_MAX_LEVEL - 1) * 2;\n\trc->merging_rsv_size += rc->nodes_relocated * 2;\n\tmutex_unlock(&fs_info->reloc_mutex);\n\nagain:\n\tif (!err) {\n\t\tnum_bytes = rc->merging_rsv_size;\n\t\tret = btrfs_block_rsv_add(fs_info, rc->block_rsv, num_bytes,\n\t\t\t\t\t  BTRFS_RESERVE_FLUSH_ALL);\n\t\tif (ret)\n\t\t\terr = ret;\n\t}\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\tif (!err)\n\t\t\tbtrfs_block_rsv_release(fs_info, rc->block_rsv,\n\t\t\t\t\t\tnum_bytes, NULL);\n\t\treturn PTR_ERR(trans);\n\t}\n\n\tif (!err) {\n\t\tif (num_bytes != rc->merging_rsv_size) {\n\t\t\tbtrfs_end_transaction(trans);\n\t\t\tbtrfs_block_rsv_release(fs_info, rc->block_rsv,\n\t\t\t\t\t\tnum_bytes, NULL);\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\trc->merge_reloc_tree = 1;\n\n\twhile (!list_empty(&rc->reloc_roots)) {\n\t\treloc_root = list_entry(rc->reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\t\tlist_del_init(&reloc_root->root_list);\n\n\t\troot = btrfs_get_fs_root(fs_info, reloc_root->root_key.offset,\n\t\t\t\tfalse);\n\t\tif (IS_ERR(root)) {\n\t\t\t \n\t\t\tlist_add(&reloc_root->root_list, &reloc_roots);\n\t\t\tbtrfs_abort_transaction(trans, (int)PTR_ERR(root));\n\t\t\tif (!err)\n\t\t\t\terr = PTR_ERR(root);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(root->reloc_root != reloc_root)) {\n\t\t\tif (root->reloc_root) {\n\t\t\t\tbtrfs_err(fs_info,\n\"reloc tree mismatch, root %lld has reloc root key (%lld %u %llu) gen %llu, expect reloc root key (%lld %u %llu) gen %llu\",\n\t\t\t\t\t  root->root_key.objectid,\n\t\t\t\t\t  root->reloc_root->root_key.objectid,\n\t\t\t\t\t  root->reloc_root->root_key.type,\n\t\t\t\t\t  root->reloc_root->root_key.offset,\n\t\t\t\t\t  btrfs_root_generation(\n\t\t\t\t\t\t  &root->reloc_root->root_item),\n\t\t\t\t\t  reloc_root->root_key.objectid,\n\t\t\t\t\t  reloc_root->root_key.type,\n\t\t\t\t\t  reloc_root->root_key.offset,\n\t\t\t\t\t  btrfs_root_generation(\n\t\t\t\t\t\t  &reloc_root->root_item));\n\t\t\t} else {\n\t\t\t\tbtrfs_err(fs_info,\n\"reloc tree mismatch, root %lld has no reloc root, expect reloc root key (%lld %u %llu) gen %llu\",\n\t\t\t\t\t  root->root_key.objectid,\n\t\t\t\t\t  reloc_root->root_key.objectid,\n\t\t\t\t\t  reloc_root->root_key.type,\n\t\t\t\t\t  reloc_root->root_key.offset,\n\t\t\t\t\t  btrfs_root_generation(\n\t\t\t\t\t\t  &reloc_root->root_item));\n\t\t\t}\n\t\t\tlist_add(&reloc_root->root_list, &reloc_roots);\n\t\t\tbtrfs_put_root(root);\n\t\t\tbtrfs_abort_transaction(trans, -EUCLEAN);\n\t\t\tif (!err)\n\t\t\t\terr = -EUCLEAN;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!err)\n\t\t\tbtrfs_set_root_refs(&reloc_root->root_item, 1);\n\t\tret = btrfs_update_reloc_root(trans, root);\n\n\t\t \n\t\tlist_add(&reloc_root->root_list, &reloc_roots);\n\t\tbtrfs_put_root(root);\n\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tif (!err)\n\t\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_splice(&reloc_roots, &rc->reloc_roots);\n\n\tif (!err)\n\t\terr = btrfs_commit_transaction(trans);\n\telse\n\t\tbtrfs_end_transaction(trans);\n\treturn err;\n}\n\nstatic noinline_for_stack\nvoid free_reloc_roots(struct list_head *list)\n{\n\tstruct btrfs_root *reloc_root, *tmp;\n\n\tlist_for_each_entry_safe(reloc_root, tmp, list, root_list)\n\t\t__del_reloc_root(reloc_root);\n}\n\nstatic noinline_for_stack\nvoid merge_reloc_roots(struct reloc_control *rc)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *reloc_root;\n\tLIST_HEAD(reloc_roots);\n\tint found = 0;\n\tint ret = 0;\nagain:\n\troot = rc->extent_root;\n\n\t \n\tmutex_lock(&fs_info->reloc_mutex);\n\tlist_splice_init(&rc->reloc_roots, &reloc_roots);\n\tmutex_unlock(&fs_info->reloc_mutex);\n\n\twhile (!list_empty(&reloc_roots)) {\n\t\tfound = 1;\n\t\treloc_root = list_entry(reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\n\t\troot = btrfs_get_fs_root(fs_info, reloc_root->root_key.offset,\n\t\t\t\t\t false);\n\t\tif (btrfs_root_refs(&reloc_root->root_item) > 0) {\n\t\t\tif (WARN_ON(IS_ERR(root))) {\n\t\t\t\t \n\t\t\t\tret = PTR_ERR(root);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (WARN_ON(root->reloc_root != reloc_root)) {\n\t\t\t\t \n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = merge_reloc_root(rc, root);\n\t\t\tbtrfs_put_root(root);\n\t\t\tif (ret) {\n\t\t\t\tif (list_empty(&reloc_root->root_list))\n\t\t\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t\t\t      &reloc_roots);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!IS_ERR(root)) {\n\t\t\t\tif (root->reloc_root == reloc_root) {\n\t\t\t\t\troot->reloc_root = NULL;\n\t\t\t\t\tbtrfs_put_root(reloc_root);\n\t\t\t\t}\n\t\t\t\tclear_bit(BTRFS_ROOT_DEAD_RELOC_TREE,\n\t\t\t\t\t  &root->state);\n\t\t\t\tbtrfs_put_root(root);\n\t\t\t}\n\n\t\t\tlist_del_init(&reloc_root->root_list);\n\t\t\t \n\t\t\tlist_add_tail(&reloc_root->reloc_dirty_list,\n\t\t\t\t      &rc->dirty_subvol_roots);\n\t\t}\n\t}\n\n\tif (found) {\n\t\tfound = 0;\n\t\tgoto again;\n\t}\nout:\n\tif (ret) {\n\t\tbtrfs_handle_fs_error(fs_info, ret, NULL);\n\t\tfree_reloc_roots(&reloc_roots);\n\n\t\t \n\t\tmutex_lock(&fs_info->reloc_mutex);\n\t\tlist_splice_init(&rc->reloc_roots, &reloc_roots);\n\t\tmutex_unlock(&fs_info->reloc_mutex);\n\t\tfree_reloc_roots(&reloc_roots);\n\t}\n\n\t \n}\n\nstatic void free_block_list(struct rb_root *blocks)\n{\n\tstruct tree_block *block;\n\tstruct rb_node *rb_node;\n\twhile ((rb_node = rb_first(blocks))) {\n\t\tblock = rb_entry(rb_node, struct tree_block, rb_node);\n\t\trb_erase(rb_node, blocks);\n\t\tkfree(block);\n\t}\n}\n\nstatic int record_reloc_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *reloc_root)\n{\n\tstruct btrfs_fs_info *fs_info = reloc_root->fs_info;\n\tstruct btrfs_root *root;\n\tint ret;\n\n\tif (reloc_root->last_trans == trans->transid)\n\t\treturn 0;\n\n\troot = btrfs_get_fs_root(fs_info, reloc_root->root_key.offset, false);\n\n\t \n\tif (IS_ERR(root)) {\n\t\tASSERT(0);\n\t\treturn PTR_ERR(root);\n\t}\n\tif (root->reloc_root != reloc_root) {\n\t\tASSERT(0);\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"root %llu has two reloc roots associated with it\",\n\t\t\t  reloc_root->root_key.offset);\n\t\tbtrfs_put_root(root);\n\t\treturn -EUCLEAN;\n\t}\n\tret = btrfs_record_root_in_trans(trans, root);\n\tbtrfs_put_root(root);\n\n\treturn ret;\n}\n\nstatic noinline_for_stack\nstruct btrfs_root *select_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct reloc_control *rc,\n\t\t\t\t     struct btrfs_backref_node *node,\n\t\t\t\t     struct btrfs_backref_edge *edges[])\n{\n\tstruct btrfs_backref_node *next;\n\tstruct btrfs_root *root;\n\tint index = 0;\n\tint ret;\n\n\tnext = node;\n\twhile (1) {\n\t\tcond_resched();\n\t\tnext = walk_up_backref(next, edges, &index);\n\t\troot = next->root;\n\n\t\t \n\t\tif (!root) {\n\t\t\tASSERT(0);\n\t\t\tbtrfs_err(trans->fs_info,\n\t\t\"bytenr %llu doesn't have a backref path ending in a root\",\n\t\t\t\t  node->bytenr);\n\t\t\treturn ERR_PTR(-EUCLEAN);\n\t\t}\n\t\tif (!test_bit(BTRFS_ROOT_SHAREABLE, &root->state)) {\n\t\t\tASSERT(0);\n\t\t\tbtrfs_err(trans->fs_info,\n\t\"bytenr %llu has multiple refs with one ending in a non-shareable root\",\n\t\t\t\t  node->bytenr);\n\t\t\treturn ERR_PTR(-EUCLEAN);\n\t\t}\n\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\t\tret = record_reloc_root_in_trans(trans, root);\n\t\t\tif (ret)\n\t\t\t\treturn ERR_PTR(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = btrfs_record_root_in_trans(trans, root);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\troot = root->reloc_root;\n\n\t\t \n\t\tif (!root)\n\t\t\treturn ERR_PTR(-ENOENT);\n\n\t\tif (next->new_bytenr != root->node->start) {\n\t\t\t \n\t\t\tASSERT(next->new_bytenr == 0);\n\t\t\tASSERT(list_empty(&next->list));\n\t\t\tif (next->new_bytenr || !list_empty(&next->list)) {\n\t\t\t\tbtrfs_err(trans->fs_info,\n\t\"bytenr %llu possibly has multiple roots pointing at the same bytenr %llu\",\n\t\t\t\t\t  node->bytenr, next->bytenr);\n\t\t\t\treturn ERR_PTR(-EUCLEAN);\n\t\t\t}\n\n\t\t\tnext->new_bytenr = root->node->start;\n\t\t\tbtrfs_put_root(next->root);\n\t\t\tnext->root = btrfs_grab_root(root);\n\t\t\tASSERT(next->root);\n\t\t\tlist_add_tail(&next->list,\n\t\t\t\t      &rc->backref_cache.changed);\n\t\t\tmark_block_processed(rc, next);\n\t\t\tbreak;\n\t\t}\n\n\t\tWARN_ON(1);\n\t\troot = NULL;\n\t\tnext = walk_down_backref(edges, &index);\n\t\tif (!next || next->level <= node->level)\n\t\t\tbreak;\n\t}\n\tif (!root) {\n\t\t \n\t\tASSERT(0);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tnext = node;\n\t \n\twhile (1) {\n\t\trc->backref_cache.path[next->level] = next;\n\t\tif (--index < 0)\n\t\t\tbreak;\n\t\tnext = edges[index]->node[UPPER];\n\t}\n\treturn root;\n}\n\n \nstatic noinline_for_stack\nstruct btrfs_root *select_one_root(struct btrfs_backref_node *node)\n{\n\tstruct btrfs_backref_node *next;\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *fs_root = NULL;\n\tstruct btrfs_backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tint index = 0;\n\n\tnext = node;\n\twhile (1) {\n\t\tcond_resched();\n\t\tnext = walk_up_backref(next, edges, &index);\n\t\troot = next->root;\n\n\t\t \n\t\tif (!root)\n\t\t\treturn ERR_PTR(-EUCLEAN);\n\n\t\t \n\t\tif (!test_bit(BTRFS_ROOT_SHAREABLE, &root->state))\n\t\t\treturn root;\n\n\t\tif (root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID)\n\t\t\tfs_root = root;\n\n\t\tif (next != node)\n\t\t\treturn NULL;\n\n\t\tnext = walk_down_backref(edges, &index);\n\t\tif (!next || next->level <= node->level)\n\t\t\tbreak;\n\t}\n\n\tif (!fs_root)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn fs_root;\n}\n\nstatic noinline_for_stack\nu64 calcu_metadata_size(struct reloc_control *rc,\n\t\t\tstruct btrfs_backref_node *node, int reserve)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\tstruct btrfs_backref_node *next = node;\n\tstruct btrfs_backref_edge *edge;\n\tstruct btrfs_backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tu64 num_bytes = 0;\n\tint index = 0;\n\n\tBUG_ON(reserve && node->processed);\n\n\twhile (next) {\n\t\tcond_resched();\n\t\twhile (1) {\n\t\t\tif (next->processed && (reserve || next != node))\n\t\t\t\tbreak;\n\n\t\t\tnum_bytes += fs_info->nodesize;\n\n\t\t\tif (list_empty(&next->upper))\n\t\t\t\tbreak;\n\n\t\t\tedge = list_entry(next->upper.next,\n\t\t\t\t\tstruct btrfs_backref_edge, list[LOWER]);\n\t\t\tedges[index++] = edge;\n\t\t\tnext = edge->node[UPPER];\n\t\t}\n\t\tnext = walk_down_backref(edges, &index);\n\t}\n\treturn num_bytes;\n}\n\nstatic int reserve_metadata_space(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct reloc_control *rc,\n\t\t\t\t  struct btrfs_backref_node *node)\n{\n\tstruct btrfs_root *root = rc->extent_root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 num_bytes;\n\tint ret;\n\tu64 tmp;\n\n\tnum_bytes = calcu_metadata_size(rc, node, 1) * 2;\n\n\ttrans->block_rsv = rc->block_rsv;\n\trc->reserved_bytes += num_bytes;\n\n\t \n\tret = btrfs_block_rsv_refill(fs_info, rc->block_rsv, num_bytes,\n\t\t\t\t     BTRFS_RESERVE_FLUSH_LIMIT);\n\tif (ret) {\n\t\ttmp = fs_info->nodesize * RELOCATION_RESERVED_NODES;\n\t\twhile (tmp <= rc->reserved_bytes)\n\t\t\ttmp <<= 1;\n\t\t \n\t\trc->block_rsv->size = tmp + fs_info->nodesize *\n\t\t\t\t      RELOCATION_RESERVED_NODES;\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int do_relocation(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc,\n\t\t\t struct btrfs_backref_node *node,\n\t\t\t struct btrfs_key *key,\n\t\t\t struct btrfs_path *path, int lowest)\n{\n\tstruct btrfs_backref_node *upper;\n\tstruct btrfs_backref_edge *edge;\n\tstruct btrfs_backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tstruct btrfs_root *root;\n\tstruct extent_buffer *eb;\n\tu32 blocksize;\n\tu64 bytenr;\n\tint slot;\n\tint ret = 0;\n\n\t \n\tASSERT(!lowest || !node->eb);\n\n\tpath->lowest_level = node->level + 1;\n\trc->backref_cache.path[node->level] = node;\n\tlist_for_each_entry(edge, &node->upper, list[LOWER]) {\n\t\tstruct btrfs_ref ref = { 0 };\n\n\t\tcond_resched();\n\n\t\tupper = edge->node[UPPER];\n\t\troot = select_reloc_root(trans, rc, upper, edges);\n\t\tif (IS_ERR(root)) {\n\t\t\tret = PTR_ERR(root);\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (upper->eb && !upper->locked) {\n\t\t\tif (!lowest) {\n\t\t\t\tret = btrfs_bin_search(upper->eb, 0, key, &slot);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto next;\n\t\t\t\tBUG_ON(ret);\n\t\t\t\tbytenr = btrfs_node_blockptr(upper->eb, slot);\n\t\t\t\tif (node->eb->start == bytenr)\n\t\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tbtrfs_backref_drop_node_buffer(upper);\n\t\t}\n\n\t\tif (!upper->eb) {\n\t\t\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\t\t\tif (ret) {\n\t\t\t\tif (ret > 0)\n\t\t\t\t\tret = -ENOENT;\n\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!upper->eb) {\n\t\t\t\tupper->eb = path->nodes[upper->level];\n\t\t\t\tpath->nodes[upper->level] = NULL;\n\t\t\t} else {\n\t\t\t\tBUG_ON(upper->eb != path->nodes[upper->level]);\n\t\t\t}\n\n\t\t\tupper->locked = 1;\n\t\t\tpath->locks[upper->level] = 0;\n\n\t\t\tslot = path->slots[upper->level];\n\t\t\tbtrfs_release_path(path);\n\t\t} else {\n\t\t\tret = btrfs_bin_search(upper->eb, 0, key, &slot);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto next;\n\t\t\tBUG_ON(ret);\n\t\t}\n\n\t\tbytenr = btrfs_node_blockptr(upper->eb, slot);\n\t\tif (lowest) {\n\t\t\tif (bytenr != node->bytenr) {\n\t\t\t\tbtrfs_err(root->fs_info,\n\t\t\"lowest leaf/node mismatch: bytenr %llu node->bytenr %llu slot %d upper %llu\",\n\t\t\t\t\t  bytenr, node->bytenr, slot,\n\t\t\t\t\t  upper->eb->start);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t} else {\n\t\t\tif (node->eb->start == bytenr)\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tblocksize = root->fs_info->nodesize;\n\t\teb = btrfs_read_node_slot(upper->eb, slot);\n\t\tif (IS_ERR(eb)) {\n\t\t\tret = PTR_ERR(eb);\n\t\t\tgoto next;\n\t\t}\n\t\tbtrfs_tree_lock(eb);\n\n\t\tif (!node->eb) {\n\t\t\tret = btrfs_cow_block(trans, root, eb, upper->eb,\n\t\t\t\t\t      slot, &eb, BTRFS_NESTING_COW);\n\t\t\tbtrfs_tree_unlock(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto next;\n\t\t\t \n\t\t\tASSERT(node->eb == eb);\n\t\t} else {\n\t\t\tbtrfs_set_node_blockptr(upper->eb, slot,\n\t\t\t\t\t\tnode->eb->start);\n\t\t\tbtrfs_set_node_ptr_generation(upper->eb, slot,\n\t\t\t\t\t\t      trans->transid);\n\t\t\tbtrfs_mark_buffer_dirty(trans, upper->eb);\n\n\t\t\tbtrfs_init_generic_ref(&ref, BTRFS_ADD_DELAYED_REF,\n\t\t\t\t\t       node->eb->start, blocksize,\n\t\t\t\t\t       upper->eb->start);\n\t\t\tbtrfs_init_tree_ref(&ref, node->level,\n\t\t\t\t\t    btrfs_header_owner(upper->eb),\n\t\t\t\t\t    root->root_key.objectid, false);\n\t\t\tret = btrfs_inc_extent_ref(trans, &ref);\n\t\t\tif (!ret)\n\t\t\t\tret = btrfs_drop_subtree(trans, root, eb,\n\t\t\t\t\t\t\t upper->eb);\n\t\t\tif (ret)\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t}\nnext:\n\t\tif (!upper->pending)\n\t\t\tbtrfs_backref_drop_node_buffer(upper);\n\t\telse\n\t\t\tbtrfs_backref_unlock_node_buffer(upper);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (!ret && node->pending) {\n\t\tbtrfs_backref_drop_node_buffer(node);\n\t\tlist_move_tail(&node->list, &rc->backref_cache.changed);\n\t\tnode->pending = 0;\n\t}\n\n\tpath->lowest_level = 0;\n\n\t \n\tASSERT(ret != -ENOSPC);\n\treturn ret;\n}\n\nstatic int link_to_upper(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc,\n\t\t\t struct btrfs_backref_node *node,\n\t\t\t struct btrfs_path *path)\n{\n\tstruct btrfs_key key;\n\n\tbtrfs_node_key_to_cpu(node->eb, &key, 0);\n\treturn do_relocation(trans, rc, node, &key, path, 0);\n}\n\nstatic int finish_pending_nodes(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct reloc_control *rc,\n\t\t\t\tstruct btrfs_path *path, int err)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_backref_cache *cache = &rc->backref_cache;\n\tstruct btrfs_backref_node *node;\n\tint level;\n\tint ret;\n\n\tfor (level = 0; level < BTRFS_MAX_LEVEL; level++) {\n\t\twhile (!list_empty(&cache->pending[level])) {\n\t\t\tnode = list_entry(cache->pending[level].next,\n\t\t\t\t\t  struct btrfs_backref_node, list);\n\t\t\tlist_move_tail(&node->list, &list);\n\t\t\tBUG_ON(!node->pending);\n\n\t\t\tif (!err) {\n\t\t\t\tret = link_to_upper(trans, rc, node, path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\terr = ret;\n\t\t\t}\n\t\t}\n\t\tlist_splice_init(&list, &cache->pending[level]);\n\t}\n\treturn err;\n}\n\n \nstatic void update_processed_blocks(struct reloc_control *rc,\n\t\t\t\t    struct btrfs_backref_node *node)\n{\n\tstruct btrfs_backref_node *next = node;\n\tstruct btrfs_backref_edge *edge;\n\tstruct btrfs_backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tint index = 0;\n\n\twhile (next) {\n\t\tcond_resched();\n\t\twhile (1) {\n\t\t\tif (next->processed)\n\t\t\t\tbreak;\n\n\t\t\tmark_block_processed(rc, next);\n\n\t\t\tif (list_empty(&next->upper))\n\t\t\t\tbreak;\n\n\t\t\tedge = list_entry(next->upper.next,\n\t\t\t\t\tstruct btrfs_backref_edge, list[LOWER]);\n\t\t\tedges[index++] = edge;\n\t\t\tnext = edge->node[UPPER];\n\t\t}\n\t\tnext = walk_down_backref(edges, &index);\n\t}\n}\n\nstatic int tree_block_processed(u64 bytenr, struct reloc_control *rc)\n{\n\tu32 blocksize = rc->extent_root->fs_info->nodesize;\n\n\tif (test_range_bit(&rc->processed_blocks, bytenr,\n\t\t\t   bytenr + blocksize - 1, EXTENT_DIRTY, 1, NULL))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int get_tree_block_key(struct btrfs_fs_info *fs_info,\n\t\t\t      struct tree_block *block)\n{\n\tstruct btrfs_tree_parent_check check = {\n\t\t.level = block->level,\n\t\t.owner_root = block->owner,\n\t\t.transid = block->key.offset\n\t};\n\tstruct extent_buffer *eb;\n\n\teb = read_tree_block(fs_info, block->bytenr, &check);\n\tif (IS_ERR(eb))\n\t\treturn PTR_ERR(eb);\n\tif (!extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\treturn -EIO;\n\t}\n\tif (block->level == 0)\n\t\tbtrfs_item_key_to_cpu(eb, &block->key, 0);\n\telse\n\t\tbtrfs_node_key_to_cpu(eb, &block->key, 0);\n\tfree_extent_buffer(eb);\n\tblock->key_ready = 1;\n\treturn 0;\n}\n\n \nstatic int relocate_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct reloc_control *rc,\n\t\t\t\tstruct btrfs_backref_node *node,\n\t\t\t\tstruct btrfs_key *key,\n\t\t\t\tstruct btrfs_path *path)\n{\n\tstruct btrfs_root *root;\n\tint ret = 0;\n\n\tif (!node)\n\t\treturn 0;\n\n\t \n\tret = reserve_metadata_space(trans, rc, node);\n\tif (ret)\n\t\tgoto out;\n\n\tBUG_ON(node->processed);\n\troot = select_one_root(node);\n\tif (IS_ERR(root)) {\n\t\tret = PTR_ERR(root);\n\n\t\t \n\t\tASSERT(ret == -ENOENT);\n\t\tif (ret == -ENOENT) {\n\t\t\tret = 0;\n\t\t\tupdate_processed_blocks(rc, node);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (root) {\n\t\tif (test_bit(BTRFS_ROOT_SHAREABLE, &root->state)) {\n\t\t\t \n\t\t\tASSERT(node->new_bytenr == 0);\n\t\t\tASSERT(list_empty(&node->list));\n\t\t\tif (node->new_bytenr || !list_empty(&node->list)) {\n\t\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t  \"bytenr %llu has improper references to it\",\n\t\t\t\t\t  node->bytenr);\n\t\t\t\tret = -EUCLEAN;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = btrfs_record_root_in_trans(trans, root);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\t \n\t\t\tif (!root->reloc_root) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\troot = root->reloc_root;\n\t\t\tnode->new_bytenr = root->node->start;\n\t\t\tbtrfs_put_root(node->root);\n\t\t\tnode->root = btrfs_grab_root(root);\n\t\t\tASSERT(node->root);\n\t\t\tlist_add_tail(&node->list, &rc->backref_cache.changed);\n\t\t} else {\n\t\t\tpath->lowest_level = node->level;\n\t\t\tif (root == root->fs_info->chunk_root)\n\t\t\t\tbtrfs_reserve_chunk_metadata(trans, false);\n\t\t\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\t\t\tbtrfs_release_path(path);\n\t\t\tif (root == root->fs_info->chunk_root)\n\t\t\t\tbtrfs_trans_release_chunk_metadata(trans);\n\t\t\tif (ret > 0)\n\t\t\t\tret = 0;\n\t\t}\n\t\tif (!ret)\n\t\t\tupdate_processed_blocks(rc, node);\n\t} else {\n\t\tret = do_relocation(trans, rc, node, key, path, 1);\n\t}\nout:\n\tif (ret || node->level == 0 || node->cowonly)\n\t\tbtrfs_backref_cleanup_node(&rc->backref_cache, node);\n\treturn ret;\n}\n\n \nstatic noinline_for_stack\nint relocate_tree_blocks(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc, struct rb_root *blocks)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\tstruct btrfs_backref_node *node;\n\tstruct btrfs_path *path;\n\tstruct tree_block *block;\n\tstruct tree_block *next;\n\tint ret;\n\tint err = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_blocks;\n\t}\n\n\t \n\trbtree_postorder_for_each_entry_safe(block, next, blocks, rb_node) {\n\t\tif (!block->key_ready)\n\t\t\tbtrfs_readahead_tree_block(fs_info, block->bytenr,\n\t\t\t\t\t\t   block->owner, 0,\n\t\t\t\t\t\t   block->level);\n\t}\n\n\t \n\trbtree_postorder_for_each_entry_safe(block, next, blocks, rb_node) {\n\t\tif (!block->key_ready) {\n\t\t\terr = get_tree_block_key(fs_info, block);\n\t\t\tif (err)\n\t\t\t\tgoto out_free_path;\n\t\t}\n\t}\n\n\t \n\trbtree_postorder_for_each_entry_safe(block, next, blocks, rb_node) {\n\t\tnode = build_backref_tree(trans, rc, &block->key,\n\t\t\t\t\t  block->level, block->bytenr);\n\t\tif (IS_ERR(node)) {\n\t\t\terr = PTR_ERR(node);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = relocate_tree_block(trans, rc, node, &block->key,\n\t\t\t\t\t  path);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\terr = finish_pending_nodes(trans, rc, path, err);\n\nout_free_path:\n\tbtrfs_free_path(path);\nout_free_blocks:\n\tfree_block_list(blocks);\n\treturn err;\n}\n\nstatic noinline_for_stack int prealloc_file_extent_cluster(\n\t\t\t\tstruct btrfs_inode *inode,\n\t\t\t\tstruct file_extent_cluster *cluster)\n{\n\tu64 alloc_hint = 0;\n\tu64 start;\n\tu64 end;\n\tu64 offset = inode->index_cnt;\n\tu64 num_bytes;\n\tint nr;\n\tint ret = 0;\n\tu64 i_size = i_size_read(&inode->vfs_inode);\n\tu64 prealloc_start = cluster->start - offset;\n\tu64 prealloc_end = cluster->end - offset;\n\tu64 cur_offset = prealloc_start;\n\n\t \n\tif (!PAGE_ALIGNED(i_size)) {\n\t\tstruct address_space *mapping = inode->vfs_inode.i_mapping;\n\t\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\t\tconst u32 sectorsize = fs_info->sectorsize;\n\t\tstruct page *page;\n\n\t\tASSERT(sectorsize < PAGE_SIZE);\n\t\tASSERT(IS_ALIGNED(i_size, sectorsize));\n\n\t\t \n\t\tret = filemap_write_and_wait(mapping);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tclear_extent_bits(&inode->io_tree, i_size,\n\t\t\t\t  round_up(i_size, PAGE_SIZE) - 1,\n\t\t\t\t  EXTENT_UPTODATE);\n\t\tpage = find_lock_page(mapping, i_size >> PAGE_SHIFT);\n\t\t \n\t\tif (page) {\n\t\t\tbtrfs_subpage_clear_uptodate(fs_info, page, i_size,\n\t\t\t\t\tround_up(i_size, PAGE_SIZE) - i_size);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t}\n\n\tBUG_ON(cluster->start != cluster->boundary[0]);\n\tret = btrfs_alloc_data_chunk_ondemand(inode,\n\t\t\t\t\t      prealloc_end + 1 - prealloc_start);\n\tif (ret)\n\t\treturn ret;\n\n\tbtrfs_inode_lock(inode, 0);\n\tfor (nr = 0; nr < cluster->nr; nr++) {\n\t\tstruct extent_state *cached_state = NULL;\n\n\t\tstart = cluster->boundary[nr] - offset;\n\t\tif (nr + 1 < cluster->nr)\n\t\t\tend = cluster->boundary[nr + 1] - 1 - offset;\n\t\telse\n\t\t\tend = cluster->end - offset;\n\n\t\tlock_extent(&inode->io_tree, start, end, &cached_state);\n\t\tnum_bytes = end + 1 - start;\n\t\tret = btrfs_prealloc_file_range(&inode->vfs_inode, 0, start,\n\t\t\t\t\t\tnum_bytes, num_bytes,\n\t\t\t\t\t\tend + 1, &alloc_hint);\n\t\tcur_offset = end + 1;\n\t\tunlock_extent(&inode->io_tree, start, end, &cached_state);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tbtrfs_inode_unlock(inode, 0);\n\n\tif (cur_offset < prealloc_end)\n\t\tbtrfs_free_reserved_data_space_noquota(inode->root->fs_info,\n\t\t\t\t\t       prealloc_end + 1 - cur_offset);\n\treturn ret;\n}\n\nstatic noinline_for_stack int setup_relocation_extent_mapping(struct inode *inode,\n\t\t\t\tu64 start, u64 end, u64 block_start)\n{\n\tstruct extent_map *em;\n\tstruct extent_state *cached_state = NULL;\n\tint ret = 0;\n\n\tem = alloc_extent_map();\n\tif (!em)\n\t\treturn -ENOMEM;\n\n\tem->start = start;\n\tem->len = end + 1 - start;\n\tem->block_len = em->len;\n\tem->block_start = block_start;\n\tset_bit(EXTENT_FLAG_PINNED, &em->flags);\n\n\tlock_extent(&BTRFS_I(inode)->io_tree, start, end, &cached_state);\n\tret = btrfs_replace_extent_map_range(BTRFS_I(inode), em, false);\n\tunlock_extent(&BTRFS_I(inode)->io_tree, start, end, &cached_state);\n\tfree_extent_map(em);\n\n\treturn ret;\n}\n\n \nnoinline int btrfs_should_cancel_balance(struct btrfs_fs_info *fs_info)\n{\n\treturn atomic_read(&fs_info->balance_cancel_req) ||\n\t\tatomic_read(&fs_info->reloc_cancel_req) ||\n\t\tfatal_signal_pending(current);\n}\nALLOW_ERROR_INJECTION(btrfs_should_cancel_balance, TRUE);\n\nstatic u64 get_cluster_boundary_end(struct file_extent_cluster *cluster,\n\t\t\t\t    int cluster_nr)\n{\n\t \n\tif (cluster_nr >= cluster->nr - 1)\n\t\treturn cluster->end;\n\n\t \n\treturn cluster->boundary[cluster_nr + 1] - 1;\n}\n\nstatic int relocate_one_page(struct inode *inode, struct file_ra_state *ra,\n\t\t\t     struct file_extent_cluster *cluster,\n\t\t\t     int *cluster_nr, unsigned long page_index)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tu64 offset = BTRFS_I(inode)->index_cnt;\n\tconst unsigned long last_index = (cluster->end - offset) >> PAGE_SHIFT;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\tstruct page *page;\n\tu64 page_start;\n\tu64 page_end;\n\tu64 cur;\n\tint ret;\n\n\tASSERT(page_index <= last_index);\n\tpage = find_lock_page(inode->i_mapping, page_index);\n\tif (!page) {\n\t\tpage_cache_sync_readahead(inode->i_mapping, ra, NULL,\n\t\t\t\tpage_index, last_index + 1 - page_index);\n\t\tpage = find_or_create_page(inode->i_mapping, page_index, mask);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (PageReadahead(page))\n\t\tpage_cache_async_readahead(inode->i_mapping, ra, NULL,\n\t\t\t\tpage_folio(page), page_index,\n\t\t\t\tlast_index + 1 - page_index);\n\n\tif (!PageUptodate(page)) {\n\t\tbtrfs_read_folio(NULL, page_folio(page));\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\tret = -EIO;\n\t\t\tgoto release_page;\n\t\t}\n\t}\n\n\t \n\tret = set_page_extent_mapped(page);\n\tif (ret < 0)\n\t\tgoto release_page;\n\n\tpage_start = page_offset(page);\n\tpage_end = page_start + PAGE_SIZE - 1;\n\n\t \n\tcur = max(page_start, cluster->boundary[*cluster_nr] - offset);\n\twhile (cur <= page_end) {\n\t\tstruct extent_state *cached_state = NULL;\n\t\tu64 extent_start = cluster->boundary[*cluster_nr] - offset;\n\t\tu64 extent_end = get_cluster_boundary_end(cluster,\n\t\t\t\t\t\t*cluster_nr) - offset;\n\t\tu64 clamped_start = max(page_start, extent_start);\n\t\tu64 clamped_end = min(page_end, extent_end);\n\t\tu32 clamped_len = clamped_end + 1 - clamped_start;\n\n\t\t \n\t\tret = btrfs_delalloc_reserve_metadata(BTRFS_I(inode),\n\t\t\t\t\t\t      clamped_len, clamped_len,\n\t\t\t\t\t\t      false);\n\t\tif (ret)\n\t\t\tgoto release_page;\n\n\t\t \n\t\tlock_extent(&BTRFS_I(inode)->io_tree, clamped_start, clamped_end,\n\t\t\t    &cached_state);\n\t\tret = btrfs_set_extent_delalloc(BTRFS_I(inode), clamped_start,\n\t\t\t\t\t\tclamped_end, 0, &cached_state);\n\t\tif (ret) {\n\t\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t clamped_start, clamped_end,\n\t\t\t\t\t EXTENT_LOCKED | EXTENT_BOUNDARY,\n\t\t\t\t\t &cached_state);\n\t\t\tbtrfs_delalloc_release_metadata(BTRFS_I(inode),\n\t\t\t\t\t\t\tclamped_len, true);\n\t\t\tbtrfs_delalloc_release_extents(BTRFS_I(inode),\n\t\t\t\t\t\t       clamped_len);\n\t\t\tgoto release_page;\n\t\t}\n\t\tbtrfs_page_set_dirty(fs_info, page, clamped_start, clamped_len);\n\n\t\t \n\t\tif (in_range(cluster->boundary[*cluster_nr] - offset,\n\t\t\t     page_start, PAGE_SIZE)) {\n\t\t\tu64 boundary_start = cluster->boundary[*cluster_nr] -\n\t\t\t\t\t\toffset;\n\t\t\tu64 boundary_end = boundary_start +\n\t\t\t\t\t   fs_info->sectorsize - 1;\n\n\t\t\tset_extent_bit(&BTRFS_I(inode)->io_tree,\n\t\t\t\t       boundary_start, boundary_end,\n\t\t\t\t       EXTENT_BOUNDARY, NULL);\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, clamped_start, clamped_end,\n\t\t\t      &cached_state);\n\t\tbtrfs_delalloc_release_extents(BTRFS_I(inode), clamped_len);\n\t\tcur += clamped_len;\n\n\t\t \n\t\tif (cur >= extent_end) {\n\t\t\t(*cluster_nr)++;\n\t\t\t \n\t\t\tif (*cluster_nr >= cluster->nr)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tunlock_page(page);\n\tput_page(page);\n\n\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\tbtrfs_throttle(fs_info);\n\tif (btrfs_should_cancel_balance(fs_info))\n\t\tret = -ECANCELED;\n\treturn ret;\n\nrelease_page:\n\tunlock_page(page);\n\tput_page(page);\n\treturn ret;\n}\n\nstatic int relocate_file_extent_cluster(struct inode *inode,\n\t\t\t\t\tstruct file_extent_cluster *cluster)\n{\n\tu64 offset = BTRFS_I(inode)->index_cnt;\n\tunsigned long index;\n\tunsigned long last_index;\n\tstruct file_ra_state *ra;\n\tint cluster_nr = 0;\n\tint ret = 0;\n\n\tif (!cluster->nr)\n\t\treturn 0;\n\n\tra = kzalloc(sizeof(*ra), GFP_NOFS);\n\tif (!ra)\n\t\treturn -ENOMEM;\n\n\tret = prealloc_file_extent_cluster(BTRFS_I(inode), cluster);\n\tif (ret)\n\t\tgoto out;\n\n\tfile_ra_state_init(ra, inode->i_mapping);\n\n\tret = setup_relocation_extent_mapping(inode, cluster->start - offset,\n\t\t\t\t   cluster->end - offset, cluster->start);\n\tif (ret)\n\t\tgoto out;\n\n\tlast_index = (cluster->end - offset) >> PAGE_SHIFT;\n\tfor (index = (cluster->start - offset) >> PAGE_SHIFT;\n\t     index <= last_index && !ret; index++)\n\t\tret = relocate_one_page(inode, ra, cluster, &cluster_nr, index);\n\tif (ret == 0)\n\t\tWARN_ON(cluster_nr != cluster->nr);\nout:\n\tkfree(ra);\n\treturn ret;\n}\n\nstatic noinline_for_stack\nint relocate_data_extent(struct inode *inode, struct btrfs_key *extent_key,\n\t\t\t struct file_extent_cluster *cluster)\n{\n\tint ret;\n\n\tif (cluster->nr > 0 && extent_key->objectid != cluster->end + 1) {\n\t\tret = relocate_file_extent_cluster(inode, cluster);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcluster->nr = 0;\n\t}\n\n\tif (!cluster->nr)\n\t\tcluster->start = extent_key->objectid;\n\telse\n\t\tBUG_ON(cluster->nr >= MAX_EXTENTS);\n\tcluster->end = extent_key->objectid + extent_key->offset - 1;\n\tcluster->boundary[cluster->nr] = extent_key->objectid;\n\tcluster->nr++;\n\n\tif (cluster->nr >= MAX_EXTENTS) {\n\t\tret = relocate_file_extent_cluster(inode, cluster);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcluster->nr = 0;\n\t}\n\treturn 0;\n}\n\n \nstatic int add_tree_block(struct reloc_control *rc,\n\t\t\t  struct btrfs_key *extent_key,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct rb_root *blocks)\n{\n\tstruct extent_buffer *eb;\n\tstruct btrfs_extent_item *ei;\n\tstruct btrfs_tree_block_info *bi;\n\tstruct tree_block *block;\n\tstruct rb_node *rb_node;\n\tu32 item_size;\n\tint level = -1;\n\tu64 generation;\n\tu64 owner = 0;\n\n\teb =  path->nodes[0];\n\titem_size = btrfs_item_size(eb, path->slots[0]);\n\n\tif (extent_key->type == BTRFS_METADATA_ITEM_KEY ||\n\t    item_size >= sizeof(*ei) + sizeof(*bi)) {\n\t\tunsigned long ptr = 0, end;\n\n\t\tei = btrfs_item_ptr(eb, path->slots[0],\n\t\t\t\tstruct btrfs_extent_item);\n\t\tend = (unsigned long)ei + item_size;\n\t\tif (extent_key->type == BTRFS_EXTENT_ITEM_KEY) {\n\t\t\tbi = (struct btrfs_tree_block_info *)(ei + 1);\n\t\t\tlevel = btrfs_tree_block_level(eb, bi);\n\t\t\tptr = (unsigned long)(bi + 1);\n\t\t} else {\n\t\t\tlevel = (int)extent_key->offset;\n\t\t\tptr = (unsigned long)(ei + 1);\n\t\t}\n\t\tgeneration = btrfs_extent_generation(eb, ei);\n\n\t\t \n\t\tif (btrfs_extent_refs(eb, ei) == 1 &&\n\t\t    !(btrfs_extent_flags(eb, ei) &\n\t\t      BTRFS_BLOCK_FLAG_FULL_BACKREF) &&\n\t\t    ptr < end) {\n\t\t\tstruct btrfs_extent_inline_ref *iref;\n\t\t\tint type;\n\n\t\t\tiref = (struct btrfs_extent_inline_ref *)ptr;\n\t\t\ttype = btrfs_get_extent_inline_ref_type(eb, iref,\n\t\t\t\t\t\t\tBTRFS_REF_TYPE_BLOCK);\n\t\t\tif (type == BTRFS_REF_TYPE_INVALID)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (type == BTRFS_TREE_BLOCK_REF_KEY)\n\t\t\t\towner = btrfs_extent_inline_ref_offset(eb, iref);\n\t\t}\n\t} else {\n\t\tbtrfs_print_leaf(eb);\n\t\tbtrfs_err(rc->block_group->fs_info,\n\t\t\t  \"unrecognized tree backref at tree block %llu slot %u\",\n\t\t\t  eb->start, path->slots[0]);\n\t\tbtrfs_release_path(path);\n\t\treturn -EUCLEAN;\n\t}\n\n\tbtrfs_release_path(path);\n\n\tBUG_ON(level == -1);\n\n\tblock = kmalloc(sizeof(*block), GFP_NOFS);\n\tif (!block)\n\t\treturn -ENOMEM;\n\n\tblock->bytenr = extent_key->objectid;\n\tblock->key.objectid = rc->extent_root->fs_info->nodesize;\n\tblock->key.offset = generation;\n\tblock->level = level;\n\tblock->key_ready = 0;\n\tblock->owner = owner;\n\n\trb_node = rb_simple_insert(blocks, block->bytenr, &block->rb_node);\n\tif (rb_node)\n\t\tbtrfs_backref_panic(rc->extent_root->fs_info, block->bytenr,\n\t\t\t\t    -EEXIST);\n\n\treturn 0;\n}\n\n \nstatic int __add_tree_block(struct reloc_control *rc,\n\t\t\t    u64 bytenr, u32 blocksize,\n\t\t\t    struct rb_root *blocks)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret;\n\tbool skinny = btrfs_fs_incompat(fs_info, SKINNY_METADATA);\n\n\tif (tree_block_processed(bytenr, rc))\n\t\treturn 0;\n\n\tif (rb_simple_search(blocks, bytenr))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tkey.objectid = bytenr;\n\tif (skinny) {\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\t\tkey.offset = (u64)-1;\n\t} else {\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.offset = blocksize;\n\t}\n\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tret = btrfs_search_slot(NULL, rc->extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0 && skinny) {\n\t\tif (path->slots[0]) {\n\t\t\tpath->slots[0]--;\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (key.objectid == bytenr &&\n\t\t\t    (key.type == BTRFS_METADATA_ITEM_KEY ||\n\t\t\t     (key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t      key.offset == blocksize)))\n\t\t\t\tret = 0;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tskinny = false;\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tif (ret) {\n\t\tASSERT(ret == 1);\n\t\tbtrfs_print_leaf(path->nodes[0]);\n\t\tbtrfs_err(fs_info,\n\t     \"tree block extent item (%llu) is not found in extent tree\",\n\t\t     bytenr);\n\t\tWARN_ON(1);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = add_tree_block(rc, &key, path, blocks);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int delete_block_group_cache(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct btrfs_block_group *block_group,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    u64 ino)\n{\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret = 0;\n\n\tif (inode)\n\t\tgoto truncate;\n\n\tinode = btrfs_iget(fs_info->sb, ino, root);\n\tif (IS_ERR(inode))\n\t\treturn -ENOENT;\n\ntruncate:\n\tret = btrfs_check_trunc_cache_free_space(fs_info,\n\t\t\t\t\t\t &fs_info->global_block_rsv);\n\tif (ret)\n\t\tgoto out;\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tret = btrfs_truncate_free_space_cache(trans, block_group, inode);\n\n\tbtrfs_end_transaction(trans);\n\tbtrfs_btree_balance_dirty(fs_info);\nout:\n\tiput(inode);\n\treturn ret;\n}\n\n \nstatic int delete_v1_space_cache(struct extent_buffer *leaf,\n\t\t\t\t struct btrfs_block_group *block_group,\n\t\t\t\t u64 data_bytenr)\n{\n\tu64 space_cache_ino;\n\tstruct btrfs_file_extent_item *ei;\n\tstruct btrfs_key key;\n\tbool found = false;\n\tint i;\n\tint ret;\n\n\tif (btrfs_header_owner(leaf) != BTRFS_ROOT_TREE_OBJECTID)\n\t\treturn 0;\n\n\tfor (i = 0; i < btrfs_header_nritems(leaf); i++) {\n\t\tu8 type;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, i);\n\t\tif (key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tcontinue;\n\t\tei = btrfs_item_ptr(leaf, i, struct btrfs_file_extent_item);\n\t\ttype = btrfs_file_extent_type(leaf, ei);\n\n\t\tif ((type == BTRFS_FILE_EXTENT_REG ||\n\t\t     type == BTRFS_FILE_EXTENT_PREALLOC) &&\n\t\t    btrfs_file_extent_disk_bytenr(leaf, ei) == data_bytenr) {\n\t\t\tfound = true;\n\t\t\tspace_cache_ino = key.objectid;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn -ENOENT;\n\tret = delete_block_group_cache(leaf->fs_info, block_group, NULL,\n\t\t\t\t\tspace_cache_ino);\n\treturn ret;\n}\n\n \nstatic noinline_for_stack\nint add_data_references(struct reloc_control *rc,\n\t\t\tstruct btrfs_key *extent_key,\n\t\t\tstruct btrfs_path *path,\n\t\t\tstruct rb_root *blocks)\n{\n\tstruct btrfs_backref_walk_ctx ctx = { 0 };\n\tstruct ulist_iterator leaf_uiter;\n\tstruct ulist_node *ref_node = NULL;\n\tconst u32 blocksize = rc->extent_root->fs_info->nodesize;\n\tint ret = 0;\n\n\tbtrfs_release_path(path);\n\n\tctx.bytenr = extent_key->objectid;\n\tctx.skip_inode_ref_list = true;\n\tctx.fs_info = rc->extent_root->fs_info;\n\n\tret = btrfs_find_all_leafs(&ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tULIST_ITER_INIT(&leaf_uiter);\n\twhile ((ref_node = ulist_next(ctx.refs, &leaf_uiter))) {\n\t\tstruct btrfs_tree_parent_check check = { 0 };\n\t\tstruct extent_buffer *eb;\n\n\t\teb = read_tree_block(ctx.fs_info, ref_node->val, &check);\n\t\tif (IS_ERR(eb)) {\n\t\t\tret = PTR_ERR(eb);\n\t\t\tbreak;\n\t\t}\n\t\tret = delete_v1_space_cache(eb, rc->block_group,\n\t\t\t\t\t    extent_key->objectid);\n\t\tfree_extent_buffer(eb);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tret = __add_tree_block(rc, ref_node->val, blocksize, blocks);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tif (ret < 0)\n\t\tfree_block_list(blocks);\n\tulist_free(ctx.refs);\n\treturn ret;\n}\n\n \nstatic noinline_for_stack\nint find_next_extent(struct reloc_control *rc, struct btrfs_path *path,\n\t\t     struct btrfs_key *extent_key)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tu64 start, end, last;\n\tint ret;\n\n\tlast = rc->block_group->start + rc->block_group->length;\n\twhile (1) {\n\t\tbool block_found;\n\n\t\tcond_resched();\n\t\tif (rc->search_start >= last) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tkey.objectid = rc->search_start;\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.offset = 0;\n\n\t\tpath->search_commit_root = 1;\n\t\tpath->skip_locking = 1;\n\t\tret = btrfs_search_slot(NULL, rc->extent_root, &key, path,\n\t\t\t\t\t0, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\nnext:\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(rc->extent_root, path);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid >= last) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (key.type != BTRFS_EXTENT_ITEM_KEY &&\n\t\t    key.type != BTRFS_METADATA_ITEM_KEY) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t\t    key.objectid + key.offset <= rc->search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (key.type == BTRFS_METADATA_ITEM_KEY &&\n\t\t    key.objectid + fs_info->nodesize <=\n\t\t    rc->search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tblock_found = find_first_extent_bit(&rc->processed_blocks,\n\t\t\t\t\t\t    key.objectid, &start, &end,\n\t\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\n\t\tif (block_found && start <= key.objectid) {\n\t\t\tbtrfs_release_path(path);\n\t\t\trc->search_start = end + 1;\n\t\t} else {\n\t\t\tif (key.type == BTRFS_EXTENT_ITEM_KEY)\n\t\t\t\trc->search_start = key.objectid + key.offset;\n\t\t\telse\n\t\t\t\trc->search_start = key.objectid +\n\t\t\t\t\tfs_info->nodesize;\n\t\t\tmemcpy(extent_key, &key, sizeof(key));\n\t\t\treturn 0;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\treturn ret;\n}\n\nstatic void set_reloc_control(struct reloc_control *rc)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\n\tmutex_lock(&fs_info->reloc_mutex);\n\tfs_info->reloc_ctl = rc;\n\tmutex_unlock(&fs_info->reloc_mutex);\n}\n\nstatic void unset_reloc_control(struct reloc_control *rc)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\n\tmutex_lock(&fs_info->reloc_mutex);\n\tfs_info->reloc_ctl = NULL;\n\tmutex_unlock(&fs_info->reloc_mutex);\n}\n\nstatic noinline_for_stack\nint prepare_to_relocate(struct reloc_control *rc)\n{\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\trc->block_rsv = btrfs_alloc_block_rsv(rc->extent_root->fs_info,\n\t\t\t\t\t      BTRFS_BLOCK_RSV_TEMP);\n\tif (!rc->block_rsv)\n\t\treturn -ENOMEM;\n\n\tmemset(&rc->cluster, 0, sizeof(rc->cluster));\n\trc->search_start = rc->block_group->start;\n\trc->extents_found = 0;\n\trc->nodes_relocated = 0;\n\trc->merging_rsv_size = 0;\n\trc->reserved_bytes = 0;\n\trc->block_rsv->size = rc->extent_root->fs_info->nodesize *\n\t\t\t      RELOCATION_RESERVED_NODES;\n\tret = btrfs_block_rsv_refill(rc->extent_root->fs_info,\n\t\t\t\t     rc->block_rsv, rc->block_rsv->size,\n\t\t\t\t     BTRFS_RESERVE_FLUSH_ALL);\n\tif (ret)\n\t\treturn ret;\n\n\trc->create_reloc_tree = 1;\n\tset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\tunset_reloc_control(rc);\n\t\t \n\t\treturn PTR_ERR(trans);\n\t}\n\n\tret = btrfs_commit_transaction(trans);\n\tif (ret)\n\t\tunset_reloc_control(rc);\n\n\treturn ret;\n}\n\nstatic noinline_for_stack int relocate_block_group(struct reloc_control *rc)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\tstruct rb_root blocks = RB_ROOT;\n\tstruct btrfs_key key;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_extent_item *ei;\n\tu64 flags;\n\tint ret;\n\tint err = 0;\n\tint progress = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = READA_FORWARD;\n\n\tret = prepare_to_relocate(rc);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto out_free;\n\t}\n\n\twhile (1) {\n\t\trc->reserved_bytes = 0;\n\t\tret = btrfs_block_rsv_refill(fs_info, rc->block_rsv,\n\t\t\t\t\t     rc->block_rsv->size,\n\t\t\t\t\t     BTRFS_RESERVE_FLUSH_ALL);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\t\tprogress++;\n\t\ttrans = btrfs_start_transaction(rc->extent_root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\terr = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tbreak;\n\t\t}\nrestart:\n\t\tif (update_backref_cache(trans, &rc->backref_cache)) {\n\t\t\tbtrfs_end_transaction(trans);\n\t\t\ttrans = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = find_next_extent(rc, path, &key);\n\t\tif (ret < 0)\n\t\t\terr = ret;\n\t\tif (ret != 0)\n\t\t\tbreak;\n\n\t\trc->extents_found++;\n\n\t\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_extent_item);\n\t\tflags = btrfs_extent_flags(path->nodes[0], ei);\n\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\t\tret = add_tree_block(rc, &key, path, &blocks);\n\t\t} else if (rc->stage == UPDATE_DATA_PTRS &&\n\t\t\t   (flags & BTRFS_EXTENT_FLAG_DATA)) {\n\t\t\tret = add_data_references(rc, &key, path, &blocks);\n\t\t} else {\n\t\t\tbtrfs_release_path(path);\n\t\t\tret = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!RB_EMPTY_ROOT(&blocks)) {\n\t\t\tret = relocate_tree_blocks(trans, rc, &blocks);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (ret != -EAGAIN) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc->extents_found--;\n\t\t\t\trc->search_start = key.objectid;\n\t\t\t}\n\t\t}\n\n\t\tbtrfs_end_transaction_throttle(trans);\n\t\tbtrfs_btree_balance_dirty(fs_info);\n\t\ttrans = NULL;\n\n\t\tif (rc->stage == MOVE_DATA_EXTENTS &&\n\t\t    (flags & BTRFS_EXTENT_FLAG_DATA)) {\n\t\t\trc->found_file_extent = 1;\n\t\t\tret = relocate_data_extent(rc->data_inode,\n\t\t\t\t\t\t   &key, &rc->cluster);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (btrfs_should_cancel_balance(fs_info)) {\n\t\t\terr = -ECANCELED;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (trans && progress && err == -ENOSPC) {\n\t\tret = btrfs_force_chunk_alloc(trans, rc->block_group->flags);\n\t\tif (ret == 1) {\n\t\t\terr = 0;\n\t\t\tprogress = 0;\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\tbtrfs_release_path(path);\n\tclear_extent_bits(&rc->processed_blocks, 0, (u64)-1, EXTENT_DIRTY);\n\n\tif (trans) {\n\t\tbtrfs_end_transaction_throttle(trans);\n\t\tbtrfs_btree_balance_dirty(fs_info);\n\t}\n\n\tif (!err) {\n\t\tret = relocate_file_extent_cluster(rc->data_inode,\n\t\t\t\t\t\t   &rc->cluster);\n\t\tif (ret < 0)\n\t\t\terr = ret;\n\t}\n\n\trc->create_reloc_tree = 0;\n\tset_reloc_control(rc);\n\n\tbtrfs_backref_release_cache(&rc->backref_cache);\n\tbtrfs_block_rsv_release(fs_info, rc->block_rsv, (u64)-1, NULL);\n\n\t \n\terr = prepare_to_merge(rc, err);\n\n\tmerge_reloc_roots(rc);\n\n\trc->merge_reloc_tree = 0;\n\tunset_reloc_control(rc);\n\tbtrfs_block_rsv_release(fs_info, rc->block_rsv, (u64)-1, NULL);\n\n\t \n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_free;\n\t}\n\tret = btrfs_commit_transaction(trans);\n\tif (ret && !err)\n\t\terr = ret;\nout_free:\n\tret = clean_dirty_subvols(rc);\n\tif (ret < 0 && !err)\n\t\terr = ret;\n\tbtrfs_free_block_rsv(fs_info, rc->block_rsv);\n\tbtrfs_free_path(path);\n\treturn err;\n}\n\nstatic int __insert_orphan_inode(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root, u64 objectid)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_inode_item *item;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_insert_empty_inode(trans, root, path, objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_inode_item);\n\tmemzero_extent_buffer(leaf, (unsigned long)item, sizeof(*item));\n\tbtrfs_set_inode_generation(leaf, item, 1);\n\tbtrfs_set_inode_size(leaf, item, 0);\n\tbtrfs_set_inode_mode(leaf, item, S_IFREG | 0600);\n\tbtrfs_set_inode_flags(leaf, item, BTRFS_INODE_NOCOMPRESS |\n\t\t\t\t\t  BTRFS_INODE_PREALLOC);\n\tbtrfs_mark_buffer_dirty(trans, leaf);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic void delete_orphan_inode(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root, u64 objectid)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tret = btrfs_del_item(trans, root, path);\nout:\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, ret);\n\tbtrfs_free_path(path);\n}\n\n \nstatic noinline_for_stack\nstruct inode *create_reloc_inode(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct btrfs_block_group *group)\n{\n\tstruct inode *inode = NULL;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root;\n\tu64 objectid;\n\tint err = 0;\n\n\troot = btrfs_grab_root(fs_info->data_reloc_root);\n\ttrans = btrfs_start_transaction(root, 6);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_put_root(root);\n\t\treturn ERR_CAST(trans);\n\t}\n\n\terr = btrfs_get_free_objectid(root, &objectid);\n\tif (err)\n\t\tgoto out;\n\n\terr = __insert_orphan_inode(trans, root, objectid);\n\tif (err)\n\t\tgoto out;\n\n\tinode = btrfs_iget(fs_info->sb, objectid, root);\n\tif (IS_ERR(inode)) {\n\t\tdelete_orphan_inode(trans, root, objectid);\n\t\terr = PTR_ERR(inode);\n\t\tinode = NULL;\n\t\tgoto out;\n\t}\n\tBTRFS_I(inode)->index_cnt = group->start;\n\n\terr = btrfs_orphan_add(trans, BTRFS_I(inode));\nout:\n\tbtrfs_put_root(root);\n\tbtrfs_end_transaction(trans);\n\tbtrfs_btree_balance_dirty(fs_info);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t}\n\treturn inode;\n}\n\n \nstatic int reloc_chunk_start(struct btrfs_fs_info *fs_info)\n{\n\tif (test_and_set_bit(BTRFS_FS_RELOC_RUNNING, &fs_info->flags)) {\n\t\t \n\t\tbtrfs_err(fs_info, \"reloc already running, cannot start\");\n\t\treturn -EINPROGRESS;\n\t}\n\n\tif (atomic_read(&fs_info->reloc_cancel_req) > 0) {\n\t\tbtrfs_info(fs_info, \"chunk relocation canceled on start\");\n\t\t \n\t\tatomic_set(&fs_info->reloc_cancel_req, 0);\n\t\treturn -ECANCELED;\n\t}\n\treturn 0;\n}\n\n \nstatic void reloc_chunk_end(struct btrfs_fs_info *fs_info)\n{\n\t \n\tif (atomic_read(&fs_info->reloc_cancel_req) > 0)\n\t\tbtrfs_info(fs_info, \"chunk relocation canceled during operation\");\n\tclear_and_wake_up_bit(BTRFS_FS_RELOC_RUNNING, &fs_info->flags);\n\tatomic_set(&fs_info->reloc_cancel_req, 0);\n}\n\nstatic struct reloc_control *alloc_reloc_control(struct btrfs_fs_info *fs_info)\n{\n\tstruct reloc_control *rc;\n\n\trc = kzalloc(sizeof(*rc), GFP_NOFS);\n\tif (!rc)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&rc->reloc_roots);\n\tINIT_LIST_HEAD(&rc->dirty_subvol_roots);\n\tbtrfs_backref_init_cache(fs_info, &rc->backref_cache, 1);\n\tmapping_tree_init(&rc->reloc_root_tree);\n\textent_io_tree_init(fs_info, &rc->processed_blocks, IO_TREE_RELOC_BLOCKS);\n\treturn rc;\n}\n\nstatic void free_reloc_control(struct reloc_control *rc)\n{\n\tstruct mapping_node *node, *tmp;\n\n\tfree_reloc_roots(&rc->reloc_roots);\n\trbtree_postorder_for_each_entry_safe(node, tmp,\n\t\t\t&rc->reloc_root_tree.rb_root, rb_node)\n\t\tkfree(node);\n\n\tkfree(rc);\n}\n\n \nstatic void describe_relocation(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_block_group *block_group)\n{\n\tchar buf[128] = {'\\0'};\n\n\tbtrfs_describe_block_groups(block_group->flags, buf, sizeof(buf));\n\n\tbtrfs_info(fs_info,\n\t\t   \"relocating block group %llu flags %s\",\n\t\t   block_group->start, buf);\n}\n\nstatic const char *stage_to_string(int stage)\n{\n\tif (stage == MOVE_DATA_EXTENTS)\n\t\treturn \"move data extents\";\n\tif (stage == UPDATE_DATA_PTRS)\n\t\treturn \"update data pointers\";\n\treturn \"unknown\";\n}\n\n \nint btrfs_relocate_block_group(struct btrfs_fs_info *fs_info, u64 group_start)\n{\n\tstruct btrfs_block_group *bg;\n\tstruct btrfs_root *extent_root = btrfs_extent_root(fs_info, group_start);\n\tstruct reloc_control *rc;\n\tstruct inode *inode;\n\tstruct btrfs_path *path;\n\tint ret;\n\tint rw = 0;\n\tint err = 0;\n\n\t \n\tret = wait_on_bit(&fs_info->flags, BTRFS_FS_UNFINISHED_DROPS, TASK_INTERRUPTIBLE);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (btrfs_fs_closing(fs_info))\n\t\treturn -EINTR;\n\n\tbg = btrfs_lookup_block_group(fs_info, group_start);\n\tif (!bg)\n\t\treturn -ENOENT;\n\n\t \n\tif (bg->flags & BTRFS_BLOCK_GROUP_DATA)\n\t\tASSERT(sb_write_started(fs_info->sb));\n\n\tif (btrfs_pinned_by_swapfile(fs_info, bg)) {\n\t\tbtrfs_put_block_group(bg);\n\t\treturn -ETXTBSY;\n\t}\n\n\trc = alloc_reloc_control(fs_info);\n\tif (!rc) {\n\t\tbtrfs_put_block_group(bg);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = reloc_chunk_start(fs_info);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto out_put_bg;\n\t}\n\n\trc->extent_root = extent_root;\n\trc->block_group = bg;\n\n\tret = btrfs_inc_block_group_ro(rc->block_group, true);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\trw = 1;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tinode = lookup_free_space_inode(rc->block_group, path);\n\tbtrfs_free_path(path);\n\n\tif (!IS_ERR(inode))\n\t\tret = delete_block_group_cache(fs_info, rc->block_group, inode, 0);\n\telse\n\t\tret = PTR_ERR(inode);\n\n\tif (ret && ret != -ENOENT) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\n\trc->data_inode = create_reloc_inode(fs_info, rc->block_group);\n\tif (IS_ERR(rc->data_inode)) {\n\t\terr = PTR_ERR(rc->data_inode);\n\t\trc->data_inode = NULL;\n\t\tgoto out;\n\t}\n\n\tdescribe_relocation(fs_info, rc->block_group);\n\n\tbtrfs_wait_block_group_reservations(rc->block_group);\n\tbtrfs_wait_nocow_writers(rc->block_group);\n\tbtrfs_wait_ordered_roots(fs_info, U64_MAX,\n\t\t\t\t rc->block_group->start,\n\t\t\t\t rc->block_group->length);\n\n\tret = btrfs_zone_finish(rc->block_group);\n\tWARN_ON(ret && ret != -EAGAIN);\n\n\twhile (1) {\n\t\tint finishes_stage;\n\n\t\tmutex_lock(&fs_info->cleaner_mutex);\n\t\tret = relocate_block_group(rc);\n\t\tmutex_unlock(&fs_info->cleaner_mutex);\n\t\tif (ret < 0)\n\t\t\terr = ret;\n\n\t\tfinishes_stage = rc->stage;\n\t\t \n\t\tif (rc->stage == MOVE_DATA_EXTENTS && rc->found_file_extent) {\n\t\t\tret = btrfs_wait_ordered_range(rc->data_inode, 0,\n\t\t\t\t\t\t       (u64)-1);\n\t\t\tif (ret)\n\t\t\t\terr = ret;\n\t\t\tinvalidate_mapping_pages(rc->data_inode->i_mapping,\n\t\t\t\t\t\t 0, -1);\n\t\t\trc->stage = UPDATE_DATA_PTRS;\n\t\t}\n\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\tif (rc->extents_found == 0)\n\t\t\tbreak;\n\n\t\tbtrfs_info(fs_info, \"found %llu extents, stage: %s\",\n\t\t\t   rc->extents_found, stage_to_string(finishes_stage));\n\t}\n\n\tWARN_ON(rc->block_group->pinned > 0);\n\tWARN_ON(rc->block_group->reserved > 0);\n\tWARN_ON(rc->block_group->used > 0);\nout:\n\tif (err && rw)\n\t\tbtrfs_dec_block_group_ro(rc->block_group);\n\tiput(rc->data_inode);\nout_put_bg:\n\tbtrfs_put_block_group(bg);\n\treloc_chunk_end(fs_info);\n\tfree_reloc_control(rc);\n\treturn err;\n}\n\nstatic noinline_for_stack int mark_garbage_root(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_trans_handle *trans;\n\tint ret, err;\n\n\ttrans = btrfs_start_transaction(fs_info->tree_root, 0);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tmemset(&root->root_item.drop_progress, 0,\n\t\tsizeof(root->root_item.drop_progress));\n\tbtrfs_set_root_drop_level(&root->root_item, 0);\n\tbtrfs_set_root_refs(&root->root_item, 0);\n\tret = btrfs_update_root(trans, fs_info->tree_root,\n\t\t\t\t&root->root_key, &root->root_item);\n\n\terr = btrfs_end_transaction(trans);\n\tif (err)\n\t\treturn err;\n\treturn ret;\n}\n\n \nint btrfs_recover_relocation(struct btrfs_fs_info *fs_info)\n{\n\tLIST_HEAD(reloc_roots);\n\tstruct btrfs_key key;\n\tstruct btrfs_root *fs_root;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct reloc_control *rc = NULL;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = READA_BACK;\n\n\tkey.objectid = BTRFS_TREE_RELOC_OBJECTID;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, fs_info->tree_root, &key,\n\t\t\t\t\tpath, 0, 0);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tbtrfs_release_path(path);\n\n\t\tif (key.objectid != BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    key.type != BTRFS_ROOT_ITEM_KEY)\n\t\t\tbreak;\n\n\t\treloc_root = btrfs_read_tree_root(fs_info->tree_root, &key);\n\t\tif (IS_ERR(reloc_root)) {\n\t\t\terr = PTR_ERR(reloc_root);\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_bit(BTRFS_ROOT_SHAREABLE, &reloc_root->state);\n\t\tlist_add(&reloc_root->root_list, &reloc_roots);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) > 0) {\n\t\t\tfs_root = btrfs_get_fs_root(fs_info,\n\t\t\t\t\treloc_root->root_key.offset, false);\n\t\t\tif (IS_ERR(fs_root)) {\n\t\t\t\tret = PTR_ERR(fs_root);\n\t\t\t\tif (ret != -ENOENT) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = mark_garbage_root(reloc_root);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbtrfs_put_root(fs_root);\n\t\t\t}\n\t\t}\n\n\t\tif (key.offset == 0)\n\t\t\tbreak;\n\n\t\tkey.offset--;\n\t}\n\tbtrfs_release_path(path);\n\n\tif (list_empty(&reloc_roots))\n\t\tgoto out;\n\n\trc = alloc_reloc_control(fs_info);\n\tif (!rc) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = reloc_chunk_start(fs_info);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto out_end;\n\t}\n\n\trc->extent_root = btrfs_extent_root(fs_info, 0);\n\n\tset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_unset;\n\t}\n\n\trc->merge_reloc_tree = 1;\n\n\twhile (!list_empty(&reloc_roots)) {\n\t\treloc_root = list_entry(reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\t\tlist_del(&reloc_root->root_list);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) == 0) {\n\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t      &rc->reloc_roots);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfs_root = btrfs_get_fs_root(fs_info, reloc_root->root_key.offset,\n\t\t\t\t\t    false);\n\t\tif (IS_ERR(fs_root)) {\n\t\t\terr = PTR_ERR(fs_root);\n\t\t\tlist_add_tail(&reloc_root->root_list, &reloc_roots);\n\t\t\tbtrfs_end_transaction(trans);\n\t\t\tgoto out_unset;\n\t\t}\n\n\t\terr = __add_reloc_root(reloc_root);\n\t\tASSERT(err != -EEXIST);\n\t\tif (err) {\n\t\t\tlist_add_tail(&reloc_root->root_list, &reloc_roots);\n\t\t\tbtrfs_put_root(fs_root);\n\t\t\tbtrfs_end_transaction(trans);\n\t\t\tgoto out_unset;\n\t\t}\n\t\tfs_root->reloc_root = btrfs_grab_root(reloc_root);\n\t\tbtrfs_put_root(fs_root);\n\t}\n\n\terr = btrfs_commit_transaction(trans);\n\tif (err)\n\t\tgoto out_unset;\n\n\tmerge_reloc_roots(rc);\n\n\tunset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_clean;\n\t}\n\terr = btrfs_commit_transaction(trans);\nout_clean:\n\tret = clean_dirty_subvols(rc);\n\tif (ret < 0 && !err)\n\t\terr = ret;\nout_unset:\n\tunset_reloc_control(rc);\nout_end:\n\treloc_chunk_end(fs_info);\n\tfree_reloc_control(rc);\nout:\n\tfree_reloc_roots(&reloc_roots);\n\n\tbtrfs_free_path(path);\n\n\tif (err == 0) {\n\t\t \n\t\tfs_root = btrfs_grab_root(fs_info->data_reloc_root);\n\t\tASSERT(fs_root);\n\t\terr = btrfs_orphan_cleanup(fs_root);\n\t\tbtrfs_put_root(fs_root);\n\t}\n\treturn err;\n}\n\n \nint btrfs_reloc_clone_csums(struct btrfs_ordered_extent *ordered)\n{\n\tstruct btrfs_inode *inode = BTRFS_I(ordered->inode);\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tu64 disk_bytenr = ordered->file_offset + inode->index_cnt;\n\tstruct btrfs_root *csum_root = btrfs_csum_root(fs_info, disk_bytenr);\n\tLIST_HEAD(list);\n\tint ret;\n\n\tret = btrfs_lookup_csums_list(csum_root, disk_bytenr,\n\t\t\t\t      disk_bytenr + ordered->num_bytes - 1,\n\t\t\t\t      &list, 0, false);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (!list_empty(&list)) {\n\t\tstruct btrfs_ordered_sum *sums =\n\t\t\tlist_entry(list.next, struct btrfs_ordered_sum, list);\n\n\t\tlist_del_init(&sums->list);\n\n\t\t \n\t\tsums->logical = ordered->disk_bytenr + sums->logical - disk_bytenr;\n\t\tbtrfs_add_ordered_sum(ordered, sums);\n\t}\n\n\treturn 0;\n}\n\nint btrfs_reloc_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *buf,\n\t\t\t  struct extent_buffer *cow)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct reloc_control *rc;\n\tstruct btrfs_backref_node *node;\n\tint first_cow = 0;\n\tint level;\n\tint ret = 0;\n\n\trc = fs_info->reloc_ctl;\n\tif (!rc)\n\t\treturn 0;\n\n\tBUG_ON(rc->stage == UPDATE_DATA_PTRS && btrfs_is_data_reloc_root(root));\n\n\tlevel = btrfs_header_level(buf);\n\tif (btrfs_header_generation(buf) <=\n\t    btrfs_root_last_snapshot(&root->root_item))\n\t\tfirst_cow = 1;\n\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID &&\n\t    rc->create_reloc_tree) {\n\t\tWARN_ON(!first_cow && level == 0);\n\n\t\tnode = rc->backref_cache.path[level];\n\t\tBUG_ON(node->bytenr != buf->start &&\n\t\t       node->new_bytenr != buf->start);\n\n\t\tbtrfs_backref_drop_node_buffer(node);\n\t\tatomic_inc(&cow->refs);\n\t\tnode->eb = cow;\n\t\tnode->new_bytenr = cow->start;\n\n\t\tif (!node->pending) {\n\t\t\tlist_move_tail(&node->list,\n\t\t\t\t       &rc->backref_cache.pending[level]);\n\t\t\tnode->pending = 1;\n\t\t}\n\n\t\tif (first_cow)\n\t\t\tmark_block_processed(rc, node);\n\n\t\tif (first_cow && level > 0)\n\t\t\trc->nodes_relocated += buf->len;\n\t}\n\n\tif (level == 0 && first_cow && rc->stage == UPDATE_DATA_PTRS)\n\t\tret = replace_file_extents(trans, rc, root, cow);\n\treturn ret;\n}\n\n \nvoid btrfs_reloc_pre_snapshot(struct btrfs_pending_snapshot *pending,\n\t\t\t      u64 *bytes_to_reserve)\n{\n\tstruct btrfs_root *root = pending->root;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tif (!rc || !have_reloc_root(root))\n\t\treturn;\n\n\tif (!rc->merge_reloc_tree)\n\t\treturn;\n\n\troot = root->reloc_root;\n\tBUG_ON(btrfs_root_refs(&root->root_item) == 0);\n\t \n\t*bytes_to_reserve += rc->nodes_relocated;\n}\n\n \nint btrfs_reloc_post_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_pending_snapshot *pending)\n{\n\tstruct btrfs_root *root = pending->root;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root *new_root;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\tint ret;\n\n\tif (!rc || !have_reloc_root(root))\n\t\treturn 0;\n\n\trc = root->fs_info->reloc_ctl;\n\trc->merging_rsv_size += rc->nodes_relocated;\n\n\tif (rc->merge_reloc_tree) {\n\t\tret = btrfs_block_rsv_migrate(&pending->block_rsv,\n\t\t\t\t\t      rc->block_rsv,\n\t\t\t\t\t      rc->nodes_relocated, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tnew_root = pending->snap;\n\treloc_root = create_reloc_root(trans, root->reloc_root,\n\t\t\t\t       new_root->root_key.objectid);\n\tif (IS_ERR(reloc_root))\n\t\treturn PTR_ERR(reloc_root);\n\n\tret = __add_reloc_root(reloc_root);\n\tASSERT(ret != -EEXIST);\n\tif (ret) {\n\t\t \n\t\tbtrfs_put_root(reloc_root);\n\t\treturn ret;\n\t}\n\tnew_root->reloc_root = btrfs_grab_root(reloc_root);\n\n\tif (rc->create_reloc_tree)\n\t\tret = clone_backref_node(trans, rc, root, reloc_root);\n\treturn ret;\n}\n\n \nu64 btrfs_get_reloc_bg_bytenr(struct btrfs_fs_info *fs_info)\n{\n\tu64 logical = U64_MAX;\n\n\tlockdep_assert_held(&fs_info->reloc_mutex);\n\n\tif (fs_info->reloc_ctl && fs_info->reloc_ctl->block_group)\n\t\tlogical = fs_info->reloc_ctl->block_group->start;\n\treturn logical;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}