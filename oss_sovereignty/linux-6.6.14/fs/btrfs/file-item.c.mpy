{
  "module_name": "file-item.c",
  "hash_id": "283f51436a19b092a845fb26023ce058a384bda19fea5d78111d24e214775470",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/file-item.c",
  "human_readable_source": "\n \n\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/sched/mm.h>\n#include <crypto/hash.h>\n#include \"messages.h\"\n#include \"misc.h\"\n#include \"ctree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"bio.h\"\n#include \"print-tree.h\"\n#include \"compression.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n#include \"file-item.h\"\n#include \"super.h\"\n\n#define __MAX_CSUM_ITEMS(r, size) ((unsigned long)(((BTRFS_LEAF_DATA_SIZE(r) - \\\n\t\t\t\t   sizeof(struct btrfs_item) * 2) / \\\n\t\t\t\t  size) - 1))\n\n#define MAX_CSUM_ITEMS(r, size) (min_t(u32, __MAX_CSUM_ITEMS(r, size), \\\n\t\t\t\t       PAGE_SIZE))\n\n \nvoid btrfs_inode_safe_disk_i_size_write(struct btrfs_inode *inode, u64 new_i_size)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tu64 start, end, i_size;\n\tint ret;\n\n\tspin_lock(&inode->lock);\n\ti_size = new_i_size ?: i_size_read(&inode->vfs_inode);\n\tif (btrfs_fs_incompat(fs_info, NO_HOLES)) {\n\t\tinode->disk_i_size = i_size;\n\t\tgoto out_unlock;\n\t}\n\n\tret = find_contiguous_extent_bit(&inode->file_extent_tree, 0, &start,\n\t\t\t\t\t &end, EXTENT_DIRTY);\n\tif (!ret && start == 0)\n\t\ti_size = min(i_size, end + 1);\n\telse\n\t\ti_size = 0;\n\tinode->disk_i_size = i_size;\nout_unlock:\n\tspin_unlock(&inode->lock);\n}\n\n \nint btrfs_inode_set_file_extent_range(struct btrfs_inode *inode, u64 start,\n\t\t\t\t      u64 len)\n{\n\tif (len == 0)\n\t\treturn 0;\n\n\tASSERT(IS_ALIGNED(start + len, inode->root->fs_info->sectorsize));\n\n\tif (btrfs_fs_incompat(inode->root->fs_info, NO_HOLES))\n\t\treturn 0;\n\treturn set_extent_bit(&inode->file_extent_tree, start, start + len - 1,\n\t\t\t      EXTENT_DIRTY, NULL);\n}\n\n \nint btrfs_inode_clear_file_extent_range(struct btrfs_inode *inode, u64 start,\n\t\t\t\t\tu64 len)\n{\n\tif (len == 0)\n\t\treturn 0;\n\n\tASSERT(IS_ALIGNED(start + len, inode->root->fs_info->sectorsize) ||\n\t       len == (u64)-1);\n\n\tif (btrfs_fs_incompat(inode->root->fs_info, NO_HOLES))\n\t\treturn 0;\n\treturn clear_extent_bit(&inode->file_extent_tree, start,\n\t\t\t\tstart + len - 1, EXTENT_DIRTY, NULL);\n}\n\nstatic size_t bytes_to_csum_size(const struct btrfs_fs_info *fs_info, u32 bytes)\n{\n\tASSERT(IS_ALIGNED(bytes, fs_info->sectorsize));\n\n\treturn (bytes >> fs_info->sectorsize_bits) * fs_info->csum_size;\n}\n\nstatic size_t csum_size_to_bytes(const struct btrfs_fs_info *fs_info, u32 csum_size)\n{\n\tASSERT(IS_ALIGNED(csum_size, fs_info->csum_size));\n\n\treturn (csum_size / fs_info->csum_size) << fs_info->sectorsize_bits;\n}\n\nstatic inline u32 max_ordered_sum_bytes(const struct btrfs_fs_info *fs_info)\n{\n\tu32 max_csum_size = round_down(PAGE_SIZE - sizeof(struct btrfs_ordered_sum),\n\t\t\t\t       fs_info->csum_size);\n\n\treturn csum_size_to_bytes(fs_info, max_csum_size);\n}\n\n \nstatic int btrfs_ordered_sum_size(struct btrfs_fs_info *fs_info, unsigned long bytes)\n{\n\treturn sizeof(struct btrfs_ordered_sum) + bytes_to_csum_size(fs_info, bytes);\n}\n\nint btrfs_insert_hole_extent(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     u64 objectid, u64 pos, u64 num_bytes)\n{\n\tint ret = 0;\n\tstruct btrfs_file_extent_item *item;\n\tstruct btrfs_key file_key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tfile_key.objectid = objectid;\n\tfile_key.offset = pos;\n\tfile_key.type = BTRFS_EXTENT_DATA_KEY;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &file_key,\n\t\t\t\t      sizeof(*item));\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(ret);  \n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t      struct btrfs_file_extent_item);\n\tbtrfs_set_file_extent_disk_bytenr(leaf, item, 0);\n\tbtrfs_set_file_extent_disk_num_bytes(leaf, item, 0);\n\tbtrfs_set_file_extent_offset(leaf, item, 0);\n\tbtrfs_set_file_extent_num_bytes(leaf, item, num_bytes);\n\tbtrfs_set_file_extent_ram_bytes(leaf, item, num_bytes);\n\tbtrfs_set_file_extent_generation(leaf, item, trans->transid);\n\tbtrfs_set_file_extent_type(leaf, item, BTRFS_FILE_EXTENT_REG);\n\tbtrfs_set_file_extent_compression(leaf, item, 0);\n\tbtrfs_set_file_extent_encryption(leaf, item, 0);\n\tbtrfs_set_file_extent_other_encoding(leaf, item, 0);\n\n\tbtrfs_mark_buffer_dirty(trans, leaf);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic struct btrfs_csum_item *\nbtrfs_lookup_csum(struct btrfs_trans_handle *trans,\n\t\t  struct btrfs_root *root,\n\t\t  struct btrfs_path *path,\n\t\t  u64 bytenr, int cow)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\tstruct btrfs_key file_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_csum_item *item;\n\tstruct extent_buffer *leaf;\n\tu64 csum_offset = 0;\n\tconst u32 csum_size = fs_info->csum_size;\n\tint csums_in_item;\n\n\tfile_key.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tfile_key.offset = bytenr;\n\tfile_key.type = BTRFS_EXTENT_CSUM_KEY;\n\tret = btrfs_search_slot(trans, root, &file_key, path, 0, cow);\n\tif (ret < 0)\n\t\tgoto fail;\n\tleaf = path->nodes[0];\n\tif (ret > 0) {\n\t\tret = 1;\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto fail;\n\t\tpath->slots[0]--;\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.type != BTRFS_EXTENT_CSUM_KEY)\n\t\t\tgoto fail;\n\n\t\tcsum_offset = (bytenr - found_key.offset) >>\n\t\t\t\tfs_info->sectorsize_bits;\n\t\tcsums_in_item = btrfs_item_size(leaf, path->slots[0]);\n\t\tcsums_in_item /= csum_size;\n\n\t\tif (csum_offset == csums_in_item) {\n\t\t\tret = -EFBIG;\n\t\t\tgoto fail;\n\t\t} else if (csum_offset > csums_in_item) {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_csum_item);\n\titem = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t\t  csum_offset * csum_size);\n\treturn item;\nfail:\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\treturn ERR_PTR(ret);\n}\n\nint btrfs_lookup_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid,\n\t\t\t     u64 offset, int mod)\n{\n\tstruct btrfs_key file_key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tfile_key.objectid = objectid;\n\tfile_key.offset = offset;\n\tfile_key.type = BTRFS_EXTENT_DATA_KEY;\n\n\treturn btrfs_search_slot(trans, root, &file_key, path, ins_len, cow);\n}\n\n \nstatic int search_csum_tree(struct btrfs_fs_info *fs_info,\n\t\t\t    struct btrfs_path *path, u64 disk_bytenr,\n\t\t\t    u64 len, u8 *dst)\n{\n\tstruct btrfs_root *csum_root;\n\tstruct btrfs_csum_item *item = NULL;\n\tstruct btrfs_key key;\n\tconst u32 sectorsize = fs_info->sectorsize;\n\tconst u32 csum_size = fs_info->csum_size;\n\tu32 itemsize;\n\tint ret;\n\tu64 csum_start;\n\tu64 csum_len;\n\n\tASSERT(IS_ALIGNED(disk_bytenr, sectorsize) &&\n\t       IS_ALIGNED(len, sectorsize));\n\n\t \n\tif (path->nodes[0]) {\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\t\titemsize = btrfs_item_size(path->nodes[0], path->slots[0]);\n\n\t\tcsum_start = key.offset;\n\t\tcsum_len = (itemsize / csum_size) * sectorsize;\n\n\t\tif (in_range(disk_bytenr, csum_start, csum_len))\n\t\t\tgoto found;\n\t}\n\n\t \n\tbtrfs_release_path(path);\n\tcsum_root = btrfs_csum_root(fs_info, disk_bytenr);\n\titem = btrfs_lookup_csum(NULL, csum_root, path, disk_bytenr, 0);\n\tif (IS_ERR(item)) {\n\t\tret = PTR_ERR(item);\n\t\tgoto out;\n\t}\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\titemsize = btrfs_item_size(path->nodes[0], path->slots[0]);\n\n\tcsum_start = key.offset;\n\tcsum_len = (itemsize / csum_size) * sectorsize;\n\tASSERT(in_range(disk_bytenr, csum_start, csum_len));\n\nfound:\n\tret = (min(csum_start + csum_len, disk_bytenr + len) -\n\t\t   disk_bytenr) >> fs_info->sectorsize_bits;\n\tread_extent_buffer(path->nodes[0], dst, (unsigned long)item,\n\t\t\tret * csum_size);\nout:\n\tif (ret == -ENOENT || ret == -EFBIG)\n\t\tret = 0;\n\treturn ret;\n}\n\n \nblk_status_t btrfs_lookup_bio_sums(struct btrfs_bio *bbio)\n{\n\tstruct btrfs_inode *inode = bbio->inode;\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tstruct bio *bio = &bbio->bio;\n\tstruct btrfs_path *path;\n\tconst u32 sectorsize = fs_info->sectorsize;\n\tconst u32 csum_size = fs_info->csum_size;\n\tu32 orig_len = bio->bi_iter.bi_size;\n\tu64 orig_disk_bytenr = bio->bi_iter.bi_sector << SECTOR_SHIFT;\n\tconst unsigned int nblocks = orig_len >> fs_info->sectorsize_bits;\n\tblk_status_t ret = BLK_STS_OK;\n\tu32 bio_offset = 0;\n\n\tif ((inode->flags & BTRFS_INODE_NODATASUM) ||\n\t    test_bit(BTRFS_FS_STATE_NO_CSUMS, &fs_info->fs_state))\n\t\treturn BLK_STS_OK;\n\n\t \n\tASSERT(bio_op(bio) == REQ_OP_READ);\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn BLK_STS_RESOURCE;\n\n\tif (nblocks * csum_size > BTRFS_BIO_INLINE_CSUM_SIZE) {\n\t\tbbio->csum = kmalloc_array(nblocks, csum_size, GFP_NOFS);\n\t\tif (!bbio->csum) {\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn BLK_STS_RESOURCE;\n\t\t}\n\t} else {\n\t\tbbio->csum = bbio->csum_inline;\n\t}\n\n\t \n\tif (nblocks > fs_info->csums_per_leaf)\n\t\tpath->reada = READA_FORWARD;\n\n\t \n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tpath->search_commit_root = 1;\n\t\tpath->skip_locking = 1;\n\t}\n\n\twhile (bio_offset < orig_len) {\n\t\tint count;\n\t\tu64 cur_disk_bytenr = orig_disk_bytenr + bio_offset;\n\t\tu8 *csum_dst = bbio->csum +\n\t\t\t(bio_offset >> fs_info->sectorsize_bits) * csum_size;\n\n\t\tcount = search_csum_tree(fs_info, path, cur_disk_bytenr,\n\t\t\t\t\t orig_len - bio_offset, csum_dst);\n\t\tif (count < 0) {\n\t\t\tret = errno_to_blk_status(count);\n\t\t\tif (bbio->csum != bbio->csum_inline)\n\t\t\t\tkfree(bbio->csum);\n\t\t\tbbio->csum = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (count == 0) {\n\t\t\tmemset(csum_dst, 0, csum_size);\n\t\t\tcount = 1;\n\n\t\t\tif (inode->root->root_key.objectid ==\n\t\t\t    BTRFS_DATA_RELOC_TREE_OBJECTID) {\n\t\t\t\tu64 file_offset = bbio->file_offset + bio_offset;\n\n\t\t\t\tset_extent_bit(&inode->io_tree, file_offset,\n\t\t\t\t\t       file_offset + sectorsize - 1,\n\t\t\t\t\t       EXTENT_NODATASUM, NULL);\n\t\t\t} else {\n\t\t\t\tbtrfs_warn_rl(fs_info,\n\t\t\t\"csum hole found for disk bytenr range [%llu, %llu)\",\n\t\t\t\tcur_disk_bytenr, cur_disk_bytenr + sectorsize);\n\t\t\t}\n\t\t}\n\t\tbio_offset += count * sectorsize;\n\t}\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nint btrfs_lookup_csums_list(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t    struct list_head *list, int search_commit,\n\t\t\t    bool nowait)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tint ret;\n\n\tASSERT(IS_ALIGNED(start, fs_info->sectorsize) &&\n\t       IS_ALIGNED(end + 1, fs_info->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->nowait = nowait;\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = READA_FORWARD;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\n\t\t \n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\tif (bytes_to_csum_size(fs_info, start - key.offset) <\n\t\t\t    btrfs_item_size(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tu64 csum_end;\n\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tcsum_end = key.offset + csum_size_to_bytes(fs_info,\n\t\t\t\t\tbtrfs_item_size(leaf, path->slots[0]));\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tunsigned long offset;\n\t\t\tsize_t size;\n\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     max_ordered_sum_bytes(fs_info));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(fs_info, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->logical = start;\n\t\t\tsums->len = size;\n\n\t\t\toffset = bytes_to_csum_size(fs_info, start - key.offset);\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   bytes_to_csum_size(fs_info, size));\n\n\t\t\tstart += size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nint btrfs_lookup_csums_bitmap(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t      u64 start, u64 end, u8 *csum_buf,\n\t\t\t      unsigned long *csum_bitmap)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_csum_item *item;\n\tconst u64 orig_start = start;\n\tbool free_path = false;\n\tint ret;\n\n\tASSERT(IS_ALIGNED(start, fs_info->sectorsize) &&\n\t       IS_ALIGNED(end + 1, fs_info->sectorsize));\n\n\tif (!path) {\n\t\tpath = btrfs_alloc_path();\n\t\tif (!path)\n\t\t\treturn -ENOMEM;\n\t\tfree_path = true;\n\t}\n\n\t \n\tif (path->nodes[0]) {\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY &&\n\t\t    key.offset <= start)\n\t\t\tgoto search_forward;\n\t\tbtrfs_release_path(path);\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\tkey.offset = start;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\n\t\t \n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\tif (bytes_to_csum_size(fs_info, start - key.offset) <\n\t\t\t    btrfs_item_size(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\nsearch_forward:\n\twhile (start <= end) {\n\t\tu64 csum_end;\n\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tcsum_end = key.offset + csum_size_to_bytes(fs_info,\n\t\t\t\t\tbtrfs_item_size(leaf, path->slots[0]));\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tunsigned long offset;\n\t\t\tsize_t size;\n\t\t\tu8 *csum_dest = csum_buf + bytes_to_csum_size(fs_info,\n\t\t\t\t\t\tstart - orig_start);\n\n\t\t\tsize = min_t(size_t, csum_end - start, end + 1 - start);\n\n\t\t\toffset = bytes_to_csum_size(fs_info, start - key.offset);\n\n\t\t\tread_extent_buffer(path->nodes[0], csum_dest,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   bytes_to_csum_size(fs_info, size));\n\n\t\t\tbitmap_set(csum_bitmap,\n\t\t\t\t(start - orig_start) >> fs_info->sectorsize_bits,\n\t\t\t\tsize >> fs_info->sectorsize_bits);\n\n\t\t\tstart += size;\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\tif (free_path)\n\t\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nblk_status_t btrfs_csum_one_bio(struct btrfs_bio *bbio)\n{\n\tstruct btrfs_ordered_extent *ordered = bbio->ordered;\n\tstruct btrfs_inode *inode = bbio->inode;\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tSHASH_DESC_ON_STACK(shash, fs_info->csum_shash);\n\tstruct bio *bio = &bbio->bio;\n\tstruct btrfs_ordered_sum *sums;\n\tchar *data;\n\tstruct bvec_iter iter;\n\tstruct bio_vec bvec;\n\tint index;\n\tunsigned int blockcount;\n\tint i;\n\tunsigned nofs_flag;\n\n\tnofs_flag = memalloc_nofs_save();\n\tsums = kvzalloc(btrfs_ordered_sum_size(fs_info, bio->bi_iter.bi_size),\n\t\t       GFP_KERNEL);\n\tmemalloc_nofs_restore(nofs_flag);\n\n\tif (!sums)\n\t\treturn BLK_STS_RESOURCE;\n\n\tsums->len = bio->bi_iter.bi_size;\n\tINIT_LIST_HEAD(&sums->list);\n\n\tsums->logical = bio->bi_iter.bi_sector << SECTOR_SHIFT;\n\tindex = 0;\n\n\tshash->tfm = fs_info->csum_shash;\n\n\tbio_for_each_segment(bvec, bio, iter) {\n\t\tblockcount = BTRFS_BYTES_TO_BLKS(fs_info,\n\t\t\t\t\t\t bvec.bv_len + fs_info->sectorsize\n\t\t\t\t\t\t - 1);\n\n\t\tfor (i = 0; i < blockcount; i++) {\n\t\t\tdata = bvec_kmap_local(&bvec);\n\t\t\tcrypto_shash_digest(shash,\n\t\t\t\t\t    data + (i * fs_info->sectorsize),\n\t\t\t\t\t    fs_info->sectorsize,\n\t\t\t\t\t    sums->sums + index);\n\t\t\tkunmap_local(data);\n\t\t\tindex += fs_info->csum_size;\n\t\t}\n\n\t}\n\n\tbbio->sums = sums;\n\tbtrfs_add_ordered_sum(ordered, sums);\n\treturn 0;\n}\n\n \nblk_status_t btrfs_alloc_dummy_sum(struct btrfs_bio *bbio)\n{\n\tbbio->sums = kmalloc(sizeof(*bbio->sums), GFP_NOFS);\n\tif (!bbio->sums)\n\t\treturn BLK_STS_RESOURCE;\n\tbbio->sums->len = bbio->bio.bi_iter.bi_size;\n\tbbio->sums->logical = bbio->bio.bi_iter.bi_sector << SECTOR_SHIFT;\n\tbtrfs_add_ordered_sum(bbio->ordered, bbio->sums);\n\treturn 0;\n}\n\n \nstatic noinline void truncate_one_csum(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       struct btrfs_key *key,\n\t\t\t\t       u64 bytenr, u64 len)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct extent_buffer *leaf;\n\tconst u32 csum_size = fs_info->csum_size;\n\tu64 csum_end;\n\tu64 end_byte = bytenr + len;\n\tu32 blocksize_bits = fs_info->sectorsize_bits;\n\n\tleaf = path->nodes[0];\n\tcsum_end = btrfs_item_size(leaf, path->slots[0]) / csum_size;\n\tcsum_end <<= blocksize_bits;\n\tcsum_end += key->offset;\n\n\tif (key->offset < bytenr && csum_end <= end_byte) {\n\t\t \n\t\tu32 new_size = (bytenr - key->offset) >> blocksize_bits;\n\t\tnew_size *= csum_size;\n\t\tbtrfs_truncate_item(trans, path, new_size, 1);\n\t} else if (key->offset >= bytenr && csum_end > end_byte &&\n\t\t   end_byte > key->offset) {\n\t\t \n\t\tu32 new_size = (csum_end - end_byte) >> blocksize_bits;\n\t\tnew_size *= csum_size;\n\n\t\tbtrfs_truncate_item(trans, path, new_size, 0);\n\n\t\tkey->offset = end_byte;\n\t\tbtrfs_set_item_key_safe(trans, path, key);\n\t} else {\n\t\tBUG();\n\t}\n}\n\n \nint btrfs_del_csums(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, u64 bytenr, u64 len)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tu64 end_byte = bytenr + len;\n\tu64 csum_end;\n\tstruct extent_buffer *leaf;\n\tint ret = 0;\n\tconst u32 csum_size = fs_info->csum_size;\n\tu32 blocksize_bits = fs_info->sectorsize_bits;\n\n\tASSERT(root->root_key.objectid == BTRFS_CSUM_TREE_OBJECTID ||\n\t       root->root_key.objectid == BTRFS_TREE_LOG_OBJECTID);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\t\tkey.offset = end_byte - 1;\n\t\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\t\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret > 0) {\n\t\t\tret = 0;\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t} else if (ret < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (key.offset >= end_byte)\n\t\t\tbreak;\n\n\t\tcsum_end = btrfs_item_size(leaf, path->slots[0]) / csum_size;\n\t\tcsum_end <<= blocksize_bits;\n\t\tcsum_end += key.offset;\n\n\t\t \n\t\tif (csum_end <= bytenr)\n\t\t\tbreak;\n\n\t\t \n\t\tif (key.offset >= bytenr && csum_end <= end_byte) {\n\t\t\tint del_nr = 1;\n\n\t\t\t \n\t\t\tif (key.offset > bytenr && path->slots[0] > 0) {\n\t\t\t\tint slot = path->slots[0] - 1;\n\n\t\t\t\twhile (slot >= 0) {\n\t\t\t\t\tstruct btrfs_key pk;\n\n\t\t\t\t\tbtrfs_item_key_to_cpu(leaf, &pk, slot);\n\t\t\t\t\tif (pk.offset < bytenr ||\n\t\t\t\t\t    pk.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t\t\t\t    pk.objectid !=\n\t\t\t\t\t    BTRFS_EXTENT_CSUM_OBJECTID)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tpath->slots[0] = slot;\n\t\t\t\t\tdel_nr++;\n\t\t\t\t\tkey.offset = pk.offset;\n\t\t\t\t\tslot--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = btrfs_del_items(trans, root, path,\n\t\t\t\t\t      path->slots[0], del_nr);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (key.offset == bytenr)\n\t\t\t\tbreak;\n\t\t} else if (key.offset < bytenr && csum_end > end_byte) {\n\t\t\tunsigned long offset;\n\t\t\tunsigned long shift_len;\n\t\t\tunsigned long item_offset;\n\t\t\t \n\t\t\toffset = (bytenr - key.offset) >> blocksize_bits;\n\t\t\toffset *= csum_size;\n\n\t\t\tshift_len = (len >> blocksize_bits) * csum_size;\n\n\t\t\titem_offset = btrfs_item_ptr_offset(leaf,\n\t\t\t\t\t\t\t    path->slots[0]);\n\n\t\t\tmemzero_extent_buffer(leaf, item_offset + offset,\n\t\t\t\t\t     shift_len);\n\t\t\tkey.offset = bytenr;\n\n\t\t\t \n\t\t\tret = btrfs_split_item(trans, root, path, &key, offset);\n\t\t\tif (ret && ret != -EAGAIN) {\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = 0;\n\n\t\t\tkey.offset = end_byte - 1;\n\t\t} else {\n\t\t\ttruncate_one_csum(trans, path, &key, bytenr, len);\n\t\t\tif (key.offset < bytenr)\n\t\t\t\tbreak;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int find_next_csum_offset(struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path,\n\t\t\t\t u64 *next_offset)\n{\n\tconst u32 nritems = btrfs_header_nritems(path->nodes[0]);\n\tstruct btrfs_key found_key;\n\tint slot = path->slots[0] + 1;\n\tint ret;\n\n\tif (nritems == 0 || slot >= nritems) {\n\t\tret = btrfs_next_leaf(root, path);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t} else if (ret > 0) {\n\t\t\t*next_offset = (u64)-1;\n\t\t\treturn 0;\n\t\t}\n\t\tslot = path->slots[0];\n\t}\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key, slot);\n\n\tif (found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t    found_key.type != BTRFS_EXTENT_CSUM_KEY)\n\t\t*next_offset = (u64)-1;\n\telse\n\t\t*next_offset = found_key.offset;\n\n\treturn 0;\n}\n\nint btrfs_csum_file_blocks(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_ordered_sum *sums)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_key file_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tstruct btrfs_csum_item *item;\n\tstruct btrfs_csum_item *item_end;\n\tstruct extent_buffer *leaf = NULL;\n\tu64 next_offset;\n\tu64 total_bytes = 0;\n\tu64 csum_offset;\n\tu64 bytenr;\n\tu32 ins_size;\n\tint index = 0;\n\tint found_next;\n\tint ret;\n\tconst u32 csum_size = fs_info->csum_size;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tnext_offset = (u64)-1;\n\tfound_next = 0;\n\tbytenr = sums->logical + total_bytes;\n\tfile_key.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tfile_key.offset = bytenr;\n\tfile_key.type = BTRFS_EXTENT_CSUM_KEY;\n\n\titem = btrfs_lookup_csum(trans, root, path, bytenr, 1);\n\tif (!IS_ERR(item)) {\n\t\tret = 0;\n\t\tleaf = path->nodes[0];\n\t\titem_end = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_csum_item);\n\t\titem_end = (struct btrfs_csum_item *)((char *)item_end +\n\t\t\t   btrfs_item_size(leaf, path->slots[0]));\n\t\tgoto found;\n\t}\n\tret = PTR_ERR(item);\n\tif (ret != -EFBIG && ret != -ENOENT)\n\t\tgoto out;\n\n\tif (ret == -EFBIG) {\n\t\tu32 item_size;\n\t\t \n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size(leaf, path->slots[0]);\n\t\tif ((item_size / csum_size) >=\n\t\t    MAX_CSUM_ITEMS(fs_info, csum_size)) {\n\t\t\t \n\t\t\tgoto insert;\n\t\t}\n\t} else {\n\t\t \n\t\tret = find_next_csum_offset(root, path, &next_offset);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tfound_next = 1;\n\t\tgoto insert;\n\t}\n\n\t \n\tif (btrfs_leaf_free_space(leaf) >= csum_size) {\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tcsum_offset = (bytenr - found_key.offset) >>\n\t\t\tfs_info->sectorsize_bits;\n\t\tgoto extend_csum;\n\t}\n\n\tbtrfs_release_path(path);\n\tpath->search_for_extension = 1;\n\tret = btrfs_search_slot(trans, root, &file_key, path,\n\t\t\t\tcsum_size, 1);\n\tpath->search_for_extension = 0;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto insert;\n\t\tpath->slots[0]--;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\tcsum_offset = (bytenr - found_key.offset) >> fs_info->sectorsize_bits;\n\n\tif (found_key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t    csum_offset >= MAX_CSUM_ITEMS(fs_info, csum_size)) {\n\t\tgoto insert;\n\t}\n\nextend_csum:\n\tif (csum_offset == btrfs_item_size(leaf, path->slots[0]) /\n\t    csum_size) {\n\t\tint extend_nr;\n\t\tu64 tmp;\n\t\tu32 diff;\n\n\t\ttmp = sums->len - total_bytes;\n\t\ttmp >>= fs_info->sectorsize_bits;\n\t\tWARN_ON(tmp < 1);\n\t\textend_nr = max_t(int, 1, tmp);\n\n\t\t \n\t\tif (root->root_key.objectid == BTRFS_TREE_LOG_OBJECTID) {\n\t\t\tif (path->slots[0] + 1 >=\n\t\t\t    btrfs_header_nritems(path->nodes[0])) {\n\t\t\t\tret = find_next_csum_offset(root, path, &next_offset);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tfound_next = 1;\n\t\t\t\tgoto insert;\n\t\t\t}\n\n\t\t\tret = find_next_csum_offset(root, path, &next_offset);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\ttmp = (next_offset - bytenr) >> fs_info->sectorsize_bits;\n\t\t\tif (tmp <= INT_MAX)\n\t\t\t\textend_nr = min_t(int, extend_nr, tmp);\n\t\t}\n\n\t\tdiff = (csum_offset + extend_nr) * csum_size;\n\t\tdiff = min(diff,\n\t\t\t   MAX_CSUM_ITEMS(fs_info, csum_size) * csum_size);\n\n\t\tdiff = diff - btrfs_item_size(leaf, path->slots[0]);\n\t\tdiff = min_t(u32, btrfs_leaf_free_space(leaf), diff);\n\t\tdiff /= csum_size;\n\t\tdiff *= csum_size;\n\n\t\tbtrfs_extend_item(trans, path, diff);\n\t\tret = 0;\n\t\tgoto csum;\n\t}\n\ninsert:\n\tbtrfs_release_path(path);\n\tcsum_offset = 0;\n\tif (found_next) {\n\t\tu64 tmp;\n\n\t\ttmp = sums->len - total_bytes;\n\t\ttmp >>= fs_info->sectorsize_bits;\n\t\ttmp = min(tmp, (next_offset - file_key.offset) >>\n\t\t\t\t\t fs_info->sectorsize_bits);\n\n\t\ttmp = max_t(u64, 1, tmp);\n\t\ttmp = min_t(u64, tmp, MAX_CSUM_ITEMS(fs_info, csum_size));\n\t\tins_size = csum_size * tmp;\n\t} else {\n\t\tins_size = csum_size;\n\t}\n\tret = btrfs_insert_empty_item(trans, root, path, &file_key,\n\t\t\t\t      ins_size);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (WARN_ON(ret != 0))\n\t\tgoto out;\n\tleaf = path->nodes[0];\ncsum:\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_csum_item);\n\titem_end = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t      btrfs_item_size(leaf, path->slots[0]));\n\titem = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t\t  csum_offset * csum_size);\nfound:\n\tins_size = (u32)(sums->len - total_bytes) >> fs_info->sectorsize_bits;\n\tins_size *= csum_size;\n\tins_size = min_t(u32, (unsigned long)item_end - (unsigned long)item,\n\t\t\t      ins_size);\n\twrite_extent_buffer(leaf, sums->sums + index, (unsigned long)item,\n\t\t\t    ins_size);\n\n\tindex += ins_size;\n\tins_size /= csum_size;\n\ttotal_bytes += ins_size * fs_info->sectorsize;\n\n\tbtrfs_mark_buffer_dirty(trans, path->nodes[0]);\n\tif (total_bytes < sums->len) {\n\t\tbtrfs_release_path(path);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nvoid btrfs_extent_item_to_extent_map(struct btrfs_inode *inode,\n\t\t\t\t     const struct btrfs_path *path,\n\t\t\t\t     struct btrfs_file_extent_item *fi,\n\t\t\t\t     struct extent_map *em)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tstruct btrfs_root *root = inode->root;\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tconst int slot = path->slots[0];\n\tstruct btrfs_key key;\n\tu64 extent_start, extent_end;\n\tu64 bytenr;\n\tu8 type = btrfs_file_extent_type(leaf, fi);\n\tint compress_type = btrfs_file_extent_compression(leaf, fi);\n\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\textent_start = key.offset;\n\textent_end = btrfs_file_extent_end(path);\n\tem->ram_bytes = btrfs_file_extent_ram_bytes(leaf, fi);\n\tem->generation = btrfs_file_extent_generation(leaf, fi);\n\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tem->start = extent_start;\n\t\tem->len = extent_end - extent_start;\n\t\tem->orig_start = extent_start -\n\t\t\tbtrfs_file_extent_offset(leaf, fi);\n\t\tem->orig_block_len = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\tbytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\tif (bytenr == 0) {\n\t\t\tem->block_start = EXTENT_MAP_HOLE;\n\t\t\treturn;\n\t\t}\n\t\tif (compress_type != BTRFS_COMPRESS_NONE) {\n\t\t\tset_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\t\tem->compress_type = compress_type;\n\t\t\tem->block_start = bytenr;\n\t\t\tem->block_len = em->orig_block_len;\n\t\t} else {\n\t\t\tbytenr += btrfs_file_extent_offset(leaf, fi);\n\t\t\tem->block_start = bytenr;\n\t\t\tem->block_len = em->len;\n\t\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC)\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t}\n\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tem->block_start = EXTENT_MAP_INLINE;\n\t\tem->start = extent_start;\n\t\tem->len = extent_end - extent_start;\n\t\t \n\t\tem->orig_start = EXTENT_MAP_HOLE;\n\t\tem->block_len = (u64)-1;\n\t\tem->compress_type = compress_type;\n\t\tif (compress_type != BTRFS_COMPRESS_NONE)\n\t\t\tset_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t} else {\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"unknown file extent item type %d, inode %llu, offset %llu, \"\n\t\t\t  \"root %llu\", type, btrfs_ino(inode), extent_start,\n\t\t\t  root->root_key.objectid);\n\t}\n}\n\n \nu64 btrfs_file_extent_end(const struct btrfs_path *path)\n{\n\tconst struct extent_buffer *leaf = path->nodes[0];\n\tconst int slot = path->slots[0];\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tu64 end;\n\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\tASSERT(key.type == BTRFS_EXTENT_DATA_KEY);\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\n\tif (btrfs_file_extent_type(leaf, fi) == BTRFS_FILE_EXTENT_INLINE) {\n\t\tend = btrfs_file_extent_ram_bytes(leaf, fi);\n\t\tend = ALIGN(key.offset + end, leaf->fs_info->sectorsize);\n\t} else {\n\t\tend = key.offset + btrfs_file_extent_num_bytes(leaf, fi);\n\t}\n\n\treturn end;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}