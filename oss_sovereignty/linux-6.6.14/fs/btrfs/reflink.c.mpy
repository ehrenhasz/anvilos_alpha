{
  "module_name": "reflink.c",
  "hash_id": "f79144aaef6ae27d2674a575a278c000ddbce41cf3be749687969a01d4879071",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/reflink.c",
  "human_readable_source": "\n\n#include <linux/blkdev.h>\n#include <linux/iversion.h>\n#include \"ctree.h\"\n#include \"fs.h\"\n#include \"messages.h\"\n#include \"compression.h\"\n#include \"delalloc-space.h\"\n#include \"disk-io.h\"\n#include \"reflink.h\"\n#include \"transaction.h\"\n#include \"subpage.h\"\n#include \"accessors.h\"\n#include \"file-item.h\"\n#include \"file.h\"\n#include \"super.h\"\n\n#define BTRFS_MAX_DEDUPE_LEN\tSZ_16M\n\nstatic int clone_finish_inode_update(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     u64 endoff,\n\t\t\t\t     const u64 destoff,\n\t\t\t\t     const u64 olen,\n\t\t\t\t     int no_time_update)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tinode_inc_iversion(inode);\n\tif (!no_time_update) {\n\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t}\n\t \n\tif (endoff > destoff + olen)\n\t\tendoff = destoff + olen;\n\tif (endoff > inode->i_size) {\n\t\ti_size_write(inode, endoff);\n\t\tbtrfs_inode_safe_disk_i_size_write(BTRFS_I(inode), 0);\n\t}\n\n\tret = btrfs_update_inode(trans, root, BTRFS_I(inode));\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tbtrfs_end_transaction(trans);\n\t\tgoto out;\n\t}\n\tret = btrfs_end_transaction(trans);\nout:\n\treturn ret;\n}\n\nstatic int copy_inline_to_page(struct btrfs_inode *inode,\n\t\t\t       const u64 file_offset,\n\t\t\t       char *inline_data,\n\t\t\t       const u64 size,\n\t\t\t       const u64 datal,\n\t\t\t       const u8 comp_type)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tconst u32 block_size = fs_info->sectorsize;\n\tconst u64 range_end = file_offset + block_size - 1;\n\tconst size_t inline_size = size - btrfs_file_extent_calc_inline_size(0);\n\tchar *data_start = inline_data + btrfs_file_extent_calc_inline_size(0);\n\tstruct extent_changeset *data_reserved = NULL;\n\tstruct page *page = NULL;\n\tstruct address_space *mapping = inode->vfs_inode.i_mapping;\n\tint ret;\n\n\tASSERT(IS_ALIGNED(file_offset, block_size));\n\n\t \n\tret = btrfs_delalloc_reserve_space(inode, &data_reserved, file_offset,\n\t\t\t\t\t   block_size);\n\tif (ret)\n\t\tgoto out;\n\n\tpage = find_or_create_page(mapping, file_offset >> PAGE_SHIFT,\n\t\t\t\t   btrfs_alloc_write_mask(mapping));\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tret = set_page_extent_mapped(page);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tclear_extent_bit(&inode->io_tree, file_offset, range_end,\n\t\t\t EXTENT_DELALLOC | EXTENT_DO_ACCOUNTING | EXTENT_DEFRAG,\n\t\t\t NULL);\n\tret = btrfs_set_extent_delalloc(inode, file_offset, range_end, 0, NULL);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tset_bit(BTRFS_INODE_NO_DELALLOC_FLUSH, &inode->runtime_flags);\n\n\tif (comp_type == BTRFS_COMPRESS_NONE) {\n\t\tmemcpy_to_page(page, offset_in_page(file_offset), data_start,\n\t\t\t       datal);\n\t} else {\n\t\tret = btrfs_decompress(comp_type, data_start, page,\n\t\t\t\t       offset_in_page(file_offset),\n\t\t\t\t       inline_size, datal);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tflush_dcache_page(page);\n\t}\n\n\t \n\tif (datal < block_size)\n\t\tmemzero_page(page, datal, block_size - datal);\n\n\tbtrfs_page_set_uptodate(fs_info, page, file_offset, block_size);\n\tbtrfs_page_clear_checked(fs_info, page, file_offset, block_size);\n\tbtrfs_page_set_dirty(fs_info, page, file_offset, block_size);\nout_unlock:\n\tif (page) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n\tif (ret)\n\t\tbtrfs_delalloc_release_space(inode, data_reserved, file_offset,\n\t\t\t\t\t     block_size, true);\n\tbtrfs_delalloc_release_extents(inode, block_size);\nout:\n\textent_changeset_free(data_reserved);\n\n\treturn ret;\n}\n\n \nstatic int clone_copy_inline_extent(struct inode *dst,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct btrfs_key *new_key,\n\t\t\t\t    const u64 drop_start,\n\t\t\t\t    const u64 datal,\n\t\t\t\t    const u64 size,\n\t\t\t\t    const u8 comp_type,\n\t\t\t\t    char *inline_data,\n\t\t\t\t    struct btrfs_trans_handle **trans_out)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(dst->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(dst)->root;\n\tconst u64 aligned_end = ALIGN(new_key->offset + datal,\n\t\t\t\t      fs_info->sectorsize);\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_drop_extents_args drop_args = { 0 };\n\tint ret;\n\tstruct btrfs_key key;\n\n\tif (new_key->offset > 0) {\n\t\tret = copy_inline_to_page(BTRFS_I(dst), new_key->offset,\n\t\t\t\t\t  inline_data, size, datal, comp_type);\n\t\tgoto out;\n\t}\n\n\tkey.objectid = btrfs_ino(BTRFS_I(dst));\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\treturn ret;\n\t} else if (ret > 0) {\n\t\tif (path->slots[0] >= btrfs_header_nritems(path->nodes[0])) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\telse if (ret > 0)\n\t\t\t\tgoto copy_inline_extent;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\t\tif (key.objectid == btrfs_ino(BTRFS_I(dst)) &&\n\t\t    key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\t \n\t\t\tASSERT(key.offset > 0);\n\t\t\tgoto copy_to_page;\n\t\t}\n\t} else if (i_size_read(dst) <= datal) {\n\t\tstruct btrfs_file_extent_item *ei;\n\n\t\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\t \n\t\tif (btrfs_file_extent_type(path->nodes[0], ei) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE)\n\t\t\tgoto copy_inline_extent;\n\n\t\tgoto copy_to_page;\n\t}\n\ncopy_inline_extent:\n\t \n\tif (i_size_read(dst) > datal) {\n\t\t \n\t\tgoto copy_to_page;\n\t}\n\n\t \n\tbtrfs_release_path(path);\n\t \n\ttrans = btrfs_start_transaction(root, 3);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\ttrans = NULL;\n\t\tgoto out;\n\t}\n\tdrop_args.path = path;\n\tdrop_args.start = drop_start;\n\tdrop_args.end = aligned_end;\n\tdrop_args.drop_cache = true;\n\tret = btrfs_drop_extents(trans, root, BTRFS_I(dst), &drop_args);\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_insert_empty_item(trans, root, path, new_key, size);\n\tif (ret)\n\t\tgoto out;\n\n\twrite_extent_buffer(path->nodes[0], inline_data,\n\t\t\t    btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\t\t  path->slots[0]),\n\t\t\t    size);\n\tbtrfs_update_inode_bytes(BTRFS_I(dst), datal, drop_args.bytes_found);\n\tbtrfs_set_inode_full_sync(BTRFS_I(dst));\n\tret = btrfs_inode_set_file_extent_range(BTRFS_I(dst), 0, aligned_end);\nout:\n\tif (!ret && !trans) {\n\t\t \n\t\ttrans = btrfs_start_transaction(root, 1);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t}\n\t}\n\tif (ret && trans) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tbtrfs_end_transaction(trans);\n\t}\n\tif (!ret)\n\t\t*trans_out = trans;\n\n\treturn ret;\n\ncopy_to_page:\n\t \n\tbtrfs_release_path(path);\n\n\tret = copy_inline_to_page(BTRFS_I(dst), new_key->offset,\n\t\t\t\t  inline_data, size, datal, comp_type);\n\tgoto out;\n}\n\n \nstatic int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       const u64 off, const u64 olen, const u64 olen_aligned,\n\t\t       const u64 destoff, int no_time_update)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_trans_handle *trans;\n\tchar *buf = NULL;\n\tstruct btrfs_key key;\n\tu32 nritems;\n\tint slot;\n\tint ret;\n\tconst u64 len = olen_aligned;\n\tu64 last_dest_end = destoff;\n\tu64 prev_extent_end = off;\n\n\tret = -ENOMEM;\n\tbuf = kvmalloc(fs_info->nodesize, GFP_KERNEL);\n\tif (!buf)\n\t\treturn ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tkvfree(buf);\n\t\treturn ret;\n\t}\n\n\tpath->reada = READA_FORWARD;\n\t \n\tkey.objectid = btrfs_ino(BTRFS_I(src));\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = off;\n\n\twhile (1) {\n\t\tstruct btrfs_file_extent_item *extent;\n\t\tu64 extent_gen;\n\t\tint type;\n\t\tu32 size;\n\t\tstruct btrfs_key new_key;\n\t\tu64 disko = 0, diskl = 0;\n\t\tu64 datao = 0, datal = 0;\n\t\tu8 comp;\n\t\tu64 drop_start;\n\n\t\t \n\t\tret = btrfs_search_slot(NULL, BTRFS_I(src)->root, &key, path,\n\t\t\t\t0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t \n\t\tif (key.offset == off && ret > 0 && path->slots[0] > 0) {\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0] - 1);\n\t\t\tif (key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\nprocess_slot:\n\t\tif (path->slots[0] >= nritems) {\n\t\t\tret = btrfs_next_leaf(BTRFS_I(src)->root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.type > BTRFS_EXTENT_DATA_KEY ||\n\t\t    key.objectid != btrfs_ino(BTRFS_I(src)))\n\t\t\tbreak;\n\n\t\tASSERT(key.type == BTRFS_EXTENT_DATA_KEY);\n\n\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\textent_gen = btrfs_file_extent_generation(leaf, extent);\n\t\tcomp = btrfs_file_extent_compression(leaf, extent);\n\t\ttype = btrfs_file_extent_type(leaf, extent);\n\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\tdisko = btrfs_file_extent_disk_bytenr(leaf, extent);\n\t\t\tdiskl = btrfs_file_extent_disk_num_bytes(leaf, extent);\n\t\t\tdatao = btrfs_file_extent_offset(leaf, extent);\n\t\t\tdatal = btrfs_file_extent_num_bytes(leaf, extent);\n\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t \n\t\t\tdatal = btrfs_file_extent_ram_bytes(leaf, extent);\n\t\t}\n\n\t\t \n\t\tif (key.offset + datal <= prev_extent_end) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto process_slot;\n\t\t} else if (key.offset >= off + len) {\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_extent_end = key.offset + datal;\n\t\tsize = btrfs_item_size(leaf, slot);\n\t\tread_extent_buffer(leaf, buf, btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t   size);\n\n\t\tbtrfs_release_path(path);\n\n\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\tnew_key.objectid = btrfs_ino(BTRFS_I(inode));\n\t\tif (off <= key.offset)\n\t\t\tnew_key.offset = key.offset + destoff - off;\n\t\telse\n\t\t\tnew_key.offset = destoff;\n\n\t\t \n\t\tif (new_key.offset != last_dest_end)\n\t\t\tdrop_start = last_dest_end;\n\t\telse\n\t\t\tdrop_start = new_key.offset;\n\n\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\tstruct btrfs_replace_extent_info clone_info;\n\n\t\t\t \n\n\t\t\t \n\t\t\tif (key.offset + datal > off + len)\n\t\t\t\tdatal = off + len - key.offset;\n\n\t\t\t \n\t\t\tif (off > key.offset) {\n\t\t\t\tdatao += off - key.offset;\n\t\t\t\tdatal -= off - key.offset;\n\t\t\t}\n\n\t\t\tclone_info.disk_offset = disko;\n\t\t\tclone_info.disk_len = diskl;\n\t\t\tclone_info.data_offset = datao;\n\t\t\tclone_info.data_len = datal;\n\t\t\tclone_info.file_offset = new_key.offset;\n\t\t\tclone_info.extent_buf = buf;\n\t\t\tclone_info.is_new_extent = false;\n\t\t\tclone_info.update_times = !no_time_update;\n\t\t\tret = btrfs_replace_file_extents(BTRFS_I(inode), path,\n\t\t\t\t\tdrop_start, new_key.offset + datal - 1,\n\t\t\t\t\t&clone_info, &trans);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tASSERT(type == BTRFS_FILE_EXTENT_INLINE);\n\t\t\t \n\t\t\tASSERT(key.offset == 0);\n\t\t\tASSERT(datal <= fs_info->sectorsize);\n\t\t\tif (WARN_ON(type != BTRFS_FILE_EXTENT_INLINE) ||\n\t\t\t    WARN_ON(key.offset != 0) ||\n\t\t\t    WARN_ON(datal > fs_info->sectorsize)) {\n\t\t\t\tret = -EUCLEAN;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = clone_copy_inline_extent(inode, path, &new_key,\n\t\t\t\t\t\t       drop_start, datal, size,\n\t\t\t\t\t\t       comp, buf, &trans);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tbtrfs_release_path(path);\n\n\t\t \n\t\tif (extent_gen == trans->transid && disko > 0)\n\t\t\tBTRFS_I(src)->last_reflink_trans = trans->transid;\n\n\t\tBTRFS_I(inode)->last_reflink_trans = trans->transid;\n\n\t\tlast_dest_end = ALIGN(new_key.offset + datal,\n\t\t\t\t      fs_info->sectorsize);\n\t\tret = clone_finish_inode_update(trans, inode, last_dest_end,\n\t\t\t\t\t\tdestoff, olen, no_time_update);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tif (new_key.offset + datal >= destoff + len)\n\t\t\tbreak;\n\n\t\tbtrfs_release_path(path);\n\t\tkey.offset = prev_extent_end;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\tret = 0;\n\n\tif (last_dest_end < destoff + len) {\n\t\t \n\t\tbtrfs_release_path(path);\n\n\t\t \n\t\tif (last_dest_end >= i_size_read(inode))\n\t\t\tbtrfs_set_inode_full_sync(BTRFS_I(inode));\n\n\t\tret = btrfs_replace_file_extents(BTRFS_I(inode), path,\n\t\t\t\tlast_dest_end, destoff + len - 1, NULL, &trans);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = clone_finish_inode_update(trans, inode, destoff + len,\n\t\t\t\t\t\tdestoff, olen, no_time_update);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tkvfree(buf);\n\tclear_bit(BTRFS_INODE_NO_DELALLOC_FLUSH, &BTRFS_I(inode)->runtime_flags);\n\n\treturn ret;\n}\n\nstatic void btrfs_double_extent_unlock(struct inode *inode1, u64 loff1,\n\t\t\t\t       struct inode *inode2, u64 loff2, u64 len)\n{\n\tunlock_extent(&BTRFS_I(inode1)->io_tree, loff1, loff1 + len - 1, NULL);\n\tunlock_extent(&BTRFS_I(inode2)->io_tree, loff2, loff2 + len - 1, NULL);\n}\n\nstatic void btrfs_double_extent_lock(struct inode *inode1, u64 loff1,\n\t\t\t\t     struct inode *inode2, u64 loff2, u64 len)\n{\n\tu64 range1_end = loff1 + len - 1;\n\tu64 range2_end = loff2 + len - 1;\n\n\tif (inode1 < inode2) {\n\t\tswap(inode1, inode2);\n\t\tswap(loff1, loff2);\n\t\tswap(range1_end, range2_end);\n\t} else if (inode1 == inode2 && loff2 < loff1) {\n\t\tswap(loff1, loff2);\n\t\tswap(range1_end, range2_end);\n\t}\n\n\tlock_extent(&BTRFS_I(inode1)->io_tree, loff1, range1_end, NULL);\n\tlock_extent(&BTRFS_I(inode2)->io_tree, loff2, range2_end, NULL);\n\n\tbtrfs_assert_inode_range_clean(BTRFS_I(inode1), loff1, range1_end);\n\tbtrfs_assert_inode_range_clean(BTRFS_I(inode2), loff2, range2_end);\n}\n\nstatic void btrfs_double_mmap_lock(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 < inode2)\n\t\tswap(inode1, inode2);\n\tdown_write(&BTRFS_I(inode1)->i_mmap_lock);\n\tdown_write_nested(&BTRFS_I(inode2)->i_mmap_lock, SINGLE_DEPTH_NESTING);\n}\n\nstatic void btrfs_double_mmap_unlock(struct inode *inode1, struct inode *inode2)\n{\n\tup_write(&BTRFS_I(inode1)->i_mmap_lock);\n\tup_write(&BTRFS_I(inode2)->i_mmap_lock);\n}\n\nstatic int btrfs_extent_same_range(struct inode *src, u64 loff, u64 len,\n\t\t\t\t   struct inode *dst, u64 dst_loff)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(src)->root->fs_info;\n\tconst u64 bs = fs_info->sb->s_blocksize;\n\tint ret;\n\n\t \n\tbtrfs_double_extent_lock(src, loff, dst, dst_loff, len);\n\tret = btrfs_clone(src, dst, loff, len, ALIGN(len, bs), dst_loff, 1);\n\tbtrfs_double_extent_unlock(src, loff, dst, dst_loff, len);\n\n\tbtrfs_btree_balance_dirty(fs_info);\n\n\treturn ret;\n}\n\nstatic int btrfs_extent_same(struct inode *src, u64 loff, u64 olen,\n\t\t\t     struct inode *dst, u64 dst_loff)\n{\n\tint ret = 0;\n\tu64 i, tail_len, chunk_count;\n\tstruct btrfs_root *root_dst = BTRFS_I(dst)->root;\n\n\tspin_lock(&root_dst->root_item_lock);\n\tif (root_dst->send_in_progress) {\n\t\tbtrfs_warn_rl(root_dst->fs_info,\n\"cannot deduplicate to root %llu while send operations are using it (%d in progress)\",\n\t\t\t      root_dst->root_key.objectid,\n\t\t\t      root_dst->send_in_progress);\n\t\tspin_unlock(&root_dst->root_item_lock);\n\t\treturn -EAGAIN;\n\t}\n\troot_dst->dedupe_in_progress++;\n\tspin_unlock(&root_dst->root_item_lock);\n\n\ttail_len = olen % BTRFS_MAX_DEDUPE_LEN;\n\tchunk_count = div_u64(olen, BTRFS_MAX_DEDUPE_LEN);\n\n\tfor (i = 0; i < chunk_count; i++) {\n\t\tret = btrfs_extent_same_range(src, loff, BTRFS_MAX_DEDUPE_LEN,\n\t\t\t\t\t      dst, dst_loff);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tloff += BTRFS_MAX_DEDUPE_LEN;\n\t\tdst_loff += BTRFS_MAX_DEDUPE_LEN;\n\t}\n\n\tif (tail_len > 0)\n\t\tret = btrfs_extent_same_range(src, loff, tail_len, dst, dst_loff);\nout:\n\tspin_lock(&root_dst->root_item_lock);\n\troot_dst->dedupe_in_progress--;\n\tspin_unlock(&root_dst->root_item_lock);\n\n\treturn ret;\n}\n\nstatic noinline int btrfs_clone_files(struct file *file, struct file *file_src,\n\t\t\t\t\tu64 off, u64 olen, u64 destoff)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct inode *src = file_inode(file_src);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tint ret;\n\tint wb_ret;\n\tu64 len = olen;\n\tu64 bs = fs_info->sb->s_blocksize;\n\n\t \n\tif (off + len == src->i_size)\n\t\tlen = ALIGN(src->i_size, bs) - off;\n\n\tif (destoff > inode->i_size) {\n\t\tconst u64 wb_start = ALIGN_DOWN(inode->i_size, bs);\n\n\t\tret = btrfs_cont_expand(BTRFS_I(inode), inode->i_size, destoff);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\tret = btrfs_wait_ordered_range(inode, wb_start,\n\t\t\t\t\t       destoff - wb_start);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tbtrfs_double_extent_lock(src, off, inode, destoff, len);\n\tret = btrfs_clone(src, inode, off, olen, len, destoff, 0);\n\tbtrfs_double_extent_unlock(src, off, inode, destoff, len);\n\n\t \n\twb_ret = btrfs_wait_ordered_range(inode, destoff, len);\n\tret = ret ? ret : wb_ret;\n\t \n\ttruncate_inode_pages_range(&inode->i_data,\n\t\t\t\tround_down(destoff, PAGE_SIZE),\n\t\t\t\tround_up(destoff + len, PAGE_SIZE) - 1);\n\n\tbtrfs_btree_balance_dirty(fs_info);\n\n\treturn ret;\n}\n\nstatic int btrfs_remap_file_range_prep(struct file *file_in, loff_t pos_in,\n\t\t\t\t       struct file *file_out, loff_t pos_out,\n\t\t\t\t       loff_t *len, unsigned int remap_flags)\n{\n\tstruct inode *inode_in = file_inode(file_in);\n\tstruct inode *inode_out = file_inode(file_out);\n\tu64 bs = BTRFS_I(inode_out)->root->fs_info->sb->s_blocksize;\n\tu64 wb_len;\n\tint ret;\n\n\tif (!(remap_flags & REMAP_FILE_DEDUP)) {\n\t\tstruct btrfs_root *root_out = BTRFS_I(inode_out)->root;\n\n\t\tif (btrfs_root_readonly(root_out))\n\t\t\treturn -EROFS;\n\n\t\tASSERT(inode_in->i_sb == inode_out->i_sb);\n\t}\n\n\t \n\tif ((BTRFS_I(inode_in)->flags & BTRFS_INODE_NODATASUM) !=\n\t    (BTRFS_I(inode_out)->flags & BTRFS_INODE_NODATASUM)) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (*len == 0 && !(remap_flags & REMAP_FILE_DEDUP))\n\t\twb_len = ALIGN(inode_in->i_size, bs) - ALIGN_DOWN(pos_in, bs);\n\telse\n\t\twb_len = ALIGN(*len, bs);\n\n\t \n\tret = filemap_flush(inode_in->i_mapping);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = btrfs_wait_ordered_range(inode_in, ALIGN_DOWN(pos_in, bs),\n\t\t\t\t       wb_len);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = btrfs_wait_ordered_range(inode_out, ALIGN_DOWN(pos_out, bs),\n\t\t\t\t       wb_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn generic_remap_file_range_prep(file_in, pos_in, file_out, pos_out,\n\t\t\t\t\t    len, remap_flags);\n}\n\nstatic bool file_sync_write(const struct file *file)\n{\n\tif (file->f_flags & (__O_SYNC | O_DSYNC))\n\t\treturn true;\n\tif (IS_SYNC(file_inode(file)))\n\t\treturn true;\n\n\treturn false;\n}\n\nloff_t btrfs_remap_file_range(struct file *src_file, loff_t off,\n\t\tstruct file *dst_file, loff_t destoff, loff_t len,\n\t\tunsigned int remap_flags)\n{\n\tstruct inode *src_inode = file_inode(src_file);\n\tstruct inode *dst_inode = file_inode(dst_file);\n\tbool same_inode = dst_inode == src_inode;\n\tint ret;\n\n\tif (remap_flags & ~(REMAP_FILE_DEDUP | REMAP_FILE_ADVISORY))\n\t\treturn -EINVAL;\n\n\tif (same_inode) {\n\t\tbtrfs_inode_lock(BTRFS_I(src_inode), BTRFS_ILOCK_MMAP);\n\t} else {\n\t\tlock_two_nondirectories(src_inode, dst_inode);\n\t\tbtrfs_double_mmap_lock(src_inode, dst_inode);\n\t}\n\n\tret = btrfs_remap_file_range_prep(src_file, off, dst_file, destoff,\n\t\t\t\t\t  &len, remap_flags);\n\tif (ret < 0 || len == 0)\n\t\tgoto out_unlock;\n\n\tif (remap_flags & REMAP_FILE_DEDUP)\n\t\tret = btrfs_extent_same(src_inode, off, len, dst_inode, destoff);\n\telse\n\t\tret = btrfs_clone_files(dst_file, src_file, off, len, destoff);\n\nout_unlock:\n\tif (same_inode) {\n\t\tbtrfs_inode_unlock(BTRFS_I(src_inode), BTRFS_ILOCK_MMAP);\n\t} else {\n\t\tbtrfs_double_mmap_unlock(src_inode, dst_inode);\n\t\tunlock_two_nondirectories(src_inode, dst_inode);\n\t}\n\n\t \n\tif (ret == 0 && len > 0 &&\n\t    (file_sync_write(src_file) || file_sync_write(dst_file))) {\n\t\tret = btrfs_sync_file(src_file, off, off + len - 1, 0);\n\t\tif (ret == 0)\n\t\t\tret = btrfs_sync_file(dst_file, destoff,\n\t\t\t\t\t      destoff + len - 1, 0);\n\t}\n\n\treturn ret < 0 ? ret : len;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}