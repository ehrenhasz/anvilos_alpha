{
  "module_name": "dev-replace.c",
  "hash_id": "518ae7e914a286ffe4ab6f62c257b1ceae9a1bd14c68b59e010d2e430af8b297",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/dev-replace.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kthread.h>\n#include <linux/math64.h>\n#include \"misc.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"async-thread.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"sysfs.h\"\n#include \"zoned.h\"\n#include \"block-group.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n#include \"scrub.h\"\n\n \n\nstatic int btrfs_dev_replace_finishing(struct btrfs_fs_info *fs_info,\n\t\t\t\t       int scrub_ret);\nstatic int btrfs_dev_replace_kthread(void *data);\n\nint btrfs_init_dev_replace(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_lookup_args args = { .devid = BTRFS_DEV_REPLACE_DEVID };\n\tstruct btrfs_key key;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tint ret = 0;\n\tstruct btrfs_path *path = NULL;\n\tint item_size;\n\tstruct btrfs_dev_replace_item *ptr;\n\tu64 src_devid;\n\n\tif (!dev_root)\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_DEV_REPLACE_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, dev_root, &key, path, 0, 0);\n\tif (ret) {\nno_valid_dev_replace_entry_found:\n\t\t \n\t\tif (btrfs_find_device(fs_info->fs_devices, &args)) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\"found replace target device without a valid replace item\");\n\t\t\tret = -EUCLEAN;\n\t\t\tgoto out;\n\t\t}\n\t\tret = 0;\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED;\n\t\tdev_replace->cont_reading_from_srcdev_mode =\n\t\t    BTRFS_DEV_REPLACE_ITEM_CONT_READING_FROM_SRCDEV_MODE_ALWAYS;\n\t\tdev_replace->time_started = 0;\n\t\tdev_replace->time_stopped = 0;\n\t\tatomic64_set(&dev_replace->num_write_errors, 0);\n\t\tatomic64_set(&dev_replace->num_uncorrectable_read_errors, 0);\n\t\tdev_replace->cursor_left = 0;\n\t\tdev_replace->committed_cursor_left = 0;\n\t\tdev_replace->cursor_left_last_write_of_item = 0;\n\t\tdev_replace->cursor_right = 0;\n\t\tdev_replace->srcdev = NULL;\n\t\tdev_replace->tgtdev = NULL;\n\t\tdev_replace->is_valid = 0;\n\t\tdev_replace->item_needs_writeback = 0;\n\t\tgoto out;\n\t}\n\tslot = path->slots[0];\n\teb = path->nodes[0];\n\titem_size = btrfs_item_size(eb, slot);\n\tptr = btrfs_item_ptr(eb, slot, struct btrfs_dev_replace_item);\n\n\tif (item_size != sizeof(struct btrfs_dev_replace_item)) {\n\t\tbtrfs_warn(fs_info,\n\t\t\t\"dev_replace entry found has unexpected size, ignore entry\");\n\t\tgoto no_valid_dev_replace_entry_found;\n\t}\n\n\tsrc_devid = btrfs_dev_replace_src_devid(eb, ptr);\n\tdev_replace->cont_reading_from_srcdev_mode =\n\t\tbtrfs_dev_replace_cont_reading_from_srcdev_mode(eb, ptr);\n\tdev_replace->replace_state = btrfs_dev_replace_replace_state(eb, ptr);\n\tdev_replace->time_started = btrfs_dev_replace_time_started(eb, ptr);\n\tdev_replace->time_stopped =\n\t\tbtrfs_dev_replace_time_stopped(eb, ptr);\n\tatomic64_set(&dev_replace->num_write_errors,\n\t\t     btrfs_dev_replace_num_write_errors(eb, ptr));\n\tatomic64_set(&dev_replace->num_uncorrectable_read_errors,\n\t\t     btrfs_dev_replace_num_uncorrectable_read_errors(eb, ptr));\n\tdev_replace->cursor_left = btrfs_dev_replace_cursor_left(eb, ptr);\n\tdev_replace->committed_cursor_left = dev_replace->cursor_left;\n\tdev_replace->cursor_left_last_write_of_item = dev_replace->cursor_left;\n\tdev_replace->cursor_right = btrfs_dev_replace_cursor_right(eb, ptr);\n\tdev_replace->is_valid = 1;\n\n\tdev_replace->item_needs_writeback = 0;\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\t \n\t\tif (btrfs_find_device(fs_info->fs_devices, &args)) {\n\t\t\tbtrfs_err(fs_info,\n\"replace without active item, run 'device scan --forget' on the target device\");\n\t\t\tret = -EUCLEAN;\n\t\t} else {\n\t\t\tdev_replace->srcdev = NULL;\n\t\t\tdev_replace->tgtdev = NULL;\n\t\t}\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tdev_replace->tgtdev = btrfs_find_device(fs_info->fs_devices, &args);\n\t\targs.devid = src_devid;\n\t\tdev_replace->srcdev = btrfs_find_device(fs_info->fs_devices, &args);\n\n\t\t \n\t\tif (!dev_replace->srcdev &&\n\t\t    !btrfs_test_opt(fs_info, DEGRADED)) {\n\t\t\tret = -EIO;\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"cannot mount because device replace operation is ongoing and\");\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"srcdev (devid %llu) is missing, need to run 'btrfs dev scan'?\",\n\t\t\t   src_devid);\n\t\t}\n\t\tif (!dev_replace->tgtdev &&\n\t\t    !btrfs_test_opt(fs_info, DEGRADED)) {\n\t\t\tret = -EIO;\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"cannot mount because device replace operation is ongoing and\");\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"tgtdev (devid %llu) is missing, need to run 'btrfs dev scan'?\",\n\t\t\t\tBTRFS_DEV_REPLACE_DEVID);\n\t\t}\n\t\tif (dev_replace->tgtdev) {\n\t\t\tif (dev_replace->srcdev) {\n\t\t\t\tdev_replace->tgtdev->total_bytes =\n\t\t\t\t\tdev_replace->srcdev->total_bytes;\n\t\t\t\tdev_replace->tgtdev->disk_total_bytes =\n\t\t\t\t\tdev_replace->srcdev->disk_total_bytes;\n\t\t\t\tdev_replace->tgtdev->commit_total_bytes =\n\t\t\t\t\tdev_replace->srcdev->commit_total_bytes;\n\t\t\t\tdev_replace->tgtdev->bytes_used =\n\t\t\t\t\tdev_replace->srcdev->bytes_used;\n\t\t\t\tdev_replace->tgtdev->commit_bytes_used =\n\t\t\t\t\tdev_replace->srcdev->commit_bytes_used;\n\t\t\t}\n\t\t\tset_bit(BTRFS_DEV_STATE_REPLACE_TGT,\n\t\t\t\t&dev_replace->tgtdev->dev_state);\n\n\t\t\tWARN_ON(fs_info->fs_devices->rw_devices == 0);\n\t\t\tdev_replace->tgtdev->io_width = fs_info->sectorsize;\n\t\t\tdev_replace->tgtdev->io_align = fs_info->sectorsize;\n\t\t\tdev_replace->tgtdev->sector_size = fs_info->sectorsize;\n\t\t\tdev_replace->tgtdev->fs_info = fs_info;\n\t\t\tset_bit(BTRFS_DEV_STATE_IN_FS_METADATA,\n\t\t\t\t&dev_replace->tgtdev->dev_state);\n\t\t}\n\t\tbreak;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nstatic int btrfs_init_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,\n\t\t\t\t  const char *device_path,\n\t\t\t\t  struct btrfs_device *srcdev,\n\t\t\t\t  struct btrfs_device **device_out)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\tstruct block_device *bdev;\n\tu64 devid = BTRFS_DEV_REPLACE_DEVID;\n\tint ret = 0;\n\n\t*device_out = NULL;\n\tif (srcdev->fs_devices->seeding) {\n\t\tbtrfs_err(fs_info, \"the filesystem is a seed filesystem!\");\n\t\treturn -EINVAL;\n\t}\n\n\tbdev = blkdev_get_by_path(device_path, BLK_OPEN_WRITE,\n\t\t\t\t  fs_info->bdev_holder, NULL);\n\tif (IS_ERR(bdev)) {\n\t\tbtrfs_err(fs_info, \"target device %s is invalid!\", device_path);\n\t\treturn PTR_ERR(bdev);\n\t}\n\n\tif (!btrfs_check_device_zone_type(fs_info, bdev)) {\n\t\tbtrfs_err(fs_info,\n\t\t\"dev-replace: zoned type of target device mismatch with filesystem\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tsync_blockdev(bdev);\n\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tif (device->bdev == bdev) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\t  \"target device is in the filesystem!\");\n\t\t\tret = -EEXIST;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\n\tif (bdev_nr_bytes(bdev) < btrfs_device_get_total_bytes(srcdev)) {\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"target device is smaller than source device!\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\n\tdevice = btrfs_alloc_device(NULL, &devid, NULL, device_path);\n\tif (IS_ERR(device)) {\n\t\tret = PTR_ERR(device);\n\t\tgoto error;\n\t}\n\n\tret = lookup_bdev(device_path, &device->devt);\n\tif (ret)\n\t\tgoto error;\n\n\tset_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state);\n\tdevice->generation = 0;\n\tdevice->io_width = fs_info->sectorsize;\n\tdevice->io_align = fs_info->sectorsize;\n\tdevice->sector_size = fs_info->sectorsize;\n\tdevice->total_bytes = btrfs_device_get_total_bytes(srcdev);\n\tdevice->disk_total_bytes = btrfs_device_get_disk_total_bytes(srcdev);\n\tdevice->bytes_used = btrfs_device_get_bytes_used(srcdev);\n\tdevice->commit_total_bytes = srcdev->commit_total_bytes;\n\tdevice->commit_bytes_used = device->bytes_used;\n\tdevice->fs_info = fs_info;\n\tdevice->bdev = bdev;\n\tset_bit(BTRFS_DEV_STATE_IN_FS_METADATA, &device->dev_state);\n\tset_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state);\n\tdevice->holder = fs_info->bdev_holder;\n\tdevice->dev_stats_valid = 1;\n\tset_blocksize(device->bdev, BTRFS_BDEV_BLOCKSIZE);\n\tdevice->fs_devices = fs_devices;\n\n\tret = btrfs_get_dev_zone_info(device, false);\n\tif (ret)\n\t\tgoto error;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_add(&device->dev_list, &fs_devices->devices);\n\tfs_devices->num_devices++;\n\tfs_devices->open_devices++;\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\t*device_out = device;\n\treturn 0;\n\nerror:\n\tblkdev_put(bdev, fs_info->bdev_holder);\n\treturn ret;\n}\n\n \nint btrfs_run_dev_replace(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tint ret;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_dev_replace_item *ptr;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tdown_read(&dev_replace->rwsem);\n\tif (!dev_replace->is_valid ||\n\t    !dev_replace->item_needs_writeback) {\n\t\tup_read(&dev_replace->rwsem);\n\t\treturn 0;\n\t}\n\tup_read(&dev_replace->rwsem);\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_DEV_REPLACE_KEY;\n\tkey.offset = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tret = btrfs_search_slot(trans, dev_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tbtrfs_warn(fs_info,\n\t\t\t   \"error %d while searching for dev_replace item!\",\n\t\t\t   ret);\n\t\tgoto out;\n\t}\n\n\tif (ret == 0 &&\n\t    btrfs_item_size(path->nodes[0], path->slots[0]) < sizeof(*ptr)) {\n\t\t \n\t\tret = btrfs_del_item(trans, dev_root, path);\n\t\tif (ret != 0) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t   \"delete too small dev_replace item failed %d!\",\n\t\t\t\t   ret);\n\t\t\tgoto out;\n\t\t}\n\t\tret = 1;\n\t}\n\n\tif (ret == 1) {\n\t\t \n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, dev_root, path,\n\t\t\t\t\t      &key, sizeof(*ptr));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t   \"insert dev_replace item failed %d!\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\teb = path->nodes[0];\n\tptr = btrfs_item_ptr(eb, path->slots[0],\n\t\t\t     struct btrfs_dev_replace_item);\n\n\tdown_write(&dev_replace->rwsem);\n\tif (dev_replace->srcdev)\n\t\tbtrfs_set_dev_replace_src_devid(eb, ptr,\n\t\t\tdev_replace->srcdev->devid);\n\telse\n\t\tbtrfs_set_dev_replace_src_devid(eb, ptr, (u64)-1);\n\tbtrfs_set_dev_replace_cont_reading_from_srcdev_mode(eb, ptr,\n\t\tdev_replace->cont_reading_from_srcdev_mode);\n\tbtrfs_set_dev_replace_replace_state(eb, ptr,\n\t\tdev_replace->replace_state);\n\tbtrfs_set_dev_replace_time_started(eb, ptr, dev_replace->time_started);\n\tbtrfs_set_dev_replace_time_stopped(eb, ptr, dev_replace->time_stopped);\n\tbtrfs_set_dev_replace_num_write_errors(eb, ptr,\n\t\tatomic64_read(&dev_replace->num_write_errors));\n\tbtrfs_set_dev_replace_num_uncorrectable_read_errors(eb, ptr,\n\t\tatomic64_read(&dev_replace->num_uncorrectable_read_errors));\n\tdev_replace->cursor_left_last_write_of_item =\n\t\tdev_replace->cursor_left;\n\tbtrfs_set_dev_replace_cursor_left(eb, ptr,\n\t\tdev_replace->cursor_left_last_write_of_item);\n\tbtrfs_set_dev_replace_cursor_right(eb, ptr,\n\t\tdev_replace->cursor_right);\n\tdev_replace->item_needs_writeback = 0;\n\tup_write(&dev_replace->rwsem);\n\n\tbtrfs_mark_buffer_dirty(trans, eb);\n\nout:\n\tbtrfs_free_path(path);\n\n\treturn ret;\n}\n\nstatic int mark_block_group_to_copy(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct btrfs_device *src_dev)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_root *root = fs_info->dev_root;\n\tstruct btrfs_dev_extent *dev_extent = NULL;\n\tstruct btrfs_block_group *cache;\n\tstruct btrfs_trans_handle *trans;\n\tint iter_ret = 0;\n\tint ret = 0;\n\tu64 chunk_offset;\n\n\t \n\tif (!btrfs_is_zoned(fs_info))\n\t\treturn 0;\n\n\tmutex_lock(&fs_info->chunk_mutex);\n\n\t \n\tspin_lock(&fs_info->trans_lock);\n\twhile (fs_info->running_transaction &&\n\t       !list_empty(&fs_info->running_transaction->dev_update_list)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\ttrans = btrfs_attach_transaction(root);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\t\tif (ret == -ENOENT) {\n\t\t\t\tspin_lock(&fs_info->trans_lock);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\n\t\tret = btrfs_commit_transaction(trans);\n\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tspin_lock(&fs_info->trans_lock);\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tpath->reada = READA_FORWARD;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\n\tkey.objectid = src_dev->devid;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\tkey.offset = 0;\n\n\tbtrfs_for_each_slot(root, &key, &found_key, path, iter_ret) {\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\n\t\tif (found_key.objectid != src_dev->devid)\n\t\t\tbreak;\n\n\t\tif (found_key.type != BTRFS_DEV_EXTENT_KEY)\n\t\t\tbreak;\n\n\t\tif (found_key.offset < key.offset)\n\t\t\tbreak;\n\n\t\tdev_extent = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dev_extent);\n\n\t\tchunk_offset = btrfs_dev_extent_chunk_offset(leaf, dev_extent);\n\n\t\tcache = btrfs_lookup_block_group(fs_info, chunk_offset);\n\t\tif (!cache)\n\t\t\tcontinue;\n\n\t\tset_bit(BLOCK_GROUP_FLAG_TO_COPY, &cache->runtime_flags);\n\t\tbtrfs_put_block_group(cache);\n\t}\n\tif (iter_ret < 0)\n\t\tret = iter_ret;\n\n\tbtrfs_free_path(path);\nunlock:\n\tmutex_unlock(&fs_info->chunk_mutex);\n\n\treturn ret;\n}\n\nbool btrfs_finish_block_group_to_copy(struct btrfs_device *srcdev,\n\t\t\t\t      struct btrfs_block_group *cache,\n\t\t\t\t      u64 physical)\n{\n\tstruct btrfs_fs_info *fs_info = cache->fs_info;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tu64 chunk_offset = cache->start;\n\tint num_extents, cur_extent;\n\tint i;\n\n\t \n\tif (!btrfs_is_zoned(fs_info))\n\t\treturn true;\n\n\tspin_lock(&cache->lock);\n\tif (test_bit(BLOCK_GROUP_FLAG_REMOVED, &cache->runtime_flags)) {\n\t\tspin_unlock(&cache->lock);\n\t\treturn true;\n\t}\n\tspin_unlock(&cache->lock);\n\n\tem = btrfs_get_chunk_map(fs_info, chunk_offset, 1);\n\tASSERT(!IS_ERR(em));\n\tmap = em->map_lookup;\n\n\tnum_extents = 0;\n\tcur_extent = 0;\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\t \n\t\tif (srcdev != map->stripes[i].dev)\n\t\t\tcontinue;\n\n\t\tnum_extents++;\n\t\tif (physical == map->stripes[i].physical)\n\t\t\tcur_extent = i;\n\t}\n\n\tfree_extent_map(em);\n\n\tif (num_extents > 1 && cur_extent < num_extents - 1) {\n\t\t \n\t\treturn false;\n\t}\n\n\t \n\tclear_bit(BLOCK_GROUP_FLAG_TO_COPY, &cache->runtime_flags);\n\n\treturn true;\n}\n\nstatic int btrfs_dev_replace_start(struct btrfs_fs_info *fs_info,\n\t\tconst char *tgtdev_name, u64 srcdevid, const char *srcdev_name,\n\t\tint read_src)\n{\n\tstruct btrfs_root *root = fs_info->dev_root;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tint ret;\n\tstruct btrfs_device *tgt_device = NULL;\n\tstruct btrfs_device *src_device = NULL;\n\n\tsrc_device = btrfs_find_device_by_devspec(fs_info, srcdevid,\n\t\t\t\t\t\t  srcdev_name);\n\tif (IS_ERR(src_device))\n\t\treturn PTR_ERR(src_device);\n\n\tif (btrfs_pinned_by_swapfile(fs_info, src_device)) {\n\t\tbtrfs_warn_in_rcu(fs_info,\n\t  \"cannot replace device %s (devid %llu) due to active swapfile\",\n\t\t\tbtrfs_dev_name(src_device), src_device->devid);\n\t\treturn -ETXTBSY;\n\t}\n\n\t \n\ttrans = btrfs_attach_transaction(root);\n\tif (!IS_ERR(trans)) {\n\t\tret = btrfs_commit_transaction(trans);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (PTR_ERR(trans) != -ENOENT) {\n\t\treturn PTR_ERR(trans);\n\t}\n\n\tret = btrfs_init_dev_replace_tgtdev(fs_info, tgtdev_name,\n\t\t\t\t\t    src_device, &tgt_device);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mark_block_group_to_copy(fs_info, src_device);\n\tif (ret)\n\t\treturn ret;\n\n\tdown_write(&dev_replace->rwsem);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tASSERT(0);\n\t\tret = BTRFS_IOCTL_DEV_REPLACE_RESULT_ALREADY_STARTED;\n\t\tup_write(&dev_replace->rwsem);\n\t\tgoto leave;\n\t}\n\n\tdev_replace->cont_reading_from_srcdev_mode = read_src;\n\tdev_replace->srcdev = src_device;\n\tdev_replace->tgtdev = tgt_device;\n\n\tbtrfs_info_in_rcu(fs_info,\n\t\t      \"dev_replace from %s (devid %llu) to %s started\",\n\t\t      btrfs_dev_name(src_device),\n\t\t      src_device->devid,\n\t\t      btrfs_dev_name(tgt_device));\n\n\t \n\tdev_replace->replace_state = BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED;\n\tdev_replace->time_started = ktime_get_real_seconds();\n\tdev_replace->cursor_left = 0;\n\tdev_replace->committed_cursor_left = 0;\n\tdev_replace->cursor_left_last_write_of_item = 0;\n\tdev_replace->cursor_right = 0;\n\tdev_replace->is_valid = 1;\n\tdev_replace->item_needs_writeback = 1;\n\tatomic64_set(&dev_replace->num_write_errors, 0);\n\tatomic64_set(&dev_replace->num_uncorrectable_read_errors, 0);\n\tup_write(&dev_replace->rwsem);\n\n\tret = btrfs_sysfs_add_device(tgt_device);\n\tif (ret)\n\t\tbtrfs_err(fs_info, \"kobj add dev failed %d\", ret);\n\n\tbtrfs_wait_ordered_roots(fs_info, U64_MAX, 0, (u64)-1);\n\n\t \n\ttrans = btrfs_start_transaction(root, 1);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tdown_write(&dev_replace->rwsem);\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED;\n\t\tdev_replace->srcdev = NULL;\n\t\tdev_replace->tgtdev = NULL;\n\t\tup_write(&dev_replace->rwsem);\n\t\tgoto leave;\n\t}\n\n\tret = btrfs_commit_transaction(trans);\n\tWARN_ON(ret);\n\n\t \n\tret = btrfs_scrub_dev(fs_info, src_device->devid, 0,\n\t\t\t      btrfs_device_get_total_bytes(src_device),\n\t\t\t      &dev_replace->scrub_progress, 0, 1);\n\n\tret = btrfs_dev_replace_finishing(fs_info, ret);\n\tif (ret == -EINPROGRESS)\n\t\tret = BTRFS_IOCTL_DEV_REPLACE_RESULT_SCRUB_INPROGRESS;\n\n\treturn ret;\n\nleave:\n\tbtrfs_destroy_dev_replace_tgtdev(tgt_device);\n\treturn ret;\n}\n\nint btrfs_dev_replace_by_ioctl(struct btrfs_fs_info *fs_info,\n\t\t\t    struct btrfs_ioctl_dev_replace_args *args)\n{\n\tint ret;\n\n\tswitch (args->start.cont_reading_from_srcdev_mode) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_ALWAYS:\n\tcase BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_AVOID:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((args->start.srcdevid == 0 && args->start.srcdev_name[0] == '\\0') ||\n\t    args->start.tgtdev_name[0] == '\\0')\n\t\treturn -EINVAL;\n\n\tret = btrfs_dev_replace_start(fs_info, args->start.tgtdev_name,\n\t\t\t\t\targs->start.srcdevid,\n\t\t\t\t\targs->start.srcdev_name,\n\t\t\t\t\targs->start.cont_reading_from_srcdev_mode);\n\targs->result = ret;\n\t \n\tif (ret == BTRFS_IOCTL_DEV_REPLACE_RESULT_SCRUB_INPROGRESS ||\n\t    ret == BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR)\n\t\treturn 0;\n\n\treturn ret;\n}\n\n \nstatic void btrfs_rm_dev_replace_blocked(struct btrfs_fs_info *fs_info)\n{\n\tset_bit(BTRFS_FS_STATE_DEV_REPLACING, &fs_info->fs_state);\n\twait_event(fs_info->dev_replace.replace_wait, !percpu_counter_sum(\n\t\t   &fs_info->dev_replace.bio_counter));\n}\n\n \nstatic void btrfs_rm_dev_replace_unblocked(struct btrfs_fs_info *fs_info)\n{\n\tclear_bit(BTRFS_FS_STATE_DEV_REPLACING, &fs_info->fs_state);\n\twake_up(&fs_info->dev_replace.replace_wait);\n}\n\n \nstatic int btrfs_set_target_alloc_state(struct btrfs_device *srcdev,\n\t\t\t\t\tstruct btrfs_device *tgtdev)\n{\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 found_start;\n\tu64 found_end;\n\tint ret = 0;\n\n\tlockdep_assert_held(&srcdev->fs_info->chunk_mutex);\n\n\twhile (find_first_extent_bit(&srcdev->alloc_state, start,\n\t\t\t\t     &found_start, &found_end,\n\t\t\t\t     CHUNK_ALLOCATED, &cached_state)) {\n\t\tret = set_extent_bit(&tgtdev->alloc_state, found_start,\n\t\t\t\t     found_end, CHUNK_ALLOCATED, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tstart = found_end + 1;\n\t}\n\n\tfree_extent_state(cached_state);\n\treturn ret;\n}\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev)\n{\n\tstruct extent_map_tree *em_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tu64 start = 0;\n\tint i;\n\n\twrite_lock(&em_tree->lock);\n\tdo {\n\t\tem = lookup_extent_mapping(em_tree, start, (u64)-1);\n\t\tif (!em)\n\t\t\tbreak;\n\t\tmap = em->map_lookup;\n\t\tfor (i = 0; i < map->num_stripes; i++)\n\t\t\tif (srcdev == map->stripes[i].dev)\n\t\t\t\tmap->stripes[i].dev = tgtdev;\n\t\tstart = em->start + em->len;\n\t\tfree_extent_map(em);\n\t} while (start);\n\twrite_unlock(&em_tree->lock);\n}\n\nstatic int btrfs_dev_replace_finishing(struct btrfs_fs_info *fs_info,\n\t\t\t\t       int scrub_ret)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *tgt_device;\n\tstruct btrfs_device *src_device;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tu8 uuid_tmp[BTRFS_UUID_SIZE];\n\tstruct btrfs_trans_handle *trans;\n\tint ret = 0;\n\n\t \n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\n\tdown_read(&dev_replace->rwsem);\n\t \n\tif (dev_replace->replace_state !=\n\t    BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED) {\n\t\tup_read(&dev_replace->rwsem);\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn 0;\n\t}\n\n\ttgt_device = dev_replace->tgtdev;\n\tsrc_device = dev_replace->srcdev;\n\tup_read(&dev_replace->rwsem);\n\n\t \n\tret = btrfs_start_delalloc_roots(fs_info, LONG_MAX, false);\n\tif (ret) {\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn ret;\n\t}\n\tbtrfs_wait_ordered_roots(fs_info, U64_MAX, 0, (u64)-1);\n\n\t \n\twhile (1) {\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\t\treturn PTR_ERR(trans);\n\t\t}\n\t\tret = btrfs_commit_transaction(trans);\n\t\tWARN_ON(ret);\n\n\t\t \n\t\tmutex_lock(&fs_devices->device_list_mutex);\n\t\t \n\t\tmutex_lock(&fs_info->chunk_mutex);\n\n\t\tif (!list_empty(&src_device->post_commit_list)) {\n\t\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\t\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdown_write(&dev_replace->rwsem);\n\tdev_replace->replace_state =\n\t\tscrub_ret ? BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED\n\t\t\t  : BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED;\n\tdev_replace->tgtdev = NULL;\n\tdev_replace->srcdev = NULL;\n\tdev_replace->time_stopped = ktime_get_real_seconds();\n\tdev_replace->item_needs_writeback = 1;\n\n\t \n\tif (!scrub_ret) {\n\t\tscrub_ret = btrfs_set_target_alloc_state(src_device, tgt_device);\n\t\tif (scrub_ret)\n\t\t\tgoto error;\n\t\tbtrfs_dev_replace_update_device_in_mapping_tree(fs_info,\n\t\t\t\t\t\t\t\tsrc_device,\n\t\t\t\t\t\t\t\ttgt_device);\n\t} else {\n\t\tif (scrub_ret != -ECANCELED)\n\t\t\tbtrfs_err_in_rcu(fs_info,\n\t\t\t\t \"btrfs_scrub_dev(%s, %llu, %s) failed %d\",\n\t\t\t\t btrfs_dev_name(src_device),\n\t\t\t\t src_device->devid,\n\t\t\t\t btrfs_dev_name(tgt_device), scrub_ret);\nerror:\n\t\tup_write(&dev_replace->rwsem);\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\t\tbtrfs_rm_dev_replace_blocked(fs_info);\n\t\tif (tgt_device)\n\t\t\tbtrfs_destroy_dev_replace_tgtdev(tgt_device);\n\t\tbtrfs_rm_dev_replace_unblocked(fs_info);\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\n\t\treturn scrub_ret;\n\t}\n\n\tbtrfs_info_in_rcu(fs_info,\n\t\t\t  \"dev_replace from %s (devid %llu) to %s finished\",\n\t\t\t  btrfs_dev_name(src_device),\n\t\t\t  src_device->devid,\n\t\t\t  btrfs_dev_name(tgt_device));\n\tclear_bit(BTRFS_DEV_STATE_REPLACE_TGT, &tgt_device->dev_state);\n\ttgt_device->devid = src_device->devid;\n\tsrc_device->devid = BTRFS_DEV_REPLACE_DEVID;\n\tmemcpy(uuid_tmp, tgt_device->uuid, sizeof(uuid_tmp));\n\tmemcpy(tgt_device->uuid, src_device->uuid, sizeof(tgt_device->uuid));\n\tmemcpy(src_device->uuid, uuid_tmp, sizeof(src_device->uuid));\n\tbtrfs_device_set_total_bytes(tgt_device, src_device->total_bytes);\n\tbtrfs_device_set_disk_total_bytes(tgt_device,\n\t\t\t\t\t  src_device->disk_total_bytes);\n\tbtrfs_device_set_bytes_used(tgt_device, src_device->bytes_used);\n\ttgt_device->commit_bytes_used = src_device->bytes_used;\n\n\tbtrfs_assign_next_active_device(src_device, tgt_device);\n\n\tlist_add(&tgt_device->dev_alloc_list, &fs_devices->alloc_list);\n\tfs_devices->rw_devices++;\n\n\tup_write(&dev_replace->rwsem);\n\tbtrfs_rm_dev_replace_blocked(fs_info);\n\n\tbtrfs_rm_dev_replace_remove_srcdev(src_device);\n\n\tbtrfs_rm_dev_replace_unblocked(fs_info);\n\n\t \n\tatomic_inc(&tgt_device->dev_stats_ccnt);\n\n\t \n\tmutex_unlock(&fs_info->chunk_mutex);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\t \n\tbtrfs_sysfs_remove_device(src_device);\n\tbtrfs_sysfs_update_devid(tgt_device);\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &src_device->dev_state))\n\t\tbtrfs_scratch_superblocks(fs_info, src_device->bdev,\n\t\t\t\t\t  src_device->name->str);\n\n\t \n\ttrans = btrfs_start_transaction(root, 0);\n\tif (!IS_ERR(trans))\n\t\tbtrfs_commit_transaction(trans);\n\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\n\tbtrfs_rm_dev_replace_free_srcdev(src_device);\n\n\treturn 0;\n}\n\n \nstatic u64 btrfs_dev_replace_progress(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tu64 ret = 0;\n\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tret = 0;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\t\tret = 1000;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tret = div64_u64(dev_replace->cursor_left,\n\t\t\t\tdiv_u64(btrfs_device_get_total_bytes(\n\t\t\t\t\t\tdev_replace->srcdev), 1000));\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nvoid btrfs_dev_replace_status(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_ioctl_dev_replace_args *args)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tdown_read(&dev_replace->rwsem);\n\t \n\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\n\targs->status.replace_state = dev_replace->replace_state;\n\targs->status.time_started = dev_replace->time_started;\n\targs->status.time_stopped = dev_replace->time_stopped;\n\targs->status.num_write_errors =\n\t\tatomic64_read(&dev_replace->num_write_errors);\n\targs->status.num_uncorrectable_read_errors =\n\t\tatomic64_read(&dev_replace->num_uncorrectable_read_errors);\n\targs->status.progress_1000 = btrfs_dev_replace_progress(fs_info);\n\tup_read(&dev_replace->rwsem);\n}\n\nint btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_device *tgt_device = NULL;\n\tstruct btrfs_device *src_device = NULL;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tint result;\n\tint ret;\n\n\tif (sb_rdonly(fs_info->sb))\n\t\treturn -EROFS;\n\n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\tdown_write(&dev_replace->rwsem);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tresult = BTRFS_IOCTL_DEV_REPLACE_RESULT_NOT_STARTED;\n\t\tup_write(&dev_replace->rwsem);\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\t\ttgt_device = dev_replace->tgtdev;\n\t\tsrc_device = dev_replace->srcdev;\n\t\tup_write(&dev_replace->rwsem);\n\t\tret = btrfs_scrub_cancel(fs_info);\n\t\tif (ret < 0) {\n\t\t\tresult = BTRFS_IOCTL_DEV_REPLACE_RESULT_NOT_STARTED;\n\t\t} else {\n\t\t\tresult = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\n\t\t\t \n\t\t\tbtrfs_info_in_rcu(fs_info,\n\t\t\t\t\"dev_replace from %s (devid %llu) to %s canceled\",\n\t\t\t\tbtrfs_dev_name(src_device), src_device->devid,\n\t\t\t\tbtrfs_dev_name(tgt_device));\n\t\t}\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\t \n\t\tresult = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\n\t\ttgt_device = dev_replace->tgtdev;\n\t\tsrc_device = dev_replace->srcdev;\n\t\tdev_replace->tgtdev = NULL;\n\t\tdev_replace->srcdev = NULL;\n\t\tdev_replace->replace_state =\n\t\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED;\n\t\tdev_replace->time_stopped = ktime_get_real_seconds();\n\t\tdev_replace->item_needs_writeback = 1;\n\n\t\tup_write(&dev_replace->rwsem);\n\n\t\t \n\t\tbtrfs_scrub_cancel(fs_info);\n\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\t\treturn PTR_ERR(trans);\n\t\t}\n\t\tret = btrfs_commit_transaction(trans);\n\t\tWARN_ON(ret);\n\n\t\tbtrfs_info_in_rcu(fs_info,\n\t\t\"suspended dev_replace from %s (devid %llu) to %s canceled\",\n\t\t\tbtrfs_dev_name(src_device), src_device->devid,\n\t\t\tbtrfs_dev_name(tgt_device));\n\n\t\tif (tgt_device)\n\t\t\tbtrfs_destroy_dev_replace_tgtdev(tgt_device);\n\t\tbreak;\n\tdefault:\n\t\tup_write(&dev_replace->rwsem);\n\t\tresult = -EINVAL;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\treturn result;\n}\n\nvoid btrfs_dev_replace_suspend_for_unmount(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\tdown_write(&dev_replace->rwsem);\n\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED;\n\t\tdev_replace->time_stopped = ktime_get_real_seconds();\n\t\tdev_replace->item_needs_writeback = 1;\n\t\tbtrfs_info(fs_info, \"suspending dev_replace for unmount\");\n\t\tbreak;\n\t}\n\n\tup_write(&dev_replace->rwsem);\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n}\n\n \nint btrfs_resume_dev_replace_async(struct btrfs_fs_info *fs_info)\n{\n\tstruct task_struct *task;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tdown_write(&dev_replace->rwsem);\n\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tup_write(&dev_replace->rwsem);\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_STARTED;\n\t\tbreak;\n\t}\n\tif (!dev_replace->tgtdev || !dev_replace->tgtdev->bdev) {\n\t\tbtrfs_info(fs_info,\n\t\t\t   \"cannot continue dev_replace, tgtdev is missing\");\n\t\tbtrfs_info(fs_info,\n\t\t\t   \"you may cancel the operation after 'mount -o degraded'\");\n\t\tdev_replace->replace_state =\n\t\t\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED;\n\t\tup_write(&dev_replace->rwsem);\n\t\treturn 0;\n\t}\n\tup_write(&dev_replace->rwsem);\n\n\t \n\tif (!btrfs_exclop_start(fs_info, BTRFS_EXCLOP_DEV_REPLACE)) {\n\t\tdown_write(&dev_replace->rwsem);\n\t\tdev_replace->replace_state =\n\t\t\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED;\n\t\tup_write(&dev_replace->rwsem);\n\t\tbtrfs_info(fs_info,\n\t\t\"cannot resume dev-replace, other exclusive operation running\");\n\t\treturn 0;\n\t}\n\n\ttask = kthread_run(btrfs_dev_replace_kthread, fs_info, \"btrfs-devrepl\");\n\treturn PTR_ERR_OR_ZERO(task);\n}\n\nstatic int btrfs_dev_replace_kthread(void *data)\n{\n\tstruct btrfs_fs_info *fs_info = data;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tu64 progress;\n\tint ret;\n\n\tprogress = btrfs_dev_replace_progress(fs_info);\n\tprogress = div_u64(progress, 10);\n\tbtrfs_info_in_rcu(fs_info,\n\t\t\"continuing dev_replace from %s (devid %llu) to target %s @%u%%\",\n\t\tbtrfs_dev_name(dev_replace->srcdev),\n\t\tdev_replace->srcdev->devid,\n\t\tbtrfs_dev_name(dev_replace->tgtdev),\n\t\t(unsigned int)progress);\n\n\tret = btrfs_scrub_dev(fs_info, dev_replace->srcdev->devid,\n\t\t\t      dev_replace->committed_cursor_left,\n\t\t\t      btrfs_device_get_total_bytes(dev_replace->srcdev),\n\t\t\t      &dev_replace->scrub_progress, 0, 1);\n\tret = btrfs_dev_replace_finishing(fs_info, ret);\n\tWARN_ON(ret && ret != -ECANCELED);\n\n\tbtrfs_exclop_finish(fs_info);\n\treturn 0;\n}\n\nint __pure btrfs_dev_replace_is_ongoing(struct btrfs_dev_replace *dev_replace)\n{\n\tif (!dev_replace->is_valid)\n\t\treturn 0;\n\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\t \n\t\tbreak;\n\t}\n\treturn 1;\n}\n\nvoid btrfs_bio_counter_sub(struct btrfs_fs_info *fs_info, s64 amount)\n{\n\tpercpu_counter_sub(&fs_info->dev_replace.bio_counter, amount);\n\tcond_wake_up_nomb(&fs_info->dev_replace.replace_wait);\n}\n\nvoid btrfs_bio_counter_inc_blocked(struct btrfs_fs_info *fs_info)\n{\n\twhile (1) {\n\t\tpercpu_counter_inc(&fs_info->dev_replace.bio_counter);\n\t\tif (likely(!test_bit(BTRFS_FS_STATE_DEV_REPLACING,\n\t\t\t\t     &fs_info->fs_state)))\n\t\t\tbreak;\n\n\t\tbtrfs_bio_counter_dec(fs_info);\n\t\twait_event(fs_info->dev_replace.replace_wait,\n\t\t\t   !test_bit(BTRFS_FS_STATE_DEV_REPLACING,\n\t\t\t\t     &fs_info->fs_state));\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}