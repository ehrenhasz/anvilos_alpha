{
  "module_name": "transaction.h",
  "hash_id": "b7828b8649922b2e3b21d91839b4bf2e5af3bdbb663f9da912e220bce48795fe",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/transaction.h",
  "human_readable_source": " \n \n\n#ifndef BTRFS_TRANSACTION_H\n#define BTRFS_TRANSACTION_H\n\n#include <linux/refcount.h>\n#include \"btrfs_inode.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include \"misc.h\"\n\n \n#define BTRFS_ROOT_TRANS_TAG\t\t\t0\n\nenum btrfs_trans_state {\n\tTRANS_STATE_RUNNING,\n\tTRANS_STATE_COMMIT_PREP,\n\tTRANS_STATE_COMMIT_START,\n\tTRANS_STATE_COMMIT_DOING,\n\tTRANS_STATE_UNBLOCKED,\n\tTRANS_STATE_SUPER_COMMITTED,\n\tTRANS_STATE_COMPLETED,\n\tTRANS_STATE_MAX,\n};\n\n#define BTRFS_TRANS_HAVE_FREE_BGS\t0\n#define BTRFS_TRANS_DIRTY_BG_RUN\t1\n#define BTRFS_TRANS_CACHE_ENOSPC\t2\n\nstruct btrfs_transaction {\n\tu64 transid;\n\t \n\tatomic_t num_extwriters;\n\t \n\tatomic_t num_writers;\n\trefcount_t use_count;\n\n\tunsigned long flags;\n\n\t \n\tenum btrfs_trans_state state;\n\tint aborted;\n\tstruct list_head list;\n\tstruct extent_io_tree dirty_pages;\n\ttime64_t start_time;\n\twait_queue_head_t writer_wait;\n\twait_queue_head_t commit_wait;\n\tstruct list_head pending_snapshots;\n\tstruct list_head dev_update_list;\n\tstruct list_head switch_commits;\n\tstruct list_head dirty_bgs;\n\n\t \n\tstruct list_head io_bgs;\n\tstruct list_head dropped_roots;\n\tstruct extent_io_tree pinned_extents;\n\n\t \n\tstruct mutex cache_write_mutex;\n\tspinlock_t dirty_bgs_lock;\n\t \n\tstruct list_head deleted_bgs;\n\tspinlock_t dropped_roots_lock;\n\tstruct btrfs_delayed_ref_root delayed_refs;\n\tstruct btrfs_fs_info *fs_info;\n\n\t \n\tatomic_t pending_ordered;\n\twait_queue_head_t pending_wait;\n};\n\nenum {\n\tENUM_BIT(__TRANS_FREEZABLE),\n\tENUM_BIT(__TRANS_START),\n\tENUM_BIT(__TRANS_ATTACH),\n\tENUM_BIT(__TRANS_JOIN),\n\tENUM_BIT(__TRANS_JOIN_NOLOCK),\n\tENUM_BIT(__TRANS_DUMMY),\n\tENUM_BIT(__TRANS_JOIN_NOSTART),\n};\n\n#define TRANS_START\t\t(__TRANS_START | __TRANS_FREEZABLE)\n#define TRANS_ATTACH\t\t(__TRANS_ATTACH)\n#define TRANS_JOIN\t\t(__TRANS_JOIN | __TRANS_FREEZABLE)\n#define TRANS_JOIN_NOLOCK\t(__TRANS_JOIN_NOLOCK)\n#define TRANS_JOIN_NOSTART\t(__TRANS_JOIN_NOSTART)\n\n#define TRANS_EXTWRITERS\t(__TRANS_START | __TRANS_ATTACH)\n\nstruct btrfs_trans_handle {\n\tu64 transid;\n\tu64 bytes_reserved;\n\tu64 chunk_bytes_reserved;\n\tunsigned long delayed_ref_updates;\n\tstruct btrfs_transaction *transaction;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct btrfs_block_rsv *orig_rsv;\n\t \n\tstruct btrfs_pending_snapshot *pending_snapshot;\n\trefcount_t use_count;\n\tunsigned int type;\n\t \n\tshort aborted;\n\tbool adding_csums;\n\tbool allocating_chunk;\n\tbool removing_chunk;\n\tbool reloc_reserved;\n\tbool in_fsync;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct list_head new_bgs;\n};\n\n \n#define TRANS_ABORTED(trans)\t\t(unlikely(READ_ONCE((trans)->aborted)))\n\nstruct btrfs_pending_snapshot {\n\tstruct dentry *dentry;\n\tstruct inode *dir;\n\tstruct btrfs_root *root;\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_root *snap;\n\tstruct btrfs_qgroup_inherit *inherit;\n\tstruct btrfs_path *path;\n\t \n\tstruct btrfs_block_rsv block_rsv;\n\t \n\tint error;\n\t \n\tdev_t anon_dev;\n\tbool readonly;\n\tstruct list_head list;\n};\n\nstatic inline void btrfs_set_inode_last_trans(struct btrfs_trans_handle *trans,\n\t\t\t\t\t      struct btrfs_inode *inode)\n{\n\tspin_lock(&inode->lock);\n\tinode->last_trans = trans->transaction->transid;\n\tinode->last_sub_trans = inode->root->log_transid;\n\tinode->last_log_commit = inode->last_sub_trans - 1;\n\tspin_unlock(&inode->lock);\n}\n\n \nstatic inline void btrfs_set_skip_qgroup(struct btrfs_trans_handle *trans,\n\t\t\t\t\t u64 qgroupid)\n{\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tWARN_ON(delayed_refs->qgroup_to_skip);\n\tdelayed_refs->qgroup_to_skip = qgroupid;\n}\n\nstatic inline void btrfs_clear_skip_qgroup(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tWARN_ON(!delayed_refs->qgroup_to_skip);\n\tdelayed_refs->qgroup_to_skip = 0;\n}\n\nbool __cold abort_should_print_stack(int errno);\n\n \n#define btrfs_abort_transaction(trans, errno)\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tbool first = false;\t\t\t\t\t\\\n\t \t\t\t\\\n\tif (!test_and_set_bit(BTRFS_FS_STATE_TRANS_ABORTED,\t\\\n\t\t\t&((trans)->fs_info->fs_state))) {\t\\\n\t\tfirst = true;\t\t\t\t\t\\\n\t\tif (WARN(abort_should_print_stack(errno),\t\\\n\t\t\tKERN_ERR\t\t\t\t\\\n\t\t\t\"BTRFS: Transaction aborted (error %d)\\n\",\t\\\n\t\t\t(errno))) {\t\t\t\t\t\\\n\t\t\t \t\t\t\\\n\t\t} else {\t\t\t\t\t\t\\\n\t\t\tbtrfs_err((trans)->fs_info,\t\t\t\\\n\t\t\t\t  \"Transaction aborted (error %d)\",\t\\\n\t\t\t\t  (errno));\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\t__btrfs_abort_transaction((trans), __func__,\t\t\\\n\t\t\t\t  __LINE__, (errno), first);\t\\\n} while (0)\n\nint btrfs_end_transaction(struct btrfs_trans_handle *trans);\nstruct btrfs_trans_handle *btrfs_start_transaction(struct btrfs_root *root,\n\t\t\t\t\t\t   unsigned int num_items);\nstruct btrfs_trans_handle *btrfs_start_transaction_fallback_global_rsv(\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tunsigned int num_items);\nstruct btrfs_trans_handle *btrfs_join_transaction(struct btrfs_root *root);\nstruct btrfs_trans_handle *btrfs_join_transaction_spacecache(struct btrfs_root *root);\nstruct btrfs_trans_handle *btrfs_join_transaction_nostart(struct btrfs_root *root);\nstruct btrfs_trans_handle *btrfs_attach_transaction(struct btrfs_root *root);\nstruct btrfs_trans_handle *btrfs_attach_transaction_barrier(\n\t\t\t\t\tstruct btrfs_root *root);\nint btrfs_wait_for_commit(struct btrfs_fs_info *fs_info, u64 transid);\n\nvoid btrfs_add_dead_root(struct btrfs_root *root);\nint btrfs_defrag_root(struct btrfs_root *root);\nvoid btrfs_maybe_wake_unfinished_drop(struct btrfs_fs_info *fs_info);\nint btrfs_clean_one_deleted_snapshot(struct btrfs_fs_info *fs_info);\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans);\nvoid btrfs_commit_transaction_async(struct btrfs_trans_handle *trans);\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans);\nbool btrfs_should_end_transaction(struct btrfs_trans_handle *trans);\nvoid btrfs_throttle(struct btrfs_fs_info *fs_info);\nint btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root);\nint btrfs_write_marked_extents(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct extent_io_tree *dirty_pages, int mark);\nint btrfs_wait_tree_log_extents(struct btrfs_root *root, int mark);\nint btrfs_transaction_blocked(struct btrfs_fs_info *info);\nint btrfs_transaction_in_commit(struct btrfs_fs_info *info);\nvoid btrfs_put_transaction(struct btrfs_transaction *transaction);\nvoid btrfs_add_dropped_root(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root);\nvoid btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans);\nvoid __cold __btrfs_abort_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\t      const char *function,\n\t\t\t\t      unsigned int line, int errno, bool first_hit);\n\nint __init btrfs_transaction_init(void);\nvoid __cold btrfs_transaction_exit(void);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}