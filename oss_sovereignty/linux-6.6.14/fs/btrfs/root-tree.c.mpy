{
  "module_name": "root-tree.c",
  "hash_id": "c633ce4f4114e015a77733a1cb1798c6da4c1aeb7805794c5f75267ffa85ba12",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/root-tree.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/uuid.h>\n#include \"ctree.h\"\n#include \"fs.h\"\n#include \"messages.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"print-tree.h\"\n#include \"qgroup.h\"\n#include \"space-info.h\"\n#include \"accessors.h\"\n#include \"root-tree.h\"\n#include \"orphan.h\"\n\n \nstatic void btrfs_read_root_item(struct extent_buffer *eb, int slot,\n\t\t\t\tstruct btrfs_root_item *item)\n{\n\tu32 len;\n\tint need_reset = 0;\n\n\tlen = btrfs_item_size(eb, slot);\n\tread_extent_buffer(eb, item, btrfs_item_ptr_offset(eb, slot),\n\t\t\t   min_t(u32, len, sizeof(*item)));\n\tif (len < sizeof(*item))\n\t\tneed_reset = 1;\n\tif (!need_reset && btrfs_root_generation(item)\n\t\t!= btrfs_root_generation_v2(item)) {\n\t\tif (btrfs_root_generation_v2(item) != 0) {\n\t\t\tbtrfs_warn(eb->fs_info,\n\t\t\t\t\t\"mismatching generation and generation_v2 found in root item. This root was probably mounted with an older kernel. Resetting all new fields.\");\n\t\t}\n\t\tneed_reset = 1;\n\t}\n\tif (need_reset) {\n\t\t \n\t\tmemset_startat(item, 0, generation_v2);\n\t\tgenerate_random_guid(item->uuid);\n\t}\n}\n\n \nint btrfs_find_root(struct btrfs_root *root, const struct btrfs_key *search_key,\n\t\t    struct btrfs_path *path, struct btrfs_root_item *root_item,\n\t\t    struct btrfs_key *root_key)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *l;\n\tint ret;\n\tint slot;\n\n\tret = btrfs_search_slot(NULL, root, search_key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (search_key->offset != -1ULL) {\t \n\t\tif (ret > 0)\n\t\t\tgoto out;\n\t} else {\n\t\tBUG_ON(ret == 0);\t\t \n\t\tif (path->slots[0] == 0)\n\t\t\tgoto out;\n\t\tpath->slots[0]--;\n\t\tret = 0;\n\t}\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\n\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\tif (found_key.objectid != search_key->objectid ||\n\t    found_key.type != BTRFS_ROOT_ITEM_KEY) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (root_item)\n\t\tbtrfs_read_root_item(l, slot, root_item);\n\tif (root_key)\n\t\tmemcpy(root_key, &found_key, sizeof(found_key));\nout:\n\tbtrfs_release_path(path);\n\treturn ret;\n}\n\nvoid btrfs_set_root_node(struct btrfs_root_item *item,\n\t\t\t struct extent_buffer *node)\n{\n\tbtrfs_set_root_bytenr(item, node->start);\n\tbtrfs_set_root_level(item, btrfs_header_level(node));\n\tbtrfs_set_root_generation(item, btrfs_header_generation(node));\n}\n\n \nint btrfs_update_root(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_root_item\n\t\t      *item)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *l;\n\tint ret;\n\tint slot;\n\tunsigned long ptr;\n\tu32 old_len;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tbtrfs_crit(fs_info,\n\t\t\t\"unable to find root key (%llu %u %llu) in tree %llu\",\n\t\t\tkey->objectid, key->type, key->offset,\n\t\t\troot->root_key.objectid);\n\t\tret = -EUCLEAN;\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr_offset(l, slot);\n\told_len = btrfs_item_size(l, slot);\n\n\t \n\tif (old_len < sizeof(*item)) {\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(trans, root, key, path,\n\t\t\t\t-1, 1);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\tkey, sizeof(*item));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tptr = btrfs_item_ptr_offset(l, slot);\n\t}\n\n\t \n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\n\twrite_extent_buffer(l, item, ptr, sizeof(*item));\n\tbtrfs_mark_buffer_dirty(trans, path->nodes[0]);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nint btrfs_insert_root(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      const struct btrfs_key *key, struct btrfs_root_item *item)\n{\n\t \n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\treturn btrfs_insert_item(trans, root, key, item, sizeof(*item));\n}\n\nint btrfs_find_orphan_roots(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root;\n\tint err = 0;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = 0;\n\n\twhile (1) {\n\t\tu64 root_objectid;\n\n\t\tret = btrfs_search_slot(NULL, tree_root, &key, path, 0, 0);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(tree_root, path);\n\t\t\tif (ret < 0)\n\t\t\t\terr = ret;\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tbtrfs_release_path(path);\n\n\t\tif (key.objectid != BTRFS_ORPHAN_OBJECTID ||\n\t\t    key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\troot_objectid = key.offset;\n\t\tkey.offset++;\n\n\t\troot = btrfs_get_fs_root(fs_info, root_objectid, false);\n\t\terr = PTR_ERR_OR_ZERO(root);\n\t\tif (err && err != -ENOENT) {\n\t\t\tbreak;\n\t\t} else if (err == -ENOENT) {\n\t\t\tstruct btrfs_trans_handle *trans;\n\n\t\t\tbtrfs_release_path(path);\n\n\t\t\ttrans = btrfs_join_transaction(tree_root);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\terr = PTR_ERR(trans);\n\t\t\t\tbtrfs_handle_fs_error(fs_info, err,\n\t\t\t\t\t    \"Failed to start trans to delete orphan item\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = btrfs_del_orphan_item(trans, tree_root,\n\t\t\t\t\t\t    root_objectid);\n\t\t\tbtrfs_end_transaction(trans);\n\t\t\tif (err) {\n\t\t\t\tbtrfs_handle_fs_error(fs_info, err,\n\t\t\t\t\t    \"Failed to delete root orphan item\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tWARN_ON(!test_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state));\n\t\tif (btrfs_root_refs(&root->root_item) == 0) {\n\t\t\tstruct btrfs_key drop_key;\n\n\t\t\tbtrfs_disk_key_to_cpu(&drop_key, &root->root_item.drop_progress);\n\t\t\t \n\t\t\tif (drop_key.objectid != 0 || drop_key.type != 0 ||\n\t\t\t    drop_key.offset != 0) {\n\t\t\t\tset_bit(BTRFS_FS_UNFINISHED_DROPS, &fs_info->flags);\n\t\t\t\tset_bit(BTRFS_ROOT_UNFINISHED_DROP, &root->state);\n\t\t\t}\n\n\t\t\tset_bit(BTRFS_ROOT_DEAD_TREE, &root->state);\n\t\t\tbtrfs_add_dead_root(root);\n\t\t}\n\t\tbtrfs_put_root(root);\n\t}\n\n\tbtrfs_free_path(path);\n\treturn err;\n}\n\n \nint btrfs_del_root(struct btrfs_trans_handle *trans,\n\t\t   const struct btrfs_key *key)\n{\n\tstruct btrfs_root *root = trans->fs_info->tree_root;\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = btrfs_search_slot(trans, root, key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tBUG_ON(ret != 0);\n\n\tret = btrfs_del_item(trans, root, path);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nint btrfs_del_root_ref(struct btrfs_trans_handle *trans, u64 root_id,\n\t\t       u64 ref_id, u64 dirid, u64 *sequence,\n\t\t       const struct fscrypt_str *name)\n{\n\tstruct btrfs_root *tree_root = trans->fs_info->tree_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root_ref *ref;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tunsigned long ptr;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = root_id;\n\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\tkey.offset = ref_id;\nagain:\n\tret = btrfs_search_slot(trans, tree_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret == 0) {\n\t\tleaf = path->nodes[0];\n\t\tref = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t     struct btrfs_root_ref);\n\t\tptr = (unsigned long)(ref + 1);\n\t\tif ((btrfs_root_ref_dirid(leaf, ref) != dirid) ||\n\t\t    (btrfs_root_ref_name_len(leaf, ref) != name->len) ||\n\t\t    memcmp_extent_buffer(leaf, name->name, ptr, name->len)) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\t*sequence = btrfs_root_ref_sequence(leaf, ref);\n\n\t\tret = btrfs_del_item(trans, tree_root, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (key.type == BTRFS_ROOT_BACKREF_KEY) {\n\t\tbtrfs_release_path(path);\n\t\tkey.objectid = ref_id;\n\t\tkey.type = BTRFS_ROOT_REF_KEY;\n\t\tkey.offset = root_id;\n\t\tgoto again;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nint btrfs_add_root_ref(struct btrfs_trans_handle *trans, u64 root_id,\n\t\t       u64 ref_id, u64 dirid, u64 sequence,\n\t\t       const struct fscrypt_str *name)\n{\n\tstruct btrfs_root *tree_root = trans->fs_info->tree_root;\n\tstruct btrfs_key key;\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root_ref *ref;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = root_id;\n\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\tkey.offset = ref_id;\nagain:\n\tret = btrfs_insert_empty_item(trans, tree_root, path, &key,\n\t\t\t\t      sizeof(*ref) + name->len);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\tref = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_root_ref);\n\tbtrfs_set_root_ref_dirid(leaf, ref, dirid);\n\tbtrfs_set_root_ref_sequence(leaf, ref, sequence);\n\tbtrfs_set_root_ref_name_len(leaf, ref, name->len);\n\tptr = (unsigned long)(ref + 1);\n\twrite_extent_buffer(leaf, name->name, ptr, name->len);\n\tbtrfs_mark_buffer_dirty(trans, leaf);\n\n\tif (key.type == BTRFS_ROOT_BACKREF_KEY) {\n\t\tbtrfs_release_path(path);\n\t\tkey.objectid = ref_id;\n\t\tkey.type = BTRFS_ROOT_REF_KEY;\n\t\tkey.offset = root_id;\n\t\tgoto again;\n\t}\n\n\tbtrfs_free_path(path);\n\treturn 0;\n}\n\n \nvoid btrfs_check_and_init_root_item(struct btrfs_root_item *root_item)\n{\n\tu64 inode_flags = btrfs_stack_inode_flags(&root_item->inode);\n\n\tif (!(inode_flags & BTRFS_INODE_ROOT_ITEM_INIT)) {\n\t\tinode_flags |= BTRFS_INODE_ROOT_ITEM_INIT;\n\t\tbtrfs_set_stack_inode_flags(&root_item->inode, inode_flags);\n\t\tbtrfs_set_root_flags(root_item, 0);\n\t\tbtrfs_set_root_limit(root_item, 0);\n\t}\n}\n\nvoid btrfs_update_root_times(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_root_item *item = &root->root_item;\n\tstruct timespec64 ct;\n\n\tktime_get_real_ts64(&ct);\n\tspin_lock(&root->root_item_lock);\n\tbtrfs_set_root_ctransid(item, trans->transid);\n\tbtrfs_set_stack_timespec_sec(&item->ctime, ct.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&item->ctime, ct.tv_nsec);\n\tspin_unlock(&root->root_item_lock);\n}\n\n \nint btrfs_subvolume_reserve_metadata(struct btrfs_root *root,\n\t\t\t\t     struct btrfs_block_rsv *rsv, int items,\n\t\t\t\t     bool use_global_rsv)\n{\n\tu64 qgroup_num_bytes = 0;\n\tu64 num_bytes;\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_block_rsv *global_rsv = &fs_info->global_block_rsv;\n\n\tif (test_bit(BTRFS_FS_QUOTA_ENABLED, &fs_info->flags)) {\n\t\t \n\t\tqgroup_num_bytes = 3 * fs_info->nodesize;\n\t\tret = btrfs_qgroup_reserve_meta_prealloc(root,\n\t\t\t\t\t\t\t qgroup_num_bytes, true,\n\t\t\t\t\t\t\t false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tnum_bytes = btrfs_calc_insert_metadata_size(fs_info, items);\n\trsv->space_info = btrfs_find_space_info(fs_info,\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_METADATA);\n\tret = btrfs_block_rsv_add(fs_info, rsv, num_bytes,\n\t\t\t\t  BTRFS_RESERVE_FLUSH_ALL);\n\n\tif (ret == -ENOSPC && use_global_rsv)\n\t\tret = btrfs_block_rsv_migrate(global_rsv, rsv, num_bytes, true);\n\n\tif (ret && qgroup_num_bytes)\n\t\tbtrfs_qgroup_free_meta_prealloc(root, qgroup_num_bytes);\n\n\tif (!ret) {\n\t\tspin_lock(&rsv->lock);\n\t\trsv->qgroup_rsv_reserved += qgroup_num_bytes;\n\t\tspin_unlock(&rsv->lock);\n\t}\n\treturn ret;\n}\n\nvoid btrfs_subvolume_release_metadata(struct btrfs_root *root,\n\t\t\t\t      struct btrfs_block_rsv *rsv)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 qgroup_to_release;\n\n\tbtrfs_block_rsv_release(fs_info, rsv, (u64)-1, &qgroup_to_release);\n\tbtrfs_qgroup_convert_reserved_meta(root, qgroup_to_release);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}