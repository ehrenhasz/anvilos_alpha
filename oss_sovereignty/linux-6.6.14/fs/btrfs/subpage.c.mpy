{
  "module_name": "subpage.c",
  "hash_id": "31d33db46989ec7897a567c44e667cff45aa6e61ffe684a1f2fc63ff36073fb1",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/subpage.c",
  "human_readable_source": "\n\n#include <linux/slab.h>\n#include \"messages.h\"\n#include \"ctree.h\"\n#include \"subpage.h\"\n#include \"btrfs_inode.h\"\n\n \n\nbool btrfs_is_subpage(const struct btrfs_fs_info *fs_info, struct page *page)\n{\n\tif (fs_info->sectorsize >= PAGE_SIZE)\n\t\treturn false;\n\n\t \n\tif (!page->mapping || !page->mapping->host ||\n\t    is_data_inode(page->mapping->host))\n\t\treturn true;\n\n\t \n\tif (fs_info->nodesize < PAGE_SIZE)\n\t\treturn true;\n\treturn false;\n}\n\nvoid btrfs_init_subpage_info(struct btrfs_subpage_info *subpage_info, u32 sectorsize)\n{\n\tunsigned int cur = 0;\n\tunsigned int nr_bits;\n\n\tASSERT(IS_ALIGNED(PAGE_SIZE, sectorsize));\n\n\tnr_bits = PAGE_SIZE / sectorsize;\n\tsubpage_info->bitmap_nr_bits = nr_bits;\n\n\tsubpage_info->uptodate_offset = cur;\n\tcur += nr_bits;\n\n\tsubpage_info->dirty_offset = cur;\n\tcur += nr_bits;\n\n\tsubpage_info->writeback_offset = cur;\n\tcur += nr_bits;\n\n\tsubpage_info->ordered_offset = cur;\n\tcur += nr_bits;\n\n\tsubpage_info->checked_offset = cur;\n\tcur += nr_bits;\n\n\tsubpage_info->total_nr_bits = cur;\n}\n\nint btrfs_attach_subpage(const struct btrfs_fs_info *fs_info,\n\t\t\t struct page *page, enum btrfs_subpage_type type)\n{\n\tstruct btrfs_subpage *subpage;\n\n\t \n\tif (page->mapping)\n\t\tASSERT(PageLocked(page));\n\n\t \n\tif (!btrfs_is_subpage(fs_info, page) || PagePrivate(page))\n\t\treturn 0;\n\n\tsubpage = btrfs_alloc_subpage(fs_info, type);\n\tif (IS_ERR(subpage))\n\t\treturn  PTR_ERR(subpage);\n\n\tattach_page_private(page, subpage);\n\treturn 0;\n}\n\nvoid btrfs_detach_subpage(const struct btrfs_fs_info *fs_info,\n\t\t\t  struct page *page)\n{\n\tstruct btrfs_subpage *subpage;\n\n\t \n\tif (!btrfs_is_subpage(fs_info, page) || !PagePrivate(page))\n\t\treturn;\n\n\tsubpage = detach_page_private(page);\n\tASSERT(subpage);\n\tbtrfs_free_subpage(subpage);\n}\n\nstruct btrfs_subpage *btrfs_alloc_subpage(const struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  enum btrfs_subpage_type type)\n{\n\tstruct btrfs_subpage *ret;\n\tunsigned int real_size;\n\n\tASSERT(fs_info->sectorsize < PAGE_SIZE);\n\n\treal_size = struct_size(ret, bitmaps,\n\t\t\tBITS_TO_LONGS(fs_info->subpage_info->total_nr_bits));\n\tret = kzalloc(real_size, GFP_NOFS);\n\tif (!ret)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&ret->lock);\n\tif (type == BTRFS_SUBPAGE_METADATA) {\n\t\tatomic_set(&ret->eb_refs, 0);\n\t} else {\n\t\tatomic_set(&ret->readers, 0);\n\t\tatomic_set(&ret->writers, 0);\n\t}\n\treturn ret;\n}\n\nvoid btrfs_free_subpage(struct btrfs_subpage *subpage)\n{\n\tkfree(subpage);\n}\n\n \nvoid btrfs_page_inc_eb_refs(const struct btrfs_fs_info *fs_info,\n\t\t\t    struct page *page)\n{\n\tstruct btrfs_subpage *subpage;\n\n\tif (!btrfs_is_subpage(fs_info, page))\n\t\treturn;\n\n\tASSERT(PagePrivate(page) && page->mapping);\n\tlockdep_assert_held(&page->mapping->private_lock);\n\n\tsubpage = (struct btrfs_subpage *)page->private;\n\tatomic_inc(&subpage->eb_refs);\n}\n\nvoid btrfs_page_dec_eb_refs(const struct btrfs_fs_info *fs_info,\n\t\t\t    struct page *page)\n{\n\tstruct btrfs_subpage *subpage;\n\n\tif (!btrfs_is_subpage(fs_info, page))\n\t\treturn;\n\n\tASSERT(PagePrivate(page) && page->mapping);\n\tlockdep_assert_held(&page->mapping->private_lock);\n\n\tsubpage = (struct btrfs_subpage *)page->private;\n\tASSERT(atomic_read(&subpage->eb_refs));\n\tatomic_dec(&subpage->eb_refs);\n}\n\nstatic void btrfs_subpage_assert(const struct btrfs_fs_info *fs_info,\n\t\tstruct page *page, u64 start, u32 len)\n{\n\t \n\tASSERT(PagePrivate(page) && page->private);\n\tASSERT(IS_ALIGNED(start, fs_info->sectorsize) &&\n\t       IS_ALIGNED(len, fs_info->sectorsize));\n\t \n\tif (page->mapping)\n\t\tASSERT(page_offset(page) <= start &&\n\t\t       start + len <= page_offset(page) + PAGE_SIZE);\n}\n\nvoid btrfs_subpage_start_reader(const struct btrfs_fs_info *fs_info,\n\t\tstruct page *page, u64 start, u32 len)\n{\n\tstruct btrfs_subpage *subpage = (struct btrfs_subpage *)page->private;\n\tconst int nbits = len >> fs_info->sectorsize_bits;\n\n\tbtrfs_subpage_assert(fs_info, page, start, len);\n\n\tatomic_add(nbits, &subpage->readers);\n}\n\nvoid btrfs_subpage_end_reader(const struct btrfs_fs_info *fs_info,\n\t\tstruct page *page, u64 start, u32 len)\n{\n\tstruct btrfs_subpage *subpage = (struct btrfs_subpage *)page->private;\n\tconst int nbits = len >> fs_info->sectorsize_bits;\n\tbool is_data;\n\tbool last;\n\n\tbtrfs_subpage_assert(fs_info, page, start, len);\n\tis_data = is_data_inode(page->mapping->host);\n\tASSERT(atomic_read(&subpage->readers) >= nbits);\n\tlast = atomic_sub_and_test(nbits, &subpage->readers);\n\n\t \n\tif (is_data && last)\n\t\tunlock_page(page);\n}\n\nstatic void btrfs_subpage_clamp_range(struct page *page, u64 *start, u32 *len)\n{\n\tu64 orig_start = *start;\n\tu32 orig_len = *len;\n\n\t*start = max_t(u64, page_offset(page), orig_start);\n\t \n\tif (page_offset(page) >= orig_start + orig_len)\n\t\t*len = 0;\n\telse\n\t\t*len = min_t(u64, page_offset(page) + PAGE_SIZE,\n\t\t\t     orig_start + orig_len) - *start;\n}\n\nvoid btrfs_subpage_start_writer(const struct btrfs_fs_info *fs_info,\n\t\tstruct page *page, u64 start, u32 len)\n{\n\tstruct btrfs_subpage *subpage = (struct btrfs_subpage *)page->private;\n\tconst int nbits = (len >> fs_info->sectorsize_bits);\n\tint ret;\n\n\tbtrfs_subpage_assert(fs_info, page, start, len);\n\n\tASSERT(atomic_read(&subpage->readers) == 0);\n\tret = atomic_add_return(nbits, &subpage->writers);\n\tASSERT(ret == nbits);\n}\n\nbool btrfs_subpage_end_and_test_writer(const struct btrfs_fs_info *fs_info,\n\t\tstruct page *page, u64 start, u32 len)\n{\n\tstruct btrfs_subpage *subpage = (struct btrfs_subpage *)page->private;\n\tconst int nbits = (len >> fs_info->sectorsize_bits);\n\n\tbtrfs_subpage_assert(fs_info, page, start, len);\n\n\t \n\tif (atomic_read(&subpage->writers) == 0)\n\t\treturn true;\n\n\tASSERT(atomic_read(&subpage->writers) >= nbits);\n\treturn atomic_sub_and_test(nbits, &subpage->writers);\n}\n\n \nint btrfs_page_start_writer_lock(const struct btrfs_fs_info *fs_info,\n\t\tstruct page *page, u64 start, u32 len)\n{\n\tif (unlikely(!fs_info) || !btrfs_is_subpage(fs_info, page)) {\n\t\tlock_page(page);\n\t\treturn 0;\n\t}\n\tlock_page(page);\n\tif (!PagePrivate(page) || !page->private) {\n\t\tunlock_page(page);\n\t\treturn -EAGAIN;\n\t}\n\tbtrfs_subpage_clamp_range(page, &start, &len);\n\tbtrfs_subpage_start_writer(fs_info, page, start, len);\n\treturn 0;\n}\n\nvoid btrfs_page_end_writer_lock(const struct btrfs_fs_info *fs_info,\n\t\tstruct page *page, u64 start, u32 len)\n{\n\tif (unlikely(!fs_info) || !btrfs_is_subpage(fs_info, page))\n\t\treturn unlock_page(page);\n\tbtrfs_subpage_clamp_range(page, &start, &len);\n\tif (btrfs_subpage_end_and_test_writer(fs_info, page, start, len))\n\t\tunlock_page(page);\n}\n\n#define subpage_calc_start_bit(fs_info, page, name, start, len)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tunsigned int start_bit;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tbtrfs_subpage_assert(fs_info, page, start, len);\t\t\\\n\tstart_bit = offset_in_page(start) >> fs_info->sectorsize_bits;\t\\\n\tstart_bit += fs_info->subpage_info->name##_offset;\t\t\\\n\tstart_bit;\t\t\t\t\t\t\t\\\n})\n\n#define subpage_test_bitmap_all_set(fs_info, subpage, name)\t\t\\\n\tbitmap_test_range_all_set(subpage->bitmaps,\t\t\t\\\n\t\t\tfs_info->subpage_info->name##_offset,\t\t\\\n\t\t\tfs_info->subpage_info->bitmap_nr_bits)\n\n#define subpage_test_bitmap_all_zero(fs_info, subpage, name)\t\t\\\n\tbitmap_test_range_all_zero(subpage->bitmaps,\t\t\t\\\n\t\t\tfs_info->subpage_info->name##_offset,\t\t\\\n\t\t\tfs_info->subpage_info->bitmap_nr_bits)\n\nvoid btrfs_subpage_set_uptodate(const struct btrfs_fs_info *fs_info,\n\t\tstruct page *page, u64 start, u32 len)\n{\n\tstruct btrfs_subpage *subpage = (struct btrfs_subpage *)page->private;\n\tunsigned int start_bit = subpage_calc_start_bit(fs_info, page,\n\t\t\t\t\t\t\tuptodate, start, len);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&subpage->lock, flags);\n\tbitmap_set(subpage->bitmaps, start_bit, len >> fs_info->sectorsize_bits);\n\tif (subpage_test_bitmap_all_set(fs_info, subpage, uptodate))\n\t\tSetPageUptodate(page);\n\tspin_unlock_irqrestore(&subpage->lock, flags);\n}\n\nvoid btrfs_subpage_clear_uptodate(const struct btrfs_fs_info *fs_info,\n\t\tstruct page *page, u64 start, u32 len)\n{\n\tstruct btrfs_subpage *subpage = (struct btrfs_subpage *)page->private;\n\tunsigned int start_bit = subpage_calc_start_bit(fs_info, page,\n\t\t\t\t\t\t\tuptodate, start, len);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&subpage->lock, flags);\n\tbitmap_clear(subpage->bitmaps, start_bit, len >> fs_info->sectorsize_bits);\n\tClearPageUptodate(page);\n\tspin_unlock_irqrestore(&subpage->lock, flags);\n}\n\nvoid btrfs_subpage_set_dirty(const struct btrfs_fs_info *fs_info,\n\t\tstruct page *page, u64 start, u32 len)\n{\n\tstruct btrfs_subpage *subpage = (struct btrfs_subpage *)page->private;\n\tunsigned int start_bit = subpage_calc_start_bit(fs_info, page,\n\t\t\t\t\t\t\tdirty, start, len);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&subpage->lock, flags);\n\tbitmap_set(subpage->bitmaps, start_bit, len >> fs_info->sectorsize_bits);\n\tspin_unlock_irqrestore(&subpage->lock, flags);\n\tset_page_dirty(page);\n}\n\n \nbool btrfs_subpage_clear_and_test_dirty(const struct btrfs_fs_info *fs_info,\n\t\tstruct page *page, u64 start, u32 len)\n{\n\tstruct btrfs_subpage *subpage = (struct btrfs_subpage *)page->private;\n\tunsigned int start_bit = subpage_calc_start_bit(fs_info, page,\n\t\t\t\t\t\t\tdirty, start, len);\n\tunsigned long flags;\n\tbool last = false;\n\n\tspin_lock_irqsave(&subpage->lock, flags);\n\tbitmap_clear(subpage->bitmaps, start_bit, len >> fs_info->sectorsize_bits);\n\tif (subpage_test_bitmap_all_zero(fs_info, subpage, dirty))\n\t\tlast = true;\n\tspin_unlock_irqrestore(&subpage->lock, flags);\n\treturn last;\n}\n\nvoid btrfs_subpage_clear_dirty(const struct btrfs_fs_info *fs_info,\n\t\tstruct page *page, u64 start, u32 len)\n{\n\tbool last;\n\n\tlast = btrfs_subpage_clear_and_test_dirty(fs_info, page, start, len);\n\tif (last)\n\t\tclear_page_dirty_for_io(page);\n}\n\nvoid btrfs_subpage_set_writeback(const struct btrfs_fs_info *fs_info,\n\t\tstruct page *page, u64 start, u32 len)\n{\n\tstruct btrfs_subpage *subpage = (struct btrfs_subpage *)page->private;\n\tunsigned int start_bit = subpage_calc_start_bit(fs_info, page,\n\t\t\t\t\t\t\twriteback, start, len);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&subpage->lock, flags);\n\tbitmap_set(subpage->bitmaps, start_bit, len >> fs_info->sectorsize_bits);\n\tset_page_writeback(page);\n\tspin_unlock_irqrestore(&subpage->lock, flags);\n}\n\nvoid btrfs_subpage_clear_writeback(const struct btrfs_fs_info *fs_info,\n\t\tstruct page *page, u64 start, u32 len)\n{\n\tstruct btrfs_subpage *subpage = (struct btrfs_subpage *)page->private;\n\tunsigned int start_bit = subpage_calc_start_bit(fs_info, page,\n\t\t\t\t\t\t\twriteback, start, len);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&subpage->lock, flags);\n\tbitmap_clear(subpage->bitmaps, start_bit, len >> fs_info->sectorsize_bits);\n\tif (subpage_test_bitmap_all_zero(fs_info, subpage, writeback)) {\n\t\tASSERT(PageWriteback(page));\n\t\tend_page_writeback(page);\n\t}\n\tspin_unlock_irqrestore(&subpage->lock, flags);\n}\n\nvoid btrfs_subpage_set_ordered(const struct btrfs_fs_info *fs_info,\n\t\tstruct page *page, u64 start, u32 len)\n{\n\tstruct btrfs_subpage *subpage = (struct btrfs_subpage *)page->private;\n\tunsigned int start_bit = subpage_calc_start_bit(fs_info, page,\n\t\t\t\t\t\t\tordered, start, len);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&subpage->lock, flags);\n\tbitmap_set(subpage->bitmaps, start_bit, len >> fs_info->sectorsize_bits);\n\tSetPageOrdered(page);\n\tspin_unlock_irqrestore(&subpage->lock, flags);\n}\n\nvoid btrfs_subpage_clear_ordered(const struct btrfs_fs_info *fs_info,\n\t\tstruct page *page, u64 start, u32 len)\n{\n\tstruct btrfs_subpage *subpage = (struct btrfs_subpage *)page->private;\n\tunsigned int start_bit = subpage_calc_start_bit(fs_info, page,\n\t\t\t\t\t\t\tordered, start, len);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&subpage->lock, flags);\n\tbitmap_clear(subpage->bitmaps, start_bit, len >> fs_info->sectorsize_bits);\n\tif (subpage_test_bitmap_all_zero(fs_info, subpage, ordered))\n\t\tClearPageOrdered(page);\n\tspin_unlock_irqrestore(&subpage->lock, flags);\n}\n\nvoid btrfs_subpage_set_checked(const struct btrfs_fs_info *fs_info,\n\t\t\t       struct page *page, u64 start, u32 len)\n{\n\tstruct btrfs_subpage *subpage = (struct btrfs_subpage *)page->private;\n\tunsigned int start_bit = subpage_calc_start_bit(fs_info, page,\n\t\t\t\t\t\t\tchecked, start, len);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&subpage->lock, flags);\n\tbitmap_set(subpage->bitmaps, start_bit, len >> fs_info->sectorsize_bits);\n\tif (subpage_test_bitmap_all_set(fs_info, subpage, checked))\n\t\tSetPageChecked(page);\n\tspin_unlock_irqrestore(&subpage->lock, flags);\n}\n\nvoid btrfs_subpage_clear_checked(const struct btrfs_fs_info *fs_info,\n\t\t\t\t struct page *page, u64 start, u32 len)\n{\n\tstruct btrfs_subpage *subpage = (struct btrfs_subpage *)page->private;\n\tunsigned int start_bit = subpage_calc_start_bit(fs_info, page,\n\t\t\t\t\t\t\tchecked, start, len);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&subpage->lock, flags);\n\tbitmap_clear(subpage->bitmaps, start_bit, len >> fs_info->sectorsize_bits);\n\tClearPageChecked(page);\n\tspin_unlock_irqrestore(&subpage->lock, flags);\n}\n\n \n#define IMPLEMENT_BTRFS_SUBPAGE_TEST_OP(name)\t\t\t\t\\\nbool btrfs_subpage_test_##name(const struct btrfs_fs_info *fs_info,\t\\\n\t\tstruct page *page, u64 start, u32 len)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct btrfs_subpage *subpage = (struct btrfs_subpage *)page->private; \\\n\tunsigned int start_bit = subpage_calc_start_bit(fs_info, page,\t\\\n\t\t\t\t\t\tname, start, len);\t\\\n\tunsigned long flags;\t\t\t\t\t\t\\\n\tbool ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tspin_lock_irqsave(&subpage->lock, flags);\t\t\t\\\n\tret = bitmap_test_range_all_set(subpage->bitmaps, start_bit,\t\\\n\t\t\t\tlen >> fs_info->sectorsize_bits);\t\\\n\tspin_unlock_irqrestore(&subpage->lock, flags);\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\nIMPLEMENT_BTRFS_SUBPAGE_TEST_OP(uptodate);\nIMPLEMENT_BTRFS_SUBPAGE_TEST_OP(dirty);\nIMPLEMENT_BTRFS_SUBPAGE_TEST_OP(writeback);\nIMPLEMENT_BTRFS_SUBPAGE_TEST_OP(ordered);\nIMPLEMENT_BTRFS_SUBPAGE_TEST_OP(checked);\n\n \n#define IMPLEMENT_BTRFS_PAGE_OPS(name, set_page_func, clear_page_func,\t\\\n\t\t\t       test_page_func)\t\t\t\t\\\nvoid btrfs_page_set_##name(const struct btrfs_fs_info *fs_info,\t\t\\\n\t\tstruct page *page, u64 start, u32 len)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely(!fs_info) || !btrfs_is_subpage(fs_info, page)) {\t\\\n\t\tset_page_func(page);\t\t\t\t\t\\\n\t\treturn;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tbtrfs_subpage_set_##name(fs_info, page, start, len);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nvoid btrfs_page_clear_##name(const struct btrfs_fs_info *fs_info,\t\\\n\t\tstruct page *page, u64 start, u32 len)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely(!fs_info) || !btrfs_is_subpage(fs_info, page)) {\t\\\n\t\tclear_page_func(page);\t\t\t\t\t\\\n\t\treturn;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tbtrfs_subpage_clear_##name(fs_info, page, start, len);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nbool btrfs_page_test_##name(const struct btrfs_fs_info *fs_info,\t\\\n\t\tstruct page *page, u64 start, u32 len)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely(!fs_info) || !btrfs_is_subpage(fs_info, page))\t\\\n\t\treturn test_page_func(page);\t\t\t\t\\\n\treturn btrfs_subpage_test_##name(fs_info, page, start, len);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nvoid btrfs_page_clamp_set_##name(const struct btrfs_fs_info *fs_info,\t\\\n\t\tstruct page *page, u64 start, u32 len)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely(!fs_info) || !btrfs_is_subpage(fs_info, page)) {\t\\\n\t\tset_page_func(page);\t\t\t\t\t\\\n\t\treturn;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tbtrfs_subpage_clamp_range(page, &start, &len);\t\t\t\\\n\tbtrfs_subpage_set_##name(fs_info, page, start, len);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nvoid btrfs_page_clamp_clear_##name(const struct btrfs_fs_info *fs_info, \\\n\t\tstruct page *page, u64 start, u32 len)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely(!fs_info) || !btrfs_is_subpage(fs_info, page)) {\t\\\n\t\tclear_page_func(page);\t\t\t\t\t\\\n\t\treturn;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tbtrfs_subpage_clamp_range(page, &start, &len);\t\t\t\\\n\tbtrfs_subpage_clear_##name(fs_info, page, start, len);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nbool btrfs_page_clamp_test_##name(const struct btrfs_fs_info *fs_info,\t\\\n\t\tstruct page *page, u64 start, u32 len)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely(!fs_info) || !btrfs_is_subpage(fs_info, page))\t\\\n\t\treturn test_page_func(page);\t\t\t\t\\\n\tbtrfs_subpage_clamp_range(page, &start, &len);\t\t\t\\\n\treturn btrfs_subpage_test_##name(fs_info, page, start, len);\t\\\n}\nIMPLEMENT_BTRFS_PAGE_OPS(uptodate, SetPageUptodate, ClearPageUptodate,\n\t\t\t PageUptodate);\nIMPLEMENT_BTRFS_PAGE_OPS(dirty, set_page_dirty, clear_page_dirty_for_io,\n\t\t\t PageDirty);\nIMPLEMENT_BTRFS_PAGE_OPS(writeback, set_page_writeback, end_page_writeback,\n\t\t\t PageWriteback);\nIMPLEMENT_BTRFS_PAGE_OPS(ordered, SetPageOrdered, ClearPageOrdered,\n\t\t\t PageOrdered);\nIMPLEMENT_BTRFS_PAGE_OPS(checked, SetPageChecked, ClearPageChecked, PageChecked);\n\n \nvoid btrfs_page_assert_not_dirty(const struct btrfs_fs_info *fs_info,\n\t\t\t\t struct page *page)\n{\n\tstruct btrfs_subpage *subpage = (struct btrfs_subpage *)page->private;\n\n\tif (!IS_ENABLED(CONFIG_BTRFS_ASSERT))\n\t\treturn;\n\n\tASSERT(!PageDirty(page));\n\tif (!btrfs_is_subpage(fs_info, page))\n\t\treturn;\n\n\tASSERT(PagePrivate(page) && page->private);\n\tASSERT(subpage_test_bitmap_all_zero(fs_info, subpage, dirty));\n}\n\n \nvoid btrfs_page_unlock_writer(struct btrfs_fs_info *fs_info, struct page *page,\n\t\t\t      u64 start, u32 len)\n{\n\tstruct btrfs_subpage *subpage;\n\n\tASSERT(PageLocked(page));\n\t \n\tif (!btrfs_is_subpage(fs_info, page))\n\t\treturn unlock_page(page);\n\n\tASSERT(PagePrivate(page) && page->private);\n\tsubpage = (struct btrfs_subpage *)page->private;\n\n\t \n\tif (atomic_read(&subpage->writers) == 0)\n\t\t \n\t\treturn unlock_page(page);\n\n\t \n\tbtrfs_page_end_writer_lock(fs_info, page, start, len);\n}\n\n#define GET_SUBPAGE_BITMAP(subpage, subpage_info, name, dst)\t\t\\\n\tbitmap_cut(dst, subpage->bitmaps, 0,\t\t\t\t\\\n\t\t   subpage_info->name##_offset, subpage_info->bitmap_nr_bits)\n\nvoid __cold btrfs_subpage_dump_bitmap(const struct btrfs_fs_info *fs_info,\n\t\t\t\t      struct page *page, u64 start, u32 len)\n{\n\tstruct btrfs_subpage_info *subpage_info = fs_info->subpage_info;\n\tstruct btrfs_subpage *subpage;\n\tunsigned long uptodate_bitmap;\n\tunsigned long error_bitmap;\n\tunsigned long dirty_bitmap;\n\tunsigned long writeback_bitmap;\n\tunsigned long ordered_bitmap;\n\tunsigned long checked_bitmap;\n\tunsigned long flags;\n\n\tASSERT(PagePrivate(page) && page->private);\n\tASSERT(subpage_info);\n\tsubpage = (struct btrfs_subpage *)page->private;\n\n\tspin_lock_irqsave(&subpage->lock, flags);\n\tGET_SUBPAGE_BITMAP(subpage, subpage_info, uptodate, &uptodate_bitmap);\n\tGET_SUBPAGE_BITMAP(subpage, subpage_info, dirty, &dirty_bitmap);\n\tGET_SUBPAGE_BITMAP(subpage, subpage_info, writeback, &writeback_bitmap);\n\tGET_SUBPAGE_BITMAP(subpage, subpage_info, ordered, &ordered_bitmap);\n\tGET_SUBPAGE_BITMAP(subpage, subpage_info, checked, &checked_bitmap);\n\tspin_unlock_irqrestore(&subpage->lock, flags);\n\n\tdump_page(page, \"btrfs subpage dump\");\n\tbtrfs_warn(fs_info,\n\"start=%llu len=%u page=%llu, bitmaps uptodate=%*pbl error=%*pbl dirty=%*pbl writeback=%*pbl ordered=%*pbl checked=%*pbl\",\n\t\t    start, len, page_offset(page),\n\t\t    subpage_info->bitmap_nr_bits, &uptodate_bitmap,\n\t\t    subpage_info->bitmap_nr_bits, &error_bitmap,\n\t\t    subpage_info->bitmap_nr_bits, &dirty_bitmap,\n\t\t    subpage_info->bitmap_nr_bits, &writeback_bitmap,\n\t\t    subpage_info->bitmap_nr_bits, &ordered_bitmap,\n\t\t    subpage_info->bitmap_nr_bits, &checked_bitmap);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}