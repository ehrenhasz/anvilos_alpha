{
  "module_name": "send.c",
  "hash_id": "fbda0744ccbd13665aaddfa86a447eaa97b979904dd061547c22bf69fadc53eb",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/send.c",
  "human_readable_source": "\n \n\n#include <linux/bsearch.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sort.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/radix-tree.h>\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/compat.h>\n#include <linux/crc32c.h>\n#include <linux/fsverity.h>\n\n#include \"send.h\"\n#include \"ctree.h\"\n#include \"backref.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"compression.h\"\n#include \"xattr.h\"\n#include \"print-tree.h\"\n#include \"accessors.h\"\n#include \"dir-item.h\"\n#include \"file-item.h\"\n#include \"ioctl.h\"\n#include \"verity.h\"\n#include \"lru_cache.h\"\n\n \n#define SEND_MAX_EXTENT_REFS\t1024\n\n \nstruct fs_path {\n\tunion {\n\t\tstruct {\n\t\t\tchar *start;\n\t\t\tchar *end;\n\n\t\t\tchar *buf;\n\t\t\tunsigned short buf_len:15;\n\t\t\tunsigned short reversed:1;\n\t\t\tchar inline_buf[];\n\t\t};\n\t\t \n\t\tchar pad[256];\n\t};\n};\n#define FS_PATH_INLINE_SIZE \\\n\t(sizeof(struct fs_path) - offsetof(struct fs_path, inline_buf))\n\n\n \nstruct clone_root {\n\tstruct btrfs_root *root;\n\tu64 ino;\n\tu64 offset;\n\tu64 num_bytes;\n\tbool found_ref;\n};\n\n#define SEND_MAX_NAME_CACHE_SIZE\t\t\t256\n\n \n#define SEND_MAX_BACKREF_CACHE_ROOTS\t\t\t17\n\n \n#define SEND_MAX_BACKREF_CACHE_SIZE 128\n\n \nstruct backref_cache_entry {\n\tstruct btrfs_lru_cache_entry entry;\n\tu64 root_ids[SEND_MAX_BACKREF_CACHE_ROOTS];\n\t \n\tint num_roots;\n};\n\n \nstatic_assert(offsetof(struct backref_cache_entry, entry) == 0);\n\n \n#define SEND_MAX_DIR_CREATED_CACHE_SIZE\t\t\t64\n\n \n#define SEND_MAX_DIR_UTIMES_CACHE_SIZE\t\t\t64\n\nstruct send_ctx {\n\tstruct file *send_filp;\n\tloff_t send_off;\n\tchar *send_buf;\n\tu32 send_size;\n\tu32 send_max_size;\n\t \n\tbool put_data;\n\tstruct page **send_buf_pages;\n\tu64 flags;\t \n\t \n\tu32 proto;\n\n\tstruct btrfs_root *send_root;\n\tstruct btrfs_root *parent_root;\n\tstruct clone_root *clone_roots;\n\tint clone_roots_cnt;\n\n\t \n\tstruct btrfs_path *left_path;\n\tstruct btrfs_path *right_path;\n\tstruct btrfs_key *cmp_key;\n\n\t \n\tu64 last_reloc_trans;\n\n\t \n\tu64 cur_ino;\n\tu64 cur_inode_gen;\n\tu64 cur_inode_size;\n\tu64 cur_inode_mode;\n\tu64 cur_inode_rdev;\n\tu64 cur_inode_last_extent;\n\tu64 cur_inode_next_write_offset;\n\tbool cur_inode_new;\n\tbool cur_inode_new_gen;\n\tbool cur_inode_deleted;\n\tbool ignore_cur_inode;\n\tbool cur_inode_needs_verity;\n\tvoid *verity_descriptor;\n\n\tu64 send_progress;\n\n\tstruct list_head new_refs;\n\tstruct list_head deleted_refs;\n\n\tstruct btrfs_lru_cache name_cache;\n\n\t \n\tstruct inode *cur_inode;\n\tstruct file_ra_state ra;\n\tu64 page_cache_clear_start;\n\tbool clean_page_cache;\n\n\t \n\n\t \n\tstruct rb_root pending_dir_moves;\n\n\t \n\tstruct rb_root waiting_dir_moves;\n\n\t \n\tstruct rb_root orphan_dirs;\n\n\tstruct rb_root rbtree_new_refs;\n\tstruct rb_root rbtree_deleted_refs;\n\n\tstruct btrfs_lru_cache backref_cache;\n\tu64 backref_cache_last_reloc_trans;\n\n\tstruct btrfs_lru_cache dir_created_cache;\n\tstruct btrfs_lru_cache dir_utimes_cache;\n};\n\nstruct pending_dir_move {\n\tstruct rb_node node;\n\tstruct list_head list;\n\tu64 parent_ino;\n\tu64 ino;\n\tu64 gen;\n\tstruct list_head update_refs;\n};\n\nstruct waiting_dir_move {\n\tstruct rb_node node;\n\tu64 ino;\n\t \n\tu64 rmdir_ino;\n\tu64 rmdir_gen;\n\tbool orphanized;\n};\n\nstruct orphan_dir_info {\n\tstruct rb_node node;\n\tu64 ino;\n\tu64 gen;\n\tu64 last_dir_index_offset;\n\tu64 dir_high_seq_ino;\n};\n\nstruct name_cache_entry {\n\t \n\tstruct btrfs_lru_cache_entry entry;\n\tu64 parent_ino;\n\tu64 parent_gen;\n\tint ret;\n\tint need_later_update;\n\tint name_len;\n\tchar name[];\n};\n\n \nstatic_assert(offsetof(struct name_cache_entry, entry) == 0);\n\n#define ADVANCE\t\t\t\t\t\t\t1\n#define ADVANCE_ONLY_NEXT\t\t\t\t\t-1\n\nenum btrfs_compare_tree_result {\n\tBTRFS_COMPARE_TREE_NEW,\n\tBTRFS_COMPARE_TREE_DELETED,\n\tBTRFS_COMPARE_TREE_CHANGED,\n\tBTRFS_COMPARE_TREE_SAME,\n};\n\n__cold\nstatic void inconsistent_snapshot_error(struct send_ctx *sctx,\n\t\t\t\t\tenum btrfs_compare_tree_result result,\n\t\t\t\t\tconst char *what)\n{\n\tconst char *result_string;\n\n\tswitch (result) {\n\tcase BTRFS_COMPARE_TREE_NEW:\n\t\tresult_string = \"new\";\n\t\tbreak;\n\tcase BTRFS_COMPARE_TREE_DELETED:\n\t\tresult_string = \"deleted\";\n\t\tbreak;\n\tcase BTRFS_COMPARE_TREE_CHANGED:\n\t\tresult_string = \"updated\";\n\t\tbreak;\n\tcase BTRFS_COMPARE_TREE_SAME:\n\t\tASSERT(0);\n\t\tresult_string = \"unchanged\";\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tresult_string = \"unexpected\";\n\t}\n\n\tbtrfs_err(sctx->send_root->fs_info,\n\t\t  \"Send: inconsistent snapshot, found %s %s for inode %llu without updated inode item, send root is %llu, parent root is %llu\",\n\t\t  result_string, what, sctx->cmp_key->objectid,\n\t\t  sctx->send_root->root_key.objectid,\n\t\t  (sctx->parent_root ?\n\t\t   sctx->parent_root->root_key.objectid : 0));\n}\n\n__maybe_unused\nstatic bool proto_cmd_ok(const struct send_ctx *sctx, int cmd)\n{\n\tswitch (sctx->proto) {\n\tcase 1:\t return cmd <= BTRFS_SEND_C_MAX_V1;\n\tcase 2:\t return cmd <= BTRFS_SEND_C_MAX_V2;\n\tcase 3:\t return cmd <= BTRFS_SEND_C_MAX_V3;\n\tdefault: return false;\n\t}\n}\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\n\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino, u64 gen);\n\nstatic int need_send_hole(struct send_ctx *sctx)\n{\n\treturn (sctx->parent_root && !sctx->cur_inode_new &&\n\t\t!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted &&\n\t\tS_ISREG(sctx->cur_inode_mode));\n}\n\nstatic void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}\n\nstatic struct fs_path *fs_path_alloc(void)\n{\n\tstruct fs_path *p;\n\n\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 0;\n\tp->buf = p->inline_buf;\n\tp->buf_len = FS_PATH_INLINE_SIZE;\n\tfs_path_reset(p);\n\treturn p;\n}\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}\n\nstatic int fs_path_len(struct fs_path *p)\n{\n\treturn p->end - p->start;\n}\n\nstatic int fs_path_ensure_buf(struct fs_path *p, int len)\n{\n\tchar *tmp_buf;\n\tint path_len;\n\tint old_buf_len;\n\n\tlen++;\n\n\tif (p->buf_len >= len)\n\t\treturn 0;\n\n\tif (len > PATH_MAX) {\n\t\tWARN_ON(1);\n\t\treturn -ENOMEM;\n\t}\n\n\tpath_len = p->end - p->start;\n\told_buf_len = p->buf_len;\n\n\t \n\tlen = kmalloc_size_roundup(len);\n\t \n\tif (p->buf == p->inline_buf) {\n\t\ttmp_buf = kmalloc(len, GFP_KERNEL);\n\t\tif (tmp_buf)\n\t\t\tmemcpy(tmp_buf, p->buf, old_buf_len);\n\t} else {\n\t\ttmp_buf = krealloc(p->buf, len, GFP_KERNEL);\n\t}\n\tif (!tmp_buf)\n\t\treturn -ENOMEM;\n\tp->buf = tmp_buf;\n\tp->buf_len = len;\n\n\tif (p->reversed) {\n\t\ttmp_buf = p->buf + old_buf_len - path_len - 1;\n\t\tp->end = p->buf + p->buf_len - 1;\n\t\tp->start = p->end - path_len;\n\t\tmemmove(p->start, tmp_buf, path_len + 1);\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start + path_len;\n\t}\n\treturn 0;\n}\n\nstatic int fs_path_prepare_for_add(struct fs_path *p, int name_len,\n\t\t\t\t   char **prepared)\n{\n\tint ret;\n\tint new_len;\n\n\tnew_len = p->end - p->start + name_len;\n\tif (p->start != p->end)\n\t\tnew_len++;\n\tret = fs_path_ensure_buf(p, new_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (p->reversed) {\n\t\tif (p->start != p->end)\n\t\t\t*--p->start = '/';\n\t\tp->start -= name_len;\n\t\t*prepared = p->start;\n\t} else {\n\t\tif (p->start != p->end)\n\t\t\t*p->end++ = '/';\n\t\t*prepared = p->end;\n\t\tp->end += name_len;\n\t\t*p->end = 0;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int fs_path_add(struct fs_path *p, const char *name, int name_len)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, name_len, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, name, name_len);\n\nout:\n\treturn ret;\n}\n\nstatic int fs_path_add_path(struct fs_path *p, struct fs_path *p2)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, p2->end - p2->start, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, p2->start, p2->end - p2->start);\n\nout:\n\treturn ret;\n}\n\nstatic int fs_path_add_from_extent_buffer(struct fs_path *p,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  unsigned long off, int len)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, len, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tread_extent_buffer(eb, prepared, off, len);\n\nout:\n\treturn ret;\n}\n\nstatic int fs_path_copy(struct fs_path *p, struct fs_path *from)\n{\n\tp->reversed = from->reversed;\n\tfs_path_reset(p);\n\n\treturn fs_path_add_path(p, from);\n}\n\nstatic void fs_path_unreverse(struct fs_path *p)\n{\n\tchar *tmp;\n\tint len;\n\n\tif (!p->reversed)\n\t\treturn;\n\n\ttmp = p->start;\n\tlen = p->end - p->start;\n\tp->start = p->buf;\n\tp->end = p->start + len;\n\tmemmove(p->start, tmp, len + 1);\n\tp->reversed = 0;\n}\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}\n\nstatic int write_buf(struct file *filp, const void *buf, u32 len, loff_t *off)\n{\n\tint ret;\n\tu32 pos = 0;\n\n\twhile (pos < len) {\n\t\tret = kernel_write(filp, buf + pos, len - pos, off);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 0)\n\t\t\treturn -EIO;\n\t\tpos += ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tlv_put(struct send_ctx *sctx, u16 attr, const void *data, int len)\n{\n\tstruct btrfs_tlv_header *hdr;\n\tint total_len = sizeof(*hdr) + len;\n\tint left = sctx->send_max_size - sctx->send_size;\n\n\tif (WARN_ON_ONCE(sctx->put_data))\n\t\treturn -EINVAL;\n\n\tif (unlikely(left < total_len))\n\t\treturn -EOVERFLOW;\n\n\thdr = (struct btrfs_tlv_header *) (sctx->send_buf + sctx->send_size);\n\tput_unaligned_le16(attr, &hdr->tlv_type);\n\tput_unaligned_le16(len, &hdr->tlv_len);\n\tmemcpy(hdr + 1, data, len);\n\tsctx->send_size += total_len;\n\n\treturn 0;\n}\n\n#define TLV_PUT_DEFINE_INT(bits) \\\n\tstatic int tlv_put_u##bits(struct send_ctx *sctx,\t \t\\\n\t\t\tu##bits attr, u##bits value)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t__le##bits __tmp = cpu_to_le##bits(value);\t\t\\\n\t\treturn tlv_put(sctx, attr, &__tmp, sizeof(__tmp));\t\\\n\t}\n\nTLV_PUT_DEFINE_INT(8)\nTLV_PUT_DEFINE_INT(32)\nTLV_PUT_DEFINE_INT(64)\n\nstatic int tlv_put_string(struct send_ctx *sctx, u16 attr,\n\t\t\t  const char *str, int len)\n{\n\tif (len == -1)\n\t\tlen = strlen(str);\n\treturn tlv_put(sctx, attr, str, len);\n}\n\nstatic int tlv_put_uuid(struct send_ctx *sctx, u16 attr,\n\t\t\tconst u8 *uuid)\n{\n\treturn tlv_put(sctx, attr, uuid, BTRFS_UUID_SIZE);\n}\n\nstatic int tlv_put_btrfs_timespec(struct send_ctx *sctx, u16 attr,\n\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_timespec *ts)\n{\n\tstruct btrfs_timespec bts;\n\tread_extent_buffer(eb, &bts, (unsigned long)ts, sizeof(bts));\n\treturn tlv_put(sctx, attr, &bts, sizeof(bts));\n}\n\n\n#define TLV_PUT(sctx, attrtype, data, attrlen) \\\n\tdo { \\\n\t\tret = tlv_put(sctx, attrtype, data, attrlen); \\\n\t\tif (ret < 0) \\\n\t\t\tgoto tlv_put_failure; \\\n\t} while (0)\n\n#define TLV_PUT_INT(sctx, attrtype, bits, value) \\\n\tdo { \\\n\t\tret = tlv_put_u##bits(sctx, attrtype, value); \\\n\t\tif (ret < 0) \\\n\t\t\tgoto tlv_put_failure; \\\n\t} while (0)\n\n#define TLV_PUT_U8(sctx, attrtype, data) TLV_PUT_INT(sctx, attrtype, 8, data)\n#define TLV_PUT_U16(sctx, attrtype, data) TLV_PUT_INT(sctx, attrtype, 16, data)\n#define TLV_PUT_U32(sctx, attrtype, data) TLV_PUT_INT(sctx, attrtype, 32, data)\n#define TLV_PUT_U64(sctx, attrtype, data) TLV_PUT_INT(sctx, attrtype, 64, data)\n#define TLV_PUT_STRING(sctx, attrtype, str, len) \\\n\tdo { \\\n\t\tret = tlv_put_string(sctx, attrtype, str, len); \\\n\t\tif (ret < 0) \\\n\t\t\tgoto tlv_put_failure; \\\n\t} while (0)\n#define TLV_PUT_PATH(sctx, attrtype, p) \\\n\tdo { \\\n\t\tret = tlv_put_string(sctx, attrtype, p->start, \\\n\t\t\tp->end - p->start); \\\n\t\tif (ret < 0) \\\n\t\t\tgoto tlv_put_failure; \\\n\t} while(0)\n#define TLV_PUT_UUID(sctx, attrtype, uuid) \\\n\tdo { \\\n\t\tret = tlv_put_uuid(sctx, attrtype, uuid); \\\n\t\tif (ret < 0) \\\n\t\t\tgoto tlv_put_failure; \\\n\t} while (0)\n#define TLV_PUT_BTRFS_TIMESPEC(sctx, attrtype, eb, ts) \\\n\tdo { \\\n\t\tret = tlv_put_btrfs_timespec(sctx, attrtype, eb, ts); \\\n\t\tif (ret < 0) \\\n\t\t\tgoto tlv_put_failure; \\\n\t} while (0)\n\nstatic int send_header(struct send_ctx *sctx)\n{\n\tstruct btrfs_stream_header hdr;\n\n\tstrcpy(hdr.magic, BTRFS_SEND_STREAM_MAGIC);\n\thdr.version = cpu_to_le32(sctx->proto);\n\treturn write_buf(sctx->send_filp, &hdr, sizeof(hdr),\n\t\t\t\t\t&sctx->send_off);\n}\n\n \nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\tput_unaligned_le16(cmd, &hdr->cmd);\n\n\treturn 0;\n}\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\tput_unaligned_le32(sctx->send_size - sizeof(*hdr), &hdr->len);\n\tput_unaligned_le32(0, &hdr->crc);\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\tput_unaligned_le32(crc, &hdr->crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->send_size = 0;\n\tsctx->put_data = false;\n\n\treturn ret;\n}\n\n \nstatic int send_rename(struct send_ctx *sctx,\n\t\t     struct fs_path *from, struct fs_path *to)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret;\n\n\tbtrfs_debug(fs_info, \"send_rename %s -> %s\", from->start, to->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_RENAME);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, from);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_TO, to);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}\n\n \nstatic int send_link(struct send_ctx *sctx,\n\t\t     struct fs_path *path, struct fs_path *lnk)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret;\n\n\tbtrfs_debug(fs_info, \"send_link %s -> %s\", path->start, lnk->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_LINK);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_LINK, lnk);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}\n\n \nstatic int send_unlink(struct send_ctx *sctx, struct fs_path *path)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret;\n\n\tbtrfs_debug(fs_info, \"send_unlink %s\", path->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UNLINK);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}\n\n \nstatic int send_rmdir(struct send_ctx *sctx, struct fs_path *path)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret;\n\n\tbtrfs_debug(fs_info, \"send_rmdir %s\", path->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_RMDIR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}\n\nstruct btrfs_inode_info {\n\tu64 size;\n\tu64 gen;\n\tu64 mode;\n\tu64 uid;\n\tu64 gid;\n\tu64 rdev;\n\tu64 fileattr;\n\tu64 nlink;\n};\n\n \nstatic int get_inode_info(struct btrfs_root *root, u64 ino,\n\t\t\t  struct btrfs_inode_info *info)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_key key;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!info)\n\t\tgoto out;\n\n\tii = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\tstruct btrfs_inode_item);\n\tinfo->size = btrfs_inode_size(path->nodes[0], ii);\n\tinfo->gen = btrfs_inode_generation(path->nodes[0], ii);\n\tinfo->mode = btrfs_inode_mode(path->nodes[0], ii);\n\tinfo->uid = btrfs_inode_uid(path->nodes[0], ii);\n\tinfo->gid = btrfs_inode_gid(path->nodes[0], ii);\n\tinfo->rdev = btrfs_inode_rdev(path->nodes[0], ii);\n\tinfo->nlink = btrfs_inode_nlink(path->nodes[0], ii);\n\t \n\tinfo->fileattr = btrfs_inode_flags(path->nodes[0], ii);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int get_inode_gen(struct btrfs_root *root, u64 ino, u64 *gen)\n{\n\tint ret;\n\tstruct btrfs_inode_info info = { 0 };\n\n\tASSERT(gen);\n\n\tret = get_inode_info(root, ino, &info);\n\t*gen = info.gen;\n\treturn ret;\n}\n\ntypedef int (*iterate_inode_ref_t)(int num, u64 dir, int index,\n\t\t\t\t   struct fs_path *p,\n\t\t\t\t   void *ctx);\n\n \nstatic int iterate_inode_ref(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *found_key, int resolve,\n\t\t\t     iterate_inode_ref_t iterate, void *ctx)\n{\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_inode_extref *extref;\n\tstruct btrfs_path *tmp_path;\n\tstruct fs_path *p;\n\tu32 cur = 0;\n\tu32 total;\n\tint slot = path->slots[0];\n\tu32 name_len;\n\tchar *start;\n\tint ret = 0;\n\tint num = 0;\n\tint index;\n\tu64 dir;\n\tunsigned long name_off;\n\tunsigned long elem_size;\n\tunsigned long ptr;\n\n\tp = fs_path_alloc_reversed();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path) {\n\t\tfs_path_free(p);\n\t\treturn -ENOMEM;\n\t}\n\n\n\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\tptr = (unsigned long)btrfs_item_ptr(eb, slot,\n\t\t\t\t\t\t    struct btrfs_inode_ref);\n\t\ttotal = btrfs_item_size(eb, slot);\n\t\telem_size = sizeof(*iref);\n\t} else {\n\t\tptr = btrfs_item_ptr_offset(eb, slot);\n\t\ttotal = btrfs_item_size(eb, slot);\n\t\telem_size = sizeof(*extref);\n\t}\n\n\twhile (cur < total) {\n\t\tfs_path_reset(p);\n\n\t\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_off = (unsigned long)(iref + 1);\n\t\t\tindex = btrfs_inode_ref_index(eb, iref);\n\t\t\tdir = found_key->offset;\n\t\t} else {\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_off = (unsigned long)&extref->name;\n\t\t\tindex = btrfs_inode_extref_index(eb, extref);\n\t\t\tdir = btrfs_inode_extref_parent(eb, extref);\n\t\t}\n\n\t\tif (resolve) {\n\t\t\tstart = btrfs_ref_to_path(root, tmp_path, name_len,\n\t\t\t\t\t\t  name_off, eb, dir,\n\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\tif (IS_ERR(start)) {\n\t\t\t\tret = PTR_ERR(start);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (start < p->buf) {\n\t\t\t\t \n\t\t\t\tret = fs_path_ensure_buf(p,\n\t\t\t\t\t\tp->buf_len + p->buf - start);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tstart = btrfs_ref_to_path(root, tmp_path,\n\t\t\t\t\t\t\t  name_len, name_off,\n\t\t\t\t\t\t\t  eb, dir,\n\t\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\t\tif (IS_ERR(start)) {\n\t\t\t\t\tret = PTR_ERR(start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tBUG_ON(start < p->buf);\n\t\t\t}\n\t\t\tp->start = start;\n\t\t} else {\n\t\t\tret = fs_path_add_from_extent_buffer(p, eb, name_off,\n\t\t\t\t\t\t\t     name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcur += elem_size + name_len;\n\t\tret = iterate(num, dir, index, p, ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnum++;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tfs_path_free(p);\n\treturn ret;\n}\n\ntypedef int (*iterate_dir_item_t)(int num, struct btrfs_key *di_key,\n\t\t\t\t  const char *name, int name_len,\n\t\t\t\t  const char *data, int data_len,\n\t\t\t\t  void *ctx);\n\n \nstatic int iterate_dir_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    iterate_dir_item_t iterate, void *ctx)\n{\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key di_key;\n\tchar *buf = NULL;\n\tint buf_len;\n\tu32 name_len;\n\tu32 data_len;\n\tu32 cur;\n\tu32 len;\n\tu32 total;\n\tint slot;\n\tint num;\n\n\t \n\tbuf_len = PATH_MAX;\n\tbuf = kmalloc(buf_len, GFP_KERNEL);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\tcur = 0;\n\tlen = 0;\n\ttotal = btrfs_item_size(eb, slot);\n\n\tnum = 0;\n\twhile (cur < total) {\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tdata_len = btrfs_dir_data_len(eb, di);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (btrfs_dir_ftype(eb, di) == BTRFS_FT_XATTR) {\n\t\t\tif (name_len > XATTR_NAME_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name_len + data_len >\n\t\t\t\t\tBTRFS_MAX_XATTR_SIZE(root->fs_info)) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (name_len + data_len > PATH_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (name_len + data_len > buf_len) {\n\t\t\tbuf_len = name_len + data_len;\n\t\t\tif (is_vmalloc_addr(buf)) {\n\t\t\t\tvfree(buf);\n\t\t\t\tbuf = NULL;\n\t\t\t} else {\n\t\t\t\tchar *tmp = krealloc(buf, buf_len,\n\t\t\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\n\t\t\t\tif (!tmp)\n\t\t\t\t\tkfree(buf);\n\t\t\t\tbuf = tmp;\n\t\t\t}\n\t\t\tif (!buf) {\n\t\t\t\tbuf = kvmalloc(buf_len, GFP_KERNEL);\n\t\t\t\tif (!buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tread_extent_buffer(eb, buf, (unsigned long)(di + 1),\n\t\t\t\tname_len + data_len);\n\n\t\tlen = sizeof(*di) + name_len + data_len;\n\t\tdi = (struct btrfs_dir_item *)((char *)di + len);\n\t\tcur += len;\n\n\t\tret = iterate(num, &di_key, buf, name_len, buf + name_len,\n\t\t\t      data_len, ctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum++;\n\t}\n\nout:\n\tkvfree(buf);\n\treturn ret;\n}\n\nstatic int __copy_first_ref(int num, u64 dir, int index,\n\t\t\t    struct fs_path *p, void *ctx)\n{\n\tint ret;\n\tstruct fs_path *pt = ctx;\n\n\tret = fs_path_copy(pt, p);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn 1;\n}\n\n \nstatic int get_inode_path(struct btrfs_root *root,\n\t\t\t  u64 ino, struct fs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key, found_key;\n\tstruct btrfs_path *p;\n\n\tp = alloc_path_for_send();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tfs_path_reset(path);\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, p, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\tbtrfs_item_key_to_cpu(p->nodes[0], &found_key, p->slots[0]);\n\tif (found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = iterate_inode_ref(root, p, &found_key, 1,\n\t\t\t\t__copy_first_ref, path);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\tbtrfs_free_path(p);\n\treturn ret;\n}\n\nstruct backref_ctx {\n\tstruct send_ctx *sctx;\n\n\t \n\tu64 found;\n\n\t \n\tu64 cur_objectid;\n\tu64 cur_offset;\n\n\t \n\tu64 extent_len;\n\n\t \n\tu64 bytenr;\n\t \n\tu64 backref_owner;\n\t \n\tu64 backref_offset;\n};\n\nstatic int __clone_root_cmp_bsearch(const void *key, const void *elt)\n{\n\tu64 root = (u64)(uintptr_t)key;\n\tconst struct clone_root *cr = elt;\n\n\tif (root < cr->root->root_key.objectid)\n\t\treturn -1;\n\tif (root > cr->root->root_key.objectid)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int __clone_root_cmp_sort(const void *e1, const void *e2)\n{\n\tconst struct clone_root *cr1 = e1;\n\tconst struct clone_root *cr2 = e2;\n\n\tif (cr1->root->root_key.objectid < cr2->root->root_key.objectid)\n\t\treturn -1;\n\tif (cr1->root->root_key.objectid > cr2->root->root_key.objectid)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int iterate_backrefs(u64 ino, u64 offset, u64 num_bytes, u64 root_id,\n\t\t\t    void *ctx_)\n{\n\tstruct backref_ctx *bctx = ctx_;\n\tstruct clone_root *clone_root;\n\n\t \n\tclone_root = bsearch((void *)(uintptr_t)root_id, bctx->sctx->clone_roots,\n\t\t\t     bctx->sctx->clone_roots_cnt,\n\t\t\t     sizeof(struct clone_root),\n\t\t\t     __clone_root_cmp_bsearch);\n\tif (!clone_root)\n\t\treturn 0;\n\n\t \n\tif (clone_root->root == bctx->sctx->send_root &&\n\t    ino == bctx->cur_objectid &&\n\t    offset == bctx->cur_offset)\n\t\treturn 0;\n\n\t \n\tif (clone_root->root == bctx->sctx->send_root) {\n\t\t \n\t\tif (ino > bctx->cur_objectid)\n\t\t\treturn 0;\n\t\t \n\t\tif (ino == bctx->cur_objectid &&\n\t\t    offset + bctx->extent_len >\n\t\t    bctx->sctx->cur_inode_next_write_offset)\n\t\t\treturn 0;\n\t}\n\n\tbctx->found++;\n\tclone_root->found_ref = true;\n\n\t \n\tif (num_bytes > clone_root->num_bytes) {\n\t\tclone_root->ino = ino;\n\t\tclone_root->offset = offset;\n\t\tclone_root->num_bytes = num_bytes;\n\n\t\t \n\t\tif (num_bytes >= bctx->extent_len)\n\t\t\treturn BTRFS_ITERATE_EXTENT_INODES_STOP;\n\t}\n\n\treturn 0;\n}\n\nstatic bool lookup_backref_cache(u64 leaf_bytenr, void *ctx,\n\t\t\t\t const u64 **root_ids_ret, int *root_count_ret)\n{\n\tstruct backref_ctx *bctx = ctx;\n\tstruct send_ctx *sctx = bctx->sctx;\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tconst u64 key = leaf_bytenr >> fs_info->sectorsize_bits;\n\tstruct btrfs_lru_cache_entry *raw_entry;\n\tstruct backref_cache_entry *entry;\n\n\tif (btrfs_lru_cache_size(&sctx->backref_cache) == 0)\n\t\treturn false;\n\n\t \n\tif (fs_info->last_reloc_trans > sctx->backref_cache_last_reloc_trans) {\n\t\tbtrfs_lru_cache_clear(&sctx->backref_cache);\n\t\treturn false;\n\t}\n\n\traw_entry = btrfs_lru_cache_lookup(&sctx->backref_cache, key, 0);\n\tif (!raw_entry)\n\t\treturn false;\n\n\tentry = container_of(raw_entry, struct backref_cache_entry, entry);\n\t*root_ids_ret = entry->root_ids;\n\t*root_count_ret = entry->num_roots;\n\n\treturn true;\n}\n\nstatic void store_backref_cache(u64 leaf_bytenr, const struct ulist *root_ids,\n\t\t\t\tvoid *ctx)\n{\n\tstruct backref_ctx *bctx = ctx;\n\tstruct send_ctx *sctx = bctx->sctx;\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tstruct backref_cache_entry *new_entry;\n\tstruct ulist_iterator uiter;\n\tstruct ulist_node *node;\n\tint ret;\n\n\t \n\tnew_entry = kmalloc(sizeof(struct backref_cache_entry), GFP_NOFS);\n\t \n\tif (!new_entry)\n\t\treturn;\n\n\tnew_entry->entry.key = leaf_bytenr >> fs_info->sectorsize_bits;\n\tnew_entry->entry.gen = 0;\n\tnew_entry->num_roots = 0;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((node = ulist_next(root_ids, &uiter)) != NULL) {\n\t\tconst u64 root_id = node->val;\n\t\tstruct clone_root *root;\n\n\t\troot = bsearch((void *)(uintptr_t)root_id, sctx->clone_roots,\n\t\t\t       sctx->clone_roots_cnt, sizeof(struct clone_root),\n\t\t\t       __clone_root_cmp_bsearch);\n\t\tif (!root)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (new_entry->num_roots >= SEND_MAX_BACKREF_CACHE_ROOTS) {\n\t\t\tkfree(new_entry);\n\t\t\treturn;\n\t\t}\n\n\t\tnew_entry->root_ids[new_entry->num_roots] = root_id;\n\t\tnew_entry->num_roots++;\n\t}\n\n\t \n\tret = btrfs_lru_cache_store(&sctx->backref_cache, &new_entry->entry,\n\t\t\t\t    GFP_NOFS);\n\tASSERT(ret == 0 || ret == -ENOMEM);\n\tif (ret) {\n\t\t \n\t\tkfree(new_entry);\n\t\treturn;\n\t}\n\n\t \n\tif (btrfs_lru_cache_size(&sctx->backref_cache) == 1)\n\t\tsctx->backref_cache_last_reloc_trans = fs_info->last_reloc_trans;\n}\n\nstatic int check_extent_item(u64 bytenr, const struct btrfs_extent_item *ei,\n\t\t\t     const struct extent_buffer *leaf, void *ctx)\n{\n\tconst u64 refs = btrfs_extent_refs(leaf, ei);\n\tconst struct backref_ctx *bctx = ctx;\n\tconst struct send_ctx *sctx = bctx->sctx;\n\n\tif (bytenr == bctx->bytenr) {\n\t\tconst u64 flags = btrfs_extent_flags(leaf, ei);\n\n\t\tif (WARN_ON(flags & BTRFS_EXTENT_FLAG_TREE_BLOCK))\n\t\t\treturn -EUCLEAN;\n\n\t\t \n\t\tif (refs == 1 && sctx->clone_roots_cnt == 1)\n\t\t\treturn -ENOENT;\n\t}\n\n\t \n\tif (refs > SEND_MAX_EXTENT_REFS)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nstatic bool skip_self_data_ref(u64 root, u64 ino, u64 offset, void *ctx)\n{\n\tconst struct backref_ctx *bctx = ctx;\n\n\tif (ino == bctx->cur_objectid &&\n\t    root == bctx->backref_owner &&\n\t    offset == bctx->backref_offset)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int find_extent_clone(struct send_ctx *sctx,\n\t\t\t     struct btrfs_path *path,\n\t\t\t     u64 ino, u64 data_offset,\n\t\t\t     u64 ino_size,\n\t\t\t     struct clone_root **found)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret;\n\tint extent_type;\n\tu64 logical;\n\tu64 disk_byte;\n\tu64 num_bytes;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct backref_ctx backref_ctx = { 0 };\n\tstruct btrfs_backref_walk_ctx backref_walk_ctx = { 0 };\n\tstruct clone_root *cur_clone_root;\n\tint compressed;\n\tu32 i;\n\n\t \n\tif (data_offset >= ino_size)\n\t\treturn 0;\n\n\tfi = btrfs_item_ptr(eb, path->slots[0], struct btrfs_file_extent_item);\n\textent_type = btrfs_file_extent_type(eb, fi);\n\tif (extent_type == BTRFS_FILE_EXTENT_INLINE)\n\t\treturn -ENOENT;\n\n\tdisk_byte = btrfs_file_extent_disk_bytenr(eb, fi);\n\tif (disk_byte == 0)\n\t\treturn -ENOENT;\n\n\tcompressed = btrfs_file_extent_compression(eb, fi);\n\tnum_bytes = btrfs_file_extent_num_bytes(eb, fi);\n\tlogical = disk_byte + btrfs_file_extent_offset(eb, fi);\n\n\t \n\tfor (i = 0; i < sctx->clone_roots_cnt; i++) {\n\t\tcur_clone_root = sctx->clone_roots + i;\n\t\tcur_clone_root->ino = (u64)-1;\n\t\tcur_clone_root->offset = 0;\n\t\tcur_clone_root->num_bytes = 0;\n\t\tcur_clone_root->found_ref = false;\n\t}\n\n\tbackref_ctx.sctx = sctx;\n\tbackref_ctx.cur_objectid = ino;\n\tbackref_ctx.cur_offset = data_offset;\n\tbackref_ctx.bytenr = disk_byte;\n\t \n\tbackref_ctx.backref_owner = btrfs_header_owner(eb);\n\tbackref_ctx.backref_offset = data_offset - btrfs_file_extent_offset(eb, fi);\n\n\t \n\tif (data_offset + num_bytes >= ino_size)\n\t\tbackref_ctx.extent_len = ino_size - data_offset;\n\telse\n\t\tbackref_ctx.extent_len = num_bytes;\n\n\t \n\tbackref_walk_ctx.bytenr = disk_byte;\n\tif (compressed == BTRFS_COMPRESS_NONE)\n\t\tbackref_walk_ctx.extent_item_pos = btrfs_file_extent_offset(eb, fi);\n\tbackref_walk_ctx.fs_info = fs_info;\n\tbackref_walk_ctx.cache_lookup = lookup_backref_cache;\n\tbackref_walk_ctx.cache_store = store_backref_cache;\n\tbackref_walk_ctx.indirect_ref_iterator = iterate_backrefs;\n\tbackref_walk_ctx.check_extent_item = check_extent_item;\n\tbackref_walk_ctx.user_ctx = &backref_ctx;\n\n\t \n\tif (sctx->clone_roots_cnt == 1)\n\t\tbackref_walk_ctx.skip_data_ref = skip_self_data_ref;\n\n\tret = iterate_extent_inodes(&backref_walk_ctx, true, iterate_backrefs,\n\t\t\t\t    &backref_ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdown_read(&fs_info->commit_root_sem);\n\tif (fs_info->last_reloc_trans > sctx->last_reloc_trans) {\n\t\t \n\t\tup_read(&fs_info->commit_root_sem);\n\t\treturn -ENOENT;\n\t}\n\tup_read(&fs_info->commit_root_sem);\n\n\tbtrfs_debug(fs_info,\n\t\t    \"find_extent_clone: data_offset=%llu, ino=%llu, num_bytes=%llu, logical=%llu\",\n\t\t    data_offset, ino, num_bytes, logical);\n\n\tif (!backref_ctx.found) {\n\t\tbtrfs_debug(fs_info, \"no clones found\");\n\t\treturn -ENOENT;\n\t}\n\n\tcur_clone_root = NULL;\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++) {\n\t\tstruct clone_root *clone_root = &sctx->clone_roots[i];\n\n\t\tif (!clone_root->found_ref)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!cur_clone_root ||\n\t\t    clone_root->num_bytes > cur_clone_root->num_bytes) {\n\t\t\tcur_clone_root = clone_root;\n\n\t\t\t \n\t\t\tif (clone_root->num_bytes >= backref_ctx.extent_len)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cur_clone_root) {\n\t\t*found = cur_clone_root;\n\t\tret = 0;\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\n\treturn ret;\n}\n\nstatic int read_symlink(struct btrfs_root *root,\n\t\t\tu64 ino,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_file_extent_item *ei;\n\tu8 type;\n\tu8 compression;\n\tunsigned long off;\n\tint len;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\t \n\t\tbtrfs_err(root->fs_info,\n\t\t\t  \"Found empty symlink inode %llu at root %llu\",\n\t\t\t  ino, root->root_key.objectid);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\tstruct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], ei);\n\tif (unlikely(type != BTRFS_FILE_EXTENT_INLINE)) {\n\t\tret = -EUCLEAN;\n\t\tbtrfs_crit(root->fs_info,\n\"send: found symlink extent that is not inline, ino %llu root %llu extent type %d\",\n\t\t\t   ino, btrfs_root_id(root), type);\n\t\tgoto out;\n\t}\n\tcompression = btrfs_file_extent_compression(path->nodes[0], ei);\n\tif (unlikely(compression != BTRFS_COMPRESS_NONE)) {\n\t\tret = -EUCLEAN;\n\t\tbtrfs_crit(root->fs_info,\n\"send: found symlink extent with compression, ino %llu root %llu compression type %d\",\n\t\t\t   ino, btrfs_root_id(root), compression);\n\t\tgoto out;\n\t}\n\n\toff = btrfs_file_extent_inline_start(ei);\n\tlen = btrfs_file_extent_ram_bytes(path->nodes[0], ei);\n\n\tret = fs_path_add_from_extent_buffer(dest, path->nodes[0], off, len);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nstatic int gen_unique_name(struct send_ctx *sctx,\n\t\t\t   u64 ino, u64 gen,\n\t\t\t   struct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tchar tmp[64];\n\tint len;\n\tu64 idx = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tstruct fscrypt_str tmp_name;\n\n\t\tlen = snprintf(tmp, sizeof(tmp), \"o%llu-%llu-%llu\",\n\t\t\t\tino, gen, idx);\n\t\tASSERT(len < sizeof(tmp));\n\t\ttmp_name.name = tmp;\n\t\ttmp_name.len = strlen(tmp);\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->send_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\t&tmp_name, 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t \n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sctx->parent_root) {\n\t\t\t \n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->parent_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\t&tmp_name, 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t \n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tbreak;\n\t}\n\n\tret = fs_path_add(dest, tmp, strlen(tmp));\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nenum inode_state {\n\tinode_state_no_change,\n\tinode_state_will_create,\n\tinode_state_did_create,\n\tinode_state_will_delete,\n\tinode_state_did_delete,\n};\n\nstatic int get_cur_inode_state(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\t       u64 *send_gen, u64 *parent_gen)\n{\n\tint ret;\n\tint left_ret;\n\tint right_ret;\n\tu64 left_gen;\n\tu64 right_gen = 0;\n\tstruct btrfs_inode_info info;\n\n\tret = get_inode_info(sctx->send_root, ino, &info);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tleft_ret = (info.nlink == 0) ? -ENOENT : ret;\n\tleft_gen = info.gen;\n\tif (send_gen)\n\t\t*send_gen = ((left_ret == -ENOENT) ? 0 : info.gen);\n\n\tif (!sctx->parent_root) {\n\t\tright_ret = -ENOENT;\n\t} else {\n\t\tret = get_inode_info(sctx->parent_root, ino, &info);\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tgoto out;\n\t\tright_ret = (info.nlink == 0) ? -ENOENT : ret;\n\t\tright_gen = info.gen;\n\t\tif (parent_gen)\n\t\t\t*parent_gen = ((right_ret == -ENOENT) ? 0 : info.gen);\n\t}\n\n\tif (!left_ret && !right_ret) {\n\t\tif (left_gen == gen && right_gen == gen) {\n\t\t\tret = inode_state_no_change;\n\t\t} else if (left_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_create;\n\t\t\telse\n\t\t\t\tret = inode_state_will_create;\n\t\t} else if (right_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_delete;\n\t\t\telse\n\t\t\t\tret = inode_state_will_delete;\n\t\t} else  {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else if (!left_ret) {\n\t\tif (left_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_create;\n\t\t\telse\n\t\t\t\tret = inode_state_will_create;\n\t\t} else {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else if (!right_ret) {\n\t\tif (right_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_delete;\n\t\t\telse\n\t\t\t\tret = inode_state_will_delete;\n\t\t} else {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int is_inode_existent(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\t     u64 *send_gen, u64 *parent_gen)\n{\n\tint ret;\n\n\tif (ino == BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\n\tret = get_cur_inode_state(sctx, ino, gen, send_gen, parent_gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret == inode_state_no_change ||\n\t    ret == inode_state_did_create ||\n\t    ret == inode_state_will_delete)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}\n\n \nstatic int lookup_dir_item_inode(struct btrfs_root *root,\n\t\t\t\t u64 dir, const char *name, int name_len,\n\t\t\t\t u64 *found_inode)\n{\n\tint ret = 0;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct fscrypt_str name_str = FSTR_INIT((char *)name, name_len);\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tdi = btrfs_lookup_dir_item(NULL, root, path, dir, &name_str, 0);\n\tif (IS_ERR_OR_NULL(di)) {\n\t\tret = di ? PTR_ERR(di) : -ENOENT;\n\t\tgoto out;\n\t}\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &key);\n\tif (key.type == BTRFS_ROOT_ITEM_KEY) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t*found_inode = key.objectid;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nstatic int get_first_ref(struct btrfs_root *root, u64 ino,\n\t\t\t u64 *dir, u64 *dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tint len;\n\tu64 parent_dir;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\tpath->slots[0]);\n\tif (ret || found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (found_key.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *iref;\n\t\tiref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(path->nodes[0], iref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t\t     (unsigned long)(iref + 1),\n\t\t\t\t\t\t     len);\n\t\tparent_dir = found_key.offset;\n\t} else {\n\t\tstruct btrfs_inode_extref *extref;\n\t\textref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_extref);\n\t\tlen = btrfs_inode_extref_name_len(path->nodes[0], extref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t(unsigned long)&extref->name, len);\n\t\tparent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tif (dir_gen) {\n\t\tret = get_inode_gen(root, parent_dir, dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*dir = parent_dir;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int is_first_ref(struct btrfs_root *root,\n\t\t\tu64 ino, u64 dir,\n\t\t\tconst char *name, int name_len)\n{\n\tint ret;\n\tstruct fs_path *tmp_name;\n\tu64 tmp_dir;\n\n\ttmp_name = fs_path_alloc();\n\tif (!tmp_name)\n\t\treturn -ENOMEM;\n\n\tret = get_first_ref(root, ino, &tmp_dir, NULL, tmp_name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (dir != tmp_dir || name_len != fs_path_len(tmp_name)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = !memcmp(tmp_name->start, name, name_len);\n\nout:\n\tfs_path_free(tmp_name);\n\treturn ret;\n}\n\n \nstatic int will_overwrite_ref(struct send_ctx *sctx, u64 dir, u64 dir_gen,\n\t\t\t      const char *name, int name_len,\n\t\t\t      u64 *who_ino, u64 *who_gen, u64 *who_mode)\n{\n\tint ret;\n\tu64 parent_root_dir_gen;\n\tu64 other_inode = 0;\n\tstruct btrfs_inode_info info;\n\n\tif (!sctx->parent_root)\n\t\treturn 0;\n\n\tret = is_inode_existent(sctx, dir, dir_gen, NULL, &parent_root_dir_gen);\n\tif (ret <= 0)\n\t\treturn 0;\n\n\t \n\tif (sctx->parent_root && dir != BTRFS_FIRST_FREE_OBJECTID &&\n\t    parent_root_dir_gen != dir_gen)\n\t\treturn 0;\n\n\tret = lookup_dir_item_inode(sctx->parent_root, dir, name, name_len,\n\t\t\t\t    &other_inode);\n\tif (ret == -ENOENT)\n\t\treturn 0;\n\telse if (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (other_inode > sctx->send_progress ||\n\t    is_waiting_for_move(sctx, other_inode)) {\n\t\tret = get_inode_info(sctx->parent_root, other_inode, &info);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*who_ino = other_inode;\n\t\t*who_gen = info.gen;\n\t\t*who_mode = info.mode;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int did_overwrite_ref(struct send_ctx *sctx,\n\t\t\t    u64 dir, u64 dir_gen,\n\t\t\t    u64 ino, u64 ino_gen,\n\t\t\t    const char *name, int name_len)\n{\n\tint ret;\n\tu64 ow_inode;\n\tu64 ow_gen = 0;\n\tu64 send_root_dir_gen;\n\n\tif (!sctx->parent_root)\n\t\treturn 0;\n\n\tret = is_inode_existent(sctx, dir, dir_gen, &send_root_dir_gen, NULL);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\t \n\tif (dir != BTRFS_FIRST_FREE_OBJECTID && send_root_dir_gen != dir_gen)\n\t\treturn 0;\n\n\t \n\tret = lookup_dir_item_inode(sctx->send_root, dir, name, name_len,\n\t\t\t\t    &ow_inode);\n\tif (ret == -ENOENT) {\n\t\t \n\t\treturn 0;\n\t} else if (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (ow_inode == ino) {\n\t\tret = get_inode_gen(sctx->send_root, ow_inode, &ow_gen);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (ow_gen == ino_gen)\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (ow_inode < sctx->send_progress)\n\t\treturn 1;\n\n\tif (ino != sctx->cur_ino && ow_inode == sctx->cur_ino) {\n\t\tif (ow_gen == 0) {\n\t\t\tret = get_inode_gen(sctx->send_root, ow_inode, &ow_gen);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (ow_gen == sctx->cur_inode_gen)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int did_overwrite_first_ref(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 dir;\n\tu64 dir_gen;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tname = fs_path_alloc();\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tret = get_first_ref(sctx->parent_root, ino, &dir, &dir_gen, name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = did_overwrite_ref(sctx, dir, dir_gen, ino, gen,\n\t\t\tname->start, fs_path_len(name));\n\nout:\n\tfs_path_free(name);\n\treturn ret;\n}\n\nstatic inline struct name_cache_entry *name_cache_search(struct send_ctx *sctx,\n\t\t\t\t\t\t\t u64 ino, u64 gen)\n{\n\tstruct btrfs_lru_cache_entry *entry;\n\n\tentry = btrfs_lru_cache_lookup(&sctx->name_cache, ino, gen);\n\tif (!entry)\n\t\treturn NULL;\n\n\treturn container_of(entry, struct name_cache_entry, entry);\n}\n\n \nstatic int __get_cur_name_and_parent(struct send_ctx *sctx,\n\t\t\t\t     u64 ino, u64 gen,\n\t\t\t\t     u64 *parent_ino,\n\t\t\t\t     u64 *parent_gen,\n\t\t\t\t     struct fs_path *dest)\n{\n\tint ret;\n\tint nce_ret;\n\tstruct name_cache_entry *nce;\n\n\t \n\tnce = name_cache_search(sctx, ino, gen);\n\tif (nce) {\n\t\tif (ino < sctx->send_progress && nce->need_later_update) {\n\t\t\tbtrfs_lru_cache_remove(&sctx->name_cache, &nce->entry);\n\t\t\tnce = NULL;\n\t\t} else {\n\t\t\t*parent_ino = nce->parent_ino;\n\t\t\t*parent_gen = nce->parent_gen;\n\t\t\tret = fs_path_add(dest, nce->name, nce->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = nce->ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tret = is_inode_existent(sctx, ino, gen, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!ret) {\n\t\tret = gen_unique_name(sctx, ino, gen, dest);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 1;\n\t\tgoto out_cache;\n\t}\n\n\t \n\tif (ino < sctx->send_progress)\n\t\tret = get_first_ref(sctx->send_root, ino,\n\t\t\t\t    parent_ino, parent_gen, dest);\n\telse\n\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t    parent_ino, parent_gen, dest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = did_overwrite_ref(sctx, *parent_ino, *parent_gen, ino, gen,\n\t\t\tdest->start, dest->end - dest->start);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tfs_path_reset(dest);\n\t\tret = gen_unique_name(sctx, ino, gen, dest);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 1;\n\t}\n\nout_cache:\n\t \n\tnce = kmalloc(sizeof(*nce) + fs_path_len(dest) + 1, GFP_KERNEL);\n\tif (!nce) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnce->entry.key = ino;\n\tnce->entry.gen = gen;\n\tnce->parent_ino = *parent_ino;\n\tnce->parent_gen = *parent_gen;\n\tnce->name_len = fs_path_len(dest);\n\tnce->ret = ret;\n\tstrcpy(nce->name, dest->start);\n\n\tif (ino < sctx->send_progress)\n\t\tnce->need_later_update = 0;\n\telse\n\t\tnce->need_later_update = 1;\n\n\tnce_ret = btrfs_lru_cache_store(&sctx->name_cache, &nce->entry, GFP_KERNEL);\n\tif (nce_ret < 0) {\n\t\tkfree(nce);\n\t\tret = nce_ret;\n\t}\n\nout:\n\treturn ret;\n}\n\n \nstatic int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tstruct waiting_dir_move *wdm;\n\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino, gen)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\twdm = get_waiting_dir_move(sctx, ino);\n\t\tif (wdm && wdm->orphanized) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tstop = 1;\n\t\t} else if (wdm) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}\n\n \nstatic int send_subvol_begin(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *send_root = sctx->send_root;\n\tstruct btrfs_root *parent_root = sctx->parent_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_root_ref *ref;\n\tstruct extent_buffer *leaf;\n\tchar *name = NULL;\n\tint namelen;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tname = kmalloc(BTRFS_PATH_NAME_MAX, GFP_KERNEL);\n\tif (!name) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\tkey.objectid = send_root->root_key.objectid;\n\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(send_root->fs_info->tree_root,\n\t\t\t\t&key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tif (key.type != BTRFS_ROOT_BACKREF_KEY ||\n\t    key.objectid != send_root->root_key.objectid) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tref = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_root_ref);\n\tnamelen = btrfs_root_ref_name_len(leaf, ref);\n\tread_extent_buffer(leaf, name, (unsigned long)(ref + 1), namelen);\n\tbtrfs_release_path(path);\n\n\tif (parent_root) {\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_SNAPSHOT);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_SUBVOL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tTLV_PUT_STRING(sctx, BTRFS_SEND_A_PATH, name, namelen);\n\n\tif (!btrfs_is_empty_uuid(sctx->send_root->root_item.received_uuid))\n\t\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_UUID,\n\t\t\t    sctx->send_root->root_item.received_uuid);\n\telse\n\t\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_UUID,\n\t\t\t    sctx->send_root->root_item.uuid);\n\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CTRANSID,\n\t\t    btrfs_root_ctransid(&sctx->send_root->root_item));\n\tif (parent_root) {\n\t\tif (!btrfs_is_empty_uuid(parent_root->root_item.received_uuid))\n\t\t\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_CLONE_UUID,\n\t\t\t\t     parent_root->root_item.received_uuid);\n\t\telse\n\t\t\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_CLONE_UUID,\n\t\t\t\t     parent_root->root_item.uuid);\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_CTRANSID,\n\t\t\t    btrfs_root_ctransid(&sctx->parent_root->root_item));\n\t}\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tbtrfs_free_path(path);\n\tkfree(name);\n\treturn ret;\n}\n\nstatic int send_truncate(struct send_ctx *sctx, u64 ino, u64 gen, u64 size)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret = 0;\n\tstruct fs_path *p;\n\n\tbtrfs_debug(fs_info, \"send_truncate %llu size=%llu\", ino, size);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_TRUNCATE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_SIZE, size);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\nstatic int send_chmod(struct send_ctx *sctx, u64 ino, u64 gen, u64 mode)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret = 0;\n\tstruct fs_path *p;\n\n\tbtrfs_debug(fs_info, \"send_chmod %llu mode=%llu\", ino, mode);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CHMOD);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_MODE, mode & 07777);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\nstatic int send_fileattr(struct send_ctx *sctx, u64 ino, u64 gen, u64 fileattr)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret = 0;\n\tstruct fs_path *p;\n\n\tif (sctx->proto < 2)\n\t\treturn 0;\n\n\tbtrfs_debug(fs_info, \"send_fileattr %llu fileattr=%llu\", ino, fileattr);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_FILEATTR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILEATTR, fileattr);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\nstatic int send_chown(struct send_ctx *sctx, u64 ino, u64 gen, u64 uid, u64 gid)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret = 0;\n\tstruct fs_path *p;\n\n\tbtrfs_debug(fs_info, \"send_chown %llu uid=%llu, gid=%llu\",\n\t\t    ino, uid, gid);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CHOWN);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_UID, uid);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_GID, gid);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\nstatic int send_utimes(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret = 0;\n\tstruct fs_path *p = NULL;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_key key;\n\tint slot;\n\n\tbtrfs_debug(fs_info, \"send_utimes %llu\", ino);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\tif (ret < 0)\n\t\tgoto out;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tii = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UTIMES);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_ATIME, eb, &ii->atime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_MTIME, eb, &ii->mtime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_CTIME, eb, &ii->ctime);\n\tif (sctx->proto >= 2)\n\t\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_OTIME, eb, &ii->otime);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nstatic int cache_dir_utimes(struct send_ctx *sctx, u64 dir, u64 gen)\n{\n\tstruct btrfs_lru_cache_entry *entry;\n\tint ret;\n\n\tentry = btrfs_lru_cache_lookup(&sctx->dir_utimes_cache, dir, gen);\n\tif (entry != NULL)\n\t\treturn 0;\n\n\t \n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn send_utimes(sctx, dir, gen);\n\n\tentry->key = dir;\n\tentry->gen = gen;\n\n\tret = btrfs_lru_cache_store(&sctx->dir_utimes_cache, entry, GFP_KERNEL);\n\tASSERT(ret != -EEXIST);\n\tif (ret) {\n\t\tkfree(entry);\n\t\treturn send_utimes(sctx, dir, gen);\n\t}\n\n\treturn 0;\n}\n\nstatic int trim_dir_utimes_cache(struct send_ctx *sctx)\n{\n\twhile (btrfs_lru_cache_size(&sctx->dir_utimes_cache) >\n\t       SEND_MAX_DIR_UTIMES_CACHE_SIZE) {\n\t\tstruct btrfs_lru_cache_entry *lru;\n\t\tint ret;\n\n\t\tlru = btrfs_lru_cache_lru_entry(&sctx->dir_utimes_cache);\n\t\tASSERT(lru != NULL);\n\n\t\tret = send_utimes(sctx, lru->key, lru->gen);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbtrfs_lru_cache_remove(&sctx->dir_utimes_cache, lru);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int send_create_inode(struct send_ctx *sctx, u64 ino)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret = 0;\n\tstruct fs_path *p;\n\tint cmd;\n\tstruct btrfs_inode_info info;\n\tu64 gen;\n\tu64 mode;\n\tu64 rdev;\n\n\tbtrfs_debug(fs_info, \"send_create_inode %llu\", ino);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tif (ino != sctx->cur_ino) {\n\t\tret = get_inode_info(sctx->send_root, ino, &info);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tgen = info.gen;\n\t\tmode = info.mode;\n\t\trdev = info.rdev;\n\t} else {\n\t\tgen = sctx->cur_inode_gen;\n\t\tmode = sctx->cur_inode_mode;\n\t\trdev = sctx->cur_inode_rdev;\n\t}\n\n\tif (S_ISREG(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKFILE;\n\t} else if (S_ISDIR(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKDIR;\n\t} else if (S_ISLNK(mode)) {\n\t\tcmd = BTRFS_SEND_C_SYMLINK;\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKNOD;\n\t} else if (S_ISFIFO(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKFIFO;\n\t} else if (S_ISSOCK(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKSOCK;\n\t} else {\n\t\tbtrfs_warn(sctx->send_root->fs_info, \"unexpected inode type %o\",\n\t\t\t\t(int)(mode & S_IFMT));\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = begin_cmd(sctx, cmd);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = gen_unique_name(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_INO, ino);\n\n\tif (S_ISLNK(mode)) {\n\t\tfs_path_reset(p);\n\t\tret = read_symlink(sctx->send_root, ino, p);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_LINK, p);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) ||\n\t\t   S_ISFIFO(mode) || S_ISSOCK(mode)) {\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_RDEV, new_encode_dev(rdev));\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_MODE, mode);\n\t}\n\n\tret = send_cmd(sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\nstatic void cache_dir_created(struct send_ctx *sctx, u64 dir)\n{\n\tstruct btrfs_lru_cache_entry *entry;\n\tint ret;\n\n\t \n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn;\n\n\tentry->key = dir;\n\tentry->gen = 0;\n\tret = btrfs_lru_cache_store(&sctx->dir_created_cache, entry, GFP_KERNEL);\n\tif (ret < 0)\n\t\tkfree(entry);\n}\n\n \nstatic int did_create_dir(struct send_ctx *sctx, u64 dir)\n{\n\tint ret = 0;\n\tint iter_ret = 0;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key di_key;\n\tstruct btrfs_dir_item *di;\n\n\tif (btrfs_lru_cache_lookup(&sctx->dir_created_cache, dir, 0))\n\t\treturn 1;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = 0;\n\n\tbtrfs_for_each_slot(sctx->send_root, &key, &found_key, path, iter_ret) {\n\t\tstruct extent_buffer *eb = path->nodes[0];\n\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdi = btrfs_item_ptr(eb, path->slots[0], struct btrfs_dir_item);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (di_key.type != BTRFS_ROOT_ITEM_KEY &&\n\t\t    di_key.objectid < sctx->send_progress) {\n\t\t\tret = 1;\n\t\t\tcache_dir_created(sctx, dir);\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (iter_ret < 0)\n\t\tret = iter_ret;\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nstatic int send_create_inode_if_needed(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tif (S_ISDIR(sctx->cur_inode_mode)) {\n\t\tret = did_create_dir(sctx, sctx->cur_ino);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret > 0)\n\t\t\treturn 0;\n\t}\n\n\tret = send_create_inode(sctx, sctx->cur_ino);\n\n\tif (ret == 0 && S_ISDIR(sctx->cur_inode_mode))\n\t\tcache_dir_created(sctx, sctx->cur_ino);\n\n\treturn ret;\n}\n\nstruct recorded_ref {\n\tstruct list_head list;\n\tchar *name;\n\tstruct fs_path *full_path;\n\tu64 dir;\n\tu64 dir_gen;\n\tint name_len;\n\tstruct rb_node node;\n\tstruct rb_root *root;\n};\n\nstatic struct recorded_ref *recorded_ref_alloc(void)\n{\n\tstruct recorded_ref *ref;\n\n\tref = kzalloc(sizeof(*ref), GFP_KERNEL);\n\tif (!ref)\n\t\treturn NULL;\n\tRB_CLEAR_NODE(&ref->node);\n\tINIT_LIST_HEAD(&ref->list);\n\treturn ref;\n}\n\nstatic void recorded_ref_free(struct recorded_ref *ref)\n{\n\tif (!ref)\n\t\treturn;\n\tif (!RB_EMPTY_NODE(&ref->node))\n\t\trb_erase(&ref->node, ref->root);\n\tlist_del(&ref->list);\n\tfs_path_free(ref->full_path);\n\tkfree(ref);\n}\n\nstatic void set_ref_path(struct recorded_ref *ref, struct fs_path *path)\n{\n\tref->full_path = path;\n\tref->name = (char *)kbasename(ref->full_path->start);\n\tref->name_len = ref->full_path->end - ref->name;\n}\n\nstatic int dup_ref(struct recorded_ref *ref, struct list_head *list)\n{\n\tstruct recorded_ref *new;\n\n\tnew = recorded_ref_alloc();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->dir = ref->dir;\n\tnew->dir_gen = ref->dir_gen;\n\tlist_add_tail(&new->list, list);\n\treturn 0;\n}\n\nstatic void __free_recorded_refs(struct list_head *head)\n{\n\tstruct recorded_ref *cur;\n\n\twhile (!list_empty(head)) {\n\t\tcur = list_entry(head->next, struct recorded_ref, list);\n\t\trecorded_ref_free(cur);\n\t}\n}\n\nstatic void free_recorded_refs(struct send_ctx *sctx)\n{\n\t__free_recorded_refs(&sctx->new_refs);\n\t__free_recorded_refs(&sctx->deleted_refs);\n}\n\n \nstatic int orphanize_inode(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\t  struct fs_path *path)\n{\n\tint ret;\n\tstruct fs_path *orphan;\n\n\torphan = fs_path_alloc();\n\tif (!orphan)\n\t\treturn -ENOMEM;\n\n\tret = gen_unique_name(sctx, ino, gen, orphan);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_rename(sctx, path, orphan);\n\nout:\n\tfs_path_free(orphan);\n\treturn ret;\n}\n\nstatic struct orphan_dir_info *add_orphan_dir_info(struct send_ctx *sctx,\n\t\t\t\t\t\t   u64 dir_ino, u64 dir_gen)\n{\n\tstruct rb_node **p = &sctx->orphan_dirs.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct orphan_dir_info *entry, *odi;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct orphan_dir_info, node);\n\t\tif (dir_ino < entry->ino)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (dir_ino > entry->ino)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (dir_gen < entry->gen)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (dir_gen > entry->gen)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\n\todi = kmalloc(sizeof(*odi), GFP_KERNEL);\n\tif (!odi)\n\t\treturn ERR_PTR(-ENOMEM);\n\todi->ino = dir_ino;\n\todi->gen = dir_gen;\n\todi->last_dir_index_offset = 0;\n\todi->dir_high_seq_ino = 0;\n\n\trb_link_node(&odi->node, parent, p);\n\trb_insert_color(&odi->node, &sctx->orphan_dirs);\n\treturn odi;\n}\n\nstatic struct orphan_dir_info *get_orphan_dir_info(struct send_ctx *sctx,\n\t\t\t\t\t\t   u64 dir_ino, u64 gen)\n{\n\tstruct rb_node *n = sctx->orphan_dirs.rb_node;\n\tstruct orphan_dir_info *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct orphan_dir_info, node);\n\t\tif (dir_ino < entry->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (dir_ino > entry->ino)\n\t\t\tn = n->rb_right;\n\t\telse if (gen < entry->gen)\n\t\t\tn = n->rb_left;\n\t\telse if (gen > entry->gen)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}\n\nstatic int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino, u64 gen)\n{\n\tstruct orphan_dir_info *odi = get_orphan_dir_info(sctx, dir_ino, gen);\n\n\treturn odi != NULL;\n}\n\nstatic void free_orphan_dir_info(struct send_ctx *sctx,\n\t\t\t\t struct orphan_dir_info *odi)\n{\n\tif (!odi)\n\t\treturn;\n\trb_erase(&odi->node, &sctx->orphan_dirs);\n\tkfree(odi);\n}\n\n \nstatic int can_rmdir(struct send_ctx *sctx, u64 dir, u64 dir_gen)\n{\n\tint ret = 0;\n\tint iter_ret = 0;\n\tstruct btrfs_root *root = sctx->parent_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key loc;\n\tstruct btrfs_dir_item *di;\n\tstruct orphan_dir_info *odi = NULL;\n\tu64 dir_high_seq_ino = 0;\n\tu64 last_dir_index_offset = 0;\n\n\t \n\tif (dir == BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 0;\n\n\todi = get_orphan_dir_info(sctx, dir, dir_gen);\n\tif (odi && sctx->cur_ino < odi->dir_high_seq_ino)\n\t\treturn 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (!odi) {\n\t\t \n\t\tkey.objectid = dir;\n\t\tkey.type = BTRFS_DIR_INDEX_KEY;\n\t\tkey.offset = (u64)-1;\n\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0) {\n\t\t\tgoto out;\n\t\t} else if (ret > 0) {\n\t\t\t \n\t\t\tASSERT(path->slots[0] > 0);\n\t\t\tif (WARN_ON(path->slots[0] == 0)) {\n\t\t\t\tret = -EUCLEAN;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\t\tif (key.objectid != dir || key.type != BTRFS_DIR_INDEX_KEY) {\n\t\t\t \n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_dir_item);\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &loc);\n\t\tdir_high_seq_ino = loc.objectid;\n\t\tif (sctx->cur_ino < dir_high_seq_ino) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbtrfs_release_path(path);\n\t}\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = (odi ? odi->last_dir_index_offset : 0);\n\n\tbtrfs_for_each_slot(root, &key, &found_key, path, iter_ret) {\n\t\tstruct waiting_dir_move *dm;\n\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type)\n\t\t\tbreak;\n\n\t\tdi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\tstruct btrfs_dir_item);\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &loc);\n\n\t\tdir_high_seq_ino = max(dir_high_seq_ino, loc.objectid);\n\t\tlast_dir_index_offset = found_key.offset;\n\n\t\tdm = get_waiting_dir_move(sctx, loc.objectid);\n\t\tif (dm) {\n\t\t\tdm->rmdir_ino = dir;\n\t\t\tdm->rmdir_gen = dir_gen;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (loc.objectid > sctx->cur_ino) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (iter_ret < 0) {\n\t\tret = iter_ret;\n\t\tgoto out;\n\t}\n\tfree_orphan_dir_info(sctx, odi);\n\n\tret = 1;\n\nout:\n\tbtrfs_free_path(path);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (!odi) {\n\t\todi = add_orphan_dir_info(sctx, dir, dir_gen);\n\t\tif (IS_ERR(odi))\n\t\t\treturn PTR_ERR(odi);\n\n\t\todi->gen = dir_gen;\n\t}\n\n\todi->last_dir_index_offset = last_dir_index_offset;\n\todi->dir_high_seq_ino = max(odi->dir_high_seq_ino, dir_high_seq_ino);\n\n\treturn 0;\n}\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct waiting_dir_move *entry = get_waiting_dir_move(sctx, ino);\n\n\treturn entry != NULL;\n}\n\nstatic int add_waiting_dir_move(struct send_ctx *sctx, u64 ino, bool orphanized)\n{\n\tstruct rb_node **p = &sctx->waiting_dir_moves.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct waiting_dir_move *entry, *dm;\n\n\tdm = kmalloc(sizeof(*dm), GFP_KERNEL);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\tdm->ino = ino;\n\tdm->rmdir_ino = 0;\n\tdm->rmdir_gen = 0;\n\tdm->orphanized = orphanized;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct waiting_dir_move, node);\n\t\tif (ino < entry->ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (ino > entry->ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tkfree(dm);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&dm->node, parent, p);\n\trb_insert_color(&dm->node, &sctx->waiting_dir_moves);\n\treturn 0;\n}\n\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct rb_node *n = sctx->waiting_dir_moves.rb_node;\n\tstruct waiting_dir_move *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct waiting_dir_move, node);\n\t\tif (ino < entry->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (ino > entry->ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}\n\nstatic void free_waiting_dir_move(struct send_ctx *sctx,\n\t\t\t\t  struct waiting_dir_move *dm)\n{\n\tif (!dm)\n\t\treturn;\n\trb_erase(&dm->node, &sctx->waiting_dir_moves);\n\tkfree(dm);\n}\n\nstatic int add_pending_dir_move(struct send_ctx *sctx,\n\t\t\t\tu64 ino,\n\t\t\t\tu64 ino_gen,\n\t\t\t\tu64 parent_ino,\n\t\t\t\tstruct list_head *new_refs,\n\t\t\t\tstruct list_head *deleted_refs,\n\t\t\t\tconst bool is_orphan)\n{\n\tstruct rb_node **p = &sctx->pending_dir_moves.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pending_dir_move *entry = NULL, *pm;\n\tstruct recorded_ref *cur;\n\tint exists = 0;\n\tint ret;\n\n\tpm = kmalloc(sizeof(*pm), GFP_KERNEL);\n\tif (!pm)\n\t\treturn -ENOMEM;\n\tpm->parent_ino = parent_ino;\n\tpm->ino = ino;\n\tpm->gen = ino_gen;\n\tINIT_LIST_HEAD(&pm->list);\n\tINIT_LIST_HEAD(&pm->update_refs);\n\tRB_CLEAR_NODE(&pm->node);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct pending_dir_move, node);\n\t\tif (parent_ino < entry->parent_ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (parent_ino > entry->parent_ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\texists = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(cur, deleted_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry(cur, new_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = add_waiting_dir_move(sctx, pm->ino, is_orphan);\n\tif (ret)\n\t\tgoto out;\n\n\tif (exists) {\n\t\tlist_add_tail(&pm->list, &entry->list);\n\t} else {\n\t\trb_link_node(&pm->node, parent, p);\n\t\trb_insert_color(&pm->node, &sctx->pending_dir_moves);\n\t}\n\tret = 0;\nout:\n\tif (ret) {\n\t\t__free_recorded_refs(&pm->update_refs);\n\t\tkfree(pm);\n\t}\n\treturn ret;\n}\n\nstatic struct pending_dir_move *get_pending_dir_moves(struct send_ctx *sctx,\n\t\t\t\t\t\t      u64 parent_ino)\n{\n\tstruct rb_node *n = sctx->pending_dir_moves.rb_node;\n\tstruct pending_dir_move *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct pending_dir_move, node);\n\t\tif (parent_ino < entry->parent_ino)\n\t\t\tn = n->rb_left;\n\t\telse if (parent_ino > entry->parent_ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}\n\nstatic int path_loop(struct send_ctx *sctx, struct fs_path *name,\n\t\t     u64 ino, u64 gen, u64 *ancestor_ino)\n{\n\tint ret = 0;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tu64 start_ino = ino;\n\n\t*ancestor_ino = 0;\n\twhile (ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino, gen))\n\t\t\tbreak;\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tif (*ancestor_ino == 0)\n\t\t\t\t*ancestor_ino = ino;\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (parent_inode == start_ino) {\n\t\t\tret = 1;\n\t\t\tif (*ancestor_ino == 0)\n\t\t\t\t*ancestor_ino = ino;\n\t\t\tbreak;\n\t\t}\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\treturn ret;\n}\n\nstatic int apply_dir_move(struct send_ctx *sctx, struct pending_dir_move *pm)\n{\n\tstruct fs_path *from_path = NULL;\n\tstruct fs_path *to_path = NULL;\n\tstruct fs_path *name = NULL;\n\tu64 orig_progress = sctx->send_progress;\n\tstruct recorded_ref *cur;\n\tu64 parent_ino, parent_gen;\n\tstruct waiting_dir_move *dm = NULL;\n\tu64 rmdir_ino = 0;\n\tu64 rmdir_gen;\n\tu64 ancestor;\n\tbool is_orphan;\n\tint ret;\n\n\tname = fs_path_alloc();\n\tfrom_path = fs_path_alloc();\n\tif (!name || !from_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdm = get_waiting_dir_move(sctx, pm->ino);\n\tASSERT(dm);\n\trmdir_ino = dm->rmdir_ino;\n\trmdir_gen = dm->rmdir_gen;\n\tis_orphan = dm->orphanized;\n\tfree_waiting_dir_move(sctx, dm);\n\n\tif (is_orphan) {\n\t\tret = gen_unique_name(sctx, pm->ino,\n\t\t\t\t      pm->gen, from_path);\n\t} else {\n\t\tret = get_first_ref(sctx->parent_root, pm->ino,\n\t\t\t\t    &parent_ino, &parent_gen, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = get_cur_path(sctx, parent_ino, parent_gen,\n\t\t\t\t   from_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = fs_path_add_path(from_path, name);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsctx->send_progress = sctx->cur_ino + 1;\n\tret = path_loop(sctx, name, pm->ino, pm->gen, &ancestor);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tLIST_HEAD(deleted_refs);\n\t\tASSERT(ancestor > BTRFS_FIRST_FREE_OBJECTID);\n\t\tret = add_pending_dir_move(sctx, pm->ino, pm->gen, ancestor,\n\t\t\t\t\t   &pm->update_refs, &deleted_refs,\n\t\t\t\t\t   is_orphan);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (rmdir_ino) {\n\t\t\tdm = get_waiting_dir_move(sctx, pm->ino);\n\t\t\tASSERT(dm);\n\t\t\tdm->rmdir_ino = rmdir_ino;\n\t\t\tdm->rmdir_gen = rmdir_gen;\n\t\t}\n\t\tgoto out;\n\t}\n\tfs_path_reset(name);\n\tto_path = name;\n\tname = NULL;\n\tret = get_cur_path(sctx, pm->ino, pm->gen, to_path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_rename(sctx, from_path, to_path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (rmdir_ino) {\n\t\tstruct orphan_dir_info *odi;\n\t\tu64 gen;\n\n\t\todi = get_orphan_dir_info(sctx, rmdir_ino, rmdir_gen);\n\t\tif (!odi) {\n\t\t\t \n\t\t\tgoto finish;\n\t\t}\n\t\tgen = odi->gen;\n\n\t\tret = can_rmdir(sctx, rmdir_ino, gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (!ret)\n\t\t\tgoto finish;\n\n\t\tname = fs_path_alloc();\n\t\tif (!name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_cur_path(sctx, rmdir_ino, gen, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = send_rmdir(sctx, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nfinish:\n\tret = cache_dir_utimes(sctx, pm->ino, pm->gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tlist_for_each_entry(cur, &pm->update_refs, list) {\n\t\t \n\t\tret = get_inode_info(sctx->send_root, cur->dir, NULL);\n\t\tif (ret == -ENOENT) {\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = cache_dir_utimes(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tfs_path_free(name);\n\tfs_path_free(from_path);\n\tfs_path_free(to_path);\n\tsctx->send_progress = orig_progress;\n\n\treturn ret;\n}\n\nstatic void free_pending_move(struct send_ctx *sctx, struct pending_dir_move *m)\n{\n\tif (!list_empty(&m->list))\n\t\tlist_del(&m->list);\n\tif (!RB_EMPTY_NODE(&m->node))\n\t\trb_erase(&m->node, &sctx->pending_dir_moves);\n\t__free_recorded_refs(&m->update_refs);\n\tkfree(m);\n}\n\nstatic void tail_append_pending_moves(struct send_ctx *sctx,\n\t\t\t\t      struct pending_dir_move *moves,\n\t\t\t\t      struct list_head *stack)\n{\n\tif (list_empty(&moves->list)) {\n\t\tlist_add_tail(&moves->list, stack);\n\t} else {\n\t\tLIST_HEAD(list);\n\t\tlist_splice_init(&moves->list, &list);\n\t\tlist_add_tail(&moves->list, stack);\n\t\tlist_splice_tail(&list, stack);\n\t}\n\tif (!RB_EMPTY_NODE(&moves->node)) {\n\t\trb_erase(&moves->node, &sctx->pending_dir_moves);\n\t\tRB_CLEAR_NODE(&moves->node);\n\t}\n}\n\nstatic int apply_children_dir_moves(struct send_ctx *sctx)\n{\n\tstruct pending_dir_move *pm;\n\tLIST_HEAD(stack);\n\tu64 parent_ino = sctx->cur_ino;\n\tint ret = 0;\n\n\tpm = get_pending_dir_moves(sctx, parent_ino);\n\tif (!pm)\n\t\treturn 0;\n\n\ttail_append_pending_moves(sctx, pm, &stack);\n\n\twhile (!list_empty(&stack)) {\n\t\tpm = list_first_entry(&stack, struct pending_dir_move, list);\n\t\tparent_ino = pm->ino;\n\t\tret = apply_dir_move(sctx, pm);\n\t\tfree_pending_move(sctx, pm);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tpm = get_pending_dir_moves(sctx, parent_ino);\n\t\tif (pm)\n\t\t\ttail_append_pending_moves(sctx, pm, &stack);\n\t}\n\treturn 0;\n\nout:\n\twhile (!list_empty(&stack)) {\n\t\tpm = list_first_entry(&stack, struct pending_dir_move, list);\n\t\tfree_pending_move(sctx, pm);\n\t}\n\treturn ret;\n}\n\n \nstatic int wait_for_dest_dir_move(struct send_ctx *sctx,\n\t\t\t\t  struct recorded_ref *parent_ref,\n\t\t\t\t  const bool is_orphan)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->parent_root->fs_info;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key di_key;\n\tstruct btrfs_dir_item *di;\n\tu64 left_gen;\n\tu64 right_gen;\n\tint ret = 0;\n\tstruct waiting_dir_move *wdm;\n\n\tif (RB_EMPTY_ROOT(&sctx->waiting_dir_moves))\n\t\treturn 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = parent_ref->dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(parent_ref->name, parent_ref->name_len);\n\n\tret = btrfs_search_slot(NULL, sctx->parent_root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdi = btrfs_match_dir_item_name(fs_info, path, parent_ref->name,\n\t\t\t\t       parent_ref->name_len);\n\tif (!di) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\t \n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &di_key);\n\tif (di_key.type != BTRFS_INODE_ITEM_KEY) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = get_inode_gen(sctx->parent_root, di_key.objectid, &left_gen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = get_inode_gen(sctx->send_root, di_key.objectid, &right_gen);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tif (right_gen != left_gen) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\twdm = get_waiting_dir_move(sctx, di_key.objectid);\n\tif (wdm && !wdm->orphanized) {\n\t\tret = add_pending_dir_move(sctx,\n\t\t\t\t\t   sctx->cur_ino,\n\t\t\t\t\t   sctx->cur_inode_gen,\n\t\t\t\t\t   di_key.objectid,\n\t\t\t\t\t   &sctx->new_refs,\n\t\t\t\t\t   &sctx->deleted_refs,\n\t\t\t\t\t   is_orphan);\n\t\tif (!ret)\n\t\t\tret = 1;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nstatic int check_ino_in_path(struct btrfs_root *root,\n\t\t\t     const u64 ino1,\n\t\t\t     const u64 ino1_gen,\n\t\t\t     const u64 ino2,\n\t\t\t     const u64 ino2_gen,\n\t\t\t     struct fs_path *fs_path)\n{\n\tu64 ino = ino2;\n\n\tif (ino1 == ino2)\n\t\treturn ino1_gen == ino2_gen;\n\n\twhile (ino > BTRFS_FIRST_FREE_OBJECTID) {\n\t\tu64 parent;\n\t\tu64 parent_gen;\n\t\tint ret;\n\n\t\tfs_path_reset(fs_path);\n\t\tret = get_first_ref(root, ino, &parent, &parent_gen, fs_path);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (parent == ino1)\n\t\t\treturn parent_gen == ino1_gen;\n\t\tino = parent;\n\t}\n\treturn 0;\n}\n\n \nstatic int is_ancestor(struct btrfs_root *root,\n\t\t       const u64 ino1,\n\t\t       const u64 ino1_gen,\n\t\t       const u64 ino2,\n\t\t       struct fs_path *fs_path)\n{\n\tbool free_fs_path = false;\n\tint ret = 0;\n\tint iter_ret = 0;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\n\tif (!fs_path) {\n\t\tfs_path = fs_path_alloc();\n\t\tif (!fs_path)\n\t\t\treturn -ENOMEM;\n\t\tfree_fs_path = true;\n\t}\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = ino2;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tbtrfs_for_each_slot(root, &key, &key, path, iter_ret) {\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tint slot = path->slots[0];\n\t\tu32 cur_offset = 0;\n\t\tu32 item_size;\n\n\t\tif (key.objectid != ino2)\n\t\t\tbreak;\n\t\tif (key.type != BTRFS_INODE_REF_KEY &&\n\t\t    key.type != BTRFS_INODE_EXTREF_KEY)\n\t\t\tbreak;\n\n\t\titem_size = btrfs_item_size(leaf, slot);\n\t\twhile (cur_offset < item_size) {\n\t\t\tu64 parent;\n\t\t\tu64 parent_gen;\n\n\t\t\tif (key.type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\t\tunsigned long ptr;\n\t\t\t\tstruct btrfs_inode_extref *extref;\n\n\t\t\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\t\t\textref = (struct btrfs_inode_extref *)\n\t\t\t\t\t(ptr + cur_offset);\n\t\t\t\tparent = btrfs_inode_extref_parent(leaf,\n\t\t\t\t\t\t\t\t   extref);\n\t\t\t\tcur_offset += sizeof(*extref);\n\t\t\t\tcur_offset += btrfs_inode_extref_name_len(leaf,\n\t\t\t\t\t\t\t\t  extref);\n\t\t\t} else {\n\t\t\t\tparent = key.offset;\n\t\t\t\tcur_offset = item_size;\n\t\t\t}\n\n\t\t\tret = get_inode_gen(root, parent, &parent_gen);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = check_ino_in_path(root, ino1, ino1_gen,\n\t\t\t\t\t\tparent, parent_gen, fs_path);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\n\tif (iter_ret < 0)\n\t\tret = iter_ret;\n\nout:\n\tbtrfs_free_path(path);\n\tif (free_fs_path)\n\t\tfs_path_free(fs_path);\n\treturn ret;\n}\n\nstatic int wait_for_parent_move(struct send_ctx *sctx,\n\t\t\t\tstruct recorded_ref *parent_ref,\n\t\t\t\tconst bool is_orphan)\n{\n\tint ret = 0;\n\tu64 ino = parent_ref->dir;\n\tu64 ino_gen = parent_ref->dir_gen;\n\tu64 parent_ino_before, parent_ino_after;\n\tstruct fs_path *path_before = NULL;\n\tstruct fs_path *path_after = NULL;\n\tint len1, len2;\n\n\tpath_after = fs_path_alloc();\n\tpath_before = fs_path_alloc();\n\tif (!path_after || !path_before) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\twhile (ino > BTRFS_FIRST_FREE_OBJECTID) {\n\t\tu64 parent_ino_after_gen;\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\t \n\t\t\tret = is_ancestor(sctx->parent_root,\n\t\t\t\t\t  sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\t\t  ino, path_before);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfs_path_reset(path_before);\n\t\tfs_path_reset(path_after);\n\n\t\tret = get_first_ref(sctx->send_root, ino, &parent_ino_after,\n\t\t\t\t    &parent_ino_after_gen, path_after);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = get_first_ref(sctx->parent_root, ino, &parent_ino_before,\n\t\t\t\t    NULL, path_before);\n\t\tif (ret < 0 && ret != -ENOENT) {\n\t\t\tgoto out;\n\t\t} else if (ret == -ENOENT) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen1 = fs_path_len(path_before);\n\t\tlen2 = fs_path_len(path_after);\n\t\tif (ino > sctx->cur_ino &&\n\t\t    (parent_ino_before != parent_ino_after || len1 != len2 ||\n\t\t     memcmp(path_before->start, path_after->start, len1))) {\n\t\t\tu64 parent_ino_gen;\n\n\t\t\tret = get_inode_gen(sctx->parent_root, ino, &parent_ino_gen);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ino_gen == parent_ino_gen) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tino = parent_ino_after;\n\t\tino_gen = parent_ino_after_gen;\n\t}\n\nout:\n\tfs_path_free(path_before);\n\tfs_path_free(path_after);\n\n\tif (ret == 1) {\n\t\tret = add_pending_dir_move(sctx,\n\t\t\t\t\t   sctx->cur_ino,\n\t\t\t\t\t   sctx->cur_inode_gen,\n\t\t\t\t\t   ino,\n\t\t\t\t\t   &sctx->new_refs,\n\t\t\t\t\t   &sctx->deleted_refs,\n\t\t\t\t\t   is_orphan);\n\t\tif (!ret)\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic int update_ref_path(struct send_ctx *sctx, struct recorded_ref *ref)\n{\n\tint ret;\n\tstruct fs_path *new_path;\n\n\t \n\tnew_path = fs_path_alloc();\n\tif (!new_path)\n\t\treturn -ENOMEM;\n\n\tret = get_cur_path(sctx, ref->dir, ref->dir_gen, new_path);\n\tif (ret < 0) {\n\t\tfs_path_free(new_path);\n\t\treturn ret;\n\t}\n\tret = fs_path_add(new_path, ref->name, ref->name_len);\n\tif (ret < 0) {\n\t\tfs_path_free(new_path);\n\t\treturn ret;\n\t}\n\n\tfs_path_free(ref->full_path);\n\tset_ref_path(ref, new_path);\n\n\treturn 0;\n}\n\n \nstatic int refresh_ref_path(struct send_ctx *sctx, struct recorded_ref *ref)\n{\n\tchar *name;\n\tint ret;\n\n\tname = kmemdup(ref->name, ref->name_len, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tfs_path_reset(ref->full_path);\n\tret = get_cur_path(sctx, ref->dir, ref->dir_gen, ref->full_path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = fs_path_add(ref->full_path, name, ref->name_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tset_ref_path(ref, ref->full_path);\nout:\n\tkfree(name);\n\treturn ret;\n}\n\n \nstatic int process_recorded_refs(struct send_ctx *sctx, int *pending_move)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret = 0;\n\tstruct recorded_ref *cur;\n\tstruct recorded_ref *cur2;\n\tLIST_HEAD(check_dirs);\n\tstruct fs_path *valid_path = NULL;\n\tu64 ow_inode = 0;\n\tu64 ow_gen;\n\tu64 ow_mode;\n\tint did_overwrite = 0;\n\tint is_orphan = 0;\n\tu64 last_dir_ino_rm = 0;\n\tbool can_rename = true;\n\tbool orphanized_dir = false;\n\tbool orphanized_ancestor = false;\n\n\tbtrfs_debug(fs_info, \"process_recorded_refs %llu\", sctx->cur_ino);\n\n\t \n\tBUG_ON(sctx->cur_ino <= BTRFS_FIRST_FREE_OBJECTID);\n\n\tvalid_path = fs_path_alloc();\n\tif (!valid_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!sctx->cur_inode_new) {\n\t\tret = did_overwrite_first_ref(sctx, sctx->cur_ino,\n\t\t\t\tsctx->cur_inode_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret)\n\t\t\tdid_overwrite = 1;\n\t}\n\tif (sctx->cur_inode_new || did_overwrite) {\n\t\tret = gen_unique_name(sctx, sctx->cur_ino,\n\t\t\t\tsctx->cur_inode_gen, valid_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tis_orphan = 1;\n\t} else {\n\t\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tvalid_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tlist_for_each_entry(cur, &sctx->new_refs, list) {\n\t\tret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret == inode_state_will_create)\n\t\t\tcontinue;\n\n\t\t \n\t\tret = will_overwrite_ref(sctx, cur->dir, cur->dir_gen,\n\t\t\t\tcur->name, cur->name_len,\n\t\t\t\t&ow_inode, &ow_gen, &ow_mode);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = is_first_ref(sctx->parent_root,\n\t\t\t\t\t   ow_inode, cur->dir, cur->name,\n\t\t\t\t\t   cur->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret) {\n\t\t\t\tstruct name_cache_entry *nce;\n\t\t\t\tstruct waiting_dir_move *wdm;\n\n\t\t\t\tif (orphanized_dir) {\n\t\t\t\t\tret = refresh_ref_path(sctx, cur);\n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = orphanize_inode(sctx, ow_inode, ow_gen,\n\t\t\t\t\t\tcur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (S_ISDIR(ow_mode))\n\t\t\t\t\torphanized_dir = true;\n\n\t\t\t\t \n\t\t\t\twdm = get_waiting_dir_move(sctx, ow_inode);\n\t\t\t\tif (wdm)\n\t\t\t\t\twdm->orphanized = true;\n\n\t\t\t\t \n\t\t\t\tnce = name_cache_search(sctx, ow_inode, ow_gen);\n\t\t\t\tif (nce)\n\t\t\t\t\tbtrfs_lru_cache_remove(&sctx->name_cache,\n\t\t\t\t\t\t\t       &nce->entry);\n\n\t\t\t\t \n\t\t\t\tret = is_ancestor(sctx->parent_root,\n\t\t\t\t\t\t  ow_inode, ow_gen,\n\t\t\t\t\t\t  sctx->cur_ino, NULL);\n\t\t\t\tif (ret > 0) {\n\t\t\t\t\torphanized_ancestor = true;\n\t\t\t\t\tfs_path_reset(valid_path);\n\t\t\t\t\tret = get_cur_path(sctx, sctx->cur_ino,\n\t\t\t\t\t\t\t   sctx->cur_inode_gen,\n\t\t\t\t\t\t\t   valid_path);\n\t\t\t\t}\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (orphanized_dir) {\n\t\t\t\t\tret = refresh_ref_path(sctx, cur);\n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = send_unlink(sctx, cur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tlist_for_each_entry(cur, &sctx->new_refs, list) {\n\t\t \n\t\tret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret == inode_state_will_create) {\n\t\t\tret = 0;\n\t\t\t \n\t\t\tlist_for_each_entry(cur2, &sctx->new_refs, list) {\n\t\t\t\tif (cur == cur2)\n\t\t\t\t\tbreak;\n\t\t\t\tif (cur2->dir == cur->dir) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!ret)\n\t\t\t\tret = did_create_dir(sctx, cur->dir);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret) {\n\t\t\t\tret = send_create_inode(sctx, cur->dir);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tcache_dir_created(sctx, cur->dir);\n\t\t\t}\n\t\t}\n\n\t\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->parent_root) {\n\t\t\tret = wait_for_dest_dir_move(sctx, cur, is_orphan);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 1) {\n\t\t\t\tcan_rename = false;\n\t\t\t\t*pending_move = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->parent_root &&\n\t\t    can_rename) {\n\t\t\tret = wait_for_parent_move(sctx, cur, is_orphan);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 1) {\n\t\t\t\tcan_rename = false;\n\t\t\t\t*pending_move = 1;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (is_orphan && can_rename) {\n\t\t\tret = send_rename(sctx, valid_path, cur->full_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tis_orphan = 0;\n\t\t\tret = fs_path_copy(valid_path, cur->full_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (can_rename) {\n\t\t\tif (S_ISDIR(sctx->cur_inode_mode)) {\n\t\t\t\t \n\t\t\t\tret = send_rename(sctx, valid_path,\n\t\t\t\t\t\t  cur->full_path);\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = fs_path_copy(valid_path,\n\t\t\t\t\t\t\t   cur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (orphanized_dir) {\n\t\t\t\t\tret = update_ref_path(sctx, cur);\n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = send_link(sctx, cur->full_path,\n\t\t\t\t\t\tvalid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = dup_ref(cur, &check_dirs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->cur_inode_deleted) {\n\t\t \n\t\tret = can_rmdir(sctx, sctx->cur_ino, sctx->cur_inode_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = send_rmdir(sctx, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (!is_orphan) {\n\t\t\tret = orphanize_inode(sctx, sctx->cur_ino,\n\t\t\t\t\tsctx->cur_inode_gen, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tis_orphan = 1;\n\t\t}\n\n\t\tlist_for_each_entry(cur, &sctx->deleted_refs, list) {\n\t\t\tret = dup_ref(cur, &check_dirs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t} else if (S_ISDIR(sctx->cur_inode_mode) &&\n\t\t   !list_empty(&sctx->deleted_refs)) {\n\t\t \n\t\tcur = list_entry(sctx->deleted_refs.next, struct recorded_ref,\n\t\t\t\tlist);\n\t\tret = dup_ref(cur, &check_dirs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else if (!S_ISDIR(sctx->cur_inode_mode)) {\n\t\t \n\t\tlist_for_each_entry(cur, &sctx->deleted_refs, list) {\n\t\t\tret = did_overwrite_ref(sctx, cur->dir, cur->dir_gen,\n\t\t\t\t\tsctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\t\tcur->name, cur->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret) {\n\t\t\t\t \n\t\t\t\tif (orphanized_ancestor) {\n\t\t\t\t\tret = update_ref_path(sctx, cur);\n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = send_unlink(sctx, cur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = dup_ref(cur, &check_dirs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (is_orphan) {\n\t\t\tret = send_unlink(sctx, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(cur, &check_dirs, list) {\n\t\t \n\t\tif (cur->dir > sctx->cur_ino)\n\t\t\tcontinue;\n\n\t\tret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret == inode_state_did_create ||\n\t\t    ret == inode_state_no_change) {\n\t\t\tret = cache_dir_utimes(sctx, cur->dir, cur->dir_gen);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (ret == inode_state_did_delete &&\n\t\t\t   cur->dir != last_dir_ino_rm) {\n\t\t\tret = can_rmdir(sctx, cur->dir, cur->dir_gen);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret) {\n\t\t\t\tret = get_cur_path(sctx, cur->dir,\n\t\t\t\t\t\t   cur->dir_gen, valid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tret = send_rmdir(sctx, valid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tlast_dir_ino_rm = cur->dir;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = 0;\n\nout:\n\t__free_recorded_refs(&check_dirs);\n\tfree_recorded_refs(sctx);\n\tfs_path_free(valid_path);\n\treturn ret;\n}\n\nstatic int rbtree_ref_comp(const void *k, const struct rb_node *node)\n{\n\tconst struct recorded_ref *data = k;\n\tconst struct recorded_ref *ref = rb_entry(node, struct recorded_ref, node);\n\tint result;\n\n\tif (data->dir > ref->dir)\n\t\treturn 1;\n\tif (data->dir < ref->dir)\n\t\treturn -1;\n\tif (data->dir_gen > ref->dir_gen)\n\t\treturn 1;\n\tif (data->dir_gen < ref->dir_gen)\n\t\treturn -1;\n\tif (data->name_len > ref->name_len)\n\t\treturn 1;\n\tif (data->name_len < ref->name_len)\n\t\treturn -1;\n\tresult = strcmp(data->name, ref->name);\n\tif (result > 0)\n\t\treturn 1;\n\tif (result < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic bool rbtree_ref_less(struct rb_node *node, const struct rb_node *parent)\n{\n\tconst struct recorded_ref *entry = rb_entry(node, struct recorded_ref, node);\n\n\treturn rbtree_ref_comp(entry, parent) < 0;\n}\n\nstatic int record_ref_in_tree(struct rb_root *root, struct list_head *refs,\n\t\t\t      struct fs_path *name, u64 dir, u64 dir_gen,\n\t\t\t      struct send_ctx *sctx)\n{\n\tint ret = 0;\n\tstruct fs_path *path = NULL;\n\tstruct recorded_ref *ref = NULL;\n\n\tpath = fs_path_alloc();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tref = recorded_ref_alloc();\n\tif (!ref) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = get_cur_path(sctx, dir, dir_gen, path);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = fs_path_add_path(path, name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tref->dir = dir;\n\tref->dir_gen = dir_gen;\n\tset_ref_path(ref, path);\n\tlist_add_tail(&ref->list, refs);\n\trb_add(&ref->node, root, rbtree_ref_less);\n\tref->root = root;\nout:\n\tif (ret) {\n\t\tif (path && (!ref || !ref->full_path))\n\t\t\tfs_path_free(path);\n\t\trecorded_ref_free(ref);\n\t}\n\treturn ret;\n}\n\nstatic int record_new_ref_if_needed(int num, u64 dir, int index,\n\t\t\t\t    struct fs_path *name, void *ctx)\n{\n\tint ret = 0;\n\tstruct send_ctx *sctx = ctx;\n\tstruct rb_node *node = NULL;\n\tstruct recorded_ref data;\n\tstruct recorded_ref *ref;\n\tu64 dir_gen;\n\n\tret = get_inode_gen(sctx->send_root, dir, &dir_gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdata.dir = dir;\n\tdata.dir_gen = dir_gen;\n\tset_ref_path(&data, name);\n\tnode = rb_find(&data, &sctx->rbtree_deleted_refs, rbtree_ref_comp);\n\tif (node) {\n\t\tref = rb_entry(node, struct recorded_ref, node);\n\t\trecorded_ref_free(ref);\n\t} else {\n\t\tret = record_ref_in_tree(&sctx->rbtree_new_refs,\n\t\t\t\t\t &sctx->new_refs, name, dir, dir_gen,\n\t\t\t\t\t sctx);\n\t}\nout:\n\treturn ret;\n}\n\nstatic int record_deleted_ref_if_needed(int num, u64 dir, int index,\n\t\t\t\t\tstruct fs_path *name, void *ctx)\n{\n\tint ret = 0;\n\tstruct send_ctx *sctx = ctx;\n\tstruct rb_node *node = NULL;\n\tstruct recorded_ref data;\n\tstruct recorded_ref *ref;\n\tu64 dir_gen;\n\n\tret = get_inode_gen(sctx->parent_root, dir, &dir_gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdata.dir = dir;\n\tdata.dir_gen = dir_gen;\n\tset_ref_path(&data, name);\n\tnode = rb_find(&data, &sctx->rbtree_new_refs, rbtree_ref_comp);\n\tif (node) {\n\t\tref = rb_entry(node, struct recorded_ref, node);\n\t\trecorded_ref_free(ref);\n\t} else {\n\t\tret = record_ref_in_tree(&sctx->rbtree_deleted_refs,\n\t\t\t\t\t &sctx->deleted_refs, name, dir,\n\t\t\t\t\t dir_gen, sctx);\n\t}\nout:\n\treturn ret;\n}\n\nstatic int record_new_ref(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tret = iterate_inode_ref(sctx->send_root, sctx->left_path,\n\t\t\t\tsctx->cmp_key, 0, record_new_ref_if_needed, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\treturn ret;\n}\n\nstatic int record_deleted_ref(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tret = iterate_inode_ref(sctx->parent_root, sctx->right_path,\n\t\t\t\tsctx->cmp_key, 0, record_deleted_ref_if_needed,\n\t\t\t\tsctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\treturn ret;\n}\n\nstatic int record_changed_ref(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tret = iterate_inode_ref(sctx->send_root, sctx->left_path,\n\t\t\tsctx->cmp_key, 0, record_new_ref_if_needed, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = iterate_inode_ref(sctx->parent_root, sctx->right_path,\n\t\t\tsctx->cmp_key, 0, record_deleted_ref_if_needed, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\treturn ret;\n}\n\n \nstatic int process_all_refs(struct send_ctx *sctx,\n\t\t\t    enum btrfs_compare_tree_result cmd)\n{\n\tint ret = 0;\n\tint iter_ret = 0;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\titerate_inode_ref_t cb;\n\tint pending_move = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (cmd == BTRFS_COMPARE_TREE_NEW) {\n\t\troot = sctx->send_root;\n\t\tcb = record_new_ref_if_needed;\n\t} else if (cmd == BTRFS_COMPARE_TREE_DELETED) {\n\t\troot = sctx->parent_root;\n\t\tcb = record_deleted_ref_if_needed;\n\t} else {\n\t\tbtrfs_err(sctx->send_root->fs_info,\n\t\t\t\t\"Wrong command %d in process_all_refs\", cmd);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\tbtrfs_for_each_slot(root, &key, &found_key, path, iter_ret) {\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t\t     found_key.type != BTRFS_INODE_EXTREF_KEY))\n\t\t\tbreak;\n\n\t\tret = iterate_inode_ref(root, path, &found_key, 0, cb, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\t \n\tif (iter_ret < 0) {\n\t\tret = iter_ret;\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\n\t \n\tret = process_recorded_refs(sctx, &pending_move);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int send_set_xattr(struct send_ctx *sctx,\n\t\t\t  struct fs_path *path,\n\t\t\t  const char *name, int name_len,\n\t\t\t  const char *data, int data_len)\n{\n\tint ret = 0;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_SET_XATTR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_STRING(sctx, BTRFS_SEND_A_XATTR_NAME, name, name_len);\n\tTLV_PUT(sctx, BTRFS_SEND_A_XATTR_DATA, data, data_len);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}\n\nstatic int send_remove_xattr(struct send_ctx *sctx,\n\t\t\t  struct fs_path *path,\n\t\t\t  const char *name, int name_len)\n{\n\tint ret = 0;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_REMOVE_XATTR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_STRING(sctx, BTRFS_SEND_A_XATTR_NAME, name, name_len);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}\n\nstatic int __process_new_xattr(int num, struct btrfs_key *di_key,\n\t\t\t       const char *name, int name_len, const char *data,\n\t\t\t       int data_len, void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\tstruct posix_acl_xattr_header dummy_acl;\n\n\t \n\tif (!strncmp(name, XATTR_NAME_CAPS, name_len))\n\t\treturn 0;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!strncmp(name, XATTR_NAME_POSIX_ACL_ACCESS, name_len) ||\n\t    !strncmp(name, XATTR_NAME_POSIX_ACL_DEFAULT, name_len)) {\n\t\tif (data_len == 0) {\n\t\t\tdummy_acl.a_version =\n\t\t\t\t\tcpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\t\t\tdata = (char *)&dummy_acl;\n\t\t\tdata_len = sizeof(dummy_acl);\n\t\t}\n\t}\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_set_xattr(sctx, p, name, name_len, data, data_len);\n\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\nstatic int __process_deleted_xattr(int num, struct btrfs_key *di_key,\n\t\t\t\t   const char *name, int name_len,\n\t\t\t\t   const char *data, int data_len, void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_remove_xattr(sctx, p, name, name_len);\n\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\nstatic int process_new_xattr(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tret = iterate_dir_item(sctx->send_root, sctx->left_path,\n\t\t\t       __process_new_xattr, sctx);\n\n\treturn ret;\n}\n\nstatic int process_deleted_xattr(struct send_ctx *sctx)\n{\n\treturn iterate_dir_item(sctx->parent_root, sctx->right_path,\n\t\t\t\t__process_deleted_xattr, sctx);\n}\n\nstruct find_xattr_ctx {\n\tconst char *name;\n\tint name_len;\n\tint found_idx;\n\tchar *found_data;\n\tint found_data_len;\n};\n\nstatic int __find_xattr(int num, struct btrfs_key *di_key, const char *name,\n\t\t\tint name_len, const char *data, int data_len, void *vctx)\n{\n\tstruct find_xattr_ctx *ctx = vctx;\n\n\tif (name_len == ctx->name_len &&\n\t    strncmp(name, ctx->name, name_len) == 0) {\n\t\tctx->found_idx = num;\n\t\tctx->found_data_len = data_len;\n\t\tctx->found_data = kmemdup(data, data_len, GFP_KERNEL);\n\t\tif (!ctx->found_data)\n\t\t\treturn -ENOMEM;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int find_xattr(struct btrfs_root *root,\n\t\t      struct btrfs_path *path,\n\t\t      struct btrfs_key *key,\n\t\t      const char *name, int name_len,\n\t\t      char **data, int *data_len)\n{\n\tint ret;\n\tstruct find_xattr_ctx ctx;\n\n\tctx.name = name;\n\tctx.name_len = name_len;\n\tctx.found_idx = -1;\n\tctx.found_data = NULL;\n\tctx.found_data_len = 0;\n\n\tret = iterate_dir_item(root, path, __find_xattr, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ctx.found_idx == -1)\n\t\treturn -ENOENT;\n\tif (data) {\n\t\t*data = ctx.found_data;\n\t\t*data_len = ctx.found_data_len;\n\t} else {\n\t\tkfree(ctx.found_data);\n\t}\n\treturn ctx.found_idx;\n}\n\n\nstatic int __process_changed_new_xattr(int num, struct btrfs_key *di_key,\n\t\t\t\t       const char *name, int name_len,\n\t\t\t\t       const char *data, int data_len,\n\t\t\t\t       void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\tchar *found_data = NULL;\n\tint found_data_len  = 0;\n\n\tret = find_xattr(sctx->parent_root, sctx->right_path,\n\t\t\t sctx->cmp_key, name, name_len, &found_data,\n\t\t\t &found_data_len);\n\tif (ret == -ENOENT) {\n\t\tret = __process_new_xattr(num, di_key, name, name_len, data,\n\t\t\t\t\t  data_len, ctx);\n\t} else if (ret >= 0) {\n\t\tif (data_len != found_data_len ||\n\t\t    memcmp(data, found_data, data_len)) {\n\t\t\tret = __process_new_xattr(num, di_key, name, name_len,\n\t\t\t\t\t\t  data, data_len, ctx);\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tkfree(found_data);\n\treturn ret;\n}\n\nstatic int __process_changed_deleted_xattr(int num, struct btrfs_key *di_key,\n\t\t\t\t\t   const char *name, int name_len,\n\t\t\t\t\t   const char *data, int data_len,\n\t\t\t\t\t   void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\n\tret = find_xattr(sctx->send_root, sctx->left_path, sctx->cmp_key,\n\t\t\t name, name_len, NULL, NULL);\n\tif (ret == -ENOENT)\n\t\tret = __process_deleted_xattr(num, di_key, name, name_len, data,\n\t\t\t\t\t      data_len, ctx);\n\telse if (ret >= 0)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int process_changed_xattr(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tret = iterate_dir_item(sctx->send_root, sctx->left_path,\n\t\t\t__process_changed_new_xattr, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = iterate_dir_item(sctx->parent_root, sctx->right_path,\n\t\t\t__process_changed_deleted_xattr, sctx);\n\nout:\n\treturn ret;\n}\n\nstatic int process_all_new_xattrs(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\tint iter_ret = 0;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\troot = sctx->send_root;\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = 0;\n\tbtrfs_for_each_slot(root, &key, &found_key, path, iter_ret) {\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = iterate_dir_item(root, path, __process_new_xattr, sctx);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\t \n\tif (iter_ret < 0)\n\t\tret = iter_ret;\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int send_verity(struct send_ctx *sctx, struct fs_path *path,\n\t\t       struct fsverity_descriptor *desc)\n{\n\tint ret;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_ENABLE_VERITY);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_U8(sctx, BTRFS_SEND_A_VERITY_ALGORITHM,\n\t\t\tle8_to_cpu(desc->hash_algorithm));\n\tTLV_PUT_U32(sctx, BTRFS_SEND_A_VERITY_BLOCK_SIZE,\n\t\t\t1U << le8_to_cpu(desc->log_blocksize));\n\tTLV_PUT(sctx, BTRFS_SEND_A_VERITY_SALT_DATA, desc->salt,\n\t\t\tle8_to_cpu(desc->salt_size));\n\tTLV_PUT(sctx, BTRFS_SEND_A_VERITY_SIG_DATA, desc->signature,\n\t\t\tle32_to_cpu(desc->sig_size));\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}\n\nstatic int process_verity(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tstruct inode *inode;\n\tstruct fs_path *p;\n\n\tinode = btrfs_iget(fs_info->sb, sctx->cur_ino, sctx->send_root);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tret = btrfs_get_verity_descriptor(inode, NULL, 0);\n\tif (ret < 0)\n\t\tgoto iput;\n\n\tif (ret > FS_VERITY_MAX_DESCRIPTOR_SIZE) {\n\t\tret = -EMSGSIZE;\n\t\tgoto iput;\n\t}\n\tif (!sctx->verity_descriptor) {\n\t\tsctx->verity_descriptor = kvmalloc(FS_VERITY_MAX_DESCRIPTOR_SIZE,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!sctx->verity_descriptor) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto iput;\n\t\t}\n\t}\n\n\tret = btrfs_get_verity_descriptor(inode, sctx->verity_descriptor, ret);\n\tif (ret < 0)\n\t\tgoto iput;\n\n\tp = fs_path_alloc();\n\tif (!p) {\n\t\tret = -ENOMEM;\n\t\tgoto iput;\n\t}\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto free_path;\n\n\tret = send_verity(sctx, p, sctx->verity_descriptor);\n\tif (ret < 0)\n\t\tgoto free_path;\n\nfree_path:\n\tfs_path_free(p);\niput:\n\tiput(inode);\n\treturn ret;\n}\n\nstatic inline u64 max_send_read_size(const struct send_ctx *sctx)\n{\n\treturn sctx->send_max_size - SZ_16K;\n}\n\nstatic int put_data_header(struct send_ctx *sctx, u32 len)\n{\n\tif (WARN_ON_ONCE(sctx->put_data))\n\t\treturn -EINVAL;\n\tsctx->put_data = true;\n\tif (sctx->proto >= 2) {\n\t\t \n\t\tif (sctx->send_max_size - sctx->send_size < sizeof(__le16) + len)\n\t\t\treturn -EOVERFLOW;\n\t\tput_unaligned_le16(BTRFS_SEND_A_DATA, sctx->send_buf + sctx->send_size);\n\t\tsctx->send_size += sizeof(__le16);\n\t} else {\n\t\tstruct btrfs_tlv_header *hdr;\n\n\t\tif (sctx->send_max_size - sctx->send_size < sizeof(*hdr) + len)\n\t\t\treturn -EOVERFLOW;\n\t\thdr = (struct btrfs_tlv_header *)(sctx->send_buf + sctx->send_size);\n\t\tput_unaligned_le16(BTRFS_SEND_A_DATA, &hdr->tlv_type);\n\t\tput_unaligned_le16(len, &hdr->tlv_len);\n\t\tsctx->send_size += sizeof(*hdr);\n\t}\n\treturn 0;\n}\n\nstatic int put_file_data(struct send_ctx *sctx, u64 offset, u32 len)\n{\n\tstruct btrfs_root *root = sctx->send_root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct page *page;\n\tpgoff_t index = offset >> PAGE_SHIFT;\n\tpgoff_t last_index;\n\tunsigned pg_offset = offset_in_page(offset);\n\tint ret;\n\n\tret = put_data_header(sctx, len);\n\tif (ret)\n\t\treturn ret;\n\n\tlast_index = (offset + len - 1) >> PAGE_SHIFT;\n\n\twhile (index <= last_index) {\n\t\tunsigned cur_len = min_t(unsigned, len,\n\t\t\t\t\t PAGE_SIZE - pg_offset);\n\n\t\tpage = find_lock_page(sctx->cur_inode->i_mapping, index);\n\t\tif (!page) {\n\t\t\tpage_cache_sync_readahead(sctx->cur_inode->i_mapping,\n\t\t\t\t\t\t  &sctx->ra, NULL, index,\n\t\t\t\t\t\t  last_index + 1 - index);\n\n\t\t\tpage = find_or_create_page(sctx->cur_inode->i_mapping,\n\t\t\t\t\t\t   index, GFP_KERNEL);\n\t\t\tif (!page) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (PageReadahead(page))\n\t\t\tpage_cache_async_readahead(sctx->cur_inode->i_mapping,\n\t\t\t\t\t\t   &sctx->ra, NULL, page_folio(page),\n\t\t\t\t\t\t   index, last_index + 1 - index);\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tbtrfs_read_folio(NULL, page_folio(page));\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\"send: IO error at offset %llu for inode %llu root %llu\",\n\t\t\t\t\tpage_offset(page), sctx->cur_ino,\n\t\t\t\t\tsctx->send_root->root_key.objectid);\n\t\t\t\tput_page(page);\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmemcpy_from_page(sctx->send_buf + sctx->send_size, page,\n\t\t\t\t pg_offset, cur_len);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tindex++;\n\t\tpg_offset = 0;\n\t\tlen -= cur_len;\n\t\tsctx->send_size += cur_len;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int send_write(struct send_ctx *sctx, u64 offset, u32 len)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret = 0;\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tbtrfs_debug(fs_info, \"send_write offset=%llu, len=%d\", offset, len);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_WRITE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tret = put_file_data(sctx, offset, len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\n \nstatic int send_clone(struct send_ctx *sctx,\n\t\t      u64 offset, u32 len,\n\t\t      struct clone_root *clone_root)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\tu64 gen;\n\n\tbtrfs_debug(sctx->send_root->fs_info,\n\t\t    \"send_clone offset=%llu, len=%d, clone_root=%llu, clone_inode=%llu, clone_offset=%llu\",\n\t\t    offset, len, clone_root->root->root_key.objectid,\n\t\t    clone_root->ino, clone_root->offset);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CLONE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_LEN, len);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\n\tif (clone_root->root == sctx->send_root) {\n\t\tret = get_inode_gen(sctx->send_root, clone_root->ino, &gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = get_cur_path(sctx, clone_root->ino, gen, p);\n\t} else {\n\t\tret = get_inode_path(clone_root->root, clone_root->ino, p);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (!btrfs_is_empty_uuid(clone_root->root->root_item.received_uuid))\n\t\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_CLONE_UUID,\n\t\t\t     clone_root->root->root_item.received_uuid);\n\telse\n\t\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_CLONE_UUID,\n\t\t\t     clone_root->root->root_item.uuid);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_CTRANSID,\n\t\t    btrfs_root_ctransid(&clone_root->root->root_item));\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_CLONE_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_OFFSET,\n\t\t\tclone_root->offset);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\n \nstatic int send_update_extent(struct send_ctx *sctx,\n\t\t\t      u64 offset, u32 len)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UPDATE_EXTENT);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_SIZE, len);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\nstatic int send_hole(struct send_ctx *sctx, u64 end)\n{\n\tstruct fs_path *p = NULL;\n\tu64 read_size = max_send_read_size(sctx);\n\tu64 offset = sctx->cur_inode_last_extent;\n\tint ret = 0;\n\n\t \n\tif (offset >= sctx->cur_inode_size)\n\t\treturn 0;\n\n\t \n\tend = min_t(u64, end, sctx->cur_inode_size);\n\n\tif (sctx->flags & BTRFS_SEND_FLAG_NO_FILE_DATA)\n\t\treturn send_update_extent(sctx, offset, end - offset);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto tlv_put_failure;\n\twhile (offset < end) {\n\t\tu64 len = min(end - offset, read_size);\n\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_WRITE);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\t\tret = put_data_header(sctx, len);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tmemset(sctx->send_buf + sctx->send_size, 0, len);\n\t\tsctx->send_size += len;\n\t\tret = send_cmd(sctx);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\toffset += len;\n\t}\n\tsctx->cur_inode_next_write_offset = offset;\ntlv_put_failure:\n\tfs_path_free(p);\n\treturn ret;\n}\n\nstatic int send_encoded_inline_extent(struct send_ctx *sctx,\n\t\t\t\t      struct btrfs_path *path, u64 offset,\n\t\t\t\t      u64 len)\n{\n\tstruct btrfs_root *root = sctx->send_root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct inode *inode;\n\tstruct fs_path *fspath;\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tstruct btrfs_key key;\n\tstruct btrfs_file_extent_item *ei;\n\tu64 ram_bytes;\n\tsize_t inline_size;\n\tint ret;\n\n\tinode = btrfs_iget(fs_info->sb, sctx->cur_ino, root);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tfspath = fs_path_alloc();\n\tif (!fspath) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_ENCODED_WRITE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, fspath);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tei = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_file_extent_item);\n\tram_bytes = btrfs_file_extent_ram_bytes(leaf, ei);\n\tinline_size = btrfs_file_extent_inline_item_len(leaf, path->slots[0]);\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, fspath);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_UNENCODED_FILE_LEN,\n\t\t    min(key.offset + ram_bytes - offset, len));\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_UNENCODED_LEN, ram_bytes);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_UNENCODED_OFFSET, offset - key.offset);\n\tret = btrfs_encoded_io_compression_from_extent(fs_info,\n\t\t\t\tbtrfs_file_extent_compression(leaf, ei));\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_U32(sctx, BTRFS_SEND_A_COMPRESSION, ret);\n\n\tret = put_data_header(sctx, inline_size);\n\tif (ret < 0)\n\t\tgoto out;\n\tread_extent_buffer(leaf, sctx->send_buf + sctx->send_size,\n\t\t\t   btrfs_file_extent_inline_start(ei), inline_size);\n\tsctx->send_size += inline_size;\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(fspath);\n\tiput(inode);\n\treturn ret;\n}\n\nstatic int send_encoded_extent(struct send_ctx *sctx, struct btrfs_path *path,\n\t\t\t       u64 offset, u64 len)\n{\n\tstruct btrfs_root *root = sctx->send_root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct inode *inode;\n\tstruct fs_path *fspath;\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tstruct btrfs_key key;\n\tstruct btrfs_file_extent_item *ei;\n\tu64 disk_bytenr, disk_num_bytes;\n\tu32 data_offset;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\tint ret;\n\n\tinode = btrfs_iget(fs_info->sb, sctx->cur_ino, root);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tfspath = fs_path_alloc();\n\tif (!fspath) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_ENCODED_WRITE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, fspath);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tei = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_file_extent_item);\n\tdisk_bytenr = btrfs_file_extent_disk_bytenr(leaf, ei);\n\tdisk_num_bytes = btrfs_file_extent_disk_num_bytes(leaf, ei);\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, fspath);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_UNENCODED_FILE_LEN,\n\t\t    min(key.offset + btrfs_file_extent_num_bytes(leaf, ei) - offset,\n\t\t\tlen));\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_UNENCODED_LEN,\n\t\t    btrfs_file_extent_ram_bytes(leaf, ei));\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_UNENCODED_OFFSET,\n\t\t    offset - key.offset + btrfs_file_extent_offset(leaf, ei));\n\tret = btrfs_encoded_io_compression_from_extent(fs_info,\n\t\t\t\tbtrfs_file_extent_compression(leaf, ei));\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_U32(sctx, BTRFS_SEND_A_COMPRESSION, ret);\n\tTLV_PUT_U32(sctx, BTRFS_SEND_A_ENCRYPTION, 0);\n\n\tret = put_data_header(sctx, disk_num_bytes);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tdata_offset = PAGE_ALIGN(sctx->send_size);\n\tif (data_offset > sctx->send_max_size ||\n\t    sctx->send_max_size - data_offset < disk_num_bytes) {\n\t\tret = -EOVERFLOW;\n\t\tgoto out;\n\t}\n\n\t \n\tret = btrfs_encoded_read_regular_fill_pages(BTRFS_I(inode), offset,\n\t\t\t\t\t\t    disk_bytenr, disk_num_bytes,\n\t\t\t\t\t\t    sctx->send_buf_pages +\n\t\t\t\t\t\t    (data_offset >> PAGE_SHIFT));\n\tif (ret)\n\t\tgoto out;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size + disk_num_bytes - sizeof(*hdr));\n\thdr->crc = 0;\n\tcrc = btrfs_crc32c(0, sctx->send_buf, sctx->send_size);\n\tcrc = btrfs_crc32c(crc, sctx->send_buf + data_offset, disk_num_bytes);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t&sctx->send_off);\n\tif (!ret) {\n\t\tret = write_buf(sctx->send_filp, sctx->send_buf + data_offset,\n\t\t\t\tdisk_num_bytes, &sctx->send_off);\n\t}\n\tsctx->send_size = 0;\n\tsctx->put_data = false;\n\ntlv_put_failure:\nout:\n\tfs_path_free(fspath);\n\tiput(inode);\n\treturn ret;\n}\n\nstatic int send_extent_data(struct send_ctx *sctx, struct btrfs_path *path,\n\t\t\t    const u64 offset, const u64 len)\n{\n\tconst u64 end = offset + len;\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tstruct btrfs_file_extent_item *ei;\n\tu64 read_size = max_send_read_size(sctx);\n\tu64 sent = 0;\n\n\tif (sctx->flags & BTRFS_SEND_FLAG_NO_FILE_DATA)\n\t\treturn send_update_extent(sctx, offset, len);\n\n\tei = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\tif ((sctx->flags & BTRFS_SEND_FLAG_COMPRESSED) &&\n\t    btrfs_file_extent_compression(leaf, ei) != BTRFS_COMPRESS_NONE) {\n\t\tbool is_inline = (btrfs_file_extent_type(leaf, ei) ==\n\t\t\t\t  BTRFS_FILE_EXTENT_INLINE);\n\n\t\t \n\t\tif (is_inline &&\n\t\t    btrfs_file_extent_inline_item_len(leaf,\n\t\t\t\t\t\t      path->slots[0]) <= len) {\n\t\t\treturn send_encoded_inline_extent(sctx, path, offset,\n\t\t\t\t\t\t\t  len);\n\t\t} else if (!is_inline &&\n\t\t\t   btrfs_file_extent_disk_num_bytes(leaf, ei) <= len) {\n\t\t\treturn send_encoded_extent(sctx, path, offset, len);\n\t\t}\n\t}\n\n\tif (sctx->cur_inode == NULL) {\n\t\tstruct btrfs_root *root = sctx->send_root;\n\n\t\tsctx->cur_inode = btrfs_iget(root->fs_info->sb, sctx->cur_ino, root);\n\t\tif (IS_ERR(sctx->cur_inode)) {\n\t\t\tint err = PTR_ERR(sctx->cur_inode);\n\n\t\t\tsctx->cur_inode = NULL;\n\t\t\treturn err;\n\t\t}\n\t\tmemset(&sctx->ra, 0, sizeof(struct file_ra_state));\n\t\tfile_ra_state_init(&sctx->ra, sctx->cur_inode->i_mapping);\n\n\t\t \n\t\tsctx->clean_page_cache = (sctx->cur_inode->i_mapping->nrpages == 0);\n\t\tsctx->page_cache_clear_start = round_down(offset, PAGE_SIZE);\n\t}\n\n\twhile (sent < len) {\n\t\tu64 size = min(len - sent, read_size);\n\t\tint ret;\n\n\t\tret = send_write(sctx, offset + sent, size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsent += size;\n\t}\n\n\tif (sctx->clean_page_cache && PAGE_ALIGNED(end)) {\n\t\t \n\t\ttruncate_inode_pages_range(&sctx->cur_inode->i_data,\n\t\t\t\t\t   sctx->page_cache_clear_start,\n\t\t\t\t\t   end - 1);\n\t\tsctx->page_cache_clear_start = end;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int send_capabilities(struct send_ctx *sctx)\n{\n\tstruct fs_path *fspath = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tstruct extent_buffer *leaf;\n\tunsigned long data_ptr;\n\tchar *buf = NULL;\n\tint buf_len;\n\tint ret = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tdi = btrfs_lookup_xattr(NULL, sctx->send_root, path, sctx->cur_ino,\n\t\t\t\tXATTR_NAME_CAPS, strlen(XATTR_NAME_CAPS), 0);\n\tif (!di) {\n\t\t \n\t\tgoto out;\n\t} else if (IS_ERR(di)) {\n\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tbuf_len = btrfs_dir_data_len(leaf, di);\n\n\tfspath = fs_path_alloc();\n\tbuf = kmalloc(buf_len, GFP_KERNEL);\n\tif (!fspath || !buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, fspath);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdata_ptr = (unsigned long)(di + 1) + btrfs_dir_name_len(leaf, di);\n\tread_extent_buffer(leaf, buf, data_ptr, buf_len);\n\n\tret = send_set_xattr(sctx, fspath, XATTR_NAME_CAPS,\n\t\t\tstrlen(XATTR_NAME_CAPS), buf, buf_len);\nout:\n\tkfree(buf);\n\tfs_path_free(fspath);\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int clone_range(struct send_ctx *sctx, struct btrfs_path *dst_path,\n\t\t       struct clone_root *clone_root, const u64 disk_byte,\n\t\t       u64 data_offset, u64 offset, u64 len)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret;\n\tstruct btrfs_inode_info info;\n\tu64 clone_src_i_size = 0;\n\n\t \n\tif (clone_root->offset == 0 &&\n\t    len == sctx->send_root->fs_info->sectorsize)\n\t\treturn send_extent_data(sctx, dst_path, offset, len);\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t \n\tret = get_inode_info(clone_root->root, clone_root->ino, &info);\n\tbtrfs_release_path(path);\n\tif (ret < 0)\n\t\tgoto out;\n\tclone_src_i_size = info.size;\n\n\t \n\tkey.objectid = clone_root->ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = clone_root->offset;\n\tret = btrfs_search_slot(NULL, clone_root->root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0] - 1);\n\t\tif (key.objectid == clone_root->ino &&\n\t\t    key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\tpath->slots[0]--;\n\t}\n\n\twhile (true) {\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tint slot = path->slots[0];\n\t\tstruct btrfs_file_extent_item *ei;\n\t\tu8 type;\n\t\tu64 ext_len;\n\t\tu64 clone_len;\n\t\tu64 clone_data_offset;\n\t\tbool crossed_src_i_size = false;\n\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(clone_root->root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\n\t\t \n\t\tif (key.objectid != clone_root->ino ||\n\t\t    key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tbreak;\n\n\t\tei = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\t\ttype = btrfs_file_extent_type(leaf, ei);\n\t\tif (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\text_len = btrfs_file_extent_ram_bytes(leaf, ei);\n\t\t\text_len = PAGE_ALIGN(ext_len);\n\t\t} else {\n\t\t\text_len = btrfs_file_extent_num_bytes(leaf, ei);\n\t\t}\n\n\t\tif (key.offset + ext_len <= clone_root->offset)\n\t\t\tgoto next;\n\n\t\tif (key.offset > clone_root->offset) {\n\t\t\t \n\t\t\tu64 hole_len = key.offset - clone_root->offset;\n\n\t\t\tif (hole_len > len)\n\t\t\t\thole_len = len;\n\t\t\tret = send_extent_data(sctx, dst_path, offset,\n\t\t\t\t\t       hole_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tlen -= hole_len;\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t\toffset += hole_len;\n\t\t\tclone_root->offset += hole_len;\n\t\t\tdata_offset += hole_len;\n\t\t}\n\n\t\tif (key.offset >= clone_root->offset + len)\n\t\t\tbreak;\n\n\t\tif (key.offset >= clone_src_i_size)\n\t\t\tbreak;\n\n\t\tif (key.offset + ext_len > clone_src_i_size) {\n\t\t\text_len = clone_src_i_size - key.offset;\n\t\t\tcrossed_src_i_size = true;\n\t\t}\n\n\t\tclone_data_offset = btrfs_file_extent_offset(leaf, ei);\n\t\tif (btrfs_file_extent_disk_bytenr(leaf, ei) == disk_byte) {\n\t\t\tclone_root->offset = key.offset;\n\t\t\tif (clone_data_offset < data_offset &&\n\t\t\t\tclone_data_offset + ext_len > data_offset) {\n\t\t\t\tu64 extent_offset;\n\n\t\t\t\textent_offset = data_offset - clone_data_offset;\n\t\t\t\text_len -= extent_offset;\n\t\t\t\tclone_data_offset += extent_offset;\n\t\t\t\tclone_root->offset += extent_offset;\n\t\t\t}\n\t\t}\n\n\t\tclone_len = min_t(u64, ext_len, len);\n\n\t\tif (btrfs_file_extent_disk_bytenr(leaf, ei) == disk_byte &&\n\t\t    clone_data_offset == data_offset) {\n\t\t\tconst u64 src_end = clone_root->offset + clone_len;\n\t\t\tconst u64 sectorsize = SZ_64K;\n\n\t\t\t \n\t\t\tif (src_end == clone_src_i_size &&\n\t\t\t    !IS_ALIGNED(src_end, sectorsize) &&\n\t\t\t    offset + clone_len < sctx->cur_inode_size) {\n\t\t\t\tu64 slen;\n\n\t\t\t\tslen = ALIGN_DOWN(src_end - clone_root->offset,\n\t\t\t\t\t\t  sectorsize);\n\t\t\t\tif (slen > 0) {\n\t\t\t\t\tret = send_clone(sctx, offset, slen,\n\t\t\t\t\t\t\t clone_root);\n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = send_extent_data(sctx, dst_path,\n\t\t\t\t\t\t       offset + slen,\n\t\t\t\t\t\t       clone_len - slen);\n\t\t\t} else {\n\t\t\t\tret = send_clone(sctx, offset, clone_len,\n\t\t\t\t\t\t clone_root);\n\t\t\t}\n\t\t} else if (crossed_src_i_size && clone_len < len) {\n\t\t\t \n\t\t\tbreak;\n\t\t} else {\n\t\t\tret = send_extent_data(sctx, dst_path, offset,\n\t\t\t\t\t       clone_len);\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tlen -= clone_len;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\toffset += clone_len;\n\t\tclone_root->offset += clone_len;\n\n\t\t \n\t\tif (clone_root->root == sctx->send_root &&\n\t\t    clone_root->ino == sctx->cur_ino &&\n\t\t    clone_root->offset >= sctx->cur_inode_next_write_offset)\n\t\t\tbreak;\n\n\t\tdata_offset += clone_len;\nnext:\n\t\tpath->slots[0]++;\n\t}\n\n\tif (len > 0)\n\t\tret = send_extent_data(sctx, dst_path, offset, len);\n\telse\n\t\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int send_write_or_clone(struct send_ctx *sctx,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *key,\n\t\t\t       struct clone_root *clone_root)\n{\n\tint ret = 0;\n\tu64 offset = key->offset;\n\tu64 end;\n\tu64 bs = sctx->send_root->fs_info->sb->s_blocksize;\n\n\tend = min_t(u64, btrfs_file_extent_end(path), sctx->cur_inode_size);\n\tif (offset >= end)\n\t\treturn 0;\n\n\tif (clone_root && IS_ALIGNED(end, bs)) {\n\t\tstruct btrfs_file_extent_item *ei;\n\t\tu64 disk_byte;\n\t\tu64 data_offset;\n\n\t\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tdisk_byte = btrfs_file_extent_disk_bytenr(path->nodes[0], ei);\n\t\tdata_offset = btrfs_file_extent_offset(path->nodes[0], ei);\n\t\tret = clone_range(sctx, path, clone_root, disk_byte,\n\t\t\t\t  data_offset, offset, end - offset);\n\t} else {\n\t\tret = send_extent_data(sctx, path, offset, end - offset);\n\t}\n\tsctx->cur_inode_next_write_offset = end;\n\treturn ret;\n}\n\nstatic int is_extent_unchanged(struct send_ctx *sctx,\n\t\t\t       struct btrfs_path *left_path,\n\t\t\t       struct btrfs_key *ekey)\n{\n\tint ret = 0;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_file_extent_item *ei;\n\tu64 left_disknr;\n\tu64 right_disknr;\n\tu64 left_offset;\n\tu64 right_offset;\n\tu64 left_offset_fixed;\n\tu64 left_len;\n\tu64 right_len;\n\tu64 left_gen;\n\tu64 right_gen;\n\tu8 left_type;\n\tu8 right_type;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\teb = left_path->nodes[0];\n\tslot = left_path->slots[0];\n\tei = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\tleft_type = btrfs_file_extent_type(eb, ei);\n\n\tif (left_type != BTRFS_FILE_EXTENT_REG) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tleft_disknr = btrfs_file_extent_disk_bytenr(eb, ei);\n\tleft_len = btrfs_file_extent_num_bytes(eb, ei);\n\tleft_offset = btrfs_file_extent_offset(eb, ei);\n\tleft_gen = btrfs_file_extent_generation(eb, ei);\n\n\t \n\n\tkey.objectid = ekey->objectid;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = ekey->offset;\n\tret = btrfs_search_slot_for_read(sctx->parent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t \n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\tif (found_key.objectid != key.objectid ||\n\t    found_key.type != key.type) {\n\t\t \n\t\tret = (left_disknr) ? 0 : 1;\n\t\tgoto out;\n\t}\n\n\t \n\tkey = found_key;\n\twhile (key.offset < ekey->offset + left_len) {\n\t\tei = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\t\tright_type = btrfs_file_extent_type(eb, ei);\n\t\tif (right_type != BTRFS_FILE_EXTENT_REG &&\n\t\t    right_type != BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (right_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tright_len = btrfs_file_extent_ram_bytes(eb, ei);\n\t\t\tright_len = PAGE_ALIGN(right_len);\n\t\t} else {\n\t\t\tright_len = btrfs_file_extent_num_bytes(eb, ei);\n\t\t}\n\n\t\t \n\t\tif (found_key.offset + right_len <= ekey->offset) {\n\t\t\t \n\t\t\tret = (left_disknr) ? 0 : 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (right_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tright_disknr = btrfs_file_extent_disk_bytenr(eb, ei);\n\t\tright_offset = btrfs_file_extent_offset(eb, ei);\n\t\tright_gen = btrfs_file_extent_generation(eb, ei);\n\n\t\tleft_offset_fixed = left_offset;\n\t\tif (key.offset < ekey->offset) {\n\t\t\t \n\t\t\tright_offset += ekey->offset - key.offset;\n\t\t} else {\n\t\t\t \n\t\t\tleft_offset_fixed += key.offset - ekey->offset;\n\t\t}\n\n\t\t \n\t\tif (left_disknr != right_disknr ||\n\t\t    left_offset_fixed != right_offset ||\n\t\t    left_gen != right_gen) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret = btrfs_next_item(sctx->parent_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (!ret) {\n\t\t\teb = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\t}\n\t\tif (ret || found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tkey.offset += right_len;\n\t\t\tbreak;\n\t\t}\n\t\tif (found_key.offset != key.offset + right_len) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tkey = found_key;\n\t}\n\n\t \n\tif (key.offset >= ekey->offset + left_len)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int get_last_extent(struct send_ctx *sctx, u64 offset)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = sctx->send_root;\n\tstruct btrfs_key key;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tsctx->cur_inode_last_extent = 0;\n\n\tkey.objectid = sctx->cur_ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = offset;\n\tret = btrfs_search_slot_for_read(root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\tif (key.objectid != sctx->cur_ino || key.type != BTRFS_EXTENT_DATA_KEY)\n\t\tgoto out;\n\n\tsctx->cur_inode_last_extent = btrfs_file_extent_end(path);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int range_is_hole_in_parent(struct send_ctx *sctx,\n\t\t\t\t   const u64 start,\n\t\t\t\t   const u64 end)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = sctx->parent_root;\n\tu64 search_start = start;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = sctx->cur_ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = search_start;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0 && path->slots[0] > 0)\n\t\tpath->slots[0]--;\n\n\twhile (search_start < end) {\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tint slot = path->slots[0];\n\t\tstruct btrfs_file_extent_item *fi;\n\t\tu64 extent_end;\n\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid < sctx->cur_ino ||\n\t\t    key.type < BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto next;\n\t\tif (key.objectid > sctx->cur_ino ||\n\t\t    key.type > BTRFS_EXTENT_DATA_KEY ||\n\t\t    key.offset >= end)\n\t\t\tbreak;\n\n\t\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\t\textent_end = btrfs_file_extent_end(path);\n\t\tif (extent_end <= start)\n\t\t\tgoto next;\n\t\tif (btrfs_file_extent_disk_bytenr(leaf, fi) == 0) {\n\t\t\tsearch_start = extent_end;\n\t\t\tgoto next;\n\t\t}\n\t\tret = 0;\n\t\tgoto out;\nnext:\n\t\tpath->slots[0]++;\n\t}\n\tret = 1;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int maybe_send_hole(struct send_ctx *sctx, struct btrfs_path *path,\n\t\t\t   struct btrfs_key *key)\n{\n\tint ret = 0;\n\n\tif (sctx->cur_ino != key->objectid || !need_send_hole(sctx))\n\t\treturn 0;\n\n\tif (sctx->cur_inode_last_extent == (u64)-1) {\n\t\tret = get_last_extent(sctx, key->offset - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (path->slots[0] == 0 &&\n\t    sctx->cur_inode_last_extent < key->offset) {\n\t\t \n\t\tret = get_last_extent(sctx, key->offset - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (sctx->cur_inode_last_extent < key->offset) {\n\t\tret = range_is_hole_in_parent(sctx,\n\t\t\t\t\t      sctx->cur_inode_last_extent,\n\t\t\t\t\t      key->offset);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret == 0)\n\t\t\tret = send_hole(sctx, key->offset);\n\t\telse\n\t\t\tret = 0;\n\t}\n\tsctx->cur_inode_last_extent = btrfs_file_extent_end(path);\n\treturn ret;\n}\n\nstatic int process_extent(struct send_ctx *sctx,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_key *key)\n{\n\tstruct clone_root *found_clone = NULL;\n\tint ret = 0;\n\n\tif (S_ISLNK(sctx->cur_inode_mode))\n\t\treturn 0;\n\n\tif (sctx->parent_root && !sctx->cur_inode_new) {\n\t\tret = is_extent_unchanged(sctx, path, key);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out_hole;\n\t\t}\n\t} else {\n\t\tstruct btrfs_file_extent_item *ei;\n\t\tu8 type;\n\n\t\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\ttype = btrfs_file_extent_type(path->nodes[0], ei);\n\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC ||\n\t\t    type == BTRFS_FILE_EXTENT_REG) {\n\t\t\t \n\t\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (btrfs_file_extent_disk_bytenr(path->nodes[0], ei) == 0) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = find_extent_clone(sctx, path, key->objectid, key->offset,\n\t\t\tsctx->cur_inode_size, &found_clone);\n\tif (ret != -ENOENT && ret < 0)\n\t\tgoto out;\n\n\tret = send_write_or_clone(sctx, path, key, found_clone);\n\tif (ret)\n\t\tgoto out;\nout_hole:\n\tret = maybe_send_hole(sctx, path, key);\nout:\n\treturn ret;\n}\n\nstatic int process_all_extents(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\tint iter_ret = 0;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\n\troot = sctx->send_root;\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = 0;\n\tbtrfs_for_each_slot(root, &key, &found_key, path, iter_ret) {\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = process_extent(sctx, path, &found_key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\t \n\tif (iter_ret < 0)\n\t\tret = iter_ret;\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int process_recorded_refs_if_needed(struct send_ctx *sctx, int at_end,\n\t\t\t\t\t   int *pending_move,\n\t\t\t\t\t   int *refs_processed)\n{\n\tint ret = 0;\n\n\tif (sctx->cur_ino == 0)\n\t\tgoto out;\n\tif (!at_end && sctx->cur_ino == sctx->cmp_key->objectid &&\n\t    sctx->cmp_key->type <= BTRFS_INODE_EXTREF_KEY)\n\t\tgoto out;\n\tif (list_empty(&sctx->new_refs) && list_empty(&sctx->deleted_refs))\n\t\tgoto out;\n\n\tret = process_recorded_refs(sctx, pending_move);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*refs_processed = 1;\nout:\n\treturn ret;\n}\n\nstatic int finish_inode_if_needed(struct send_ctx *sctx, int at_end)\n{\n\tint ret = 0;\n\tstruct btrfs_inode_info info;\n\tu64 left_mode;\n\tu64 left_uid;\n\tu64 left_gid;\n\tu64 left_fileattr;\n\tu64 right_mode;\n\tu64 right_uid;\n\tu64 right_gid;\n\tu64 right_fileattr;\n\tint need_chmod = 0;\n\tint need_chown = 0;\n\tbool need_fileattr = false;\n\tint need_truncate = 1;\n\tint pending_move = 0;\n\tint refs_processed = 0;\n\n\tif (sctx->ignore_cur_inode)\n\t\treturn 0;\n\n\tret = process_recorded_refs_if_needed(sctx, at_end, &pending_move,\n\t\t\t\t\t      &refs_processed);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (refs_processed && !pending_move)\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\n\tif (sctx->cur_ino == 0 || sctx->cur_inode_deleted)\n\t\tgoto out;\n\tif (!at_end && sctx->cmp_key->objectid == sctx->cur_ino)\n\t\tgoto out;\n\tret = get_inode_info(sctx->send_root, sctx->cur_ino, &info);\n\tif (ret < 0)\n\t\tgoto out;\n\tleft_mode = info.mode;\n\tleft_uid = info.uid;\n\tleft_gid = info.gid;\n\tleft_fileattr = info.fileattr;\n\n\tif (!sctx->parent_root || sctx->cur_inode_new) {\n\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode))\n\t\t\tneed_chmod = 1;\n\t\tif (sctx->cur_inode_next_write_offset == sctx->cur_inode_size)\n\t\t\tneed_truncate = 0;\n\t} else {\n\t\tu64 old_size;\n\n\t\tret = get_inode_info(sctx->parent_root, sctx->cur_ino, &info);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\told_size = info.size;\n\t\tright_mode = info.mode;\n\t\tright_uid = info.uid;\n\t\tright_gid = info.gid;\n\t\tright_fileattr = info.fileattr;\n\n\t\tif (left_uid != right_uid || left_gid != right_gid)\n\t\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode) && left_mode != right_mode)\n\t\t\tneed_chmod = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode) && left_fileattr != right_fileattr)\n\t\t\tneed_fileattr = true;\n\t\tif ((old_size == sctx->cur_inode_size) ||\n\t\t    (sctx->cur_inode_size > old_size &&\n\t\t     sctx->cur_inode_next_write_offset == sctx->cur_inode_size))\n\t\t\tneed_truncate = 0;\n\t}\n\n\tif (S_ISREG(sctx->cur_inode_mode)) {\n\t\tif (need_send_hole(sctx)) {\n\t\t\tif (sctx->cur_inode_last_extent == (u64)-1 ||\n\t\t\t    sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = get_last_extent(sctx, (u64)-1);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = send_hole(sctx, sctx->cur_inode_size);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (need_truncate) {\n\t\t\tret = send_truncate(sctx, sctx->cur_ino,\n\t\t\t\t\t    sctx->cur_inode_gen,\n\t\t\t\t\t    sctx->cur_inode_size);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (need_chown) {\n\t\tret = send_chown(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_uid, left_gid);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tif (need_chmod) {\n\t\tret = send_chmod(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_mode);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tif (need_fileattr) {\n\t\tret = send_fileattr(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\t    left_fileattr);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (proto_cmd_ok(sctx, BTRFS_SEND_C_ENABLE_VERITY)\n\t    && sctx->cur_inode_needs_verity) {\n\t\tret = process_verity(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = send_capabilities(sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (!is_waiting_for_move(sctx, sctx->cur_ino)) {\n\t\tret = apply_children_dir_moves(sctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t \n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\n\t\t \n\t\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->cur_inode_size > 0)\n\t\t\tret = cache_dir_utimes(sctx, sctx->cur_ino, sctx->cur_inode_gen);\n\t\telse\n\t\t\tret = send_utimes(sctx, sctx->cur_ino, sctx->cur_inode_gen);\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (!ret)\n\t\tret = trim_dir_utimes_cache(sctx);\n\n\treturn ret;\n}\n\nstatic void close_current_inode(struct send_ctx *sctx)\n{\n\tu64 i_size;\n\n\tif (sctx->cur_inode == NULL)\n\t\treturn;\n\n\ti_size = i_size_read(sctx->cur_inode);\n\n\t \n\tif (sctx->clean_page_cache && sctx->page_cache_clear_start < i_size)\n\t\ttruncate_inode_pages_range(&sctx->cur_inode->i_data,\n\t\t\t\t\t   sctx->page_cache_clear_start,\n\t\t\t\t\t   round_up(i_size, PAGE_SIZE) - 1);\n\n\tiput(sctx->cur_inode);\n\tsctx->cur_inode = NULL;\n}\n\nstatic int changed_inode(struct send_ctx *sctx,\n\t\t\t enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\tstruct btrfs_key *key = sctx->cmp_key;\n\tstruct btrfs_inode_item *left_ii = NULL;\n\tstruct btrfs_inode_item *right_ii = NULL;\n\tu64 left_gen = 0;\n\tu64 right_gen = 0;\n\n\tclose_current_inode(sctx);\n\n\tsctx->cur_ino = key->objectid;\n\tsctx->cur_inode_new_gen = false;\n\tsctx->cur_inode_last_extent = (u64)-1;\n\tsctx->cur_inode_next_write_offset = 0;\n\tsctx->ignore_cur_inode = false;\n\n\t \n\tsctx->send_progress = sctx->cur_ino;\n\n\tif (result == BTRFS_COMPARE_TREE_NEW ||\n\t    result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\tleft_ii = btrfs_item_ptr(sctx->left_path->nodes[0],\n\t\t\t\tsctx->left_path->slots[0],\n\t\t\t\tstruct btrfs_inode_item);\n\t\tleft_gen = btrfs_inode_generation(sctx->left_path->nodes[0],\n\t\t\t\tleft_ii);\n\t} else {\n\t\tright_ii = btrfs_item_ptr(sctx->right_path->nodes[0],\n\t\t\t\tsctx->right_path->slots[0],\n\t\t\t\tstruct btrfs_inode_item);\n\t\tright_gen = btrfs_inode_generation(sctx->right_path->nodes[0],\n\t\t\t\tright_ii);\n\t}\n\tif (result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\tright_ii = btrfs_item_ptr(sctx->right_path->nodes[0],\n\t\t\t\tsctx->right_path->slots[0],\n\t\t\t\tstruct btrfs_inode_item);\n\n\t\tright_gen = btrfs_inode_generation(sctx->right_path->nodes[0],\n\t\t\t\tright_ii);\n\n\t\t \n\t\tif (left_gen != right_gen &&\n\t\t    sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tsctx->cur_inode_new_gen = true;\n\t}\n\n\t \n\tif (result == BTRFS_COMPARE_TREE_NEW) {\n\t\tif (btrfs_inode_nlink(sctx->left_path->nodes[0], left_ii) == 0) {\n\t\t\tsctx->ignore_cur_inode = true;\n\t\t\tgoto out;\n\t\t}\n\t\tsctx->cur_inode_gen = left_gen;\n\t\tsctx->cur_inode_new = true;\n\t\tsctx->cur_inode_deleted = false;\n\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\tsctx->cur_inode_rdev = btrfs_inode_rdev(\n\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\tif (sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tret = send_create_inode_if_needed(sctx);\n\t} else if (result == BTRFS_COMPARE_TREE_DELETED) {\n\t\tsctx->cur_inode_gen = right_gen;\n\t\tsctx->cur_inode_new = false;\n\t\tsctx->cur_inode_deleted = true;\n\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t} else if (result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\tu32 new_nlinks, old_nlinks;\n\n\t\tnew_nlinks = btrfs_inode_nlink(sctx->left_path->nodes[0], left_ii);\n\t\told_nlinks = btrfs_inode_nlink(sctx->right_path->nodes[0], right_ii);\n\t\tif (new_nlinks == 0 && old_nlinks == 0) {\n\t\t\tsctx->ignore_cur_inode = true;\n\t\t\tgoto out;\n\t\t} else if (new_nlinks == 0 || old_nlinks == 0) {\n\t\t\tsctx->cur_inode_new_gen = 1;\n\t\t}\n\t\t \n\t\tif (sctx->cur_inode_new_gen) {\n\t\t\t \n\t\t\tif (old_nlinks > 0) {\n\t\t\t\tsctx->cur_inode_gen = right_gen;\n\t\t\t\tsctx->cur_inode_new = false;\n\t\t\t\tsctx->cur_inode_deleted = true;\n\t\t\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t\t\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t\t\t\tret = process_all_refs(sctx,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (new_nlinks > 0) {\n\t\t\t\tsctx->cur_inode_gen = left_gen;\n\t\t\t\tsctx->cur_inode_new = true;\n\t\t\t\tsctx->cur_inode_deleted = false;\n\t\t\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\t\t\tsctx->left_path->nodes[0],\n\t\t\t\t\t\tleft_ii);\n\t\t\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\t\t\tsctx->left_path->nodes[0],\n\t\t\t\t\t\tleft_ii);\n\t\t\t\tsctx->cur_inode_rdev = btrfs_inode_rdev(\n\t\t\t\t\t\tsctx->left_path->nodes[0],\n\t\t\t\t\t\tleft_ii);\n\t\t\t\tret = send_create_inode_if_needed(sctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tret = process_all_refs(sctx, BTRFS_COMPARE_TREE_NEW);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\t \n\t\t\t\tsctx->send_progress = sctx->cur_ino + 1;\n\n\t\t\t\t \n\t\t\t\tret = process_all_extents(sctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tret = process_all_new_xattrs(sctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tsctx->cur_inode_gen = left_gen;\n\t\t\tsctx->cur_inode_new = false;\n\t\t\tsctx->cur_inode_new_gen = false;\n\t\t\tsctx->cur_inode_deleted = false;\n\t\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}\n\n \nstatic int changed_ref(struct send_ctx *sctx,\n\t\t       enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\tif (sctx->cur_ino != sctx->cmp_key->objectid) {\n\t\tinconsistent_snapshot_error(sctx, result, \"reference\");\n\t\treturn -EIO;\n\t}\n\n\tif (!sctx->cur_inode_new_gen &&\n\t    sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tif (result == BTRFS_COMPARE_TREE_NEW)\n\t\t\tret = record_new_ref(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_DELETED)\n\t\t\tret = record_deleted_ref(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_CHANGED)\n\t\t\tret = record_changed_ref(sctx);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int changed_xattr(struct send_ctx *sctx,\n\t\t\t enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\tif (sctx->cur_ino != sctx->cmp_key->objectid) {\n\t\tinconsistent_snapshot_error(sctx, result, \"xattr\");\n\t\treturn -EIO;\n\t}\n\n\tif (!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted) {\n\t\tif (result == BTRFS_COMPARE_TREE_NEW)\n\t\t\tret = process_new_xattr(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_DELETED)\n\t\t\tret = process_deleted_xattr(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_CHANGED)\n\t\t\tret = process_changed_xattr(sctx);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int changed_extent(struct send_ctx *sctx,\n\t\t\t  enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\t \n\tif (sctx->cur_ino != sctx->cmp_key->objectid)\n\t\treturn 0;\n\n\tif (!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted) {\n\t\tif (result != BTRFS_COMPARE_TREE_DELETED)\n\t\t\tret = process_extent(sctx, sctx->left_path,\n\t\t\t\t\tsctx->cmp_key);\n\t}\n\n\treturn ret;\n}\n\nstatic int changed_verity(struct send_ctx *sctx, enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\tif (!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted) {\n\t\tif (result == BTRFS_COMPARE_TREE_NEW)\n\t\t\tsctx->cur_inode_needs_verity = true;\n\t}\n\treturn ret;\n}\n\nstatic int dir_changed(struct send_ctx *sctx, u64 dir)\n{\n\tu64 orig_gen, new_gen;\n\tint ret;\n\n\tret = get_inode_gen(sctx->send_root, dir, &new_gen);\n\tif (ret)\n\t\treturn ret;\n\n\tret = get_inode_gen(sctx->parent_root, dir, &orig_gen);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (orig_gen != new_gen) ? 1 : 0;\n}\n\nstatic int compare_refs(struct send_ctx *sctx, struct btrfs_path *path,\n\t\t\tstruct btrfs_key *key)\n{\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\tu64 dirid = 0, last_dirid = 0;\n\tunsigned long ptr;\n\tu32 item_size;\n\tu32 cur_offset = 0;\n\tint ref_name_len;\n\tint ret = 0;\n\n\t \n\tif (key->type == BTRFS_INODE_REF_KEY) {\n\t\tdirid = key->offset;\n\n\t\tret = dir_changed(sctx, dirid);\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size(leaf, path->slots[0]);\n\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\twhile (cur_offset < item_size) {\n\t\textref = (struct btrfs_inode_extref *)(ptr +\n\t\t\t\t\t\t       cur_offset);\n\t\tdirid = btrfs_inode_extref_parent(leaf, extref);\n\t\tref_name_len = btrfs_inode_extref_name_len(leaf, extref);\n\t\tcur_offset += ref_name_len + sizeof(*extref);\n\t\tif (dirid == last_dirid)\n\t\t\tcontinue;\n\t\tret = dir_changed(sctx, dirid);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tlast_dirid = dirid;\n\t}\nout:\n\treturn ret;\n}\n\n \nstatic int changed_cb(struct btrfs_path *left_path,\n\t\t      struct btrfs_path *right_path,\n\t\t      struct btrfs_key *key,\n\t\t      enum btrfs_compare_tree_result result,\n\t\t      struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\t \n\tlockdep_assert_not_held(&sctx->send_root->fs_info->commit_root_sem);\n\n\t \n\tif (left_path->nodes[0])\n\t\tASSERT(test_bit(EXTENT_BUFFER_UNMAPPED,\n\t\t\t\t&left_path->nodes[0]->bflags));\n\t \n\tif (right_path && right_path->nodes[0])\n\t\tASSERT(test_bit(EXTENT_BUFFER_UNMAPPED,\n\t\t\t\t&right_path->nodes[0]->bflags));\n\n\tif (result == BTRFS_COMPARE_TREE_SAME) {\n\t\tif (key->type == BTRFS_INODE_REF_KEY ||\n\t\t    key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\tret = compare_refs(sctx, left_path, key);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t} else if (key->type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\treturn maybe_send_hole(sctx, left_path, key);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tresult = BTRFS_COMPARE_TREE_CHANGED;\n\t\tret = 0;\n\t}\n\n\tsctx->left_path = left_path;\n\tsctx->right_path = right_path;\n\tsctx->cmp_key = key;\n\n\tret = finish_inode_if_needed(sctx, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (key->objectid == BTRFS_FREE_INO_OBJECTID ||\n\t    key->objectid == BTRFS_FREE_SPACE_OBJECTID)\n\t\tgoto out;\n\n\tif (key->type == BTRFS_INODE_ITEM_KEY) {\n\t\tret = changed_inode(sctx, result);\n\t} else if (!sctx->ignore_cur_inode) {\n\t\tif (key->type == BTRFS_INODE_REF_KEY ||\n\t\t    key->type == BTRFS_INODE_EXTREF_KEY)\n\t\t\tret = changed_ref(sctx, result);\n\t\telse if (key->type == BTRFS_XATTR_ITEM_KEY)\n\t\t\tret = changed_xattr(sctx, result);\n\t\telse if (key->type == BTRFS_EXTENT_DATA_KEY)\n\t\t\tret = changed_extent(sctx, result);\n\t\telse if (key->type == BTRFS_VERITY_DESC_ITEM_KEY &&\n\t\t\t key->offset == 0)\n\t\t\tret = changed_verity(sctx, result);\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int search_key_again(const struct send_ctx *sctx,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path,\n\t\t\t    const struct btrfs_key *key)\n{\n\tint ret;\n\n\tif (!path->need_commit_sem)\n\t\tlockdep_assert_held_read(&root->fs_info->commit_root_sem);\n\n\t \n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tASSERT(ret <= 0);\n\tif (ret > 0) {\n\t\tbtrfs_print_tree(path->nodes[path->lowest_level], false);\n\t\tbtrfs_err(root->fs_info,\n\"send: key (%llu %u %llu) not found in %s root %llu, lowest_level %d, slot %d\",\n\t\t\t  key->objectid, key->type, key->offset,\n\t\t\t  (root == sctx->parent_root ? \"parent\" : \"send\"),\n\t\t\t  root->root_key.objectid, path->lowest_level,\n\t\t\t  path->slots[path->lowest_level]);\n\t\treturn -EUCLEAN;\n\t}\n\n\treturn ret;\n}\n\nstatic int full_send_tree(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *send_root = sctx->send_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_fs_info *fs_info = send_root->fs_info;\n\tstruct btrfs_path *path;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = READA_FORWARD_ALWAYS;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tdown_read(&fs_info->commit_root_sem);\n\tsctx->last_reloc_trans = fs_info->last_reloc_trans;\n\tup_read(&fs_info->commit_root_sem);\n\n\tret = btrfs_search_slot_for_read(send_root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret)\n\t\tgoto out_finish;\n\n\twhile (1) {\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\t\tret = changed_cb(path, NULL, &key,\n\t\t\t\t BTRFS_COMPARE_TREE_NEW, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tdown_read(&fs_info->commit_root_sem);\n\t\tif (fs_info->last_reloc_trans > sctx->last_reloc_trans) {\n\t\t\tsctx->last_reloc_trans = fs_info->last_reloc_trans;\n\t\t\tup_read(&fs_info->commit_root_sem);\n\t\t\t \n\t\t\tbtrfs_release_path(path);\n\t\t\tret = search_key_again(sctx, send_root, path, &key);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tup_read(&fs_info->commit_root_sem);\n\t\t}\n\n\t\tret = btrfs_next_item(send_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret  = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_finish:\n\tret = finish_inode_if_needed(sctx, 1);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int replace_node_with_clone(struct btrfs_path *path, int level)\n{\n\tstruct extent_buffer *clone;\n\n\tclone = btrfs_clone_extent_buffer(path->nodes[level]);\n\tif (!clone)\n\t\treturn -ENOMEM;\n\n\tfree_extent_buffer(path->nodes[level]);\n\tpath->nodes[level] = clone;\n\n\treturn 0;\n}\n\nstatic int tree_move_down(struct btrfs_path *path, int *level, u64 reada_min_gen)\n{\n\tstruct extent_buffer *eb;\n\tstruct extent_buffer *parent = path->nodes[*level];\n\tint slot = path->slots[*level];\n\tconst int nritems = btrfs_header_nritems(parent);\n\tu64 reada_max;\n\tu64 reada_done = 0;\n\n\tlockdep_assert_held_read(&parent->fs_info->commit_root_sem);\n\n\tBUG_ON(*level == 0);\n\teb = btrfs_read_node_slot(parent, slot);\n\tif (IS_ERR(eb))\n\t\treturn PTR_ERR(eb);\n\n\t \n\treada_max = (*level == 1 ? SZ_128K : eb->fs_info->nodesize);\n\n\tfor (slot++; slot < nritems && reada_done < reada_max; slot++) {\n\t\tif (btrfs_node_ptr_generation(parent, slot) > reada_min_gen) {\n\t\t\tbtrfs_readahead_node_child(parent, slot);\n\t\t\treada_done += eb->fs_info->nodesize;\n\t\t}\n\t}\n\n\tpath->nodes[*level - 1] = eb;\n\tpath->slots[*level - 1] = 0;\n\t(*level)--;\n\n\tif (*level == 0)\n\t\treturn replace_node_with_clone(path, 0);\n\n\treturn 0;\n}\n\nstatic int tree_move_next_or_upnext(struct btrfs_path *path,\n\t\t\t\t    int *level, int root_level)\n{\n\tint ret = 0;\n\tint nritems;\n\tnritems = btrfs_header_nritems(path->nodes[*level]);\n\n\tpath->slots[*level]++;\n\n\twhile (path->slots[*level] >= nritems) {\n\t\tif (*level == root_level) {\n\t\t\tpath->slots[*level] = nritems - 1;\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tpath->slots[*level] = 0;\n\t\tfree_extent_buffer(path->nodes[*level]);\n\t\tpath->nodes[*level] = NULL;\n\t\t(*level)++;\n\t\tpath->slots[*level]++;\n\n\t\tnritems = btrfs_header_nritems(path->nodes[*level]);\n\t\tret = 1;\n\t}\n\treturn ret;\n}\n\n \nstatic int tree_advance(struct btrfs_path *path,\n\t\t\tint *level, int root_level,\n\t\t\tint allow_down,\n\t\t\tstruct btrfs_key *key,\n\t\t\tu64 reada_min_gen)\n{\n\tint ret;\n\n\tif (*level == 0 || !allow_down) {\n\t\tret = tree_move_next_or_upnext(path, level, root_level);\n\t} else {\n\t\tret = tree_move_down(path, level, reada_min_gen);\n\t}\n\n\t \n\tif (*level == 0)\n\t\tbtrfs_item_key_to_cpu(path->nodes[*level], key,\n\t\t\t\t      path->slots[*level]);\n\telse\n\t\tbtrfs_node_key_to_cpu(path->nodes[*level], key,\n\t\t\t\t      path->slots[*level]);\n\n\treturn ret;\n}\n\nstatic int tree_compare_item(struct btrfs_path *left_path,\n\t\t\t     struct btrfs_path *right_path,\n\t\t\t     char *tmp_buf)\n{\n\tint cmp;\n\tint len1, len2;\n\tunsigned long off1, off2;\n\n\tlen1 = btrfs_item_size(left_path->nodes[0], left_path->slots[0]);\n\tlen2 = btrfs_item_size(right_path->nodes[0], right_path->slots[0]);\n\tif (len1 != len2)\n\t\treturn 1;\n\n\toff1 = btrfs_item_ptr_offset(left_path->nodes[0], left_path->slots[0]);\n\toff2 = btrfs_item_ptr_offset(right_path->nodes[0],\n\t\t\t\tright_path->slots[0]);\n\n\tread_extent_buffer(left_path->nodes[0], tmp_buf, off1, len1);\n\n\tcmp = memcmp_extent_buffer(right_path->nodes[0], tmp_buf, off2, len1);\n\tif (cmp)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int restart_after_relocation(struct btrfs_path *left_path,\n\t\t\t\t    struct btrfs_path *right_path,\n\t\t\t\t    const struct btrfs_key *left_key,\n\t\t\t\t    const struct btrfs_key *right_key,\n\t\t\t\t    int left_level,\n\t\t\t\t    int right_level,\n\t\t\t\t    const struct send_ctx *sctx)\n{\n\tint root_level;\n\tint ret;\n\n\tlockdep_assert_held_read(&sctx->send_root->fs_info->commit_root_sem);\n\n\tbtrfs_release_path(left_path);\n\tbtrfs_release_path(right_path);\n\n\t \n\tleft_path->lowest_level = left_level;\n\tret = search_key_again(sctx, sctx->send_root, left_path, left_key);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tright_path->lowest_level = right_level;\n\tret = search_key_again(sctx, sctx->parent_root, right_path, right_key);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (left_level == 0) {\n\t\tret = replace_node_with_clone(left_path, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (right_level == 0) {\n\t\tret = replace_node_with_clone(right_path, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\troot_level = btrfs_header_level(sctx->send_root->commit_root);\n\tif (root_level > 0) {\n\t\tret = replace_node_with_clone(left_path, root_level);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\troot_level = btrfs_header_level(sctx->parent_root->commit_root);\n\tif (root_level > 0) {\n\t\tret = replace_node_with_clone(right_path, root_level);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int btrfs_compare_trees(struct btrfs_root *left_root,\n\t\t\tstruct btrfs_root *right_root, struct send_ctx *sctx)\n{\n\tstruct btrfs_fs_info *fs_info = left_root->fs_info;\n\tint ret;\n\tint cmp;\n\tstruct btrfs_path *left_path = NULL;\n\tstruct btrfs_path *right_path = NULL;\n\tstruct btrfs_key left_key;\n\tstruct btrfs_key right_key;\n\tchar *tmp_buf = NULL;\n\tint left_root_level;\n\tint right_root_level;\n\tint left_level;\n\tint right_level;\n\tint left_end_reached = 0;\n\tint right_end_reached = 0;\n\tint advance_left = 0;\n\tint advance_right = 0;\n\tu64 left_blockptr;\n\tu64 right_blockptr;\n\tu64 left_gen;\n\tu64 right_gen;\n\tu64 reada_min_gen;\n\n\tleft_path = btrfs_alloc_path();\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tright_path = btrfs_alloc_path();\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttmp_buf = kvmalloc(fs_info->nodesize, GFP_KERNEL);\n\tif (!tmp_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tleft_path->search_commit_root = 1;\n\tleft_path->skip_locking = 1;\n\tright_path->search_commit_root = 1;\n\tright_path->skip_locking = 1;\n\n\t \n\n\tdown_read(&fs_info->commit_root_sem);\n\tleft_level = btrfs_header_level(left_root->commit_root);\n\tleft_root_level = left_level;\n\t \n\tleft_path->nodes[left_level] =\n\t\t\tbtrfs_clone_extent_buffer(left_root->commit_root);\n\tif (!left_path->nodes[left_level]) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tright_level = btrfs_header_level(right_root->commit_root);\n\tright_root_level = right_level;\n\tright_path->nodes[right_level] =\n\t\t\tbtrfs_clone_extent_buffer(right_root->commit_root);\n\tif (!right_path->nodes[right_level]) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\t \n\treada_min_gen = btrfs_header_generation(right_root->commit_root);\n\n\tif (left_level == 0)\n\t\tbtrfs_item_key_to_cpu(left_path->nodes[left_level],\n\t\t\t\t&left_key, left_path->slots[left_level]);\n\telse\n\t\tbtrfs_node_key_to_cpu(left_path->nodes[left_level],\n\t\t\t\t&left_key, left_path->slots[left_level]);\n\tif (right_level == 0)\n\t\tbtrfs_item_key_to_cpu(right_path->nodes[right_level],\n\t\t\t\t&right_key, right_path->slots[right_level]);\n\telse\n\t\tbtrfs_node_key_to_cpu(right_path->nodes[right_level],\n\t\t\t\t&right_key, right_path->slots[right_level]);\n\n\tsctx->last_reloc_trans = fs_info->last_reloc_trans;\n\n\twhile (1) {\n\t\tif (need_resched() ||\n\t\t    rwsem_is_contended(&fs_info->commit_root_sem)) {\n\t\t\tup_read(&fs_info->commit_root_sem);\n\t\t\tcond_resched();\n\t\t\tdown_read(&fs_info->commit_root_sem);\n\t\t}\n\n\t\tif (fs_info->last_reloc_trans > sctx->last_reloc_trans) {\n\t\t\tret = restart_after_relocation(left_path, right_path,\n\t\t\t\t\t\t       &left_key, &right_key,\n\t\t\t\t\t\t       left_level, right_level,\n\t\t\t\t\t\t       sctx);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_unlock;\n\t\t\tsctx->last_reloc_trans = fs_info->last_reloc_trans;\n\t\t}\n\n\t\tif (advance_left && !left_end_reached) {\n\t\t\tret = tree_advance(left_path, &left_level,\n\t\t\t\t\tleft_root_level,\n\t\t\t\t\tadvance_left != ADVANCE_ONLY_NEXT,\n\t\t\t\t\t&left_key, reada_min_gen);\n\t\t\tif (ret == -1)\n\t\t\t\tleft_end_reached = ADVANCE;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto out_unlock;\n\t\t\tadvance_left = 0;\n\t\t}\n\t\tif (advance_right && !right_end_reached) {\n\t\t\tret = tree_advance(right_path, &right_level,\n\t\t\t\t\tright_root_level,\n\t\t\t\t\tadvance_right != ADVANCE_ONLY_NEXT,\n\t\t\t\t\t&right_key, reada_min_gen);\n\t\t\tif (ret == -1)\n\t\t\t\tright_end_reached = ADVANCE;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto out_unlock;\n\t\t\tadvance_right = 0;\n\t\t}\n\n\t\tif (left_end_reached && right_end_reached) {\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t} else if (left_end_reached) {\n\t\t\tif (right_level == 0) {\n\t\t\t\tup_read(&fs_info->commit_root_sem);\n\t\t\t\tret = changed_cb(left_path, right_path,\n\t\t\t\t\t\t&right_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED,\n\t\t\t\t\t\tsctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tdown_read(&fs_info->commit_root_sem);\n\t\t\t}\n\t\t\tadvance_right = ADVANCE;\n\t\t\tcontinue;\n\t\t} else if (right_end_reached) {\n\t\t\tif (left_level == 0) {\n\t\t\t\tup_read(&fs_info->commit_root_sem);\n\t\t\t\tret = changed_cb(left_path, right_path,\n\t\t\t\t\t\t&left_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_NEW,\n\t\t\t\t\t\tsctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tdown_read(&fs_info->commit_root_sem);\n\t\t\t}\n\t\t\tadvance_left = ADVANCE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (left_level == 0 && right_level == 0) {\n\t\t\tup_read(&fs_info->commit_root_sem);\n\t\t\tcmp = btrfs_comp_cpu_keys(&left_key, &right_key);\n\t\t\tif (cmp < 0) {\n\t\t\t\tret = changed_cb(left_path, right_path,\n\t\t\t\t\t\t&left_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_NEW,\n\t\t\t\t\t\tsctx);\n\t\t\t\tadvance_left = ADVANCE;\n\t\t\t} else if (cmp > 0) {\n\t\t\t\tret = changed_cb(left_path, right_path,\n\t\t\t\t\t\t&right_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED,\n\t\t\t\t\t\tsctx);\n\t\t\t\tadvance_right = ADVANCE;\n\t\t\t} else {\n\t\t\t\tenum btrfs_compare_tree_result result;\n\n\t\t\t\tWARN_ON(!extent_buffer_uptodate(left_path->nodes[0]));\n\t\t\t\tret = tree_compare_item(left_path, right_path,\n\t\t\t\t\t\t\ttmp_buf);\n\t\t\t\tif (ret)\n\t\t\t\t\tresult = BTRFS_COMPARE_TREE_CHANGED;\n\t\t\t\telse\n\t\t\t\t\tresult = BTRFS_COMPARE_TREE_SAME;\n\t\t\t\tret = changed_cb(left_path, right_path,\n\t\t\t\t\t\t &left_key, result, sctx);\n\t\t\t\tadvance_left = ADVANCE;\n\t\t\t\tadvance_right = ADVANCE;\n\t\t\t}\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tdown_read(&fs_info->commit_root_sem);\n\t\t} else if (left_level == right_level) {\n\t\t\tcmp = btrfs_comp_cpu_keys(&left_key, &right_key);\n\t\t\tif (cmp < 0) {\n\t\t\t\tadvance_left = ADVANCE;\n\t\t\t} else if (cmp > 0) {\n\t\t\t\tadvance_right = ADVANCE;\n\t\t\t} else {\n\t\t\t\tleft_blockptr = btrfs_node_blockptr(\n\t\t\t\t\t\tleft_path->nodes[left_level],\n\t\t\t\t\t\tleft_path->slots[left_level]);\n\t\t\t\tright_blockptr = btrfs_node_blockptr(\n\t\t\t\t\t\tright_path->nodes[right_level],\n\t\t\t\t\t\tright_path->slots[right_level]);\n\t\t\t\tleft_gen = btrfs_node_ptr_generation(\n\t\t\t\t\t\tleft_path->nodes[left_level],\n\t\t\t\t\t\tleft_path->slots[left_level]);\n\t\t\t\tright_gen = btrfs_node_ptr_generation(\n\t\t\t\t\t\tright_path->nodes[right_level],\n\t\t\t\t\t\tright_path->slots[right_level]);\n\t\t\t\tif (left_blockptr == right_blockptr &&\n\t\t\t\t    left_gen == right_gen) {\n\t\t\t\t\t \n\t\t\t\t\tadvance_left = ADVANCE_ONLY_NEXT;\n\t\t\t\t\tadvance_right = ADVANCE_ONLY_NEXT;\n\t\t\t\t} else {\n\t\t\t\t\tadvance_left = ADVANCE;\n\t\t\t\t\tadvance_right = ADVANCE;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (left_level < right_level) {\n\t\t\tadvance_right = ADVANCE;\n\t\t} else {\n\t\t\tadvance_left = ADVANCE;\n\t\t}\n\t}\n\nout_unlock:\n\tup_read(&fs_info->commit_root_sem);\nout:\n\tbtrfs_free_path(left_path);\n\tbtrfs_free_path(right_path);\n\tkvfree(tmp_buf);\n\treturn ret;\n}\n\nstatic int send_subvol(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tif (!(sctx->flags & BTRFS_SEND_FLAG_OMIT_STREAM_HEADER)) {\n\t\tret = send_header(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = send_subvol_begin(sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (sctx->parent_root) {\n\t\tret = btrfs_compare_trees(sctx->send_root, sctx->parent_root, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = finish_inode_if_needed(sctx, 1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tret = full_send_tree(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tfree_recorded_refs(sctx);\n\treturn ret;\n}\n\n \nstatic int ensure_commit_roots_uptodate(struct send_ctx *sctx)\n{\n\tint i;\n\tstruct btrfs_trans_handle *trans = NULL;\n\nagain:\n\tif (sctx->parent_root &&\n\t    sctx->parent_root->node != sctx->parent_root->commit_root)\n\t\tgoto commit_trans;\n\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++)\n\t\tif (sctx->clone_roots[i].root->node !=\n\t\t    sctx->clone_roots[i].root->commit_root)\n\t\t\tgoto commit_trans;\n\n\tif (trans)\n\t\treturn btrfs_end_transaction(trans);\n\n\treturn 0;\n\ncommit_trans:\n\t \n\tif (!trans) {\n\t\ttrans = btrfs_join_transaction(sctx->send_root);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t\tgoto again;\n\t}\n\n\treturn btrfs_commit_transaction(trans);\n}\n\n \nstatic int flush_delalloc_roots(struct send_ctx *sctx)\n{\n\tstruct btrfs_root *root = sctx->parent_root;\n\tint ret;\n\tint i;\n\n\tif (root) {\n\t\tret = btrfs_start_delalloc_snapshot(root, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbtrfs_wait_ordered_extents(root, U64_MAX, 0, U64_MAX);\n\t}\n\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++) {\n\t\troot = sctx->clone_roots[i].root;\n\t\tret = btrfs_start_delalloc_snapshot(root, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbtrfs_wait_ordered_extents(root, U64_MAX, 0, U64_MAX);\n\t}\n\n\treturn 0;\n}\n\nstatic void btrfs_root_dec_send_in_progress(struct btrfs_root* root)\n{\n\tspin_lock(&root->root_item_lock);\n\troot->send_in_progress--;\n\t \n\tif (root->send_in_progress < 0)\n\t\tbtrfs_err(root->fs_info,\n\t\t\t  \"send_in_progress unbalanced %d root %llu\",\n\t\t\t  root->send_in_progress, root->root_key.objectid);\n\tspin_unlock(&root->root_item_lock);\n}\n\nstatic void dedupe_in_progress_warn(const struct btrfs_root *root)\n{\n\tbtrfs_warn_rl(root->fs_info,\n\"cannot use root %llu for send while deduplications on it are in progress (%d in progress)\",\n\t\t      root->root_key.objectid, root->dedupe_in_progress);\n}\n\nlong btrfs_ioctl_send(struct inode *inode, struct btrfs_ioctl_send_args *arg)\n{\n\tint ret = 0;\n\tstruct btrfs_root *send_root = BTRFS_I(inode)->root;\n\tstruct btrfs_fs_info *fs_info = send_root->fs_info;\n\tstruct btrfs_root *clone_root;\n\tstruct send_ctx *sctx = NULL;\n\tu32 i;\n\tu64 *clone_sources_tmp = NULL;\n\tint clone_sources_to_rollback = 0;\n\tsize_t alloc_size;\n\tint sort_clone_roots = 0;\n\tstruct btrfs_lru_cache_entry *entry;\n\tstruct btrfs_lru_cache_entry *tmp;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t \n\tspin_lock(&send_root->root_item_lock);\n\tif (btrfs_root_readonly(send_root) && send_root->dedupe_in_progress) {\n\t\tdedupe_in_progress_warn(send_root);\n\t\tspin_unlock(&send_root->root_item_lock);\n\t\treturn -EAGAIN;\n\t}\n\tsend_root->send_in_progress++;\n\tspin_unlock(&send_root->root_item_lock);\n\n\t \n\tif (!btrfs_root_readonly(send_root)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\t \n\tif (arg->clone_sources_count > SZ_8M / sizeof(struct clone_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (arg->flags & ~BTRFS_SEND_FLAG_MASK) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsctx = kzalloc(sizeof(struct send_ctx), GFP_KERNEL);\n\tif (!sctx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&sctx->new_refs);\n\tINIT_LIST_HEAD(&sctx->deleted_refs);\n\n\tbtrfs_lru_cache_init(&sctx->name_cache, SEND_MAX_NAME_CACHE_SIZE);\n\tbtrfs_lru_cache_init(&sctx->backref_cache, SEND_MAX_BACKREF_CACHE_SIZE);\n\tbtrfs_lru_cache_init(&sctx->dir_created_cache,\n\t\t\t     SEND_MAX_DIR_CREATED_CACHE_SIZE);\n\t \n\tbtrfs_lru_cache_init(&sctx->dir_utimes_cache, 0);\n\n\tsctx->pending_dir_moves = RB_ROOT;\n\tsctx->waiting_dir_moves = RB_ROOT;\n\tsctx->orphan_dirs = RB_ROOT;\n\tsctx->rbtree_new_refs = RB_ROOT;\n\tsctx->rbtree_deleted_refs = RB_ROOT;\n\n\tsctx->flags = arg->flags;\n\n\tif (arg->flags & BTRFS_SEND_FLAG_VERSION) {\n\t\tif (arg->version > BTRFS_SEND_STREAM_VERSION) {\n\t\t\tret = -EPROTO;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tsctx->proto = arg->version ?: BTRFS_SEND_STREAM_VERSION;\n\t} else {\n\t\tsctx->proto = 1;\n\t}\n\tif ((arg->flags & BTRFS_SEND_FLAG_COMPRESSED) && sctx->proto < 2) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsctx->send_filp = fget(arg->send_fd);\n\tif (!sctx->send_filp || !(sctx->send_filp->f_mode & FMODE_WRITE)) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tsctx->send_root = send_root;\n\t \n\tif (btrfs_root_dead(sctx->send_root)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tsctx->clone_roots_cnt = arg->clone_sources_count;\n\n\tif (sctx->proto >= 2) {\n\t\tu32 send_buf_num_pages;\n\n\t\tsctx->send_max_size = BTRFS_SEND_BUF_SIZE_V2;\n\t\tsctx->send_buf = vmalloc(sctx->send_max_size);\n\t\tif (!sctx->send_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tsend_buf_num_pages = sctx->send_max_size >> PAGE_SHIFT;\n\t\tsctx->send_buf_pages = kcalloc(send_buf_num_pages,\n\t\t\t\t\t       sizeof(*sctx->send_buf_pages),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!sctx->send_buf_pages) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfor (i = 0; i < send_buf_num_pages; i++) {\n\t\t\tsctx->send_buf_pages[i] =\n\t\t\t\tvmalloc_to_page(sctx->send_buf + (i << PAGE_SHIFT));\n\t\t}\n\t} else {\n\t\tsctx->send_max_size = BTRFS_SEND_BUF_SIZE_V1;\n\t\tsctx->send_buf = kvmalloc(sctx->send_max_size, GFP_KERNEL);\n\t}\n\tif (!sctx->send_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsctx->clone_roots = kvcalloc(sizeof(*sctx->clone_roots),\n\t\t\t\t     arg->clone_sources_count + 1,\n\t\t\t\t     GFP_KERNEL);\n\tif (!sctx->clone_roots) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\talloc_size = array_size(sizeof(*arg->clone_sources),\n\t\t\t\targ->clone_sources_count);\n\n\tif (arg->clone_sources_count) {\n\t\tclone_sources_tmp = kvmalloc(alloc_size, GFP_KERNEL);\n\t\tif (!clone_sources_tmp) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = copy_from_user(clone_sources_tmp, arg->clone_sources,\n\t\t\t\talloc_size);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < arg->clone_sources_count; i++) {\n\t\t\tclone_root = btrfs_get_fs_root(fs_info,\n\t\t\t\t\t\tclone_sources_tmp[i], true);\n\t\t\tif (IS_ERR(clone_root)) {\n\t\t\t\tret = PTR_ERR(clone_root);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tspin_lock(&clone_root->root_item_lock);\n\t\t\tif (!btrfs_root_readonly(clone_root) ||\n\t\t\t    btrfs_root_dead(clone_root)) {\n\t\t\t\tspin_unlock(&clone_root->root_item_lock);\n\t\t\t\tbtrfs_put_root(clone_root);\n\t\t\t\tret = -EPERM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (clone_root->dedupe_in_progress) {\n\t\t\t\tdedupe_in_progress_warn(clone_root);\n\t\t\t\tspin_unlock(&clone_root->root_item_lock);\n\t\t\t\tbtrfs_put_root(clone_root);\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tclone_root->send_in_progress++;\n\t\t\tspin_unlock(&clone_root->root_item_lock);\n\n\t\t\tsctx->clone_roots[i].root = clone_root;\n\t\t\tclone_sources_to_rollback = i + 1;\n\t\t}\n\t\tkvfree(clone_sources_tmp);\n\t\tclone_sources_tmp = NULL;\n\t}\n\n\tif (arg->parent_root) {\n\t\tsctx->parent_root = btrfs_get_fs_root(fs_info, arg->parent_root,\n\t\t\t\t\t\t      true);\n\t\tif (IS_ERR(sctx->parent_root)) {\n\t\t\tret = PTR_ERR(sctx->parent_root);\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock(&sctx->parent_root->root_item_lock);\n\t\tsctx->parent_root->send_in_progress++;\n\t\tif (!btrfs_root_readonly(sctx->parent_root) ||\n\t\t\t\tbtrfs_root_dead(sctx->parent_root)) {\n\t\t\tspin_unlock(&sctx->parent_root->root_item_lock);\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sctx->parent_root->dedupe_in_progress) {\n\t\t\tdedupe_in_progress_warn(sctx->parent_root);\n\t\t\tspin_unlock(&sctx->parent_root->root_item_lock);\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&sctx->parent_root->root_item_lock);\n\t}\n\n\t \n\tsctx->clone_roots[sctx->clone_roots_cnt++].root =\n\t\tbtrfs_grab_root(sctx->send_root);\n\n\t \n\tsort(sctx->clone_roots, sctx->clone_roots_cnt,\n\t\t\tsizeof(*sctx->clone_roots), __clone_root_cmp_sort,\n\t\t\tNULL);\n\tsort_clone_roots = 1;\n\n\tret = flush_delalloc_roots(sctx);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ensure_commit_roots_uptodate(sctx);\n\tif (ret)\n\t\tgoto out;\n\n\tret = send_subvol(sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tbtrfs_lru_cache_for_each_entry_safe(&sctx->dir_utimes_cache, entry, tmp) {\n\t\tret = send_utimes(sctx, entry->key, entry->gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbtrfs_lru_cache_remove(&sctx->dir_utimes_cache, entry);\n\t}\n\n\tif (!(sctx->flags & BTRFS_SEND_FLAG_OMIT_END_CMD)) {\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_END);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = send_cmd(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tWARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->pending_dir_moves));\n\twhile (sctx && !RB_EMPTY_ROOT(&sctx->pending_dir_moves)) {\n\t\tstruct rb_node *n;\n\t\tstruct pending_dir_move *pm;\n\n\t\tn = rb_first(&sctx->pending_dir_moves);\n\t\tpm = rb_entry(n, struct pending_dir_move, node);\n\t\twhile (!list_empty(&pm->list)) {\n\t\t\tstruct pending_dir_move *pm2;\n\n\t\t\tpm2 = list_first_entry(&pm->list,\n\t\t\t\t\t       struct pending_dir_move, list);\n\t\t\tfree_pending_move(sctx, pm2);\n\t\t}\n\t\tfree_pending_move(sctx, pm);\n\t}\n\n\tWARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->waiting_dir_moves));\n\twhile (sctx && !RB_EMPTY_ROOT(&sctx->waiting_dir_moves)) {\n\t\tstruct rb_node *n;\n\t\tstruct waiting_dir_move *dm;\n\n\t\tn = rb_first(&sctx->waiting_dir_moves);\n\t\tdm = rb_entry(n, struct waiting_dir_move, node);\n\t\trb_erase(&dm->node, &sctx->waiting_dir_moves);\n\t\tkfree(dm);\n\t}\n\n\tWARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->orphan_dirs));\n\twhile (sctx && !RB_EMPTY_ROOT(&sctx->orphan_dirs)) {\n\t\tstruct rb_node *n;\n\t\tstruct orphan_dir_info *odi;\n\n\t\tn = rb_first(&sctx->orphan_dirs);\n\t\todi = rb_entry(n, struct orphan_dir_info, node);\n\t\tfree_orphan_dir_info(sctx, odi);\n\t}\n\n\tif (sort_clone_roots) {\n\t\tfor (i = 0; i < sctx->clone_roots_cnt; i++) {\n\t\t\tbtrfs_root_dec_send_in_progress(\n\t\t\t\t\tsctx->clone_roots[i].root);\n\t\t\tbtrfs_put_root(sctx->clone_roots[i].root);\n\t\t}\n\t} else {\n\t\tfor (i = 0; sctx && i < clone_sources_to_rollback; i++) {\n\t\t\tbtrfs_root_dec_send_in_progress(\n\t\t\t\t\tsctx->clone_roots[i].root);\n\t\t\tbtrfs_put_root(sctx->clone_roots[i].root);\n\t\t}\n\n\t\tbtrfs_root_dec_send_in_progress(send_root);\n\t}\n\tif (sctx && !IS_ERR_OR_NULL(sctx->parent_root)) {\n\t\tbtrfs_root_dec_send_in_progress(sctx->parent_root);\n\t\tbtrfs_put_root(sctx->parent_root);\n\t}\n\n\tkvfree(clone_sources_tmp);\n\n\tif (sctx) {\n\t\tif (sctx->send_filp)\n\t\t\tfput(sctx->send_filp);\n\n\t\tkvfree(sctx->clone_roots);\n\t\tkfree(sctx->send_buf_pages);\n\t\tkvfree(sctx->send_buf);\n\t\tkvfree(sctx->verity_descriptor);\n\n\t\tclose_current_inode(sctx);\n\n\t\tbtrfs_lru_cache_clear(&sctx->name_cache);\n\t\tbtrfs_lru_cache_clear(&sctx->backref_cache);\n\t\tbtrfs_lru_cache_clear(&sctx->dir_created_cache);\n\t\tbtrfs_lru_cache_clear(&sctx->dir_utimes_cache);\n\n\t\tkfree(sctx);\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}