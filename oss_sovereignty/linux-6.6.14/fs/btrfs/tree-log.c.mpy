{
  "module_name": "tree-log.c",
  "hash_id": "64b691b5fa445741a75466077cc0d9e66fe415c5d9696cb3f07819594e57c460",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/tree-log.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/list_sort.h>\n#include <linux/iversion.h>\n#include \"misc.h\"\n#include \"ctree.h\"\n#include \"tree-log.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"backref.h\"\n#include \"compression.h\"\n#include \"qgroup.h\"\n#include \"block-group.h\"\n#include \"space-info.h\"\n#include \"zoned.h\"\n#include \"inode-item.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n#include \"extent-tree.h\"\n#include \"root-tree.h\"\n#include \"dir-item.h\"\n#include \"file-item.h\"\n#include \"file.h\"\n#include \"orphan.h\"\n#include \"tree-checker.h\"\n\n#define MAX_CONFLICT_INODES 10\n\n \nenum {\n\tLOG_INODE_ALL,\n\tLOG_INODE_EXISTS,\n};\n\n \n\n \nenum {\n\tLOG_WALK_PIN_ONLY,\n\tLOG_WALK_REPLAY_INODES,\n\tLOG_WALK_REPLAY_DIR_INDEX,\n\tLOG_WALK_REPLAY_ALL,\n};\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline int replay_dir_deletes(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       u64 dirid, int del_all);\nstatic void wait_log_commit(struct btrfs_root *root, int transid);\n\n \n\n \nstatic int start_log_trans(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tconst bool zoned = btrfs_is_zoned(fs_info);\n\tint ret = 0;\n\tbool created = false;\n\n\t \n\tif (!test_bit(BTRFS_ROOT_HAS_LOG_TREE, &tree_root->state)) {\n\t\tmutex_lock(&tree_root->log_mutex);\n\t\tif (!fs_info->log_root_tree) {\n\t\t\tret = btrfs_init_log_root_tree(trans, fs_info);\n\t\t\tif (!ret) {\n\t\t\t\tset_bit(BTRFS_ROOT_HAS_LOG_TREE, &tree_root->state);\n\t\t\t\tcreated = true;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&tree_root->log_mutex);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&root->log_mutex);\n\nagain:\n\tif (root->log_root) {\n\t\tint index = (root->log_transid + 1) % 2;\n\n\t\tif (btrfs_need_log_full_commit(trans)) {\n\t\t\tret = BTRFS_LOG_FORCE_COMMIT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (zoned && atomic_read(&root->log_commit[index])) {\n\t\t\twait_log_commit(root, root->log_transid - 1);\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (!root->log_start_pid) {\n\t\t\tclear_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);\n\t\t\troot->log_start_pid = current->pid;\n\t\t} else if (root->log_start_pid != current->pid) {\n\t\t\tset_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);\n\t\t}\n\t} else {\n\t\t \n\t\tif (zoned && !created) {\n\t\t\tret = BTRFS_LOG_FORCE_COMMIT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_add_log_tree(trans, root);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tset_bit(BTRFS_ROOT_HAS_LOG_TREE, &root->state);\n\t\tclear_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);\n\t\troot->log_start_pid = current->pid;\n\t}\n\n\tatomic_inc(&root->log_writers);\n\tif (!ctx->logging_new_name) {\n\t\tint index = root->log_transid % 2;\n\t\tlist_add_tail(&ctx->list, &root->log_ctxs[index]);\n\t\tctx->log_transid = root->log_transid;\n\t}\n\nout:\n\tmutex_unlock(&root->log_mutex);\n\treturn ret;\n}\n\n \nstatic int join_running_log_trans(struct btrfs_root *root)\n{\n\tconst bool zoned = btrfs_is_zoned(root->fs_info);\n\tint ret = -ENOENT;\n\n\tif (!test_bit(BTRFS_ROOT_HAS_LOG_TREE, &root->state))\n\t\treturn ret;\n\n\tmutex_lock(&root->log_mutex);\nagain:\n\tif (root->log_root) {\n\t\tint index = (root->log_transid + 1) % 2;\n\n\t\tret = 0;\n\t\tif (zoned && atomic_read(&root->log_commit[index])) {\n\t\t\twait_log_commit(root, root->log_transid - 1);\n\t\t\tgoto again;\n\t\t}\n\t\tatomic_inc(&root->log_writers);\n\t}\n\tmutex_unlock(&root->log_mutex);\n\treturn ret;\n}\n\n \nvoid btrfs_pin_log_trans(struct btrfs_root *root)\n{\n\tatomic_inc(&root->log_writers);\n}\n\n \nvoid btrfs_end_log_trans(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->log_writers)) {\n\t\t \n\t\tcond_wake_up_nomb(&root->log_writer_wait);\n\t}\n}\n\n \nstruct walk_control {\n\t \n\tint free;\n\n\t \n\tint pin;\n\n\t \n\tint stage;\n\n\t \n\tbool ignore_cur_inode;\n\n\t \n\tstruct btrfs_root *replay_dest;\n\n\t \n\tstruct btrfs_trans_handle *trans;\n\n\t \n\tint (*process_func)(struct btrfs_root *log, struct extent_buffer *eb,\n\t\t\t    struct walk_control *wc, u64 gen, int level);\n};\n\n \nstatic int process_one_buffer(struct btrfs_root *log,\n\t\t\t      struct extent_buffer *eb,\n\t\t\t      struct walk_control *wc, u64 gen, int level)\n{\n\tstruct btrfs_fs_info *fs_info = log->fs_info;\n\tint ret = 0;\n\n\t \n\tif (btrfs_fs_incompat(fs_info, MIXED_GROUPS)) {\n\t\tstruct btrfs_tree_parent_check check = {\n\t\t\t.level = level,\n\t\t\t.transid = gen\n\t\t};\n\n\t\tret = btrfs_read_extent_buffer(eb, &check);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (wc->pin) {\n\t\tret = btrfs_pin_extent_for_log_replay(wc->trans, eb->start,\n\t\t\t\t\t\t      eb->len);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (btrfs_buffer_uptodate(eb, gen, 0) &&\n\t\t    btrfs_header_level(eb) == 0)\n\t\t\tret = btrfs_exclude_logged_extents(eb);\n\t}\n\treturn ret;\n}\n\n \nstatic int overwrite_item(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct extent_buffer *eb, int slot,\n\t\t\t  struct btrfs_key *key)\n{\n\tint ret;\n\tu32 item_size;\n\tu64 saved_i_size = 0;\n\tint save_old_i_size = 0;\n\tunsigned long src_ptr;\n\tunsigned long dst_ptr;\n\tbool inode_item = key->type == BTRFS_INODE_ITEM_KEY;\n\n\t \n\tASSERT(root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID);\n\n\titem_size = btrfs_item_size(eb, slot);\n\tsrc_ptr = btrfs_item_ptr_offset(eb, slot);\n\n\t \n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0) {\n\t\tchar *src_copy;\n\t\tchar *dst_copy;\n\t\tu32 dst_size = btrfs_item_size(path->nodes[0],\n\t\t\t\t\t\t  path->slots[0]);\n\t\tif (dst_size != item_size)\n\t\t\tgoto insert;\n\n\t\tif (item_size == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\t\tdst_copy = kmalloc(item_size, GFP_NOFS);\n\t\tsrc_copy = kmalloc(item_size, GFP_NOFS);\n\t\tif (!dst_copy || !src_copy) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tkfree(dst_copy);\n\t\t\tkfree(src_copy);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tread_extent_buffer(eb, src_copy, src_ptr, item_size);\n\n\t\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tread_extent_buffer(path->nodes[0], dst_copy, dst_ptr,\n\t\t\t\t   item_size);\n\t\tret = memcmp(dst_copy, src_copy, item_size);\n\n\t\tkfree(dst_copy);\n\t\tkfree(src_copy);\n\t\t \n\t\tif (ret == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (inode_item) {\n\t\t\tstruct btrfs_inode_item *item;\n\t\t\tu64 nbytes;\n\t\t\tu32 mode;\n\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tnbytes = btrfs_inode_nbytes(path->nodes[0], item);\n\t\t\titem = btrfs_item_ptr(eb, slot,\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tbtrfs_set_inode_nbytes(eb, item, nbytes);\n\n\t\t\t \n\t\t\tmode = btrfs_inode_mode(eb, item);\n\t\t\tif (S_ISDIR(mode))\n\t\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t\t}\n\t} else if (inode_item) {\n\t\tstruct btrfs_inode_item *item;\n\t\tu32 mode;\n\n\t\t \n\t\titem = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\t\tbtrfs_set_inode_nbytes(eb, item, 0);\n\n\t\t \n\t\tmode = btrfs_inode_mode(eb, item);\n\t\tif (S_ISDIR(mode))\n\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t}\ninsert:\n\tbtrfs_release_path(path);\n\t \n\tpath->skip_release_on_error = 1;\n\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t      key, item_size);\n\tpath->skip_release_on_error = 0;\n\n\t \n\tif (ret == -EEXIST || ret == -EOVERFLOW) {\n\t\tu32 found_size;\n\t\tfound_size = btrfs_item_size(path->nodes[0],\n\t\t\t\t\t\tpath->slots[0]);\n\t\tif (found_size > item_size)\n\t\t\tbtrfs_truncate_item(trans, path, item_size, 1);\n\t\telse if (found_size < item_size)\n\t\t\tbtrfs_extend_item(trans, path, item_size - found_size);\n\t} else if (ret) {\n\t\treturn ret;\n\t}\n\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\tpath->slots[0]);\n\n\t \n\tif (key->type == BTRFS_INODE_ITEM_KEY && ret == -EEXIST) {\n\t\tstruct btrfs_inode_item *src_item;\n\t\tstruct btrfs_inode_item *dst_item;\n\n\t\tsrc_item = (struct btrfs_inode_item *)src_ptr;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\n\t\tif (btrfs_inode_generation(eb, src_item) == 0) {\n\t\t\tstruct extent_buffer *dst_eb = path->nodes[0];\n\t\t\tconst u64 ino_size = btrfs_inode_size(eb, src_item);\n\n\t\t\t \n\t\t\tif (S_ISREG(btrfs_inode_mode(eb, src_item)) &&\n\t\t\t    S_ISREG(btrfs_inode_mode(dst_eb, dst_item)) &&\n\t\t\t    ino_size != 0)\n\t\t\t\tbtrfs_set_inode_size(dst_eb, dst_item, ino_size);\n\t\t\tgoto no_copy;\n\t\t}\n\n\t\tif (S_ISDIR(btrfs_inode_mode(eb, src_item)) &&\n\t\t    S_ISDIR(btrfs_inode_mode(path->nodes[0], dst_item))) {\n\t\t\tsave_old_i_size = 1;\n\t\t\tsaved_i_size = btrfs_inode_size(path->nodes[0],\n\t\t\t\t\t\t\tdst_item);\n\t\t}\n\t}\n\n\tcopy_extent_buffer(path->nodes[0], eb, dst_ptr,\n\t\t\t   src_ptr, item_size);\n\n\tif (save_old_i_size) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tbtrfs_set_inode_size(path->nodes[0], dst_item, saved_i_size);\n\t}\n\n\t \n\tif (key->type == BTRFS_INODE_ITEM_KEY) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tif (btrfs_inode_generation(path->nodes[0], dst_item) == 0) {\n\t\t\tbtrfs_set_inode_generation(path->nodes[0], dst_item,\n\t\t\t\t\t\t   trans->transid);\n\t\t}\n\t}\nno_copy:\n\tbtrfs_mark_buffer_dirty(trans, path->nodes[0]);\n\tbtrfs_release_path(path);\n\treturn 0;\n}\n\nstatic int read_alloc_one_name(struct extent_buffer *eb, void *start, int len,\n\t\t\t       struct fscrypt_str *name)\n{\n\tchar *buf;\n\n\tbuf = kmalloc(len, GFP_NOFS);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(eb, buf, (unsigned long)start, len);\n\tname->name = buf;\n\tname->len = len;\n\treturn 0;\n}\n\n \nstatic noinline struct inode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget(root->fs_info->sb, objectid, root);\n\tif (IS_ERR(inode))\n\t\tinode = NULL;\n\treturn inode;\n}\n\n \nstatic noinline int replay_one_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct extent_buffer *eb, int slot,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_drop_extents_args drop_args = { 0 };\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint found_type;\n\tu64 extent_end;\n\tu64 start = key->offset;\n\tu64 nbytes = 0;\n\tstruct btrfs_file_extent_item *item;\n\tstruct inode *inode = NULL;\n\tunsigned long size;\n\tint ret = 0;\n\n\titem = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\tfound_type = btrfs_file_extent_type(eb, item);\n\n\tif (found_type == BTRFS_FILE_EXTENT_REG ||\n\t    found_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tnbytes = btrfs_file_extent_num_bytes(eb, item);\n\t\textent_end = start + nbytes;\n\n\t\t \n\t\tif (btrfs_file_extent_disk_bytenr(eb, item) == 0)\n\t\t\tnbytes = 0;\n\t} else if (found_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tsize = btrfs_file_extent_ram_bytes(eb, item);\n\t\tnbytes = btrfs_file_extent_ram_bytes(eb, item);\n\t\textent_end = ALIGN(start + size,\n\t\t\t\t   fs_info->sectorsize);\n\t} else {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tinode = read_one_inode(root, key->objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tret = btrfs_lookup_file_extent(trans, root, path,\n\t\t\tbtrfs_ino(BTRFS_I(inode)), start, 0);\n\n\tif (ret == 0 &&\n\t    (found_type == BTRFS_FILE_EXTENT_REG ||\n\t     found_type == BTRFS_FILE_EXTENT_PREALLOC)) {\n\t\tstruct btrfs_file_extent_item cmp1;\n\t\tstruct btrfs_file_extent_item cmp2;\n\t\tstruct btrfs_file_extent_item *existing;\n\t\tstruct extent_buffer *leaf;\n\n\t\tleaf = path->nodes[0];\n\t\texisting = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_file_extent_item);\n\n\t\tread_extent_buffer(eb, &cmp1, (unsigned long)item,\n\t\t\t\t   sizeof(cmp1));\n\t\tread_extent_buffer(leaf, &cmp2, (unsigned long)existing,\n\t\t\t\t   sizeof(cmp2));\n\n\t\t \n\t\tif (memcmp(&cmp1, &cmp2, sizeof(cmp1)) == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\n\t \n\tdrop_args.start = start;\n\tdrop_args.end = extent_end;\n\tdrop_args.drop_cache = true;\n\tret = btrfs_drop_extents(trans, root, BTRFS_I(inode), &drop_args);\n\tif (ret)\n\t\tgoto out;\n\n\tif (found_type == BTRFS_FILE_EXTENT_REG ||\n\t    found_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tu64 offset;\n\t\tunsigned long dest_offset;\n\t\tstruct btrfs_key ins;\n\n\t\tif (btrfs_file_extent_disk_bytenr(eb, item) == 0 &&\n\t\t    btrfs_fs_incompat(fs_info, NO_HOLES))\n\t\t\tgoto update_inode;\n\n\t\tret = btrfs_insert_empty_item(trans, root, path, key,\n\t\t\t\t\t      sizeof(*item));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tdest_offset = btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\t\t    path->slots[0]);\n\t\tcopy_extent_buffer(path->nodes[0], eb, dest_offset,\n\t\t\t\t(unsigned long)item,  sizeof(*item));\n\n\t\tins.objectid = btrfs_file_extent_disk_bytenr(eb, item);\n\t\tins.offset = btrfs_file_extent_disk_num_bytes(eb, item);\n\t\tins.type = BTRFS_EXTENT_ITEM_KEY;\n\t\toffset = key->offset - btrfs_file_extent_offset(eb, item);\n\n\t\t \n\t\tret = btrfs_qgroup_trace_extent(trans,\n\t\t\t\tbtrfs_file_extent_disk_bytenr(eb, item),\n\t\t\t\tbtrfs_file_extent_disk_num_bytes(eb, item));\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ins.objectid > 0) {\n\t\t\tstruct btrfs_ref ref = { 0 };\n\t\t\tu64 csum_start;\n\t\t\tu64 csum_end;\n\t\t\tLIST_HEAD(ordered_sums);\n\n\t\t\t \n\t\t\tret = btrfs_lookup_data_extent(fs_info, ins.objectid,\n\t\t\t\t\t\tins.offset);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret == 0) {\n\t\t\t\tbtrfs_init_generic_ref(&ref,\n\t\t\t\t\t\tBTRFS_ADD_DELAYED_REF,\n\t\t\t\t\t\tins.objectid, ins.offset, 0);\n\t\t\t\tbtrfs_init_data_ref(&ref,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tkey->objectid, offset, 0, false);\n\t\t\t\tret = btrfs_inc_extent_ref(trans, &ref);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tret = btrfs_alloc_logged_file_extent(trans,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tkey->objectid, offset, &ins);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_release_path(path);\n\n\t\t\tif (btrfs_file_extent_compression(eb, item)) {\n\t\t\t\tcsum_start = ins.objectid;\n\t\t\t\tcsum_end = csum_start + ins.offset;\n\t\t\t} else {\n\t\t\t\tcsum_start = ins.objectid +\n\t\t\t\t\tbtrfs_file_extent_offset(eb, item);\n\t\t\t\tcsum_end = csum_start +\n\t\t\t\t\tbtrfs_file_extent_num_bytes(eb, item);\n\t\t\t}\n\n\t\t\tret = btrfs_lookup_csums_list(root->log_root,\n\t\t\t\t\t\tcsum_start, csum_end - 1,\n\t\t\t\t\t\t&ordered_sums, 0, false);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\t \n\t\t\twhile (!list_empty(&ordered_sums)) {\n\t\t\t\tstruct btrfs_ordered_sum *sums;\n\t\t\t\tstruct btrfs_root *csum_root;\n\n\t\t\t\tsums = list_entry(ordered_sums.next,\n\t\t\t\t\t\tstruct btrfs_ordered_sum,\n\t\t\t\t\t\tlist);\n\t\t\t\tcsum_root = btrfs_csum_root(fs_info,\n\t\t\t\t\t\t\t    sums->logical);\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = btrfs_del_csums(trans, csum_root,\n\t\t\t\t\t\t\t      sums->logical,\n\t\t\t\t\t\t\t      sums->len);\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = btrfs_csum_file_blocks(trans,\n\t\t\t\t\t\t\t\t     csum_root,\n\t\t\t\t\t\t\t\t     sums);\n\t\t\t\tlist_del(&sums->list);\n\t\t\t\tkfree(sums);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tbtrfs_release_path(path);\n\t\t}\n\t} else if (found_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t \n\t\tret = overwrite_item(trans, root, path, eb, slot, key);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = btrfs_inode_set_file_extent_range(BTRFS_I(inode), start,\n\t\t\t\t\t\textent_end - start);\n\tif (ret)\n\t\tgoto out;\n\nupdate_inode:\n\tbtrfs_update_inode_bytes(BTRFS_I(inode), nbytes, drop_args.bytes_found);\n\tret = btrfs_update_inode(trans, root, BTRFS_I(inode));\nout:\n\tiput(inode);\n\treturn ret;\n}\n\nstatic int unlink_inode_for_log_replay(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_inode *dir,\n\t\t\t\t       struct btrfs_inode *inode,\n\t\t\t\t       const struct fscrypt_str *name)\n{\n\tint ret;\n\n\tret = btrfs_unlink_inode(trans, dir, inode, name);\n\tif (ret)\n\t\treturn ret;\n\t \n\treturn btrfs_run_delayed_items(trans);\n}\n\n \nstatic noinline int drop_one_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct btrfs_inode *dir,\n\t\t\t\t      struct btrfs_dir_item *di)\n{\n\tstruct btrfs_root *root = dir->root;\n\tstruct inode *inode;\n\tstruct fscrypt_str name;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key location;\n\tint ret;\n\n\tleaf = path->nodes[0];\n\n\tbtrfs_dir_item_key_to_cpu(leaf, di, &location);\n\tret = read_alloc_one_name(leaf, di + 1, btrfs_dir_name_len(leaf, di), &name);\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\tbtrfs_release_path(path);\n\n\tinode = read_one_inode(root, location.objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = link_to_fixup_dir(trans, root, path, location.objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tret = unlink_inode_for_log_replay(trans, dir, BTRFS_I(inode), &name);\nout:\n\tkfree(name.name);\n\tiput(inode);\n\treturn ret;\n}\n\n \nstatic noinline int inode_in_dir(struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path,\n\t\t\t\t u64 dirid, u64 objectid, u64 index,\n\t\t\t\t struct fscrypt_str *name)\n{\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key location;\n\tint ret = 0;\n\n\tdi = btrfs_lookup_dir_index_item(NULL, root, path, dirid,\n\t\t\t\t\t index, name, 0);\n\tif (IS_ERR(di)) {\n\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t} else if (di) {\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);\n\t\tif (location.objectid != objectid)\n\t\t\tgoto out;\n\t} else {\n\t\tgoto out;\n\t}\n\n\tbtrfs_release_path(path);\n\tdi = btrfs_lookup_dir_item(NULL, root, path, dirid, name, 0);\n\tif (IS_ERR(di)) {\n\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t} else if (di) {\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);\n\t\tif (location.objectid == objectid)\n\t\t\tret = 1;\n\t}\nout:\n\tbtrfs_release_path(path);\n\treturn ret;\n}\n\n \nstatic noinline int backref_in_log(struct btrfs_root *log,\n\t\t\t\t   struct btrfs_key *key,\n\t\t\t\t   u64 ref_objectid,\n\t\t\t\t   const struct fscrypt_str *name)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(NULL, log, key, path, 0, 0);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret == 1) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (key->type == BTRFS_INODE_EXTREF_KEY)\n\t\tret = !!btrfs_find_name_in_ext_backref(path->nodes[0],\n\t\t\t\t\t\t       path->slots[0],\n\t\t\t\t\t\t       ref_objectid, name);\n\telse\n\t\tret = !!btrfs_find_name_in_backref(path->nodes[0],\n\t\t\t\t\t\t   path->slots[0], name);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic inline int __add_inode_ref(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_root *log_root,\n\t\t\t\t  struct btrfs_inode *dir,\n\t\t\t\t  struct btrfs_inode *inode,\n\t\t\t\t  u64 inode_objectid, u64 parent_objectid,\n\t\t\t\t  u64 ref_index, struct fscrypt_str *name)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key search_key;\n\tstruct btrfs_inode_extref *extref;\n\nagain:\n\t \n\tsearch_key.objectid = inode_objectid;\n\tsearch_key.type = BTRFS_INODE_REF_KEY;\n\tsearch_key.offset = parent_objectid;\n\tret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);\n\tif (ret == 0) {\n\t\tstruct btrfs_inode_ref *victim_ref;\n\t\tunsigned long ptr;\n\t\tunsigned long ptr_end;\n\n\t\tleaf = path->nodes[0];\n\n\t\t \n\t\tif (search_key.objectid == search_key.offset)\n\t\t\treturn 1;\n\n\t\t \n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\tptr_end = ptr + btrfs_item_size(leaf, path->slots[0]);\n\t\twhile (ptr < ptr_end) {\n\t\t\tstruct fscrypt_str victim_name;\n\n\t\t\tvictim_ref = (struct btrfs_inode_ref *)ptr;\n\t\t\tret = read_alloc_one_name(leaf, (victim_ref + 1),\n\t\t\t\t btrfs_inode_ref_name_len(leaf, victim_ref),\n\t\t\t\t &victim_name);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = backref_in_log(log_root, &search_key,\n\t\t\t\t\t     parent_objectid, &victim_name);\n\t\t\tif (ret < 0) {\n\t\t\t\tkfree(victim_name.name);\n\t\t\t\treturn ret;\n\t\t\t} else if (!ret) {\n\t\t\t\tinc_nlink(&inode->vfs_inode);\n\t\t\t\tbtrfs_release_path(path);\n\n\t\t\t\tret = unlink_inode_for_log_replay(trans, dir, inode,\n\t\t\t\t\t\t&victim_name);\n\t\t\t\tkfree(victim_name.name);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tkfree(victim_name.name);\n\n\t\t\tptr = (unsigned long)(victim_ref + 1) + victim_name.len;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\n\t \n\textref = btrfs_lookup_inode_extref(NULL, root, path, name,\n\t\t\t\t\t   inode_objectid, parent_objectid, 0,\n\t\t\t\t\t   0);\n\tif (IS_ERR(extref)) {\n\t\treturn PTR_ERR(extref);\n\t} else if (extref) {\n\t\tu32 item_size;\n\t\tu32 cur_offset = 0;\n\t\tunsigned long base;\n\t\tstruct inode *victim_parent;\n\n\t\tleaf = path->nodes[0];\n\n\t\titem_size = btrfs_item_size(leaf, path->slots[0]);\n\t\tbase = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\n\t\twhile (cur_offset < item_size) {\n\t\t\tstruct fscrypt_str victim_name;\n\n\t\t\textref = (struct btrfs_inode_extref *)(base + cur_offset);\n\n\t\t\tif (btrfs_inode_extref_parent(leaf, extref) != parent_objectid)\n\t\t\t\tgoto next;\n\n\t\t\tret = read_alloc_one_name(leaf, &extref->name,\n\t\t\t\t btrfs_inode_extref_name_len(leaf, extref),\n\t\t\t\t &victim_name);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tsearch_key.objectid = inode_objectid;\n\t\t\tsearch_key.type = BTRFS_INODE_EXTREF_KEY;\n\t\t\tsearch_key.offset = btrfs_extref_hash(parent_objectid,\n\t\t\t\t\t\t\t      victim_name.name,\n\t\t\t\t\t\t\t      victim_name.len);\n\t\t\tret = backref_in_log(log_root, &search_key,\n\t\t\t\t\t     parent_objectid, &victim_name);\n\t\t\tif (ret < 0) {\n\t\t\t\tkfree(victim_name.name);\n\t\t\t\treturn ret;\n\t\t\t} else if (!ret) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tvictim_parent = read_one_inode(root,\n\t\t\t\t\t\tparent_objectid);\n\t\t\t\tif (victim_parent) {\n\t\t\t\t\tinc_nlink(&inode->vfs_inode);\n\t\t\t\t\tbtrfs_release_path(path);\n\n\t\t\t\t\tret = unlink_inode_for_log_replay(trans,\n\t\t\t\t\t\t\tBTRFS_I(victim_parent),\n\t\t\t\t\t\t\tinode, &victim_name);\n\t\t\t\t}\n\t\t\t\tiput(victim_parent);\n\t\t\t\tkfree(victim_name.name);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tkfree(victim_name.name);\nnext:\n\t\t\tcur_offset += victim_name.len + sizeof(*extref);\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\n\t \n\tdi = btrfs_lookup_dir_index_item(trans, root, path, btrfs_ino(dir),\n\t\t\t\t\t ref_index, name, 0);\n\tif (IS_ERR(di)) {\n\t\treturn PTR_ERR(di);\n\t} else if (di) {\n\t\tret = drop_one_dir_item(trans, path, dir, di);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tbtrfs_release_path(path);\n\n\t \n\tdi = btrfs_lookup_dir_item(trans, root, path, btrfs_ino(dir), name, 0);\n\tif (IS_ERR(di)) {\n\t\treturn PTR_ERR(di);\n\t} else if (di) {\n\t\tret = drop_one_dir_item(trans, path, dir, di);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tbtrfs_release_path(path);\n\n\treturn 0;\n}\n\nstatic int extref_get_fields(struct extent_buffer *eb, unsigned long ref_ptr,\n\t\t\t     struct fscrypt_str *name, u64 *index,\n\t\t\t     u64 *parent_objectid)\n{\n\tstruct btrfs_inode_extref *extref;\n\tint ret;\n\n\textref = (struct btrfs_inode_extref *)ref_ptr;\n\n\tret = read_alloc_one_name(eb, &extref->name,\n\t\t\t\t  btrfs_inode_extref_name_len(eb, extref), name);\n\tif (ret)\n\t\treturn ret;\n\n\tif (index)\n\t\t*index = btrfs_inode_extref_index(eb, extref);\n\tif (parent_objectid)\n\t\t*parent_objectid = btrfs_inode_extref_parent(eb, extref);\n\n\treturn 0;\n}\n\nstatic int ref_get_fields(struct extent_buffer *eb, unsigned long ref_ptr,\n\t\t\t  struct fscrypt_str *name, u64 *index)\n{\n\tstruct btrfs_inode_ref *ref;\n\tint ret;\n\n\tref = (struct btrfs_inode_ref *)ref_ptr;\n\n\tret = read_alloc_one_name(eb, ref + 1, btrfs_inode_ref_name_len(eb, ref),\n\t\t\t\t  name);\n\tif (ret)\n\t\treturn ret;\n\n\tif (index)\n\t\t*index = btrfs_inode_ref_index(eb, ref);\n\n\treturn 0;\n}\n\n \nstatic int unlink_old_inode_refs(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path,\n\t\t\t\t struct btrfs_inode *inode,\n\t\t\t\t struct extent_buffer *log_eb,\n\t\t\t\t int log_slot,\n\t\t\t\t struct btrfs_key *key)\n{\n\tint ret;\n\tunsigned long ref_ptr;\n\tunsigned long ref_end;\n\tstruct extent_buffer *eb;\n\nagain:\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\teb = path->nodes[0];\n\tref_ptr = btrfs_item_ptr_offset(eb, path->slots[0]);\n\tref_end = ref_ptr + btrfs_item_size(eb, path->slots[0]);\n\twhile (ref_ptr < ref_end) {\n\t\tstruct fscrypt_str name;\n\t\tu64 parent_id;\n\n\t\tif (key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\tret = extref_get_fields(eb, ref_ptr, &name,\n\t\t\t\t\t\tNULL, &parent_id);\n\t\t} else {\n\t\t\tparent_id = key->offset;\n\t\t\tret = ref_get_fields(eb, ref_ptr, &name, NULL);\n\t\t}\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (key->type == BTRFS_INODE_EXTREF_KEY)\n\t\t\tret = !!btrfs_find_name_in_ext_backref(log_eb, log_slot,\n\t\t\t\t\t\t\t       parent_id, &name);\n\t\telse\n\t\t\tret = !!btrfs_find_name_in_backref(log_eb, log_slot, &name);\n\n\t\tif (!ret) {\n\t\t\tstruct inode *dir;\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tdir = read_one_inode(root, parent_id);\n\t\t\tif (!dir) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tkfree(name.name);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = unlink_inode_for_log_replay(trans, BTRFS_I(dir),\n\t\t\t\t\t\t inode, &name);\n\t\t\tkfree(name.name);\n\t\t\tiput(dir);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tgoto again;\n\t\t}\n\n\t\tkfree(name.name);\n\t\tref_ptr += name.len;\n\t\tif (key->type == BTRFS_INODE_EXTREF_KEY)\n\t\t\tref_ptr += sizeof(struct btrfs_inode_extref);\n\t\telse\n\t\t\tref_ptr += sizeof(struct btrfs_inode_ref);\n\t}\n\tret = 0;\n out:\n\tbtrfs_release_path(path);\n\treturn ret;\n}\n\n \nstatic noinline int add_inode_ref(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t  struct btrfs_root *log,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct extent_buffer *eb, int slot,\n\t\t\t\t  struct btrfs_key *key)\n{\n\tstruct inode *dir = NULL;\n\tstruct inode *inode = NULL;\n\tunsigned long ref_ptr;\n\tunsigned long ref_end;\n\tstruct fscrypt_str name;\n\tint ret;\n\tint log_ref_ver = 0;\n\tu64 parent_objectid;\n\tu64 inode_objectid;\n\tu64 ref_index = 0;\n\tint ref_struct_size;\n\n\tref_ptr = btrfs_item_ptr_offset(eb, slot);\n\tref_end = ref_ptr + btrfs_item_size(eb, slot);\n\n\tif (key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\tstruct btrfs_inode_extref *r;\n\n\t\tref_struct_size = sizeof(struct btrfs_inode_extref);\n\t\tlog_ref_ver = 1;\n\t\tr = (struct btrfs_inode_extref *)ref_ptr;\n\t\tparent_objectid = btrfs_inode_extref_parent(eb, r);\n\t} else {\n\t\tref_struct_size = sizeof(struct btrfs_inode_ref);\n\t\tparent_objectid = key->offset;\n\t}\n\tinode_objectid = key->objectid;\n\n\t \n\tdir = read_one_inode(root, parent_objectid);\n\tif (!dir) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tinode = read_one_inode(root, inode_objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\twhile (ref_ptr < ref_end) {\n\t\tif (log_ref_ver) {\n\t\t\tret = extref_get_fields(eb, ref_ptr, &name,\n\t\t\t\t\t\t&ref_index, &parent_objectid);\n\t\t\t \n\t\t\tif (!dir)\n\t\t\t\tdir = read_one_inode(root, parent_objectid);\n\t\t\tif (!dir) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tret = ref_get_fields(eb, ref_ptr, &name, &ref_index);\n\t\t}\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = inode_in_dir(root, path, btrfs_ino(BTRFS_I(dir)),\n\t\t\t\t   btrfs_ino(BTRFS_I(inode)), ref_index, &name);\n\t\tif (ret < 0) {\n\t\t\tgoto out;\n\t\t} else if (ret == 0) {\n\t\t\t \n\t\t\tret = __add_inode_ref(trans, root, path, log,\n\t\t\t\t\t      BTRFS_I(dir), BTRFS_I(inode),\n\t\t\t\t\t      inode_objectid, parent_objectid,\n\t\t\t\t\t      ref_index, &name);\n\t\t\tif (ret) {\n\t\t\t\tif (ret == 1)\n\t\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = btrfs_add_link(trans, BTRFS_I(dir), BTRFS_I(inode),\n\t\t\t\t\t     &name, 0, ref_index);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tret = btrfs_update_inode(trans, root, BTRFS_I(inode));\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t\t \n\n\t\tref_ptr = (unsigned long)(ref_ptr + ref_struct_size) + name.len;\n\t\tkfree(name.name);\n\t\tname.name = NULL;\n\t\tif (log_ref_ver) {\n\t\t\tiput(dir);\n\t\t\tdir = NULL;\n\t\t}\n\t}\n\n\t \n\tret = unlink_old_inode_refs(trans, root, path, BTRFS_I(inode), eb, slot,\n\t\t\t\t    key);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = overwrite_item(trans, root, path, eb, slot, key);\nout:\n\tbtrfs_release_path(path);\n\tkfree(name.name);\n\tiput(dir);\n\tiput(inode);\n\treturn ret;\n}\n\nstatic int count_inode_extrefs(struct btrfs_root *root,\n\t\tstruct btrfs_inode *inode, struct btrfs_path *path)\n{\n\tint ret = 0;\n\tint name_len;\n\tunsigned int nlink = 0;\n\tu32 item_size;\n\tu32 cur_offset = 0;\n\tu64 inode_objectid = btrfs_ino(inode);\n\tu64 offset = 0;\n\tunsigned long ptr;\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\n\twhile (1) {\n\t\tret = btrfs_find_one_extref(root, inode_objectid, offset, path,\n\t\t\t\t\t    &extref, &offset);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size(leaf, path->slots[0]);\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\tcur_offset = 0;\n\n\t\twhile (cur_offset < item_size) {\n\t\t\textref = (struct btrfs_inode_extref *) (ptr + cur_offset);\n\t\t\tname_len = btrfs_inode_extref_name_len(leaf, extref);\n\n\t\t\tnlink++;\n\n\t\t\tcur_offset += name_len + sizeof(*extref);\n\t\t}\n\n\t\toffset++;\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_release_path(path);\n\n\tif (ret < 0 && ret != -ENOENT)\n\t\treturn ret;\n\treturn nlink;\n}\n\nstatic int count_inode_refs(struct btrfs_root *root,\n\t\t\tstruct btrfs_inode *inode, struct btrfs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tunsigned int nlink = 0;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tint name_len;\n\tu64 ino = btrfs_ino(inode);\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\nprocess_slot:\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t      path->slots[0]);\n\t\tif (key.objectid != ino ||\n\t\t    key.type != BTRFS_INODE_REF_KEY)\n\t\t\tbreak;\n\t\tptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tptr_end = ptr + btrfs_item_size(path->nodes[0],\n\t\t\t\t\t\t   path->slots[0]);\n\t\twhile (ptr < ptr_end) {\n\t\t\tstruct btrfs_inode_ref *ref;\n\n\t\t\tref = (struct btrfs_inode_ref *)ptr;\n\t\t\tname_len = btrfs_inode_ref_name_len(path->nodes[0],\n\t\t\t\t\t\t\t    ref);\n\t\t\tptr = (unsigned long)(ref + 1) + name_len;\n\t\t\tnlink++;\n\t\t}\n\n\t\tif (key.offset == 0)\n\t\t\tbreak;\n\t\tif (path->slots[0] > 0) {\n\t\t\tpath->slots[0]--;\n\t\t\tgoto process_slot;\n\t\t}\n\t\tkey.offset--;\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_release_path(path);\n\n\treturn nlink;\n}\n\n \nstatic noinline int fixup_inode_link_count(struct btrfs_trans_handle *trans,\n\t\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t\t   struct inode *inode)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\tu64 nlink = 0;\n\tu64 ino = btrfs_ino(BTRFS_I(inode));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = count_inode_refs(root, BTRFS_I(inode), path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnlink = ret;\n\n\tret = count_inode_extrefs(root, BTRFS_I(inode), path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnlink += ret;\n\n\tret = 0;\n\n\tif (nlink != inode->i_nlink) {\n\t\tset_nlink(inode, nlink);\n\t\tret = btrfs_update_inode(trans, root, BTRFS_I(inode));\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tBTRFS_I(inode)->index_cnt = (u64)-1;\n\n\tif (inode->i_nlink == 0) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tret = replay_dir_deletes(trans, root, NULL, path,\n\t\t\t\t\t\t ino, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t\tret = btrfs_insert_orphan_item(trans, root, ino);\n\t\tif (ret == -EEXIST)\n\t\t\tret = 0;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic noinline int fixup_inode_link_counts(struct btrfs_trans_handle *trans,\n\t\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t\t    struct btrfs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = BTRFS_TREE_LOG_FIXUP_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (ret == 1) {\n\t\t\tret = 0;\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_TREE_LOG_FIXUP_OBJECTID ||\n\t\t    key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tbtrfs_release_path(path);\n\t\tinode = read_one_inode(root, key.offset);\n\t\tif (!inode) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = fixup_inode_link_count(trans, root, inode);\n\t\tiput(inode);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tkey.offset = (u64)-1;\n\t}\n\tbtrfs_release_path(path);\n\treturn ret;\n}\n\n\n \nstatic noinline int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      u64 objectid)\n{\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tstruct inode *inode;\n\n\tinode = read_one_inode(root, objectid);\n\tif (!inode)\n\t\treturn -EIO;\n\n\tkey.objectid = BTRFS_TREE_LOG_FIXUP_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key, 0);\n\n\tbtrfs_release_path(path);\n\tif (ret == 0) {\n\t\tif (!inode->i_nlink)\n\t\t\tset_nlink(inode, 1);\n\t\telse\n\t\t\tinc_nlink(inode);\n\t\tret = btrfs_update_inode(trans, root, BTRFS_I(inode));\n\t} else if (ret == -EEXIST) {\n\t\tret = 0;\n\t}\n\tiput(inode);\n\n\treturn ret;\n}\n\n \nstatic noinline int insert_one_name(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    u64 dirid, u64 index,\n\t\t\t\t    const struct fscrypt_str *name,\n\t\t\t\t    struct btrfs_key *location)\n{\n\tstruct inode *inode;\n\tstruct inode *dir;\n\tint ret;\n\n\tinode = read_one_inode(root, location->objectid);\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tdir = read_one_inode(root, dirid);\n\tif (!dir) {\n\t\tiput(inode);\n\t\treturn -EIO;\n\t}\n\n\tret = btrfs_add_link(trans, BTRFS_I(dir), BTRFS_I(inode), name,\n\t\t\t     1, index);\n\n\t \n\n\tiput(inode);\n\tiput(dir);\n\treturn ret;\n}\n\nstatic int delete_conflicting_dir_entry(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_inode *dir,\n\t\t\t\t\tstruct btrfs_path *path,\n\t\t\t\t\tstruct btrfs_dir_item *dst_di,\n\t\t\t\t\tconst struct btrfs_key *log_key,\n\t\t\t\t\tu8 log_flags,\n\t\t\t\t\tbool exists)\n{\n\tstruct btrfs_key found_key;\n\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], dst_di, &found_key);\n\t \n\tif (found_key.objectid == log_key->objectid &&\n\t    found_key.type == log_key->type &&\n\t    found_key.offset == log_key->offset &&\n\t    btrfs_dir_flags(path->nodes[0], dst_di) == log_flags)\n\t\treturn 1;\n\n\t \n\tif (!exists)\n\t\treturn 0;\n\n\treturn drop_one_dir_item(trans, path, dir, dst_di);\n}\n\n \nstatic noinline int replay_one_name(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct extent_buffer *eb,\n\t\t\t\t    struct btrfs_dir_item *di,\n\t\t\t\t    struct btrfs_key *key)\n{\n\tstruct fscrypt_str name;\n\tstruct btrfs_dir_item *dir_dst_di;\n\tstruct btrfs_dir_item *index_dst_di;\n\tbool dir_dst_matches = false;\n\tbool index_dst_matches = false;\n\tstruct btrfs_key log_key;\n\tstruct btrfs_key search_key;\n\tstruct inode *dir;\n\tu8 log_flags;\n\tbool exists;\n\tint ret;\n\tbool update_size = true;\n\tbool name_added = false;\n\n\tdir = read_one_inode(root, key->objectid);\n\tif (!dir)\n\t\treturn -EIO;\n\n\tret = read_alloc_one_name(eb, di + 1, btrfs_dir_name_len(eb, di), &name);\n\tif (ret)\n\t\tgoto out;\n\n\tlog_flags = btrfs_dir_flags(eb, di);\n\tbtrfs_dir_item_key_to_cpu(eb, di, &log_key);\n\tret = btrfs_lookup_inode(trans, root, path, &log_key, 0);\n\tbtrfs_release_path(path);\n\tif (ret < 0)\n\t\tgoto out;\n\texists = (ret == 0);\n\tret = 0;\n\n\tdir_dst_di = btrfs_lookup_dir_item(trans, root, path, key->objectid,\n\t\t\t\t\t   &name, 1);\n\tif (IS_ERR(dir_dst_di)) {\n\t\tret = PTR_ERR(dir_dst_di);\n\t\tgoto out;\n\t} else if (dir_dst_di) {\n\t\tret = delete_conflicting_dir_entry(trans, BTRFS_I(dir), path,\n\t\t\t\t\t\t   dir_dst_di, &log_key,\n\t\t\t\t\t\t   log_flags, exists);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tdir_dst_matches = (ret == 1);\n\t}\n\n\tbtrfs_release_path(path);\n\n\tindex_dst_di = btrfs_lookup_dir_index_item(trans, root, path,\n\t\t\t\t\t\t   key->objectid, key->offset,\n\t\t\t\t\t\t   &name, 1);\n\tif (IS_ERR(index_dst_di)) {\n\t\tret = PTR_ERR(index_dst_di);\n\t\tgoto out;\n\t} else if (index_dst_di) {\n\t\tret = delete_conflicting_dir_entry(trans, BTRFS_I(dir), path,\n\t\t\t\t\t\t   index_dst_di, &log_key,\n\t\t\t\t\t\t   log_flags, exists);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tindex_dst_matches = (ret == 1);\n\t}\n\n\tbtrfs_release_path(path);\n\n\tif (dir_dst_matches && index_dst_matches) {\n\t\tret = 0;\n\t\tupdate_size = false;\n\t\tgoto out;\n\t}\n\n\t \n\tsearch_key.objectid = log_key.objectid;\n\tsearch_key.type = BTRFS_INODE_REF_KEY;\n\tsearch_key.offset = key->objectid;\n\tret = backref_in_log(root->log_root, &search_key, 0, &name);\n\tif (ret < 0) {\n\t        goto out;\n\t} else if (ret) {\n\t         \n\t        ret = 0;\n\t        update_size = false;\n\t        goto out;\n\t}\n\n\tsearch_key.objectid = log_key.objectid;\n\tsearch_key.type = BTRFS_INODE_EXTREF_KEY;\n\tsearch_key.offset = key->objectid;\n\tret = backref_in_log(root->log_root, &search_key, key->objectid, &name);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\t \n\t\tret = 0;\n\t\tupdate_size = false;\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\tret = insert_one_name(trans, root, key->objectid, key->offset,\n\t\t\t      &name, &log_key);\n\tif (ret && ret != -ENOENT && ret != -EEXIST)\n\t\tgoto out;\n\tif (!ret)\n\t\tname_added = true;\n\tupdate_size = false;\n\tret = 0;\n\nout:\n\tif (!ret && update_size) {\n\t\tbtrfs_i_size_write(BTRFS_I(dir), dir->i_size + name.len * 2);\n\t\tret = btrfs_update_inode(trans, root, BTRFS_I(dir));\n\t}\n\tkfree(name.name);\n\tiput(dir);\n\tif (!ret && name_added)\n\t\tret = 1;\n\treturn ret;\n}\n\n \nstatic noinline int replay_one_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_path *path,\n\t\t\t\t\tstruct extent_buffer *eb, int slot,\n\t\t\t\t\tstruct btrfs_key *key)\n{\n\tint ret;\n\tstruct btrfs_dir_item *di;\n\n\t \n\tASSERT(key->type == BTRFS_DIR_INDEX_KEY);\n\n\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\tret = replay_one_name(trans, root, path, eb, di, key);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (ret == 1 && btrfs_dir_ftype(eb, di) != BTRFS_FT_DIR) {\n\t\tstruct btrfs_path *fixup_path;\n\t\tstruct btrfs_key di_key;\n\n\t\tfixup_path = btrfs_alloc_path();\n\t\tif (!fixup_path)\n\t\t\treturn -ENOMEM;\n\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\t\tret = link_to_fixup_dir(trans, root, fixup_path, di_key.objectid);\n\t\tbtrfs_free_path(fixup_path);\n\t}\n\n\treturn ret;\n}\n\n \nstatic noinline int find_dir_range(struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   u64 dirid,\n\t\t\t\t   u64 *start_ret, u64 *end_ret)\n{\n\tstruct btrfs_key key;\n\tu64 found_end;\n\tstruct btrfs_dir_log_item *item;\n\tint ret;\n\tint nritems;\n\n\tif (*start_ret == (u64)-1)\n\t\treturn 1;\n\n\tkey.objectid = dirid;\n\tkey.type = BTRFS_DIR_LOG_INDEX_KEY;\n\tkey.offset = *start_ret;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto out;\n\t\tpath->slots[0]--;\n\t}\n\tif (ret != 0)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\tif (key.type != BTRFS_DIR_LOG_INDEX_KEY || key.objectid != dirid) {\n\t\tret = 1;\n\t\tgoto next;\n\t}\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_dir_log_item);\n\tfound_end = btrfs_dir_log_end(path->nodes[0], item);\n\n\tif (*start_ret >= key.offset && *start_ret <= found_end) {\n\t\tret = 0;\n\t\t*start_ret = key.offset;\n\t\t*end_ret = found_end;\n\t\tgoto out;\n\t}\n\tret = 1;\nnext:\n\t \n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\tpath->slots[0]++;\n\tif (path->slots[0] >= nritems) {\n\t\tret = btrfs_next_leaf(root, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\tif (key.type != BTRFS_DIR_LOG_INDEX_KEY || key.objectid != dirid) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_dir_log_item);\n\tfound_end = btrfs_dir_log_end(path->nodes[0], item);\n\t*start_ret = key.offset;\n\t*end_ret = found_end;\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\treturn ret;\n}\n\n \nstatic noinline int check_item_in_log(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *log,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct btrfs_path *log_path,\n\t\t\t\t      struct inode *dir,\n\t\t\t\t      struct btrfs_key *dir_key)\n{\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tint ret;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tstruct btrfs_dir_item *di;\n\tstruct fscrypt_str name;\n\tstruct inode *inode = NULL;\n\tstruct btrfs_key location;\n\n\t \n\tASSERT(dir_key->type == BTRFS_DIR_INDEX_KEY);\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\tret = read_alloc_one_name(eb, di + 1, btrfs_dir_name_len(eb, di), &name);\n\tif (ret)\n\t\tgoto out;\n\n\tif (log) {\n\t\tstruct btrfs_dir_item *log_di;\n\n\t\tlog_di = btrfs_lookup_dir_index_item(trans, log, log_path,\n\t\t\t\t\t\t     dir_key->objectid,\n\t\t\t\t\t\t     dir_key->offset, &name, 0);\n\t\tif (IS_ERR(log_di)) {\n\t\t\tret = PTR_ERR(log_di);\n\t\t\tgoto out;\n\t\t} else if (log_di) {\n\t\t\t \n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tbtrfs_dir_item_key_to_cpu(eb, di, &location);\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(log_path);\n\tinode = read_one_inode(root, location.objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = link_to_fixup_dir(trans, root, path, location.objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tinc_nlink(inode);\n\tret = unlink_inode_for_log_replay(trans, BTRFS_I(dir), BTRFS_I(inode),\n\t\t\t\t\t  &name);\n\t \nout:\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(log_path);\n\tkfree(name.name);\n\tiput(inode);\n\treturn ret;\n}\n\nstatic int replay_xattr_deletes(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root,\n\t\t\t      struct btrfs_root *log,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      const u64 ino)\n{\n\tstruct btrfs_key search_key;\n\tstruct btrfs_path *log_path;\n\tint i;\n\tint nritems;\n\tint ret;\n\n\tlog_path = btrfs_alloc_path();\n\tif (!log_path)\n\t\treturn -ENOMEM;\n\n\tsearch_key.objectid = ino;\n\tsearch_key.type = BTRFS_XATTR_ITEM_KEY;\n\tsearch_key.offset = 0;\nagain:\n\tret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\nprocess_leaf:\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\tfor (i = path->slots[0]; i < nritems; i++) {\n\t\tstruct btrfs_key key;\n\t\tstruct btrfs_dir_item *di;\n\t\tstruct btrfs_dir_item *log_di;\n\t\tu32 total_size;\n\t\tu32 cur;\n\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, i);\n\t\tif (key.objectid != ino || key.type != BTRFS_XATTR_ITEM_KEY) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdi = btrfs_item_ptr(path->nodes[0], i, struct btrfs_dir_item);\n\t\ttotal_size = btrfs_item_size(path->nodes[0], i);\n\t\tcur = 0;\n\t\twhile (cur < total_size) {\n\t\t\tu16 name_len = btrfs_dir_name_len(path->nodes[0], di);\n\t\t\tu16 data_len = btrfs_dir_data_len(path->nodes[0], di);\n\t\t\tu32 this_len = sizeof(*di) + name_len + data_len;\n\t\t\tchar *name;\n\n\t\t\tname = kmalloc(name_len, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tread_extent_buffer(path->nodes[0], name,\n\t\t\t\t\t   (unsigned long)(di + 1), name_len);\n\n\t\t\tlog_di = btrfs_lookup_xattr(NULL, log, log_path, ino,\n\t\t\t\t\t\t    name, name_len, 0);\n\t\t\tbtrfs_release_path(log_path);\n\t\t\tif (!log_di) {\n\t\t\t\t \n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tdi = btrfs_lookup_xattr(trans, root, path, ino,\n\t\t\t\t\t\t\tname, name_len, -1);\n\t\t\t\tkfree(name);\n\t\t\t\tif (IS_ERR(di)) {\n\t\t\t\t\tret = PTR_ERR(di);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tASSERT(di);\n\t\t\t\tret = btrfs_delete_one_dir_name(trans, root,\n\t\t\t\t\t\t\t\tpath, di);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tsearch_key = key;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tkfree(name);\n\t\t\tif (IS_ERR(log_di)) {\n\t\t\t\tret = PTR_ERR(log_di);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcur += this_len;\n\t\t\tdi = (struct btrfs_dir_item *)((char *)di + this_len);\n\t\t}\n\t}\n\tret = btrfs_next_leaf(root, path);\n\tif (ret > 0)\n\t\tret = 0;\n\telse if (ret == 0)\n\t\tgoto process_leaf;\nout:\n\tbtrfs_free_path(log_path);\n\tbtrfs_release_path(path);\n\treturn ret;\n}\n\n\n \nstatic noinline int replay_dir_deletes(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       u64 dirid, int del_all)\n{\n\tu64 range_start;\n\tu64 range_end;\n\tint ret = 0;\n\tstruct btrfs_key dir_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *log_path;\n\tstruct inode *dir;\n\n\tdir_key.objectid = dirid;\n\tdir_key.type = BTRFS_DIR_INDEX_KEY;\n\tlog_path = btrfs_alloc_path();\n\tif (!log_path)\n\t\treturn -ENOMEM;\n\n\tdir = read_one_inode(root, dirid);\n\t \n\tif (!dir) {\n\t\tbtrfs_free_path(log_path);\n\t\treturn 0;\n\t}\n\n\trange_start = 0;\n\trange_end = 0;\n\twhile (1) {\n\t\tif (del_all)\n\t\t\trange_end = (u64)-1;\n\t\telse {\n\t\t\tret = find_dir_range(log, path, dirid,\n\t\t\t\t\t     &range_start, &range_end);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdir_key.offset = range_start;\n\t\twhile (1) {\n\t\t\tint nritems;\n\t\t\tret = btrfs_search_slot(NULL, root, &dir_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t\tif (path->slots[0] >= nritems) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret == 1)\n\t\t\t\t\tbreak;\n\t\t\t\telse if (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (found_key.objectid != dirid ||\n\t\t\t    found_key.type != dir_key.type) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (found_key.offset > range_end)\n\t\t\t\tbreak;\n\n\t\t\tret = check_item_in_log(trans, log, path,\n\t\t\t\t\t\tlog_path, dir,\n\t\t\t\t\t\t&found_key);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (found_key.offset == (u64)-1)\n\t\t\t\tbreak;\n\t\t\tdir_key.offset = found_key.offset + 1;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tif (range_end == (u64)-1)\n\t\t\tbreak;\n\t\trange_start = range_end + 1;\n\t}\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\tbtrfs_free_path(log_path);\n\tiput(dir);\n\treturn ret;\n}\n\n \nstatic int replay_one_buffer(struct btrfs_root *log, struct extent_buffer *eb,\n\t\t\t     struct walk_control *wc, u64 gen, int level)\n{\n\tint nritems;\n\tstruct btrfs_tree_parent_check check = {\n\t\t.transid = gen,\n\t\t.level = level\n\t};\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = wc->replay_dest;\n\tstruct btrfs_key key;\n\tint i;\n\tint ret;\n\n\tret = btrfs_read_extent_buffer(eb, &check);\n\tif (ret)\n\t\treturn ret;\n\n\tlevel = btrfs_header_level(eb);\n\n\tif (level != 0)\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tnritems = btrfs_header_nritems(eb);\n\tfor (i = 0; i < nritems; i++) {\n\t\tbtrfs_item_key_to_cpu(eb, &key, i);\n\n\t\t \n\t\tif (key.type == BTRFS_INODE_ITEM_KEY &&\n\t\t    wc->stage == LOG_WALK_REPLAY_INODES) {\n\t\t\tstruct btrfs_inode_item *inode_item;\n\t\t\tu32 mode;\n\n\t\t\tinode_item = btrfs_item_ptr(eb, i,\n\t\t\t\t\t    struct btrfs_inode_item);\n\t\t\t \n\t\t\tif (btrfs_inode_nlink(eb, inode_item) == 0) {\n\t\t\t\twc->ignore_cur_inode = true;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\twc->ignore_cur_inode = false;\n\t\t\t}\n\t\t\tret = replay_xattr_deletes(wc->trans, root, log,\n\t\t\t\t\t\t   path, key.objectid);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tmode = btrfs_inode_mode(eb, inode_item);\n\t\t\tif (S_ISDIR(mode)) {\n\t\t\t\tret = replay_dir_deletes(wc->trans,\n\t\t\t\t\t root, log, path, key.objectid, 0);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = overwrite_item(wc->trans, root, path,\n\t\t\t\t\t     eb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (S_ISREG(mode)) {\n\t\t\t\tstruct btrfs_drop_extents_args drop_args = { 0 };\n\t\t\t\tstruct inode *inode;\n\t\t\t\tu64 from;\n\n\t\t\t\tinode = read_one_inode(root, key.objectid);\n\t\t\t\tif (!inode) {\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfrom = ALIGN(i_size_read(inode),\n\t\t\t\t\t     root->fs_info->sectorsize);\n\t\t\t\tdrop_args.start = from;\n\t\t\t\tdrop_args.end = (u64)-1;\n\t\t\t\tdrop_args.drop_cache = true;\n\t\t\t\tret = btrfs_drop_extents(wc->trans, root,\n\t\t\t\t\t\t\t BTRFS_I(inode),\n\t\t\t\t\t\t\t &drop_args);\n\t\t\t\tif (!ret) {\n\t\t\t\t\tinode_sub_bytes(inode,\n\t\t\t\t\t\t\tdrop_args.bytes_found);\n\t\t\t\t\t \n\t\t\t\t\tret = btrfs_update_inode(wc->trans,\n\t\t\t\t\t\t\troot, BTRFS_I(inode));\n\t\t\t\t}\n\t\t\t\tiput(inode);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = link_to_fixup_dir(wc->trans, root,\n\t\t\t\t\t\tpath, key.objectid);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (wc->ignore_cur_inode)\n\t\t\tcontinue;\n\n\t\tif (key.type == BTRFS_DIR_INDEX_KEY &&\n\t\t    wc->stage == LOG_WALK_REPLAY_DIR_INDEX) {\n\t\t\tret = replay_one_dir_item(wc->trans, root, path,\n\t\t\t\t\t\t  eb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (wc->stage < LOG_WALK_REPLAY_ALL)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (key.type == BTRFS_XATTR_ITEM_KEY) {\n\t\t\tret = overwrite_item(wc->trans, root, path,\n\t\t\t\t\t     eb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else if (key.type == BTRFS_INODE_REF_KEY ||\n\t\t\t   key.type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\tret = add_inode_ref(wc->trans, root, log, path,\n\t\t\t\t\t    eb, i, &key);\n\t\t\tif (ret && ret != -ENOENT)\n\t\t\t\tbreak;\n\t\t\tret = 0;\n\t\t} else if (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tret = replay_one_extent(wc->trans, root, path,\n\t\t\t\t\t\teb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t}\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nstatic void unaccount_log_buffer(struct btrfs_fs_info *fs_info, u64 start)\n{\n\tstruct btrfs_block_group *cache;\n\n\tcache = btrfs_lookup_block_group(fs_info, start);\n\tif (!cache) {\n\t\tbtrfs_err(fs_info, \"unable to find block group for %llu\", start);\n\t\treturn;\n\t}\n\n\tspin_lock(&cache->space_info->lock);\n\tspin_lock(&cache->lock);\n\tcache->reserved -= fs_info->nodesize;\n\tcache->space_info->bytes_reserved -= fs_info->nodesize;\n\tspin_unlock(&cache->lock);\n\tspin_unlock(&cache->space_info->lock);\n\n\tbtrfs_put_block_group(cache);\n}\n\nstatic int clean_log_buffer(struct btrfs_trans_handle *trans,\n\t\t\t    struct extent_buffer *eb)\n{\n\tint ret;\n\n\tbtrfs_tree_lock(eb);\n\tbtrfs_clear_buffer_dirty(trans, eb);\n\twait_on_extent_buffer_writeback(eb);\n\tbtrfs_tree_unlock(eb);\n\n\tif (trans) {\n\t\tret = btrfs_pin_reserved_extent(trans, eb->start, eb->len);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbtrfs_redirty_list_add(trans->transaction, eb);\n\t} else {\n\t\tunaccount_log_buffer(eb->fs_info, eb->start);\n\t}\n\n\treturn 0;\n}\n\nstatic noinline int walk_down_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path, int *level,\n\t\t\t\t   struct walk_control *wc)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 bytenr;\n\tu64 ptr_gen;\n\tstruct extent_buffer *next;\n\tstruct extent_buffer *cur;\n\tint ret = 0;\n\n\twhile (*level > 0) {\n\t\tstruct btrfs_tree_parent_check check = { 0 };\n\n\t\tcur = path->nodes[*level];\n\n\t\tWARN_ON(btrfs_header_level(cur) != *level);\n\n\t\tif (path->slots[*level] >=\n\t\t    btrfs_header_nritems(cur))\n\t\t\tbreak;\n\n\t\tbytenr = btrfs_node_blockptr(cur, path->slots[*level]);\n\t\tptr_gen = btrfs_node_ptr_generation(cur, path->slots[*level]);\n\t\tcheck.transid = ptr_gen;\n\t\tcheck.level = *level - 1;\n\t\tcheck.has_first_key = true;\n\t\tbtrfs_node_key_to_cpu(cur, &check.first_key, path->slots[*level]);\n\n\t\tnext = btrfs_find_create_tree_block(fs_info, bytenr,\n\t\t\t\t\t\t    btrfs_header_owner(cur),\n\t\t\t\t\t\t    *level - 1);\n\t\tif (IS_ERR(next))\n\t\t\treturn PTR_ERR(next);\n\n\t\tif (*level == 1) {\n\t\t\tret = wc->process_func(root, next, wc, ptr_gen,\n\t\t\t\t\t       *level - 1);\n\t\t\tif (ret) {\n\t\t\t\tfree_extent_buffer(next);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tpath->slots[*level]++;\n\t\t\tif (wc->free) {\n\t\t\t\tret = btrfs_read_extent_buffer(next, &check);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfree_extent_buffer(next);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = clean_log_buffer(trans, next);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfree_extent_buffer(next);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree_extent_buffer(next);\n\t\t\tcontinue;\n\t\t}\n\t\tret = btrfs_read_extent_buffer(next, &check);\n\t\tif (ret) {\n\t\t\tfree_extent_buffer(next);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (path->nodes[*level-1])\n\t\t\tfree_extent_buffer(path->nodes[*level-1]);\n\t\tpath->nodes[*level-1] = next;\n\t\t*level = btrfs_header_level(next);\n\t\tpath->slots[*level] = 0;\n\t\tcond_resched();\n\t}\n\tpath->slots[*level] = btrfs_header_nritems(path->nodes[*level]);\n\n\tcond_resched();\n\treturn 0;\n}\n\nstatic noinline int walk_up_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path, int *level,\n\t\t\t\t struct walk_control *wc)\n{\n\tint i;\n\tint slot;\n\tint ret;\n\n\tfor (i = *level; i < BTRFS_MAX_LEVEL - 1 && path->nodes[i]; i++) {\n\t\tslot = path->slots[i];\n\t\tif (slot + 1 < btrfs_header_nritems(path->nodes[i])) {\n\t\t\tpath->slots[i]++;\n\t\t\t*level = i;\n\t\t\tWARN_ON(*level == 0);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tret = wc->process_func(root, path->nodes[*level], wc,\n\t\t\t\t btrfs_header_generation(path->nodes[*level]),\n\t\t\t\t *level);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (wc->free) {\n\t\t\t\tret = clean_log_buffer(trans, path->nodes[*level]);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tfree_extent_buffer(path->nodes[*level]);\n\t\t\tpath->nodes[*level] = NULL;\n\t\t\t*level = i + 1;\n\t\t}\n\t}\n\treturn 1;\n}\n\n \nstatic int walk_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *log, struct walk_control *wc)\n{\n\tint ret = 0;\n\tint wret;\n\tint level;\n\tstruct btrfs_path *path;\n\tint orig_level;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tlevel = btrfs_header_level(log->node);\n\torig_level = level;\n\tpath->nodes[level] = log->node;\n\tatomic_inc(&log->node->refs);\n\tpath->slots[level] = 0;\n\n\twhile (1) {\n\t\twret = walk_down_log_tree(trans, log, path, &level, wc);\n\t\tif (wret > 0)\n\t\t\tbreak;\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\n\t\twret = walk_up_log_tree(trans, log, path, &level, wc);\n\t\tif (wret > 0)\n\t\t\tbreak;\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (path->nodes[orig_level]) {\n\t\tret = wc->process_func(log, path->nodes[orig_level], wc,\n\t\t\t btrfs_header_generation(path->nodes[orig_level]),\n\t\t\t orig_level);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tif (wc->free)\n\t\t\tret = clean_log_buffer(trans, path->nodes[orig_level]);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nstatic int update_log_root(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *log,\n\t\t\t   struct btrfs_root_item *root_item)\n{\n\tstruct btrfs_fs_info *fs_info = log->fs_info;\n\tint ret;\n\n\tif (log->log_transid == 1) {\n\t\t \n\t\tret = btrfs_insert_root(trans, fs_info->log_root_tree,\n\t\t\t\t&log->root_key, root_item);\n\t} else {\n\t\tret = btrfs_update_root(trans, fs_info->log_root_tree,\n\t\t\t\t&log->root_key, root_item);\n\t}\n\treturn ret;\n}\n\nstatic void wait_log_commit(struct btrfs_root *root, int transid)\n{\n\tDEFINE_WAIT(wait);\n\tint index = transid % 2;\n\n\t \n\tfor (;;) {\n\t\tprepare_to_wait(&root->log_commit_wait[index],\n\t\t\t\t&wait, TASK_UNINTERRUPTIBLE);\n\n\t\tif (!(root->log_transid_committed < transid &&\n\t\t      atomic_read(&root->log_commit[index])))\n\t\t\tbreak;\n\n\t\tmutex_unlock(&root->log_mutex);\n\t\tschedule();\n\t\tmutex_lock(&root->log_mutex);\n\t}\n\tfinish_wait(&root->log_commit_wait[index], &wait);\n}\n\nstatic void wait_for_writer(struct btrfs_root *root)\n{\n\tDEFINE_WAIT(wait);\n\n\tfor (;;) {\n\t\tprepare_to_wait(&root->log_writer_wait, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&root->log_writers))\n\t\t\tbreak;\n\n\t\tmutex_unlock(&root->log_mutex);\n\t\tschedule();\n\t\tmutex_lock(&root->log_mutex);\n\t}\n\tfinish_wait(&root->log_writer_wait, &wait);\n}\n\nstatic inline void btrfs_remove_log_ctx(struct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_log_ctx *ctx)\n{\n\tmutex_lock(&root->log_mutex);\n\tlist_del_init(&ctx->list);\n\tmutex_unlock(&root->log_mutex);\n}\n\n \nstatic inline void btrfs_remove_all_log_ctxs(struct btrfs_root *root,\n\t\t\t\t\t     int index, int error)\n{\n\tstruct btrfs_log_ctx *ctx;\n\tstruct btrfs_log_ctx *safe;\n\n\tlist_for_each_entry_safe(ctx, safe, &root->log_ctxs[index], list) {\n\t\tlist_del_init(&ctx->list);\n\t\tctx->log_ret = error;\n\t}\n}\n\n \nint btrfs_sync_log(struct btrfs_trans_handle *trans,\n\t\t   struct btrfs_root *root, struct btrfs_log_ctx *ctx)\n{\n\tint index1;\n\tint index2;\n\tint mark;\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_root *log = root->log_root;\n\tstruct btrfs_root *log_root_tree = fs_info->log_root_tree;\n\tstruct btrfs_root_item new_root_item;\n\tint log_transid = 0;\n\tstruct btrfs_log_ctx root_log_ctx;\n\tstruct blk_plug plug;\n\tu64 log_root_start;\n\tu64 log_root_level;\n\n\tmutex_lock(&root->log_mutex);\n\tlog_transid = ctx->log_transid;\n\tif (root->log_transid_committed >= log_transid) {\n\t\tmutex_unlock(&root->log_mutex);\n\t\treturn ctx->log_ret;\n\t}\n\n\tindex1 = log_transid % 2;\n\tif (atomic_read(&root->log_commit[index1])) {\n\t\twait_log_commit(root, log_transid);\n\t\tmutex_unlock(&root->log_mutex);\n\t\treturn ctx->log_ret;\n\t}\n\tASSERT(log_transid == root->log_transid);\n\tatomic_set(&root->log_commit[index1], 1);\n\n\t \n\tif (atomic_read(&root->log_commit[(index1 + 1) % 2]))\n\t\twait_log_commit(root, log_transid - 1);\n\n\twhile (1) {\n\t\tint batch = atomic_read(&root->log_batch);\n\t\t \n\t\tif (!btrfs_test_opt(fs_info, SSD) &&\n\t\t    test_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state)) {\n\t\t\tmutex_unlock(&root->log_mutex);\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\tmutex_lock(&root->log_mutex);\n\t\t}\n\t\twait_for_writer(root);\n\t\tif (batch == atomic_read(&root->log_batch))\n\t\t\tbreak;\n\t}\n\n\t \n\tif (btrfs_need_log_full_commit(trans)) {\n\t\tret = BTRFS_LOG_FORCE_COMMIT;\n\t\tmutex_unlock(&root->log_mutex);\n\t\tgoto out;\n\t}\n\n\tif (log_transid % 2 == 0)\n\t\tmark = EXTENT_DIRTY;\n\telse\n\t\tmark = EXTENT_NEW;\n\n\t \n\tblk_start_plug(&plug);\n\tret = btrfs_write_marked_extents(fs_info, &log->dirty_log_pages, mark);\n\t \n\tif (ret == -EAGAIN && btrfs_is_zoned(fs_info))\n\t\tret = 0;\n\tif (ret) {\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_set_log_full_commit(trans);\n\t\tmutex_unlock(&root->log_mutex);\n\t\tgoto out;\n\t}\n\n\t \n\tbtrfs_set_root_node(&log->root_item, log->node);\n\tmemcpy(&new_root_item, &log->root_item, sizeof(new_root_item));\n\n\troot->log_transid++;\n\tlog->log_transid = root->log_transid;\n\troot->log_start_pid = 0;\n\t \n\tmutex_unlock(&root->log_mutex);\n\n\tif (btrfs_is_zoned(fs_info)) {\n\t\tmutex_lock(&fs_info->tree_root->log_mutex);\n\t\tif (!log_root_tree->node) {\n\t\t\tret = btrfs_alloc_log_tree_node(trans, log_root_tree);\n\t\t\tif (ret) {\n\t\t\t\tmutex_unlock(&fs_info->tree_root->log_mutex);\n\t\t\t\tblk_finish_plug(&plug);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&fs_info->tree_root->log_mutex);\n\t}\n\n\tbtrfs_init_log_ctx(&root_log_ctx, NULL);\n\n\tmutex_lock(&log_root_tree->log_mutex);\n\n\tindex2 = log_root_tree->log_transid % 2;\n\tlist_add_tail(&root_log_ctx.list, &log_root_tree->log_ctxs[index2]);\n\troot_log_ctx.log_transid = log_root_tree->log_transid;\n\n\t \n\tret = update_log_root(trans, log, &new_root_item);\n\tif (ret) {\n\t\tif (!list_empty(&root_log_ctx.list))\n\t\t\tlist_del_init(&root_log_ctx.list);\n\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_set_log_full_commit(trans);\n\t\tif (ret != -ENOSPC)\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\t  \"failed to update log for root %llu ret %d\",\n\t\t\t\t  root->root_key.objectid, ret);\n\t\tbtrfs_wait_tree_log_extents(log, mark);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tgoto out;\n\t}\n\n\tif (log_root_tree->log_transid_committed >= root_log_ctx.log_transid) {\n\t\tblk_finish_plug(&plug);\n\t\tlist_del_init(&root_log_ctx.list);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = root_log_ctx.log_ret;\n\t\tgoto out;\n\t}\n\n\tindex2 = root_log_ctx.log_transid % 2;\n\tif (atomic_read(&log_root_tree->log_commit[index2])) {\n\t\tblk_finish_plug(&plug);\n\t\tret = btrfs_wait_tree_log_extents(log, mark);\n\t\twait_log_commit(log_root_tree,\n\t\t\t\troot_log_ctx.log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tif (!ret)\n\t\t\tret = root_log_ctx.log_ret;\n\t\tgoto out;\n\t}\n\tASSERT(root_log_ctx.log_transid == log_root_tree->log_transid);\n\tatomic_set(&log_root_tree->log_commit[index2], 1);\n\n\tif (atomic_read(&log_root_tree->log_commit[(index2 + 1) % 2])) {\n\t\twait_log_commit(log_root_tree,\n\t\t\t\troot_log_ctx.log_transid - 1);\n\t}\n\n\t \n\tif (btrfs_need_log_full_commit(trans)) {\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_wait_tree_log_extents(log, mark);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = BTRFS_LOG_FORCE_COMMIT;\n\t\tgoto out_wake_log_root;\n\t}\n\n\tret = btrfs_write_marked_extents(fs_info,\n\t\t\t\t\t &log_root_tree->dirty_log_pages,\n\t\t\t\t\t EXTENT_DIRTY | EXTENT_NEW);\n\tblk_finish_plug(&plug);\n\t \n\tif (ret == -EAGAIN && btrfs_is_zoned(fs_info)) {\n\t\tbtrfs_set_log_full_commit(trans);\n\t\tbtrfs_wait_tree_log_extents(log, mark);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tgoto out_wake_log_root;\n\t} else if (ret) {\n\t\tbtrfs_set_log_full_commit(trans);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tgoto out_wake_log_root;\n\t}\n\tret = btrfs_wait_tree_log_extents(log, mark);\n\tif (!ret)\n\t\tret = btrfs_wait_tree_log_extents(log_root_tree,\n\t\t\t\t\t\t  EXTENT_NEW | EXTENT_DIRTY);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(trans);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tgoto out_wake_log_root;\n\t}\n\n\tlog_root_start = log_root_tree->node->start;\n\tlog_root_level = btrfs_header_level(log_root_tree->node);\n\tlog_root_tree->log_transid++;\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\t \n\tmutex_lock(&fs_info->tree_log_mutex);\n\n\t \n\tif (BTRFS_FS_ERROR(fs_info)) {\n\t\tret = -EIO;\n\t\tbtrfs_set_log_full_commit(trans);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tmutex_unlock(&fs_info->tree_log_mutex);\n\t\tgoto out_wake_log_root;\n\t}\n\n\tbtrfs_set_super_log_root(fs_info->super_for_commit, log_root_start);\n\tbtrfs_set_super_log_root_level(fs_info->super_for_commit, log_root_level);\n\tret = write_all_supers(fs_info, 1);\n\tmutex_unlock(&fs_info->tree_log_mutex);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(trans);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out_wake_log_root;\n\t}\n\n\t \n\tASSERT(root->last_log_commit <= log_transid);\n\troot->last_log_commit = log_transid;\n\nout_wake_log_root:\n\tmutex_lock(&log_root_tree->log_mutex);\n\tbtrfs_remove_all_log_ctxs(log_root_tree, index2, ret);\n\n\tlog_root_tree->log_transid_committed++;\n\tatomic_set(&log_root_tree->log_commit[index2], 0);\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\t \n\tcond_wake_up(&log_root_tree->log_commit_wait[index2]);\nout:\n\tmutex_lock(&root->log_mutex);\n\tbtrfs_remove_all_log_ctxs(root, index1, ret);\n\troot->log_transid_committed++;\n\tatomic_set(&root->log_commit[index1], 0);\n\tmutex_unlock(&root->log_mutex);\n\n\t \n\tcond_wake_up(&root->log_commit_wait[index1]);\n\treturn ret;\n}\n\nstatic void free_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *log)\n{\n\tint ret;\n\tstruct walk_control wc = {\n\t\t.free = 1,\n\t\t.process_func = process_one_buffer\n\t};\n\n\tif (log->node) {\n\t\tret = walk_log_tree(trans, log, &wc);\n\t\tif (ret) {\n\t\t\t \n\t\t\tset_bit(BTRFS_FS_STATE_LOG_CLEANUP_ERROR,\n\t\t\t\t&log->fs_info->fs_state);\n\n\t\t\t \n\t\t\tbtrfs_write_marked_extents(log->fs_info,\n\t\t\t\t\t\t   &log->dirty_log_pages,\n\t\t\t\t\t\t   EXTENT_DIRTY | EXTENT_NEW);\n\t\t\tbtrfs_wait_tree_log_extents(log,\n\t\t\t\t\t\t    EXTENT_DIRTY | EXTENT_NEW);\n\n\t\t\tif (trans)\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\telse\n\t\t\t\tbtrfs_handle_fs_error(log->fs_info, ret, NULL);\n\t\t}\n\t}\n\n\tclear_extent_bits(&log->dirty_log_pages, 0, (u64)-1,\n\t\t\t  EXTENT_DIRTY | EXTENT_NEW | EXTENT_NEED_WAIT);\n\textent_io_tree_release(&log->log_csum_range);\n\n\tbtrfs_put_root(log);\n}\n\n \nint btrfs_free_log(struct btrfs_trans_handle *trans, struct btrfs_root *root)\n{\n\tif (root->log_root) {\n\t\tfree_log_tree(trans, root->log_root);\n\t\troot->log_root = NULL;\n\t\tclear_bit(BTRFS_ROOT_HAS_LOG_TREE, &root->state);\n\t}\n\treturn 0;\n}\n\nint btrfs_free_log_root_tree(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->log_root_tree) {\n\t\tfree_log_tree(trans, fs_info->log_root_tree);\n\t\tfs_info->log_root_tree = NULL;\n\t\tclear_bit(BTRFS_ROOT_HAS_LOG_TREE, &fs_info->tree_root->state);\n\t}\n\treturn 0;\n}\n\n \nstatic int inode_logged(const struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_inode *inode,\n\t\t\tstruct btrfs_path *path_in)\n{\n\tstruct btrfs_path *path = path_in;\n\tstruct btrfs_key key;\n\tint ret;\n\n\tif (inode->logged_trans == trans->transid)\n\t\treturn 1;\n\n\t \n\tif (inode->logged_trans > 0)\n\t\treturn 0;\n\n\t \n\tif (!test_bit(BTRFS_ROOT_HAS_LOG_TREE, &inode->root->state)) {\n\t\tinode->logged_trans = trans->transid - 1;\n\t\treturn 0;\n\t}\n\n\t \n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tif (!path) {\n\t\tpath = btrfs_alloc_path();\n\t\tif (!path)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tret = btrfs_search_slot(NULL, inode->root->log_root, &key, path, 0, 0);\n\n\tif (path_in)\n\t\tbtrfs_release_path(path);\n\telse\n\t\tbtrfs_free_path(path);\n\n\t \n\tif (ret < 0) {\n\t\treturn ret;\n\t} else if (ret > 0) {\n\t\t \n\t\tinode->logged_trans = trans->transid - 1;\n\t\treturn 0;\n\t}\n\n\t \n\tinode->logged_trans = trans->transid;\n\n\t \n\tif (S_ISDIR(inode->vfs_inode.i_mode))\n\t\tinode->last_dir_index_offset = (u64)-1;\n\n\treturn 1;\n}\n\n \nstatic int del_logged_dentry(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *log,\n\t\t\t     struct btrfs_path *path,\n\t\t\t     u64 dir_ino,\n\t\t\t     const struct fscrypt_str *name,\n\t\t\t     u64 index)\n{\n\tstruct btrfs_dir_item *di;\n\n\t \n\tdi = btrfs_lookup_dir_index_item(trans, log, path, dir_ino,\n\t\t\t\t\t index, name, -1);\n\tif (IS_ERR(di))\n\t\treturn PTR_ERR(di);\n\telse if (!di)\n\t\treturn 1;\n\n\t \n\treturn btrfs_delete_one_dir_name(trans, log, path, di);\n}\n\n \nvoid btrfs_del_dir_entries_in_log(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t  const struct fscrypt_str *name,\n\t\t\t\t  struct btrfs_inode *dir, u64 index)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tret = inode_logged(trans, dir, NULL);\n\tif (ret == 0)\n\t\treturn;\n\telse if (ret < 0) {\n\t\tbtrfs_set_log_full_commit(trans);\n\t\treturn;\n\t}\n\n\tret = join_running_log_trans(root);\n\tif (ret)\n\t\treturn;\n\n\tmutex_lock(&dir->log_mutex);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tret = del_logged_dentry(trans, root->log_root, path, btrfs_ino(dir),\n\t\t\t\tname, index);\n\tbtrfs_free_path(path);\nout_unlock:\n\tmutex_unlock(&dir->log_mutex);\n\tif (ret < 0)\n\t\tbtrfs_set_log_full_commit(trans);\n\tbtrfs_end_log_trans(root);\n}\n\n \nvoid btrfs_del_inode_ref_in_log(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tconst struct fscrypt_str *name,\n\t\t\t\tstruct btrfs_inode *inode, u64 dirid)\n{\n\tstruct btrfs_root *log;\n\tu64 index;\n\tint ret;\n\n\tret = inode_logged(trans, inode, NULL);\n\tif (ret == 0)\n\t\treturn;\n\telse if (ret < 0) {\n\t\tbtrfs_set_log_full_commit(trans);\n\t\treturn;\n\t}\n\n\tret = join_running_log_trans(root);\n\tif (ret)\n\t\treturn;\n\tlog = root->log_root;\n\tmutex_lock(&inode->log_mutex);\n\n\tret = btrfs_del_inode_ref(trans, log, name, btrfs_ino(inode),\n\t\t\t\t  dirid, &index);\n\tmutex_unlock(&inode->log_mutex);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tbtrfs_set_log_full_commit(trans);\n\tbtrfs_end_log_trans(root);\n}\n\n \nstatic noinline int insert_dir_log_key(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       u64 dirid,\n\t\t\t\t       u64 first_offset, u64 last_offset)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_dir_log_item *item;\n\n\tkey.objectid = dirid;\n\tkey.offset = first_offset;\n\tkey.type = BTRFS_DIR_LOG_INDEX_KEY;\n\tret = btrfs_insert_empty_item(trans, log, path, &key, sizeof(*item));\n\t \n\tif (ret && ret != -EEXIST)\n\t\treturn ret;\n\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_dir_log_item);\n\tif (ret == -EEXIST) {\n\t\tconst u64 curr_end = btrfs_dir_log_end(path->nodes[0], item);\n\n\t\t \n\t\tlast_offset = max(last_offset, curr_end);\n\t}\n\tbtrfs_set_dir_log_end(path->nodes[0], item, last_offset);\n\tbtrfs_mark_buffer_dirty(trans, path->nodes[0]);\n\tbtrfs_release_path(path);\n\treturn 0;\n}\n\nstatic int flush_dir_items_batch(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_inode *inode,\n\t\t\t\t struct extent_buffer *src,\n\t\t\t\t struct btrfs_path *dst_path,\n\t\t\t\t int start_slot,\n\t\t\t\t int count)\n{\n\tstruct btrfs_root *log = inode->root->log_root;\n\tchar *ins_data = NULL;\n\tstruct btrfs_item_batch batch;\n\tstruct extent_buffer *dst;\n\tunsigned long src_offset;\n\tunsigned long dst_offset;\n\tu64 last_index;\n\tstruct btrfs_key key;\n\tu32 item_size;\n\tint ret;\n\tint i;\n\n\tASSERT(count > 0);\n\tbatch.nr = count;\n\n\tif (count == 1) {\n\t\tbtrfs_item_key_to_cpu(src, &key, start_slot);\n\t\titem_size = btrfs_item_size(src, start_slot);\n\t\tbatch.keys = &key;\n\t\tbatch.data_sizes = &item_size;\n\t\tbatch.total_data_size = item_size;\n\t} else {\n\t\tstruct btrfs_key *ins_keys;\n\t\tu32 *ins_sizes;\n\n\t\tins_data = kmalloc(count * sizeof(u32) +\n\t\t\t\t   count * sizeof(struct btrfs_key), GFP_NOFS);\n\t\tif (!ins_data)\n\t\t\treturn -ENOMEM;\n\n\t\tins_sizes = (u32 *)ins_data;\n\t\tins_keys = (struct btrfs_key *)(ins_data + count * sizeof(u32));\n\t\tbatch.keys = ins_keys;\n\t\tbatch.data_sizes = ins_sizes;\n\t\tbatch.total_data_size = 0;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tconst int slot = start_slot + i;\n\n\t\t\tbtrfs_item_key_to_cpu(src, &ins_keys[i], slot);\n\t\t\tins_sizes[i] = btrfs_item_size(src, slot);\n\t\t\tbatch.total_data_size += ins_sizes[i];\n\t\t}\n\t}\n\n\tret = btrfs_insert_empty_items(trans, log, dst_path, &batch);\n\tif (ret)\n\t\tgoto out;\n\n\tdst = dst_path->nodes[0];\n\t \n\tdst_offset = btrfs_item_ptr_offset(dst, dst_path->slots[0] + count - 1);\n\tsrc_offset = btrfs_item_ptr_offset(src, start_slot + count - 1);\n\tcopy_extent_buffer(dst, src, dst_offset, src_offset, batch.total_data_size);\n\tbtrfs_release_path(dst_path);\n\n\tlast_index = batch.keys[count - 1].offset;\n\tASSERT(last_index > inode->last_dir_index_offset);\n\n\t \n\tif (WARN_ON(last_index <= inode->last_dir_index_offset))\n\t\tret = BTRFS_LOG_FORCE_COMMIT;\n\telse\n\t\tinode->last_dir_index_offset = last_index;\n\n\tif (btrfs_get_first_dir_index_to_log(inode) == 0)\n\t\tbtrfs_set_first_dir_index_to_log(inode, batch.keys[0].offset);\nout:\n\tkfree(ins_data);\n\n\treturn ret;\n}\n\nstatic int process_dir_items_leaf(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_inode *inode,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_path *dst_path,\n\t\t\t\t  struct btrfs_log_ctx *ctx,\n\t\t\t\t  u64 *last_old_dentry_offset)\n{\n\tstruct btrfs_root *log = inode->root->log_root;\n\tstruct extent_buffer *src;\n\tconst int nritems = btrfs_header_nritems(path->nodes[0]);\n\tconst u64 ino = btrfs_ino(inode);\n\tbool last_found = false;\n\tint batch_start = 0;\n\tint batch_size = 0;\n\tint i;\n\n\t \n\tsrc = btrfs_clone_extent_buffer(path->nodes[0]);\n\tif (!src)\n\t\treturn -ENOMEM;\n\n\ti = path->slots[0];\n\tbtrfs_release_path(path);\n\tpath->nodes[0] = src;\n\tpath->slots[0] = i;\n\n\tfor (; i < nritems; i++) {\n\t\tstruct btrfs_dir_item *di;\n\t\tstruct btrfs_key key;\n\t\tint ret;\n\n\t\tbtrfs_item_key_to_cpu(src, &key, i);\n\n\t\tif (key.objectid != ino || key.type != BTRFS_DIR_INDEX_KEY) {\n\t\t\tlast_found = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tdi = btrfs_item_ptr(src, i, struct btrfs_dir_item);\n\n\t\t \n\t\tif (btrfs_dir_transid(src, di) < trans->transid) {\n\t\t\tif (key.offset > *last_old_dentry_offset + 1) {\n\t\t\t\tret = insert_dir_log_key(trans, log, dst_path,\n\t\t\t\t\t\t ino, *last_old_dentry_offset + 1,\n\t\t\t\t\t\t key.offset - 1);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t*last_old_dentry_offset = key.offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (key.offset <= inode->last_dir_index_offset)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!ctx->log_new_dentries) {\n\t\t\tstruct btrfs_key di_key;\n\n\t\t\tbtrfs_dir_item_key_to_cpu(src, di, &di_key);\n\t\t\tif (di_key.type != BTRFS_ROOT_ITEM_KEY)\n\t\t\t\tctx->log_new_dentries = true;\n\t\t}\n\n\t\tif (batch_size == 0)\n\t\t\tbatch_start = i;\n\t\tbatch_size++;\n\t}\n\n\tif (batch_size > 0) {\n\t\tint ret;\n\n\t\tret = flush_dir_items_batch(trans, inode, src, dst_path,\n\t\t\t\t\t    batch_start, batch_size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn last_found ? 1 : 0;\n}\n\n \nstatic noinline int log_dir_items(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_inode *inode,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_path *dst_path,\n\t\t\t  struct btrfs_log_ctx *ctx,\n\t\t\t  u64 min_offset, u64 *last_offset_ret)\n{\n\tstruct btrfs_key min_key;\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_root *log = root->log_root;\n\tint ret;\n\tu64 last_old_dentry_offset = min_offset - 1;\n\tu64 last_offset = (u64)-1;\n\tu64 ino = btrfs_ino(inode);\n\n\tmin_key.objectid = ino;\n\tmin_key.type = BTRFS_DIR_INDEX_KEY;\n\tmin_key.offset = min_offset;\n\n\tret = btrfs_search_forward(root, &min_key, path, trans->transid);\n\n\t \n\tif (ret != 0 || min_key.objectid != ino ||\n\t    min_key.type != BTRFS_DIR_INDEX_KEY) {\n\t\tmin_key.objectid = ino;\n\t\tmin_key.type = BTRFS_DIR_INDEX_KEY;\n\t\tmin_key.offset = (u64)-1;\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(NULL, root, &min_key, path, 0, 0);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn ret;\n\t\t}\n\t\tret = btrfs_previous_item(root, path, ino, BTRFS_DIR_INDEX_KEY);\n\n\t\t \n\t\tif (ret == 0) {\n\t\t\tstruct btrfs_key tmp;\n\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &tmp,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (tmp.type == BTRFS_DIR_INDEX_KEY)\n\t\t\t\tlast_old_dentry_offset = tmp.offset;\n\t\t} else if (ret > 0) {\n\t\t\tret = 0;\n\t\t}\n\n\t\tgoto done;\n\t}\n\n\t \n\tret = btrfs_previous_item(root, path, ino, BTRFS_DIR_INDEX_KEY);\n\tif (ret == 0) {\n\t\tstruct btrfs_key tmp;\n\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &tmp, path->slots[0]);\n\t\t \n\t\tif (tmp.type == BTRFS_DIR_INDEX_KEY)\n\t\t\tlast_old_dentry_offset = tmp.offset;\n\t} else if (ret < 0) {\n\t\tgoto done;\n\t}\n\n\tbtrfs_release_path(path);\n\n\t \nsearch:\n\tret = btrfs_search_slot(NULL, root, &min_key, path, 0, 0);\n\tif (ret > 0) {\n\t\tret = btrfs_next_item(root, path);\n\t\tif (ret > 0) {\n\t\t\t \n\t\t\tret = 0;\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (ret < 0)\n\t\tgoto done;\n\n\t \n\twhile (1) {\n\t\tret = process_dir_items_leaf(trans, inode, path, dst_path, ctx,\n\t\t\t\t\t     &last_old_dentry_offset);\n\t\tif (ret != 0) {\n\t\t\tif (ret > 0)\n\t\t\t\tret = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tpath->slots[0] = btrfs_header_nritems(path->nodes[0]);\n\n\t\t \n\t\tret = btrfs_next_leaf(root, path);\n\t\tif (ret) {\n\t\t\tif (ret == 1) {\n\t\t\t\tlast_offset = (u64)-1;\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &min_key, path->slots[0]);\n\t\tif (min_key.objectid != ino || min_key.type != BTRFS_DIR_INDEX_KEY) {\n\t\t\tlast_offset = (u64)-1;\n\t\t\tgoto done;\n\t\t}\n\t\tif (btrfs_header_generation(path->nodes[0]) != trans->transid) {\n\t\t\t \n\t\t\tlast_offset = min_key.offset - 1;\n\t\t\tgoto done;\n\t\t}\n\t\tif (need_resched()) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tcond_resched();\n\t\t\tgoto search;\n\t\t}\n\t}\ndone:\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(dst_path);\n\n\tif (ret == 0) {\n\t\t*last_offset_ret = last_offset;\n\t\t \n\t\tASSERT(last_old_dentry_offset <= last_offset);\n\t\tif (last_old_dentry_offset < last_offset)\n\t\t\tret = insert_dir_log_key(trans, log, path, ino,\n\t\t\t\t\t\t last_old_dentry_offset + 1,\n\t\t\t\t\t\t last_offset);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int update_last_dir_index_offset(struct btrfs_inode *inode,\n\t\t\t\t\tstruct btrfs_path *path,\n\t\t\t\t\tconst struct btrfs_log_ctx *ctx)\n{\n\tconst u64 ino = btrfs_ino(inode);\n\tstruct btrfs_key key;\n\tint ret;\n\n\tlockdep_assert_held(&inode->log_mutex);\n\n\tif (inode->last_dir_index_offset != (u64)-1)\n\t\treturn 0;\n\n\tif (!ctx->logged_before) {\n\t\tinode->last_dir_index_offset = BTRFS_DIR_START_INDEX - 1;\n\t\treturn 0;\n\t}\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, inode->root->log_root, &key, path, 0, 0);\n\t \n\tif (ret <= 0)\n\t\tgoto out;\n\n\tret = 0;\n\tinode->last_dir_index_offset = BTRFS_DIR_START_INDEX - 1;\n\n\t \n\tif (path->slots[0] == 0)\n\t\tgoto out;\n\n\t \n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0] - 1);\n\tif (key.objectid == ino && key.type == BTRFS_DIR_INDEX_KEY)\n\t\tinode->last_dir_index_offset = key.offset;\n\nout:\n\tbtrfs_release_path(path);\n\n\treturn ret;\n}\n\n \nstatic noinline int log_directory_changes(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_inode *inode,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_path *dst_path,\n\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tu64 min_key;\n\tu64 max_key;\n\tint ret;\n\n\tret = update_last_dir_index_offset(inode, path, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tmin_key = BTRFS_DIR_START_INDEX;\n\tmax_key = 0;\n\n\twhile (1) {\n\t\tret = log_dir_items(trans, inode, path, dst_path,\n\t\t\t\tctx, min_key, &max_key);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (max_key == (u64)-1)\n\t\t\tbreak;\n\t\tmin_key = max_key + 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int drop_inode_items(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *log,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_inode *inode,\n\t\t\t\t  int max_key_type)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tint start_slot;\n\n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = max_key_type;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, log, &key, path, -1, 1);\n\t\tif (ret < 0) {\n\t\t\tbreak;\n\t\t} else if (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\n\t\tif (found_key.objectid != key.objectid)\n\t\t\tbreak;\n\n\t\tfound_key.offset = 0;\n\t\tfound_key.type = 0;\n\t\tret = btrfs_bin_search(path->nodes[0], 0, &found_key, &start_slot);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tret = btrfs_del_items(trans, log, path, start_slot,\n\t\t\t\t      path->slots[0] - start_slot + 1);\n\t\t \n\t\tif (ret || start_slot != 0)\n\t\t\tbreak;\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_release_path(path);\n\tif (ret > 0)\n\t\tret = 0;\n\treturn ret;\n}\n\nstatic int truncate_inode_items(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *log_root,\n\t\t\t\tstruct btrfs_inode *inode,\n\t\t\t\tu64 new_size, u32 min_type)\n{\n\tstruct btrfs_truncate_control control = {\n\t\t.new_size = new_size,\n\t\t.ino = btrfs_ino(inode),\n\t\t.min_type = min_type,\n\t\t.skip_ref_updates = true,\n\t};\n\n\treturn btrfs_truncate_inode_items(trans, log_root, &control);\n}\n\nstatic void fill_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct extent_buffer *leaf,\n\t\t\t    struct btrfs_inode_item *item,\n\t\t\t    struct inode *inode, int log_inode_only,\n\t\t\t    u64 logged_isize)\n{\n\tstruct btrfs_map_token token;\n\tu64 flags;\n\n\tbtrfs_init_map_token(&token, leaf);\n\n\tif (log_inode_only) {\n\t\t \n\t\tbtrfs_set_token_inode_generation(&token, item, 0);\n\t\tbtrfs_set_token_inode_size(&token, item, logged_isize);\n\t} else {\n\t\tbtrfs_set_token_inode_generation(&token, item,\n\t\t\t\t\t\t BTRFS_I(inode)->generation);\n\t\tbtrfs_set_token_inode_size(&token, item, inode->i_size);\n\t}\n\n\tbtrfs_set_token_inode_uid(&token, item, i_uid_read(inode));\n\tbtrfs_set_token_inode_gid(&token, item, i_gid_read(inode));\n\tbtrfs_set_token_inode_mode(&token, item, inode->i_mode);\n\tbtrfs_set_token_inode_nlink(&token, item, inode->i_nlink);\n\n\tbtrfs_set_token_timespec_sec(&token, &item->atime,\n\t\t\t\t     inode->i_atime.tv_sec);\n\tbtrfs_set_token_timespec_nsec(&token, &item->atime,\n\t\t\t\t      inode->i_atime.tv_nsec);\n\n\tbtrfs_set_token_timespec_sec(&token, &item->mtime,\n\t\t\t\t     inode->i_mtime.tv_sec);\n\tbtrfs_set_token_timespec_nsec(&token, &item->mtime,\n\t\t\t\t      inode->i_mtime.tv_nsec);\n\n\tbtrfs_set_token_timespec_sec(&token, &item->ctime,\n\t\t\t\t     inode_get_ctime(inode).tv_sec);\n\tbtrfs_set_token_timespec_nsec(&token, &item->ctime,\n\t\t\t\t      inode_get_ctime(inode).tv_nsec);\n\n\t \n\n\tbtrfs_set_token_inode_sequence(&token, item, inode_peek_iversion(inode));\n\tbtrfs_set_token_inode_transid(&token, item, trans->transid);\n\tbtrfs_set_token_inode_rdev(&token, item, inode->i_rdev);\n\tflags = btrfs_inode_combine_flags(BTRFS_I(inode)->flags,\n\t\t\t\t\t  BTRFS_I(inode)->ro_flags);\n\tbtrfs_set_token_inode_flags(&token, item, flags);\n\tbtrfs_set_token_inode_block_group(&token, item, 0);\n}\n\nstatic int log_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *log, struct btrfs_path *path,\n\t\t\t  struct btrfs_inode *inode, bool inode_item_dropped)\n{\n\tstruct btrfs_inode_item *inode_item;\n\tint ret;\n\n\t \n\tif (!inode_item_dropped && inode->logged_trans == trans->transid) {\n\t\tret = btrfs_search_slot(trans, log, &inode->location, path, 0, 1);\n\t\tASSERT(ret <= 0);\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t} else {\n\t\t \n\t\tret = btrfs_insert_empty_item(trans, log, path, &inode->location,\n\t\t\t\t\t      sizeof(*inode_item));\n\t\tASSERT(ret != -EEXIST);\n\t}\n\tif (ret)\n\t\treturn ret;\n\tinode_item = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\tfill_inode_item(trans, path->nodes[0], inode_item, &inode->vfs_inode,\n\t\t\t0, 0);\n\tbtrfs_release_path(path);\n\treturn 0;\n}\n\nstatic int log_csums(struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_inode *inode,\n\t\t     struct btrfs_root *log_root,\n\t\t     struct btrfs_ordered_sum *sums)\n{\n\tconst u64 lock_end = sums->logical + sums->len - 1;\n\tstruct extent_state *cached_state = NULL;\n\tint ret;\n\n\t \n\tif (inode->last_reflink_trans < trans->transid)\n\t\treturn btrfs_csum_file_blocks(trans, log_root, sums);\n\n\t \n\tret = lock_extent(&log_root->log_csum_range, sums->logical, lock_end,\n\t\t\t  &cached_state);\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = btrfs_del_csums(trans, log_root, sums->logical, sums->len);\n\tif (!ret)\n\t\tret = btrfs_csum_file_blocks(trans, log_root, sums);\n\n\tunlock_extent(&log_root->log_csum_range, sums->logical, lock_end,\n\t\t      &cached_state);\n\n\treturn ret;\n}\n\nstatic noinline int copy_items(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_inode *inode,\n\t\t\t       struct btrfs_path *dst_path,\n\t\t\t       struct btrfs_path *src_path,\n\t\t\t       int start_slot, int nr, int inode_only,\n\t\t\t       u64 logged_isize)\n{\n\tstruct btrfs_root *log = inode->root->log_root;\n\tstruct btrfs_file_extent_item *extent;\n\tstruct extent_buffer *src;\n\tint ret = 0;\n\tstruct btrfs_key *ins_keys;\n\tu32 *ins_sizes;\n\tstruct btrfs_item_batch batch;\n\tchar *ins_data;\n\tint i;\n\tint dst_index;\n\tconst bool skip_csum = (inode->flags & BTRFS_INODE_NODATASUM);\n\tconst u64 i_size = i_size_read(&inode->vfs_inode);\n\n\t \n\tsrc = btrfs_clone_extent_buffer(src_path->nodes[0]);\n\tif (!src)\n\t\treturn -ENOMEM;\n\n\ti = src_path->slots[0];\n\tbtrfs_release_path(src_path);\n\tsrc_path->nodes[0] = src;\n\tsrc_path->slots[0] = i;\n\n\tins_data = kmalloc(nr * sizeof(struct btrfs_key) +\n\t\t\t   nr * sizeof(u32), GFP_NOFS);\n\tif (!ins_data)\n\t\treturn -ENOMEM;\n\n\tins_sizes = (u32 *)ins_data;\n\tins_keys = (struct btrfs_key *)(ins_data + nr * sizeof(u32));\n\tbatch.keys = ins_keys;\n\tbatch.data_sizes = ins_sizes;\n\tbatch.total_data_size = 0;\n\tbatch.nr = 0;\n\n\tdst_index = 0;\n\tfor (i = 0; i < nr; i++) {\n\t\tconst int src_slot = start_slot + i;\n\t\tstruct btrfs_root *csum_root;\n\t\tstruct btrfs_ordered_sum *sums;\n\t\tstruct btrfs_ordered_sum *sums_next;\n\t\tLIST_HEAD(ordered_sums);\n\t\tu64 disk_bytenr;\n\t\tu64 disk_num_bytes;\n\t\tu64 extent_offset;\n\t\tu64 extent_num_bytes;\n\t\tbool is_old_extent;\n\n\t\tbtrfs_item_key_to_cpu(src, &ins_keys[dst_index], src_slot);\n\n\t\tif (ins_keys[dst_index].type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto add_to_batch;\n\n\t\textent = btrfs_item_ptr(src, src_slot,\n\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\tis_old_extent = (btrfs_file_extent_generation(src, extent) <\n\t\t\t\t trans->transid);\n\n\t\t \n\t\tif (is_old_extent &&\n\t\t    ins_keys[dst_index].offset < i_size &&\n\t\t    inode->last_reflink_trans < trans->transid)\n\t\t\tcontinue;\n\n\t\tif (skip_csum)\n\t\t\tgoto add_to_batch;\n\n\t\t \n\t\tif (btrfs_file_extent_type(src, extent) != BTRFS_FILE_EXTENT_REG)\n\t\t\tgoto add_to_batch;\n\n\t\t \n\t\tif (is_old_extent)\n\t\t\tgoto add_to_batch;\n\n\t\tdisk_bytenr = btrfs_file_extent_disk_bytenr(src, extent);\n\t\t \n\t\tif (disk_bytenr == 0)\n\t\t\tgoto add_to_batch;\n\n\t\tdisk_num_bytes = btrfs_file_extent_disk_num_bytes(src, extent);\n\n\t\tif (btrfs_file_extent_compression(src, extent)) {\n\t\t\textent_offset = 0;\n\t\t\textent_num_bytes = disk_num_bytes;\n\t\t} else {\n\t\t\textent_offset = btrfs_file_extent_offset(src, extent);\n\t\t\textent_num_bytes = btrfs_file_extent_num_bytes(src, extent);\n\t\t}\n\n\t\tcsum_root = btrfs_csum_root(trans->fs_info, disk_bytenr);\n\t\tdisk_bytenr += extent_offset;\n\t\tret = btrfs_lookup_csums_list(csum_root, disk_bytenr,\n\t\t\t\t\t      disk_bytenr + extent_num_bytes - 1,\n\t\t\t\t\t      &ordered_sums, 0, false);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tlist_for_each_entry_safe(sums, sums_next, &ordered_sums, list) {\n\t\t\tif (!ret)\n\t\t\t\tret = log_csums(trans, inode, log, sums);\n\t\t\tlist_del(&sums->list);\n\t\t\tkfree(sums);\n\t\t}\n\t\tif (ret)\n\t\t\tgoto out;\n\nadd_to_batch:\n\t\tins_sizes[dst_index] = btrfs_item_size(src, src_slot);\n\t\tbatch.total_data_size += ins_sizes[dst_index];\n\t\tbatch.nr++;\n\t\tdst_index++;\n\t}\n\n\t \n\tif (batch.nr == 0)\n\t\tgoto out;\n\n\tret = btrfs_insert_empty_items(trans, log, dst_path, &batch);\n\tif (ret)\n\t\tgoto out;\n\n\tdst_index = 0;\n\tfor (i = 0; i < nr; i++) {\n\t\tconst int src_slot = start_slot + i;\n\t\tconst int dst_slot = dst_path->slots[0] + dst_index;\n\t\tstruct btrfs_key key;\n\t\tunsigned long src_offset;\n\t\tunsigned long dst_offset;\n\n\t\t \n\t\tif (dst_index >= batch.nr)\n\t\t\tbreak;\n\n\t\tbtrfs_item_key_to_cpu(src, &key, src_slot);\n\n\t\tif (key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto copy_item;\n\n\t\textent = btrfs_item_ptr(src, src_slot,\n\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t \n\t\tif (btrfs_file_extent_generation(src, extent) < trans->transid &&\n\t\t    key.offset < i_size &&\n\t\t    inode->last_reflink_trans < trans->transid)\n\t\t\tcontinue;\n\ncopy_item:\n\t\tdst_offset = btrfs_item_ptr_offset(dst_path->nodes[0], dst_slot);\n\t\tsrc_offset = btrfs_item_ptr_offset(src, src_slot);\n\n\t\tif (key.type == BTRFS_INODE_ITEM_KEY) {\n\t\t\tstruct btrfs_inode_item *inode_item;\n\n\t\t\tinode_item = btrfs_item_ptr(dst_path->nodes[0], dst_slot,\n\t\t\t\t\t\t    struct btrfs_inode_item);\n\t\t\tfill_inode_item(trans, dst_path->nodes[0], inode_item,\n\t\t\t\t\t&inode->vfs_inode,\n\t\t\t\t\tinode_only == LOG_INODE_EXISTS,\n\t\t\t\t\tlogged_isize);\n\t\t} else {\n\t\t\tcopy_extent_buffer(dst_path->nodes[0], src, dst_offset,\n\t\t\t\t\t   src_offset, ins_sizes[dst_index]);\n\t\t}\n\n\t\tdst_index++;\n\t}\n\n\tbtrfs_mark_buffer_dirty(trans, dst_path->nodes[0]);\n\tbtrfs_release_path(dst_path);\nout:\n\tkfree(ins_data);\n\n\treturn ret;\n}\n\nstatic int extent_cmp(void *priv, const struct list_head *a,\n\t\t      const struct list_head *b)\n{\n\tconst struct extent_map *em1, *em2;\n\n\tem1 = list_entry(a, struct extent_map, list);\n\tem2 = list_entry(b, struct extent_map, list);\n\n\tif (em1->start < em2->start)\n\t\treturn -1;\n\telse if (em1->start > em2->start)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int log_extent_csums(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_inode *inode,\n\t\t\t    struct btrfs_root *log_root,\n\t\t\t    const struct extent_map *em,\n\t\t\t    struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct btrfs_root *csum_root;\n\tu64 csum_offset;\n\tu64 csum_len;\n\tu64 mod_start = em->mod_start;\n\tu64 mod_len = em->mod_len;\n\tLIST_HEAD(ordered_sums);\n\tint ret = 0;\n\n\tif (inode->flags & BTRFS_INODE_NODATASUM ||\n\t    test_bit(EXTENT_FLAG_PREALLOC, &em->flags) ||\n\t    em->block_start == EXTENT_MAP_HOLE)\n\t\treturn 0;\n\n\tlist_for_each_entry(ordered, &ctx->ordered_extents, log_list) {\n\t\tconst u64 ordered_end = ordered->file_offset + ordered->num_bytes;\n\t\tconst u64 mod_end = mod_start + mod_len;\n\t\tstruct btrfs_ordered_sum *sums;\n\n\t\tif (mod_len == 0)\n\t\t\tbreak;\n\n\t\tif (ordered_end <= mod_start)\n\t\t\tcontinue;\n\t\tif (mod_end <= ordered->file_offset)\n\t\t\tbreak;\n\n\t\t \n\t\tif (ordered->file_offset > mod_start) {\n\t\t\tif (ordered_end >= mod_end)\n\t\t\t\tmod_len = ordered->file_offset - mod_start;\n\t\t\t \n\t\t} else {\n\t\t\tif (ordered_end < mod_end) {\n\t\t\t\tmod_len = mod_end - ordered_end;\n\t\t\t\tmod_start = ordered_end;\n\t\t\t} else {\n\t\t\t\tmod_len = 0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (test_and_set_bit(BTRFS_ORDERED_LOGGED_CSUM, &ordered->flags))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(sums, &ordered->list, list) {\n\t\t\tret = log_csums(trans, inode, log_root, sums);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (mod_len == 0)\n\t\treturn 0;\n\n\t \n\tif (em->compress_type) {\n\t\tcsum_offset = 0;\n\t\tcsum_len = max(em->block_len, em->orig_block_len);\n\t} else {\n\t\tcsum_offset = mod_start - em->start;\n\t\tcsum_len = mod_len;\n\t}\n\n\t \n\tcsum_root = btrfs_csum_root(trans->fs_info, em->block_start);\n\tret = btrfs_lookup_csums_list(csum_root, em->block_start + csum_offset,\n\t\t\t\t      em->block_start + csum_offset +\n\t\t\t\t      csum_len - 1, &ordered_sums, 0, false);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (!list_empty(&ordered_sums)) {\n\t\tstruct btrfs_ordered_sum *sums = list_entry(ordered_sums.next,\n\t\t\t\t\t\t   struct btrfs_ordered_sum,\n\t\t\t\t\t\t   list);\n\t\tif (!ret)\n\t\t\tret = log_csums(trans, inode, log_root, sums);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\n\treturn ret;\n}\n\nstatic int log_one_extent(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_inode *inode,\n\t\t\t  const struct extent_map *em,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_drop_extents_args drop_args = { 0 };\n\tstruct btrfs_root *log = inode->root->log_root;\n\tstruct btrfs_file_extent_item fi = { 0 };\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tu64 extent_offset = em->start - em->orig_start;\n\tu64 block_len;\n\tint ret;\n\n\tbtrfs_set_stack_file_extent_generation(&fi, trans->transid);\n\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\tbtrfs_set_stack_file_extent_type(&fi, BTRFS_FILE_EXTENT_PREALLOC);\n\telse\n\t\tbtrfs_set_stack_file_extent_type(&fi, BTRFS_FILE_EXTENT_REG);\n\n\tblock_len = max(em->block_len, em->orig_block_len);\n\tif (em->compress_type != BTRFS_COMPRESS_NONE) {\n\t\tbtrfs_set_stack_file_extent_disk_bytenr(&fi, em->block_start);\n\t\tbtrfs_set_stack_file_extent_disk_num_bytes(&fi, block_len);\n\t} else if (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\tbtrfs_set_stack_file_extent_disk_bytenr(&fi, em->block_start -\n\t\t\t\t\t\t\textent_offset);\n\t\tbtrfs_set_stack_file_extent_disk_num_bytes(&fi, block_len);\n\t}\n\n\tbtrfs_set_stack_file_extent_offset(&fi, extent_offset);\n\tbtrfs_set_stack_file_extent_num_bytes(&fi, em->len);\n\tbtrfs_set_stack_file_extent_ram_bytes(&fi, em->ram_bytes);\n\tbtrfs_set_stack_file_extent_compression(&fi, em->compress_type);\n\n\tret = log_extent_csums(trans, inode, log, em, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ctx->logged_before) {\n\t\tdrop_args.path = path;\n\t\tdrop_args.start = em->start;\n\t\tdrop_args.end = em->start + em->len;\n\t\tdrop_args.replace_extent = true;\n\t\tdrop_args.extent_item_size = sizeof(fi);\n\t\tret = btrfs_drop_extents(trans, log, inode, &drop_args);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!drop_args.extent_inserted) {\n\t\tkey.objectid = btrfs_ino(inode);\n\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\tkey.offset = em->start;\n\n\t\tret = btrfs_insert_empty_item(trans, log, path, &key,\n\t\t\t\t\t      sizeof(fi));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tleaf = path->nodes[0];\n\twrite_extent_buffer(leaf, &fi,\n\t\t\t    btrfs_item_ptr_offset(leaf, path->slots[0]),\n\t\t\t    sizeof(fi));\n\tbtrfs_mark_buffer_dirty(trans, leaf);\n\n\tbtrfs_release_path(path);\n\n\treturn ret;\n}\n\n \nstatic int btrfs_log_prealloc_extents(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_inode *inode,\n\t\t\t\t      struct btrfs_path *path)\n{\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_key key;\n\tconst u64 i_size = i_size_read(&inode->vfs_inode);\n\tconst u64 ino = btrfs_ino(inode);\n\tstruct btrfs_path *dst_path = NULL;\n\tbool dropped_extents = false;\n\tu64 truncate_offset = i_size;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tint ins_nr = 0;\n\tint start_slot = 0;\n\tint ret;\n\n\tif (!(inode->flags & BTRFS_INODE_PREALLOC))\n\t\treturn 0;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = i_size;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = btrfs_previous_item(root, path, ino, BTRFS_EXTENT_DATA_KEY);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret == 0) {\n\t\tstruct btrfs_file_extent_item *ei;\n\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tei = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\n\t\tif (btrfs_file_extent_type(leaf, ei) ==\n\t\t    BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\tu64 extent_end;\n\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_num_bytes(leaf, ei);\n\n\t\t\tif (extent_end > i_size)\n\t\t\t\ttruncate_offset = extent_end;\n\t\t}\n\t} else {\n\t\tret = 0;\n\t}\n\n\twhile (true) {\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tif (ins_nr > 0) {\n\t\t\t\tret = copy_items(trans, inode, dst_path, path,\n\t\t\t\t\t\t start_slot, ins_nr, 1, 0);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tins_nr = 0;\n\t\t\t}\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid > ino)\n\t\t\tbreak;\n\t\tif (WARN_ON_ONCE(key.objectid < ino) ||\n\t\t    key.type < BTRFS_EXTENT_DATA_KEY ||\n\t\t    key.offset < i_size) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dropped_extents) {\n\t\t\t \n\t\t\tret = truncate_inode_items(trans, root->log_root, inode,\n\t\t\t\t\t\t   truncate_offset,\n\t\t\t\t\t\t   BTRFS_EXTENT_DATA_KEY);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tdropped_extents = true;\n\t\t}\n\t\tif (ins_nr == 0)\n\t\t\tstart_slot = slot;\n\t\tins_nr++;\n\t\tpath->slots[0]++;\n\t\tif (!dst_path) {\n\t\t\tdst_path = btrfs_alloc_path();\n\t\t\tif (!dst_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tif (ins_nr > 0)\n\t\tret = copy_items(trans, inode, dst_path, path,\n\t\t\t\t start_slot, ins_nr, 1, 0);\nout:\n\tbtrfs_release_path(path);\n\tbtrfs_free_path(dst_path);\n\treturn ret;\n}\n\nstatic int btrfs_log_changed_extents(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_inode *inode,\n\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t     struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct btrfs_ordered_extent *tmp;\n\tstruct extent_map *em, *n;\n\tLIST_HEAD(extents);\n\tstruct extent_map_tree *tree = &inode->extent_tree;\n\tint ret = 0;\n\tint num = 0;\n\n\twrite_lock(&tree->lock);\n\n\tlist_for_each_entry_safe(em, n, &tree->modified_extents, list) {\n\t\tlist_del_init(&em->list);\n\t\t \n\t\tif (++num > 32768) {\n\t\t\tlist_del_init(&tree->modified_extents);\n\t\t\tret = -EFBIG;\n\t\t\tgoto process;\n\t\t}\n\n\t\tif (em->generation < trans->transid)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags) &&\n\t\t    em->start >= i_size_read(&inode->vfs_inode))\n\t\t\tcontinue;\n\n\t\t \n\t\trefcount_inc(&em->refs);\n\t\tset_bit(EXTENT_FLAG_LOGGING, &em->flags);\n\t\tlist_add_tail(&em->list, &extents);\n\t\tnum++;\n\t}\n\n\tlist_sort(NULL, &extents, extent_cmp);\nprocess:\n\twhile (!list_empty(&extents)) {\n\t\tem = list_entry(extents.next, struct extent_map, list);\n\n\t\tlist_del_init(&em->list);\n\n\t\t \n\t\tif (ret) {\n\t\t\tclear_em_logging(tree, em);\n\t\t\tfree_extent_map(em);\n\t\t\tcontinue;\n\t\t}\n\n\t\twrite_unlock(&tree->lock);\n\n\t\tret = log_one_extent(trans, inode, em, path, ctx);\n\t\twrite_lock(&tree->lock);\n\t\tclear_em_logging(tree, em);\n\t\tfree_extent_map(em);\n\t}\n\tWARN_ON(!list_empty(&extents));\n\twrite_unlock(&tree->lock);\n\n\tif (!ret)\n\t\tret = btrfs_log_prealloc_extents(trans, inode, path);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tlist_for_each_entry_safe(ordered, tmp, &ctx->ordered_extents, log_list) {\n\t\tlist_del_init(&ordered->log_list);\n\t\tset_bit(BTRFS_ORDERED_LOGGED, &ordered->flags);\n\n\t\tif (!test_bit(BTRFS_ORDERED_COMPLETE, &ordered->flags)) {\n\t\t\tspin_lock_irq(&inode->ordered_tree.lock);\n\t\t\tif (!test_bit(BTRFS_ORDERED_COMPLETE, &ordered->flags)) {\n\t\t\t\tset_bit(BTRFS_ORDERED_PENDING, &ordered->flags);\n\t\t\t\tatomic_inc(&trans->transaction->pending_ordered);\n\t\t\t}\n\t\t\tspin_unlock_irq(&inode->ordered_tree.lock);\n\t\t}\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\treturn 0;\n}\n\nstatic int logged_inode_size(struct btrfs_root *log, struct btrfs_inode *inode,\n\t\t\t     struct btrfs_path *path, u64 *size_ret)\n{\n\tstruct btrfs_key key;\n\tint ret;\n\n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(NULL, log, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\treturn ret;\n\t} else if (ret > 0) {\n\t\t*size_ret = 0;\n\t} else {\n\t\tstruct btrfs_inode_item *item;\n\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_item);\n\t\t*size_ret = btrfs_inode_size(path->nodes[0], item);\n\t\t \n\t\tif (*size_ret > inode->vfs_inode.i_size)\n\t\t\t*size_ret = inode->vfs_inode.i_size;\n\t}\n\n\tbtrfs_release_path(path);\n\treturn 0;\n}\n\n \nstatic int btrfs_log_all_xattrs(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_inode *inode,\n\t\t\t\tstruct btrfs_path *path,\n\t\t\t\tstruct btrfs_path *dst_path)\n{\n\tstruct btrfs_root *root = inode->root;\n\tint ret;\n\tstruct btrfs_key key;\n\tconst u64 ino = btrfs_ino(inode);\n\tint ins_nr = 0;\n\tint start_slot = 0;\n\tbool found_xattrs = false;\n\n\tif (test_bit(BTRFS_INODE_NO_XATTRS, &inode->runtime_flags))\n\t\treturn 0;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (true) {\n\t\tint slot = path->slots[0];\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tint nritems = btrfs_header_nritems(leaf);\n\n\t\tif (slot >= nritems) {\n\t\t\tif (ins_nr > 0) {\n\t\t\t\tret = copy_items(trans, inode, dst_path, path,\n\t\t\t\t\t\t start_slot, ins_nr, 1, 0);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tins_nr = 0;\n\t\t\t}\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid != ino || key.type != BTRFS_XATTR_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tif (ins_nr == 0)\n\t\t\tstart_slot = slot;\n\t\tins_nr++;\n\t\tpath->slots[0]++;\n\t\tfound_xattrs = true;\n\t\tcond_resched();\n\t}\n\tif (ins_nr > 0) {\n\t\tret = copy_items(trans, inode, dst_path, path,\n\t\t\t\t start_slot, ins_nr, 1, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (!found_xattrs)\n\t\tset_bit(BTRFS_INODE_NO_XATTRS, &inode->runtime_flags);\n\n\treturn 0;\n}\n\n \nstatic int btrfs_log_holes(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_inode *inode,\n\t\t\t   struct btrfs_path *path)\n{\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_key key;\n\tconst u64 ino = btrfs_ino(inode);\n\tconst u64 i_size = i_size_read(&inode->vfs_inode);\n\tu64 prev_extent_end = 0;\n\tint ret;\n\n\tif (!btrfs_fs_incompat(fs_info, NO_HOLES) || i_size == 0)\n\t\treturn 0;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (true) {\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\n\t\tif (path->slots[0] >= btrfs_header_nritems(path->nodes[0])) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != ino || key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tbreak;\n\n\t\t \n\t\tif (prev_extent_end < key.offset) {\n\t\t\tconst u64 hole_len = key.offset - prev_extent_end;\n\n\t\t\t \n\t\t\tbtrfs_release_path(path);\n\t\t\tret = btrfs_insert_hole_extent(trans, root->log_root,\n\t\t\t\t\t\t       ino, prev_extent_end,\n\t\t\t\t\t\t       hole_len);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (WARN_ON(ret > 0))\n\t\t\t\treturn -ENOENT;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tprev_extent_end = btrfs_file_extent_end(path);\n\t\tpath->slots[0]++;\n\t\tcond_resched();\n\t}\n\n\tif (prev_extent_end < i_size) {\n\t\tu64 hole_len;\n\n\t\tbtrfs_release_path(path);\n\t\thole_len = ALIGN(i_size - prev_extent_end, fs_info->sectorsize);\n\t\tret = btrfs_insert_hole_extent(trans, root->log_root, ino,\n\t\t\t\t\t       prev_extent_end, hole_len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int btrfs_check_ref_name_override(struct extent_buffer *eb,\n\t\t\t\t\t const int slot,\n\t\t\t\t\t const struct btrfs_key *key,\n\t\t\t\t\t struct btrfs_inode *inode,\n\t\t\t\t\t u64 *other_ino, u64 *other_parent)\n{\n\tint ret;\n\tstruct btrfs_path *search_path;\n\tchar *name = NULL;\n\tu32 name_len = 0;\n\tu32 item_size = btrfs_item_size(eb, slot);\n\tu32 cur_offset = 0;\n\tunsigned long ptr = btrfs_item_ptr_offset(eb, slot);\n\n\tsearch_path = btrfs_alloc_path();\n\tif (!search_path)\n\t\treturn -ENOMEM;\n\tsearch_path->search_commit_root = 1;\n\tsearch_path->skip_locking = 1;\n\n\twhile (cur_offset < item_size) {\n\t\tu64 parent;\n\t\tu32 this_name_len;\n\t\tu32 this_len;\n\t\tunsigned long name_ptr;\n\t\tstruct btrfs_dir_item *di;\n\t\tstruct fscrypt_str name_str;\n\n\t\tif (key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tstruct btrfs_inode_ref *iref;\n\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur_offset);\n\t\t\tparent = key->offset;\n\t\t\tthis_name_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_ptr = (unsigned long)(iref + 1);\n\t\t\tthis_len = sizeof(*iref) + this_name_len;\n\t\t} else {\n\t\t\tstruct btrfs_inode_extref *extref;\n\n\t\t\textref = (struct btrfs_inode_extref *)(ptr +\n\t\t\t\t\t\t\t       cur_offset);\n\t\t\tparent = btrfs_inode_extref_parent(eb, extref);\n\t\t\tthis_name_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_ptr = (unsigned long)&extref->name;\n\t\t\tthis_len = sizeof(*extref) + this_name_len;\n\t\t}\n\n\t\tif (this_name_len > name_len) {\n\t\t\tchar *new_name;\n\n\t\t\tnew_name = krealloc(name, this_name_len, GFP_NOFS);\n\t\t\tif (!new_name) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tname_len = this_name_len;\n\t\t\tname = new_name;\n\t\t}\n\n\t\tread_extent_buffer(eb, name, name_ptr, this_name_len);\n\n\t\tname_str.name = name;\n\t\tname_str.len = this_name_len;\n\t\tdi = btrfs_lookup_dir_item(NULL, inode->root, search_path,\n\t\t\t\tparent, &name_str, 0);\n\t\tif (di && !IS_ERR(di)) {\n\t\t\tstruct btrfs_key di_key;\n\n\t\t\tbtrfs_dir_item_key_to_cpu(search_path->nodes[0],\n\t\t\t\t\t\t  di, &di_key);\n\t\t\tif (di_key.type == BTRFS_INODE_ITEM_KEY) {\n\t\t\t\tif (di_key.objectid != key->objectid) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\t*other_ino = di_key.objectid;\n\t\t\t\t\t*other_parent = parent;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret = -EAGAIN;\n\t\t\t}\n\t\t\tgoto out;\n\t\t} else if (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(search_path);\n\n\t\tcur_offset += this_len;\n\t}\n\tret = 0;\nout:\n\tbtrfs_free_path(search_path);\n\tkfree(name);\n\treturn ret;\n}\n\n \nstatic bool need_log_inode(const struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_inode *inode)\n{\n\t \n\tif (S_ISDIR(inode->vfs_inode.i_mode) && inode->last_trans < trans->transid)\n\t\treturn false;\n\n\t \n\tif (inode_logged(trans, inode, NULL) == 1 &&\n\t    !test_bit(BTRFS_INODE_COPY_EVERYTHING, &inode->runtime_flags))\n\t\treturn false;\n\n\treturn true;\n}\n\nstruct btrfs_dir_list {\n\tu64 ino;\n\tstruct list_head list;\n};\n\n \nstatic int log_new_dir_dentries(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_inode *start_inode,\n\t\t\t\tstruct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_root *root = start_inode->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_path *path;\n\tLIST_HEAD(dir_list);\n\tstruct btrfs_dir_list *dir_elem;\n\tu64 ino = btrfs_ino(start_inode);\n\tstruct btrfs_inode *curr_inode = start_inode;\n\tint ret = 0;\n\n\t \n\tif (ctx->logging_new_name)\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t \n\tihold(&curr_inode->vfs_inode);\n\n\twhile (true) {\n\t\tstruct inode *vfs_inode;\n\t\tstruct btrfs_key key;\n\t\tstruct btrfs_key found_key;\n\t\tu64 next_index;\n\t\tbool continue_curr_inode = true;\n\t\tint iter_ret;\n\n\t\tkey.objectid = ino;\n\t\tkey.type = BTRFS_DIR_INDEX_KEY;\n\t\tkey.offset = btrfs_get_first_dir_index_to_log(curr_inode);\n\t\tnext_index = key.offset;\nagain:\n\t\tbtrfs_for_each_slot(root->log_root, &key, &found_key, path, iter_ret) {\n\t\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\t\tstruct btrfs_dir_item *di;\n\t\t\tstruct btrfs_key di_key;\n\t\t\tstruct inode *di_inode;\n\t\t\tint log_mode = LOG_INODE_EXISTS;\n\t\t\tint type;\n\n\t\t\tif (found_key.objectid != ino ||\n\t\t\t    found_key.type != BTRFS_DIR_INDEX_KEY) {\n\t\t\t\tcontinue_curr_inode = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnext_index = found_key.offset + 1;\n\n\t\t\tdi = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\t\t\ttype = btrfs_dir_ftype(leaf, di);\n\t\t\tif (btrfs_dir_transid(leaf, di) < trans->transid)\n\t\t\t\tcontinue;\n\t\t\tbtrfs_dir_item_key_to_cpu(leaf, di, &di_key);\n\t\t\tif (di_key.type == BTRFS_ROOT_ITEM_KEY)\n\t\t\t\tcontinue;\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tdi_inode = btrfs_iget(fs_info->sb, di_key.objectid, root);\n\t\t\tif (IS_ERR(di_inode)) {\n\t\t\t\tret = PTR_ERR(di_inode);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!need_log_inode(trans, BTRFS_I(di_inode))) {\n\t\t\t\tbtrfs_add_delayed_iput(BTRFS_I(di_inode));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tctx->log_new_dentries = false;\n\t\t\tif (type == BTRFS_FT_DIR)\n\t\t\t\tlog_mode = LOG_INODE_ALL;\n\t\t\tret = btrfs_log_inode(trans, BTRFS_I(di_inode),\n\t\t\t\t\t      log_mode, ctx);\n\t\t\tbtrfs_add_delayed_iput(BTRFS_I(di_inode));\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (ctx->log_new_dentries) {\n\t\t\t\tdir_elem = kmalloc(sizeof(*dir_elem), GFP_NOFS);\n\t\t\t\tif (!dir_elem) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tdir_elem->ino = di_key.objectid;\n\t\t\t\tlist_add_tail(&dir_elem->list, &dir_list);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_release_path(path);\n\n\t\tif (iter_ret < 0) {\n\t\t\tret = iter_ret;\n\t\t\tgoto out;\n\t\t} else if (iter_ret > 0) {\n\t\t\tcontinue_curr_inode = false;\n\t\t} else {\n\t\t\tkey = found_key;\n\t\t}\n\n\t\tif (continue_curr_inode && key.offset < (u64)-1) {\n\t\t\tkey.offset++;\n\t\t\tgoto again;\n\t\t}\n\n\t\tbtrfs_set_first_dir_index_to_log(curr_inode, next_index);\n\n\t\tif (list_empty(&dir_list))\n\t\t\tbreak;\n\n\t\tdir_elem = list_first_entry(&dir_list, struct btrfs_dir_list, list);\n\t\tino = dir_elem->ino;\n\t\tlist_del(&dir_elem->list);\n\t\tkfree(dir_elem);\n\n\t\tbtrfs_add_delayed_iput(curr_inode);\n\t\tcurr_inode = NULL;\n\n\t\tvfs_inode = btrfs_iget(fs_info->sb, ino, root);\n\t\tif (IS_ERR(vfs_inode)) {\n\t\t\tret = PTR_ERR(vfs_inode);\n\t\t\tbreak;\n\t\t}\n\t\tcurr_inode = BTRFS_I(vfs_inode);\n\t}\nout:\n\tbtrfs_free_path(path);\n\tif (curr_inode)\n\t\tbtrfs_add_delayed_iput(curr_inode);\n\n\tif (ret) {\n\t\tstruct btrfs_dir_list *next;\n\n\t\tlist_for_each_entry_safe(dir_elem, next, &dir_list, list)\n\t\t\tkfree(dir_elem);\n\t}\n\n\treturn ret;\n}\n\nstruct btrfs_ino_list {\n\tu64 ino;\n\tu64 parent;\n\tstruct list_head list;\n};\n\nstatic void free_conflicting_inodes(struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_ino_list *curr;\n\tstruct btrfs_ino_list *next;\n\n\tlist_for_each_entry_safe(curr, next, &ctx->conflict_inodes, list) {\n\t\tlist_del(&curr->list);\n\t\tkfree(curr);\n\t}\n}\n\nstatic int conflicting_inode_is_dir(struct btrfs_root *root, u64 ino,\n\t\t\t\t    struct btrfs_path *path)\n{\n\tstruct btrfs_key key;\n\tint ret;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (WARN_ON_ONCE(ret > 0)) {\n\t\t \n\t\tret = -ENOENT;\n\t} else if (ret == 0) {\n\t\tstruct btrfs_inode_item *item;\n\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_item);\n\t\tif (S_ISDIR(btrfs_inode_mode(path->nodes[0], item)))\n\t\t\tret = 1;\n\t}\n\n\tbtrfs_release_path(path);\n\tpath->search_commit_root = 0;\n\tpath->skip_locking = 0;\n\n\treturn ret;\n}\n\nstatic int add_conflicting_inode(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path,\n\t\t\t\t u64 ino, u64 parent,\n\t\t\t\t struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_ino_list *ino_elem;\n\tstruct inode *inode;\n\n\t \n\tif (ctx->num_conflict_inodes >= MAX_CONFLICT_INODES)\n\t\treturn BTRFS_LOG_FORCE_COMMIT;\n\n\tinode = btrfs_iget(root->fs_info->sb, ino, root);\n\t \n\tif (IS_ERR(inode)) {\n\t\tint ret = PTR_ERR(inode);\n\n\t\tif (ret != -ENOENT)\n\t\t\treturn ret;\n\n\t\tret = conflicting_inode_is_dir(root, ino, path);\n\t\t \n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tino_elem = kmalloc(sizeof(*ino_elem), GFP_NOFS);\n\t\tif (!ino_elem)\n\t\t\treturn -ENOMEM;\n\t\tino_elem->ino = ino;\n\t\tino_elem->parent = parent;\n\t\tlist_add_tail(&ino_elem->list, &ctx->conflict_inodes);\n\t\tctx->num_conflict_inodes++;\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (!need_log_inode(trans, BTRFS_I(inode))) {\n\t\tbtrfs_add_delayed_iput(BTRFS_I(inode));\n\t\treturn 0;\n\t}\n\n\tbtrfs_add_delayed_iput(BTRFS_I(inode));\n\n\tino_elem = kmalloc(sizeof(*ino_elem), GFP_NOFS);\n\tif (!ino_elem)\n\t\treturn -ENOMEM;\n\tino_elem->ino = ino;\n\tino_elem->parent = parent;\n\tlist_add_tail(&ino_elem->list, &ctx->conflict_inodes);\n\tctx->num_conflict_inodes++;\n\n\treturn 0;\n}\n\nstatic int log_conflicting_inodes(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret = 0;\n\n\t \n\tif (ctx->logging_conflict_inodes)\n\t\treturn 0;\n\n\tctx->logging_conflict_inodes = true;\n\n\t \n\twhile (!list_empty(&ctx->conflict_inodes)) {\n\t\tstruct btrfs_ino_list *curr;\n\t\tstruct inode *inode;\n\t\tu64 ino;\n\t\tu64 parent;\n\n\t\tcurr = list_first_entry(&ctx->conflict_inodes,\n\t\t\t\t\tstruct btrfs_ino_list, list);\n\t\tino = curr->ino;\n\t\tparent = curr->parent;\n\t\tlist_del(&curr->list);\n\t\tkfree(curr);\n\n\t\tinode = btrfs_iget(fs_info->sb, ino, root);\n\t\t \n\t\tif (IS_ERR(inode)) {\n\t\t\tret = PTR_ERR(inode);\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tbreak;\n\n\t\t\tinode = btrfs_iget(fs_info->sb, parent, root);\n\t\t\tif (IS_ERR(inode)) {\n\t\t\t\tret = PTR_ERR(inode);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = btrfs_log_inode(trans, BTRFS_I(inode),\n\t\t\t\t\t      LOG_INODE_ALL, ctx);\n\t\t\tbtrfs_add_delayed_iput(BTRFS_I(inode));\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!need_log_inode(trans, BTRFS_I(inode))) {\n\t\t\tbtrfs_add_delayed_iput(BTRFS_I(inode));\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tret = btrfs_log_inode(trans, BTRFS_I(inode), LOG_INODE_EXISTS, ctx);\n\t\tbtrfs_add_delayed_iput(BTRFS_I(inode));\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tctx->logging_conflict_inodes = false;\n\tif (ret)\n\t\tfree_conflicting_inodes(ctx);\n\n\treturn ret;\n}\n\nstatic int copy_inode_items_to_log(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_inode *inode,\n\t\t\t\t   struct btrfs_key *min_key,\n\t\t\t\t   const struct btrfs_key *max_key,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct btrfs_path *dst_path,\n\t\t\t\t   const u64 logged_isize,\n\t\t\t\t   const int inode_only,\n\t\t\t\t   struct btrfs_log_ctx *ctx,\n\t\t\t\t   bool *need_log_inode_item)\n{\n\tconst u64 i_size = i_size_read(&inode->vfs_inode);\n\tstruct btrfs_root *root = inode->root;\n\tint ins_start_slot = 0;\n\tint ins_nr = 0;\n\tint ret;\n\n\twhile (1) {\n\t\tret = btrfs_search_forward(root, min_key, path, trans->transid);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret > 0) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\nagain:\n\t\t \n\t\tif (min_key->objectid != max_key->objectid)\n\t\t\tbreak;\n\t\tif (min_key->type > max_key->type)\n\t\t\tbreak;\n\n\t\tif (min_key->type == BTRFS_INODE_ITEM_KEY) {\n\t\t\t*need_log_inode_item = false;\n\t\t} else if (min_key->type == BTRFS_EXTENT_DATA_KEY &&\n\t\t\t   min_key->offset >= i_size) {\n\t\t\t \n\t\t\tbreak;\n\t\t} else if ((min_key->type == BTRFS_INODE_REF_KEY ||\n\t\t\t    min_key->type == BTRFS_INODE_EXTREF_KEY) &&\n\t\t\t   (inode->generation == trans->transid ||\n\t\t\t    ctx->logging_conflict_inodes)) {\n\t\t\tu64 other_ino = 0;\n\t\t\tu64 other_parent = 0;\n\n\t\t\tret = btrfs_check_ref_name_override(path->nodes[0],\n\t\t\t\t\tpath->slots[0], min_key, inode,\n\t\t\t\t\t&other_ino, &other_parent);\n\t\t\tif (ret < 0) {\n\t\t\t\treturn ret;\n\t\t\t} else if (ret > 0 &&\n\t\t\t\t   other_ino != btrfs_ino(BTRFS_I(ctx->inode))) {\n\t\t\t\tif (ins_nr > 0) {\n\t\t\t\t\tins_nr++;\n\t\t\t\t} else {\n\t\t\t\t\tins_nr = 1;\n\t\t\t\t\tins_start_slot = path->slots[0];\n\t\t\t\t}\n\t\t\t\tret = copy_items(trans, inode, dst_path, path,\n\t\t\t\t\t\t ins_start_slot, ins_nr,\n\t\t\t\t\t\t inode_only, logged_isize);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tins_nr = 0;\n\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tret = add_conflicting_inode(trans, root, path,\n\t\t\t\t\t\t\t    other_ino,\n\t\t\t\t\t\t\t    other_parent, ctx);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tgoto next_key;\n\t\t\t}\n\t\t} else if (min_key->type == BTRFS_XATTR_ITEM_KEY) {\n\t\t\t \n\t\t\tif (ins_nr == 0)\n\t\t\t\tgoto next_slot;\n\t\t\tret = copy_items(trans, inode, dst_path, path,\n\t\t\t\t\t ins_start_slot,\n\t\t\t\t\t ins_nr, inode_only, logged_isize);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tins_nr = 0;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\tif (ins_nr && ins_start_slot + ins_nr == path->slots[0]) {\n\t\t\tins_nr++;\n\t\t\tgoto next_slot;\n\t\t} else if (!ins_nr) {\n\t\t\tins_start_slot = path->slots[0];\n\t\t\tins_nr = 1;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\tret = copy_items(trans, inode, dst_path, path, ins_start_slot,\n\t\t\t\t ins_nr, inode_only, logged_isize);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tins_nr = 1;\n\t\tins_start_slot = path->slots[0];\nnext_slot:\n\t\tpath->slots[0]++;\n\t\tif (path->slots[0] < btrfs_header_nritems(path->nodes[0])) {\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], min_key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tgoto again;\n\t\t}\n\t\tif (ins_nr) {\n\t\t\tret = copy_items(trans, inode, dst_path, path,\n\t\t\t\t\t ins_start_slot, ins_nr, inode_only,\n\t\t\t\t\t logged_isize);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tins_nr = 0;\n\t\t}\n\t\tbtrfs_release_path(path);\nnext_key:\n\t\tif (min_key->offset < (u64)-1) {\n\t\t\tmin_key->offset++;\n\t\t} else if (min_key->type < max_key->type) {\n\t\t\tmin_key->type++;\n\t\t\tmin_key->offset = 0;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tcond_resched();\n\t}\n\tif (ins_nr) {\n\t\tret = copy_items(trans, inode, dst_path, path, ins_start_slot,\n\t\t\t\t ins_nr, inode_only, logged_isize);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (inode_only == LOG_INODE_ALL && S_ISREG(inode->vfs_inode.i_mode)) {\n\t\t \n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_log_prealloc_extents(trans, inode, dst_path);\n\t}\n\n\treturn ret;\n}\n\nstatic int insert_delayed_items_batch(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *log,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      const struct btrfs_item_batch *batch,\n\t\t\t\t      const struct btrfs_delayed_item *first_item)\n{\n\tconst struct btrfs_delayed_item *curr = first_item;\n\tint ret;\n\n\tret = btrfs_insert_empty_items(trans, log, path, batch);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (int i = 0; i < batch->nr; i++) {\n\t\tchar *data_ptr;\n\n\t\tdata_ptr = btrfs_item_ptr(path->nodes[0], path->slots[0], char);\n\t\twrite_extent_buffer(path->nodes[0], &curr->data,\n\t\t\t\t    (unsigned long)data_ptr, curr->data_len);\n\t\tcurr = list_next_entry(curr, log_list);\n\t\tpath->slots[0]++;\n\t}\n\n\tbtrfs_release_path(path);\n\n\treturn 0;\n}\n\nstatic int log_delayed_insertion_items(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_inode *inode,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       const struct list_head *delayed_ins_list,\n\t\t\t\t       struct btrfs_log_ctx *ctx)\n{\n\t \n\tconst int max_batch_size = 195;\n\tconst int leaf_data_size = BTRFS_LEAF_DATA_SIZE(trans->fs_info);\n\tconst u64 ino = btrfs_ino(inode);\n\tstruct btrfs_root *log = inode->root->log_root;\n\tstruct btrfs_item_batch batch = {\n\t\t.nr = 0,\n\t\t.total_data_size = 0,\n\t};\n\tconst struct btrfs_delayed_item *first = NULL;\n\tconst struct btrfs_delayed_item *curr;\n\tchar *ins_data;\n\tstruct btrfs_key *ins_keys;\n\tu32 *ins_sizes;\n\tu64 curr_batch_size = 0;\n\tint batch_idx = 0;\n\tint ret;\n\n\t \n\tlockdep_assert_held(&inode->log_mutex);\n\n\t \n\tlist_for_each_entry(curr, delayed_ins_list, log_list) {\n\t\tif (curr->index > inode->last_dir_index_offset) {\n\t\t\tfirst = curr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!first)\n\t\treturn 0;\n\n\tins_data = kmalloc(max_batch_size * sizeof(u32) +\n\t\t\t   max_batch_size * sizeof(struct btrfs_key), GFP_NOFS);\n\tif (!ins_data)\n\t\treturn -ENOMEM;\n\tins_sizes = (u32 *)ins_data;\n\tbatch.data_sizes = ins_sizes;\n\tins_keys = (struct btrfs_key *)(ins_data + max_batch_size * sizeof(u32));\n\tbatch.keys = ins_keys;\n\n\tcurr = first;\n\twhile (!list_entry_is_head(curr, delayed_ins_list, log_list)) {\n\t\tconst u32 curr_size = curr->data_len + sizeof(struct btrfs_item);\n\n\t\tif (curr_batch_size + curr_size > leaf_data_size ||\n\t\t    batch.nr == max_batch_size) {\n\t\t\tret = insert_delayed_items_batch(trans, log, path,\n\t\t\t\t\t\t\t &batch, first);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbatch_idx = 0;\n\t\t\tbatch.nr = 0;\n\t\t\tbatch.total_data_size = 0;\n\t\t\tcurr_batch_size = 0;\n\t\t\tfirst = curr;\n\t\t}\n\n\t\tins_sizes[batch_idx] = curr->data_len;\n\t\tins_keys[batch_idx].objectid = ino;\n\t\tins_keys[batch_idx].type = BTRFS_DIR_INDEX_KEY;\n\t\tins_keys[batch_idx].offset = curr->index;\n\t\tcurr_batch_size += curr_size;\n\t\tbatch.total_data_size += curr->data_len;\n\t\tbatch.nr++;\n\t\tbatch_idx++;\n\t\tcurr = list_next_entry(curr, log_list);\n\t}\n\n\tASSERT(batch.nr >= 1);\n\tret = insert_delayed_items_batch(trans, log, path, &batch, first);\n\n\tcurr = list_last_entry(delayed_ins_list, struct btrfs_delayed_item,\n\t\t\t       log_list);\n\tinode->last_dir_index_offset = curr->index;\nout:\n\tkfree(ins_data);\n\n\treturn ret;\n}\n\nstatic int log_delayed_deletions_full(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_inode *inode,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      const struct list_head *delayed_del_list,\n\t\t\t\t      struct btrfs_log_ctx *ctx)\n{\n\tconst u64 ino = btrfs_ino(inode);\n\tconst struct btrfs_delayed_item *curr;\n\n\tcurr = list_first_entry(delayed_del_list, struct btrfs_delayed_item,\n\t\t\t\tlog_list);\n\n\twhile (!list_entry_is_head(curr, delayed_del_list, log_list)) {\n\t\tu64 first_dir_index = curr->index;\n\t\tu64 last_dir_index;\n\t\tconst struct btrfs_delayed_item *next;\n\t\tint ret;\n\n\t\t \n\t\tnext = list_next_entry(curr, log_list);\n\t\twhile (!list_entry_is_head(next, delayed_del_list, log_list)) {\n\t\t\tif (next->index != curr->index + 1)\n\t\t\t\tbreak;\n\t\t\tcurr = next;\n\t\t\tnext = list_next_entry(next, log_list);\n\t\t}\n\n\t\tlast_dir_index = curr->index;\n\t\tASSERT(last_dir_index >= first_dir_index);\n\n\t\tret = insert_dir_log_key(trans, inode->root->log_root, path,\n\t\t\t\t\t ino, first_dir_index, last_dir_index);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcurr = list_next_entry(curr, log_list);\n\t}\n\n\treturn 0;\n}\n\nstatic int batch_delete_dir_index_items(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_inode *inode,\n\t\t\t\t\tstruct btrfs_path *path,\n\t\t\t\t\tstruct btrfs_log_ctx *ctx,\n\t\t\t\t\tconst struct list_head *delayed_del_list,\n\t\t\t\t\tconst struct btrfs_delayed_item *first,\n\t\t\t\t\tconst struct btrfs_delayed_item **last_ret)\n{\n\tconst struct btrfs_delayed_item *next;\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tconst int last_slot = btrfs_header_nritems(leaf) - 1;\n\tint slot = path->slots[0] + 1;\n\tconst u64 ino = btrfs_ino(inode);\n\n\tnext = list_next_entry(first, log_list);\n\n\twhile (slot < last_slot &&\n\t       !list_entry_is_head(next, delayed_del_list, log_list)) {\n\t\tstruct btrfs_key key;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid != ino ||\n\t\t    key.type != BTRFS_DIR_INDEX_KEY ||\n\t\t    key.offset != next->index)\n\t\t\tbreak;\n\n\t\tslot++;\n\t\t*last_ret = next;\n\t\tnext = list_next_entry(next, log_list);\n\t}\n\n\treturn btrfs_del_items(trans, inode->root->log_root, path,\n\t\t\t       path->slots[0], slot - path->slots[0]);\n}\n\nstatic int log_delayed_deletions_incremental(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_inode *inode,\n\t\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t\t     const struct list_head *delayed_del_list,\n\t\t\t\t\t     struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_root *log = inode->root->log_root;\n\tconst struct btrfs_delayed_item *curr;\n\tu64 last_range_start = 0;\n\tu64 last_range_end = 0;\n\tstruct btrfs_key key;\n\n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tcurr = list_first_entry(delayed_del_list, struct btrfs_delayed_item,\n\t\t\t\tlog_list);\n\n\twhile (!list_entry_is_head(curr, delayed_del_list, log_list)) {\n\t\tconst struct btrfs_delayed_item *last = curr;\n\t\tu64 first_dir_index = curr->index;\n\t\tu64 last_dir_index;\n\t\tbool deleted_items = false;\n\t\tint ret;\n\n\t\tkey.offset = curr->index;\n\t\tret = btrfs_search_slot(trans, log, &key, path, -1, 1);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t} else if (ret == 0) {\n\t\t\tret = batch_delete_dir_index_items(trans, inode, path, ctx,\n\t\t\t\t\t\t\t   delayed_del_list, curr,\n\t\t\t\t\t\t\t   &last);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tdeleted_items = true;\n\t\t}\n\n\t\tbtrfs_release_path(path);\n\n\t\t \n\t\tif (deleted_items)\n\t\t\tgoto next_batch;\n\n\t\tlast_dir_index = last->index;\n\t\tASSERT(last_dir_index >= first_dir_index);\n\t\t \n\t\tif (last_range_end != 0 && first_dir_index == last_range_end + 1)\n\t\t\tfirst_dir_index = last_range_start;\n\n\t\tret = insert_dir_log_key(trans, log, path, key.objectid,\n\t\t\t\t\t first_dir_index, last_dir_index);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tlast_range_start = first_dir_index;\n\t\tlast_range_end = last_dir_index;\nnext_batch:\n\t\tcurr = list_next_entry(last, log_list);\n\t}\n\n\treturn 0;\n}\n\nstatic int log_delayed_deletion_items(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_inode *inode,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      const struct list_head *delayed_del_list,\n\t\t\t\t      struct btrfs_log_ctx *ctx)\n{\n\t \n\tlockdep_assert_held(&inode->log_mutex);\n\n\tif (list_empty(delayed_del_list))\n\t\treturn 0;\n\n\tif (ctx->logged_before)\n\t\treturn log_delayed_deletions_incremental(trans, inode, path,\n\t\t\t\t\t\t\t delayed_del_list, ctx);\n\n\treturn log_delayed_deletions_full(trans, inode, path, delayed_del_list,\n\t\t\t\t\t  ctx);\n}\n\n \nstatic int log_new_delayed_dentries(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_inode *inode,\n\t\t\t\t    const struct list_head *delayed_ins_list,\n\t\t\t\t    struct btrfs_log_ctx *ctx)\n{\n\tconst bool orig_log_new_dentries = ctx->log_new_dentries;\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_delayed_item *item;\n\tint ret = 0;\n\n\t \n\tlockdep_assert_not_held(&inode->log_mutex);\n\n\tASSERT(!ctx->logging_new_delayed_dentries);\n\tctx->logging_new_delayed_dentries = true;\n\n\tlist_for_each_entry(item, delayed_ins_list, log_list) {\n\t\tstruct btrfs_dir_item *dir_item;\n\t\tstruct inode *di_inode;\n\t\tstruct btrfs_key key;\n\t\tint log_mode = LOG_INODE_EXISTS;\n\n\t\tdir_item = (struct btrfs_dir_item *)item->data;\n\t\tbtrfs_disk_key_to_cpu(&key, &dir_item->location);\n\n\t\tif (key.type == BTRFS_ROOT_ITEM_KEY)\n\t\t\tcontinue;\n\n\t\tdi_inode = btrfs_iget(fs_info->sb, key.objectid, inode->root);\n\t\tif (IS_ERR(di_inode)) {\n\t\t\tret = PTR_ERR(di_inode);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!need_log_inode(trans, BTRFS_I(di_inode))) {\n\t\t\tbtrfs_add_delayed_iput(BTRFS_I(di_inode));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (btrfs_stack_dir_ftype(dir_item) == BTRFS_FT_DIR)\n\t\t\tlog_mode = LOG_INODE_ALL;\n\n\t\tctx->log_new_dentries = false;\n\t\tret = btrfs_log_inode(trans, BTRFS_I(di_inode), log_mode, ctx);\n\n\t\tif (!ret && ctx->log_new_dentries)\n\t\t\tret = log_new_dir_dentries(trans, BTRFS_I(di_inode), ctx);\n\n\t\tbtrfs_add_delayed_iput(BTRFS_I(di_inode));\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tctx->log_new_dentries = orig_log_new_dentries;\n\tctx->logging_new_delayed_dentries = false;\n\n\treturn ret;\n}\n\n \nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_path *dst_path;\n\tstruct btrfs_key min_key;\n\tstruct btrfs_key max_key;\n\tstruct btrfs_root *log = inode->root->log_root;\n\tint ret;\n\tbool fast_search = false;\n\tu64 ino = btrfs_ino(inode);\n\tstruct extent_map_tree *em_tree = &inode->extent_tree;\n\tu64 logged_isize = 0;\n\tbool need_log_inode_item = true;\n\tbool xattrs_logged = false;\n\tbool inode_item_dropped = true;\n\tbool full_dir_logging = false;\n\tLIST_HEAD(delayed_ins_list);\n\tLIST_HEAD(delayed_del_list);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tdst_path = btrfs_alloc_path();\n\tif (!dst_path) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\tmin_key.objectid = ino;\n\tmin_key.type = BTRFS_INODE_ITEM_KEY;\n\tmin_key.offset = 0;\n\n\tmax_key.objectid = ino;\n\n\n\t \n\tif (S_ISDIR(inode->vfs_inode.i_mode) ||\n\t    (!test_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t       &inode->runtime_flags) &&\n\t     inode_only >= LOG_INODE_EXISTS))\n\t\tmax_key.type = BTRFS_XATTR_ITEM_KEY;\n\telse\n\t\tmax_key.type = (u8)-1;\n\tmax_key.offset = (u64)-1;\n\n\tif (S_ISDIR(inode->vfs_inode.i_mode) && inode_only == LOG_INODE_ALL)\n\t\tfull_dir_logging = true;\n\n\t \n\tif (full_dir_logging && ctx->logging_new_delayed_dentries) {\n\t\tret = btrfs_commit_inode_delayed_items(trans, inode);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tmutex_lock(&inode->log_mutex);\n\n\t \n\tif (S_ISLNK(inode->vfs_inode.i_mode))\n\t\tinode_only = LOG_INODE_ALL;\n\n\t \n\tret = inode_logged(trans, inode, path);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\tctx->logged_before = (ret == 1);\n\tret = 0;\n\n\t \n\tif (full_dir_logging && inode->last_unlink_trans >= trans->transid) {\n\t\tret = BTRFS_LOG_FORCE_COMMIT;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (S_ISDIR(inode->vfs_inode.i_mode)) {\n\t\tclear_bit(BTRFS_INODE_COPY_EVERYTHING, &inode->runtime_flags);\n\t\tif (ctx->logged_before)\n\t\t\tret = drop_inode_items(trans, log, path, inode,\n\t\t\t\t\t       BTRFS_XATTR_ITEM_KEY);\n\t} else {\n\t\tif (inode_only == LOG_INODE_EXISTS && ctx->logged_before) {\n\t\t\t \n\t\t\tret = logged_inode_size(log, inode, path, &logged_isize);\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (test_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t     &inode->runtime_flags)) {\n\t\t\tif (inode_only == LOG_INODE_EXISTS) {\n\t\t\t\tmax_key.type = BTRFS_XATTR_ITEM_KEY;\n\t\t\t\tif (ctx->logged_before)\n\t\t\t\t\tret = drop_inode_items(trans, log, path,\n\t\t\t\t\t\t\t       inode, max_key.type);\n\t\t\t} else {\n\t\t\t\tclear_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t\t  &inode->runtime_flags);\n\t\t\t\tclear_bit(BTRFS_INODE_COPY_EVERYTHING,\n\t\t\t\t\t  &inode->runtime_flags);\n\t\t\t\tif (ctx->logged_before)\n\t\t\t\t\tret = truncate_inode_items(trans, log,\n\t\t\t\t\t\t\t\t   inode, 0, 0);\n\t\t\t}\n\t\t} else if (test_and_clear_bit(BTRFS_INODE_COPY_EVERYTHING,\n\t\t\t\t\t      &inode->runtime_flags) ||\n\t\t\t   inode_only == LOG_INODE_EXISTS) {\n\t\t\tif (inode_only == LOG_INODE_ALL)\n\t\t\t\tfast_search = true;\n\t\t\tmax_key.type = BTRFS_XATTR_ITEM_KEY;\n\t\t\tif (ctx->logged_before)\n\t\t\t\tret = drop_inode_items(trans, log, path, inode,\n\t\t\t\t\t\t       max_key.type);\n\t\t} else {\n\t\t\tif (inode_only == LOG_INODE_ALL)\n\t\t\t\tfast_search = true;\n\t\t\tinode_item_dropped = false;\n\t\t\tgoto log_extents;\n\t\t}\n\n\t}\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tif (full_dir_logging && !ctx->logging_new_delayed_dentries)\n\t\tbtrfs_log_get_delayed_items(inode, &delayed_ins_list,\n\t\t\t\t\t    &delayed_del_list);\n\n\tret = copy_inode_items_to_log(trans, inode, &min_key, &max_key,\n\t\t\t\t      path, dst_path, logged_isize,\n\t\t\t\t      inode_only, ctx,\n\t\t\t\t      &need_log_inode_item);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(dst_path);\n\tret = btrfs_log_all_xattrs(trans, inode, path, dst_path);\n\tif (ret)\n\t\tgoto out_unlock;\n\txattrs_logged = true;\n\tif (max_key.type >= BTRFS_EXTENT_DATA_KEY && !fast_search) {\n\t\tbtrfs_release_path(path);\n\t\tbtrfs_release_path(dst_path);\n\t\tret = btrfs_log_holes(trans, inode, path);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\nlog_extents:\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(dst_path);\n\tif (need_log_inode_item) {\n\t\tret = log_inode_item(trans, log, dst_path, inode, inode_item_dropped);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\t \n\t\tif (!xattrs_logged && inode->logged_trans < trans->transid) {\n\t\t\tret = btrfs_log_all_xattrs(trans, inode, path, dst_path);\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\t\t\tbtrfs_release_path(path);\n\t\t}\n\t}\n\tif (fast_search) {\n\t\tret = btrfs_log_changed_extents(trans, inode, dst_path, ctx);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t} else if (inode_only == LOG_INODE_ALL) {\n\t\tstruct extent_map *em, *n;\n\n\t\twrite_lock(&em_tree->lock);\n\t\tlist_for_each_entry_safe(em, n, &em_tree->modified_extents, list)\n\t\t\tlist_del_init(&em->list);\n\t\twrite_unlock(&em_tree->lock);\n\t}\n\n\tif (full_dir_logging) {\n\t\tret = log_directory_changes(trans, inode, path, dst_path, ctx);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tret = log_delayed_insertion_items(trans, inode, path,\n\t\t\t\t\t\t  &delayed_ins_list, ctx);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tret = log_delayed_deletion_items(trans, inode, path,\n\t\t\t\t\t\t &delayed_del_list, ctx);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\tspin_lock(&inode->lock);\n\tinode->logged_trans = trans->transid;\n\t \n\tif (inode_only != LOG_INODE_EXISTS)\n\t\tinode->last_log_commit = inode->last_sub_trans;\n\tspin_unlock(&inode->lock);\n\n\t \n\tif (inode_only == LOG_INODE_ALL)\n\t\tinode->last_reflink_trans = 0;\n\nout_unlock:\n\tmutex_unlock(&inode->log_mutex);\nout:\n\tbtrfs_free_path(path);\n\tbtrfs_free_path(dst_path);\n\n\tif (ret)\n\t\tfree_conflicting_inodes(ctx);\n\telse\n\t\tret = log_conflicting_inodes(trans, inode->root, ctx);\n\n\tif (full_dir_logging && !ctx->logging_new_delayed_dentries) {\n\t\tif (!ret)\n\t\t\tret = log_new_delayed_dentries(trans, inode,\n\t\t\t\t\t\t       &delayed_ins_list, ctx);\n\n\t\tbtrfs_log_put_delayed_items(inode, &delayed_ins_list,\n\t\t\t\t\t    &delayed_del_list);\n\t}\n\n\treturn ret;\n}\n\nstatic int btrfs_log_all_parents(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_inode *inode,\n\t\t\t\t struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = inode->root;\n\tconst u64 ino = btrfs_ino(inode);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->skip_locking = 1;\n\tpath->search_commit_root = 1;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (true) {\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tint slot = path->slots[0];\n\t\tu32 cur_offset = 0;\n\t\tu32 item_size;\n\t\tunsigned long ptr;\n\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\t \n\t\tif (key.objectid != ino || key.type > BTRFS_INODE_EXTREF_KEY)\n\t\t\tbreak;\n\n\t\titem_size = btrfs_item_size(leaf, slot);\n\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\twhile (cur_offset < item_size) {\n\t\t\tstruct btrfs_key inode_key;\n\t\t\tstruct inode *dir_inode;\n\n\t\t\tinode_key.type = BTRFS_INODE_ITEM_KEY;\n\t\t\tinode_key.offset = 0;\n\n\t\t\tif (key.type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\t\tstruct btrfs_inode_extref *extref;\n\n\t\t\t\textref = (struct btrfs_inode_extref *)\n\t\t\t\t\t(ptr + cur_offset);\n\t\t\t\tinode_key.objectid = btrfs_inode_extref_parent(\n\t\t\t\t\tleaf, extref);\n\t\t\t\tcur_offset += sizeof(*extref);\n\t\t\t\tcur_offset += btrfs_inode_extref_name_len(leaf,\n\t\t\t\t\textref);\n\t\t\t} else {\n\t\t\t\tinode_key.objectid = key.offset;\n\t\t\t\tcur_offset = item_size;\n\t\t\t}\n\n\t\t\tdir_inode = btrfs_iget(fs_info->sb, inode_key.objectid,\n\t\t\t\t\t       root);\n\t\t\t \n\t\t\tif (IS_ERR(dir_inode)) {\n\t\t\t\tret = PTR_ERR(dir_inode);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!need_log_inode(trans, BTRFS_I(dir_inode))) {\n\t\t\t\tbtrfs_add_delayed_iput(BTRFS_I(dir_inode));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tctx->log_new_dentries = false;\n\t\t\tret = btrfs_log_inode(trans, BTRFS_I(dir_inode),\n\t\t\t\t\t      LOG_INODE_ALL, ctx);\n\t\t\tif (!ret && ctx->log_new_dentries)\n\t\t\t\tret = log_new_dir_dentries(trans,\n\t\t\t\t\t\t   BTRFS_I(dir_inode), ctx);\n\t\t\tbtrfs_add_delayed_iput(BTRFS_I(dir_inode));\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int log_new_ancestors(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path,\n\t\t\t     struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_key found_key;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key, path->slots[0]);\n\n\twhile (true) {\n\t\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\t\tstruct extent_buffer *leaf;\n\t\tint slot;\n\t\tstruct btrfs_key search_key;\n\t\tstruct inode *inode;\n\t\tu64 ino;\n\t\tint ret = 0;\n\n\t\tbtrfs_release_path(path);\n\n\t\tino = found_key.offset;\n\n\t\tsearch_key.objectid = found_key.offset;\n\t\tsearch_key.type = BTRFS_INODE_ITEM_KEY;\n\t\tsearch_key.offset = 0;\n\t\tinode = btrfs_iget(fs_info->sb, ino, root);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\n\t\tif (BTRFS_I(inode)->generation >= trans->transid &&\n\t\t    need_log_inode(trans, BTRFS_I(inode)))\n\t\t\tret = btrfs_log_inode(trans, BTRFS_I(inode),\n\t\t\t\t\t      LOG_INODE_EXISTS, ctx);\n\t\tbtrfs_add_delayed_iput(BTRFS_I(inode));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (search_key.objectid == BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tbreak;\n\n\t\tsearch_key.type = BTRFS_INODE_REF_KEY;\n\t\tret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\telse if (ret > 0)\n\t\t\t\treturn -ENOENT;\n\t\t\tleaf = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\t\tif (found_key.objectid != search_key.objectid ||\n\t\t    found_key.type != BTRFS_INODE_REF_KEY)\n\t\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}\n\nstatic int log_new_ancestors_fast(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_inode *inode,\n\t\t\t\t  struct dentry *parent,\n\t\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_root *root = inode->root;\n\tstruct dentry *old_parent = NULL;\n\tstruct super_block *sb = inode->vfs_inode.i_sb;\n\tint ret = 0;\n\n\twhile (true) {\n\t\tif (!parent || d_really_is_negative(parent) ||\n\t\t    sb != parent->d_sb)\n\t\t\tbreak;\n\n\t\tinode = BTRFS_I(d_inode(parent));\n\t\tif (root != inode->root)\n\t\t\tbreak;\n\n\t\tif (inode->generation >= trans->transid &&\n\t\t    need_log_inode(trans, inode)) {\n\t\t\tret = btrfs_log_inode(trans, inode,\n\t\t\t\t\t      LOG_INODE_EXISTS, ctx);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (IS_ROOT(parent))\n\t\t\tbreak;\n\n\t\tparent = dget_parent(parent);\n\t\tdput(old_parent);\n\t\told_parent = parent;\n\t}\n\tdput(old_parent);\n\n\treturn ret;\n}\n\nstatic int log_all_new_ancestors(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_inode *inode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_root *root = inode->root;\n\tconst u64 ino = btrfs_ino(inode);\n\tstruct btrfs_path *path;\n\tstruct btrfs_key search_key;\n\tint ret;\n\n\t \n\tif (inode->vfs_inode.i_nlink < 2)\n\t\treturn log_new_ancestors_fast(trans, inode, parent, ctx);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tsearch_key.objectid = ino;\n\tsearch_key.type = BTRFS_INODE_REF_KEY;\n\tsearch_key.offset = 0;\nagain:\n\tret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret == 0)\n\t\tpath->slots[0]++;\n\n\twhile (true) {\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tint slot = path->slots[0];\n\t\tstruct btrfs_key found_key;\n\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\t\tif (found_key.objectid != ino ||\n\t\t    found_key.type > BTRFS_INODE_EXTREF_KEY)\n\t\t\tbreak;\n\n\t\t \n\t\tif (found_key.type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\tret = -EMLINK;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tmemcpy(&search_key, &found_key, sizeof(search_key));\n\n\t\tret = log_new_ancestors(trans, root, path, ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbtrfs_release_path(path);\n\t\tgoto again;\n\t}\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nstatic int btrfs_log_inode_parent(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_inode *inode,\n\t\t\t\t  struct dentry *parent,\n\t\t\t\t  int inode_only,\n\t\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret = 0;\n\tbool log_dentries = false;\n\n\tif (btrfs_test_opt(fs_info, NOTREELOG)) {\n\t\tret = BTRFS_LOG_FORCE_COMMIT;\n\t\tgoto end_no_trans;\n\t}\n\n\tif (btrfs_root_refs(&root->root_item) == 0) {\n\t\tret = BTRFS_LOG_FORCE_COMMIT;\n\t\tgoto end_no_trans;\n\t}\n\n\t \n\tif ((btrfs_inode_in_log(inode, trans->transid) &&\n\t     list_empty(&ctx->ordered_extents)) ||\n\t    inode->vfs_inode.i_nlink == 0) {\n\t\tret = BTRFS_NO_LOG_SYNC;\n\t\tgoto end_no_trans;\n\t}\n\n\tret = start_log_trans(trans, root, ctx);\n\tif (ret)\n\t\tgoto end_no_trans;\n\n\tret = btrfs_log_inode(trans, inode, inode_only, ctx);\n\tif (ret)\n\t\tgoto end_trans;\n\n\t \n\tif (S_ISREG(inode->vfs_inode.i_mode) &&\n\t    inode->generation < trans->transid &&\n\t    inode->last_unlink_trans < trans->transid) {\n\t\tret = 0;\n\t\tgoto end_trans;\n\t}\n\n\tif (S_ISDIR(inode->vfs_inode.i_mode) && ctx->log_new_dentries)\n\t\tlog_dentries = true;\n\n\t \n\tif (inode->last_unlink_trans >= trans->transid) {\n\t\tret = btrfs_log_all_parents(trans, inode, ctx);\n\t\tif (ret)\n\t\t\tgoto end_trans;\n\t}\n\n\tret = log_all_new_ancestors(trans, inode, parent, ctx);\n\tif (ret)\n\t\tgoto end_trans;\n\n\tif (log_dentries)\n\t\tret = log_new_dir_dentries(trans, inode, ctx);\n\telse\n\t\tret = 0;\nend_trans:\n\tif (ret < 0) {\n\t\tbtrfs_set_log_full_commit(trans);\n\t\tret = BTRFS_LOG_FORCE_COMMIT;\n\t}\n\n\tif (ret)\n\t\tbtrfs_remove_log_ctx(root, ctx);\n\tbtrfs_end_log_trans(root);\nend_no_trans:\n\treturn ret;\n}\n\n \nint btrfs_log_dentry_safe(struct btrfs_trans_handle *trans,\n\t\t\t  struct dentry *dentry,\n\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tstruct dentry *parent = dget_parent(dentry);\n\tint ret;\n\n\tret = btrfs_log_inode_parent(trans, BTRFS_I(d_inode(dentry)), parent,\n\t\t\t\t     LOG_INODE_ALL, ctx);\n\tdput(parent);\n\n\treturn ret;\n}\n\n \nint btrfs_recover_log_trees(struct btrfs_root *log_root_tree)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_root *log;\n\tstruct btrfs_fs_info *fs_info = log_root_tree->fs_info;\n\tstruct walk_control wc = {\n\t\t.process_func = process_one_buffer,\n\t\t.stage = LOG_WALK_PIN_ONLY,\n\t};\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tset_bit(BTRFS_FS_LOG_RECOVERING, &fs_info->flags);\n\n\ttrans = btrfs_start_transaction(fs_info->tree_root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto error;\n\t}\n\n\twc.trans = trans;\n\twc.pin = 1;\n\n\tret = walk_log_tree(trans, log_root_tree, &wc);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto error;\n\t}\n\nagain:\n\tkey.objectid = BTRFS_TREE_LOG_OBJECTID;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, log_root_tree, &key, path, 0, 0);\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto error;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\t\tbtrfs_release_path(path);\n\t\tif (found_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\t\tbreak;\n\n\t\tlog = btrfs_read_tree_root(log_root_tree, &found_key);\n\t\tif (IS_ERR(log)) {\n\t\t\tret = PTR_ERR(log);\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto error;\n\t\t}\n\n\t\twc.replay_dest = btrfs_get_fs_root(fs_info, found_key.offset,\n\t\t\t\t\t\t   true);\n\t\tif (IS_ERR(wc.replay_dest)) {\n\t\t\tret = PTR_ERR(wc.replay_dest);\n\n\t\t\t \n\t\t\tif (ret == -ENOENT)\n\t\t\t\tret = btrfs_pin_extent_for_log_replay(trans,\n\t\t\t\t\t\t\tlog->node->start,\n\t\t\t\t\t\t\tlog->node->len);\n\t\t\tbtrfs_put_root(log);\n\n\t\t\tif (!ret)\n\t\t\t\tgoto next;\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto error;\n\t\t}\n\n\t\twc.replay_dest->log_root = log;\n\t\tret = btrfs_record_root_in_trans(trans, wc.replay_dest);\n\t\tif (ret)\n\t\t\t \n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\telse\n\t\t\tret = walk_log_tree(trans, log, &wc);\n\n\t\tif (!ret && wc.stage == LOG_WALK_REPLAY_ALL) {\n\t\t\tret = fixup_inode_link_counts(trans, wc.replay_dest,\n\t\t\t\t\t\t      path);\n\t\t\tif (ret)\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t}\n\n\t\tif (!ret && wc.stage == LOG_WALK_REPLAY_ALL) {\n\t\t\tstruct btrfs_root *root = wc.replay_dest;\n\n\t\t\tbtrfs_release_path(path);\n\n\t\t\t \n\t\t\tret = btrfs_init_root_free_objectid(root);\n\t\t\tif (ret)\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t}\n\n\t\twc.replay_dest->log_root = NULL;\n\t\tbtrfs_put_root(wc.replay_dest);\n\t\tbtrfs_put_root(log);\n\n\t\tif (ret)\n\t\t\tgoto error;\nnext:\n\t\tif (found_key.offset == 0)\n\t\t\tbreak;\n\t\tkey.offset = found_key.offset - 1;\n\t}\n\tbtrfs_release_path(path);\n\n\t \n\tif (wc.pin) {\n\t\twc.pin = 0;\n\t\twc.process_func = replay_one_buffer;\n\t\twc.stage = LOG_WALK_REPLAY_INODES;\n\t\tgoto again;\n\t}\n\t \n\tif (wc.stage < LOG_WALK_REPLAY_ALL) {\n\t\twc.stage++;\n\t\tgoto again;\n\t}\n\n\tbtrfs_free_path(path);\n\n\t \n\tret = btrfs_commit_transaction(trans);\n\tif (ret)\n\t\treturn ret;\n\n\tlog_root_tree->log_root = NULL;\n\tclear_bit(BTRFS_FS_LOG_RECOVERING, &fs_info->flags);\n\tbtrfs_put_root(log_root_tree);\n\n\treturn 0;\nerror:\n\tif (wc.trans)\n\t\tbtrfs_end_transaction(wc.trans);\n\tclear_bit(BTRFS_FS_LOG_RECOVERING, &fs_info->flags);\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nvoid btrfs_record_unlink_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_inode *dir, struct btrfs_inode *inode,\n\t\t\t     bool for_rename)\n{\n\t \n\tmutex_lock(&inode->log_mutex);\n\tinode->last_unlink_trans = trans->transid;\n\tmutex_unlock(&inode->log_mutex);\n\n\tif (!for_rename)\n\t\treturn;\n\n\t \n\tif (inode_logged(trans, dir, NULL) == 1)\n\t\treturn;\n\n\t \n\tif (inode_logged(trans, inode, NULL) == 1)\n\t\treturn;\n\n\t \n\tmutex_lock(&dir->log_mutex);\n\tdir->last_unlink_trans = trans->transid;\n\tmutex_unlock(&dir->log_mutex);\n}\n\n \nvoid btrfs_record_snapshot_destroy(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_inode *dir)\n{\n\tmutex_lock(&dir->log_mutex);\n\tdir->last_unlink_trans = trans->transid;\n\tmutex_unlock(&dir->log_mutex);\n}\n\n \nvoid btrfs_log_new_name(struct btrfs_trans_handle *trans,\n\t\t\tstruct dentry *old_dentry, struct btrfs_inode *old_dir,\n\t\t\tu64 old_dir_index, struct dentry *parent)\n{\n\tstruct btrfs_inode *inode = BTRFS_I(d_inode(old_dentry));\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_log_ctx ctx;\n\tbool log_pinned = false;\n\tint ret;\n\n\t \n\tif (!S_ISDIR(inode->vfs_inode.i_mode))\n\t\tinode->last_unlink_trans = trans->transid;\n\n\t \n\tret = inode_logged(trans, inode, NULL);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret == 0) {\n\t\tif (!old_dir)\n\t\t\treturn;\n\t\t \n\t\tret = inode_logged(trans, old_dir, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\telse if (ret == 0)\n\t\t\treturn;\n\t}\n\tret = 0;\n\n\t \n\tif (old_dir && old_dir->logged_trans == trans->transid) {\n\t\tstruct btrfs_root *log = old_dir->root->log_root;\n\t\tstruct btrfs_path *path;\n\t\tstruct fscrypt_name fname;\n\n\t\tASSERT(old_dir_index >= BTRFS_DIR_START_INDEX);\n\n\t\tret = fscrypt_setup_filename(&old_dir->vfs_inode,\n\t\t\t\t\t     &old_dentry->d_name, 0, &fname);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t \n\t\tret = join_running_log_trans(root);\n\t\t \n\t\tif (WARN_ON_ONCE(ret < 0)) {\n\t\t\tfscrypt_free_filename(&fname);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlog_pinned = true;\n\n\t\tpath = btrfs_alloc_path();\n\t\tif (!path) {\n\t\t\tret = -ENOMEM;\n\t\t\tfscrypt_free_filename(&fname);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tmutex_lock(&old_dir->log_mutex);\n\t\tret = del_logged_dentry(trans, log, path, btrfs_ino(old_dir),\n\t\t\t\t\t&fname.disk_name, old_dir_index);\n\t\tif (ret > 0) {\n\t\t\t \n\t\t\tbtrfs_release_path(path);\n\t\t\tret = insert_dir_log_key(trans, log, path,\n\t\t\t\t\t\t btrfs_ino(old_dir),\n\t\t\t\t\t\t old_dir_index, old_dir_index);\n\t\t}\n\t\tmutex_unlock(&old_dir->log_mutex);\n\n\t\tbtrfs_free_path(path);\n\t\tfscrypt_free_filename(&fname);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tbtrfs_init_log_ctx(&ctx, &inode->vfs_inode);\n\tctx.logging_new_name = true;\n\t \n\tbtrfs_log_inode_parent(trans, inode, parent, LOG_INODE_EXISTS, &ctx);\n\tASSERT(list_empty(&ctx.conflict_inodes));\nout:\n\t \n\tif (ret < 0)\n\t\tbtrfs_set_log_full_commit(trans);\n\tif (log_pinned)\n\t\tbtrfs_end_log_trans(root);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}