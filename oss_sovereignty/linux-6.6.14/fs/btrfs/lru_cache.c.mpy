{
  "module_name": "lru_cache.c",
  "hash_id": "4864cfc0ae06ad735c16244468c822839b88e31354fe0183ac1804b4ba8c8e67",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/lru_cache.c",
  "human_readable_source": "\n\n#include <linux/mm.h>\n#include \"lru_cache.h\"\n#include \"messages.h\"\n\n \nvoid btrfs_lru_cache_init(struct btrfs_lru_cache *cache, unsigned int max_size)\n{\n\tINIT_LIST_HEAD(&cache->lru_list);\n\tmt_init(&cache->entries);\n\tcache->size = 0;\n\tcache->max_size = max_size;\n}\n\nstatic struct btrfs_lru_cache_entry *match_entry(struct list_head *head, u64 key,\n\t\t\t\t\t\t u64 gen)\n{\n\tstruct btrfs_lru_cache_entry *entry;\n\n\tlist_for_each_entry(entry, head, list) {\n\t\tif (entry->key == key && entry->gen == gen)\n\t\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\n \nstruct btrfs_lru_cache_entry *btrfs_lru_cache_lookup(struct btrfs_lru_cache *cache,\n\t\t\t\t\t\t     u64 key, u64 gen)\n{\n\tstruct list_head *head;\n\tstruct btrfs_lru_cache_entry *entry;\n\n\thead = mtree_load(&cache->entries, key);\n\tif (!head)\n\t\treturn NULL;\n\n\tentry = match_entry(head, key, gen);\n\tif (entry)\n\t\tlist_move_tail(&entry->lru_list, &cache->lru_list);\n\n\treturn entry;\n}\n\n \nvoid btrfs_lru_cache_remove(struct btrfs_lru_cache *cache,\n\t\t\t    struct btrfs_lru_cache_entry *entry)\n{\n\tstruct list_head *prev = entry->list.prev;\n\n\tASSERT(cache->size > 0);\n\tASSERT(!mtree_empty(&cache->entries));\n\n\tlist_del(&entry->list);\n\tlist_del(&entry->lru_list);\n\n\tif (list_empty(prev)) {\n\t\tstruct list_head *head;\n\n\t\t \n\t\thead = mtree_erase(&cache->entries, entry->key);\n\t\tASSERT(head == prev);\n\t\tkfree(head);\n\t}\n\n\tkfree(entry);\n\tcache->size--;\n}\n\n \nint btrfs_lru_cache_store(struct btrfs_lru_cache *cache,\n\t\t\t  struct btrfs_lru_cache_entry *new_entry,\n\t\t\t  gfp_t gfp)\n{\n\tconst u64 key = new_entry->key;\n\tstruct list_head *head;\n\tint ret;\n\n\thead = kmalloc(sizeof(*head), gfp);\n\tif (!head)\n\t\treturn -ENOMEM;\n\n\tret = mtree_insert(&cache->entries, key, head, gfp);\n\tif (ret == 0) {\n\t\tINIT_LIST_HEAD(head);\n\t\tlist_add_tail(&new_entry->list, head);\n\t} else if (ret == -EEXIST) {\n\t\tkfree(head);\n\t\thead = mtree_load(&cache->entries, key);\n\t\tASSERT(head != NULL);\n\t\tif (match_entry(head, key, new_entry->gen) != NULL)\n\t\t\treturn -EEXIST;\n\t\tlist_add_tail(&new_entry->list, head);\n\t} else if (ret < 0) {\n\t\tkfree(head);\n\t\treturn ret;\n\t}\n\n\tif (cache->max_size > 0 && cache->size == cache->max_size) {\n\t\tstruct btrfs_lru_cache_entry *lru_entry;\n\n\t\tlru_entry = list_first_entry(&cache->lru_list,\n\t\t\t\t\t     struct btrfs_lru_cache_entry,\n\t\t\t\t\t     lru_list);\n\t\tbtrfs_lru_cache_remove(cache, lru_entry);\n\t}\n\n\tlist_add_tail(&new_entry->lru_list, &cache->lru_list);\n\tcache->size++;\n\n\treturn 0;\n}\n\n \nvoid btrfs_lru_cache_clear(struct btrfs_lru_cache *cache)\n{\n\tstruct btrfs_lru_cache_entry *entry;\n\tstruct btrfs_lru_cache_entry *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, &cache->lru_list, lru_list)\n\t\tbtrfs_lru_cache_remove(cache, entry);\n\n\tASSERT(cache->size == 0);\n\tASSERT(mtree_empty(&cache->entries));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}