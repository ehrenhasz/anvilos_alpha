{
  "module_name": "backref.h",
  "hash_id": "ab314b8eba89dc9bfb9f2729e766fa4ac0ef3c06840512c1c063c5dda85db447",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/backref.h",
  "human_readable_source": " \n \n\n#ifndef BTRFS_BACKREF_H\n#define BTRFS_BACKREF_H\n\n#include <linux/btrfs.h>\n#include \"messages.h\"\n#include \"ulist.h\"\n#include \"disk-io.h\"\n#include \"extent_io.h\"\n\n \n#define BTRFS_ITERATE_EXTENT_INODES_STOP 5\n\n \ntypedef int (iterate_extent_inodes_t)(u64 inum, u64 offset, u64 num_bytes,\n\t\t\t\t      u64 root, void *ctx);\n\n \nstruct btrfs_backref_walk_ctx {\n\t \n\tu64 bytenr;\n\t \n\tu64 extent_item_pos;\n\t \n\tbool ignore_extent_item_pos;\n\t \n\tbool skip_inode_ref_list;\n\t \n\tstruct btrfs_trans_handle *trans;\n\t \n\tstruct btrfs_fs_info *fs_info;\n\t \n\tu64 time_seq;\n\t \n\tstruct ulist *refs;\n\t \n\tstruct ulist *roots;\n\t \n\tbool (*cache_lookup)(u64 leaf_bytenr, void *user_ctx,\n\t\t\t     const u64 **root_ids_ret, int *root_count_ret);\n\tvoid (*cache_store)(u64 leaf_bytenr, const struct ulist *root_ids,\n\t\t\t    void *user_ctx);\n\t \n\titerate_extent_inodes_t *indirect_ref_iterator;\n\t \n\tint (*check_extent_item)(u64 bytenr, const struct btrfs_extent_item *ei,\n\t\t\t\t const struct extent_buffer *leaf, void *user_ctx);\n\t \n\tbool (*skip_data_ref)(u64 root, u64 ino, u64 offset, void *user_ctx);\n\t \n\tvoid *user_ctx;\n};\n\nstruct inode_fs_paths {\n\tstruct btrfs_path\t\t*btrfs_path;\n\tstruct btrfs_root\t\t*fs_root;\n\tstruct btrfs_data_container\t*fspath;\n};\n\nstruct btrfs_backref_shared_cache_entry {\n\tu64 bytenr;\n\tu64 gen;\n\tbool is_shared;\n};\n\n#define BTRFS_BACKREF_CTX_PREV_EXTENTS_SIZE 8\n\nstruct btrfs_backref_share_check_ctx {\n\t \n\tstruct ulist refs;\n\t \n\tu64 curr_leaf_bytenr;\n\t \n\tu64 prev_leaf_bytenr;\n\t \n\tstruct btrfs_backref_shared_cache_entry path_cache_entries[BTRFS_MAX_LEVEL];\n\tbool use_path_cache;\n\t \n\tstruct {\n\t\tu64 bytenr;\n\t\tbool is_shared;\n\t} prev_extents_cache[BTRFS_BACKREF_CTX_PREV_EXTENTS_SIZE];\n\t \n\tint prev_extents_cache_slot;\n};\n\nstruct btrfs_backref_share_check_ctx *btrfs_alloc_backref_share_check_ctx(void);\nvoid btrfs_free_backref_share_ctx(struct btrfs_backref_share_check_ctx *ctx);\n\nint extent_from_logical(struct btrfs_fs_info *fs_info, u64 logical,\n\t\t\tstruct btrfs_path *path, struct btrfs_key *found_key,\n\t\t\tu64 *flags);\n\nint tree_backref_for_extent(unsigned long *ptr, struct extent_buffer *eb,\n\t\t\t    struct btrfs_key *key, struct btrfs_extent_item *ei,\n\t\t\t    u32 item_size, u64 *out_root, u8 *out_level);\n\nint iterate_extent_inodes(struct btrfs_backref_walk_ctx *ctx,\n\t\t\t  bool search_commit_root,\n\t\t\t  iterate_extent_inodes_t *iterate, void *user_ctx);\n\nint iterate_inodes_from_logical(u64 logical, struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_path *path, void *ctx,\n\t\t\t\tbool ignore_offset);\n\nint paths_from_inode(u64 inum, struct inode_fs_paths *ipath);\n\nint btrfs_find_all_leafs(struct btrfs_backref_walk_ctx *ctx);\nint btrfs_find_all_roots(struct btrfs_backref_walk_ctx *ctx,\n\t\t\t bool skip_commit_root_sem);\nchar *btrfs_ref_to_path(struct btrfs_root *fs_root, struct btrfs_path *path,\n\t\t\tu32 name_len, unsigned long name_off,\n\t\t\tstruct extent_buffer *eb_in, u64 parent,\n\t\t\tchar *dest, u32 size);\n\nstruct btrfs_data_container *init_data_container(u32 total_bytes);\nstruct inode_fs_paths *init_ipath(s32 total_bytes, struct btrfs_root *fs_root,\n\t\t\t\t\tstruct btrfs_path *path);\nvoid free_ipath(struct inode_fs_paths *ipath);\n\nint btrfs_find_one_extref(struct btrfs_root *root, u64 inode_objectid,\n\t\t\t  u64 start_off, struct btrfs_path *path,\n\t\t\t  struct btrfs_inode_extref **ret_extref,\n\t\t\t  u64 *found_off);\nint btrfs_is_data_extent_shared(struct btrfs_inode *inode, u64 bytenr,\n\t\t\t\tu64 extent_gen,\n\t\t\t\tstruct btrfs_backref_share_check_ctx *ctx);\n\nint __init btrfs_prelim_ref_init(void);\nvoid __cold btrfs_prelim_ref_exit(void);\n\nstruct prelim_ref {\n\tstruct rb_node rbnode;\n\tu64 root_id;\n\tstruct btrfs_key key_for_search;\n\tint level;\n\tint count;\n\tstruct extent_inode_elem *inode_list;\n\tu64 parent;\n\tu64 wanted_disk_byte;\n};\n\n \nstruct btrfs_backref_iter {\n\tu64 bytenr;\n\tstruct btrfs_path *path;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_key cur_key;\n\tu32 item_ptr;\n\tu32 cur_ptr;\n\tu32 end_ptr;\n};\n\nstruct btrfs_backref_iter *btrfs_backref_iter_alloc(struct btrfs_fs_info *fs_info);\n\nstatic inline void btrfs_backref_iter_free(struct btrfs_backref_iter *iter)\n{\n\tif (!iter)\n\t\treturn;\n\tbtrfs_free_path(iter->path);\n\tkfree(iter);\n}\n\nstatic inline struct extent_buffer *btrfs_backref_get_eb(\n\t\tstruct btrfs_backref_iter *iter)\n{\n\tif (!iter)\n\t\treturn NULL;\n\treturn iter->path->nodes[0];\n}\n\n \nstatic inline bool btrfs_backref_has_tree_block_info(\n\t\tstruct btrfs_backref_iter *iter)\n{\n\tif (iter->cur_key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t    iter->cur_ptr - iter->item_ptr == sizeof(struct btrfs_extent_item))\n\t\treturn true;\n\treturn false;\n}\n\nint btrfs_backref_iter_start(struct btrfs_backref_iter *iter, u64 bytenr);\n\nint btrfs_backref_iter_next(struct btrfs_backref_iter *iter);\n\nstatic inline bool btrfs_backref_iter_is_inline_ref(\n\t\tstruct btrfs_backref_iter *iter)\n{\n\tif (iter->cur_key.type == BTRFS_EXTENT_ITEM_KEY ||\n\t    iter->cur_key.type == BTRFS_METADATA_ITEM_KEY)\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline void btrfs_backref_iter_release(struct btrfs_backref_iter *iter)\n{\n\titer->bytenr = 0;\n\titer->item_ptr = 0;\n\titer->cur_ptr = 0;\n\titer->end_ptr = 0;\n\tbtrfs_release_path(iter->path);\n\tmemset(&iter->cur_key, 0, sizeof(iter->cur_key));\n}\n\n \n\n \nstruct btrfs_backref_node {\n\tstruct {\n\t\tstruct rb_node rb_node;\n\t\tu64 bytenr;\n\t};  \n\n\tu64 new_bytenr;\n\t \n\tu64 owner;\n\t \n\tstruct list_head list;\n\n\t \n\tstruct list_head upper;\n\t \n\tstruct list_head lower;\n\n\t \n\tstruct btrfs_root *root;\n\t \n\tstruct extent_buffer *eb;\n\t \n\tunsigned int level:8;\n\t \n\tunsigned int cowonly:1;\n\t \n\tunsigned int lowest:1;\n\t \n\tunsigned int locked:1;\n\t \n\tunsigned int processed:1;\n\t \n\tunsigned int checked:1;\n\t \n\tunsigned int pending:1;\n\t \n\tunsigned int detached:1;\n\n\t \n\tunsigned int is_reloc_root:1;\n};\n\n#define LOWER\t0\n#define UPPER\t1\n\n \nstruct btrfs_backref_edge {\n\t \n\tstruct list_head list[2];\n\n\t \n\tstruct btrfs_backref_node *node[2];\n};\n\nstruct btrfs_backref_cache {\n\t \n\tstruct rb_root rb_root;\n\t \n\tstruct btrfs_backref_node *path[BTRFS_MAX_LEVEL];\n\t \n\tstruct list_head pending[BTRFS_MAX_LEVEL];\n\t \n\tstruct list_head leaves;\n\t \n\tstruct list_head changed;\n\t \n\tstruct list_head detached;\n\n\tu64 last_trans;\n\n\tint nr_nodes;\n\tint nr_edges;\n\n\t \n\tstruct list_head pending_edge;\n\n\t \n\tstruct list_head useless_node;\n\n\tstruct btrfs_fs_info *fs_info;\n\n\t \n\tunsigned int is_reloc;\n};\n\nvoid btrfs_backref_init_cache(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_backref_cache *cache, int is_reloc);\nstruct btrfs_backref_node *btrfs_backref_alloc_node(\n\t\tstruct btrfs_backref_cache *cache, u64 bytenr, int level);\nstruct btrfs_backref_edge *btrfs_backref_alloc_edge(\n\t\tstruct btrfs_backref_cache *cache);\n\n#define\t\tLINK_LOWER\t(1 << 0)\n#define\t\tLINK_UPPER\t(1 << 1)\nstatic inline void btrfs_backref_link_edge(struct btrfs_backref_edge *edge,\n\t\t\t\t\t   struct btrfs_backref_node *lower,\n\t\t\t\t\t   struct btrfs_backref_node *upper,\n\t\t\t\t\t   int link_which)\n{\n\tASSERT(upper && lower && upper->level == lower->level + 1);\n\tedge->node[LOWER] = lower;\n\tedge->node[UPPER] = upper;\n\tif (link_which & LINK_LOWER)\n\t\tlist_add_tail(&edge->list[LOWER], &lower->upper);\n\tif (link_which & LINK_UPPER)\n\t\tlist_add_tail(&edge->list[UPPER], &upper->lower);\n}\n\nstatic inline void btrfs_backref_free_node(struct btrfs_backref_cache *cache,\n\t\t\t\t\t   struct btrfs_backref_node *node)\n{\n\tif (node) {\n\t\tASSERT(list_empty(&node->list));\n\t\tASSERT(list_empty(&node->lower));\n\t\tASSERT(node->eb == NULL);\n\t\tcache->nr_nodes--;\n\t\tbtrfs_put_root(node->root);\n\t\tkfree(node);\n\t}\n}\n\nstatic inline void btrfs_backref_free_edge(struct btrfs_backref_cache *cache,\n\t\t\t\t\t   struct btrfs_backref_edge *edge)\n{\n\tif (edge) {\n\t\tcache->nr_edges--;\n\t\tkfree(edge);\n\t}\n}\n\nstatic inline void btrfs_backref_unlock_node_buffer(\n\t\tstruct btrfs_backref_node *node)\n{\n\tif (node->locked) {\n\t\tbtrfs_tree_unlock(node->eb);\n\t\tnode->locked = 0;\n\t}\n}\n\nstatic inline void btrfs_backref_drop_node_buffer(\n\t\tstruct btrfs_backref_node *node)\n{\n\tif (node->eb) {\n\t\tbtrfs_backref_unlock_node_buffer(node);\n\t\tfree_extent_buffer(node->eb);\n\t\tnode->eb = NULL;\n\t}\n}\n\n \nstatic inline void btrfs_backref_drop_node(struct btrfs_backref_cache *tree,\n\t\t\t\t\t   struct btrfs_backref_node *node)\n{\n\tASSERT(list_empty(&node->upper));\n\n\tbtrfs_backref_drop_node_buffer(node);\n\tlist_del_init(&node->list);\n\tlist_del_init(&node->lower);\n\tif (!RB_EMPTY_NODE(&node->rb_node))\n\t\trb_erase(&node->rb_node, &tree->rb_root);\n\tbtrfs_backref_free_node(tree, node);\n}\n\nvoid btrfs_backref_cleanup_node(struct btrfs_backref_cache *cache,\n\t\t\t\tstruct btrfs_backref_node *node);\n\nvoid btrfs_backref_release_cache(struct btrfs_backref_cache *cache);\n\nstatic inline void btrfs_backref_panic(struct btrfs_fs_info *fs_info,\n\t\t\t\t       u64 bytenr, int errno)\n{\n\tbtrfs_panic(fs_info, errno,\n\t\t    \"Inconsistency in backref cache found at offset %llu\",\n\t\t    bytenr);\n}\n\nint btrfs_backref_add_tree_node(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_backref_cache *cache,\n\t\t\t\tstruct btrfs_path *path,\n\t\t\t\tstruct btrfs_backref_iter *iter,\n\t\t\t\tstruct btrfs_key *node_key,\n\t\t\t\tstruct btrfs_backref_node *cur);\n\nint btrfs_backref_finish_upper_links(struct btrfs_backref_cache *cache,\n\t\t\t\t     struct btrfs_backref_node *start);\n\nvoid btrfs_backref_error_cleanup(struct btrfs_backref_cache *cache,\n\t\t\t\t struct btrfs_backref_node *node);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}