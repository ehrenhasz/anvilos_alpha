{
  "module_name": "messages.c",
  "hash_id": "d3c218af97cc675676781c0983fa2be5a825f283d906ba9f9583f0ada765fc3b",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/messages.c",
  "human_readable_source": "\n\n#include \"fs.h\"\n#include \"messages.h\"\n#include \"discard.h\"\n#include \"transaction.h\"\n#include \"space-info.h\"\n#include \"super.h\"\n\n#ifdef CONFIG_PRINTK\n\n#define STATE_STRING_PREFACE\t\": state \"\n#define STATE_STRING_BUF_LEN\t(sizeof(STATE_STRING_PREFACE) + BTRFS_FS_STATE_COUNT + 1)\n\n \nstatic const char fs_state_chars[] = {\n\t[BTRFS_FS_STATE_REMOUNTING]\t\t= 'M',\n\t[BTRFS_FS_STATE_RO]\t\t\t= 0,\n\t[BTRFS_FS_STATE_TRANS_ABORTED]\t\t= 'A',\n\t[BTRFS_FS_STATE_DEV_REPLACING]\t\t= 'R',\n\t[BTRFS_FS_STATE_DUMMY_FS_INFO]\t\t= 0,\n\t[BTRFS_FS_STATE_NO_CSUMS]\t\t= 'C',\n\t[BTRFS_FS_STATE_LOG_CLEANUP_ERROR]\t= 'L',\n};\n\nstatic void btrfs_state_to_string(const struct btrfs_fs_info *info, char *buf)\n{\n\tunsigned int bit;\n\tbool states_printed = false;\n\tunsigned long fs_state = READ_ONCE(info->fs_state);\n\tchar *curr = buf;\n\n\tmemcpy(curr, STATE_STRING_PREFACE, sizeof(STATE_STRING_PREFACE));\n\tcurr += sizeof(STATE_STRING_PREFACE) - 1;\n\n\tif (BTRFS_FS_ERROR(info)) {\n\t\t*curr++ = 'E';\n\t\tstates_printed = true;\n\t}\n\n\tfor_each_set_bit(bit, &fs_state, sizeof(fs_state)) {\n\t\tWARN_ON_ONCE(bit >= BTRFS_FS_STATE_COUNT);\n\t\tif ((bit < BTRFS_FS_STATE_COUNT) && fs_state_chars[bit]) {\n\t\t\t*curr++ = fs_state_chars[bit];\n\t\t\tstates_printed = true;\n\t\t}\n\t}\n\n\t \n\tif (!states_printed)\n\t\tcurr = buf;\n\n\t*curr++ = 0;\n}\n#endif\n\n \nconst char * __attribute_const__ btrfs_decode_error(int errno)\n{\n\tchar *errstr = \"unknown\";\n\n\tswitch (errno) {\n\tcase -ENOENT:\t\t \n\t\terrstr = \"No such entry\";\n\t\tbreak;\n\tcase -EIO:\t\t \n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\t\t \n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EEXIST:\t\t \n\t\terrstr = \"Object already exists\";\n\t\tbreak;\n\tcase -ENOSPC:\t\t \n\t\terrstr = \"No space left\";\n\t\tbreak;\n\tcase -EROFS:\t\t \n\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tcase -EOPNOTSUPP:\t \n\t\terrstr = \"Operation not supported\";\n\t\tbreak;\n\tcase -EUCLEAN:\t\t \n\t\terrstr = \"Filesystem corrupted\";\n\t\tbreak;\n\tcase -EDQUOT:\t\t \n\t\terrstr = \"Quota exceeded\";\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}\n\n \n__cold\nvoid __btrfs_handle_fs_error(struct btrfs_fs_info *fs_info, const char *function,\n\t\t       unsigned int line, int errno, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n#ifdef CONFIG_PRINTK\n\tchar statestr[STATE_STRING_BUF_LEN];\n\tconst char *errstr;\n#endif\n\n#ifdef CONFIG_PRINTK_INDEX\n\tprintk_index_subsys_emit(\n\t\t\"BTRFS: error (device %s%s) in %s:%d: errno=%d %s\", KERN_CRIT, fmt);\n#endif\n\n\t \n\tif (errno == -EROFS && sb_rdonly(sb))\n\t\treturn;\n\n#ifdef CONFIG_PRINTK\n\terrstr = btrfs_decode_error(errno);\n\tbtrfs_state_to_string(fs_info, statestr);\n\tif (fmt) {\n\t\tstruct va_format vaf;\n\t\tva_list args;\n\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tpr_crit(\"BTRFS: error (device %s%s) in %s:%d: errno=%d %s (%pV)\\n\",\n\t\t\tsb->s_id, statestr, function, line, errno, errstr, &vaf);\n\t\tva_end(args);\n\t} else {\n\t\tpr_crit(\"BTRFS: error (device %s%s) in %s:%d: errno=%d %s\\n\",\n\t\t\tsb->s_id, statestr, function, line, errno, errstr);\n\t}\n#endif\n\n\t \n\tWRITE_ONCE(fs_info->fs_error, errno);\n\n\t \n\tif (!(sb->s_flags & SB_BORN))\n\t\treturn;\n\n\tif (sb_rdonly(sb))\n\t\treturn;\n\n\tbtrfs_discard_stop(fs_info);\n\n\t \n\tbtrfs_set_sb_rdonly(sb);\n\tbtrfs_info(fs_info, \"forced readonly\");\n\t \n}\n\n#ifdef CONFIG_PRINTK\nstatic const char * const logtypes[] = {\n\t\"emergency\",\n\t\"alert\",\n\t\"critical\",\n\t\"error\",\n\t\"warning\",\n\t\"notice\",\n\t\"info\",\n\t\"debug\",\n};\n\n \nstatic struct ratelimit_state printk_limits[] = {\n\tRATELIMIT_STATE_INIT(printk_limits[0], DEFAULT_RATELIMIT_INTERVAL, 100),\n\tRATELIMIT_STATE_INIT(printk_limits[1], DEFAULT_RATELIMIT_INTERVAL, 100),\n\tRATELIMIT_STATE_INIT(printk_limits[2], DEFAULT_RATELIMIT_INTERVAL, 100),\n\tRATELIMIT_STATE_INIT(printk_limits[3], DEFAULT_RATELIMIT_INTERVAL, 100),\n\tRATELIMIT_STATE_INIT(printk_limits[4], DEFAULT_RATELIMIT_INTERVAL, 100),\n\tRATELIMIT_STATE_INIT(printk_limits[5], DEFAULT_RATELIMIT_INTERVAL, 100),\n\tRATELIMIT_STATE_INIT(printk_limits[6], DEFAULT_RATELIMIT_INTERVAL, 100),\n\tRATELIMIT_STATE_INIT(printk_limits[7], DEFAULT_RATELIMIT_INTERVAL, 100),\n};\n\nvoid __cold _btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tchar lvl[PRINTK_MAX_SINGLE_HEADER_LEN + 1] = \"\\0\";\n\tstruct va_format vaf;\n\tva_list args;\n\tint kern_level;\n\tconst char *type = logtypes[4];\n\tstruct ratelimit_state *ratelimit = &printk_limits[4];\n\n#ifdef CONFIG_PRINTK_INDEX\n\tprintk_index_subsys_emit(\"%sBTRFS %s (device %s): \", NULL, fmt);\n#endif\n\n\tva_start(args, fmt);\n\n\twhile ((kern_level = printk_get_level(fmt)) != 0) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\n\t\tif (kern_level >= '0' && kern_level <= '7') {\n\t\t\tmemcpy(lvl, fmt,  size);\n\t\t\tlvl[size] = '\\0';\n\t\t\ttype = logtypes[kern_level - '0'];\n\t\t\tratelimit = &printk_limits[kern_level - '0'];\n\t\t}\n\t\tfmt += size;\n\t}\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (__ratelimit(ratelimit)) {\n\t\tif (fs_info) {\n\t\t\tchar statestr[STATE_STRING_BUF_LEN];\n\n\t\t\tbtrfs_state_to_string(fs_info, statestr);\n\t\t\t_printk(\"%sBTRFS %s (device %s%s): %pV\\n\", lvl, type,\n\t\t\t\tfs_info->sb->s_id, statestr, &vaf);\n\t\t} else {\n\t\t\t_printk(\"%sBTRFS %s: %pV\\n\", lvl, type, &vaf);\n\t\t}\n\t}\n\n\tva_end(args);\n}\n#endif\n\n#if BITS_PER_LONG == 32\nvoid __cold btrfs_warn_32bit_limit(struct btrfs_fs_info *fs_info)\n{\n\tif (!test_and_set_bit(BTRFS_FS_32BIT_WARN, &fs_info->flags)) {\n\t\tbtrfs_warn(fs_info, \"reaching 32bit limit for logical addresses\");\n\t\tbtrfs_warn(fs_info,\n\"due to page cache limit on 32bit systems, btrfs can't access metadata at or beyond %lluT\",\n\t\t\t   BTRFS_32BIT_MAX_FILE_SIZE >> 40);\n\t\tbtrfs_warn(fs_info,\n\t\t\t   \"please consider upgrading to 64bit kernel/hardware\");\n\t}\n}\n\nvoid __cold btrfs_err_32bit_limit(struct btrfs_fs_info *fs_info)\n{\n\tif (!test_and_set_bit(BTRFS_FS_32BIT_ERROR, &fs_info->flags)) {\n\t\tbtrfs_err(fs_info, \"reached 32bit limit for logical addresses\");\n\t\tbtrfs_err(fs_info,\n\"due to page cache limit on 32bit systems, metadata beyond %lluT can't be accessed\",\n\t\t\t  BTRFS_32BIT_MAX_FILE_SIZE >> 40);\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"please consider upgrading to 64bit kernel/hardware\");\n\t}\n}\n#endif\n\n \n__cold\nvoid __btrfs_panic(struct btrfs_fs_info *fs_info, const char *function,\n\t\t   unsigned int line, int errno, const char *fmt, ...)\n{\n\tchar *s_id = \"<unknown>\";\n\tconst char *errstr;\n\tstruct va_format vaf = { .fmt = fmt };\n\tva_list args;\n\n\tif (fs_info)\n\t\ts_id = fs_info->sb->s_id;\n\n\tva_start(args, fmt);\n\tvaf.va = &args;\n\n\terrstr = btrfs_decode_error(errno);\n\tif (fs_info && (btrfs_test_opt(fs_info, PANIC_ON_FATAL_ERROR)))\n\t\tpanic(KERN_CRIT \"BTRFS panic (device %s) in %s:%d: %pV (errno=%d %s)\\n\",\n\t\t\ts_id, function, line, &vaf, errno, errstr);\n\n\tbtrfs_crit(fs_info, \"panic in %s:%d: %pV (errno=%d %s)\",\n\t\t   function, line, &vaf, errno, errstr);\n\tva_end(args);\n\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}