{
  "module_name": "zlib.c",
  "hash_id": "a66d3674ce26d4bade14449a55f56993cda9e4cd9bc0671e07953f794ecba8dc",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/zlib.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/zlib.h>\n#include <linux/zutil.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/refcount.h>\n#include \"compression.h\"\n\n \n#define ZLIB_DFLTCC_BUF_SIZE    (4 * PAGE_SIZE)\n\nstruct workspace {\n\tz_stream strm;\n\tchar *buf;\n\tunsigned int buf_size;\n\tstruct list_head list;\n\tint level;\n};\n\nstatic struct workspace_manager wsm;\n\nstruct list_head *zlib_get_workspace(unsigned int level)\n{\n\tstruct list_head *ws = btrfs_get_workspace(BTRFS_COMPRESS_ZLIB, level);\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\n\tworkspace->level = level;\n\n\treturn ws;\n}\n\nvoid zlib_free_workspace(struct list_head *ws)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\n\tkvfree(workspace->strm.workspace);\n\tkfree(workspace->buf);\n\tkfree(workspace);\n}\n\nstruct list_head *zlib_alloc_workspace(unsigned int level)\n{\n\tstruct workspace *workspace;\n\tint workspacesize;\n\n\tworkspace = kzalloc(sizeof(*workspace), GFP_KERNEL);\n\tif (!workspace)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tworkspacesize = max(zlib_deflate_workspacesize(MAX_WBITS, MAX_MEM_LEVEL),\n\t\t\tzlib_inflate_workspacesize());\n\tworkspace->strm.workspace = kvzalloc(workspacesize, GFP_KERNEL | __GFP_NOWARN);\n\tworkspace->level = level;\n\tworkspace->buf = NULL;\n\t \n\tif (zlib_deflate_dfltcc_enabled()) {\n\t\tworkspace->buf = kmalloc(ZLIB_DFLTCC_BUF_SIZE,\n\t\t\t\t\t __GFP_NOMEMALLOC | __GFP_NORETRY |\n\t\t\t\t\t __GFP_NOWARN | GFP_NOIO);\n\t\tworkspace->buf_size = ZLIB_DFLTCC_BUF_SIZE;\n\t}\n\tif (!workspace->buf) {\n\t\tworkspace->buf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\t\tworkspace->buf_size = PAGE_SIZE;\n\t}\n\tif (!workspace->strm.workspace || !workspace->buf)\n\t\tgoto fail;\n\n\tINIT_LIST_HEAD(&workspace->list);\n\n\treturn &workspace->list;\nfail:\n\tzlib_free_workspace(&workspace->list);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nint zlib_compress_pages(struct list_head *ws, struct address_space *mapping,\n\t\tu64 start, struct page **pages, unsigned long *out_pages,\n\t\tunsigned long *total_in, unsigned long *total_out)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\tint ret;\n\tchar *data_in = NULL;\n\tchar *cpage_out;\n\tint nr_pages = 0;\n\tstruct page *in_page = NULL;\n\tstruct page *out_page = NULL;\n\tunsigned long bytes_left;\n\tunsigned int in_buf_pages;\n\tunsigned long len = *total_out;\n\tunsigned long nr_dest_pages = *out_pages;\n\tconst unsigned long max_out = nr_dest_pages * PAGE_SIZE;\n\n\t*out_pages = 0;\n\t*total_out = 0;\n\t*total_in = 0;\n\n\tif (Z_OK != zlib_deflateInit(&workspace->strm, workspace->level)) {\n\t\tpr_warn(\"BTRFS: deflateInit failed\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tworkspace->strm.total_in = 0;\n\tworkspace->strm.total_out = 0;\n\n\tout_page = alloc_page(GFP_NOFS);\n\tif (out_page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tcpage_out = page_address(out_page);\n\tpages[0] = out_page;\n\tnr_pages = 1;\n\n\tworkspace->strm.next_in = workspace->buf;\n\tworkspace->strm.avail_in = 0;\n\tworkspace->strm.next_out = cpage_out;\n\tworkspace->strm.avail_out = PAGE_SIZE;\n\n\twhile (workspace->strm.total_in < len) {\n\t\t \n\t\tif (workspace->strm.avail_in == 0) {\n\t\t\tbytes_left = len - workspace->strm.total_in;\n\t\t\tin_buf_pages = min(DIV_ROUND_UP(bytes_left, PAGE_SIZE),\n\t\t\t\t\t   workspace->buf_size / PAGE_SIZE);\n\t\t\tif (in_buf_pages > 1) {\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < in_buf_pages; i++) {\n\t\t\t\t\tif (data_in) {\n\t\t\t\t\t\tkunmap_local(data_in);\n\t\t\t\t\t\tput_page(in_page);\n\t\t\t\t\t}\n\t\t\t\t\tin_page = find_get_page(mapping,\n\t\t\t\t\t\t\t\tstart >> PAGE_SHIFT);\n\t\t\t\t\tdata_in = kmap_local_page(in_page);\n\t\t\t\t\tcopy_page(workspace->buf + i * PAGE_SIZE,\n\t\t\t\t\t\t  data_in);\n\t\t\t\t\tstart += PAGE_SIZE;\n\t\t\t\t}\n\t\t\t\tworkspace->strm.next_in = workspace->buf;\n\t\t\t} else {\n\t\t\t\tif (data_in) {\n\t\t\t\t\tkunmap_local(data_in);\n\t\t\t\t\tput_page(in_page);\n\t\t\t\t}\n\t\t\t\tin_page = find_get_page(mapping,\n\t\t\t\t\t\t\tstart >> PAGE_SHIFT);\n\t\t\t\tdata_in = kmap_local_page(in_page);\n\t\t\t\tstart += PAGE_SIZE;\n\t\t\t\tworkspace->strm.next_in = data_in;\n\t\t\t}\n\t\t\tworkspace->strm.avail_in = min(bytes_left,\n\t\t\t\t\t\t       (unsigned long) workspace->buf_size);\n\t\t}\n\n\t\tret = zlib_deflate(&workspace->strm, Z_SYNC_FLUSH);\n\t\tif (ret != Z_OK) {\n\t\t\tpr_debug(\"BTRFS: deflate in loop returned %d\\n\",\n\t\t\t       ret);\n\t\t\tzlib_deflateEnd(&workspace->strm);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (workspace->strm.total_in > 8192 &&\n\t\t    workspace->strm.total_in <\n\t\t    workspace->strm.total_out) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (workspace->strm.avail_out == 0) {\n\t\t\tif (nr_pages == nr_dest_pages) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tout_page = alloc_page(GFP_NOFS);\n\t\t\tif (out_page == NULL) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcpage_out = page_address(out_page);\n\t\t\tpages[nr_pages] = out_page;\n\t\t\tnr_pages++;\n\t\t\tworkspace->strm.avail_out = PAGE_SIZE;\n\t\t\tworkspace->strm.next_out = cpage_out;\n\t\t}\n\t\t \n\t\tif (workspace->strm.total_in >= len)\n\t\t\tbreak;\n\t\tif (workspace->strm.total_out > max_out)\n\t\t\tbreak;\n\t}\n\tworkspace->strm.avail_in = 0;\n\t \n\twhile (ret != Z_STREAM_END) {\n\t\tret = zlib_deflate(&workspace->strm, Z_FINISH);\n\t\tif (ret == Z_STREAM_END)\n\t\t\tbreak;\n\t\tif (ret != Z_OK && ret != Z_BUF_ERROR) {\n\t\t\tzlib_deflateEnd(&workspace->strm);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t} else if (workspace->strm.avail_out == 0) {\n\t\t\t \n\t\t\tif (nr_pages == nr_dest_pages) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tout_page = alloc_page(GFP_NOFS);\n\t\t\tif (out_page == NULL) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcpage_out = page_address(out_page);\n\t\t\tpages[nr_pages] = out_page;\n\t\t\tnr_pages++;\n\t\t\tworkspace->strm.avail_out = PAGE_SIZE;\n\t\t\tworkspace->strm.next_out = cpage_out;\n\t\t}\n\t}\n\tzlib_deflateEnd(&workspace->strm);\n\n\tif (workspace->strm.total_out >= workspace->strm.total_in) {\n\t\tret = -E2BIG;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\t*total_out = workspace->strm.total_out;\n\t*total_in = workspace->strm.total_in;\nout:\n\t*out_pages = nr_pages;\n\tif (data_in) {\n\t\tkunmap_local(data_in);\n\t\tput_page(in_page);\n\t}\n\n\treturn ret;\n}\n\nint zlib_decompress_bio(struct list_head *ws, struct compressed_bio *cb)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\tint ret = 0, ret2;\n\tint wbits = MAX_WBITS;\n\tchar *data_in;\n\tsize_t total_out = 0;\n\tunsigned long page_in_index = 0;\n\tsize_t srclen = cb->compressed_len;\n\tunsigned long total_pages_in = DIV_ROUND_UP(srclen, PAGE_SIZE);\n\tunsigned long buf_start;\n\tstruct page **pages_in = cb->compressed_pages;\n\n\tdata_in = kmap_local_page(pages_in[page_in_index]);\n\tworkspace->strm.next_in = data_in;\n\tworkspace->strm.avail_in = min_t(size_t, srclen, PAGE_SIZE);\n\tworkspace->strm.total_in = 0;\n\n\tworkspace->strm.total_out = 0;\n\tworkspace->strm.next_out = workspace->buf;\n\tworkspace->strm.avail_out = workspace->buf_size;\n\n\t \n\tif (srclen > 2 && !(data_in[1] & PRESET_DICT) &&\n\t    ((data_in[0] & 0x0f) == Z_DEFLATED) &&\n\t    !(((data_in[0]<<8) + data_in[1]) % 31)) {\n\n\t\twbits = -((data_in[0] >> 4) + 8);\n\t\tworkspace->strm.next_in += 2;\n\t\tworkspace->strm.avail_in -= 2;\n\t}\n\n\tif (Z_OK != zlib_inflateInit2(&workspace->strm, wbits)) {\n\t\tpr_warn(\"BTRFS: inflateInit failed\\n\");\n\t\tkunmap_local(data_in);\n\t\treturn -EIO;\n\t}\n\twhile (workspace->strm.total_in < srclen) {\n\t\tret = zlib_inflate(&workspace->strm, Z_NO_FLUSH);\n\t\tif (ret != Z_OK && ret != Z_STREAM_END)\n\t\t\tbreak;\n\n\t\tbuf_start = total_out;\n\t\ttotal_out = workspace->strm.total_out;\n\n\t\t \n\t\tif (buf_start == total_out)\n\t\t\tbreak;\n\n\t\tret2 = btrfs_decompress_buf2page(workspace->buf,\n\t\t\t\ttotal_out - buf_start, cb, buf_start);\n\t\tif (ret2 == 0) {\n\t\t\tret = 0;\n\t\t\tgoto done;\n\t\t}\n\n\t\tworkspace->strm.next_out = workspace->buf;\n\t\tworkspace->strm.avail_out = workspace->buf_size;\n\n\t\tif (workspace->strm.avail_in == 0) {\n\t\t\tunsigned long tmp;\n\t\t\tkunmap_local(data_in);\n\t\t\tpage_in_index++;\n\t\t\tif (page_in_index >= total_pages_in) {\n\t\t\t\tdata_in = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata_in = kmap_local_page(pages_in[page_in_index]);\n\t\t\tworkspace->strm.next_in = data_in;\n\t\t\ttmp = srclen - workspace->strm.total_in;\n\t\t\tworkspace->strm.avail_in = min(tmp, PAGE_SIZE);\n\t\t}\n\t}\n\tif (ret != Z_STREAM_END)\n\t\tret = -EIO;\n\telse\n\t\tret = 0;\ndone:\n\tzlib_inflateEnd(&workspace->strm);\n\tif (data_in)\n\t\tkunmap_local(data_in);\n\treturn ret;\n}\n\nint zlib_decompress(struct list_head *ws, const u8 *data_in,\n\t\tstruct page *dest_page, unsigned long start_byte, size_t srclen,\n\t\tsize_t destlen)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\tint ret = 0;\n\tint wbits = MAX_WBITS;\n\tunsigned long bytes_left;\n\tunsigned long total_out = 0;\n\tunsigned long pg_offset = 0;\n\n\tdestlen = min_t(unsigned long, destlen, PAGE_SIZE);\n\tbytes_left = destlen;\n\n\tworkspace->strm.next_in = data_in;\n\tworkspace->strm.avail_in = srclen;\n\tworkspace->strm.total_in = 0;\n\n\tworkspace->strm.next_out = workspace->buf;\n\tworkspace->strm.avail_out = workspace->buf_size;\n\tworkspace->strm.total_out = 0;\n\t \n\tif (srclen > 2 && !(data_in[1] & PRESET_DICT) &&\n\t    ((data_in[0] & 0x0f) == Z_DEFLATED) &&\n\t    !(((data_in[0]<<8) + data_in[1]) % 31)) {\n\n\t\twbits = -((data_in[0] >> 4) + 8);\n\t\tworkspace->strm.next_in += 2;\n\t\tworkspace->strm.avail_in -= 2;\n\t}\n\n\tif (Z_OK != zlib_inflateInit2(&workspace->strm, wbits)) {\n\t\tpr_warn(\"BTRFS: inflateInit failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\twhile (bytes_left > 0) {\n\t\tunsigned long buf_start;\n\t\tunsigned long buf_offset;\n\t\tunsigned long bytes;\n\n\t\tret = zlib_inflate(&workspace->strm, Z_NO_FLUSH);\n\t\tif (ret != Z_OK && ret != Z_STREAM_END)\n\t\t\tbreak;\n\n\t\tbuf_start = total_out;\n\t\ttotal_out = workspace->strm.total_out;\n\n\t\tif (total_out == buf_start) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (total_out <= start_byte)\n\t\t\tgoto next;\n\n\t\tif (total_out > start_byte && buf_start < start_byte)\n\t\t\tbuf_offset = start_byte - buf_start;\n\t\telse\n\t\t\tbuf_offset = 0;\n\n\t\tbytes = min(PAGE_SIZE - pg_offset,\n\t\t\t    PAGE_SIZE - (buf_offset % PAGE_SIZE));\n\t\tbytes = min(bytes, bytes_left);\n\n\t\tmemcpy_to_page(dest_page, pg_offset,\n\t\t\t       workspace->buf + buf_offset, bytes);\n\n\t\tpg_offset += bytes;\n\t\tbytes_left -= bytes;\nnext:\n\t\tworkspace->strm.next_out = workspace->buf;\n\t\tworkspace->strm.avail_out = workspace->buf_size;\n\t}\n\n\tif (ret != Z_STREAM_END && bytes_left != 0)\n\t\tret = -EIO;\n\telse\n\t\tret = 0;\n\n\tzlib_inflateEnd(&workspace->strm);\n\n\t \n\tif (pg_offset < destlen) {\n\t\tmemzero_page(dest_page, pg_offset, destlen - pg_offset);\n\t}\n\treturn ret;\n}\n\nconst struct btrfs_compress_op btrfs_zlib_compress = {\n\t.workspace_manager\t= &wsm,\n\t.max_level\t\t= 9,\n\t.default_level\t\t= BTRFS_ZLIB_DEFAULT_LEVEL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}