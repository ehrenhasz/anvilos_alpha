{
  "module_name": "uuid-tree.c",
  "hash_id": "0d8e6ef6cada90d167ee369eb8acaf5126ea6a215f9133704535a39aa17332e8",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/uuid-tree.c",
  "human_readable_source": "\n \n\n#include <linux/uuid.h>\n#include <asm/unaligned.h>\n#include \"messages.h\"\n#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"print-tree.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n#include \"uuid-tree.h\"\n\nstatic void btrfs_uuid_to_key(u8 *uuid, u8 type, struct btrfs_key *key)\n{\n\tkey->type = type;\n\tkey->objectid = get_unaligned_le64(uuid);\n\tkey->offset = get_unaligned_le64(uuid + sizeof(u64));\n}\n\n \nstatic int btrfs_uuid_tree_lookup(struct btrfs_root *uuid_root, u8 *uuid,\n\t\t\t\t  u8 type, u64 subid)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tu32 item_size;\n\tunsigned long offset;\n\tstruct btrfs_key key;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\tret = btrfs_search_slot(NULL, uuid_root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem_size = btrfs_item_size(eb, slot);\n\toffset = btrfs_item_ptr_offset(eb, slot);\n\tret = -ENOENT;\n\n\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\tbtrfs_warn(uuid_root->fs_info,\n\t\t\t   \"uuid item with illegal size %lu!\",\n\t\t\t   (unsigned long)item_size);\n\t\tgoto out;\n\t}\n\twhile (item_size) {\n\t\t__le64 data;\n\n\t\tread_extent_buffer(eb, &data, offset, sizeof(data));\n\t\tif (le64_to_cpu(data) == subid) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\toffset += sizeof(data);\n\t\titem_size -= sizeof(data);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nint btrfs_uuid_tree_add(struct btrfs_trans_handle *trans, u8 *uuid, u8 type,\n\t\t\tu64 subid_cpu)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_root *uuid_root = fs_info->uuid_root;\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\t__le64 subid_le;\n\n\tret = btrfs_uuid_tree_lookup(uuid_root, uuid, type, subid_cpu);\n\tif (ret != -ENOENT)\n\t\treturn ret;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_insert_empty_item(trans, uuid_root, path, &key,\n\t\t\t\t      sizeof(subid_le));\n\tif (ret >= 0) {\n\t\t \n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t} else if (ret == -EEXIST) {\n\t\t \n\t\tbtrfs_extend_item(trans, path, sizeof(subid_le));\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t\toffset += btrfs_item_size(eb, slot) - sizeof(subid_le);\n\t} else {\n\t\tbtrfs_warn(fs_info,\n\t\t\t   \"insert uuid item failed %d (0x%016llx, 0x%016llx) type %u!\",\n\t\t\t   ret, key.objectid, key.offset, type);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tsubid_le = cpu_to_le64(subid_cpu);\n\twrite_extent_buffer(eb, &subid_le, offset, sizeof(subid_le));\n\tbtrfs_mark_buffer_dirty(trans, eb);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nint btrfs_uuid_tree_remove(struct btrfs_trans_handle *trans, u8 *uuid, u8 type,\n\t\t\tu64 subid)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_root *uuid_root = fs_info->uuid_root;\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\tu32 item_size;\n\tunsigned long move_dst;\n\tunsigned long move_src;\n\tunsigned long move_len;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_search_slot(trans, uuid_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tbtrfs_warn(fs_info, \"error %d while searching for uuid item!\",\n\t\t\t   ret);\n\t\tgoto out;\n\t}\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\toffset = btrfs_item_ptr_offset(eb, slot);\n\titem_size = btrfs_item_size(eb, slot);\n\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\tbtrfs_warn(fs_info, \"uuid item with illegal size %lu!\",\n\t\t\t   (unsigned long)item_size);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\twhile (item_size) {\n\t\t__le64 read_subid;\n\n\t\tread_extent_buffer(eb, &read_subid, offset, sizeof(read_subid));\n\t\tif (le64_to_cpu(read_subid) == subid)\n\t\t\tbreak;\n\t\toffset += sizeof(read_subid);\n\t\titem_size -= sizeof(read_subid);\n\t}\n\n\tif (!item_size) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\titem_size = btrfs_item_size(eb, slot);\n\tif (item_size == sizeof(subid)) {\n\t\tret = btrfs_del_item(trans, uuid_root, path);\n\t\tgoto out;\n\t}\n\n\tmove_dst = offset;\n\tmove_src = offset + sizeof(subid);\n\tmove_len = item_size - (move_src - btrfs_item_ptr_offset(eb, slot));\n\tmemmove_extent_buffer(eb, move_dst, move_src, move_len);\n\tbtrfs_truncate_item(trans, path, item_size - sizeof(subid), 1);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int btrfs_uuid_iter_rem(struct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\t       u64 subid)\n{\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\t \n\ttrans = btrfs_start_transaction(uuid_root, 1);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tret = btrfs_uuid_tree_remove(trans, uuid, type, subid);\n\tbtrfs_end_transaction(trans);\n\nout:\n\treturn ret;\n}\n\n \nstatic int btrfs_check_uuid_tree_entry(struct btrfs_fs_info *fs_info,\n\t\t\t\t       u8 *uuid, u8 type, u64 subvolid)\n{\n\tint ret = 0;\n\tstruct btrfs_root *subvol_root;\n\n\tif (type != BTRFS_UUID_KEY_SUBVOL &&\n\t    type != BTRFS_UUID_KEY_RECEIVED_SUBVOL)\n\t\tgoto out;\n\n\tsubvol_root = btrfs_get_fs_root(fs_info, subvolid, true);\n\tif (IS_ERR(subvol_root)) {\n\t\tret = PTR_ERR(subvol_root);\n\t\tif (ret == -ENOENT)\n\t\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tswitch (type) {\n\tcase BTRFS_UUID_KEY_SUBVOL:\n\t\tif (memcmp(uuid, subvol_root->root_item.uuid, BTRFS_UUID_SIZE))\n\t\t\tret = 1;\n\t\tbreak;\n\tcase BTRFS_UUID_KEY_RECEIVED_SUBVOL:\n\t\tif (memcmp(uuid, subvol_root->root_item.received_uuid,\n\t\t\t   BTRFS_UUID_SIZE))\n\t\t\tret = 1;\n\t\tbreak;\n\t}\n\tbtrfs_put_root(subvol_root);\nout:\n\treturn ret;\n}\n\nint btrfs_uuid_tree_iterate(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = fs_info->uuid_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tint ret = 0;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tu32 item_size;\n\tunsigned long offset;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = 0;\n\tkey.offset = 0;\n\nagain_search_slot:\n\tret = btrfs_search_forward(root, &key, path, BTRFS_OLDEST_GENERATION);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tif (btrfs_fs_closing(fs_info)) {\n\t\t\tret = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t\tcond_resched();\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\n\t\tif (key.type != BTRFS_UUID_KEY_SUBVOL &&\n\t\t    key.type != BTRFS_UUID_KEY_RECEIVED_SUBVOL)\n\t\t\tgoto skip;\n\n\t\toffset = btrfs_item_ptr_offset(leaf, slot);\n\t\titem_size = btrfs_item_size(leaf, slot);\n\t\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t   \"uuid item with illegal size %lu!\",\n\t\t\t\t   (unsigned long)item_size);\n\t\t\tgoto skip;\n\t\t}\n\t\twhile (item_size) {\n\t\t\tu8 uuid[BTRFS_UUID_SIZE];\n\t\t\t__le64 subid_le;\n\t\t\tu64 subid_cpu;\n\n\t\t\tput_unaligned_le64(key.objectid, uuid);\n\t\t\tput_unaligned_le64(key.offset, uuid + sizeof(u64));\n\t\t\tread_extent_buffer(leaf, &subid_le, offset,\n\t\t\t\t\t   sizeof(subid_le));\n\t\t\tsubid_cpu = le64_to_cpu(subid_le);\n\t\t\tret = btrfs_check_uuid_tree_entry(fs_info, uuid,\n\t\t\t\t\t\t\t  key.type, subid_cpu);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tret = btrfs_uuid_iter_rem(root, uuid, key.type,\n\t\t\t\t\t\t\t  subid_cpu);\n\t\t\t\tif (ret == 0) {\n\t\t\t\t\t \n\t\t\t\t\tgoto again_search_slot;\n\t\t\t\t}\n\t\t\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\t\t\tgoto out;\n\t\t\t\tkey.offset++;\n\t\t\t\tgoto again_search_slot;\n\t\t\t}\n\t\t\titem_size -= sizeof(subid_le);\n\t\t\toffset += sizeof(subid_le);\n\t\t}\n\nskip:\n\t\tret = btrfs_next_item(root, path);\n\t\tif (ret == 0)\n\t\t\tcontinue;\n\t\telse if (ret > 0)\n\t\t\tret = 0;\n\t\tbreak;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}