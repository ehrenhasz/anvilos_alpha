{
  "module_name": "ctree.h",
  "hash_id": "5d44f9f47750271cbd2aec0aa0692c5cd49c823304dac6ca125cbe2a58e55764",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/ctree.h",
  "human_readable_source": " \n \n\n#ifndef BTRFS_CTREE_H\n#define BTRFS_CTREE_H\n\n#include <linux/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/rwsem.h>\n#include <linux/semaphore.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <trace/events/btrfs.h>\n#include <asm/unaligned.h>\n#include <linux/pagemap.h>\n#include <linux/btrfs.h>\n#include <linux/btrfs_tree.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/sizes.h>\n#include <linux/dynamic_debug.h>\n#include <linux/refcount.h>\n#include <linux/crc32c.h>\n#include <linux/iomap.h>\n#include <linux/fscrypt.h>\n#include \"extent-io-tree.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include \"async-thread.h\"\n#include \"block-rsv.h\"\n#include \"locking.h\"\n#include \"misc.h\"\n#include \"fs.h\"\n\nstruct btrfs_trans_handle;\nstruct btrfs_transaction;\nstruct btrfs_pending_snapshot;\nstruct btrfs_delayed_ref_root;\nstruct btrfs_space_info;\nstruct btrfs_block_group;\nstruct btrfs_ordered_sum;\nstruct btrfs_ref;\nstruct btrfs_bio;\nstruct btrfs_ioctl_encoded_io_args;\nstruct btrfs_device;\nstruct btrfs_fs_devices;\nstruct btrfs_balance_control;\nstruct btrfs_delayed_root;\nstruct reloc_control;\n\n \nenum {\n\tREADA_NONE,\n\tREADA_BACK,\n\tREADA_FORWARD,\n\t \n\tREADA_FORWARD_ALWAYS,\n};\n\n \nstruct btrfs_path {\n\tstruct extent_buffer *nodes[BTRFS_MAX_LEVEL];\n\tint slots[BTRFS_MAX_LEVEL];\n\t \n\tu8 locks[BTRFS_MAX_LEVEL];\n\tu8 reada;\n\t \n\tu8 lowest_level;\n\n\t \n\tunsigned int search_for_split:1;\n\tunsigned int keep_locks:1;\n\tunsigned int skip_locking:1;\n\tunsigned int search_commit_root:1;\n\tunsigned int need_commit_sem:1;\n\tunsigned int skip_release_on_error:1;\n\t \n\tunsigned int search_for_extension:1;\n\t \n\tunsigned int nowait:1;\n};\n\n \nenum {\n\t \n\tBTRFS_ROOT_IN_TRANS_SETUP,\n\n\t \n\tBTRFS_ROOT_SHAREABLE,\n\tBTRFS_ROOT_TRACK_DIRTY,\n\tBTRFS_ROOT_IN_RADIX,\n\tBTRFS_ROOT_ORPHAN_ITEM_INSERTED,\n\tBTRFS_ROOT_DEFRAG_RUNNING,\n\tBTRFS_ROOT_FORCE_COW,\n\tBTRFS_ROOT_MULTI_LOG_TASKS,\n\tBTRFS_ROOT_DIRTY,\n\tBTRFS_ROOT_DELETING,\n\n\t \n\tBTRFS_ROOT_DEAD_RELOC_TREE,\n\t \n\tBTRFS_ROOT_DEAD_TREE,\n\t \n\tBTRFS_ROOT_HAS_LOG_TREE,\n\t \n\tBTRFS_ROOT_QGROUP_FLUSHING,\n\t \n\tBTRFS_ROOT_ORPHAN_CLEANUP,\n\t \n\tBTRFS_ROOT_UNFINISHED_DROP,\n\t \n\tBTRFS_ROOT_RESET_LOCKDEP_CLASS,\n};\n\n \nstruct btrfs_qgroup_swapped_blocks {\n\tspinlock_t lock;\n\t \n\tbool swapped;\n\tstruct rb_root blocks[BTRFS_MAX_LEVEL];\n};\n\n \nstruct btrfs_root {\n\tstruct rb_node rb_node;\n\n\tstruct extent_buffer *node;\n\n\tstruct extent_buffer *commit_root;\n\tstruct btrfs_root *log_root;\n\tstruct btrfs_root *reloc_root;\n\n\tunsigned long state;\n\tstruct btrfs_root_item root_item;\n\tstruct btrfs_key root_key;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct extent_io_tree dirty_log_pages;\n\n\tstruct mutex objectid_mutex;\n\n\tspinlock_t accounting_lock;\n\tstruct btrfs_block_rsv *block_rsv;\n\n\tstruct mutex log_mutex;\n\twait_queue_head_t log_writer_wait;\n\twait_queue_head_t log_commit_wait[2];\n\tstruct list_head log_ctxs[2];\n\t \n\tatomic_t log_writers;\n\tatomic_t log_commit[2];\n\t \n\tatomic_t log_batch;\n\tint log_transid;\n\t \n\tint log_transid_committed;\n\t \n\tint last_log_commit;\n\tpid_t log_start_pid;\n\n\tu64 last_trans;\n\n\tu32 type;\n\n\tu64 free_objectid;\n\n\tstruct btrfs_key defrag_progress;\n\tstruct btrfs_key defrag_max;\n\n\t \n\tstruct list_head dirty_list;\n\n\tstruct list_head root_list;\n\n\tspinlock_t log_extents_lock[2];\n\tstruct list_head logged_list[2];\n\n\tspinlock_t inode_lock;\n\t \n\tstruct rb_root inode_tree;\n\n\t \n\tstruct radix_tree_root delayed_nodes_tree;\n\t \n\tdev_t anon_dev;\n\n\tspinlock_t root_item_lock;\n\trefcount_t refs;\n\n\tstruct mutex delalloc_mutex;\n\tspinlock_t delalloc_lock;\n\t \n\tstruct list_head delalloc_inodes;\n\tstruct list_head delalloc_root;\n\tu64 nr_delalloc_inodes;\n\n\tstruct mutex ordered_extent_mutex;\n\t \n\tspinlock_t ordered_extent_lock;\n\n\t \n\tstruct list_head ordered_extents;\n\tstruct list_head ordered_root;\n\tu64 nr_ordered_extents;\n\n\t \n\tstruct list_head reloc_dirty_list;\n\n\t \n\tint send_in_progress;\n\t \n\tint dedupe_in_progress;\n\t \n\tstruct btrfs_drew_lock snapshot_lock;\n\n\tatomic_t snapshot_force_cow;\n\n\t \n\tspinlock_t qgroup_meta_rsv_lock;\n\tu64 qgroup_meta_rsv_pertrans;\n\tu64 qgroup_meta_rsv_prealloc;\n\twait_queue_head_t qgroup_flush_wait;\n\n\t \n\tatomic_t nr_swapfiles;\n\n\t \n\tstruct btrfs_qgroup_swapped_blocks swapped_blocks;\n\n\t \n\tstruct extent_io_tree log_csum_range;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\tu64 alloc_bytenr;\n#endif\n\n#ifdef CONFIG_BTRFS_DEBUG\n\tstruct list_head leak_list;\n#endif\n};\n\nstatic inline bool btrfs_root_readonly(const struct btrfs_root *root)\n{\n\t \n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}\n\nstatic inline bool btrfs_root_dead(const struct btrfs_root *root)\n{\n\t \n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_DEAD)) != 0;\n}\n\nstatic inline u64 btrfs_root_id(const struct btrfs_root *root)\n{\n\treturn root->root_key.objectid;\n}\n\n \nstruct btrfs_replace_extent_info {\n\tu64 disk_offset;\n\tu64 disk_len;\n\tu64 data_offset;\n\tu64 data_len;\n\tu64 file_offset;\n\t \n\tchar *extent_buf;\n\t \n\tbool is_new_extent;\n\t \n\tbool update_times;\n\t \n\tint qgroup_reserved;\n\t \n\tint insertions;\n};\n\n \nstruct btrfs_drop_extents_args {\n\t \n\n\t \n\tstruct btrfs_path *path;\n\t \n\tu64 start;\n\t \n\tu64 end;\n\t \n\tbool drop_cache;\n\t \n\tbool replace_extent;\n\t \n\tu32 extent_item_size;\n\n\t \n\n\t \n\tu64 drop_end;\n\t \n\tu64 bytes_found;\n\t \n\tbool extent_inserted;\n};\n\nstruct btrfs_file_private {\n\tvoid *filldir_buf;\n\tu64 last_index;\n\tstruct extent_state *llseek_cached_state;\n};\n\nstatic inline u32 BTRFS_LEAF_DATA_SIZE(const struct btrfs_fs_info *info)\n{\n\treturn info->nodesize - sizeof(struct btrfs_header);\n}\n\nstatic inline u32 BTRFS_MAX_ITEM_SIZE(const struct btrfs_fs_info *info)\n{\n\treturn BTRFS_LEAF_DATA_SIZE(info) - sizeof(struct btrfs_item);\n}\n\nstatic inline u32 BTRFS_NODEPTRS_PER_BLOCK(const struct btrfs_fs_info *info)\n{\n\treturn BTRFS_LEAF_DATA_SIZE(info) / sizeof(struct btrfs_key_ptr);\n}\n\nstatic inline u32 BTRFS_MAX_XATTR_SIZE(const struct btrfs_fs_info *info)\n{\n\treturn BTRFS_MAX_ITEM_SIZE(info) - sizeof(struct btrfs_dir_item);\n}\n\n#define BTRFS_BYTES_TO_BLKS(fs_info, bytes) \\\n\t\t\t\t((bytes) >> (fs_info)->sectorsize_bits)\n\nstatic inline u32 btrfs_crc32c(u32 crc, const void *address, unsigned length)\n{\n\treturn crc32c(crc, address, length);\n}\n\nstatic inline void btrfs_crc32c_final(u32 crc, u8 *result)\n{\n\tput_unaligned_le32(~crc, result);\n}\n\nstatic inline u64 btrfs_name_hash(const char *name, int len)\n{\n       return crc32c((u32)~1, name, len);\n}\n\n \nstatic inline u64 btrfs_extref_hash(u64 parent_objectid, const char *name,\n                                   int len)\n{\n       return (u64) crc32c(parent_objectid, name, len);\n}\n\nstatic inline gfp_t btrfs_alloc_write_mask(struct address_space *mapping)\n{\n\treturn mapping_gfp_constraint(mapping, ~__GFP_FS);\n}\n\nint btrfs_error_unpin_extent_range(struct btrfs_fs_info *fs_info,\n\t\t\t\t   u64 start, u64 end);\nint btrfs_discard_extent(struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t u64 num_bytes, u64 *actual_bytes);\nint btrfs_trim_fs(struct btrfs_fs_info *fs_info, struct fstrim_range *range);\n\n \nint __init btrfs_ctree_init(void);\nvoid __cold btrfs_ctree_exit(void);\n\nint btrfs_bin_search(struct extent_buffer *eb, int first_slot,\n\t\t     const struct btrfs_key *key, int *slot);\n\nint __pure btrfs_comp_cpu_keys(const struct btrfs_key *k1, const struct btrfs_key *k2);\nint btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type);\nint btrfs_previous_extent_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid);\nvoid btrfs_set_item_key_safe(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_path *path,\n\t\t\t     const struct btrfs_key *new_key);\nstruct extent_buffer *btrfs_root_node(struct btrfs_root *root);\nint btrfs_find_next_key(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\tstruct btrfs_key *key, int lowest_level,\n\t\t\tu64 min_trans);\nint btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,\n\t\t\t struct btrfs_path *path,\n\t\t\t u64 min_trans);\nstruct extent_buffer *btrfs_read_node_slot(struct extent_buffer *parent,\n\t\t\t\t\t   int slot);\n\nint btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret,\n\t\t    enum btrfs_lock_nesting nest);\nint btrfs_copy_root(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_root *root,\n\t\t      struct extent_buffer *buf,\n\t\t      struct extent_buffer **cow_ret, u64 new_root_objectid);\nint btrfs_block_can_be_shared(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root,\n\t\t\t      struct extent_buffer *buf);\nint btrfs_del_ptr(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t  struct btrfs_path *path, int level, int slot);\nvoid btrfs_extend_item(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_path *path, u32 data_size);\nvoid btrfs_truncate_item(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_path *path, u32 new_size, int from_end);\nint btrfs_split_item(struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_root *root,\n\t\t     struct btrfs_path *path,\n\t\t     const struct btrfs_key *new_key,\n\t\t     unsigned long split_offset);\nint btrfs_duplicate_item(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t struct btrfs_path *path,\n\t\t\t const struct btrfs_key *new_key);\nint btrfs_find_item(struct btrfs_root *fs_root, struct btrfs_path *path,\n\t\tu64 inum, u64 ioff, u8 key_type, struct btrfs_key *found_key);\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      const struct btrfs_key *key, struct btrfs_path *p,\n\t\t      int ins_len, int cow);\nint btrfs_search_old_slot(struct btrfs_root *root, const struct btrfs_key *key,\n\t\t\t  struct btrfs_path *p, u64 time_seq);\nint btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       const struct btrfs_key *key,\n\t\t\t       struct btrfs_path *p, int find_higher,\n\t\t\t       int return_any);\nint btrfs_realloc_node(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct extent_buffer *parent,\n\t\t       int start_slot, u64 *last_ret,\n\t\t       struct btrfs_key *progress);\nvoid btrfs_release_path(struct btrfs_path *p);\nstruct btrfs_path *btrfs_alloc_path(void);\nvoid btrfs_free_path(struct btrfs_path *p);\n\nint btrfs_del_items(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t   struct btrfs_path *path, int slot, int nr);\nstatic inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}\n\n \nstruct btrfs_item_batch {\n\t \n\tconst struct btrfs_key *keys;\n\t \n\tconst u32 *data_sizes;\n\t \n\tu32 total_data_size;\n\t \n\tint nr;\n};\n\nvoid btrfs_setup_item_for_insert(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path,\n\t\t\t\t const struct btrfs_key *key,\n\t\t\t\t u32 data_size);\nint btrfs_insert_item(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      const struct btrfs_key *key, void *data, u32 data_size);\nint btrfs_insert_empty_items(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path,\n\t\t\t     const struct btrfs_item_batch *batch);\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  const struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\tstruct btrfs_item_batch batch;\n\n\tbatch.keys = key;\n\tbatch.data_sizes = &data_size;\n\tbatch.total_data_size = data_size;\n\tbatch.nr = 1;\n\n\treturn btrfs_insert_empty_items(trans, root, path, &batch);\n}\n\nint btrfs_next_old_leaf(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\tu64 time_seq);\n\nint btrfs_search_backwards(struct btrfs_root *root, struct btrfs_key *key,\n\t\t\t   struct btrfs_path *path);\n\nint btrfs_get_next_valid_item(struct btrfs_root *root, struct btrfs_key *key,\n\t\t\t      struct btrfs_path *path);\n\n \n#define btrfs_for_each_slot(root, key, found_key, path, iter_ret)\t\t\\\n\tfor (iter_ret = btrfs_search_slot(NULL, (root), (key), (path), 0, 0);\t\\\n\t\t(iter_ret) >= 0 &&\t\t\t\t\t\t\\\n\t\t(iter_ret = btrfs_get_next_valid_item((root), (found_key), (path))) == 0; \\\n\t\t(path)->slots[0]++\t\t\t\t\t\t\\\n\t)\n\nint btrfs_next_old_item(struct btrfs_root *root, struct btrfs_path *path, u64 time_seq);\n\n \nstatic inline int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}\n\nstatic inline int btrfs_next_item(struct btrfs_root *root, struct btrfs_path *p)\n{\n\treturn btrfs_next_old_item(root, p, 0);\n}\nint btrfs_leaf_free_space(const struct extent_buffer *leaf);\n\nstatic inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    ((s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID &&\n\t      !btrfs_qgroup_level(rootid)))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline bool btrfs_is_data_reloc_root(const struct btrfs_root *root)\n{\n\treturn root->root_key.objectid == BTRFS_DATA_RELOC_TREE_OBJECTID;\n}\n\nu16 btrfs_csum_type_size(u16 type);\nint btrfs_super_csum_size(const struct btrfs_super_block *s);\nconst char *btrfs_super_csum_name(u16 csum_type);\nconst char *btrfs_super_csum_driver(u16 csum_type);\nsize_t __attribute_const__ btrfs_get_num_csums(void);\n\n \n#define PageOrdered(page)\t\tPagePrivate2(page)\n#define SetPageOrdered(page)\t\tSetPagePrivate2(page)\n#define ClearPageOrdered(page)\t\tClearPagePrivate2(page)\n#define folio_test_ordered(folio)\tfolio_test_private_2(folio)\n#define folio_set_ordered(folio)\tfolio_set_private_2(folio)\n#define folio_clear_ordered(folio)\tfolio_clear_private_2(folio)\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}