{
  "module_name": "locking.h",
  "hash_id": "80c7bb87aeb2d05d220811555ffe5e4ce222f3ae5a6ae5953a9c14f1488b9cd9",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/locking.h",
  "human_readable_source": " \n \n\n#ifndef BTRFS_LOCKING_H\n#define BTRFS_LOCKING_H\n\n#include <linux/atomic.h>\n#include <linux/wait.h>\n#include <linux/percpu_counter.h>\n#include \"extent_io.h\"\n\n#define BTRFS_WRITE_LOCK 1\n#define BTRFS_READ_LOCK 2\n\n \nenum btrfs_lock_nesting {\n\tBTRFS_NESTING_NORMAL,\n\n\t \n\tBTRFS_NESTING_COW,\n\n\t \n\tBTRFS_NESTING_LEFT,\n\tBTRFS_NESTING_RIGHT,\n\n\t \n\tBTRFS_NESTING_LEFT_COW,\n\tBTRFS_NESTING_RIGHT_COW,\n\n\t \n\tBTRFS_NESTING_SPLIT,\n\n\t \n\tBTRFS_NESTING_NEW_ROOT,\n\n\t \n\tBTRFS_NESTING_MAX,\n};\n\nenum btrfs_lockdep_trans_states {\n\tBTRFS_LOCKDEP_TRANS_COMMIT_PREP,\n\tBTRFS_LOCKDEP_TRANS_UNBLOCKED,\n\tBTRFS_LOCKDEP_TRANS_SUPER_COMMITTED,\n\tBTRFS_LOCKDEP_TRANS_COMPLETED,\n};\n\n \n#define btrfs_might_wait_for_event(owner, lock)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\\\n\t\trwsem_acquire(&owner->lock##_map, 0, 0, _THIS_IP_);\t\t\\\n\t\trwsem_release(&owner->lock##_map, _THIS_IP_);\t\t\t\\\n\t} while (0)\n\n \n#define btrfs_lockdep_acquire(owner, lock)\t\t\t\t\t\\\n\trwsem_acquire_read(&owner->lock##_map, 0, 0, _THIS_IP_)\n\n \n#define btrfs_lockdep_release(owner, lock)\t\t\t\t\t\\\n\trwsem_release(&owner->lock##_map, _THIS_IP_)\n\n \n#define btrfs_might_wait_for_state(owner, i)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\\\n\t\trwsem_acquire(&owner->btrfs_state_change_map[i], 0, 0, _THIS_IP_); \\\n\t\trwsem_release(&owner->btrfs_state_change_map[i], _THIS_IP_);\t\\\n\t} while (0)\n\n#define btrfs_trans_state_lockdep_acquire(owner, i)\t\t\t\t\\\n\trwsem_acquire_read(&owner->btrfs_state_change_map[i], 0, 0, _THIS_IP_)\n\n#define btrfs_trans_state_lockdep_release(owner, i)\t\t\t\t\\\n\trwsem_release(&owner->btrfs_state_change_map[i], _THIS_IP_)\n\n \n#define btrfs_lockdep_init_map(owner, lock)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\\\n\t\tstatic struct lock_class_key lock##_key;\t\t\t\\\n\t\tlockdep_init_map(&owner->lock##_map, #lock, &lock##_key, 0);\t\\\n\t} while (0)\n\n \n#define btrfs_state_lockdep_init_map(owner, lock, state)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\\\n\t\tstatic struct lock_class_key lock##_key;\t\t\t\\\n\t\tlockdep_init_map(&owner->btrfs_state_change_map[state], #lock,\t\\\n\t\t\t\t &lock##_key, 0);\t\t\t\t\\\n\t} while (0)\n\nstatic_assert(BTRFS_NESTING_MAX <= MAX_LOCKDEP_SUBCLASSES,\n\t      \"too many lock subclasses defined\");\n\nstruct btrfs_path;\n\nvoid __btrfs_tree_lock(struct extent_buffer *eb, enum btrfs_lock_nesting nest);\nvoid btrfs_tree_lock(struct extent_buffer *eb);\nvoid btrfs_tree_unlock(struct extent_buffer *eb);\n\nvoid __btrfs_tree_read_lock(struct extent_buffer *eb, enum btrfs_lock_nesting nest);\nvoid btrfs_tree_read_lock(struct extent_buffer *eb);\nvoid btrfs_tree_read_unlock(struct extent_buffer *eb);\nint btrfs_try_tree_read_lock(struct extent_buffer *eb);\nint btrfs_try_tree_write_lock(struct extent_buffer *eb);\nstruct extent_buffer *btrfs_lock_root_node(struct btrfs_root *root);\nstruct extent_buffer *btrfs_read_lock_root_node(struct btrfs_root *root);\nstruct extent_buffer *btrfs_try_read_lock_root_node(struct btrfs_root *root);\n\n#ifdef CONFIG_BTRFS_DEBUG\nstatic inline void btrfs_assert_tree_write_locked(struct extent_buffer *eb)\n{\n\tlockdep_assert_held_write(&eb->lock);\n}\n#else\nstatic inline void btrfs_assert_tree_write_locked(struct extent_buffer *eb) { }\n#endif\n\nvoid btrfs_unlock_up_safe(struct btrfs_path *path, int level);\n\nstatic inline void btrfs_tree_unlock_rw(struct extent_buffer *eb, int rw)\n{\n\tif (rw == BTRFS_WRITE_LOCK)\n\t\tbtrfs_tree_unlock(eb);\n\telse if (rw == BTRFS_READ_LOCK)\n\t\tbtrfs_tree_read_unlock(eb);\n\telse\n\t\tBUG();\n}\n\nstruct btrfs_drew_lock {\n\tatomic_t readers;\n\tatomic_t writers;\n\twait_queue_head_t pending_writers;\n\twait_queue_head_t pending_readers;\n};\n\nvoid btrfs_drew_lock_init(struct btrfs_drew_lock *lock);\nvoid btrfs_drew_write_lock(struct btrfs_drew_lock *lock);\nbool btrfs_drew_try_write_lock(struct btrfs_drew_lock *lock);\nvoid btrfs_drew_write_unlock(struct btrfs_drew_lock *lock);\nvoid btrfs_drew_read_lock(struct btrfs_drew_lock *lock);\nvoid btrfs_drew_read_unlock(struct btrfs_drew_lock *lock);\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nvoid btrfs_set_buffer_lockdep_class(u64 objectid, struct extent_buffer *eb, int level);\nvoid btrfs_maybe_reset_lockdep_class(struct btrfs_root *root, struct extent_buffer *eb);\n#else\nstatic inline void btrfs_set_buffer_lockdep_class(u64 objectid,\n\t\t\t\t\tstruct extent_buffer *eb, int level)\n{\n}\nstatic inline void btrfs_maybe_reset_lockdep_class(struct btrfs_root *root,\n\t\t\t\t\t\t   struct extent_buffer *eb)\n{\n}\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}