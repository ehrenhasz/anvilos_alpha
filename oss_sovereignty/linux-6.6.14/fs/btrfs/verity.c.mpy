{
  "module_name": "verity.c",
  "hash_id": "04f9cbac3c244b84e317bbce166f44f1065cdb516a974a055a7208c8378a4a5d",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/verity.c",
  "human_readable_source": "\n\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/iversion.h>\n#include <linux/fsverity.h>\n#include <linux/sched/mm.h>\n#include \"messages.h\"\n#include \"ctree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n#include \"ioctl.h\"\n#include \"verity.h\"\n#include \"orphan.h\"\n\n \n\n#define MERKLE_START_ALIGN\t\t\t65536\n\n \nstatic loff_t merkle_file_pos(const struct inode *inode)\n{\n\tu64 sz = inode->i_size;\n\tu64 rounded = round_up(sz, MERKLE_START_ALIGN);\n\n\tif (rounded > inode->i_sb->s_maxbytes)\n\t\treturn -EFBIG;\n\n\treturn rounded;\n}\n\n \nstatic int drop_verity_items(struct btrfs_inode *inode, u8 key_type)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint count = 0;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\t \n\t\ttrans = btrfs_start_transaction(root, 1);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tkey.objectid = btrfs_ino(inode);\n\t\tkey.type = key_type;\n\t\tkey.offset = (u64)-1;\n\n\t\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret > 0) {\n\t\t\tret = 0;\n\t\t\t \n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t} else if (ret < 0) {\n\t\t\tbtrfs_end_transaction(trans);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\t\t \n\t\tif (key.objectid != btrfs_ino(inode) || key.type != key_type)\n\t\t\tbreak;\n\n\t\t \n\t\tret = btrfs_del_items(trans, root, path, path->slots[0], 1);\n\t\tif (ret) {\n\t\t\tbtrfs_end_transaction(trans);\n\t\t\tgoto out;\n\t\t}\n\t\tcount++;\n\t\tbtrfs_release_path(path);\n\t\tbtrfs_end_transaction(trans);\n\t}\n\tret = count;\n\tbtrfs_end_transaction(trans);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nint btrfs_drop_verity_items(struct btrfs_inode *inode)\n{\n\tint ret;\n\n\tret = drop_verity_items(inode, BTRFS_VERITY_DESC_ITEM_KEY);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = drop_verity_items(inode, BTRFS_VERITY_MERKLE_ITEM_KEY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int write_key_bytes(struct btrfs_inode *inode, u8 key_type, u64 offset,\n\t\t\t   const char *src, u64 len)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = inode->root;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tunsigned long copy_bytes;\n\tunsigned long src_offset = 0;\n\tvoid *data;\n\tint ret = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (len > 0) {\n\t\t \n\t\ttrans = btrfs_start_transaction(root, 1);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tbreak;\n\t\t}\n\n\t\tkey.objectid = btrfs_ino(inode);\n\t\tkey.type = key_type;\n\t\tkey.offset = offset;\n\n\t\t \n\t\tcopy_bytes = min_t(u64, len, 2048);\n\n\t\tret = btrfs_insert_empty_item(trans, root, path, &key, copy_bytes);\n\t\tif (ret) {\n\t\t\tbtrfs_end_transaction(trans);\n\t\t\tbreak;\n\t\t}\n\n\t\tleaf = path->nodes[0];\n\n\t\tdata = btrfs_item_ptr(leaf, path->slots[0], void);\n\t\twrite_extent_buffer(leaf, src + src_offset,\n\t\t\t\t    (unsigned long)data, copy_bytes);\n\t\toffset += copy_bytes;\n\t\tsrc_offset += copy_bytes;\n\t\tlen -= copy_bytes;\n\n\t\tbtrfs_release_path(path);\n\t\tbtrfs_end_transaction(trans);\n\t}\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nstatic int read_key_bytes(struct btrfs_inode *inode, u8 key_type, u64 offset,\n\t\t\t  char *dest, u64 len, struct page *dest_page)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = inode->root;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tu64 item_end;\n\tu64 copy_end;\n\tint copied = 0;\n\tu32 copy_offset;\n\tunsigned long copy_bytes;\n\tunsigned long dest_offset = 0;\n\tvoid *data;\n\tchar *kaddr = dest;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (dest_page)\n\t\tpath->reada = READA_FORWARD;\n\n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = key_type;\n\tkey.offset = offset;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret > 0) {\n\t\tret = 0;\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto out;\n\t\tpath->slots[0]--;\n\t}\n\n\twhile (len > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\n\t\tif (key.objectid != btrfs_ino(inode) || key.type != key_type)\n\t\t\tbreak;\n\n\t\titem_end = btrfs_item_size(leaf, path->slots[0]) + key.offset;\n\n\t\tif (copied > 0) {\n\t\t\t \n\t\t\tif (key.offset != offset)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tif (key.offset > offset)\n\t\t\t\tbreak;\n\t\t\tif (item_end <= offset)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!dest)\n\t\t\tcopy_end = item_end;\n\t\telse\n\t\t\tcopy_end = min(offset + len, item_end);\n\n\t\t \n\t\tcopy_bytes = copy_end - offset;\n\n\t\t \n\t\tcopy_offset = offset - key.offset;\n\n\t\tif (dest) {\n\t\t\tif (dest_page)\n\t\t\t\tkaddr = kmap_local_page(dest_page);\n\n\t\t\tdata = btrfs_item_ptr(leaf, path->slots[0], void);\n\t\t\tread_extent_buffer(leaf, kaddr + dest_offset,\n\t\t\t\t\t   (unsigned long)data + copy_offset,\n\t\t\t\t\t   copy_bytes);\n\n\t\t\tif (dest_page)\n\t\t\t\tkunmap_local(kaddr);\n\t\t}\n\n\t\toffset += copy_bytes;\n\t\tdest_offset += copy_bytes;\n\t\tlen -= copy_bytes;\n\t\tcopied += copy_bytes;\n\n\t\tpath->slots[0]++;\n\t\tif (path->slots[0] >= btrfs_header_nritems(path->nodes[0])) {\n\t\t\t \n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tbreak;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tbtrfs_free_path(path);\n\tif (!ret)\n\t\tret = copied;\n\treturn ret;\n}\n\n \nstatic int del_orphan(struct btrfs_trans_handle *trans, struct btrfs_inode *inode)\n{\n\tstruct btrfs_root *root = inode->root;\n\tint ret;\n\n\t \n\tif (!inode->vfs_inode.i_nlink)\n\t\treturn 0;\n\n\tret = btrfs_del_orphan_item(trans, root, btrfs_ino(inode));\n\tif (ret == -ENOENT)\n\t\tret = 0;\n\treturn ret;\n}\n\n \nstatic int rollback_verity(struct btrfs_inode *inode)\n{\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_root *root = inode->root;\n\tint ret;\n\n\tASSERT(inode_is_locked(&inode->vfs_inode));\n\ttruncate_inode_pages(inode->vfs_inode.i_mapping, inode->vfs_inode.i_size);\n\tclear_bit(BTRFS_INODE_VERITY_IN_PROGRESS, &inode->runtime_flags);\n\tret = btrfs_drop_verity_items(inode);\n\tif (ret) {\n\t\tbtrfs_handle_fs_error(root->fs_info, ret,\n\t\t\t\t\"failed to drop verity items in rollback %llu\",\n\t\t\t\t(u64)inode->vfs_inode.i_ino);\n\t\tgoto out;\n\t}\n\n\t \n\ttrans = btrfs_start_transaction(root, 2);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\ttrans = NULL;\n\t\tbtrfs_handle_fs_error(root->fs_info, ret,\n\t\t\t\"failed to start transaction in verity rollback %llu\",\n\t\t\t(u64)inode->vfs_inode.i_ino);\n\t\tgoto out;\n\t}\n\tinode->ro_flags &= ~BTRFS_INODE_RO_VERITY;\n\tbtrfs_sync_inode_flags_to_i_flags(&inode->vfs_inode);\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\n\tret = del_orphan(trans, inode);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\nout:\n\tif (trans)\n\t\tbtrfs_end_transaction(trans);\n\treturn ret;\n}\n\n \nstatic int finish_verity(struct btrfs_inode *inode, const void *desc,\n\t\t\t size_t desc_size)\n{\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_verity_descriptor_item item;\n\tint ret;\n\n\t \n\tmemset(&item, 0, sizeof(item));\n\tbtrfs_set_stack_verity_descriptor_size(&item, desc_size);\n\tret = write_key_bytes(inode, BTRFS_VERITY_DESC_ITEM_KEY, 0,\n\t\t\t      (const char *)&item, sizeof(item));\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = write_key_bytes(inode, BTRFS_VERITY_DESC_ITEM_KEY, 1,\n\t\t\t      desc, desc_size);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\ttrans = btrfs_start_transaction(root, 2);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\tinode->ro_flags |= BTRFS_INODE_RO_VERITY;\n\tbtrfs_sync_inode_flags_to_i_flags(&inode->vfs_inode);\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret)\n\t\tgoto end_trans;\n\tret = del_orphan(trans, inode);\n\tif (ret)\n\t\tgoto end_trans;\n\tclear_bit(BTRFS_INODE_VERITY_IN_PROGRESS, &inode->runtime_flags);\n\tbtrfs_set_fs_compat_ro(root->fs_info, VERITY);\nend_trans:\n\tbtrfs_end_transaction(trans);\nout:\n\treturn ret;\n\n}\n\n \nstatic int btrfs_begin_enable_verity(struct file *filp)\n{\n\tstruct btrfs_inode *inode = BTRFS_I(file_inode(filp));\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tASSERT(inode_is_locked(file_inode(filp)));\n\n\tif (test_bit(BTRFS_INODE_VERITY_IN_PROGRESS, &inode->runtime_flags))\n\t\treturn -EBUSY;\n\n\t \n\tret = btrfs_drop_verity_items(inode);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttrans = btrfs_start_transaction(root, 1);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tret = btrfs_orphan_add(trans, inode);\n\tif (!ret)\n\t\tset_bit(BTRFS_INODE_VERITY_IN_PROGRESS, &inode->runtime_flags);\n\tbtrfs_end_transaction(trans);\n\n\treturn 0;\n}\n\n \nstatic int btrfs_end_enable_verity(struct file *filp, const void *desc,\n\t\t\t\t   size_t desc_size, u64 merkle_tree_size)\n{\n\tstruct btrfs_inode *inode = BTRFS_I(file_inode(filp));\n\tint ret = 0;\n\tint rollback_ret;\n\n\tASSERT(inode_is_locked(file_inode(filp)));\n\n\tif (desc == NULL)\n\t\tgoto rollback;\n\n\tret = finish_verity(inode, desc, desc_size);\n\tif (ret)\n\t\tgoto rollback;\n\treturn ret;\n\nrollback:\n\trollback_ret = rollback_verity(inode);\n\tif (rollback_ret)\n\t\tbtrfs_err(inode->root->fs_info,\n\t\t\t  \"failed to rollback verity items: %d\", rollback_ret);\n\treturn ret;\n}\n\n \nint btrfs_get_verity_descriptor(struct inode *inode, void *buf, size_t buf_size)\n{\n\tu64 true_size;\n\tint ret = 0;\n\tstruct btrfs_verity_descriptor_item item;\n\n\tmemset(&item, 0, sizeof(item));\n\tret = read_key_bytes(BTRFS_I(inode), BTRFS_VERITY_DESC_ITEM_KEY, 0,\n\t\t\t     (char *)&item, sizeof(item), NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (item.reserved[0] != 0 || item.reserved[1] != 0)\n\t\treturn -EUCLEAN;\n\n\ttrue_size = btrfs_stack_verity_descriptor_size(&item);\n\tif (true_size > INT_MAX)\n\t\treturn -EUCLEAN;\n\n\tif (buf_size == 0)\n\t\treturn true_size;\n\tif (buf_size < true_size)\n\t\treturn -ERANGE;\n\n\tret = read_key_bytes(BTRFS_I(inode), BTRFS_VERITY_DESC_ITEM_KEY, 1,\n\t\t\t     buf, buf_size, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != true_size)\n\t\treturn -EIO;\n\n\treturn true_size;\n}\n\n \nstatic struct page *btrfs_read_merkle_tree_page(struct inode *inode,\n\t\t\t\t\t\tpgoff_t index,\n\t\t\t\t\t\tunsigned long num_ra_pages)\n{\n\tstruct folio *folio;\n\tu64 off = (u64)index << PAGE_SHIFT;\n\tloff_t merkle_pos = merkle_file_pos(inode);\n\tint ret;\n\n\tif (merkle_pos < 0)\n\t\treturn ERR_PTR(merkle_pos);\n\tif (merkle_pos > inode->i_sb->s_maxbytes - off - PAGE_SIZE)\n\t\treturn ERR_PTR(-EFBIG);\n\tindex += merkle_pos >> PAGE_SHIFT;\nagain:\n\tfolio = __filemap_get_folio(inode->i_mapping, index, FGP_ACCESSED, 0);\n\tif (!IS_ERR(folio)) {\n\t\tif (folio_test_uptodate(folio))\n\t\t\tgoto out;\n\n\t\tfolio_lock(folio);\n\t\t \n\t\tif (!folio_test_uptodate(folio)) {\n\t\t\tfolio_unlock(folio);\n\t\t\tfolio_put(folio);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t\tfolio_unlock(folio);\n\t\tgoto out;\n\t}\n\n\tfolio = filemap_alloc_folio(mapping_gfp_constraint(inode->i_mapping, ~__GFP_FS),\n\t\t\t\t    0);\n\tif (!folio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = filemap_add_folio(inode->i_mapping, folio, index, GFP_NOFS);\n\tif (ret) {\n\t\tfolio_put(folio);\n\t\t \n\t\tif (ret == -EEXIST)\n\t\t\tgoto again;\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\tret = read_key_bytes(BTRFS_I(inode), BTRFS_VERITY_MERKLE_ITEM_KEY, off,\n\t\t\t     folio_address(folio), PAGE_SIZE, &folio->page);\n\tif (ret < 0) {\n\t\tfolio_put(folio);\n\t\treturn ERR_PTR(ret);\n\t}\n\tif (ret < PAGE_SIZE)\n\t\tfolio_zero_segment(folio, ret, PAGE_SIZE);\n\n\tfolio_mark_uptodate(folio);\n\tfolio_unlock(folio);\n\nout:\n\treturn folio_file_page(folio, index);\n}\n\n \nstatic int btrfs_write_merkle_tree_block(struct inode *inode, const void *buf,\n\t\t\t\t\t u64 pos, unsigned int size)\n{\n\tloff_t merkle_pos = merkle_file_pos(inode);\n\n\tif (merkle_pos < 0)\n\t\treturn merkle_pos;\n\tif (merkle_pos > inode->i_sb->s_maxbytes - pos - size)\n\t\treturn -EFBIG;\n\n\treturn write_key_bytes(BTRFS_I(inode), BTRFS_VERITY_MERKLE_ITEM_KEY,\n\t\t\t       pos, buf, size);\n}\n\nconst struct fsverity_operations btrfs_verityops = {\n\t.begin_enable_verity     = btrfs_begin_enable_verity,\n\t.end_enable_verity       = btrfs_end_enable_verity,\n\t.get_verity_descriptor   = btrfs_get_verity_descriptor,\n\t.read_merkle_tree_page   = btrfs_read_merkle_tree_page,\n\t.write_merkle_tree_block = btrfs_write_merkle_tree_block,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}