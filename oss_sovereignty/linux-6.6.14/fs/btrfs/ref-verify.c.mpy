{
  "module_name": "ref-verify.c",
  "hash_id": "359fb261c890a8829321133d3050fcfa6f8469ca0c83d3be80e215464829b434",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/ref-verify.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/stacktrace.h>\n#include \"messages.h\"\n#include \"ctree.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"ref-verify.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n\n \nstruct root_entry {\n\tu64 root_objectid;\n\tu64 num_refs;\n\tstruct rb_node node;\n};\n\n \nstruct ref_entry {\n\tu64 root_objectid;\n\tu64 parent;\n\tu64 owner;\n\tu64 offset;\n\tu64 num_refs;\n\tstruct rb_node node;\n};\n\n#define MAX_TRACE\t16\n\n \nstruct ref_action {\n\tint action;\n\tu64 root;\n\tstruct ref_entry ref;\n\tstruct list_head list;\n\tunsigned long trace[MAX_TRACE];\n\tunsigned int trace_len;\n};\n\n \nstruct block_entry {\n\tu64 bytenr;\n\tu64 len;\n\tu64 num_refs;\n\tint metadata;\n\tint from_disk;\n\tstruct rb_root roots;\n\tstruct rb_root refs;\n\tstruct rb_node node;\n\tstruct list_head actions;\n};\n\nstatic struct block_entry *insert_block_entry(struct rb_root *root,\n\t\t\t\t\t      struct block_entry *be)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct block_entry *entry;\n\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\tentry = rb_entry(parent_node, struct block_entry, node);\n\t\tif (entry->bytenr > be->bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (entry->bytenr < be->bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\n\trb_link_node(&be->node, parent_node, p);\n\trb_insert_color(&be->node, root);\n\treturn NULL;\n}\n\nstatic struct block_entry *lookup_block_entry(struct rb_root *root, u64 bytenr)\n{\n\tstruct rb_node *n;\n\tstruct block_entry *entry = NULL;\n\n\tn = root->rb_node;\n\twhile (n) {\n\t\tentry = rb_entry(n, struct block_entry, node);\n\t\tif (entry->bytenr < bytenr)\n\t\t\tn = n->rb_right;\n\t\telse if (entry->bytenr > bytenr)\n\t\t\tn = n->rb_left;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}\n\nstatic struct root_entry *insert_root_entry(struct rb_root *root,\n\t\t\t\t\t    struct root_entry *re)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct root_entry *entry;\n\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\tentry = rb_entry(parent_node, struct root_entry, node);\n\t\tif (entry->root_objectid > re->root_objectid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (entry->root_objectid < re->root_objectid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\n\trb_link_node(&re->node, parent_node, p);\n\trb_insert_color(&re->node, root);\n\treturn NULL;\n\n}\n\nstatic int comp_refs(struct ref_entry *ref1, struct ref_entry *ref2)\n{\n\tif (ref1->root_objectid < ref2->root_objectid)\n\t\treturn -1;\n\tif (ref1->root_objectid > ref2->root_objectid)\n\t\treturn 1;\n\tif (ref1->parent < ref2->parent)\n\t\treturn -1;\n\tif (ref1->parent > ref2->parent)\n\t\treturn 1;\n\tif (ref1->owner < ref2->owner)\n\t\treturn -1;\n\tif (ref1->owner > ref2->owner)\n\t\treturn 1;\n\tif (ref1->offset < ref2->offset)\n\t\treturn -1;\n\tif (ref1->offset > ref2->offset)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic struct ref_entry *insert_ref_entry(struct rb_root *root,\n\t\t\t\t\t  struct ref_entry *ref)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct ref_entry *entry;\n\tint cmp;\n\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\tentry = rb_entry(parent_node, struct ref_entry, node);\n\t\tcmp = comp_refs(entry, ref);\n\t\tif (cmp > 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp < 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\n\trb_link_node(&ref->node, parent_node, p);\n\trb_insert_color(&ref->node, root);\n\treturn NULL;\n\n}\n\nstatic struct root_entry *lookup_root_entry(struct rb_root *root, u64 objectid)\n{\n\tstruct rb_node *n;\n\tstruct root_entry *entry = NULL;\n\n\tn = root->rb_node;\n\twhile (n) {\n\t\tentry = rb_entry(n, struct root_entry, node);\n\t\tif (entry->root_objectid < objectid)\n\t\t\tn = n->rb_right;\n\t\telse if (entry->root_objectid > objectid)\n\t\t\tn = n->rb_left;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}\n\n#ifdef CONFIG_STACKTRACE\nstatic void __save_stack_trace(struct ref_action *ra)\n{\n\tra->trace_len = stack_trace_save(ra->trace, MAX_TRACE, 2);\n}\n\nstatic void __print_stack_trace(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct ref_action *ra)\n{\n\tif (ra->trace_len == 0) {\n\t\tbtrfs_err(fs_info, \"  ref-verify: no stacktrace\");\n\t\treturn;\n\t}\n\tstack_trace_print(ra->trace, ra->trace_len, 2);\n}\n#else\nstatic inline void __save_stack_trace(struct ref_action *ra)\n{\n}\n\nstatic inline void __print_stack_trace(struct btrfs_fs_info *fs_info,\n\t\t\t\t       struct ref_action *ra)\n{\n\tbtrfs_err(fs_info, \"  ref-verify: no stacktrace support\");\n}\n#endif\n\nstatic void free_block_entry(struct block_entry *be)\n{\n\tstruct root_entry *re;\n\tstruct ref_entry *ref;\n\tstruct ref_action *ra;\n\tstruct rb_node *n;\n\n\twhile ((n = rb_first(&be->roots))) {\n\t\tre = rb_entry(n, struct root_entry, node);\n\t\trb_erase(&re->node, &be->roots);\n\t\tkfree(re);\n\t}\n\n\twhile((n = rb_first(&be->refs))) {\n\t\tref = rb_entry(n, struct ref_entry, node);\n\t\trb_erase(&ref->node, &be->refs);\n\t\tkfree(ref);\n\t}\n\n\twhile (!list_empty(&be->actions)) {\n\t\tra = list_first_entry(&be->actions, struct ref_action,\n\t\t\t\t      list);\n\t\tlist_del(&ra->list);\n\t\tkfree(ra);\n\t}\n\tkfree(be);\n}\n\nstatic struct block_entry *add_block_entry(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 bytenr, u64 len,\n\t\t\t\t\t   u64 root_objectid)\n{\n\tstruct block_entry *be = NULL, *exist;\n\tstruct root_entry *re = NULL;\n\n\tre = kzalloc(sizeof(struct root_entry), GFP_NOFS);\n\tbe = kzalloc(sizeof(struct block_entry), GFP_NOFS);\n\tif (!be || !re) {\n\t\tkfree(re);\n\t\tkfree(be);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tbe->bytenr = bytenr;\n\tbe->len = len;\n\n\tre->root_objectid = root_objectid;\n\tre->num_refs = 0;\n\n\tspin_lock(&fs_info->ref_verify_lock);\n\texist = insert_block_entry(&fs_info->block_tree, be);\n\tif (exist) {\n\t\tif (root_objectid) {\n\t\t\tstruct root_entry *exist_re;\n\n\t\t\texist_re = insert_root_entry(&exist->roots, re);\n\t\t\tif (exist_re)\n\t\t\t\tkfree(re);\n\t\t} else {\n\t\t\tkfree(re);\n\t\t}\n\t\tkfree(be);\n\t\treturn exist;\n\t}\n\n\tbe->num_refs = 0;\n\tbe->metadata = 0;\n\tbe->from_disk = 0;\n\tbe->roots = RB_ROOT;\n\tbe->refs = RB_ROOT;\n\tINIT_LIST_HEAD(&be->actions);\n\tif (root_objectid)\n\t\tinsert_root_entry(&be->roots, re);\n\telse\n\t\tkfree(re);\n\treturn be;\n}\n\nstatic int add_tree_block(struct btrfs_fs_info *fs_info, u64 ref_root,\n\t\t\t  u64 parent, u64 bytenr, int level)\n{\n\tstruct block_entry *be;\n\tstruct root_entry *re;\n\tstruct ref_entry *ref = NULL, *exist;\n\n\tref = kmalloc(sizeof(struct ref_entry), GFP_NOFS);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\tif (parent)\n\t\tref->root_objectid = 0;\n\telse\n\t\tref->root_objectid = ref_root;\n\tref->parent = parent;\n\tref->owner = level;\n\tref->offset = 0;\n\tref->num_refs = 1;\n\n\tbe = add_block_entry(fs_info, bytenr, fs_info->nodesize, ref_root);\n\tif (IS_ERR(be)) {\n\t\tkfree(ref);\n\t\treturn PTR_ERR(be);\n\t}\n\tbe->num_refs++;\n\tbe->from_disk = 1;\n\tbe->metadata = 1;\n\n\tif (!parent) {\n\t\tASSERT(ref_root);\n\t\tre = lookup_root_entry(&be->roots, ref_root);\n\t\tASSERT(re);\n\t\tre->num_refs++;\n\t}\n\texist = insert_ref_entry(&be->refs, ref);\n\tif (exist) {\n\t\texist->num_refs++;\n\t\tkfree(ref);\n\t}\n\tspin_unlock(&fs_info->ref_verify_lock);\n\n\treturn 0;\n}\n\nstatic int add_shared_data_ref(struct btrfs_fs_info *fs_info,\n\t\t\t       u64 parent, u32 num_refs, u64 bytenr,\n\t\t\t       u64 num_bytes)\n{\n\tstruct block_entry *be;\n\tstruct ref_entry *ref;\n\n\tref = kzalloc(sizeof(struct ref_entry), GFP_NOFS);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\tbe = add_block_entry(fs_info, bytenr, num_bytes, 0);\n\tif (IS_ERR(be)) {\n\t\tkfree(ref);\n\t\treturn PTR_ERR(be);\n\t}\n\tbe->num_refs += num_refs;\n\n\tref->parent = parent;\n\tref->num_refs = num_refs;\n\tif (insert_ref_entry(&be->refs, ref)) {\n\t\tspin_unlock(&fs_info->ref_verify_lock);\n\t\tbtrfs_err(fs_info, \"existing shared ref when reading from disk?\");\n\t\tkfree(ref);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock(&fs_info->ref_verify_lock);\n\treturn 0;\n}\n\nstatic int add_extent_data_ref(struct btrfs_fs_info *fs_info,\n\t\t\t       struct extent_buffer *leaf,\n\t\t\t       struct btrfs_extent_data_ref *dref,\n\t\t\t       u64 bytenr, u64 num_bytes)\n{\n\tstruct block_entry *be;\n\tstruct ref_entry *ref;\n\tstruct root_entry *re;\n\tu64 ref_root = btrfs_extent_data_ref_root(leaf, dref);\n\tu64 owner = btrfs_extent_data_ref_objectid(leaf, dref);\n\tu64 offset = btrfs_extent_data_ref_offset(leaf, dref);\n\tu32 num_refs = btrfs_extent_data_ref_count(leaf, dref);\n\n\tref = kzalloc(sizeof(struct ref_entry), GFP_NOFS);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\tbe = add_block_entry(fs_info, bytenr, num_bytes, ref_root);\n\tif (IS_ERR(be)) {\n\t\tkfree(ref);\n\t\treturn PTR_ERR(be);\n\t}\n\tbe->num_refs += num_refs;\n\n\tref->parent = 0;\n\tref->owner = owner;\n\tref->root_objectid = ref_root;\n\tref->offset = offset;\n\tref->num_refs = num_refs;\n\tif (insert_ref_entry(&be->refs, ref)) {\n\t\tspin_unlock(&fs_info->ref_verify_lock);\n\t\tbtrfs_err(fs_info, \"existing ref when reading from disk?\");\n\t\tkfree(ref);\n\t\treturn -EINVAL;\n\t}\n\n\tre = lookup_root_entry(&be->roots, ref_root);\n\tif (!re) {\n\t\tspin_unlock(&fs_info->ref_verify_lock);\n\t\tbtrfs_err(fs_info, \"missing root in new block entry?\");\n\t\treturn -EINVAL;\n\t}\n\tre->num_refs += num_refs;\n\tspin_unlock(&fs_info->ref_verify_lock);\n\treturn 0;\n}\n\nstatic int process_extent_item(struct btrfs_fs_info *fs_info,\n\t\t\t       struct btrfs_path *path, struct btrfs_key *key,\n\t\t\t       int slot, int *tree_block_level)\n{\n\tstruct btrfs_extent_item *ei;\n\tstruct btrfs_extent_inline_ref *iref;\n\tstruct btrfs_extent_data_ref *dref;\n\tstruct btrfs_shared_data_ref *sref;\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tu32 item_size = btrfs_item_size(leaf, slot);\n\tunsigned long end, ptr;\n\tu64 offset, flags, count;\n\tint type, ret;\n\n\tei = btrfs_item_ptr(leaf, slot, struct btrfs_extent_item);\n\tflags = btrfs_extent_flags(leaf, ei);\n\n\tif ((key->type == BTRFS_EXTENT_ITEM_KEY) &&\n\t    flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tstruct btrfs_tree_block_info *info;\n\n\t\tinfo = (struct btrfs_tree_block_info *)(ei + 1);\n\t\t*tree_block_level = btrfs_tree_block_level(leaf, info);\n\t\tiref = (struct btrfs_extent_inline_ref *)(info + 1);\n\t} else {\n\t\tif (key->type == BTRFS_METADATA_ITEM_KEY)\n\t\t\t*tree_block_level = key->offset;\n\t\tiref = (struct btrfs_extent_inline_ref *)(ei + 1);\n\t}\n\n\tptr = (unsigned long)iref;\n\tend = (unsigned long)ei + item_size;\n\twhile (ptr < end) {\n\t\tiref = (struct btrfs_extent_inline_ref *)ptr;\n\t\ttype = btrfs_extent_inline_ref_type(leaf, iref);\n\t\toffset = btrfs_extent_inline_ref_offset(leaf, iref);\n\t\tswitch (type) {\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\t\tret = add_tree_block(fs_info, offset, 0, key->objectid,\n\t\t\t\t\t     *tree_block_level);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tret = add_tree_block(fs_info, 0, offset, key->objectid,\n\t\t\t\t\t     *tree_block_level);\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\t\tdref = (struct btrfs_extent_data_ref *)(&iref->offset);\n\t\t\tret = add_extent_data_ref(fs_info, leaf, dref,\n\t\t\t\t\t\t  key->objectid, key->offset);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tsref = (struct btrfs_shared_data_ref *)(iref + 1);\n\t\t\tcount = btrfs_shared_data_ref_count(leaf, sref);\n\t\t\tret = add_shared_data_ref(fs_info, offset, count,\n\t\t\t\t\t\t  key->objectid, key->offset);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbtrfs_err(fs_info, \"invalid key type in iref\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t\tptr += btrfs_extent_inline_ref_size(type);\n\t}\n\treturn ret;\n}\n\nstatic int process_leaf(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 *bytenr, u64 *num_bytes,\n\t\t\tint *tree_block_level)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tstruct btrfs_extent_data_ref *dref;\n\tstruct btrfs_shared_data_ref *sref;\n\tu32 count;\n\tint i = 0, ret = 0;\n\tstruct btrfs_key key;\n\tint nritems = btrfs_header_nritems(leaf);\n\n\tfor (i = 0; i < nritems; i++) {\n\t\tbtrfs_item_key_to_cpu(leaf, &key, i);\n\t\tswitch (key.type) {\n\t\tcase BTRFS_EXTENT_ITEM_KEY:\n\t\t\t*num_bytes = key.offset;\n\t\t\tfallthrough;\n\t\tcase BTRFS_METADATA_ITEM_KEY:\n\t\t\t*bytenr = key.objectid;\n\t\t\tret = process_extent_item(fs_info, path, &key, i,\n\t\t\t\t\t\t  tree_block_level);\n\t\t\tbreak;\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\t\tret = add_tree_block(fs_info, key.offset, 0,\n\t\t\t\t\t     key.objectid, *tree_block_level);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tret = add_tree_block(fs_info, 0, key.offset,\n\t\t\t\t\t     key.objectid, *tree_block_level);\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\t\tdref = btrfs_item_ptr(leaf, i,\n\t\t\t\t\t      struct btrfs_extent_data_ref);\n\t\t\tret = add_extent_data_ref(fs_info, leaf, dref, *bytenr,\n\t\t\t\t\t\t  *num_bytes);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tsref = btrfs_item_ptr(leaf, i,\n\t\t\t\t\t      struct btrfs_shared_data_ref);\n\t\t\tcount = btrfs_shared_data_ref_count(leaf, sref);\n\t\t\tret = add_shared_data_ref(fs_info, key.offset, count,\n\t\t\t\t\t\t  *bytenr, *num_bytes);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nstatic int walk_down_tree(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t  int level, u64 *bytenr, u64 *num_bytes,\n\t\t\t  int *tree_block_level)\n{\n\tstruct extent_buffer *eb;\n\tint ret = 0;\n\n\twhile (level >= 0) {\n\t\tif (level) {\n\t\t\teb = btrfs_read_node_slot(path->nodes[level],\n\t\t\t\t\t\t  path->slots[level]);\n\t\t\tif (IS_ERR(eb))\n\t\t\t\treturn PTR_ERR(eb);\n\t\t\tbtrfs_tree_read_lock(eb);\n\t\t\tpath->nodes[level-1] = eb;\n\t\t\tpath->slots[level-1] = 0;\n\t\t\tpath->locks[level-1] = BTRFS_READ_LOCK;\n\t\t} else {\n\t\t\tret = process_leaf(root, path, bytenr, num_bytes,\n\t\t\t\t\t   tree_block_level);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tlevel--;\n\t}\n\treturn ret;\n}\n\n \nstatic int walk_up_tree(struct btrfs_path *path, int *level)\n{\n\tint l;\n\n\tfor (l = 0; l < BTRFS_MAX_LEVEL; l++) {\n\t\tif (!path->nodes[l])\n\t\t\tcontinue;\n\t\tif (l) {\n\t\t\tpath->slots[l]++;\n\t\t\tif (path->slots[l] <\n\t\t\t    btrfs_header_nritems(path->nodes[l])) {\n\t\t\t\t*level = l;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbtrfs_tree_unlock_rw(path->nodes[l], path->locks[l]);\n\t\tfree_extent_buffer(path->nodes[l]);\n\t\tpath->nodes[l] = NULL;\n\t\tpath->slots[l] = 0;\n\t\tpath->locks[l] = 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void dump_ref_action(struct btrfs_fs_info *fs_info,\n\t\t\t    struct ref_action *ra)\n{\n\tbtrfs_err(fs_info,\n\"  Ref action %d, root %llu, ref_root %llu, parent %llu, owner %llu, offset %llu, num_refs %llu\",\n\t\t  ra->action, ra->root, ra->ref.root_objectid, ra->ref.parent,\n\t\t  ra->ref.owner, ra->ref.offset, ra->ref.num_refs);\n\t__print_stack_trace(fs_info, ra);\n}\n\n \nstatic void dump_block_entry(struct btrfs_fs_info *fs_info,\n\t\t\t     struct block_entry *be)\n{\n\tstruct ref_entry *ref;\n\tstruct root_entry *re;\n\tstruct ref_action *ra;\n\tstruct rb_node *n;\n\n\tbtrfs_err(fs_info,\n\"dumping block entry [%llu %llu], num_refs %llu, metadata %d, from disk %d\",\n\t\t  be->bytenr, be->len, be->num_refs, be->metadata,\n\t\t  be->from_disk);\n\n\tfor (n = rb_first(&be->refs); n; n = rb_next(n)) {\n\t\tref = rb_entry(n, struct ref_entry, node);\n\t\tbtrfs_err(fs_info,\n\"  ref root %llu, parent %llu, owner %llu, offset %llu, num_refs %llu\",\n\t\t\t  ref->root_objectid, ref->parent, ref->owner,\n\t\t\t  ref->offset, ref->num_refs);\n\t}\n\n\tfor (n = rb_first(&be->roots); n; n = rb_next(n)) {\n\t\tre = rb_entry(n, struct root_entry, node);\n\t\tbtrfs_err(fs_info, \"  root entry %llu, num_refs %llu\",\n\t\t\t  re->root_objectid, re->num_refs);\n\t}\n\n\tlist_for_each_entry(ra, &be->actions, list)\n\t\tdump_ref_action(fs_info, ra);\n}\n\n \nint btrfs_ref_tree_mod(struct btrfs_fs_info *fs_info,\n\t\t       struct btrfs_ref *generic_ref)\n{\n\tstruct ref_entry *ref = NULL, *exist;\n\tstruct ref_action *ra = NULL;\n\tstruct block_entry *be = NULL;\n\tstruct root_entry *re = NULL;\n\tint action = generic_ref->action;\n\tint ret = 0;\n\tbool metadata;\n\tu64 bytenr = generic_ref->bytenr;\n\tu64 num_bytes = generic_ref->len;\n\tu64 parent = generic_ref->parent;\n\tu64 ref_root = 0;\n\tu64 owner = 0;\n\tu64 offset = 0;\n\n\tif (!btrfs_test_opt(fs_info, REF_VERIFY))\n\t\treturn 0;\n\n\tif (generic_ref->type == BTRFS_REF_METADATA) {\n\t\tif (!parent)\n\t\t\tref_root = generic_ref->tree_ref.owning_root;\n\t\towner = generic_ref->tree_ref.level;\n\t} else if (!parent) {\n\t\tref_root = generic_ref->data_ref.owning_root;\n\t\towner = generic_ref->data_ref.ino;\n\t\toffset = generic_ref->data_ref.offset;\n\t}\n\tmetadata = owner < BTRFS_FIRST_FREE_OBJECTID;\n\n\tref = kzalloc(sizeof(struct ref_entry), GFP_NOFS);\n\tra = kmalloc(sizeof(struct ref_action), GFP_NOFS);\n\tif (!ra || !ref) {\n\t\tkfree(ref);\n\t\tkfree(ra);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tref->parent = parent;\n\tref->owner = owner;\n\tref->root_objectid = ref_root;\n\tref->offset = offset;\n\tref->num_refs = (action == BTRFS_DROP_DELAYED_REF) ? -1 : 1;\n\n\tmemcpy(&ra->ref, ref, sizeof(struct ref_entry));\n\t \n\tra->ref.owner = owner;\n\tra->ref.offset = offset;\n\tra->ref.root_objectid = ref_root;\n\t__save_stack_trace(ra);\n\n\tINIT_LIST_HEAD(&ra->list);\n\tra->action = action;\n\tra->root = generic_ref->real_root;\n\n\t \n\tret = -EINVAL;\n\tif (action == BTRFS_ADD_DELAYED_EXTENT) {\n\t\t \n\t\tbe = add_block_entry(fs_info, bytenr, num_bytes, ref_root);\n\t\tif (IS_ERR(be)) {\n\t\t\tkfree(ref);\n\t\t\tkfree(ra);\n\t\t\tret = PTR_ERR(be);\n\t\t\tgoto out;\n\t\t}\n\t\tbe->num_refs++;\n\t\tif (metadata)\n\t\t\tbe->metadata = 1;\n\n\t\tif (be->num_refs != 1) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\"re-allocated a block that still has references to it!\");\n\t\t\tdump_block_entry(fs_info, be);\n\t\t\tdump_ref_action(fs_info, ra);\n\t\t\tkfree(ref);\n\t\t\tkfree(ra);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\twhile (!list_empty(&be->actions)) {\n\t\t\tstruct ref_action *tmp;\n\n\t\t\ttmp = list_first_entry(&be->actions, struct ref_action,\n\t\t\t\t\t       list);\n\t\t\tlist_del(&tmp->list);\n\t\t\tkfree(tmp);\n\t\t}\n\t} else {\n\t\tstruct root_entry *tmp;\n\n\t\tif (!parent) {\n\t\t\tre = kmalloc(sizeof(struct root_entry), GFP_NOFS);\n\t\t\tif (!re) {\n\t\t\t\tkfree(ref);\n\t\t\t\tkfree(ra);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\tref_root = generic_ref->real_root;\n\t\t\tre->root_objectid = generic_ref->real_root;\n\t\t\tre->num_refs = 0;\n\t\t}\n\n\t\tspin_lock(&fs_info->ref_verify_lock);\n\t\tbe = lookup_block_entry(&fs_info->block_tree, bytenr);\n\t\tif (!be) {\n\t\t\tbtrfs_err(fs_info,\n\"trying to do action %d to bytenr %llu num_bytes %llu but there is no existing entry!\",\n\t\t\t\t  action, bytenr, num_bytes);\n\t\t\tdump_ref_action(fs_info, ra);\n\t\t\tkfree(ref);\n\t\t\tkfree(ra);\n\t\t\tkfree(re);\n\t\t\tgoto out_unlock;\n\t\t} else if (be->num_refs == 0) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\"trying to do action %d for a bytenr that has 0 total references\",\n\t\t\t\taction);\n\t\t\tdump_block_entry(fs_info, be);\n\t\t\tdump_ref_action(fs_info, ra);\n\t\t\tkfree(ref);\n\t\t\tkfree(ra);\n\t\t\tkfree(re);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (!parent) {\n\t\t\ttmp = insert_root_entry(&be->roots, re);\n\t\t\tif (tmp) {\n\t\t\t\tkfree(re);\n\t\t\t\tre = tmp;\n\t\t\t}\n\t\t}\n\t}\n\n\texist = insert_ref_entry(&be->refs, ref);\n\tif (exist) {\n\t\tif (action == BTRFS_DROP_DELAYED_REF) {\n\t\t\tif (exist->num_refs == 0) {\n\t\t\t\tbtrfs_err(fs_info,\n\"dropping a ref for a existing root that doesn't have a ref on the block\");\n\t\t\t\tdump_block_entry(fs_info, be);\n\t\t\t\tdump_ref_action(fs_info, ra);\n\t\t\t\tkfree(ref);\n\t\t\t\tkfree(ra);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\texist->num_refs--;\n\t\t\tif (exist->num_refs == 0) {\n\t\t\t\trb_erase(&exist->node, &be->refs);\n\t\t\t\tkfree(exist);\n\t\t\t}\n\t\t} else if (!be->metadata) {\n\t\t\texist->num_refs++;\n\t\t} else {\n\t\t\tbtrfs_err(fs_info,\n\"attempting to add another ref for an existing ref on a tree block\");\n\t\t\tdump_block_entry(fs_info, be);\n\t\t\tdump_ref_action(fs_info, ra);\n\t\t\tkfree(ref);\n\t\t\tkfree(ra);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tkfree(ref);\n\t} else {\n\t\tif (action == BTRFS_DROP_DELAYED_REF) {\n\t\t\tbtrfs_err(fs_info,\n\"dropping a ref for a root that doesn't have a ref on the block\");\n\t\t\tdump_block_entry(fs_info, be);\n\t\t\tdump_ref_action(fs_info, ra);\n\t\t\tkfree(ref);\n\t\t\tkfree(ra);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (!parent && !re) {\n\t\tre = lookup_root_entry(&be->roots, ref_root);\n\t\tif (!re) {\n\t\t\t \n\t\t\tbtrfs_err(fs_info, \"failed to find root %llu for %llu\",\n\t\t\t\t  generic_ref->real_root, be->bytenr);\n\t\t\tdump_block_entry(fs_info, be);\n\t\t\tdump_ref_action(fs_info, ra);\n\t\t\tkfree(ra);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tif (action == BTRFS_DROP_DELAYED_REF) {\n\t\tif (re)\n\t\t\tre->num_refs--;\n\t\tbe->num_refs--;\n\t} else if (action == BTRFS_ADD_DELAYED_REF) {\n\t\tbe->num_refs++;\n\t\tif (re)\n\t\t\tre->num_refs++;\n\t}\n\tlist_add_tail(&ra->list, &be->actions);\n\tret = 0;\nout_unlock:\n\tspin_unlock(&fs_info->ref_verify_lock);\nout:\n\tif (ret)\n\t\tbtrfs_clear_opt(fs_info->mount_opt, REF_VERIFY);\n\treturn ret;\n}\n\n \nvoid btrfs_free_ref_cache(struct btrfs_fs_info *fs_info)\n{\n\tstruct block_entry *be;\n\tstruct rb_node *n;\n\n\tif (!btrfs_test_opt(fs_info, REF_VERIFY))\n\t\treturn;\n\n\tspin_lock(&fs_info->ref_verify_lock);\n\twhile ((n = rb_first(&fs_info->block_tree))) {\n\t\tbe = rb_entry(n, struct block_entry, node);\n\t\trb_erase(&be->node, &fs_info->block_tree);\n\t\tfree_block_entry(be);\n\t\tcond_resched_lock(&fs_info->ref_verify_lock);\n\t}\n\tspin_unlock(&fs_info->ref_verify_lock);\n}\n\nvoid btrfs_free_ref_tree_range(struct btrfs_fs_info *fs_info, u64 start,\n\t\t\t       u64 len)\n{\n\tstruct block_entry *be = NULL, *entry;\n\tstruct rb_node *n;\n\n\tif (!btrfs_test_opt(fs_info, REF_VERIFY))\n\t\treturn;\n\n\tspin_lock(&fs_info->ref_verify_lock);\n\tn = fs_info->block_tree.rb_node;\n\twhile (n) {\n\t\tentry = rb_entry(n, struct block_entry, node);\n\t\tif (entry->bytenr < start) {\n\t\t\tn = n->rb_right;\n\t\t} else if (entry->bytenr > start) {\n\t\t\tn = n->rb_left;\n\t\t} else {\n\t\t\tbe = entry;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (be == NULL ||\n\t\t    (entry->bytenr < start && be->bytenr > start) ||\n\t\t    (entry->bytenr < start && entry->bytenr > be->bytenr))\n\t\t\tbe = entry;\n\t}\n\n\t \n\tif (!be) {\n\t\tspin_unlock(&fs_info->ref_verify_lock);\n\t\treturn;\n\t}\n\n\tn = &be->node;\n\twhile (n) {\n\t\tbe = rb_entry(n, struct block_entry, node);\n\t\tn = rb_next(n);\n\t\tif (be->bytenr < start && be->bytenr + be->len > start) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\"block entry overlaps a block group [%llu,%llu]!\",\n\t\t\t\tstart, len);\n\t\t\tdump_block_entry(fs_info, be);\n\t\t\tcontinue;\n\t\t}\n\t\tif (be->bytenr < start)\n\t\t\tcontinue;\n\t\tif (be->bytenr >= start + len)\n\t\t\tbreak;\n\t\tif (be->bytenr + be->len > start + len) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\"block entry overlaps a block group [%llu,%llu]!\",\n\t\t\t\tstart, len);\n\t\t\tdump_block_entry(fs_info, be);\n\t\t}\n\t\trb_erase(&be->node, &fs_info->block_tree);\n\t\tfree_block_entry(be);\n\t}\n\tspin_unlock(&fs_info->ref_verify_lock);\n}\n\n \nint btrfs_build_ref_tree(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *extent_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *eb;\n\tint tree_block_level = 0;\n\tu64 bytenr = 0, num_bytes = 0;\n\tint ret, level;\n\n\tif (!btrfs_test_opt(fs_info, REF_VERIFY))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\textent_root = btrfs_extent_root(fs_info, 0);\n\teb = btrfs_read_lock_root_node(extent_root);\n\tlevel = btrfs_header_level(eb);\n\tpath->nodes[level] = eb;\n\tpath->slots[level] = 0;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\twhile (1) {\n\t\t \n\t\tret = walk_down_tree(extent_root, path, level,\n\t\t\t\t     &bytenr, &num_bytes, &tree_block_level);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = walk_up_tree(path, &level);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret) {\n\t\tbtrfs_clear_opt(fs_info->mount_opt, REF_VERIFY);\n\t\tbtrfs_free_ref_cache(fs_info);\n\t}\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}