{
  "module_name": "block-rsv.c",
  "hash_id": "3168c91f96ebc31609eadce24a3a18728a8cb776bd3dffd841f5c20a85dfedbc",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/block-rsv.c",
  "human_readable_source": "\n\n#include \"misc.h\"\n#include \"ctree.h\"\n#include \"block-rsv.h\"\n#include \"space-info.h\"\n#include \"transaction.h\"\n#include \"block-group.h\"\n#include \"disk-io.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n\n \n\nstatic u64 block_rsv_release_bytes(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct btrfs_block_rsv *block_rsv,\n\t\t\t\t    struct btrfs_block_rsv *dest, u64 num_bytes,\n\t\t\t\t    u64 *qgroup_to_release_ret)\n{\n\tstruct btrfs_space_info *space_info = block_rsv->space_info;\n\tu64 qgroup_to_release = 0;\n\tu64 ret;\n\n\tspin_lock(&block_rsv->lock);\n\tif (num_bytes == (u64)-1) {\n\t\tnum_bytes = block_rsv->size;\n\t\tqgroup_to_release = block_rsv->qgroup_rsv_size;\n\t}\n\tblock_rsv->size -= num_bytes;\n\tif (block_rsv->reserved >= block_rsv->size) {\n\t\tnum_bytes = block_rsv->reserved - block_rsv->size;\n\t\tblock_rsv->reserved = block_rsv->size;\n\t\tblock_rsv->full = true;\n\t} else {\n\t\tnum_bytes = 0;\n\t}\n\tif (qgroup_to_release_ret &&\n\t    block_rsv->qgroup_rsv_reserved >= block_rsv->qgroup_rsv_size) {\n\t\tqgroup_to_release = block_rsv->qgroup_rsv_reserved -\n\t\t\t\t    block_rsv->qgroup_rsv_size;\n\t\tblock_rsv->qgroup_rsv_reserved = block_rsv->qgroup_rsv_size;\n\t} else {\n\t\tqgroup_to_release = 0;\n\t}\n\tspin_unlock(&block_rsv->lock);\n\n\tret = num_bytes;\n\tif (num_bytes > 0) {\n\t\tif (dest) {\n\t\t\tspin_lock(&dest->lock);\n\t\t\tif (!dest->full) {\n\t\t\t\tu64 bytes_to_add;\n\n\t\t\t\tbytes_to_add = dest->size - dest->reserved;\n\t\t\t\tbytes_to_add = min(num_bytes, bytes_to_add);\n\t\t\t\tdest->reserved += bytes_to_add;\n\t\t\t\tif (dest->reserved >= dest->size)\n\t\t\t\t\tdest->full = true;\n\t\t\t\tnum_bytes -= bytes_to_add;\n\t\t\t}\n\t\t\tspin_unlock(&dest->lock);\n\t\t}\n\t\tif (num_bytes)\n\t\t\tbtrfs_space_info_free_bytes_may_use(fs_info,\n\t\t\t\t\t\t\t    space_info,\n\t\t\t\t\t\t\t    num_bytes);\n\t}\n\tif (qgroup_to_release_ret)\n\t\t*qgroup_to_release_ret = qgroup_to_release;\n\treturn ret;\n}\n\nint btrfs_block_rsv_migrate(struct btrfs_block_rsv *src,\n\t\t\t    struct btrfs_block_rsv *dst, u64 num_bytes,\n\t\t\t    bool update_size)\n{\n\tint ret;\n\n\tret = btrfs_block_rsv_use_bytes(src, num_bytes);\n\tif (ret)\n\t\treturn ret;\n\n\tbtrfs_block_rsv_add_bytes(dst, num_bytes, update_size);\n\treturn 0;\n}\n\nvoid btrfs_init_block_rsv(struct btrfs_block_rsv *rsv, enum btrfs_rsv_type type)\n{\n\tmemset(rsv, 0, sizeof(*rsv));\n\tspin_lock_init(&rsv->lock);\n\trsv->type = type;\n}\n\nvoid btrfs_init_metadata_block_rsv(struct btrfs_fs_info *fs_info,\n\t\t\t\t   struct btrfs_block_rsv *rsv,\n\t\t\t\t   enum btrfs_rsv_type type)\n{\n\tbtrfs_init_block_rsv(rsv, type);\n\trsv->space_info = btrfs_find_space_info(fs_info,\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_METADATA);\n}\n\nstruct btrfs_block_rsv *btrfs_alloc_block_rsv(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t      enum btrfs_rsv_type type)\n{\n\tstruct btrfs_block_rsv *block_rsv;\n\n\tblock_rsv = kmalloc(sizeof(*block_rsv), GFP_NOFS);\n\tif (!block_rsv)\n\t\treturn NULL;\n\n\tbtrfs_init_metadata_block_rsv(fs_info, block_rsv, type);\n\treturn block_rsv;\n}\n\nvoid btrfs_free_block_rsv(struct btrfs_fs_info *fs_info,\n\t\t\t  struct btrfs_block_rsv *rsv)\n{\n\tif (!rsv)\n\t\treturn;\n\tbtrfs_block_rsv_release(fs_info, rsv, (u64)-1, NULL);\n\tkfree(rsv);\n}\n\nint btrfs_block_rsv_add(struct btrfs_fs_info *fs_info,\n\t\t\tstruct btrfs_block_rsv *block_rsv, u64 num_bytes,\n\t\t\tenum btrfs_reserve_flush_enum flush)\n{\n\tint ret;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tret = btrfs_reserve_metadata_bytes(fs_info, block_rsv, num_bytes, flush);\n\tif (!ret)\n\t\tbtrfs_block_rsv_add_bytes(block_rsv, num_bytes, true);\n\n\treturn ret;\n}\n\nint btrfs_block_rsv_check(struct btrfs_block_rsv *block_rsv, int min_percent)\n{\n\tu64 num_bytes = 0;\n\tint ret = -ENOSPC;\n\n\tspin_lock(&block_rsv->lock);\n\tnum_bytes = mult_perc(block_rsv->size, min_percent);\n\tif (block_rsv->reserved >= num_bytes)\n\t\tret = 0;\n\tspin_unlock(&block_rsv->lock);\n\n\treturn ret;\n}\n\nint btrfs_block_rsv_refill(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_block_rsv *block_rsv, u64 num_bytes,\n\t\t\t   enum btrfs_reserve_flush_enum flush)\n{\n\tint ret = -ENOSPC;\n\n\tif (!block_rsv)\n\t\treturn 0;\n\n\tspin_lock(&block_rsv->lock);\n\tif (block_rsv->reserved >= num_bytes)\n\t\tret = 0;\n\telse\n\t\tnum_bytes -= block_rsv->reserved;\n\tspin_unlock(&block_rsv->lock);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tret = btrfs_reserve_metadata_bytes(fs_info, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tbtrfs_block_rsv_add_bytes(block_rsv, num_bytes, false);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}\n\nu64 btrfs_block_rsv_release(struct btrfs_fs_info *fs_info,\n\t\t\t    struct btrfs_block_rsv *block_rsv, u64 num_bytes,\n\t\t\t    u64 *qgroup_to_release)\n{\n\tstruct btrfs_block_rsv *global_rsv = &fs_info->global_block_rsv;\n\tstruct btrfs_block_rsv *delayed_rsv = &fs_info->delayed_refs_rsv;\n\tstruct btrfs_block_rsv *target = NULL;\n\n\t \n\tif (block_rsv == delayed_rsv)\n\t\ttarget = global_rsv;\n\telse if (block_rsv != global_rsv && !btrfs_block_rsv_full(delayed_rsv))\n\t\ttarget = delayed_rsv;\n\n\tif (target && block_rsv->space_info != target->space_info)\n\t\ttarget = NULL;\n\n\treturn block_rsv_release_bytes(fs_info, block_rsv, target, num_bytes,\n\t\t\t\t       qgroup_to_release);\n}\n\nint btrfs_block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv, u64 num_bytes)\n{\n\tint ret = -ENOSPC;\n\n\tspin_lock(&block_rsv->lock);\n\tif (block_rsv->reserved >= num_bytes) {\n\t\tblock_rsv->reserved -= num_bytes;\n\t\tif (block_rsv->reserved < block_rsv->size)\n\t\t\tblock_rsv->full = false;\n\t\tret = 0;\n\t}\n\tspin_unlock(&block_rsv->lock);\n\treturn ret;\n}\n\nvoid btrfs_block_rsv_add_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes, bool update_size)\n{\n\tspin_lock(&block_rsv->lock);\n\tblock_rsv->reserved += num_bytes;\n\tif (update_size)\n\t\tblock_rsv->size += num_bytes;\n\telse if (block_rsv->reserved >= block_rsv->size)\n\t\tblock_rsv->full = true;\n\tspin_unlock(&block_rsv->lock);\n}\n\nvoid btrfs_update_global_block_rsv(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_block_rsv *block_rsv = &fs_info->global_block_rsv;\n\tstruct btrfs_space_info *sinfo = block_rsv->space_info;\n\tstruct btrfs_root *root, *tmp;\n\tu64 num_bytes = btrfs_root_used(&fs_info->tree_root->root_item);\n\tunsigned int min_items = 1;\n\n\t \n\tread_lock(&fs_info->global_root_lock);\n\trbtree_postorder_for_each_entry_safe(root, tmp, &fs_info->global_root_tree,\n\t\t\t\t\t     rb_node) {\n\t\tif (root->root_key.objectid == BTRFS_EXTENT_TREE_OBJECTID ||\n\t\t    root->root_key.objectid == BTRFS_CSUM_TREE_OBJECTID ||\n\t\t    root->root_key.objectid == BTRFS_FREE_SPACE_TREE_OBJECTID) {\n\t\t\tnum_bytes += btrfs_root_used(&root->root_item);\n\t\t\tmin_items++;\n\t\t}\n\t}\n\tread_unlock(&fs_info->global_root_lock);\n\n\tif (btrfs_fs_compat_ro(fs_info, BLOCK_GROUP_TREE)) {\n\t\tnum_bytes += btrfs_root_used(&fs_info->block_group_root->root_item);\n\t\tmin_items++;\n\t}\n\n\t \n\tmin_items += BTRFS_UNLINK_METADATA_UNITS;\n\n\tnum_bytes = max_t(u64, num_bytes,\n\t\t\t  btrfs_calc_insert_metadata_size(fs_info, min_items) +\n\t\t\t  btrfs_calc_delayed_ref_bytes(fs_info,\n\t\t\t\t\t       BTRFS_UNLINK_METADATA_UNITS));\n\n\tspin_lock(&sinfo->lock);\n\tspin_lock(&block_rsv->lock);\n\n\tblock_rsv->size = min_t(u64, num_bytes, SZ_512M);\n\n\tif (block_rsv->reserved < block_rsv->size) {\n\t\tnum_bytes = block_rsv->size - block_rsv->reserved;\n\t\tbtrfs_space_info_update_bytes_may_use(fs_info, sinfo,\n\t\t\t\t\t\t      num_bytes);\n\t\tblock_rsv->reserved = block_rsv->size;\n\t} else if (block_rsv->reserved > block_rsv->size) {\n\t\tnum_bytes = block_rsv->reserved - block_rsv->size;\n\t\tbtrfs_space_info_update_bytes_may_use(fs_info, sinfo,\n\t\t\t\t\t\t      -num_bytes);\n\t\tblock_rsv->reserved = block_rsv->size;\n\t\tbtrfs_try_granting_tickets(fs_info, sinfo);\n\t}\n\n\tblock_rsv->full = (block_rsv->reserved == block_rsv->size);\n\n\tif (block_rsv->size >= sinfo->total_bytes)\n\t\tsinfo->force_alloc = CHUNK_ALLOC_FORCE;\n\tspin_unlock(&block_rsv->lock);\n\tspin_unlock(&sinfo->lock);\n}\n\nvoid btrfs_init_root_block_rsv(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tswitch (root->root_key.objectid) {\n\tcase BTRFS_CSUM_TREE_OBJECTID:\n\tcase BTRFS_EXTENT_TREE_OBJECTID:\n\tcase BTRFS_FREE_SPACE_TREE_OBJECTID:\n\tcase BTRFS_BLOCK_GROUP_TREE_OBJECTID:\n\t\troot->block_rsv = &fs_info->delayed_refs_rsv;\n\t\tbreak;\n\tcase BTRFS_ROOT_TREE_OBJECTID:\n\tcase BTRFS_DEV_TREE_OBJECTID:\n\tcase BTRFS_QUOTA_TREE_OBJECTID:\n\t\troot->block_rsv = &fs_info->global_block_rsv;\n\t\tbreak;\n\tcase BTRFS_CHUNK_TREE_OBJECTID:\n\t\troot->block_rsv = &fs_info->chunk_block_rsv;\n\t\tbreak;\n\tdefault:\n\t\troot->block_rsv = NULL;\n\t\tbreak;\n\t}\n}\n\nvoid btrfs_init_global_block_rsv(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_space_info *space_info;\n\n\tspace_info = btrfs_find_space_info(fs_info, BTRFS_BLOCK_GROUP_SYSTEM);\n\tfs_info->chunk_block_rsv.space_info = space_info;\n\n\tspace_info = btrfs_find_space_info(fs_info, BTRFS_BLOCK_GROUP_METADATA);\n\tfs_info->global_block_rsv.space_info = space_info;\n\tfs_info->trans_block_rsv.space_info = space_info;\n\tfs_info->empty_block_rsv.space_info = space_info;\n\tfs_info->delayed_block_rsv.space_info = space_info;\n\tfs_info->delayed_refs_rsv.space_info = space_info;\n\n\tbtrfs_update_global_block_rsv(fs_info);\n}\n\nvoid btrfs_release_global_block_rsv(struct btrfs_fs_info *fs_info)\n{\n\tbtrfs_block_rsv_release(fs_info, &fs_info->global_block_rsv, (u64)-1,\n\t\t\t\tNULL);\n\tWARN_ON(fs_info->trans_block_rsv.size > 0);\n\tWARN_ON(fs_info->trans_block_rsv.reserved > 0);\n\tWARN_ON(fs_info->chunk_block_rsv.size > 0);\n\tWARN_ON(fs_info->chunk_block_rsv.reserved > 0);\n\tWARN_ON(fs_info->delayed_block_rsv.size > 0);\n\tWARN_ON(fs_info->delayed_block_rsv.reserved > 0);\n\tWARN_ON(fs_info->delayed_refs_rsv.reserved > 0);\n\tWARN_ON(fs_info->delayed_refs_rsv.size > 0);\n}\n\nstatic struct btrfs_block_rsv *get_block_rsv(\n\t\t\t\t\tconst struct btrfs_trans_handle *trans,\n\t\t\t\t\tconst struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_block_rsv *block_rsv = NULL;\n\n\tif (test_bit(BTRFS_ROOT_SHAREABLE, &root->state) ||\n\t    (root == fs_info->uuid_root) ||\n\t    (trans->adding_csums &&\n\t     root->root_key.objectid == BTRFS_CSUM_TREE_OBJECTID))\n\t\tblock_rsv = trans->block_rsv;\n\n\tif (!block_rsv)\n\t\tblock_rsv = root->block_rsv;\n\n\tif (!block_rsv)\n\t\tblock_rsv = &fs_info->empty_block_rsv;\n\n\treturn block_rsv;\n}\n\nstruct btrfs_block_rsv *btrfs_use_block_rsv(struct btrfs_trans_handle *trans,\n\t\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t\t    u32 blocksize)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct btrfs_block_rsv *global_rsv = &fs_info->global_block_rsv;\n\tint ret;\n\tbool global_updated = false;\n\n\tblock_rsv = get_block_rsv(trans, root);\n\n\tif (unlikely(block_rsv->size == 0))\n\t\tgoto try_reserve;\nagain:\n\tret = btrfs_block_rsv_use_bytes(block_rsv, blocksize);\n\tif (!ret)\n\t\treturn block_rsv;\n\n\tif (block_rsv->failfast)\n\t\treturn ERR_PTR(ret);\n\n\tif (block_rsv->type == BTRFS_BLOCK_RSV_GLOBAL && !global_updated) {\n\t\tglobal_updated = true;\n\t\tbtrfs_update_global_block_rsv(fs_info);\n\t\tgoto again;\n\t}\n\n\t \n\tif (block_rsv->type != BTRFS_BLOCK_RSV_DELREFS &&\n\t    btrfs_test_opt(fs_info, ENOSPC_DEBUG)) {\n\t\tstatic DEFINE_RATELIMIT_STATE(_rs,\n\t\t\t\tDEFAULT_RATELIMIT_INTERVAL * 10,\n\t\t\t\t  1);\n\t\tif (__ratelimit(&_rs))\n\t\t\tWARN(1, KERN_DEBUG\n\t\t\t\t\"BTRFS: block rsv %d returned %d\\n\",\n\t\t\t\tblock_rsv->type, ret);\n\t}\ntry_reserve:\n\tret = btrfs_reserve_metadata_bytes(fs_info, block_rsv, blocksize,\n\t\t\t\t\t   BTRFS_RESERVE_NO_FLUSH);\n\tif (!ret)\n\t\treturn block_rsv;\n\t \n\tif (block_rsv->type != BTRFS_BLOCK_RSV_GLOBAL &&\n\t    block_rsv->space_info == global_rsv->space_info) {\n\t\tret = btrfs_block_rsv_use_bytes(global_rsv, blocksize);\n\t\tif (!ret)\n\t\t\treturn global_rsv;\n\t}\n\n\t \n\tret = btrfs_reserve_metadata_bytes(fs_info, block_rsv, blocksize,\n\t\t\t\t\t   BTRFS_RESERVE_FLUSH_EMERGENCY);\n\tif (!ret)\n\t\treturn block_rsv;\n\n\treturn ERR_PTR(ret);\n}\n\nint btrfs_check_trunc_cache_free_space(struct btrfs_fs_info *fs_info,\n\t\t\t\t       struct btrfs_block_rsv *rsv)\n{\n\tu64 needed_bytes;\n\tint ret;\n\n\t \n\tneeded_bytes = btrfs_calc_insert_metadata_size(fs_info, 1) +\n\t\tbtrfs_calc_metadata_size(fs_info, 1);\n\n\tspin_lock(&rsv->lock);\n\tif (rsv->reserved < needed_bytes)\n\t\tret = -ENOSPC;\n\telse\n\t\tret = 0;\n\tspin_unlock(&rsv->lock);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}