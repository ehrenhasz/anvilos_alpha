{
  "module_name": "inode.c",
  "hash_id": "bbbf7f6990b899aea0f86379324d8167f40a487b21aa49441b721de3f9dce66d",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/inode.c",
  "human_readable_source": "\n \n\n#include <crypto/hash.h>\n#include <linux/kernel.h>\n#include <linux/bio.h>\n#include <linux/blk-cgroup.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/compat.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/falloc.h>\n#include <linux/slab.h>\n#include <linux/ratelimit.h>\n#include <linux/btrfs.h>\n#include <linux/blkdev.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/uio.h>\n#include <linux/magic.h>\n#include <linux/iversion.h>\n#include <linux/swap.h>\n#include <linux/migrate.h>\n#include <linux/sched/mm.h>\n#include <linux/iomap.h>\n#include <asm/unaligned.h>\n#include <linux/fsverity.h>\n#include \"misc.h\"\n#include \"ctree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"print-tree.h\"\n#include \"ordered-data.h\"\n#include \"xattr.h\"\n#include \"tree-log.h\"\n#include \"bio.h\"\n#include \"compression.h\"\n#include \"locking.h\"\n#include \"free-space-cache.h\"\n#include \"props.h\"\n#include \"qgroup.h\"\n#include \"delalloc-space.h\"\n#include \"block-group.h\"\n#include \"space-info.h\"\n#include \"zoned.h\"\n#include \"subpage.h\"\n#include \"inode-item.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n#include \"extent-tree.h\"\n#include \"root-tree.h\"\n#include \"defrag.h\"\n#include \"dir-item.h\"\n#include \"file-item.h\"\n#include \"uuid-tree.h\"\n#include \"ioctl.h\"\n#include \"file.h\"\n#include \"acl.h\"\n#include \"relocation.h\"\n#include \"verity.h\"\n#include \"super.h\"\n#include \"orphan.h\"\n#include \"backref.h\"\n\nstruct btrfs_iget_args {\n\tu64 ino;\n\tstruct btrfs_root *root;\n};\n\nstruct btrfs_dio_data {\n\tssize_t submitted;\n\tstruct extent_changeset *data_reserved;\n\tstruct btrfs_ordered_extent *ordered;\n\tbool data_space_reserved;\n\tbool nocow_done;\n};\n\nstruct btrfs_dio_private {\n\t \n\tu64 file_offset;\n\tu32 bytes;\n\n\t \n\tstruct btrfs_bio bbio;\n};\n\nstatic struct bio_set btrfs_dio_bioset;\n\nstruct btrfs_rename_ctx {\n\t \n\tu64 index;\n};\n\n \nstruct data_reloc_warn {\n\tstruct btrfs_path path;\n\tstruct btrfs_fs_info *fs_info;\n\tu64 extent_item_size;\n\tu64 logical;\n\tint mirror_num;\n};\n\nstatic const struct inode_operations btrfs_dir_inode_operations;\nstatic const struct inode_operations btrfs_symlink_inode_operations;\nstatic const struct inode_operations btrfs_special_inode_operations;\nstatic const struct inode_operations btrfs_file_inode_operations;\nstatic const struct address_space_operations btrfs_aops;\nstatic const struct file_operations btrfs_dir_file_operations;\n\nstatic struct kmem_cache *btrfs_inode_cachep;\n\nstatic int btrfs_setsize(struct inode *inode, struct iattr *attr);\nstatic int btrfs_truncate(struct btrfs_inode *inode, bool skip_writeback);\n\nstatic noinline int run_delalloc_cow(struct btrfs_inode *inode,\n\t\t\t\t     struct page *locked_page, u64 start,\n\t\t\t\t     u64 end, struct writeback_control *wbc,\n\t\t\t\t     bool pages_dirty);\nstatic struct extent_map *create_io_em(struct btrfs_inode *inode, u64 start,\n\t\t\t\t       u64 len, u64 orig_start, u64 block_start,\n\t\t\t\t       u64 block_len, u64 orig_block_len,\n\t\t\t\t       u64 ram_bytes, int compress_type,\n\t\t\t\t       int type);\n\nstatic int data_reloc_print_warning_inode(u64 inum, u64 offset, u64 num_bytes,\n\t\t\t\t\t  u64 root, void *warn_ctx)\n{\n\tstruct data_reloc_warn *warn = warn_ctx;\n\tstruct btrfs_fs_info *fs_info = warn->fs_info;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct inode_fs_paths *ipath = NULL;\n\tstruct btrfs_root *local_root;\n\tstruct btrfs_key key;\n\tunsigned int nofs_flag;\n\tu32 nlink;\n\tint ret;\n\n\tlocal_root = btrfs_get_fs_root(fs_info, root, true);\n\tif (IS_ERR(local_root)) {\n\t\tret = PTR_ERR(local_root);\n\t\tgoto err;\n\t}\n\n\t \n\tkey.objectid = inum;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(NULL, local_root, &key, &warn->path, 0, 0);\n\tif (ret) {\n\t\tbtrfs_put_root(local_root);\n\t\tbtrfs_release_path(&warn->path);\n\t\tgoto err;\n\t}\n\n\teb = warn->path.nodes[0];\n\tinode_item = btrfs_item_ptr(eb, warn->path.slots[0], struct btrfs_inode_item);\n\tnlink = btrfs_inode_nlink(eb, inode_item);\n\tbtrfs_release_path(&warn->path);\n\n\tnofs_flag = memalloc_nofs_save();\n\tipath = init_ipath(4096, local_root, &warn->path);\n\tmemalloc_nofs_restore(nofs_flag);\n\tif (IS_ERR(ipath)) {\n\t\tbtrfs_put_root(local_root);\n\t\tret = PTR_ERR(ipath);\n\t\tipath = NULL;\n\t\t \n\t\tbtrfs_warn(fs_info,\n\"checksum error at logical %llu mirror %u root %llu, inode %llu offset %llu\",\n\t\t\t   warn->logical, warn->mirror_num, root, inum, offset);\n\t\treturn ret;\n\t}\n\tret = paths_from_inode(inum, ipath);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tfor (int i = 0; i < ipath->fspath->elem_cnt; i++) {\n\t\tbtrfs_warn(fs_info,\n\"checksum error at logical %llu mirror %u root %llu inode %llu offset %llu length %u links %u (path: %s)\",\n\t\t\t   warn->logical, warn->mirror_num, root, inum, offset,\n\t\t\t   fs_info->sectorsize, nlink,\n\t\t\t   (char *)(unsigned long)ipath->fspath->val[i]);\n\t}\n\n\tbtrfs_put_root(local_root);\n\tfree_ipath(ipath);\n\treturn 0;\n\nerr:\n\tbtrfs_warn(fs_info,\n\"checksum error at logical %llu mirror %u root %llu inode %llu offset %llu, path resolving failed with ret=%d\",\n\t\t   warn->logical, warn->mirror_num, root, inum, offset, ret);\n\n\tfree_ipath(ipath);\n\treturn ret;\n}\n\n \nstatic void print_data_reloc_error(const struct btrfs_inode *inode, u64 file_off,\n\t\t\t\t   const u8 *csum, const u8 *csum_expected,\n\t\t\t\t   int mirror_num)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tstruct btrfs_path path = { 0 };\n\tstruct btrfs_key found_key = { 0 };\n\tstruct extent_buffer *eb;\n\tstruct btrfs_extent_item *ei;\n\tconst u32 csum_size = fs_info->csum_size;\n\tu64 logical;\n\tu64 flags;\n\tu32 item_size;\n\tint ret;\n\n\tmutex_lock(&fs_info->reloc_mutex);\n\tlogical = btrfs_get_reloc_bg_bytenr(fs_info);\n\tmutex_unlock(&fs_info->reloc_mutex);\n\n\tif (logical == U64_MAX) {\n\t\tbtrfs_warn_rl(fs_info, \"has data reloc tree but no running relocation\");\n\t\tbtrfs_warn_rl(fs_info,\n\"csum failed root %lld ino %llu off %llu csum \" CSUM_FMT \" expected csum \" CSUM_FMT \" mirror %d\",\n\t\t\tinode->root->root_key.objectid, btrfs_ino(inode), file_off,\n\t\t\tCSUM_FMT_VALUE(csum_size, csum),\n\t\t\tCSUM_FMT_VALUE(csum_size, csum_expected),\n\t\t\tmirror_num);\n\t\treturn;\n\t}\n\n\tlogical += file_off;\n\tbtrfs_warn_rl(fs_info,\n\"csum failed root %lld ino %llu off %llu logical %llu csum \" CSUM_FMT \" expected csum \" CSUM_FMT \" mirror %d\",\n\t\t\tinode->root->root_key.objectid,\n\t\t\tbtrfs_ino(inode), file_off, logical,\n\t\t\tCSUM_FMT_VALUE(csum_size, csum),\n\t\t\tCSUM_FMT_VALUE(csum_size, csum_expected),\n\t\t\tmirror_num);\n\n\tret = extent_from_logical(fs_info, logical, &path, &found_key, &flags);\n\tif (ret < 0) {\n\t\tbtrfs_err_rl(fs_info, \"failed to lookup extent item for logical %llu: %d\",\n\t\t\t     logical, ret);\n\t\treturn;\n\t}\n\teb = path.nodes[0];\n\tei = btrfs_item_ptr(eb, path.slots[0], struct btrfs_extent_item);\n\titem_size = btrfs_item_size(eb, path.slots[0]);\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tunsigned long ptr = 0;\n\t\tu64 ref_root;\n\t\tu8 ref_level;\n\n\t\twhile (true) {\n\t\t\tret = tree_backref_for_extent(&ptr, eb, &found_key, ei,\n\t\t\t\t\t\t      item_size, &ref_root,\n\t\t\t\t\t\t      &ref_level);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_warn_rl(fs_info,\n\t\t\t\t\"failed to resolve tree backref for logical %llu: %d\",\n\t\t\t\t\t      logical, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\n\t\t\tbtrfs_warn_rl(fs_info,\n\"csum error at logical %llu mirror %u: metadata %s (level %d) in tree %llu\",\n\t\t\t\tlogical, mirror_num,\n\t\t\t\t(ref_level ? \"node\" : \"leaf\"),\n\t\t\t\tref_level, ref_root);\n\t\t}\n\t\tbtrfs_release_path(&path);\n\t} else {\n\t\tstruct btrfs_backref_walk_ctx ctx = { 0 };\n\t\tstruct data_reloc_warn reloc_warn = { 0 };\n\n\t\tbtrfs_release_path(&path);\n\n\t\tctx.bytenr = found_key.objectid;\n\t\tctx.extent_item_pos = logical - found_key.objectid;\n\t\tctx.fs_info = fs_info;\n\n\t\treloc_warn.logical = logical;\n\t\treloc_warn.extent_item_size = found_key.offset;\n\t\treloc_warn.mirror_num = mirror_num;\n\t\treloc_warn.fs_info = fs_info;\n\n\t\titerate_extent_inodes(&ctx, true,\n\t\t\t\t      data_reloc_print_warning_inode, &reloc_warn);\n\t}\n}\n\nstatic void __cold btrfs_print_data_csum_error(struct btrfs_inode *inode,\n\t\tu64 logical_start, u8 *csum, u8 *csum_expected, int mirror_num)\n{\n\tstruct btrfs_root *root = inode->root;\n\tconst u32 csum_size = root->fs_info->csum_size;\n\n\t \n\tif (root->root_key.objectid == BTRFS_DATA_RELOC_TREE_OBJECTID)\n\t\treturn print_data_reloc_error(inode, logical_start, csum,\n\t\t\t\t\t      csum_expected, mirror_num);\n\n\t \n\tif (root->root_key.objectid >= BTRFS_LAST_FREE_OBJECTID) {\n\t\tbtrfs_warn_rl(root->fs_info,\n\"csum failed root %lld ino %lld off %llu csum \" CSUM_FMT \" expected csum \" CSUM_FMT \" mirror %d\",\n\t\t\troot->root_key.objectid, btrfs_ino(inode),\n\t\t\tlogical_start,\n\t\t\tCSUM_FMT_VALUE(csum_size, csum),\n\t\t\tCSUM_FMT_VALUE(csum_size, csum_expected),\n\t\t\tmirror_num);\n\t} else {\n\t\tbtrfs_warn_rl(root->fs_info,\n\"csum failed root %llu ino %llu off %llu csum \" CSUM_FMT \" expected csum \" CSUM_FMT \" mirror %d\",\n\t\t\troot->root_key.objectid, btrfs_ino(inode),\n\t\t\tlogical_start,\n\t\t\tCSUM_FMT_VALUE(csum_size, csum),\n\t\t\tCSUM_FMT_VALUE(csum_size, csum_expected),\n\t\t\tmirror_num);\n\t}\n}\n\n \nint btrfs_inode_lock(struct btrfs_inode *inode, unsigned int ilock_flags)\n{\n\tif (ilock_flags & BTRFS_ILOCK_SHARED) {\n\t\tif (ilock_flags & BTRFS_ILOCK_TRY) {\n\t\t\tif (!inode_trylock_shared(&inode->vfs_inode))\n\t\t\t\treturn -EAGAIN;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tinode_lock_shared(&inode->vfs_inode);\n\t} else {\n\t\tif (ilock_flags & BTRFS_ILOCK_TRY) {\n\t\t\tif (!inode_trylock(&inode->vfs_inode))\n\t\t\t\treturn -EAGAIN;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tinode_lock(&inode->vfs_inode);\n\t}\n\tif (ilock_flags & BTRFS_ILOCK_MMAP)\n\t\tdown_write(&inode->i_mmap_lock);\n\treturn 0;\n}\n\n \nvoid btrfs_inode_unlock(struct btrfs_inode *inode, unsigned int ilock_flags)\n{\n\tif (ilock_flags & BTRFS_ILOCK_MMAP)\n\t\tup_write(&inode->i_mmap_lock);\n\tif (ilock_flags & BTRFS_ILOCK_SHARED)\n\t\tinode_unlock_shared(&inode->vfs_inode);\n\telse\n\t\tinode_unlock(&inode->vfs_inode);\n}\n\n \nstatic inline void btrfs_cleanup_ordered_extents(struct btrfs_inode *inode,\n\t\t\t\t\t\t struct page *locked_page,\n\t\t\t\t\t\t u64 offset, u64 bytes)\n{\n\tunsigned long index = offset >> PAGE_SHIFT;\n\tunsigned long end_index = (offset + bytes - 1) >> PAGE_SHIFT;\n\tu64 page_start = 0, page_end = 0;\n\tstruct page *page;\n\n\tif (locked_page) {\n\t\tpage_start = page_offset(locked_page);\n\t\tpage_end = page_start + PAGE_SIZE - 1;\n\t}\n\n\twhile (index <= end_index) {\n\t\t \n\t\tif (locked_page && index == (page_start >> PAGE_SHIFT)) {\n\t\t\tindex++;\n\t\t\tcontinue;\n\t\t}\n\t\tpage = find_get_page(inode->vfs_inode.i_mapping, index);\n\t\tindex++;\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t \n\t\tbtrfs_page_clamp_clear_ordered(inode->root->fs_info, page,\n\t\t\t\t\t       offset, bytes);\n\t\tput_page(page);\n\t}\n\n\tif (locked_page) {\n\t\t \n\t\tif (bytes + offset <= page_start + PAGE_SIZE)\n\t\t\treturn;\n\t\t \n\t\tif (page_start >= offset && page_end <= (offset + bytes - 1)) {\n\t\t\tbytes = offset + bytes - page_offset(locked_page) - PAGE_SIZE;\n\t\t\toffset = page_offset(locked_page) + PAGE_SIZE;\n\t\t}\n\t}\n\n\treturn btrfs_mark_ordered_io_finished(inode, NULL, offset, bytes, false);\n}\n\nstatic int btrfs_dirty_inode(struct btrfs_inode *inode);\n\nstatic int btrfs_init_inode_security(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_new_inode_args *args)\n{\n\tint err;\n\n\tif (args->default_acl) {\n\t\terr = __btrfs_set_acl(trans, args->inode, args->default_acl,\n\t\t\t\t      ACL_TYPE_DEFAULT);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (args->acl) {\n\t\terr = __btrfs_set_acl(trans, args->inode, args->acl, ACL_TYPE_ACCESS);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (!args->default_acl && !args->acl)\n\t\tcache_no_acl(args->inode);\n\treturn btrfs_xattr_security_init(trans, args->inode, args->dir,\n\t\t\t\t\t &args->dentry->d_name);\n}\n\n \nstatic int insert_inline_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_path *path,\n\t\t\t\tstruct btrfs_inode *inode, bool extent_inserted,\n\t\t\t\tsize_t size, size_t compressed_size,\n\t\t\t\tint compress_type,\n\t\t\t\tstruct page **compressed_pages,\n\t\t\t\tbool update_i_size)\n{\n\tstruct btrfs_root *root = inode->root;\n\tstruct extent_buffer *leaf;\n\tstruct page *page = NULL;\n\tchar *kaddr;\n\tunsigned long ptr;\n\tstruct btrfs_file_extent_item *ei;\n\tint ret;\n\tsize_t cur_size = size;\n\tu64 i_size;\n\n\tASSERT((compressed_size > 0 && compressed_pages) ||\n\t       (compressed_size == 0 && !compressed_pages));\n\n\tif (compressed_size && compressed_pages)\n\t\tcur_size = compressed_size;\n\n\tif (!extent_inserted) {\n\t\tstruct btrfs_key key;\n\t\tsize_t datasize;\n\n\t\tkey.objectid = btrfs_ino(inode);\n\t\tkey.offset = 0;\n\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\n\t\tdatasize = btrfs_file_extent_calc_inline_size(cur_size);\n\t\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t\t      datasize);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\tleaf = path->nodes[0];\n\tei = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\tbtrfs_set_file_extent_generation(leaf, ei, trans->transid);\n\tbtrfs_set_file_extent_type(leaf, ei, BTRFS_FILE_EXTENT_INLINE);\n\tbtrfs_set_file_extent_encryption(leaf, ei, 0);\n\tbtrfs_set_file_extent_other_encoding(leaf, ei, 0);\n\tbtrfs_set_file_extent_ram_bytes(leaf, ei, size);\n\tptr = btrfs_file_extent_inline_start(ei);\n\n\tif (compress_type != BTRFS_COMPRESS_NONE) {\n\t\tstruct page *cpage;\n\t\tint i = 0;\n\t\twhile (compressed_size > 0) {\n\t\t\tcpage = compressed_pages[i];\n\t\t\tcur_size = min_t(unsigned long, compressed_size,\n\t\t\t\t       PAGE_SIZE);\n\n\t\t\tkaddr = kmap_local_page(cpage);\n\t\t\twrite_extent_buffer(leaf, kaddr, ptr, cur_size);\n\t\t\tkunmap_local(kaddr);\n\n\t\t\ti++;\n\t\t\tptr += cur_size;\n\t\t\tcompressed_size -= cur_size;\n\t\t}\n\t\tbtrfs_set_file_extent_compression(leaf, ei,\n\t\t\t\t\t\t  compress_type);\n\t} else {\n\t\tpage = find_get_page(inode->vfs_inode.i_mapping, 0);\n\t\tbtrfs_set_file_extent_compression(leaf, ei, 0);\n\t\tkaddr = kmap_local_page(page);\n\t\twrite_extent_buffer(leaf, kaddr, ptr, size);\n\t\tkunmap_local(kaddr);\n\t\tput_page(page);\n\t}\n\tbtrfs_mark_buffer_dirty(trans, leaf);\n\tbtrfs_release_path(path);\n\n\t \n\tret = btrfs_inode_set_file_extent_range(inode, 0,\n\t\t\t\t\tALIGN(size, root->fs_info->sectorsize));\n\tif (ret)\n\t\tgoto fail;\n\n\t \n\ti_size = i_size_read(&inode->vfs_inode);\n\tif (update_i_size && size > i_size) {\n\t\ti_size_write(&inode->vfs_inode, size);\n\t\ti_size = size;\n\t}\n\tinode->disk_i_size = i_size;\n\nfail:\n\treturn ret;\n}\n\n\n \nstatic noinline int cow_file_range_inline(struct btrfs_inode *inode, u64 size,\n\t\t\t\t\t  size_t compressed_size,\n\t\t\t\t\t  int compress_type,\n\t\t\t\t\t  struct page **compressed_pages,\n\t\t\t\t\t  bool update_i_size)\n{\n\tstruct btrfs_drop_extents_args drop_args = { 0 };\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_trans_handle *trans;\n\tu64 data_len = (compressed_size ?: size);\n\tint ret;\n\tstruct btrfs_path *path;\n\n\t \n\tif (size < i_size_read(&inode->vfs_inode) ||\n\t    size > fs_info->sectorsize ||\n\t    data_len > BTRFS_MAX_INLINE_DATA_SIZE(fs_info) ||\n\t    data_len > fs_info->max_inline)\n\t\treturn 1;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(trans);\n\t}\n\ttrans->block_rsv = &inode->block_rsv;\n\n\tdrop_args.path = path;\n\tdrop_args.start = 0;\n\tdrop_args.end = fs_info->sectorsize;\n\tdrop_args.drop_cache = true;\n\tdrop_args.replace_extent = true;\n\tdrop_args.extent_item_size = btrfs_file_extent_calc_inline_size(data_len);\n\tret = btrfs_drop_extents(trans, root, inode, &drop_args);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\n\n\tret = insert_inline_extent(trans, path, inode, drop_args.extent_inserted,\n\t\t\t\t   size, compressed_size, compress_type,\n\t\t\t\t   compressed_pages, update_i_size);\n\tif (ret && ret != -ENOSPC) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t} else if (ret == -ENOSPC) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tbtrfs_update_inode_bytes(inode, size, drop_args.bytes_found);\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret && ret != -ENOSPC) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t} else if (ret == -ENOSPC) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tbtrfs_set_inode_full_sync(inode);\nout:\n\t \n\tbtrfs_qgroup_free_data(inode, NULL, 0, PAGE_SIZE, NULL);\n\tbtrfs_free_path(path);\n\tbtrfs_end_transaction(trans);\n\treturn ret;\n}\n\nstruct async_extent {\n\tu64 start;\n\tu64 ram_size;\n\tu64 compressed_size;\n\tstruct page **pages;\n\tunsigned long nr_pages;\n\tint compress_type;\n\tstruct list_head list;\n};\n\nstruct async_chunk {\n\tstruct btrfs_inode *inode;\n\tstruct page *locked_page;\n\tu64 start;\n\tu64 end;\n\tblk_opf_t write_flags;\n\tstruct list_head extents;\n\tstruct cgroup_subsys_state *blkcg_css;\n\tstruct btrfs_work work;\n\tstruct async_cow *async_cow;\n};\n\nstruct async_cow {\n\tatomic_t num_chunks;\n\tstruct async_chunk chunks[];\n};\n\nstatic noinline int add_async_extent(struct async_chunk *cow,\n\t\t\t\t     u64 start, u64 ram_size,\n\t\t\t\t     u64 compressed_size,\n\t\t\t\t     struct page **pages,\n\t\t\t\t     unsigned long nr_pages,\n\t\t\t\t     int compress_type)\n{\n\tstruct async_extent *async_extent;\n\n\tasync_extent = kmalloc(sizeof(*async_extent), GFP_NOFS);\n\tBUG_ON(!async_extent);  \n\tasync_extent->start = start;\n\tasync_extent->ram_size = ram_size;\n\tasync_extent->compressed_size = compressed_size;\n\tasync_extent->pages = pages;\n\tasync_extent->nr_pages = nr_pages;\n\tasync_extent->compress_type = compress_type;\n\tlist_add_tail(&async_extent->list, &cow->extents);\n\treturn 0;\n}\n\n \nstatic inline int inode_need_compress(struct btrfs_inode *inode, u64 start,\n\t\t\t\t      u64 end)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\n\tif (!btrfs_inode_can_compress(inode)) {\n\t\tWARN(IS_ENABLED(CONFIG_BTRFS_DEBUG),\n\t\t\tKERN_ERR \"BTRFS: unexpected compression for ino %llu\\n\",\n\t\t\tbtrfs_ino(inode));\n\t\treturn 0;\n\t}\n\t \n\tif (fs_info->sectorsize < PAGE_SIZE) {\n\t\tif (!PAGE_ALIGNED(start) ||\n\t\t    !PAGE_ALIGNED(end + 1))\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (btrfs_test_opt(fs_info, FORCE_COMPRESS))\n\t\treturn 1;\n\t \n\tif (inode->defrag_compress)\n\t\treturn 1;\n\t \n\tif (inode->flags & BTRFS_INODE_NOCOMPRESS)\n\t\treturn 0;\n\tif (btrfs_test_opt(fs_info, COMPRESS) ||\n\t    inode->flags & BTRFS_INODE_COMPRESS ||\n\t    inode->prop_compress)\n\t\treturn btrfs_compress_heuristic(&inode->vfs_inode, start, end);\n\treturn 0;\n}\n\nstatic inline void inode_should_defrag(struct btrfs_inode *inode,\n\t\tu64 start, u64 end, u64 num_bytes, u32 small_write)\n{\n\t \n\tif (num_bytes < small_write &&\n\t    (start > 0 || end + 1 < inode->disk_i_size))\n\t\tbtrfs_add_inode_defrag(NULL, inode, small_write);\n}\n\n \nstatic void compress_file_range(struct btrfs_work *work)\n{\n\tstruct async_chunk *async_chunk =\n\t\tcontainer_of(work, struct async_chunk, work);\n\tstruct btrfs_inode *inode = async_chunk->inode;\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tstruct address_space *mapping = inode->vfs_inode.i_mapping;\n\tu64 blocksize = fs_info->sectorsize;\n\tu64 start = async_chunk->start;\n\tu64 end = async_chunk->end;\n\tu64 actual_end;\n\tu64 i_size;\n\tint ret = 0;\n\tstruct page **pages;\n\tunsigned long nr_pages;\n\tunsigned long total_compressed = 0;\n\tunsigned long total_in = 0;\n\tunsigned int poff;\n\tint i;\n\tint compress_type = fs_info->compress_type;\n\n\tinode_should_defrag(inode, start, end, end - start + 1, SZ_16K);\n\n\t \n\textent_range_clear_dirty_for_io(&inode->vfs_inode, start, end);\n\n\t \n\tbarrier();\n\ti_size = i_size_read(&inode->vfs_inode);\n\tbarrier();\n\tactual_end = min_t(u64, i_size, end + 1);\nagain:\n\tpages = NULL;\n\tnr_pages = (end >> PAGE_SHIFT) - (start >> PAGE_SHIFT) + 1;\n\tnr_pages = min_t(unsigned long, nr_pages, BTRFS_MAX_COMPRESSED_PAGES);\n\n\t \n\tif (actual_end <= start)\n\t\tgoto cleanup_and_bail_uncompressed;\n\n\ttotal_compressed = actual_end - start;\n\n\t \n\tif (total_compressed <= blocksize &&\n\t   (start > 0 || end + 1 < inode->disk_i_size))\n\t\tgoto cleanup_and_bail_uncompressed;\n\n\t \n\tif (blocksize < PAGE_SIZE) {\n\t\tif (!PAGE_ALIGNED(start) ||\n\t\t    !PAGE_ALIGNED(round_up(actual_end, blocksize)))\n\t\t\tgoto cleanup_and_bail_uncompressed;\n\t}\n\n\ttotal_compressed = min_t(unsigned long, total_compressed,\n\t\t\tBTRFS_MAX_UNCOMPRESSED);\n\ttotal_in = 0;\n\tret = 0;\n\n\t \n\tif (!inode_need_compress(inode, start, end))\n\t\tgoto cleanup_and_bail_uncompressed;\n\n\tpages = kcalloc(nr_pages, sizeof(struct page *), GFP_NOFS);\n\tif (!pages) {\n\t\t \n\t\tgoto cleanup_and_bail_uncompressed;\n\t}\n\n\tif (inode->defrag_compress)\n\t\tcompress_type = inode->defrag_compress;\n\telse if (inode->prop_compress)\n\t\tcompress_type = inode->prop_compress;\n\n\t \n\tret = btrfs_compress_pages(compress_type | (fs_info->compress_level << 4),\n\t\t\t\t   mapping, start, pages, &nr_pages, &total_in,\n\t\t\t\t   &total_compressed);\n\tif (ret)\n\t\tgoto mark_incompressible;\n\n\t \n\tpoff = offset_in_page(total_compressed);\n\tif (poff)\n\t\tmemzero_page(pages[nr_pages - 1], poff, PAGE_SIZE - poff);\n\n\t \n\tif (start == 0 && fs_info->sectorsize == PAGE_SIZE) {\n\t\tif (total_in < actual_end) {\n\t\t\tret = cow_file_range_inline(inode, actual_end, 0,\n\t\t\t\t\t\t    BTRFS_COMPRESS_NONE, NULL,\n\t\t\t\t\t\t    false);\n\t\t} else {\n\t\t\tret = cow_file_range_inline(inode, actual_end,\n\t\t\t\t\t\t    total_compressed,\n\t\t\t\t\t\t    compress_type, pages,\n\t\t\t\t\t\t    false);\n\t\t}\n\t\tif (ret <= 0) {\n\t\t\tunsigned long clear_flags = EXTENT_DELALLOC |\n\t\t\t\tEXTENT_DELALLOC_NEW | EXTENT_DEFRAG |\n\t\t\t\tEXTENT_DO_ACCOUNTING;\n\n\t\t\tif (ret < 0)\n\t\t\t\tmapping_set_error(mapping, -EIO);\n\n\t\t\t \n\t\t\textent_clear_unlock_delalloc(inode, start, end,\n\t\t\t\t\t\t     NULL,\n\t\t\t\t\t\t     clear_flags,\n\t\t\t\t\t\t     PAGE_UNLOCK |\n\t\t\t\t\t\t     PAGE_START_WRITEBACK |\n\t\t\t\t\t\t     PAGE_END_WRITEBACK);\n\t\t\tgoto free_pages;\n\t\t}\n\t}\n\n\t \n\ttotal_compressed = ALIGN(total_compressed, blocksize);\n\n\t \n\ttotal_in = round_up(total_in, fs_info->sectorsize);\n\tif (total_compressed + blocksize > total_in)\n\t\tgoto mark_incompressible;\n\n\t \n\tadd_async_extent(async_chunk, start, total_in, total_compressed, pages,\n\t\t\t nr_pages, compress_type);\n\tif (start + total_in < end) {\n\t\tstart += total_in;\n\t\tcond_resched();\n\t\tgoto again;\n\t}\n\treturn;\n\nmark_incompressible:\n\tif (!btrfs_test_opt(fs_info, FORCE_COMPRESS) && !inode->prop_compress)\n\t\tinode->flags |= BTRFS_INODE_NOCOMPRESS;\ncleanup_and_bail_uncompressed:\n\tadd_async_extent(async_chunk, start, end - start + 1, 0, NULL, 0,\n\t\t\t BTRFS_COMPRESS_NONE);\nfree_pages:\n\tif (pages) {\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tWARN_ON(pages[i]->mapping);\n\t\t\tput_page(pages[i]);\n\t\t}\n\t\tkfree(pages);\n\t}\n}\n\nstatic void free_async_extent_pages(struct async_extent *async_extent)\n{\n\tint i;\n\n\tif (!async_extent->pages)\n\t\treturn;\n\n\tfor (i = 0; i < async_extent->nr_pages; i++) {\n\t\tWARN_ON(async_extent->pages[i]->mapping);\n\t\tput_page(async_extent->pages[i]);\n\t}\n\tkfree(async_extent->pages);\n\tasync_extent->nr_pages = 0;\n\tasync_extent->pages = NULL;\n}\n\nstatic void submit_uncompressed_range(struct btrfs_inode *inode,\n\t\t\t\t      struct async_extent *async_extent,\n\t\t\t\t      struct page *locked_page)\n{\n\tu64 start = async_extent->start;\n\tu64 end = async_extent->start + async_extent->ram_size - 1;\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t\t= WB_SYNC_ALL,\n\t\t.range_start\t\t= start,\n\t\t.range_end\t\t= end,\n\t\t.no_cgroup_owner\t= 1,\n\t};\n\n\twbc_attach_fdatawrite_inode(&wbc, &inode->vfs_inode);\n\tret = run_delalloc_cow(inode, locked_page, start, end, &wbc, false);\n\twbc_detach_inode(&wbc);\n\tif (ret < 0) {\n\t\tbtrfs_cleanup_ordered_extents(inode, locked_page, start, end - start + 1);\n\t\tif (locked_page) {\n\t\t\tconst u64 page_start = page_offset(locked_page);\n\n\t\t\tset_page_writeback(locked_page);\n\t\t\tend_page_writeback(locked_page);\n\t\t\tbtrfs_mark_ordered_io_finished(inode, locked_page,\n\t\t\t\t\t\t       page_start, PAGE_SIZE,\n\t\t\t\t\t\t       !ret);\n\t\t\tmapping_set_error(locked_page->mapping, ret);\n\t\t\tunlock_page(locked_page);\n\t\t}\n\t}\n}\n\nstatic void submit_one_async_extent(struct async_chunk *async_chunk,\n\t\t\t\t    struct async_extent *async_extent,\n\t\t\t\t    u64 *alloc_hint)\n{\n\tstruct btrfs_inode *inode = async_chunk->inode;\n\tstruct extent_io_tree *io_tree = &inode->io_tree;\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct btrfs_key ins;\n\tstruct page *locked_page = NULL;\n\tstruct extent_map *em;\n\tint ret = 0;\n\tu64 start = async_extent->start;\n\tu64 end = async_extent->start + async_extent->ram_size - 1;\n\n\tif (async_chunk->blkcg_css)\n\t\tkthread_associate_blkcg(async_chunk->blkcg_css);\n\n\t \n\tif (async_chunk->locked_page) {\n\t\tu64 locked_page_start = page_offset(async_chunk->locked_page);\n\t\tu64 locked_page_end = locked_page_start + PAGE_SIZE - 1;\n\n\t\tif (!(start >= locked_page_end || end <= locked_page_start))\n\t\t\tlocked_page = async_chunk->locked_page;\n\t}\n\tlock_extent(io_tree, start, end, NULL);\n\n\tif (async_extent->compress_type == BTRFS_COMPRESS_NONE) {\n\t\tsubmit_uncompressed_range(inode, async_extent, locked_page);\n\t\tgoto done;\n\t}\n\n\tret = btrfs_reserve_extent(root, async_extent->ram_size,\n\t\t\t\t   async_extent->compressed_size,\n\t\t\t\t   async_extent->compressed_size,\n\t\t\t\t   0, *alloc_hint, &ins, 1, 1);\n\tif (ret) {\n\t\t \n\t\tgoto out_free;\n\t}\n\n\t \n\tem = create_io_em(inode, start,\n\t\t\t  async_extent->ram_size,\t \n\t\t\t  start,\t\t\t \n\t\t\t  ins.objectid,\t\t\t \n\t\t\t  ins.offset,\t\t\t \n\t\t\t  ins.offset,\t\t\t \n\t\t\t  async_extent->ram_size,\t \n\t\t\t  async_extent->compress_type,\n\t\t\t  BTRFS_ORDERED_COMPRESSED);\n\tif (IS_ERR(em)) {\n\t\tret = PTR_ERR(em);\n\t\tgoto out_free_reserve;\n\t}\n\tfree_extent_map(em);\n\n\tordered = btrfs_alloc_ordered_extent(inode, start,\t \n\t\t\t\t       async_extent->ram_size,\t \n\t\t\t\t       async_extent->ram_size,\t \n\t\t\t\t       ins.objectid,\t\t \n\t\t\t\t       ins.offset,\t\t \n\t\t\t\t       0,\t\t\t \n\t\t\t\t       1 << BTRFS_ORDERED_COMPRESSED,\n\t\t\t\t       async_extent->compress_type);\n\tif (IS_ERR(ordered)) {\n\t\tbtrfs_drop_extent_map_range(inode, start, end, false);\n\t\tret = PTR_ERR(ordered);\n\t\tgoto out_free_reserve;\n\t}\n\tbtrfs_dec_block_group_reservations(fs_info, ins.objectid);\n\n\t \n\textent_clear_unlock_delalloc(inode, start, end,\n\t\t\tNULL, EXTENT_LOCKED | EXTENT_DELALLOC,\n\t\t\tPAGE_UNLOCK | PAGE_START_WRITEBACK);\n\tbtrfs_submit_compressed_write(ordered,\n\t\t\t    async_extent->pages,\t \n\t\t\t    async_extent->nr_pages,\n\t\t\t    async_chunk->write_flags, true);\n\t*alloc_hint = ins.objectid + ins.offset;\ndone:\n\tif (async_chunk->blkcg_css)\n\t\tkthread_associate_blkcg(NULL);\n\tkfree(async_extent);\n\treturn;\n\nout_free_reserve:\n\tbtrfs_dec_block_group_reservations(fs_info, ins.objectid);\n\tbtrfs_free_reserved_extent(fs_info, ins.objectid, ins.offset, 1);\nout_free:\n\tmapping_set_error(inode->vfs_inode.i_mapping, -EIO);\n\textent_clear_unlock_delalloc(inode, start, end,\n\t\t\t\t     NULL, EXTENT_LOCKED | EXTENT_DELALLOC |\n\t\t\t\t     EXTENT_DELALLOC_NEW |\n\t\t\t\t     EXTENT_DEFRAG | EXTENT_DO_ACCOUNTING,\n\t\t\t\t     PAGE_UNLOCK | PAGE_START_WRITEBACK |\n\t\t\t\t     PAGE_END_WRITEBACK);\n\tfree_async_extent_pages(async_extent);\n\tif (async_chunk->blkcg_css)\n\t\tkthread_associate_blkcg(NULL);\n\tbtrfs_debug(fs_info,\n\"async extent submission failed root=%lld inode=%llu start=%llu len=%llu ret=%d\",\n\t\t    root->root_key.objectid, btrfs_ino(inode), start,\n\t\t    async_extent->ram_size, ret);\n\tkfree(async_extent);\n}\n\nstatic u64 get_extent_allocation_hint(struct btrfs_inode *inode, u64 start,\n\t\t\t\t      u64 num_bytes)\n{\n\tstruct extent_map_tree *em_tree = &inode->extent_tree;\n\tstruct extent_map *em;\n\tu64 alloc_hint = 0;\n\n\tread_lock(&em_tree->lock);\n\tem = search_extent_mapping(em_tree, start, num_bytes);\n\tif (em) {\n\t\t \n\t\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\t\tfree_extent_map(em);\n\t\t\tem = search_extent_mapping(em_tree, 0, 0);\n\t\t\tif (em && em->block_start < EXTENT_MAP_LAST_BYTE)\n\t\t\t\talloc_hint = em->block_start;\n\t\t\tif (em)\n\t\t\t\tfree_extent_map(em);\n\t\t} else {\n\t\t\talloc_hint = em->block_start;\n\t\t\tfree_extent_map(em);\n\t\t}\n\t}\n\tread_unlock(&em_tree->lock);\n\n\treturn alloc_hint;\n}\n\n \nstatic noinline int cow_file_range(struct btrfs_inode *inode,\n\t\t\t\t   struct page *locked_page, u64 start, u64 end,\n\t\t\t\t   u64 *done_offset,\n\t\t\t\t   bool keep_locked, bool no_inline)\n{\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 alloc_hint = 0;\n\tu64 orig_start = start;\n\tu64 num_bytes;\n\tunsigned long ram_size;\n\tu64 cur_alloc_size = 0;\n\tu64 min_alloc_size;\n\tu64 blocksize = fs_info->sectorsize;\n\tstruct btrfs_key ins;\n\tstruct extent_map *em;\n\tunsigned clear_bits;\n\tunsigned long page_ops;\n\tbool extent_reserved = false;\n\tint ret = 0;\n\n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tnum_bytes = ALIGN(end - start + 1, blocksize);\n\tnum_bytes = max(blocksize,  num_bytes);\n\tASSERT(num_bytes <= btrfs_super_total_bytes(fs_info->super_copy));\n\n\tinode_should_defrag(inode, start, end, num_bytes, SZ_64K);\n\n\t \n\tif (start == 0 && fs_info->sectorsize == PAGE_SIZE && !no_inline) {\n\t\tu64 actual_end = min_t(u64, i_size_read(&inode->vfs_inode),\n\t\t\t\t       end + 1);\n\n\t\t \n\t\tret = cow_file_range_inline(inode, actual_end, 0,\n\t\t\t\t\t    BTRFS_COMPRESS_NONE, NULL, false);\n\t\tif (ret == 0) {\n\t\t\t \n\t\t\textent_clear_unlock_delalloc(inode, start, end,\n\t\t\t\t     locked_page,\n\t\t\t\t     EXTENT_LOCKED | EXTENT_DELALLOC |\n\t\t\t\t     EXTENT_DELALLOC_NEW | EXTENT_DEFRAG |\n\t\t\t\t     EXTENT_DO_ACCOUNTING, PAGE_UNLOCK |\n\t\t\t\t     PAGE_START_WRITEBACK | PAGE_END_WRITEBACK);\n\t\t\t \n\t\t\tunlock_page(locked_page);\n\t\t\tret = 1;\n\t\t\tgoto done;\n\t\t} else if (ret < 0) {\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\talloc_hint = get_extent_allocation_hint(inode, start, num_bytes);\n\n\t \n\tif (btrfs_is_data_reloc_root(root))\n\t\tmin_alloc_size = num_bytes;\n\telse\n\t\tmin_alloc_size = fs_info->sectorsize;\n\n\twhile (num_bytes > 0) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\n\t\tcur_alloc_size = num_bytes;\n\t\tret = btrfs_reserve_extent(root, cur_alloc_size, cur_alloc_size,\n\t\t\t\t\t   min_alloc_size, 0, alloc_hint,\n\t\t\t\t\t   &ins, 1, 1);\n\t\tif (ret == -EAGAIN) {\n\t\t\t \n\t\t\tASSERT(btrfs_is_zoned(fs_info));\n\t\t\tif (start == orig_start) {\n\t\t\t\twait_on_bit_io(&inode->root->fs_info->flags,\n\t\t\t\t\t       BTRFS_FS_NEED_ZONE_FINISH,\n\t\t\t\t\t       TASK_UNINTERRUPTIBLE);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (done_offset) {\n\t\t\t\t*done_offset = start - 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tret = -ENOSPC;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out_unlock;\n\t\tcur_alloc_size = ins.offset;\n\t\textent_reserved = true;\n\n\t\tram_size = ins.offset;\n\t\tem = create_io_em(inode, start, ins.offset,  \n\t\t\t\t  start,  \n\t\t\t\t  ins.objectid,  \n\t\t\t\t  ins.offset,  \n\t\t\t\t  ins.offset,  \n\t\t\t\t  ram_size,  \n\t\t\t\t  BTRFS_COMPRESS_NONE,  \n\t\t\t\t  BTRFS_ORDERED_REGULAR  );\n\t\tif (IS_ERR(em)) {\n\t\t\tret = PTR_ERR(em);\n\t\t\tgoto out_reserve;\n\t\t}\n\t\tfree_extent_map(em);\n\n\t\tordered = btrfs_alloc_ordered_extent(inode, start, ram_size,\n\t\t\t\t\tram_size, ins.objectid, cur_alloc_size,\n\t\t\t\t\t0, 1 << BTRFS_ORDERED_REGULAR,\n\t\t\t\t\tBTRFS_COMPRESS_NONE);\n\t\tif (IS_ERR(ordered)) {\n\t\t\tret = PTR_ERR(ordered);\n\t\t\tgoto out_drop_extent_cache;\n\t\t}\n\n\t\tif (btrfs_is_data_reloc_root(root)) {\n\t\t\tret = btrfs_reloc_clone_csums(ordered);\n\n\t\t\t \n\t\t\tif (ret)\n\t\t\t\tbtrfs_drop_extent_map_range(inode, start,\n\t\t\t\t\t\t\t    start + ram_size - 1,\n\t\t\t\t\t\t\t    false);\n\t\t}\n\t\tbtrfs_put_ordered_extent(ordered);\n\n\t\tbtrfs_dec_block_group_reservations(fs_info, ins.objectid);\n\n\t\t \n\t\tpage_ops = (keep_locked ? 0 : PAGE_UNLOCK);\n\t\tpage_ops |= PAGE_SET_ORDERED;\n\n\t\textent_clear_unlock_delalloc(inode, start, start + ram_size - 1,\n\t\t\t\t\t     locked_page,\n\t\t\t\t\t     EXTENT_LOCKED | EXTENT_DELALLOC,\n\t\t\t\t\t     page_ops);\n\t\tif (num_bytes < cur_alloc_size)\n\t\t\tnum_bytes = 0;\n\t\telse\n\t\t\tnum_bytes -= cur_alloc_size;\n\t\talloc_hint = ins.objectid + ins.offset;\n\t\tstart += cur_alloc_size;\n\t\textent_reserved = false;\n\n\t\t \n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\ndone:\n\tif (done_offset)\n\t\t*done_offset = end;\n\treturn ret;\n\nout_drop_extent_cache:\n\tbtrfs_drop_extent_map_range(inode, start, start + ram_size - 1, false);\nout_reserve:\n\tbtrfs_dec_block_group_reservations(fs_info, ins.objectid);\n\tbtrfs_free_reserved_extent(fs_info, ins.objectid, ins.offset, 1);\nout_unlock:\n\t \n\n\tclear_bits = EXTENT_LOCKED | EXTENT_DELALLOC | EXTENT_DELALLOC_NEW |\n\t\tEXTENT_DEFRAG | EXTENT_CLEAR_META_RESV;\n\tpage_ops = PAGE_UNLOCK | PAGE_START_WRITEBACK | PAGE_END_WRITEBACK;\n\n\t \n\tif (keep_locked && orig_start < start) {\n\t\tif (!locked_page)\n\t\t\tmapping_set_error(inode->vfs_inode.i_mapping, ret);\n\t\textent_clear_unlock_delalloc(inode, orig_start, start - 1,\n\t\t\t\t\t     locked_page, 0, page_ops);\n\t}\n\n\t \n\tif (extent_reserved) {\n\t\textent_clear_unlock_delalloc(inode, start,\n\t\t\t\t\t     start + cur_alloc_size - 1,\n\t\t\t\t\t     locked_page,\n\t\t\t\t\t     clear_bits,\n\t\t\t\t\t     page_ops);\n\t\tstart += cur_alloc_size;\n\t}\n\n\t \n\tif (start < end) {\n\t\tclear_bits |= EXTENT_CLEAR_DATA_RESV;\n\t\textent_clear_unlock_delalloc(inode, start, end, locked_page,\n\t\t\t\t\t     clear_bits, page_ops);\n\t}\n\treturn ret;\n}\n\n \nstatic noinline void submit_compressed_extents(struct btrfs_work *work)\n{\n\tstruct async_chunk *async_chunk = container_of(work, struct async_chunk,\n\t\t\t\t\t\t     work);\n\tstruct btrfs_fs_info *fs_info = btrfs_work_owner(work);\n\tstruct async_extent *async_extent;\n\tunsigned long nr_pages;\n\tu64 alloc_hint = 0;\n\n\tnr_pages = (async_chunk->end - async_chunk->start + PAGE_SIZE) >>\n\t\tPAGE_SHIFT;\n\n\twhile (!list_empty(&async_chunk->extents)) {\n\t\tasync_extent = list_entry(async_chunk->extents.next,\n\t\t\t\t\t  struct async_extent, list);\n\t\tlist_del(&async_extent->list);\n\t\tsubmit_one_async_extent(async_chunk, async_extent, &alloc_hint);\n\t}\n\n\t \n\tif (atomic_sub_return(nr_pages, &fs_info->async_delalloc_pages) <\n\t    5 * SZ_1M)\n\t\tcond_wake_up_nomb(&fs_info->async_submit_wait);\n}\n\nstatic noinline void async_cow_free(struct btrfs_work *work)\n{\n\tstruct async_chunk *async_chunk;\n\tstruct async_cow *async_cow;\n\n\tasync_chunk = container_of(work, struct async_chunk, work);\n\tbtrfs_add_delayed_iput(async_chunk->inode);\n\tif (async_chunk->blkcg_css)\n\t\tcss_put(async_chunk->blkcg_css);\n\n\tasync_cow = async_chunk->async_cow;\n\tif (atomic_dec_and_test(&async_cow->num_chunks))\n\t\tkvfree(async_cow);\n}\n\nstatic bool run_delalloc_compressed(struct btrfs_inode *inode,\n\t\t\t\t    struct page *locked_page, u64 start,\n\t\t\t\t    u64 end, struct writeback_control *wbc)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tstruct cgroup_subsys_state *blkcg_css = wbc_blkcg_css(wbc);\n\tstruct async_cow *ctx;\n\tstruct async_chunk *async_chunk;\n\tunsigned long nr_pages;\n\tu64 num_chunks = DIV_ROUND_UP(end - start, SZ_512K);\n\tint i;\n\tunsigned nofs_flag;\n\tconst blk_opf_t write_flags = wbc_to_write_flags(wbc);\n\n\tnofs_flag = memalloc_nofs_save();\n\tctx = kvmalloc(struct_size(ctx, chunks, num_chunks), GFP_KERNEL);\n\tmemalloc_nofs_restore(nofs_flag);\n\tif (!ctx)\n\t\treturn false;\n\n\tunlock_extent(&inode->io_tree, start, end, NULL);\n\tset_bit(BTRFS_INODE_HAS_ASYNC_EXTENT, &inode->runtime_flags);\n\n\tasync_chunk = ctx->chunks;\n\tatomic_set(&ctx->num_chunks, num_chunks);\n\n\tfor (i = 0; i < num_chunks; i++) {\n\t\tu64 cur_end = min(end, start + SZ_512K - 1);\n\n\t\t \n\t\tihold(&inode->vfs_inode);\n\t\tasync_chunk[i].async_cow = ctx;\n\t\tasync_chunk[i].inode = inode;\n\t\tasync_chunk[i].start = start;\n\t\tasync_chunk[i].end = cur_end;\n\t\tasync_chunk[i].write_flags = write_flags;\n\t\tINIT_LIST_HEAD(&async_chunk[i].extents);\n\n\t\t \n\t\tif (locked_page) {\n\t\t\t \n\t\t\twbc_account_cgroup_owner(wbc, locked_page,\n\t\t\t\t\t\t cur_end - start);\n\t\t\tasync_chunk[i].locked_page = locked_page;\n\t\t\tlocked_page = NULL;\n\t\t} else {\n\t\t\tasync_chunk[i].locked_page = NULL;\n\t\t}\n\n\t\tif (blkcg_css != blkcg_root_css) {\n\t\t\tcss_get(blkcg_css);\n\t\t\tasync_chunk[i].blkcg_css = blkcg_css;\n\t\t\tasync_chunk[i].write_flags |= REQ_BTRFS_CGROUP_PUNT;\n\t\t} else {\n\t\t\tasync_chunk[i].blkcg_css = NULL;\n\t\t}\n\n\t\tbtrfs_init_work(&async_chunk[i].work, compress_file_range,\n\t\t\t\tsubmit_compressed_extents, async_cow_free);\n\n\t\tnr_pages = DIV_ROUND_UP(cur_end - start, PAGE_SIZE);\n\t\tatomic_add(nr_pages, &fs_info->async_delalloc_pages);\n\n\t\tbtrfs_queue_work(fs_info->delalloc_workers, &async_chunk[i].work);\n\n\t\tstart = cur_end + 1;\n\t}\n\treturn true;\n}\n\n \nstatic noinline int run_delalloc_cow(struct btrfs_inode *inode,\n\t\t\t\t     struct page *locked_page, u64 start,\n\t\t\t\t     u64 end, struct writeback_control *wbc,\n\t\t\t\t     bool pages_dirty)\n{\n\tu64 done_offset = end;\n\tint ret;\n\n\twhile (start <= end) {\n\t\tret = cow_file_range(inode, locked_page, start, end, &done_offset,\n\t\t\t\t     true, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\textent_write_locked_range(&inode->vfs_inode, locked_page, start,\n\t\t\t\t\t  done_offset, wbc, pages_dirty);\n\t\tstart = done_offset + 1;\n\t}\n\n\treturn 1;\n}\n\nstatic noinline int csum_exist_in_range(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tu64 bytenr, u64 num_bytes, bool nowait)\n{\n\tstruct btrfs_root *csum_root = btrfs_csum_root(fs_info, bytenr);\n\tstruct btrfs_ordered_sum *sums;\n\tint ret;\n\tLIST_HEAD(list);\n\n\tret = btrfs_lookup_csums_list(csum_root, bytenr, bytenr + num_bytes - 1,\n\t\t\t\t      &list, 0, nowait);\n\tif (ret == 0 && list_empty(&list))\n\t\treturn 0;\n\n\twhile (!list_empty(&list)) {\n\t\tsums = list_entry(list.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 1;\n}\n\nstatic int fallback_to_cow(struct btrfs_inode *inode, struct page *locked_page,\n\t\t\t   const u64 start, const u64 end)\n{\n\tconst bool is_space_ino = btrfs_is_free_space_inode(inode);\n\tconst bool is_reloc_ino = btrfs_is_data_reloc_root(inode->root);\n\tconst u64 range_bytes = end + 1 - start;\n\tstruct extent_io_tree *io_tree = &inode->io_tree;\n\tu64 range_start = start;\n\tu64 count;\n\tint ret;\n\n\t \n\tcount = count_range_bits(io_tree, &range_start, end, range_bytes,\n\t\t\t\t EXTENT_NORESERVE, 0, NULL);\n\tif (count > 0 || is_space_ino || is_reloc_ino) {\n\t\tu64 bytes = count;\n\t\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\t\tstruct btrfs_space_info *sinfo = fs_info->data_sinfo;\n\n\t\tif (is_space_ino || is_reloc_ino)\n\t\t\tbytes = range_bytes;\n\n\t\tspin_lock(&sinfo->lock);\n\t\tbtrfs_space_info_update_bytes_may_use(fs_info, sinfo, bytes);\n\t\tspin_unlock(&sinfo->lock);\n\n\t\tif (count > 0)\n\t\t\tclear_extent_bit(io_tree, start, end, EXTENT_NORESERVE,\n\t\t\t\t\t NULL);\n\t}\n\n\t \n\tret = cow_file_range(inode, locked_page, start, end, NULL, false, true);\n\tASSERT(ret != 1);\n\treturn ret;\n}\n\nstruct can_nocow_file_extent_args {\n\t \n\n\t \n\tu64 start;\n\t \n\tu64 end;\n\tbool writeback_path;\n\tbool strict;\n\t \n\tbool free_path;\n\n\t \n\n\tu64 disk_bytenr;\n\tu64 disk_num_bytes;\n\tu64 extent_offset;\n\t \n\tu64 num_bytes;\n};\n\n \nstatic int can_nocow_file_extent(struct btrfs_path *path,\n\t\t\t\t struct btrfs_key *key,\n\t\t\t\t struct btrfs_inode *inode,\n\t\t\t\t struct can_nocow_file_extent_args *args)\n{\n\tconst bool is_freespace_inode = btrfs_is_free_space_inode(inode);\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_file_extent_item *fi;\n\tu64 extent_end;\n\tu8 extent_type;\n\tint can_nocow = 0;\n\tint ret = 0;\n\tbool nowait = path->nowait;\n\n\tfi = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_file_extent_item);\n\textent_type = btrfs_file_extent_type(leaf, fi);\n\n\tif (extent_type == BTRFS_FILE_EXTENT_INLINE)\n\t\tgoto out;\n\n\t \n\targs->disk_bytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\targs->disk_num_bytes = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\targs->extent_offset = btrfs_file_extent_offset(leaf, fi);\n\n\tif (!(inode->flags & BTRFS_INODE_NODATACOW) &&\n\t    extent_type == BTRFS_FILE_EXTENT_REG)\n\t\tgoto out;\n\n\t \n\tif (!args->strict &&\n\t    btrfs_file_extent_generation(leaf, fi) <=\n\t    btrfs_root_last_snapshot(&root->root_item))\n\t\tgoto out;\n\n\t \n\tif (args->disk_bytenr == 0)\n\t\tgoto out;\n\n\t \n\tif (btrfs_file_extent_compression(leaf, fi) ||\n\t    btrfs_file_extent_encryption(leaf, fi) ||\n\t    btrfs_file_extent_other_encoding(leaf, fi))\n\t\tgoto out;\n\n\textent_end = btrfs_file_extent_end(path);\n\n\t \n\tbtrfs_release_path(path);\n\n\tret = btrfs_cross_ref_exist(root, btrfs_ino(inode),\n\t\t\t\t    key->offset - args->extent_offset,\n\t\t\t\t    args->disk_bytenr, args->strict, path);\n\tWARN_ON_ONCE(ret > 0 && is_freespace_inode);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tif (args->free_path) {\n\t\t \n\t\tbtrfs_free_path(path);\n\t\tpath = NULL;\n\t}\n\n\t \n\tif (args->writeback_path && !is_freespace_inode &&\n\t    atomic_read(&root->snapshot_force_cow))\n\t\tgoto out;\n\n\targs->disk_bytenr += args->extent_offset;\n\targs->disk_bytenr += args->start - key->offset;\n\targs->num_bytes = min(args->end + 1, extent_end) - args->start;\n\n\t \n\tret = csum_exist_in_range(root->fs_info, args->disk_bytenr, args->num_bytes,\n\t\t\t\t  nowait);\n\tWARN_ON_ONCE(ret > 0 && is_freespace_inode);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tcan_nocow = 1;\n out:\n\tif (args->free_path && path)\n\t\tbtrfs_free_path(path);\n\n\treturn ret < 0 ? ret : can_nocow;\n}\n\n \nstatic noinline int run_delalloc_nocow(struct btrfs_inode *inode,\n\t\t\t\t       struct page *locked_page,\n\t\t\t\t       const u64 start, const u64 end)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_path *path;\n\tu64 cow_start = (u64)-1;\n\tu64 cur_offset = start;\n\tint ret;\n\tbool check_prev = true;\n\tu64 ino = btrfs_ino(inode);\n\tstruct can_nocow_file_extent_args nocow_args = { 0 };\n\n\t \n\tASSERT(!btrfs_is_zoned(fs_info) || btrfs_is_data_reloc_root(root));\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tnocow_args.end = end;\n\tnocow_args.writeback_path = true;\n\n\twhile (1) {\n\t\tstruct btrfs_block_group *nocow_bg = NULL;\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tstruct btrfs_key found_key;\n\t\tstruct btrfs_file_extent_item *fi;\n\t\tstruct extent_buffer *leaf;\n\t\tu64 extent_end;\n\t\tu64 ram_bytes;\n\t\tu64 nocow_end;\n\t\tint extent_type;\n\t\tbool is_prealloc;\n\n\t\tret = btrfs_lookup_file_extent(NULL, root, path, ino,\n\t\t\t\t\t       cur_offset, 0);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tif (ret > 0 && path->slots[0] > 0 && check_prev) {\n\t\t\tleaf = path->nodes[0];\n\t\t\tbtrfs_item_key_to_cpu(leaf, &found_key,\n\t\t\t\t\t      path->slots[0] - 1);\n\t\t\tif (found_key.objectid == ino &&\n\t\t\t    found_key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t\tcheck_prev = false;\nnext_slot:\n\t\t \n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\t\t \n\t\tif (found_key.objectid > ino)\n\t\t\tbreak;\n\t\t \n\t\tif (WARN_ON_ONCE(found_key.objectid < ino) ||\n\t\t    found_key.type < BTRFS_EXTENT_DATA_KEY) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\t \n\t\tif (found_key.type > BTRFS_EXTENT_DATA_KEY ||\n\t\t    found_key.offset > end)\n\t\t\tbreak;\n\n\t\t \n\t\tif (found_key.offset > cur_offset) {\n\t\t\textent_end = found_key.offset;\n\t\t\textent_type = 0;\n\t\t\tgoto must_cow;\n\t\t}\n\n\t\t \n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\textent_type = btrfs_file_extent_type(leaf, fi);\n\t\t \n\t\tASSERT(extent_type < BTRFS_NR_FILE_EXTENT_TYPES);\n\t\tif (WARN_ON(extent_type >= BTRFS_NR_FILE_EXTENT_TYPES)) {\n\t\t\tret = -EUCLEAN;\n\t\t\tgoto error;\n\t\t}\n\t\tram_bytes = btrfs_file_extent_ram_bytes(leaf, fi);\n\t\textent_end = btrfs_file_extent_end(path);\n\n\t\t \n\t\tif (extent_end <= cur_offset) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\tnocow_args.start = cur_offset;\n\t\tret = can_nocow_file_extent(path, &found_key, inode, &nocow_args);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tif (ret == 0)\n\t\t\tgoto must_cow;\n\n\t\tret = 0;\n\t\tnocow_bg = btrfs_inc_nocow_writers(fs_info, nocow_args.disk_bytenr);\n\t\tif (!nocow_bg) {\nmust_cow:\n\t\t\t \n\t\t\tif (cow_start == (u64)-1)\n\t\t\t\tcow_start = cur_offset;\n\t\t\tcur_offset = extent_end;\n\t\t\tif (cur_offset > end)\n\t\t\t\tbreak;\n\t\t\tif (!path->nodes[0])\n\t\t\t\tcontinue;\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\t \n\t\tif (cow_start != (u64)-1) {\n\t\t\tret = fallback_to_cow(inode, locked_page,\n\t\t\t\t\t      cow_start, found_key.offset - 1);\n\t\t\tcow_start = (u64)-1;\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_dec_nocow_writers(nocow_bg);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tnocow_end = cur_offset + nocow_args.num_bytes - 1;\n\t\tis_prealloc = extent_type == BTRFS_FILE_EXTENT_PREALLOC;\n\t\tif (is_prealloc) {\n\t\t\tu64 orig_start = found_key.offset - nocow_args.extent_offset;\n\t\t\tstruct extent_map *em;\n\n\t\t\tem = create_io_em(inode, cur_offset, nocow_args.num_bytes,\n\t\t\t\t\t  orig_start,\n\t\t\t\t\t  nocow_args.disk_bytenr,  \n\t\t\t\t\t  nocow_args.num_bytes,  \n\t\t\t\t\t  nocow_args.disk_num_bytes,  \n\t\t\t\t\t  ram_bytes, BTRFS_COMPRESS_NONE,\n\t\t\t\t\t  BTRFS_ORDERED_PREALLOC);\n\t\t\tif (IS_ERR(em)) {\n\t\t\t\tbtrfs_dec_nocow_writers(nocow_bg);\n\t\t\t\tret = PTR_ERR(em);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tfree_extent_map(em);\n\t\t}\n\n\t\tordered = btrfs_alloc_ordered_extent(inode, cur_offset,\n\t\t\t\tnocow_args.num_bytes, nocow_args.num_bytes,\n\t\t\t\tnocow_args.disk_bytenr, nocow_args.num_bytes, 0,\n\t\t\t\tis_prealloc\n\t\t\t\t? (1 << BTRFS_ORDERED_PREALLOC)\n\t\t\t\t: (1 << BTRFS_ORDERED_NOCOW),\n\t\t\t\tBTRFS_COMPRESS_NONE);\n\t\tbtrfs_dec_nocow_writers(nocow_bg);\n\t\tif (IS_ERR(ordered)) {\n\t\t\tif (is_prealloc) {\n\t\t\t\tbtrfs_drop_extent_map_range(inode, cur_offset,\n\t\t\t\t\t\t\t    nocow_end, false);\n\t\t\t}\n\t\t\tret = PTR_ERR(ordered);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (btrfs_is_data_reloc_root(root))\n\t\t\t \n\t\t\tret = btrfs_reloc_clone_csums(ordered);\n\t\tbtrfs_put_ordered_extent(ordered);\n\n\t\textent_clear_unlock_delalloc(inode, cur_offset, nocow_end,\n\t\t\t\t\t     locked_page, EXTENT_LOCKED |\n\t\t\t\t\t     EXTENT_DELALLOC |\n\t\t\t\t\t     EXTENT_CLEAR_DATA_RESV,\n\t\t\t\t\t     PAGE_UNLOCK | PAGE_SET_ORDERED);\n\n\t\tcur_offset = extent_end;\n\n\t\t \n\t\tif (ret)\n\t\t\tgoto error;\n\t\tif (cur_offset > end)\n\t\t\tbreak;\n\t}\n\tbtrfs_release_path(path);\n\n\tif (cur_offset <= end && cow_start == (u64)-1)\n\t\tcow_start = cur_offset;\n\n\tif (cow_start != (u64)-1) {\n\t\tcur_offset = end;\n\t\tret = fallback_to_cow(inode, locked_page, cow_start, end);\n\t\tcow_start = (u64)-1;\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tbtrfs_free_path(path);\n\treturn 0;\n\nerror:\n\t \n\tif (cow_start != (u64)-1)\n\t\tcur_offset = cow_start;\n\tif (cur_offset < end)\n\t\textent_clear_unlock_delalloc(inode, cur_offset, end,\n\t\t\t\t\t     locked_page, EXTENT_LOCKED |\n\t\t\t\t\t     EXTENT_DELALLOC | EXTENT_DEFRAG |\n\t\t\t\t\t     EXTENT_DO_ACCOUNTING, PAGE_UNLOCK |\n\t\t\t\t\t     PAGE_START_WRITEBACK |\n\t\t\t\t\t     PAGE_END_WRITEBACK);\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic bool should_nocow(struct btrfs_inode *inode, u64 start, u64 end)\n{\n\tif (inode->flags & (BTRFS_INODE_NODATACOW | BTRFS_INODE_PREALLOC)) {\n\t\tif (inode->defrag_bytes &&\n\t\t    test_range_bit(&inode->io_tree, start, end, EXTENT_DEFRAG,\n\t\t\t\t   0, NULL))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nint btrfs_run_delalloc_range(struct btrfs_inode *inode, struct page *locked_page,\n\t\t\t     u64 start, u64 end, struct writeback_control *wbc)\n{\n\tconst bool zoned = btrfs_is_zoned(inode->root->fs_info);\n\tint ret;\n\n\t \n\tASSERT(!(end <= page_offset(locked_page) ||\n\t\t start >= page_offset(locked_page) + PAGE_SIZE));\n\n\tif (should_nocow(inode, start, end)) {\n\t\tret = run_delalloc_nocow(inode, locked_page, start, end);\n\t\tgoto out;\n\t}\n\n\tif (btrfs_inode_can_compress(inode) &&\n\t    inode_need_compress(inode, start, end) &&\n\t    run_delalloc_compressed(inode, locked_page, start, end, wbc))\n\t\treturn 1;\n\n\tif (zoned)\n\t\tret = run_delalloc_cow(inode, locked_page, start, end, wbc,\n\t\t\t\t       true);\n\telse\n\t\tret = cow_file_range(inode, locked_page, start, end, NULL,\n\t\t\t\t     false, false);\n\nout:\n\tif (ret < 0)\n\t\tbtrfs_cleanup_ordered_extents(inode, locked_page, start,\n\t\t\t\t\t      end - start + 1);\n\treturn ret;\n}\n\nvoid btrfs_split_delalloc_extent(struct btrfs_inode *inode,\n\t\t\t\t struct extent_state *orig, u64 split)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tu64 size;\n\n\t \n\tif (!(orig->state & EXTENT_DELALLOC))\n\t\treturn;\n\n\tsize = orig->end - orig->start + 1;\n\tif (size > fs_info->max_extent_size) {\n\t\tu32 num_extents;\n\t\tu64 new_size;\n\n\t\t \n\t\tnew_size = orig->end - split + 1;\n\t\tnum_extents = count_max_extents(fs_info, new_size);\n\t\tnew_size = split - orig->start;\n\t\tnum_extents += count_max_extents(fs_info, new_size);\n\t\tif (count_max_extents(fs_info, size) >= num_extents)\n\t\t\treturn;\n\t}\n\n\tspin_lock(&inode->lock);\n\tbtrfs_mod_outstanding_extents(inode, 1);\n\tspin_unlock(&inode->lock);\n}\n\n \nvoid btrfs_merge_delalloc_extent(struct btrfs_inode *inode, struct extent_state *new,\n\t\t\t\t struct extent_state *other)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tu64 new_size, old_size;\n\tu32 num_extents;\n\n\t \n\tif (!(other->state & EXTENT_DELALLOC))\n\t\treturn;\n\n\tif (new->start > other->start)\n\t\tnew_size = new->end - other->start + 1;\n\telse\n\t\tnew_size = other->end - new->start + 1;\n\n\t \n\tif (new_size <= fs_info->max_extent_size) {\n\t\tspin_lock(&inode->lock);\n\t\tbtrfs_mod_outstanding_extents(inode, -1);\n\t\tspin_unlock(&inode->lock);\n\t\treturn;\n\t}\n\n\t \n\told_size = other->end - other->start + 1;\n\tnum_extents = count_max_extents(fs_info, old_size);\n\told_size = new->end - new->start + 1;\n\tnum_extents += count_max_extents(fs_info, old_size);\n\tif (count_max_extents(fs_info, new_size) >= num_extents)\n\t\treturn;\n\n\tspin_lock(&inode->lock);\n\tbtrfs_mod_outstanding_extents(inode, -1);\n\tspin_unlock(&inode->lock);\n}\n\nstatic void btrfs_add_delalloc_inodes(struct btrfs_root *root,\n\t\t\t\t      struct btrfs_inode *inode)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\n\tspin_lock(&root->delalloc_lock);\n\tif (list_empty(&inode->delalloc_inodes)) {\n\t\tlist_add_tail(&inode->delalloc_inodes, &root->delalloc_inodes);\n\t\tset_bit(BTRFS_INODE_IN_DELALLOC_LIST, &inode->runtime_flags);\n\t\troot->nr_delalloc_inodes++;\n\t\tif (root->nr_delalloc_inodes == 1) {\n\t\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t\t\tBUG_ON(!list_empty(&root->delalloc_root));\n\t\t\tlist_add_tail(&root->delalloc_root,\n\t\t\t\t      &fs_info->delalloc_roots);\n\t\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\t\t}\n\t}\n\tspin_unlock(&root->delalloc_lock);\n}\n\nvoid __btrfs_del_delalloc_inode(struct btrfs_root *root,\n\t\t\t\tstruct btrfs_inode *inode)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (!list_empty(&inode->delalloc_inodes)) {\n\t\tlist_del_init(&inode->delalloc_inodes);\n\t\tclear_bit(BTRFS_INODE_IN_DELALLOC_LIST,\n\t\t\t  &inode->runtime_flags);\n\t\troot->nr_delalloc_inodes--;\n\t\tif (!root->nr_delalloc_inodes) {\n\t\t\tASSERT(list_empty(&root->delalloc_inodes));\n\t\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t\t\tBUG_ON(list_empty(&root->delalloc_root));\n\t\t\tlist_del_init(&root->delalloc_root);\n\t\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\t\t}\n\t}\n}\n\nstatic void btrfs_del_delalloc_inode(struct btrfs_root *root,\n\t\t\t\t     struct btrfs_inode *inode)\n{\n\tspin_lock(&root->delalloc_lock);\n\t__btrfs_del_delalloc_inode(root, inode);\n\tspin_unlock(&root->delalloc_lock);\n}\n\n \nvoid btrfs_set_delalloc_extent(struct btrfs_inode *inode, struct extent_state *state,\n\t\t\t       u32 bits)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\n\tif ((bits & EXTENT_DEFRAG) && !(bits & EXTENT_DELALLOC))\n\t\tWARN_ON(1);\n\t \n\tif (!(state->state & EXTENT_DELALLOC) && (bits & EXTENT_DELALLOC)) {\n\t\tstruct btrfs_root *root = inode->root;\n\t\tu64 len = state->end + 1 - state->start;\n\t\tu32 num_extents = count_max_extents(fs_info, len);\n\t\tbool do_list = !btrfs_is_free_space_inode(inode);\n\n\t\tspin_lock(&inode->lock);\n\t\tbtrfs_mod_outstanding_extents(inode, num_extents);\n\t\tspin_unlock(&inode->lock);\n\n\t\t \n\t\tif (btrfs_is_testing(fs_info))\n\t\t\treturn;\n\n\t\tpercpu_counter_add_batch(&fs_info->delalloc_bytes, len,\n\t\t\t\t\t fs_info->delalloc_batch);\n\t\tspin_lock(&inode->lock);\n\t\tinode->delalloc_bytes += len;\n\t\tif (bits & EXTENT_DEFRAG)\n\t\t\tinode->defrag_bytes += len;\n\t\tif (do_list && !test_bit(BTRFS_INODE_IN_DELALLOC_LIST,\n\t\t\t\t\t &inode->runtime_flags))\n\t\t\tbtrfs_add_delalloc_inodes(root, inode);\n\t\tspin_unlock(&inode->lock);\n\t}\n\n\tif (!(state->state & EXTENT_DELALLOC_NEW) &&\n\t    (bits & EXTENT_DELALLOC_NEW)) {\n\t\tspin_lock(&inode->lock);\n\t\tinode->new_delalloc_bytes += state->end + 1 - state->start;\n\t\tspin_unlock(&inode->lock);\n\t}\n}\n\n \nvoid btrfs_clear_delalloc_extent(struct btrfs_inode *inode,\n\t\t\t\t struct extent_state *state, u32 bits)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tu64 len = state->end + 1 - state->start;\n\tu32 num_extents = count_max_extents(fs_info, len);\n\n\tif ((state->state & EXTENT_DEFRAG) && (bits & EXTENT_DEFRAG)) {\n\t\tspin_lock(&inode->lock);\n\t\tinode->defrag_bytes -= len;\n\t\tspin_unlock(&inode->lock);\n\t}\n\n\t \n\tif ((state->state & EXTENT_DELALLOC) && (bits & EXTENT_DELALLOC)) {\n\t\tstruct btrfs_root *root = inode->root;\n\t\tbool do_list = !btrfs_is_free_space_inode(inode);\n\n\t\tspin_lock(&inode->lock);\n\t\tbtrfs_mod_outstanding_extents(inode, -num_extents);\n\t\tspin_unlock(&inode->lock);\n\n\t\t \n\t\tif (bits & EXTENT_CLEAR_META_RESV &&\n\t\t    root != fs_info->tree_root)\n\t\t\tbtrfs_delalloc_release_metadata(inode, len, false);\n\n\t\t \n\t\tif (btrfs_is_testing(fs_info))\n\t\t\treturn;\n\n\t\tif (!btrfs_is_data_reloc_root(root) &&\n\t\t    do_list && !(state->state & EXTENT_NORESERVE) &&\n\t\t    (bits & EXTENT_CLEAR_DATA_RESV))\n\t\t\tbtrfs_free_reserved_data_space_noquota(fs_info, len);\n\n\t\tpercpu_counter_add_batch(&fs_info->delalloc_bytes, -len,\n\t\t\t\t\t fs_info->delalloc_batch);\n\t\tspin_lock(&inode->lock);\n\t\tinode->delalloc_bytes -= len;\n\t\tif (do_list && inode->delalloc_bytes == 0 &&\n\t\t    test_bit(BTRFS_INODE_IN_DELALLOC_LIST,\n\t\t\t\t\t&inode->runtime_flags))\n\t\t\tbtrfs_del_delalloc_inode(root, inode);\n\t\tspin_unlock(&inode->lock);\n\t}\n\n\tif ((state->state & EXTENT_DELALLOC_NEW) &&\n\t    (bits & EXTENT_DELALLOC_NEW)) {\n\t\tspin_lock(&inode->lock);\n\t\tASSERT(inode->new_delalloc_bytes >= len);\n\t\tinode->new_delalloc_bytes -= len;\n\t\tif (bits & EXTENT_ADD_INODE_BYTES)\n\t\t\tinode_add_bytes(&inode->vfs_inode, len);\n\t\tspin_unlock(&inode->lock);\n\t}\n}\n\nstatic int btrfs_extract_ordered_extent(struct btrfs_bio *bbio,\n\t\t\t\t\tstruct btrfs_ordered_extent *ordered)\n{\n\tu64 start = (u64)bbio->bio.bi_iter.bi_sector << SECTOR_SHIFT;\n\tu64 len = bbio->bio.bi_iter.bi_size;\n\tstruct btrfs_ordered_extent *new;\n\tint ret;\n\n\t \n\tif (WARN_ON_ONCE(start != ordered->disk_bytenr))\n\t\treturn -EINVAL;\n\n\t \n\tif (ordered->disk_num_bytes == len) {\n\t\trefcount_inc(&ordered->refs);\n\t\tbbio->ordered = ordered;\n\t\treturn 0;\n\t}\n\n\t \n\tif (!test_bit(BTRFS_ORDERED_NOCOW, &ordered->flags)) {\n\t\tret = split_extent_map(bbio->inode, bbio->file_offset,\n\t\t\t\t       ordered->num_bytes, len,\n\t\t\t\t       ordered->disk_bytenr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tnew = btrfs_split_ordered_extent(ordered, len);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\tbbio->ordered = new;\n\treturn 0;\n}\n\n \nstatic int add_pending_csums(struct btrfs_trans_handle *trans,\n\t\t\t     struct list_head *list)\n{\n\tstruct btrfs_ordered_sum *sum;\n\tstruct btrfs_root *csum_root = NULL;\n\tint ret;\n\n\tlist_for_each_entry(sum, list, list) {\n\t\ttrans->adding_csums = true;\n\t\tif (!csum_root)\n\t\t\tcsum_root = btrfs_csum_root(trans->fs_info,\n\t\t\t\t\t\t    sum->logical);\n\t\tret = btrfs_csum_file_blocks(trans, csum_root, sum);\n\t\ttrans->adding_csums = false;\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int btrfs_find_new_delalloc_bytes(struct btrfs_inode *inode,\n\t\t\t\t\t const u64 start,\n\t\t\t\t\t const u64 len,\n\t\t\t\t\t struct extent_state **cached_state)\n{\n\tu64 search_start = start;\n\tconst u64 end = start + len - 1;\n\n\twhile (search_start < end) {\n\t\tconst u64 search_len = end - search_start + 1;\n\t\tstruct extent_map *em;\n\t\tu64 em_len;\n\t\tint ret = 0;\n\n\t\tem = btrfs_get_extent(inode, NULL, 0, search_start, search_len);\n\t\tif (IS_ERR(em))\n\t\t\treturn PTR_ERR(em);\n\n\t\tif (em->block_start != EXTENT_MAP_HOLE)\n\t\t\tgoto next;\n\n\t\tem_len = em->len;\n\t\tif (em->start < search_start)\n\t\t\tem_len -= search_start - em->start;\n\t\tif (em_len > search_len)\n\t\t\tem_len = search_len;\n\n\t\tret = set_extent_bit(&inode->io_tree, search_start,\n\t\t\t\t     search_start + em_len - 1,\n\t\t\t\t     EXTENT_DELALLOC_NEW, cached_state);\nnext:\n\t\tsearch_start = extent_map_end(em);\n\t\tfree_extent_map(em);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint btrfs_set_extent_delalloc(struct btrfs_inode *inode, u64 start, u64 end,\n\t\t\t      unsigned int extra_bits,\n\t\t\t      struct extent_state **cached_state)\n{\n\tWARN_ON(PAGE_ALIGNED(end));\n\n\tif (start >= i_size_read(&inode->vfs_inode) &&\n\t    !(inode->flags & BTRFS_INODE_PREALLOC)) {\n\t\t \n\t\textra_bits |= EXTENT_DELALLOC_NEW;\n\t} else {\n\t\tint ret;\n\n\t\tret = btrfs_find_new_delalloc_bytes(inode, start,\n\t\t\t\t\t\t    end + 1 - start,\n\t\t\t\t\t\t    cached_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn set_extent_bit(&inode->io_tree, start, end,\n\t\t\t      EXTENT_DELALLOC | extra_bits, cached_state);\n}\n\n \nstruct btrfs_writepage_fixup {\n\tstruct page *page;\n\tstruct btrfs_inode *inode;\n\tstruct btrfs_work work;\n};\n\nstatic void btrfs_writepage_fixup_worker(struct btrfs_work *work)\n{\n\tstruct btrfs_writepage_fixup *fixup =\n\t\tcontainer_of(work, struct btrfs_writepage_fixup, work);\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_changeset *data_reserved = NULL;\n\tstruct page *page = fixup->page;\n\tstruct btrfs_inode *inode = fixup->inode;\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tu64 page_start = page_offset(page);\n\tu64 page_end = page_offset(page) + PAGE_SIZE - 1;\n\tint ret = 0;\n\tbool free_delalloc_space = true;\n\n\t \n\tret = btrfs_delalloc_reserve_space(inode, &data_reserved, page_start,\n\t\t\t\t\t   PAGE_SIZE);\nagain:\n\tlock_page(page);\n\n\t \n\tif (!page->mapping || !PageDirty(page) || !PageChecked(page)) {\n\t\t \n\t\tif (!ret) {\n\t\t\tbtrfs_delalloc_release_extents(inode, PAGE_SIZE);\n\t\t\tbtrfs_delalloc_release_space(inode, data_reserved,\n\t\t\t\t\t\t     page_start, PAGE_SIZE,\n\t\t\t\t\t\t     true);\n\t\t}\n\t\tret = 0;\n\t\tgoto out_page;\n\t}\n\n\t \n\tif (ret)\n\t\tgoto out_page;\n\n\tlock_extent(&inode->io_tree, page_start, page_end, &cached_state);\n\n\t \n\tif (PageOrdered(page))\n\t\tgoto out_reserved;\n\n\tordered = btrfs_lookup_ordered_range(inode, page_start, PAGE_SIZE);\n\tif (ordered) {\n\t\tunlock_extent(&inode->io_tree, page_start, page_end,\n\t\t\t      &cached_state);\n\t\tunlock_page(page);\n\t\tbtrfs_start_ordered_extent(ordered);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tgoto again;\n\t}\n\n\tret = btrfs_set_extent_delalloc(inode, page_start, page_end, 0,\n\t\t\t\t\t&cached_state);\n\tif (ret)\n\t\tgoto out_reserved;\n\n\t \n\tBUG_ON(!PageDirty(page));\n\tfree_delalloc_space = false;\nout_reserved:\n\tbtrfs_delalloc_release_extents(inode, PAGE_SIZE);\n\tif (free_delalloc_space)\n\t\tbtrfs_delalloc_release_space(inode, data_reserved, page_start,\n\t\t\t\t\t     PAGE_SIZE, true);\n\tunlock_extent(&inode->io_tree, page_start, page_end, &cached_state);\nout_page:\n\tif (ret) {\n\t\t \n\t\tmapping_set_error(page->mapping, ret);\n\t\tbtrfs_mark_ordered_io_finished(inode, page, page_start,\n\t\t\t\t\t       PAGE_SIZE, !ret);\n\t\tclear_page_dirty_for_io(page);\n\t}\n\tbtrfs_page_clear_checked(fs_info, page, page_start, PAGE_SIZE);\n\tunlock_page(page);\n\tput_page(page);\n\tkfree(fixup);\n\textent_changeset_free(data_reserved);\n\t \n\tbtrfs_add_delayed_iput(inode);\n}\n\n \nint btrfs_writepage_cow_fixup(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_writepage_fixup *fixup;\n\n\t \n\tif (PageOrdered(page))\n\t\treturn 0;\n\n\t \n\tif (PageChecked(page))\n\t\treturn -EAGAIN;\n\n\tfixup = kzalloc(sizeof(*fixup), GFP_NOFS);\n\tif (!fixup)\n\t\treturn -EAGAIN;\n\n\t \n\tihold(inode);\n\tbtrfs_page_set_checked(fs_info, page, page_offset(page), PAGE_SIZE);\n\tget_page(page);\n\tbtrfs_init_work(&fixup->work, btrfs_writepage_fixup_worker, NULL, NULL);\n\tfixup->page = page;\n\tfixup->inode = BTRFS_I(inode);\n\tbtrfs_queue_work(fs_info->fixup_workers, &fixup->work);\n\n\treturn -EAGAIN;\n}\n\nstatic int insert_reserved_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_inode *inode, u64 file_pos,\n\t\t\t\t       struct btrfs_file_extent_item *stack_fi,\n\t\t\t\t       const bool update_inode_bytes,\n\t\t\t\t       u64 qgroup_reserved)\n{\n\tstruct btrfs_root *root = inode->root;\n\tconst u64 sectorsize = root->fs_info->sectorsize;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key ins;\n\tu64 disk_num_bytes = btrfs_stack_file_extent_disk_num_bytes(stack_fi);\n\tu64 disk_bytenr = btrfs_stack_file_extent_disk_bytenr(stack_fi);\n\tu64 offset = btrfs_stack_file_extent_offset(stack_fi);\n\tu64 num_bytes = btrfs_stack_file_extent_num_bytes(stack_fi);\n\tu64 ram_bytes = btrfs_stack_file_extent_ram_bytes(stack_fi);\n\tstruct btrfs_drop_extents_args drop_args = { 0 };\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t \n\tdrop_args.path = path;\n\tdrop_args.start = file_pos;\n\tdrop_args.end = file_pos + num_bytes;\n\tdrop_args.replace_extent = true;\n\tdrop_args.extent_item_size = sizeof(*stack_fi);\n\tret = btrfs_drop_extents(trans, root, inode, &drop_args);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!drop_args.extent_inserted) {\n\t\tins.objectid = btrfs_ino(inode);\n\t\tins.offset = file_pos;\n\t\tins.type = BTRFS_EXTENT_DATA_KEY;\n\n\t\tret = btrfs_insert_empty_item(trans, root, path, &ins,\n\t\t\t\t\t      sizeof(*stack_fi));\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tleaf = path->nodes[0];\n\tbtrfs_set_stack_file_extent_generation(stack_fi, trans->transid);\n\twrite_extent_buffer(leaf, stack_fi,\n\t\t\tbtrfs_item_ptr_offset(leaf, path->slots[0]),\n\t\t\tsizeof(struct btrfs_file_extent_item));\n\n\tbtrfs_mark_buffer_dirty(trans, leaf);\n\tbtrfs_release_path(path);\n\n\t \n\tif (file_pos == 0 && !IS_ALIGNED(drop_args.bytes_found, sectorsize)) {\n\t\tu64 inline_size = round_down(drop_args.bytes_found, sectorsize);\n\n\t\tinline_size = drop_args.bytes_found - inline_size;\n\t\tbtrfs_update_inode_bytes(inode, sectorsize, inline_size);\n\t\tdrop_args.bytes_found -= inline_size;\n\t\tnum_bytes -= sectorsize;\n\t}\n\n\tif (update_inode_bytes)\n\t\tbtrfs_update_inode_bytes(inode, num_bytes, drop_args.bytes_found);\n\n\tins.objectid = disk_bytenr;\n\tins.offset = disk_num_bytes;\n\tins.type = BTRFS_EXTENT_ITEM_KEY;\n\n\tret = btrfs_inode_set_file_extent_range(inode, file_pos, ram_bytes);\n\tif (ret)\n\t\tgoto out;\n\n\tret = btrfs_alloc_reserved_file_extent(trans, root, btrfs_ino(inode),\n\t\t\t\t\t       file_pos - offset,\n\t\t\t\t\t       qgroup_reserved, &ins);\nout:\n\tbtrfs_free_path(path);\n\n\treturn ret;\n}\n\nstatic void btrfs_release_delalloc_bytes(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t u64 start, u64 len)\n{\n\tstruct btrfs_block_group *cache;\n\n\tcache = btrfs_lookup_block_group(fs_info, start);\n\tASSERT(cache);\n\n\tspin_lock(&cache->lock);\n\tcache->delalloc_bytes -= len;\n\tspin_unlock(&cache->lock);\n\n\tbtrfs_put_block_group(cache);\n}\n\nstatic int insert_ordered_extent_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_ordered_extent *oe)\n{\n\tstruct btrfs_file_extent_item stack_fi;\n\tbool update_inode_bytes;\n\tu64 num_bytes = oe->num_bytes;\n\tu64 ram_bytes = oe->ram_bytes;\n\n\tmemset(&stack_fi, 0, sizeof(stack_fi));\n\tbtrfs_set_stack_file_extent_type(&stack_fi, BTRFS_FILE_EXTENT_REG);\n\tbtrfs_set_stack_file_extent_disk_bytenr(&stack_fi, oe->disk_bytenr);\n\tbtrfs_set_stack_file_extent_disk_num_bytes(&stack_fi,\n\t\t\t\t\t\t   oe->disk_num_bytes);\n\tbtrfs_set_stack_file_extent_offset(&stack_fi, oe->offset);\n\tif (test_bit(BTRFS_ORDERED_TRUNCATED, &oe->flags)) {\n\t\tnum_bytes = oe->truncated_len;\n\t\tram_bytes = num_bytes;\n\t}\n\tbtrfs_set_stack_file_extent_num_bytes(&stack_fi, num_bytes);\n\tbtrfs_set_stack_file_extent_ram_bytes(&stack_fi, ram_bytes);\n\tbtrfs_set_stack_file_extent_compression(&stack_fi, oe->compress_type);\n\t \n\n\t \n\tupdate_inode_bytes = test_bit(BTRFS_ORDERED_DIRECT, &oe->flags) ||\n\t\t\t     test_bit(BTRFS_ORDERED_ENCODED, &oe->flags) ||\n\t\t\t     test_bit(BTRFS_ORDERED_TRUNCATED, &oe->flags);\n\n\treturn insert_reserved_file_extent(trans, BTRFS_I(oe->inode),\n\t\t\t\t\t   oe->file_offset, &stack_fi,\n\t\t\t\t\t   update_inode_bytes, oe->qgroup_rsv);\n}\n\n \nint btrfs_finish_one_ordered(struct btrfs_ordered_extent *ordered_extent)\n{\n\tstruct btrfs_inode *inode = BTRFS_I(ordered_extent->inode);\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct extent_io_tree *io_tree = &inode->io_tree;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start, end;\n\tint compress_type = 0;\n\tint ret = 0;\n\tu64 logical_len = ordered_extent->num_bytes;\n\tbool freespace_inode;\n\tbool truncated = false;\n\tbool clear_reserved_extent = true;\n\tunsigned int clear_bits = EXTENT_DEFRAG;\n\n\tstart = ordered_extent->file_offset;\n\tend = start + ordered_extent->num_bytes - 1;\n\n\tif (!test_bit(BTRFS_ORDERED_NOCOW, &ordered_extent->flags) &&\n\t    !test_bit(BTRFS_ORDERED_PREALLOC, &ordered_extent->flags) &&\n\t    !test_bit(BTRFS_ORDERED_DIRECT, &ordered_extent->flags) &&\n\t    !test_bit(BTRFS_ORDERED_ENCODED, &ordered_extent->flags))\n\t\tclear_bits |= EXTENT_DELALLOC_NEW;\n\n\tfreespace_inode = btrfs_is_free_space_inode(inode);\n\tif (!freespace_inode)\n\t\tbtrfs_lockdep_acquire(fs_info, btrfs_ordered_extent);\n\n\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered_extent->flags)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (btrfs_is_zoned(fs_info))\n\t\tbtrfs_zone_finish_endio(fs_info, ordered_extent->disk_bytenr,\n\t\t\t\t\tordered_extent->disk_num_bytes);\n\n\tif (test_bit(BTRFS_ORDERED_TRUNCATED, &ordered_extent->flags)) {\n\t\ttruncated = true;\n\t\tlogical_len = ordered_extent->truncated_len;\n\t\t \n\t\tif (!logical_len)\n\t\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_ORDERED_NOCOW, &ordered_extent->flags)) {\n\t\tBUG_ON(!list_empty(&ordered_extent->list));  \n\n\t\tbtrfs_inode_safe_disk_i_size_write(inode, 0);\n\t\tif (freespace_inode)\n\t\t\ttrans = btrfs_join_transaction_spacecache(root);\n\t\telse\n\t\t\ttrans = btrfs_join_transaction(root);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrans->block_rsv = &inode->block_rsv;\n\t\tret = btrfs_update_inode_fallback(trans, root, inode);\n\t\tif (ret)  \n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\n\n\tclear_bits |= EXTENT_LOCKED;\n\tlock_extent(io_tree, start, end, &cached_state);\n\n\tif (freespace_inode)\n\t\ttrans = btrfs_join_transaction_spacecache(root);\n\telse\n\t\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\ttrans = NULL;\n\t\tgoto out;\n\t}\n\n\ttrans->block_rsv = &inode->block_rsv;\n\n\tif (test_bit(BTRFS_ORDERED_COMPRESSED, &ordered_extent->flags))\n\t\tcompress_type = ordered_extent->compress_type;\n\tif (test_bit(BTRFS_ORDERED_PREALLOC, &ordered_extent->flags)) {\n\t\tBUG_ON(compress_type);\n\t\tret = btrfs_mark_extent_written(trans, inode,\n\t\t\t\t\t\tordered_extent->file_offset,\n\t\t\t\t\t\tordered_extent->file_offset +\n\t\t\t\t\t\tlogical_len);\n\t\tbtrfs_zoned_release_data_reloc_bg(fs_info, ordered_extent->disk_bytenr,\n\t\t\t\t\t\t  ordered_extent->disk_num_bytes);\n\t} else {\n\t\tBUG_ON(root == fs_info->tree_root);\n\t\tret = insert_ordered_extent_file_extent(trans, ordered_extent);\n\t\tif (!ret) {\n\t\t\tclear_reserved_extent = false;\n\t\t\tbtrfs_release_delalloc_bytes(fs_info,\n\t\t\t\t\t\tordered_extent->disk_bytenr,\n\t\t\t\t\t\tordered_extent->disk_num_bytes);\n\t\t}\n\t}\n\tunpin_extent_cache(&inode->extent_tree, ordered_extent->file_offset,\n\t\t\t   ordered_extent->num_bytes, trans->transid);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\n\n\tret = add_pending_csums(trans, &ordered_extent->list);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\n\n\t \n\tif ((clear_bits & EXTENT_DELALLOC_NEW) &&\n\t    !test_bit(BTRFS_ORDERED_TRUNCATED, &ordered_extent->flags))\n\t\tclear_extent_bit(&inode->io_tree, start, end,\n\t\t\t\t EXTENT_DELALLOC_NEW | EXTENT_ADD_INODE_BYTES,\n\t\t\t\t &cached_state);\n\n\tbtrfs_inode_safe_disk_i_size_write(inode, 0);\n\tret = btrfs_update_inode_fallback(trans, root, inode);\n\tif (ret) {  \n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tclear_extent_bit(&inode->io_tree, start, end, clear_bits,\n\t\t\t &cached_state);\n\n\tif (trans)\n\t\tbtrfs_end_transaction(trans);\n\n\tif (ret || truncated) {\n\t\tu64 unwritten_start = start;\n\n\t\t \n\t\tif (ret && !test_and_set_bit(BTRFS_ORDERED_IOERR,\n\t\t\t\t\t     &ordered_extent->flags))\n\t\t\tmapping_set_error(ordered_extent->inode->i_mapping, -EIO);\n\n\t\tif (truncated)\n\t\t\tunwritten_start += logical_len;\n\t\tclear_extent_uptodate(io_tree, unwritten_start, end, NULL);\n\n\t\t \n\t\tbtrfs_drop_extent_map_range(inode, unwritten_start, end, false);\n\n\t\t \n\t\tif ((ret || !logical_len) &&\n\t\t    clear_reserved_extent &&\n\t\t    !test_bit(BTRFS_ORDERED_NOCOW, &ordered_extent->flags) &&\n\t\t    !test_bit(BTRFS_ORDERED_PREALLOC, &ordered_extent->flags)) {\n\t\t\t \n\t\t\tif (ret && btrfs_test_opt(fs_info, DISCARD_SYNC))\n\t\t\t\tbtrfs_discard_extent(fs_info,\n\t\t\t\t\t\tordered_extent->disk_bytenr,\n\t\t\t\t\t\tordered_extent->disk_num_bytes,\n\t\t\t\t\t\tNULL);\n\t\t\tbtrfs_free_reserved_extent(fs_info,\n\t\t\t\t\tordered_extent->disk_bytenr,\n\t\t\t\t\tordered_extent->disk_num_bytes, 1);\n\t\t\t \n\t\t\tbtrfs_qgroup_free_refroot(fs_info, inode->root->root_key.objectid,\n\t\t\t\t\t\t  ordered_extent->qgroup_rsv,\n\t\t\t\t\t\t  BTRFS_QGROUP_RSV_DATA);\n\t\t}\n\t}\n\n\t \n\tbtrfs_remove_ordered_extent(inode, ordered_extent);\n\n\t \n\tbtrfs_put_ordered_extent(ordered_extent);\n\t \n\tbtrfs_put_ordered_extent(ordered_extent);\n\n\treturn ret;\n}\n\nint btrfs_finish_ordered_io(struct btrfs_ordered_extent *ordered)\n{\n\tif (btrfs_is_zoned(btrfs_sb(ordered->inode->i_sb)) &&\n\t    !test_bit(BTRFS_ORDERED_IOERR, &ordered->flags))\n\t\tbtrfs_finish_ordered_zoned(ordered);\n\treturn btrfs_finish_one_ordered(ordered);\n}\n\n \nint btrfs_check_sector_csum(struct btrfs_fs_info *fs_info, struct page *page,\n\t\t\t    u32 pgoff, u8 *csum, const u8 * const csum_expected)\n{\n\tSHASH_DESC_ON_STACK(shash, fs_info->csum_shash);\n\tchar *kaddr;\n\n\tASSERT(pgoff + fs_info->sectorsize <= PAGE_SIZE);\n\n\tshash->tfm = fs_info->csum_shash;\n\n\tkaddr = kmap_local_page(page) + pgoff;\n\tcrypto_shash_digest(shash, kaddr, fs_info->sectorsize, csum);\n\tkunmap_local(kaddr);\n\n\tif (memcmp(csum, csum_expected, fs_info->csum_size))\n\t\treturn -EIO;\n\treturn 0;\n}\n\n \nbool btrfs_data_csum_ok(struct btrfs_bio *bbio, struct btrfs_device *dev,\n\t\t\tu32 bio_offset, struct bio_vec *bv)\n{\n\tstruct btrfs_inode *inode = bbio->inode;\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tu64 file_offset = bbio->file_offset + bio_offset;\n\tu64 end = file_offset + bv->bv_len - 1;\n\tu8 *csum_expected;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\n\tASSERT(bv->bv_len == fs_info->sectorsize);\n\n\tif (!bbio->csum)\n\t\treturn true;\n\n\tif (btrfs_is_data_reloc_root(inode->root) &&\n\t    test_range_bit(&inode->io_tree, file_offset, end, EXTENT_NODATASUM,\n\t\t\t   1, NULL)) {\n\t\t \n\t\tclear_extent_bits(&inode->io_tree, file_offset, end,\n\t\t\t\t  EXTENT_NODATASUM);\n\t\treturn true;\n\t}\n\n\tcsum_expected = bbio->csum + (bio_offset >> fs_info->sectorsize_bits) *\n\t\t\t\tfs_info->csum_size;\n\tif (btrfs_check_sector_csum(fs_info, bv->bv_page, bv->bv_offset, csum,\n\t\t\t\t    csum_expected))\n\t\tgoto zeroit;\n\treturn true;\n\nzeroit:\n\tbtrfs_print_data_csum_error(inode, file_offset, csum, csum_expected,\n\t\t\t\t    bbio->mirror_num);\n\tif (dev)\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_CORRUPTION_ERRS);\n\tmemzero_bvec(bv);\n\treturn false;\n}\n\n \nvoid btrfs_add_delayed_iput(struct btrfs_inode *inode)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tunsigned long flags;\n\n\tif (atomic_add_unless(&inode->vfs_inode.i_count, -1, 1))\n\t\treturn;\n\n\tatomic_inc(&fs_info->nr_delayed_iputs);\n\t \n\tspin_lock_irqsave(&fs_info->delayed_iput_lock, flags);\n\tASSERT(list_empty(&inode->delayed_iput));\n\tlist_add_tail(&inode->delayed_iput, &fs_info->delayed_iputs);\n\tspin_unlock_irqrestore(&fs_info->delayed_iput_lock, flags);\n\tif (!test_bit(BTRFS_FS_CLEANER_RUNNING, &fs_info->flags))\n\t\twake_up_process(fs_info->cleaner_kthread);\n}\n\nstatic void run_delayed_iput_locked(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct btrfs_inode *inode)\n{\n\tlist_del_init(&inode->delayed_iput);\n\tspin_unlock_irq(&fs_info->delayed_iput_lock);\n\tiput(&inode->vfs_inode);\n\tif (atomic_dec_and_test(&fs_info->nr_delayed_iputs))\n\t\twake_up(&fs_info->delayed_iputs_wait);\n\tspin_lock_irq(&fs_info->delayed_iput_lock);\n}\n\nstatic void btrfs_run_delayed_iput(struct btrfs_fs_info *fs_info,\n\t\t\t\t   struct btrfs_inode *inode)\n{\n\tif (!list_empty(&inode->delayed_iput)) {\n\t\tspin_lock_irq(&fs_info->delayed_iput_lock);\n\t\tif (!list_empty(&inode->delayed_iput))\n\t\t\trun_delayed_iput_locked(fs_info, inode);\n\t\tspin_unlock_irq(&fs_info->delayed_iput_lock);\n\t}\n}\n\nvoid btrfs_run_delayed_iputs(struct btrfs_fs_info *fs_info)\n{\n\t \n\tspin_lock_irq(&fs_info->delayed_iput_lock);\n\twhile (!list_empty(&fs_info->delayed_iputs)) {\n\t\tstruct btrfs_inode *inode;\n\n\t\tinode = list_first_entry(&fs_info->delayed_iputs,\n\t\t\t\tstruct btrfs_inode, delayed_iput);\n\t\trun_delayed_iput_locked(fs_info, inode);\n\t\tif (need_resched()) {\n\t\t\tspin_unlock_irq(&fs_info->delayed_iput_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock_irq(&fs_info->delayed_iput_lock);\n\t\t}\n\t}\n\tspin_unlock_irq(&fs_info->delayed_iput_lock);\n}\n\n \nint btrfs_wait_on_delayed_iputs(struct btrfs_fs_info *fs_info)\n{\n\tint ret = wait_event_killable(fs_info->delayed_iputs_wait,\n\t\t\tatomic_read(&fs_info->nr_delayed_iputs) == 0);\n\tif (ret)\n\t\treturn -EINTR;\n\treturn 0;\n}\n\n \nint btrfs_orphan_add(struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_insert_orphan_item(trans, inode->root, btrfs_ino(inode));\n\tif (ret && ret != -EEXIST) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int btrfs_orphan_del(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_inode *inode)\n{\n\treturn btrfs_del_orphan_item(trans, inode->root, btrfs_ino(inode));\n}\n\n \nint btrfs_orphan_cleanup(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key, found_key;\n\tstruct btrfs_trans_handle *trans;\n\tstruct inode *inode;\n\tu64 last_objectid = 0;\n\tint ret = 0, nr_unlink = 0;\n\n\tif (test_and_set_bit(BTRFS_ROOT_ORPHAN_CLEANUP, &root->state))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpath->reada = READA_BACK;\n\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (ret > 0) {\n\t\t\tret = 0;\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\t \n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\t\t \n\t\tif (found_key.objectid != BTRFS_ORPHAN_OBJECTID)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\t \n\t\tbtrfs_release_path(path);\n\n\t\t \n\n\t\tif (found_key.offset == last_objectid) {\n\t\t\t \n\t\t\tbtrfs_err(fs_info,\n\t\t\t\t  \"Error removing orphan entry, stopping orphan cleanup\");\n\t\t\tret = BTRFS_FS_ERROR(fs_info) ?: -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlast_objectid = found_key.offset;\n\n\t\tfound_key.objectid = found_key.offset;\n\t\tfound_key.type = BTRFS_INODE_ITEM_KEY;\n\t\tfound_key.offset = 0;\n\t\tinode = btrfs_iget(fs_info->sb, last_objectid, root);\n\t\tif (IS_ERR(inode)) {\n\t\t\tret = PTR_ERR(inode);\n\t\t\tinode = NULL;\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (!inode && root == fs_info->tree_root) {\n\t\t\tstruct btrfs_root *dead_root;\n\t\t\tint is_dead_root = 0;\n\n\t\t\t \n\n\t\t\tspin_lock(&fs_info->fs_roots_radix_lock);\n\t\t\tdead_root = radix_tree_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t\t\t\t (unsigned long)found_key.objectid);\n\t\t\tif (dead_root && btrfs_root_refs(&dead_root->root_item) == 0)\n\t\t\t\tis_dead_root = 1;\n\t\t\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\n\t\t\tif (is_dead_root) {\n\t\t\t\t \n\t\t\t\tkey.offset = found_key.objectid - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t}\n\n\t\t \n\t\tif (!inode || inode->i_nlink) {\n\t\t\tif (inode) {\n\t\t\t\tret = btrfs_drop_verity_items(BTRFS_I(inode));\n\t\t\t\tiput(inode);\n\t\t\t\tinode = NULL;\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_debug(fs_info, \"auto deleting %Lu\",\n\t\t\t\t    found_key.objectid);\n\t\t\tret = btrfs_del_orphan_item(trans, root,\n\t\t\t\t\t\t    found_key.objectid);\n\t\t\tbtrfs_end_transaction(trans);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnr_unlink++;\n\n\t\t \n\t\tiput(inode);\n\t}\n\t \n\tbtrfs_release_path(path);\n\n\tif (test_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state)) {\n\t\ttrans = btrfs_join_transaction(root);\n\t\tif (!IS_ERR(trans))\n\t\t\tbtrfs_end_transaction(trans);\n\t}\n\n\tif (nr_unlink)\n\t\tbtrfs_debug(fs_info, \"unlinked %d orphans\", nr_unlink);\n\nout:\n\tif (ret)\n\t\tbtrfs_err(fs_info, \"could not do orphan cleanup %d\", ret);\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nstatic noinline int acls_after_inode_item(struct extent_buffer *leaf,\n\t\t\t\t\t  int slot, u64 objectid,\n\t\t\t\t\t  int *first_xattr_slot)\n{\n\tu32 nritems = btrfs_header_nritems(leaf);\n\tstruct btrfs_key found_key;\n\tstatic u64 xattr_access = 0;\n\tstatic u64 xattr_default = 0;\n\tint scanned = 0;\n\n\tif (!xattr_access) {\n\t\txattr_access = btrfs_name_hash(XATTR_NAME_POSIX_ACL_ACCESS,\n\t\t\t\t\tstrlen(XATTR_NAME_POSIX_ACL_ACCESS));\n\t\txattr_default = btrfs_name_hash(XATTR_NAME_POSIX_ACL_DEFAULT,\n\t\t\t\t\tstrlen(XATTR_NAME_POSIX_ACL_DEFAULT));\n\t}\n\n\tslot++;\n\t*first_xattr_slot = -1;\n\twhile (slot < nritems) {\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\t \n\t\tif (found_key.objectid != objectid)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (found_key.type == BTRFS_XATTR_ITEM_KEY) {\n\t\t\tif (*first_xattr_slot == -1)\n\t\t\t\t*first_xattr_slot = slot;\n\t\t\tif (found_key.offset == xattr_access ||\n\t\t\t    found_key.offset == xattr_default)\n\t\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tif (found_key.type > BTRFS_XATTR_ITEM_KEY)\n\t\t\treturn 0;\n\n\t\tslot++;\n\t\tscanned++;\n\n\t\t \n\t\tif (scanned >= 8)\n\t\t\tbreak;\n\t}\n\t \n\tif (*first_xattr_slot == -1)\n\t\t*first_xattr_slot = slot;\n\treturn 1;\n}\n\n \nstatic int btrfs_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct btrfs_path *in_path)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_path *path = in_path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_key location;\n\tunsigned long ptr;\n\tint maybe_acls;\n\tu32 rdev;\n\tint ret;\n\tbool filled = false;\n\tint first_xattr_slot;\n\n\tret = btrfs_fill_inode(inode, &rdev);\n\tif (!ret)\n\t\tfilled = true;\n\n\tif (!path) {\n\t\tpath = btrfs_alloc_path();\n\t\tif (!path)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(&location, &BTRFS_I(inode)->location, sizeof(location));\n\n\tret = btrfs_lookup_inode(NULL, root, path, &location, 0);\n\tif (ret) {\n\t\tif (path != in_path)\n\t\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\n\tif (filled)\n\t\tgoto cache_index;\n\n\tinode_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\tinode->i_mode = btrfs_inode_mode(leaf, inode_item);\n\tset_nlink(inode, btrfs_inode_nlink(leaf, inode_item));\n\ti_uid_write(inode, btrfs_inode_uid(leaf, inode_item));\n\ti_gid_write(inode, btrfs_inode_gid(leaf, inode_item));\n\tbtrfs_i_size_write(BTRFS_I(inode), btrfs_inode_size(leaf, inode_item));\n\tbtrfs_inode_set_file_extent_range(BTRFS_I(inode), 0,\n\t\t\tround_up(i_size_read(inode), fs_info->sectorsize));\n\n\tinode->i_atime.tv_sec = btrfs_timespec_sec(leaf, &inode_item->atime);\n\tinode->i_atime.tv_nsec = btrfs_timespec_nsec(leaf, &inode_item->atime);\n\n\tinode->i_mtime.tv_sec = btrfs_timespec_sec(leaf, &inode_item->mtime);\n\tinode->i_mtime.tv_nsec = btrfs_timespec_nsec(leaf, &inode_item->mtime);\n\n\tinode_set_ctime(inode, btrfs_timespec_sec(leaf, &inode_item->ctime),\n\t\t\tbtrfs_timespec_nsec(leaf, &inode_item->ctime));\n\n\tBTRFS_I(inode)->i_otime.tv_sec =\n\t\tbtrfs_timespec_sec(leaf, &inode_item->otime);\n\tBTRFS_I(inode)->i_otime.tv_nsec =\n\t\tbtrfs_timespec_nsec(leaf, &inode_item->otime);\n\n\tinode_set_bytes(inode, btrfs_inode_nbytes(leaf, inode_item));\n\tBTRFS_I(inode)->generation = btrfs_inode_generation(leaf, inode_item);\n\tBTRFS_I(inode)->last_trans = btrfs_inode_transid(leaf, inode_item);\n\n\tinode_set_iversion_queried(inode,\n\t\t\t\t   btrfs_inode_sequence(leaf, inode_item));\n\tinode->i_generation = BTRFS_I(inode)->generation;\n\tinode->i_rdev = 0;\n\trdev = btrfs_inode_rdev(leaf, inode_item);\n\n\tBTRFS_I(inode)->index_cnt = (u64)-1;\n\tbtrfs_inode_split_flags(btrfs_inode_flags(leaf, inode_item),\n\t\t\t\t&BTRFS_I(inode)->flags, &BTRFS_I(inode)->ro_flags);\n\ncache_index:\n\t \n\tif (BTRFS_I(inode)->last_trans == fs_info->generation)\n\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\n\t \n\tBTRFS_I(inode)->last_unlink_trans = BTRFS_I(inode)->last_trans;\n\n\t \n\tBTRFS_I(inode)->last_reflink_trans = BTRFS_I(inode)->last_trans;\n\n\tpath->slots[0]++;\n\tif (inode->i_nlink != 1 ||\n\t    path->slots[0] >= btrfs_header_nritems(leaf))\n\t\tgoto cache_acl;\n\n\tbtrfs_item_key_to_cpu(leaf, &location, path->slots[0]);\n\tif (location.objectid != btrfs_ino(BTRFS_I(inode)))\n\t\tgoto cache_acl;\n\n\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\tif (location.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *ref;\n\n\t\tref = (struct btrfs_inode_ref *)ptr;\n\t\tBTRFS_I(inode)->dir_index = btrfs_inode_ref_index(leaf, ref);\n\t} else if (location.type == BTRFS_INODE_EXTREF_KEY) {\n\t\tstruct btrfs_inode_extref *extref;\n\n\t\textref = (struct btrfs_inode_extref *)ptr;\n\t\tBTRFS_I(inode)->dir_index = btrfs_inode_extref_index(leaf,\n\t\t\t\t\t\t\t\t     extref);\n\t}\ncache_acl:\n\t \n\tmaybe_acls = acls_after_inode_item(leaf, path->slots[0],\n\t\t\tbtrfs_ino(BTRFS_I(inode)), &first_xattr_slot);\n\tif (first_xattr_slot != -1) {\n\t\tpath->slots[0] = first_xattr_slot;\n\t\tret = btrfs_load_inode_props(inode, path);\n\t\tif (ret)\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\t  \"error loading props for ino %llu (root %llu): %d\",\n\t\t\t\t  btrfs_ino(BTRFS_I(inode)),\n\t\t\t\t  root->root_key.objectid, ret);\n\t}\n\tif (path != in_path)\n\t\tbtrfs_free_path(path);\n\n\tif (!maybe_acls)\n\t\tcache_no_acl(inode);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_mapping->a_ops = &btrfs_aops;\n\t\tinode->i_fop = &btrfs_file_operations;\n\t\tinode->i_op = &btrfs_file_inode_operations;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_fop = &btrfs_dir_file_operations;\n\t\tinode->i_op = &btrfs_dir_inode_operations;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &btrfs_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &btrfs_aops;\n\t\tbreak;\n\tdefault:\n\t\tinode->i_op = &btrfs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n\t\tbreak;\n\t}\n\n\tbtrfs_sync_inode_flags_to_i_flags(inode);\n\treturn 0;\n}\n\n \nstatic void fill_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct extent_buffer *leaf,\n\t\t\t    struct btrfs_inode_item *item,\n\t\t\t    struct inode *inode)\n{\n\tstruct btrfs_map_token token;\n\tu64 flags;\n\n\tbtrfs_init_map_token(&token, leaf);\n\n\tbtrfs_set_token_inode_uid(&token, item, i_uid_read(inode));\n\tbtrfs_set_token_inode_gid(&token, item, i_gid_read(inode));\n\tbtrfs_set_token_inode_size(&token, item, BTRFS_I(inode)->disk_i_size);\n\tbtrfs_set_token_inode_mode(&token, item, inode->i_mode);\n\tbtrfs_set_token_inode_nlink(&token, item, inode->i_nlink);\n\n\tbtrfs_set_token_timespec_sec(&token, &item->atime,\n\t\t\t\t     inode->i_atime.tv_sec);\n\tbtrfs_set_token_timespec_nsec(&token, &item->atime,\n\t\t\t\t      inode->i_atime.tv_nsec);\n\n\tbtrfs_set_token_timespec_sec(&token, &item->mtime,\n\t\t\t\t     inode->i_mtime.tv_sec);\n\tbtrfs_set_token_timespec_nsec(&token, &item->mtime,\n\t\t\t\t      inode->i_mtime.tv_nsec);\n\n\tbtrfs_set_token_timespec_sec(&token, &item->ctime,\n\t\t\t\t     inode_get_ctime(inode).tv_sec);\n\tbtrfs_set_token_timespec_nsec(&token, &item->ctime,\n\t\t\t\t      inode_get_ctime(inode).tv_nsec);\n\n\tbtrfs_set_token_timespec_sec(&token, &item->otime,\n\t\t\t\t     BTRFS_I(inode)->i_otime.tv_sec);\n\tbtrfs_set_token_timespec_nsec(&token, &item->otime,\n\t\t\t\t      BTRFS_I(inode)->i_otime.tv_nsec);\n\n\tbtrfs_set_token_inode_nbytes(&token, item, inode_get_bytes(inode));\n\tbtrfs_set_token_inode_generation(&token, item,\n\t\t\t\t\t BTRFS_I(inode)->generation);\n\tbtrfs_set_token_inode_sequence(&token, item, inode_peek_iversion(inode));\n\tbtrfs_set_token_inode_transid(&token, item, trans->transid);\n\tbtrfs_set_token_inode_rdev(&token, item, inode->i_rdev);\n\tflags = btrfs_inode_combine_flags(BTRFS_I(inode)->flags,\n\t\t\t\t\t  BTRFS_I(inode)->ro_flags);\n\tbtrfs_set_token_inode_flags(&token, item, flags);\n\tbtrfs_set_token_inode_block_group(&token, item, 0);\n}\n\n \nstatic noinline int btrfs_update_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_inode *inode)\n{\n\tstruct btrfs_inode_item *inode_item;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_lookup_inode(trans, root, path, &inode->location, 1);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\tgoto failed;\n\t}\n\n\tleaf = path->nodes[0];\n\tinode_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\n\tfill_inode_item(trans, leaf, inode_item, &inode->vfs_inode);\n\tbtrfs_mark_buffer_dirty(trans, leaf);\n\tbtrfs_set_inode_last_trans(trans, inode);\n\tret = 0;\nfailed:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nnoinline int btrfs_update_inode(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_inode *inode)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\t \n\tif (!btrfs_is_free_space_inode(inode)\n\t    && !btrfs_is_data_reloc_root(root)\n\t    && !test_bit(BTRFS_FS_LOG_RECOVERING, &fs_info->flags)) {\n\t\tbtrfs_update_root_times(trans, root);\n\n\t\tret = btrfs_delayed_update_inode(trans, root, inode);\n\t\tif (!ret)\n\t\t\tbtrfs_set_inode_last_trans(trans, inode);\n\t\treturn ret;\n\t}\n\n\treturn btrfs_update_inode_item(trans, root, inode);\n}\n\nint btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root, struct btrfs_inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}\n\n \nstatic int __btrfs_unlink_inode(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_inode *dir,\n\t\t\t\tstruct btrfs_inode *inode,\n\t\t\t\tconst struct fscrypt_str *name,\n\t\t\t\tstruct btrfs_rename_ctx *rename_ctx)\n{\n\tstruct btrfs_root *root = dir->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_path *path;\n\tint ret = 0;\n\tstruct btrfs_dir_item *di;\n\tu64 index;\n\tu64 ino = btrfs_ino(inode);\n\tu64 dir_ino = btrfs_ino(dir);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdi = btrfs_lookup_dir_item(trans, root, path, dir_ino, name, -1);\n\tif (IS_ERR_OR_NULL(di)) {\n\t\tret = di ? PTR_ERR(di) : -ENOENT;\n\t\tgoto err;\n\t}\n\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n\tif (ret)\n\t\tgoto err;\n\tbtrfs_release_path(path);\n\n\t \n\tif (inode->dir_index) {\n\t\tret = btrfs_delayed_delete_inode_ref(inode);\n\t\tif (!ret) {\n\t\t\tindex = inode->dir_index;\n\t\t\tgoto skip_backref;\n\t\t}\n\t}\n\n\tret = btrfs_del_inode_ref(trans, root, name, ino, dir_ino, &index);\n\tif (ret) {\n\t\tbtrfs_info(fs_info,\n\t\t\t\"failed to delete reference to %.*s, inode %llu parent %llu\",\n\t\t\tname->len, name->name, ino, dir_ino);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto err;\n\t}\nskip_backref:\n\tif (rename_ctx)\n\t\trename_ctx->index = index;\n\n\tret = btrfs_delete_delayed_dir_index(trans, dir, index);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto err;\n\t}\n\n\t \n\tif (!rename_ctx) {\n\t\tbtrfs_del_inode_ref_in_log(trans, root, name, inode, dir_ino);\n\t\tbtrfs_del_dir_entries_in_log(trans, root, name, dir, index);\n\t}\n\n\t \n\tbtrfs_run_delayed_iput(fs_info, inode);\nerr:\n\tbtrfs_free_path(path);\n\tif (ret)\n\t\tgoto out;\n\n\tbtrfs_i_size_write(dir, dir->vfs_inode.i_size - name->len * 2);\n\tinode_inc_iversion(&inode->vfs_inode);\n\tinode_inc_iversion(&dir->vfs_inode);\n\tinode_set_ctime_current(&inode->vfs_inode);\n\tdir->vfs_inode.i_mtime = inode_set_ctime_current(&dir->vfs_inode);\n\tret = btrfs_update_inode(trans, root, dir);\nout:\n\treturn ret;\n}\n\nint btrfs_unlink_inode(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_inode *dir, struct btrfs_inode *inode,\n\t\t       const struct fscrypt_str *name)\n{\n\tint ret;\n\n\tret = __btrfs_unlink_inode(trans, dir, inode, name, NULL);\n\tif (!ret) {\n\t\tdrop_nlink(&inode->vfs_inode);\n\t\tret = btrfs_update_inode(trans, inode->root, inode);\n\t}\n\treturn ret;\n}\n\n \nstatic struct btrfs_trans_handle *__unlink_start_trans(struct btrfs_inode *dir)\n{\n\tstruct btrfs_root *root = dir->root;\n\n\treturn btrfs_start_transaction_fallback_global_rsv(root,\n\t\t\t\t\t\t   BTRFS_UNLINK_METADATA_UNITS);\n}\n\nstatic int btrfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct inode *inode = d_inode(dentry);\n\tint ret;\n\tstruct fscrypt_name fname;\n\n\tret = fscrypt_setup_filename(dir, &dentry->d_name, 1, &fname);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\ttrans = __unlink_start_trans(BTRFS_I(dir));\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto fscrypt_free;\n\t}\n\n\tbtrfs_record_unlink_dir(trans, BTRFS_I(dir), BTRFS_I(d_inode(dentry)),\n\t\t\t\tfalse);\n\n\tret = btrfs_unlink_inode(trans, BTRFS_I(dir), BTRFS_I(d_inode(dentry)),\n\t\t\t\t &fname.disk_name);\n\tif (ret)\n\t\tgoto end_trans;\n\n\tif (inode->i_nlink == 0) {\n\t\tret = btrfs_orphan_add(trans, BTRFS_I(inode));\n\t\tif (ret)\n\t\t\tgoto end_trans;\n\t}\n\nend_trans:\n\tbtrfs_end_transaction(trans);\n\tbtrfs_btree_balance_dirty(BTRFS_I(dir)->root->fs_info);\nfscrypt_free:\n\tfscrypt_free_filename(&fname);\n\treturn ret;\n}\n\nstatic int btrfs_unlink_subvol(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_inode *dir, struct dentry *dentry)\n{\n\tstruct btrfs_root *root = dir->root;\n\tstruct btrfs_inode *inode = BTRFS_I(d_inode(dentry));\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tu64 index;\n\tint ret;\n\tu64 objectid;\n\tu64 dir_ino = btrfs_ino(dir);\n\tstruct fscrypt_name fname;\n\n\tret = fscrypt_setup_filename(&dir->vfs_inode, &dentry->d_name, 1, &fname);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tif (btrfs_ino(inode) == BTRFS_FIRST_FREE_OBJECTID) {\n\t\tobjectid = inode->root->root_key.objectid;\n\t} else if (btrfs_ino(inode) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID) {\n\t\tobjectid = inode->location.objectid;\n\t} else {\n\t\tWARN_ON(1);\n\t\tfscrypt_free_filename(&fname);\n\t\treturn -EINVAL;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdi = btrfs_lookup_dir_item(trans, root, path, dir_ino,\n\t\t\t\t   &fname.disk_name, -1);\n\tif (IS_ERR_OR_NULL(di)) {\n\t\tret = di ? PTR_ERR(di) : -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_dir_item_key_to_cpu(leaf, di, &key);\n\tWARN_ON(key.type != BTRFS_ROOT_ITEM_KEY || key.objectid != objectid);\n\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\n\t \n\tif (btrfs_ino(inode) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID) {\n\t\tdi = btrfs_search_dir_index_item(root, path, dir_ino, &fname.disk_name);\n\t\tif (IS_ERR_OR_NULL(di)) {\n\t\t\tif (!di)\n\t\t\t\tret = -ENOENT;\n\t\t\telse\n\t\t\t\tret = PTR_ERR(di);\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tindex = key.offset;\n\t\tbtrfs_release_path(path);\n\t} else {\n\t\tret = btrfs_del_root_ref(trans, objectid,\n\t\t\t\t\t root->root_key.objectid, dir_ino,\n\t\t\t\t\t &index, &fname.disk_name);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = btrfs_delete_delayed_dir_index(trans, dir, index);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\n\n\tbtrfs_i_size_write(dir, dir->vfs_inode.i_size - fname.disk_name.len * 2);\n\tinode_inc_iversion(&dir->vfs_inode);\n\tdir->vfs_inode.i_mtime = inode_set_ctime_current(&dir->vfs_inode);\n\tret = btrfs_update_inode_fallback(trans, root, dir);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, ret);\nout:\n\tbtrfs_free_path(path);\n\tfscrypt_free_filename(&fname);\n\treturn ret;\n}\n\n \nstatic noinline int may_destroy_subvol(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tstruct fscrypt_str name = FSTR_INIT(\"default\", 7);\n\tu64 dir_id;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t \n\tdir_id = btrfs_super_root_dir(fs_info->super_copy);\n\tdi = btrfs_lookup_dir_item(NULL, fs_info->tree_root, path,\n\t\t\t\t   dir_id, &name, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &key);\n\t\tif (key.objectid == root->root_key.objectid) {\n\t\t\tret = -EPERM;\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\t  \"deleting default subvolume %llu is not allowed\",\n\t\t\t\t  key.objectid);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t}\n\n\tkey.objectid = root->root_key.objectid;\n\tkey.type = BTRFS_ROOT_REF_KEY;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, fs_info->tree_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(ret == 0);\n\n\tret = 0;\n\tif (path->slots[0] > 0) {\n\t\tpath->slots[0]--;\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\t\tif (key.objectid == root->root_key.objectid &&\n\t\t    key.type == BTRFS_ROOT_REF_KEY)\n\t\t\tret = -ENOTEMPTY;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nstatic void btrfs_prune_dentries(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct rb_node *node;\n\tstruct rb_node *prev;\n\tstruct btrfs_inode *entry;\n\tstruct inode *inode;\n\tu64 objectid = 0;\n\n\tif (!BTRFS_FS_ERROR(fs_info))\n\t\tWARN_ON(btrfs_root_refs(&root->root_item) != 0);\n\n\tspin_lock(&root->inode_lock);\nagain:\n\tnode = root->inode_tree.rb_node;\n\tprev = NULL;\n\twhile (node) {\n\t\tprev = node;\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\n\t\tif (objectid < btrfs_ino(entry))\n\t\t\tnode = node->rb_left;\n\t\telse if (objectid > btrfs_ino(entry))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!node) {\n\t\twhile (prev) {\n\t\t\tentry = rb_entry(prev, struct btrfs_inode, rb_node);\n\t\t\tif (objectid <= btrfs_ino(entry)) {\n\t\t\t\tnode = prev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprev = rb_next(prev);\n\t\t}\n\t}\n\twhile (node) {\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\t\tobjectid = btrfs_ino(entry) + 1;\n\t\tinode = igrab(&entry->vfs_inode);\n\t\tif (inode) {\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\tif (atomic_read(&inode->i_count) > 1)\n\t\t\t\td_prune_aliases(inode);\n\t\t\t \n\t\t\tiput(inode);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&root->inode_lock);\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (cond_resched_lock(&root->inode_lock))\n\t\t\tgoto again;\n\n\t\tnode = rb_next(node);\n\t}\n\tspin_unlock(&root->inode_lock);\n}\n\nint btrfs_delete_subvolume(struct btrfs_inode *dir, struct dentry *dentry)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(dentry->d_sb);\n\tstruct btrfs_root *root = dir->root;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct btrfs_root *dest = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_block_rsv block_rsv;\n\tu64 root_flags;\n\tint ret;\n\n\t \n\tspin_lock(&dest->root_item_lock);\n\tif (dest->send_in_progress) {\n\t\tspin_unlock(&dest->root_item_lock);\n\t\tbtrfs_warn(fs_info,\n\t\t\t   \"attempt to delete subvolume %llu during send\",\n\t\t\t   dest->root_key.objectid);\n\t\treturn -EPERM;\n\t}\n\tif (atomic_read(&dest->nr_swapfiles)) {\n\t\tspin_unlock(&dest->root_item_lock);\n\t\tbtrfs_warn(fs_info,\n\t\t\t   \"attempt to delete subvolume %llu with active swapfile\",\n\t\t\t   root->root_key.objectid);\n\t\treturn -EPERM;\n\t}\n\troot_flags = btrfs_root_flags(&dest->root_item);\n\tbtrfs_set_root_flags(&dest->root_item,\n\t\t\t     root_flags | BTRFS_ROOT_SUBVOL_DEAD);\n\tspin_unlock(&dest->root_item_lock);\n\n\tdown_write(&fs_info->subvol_sem);\n\n\tret = may_destroy_subvol(dest);\n\tif (ret)\n\t\tgoto out_up_write;\n\n\tbtrfs_init_block_rsv(&block_rsv, BTRFS_BLOCK_RSV_TEMP);\n\t \n\tret = btrfs_subvolume_reserve_metadata(root, &block_rsv, 5, true);\n\tif (ret)\n\t\tgoto out_up_write;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_release;\n\t}\n\ttrans->block_rsv = &block_rsv;\n\ttrans->bytes_reserved = block_rsv.size;\n\n\tbtrfs_record_snapshot_destroy(trans, dir);\n\n\tret = btrfs_unlink_subvol(trans, dir, dentry);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out_end_trans;\n\t}\n\n\tret = btrfs_record_root_in_trans(trans, dest);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out_end_trans;\n\t}\n\n\tmemset(&dest->root_item.drop_progress, 0,\n\t\tsizeof(dest->root_item.drop_progress));\n\tbtrfs_set_root_drop_level(&dest->root_item, 0);\n\tbtrfs_set_root_refs(&dest->root_item, 0);\n\n\tif (!test_and_set_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &dest->state)) {\n\t\tret = btrfs_insert_orphan_item(trans,\n\t\t\t\t\tfs_info->tree_root,\n\t\t\t\t\tdest->root_key.objectid);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out_end_trans;\n\t\t}\n\t}\n\n\tret = btrfs_uuid_tree_remove(trans, dest->root_item.uuid,\n\t\t\t\t  BTRFS_UUID_KEY_SUBVOL,\n\t\t\t\t  dest->root_key.objectid);\n\tif (ret && ret != -ENOENT) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out_end_trans;\n\t}\n\tif (!btrfs_is_empty_uuid(dest->root_item.received_uuid)) {\n\t\tret = btrfs_uuid_tree_remove(trans,\n\t\t\t\t\t  dest->root_item.received_uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  dest->root_key.objectid);\n\t\tif (ret && ret != -ENOENT) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out_end_trans;\n\t\t}\n\t}\n\n\tfree_anon_bdev(dest->anon_dev);\n\tdest->anon_dev = 0;\nout_end_trans:\n\ttrans->block_rsv = NULL;\n\ttrans->bytes_reserved = 0;\n\tret = btrfs_end_transaction(trans);\n\tinode->i_flags |= S_DEAD;\nout_release:\n\tbtrfs_subvolume_release_metadata(root, &block_rsv);\nout_up_write:\n\tup_write(&fs_info->subvol_sem);\n\tif (ret) {\n\t\tspin_lock(&dest->root_item_lock);\n\t\troot_flags = btrfs_root_flags(&dest->root_item);\n\t\tbtrfs_set_root_flags(&dest->root_item,\n\t\t\t\troot_flags & ~BTRFS_ROOT_SUBVOL_DEAD);\n\t\tspin_unlock(&dest->root_item_lock);\n\t} else {\n\t\td_invalidate(dentry);\n\t\tbtrfs_prune_dentries(dest);\n\t\tASSERT(dest->send_in_progress == 0);\n\t}\n\n\treturn ret;\n}\n\nstatic int btrfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tint err = 0;\n\tstruct btrfs_trans_handle *trans;\n\tu64 last_unlink_trans;\n\tstruct fscrypt_name fname;\n\n\tif (inode->i_size > BTRFS_EMPTY_DIR_SIZE)\n\t\treturn -ENOTEMPTY;\n\tif (btrfs_ino(BTRFS_I(inode)) == BTRFS_FIRST_FREE_OBJECTID) {\n\t\tif (unlikely(btrfs_fs_incompat(fs_info, EXTENT_TREE_V2))) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\"extent tree v2 doesn't support snapshot deletion yet\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\treturn btrfs_delete_subvolume(BTRFS_I(dir), dentry);\n\t}\n\n\terr = fscrypt_setup_filename(dir, &dentry->d_name, 1, &fname);\n\tif (err)\n\t\treturn err;\n\n\t \n\n\ttrans = __unlink_start_trans(BTRFS_I(dir));\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_notrans;\n\t}\n\n\tif (unlikely(btrfs_ino(BTRFS_I(inode)) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID)) {\n\t\terr = btrfs_unlink_subvol(trans, BTRFS_I(dir), dentry);\n\t\tgoto out;\n\t}\n\n\terr = btrfs_orphan_add(trans, BTRFS_I(inode));\n\tif (err)\n\t\tgoto out;\n\n\tlast_unlink_trans = BTRFS_I(inode)->last_unlink_trans;\n\n\t \n\terr = btrfs_unlink_inode(trans, BTRFS_I(dir), BTRFS_I(d_inode(dentry)),\n\t\t\t\t &fname.disk_name);\n\tif (!err) {\n\t\tbtrfs_i_size_write(BTRFS_I(inode), 0);\n\t\t \n\t\tif (last_unlink_trans >= trans->transid)\n\t\t\tBTRFS_I(dir)->last_unlink_trans = last_unlink_trans;\n\t}\nout:\n\tbtrfs_end_transaction(trans);\nout_notrans:\n\tbtrfs_btree_balance_dirty(fs_info);\n\tfscrypt_free_filename(&fname);\n\n\treturn err;\n}\n\n \nint btrfs_truncate_block(struct btrfs_inode *inode, loff_t from, loff_t len,\n\t\t\t int front)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tstruct address_space *mapping = inode->vfs_inode.i_mapping;\n\tstruct extent_io_tree *io_tree = &inode->io_tree;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_changeset *data_reserved = NULL;\n\tbool only_release_metadata = false;\n\tu32 blocksize = fs_info->sectorsize;\n\tpgoff_t index = from >> PAGE_SHIFT;\n\tunsigned offset = from & (blocksize - 1);\n\tstruct page *page;\n\tgfp_t mask = btrfs_alloc_write_mask(mapping);\n\tsize_t write_bytes = blocksize;\n\tint ret = 0;\n\tu64 block_start;\n\tu64 block_end;\n\n\tif (IS_ALIGNED(offset, blocksize) &&\n\t    (!len || IS_ALIGNED(len, blocksize)))\n\t\tgoto out;\n\n\tblock_start = round_down(from, blocksize);\n\tblock_end = block_start + blocksize - 1;\n\n\tret = btrfs_check_data_free_space(inode, &data_reserved, block_start,\n\t\t\t\t\t  blocksize, false);\n\tif (ret < 0) {\n\t\tif (btrfs_check_nocow_lock(inode, block_start, &write_bytes, false) > 0) {\n\t\t\t \n\t\t\tonly_release_metadata = true;\n\t\t} else {\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = btrfs_delalloc_reserve_metadata(inode, blocksize, blocksize, false);\n\tif (ret < 0) {\n\t\tif (!only_release_metadata)\n\t\t\tbtrfs_free_reserved_data_space(inode, data_reserved,\n\t\t\t\t\t\t       block_start, blocksize);\n\t\tgoto out;\n\t}\nagain:\n\tpage = find_or_create_page(mapping, index, mask);\n\tif (!page) {\n\t\tbtrfs_delalloc_release_space(inode, data_reserved, block_start,\n\t\t\t\t\t     blocksize, true);\n\t\tbtrfs_delalloc_release_extents(inode, blocksize);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tret = btrfs_read_folio(NULL, page_folio(page));\n\t\tlock_page(page);\n\t\tif (page->mapping != mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto again;\n\t\t}\n\t\tif (!PageUptodate(page)) {\n\t\t\tret = -EIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t \n\tret = set_page_extent_mapped(page);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\twait_on_page_writeback(page);\n\n\tlock_extent(io_tree, block_start, block_end, &cached_state);\n\n\tordered = btrfs_lookup_ordered_extent(inode, block_start);\n\tif (ordered) {\n\t\tunlock_extent(io_tree, block_start, block_end, &cached_state);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tbtrfs_start_ordered_extent(ordered);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tgoto again;\n\t}\n\n\tclear_extent_bit(&inode->io_tree, block_start, block_end,\n\t\t\t EXTENT_DELALLOC | EXTENT_DO_ACCOUNTING | EXTENT_DEFRAG,\n\t\t\t &cached_state);\n\n\tret = btrfs_set_extent_delalloc(inode, block_start, block_end, 0,\n\t\t\t\t\t&cached_state);\n\tif (ret) {\n\t\tunlock_extent(io_tree, block_start, block_end, &cached_state);\n\t\tgoto out_unlock;\n\t}\n\n\tif (offset != blocksize) {\n\t\tif (!len)\n\t\t\tlen = blocksize - offset;\n\t\tif (front)\n\t\t\tmemzero_page(page, (block_start - page_offset(page)),\n\t\t\t\t     offset);\n\t\telse\n\t\t\tmemzero_page(page, (block_start - page_offset(page)) + offset,\n\t\t\t\t     len);\n\t}\n\tbtrfs_page_clear_checked(fs_info, page, block_start,\n\t\t\t\t block_end + 1 - block_start);\n\tbtrfs_page_set_dirty(fs_info, page, block_start, block_end + 1 - block_start);\n\tunlock_extent(io_tree, block_start, block_end, &cached_state);\n\n\tif (only_release_metadata)\n\t\tset_extent_bit(&inode->io_tree, block_start, block_end,\n\t\t\t       EXTENT_NORESERVE, NULL);\n\nout_unlock:\n\tif (ret) {\n\t\tif (only_release_metadata)\n\t\t\tbtrfs_delalloc_release_metadata(inode, blocksize, true);\n\t\telse\n\t\t\tbtrfs_delalloc_release_space(inode, data_reserved,\n\t\t\t\t\tblock_start, blocksize, true);\n\t}\n\tbtrfs_delalloc_release_extents(inode, blocksize);\n\tunlock_page(page);\n\tput_page(page);\nout:\n\tif (only_release_metadata)\n\t\tbtrfs_check_nocow_unlock(inode);\n\textent_changeset_free(data_reserved);\n\treturn ret;\n}\n\nstatic int maybe_insert_hole(struct btrfs_root *root, struct btrfs_inode *inode,\n\t\t\t     u64 offset, u64 len)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_drop_extents_args drop_args = { 0 };\n\tint ret;\n\n\t \n\tif (btrfs_fs_incompat(fs_info, NO_HOLES))\n\t\treturn 0;\n\n\t \n\ttrans = btrfs_start_transaction(root, 3);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tdrop_args.start = offset;\n\tdrop_args.end = offset + len;\n\tdrop_args.drop_cache = true;\n\n\tret = btrfs_drop_extents(trans, root, inode, &drop_args);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tbtrfs_end_transaction(trans);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_insert_hole_extent(trans, root, btrfs_ino(inode), offset, len);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t} else {\n\t\tbtrfs_update_inode_bytes(inode, 0, drop_args.bytes_found);\n\t\tbtrfs_update_inode(trans, root, inode);\n\t}\n\tbtrfs_end_transaction(trans);\n\treturn ret;\n}\n\n \nint btrfs_cont_expand(struct btrfs_inode *inode, loff_t oldsize, loff_t size)\n{\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct extent_io_tree *io_tree = &inode->io_tree;\n\tstruct extent_map *em = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tu64 hole_start = ALIGN(oldsize, fs_info->sectorsize);\n\tu64 block_end = ALIGN(size, fs_info->sectorsize);\n\tu64 last_byte;\n\tu64 cur_offset;\n\tu64 hole_size;\n\tint err = 0;\n\n\t \n\terr = btrfs_truncate_block(inode, oldsize, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\tif (size <= hole_start)\n\t\treturn 0;\n\n\tbtrfs_lock_and_flush_ordered_range(inode, hole_start, block_end - 1,\n\t\t\t\t\t   &cached_state);\n\tcur_offset = hole_start;\n\twhile (1) {\n\t\tem = btrfs_get_extent(inode, NULL, 0, cur_offset,\n\t\t\t\t      block_end - cur_offset);\n\t\tif (IS_ERR(em)) {\n\t\t\terr = PTR_ERR(em);\n\t\t\tem = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tlast_byte = min(extent_map_end(em), block_end);\n\t\tlast_byte = ALIGN(last_byte, fs_info->sectorsize);\n\t\thole_size = last_byte - cur_offset;\n\n\t\tif (!test_bit(EXTENT_FLAG_PREALLOC, &em->flags)) {\n\t\t\tstruct extent_map *hole_em;\n\n\t\t\terr = maybe_insert_hole(root, inode, cur_offset,\n\t\t\t\t\t\thole_size);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\terr = btrfs_inode_set_file_extent_range(inode,\n\t\t\t\t\t\t\tcur_offset, hole_size);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\thole_em = alloc_extent_map();\n\t\t\tif (!hole_em) {\n\t\t\t\tbtrfs_drop_extent_map_range(inode, cur_offset,\n\t\t\t\t\t\t    cur_offset + hole_size - 1,\n\t\t\t\t\t\t    false);\n\t\t\t\tbtrfs_set_inode_full_sync(inode);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\thole_em->start = cur_offset;\n\t\t\thole_em->len = hole_size;\n\t\t\thole_em->orig_start = cur_offset;\n\n\t\t\thole_em->block_start = EXTENT_MAP_HOLE;\n\t\t\thole_em->block_len = 0;\n\t\t\thole_em->orig_block_len = 0;\n\t\t\thole_em->ram_bytes = hole_size;\n\t\t\thole_em->compress_type = BTRFS_COMPRESS_NONE;\n\t\t\thole_em->generation = fs_info->generation;\n\n\t\t\terr = btrfs_replace_extent_map_range(inode, hole_em, true);\n\t\t\tfree_extent_map(hole_em);\n\t\t} else {\n\t\t\terr = btrfs_inode_set_file_extent_range(inode,\n\t\t\t\t\t\t\tcur_offset, hole_size);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\nnext:\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\t\tcur_offset = last_byte;\n\t\tif (cur_offset >= block_end)\n\t\t\tbreak;\n\t}\n\tfree_extent_map(em);\n\tunlock_extent(io_tree, hole_start, block_end - 1, &cached_state);\n\treturn err;\n}\n\nstatic int btrfs_setsize(struct inode *inode, struct iattr *attr)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\tloff_t oldsize = i_size_read(inode);\n\tloff_t newsize = attr->ia_size;\n\tint mask = attr->ia_valid;\n\tint ret;\n\n\t \n\tif (newsize != oldsize) {\n\t\tinode_inc_iversion(inode);\n\t\tif (!(mask & (ATTR_CTIME | ATTR_MTIME))) {\n\t\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\t}\n\t}\n\n\tif (newsize > oldsize) {\n\t\t \n\t\tbtrfs_drew_write_lock(&root->snapshot_lock);\n\t\tret = btrfs_cont_expand(BTRFS_I(inode), oldsize, newsize);\n\t\tif (ret) {\n\t\t\tbtrfs_drew_write_unlock(&root->snapshot_lock);\n\t\t\treturn ret;\n\t\t}\n\n\t\ttrans = btrfs_start_transaction(root, 1);\n\t\tif (IS_ERR(trans)) {\n\t\t\tbtrfs_drew_write_unlock(&root->snapshot_lock);\n\t\t\treturn PTR_ERR(trans);\n\t\t}\n\n\t\ti_size_write(inode, newsize);\n\t\tbtrfs_inode_safe_disk_i_size_write(BTRFS_I(inode), 0);\n\t\tpagecache_isize_extended(inode, oldsize, newsize);\n\t\tret = btrfs_update_inode(trans, root, BTRFS_I(inode));\n\t\tbtrfs_drew_write_unlock(&root->snapshot_lock);\n\t\tbtrfs_end_transaction(trans);\n\t} else {\n\t\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\n\t\tif (btrfs_is_zoned(fs_info)) {\n\t\t\tret = btrfs_wait_ordered_range(inode,\n\t\t\t\t\tALIGN(newsize, fs_info->sectorsize),\n\t\t\t\t\t(u64)-1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (newsize == 0)\n\t\t\tset_bit(BTRFS_INODE_FLUSH_ON_CLOSE,\n\t\t\t\t&BTRFS_I(inode)->runtime_flags);\n\n\t\ttruncate_setsize(inode, newsize);\n\n\t\tinode_dio_wait(inode);\n\n\t\tret = btrfs_truncate(BTRFS_I(inode), newsize == oldsize);\n\t\tif (ret && inode->i_nlink) {\n\t\t\tint err;\n\n\t\t\t \n\t\t\terr = btrfs_wait_ordered_range(inode, 0, (u64)-1);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\ti_size_write(inode, BTRFS_I(inode)->disk_i_size);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int btrfs_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t\t struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint err;\n\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\terr = setattr_prepare(idmap, dentry, attr);\n\tif (err)\n\t\treturn err;\n\n\tif (S_ISREG(inode->i_mode) && (attr->ia_valid & ATTR_SIZE)) {\n\t\terr = btrfs_setsize(inode, attr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (attr->ia_valid) {\n\t\tsetattr_copy(idmap, inode, attr);\n\t\tinode_inc_iversion(inode);\n\t\terr = btrfs_dirty_inode(BTRFS_I(inode));\n\n\t\tif (!err && attr->ia_valid & ATTR_MODE)\n\t\t\terr = posix_acl_chmod(idmap, dentry, inode->i_mode);\n\t}\n\n\treturn err;\n}\n\n \nstatic void evict_inode_truncate_pages(struct inode *inode)\n{\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct rb_node *node;\n\n\tASSERT(inode->i_state & I_FREEING);\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\tbtrfs_drop_extent_map_range(BTRFS_I(inode), 0, (u64)-1, false);\n\n\t \n\tspin_lock(&io_tree->lock);\n\twhile (!RB_EMPTY_ROOT(&io_tree->state)) {\n\t\tstruct extent_state *state;\n\t\tstruct extent_state *cached_state = NULL;\n\t\tu64 start;\n\t\tu64 end;\n\t\tunsigned state_flags;\n\n\t\tnode = rb_first(&io_tree->state);\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tstart = state->start;\n\t\tend = state->end;\n\t\tstate_flags = state->state;\n\t\tspin_unlock(&io_tree->lock);\n\n\t\tlock_extent(io_tree, start, end, &cached_state);\n\n\t\t \n\t\tif (state_flags & EXTENT_DELALLOC)\n\t\t\tbtrfs_qgroup_free_data(BTRFS_I(inode), NULL, start,\n\t\t\t\t\t       end - start + 1, NULL);\n\n\t\tclear_extent_bit(io_tree, start, end,\n\t\t\t\t EXTENT_CLEAR_ALL_BITS | EXTENT_DO_ACCOUNTING,\n\t\t\t\t &cached_state);\n\n\t\tcond_resched();\n\t\tspin_lock(&io_tree->lock);\n\t}\n\tspin_unlock(&io_tree->lock);\n}\n\nstatic struct btrfs_trans_handle *evict_refill_and_join(struct btrfs_root *root,\n\t\t\t\t\t\t\tstruct btrfs_block_rsv *rsv)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_trans_handle *trans;\n\tu64 delayed_refs_extra = btrfs_calc_delayed_ref_bytes(fs_info, 1);\n\tint ret;\n\n\t \n\tret = btrfs_block_rsv_refill(fs_info, rsv, rsv->size + delayed_refs_extra,\n\t\t\t\t     BTRFS_RESERVE_FLUSH_EVICT);\n\tif (ret) {\n\t\tret = btrfs_block_rsv_refill(fs_info, rsv, rsv->size,\n\t\t\t\t\t     BTRFS_RESERVE_FLUSH_EVICT);\n\t\tif (ret) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t   \"could not allocate space for delete; will truncate on mount\");\n\t\t\treturn ERR_PTR(-ENOSPC);\n\t\t}\n\t\tdelayed_refs_extra = 0;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans))\n\t\treturn trans;\n\n\tif (delayed_refs_extra) {\n\t\ttrans->block_rsv = &fs_info->trans_block_rsv;\n\t\ttrans->bytes_reserved = delayed_refs_extra;\n\t\tbtrfs_block_rsv_migrate(rsv, trans->block_rsv,\n\t\t\t\t\tdelayed_refs_extra, true);\n\t}\n\treturn trans;\n}\n\nvoid btrfs_evict_inode(struct inode *inode)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_block_rsv *rsv = NULL;\n\tint ret;\n\n\ttrace_btrfs_inode_evict(inode);\n\n\tif (!root) {\n\t\tfsverity_cleanup_inode(inode);\n\t\tclear_inode(inode);\n\t\treturn;\n\t}\n\n\tevict_inode_truncate_pages(inode);\n\n\tif (inode->i_nlink &&\n\t    ((btrfs_root_refs(&root->root_item) != 0 &&\n\t      root->root_key.objectid != BTRFS_ROOT_TREE_OBJECTID) ||\n\t     btrfs_is_free_space_inode(BTRFS_I(inode))))\n\t\tgoto out;\n\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\tif (test_bit(BTRFS_FS_LOG_RECOVERING, &fs_info->flags))\n\t\tgoto out;\n\n\tif (inode->i_nlink > 0) {\n\t\tBUG_ON(btrfs_root_refs(&root->root_item) != 0 &&\n\t\t       root->root_key.objectid != BTRFS_ROOT_TREE_OBJECTID);\n\t\tgoto out;\n\t}\n\n\t \n\tret = btrfs_commit_inode_delayed_inode(BTRFS_I(inode));\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tbtrfs_kill_delayed_inode_items(BTRFS_I(inode));\n\n\trsv = btrfs_alloc_block_rsv(fs_info, BTRFS_BLOCK_RSV_TEMP);\n\tif (!rsv)\n\t\tgoto out;\n\trsv->size = btrfs_calc_metadata_size(fs_info, 1);\n\trsv->failfast = true;\n\n\tbtrfs_i_size_write(BTRFS_I(inode), 0);\n\n\twhile (1) {\n\t\tstruct btrfs_truncate_control control = {\n\t\t\t.inode = BTRFS_I(inode),\n\t\t\t.ino = btrfs_ino(BTRFS_I(inode)),\n\t\t\t.new_size = 0,\n\t\t\t.min_type = 0,\n\t\t};\n\n\t\ttrans = evict_refill_and_join(root, rsv);\n\t\tif (IS_ERR(trans))\n\t\t\tgoto out;\n\n\t\ttrans->block_rsv = rsv;\n\n\t\tret = btrfs_truncate_inode_items(trans, root, &control);\n\t\ttrans->block_rsv = &fs_info->trans_block_rsv;\n\t\tbtrfs_end_transaction(trans);\n\t\t \n\t\tbtrfs_btree_balance_dirty_nodelay(fs_info);\n\t\tif (ret && ret != -ENOSPC && ret != -EAGAIN)\n\t\t\tgoto out;\n\t\telse if (!ret)\n\t\t\tbreak;\n\t}\n\n\t \n\ttrans = evict_refill_and_join(root, rsv);\n\tif (!IS_ERR(trans)) {\n\t\ttrans->block_rsv = rsv;\n\t\tbtrfs_orphan_del(trans, BTRFS_I(inode));\n\t\ttrans->block_rsv = &fs_info->trans_block_rsv;\n\t\tbtrfs_end_transaction(trans);\n\t}\n\nout:\n\tbtrfs_free_block_rsv(fs_info, rsv);\n\t \n\tbtrfs_remove_delayed_node(BTRFS_I(inode));\n\tfsverity_cleanup_inode(inode);\n\tclear_inode(inode);\n}\n\n \nstatic int btrfs_inode_by_name(struct btrfs_inode *dir, struct dentry *dentry,\n\t\t\t       struct btrfs_key *location, u8 *type)\n{\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = dir->root;\n\tint ret = 0;\n\tstruct fscrypt_name fname;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = fscrypt_setup_filename(&dir->vfs_inode, &dentry->d_name, 1, &fname);\n\tif (ret < 0)\n\t\tgoto out;\n\t \n\tASSERT(ret == 0);\n\n\t \n\n\tdi = btrfs_lookup_dir_item(NULL, root, path, btrfs_ino(dir),\n\t\t\t\t   &fname.disk_name, 0);\n\tif (IS_ERR_OR_NULL(di)) {\n\t\tret = di ? PTR_ERR(di) : -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, location);\n\tif (location->type != BTRFS_INODE_ITEM_KEY &&\n\t    location->type != BTRFS_ROOT_ITEM_KEY) {\n\t\tret = -EUCLEAN;\n\t\tbtrfs_warn(root->fs_info,\n\"%s gets something invalid in DIR_ITEM (name %s, directory ino %llu, location(%llu %u %llu))\",\n\t\t\t   __func__, fname.disk_name.name, btrfs_ino(dir),\n\t\t\t   location->objectid, location->type, location->offset);\n\t}\n\tif (!ret)\n\t\t*type = btrfs_dir_ftype(path->nodes[0], di);\nout:\n\tfscrypt_free_filename(&fname);\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nstatic int fixup_tree_root_location(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct btrfs_inode *dir,\n\t\t\t\t    struct dentry *dentry,\n\t\t\t\t    struct btrfs_key *location,\n\t\t\t\t    struct btrfs_root **sub_root)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *new_root;\n\tstruct btrfs_root_ref *ref;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tint ret;\n\tint err = 0;\n\tstruct fscrypt_name fname;\n\n\tret = fscrypt_setup_filename(&dir->vfs_inode, &dentry->d_name, 0, &fname);\n\tif (ret)\n\t\treturn ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = -ENOENT;\n\tkey.objectid = dir->root->root_key.objectid;\n\tkey.type = BTRFS_ROOT_REF_KEY;\n\tkey.offset = location->objectid;\n\n\tret = btrfs_search_slot(NULL, fs_info->tree_root, &key, path, 0, 0);\n\tif (ret) {\n\t\tif (ret < 0)\n\t\t\terr = ret;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tref = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_root_ref);\n\tif (btrfs_root_ref_dirid(leaf, ref) != btrfs_ino(dir) ||\n\t    btrfs_root_ref_name_len(leaf, ref) != fname.disk_name.len)\n\t\tgoto out;\n\n\tret = memcmp_extent_buffer(leaf, fname.disk_name.name,\n\t\t\t\t   (unsigned long)(ref + 1), fname.disk_name.len);\n\tif (ret)\n\t\tgoto out;\n\n\tbtrfs_release_path(path);\n\n\tnew_root = btrfs_get_fs_root(fs_info, location->objectid, true);\n\tif (IS_ERR(new_root)) {\n\t\terr = PTR_ERR(new_root);\n\t\tgoto out;\n\t}\n\n\t*sub_root = new_root;\n\tlocation->objectid = btrfs_root_dirid(&new_root->root_item);\n\tlocation->type = BTRFS_INODE_ITEM_KEY;\n\tlocation->offset = 0;\n\terr = 0;\nout:\n\tbtrfs_free_path(path);\n\tfscrypt_free_filename(&fname);\n\treturn err;\n}\n\nstatic void inode_tree_add(struct btrfs_inode *inode)\n{\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_inode *entry;\n\tstruct rb_node **p;\n\tstruct rb_node *parent;\n\tstruct rb_node *new = &inode->rb_node;\n\tu64 ino = btrfs_ino(inode);\n\n\tif (inode_unhashed(&inode->vfs_inode))\n\t\treturn;\n\tparent = NULL;\n\tspin_lock(&root->inode_lock);\n\tp = &root->inode_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct btrfs_inode, rb_node);\n\n\t\tif (ino < btrfs_ino(entry))\n\t\t\tp = &parent->rb_left;\n\t\telse if (ino > btrfs_ino(entry))\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\tWARN_ON(!(entry->vfs_inode.i_state &\n\t\t\t\t  (I_WILL_FREE | I_FREEING)));\n\t\t\trb_replace_node(parent, new, &root->inode_tree);\n\t\t\tRB_CLEAR_NODE(parent);\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn;\n\t\t}\n\t}\n\trb_link_node(new, parent, p);\n\trb_insert_color(new, &root->inode_tree);\n\tspin_unlock(&root->inode_lock);\n}\n\nstatic void inode_tree_del(struct btrfs_inode *inode)\n{\n\tstruct btrfs_root *root = inode->root;\n\tint empty = 0;\n\n\tspin_lock(&root->inode_lock);\n\tif (!RB_EMPTY_NODE(&inode->rb_node)) {\n\t\trb_erase(&inode->rb_node, &root->inode_tree);\n\t\tRB_CLEAR_NODE(&inode->rb_node);\n\t\tempty = RB_EMPTY_ROOT(&root->inode_tree);\n\t}\n\tspin_unlock(&root->inode_lock);\n\n\tif (empty && btrfs_root_refs(&root->root_item) == 0) {\n\t\tspin_lock(&root->inode_lock);\n\t\tempty = RB_EMPTY_ROOT(&root->inode_tree);\n\t\tspin_unlock(&root->inode_lock);\n\t\tif (empty)\n\t\t\tbtrfs_add_dead_root(root);\n\t}\n}\n\n\nstatic int btrfs_init_locked_inode(struct inode *inode, void *p)\n{\n\tstruct btrfs_iget_args *args = p;\n\n\tinode->i_ino = args->ino;\n\tBTRFS_I(inode)->location.objectid = args->ino;\n\tBTRFS_I(inode)->location.type = BTRFS_INODE_ITEM_KEY;\n\tBTRFS_I(inode)->location.offset = 0;\n\tBTRFS_I(inode)->root = btrfs_grab_root(args->root);\n\tBUG_ON(args->root && !BTRFS_I(inode)->root);\n\n\tif (args->root && args->root == args->root->fs_info->tree_root &&\n\t    args->ino != BTRFS_BTREE_INODE_OBJECTID)\n\t\tset_bit(BTRFS_INODE_FREE_SPACE_INODE,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\treturn 0;\n}\n\nstatic int btrfs_find_actor(struct inode *inode, void *opaque)\n{\n\tstruct btrfs_iget_args *args = opaque;\n\n\treturn args->ino == BTRFS_I(inode)->location.objectid &&\n\t\targs->root == BTRFS_I(inode)->root;\n}\n\nstatic struct inode *btrfs_iget_locked(struct super_block *s, u64 ino,\n\t\t\t\t       struct btrfs_root *root)\n{\n\tstruct inode *inode;\n\tstruct btrfs_iget_args args;\n\tunsigned long hashval = btrfs_inode_hash(ino, root);\n\n\targs.ino = ino;\n\targs.root = root;\n\n\tinode = iget5_locked(s, hashval, btrfs_find_actor,\n\t\t\t     btrfs_init_locked_inode,\n\t\t\t     (void *)&args);\n\treturn inode;\n}\n\n \nstruct inode *btrfs_iget_path(struct super_block *s, u64 ino,\n\t\t\t      struct btrfs_root *root, struct btrfs_path *path)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, ino, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tint ret;\n\n\t\tret = btrfs_read_locked_inode(inode, path);\n\t\tif (!ret) {\n\t\t\tinode_tree_add(BTRFS_I(inode));\n\t\t\tunlock_new_inode(inode);\n\t\t} else {\n\t\t\tiget_failed(inode);\n\t\t\t \n\t\t\tif (ret > 0)\n\t\t\t\tret = -ENOENT;\n\t\t\tinode = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn inode;\n}\n\nstruct inode *btrfs_iget(struct super_block *s, u64 ino, struct btrfs_root *root)\n{\n\treturn btrfs_iget_path(s, ino, root, NULL);\n}\n\nstatic struct inode *new_simple_dir(struct inode *dir,\n\t\t\t\t    struct btrfs_key *key,\n\t\t\t\t    struct btrfs_root *root)\n{\n\tstruct inode *inode = new_inode(dir->i_sb);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tBTRFS_I(inode)->root = btrfs_grab_root(root);\n\tmemcpy(&BTRFS_I(inode)->location, key, sizeof(*key));\n\tset_bit(BTRFS_INODE_DUMMY, &BTRFS_I(inode)->runtime_flags);\n\n\tinode->i_ino = BTRFS_EMPTY_SUBVOL_DIR_OBJECTID;\n\t \n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_opflags &= ~IOP_XATTR;\n\tinode->i_fop = &simple_dir_operations;\n\tinode->i_mode = S_IFDIR | S_IRUGO | S_IWUSR | S_IXUGO;\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tinode->i_atime = dir->i_atime;\n\tBTRFS_I(inode)->i_otime = inode->i_mtime;\n\tinode->i_uid = dir->i_uid;\n\tinode->i_gid = dir->i_gid;\n\n\treturn inode;\n}\n\nstatic_assert(BTRFS_FT_UNKNOWN == FT_UNKNOWN);\nstatic_assert(BTRFS_FT_REG_FILE == FT_REG_FILE);\nstatic_assert(BTRFS_FT_DIR == FT_DIR);\nstatic_assert(BTRFS_FT_CHRDEV == FT_CHRDEV);\nstatic_assert(BTRFS_FT_BLKDEV == FT_BLKDEV);\nstatic_assert(BTRFS_FT_FIFO == FT_FIFO);\nstatic_assert(BTRFS_FT_SOCK == FT_SOCK);\nstatic_assert(BTRFS_FT_SYMLINK == FT_SYMLINK);\n\nstatic inline u8 btrfs_inode_type(struct inode *inode)\n{\n\treturn fs_umode_to_ftype(inode->i_mode);\n}\n\nstruct inode *btrfs_lookup_dentry(struct inode *dir, struct dentry *dentry)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(dir->i_sb);\n\tstruct inode *inode;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_root *sub_root = root;\n\tstruct btrfs_key location;\n\tu8 di_type = 0;\n\tint ret = 0;\n\n\tif (dentry->d_name.len > BTRFS_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tret = btrfs_inode_by_name(BTRFS_I(dir), dentry, &location, &di_type);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (location.type == BTRFS_INODE_ITEM_KEY) {\n\t\tinode = btrfs_iget(dir->i_sb, location.objectid, root);\n\t\tif (IS_ERR(inode))\n\t\t\treturn inode;\n\n\t\t \n\t\tif (btrfs_inode_type(inode) != di_type) {\n\t\t\tbtrfs_crit(fs_info,\n\"inode mode mismatch with dir: inode mode=0%o btrfs type=%u dir type=%u\",\n\t\t\t\t  inode->i_mode, btrfs_inode_type(inode),\n\t\t\t\t  di_type);\n\t\t\tiput(inode);\n\t\t\treturn ERR_PTR(-EUCLEAN);\n\t\t}\n\t\treturn inode;\n\t}\n\n\tret = fixup_tree_root_location(fs_info, BTRFS_I(dir), dentry,\n\t\t\t\t       &location, &sub_root);\n\tif (ret < 0) {\n\t\tif (ret != -ENOENT)\n\t\t\tinode = ERR_PTR(ret);\n\t\telse\n\t\t\tinode = new_simple_dir(dir, &location, root);\n\t} else {\n\t\tinode = btrfs_iget(dir->i_sb, location.objectid, sub_root);\n\t\tbtrfs_put_root(sub_root);\n\n\t\tif (IS_ERR(inode))\n\t\t\treturn inode;\n\n\t\tdown_read(&fs_info->cleanup_work_sem);\n\t\tif (!sb_rdonly(inode->i_sb))\n\t\t\tret = btrfs_orphan_cleanup(sub_root);\n\t\tup_read(&fs_info->cleanup_work_sem);\n\t\tif (ret) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn inode;\n}\n\nstatic int btrfs_dentry_delete(const struct dentry *dentry)\n{\n\tstruct btrfs_root *root;\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (!inode && !IS_ROOT(dentry))\n\t\tinode = d_inode(dentry->d_parent);\n\n\tif (inode) {\n\t\troot = BTRFS_I(inode)->root;\n\t\tif (btrfs_root_refs(&root->root_item) == 0)\n\t\t\treturn 1;\n\n\t\tif (btrfs_ino(BTRFS_I(inode)) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic struct dentry *btrfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct inode *inode = btrfs_lookup_dentry(dir, dentry);\n\n\tif (inode == ERR_PTR(-ENOENT))\n\t\tinode = NULL;\n\treturn d_splice_alias(inode, dentry);\n}\n\n \nstatic int btrfs_set_inode_index_count(struct btrfs_inode *inode)\n{\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_key key, found_key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = (u64)-1;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\t \n\tif (ret == 0)\n\t\tgoto out;\n\tret = 0;\n\n\tif (path->slots[0] == 0) {\n\t\tinode->index_cnt = BTRFS_DIR_START_INDEX;\n\t\tgoto out;\n\t}\n\n\tpath->slots[0]--;\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\tif (found_key.objectid != btrfs_ino(inode) ||\n\t    found_key.type != BTRFS_DIR_INDEX_KEY) {\n\t\tinode->index_cnt = BTRFS_DIR_START_INDEX;\n\t\tgoto out;\n\t}\n\n\tinode->index_cnt = found_key.offset + 1;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int btrfs_get_dir_last_index(struct btrfs_inode *dir, u64 *index)\n{\n\tint ret = 0;\n\n\tbtrfs_inode_lock(dir, 0);\n\tif (dir->index_cnt == (u64)-1) {\n\t\tret = btrfs_inode_delayed_dir_index_count(dir);\n\t\tif (ret) {\n\t\t\tret = btrfs_set_inode_index_count(dir);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\t*index = dir->index_cnt - 1;\nout:\n\tbtrfs_inode_unlock(dir, 0);\n\n\treturn ret;\n}\n\n \nstatic int btrfs_opendir(struct inode *inode, struct file *file)\n{\n\tstruct btrfs_file_private *private;\n\tu64 last_index;\n\tint ret;\n\n\tret = btrfs_get_dir_last_index(BTRFS_I(inode), &last_index);\n\tif (ret)\n\t\treturn ret;\n\n\tprivate = kzalloc(sizeof(struct btrfs_file_private), GFP_KERNEL);\n\tif (!private)\n\t\treturn -ENOMEM;\n\tprivate->last_index = last_index;\n\tprivate->filldir_buf = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!private->filldir_buf) {\n\t\tkfree(private);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = private;\n\treturn 0;\n}\n\nstatic loff_t btrfs_dir_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct btrfs_file_private *private = file->private_data;\n\tint ret;\n\n\tret = btrfs_get_dir_last_index(BTRFS_I(file_inode(file)),\n\t\t\t\t       &private->last_index);\n\tif (ret)\n\t\treturn ret;\n\n\treturn generic_file_llseek(file, offset, whence);\n}\n\nstruct dir_entry {\n\tu64 ino;\n\tu64 offset;\n\tunsigned type;\n\tint name_len;\n};\n\nstatic int btrfs_filldir(void *addr, int entries, struct dir_context *ctx)\n{\n\twhile (entries--) {\n\t\tstruct dir_entry *entry = addr;\n\t\tchar *name = (char *)(entry + 1);\n\n\t\tctx->pos = get_unaligned(&entry->offset);\n\t\tif (!dir_emit(ctx, name, get_unaligned(&entry->name_len),\n\t\t\t\t\t get_unaligned(&entry->ino),\n\t\t\t\t\t get_unaligned(&entry->type)))\n\t\t\treturn 1;\n\t\taddr += sizeof(struct dir_entry) +\n\t\t\tget_unaligned(&entry->name_len);\n\t\tctx->pos++;\n\t}\n\treturn 0;\n}\n\nstatic int btrfs_real_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_file_private *private = file->private_data;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tvoid *addr;\n\tLIST_HEAD(ins_list);\n\tLIST_HEAD(del_list);\n\tint ret;\n\tchar *name_ptr;\n\tint name_len;\n\tint entries = 0;\n\tint total_len = 0;\n\tbool put = false;\n\tstruct btrfs_key location;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\taddr = private->filldir_buf;\n\tpath->reada = READA_FORWARD;\n\n\tput = btrfs_readdir_get_delayed_items(inode, private->last_index,\n\t\t\t\t\t      &ins_list, &del_list);\n\nagain:\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = ctx->pos;\n\tkey.objectid = btrfs_ino(BTRFS_I(inode));\n\n\tbtrfs_for_each_slot(root, &key, &found_key, path, ret) {\n\t\tstruct dir_entry *entry;\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tu8 ftype;\n\n\t\tif (found_key.objectid != key.objectid)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_DIR_INDEX_KEY)\n\t\t\tbreak;\n\t\tif (found_key.offset < ctx->pos)\n\t\t\tcontinue;\n\t\tif (found_key.offset > private->last_index)\n\t\t\tbreak;\n\t\tif (btrfs_should_delete_dir_index(&del_list, found_key.offset))\n\t\t\tcontinue;\n\t\tdi = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\t\tname_len = btrfs_dir_name_len(leaf, di);\n\t\tif ((total_len + sizeof(struct dir_entry) + name_len) >=\n\t\t    PAGE_SIZE) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tret = btrfs_filldir(private->filldir_buf, entries, ctx);\n\t\t\tif (ret)\n\t\t\t\tgoto nopos;\n\t\t\taddr = private->filldir_buf;\n\t\t\tentries = 0;\n\t\t\ttotal_len = 0;\n\t\t\tgoto again;\n\t\t}\n\n\t\tftype = btrfs_dir_flags_to_ftype(btrfs_dir_flags(leaf, di));\n\t\tentry = addr;\n\t\tname_ptr = (char *)(entry + 1);\n\t\tread_extent_buffer(leaf, name_ptr,\n\t\t\t\t   (unsigned long)(di + 1), name_len);\n\t\tput_unaligned(name_len, &entry->name_len);\n\t\tput_unaligned(fs_ftype_to_dtype(ftype), &entry->type);\n\t\tbtrfs_dir_item_key_to_cpu(leaf, di, &location);\n\t\tput_unaligned(location.objectid, &entry->ino);\n\t\tput_unaligned(found_key.offset, &entry->offset);\n\t\tentries++;\n\t\taddr += sizeof(struct dir_entry) + name_len;\n\t\ttotal_len += sizeof(struct dir_entry) + name_len;\n\t}\n\t \n\tif (ret < 0)\n\t\tgoto err;\n\n\tbtrfs_release_path(path);\n\n\tret = btrfs_filldir(private->filldir_buf, entries, ctx);\n\tif (ret)\n\t\tgoto nopos;\n\n\tret = btrfs_readdir_delayed_dir_index(ctx, &ins_list);\n\tif (ret)\n\t\tgoto nopos;\n\n\t \n\tif (ctx->pos >= INT_MAX)\n\t\tctx->pos = LLONG_MAX;\n\telse\n\t\tctx->pos = INT_MAX;\nnopos:\n\tret = 0;\nerr:\n\tif (put)\n\t\tbtrfs_readdir_put_delayed_items(inode, &ins_list, &del_list);\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nstatic int btrfs_dirty_inode(struct btrfs_inode *inode)\n{\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tif (test_bit(BTRFS_INODE_DUMMY, &inode->runtime_flags))\n\t\treturn 0;\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret && (ret == -ENOSPC || ret == -EDQUOT)) {\n\t\t \n\t\tbtrfs_end_transaction(trans);\n\t\ttrans = btrfs_start_transaction(root, 1);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t}\n\tbtrfs_end_transaction(trans);\n\tif (inode->delayed_node)\n\t\tbtrfs_balance_delayed_items(fs_info);\n\n\treturn ret;\n}\n\n \nstatic int btrfs_update_time(struct inode *inode, int flags)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tbool dirty = flags & ~S_VERSION;\n\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\tdirty = inode_update_timestamps(inode, flags);\n\treturn dirty ? btrfs_dirty_inode(BTRFS_I(inode)) : 0;\n}\n\n \nint btrfs_set_inode_index(struct btrfs_inode *dir, u64 *index)\n{\n\tint ret = 0;\n\n\tif (dir->index_cnt == (u64)-1) {\n\t\tret = btrfs_inode_delayed_dir_index_count(dir);\n\t\tif (ret) {\n\t\t\tret = btrfs_set_inode_index_count(dir);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t*index = dir->index_cnt;\n\tdir->index_cnt++;\n\n\treturn ret;\n}\n\nstatic int btrfs_insert_inode_locked(struct inode *inode)\n{\n\tstruct btrfs_iget_args args;\n\n\targs.ino = BTRFS_I(inode)->location.objectid;\n\targs.root = BTRFS_I(inode)->root;\n\n\treturn insert_inode_locked4(inode,\n\t\t   btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root),\n\t\t   btrfs_find_actor, &args);\n}\n\nint btrfs_new_inode_prepare(struct btrfs_new_inode_args *args,\n\t\t\t    unsigned int *trans_num_items)\n{\n\tstruct inode *dir = args->dir;\n\tstruct inode *inode = args->inode;\n\tint ret;\n\n\tif (!args->orphan) {\n\t\tret = fscrypt_setup_filename(dir, &args->dentry->d_name, 0,\n\t\t\t\t\t     &args->fname);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = posix_acl_create(dir, &inode->i_mode, &args->default_acl, &args->acl);\n\tif (ret) {\n\t\tfscrypt_free_filename(&args->fname);\n\t\treturn ret;\n\t}\n\n\t \n\t*trans_num_items = 1;\n\t \n\tif (BTRFS_I(dir)->prop_compress)\n\t\t(*trans_num_items)++;\n\t \n\tif (args->default_acl)\n\t\t(*trans_num_items)++;\n\t \n\tif (args->acl)\n\t\t(*trans_num_items)++;\n#ifdef CONFIG_SECURITY\n\t \n\tif (dir->i_security)\n\t\t(*trans_num_items)++;\n#endif\n\tif (args->orphan) {\n\t\t \n\t\t(*trans_num_items)++;\n\t} else {\n\t\t \n\t\t*trans_num_items += 3;\n\t}\n\treturn 0;\n}\n\nvoid btrfs_new_inode_args_destroy(struct btrfs_new_inode_args *args)\n{\n\tposix_acl_release(args->acl);\n\tposix_acl_release(args->default_acl);\n\tfscrypt_free_filename(&args->fname);\n}\n\n \nstatic void btrfs_inherit_iflags(struct btrfs_inode *inode, struct btrfs_inode *dir)\n{\n\tunsigned int flags;\n\n\tflags = dir->flags;\n\n\tif (flags & BTRFS_INODE_NOCOMPRESS) {\n\t\tinode->flags &= ~BTRFS_INODE_COMPRESS;\n\t\tinode->flags |= BTRFS_INODE_NOCOMPRESS;\n\t} else if (flags & BTRFS_INODE_COMPRESS) {\n\t\tinode->flags &= ~BTRFS_INODE_NOCOMPRESS;\n\t\tinode->flags |= BTRFS_INODE_COMPRESS;\n\t}\n\n\tif (flags & BTRFS_INODE_NODATACOW) {\n\t\tinode->flags |= BTRFS_INODE_NODATACOW;\n\t\tif (S_ISREG(inode->vfs_inode.i_mode))\n\t\t\tinode->flags |= BTRFS_INODE_NODATASUM;\n\t}\n\n\tbtrfs_sync_inode_flags_to_i_flags(&inode->vfs_inode);\n}\n\nint btrfs_create_new_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_new_inode_args *args)\n{\n\tstruct inode *dir = args->dir;\n\tstruct inode *inode = args->inode;\n\tconst struct fscrypt_str *name = args->orphan ? NULL : &args->fname.disk_name;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(dir->i_sb);\n\tstruct btrfs_root *root;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct btrfs_key *location;\n\tstruct btrfs_path *path;\n\tu64 objectid;\n\tstruct btrfs_inode_ref *ref;\n\tstruct btrfs_key key[2];\n\tu32 sizes[2];\n\tstruct btrfs_item_batch batch;\n\tunsigned long ptr;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (!args->subvol)\n\t\tBTRFS_I(inode)->root = btrfs_grab_root(BTRFS_I(dir)->root);\n\troot = BTRFS_I(inode)->root;\n\n\tret = btrfs_get_free_objectid(root, &objectid);\n\tif (ret)\n\t\tgoto out;\n\tinode->i_ino = objectid;\n\n\tif (args->orphan) {\n\t\t \n\t\tset_nlink(inode, 0);\n\t} else {\n\t\ttrace_btrfs_inode_request(dir);\n\n\t\tret = btrfs_set_inode_index(BTRFS_I(dir), &BTRFS_I(inode)->dir_index);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\t \n\tBTRFS_I(inode)->index_cnt = BTRFS_DIR_START_INDEX;\n\tBTRFS_I(inode)->generation = trans->transid;\n\tinode->i_generation = BTRFS_I(inode)->generation;\n\n\t \n\tif (!args->subvol)\n\t\tbtrfs_inherit_iflags(BTRFS_I(inode), BTRFS_I(dir));\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (btrfs_test_opt(fs_info, NODATASUM))\n\t\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NODATASUM;\n\t\tif (btrfs_test_opt(fs_info, NODATACOW))\n\t\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NODATACOW |\n\t\t\t\tBTRFS_INODE_NODATASUM;\n\t}\n\n\tlocation = &BTRFS_I(inode)->location;\n\tlocation->objectid = objectid;\n\tlocation->offset = 0;\n\tlocation->type = BTRFS_INODE_ITEM_KEY;\n\n\tret = btrfs_insert_inode_locked(inode);\n\tif (ret < 0) {\n\t\tif (!args->orphan)\n\t\t\tBTRFS_I(dir)->index_cnt--;\n\t\tgoto out;\n\t}\n\n\t \n\tbtrfs_set_inode_full_sync(BTRFS_I(inode));\n\n\tkey[0].objectid = objectid;\n\tkey[0].type = BTRFS_INODE_ITEM_KEY;\n\tkey[0].offset = 0;\n\n\tsizes[0] = sizeof(struct btrfs_inode_item);\n\n\tif (!args->orphan) {\n\t\t \n\t\tkey[1].objectid = objectid;\n\t\tkey[1].type = BTRFS_INODE_REF_KEY;\n\t\tif (args->subvol) {\n\t\t\tkey[1].offset = objectid;\n\t\t\tsizes[1] = 2 + sizeof(*ref);\n\t\t} else {\n\t\t\tkey[1].offset = btrfs_ino(BTRFS_I(dir));\n\t\t\tsizes[1] = name->len + sizeof(*ref);\n\t\t}\n\t}\n\n\tbatch.keys = &key[0];\n\tbatch.data_sizes = &sizes[0];\n\tbatch.total_data_size = sizes[0] + (args->orphan ? 0 : sizes[1]);\n\tbatch.nr = args->orphan ? 1 : 2;\n\tret = btrfs_insert_empty_items(trans, root, path, &batch);\n\tif (ret != 0) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto discard;\n\t}\n\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tinode->i_atime = inode->i_mtime;\n\tBTRFS_I(inode)->i_otime = inode->i_mtime;\n\n\t \n\n\tinode_item = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t  struct btrfs_inode_item);\n\tmemzero_extent_buffer(path->nodes[0], (unsigned long)inode_item,\n\t\t\t     sizeof(*inode_item));\n\tfill_inode_item(trans, path->nodes[0], inode_item, inode);\n\n\tif (!args->orphan) {\n\t\tref = btrfs_item_ptr(path->nodes[0], path->slots[0] + 1,\n\t\t\t\t     struct btrfs_inode_ref);\n\t\tptr = (unsigned long)(ref + 1);\n\t\tif (args->subvol) {\n\t\t\tbtrfs_set_inode_ref_name_len(path->nodes[0], ref, 2);\n\t\t\tbtrfs_set_inode_ref_index(path->nodes[0], ref, 0);\n\t\t\twrite_extent_buffer(path->nodes[0], \"..\", ptr, 2);\n\t\t} else {\n\t\t\tbtrfs_set_inode_ref_name_len(path->nodes[0], ref,\n\t\t\t\t\t\t     name->len);\n\t\t\tbtrfs_set_inode_ref_index(path->nodes[0], ref,\n\t\t\t\t\t\t  BTRFS_I(inode)->dir_index);\n\t\t\twrite_extent_buffer(path->nodes[0], name->name, ptr,\n\t\t\t\t\t    name->len);\n\t\t}\n\t}\n\n\tbtrfs_mark_buffer_dirty(trans, path->nodes[0]);\n\t \n\tbtrfs_free_path(path);\n\tpath = NULL;\n\n\tif (args->subvol) {\n\t\tstruct inode *parent;\n\n\t\t \n\t\tparent = btrfs_iget(fs_info->sb, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\t    BTRFS_I(dir)->root);\n\t\tif (IS_ERR(parent)) {\n\t\t\tret = PTR_ERR(parent);\n\t\t} else {\n\t\t\tret = btrfs_inode_inherit_props(trans, inode, parent);\n\t\t\tiput(parent);\n\t\t}\n\t} else {\n\t\tret = btrfs_inode_inherit_props(trans, inode, dir);\n\t}\n\tif (ret) {\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"error inheriting props for ino %llu (root %llu): %d\",\n\t\t\t  btrfs_ino(BTRFS_I(inode)), root->root_key.objectid,\n\t\t\t  ret);\n\t}\n\n\t \n\tif (!args->subvol) {\n\t\tret = btrfs_init_inode_security(trans, args);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto discard;\n\t\t}\n\t}\n\n\tinode_tree_add(BTRFS_I(inode));\n\n\ttrace_btrfs_inode_new(inode);\n\tbtrfs_set_inode_last_trans(trans, BTRFS_I(inode));\n\n\tbtrfs_update_root_times(trans, root);\n\n\tif (args->orphan) {\n\t\tret = btrfs_orphan_add(trans, BTRFS_I(inode));\n\t} else {\n\t\tret = btrfs_add_link(trans, BTRFS_I(dir), BTRFS_I(inode), name,\n\t\t\t\t     0, BTRFS_I(inode)->dir_index);\n\t}\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto discard;\n\t}\n\n\treturn 0;\n\ndiscard:\n\t \n\tihold(inode);\n\tdiscard_new_inode(inode);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nint btrfs_add_link(struct btrfs_trans_handle *trans,\n\t\t   struct btrfs_inode *parent_inode, struct btrfs_inode *inode,\n\t\t   const struct fscrypt_str *name, int add_backref, u64 index)\n{\n\tint ret = 0;\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = parent_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tu64 parent_ino = btrfs_ino(parent_inode);\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tmemcpy(&key, &inode->root->root_key, sizeof(key));\n\t} else {\n\t\tkey.objectid = ino;\n\t\tkey.type = BTRFS_INODE_ITEM_KEY;\n\t\tkey.offset = 0;\n\t}\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_add_root_ref(trans, key.objectid,\n\t\t\t\t\t root->root_key.objectid, parent_ino,\n\t\t\t\t\t index, name);\n\t} else if (add_backref) {\n\t\tret = btrfs_insert_inode_ref(trans, root, name,\n\t\t\t\t\t     ino, parent_ino, index);\n\t}\n\n\t \n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_insert_dir_item(trans, name, parent_inode, &key,\n\t\t\t\t    btrfs_inode_type(&inode->vfs_inode), index);\n\tif (ret == -EEXIST || ret == -EOVERFLOW)\n\t\tgoto fail_dir_item;\n\telse if (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\treturn ret;\n\t}\n\n\tbtrfs_i_size_write(parent_inode, parent_inode->vfs_inode.i_size +\n\t\t\t   name->len * 2);\n\tinode_inc_iversion(&parent_inode->vfs_inode);\n\t \n\tif (!test_bit(BTRFS_FS_LOG_RECOVERING, &root->fs_info->flags))\n\t\tparent_inode->vfs_inode.i_mtime =\n\t\t\tinode_set_ctime_current(&parent_inode->vfs_inode);\n\n\tret = btrfs_update_inode(trans, root, parent_inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, ret);\n\treturn ret;\n\nfail_dir_item:\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tu64 local_index;\n\t\tint err;\n\t\terr = btrfs_del_root_ref(trans, key.objectid,\n\t\t\t\t\t root->root_key.objectid, parent_ino,\n\t\t\t\t\t &local_index, name);\n\t\tif (err)\n\t\t\tbtrfs_abort_transaction(trans, err);\n\t} else if (add_backref) {\n\t\tu64 local_index;\n\t\tint err;\n\n\t\terr = btrfs_del_inode_ref(trans, root, name, ino, parent_ino,\n\t\t\t\t\t  &local_index);\n\t\tif (err)\n\t\t\tbtrfs_abort_transaction(trans, err);\n\t}\n\n\t \n\treturn ret;\n}\n\nstatic int btrfs_create_common(struct inode *dir, struct dentry *dentry,\n\t\t\t       struct inode *inode)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(dir->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_new_inode_args new_inode_args = {\n\t\t.dir = dir,\n\t\t.dentry = dentry,\n\t\t.inode = inode,\n\t};\n\tunsigned int trans_num_items;\n\tstruct btrfs_trans_handle *trans;\n\tint err;\n\n\terr = btrfs_new_inode_prepare(&new_inode_args, &trans_num_items);\n\tif (err)\n\t\tgoto out_inode;\n\n\ttrans = btrfs_start_transaction(root, trans_num_items);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_new_inode_args;\n\t}\n\n\terr = btrfs_create_new_inode(trans, &new_inode_args);\n\tif (!err)\n\t\td_instantiate_new(dentry, inode);\n\n\tbtrfs_end_transaction(trans);\n\tbtrfs_btree_balance_dirty(fs_info);\nout_new_inode_args:\n\tbtrfs_new_inode_args_destroy(&new_inode_args);\nout_inode:\n\tif (err)\n\t\tiput(inode);\n\treturn err;\n}\n\nstatic int btrfs_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\tinode_init_owner(idmap, inode, dir, mode);\n\tinode->i_op = &btrfs_special_inode_operations;\n\tinit_special_inode(inode, inode->i_mode, rdev);\n\treturn btrfs_create_common(dir, dentry, inode);\n}\n\nstatic int btrfs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\tinode_init_owner(idmap, inode, dir, mode);\n\tinode->i_fop = &btrfs_file_operations;\n\tinode->i_op = &btrfs_file_inode_operations;\n\tinode->i_mapping->a_ops = &btrfs_aops;\n\treturn btrfs_create_common(dir, dentry, inode);\n}\n\nstatic int btrfs_link(struct dentry *old_dentry, struct inode *dir,\n\t\t      struct dentry *dentry)\n{\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct inode *inode = d_inode(old_dentry);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct fscrypt_name fname;\n\tu64 index;\n\tint err;\n\tint drop_inode = 0;\n\n\t \n\tif (root->root_key.objectid != BTRFS_I(inode)->root->root_key.objectid)\n\t\treturn -EXDEV;\n\n\tif (inode->i_nlink >= BTRFS_LINK_MAX)\n\t\treturn -EMLINK;\n\n\terr = fscrypt_setup_filename(dir, &dentry->d_name, 0, &fname);\n\tif (err)\n\t\tgoto fail;\n\n\terr = btrfs_set_inode_index(BTRFS_I(dir), &index);\n\tif (err)\n\t\tgoto fail;\n\n\t \n\ttrans = btrfs_start_transaction(root, inode->i_nlink ? 5 : 6);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\ttrans = NULL;\n\t\tgoto fail;\n\t}\n\n\t \n\tBTRFS_I(inode)->dir_index = 0ULL;\n\tinc_nlink(inode);\n\tinode_inc_iversion(inode);\n\tinode_set_ctime_current(inode);\n\tihold(inode);\n\tset_bit(BTRFS_INODE_COPY_EVERYTHING, &BTRFS_I(inode)->runtime_flags);\n\n\terr = btrfs_add_link(trans, BTRFS_I(dir), BTRFS_I(inode),\n\t\t\t     &fname.disk_name, 1, index);\n\n\tif (err) {\n\t\tdrop_inode = 1;\n\t} else {\n\t\tstruct dentry *parent = dentry->d_parent;\n\n\t\terr = btrfs_update_inode(trans, root, BTRFS_I(inode));\n\t\tif (err)\n\t\t\tgoto fail;\n\t\tif (inode->i_nlink == 1) {\n\t\t\t \n\t\t\terr = btrfs_orphan_del(trans, BTRFS_I(inode));\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\t\t}\n\t\td_instantiate(dentry, inode);\n\t\tbtrfs_log_new_name(trans, old_dentry, NULL, 0, parent);\n\t}\n\nfail:\n\tfscrypt_free_filename(&fname);\n\tif (trans)\n\t\tbtrfs_end_transaction(trans);\n\tif (drop_inode) {\n\t\tinode_dec_link_count(inode);\n\t\tiput(inode);\n\t}\n\tbtrfs_btree_balance_dirty(fs_info);\n\treturn err;\n}\n\nstatic int btrfs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\tinode_init_owner(idmap, inode, dir, S_IFDIR | mode);\n\tinode->i_op = &btrfs_dir_inode_operations;\n\tinode->i_fop = &btrfs_dir_file_operations;\n\treturn btrfs_create_common(dir, dentry, inode);\n}\n\nstatic noinline int uncompress_inline(struct btrfs_path *path,\n\t\t\t\t      struct page *page,\n\t\t\t\t      struct btrfs_file_extent_item *item)\n{\n\tint ret;\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tchar *tmp;\n\tsize_t max_size;\n\tunsigned long inline_size;\n\tunsigned long ptr;\n\tint compress_type;\n\n\tcompress_type = btrfs_file_extent_compression(leaf, item);\n\tmax_size = btrfs_file_extent_ram_bytes(leaf, item);\n\tinline_size = btrfs_file_extent_inline_item_len(leaf, path->slots[0]);\n\ttmp = kmalloc(inline_size, GFP_NOFS);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\tptr = btrfs_file_extent_inline_start(item);\n\n\tread_extent_buffer(leaf, tmp, ptr, inline_size);\n\n\tmax_size = min_t(unsigned long, PAGE_SIZE, max_size);\n\tret = btrfs_decompress(compress_type, tmp, page, 0, inline_size, max_size);\n\n\t \n\n\tif (max_size < PAGE_SIZE)\n\t\tmemzero_page(page, max_size, PAGE_SIZE - max_size);\n\tkfree(tmp);\n\treturn ret;\n}\n\nstatic int read_inline_extent(struct btrfs_inode *inode, struct btrfs_path *path,\n\t\t\t      struct page *page)\n{\n\tstruct btrfs_file_extent_item *fi;\n\tvoid *kaddr;\n\tsize_t copy_size;\n\n\tif (!page || PageUptodate(page))\n\t\treturn 0;\n\n\tASSERT(page_offset(page) == 0);\n\n\tfi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\tif (btrfs_file_extent_compression(path->nodes[0], fi) != BTRFS_COMPRESS_NONE)\n\t\treturn uncompress_inline(path, page, fi);\n\n\tcopy_size = min_t(u64, PAGE_SIZE,\n\t\t\t  btrfs_file_extent_ram_bytes(path->nodes[0], fi));\n\tkaddr = kmap_local_page(page);\n\tread_extent_buffer(path->nodes[0], kaddr,\n\t\t\t   btrfs_file_extent_inline_start(fi), copy_size);\n\tkunmap_local(kaddr);\n\tif (copy_size < PAGE_SIZE)\n\t\tmemzero_page(page, copy_size, PAGE_SIZE - copy_size);\n\treturn 0;\n}\n\n \nstruct extent_map *btrfs_get_extent(struct btrfs_inode *inode,\n\t\t\t\t    struct page *page, size_t pg_offset,\n\t\t\t\t    u64 start, u64 len)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tint ret = 0;\n\tu64 extent_start = 0;\n\tu64 extent_end = 0;\n\tu64 objectid = btrfs_ino(inode);\n\tint extent_type = -1;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_file_extent_item *item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key found_key;\n\tstruct extent_map *em = NULL;\n\tstruct extent_map_tree *em_tree = &inode->extent_tree;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, start, len);\n\tread_unlock(&em_tree->lock);\n\n\tif (em) {\n\t\tif (em->start > start || em->start + em->len <= start)\n\t\t\tfree_extent_map(em);\n\t\telse if (em->block_start == EXTENT_MAP_INLINE && page)\n\t\t\tfree_extent_map(em);\n\t\telse\n\t\t\tgoto out;\n\t}\n\tem = alloc_extent_map();\n\tif (!em) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tem->start = EXTENT_MAP_HOLE;\n\tem->orig_start = EXTENT_MAP_HOLE;\n\tem->len = (u64)-1;\n\tem->block_len = (u64)-1;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tpath->reada = READA_FORWARD;\n\n\t \n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tpath->search_commit_root = 1;\n\t\tpath->skip_locking = 1;\n\t}\n\n\tret = btrfs_lookup_file_extent(NULL, root, path, objectid, start, 0);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret > 0) {\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto not_found;\n\t\tpath->slots[0]--;\n\t\tret = 0;\n\t}\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t      struct btrfs_file_extent_item);\n\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\tif (found_key.objectid != objectid ||\n\t    found_key.type != BTRFS_EXTENT_DATA_KEY) {\n\t\t \n\t\textent_end = start;\n\t\tgoto next;\n\t}\n\n\textent_type = btrfs_file_extent_type(leaf, item);\n\textent_start = found_key.offset;\n\textent_end = btrfs_file_extent_end(path);\n\tif (extent_type == BTRFS_FILE_EXTENT_REG ||\n\t    extent_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t \n\t\tif (!S_ISREG(inode->vfs_inode.i_mode)) {\n\t\t\tret = -EUCLEAN;\n\t\t\tbtrfs_crit(fs_info,\n\t\t\"regular/prealloc extent found for non-regular inode %llu\",\n\t\t\t\t   btrfs_ino(inode));\n\t\t\tgoto out;\n\t\t}\n\t\ttrace_btrfs_get_extent_show_fi_regular(inode, leaf, item,\n\t\t\t\t\t\t       extent_start);\n\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\ttrace_btrfs_get_extent_show_fi_inline(inode, leaf, item,\n\t\t\t\t\t\t      path->slots[0],\n\t\t\t\t\t\t      extent_start);\n\t}\nnext:\n\tif (start >= extent_end) {\n\t\tpath->slots[0]++;\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tgoto not_found;\n\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid != objectid ||\n\t\t    found_key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto not_found;\n\t\tif (start + len <= found_key.offset)\n\t\t\tgoto not_found;\n\t\tif (start > found_key.offset)\n\t\t\tgoto next;\n\n\t\t \n\t\tem->start = start;\n\t\tem->orig_start = start;\n\t\tem->len = found_key.offset - start;\n\t\tem->block_start = EXTENT_MAP_HOLE;\n\t\tgoto insert;\n\t}\n\n\tbtrfs_extent_item_to_extent_map(inode, path, item, em);\n\n\tif (extent_type == BTRFS_FILE_EXTENT_REG ||\n\t    extent_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tgoto insert;\n\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t \n\t\tASSERT(pg_offset == 0);\n\t\tASSERT(extent_start == 0);\n\t\tASSERT(em->start == 0);\n\n\t\t \n\t\tASSERT(em->block_start == EXTENT_MAP_INLINE);\n\t\tASSERT(em->len == fs_info->sectorsize);\n\n\t\tret = read_inline_extent(inode, path, page);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tgoto insert;\n\t}\nnot_found:\n\tem->start = start;\n\tem->orig_start = start;\n\tem->len = len;\n\tem->block_start = EXTENT_MAP_HOLE;\ninsert:\n\tret = 0;\n\tbtrfs_release_path(path);\n\tif (em->start > start || extent_map_end(em) <= start) {\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"bad extent! em: [%llu %llu] passed [%llu %llu]\",\n\t\t\t  em->start, em->len, start, len);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\twrite_lock(&em_tree->lock);\n\tret = btrfs_add_extent_mapping(fs_info, em_tree, &em, start, len);\n\twrite_unlock(&em_tree->lock);\nout:\n\tbtrfs_free_path(path);\n\n\ttrace_btrfs_get_extent(root, inode, em);\n\n\tif (ret) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(ret);\n\t}\n\treturn em;\n}\n\nstatic struct extent_map *btrfs_create_dio_extent(struct btrfs_inode *inode,\n\t\t\t\t\t\t  struct btrfs_dio_data *dio_data,\n\t\t\t\t\t\t  const u64 start,\n\t\t\t\t\t\t  const u64 len,\n\t\t\t\t\t\t  const u64 orig_start,\n\t\t\t\t\t\t  const u64 block_start,\n\t\t\t\t\t\t  const u64 block_len,\n\t\t\t\t\t\t  const u64 orig_block_len,\n\t\t\t\t\t\t  const u64 ram_bytes,\n\t\t\t\t\t\t  const int type)\n{\n\tstruct extent_map *em = NULL;\n\tstruct btrfs_ordered_extent *ordered;\n\n\tif (type != BTRFS_ORDERED_NOCOW) {\n\t\tem = create_io_em(inode, start, len, orig_start, block_start,\n\t\t\t\t  block_len, orig_block_len, ram_bytes,\n\t\t\t\t  BTRFS_COMPRESS_NONE,  \n\t\t\t\t  type);\n\t\tif (IS_ERR(em))\n\t\t\tgoto out;\n\t}\n\tordered = btrfs_alloc_ordered_extent(inode, start, len, len,\n\t\t\t\t\t     block_start, block_len, 0,\n\t\t\t\t\t     (1 << type) |\n\t\t\t\t\t     (1 << BTRFS_ORDERED_DIRECT),\n\t\t\t\t\t     BTRFS_COMPRESS_NONE);\n\tif (IS_ERR(ordered)) {\n\t\tif (em) {\n\t\t\tfree_extent_map(em);\n\t\t\tbtrfs_drop_extent_map_range(inode, start,\n\t\t\t\t\t\t    start + len - 1, false);\n\t\t}\n\t\tem = ERR_CAST(ordered);\n\t} else {\n\t\tASSERT(!dio_data->ordered);\n\t\tdio_data->ordered = ordered;\n\t}\n out:\n\n\treturn em;\n}\n\nstatic struct extent_map *btrfs_new_extent_direct(struct btrfs_inode *inode,\n\t\t\t\t\t\t  struct btrfs_dio_data *dio_data,\n\t\t\t\t\t\t  u64 start, u64 len)\n{\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct extent_map *em;\n\tstruct btrfs_key ins;\n\tu64 alloc_hint;\n\tint ret;\n\n\talloc_hint = get_extent_allocation_hint(inode, start, len);\nagain:\n\tret = btrfs_reserve_extent(root, len, len, fs_info->sectorsize,\n\t\t\t\t   0, alloc_hint, &ins, 1, 1);\n\tif (ret == -EAGAIN) {\n\t\tASSERT(btrfs_is_zoned(fs_info));\n\t\twait_on_bit_io(&inode->root->fs_info->flags, BTRFS_FS_NEED_ZONE_FINISH,\n\t\t\t       TASK_UNINTERRUPTIBLE);\n\t\tgoto again;\n\t}\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tem = btrfs_create_dio_extent(inode, dio_data, start, ins.offset, start,\n\t\t\t\t     ins.objectid, ins.offset, ins.offset,\n\t\t\t\t     ins.offset, BTRFS_ORDERED_REGULAR);\n\tbtrfs_dec_block_group_reservations(fs_info, ins.objectid);\n\tif (IS_ERR(em))\n\t\tbtrfs_free_reserved_extent(fs_info, ins.objectid, ins.offset,\n\t\t\t\t\t   1);\n\n\treturn em;\n}\n\nstatic bool btrfs_extent_readonly(struct btrfs_fs_info *fs_info, u64 bytenr)\n{\n\tstruct btrfs_block_group *block_group;\n\tbool readonly = false;\n\n\tblock_group = btrfs_lookup_block_group(fs_info, bytenr);\n\tif (!block_group || block_group->ro)\n\t\treadonly = true;\n\tif (block_group)\n\t\tbtrfs_put_block_group(block_group);\n\treturn readonly;\n}\n\n \nnoinline int can_nocow_extent(struct inode *inode, u64 offset, u64 *len,\n\t\t\t      u64 *orig_start, u64 *orig_block_len,\n\t\t\t      u64 *ram_bytes, bool nowait, bool strict)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct can_nocow_file_extent_args nocow_args = { 0 };\n\tstruct btrfs_path *path;\n\tint ret;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tint found_type;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->nowait = nowait;\n\n\tret = btrfs_lookup_file_extent(NULL, root, path,\n\t\t\tbtrfs_ino(BTRFS_I(inode)), offset, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret == 1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\t \n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tpath->slots[0]--;\n\t}\n\tret = 0;\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tif (key.objectid != btrfs_ino(BTRFS_I(inode)) ||\n\t    key.type != BTRFS_EXTENT_DATA_KEY) {\n\t\t \n\t\tgoto out;\n\t}\n\n\tif (key.offset > offset) {\n\t\t \n\t\tgoto out;\n\t}\n\n\tif (btrfs_file_extent_end(path) <= offset)\n\t\tgoto out;\n\n\tfi = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_file_extent_item);\n\tfound_type = btrfs_file_extent_type(leaf, fi);\n\tif (ram_bytes)\n\t\t*ram_bytes = btrfs_file_extent_ram_bytes(leaf, fi);\n\n\tnocow_args.start = offset;\n\tnocow_args.end = offset + *len - 1;\n\tnocow_args.strict = strict;\n\tnocow_args.free_path = true;\n\n\tret = can_nocow_file_extent(path, &key, BTRFS_I(inode), &nocow_args);\n\t \n\tpath = NULL;\n\n\tif (ret != 1) {\n\t\t \n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tif (btrfs_extent_readonly(fs_info, nocow_args.disk_bytenr))\n\t\tgoto out;\n\n\tif (!(BTRFS_I(inode)->flags & BTRFS_INODE_NODATACOW) &&\n\t    found_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tu64 range_end;\n\n\t\trange_end = round_up(offset + nocow_args.num_bytes,\n\t\t\t\t     root->fs_info->sectorsize) - 1;\n\t\tret = test_range_bit(io_tree, offset, range_end,\n\t\t\t\t     EXTENT_DELALLOC, 0, NULL);\n\t\tif (ret) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (orig_start)\n\t\t*orig_start = key.offset - nocow_args.extent_offset;\n\tif (orig_block_len)\n\t\t*orig_block_len = nocow_args.disk_num_bytes;\n\n\t*len = nocow_args.num_bytes;\n\tret = 1;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int lock_extent_direct(struct inode *inode, u64 lockstart, u64 lockend,\n\t\t\t      struct extent_state **cached_state,\n\t\t\t      unsigned int iomap_flags)\n{\n\tconst bool writing = (iomap_flags & IOMAP_WRITE);\n\tconst bool nowait = (iomap_flags & IOMAP_NOWAIT);\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_ordered_extent *ordered;\n\tint ret = 0;\n\n\twhile (1) {\n\t\tif (nowait) {\n\t\t\tif (!try_lock_extent(io_tree, lockstart, lockend,\n\t\t\t\t\t     cached_state))\n\t\t\t\treturn -EAGAIN;\n\t\t} else {\n\t\t\tlock_extent(io_tree, lockstart, lockend, cached_state);\n\t\t}\n\t\t \n\t\tordered = btrfs_lookup_ordered_range(BTRFS_I(inode), lockstart,\n\t\t\t\t\t\t     lockend - lockstart + 1);\n\n\t\t \n\t\tif (!ordered &&\n\t\t    (!writing || !filemap_range_has_page(inode->i_mapping,\n\t\t\t\t\t\t\t lockstart, lockend)))\n\t\t\tbreak;\n\n\t\tunlock_extent(io_tree, lockstart, lockend, cached_state);\n\n\t\tif (ordered) {\n\t\t\tif (nowait) {\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (writing ||\n\t\t\t    test_bit(BTRFS_ORDERED_DIRECT, &ordered->flags))\n\t\t\t\tbtrfs_start_ordered_extent(ordered);\n\t\t\telse\n\t\t\t\tret = nowait ? -EAGAIN : -ENOTBLK;\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t} else {\n\t\t\t \n\t\t\tret = nowait ? -EAGAIN : -ENOTBLK;\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\n\treturn ret;\n}\n\n \nstatic struct extent_map *create_io_em(struct btrfs_inode *inode, u64 start,\n\t\t\t\t       u64 len, u64 orig_start, u64 block_start,\n\t\t\t\t       u64 block_len, u64 orig_block_len,\n\t\t\t\t       u64 ram_bytes, int compress_type,\n\t\t\t\t       int type)\n{\n\tstruct extent_map *em;\n\tint ret;\n\n\tASSERT(type == BTRFS_ORDERED_PREALLOC ||\n\t       type == BTRFS_ORDERED_COMPRESSED ||\n\t       type == BTRFS_ORDERED_NOCOW ||\n\t       type == BTRFS_ORDERED_REGULAR);\n\n\tem = alloc_extent_map();\n\tif (!em)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tem->start = start;\n\tem->orig_start = orig_start;\n\tem->len = len;\n\tem->block_len = block_len;\n\tem->block_start = block_start;\n\tem->orig_block_len = orig_block_len;\n\tem->ram_bytes = ram_bytes;\n\tem->generation = -1;\n\tset_bit(EXTENT_FLAG_PINNED, &em->flags);\n\tif (type == BTRFS_ORDERED_PREALLOC) {\n\t\tset_bit(EXTENT_FLAG_FILLING, &em->flags);\n\t} else if (type == BTRFS_ORDERED_COMPRESSED) {\n\t\tset_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tem->compress_type = compress_type;\n\t}\n\n\tret = btrfs_replace_extent_map_range(inode, em, true);\n\tif (ret) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\treturn em;\n}\n\n\nstatic int btrfs_get_blocks_direct_write(struct extent_map **map,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t struct btrfs_dio_data *dio_data,\n\t\t\t\t\t u64 start, u64 *lenp,\n\t\t\t\t\t unsigned int iomap_flags)\n{\n\tconst bool nowait = (iomap_flags & IOMAP_NOWAIT);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct extent_map *em = *map;\n\tint type;\n\tu64 block_start, orig_start, orig_block_len, ram_bytes;\n\tstruct btrfs_block_group *bg;\n\tbool can_nocow = false;\n\tbool space_reserved = false;\n\tu64 len = *lenp;\n\tu64 prev_len;\n\tint ret = 0;\n\n\t \n\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags) ||\n\t    ((BTRFS_I(inode)->flags & BTRFS_INODE_NODATACOW) &&\n\t     em->block_start != EXTENT_MAP_HOLE)) {\n\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\ttype = BTRFS_ORDERED_PREALLOC;\n\t\telse\n\t\t\ttype = BTRFS_ORDERED_NOCOW;\n\t\tlen = min(len, em->len - (start - em->start));\n\t\tblock_start = em->block_start + (start - em->start);\n\n\t\tif (can_nocow_extent(inode, start, &len, &orig_start,\n\t\t\t\t     &orig_block_len, &ram_bytes, false, false) == 1) {\n\t\t\tbg = btrfs_inc_nocow_writers(fs_info, block_start);\n\t\t\tif (bg)\n\t\t\t\tcan_nocow = true;\n\t\t}\n\t}\n\n\tprev_len = len;\n\tif (can_nocow) {\n\t\tstruct extent_map *em2;\n\n\t\t \n\t\tret = btrfs_delalloc_reserve_metadata(BTRFS_I(inode), len, len,\n\t\t\t\t\t\t      nowait);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tfree_extent_map(em);\n\t\t\t*map = NULL;\n\t\t\tbtrfs_dec_nocow_writers(bg);\n\t\t\tif (nowait && (ret == -ENOSPC || ret == -EDQUOT))\n\t\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tspace_reserved = true;\n\n\t\tem2 = btrfs_create_dio_extent(BTRFS_I(inode), dio_data, start, len,\n\t\t\t\t\t      orig_start, block_start,\n\t\t\t\t\t      len, orig_block_len,\n\t\t\t\t\t      ram_bytes, type);\n\t\tbtrfs_dec_nocow_writers(bg);\n\t\tif (type == BTRFS_ORDERED_PREALLOC) {\n\t\t\tfree_extent_map(em);\n\t\t\t*map = em2;\n\t\t\tem = em2;\n\t\t}\n\n\t\tif (IS_ERR(em2)) {\n\t\t\tret = PTR_ERR(em2);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdio_data->nocow_done = true;\n\t} else {\n\t\t \n\t\tfree_extent_map(em);\n\t\t*map = NULL;\n\n\t\tif (nowait) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (!dio_data->data_space_reserved) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret = btrfs_delalloc_reserve_metadata(BTRFS_I(inode), len, len,\n\t\t\t\t\t\t      false);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tspace_reserved = true;\n\n\t\tem = btrfs_new_extent_direct(BTRFS_I(inode), dio_data, start, len);\n\t\tif (IS_ERR(em)) {\n\t\t\tret = PTR_ERR(em);\n\t\t\tgoto out;\n\t\t}\n\t\t*map = em;\n\t\tlen = min(len, em->len - (start - em->start));\n\t\tif (len < prev_len)\n\t\t\tbtrfs_delalloc_release_metadata(BTRFS_I(inode),\n\t\t\t\t\t\t\tprev_len - len, true);\n\t}\n\n\t \n\tbtrfs_delalloc_release_extents(BTRFS_I(inode), prev_len);\n\n\t \n\tif (start + len > i_size_read(inode))\n\t\ti_size_write(inode, start + len);\nout:\n\tif (ret && space_reserved) {\n\t\tbtrfs_delalloc_release_extents(BTRFS_I(inode), len);\n\t\tbtrfs_delalloc_release_metadata(BTRFS_I(inode), len, true);\n\t}\n\t*lenp = len;\n\treturn ret;\n}\n\nstatic int btrfs_dio_iomap_begin(struct inode *inode, loff_t start,\n\t\tloff_t length, unsigned int flags, struct iomap *iomap,\n\t\tstruct iomap *srcmap)\n{\n\tstruct iomap_iter *iter = container_of(iomap, struct iomap_iter, iomap);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct extent_map *em;\n\tstruct extent_state *cached_state = NULL;\n\tstruct btrfs_dio_data *dio_data = iter->private;\n\tu64 lockstart, lockend;\n\tconst bool write = !!(flags & IOMAP_WRITE);\n\tint ret = 0;\n\tu64 len = length;\n\tconst u64 data_alloc_len = length;\n\tbool unlock_extents = false;\n\n\t \n\tif (!write && (flags & IOMAP_NOWAIT) && length > PAGE_SIZE)\n\t\treturn -EAGAIN;\n\n\t \n\tif (!write)\n\t\tlen = min_t(u64, len, fs_info->sectorsize * BTRFS_MAX_BIO_SECTORS);\n\n\tlockstart = start;\n\tlockend = start + len - 1;\n\n\t \n\tif (test_bit(BTRFS_INODE_HAS_ASYNC_EXTENT,\n\t\t     &BTRFS_I(inode)->runtime_flags)) {\n\t\tif (flags & IOMAP_NOWAIT) {\n\t\t\tif (filemap_range_needs_writeback(inode->i_mapping,\n\t\t\t\t\t\t\t  lockstart, lockend))\n\t\t\t\treturn -EAGAIN;\n\t\t} else {\n\t\t\tret = filemap_fdatawrite_range(inode->i_mapping, start,\n\t\t\t\t\t\t       start + length - 1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmemset(dio_data, 0, sizeof(*dio_data));\n\n\t \n\tif (write && !(flags & IOMAP_NOWAIT)) {\n\t\tret = btrfs_check_data_free_space(BTRFS_I(inode),\n\t\t\t\t\t\t  &dio_data->data_reserved,\n\t\t\t\t\t\t  start, data_alloc_len, false);\n\t\tif (!ret)\n\t\t\tdio_data->data_space_reserved = true;\n\t\telse if (ret && !(BTRFS_I(inode)->flags &\n\t\t\t\t  (BTRFS_INODE_NODATACOW | BTRFS_INODE_PREALLOC)))\n\t\t\tgoto err;\n\t}\n\n\t \n\tret = lock_extent_direct(inode, lockstart, lockend, &cached_state, flags);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, start, len);\n\tif (IS_ERR(em)) {\n\t\tret = PTR_ERR(em);\n\t\tgoto unlock_err;\n\t}\n\n\t \n\tif (test_bit(EXTENT_FLAG_COMPRESSED, &em->flags) ||\n\t    em->block_start == EXTENT_MAP_INLINE) {\n\t\tfree_extent_map(em);\n\t\t \n\t\tret = (flags & IOMAP_NOWAIT) ? -EAGAIN : -ENOTBLK;\n\t\tgoto unlock_err;\n\t}\n\n\tlen = min(len, em->len - (start - em->start));\n\n\t \n\tif ((flags & IOMAP_NOWAIT) && len < length) {\n\t\tfree_extent_map(em);\n\t\tret = -EAGAIN;\n\t\tgoto unlock_err;\n\t}\n\n\tif (write) {\n\t\tret = btrfs_get_blocks_direct_write(&em, inode, dio_data,\n\t\t\t\t\t\t    start, &len, flags);\n\t\tif (ret < 0)\n\t\t\tgoto unlock_err;\n\t\tunlock_extents = true;\n\t\t \n\t\tlen = min(len, em->len - (start - em->start));\n\t\tif (dio_data->data_space_reserved) {\n\t\t\tu64 release_offset;\n\t\t\tu64 release_len = 0;\n\n\t\t\tif (dio_data->nocow_done) {\n\t\t\t\trelease_offset = start;\n\t\t\t\trelease_len = data_alloc_len;\n\t\t\t} else if (len < data_alloc_len) {\n\t\t\t\trelease_offset = start + len;\n\t\t\t\trelease_len = data_alloc_len - len;\n\t\t\t}\n\n\t\t\tif (release_len > 0)\n\t\t\t\tbtrfs_free_reserved_data_space(BTRFS_I(inode),\n\t\t\t\t\t\t\t       dio_data->data_reserved,\n\t\t\t\t\t\t\t       release_offset,\n\t\t\t\t\t\t\t       release_len);\n\t\t}\n\t} else {\n\t\t \n\t\tlockstart = start + len;\n\t\tif (lockstart < lockend)\n\t\t\tunlock_extents = true;\n\t}\n\n\tif (unlock_extents)\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t\t      &cached_state);\n\telse\n\t\tfree_extent_state(cached_state);\n\n\t \n\tif ((em->block_start == EXTENT_MAP_HOLE) ||\n\t    (test_bit(EXTENT_FLAG_PREALLOC, &em->flags) && !write)) {\n\t\tiomap->addr = IOMAP_NULL_ADDR;\n\t\tiomap->type = IOMAP_HOLE;\n\t} else {\n\t\tiomap->addr = em->block_start + (start - em->start);\n\t\tiomap->type = IOMAP_MAPPED;\n\t}\n\tiomap->offset = start;\n\tiomap->bdev = fs_info->fs_devices->latest_dev->bdev;\n\tiomap->length = len;\n\tfree_extent_map(em);\n\n\treturn 0;\n\nunlock_err:\n\tunlock_extent(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t      &cached_state);\nerr:\n\tif (dio_data->data_space_reserved) {\n\t\tbtrfs_free_reserved_data_space(BTRFS_I(inode),\n\t\t\t\t\t       dio_data->data_reserved,\n\t\t\t\t\t       start, data_alloc_len);\n\t\textent_changeset_free(dio_data->data_reserved);\n\t}\n\n\treturn ret;\n}\n\nstatic int btrfs_dio_iomap_end(struct inode *inode, loff_t pos, loff_t length,\n\t\tssize_t written, unsigned int flags, struct iomap *iomap)\n{\n\tstruct iomap_iter *iter = container_of(iomap, struct iomap_iter, iomap);\n\tstruct btrfs_dio_data *dio_data = iter->private;\n\tsize_t submitted = dio_data->submitted;\n\tconst bool write = !!(flags & IOMAP_WRITE);\n\tint ret = 0;\n\n\tif (!write && (iomap->type == IOMAP_HOLE)) {\n\t\t \n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, pos, pos + length - 1,\n\t\t\t      NULL);\n\t\treturn 0;\n\t}\n\n\tif (submitted < length) {\n\t\tpos += submitted;\n\t\tlength -= submitted;\n\t\tif (write)\n\t\t\tbtrfs_finish_ordered_extent(dio_data->ordered, NULL,\n\t\t\t\t\t\t    pos, length, false);\n\t\telse\n\t\t\tunlock_extent(&BTRFS_I(inode)->io_tree, pos,\n\t\t\t\t      pos + length - 1, NULL);\n\t\tret = -ENOTBLK;\n\t}\n\tif (write) {\n\t\tbtrfs_put_ordered_extent(dio_data->ordered);\n\t\tdio_data->ordered = NULL;\n\t}\n\n\tif (write)\n\t\textent_changeset_free(dio_data->data_reserved);\n\treturn ret;\n}\n\nstatic void btrfs_dio_end_io(struct btrfs_bio *bbio)\n{\n\tstruct btrfs_dio_private *dip =\n\t\tcontainer_of(bbio, struct btrfs_dio_private, bbio);\n\tstruct btrfs_inode *inode = bbio->inode;\n\tstruct bio *bio = &bbio->bio;\n\n\tif (bio->bi_status) {\n\t\tbtrfs_warn(inode->root->fs_info,\n\t\t\"direct IO failed ino %llu op 0x%0x offset %#llx len %u err no %d\",\n\t\t\t   btrfs_ino(inode), bio->bi_opf,\n\t\t\t   dip->file_offset, dip->bytes, bio->bi_status);\n\t}\n\n\tif (btrfs_op(bio) == BTRFS_MAP_WRITE) {\n\t\tbtrfs_finish_ordered_extent(bbio->ordered, NULL,\n\t\t\t\t\t    dip->file_offset, dip->bytes,\n\t\t\t\t\t    !bio->bi_status);\n\t} else {\n\t\tunlock_extent(&inode->io_tree, dip->file_offset,\n\t\t\t      dip->file_offset + dip->bytes - 1, NULL);\n\t}\n\n\tbbio->bio.bi_private = bbio->private;\n\tiomap_dio_bio_end_io(bio);\n}\n\nstatic void btrfs_dio_submit_io(const struct iomap_iter *iter, struct bio *bio,\n\t\t\t\tloff_t file_offset)\n{\n\tstruct btrfs_bio *bbio = btrfs_bio(bio);\n\tstruct btrfs_dio_private *dip =\n\t\tcontainer_of(bbio, struct btrfs_dio_private, bbio);\n\tstruct btrfs_dio_data *dio_data = iter->private;\n\n\tbtrfs_bio_init(bbio, BTRFS_I(iter->inode)->root->fs_info,\n\t\t       btrfs_dio_end_io, bio->bi_private);\n\tbbio->inode = BTRFS_I(iter->inode);\n\tbbio->file_offset = file_offset;\n\n\tdip->file_offset = file_offset;\n\tdip->bytes = bio->bi_iter.bi_size;\n\n\tdio_data->submitted += bio->bi_iter.bi_size;\n\n\t \n\tif (iter->flags & IOMAP_WRITE) {\n\t\tint ret;\n\n\t\tret = btrfs_extract_ordered_extent(bbio, dio_data->ordered);\n\t\tif (ret) {\n\t\t\tbtrfs_finish_ordered_extent(dio_data->ordered, NULL,\n\t\t\t\t\t\t    file_offset, dip->bytes,\n\t\t\t\t\t\t    !ret);\n\t\t\tbio->bi_status = errno_to_blk_status(ret);\n\t\t\tiomap_dio_bio_end_io(bio);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbtrfs_submit_bio(bbio, 0);\n}\n\nstatic const struct iomap_ops btrfs_dio_iomap_ops = {\n\t.iomap_begin            = btrfs_dio_iomap_begin,\n\t.iomap_end              = btrfs_dio_iomap_end,\n};\n\nstatic const struct iomap_dio_ops btrfs_dio_ops = {\n\t.submit_io\t\t= btrfs_dio_submit_io,\n\t.bio_set\t\t= &btrfs_dio_bioset,\n};\n\nssize_t btrfs_dio_read(struct kiocb *iocb, struct iov_iter *iter, size_t done_before)\n{\n\tstruct btrfs_dio_data data = { 0 };\n\n\treturn iomap_dio_rw(iocb, iter, &btrfs_dio_iomap_ops, &btrfs_dio_ops,\n\t\t\t    IOMAP_DIO_PARTIAL, &data, done_before);\n}\n\nstruct iomap_dio *btrfs_dio_write(struct kiocb *iocb, struct iov_iter *iter,\n\t\t\t\t  size_t done_before)\n{\n\tstruct btrfs_dio_data data = { 0 };\n\n\treturn __iomap_dio_rw(iocb, iter, &btrfs_dio_iomap_ops, &btrfs_dio_ops,\n\t\t\t    IOMAP_DIO_PARTIAL, &data, done_before);\n}\n\nstatic int btrfs_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t\tu64 start, u64 len)\n{\n\tint\tret;\n\n\tret = fiemap_prep(inode, fieinfo, start, &len, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (fieinfo->fi_flags & FIEMAP_FLAG_SYNC) {\n\t\tret = btrfs_wait_ordered_range(inode, 0, LLONG_MAX);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn extent_fiemap(BTRFS_I(inode), fieinfo, start, len);\n}\n\nstatic int btrfs_writepages(struct address_space *mapping,\n\t\t\t    struct writeback_control *wbc)\n{\n\treturn extent_writepages(mapping, wbc);\n}\n\nstatic void btrfs_readahead(struct readahead_control *rac)\n{\n\textent_readahead(rac);\n}\n\n \nstatic void wait_subpage_spinlock(struct page *page)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(page->mapping->host->i_sb);\n\tstruct btrfs_subpage *subpage;\n\n\tif (!btrfs_is_subpage(fs_info, page))\n\t\treturn;\n\n\tASSERT(PagePrivate(page) && page->private);\n\tsubpage = (struct btrfs_subpage *)page->private;\n\n\t \n\tspin_lock_irq(&subpage->lock);\n\tspin_unlock_irq(&subpage->lock);\n}\n\nstatic bool __btrfs_release_folio(struct folio *folio, gfp_t gfp_flags)\n{\n\tint ret = try_release_extent_mapping(&folio->page, gfp_flags);\n\n\tif (ret == 1) {\n\t\twait_subpage_spinlock(&folio->page);\n\t\tclear_page_extent_mapped(&folio->page);\n\t}\n\treturn ret;\n}\n\nstatic bool btrfs_release_folio(struct folio *folio, gfp_t gfp_flags)\n{\n\tif (folio_test_writeback(folio) || folio_test_dirty(folio))\n\t\treturn false;\n\treturn __btrfs_release_folio(folio, gfp_flags);\n}\n\n#ifdef CONFIG_MIGRATION\nstatic int btrfs_migrate_folio(struct address_space *mapping,\n\t\t\t     struct folio *dst, struct folio *src,\n\t\t\t     enum migrate_mode mode)\n{\n\tint ret = filemap_migrate_folio(mapping, dst, src, mode);\n\n\tif (ret != MIGRATEPAGE_SUCCESS)\n\t\treturn ret;\n\n\tif (folio_test_ordered(src)) {\n\t\tfolio_clear_ordered(src);\n\t\tfolio_set_ordered(dst);\n\t}\n\n\treturn MIGRATEPAGE_SUCCESS;\n}\n#else\n#define btrfs_migrate_folio NULL\n#endif\n\nstatic void btrfs_invalidate_folio(struct folio *folio, size_t offset,\n\t\t\t\t size_t length)\n{\n\tstruct btrfs_inode *inode = BTRFS_I(folio->mapping->host);\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tstruct extent_io_tree *tree = &inode->io_tree;\n\tstruct extent_state *cached_state = NULL;\n\tu64 page_start = folio_pos(folio);\n\tu64 page_end = page_start + folio_size(folio) - 1;\n\tu64 cur;\n\tint inode_evicting = inode->vfs_inode.i_state & I_FREEING;\n\n\t \n\tfolio_wait_writeback(folio);\n\twait_subpage_spinlock(&folio->page);\n\n\t \n\tif (!(offset == 0 && length == folio_size(folio))) {\n\t\tbtrfs_release_folio(folio, GFP_NOFS);\n\t\treturn;\n\t}\n\n\tif (!inode_evicting)\n\t\tlock_extent(tree, page_start, page_end, &cached_state);\n\n\tcur = page_start;\n\twhile (cur < page_end) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tu64 range_end;\n\t\tu32 range_len;\n\t\tu32 extra_flags = 0;\n\n\t\tordered = btrfs_lookup_first_ordered_range(inode, cur,\n\t\t\t\t\t\t\t   page_end + 1 - cur);\n\t\tif (!ordered) {\n\t\t\trange_end = page_end;\n\t\t\t \n\t\t\textra_flags = EXTENT_CLEAR_ALL_BITS;\n\t\t\tgoto next;\n\t\t}\n\t\tif (ordered->file_offset > cur) {\n\t\t\t \n\t\t\trange_end = ordered->file_offset - 1;\n\t\t\textra_flags = EXTENT_CLEAR_ALL_BITS;\n\t\t\tgoto next;\n\t\t}\n\n\t\trange_end = min(ordered->file_offset + ordered->num_bytes - 1,\n\t\t\t\tpage_end);\n\t\tASSERT(range_end + 1 - cur < U32_MAX);\n\t\trange_len = range_end + 1 - cur;\n\t\tif (!btrfs_page_test_ordered(fs_info, &folio->page, cur, range_len)) {\n\t\t\t \n\t\t\tgoto next;\n\t\t}\n\t\tbtrfs_page_clear_ordered(fs_info, &folio->page, cur, range_len);\n\n\t\t \n\t\tif (!inode_evicting)\n\t\t\tclear_extent_bit(tree, cur, range_end,\n\t\t\t\t\t EXTENT_DELALLOC |\n\t\t\t\t\t EXTENT_LOCKED | EXTENT_DO_ACCOUNTING |\n\t\t\t\t\t EXTENT_DEFRAG, &cached_state);\n\n\t\tspin_lock_irq(&inode->ordered_tree.lock);\n\t\tset_bit(BTRFS_ORDERED_TRUNCATED, &ordered->flags);\n\t\tordered->truncated_len = min(ordered->truncated_len,\n\t\t\t\t\t     cur - ordered->file_offset);\n\t\tspin_unlock_irq(&inode->ordered_tree.lock);\n\n\t\t \n\t\tif (btrfs_dec_test_ordered_pending(inode, &ordered,\n\t\t\t\t\t\t   cur, range_end + 1 - cur)) {\n\t\t\tbtrfs_finish_ordered_io(ordered);\n\t\t\t \n\t\t\textra_flags = EXTENT_CLEAR_ALL_BITS;\n\t\t}\nnext:\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t \n\t\tbtrfs_qgroup_free_data(inode, NULL, cur, range_end + 1 - cur, NULL);\n\t\tif (!inode_evicting) {\n\t\t\tclear_extent_bit(tree, cur, range_end, EXTENT_LOCKED |\n\t\t\t\t EXTENT_DELALLOC | EXTENT_UPTODATE |\n\t\t\t\t EXTENT_DO_ACCOUNTING | EXTENT_DEFRAG |\n\t\t\t\t extra_flags, &cached_state);\n\t\t}\n\t\tcur = range_end + 1;\n\t}\n\t \n\tASSERT(!folio_test_ordered(folio));\n\tbtrfs_page_clear_checked(fs_info, &folio->page, folio_pos(folio), folio_size(folio));\n\tif (!inode_evicting)\n\t\t__btrfs_release_folio(folio, GFP_NOFS);\n\tclear_page_extent_mapped(&folio->page);\n}\n\n \nvm_fault_t btrfs_page_mkwrite(struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_changeset *data_reserved = NULL;\n\tunsigned long zero_start;\n\tloff_t size;\n\tvm_fault_t ret;\n\tint ret2;\n\tint reserved = 0;\n\tu64 reserved_space;\n\tu64 page_start;\n\tu64 page_end;\n\tu64 end;\n\n\treserved_space = PAGE_SIZE;\n\n\tsb_start_pagefault(inode->i_sb);\n\tpage_start = page_offset(page);\n\tpage_end = page_start + PAGE_SIZE - 1;\n\tend = page_end;\n\n\t \n\tret2 = btrfs_delalloc_reserve_space(BTRFS_I(inode), &data_reserved,\n\t\t\t\t\t    page_start, reserved_space);\n\tif (!ret2) {\n\t\tret2 = file_update_time(vmf->vma->vm_file);\n\t\treserved = 1;\n\t}\n\tif (ret2) {\n\t\tret = vmf_error(ret2);\n\t\tif (reserved)\n\t\t\tgoto out;\n\t\tgoto out_noreserve;\n\t}\n\n\tret = VM_FAULT_NOPAGE;  \nagain:\n\tdown_read(&BTRFS_I(inode)->i_mmap_lock);\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\n\tif ((page->mapping != inode->i_mapping) ||\n\t    (page_start >= size)) {\n\t\t \n\t\tgoto out_unlock;\n\t}\n\twait_on_page_writeback(page);\n\n\tlock_extent(io_tree, page_start, page_end, &cached_state);\n\tret2 = set_page_extent_mapped(page);\n\tif (ret2 < 0) {\n\t\tret = vmf_error(ret2);\n\t\tunlock_extent(io_tree, page_start, page_end, &cached_state);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tordered = btrfs_lookup_ordered_range(BTRFS_I(inode), page_start,\n\t\t\tPAGE_SIZE);\n\tif (ordered) {\n\t\tunlock_extent(io_tree, page_start, page_end, &cached_state);\n\t\tunlock_page(page);\n\t\tup_read(&BTRFS_I(inode)->i_mmap_lock);\n\t\tbtrfs_start_ordered_extent(ordered);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tgoto again;\n\t}\n\n\tif (page->index == ((size - 1) >> PAGE_SHIFT)) {\n\t\treserved_space = round_up(size - page_start,\n\t\t\t\t\t  fs_info->sectorsize);\n\t\tif (reserved_space < PAGE_SIZE) {\n\t\t\tend = page_start + reserved_space - 1;\n\t\t\tbtrfs_delalloc_release_space(BTRFS_I(inode),\n\t\t\t\t\tdata_reserved, page_start,\n\t\t\t\t\tPAGE_SIZE - reserved_space, true);\n\t\t}\n\t}\n\n\t \n\tclear_extent_bit(&BTRFS_I(inode)->io_tree, page_start, end,\n\t\t\t  EXTENT_DELALLOC | EXTENT_DO_ACCOUNTING |\n\t\t\t  EXTENT_DEFRAG, &cached_state);\n\n\tret2 = btrfs_set_extent_delalloc(BTRFS_I(inode), page_start, end, 0,\n\t\t\t\t\t&cached_state);\n\tif (ret2) {\n\t\tunlock_extent(io_tree, page_start, page_end, &cached_state);\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (page_start + PAGE_SIZE > size)\n\t\tzero_start = offset_in_page(size);\n\telse\n\t\tzero_start = PAGE_SIZE;\n\n\tif (zero_start != PAGE_SIZE)\n\t\tmemzero_page(page, zero_start, PAGE_SIZE - zero_start);\n\n\tbtrfs_page_clear_checked(fs_info, page, page_start, PAGE_SIZE);\n\tbtrfs_page_set_dirty(fs_info, page, page_start, end + 1 - page_start);\n\tbtrfs_page_set_uptodate(fs_info, page, page_start, end + 1 - page_start);\n\n\tbtrfs_set_inode_last_sub_trans(BTRFS_I(inode));\n\n\tunlock_extent(io_tree, page_start, page_end, &cached_state);\n\tup_read(&BTRFS_I(inode)->i_mmap_lock);\n\n\tbtrfs_delalloc_release_extents(BTRFS_I(inode), PAGE_SIZE);\n\tsb_end_pagefault(inode->i_sb);\n\textent_changeset_free(data_reserved);\n\treturn VM_FAULT_LOCKED;\n\nout_unlock:\n\tunlock_page(page);\n\tup_read(&BTRFS_I(inode)->i_mmap_lock);\nout:\n\tbtrfs_delalloc_release_extents(BTRFS_I(inode), PAGE_SIZE);\n\tbtrfs_delalloc_release_space(BTRFS_I(inode), data_reserved, page_start,\n\t\t\t\t     reserved_space, (ret != 0));\nout_noreserve:\n\tsb_end_pagefault(inode->i_sb);\n\textent_changeset_free(data_reserved);\n\treturn ret;\n}\n\nstatic int btrfs_truncate(struct btrfs_inode *inode, bool skip_writeback)\n{\n\tstruct btrfs_truncate_control control = {\n\t\t.inode = inode,\n\t\t.ino = btrfs_ino(inode),\n\t\t.min_type = BTRFS_EXTENT_DATA_KEY,\n\t\t.clear_extent_range = true,\n\t};\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_block_rsv *rsv;\n\tint ret;\n\tstruct btrfs_trans_handle *trans;\n\tu64 mask = fs_info->sectorsize - 1;\n\tconst u64 min_size = btrfs_calc_metadata_size(fs_info, 1);\n\n\tif (!skip_writeback) {\n\t\tret = btrfs_wait_ordered_range(&inode->vfs_inode,\n\t\t\t\t\t       inode->vfs_inode.i_size & (~mask),\n\t\t\t\t\t       (u64)-1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\trsv = btrfs_alloc_block_rsv(fs_info, BTRFS_BLOCK_RSV_TEMP);\n\tif (!rsv)\n\t\treturn -ENOMEM;\n\trsv->size = min_size;\n\trsv->failfast = true;\n\n\t \n\ttrans = btrfs_start_transaction(root, 2);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\t \n\tret = btrfs_block_rsv_migrate(&fs_info->trans_block_rsv, rsv,\n\t\t\t\t      min_size, false);\n\t \n\tif (WARN_ON(ret)) {\n\t\tbtrfs_end_transaction(trans);\n\t\tgoto out;\n\t}\n\n\ttrans->block_rsv = rsv;\n\n\twhile (1) {\n\t\tstruct extent_state *cached_state = NULL;\n\t\tconst u64 new_size = inode->vfs_inode.i_size;\n\t\tconst u64 lock_start = ALIGN_DOWN(new_size, fs_info->sectorsize);\n\n\t\tcontrol.new_size = new_size;\n\t\tlock_extent(&inode->io_tree, lock_start, (u64)-1, &cached_state);\n\t\t \n\t\tbtrfs_drop_extent_map_range(inode,\n\t\t\t\t\t    ALIGN(new_size, fs_info->sectorsize),\n\t\t\t\t\t    (u64)-1, false);\n\n\t\tret = btrfs_truncate_inode_items(trans, root, &control);\n\n\t\tinode_sub_bytes(&inode->vfs_inode, control.sub_bytes);\n\t\tbtrfs_inode_safe_disk_i_size_write(inode, control.last_size);\n\n\t\tunlock_extent(&inode->io_tree, lock_start, (u64)-1, &cached_state);\n\n\t\ttrans->block_rsv = &fs_info->trans_block_rsv;\n\t\tif (ret != -ENOSPC && ret != -EAGAIN)\n\t\t\tbreak;\n\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tbtrfs_end_transaction(trans);\n\t\tbtrfs_btree_balance_dirty(fs_info);\n\n\t\ttrans = btrfs_start_transaction(root, 2);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_block_rsv_release(fs_info, rsv, -1, NULL);\n\t\tret = btrfs_block_rsv_migrate(&fs_info->trans_block_rsv,\n\t\t\t\t\t      rsv, min_size, false);\n\t\t \n\t\tif (WARN_ON(ret))\n\t\t\tbreak;\n\n\t\ttrans->block_rsv = rsv;\n\t}\n\n\t \n\tif (ret == BTRFS_NEED_TRUNCATE_BLOCK) {\n\t\tbtrfs_end_transaction(trans);\n\t\tbtrfs_btree_balance_dirty(fs_info);\n\n\t\tret = btrfs_truncate_block(inode, inode->vfs_inode.i_size, 0, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\ttrans = btrfs_start_transaction(root, 1);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_inode_safe_disk_i_size_write(inode, 0);\n\t}\n\n\tif (trans) {\n\t\tint ret2;\n\n\t\ttrans->block_rsv = &fs_info->trans_block_rsv;\n\t\tret2 = btrfs_update_inode(trans, root, inode);\n\t\tif (ret2 && !ret)\n\t\t\tret = ret2;\n\n\t\tret2 = btrfs_end_transaction(trans);\n\t\tif (ret2 && !ret)\n\t\t\tret = ret2;\n\t\tbtrfs_btree_balance_dirty(fs_info);\n\t}\nout:\n\tbtrfs_free_block_rsv(fs_info, rsv);\n\t \n\tif (control.extents_found > 0)\n\t\tbtrfs_set_inode_full_sync(inode);\n\n\treturn ret;\n}\n\nstruct inode *btrfs_new_subvol_inode(struct mnt_idmap *idmap,\n\t\t\t\t     struct inode *dir)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(dir->i_sb);\n\tif (inode) {\n\t\t \n\t\tinode_init_owner(idmap, inode, NULL,\n\t\t\t\t S_IFDIR | (~current_umask() & S_IRWXUGO));\n\t\tinode->i_op = &btrfs_dir_inode_operations;\n\t\tinode->i_fop = &btrfs_dir_file_operations;\n\t}\n\treturn inode;\n}\n\nstruct inode *btrfs_alloc_inode(struct super_block *sb)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_inode *ei;\n\tstruct inode *inode;\n\n\tei = alloc_inode_sb(sb, btrfs_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\n\tei->root = NULL;\n\tei->generation = 0;\n\tei->last_trans = 0;\n\tei->last_sub_trans = 0;\n\tei->logged_trans = 0;\n\tei->delalloc_bytes = 0;\n\tei->new_delalloc_bytes = 0;\n\tei->defrag_bytes = 0;\n\tei->disk_i_size = 0;\n\tei->flags = 0;\n\tei->ro_flags = 0;\n\tei->csum_bytes = 0;\n\tei->index_cnt = (u64)-1;\n\tei->dir_index = 0;\n\tei->last_unlink_trans = 0;\n\tei->last_reflink_trans = 0;\n\tei->last_log_commit = 0;\n\n\tspin_lock_init(&ei->lock);\n\tei->outstanding_extents = 0;\n\tif (sb->s_magic != BTRFS_TEST_MAGIC)\n\t\tbtrfs_init_metadata_block_rsv(fs_info, &ei->block_rsv,\n\t\t\t\t\t      BTRFS_BLOCK_RSV_DELALLOC);\n\tei->runtime_flags = 0;\n\tei->prop_compress = BTRFS_COMPRESS_NONE;\n\tei->defrag_compress = BTRFS_COMPRESS_NONE;\n\n\tei->delayed_node = NULL;\n\n\tei->i_otime.tv_sec = 0;\n\tei->i_otime.tv_nsec = 0;\n\n\tinode = &ei->vfs_inode;\n\textent_map_tree_init(&ei->extent_tree);\n\textent_io_tree_init(fs_info, &ei->io_tree, IO_TREE_INODE_IO);\n\tei->io_tree.inode = ei;\n\textent_io_tree_init(fs_info, &ei->file_extent_tree,\n\t\t\t    IO_TREE_INODE_FILE_EXTENT);\n\tmutex_init(&ei->log_mutex);\n\tbtrfs_ordered_inode_tree_init(&ei->ordered_tree);\n\tINIT_LIST_HEAD(&ei->delalloc_inodes);\n\tINIT_LIST_HEAD(&ei->delayed_iput);\n\tRB_CLEAR_NODE(&ei->rb_node);\n\tinit_rwsem(&ei->i_mmap_lock);\n\n\treturn inode;\n}\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\nvoid btrfs_test_destroy_inode(struct inode *inode)\n{\n\tbtrfs_drop_extent_map_range(BTRFS_I(inode), 0, (u64)-1, false);\n\tkmem_cache_free(btrfs_inode_cachep, BTRFS_I(inode));\n}\n#endif\n\nvoid btrfs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(btrfs_inode_cachep, BTRFS_I(inode));\n}\n\nvoid btrfs_destroy_inode(struct inode *vfs_inode)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct btrfs_inode *inode = BTRFS_I(vfs_inode);\n\tstruct btrfs_root *root = inode->root;\n\tbool freespace_inode;\n\n\tWARN_ON(!hlist_empty(&vfs_inode->i_dentry));\n\tWARN_ON(vfs_inode->i_data.nrpages);\n\tWARN_ON(inode->block_rsv.reserved);\n\tWARN_ON(inode->block_rsv.size);\n\tWARN_ON(inode->outstanding_extents);\n\tif (!S_ISDIR(vfs_inode->i_mode)) {\n\t\tWARN_ON(inode->delalloc_bytes);\n\t\tWARN_ON(inode->new_delalloc_bytes);\n\t}\n\tWARN_ON(inode->csum_bytes);\n\tWARN_ON(inode->defrag_bytes);\n\n\t \n\tif (!root)\n\t\treturn;\n\n\t \n\tfreespace_inode = btrfs_is_free_space_inode(inode);\n\n\twhile (1) {\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, (u64)-1);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\telse {\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t  \"found ordered extent %llu %llu on inode cleanup\",\n\t\t\t\t  ordered->file_offset, ordered->num_bytes);\n\n\t\t\tif (!freespace_inode)\n\t\t\t\tbtrfs_lockdep_acquire(root->fs_info, btrfs_ordered_extent);\n\n\t\t\tbtrfs_remove_ordered_extent(inode, ordered);\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t}\n\t}\n\tbtrfs_qgroup_check_reserved_leak(inode);\n\tinode_tree_del(inode);\n\tbtrfs_drop_extent_map_range(inode, 0, (u64)-1, false);\n\tbtrfs_inode_clear_file_extent_range(inode, 0, (u64)-1);\n\tbtrfs_put_root(inode->root);\n}\n\nint btrfs_drop_inode(struct inode *inode)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\n\tif (root == NULL)\n\t\treturn 1;\n\n\t \n\tif (btrfs_root_refs(&root->root_item) == 0)\n\t\treturn 1;\n\telse\n\t\treturn generic_drop_inode(inode);\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct btrfs_inode *ei = foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nvoid __cold btrfs_destroy_cachep(void)\n{\n\t \n\trcu_barrier();\n\tbioset_exit(&btrfs_dio_bioset);\n\tkmem_cache_destroy(btrfs_inode_cachep);\n}\n\nint __init btrfs_init_cachep(void)\n{\n\tbtrfs_inode_cachep = kmem_cache_create(\"btrfs_inode\",\n\t\t\tsizeof(struct btrfs_inode), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD | SLAB_ACCOUNT,\n\t\t\tinit_once);\n\tif (!btrfs_inode_cachep)\n\t\tgoto fail;\n\n\tif (bioset_init(&btrfs_dio_bioset, BIO_POOL_SIZE,\n\t\t\toffsetof(struct btrfs_dio_private, bbio.bio),\n\t\t\tBIOSET_NEED_BVECS))\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tbtrfs_destroy_cachep();\n\treturn -ENOMEM;\n}\n\nstatic int btrfs_getattr(struct mnt_idmap *idmap,\n\t\t\t const struct path *path, struct kstat *stat,\n\t\t\t u32 request_mask, unsigned int flags)\n{\n\tu64 delalloc_bytes;\n\tu64 inode_bytes;\n\tstruct inode *inode = d_inode(path->dentry);\n\tu32 blocksize = inode->i_sb->s_blocksize;\n\tu32 bi_flags = BTRFS_I(inode)->flags;\n\tu32 bi_ro_flags = BTRFS_I(inode)->ro_flags;\n\n\tstat->result_mask |= STATX_BTIME;\n\tstat->btime.tv_sec = BTRFS_I(inode)->i_otime.tv_sec;\n\tstat->btime.tv_nsec = BTRFS_I(inode)->i_otime.tv_nsec;\n\tif (bi_flags & BTRFS_INODE_APPEND)\n\t\tstat->attributes |= STATX_ATTR_APPEND;\n\tif (bi_flags & BTRFS_INODE_COMPRESS)\n\t\tstat->attributes |= STATX_ATTR_COMPRESSED;\n\tif (bi_flags & BTRFS_INODE_IMMUTABLE)\n\t\tstat->attributes |= STATX_ATTR_IMMUTABLE;\n\tif (bi_flags & BTRFS_INODE_NODUMP)\n\t\tstat->attributes |= STATX_ATTR_NODUMP;\n\tif (bi_ro_flags & BTRFS_INODE_RO_VERITY)\n\t\tstat->attributes |= STATX_ATTR_VERITY;\n\n\tstat->attributes_mask |= (STATX_ATTR_APPEND |\n\t\t\t\t  STATX_ATTR_COMPRESSED |\n\t\t\t\t  STATX_ATTR_IMMUTABLE |\n\t\t\t\t  STATX_ATTR_NODUMP);\n\n\tgeneric_fillattr(idmap, request_mask, inode, stat);\n\tstat->dev = BTRFS_I(inode)->root->anon_dev;\n\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tdelalloc_bytes = BTRFS_I(inode)->new_delalloc_bytes;\n\tinode_bytes = inode_get_bytes(inode);\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\tstat->blocks = (ALIGN(inode_bytes, blocksize) +\n\t\t\tALIGN(delalloc_bytes, blocksize)) >> SECTOR_SHIFT;\n\treturn 0;\n}\n\nstatic int btrfs_rename_exchange(struct inode *old_dir,\n\t\t\t      struct dentry *old_dentry,\n\t\t\t      struct inode *new_dir,\n\t\t\t      struct dentry *new_dentry)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(old_dir->i_sb);\n\tstruct btrfs_trans_handle *trans;\n\tunsigned int trans_num_items;\n\tstruct btrfs_root *root = BTRFS_I(old_dir)->root;\n\tstruct btrfs_root *dest = BTRFS_I(new_dir)->root;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct btrfs_rename_ctx old_rename_ctx;\n\tstruct btrfs_rename_ctx new_rename_ctx;\n\tu64 old_ino = btrfs_ino(BTRFS_I(old_inode));\n\tu64 new_ino = btrfs_ino(BTRFS_I(new_inode));\n\tu64 old_idx = 0;\n\tu64 new_idx = 0;\n\tint ret;\n\tint ret2;\n\tbool need_abort = false;\n\tstruct fscrypt_name old_fname, new_fname;\n\tstruct fscrypt_str *old_name, *new_name;\n\n\t \n\tif (root != dest &&\n\t    (old_ino != BTRFS_FIRST_FREE_OBJECTID ||\n\t     new_ino != BTRFS_FIRST_FREE_OBJECTID))\n\t\treturn -EXDEV;\n\n\tret = fscrypt_setup_filename(old_dir, &old_dentry->d_name, 0, &old_fname);\n\tif (ret)\n\t\treturn ret;\n\n\tret = fscrypt_setup_filename(new_dir, &new_dentry->d_name, 0, &new_fname);\n\tif (ret) {\n\t\tfscrypt_free_filename(&old_fname);\n\t\treturn ret;\n\t}\n\n\told_name = &old_fname.disk_name;\n\tnew_name = &new_fname.disk_name;\n\n\t \n\tif (old_ino == BTRFS_FIRST_FREE_OBJECTID ||\n\t    new_ino == BTRFS_FIRST_FREE_OBJECTID)\n\t\tdown_read(&fs_info->subvol_sem);\n\n\t \n\ttrans_num_items = (old_dir == new_dir ? 9 : 10);\n\tif (old_ino == BTRFS_FIRST_FREE_OBJECTID) {\n\t\t \n\t\ttrans_num_items += 4;\n\t} else {\n\t\t \n\t\ttrans_num_items += 3;\n\t}\n\tif (new_ino == BTRFS_FIRST_FREE_OBJECTID)\n\t\ttrans_num_items += 4;\n\telse\n\t\ttrans_num_items += 3;\n\ttrans = btrfs_start_transaction(root, trans_num_items);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_notrans;\n\t}\n\n\tif (dest != root) {\n\t\tret = btrfs_record_root_in_trans(trans, dest);\n\t\tif (ret)\n\t\t\tgoto out_fail;\n\t}\n\n\t \n\tret = btrfs_set_inode_index(BTRFS_I(new_dir), &old_idx);\n\tif (ret)\n\t\tgoto out_fail;\n\tret = btrfs_set_inode_index(BTRFS_I(old_dir), &new_idx);\n\tif (ret)\n\t\tgoto out_fail;\n\n\tBTRFS_I(old_inode)->dir_index = 0ULL;\n\tBTRFS_I(new_inode)->dir_index = 0ULL;\n\n\t \n\tif (old_ino == BTRFS_FIRST_FREE_OBJECTID) {\n\t\t \n\t\tbtrfs_set_log_full_commit(trans);\n\t} else {\n\t\tret = btrfs_insert_inode_ref(trans, dest, new_name, old_ino,\n\t\t\t\t\t     btrfs_ino(BTRFS_I(new_dir)),\n\t\t\t\t\t     old_idx);\n\t\tif (ret)\n\t\t\tgoto out_fail;\n\t\tneed_abort = true;\n\t}\n\n\t \n\tif (new_ino == BTRFS_FIRST_FREE_OBJECTID) {\n\t\t \n\t\tbtrfs_set_log_full_commit(trans);\n\t} else {\n\t\tret = btrfs_insert_inode_ref(trans, root, old_name, new_ino,\n\t\t\t\t\t     btrfs_ino(BTRFS_I(old_dir)),\n\t\t\t\t\t     new_idx);\n\t\tif (ret) {\n\t\t\tif (need_abort)\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\t \n\tinode_inc_iversion(old_dir);\n\tinode_inc_iversion(new_dir);\n\tinode_inc_iversion(old_inode);\n\tinode_inc_iversion(new_inode);\n\tsimple_rename_timestamp(old_dir, old_dentry, new_dir, new_dentry);\n\n\tif (old_dentry->d_parent != new_dentry->d_parent) {\n\t\tbtrfs_record_unlink_dir(trans, BTRFS_I(old_dir),\n\t\t\t\t\tBTRFS_I(old_inode), true);\n\t\tbtrfs_record_unlink_dir(trans, BTRFS_I(new_dir),\n\t\t\t\t\tBTRFS_I(new_inode), true);\n\t}\n\n\t \n\tif (old_ino == BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_unlink_subvol(trans, BTRFS_I(old_dir), old_dentry);\n\t} else {  \n\t\tret = __btrfs_unlink_inode(trans, BTRFS_I(old_dir),\n\t\t\t\t\t   BTRFS_I(old_dentry->d_inode),\n\t\t\t\t\t   old_name, &old_rename_ctx);\n\t\tif (!ret)\n\t\t\tret = btrfs_update_inode(trans, root, BTRFS_I(old_inode));\n\t}\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out_fail;\n\t}\n\n\t \n\tif (new_ino == BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_unlink_subvol(trans, BTRFS_I(new_dir), new_dentry);\n\t} else {  \n\t\tret = __btrfs_unlink_inode(trans, BTRFS_I(new_dir),\n\t\t\t\t\t   BTRFS_I(new_dentry->d_inode),\n\t\t\t\t\t   new_name, &new_rename_ctx);\n\t\tif (!ret)\n\t\t\tret = btrfs_update_inode(trans, dest, BTRFS_I(new_inode));\n\t}\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out_fail;\n\t}\n\n\tret = btrfs_add_link(trans, BTRFS_I(new_dir), BTRFS_I(old_inode),\n\t\t\t     new_name, 0, old_idx);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out_fail;\n\t}\n\n\tret = btrfs_add_link(trans, BTRFS_I(old_dir), BTRFS_I(new_inode),\n\t\t\t     old_name, 0, new_idx);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out_fail;\n\t}\n\n\tif (old_inode->i_nlink == 1)\n\t\tBTRFS_I(old_inode)->dir_index = old_idx;\n\tif (new_inode->i_nlink == 1)\n\t\tBTRFS_I(new_inode)->dir_index = new_idx;\n\n\t \n\tif (old_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\tbtrfs_pin_log_trans(root);\n\tif (new_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\tbtrfs_pin_log_trans(dest);\n\n\t \n\tif (old_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\tbtrfs_log_new_name(trans, old_dentry, BTRFS_I(old_dir),\n\t\t\t\t   old_rename_ctx.index, new_dentry->d_parent);\n\tif (new_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\tbtrfs_log_new_name(trans, new_dentry, BTRFS_I(new_dir),\n\t\t\t\t   new_rename_ctx.index, old_dentry->d_parent);\n\n\t \n\tif (old_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\tbtrfs_end_log_trans(root);\n\tif (new_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\tbtrfs_end_log_trans(dest);\nout_fail:\n\tret2 = btrfs_end_transaction(trans);\n\tret = ret ? ret : ret2;\nout_notrans:\n\tif (new_ino == BTRFS_FIRST_FREE_OBJECTID ||\n\t    old_ino == BTRFS_FIRST_FREE_OBJECTID)\n\t\tup_read(&fs_info->subvol_sem);\n\n\tfscrypt_free_filename(&new_fname);\n\tfscrypt_free_filename(&old_fname);\n\treturn ret;\n}\n\nstatic struct inode *new_whiteout_inode(struct mnt_idmap *idmap,\n\t\t\t\t\tstruct inode *dir)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(dir->i_sb);\n\tif (inode) {\n\t\tinode_init_owner(idmap, inode, dir,\n\t\t\t\t S_IFCHR | WHITEOUT_MODE);\n\t\tinode->i_op = &btrfs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, WHITEOUT_DEV);\n\t}\n\treturn inode;\n}\n\nstatic int btrfs_rename(struct mnt_idmap *idmap,\n\t\t\tstruct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry,\n\t\t\tunsigned int flags)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(old_dir->i_sb);\n\tstruct btrfs_new_inode_args whiteout_args = {\n\t\t.dir = old_dir,\n\t\t.dentry = old_dentry,\n\t};\n\tstruct btrfs_trans_handle *trans;\n\tunsigned int trans_num_items;\n\tstruct btrfs_root *root = BTRFS_I(old_dir)->root;\n\tstruct btrfs_root *dest = BTRFS_I(new_dir)->root;\n\tstruct inode *new_inode = d_inode(new_dentry);\n\tstruct inode *old_inode = d_inode(old_dentry);\n\tstruct btrfs_rename_ctx rename_ctx;\n\tu64 index = 0;\n\tint ret;\n\tint ret2;\n\tu64 old_ino = btrfs_ino(BTRFS_I(old_inode));\n\tstruct fscrypt_name old_fname, new_fname;\n\n\tif (btrfs_ino(BTRFS_I(new_dir)) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID)\n\t\treturn -EPERM;\n\n\t \n\tif (old_ino != BTRFS_FIRST_FREE_OBJECTID && root != dest)\n\t\treturn -EXDEV;\n\n\tif (old_ino == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ||\n\t    (new_inode && btrfs_ino(BTRFS_I(new_inode)) == BTRFS_FIRST_FREE_OBJECTID))\n\t\treturn -ENOTEMPTY;\n\n\tif (S_ISDIR(old_inode->i_mode) && new_inode &&\n\t    new_inode->i_size > BTRFS_EMPTY_DIR_SIZE)\n\t\treturn -ENOTEMPTY;\n\n\tret = fscrypt_setup_filename(old_dir, &old_dentry->d_name, 0, &old_fname);\n\tif (ret)\n\t\treturn ret;\n\n\tret = fscrypt_setup_filename(new_dir, &new_dentry->d_name, 0, &new_fname);\n\tif (ret) {\n\t\tfscrypt_free_filename(&old_fname);\n\t\treturn ret;\n\t}\n\n\t \n\tret = btrfs_check_dir_item_collision(dest, new_dir->i_ino, &new_fname.disk_name);\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\t \n\t\t\tif (WARN_ON(!new_inode)) {\n\t\t\t\tgoto out_fscrypt_names;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tgoto out_fscrypt_names;\n\t\t}\n\t}\n\tret = 0;\n\n\t \n\tif (new_inode && S_ISREG(old_inode->i_mode) && new_inode->i_size)\n\t\tfilemap_flush(old_inode->i_mapping);\n\n\tif (flags & RENAME_WHITEOUT) {\n\t\twhiteout_args.inode = new_whiteout_inode(idmap, old_dir);\n\t\tif (!whiteout_args.inode) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_fscrypt_names;\n\t\t}\n\t\tret = btrfs_new_inode_prepare(&whiteout_args, &trans_num_items);\n\t\tif (ret)\n\t\t\tgoto out_whiteout_inode;\n\t} else {\n\t\t \n\t\ttrans_num_items = 1;\n\t}\n\n\tif (old_ino == BTRFS_FIRST_FREE_OBJECTID) {\n\t\t \n\t\tdown_read(&fs_info->subvol_sem);\n\t\t \n\t\ttrans_num_items += 4;\n\t} else {\n\t\t \n\t\ttrans_num_items += 3;\n\t}\n\t \n\ttrans_num_items += 4;\n\t \n\tif (new_dir != old_dir)\n\t\ttrans_num_items++;\n\tif (new_inode) {\n\t\t \n\t\ttrans_num_items += 5;\n\t}\n\ttrans = btrfs_start_transaction(root, trans_num_items);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_notrans;\n\t}\n\n\tif (dest != root) {\n\t\tret = btrfs_record_root_in_trans(trans, dest);\n\t\tif (ret)\n\t\t\tgoto out_fail;\n\t}\n\n\tret = btrfs_set_inode_index(BTRFS_I(new_dir), &index);\n\tif (ret)\n\t\tgoto out_fail;\n\n\tBTRFS_I(old_inode)->dir_index = 0ULL;\n\tif (unlikely(old_ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\t \n\t\tbtrfs_set_log_full_commit(trans);\n\t} else {\n\t\tret = btrfs_insert_inode_ref(trans, dest, &new_fname.disk_name,\n\t\t\t\t\t     old_ino, btrfs_ino(BTRFS_I(new_dir)),\n\t\t\t\t\t     index);\n\t\tif (ret)\n\t\t\tgoto out_fail;\n\t}\n\n\tinode_inc_iversion(old_dir);\n\tinode_inc_iversion(new_dir);\n\tinode_inc_iversion(old_inode);\n\tsimple_rename_timestamp(old_dir, old_dentry, new_dir, new_dentry);\n\n\tif (old_dentry->d_parent != new_dentry->d_parent)\n\t\tbtrfs_record_unlink_dir(trans, BTRFS_I(old_dir),\n\t\t\t\t\tBTRFS_I(old_inode), true);\n\n\tif (unlikely(old_ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_unlink_subvol(trans, BTRFS_I(old_dir), old_dentry);\n\t} else {\n\t\tret = __btrfs_unlink_inode(trans, BTRFS_I(old_dir),\n\t\t\t\t\t   BTRFS_I(d_inode(old_dentry)),\n\t\t\t\t\t   &old_fname.disk_name, &rename_ctx);\n\t\tif (!ret)\n\t\t\tret = btrfs_update_inode(trans, root, BTRFS_I(old_inode));\n\t}\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out_fail;\n\t}\n\n\tif (new_inode) {\n\t\tinode_inc_iversion(new_inode);\n\t\tif (unlikely(btrfs_ino(BTRFS_I(new_inode)) ==\n\t\t\t     BTRFS_EMPTY_SUBVOL_DIR_OBJECTID)) {\n\t\t\tret = btrfs_unlink_subvol(trans, BTRFS_I(new_dir), new_dentry);\n\t\t\tBUG_ON(new_inode->i_nlink == 0);\n\t\t} else {\n\t\t\tret = btrfs_unlink_inode(trans, BTRFS_I(new_dir),\n\t\t\t\t\t\t BTRFS_I(d_inode(new_dentry)),\n\t\t\t\t\t\t &new_fname.disk_name);\n\t\t}\n\t\tif (!ret && new_inode->i_nlink == 0)\n\t\t\tret = btrfs_orphan_add(trans,\n\t\t\t\t\tBTRFS_I(d_inode(new_dentry)));\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tret = btrfs_add_link(trans, BTRFS_I(new_dir), BTRFS_I(old_inode),\n\t\t\t     &new_fname.disk_name, 0, index);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out_fail;\n\t}\n\n\tif (old_inode->i_nlink == 1)\n\t\tBTRFS_I(old_inode)->dir_index = index;\n\n\tif (old_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\tbtrfs_log_new_name(trans, old_dentry, BTRFS_I(old_dir),\n\t\t\t\t   rename_ctx.index, new_dentry->d_parent);\n\n\tif (flags & RENAME_WHITEOUT) {\n\t\tret = btrfs_create_new_inode(trans, &whiteout_args);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out_fail;\n\t\t} else {\n\t\t\tunlock_new_inode(whiteout_args.inode);\n\t\t\tiput(whiteout_args.inode);\n\t\t\twhiteout_args.inode = NULL;\n\t\t}\n\t}\nout_fail:\n\tret2 = btrfs_end_transaction(trans);\n\tret = ret ? ret : ret2;\nout_notrans:\n\tif (old_ino == BTRFS_FIRST_FREE_OBJECTID)\n\t\tup_read(&fs_info->subvol_sem);\n\tif (flags & RENAME_WHITEOUT)\n\t\tbtrfs_new_inode_args_destroy(&whiteout_args);\nout_whiteout_inode:\n\tif (flags & RENAME_WHITEOUT)\n\t\tiput(whiteout_args.inode);\nout_fscrypt_names:\n\tfscrypt_free_filename(&old_fname);\n\tfscrypt_free_filename(&new_fname);\n\treturn ret;\n}\n\nstatic int btrfs_rename2(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\t\t struct dentry *old_dentry, struct inode *new_dir,\n\t\t\t struct dentry *new_dentry, unsigned int flags)\n{\n\tint ret;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\treturn -EINVAL;\n\n\tif (flags & RENAME_EXCHANGE)\n\t\tret = btrfs_rename_exchange(old_dir, old_dentry, new_dir,\n\t\t\t\t\t    new_dentry);\n\telse\n\t\tret = btrfs_rename(idmap, old_dir, old_dentry, new_dir,\n\t\t\t\t   new_dentry, flags);\n\n\tbtrfs_btree_balance_dirty(BTRFS_I(new_dir)->root->fs_info);\n\n\treturn ret;\n}\n\nstruct btrfs_delalloc_work {\n\tstruct inode *inode;\n\tstruct completion completion;\n\tstruct list_head list;\n\tstruct btrfs_work work;\n};\n\nstatic void btrfs_run_delalloc_work(struct btrfs_work *work)\n{\n\tstruct btrfs_delalloc_work *delalloc_work;\n\tstruct inode *inode;\n\n\tdelalloc_work = container_of(work, struct btrfs_delalloc_work,\n\t\t\t\t     work);\n\tinode = delalloc_work->inode;\n\tfilemap_flush(inode->i_mapping);\n\tif (test_bit(BTRFS_INODE_HAS_ASYNC_EXTENT,\n\t\t\t\t&BTRFS_I(inode)->runtime_flags))\n\t\tfilemap_flush(inode->i_mapping);\n\n\tiput(inode);\n\tcomplete(&delalloc_work->completion);\n}\n\nstatic struct btrfs_delalloc_work *btrfs_alloc_delalloc_work(struct inode *inode)\n{\n\tstruct btrfs_delalloc_work *work;\n\n\twork = kmalloc(sizeof(*work), GFP_NOFS);\n\tif (!work)\n\t\treturn NULL;\n\n\tinit_completion(&work->completion);\n\tINIT_LIST_HEAD(&work->list);\n\twork->inode = inode;\n\tbtrfs_init_work(&work->work, btrfs_run_delalloc_work, NULL, NULL);\n\n\treturn work;\n}\n\n \nstatic int start_delalloc_inodes(struct btrfs_root *root,\n\t\t\t\t struct writeback_control *wbc, bool snapshot,\n\t\t\t\t bool in_reclaim_context)\n{\n\tstruct btrfs_inode *binode;\n\tstruct inode *inode;\n\tstruct btrfs_delalloc_work *work, *next;\n\tLIST_HEAD(works);\n\tLIST_HEAD(splice);\n\tint ret = 0;\n\tbool full_flush = wbc->nr_to_write == LONG_MAX;\n\n\tmutex_lock(&root->delalloc_mutex);\n\tspin_lock(&root->delalloc_lock);\n\tlist_splice_init(&root->delalloc_inodes, &splice);\n\twhile (!list_empty(&splice)) {\n\t\tbinode = list_entry(splice.next, struct btrfs_inode,\n\t\t\t\t    delalloc_inodes);\n\n\t\tlist_move_tail(&binode->delalloc_inodes,\n\t\t\t       &root->delalloc_inodes);\n\n\t\tif (in_reclaim_context &&\n\t\t    test_bit(BTRFS_INODE_NO_DELALLOC_FLUSH, &binode->runtime_flags))\n\t\t\tcontinue;\n\n\t\tinode = igrab(&binode->vfs_inode);\n\t\tif (!inode) {\n\t\t\tcond_resched_lock(&root->delalloc_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&root->delalloc_lock);\n\n\t\tif (snapshot)\n\t\t\tset_bit(BTRFS_INODE_SNAPSHOT_FLUSH,\n\t\t\t\t&binode->runtime_flags);\n\t\tif (full_flush) {\n\t\t\twork = btrfs_alloc_delalloc_work(inode);\n\t\t\tif (!work) {\n\t\t\t\tiput(inode);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlist_add_tail(&work->list, &works);\n\t\t\tbtrfs_queue_work(root->fs_info->flush_workers,\n\t\t\t\t\t &work->work);\n\t\t} else {\n\t\t\tret = filemap_fdatawrite_wbc(inode->i_mapping, wbc);\n\t\t\tbtrfs_add_delayed_iput(BTRFS_I(inode));\n\t\t\tif (ret || wbc->nr_to_write <= 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tcond_resched();\n\t\tspin_lock(&root->delalloc_lock);\n\t}\n\tspin_unlock(&root->delalloc_lock);\n\nout:\n\tlist_for_each_entry_safe(work, next, &works, list) {\n\t\tlist_del_init(&work->list);\n\t\twait_for_completion(&work->completion);\n\t\tkfree(work);\n\t}\n\n\tif (!list_empty(&splice)) {\n\t\tspin_lock(&root->delalloc_lock);\n\t\tlist_splice_tail(&splice, &root->delalloc_inodes);\n\t\tspin_unlock(&root->delalloc_lock);\n\t}\n\tmutex_unlock(&root->delalloc_mutex);\n\treturn ret;\n}\n\nint btrfs_start_delalloc_snapshot(struct btrfs_root *root, bool in_reclaim_context)\n{\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (BTRFS_FS_ERROR(fs_info))\n\t\treturn -EROFS;\n\n\treturn start_delalloc_inodes(root, &wbc, true, in_reclaim_context);\n}\n\nint btrfs_start_delalloc_roots(struct btrfs_fs_info *fs_info, long nr,\n\t\t\t       bool in_reclaim_context)\n{\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = nr,\n\t\t.sync_mode = WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\tstruct btrfs_root *root;\n\tLIST_HEAD(splice);\n\tint ret;\n\n\tif (BTRFS_FS_ERROR(fs_info))\n\t\treturn -EROFS;\n\n\tmutex_lock(&fs_info->delalloc_root_mutex);\n\tspin_lock(&fs_info->delalloc_root_lock);\n\tlist_splice_init(&fs_info->delalloc_roots, &splice);\n\twhile (!list_empty(&splice)) {\n\t\t \n\t\tif (nr == LONG_MAX)\n\t\t\twbc.nr_to_write = LONG_MAX;\n\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tdelalloc_root);\n\t\troot = btrfs_grab_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->delalloc_root,\n\t\t\t       &fs_info->delalloc_roots);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\t\tret = start_delalloc_inodes(root, &wbc, false, in_reclaim_context);\n\t\tbtrfs_put_root(root);\n\t\tif (ret < 0 || wbc.nr_to_write <= 0)\n\t\t\tgoto out;\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t}\n\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\tret = 0;\nout:\n\tif (!list_empty(&splice)) {\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t\tlist_splice_tail(&splice, &fs_info->delalloc_roots);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\t}\n\tmutex_unlock(&fs_info->delalloc_root_mutex);\n\treturn ret;\n}\n\nstatic int btrfs_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t struct dentry *dentry, const char *symname)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(dir->i_sb);\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\tstruct btrfs_new_inode_args new_inode_args = {\n\t\t.dir = dir,\n\t\t.dentry = dentry,\n\t};\n\tunsigned int trans_num_items;\n\tint err;\n\tint name_len;\n\tint datasize;\n\tunsigned long ptr;\n\tstruct btrfs_file_extent_item *ei;\n\tstruct extent_buffer *leaf;\n\n\tname_len = strlen(symname);\n\tif (name_len > BTRFS_MAX_INLINE_DATA_SIZE(fs_info))\n\t\treturn -ENAMETOOLONG;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\tinode_init_owner(idmap, inode, dir, S_IFLNK | S_IRWXUGO);\n\tinode->i_op = &btrfs_symlink_inode_operations;\n\tinode_nohighmem(inode);\n\tinode->i_mapping->a_ops = &btrfs_aops;\n\tbtrfs_i_size_write(BTRFS_I(inode), name_len);\n\tinode_set_bytes(inode, name_len);\n\n\tnew_inode_args.inode = inode;\n\terr = btrfs_new_inode_prepare(&new_inode_args, &trans_num_items);\n\tif (err)\n\t\tgoto out_inode;\n\t \n\ttrans_num_items++;\n\n\ttrans = btrfs_start_transaction(root, trans_num_items);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_new_inode_args;\n\t}\n\n\terr = btrfs_create_new_inode(trans, &new_inode_args);\n\tif (err)\n\t\tgoto out;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tbtrfs_abort_transaction(trans, err);\n\t\tdiscard_new_inode(inode);\n\t\tinode = NULL;\n\t\tgoto out;\n\t}\n\tkey.objectid = btrfs_ino(BTRFS_I(inode));\n\tkey.offset = 0;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tdatasize = btrfs_file_extent_calc_inline_size(name_len);\n\terr = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      datasize);\n\tif (err) {\n\t\tbtrfs_abort_transaction(trans, err);\n\t\tbtrfs_free_path(path);\n\t\tdiscard_new_inode(inode);\n\t\tinode = NULL;\n\t\tgoto out;\n\t}\n\tleaf = path->nodes[0];\n\tei = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\tbtrfs_set_file_extent_generation(leaf, ei, trans->transid);\n\tbtrfs_set_file_extent_type(leaf, ei,\n\t\t\t\t   BTRFS_FILE_EXTENT_INLINE);\n\tbtrfs_set_file_extent_encryption(leaf, ei, 0);\n\tbtrfs_set_file_extent_compression(leaf, ei, 0);\n\tbtrfs_set_file_extent_other_encoding(leaf, ei, 0);\n\tbtrfs_set_file_extent_ram_bytes(leaf, ei, name_len);\n\n\tptr = btrfs_file_extent_inline_start(ei);\n\twrite_extent_buffer(leaf, symname, ptr, name_len);\n\tbtrfs_mark_buffer_dirty(trans, leaf);\n\tbtrfs_free_path(path);\n\n\td_instantiate_new(dentry, inode);\n\terr = 0;\nout:\n\tbtrfs_end_transaction(trans);\n\tbtrfs_btree_balance_dirty(fs_info);\nout_new_inode_args:\n\tbtrfs_new_inode_args_destroy(&new_inode_args);\nout_inode:\n\tif (err)\n\t\tiput(inode);\n\treturn err;\n}\n\nstatic struct btrfs_trans_handle *insert_prealloc_file_extent(\n\t\t\t\t       struct btrfs_trans_handle *trans_in,\n\t\t\t\t       struct btrfs_inode *inode,\n\t\t\t\t       struct btrfs_key *ins,\n\t\t\t\t       u64 file_offset)\n{\n\tstruct btrfs_file_extent_item stack_fi;\n\tstruct btrfs_replace_extent_info extent_info;\n\tstruct btrfs_trans_handle *trans = trans_in;\n\tstruct btrfs_path *path;\n\tu64 start = ins->objectid;\n\tu64 len = ins->offset;\n\tu64 qgroup_released = 0;\n\tint ret;\n\n\tmemset(&stack_fi, 0, sizeof(stack_fi));\n\n\tbtrfs_set_stack_file_extent_type(&stack_fi, BTRFS_FILE_EXTENT_PREALLOC);\n\tbtrfs_set_stack_file_extent_disk_bytenr(&stack_fi, start);\n\tbtrfs_set_stack_file_extent_disk_num_bytes(&stack_fi, len);\n\tbtrfs_set_stack_file_extent_num_bytes(&stack_fi, len);\n\tbtrfs_set_stack_file_extent_ram_bytes(&stack_fi, len);\n\tbtrfs_set_stack_file_extent_compression(&stack_fi, BTRFS_COMPRESS_NONE);\n\t \n\n\tret = btrfs_qgroup_release_data(inode, file_offset, len, &qgroup_released);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (trans) {\n\t\tret = insert_reserved_file_extent(trans, inode,\n\t\t\t\t\t\t  file_offset, &stack_fi,\n\t\t\t\t\t\t  true, qgroup_released);\n\t\tif (ret)\n\t\t\tgoto free_qgroup;\n\t\treturn trans;\n\t}\n\n\textent_info.disk_offset = start;\n\textent_info.disk_len = len;\n\textent_info.data_offset = 0;\n\textent_info.data_len = len;\n\textent_info.file_offset = file_offset;\n\textent_info.extent_buf = (char *)&stack_fi;\n\textent_info.is_new_extent = true;\n\textent_info.update_times = true;\n\textent_info.qgroup_reserved = qgroup_released;\n\textent_info.insertions = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto free_qgroup;\n\t}\n\n\tret = btrfs_replace_file_extents(inode, path, file_offset,\n\t\t\t\t     file_offset + len - 1, &extent_info,\n\t\t\t\t     &trans);\n\tbtrfs_free_path(path);\n\tif (ret)\n\t\tgoto free_qgroup;\n\treturn trans;\n\nfree_qgroup:\n\t \n\tbtrfs_qgroup_free_refroot(inode->root->fs_info,\n\t\t\tinode->root->root_key.objectid, qgroup_released,\n\t\t\tBTRFS_QGROUP_RSV_DATA);\n\treturn ERR_PTR(ret);\n}\n\nstatic int __btrfs_prealloc_file_range(struct inode *inode, int mode,\n\t\t\t\t       u64 start, u64 num_bytes, u64 min_size,\n\t\t\t\t       loff_t actual_len, u64 *alloc_hint,\n\t\t\t\t       struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct extent_map *em;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_key ins;\n\tu64 cur_offset = start;\n\tu64 clear_offset = start;\n\tu64 i_size;\n\tu64 cur_bytes;\n\tu64 last_alloc = (u64)-1;\n\tint ret = 0;\n\tbool own_trans = true;\n\tu64 end = start + num_bytes - 1;\n\n\tif (trans)\n\t\town_trans = false;\n\twhile (num_bytes > 0) {\n\t\tcur_bytes = min_t(u64, num_bytes, SZ_256M);\n\t\tcur_bytes = max(cur_bytes, min_size);\n\t\t \n\t\tcur_bytes = min(cur_bytes, last_alloc);\n\t\tret = btrfs_reserve_extent(root, cur_bytes, cur_bytes,\n\t\t\t\tmin_size, 0, *alloc_hint, &ins, 1, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tclear_offset += ins.offset;\n\n\t\tlast_alloc = ins.offset;\n\t\ttrans = insert_prealloc_file_extent(trans, BTRFS_I(inode),\n\t\t\t\t\t\t    &ins, cur_offset);\n\t\t \n\t\tbtrfs_dec_block_group_reservations(fs_info, ins.objectid);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tbtrfs_free_reserved_extent(fs_info, ins.objectid,\n\t\t\t\t\t\t   ins.offset, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\tbtrfs_drop_extent_map_range(BTRFS_I(inode), cur_offset,\n\t\t\t\t\t    cur_offset + ins.offset - 1, false);\n\t\t\tbtrfs_set_inode_full_sync(BTRFS_I(inode));\n\t\t\tgoto next;\n\t\t}\n\n\t\tem->start = cur_offset;\n\t\tem->orig_start = cur_offset;\n\t\tem->len = ins.offset;\n\t\tem->block_start = ins.objectid;\n\t\tem->block_len = ins.offset;\n\t\tem->orig_block_len = ins.offset;\n\t\tem->ram_bytes = ins.offset;\n\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\tem->generation = trans->transid;\n\n\t\tret = btrfs_replace_extent_map_range(BTRFS_I(inode), em, true);\n\t\tfree_extent_map(em);\nnext:\n\t\tnum_bytes -= ins.offset;\n\t\tcur_offset += ins.offset;\n\t\t*alloc_hint = ins.objectid + ins.offset;\n\n\t\tinode_inc_iversion(inode);\n\t\tinode_set_ctime_current(inode);\n\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_PREALLOC;\n\t\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t\t    (actual_len > inode->i_size) &&\n\t\t    (cur_offset > inode->i_size)) {\n\t\t\tif (cur_offset > actual_len)\n\t\t\t\ti_size = actual_len;\n\t\t\telse\n\t\t\t\ti_size = cur_offset;\n\t\t\ti_size_write(inode, i_size);\n\t\t\tbtrfs_inode_safe_disk_i_size_write(BTRFS_I(inode), 0);\n\t\t}\n\n\t\tret = btrfs_update_inode(trans, root, BTRFS_I(inode));\n\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tif (own_trans)\n\t\t\t\tbtrfs_end_transaction(trans);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (own_trans) {\n\t\t\tbtrfs_end_transaction(trans);\n\t\t\ttrans = NULL;\n\t\t}\n\t}\n\tif (clear_offset < end)\n\t\tbtrfs_free_reserved_data_space(BTRFS_I(inode), NULL, clear_offset,\n\t\t\tend - clear_offset + 1);\n\treturn ret;\n}\n\nint btrfs_prealloc_file_range(struct inode *inode, int mode,\n\t\t\t      u64 start, u64 num_bytes, u64 min_size,\n\t\t\t      loff_t actual_len, u64 *alloc_hint)\n{\n\treturn __btrfs_prealloc_file_range(inode, mode, start, num_bytes,\n\t\t\t\t\t   min_size, actual_len, alloc_hint,\n\t\t\t\t\t   NULL);\n}\n\nint btrfs_prealloc_file_range_trans(struct inode *inode,\n\t\t\t\t    struct btrfs_trans_handle *trans, int mode,\n\t\t\t\t    u64 start, u64 num_bytes, u64 min_size,\n\t\t\t\t    loff_t actual_len, u64 *alloc_hint)\n{\n\treturn __btrfs_prealloc_file_range(inode, mode, start, num_bytes,\n\t\t\t\t\t   min_size, actual_len, alloc_hint, trans);\n}\n\nstatic int btrfs_permission(struct mnt_idmap *idmap,\n\t\t\t    struct inode *inode, int mask)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tumode_t mode = inode->i_mode;\n\n\tif (mask & MAY_WRITE &&\n\t    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode))) {\n\t\tif (btrfs_root_readonly(root))\n\t\t\treturn -EROFS;\n\t\tif (BTRFS_I(inode)->flags & BTRFS_INODE_READONLY)\n\t\t\treturn -EACCES;\n\t}\n\treturn generic_permission(idmap, inode, mask);\n}\n\nstatic int btrfs_tmpfile(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t struct file *file, umode_t mode)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(dir->i_sb);\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct inode *inode;\n\tstruct btrfs_new_inode_args new_inode_args = {\n\t\t.dir = dir,\n\t\t.dentry = file->f_path.dentry,\n\t\t.orphan = true,\n\t};\n\tunsigned int trans_num_items;\n\tint ret;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\tinode_init_owner(idmap, inode, dir, mode);\n\tinode->i_fop = &btrfs_file_operations;\n\tinode->i_op = &btrfs_file_inode_operations;\n\tinode->i_mapping->a_ops = &btrfs_aops;\n\n\tnew_inode_args.inode = inode;\n\tret = btrfs_new_inode_prepare(&new_inode_args, &trans_num_items);\n\tif (ret)\n\t\tgoto out_inode;\n\n\ttrans = btrfs_start_transaction(root, trans_num_items);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_new_inode_args;\n\t}\n\n\tret = btrfs_create_new_inode(trans, &new_inode_args);\n\n\t \n\tset_nlink(inode, 1);\n\n\tif (!ret) {\n\t\td_tmpfile(file, inode);\n\t\tunlock_new_inode(inode);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tbtrfs_end_transaction(trans);\n\tbtrfs_btree_balance_dirty(fs_info);\nout_new_inode_args:\n\tbtrfs_new_inode_args_destroy(&new_inode_args);\nout_inode:\n\tif (ret)\n\t\tiput(inode);\n\treturn finish_open_simple(file, ret);\n}\n\nvoid btrfs_set_range_writeback(struct btrfs_inode *inode, u64 start, u64 end)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tunsigned long index = start >> PAGE_SHIFT;\n\tunsigned long end_index = end >> PAGE_SHIFT;\n\tstruct page *page;\n\tu32 len;\n\n\tASSERT(end + 1 - start <= U32_MAX);\n\tlen = end + 1 - start;\n\twhile (index <= end_index) {\n\t\tpage = find_get_page(inode->vfs_inode.i_mapping, index);\n\t\tASSERT(page);  \n\n\t\tbtrfs_page_set_writeback(fs_info, page, start, len);\n\t\tput_page(page);\n\t\tindex++;\n\t}\n}\n\nint btrfs_encoded_io_compression_from_extent(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t     int compress_type)\n{\n\tswitch (compress_type) {\n\tcase BTRFS_COMPRESS_NONE:\n\t\treturn BTRFS_ENCODED_IO_COMPRESSION_NONE;\n\tcase BTRFS_COMPRESS_ZLIB:\n\t\treturn BTRFS_ENCODED_IO_COMPRESSION_ZLIB;\n\tcase BTRFS_COMPRESS_LZO:\n\t\t \n\t\tif (fs_info->sectorsize < SZ_4K || fs_info->sectorsize > SZ_64K)\n\t\t\treturn -EINVAL;\n\t\treturn BTRFS_ENCODED_IO_COMPRESSION_LZO_4K +\n\t\t       (fs_info->sectorsize_bits - 12);\n\tcase BTRFS_COMPRESS_ZSTD:\n\t\treturn BTRFS_ENCODED_IO_COMPRESSION_ZSTD;\n\tdefault:\n\t\treturn -EUCLEAN;\n\t}\n}\n\nstatic ssize_t btrfs_encoded_read_inline(\n\t\t\t\tstruct kiocb *iocb,\n\t\t\t\tstruct iov_iter *iter, u64 start,\n\t\t\t\tu64 lockend,\n\t\t\t\tstruct extent_state **cached_state,\n\t\t\t\tu64 extent_start, size_t count,\n\t\t\t\tstruct btrfs_ioctl_encoded_io_args *encoded,\n\t\t\t\tbool *unlocked)\n{\n\tstruct btrfs_inode *inode = BTRFS_I(file_inode(iocb->ki_filp));\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct extent_io_tree *io_tree = &inode->io_tree;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *item;\n\tu64 ram_bytes;\n\tunsigned long ptr;\n\tvoid *tmp;\n\tssize_t ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tret = btrfs_lookup_file_extent(NULL, root, path, btrfs_ino(inode),\n\t\t\t\t       extent_start, 0);\n\tif (ret) {\n\t\tif (ret > 0) {\n\t\t\t \n\t\t\tret = -EIO;\n\t\t}\n\t\tgoto out;\n\t}\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_file_extent_item);\n\n\tram_bytes = btrfs_file_extent_ram_bytes(leaf, item);\n\tptr = btrfs_file_extent_inline_start(item);\n\n\tencoded->len = min_t(u64, extent_start + ram_bytes,\n\t\t\t     inode->vfs_inode.i_size) - iocb->ki_pos;\n\tret = btrfs_encoded_io_compression_from_extent(fs_info,\n\t\t\t\t btrfs_file_extent_compression(leaf, item));\n\tif (ret < 0)\n\t\tgoto out;\n\tencoded->compression = ret;\n\tif (encoded->compression) {\n\t\tsize_t inline_size;\n\n\t\tinline_size = btrfs_file_extent_inline_item_len(leaf,\n\t\t\t\t\t\t\t\tpath->slots[0]);\n\t\tif (inline_size > count) {\n\t\t\tret = -ENOBUFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcount = inline_size;\n\t\tencoded->unencoded_len = ram_bytes;\n\t\tencoded->unencoded_offset = iocb->ki_pos - extent_start;\n\t} else {\n\t\tcount = min_t(u64, count, encoded->len);\n\t\tencoded->len = count;\n\t\tencoded->unencoded_len = count;\n\t\tptr += iocb->ki_pos - extent_start;\n\t}\n\n\ttmp = kmalloc(count, GFP_NOFS);\n\tif (!tmp) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tread_extent_buffer(leaf, tmp, ptr, count);\n\tbtrfs_release_path(path);\n\tunlock_extent(io_tree, start, lockend, cached_state);\n\tbtrfs_inode_unlock(inode, BTRFS_ILOCK_SHARED);\n\t*unlocked = true;\n\n\tret = copy_to_iter(tmp, count, iter);\n\tif (ret != count)\n\t\tret = -EFAULT;\n\tkfree(tmp);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstruct btrfs_encoded_read_private {\n\twait_queue_head_t wait;\n\tatomic_t pending;\n\tblk_status_t status;\n};\n\nstatic void btrfs_encoded_read_endio(struct btrfs_bio *bbio)\n{\n\tstruct btrfs_encoded_read_private *priv = bbio->private;\n\n\tif (bbio->bio.bi_status) {\n\t\t \n\t\tWRITE_ONCE(priv->status, bbio->bio.bi_status);\n\t}\n\tif (!atomic_dec_return(&priv->pending))\n\t\twake_up(&priv->wait);\n\tbio_put(&bbio->bio);\n}\n\nint btrfs_encoded_read_regular_fill_pages(struct btrfs_inode *inode,\n\t\t\t\t\t  u64 file_offset, u64 disk_bytenr,\n\t\t\t\t\t  u64 disk_io_size, struct page **pages)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tstruct btrfs_encoded_read_private priv = {\n\t\t.pending = ATOMIC_INIT(1),\n\t};\n\tunsigned long i = 0;\n\tstruct btrfs_bio *bbio;\n\n\tinit_waitqueue_head(&priv.wait);\n\n\tbbio = btrfs_bio_alloc(BIO_MAX_VECS, REQ_OP_READ, fs_info,\n\t\t\t       btrfs_encoded_read_endio, &priv);\n\tbbio->bio.bi_iter.bi_sector = disk_bytenr >> SECTOR_SHIFT;\n\tbbio->inode = inode;\n\n\tdo {\n\t\tsize_t bytes = min_t(u64, disk_io_size, PAGE_SIZE);\n\n\t\tif (bio_add_page(&bbio->bio, pages[i], bytes, 0) < bytes) {\n\t\t\tatomic_inc(&priv.pending);\n\t\t\tbtrfs_submit_bio(bbio, 0);\n\n\t\t\tbbio = btrfs_bio_alloc(BIO_MAX_VECS, REQ_OP_READ, fs_info,\n\t\t\t\t\t       btrfs_encoded_read_endio, &priv);\n\t\t\tbbio->bio.bi_iter.bi_sector = disk_bytenr >> SECTOR_SHIFT;\n\t\t\tbbio->inode = inode;\n\t\t\tcontinue;\n\t\t}\n\n\t\ti++;\n\t\tdisk_bytenr += bytes;\n\t\tdisk_io_size -= bytes;\n\t} while (disk_io_size);\n\n\tatomic_inc(&priv.pending);\n\tbtrfs_submit_bio(bbio, 0);\n\n\tif (atomic_dec_return(&priv.pending))\n\t\tio_wait_event(priv.wait, !atomic_read(&priv.pending));\n\t \n\treturn blk_status_to_errno(READ_ONCE(priv.status));\n}\n\nstatic ssize_t btrfs_encoded_read_regular(struct kiocb *iocb,\n\t\t\t\t\t  struct iov_iter *iter,\n\t\t\t\t\t  u64 start, u64 lockend,\n\t\t\t\t\t  struct extent_state **cached_state,\n\t\t\t\t\t  u64 disk_bytenr, u64 disk_io_size,\n\t\t\t\t\t  size_t count, bool compressed,\n\t\t\t\t\t  bool *unlocked)\n{\n\tstruct btrfs_inode *inode = BTRFS_I(file_inode(iocb->ki_filp));\n\tstruct extent_io_tree *io_tree = &inode->io_tree;\n\tstruct page **pages;\n\tunsigned long nr_pages, i;\n\tu64 cur;\n\tsize_t page_offset;\n\tssize_t ret;\n\n\tnr_pages = DIV_ROUND_UP(disk_io_size, PAGE_SIZE);\n\tpages = kcalloc(nr_pages, sizeof(struct page *), GFP_NOFS);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\tret = btrfs_alloc_page_array(nr_pages, pages);\n\tif (ret) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t\t}\n\n\tret = btrfs_encoded_read_regular_fill_pages(inode, start, disk_bytenr,\n\t\t\t\t\t\t    disk_io_size, pages);\n\tif (ret)\n\t\tgoto out;\n\n\tunlock_extent(io_tree, start, lockend, cached_state);\n\tbtrfs_inode_unlock(inode, BTRFS_ILOCK_SHARED);\n\t*unlocked = true;\n\n\tif (compressed) {\n\t\ti = 0;\n\t\tpage_offset = 0;\n\t} else {\n\t\ti = (iocb->ki_pos - start) >> PAGE_SHIFT;\n\t\tpage_offset = (iocb->ki_pos - start) & (PAGE_SIZE - 1);\n\t}\n\tcur = 0;\n\twhile (cur < count) {\n\t\tsize_t bytes = min_t(size_t, count - cur,\n\t\t\t\t     PAGE_SIZE - page_offset);\n\n\t\tif (copy_page_to_iter(pages[i], page_offset, bytes,\n\t\t\t\t      iter) != bytes) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\ti++;\n\t\tcur += bytes;\n\t\tpage_offset = 0;\n\t}\n\tret = count;\nout:\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\t}\n\tkfree(pages);\n\treturn ret;\n}\n\nssize_t btrfs_encoded_read(struct kiocb *iocb, struct iov_iter *iter,\n\t\t\t   struct btrfs_ioctl_encoded_io_args *encoded)\n{\n\tstruct btrfs_inode *inode = BTRFS_I(file_inode(iocb->ki_filp));\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tstruct extent_io_tree *io_tree = &inode->io_tree;\n\tssize_t ret;\n\tsize_t count = iov_iter_count(iter);\n\tu64 start, lockend, disk_bytenr, disk_io_size;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_map *em;\n\tbool unlocked = false;\n\n\tfile_accessed(iocb->ki_filp);\n\n\tbtrfs_inode_lock(inode, BTRFS_ILOCK_SHARED);\n\n\tif (iocb->ki_pos >= inode->vfs_inode.i_size) {\n\t\tbtrfs_inode_unlock(inode, BTRFS_ILOCK_SHARED);\n\t\treturn 0;\n\t}\n\tstart = ALIGN_DOWN(iocb->ki_pos, fs_info->sectorsize);\n\t \n\tlockend = start + BTRFS_MAX_UNCOMPRESSED - 1;\n\n\tfor (;;) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\n\t\tret = btrfs_wait_ordered_range(&inode->vfs_inode, start,\n\t\t\t\t\t       lockend - start + 1);\n\t\tif (ret)\n\t\t\tgoto out_unlock_inode;\n\t\tlock_extent(io_tree, start, lockend, &cached_state);\n\t\tordered = btrfs_lookup_ordered_range(inode, start,\n\t\t\t\t\t\t     lockend - start + 1);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tunlock_extent(io_tree, start, lockend, &cached_state);\n\t\tcond_resched();\n\t}\n\n\tem = btrfs_get_extent(inode, NULL, 0, start, lockend - start + 1);\n\tif (IS_ERR(em)) {\n\t\tret = PTR_ERR(em);\n\t\tgoto out_unlock_extent;\n\t}\n\n\tif (em->block_start == EXTENT_MAP_INLINE) {\n\t\tu64 extent_start = em->start;\n\n\t\t \n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\t\tret = btrfs_encoded_read_inline(iocb, iter, start, lockend,\n\t\t\t\t\t\t&cached_state, extent_start,\n\t\t\t\t\t\tcount, encoded, &unlocked);\n\t\tgoto out;\n\t}\n\n\t \n\tencoded->len = min_t(u64, extent_map_end(em),\n\t\t\t     inode->vfs_inode.i_size) - iocb->ki_pos;\n\tif (em->block_start == EXTENT_MAP_HOLE ||\n\t    test_bit(EXTENT_FLAG_PREALLOC, &em->flags)) {\n\t\tdisk_bytenr = EXTENT_MAP_HOLE;\n\t\tcount = min_t(u64, count, encoded->len);\n\t\tencoded->len = count;\n\t\tencoded->unencoded_len = count;\n\t} else if (test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {\n\t\tdisk_bytenr = em->block_start;\n\t\t \n\t\tif (em->block_len > count) {\n\t\t\tret = -ENOBUFS;\n\t\t\tgoto out_em;\n\t\t}\n\t\tdisk_io_size = em->block_len;\n\t\tcount = em->block_len;\n\t\tencoded->unencoded_len = em->ram_bytes;\n\t\tencoded->unencoded_offset = iocb->ki_pos - em->orig_start;\n\t\tret = btrfs_encoded_io_compression_from_extent(fs_info,\n\t\t\t\t\t\t\t     em->compress_type);\n\t\tif (ret < 0)\n\t\t\tgoto out_em;\n\t\tencoded->compression = ret;\n\t} else {\n\t\tdisk_bytenr = em->block_start + (start - em->start);\n\t\tif (encoded->len > count)\n\t\t\tencoded->len = count;\n\t\t \n\t\tdisk_io_size = min(lockend + 1, iocb->ki_pos + encoded->len) - start;\n\t\tcount = start + disk_io_size - iocb->ki_pos;\n\t\tencoded->len = count;\n\t\tencoded->unencoded_len = count;\n\t\tdisk_io_size = ALIGN(disk_io_size, fs_info->sectorsize);\n\t}\n\tfree_extent_map(em);\n\tem = NULL;\n\n\tif (disk_bytenr == EXTENT_MAP_HOLE) {\n\t\tunlock_extent(io_tree, start, lockend, &cached_state);\n\t\tbtrfs_inode_unlock(inode, BTRFS_ILOCK_SHARED);\n\t\tunlocked = true;\n\t\tret = iov_iter_zero(count, iter);\n\t\tif (ret != count)\n\t\t\tret = -EFAULT;\n\t} else {\n\t\tret = btrfs_encoded_read_regular(iocb, iter, start, lockend,\n\t\t\t\t\t\t &cached_state, disk_bytenr,\n\t\t\t\t\t\t disk_io_size, count,\n\t\t\t\t\t\t encoded->compression,\n\t\t\t\t\t\t &unlocked);\n\t}\n\nout:\n\tif (ret >= 0)\n\t\tiocb->ki_pos += encoded->len;\nout_em:\n\tfree_extent_map(em);\nout_unlock_extent:\n\tif (!unlocked)\n\t\tunlock_extent(io_tree, start, lockend, &cached_state);\nout_unlock_inode:\n\tif (!unlocked)\n\t\tbtrfs_inode_unlock(inode, BTRFS_ILOCK_SHARED);\n\treturn ret;\n}\n\nssize_t btrfs_do_encoded_write(struct kiocb *iocb, struct iov_iter *from,\n\t\t\t       const struct btrfs_ioctl_encoded_io_args *encoded)\n{\n\tstruct btrfs_inode *inode = BTRFS_I(file_inode(iocb->ki_filp));\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct extent_io_tree *io_tree = &inode->io_tree;\n\tstruct extent_changeset *data_reserved = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tstruct btrfs_ordered_extent *ordered;\n\tint compression;\n\tsize_t orig_count;\n\tu64 start, end;\n\tu64 num_bytes, ram_bytes, disk_num_bytes;\n\tunsigned long nr_pages, i;\n\tstruct page **pages;\n\tstruct btrfs_key ins;\n\tbool extent_reserved = false;\n\tstruct extent_map *em;\n\tssize_t ret;\n\n\tswitch (encoded->compression) {\n\tcase BTRFS_ENCODED_IO_COMPRESSION_ZLIB:\n\t\tcompression = BTRFS_COMPRESS_ZLIB;\n\t\tbreak;\n\tcase BTRFS_ENCODED_IO_COMPRESSION_ZSTD:\n\t\tcompression = BTRFS_COMPRESS_ZSTD;\n\t\tbreak;\n\tcase BTRFS_ENCODED_IO_COMPRESSION_LZO_4K:\n\tcase BTRFS_ENCODED_IO_COMPRESSION_LZO_8K:\n\tcase BTRFS_ENCODED_IO_COMPRESSION_LZO_16K:\n\tcase BTRFS_ENCODED_IO_COMPRESSION_LZO_32K:\n\tcase BTRFS_ENCODED_IO_COMPRESSION_LZO_64K:\n\t\t \n\t\tif (encoded->compression -\n\t\t    BTRFS_ENCODED_IO_COMPRESSION_LZO_4K + 12 !=\n\t\t    fs_info->sectorsize_bits)\n\t\t\treturn -EINVAL;\n\t\tcompression = BTRFS_COMPRESS_LZO;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (encoded->encryption != BTRFS_ENCODED_IO_ENCRYPTION_NONE)\n\t\treturn -EINVAL;\n\n\torig_count = iov_iter_count(from);\n\n\t \n\tif (encoded->unencoded_len > BTRFS_MAX_UNCOMPRESSED ||\n\t    orig_count > BTRFS_MAX_COMPRESSED || orig_count == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (orig_count >= encoded->unencoded_len)\n\t\treturn -EINVAL;\n\n\t \n\tstart = iocb->ki_pos;\n\tif (!IS_ALIGNED(start, fs_info->sectorsize))\n\t\treturn -EINVAL;\n\n\t \n\tif (start + encoded->len < inode->vfs_inode.i_size &&\n\t    !IS_ALIGNED(start + encoded->len, fs_info->sectorsize))\n\t\treturn -EINVAL;\n\n\t \n\tif (!IS_ALIGNED(encoded->unencoded_offset, fs_info->sectorsize))\n\t\treturn -EINVAL;\n\n\tnum_bytes = ALIGN(encoded->len, fs_info->sectorsize);\n\tram_bytes = ALIGN(encoded->unencoded_len, fs_info->sectorsize);\n\tend = start + num_bytes - 1;\n\n\t \n\tdisk_num_bytes = ALIGN(orig_count, fs_info->sectorsize);\n\tnr_pages = DIV_ROUND_UP(disk_num_bytes, PAGE_SIZE);\n\tpages = kvcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL_ACCOUNT);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tsize_t bytes = min_t(size_t, PAGE_SIZE, iov_iter_count(from));\n\t\tchar *kaddr;\n\n\t\tpages[i] = alloc_page(GFP_KERNEL_ACCOUNT);\n\t\tif (!pages[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_pages;\n\t\t}\n\t\tkaddr = kmap_local_page(pages[i]);\n\t\tif (copy_from_iter(kaddr, bytes, from) != bytes) {\n\t\t\tkunmap_local(kaddr);\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_pages;\n\t\t}\n\t\tif (bytes < PAGE_SIZE)\n\t\t\tmemset(kaddr + bytes, 0, PAGE_SIZE - bytes);\n\t\tkunmap_local(kaddr);\n\t}\n\n\tfor (;;) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\n\t\tret = btrfs_wait_ordered_range(&inode->vfs_inode, start, num_bytes);\n\t\tif (ret)\n\t\t\tgoto out_pages;\n\t\tret = invalidate_inode_pages2_range(inode->vfs_inode.i_mapping,\n\t\t\t\t\t\t    start >> PAGE_SHIFT,\n\t\t\t\t\t\t    end >> PAGE_SHIFT);\n\t\tif (ret)\n\t\t\tgoto out_pages;\n\t\tlock_extent(io_tree, start, end, &cached_state);\n\t\tordered = btrfs_lookup_ordered_range(inode, start, num_bytes);\n\t\tif (!ordered &&\n\t\t    !filemap_range_has_page(inode->vfs_inode.i_mapping, start, end))\n\t\t\tbreak;\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tunlock_extent(io_tree, start, end, &cached_state);\n\t\tcond_resched();\n\t}\n\n\t \n\tret = btrfs_alloc_data_chunk_ondemand(inode, disk_num_bytes);\n\tif (ret)\n\t\tgoto out_unlock;\n\tret = btrfs_qgroup_reserve_data(inode, &data_reserved, start, num_bytes);\n\tif (ret)\n\t\tgoto out_free_data_space;\n\tret = btrfs_delalloc_reserve_metadata(inode, num_bytes, disk_num_bytes,\n\t\t\t\t\t      false);\n\tif (ret)\n\t\tgoto out_qgroup_free_data;\n\n\t \n\tif (start == 0 && encoded->unencoded_len == encoded->len &&\n\t    encoded->unencoded_offset == 0) {\n\t\tret = cow_file_range_inline(inode, encoded->len, orig_count,\n\t\t\t\t\t    compression, pages, true);\n\t\tif (ret <= 0) {\n\t\t\tif (ret == 0)\n\t\t\t\tret = orig_count;\n\t\t\tgoto out_delalloc_release;\n\t\t}\n\t}\n\n\tret = btrfs_reserve_extent(root, disk_num_bytes, disk_num_bytes,\n\t\t\t\t   disk_num_bytes, 0, 0, &ins, 1, 1);\n\tif (ret)\n\t\tgoto out_delalloc_release;\n\textent_reserved = true;\n\n\tem = create_io_em(inode, start, num_bytes,\n\t\t\t  start - encoded->unencoded_offset, ins.objectid,\n\t\t\t  ins.offset, ins.offset, ram_bytes, compression,\n\t\t\t  BTRFS_ORDERED_COMPRESSED);\n\tif (IS_ERR(em)) {\n\t\tret = PTR_ERR(em);\n\t\tgoto out_free_reserved;\n\t}\n\tfree_extent_map(em);\n\n\tordered = btrfs_alloc_ordered_extent(inode, start, num_bytes, ram_bytes,\n\t\t\t\t       ins.objectid, ins.offset,\n\t\t\t\t       encoded->unencoded_offset,\n\t\t\t\t       (1 << BTRFS_ORDERED_ENCODED) |\n\t\t\t\t       (1 << BTRFS_ORDERED_COMPRESSED),\n\t\t\t\t       compression);\n\tif (IS_ERR(ordered)) {\n\t\tbtrfs_drop_extent_map_range(inode, start, end, false);\n\t\tret = PTR_ERR(ordered);\n\t\tgoto out_free_reserved;\n\t}\n\tbtrfs_dec_block_group_reservations(fs_info, ins.objectid);\n\n\tif (start + encoded->len > inode->vfs_inode.i_size)\n\t\ti_size_write(&inode->vfs_inode, start + encoded->len);\n\n\tunlock_extent(io_tree, start, end, &cached_state);\n\n\tbtrfs_delalloc_release_extents(inode, num_bytes);\n\n\tbtrfs_submit_compressed_write(ordered, pages, nr_pages, 0, false);\n\tret = orig_count;\n\tgoto out;\n\nout_free_reserved:\n\tbtrfs_dec_block_group_reservations(fs_info, ins.objectid);\n\tbtrfs_free_reserved_extent(fs_info, ins.objectid, ins.offset, 1);\nout_delalloc_release:\n\tbtrfs_delalloc_release_extents(inode, num_bytes);\n\tbtrfs_delalloc_release_metadata(inode, disk_num_bytes, ret < 0);\nout_qgroup_free_data:\n\tif (ret < 0)\n\t\tbtrfs_qgroup_free_data(inode, data_reserved, start, num_bytes, NULL);\nout_free_data_space:\n\t \n\tif (!extent_reserved)\n\t\tbtrfs_free_reserved_data_space_noquota(fs_info, disk_num_bytes);\nout_unlock:\n\tunlock_extent(io_tree, start, end, &cached_state);\nout_pages:\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\t}\n\tkvfree(pages);\nout:\n\tif (ret >= 0)\n\t\tiocb->ki_pos += encoded->len;\n\treturn ret;\n}\n\n#ifdef CONFIG_SWAP\n \nstatic int btrfs_add_swapfile_pin(struct inode *inode, void *ptr,\n\t\t\t\t  bool is_block_group)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct btrfs_swapfile_pin *sp, *entry;\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\n\tsp = kmalloc(sizeof(*sp), GFP_NOFS);\n\tif (!sp)\n\t\treturn -ENOMEM;\n\tsp->ptr = ptr;\n\tsp->inode = inode;\n\tsp->is_block_group = is_block_group;\n\tsp->bg_extent_count = 1;\n\n\tspin_lock(&fs_info->swapfile_pins_lock);\n\tp = &fs_info->swapfile_pins.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct btrfs_swapfile_pin, node);\n\t\tif (sp->ptr < entry->ptr ||\n\t\t    (sp->ptr == entry->ptr && sp->inode < entry->inode)) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (sp->ptr > entry->ptr ||\n\t\t\t   (sp->ptr == entry->ptr && sp->inode > entry->inode)) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tif (is_block_group)\n\t\t\t\tentry->bg_extent_count++;\n\t\t\tspin_unlock(&fs_info->swapfile_pins_lock);\n\t\t\tkfree(sp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\trb_link_node(&sp->node, parent, p);\n\trb_insert_color(&sp->node, &fs_info->swapfile_pins);\n\tspin_unlock(&fs_info->swapfile_pins_lock);\n\treturn 0;\n}\n\n \nstatic void btrfs_free_swapfile_pins(struct inode *inode)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct btrfs_swapfile_pin *sp;\n\tstruct rb_node *node, *next;\n\n\tspin_lock(&fs_info->swapfile_pins_lock);\n\tnode = rb_first(&fs_info->swapfile_pins);\n\twhile (node) {\n\t\tnext = rb_next(node);\n\t\tsp = rb_entry(node, struct btrfs_swapfile_pin, node);\n\t\tif (sp->inode == inode) {\n\t\t\trb_erase(&sp->node, &fs_info->swapfile_pins);\n\t\t\tif (sp->is_block_group) {\n\t\t\t\tbtrfs_dec_block_group_swap_extents(sp->ptr,\n\t\t\t\t\t\t\t   sp->bg_extent_count);\n\t\t\t\tbtrfs_put_block_group(sp->ptr);\n\t\t\t}\n\t\t\tkfree(sp);\n\t\t}\n\t\tnode = next;\n\t}\n\tspin_unlock(&fs_info->swapfile_pins_lock);\n}\n\nstruct btrfs_swap_info {\n\tu64 start;\n\tu64 block_start;\n\tu64 block_len;\n\tu64 lowest_ppage;\n\tu64 highest_ppage;\n\tunsigned long nr_pages;\n\tint nr_extents;\n};\n\nstatic int btrfs_add_swap_extent(struct swap_info_struct *sis,\n\t\t\t\t struct btrfs_swap_info *bsi)\n{\n\tunsigned long nr_pages;\n\tunsigned long max_pages;\n\tu64 first_ppage, first_ppage_reported, next_ppage;\n\tint ret;\n\n\t \n\tif (bsi->nr_pages >= sis->max)\n\t\treturn 0;\n\n\tmax_pages = sis->max - bsi->nr_pages;\n\tfirst_ppage = PAGE_ALIGN(bsi->block_start) >> PAGE_SHIFT;\n\tnext_ppage = PAGE_ALIGN_DOWN(bsi->block_start + bsi->block_len) >> PAGE_SHIFT;\n\n\tif (first_ppage >= next_ppage)\n\t\treturn 0;\n\tnr_pages = next_ppage - first_ppage;\n\tnr_pages = min(nr_pages, max_pages);\n\n\tfirst_ppage_reported = first_ppage;\n\tif (bsi->start == 0)\n\t\tfirst_ppage_reported++;\n\tif (bsi->lowest_ppage > first_ppage_reported)\n\t\tbsi->lowest_ppage = first_ppage_reported;\n\tif (bsi->highest_ppage < (next_ppage - 1))\n\t\tbsi->highest_ppage = next_ppage - 1;\n\n\tret = add_swap_extent(sis, bsi->nr_pages, nr_pages, first_ppage);\n\tif (ret < 0)\n\t\treturn ret;\n\tbsi->nr_extents += ret;\n\tbsi->nr_pages += nr_pages;\n\treturn 0;\n}\n\nstatic void btrfs_swap_deactivate(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\n\tbtrfs_free_swapfile_pins(inode);\n\tatomic_dec(&BTRFS_I(inode)->root->nr_swapfiles);\n}\n\nstatic int btrfs_swap_activate(struct swap_info_struct *sis, struct file *file,\n\t\t\t       sector_t *span)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_map *em = NULL;\n\tstruct btrfs_device *device = NULL;\n\tstruct btrfs_swap_info bsi = {\n\t\t.lowest_ppage = (sector_t)-1ULL,\n\t};\n\tint ret = 0;\n\tu64 isize;\n\tu64 start;\n\n\t \n\tret = btrfs_wait_ordered_range(inode, 0, (u64)-1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (BTRFS_I(inode)->flags & BTRFS_INODE_COMPRESS) {\n\t\tbtrfs_warn(fs_info, \"swapfile must not be compressed\");\n\t\treturn -EINVAL;\n\t}\n\tif (!(BTRFS_I(inode)->flags & BTRFS_INODE_NODATACOW)) {\n\t\tbtrfs_warn(fs_info, \"swapfile must not be copy-on-write\");\n\t\treturn -EINVAL;\n\t}\n\tif (!(BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM)) {\n\t\tbtrfs_warn(fs_info, \"swapfile must not be checksummed\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!btrfs_exclop_start(fs_info, BTRFS_EXCLOP_SWAP_ACTIVATE)) {\n\t\tbtrfs_warn(fs_info,\n\t   \"cannot activate swapfile while exclusive operation is running\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (!btrfs_drew_try_write_lock(&root->snapshot_lock)) {\n\t\tbtrfs_exclop_finish(fs_info);\n\t\tbtrfs_warn(fs_info,\n\t   \"cannot activate swapfile because snapshot creation is in progress\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tspin_lock(&root->root_item_lock);\n\tif (btrfs_root_dead(root)) {\n\t\tspin_unlock(&root->root_item_lock);\n\n\t\tbtrfs_exclop_finish(fs_info);\n\t\tbtrfs_warn(fs_info,\n\t\t\"cannot activate swapfile because subvolume %llu is being deleted\",\n\t\t\troot->root_key.objectid);\n\t\treturn -EPERM;\n\t}\n\tatomic_inc(&root->nr_swapfiles);\n\tspin_unlock(&root->root_item_lock);\n\n\tisize = ALIGN_DOWN(inode->i_size, fs_info->sectorsize);\n\n\tlock_extent(io_tree, 0, isize - 1, &cached_state);\n\tstart = 0;\n\twhile (start < isize) {\n\t\tu64 logical_block_start, physical_block_start;\n\t\tstruct btrfs_block_group *bg;\n\t\tu64 len = isize - start;\n\n\t\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, start, len);\n\t\tif (IS_ERR(em)) {\n\t\t\tret = PTR_ERR(em);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (em->block_start == EXTENT_MAP_HOLE) {\n\t\t\tbtrfs_warn(fs_info, \"swapfile must not have holes\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (em->block_start == EXTENT_MAP_INLINE) {\n\t\t\t \n\t\t\tbtrfs_warn(fs_info, \"swapfile must not be inline\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {\n\t\t\tbtrfs_warn(fs_info, \"swapfile must not be compressed\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlogical_block_start = em->block_start + (start - em->start);\n\t\tlen = min(len, em->len - (start - em->start));\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\n\t\tret = can_nocow_extent(inode, start, &len, NULL, NULL, NULL, false, true);\n\t\tif (ret < 0) {\n\t\t\tgoto out;\n\t\t} else if (ret) {\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t   \"swapfile must not be copy-on-write\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tem = btrfs_get_chunk_map(fs_info, logical_block_start, len);\n\t\tif (IS_ERR(em)) {\n\t\t\tret = PTR_ERR(em);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (em->map_lookup->type & BTRFS_BLOCK_GROUP_PROFILE_MASK) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t   \"swapfile must have single data profile\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (device == NULL) {\n\t\t\tdevice = em->map_lookup->stripes[0].dev;\n\t\t\tret = btrfs_add_swapfile_pin(inode, device, false);\n\t\t\tif (ret == 1)\n\t\t\t\tret = 0;\n\t\t\telse if (ret)\n\t\t\t\tgoto out;\n\t\t} else if (device != em->map_lookup->stripes[0].dev) {\n\t\t\tbtrfs_warn(fs_info, \"swapfile must be on one device\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tphysical_block_start = (em->map_lookup->stripes[0].physical +\n\t\t\t\t\t(logical_block_start - em->start));\n\t\tlen = min(len, em->len - (logical_block_start - em->start));\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\n\t\tbg = btrfs_lookup_block_group(fs_info, logical_block_start);\n\t\tif (!bg) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"could not find block group containing swapfile\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!btrfs_inc_block_group_swap_extents(bg)) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"block group for swapfile at %llu is read-only%s\",\n\t\t\t   bg->start,\n\t\t\t   atomic_read(&fs_info->scrubs_running) ?\n\t\t\t\t       \" (scrub running)\" : \"\");\n\t\t\tbtrfs_put_block_group(bg);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_add_swapfile_pin(inode, bg, true);\n\t\tif (ret) {\n\t\t\tbtrfs_put_block_group(bg);\n\t\t\tif (ret == 1)\n\t\t\t\tret = 0;\n\t\t\telse\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (bsi.block_len &&\n\t\t    bsi.block_start + bsi.block_len == physical_block_start) {\n\t\t\tbsi.block_len += len;\n\t\t} else {\n\t\t\tif (bsi.block_len) {\n\t\t\t\tret = btrfs_add_swap_extent(sis, &bsi);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbsi.start = start;\n\t\t\tbsi.block_start = physical_block_start;\n\t\t\tbsi.block_len = len;\n\t\t}\n\n\t\tstart += len;\n\t}\n\n\tif (bsi.block_len)\n\t\tret = btrfs_add_swap_extent(sis, &bsi);\n\nout:\n\tif (!IS_ERR_OR_NULL(em))\n\t\tfree_extent_map(em);\n\n\tunlock_extent(io_tree, 0, isize - 1, &cached_state);\n\n\tif (ret)\n\t\tbtrfs_swap_deactivate(file);\n\n\tbtrfs_drew_write_unlock(&root->snapshot_lock);\n\n\tbtrfs_exclop_finish(fs_info);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (device)\n\t\tsis->bdev = device->bdev;\n\t*span = bsi.highest_ppage - bsi.lowest_ppage + 1;\n\tsis->max = bsi.nr_pages;\n\tsis->pages = bsi.nr_pages - 1;\n\tsis->highest_bit = bsi.nr_pages - 1;\n\treturn bsi.nr_extents;\n}\n#else\nstatic void btrfs_swap_deactivate(struct file *file)\n{\n}\n\nstatic int btrfs_swap_activate(struct swap_info_struct *sis, struct file *file,\n\t\t\t       sector_t *span)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\n \nvoid btrfs_update_inode_bytes(struct btrfs_inode *inode,\n\t\t\t      const u64 add_bytes,\n\t\t\t      const u64 del_bytes)\n{\n\tif (add_bytes == del_bytes)\n\t\treturn;\n\n\tspin_lock(&inode->lock);\n\tif (del_bytes > 0)\n\t\tinode_sub_bytes(&inode->vfs_inode, del_bytes);\n\tif (add_bytes > 0)\n\t\tinode_add_bytes(&inode->vfs_inode, add_bytes);\n\tspin_unlock(&inode->lock);\n}\n\n \nvoid btrfs_assert_inode_range_clean(struct btrfs_inode *inode, u64 start, u64 end)\n{\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_ordered_extent *ordered;\n\n\tif (!IS_ENABLED(CONFIG_BTRFS_ASSERT))\n\t\treturn;\n\n\tordered = btrfs_lookup_first_ordered_range(inode, start, end + 1 - start);\n\tif (ordered) {\n\t\tbtrfs_err(root->fs_info,\n\"found unexpected ordered extent in file range [%llu, %llu] for inode %llu root %llu (ordered range [%llu, %llu])\",\n\t\t\t  start, end, btrfs_ino(inode), root->root_key.objectid,\n\t\t\t  ordered->file_offset,\n\t\t\t  ordered->file_offset + ordered->num_bytes - 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tASSERT(ordered == NULL);\n}\n\nstatic const struct inode_operations btrfs_dir_inode_operations = {\n\t.getattr\t= btrfs_getattr,\n\t.lookup\t\t= btrfs_lookup,\n\t.create\t\t= btrfs_create,\n\t.unlink\t\t= btrfs_unlink,\n\t.link\t\t= btrfs_link,\n\t.mkdir\t\t= btrfs_mkdir,\n\t.rmdir\t\t= btrfs_rmdir,\n\t.rename\t\t= btrfs_rename2,\n\t.symlink\t= btrfs_symlink,\n\t.setattr\t= btrfs_setattr,\n\t.mknod\t\t= btrfs_mknod,\n\t.listxattr\t= btrfs_listxattr,\n\t.permission\t= btrfs_permission,\n\t.get_inode_acl\t= btrfs_get_acl,\n\t.set_acl\t= btrfs_set_acl,\n\t.update_time\t= btrfs_update_time,\n\t.tmpfile        = btrfs_tmpfile,\n\t.fileattr_get\t= btrfs_fileattr_get,\n\t.fileattr_set\t= btrfs_fileattr_set,\n};\n\nstatic const struct file_operations btrfs_dir_file_operations = {\n\t.llseek\t\t= btrfs_dir_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= btrfs_real_readdir,\n\t.open\t\t= btrfs_opendir,\n\t.unlocked_ioctl\t= btrfs_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= btrfs_compat_ioctl,\n#endif\n\t.release        = btrfs_release_file,\n\t.fsync\t\t= btrfs_sync_file,\n};\n\n \nstatic const struct address_space_operations btrfs_aops = {\n\t.read_folio\t= btrfs_read_folio,\n\t.writepages\t= btrfs_writepages,\n\t.readahead\t= btrfs_readahead,\n\t.invalidate_folio = btrfs_invalidate_folio,\n\t.release_folio\t= btrfs_release_folio,\n\t.migrate_folio\t= btrfs_migrate_folio,\n\t.dirty_folio\t= filemap_dirty_folio,\n\t.error_remove_page = generic_error_remove_page,\n\t.swap_activate\t= btrfs_swap_activate,\n\t.swap_deactivate = btrfs_swap_deactivate,\n};\n\nstatic const struct inode_operations btrfs_file_inode_operations = {\n\t.getattr\t= btrfs_getattr,\n\t.setattr\t= btrfs_setattr,\n\t.listxattr      = btrfs_listxattr,\n\t.permission\t= btrfs_permission,\n\t.fiemap\t\t= btrfs_fiemap,\n\t.get_inode_acl\t= btrfs_get_acl,\n\t.set_acl\t= btrfs_set_acl,\n\t.update_time\t= btrfs_update_time,\n\t.fileattr_get\t= btrfs_fileattr_get,\n\t.fileattr_set\t= btrfs_fileattr_set,\n};\nstatic const struct inode_operations btrfs_special_inode_operations = {\n\t.getattr\t= btrfs_getattr,\n\t.setattr\t= btrfs_setattr,\n\t.permission\t= btrfs_permission,\n\t.listxattr\t= btrfs_listxattr,\n\t.get_inode_acl\t= btrfs_get_acl,\n\t.set_acl\t= btrfs_set_acl,\n\t.update_time\t= btrfs_update_time,\n};\nstatic const struct inode_operations btrfs_symlink_inode_operations = {\n\t.get_link\t= page_get_link,\n\t.getattr\t= btrfs_getattr,\n\t.setattr\t= btrfs_setattr,\n\t.permission\t= btrfs_permission,\n\t.listxattr\t= btrfs_listxattr,\n\t.update_time\t= btrfs_update_time,\n};\n\nconst struct dentry_operations btrfs_dentry_operations = {\n\t.d_delete\t= btrfs_dentry_delete,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}