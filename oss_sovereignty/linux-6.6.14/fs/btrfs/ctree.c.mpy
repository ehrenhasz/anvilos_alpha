{
  "module_name": "ctree.c",
  "hash_id": "dad5c225f455d205a595acc74ab2e5b855c5ccaf865faa1584662e275c8c2593",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/ctree.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/error-injection.h>\n#include \"messages.h\"\n#include \"ctree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"qgroup.h\"\n#include \"tree-mod-log.h\"\n#include \"tree-checker.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n#include \"extent-tree.h\"\n#include \"relocation.h\"\n#include \"file-item.h\"\n\nstatic struct kmem_cache *btrfs_path_cachep;\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic int split_leaf(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      const struct btrfs_key *ins_key, struct btrfs_path *path,\n\t\t      int data_size, int extend);\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic int balance_node_right(struct btrfs_trans_handle *trans,\n\t\t\t      struct extent_buffer *dst_buf,\n\t\t\t      struct extent_buffer *src_buf);\n\nstatic const struct btrfs_csums {\n\tu16\t\tsize;\n\tconst char\tname[10];\n\tconst char\tdriver[12];\n} btrfs_csums[] = {\n\t[BTRFS_CSUM_TYPE_CRC32] = { .size = 4, .name = \"crc32c\" },\n\t[BTRFS_CSUM_TYPE_XXHASH] = { .size = 8, .name = \"xxhash64\" },\n\t[BTRFS_CSUM_TYPE_SHA256] = { .size = 32, .name = \"sha256\" },\n\t[BTRFS_CSUM_TYPE_BLAKE2] = { .size = 32, .name = \"blake2b\",\n\t\t\t\t     .driver = \"blake2b-256\" },\n};\n\n \nstatic unsigned int leaf_data_end(const struct extent_buffer *leaf)\n{\n\tu32 nr = btrfs_header_nritems(leaf);\n\n\tif (nr == 0)\n\t\treturn BTRFS_LEAF_DATA_SIZE(leaf->fs_info);\n\treturn btrfs_item_offset(leaf, nr - 1);\n}\n\n \nstatic inline void memmove_leaf_data(const struct extent_buffer *leaf,\n\t\t\t\t     unsigned long dst_offset,\n\t\t\t\t     unsigned long src_offset,\n\t\t\t\t     unsigned long len)\n{\n\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(leaf, 0) + dst_offset,\n\t\t\t      btrfs_item_nr_offset(leaf, 0) + src_offset, len);\n}\n\n \nstatic inline void copy_leaf_data(const struct extent_buffer *dst,\n\t\t\t\t  const struct extent_buffer *src,\n\t\t\t\t  unsigned long dst_offset,\n\t\t\t\t  unsigned long src_offset, unsigned long len)\n{\n\tcopy_extent_buffer(dst, src, btrfs_item_nr_offset(dst, 0) + dst_offset,\n\t\t\t   btrfs_item_nr_offset(src, 0) + src_offset, len);\n}\n\n \nstatic inline void memmove_leaf_items(const struct extent_buffer *leaf,\n\t\t\t\t      int dst_item, int src_item, int nr_items)\n{\n\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(leaf, dst_item),\n\t\t\t      btrfs_item_nr_offset(leaf, src_item),\n\t\t\t      nr_items * sizeof(struct btrfs_item));\n}\n\n \nstatic inline void copy_leaf_items(const struct extent_buffer *dst,\n\t\t\t\t   const struct extent_buffer *src,\n\t\t\t\t   int dst_item, int src_item, int nr_items)\n{\n\tcopy_extent_buffer(dst, src, btrfs_item_nr_offset(dst, dst_item),\n\t\t\t      btrfs_item_nr_offset(src, src_item),\n\t\t\t      nr_items * sizeof(struct btrfs_item));\n}\n\n \nu16 btrfs_csum_type_size(u16 type)\n{\n\treturn btrfs_csums[type].size;\n}\n\nint btrfs_super_csum_size(const struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t \n\treturn btrfs_csum_type_size(t);\n}\n\nconst char *btrfs_super_csum_name(u16 csum_type)\n{\n\t \n\treturn btrfs_csums[csum_type].name;\n}\n\n \nconst char *btrfs_super_csum_driver(u16 csum_type)\n{\n\t \n\treturn btrfs_csums[csum_type].driver[0] ?\n\t\tbtrfs_csums[csum_type].driver :\n\t\tbtrfs_csums[csum_type].name;\n}\n\nsize_t __attribute_const__ btrfs_get_num_csums(void)\n{\n\treturn ARRAY_SIZE(btrfs_csums);\n}\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tmight_sleep();\n\n\treturn kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n}\n\n \nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}\n\n \nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}\n\n \nbool __cold abort_should_print_stack(int errno)\n{\n\tswitch (errno) {\n\tcase -EIO:\n\tcase -EROFS:\n\tcase -ENOMEM:\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstruct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t \n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}\n\n \nstatic void add_root_to_dirty_list(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (test_bit(BTRFS_ROOT_DIRTY, &root->state) ||\n\t    !test_bit(BTRFS_ROOT_TRACK_DIRTY, &root->state))\n\t\treturn;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (!test_and_set_bit(BTRFS_ROOT_DIRTY, &root->state)) {\n\t\t \n\t\tif (root->root_key.objectid == BTRFS_EXTENT_TREE_OBJECTID)\n\t\t\tlist_move_tail(&root->dirty_list,\n\t\t\t\t       &fs_info->dirty_cowonly_roots);\n\t\telse\n\t\t\tlist_move(&root->dirty_list,\n\t\t\t\t  &fs_info->dirty_cowonly_roots);\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n}\n\n \nint btrfs_copy_root(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_root *root,\n\t\t      struct extent_buffer *buf,\n\t\t      struct extent_buffer **cow_ret, u64 new_root_objectid)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct extent_buffer *cow;\n\tint ret = 0;\n\tint level;\n\tstruct btrfs_disk_key disk_key;\n\n\tWARN_ON(test_bit(BTRFS_ROOT_SHAREABLE, &root->state) &&\n\t\ttrans->transid != fs_info->running_transaction->transid);\n\tWARN_ON(test_bit(BTRFS_ROOT_SHAREABLE, &root->state) &&\n\t\ttrans->transid != root->last_trans);\n\n\tlevel = btrfs_header_level(buf);\n\tif (level == 0)\n\t\tbtrfs_item_key(buf, &disk_key, 0);\n\telse\n\t\tbtrfs_node_key(buf, &disk_key, 0);\n\n\tcow = btrfs_alloc_tree_block(trans, root, 0, new_root_objectid,\n\t\t\t\t     &disk_key, level, buf->start, 0,\n\t\t\t\t     BTRFS_NESTING_NEW_ROOT);\n\tif (IS_ERR(cow))\n\t\treturn PTR_ERR(cow);\n\n\tcopy_extent_buffer_full(cow, buf);\n\tbtrfs_set_header_bytenr(cow, cow->start);\n\tbtrfs_set_header_generation(cow, trans->transid);\n\tbtrfs_set_header_backref_rev(cow, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_clear_header_flag(cow, BTRFS_HEADER_FLAG_WRITTEN |\n\t\t\t\t     BTRFS_HEADER_FLAG_RELOC);\n\tif (new_root_objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tbtrfs_set_header_flag(cow, BTRFS_HEADER_FLAG_RELOC);\n\telse\n\t\tbtrfs_set_header_owner(cow, new_root_objectid);\n\n\twrite_extent_buffer_fsid(cow, fs_info->fs_devices->metadata_uuid);\n\n\tWARN_ON(btrfs_header_generation(buf) > trans->transid);\n\tif (new_root_objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\telse\n\t\tret = btrfs_inc_ref(trans, root, cow, 0);\n\tif (ret) {\n\t\tbtrfs_tree_unlock(cow);\n\t\tfree_extent_buffer(cow);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\treturn ret;\n\t}\n\n\tbtrfs_mark_buffer_dirty(trans, cow);\n\t*cow_ret = cow;\n\treturn 0;\n}\n\n \nint btrfs_block_can_be_shared(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root,\n\t\t\t      struct extent_buffer *buf)\n{\n\t \n\tif (test_bit(BTRFS_ROOT_SHAREABLE, &root->state) &&\n\t    buf != root->node &&\n\t    (btrfs_header_generation(buf) <=\n\t     btrfs_root_last_snapshot(&root->root_item) ||\n\t     btrfs_header_flag(buf, BTRFS_HEADER_FLAG_RELOC))) {\n\t\tif (buf != root->commit_root)\n\t\t\treturn 1;\n\t\t \n\t\tif (btrfs_header_generation(buf) == trans->transid)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic noinline int update_ref_for_cow(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct extent_buffer *buf,\n\t\t\t\t       struct extent_buffer *cow,\n\t\t\t\t       int *last_ref)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 refs;\n\tu64 owner;\n\tu64 flags;\n\tu64 new_flags = 0;\n\tint ret;\n\n\t \n\n\tif (btrfs_block_can_be_shared(trans, root, buf)) {\n\t\tret = btrfs_lookup_extent_info(trans, fs_info, buf->start,\n\t\t\t\t\t       btrfs_header_level(buf), 1,\n\t\t\t\t\t       &refs, &flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (unlikely(refs == 0)) {\n\t\t\tbtrfs_crit(fs_info,\n\t\t\"found 0 references for tree block at bytenr %llu level %d root %llu\",\n\t\t\t\t   buf->start, btrfs_header_level(buf),\n\t\t\t\t   btrfs_root_id(root));\n\t\t\tret = -EUCLEAN;\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\trefs = 1;\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    btrfs_header_backref_rev(buf) < BTRFS_MIXED_BACKREF_REV)\n\t\t\tflags = BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t\telse\n\t\t\tflags = 0;\n\t}\n\n\towner = btrfs_header_owner(buf);\n\tBUG_ON(owner == BTRFS_TREE_RELOC_OBJECTID &&\n\t       !(flags & BTRFS_BLOCK_FLAG_FULL_BACKREF));\n\n\tif (refs > 1) {\n\t\tif ((owner == root->root_key.objectid ||\n\t\t     root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) &&\n\t\t    !(flags & BTRFS_BLOCK_FLAG_FULL_BACKREF)) {\n\t\t\tret = btrfs_inc_ref(trans, root, buf, 1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (root->root_key.objectid ==\n\t\t\t    BTRFS_TREE_RELOC_OBJECTID) {\n\t\t\t\tret = btrfs_dec_ref(trans, root, buf, 0);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tnew_flags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t\t} else {\n\n\t\t\tif (root->root_key.objectid ==\n\t\t\t    BTRFS_TREE_RELOC_OBJECTID)\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\t\t\telse\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (new_flags != 0) {\n\t\t\tret = btrfs_set_disk_extent_flags(trans, buf, new_flags);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tif (flags & BTRFS_BLOCK_FLAG_FULL_BACKREF) {\n\t\t\tif (root->root_key.objectid ==\n\t\t\t    BTRFS_TREE_RELOC_OBJECTID)\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\t\t\telse\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tret = btrfs_dec_ref(trans, root, buf, 1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbtrfs_clear_buffer_dirty(trans, buf);\n\t\t*last_ref = 1;\n\t}\n\treturn 0;\n}\n\n \nstatic noinline int __btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct extent_buffer *buf,\n\t\t\t     struct extent_buffer *parent, int parent_slot,\n\t\t\t     struct extent_buffer **cow_ret,\n\t\t\t     u64 search_start, u64 empty_size,\n\t\t\t     enum btrfs_lock_nesting nest)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *cow;\n\tint level, ret;\n\tint last_ref = 0;\n\tint unlock_orig = 0;\n\tu64 parent_start = 0;\n\n\tif (*cow_ret == buf)\n\t\tunlock_orig = 1;\n\n\tbtrfs_assert_tree_write_locked(buf);\n\n\tWARN_ON(test_bit(BTRFS_ROOT_SHAREABLE, &root->state) &&\n\t\ttrans->transid != fs_info->running_transaction->transid);\n\tWARN_ON(test_bit(BTRFS_ROOT_SHAREABLE, &root->state) &&\n\t\ttrans->transid != root->last_trans);\n\n\tlevel = btrfs_header_level(buf);\n\n\tif (level == 0)\n\t\tbtrfs_item_key(buf, &disk_key, 0);\n\telse\n\t\tbtrfs_node_key(buf, &disk_key, 0);\n\n\tif ((root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) && parent)\n\t\tparent_start = parent->start;\n\n\tcow = btrfs_alloc_tree_block(trans, root, parent_start,\n\t\t\t\t     root->root_key.objectid, &disk_key, level,\n\t\t\t\t     search_start, empty_size, nest);\n\tif (IS_ERR(cow))\n\t\treturn PTR_ERR(cow);\n\n\t \n\n\tcopy_extent_buffer_full(cow, buf);\n\tbtrfs_set_header_bytenr(cow, cow->start);\n\tbtrfs_set_header_generation(cow, trans->transid);\n\tbtrfs_set_header_backref_rev(cow, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_clear_header_flag(cow, BTRFS_HEADER_FLAG_WRITTEN |\n\t\t\t\t     BTRFS_HEADER_FLAG_RELOC);\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tbtrfs_set_header_flag(cow, BTRFS_HEADER_FLAG_RELOC);\n\telse\n\t\tbtrfs_set_header_owner(cow, root->root_key.objectid);\n\n\twrite_extent_buffer_fsid(cow, fs_info->fs_devices->metadata_uuid);\n\n\tret = update_ref_for_cow(trans, root, buf, cow, &last_ref);\n\tif (ret) {\n\t\tbtrfs_tree_unlock(cow);\n\t\tfree_extent_buffer(cow);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\treturn ret;\n\t}\n\n\tif (test_bit(BTRFS_ROOT_SHAREABLE, &root->state)) {\n\t\tret = btrfs_reloc_cow_block(trans, root, buf, cow);\n\t\tif (ret) {\n\t\t\tbtrfs_tree_unlock(cow);\n\t\t\tfree_extent_buffer(cow);\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (buf == root->node) {\n\t\tWARN_ON(parent && parent != buf);\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    btrfs_header_backref_rev(buf) < BTRFS_MIXED_BACKREF_REV)\n\t\t\tparent_start = buf->start;\n\n\t\tret = btrfs_tree_mod_log_insert_root(root->node, cow, true);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_tree_unlock(cow);\n\t\t\tfree_extent_buffer(cow);\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tatomic_inc(&cow->refs);\n\t\trcu_assign_pointer(root->node, cow);\n\n\t\tbtrfs_free_tree_block(trans, btrfs_root_id(root), buf,\n\t\t\t\t      parent_start, last_ref);\n\t\tfree_extent_buffer(buf);\n\t\tadd_root_to_dirty_list(root);\n\t} else {\n\t\tWARN_ON(trans->transid != btrfs_header_generation(parent));\n\t\tret = btrfs_tree_mod_log_insert_key(parent, parent_slot,\n\t\t\t\t\t\t    BTRFS_MOD_LOG_KEY_REPLACE);\n\t\tif (ret) {\n\t\t\tbtrfs_tree_unlock(cow);\n\t\t\tfree_extent_buffer(cow);\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbtrfs_set_node_blockptr(parent, parent_slot,\n\t\t\t\t\tcow->start);\n\t\tbtrfs_set_node_ptr_generation(parent, parent_slot,\n\t\t\t\t\t      trans->transid);\n\t\tbtrfs_mark_buffer_dirty(trans, parent);\n\t\tif (last_ref) {\n\t\t\tret = btrfs_tree_mod_log_free_eb(buf);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_tree_unlock(cow);\n\t\t\t\tfree_extent_buffer(cow);\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbtrfs_free_tree_block(trans, btrfs_root_id(root), buf,\n\t\t\t\t      parent_start, last_ref);\n\t}\n\tif (unlock_orig)\n\t\tbtrfs_tree_unlock(buf);\n\tfree_extent_buffer_stale(buf);\n\tbtrfs_mark_buffer_dirty(trans, cow);\n\t*cow_ret = cow;\n\treturn 0;\n}\n\nstatic inline int should_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *buf)\n{\n\tif (btrfs_is_testing(root->fs_info))\n\t\treturn 0;\n\n\t \n\tsmp_mb__before_atomic();\n\n\t \n\tif (btrfs_header_generation(buf) == trans->transid &&\n\t    !btrfs_header_flag(buf, BTRFS_HEADER_FLAG_WRITTEN) &&\n\t    !(root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID &&\n\t      btrfs_header_flag(buf, BTRFS_HEADER_FLAG_RELOC)) &&\n\t    !test_bit(BTRFS_ROOT_FORCE_COW, &root->state))\n\t\treturn 0;\n\treturn 1;\n}\n\n \nnoinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret,\n\t\t    enum btrfs_lock_nesting nest)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 search_start;\n\tint ret;\n\n\tif (unlikely(test_bit(BTRFS_ROOT_DELETING, &root->state))) {\n\t\tbtrfs_abort_transaction(trans, -EUCLEAN);\n\t\tbtrfs_crit(fs_info,\n\t\t   \"attempt to COW block %llu on root %llu that is being deleted\",\n\t\t\t   buf->start, btrfs_root_id(root));\n\t\treturn -EUCLEAN;\n\t}\n\n\t \n\tif (unlikely(trans->transaction != fs_info->running_transaction ||\n\t\t     trans->transid != fs_info->generation)) {\n\t\tbtrfs_abort_transaction(trans, -EUCLEAN);\n\t\tbtrfs_crit(fs_info,\n\"unexpected transaction when attempting to COW block %llu on root %llu, transaction %llu running transaction %llu fs generation %llu\",\n\t\t\t   buf->start, btrfs_root_id(root), trans->transid,\n\t\t\t   fs_info->running_transaction->transid,\n\t\t\t   fs_info->generation);\n\t\treturn -EUCLEAN;\n\t}\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)SZ_1G - 1);\n\n\t \n\tbtrfs_qgroup_trace_subtree_after_cow(trans, root, buf);\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0, nest);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}\nALLOW_ERROR_INJECTION(btrfs_cow_block, ERRNO);\n\n \nstatic int close_blocks(u64 blocknr, u64 other, u32 blocksize)\n{\n\tif (blocknr < other && other - (blocknr + blocksize) < 32768)\n\t\treturn 1;\n\tif (blocknr > other && blocknr - (other + blocksize) < 32768)\n\t\treturn 1;\n\treturn 0;\n}\n\n#ifdef __LITTLE_ENDIAN\n\n \nstatic int comp_keys(const struct btrfs_disk_key *disk_key,\n\t\t     const struct btrfs_key *k2)\n{\n\tconst struct btrfs_key *k1 = (const struct btrfs_key *)disk_key;\n\n\treturn btrfs_comp_cpu_keys(k1, k2);\n}\n\n#else\n\n \nstatic int comp_keys(const struct btrfs_disk_key *disk,\n\t\t     const struct btrfs_key *k2)\n{\n\tstruct btrfs_key k1;\n\n\tbtrfs_disk_key_to_cpu(&k1, disk);\n\n\treturn btrfs_comp_cpu_keys(&k1, k2);\n}\n#endif\n\n \nint __pure btrfs_comp_cpu_keys(const struct btrfs_key *k1, const struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}\n\n \nint btrfs_realloc_node(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct extent_buffer *parent,\n\t\t       int start_slot, u64 *last_ret,\n\t\t       struct btrfs_key *progress)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct extent_buffer *cur;\n\tu64 blocknr;\n\tu64 search_start = *last_ret;\n\tu64 last_block = 0;\n\tu64 other;\n\tu32 parent_nritems;\n\tint end_slot;\n\tint i;\n\tint err = 0;\n\tu32 blocksize;\n\tint progress_passed = 0;\n\tstruct btrfs_disk_key disk_key;\n\n\t \n\tif (unlikely(trans->transaction != fs_info->running_transaction ||\n\t\t     trans->transid != fs_info->generation)) {\n\t\tbtrfs_abort_transaction(trans, -EUCLEAN);\n\t\tbtrfs_crit(fs_info,\n\"unexpected transaction when attempting to reallocate parent %llu for root %llu, transaction %llu running transaction %llu fs generation %llu\",\n\t\t\t   parent->start, btrfs_root_id(root), trans->transid,\n\t\t\t   fs_info->running_transaction->transid,\n\t\t\t   fs_info->generation);\n\t\treturn -EUCLEAN;\n\t}\n\n\tparent_nritems = btrfs_header_nritems(parent);\n\tblocksize = fs_info->nodesize;\n\tend_slot = parent_nritems - 1;\n\n\tif (parent_nritems <= 1)\n\t\treturn 0;\n\n\tfor (i = start_slot; i <= end_slot; i++) {\n\t\tint close = 1;\n\n\t\tbtrfs_node_key(parent, &disk_key, i);\n\t\tif (!progress_passed && comp_keys(&disk_key, progress) < 0)\n\t\t\tcontinue;\n\n\t\tprogress_passed = 1;\n\t\tblocknr = btrfs_node_blockptr(parent, i);\n\t\tif (last_block == 0)\n\t\t\tlast_block = blocknr;\n\n\t\tif (i > 0) {\n\t\t\tother = btrfs_node_blockptr(parent, i - 1);\n\t\t\tclose = close_blocks(blocknr, other, blocksize);\n\t\t}\n\t\tif (!close && i < end_slot) {\n\t\t\tother = btrfs_node_blockptr(parent, i + 1);\n\t\t\tclose = close_blocks(blocknr, other, blocksize);\n\t\t}\n\t\tif (close) {\n\t\t\tlast_block = blocknr;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcur = btrfs_read_node_slot(parent, i);\n\t\tif (IS_ERR(cur))\n\t\t\treturn PTR_ERR(cur);\n\t\tif (search_start == 0)\n\t\t\tsearch_start = last_block;\n\n\t\tbtrfs_tree_lock(cur);\n\t\terr = __btrfs_cow_block(trans, root, cur, parent, i,\n\t\t\t\t\t&cur, search_start,\n\t\t\t\t\tmin(16 * blocksize,\n\t\t\t\t\t    (end_slot - i) * blocksize),\n\t\t\t\t\tBTRFS_NESTING_COW);\n\t\tif (err) {\n\t\t\tbtrfs_tree_unlock(cur);\n\t\t\tfree_extent_buffer(cur);\n\t\t\tbreak;\n\t\t}\n\t\tsearch_start = cur->start;\n\t\tlast_block = cur->start;\n\t\t*last_ret = search_start;\n\t\tbtrfs_tree_unlock(cur);\n\t\tfree_extent_buffer(cur);\n\t}\n\treturn err;\n}\n\n \nint btrfs_bin_search(struct extent_buffer *eb, int first_slot,\n\t\t     const struct btrfs_key *key, int *slot)\n{\n\tunsigned long p;\n\tint item_size;\n\t \n\tu32 low = first_slot;\n\tu32 high = btrfs_header_nritems(eb);\n\tint ret;\n\tconst int key_size = sizeof(struct btrfs_disk_key);\n\n\tif (unlikely(low > high)) {\n\t\tbtrfs_err(eb->fs_info,\n\t\t \"%s: low (%u) > high (%u) eb %llu owner %llu level %d\",\n\t\t\t  __func__, low, high, eb->start,\n\t\t\t  btrfs_header_owner(eb), btrfs_header_level(eb));\n\t\treturn -EINVAL;\n\t}\n\n\tif (btrfs_header_level(eb) == 0) {\n\t\tp = offsetof(struct btrfs_leaf, items);\n\t\titem_size = sizeof(struct btrfs_item);\n\t} else {\n\t\tp = offsetof(struct btrfs_node, ptrs);\n\t\titem_size = sizeof(struct btrfs_key_ptr);\n\t}\n\n\twhile (low < high) {\n\t\tunsigned long oip;\n\t\tunsigned long offset;\n\t\tstruct btrfs_disk_key *tmp;\n\t\tstruct btrfs_disk_key unaligned;\n\t\tint mid;\n\n\t\tmid = (low + high) / 2;\n\t\toffset = p + mid * item_size;\n\t\toip = offset_in_page(offset);\n\n\t\tif (oip + key_size <= PAGE_SIZE) {\n\t\t\tconst unsigned long idx = get_eb_page_index(offset);\n\t\t\tchar *kaddr = page_address(eb->pages[idx]);\n\n\t\t\toip = get_eb_offset_in_page(eb, offset);\n\t\t\ttmp = (struct btrfs_disk_key *)(kaddr + oip);\n\t\t} else {\n\t\t\tread_extent_buffer(eb, &unaligned, offset, key_size);\n\t\t\ttmp = &unaligned;\n\t\t}\n\n\t\tret = comp_keys(tmp, key);\n\n\t\tif (ret < 0)\n\t\t\tlow = mid + 1;\n\t\telse if (ret > 0)\n\t\t\thigh = mid;\n\t\telse {\n\t\t\t*slot = mid;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*slot = low;\n\treturn 1;\n}\n\nstatic void root_add_used(struct btrfs_root *root, u32 size)\n{\n\tspin_lock(&root->accounting_lock);\n\tbtrfs_set_root_used(&root->root_item,\n\t\t\t    btrfs_root_used(&root->root_item) + size);\n\tspin_unlock(&root->accounting_lock);\n}\n\nstatic void root_sub_used(struct btrfs_root *root, u32 size)\n{\n\tspin_lock(&root->accounting_lock);\n\tbtrfs_set_root_used(&root->root_item,\n\t\t\t    btrfs_root_used(&root->root_item) - size);\n\tspin_unlock(&root->accounting_lock);\n}\n\n \nstruct extent_buffer *btrfs_read_node_slot(struct extent_buffer *parent,\n\t\t\t\t\t   int slot)\n{\n\tint level = btrfs_header_level(parent);\n\tstruct btrfs_tree_parent_check check = { 0 };\n\tstruct extent_buffer *eb;\n\n\tif (slot < 0 || slot >= btrfs_header_nritems(parent))\n\t\treturn ERR_PTR(-ENOENT);\n\n\tASSERT(level);\n\n\tcheck.level = level - 1;\n\tcheck.transid = btrfs_node_ptr_generation(parent, slot);\n\tcheck.owner_root = btrfs_header_owner(parent);\n\tcheck.has_first_key = true;\n\tbtrfs_node_key_to_cpu(parent, &check.first_key, slot);\n\n\teb = read_tree_block(parent->fs_info, btrfs_node_blockptr(parent, slot),\n\t\t\t     &check);\n\tif (IS_ERR(eb))\n\t\treturn eb;\n\tif (!extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn eb;\n}\n\n \nstatic noinline int balance_level(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t struct btrfs_path *path, int level)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct extent_buffer *right = NULL;\n\tstruct extent_buffer *mid;\n\tstruct extent_buffer *left = NULL;\n\tstruct extent_buffer *parent = NULL;\n\tint ret = 0;\n\tint wret;\n\tint pslot;\n\tint orig_slot = path->slots[level];\n\tu64 orig_ptr;\n\n\tASSERT(level > 0);\n\n\tmid = path->nodes[level];\n\n\tWARN_ON(path->locks[level] != BTRFS_WRITE_LOCK);\n\tWARN_ON(btrfs_header_generation(mid) != trans->transid);\n\n\torig_ptr = btrfs_node_blockptr(mid, orig_slot);\n\n\tif (level < BTRFS_MAX_LEVEL - 1) {\n\t\tparent = path->nodes[level + 1];\n\t\tpslot = path->slots[level + 1];\n\t}\n\n\t \n\tif (!parent) {\n\t\tstruct extent_buffer *child;\n\n\t\tif (btrfs_header_nritems(mid) != 1)\n\t\t\treturn 0;\n\n\t\t \n\t\tchild = btrfs_read_node_slot(mid, 0);\n\t\tif (IS_ERR(child)) {\n\t\t\tret = PTR_ERR(child);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbtrfs_tree_lock(child);\n\t\tret = btrfs_cow_block(trans, root, child, mid, 0, &child,\n\t\t\t\t      BTRFS_NESTING_COW);\n\t\tif (ret) {\n\t\t\tbtrfs_tree_unlock(child);\n\t\t\tfree_extent_buffer(child);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_tree_mod_log_insert_root(root->node, child, true);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_tree_unlock(child);\n\t\t\tfree_extent_buffer(child);\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out;\n\t\t}\n\t\trcu_assign_pointer(root->node, child);\n\n\t\tadd_root_to_dirty_list(root);\n\t\tbtrfs_tree_unlock(child);\n\n\t\tpath->locks[level] = 0;\n\t\tpath->nodes[level] = NULL;\n\t\tbtrfs_clear_buffer_dirty(trans, mid);\n\t\tbtrfs_tree_unlock(mid);\n\t\t \n\t\tfree_extent_buffer(mid);\n\n\t\troot_sub_used(root, mid->len);\n\t\tbtrfs_free_tree_block(trans, btrfs_root_id(root), mid, 0, 1);\n\t\t \n\t\tfree_extent_buffer_stale(mid);\n\t\treturn 0;\n\t}\n\tif (btrfs_header_nritems(mid) >\n\t    BTRFS_NODEPTRS_PER_BLOCK(fs_info) / 4)\n\t\treturn 0;\n\n\tif (pslot) {\n\t\tleft = btrfs_read_node_slot(parent, pslot - 1);\n\t\tif (IS_ERR(left)) {\n\t\t\tret = PTR_ERR(left);\n\t\t\tleft = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t__btrfs_tree_lock(left, BTRFS_NESTING_LEFT);\n\t\twret = btrfs_cow_block(trans, root, left,\n\t\t\t\t       parent, pslot - 1, &left,\n\t\t\t\t       BTRFS_NESTING_LEFT_COW);\n\t\tif (wret) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (pslot + 1 < btrfs_header_nritems(parent)) {\n\t\tright = btrfs_read_node_slot(parent, pslot + 1);\n\t\tif (IS_ERR(right)) {\n\t\t\tret = PTR_ERR(right);\n\t\t\tright = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t__btrfs_tree_lock(right, BTRFS_NESTING_RIGHT);\n\t\twret = btrfs_cow_block(trans, root, right,\n\t\t\t\t       parent, pslot + 1, &right,\n\t\t\t\t       BTRFS_NESTING_RIGHT_COW);\n\t\tif (wret) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (left) {\n\t\torig_slot += btrfs_header_nritems(left);\n\t\twret = push_node_left(trans, left, mid, 1);\n\t\tif (wret < 0)\n\t\t\tret = wret;\n\t}\n\n\t \n\tif (right) {\n\t\twret = push_node_left(trans, mid, right, 1);\n\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\tret = wret;\n\t\tif (btrfs_header_nritems(right) == 0) {\n\t\t\tbtrfs_clear_buffer_dirty(trans, right);\n\t\t\tbtrfs_tree_unlock(right);\n\t\t\tret = btrfs_del_ptr(trans, root, path, level + 1, pslot + 1);\n\t\t\tif (ret < 0) {\n\t\t\t\tfree_extent_buffer_stale(right);\n\t\t\t\tright = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\troot_sub_used(root, right->len);\n\t\t\tbtrfs_free_tree_block(trans, btrfs_root_id(root), right,\n\t\t\t\t\t      0, 1);\n\t\t\tfree_extent_buffer_stale(right);\n\t\t\tright = NULL;\n\t\t} else {\n\t\t\tstruct btrfs_disk_key right_key;\n\t\t\tbtrfs_node_key(right, &right_key, 0);\n\t\t\tret = btrfs_tree_mod_log_insert_key(parent, pslot + 1,\n\t\t\t\t\tBTRFS_MOD_LOG_KEY_REPLACE);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_set_node_key(parent, &right_key, pslot + 1);\n\t\t\tbtrfs_mark_buffer_dirty(trans, parent);\n\t\t}\n\t}\n\tif (btrfs_header_nritems(mid) == 1) {\n\t\t \n\t\tif (unlikely(!left)) {\n\t\t\tbtrfs_crit(fs_info,\n\"missing left child when middle child only has 1 item, parent bytenr %llu level %d mid bytenr %llu root %llu\",\n\t\t\t\t   parent->start, btrfs_header_level(parent),\n\t\t\t\t   mid->start, btrfs_root_id(root));\n\t\t\tret = -EUCLEAN;\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out;\n\t\t}\n\t\twret = balance_node_right(trans, mid, left);\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\t\tif (wret == 1) {\n\t\t\twret = push_node_left(trans, left, mid, 1);\n\t\t\tif (wret < 0)\n\t\t\t\tret = wret;\n\t\t}\n\t\tBUG_ON(wret == 1);\n\t}\n\tif (btrfs_header_nritems(mid) == 0) {\n\t\tbtrfs_clear_buffer_dirty(trans, mid);\n\t\tbtrfs_tree_unlock(mid);\n\t\tret = btrfs_del_ptr(trans, root, path, level + 1, pslot);\n\t\tif (ret < 0) {\n\t\t\tfree_extent_buffer_stale(mid);\n\t\t\tmid = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\troot_sub_used(root, mid->len);\n\t\tbtrfs_free_tree_block(trans, btrfs_root_id(root), mid, 0, 1);\n\t\tfree_extent_buffer_stale(mid);\n\t\tmid = NULL;\n\t} else {\n\t\t \n\t\tstruct btrfs_disk_key mid_key;\n\t\tbtrfs_node_key(mid, &mid_key, 0);\n\t\tret = btrfs_tree_mod_log_insert_key(parent, pslot,\n\t\t\t\t\t\t    BTRFS_MOD_LOG_KEY_REPLACE);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_set_node_key(parent, &mid_key, pslot);\n\t\tbtrfs_mark_buffer_dirty(trans, parent);\n\t}\n\n\t \n\tif (left) {\n\t\tif (btrfs_header_nritems(left) > orig_slot) {\n\t\t\tatomic_inc(&left->refs);\n\t\t\t \n\t\t\tpath->nodes[level] = left;\n\t\t\tpath->slots[level + 1] -= 1;\n\t\t\tpath->slots[level] = orig_slot;\n\t\t\tif (mid) {\n\t\t\t\tbtrfs_tree_unlock(mid);\n\t\t\t\tfree_extent_buffer(mid);\n\t\t\t}\n\t\t} else {\n\t\t\torig_slot -= btrfs_header_nritems(left);\n\t\t\tpath->slots[level] = orig_slot;\n\t\t}\n\t}\n\t \n\tif (orig_ptr !=\n\t    btrfs_node_blockptr(path->nodes[level], path->slots[level]))\n\t\tBUG();\nout:\n\tif (right) {\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\tif (left) {\n\t\tif (path->nodes[level] != left)\n\t\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t}\n\treturn ret;\n}\n\n \nstatic noinline int push_nodes_for_insert(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path, int level)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct extent_buffer *right = NULL;\n\tstruct extent_buffer *mid;\n\tstruct extent_buffer *left = NULL;\n\tstruct extent_buffer *parent = NULL;\n\tint ret = 0;\n\tint wret;\n\tint pslot;\n\tint orig_slot = path->slots[level];\n\n\tif (level == 0)\n\t\treturn 1;\n\n\tmid = path->nodes[level];\n\tWARN_ON(btrfs_header_generation(mid) != trans->transid);\n\n\tif (level < BTRFS_MAX_LEVEL - 1) {\n\t\tparent = path->nodes[level + 1];\n\t\tpslot = path->slots[level + 1];\n\t}\n\n\tif (!parent)\n\t\treturn 1;\n\n\t \n\tif (pslot) {\n\t\tu32 left_nr;\n\n\t\tleft = btrfs_read_node_slot(parent, pslot - 1);\n\t\tif (IS_ERR(left))\n\t\t\treturn PTR_ERR(left);\n\n\t\t__btrfs_tree_lock(left, BTRFS_NESTING_LEFT);\n\n\t\tleft_nr = btrfs_header_nritems(left);\n\t\tif (left_nr >= BTRFS_NODEPTRS_PER_BLOCK(fs_info) - 1) {\n\t\t\twret = 1;\n\t\t} else {\n\t\t\tret = btrfs_cow_block(trans, root, left, parent,\n\t\t\t\t\t      pslot - 1, &left,\n\t\t\t\t\t      BTRFS_NESTING_LEFT_COW);\n\t\t\tif (ret)\n\t\t\t\twret = 1;\n\t\t\telse {\n\t\t\t\twret = push_node_left(trans, left, mid, 0);\n\t\t\t}\n\t\t}\n\t\tif (wret < 0)\n\t\t\tret = wret;\n\t\tif (wret == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\t\t\torig_slot += left_nr;\n\t\t\tbtrfs_node_key(mid, &disk_key, 0);\n\t\t\tret = btrfs_tree_mod_log_insert_key(parent, pslot,\n\t\t\t\t\tBTRFS_MOD_LOG_KEY_REPLACE);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_tree_unlock(left);\n\t\t\t\tfree_extent_buffer(left);\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbtrfs_set_node_key(parent, &disk_key, pslot);\n\t\t\tbtrfs_mark_buffer_dirty(trans, parent);\n\t\t\tif (btrfs_header_nritems(left) > orig_slot) {\n\t\t\t\tpath->nodes[level] = left;\n\t\t\t\tpath->slots[level + 1] -= 1;\n\t\t\t\tpath->slots[level] = orig_slot;\n\t\t\t\tbtrfs_tree_unlock(mid);\n\t\t\t\tfree_extent_buffer(mid);\n\t\t\t} else {\n\t\t\t\torig_slot -=\n\t\t\t\t\tbtrfs_header_nritems(left);\n\t\t\t\tpath->slots[level] = orig_slot;\n\t\t\t\tbtrfs_tree_unlock(left);\n\t\t\t\tfree_extent_buffer(left);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t}\n\n\t \n\tif (pslot + 1 < btrfs_header_nritems(parent)) {\n\t\tu32 right_nr;\n\n\t\tright = btrfs_read_node_slot(parent, pslot + 1);\n\t\tif (IS_ERR(right))\n\t\t\treturn PTR_ERR(right);\n\n\t\t__btrfs_tree_lock(right, BTRFS_NESTING_RIGHT);\n\n\t\tright_nr = btrfs_header_nritems(right);\n\t\tif (right_nr >= BTRFS_NODEPTRS_PER_BLOCK(fs_info) - 1) {\n\t\t\twret = 1;\n\t\t} else {\n\t\t\tret = btrfs_cow_block(trans, root, right,\n\t\t\t\t\t      parent, pslot + 1,\n\t\t\t\t\t      &right, BTRFS_NESTING_RIGHT_COW);\n\t\t\tif (ret)\n\t\t\t\twret = 1;\n\t\t\telse {\n\t\t\t\twret = balance_node_right(trans, right, mid);\n\t\t\t}\n\t\t}\n\t\tif (wret < 0)\n\t\t\tret = wret;\n\t\tif (wret == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\n\t\t\tbtrfs_node_key(right, &disk_key, 0);\n\t\t\tret = btrfs_tree_mod_log_insert_key(parent, pslot + 1,\n\t\t\t\t\tBTRFS_MOD_LOG_KEY_REPLACE);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_tree_unlock(right);\n\t\t\t\tfree_extent_buffer(right);\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbtrfs_set_node_key(parent, &disk_key, pslot + 1);\n\t\t\tbtrfs_mark_buffer_dirty(trans, parent);\n\n\t\t\tif (btrfs_header_nritems(mid) <= orig_slot) {\n\t\t\t\tpath->nodes[level] = right;\n\t\t\t\tpath->slots[level + 1] += 1;\n\t\t\t\tpath->slots[level] = orig_slot -\n\t\t\t\t\tbtrfs_header_nritems(mid);\n\t\t\t\tbtrfs_tree_unlock(mid);\n\t\t\t\tfree_extent_buffer(mid);\n\t\t\t} else {\n\t\t\t\tbtrfs_tree_unlock(right);\n\t\t\t\tfree_extent_buffer(right);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\treturn 1;\n}\n\n \nstatic void reada_for_search(struct btrfs_fs_info *fs_info,\n\t\t\t     struct btrfs_path *path,\n\t\t\t     int level, int slot, u64 objectid)\n{\n\tstruct extent_buffer *node;\n\tstruct btrfs_disk_key disk_key;\n\tu32 nritems;\n\tu64 search;\n\tu64 target;\n\tu64 nread = 0;\n\tu64 nread_max;\n\tu32 nr;\n\tu32 blocksize;\n\tu32 nscan = 0;\n\n\tif (level != 1 && path->reada != READA_FORWARD_ALWAYS)\n\t\treturn;\n\n\tif (!path->nodes[level])\n\t\treturn;\n\n\tnode = path->nodes[level];\n\n\t \n\tif (path->reada == READA_FORWARD_ALWAYS) {\n\t\tif (level > 1)\n\t\t\tnread_max = node->fs_info->nodesize;\n\t\telse\n\t\t\tnread_max = SZ_128K;\n\t} else {\n\t\tnread_max = SZ_64K;\n\t}\n\n\tsearch = btrfs_node_blockptr(node, slot);\n\tblocksize = fs_info->nodesize;\n\tif (path->reada != READA_FORWARD_ALWAYS) {\n\t\tstruct extent_buffer *eb;\n\n\t\teb = find_extent_buffer(fs_info, search);\n\t\tif (eb) {\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttarget = search;\n\n\tnritems = btrfs_header_nritems(node);\n\tnr = slot;\n\n\twhile (1) {\n\t\tif (path->reada == READA_BACK) {\n\t\t\tif (nr == 0)\n\t\t\t\tbreak;\n\t\t\tnr--;\n\t\t} else if (path->reada == READA_FORWARD ||\n\t\t\t   path->reada == READA_FORWARD_ALWAYS) {\n\t\t\tnr++;\n\t\t\tif (nr >= nritems)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (path->reada == READA_BACK && objectid) {\n\t\t\tbtrfs_node_key(node, &disk_key, nr);\n\t\t\tif (btrfs_disk_key_objectid(&disk_key) != objectid)\n\t\t\t\tbreak;\n\t\t}\n\t\tsearch = btrfs_node_blockptr(node, nr);\n\t\tif (path->reada == READA_FORWARD_ALWAYS ||\n\t\t    (search <= target && target - search <= 65536) ||\n\t\t    (search > target && search - target <= 65536)) {\n\t\t\tbtrfs_readahead_node_child(node, nr);\n\t\t\tnread += blocksize;\n\t\t}\n\t\tnscan++;\n\t\tif (nread > nread_max || nscan > 32)\n\t\t\tbreak;\n\t}\n}\n\nstatic noinline void reada_for_balance(struct btrfs_path *path, int level)\n{\n\tstruct extent_buffer *parent;\n\tint slot;\n\tint nritems;\n\n\tparent = path->nodes[level + 1];\n\tif (!parent)\n\t\treturn;\n\n\tnritems = btrfs_header_nritems(parent);\n\tslot = path->slots[level + 1];\n\n\tif (slot > 0)\n\t\tbtrfs_readahead_node_child(parent, slot - 1);\n\tif (slot + 1 < nritems)\n\t\tbtrfs_readahead_node_child(parent, slot + 1);\n}\n\n\n \nstatic noinline void unlock_up(struct btrfs_path *path, int level,\n\t\t\t       int lowest_unlock, int min_write_lock_level,\n\t\t\t       int *write_lock_level)\n{\n\tint i;\n\tint skip_level = level;\n\tbool check_skip = true;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tif (!path->locks[i])\n\t\t\tbreak;\n\n\t\tif (check_skip) {\n\t\t\tif (path->slots[i] == 0) {\n\t\t\t\tskip_level = i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (path->keep_locks) {\n\t\t\t\tu32 nritems;\n\n\t\t\t\tnritems = btrfs_header_nritems(path->nodes[i]);\n\t\t\t\tif (nritems < 1 || path->slots[i] >= nritems - 1) {\n\t\t\t\t\tskip_level = i + 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (i >= lowest_unlock && i > skip_level) {\n\t\t\tcheck_skip = false;\n\t\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\t\tpath->locks[i] = 0;\n\t\t\tif (write_lock_level &&\n\t\t\t    i > min_write_lock_level &&\n\t\t\t    i <= *write_lock_level) {\n\t\t\t\t*write_lock_level = i - 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic int\nread_block_for_search(struct btrfs_root *root, struct btrfs_path *p,\n\t\t      struct extent_buffer **eb_ret, int level, int slot,\n\t\t      const struct btrfs_key *key)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_tree_parent_check check = { 0 };\n\tu64 blocknr;\n\tu64 gen;\n\tstruct extent_buffer *tmp;\n\tint ret;\n\tint parent_level;\n\tbool unlock_up;\n\n\tunlock_up = ((level + 1 < BTRFS_MAX_LEVEL) && p->locks[level + 1]);\n\tblocknr = btrfs_node_blockptr(*eb_ret, slot);\n\tgen = btrfs_node_ptr_generation(*eb_ret, slot);\n\tparent_level = btrfs_header_level(*eb_ret);\n\tbtrfs_node_key_to_cpu(*eb_ret, &check.first_key, slot);\n\tcheck.has_first_key = true;\n\tcheck.level = parent_level - 1;\n\tcheck.transid = gen;\n\tcheck.owner_root = root->root_key.objectid;\n\n\t \n\ttmp = find_extent_buffer(fs_info, blocknr);\n\tif (tmp) {\n\t\tif (p->reada == READA_FORWARD_ALWAYS)\n\t\t\treada_for_search(fs_info, p, level, slot, key->objectid);\n\n\t\t \n\t\tif (btrfs_buffer_uptodate(tmp, gen, 1) > 0) {\n\t\t\t \n\t\t\tif (btrfs_verify_level_key(tmp,\n\t\t\t\t\tparent_level - 1, &check.first_key, gen)) {\n\t\t\t\tfree_extent_buffer(tmp);\n\t\t\t\treturn -EUCLEAN;\n\t\t\t}\n\t\t\t*eb_ret = tmp;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (p->nowait) {\n\t\t\tfree_extent_buffer(tmp);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (unlock_up)\n\t\t\tbtrfs_unlock_up_safe(p, level + 1);\n\n\t\t \n\t\tret = btrfs_read_extent_buffer(tmp, &check);\n\t\tif (ret) {\n\t\t\tfree_extent_buffer(tmp);\n\t\t\tbtrfs_release_path(p);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (btrfs_check_eb_owner(tmp, root->root_key.objectid)) {\n\t\t\tfree_extent_buffer(tmp);\n\t\t\tbtrfs_release_path(p);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\tif (unlock_up)\n\t\t\tret = -EAGAIN;\n\n\t\tgoto out;\n\t} else if (p->nowait) {\n\t\treturn -EAGAIN;\n\t}\n\n\tif (unlock_up) {\n\t\tbtrfs_unlock_up_safe(p, level + 1);\n\t\tret = -EAGAIN;\n\t} else {\n\t\tret = 0;\n\t}\n\n\tif (p->reada != READA_NONE)\n\t\treada_for_search(fs_info, p, level, slot, key->objectid);\n\n\ttmp = read_tree_block(fs_info, blocknr, &check);\n\tif (IS_ERR(tmp)) {\n\t\tbtrfs_release_path(p);\n\t\treturn PTR_ERR(tmp);\n\t}\n\t \n\tif (!extent_buffer_uptodate(tmp))\n\t\tret = -EIO;\n\nout:\n\tif (ret == 0) {\n\t\t*eb_ret = tmp;\n\t} else {\n\t\tfree_extent_buffer(tmp);\n\t\tbtrfs_release_path(p);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int\nsetup_nodes_for_search(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *p,\n\t\t       struct extent_buffer *b, int level, int ins_len,\n\t\t       int *write_lock_level)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret = 0;\n\n\tif ((p->search_for_split || ins_len > 0) && btrfs_header_nritems(b) >=\n\t    BTRFS_NODEPTRS_PER_BLOCK(fs_info) - 3) {\n\n\t\tif (*write_lock_level < level + 1) {\n\t\t\t*write_lock_level = level + 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\treada_for_balance(p, level);\n\t\tret = split_node(trans, root, p, level);\n\n\t\tb = p->nodes[level];\n\t} else if (ins_len < 0 && btrfs_header_nritems(b) <\n\t\t   BTRFS_NODEPTRS_PER_BLOCK(fs_info) / 2) {\n\n\t\tif (*write_lock_level < level + 1) {\n\t\t\t*write_lock_level = level + 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\treada_for_balance(p, level);\n\t\tret = balance_level(trans, root, p, level);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tb = p->nodes[level];\n\t\tif (!b) {\n\t\t\tbtrfs_release_path(p);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tBUG_ON(btrfs_header_nritems(b) == 1);\n\t}\n\treturn ret;\n}\n\nint btrfs_find_item(struct btrfs_root *fs_root, struct btrfs_path *path,\n\t\tu64 iobjectid, u64 ioff, u8 key_type,\n\t\tstruct btrfs_key *found_key)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\n\tASSERT(path);\n\tASSERT(found_key);\n\n\tkey.type = key_type;\n\tkey.objectid = iobjectid;\n\tkey.offset = ioff;\n\n\tret = btrfs_search_slot(NULL, fs_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\teb = path->nodes[0];\n\tif (ret && path->slots[0] >= btrfs_header_nritems(eb)) {\n\t\tret = btrfs_next_leaf(fs_root, path);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\teb = path->nodes[0];\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, found_key, path->slots[0]);\n\tif (found_key->type != key.type ||\n\t\t\tfound_key->objectid != key.objectid)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct extent_buffer *btrfs_search_slot_get_root(struct btrfs_root *root,\n\t\t\t\t\t\t\tstruct btrfs_path *p,\n\t\t\t\t\t\t\tint write_lock_level)\n{\n\tstruct extent_buffer *b;\n\tint root_lock = 0;\n\tint level = 0;\n\n\tif (p->search_commit_root) {\n\t\tb = root->commit_root;\n\t\tatomic_inc(&b->refs);\n\t\tlevel = btrfs_header_level(b);\n\t\t \n\t\tASSERT(p->skip_locking == 1);\n\n\t\tgoto out;\n\t}\n\n\tif (p->skip_locking) {\n\t\tb = btrfs_root_node(root);\n\t\tlevel = btrfs_header_level(b);\n\t\tgoto out;\n\t}\n\n\t \n\troot_lock = BTRFS_READ_LOCK;\n\n\t \n\tif (write_lock_level < BTRFS_MAX_LEVEL) {\n\t\t \n\t\tif (p->nowait) {\n\t\t\tb = btrfs_try_read_lock_root_node(root);\n\t\t\tif (IS_ERR(b))\n\t\t\t\treturn b;\n\t\t} else {\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t}\n\t\tlevel = btrfs_header_level(b);\n\t\tif (level > write_lock_level)\n\t\t\tgoto out;\n\n\t\t \n\t\tbtrfs_tree_read_unlock(b);\n\t\tfree_extent_buffer(b);\n\t}\n\n\tb = btrfs_lock_root_node(root);\n\troot_lock = BTRFS_WRITE_LOCK;\n\n\t \n\tlevel = btrfs_header_level(b);\n\nout:\n\t \n\tif (!extent_buffer_uptodate(b)) {\n\t\tif (root_lock)\n\t\t\tbtrfs_tree_unlock_rw(b, root_lock);\n\t\tfree_extent_buffer(b);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\t \n\treturn b;\n}\n\n \nstatic int finish_need_commit_sem_search(struct btrfs_path *path)\n{\n\tconst int i = path->lowest_level;\n\tconst int slot = path->slots[i];\n\tstruct extent_buffer *lowest = path->nodes[i];\n\tstruct extent_buffer *clone;\n\n\tASSERT(path->need_commit_sem);\n\n\tif (!lowest)\n\t\treturn 0;\n\n\tlockdep_assert_held_read(&lowest->fs_info->commit_root_sem);\n\n\tclone = btrfs_clone_extent_buffer(lowest);\n\tif (!clone)\n\t\treturn -ENOMEM;\n\n\tbtrfs_release_path(path);\n\tpath->nodes[i] = clone;\n\tpath->slots[i] = slot;\n\n\treturn 0;\n}\n\nstatic inline int search_for_key_slot(struct extent_buffer *eb,\n\t\t\t\t      int search_low_slot,\n\t\t\t\t      const struct btrfs_key *key,\n\t\t\t\t      int prev_cmp,\n\t\t\t\t      int *slot)\n{\n\t \n\tif (prev_cmp == 0) {\n\t\t*slot = 0;\n\t\treturn 0;\n\t}\n\n\treturn btrfs_bin_search(eb, search_low_slot, key, slot);\n}\n\nstatic int search_leaf(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root,\n\t\t       const struct btrfs_key *key,\n\t\t       struct btrfs_path *path,\n\t\t       int ins_len,\n\t\t       int prev_cmp)\n{\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tint leaf_free_space = -1;\n\tint search_low_slot = 0;\n\tint ret;\n\tbool do_bin_search = true;\n\n\t \n\tif (ins_len > 0) {\n\t\t \n\t\tleaf_free_space = btrfs_leaf_free_space(leaf);\n\n\t\t \n\t\tif (path->locks[1] && leaf_free_space >= ins_len) {\n\t\t\tstruct btrfs_disk_key first_key;\n\n\t\t\tASSERT(btrfs_header_nritems(leaf) > 0);\n\t\t\tbtrfs_item_key(leaf, &first_key, 0);\n\n\t\t\t \n\t\t\tret = comp_keys(&first_key, key);\n\t\t\tif (ret < 0) {\n\t\t\t\t \n\t\t\t\tbtrfs_unlock_up_safe(path, 1);\n\t\t\t\tsearch_low_slot = 1;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (ret == 0)\n\t\t\t\t\tbtrfs_unlock_up_safe(path, 1);\n\t\t\t\t \n\t\t\t\tdo_bin_search = false;\n\t\t\t\tpath->slots[0] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (do_bin_search) {\n\t\tret = search_for_key_slot(leaf, search_low_slot, key,\n\t\t\t\t\t  prev_cmp, &path->slots[0]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (ins_len > 0) {\n\t\t \n\t\tif (ret == 0 && !path->search_for_extension) {\n\t\t\tASSERT(ins_len >= sizeof(struct btrfs_item));\n\t\t\tins_len -= sizeof(struct btrfs_item);\n\t\t}\n\n\t\tASSERT(leaf_free_space >= 0);\n\n\t\tif (leaf_free_space < ins_len) {\n\t\t\tint err;\n\n\t\t\terr = split_leaf(trans, root, key, path, ins_len,\n\t\t\t\t\t (ret == 0));\n\t\t\tASSERT(err <= 0);\n\t\t\tif (WARN_ON(err > 0))\n\t\t\t\terr = -EUCLEAN;\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      const struct btrfs_key *key, struct btrfs_path *p,\n\t\t      int ins_len, int cow)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\t \n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tmight_sleep();\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\t \n\tASSERT(!p->nowait || !cow);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t \n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t \n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\n\tif (p->need_commit_sem) {\n\t\tASSERT(p->search_commit_root);\n\t\tif (p->nowait) {\n\t\t\tif (!down_read_trylock(&fs_info->commit_root_sem))\n\t\t\t\treturn -EAGAIN;\n\t\t} else {\n\t\t\tdown_read(&fs_info->commit_root_sem);\n\t\t}\n\t}\n\nagain:\n\tprev_cmp = -1;\n\tb = btrfs_search_slot_get_root(root, p, write_lock_level);\n\tif (IS_ERR(b)) {\n\t\tret = PTR_ERR(b);\n\t\tgoto done;\n\t}\n\n\twhile (b) {\n\t\tint dec = 0;\n\n\t\tlevel = btrfs_header_level(b);\n\n\t\tif (cow) {\n\t\t\tbool last_level = (level == (BTRFS_MAX_LEVEL - 1));\n\n\t\t\t \n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t \n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tif (last_level)\n\t\t\t\terr = btrfs_cow_block(trans, root, b, NULL, 0,\n\t\t\t\t\t\t      &b,\n\t\t\t\t\t\t      BTRFS_NESTING_COW);\n\t\t\telse\n\t\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t\t      p->slots[level + 1], &b,\n\t\t\t\t\t\t      BTRFS_NESTING_COW);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\n\t\t \n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (level == 0) {\n\t\t\tif (ins_len > 0)\n\t\t\t\tASSERT(write_lock_level >= 1);\n\n\t\t\tret = search_leaf(trans, root, key, p, ins_len, prev_cmp);\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, NULL);\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = search_for_key_slot(b, 0, key, prev_cmp, &slot);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tprev_cmp = ret;\n\n\t\tif (ret && slot > 0) {\n\t\t\tdec = 1;\n\t\t\tslot--;\n\t\t}\n\t\tp->slots[level] = slot;\n\t\terr = setup_nodes_for_search(trans, root, p, b, level, ins_len,\n\t\t\t\t\t     &write_lock_level);\n\t\tif (err == -EAGAIN)\n\t\t\tgoto again;\n\t\tif (err) {\n\t\t\tret = err;\n\t\t\tgoto done;\n\t\t}\n\t\tb = p->nodes[level];\n\t\tslot = p->slots[level];\n\n\t\t \n\t\tif (slot == 0 && ins_len && write_lock_level < level + 1) {\n\t\t\twrite_lock_level = level + 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\n\t\tunlock_up(p, level, lowest_unlock, min_write_lock_level,\n\t\t\t  &write_lock_level);\n\n\t\tif (level == lowest_level) {\n\t\t\tif (dec)\n\t\t\t\tp->slots[level]++;\n\t\t\tgoto done;\n\t\t}\n\n\t\terr = read_block_for_search(root, p, &b, level, slot, key);\n\t\tif (err == -EAGAIN)\n\t\t\tgoto again;\n\t\tif (err) {\n\t\t\tret = err;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!p->skip_locking) {\n\t\t\tlevel = btrfs_header_level(b);\n\n\t\t\tbtrfs_maybe_reset_lockdep_class(root, b);\n\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t} else {\n\t\t\t\tif (p->nowait) {\n\t\t\t\t\tif (!btrfs_try_tree_read_lock(b)) {\n\t\t\t\t\t\tfree_extent_buffer(b);\n\t\t\t\t\t\tret = -EAGAIN;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t}\n\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t}\n\t\t\tp->nodes[level] = b;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\n\tif (p->need_commit_sem) {\n\t\tint ret2;\n\n\t\tret2 = finish_need_commit_sem_search(p);\n\t\tup_read(&fs_info->commit_root_sem);\n\t\tif (ret2)\n\t\t\tret = ret2;\n\t}\n\n\treturn ret;\n}\nALLOW_ERROR_INJECTION(btrfs_search_slot, ERRNO);\n\n \nint btrfs_search_old_slot(struct btrfs_root *root, const struct btrfs_key *key,\n\t\t\t  struct btrfs_path *p, u64 time_seq)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tu8 lowest_level = 0;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(p->nodes[0] != NULL);\n\tASSERT(!p->nowait);\n\n\tif (p->search_commit_root) {\n\t\tBUG_ON(time_seq);\n\t\treturn btrfs_search_slot(NULL, root, key, p, 0, 0);\n\t}\n\nagain:\n\tb = btrfs_get_old_root(root, time_seq);\n\tif (!b) {\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\tlevel = btrfs_header_level(b);\n\tp->locks[level] = BTRFS_READ_LOCK;\n\n\twhile (b) {\n\t\tint dec = 0;\n\n\t\tlevel = btrfs_header_level(b);\n\t\tp->nodes[level] = b;\n\n\t\t \n\t\tbtrfs_unlock_up_safe(p, level + 1);\n\n\t\tret = btrfs_bin_search(b, 0, key, &slot);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tif (level == 0) {\n\t\t\tp->slots[level] = slot;\n\t\t\tunlock_up(p, level, lowest_unlock, 0, NULL);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ret && slot > 0) {\n\t\t\tdec = 1;\n\t\t\tslot--;\n\t\t}\n\t\tp->slots[level] = slot;\n\t\tunlock_up(p, level, lowest_unlock, 0, NULL);\n\n\t\tif (level == lowest_level) {\n\t\t\tif (dec)\n\t\t\t\tp->slots[level]++;\n\t\t\tgoto done;\n\t\t}\n\n\t\terr = read_block_for_search(root, p, &b, level, slot, key);\n\t\tif (err == -EAGAIN)\n\t\t\tgoto again;\n\t\tif (err) {\n\t\t\tret = err;\n\t\t\tgoto done;\n\t\t}\n\n\t\tlevel = btrfs_header_level(b);\n\t\tbtrfs_tree_read_lock(b);\n\t\tb = btrfs_tree_mod_log_rewind(fs_info, p, b, time_seq);\n\t\tif (!b) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\tp->nodes[level] = b;\n\t}\n\tret = 1;\ndone:\n\tif (ret < 0)\n\t\tbtrfs_release_path(p);\n\n\treturn ret;\n}\n\n \nstatic int btrfs_prev_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key orig_key;\n\tstruct btrfs_disk_key found_key;\n\tint ret;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, 0);\n\torig_key = key;\n\n\tif (key.offset > 0) {\n\t\tkey.offset--;\n\t} else if (key.type > 0) {\n\t\tkey.type--;\n\t\tkey.offset = (u64)-1;\n\t} else if (key.objectid > 0) {\n\t\tkey.objectid--;\n\t\tkey.type = (u8)-1;\n\t\tkey.offset = (u64)-1;\n\t} else {\n\t\treturn 1;\n\t}\n\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\t \n\tif (path->slots[0] < btrfs_header_nritems(path->nodes[0])) {\n\t\tbtrfs_item_key(path->nodes[0], &found_key, path->slots[0]);\n\t\tret = comp_keys(&found_key, &orig_key);\n\t\tif (ret == 0) {\n\t\t\tif (path->slots[0] > 0) {\n\t\t\t\tpath->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t \n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tbtrfs_item_key(path->nodes[0], &found_key, 0);\n\tret = comp_keys(&found_key, &key);\n\t \n\tif (ret <= 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nint btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       const struct btrfs_key *key,\n\t\t\t       struct btrfs_path *p, int find_higher,\n\t\t\t       int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t \n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t \n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t \n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint btrfs_search_backwards(struct btrfs_root *root, struct btrfs_key *key,\n\t\t\t   struct btrfs_path *path)\n{\n\tint ret;\n\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret > 0)\n\t\tret = btrfs_previous_item(root, path, key->objectid, key->type);\n\n\tif (ret == 0)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], key, path->slots[0]);\n\n\treturn ret;\n}\n\n \nint btrfs_get_next_valid_item(struct btrfs_root *root, struct btrfs_key *key,\n\t\t\t      struct btrfs_path *path)\n{\n\tif (path->slots[0] >= btrfs_header_nritems(path->nodes[0])) {\n\t\tint ret;\n\n\t\tret = btrfs_next_leaf(root, path);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], key, path->slots[0]);\n\treturn 0;\n}\n\n \nstatic void fixup_low_keys(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_path *path,\n\t\t\t   struct btrfs_disk_key *key, int level)\n{\n\tint i;\n\tstruct extent_buffer *t;\n\tint ret;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tint tslot = path->slots[i];\n\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tt = path->nodes[i];\n\t\tret = btrfs_tree_mod_log_insert_key(t, tslot,\n\t\t\t\t\t\t    BTRFS_MOD_LOG_KEY_REPLACE);\n\t\tBUG_ON(ret < 0);\n\t\tbtrfs_set_node_key(t, key, tslot);\n\t\tbtrfs_mark_buffer_dirty(trans, path->nodes[i]);\n\t\tif (tslot != 0)\n\t\t\tbreak;\n\t}\n}\n\n \nvoid btrfs_set_item_key_safe(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_path *path,\n\t\t\t     const struct btrfs_key *new_key)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tif (slot > 0) {\n\t\tbtrfs_item_key(eb, &disk_key, slot - 1);\n\t\tif (unlikely(comp_keys(&disk_key, new_key) >= 0)) {\n\t\t\tbtrfs_print_leaf(eb);\n\t\t\tbtrfs_crit(fs_info,\n\t\t\"slot %u key (%llu %u %llu) new key (%llu %u %llu)\",\n\t\t\t\t   slot, btrfs_disk_key_objectid(&disk_key),\n\t\t\t\t   btrfs_disk_key_type(&disk_key),\n\t\t\t\t   btrfs_disk_key_offset(&disk_key),\n\t\t\t\t   new_key->objectid, new_key->type,\n\t\t\t\t   new_key->offset);\n\t\t\tBUG();\n\t\t}\n\t}\n\tif (slot < btrfs_header_nritems(eb) - 1) {\n\t\tbtrfs_item_key(eb, &disk_key, slot + 1);\n\t\tif (unlikely(comp_keys(&disk_key, new_key) <= 0)) {\n\t\t\tbtrfs_print_leaf(eb);\n\t\t\tbtrfs_crit(fs_info,\n\t\t\"slot %u key (%llu %u %llu) new key (%llu %u %llu)\",\n\t\t\t\t   slot, btrfs_disk_key_objectid(&disk_key),\n\t\t\t\t   btrfs_disk_key_type(&disk_key),\n\t\t\t\t   btrfs_disk_key_offset(&disk_key),\n\t\t\t\t   new_key->objectid, new_key->type,\n\t\t\t\t   new_key->offset);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(eb, &disk_key, slot);\n\tbtrfs_mark_buffer_dirty(trans, eb);\n\tif (slot == 0)\n\t\tfixup_low_keys(trans, path, &disk_key, 1);\n}\n\n \nstatic bool check_sibling_keys(struct extent_buffer *left,\n\t\t\t       struct extent_buffer *right)\n{\n\tstruct btrfs_key left_last;\n\tstruct btrfs_key right_first;\n\tint level = btrfs_header_level(left);\n\tint nr_left = btrfs_header_nritems(left);\n\tint nr_right = btrfs_header_nritems(right);\n\n\t \n\tif (!nr_left || !nr_right)\n\t\treturn false;\n\n\tif (level) {\n\t\tbtrfs_node_key_to_cpu(left, &left_last, nr_left - 1);\n\t\tbtrfs_node_key_to_cpu(right, &right_first, 0);\n\t} else {\n\t\tbtrfs_item_key_to_cpu(left, &left_last, nr_left - 1);\n\t\tbtrfs_item_key_to_cpu(right, &right_first, 0);\n\t}\n\n\tif (unlikely(btrfs_comp_cpu_keys(&left_last, &right_first) >= 0)) {\n\t\tbtrfs_crit(left->fs_info, \"left extent buffer:\");\n\t\tbtrfs_print_tree(left, false);\n\t\tbtrfs_crit(left->fs_info, \"right extent buffer:\");\n\t\tbtrfs_print_tree(right, false);\n\t\tbtrfs_crit(left->fs_info,\n\"bad key order, sibling blocks, left last (%llu %u %llu) right first (%llu %u %llu)\",\n\t\t\t   left_last.objectid, left_last.type,\n\t\t\t   left_last.offset, right_first.objectid,\n\t\t\t   right_first.type, right_first.offset);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tint push_items = 0;\n\tint src_nritems;\n\tint dst_nritems;\n\tint ret = 0;\n\n\tsrc_nritems = btrfs_header_nritems(src);\n\tdst_nritems = btrfs_header_nritems(dst);\n\tpush_items = BTRFS_NODEPTRS_PER_BLOCK(fs_info) - dst_nritems;\n\tWARN_ON(btrfs_header_generation(src) != trans->transid);\n\tWARN_ON(btrfs_header_generation(dst) != trans->transid);\n\n\tif (!empty && src_nritems <= 8)\n\t\treturn 1;\n\n\tif (push_items <= 0)\n\t\treturn 1;\n\n\tif (empty) {\n\t\tpush_items = min(src_nritems, push_items);\n\t\tif (push_items < src_nritems) {\n\t\t\t \n\t\t\tif (src_nritems - push_items < 8) {\n\t\t\t\tif (push_items <= 8)\n\t\t\t\t\treturn 1;\n\t\t\t\tpush_items -= 8;\n\t\t\t}\n\t\t}\n\t} else\n\t\tpush_items = min(src_nritems - 8, push_items);\n\n\t \n\tif (check_sibling_keys(dst, src)) {\n\t\tret = -EUCLEAN;\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\treturn ret;\n\t}\n\tret = btrfs_tree_mod_log_eb_copy(dst, src, dst_nritems, 0, push_items);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(dst, src,\n\t\t\t   btrfs_node_key_ptr_offset(dst, dst_nritems),\n\t\t\t   btrfs_node_key_ptr_offset(src, 0),\n\t\t\t   push_items * sizeof(struct btrfs_key_ptr));\n\n\tif (push_items < src_nritems) {\n\t\t \n\t\tmemmove_extent_buffer(src, btrfs_node_key_ptr_offset(src, 0),\n\t\t\t\t      btrfs_node_key_ptr_offset(src, push_items),\n\t\t\t\t      (src_nritems - push_items) *\n\t\t\t\t      sizeof(struct btrfs_key_ptr));\n\t}\n\tbtrfs_set_header_nritems(src, src_nritems - push_items);\n\tbtrfs_set_header_nritems(dst, dst_nritems + push_items);\n\tbtrfs_mark_buffer_dirty(trans, src);\n\tbtrfs_mark_buffer_dirty(trans, dst);\n\n\treturn ret;\n}\n\n \nstatic int balance_node_right(struct btrfs_trans_handle *trans,\n\t\t\t      struct extent_buffer *dst,\n\t\t\t      struct extent_buffer *src)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tint push_items = 0;\n\tint max_push;\n\tint src_nritems;\n\tint dst_nritems;\n\tint ret = 0;\n\n\tWARN_ON(btrfs_header_generation(src) != trans->transid);\n\tWARN_ON(btrfs_header_generation(dst) != trans->transid);\n\n\tsrc_nritems = btrfs_header_nritems(src);\n\tdst_nritems = btrfs_header_nritems(dst);\n\tpush_items = BTRFS_NODEPTRS_PER_BLOCK(fs_info) - dst_nritems;\n\tif (push_items <= 0)\n\t\treturn 1;\n\n\tif (src_nritems < 4)\n\t\treturn 1;\n\n\tmax_push = src_nritems / 2 + 1;\n\t \n\tif (max_push >= src_nritems)\n\t\treturn 1;\n\n\tif (max_push < push_items)\n\t\tpush_items = max_push;\n\n\t \n\tif (check_sibling_keys(src, dst)) {\n\t\tret = -EUCLEAN;\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmemmove_extent_buffer(dst, btrfs_node_key_ptr_offset(dst, push_items),\n\t\t\t\t      btrfs_node_key_ptr_offset(dst, 0),\n\t\t\t\t      (dst_nritems) *\n\t\t\t\t      sizeof(struct btrfs_key_ptr));\n\n\tret = btrfs_tree_mod_log_eb_copy(dst, src, 0, src_nritems - push_items,\n\t\t\t\t\t push_items);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(dst, src,\n\t\t\t   btrfs_node_key_ptr_offset(dst, 0),\n\t\t\t   btrfs_node_key_ptr_offset(src, src_nritems - push_items),\n\t\t\t   push_items * sizeof(struct btrfs_key_ptr));\n\n\tbtrfs_set_header_nritems(src, src_nritems - push_items);\n\tbtrfs_set_header_nritems(dst, dst_nritems + push_items);\n\n\tbtrfs_mark_buffer_dirty(trans, src);\n\tbtrfs_mark_buffer_dirty(trans, dst);\n\n\treturn ret;\n}\n\n \nstatic noinline int insert_new_root(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_path *path, int level)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 lower_gen;\n\tstruct extent_buffer *lower;\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *old;\n\tstruct btrfs_disk_key lower_key;\n\tint ret;\n\n\tBUG_ON(path->nodes[level]);\n\tBUG_ON(path->nodes[level-1] != root->node);\n\n\tlower = path->nodes[level-1];\n\tif (level == 1)\n\t\tbtrfs_item_key(lower, &lower_key, 0);\n\telse\n\t\tbtrfs_node_key(lower, &lower_key, 0);\n\n\tc = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t\t   &lower_key, level, root->node->start, 0,\n\t\t\t\t   BTRFS_NESTING_NEW_ROOT);\n\tif (IS_ERR(c))\n\t\treturn PTR_ERR(c);\n\n\troot_add_used(root, fs_info->nodesize);\n\n\tbtrfs_set_header_nritems(c, 1);\n\tbtrfs_set_node_key(c, &lower_key, 0);\n\tbtrfs_set_node_blockptr(c, 0, lower->start);\n\tlower_gen = btrfs_header_generation(lower);\n\tWARN_ON(lower_gen != trans->transid);\n\n\tbtrfs_set_node_ptr_generation(c, 0, lower_gen);\n\n\tbtrfs_mark_buffer_dirty(trans, c);\n\n\told = root->node;\n\tret = btrfs_tree_mod_log_insert_root(root->node, c, false);\n\tif (ret < 0) {\n\t\tbtrfs_free_tree_block(trans, btrfs_root_id(root), c, 0, 1);\n\t\tbtrfs_tree_unlock(c);\n\t\tfree_extent_buffer(c);\n\t\treturn ret;\n\t}\n\trcu_assign_pointer(root->node, c);\n\n\t \n\tfree_extent_buffer(old);\n\n\tadd_root_to_dirty_list(root);\n\tatomic_inc(&c->refs);\n\tpath->nodes[level] = c;\n\tpath->locks[level] = BTRFS_WRITE_LOCK;\n\tpath->slots[level] = 0;\n\treturn 0;\n}\n\n \nstatic int insert_ptr(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_path *path,\n\t\t      struct btrfs_disk_key *key, u64 bytenr,\n\t\t      int slot, int level)\n{\n\tstruct extent_buffer *lower;\n\tint nritems;\n\tint ret;\n\n\tBUG_ON(!path->nodes[level]);\n\tbtrfs_assert_tree_write_locked(path->nodes[level]);\n\tlower = path->nodes[level];\n\tnritems = btrfs_header_nritems(lower);\n\tBUG_ON(slot > nritems);\n\tBUG_ON(nritems == BTRFS_NODEPTRS_PER_BLOCK(trans->fs_info));\n\tif (slot != nritems) {\n\t\tif (level) {\n\t\t\tret = btrfs_tree_mod_log_insert_move(lower, slot + 1,\n\t\t\t\t\tslot, nritems - slot);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tmemmove_extent_buffer(lower,\n\t\t\t      btrfs_node_key_ptr_offset(lower, slot + 1),\n\t\t\t      btrfs_node_key_ptr_offset(lower, slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_key_ptr));\n\t}\n\tif (level) {\n\t\tret = btrfs_tree_mod_log_insert_key(lower, slot,\n\t\t\t\t\t\t    BTRFS_MOD_LOG_KEY_ADD);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tbtrfs_set_node_key(lower, key, slot);\n\tbtrfs_set_node_blockptr(lower, slot, bytenr);\n\tWARN_ON(trans->transid == 0);\n\tbtrfs_set_node_ptr_generation(lower, slot, trans->transid);\n\tbtrfs_set_header_nritems(lower, nritems + 1);\n\tbtrfs_mark_buffer_dirty(trans, lower);\n\n\treturn 0;\n}\n\n \nstatic noinline int split_node(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_path *path, int level)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *split;\n\tstruct btrfs_disk_key disk_key;\n\tint mid;\n\tint ret;\n\tu32 c_nritems;\n\n\tc = path->nodes[level];\n\tWARN_ON(btrfs_header_generation(c) != trans->transid);\n\tif (c == root->node) {\n\t\t \n\t\tret = insert_new_root(trans, root, path, level + 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = push_nodes_for_insert(trans, root, path, level);\n\t\tc = path->nodes[level];\n\t\tif (!ret && btrfs_header_nritems(c) <\n\t\t    BTRFS_NODEPTRS_PER_BLOCK(fs_info) - 3)\n\t\t\treturn 0;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tc_nritems = btrfs_header_nritems(c);\n\tmid = (c_nritems + 1) / 2;\n\tbtrfs_node_key(c, &disk_key, mid);\n\n\tsplit = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t\t       &disk_key, level, c->start, 0,\n\t\t\t\t       BTRFS_NESTING_SPLIT);\n\tif (IS_ERR(split))\n\t\treturn PTR_ERR(split);\n\n\troot_add_used(root, fs_info->nodesize);\n\tASSERT(btrfs_header_level(c) == level);\n\n\tret = btrfs_tree_mod_log_eb_copy(split, c, 0, mid, c_nritems - mid);\n\tif (ret) {\n\t\tbtrfs_tree_unlock(split);\n\t\tfree_extent_buffer(split);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(split, c,\n\t\t\t   btrfs_node_key_ptr_offset(split, 0),\n\t\t\t   btrfs_node_key_ptr_offset(c, mid),\n\t\t\t   (c_nritems - mid) * sizeof(struct btrfs_key_ptr));\n\tbtrfs_set_header_nritems(split, c_nritems - mid);\n\tbtrfs_set_header_nritems(c, mid);\n\n\tbtrfs_mark_buffer_dirty(trans, c);\n\tbtrfs_mark_buffer_dirty(trans, split);\n\n\tret = insert_ptr(trans, path, &disk_key, split->start,\n\t\t\t path->slots[level + 1] + 1, level + 1);\n\tif (ret < 0) {\n\t\tbtrfs_tree_unlock(split);\n\t\tfree_extent_buffer(split);\n\t\treturn ret;\n\t}\n\n\tif (path->slots[level] >= mid) {\n\t\tpath->slots[level] -= mid;\n\t\tbtrfs_tree_unlock(c);\n\t\tfree_extent_buffer(c);\n\t\tpath->nodes[level] = split;\n\t\tpath->slots[level + 1] += 1;\n\t} else {\n\t\tbtrfs_tree_unlock(split);\n\t\tfree_extent_buffer(split);\n\t}\n\treturn 0;\n}\n\n \nstatic int leaf_space_used(const struct extent_buffer *l, int start, int nr)\n{\n\tint data_len;\n\tint nritems = btrfs_header_nritems(l);\n\tint end = min(nritems, start + nr) - 1;\n\n\tif (!nr)\n\t\treturn 0;\n\tdata_len = btrfs_item_offset(l, start) + btrfs_item_size(l, start);\n\tdata_len = data_len - btrfs_item_offset(l, end);\n\tdata_len += sizeof(struct btrfs_item) * nr;\n\tWARN_ON(data_len < 0);\n\treturn data_len;\n}\n\n \nint btrfs_leaf_free_space(const struct extent_buffer *leaf)\n{\n\tstruct btrfs_fs_info *fs_info = leaf->fs_info;\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\n\tret = BTRFS_LEAF_DATA_SIZE(fs_info) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(fs_info,\n\t\t\t   \"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t\t   ret,\n\t\t\t   (unsigned long) BTRFS_LEAF_DATA_SIZE(fs_info),\n\t\t\t   leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}\n\n \nstatic noinline int __push_leaf_right(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      int data_size, int empty,\n\t\t\t\t      struct extent_buffer *right,\n\t\t\t\t      int free_space, u32 left_nritems,\n\t\t\t\t      u32 min_slot)\n{\n\tstruct btrfs_fs_info *fs_info = right->fs_info;\n\tstruct extent_buffer *left = path->nodes[0];\n\tstruct extent_buffer *upper = path->nodes[1];\n\tstruct btrfs_map_token token;\n\tstruct btrfs_disk_key disk_key;\n\tint slot;\n\tu32 i;\n\tint push_space = 0;\n\tint push_items = 0;\n\tu32 nr;\n\tu32 right_nritems;\n\tu32 data_end;\n\tu32 this_item_size;\n\n\tif (empty)\n\t\tnr = 0;\n\telse\n\t\tnr = max_t(u32, 1, min_slot);\n\n\tif (path->slots[0] >= left_nritems)\n\t\tpush_space += data_size;\n\n\tslot = path->slots[1];\n\ti = left_nritems - 1;\n\twhile (i >= nr) {\n\t\tif (!empty && push_items > 0) {\n\t\t\tif (path->slots[0] > i)\n\t\t\t\tbreak;\n\t\t\tif (path->slots[0] == i) {\n\t\t\t\tint space = btrfs_leaf_free_space(left);\n\n\t\t\t\tif (space + push_space * 2 > free_space)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (path->slots[0] == i)\n\t\t\tpush_space += data_size;\n\n\t\tthis_item_size = btrfs_item_size(left, i);\n\t\tif (this_item_size + sizeof(struct btrfs_item) +\n\t\t    push_space > free_space)\n\t\t\tbreak;\n\n\t\tpush_items++;\n\t\tpush_space += this_item_size + sizeof(struct btrfs_item);\n\t\tif (i == 0)\n\t\t\tbreak;\n\t\ti--;\n\t}\n\n\tif (push_items == 0)\n\t\tgoto out_unlock;\n\n\tWARN_ON(!empty && push_items == left_nritems);\n\n\t \n\tright_nritems = btrfs_header_nritems(right);\n\n\tpush_space = btrfs_item_data_end(left, left_nritems - push_items);\n\tpush_space -= leaf_data_end(left);\n\n\t \n\tdata_end = leaf_data_end(right);\n\tmemmove_leaf_data(right, data_end - push_space, data_end,\n\t\t\t  BTRFS_LEAF_DATA_SIZE(fs_info) - data_end);\n\n\t \n\tcopy_leaf_data(right, left, BTRFS_LEAF_DATA_SIZE(fs_info) - push_space,\n\t\t       leaf_data_end(left), push_space);\n\n\tmemmove_leaf_items(right, push_items, 0, right_nritems);\n\n\t \n\tcopy_leaf_items(right, left, 0, left_nritems - push_items, push_items);\n\n\t \n\tbtrfs_init_map_token(&token, right);\n\tright_nritems += push_items;\n\tbtrfs_set_header_nritems(right, right_nritems);\n\tpush_space = BTRFS_LEAF_DATA_SIZE(fs_info);\n\tfor (i = 0; i < right_nritems; i++) {\n\t\tpush_space -= btrfs_token_item_size(&token, i);\n\t\tbtrfs_set_token_item_offset(&token, i, push_space);\n\t}\n\n\tleft_nritems -= push_items;\n\tbtrfs_set_header_nritems(left, left_nritems);\n\n\tif (left_nritems)\n\t\tbtrfs_mark_buffer_dirty(trans, left);\n\telse\n\t\tbtrfs_clear_buffer_dirty(trans, left);\n\n\tbtrfs_mark_buffer_dirty(trans, right);\n\n\tbtrfs_item_key(right, &disk_key, 0);\n\tbtrfs_set_node_key(upper, &disk_key, slot + 1);\n\tbtrfs_mark_buffer_dirty(trans, upper);\n\n\t \n\tif (path->slots[0] >= left_nritems) {\n\t\tpath->slots[0] -= left_nritems;\n\t\tif (btrfs_header_nritems(path->nodes[0]) == 0)\n\t\t\tbtrfs_clear_buffer_dirty(trans, path->nodes[0]);\n\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\tfree_extent_buffer(path->nodes[0]);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[1] += 1;\n\t} else {\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\treturn 0;\n\nout_unlock:\n\tbtrfs_tree_unlock(right);\n\tfree_extent_buffer(right);\n\treturn 1;\n}\n\n \nstatic int push_leaf_right(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t   *root, struct btrfs_path *path,\n\t\t\t   int min_data_size, int data_size,\n\t\t\t   int empty, u32 min_slot)\n{\n\tstruct extent_buffer *left = path->nodes[0];\n\tstruct extent_buffer *right;\n\tstruct extent_buffer *upper;\n\tint slot;\n\tint free_space;\n\tu32 left_nritems;\n\tint ret;\n\n\tif (!path->nodes[1])\n\t\treturn 1;\n\n\tslot = path->slots[1];\n\tupper = path->nodes[1];\n\tif (slot >= btrfs_header_nritems(upper) - 1)\n\t\treturn 1;\n\n\tbtrfs_assert_tree_write_locked(path->nodes[1]);\n\n\tright = btrfs_read_node_slot(upper, slot + 1);\n\tif (IS_ERR(right))\n\t\treturn PTR_ERR(right);\n\n\t__btrfs_tree_lock(right, BTRFS_NESTING_RIGHT);\n\n\tfree_space = btrfs_leaf_free_space(right);\n\tif (free_space < data_size)\n\t\tgoto out_unlock;\n\n\tret = btrfs_cow_block(trans, root, right, upper,\n\t\t\t      slot + 1, &right, BTRFS_NESTING_RIGHT_COW);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tleft_nritems = btrfs_header_nritems(left);\n\tif (left_nritems == 0)\n\t\tgoto out_unlock;\n\n\tif (check_sibling_keys(left, right)) {\n\t\tret = -EUCLEAN;\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t\treturn ret;\n\t}\n\tif (path->slots[0] == left_nritems && !empty) {\n\t\t \n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[0] = 0;\n\t\tpath->slots[1]++;\n\t\treturn 0;\n\t}\n\n\treturn __push_leaf_right(trans, path, min_data_size, empty, right,\n\t\t\t\t free_space, left_nritems, min_slot);\nout_unlock:\n\tbtrfs_tree_unlock(right);\n\tfree_extent_buffer(right);\n\treturn 1;\n}\n\n \nstatic noinline int __push_leaf_left(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_path *path, int data_size,\n\t\t\t\t     int empty, struct extent_buffer *left,\n\t\t\t\t     int free_space, u32 right_nritems,\n\t\t\t\t     u32 max_slot)\n{\n\tstruct btrfs_fs_info *fs_info = left->fs_info;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *right = path->nodes[0];\n\tint i;\n\tint push_space = 0;\n\tint push_items = 0;\n\tu32 old_left_nritems;\n\tu32 nr;\n\tint ret = 0;\n\tu32 this_item_size;\n\tu32 old_left_item_size;\n\tstruct btrfs_map_token token;\n\n\tif (empty)\n\t\tnr = min(right_nritems, max_slot);\n\telse\n\t\tnr = min(right_nritems - 1, max_slot);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (!empty && push_items > 0) {\n\t\t\tif (path->slots[0] < i)\n\t\t\t\tbreak;\n\t\t\tif (path->slots[0] == i) {\n\t\t\t\tint space = btrfs_leaf_free_space(right);\n\n\t\t\t\tif (space + push_space * 2 > free_space)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (path->slots[0] == i)\n\t\t\tpush_space += data_size;\n\n\t\tthis_item_size = btrfs_item_size(right, i);\n\t\tif (this_item_size + sizeof(struct btrfs_item) + push_space >\n\t\t    free_space)\n\t\t\tbreak;\n\n\t\tpush_items++;\n\t\tpush_space += this_item_size + sizeof(struct btrfs_item);\n\t}\n\n\tif (push_items == 0) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\tWARN_ON(!empty && push_items == btrfs_header_nritems(right));\n\n\t \n\tcopy_leaf_items(left, right, btrfs_header_nritems(left), 0, push_items);\n\n\tpush_space = BTRFS_LEAF_DATA_SIZE(fs_info) -\n\t\t     btrfs_item_offset(right, push_items - 1);\n\n\tcopy_leaf_data(left, right, leaf_data_end(left) - push_space,\n\t\t       btrfs_item_offset(right, push_items - 1), push_space);\n\told_left_nritems = btrfs_header_nritems(left);\n\tBUG_ON(old_left_nritems <= 0);\n\n\tbtrfs_init_map_token(&token, left);\n\told_left_item_size = btrfs_item_offset(left, old_left_nritems - 1);\n\tfor (i = old_left_nritems; i < old_left_nritems + push_items; i++) {\n\t\tu32 ioff;\n\n\t\tioff = btrfs_token_item_offset(&token, i);\n\t\tbtrfs_set_token_item_offset(&token, i,\n\t\t      ioff - (BTRFS_LEAF_DATA_SIZE(fs_info) - old_left_item_size));\n\t}\n\tbtrfs_set_header_nritems(left, old_left_nritems + push_items);\n\n\t \n\tif (push_items > right_nritems)\n\t\tWARN(1, KERN_CRIT \"push items %d nr %u\\n\", push_items,\n\t\t       right_nritems);\n\n\tif (push_items < right_nritems) {\n\t\tpush_space = btrfs_item_offset(right, push_items - 1) -\n\t\t\t\t\t\t  leaf_data_end(right);\n\t\tmemmove_leaf_data(right,\n\t\t\t\t  BTRFS_LEAF_DATA_SIZE(fs_info) - push_space,\n\t\t\t\t  leaf_data_end(right), push_space);\n\n\t\tmemmove_leaf_items(right, 0, push_items,\n\t\t\t\t   btrfs_header_nritems(right) - push_items);\n\t}\n\n\tbtrfs_init_map_token(&token, right);\n\tright_nritems -= push_items;\n\tbtrfs_set_header_nritems(right, right_nritems);\n\tpush_space = BTRFS_LEAF_DATA_SIZE(fs_info);\n\tfor (i = 0; i < right_nritems; i++) {\n\t\tpush_space = push_space - btrfs_token_item_size(&token, i);\n\t\tbtrfs_set_token_item_offset(&token, i, push_space);\n\t}\n\n\tbtrfs_mark_buffer_dirty(trans, left);\n\tif (right_nritems)\n\t\tbtrfs_mark_buffer_dirty(trans, right);\n\telse\n\t\tbtrfs_clear_buffer_dirty(trans, right);\n\n\tbtrfs_item_key(right, &disk_key, 0);\n\tfixup_low_keys(trans, path, &disk_key, 1);\n\n\t \n\tif (path->slots[0] < push_items) {\n\t\tpath->slots[0] += old_left_nritems;\n\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\tfree_extent_buffer(path->nodes[0]);\n\t\tpath->nodes[0] = left;\n\t\tpath->slots[1] -= 1;\n\t} else {\n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t\tpath->slots[0] -= push_items;\n\t}\n\tBUG_ON(path->slots[0] < 0);\n\treturn ret;\nout:\n\tbtrfs_tree_unlock(left);\n\tfree_extent_buffer(left);\n\treturn ret;\n}\n\n \nstatic int push_leaf_left(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t  *root, struct btrfs_path *path, int min_data_size,\n\t\t\t  int data_size, int empty, u32 max_slot)\n{\n\tstruct extent_buffer *right = path->nodes[0];\n\tstruct extent_buffer *left;\n\tint slot;\n\tint free_space;\n\tu32 right_nritems;\n\tint ret = 0;\n\n\tslot = path->slots[1];\n\tif (slot == 0)\n\t\treturn 1;\n\tif (!path->nodes[1])\n\t\treturn 1;\n\n\tright_nritems = btrfs_header_nritems(right);\n\tif (right_nritems == 0)\n\t\treturn 1;\n\n\tbtrfs_assert_tree_write_locked(path->nodes[1]);\n\n\tleft = btrfs_read_node_slot(path->nodes[1], slot - 1);\n\tif (IS_ERR(left))\n\t\treturn PTR_ERR(left);\n\n\t__btrfs_tree_lock(left, BTRFS_NESTING_LEFT);\n\n\tfree_space = btrfs_leaf_free_space(left);\n\tif (free_space < data_size) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_cow_block(trans, root, left,\n\t\t\t      path->nodes[1], slot - 1, &left,\n\t\t\t      BTRFS_NESTING_LEFT_COW);\n\tif (ret) {\n\t\t \n\t\tif (ret == -ENOSPC)\n\t\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (check_sibling_keys(left, right)) {\n\t\tret = -EUCLEAN;\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\n\treturn __push_leaf_left(trans, path, min_data_size, empty, left,\n\t\t\t\tfree_space, right_nritems, max_slot);\nout:\n\tbtrfs_tree_unlock(left);\n\tfree_extent_buffer(left);\n\treturn ret;\n}\n\n \nstatic noinline int copy_for_split(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct extent_buffer *l,\n\t\t\t\t   struct extent_buffer *right,\n\t\t\t\t   int slot, int mid, int nritems)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tint data_copy_size;\n\tint rt_data_off;\n\tint i;\n\tint ret;\n\tstruct btrfs_disk_key disk_key;\n\tstruct btrfs_map_token token;\n\n\tnritems = nritems - mid;\n\tbtrfs_set_header_nritems(right, nritems);\n\tdata_copy_size = btrfs_item_data_end(l, mid) - leaf_data_end(l);\n\n\tcopy_leaf_items(right, l, 0, mid, nritems);\n\n\tcopy_leaf_data(right, l, BTRFS_LEAF_DATA_SIZE(fs_info) - data_copy_size,\n\t\t       leaf_data_end(l), data_copy_size);\n\n\trt_data_off = BTRFS_LEAF_DATA_SIZE(fs_info) - btrfs_item_data_end(l, mid);\n\n\tbtrfs_init_map_token(&token, right);\n\tfor (i = 0; i < nritems; i++) {\n\t\tu32 ioff;\n\n\t\tioff = btrfs_token_item_offset(&token, i);\n\t\tbtrfs_set_token_item_offset(&token, i, ioff + rt_data_off);\n\t}\n\n\tbtrfs_set_header_nritems(l, mid);\n\tbtrfs_item_key(right, &disk_key, 0);\n\tret = insert_ptr(trans, path, &disk_key, right->start, path->slots[1] + 1, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbtrfs_mark_buffer_dirty(trans, right);\n\tbtrfs_mark_buffer_dirty(trans, l);\n\tBUG_ON(path->slots[0] != slot);\n\n\tif (mid <= slot) {\n\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\tfree_extent_buffer(path->nodes[0]);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[0] -= mid;\n\t\tpath->slots[1] += 1;\n\t} else {\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\n\tBUG_ON(path->slots[0] < 0);\n\n\treturn 0;\n}\n\n \nstatic noinline int push_for_double_split(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  int data_size)\n{\n\tint ret;\n\tint progress = 0;\n\tint slot;\n\tu32 nritems;\n\tint space_needed = data_size;\n\n\tslot = path->slots[0];\n\tif (slot < btrfs_header_nritems(path->nodes[0]))\n\t\tspace_needed -= btrfs_leaf_free_space(path->nodes[0]);\n\n\t \n\tret = push_leaf_right(trans, root, path, 1, space_needed, 0, slot);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0)\n\t\tprogress++;\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t \n\tif (path->slots[0] == 0 || path->slots[0] == nritems)\n\t\treturn 0;\n\n\tif (btrfs_leaf_free_space(path->nodes[0]) >= data_size)\n\t\treturn 0;\n\n\t \n\tslot = path->slots[0];\n\tspace_needed = data_size;\n\tif (slot > 0)\n\t\tspace_needed -= btrfs_leaf_free_space(path->nodes[0]);\n\tret = push_leaf_left(trans, root, path, 1, space_needed, 0, slot);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0)\n\t\tprogress++;\n\n\tif (progress)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic noinline int split_leaf(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       const struct btrfs_key *ins_key,\n\t\t\t       struct btrfs_path *path, int data_size,\n\t\t\t       int extend)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *l;\n\tu32 nritems;\n\tint mid;\n\tint slot;\n\tstruct extent_buffer *right;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret = 0;\n\tint wret;\n\tint split;\n\tint num_doubles = 0;\n\tint tried_avoid_double = 0;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tif (extend && data_size + btrfs_item_size(l, slot) +\n\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(fs_info))\n\t\treturn -EOVERFLOW;\n\n\t \n\tif (data_size && path->nodes[1]) {\n\t\tint space_needed = data_size;\n\n\t\tif (slot < btrfs_header_nritems(l))\n\t\t\tspace_needed -= btrfs_leaf_free_space(l);\n\n\t\twret = push_leaf_right(trans, root, path, space_needed,\n\t\t\t\t       space_needed, 0, 0);\n\t\tif (wret < 0)\n\t\t\treturn wret;\n\t\tif (wret) {\n\t\t\tspace_needed = data_size;\n\t\t\tif (slot > 0)\n\t\t\t\tspace_needed -= btrfs_leaf_free_space(l);\n\t\t\twret = push_leaf_left(trans, root, path, space_needed,\n\t\t\t\t\t      space_needed, 0, (u32)-1);\n\t\t\tif (wret < 0)\n\t\t\t\treturn wret;\n\t\t}\n\t\tl = path->nodes[0];\n\n\t\t \n\t\tif (btrfs_leaf_free_space(l) >= data_size)\n\t\t\treturn 0;\n\t}\n\n\tif (!path->nodes[1]) {\n\t\tret = insert_new_root(trans, root, path, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\nagain:\n\tsplit = 1;\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tnritems = btrfs_header_nritems(l);\n\tmid = (nritems + 1) / 2;\n\n\tif (mid <= slot) {\n\t\tif (nritems == 1 ||\n\t\t    leaf_space_used(l, mid, nritems - mid) + data_size >\n\t\t\tBTRFS_LEAF_DATA_SIZE(fs_info)) {\n\t\t\tif (slot >= nritems) {\n\t\t\t\tsplit = 0;\n\t\t\t} else {\n\t\t\t\tmid = slot;\n\t\t\t\tif (mid != nritems &&\n\t\t\t\t    leaf_space_used(l, mid, nritems - mid) +\n\t\t\t\t    data_size > BTRFS_LEAF_DATA_SIZE(fs_info)) {\n\t\t\t\t\tif (data_size && !tried_avoid_double)\n\t\t\t\t\t\tgoto push_for_double;\n\t\t\t\t\tsplit = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (leaf_space_used(l, 0, mid) + data_size >\n\t\t\tBTRFS_LEAF_DATA_SIZE(fs_info)) {\n\t\t\tif (!extend && data_size && slot == 0) {\n\t\t\t\tsplit = 0;\n\t\t\t} else if ((extend || !data_size) && slot == 0) {\n\t\t\t\tmid = 1;\n\t\t\t} else {\n\t\t\t\tmid = slot;\n\t\t\t\tif (mid != nritems &&\n\t\t\t\t    leaf_space_used(l, mid, nritems - mid) +\n\t\t\t\t    data_size > BTRFS_LEAF_DATA_SIZE(fs_info)) {\n\t\t\t\t\tif (data_size && !tried_avoid_double)\n\t\t\t\t\t\tgoto push_for_double;\n\t\t\t\t\tsplit = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (split == 0)\n\t\tbtrfs_cpu_key_to_disk(&disk_key, ins_key);\n\telse\n\t\tbtrfs_item_key(l, &disk_key, mid);\n\n\t \n\tright = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t\t       &disk_key, 0, l->start, 0,\n\t\t\t\t       num_doubles ? BTRFS_NESTING_NEW_ROOT :\n\t\t\t\t       BTRFS_NESTING_SPLIT);\n\tif (IS_ERR(right))\n\t\treturn PTR_ERR(right);\n\n\troot_add_used(root, fs_info->nodesize);\n\n\tif (split == 0) {\n\t\tif (mid <= slot) {\n\t\t\tbtrfs_set_header_nritems(right, 0);\n\t\t\tret = insert_ptr(trans, path, &disk_key,\n\t\t\t\t\t right->start, path->slots[1] + 1, 1);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_tree_unlock(right);\n\t\t\t\tfree_extent_buffer(right);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\t\tfree_extent_buffer(path->nodes[0]);\n\t\t\tpath->nodes[0] = right;\n\t\t\tpath->slots[0] = 0;\n\t\t\tpath->slots[1] += 1;\n\t\t} else {\n\t\t\tbtrfs_set_header_nritems(right, 0);\n\t\t\tret = insert_ptr(trans, path, &disk_key,\n\t\t\t\t\t right->start, path->slots[1], 1);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_tree_unlock(right);\n\t\t\t\tfree_extent_buffer(right);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\t\tfree_extent_buffer(path->nodes[0]);\n\t\t\tpath->nodes[0] = right;\n\t\t\tpath->slots[0] = 0;\n\t\t\tif (path->slots[1] == 0)\n\t\t\t\tfixup_low_keys(trans, path, &disk_key, 1);\n\t\t}\n\t\t \n\t\treturn ret;\n\t}\n\n\tret = copy_for_split(trans, path, l, right, slot, mid, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t\treturn ret;\n\t}\n\n\tif (split == 2) {\n\t\tBUG_ON(num_doubles != 0);\n\t\tnum_doubles++;\n\t\tgoto again;\n\t}\n\n\treturn 0;\n\npush_for_double:\n\tpush_for_double_split(trans, root, path, data_size);\n\ttried_avoid_double = 1;\n\tif (btrfs_leaf_free_space(path->nodes[0]) >= data_size)\n\t\treturn 0;\n\tgoto again;\n}\n\nstatic noinline int setup_leaf_for_split(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct btrfs_path *path, int ins_len)\n{\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tu64 extent_len = 0;\n\tu32 item_size;\n\tint ret;\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\n\tBUG_ON(key.type != BTRFS_EXTENT_DATA_KEY &&\n\t       key.type != BTRFS_EXTENT_CSUM_KEY);\n\n\tif (btrfs_leaf_free_space(leaf) >= ins_len)\n\t\treturn 0;\n\n\titem_size = btrfs_item_size(leaf, path->slots[0]);\n\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\textent_len = btrfs_file_extent_num_bytes(leaf, fi);\n\t}\n\tbtrfs_release_path(path);\n\n\tpath->keep_locks = 1;\n\tpath->search_for_split = 1;\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tpath->search_for_split = 0;\n\tif (ret > 0)\n\t\tret = -EAGAIN;\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = -EAGAIN;\n\tleaf = path->nodes[0];\n\t \n\tif (item_size != btrfs_item_size(leaf, path->slots[0]))\n\t\tgoto err;\n\n\t \n\tif (btrfs_leaf_free_space(path->nodes[0]) >= ins_len)\n\t\tgoto err;\n\n\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tif (extent_len != btrfs_file_extent_num_bytes(leaf, fi))\n\t\t\tgoto err;\n\t}\n\n\tret = split_leaf(trans, root, &key, path, ins_len, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tpath->keep_locks = 0;\n\tbtrfs_unlock_up_safe(path, 1);\n\treturn 0;\nerr:\n\tpath->keep_locks = 0;\n\treturn ret;\n}\n\nstatic noinline int split_item(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       const struct btrfs_key *new_key,\n\t\t\t       unsigned long split_offset)\n{\n\tstruct extent_buffer *leaf;\n\tint orig_slot, slot;\n\tchar *buf;\n\tu32 nritems;\n\tu32 item_size;\n\tu32 orig_offset;\n\tstruct btrfs_disk_key disk_key;\n\n\tleaf = path->nodes[0];\n\t \n\tif (WARN_ON(btrfs_leaf_free_space(leaf) < sizeof(struct btrfs_item)))\n\t\treturn -ENOSPC;\n\n\torig_slot = path->slots[0];\n\torig_offset = btrfs_item_offset(leaf, path->slots[0]);\n\titem_size = btrfs_item_size(leaf, path->slots[0]);\n\n\tbuf = kmalloc(item_size, GFP_NOFS);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(leaf, buf, btrfs_item_ptr_offset(leaf,\n\t\t\t    path->slots[0]), item_size);\n\n\tslot = path->slots[0] + 1;\n\tnritems = btrfs_header_nritems(leaf);\n\tif (slot != nritems) {\n\t\t \n\t\tmemmove_leaf_items(leaf, slot + 1, slot, nritems - slot);\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(leaf, &disk_key, slot);\n\n\tbtrfs_set_item_offset(leaf, slot, orig_offset);\n\tbtrfs_set_item_size(leaf, slot, item_size - split_offset);\n\n\tbtrfs_set_item_offset(leaf, orig_slot,\n\t\t\t\t orig_offset + item_size - split_offset);\n\tbtrfs_set_item_size(leaf, orig_slot, split_offset);\n\n\tbtrfs_set_header_nritems(leaf, nritems + 1);\n\n\t \n\twrite_extent_buffer(leaf, buf,\n\t\t\t    btrfs_item_ptr_offset(leaf, path->slots[0]),\n\t\t\t    split_offset);\n\n\t \n\twrite_extent_buffer(leaf, buf + split_offset,\n\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t    item_size - split_offset);\n\tbtrfs_mark_buffer_dirty(trans, leaf);\n\n\tBUG_ON(btrfs_leaf_free_space(leaf) < 0);\n\tkfree(buf);\n\treturn 0;\n}\n\n \nint btrfs_split_item(struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_root *root,\n\t\t     struct btrfs_path *path,\n\t\t     const struct btrfs_key *new_key,\n\t\t     unsigned long split_offset)\n{\n\tint ret;\n\tret = setup_leaf_for_split(trans, root, path,\n\t\t\t\t   sizeof(struct btrfs_item));\n\tif (ret)\n\t\treturn ret;\n\n\tret = split_item(trans, path, new_key, split_offset);\n\treturn ret;\n}\n\n \nvoid btrfs_truncate_item(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_path *path, u32 new_size, int from_end)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data_start;\n\tunsigned int old_size;\n\tunsigned int size_diff;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\told_size = btrfs_item_size(leaf, slot);\n\tif (old_size == new_size)\n\t\treturn;\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(leaf);\n\n\told_data_start = btrfs_item_offset(leaf, slot);\n\n\tsize_diff = old_size - new_size;\n\n\tBUG_ON(slot < 0);\n\tBUG_ON(slot >= nritems);\n\n\t \n\t \n\tbtrfs_init_map_token(&token, leaf);\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\n\t\tioff = btrfs_token_item_offset(&token, i);\n\t\tbtrfs_set_token_item_offset(&token, i, ioff + size_diff);\n\t}\n\n\t \n\tif (from_end) {\n\t\tmemmove_leaf_data(leaf, data_end + size_diff, data_end,\n\t\t\t\t  old_data_start + new_size - data_end);\n\t} else {\n\t\tstruct btrfs_disk_key disk_key;\n\t\tu64 offset;\n\n\t\tbtrfs_item_key(leaf, &disk_key, slot);\n\n\t\tif (btrfs_disk_key_type(&disk_key) == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tunsigned long ptr;\n\t\t\tstruct btrfs_file_extent_item *fi;\n\n\t\t\tfi = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tfi = (struct btrfs_file_extent_item *)(\n\t\t\t     (unsigned long)fi - size_diff);\n\n\t\t\tif (btrfs_file_extent_type(leaf, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\t\t\tmemmove_extent_buffer(leaf, ptr,\n\t\t\t\t      (unsigned long)fi,\n\t\t\t\t      BTRFS_FILE_EXTENT_INLINE_DATA_START);\n\t\t\t}\n\t\t}\n\n\t\tmemmove_leaf_data(leaf, data_end + size_diff, data_end,\n\t\t\t\t  old_data_start - data_end);\n\n\t\toffset = btrfs_disk_key_offset(&disk_key);\n\t\tbtrfs_set_disk_key_offset(&disk_key, offset + size_diff);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot);\n\t\tif (slot == 0)\n\t\t\tfixup_low_keys(trans, path, &disk_key, 1);\n\t}\n\n\tbtrfs_set_item_size(leaf, slot, new_size);\n\tbtrfs_mark_buffer_dirty(trans, leaf);\n\n\tif (btrfs_leaf_free_space(leaf) < 0) {\n\t\tbtrfs_print_leaf(leaf);\n\t\tBUG();\n\t}\n}\n\n \nvoid btrfs_extend_item(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_path *path, u32 data_size)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data;\n\tunsigned int old_size;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tleaf = path->nodes[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(leaf);\n\n\tif (btrfs_leaf_free_space(leaf) < data_size) {\n\t\tbtrfs_print_leaf(leaf);\n\t\tBUG();\n\t}\n\tslot = path->slots[0];\n\told_data = btrfs_item_data_end(leaf, slot);\n\n\tBUG_ON(slot < 0);\n\tif (slot >= nritems) {\n\t\tbtrfs_print_leaf(leaf);\n\t\tbtrfs_crit(leaf->fs_info, \"slot %d too large, nritems %d\",\n\t\t\t   slot, nritems);\n\t\tBUG();\n\t}\n\n\t \n\t \n\tbtrfs_init_map_token(&token, leaf);\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\n\t\tioff = btrfs_token_item_offset(&token, i);\n\t\tbtrfs_set_token_item_offset(&token, i, ioff - data_size);\n\t}\n\n\t \n\tmemmove_leaf_data(leaf, data_end - data_size, data_end,\n\t\t\t  old_data - data_end);\n\n\tdata_end = old_data;\n\told_size = btrfs_item_size(leaf, slot);\n\tbtrfs_set_item_size(leaf, slot, old_size + data_size);\n\tbtrfs_mark_buffer_dirty(trans, leaf);\n\n\tif (btrfs_leaf_free_space(leaf) < 0) {\n\t\tbtrfs_print_leaf(leaf);\n\t\tBUG();\n\t}\n}\n\n \nstatic void setup_items_for_insert(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t\t   const struct btrfs_item_batch *batch)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint i;\n\tu32 nritems;\n\tunsigned int data_end;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_map_token token;\n\tu32 total_size;\n\n\t \n\tif (path->slots[0] == 0) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, &batch->keys[0]);\n\t\tfixup_low_keys(trans, path, &disk_key, 1);\n\t}\n\tbtrfs_unlock_up_safe(path, 1);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(leaf);\n\ttotal_size = batch->total_data_size + (batch->nr * sizeof(struct btrfs_item));\n\n\tif (btrfs_leaf_free_space(leaf) < total_size) {\n\t\tbtrfs_print_leaf(leaf);\n\t\tbtrfs_crit(fs_info, \"not enough freespace need %u have %d\",\n\t\t\t   total_size, btrfs_leaf_free_space(leaf));\n\t\tBUG();\n\t}\n\n\tbtrfs_init_map_token(&token, leaf);\n\tif (slot != nritems) {\n\t\tunsigned int old_data = btrfs_item_data_end(leaf, slot);\n\n\t\tif (old_data < data_end) {\n\t\t\tbtrfs_print_leaf(leaf);\n\t\t\tbtrfs_crit(fs_info,\n\t\t\"item at slot %d with data offset %u beyond data end of leaf %u\",\n\t\t\t\t   slot, old_data, data_end);\n\t\t\tBUG();\n\t\t}\n\t\t \n\t\t \n\t\tfor (i = slot; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\tioff = btrfs_token_item_offset(&token, i);\n\t\t\tbtrfs_set_token_item_offset(&token, i,\n\t\t\t\t\t\t       ioff - batch->total_data_size);\n\t\t}\n\t\t \n\t\tmemmove_leaf_items(leaf, slot + batch->nr, slot, nritems - slot);\n\n\t\t \n\t\tmemmove_leaf_data(leaf, data_end - batch->total_data_size,\n\t\t\t\t  data_end, old_data - data_end);\n\t\tdata_end = old_data;\n\t}\n\n\t \n\tfor (i = 0; i < batch->nr; i++) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, &batch->keys[i]);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot + i);\n\t\tdata_end -= batch->data_sizes[i];\n\t\tbtrfs_set_token_item_offset(&token, slot + i, data_end);\n\t\tbtrfs_set_token_item_size(&token, slot + i, batch->data_sizes[i]);\n\t}\n\n\tbtrfs_set_header_nritems(leaf, nritems + batch->nr);\n\tbtrfs_mark_buffer_dirty(trans, leaf);\n\n\tif (btrfs_leaf_free_space(leaf) < 0) {\n\t\tbtrfs_print_leaf(leaf);\n\t\tBUG();\n\t}\n}\n\n \nvoid btrfs_setup_item_for_insert(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path,\n\t\t\t\t const struct btrfs_key *key,\n\t\t\t\t u32 data_size)\n{\n\tstruct btrfs_item_batch batch;\n\n\tbatch.keys = key;\n\tbatch.data_sizes = &data_size;\n\tbatch.total_data_size = data_size;\n\tbatch.nr = 1;\n\n\tsetup_items_for_insert(trans, root, path, &batch);\n}\n\n \nint btrfs_insert_empty_items(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path,\n\t\t\t    const struct btrfs_item_batch *batch)\n{\n\tint ret = 0;\n\tint slot;\n\tu32 total_size;\n\n\ttotal_size = batch->total_data_size + (batch->nr * sizeof(struct btrfs_item));\n\tret = btrfs_search_slot(trans, root, &batch->keys[0], path, total_size, 1);\n\tif (ret == 0)\n\t\treturn -EEXIST;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tslot = path->slots[0];\n\tBUG_ON(slot < 0);\n\n\tsetup_items_for_insert(trans, root, path, batch);\n\treturn 0;\n}\n\n \nint btrfs_insert_item(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      const struct btrfs_key *cpu_key, void *data,\n\t\t      u32 data_size)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = btrfs_insert_empty_item(trans, root, path, cpu_key, data_size);\n\tif (!ret) {\n\t\tleaf = path->nodes[0];\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\twrite_extent_buffer(leaf, data, ptr, data_size);\n\t\tbtrfs_mark_buffer_dirty(trans, leaf);\n\t}\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nint btrfs_duplicate_item(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t struct btrfs_path *path,\n\t\t\t const struct btrfs_key *new_key)\n{\n\tstruct extent_buffer *leaf;\n\tint ret;\n\tu32 item_size;\n\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size(leaf, path->slots[0]);\n\tret = setup_leaf_for_split(trans, root, path,\n\t\t\t\t   item_size + sizeof(struct btrfs_item));\n\tif (ret)\n\t\treturn ret;\n\n\tpath->slots[0]++;\n\tbtrfs_setup_item_for_insert(trans, root, path, new_key, item_size);\n\tleaf = path->nodes[0];\n\tmemcpy_extent_buffer(leaf,\n\t\t\t     btrfs_item_ptr_offset(leaf, path->slots[0]),\n\t\t\t     btrfs_item_ptr_offset(leaf, path->slots[0] - 1),\n\t\t\t     item_size);\n\treturn 0;\n}\n\n \nint btrfs_del_ptr(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t  struct btrfs_path *path, int level, int slot)\n{\n\tstruct extent_buffer *parent = path->nodes[level];\n\tu32 nritems;\n\tint ret;\n\n\tnritems = btrfs_header_nritems(parent);\n\tif (slot != nritems - 1) {\n\t\tif (level) {\n\t\t\tret = btrfs_tree_mod_log_insert_move(parent, slot,\n\t\t\t\t\tslot + 1, nritems - slot - 1);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tmemmove_extent_buffer(parent,\n\t\t\t      btrfs_node_key_ptr_offset(parent, slot),\n\t\t\t      btrfs_node_key_ptr_offset(parent, slot + 1),\n\t\t\t      sizeof(struct btrfs_key_ptr) *\n\t\t\t      (nritems - slot - 1));\n\t} else if (level) {\n\t\tret = btrfs_tree_mod_log_insert_key(parent, slot,\n\t\t\t\t\t\t    BTRFS_MOD_LOG_KEY_REMOVE);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tnritems--;\n\tbtrfs_set_header_nritems(parent, nritems);\n\tif (nritems == 0 && parent == root->node) {\n\t\tBUG_ON(btrfs_header_level(root->node) != 1);\n\t\t \n\t\tbtrfs_set_header_level(root->node, 0);\n\t} else if (slot == 0) {\n\t\tstruct btrfs_disk_key disk_key;\n\n\t\tbtrfs_node_key(parent, &disk_key, 0);\n\t\tfixup_low_keys(trans, path, &disk_key, level + 1);\n\t}\n\tbtrfs_mark_buffer_dirty(trans, parent);\n\treturn 0;\n}\n\n \nstatic noinline int btrfs_del_leaf(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint ret;\n\n\tWARN_ON(btrfs_header_generation(leaf) != trans->transid);\n\tret = btrfs_del_ptr(trans, root, path, 1, path->slots[1]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbtrfs_unlock_up_safe(path, 0);\n\n\troot_sub_used(root, leaf->len);\n\n\tatomic_inc(&leaf->refs);\n\tbtrfs_free_tree_block(trans, btrfs_root_id(root), leaf, 0, 1);\n\tfree_extent_buffer_stale(leaf);\n\treturn 0;\n}\n \nint btrfs_del_items(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t    struct btrfs_path *path, int slot, int nr)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct extent_buffer *leaf;\n\tint ret = 0;\n\tint wret;\n\tu32 nritems;\n\n\tleaf = path->nodes[0];\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (slot + nr != nritems) {\n\t\tconst u32 last_off = btrfs_item_offset(leaf, slot + nr - 1);\n\t\tconst int data_end = leaf_data_end(leaf);\n\t\tstruct btrfs_map_token token;\n\t\tu32 dsize = 0;\n\t\tint i;\n\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tdsize += btrfs_item_size(leaf, slot + i);\n\n\t\tmemmove_leaf_data(leaf, data_end + dsize, data_end,\n\t\t\t\t  last_off - data_end);\n\n\t\tbtrfs_init_map_token(&token, leaf);\n\t\tfor (i = slot + nr; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\tioff = btrfs_token_item_offset(&token, i);\n\t\t\tbtrfs_set_token_item_offset(&token, i, ioff + dsize);\n\t\t}\n\n\t\tmemmove_leaf_items(leaf, slot, slot + nr, nritems - slot - nr);\n\t}\n\tbtrfs_set_header_nritems(leaf, nritems - nr);\n\tnritems -= nr;\n\n\t \n\tif (nritems == 0) {\n\t\tif (leaf == root->node) {\n\t\t\tbtrfs_set_header_level(leaf, 0);\n\t\t} else {\n\t\t\tbtrfs_clear_buffer_dirty(trans, leaf);\n\t\t\tret = btrfs_del_leaf(trans, root, path, leaf);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tint used = leaf_space_used(leaf, 0, nritems);\n\t\tif (slot == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\n\t\t\tbtrfs_item_key(leaf, &disk_key, 0);\n\t\t\tfixup_low_keys(trans, path, &disk_key, 1);\n\t\t}\n\n\t\t \n\t\tif (used < BTRFS_LEAF_DATA_SIZE(fs_info) / 3) {\n\t\t\tu32 min_push_space;\n\n\t\t\t \n\t\t\tslot = path->slots[1];\n\t\t\tatomic_inc(&leaf->refs);\n\t\t\t \n\t\t\tmin_push_space = sizeof(struct btrfs_item) +\n\t\t\t\tbtrfs_item_size(leaf, 0);\n\t\t\twret = push_leaf_left(trans, root, path, 0,\n\t\t\t\t\t      min_push_space, 1, (u32)-1);\n\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\tret = wret;\n\n\t\t\tif (path->nodes[0] == leaf &&\n\t\t\t    btrfs_header_nritems(leaf)) {\n\t\t\t\t \n\t\t\t\tnritems = btrfs_header_nritems(leaf);\n\t\t\t\tmin_push_space = leaf_space_used(leaf, 0, nritems);\n\t\t\t\twret = push_leaf_right(trans, root, path, 0,\n\t\t\t\t\t\t       min_push_space, 1, 0);\n\t\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\t\tret = wret;\n\t\t\t}\n\n\t\t\tif (btrfs_header_nritems(leaf) == 0) {\n\t\t\t\tpath->slots[1] = slot;\n\t\t\t\tret = btrfs_del_leaf(trans, root, path, leaf);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (path->nodes[0] == leaf)\n\t\t\t\t\tbtrfs_mark_buffer_dirty(trans, leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t}\n\t\t} else {\n\t\t\tbtrfs_mark_buffer_dirty(trans, leaf);\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nint btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,\n\t\t\t struct btrfs_path *path,\n\t\t\t u64 min_trans)\n{\n\tstruct extent_buffer *cur;\n\tstruct btrfs_key found_key;\n\tint slot;\n\tint sret;\n\tu32 nritems;\n\tint level;\n\tint ret = 1;\n\tint keep_locks = path->keep_locks;\n\n\tASSERT(!path->nowait);\n\tpath->keep_locks = 1;\nagain:\n\tcur = btrfs_read_lock_root_node(root);\n\tlevel = btrfs_header_level(cur);\n\tWARN_ON(path->nodes[level]);\n\tpath->nodes[level] = cur;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\tif (btrfs_header_generation(cur) < min_trans) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnritems = btrfs_header_nritems(cur);\n\t\tlevel = btrfs_header_level(cur);\n\t\tsret = btrfs_bin_search(cur, 0, min_key, &slot);\n\t\tif (sret < 0) {\n\t\t\tret = sret;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (level == path->lowest_level) {\n\t\t\tif (slot >= nritems)\n\t\t\t\tgoto find_next_key;\n\t\t\tret = 0;\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_item_key_to_cpu(cur, &found_key, slot);\n\t\t\tgoto out;\n\t\t}\n\t\tif (sret && slot > 0)\n\t\t\tslot--;\n\t\t \n\t\twhile (slot < nritems) {\n\t\t\tu64 gen;\n\n\t\t\tgen = btrfs_node_ptr_generation(cur, slot);\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nfind_next_key:\n\t\t \n\t\tif (slot >= nritems) {\n\t\t\tpath->slots[level] = slot;\n\t\t\tsret = btrfs_find_next_key(root, path, min_key, level,\n\t\t\t\t\t\t  min_trans);\n\t\t\tif (sret == 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t \n\t\tbtrfs_node_key_to_cpu(cur, &found_key, slot);\n\t\tpath->slots[level] = slot;\n\t\tif (level == path->lowest_level) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tcur = btrfs_read_node_slot(cur, slot);\n\t\tif (IS_ERR(cur)) {\n\t\t\tret = PTR_ERR(cur);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbtrfs_tree_read_lock(cur);\n\n\t\tpath->locks[level - 1] = BTRFS_READ_LOCK;\n\t\tpath->nodes[level - 1] = cur;\n\t\tunlock_up(path, level, 1, 0, NULL);\n\t}\nout:\n\tpath->keep_locks = keep_locks;\n\tif (ret == 0) {\n\t\tbtrfs_unlock_up_safe(path, path->lowest_level + 1);\n\t\tmemcpy(min_key, &found_key, sizeof(found_key));\n\t}\n\treturn ret;\n}\n\n \nint btrfs_find_next_key(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\tstruct btrfs_key *key, int level, u64 min_trans)\n{\n\tint slot;\n\tstruct extent_buffer *c;\n\n\tWARN_ON(!path->keep_locks && !path->skip_locking);\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level])\n\t\t\treturn 1;\n\n\t\tslot = path->slots[level] + 1;\n\t\tc = path->nodes[level];\nnext:\n\t\tif (slot >= btrfs_header_nritems(c)) {\n\t\t\tint ret;\n\t\t\tint orig_lowest;\n\t\t\tstruct btrfs_key cur_key;\n\t\t\tif (level + 1 >= BTRFS_MAX_LEVEL ||\n\t\t\t    !path->nodes[level + 1])\n\t\t\t\treturn 1;\n\n\t\t\tif (path->locks[level + 1] || path->skip_locking) {\n\t\t\t\tlevel++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tslot = btrfs_header_nritems(c) - 1;\n\t\t\tif (level == 0)\n\t\t\t\tbtrfs_item_key_to_cpu(c, &cur_key, slot);\n\t\t\telse\n\t\t\t\tbtrfs_node_key_to_cpu(c, &cur_key, slot);\n\n\t\t\torig_lowest = path->lowest_level;\n\t\t\tbtrfs_release_path(path);\n\t\t\tpath->lowest_level = level;\n\t\t\tret = btrfs_search_slot(NULL, root, &cur_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tpath->lowest_level = orig_lowest;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tc = path->nodes[level];\n\t\t\tslot = path->slots[level];\n\t\t\tif (ret == 0)\n\t\t\t\tslot++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (level == 0)\n\t\t\tbtrfs_item_key_to_cpu(c, key, slot);\n\t\telse {\n\t\t\tu64 gen = btrfs_node_ptr_generation(c, slot);\n\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tbtrfs_node_key_to_cpu(c, key, slot);\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint btrfs_next_old_leaf(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\tu64 time_seq)\n{\n\tint slot;\n\tint level;\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *next;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_key key;\n\tbool need_commit_sem = false;\n\tu32 nritems;\n\tint ret;\n\tint i;\n\n\t \n\tif (time_seq)\n\t\tASSERT(!path->nowait);\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\tif (nritems == 0)\n\t\treturn 1;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, nritems - 1);\nagain:\n\tlevel = 1;\n\tnext = NULL;\n\tbtrfs_release_path(path);\n\n\tpath->keep_locks = 1;\n\n\tif (time_seq) {\n\t\tret = btrfs_search_old_slot(root, &key, path, time_seq);\n\t} else {\n\t\tif (path->need_commit_sem) {\n\t\t\tpath->need_commit_sem = 0;\n\t\t\tneed_commit_sem = true;\n\t\t\tif (path->nowait) {\n\t\t\t\tif (!down_read_trylock(&fs_info->commit_root_sem)) {\n\t\t\t\t\tret = -EAGAIN;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdown_read(&fs_info->commit_root_sem);\n\t\t\t}\n\t\t}\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t}\n\tpath->keep_locks = 0;\n\n\tif (ret < 0)\n\t\tgoto done;\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t \n\tif (nritems > 0 && path->slots[0] < nritems - 1) {\n\t\tif (ret == 0)\n\t\t\tpath->slots[0]++;\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\t \n\tif (nritems > 0 && ret > 0 && path->slots[0] == nritems - 1) {\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level]) {\n\t\t\tret = 1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tslot = path->slots[level] + 1;\n\t\tc = path->nodes[level];\n\t\tif (slot >= btrfs_header_nritems(c)) {\n\t\t\tlevel++;\n\t\t\tif (level == BTRFS_MAX_LEVEL) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t \n\t\tfor (i = 0; i < level; i++) {\n\t\t\tif (path->locks[level]) {\n\t\t\t\tbtrfs_tree_read_unlock(path->nodes[i]);\n\t\t\t\tpath->locks[i] = 0;\n\t\t\t}\n\t\t\tfree_extent_buffer(path->nodes[i]);\n\t\t\tpath->nodes[i] = NULL;\n\t\t}\n\n\t\tnext = c;\n\t\tret = read_block_for_search(root, path, &next, level,\n\t\t\t\t\t    slot, &key);\n\t\tif (ret == -EAGAIN && !path->nowait)\n\t\t\tgoto again;\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!path->skip_locking) {\n\t\t\tret = btrfs_try_tree_read_lock(next);\n\t\t\tif (!ret && path->nowait) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (!ret && time_seq) {\n\t\t\t\t \n\t\t\t\tfree_extent_buffer(next);\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tcond_resched();\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tbtrfs_tree_read_lock(next);\n\t\t}\n\t\tbreak;\n\t}\n\tpath->slots[level] = slot;\n\twhile (1) {\n\t\tlevel--;\n\t\tpath->nodes[level] = next;\n\t\tpath->slots[level] = 0;\n\t\tif (!path->skip_locking)\n\t\t\tpath->locks[level] = BTRFS_READ_LOCK;\n\t\tif (!level)\n\t\t\tbreak;\n\n\t\tret = read_block_for_search(root, path, &next, level,\n\t\t\t\t\t    0, &key);\n\t\tif (ret == -EAGAIN && !path->nowait)\n\t\t\tgoto again;\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!path->skip_locking) {\n\t\t\tif (path->nowait) {\n\t\t\t\tif (!btrfs_try_tree_read_lock(next)) {\n\t\t\t\t\tret = -EAGAIN;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbtrfs_tree_read_lock(next);\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\ndone:\n\tunlock_up(path, 0, 1, 0, NULL);\n\tif (need_commit_sem) {\n\t\tint ret2;\n\n\t\tpath->need_commit_sem = 1;\n\t\tret2 = finish_need_commit_sem_search(path);\n\t\tup_read(&fs_info->commit_root_sem);\n\t\tif (ret2)\n\t\t\tret = ret2;\n\t}\n\n\treturn ret;\n}\n\nint btrfs_next_old_item(struct btrfs_root *root, struct btrfs_path *path, u64 time_seq)\n{\n\tpath->slots[0]++;\n\tif (path->slots[0] >= btrfs_header_nritems(path->nodes[0]))\n\t\treturn btrfs_next_old_leaf(root, path, time_seq);\n\treturn 0;\n}\n\n \nint btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}\n\n \nint btrfs_previous_extent_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == BTRFS_EXTENT_ITEM_KEY ||\n\t\t    found_key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < BTRFS_EXTENT_ITEM_KEY)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}\n\nint __init btrfs_ctree_init(void)\n{\n\tbtrfs_path_cachep = kmem_cache_create(\"btrfs_path\",\n\t\t\tsizeof(struct btrfs_path), 0,\n\t\t\tSLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_path_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid __cold btrfs_ctree_exit(void)\n{\n\tkmem_cache_destroy(btrfs_path_cachep);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}