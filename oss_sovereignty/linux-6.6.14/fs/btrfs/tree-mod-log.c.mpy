{
  "module_name": "tree-mod-log.c",
  "hash_id": "3f462ab9dd435d3ad34bbae853dcb67170bcf46d7afefb2dc8428ef642fcbeeb",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/tree-mod-log.c",
  "human_readable_source": "\n\n#include \"messages.h\"\n#include \"tree-mod-log.h\"\n#include \"disk-io.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n#include \"tree-checker.h\"\n\nstruct tree_mod_root {\n\tu64 logical;\n\tu8 level;\n};\n\nstruct tree_mod_elem {\n\tstruct rb_node node;\n\tu64 logical;\n\tu64 seq;\n\tenum btrfs_mod_log_op op;\n\n\t \n\tint slot;\n\n\t \n\tu64 generation;\n\n\t \n\tstruct btrfs_disk_key key;\n\tu64 blockptr;\n\n\t \n\tstruct {\n\t\tint dst_slot;\n\t\tint nr_items;\n\t} move;\n\n\t \n\tstruct tree_mod_root old_root;\n};\n\n \nstatic inline u64 btrfs_inc_tree_mod_seq(struct btrfs_fs_info *fs_info)\n{\n\treturn atomic64_inc_return(&fs_info->tree_mod_seq);\n}\n\n \nu64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_seq_list *elem)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t\tset_bit(BTRFS_FS_TREE_MOD_LOG_USERS, &fs_info->flags);\n\t}\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n\n\treturn elem->seq;\n}\n\nvoid btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct btrfs_seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = BTRFS_SEQ_LAST;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\twrite_lock(&fs_info->tree_mod_log_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tif (list_empty(&fs_info->tree_mod_seq_list)) {\n\t\tclear_bit(BTRFS_FS_TREE_MOD_LOG_USERS, &fs_info->flags);\n\t} else {\n\t\tstruct btrfs_seq_list *first;\n\n\t\tfirst = list_first_entry(&fs_info->tree_mod_seq_list,\n\t\t\t\t\t struct btrfs_seq_list, list);\n\t\tif (seq_putting > first->seq) {\n\t\t\t \n\t\t\twrite_unlock(&fs_info->tree_mod_log_lock);\n\t\t\treturn;\n\t\t}\n\t\tmin_seq = first->seq;\n\t}\n\n\t \n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = rb_entry(node, struct tree_mod_elem, node);\n\t\tif (tm->seq >= min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}\n\n \nstatic noinline int tree_mod_log_insert(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tstruct tree_mod_elem *tm)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_mod_elem *cur;\n\n\tlockdep_assert_held_write(&fs_info->tree_mod_log_lock);\n\n\ttm->seq = btrfs_inc_tree_mod_seq(fs_info);\n\n\ttm_root = &fs_info->tree_mod_log;\n\tnew = &tm_root->rb_node;\n\twhile (*new) {\n\t\tcur = rb_entry(*new, struct tree_mod_elem, node);\n\t\tparent = *new;\n\t\tif (cur->logical < tm->logical)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->logical > tm->logical)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse if (cur->seq < tm->seq)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->seq > tm->seq)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&tm->node, parent, new);\n\trb_insert_color(&tm->node, tm_root);\n\treturn 0;\n}\n\n \nstatic inline bool tree_mod_dont_log(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb)\n{\n\tif (!test_bit(BTRFS_FS_TREE_MOD_LOG_USERS, &fs_info->flags))\n\t\treturn true;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn true;\n\n\twrite_lock(&fs_info->tree_mod_log_lock);\n\tif (list_empty(&(fs_info)->tree_mod_seq_list)) {\n\t\twrite_unlock(&fs_info->tree_mod_log_lock);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic inline bool tree_mod_need_log(const struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb)\n{\n\tif (!test_bit(BTRFS_FS_TREE_MOD_LOG_USERS, &fs_info->flags))\n\t\treturn false;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct tree_mod_elem *alloc_tree_mod_elem(struct extent_buffer *eb,\n\t\t\t\t\t\t int slot,\n\t\t\t\t\t\t enum btrfs_mod_log_op op)\n{\n\tstruct tree_mod_elem *tm;\n\n\ttm = kzalloc(sizeof(*tm), GFP_NOFS);\n\tif (!tm)\n\t\treturn NULL;\n\n\ttm->logical = eb->start;\n\tif (op != BTRFS_MOD_LOG_KEY_ADD) {\n\t\tbtrfs_node_key(eb, &tm->key, slot);\n\t\ttm->blockptr = btrfs_node_blockptr(eb, slot);\n\t}\n\ttm->op = op;\n\ttm->slot = slot;\n\ttm->generation = btrfs_node_ptr_generation(eb, slot);\n\tRB_CLEAR_NODE(&tm->node);\n\n\treturn tm;\n}\n\nint btrfs_tree_mod_log_insert_key(struct extent_buffer *eb, int slot,\n\t\t\t\t  enum btrfs_mod_log_op op)\n{\n\tstruct tree_mod_elem *tm;\n\tint ret = 0;\n\n\tif (!tree_mod_need_log(eb->fs_info, eb))\n\t\treturn 0;\n\n\ttm = alloc_tree_mod_elem(eb, slot, op);\n\tif (!tm)\n\t\tret = -ENOMEM;\n\n\tif (tree_mod_dont_log(eb->fs_info, eb)) {\n\t\tkfree(tm);\n\t\t \n\t\treturn 0;\n\t} else if (ret != 0) {\n\t\t \n\t\tgoto out_unlock;\n\t}\n\n\tret = tree_mod_log_insert(eb->fs_info, tm);\nout_unlock:\n\twrite_unlock(&eb->fs_info->tree_mod_log_lock);\n\tif (ret)\n\t\tkfree(tm);\n\n\treturn ret;\n}\n\nstatic struct tree_mod_elem *tree_mod_log_alloc_move(struct extent_buffer *eb,\n\t\t\t\t\t\t     int dst_slot, int src_slot,\n\t\t\t\t\t\t     int nr_items)\n{\n\tstruct tree_mod_elem *tm;\n\n\ttm = kzalloc(sizeof(*tm), GFP_NOFS);\n\tif (!tm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttm->logical = eb->start;\n\ttm->slot = src_slot;\n\ttm->move.dst_slot = dst_slot;\n\ttm->move.nr_items = nr_items;\n\ttm->op = BTRFS_MOD_LOG_MOVE_KEYS;\n\tRB_CLEAR_NODE(&tm->node);\n\n\treturn tm;\n}\n\nint btrfs_tree_mod_log_insert_move(struct extent_buffer *eb,\n\t\t\t\t   int dst_slot, int src_slot,\n\t\t\t\t   int nr_items)\n{\n\tstruct tree_mod_elem *tm = NULL;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tint ret = 0;\n\tint i;\n\tbool locked = false;\n\n\tif (!tree_mod_need_log(eb->fs_info, eb))\n\t\treturn 0;\n\n\ttm_list = kcalloc(nr_items, sizeof(struct tree_mod_elem *), GFP_NOFS);\n\tif (!tm_list) {\n\t\tret = -ENOMEM;\n\t\tgoto lock;\n\t}\n\n\ttm = tree_mod_log_alloc_move(eb, dst_slot, src_slot, nr_items);\n\tif (IS_ERR(tm)) {\n\t\tret = PTR_ERR(tm);\n\t\ttm = NULL;\n\t\tgoto lock;\n\t}\n\n\tfor (i = 0; i + dst_slot < src_slot && i < nr_items; i++) {\n\t\ttm_list[i] = alloc_tree_mod_elem(eb, i + dst_slot,\n\t\t\t\tBTRFS_MOD_LOG_KEY_REMOVE_WHILE_MOVING);\n\t\tif (!tm_list[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto lock;\n\t\t}\n\t}\n\nlock:\n\tif (tree_mod_dont_log(eb->fs_info, eb)) {\n\t\t \n\t\tret = 0;\n\t\tgoto free_tms;\n\t}\n\tlocked = true;\n\n\t \n\tif (ret != 0)\n\t\tgoto free_tms;\n\n\t \n\tfor (i = 0; i + dst_slot < src_slot && i < nr_items; i++) {\n\t\tret = tree_mod_log_insert(eb->fs_info, tm_list[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t}\n\n\tret = tree_mod_log_insert(eb->fs_info, tm);\n\tif (ret)\n\t\tgoto free_tms;\n\twrite_unlock(&eb->fs_info->tree_mod_log_lock);\n\tkfree(tm_list);\n\n\treturn 0;\n\nfree_tms:\n\tif (tm_list) {\n\t\tfor (i = 0; i < nr_items; i++) {\n\t\t\tif (tm_list[i] && !RB_EMPTY_NODE(&tm_list[i]->node))\n\t\t\t\trb_erase(&tm_list[i]->node, &eb->fs_info->tree_mod_log);\n\t\t\tkfree(tm_list[i]);\n\t\t}\n\t}\n\tif (locked)\n\t\twrite_unlock(&eb->fs_info->tree_mod_log_lock);\n\tkfree(tm_list);\n\tkfree(tm);\n\n\treturn ret;\n}\n\nstatic inline int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t       struct tree_mod_elem **tm_list,\n\t\t\t\t       int nritems)\n{\n\tint i, j;\n\tint ret;\n\n\tfor (i = nritems - 1; i >= 0; i--) {\n\t\tret = tree_mod_log_insert(fs_info, tm_list[i]);\n\t\tif (ret) {\n\t\t\tfor (j = nritems - 1; j > i; j--)\n\t\t\t\trb_erase(&tm_list[j]->node,\n\t\t\t\t\t &fs_info->tree_mod_log);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint btrfs_tree_mod_log_insert_root(struct extent_buffer *old_root,\n\t\t\t\t   struct extent_buffer *new_root,\n\t\t\t\t   bool log_removal)\n{\n\tstruct btrfs_fs_info *fs_info = old_root->fs_info;\n\tstruct tree_mod_elem *tm = NULL;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tint nritems = 0;\n\tint ret = 0;\n\tint i;\n\n\tif (!tree_mod_need_log(fs_info, NULL))\n\t\treturn 0;\n\n\tif (log_removal && btrfs_header_level(old_root) > 0) {\n\t\tnritems = btrfs_header_nritems(old_root);\n\t\ttm_list = kcalloc(nritems, sizeof(struct tree_mod_elem *),\n\t\t\t\t  GFP_NOFS);\n\t\tif (!tm_list) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto lock;\n\t\t}\n\t\tfor (i = 0; i < nritems; i++) {\n\t\t\ttm_list[i] = alloc_tree_mod_elem(old_root, i,\n\t\t\t    BTRFS_MOD_LOG_KEY_REMOVE_WHILE_FREEING);\n\t\t\tif (!tm_list[i]) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto lock;\n\t\t\t}\n\t\t}\n\t}\n\n\ttm = kzalloc(sizeof(*tm), GFP_NOFS);\n\tif (!tm) {\n\t\tret = -ENOMEM;\n\t\tgoto lock;\n\t}\n\n\ttm->logical = new_root->start;\n\ttm->old_root.logical = old_root->start;\n\ttm->old_root.level = btrfs_header_level(old_root);\n\ttm->generation = btrfs_header_generation(old_root);\n\ttm->op = BTRFS_MOD_LOG_ROOT_REPLACE;\n\nlock:\n\tif (tree_mod_dont_log(fs_info, NULL)) {\n\t\t \n\t\tret = 0;\n\t\tgoto free_tms;\n\t} else if (ret != 0) {\n\t\t \n\t\tgoto out_unlock;\n\t}\n\n\tif (tm_list)\n\t\tret = tree_mod_log_free_eb(fs_info, tm_list, nritems);\n\tif (!ret)\n\t\tret = tree_mod_log_insert(fs_info, tm);\n\nout_unlock:\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n\tif (ret)\n\t\tgoto free_tms;\n\tkfree(tm_list);\n\n\treturn ret;\n\nfree_tms:\n\tif (tm_list) {\n\t\tfor (i = 0; i < nritems; i++)\n\t\t\tkfree(tm_list[i]);\n\t\tkfree(tm_list);\n\t}\n\tkfree(tm);\n\n\treturn ret;\n}\n\nstatic struct tree_mod_elem *__tree_mod_log_search(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\t   u64 start, u64 min_seq,\n\t\t\t\t\t\t   bool smallest)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct tree_mod_elem *cur = NULL;\n\tstruct tree_mod_elem *found = NULL;\n\n\tread_lock(&fs_info->tree_mod_log_lock);\n\ttm_root = &fs_info->tree_mod_log;\n\tnode = tm_root->rb_node;\n\twhile (node) {\n\t\tcur = rb_entry(node, struct tree_mod_elem, node);\n\t\tif (cur->logical < start) {\n\t\t\tnode = node->rb_left;\n\t\t} else if (cur->logical > start) {\n\t\t\tnode = node->rb_right;\n\t\t} else if (cur->seq < min_seq) {\n\t\t\tnode = node->rb_left;\n\t\t} else if (!smallest) {\n\t\t\t \n\t\t\tif (found)\n\t\t\t\tBUG_ON(found->seq > cur->seq);\n\t\t\tfound = cur;\n\t\t\tnode = node->rb_left;\n\t\t} else if (cur->seq > min_seq) {\n\t\t\t \n\t\t\tif (found)\n\t\t\t\tBUG_ON(found->seq < cur->seq);\n\t\t\tfound = cur;\n\t\t\tnode = node->rb_right;\n\t\t} else {\n\t\t\tfound = cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&fs_info->tree_mod_log_lock);\n\n\treturn found;\n}\n\n \nstatic struct tree_mod_elem *tree_mod_log_search_oldest(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\t\tu64 start, u64 min_seq)\n{\n\treturn __tree_mod_log_search(fs_info, start, min_seq, true);\n}\n\n \nstatic struct tree_mod_elem *tree_mod_log_search(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\t u64 start, u64 min_seq)\n{\n\treturn __tree_mod_log_search(fs_info, start, min_seq, false);\n}\n\nint btrfs_tree_mod_log_eb_copy(struct extent_buffer *dst,\n\t\t\t       struct extent_buffer *src,\n\t\t\t       unsigned long dst_offset,\n\t\t\t       unsigned long src_offset,\n\t\t\t       int nr_items)\n{\n\tstruct btrfs_fs_info *fs_info = dst->fs_info;\n\tint ret = 0;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tstruct tree_mod_elem **tm_list_add = NULL;\n\tstruct tree_mod_elem **tm_list_rem = NULL;\n\tint i;\n\tbool locked = false;\n\tstruct tree_mod_elem *dst_move_tm = NULL;\n\tstruct tree_mod_elem *src_move_tm = NULL;\n\tu32 dst_move_nr_items = btrfs_header_nritems(dst) - dst_offset;\n\tu32 src_move_nr_items = btrfs_header_nritems(src) - (src_offset + nr_items);\n\n\tif (!tree_mod_need_log(fs_info, NULL))\n\t\treturn 0;\n\n\tif (btrfs_header_level(dst) == 0 && btrfs_header_level(src) == 0)\n\t\treturn 0;\n\n\ttm_list = kcalloc(nr_items * 2, sizeof(struct tree_mod_elem *),\n\t\t\t  GFP_NOFS);\n\tif (!tm_list) {\n\t\tret = -ENOMEM;\n\t\tgoto lock;\n\t}\n\n\tif (dst_move_nr_items) {\n\t\tdst_move_tm = tree_mod_log_alloc_move(dst, dst_offset + nr_items,\n\t\t\t\t\t\t      dst_offset, dst_move_nr_items);\n\t\tif (IS_ERR(dst_move_tm)) {\n\t\t\tret = PTR_ERR(dst_move_tm);\n\t\t\tdst_move_tm = NULL;\n\t\t\tgoto lock;\n\t\t}\n\t}\n\tif (src_move_nr_items) {\n\t\tsrc_move_tm = tree_mod_log_alloc_move(src, src_offset,\n\t\t\t\t\t\t      src_offset + nr_items,\n\t\t\t\t\t\t      src_move_nr_items);\n\t\tif (IS_ERR(src_move_tm)) {\n\t\t\tret = PTR_ERR(src_move_tm);\n\t\t\tsrc_move_tm = NULL;\n\t\t\tgoto lock;\n\t\t}\n\t}\n\n\ttm_list_add = tm_list;\n\ttm_list_rem = tm_list + nr_items;\n\tfor (i = 0; i < nr_items; i++) {\n\t\ttm_list_rem[i] = alloc_tree_mod_elem(src, i + src_offset,\n\t\t\t\t\t\t     BTRFS_MOD_LOG_KEY_REMOVE);\n\t\tif (!tm_list_rem[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto lock;\n\t\t}\n\n\t\ttm_list_add[i] = alloc_tree_mod_elem(dst, i + dst_offset,\n\t\t\t\t\t\t     BTRFS_MOD_LOG_KEY_ADD);\n\t\tif (!tm_list_add[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto lock;\n\t\t}\n\t}\n\nlock:\n\tif (tree_mod_dont_log(fs_info, NULL)) {\n\t\t \n\t\tret = 0;\n\t\tgoto free_tms;\n\t}\n\tlocked = true;\n\n\t \n\tif (ret != 0)\n\t\tgoto free_tms;\n\n\tif (dst_move_tm) {\n\t\tret = tree_mod_log_insert(fs_info, dst_move_tm);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t}\n\tfor (i = 0; i < nr_items; i++) {\n\t\tret = tree_mod_log_insert(fs_info, tm_list_rem[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t\tret = tree_mod_log_insert(fs_info, tm_list_add[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t}\n\tif (src_move_tm) {\n\t\tret = tree_mod_log_insert(fs_info, src_move_tm);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t}\n\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n\tkfree(tm_list);\n\n\treturn 0;\n\nfree_tms:\n\tif (dst_move_tm && !RB_EMPTY_NODE(&dst_move_tm->node))\n\t\trb_erase(&dst_move_tm->node, &fs_info->tree_mod_log);\n\tkfree(dst_move_tm);\n\tif (src_move_tm && !RB_EMPTY_NODE(&src_move_tm->node))\n\t\trb_erase(&src_move_tm->node, &fs_info->tree_mod_log);\n\tkfree(src_move_tm);\n\tif (tm_list) {\n\t\tfor (i = 0; i < nr_items * 2; i++) {\n\t\t\tif (tm_list[i] && !RB_EMPTY_NODE(&tm_list[i]->node))\n\t\t\t\trb_erase(&tm_list[i]->node, &fs_info->tree_mod_log);\n\t\t\tkfree(tm_list[i]);\n\t\t}\n\t}\n\tif (locked)\n\t\twrite_unlock(&fs_info->tree_mod_log_lock);\n\tkfree(tm_list);\n\n\treturn ret;\n}\n\nint btrfs_tree_mod_log_free_eb(struct extent_buffer *eb)\n{\n\tstruct tree_mod_elem **tm_list = NULL;\n\tint nritems = 0;\n\tint i;\n\tint ret = 0;\n\n\tif (!tree_mod_need_log(eb->fs_info, eb))\n\t\treturn 0;\n\n\tnritems = btrfs_header_nritems(eb);\n\ttm_list = kcalloc(nritems, sizeof(struct tree_mod_elem *), GFP_NOFS);\n\tif (!tm_list) {\n\t\tret = -ENOMEM;\n\t\tgoto lock;\n\t}\n\n\tfor (i = 0; i < nritems; i++) {\n\t\ttm_list[i] = alloc_tree_mod_elem(eb, i,\n\t\t\t\t    BTRFS_MOD_LOG_KEY_REMOVE_WHILE_FREEING);\n\t\tif (!tm_list[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto lock;\n\t\t}\n\t}\n\nlock:\n\tif (tree_mod_dont_log(eb->fs_info, eb)) {\n\t\t \n\t\tret = 0;\n\t\tgoto free_tms;\n\t} else if (ret != 0) {\n\t\t \n\t\tgoto out_unlock;\n\t}\n\n\tret = tree_mod_log_free_eb(eb->fs_info, tm_list, nritems);\nout_unlock:\n\twrite_unlock(&eb->fs_info->tree_mod_log_lock);\n\tif (ret)\n\t\tgoto free_tms;\n\tkfree(tm_list);\n\n\treturn 0;\n\nfree_tms:\n\tif (tm_list) {\n\t\tfor (i = 0; i < nritems; i++)\n\t\t\tkfree(tm_list[i]);\n\t\tkfree(tm_list);\n\t}\n\n\treturn ret;\n}\n\n \nstatic struct tree_mod_elem *tree_mod_log_oldest_root(struct extent_buffer *eb_root,\n\t\t\t\t\t\t      u64 time_seq)\n{\n\tstruct tree_mod_elem *tm;\n\tstruct tree_mod_elem *found = NULL;\n\tu64 root_logical = eb_root->start;\n\tbool looped = false;\n\n\tif (!time_seq)\n\t\treturn NULL;\n\n\t \n\twhile (1) {\n\t\ttm = tree_mod_log_search_oldest(eb_root->fs_info, root_logical,\n\t\t\t\t\t\ttime_seq);\n\t\tif (!looped && !tm)\n\t\t\treturn NULL;\n\t\t \n\t\tif (!tm)\n\t\t\tbreak;\n\n\t\t \n\t\tif (tm->op != BTRFS_MOD_LOG_ROOT_REPLACE)\n\t\t\tbreak;\n\n\t\tfound = tm;\n\t\troot_logical = tm->old_root.logical;\n\t\tlooped = true;\n\t}\n\n\t \n\tif (!found)\n\t\tfound = tm;\n\n\treturn found;\n}\n\n\n \nstatic void tree_mod_log_rewind(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct extent_buffer *eb,\n\t\t\t\tu64 time_seq,\n\t\t\t\tstruct tree_mod_elem *first_tm)\n{\n\tu32 n;\n\tstruct rb_node *next;\n\tstruct tree_mod_elem *tm = first_tm;\n\tunsigned long o_dst;\n\tunsigned long o_src;\n\tunsigned long p_size = sizeof(struct btrfs_key_ptr);\n\t \n\tint max_slot;\n\tint move_src_end_slot;\n\tint move_dst_end_slot;\n\n\tn = btrfs_header_nritems(eb);\n\tmax_slot = n - 1;\n\tread_lock(&fs_info->tree_mod_log_lock);\n\twhile (tm && tm->seq >= time_seq) {\n\t\tASSERT(max_slot >= -1);\n\t\t \n\t\tswitch (tm->op) {\n\t\tcase BTRFS_MOD_LOG_KEY_REMOVE_WHILE_FREEING:\n\t\t\tBUG_ON(tm->slot < n);\n\t\t\tfallthrough;\n\t\tcase BTRFS_MOD_LOG_KEY_REMOVE_WHILE_MOVING:\n\t\tcase BTRFS_MOD_LOG_KEY_REMOVE:\n\t\t\tbtrfs_set_node_key(eb, &tm->key, tm->slot);\n\t\t\tbtrfs_set_node_blockptr(eb, tm->slot, tm->blockptr);\n\t\t\tbtrfs_set_node_ptr_generation(eb, tm->slot,\n\t\t\t\t\t\t      tm->generation);\n\t\t\tn++;\n\t\t\tif (tm->slot > max_slot)\n\t\t\t\tmax_slot = tm->slot;\n\t\t\tbreak;\n\t\tcase BTRFS_MOD_LOG_KEY_REPLACE:\n\t\t\tBUG_ON(tm->slot >= n);\n\t\t\tbtrfs_set_node_key(eb, &tm->key, tm->slot);\n\t\t\tbtrfs_set_node_blockptr(eb, tm->slot, tm->blockptr);\n\t\t\tbtrfs_set_node_ptr_generation(eb, tm->slot,\n\t\t\t\t\t\t      tm->generation);\n\t\t\tbreak;\n\t\tcase BTRFS_MOD_LOG_KEY_ADD:\n\t\t\t \n\t\t\tif (tm->slot == max_slot)\n\t\t\t\tmax_slot--;\n\t\t\t \n\t\t\tn--;\n\t\t\tbreak;\n\t\tcase BTRFS_MOD_LOG_MOVE_KEYS:\n\t\t\tASSERT(tm->move.nr_items > 0);\n\t\t\tmove_src_end_slot = tm->move.dst_slot + tm->move.nr_items - 1;\n\t\t\tmove_dst_end_slot = tm->slot + tm->move.nr_items - 1;\n\t\t\to_dst = btrfs_node_key_ptr_offset(eb, tm->slot);\n\t\t\to_src = btrfs_node_key_ptr_offset(eb, tm->move.dst_slot);\n\t\t\tif (WARN_ON(move_src_end_slot > max_slot ||\n\t\t\t\t    tm->move.nr_items <= 0)) {\n\t\t\t\tbtrfs_warn(fs_info,\n\"move from invalid tree mod log slot eb %llu slot %d dst_slot %d nr_items %d seq %llu n %u max_slot %d\",\n\t\t\t\t\t   eb->start, tm->slot,\n\t\t\t\t\t   tm->move.dst_slot, tm->move.nr_items,\n\t\t\t\t\t   tm->seq, n, max_slot);\n\t\t\t}\n\t\t\tmemmove_extent_buffer(eb, o_dst, o_src,\n\t\t\t\t\t      tm->move.nr_items * p_size);\n\t\t\tmax_slot = move_dst_end_slot;\n\t\t\tbreak;\n\t\tcase BTRFS_MOD_LOG_ROOT_REPLACE:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tnext = rb_next(&tm->node);\n\t\tif (!next)\n\t\t\tbreak;\n\t\ttm = rb_entry(next, struct tree_mod_elem, node);\n\t\tif (tm->logical != first_tm->logical)\n\t\t\tbreak;\n\t}\n\tread_unlock(&fs_info->tree_mod_log_lock);\n\tbtrfs_set_header_nritems(eb, n);\n}\n\n \nstruct extent_buffer *btrfs_tree_mod_log_rewind(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_path *path,\n\t\t\t\t\t\tstruct extent_buffer *eb,\n\t\t\t\t\t\tu64 time_seq)\n{\n\tstruct extent_buffer *eb_rewin;\n\tstruct tree_mod_elem *tm;\n\n\tif (!time_seq)\n\t\treturn eb;\n\n\tif (btrfs_header_level(eb) == 0)\n\t\treturn eb;\n\n\ttm = tree_mod_log_search(fs_info, eb->start, time_seq);\n\tif (!tm)\n\t\treturn eb;\n\n\tif (tm->op == BTRFS_MOD_LOG_KEY_REMOVE_WHILE_FREEING) {\n\t\tBUG_ON(tm->slot != 0);\n\t\teb_rewin = alloc_dummy_extent_buffer(fs_info, eb->start);\n\t\tif (!eb_rewin) {\n\t\t\tbtrfs_tree_read_unlock(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn NULL;\n\t\t}\n\t\tbtrfs_set_header_bytenr(eb_rewin, eb->start);\n\t\tbtrfs_set_header_backref_rev(eb_rewin,\n\t\t\t\t\t     btrfs_header_backref_rev(eb));\n\t\tbtrfs_set_header_owner(eb_rewin, btrfs_header_owner(eb));\n\t\tbtrfs_set_header_level(eb_rewin, btrfs_header_level(eb));\n\t} else {\n\t\teb_rewin = btrfs_clone_extent_buffer(eb);\n\t\tif (!eb_rewin) {\n\t\t\tbtrfs_tree_read_unlock(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tbtrfs_tree_read_unlock(eb);\n\tfree_extent_buffer(eb);\n\n\tbtrfs_set_buffer_lockdep_class(btrfs_header_owner(eb_rewin),\n\t\t\t\t       eb_rewin, btrfs_header_level(eb_rewin));\n\tbtrfs_tree_read_lock(eb_rewin);\n\ttree_mod_log_rewind(fs_info, eb_rewin, time_seq, tm);\n\tWARN_ON(btrfs_header_nritems(eb_rewin) >\n\t\tBTRFS_NODEPTRS_PER_BLOCK(fs_info));\n\n\treturn eb_rewin;\n}\n\n \nstruct extent_buffer *btrfs_get_old_root(struct btrfs_root *root, u64 time_seq)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct tree_mod_elem *tm;\n\tstruct extent_buffer *eb = NULL;\n\tstruct extent_buffer *eb_root;\n\tu64 eb_root_owner = 0;\n\tstruct extent_buffer *old;\n\tstruct tree_mod_root *old_root = NULL;\n\tu64 old_generation = 0;\n\tu64 logical;\n\tint level;\n\n\teb_root = btrfs_read_lock_root_node(root);\n\ttm = tree_mod_log_oldest_root(eb_root, time_seq);\n\tif (!tm)\n\t\treturn eb_root;\n\n\tif (tm->op == BTRFS_MOD_LOG_ROOT_REPLACE) {\n\t\told_root = &tm->old_root;\n\t\told_generation = tm->generation;\n\t\tlogical = old_root->logical;\n\t\tlevel = old_root->level;\n\t} else {\n\t\tlogical = eb_root->start;\n\t\tlevel = btrfs_header_level(eb_root);\n\t}\n\n\ttm = tree_mod_log_search(fs_info, logical, time_seq);\n\tif (old_root && tm && tm->op != BTRFS_MOD_LOG_KEY_REMOVE_WHILE_FREEING) {\n\t\tstruct btrfs_tree_parent_check check = { 0 };\n\n\t\tbtrfs_tree_read_unlock(eb_root);\n\t\tfree_extent_buffer(eb_root);\n\n\t\tcheck.level = level;\n\t\tcheck.owner_root = root->root_key.objectid;\n\n\t\told = read_tree_block(fs_info, logical, &check);\n\t\tif (WARN_ON(IS_ERR(old) || !extent_buffer_uptodate(old))) {\n\t\t\tif (!IS_ERR(old))\n\t\t\t\tfree_extent_buffer(old);\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t   \"failed to read tree block %llu from get_old_root\",\n\t\t\t\t   logical);\n\t\t} else {\n\t\t\tstruct tree_mod_elem *tm2;\n\n\t\t\tbtrfs_tree_read_lock(old);\n\t\t\teb = btrfs_clone_extent_buffer(old);\n\t\t\t \n\t\t\ttm2 = tree_mod_log_search(fs_info, logical, time_seq);\n\t\t\tbtrfs_tree_read_unlock(old);\n\t\t\tfree_extent_buffer(old);\n\t\t\tASSERT(tm2);\n\t\t\tASSERT(tm2 == tm || tm2->seq > tm->seq);\n\t\t\tif (!tm2 || tm2->seq < tm->seq) {\n\t\t\t\tfree_extent_buffer(eb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttm = tm2;\n\t\t}\n\t} else if (old_root) {\n\t\teb_root_owner = btrfs_header_owner(eb_root);\n\t\tbtrfs_tree_read_unlock(eb_root);\n\t\tfree_extent_buffer(eb_root);\n\t\teb = alloc_dummy_extent_buffer(fs_info, logical);\n\t} else {\n\t\teb = btrfs_clone_extent_buffer(eb_root);\n\t\tbtrfs_tree_read_unlock(eb_root);\n\t\tfree_extent_buffer(eb_root);\n\t}\n\n\tif (!eb)\n\t\treturn NULL;\n\tif (old_root) {\n\t\tbtrfs_set_header_bytenr(eb, eb->start);\n\t\tbtrfs_set_header_backref_rev(eb, BTRFS_MIXED_BACKREF_REV);\n\t\tbtrfs_set_header_owner(eb, eb_root_owner);\n\t\tbtrfs_set_header_level(eb, old_root->level);\n\t\tbtrfs_set_header_generation(eb, old_generation);\n\t}\n\tbtrfs_set_buffer_lockdep_class(btrfs_header_owner(eb), eb,\n\t\t\t\t       btrfs_header_level(eb));\n\tbtrfs_tree_read_lock(eb);\n\tif (tm)\n\t\ttree_mod_log_rewind(fs_info, eb, time_seq, tm);\n\telse\n\t\tWARN_ON(btrfs_header_level(eb) != 0);\n\tWARN_ON(btrfs_header_nritems(eb) > BTRFS_NODEPTRS_PER_BLOCK(fs_info));\n\n\treturn eb;\n}\n\nint btrfs_old_root_level(struct btrfs_root *root, u64 time_seq)\n{\n\tstruct tree_mod_elem *tm;\n\tint level;\n\tstruct extent_buffer *eb_root = btrfs_root_node(root);\n\n\ttm = tree_mod_log_oldest_root(eb_root, time_seq);\n\tif (tm && tm->op == BTRFS_MOD_LOG_ROOT_REPLACE)\n\t\tlevel = tm->old_root.level;\n\telse\n\t\tlevel = btrfs_header_level(eb_root);\n\n\tfree_extent_buffer(eb_root);\n\n\treturn level;\n}\n\n \nu64 btrfs_tree_mod_log_lowest_seq(struct btrfs_fs_info *fs_info)\n{\n\tu64 ret = 0;\n\n\tread_lock(&fs_info->tree_mod_log_lock);\n\tif (!list_empty(&fs_info->tree_mod_seq_list)) {\n\t\tstruct btrfs_seq_list *elem;\n\n\t\telem = list_first_entry(&fs_info->tree_mod_seq_list,\n\t\t\t\t\tstruct btrfs_seq_list, list);\n\t\tret = elem->seq;\n\t}\n\tread_unlock(&fs_info->tree_mod_log_lock);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}