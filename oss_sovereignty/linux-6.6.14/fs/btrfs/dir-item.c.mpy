{
  "module_name": "dir-item.c",
  "hash_id": "74b1ada3108a9b28022c15744d15669a0408410c59037787767f58415b68e6fc",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/dir-item.c",
  "human_readable_source": "\n \n\n#include \"messages.h\"\n#include \"ctree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"accessors.h\"\n#include \"dir-item.h\"\n\n \nstatic struct btrfs_dir_item *insert_with_overflow(struct btrfs_trans_handle\n\t\t\t\t\t\t   *trans,\n\t\t\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t\t\t   struct btrfs_key *cpu_key,\n\t\t\t\t\t\t   u32 data_size,\n\t\t\t\t\t\t   const char *name,\n\t\t\t\t\t\t   int name_len)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\tchar *ptr;\n\tstruct extent_buffer *leaf;\n\n\tret = btrfs_insert_empty_item(trans, root, path, cpu_key, data_size);\n\tif (ret == -EEXIST) {\n\t\tstruct btrfs_dir_item *di;\n\t\tdi = btrfs_match_dir_item_name(fs_info, path, name, name_len);\n\t\tif (di)\n\t\t\treturn ERR_PTR(-EEXIST);\n\t\tbtrfs_extend_item(trans, path, data_size);\n\t} else if (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tWARN_ON(ret > 0);\n\tleaf = path->nodes[0];\n\tptr = btrfs_item_ptr(leaf, path->slots[0], char);\n\tASSERT(data_size <= btrfs_item_size(leaf, path->slots[0]));\n\tptr += btrfs_item_size(leaf, path->slots[0]) - data_size;\n\treturn (struct btrfs_dir_item *)ptr;\n}\n\n \nint btrfs_insert_xattr_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path, u64 objectid,\n\t\t\t    const char *name, u16 name_len,\n\t\t\t    const void *data, u16 data_len)\n{\n\tint ret = 0;\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr, data_ptr;\n\tstruct btrfs_key key, location;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tu32 data_size;\n\n\tif (name_len + data_len > BTRFS_MAX_XATTR_SIZE(root->fs_info))\n\t\treturn -ENOSPC;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tdata_size = sizeof(*dir_item) + name_len + data_len;\n\tdir_item = insert_with_overflow(trans, root, path, &key, data_size,\n\t\t\t\t\tname, name_len);\n\tif (IS_ERR(dir_item))\n\t\treturn PTR_ERR(dir_item);\n\tmemset(&location, 0, sizeof(location));\n\n\tleaf = path->nodes[0];\n\tbtrfs_cpu_key_to_disk(&disk_key, &location);\n\tbtrfs_set_dir_item_key(leaf, dir_item, &disk_key);\n\tbtrfs_set_dir_flags(leaf, dir_item, BTRFS_FT_XATTR);\n\tbtrfs_set_dir_name_len(leaf, dir_item, name_len);\n\tbtrfs_set_dir_transid(leaf, dir_item, trans->transid);\n\tbtrfs_set_dir_data_len(leaf, dir_item, data_len);\n\tname_ptr = (unsigned long)(dir_item + 1);\n\tdata_ptr = (unsigned long)((char *)name_ptr + name_len);\n\n\twrite_extent_buffer(leaf, name, name_ptr, name_len);\n\twrite_extent_buffer(leaf, data, data_ptr, data_len);\n\tbtrfs_mark_buffer_dirty(trans, path->nodes[0]);\n\n\treturn ret;\n}\n\n \nint btrfs_insert_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t  const struct fscrypt_str *name, struct btrfs_inode *dir,\n\t\t\t  struct btrfs_key *location, u8 type, u64 index)\n{\n\tint ret = 0;\n\tint ret2 = 0;\n\tstruct btrfs_root *root = dir->root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *dir_item;\n\tstruct extent_buffer *leaf;\n\tunsigned long name_ptr;\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key disk_key;\n\tu32 data_size;\n\n\tkey.objectid = btrfs_ino(dir);\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(name->name, name->len);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tbtrfs_cpu_key_to_disk(&disk_key, location);\n\n\tdata_size = sizeof(*dir_item) + name->len;\n\tdir_item = insert_with_overflow(trans, root, path, &key, data_size,\n\t\t\t\t\tname->name, name->len);\n\tif (IS_ERR(dir_item)) {\n\t\tret = PTR_ERR(dir_item);\n\t\tif (ret == -EEXIST)\n\t\t\tgoto second_insert;\n\t\tgoto out_free;\n\t}\n\n\tif (IS_ENCRYPTED(&dir->vfs_inode))\n\t\ttype |= BTRFS_FT_ENCRYPTED;\n\n\tleaf = path->nodes[0];\n\tbtrfs_set_dir_item_key(leaf, dir_item, &disk_key);\n\tbtrfs_set_dir_flags(leaf, dir_item, type);\n\tbtrfs_set_dir_data_len(leaf, dir_item, 0);\n\tbtrfs_set_dir_name_len(leaf, dir_item, name->len);\n\tbtrfs_set_dir_transid(leaf, dir_item, trans->transid);\n\tname_ptr = (unsigned long)(dir_item + 1);\n\n\twrite_extent_buffer(leaf, name->name, name_ptr, name->len);\n\tbtrfs_mark_buffer_dirty(trans, leaf);\n\nsecond_insert:\n\t \n\tif (root == root->fs_info->tree_root) {\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\tbtrfs_release_path(path);\n\n\tret2 = btrfs_insert_delayed_dir_index(trans, name->name, name->len, dir,\n\t\t\t\t\t      &disk_key, type, index);\nout_free:\n\tbtrfs_free_path(path);\n\tif (ret)\n\t\treturn ret;\n\tif (ret2)\n\t\treturn ret2;\n\treturn 0;\n}\n\nstatic struct btrfs_dir_item *btrfs_lookup_match_dir(\n\t\t\tstruct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *root, struct btrfs_path *path,\n\t\t\tstruct btrfs_key *key, const char *name,\n\t\t\tint name_len, int mod)\n{\n\tconst int ins_len = (mod < 0 ? -1 : 0);\n\tconst int cow = (mod != 0);\n\tint ret;\n\n\tret = btrfs_search_slot(trans, root, key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn btrfs_match_dir_item_name(root->fs_info, path, name, name_len);\n}\n\n \nstruct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const struct fscrypt_str *name,\n\t\t\t\t\t     int mod)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_dir_item *di;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(name->name, name->len);\n\n\tdi = btrfs_lookup_match_dir(trans, root, path, &key, name->name,\n\t\t\t\t    name->len, mod);\n\tif (IS_ERR(di) && PTR_ERR(di) == -ENOENT)\n\t\treturn NULL;\n\n\treturn di;\n}\n\nint btrfs_check_dir_item_collision(struct btrfs_root *root, u64 dir,\n\t\t\t\t   const struct fscrypt_str *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_dir_item *di;\n\tint data_size;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(name->name, name->len);\n\n\tdi = btrfs_lookup_match_dir(NULL, root, path, &key, name->name,\n\t\t\t\t    name->len, 0);\n\tif (IS_ERR(di)) {\n\t\tret = PTR_ERR(di);\n\t\t \n\t\tif (ret == -ENOENT) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (di) {\n\t\t \n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t \n\tdata_size = sizeof(*di) + name->len;\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\tif (data_size + btrfs_item_size(leaf, slot) +\n\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root->fs_info)) {\n\t\tret = -EOVERFLOW;\n\t} else {\n\t\t \n\t\tret = 0;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nstruct btrfs_dir_item *\nbtrfs_lookup_dir_index_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path, u64 dir,\n\t\t\t    u64 index, const struct fscrypt_str *name, int mod)\n{\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = index;\n\n\tdi = btrfs_lookup_match_dir(trans, root, path, &key, name->name,\n\t\t\t\t    name->len, mod);\n\tif (di == ERR_PTR(-ENOENT))\n\t\treturn NULL;\n\n\treturn di;\n}\n\nstruct btrfs_dir_item *\nbtrfs_search_dir_index_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    u64 dirid, const struct fscrypt_str *name)\n{\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tint ret;\n\n\tkey.objectid = dirid;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = 0;\n\n\tbtrfs_for_each_slot(root, &key, &key, path, ret) {\n\t\tif (key.objectid != dirid || key.type != BTRFS_DIR_INDEX_KEY)\n\t\t\tbreak;\n\n\t\tdi = btrfs_match_dir_item_name(root->fs_info, path,\n\t\t\t\t\t       name->name, name->len);\n\t\tif (di)\n\t\t\treturn di;\n\t}\n\t \n\tif (ret > 0)\n\t\tret = 0;\n\n\treturn ERR_PTR(ret);\n}\n\nstruct btrfs_dir_item *btrfs_lookup_xattr(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path, u64 dir,\n\t\t\t\t\t  const char *name, u16 name_len,\n\t\t\t\t\t  int mod)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_dir_item *di;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tdi = btrfs_lookup_match_dir(trans, root, path, &key, name, name_len, mod);\n\tif (IS_ERR(di) && PTR_ERR(di) == -ENOENT)\n\t\treturn NULL;\n\n\treturn di;\n}\n\n \nstruct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\t struct btrfs_path *path,\n\t\t\t\t\t\t const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\n\ttotal_len = btrfs_item_size(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}\n\n \nint btrfs_delete_one_dir_name(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      struct btrfs_dir_item *di)\n{\n\n\tstruct extent_buffer *leaf;\n\tu32 sub_item_len;\n\tu32 item_len;\n\tint ret = 0;\n\n\tleaf = path->nodes[0];\n\tsub_item_len = sizeof(*di) + btrfs_dir_name_len(leaf, di) +\n\t\tbtrfs_dir_data_len(leaf, di);\n\titem_len = btrfs_item_size(leaf, path->slots[0]);\n\tif (sub_item_len == item_len) {\n\t\tret = btrfs_del_item(trans, root, path);\n\t} else {\n\t\t \n\t\tunsigned long ptr = (unsigned long)di;\n\t\tunsigned long start;\n\n\t\tstart = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\tmemmove_extent_buffer(leaf, ptr, ptr + sub_item_len,\n\t\t\titem_len - (ptr + sub_item_len - start));\n\t\tbtrfs_truncate_item(trans, path, item_len - sub_item_len, 1);\n\t}\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}