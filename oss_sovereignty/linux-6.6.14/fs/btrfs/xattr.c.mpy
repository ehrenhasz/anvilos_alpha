{
  "module_name": "xattr.c",
  "hash_id": "3fa728a568a169275b5ce417587dd95f8582c94255033f73088029a2432991b5",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/xattr.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/iversion.h>\n#include <linux/sched/mm.h>\n#include \"ctree.h\"\n#include \"fs.h\"\n#include \"messages.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"xattr.h\"\n#include \"disk-io.h\"\n#include \"props.h\"\n#include \"locking.h\"\n#include \"accessors.h\"\n#include \"dir-item.h\"\n\nint btrfs_getxattr(struct inode *inode, const char *name,\n\t\t\t\tvoid *buffer, size_t size)\n{\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tint ret = 0;\n\tunsigned long data_ptr;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t \n\tdi = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(BTRFS_I(inode)),\n\t\t\tname, strlen(name), 0);\n\tif (!di) {\n\t\tret = -ENODATA;\n\t\tgoto out;\n\t} else if (IS_ERR(di)) {\n\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\t \n\tif (!size) {\n\t\tret = btrfs_dir_data_len(leaf, di);\n\t\tgoto out;\n\t}\n\n\t \n\tif (btrfs_dir_data_len(leaf, di) > size) {\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\n\t \n\tdata_ptr = (unsigned long)((char *)(di + 1) +\n\t\t\t\t   btrfs_dir_name_len(leaf, di));\n\tread_extent_buffer(leaf, buffer, data_ptr,\n\t\t\t   btrfs_dir_data_len(leaf, di));\n\tret = btrfs_dir_data_len(leaf, di);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nint btrfs_setxattr(struct btrfs_trans_handle *trans, struct inode *inode,\n\t\t   const char *name, const void *value, size_t size, int flags)\n{\n\tstruct btrfs_dir_item *di = NULL;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_path *path;\n\tsize_t name_len = strlen(name);\n\tint ret = 0;\n\n\tASSERT(trans);\n\n\tif (name_len + size > BTRFS_MAX_XATTR_SIZE(root->fs_info))\n\t\treturn -ENOSPC;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->skip_release_on_error = 1;\n\n\tif (!value) {\n\t\tdi = btrfs_lookup_xattr(trans, root, path,\n\t\t\t\tbtrfs_ino(BTRFS_I(inode)), name, name_len, -1);\n\t\tif (!di && (flags & XATTR_REPLACE))\n\t\t\tret = -ENODATA;\n\t\telse if (IS_ERR(di))\n\t\t\tret = PTR_ERR(di);\n\t\telse if (di)\n\t\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n\t\tgoto out;\n\t}\n\n\t \n\tif (flags & XATTR_REPLACE) {\n\t\tASSERT(inode_is_locked(inode));\n\t\tdi = btrfs_lookup_xattr(NULL, root, path,\n\t\t\t\tbtrfs_ino(BTRFS_I(inode)), name, name_len, 0);\n\t\tif (!di)\n\t\t\tret = -ENODATA;\n\t\telse if (IS_ERR(di))\n\t\t\tret = PTR_ERR(di);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbtrfs_release_path(path);\n\t\tdi = NULL;\n\t}\n\n\tret = btrfs_insert_xattr_item(trans, root, path, btrfs_ino(BTRFS_I(inode)),\n\t\t\t\t      name, name_len, value, size);\n\tif (ret == -EOVERFLOW) {\n\t\t \n\t\tret = 0;\n\t\tbtrfs_assert_tree_write_locked(path->nodes[0]);\n\t\tdi = btrfs_match_dir_item_name(fs_info, path, name, name_len);\n\t\tif (!di && !(flags & XATTR_REPLACE)) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t} else if (ret == -EEXIST) {\n\t\tret = 0;\n\t\tdi = btrfs_match_dir_item_name(fs_info, path, name, name_len);\n\t\tASSERT(di);  \n\t} else if (ret) {\n\t\tgoto out;\n\t}\n\n\tif (di && (flags & XATTR_CREATE)) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (di) {\n\t\t \n\t\tconst int slot = path->slots[0];\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tconst u16 old_data_len = btrfs_dir_data_len(leaf, di);\n\t\tconst u32 item_size = btrfs_item_size(leaf, slot);\n\t\tconst u32 data_size = sizeof(*di) + name_len + size;\n\t\tunsigned long data_ptr;\n\t\tchar *ptr;\n\n\t\tif (size > old_data_len) {\n\t\t\tif (btrfs_leaf_free_space(leaf) <\n\t\t\t    (size - old_data_len)) {\n\t\t\t\tret = -ENOSPC;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (old_data_len + name_len + sizeof(*di) == item_size) {\n\t\t\t \n\t\t\tif (size > old_data_len)\n\t\t\t\tbtrfs_extend_item(trans, path, size - old_data_len);\n\t\t\telse if (size < old_data_len)\n\t\t\t\tbtrfs_truncate_item(trans, path, data_size, 1);\n\t\t} else {\n\t\t\t \n\t\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbtrfs_extend_item(trans, path, data_size);\n\t\t}\n\n\t\tptr = btrfs_item_ptr(leaf, slot, char);\n\t\tptr += btrfs_item_size(leaf, slot) - data_size;\n\t\tdi = (struct btrfs_dir_item *)ptr;\n\t\tbtrfs_set_dir_data_len(leaf, di, size);\n\t\tdata_ptr = ((unsigned long)(di + 1)) + name_len;\n\t\twrite_extent_buffer(leaf, value, data_ptr, size);\n\t\tbtrfs_mark_buffer_dirty(trans, leaf);\n\t} else {\n\t\t \n\t}\nout:\n\tbtrfs_free_path(path);\n\tif (!ret) {\n\t\tset_bit(BTRFS_INODE_COPY_EVERYTHING,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\tclear_bit(BTRFS_INODE_NO_XATTRS, &BTRFS_I(inode)->runtime_flags);\n\t}\n\treturn ret;\n}\n\n \nint btrfs_setxattr_trans(struct inode *inode, const char *name,\n\t\t\t const void *value, size_t size, int flags)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\tconst bool start_trans = (current->journal_info == NULL);\n\tint ret;\n\n\tif (start_trans) {\n\t\t \n\t\ttrans = btrfs_start_transaction(root, 2);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t} else {\n\t\t \n\t\tASSERT(strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t       XATTR_SECURITY_PREFIX_LEN) == 0);\n\t\ttrans = current->journal_info;\n\t}\n\n\tret = btrfs_setxattr(trans, inode, name, value, size, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tinode_inc_iversion(inode);\n\tinode_set_ctime_current(inode);\n\tret = btrfs_update_inode(trans, root, BTRFS_I(inode));\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, ret);\nout:\n\tif (start_trans)\n\t\tbtrfs_end_transaction(trans);\n\treturn ret;\n}\n\nssize_t btrfs_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key key;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path;\n\tint iter_ret = 0;\n\tint ret = 0;\n\tsize_t total_size = 0, size_left = size;\n\n\t \n\tkey.objectid = btrfs_ino(BTRFS_I(inode));\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = READA_FORWARD;\n\n\t \n\tbtrfs_for_each_slot(root, &key, &found_key, path, iter_ret) {\n\t\tstruct extent_buffer *leaf;\n\t\tint slot;\n\t\tstruct btrfs_dir_item *di;\n\t\tu32 item_size;\n\t\tu32 cur;\n\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\t \n\t\tif (found_key.objectid != key.objectid)\n\t\t\tbreak;\n\t\tif (found_key.type > BTRFS_XATTR_ITEM_KEY)\n\t\t\tbreak;\n\t\tif (found_key.type < BTRFS_XATTR_ITEM_KEY)\n\t\t\tcontinue;\n\n\t\tdi = btrfs_item_ptr(leaf, slot, struct btrfs_dir_item);\n\t\titem_size = btrfs_item_size(leaf, slot);\n\t\tcur = 0;\n\t\twhile (cur < item_size) {\n\t\t\tu16 name_len = btrfs_dir_name_len(leaf, di);\n\t\t\tu16 data_len = btrfs_dir_data_len(leaf, di);\n\t\t\tu32 this_len = sizeof(*di) + name_len + data_len;\n\t\t\tunsigned long name_ptr = (unsigned long)(di + 1);\n\n\t\t\ttotal_size += name_len + 1;\n\t\t\t \n\t\t\tif (!size)\n\t\t\t\tgoto next;\n\n\t\t\tif (!buffer || (name_len + 1) > size_left) {\n\t\t\t        iter_ret = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tread_extent_buffer(leaf, buffer, name_ptr, name_len);\n\t\t\tbuffer[name_len] = '\\0';\n\n\t\t\tsize_left -= name_len + 1;\n\t\t\tbuffer += name_len + 1;\nnext:\n\t\t\tcur += this_len;\n\t\t\tdi = (struct btrfs_dir_item *)((char *)di + this_len);\n\t\t}\n\t}\n\n\tif (iter_ret < 0)\n\t\tret = iter_ret;\n\telse\n\t\tret = total_size;\n\n\tbtrfs_free_path(path);\n\n\treturn ret;\n}\n\nstatic int btrfs_xattr_handler_get(const struct xattr_handler *handler,\n\t\t\t\t   struct dentry *unused, struct inode *inode,\n\t\t\t\t   const char *name, void *buffer, size_t size)\n{\n\tname = xattr_full_name(handler, name);\n\treturn btrfs_getxattr(inode, name, buffer, size);\n}\n\nstatic int btrfs_xattr_handler_set(const struct xattr_handler *handler,\n\t\t\t\t   struct mnt_idmap *idmap,\n\t\t\t\t   struct dentry *unused, struct inode *inode,\n\t\t\t\t   const char *name, const void *buffer,\n\t\t\t\t   size_t size, int flags)\n{\n\tif (btrfs_root_readonly(BTRFS_I(inode)->root))\n\t\treturn -EROFS;\n\n\tname = xattr_full_name(handler, name);\n\treturn btrfs_setxattr_trans(inode, name, buffer, size, flags);\n}\n\nstatic int btrfs_xattr_handler_set_prop(const struct xattr_handler *handler,\n\t\t\t\t\tstruct mnt_idmap *idmap,\n\t\t\t\t\tstruct dentry *unused, struct inode *inode,\n\t\t\t\t\tconst char *name, const void *value,\n\t\t\t\t\tsize_t size, int flags)\n{\n\tint ret;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\n\tname = xattr_full_name(handler, name);\n\tret = btrfs_validate_prop(BTRFS_I(inode), name, value, size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (btrfs_ignore_prop(BTRFS_I(inode), name))\n\t\treturn 0;\n\n\ttrans = btrfs_start_transaction(root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tret = btrfs_set_prop(trans, inode, name, value, size, flags);\n\tif (!ret) {\n\t\tinode_inc_iversion(inode);\n\t\tinode_set_ctime_current(inode);\n\t\tret = btrfs_update_inode(trans, root, BTRFS_I(inode));\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t}\n\n\tbtrfs_end_transaction(trans);\n\n\treturn ret;\n}\n\nstatic const struct xattr_handler btrfs_security_xattr_handler = {\n\t.prefix = XATTR_SECURITY_PREFIX,\n\t.get = btrfs_xattr_handler_get,\n\t.set = btrfs_xattr_handler_set,\n};\n\nstatic const struct xattr_handler btrfs_trusted_xattr_handler = {\n\t.prefix = XATTR_TRUSTED_PREFIX,\n\t.get = btrfs_xattr_handler_get,\n\t.set = btrfs_xattr_handler_set,\n};\n\nstatic const struct xattr_handler btrfs_user_xattr_handler = {\n\t.prefix = XATTR_USER_PREFIX,\n\t.get = btrfs_xattr_handler_get,\n\t.set = btrfs_xattr_handler_set,\n};\n\nstatic const struct xattr_handler btrfs_btrfs_xattr_handler = {\n\t.prefix = XATTR_BTRFS_PREFIX,\n\t.get = btrfs_xattr_handler_get,\n\t.set = btrfs_xattr_handler_set_prop,\n};\n\nconst struct xattr_handler *btrfs_xattr_handlers[] = {\n\t&btrfs_security_xattr_handler,\n\t&btrfs_trusted_xattr_handler,\n\t&btrfs_user_xattr_handler,\n\t&btrfs_btrfs_xattr_handler,\n\tNULL,\n};\n\nstatic int btrfs_initxattrs(struct inode *inode,\n\t\t\t    const struct xattr *xattr_array, void *fs_private)\n{\n\tstruct btrfs_trans_handle *trans = fs_private;\n\tconst struct xattr *xattr;\n\tunsigned int nofs_flag;\n\tchar *name;\n\tint err = 0;\n\n\t \n\tnofs_flag = memalloc_nofs_save();\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\tname = kmalloc(XATTR_SECURITY_PREFIX_LEN +\n\t\t\t       strlen(xattr->name) + 1, GFP_KERNEL);\n\t\tif (!name) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tstrcpy(name, XATTR_SECURITY_PREFIX);\n\t\tstrcpy(name + XATTR_SECURITY_PREFIX_LEN, xattr->name);\n\t\terr = btrfs_setxattr(trans, inode, name, xattr->value,\n\t\t\t\t     xattr->value_len, 0);\n\t\tkfree(name);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\tmemalloc_nofs_restore(nofs_flag);\n\treturn err;\n}\n\nint btrfs_xattr_security_init(struct btrfs_trans_handle *trans,\n\t\t\t      struct inode *inode, struct inode *dir,\n\t\t\t      const struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &btrfs_initxattrs, trans);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}