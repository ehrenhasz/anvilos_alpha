{
  "module_name": "fs.h",
  "hash_id": "549c3f5d0ff17f73e05892823690d38730a5cfe7f442ea12b54deebcb21b7ed1",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/fs.h",
  "human_readable_source": " \n\n#ifndef BTRFS_FS_H\n#define BTRFS_FS_H\n\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/btrfs_tree.h>\n#include <linux/sizes.h>\n#include \"extent-io-tree.h\"\n#include \"extent_map.h\"\n#include \"async-thread.h\"\n#include \"block-rsv.h\"\n\n#define BTRFS_MAX_EXTENT_SIZE SZ_128M\n\n#define BTRFS_OLDEST_GENERATION\t0ULL\n\n#define BTRFS_EMPTY_DIR_SIZE 0\n\n#define BTRFS_DIRTY_METADATA_THRESH\t\tSZ_32M\n\n#define BTRFS_SUPER_INFO_OFFSET\t\t\tSZ_64K\n#define BTRFS_SUPER_INFO_SIZE\t\t\t4096\nstatic_assert(sizeof(struct btrfs_super_block) == BTRFS_SUPER_INFO_SIZE);\n\n \n#define BTRFS_UNLINK_METADATA_UNITS\t\t6\n\n \n#define BTRFS_DEVICE_RANGE_RESERVED\t\t\t(SZ_1M)\n \nenum {\n\t \n\tBTRFS_FS_STATE_REMOUNTING,\n\t \n\tBTRFS_FS_STATE_RO,\n\t \n\tBTRFS_FS_STATE_TRANS_ABORTED,\n\t \n\tBTRFS_FS_STATE_DEV_REPLACING,\n\t \n\tBTRFS_FS_STATE_DUMMY_FS_INFO,\n\n\tBTRFS_FS_STATE_NO_CSUMS,\n\n\t \n\tBTRFS_FS_STATE_LOG_CLEANUP_ERROR,\n\n\tBTRFS_FS_STATE_COUNT\n};\n\nenum {\n\tBTRFS_FS_CLOSING_START,\n\tBTRFS_FS_CLOSING_DONE,\n\tBTRFS_FS_LOG_RECOVERING,\n\tBTRFS_FS_OPEN,\n\tBTRFS_FS_QUOTA_ENABLED,\n\tBTRFS_FS_UPDATE_UUID_TREE_GEN,\n\tBTRFS_FS_CREATING_FREE_SPACE_TREE,\n\tBTRFS_FS_BTREE_ERR,\n\tBTRFS_FS_LOG1_ERR,\n\tBTRFS_FS_LOG2_ERR,\n\tBTRFS_FS_QUOTA_OVERRIDE,\n\t \n\tBTRFS_FS_FROZEN,\n\t \n\tBTRFS_FS_BALANCE_RUNNING,\n\n\t \n\tBTRFS_FS_RELOC_RUNNING,\n\n\t \n\tBTRFS_FS_CLEANER_RUNNING,\n\n\t \n\tBTRFS_FS_CSUM_IMPL_FAST,\n\n\t \n\tBTRFS_FS_DISCARD_RUNNING,\n\n\t \n\tBTRFS_FS_CLEANUP_SPACE_CACHE_V1,\n\n\t \n\tBTRFS_FS_FREE_SPACE_TREE_UNTRUSTED,\n\n\t \n\tBTRFS_FS_TREE_MOD_LOG_USERS,\n\n\t \n\tBTRFS_FS_COMMIT_TRANS,\n\n\t \n\tBTRFS_FS_UNFINISHED_DROPS,\n\n\t \n\tBTRFS_FS_NEED_ZONE_FINISH,\n\n\t \n\tBTRFS_FS_NEED_TRANS_COMMIT,\n\n\t \n\tBTRFS_FS_ACTIVE_ZONE_TRACKING,\n\n\t \n\tBTRFS_FS_FEATURE_CHANGED,\n\n#if BITS_PER_LONG == 32\n\t \n\tBTRFS_FS_32BIT_ERROR,\n\tBTRFS_FS_32BIT_WARN,\n#endif\n};\n\n \nenum {\n\tBTRFS_MOUNT_NODATASUM\t\t\t= (1UL << 0),\n\tBTRFS_MOUNT_NODATACOW\t\t\t= (1UL << 1),\n\tBTRFS_MOUNT_NOBARRIER\t\t\t= (1UL << 2),\n\tBTRFS_MOUNT_SSD\t\t\t\t= (1UL << 3),\n\tBTRFS_MOUNT_DEGRADED\t\t\t= (1UL << 4),\n\tBTRFS_MOUNT_COMPRESS\t\t\t= (1UL << 5),\n\tBTRFS_MOUNT_NOTREELOG   \t\t= (1UL << 6),\n\tBTRFS_MOUNT_FLUSHONCOMMIT\t\t= (1UL << 7),\n\tBTRFS_MOUNT_SSD_SPREAD\t\t\t= (1UL << 8),\n\tBTRFS_MOUNT_NOSSD\t\t\t= (1UL << 9),\n\tBTRFS_MOUNT_DISCARD_SYNC\t\t= (1UL << 10),\n\tBTRFS_MOUNT_FORCE_COMPRESS      \t= (1UL << 11),\n\tBTRFS_MOUNT_SPACE_CACHE\t\t\t= (1UL << 12),\n\tBTRFS_MOUNT_CLEAR_CACHE\t\t\t= (1UL << 13),\n\tBTRFS_MOUNT_USER_SUBVOL_RM_ALLOWED\t= (1UL << 14),\n\tBTRFS_MOUNT_ENOSPC_DEBUG\t\t= (1UL << 15),\n\tBTRFS_MOUNT_AUTO_DEFRAG\t\t\t= (1UL << 16),\n\tBTRFS_MOUNT_USEBACKUPROOT\t\t= (1UL << 17),\n\tBTRFS_MOUNT_SKIP_BALANCE\t\t= (1UL << 18),\n\tBTRFS_MOUNT_CHECK_INTEGRITY\t\t= (1UL << 19),\n\tBTRFS_MOUNT_CHECK_INTEGRITY_DATA\t= (1UL << 20),\n\tBTRFS_MOUNT_PANIC_ON_FATAL_ERROR\t= (1UL << 21),\n\tBTRFS_MOUNT_RESCAN_UUID_TREE\t\t= (1UL << 22),\n\tBTRFS_MOUNT_FRAGMENT_DATA\t\t= (1UL << 23),\n\tBTRFS_MOUNT_FRAGMENT_METADATA\t\t= (1UL << 24),\n\tBTRFS_MOUNT_FREE_SPACE_TREE\t\t= (1UL << 25),\n\tBTRFS_MOUNT_NOLOGREPLAY\t\t\t= (1UL << 26),\n\tBTRFS_MOUNT_REF_VERIFY\t\t\t= (1UL << 27),\n\tBTRFS_MOUNT_DISCARD_ASYNC\t\t= (1UL << 28),\n\tBTRFS_MOUNT_IGNOREBADROOTS\t\t= (1UL << 29),\n\tBTRFS_MOUNT_IGNOREDATACSUMS\t\t= (1UL << 30),\n\tBTRFS_MOUNT_NODISCARD\t\t\t= (1UL << 31),\n};\n\n \n#define BTRFS_FEATURE_COMPAT_SUPP\t\t0ULL\n#define BTRFS_FEATURE_COMPAT_SAFE_SET\t\t0ULL\n#define BTRFS_FEATURE_COMPAT_SAFE_CLEAR\t\t0ULL\n\n#define BTRFS_FEATURE_COMPAT_RO_SUPP\t\t\t\\\n\t(BTRFS_FEATURE_COMPAT_RO_FREE_SPACE_TREE |\t\\\n\t BTRFS_FEATURE_COMPAT_RO_FREE_SPACE_TREE_VALID | \\\n\t BTRFS_FEATURE_COMPAT_RO_VERITY |\t\t\\\n\t BTRFS_FEATURE_COMPAT_RO_BLOCK_GROUP_TREE)\n\n#define BTRFS_FEATURE_COMPAT_RO_SAFE_SET\t0ULL\n#define BTRFS_FEATURE_COMPAT_RO_SAFE_CLEAR\t0ULL\n\n#define BTRFS_FEATURE_INCOMPAT_SUPP_STABLE\t\t\\\n\t(BTRFS_FEATURE_INCOMPAT_MIXED_BACKREF |\t\t\\\n\t BTRFS_FEATURE_INCOMPAT_DEFAULT_SUBVOL |\t\\\n\t BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS |\t\t\\\n\t BTRFS_FEATURE_INCOMPAT_BIG_METADATA |\t\t\\\n\t BTRFS_FEATURE_INCOMPAT_COMPRESS_LZO |\t\t\\\n\t BTRFS_FEATURE_INCOMPAT_COMPRESS_ZSTD |\t\t\\\n\t BTRFS_FEATURE_INCOMPAT_RAID56 |\t\t\\\n\t BTRFS_FEATURE_INCOMPAT_EXTENDED_IREF |\t\t\\\n\t BTRFS_FEATURE_INCOMPAT_SKINNY_METADATA |\t\\\n\t BTRFS_FEATURE_INCOMPAT_NO_HOLES\t|\t\\\n\t BTRFS_FEATURE_INCOMPAT_METADATA_UUID\t|\t\\\n\t BTRFS_FEATURE_INCOMPAT_RAID1C34\t|\t\\\n\t BTRFS_FEATURE_INCOMPAT_ZONED)\n\n#ifdef CONFIG_BTRFS_DEBUG\n\t \n#define BTRFS_FEATURE_INCOMPAT_SUPP\t\t\\\n\t(BTRFS_FEATURE_INCOMPAT_SUPP_STABLE |\t\\\n\t BTRFS_FEATURE_INCOMPAT_EXTENT_TREE_V2)\n\n#else\n\n#define BTRFS_FEATURE_INCOMPAT_SUPP\t\t\\\n\t(BTRFS_FEATURE_INCOMPAT_SUPP_STABLE)\n\n#endif\n\n#define BTRFS_FEATURE_INCOMPAT_SAFE_SET\t\t\t\\\n\t(BTRFS_FEATURE_INCOMPAT_EXTENDED_IREF)\n#define BTRFS_FEATURE_INCOMPAT_SAFE_CLEAR\t\t0ULL\n\n#define BTRFS_DEFAULT_COMMIT_INTERVAL\t(30)\n#define BTRFS_DEFAULT_MAX_INLINE\t(2048)\n\nstruct btrfs_dev_replace {\n\t \n\tu64 replace_state;\n\t \n\ttime64_t time_started;\n\t \n\ttime64_t time_stopped;\n\tatomic64_t num_write_errors;\n\tatomic64_t num_uncorrectable_read_errors;\n\n\tu64 cursor_left;\n\tu64 committed_cursor_left;\n\tu64 cursor_left_last_write_of_item;\n\tu64 cursor_right;\n\n\t \n\tu64 cont_reading_from_srcdev_mode;\n\n\tint is_valid;\n\tint item_needs_writeback;\n\tstruct btrfs_device *srcdev;\n\tstruct btrfs_device *tgtdev;\n\n\tstruct mutex lock_finishing_cancel_unmount;\n\tstruct rw_semaphore rwsem;\n\n\tstruct btrfs_scrub_progress scrub_progress;\n\n\tstruct percpu_counter bio_counter;\n\twait_queue_head_t replace_wait;\n};\n\n \nstruct btrfs_free_cluster {\n\tspinlock_t lock;\n\tspinlock_t refill_lock;\n\tstruct rb_root root;\n\n\t \n\tu64 max_size;\n\n\t \n\tu64 window_start;\n\n\t \n\tbool fragmented;\n\n\tstruct btrfs_block_group *block_group;\n\t \n\tstruct list_head block_group_list;\n};\n\n \n \n#define BTRFS_NR_DISCARD_LISTS\t\t3\n#define BTRFS_DISCARD_INDEX_UNUSED\t0\n#define BTRFS_DISCARD_INDEX_START\t1\n\nstruct btrfs_discard_ctl {\n\tstruct workqueue_struct *discard_workers;\n\tstruct delayed_work work;\n\tspinlock_t lock;\n\tstruct btrfs_block_group *block_group;\n\tstruct list_head discard_list[BTRFS_NR_DISCARD_LISTS];\n\tu64 prev_discard;\n\tu64 prev_discard_time;\n\tatomic_t discardable_extents;\n\tatomic64_t discardable_bytes;\n\tu64 max_discard_size;\n\tu64 delay_ms;\n\tu32 iops_limit;\n\tu32 kbps_limit;\n\tu64 discard_extent_bytes;\n\tu64 discard_bitmap_bytes;\n\tatomic64_t discard_bytes_saved;\n};\n\n \nenum btrfs_exclusive_operation {\n\tBTRFS_EXCLOP_NONE,\n\tBTRFS_EXCLOP_BALANCE_PAUSED,\n\tBTRFS_EXCLOP_BALANCE,\n\tBTRFS_EXCLOP_DEV_ADD,\n\tBTRFS_EXCLOP_DEV_REMOVE,\n\tBTRFS_EXCLOP_DEV_REPLACE,\n\tBTRFS_EXCLOP_RESIZE,\n\tBTRFS_EXCLOP_SWAP_ACTIVATE,\n};\n\n \nstruct btrfs_commit_stats {\n\t \n\tu64 commit_count;\n\t \n\tu64 max_commit_dur;\n\t \n\tu64 last_commit_dur;\n\t \n\tu64 total_commit_dur;\n};\n\nstruct btrfs_fs_info {\n\tu8 chunk_tree_uuid[BTRFS_UUID_SIZE];\n\tunsigned long flags;\n\tstruct btrfs_root *tree_root;\n\tstruct btrfs_root *chunk_root;\n\tstruct btrfs_root *dev_root;\n\tstruct btrfs_root *fs_root;\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_root *uuid_root;\n\tstruct btrfs_root *data_reloc_root;\n\tstruct btrfs_root *block_group_root;\n\n\t \n\tstruct btrfs_root *log_root_tree;\n\n\t \n\trwlock_t global_root_lock;\n\tstruct rb_root global_root_tree;\n\n\tspinlock_t fs_roots_radix_lock;\n\tstruct radix_tree_root fs_roots_radix;\n\n\t \n\trwlock_t block_group_cache_lock;\n\tstruct rb_root_cached block_group_cache_tree;\n\n\t \n\tatomic64_t free_chunk_space;\n\n\t \n\tstruct extent_io_tree excluded_extents;\n\n\t \n\tstruct extent_map_tree mapping_tree;\n\n\t \n\tstruct btrfs_block_rsv global_block_rsv;\n\t \n\tstruct btrfs_block_rsv trans_block_rsv;\n\t \n\tstruct btrfs_block_rsv chunk_block_rsv;\n\t \n\tstruct btrfs_block_rsv delayed_block_rsv;\n\t \n\tstruct btrfs_block_rsv delayed_refs_rsv;\n\n\tstruct btrfs_block_rsv empty_block_rsv;\n\n\tu64 generation;\n\tu64 last_trans_committed;\n\t \n\tu64 last_reloc_trans;\n\n\t \n\tu64 last_trans_log_full_commit;\n\tunsigned long mount_opt;\n\n\tunsigned long compress_type:4;\n\tunsigned int compress_level;\n\tu32 commit_interval;\n\t \n\tu64 max_inline;\n\n\tstruct btrfs_transaction *running_transaction;\n\twait_queue_head_t transaction_throttle;\n\twait_queue_head_t transaction_wait;\n\twait_queue_head_t transaction_blocked_wait;\n\twait_queue_head_t async_submit_wait;\n\n\t \n\tspinlock_t super_lock;\n\tstruct btrfs_super_block *super_copy;\n\tstruct btrfs_super_block *super_for_commit;\n\tstruct super_block *sb;\n\tstruct inode *btree_inode;\n\tstruct mutex tree_log_mutex;\n\tstruct mutex transaction_kthread_mutex;\n\tstruct mutex cleaner_mutex;\n\tstruct mutex chunk_mutex;\n\n\t \n\tstruct mutex ro_block_group_mutex;\n\n\t \n\tstruct btrfs_stripe_hash_table *stripe_hash_table;\n\n\t \n\tstruct mutex ordered_operations_mutex;\n\n\tstruct rw_semaphore commit_root_sem;\n\n\tstruct rw_semaphore cleanup_work_sem;\n\n\tstruct rw_semaphore subvol_sem;\n\n\tspinlock_t trans_lock;\n\t \n\tstruct mutex reloc_mutex;\n\n\tstruct list_head trans_list;\n\tstruct list_head dead_roots;\n\tstruct list_head caching_block_groups;\n\n\tspinlock_t delayed_iput_lock;\n\tstruct list_head delayed_iputs;\n\tatomic_t nr_delayed_iputs;\n\twait_queue_head_t delayed_iputs_wait;\n\n\tatomic64_t tree_mod_seq;\n\n\t \n\trwlock_t tree_mod_log_lock;\n\tstruct rb_root tree_mod_log;\n\tstruct list_head tree_mod_seq_list;\n\n\tatomic_t async_delalloc_pages;\n\n\t \n\tspinlock_t ordered_root_lock;\n\n\t \n\tstruct list_head ordered_roots;\n\n\tstruct mutex delalloc_root_mutex;\n\tspinlock_t delalloc_root_lock;\n\t \n\tstruct list_head delalloc_roots;\n\n\t \n\tstruct btrfs_workqueue *workers;\n\tstruct btrfs_workqueue *delalloc_workers;\n\tstruct btrfs_workqueue *flush_workers;\n\tstruct workqueue_struct *endio_workers;\n\tstruct workqueue_struct *endio_meta_workers;\n\tstruct workqueue_struct *rmw_workers;\n\tstruct workqueue_struct *compressed_write_workers;\n\tstruct btrfs_workqueue *endio_write_workers;\n\tstruct btrfs_workqueue *endio_freespace_worker;\n\tstruct btrfs_workqueue *caching_workers;\n\n\t \n\tstruct btrfs_workqueue *fixup_workers;\n\tstruct btrfs_workqueue *delayed_workers;\n\n\tstruct task_struct *transaction_kthread;\n\tstruct task_struct *cleaner_kthread;\n\tu32 thread_pool_size;\n\n\tstruct kobject *space_info_kobj;\n\tstruct kobject *qgroups_kobj;\n\tstruct kobject *discard_kobj;\n\n\t \n\tstruct percpu_counter dirty_metadata_bytes;\n\tstruct percpu_counter delalloc_bytes;\n\tstruct percpu_counter ordered_bytes;\n\ts32 dirty_metadata_batch;\n\ts32 delalloc_batch;\n\n\t \n\tstruct list_head dirty_cowonly_roots;\n\n\tstruct btrfs_fs_devices *fs_devices;\n\n\t \n\tstruct list_head space_info;\n\n\tstruct btrfs_space_info *data_sinfo;\n\n\tstruct reloc_control *reloc_ctl;\n\n\t \n\tstruct btrfs_free_cluster data_alloc_cluster;\n\n\t \n\tstruct btrfs_free_cluster meta_alloc_cluster;\n\n\t \n\tspinlock_t defrag_inodes_lock;\n\tstruct rb_root defrag_inodes;\n\tatomic_t defrag_running;\n\n\t \n\tseqlock_t profiles_lock;\n\t \n\tu64 avail_data_alloc_bits;\n\tu64 avail_metadata_alloc_bits;\n\tu64 avail_system_alloc_bits;\n\n\t \n\tspinlock_t balance_lock;\n\tstruct mutex balance_mutex;\n\tatomic_t balance_pause_req;\n\tatomic_t balance_cancel_req;\n\tstruct btrfs_balance_control *balance_ctl;\n\twait_queue_head_t balance_wait_q;\n\n\t \n\tatomic_t reloc_cancel_req;\n\n\tu32 data_chunk_allocations;\n\tu32 metadata_ratio;\n\n\tvoid *bdev_holder;\n\n\t \n\tstruct mutex scrub_lock;\n\tatomic_t scrubs_running;\n\tatomic_t scrub_pause_req;\n\tatomic_t scrubs_paused;\n\tatomic_t scrub_cancel_req;\n\twait_queue_head_t scrub_pause_wait;\n\t \n\trefcount_t scrub_workers_refcnt;\n\tstruct workqueue_struct *scrub_workers;\n\tstruct btrfs_subpage_info *subpage_info;\n\n\tstruct btrfs_discard_ctl discard_ctl;\n\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tu32 check_integrity_print_mask;\n#endif\n\t \n\tu64 qgroup_flags;\n\n\t \n\tstruct rb_root qgroup_tree;\n\tspinlock_t qgroup_lock;\n\n\t \n\tstruct ulist *qgroup_ulist;\n\n\t \n\tstruct mutex qgroup_ioctl_lock;\n\n\t \n\tstruct list_head dirty_qgroups;\n\n\t \n\tu64 qgroup_seq;\n\n\t \n\t \n\tstruct mutex qgroup_rescan_lock;\n\tstruct btrfs_key qgroup_rescan_progress;\n\tstruct btrfs_workqueue *qgroup_rescan_workers;\n\tstruct completion qgroup_rescan_completion;\n\tstruct btrfs_work qgroup_rescan_work;\n\t \n\tbool qgroup_rescan_running;\n\tu8 qgroup_drop_subtree_thres;\n\n\t \n\tint fs_error;\n\n\t \n\tunsigned long fs_state;\n\n\tstruct btrfs_delayed_root *delayed_root;\n\n\t \n\tspinlock_t buffer_lock;\n\t \n\tstruct radix_tree_root buffer_radix;\n\n\t \n\tint backup_root_index;\n\n\t \n\tstruct btrfs_dev_replace dev_replace;\n\n\tstruct semaphore uuid_tree_rescan_sem;\n\n\t \n\tstruct work_struct async_reclaim_work;\n\tstruct work_struct async_data_reclaim_work;\n\tstruct work_struct preempt_reclaim_work;\n\n\t \n\tstruct work_struct reclaim_bgs_work;\n\tstruct list_head reclaim_bgs;\n\tint bg_reclaim_threshold;\n\n\tspinlock_t unused_bgs_lock;\n\tstruct list_head unused_bgs;\n\tstruct mutex unused_bg_unpin_mutex;\n\t \n\tstruct mutex reclaim_bgs_lock;\n\n\t \n\tu32 nodesize;\n\tu32 sectorsize;\n\t \n\tu32 sectorsize_bits;\n\tu32 csum_size;\n\tu32 csums_per_leaf;\n\tu32 stripesize;\n\n\t \n\tu64 max_extent_size;\n\n\t \n\tspinlock_t swapfile_pins_lock;\n\tstruct rb_root swapfile_pins;\n\n\tstruct crypto_shash *csum_shash;\n\n\t \n\tenum btrfs_exclusive_operation exclusive_operation;\n\n\t \n\tu64 zone_size;\n\n\t \n\tstruct queue_limits limits;\n\tu64 max_zone_append_size;\n\n\tstruct mutex zoned_meta_io_lock;\n\tspinlock_t treelog_bg_lock;\n\tu64 treelog_bg;\n\n\t \n\tspinlock_t relocation_bg_lock;\n\tu64 data_reloc_bg;\n\tstruct mutex zoned_data_reloc_io_lock;\n\n\tstruct btrfs_block_group *active_meta_bg;\n\tstruct btrfs_block_group *active_system_bg;\n\n\tu64 nr_global_roots;\n\n\tspinlock_t zone_active_bgs_lock;\n\tstruct list_head zone_active_bgs;\n\n\t \n\tstruct btrfs_commit_stats commit_stats;\n\n\t \n\tu64 last_root_drop_gen;\n\n\t \n\tstruct lockdep_map btrfs_trans_num_writers_map;\n\tstruct lockdep_map btrfs_trans_num_extwriters_map;\n\tstruct lockdep_map btrfs_state_change_map[4];\n\tstruct lockdep_map btrfs_trans_pending_ordered_map;\n\tstruct lockdep_map btrfs_ordered_extent_map;\n\n#ifdef CONFIG_BTRFS_FS_REF_VERIFY\n\tspinlock_t ref_verify_lock;\n\tstruct rb_root block_tree;\n#endif\n\n#ifdef CONFIG_BTRFS_DEBUG\n\tstruct kobject *debug_kobj;\n\tstruct list_head allocated_roots;\n\n\tspinlock_t eb_leak_lock;\n\tstruct list_head allocated_ebs;\n#endif\n};\n\nstatic inline void btrfs_set_last_root_drop_gen(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tu64 gen)\n{\n\tWRITE_ONCE(fs_info->last_root_drop_gen, gen);\n}\n\nstatic inline u64 btrfs_get_last_root_drop_gen(const struct btrfs_fs_info *fs_info)\n{\n\treturn READ_ONCE(fs_info->last_root_drop_gen);\n}\n\n \nstatic inline u64 btrfs_csum_bytes_to_leaves(\n\t\t\tconst struct btrfs_fs_info *fs_info, u64 csum_bytes)\n{\n\tconst u64 num_csums = csum_bytes >> fs_info->sectorsize_bits;\n\n\treturn DIV_ROUND_UP_ULL(num_csums, fs_info->csums_per_leaf);\n}\n\n \nstatic inline u64 btrfs_calc_insert_metadata_size(const struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\t  unsigned num_items)\n{\n\treturn (u64)fs_info->nodesize * BTRFS_MAX_LEVEL * 2 * num_items;\n}\n\n \nstatic inline u64 btrfs_calc_metadata_size(const struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\t unsigned num_items)\n{\n\treturn (u64)fs_info->nodesize * BTRFS_MAX_LEVEL * num_items;\n}\n\n#define BTRFS_MAX_EXTENT_ITEM_SIZE(r) ((BTRFS_LEAF_DATA_SIZE(r->fs_info) >> 4) - \\\n\t\t\t\t\tsizeof(struct btrfs_item))\n\nstatic inline bool btrfs_is_zoned(const struct btrfs_fs_info *fs_info)\n{\n\treturn IS_ENABLED(CONFIG_BLK_DEV_ZONED) && fs_info->zone_size > 0;\n}\n\n \nstatic inline u32 count_max_extents(struct btrfs_fs_info *fs_info, u64 size)\n{\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\tif (!fs_info)\n\t\treturn div_u64(size + BTRFS_MAX_EXTENT_SIZE - 1, BTRFS_MAX_EXTENT_SIZE);\n#endif\n\n\treturn div_u64(size + fs_info->max_extent_size - 1, fs_info->max_extent_size);\n}\n\nbool btrfs_exclop_start(struct btrfs_fs_info *fs_info,\n\t\t\tenum btrfs_exclusive_operation type);\nbool btrfs_exclop_start_try_lock(struct btrfs_fs_info *fs_info,\n\t\t\t\t enum btrfs_exclusive_operation type);\nvoid btrfs_exclop_start_unlock(struct btrfs_fs_info *fs_info);\nvoid btrfs_exclop_finish(struct btrfs_fs_info *fs_info);\nvoid btrfs_exclop_balance(struct btrfs_fs_info *fs_info,\n\t\t\t  enum btrfs_exclusive_operation op);\n\n \nvoid __btrfs_set_fs_incompat(struct btrfs_fs_info *fs_info, u64 flag,\n\t\t\t     const char *name);\nvoid __btrfs_clear_fs_incompat(struct btrfs_fs_info *fs_info, u64 flag,\n\t\t\t       const char *name);\nvoid __btrfs_set_fs_compat_ro(struct btrfs_fs_info *fs_info, u64 flag,\n\t\t\t      const char *name);\nvoid __btrfs_clear_fs_compat_ro(struct btrfs_fs_info *fs_info, u64 flag,\n\t\t\t\tconst char *name);\n\n#define __btrfs_fs_incompat(fs_info, flags)\t\t\t\t\\\n\t(!!(btrfs_super_incompat_flags((fs_info)->super_copy) & (flags)))\n\n#define __btrfs_fs_compat_ro(fs_info, flags)\t\t\t\t\\\n\t(!!(btrfs_super_compat_ro_flags((fs_info)->super_copy) & (flags)))\n\n#define btrfs_set_fs_incompat(__fs_info, opt)\t\t\t\t\\\n\t__btrfs_set_fs_incompat((__fs_info), BTRFS_FEATURE_INCOMPAT_##opt, #opt)\n\n#define btrfs_clear_fs_incompat(__fs_info, opt)\t\t\t\t\\\n\t__btrfs_clear_fs_incompat((__fs_info), BTRFS_FEATURE_INCOMPAT_##opt, #opt)\n\n#define btrfs_fs_incompat(fs_info, opt)\t\t\t\t\t\\\n\t__btrfs_fs_incompat((fs_info), BTRFS_FEATURE_INCOMPAT_##opt)\n\n#define btrfs_set_fs_compat_ro(__fs_info, opt)\t\t\t\t\\\n\t__btrfs_set_fs_compat_ro((__fs_info), BTRFS_FEATURE_COMPAT_RO_##opt, #opt)\n\n#define btrfs_clear_fs_compat_ro(__fs_info, opt)\t\t\t\\\n\t__btrfs_clear_fs_compat_ro((__fs_info), BTRFS_FEATURE_COMPAT_RO_##opt, #opt)\n\n#define btrfs_fs_compat_ro(fs_info, opt)\t\t\t\t\\\n\t__btrfs_fs_compat_ro((fs_info), BTRFS_FEATURE_COMPAT_RO_##opt)\n\n#define btrfs_clear_opt(o, opt)\t\t((o) &= ~BTRFS_MOUNT_##opt)\n#define btrfs_set_opt(o, opt)\t\t((o) |= BTRFS_MOUNT_##opt)\n#define btrfs_raw_test_opt(o, opt)\t((o) & BTRFS_MOUNT_##opt)\n#define btrfs_test_opt(fs_info, opt)\t((fs_info)->mount_opt & \\\n\t\t\t\t\t BTRFS_MOUNT_##opt)\n\n#define btrfs_set_and_info(fs_info, opt, fmt, args...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (!btrfs_test_opt(fs_info, opt))\t\t\t\t\\\n\t\tbtrfs_info(fs_info, fmt, ##args);\t\t\t\\\n\tbtrfs_set_opt(fs_info->mount_opt, opt);\t\t\t\t\\\n} while (0)\n\n#define btrfs_clear_and_info(fs_info, opt, fmt, args...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (btrfs_test_opt(fs_info, opt))\t\t\t\t\\\n\t\tbtrfs_info(fs_info, fmt, ##args);\t\t\t\\\n\tbtrfs_clear_opt(fs_info->mount_opt, opt);\t\t\t\\\n} while (0)\n\nstatic inline int btrfs_fs_closing(struct btrfs_fs_info *fs_info)\n{\n\t \n\tif (test_bit(BTRFS_FS_CLOSING_START, &fs_info->flags)) {\n\t\tif (test_bit(BTRFS_FS_CLOSING_DONE, &fs_info->flags))\n\t\t\treturn 2;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic inline int btrfs_need_cleaner_sleep(struct btrfs_fs_info *fs_info)\n{\n\treturn test_bit(BTRFS_FS_STATE_RO, &fs_info->fs_state) ||\n\t\tbtrfs_fs_closing(fs_info);\n}\n\nstatic inline void btrfs_wake_unfinished_drop(struct btrfs_fs_info *fs_info)\n{\n\tclear_and_wake_up_bit(BTRFS_FS_UNFINISHED_DROPS, &fs_info->flags);\n}\n\n#define BTRFS_FS_ERROR(fs_info)\t(READ_ONCE((fs_info)->fs_error))\n\n#define BTRFS_FS_LOG_CLEANUP_ERROR(fs_info)\t\t\t\t\\\n\t(unlikely(test_bit(BTRFS_FS_STATE_LOG_CLEANUP_ERROR,\t\t\\\n\t\t\t   &(fs_info)->fs_state)))\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\n#define EXPORT_FOR_TESTS\n\nstatic inline int btrfs_is_testing(struct btrfs_fs_info *fs_info)\n{\n\treturn test_bit(BTRFS_FS_STATE_DUMMY_FS_INFO, &fs_info->fs_state);\n}\n\nvoid btrfs_test_destroy_inode(struct inode *inode);\n\n#else\n\n#define EXPORT_FOR_TESTS static\n\nstatic inline int btrfs_is_testing(struct btrfs_fs_info *fs_info)\n{\n\treturn 0;\n}\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}