{
  "module_name": "super.c",
  "hash_id": "c3f30870da9f9100b7b40594aa09afc50bcf852d5ad3a2ad5792b7809a4b0c53",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/super.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/mount.h>\n#include <linux/writeback.h>\n#include <linux/statfs.h>\n#include <linux/compat.h>\n#include <linux/parser.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/ratelimit.h>\n#include <linux/crc32c.h>\n#include <linux/btrfs.h>\n#include \"messages.h\"\n#include \"delayed-inode.h\"\n#include \"ctree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"print-tree.h\"\n#include \"props.h\"\n#include \"xattr.h\"\n#include \"bio.h\"\n#include \"export.h\"\n#include \"compression.h\"\n#include \"rcu-string.h\"\n#include \"dev-replace.h\"\n#include \"free-space-cache.h\"\n#include \"backref.h\"\n#include \"space-info.h\"\n#include \"sysfs.h\"\n#include \"zoned.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"block-group.h\"\n#include \"discard.h\"\n#include \"qgroup.h\"\n#include \"raid56.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n#include \"defrag.h\"\n#include \"dir-item.h\"\n#include \"ioctl.h\"\n#include \"scrub.h\"\n#include \"verity.h\"\n#include \"super.h\"\n#include \"extent-tree.h\"\n#define CREATE_TRACE_POINTS\n#include <trace/events/btrfs.h>\n\nstatic const struct super_operations btrfs_super_ops;\n\n \nstatic struct file_system_type btrfs_fs_type;\nstatic struct file_system_type btrfs_root_fs_type;\n\nstatic int btrfs_remount(struct super_block *sb, int *flags, char *data);\n\nstatic void btrfs_put_super(struct super_block *sb)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\n\tbtrfs_info(fs_info, \"last unmount of filesystem %pU\", fs_info->fs_devices->fsid);\n\tclose_ctree(fs_info);\n}\n\nenum {\n\tOpt_acl, Opt_noacl,\n\tOpt_clear_cache,\n\tOpt_commit_interval,\n\tOpt_compress,\n\tOpt_compress_force,\n\tOpt_compress_force_type,\n\tOpt_compress_type,\n\tOpt_degraded,\n\tOpt_device,\n\tOpt_fatal_errors,\n\tOpt_flushoncommit, Opt_noflushoncommit,\n\tOpt_max_inline,\n\tOpt_barrier, Opt_nobarrier,\n\tOpt_datacow, Opt_nodatacow,\n\tOpt_datasum, Opt_nodatasum,\n\tOpt_defrag, Opt_nodefrag,\n\tOpt_discard, Opt_nodiscard,\n\tOpt_discard_mode,\n\tOpt_norecovery,\n\tOpt_ratio,\n\tOpt_rescan_uuid_tree,\n\tOpt_skip_balance,\n\tOpt_space_cache, Opt_no_space_cache,\n\tOpt_space_cache_version,\n\tOpt_ssd, Opt_nossd,\n\tOpt_ssd_spread, Opt_nossd_spread,\n\tOpt_subvol,\n\tOpt_subvol_empty,\n\tOpt_subvolid,\n\tOpt_thread_pool,\n\tOpt_treelog, Opt_notreelog,\n\tOpt_user_subvol_rm_allowed,\n\n\t \n\tOpt_rescue,\n\tOpt_usebackuproot,\n\tOpt_nologreplay,\n\tOpt_ignorebadroots,\n\tOpt_ignoredatacsums,\n\tOpt_rescue_all,\n\n\t \n\tOpt_recovery,\n\tOpt_inode_cache, Opt_noinode_cache,\n\n\t \n\tOpt_check_integrity,\n\tOpt_check_integrity_including_extent_data,\n\tOpt_check_integrity_print_mask,\n\tOpt_enospc_debug, Opt_noenospc_debug,\n#ifdef CONFIG_BTRFS_DEBUG\n\tOpt_fragment_data, Opt_fragment_metadata, Opt_fragment_all,\n#endif\n#ifdef CONFIG_BTRFS_FS_REF_VERIFY\n\tOpt_ref_verify,\n#endif\n\tOpt_err,\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_clear_cache, \"clear_cache\"},\n\t{Opt_commit_interval, \"commit=%u\"},\n\t{Opt_compress, \"compress\"},\n\t{Opt_compress_type, \"compress=%s\"},\n\t{Opt_compress_force, \"compress-force\"},\n\t{Opt_compress_force_type, \"compress-force=%s\"},\n\t{Opt_degraded, \"degraded\"},\n\t{Opt_device, \"device=%s\"},\n\t{Opt_fatal_errors, \"fatal_errors=%s\"},\n\t{Opt_flushoncommit, \"flushoncommit\"},\n\t{Opt_noflushoncommit, \"noflushoncommit\"},\n\t{Opt_inode_cache, \"inode_cache\"},\n\t{Opt_noinode_cache, \"noinode_cache\"},\n\t{Opt_max_inline, \"max_inline=%s\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_datacow, \"datacow\"},\n\t{Opt_nodatacow, \"nodatacow\"},\n\t{Opt_datasum, \"datasum\"},\n\t{Opt_nodatasum, \"nodatasum\"},\n\t{Opt_defrag, \"autodefrag\"},\n\t{Opt_nodefrag, \"noautodefrag\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_discard_mode, \"discard=%s\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_norecovery, \"norecovery\"},\n\t{Opt_ratio, \"metadata_ratio=%u\"},\n\t{Opt_rescan_uuid_tree, \"rescan_uuid_tree\"},\n\t{Opt_skip_balance, \"skip_balance\"},\n\t{Opt_space_cache, \"space_cache\"},\n\t{Opt_no_space_cache, \"nospace_cache\"},\n\t{Opt_space_cache_version, \"space_cache=%s\"},\n\t{Opt_ssd, \"ssd\"},\n\t{Opt_nossd, \"nossd\"},\n\t{Opt_ssd_spread, \"ssd_spread\"},\n\t{Opt_nossd_spread, \"nossd_spread\"},\n\t{Opt_subvol, \"subvol=%s\"},\n\t{Opt_subvol_empty, \"subvol=\"},\n\t{Opt_subvolid, \"subvolid=%s\"},\n\t{Opt_thread_pool, \"thread_pool=%u\"},\n\t{Opt_treelog, \"treelog\"},\n\t{Opt_notreelog, \"notreelog\"},\n\t{Opt_user_subvol_rm_allowed, \"user_subvol_rm_allowed\"},\n\n\t \n\t{Opt_rescue, \"rescue=%s\"},\n\t \n\t{Opt_nologreplay, \"nologreplay\"},\n\t \n\t{Opt_usebackuproot, \"usebackuproot\"},\n\n\t \n\t{Opt_recovery, \"recovery\"},\n\n\t \n\t{Opt_check_integrity, \"check_int\"},\n\t{Opt_check_integrity_including_extent_data, \"check_int_data\"},\n\t{Opt_check_integrity_print_mask, \"check_int_print_mask=%u\"},\n\t{Opt_enospc_debug, \"enospc_debug\"},\n\t{Opt_noenospc_debug, \"noenospc_debug\"},\n#ifdef CONFIG_BTRFS_DEBUG\n\t{Opt_fragment_data, \"fragment=data\"},\n\t{Opt_fragment_metadata, \"fragment=metadata\"},\n\t{Opt_fragment_all, \"fragment=all\"},\n#endif\n#ifdef CONFIG_BTRFS_FS_REF_VERIFY\n\t{Opt_ref_verify, \"ref_verify\"},\n#endif\n\t{Opt_err, NULL},\n};\n\nstatic const match_table_t rescue_tokens = {\n\t{Opt_usebackuproot, \"usebackuproot\"},\n\t{Opt_nologreplay, \"nologreplay\"},\n\t{Opt_ignorebadroots, \"ignorebadroots\"},\n\t{Opt_ignorebadroots, \"ibadroots\"},\n\t{Opt_ignoredatacsums, \"ignoredatacsums\"},\n\t{Opt_ignoredatacsums, \"idatacsums\"},\n\t{Opt_rescue_all, \"all\"},\n\t{Opt_err, NULL},\n};\n\nstatic bool check_ro_option(struct btrfs_fs_info *fs_info, unsigned long opt,\n\t\t\t    const char *opt_name)\n{\n\tif (fs_info->mount_opt & opt) {\n\t\tbtrfs_err(fs_info, \"%s must be used with ro mount option\",\n\t\t\t  opt_name);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int parse_rescue_options(struct btrfs_fs_info *info, const char *options)\n{\n\tchar *opts;\n\tchar *orig;\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = 0;\n\n\topts = kstrdup(options, GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\torig = opts;\n\n\twhile ((p = strsep(&opts, \":\")) != NULL) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, rescue_tokens, args);\n\t\tswitch (token){\n\t\tcase Opt_usebackuproot:\n\t\t\tbtrfs_info(info,\n\t\t\t\t   \"trying to use backup root at mount time\");\n\t\t\tbtrfs_set_opt(info->mount_opt, USEBACKUPROOT);\n\t\t\tbreak;\n\t\tcase Opt_nologreplay:\n\t\t\tbtrfs_set_and_info(info, NOLOGREPLAY,\n\t\t\t\t\t   \"disabling log replay at mount time\");\n\t\t\tbreak;\n\t\tcase Opt_ignorebadroots:\n\t\t\tbtrfs_set_and_info(info, IGNOREBADROOTS,\n\t\t\t\t\t   \"ignoring bad roots\");\n\t\t\tbreak;\n\t\tcase Opt_ignoredatacsums:\n\t\t\tbtrfs_set_and_info(info, IGNOREDATACSUMS,\n\t\t\t\t\t   \"ignoring data csums\");\n\t\t\tbreak;\n\t\tcase Opt_rescue_all:\n\t\t\tbtrfs_info(info, \"enabling all of the rescue options\");\n\t\t\tbtrfs_set_and_info(info, IGNOREDATACSUMS,\n\t\t\t\t\t   \"ignoring data csums\");\n\t\t\tbtrfs_set_and_info(info, IGNOREBADROOTS,\n\t\t\t\t\t   \"ignoring bad roots\");\n\t\t\tbtrfs_set_and_info(info, NOLOGREPLAY,\n\t\t\t\t\t   \"disabling log replay at mount time\");\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\t\tbtrfs_info(info, \"unrecognized rescue option '%s'\", p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t}\nout:\n\tkfree(orig);\n\treturn ret;\n}\n\n \nint btrfs_parse_options(struct btrfs_fs_info *info, char *options,\n\t\t\tunsigned long new_flags)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p, *num;\n\tint intarg;\n\tint ret = 0;\n\tchar *compress_type;\n\tbool compress_force = false;\n\tenum btrfs_compression_type saved_compress_type;\n\tint saved_compress_level;\n\tbool saved_compress_force;\n\tint no_compress = 0;\n\tconst bool remounting = test_bit(BTRFS_FS_STATE_REMOUNTING, &info->fs_state);\n\n\tif (btrfs_fs_compat_ro(info, FREE_SPACE_TREE))\n\t\tbtrfs_set_opt(info->mount_opt, FREE_SPACE_TREE);\n\telse if (btrfs_free_space_cache_v1_active(info)) {\n\t\tif (btrfs_is_zoned(info)) {\n\t\t\tbtrfs_info(info,\n\t\t\t\"zoned: clearing existing space cache\");\n\t\t\tbtrfs_set_super_cache_generation(info->super_copy, 0);\n\t\t} else {\n\t\t\tbtrfs_set_opt(info->mount_opt, SPACE_CACHE);\n\t\t}\n\t}\n\n\t \n\tif (!options)\n\t\tgoto check;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_degraded:\n\t\t\tbtrfs_info(info, \"allowing degraded mounts\");\n\t\t\tbtrfs_set_opt(info->mount_opt, DEGRADED);\n\t\t\tbreak;\n\t\tcase Opt_subvol:\n\t\tcase Opt_subvol_empty:\n\t\tcase Opt_subvolid:\n\t\tcase Opt_device:\n\t\t\t \n\t\t\tbreak;\n\t\tcase Opt_nodatasum:\n\t\t\tbtrfs_set_and_info(info, NODATASUM,\n\t\t\t\t\t   \"setting nodatasum\");\n\t\t\tbreak;\n\t\tcase Opt_datasum:\n\t\t\tif (btrfs_test_opt(info, NODATASUM)) {\n\t\t\t\tif (btrfs_test_opt(info, NODATACOW))\n\t\t\t\t\tbtrfs_info(info,\n\t\t\t\t\t\t   \"setting datasum, datacow enabled\");\n\t\t\t\telse\n\t\t\t\t\tbtrfs_info(info, \"setting datasum\");\n\t\t\t}\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\tbreak;\n\t\tcase Opt_nodatacow:\n\t\t\tif (!btrfs_test_opt(info, NODATACOW)) {\n\t\t\t\tif (!btrfs_test_opt(info, COMPRESS) ||\n\t\t\t\t    !btrfs_test_opt(info, FORCE_COMPRESS)) {\n\t\t\t\t\tbtrfs_info(info,\n\t\t\t\t\t\t   \"setting nodatacow, compression disabled\");\n\t\t\t\t} else {\n\t\t\t\t\tbtrfs_info(info, \"setting nodatacow\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbtrfs_clear_opt(info->mount_opt, COMPRESS);\n\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\tbtrfs_set_opt(info->mount_opt, NODATACOW);\n\t\t\tbtrfs_set_opt(info->mount_opt, NODATASUM);\n\t\t\tbreak;\n\t\tcase Opt_datacow:\n\t\t\tbtrfs_clear_and_info(info, NODATACOW,\n\t\t\t\t\t     \"setting datacow\");\n\t\t\tbreak;\n\t\tcase Opt_compress_force:\n\t\tcase Opt_compress_force_type:\n\t\t\tcompress_force = true;\n\t\t\tfallthrough;\n\t\tcase Opt_compress:\n\t\tcase Opt_compress_type:\n\t\t\tsaved_compress_type = btrfs_test_opt(info,\n\t\t\t\t\t\t\t     COMPRESS) ?\n\t\t\t\tinfo->compress_type : BTRFS_COMPRESS_NONE;\n\t\t\tsaved_compress_force =\n\t\t\t\tbtrfs_test_opt(info, FORCE_COMPRESS);\n\t\t\tsaved_compress_level = info->compress_level;\n\t\t\tif (token == Opt_compress ||\n\t\t\t    token == Opt_compress_force ||\n\t\t\t    strncmp(args[0].from, \"zlib\", 4) == 0) {\n\t\t\t\tcompress_type = \"zlib\";\n\n\t\t\t\tinfo->compress_type = BTRFS_COMPRESS_ZLIB;\n\t\t\t\tinfo->compress_level = BTRFS_ZLIB_DEFAULT_LEVEL;\n\t\t\t\t \n\t\t\t\tif (token != Opt_compress &&\n\t\t\t\t    token != Opt_compress_force)\n\t\t\t\t\tinfo->compress_level =\n\t\t\t\t\t  btrfs_compress_str2level(\n\t\t\t\t\t\t\tBTRFS_COMPRESS_ZLIB,\n\t\t\t\t\t\t\targs[0].from + 4);\n\t\t\t\tbtrfs_set_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\t\tno_compress = 0;\n\t\t\t} else if (strncmp(args[0].from, \"lzo\", 3) == 0) {\n\t\t\t\tcompress_type = \"lzo\";\n\t\t\t\tinfo->compress_type = BTRFS_COMPRESS_LZO;\n\t\t\t\tinfo->compress_level = 0;\n\t\t\t\tbtrfs_set_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\t\tbtrfs_set_fs_incompat(info, COMPRESS_LZO);\n\t\t\t\tno_compress = 0;\n\t\t\t} else if (strncmp(args[0].from, \"zstd\", 4) == 0) {\n\t\t\t\tcompress_type = \"zstd\";\n\t\t\t\tinfo->compress_type = BTRFS_COMPRESS_ZSTD;\n\t\t\t\tinfo->compress_level =\n\t\t\t\t\tbtrfs_compress_str2level(\n\t\t\t\t\t\t\t BTRFS_COMPRESS_ZSTD,\n\t\t\t\t\t\t\t args[0].from + 4);\n\t\t\t\tbtrfs_set_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\t\tbtrfs_set_fs_incompat(info, COMPRESS_ZSTD);\n\t\t\t\tno_compress = 0;\n\t\t\t} else if (strncmp(args[0].from, \"no\", 2) == 0) {\n\t\t\t\tcompress_type = \"no\";\n\t\t\t\tinfo->compress_level = 0;\n\t\t\t\tinfo->compress_type = 0;\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\t\tcompress_force = false;\n\t\t\t\tno_compress++;\n\t\t\t} else {\n\t\t\t\tbtrfs_err(info, \"unrecognized compression value %s\",\n\t\t\t\t\t  args[0].from);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (compress_force) {\n\t\t\t\tbtrfs_set_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\t}\n\t\t\tif (no_compress == 1) {\n\t\t\t\tbtrfs_info(info, \"use no compression\");\n\t\t\t} else if ((info->compress_type != saved_compress_type) ||\n\t\t\t\t   (compress_force != saved_compress_force) ||\n\t\t\t\t   (info->compress_level != saved_compress_level)) {\n\t\t\t\tbtrfs_info(info, \"%s %s compression, level %d\",\n\t\t\t\t\t   (compress_force) ? \"force\" : \"use\",\n\t\t\t\t\t   compress_type, info->compress_level);\n\t\t\t}\n\t\t\tcompress_force = false;\n\t\t\tbreak;\n\t\tcase Opt_ssd:\n\t\t\tbtrfs_set_and_info(info, SSD,\n\t\t\t\t\t   \"enabling ssd optimizations\");\n\t\t\tbtrfs_clear_opt(info->mount_opt, NOSSD);\n\t\t\tbreak;\n\t\tcase Opt_ssd_spread:\n\t\t\tbtrfs_set_and_info(info, SSD,\n\t\t\t\t\t   \"enabling ssd optimizations\");\n\t\t\tbtrfs_set_and_info(info, SSD_SPREAD,\n\t\t\t\t\t   \"using spread ssd allocation scheme\");\n\t\t\tbtrfs_clear_opt(info->mount_opt, NOSSD);\n\t\t\tbreak;\n\t\tcase Opt_nossd:\n\t\t\tbtrfs_set_opt(info->mount_opt, NOSSD);\n\t\t\tbtrfs_clear_and_info(info, SSD,\n\t\t\t\t\t     \"not using ssd optimizations\");\n\t\t\tfallthrough;\n\t\tcase Opt_nossd_spread:\n\t\t\tbtrfs_clear_and_info(info, SSD_SPREAD,\n\t\t\t\t\t     \"not using spread ssd allocation scheme\");\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tbtrfs_clear_and_info(info, NOBARRIER,\n\t\t\t\t\t     \"turning on barriers\");\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tbtrfs_set_and_info(info, NOBARRIER,\n\t\t\t\t\t   \"turning off barriers\");\n\t\t\tbreak;\n\t\tcase Opt_thread_pool:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_err(info, \"unrecognized thread_pool value %s\",\n\t\t\t\t\t  args[0].from);\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg == 0) {\n\t\t\t\tbtrfs_err(info, \"invalid value 0 for thread_pool\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinfo->thread_pool_size = intarg;\n\t\t\tbreak;\n\t\tcase Opt_max_inline:\n\t\t\tnum = match_strdup(&args[0]);\n\t\t\tif (num) {\n\t\t\t\tinfo->max_inline = memparse(num, NULL);\n\t\t\t\tkfree(num);\n\n\t\t\t\tif (info->max_inline) {\n\t\t\t\t\tinfo->max_inline = min_t(u64,\n\t\t\t\t\t\tinfo->max_inline,\n\t\t\t\t\t\tinfo->sectorsize);\n\t\t\t\t}\n\t\t\t\tbtrfs_info(info, \"max_inline at %llu\",\n\t\t\t\t\t   info->max_inline);\n\t\t\t} else {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_acl:\n#ifdef CONFIG_BTRFS_FS_POSIX_ACL\n\t\t\tinfo->sb->s_flags |= SB_POSIXACL;\n\t\t\tbreak;\n#else\n\t\t\tbtrfs_err(info, \"support for ACL not compiled in!\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n#endif\n\t\tcase Opt_noacl:\n\t\t\tinfo->sb->s_flags &= ~SB_POSIXACL;\n\t\t\tbreak;\n\t\tcase Opt_notreelog:\n\t\t\tbtrfs_set_and_info(info, NOTREELOG,\n\t\t\t\t\t   \"disabling tree log\");\n\t\t\tbreak;\n\t\tcase Opt_treelog:\n\t\t\tbtrfs_clear_and_info(info, NOTREELOG,\n\t\t\t\t\t     \"enabling tree log\");\n\t\t\tbreak;\n\t\tcase Opt_norecovery:\n\t\tcase Opt_nologreplay:\n\t\t\tbtrfs_warn(info,\n\t\t\"'nologreplay' is deprecated, use 'rescue=nologreplay' instead\");\n\t\t\tbtrfs_set_and_info(info, NOLOGREPLAY,\n\t\t\t\t\t   \"disabling log replay at mount time\");\n\t\t\tbreak;\n\t\tcase Opt_flushoncommit:\n\t\t\tbtrfs_set_and_info(info, FLUSHONCOMMIT,\n\t\t\t\t\t   \"turning on flush-on-commit\");\n\t\t\tbreak;\n\t\tcase Opt_noflushoncommit:\n\t\t\tbtrfs_clear_and_info(info, FLUSHONCOMMIT,\n\t\t\t\t\t     \"turning off flush-on-commit\");\n\t\t\tbreak;\n\t\tcase Opt_ratio:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_err(info, \"unrecognized metadata_ratio value %s\",\n\t\t\t\t\t  args[0].from);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinfo->metadata_ratio = intarg;\n\t\t\tbtrfs_info(info, \"metadata ratio %u\",\n\t\t\t\t   info->metadata_ratio);\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\tcase Opt_discard_mode:\n\t\t\tif (token == Opt_discard ||\n\t\t\t    strcmp(args[0].from, \"sync\") == 0) {\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, DISCARD_ASYNC);\n\t\t\t\tbtrfs_set_and_info(info, DISCARD_SYNC,\n\t\t\t\t\t\t   \"turning on sync discard\");\n\t\t\t} else if (strcmp(args[0].from, \"async\") == 0) {\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, DISCARD_SYNC);\n\t\t\t\tbtrfs_set_and_info(info, DISCARD_ASYNC,\n\t\t\t\t\t\t   \"turning on async discard\");\n\t\t\t} else {\n\t\t\t\tbtrfs_err(info, \"unrecognized discard mode value %s\",\n\t\t\t\t\t  args[0].from);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODISCARD);\n\t\t\tbreak;\n\t\tcase Opt_nodiscard:\n\t\t\tbtrfs_clear_and_info(info, DISCARD_SYNC,\n\t\t\t\t\t     \"turning off discard\");\n\t\t\tbtrfs_clear_and_info(info, DISCARD_ASYNC,\n\t\t\t\t\t     \"turning off async discard\");\n\t\t\tbtrfs_set_opt(info->mount_opt, NODISCARD);\n\t\t\tbreak;\n\t\tcase Opt_space_cache:\n\t\tcase Opt_space_cache_version:\n\t\t\t \n\t\t\tif (btrfs_fs_incompat(info, EXTENT_TREE_V2))\n\t\t\t\tbreak;\n\t\t\tif (token == Opt_space_cache ||\n\t\t\t    strcmp(args[0].from, \"v1\") == 0) {\n\t\t\t\tbtrfs_clear_opt(info->mount_opt,\n\t\t\t\t\t\tFREE_SPACE_TREE);\n\t\t\t\tbtrfs_set_and_info(info, SPACE_CACHE,\n\t\t\t\t\t   \"enabling disk space caching\");\n\t\t\t} else if (strcmp(args[0].from, \"v2\") == 0) {\n\t\t\t\tbtrfs_clear_opt(info->mount_opt,\n\t\t\t\t\t\tSPACE_CACHE);\n\t\t\t\tbtrfs_set_and_info(info, FREE_SPACE_TREE,\n\t\t\t\t\t\t   \"enabling free space tree\");\n\t\t\t} else {\n\t\t\t\tbtrfs_err(info, \"unrecognized space_cache value %s\",\n\t\t\t\t\t  args[0].from);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_rescan_uuid_tree:\n\t\t\tbtrfs_set_opt(info->mount_opt, RESCAN_UUID_TREE);\n\t\t\tbreak;\n\t\tcase Opt_no_space_cache:\n\t\t\t \n\t\t\tif (btrfs_fs_incompat(info, EXTENT_TREE_V2))\n\t\t\t\tbreak;\n\t\t\tif (btrfs_test_opt(info, SPACE_CACHE)) {\n\t\t\t\tbtrfs_clear_and_info(info, SPACE_CACHE,\n\t\t\t\t\t     \"disabling disk space caching\");\n\t\t\t}\n\t\t\tif (btrfs_test_opt(info, FREE_SPACE_TREE)) {\n\t\t\t\tbtrfs_clear_and_info(info, FREE_SPACE_TREE,\n\t\t\t\t\t     \"disabling free space tree\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_inode_cache:\n\t\tcase Opt_noinode_cache:\n\t\t\tbtrfs_warn(info,\n\t\"the 'inode_cache' option is deprecated and has no effect since 5.11\");\n\t\t\tbreak;\n\t\tcase Opt_clear_cache:\n\t\t\t \n\t\t\tif (btrfs_fs_incompat(info, EXTENT_TREE_V2))\n\t\t\t\tbreak;\n\t\t\tbtrfs_set_and_info(info, CLEAR_CACHE,\n\t\t\t\t\t   \"force clearing of disk cache\");\n\t\t\tbreak;\n\t\tcase Opt_user_subvol_rm_allowed:\n\t\t\tbtrfs_set_opt(info->mount_opt, USER_SUBVOL_RM_ALLOWED);\n\t\t\tbreak;\n\t\tcase Opt_enospc_debug:\n\t\t\tbtrfs_set_opt(info->mount_opt, ENOSPC_DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_noenospc_debug:\n\t\t\tbtrfs_clear_opt(info->mount_opt, ENOSPC_DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_defrag:\n\t\t\tbtrfs_set_and_info(info, AUTO_DEFRAG,\n\t\t\t\t\t   \"enabling auto defrag\");\n\t\t\tbreak;\n\t\tcase Opt_nodefrag:\n\t\t\tbtrfs_clear_and_info(info, AUTO_DEFRAG,\n\t\t\t\t\t     \"disabling auto defrag\");\n\t\t\tbreak;\n\t\tcase Opt_recovery:\n\t\tcase Opt_usebackuproot:\n\t\t\tbtrfs_warn(info,\n\t\t\t\"'%s' is deprecated, use 'rescue=usebackuproot' instead\",\n\t\t\t\t   token == Opt_recovery ? \"recovery\" :\n\t\t\t\t   \"usebackuproot\");\n\t\t\tbtrfs_info(info,\n\t\t\t\t   \"trying to use backup root at mount time\");\n\t\t\tbtrfs_set_opt(info->mount_opt, USEBACKUPROOT);\n\t\t\tbreak;\n\t\tcase Opt_skip_balance:\n\t\t\tbtrfs_set_opt(info->mount_opt, SKIP_BALANCE);\n\t\t\tbreak;\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\t\tcase Opt_check_integrity_including_extent_data:\n\t\t\tbtrfs_warn(info,\n\t\"integrity checker is deprecated and will be removed in 6.7\");\n\t\t\tbtrfs_info(info,\n\t\t\t\t   \"enabling check integrity including extent data\");\n\t\t\tbtrfs_set_opt(info->mount_opt, CHECK_INTEGRITY_DATA);\n\t\t\tbtrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);\n\t\t\tbreak;\n\t\tcase Opt_check_integrity:\n\t\t\tbtrfs_warn(info,\n\t\"integrity checker is deprecated and will be removed in 6.7\");\n\t\t\tbtrfs_info(info, \"enabling check integrity\");\n\t\t\tbtrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);\n\t\t\tbreak;\n\t\tcase Opt_check_integrity_print_mask:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_err(info,\n\t\t\t\t\"unrecognized check_integrity_print_mask value %s\",\n\t\t\t\t\targs[0].from);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinfo->check_integrity_print_mask = intarg;\n\t\t\tbtrfs_warn(info,\n\t\"integrity checker is deprecated and will be removed in 6.7\");\n\t\t\tbtrfs_info(info, \"check_integrity_print_mask 0x%x\",\n\t\t\t\t   info->check_integrity_print_mask);\n\t\t\tbreak;\n#else\n\t\tcase Opt_check_integrity_including_extent_data:\n\t\tcase Opt_check_integrity:\n\t\tcase Opt_check_integrity_print_mask:\n\t\t\tbtrfs_err(info,\n\t\t\t\t  \"support for check_integrity* not compiled in!\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n#endif\n\t\tcase Opt_fatal_errors:\n\t\t\tif (strcmp(args[0].from, \"panic\") == 0) {\n\t\t\t\tbtrfs_set_opt(info->mount_opt,\n\t\t\t\t\t      PANIC_ON_FATAL_ERROR);\n\t\t\t} else if (strcmp(args[0].from, \"bug\") == 0) {\n\t\t\t\tbtrfs_clear_opt(info->mount_opt,\n\t\t\t\t\t      PANIC_ON_FATAL_ERROR);\n\t\t\t} else {\n\t\t\t\tbtrfs_err(info, \"unrecognized fatal_errors value %s\",\n\t\t\t\t\t  args[0].from);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_commit_interval:\n\t\t\tintarg = 0;\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_err(info, \"unrecognized commit_interval value %s\",\n\t\t\t\t\t  args[0].from);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (intarg == 0) {\n\t\t\t\tbtrfs_info(info,\n\t\t\t\t\t   \"using default commit interval %us\",\n\t\t\t\t\t   BTRFS_DEFAULT_COMMIT_INTERVAL);\n\t\t\t\tintarg = BTRFS_DEFAULT_COMMIT_INTERVAL;\n\t\t\t} else if (intarg > 300) {\n\t\t\t\tbtrfs_warn(info, \"excessive commit interval %d\",\n\t\t\t\t\t   intarg);\n\t\t\t}\n\t\t\tinfo->commit_interval = intarg;\n\t\t\tbreak;\n\t\tcase Opt_rescue:\n\t\t\tret = parse_rescue_options(info, args[0].from);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_err(info, \"unrecognized rescue value %s\",\n\t\t\t\t\t  args[0].from);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tcase Opt_fragment_all:\n\t\t\tbtrfs_info(info, \"fragmenting all space\");\n\t\t\tbtrfs_set_opt(info->mount_opt, FRAGMENT_DATA);\n\t\t\tbtrfs_set_opt(info->mount_opt, FRAGMENT_METADATA);\n\t\t\tbreak;\n\t\tcase Opt_fragment_metadata:\n\t\t\tbtrfs_info(info, \"fragmenting metadata\");\n\t\t\tbtrfs_set_opt(info->mount_opt,\n\t\t\t\t      FRAGMENT_METADATA);\n\t\t\tbreak;\n\t\tcase Opt_fragment_data:\n\t\t\tbtrfs_info(info, \"fragmenting data\");\n\t\t\tbtrfs_set_opt(info->mount_opt, FRAGMENT_DATA);\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_BTRFS_FS_REF_VERIFY\n\t\tcase Opt_ref_verify:\n\t\t\tbtrfs_info(info, \"doing ref verification\");\n\t\t\tbtrfs_set_opt(info->mount_opt, REF_VERIFY);\n\t\t\tbreak;\n#endif\n\t\tcase Opt_err:\n\t\t\tbtrfs_err(info, \"unrecognized mount option '%s'\", p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\ncheck:\n\t \n\tif (new_flags & SB_RDONLY)\n\t\tgoto out;\n\n\tif (check_ro_option(info, BTRFS_MOUNT_NOLOGREPLAY, \"nologreplay\") ||\n\t    check_ro_option(info, BTRFS_MOUNT_IGNOREBADROOTS, \"ignorebadroots\") ||\n\t    check_ro_option(info, BTRFS_MOUNT_IGNOREDATACSUMS, \"ignoredatacsums\"))\n\t\tret = -EINVAL;\nout:\n\tif (btrfs_fs_compat_ro(info, FREE_SPACE_TREE) &&\n\t    !btrfs_test_opt(info, FREE_SPACE_TREE) &&\n\t    !btrfs_test_opt(info, CLEAR_CACHE)) {\n\t\tbtrfs_err(info, \"cannot disable free space tree\");\n\t\tret = -EINVAL;\n\t}\n\tif (btrfs_fs_compat_ro(info, BLOCK_GROUP_TREE) &&\n\t     !btrfs_test_opt(info, FREE_SPACE_TREE)) {\n\t\tbtrfs_err(info, \"cannot disable free space tree with block-group-tree feature\");\n\t\tret = -EINVAL;\n\t}\n\tif (!ret)\n\t\tret = btrfs_check_mountopts_zoned(info);\n\tif (!ret && !remounting) {\n\t\tif (btrfs_test_opt(info, SPACE_CACHE))\n\t\t\tbtrfs_info(info, \"disk space caching is enabled\");\n\t\tif (btrfs_test_opt(info, FREE_SPACE_TREE))\n\t\t\tbtrfs_info(info, \"using free space tree\");\n\t}\n\treturn ret;\n}\n\n \nstatic int btrfs_parse_device_options(const char *options, blk_mode_t flags)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *device_name, *opts, *orig, *p;\n\tstruct btrfs_device *device = NULL;\n\tint error = 0;\n\n\tlockdep_assert_held(&uuid_mutex);\n\n\tif (!options)\n\t\treturn 0;\n\n\t \n\topts = kstrdup(options, GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\torig = opts;\n\n\twhile ((p = strsep(&opts, \",\")) != NULL) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tif (token == Opt_device) {\n\t\t\tdevice_name = match_strdup(&args[0]);\n\t\t\tif (!device_name) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdevice = btrfs_scan_one_device(device_name, flags);\n\t\t\tkfree(device_name);\n\t\t\tif (IS_ERR(device)) {\n\t\t\t\terror = PTR_ERR(device);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tkfree(orig);\n\treturn error;\n}\n\n \nstatic int btrfs_parse_subvol_options(const char *options, char **subvol_name,\n\t\tu64 *subvol_objectid)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *opts, *orig, *p;\n\tint error = 0;\n\tu64 subvolid;\n\n\tif (!options)\n\t\treturn 0;\n\n\t \n\topts = kstrdup(options, GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\torig = opts;\n\n\twhile ((p = strsep(&opts, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_subvol:\n\t\t\tkfree(*subvol_name);\n\t\t\t*subvol_name = match_strdup(&args[0]);\n\t\t\tif (!*subvol_name) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_subvolid:\n\t\t\terror = match_u64(&args[0], &subvolid);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tif (subvolid == 0)\n\t\t\t\tsubvolid = BTRFS_FS_TREE_OBJECTID;\n\n\t\t\t*subvol_objectid = subvolid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tkfree(orig);\n\treturn error;\n}\n\nchar *btrfs_get_subvol_name_from_objectid(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  u64 subvol_objectid)\n{\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_root *fs_root = NULL;\n\tstruct btrfs_root_ref *root_ref;\n\tstruct btrfs_inode_ref *inode_ref;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path = NULL;\n\tchar *name = NULL, *ptr;\n\tu64 dirid;\n\tint len;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tname = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tptr = name + PATH_MAX - 1;\n\tptr[0] = '\\0';\n\n\t \n\twhile (subvol_objectid != BTRFS_FS_TREE_OBJECTID) {\n\t\tkey.objectid = subvol_objectid;\n\t\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\t\tkey.offset = (u64)-1;\n\n\t\tret = btrfs_search_backwards(root, &key, path);\n\t\tif (ret < 0) {\n\t\t\tgoto err;\n\t\t} else if (ret > 0) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto err;\n\t\t}\n\n\t\tsubvol_objectid = key.offset;\n\n\t\troot_ref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t  struct btrfs_root_ref);\n\t\tlen = btrfs_root_ref_name_len(path->nodes[0], root_ref);\n\t\tptr -= len + 1;\n\t\tif (ptr < name) {\n\t\t\tret = -ENAMETOOLONG;\n\t\t\tgoto err;\n\t\t}\n\t\tread_extent_buffer(path->nodes[0], ptr + 1,\n\t\t\t\t   (unsigned long)(root_ref + 1), len);\n\t\tptr[0] = '/';\n\t\tdirid = btrfs_root_ref_dirid(path->nodes[0], root_ref);\n\t\tbtrfs_release_path(path);\n\n\t\tfs_root = btrfs_get_fs_root(fs_info, subvol_objectid, true);\n\t\tif (IS_ERR(fs_root)) {\n\t\t\tret = PTR_ERR(fs_root);\n\t\t\tfs_root = NULL;\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\twhile (dirid != BTRFS_FIRST_FREE_OBJECTID) {\n\t\t\tkey.objectid = dirid;\n\t\t\tkey.type = BTRFS_INODE_REF_KEY;\n\t\t\tkey.offset = (u64)-1;\n\n\t\t\tret = btrfs_search_backwards(fs_root, &key, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto err;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tdirid = key.offset;\n\n\t\t\tinode_ref = btrfs_item_ptr(path->nodes[0],\n\t\t\t\t\t\t   path->slots[0],\n\t\t\t\t\t\t   struct btrfs_inode_ref);\n\t\t\tlen = btrfs_inode_ref_name_len(path->nodes[0],\n\t\t\t\t\t\t       inode_ref);\n\t\t\tptr -= len + 1;\n\t\t\tif (ptr < name) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tread_extent_buffer(path->nodes[0], ptr + 1,\n\t\t\t\t\t   (unsigned long)(inode_ref + 1), len);\n\t\t\tptr[0] = '/';\n\t\t\tbtrfs_release_path(path);\n\t\t}\n\t\tbtrfs_put_root(fs_root);\n\t\tfs_root = NULL;\n\t}\n\n\tbtrfs_free_path(path);\n\tif (ptr == name + PATH_MAX - 1) {\n\t\tname[0] = '/';\n\t\tname[1] = '\\0';\n\t} else {\n\t\tmemmove(name, ptr, name + PATH_MAX - ptr);\n\t}\n\treturn name;\n\nerr:\n\tbtrfs_put_root(fs_root);\n\tbtrfs_free_path(path);\n\tkfree(name);\n\treturn ERR_PTR(ret);\n}\n\nstatic int get_default_subvol_objectid(struct btrfs_fs_info *fs_info, u64 *objectid)\n{\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key location;\n\tstruct fscrypt_str name = FSTR_INIT(\"default\", 7);\n\tu64 dir_id;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t \n\tdir_id = btrfs_super_root_dir(fs_info->super_copy);\n\tdi = btrfs_lookup_dir_item(NULL, root, path, dir_id, &name, 0);\n\tif (IS_ERR(di)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(di);\n\t}\n\tif (!di) {\n\t\t \n\t\tbtrfs_free_path(path);\n\t\t*objectid = BTRFS_FS_TREE_OBJECTID;\n\t\treturn 0;\n\t}\n\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);\n\tbtrfs_free_path(path);\n\t*objectid = location.objectid;\n\treturn 0;\n}\n\nstatic int btrfs_fill_super(struct super_block *sb,\n\t\t\t    struct btrfs_fs_devices *fs_devices,\n\t\t\t    void *data)\n{\n\tstruct inode *inode;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tint err;\n\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_magic = BTRFS_SUPER_MAGIC;\n\tsb->s_op = &btrfs_super_ops;\n\tsb->s_d_op = &btrfs_dentry_operations;\n\tsb->s_export_op = &btrfs_export_ops;\n#ifdef CONFIG_FS_VERITY\n\tsb->s_vop = &btrfs_verityops;\n#endif\n\tsb->s_xattr = btrfs_xattr_handlers;\n\tsb->s_time_gran = 1;\n#ifdef CONFIG_BTRFS_FS_POSIX_ACL\n\tsb->s_flags |= SB_POSIXACL;\n#endif\n\tsb->s_flags |= SB_I_VERSION;\n\tsb->s_iflags |= SB_I_CGROUPWB;\n\n\terr = super_setup_bdi(sb);\n\tif (err) {\n\t\tbtrfs_err(fs_info, \"super_setup_bdi failed\");\n\t\treturn err;\n\t}\n\n\terr = open_ctree(sb, fs_devices, (char *)data);\n\tif (err) {\n\t\tbtrfs_err(fs_info, \"open_ctree failed\");\n\t\treturn err;\n\t}\n\n\tinode = btrfs_iget(sb, BTRFS_FIRST_FREE_OBJECTID, fs_info->fs_root);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tbtrfs_handle_fs_error(fs_info, err, NULL);\n\t\tgoto fail_close;\n\t}\n\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_close;\n\t}\n\n\tsb->s_flags |= SB_ACTIVE;\n\treturn 0;\n\nfail_close:\n\tclose_ctree(fs_info);\n\treturn err;\n}\n\nint btrfs_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *root = fs_info->tree_root;\n\n\ttrace_btrfs_sync_fs(fs_info, wait);\n\n\tif (!wait) {\n\t\tfilemap_flush(fs_info->btree_inode->i_mapping);\n\t\treturn 0;\n\t}\n\n\tbtrfs_wait_ordered_roots(fs_info, U64_MAX, 0, (u64)-1);\n\n\ttrans = btrfs_attach_transaction_barrier(root);\n\tif (IS_ERR(trans)) {\n\t\t \n\t\tif (PTR_ERR(trans) == -ENOENT) {\n\t\t\t \n\t\t\tif (!test_bit(BTRFS_FS_NEED_TRANS_COMMIT,\n\t\t\t\t      &fs_info->flags))\n\t\t\t\treturn 0;\n\t\t\t \n\t\t\tif (sb_start_write_trylock(sb))\n\t\t\t\tsb_end_write(sb);\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t\ttrans = btrfs_start_transaction(root, 0);\n\t\t}\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t}\n\treturn btrfs_commit_transaction(trans);\n}\n\nstatic void print_rescue_option(struct seq_file *seq, const char *s, bool *printed)\n{\n\tseq_printf(seq, \"%s%s\", (*printed) ? \":\" : \",rescue=\", s);\n\t*printed = true;\n}\n\nstatic int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)\n{\n\tstruct btrfs_fs_info *info = btrfs_sb(dentry->d_sb);\n\tconst char *compress_type;\n\tconst char *subvol_name;\n\tbool printed = false;\n\n\tif (btrfs_test_opt(info, DEGRADED))\n\t\tseq_puts(seq, \",degraded\");\n\tif (btrfs_test_opt(info, NODATASUM))\n\t\tseq_puts(seq, \",nodatasum\");\n\tif (btrfs_test_opt(info, NODATACOW))\n\t\tseq_puts(seq, \",nodatacow\");\n\tif (btrfs_test_opt(info, NOBARRIER))\n\t\tseq_puts(seq, \",nobarrier\");\n\tif (info->max_inline != BTRFS_DEFAULT_MAX_INLINE)\n\t\tseq_printf(seq, \",max_inline=%llu\", info->max_inline);\n\tif (info->thread_pool_size !=  min_t(unsigned long,\n\t\t\t\t\t     num_online_cpus() + 2, 8))\n\t\tseq_printf(seq, \",thread_pool=%u\", info->thread_pool_size);\n\tif (btrfs_test_opt(info, COMPRESS)) {\n\t\tcompress_type = btrfs_compress_type2str(info->compress_type);\n\t\tif (btrfs_test_opt(info, FORCE_COMPRESS))\n\t\t\tseq_printf(seq, \",compress-force=%s\", compress_type);\n\t\telse\n\t\t\tseq_printf(seq, \",compress=%s\", compress_type);\n\t\tif (info->compress_level)\n\t\t\tseq_printf(seq, \":%d\", info->compress_level);\n\t}\n\tif (btrfs_test_opt(info, NOSSD))\n\t\tseq_puts(seq, \",nossd\");\n\tif (btrfs_test_opt(info, SSD_SPREAD))\n\t\tseq_puts(seq, \",ssd_spread\");\n\telse if (btrfs_test_opt(info, SSD))\n\t\tseq_puts(seq, \",ssd\");\n\tif (btrfs_test_opt(info, NOTREELOG))\n\t\tseq_puts(seq, \",notreelog\");\n\tif (btrfs_test_opt(info, NOLOGREPLAY))\n\t\tprint_rescue_option(seq, \"nologreplay\", &printed);\n\tif (btrfs_test_opt(info, USEBACKUPROOT))\n\t\tprint_rescue_option(seq, \"usebackuproot\", &printed);\n\tif (btrfs_test_opt(info, IGNOREBADROOTS))\n\t\tprint_rescue_option(seq, \"ignorebadroots\", &printed);\n\tif (btrfs_test_opt(info, IGNOREDATACSUMS))\n\t\tprint_rescue_option(seq, \"ignoredatacsums\", &printed);\n\tif (btrfs_test_opt(info, FLUSHONCOMMIT))\n\t\tseq_puts(seq, \",flushoncommit\");\n\tif (btrfs_test_opt(info, DISCARD_SYNC))\n\t\tseq_puts(seq, \",discard\");\n\tif (btrfs_test_opt(info, DISCARD_ASYNC))\n\t\tseq_puts(seq, \",discard=async\");\n\tif (!(info->sb->s_flags & SB_POSIXACL))\n\t\tseq_puts(seq, \",noacl\");\n\tif (btrfs_free_space_cache_v1_active(info))\n\t\tseq_puts(seq, \",space_cache\");\n\telse if (btrfs_fs_compat_ro(info, FREE_SPACE_TREE))\n\t\tseq_puts(seq, \",space_cache=v2\");\n\telse\n\t\tseq_puts(seq, \",nospace_cache\");\n\tif (btrfs_test_opt(info, RESCAN_UUID_TREE))\n\t\tseq_puts(seq, \",rescan_uuid_tree\");\n\tif (btrfs_test_opt(info, CLEAR_CACHE))\n\t\tseq_puts(seq, \",clear_cache\");\n\tif (btrfs_test_opt(info, USER_SUBVOL_RM_ALLOWED))\n\t\tseq_puts(seq, \",user_subvol_rm_allowed\");\n\tif (btrfs_test_opt(info, ENOSPC_DEBUG))\n\t\tseq_puts(seq, \",enospc_debug\");\n\tif (btrfs_test_opt(info, AUTO_DEFRAG))\n\t\tseq_puts(seq, \",autodefrag\");\n\tif (btrfs_test_opt(info, SKIP_BALANCE))\n\t\tseq_puts(seq, \",skip_balance\");\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_test_opt(info, CHECK_INTEGRITY_DATA))\n\t\tseq_puts(seq, \",check_int_data\");\n\telse if (btrfs_test_opt(info, CHECK_INTEGRITY))\n\t\tseq_puts(seq, \",check_int\");\n\tif (info->check_integrity_print_mask)\n\t\tseq_printf(seq, \",check_int_print_mask=%d\",\n\t\t\t\tinfo->check_integrity_print_mask);\n#endif\n\tif (info->metadata_ratio)\n\t\tseq_printf(seq, \",metadata_ratio=%u\", info->metadata_ratio);\n\tif (btrfs_test_opt(info, PANIC_ON_FATAL_ERROR))\n\t\tseq_puts(seq, \",fatal_errors=panic\");\n\tif (info->commit_interval != BTRFS_DEFAULT_COMMIT_INTERVAL)\n\t\tseq_printf(seq, \",commit=%u\", info->commit_interval);\n#ifdef CONFIG_BTRFS_DEBUG\n\tif (btrfs_test_opt(info, FRAGMENT_DATA))\n\t\tseq_puts(seq, \",fragment=data\");\n\tif (btrfs_test_opt(info, FRAGMENT_METADATA))\n\t\tseq_puts(seq, \",fragment=metadata\");\n#endif\n\tif (btrfs_test_opt(info, REF_VERIFY))\n\t\tseq_puts(seq, \",ref_verify\");\n\tseq_printf(seq, \",subvolid=%llu\",\n\t\t  BTRFS_I(d_inode(dentry))->root->root_key.objectid);\n\tsubvol_name = btrfs_get_subvol_name_from_objectid(info,\n\t\t\tBTRFS_I(d_inode(dentry))->root->root_key.objectid);\n\tif (!IS_ERR(subvol_name)) {\n\t\tseq_puts(seq, \",subvol=\");\n\t\tseq_escape(seq, subvol_name, \" \\t\\n\\\\\");\n\t\tkfree(subvol_name);\n\t}\n\treturn 0;\n}\n\nstatic int btrfs_test_super(struct super_block *s, void *data)\n{\n\tstruct btrfs_fs_info *p = data;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(s);\n\n\treturn fs_info->fs_devices == p->fs_devices;\n}\n\nstatic int btrfs_set_super(struct super_block *s, void *data)\n{\n\tint err = set_anon_super(s, data);\n\tif (!err)\n\t\ts->s_fs_info = data;\n\treturn err;\n}\n\n \nstatic inline int is_subvolume_inode(struct inode *inode)\n{\n\tif (inode && inode->i_ino == BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic struct dentry *mount_subvol(const char *subvol_name, u64 subvol_objectid,\n\t\t\t\t   struct vfsmount *mnt)\n{\n\tstruct dentry *root;\n\tint ret;\n\n\tif (!subvol_name) {\n\t\tif (!subvol_objectid) {\n\t\t\tret = get_default_subvol_objectid(btrfs_sb(mnt->mnt_sb),\n\t\t\t\t\t\t\t  &subvol_objectid);\n\t\t\tif (ret) {\n\t\t\t\troot = ERR_PTR(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tsubvol_name = btrfs_get_subvol_name_from_objectid(\n\t\t\t\t\tbtrfs_sb(mnt->mnt_sb), subvol_objectid);\n\t\tif (IS_ERR(subvol_name)) {\n\t\t\troot = ERR_CAST(subvol_name);\n\t\t\tsubvol_name = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t}\n\n\troot = mount_subtree(mnt, subvol_name);\n\t \n\tmnt = NULL;\n\n\tif (!IS_ERR(root)) {\n\t\tstruct super_block *s = root->d_sb;\n\t\tstruct btrfs_fs_info *fs_info = btrfs_sb(s);\n\t\tstruct inode *root_inode = d_inode(root);\n\t\tu64 root_objectid = BTRFS_I(root_inode)->root->root_key.objectid;\n\n\t\tret = 0;\n\t\tif (!is_subvolume_inode(root_inode)) {\n\t\t\tbtrfs_err(fs_info, \"'%s' is not a valid subvolume\",\n\t\t\t       subvol_name);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tif (subvol_objectid && root_objectid != subvol_objectid) {\n\t\t\t \n\t\t\tbtrfs_err(fs_info,\n\t\t\t\t  \"subvol '%s' does not match subvolid %llu\",\n\t\t\t\t  subvol_name, subvol_objectid);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tif (ret) {\n\t\t\tdput(root);\n\t\t\troot = ERR_PTR(ret);\n\t\t\tdeactivate_locked_super(s);\n\t\t}\n\t}\n\nout:\n\tmntput(mnt);\n\tkfree(subvol_name);\n\treturn root;\n}\n\n \nstatic struct dentry *btrfs_mount_root(struct file_system_type *fs_type,\n\t\tint flags, const char *device_name, void *data)\n{\n\tstruct block_device *bdev = NULL;\n\tstruct super_block *s;\n\tstruct btrfs_device *device = NULL;\n\tstruct btrfs_fs_devices *fs_devices = NULL;\n\tstruct btrfs_fs_info *fs_info = NULL;\n\tvoid *new_sec_opts = NULL;\n\tblk_mode_t mode = sb_open_mode(flags);\n\tint error = 0;\n\n\tif (data) {\n\t\terror = security_sb_eat_lsm_opts(data, &new_sec_opts);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t}\n\n\t \n\tfs_info = kvzalloc(sizeof(struct btrfs_fs_info), GFP_KERNEL);\n\tif (!fs_info) {\n\t\terror = -ENOMEM;\n\t\tgoto error_sec_opts;\n\t}\n\tbtrfs_init_fs_info(fs_info);\n\n\tfs_info->super_copy = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_KERNEL);\n\tfs_info->super_for_commit = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_KERNEL);\n\tif (!fs_info->super_copy || !fs_info->super_for_commit) {\n\t\terror = -ENOMEM;\n\t\tgoto error_fs_info;\n\t}\n\n\tmutex_lock(&uuid_mutex);\n\terror = btrfs_parse_device_options(data, mode);\n\tif (error) {\n\t\tmutex_unlock(&uuid_mutex);\n\t\tgoto error_fs_info;\n\t}\n\n\tdevice = btrfs_scan_one_device(device_name, mode);\n\tif (IS_ERR(device)) {\n\t\tmutex_unlock(&uuid_mutex);\n\t\terror = PTR_ERR(device);\n\t\tgoto error_fs_info;\n\t}\n\n\tfs_devices = device->fs_devices;\n\tfs_info->fs_devices = fs_devices;\n\n\terror = btrfs_open_devices(fs_devices, mode, fs_type);\n\tmutex_unlock(&uuid_mutex);\n\tif (error)\n\t\tgoto error_fs_info;\n\n\tif (!(flags & SB_RDONLY) && fs_devices->rw_devices == 0) {\n\t\terror = -EACCES;\n\t\tgoto error_close_devices;\n\t}\n\n\tbdev = fs_devices->latest_dev->bdev;\n\ts = sget(fs_type, btrfs_test_super, btrfs_set_super, flags | SB_NOSEC,\n\t\t fs_info);\n\tif (IS_ERR(s)) {\n\t\terror = PTR_ERR(s);\n\t\tgoto error_close_devices;\n\t}\n\n\tif (s->s_root) {\n\t\tbtrfs_close_devices(fs_devices);\n\t\tbtrfs_free_fs_info(fs_info);\n\t\tif ((flags ^ s->s_flags) & SB_RDONLY)\n\t\t\terror = -EBUSY;\n\t} else {\n\t\tsnprintf(s->s_id, sizeof(s->s_id), \"%pg\", bdev);\n\t\tshrinker_debugfs_rename(&s->s_shrink, \"sb-%s:%s\", fs_type->name,\n\t\t\t\t\ts->s_id);\n\t\tbtrfs_sb(s)->bdev_holder = fs_type;\n\t\terror = btrfs_fill_super(s, fs_devices, data);\n\t}\n\tif (!error)\n\t\terror = security_sb_set_mnt_opts(s, new_sec_opts, 0, NULL);\n\tsecurity_free_mnt_opts(&new_sec_opts);\n\tif (error) {\n\t\tdeactivate_locked_super(s);\n\t\treturn ERR_PTR(error);\n\t}\n\n\treturn dget(s->s_root);\n\nerror_close_devices:\n\tbtrfs_close_devices(fs_devices);\nerror_fs_info:\n\tbtrfs_free_fs_info(fs_info);\nerror_sec_opts:\n\tsecurity_free_mnt_opts(&new_sec_opts);\n\treturn ERR_PTR(error);\n}\n\n \nstatic struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,\n\t\tconst char *device_name, void *data)\n{\n\tstruct vfsmount *mnt_root;\n\tstruct dentry *root;\n\tchar *subvol_name = NULL;\n\tu64 subvol_objectid = 0;\n\tint error = 0;\n\n\terror = btrfs_parse_subvol_options(data, &subvol_name,\n\t\t\t\t\t&subvol_objectid);\n\tif (error) {\n\t\tkfree(subvol_name);\n\t\treturn ERR_PTR(error);\n\t}\n\n\t \n\tmnt_root = vfs_kern_mount(&btrfs_root_fs_type, flags, device_name, data);\n\tif (PTR_ERR_OR_ZERO(mnt_root) == -EBUSY) {\n\t\tif (flags & SB_RDONLY) {\n\t\t\tmnt_root = vfs_kern_mount(&btrfs_root_fs_type,\n\t\t\t\tflags & ~SB_RDONLY, device_name, data);\n\t\t} else {\n\t\t\tmnt_root = vfs_kern_mount(&btrfs_root_fs_type,\n\t\t\t\tflags | SB_RDONLY, device_name, data);\n\t\t\tif (IS_ERR(mnt_root)) {\n\t\t\t\troot = ERR_CAST(mnt_root);\n\t\t\t\tkfree(subvol_name);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tdown_write(&mnt_root->mnt_sb->s_umount);\n\t\t\terror = btrfs_remount(mnt_root->mnt_sb, &flags, NULL);\n\t\t\tup_write(&mnt_root->mnt_sb->s_umount);\n\t\t\tif (error < 0) {\n\t\t\t\troot = ERR_PTR(error);\n\t\t\t\tmntput(mnt_root);\n\t\t\t\tkfree(subvol_name);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_ERR(mnt_root)) {\n\t\troot = ERR_CAST(mnt_root);\n\t\tkfree(subvol_name);\n\t\tgoto out;\n\t}\n\n\t \n\troot = mount_subvol(subvol_name, subvol_objectid, mnt_root);\n\nout:\n\treturn root;\n}\n\nstatic void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,\n\t\t\t\t     u32 new_pool_size, u32 old_pool_size)\n{\n\tif (new_pool_size == old_pool_size)\n\t\treturn;\n\n\tfs_info->thread_pool_size = new_pool_size;\n\n\tbtrfs_info(fs_info, \"resize thread pool %d -> %d\",\n\t       old_pool_size, new_pool_size);\n\n\tbtrfs_workqueue_set_max(fs_info->workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->delalloc_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->caching_workers, new_pool_size);\n\tworkqueue_set_max_active(fs_info->endio_workers, new_pool_size);\n\tworkqueue_set_max_active(fs_info->endio_meta_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_write_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_freespace_worker, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->delayed_workers, new_pool_size);\n}\n\nstatic inline void btrfs_remount_begin(struct btrfs_fs_info *fs_info,\n\t\t\t\t       unsigned long old_opts, int flags)\n{\n\tif (btrfs_raw_test_opt(old_opts, AUTO_DEFRAG) &&\n\t    (!btrfs_raw_test_opt(fs_info->mount_opt, AUTO_DEFRAG) ||\n\t     (flags & SB_RDONLY))) {\n\t\t \n\t\twait_event(fs_info->transaction_wait,\n\t\t\t   (atomic_read(&fs_info->defrag_running) == 0));\n\t\tif (flags & SB_RDONLY)\n\t\t\tsync_filesystem(fs_info->sb);\n\t}\n}\n\nstatic inline void btrfs_remount_cleanup(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t unsigned long old_opts)\n{\n\tconst bool cache_opt = btrfs_test_opt(fs_info, SPACE_CACHE);\n\n\t \n\tif (btrfs_raw_test_opt(old_opts, AUTO_DEFRAG) &&\n\t    (!btrfs_raw_test_opt(fs_info->mount_opt, AUTO_DEFRAG) || sb_rdonly(fs_info->sb))) {\n\t\tbtrfs_cleanup_defrag_inodes(fs_info);\n\t}\n\n\t \n\tif (!btrfs_raw_test_opt(old_opts, DISCARD_ASYNC) &&\n\t    btrfs_test_opt(fs_info, DISCARD_ASYNC))\n\t\tbtrfs_discard_resume(fs_info);\n\telse if (btrfs_raw_test_opt(old_opts, DISCARD_ASYNC) &&\n\t\t !btrfs_test_opt(fs_info, DISCARD_ASYNC))\n\t\tbtrfs_discard_cleanup(fs_info);\n\n\t \n\tif (cache_opt != btrfs_free_space_cache_v1_active(fs_info))\n\t\tbtrfs_set_free_space_cache_v1_active(fs_info, cache_opt);\n}\n\nstatic int btrfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tunsigned old_flags = sb->s_flags;\n\tunsigned long old_opts = fs_info->mount_opt;\n\tunsigned long old_compress_type = fs_info->compress_type;\n\tu64 old_max_inline = fs_info->max_inline;\n\tu32 old_thread_pool_size = fs_info->thread_pool_size;\n\tu32 old_metadata_ratio = fs_info->metadata_ratio;\n\tint ret;\n\n\tsync_filesystem(sb);\n\tset_bit(BTRFS_FS_STATE_REMOUNTING, &fs_info->fs_state);\n\n\tif (data) {\n\t\tvoid *new_sec_opts = NULL;\n\n\t\tret = security_sb_eat_lsm_opts(data, &new_sec_opts);\n\t\tif (!ret)\n\t\t\tret = security_sb_remount(sb, new_sec_opts);\n\t\tsecurity_free_mnt_opts(&new_sec_opts);\n\t\tif (ret)\n\t\t\tgoto restore;\n\t}\n\n\tret = btrfs_parse_options(fs_info, data, *flags);\n\tif (ret)\n\t\tgoto restore;\n\n\tret = btrfs_check_features(fs_info, !(*flags & SB_RDONLY));\n\tif (ret < 0)\n\t\tgoto restore;\n\n\tbtrfs_remount_begin(fs_info, old_opts, *flags);\n\tbtrfs_resize_thread_pool(fs_info,\n\t\tfs_info->thread_pool_size, old_thread_pool_size);\n\n\tif ((bool)btrfs_test_opt(fs_info, FREE_SPACE_TREE) !=\n\t    (bool)btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE) &&\n\t    (!sb_rdonly(sb) || (*flags & SB_RDONLY))) {\n\t\tbtrfs_warn(fs_info,\n\t\t\"remount supports changing free space tree only from ro to rw\");\n\t\t \n\t\tif (btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE)) {\n\t\t\tbtrfs_set_opt(fs_info->mount_opt, FREE_SPACE_TREE);\n\t\t\tbtrfs_clear_opt(fs_info->mount_opt, SPACE_CACHE);\n\t\t}\n\t\tif (btrfs_free_space_cache_v1_active(fs_info)) {\n\t\t\tbtrfs_clear_opt(fs_info->mount_opt, FREE_SPACE_TREE);\n\t\t\tbtrfs_set_opt(fs_info->mount_opt, SPACE_CACHE);\n\t\t}\n\t}\n\n\tif ((bool)(*flags & SB_RDONLY) == sb_rdonly(sb))\n\t\tgoto out;\n\n\tif (*flags & SB_RDONLY) {\n\t\t \n\t\tcancel_work_sync(&fs_info->async_reclaim_work);\n\t\tcancel_work_sync(&fs_info->async_data_reclaim_work);\n\n\t\tbtrfs_discard_cleanup(fs_info);\n\n\t\t \n\t\tdown(&fs_info->uuid_tree_rescan_sem);\n\t\t \n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\n\t\tbtrfs_set_sb_rdonly(sb);\n\n\t\t \n\t\tbtrfs_delete_unused_bgs(fs_info);\n\n\t\t \n\t\twait_on_bit(&fs_info->flags, BTRFS_FS_CLEANER_RUNNING,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\n\t\t \n\t\tbtrfs_run_delayed_iputs(fs_info);\n\n\t\tbtrfs_dev_replace_suspend_for_unmount(fs_info);\n\t\tbtrfs_scrub_cancel(fs_info);\n\t\tbtrfs_pause_balance(fs_info);\n\n\t\t \n\t\tbtrfs_qgroup_wait_for_completion(fs_info, false);\n\n\t\tret = btrfs_commit_super(fs_info);\n\t\tif (ret)\n\t\t\tgoto restore;\n\t} else {\n\t\tif (BTRFS_FS_ERROR(fs_info)) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\"Remounting read-write after error is not allowed\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto restore;\n\t\t}\n\t\tif (fs_info->fs_devices->rw_devices == 0) {\n\t\t\tret = -EACCES;\n\t\t\tgoto restore;\n\t\t}\n\n\t\tif (!btrfs_check_rw_degradable(fs_info, NULL)) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\"too many missing devices, writable remount is not allowed\");\n\t\t\tret = -EACCES;\n\t\t\tgoto restore;\n\t\t}\n\n\t\tif (btrfs_super_log_root(fs_info->super_copy) != 0) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\"mount required to replay tree-log, cannot remount read-write\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto restore;\n\t\t}\n\n\t\t \n\t\tret = btrfs_start_pre_rw_mount(fs_info);\n\t\tif (ret)\n\t\t\tgoto restore;\n\n\t\tbtrfs_clear_sb_rdonly(sb);\n\n\t\tset_bit(BTRFS_FS_OPEN, &fs_info->flags);\n\n\t\t \n\t\tbtrfs_discard_resume(fs_info);\n\t}\nout:\n\t \n\t*flags |= SB_I_VERSION;\n\n\twake_up_process(fs_info->transaction_kthread);\n\tbtrfs_remount_cleanup(fs_info, old_opts);\n\tbtrfs_clear_oneshot_options(fs_info);\n\tclear_bit(BTRFS_FS_STATE_REMOUNTING, &fs_info->fs_state);\n\n\treturn 0;\n\nrestore:\n\t \n\tif (sb_rdonly(sb))\n\t\told_flags |= SB_RDONLY;\n\tif (!(old_flags & SB_RDONLY))\n\t\tclear_bit(BTRFS_FS_STATE_RO, &fs_info->fs_state);\n\tsb->s_flags = old_flags;\n\tfs_info->mount_opt = old_opts;\n\tfs_info->compress_type = old_compress_type;\n\tfs_info->max_inline = old_max_inline;\n\tbtrfs_resize_thread_pool(fs_info,\n\t\told_thread_pool_size, fs_info->thread_pool_size);\n\tfs_info->metadata_ratio = old_metadata_ratio;\n\tbtrfs_remount_cleanup(fs_info, old_opts);\n\tclear_bit(BTRFS_FS_STATE_REMOUNTING, &fs_info->fs_state);\n\n\treturn ret;\n}\n\n \nstatic int btrfs_cmp_device_free_bytes(const void *a, const void *b)\n{\n\tconst struct btrfs_device_info *dev_info1 = a;\n\tconst struct btrfs_device_info *dev_info2 = b;\n\n\tif (dev_info1->max_avail > dev_info2->max_avail)\n\t\treturn -1;\n\telse if (dev_info1->max_avail < dev_info2->max_avail)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic inline void btrfs_descending_sort_devices(\n\t\t\t\t\tstruct btrfs_device_info *devices,\n\t\t\t\t\tsize_t nr_devices)\n{\n\tsort(devices, nr_devices, sizeof(struct btrfs_device_info),\n\t     btrfs_cmp_device_free_bytes, NULL);\n}\n\n \nstatic inline int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t      u64 *free_bytes)\n{\n\tstruct btrfs_device_info *devices_info;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\tu64 type;\n\tu64 avail_space;\n\tu64 min_stripe_size;\n\tint num_stripes = 1;\n\tint i = 0, nr_devices;\n\tconst struct btrfs_raid_attr *rattr;\n\n\t \n\tnr_devices = fs_info->fs_devices->open_devices;\n\tif (!nr_devices) {\n\t\tsmp_mb();\n\t\tnr_devices = fs_info->fs_devices->open_devices;\n\t\tASSERT(nr_devices);\n\t\tif (!nr_devices) {\n\t\t\t*free_bytes = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdevices_info = kmalloc_array(nr_devices, sizeof(*devices_info),\n\t\t\t       GFP_KERNEL);\n\tif (!devices_info)\n\t\treturn -ENOMEM;\n\n\t \n\ttype = btrfs_data_alloc_profile(fs_info);\n\trattr = &btrfs_raid_array[btrfs_bg_flags_to_raid_index(type)];\n\n\tif (type & BTRFS_BLOCK_GROUP_RAID0)\n\t\tnum_stripes = nr_devices;\n\telse if (type & BTRFS_BLOCK_GROUP_RAID1_MASK)\n\t\tnum_stripes = rattr->ncopies;\n\telse if (type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tnum_stripes = 4;\n\n\t \n\tmin_stripe_size = rattr->dev_stripes * BTRFS_STRIPE_LEN;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(device, &fs_devices->devices, dev_list) {\n\t\tif (!test_bit(BTRFS_DEV_STATE_IN_FS_METADATA,\n\t\t\t\t\t\t&device->dev_state) ||\n\t\t    !device->bdev ||\n\t\t    test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state))\n\t\t\tcontinue;\n\n\t\tif (i >= nr_devices)\n\t\t\tbreak;\n\n\t\tavail_space = device->total_bytes - device->bytes_used;\n\n\t\t \n\t\tavail_space = rounddown(avail_space, BTRFS_STRIPE_LEN);\n\n\t\t \n\t\tif (avail_space <= BTRFS_DEVICE_RANGE_RESERVED + min_stripe_size)\n\t\t\tcontinue;\n\n\t\tavail_space -= BTRFS_DEVICE_RANGE_RESERVED;\n\n\t\tdevices_info[i].dev = device;\n\t\tdevices_info[i].max_avail = avail_space;\n\n\t\ti++;\n\t}\n\trcu_read_unlock();\n\n\tnr_devices = i;\n\n\tbtrfs_descending_sort_devices(devices_info, nr_devices);\n\n\ti = nr_devices - 1;\n\tavail_space = 0;\n\twhile (nr_devices >= rattr->devs_min) {\n\t\tnum_stripes = min(num_stripes, nr_devices);\n\n\t\tif (devices_info[i].max_avail >= min_stripe_size) {\n\t\t\tint j;\n\t\t\tu64 alloc_size;\n\n\t\t\tavail_space += devices_info[i].max_avail * num_stripes;\n\t\t\talloc_size = devices_info[i].max_avail;\n\t\t\tfor (j = i + 1 - num_stripes; j <= i; j++)\n\t\t\t\tdevices_info[j].max_avail -= alloc_size;\n\t\t}\n\t\ti--;\n\t\tnr_devices--;\n\t}\n\n\tkfree(devices_info);\n\t*free_bytes = avail_space;\n\treturn 0;\n}\n\n \nstatic int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(dentry->d_sb);\n\tstruct btrfs_super_block *disk_super = fs_info->super_copy;\n\tstruct btrfs_space_info *found;\n\tu64 total_used = 0;\n\tu64 total_free_data = 0;\n\tu64 total_free_meta = 0;\n\tu32 bits = fs_info->sectorsize_bits;\n\t__be32 *fsid = (__be32 *)fs_info->fs_devices->fsid;\n\tunsigned factor = 1;\n\tstruct btrfs_block_rsv *block_rsv = &fs_info->global_block_rsv;\n\tint ret;\n\tu64 thresh = 0;\n\tint mixed = 0;\n\n\tlist_for_each_entry(found, &fs_info->space_info, list) {\n\t\tif (found->flags & BTRFS_BLOCK_GROUP_DATA) {\n\t\t\tint i;\n\n\t\t\ttotal_free_data += found->disk_total - found->disk_used;\n\t\t\ttotal_free_data -=\n\t\t\t\tbtrfs_account_ro_block_groups_free_space(found);\n\n\t\t\tfor (i = 0; i < BTRFS_NR_RAID_TYPES; i++) {\n\t\t\t\tif (!list_empty(&found->block_groups[i]))\n\t\t\t\t\tfactor = btrfs_bg_type_to_factor(\n\t\t\t\t\t\tbtrfs_raid_array[i].bg_flag);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!mixed && found->flags & BTRFS_BLOCK_GROUP_METADATA) {\n\t\t\tif (found->flags & BTRFS_BLOCK_GROUP_DATA)\n\t\t\t\tmixed = 1;\n\t\t\telse\n\t\t\t\ttotal_free_meta += found->disk_total -\n\t\t\t\t\tfound->disk_used;\n\t\t}\n\n\t\ttotal_used += found->disk_used;\n\t}\n\n\tbuf->f_blocks = div_u64(btrfs_super_total_bytes(disk_super), factor);\n\tbuf->f_blocks >>= bits;\n\tbuf->f_bfree = buf->f_blocks - (div_u64(total_used, factor) >> bits);\n\n\t \n\tspin_lock(&block_rsv->lock);\n\t \n\tif (buf->f_bfree >= block_rsv->size >> bits)\n\t\tbuf->f_bfree -= block_rsv->size >> bits;\n\telse\n\t\tbuf->f_bfree = 0;\n\tspin_unlock(&block_rsv->lock);\n\n\tbuf->f_bavail = div_u64(total_free_data, factor);\n\tret = btrfs_calc_avail_data_space(fs_info, &total_free_data);\n\tif (ret)\n\t\treturn ret;\n\tbuf->f_bavail += div_u64(total_free_data, factor);\n\tbuf->f_bavail = buf->f_bavail >> bits;\n\n\t \n\tthresh = SZ_4M;\n\n\t \n\tif (!mixed && block_rsv->space_info->full &&\n\t    (total_free_meta < thresh || total_free_meta - thresh < block_rsv->size))\n\t\tbuf->f_bavail = 0;\n\n\tbuf->f_type = BTRFS_SUPER_MAGIC;\n\tbuf->f_bsize = dentry->d_sb->s_blocksize;\n\tbuf->f_namelen = BTRFS_NAME_LEN;\n\n\t \n\tbuf->f_fsid.val[0] = be32_to_cpu(fsid[0]) ^ be32_to_cpu(fsid[2]);\n\tbuf->f_fsid.val[1] = be32_to_cpu(fsid[1]) ^ be32_to_cpu(fsid[3]);\n\t \n\tbuf->f_fsid.val[0] ^=\n\t\tBTRFS_I(d_inode(dentry))->root->root_key.objectid >> 32;\n\tbuf->f_fsid.val[1] ^=\n\t\tBTRFS_I(d_inode(dentry))->root->root_key.objectid;\n\n\treturn 0;\n}\n\nstatic void btrfs_kill_super(struct super_block *sb)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tkill_anon_super(sb);\n\tbtrfs_free_fs_info(fs_info);\n}\n\nstatic struct file_system_type btrfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"btrfs\",\n\t.mount\t\t= btrfs_mount,\n\t.kill_sb\t= btrfs_kill_super,\n\t.fs_flags\t= FS_REQUIRES_DEV | FS_BINARY_MOUNTDATA,\n};\n\nstatic struct file_system_type btrfs_root_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"btrfs\",\n\t.mount\t\t= btrfs_mount_root,\n\t.kill_sb\t= btrfs_kill_super,\n\t.fs_flags\t= FS_REQUIRES_DEV | FS_BINARY_MOUNTDATA | FS_ALLOW_IDMAP,\n};\n\nMODULE_ALIAS_FS(\"btrfs\");\n\nstatic int btrfs_control_open(struct inode *inode, struct file *file)\n{\n\t \n\tfile->private_data = NULL;\n\treturn 0;\n}\n\n \nstatic long btrfs_control_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tstruct btrfs_ioctl_vol_args *vol;\n\tstruct btrfs_device *device = NULL;\n\tdev_t devt = 0;\n\tint ret = -ENOTTY;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tvol = memdup_user((void __user *)arg, sizeof(*vol));\n\tif (IS_ERR(vol))\n\t\treturn PTR_ERR(vol);\n\tvol->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\n\tswitch (cmd) {\n\tcase BTRFS_IOC_SCAN_DEV:\n\t\tmutex_lock(&uuid_mutex);\n\t\tdevice = btrfs_scan_one_device(vol->name, BLK_OPEN_READ);\n\t\tret = PTR_ERR_OR_ZERO(device);\n\t\tmutex_unlock(&uuid_mutex);\n\t\tbreak;\n\tcase BTRFS_IOC_FORGET_DEV:\n\t\tif (vol->name[0] != 0) {\n\t\t\tret = lookup_bdev(vol->name, &devt);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = btrfs_forget_devices(devt);\n\t\tbreak;\n\tcase BTRFS_IOC_DEVICES_READY:\n\t\tmutex_lock(&uuid_mutex);\n\t\tdevice = btrfs_scan_one_device(vol->name, BLK_OPEN_READ);\n\t\tif (IS_ERR(device)) {\n\t\t\tmutex_unlock(&uuid_mutex);\n\t\t\tret = PTR_ERR(device);\n\t\t\tbreak;\n\t\t}\n\t\tret = !(device->fs_devices->num_devices ==\n\t\t\tdevice->fs_devices->total_devices);\n\t\tmutex_unlock(&uuid_mutex);\n\t\tbreak;\n\tcase BTRFS_IOC_GET_SUPPORTED_FEATURES:\n\t\tret = btrfs_ioctl_get_supported_features((void __user*)arg);\n\t\tbreak;\n\t}\n\n\tkfree(vol);\n\treturn ret;\n}\n\nstatic int btrfs_freeze(struct super_block *sb)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *root = fs_info->tree_root;\n\n\tset_bit(BTRFS_FS_FROZEN, &fs_info->flags);\n\t \n\ttrans = btrfs_attach_transaction_barrier(root);\n\tif (IS_ERR(trans)) {\n\t\t \n\t\tif (PTR_ERR(trans) == -ENOENT)\n\t\t\treturn 0;\n\t\treturn PTR_ERR(trans);\n\t}\n\treturn btrfs_commit_transaction(trans);\n}\n\nstatic int check_dev_super(struct btrfs_device *dev)\n{\n\tstruct btrfs_fs_info *fs_info = dev->fs_info;\n\tstruct btrfs_super_block *sb;\n\tu16 csum_type;\n\tint ret = 0;\n\n\t \n\tASSERT(test_bit(BTRFS_FS_FROZEN, &fs_info->flags));\n\n\t \n\tif (!dev->bdev)\n\t\treturn 0;\n\n\t \n\tsb = btrfs_read_dev_one_super(dev->bdev, 0, true);\n\tif (IS_ERR(sb))\n\t\treturn PTR_ERR(sb);\n\n\t \n\tcsum_type = btrfs_super_csum_type(sb);\n\tif (csum_type != btrfs_super_csum_type(fs_info->super_copy)) {\n\t\tbtrfs_err(fs_info, \"csum type changed, has %u expect %u\",\n\t\t\t  csum_type, btrfs_super_csum_type(fs_info->super_copy));\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\tif (btrfs_check_super_csum(fs_info, sb)) {\n\t\tbtrfs_err(fs_info, \"csum for on-disk super block no longer matches\");\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\t \n\tret = btrfs_validate_super(fs_info, sb, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (btrfs_super_generation(sb) != fs_info->last_trans_committed) {\n\t\tbtrfs_err(fs_info, \"transid mismatch, has %llu expect %llu\",\n\t\t\tbtrfs_super_generation(sb),\n\t\t\tfs_info->last_trans_committed);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\nout:\n\tbtrfs_release_disk_super(sb);\n\treturn ret;\n}\n\nstatic int btrfs_unfreeze(struct super_block *sb)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_device *device;\n\tint ret = 0;\n\n\t \n\tlist_for_each_entry(device, &fs_info->fs_devices->devices, dev_list) {\n\t\tret = check_dev_super(device);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_handle_fs_error(fs_info, ret,\n\t\t\t\t\"super block on devid %llu got modified unexpectedly\",\n\t\t\t\tdevice->devid);\n\t\t\tbreak;\n\t\t}\n\t}\n\tclear_bit(BTRFS_FS_FROZEN, &fs_info->flags);\n\n\t \n\treturn 0;\n}\n\nstatic int btrfs_show_devname(struct seq_file *m, struct dentry *root)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(root->d_sb);\n\n\t \n\trcu_read_lock();\n\tseq_escape(m, btrfs_dev_name(fs_info->fs_devices->latest_dev), \" \\t\\n\\\\\");\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic const struct super_operations btrfs_super_ops = {\n\t.drop_inode\t= btrfs_drop_inode,\n\t.evict_inode\t= btrfs_evict_inode,\n\t.put_super\t= btrfs_put_super,\n\t.sync_fs\t= btrfs_sync_fs,\n\t.show_options\t= btrfs_show_options,\n\t.show_devname\t= btrfs_show_devname,\n\t.alloc_inode\t= btrfs_alloc_inode,\n\t.destroy_inode\t= btrfs_destroy_inode,\n\t.free_inode\t= btrfs_free_inode,\n\t.statfs\t\t= btrfs_statfs,\n\t.remount_fs\t= btrfs_remount,\n\t.freeze_fs\t= btrfs_freeze,\n\t.unfreeze_fs\t= btrfs_unfreeze,\n};\n\nstatic const struct file_operations btrfs_ctl_fops = {\n\t.open = btrfs_control_open,\n\t.unlocked_ioctl\t = btrfs_control_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n\t.owner\t = THIS_MODULE,\n\t.llseek = noop_llseek,\n};\n\nstatic struct miscdevice btrfs_misc = {\n\t.minor\t\t= BTRFS_MINOR,\n\t.name\t\t= \"btrfs-control\",\n\t.fops\t\t= &btrfs_ctl_fops\n};\n\nMODULE_ALIAS_MISCDEV(BTRFS_MINOR);\nMODULE_ALIAS(\"devname:btrfs-control\");\n\nstatic int __init btrfs_interface_init(void)\n{\n\treturn misc_register(&btrfs_misc);\n}\n\nstatic __cold void btrfs_interface_exit(void)\n{\n\tmisc_deregister(&btrfs_misc);\n}\n\nstatic int __init btrfs_print_mod_info(void)\n{\n\tstatic const char options[] = \"\"\n#ifdef CONFIG_BTRFS_DEBUG\n\t\t\t\", debug=on\"\n#endif\n#ifdef CONFIG_BTRFS_ASSERT\n\t\t\t\", assert=on\"\n#endif\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\t\t\t\", integrity-checker=on\"\n#endif\n#ifdef CONFIG_BTRFS_FS_REF_VERIFY\n\t\t\t\", ref-verify=on\"\n#endif\n#ifdef CONFIG_BLK_DEV_ZONED\n\t\t\t\", zoned=yes\"\n#else\n\t\t\t\", zoned=no\"\n#endif\n#ifdef CONFIG_FS_VERITY\n\t\t\t\", fsverity=yes\"\n#else\n\t\t\t\", fsverity=no\"\n#endif\n\t\t\t;\n\tpr_info(\"Btrfs loaded%s\\n\", options);\n\treturn 0;\n}\n\nstatic int register_btrfs(void)\n{\n\treturn register_filesystem(&btrfs_fs_type);\n}\n\nstatic void unregister_btrfs(void)\n{\n\tunregister_filesystem(&btrfs_fs_type);\n}\n\n \nstruct init_sequence {\n\tint (*init_func)(void);\n\t \n\tvoid (*exit_func)(void);\n};\n\nstatic const struct init_sequence mod_init_seq[] = {\n\t{\n\t\t.init_func = btrfs_props_init,\n\t\t.exit_func = NULL,\n\t}, {\n\t\t.init_func = btrfs_init_sysfs,\n\t\t.exit_func = btrfs_exit_sysfs,\n\t}, {\n\t\t.init_func = btrfs_init_compress,\n\t\t.exit_func = btrfs_exit_compress,\n\t}, {\n\t\t.init_func = btrfs_init_cachep,\n\t\t.exit_func = btrfs_destroy_cachep,\n\t}, {\n\t\t.init_func = btrfs_transaction_init,\n\t\t.exit_func = btrfs_transaction_exit,\n\t}, {\n\t\t.init_func = btrfs_ctree_init,\n\t\t.exit_func = btrfs_ctree_exit,\n\t}, {\n\t\t.init_func = btrfs_free_space_init,\n\t\t.exit_func = btrfs_free_space_exit,\n\t}, {\n\t\t.init_func = extent_state_init_cachep,\n\t\t.exit_func = extent_state_free_cachep,\n\t}, {\n\t\t.init_func = extent_buffer_init_cachep,\n\t\t.exit_func = extent_buffer_free_cachep,\n\t}, {\n\t\t.init_func = btrfs_bioset_init,\n\t\t.exit_func = btrfs_bioset_exit,\n\t}, {\n\t\t.init_func = extent_map_init,\n\t\t.exit_func = extent_map_exit,\n\t}, {\n\t\t.init_func = ordered_data_init,\n\t\t.exit_func = ordered_data_exit,\n\t}, {\n\t\t.init_func = btrfs_delayed_inode_init,\n\t\t.exit_func = btrfs_delayed_inode_exit,\n\t}, {\n\t\t.init_func = btrfs_auto_defrag_init,\n\t\t.exit_func = btrfs_auto_defrag_exit,\n\t}, {\n\t\t.init_func = btrfs_delayed_ref_init,\n\t\t.exit_func = btrfs_delayed_ref_exit,\n\t}, {\n\t\t.init_func = btrfs_prelim_ref_init,\n\t\t.exit_func = btrfs_prelim_ref_exit,\n\t}, {\n\t\t.init_func = btrfs_interface_init,\n\t\t.exit_func = btrfs_interface_exit,\n\t}, {\n\t\t.init_func = btrfs_print_mod_info,\n\t\t.exit_func = NULL,\n\t}, {\n\t\t.init_func = btrfs_run_sanity_tests,\n\t\t.exit_func = NULL,\n\t}, {\n\t\t.init_func = register_btrfs,\n\t\t.exit_func = unregister_btrfs,\n\t}\n};\n\nstatic bool mod_init_result[ARRAY_SIZE(mod_init_seq)];\n\nstatic __always_inline void btrfs_exit_btrfs_fs(void)\n{\n\tint i;\n\n\tfor (i = ARRAY_SIZE(mod_init_seq) - 1; i >= 0; i--) {\n\t\tif (!mod_init_result[i])\n\t\t\tcontinue;\n\t\tif (mod_init_seq[i].exit_func)\n\t\t\tmod_init_seq[i].exit_func();\n\t\tmod_init_result[i] = false;\n\t}\n}\n\nstatic void __exit exit_btrfs_fs(void)\n{\n\tbtrfs_exit_btrfs_fs();\n\tbtrfs_cleanup_fs_uuids();\n}\n\nstatic int __init init_btrfs_fs(void)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mod_init_seq); i++) {\n\t\tASSERT(!mod_init_result[i]);\n\t\tret = mod_init_seq[i].init_func();\n\t\tif (ret < 0) {\n\t\t\tbtrfs_exit_btrfs_fs();\n\t\t\treturn ret;\n\t\t}\n\t\tmod_init_result[i] = true;\n\t}\n\treturn 0;\n}\n\nlate_initcall(init_btrfs_fs);\nmodule_exit(exit_btrfs_fs)\n\nMODULE_LICENSE(\"GPL\");\nMODULE_SOFTDEP(\"pre: crc32c\");\nMODULE_SOFTDEP(\"pre: xxhash64\");\nMODULE_SOFTDEP(\"pre: sha256\");\nMODULE_SOFTDEP(\"pre: blake2b-256\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}