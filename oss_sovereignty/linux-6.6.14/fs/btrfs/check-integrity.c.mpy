{
  "module_name": "check-integrity.c",
  "hash_id": "aa2652e79909b1fea627d215d8a400a8cf155361a5f50c30d1fb6901a571ce2c",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/check-integrity.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <crypto/hash.h>\n#include \"messages.h\"\n#include \"ctree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"extent_io.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"accessors.h\"\n\n#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000\n#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000\n#define BTRFSIC_DEV2STATE_HASHTABLE_SIZE 0x100\n#define BTRFSIC_BLOCK_MAGIC_NUMBER 0x14491051\n#define BTRFSIC_BLOCK_LINK_MAGIC_NUMBER 0x11070807\n#define BTRFSIC_DEV2STATE_MAGIC_NUMBER 0x20111530\n#define BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER 20111300\n#define BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL (200 - 6)\t \n#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)\n\n \n#define BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE\t\t\t0x00000001\n#define BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION\t\t0x00000002\n#define BTRFSIC_PRINT_MASK_TREE_AFTER_SB_WRITE\t\t\t0x00000004\n#define BTRFSIC_PRINT_MASK_TREE_BEFORE_SB_WRITE\t\t\t0x00000008\n#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH\t\t\t0x00000010\n#define BTRFSIC_PRINT_MASK_END_IO_BIO_BH\t\t\t0x00000020\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n#define BTRFSIC_PRINT_MASK_VERY_VERBOSE\t\t\t\t0x00000080\n#define BTRFSIC_PRINT_MASK_INITIAL_TREE\t\t\t\t0x00000100\n#define BTRFSIC_PRINT_MASK_INITIAL_ALL_TREES\t\t\t0x00000200\n#define BTRFSIC_PRINT_MASK_INITIAL_DATABASE\t\t\t0x00000400\n#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800\n#define BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS\t\t0x00001000\n#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH_VERBOSE\t\t0x00002000\n\nstruct btrfsic_dev_state;\nstruct btrfsic_state;\n\nstruct btrfsic_block {\n\tu32 magic_num;\t\t \n\tunsigned int is_metadata:1;\t \n\tunsigned int is_superblock:1;\t \n\tunsigned int is_iodone:1;\t \n\tunsigned int iodone_w_error:1;\t \n\tunsigned int never_written:1;\t \n\tunsigned int mirror_num;\t \n\tstruct btrfsic_dev_state *dev_state;\n\tu64 dev_bytenr;\t\t \n\tu64 logical_bytenr;\t \n\tu64 generation;\n\tstruct btrfs_disk_key disk_key;\t \n\tstruct list_head collision_resolving_node;\t \n\tstruct list_head all_blocks_node;\t \n\n\t \n\tstruct list_head ref_to_list;\t \n\tstruct list_head ref_from_list;\t \n\tstruct btrfsic_block *next_in_same_bio;\n\tvoid *orig_bio_private;\n\tbio_end_io_t *orig_bio_end_io;\n\tblk_opf_t submit_bio_bh_rw;\n\tu64 flush_gen;  \n};\n\n \nstruct btrfsic_block_link {\n\tu32 magic_num;\t\t \n\tu32 ref_cnt;\n\tstruct list_head node_ref_to;\t \n\tstruct list_head node_ref_from;\t \n\tstruct list_head collision_resolving_node;\t \n\tstruct btrfsic_block *block_ref_to;\n\tstruct btrfsic_block *block_ref_from;\n\tu64 parent_generation;\n};\n\nstruct btrfsic_dev_state {\n\tu32 magic_num;\t\t \n\tstruct block_device *bdev;\n\tstruct btrfsic_state *state;\n\tstruct list_head collision_resolving_node;\t \n\tstruct btrfsic_block dummy_block_for_bio_bh_flush;\n\tu64 last_flush_gen;\n};\n\nstruct btrfsic_block_hashtable {\n\tstruct list_head table[BTRFSIC_BLOCK_HASHTABLE_SIZE];\n};\n\nstruct btrfsic_block_link_hashtable {\n\tstruct list_head table[BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE];\n};\n\nstruct btrfsic_dev_state_hashtable {\n\tstruct list_head table[BTRFSIC_DEV2STATE_HASHTABLE_SIZE];\n};\n\nstruct btrfsic_block_data_ctx {\n\tu64 start;\t\t \n\tu64 dev_bytenr;\t\t \n\tu32 len;\n\tstruct btrfsic_dev_state *dev;\n\tchar **datav;\n\tstruct page **pagev;\n\tvoid *mem_to_free;\n};\n\n \nstruct btrfsic_stack_frame {\n\tu32 magic;\n\tu32 nr;\n\tint error;\n\tint i;\n\tint limit_nesting;\n\tint num_copies;\n\tint mirror_num;\n\tstruct btrfsic_block *block;\n\tstruct btrfsic_block_data_ctx *block_ctx;\n\tstruct btrfsic_block *next_block;\n\tstruct btrfsic_block_data_ctx next_block_ctx;\n\tstruct btrfs_header *hdr;\n\tstruct btrfsic_stack_frame *prev;\n};\n\n \nstruct btrfsic_state {\n\tu32 print_mask;\n\tint include_extent_data;\n\tstruct list_head all_blocks_list;\n\tstruct btrfsic_block_hashtable block_hashtable;\n\tstruct btrfsic_block_link_hashtable block_link_hashtable;\n\tstruct btrfs_fs_info *fs_info;\n\tu64 max_superblock_generation;\n\tstruct btrfsic_block *latest_superblock;\n\tu32 metablock_size;\n\tu32 datablock_size;\n};\n\nstatic int btrfsic_process_metablock(struct btrfsic_state *state,\n\t\t\t\t     struct btrfsic_block *block,\n\t\t\t\t     struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t     int limit_nesting, int force_iodone_flag);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx\n\t\t*block_ctx, u64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation);\nstatic int btrfsic_handle_extent_data(struct btrfsic_state *state,\n\t\t\t\t      struct btrfsic_block *block,\n\t\t\t\t      struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t      u32 item_offset, int force_iodone_flag);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_process_written_superblock(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *const block,\n\t\tstruct btrfs_super_block *const super_hdr);\nstatic void btrfsic_bio_end_io(struct bio *bp);\nstatic int btrfsic_is_block_ref_by_superblock(const struct btrfsic_state *state,\n\t\t\t\t\t      const struct btrfsic_block *block,\n\t\t\t\t\t      int recursion_level);\nstatic int btrfsic_check_all_ref_blocks(struct btrfsic_state *state,\n\t\t\t\t\tstruct btrfsic_block *const block,\n\t\t\t\t\tint recursion_level);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level);\nstatic struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation);\nstatic struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created);\nstatic int btrfsic_process_superblock_dev_mirror(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_dev_state *dev_state,\n\t\tstruct btrfs_device *device,\n\t\tint superblock_mirror_num,\n\t\tstruct btrfsic_dev_state **selected_dev_state,\n\t\tstruct btrfs_super_block *selected_super);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(dev_t dev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct mutex btrfsic_mutex;\nstatic int btrfsic_is_initialized;\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\n\nstatic void btrfsic_block_init(struct btrfsic_block *b)\n{\n\tb->magic_num = BTRFSIC_BLOCK_MAGIC_NUMBER;\n\tb->dev_state = NULL;\n\tb->dev_bytenr = 0;\n\tb->logical_bytenr = 0;\n\tb->generation = BTRFSIC_GENERATION_UNKNOWN;\n\tb->disk_key.objectid = 0;\n\tb->disk_key.type = 0;\n\tb->disk_key.offset = 0;\n\tb->is_metadata = 0;\n\tb->is_superblock = 0;\n\tb->is_iodone = 0;\n\tb->iodone_w_error = 0;\n\tb->never_written = 0;\n\tb->mirror_num = 0;\n\tb->next_in_same_bio = NULL;\n\tb->orig_bio_private = NULL;\n\tb->orig_bio_end_io = NULL;\n\tINIT_LIST_HEAD(&b->collision_resolving_node);\n\tINIT_LIST_HEAD(&b->all_blocks_node);\n\tINIT_LIST_HEAD(&b->ref_to_list);\n\tINIT_LIST_HEAD(&b->ref_from_list);\n\tb->submit_bio_bh_rw = 0;\n\tb->flush_gen = 0;\n}\n\nstatic struct btrfsic_block *btrfsic_block_alloc(void)\n{\n\tstruct btrfsic_block *b;\n\n\tb = kzalloc(sizeof(*b), GFP_NOFS);\n\tif (NULL != b)\n\t\tbtrfsic_block_init(b);\n\n\treturn b;\n}\n\nstatic void btrfsic_block_free(struct btrfsic_block *b)\n{\n\tBUG_ON(!(NULL == b || BTRFSIC_BLOCK_MAGIC_NUMBER == b->magic_num));\n\tkfree(b);\n}\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *l)\n{\n\tl->magic_num = BTRFSIC_BLOCK_LINK_MAGIC_NUMBER;\n\tl->ref_cnt = 1;\n\tINIT_LIST_HEAD(&l->node_ref_to);\n\tINIT_LIST_HEAD(&l->node_ref_from);\n\tINIT_LIST_HEAD(&l->collision_resolving_node);\n\tl->block_ref_to = NULL;\n\tl->block_ref_from = NULL;\n}\n\nstatic struct btrfsic_block_link *btrfsic_block_link_alloc(void)\n{\n\tstruct btrfsic_block_link *l;\n\n\tl = kzalloc(sizeof(*l), GFP_NOFS);\n\tif (NULL != l)\n\t\tbtrfsic_block_link_init(l);\n\n\treturn l;\n}\n\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *l)\n{\n\tBUG_ON(!(NULL == l || BTRFSIC_BLOCK_LINK_MAGIC_NUMBER == l->magic_num));\n\tkfree(l);\n}\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds)\n{\n\tds->magic_num = BTRFSIC_DEV2STATE_MAGIC_NUMBER;\n\tds->bdev = NULL;\n\tds->state = NULL;\n\tINIT_LIST_HEAD(&ds->collision_resolving_node);\n\tds->last_flush_gen = 0;\n\tbtrfsic_block_init(&ds->dummy_block_for_bio_bh_flush);\n\tds->dummy_block_for_bio_bh_flush.is_iodone = 1;\n\tds->dummy_block_for_bio_bh_flush.dev_state = ds;\n}\n\nstatic struct btrfsic_dev_state *btrfsic_dev_state_alloc(void)\n{\n\tstruct btrfsic_dev_state *ds;\n\n\tds = kzalloc(sizeof(*ds), GFP_NOFS);\n\tif (NULL != ds)\n\t\tbtrfsic_dev_state_init(ds);\n\n\treturn ds;\n}\n\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds)\n{\n\tBUG_ON(!(NULL == ds ||\n\t\t BTRFSIC_DEV2STATE_MAGIC_NUMBER == ds->magic_num));\n\tkfree(ds);\n}\n\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFSIC_BLOCK_HASHTABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(h->table + i);\n}\n\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(b->dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)b->dev_state->bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\n\tlist_add(&b->collision_resolving_node, h->table + hashval);\n}\n\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b)\n{\n\tlist_del(&b->collision_resolving_node);\n}\n\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\tstruct btrfsic_block *b;\n\n\tlist_for_each_entry(b, h->table + hashval, collision_resolving_node) {\n\t\tif (b->dev_state->bdev == bdev && b->dev_bytenr == dev_bytenr)\n\t\t\treturn b;\n\t}\n\n\treturn NULL;\n}\n\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(h->table + i);\n}\n\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(l->block_ref_to->dev_bytenr >> 16)) ^\n\t     ((unsigned int)(l->block_ref_from->dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)l->block_ref_to->dev_state->bdev)) ^\n\t     ((unsigned int)((uintptr_t)l->block_ref_from->dev_state->bdev)))\n\t     & (BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE - 1);\n\n\tBUG_ON(NULL == l->block_ref_to);\n\tBUG_ON(NULL == l->block_ref_from);\n\tlist_add(&l->collision_resolving_node, h->table + hashval);\n}\n\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l)\n{\n\tlist_del(&l->collision_resolving_node);\n}\n\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr_ref_to >> 16)) ^\n\t     ((unsigned int)(dev_bytenr_ref_from >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev_ref_to)) ^\n\t     ((unsigned int)((uintptr_t)bdev_ref_from))) &\n\t     (BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE - 1);\n\tstruct btrfsic_block_link *l;\n\n\tlist_for_each_entry(l, h->table + hashval, collision_resolving_node) {\n\t\tBUG_ON(NULL == l->block_ref_to);\n\t\tBUG_ON(NULL == l->block_ref_from);\n\t\tif (l->block_ref_to->dev_state->bdev == bdev_ref_to &&\n\t\t    l->block_ref_to->dev_bytenr == dev_bytenr_ref_to &&\n\t\t    l->block_ref_from->dev_state->bdev == bdev_ref_from &&\n\t\t    l->block_ref_from->dev_bytenr == dev_bytenr_ref_from)\n\t\t\treturn l;\n\t}\n\n\treturn NULL;\n}\n\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFSIC_DEV2STATE_HASHTABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(h->table + i);\n}\n\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)((uintptr_t)ds->bdev->bd_dev)) &\n\t     (BTRFSIC_DEV2STATE_HASHTABLE_SIZE - 1));\n\n\tlist_add(&ds->collision_resolving_node, h->table + hashval);\n}\n\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds)\n{\n\tlist_del(&ds->collision_resolving_node);\n}\n\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(dev_t dev,\n\t\tstruct btrfsic_dev_state_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t\tdev & (BTRFSIC_DEV2STATE_HASHTABLE_SIZE - 1);\n\tstruct btrfsic_dev_state *ds;\n\n\tlist_for_each_entry(ds, h->table + hashval, collision_resolving_node) {\n\t\tif (ds->bdev->bd_dev == dev)\n\t\t\treturn ds;\n\t}\n\n\treturn NULL;\n}\n\nstatic int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_super_block *selected_super;\n\tstruct list_head *dev_head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\tstruct btrfsic_dev_state *selected_dev_state = NULL;\n\tint ret = 0;\n\tint pass;\n\n\tselected_super = kzalloc(sizeof(*selected_super), GFP_NOFS);\n\tif (!selected_super)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(device, dev_head, dev_list) {\n\t\tint i;\n\t\tstruct btrfsic_dev_state *dev_state;\n\n\t\tif (!device->bdev || !device->name)\n\t\t\tcontinue;\n\n\t\tdev_state = btrfsic_dev_state_lookup(device->bdev->bd_dev);\n\t\tBUG_ON(NULL == dev_state);\n\t\tfor (i = 0; i < BTRFS_SUPER_MIRROR_MAX; i++) {\n\t\t\tret = btrfsic_process_superblock_dev_mirror(\n\t\t\t\t\tstate, dev_state, device, i,\n\t\t\t\t\t&selected_dev_state, selected_super);\n\t\t\tif (0 != ret && 0 == i) {\n\t\t\t\tkfree(selected_super);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (NULL == state->latest_superblock) {\n\t\tpr_info(\"btrfsic: no superblock found!\\n\");\n\t\tkfree(selected_super);\n\t\treturn -1;\n\t}\n\n\tfor (pass = 0; pass < 3; pass++) {\n\t\tint num_copies;\n\t\tint mirror_num;\n\t\tu64 next_bytenr;\n\n\t\tswitch (pass) {\n\t\tcase 0:\n\t\t\tnext_bytenr = btrfs_super_root(selected_super);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tpr_info(\"root@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnext_bytenr = btrfs_super_chunk_root(selected_super);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tpr_info(\"chunk@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tnext_bytenr = btrfs_super_log_root(selected_super);\n\t\t\tif (0 == next_bytenr)\n\t\t\t\tcontinue;\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tpr_info(\"log@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_copies = btrfs_num_copies(state->fs_info, next_bytenr,\n\t\t\t\t\t      state->metablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tpr_info(\"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tstruct btrfsic_block *next_block;\n\t\t\tstruct btrfsic_block_data_ctx tmp_next_block_ctx;\n\t\t\tstruct btrfsic_block_link *l;\n\n\t\t\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t\tstate->metablock_size,\n\t\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\t\tmirror_num);\n\t\t\tif (ret) {\n\t\t\t\tpr_info(\"btrfsic: btrfsic_map_block(root @%llu, mirror %d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\tkfree(selected_super);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_hashtable_lookup(\n\t\t\t\t\ttmp_next_block_ctx.dev->bdev,\n\t\t\t\t\ttmp_next_block_ctx.dev_bytenr,\n\t\t\t\t\t&state->block_hashtable);\n\t\t\tBUG_ON(NULL == next_block);\n\n\t\t\tl = btrfsic_block_link_hashtable_lookup(\n\t\t\t\t\ttmp_next_block_ctx.dev->bdev,\n\t\t\t\t\ttmp_next_block_ctx.dev_bytenr,\n\t\t\t\t\tstate->latest_superblock->dev_state->\n\t\t\t\t\tbdev,\n\t\t\t\t\tstate->latest_superblock->dev_bytenr,\n\t\t\t\t\t&state->block_link_hashtable);\n\t\t\tBUG_ON(NULL == l);\n\n\t\t\tret = btrfsic_read_block(state, &tmp_next_block_ctx);\n\t\t\tif (ret < (int)PAGE_SIZE) {\n\t\t\t\tpr_info(\"btrfsic: read @logical %llu failed!\\n\",\n\t\t\t\t       tmp_next_block_ctx.start);\n\t\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\t\tkfree(selected_super);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tret = btrfsic_process_metablock(state,\n\t\t\t\t\t\t\tnext_block,\n\t\t\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\t\t\tBTRFS_MAX_LEVEL + 3, 1);\n\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t}\n\t}\n\n\tkfree(selected_super);\n\treturn ret;\n}\n\nstatic int btrfsic_process_superblock_dev_mirror(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_dev_state *dev_state,\n\t\tstruct btrfs_device *device,\n\t\tint superblock_mirror_num,\n\t\tstruct btrfsic_dev_state **selected_dev_state,\n\t\tstruct btrfs_super_block *selected_super)\n{\n\tstruct btrfs_fs_info *fs_info = state->fs_info;\n\tstruct btrfs_super_block *super_tmp;\n\tu64 dev_bytenr;\n\tstruct btrfsic_block *superblock_tmp;\n\tint pass;\n\tstruct block_device *const superblock_bdev = device->bdev;\n\tstruct page *page;\n\tstruct address_space *mapping = superblock_bdev->bd_inode->i_mapping;\n\tint ret = 0;\n\n\t \n\tdev_bytenr = btrfs_sb_offset(superblock_mirror_num);\n\tif (dev_bytenr + BTRFS_SUPER_INFO_SIZE > device->commit_total_bytes)\n\t\treturn -1;\n\n\tpage = read_cache_page_gfp(mapping, dev_bytenr >> PAGE_SHIFT, GFP_NOFS);\n\tif (IS_ERR(page))\n\t\treturn -1;\n\n\tsuper_tmp = page_address(page);\n\n\tif (btrfs_super_bytenr(super_tmp) != dev_bytenr ||\n\t    btrfs_super_magic(super_tmp) != BTRFS_MAGIC ||\n\t    memcmp(device->uuid, super_tmp->dev_item.uuid, BTRFS_UUID_SIZE) ||\n\t    btrfs_super_nodesize(super_tmp) != state->metablock_size ||\n\t    btrfs_super_sectorsize(super_tmp) != state->datablock_size) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tsuperblock_tmp =\n\t    btrfsic_block_hashtable_lookup(superblock_bdev,\n\t\t\t\t\t   dev_bytenr,\n\t\t\t\t\t   &state->block_hashtable);\n\tif (NULL == superblock_tmp) {\n\t\tsuperblock_tmp = btrfsic_block_alloc();\n\t\tif (NULL == superblock_tmp) {\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tsuperblock_tmp->dev_bytenr = dev_bytenr;\n\t\tsuperblock_tmp->dev_state = dev_state;\n\t\tsuperblock_tmp->logical_bytenr = dev_bytenr;\n\t\tsuperblock_tmp->generation = btrfs_super_generation(super_tmp);\n\t\tsuperblock_tmp->is_metadata = 1;\n\t\tsuperblock_tmp->is_superblock = 1;\n\t\tsuperblock_tmp->is_iodone = 1;\n\t\tsuperblock_tmp->never_written = 0;\n\t\tsuperblock_tmp->mirror_num = 1 + superblock_mirror_num;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE)\n\t\t\tbtrfs_info_in_rcu(fs_info,\n\t\t\t\"new initial S-block (bdev %p, %s) @%llu (%pg/%llu/%d)\",\n\t\t\t\t     superblock_bdev,\n\t\t\t\t     btrfs_dev_name(device), dev_bytenr,\n\t\t\t\t     dev_state->bdev, dev_bytenr,\n\t\t\t\t     superblock_mirror_num);\n\t\tlist_add(&superblock_tmp->all_blocks_node,\n\t\t\t &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(superblock_tmp,\n\t\t\t\t\t    &state->block_hashtable);\n\t}\n\n\t \n\tif (btrfs_super_generation(super_tmp) >\n\t    state->max_superblock_generation ||\n\t    0 == state->max_superblock_generation) {\n\t\tmemcpy(selected_super, super_tmp, sizeof(*selected_super));\n\t\t*selected_dev_state = dev_state;\n\t\tstate->max_superblock_generation =\n\t\t    btrfs_super_generation(super_tmp);\n\t\tstate->latest_superblock = superblock_tmp;\n\t}\n\n\tfor (pass = 0; pass < 3; pass++) {\n\t\tu64 next_bytenr;\n\t\tint num_copies;\n\t\tint mirror_num;\n\t\tconst char *additional_string = NULL;\n\t\tstruct btrfs_disk_key tmp_disk_key;\n\n\t\ttmp_disk_key.type = BTRFS_ROOT_ITEM_KEY;\n\t\ttmp_disk_key.offset = 0;\n\t\tswitch (pass) {\n\t\tcase 0:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_ROOT_TREE_OBJECTID);\n\t\t\tadditional_string = \"initial root \";\n\t\t\tnext_bytenr = btrfs_super_root(super_tmp);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_CHUNK_TREE_OBJECTID);\n\t\t\tadditional_string = \"initial chunk \";\n\t\t\tnext_bytenr = btrfs_super_chunk_root(super_tmp);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_TREE_LOG_OBJECTID);\n\t\t\tadditional_string = \"initial log \";\n\t\t\tnext_bytenr = btrfs_super_log_root(super_tmp);\n\t\t\tif (0 == next_bytenr)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_copies = btrfs_num_copies(fs_info, next_bytenr,\n\t\t\t\t\t      state->metablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tpr_info(\"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tstruct btrfsic_block *next_block;\n\t\t\tstruct btrfsic_block_data_ctx tmp_next_block_ctx;\n\t\t\tstruct btrfsic_block_link *l;\n\n\t\t\tif (btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t      state->metablock_size,\n\t\t\t\t\t      &tmp_next_block_ctx,\n\t\t\t\t\t      mirror_num)) {\n\t\t\t\tpr_info(\"btrfsic: btrfsic_map_block(bytenr @%llu, mirror %d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\tret = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_lookup_or_add(\n\t\t\t\t\tstate, &tmp_next_block_ctx,\n\t\t\t\t\tadditional_string, 1, 1, 0,\n\t\t\t\t\tmirror_num, NULL);\n\t\t\tif (NULL == next_block) {\n\t\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\t\tret = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tnext_block->disk_key = tmp_disk_key;\n\t\t\tnext_block->generation = BTRFSIC_GENERATION_UNKNOWN;\n\t\t\tl = btrfsic_block_link_lookup_or_add(\n\t\t\t\t\tstate, &tmp_next_block_ctx,\n\t\t\t\t\tnext_block, superblock_tmp,\n\t\t\t\t\tBTRFSIC_GENERATION_UNKNOWN);\n\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\tif (NULL == l) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_INITIAL_ALL_TREES)\n\t\tbtrfsic_dump_tree_sub(state, superblock_tmp, 0);\n\nout:\n\tput_page(page);\n\treturn ret;\n}\n\nstatic struct btrfsic_stack_frame *btrfsic_stack_frame_alloc(void)\n{\n\tstruct btrfsic_stack_frame *sf;\n\n\tsf = kzalloc(sizeof(*sf), GFP_NOFS);\n\tif (sf)\n\t\tsf->magic = BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER;\n\treturn sf;\n}\n\nstatic void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf)\n{\n\tBUG_ON(!(NULL == sf ||\n\t\t BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER == sf->magic));\n\tkfree(sf);\n}\n\nstatic noinline_for_stack int btrfsic_process_metablock(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *const first_block,\n\t\tstruct btrfsic_block_data_ctx *const first_block_ctx,\n\t\tint first_limit_nesting, int force_iodone_flag)\n{\n\tstruct btrfsic_stack_frame initial_stack_frame = { 0 };\n\tstruct btrfsic_stack_frame *sf;\n\tstruct btrfsic_stack_frame *next_stack;\n\tstruct btrfs_header *const first_hdr =\n\t\t(struct btrfs_header *)first_block_ctx->datav[0];\n\n\tBUG_ON(!first_hdr);\n\tsf = &initial_stack_frame;\n\tsf->error = 0;\n\tsf->i = -1;\n\tsf->limit_nesting = first_limit_nesting;\n\tsf->block = first_block;\n\tsf->block_ctx = first_block_ctx;\n\tsf->next_block = NULL;\n\tsf->hdr = first_hdr;\n\tsf->prev = NULL;\n\ncontinue_with_new_stack_frame:\n\tsf->block->generation = btrfs_stack_header_generation(sf->hdr);\n\tif (0 == sf->hdr->level) {\n\t\tstruct btrfs_leaf *const leafhdr =\n\t\t    (struct btrfs_leaf *)sf->hdr;\n\n\t\tif (-1 == sf->i) {\n\t\t\tsf->nr = btrfs_stack_header_nritems(&leafhdr->header);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tpr_info(\"leaf %llu items %d generation %llu owner %llu\\n\",\n\t\t\t\t       sf->block_ctx->start, sf->nr,\n\t\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t\t       &leafhdr->header),\n\t\t\t\t       btrfs_stack_header_owner(\n\t\t\t\t\t       &leafhdr->header));\n\t\t}\n\ncontinue_with_current_leaf_stack_frame:\n\t\tif (0 == sf->num_copies || sf->mirror_num > sf->num_copies) {\n\t\t\tsf->i++;\n\t\t\tsf->num_copies = 0;\n\t\t}\n\n\t\tif (sf->i < sf->nr) {\n\t\t\tstruct btrfs_item disk_item;\n\t\t\tu32 disk_item_offset =\n\t\t\t\t(uintptr_t)(leafhdr->items + sf->i) -\n\t\t\t\t(uintptr_t)leafhdr;\n\t\t\tstruct btrfs_disk_key *disk_key;\n\t\t\tu8 type;\n\t\t\tu32 item_offset;\n\t\t\tu32 item_size;\n\n\t\t\tif (disk_item_offset + sizeof(struct btrfs_item) >\n\t\t\t    sf->block_ctx->len) {\nleaf_item_out_of_bounce_error:\n\t\t\t\tpr_info(\n\t\t\"btrfsic: leaf item out of bounce at logical %llu, dev %pg\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       sf->block_ctx->dev->bdev);\n\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\t\t\tbtrfsic_read_from_block_data(sf->block_ctx,\n\t\t\t\t\t\t     &disk_item,\n\t\t\t\t\t\t     disk_item_offset,\n\t\t\t\t\t\t     sizeof(struct btrfs_item));\n\t\t\titem_offset = btrfs_stack_item_offset(&disk_item);\n\t\t\titem_size = btrfs_stack_item_size(&disk_item);\n\t\t\tdisk_key = &disk_item.key;\n\t\t\ttype = btrfs_disk_key_type(disk_key);\n\n\t\t\tif (BTRFS_ROOT_ITEM_KEY == type) {\n\t\t\t\tstruct btrfs_root_item root_item;\n\t\t\t\tu32 root_item_offset;\n\t\t\t\tu64 next_bytenr;\n\n\t\t\t\troot_item_offset = item_offset +\n\t\t\t\t\toffsetof(struct btrfs_leaf, items);\n\t\t\t\tif (root_item_offset + item_size >\n\t\t\t\t    sf->block_ctx->len)\n\t\t\t\t\tgoto leaf_item_out_of_bounce_error;\n\t\t\t\tbtrfsic_read_from_block_data(\n\t\t\t\t\tsf->block_ctx, &root_item,\n\t\t\t\t\troot_item_offset,\n\t\t\t\t\titem_size);\n\t\t\t\tnext_bytenr = btrfs_root_bytenr(&root_item);\n\n\t\t\t\tsf->error =\n\t\t\t\t    btrfsic_create_link_to_next_block(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tsf->block,\n\t\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\t\tnext_bytenr,\n\t\t\t\t\t\tsf->limit_nesting,\n\t\t\t\t\t\t&sf->next_block_ctx,\n\t\t\t\t\t\t&sf->next_block,\n\t\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t\t&sf->num_copies,\n\t\t\t\t\t\t&sf->mirror_num,\n\t\t\t\t\t\tdisk_key,\n\t\t\t\t\t\tbtrfs_root_generation(\n\t\t\t\t\t\t&root_item));\n\t\t\t\tif (sf->error)\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\n\t\t\t\tif (NULL != sf->next_block) {\n\t\t\t\t\tstruct btrfs_header *const next_hdr =\n\t\t\t\t\t    (struct btrfs_header *)\n\t\t\t\t\t    sf->next_block_ctx.datav[0];\n\n\t\t\t\t\tnext_stack =\n\t\t\t\t\t    btrfsic_stack_frame_alloc();\n\t\t\t\t\tif (NULL == next_stack) {\n\t\t\t\t\t\tsf->error = -1;\n\t\t\t\t\t\tbtrfsic_release_block_ctx(\n\t\t\t\t\t\t\t\t&sf->\n\t\t\t\t\t\t\t\tnext_block_ctx);\n\t\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_stack->i = -1;\n\t\t\t\t\tnext_stack->block = sf->next_block;\n\t\t\t\t\tnext_stack->block_ctx =\n\t\t\t\t\t    &sf->next_block_ctx;\n\t\t\t\t\tnext_stack->next_block = NULL;\n\t\t\t\t\tnext_stack->hdr = next_hdr;\n\t\t\t\t\tnext_stack->limit_nesting =\n\t\t\t\t\t    sf->limit_nesting - 1;\n\t\t\t\t\tnext_stack->prev = sf;\n\t\t\t\t\tsf = next_stack;\n\t\t\t\t\tgoto continue_with_new_stack_frame;\n\t\t\t\t}\n\t\t\t} else if (BTRFS_EXTENT_DATA_KEY == type &&\n\t\t\t\t   state->include_extent_data) {\n\t\t\t\tsf->error = btrfsic_handle_extent_data(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tsf->block,\n\t\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\t\titem_offset,\n\t\t\t\t\t\tforce_iodone_flag);\n\t\t\t\tif (sf->error)\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\n\t\t\tgoto continue_with_current_leaf_stack_frame;\n\t\t}\n\t} else {\n\t\tstruct btrfs_node *const nodehdr = (struct btrfs_node *)sf->hdr;\n\n\t\tif (-1 == sf->i) {\n\t\t\tsf->nr = btrfs_stack_header_nritems(&nodehdr->header);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tpr_info(\"node %llu level %d items %d generation %llu owner %llu\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       nodehdr->header.level, sf->nr,\n\t\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       &nodehdr->header),\n\t\t\t\t       btrfs_stack_header_owner(\n\t\t\t\t       &nodehdr->header));\n\t\t}\n\ncontinue_with_current_node_stack_frame:\n\t\tif (0 == sf->num_copies || sf->mirror_num > sf->num_copies) {\n\t\t\tsf->i++;\n\t\t\tsf->num_copies = 0;\n\t\t}\n\n\t\tif (sf->i < sf->nr) {\n\t\t\tstruct btrfs_key_ptr key_ptr;\n\t\t\tu32 key_ptr_offset;\n\t\t\tu64 next_bytenr;\n\n\t\t\tkey_ptr_offset = (uintptr_t)(nodehdr->ptrs + sf->i) -\n\t\t\t\t\t  (uintptr_t)nodehdr;\n\t\t\tif (key_ptr_offset + sizeof(struct btrfs_key_ptr) >\n\t\t\t    sf->block_ctx->len) {\n\t\t\t\tpr_info(\n\t\t\"btrfsic: node item out of bounce at logical %llu, dev %pg\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       sf->block_ctx->dev->bdev);\n\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\t\t\tbtrfsic_read_from_block_data(\n\t\t\t\tsf->block_ctx, &key_ptr, key_ptr_offset,\n\t\t\t\tsizeof(struct btrfs_key_ptr));\n\t\t\tnext_bytenr = btrfs_stack_key_blockptr(&key_ptr);\n\n\t\t\tsf->error = btrfsic_create_link_to_next_block(\n\t\t\t\t\tstate,\n\t\t\t\t\tsf->block,\n\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\tnext_bytenr,\n\t\t\t\t\tsf->limit_nesting,\n\t\t\t\t\t&sf->next_block_ctx,\n\t\t\t\t\t&sf->next_block,\n\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t&sf->num_copies,\n\t\t\t\t\t&sf->mirror_num,\n\t\t\t\t\t&key_ptr.key,\n\t\t\t\t\tbtrfs_stack_key_generation(&key_ptr));\n\t\t\tif (sf->error)\n\t\t\t\tgoto one_stack_frame_backwards;\n\n\t\t\tif (NULL != sf->next_block) {\n\t\t\t\tstruct btrfs_header *const next_hdr =\n\t\t\t\t    (struct btrfs_header *)\n\t\t\t\t    sf->next_block_ctx.datav[0];\n\n\t\t\t\tnext_stack = btrfsic_stack_frame_alloc();\n\t\t\t\tif (NULL == next_stack) {\n\t\t\t\t\tsf->error = -1;\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t\t}\n\n\t\t\t\tnext_stack->i = -1;\n\t\t\t\tnext_stack->block = sf->next_block;\n\t\t\t\tnext_stack->block_ctx = &sf->next_block_ctx;\n\t\t\t\tnext_stack->next_block = NULL;\n\t\t\t\tnext_stack->hdr = next_hdr;\n\t\t\t\tnext_stack->limit_nesting =\n\t\t\t\t    sf->limit_nesting - 1;\n\t\t\t\tnext_stack->prev = sf;\n\t\t\t\tsf = next_stack;\n\t\t\t\tgoto continue_with_new_stack_frame;\n\t\t\t}\n\n\t\t\tgoto continue_with_current_node_stack_frame;\n\t\t}\n\t}\n\none_stack_frame_backwards:\n\tif (NULL != sf->prev) {\n\t\tstruct btrfsic_stack_frame *const prev = sf->prev;\n\n\t\t \n\t\tbtrfsic_release_block_ctx(sf->block_ctx);\n\n\t\tif (sf->error) {\n\t\t\tprev->error = sf->error;\n\t\t\tbtrfsic_stack_frame_free(sf);\n\t\t\tsf = prev;\n\t\t\tgoto one_stack_frame_backwards;\n\t\t}\n\n\t\tbtrfsic_stack_frame_free(sf);\n\t\tsf = prev;\n\t\tgoto continue_with_new_stack_frame;\n\t} else {\n\t\tBUG_ON(&initial_stack_frame != sf);\n\t}\n\n\treturn sf->error;\n}\n\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dstv, u32 offset, size_t len)\n{\n\tsize_t cur;\n\tsize_t pgoff;\n\tchar *kaddr;\n\tchar *dst = (char *)dstv;\n\tsize_t start_offset = offset_in_page(block_ctx->start);\n\tunsigned long i = (start_offset + offset) >> PAGE_SHIFT;\n\n\tWARN_ON(offset + len > block_ctx->len);\n\tpgoff = offset_in_page(start_offset + offset);\n\n\twhile (len > 0) {\n\t\tcur = min(len, ((size_t)PAGE_SIZE - pgoff));\n\t\tBUG_ON(i >= DIV_ROUND_UP(block_ctx->len, PAGE_SIZE));\n\t\tkaddr = block_ctx->datav[i];\n\t\tmemcpy(dst, kaddr + pgoff, cur);\n\n\t\tdst += cur;\n\t\tlen -= cur;\n\t\tpgoff = 0;\n\t\ti++;\n\t}\n}\n\nstatic int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tu64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation)\n{\n\tstruct btrfs_fs_info *fs_info = state->fs_info;\n\tstruct btrfsic_block *next_block = NULL;\n\tint ret;\n\tstruct btrfsic_block_link *l;\n\tint did_alloc_block_link;\n\tint block_was_created;\n\n\t*next_blockp = NULL;\n\tif (0 == *num_copiesp) {\n\t\t*num_copiesp = btrfs_num_copies(fs_info, next_bytenr,\n\t\t\t\t\t\tstate->metablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tpr_info(\"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, *num_copiesp);\n\t\t*mirror_nump = 1;\n\t}\n\n\tif (*mirror_nump > *num_copiesp)\n\t\treturn 0;\n\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\tpr_info(\"btrfsic_create_link_to_next_block(mirror_num=%d)\\n\",\n\t\t       *mirror_nump);\n\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\tstate->metablock_size,\n\t\t\t\tnext_block_ctx, *mirror_nump);\n\tif (ret) {\n\t\tpr_info(\"btrfsic: btrfsic_map_block(@%llu, mirror=%d) failed!\\n\",\n\t\t       next_bytenr, *mirror_nump);\n\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t*next_blockp = NULL;\n\t\treturn -1;\n\t}\n\n\tnext_block = btrfsic_block_lookup_or_add(state,\n\t\t\t\t\t\t next_block_ctx, \"referenced \",\n\t\t\t\t\t\t 1, force_iodone_flag,\n\t\t\t\t\t\t !force_iodone_flag,\n\t\t\t\t\t\t *mirror_nump,\n\t\t\t\t\t\t &block_was_created);\n\tif (NULL == next_block) {\n\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t*next_blockp = NULL;\n\t\treturn -1;\n\t}\n\tif (block_was_created) {\n\t\tl = NULL;\n\t\tnext_block->generation = BTRFSIC_GENERATION_UNKNOWN;\n\t} else {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE) {\n\t\t\tif (next_block->logical_bytenr != next_bytenr &&\n\t\t\t    !(!next_block->is_metadata &&\n\t\t\t      0 == next_block->logical_bytenr))\n\t\t\t\tpr_info(\n\"referenced block @%llu (%pg/%llu/%d) found in hash table, %c, bytenr mismatch (!= stored %llu)\\n\",\n\t\t\t\t       next_bytenr, next_block_ctx->dev->bdev,\n\t\t\t\t       next_block_ctx->dev_bytenr, *mirror_nump,\n\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t      next_block),\n\t\t\t\t       next_block->logical_bytenr);\n\t\t\telse\n\t\t\t\tpr_info(\n\t\t\"referenced block @%llu (%pg/%llu/%d) found in hash table, %c\\n\",\n\t\t\t\t       next_bytenr, next_block_ctx->dev->bdev,\n\t\t\t\t       next_block_ctx->dev_bytenr, *mirror_nump,\n\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t      next_block));\n\t\t}\n\t\tnext_block->logical_bytenr = next_bytenr;\n\n\t\tnext_block->mirror_num = *mirror_nump;\n\t\tl = btrfsic_block_link_hashtable_lookup(\n\t\t\t\tnext_block_ctx->dev->bdev,\n\t\t\t\tnext_block_ctx->dev_bytenr,\n\t\t\t\tblock_ctx->dev->bdev,\n\t\t\t\tblock_ctx->dev_bytenr,\n\t\t\t\t&state->block_link_hashtable);\n\t}\n\n\tnext_block->disk_key = *disk_key;\n\tif (NULL == l) {\n\t\tl = btrfsic_block_link_alloc();\n\t\tif (NULL == l) {\n\t\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t\t*next_blockp = NULL;\n\t\t\treturn -1;\n\t\t}\n\n\t\tdid_alloc_block_link = 1;\n\t\tl->block_ref_to = next_block;\n\t\tl->block_ref_from = block;\n\t\tl->ref_cnt = 1;\n\t\tl->parent_generation = parent_generation;\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\n\t\tlist_add(&l->node_ref_to, &block->ref_to_list);\n\t\tlist_add(&l->node_ref_from, &next_block->ref_from_list);\n\n\t\tbtrfsic_block_link_hashtable_add(l,\n\t\t\t\t\t\t &state->block_link_hashtable);\n\t} else {\n\t\tdid_alloc_block_link = 0;\n\t\tif (0 == limit_nesting) {\n\t\t\tl->ref_cnt++;\n\t\t\tl->parent_generation = parent_generation;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_add_link(state, l);\n\t\t}\n\t}\n\n\tif (limit_nesting > 0 && did_alloc_block_link) {\n\t\tret = btrfsic_read_block(state, next_block_ctx);\n\t\tif (ret < (int)next_block_ctx->len) {\n\t\t\tpr_info(\"btrfsic: read block @logical %llu failed!\\n\",\n\t\t\t       next_bytenr);\n\t\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t\t*next_blockp = NULL;\n\t\t\treturn -1;\n\t\t}\n\n\t\t*next_blockp = next_block;\n\t} else {\n\t\t*next_blockp = NULL;\n\t}\n\t(*mirror_nump)++;\n\n\treturn 0;\n}\n\nstatic int btrfsic_handle_extent_data(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tu32 item_offset, int force_iodone_flag)\n{\n\tstruct btrfs_fs_info *fs_info = state->fs_info;\n\tstruct btrfs_file_extent_item file_extent_item;\n\tu64 file_extent_item_offset;\n\tu64 next_bytenr;\n\tu64 num_bytes;\n\tu64 generation;\n\tstruct btrfsic_block_link *l;\n\tint ret;\n\n\tfile_extent_item_offset = offsetof(struct btrfs_leaf, items) +\n\t\t\t\t  item_offset;\n\tif (file_extent_item_offset +\n\t    offsetof(struct btrfs_file_extent_item, disk_num_bytes) >\n\t    block_ctx->len) {\n\t\tpr_info(\"btrfsic: file item out of bounce at logical %llu, dev %pg\\n\",\n\t\t       block_ctx->start, block_ctx->dev->bdev);\n\t\treturn -1;\n\t}\n\n\tbtrfsic_read_from_block_data(block_ctx, &file_extent_item,\n\t\tfile_extent_item_offset,\n\t\toffsetof(struct btrfs_file_extent_item, disk_num_bytes));\n\tif (BTRFS_FILE_EXTENT_REG != file_extent_item.type ||\n\t    btrfs_stack_file_extent_disk_bytenr(&file_extent_item) == 0) {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERY_VERBOSE)\n\t\t\tpr_info(\"extent_data: type %u, disk_bytenr = %llu\\n\",\n\t\t\t       file_extent_item.type,\n\t\t\t       btrfs_stack_file_extent_disk_bytenr(\n\t\t\t       &file_extent_item));\n\t\treturn 0;\n\t}\n\n\tif (file_extent_item_offset + sizeof(struct btrfs_file_extent_item) >\n\t    block_ctx->len) {\n\t\tpr_info(\"btrfsic: file item out of bounce at logical %llu, dev %pg\\n\",\n\t\t       block_ctx->start, block_ctx->dev->bdev);\n\t\treturn -1;\n\t}\n\tbtrfsic_read_from_block_data(block_ctx, &file_extent_item,\n\t\t\t\t     file_extent_item_offset,\n\t\t\t\t     sizeof(struct btrfs_file_extent_item));\n\tnext_bytenr = btrfs_stack_file_extent_disk_bytenr(&file_extent_item);\n\tif (btrfs_stack_file_extent_compression(&file_extent_item) ==\n\t    BTRFS_COMPRESS_NONE) {\n\t\tnext_bytenr += btrfs_stack_file_extent_offset(&file_extent_item);\n\t\tnum_bytes = btrfs_stack_file_extent_num_bytes(&file_extent_item);\n\t} else {\n\t\tnum_bytes = btrfs_stack_file_extent_disk_num_bytes(&file_extent_item);\n\t}\n\tgeneration = btrfs_stack_file_extent_generation(&file_extent_item);\n\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERY_VERBOSE)\n\t\tpr_info(\"extent_data: type %u, disk_bytenr = %llu, offset = %llu, num_bytes = %llu\\n\",\n\t\t       file_extent_item.type,\n\t\t       btrfs_stack_file_extent_disk_bytenr(&file_extent_item),\n\t\t       btrfs_stack_file_extent_offset(&file_extent_item),\n\t\t       num_bytes);\n\twhile (num_bytes > 0) {\n\t\tu32 chunk_len;\n\t\tint num_copies;\n\t\tint mirror_num;\n\n\t\tif (num_bytes > state->datablock_size)\n\t\t\tchunk_len = state->datablock_size;\n\t\telse\n\t\t\tchunk_len = num_bytes;\n\n\t\tnum_copies = btrfs_num_copies(fs_info, next_bytenr,\n\t\t\t\t\t      state->datablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tpr_info(\"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tstruct btrfsic_block_data_ctx next_block_ctx;\n\t\t\tstruct btrfsic_block *next_block;\n\t\t\tint block_was_created;\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tpr_info(\"btrfsic_handle_extent_data(mirror_num=%d)\\n\",\n\t\t\t\t\tmirror_num);\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERY_VERBOSE)\n\t\t\t\tpr_info(\"\\tdisk_bytenr = %llu, num_bytes %u\\n\",\n\t\t\t\t       next_bytenr, chunk_len);\n\t\t\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t\tchunk_len, &next_block_ctx,\n\t\t\t\t\t\tmirror_num);\n\t\t\tif (ret) {\n\t\t\t\tpr_info(\"btrfsic: btrfsic_map_block(@%llu, mirror=%d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_lookup_or_add(\n\t\t\t\t\tstate,\n\t\t\t\t\t&next_block_ctx,\n\t\t\t\t\t\"referenced \",\n\t\t\t\t\t0,\n\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t!force_iodone_flag,\n\t\t\t\t\tmirror_num,\n\t\t\t\t\t&block_was_created);\n\t\t\tif (NULL == next_block) {\n\t\t\t\tbtrfsic_release_block_ctx(&next_block_ctx);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!block_was_created) {\n\t\t\t\tif ((state->print_mask &\n\t\t\t\t     BTRFSIC_PRINT_MASK_VERBOSE) &&\n\t\t\t\t    next_block->logical_bytenr != next_bytenr &&\n\t\t\t\t    !(!next_block->is_metadata &&\n\t\t\t\t      0 == next_block->logical_bytenr)) {\n\t\t\t\t\tpr_info(\n\"referenced block @%llu (%pg/%llu/%d) found in hash table, D, bytenr mismatch (!= stored %llu)\\n\",\n\t\t\t\t\t       next_bytenr,\n\t\t\t\t\t       next_block_ctx.dev->bdev,\n\t\t\t\t\t       next_block_ctx.dev_bytenr,\n\t\t\t\t\t       mirror_num,\n\t\t\t\t\t       next_block->logical_bytenr);\n\t\t\t\t}\n\t\t\t\tnext_block->logical_bytenr = next_bytenr;\n\t\t\t\tnext_block->mirror_num = mirror_num;\n\t\t\t}\n\n\t\t\tl = btrfsic_block_link_lookup_or_add(state,\n\t\t\t\t\t\t\t     &next_block_ctx,\n\t\t\t\t\t\t\t     next_block, block,\n\t\t\t\t\t\t\t     generation);\n\t\t\tbtrfsic_release_block_ctx(&next_block_ctx);\n\t\t\tif (NULL == l)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tnext_bytenr += chunk_len;\n\t\tnum_bytes -= chunk_len;\n\t}\n\n\treturn 0;\n}\n\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num)\n{\n\tstruct btrfs_fs_info *fs_info = state->fs_info;\n\tint ret;\n\tu64 length;\n\tstruct btrfs_io_context *bioc = NULL;\n\tstruct btrfs_io_stripe smap, *map;\n\tstruct btrfs_device *device;\n\n\tlength = len;\n\tret = btrfs_map_block(fs_info, BTRFS_MAP_READ, bytenr, &length, &bioc,\n\t\t\t      NULL, &mirror_num, 0);\n\tif (ret) {\n\t\tblock_ctx_out->start = 0;\n\t\tblock_ctx_out->dev_bytenr = 0;\n\t\tblock_ctx_out->len = 0;\n\t\tblock_ctx_out->dev = NULL;\n\t\tblock_ctx_out->datav = NULL;\n\t\tblock_ctx_out->pagev = NULL;\n\t\tblock_ctx_out->mem_to_free = NULL;\n\n\t\treturn ret;\n\t}\n\n\tif (bioc)\n\t\tmap = &bioc->stripes[0];\n\telse\n\t\tmap = &smap;\n\n\tdevice = map->dev;\n\tif (test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state) ||\n\t    !device->bdev || !device->name)\n\t\tblock_ctx_out->dev = NULL;\n\telse\n\t\tblock_ctx_out->dev = btrfsic_dev_state_lookup(\n\t\t\t\t\t\t\tdevice->bdev->bd_dev);\n\tblock_ctx_out->dev_bytenr = map->physical;\n\tblock_ctx_out->start = bytenr;\n\tblock_ctx_out->len = len;\n\tblock_ctx_out->datav = NULL;\n\tblock_ctx_out->pagev = NULL;\n\tblock_ctx_out->mem_to_free = NULL;\n\n\tkfree(bioc);\n\tif (NULL == block_ctx_out->dev) {\n\t\tret = -ENXIO;\n\t\tpr_info(\"btrfsic: error, cannot lookup dev (#1)!\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_SIZE - 1) >>\n\t\t\t    PAGE_SHIFT;\n\t\t \n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages])\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}\n\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx)\n{\n\tunsigned int num_pages;\n\tunsigned int i;\n\tsize_t size;\n\tu64 dev_bytenr;\n\tint ret;\n\n\tBUG_ON(block_ctx->datav);\n\tBUG_ON(block_ctx->pagev);\n\tBUG_ON(block_ctx->mem_to_free);\n\tif (!PAGE_ALIGNED(block_ctx->dev_bytenr)) {\n\t\tpr_info(\"btrfsic: read_block() with unaligned bytenr %llu\\n\",\n\t\t       block_ctx->dev_bytenr);\n\t\treturn -1;\n\t}\n\n\tnum_pages = (block_ctx->len + (u64)PAGE_SIZE - 1) >>\n\t\t    PAGE_SHIFT;\n\tsize = sizeof(*block_ctx->datav) + sizeof(*block_ctx->pagev);\n\tblock_ctx->mem_to_free = kcalloc(num_pages, size, GFP_NOFS);\n\tif (!block_ctx->mem_to_free)\n\t\treturn -ENOMEM;\n\tblock_ctx->datav = block_ctx->mem_to_free;\n\tblock_ctx->pagev = (struct page **)(block_ctx->datav + num_pages);\n\tret = btrfs_alloc_page_array(num_pages, block_ctx->pagev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_bytenr = block_ctx->dev_bytenr;\n\tfor (i = 0; i < num_pages;) {\n\t\tstruct bio *bio;\n\t\tunsigned int j;\n\n\t\tbio = bio_alloc(block_ctx->dev->bdev, num_pages - i,\n\t\t\t\tREQ_OP_READ, GFP_NOFS);\n\t\tbio->bi_iter.bi_sector = dev_bytenr >> SECTOR_SHIFT;\n\n\t\tfor (j = i; j < num_pages; j++) {\n\t\t\tret = bio_add_page(bio, block_ctx->pagev[j],\n\t\t\t\t\t   PAGE_SIZE, 0);\n\t\t\tif (PAGE_SIZE != ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == i) {\n\t\t\tpr_info(\"btrfsic: error, failed to add a single page!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (submit_bio_wait(bio)) {\n\t\t\tpr_info(\"btrfsic: read error at logical %llu dev %pg!\\n\",\n\t\t\t       block_ctx->start, block_ctx->dev->bdev);\n\t\t\tbio_put(bio);\n\t\t\treturn -1;\n\t\t}\n\t\tbio_put(bio);\n\t\tdev_bytenr += (j - i) * PAGE_SIZE;\n\t\ti = j;\n\t}\n\tfor (i = 0; i < num_pages; i++)\n\t\tblock_ctx->datav[i] = page_address(block_ctx->pagev[i]);\n\n\treturn block_ctx->len;\n}\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state)\n{\n\tconst struct btrfsic_block *b_all;\n\n\tBUG_ON(NULL == state);\n\n\tpr_info(\"all_blocks_list:\\n\");\n\tlist_for_each_entry(b_all, &state->all_blocks_list, all_blocks_node) {\n\t\tconst struct btrfsic_block_link *l;\n\n\t\tpr_info(\"%c-block @%llu (%pg/%llu/%d)\\n\",\n\t\t       btrfsic_get_block_type(state, b_all),\n\t\t       b_all->logical_bytenr, b_all->dev_state->bdev,\n\t\t       b_all->dev_bytenr, b_all->mirror_num);\n\n\t\tlist_for_each_entry(l, &b_all->ref_to_list, node_ref_to) {\n\t\t\tpr_info(\n\t\t\" %c @%llu (%pg/%llu/%d) refers %u* to %c @%llu (%pg/%llu/%d)\\n\",\n\t\t\t       btrfsic_get_block_type(state, b_all),\n\t\t\t       b_all->logical_bytenr, b_all->dev_state->bdev,\n\t\t\t       b_all->dev_bytenr, b_all->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->bdev,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t}\n\n\t\tlist_for_each_entry(l, &b_all->ref_from_list, node_ref_from) {\n\t\t\tpr_info(\n\t\t\" %c @%llu (%pg/%llu/%d) is ref %u* from %c @%llu (%pg/%llu/%d)\\n\",\n\t\t\t       btrfsic_get_block_type(state, b_all),\n\t\t\t       b_all->logical_bytenr, b_all->dev_state->bdev,\n\t\t\t       b_all->dev_bytenr, b_all->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t\t\t       l->block_ref_from->logical_bytenr,\n\t\t\t       l->block_ref_from->dev_state->bdev,\n\t\t\t       l->block_ref_from->dev_bytenr,\n\t\t\t       l->block_ref_from->mirror_num);\n\t\t}\n\n\t\tpr_info(\"\\n\");\n\t}\n}\n\n \nstatic noinline_for_stack int btrfsic_test_for_metadata(\n\t\tstruct btrfsic_state *state,\n\t\tchar **datav, unsigned int num_pages)\n{\n\tstruct btrfs_fs_info *fs_info = state->fs_info;\n\tSHASH_DESC_ON_STACK(shash, fs_info->csum_shash);\n\tstruct btrfs_header *h;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tunsigned int i;\n\n\tif (num_pages * PAGE_SIZE < state->metablock_size)\n\t\treturn 1;  \n\tnum_pages = state->metablock_size >> PAGE_SHIFT;\n\th = (struct btrfs_header *)datav[0];\n\n\tif (memcmp(h->fsid, fs_info->fs_devices->fsid, BTRFS_FSID_SIZE))\n\t\treturn 1;\n\n\tshash->tfm = fs_info->csum_shash;\n\tcrypto_shash_init(shash);\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tu8 *data = i ? datav[i] : (datav[i] + BTRFS_CSUM_SIZE);\n\t\tsize_t sublen = i ? PAGE_SIZE :\n\t\t\t\t    (PAGE_SIZE - BTRFS_CSUM_SIZE);\n\n\t\tcrypto_shash_update(shash, data, sublen);\n\t}\n\tcrypto_shash_final(shash, csum);\n\tif (memcmp(csum, h->csum, fs_info->csum_size))\n\t\treturn 1;\n\n\treturn 0;  \n}\n\nstatic void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  blk_opf_t submit_bio_bh_rw)\n{\n\tint is_metadata;\n\tstruct btrfsic_block *block;\n\tstruct btrfsic_block_data_ctx block_ctx;\n\tint ret;\n\tstruct btrfsic_state *state = dev_state->state;\n\tstruct block_device *bdev = dev_state->bdev;\n\tunsigned int processed_len;\n\n\tif (NULL != bio_is_patched)\n\t\t*bio_is_patched = 0;\n\nagain:\n\tif (num_pages == 0)\n\t\treturn;\n\n\tprocessed_len = 0;\n\tis_metadata = (0 == btrfsic_test_for_metadata(state, mapped_datav,\n\t\t\t\t\t\t      num_pages));\n\n\tblock = btrfsic_block_hashtable_lookup(bdev, dev_bytenr,\n\t\t\t\t\t       &state->block_hashtable);\n\tif (NULL != block) {\n\t\tu64 bytenr = 0;\n\t\tstruct btrfsic_block_link *l, *tmp;\n\n\t\tif (block->is_superblock) {\n\t\t\tbytenr = btrfs_super_bytenr((struct btrfs_super_block *)\n\t\t\t\t\t\t    mapped_datav[0]);\n\t\t\tif (num_pages * PAGE_SIZE <\n\t\t\t    BTRFS_SUPER_INFO_SIZE) {\n\t\t\t\tpr_info(\"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tis_metadata = 1;\n\t\t\tBUG_ON(!PAGE_ALIGNED(BTRFS_SUPER_INFO_SIZE));\n\t\t\tprocessed_len = BTRFS_SUPER_INFO_SIZE;\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_TREE_BEFORE_SB_WRITE) {\n\t\t\t\tpr_info(\"[before new superblock is written]:\\n\");\n\t\t\t\tbtrfsic_dump_tree_sub(state, block, 0);\n\t\t\t}\n\t\t}\n\t\tif (is_metadata) {\n\t\t\tif (!block->is_superblock) {\n\t\t\t\tif (num_pages * PAGE_SIZE <\n\t\t\t\t    state->metablock_size) {\n\t\t\t\t\tpr_info(\"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tprocessed_len = state->metablock_size;\n\t\t\t\tbytenr = btrfs_stack_header_bytenr(\n\t\t\t\t\t\t(struct btrfs_header *)\n\t\t\t\t\t\tmapped_datav[0]);\n\t\t\t\tbtrfsic_cmp_log_and_dev_bytenr(state, bytenr,\n\t\t\t\t\t\t\t       dev_state,\n\t\t\t\t\t\t\t       dev_bytenr);\n\t\t\t}\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE) {\n\t\t\t\tif (block->logical_bytenr != bytenr &&\n\t\t\t\t    !(!block->is_metadata &&\n\t\t\t\t      block->logical_bytenr == 0))\n\t\t\t\t\tpr_info(\n\"written block @%llu (%pg/%llu/%d) found in hash table, %c, bytenr mismatch (!= stored %llu)\\n\",\n\t\t\t\t\t       bytenr, dev_state->bdev,\n\t\t\t\t\t       dev_bytenr,\n\t\t\t\t\t       block->mirror_num,\n\t\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t\t      block),\n\t\t\t\t\t       block->logical_bytenr);\n\t\t\t\telse\n\t\t\t\t\tpr_info(\n\t\t\"written block @%llu (%pg/%llu/%d) found in hash table, %c\\n\",\n\t\t\t\t\t       bytenr, dev_state->bdev,\n\t\t\t\t\t       dev_bytenr, block->mirror_num,\n\t\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t\t      block));\n\t\t\t}\n\t\t\tblock->logical_bytenr = bytenr;\n\t\t} else {\n\t\t\tif (num_pages * PAGE_SIZE <\n\t\t\t    state->datablock_size) {\n\t\t\t\tpr_info(\"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprocessed_len = state->datablock_size;\n\t\t\tbytenr = block->logical_bytenr;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tpr_info(\n\t\t\"written block @%llu (%pg/%llu/%d) found in hash table, %c\\n\",\n\t\t\t\t       bytenr, dev_state->bdev, dev_bytenr,\n\t\t\t\t       block->mirror_num,\n\t\t\t\t       btrfsic_get_block_type(state, block));\n\t\t}\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tpr_info(\"ref_to_list: %cE, ref_from_list: %cE\\n\",\n\t\t\t       list_empty(&block->ref_to_list) ? ' ' : '!',\n\t\t\t       list_empty(&block->ref_from_list) ? ' ' : '!');\n\t\tif (btrfsic_is_block_ref_by_superblock(state, block, 0)) {\n\t\t\tpr_info(\n\"btrfs: attempt to overwrite %c-block @%llu (%pg/%llu/%d), old(gen=%llu, objectid=%llu, type=%d, offset=%llu), new(gen=%llu), which is referenced by most recent superblock (superblockgen=%llu)!\\n\",\n\t\t\t       btrfsic_get_block_type(state, block), bytenr,\n\t\t\t       dev_state->bdev, dev_bytenr, block->mirror_num,\n\t\t\t       block->generation,\n\t\t\t       btrfs_disk_key_objectid(&block->disk_key),\n\t\t\t       block->disk_key.type,\n\t\t\t       btrfs_disk_key_offset(&block->disk_key),\n\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       (struct btrfs_header *) mapped_datav[0]),\n\t\t\t       state->max_superblock_generation);\n\t\t\tbtrfsic_dump_tree(state);\n\t\t}\n\n\t\tif (!block->is_iodone && !block->never_written) {\n\t\t\tpr_info(\n\"btrfs: attempt to overwrite %c-block @%llu (%pg/%llu/%d), oldgen=%llu, newgen=%llu, which is not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, block), bytenr,\n\t\t\t       dev_state->bdev, dev_bytenr, block->mirror_num,\n\t\t\t       block->generation,\n\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       (struct btrfs_header *)\n\t\t\t\t       mapped_datav[0]));\n\t\t\t \n\t\t\tbtrfsic_dump_tree(state);\n\t\t\tgoto continue_loop;\n\t\t}\n\n\t\t \n\t\tlist_for_each_entry_safe(l, tmp, &block->ref_to_list,\n\t\t\t\t\t node_ref_to) {\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_rem_link(state, l);\n\t\t\tl->ref_cnt--;\n\t\t\tif (0 == l->ref_cnt) {\n\t\t\t\tlist_del(&l->node_ref_to);\n\t\t\t\tlist_del(&l->node_ref_from);\n\t\t\t\tbtrfsic_block_link_hashtable_remove(l);\n\t\t\t\tbtrfsic_block_link_free(l);\n\t\t\t}\n\t\t}\n\n\t\tblock_ctx.dev = dev_state;\n\t\tblock_ctx.dev_bytenr = dev_bytenr;\n\t\tblock_ctx.start = bytenr;\n\t\tblock_ctx.len = processed_len;\n\t\tblock_ctx.pagev = NULL;\n\t\tblock_ctx.mem_to_free = NULL;\n\t\tblock_ctx.datav = mapped_datav;\n\n\t\tif (is_metadata || state->include_extent_data) {\n\t\t\tblock->never_written = 0;\n\t\t\tblock->iodone_w_error = 0;\n\t\t\tif (NULL != bio) {\n\t\t\t\tblock->is_iodone = 0;\n\t\t\t\tBUG_ON(NULL == bio_is_patched);\n\t\t\t\tif (!*bio_is_patched) {\n\t\t\t\t\tblock->orig_bio_private =\n\t\t\t\t\t    bio->bi_private;\n\t\t\t\t\tblock->orig_bio_end_io =\n\t\t\t\t\t    bio->bi_end_io;\n\t\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\t\tbio->bi_private = block;\n\t\t\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t\t\t\t*bio_is_patched = 1;\n\t\t\t\t} else {\n\t\t\t\t\tstruct btrfsic_block *chained_block =\n\t\t\t\t\t    (struct btrfsic_block *)\n\t\t\t\t\t    bio->bi_private;\n\n\t\t\t\t\tBUG_ON(NULL == chained_block);\n\t\t\t\t\tblock->orig_bio_private =\n\t\t\t\t\t    chained_block->orig_bio_private;\n\t\t\t\t\tblock->orig_bio_end_io =\n\t\t\t\t\t    chained_block->orig_bio_end_io;\n\t\t\t\t\tblock->next_in_same_bio = chained_block;\n\t\t\t\t\tbio->bi_private = block;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tblock->is_iodone = 1;\n\t\t\t\tblock->orig_bio_private = NULL;\n\t\t\t\tblock->orig_bio_end_io = NULL;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t}\n\t\t}\n\n\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\tblock->submit_bio_bh_rw = submit_bio_bh_rw;\n\t\tif (is_metadata) {\n\t\t\tblock->logical_bytenr = bytenr;\n\t\t\tblock->is_metadata = 1;\n\t\t\tif (block->is_superblock) {\n\t\t\t\tBUG_ON(PAGE_SIZE !=\n\t\t\t\t       BTRFS_SUPER_INFO_SIZE);\n\t\t\t\tret = btrfsic_process_written_superblock(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\t(struct btrfs_super_block *)\n\t\t\t\t\t\tmapped_datav[0]);\n\t\t\t\tif (state->print_mask &\n\t\t\t\t    BTRFSIC_PRINT_MASK_TREE_AFTER_SB_WRITE) {\n\t\t\t\t\tpr_info(\"[after new superblock is written]:\\n\");\n\t\t\t\t\tbtrfsic_dump_tree_sub(state, block, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tblock->mirror_num = 0;\t \n\t\t\t\tret = btrfsic_process_metablock(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\t&block_ctx,\n\t\t\t\t\t\t0, 0);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tpr_info(\"btrfsic: btrfsic_process_metablock(root @%llu) failed!\\n\",\n\t\t\t\t       dev_bytenr);\n\t\t} else {\n\t\t\tblock->is_metadata = 0;\n\t\t\tblock->mirror_num = 0;\t \n\t\t\tblock->generation = BTRFSIC_GENERATION_UNKNOWN;\n\t\t\tif (!state->include_extent_data\n\t\t\t    && list_empty(&block->ref_from_list)) {\n\t\t\t\t \n\t\t\t\tbtrfsic_block_hashtable_remove(block);\n\t\t\t\tlist_del(&block->all_blocks_node);\n\t\t\t\tbtrfsic_block_free(block);\n\t\t\t}\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t} else {\n\t\t \n\t\tu64 bytenr;\n\n\t\tif (!is_metadata) {\n\t\t\tprocessed_len = state->datablock_size;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tpr_info(\n\t\t\t\"written block (%pg/%llu/?) !found in hash table, D\\n\",\n\t\t\t\t       dev_state->bdev, dev_bytenr);\n\t\t\tif (!state->include_extent_data) {\n\t\t\t\t \n\t\t\t\tgoto continue_loop;\n\t\t\t}\n\n\t\t\t \n\t\t\tbytenr = 0;\t \n\t\t} else {\n\t\t\tprocessed_len = state->metablock_size;\n\t\t\tbytenr = btrfs_stack_header_bytenr(\n\t\t\t\t\t(struct btrfs_header *)\n\t\t\t\t\tmapped_datav[0]);\n\t\t\tbtrfsic_cmp_log_and_dev_bytenr(state, bytenr, dev_state,\n\t\t\t\t\t\t       dev_bytenr);\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tpr_info(\n\t\t\t\"written block @%llu (%pg/%llu/?) !found in hash table, M\\n\",\n\t\t\t\t       bytenr, dev_state->bdev, dev_bytenr);\n\t\t}\n\n\t\tblock_ctx.dev = dev_state;\n\t\tblock_ctx.dev_bytenr = dev_bytenr;\n\t\tblock_ctx.start = bytenr;\n\t\tblock_ctx.len = processed_len;\n\t\tblock_ctx.pagev = NULL;\n\t\tblock_ctx.mem_to_free = NULL;\n\t\tblock_ctx.datav = mapped_datav;\n\n\t\tblock = btrfsic_block_alloc();\n\t\tif (NULL == block) {\n\t\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t\t\tgoto continue_loop;\n\t\t}\n\t\tblock->dev_state = dev_state;\n\t\tblock->dev_bytenr = dev_bytenr;\n\t\tblock->logical_bytenr = bytenr;\n\t\tblock->is_metadata = is_metadata;\n\t\tblock->never_written = 0;\n\t\tblock->iodone_w_error = 0;\n\t\tblock->mirror_num = 0;\t \n\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\tblock->submit_bio_bh_rw = submit_bio_bh_rw;\n\t\tif (NULL != bio) {\n\t\t\tblock->is_iodone = 0;\n\t\t\tBUG_ON(NULL == bio_is_patched);\n\t\t\tif (!*bio_is_patched) {\n\t\t\t\tblock->orig_bio_private = bio->bi_private;\n\t\t\t\tblock->orig_bio_end_io = bio->bi_end_io;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\tbio->bi_private = block;\n\t\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t\t\t*bio_is_patched = 1;\n\t\t\t} else {\n\t\t\t\tstruct btrfsic_block *chained_block =\n\t\t\t\t    (struct btrfsic_block *)\n\t\t\t\t    bio->bi_private;\n\n\t\t\t\tBUG_ON(NULL == chained_block);\n\t\t\t\tblock->orig_bio_private =\n\t\t\t\t    chained_block->orig_bio_private;\n\t\t\t\tblock->orig_bio_end_io =\n\t\t\t\t    chained_block->orig_bio_end_io;\n\t\t\t\tblock->next_in_same_bio = chained_block;\n\t\t\t\tbio->bi_private = block;\n\t\t\t}\n\t\t} else {\n\t\t\tblock->is_iodone = 1;\n\t\t\tblock->orig_bio_private = NULL;\n\t\t\tblock->orig_bio_end_io = NULL;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t}\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tpr_info(\"new written %c-block @%llu (%pg/%llu/%d)\\n\",\n\t\t\t       is_metadata ? 'M' : 'D',\n\t\t\t       block->logical_bytenr, block->dev_state->bdev,\n\t\t\t       block->dev_bytenr, block->mirror_num);\n\t\tlist_add(&block->all_blocks_node, &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(block, &state->block_hashtable);\n\n\t\tif (is_metadata) {\n\t\t\tret = btrfsic_process_metablock(state, block,\n\t\t\t\t\t\t\t&block_ctx, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tpr_info(\"btrfsic: process_metablock(root @%llu) failed!\\n\",\n\t\t\t\t       dev_bytenr);\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t}\n\ncontinue_loop:\n\tBUG_ON(!processed_len);\n\tdev_bytenr += processed_len;\n\tmapped_datav += processed_len >> PAGE_SHIFT;\n\tnum_pages -= processed_len >> PAGE_SHIFT;\n\tgoto again;\n}\n\nstatic void btrfsic_bio_end_io(struct bio *bp)\n{\n\tstruct btrfsic_block *block = bp->bi_private;\n\tint iodone_w_error;\n\n\t \n\tiodone_w_error = 0;\n\tif (bp->bi_status)\n\t\tiodone_w_error = 1;\n\n\tBUG_ON(NULL == block);\n\tbp->bi_private = block->orig_bio_private;\n\tbp->bi_end_io = block->orig_bio_end_io;\n\n\tdo {\n\t\tstruct btrfsic_block *next_block;\n\t\tstruct btrfsic_dev_state *const dev_state = block->dev_state;\n\n\t\tif ((dev_state->state->print_mask &\n\t\t     BTRFSIC_PRINT_MASK_END_IO_BIO_BH))\n\t\t\tpr_info(\"bio_end_io(err=%d) for %c @%llu (%pg/%llu/%d)\\n\",\n\t\t\t       bp->bi_status,\n\t\t\t       btrfsic_get_block_type(dev_state->state, block),\n\t\t\t       block->logical_bytenr, dev_state->bdev,\n\t\t\t       block->dev_bytenr, block->mirror_num);\n\t\tnext_block = block->next_in_same_bio;\n\t\tblock->iodone_w_error = iodone_w_error;\n\t\tif (block->submit_bio_bh_rw & REQ_PREFLUSH) {\n\t\t\tdev_state->last_flush_gen++;\n\t\t\tif ((dev_state->state->print_mask &\n\t\t\t     BTRFSIC_PRINT_MASK_END_IO_BIO_BH))\n\t\t\t\tpr_info(\"bio_end_io() new %pg flush_gen=%llu\\n\",\n\t\t\t\t       dev_state->bdev,\n\t\t\t\t       dev_state->last_flush_gen);\n\t\t}\n\t\tif (block->submit_bio_bh_rw & REQ_FUA)\n\t\t\tblock->flush_gen = 0;  \n\t\tblock->is_iodone = 1;  \n\t\tblock = next_block;\n\t} while (NULL != block);\n\n\tbp->bi_end_io(bp);\n}\n\nstatic int btrfsic_process_written_superblock(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *const superblock,\n\t\tstruct btrfs_super_block *const super_hdr)\n{\n\tstruct btrfs_fs_info *fs_info = state->fs_info;\n\tint pass;\n\n\tsuperblock->generation = btrfs_super_generation(super_hdr);\n\tif (!(superblock->generation > state->max_superblock_generation ||\n\t      0 == state->max_superblock_generation)) {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE)\n\t\t\tpr_info(\n\t\"btrfsic: superblock @%llu (%pg/%llu/%d) with old gen %llu <= %llu\\n\",\n\t\t\t       superblock->logical_bytenr,\n\t\t\t       superblock->dev_state->bdev,\n\t\t\t       superblock->dev_bytenr, superblock->mirror_num,\n\t\t\t       btrfs_super_generation(super_hdr),\n\t\t\t       state->max_superblock_generation);\n\t} else {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE)\n\t\t\tpr_info(\n\t\"btrfsic: got new superblock @%llu (%pg/%llu/%d) with new gen %llu > %llu\\n\",\n\t\t\t       superblock->logical_bytenr,\n\t\t\t       superblock->dev_state->bdev,\n\t\t\t       superblock->dev_bytenr, superblock->mirror_num,\n\t\t\t       btrfs_super_generation(super_hdr),\n\t\t\t       state->max_superblock_generation);\n\n\t\tstate->max_superblock_generation =\n\t\t    btrfs_super_generation(super_hdr);\n\t\tstate->latest_superblock = superblock;\n\t}\n\n\tfor (pass = 0; pass < 3; pass++) {\n\t\tint ret;\n\t\tu64 next_bytenr;\n\t\tstruct btrfsic_block *next_block;\n\t\tstruct btrfsic_block_data_ctx tmp_next_block_ctx;\n\t\tstruct btrfsic_block_link *l;\n\t\tint num_copies;\n\t\tint mirror_num;\n\t\tconst char *additional_string = NULL;\n\t\tstruct btrfs_disk_key tmp_disk_key = {0};\n\n\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t    BTRFS_ROOT_ITEM_KEY);\n\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key, 0);\n\n\t\tswitch (pass) {\n\t\tcase 0:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_ROOT_TREE_OBJECTID);\n\t\t\tadditional_string = \"root \";\n\t\t\tnext_bytenr = btrfs_super_root(super_hdr);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tpr_info(\"root@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_CHUNK_TREE_OBJECTID);\n\t\t\tadditional_string = \"chunk \";\n\t\t\tnext_bytenr = btrfs_super_chunk_root(super_hdr);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tpr_info(\"chunk@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_TREE_LOG_OBJECTID);\n\t\t\tadditional_string = \"log \";\n\t\t\tnext_bytenr = btrfs_super_log_root(super_hdr);\n\t\t\tif (0 == next_bytenr)\n\t\t\t\tcontinue;\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tpr_info(\"log@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_copies = btrfs_num_copies(fs_info, next_bytenr,\n\t\t\t\t\t      BTRFS_SUPER_INFO_SIZE);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tpr_info(\"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tint was_created;\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tpr_info(\"btrfsic_process_written_superblock(mirror_num=%d)\\n\", mirror_num);\n\t\t\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t\tBTRFS_SUPER_INFO_SIZE,\n\t\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\t\tmirror_num);\n\t\t\tif (ret) {\n\t\t\t\tpr_info(\"btrfsic: btrfsic_map_block(@%llu, mirror=%d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_lookup_or_add(\n\t\t\t\t\tstate,\n\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\tadditional_string,\n\t\t\t\t\t1, 0, 1,\n\t\t\t\t\tmirror_num,\n\t\t\t\t\t&was_created);\n\t\t\tif (NULL == next_block) {\n\t\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block->disk_key = tmp_disk_key;\n\t\t\tif (was_created)\n\t\t\t\tnext_block->generation =\n\t\t\t\t    BTRFSIC_GENERATION_UNKNOWN;\n\t\t\tl = btrfsic_block_link_lookup_or_add(\n\t\t\t\t\tstate,\n\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\tnext_block,\n\t\t\t\t\tsuperblock,\n\t\t\t\t\tBTRFSIC_GENERATION_UNKNOWN);\n\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\tif (NULL == l)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (WARN_ON(-1 == btrfsic_check_all_ref_blocks(state, superblock, 0)))\n\t\tbtrfsic_dump_tree(state);\n\n\treturn 0;\n}\n\nstatic int btrfsic_check_all_ref_blocks(struct btrfsic_state *state,\n\t\t\t\t\tstruct btrfsic_block *const block,\n\t\t\t\t\tint recursion_level)\n{\n\tconst struct btrfsic_block_link *l;\n\tint ret = 0;\n\n\tif (recursion_level >= 3 + BTRFS_MAX_LEVEL) {\n\t\t \n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tpr_info(\"btrfsic: abort cyclic linkage (case 1).\\n\");\n\n\t\treturn ret;\n\t}\n\n\t \n\tlist_for_each_entry(l, &block->ref_to_list, node_ref_to) {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tpr_info(\n\t\t\"rl=%d, %c @%llu (%pg/%llu/%d) %u* refers to %c @%llu (%pg/%llu/%d)\\n\",\n\t\t\t       recursion_level,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, block->dev_state->bdev,\n\t\t\t       block->dev_bytenr, block->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->bdev,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\tif (l->block_ref_to->never_written) {\n\t\t\tpr_info(\n\"btrfs: attempt to write superblock which references block %c @%llu (%pg/%llu/%d) which is never written!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->bdev,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t\tret = -1;\n\t\t} else if (!l->block_ref_to->is_iodone) {\n\t\t\tpr_info(\n\"btrfs: attempt to write superblock which references block %c @%llu (%pg/%llu/%d) which is not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->bdev,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t\tret = -1;\n\t\t} else if (l->block_ref_to->iodone_w_error) {\n\t\t\tpr_info(\n\"btrfs: attempt to write superblock which references block %c @%llu (%pg/%llu/%d) which has write error!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->bdev,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t\tret = -1;\n\t\t} else if (l->parent_generation !=\n\t\t\t   l->block_ref_to->generation &&\n\t\t\t   BTRFSIC_GENERATION_UNKNOWN !=\n\t\t\t   l->parent_generation &&\n\t\t\t   BTRFSIC_GENERATION_UNKNOWN !=\n\t\t\t   l->block_ref_to->generation) {\n\t\t\tpr_info(\n\"btrfs: attempt to write superblock which references block %c @%llu (%pg/%llu/%d) with generation %llu != parent generation %llu!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->bdev,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num,\n\t\t\t       l->block_ref_to->generation,\n\t\t\t       l->parent_generation);\n\t\t\tret = -1;\n\t\t} else if (l->block_ref_to->flush_gen >\n\t\t\t   l->block_ref_to->dev_state->last_flush_gen) {\n\t\t\tpr_info(\n\"btrfs: attempt to write superblock which references block %c @%llu (%pg/%llu/%d) which is not flushed out of disk's write cache (block flush_gen=%llu, dev->flush_gen=%llu)!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->bdev,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num, block->flush_gen,\n\t\t\t       l->block_ref_to->dev_state->last_flush_gen);\n\t\t\tret = -1;\n\t\t} else if (-1 == btrfsic_check_all_ref_blocks(state,\n\t\t\t\t\t\t\t      l->block_ref_to,\n\t\t\t\t\t\t\t      recursion_level +\n\t\t\t\t\t\t\t      1)) {\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int btrfsic_is_block_ref_by_superblock(\n\t\tconst struct btrfsic_state *state,\n\t\tconst struct btrfsic_block *block,\n\t\tint recursion_level)\n{\n\tconst struct btrfsic_block_link *l;\n\n\tif (recursion_level >= 3 + BTRFS_MAX_LEVEL) {\n\t\t \n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tpr_info(\"btrfsic: abort cyclic linkage (case 2).\\n\");\n\n\t\treturn 0;\n\t}\n\n\t \n\tlist_for_each_entry(l, &block->ref_from_list, node_ref_from) {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tpr_info(\n\t\"rl=%d, %c @%llu (%pg/%llu/%d) is ref %u* from %c @%llu (%pg/%llu/%d)\\n\",\n\t\t\t       recursion_level,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, block->dev_state->bdev,\n\t\t\t       block->dev_bytenr, block->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t\t\t       l->block_ref_from->logical_bytenr,\n\t\t\t       l->block_ref_from->dev_state->bdev,\n\t\t\t       l->block_ref_from->dev_bytenr,\n\t\t\t       l->block_ref_from->mirror_num);\n\t\tif (l->block_ref_from->is_superblock &&\n\t\t    state->latest_superblock->dev_bytenr ==\n\t\t    l->block_ref_from->dev_bytenr &&\n\t\t    state->latest_superblock->dev_state->bdev ==\n\t\t    l->block_ref_from->dev_state->bdev)\n\t\t\treturn 1;\n\t\telse if (btrfsic_is_block_ref_by_superblock(state,\n\t\t\t\t\t\t\t    l->block_ref_from,\n\t\t\t\t\t\t\t    recursion_level +\n\t\t\t\t\t\t\t    1))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l)\n{\n\tpr_info(\"add %u* link from %c @%llu (%pg/%llu/%d) to %c @%llu (%pg/%llu/%d)\\n\",\n\t       l->ref_cnt,\n\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t       l->block_ref_from->logical_bytenr,\n\t       l->block_ref_from->dev_state->bdev,\n\t       l->block_ref_from->dev_bytenr, l->block_ref_from->mirror_num,\n\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t       l->block_ref_to->logical_bytenr,\n\t       l->block_ref_to->dev_state->bdev, l->block_ref_to->dev_bytenr,\n\t       l->block_ref_to->mirror_num);\n}\n\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l)\n{\n\tpr_info(\"rem %u* link from %c @%llu (%pg/%llu/%d) to %c @%llu (%pg/%llu/%d)\\n\",\n\t       l->ref_cnt,\n\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t       l->block_ref_from->logical_bytenr,\n\t       l->block_ref_from->dev_state->bdev,\n\t       l->block_ref_from->dev_bytenr, l->block_ref_from->mirror_num,\n\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t       l->block_ref_to->logical_bytenr,\n\t       l->block_ref_to->dev_state->bdev, l->block_ref_to->dev_bytenr,\n\t       l->block_ref_to->mirror_num);\n}\n\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}\n\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state)\n{\n\tbtrfsic_dump_tree_sub(state, state->latest_superblock, 0);\n}\n\nstatic void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level)\n{\n\tconst struct btrfsic_block_link *l;\n\tint indent_add;\n\tstatic char buf[80];\n\tint cursor_position;\n\n\t \n\n\t \n\tindent_add = sprintf(buf, \"%c-%llu(%pg/%llu/%u)\",\n\t\t\t     btrfsic_get_block_type(state, block),\n\t\t\t     block->logical_bytenr, block->dev_state->bdev,\n\t\t\t     block->dev_bytenr, block->mirror_num);\n\tif (indent_level + indent_add > BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\tprintk(\"[...]\\n\");\n\t\treturn;\n\t}\n\tprintk(buf);\n\tindent_level += indent_add;\n\tif (list_empty(&block->ref_to_list)) {\n\t\tprintk(\"\\n\");\n\t\treturn;\n\t}\n\tif (block->mirror_num > 1 &&\n\t    !(state->print_mask & BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS)) {\n\t\tprintk(\" [...]\\n\");\n\t\treturn;\n\t}\n\n\tcursor_position = indent_level;\n\tlist_for_each_entry(l, &block->ref_to_list, node_ref_to) {\n\t\twhile (cursor_position < indent_level) {\n\t\t\tprintk(\" \");\n\t\t\tcursor_position++;\n\t\t}\n\t\tif (l->ref_cnt > 1)\n\t\t\tindent_add = sprintf(buf, \" %d*--> \", l->ref_cnt);\n\t\telse\n\t\t\tindent_add = sprintf(buf, \" --> \");\n\t\tif (indent_level + indent_add >\n\t\t    BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\t\tprintk(\"[...]\\n\");\n\t\t\tcursor_position = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintk(buf);\n\n\t\tbtrfsic_dump_tree_sub(state, l->block_ref_to,\n\t\t\t\t      indent_level + indent_add);\n\t\tcursor_position = 0;\n\t}\n}\n\nstatic struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation)\n{\n\tstruct btrfsic_block_link *l;\n\n\tl = btrfsic_block_link_hashtable_lookup(next_block_ctx->dev->bdev,\n\t\t\t\t\t\tnext_block_ctx->dev_bytenr,\n\t\t\t\t\t\tfrom_block->dev_state->bdev,\n\t\t\t\t\t\tfrom_block->dev_bytenr,\n\t\t\t\t\t\t&state->block_link_hashtable);\n\tif (NULL == l) {\n\t\tl = btrfsic_block_link_alloc();\n\t\tif (!l)\n\t\t\treturn NULL;\n\n\t\tl->block_ref_to = next_block;\n\t\tl->block_ref_from = from_block;\n\t\tl->ref_cnt = 1;\n\t\tl->parent_generation = parent_generation;\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\n\t\tlist_add(&l->node_ref_to, &from_block->ref_to_list);\n\t\tlist_add(&l->node_ref_from, &next_block->ref_from_list);\n\n\t\tbtrfsic_block_link_hashtable_add(l,\n\t\t\t\t\t\t &state->block_link_hashtable);\n\t} else {\n\t\tl->ref_cnt++;\n\t\tl->parent_generation = parent_generation;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\t}\n\n\treturn l;\n}\n\nstatic struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created)\n{\n\tstruct btrfsic_block *block;\n\n\tblock = btrfsic_block_hashtable_lookup(block_ctx->dev->bdev,\n\t\t\t\t\t       block_ctx->dev_bytenr,\n\t\t\t\t\t       &state->block_hashtable);\n\tif (NULL == block) {\n\t\tstruct btrfsic_dev_state *dev_state;\n\n\t\tblock = btrfsic_block_alloc();\n\t\tif (!block)\n\t\t\treturn NULL;\n\n\t\tdev_state = btrfsic_dev_state_lookup(block_ctx->dev->bdev->bd_dev);\n\t\tif (NULL == dev_state) {\n\t\t\tpr_info(\"btrfsic: error, lookup dev_state failed!\\n\");\n\t\t\tbtrfsic_block_free(block);\n\t\t\treturn NULL;\n\t\t}\n\t\tblock->dev_state = dev_state;\n\t\tblock->dev_bytenr = block_ctx->dev_bytenr;\n\t\tblock->logical_bytenr = block_ctx->start;\n\t\tblock->is_metadata = is_metadata;\n\t\tblock->is_iodone = is_iodone;\n\t\tblock->never_written = never_written;\n\t\tblock->mirror_num = mirror_num;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tpr_info(\"New %s%c-block @%llu (%pg/%llu/%d)\\n\",\n\t\t\t       additional_string,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, dev_state->bdev,\n\t\t\t       block->dev_bytenr, mirror_num);\n\t\tlist_add(&block->all_blocks_node, &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(block, &state->block_hashtable);\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 1;\n\t} else {\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 0;\n\t}\n\n\treturn block;\n}\n\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr)\n{\n\tstruct btrfs_fs_info *fs_info = state->fs_info;\n\tstruct btrfsic_block_data_ctx block_ctx;\n\tint num_copies;\n\tint mirror_num;\n\tint match = 0;\n\tint ret;\n\n\tnum_copies = btrfs_num_copies(fs_info, bytenr, state->metablock_size);\n\n\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\tret = btrfsic_map_block(state, bytenr, state->metablock_size,\n\t\t\t\t\t&block_ctx, mirror_num);\n\t\tif (ret) {\n\t\t\tpr_info(\"btrfsic: btrfsic_map_block(logical @%llu, mirror %d) failed!\\n\",\n\t\t\t       bytenr, mirror_num);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev_state->bdev == block_ctx.dev->bdev &&\n\t\t    dev_bytenr == block_ctx.dev_bytenr) {\n\t\t\tmatch++;\n\t\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t}\n\n\tif (WARN_ON(!match)) {\n\t\tpr_info(\n\"btrfs: attempt to write M-block which contains logical bytenr that doesn't map to dev+physical bytenr of submit_bio, buffer->log_bytenr=%llu, submit_bio(bdev=%pg, phys_bytenr=%llu)!\\n\",\n\t\t       bytenr, dev_state->bdev, dev_bytenr);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tret = btrfsic_map_block(state, bytenr,\n\t\t\t\t\t\tstate->metablock_size,\n\t\t\t\t\t\t&block_ctx, mirror_num);\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\n\t\t\tpr_info(\"read logical bytenr @%llu maps to (%pg/%llu/%d)\\n\",\n\t\t\t       bytenr, block_ctx.dev->bdev,\n\t\t\t       block_ctx.dev_bytenr, mirror_num);\n\t\t}\n\t}\n}\n\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(dev_t dev)\n{\n\treturn btrfsic_dev_state_hashtable_lookup(dev,\n\t\t\t\t\t\t  &btrfsic_dev_state_hashtable);\n}\n\nstatic void btrfsic_check_write_bio(struct bio *bio, struct btrfsic_dev_state *dev_state)\n{\n\tunsigned int segs = bio_segments(bio);\n\tu64 dev_bytenr = 512 * bio->bi_iter.bi_sector;\n\tu64 cur_bytenr = dev_bytenr;\n\tstruct bvec_iter iter;\n\tstruct bio_vec bvec;\n\tchar **mapped_datav;\n\tint bio_is_patched = 0;\n\tint i = 0;\n\n\tif (dev_state->state->print_mask & BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\tpr_info(\n\"submit_bio(rw=%d,0x%x, bi_vcnt=%u, bi_sector=%llu (bytenr %llu), bi_bdev=%p)\\n\",\n\t\t       bio_op(bio), bio->bi_opf, segs,\n\t\t       bio->bi_iter.bi_sector, dev_bytenr, bio->bi_bdev);\n\n\tmapped_datav = kmalloc_array(segs, sizeof(*mapped_datav), GFP_NOFS);\n\tif (!mapped_datav)\n\t\treturn;\n\n\tbio_for_each_segment(bvec, bio, iter) {\n\t\tBUG_ON(bvec.bv_len != PAGE_SIZE);\n\t\tmapped_datav[i] = page_address(bvec.bv_page);\n\t\ti++;\n\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH_VERBOSE)\n\t\t\tpr_info(\"#%u: bytenr=%llu, len=%u, offset=%u\\n\",\n\t\t\t       i, cur_bytenr, bvec.bv_len, bvec.bv_offset);\n\t\tcur_bytenr += bvec.bv_len;\n\t}\n\n\tbtrfsic_process_written_block(dev_state, dev_bytenr, mapped_datav, segs,\n\t\t\t\t      bio, &bio_is_patched, bio->bi_opf);\n\tkfree(mapped_datav);\n}\n\nstatic void btrfsic_check_flush_bio(struct bio *bio, struct btrfsic_dev_state *dev_state)\n{\n\tif (dev_state->state->print_mask & BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\tpr_info(\"submit_bio(rw=%d,0x%x FLUSH, bdev=%p)\\n\",\n\t\t       bio_op(bio), bio->bi_opf, bio->bi_bdev);\n\n\tif (dev_state->dummy_block_for_bio_bh_flush.is_iodone) {\n\t\tstruct btrfsic_block *const block =\n\t\t\t&dev_state->dummy_block_for_bio_bh_flush;\n\n\t\tblock->is_iodone = 0;\n\t\tblock->never_written = 0;\n\t\tblock->iodone_w_error = 0;\n\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\tblock->submit_bio_bh_rw = bio->bi_opf;\n\t\tblock->orig_bio_private = bio->bi_private;\n\t\tblock->orig_bio_end_io = bio->bi_end_io;\n\t\tblock->next_in_same_bio = NULL;\n\t\tbio->bi_private = block;\n\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t} else if ((dev_state->state->print_mask &\n\t\t   (BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH |\n\t\t    BTRFSIC_PRINT_MASK_VERBOSE))) {\n\t\tpr_info(\n\"btrfsic_submit_bio(%pg) with FLUSH but dummy block already in use (ignored)!\\n\",\n\t\t       dev_state->bdev);\n\t}\n}\n\nvoid btrfsic_check_bio(struct bio *bio)\n{\n\tstruct btrfsic_dev_state *dev_state;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn;\n\n\t \n\tdev_state = btrfsic_dev_state_lookup(bio->bi_bdev->bd_dev);\n\tmutex_lock(&btrfsic_mutex);\n\tif (dev_state) {\n\t\tif (bio_op(bio) == REQ_OP_WRITE && bio_has_data(bio))\n\t\t\tbtrfsic_check_write_bio(bio, dev_state);\n\t\telse if (bio->bi_opf & REQ_PREFLUSH)\n\t\t\tbtrfsic_check_flush_bio(bio, dev_state);\n\t}\n\tmutex_unlock(&btrfsic_mutex);\n}\n\nint btrfsic_mount(struct btrfs_fs_info *fs_info,\n\t\t  struct btrfs_fs_devices *fs_devices,\n\t\t  int including_extent_data, u32 print_mask)\n{\n\tint ret;\n\tstruct btrfsic_state *state;\n\tstruct list_head *dev_head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\n\tif (!PAGE_ALIGNED(fs_info->nodesize)) {\n\t\tpr_info(\"btrfsic: cannot handle nodesize %d not being a multiple of PAGE_SIZE %ld!\\n\",\n\t\t       fs_info->nodesize, PAGE_SIZE);\n\t\treturn -1;\n\t}\n\tif (!PAGE_ALIGNED(fs_info->sectorsize)) {\n\t\tpr_info(\"btrfsic: cannot handle sectorsize %d not being a multiple of PAGE_SIZE %ld!\\n\",\n\t\t       fs_info->sectorsize, PAGE_SIZE);\n\t\treturn -1;\n\t}\n\tstate = kvzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tif (!btrfsic_is_initialized) {\n\t\tmutex_init(&btrfsic_mutex);\n\t\tbtrfsic_dev_state_hashtable_init(&btrfsic_dev_state_hashtable);\n\t\tbtrfsic_is_initialized = 1;\n\t}\n\tmutex_lock(&btrfsic_mutex);\n\tstate->fs_info = fs_info;\n\tstate->print_mask = print_mask;\n\tstate->include_extent_data = including_extent_data;\n\tstate->metablock_size = fs_info->nodesize;\n\tstate->datablock_size = fs_info->sectorsize;\n\tINIT_LIST_HEAD(&state->all_blocks_list);\n\tbtrfsic_block_hashtable_init(&state->block_hashtable);\n\tbtrfsic_block_link_hashtable_init(&state->block_link_hashtable);\n\tstate->max_superblock_generation = 0;\n\tstate->latest_superblock = NULL;\n\n\tlist_for_each_entry(device, dev_head, dev_list) {\n\t\tstruct btrfsic_dev_state *ds;\n\n\t\tif (!device->bdev || !device->name)\n\t\t\tcontinue;\n\n\t\tds = btrfsic_dev_state_alloc();\n\t\tif (NULL == ds) {\n\t\t\tmutex_unlock(&btrfsic_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tds->bdev = device->bdev;\n\t\tds->state = state;\n\t\tbtrfsic_dev_state_hashtable_add(ds,\n\t\t\t\t\t\t&btrfsic_dev_state_hashtable);\n\t}\n\n\tret = btrfsic_process_superblock(state, fs_devices);\n\tif (0 != ret) {\n\t\tmutex_unlock(&btrfsic_mutex);\n\t\tbtrfsic_unmount(fs_devices);\n\t\treturn ret;\n\t}\n\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_INITIAL_DATABASE)\n\t\tbtrfsic_dump_database(state);\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_INITIAL_TREE)\n\t\tbtrfsic_dump_tree(state);\n\n\tmutex_unlock(&btrfsic_mutex);\n\treturn 0;\n}\n\nvoid btrfsic_unmount(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfsic_block *b_all, *tmp_all;\n\tstruct btrfsic_state *state;\n\tstruct list_head *dev_head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn;\n\n\tmutex_lock(&btrfsic_mutex);\n\n\tstate = NULL;\n\tlist_for_each_entry(device, dev_head, dev_list) {\n\t\tstruct btrfsic_dev_state *ds;\n\n\t\tif (!device->bdev || !device->name)\n\t\t\tcontinue;\n\n\t\tds = btrfsic_dev_state_hashtable_lookup(\n\t\t\t\tdevice->bdev->bd_dev,\n\t\t\t\t&btrfsic_dev_state_hashtable);\n\t\tif (NULL != ds) {\n\t\t\tstate = ds->state;\n\t\t\tbtrfsic_dev_state_hashtable_remove(ds);\n\t\t\tbtrfsic_dev_state_free(ds);\n\t\t}\n\t}\n\n\tif (NULL == state) {\n\t\tpr_info(\"btrfsic: error, cannot find state information on umount!\\n\");\n\t\tmutex_unlock(&btrfsic_mutex);\n\t\treturn;\n\t}\n\n\t \n\tlist_for_each_entry_safe(b_all, tmp_all, &state->all_blocks_list,\n\t\t\t\t all_blocks_node) {\n\t\tstruct btrfsic_block_link *l, *tmp;\n\n\t\tlist_for_each_entry_safe(l, tmp, &b_all->ref_to_list,\n\t\t\t\t\t node_ref_to) {\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_rem_link(state, l);\n\n\t\t\tl->ref_cnt--;\n\t\t\tif (0 == l->ref_cnt)\n\t\t\t\tbtrfsic_block_link_free(l);\n\t\t}\n\n\t\tif (b_all->is_iodone || b_all->never_written)\n\t\t\tbtrfsic_block_free(b_all);\n\t\telse\n\t\t\tpr_info(\n\"btrfs: attempt to free %c-block @%llu (%pg/%llu/%d) on umount which is not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, b_all),\n\t\t\t       b_all->logical_bytenr, b_all->dev_state->bdev,\n\t\t\t       b_all->dev_bytenr, b_all->mirror_num);\n\t}\n\n\tmutex_unlock(&btrfsic_mutex);\n\n\tkvfree(state);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}