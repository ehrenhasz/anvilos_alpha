{
  "module_name": "delayed-ref.h",
  "hash_id": "6e5ec5d98d707747b8ff537655dd1fcddc2549268e133fa71ea00ba13dd5547e",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/delayed-ref.h",
  "human_readable_source": " \n \n\n#ifndef BTRFS_DELAYED_REF_H\n#define BTRFS_DELAYED_REF_H\n\n#include <linux/refcount.h>\n\n \n#define BTRFS_ADD_DELAYED_REF    1  \n#define BTRFS_DROP_DELAYED_REF   2  \n#define BTRFS_ADD_DELAYED_EXTENT 3  \n#define BTRFS_UPDATE_DELAYED_HEAD 4  \n\nstruct btrfs_delayed_ref_node {\n\tstruct rb_node ref_node;\n\t \n\tstruct list_head add_list;\n\n\t \n\tu64 bytenr;\n\n\t \n\tu64 num_bytes;\n\n\t \n\tu64 seq;\n\n\t \n\trefcount_t refs;\n\n\t \n\tint ref_mod;\n\n\tunsigned int action:8;\n\tunsigned int type:8;\n};\n\nstruct btrfs_delayed_extent_op {\n\tstruct btrfs_disk_key key;\n\tu8 level;\n\tbool update_key;\n\tbool update_flags;\n\tu64 flags_to_set;\n};\n\n \nstruct btrfs_delayed_ref_head {\n\tu64 bytenr;\n\tu64 num_bytes;\n\t \n\tstruct rb_node href_node;\n\t \n\tstruct mutex mutex;\n\n\trefcount_t refs;\n\n\t \n\tspinlock_t lock;\n\tstruct rb_root_cached ref_tree;\n\t \n\tstruct list_head ref_add_list;\n\n\tstruct btrfs_delayed_extent_op *extent_op;\n\n\t \n\tint total_ref_mod;\n\n\t \n\tint ref_mod;\n\n\t \n\tbool must_insert_reserved;\n\tbool is_data;\n\tbool is_system;\n\tbool processing;\n};\n\nstruct btrfs_delayed_tree_ref {\n\tstruct btrfs_delayed_ref_node node;\n\tu64 root;\n\tu64 parent;\n\tint level;\n};\n\nstruct btrfs_delayed_data_ref {\n\tstruct btrfs_delayed_ref_node node;\n\tu64 root;\n\tu64 parent;\n\tu64 objectid;\n\tu64 offset;\n};\n\nenum btrfs_delayed_ref_flags {\n\t \n\tBTRFS_DELAYED_REFS_FLUSHING,\n};\n\nstruct btrfs_delayed_ref_root {\n\t \n\tstruct rb_root_cached href_root;\n\n\t \n\tstruct rb_root dirty_extent_root;\n\n\t \n\tspinlock_t lock;\n\n\t \n\tatomic_t num_entries;\n\n\t \n\tunsigned long num_heads;\n\n\t \n\tunsigned long num_heads_ready;\n\n\tu64 pending_csums;\n\n\tunsigned long flags;\n\n\tu64 run_delayed_start;\n\n\t \n\tu64 qgroup_to_skip;\n};\n\nenum btrfs_ref_type {\n\tBTRFS_REF_NOT_SET,\n\tBTRFS_REF_DATA,\n\tBTRFS_REF_METADATA,\n\tBTRFS_REF_LAST,\n};\n\nstruct btrfs_data_ref {\n\t \n\n\t \n\tu64 owning_root;\n\n\t \n\tu64 ino;\n\n\t \n\tu64 offset;\n};\n\nstruct btrfs_tree_ref {\n\t \n\tint level;\n\n\t \n\tu64 owning_root;\n\n\t \n};\n\nstruct btrfs_ref {\n\tenum btrfs_ref_type type;\n\tint action;\n\n\t \n\tbool skip_qgroup;\n\n#ifdef CONFIG_BTRFS_FS_REF_VERIFY\n\t \n\tu64 real_root;\n#endif\n\tu64 bytenr;\n\tu64 len;\n\n\t \n\tu64 parent;\n\tunion {\n\t\tstruct btrfs_data_ref data_ref;\n\t\tstruct btrfs_tree_ref tree_ref;\n\t};\n};\n\nextern struct kmem_cache *btrfs_delayed_ref_head_cachep;\nextern struct kmem_cache *btrfs_delayed_tree_ref_cachep;\nextern struct kmem_cache *btrfs_delayed_data_ref_cachep;\nextern struct kmem_cache *btrfs_delayed_extent_op_cachep;\n\nint __init btrfs_delayed_ref_init(void);\nvoid __cold btrfs_delayed_ref_exit(void);\n\nstatic inline u64 btrfs_calc_delayed_ref_bytes(const struct btrfs_fs_info *fs_info,\n\t\t\t\t\t       int num_delayed_refs)\n{\n\tu64 num_bytes;\n\n\tnum_bytes = btrfs_calc_insert_metadata_size(fs_info, num_delayed_refs);\n\n\t \n\tif (btrfs_test_opt(fs_info, FREE_SPACE_TREE))\n\t\tnum_bytes *= 2;\n\n\treturn num_bytes;\n}\n\nstatic inline void btrfs_init_generic_ref(struct btrfs_ref *generic_ref,\n\t\t\t\tint action, u64 bytenr, u64 len, u64 parent)\n{\n\tgeneric_ref->action = action;\n\tgeneric_ref->bytenr = bytenr;\n\tgeneric_ref->len = len;\n\tgeneric_ref->parent = parent;\n}\n\nstatic inline void btrfs_init_tree_ref(struct btrfs_ref *generic_ref,\n\t\t\t\tint level, u64 root, u64 mod_root, bool skip_qgroup)\n{\n#ifdef CONFIG_BTRFS_FS_REF_VERIFY\n\t \n\tgeneric_ref->real_root = mod_root ?: root;\n#endif\n\tgeneric_ref->tree_ref.level = level;\n\tgeneric_ref->tree_ref.owning_root = root;\n\tgeneric_ref->type = BTRFS_REF_METADATA;\n\tif (skip_qgroup || !(is_fstree(root) &&\n\t\t\t     (!mod_root || is_fstree(mod_root))))\n\t\tgeneric_ref->skip_qgroup = true;\n\telse\n\t\tgeneric_ref->skip_qgroup = false;\n\n}\n\nstatic inline void btrfs_init_data_ref(struct btrfs_ref *generic_ref,\n\t\t\t\tu64 ref_root, u64 ino, u64 offset, u64 mod_root,\n\t\t\t\tbool skip_qgroup)\n{\n#ifdef CONFIG_BTRFS_FS_REF_VERIFY\n\t \n\tgeneric_ref->real_root = mod_root ?: ref_root;\n#endif\n\tgeneric_ref->data_ref.owning_root = ref_root;\n\tgeneric_ref->data_ref.ino = ino;\n\tgeneric_ref->data_ref.offset = offset;\n\tgeneric_ref->type = BTRFS_REF_DATA;\n\tif (skip_qgroup || !(is_fstree(ref_root) &&\n\t\t\t     (!mod_root || is_fstree(mod_root))))\n\t\tgeneric_ref->skip_qgroup = true;\n\telse\n\t\tgeneric_ref->skip_qgroup = false;\n}\n\nstatic inline struct btrfs_delayed_extent_op *\nbtrfs_alloc_delayed_extent_op(void)\n{\n\treturn kmem_cache_alloc(btrfs_delayed_extent_op_cachep, GFP_NOFS);\n}\n\nstatic inline void\nbtrfs_free_delayed_extent_op(struct btrfs_delayed_extent_op *op)\n{\n\tif (op)\n\t\tkmem_cache_free(btrfs_delayed_extent_op_cachep, op);\n}\n\nstatic inline void btrfs_put_delayed_ref(struct btrfs_delayed_ref_node *ref)\n{\n\tWARN_ON(refcount_read(&ref->refs) == 0);\n\tif (refcount_dec_and_test(&ref->refs)) {\n\t\tWARN_ON(!RB_EMPTY_NODE(&ref->ref_node));\n\t\tswitch (ref->type) {\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tkmem_cache_free(btrfs_delayed_tree_ref_cachep, ref);\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tkmem_cache_free(btrfs_delayed_data_ref_cachep, ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n}\n\nstatic inline u64 btrfs_ref_head_to_space_flags(\n\t\t\t\tstruct btrfs_delayed_ref_head *head_ref)\n{\n\tif (head_ref->is_data)\n\t\treturn BTRFS_BLOCK_GROUP_DATA;\n\telse if (head_ref->is_system)\n\t\treturn BTRFS_BLOCK_GROUP_SYSTEM;\n\treturn BTRFS_BLOCK_GROUP_METADATA;\n}\n\nstatic inline void btrfs_put_delayed_ref_head(struct btrfs_delayed_ref_head *head)\n{\n\tif (refcount_dec_and_test(&head->refs))\n\t\tkmem_cache_free(btrfs_delayed_ref_head_cachep, head);\n}\n\nint btrfs_add_delayed_tree_ref(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_ref *generic_ref,\n\t\t\t       struct btrfs_delayed_extent_op *extent_op);\nint btrfs_add_delayed_data_ref(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_ref *generic_ref,\n\t\t\t       u64 reserved);\nint btrfs_add_delayed_extent_op(struct btrfs_trans_handle *trans,\n\t\t\t\tu64 bytenr, u64 num_bytes,\n\t\t\t\tstruct btrfs_delayed_extent_op *extent_op);\nvoid btrfs_merge_delayed_refs(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_delayed_ref_root *delayed_refs,\n\t\t\t      struct btrfs_delayed_ref_head *head);\n\nstruct btrfs_delayed_ref_head *\nbtrfs_find_delayed_ref_head(struct btrfs_delayed_ref_root *delayed_refs,\n\t\t\t    u64 bytenr);\nint btrfs_delayed_ref_lock(struct btrfs_delayed_ref_root *delayed_refs,\n\t\t\t   struct btrfs_delayed_ref_head *head);\nstatic inline void btrfs_delayed_ref_unlock(struct btrfs_delayed_ref_head *head)\n{\n\tmutex_unlock(&head->mutex);\n}\nvoid btrfs_delete_ref_head(struct btrfs_delayed_ref_root *delayed_refs,\n\t\t\t   struct btrfs_delayed_ref_head *head);\n\nstruct btrfs_delayed_ref_head *btrfs_select_ref_head(\n\t\tstruct btrfs_delayed_ref_root *delayed_refs);\n\nint btrfs_check_delayed_seq(struct btrfs_fs_info *fs_info, u64 seq);\n\nvoid btrfs_delayed_refs_rsv_release(struct btrfs_fs_info *fs_info, int nr);\nvoid btrfs_update_delayed_refs_rsv(struct btrfs_trans_handle *trans);\nint btrfs_delayed_refs_rsv_refill(struct btrfs_fs_info *fs_info,\n\t\t\t\t  enum btrfs_reserve_flush_enum flush);\nvoid btrfs_migrate_to_delayed_refs_rsv(struct btrfs_fs_info *fs_info,\n\t\t\t\t       u64 num_bytes);\nbool btrfs_check_space_for_delayed_refs(struct btrfs_fs_info *fs_info);\n\n \nstatic inline struct btrfs_delayed_tree_ref *\nbtrfs_delayed_node_to_tree_ref(struct btrfs_delayed_ref_node *node)\n{\n\treturn container_of(node, struct btrfs_delayed_tree_ref, node);\n}\n\nstatic inline struct btrfs_delayed_data_ref *\nbtrfs_delayed_node_to_data_ref(struct btrfs_delayed_ref_node *node)\n{\n\treturn container_of(node, struct btrfs_delayed_data_ref, node);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}