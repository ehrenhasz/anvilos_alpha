{
  "module_name": "sysfs.c",
  "hash_id": "38178be9fef40344e9fe64c26ccfc8ce1c1143cfa4f5c0504eacfa29af99ebda",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/sched/mm.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/bug.h>\n#include <linux/list.h>\n#include <crypto/hash.h>\n#include \"messages.h\"\n#include \"ctree.h\"\n#include \"discard.h\"\n#include \"disk-io.h\"\n#include \"send.h\"\n#include \"transaction.h\"\n#include \"sysfs.h\"\n#include \"volumes.h\"\n#include \"space-info.h\"\n#include \"block-group.h\"\n#include \"qgroup.h\"\n#include \"misc.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n\n \n\nstruct btrfs_feature_attr {\n\tstruct kobj_attribute kobj_attr;\n\tenum btrfs_feature_set feature_set;\n\tu64 feature_bit;\n};\n\n \nstruct raid_kobject {\n\tu64 flags;\n\tstruct kobject kobj;\n};\n\n#define __INIT_KOBJ_ATTR(_name, _mode, _show, _store)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.attr\t= { .name = __stringify(_name), .mode = _mode },\t\\\n\t.show\t= _show,\t\t\t\t\t\t\\\n\t.store\t= _store,\t\t\t\t\t\t\\\n}\n\n#define BTRFS_ATTR_W(_prefix, _name, _store)\t\t\t        \\\n\tstatic struct kobj_attribute btrfs_attr_##_prefix##_##_name =\t\\\n\t\t\t__INIT_KOBJ_ATTR(_name, 0200, NULL, _store)\n\n#define BTRFS_ATTR_RW(_prefix, _name, _show, _store)\t\t\t\\\n\tstatic struct kobj_attribute btrfs_attr_##_prefix##_##_name =\t\\\n\t\t\t__INIT_KOBJ_ATTR(_name, 0644, _show, _store)\n\n#define BTRFS_ATTR(_prefix, _name, _show)\t\t\t\t\\\n\tstatic struct kobj_attribute btrfs_attr_##_prefix##_##_name =\t\\\n\t\t\t__INIT_KOBJ_ATTR(_name, 0444, _show, NULL)\n\n#define BTRFS_ATTR_PTR(_prefix, _name)\t\t\t\t\t\\\n\t(&btrfs_attr_##_prefix##_##_name.attr)\n\n#define BTRFS_FEAT_ATTR(_name, _feature_set, _feature_prefix, _feature_bit)  \\\nstatic struct btrfs_feature_attr btrfs_attr_features_##_name = {\t     \\\n\t.kobj_attr = __INIT_KOBJ_ATTR(_name, S_IRUGO,\t\t\t     \\\n\t\t\t\t      btrfs_feature_attr_show,\t\t     \\\n\t\t\t\t      btrfs_feature_attr_store),\t     \\\n\t.feature_set\t= _feature_set,\t\t\t\t\t     \\\n\t.feature_bit\t= _feature_prefix ##_## _feature_bit,\t\t     \\\n}\n#define BTRFS_FEAT_ATTR_PTR(_name)\t\t\t\t\t     \\\n\t(&btrfs_attr_features_##_name.kobj_attr.attr)\n\n#define BTRFS_FEAT_ATTR_COMPAT(name, feature) \\\n\tBTRFS_FEAT_ATTR(name, FEAT_COMPAT, BTRFS_FEATURE_COMPAT, feature)\n#define BTRFS_FEAT_ATTR_COMPAT_RO(name, feature) \\\n\tBTRFS_FEAT_ATTR(name, FEAT_COMPAT_RO, BTRFS_FEATURE_COMPAT_RO, feature)\n#define BTRFS_FEAT_ATTR_INCOMPAT(name, feature) \\\n\tBTRFS_FEAT_ATTR(name, FEAT_INCOMPAT, BTRFS_FEATURE_INCOMPAT, feature)\n\nstatic inline struct btrfs_fs_info *to_fs_info(struct kobject *kobj);\nstatic inline struct btrfs_fs_devices *to_fs_devs(struct kobject *kobj);\nstatic struct kobject *get_btrfs_kobj(struct kobject *kobj);\n\nstatic struct btrfs_feature_attr *to_btrfs_feature_attr(struct kobj_attribute *a)\n{\n\treturn container_of(a, struct btrfs_feature_attr, kobj_attr);\n}\n\nstatic struct kobj_attribute *attr_to_btrfs_attr(struct attribute *attr)\n{\n\treturn container_of(attr, struct kobj_attribute, attr);\n}\n\nstatic struct btrfs_feature_attr *attr_to_btrfs_feature_attr(\n\t\tstruct attribute *attr)\n{\n\treturn to_btrfs_feature_attr(attr_to_btrfs_attr(attr));\n}\n\nstatic u64 get_features(struct btrfs_fs_info *fs_info,\n\t\t\tenum btrfs_feature_set set)\n{\n\tstruct btrfs_super_block *disk_super = fs_info->super_copy;\n\tif (set == FEAT_COMPAT)\n\t\treturn btrfs_super_compat_flags(disk_super);\n\telse if (set == FEAT_COMPAT_RO)\n\t\treturn btrfs_super_compat_ro_flags(disk_super);\n\telse\n\t\treturn btrfs_super_incompat_flags(disk_super);\n}\n\nstatic void set_features(struct btrfs_fs_info *fs_info,\n\t\t\t enum btrfs_feature_set set, u64 features)\n{\n\tstruct btrfs_super_block *disk_super = fs_info->super_copy;\n\tif (set == FEAT_COMPAT)\n\t\tbtrfs_set_super_compat_flags(disk_super, features);\n\telse if (set == FEAT_COMPAT_RO)\n\t\tbtrfs_set_super_compat_ro_flags(disk_super, features);\n\telse\n\t\tbtrfs_set_super_incompat_flags(disk_super, features);\n}\n\nstatic int can_modify_feature(struct btrfs_feature_attr *fa)\n{\n\tint val = 0;\n\tu64 set, clear;\n\tswitch (fa->feature_set) {\n\tcase FEAT_COMPAT:\n\t\tset = BTRFS_FEATURE_COMPAT_SAFE_SET;\n\t\tclear = BTRFS_FEATURE_COMPAT_SAFE_CLEAR;\n\t\tbreak;\n\tcase FEAT_COMPAT_RO:\n\t\tset = BTRFS_FEATURE_COMPAT_RO_SAFE_SET;\n\t\tclear = BTRFS_FEATURE_COMPAT_RO_SAFE_CLEAR;\n\t\tbreak;\n\tcase FEAT_INCOMPAT:\n\t\tset = BTRFS_FEATURE_INCOMPAT_SAFE_SET;\n\t\tclear = BTRFS_FEATURE_INCOMPAT_SAFE_CLEAR;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"btrfs: sysfs: unknown feature set %d\\n\",\n\t\t\t\tfa->feature_set);\n\t\treturn 0;\n\t}\n\n\tif (set & fa->feature_bit)\n\t\tval |= 1;\n\tif (clear & fa->feature_bit)\n\t\tval |= 2;\n\n\treturn val;\n}\n\nstatic ssize_t btrfs_feature_attr_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *a, char *buf)\n{\n\tint val = 0;\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj);\n\tstruct btrfs_feature_attr *fa = to_btrfs_feature_attr(a);\n\tif (fs_info) {\n\t\tu64 features = get_features(fs_info, fa->feature_set);\n\t\tif (features & fa->feature_bit)\n\t\t\tval = 1;\n\t} else\n\t\tval = can_modify_feature(fa);\n\n\treturn sysfs_emit(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t btrfs_feature_attr_store(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *a,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_feature_attr *fa = to_btrfs_feature_attr(a);\n\tu64 features, set, clear;\n\tunsigned long val;\n\tint ret;\n\n\tfs_info = to_fs_info(kobj);\n\tif (!fs_info)\n\t\treturn -EPERM;\n\n\tif (sb_rdonly(fs_info->sb))\n\t\treturn -EROFS;\n\n\tret = kstrtoul(skip_spaces(buf), 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fa->feature_set == FEAT_COMPAT) {\n\t\tset = BTRFS_FEATURE_COMPAT_SAFE_SET;\n\t\tclear = BTRFS_FEATURE_COMPAT_SAFE_CLEAR;\n\t} else if (fa->feature_set == FEAT_COMPAT_RO) {\n\t\tset = BTRFS_FEATURE_COMPAT_RO_SAFE_SET;\n\t\tclear = BTRFS_FEATURE_COMPAT_RO_SAFE_CLEAR;\n\t} else {\n\t\tset = BTRFS_FEATURE_INCOMPAT_SAFE_SET;\n\t\tclear = BTRFS_FEATURE_INCOMPAT_SAFE_CLEAR;\n\t}\n\n\tfeatures = get_features(fs_info, fa->feature_set);\n\n\t \n\tif ((val && (features & fa->feature_bit)) ||\n\t    (!val && !(features & fa->feature_bit)))\n\t\treturn count;\n\n\tif ((val && !(set & fa->feature_bit)) ||\n\t    (!val && !(clear & fa->feature_bit))) {\n\t\tbtrfs_info(fs_info,\n\t\t\t\"%sabling feature %s on mounted fs is not supported.\",\n\t\t\tval ? \"En\" : \"Dis\", fa->kobj_attr.attr.name);\n\t\treturn -EPERM;\n\t}\n\n\tbtrfs_info(fs_info, \"%s %s feature flag\",\n\t\t   val ? \"Setting\" : \"Clearing\", fa->kobj_attr.attr.name);\n\n\tspin_lock(&fs_info->super_lock);\n\tfeatures = get_features(fs_info, fa->feature_set);\n\tif (val)\n\t\tfeatures |= fa->feature_bit;\n\telse\n\t\tfeatures &= ~fa->feature_bit;\n\tset_features(fs_info, fa->feature_set, features);\n\tspin_unlock(&fs_info->super_lock);\n\n\t \n\tset_bit(BTRFS_FS_NEED_TRANS_COMMIT, &fs_info->flags);\n\twake_up_process(fs_info->transaction_kthread);\n\n\treturn count;\n}\n\nstatic umode_t btrfs_feature_visible(struct kobject *kobj,\n\t\t\t\t     struct attribute *attr, int unused)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj);\n\tumode_t mode = attr->mode;\n\n\tif (fs_info) {\n\t\tstruct btrfs_feature_attr *fa;\n\t\tu64 features;\n\n\t\tfa = attr_to_btrfs_feature_attr(attr);\n\t\tfeatures = get_features(fs_info, fa->feature_set);\n\n\t\tif (can_modify_feature(fa))\n\t\t\tmode |= S_IWUSR;\n\t\telse if (!(features & fa->feature_bit))\n\t\t\tmode = 0;\n\t}\n\n\treturn mode;\n}\n\nBTRFS_FEAT_ATTR_INCOMPAT(default_subvol, DEFAULT_SUBVOL);\nBTRFS_FEAT_ATTR_INCOMPAT(mixed_groups, MIXED_GROUPS);\nBTRFS_FEAT_ATTR_INCOMPAT(compress_lzo, COMPRESS_LZO);\nBTRFS_FEAT_ATTR_INCOMPAT(compress_zstd, COMPRESS_ZSTD);\nBTRFS_FEAT_ATTR_INCOMPAT(extended_iref, EXTENDED_IREF);\nBTRFS_FEAT_ATTR_INCOMPAT(raid56, RAID56);\nBTRFS_FEAT_ATTR_INCOMPAT(skinny_metadata, SKINNY_METADATA);\nBTRFS_FEAT_ATTR_INCOMPAT(no_holes, NO_HOLES);\nBTRFS_FEAT_ATTR_INCOMPAT(metadata_uuid, METADATA_UUID);\nBTRFS_FEAT_ATTR_COMPAT_RO(free_space_tree, FREE_SPACE_TREE);\nBTRFS_FEAT_ATTR_COMPAT_RO(block_group_tree, BLOCK_GROUP_TREE);\nBTRFS_FEAT_ATTR_INCOMPAT(raid1c34, RAID1C34);\n#ifdef CONFIG_BLK_DEV_ZONED\nBTRFS_FEAT_ATTR_INCOMPAT(zoned, ZONED);\n#endif\n#ifdef CONFIG_BTRFS_DEBUG\n \nBTRFS_FEAT_ATTR_INCOMPAT(extent_tree_v2, EXTENT_TREE_V2);\n#endif\n#ifdef CONFIG_FS_VERITY\nBTRFS_FEAT_ATTR_COMPAT_RO(verity, VERITY);\n#endif\n\n \nstatic struct attribute *btrfs_supported_feature_attrs[] = {\n\tBTRFS_FEAT_ATTR_PTR(default_subvol),\n\tBTRFS_FEAT_ATTR_PTR(mixed_groups),\n\tBTRFS_FEAT_ATTR_PTR(compress_lzo),\n\tBTRFS_FEAT_ATTR_PTR(compress_zstd),\n\tBTRFS_FEAT_ATTR_PTR(extended_iref),\n\tBTRFS_FEAT_ATTR_PTR(raid56),\n\tBTRFS_FEAT_ATTR_PTR(skinny_metadata),\n\tBTRFS_FEAT_ATTR_PTR(no_holes),\n\tBTRFS_FEAT_ATTR_PTR(metadata_uuid),\n\tBTRFS_FEAT_ATTR_PTR(free_space_tree),\n\tBTRFS_FEAT_ATTR_PTR(raid1c34),\n\tBTRFS_FEAT_ATTR_PTR(block_group_tree),\n#ifdef CONFIG_BLK_DEV_ZONED\n\tBTRFS_FEAT_ATTR_PTR(zoned),\n#endif\n#ifdef CONFIG_BTRFS_DEBUG\n\tBTRFS_FEAT_ATTR_PTR(extent_tree_v2),\n#endif\n#ifdef CONFIG_FS_VERITY\n\tBTRFS_FEAT_ATTR_PTR(verity),\n#endif\n\tNULL\n};\n\nstatic const struct attribute_group btrfs_feature_attr_group = {\n\t.name = \"features\",\n\t.is_visible = btrfs_feature_visible,\n\t.attrs = btrfs_supported_feature_attrs,\n};\n\nstatic ssize_t rmdir_subvol_show(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *ka, char *buf)\n{\n\treturn sysfs_emit(buf, \"0\\n\");\n}\nBTRFS_ATTR(static_feature, rmdir_subvol, rmdir_subvol_show);\n\nstatic ssize_t supported_checksums_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *a, char *buf)\n{\n\tssize_t ret = 0;\n\tint i;\n\n\tfor (i = 0; i < btrfs_get_num_csums(); i++) {\n\t\t \n\t\tret += sysfs_emit_at(buf, ret, \"%s%s\", (i == 0 ? \"\" : \" \"),\n\t\t\t\t     btrfs_super_csum_name(i));\n\n\t}\n\n\tret += sysfs_emit_at(buf, ret, \"\\n\");\n\treturn ret;\n}\nBTRFS_ATTR(static_feature, supported_checksums, supported_checksums_show);\n\nstatic ssize_t send_stream_version_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *ka, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", BTRFS_SEND_STREAM_VERSION);\n}\nBTRFS_ATTR(static_feature, send_stream_version, send_stream_version_show);\n\nstatic const char *rescue_opts[] = {\n\t\"usebackuproot\",\n\t\"nologreplay\",\n\t\"ignorebadroots\",\n\t\"ignoredatacsums\",\n\t\"all\",\n};\n\nstatic ssize_t supported_rescue_options_show(struct kobject *kobj,\n\t\t\t\t\t     struct kobj_attribute *a,\n\t\t\t\t\t     char *buf)\n{\n\tssize_t ret = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rescue_opts); i++)\n\t\tret += sysfs_emit_at(buf, ret, \"%s%s\", (i ? \" \" : \"\"), rescue_opts[i]);\n\tret += sysfs_emit_at(buf, ret, \"\\n\");\n\treturn ret;\n}\nBTRFS_ATTR(static_feature, supported_rescue_options,\n\t   supported_rescue_options_show);\n\nstatic ssize_t supported_sectorsizes_show(struct kobject *kobj,\n\t\t\t\t\t  struct kobj_attribute *a,\n\t\t\t\t\t  char *buf)\n{\n\tssize_t ret = 0;\n\n\t \n\tif (PAGE_SIZE > SZ_4K)\n\t\tret += sysfs_emit_at(buf, ret, \"%u \", SZ_4K);\n\tret += sysfs_emit_at(buf, ret, \"%lu\\n\", PAGE_SIZE);\n\n\treturn ret;\n}\nBTRFS_ATTR(static_feature, supported_sectorsizes,\n\t   supported_sectorsizes_show);\n\nstatic ssize_t acl_show(struct kobject *kobj, struct kobj_attribute *a, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", !!IS_ENABLED(CONFIG_BTRFS_FS_POSIX_ACL));\n}\nBTRFS_ATTR(static_feature, acl, acl_show);\n\n \nstatic struct attribute *btrfs_supported_static_feature_attrs[] = {\n\tBTRFS_ATTR_PTR(static_feature, acl),\n\tBTRFS_ATTR_PTR(static_feature, rmdir_subvol),\n\tBTRFS_ATTR_PTR(static_feature, supported_checksums),\n\tBTRFS_ATTR_PTR(static_feature, send_stream_version),\n\tBTRFS_ATTR_PTR(static_feature, supported_rescue_options),\n\tBTRFS_ATTR_PTR(static_feature, supported_sectorsizes),\n\tNULL\n};\n\nstatic const struct attribute_group btrfs_static_feature_attr_group = {\n\t.name = \"features\",\n\t.attrs = btrfs_supported_static_feature_attrs,\n};\n\n \n#define discard_to_fs_info(_kobj)\tto_fs_info(get_btrfs_kobj(_kobj))\n\nstatic ssize_t btrfs_discardable_bytes_show(struct kobject *kobj,\n\t\t\t\t\t    struct kobj_attribute *a,\n\t\t\t\t\t    char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = discard_to_fs_info(kobj);\n\n\treturn sysfs_emit(buf, \"%lld\\n\",\n\t\t\tatomic64_read(&fs_info->discard_ctl.discardable_bytes));\n}\nBTRFS_ATTR(discard, discardable_bytes, btrfs_discardable_bytes_show);\n\nstatic ssize_t btrfs_discardable_extents_show(struct kobject *kobj,\n\t\t\t\t\t      struct kobj_attribute *a,\n\t\t\t\t\t      char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = discard_to_fs_info(kobj);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\tatomic_read(&fs_info->discard_ctl.discardable_extents));\n}\nBTRFS_ATTR(discard, discardable_extents, btrfs_discardable_extents_show);\n\nstatic ssize_t btrfs_discard_bitmap_bytes_show(struct kobject *kobj,\n\t\t\t\t\t       struct kobj_attribute *a,\n\t\t\t\t\t       char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = discard_to_fs_info(kobj);\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t  fs_info->discard_ctl.discard_bitmap_bytes);\n}\nBTRFS_ATTR(discard, discard_bitmap_bytes, btrfs_discard_bitmap_bytes_show);\n\nstatic ssize_t btrfs_discard_bytes_saved_show(struct kobject *kobj,\n\t\t\t\t\t      struct kobj_attribute *a,\n\t\t\t\t\t      char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = discard_to_fs_info(kobj);\n\n\treturn sysfs_emit(buf, \"%lld\\n\",\n\t\tatomic64_read(&fs_info->discard_ctl.discard_bytes_saved));\n}\nBTRFS_ATTR(discard, discard_bytes_saved, btrfs_discard_bytes_saved_show);\n\nstatic ssize_t btrfs_discard_extent_bytes_show(struct kobject *kobj,\n\t\t\t\t\t       struct kobj_attribute *a,\n\t\t\t\t\t       char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = discard_to_fs_info(kobj);\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t  fs_info->discard_ctl.discard_extent_bytes);\n}\nBTRFS_ATTR(discard, discard_extent_bytes, btrfs_discard_extent_bytes_show);\n\nstatic ssize_t btrfs_discard_iops_limit_show(struct kobject *kobj,\n\t\t\t\t\t     struct kobj_attribute *a,\n\t\t\t\t\t     char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = discard_to_fs_info(kobj);\n\n\treturn sysfs_emit(buf, \"%u\\n\",\n\t\t\t  READ_ONCE(fs_info->discard_ctl.iops_limit));\n}\n\nstatic ssize_t btrfs_discard_iops_limit_store(struct kobject *kobj,\n\t\t\t\t\t      struct kobj_attribute *a,\n\t\t\t\t\t      const char *buf, size_t len)\n{\n\tstruct btrfs_fs_info *fs_info = discard_to_fs_info(kobj);\n\tstruct btrfs_discard_ctl *discard_ctl = &fs_info->discard_ctl;\n\tu32 iops_limit;\n\tint ret;\n\n\tret = kstrtou32(buf, 10, &iops_limit);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tWRITE_ONCE(discard_ctl->iops_limit, iops_limit);\n\tbtrfs_discard_calc_delay(discard_ctl);\n\tbtrfs_discard_schedule_work(discard_ctl, true);\n\treturn len;\n}\nBTRFS_ATTR_RW(discard, iops_limit, btrfs_discard_iops_limit_show,\n\t      btrfs_discard_iops_limit_store);\n\nstatic ssize_t btrfs_discard_kbps_limit_show(struct kobject *kobj,\n\t\t\t\t\t     struct kobj_attribute *a,\n\t\t\t\t\t     char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = discard_to_fs_info(kobj);\n\n\treturn sysfs_emit(buf, \"%u\\n\",\n\t\t\t  READ_ONCE(fs_info->discard_ctl.kbps_limit));\n}\n\nstatic ssize_t btrfs_discard_kbps_limit_store(struct kobject *kobj,\n\t\t\t\t\t      struct kobj_attribute *a,\n\t\t\t\t\t      const char *buf, size_t len)\n{\n\tstruct btrfs_fs_info *fs_info = discard_to_fs_info(kobj);\n\tstruct btrfs_discard_ctl *discard_ctl = &fs_info->discard_ctl;\n\tu32 kbps_limit;\n\tint ret;\n\n\tret = kstrtou32(buf, 10, &kbps_limit);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tWRITE_ONCE(discard_ctl->kbps_limit, kbps_limit);\n\tbtrfs_discard_schedule_work(discard_ctl, true);\n\treturn len;\n}\nBTRFS_ATTR_RW(discard, kbps_limit, btrfs_discard_kbps_limit_show,\n\t      btrfs_discard_kbps_limit_store);\n\nstatic ssize_t btrfs_discard_max_discard_size_show(struct kobject *kobj,\n\t\t\t\t\t\t   struct kobj_attribute *a,\n\t\t\t\t\t\t   char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = discard_to_fs_info(kobj);\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t  READ_ONCE(fs_info->discard_ctl.max_discard_size));\n}\n\nstatic ssize_t btrfs_discard_max_discard_size_store(struct kobject *kobj,\n\t\t\t\t\t\t    struct kobj_attribute *a,\n\t\t\t\t\t\t    const char *buf, size_t len)\n{\n\tstruct btrfs_fs_info *fs_info = discard_to_fs_info(kobj);\n\tstruct btrfs_discard_ctl *discard_ctl = &fs_info->discard_ctl;\n\tu64 max_discard_size;\n\tint ret;\n\n\tret = kstrtou64(buf, 10, &max_discard_size);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tWRITE_ONCE(discard_ctl->max_discard_size, max_discard_size);\n\n\treturn len;\n}\nBTRFS_ATTR_RW(discard, max_discard_size, btrfs_discard_max_discard_size_show,\n\t      btrfs_discard_max_discard_size_store);\n\n \nstatic const struct attribute *discard_attrs[] = {\n\tBTRFS_ATTR_PTR(discard, discardable_bytes),\n\tBTRFS_ATTR_PTR(discard, discardable_extents),\n\tBTRFS_ATTR_PTR(discard, discard_bitmap_bytes),\n\tBTRFS_ATTR_PTR(discard, discard_bytes_saved),\n\tBTRFS_ATTR_PTR(discard, discard_extent_bytes),\n\tBTRFS_ATTR_PTR(discard, iops_limit),\n\tBTRFS_ATTR_PTR(discard, kbps_limit),\n\tBTRFS_ATTR_PTR(discard, max_discard_size),\n\tNULL,\n};\n\n#ifdef CONFIG_BTRFS_DEBUG\n\n \nstatic const struct attribute *btrfs_debug_mount_attrs[] = {\n\tNULL,\n};\n\n \nstatic struct attribute *btrfs_debug_feature_attrs[] = {\n\tNULL\n};\n\nstatic const struct attribute_group btrfs_debug_feature_attr_group = {\n\t.name = \"debug\",\n\t.attrs = btrfs_debug_feature_attrs,\n};\n\n#endif\n\nstatic ssize_t btrfs_show_u64(u64 *value_ptr, spinlock_t *lock, char *buf)\n{\n\tu64 val;\n\tif (lock)\n\t\tspin_lock(lock);\n\tval = *value_ptr;\n\tif (lock)\n\t\tspin_unlock(lock);\n\treturn sysfs_emit(buf, \"%llu\\n\", val);\n}\n\nstatic ssize_t global_rsv_size_show(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *ka, char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj->parent);\n\tstruct btrfs_block_rsv *block_rsv = &fs_info->global_block_rsv;\n\treturn btrfs_show_u64(&block_rsv->size, &block_rsv->lock, buf);\n}\nBTRFS_ATTR(allocation, global_rsv_size, global_rsv_size_show);\n\nstatic ssize_t global_rsv_reserved_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *a, char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj->parent);\n\tstruct btrfs_block_rsv *block_rsv = &fs_info->global_block_rsv;\n\treturn btrfs_show_u64(&block_rsv->reserved, &block_rsv->lock, buf);\n}\nBTRFS_ATTR(allocation, global_rsv_reserved, global_rsv_reserved_show);\n\n#define to_space_info(_kobj) container_of(_kobj, struct btrfs_space_info, kobj)\n#define to_raid_kobj(_kobj) container_of(_kobj, struct raid_kobject, kobj)\n\nstatic ssize_t raid_bytes_show(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr, char *buf);\nBTRFS_ATTR(raid, total_bytes, raid_bytes_show);\nBTRFS_ATTR(raid, used_bytes, raid_bytes_show);\n\nstatic ssize_t raid_bytes_show(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr, char *buf)\n\n{\n\tstruct btrfs_space_info *sinfo = to_space_info(kobj->parent);\n\tstruct btrfs_block_group *block_group;\n\tint index = btrfs_bg_flags_to_raid_index(to_raid_kobj(kobj)->flags);\n\tu64 val = 0;\n\n\tdown_read(&sinfo->groups_sem);\n\tlist_for_each_entry(block_group, &sinfo->block_groups[index], list) {\n\t\tif (&attr->attr == BTRFS_ATTR_PTR(raid, total_bytes))\n\t\t\tval += block_group->length;\n\t\telse\n\t\t\tval += block_group->used;\n\t}\n\tup_read(&sinfo->groups_sem);\n\treturn sysfs_emit(buf, \"%llu\\n\", val);\n}\n\n \nstatic struct attribute *raid_attrs[] = {\n\tBTRFS_ATTR_PTR(raid, total_bytes),\n\tBTRFS_ATTR_PTR(raid, used_bytes),\n\tNULL\n};\nATTRIBUTE_GROUPS(raid);\n\nstatic void release_raid_kobj(struct kobject *kobj)\n{\n\tkfree(to_raid_kobj(kobj));\n}\n\nstatic const struct kobj_type btrfs_raid_ktype = {\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.release = release_raid_kobj,\n\t.default_groups = raid_groups,\n};\n\n#define SPACE_INFO_ATTR(field)\t\t\t\t\t\t\\\nstatic ssize_t btrfs_space_info_show_##field(struct kobject *kobj,\t\\\n\t\t\t\t\t     struct kobj_attribute *a,\t\\\n\t\t\t\t\t     char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct btrfs_space_info *sinfo = to_space_info(kobj);\t\t\\\n\treturn btrfs_show_u64(&sinfo->field, &sinfo->lock, buf);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nBTRFS_ATTR(space_info, field, btrfs_space_info_show_##field)\n\nstatic ssize_t btrfs_chunk_size_show(struct kobject *kobj,\n\t\t\t\t     struct kobj_attribute *a, char *buf)\n{\n\tstruct btrfs_space_info *sinfo = to_space_info(kobj);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", READ_ONCE(sinfo->chunk_size));\n}\n\n \nstatic ssize_t btrfs_chunk_size_store(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *a,\n\t\t\t\t      const char *buf, size_t len)\n{\n\tstruct btrfs_space_info *space_info = to_space_info(kobj);\n\tstruct btrfs_fs_info *fs_info = to_fs_info(get_btrfs_kobj(kobj));\n\tchar *retptr;\n\tu64 val;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!fs_info->fs_devices)\n\t\treturn -EINVAL;\n\n\tif (btrfs_is_zoned(fs_info))\n\t\treturn -EINVAL;\n\n\t \n\tif (space_info->flags & BTRFS_BLOCK_GROUP_SYSTEM)\n\t\treturn -EPERM;\n\n\tval = memparse(buf, &retptr);\n\t \n\tretptr = skip_spaces(retptr);\n\tif (*retptr != 0 || val == 0)\n\t\treturn -EINVAL;\n\n\tval = min(val, BTRFS_MAX_DATA_CHUNK_SIZE);\n\n\t \n\tval = min(mult_perc(fs_info->fs_devices->total_rw_bytes, 10), val);\n\n\t \n\tval &= ~((u64)SZ_256M - 1);\n\n\t \n\tif (val < SZ_256M)\n\t\treturn -EINVAL;\n\n\tbtrfs_update_space_info_chunk_size(space_info, val);\n\n\treturn len;\n}\n\nstatic ssize_t btrfs_size_classes_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *a, char *buf)\n{\n\tstruct btrfs_space_info *sinfo = to_space_info(kobj);\n\tstruct btrfs_block_group *bg;\n\tu32 none = 0;\n\tu32 small = 0;\n\tu32 medium = 0;\n\tu32 large = 0;\n\n\tfor (int i = 0; i < BTRFS_NR_RAID_TYPES; ++i) {\n\t\tdown_read(&sinfo->groups_sem);\n\t\tlist_for_each_entry(bg, &sinfo->block_groups[i], list) {\n\t\t\tif (!btrfs_block_group_should_use_size_class(bg))\n\t\t\t\tcontinue;\n\t\t\tswitch (bg->size_class) {\n\t\t\tcase BTRFS_BG_SZ_NONE:\n\t\t\t\tnone++;\n\t\t\t\tbreak;\n\t\t\tcase BTRFS_BG_SZ_SMALL:\n\t\t\t\tsmall++;\n\t\t\t\tbreak;\n\t\t\tcase BTRFS_BG_SZ_MEDIUM:\n\t\t\t\tmedium++;\n\t\t\t\tbreak;\n\t\t\tcase BTRFS_BG_SZ_LARGE:\n\t\t\t\tlarge++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tup_read(&sinfo->groups_sem);\n\t}\n\treturn sysfs_emit(buf, \"none %u\\n\"\n\t\t\t       \"small %u\\n\"\n\t\t\t       \"medium %u\\n\"\n\t\t\t       \"large %u\\n\",\n\t\t\t       none, small, medium, large);\n}\n\n#ifdef CONFIG_BTRFS_DEBUG\n \nstatic ssize_t btrfs_force_chunk_alloc_store(struct kobject *kobj,\n\t\t\t\t\t     struct kobj_attribute *a,\n\t\t\t\t\t     const char *buf, size_t len)\n{\n\tstruct btrfs_space_info *space_info = to_space_info(kobj);\n\tstruct btrfs_fs_info *fs_info = to_fs_info(get_btrfs_kobj(kobj));\n\tstruct btrfs_trans_handle *trans;\n\tbool val;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (sb_rdonly(fs_info->sb))\n\t\treturn -EROFS;\n\n\tret = kstrtobool(buf, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\t \n\ttrans = btrfs_start_transaction(fs_info->tree_root, 0);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\tret = btrfs_force_chunk_alloc(trans, space_info->flags);\n\tbtrfs_end_transaction(trans);\n\n\tif (ret == 1)\n\t\treturn len;\n\n\treturn -ENOSPC;\n}\nBTRFS_ATTR_W(space_info, force_chunk_alloc, btrfs_force_chunk_alloc_store);\n\n#endif\n\nSPACE_INFO_ATTR(flags);\nSPACE_INFO_ATTR(total_bytes);\nSPACE_INFO_ATTR(bytes_used);\nSPACE_INFO_ATTR(bytes_pinned);\nSPACE_INFO_ATTR(bytes_reserved);\nSPACE_INFO_ATTR(bytes_may_use);\nSPACE_INFO_ATTR(bytes_readonly);\nSPACE_INFO_ATTR(bytes_zone_unusable);\nSPACE_INFO_ATTR(disk_used);\nSPACE_INFO_ATTR(disk_total);\nBTRFS_ATTR_RW(space_info, chunk_size, btrfs_chunk_size_show, btrfs_chunk_size_store);\nBTRFS_ATTR(space_info, size_classes, btrfs_size_classes_show);\n\nstatic ssize_t btrfs_sinfo_bg_reclaim_threshold_show(struct kobject *kobj,\n\t\t\t\t\t\t     struct kobj_attribute *a,\n\t\t\t\t\t\t     char *buf)\n{\n\tstruct btrfs_space_info *space_info = to_space_info(kobj);\n\n\treturn sysfs_emit(buf, \"%d\\n\", READ_ONCE(space_info->bg_reclaim_threshold));\n}\n\nstatic ssize_t btrfs_sinfo_bg_reclaim_threshold_store(struct kobject *kobj,\n\t\t\t\t\t\t      struct kobj_attribute *a,\n\t\t\t\t\t\t      const char *buf, size_t len)\n{\n\tstruct btrfs_space_info *space_info = to_space_info(kobj);\n\tint thresh;\n\tint ret;\n\n\tret = kstrtoint(buf, 10, &thresh);\n\tif (ret)\n\t\treturn ret;\n\n\tif (thresh < 0 || thresh > 100)\n\t\treturn -EINVAL;\n\n\tWRITE_ONCE(space_info->bg_reclaim_threshold, thresh);\n\n\treturn len;\n}\n\nBTRFS_ATTR_RW(space_info, bg_reclaim_threshold,\n\t      btrfs_sinfo_bg_reclaim_threshold_show,\n\t      btrfs_sinfo_bg_reclaim_threshold_store);\n\n \nstatic struct attribute *space_info_attrs[] = {\n\tBTRFS_ATTR_PTR(space_info, flags),\n\tBTRFS_ATTR_PTR(space_info, total_bytes),\n\tBTRFS_ATTR_PTR(space_info, bytes_used),\n\tBTRFS_ATTR_PTR(space_info, bytes_pinned),\n\tBTRFS_ATTR_PTR(space_info, bytes_reserved),\n\tBTRFS_ATTR_PTR(space_info, bytes_may_use),\n\tBTRFS_ATTR_PTR(space_info, bytes_readonly),\n\tBTRFS_ATTR_PTR(space_info, bytes_zone_unusable),\n\tBTRFS_ATTR_PTR(space_info, disk_used),\n\tBTRFS_ATTR_PTR(space_info, disk_total),\n\tBTRFS_ATTR_PTR(space_info, bg_reclaim_threshold),\n\tBTRFS_ATTR_PTR(space_info, chunk_size),\n\tBTRFS_ATTR_PTR(space_info, size_classes),\n#ifdef CONFIG_BTRFS_DEBUG\n\tBTRFS_ATTR_PTR(space_info, force_chunk_alloc),\n#endif\n\tNULL,\n};\nATTRIBUTE_GROUPS(space_info);\n\nstatic void space_info_release(struct kobject *kobj)\n{\n\tstruct btrfs_space_info *sinfo = to_space_info(kobj);\n\tkfree(sinfo);\n}\n\nstatic const struct kobj_type space_info_ktype = {\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.release = space_info_release,\n\t.default_groups = space_info_groups,\n};\n\n \nstatic const struct attribute *allocation_attrs[] = {\n\tBTRFS_ATTR_PTR(allocation, global_rsv_reserved),\n\tBTRFS_ATTR_PTR(allocation, global_rsv_size),\n\tNULL,\n};\n\nstatic ssize_t btrfs_label_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *a, char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj);\n\tchar *label = fs_info->super_copy->label;\n\tssize_t ret;\n\n\tspin_lock(&fs_info->super_lock);\n\tret = sysfs_emit(buf, label[0] ? \"%s\\n\" : \"%s\", label);\n\tspin_unlock(&fs_info->super_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t btrfs_label_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *a,\n\t\t\t\t const char *buf, size_t len)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj);\n\tsize_t p_len;\n\n\tif (!fs_info)\n\t\treturn -EPERM;\n\n\tif (sb_rdonly(fs_info->sb))\n\t\treturn -EROFS;\n\n\t \n\tp_len = strcspn(buf, \"\\n\");\n\n\tif (p_len >= BTRFS_LABEL_SIZE)\n\t\treturn -EINVAL;\n\n\tspin_lock(&fs_info->super_lock);\n\tmemset(fs_info->super_copy->label, 0, BTRFS_LABEL_SIZE);\n\tmemcpy(fs_info->super_copy->label, buf, p_len);\n\tspin_unlock(&fs_info->super_lock);\n\n\t \n\tset_bit(BTRFS_FS_NEED_TRANS_COMMIT, &fs_info->flags);\n\twake_up_process(fs_info->transaction_kthread);\n\n\treturn len;\n}\nBTRFS_ATTR_RW(, label, btrfs_label_show, btrfs_label_store);\n\nstatic ssize_t btrfs_nodesize_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *a, char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj);\n\n\treturn sysfs_emit(buf, \"%u\\n\", fs_info->super_copy->nodesize);\n}\n\nBTRFS_ATTR(, nodesize, btrfs_nodesize_show);\n\nstatic ssize_t btrfs_sectorsize_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *a, char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj);\n\n\treturn sysfs_emit(buf, \"%u\\n\", fs_info->super_copy->sectorsize);\n}\n\nBTRFS_ATTR(, sectorsize, btrfs_sectorsize_show);\n\nstatic ssize_t btrfs_commit_stats_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *a, char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj);\n\n\treturn sysfs_emit(buf,\n\t\t\"commits %llu\\n\"\n\t\t\"last_commit_ms %llu\\n\"\n\t\t\"max_commit_ms %llu\\n\"\n\t\t\"total_commit_ms %llu\\n\",\n\t\tfs_info->commit_stats.commit_count,\n\t\tdiv_u64(fs_info->commit_stats.last_commit_dur, NSEC_PER_MSEC),\n\t\tdiv_u64(fs_info->commit_stats.max_commit_dur, NSEC_PER_MSEC),\n\t\tdiv_u64(fs_info->commit_stats.total_commit_dur, NSEC_PER_MSEC));\n}\n\nstatic ssize_t btrfs_commit_stats_store(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *a,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj);\n\tunsigned long val;\n\tint ret;\n\n\tif (!fs_info)\n\t\treturn -EPERM;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val)\n\t\treturn -EINVAL;\n\n\tWRITE_ONCE(fs_info->commit_stats.max_commit_dur, 0);\n\n\treturn len;\n}\nBTRFS_ATTR_RW(, commit_stats, btrfs_commit_stats_show, btrfs_commit_stats_store);\n\nstatic ssize_t btrfs_clone_alignment_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *a, char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj);\n\n\treturn sysfs_emit(buf, \"%u\\n\", fs_info->super_copy->sectorsize);\n}\n\nBTRFS_ATTR(, clone_alignment, btrfs_clone_alignment_show);\n\nstatic ssize_t quota_override_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *a, char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj);\n\tint quota_override;\n\n\tquota_override = test_bit(BTRFS_FS_QUOTA_OVERRIDE, &fs_info->flags);\n\treturn sysfs_emit(buf, \"%d\\n\", quota_override);\n}\n\nstatic ssize_t quota_override_store(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *a,\n\t\t\t\t    const char *buf, size_t len)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj);\n\tunsigned long knob;\n\tint err;\n\n\tif (!fs_info)\n\t\treturn -EPERM;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\terr = kstrtoul(buf, 10, &knob);\n\tif (err)\n\t\treturn err;\n\tif (knob > 1)\n\t\treturn -EINVAL;\n\n\tif (knob)\n\t\tset_bit(BTRFS_FS_QUOTA_OVERRIDE, &fs_info->flags);\n\telse\n\t\tclear_bit(BTRFS_FS_QUOTA_OVERRIDE, &fs_info->flags);\n\n\treturn len;\n}\n\nBTRFS_ATTR_RW(, quota_override, quota_override_show, quota_override_store);\n\nstatic ssize_t btrfs_metadata_uuid_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *a, char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj);\n\n\treturn sysfs_emit(buf, \"%pU\\n\", fs_info->fs_devices->metadata_uuid);\n}\n\nBTRFS_ATTR(, metadata_uuid, btrfs_metadata_uuid_show);\n\nstatic ssize_t btrfs_checksum_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *a, char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj);\n\tu16 csum_type = btrfs_super_csum_type(fs_info->super_copy);\n\n\treturn sysfs_emit(buf, \"%s (%s)\\n\",\n\t\t\t  btrfs_super_csum_name(csum_type),\n\t\t\t  crypto_shash_driver_name(fs_info->csum_shash));\n}\n\nBTRFS_ATTR(, checksum, btrfs_checksum_show);\n\nstatic ssize_t btrfs_exclusive_operation_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *a, char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj);\n\tconst char *str;\n\n\tswitch (READ_ONCE(fs_info->exclusive_operation)) {\n\t\tcase  BTRFS_EXCLOP_NONE:\n\t\t\tstr = \"none\\n\";\n\t\t\tbreak;\n\t\tcase BTRFS_EXCLOP_BALANCE:\n\t\t\tstr = \"balance\\n\";\n\t\t\tbreak;\n\t\tcase BTRFS_EXCLOP_BALANCE_PAUSED:\n\t\t\tstr = \"balance paused\\n\";\n\t\t\tbreak;\n\t\tcase BTRFS_EXCLOP_DEV_ADD:\n\t\t\tstr = \"device add\\n\";\n\t\t\tbreak;\n\t\tcase BTRFS_EXCLOP_DEV_REMOVE:\n\t\t\tstr = \"device remove\\n\";\n\t\t\tbreak;\n\t\tcase BTRFS_EXCLOP_DEV_REPLACE:\n\t\t\tstr = \"device replace\\n\";\n\t\t\tbreak;\n\t\tcase BTRFS_EXCLOP_RESIZE:\n\t\t\tstr = \"resize\\n\";\n\t\t\tbreak;\n\t\tcase BTRFS_EXCLOP_SWAP_ACTIVATE:\n\t\t\tstr = \"swap activate\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstr = \"UNKNOWN\\n\";\n\t\t\tbreak;\n\t}\n\treturn sysfs_emit(buf, \"%s\", str);\n}\nBTRFS_ATTR(, exclusive_operation, btrfs_exclusive_operation_show);\n\nstatic ssize_t btrfs_generation_show(struct kobject *kobj,\n\t\t\t\t     struct kobj_attribute *a, char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", fs_info->generation);\n}\nBTRFS_ATTR(, generation, btrfs_generation_show);\n\nstatic const char * const btrfs_read_policy_name[] = { \"pid\" };\n\nstatic ssize_t btrfs_read_policy_show(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *a, char *buf)\n{\n\tstruct btrfs_fs_devices *fs_devices = to_fs_devs(kobj);\n\tssize_t ret = 0;\n\tint i;\n\n\tfor (i = 0; i < BTRFS_NR_READ_POLICY; i++) {\n\t\tif (fs_devices->read_policy == i)\n\t\t\tret += sysfs_emit_at(buf, ret, \"%s[%s]\",\n\t\t\t\t\t (ret == 0 ? \"\" : \" \"),\n\t\t\t\t\t btrfs_read_policy_name[i]);\n\t\telse\n\t\t\tret += sysfs_emit_at(buf, ret, \"%s%s\",\n\t\t\t\t\t (ret == 0 ? \"\" : \" \"),\n\t\t\t\t\t btrfs_read_policy_name[i]);\n\t}\n\n\tret += sysfs_emit_at(buf, ret, \"\\n\");\n\n\treturn ret;\n}\n\nstatic ssize_t btrfs_read_policy_store(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *a,\n\t\t\t\t       const char *buf, size_t len)\n{\n\tstruct btrfs_fs_devices *fs_devices = to_fs_devs(kobj);\n\tint i;\n\n\tfor (i = 0; i < BTRFS_NR_READ_POLICY; i++) {\n\t\tif (sysfs_streq(buf, btrfs_read_policy_name[i])) {\n\t\t\tif (i != fs_devices->read_policy) {\n\t\t\t\tfs_devices->read_policy = i;\n\t\t\t\tbtrfs_info(fs_devices->fs_info,\n\t\t\t\t\t   \"read policy set to '%s'\",\n\t\t\t\t\t   btrfs_read_policy_name[i]);\n\t\t\t}\n\t\t\treturn len;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\nBTRFS_ATTR_RW(, read_policy, btrfs_read_policy_show, btrfs_read_policy_store);\n\nstatic ssize_t btrfs_bg_reclaim_threshold_show(struct kobject *kobj,\n\t\t\t\t\t       struct kobj_attribute *a,\n\t\t\t\t\t       char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj);\n\n\treturn sysfs_emit(buf, \"%d\\n\", READ_ONCE(fs_info->bg_reclaim_threshold));\n}\n\nstatic ssize_t btrfs_bg_reclaim_threshold_store(struct kobject *kobj,\n\t\t\t\t\t\tstruct kobj_attribute *a,\n\t\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(kobj);\n\tint thresh;\n\tint ret;\n\n\tret = kstrtoint(buf, 10, &thresh);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_BTRFS_DEBUG\n\tif (thresh != 0 && (thresh > 100))\n\t\treturn -EINVAL;\n#else\n\tif (thresh != 0 && (thresh <= 50 || thresh > 100))\n\t\treturn -EINVAL;\n#endif\n\n\tWRITE_ONCE(fs_info->bg_reclaim_threshold, thresh);\n\n\treturn len;\n}\nBTRFS_ATTR_RW(, bg_reclaim_threshold, btrfs_bg_reclaim_threshold_show,\n\t      btrfs_bg_reclaim_threshold_store);\n\n \nstatic const struct attribute *btrfs_attrs[] = {\n\tBTRFS_ATTR_PTR(, label),\n\tBTRFS_ATTR_PTR(, nodesize),\n\tBTRFS_ATTR_PTR(, sectorsize),\n\tBTRFS_ATTR_PTR(, clone_alignment),\n\tBTRFS_ATTR_PTR(, quota_override),\n\tBTRFS_ATTR_PTR(, metadata_uuid),\n\tBTRFS_ATTR_PTR(, checksum),\n\tBTRFS_ATTR_PTR(, exclusive_operation),\n\tBTRFS_ATTR_PTR(, generation),\n\tBTRFS_ATTR_PTR(, read_policy),\n\tBTRFS_ATTR_PTR(, bg_reclaim_threshold),\n\tBTRFS_ATTR_PTR(, commit_stats),\n\tNULL,\n};\n\nstatic void btrfs_release_fsid_kobj(struct kobject *kobj)\n{\n\tstruct btrfs_fs_devices *fs_devs = to_fs_devs(kobj);\n\n\tmemset(&fs_devs->fsid_kobj, 0, sizeof(struct kobject));\n\tcomplete(&fs_devs->kobj_unregister);\n}\n\nstatic const struct kobj_type btrfs_ktype = {\n\t.sysfs_ops\t= &kobj_sysfs_ops,\n\t.release\t= btrfs_release_fsid_kobj,\n};\n\nstatic inline struct btrfs_fs_devices *to_fs_devs(struct kobject *kobj)\n{\n\tif (kobj->ktype != &btrfs_ktype)\n\t\treturn NULL;\n\treturn container_of(kobj, struct btrfs_fs_devices, fsid_kobj);\n}\n\nstatic inline struct btrfs_fs_info *to_fs_info(struct kobject *kobj)\n{\n\tif (kobj->ktype != &btrfs_ktype)\n\t\treturn NULL;\n\treturn to_fs_devs(kobj)->fs_info;\n}\n\nstatic struct kobject *get_btrfs_kobj(struct kobject *kobj)\n{\n\twhile (kobj) {\n\t\tif (kobj->ktype == &btrfs_ktype)\n\t\t\treturn kobj;\n\t\tkobj = kobj->parent;\n\t}\n\treturn NULL;\n}\n\n#define NUM_FEATURE_BITS 64\n#define BTRFS_FEATURE_NAME_MAX 13\nstatic char btrfs_unknown_feature_names[FEAT_MAX][NUM_FEATURE_BITS][BTRFS_FEATURE_NAME_MAX];\nstatic struct btrfs_feature_attr btrfs_feature_attrs[FEAT_MAX][NUM_FEATURE_BITS];\n\nstatic_assert(ARRAY_SIZE(btrfs_unknown_feature_names) ==\n\t      ARRAY_SIZE(btrfs_feature_attrs));\nstatic_assert(ARRAY_SIZE(btrfs_unknown_feature_names[0]) ==\n\t      ARRAY_SIZE(btrfs_feature_attrs[0]));\n\nstatic const u64 supported_feature_masks[FEAT_MAX] = {\n\t[FEAT_COMPAT]    = BTRFS_FEATURE_COMPAT_SUPP,\n\t[FEAT_COMPAT_RO] = BTRFS_FEATURE_COMPAT_RO_SUPP,\n\t[FEAT_INCOMPAT]  = BTRFS_FEATURE_INCOMPAT_SUPP,\n};\n\nstatic int addrm_unknown_feature_attrs(struct btrfs_fs_info *fs_info, bool add)\n{\n\tint set;\n\n\tfor (set = 0; set < FEAT_MAX; set++) {\n\t\tint i;\n\t\tstruct attribute *attrs[2];\n\t\tstruct attribute_group agroup = {\n\t\t\t.name = \"features\",\n\t\t\t.attrs = attrs,\n\t\t};\n\t\tu64 features = get_features(fs_info, set);\n\t\tfeatures &= ~supported_feature_masks[set];\n\n\t\tif (!features)\n\t\t\tcontinue;\n\n\t\tattrs[1] = NULL;\n\t\tfor (i = 0; i < NUM_FEATURE_BITS; i++) {\n\t\t\tstruct btrfs_feature_attr *fa;\n\n\t\t\tif (!(features & (1ULL << i)))\n\t\t\t\tcontinue;\n\n\t\t\tfa = &btrfs_feature_attrs[set][i];\n\t\t\tattrs[0] = &fa->kobj_attr.attr;\n\t\t\tif (add) {\n\t\t\t\tint ret;\n\t\t\t\tret = sysfs_merge_group(&fs_info->fs_devices->fsid_kobj,\n\t\t\t\t\t\t\t&agroup);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\tsysfs_unmerge_group(&fs_info->fs_devices->fsid_kobj,\n\t\t\t\t\t\t    &agroup);\n\t\t}\n\n\t}\n\treturn 0;\n}\n\nstatic void __btrfs_sysfs_remove_fsid(struct btrfs_fs_devices *fs_devs)\n{\n\tif (fs_devs->devinfo_kobj) {\n\t\tkobject_del(fs_devs->devinfo_kobj);\n\t\tkobject_put(fs_devs->devinfo_kobj);\n\t\tfs_devs->devinfo_kobj = NULL;\n\t}\n\n\tif (fs_devs->devices_kobj) {\n\t\tkobject_del(fs_devs->devices_kobj);\n\t\tkobject_put(fs_devs->devices_kobj);\n\t\tfs_devs->devices_kobj = NULL;\n\t}\n\n\tif (fs_devs->fsid_kobj.state_initialized) {\n\t\tkobject_del(&fs_devs->fsid_kobj);\n\t\tkobject_put(&fs_devs->fsid_kobj);\n\t\twait_for_completion(&fs_devs->kobj_unregister);\n\t}\n}\n\n \nvoid btrfs_sysfs_remove_fsid(struct btrfs_fs_devices *fs_devs)\n{\n\tstruct list_head *fs_uuids = btrfs_get_fs_uuids();\n\n\tif (fs_devs) {\n\t\t__btrfs_sysfs_remove_fsid(fs_devs);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(fs_devs, fs_uuids, fs_list) {\n\t\t__btrfs_sysfs_remove_fsid(fs_devs);\n\t}\n}\n\nstatic void btrfs_sysfs_remove_fs_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *seed;\n\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list)\n\t\tbtrfs_sysfs_remove_device(device);\n\n\tlist_for_each_entry(seed, &fs_devices->seed_list, seed_list) {\n\t\tlist_for_each_entry(device, &seed->devices, dev_list)\n\t\t\tbtrfs_sysfs_remove_device(device);\n\t}\n}\n\nvoid btrfs_sysfs_remove_mounted(struct btrfs_fs_info *fs_info)\n{\n\tstruct kobject *fsid_kobj = &fs_info->fs_devices->fsid_kobj;\n\n\tsysfs_remove_link(fsid_kobj, \"bdi\");\n\n\tif (fs_info->space_info_kobj) {\n\t\tsysfs_remove_files(fs_info->space_info_kobj, allocation_attrs);\n\t\tkobject_del(fs_info->space_info_kobj);\n\t\tkobject_put(fs_info->space_info_kobj);\n\t}\n\tif (fs_info->discard_kobj) {\n\t\tsysfs_remove_files(fs_info->discard_kobj, discard_attrs);\n\t\tkobject_del(fs_info->discard_kobj);\n\t\tkobject_put(fs_info->discard_kobj);\n\t}\n#ifdef CONFIG_BTRFS_DEBUG\n\tif (fs_info->debug_kobj) {\n\t\tsysfs_remove_files(fs_info->debug_kobj, btrfs_debug_mount_attrs);\n\t\tkobject_del(fs_info->debug_kobj);\n\t\tkobject_put(fs_info->debug_kobj);\n\t}\n#endif\n\taddrm_unknown_feature_attrs(fs_info, false);\n\tsysfs_remove_group(fsid_kobj, &btrfs_feature_attr_group);\n\tsysfs_remove_files(fsid_kobj, btrfs_attrs);\n\tbtrfs_sysfs_remove_fs_devices(fs_info->fs_devices);\n}\n\nstatic const char * const btrfs_feature_set_names[FEAT_MAX] = {\n\t[FEAT_COMPAT]\t = \"compat\",\n\t[FEAT_COMPAT_RO] = \"compat_ro\",\n\t[FEAT_INCOMPAT]\t = \"incompat\",\n};\n\nconst char *btrfs_feature_set_name(enum btrfs_feature_set set)\n{\n\treturn btrfs_feature_set_names[set];\n}\n\nchar *btrfs_printable_features(enum btrfs_feature_set set, u64 flags)\n{\n\tsize_t bufsize = 4096;  \n\tint len = 0;\n\tint i;\n\tchar *str;\n\n\tstr = kmalloc(bufsize, GFP_KERNEL);\n\tif (!str)\n\t\treturn str;\n\n\tfor (i = 0; i < ARRAY_SIZE(btrfs_feature_attrs[set]); i++) {\n\t\tconst char *name;\n\n\t\tif (!(flags & (1ULL << i)))\n\t\t\tcontinue;\n\n\t\tname = btrfs_feature_attrs[set][i].kobj_attr.attr.name;\n\t\tlen += scnprintf(str + len, bufsize - len, \"%s%s\",\n\t\t\t\tlen ? \",\" : \"\", name);\n\t}\n\n\treturn str;\n}\n\nstatic void init_feature_attrs(void)\n{\n\tstruct btrfs_feature_attr *fa;\n\tint set, i;\n\n\tmemset(btrfs_feature_attrs, 0, sizeof(btrfs_feature_attrs));\n\tmemset(btrfs_unknown_feature_names, 0,\n\t       sizeof(btrfs_unknown_feature_names));\n\n\tfor (i = 0; btrfs_supported_feature_attrs[i]; i++) {\n\t\tstruct btrfs_feature_attr *sfa;\n\t\tstruct attribute *a = btrfs_supported_feature_attrs[i];\n\t\tint bit;\n\t\tsfa = attr_to_btrfs_feature_attr(a);\n\t\tbit = ilog2(sfa->feature_bit);\n\t\tfa = &btrfs_feature_attrs[sfa->feature_set][bit];\n\n\t\tfa->kobj_attr.attr.name = sfa->kobj_attr.attr.name;\n\t}\n\n\tfor (set = 0; set < FEAT_MAX; set++) {\n\t\tfor (i = 0; i < ARRAY_SIZE(btrfs_feature_attrs[set]); i++) {\n\t\t\tchar *name = btrfs_unknown_feature_names[set][i];\n\t\t\tfa = &btrfs_feature_attrs[set][i];\n\n\t\t\tif (fa->kobj_attr.attr.name)\n\t\t\t\tcontinue;\n\n\t\t\tsnprintf(name, BTRFS_FEATURE_NAME_MAX, \"%s:%u\",\n\t\t\t\t btrfs_feature_set_names[set], i);\n\n\t\t\tfa->kobj_attr.attr.name = name;\n\t\t\tfa->kobj_attr.attr.mode = S_IRUGO;\n\t\t\tfa->feature_set = set;\n\t\t\tfa->feature_bit = 1ULL << i;\n\t\t}\n\t}\n}\n\n \nvoid btrfs_sysfs_add_block_group_type(struct btrfs_block_group *cache)\n{\n\tstruct btrfs_fs_info *fs_info = cache->fs_info;\n\tstruct btrfs_space_info *space_info = cache->space_info;\n\tstruct raid_kobject *rkobj;\n\tconst int index = btrfs_bg_flags_to_raid_index(cache->flags);\n\tunsigned int nofs_flag;\n\tint ret;\n\n\t \n\tnofs_flag = memalloc_nofs_save();\n\n\trkobj = kzalloc(sizeof(*rkobj), GFP_NOFS);\n\tif (!rkobj) {\n\t\tmemalloc_nofs_restore(nofs_flag);\n\t\tbtrfs_warn(cache->fs_info,\n\t\t\t\t\"couldn't alloc memory for raid level kobject\");\n\t\treturn;\n\t}\n\n\trkobj->flags = cache->flags;\n\tkobject_init(&rkobj->kobj, &btrfs_raid_ktype);\n\n\t \n\tspin_lock(&space_info->lock);\n\tif (space_info->block_group_kobjs[index]) {\n\t\tspin_unlock(&space_info->lock);\n\t\tkobject_put(&rkobj->kobj);\n\t\treturn;\n\t} else {\n\t\tspace_info->block_group_kobjs[index] = &rkobj->kobj;\n\t}\n\tspin_unlock(&space_info->lock);\n\n\tret = kobject_add(&rkobj->kobj, &space_info->kobj, \"%s\",\n\t\t\t  btrfs_bg_type_to_raid_name(rkobj->flags));\n\tmemalloc_nofs_restore(nofs_flag);\n\tif (ret) {\n\t\tspin_lock(&space_info->lock);\n\t\tspace_info->block_group_kobjs[index] = NULL;\n\t\tspin_unlock(&space_info->lock);\n\t\tkobject_put(&rkobj->kobj);\n\t\tbtrfs_warn(fs_info,\n\t\t\t\"failed to add kobject for block cache, ignoring\");\n\t\treturn;\n\t}\n}\n\n \nvoid btrfs_sysfs_remove_space_info(struct btrfs_space_info *space_info)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_NR_RAID_TYPES; i++) {\n\t\tstruct kobject *kobj;\n\n\t\tkobj = space_info->block_group_kobjs[i];\n\t\tspace_info->block_group_kobjs[i] = NULL;\n\t\tif (kobj) {\n\t\t\tkobject_del(kobj);\n\t\t\tkobject_put(kobj);\n\t\t}\n\t}\n\tkobject_del(&space_info->kobj);\n\tkobject_put(&space_info->kobj);\n}\n\nstatic const char *alloc_name(u64 flags)\n{\n\tswitch (flags) {\n\tcase BTRFS_BLOCK_GROUP_METADATA | BTRFS_BLOCK_GROUP_DATA:\n\t\treturn \"mixed\";\n\tcase BTRFS_BLOCK_GROUP_METADATA:\n\t\treturn \"metadata\";\n\tcase BTRFS_BLOCK_GROUP_DATA:\n\t\treturn \"data\";\n\tcase BTRFS_BLOCK_GROUP_SYSTEM:\n\t\treturn \"system\";\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn \"invalid-combination\";\n\t}\n}\n\n \nint btrfs_sysfs_add_space_info_type(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct btrfs_space_info *space_info)\n{\n\tint ret;\n\n\tret = kobject_init_and_add(&space_info->kobj, &space_info_ktype,\n\t\t\t\t   fs_info->space_info_kobj, \"%s\",\n\t\t\t\t   alloc_name(space_info->flags));\n\tif (ret) {\n\t\tkobject_put(&space_info->kobj);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid btrfs_sysfs_remove_device(struct btrfs_device *device)\n{\n\tstruct kobject *devices_kobj;\n\n\t \n\tdevices_kobj = device->fs_info->fs_devices->devices_kobj;\n\tASSERT(devices_kobj);\n\n\tif (device->bdev)\n\t\tsysfs_remove_link(devices_kobj, bdev_kobj(device->bdev)->name);\n\n\tif (device->devid_kobj.state_initialized) {\n\t\tkobject_del(&device->devid_kobj);\n\t\tkobject_put(&device->devid_kobj);\n\t\twait_for_completion(&device->kobj_unregister);\n\t}\n}\n\nstatic ssize_t btrfs_devinfo_in_fs_metadata_show(struct kobject *kobj,\n\t\t\t\t\t         struct kobj_attribute *a,\n\t\t\t\t\t         char *buf)\n{\n\tint val;\n\tstruct btrfs_device *device = container_of(kobj, struct btrfs_device,\n\t\t\t\t\t\t   devid_kobj);\n\n\tval = !!test_bit(BTRFS_DEV_STATE_IN_FS_METADATA, &device->dev_state);\n\n\treturn sysfs_emit(buf, \"%d\\n\", val);\n}\nBTRFS_ATTR(devid, in_fs_metadata, btrfs_devinfo_in_fs_metadata_show);\n\nstatic ssize_t btrfs_devinfo_missing_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *a, char *buf)\n{\n\tint val;\n\tstruct btrfs_device *device = container_of(kobj, struct btrfs_device,\n\t\t\t\t\t\t   devid_kobj);\n\n\tval = !!test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state);\n\n\treturn sysfs_emit(buf, \"%d\\n\", val);\n}\nBTRFS_ATTR(devid, missing, btrfs_devinfo_missing_show);\n\nstatic ssize_t btrfs_devinfo_replace_target_show(struct kobject *kobj,\n\t\t\t\t\t         struct kobj_attribute *a,\n\t\t\t\t\t         char *buf)\n{\n\tint val;\n\tstruct btrfs_device *device = container_of(kobj, struct btrfs_device,\n\t\t\t\t\t\t   devid_kobj);\n\n\tval = !!test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state);\n\n\treturn sysfs_emit(buf, \"%d\\n\", val);\n}\nBTRFS_ATTR(devid, replace_target, btrfs_devinfo_replace_target_show);\n\nstatic ssize_t btrfs_devinfo_scrub_speed_max_show(struct kobject *kobj,\n\t\t\t\t\t     struct kobj_attribute *a,\n\t\t\t\t\t     char *buf)\n{\n\tstruct btrfs_device *device = container_of(kobj, struct btrfs_device,\n\t\t\t\t\t\t   devid_kobj);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", READ_ONCE(device->scrub_speed_max));\n}\n\nstatic ssize_t btrfs_devinfo_scrub_speed_max_store(struct kobject *kobj,\n\t\t\t\t\t      struct kobj_attribute *a,\n\t\t\t\t\t      const char *buf, size_t len)\n{\n\tstruct btrfs_device *device = container_of(kobj, struct btrfs_device,\n\t\t\t\t\t\t   devid_kobj);\n\tchar *endptr;\n\tunsigned long long limit;\n\n\tlimit = memparse(buf, &endptr);\n\tWRITE_ONCE(device->scrub_speed_max, limit);\n\treturn len;\n}\nBTRFS_ATTR_RW(devid, scrub_speed_max, btrfs_devinfo_scrub_speed_max_show,\n\t      btrfs_devinfo_scrub_speed_max_store);\n\nstatic ssize_t btrfs_devinfo_writeable_show(struct kobject *kobj,\n\t\t\t\t\t    struct kobj_attribute *a, char *buf)\n{\n\tint val;\n\tstruct btrfs_device *device = container_of(kobj, struct btrfs_device,\n\t\t\t\t\t\t   devid_kobj);\n\n\tval = !!test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state);\n\n\treturn sysfs_emit(buf, \"%d\\n\", val);\n}\nBTRFS_ATTR(devid, writeable, btrfs_devinfo_writeable_show);\n\nstatic ssize_t btrfs_devinfo_fsid_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *a, char *buf)\n{\n\tstruct btrfs_device *device = container_of(kobj, struct btrfs_device,\n\t\t\t\t\t\t   devid_kobj);\n\n\treturn sysfs_emit(buf, \"%pU\\n\", device->fs_devices->fsid);\n}\nBTRFS_ATTR(devid, fsid, btrfs_devinfo_fsid_show);\n\nstatic ssize_t btrfs_devinfo_error_stats_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *a, char *buf)\n{\n\tstruct btrfs_device *device = container_of(kobj, struct btrfs_device,\n\t\t\t\t\t\t   devid_kobj);\n\n\tif (!device->dev_stats_valid)\n\t\treturn sysfs_emit(buf, \"invalid\\n\");\n\n\t \n\treturn sysfs_emit(buf,\n\t\t\"write_errs %d\\n\"\n\t\t\"read_errs %d\\n\"\n\t\t\"flush_errs %d\\n\"\n\t\t\"corruption_errs %d\\n\"\n\t\t\"generation_errs %d\\n\",\n\t\tbtrfs_dev_stat_read(device, BTRFS_DEV_STAT_WRITE_ERRS),\n\t\tbtrfs_dev_stat_read(device, BTRFS_DEV_STAT_READ_ERRS),\n\t\tbtrfs_dev_stat_read(device, BTRFS_DEV_STAT_FLUSH_ERRS),\n\t\tbtrfs_dev_stat_read(device, BTRFS_DEV_STAT_CORRUPTION_ERRS),\n\t\tbtrfs_dev_stat_read(device, BTRFS_DEV_STAT_GENERATION_ERRS));\n}\nBTRFS_ATTR(devid, error_stats, btrfs_devinfo_error_stats_show);\n\n \nstatic struct attribute *devid_attrs[] = {\n\tBTRFS_ATTR_PTR(devid, error_stats),\n\tBTRFS_ATTR_PTR(devid, fsid),\n\tBTRFS_ATTR_PTR(devid, in_fs_metadata),\n\tBTRFS_ATTR_PTR(devid, missing),\n\tBTRFS_ATTR_PTR(devid, replace_target),\n\tBTRFS_ATTR_PTR(devid, scrub_speed_max),\n\tBTRFS_ATTR_PTR(devid, writeable),\n\tNULL\n};\nATTRIBUTE_GROUPS(devid);\n\nstatic void btrfs_release_devid_kobj(struct kobject *kobj)\n{\n\tstruct btrfs_device *device = container_of(kobj, struct btrfs_device,\n\t\t\t\t\t\t   devid_kobj);\n\n\tmemset(&device->devid_kobj, 0, sizeof(struct kobject));\n\tcomplete(&device->kobj_unregister);\n}\n\nstatic const struct kobj_type devid_ktype = {\n\t.sysfs_ops\t= &kobj_sysfs_ops,\n\t.default_groups = devid_groups,\n\t.release\t= btrfs_release_devid_kobj,\n};\n\nint btrfs_sysfs_add_device(struct btrfs_device *device)\n{\n\tint ret;\n\tunsigned int nofs_flag;\n\tstruct kobject *devices_kobj;\n\tstruct kobject *devinfo_kobj;\n\n\t \n\tdevices_kobj = device->fs_info->fs_devices->devices_kobj;\n\tdevinfo_kobj = device->fs_info->fs_devices->devinfo_kobj;\n\tASSERT(devices_kobj);\n\tASSERT(devinfo_kobj);\n\n\tnofs_flag = memalloc_nofs_save();\n\n\tif (device->bdev) {\n\t\tstruct kobject *disk_kobj = bdev_kobj(device->bdev);\n\n\t\tret = sysfs_create_link(devices_kobj, disk_kobj, disk_kobj->name);\n\t\tif (ret) {\n\t\t\tbtrfs_warn(device->fs_info,\n\t\t\t\t\"creating sysfs device link for devid %llu failed: %d\",\n\t\t\t\tdevice->devid, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tinit_completion(&device->kobj_unregister);\n\tret = kobject_init_and_add(&device->devid_kobj, &devid_ktype,\n\t\t\t\t   devinfo_kobj, \"%llu\", device->devid);\n\tif (ret) {\n\t\tkobject_put(&device->devid_kobj);\n\t\tbtrfs_warn(device->fs_info,\n\t\t\t   \"devinfo init for devid %llu failed: %d\",\n\t\t\t   device->devid, ret);\n\t}\n\nout:\n\tmemalloc_nofs_restore(nofs_flag);\n\treturn ret;\n}\n\nstatic int btrfs_sysfs_add_fs_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tint ret;\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *seed;\n\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tret = btrfs_sysfs_add_device(device);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\tlist_for_each_entry(seed, &fs_devices->seed_list, seed_list) {\n\t\tlist_for_each_entry(device, &seed->devices, dev_list) {\n\t\t\tret = btrfs_sysfs_add_device(device);\n\t\t\tif (ret)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail:\n\tbtrfs_sysfs_remove_fs_devices(fs_devices);\n\treturn ret;\n}\n\nvoid btrfs_kobject_uevent(struct block_device *bdev, enum kobject_action action)\n{\n\tint ret;\n\n\tret = kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, action);\n\tif (ret)\n\t\tpr_warn(\"BTRFS: Sending event '%d' to kobject: '%s' (%p): failed\\n\",\n\t\t\taction, kobject_name(&disk_to_dev(bdev->bd_disk)->kobj),\n\t\t\t&disk_to_dev(bdev->bd_disk)->kobj);\n}\n\nvoid btrfs_sysfs_update_sprout_fsid(struct btrfs_fs_devices *fs_devices)\n\n{\n\tchar fsid_buf[BTRFS_UUID_UNPARSED_SIZE];\n\n\t \n\tsnprintf(fsid_buf, BTRFS_UUID_UNPARSED_SIZE, \"%pU\", fs_devices->fsid);\n\tif (kobject_rename(&fs_devices->fsid_kobj, fsid_buf))\n\t\tbtrfs_warn(fs_devices->fs_info,\n\t\t\t\t\"sysfs: failed to create fsid for sprout\");\n}\n\nvoid btrfs_sysfs_update_devid(struct btrfs_device *device)\n{\n\tchar tmp[24];\n\n\tsnprintf(tmp, sizeof(tmp), \"%llu\", device->devid);\n\n\tif (kobject_rename(&device->devid_kobj, tmp))\n\t\tbtrfs_warn(device->fs_devices->fs_info,\n\t\t\t   \"sysfs: failed to update devid for %llu\",\n\t\t\t   device->devid);\n}\n\n \nstatic struct kset *btrfs_kset;\n\n \nint btrfs_sysfs_add_fsid(struct btrfs_fs_devices *fs_devs)\n{\n\tint error;\n\n\tinit_completion(&fs_devs->kobj_unregister);\n\tfs_devs->fsid_kobj.kset = btrfs_kset;\n\terror = kobject_init_and_add(&fs_devs->fsid_kobj, &btrfs_ktype, NULL,\n\t\t\t\t     \"%pU\", fs_devs->fsid);\n\tif (error) {\n\t\tkobject_put(&fs_devs->fsid_kobj);\n\t\treturn error;\n\t}\n\n\tfs_devs->devices_kobj = kobject_create_and_add(\"devices\",\n\t\t\t\t\t\t       &fs_devs->fsid_kobj);\n\tif (!fs_devs->devices_kobj) {\n\t\tbtrfs_err(fs_devs->fs_info,\n\t\t\t  \"failed to init sysfs device interface\");\n\t\tbtrfs_sysfs_remove_fsid(fs_devs);\n\t\treturn -ENOMEM;\n\t}\n\n\tfs_devs->devinfo_kobj = kobject_create_and_add(\"devinfo\",\n\t\t\t\t\t\t       &fs_devs->fsid_kobj);\n\tif (!fs_devs->devinfo_kobj) {\n\t\tbtrfs_err(fs_devs->fs_info,\n\t\t\t  \"failed to init sysfs devinfo kobject\");\n\t\tbtrfs_sysfs_remove_fsid(fs_devs);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nint btrfs_sysfs_add_mounted(struct btrfs_fs_info *fs_info)\n{\n\tint error;\n\tstruct btrfs_fs_devices *fs_devs = fs_info->fs_devices;\n\tstruct kobject *fsid_kobj = &fs_devs->fsid_kobj;\n\n\terror = btrfs_sysfs_add_fs_devices(fs_devs);\n\tif (error)\n\t\treturn error;\n\n\terror = sysfs_create_files(fsid_kobj, btrfs_attrs);\n\tif (error) {\n\t\tbtrfs_sysfs_remove_fs_devices(fs_devs);\n\t\treturn error;\n\t}\n\n\terror = sysfs_create_group(fsid_kobj,\n\t\t\t\t   &btrfs_feature_attr_group);\n\tif (error)\n\t\tgoto failure;\n\n#ifdef CONFIG_BTRFS_DEBUG\n\tfs_info->debug_kobj = kobject_create_and_add(\"debug\", fsid_kobj);\n\tif (!fs_info->debug_kobj) {\n\t\terror = -ENOMEM;\n\t\tgoto failure;\n\t}\n\n\terror = sysfs_create_files(fs_info->debug_kobj, btrfs_debug_mount_attrs);\n\tif (error)\n\t\tgoto failure;\n#endif\n\n\t \n\tfs_info->discard_kobj = kobject_create_and_add(\"discard\", fsid_kobj);\n\tif (!fs_info->discard_kobj) {\n\t\terror = -ENOMEM;\n\t\tgoto failure;\n\t}\n\n\terror = sysfs_create_files(fs_info->discard_kobj, discard_attrs);\n\tif (error)\n\t\tgoto failure;\n\n\terror = addrm_unknown_feature_attrs(fs_info, true);\n\tif (error)\n\t\tgoto failure;\n\n\terror = sysfs_create_link(fsid_kobj, &fs_info->sb->s_bdi->dev->kobj, \"bdi\");\n\tif (error)\n\t\tgoto failure;\n\n\tfs_info->space_info_kobj = kobject_create_and_add(\"allocation\",\n\t\t\t\t\t\t  fsid_kobj);\n\tif (!fs_info->space_info_kobj) {\n\t\terror = -ENOMEM;\n\t\tgoto failure;\n\t}\n\n\terror = sysfs_create_files(fs_info->space_info_kobj, allocation_attrs);\n\tif (error)\n\t\tgoto failure;\n\n\treturn 0;\nfailure:\n\tbtrfs_sysfs_remove_mounted(fs_info);\n\treturn error;\n}\n\nstatic ssize_t qgroup_enabled_show(struct kobject *qgroups_kobj,\n\t\t\t\t   struct kobj_attribute *a,\n\t\t\t\t   char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(qgroups_kobj->parent);\n\tbool enabled;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tenabled = fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON;\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\treturn sysfs_emit(buf, \"%d\\n\", enabled);\n}\nBTRFS_ATTR(qgroups, enabled, qgroup_enabled_show);\n\nstatic ssize_t qgroup_inconsistent_show(struct kobject *qgroups_kobj,\n\t\t\t\t\tstruct kobj_attribute *a,\n\t\t\t\t\tchar *buf)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(qgroups_kobj->parent);\n\tbool inconsistent;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tinconsistent = (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT);\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\treturn sysfs_emit(buf, \"%d\\n\", inconsistent);\n}\nBTRFS_ATTR(qgroups, inconsistent, qgroup_inconsistent_show);\n\nstatic ssize_t qgroup_drop_subtree_thres_show(struct kobject *qgroups_kobj,\n\t\t\t\t\t      struct kobj_attribute *a,\n\t\t\t\t\t      char *buf)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(qgroups_kobj->parent);\n\tu8 result;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tresult = fs_info->qgroup_drop_subtree_thres;\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\treturn sysfs_emit(buf, \"%d\\n\", result);\n}\n\nstatic ssize_t qgroup_drop_subtree_thres_store(struct kobject *qgroups_kobj,\n\t\t\t\t\t       struct kobj_attribute *a,\n\t\t\t\t\t       const char *buf, size_t len)\n{\n\tstruct btrfs_fs_info *fs_info = to_fs_info(qgroups_kobj->parent);\n\tu8 new_thres;\n\tint ret;\n\n\tret = kstrtou8(buf, 10, &new_thres);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tif (new_thres > BTRFS_MAX_LEVEL)\n\t\treturn -EINVAL;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tfs_info->qgroup_drop_subtree_thres = new_thres;\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\treturn len;\n}\nBTRFS_ATTR_RW(qgroups, drop_subtree_threshold, qgroup_drop_subtree_thres_show,\n\t      qgroup_drop_subtree_thres_store);\n\n \nstatic struct attribute *qgroups_attrs[] = {\n\tBTRFS_ATTR_PTR(qgroups, enabled),\n\tBTRFS_ATTR_PTR(qgroups, inconsistent),\n\tBTRFS_ATTR_PTR(qgroups, drop_subtree_threshold),\n\tNULL\n};\nATTRIBUTE_GROUPS(qgroups);\n\nstatic void qgroups_release(struct kobject *kobj)\n{\n\tkfree(kobj);\n}\n\nstatic const struct kobj_type qgroups_ktype = {\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = qgroups_groups,\n\t.release = qgroups_release,\n};\n\nstatic inline struct btrfs_fs_info *qgroup_kobj_to_fs_info(struct kobject *kobj)\n{\n\treturn to_fs_info(kobj->parent->parent);\n}\n\n#define QGROUP_ATTR(_member, _show_name)\t\t\t\t\t\\\nstatic ssize_t btrfs_qgroup_show_##_member(struct kobject *qgroup_kobj,\t\t\\\n\t\t\t\t\t   struct kobj_attribute *a,\t\t\\\n\t\t\t\t\t   char *buf)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tstruct btrfs_fs_info *fs_info = qgroup_kobj_to_fs_info(qgroup_kobj);\t\\\n\tstruct btrfs_qgroup *qgroup = container_of(qgroup_kobj,\t\t\t\\\n\t\t\tstruct btrfs_qgroup, kobj);\t\t\t\t\\\n\treturn btrfs_show_u64(&qgroup->_member, &fs_info->qgroup_lock, buf);\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\nBTRFS_ATTR(qgroup, _show_name, btrfs_qgroup_show_##_member)\n\n#define QGROUP_RSV_ATTR(_name, _type)\t\t\t\t\t\t\\\nstatic ssize_t btrfs_qgroup_rsv_show_##_name(struct kobject *qgroup_kobj,\t\\\n\t\t\t\t\t     struct kobj_attribute *a,\t\t\\\n\t\t\t\t\t     char *buf)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tstruct btrfs_fs_info *fs_info = qgroup_kobj_to_fs_info(qgroup_kobj);\t\\\n\tstruct btrfs_qgroup *qgroup = container_of(qgroup_kobj,\t\t\t\\\n\t\t\tstruct btrfs_qgroup, kobj);\t\t\t\t\\\n\treturn btrfs_show_u64(&qgroup->rsv.values[_type],\t\t\t\\\n\t\t\t&fs_info->qgroup_lock, buf);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\nBTRFS_ATTR(qgroup, rsv_##_name, btrfs_qgroup_rsv_show_##_name)\n\nQGROUP_ATTR(rfer, referenced);\nQGROUP_ATTR(excl, exclusive);\nQGROUP_ATTR(max_rfer, max_referenced);\nQGROUP_ATTR(max_excl, max_exclusive);\nQGROUP_ATTR(lim_flags, limit_flags);\nQGROUP_RSV_ATTR(data, BTRFS_QGROUP_RSV_DATA);\nQGROUP_RSV_ATTR(meta_pertrans, BTRFS_QGROUP_RSV_META_PERTRANS);\nQGROUP_RSV_ATTR(meta_prealloc, BTRFS_QGROUP_RSV_META_PREALLOC);\n\n \nstatic struct attribute *qgroup_attrs[] = {\n\tBTRFS_ATTR_PTR(qgroup, referenced),\n\tBTRFS_ATTR_PTR(qgroup, exclusive),\n\tBTRFS_ATTR_PTR(qgroup, max_referenced),\n\tBTRFS_ATTR_PTR(qgroup, max_exclusive),\n\tBTRFS_ATTR_PTR(qgroup, limit_flags),\n\tBTRFS_ATTR_PTR(qgroup, rsv_data),\n\tBTRFS_ATTR_PTR(qgroup, rsv_meta_pertrans),\n\tBTRFS_ATTR_PTR(qgroup, rsv_meta_prealloc),\n\tNULL\n};\nATTRIBUTE_GROUPS(qgroup);\n\nstatic void qgroup_release(struct kobject *kobj)\n{\n\tstruct btrfs_qgroup *qgroup = container_of(kobj, struct btrfs_qgroup, kobj);\n\n\tmemset(&qgroup->kobj, 0, sizeof(*kobj));\n}\n\nstatic const struct kobj_type qgroup_ktype = {\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.release = qgroup_release,\n\t.default_groups = qgroup_groups,\n};\n\nint btrfs_sysfs_add_one_qgroup(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_qgroup *qgroup)\n{\n\tstruct kobject *qgroups_kobj = fs_info->qgroups_kobj;\n\tint ret;\n\n\tif (test_bit(BTRFS_FS_STATE_DUMMY_FS_INFO, &fs_info->fs_state))\n\t\treturn 0;\n\tif (qgroup->kobj.state_initialized)\n\t\treturn 0;\n\tif (!qgroups_kobj)\n\t\treturn -EINVAL;\n\n\tret = kobject_init_and_add(&qgroup->kobj, &qgroup_ktype, qgroups_kobj,\n\t\t\t\"%hu_%llu\", btrfs_qgroup_level(qgroup->qgroupid),\n\t\t\tbtrfs_qgroup_subvolid(qgroup->qgroupid));\n\tif (ret < 0)\n\t\tkobject_put(&qgroup->kobj);\n\n\treturn ret;\n}\n\nvoid btrfs_sysfs_del_qgroups(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_qgroup *qgroup;\n\tstruct btrfs_qgroup *next;\n\n\tif (test_bit(BTRFS_FS_STATE_DUMMY_FS_INFO, &fs_info->fs_state))\n\t\treturn;\n\n\trbtree_postorder_for_each_entry_safe(qgroup, next,\n\t\t\t\t\t     &fs_info->qgroup_tree, node)\n\t\tbtrfs_sysfs_del_one_qgroup(fs_info, qgroup);\n\tif (fs_info->qgroups_kobj) {\n\t\tkobject_del(fs_info->qgroups_kobj);\n\t\tkobject_put(fs_info->qgroups_kobj);\n\t\tfs_info->qgroups_kobj = NULL;\n\t}\n}\n\n \nint btrfs_sysfs_add_qgroups(struct btrfs_fs_info *fs_info)\n{\n\tstruct kobject *fsid_kobj = &fs_info->fs_devices->fsid_kobj;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct btrfs_qgroup *next;\n\tint ret = 0;\n\n\tif (test_bit(BTRFS_FS_STATE_DUMMY_FS_INFO, &fs_info->fs_state))\n\t\treturn 0;\n\n\tASSERT(fsid_kobj);\n\tif (fs_info->qgroups_kobj)\n\t\treturn 0;\n\n\tfs_info->qgroups_kobj = kzalloc(sizeof(struct kobject), GFP_KERNEL);\n\tif (!fs_info->qgroups_kobj)\n\t\treturn -ENOMEM;\n\n\tret = kobject_init_and_add(fs_info->qgroups_kobj, &qgroups_ktype,\n\t\t\t\t   fsid_kobj, \"qgroups\");\n\tif (ret < 0)\n\t\tgoto out;\n\n\trbtree_postorder_for_each_entry_safe(qgroup, next,\n\t\t\t\t\t     &fs_info->qgroup_tree, node) {\n\t\tret = btrfs_sysfs_add_one_qgroup(fs_info, qgroup);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (ret < 0)\n\t\tbtrfs_sysfs_del_qgroups(fs_info);\n\treturn ret;\n}\n\nvoid btrfs_sysfs_del_one_qgroup(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_qgroup *qgroup)\n{\n\tif (test_bit(BTRFS_FS_STATE_DUMMY_FS_INFO, &fs_info->fs_state))\n\t\treturn;\n\n\tif (qgroup->kobj.state_initialized) {\n\t\tkobject_del(&qgroup->kobj);\n\t\tkobject_put(&qgroup->kobj);\n\t}\n}\n\n \nvoid btrfs_sysfs_feature_update(struct btrfs_fs_info *fs_info)\n{\n\tstruct kobject *fsid_kobj;\n\tint ret;\n\n\tif (!fs_info)\n\t\treturn;\n\n\tfsid_kobj = &fs_info->fs_devices->fsid_kobj;\n\tif (!fsid_kobj->state_initialized)\n\t\treturn;\n\n\tret = sysfs_update_group(fsid_kobj, &btrfs_feature_attr_group);\n\tif (ret < 0)\n\t\tbtrfs_warn(fs_info,\n\t\t\t   \"failed to update /sys/fs/btrfs/%pU/features: %d\",\n\t\t\t   fs_info->fs_devices->fsid, ret);\n}\n\nint __init btrfs_init_sysfs(void)\n{\n\tint ret;\n\n\tbtrfs_kset = kset_create_and_add(\"btrfs\", NULL, fs_kobj);\n\tif (!btrfs_kset)\n\t\treturn -ENOMEM;\n\n\tinit_feature_attrs();\n\tret = sysfs_create_group(&btrfs_kset->kobj, &btrfs_feature_attr_group);\n\tif (ret)\n\t\tgoto out2;\n\tret = sysfs_merge_group(&btrfs_kset->kobj,\n\t\t\t\t&btrfs_static_feature_attr_group);\n\tif (ret)\n\t\tgoto out_remove_group;\n\n#ifdef CONFIG_BTRFS_DEBUG\n\tret = sysfs_create_group(&btrfs_kset->kobj, &btrfs_debug_feature_attr_group);\n\tif (ret) {\n\t\tsysfs_unmerge_group(&btrfs_kset->kobj,\n\t\t\t\t    &btrfs_static_feature_attr_group);\n\t\tgoto out_remove_group;\n\t}\n#endif\n\n\treturn 0;\n\nout_remove_group:\n\tsysfs_remove_group(&btrfs_kset->kobj, &btrfs_feature_attr_group);\nout2:\n\tkset_unregister(btrfs_kset);\n\n\treturn ret;\n}\n\nvoid __cold btrfs_exit_sysfs(void)\n{\n\tsysfs_unmerge_group(&btrfs_kset->kobj,\n\t\t\t    &btrfs_static_feature_attr_group);\n\tsysfs_remove_group(&btrfs_kset->kobj, &btrfs_feature_attr_group);\n#ifdef CONFIG_BTRFS_DEBUG\n\tsysfs_remove_group(&btrfs_kset->kobj, &btrfs_debug_feature_attr_group);\n#endif\n\tkset_unregister(btrfs_kset);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}