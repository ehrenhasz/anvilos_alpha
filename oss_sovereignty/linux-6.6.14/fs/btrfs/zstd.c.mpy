{
  "module_name": "zstd.c",
  "hash_id": "94da4b84ae6ca7305898e75fd8b29c2bd45383cb9337c70ece5da5fdf6f720bd",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/zstd.c",
  "human_readable_source": "\n \n\n#include <linux/bio.h>\n#include <linux/bitmap.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/pagemap.h>\n#include <linux/refcount.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/zstd.h>\n#include \"misc.h\"\n#include \"compression.h\"\n#include \"ctree.h\"\n\n#define ZSTD_BTRFS_MAX_WINDOWLOG 17\n#define ZSTD_BTRFS_MAX_INPUT (1 << ZSTD_BTRFS_MAX_WINDOWLOG)\n#define ZSTD_BTRFS_DEFAULT_LEVEL 3\n#define ZSTD_BTRFS_MAX_LEVEL 15\n \n#define ZSTD_BTRFS_RECLAIM_JIFFIES (307 * HZ)\n\nstatic zstd_parameters zstd_get_btrfs_parameters(unsigned int level,\n\t\t\t\t\t\t size_t src_len)\n{\n\tzstd_parameters params = zstd_get_params(level, src_len);\n\n\tif (params.cParams.windowLog > ZSTD_BTRFS_MAX_WINDOWLOG)\n\t\tparams.cParams.windowLog = ZSTD_BTRFS_MAX_WINDOWLOG;\n\tWARN_ON(src_len > ZSTD_BTRFS_MAX_INPUT);\n\treturn params;\n}\n\nstruct workspace {\n\tvoid *mem;\n\tsize_t size;\n\tchar *buf;\n\tunsigned int level;\n\tunsigned int req_level;\n\tunsigned long last_used;  \n\tstruct list_head list;\n\tstruct list_head lru_list;\n\tzstd_in_buffer in_buf;\n\tzstd_out_buffer out_buf;\n};\n\n \n\nstruct zstd_workspace_manager {\n\tconst struct btrfs_compress_op *ops;\n\tspinlock_t lock;\n\tstruct list_head lru_list;\n\tstruct list_head idle_ws[ZSTD_BTRFS_MAX_LEVEL];\n\tunsigned long active_map;\n\twait_queue_head_t wait;\n\tstruct timer_list timer;\n};\n\nstatic struct zstd_workspace_manager wsm;\n\nstatic size_t zstd_ws_mem_sizes[ZSTD_BTRFS_MAX_LEVEL];\n\nstatic inline struct workspace *list_to_workspace(struct list_head *list)\n{\n\treturn container_of(list, struct workspace, list);\n}\n\nvoid zstd_free_workspace(struct list_head *ws);\nstruct list_head *zstd_alloc_workspace(unsigned int level);\n\n \nstatic void zstd_reclaim_timer_fn(struct timer_list *timer)\n{\n\tunsigned long reclaim_threshold = jiffies - ZSTD_BTRFS_RECLAIM_JIFFIES;\n\tstruct list_head *pos, *next;\n\n\tspin_lock(&wsm.lock);\n\n\tif (list_empty(&wsm.lru_list)) {\n\t\tspin_unlock(&wsm.lock);\n\t\treturn;\n\t}\n\n\tlist_for_each_prev_safe(pos, next, &wsm.lru_list) {\n\t\tstruct workspace *victim = container_of(pos, struct workspace,\n\t\t\t\t\t\t\tlru_list);\n\t\tunsigned int level;\n\n\t\tif (time_after(victim->last_used, reclaim_threshold))\n\t\t\tbreak;\n\n\t\t \n\t\tif (victim->req_level)\n\t\t\tcontinue;\n\n\t\tlevel = victim->level;\n\t\tlist_del(&victim->lru_list);\n\t\tlist_del(&victim->list);\n\t\tzstd_free_workspace(&victim->list);\n\n\t\tif (list_empty(&wsm.idle_ws[level - 1]))\n\t\t\tclear_bit(level - 1, &wsm.active_map);\n\n\t}\n\n\tif (!list_empty(&wsm.lru_list))\n\t\tmod_timer(&wsm.timer, jiffies + ZSTD_BTRFS_RECLAIM_JIFFIES);\n\n\tspin_unlock(&wsm.lock);\n}\n\n \nstatic void zstd_calc_ws_mem_sizes(void)\n{\n\tsize_t max_size = 0;\n\tunsigned int level;\n\n\tfor (level = 1; level <= ZSTD_BTRFS_MAX_LEVEL; level++) {\n\t\tzstd_parameters params =\n\t\t\tzstd_get_btrfs_parameters(level, ZSTD_BTRFS_MAX_INPUT);\n\t\tsize_t level_size =\n\t\t\tmax_t(size_t,\n\t\t\t      zstd_cstream_workspace_bound(&params.cParams),\n\t\t\t      zstd_dstream_workspace_bound(ZSTD_BTRFS_MAX_INPUT));\n\n\t\tmax_size = max_t(size_t, max_size, level_size);\n\t\tzstd_ws_mem_sizes[level - 1] = max_size;\n\t}\n}\n\nvoid zstd_init_workspace_manager(void)\n{\n\tstruct list_head *ws;\n\tint i;\n\n\tzstd_calc_ws_mem_sizes();\n\n\twsm.ops = &btrfs_zstd_compress;\n\tspin_lock_init(&wsm.lock);\n\tinit_waitqueue_head(&wsm.wait);\n\ttimer_setup(&wsm.timer, zstd_reclaim_timer_fn, 0);\n\n\tINIT_LIST_HEAD(&wsm.lru_list);\n\tfor (i = 0; i < ZSTD_BTRFS_MAX_LEVEL; i++)\n\t\tINIT_LIST_HEAD(&wsm.idle_ws[i]);\n\n\tws = zstd_alloc_workspace(ZSTD_BTRFS_MAX_LEVEL);\n\tif (IS_ERR(ws)) {\n\t\tpr_warn(\n\t\t\"BTRFS: cannot preallocate zstd compression workspace\\n\");\n\t} else {\n\t\tset_bit(ZSTD_BTRFS_MAX_LEVEL - 1, &wsm.active_map);\n\t\tlist_add(ws, &wsm.idle_ws[ZSTD_BTRFS_MAX_LEVEL - 1]);\n\t}\n}\n\nvoid zstd_cleanup_workspace_manager(void)\n{\n\tstruct workspace *workspace;\n\tint i;\n\n\tspin_lock_bh(&wsm.lock);\n\tfor (i = 0; i < ZSTD_BTRFS_MAX_LEVEL; i++) {\n\t\twhile (!list_empty(&wsm.idle_ws[i])) {\n\t\t\tworkspace = container_of(wsm.idle_ws[i].next,\n\t\t\t\t\t\t struct workspace, list);\n\t\t\tlist_del(&workspace->list);\n\t\t\tlist_del(&workspace->lru_list);\n\t\t\tzstd_free_workspace(&workspace->list);\n\t\t}\n\t}\n\tspin_unlock_bh(&wsm.lock);\n\n\tdel_timer_sync(&wsm.timer);\n}\n\n \nstatic struct list_head *zstd_find_workspace(unsigned int level)\n{\n\tstruct list_head *ws;\n\tstruct workspace *workspace;\n\tint i = level - 1;\n\n\tspin_lock_bh(&wsm.lock);\n\tfor_each_set_bit_from(i, &wsm.active_map, ZSTD_BTRFS_MAX_LEVEL) {\n\t\tif (!list_empty(&wsm.idle_ws[i])) {\n\t\t\tws = wsm.idle_ws[i].next;\n\t\t\tworkspace = list_to_workspace(ws);\n\t\t\tlist_del_init(ws);\n\t\t\t \n\t\t\tworkspace->req_level = level;\n\t\t\tif (level == workspace->level)\n\t\t\t\tlist_del(&workspace->lru_list);\n\t\t\tif (list_empty(&wsm.idle_ws[i]))\n\t\t\t\tclear_bit(i, &wsm.active_map);\n\t\t\tspin_unlock_bh(&wsm.lock);\n\t\t\treturn ws;\n\t\t}\n\t}\n\tspin_unlock_bh(&wsm.lock);\n\n\treturn NULL;\n}\n\n \nstruct list_head *zstd_get_workspace(unsigned int level)\n{\n\tstruct list_head *ws;\n\tunsigned int nofs_flag;\n\n\t \n\tif (!level)\n\t\tlevel = 1;\n\nagain:\n\tws = zstd_find_workspace(level);\n\tif (ws)\n\t\treturn ws;\n\n\tnofs_flag = memalloc_nofs_save();\n\tws = zstd_alloc_workspace(level);\n\tmemalloc_nofs_restore(nofs_flag);\n\n\tif (IS_ERR(ws)) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&wsm.wait, &wait, TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t\tfinish_wait(&wsm.wait, &wait);\n\n\t\tgoto again;\n\t}\n\n\treturn ws;\n}\n\n \nvoid zstd_put_workspace(struct list_head *ws)\n{\n\tstruct workspace *workspace = list_to_workspace(ws);\n\n\tspin_lock_bh(&wsm.lock);\n\n\t \n\tif (workspace->req_level == workspace->level) {\n\t\t \n\t\tif (list_empty(&wsm.idle_ws[ZSTD_BTRFS_MAX_LEVEL - 1])) {\n\t\t\tINIT_LIST_HEAD(&workspace->lru_list);\n\t\t} else {\n\t\t\tworkspace->last_used = jiffies;\n\t\t\tlist_add(&workspace->lru_list, &wsm.lru_list);\n\t\t\tif (!timer_pending(&wsm.timer))\n\t\t\t\tmod_timer(&wsm.timer,\n\t\t\t\t\t  jiffies + ZSTD_BTRFS_RECLAIM_JIFFIES);\n\t\t}\n\t}\n\n\tset_bit(workspace->level - 1, &wsm.active_map);\n\tlist_add(&workspace->list, &wsm.idle_ws[workspace->level - 1]);\n\tworkspace->req_level = 0;\n\n\tspin_unlock_bh(&wsm.lock);\n\n\tif (workspace->level == ZSTD_BTRFS_MAX_LEVEL)\n\t\tcond_wake_up(&wsm.wait);\n}\n\nvoid zstd_free_workspace(struct list_head *ws)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\n\tkvfree(workspace->mem);\n\tkfree(workspace->buf);\n\tkfree(workspace);\n}\n\nstruct list_head *zstd_alloc_workspace(unsigned int level)\n{\n\tstruct workspace *workspace;\n\n\tworkspace = kzalloc(sizeof(*workspace), GFP_KERNEL);\n\tif (!workspace)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tworkspace->size = zstd_ws_mem_sizes[level - 1];\n\tworkspace->level = level;\n\tworkspace->req_level = level;\n\tworkspace->last_used = jiffies;\n\tworkspace->mem = kvmalloc(workspace->size, GFP_KERNEL | __GFP_NOWARN);\n\tworkspace->buf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!workspace->mem || !workspace->buf)\n\t\tgoto fail;\n\n\tINIT_LIST_HEAD(&workspace->list);\n\tINIT_LIST_HEAD(&workspace->lru_list);\n\n\treturn &workspace->list;\nfail:\n\tzstd_free_workspace(&workspace->list);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nint zstd_compress_pages(struct list_head *ws, struct address_space *mapping,\n\t\tu64 start, struct page **pages, unsigned long *out_pages,\n\t\tunsigned long *total_in, unsigned long *total_out)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\tzstd_cstream *stream;\n\tint ret = 0;\n\tint nr_pages = 0;\n\tstruct page *in_page = NULL;   \n\tstruct page *out_page = NULL;  \n\tunsigned long tot_in = 0;\n\tunsigned long tot_out = 0;\n\tunsigned long len = *total_out;\n\tconst unsigned long nr_dest_pages = *out_pages;\n\tunsigned long max_out = nr_dest_pages * PAGE_SIZE;\n\tzstd_parameters params = zstd_get_btrfs_parameters(workspace->req_level,\n\t\t\t\t\t\t\t   len);\n\n\t*out_pages = 0;\n\t*total_out = 0;\n\t*total_in = 0;\n\n\t \n\tstream = zstd_init_cstream(&params, len, workspace->mem,\n\t\t\tworkspace->size);\n\tif (!stream) {\n\t\tpr_warn(\"BTRFS: zstd_init_cstream failed\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tin_page = find_get_page(mapping, start >> PAGE_SHIFT);\n\tworkspace->in_buf.src = kmap_local_page(in_page);\n\tworkspace->in_buf.pos = 0;\n\tworkspace->in_buf.size = min_t(size_t, len, PAGE_SIZE);\n\n\n\t \n\tout_page = alloc_page(GFP_NOFS);\n\tif (out_page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpages[nr_pages++] = out_page;\n\tworkspace->out_buf.dst = page_address(out_page);\n\tworkspace->out_buf.pos = 0;\n\tworkspace->out_buf.size = min_t(size_t, max_out, PAGE_SIZE);\n\n\twhile (1) {\n\t\tsize_t ret2;\n\n\t\tret2 = zstd_compress_stream(stream, &workspace->out_buf,\n\t\t\t\t&workspace->in_buf);\n\t\tif (zstd_is_error(ret2)) {\n\t\t\tpr_debug(\"BTRFS: zstd_compress_stream returned %d\\n\",\n\t\t\t\t\tzstd_get_error_code(ret2));\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (tot_in + workspace->in_buf.pos > 8192 &&\n\t\t\t\ttot_in + workspace->in_buf.pos <\n\t\t\t\ttot_out + workspace->out_buf.pos) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (workspace->out_buf.pos >= max_out) {\n\t\t\ttot_out += workspace->out_buf.pos;\n\t\t\tret = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (workspace->out_buf.pos == workspace->out_buf.size) {\n\t\t\ttot_out += PAGE_SIZE;\n\t\t\tmax_out -= PAGE_SIZE;\n\t\t\tif (nr_pages == nr_dest_pages) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tout_page = alloc_page(GFP_NOFS);\n\t\t\tif (out_page == NULL) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpages[nr_pages++] = out_page;\n\t\t\tworkspace->out_buf.dst = page_address(out_page);\n\t\t\tworkspace->out_buf.pos = 0;\n\t\t\tworkspace->out_buf.size = min_t(size_t, max_out,\n\t\t\t\t\t\t\tPAGE_SIZE);\n\t\t}\n\n\t\t \n\t\tif (workspace->in_buf.pos >= len) {\n\t\t\ttot_in += workspace->in_buf.pos;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (workspace->in_buf.pos == workspace->in_buf.size) {\n\t\t\ttot_in += PAGE_SIZE;\n\t\t\tkunmap_local(workspace->in_buf.src);\n\t\t\tput_page(in_page);\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen -= PAGE_SIZE;\n\t\t\tin_page = find_get_page(mapping, start >> PAGE_SHIFT);\n\t\t\tworkspace->in_buf.src = kmap_local_page(in_page);\n\t\t\tworkspace->in_buf.pos = 0;\n\t\t\tworkspace->in_buf.size = min_t(size_t, len, PAGE_SIZE);\n\t\t}\n\t}\n\twhile (1) {\n\t\tsize_t ret2;\n\n\t\tret2 = zstd_end_stream(stream, &workspace->out_buf);\n\t\tif (zstd_is_error(ret2)) {\n\t\t\tpr_debug(\"BTRFS: zstd_end_stream returned %d\\n\",\n\t\t\t\t\tzstd_get_error_code(ret2));\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret2 == 0) {\n\t\t\ttot_out += workspace->out_buf.pos;\n\t\t\tbreak;\n\t\t}\n\t\tif (workspace->out_buf.pos >= max_out) {\n\t\t\ttot_out += workspace->out_buf.pos;\n\t\t\tret = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttot_out += PAGE_SIZE;\n\t\tmax_out -= PAGE_SIZE;\n\t\tif (nr_pages == nr_dest_pages) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\t\tout_page = alloc_page(GFP_NOFS);\n\t\tif (out_page == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tpages[nr_pages++] = out_page;\n\t\tworkspace->out_buf.dst = page_address(out_page);\n\t\tworkspace->out_buf.pos = 0;\n\t\tworkspace->out_buf.size = min_t(size_t, max_out, PAGE_SIZE);\n\t}\n\n\tif (tot_out >= tot_in) {\n\t\tret = -E2BIG;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\t*total_in = tot_in;\n\t*total_out = tot_out;\nout:\n\t*out_pages = nr_pages;\n\tif (workspace->in_buf.src) {\n\t\tkunmap_local(workspace->in_buf.src);\n\t\tput_page(in_page);\n\t}\n\treturn ret;\n}\n\nint zstd_decompress_bio(struct list_head *ws, struct compressed_bio *cb)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\tstruct page **pages_in = cb->compressed_pages;\n\tsize_t srclen = cb->compressed_len;\n\tzstd_dstream *stream;\n\tint ret = 0;\n\tunsigned long page_in_index = 0;\n\tunsigned long total_pages_in = DIV_ROUND_UP(srclen, PAGE_SIZE);\n\tunsigned long buf_start;\n\tunsigned long total_out = 0;\n\n\tstream = zstd_init_dstream(\n\t\t\tZSTD_BTRFS_MAX_INPUT, workspace->mem, workspace->size);\n\tif (!stream) {\n\t\tpr_debug(\"BTRFS: zstd_init_dstream failed\\n\");\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\tworkspace->in_buf.src = kmap_local_page(pages_in[page_in_index]);\n\tworkspace->in_buf.pos = 0;\n\tworkspace->in_buf.size = min_t(size_t, srclen, PAGE_SIZE);\n\n\tworkspace->out_buf.dst = workspace->buf;\n\tworkspace->out_buf.pos = 0;\n\tworkspace->out_buf.size = PAGE_SIZE;\n\n\twhile (1) {\n\t\tsize_t ret2;\n\n\t\tret2 = zstd_decompress_stream(stream, &workspace->out_buf,\n\t\t\t\t&workspace->in_buf);\n\t\tif (zstd_is_error(ret2)) {\n\t\t\tpr_debug(\"BTRFS: zstd_decompress_stream returned %d\\n\",\n\t\t\t\t\tzstd_get_error_code(ret2));\n\t\t\tret = -EIO;\n\t\t\tgoto done;\n\t\t}\n\t\tbuf_start = total_out;\n\t\ttotal_out += workspace->out_buf.pos;\n\t\tworkspace->out_buf.pos = 0;\n\n\t\tret = btrfs_decompress_buf2page(workspace->out_buf.dst,\n\t\t\t\ttotal_out - buf_start, cb, buf_start);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\n\t\tif (workspace->in_buf.pos >= srclen)\n\t\t\tbreak;\n\n\t\t \n\t\tif (ret2 == 0)\n\t\t\tbreak;\n\n\t\tif (workspace->in_buf.pos == workspace->in_buf.size) {\n\t\t\tkunmap_local(workspace->in_buf.src);\n\t\t\tpage_in_index++;\n\t\t\tif (page_in_index >= total_pages_in) {\n\t\t\t\tworkspace->in_buf.src = NULL;\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tsrclen -= PAGE_SIZE;\n\t\t\tworkspace->in_buf.src = kmap_local_page(pages_in[page_in_index]);\n\t\t\tworkspace->in_buf.pos = 0;\n\t\t\tworkspace->in_buf.size = min_t(size_t, srclen, PAGE_SIZE);\n\t\t}\n\t}\n\tret = 0;\ndone:\n\tif (workspace->in_buf.src)\n\t\tkunmap_local(workspace->in_buf.src);\n\treturn ret;\n}\n\nint zstd_decompress(struct list_head *ws, const u8 *data_in,\n\t\tstruct page *dest_page, unsigned long start_byte, size_t srclen,\n\t\tsize_t destlen)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\tzstd_dstream *stream;\n\tint ret = 0;\n\tsize_t ret2;\n\tunsigned long total_out = 0;\n\tunsigned long pg_offset = 0;\n\n\tstream = zstd_init_dstream(\n\t\t\tZSTD_BTRFS_MAX_INPUT, workspace->mem, workspace->size);\n\tif (!stream) {\n\t\tpr_warn(\"BTRFS: zstd_init_dstream failed\\n\");\n\t\tret = -EIO;\n\t\tgoto finish;\n\t}\n\n\tdestlen = min_t(size_t, destlen, PAGE_SIZE);\n\n\tworkspace->in_buf.src = data_in;\n\tworkspace->in_buf.pos = 0;\n\tworkspace->in_buf.size = srclen;\n\n\tworkspace->out_buf.dst = workspace->buf;\n\tworkspace->out_buf.pos = 0;\n\tworkspace->out_buf.size = PAGE_SIZE;\n\n\tret2 = 1;\n\twhile (pg_offset < destlen\n\t       && workspace->in_buf.pos < workspace->in_buf.size) {\n\t\tunsigned long buf_start;\n\t\tunsigned long buf_offset;\n\t\tunsigned long bytes;\n\n\t\t \n\t\tif (ret2 == 0) {\n\t\t\tpr_debug(\"BTRFS: zstd_decompress_stream ended early\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto finish;\n\t\t}\n\t\tret2 = zstd_decompress_stream(stream, &workspace->out_buf,\n\t\t\t\t&workspace->in_buf);\n\t\tif (zstd_is_error(ret2)) {\n\t\t\tpr_debug(\"BTRFS: zstd_decompress_stream returned %d\\n\",\n\t\t\t\t\tzstd_get_error_code(ret2));\n\t\t\tret = -EIO;\n\t\t\tgoto finish;\n\t\t}\n\n\t\tbuf_start = total_out;\n\t\ttotal_out += workspace->out_buf.pos;\n\t\tworkspace->out_buf.pos = 0;\n\n\t\tif (total_out <= start_byte)\n\t\t\tcontinue;\n\n\t\tif (total_out > start_byte && buf_start < start_byte)\n\t\t\tbuf_offset = start_byte - buf_start;\n\t\telse\n\t\t\tbuf_offset = 0;\n\n\t\tbytes = min_t(unsigned long, destlen - pg_offset,\n\t\t\t\tworkspace->out_buf.size - buf_offset);\n\n\t\tmemcpy_to_page(dest_page, pg_offset,\n\t\t\t       workspace->out_buf.dst + buf_offset, bytes);\n\n\t\tpg_offset += bytes;\n\t}\n\tret = 0;\nfinish:\n\tif (pg_offset < destlen) {\n\t\tmemzero_page(dest_page, pg_offset, destlen - pg_offset);\n\t}\n\treturn ret;\n}\n\nconst struct btrfs_compress_op btrfs_zstd_compress = {\n\t \n\t.workspace_manager = NULL,\n\t.max_level\t= ZSTD_BTRFS_MAX_LEVEL,\n\t.default_level\t= ZSTD_BTRFS_DEFAULT_LEVEL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}