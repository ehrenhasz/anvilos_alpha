{
  "module_name": "misc.h",
  "hash_id": "bd75d8e6eea56dda1b9c751c953b628ee2800f2b0b2342e1485447be208a6b1f",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/misc.h",
  "human_readable_source": " \n\n#ifndef BTRFS_MISC_H\n#define BTRFS_MISC_H\n\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/math64.h>\n#include <linux/rbtree.h>\n\n \n#define ENUM_BIT(name)                                  \\\n\t__ ## name ## _BIT,                             \\\n\tname = (1U << __ ## name ## _BIT),              \\\n\t__ ## name ## _SEQ = __ ## name ## _BIT\n\nstatic inline void cond_wake_up(struct wait_queue_head *wq)\n{\n\t \n\tif (wq_has_sleeper(wq))\n\t\twake_up(wq);\n}\n\nstatic inline void cond_wake_up_nomb(struct wait_queue_head *wq)\n{\n\t \n\tif (waitqueue_active(wq))\n\t\twake_up(wq);\n}\n\nstatic inline u64 mult_perc(u64 num, u32 percent)\n{\n\treturn div_u64(num * percent, 100);\n}\n \nstatic inline bool is_power_of_two_u64(u64 n)\n{\n\treturn n != 0 && (n & (n - 1)) == 0;\n}\n\nstatic inline bool has_single_bit_set(u64 n)\n{\n\treturn is_power_of_two_u64(n);\n}\n\n \nstruct rb_simple_node {\n\tstruct rb_node rb_node;\n\tu64 bytenr;\n};\n\nstatic inline struct rb_node *rb_simple_search(struct rb_root *root, u64 bytenr)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct rb_simple_node *entry;\n\n\twhile (node) {\n\t\tentry = rb_entry(node, struct rb_simple_node, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tnode = node->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn node;\n\t}\n\treturn NULL;\n}\n\n \nstatic inline struct rb_node *rb_simple_search_first(struct rb_root *root,\n\t\t\t\t\t\t     u64 bytenr)\n{\n\tstruct rb_node *node = root->rb_node, *ret = NULL;\n\tstruct rb_simple_node *entry, *ret_entry = NULL;\n\n\twhile (node) {\n\t\tentry = rb_entry(node, struct rb_simple_node, rb_node);\n\n\t\tif (bytenr < entry->bytenr) {\n\t\t\tif (!ret || entry->bytenr < ret_entry->bytenr) {\n\t\t\t\tret = node;\n\t\t\t\tret_entry = entry;\n\t\t\t}\n\n\t\t\tnode = node->rb_left;\n\t\t} else if (bytenr > entry->bytenr) {\n\t\t\tnode = node->rb_right;\n\t\t} else {\n\t\t\treturn node;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic inline struct rb_node *rb_simple_insert(struct rb_root *root, u64 bytenr,\n\t\t\t\t\t       struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_simple_node *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct rb_simple_node, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}\n\nstatic inline bool bitmap_test_range_all_set(const unsigned long *addr,\n\t\t\t\t\t     unsigned long start,\n\t\t\t\t\t     unsigned long nbits)\n{\n\tunsigned long found_zero;\n\n\tfound_zero = find_next_zero_bit(addr, start + nbits, start);\n\treturn (found_zero == start + nbits);\n}\n\nstatic inline bool bitmap_test_range_all_zero(const unsigned long *addr,\n\t\t\t\t\t      unsigned long start,\n\t\t\t\t\t      unsigned long nbits)\n{\n\tunsigned long found_set;\n\n\tfound_set = find_next_bit(addr, start + nbits, start);\n\treturn (found_set == start + nbits);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}