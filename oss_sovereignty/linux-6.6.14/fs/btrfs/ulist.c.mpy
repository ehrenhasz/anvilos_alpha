{
  "module_name": "ulist.c",
  "hash_id": "f4453b381d35048533277485fc359f5312377bc40f436d88d6502abec7e5fec8",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/ulist.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include \"messages.h\"\n#include \"ulist.h\"\n#include \"ctree.h\"\n\n \n\n \nvoid ulist_init(struct ulist *ulist)\n{\n\tINIT_LIST_HEAD(&ulist->nodes);\n\tulist->root = RB_ROOT;\n\tulist->nnodes = 0;\n}\n\n \nvoid ulist_release(struct ulist *ulist)\n{\n\tstruct ulist_node *node;\n\tstruct ulist_node *next;\n\n\tlist_for_each_entry_safe(node, next, &ulist->nodes, list) {\n\t\tkfree(node);\n\t}\n\tulist->root = RB_ROOT;\n\tINIT_LIST_HEAD(&ulist->nodes);\n}\n\n \nvoid ulist_reinit(struct ulist *ulist)\n{\n\tulist_release(ulist);\n\tulist_init(ulist);\n}\n\n \nstruct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}\n\n \nvoid ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_release(ulist);\n\tkfree(ulist);\n}\n\nstatic struct ulist_node *ulist_rbtree_search(struct ulist *ulist, u64 val)\n{\n\tstruct rb_node *n = ulist->root.rb_node;\n\tstruct ulist_node *u = NULL;\n\n\twhile (n) {\n\t\tu = rb_entry(n, struct ulist_node, rb_node);\n\t\tif (u->val < val)\n\t\t\tn = n->rb_right;\n\t\telse if (u->val > val)\n\t\t\tn = n->rb_left;\n\t\telse\n\t\t\treturn u;\n\t}\n\treturn NULL;\n}\n\nstatic void ulist_rbtree_erase(struct ulist *ulist, struct ulist_node *node)\n{\n\trb_erase(&node->rb_node, &ulist->root);\n\tlist_del(&node->list);\n\tkfree(node);\n\tBUG_ON(ulist->nnodes == 0);\n\tulist->nnodes--;\n}\n\nstatic int ulist_rbtree_insert(struct ulist *ulist, struct ulist_node *ins)\n{\n\tstruct rb_node **p = &ulist->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ulist_node *cur = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tcur = rb_entry(parent, struct ulist_node, rb_node);\n\n\t\tif (cur->val < ins->val)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (cur->val > ins->val)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\trb_link_node(&ins->rb_node, parent, p);\n\trb_insert_color(&ins->rb_node, &ulist->root);\n\treturn 0;\n}\n\n \nint ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\n{\n\treturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\n}\n\nint ulist_add_merge(struct ulist *ulist, u64 val, u64 aux,\n\t\t    u64 *old_aux, gfp_t gfp_mask)\n{\n\tint ret;\n\tstruct ulist_node *node;\n\n\tnode = ulist_rbtree_search(ulist, val);\n\tif (node) {\n\t\tif (old_aux)\n\t\t\t*old_aux = node->aux;\n\t\treturn 0;\n\t}\n\tnode = kmalloc(sizeof(*node), gfp_mask);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tnode->val = val;\n\tnode->aux = aux;\n\n\tret = ulist_rbtree_insert(ulist, node);\n\tASSERT(!ret);\n\tlist_add_tail(&node->list, &ulist->nodes);\n\tulist->nnodes++;\n\n\treturn 1;\n}\n\n \nint ulist_del(struct ulist *ulist, u64 val, u64 aux)\n{\n\tstruct ulist_node *node;\n\n\tnode = ulist_rbtree_search(ulist, val);\n\t \n\tif (!node)\n\t\treturn 1;\n\n\tif (node->aux != aux)\n\t\treturn 1;\n\n\t \n\tulist_rbtree_erase(ulist, node);\n\treturn 0;\n}\n\n \nstruct ulist_node *ulist_next(const struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n\treturn node;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}