{
  "module_name": "props.c",
  "hash_id": "96e6eb0b637f97f820ec5f3e6f2aa86fd51228523fe9aebd9608de96a0f9325c",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/props.c",
  "human_readable_source": "\n \n\n#include <linux/hashtable.h>\n#include \"messages.h\"\n#include \"props.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include \"xattr.h\"\n#include \"compression.h\"\n#include \"space-info.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n#include \"super.h\"\n\n#define BTRFS_PROP_HANDLERS_HT_BITS 8\nstatic DEFINE_HASHTABLE(prop_handlers_ht, BTRFS_PROP_HANDLERS_HT_BITS);\n\nstruct prop_handler {\n\tstruct hlist_node node;\n\tconst char *xattr_name;\n\tint (*validate)(const struct btrfs_inode *inode, const char *value,\n\t\t\tsize_t len);\n\tint (*apply)(struct inode *inode, const char *value, size_t len);\n\tconst char *(*extract)(struct inode *inode);\n\tbool (*ignore)(const struct btrfs_inode *inode);\n\tint inheritable;\n};\n\nstatic const struct hlist_head *find_prop_handlers_by_hash(const u64 hash)\n{\n\tstruct hlist_head *h;\n\n\th = &prop_handlers_ht[hash_min(hash, BTRFS_PROP_HANDLERS_HT_BITS)];\n\tif (hlist_empty(h))\n\t\treturn NULL;\n\n\treturn h;\n}\n\nstatic const struct prop_handler *\nfind_prop_handler(const char *name,\n\t\t  const struct hlist_head *handlers)\n{\n\tstruct prop_handler *h;\n\n\tif (!handlers) {\n\t\tu64 hash = btrfs_name_hash(name, strlen(name));\n\n\t\thandlers = find_prop_handlers_by_hash(hash);\n\t\tif (!handlers)\n\t\t\treturn NULL;\n\t}\n\n\thlist_for_each_entry(h, handlers, node)\n\t\tif (!strcmp(h->xattr_name, name))\n\t\t\treturn h;\n\n\treturn NULL;\n}\n\nint btrfs_validate_prop(const struct btrfs_inode *inode, const char *name,\n\t\t\tconst char *value, size_t value_len)\n{\n\tconst struct prop_handler *handler;\n\n\tif (strlen(name) <= XATTR_BTRFS_PREFIX_LEN)\n\t\treturn -EINVAL;\n\n\thandler = find_prop_handler(name, NULL);\n\tif (!handler)\n\t\treturn -EINVAL;\n\n\tif (value_len == 0)\n\t\treturn 0;\n\n\treturn handler->validate(inode, value, value_len);\n}\n\n \nbool btrfs_ignore_prop(const struct btrfs_inode *inode, const char *name)\n{\n\tconst struct prop_handler *handler;\n\n\thandler = find_prop_handler(name, NULL);\n\tASSERT(handler != NULL);\n\n\treturn handler->ignore(inode);\n}\n\nint btrfs_set_prop(struct btrfs_trans_handle *trans, struct inode *inode,\n\t\t   const char *name, const char *value, size_t value_len,\n\t\t   int flags)\n{\n\tconst struct prop_handler *handler;\n\tint ret;\n\n\thandler = find_prop_handler(name, NULL);\n\tif (!handler)\n\t\treturn -EINVAL;\n\n\tif (value_len == 0) {\n\t\tret = btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t\t     NULL, 0, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = handler->apply(inode, NULL, 0);\n\t\tASSERT(ret == 0);\n\n\t\treturn ret;\n\t}\n\n\tret = btrfs_setxattr(trans, inode, handler->xattr_name, value,\n\t\t\t     value_len, flags);\n\tif (ret)\n\t\treturn ret;\n\tret = handler->apply(inode, value, value_len);\n\tif (ret) {\n\t\tbtrfs_setxattr(trans, inode, handler->xattr_name, NULL,\n\t\t\t       0, flags);\n\t\treturn ret;\n\t}\n\n\tset_bit(BTRFS_INODE_HAS_PROPS, &BTRFS_I(inode)->runtime_flags);\n\n\treturn 0;\n}\n\nstatic int iterate_object_props(struct btrfs_root *root,\n\t\t\t\tstruct btrfs_path *path,\n\t\t\t\tu64 objectid,\n\t\t\t\tvoid (*iterator)(void *,\n\t\t\t\t\t\t const struct prop_handler *,\n\t\t\t\t\t\t const char *,\n\t\t\t\t\t\t size_t),\n\t\t\t\tvoid *ctx)\n{\n\tint ret;\n\tchar *name_buf = NULL;\n\tchar *value_buf = NULL;\n\tint name_buf_len = 0;\n\tint value_buf_len = 0;\n\n\twhile (1) {\n\t\tstruct btrfs_key key;\n\t\tstruct btrfs_dir_item *di;\n\t\tstruct extent_buffer *leaf;\n\t\tu32 total_len, cur, this_len;\n\t\tint slot;\n\t\tconst struct hlist_head *handlers;\n\n\t\tslot = path->slots[0];\n\t\tleaf = path->nodes[0];\n\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid != objectid)\n\t\t\tbreak;\n\t\tif (key.type != BTRFS_XATTR_ITEM_KEY)\n\t\t\tbreak;\n\n\t\thandlers = find_prop_handlers_by_hash(key.offset);\n\t\tif (!handlers)\n\t\t\tgoto next_slot;\n\n\t\tdi = btrfs_item_ptr(leaf, slot, struct btrfs_dir_item);\n\t\tcur = 0;\n\t\ttotal_len = btrfs_item_size(leaf, slot);\n\n\t\twhile (cur < total_len) {\n\t\t\tu32 name_len = btrfs_dir_name_len(leaf, di);\n\t\t\tu32 data_len = btrfs_dir_data_len(leaf, di);\n\t\t\tunsigned long name_ptr, data_ptr;\n\t\t\tconst struct prop_handler *handler;\n\n\t\t\tthis_len = sizeof(*di) + name_len + data_len;\n\t\t\tname_ptr = (unsigned long)(di + 1);\n\t\t\tdata_ptr = name_ptr + name_len;\n\n\t\t\tif (name_len <= XATTR_BTRFS_PREFIX_LEN ||\n\t\t\t    memcmp_extent_buffer(leaf, XATTR_BTRFS_PREFIX,\n\t\t\t\t\t\t name_ptr,\n\t\t\t\t\t\t XATTR_BTRFS_PREFIX_LEN))\n\t\t\t\tgoto next_dir_item;\n\n\t\t\tif (name_len >= name_buf_len) {\n\t\t\t\tkfree(name_buf);\n\t\t\t\tname_buf_len = name_len + 1;\n\t\t\t\tname_buf = kmalloc(name_buf_len, GFP_NOFS);\n\t\t\t\tif (!name_buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tread_extent_buffer(leaf, name_buf, name_ptr, name_len);\n\t\t\tname_buf[name_len] = '\\0';\n\n\t\t\thandler = find_prop_handler(name_buf, handlers);\n\t\t\tif (!handler)\n\t\t\t\tgoto next_dir_item;\n\n\t\t\tif (data_len > value_buf_len) {\n\t\t\t\tkfree(value_buf);\n\t\t\t\tvalue_buf_len = data_len;\n\t\t\t\tvalue_buf = kmalloc(data_len, GFP_NOFS);\n\t\t\t\tif (!value_buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tread_extent_buffer(leaf, value_buf, data_ptr, data_len);\n\n\t\t\titerator(ctx, handler, value_buf, data_len);\nnext_dir_item:\n\t\t\tcur += this_len;\n\t\t\tdi = (struct btrfs_dir_item *)((char *) di + this_len);\n\t\t}\n\nnext_slot:\n\t\tpath->slots[0]++;\n\t}\n\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\tkfree(name_buf);\n\tkfree(value_buf);\n\n\treturn ret;\n}\n\nstatic void inode_prop_iterator(void *ctx,\n\t\t\t\tconst struct prop_handler *handler,\n\t\t\t\tconst char *value,\n\t\t\t\tsize_t len)\n{\n\tstruct inode *inode = ctx;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tret = handler->apply(inode, value, len);\n\tif (unlikely(ret))\n\t\tbtrfs_warn(root->fs_info,\n\t\t\t   \"error applying prop %s to ino %llu (root %llu): %d\",\n\t\t\t   handler->xattr_name, btrfs_ino(BTRFS_I(inode)),\n\t\t\t   root->root_key.objectid, ret);\n\telse\n\t\tset_bit(BTRFS_INODE_HAS_PROPS, &BTRFS_I(inode)->runtime_flags);\n}\n\nint btrfs_load_inode_props(struct inode *inode, struct btrfs_path *path)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tu64 ino = btrfs_ino(BTRFS_I(inode));\n\n\treturn iterate_object_props(root, path, ino, inode_prop_iterator, inode);\n}\n\nstatic int prop_compression_validate(const struct btrfs_inode *inode,\n\t\t\t\t     const char *value, size_t len)\n{\n\tif (!btrfs_inode_can_compress(inode))\n\t\treturn -EINVAL;\n\n\tif (!value)\n\t\treturn 0;\n\n\tif (btrfs_compress_is_valid_type(value, len))\n\t\treturn 0;\n\n\tif ((len == 2 && strncmp(\"no\", value, 2) == 0) ||\n\t    (len == 4 && strncmp(\"none\", value, 4) == 0))\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic int prop_compression_apply(struct inode *inode, const char *value,\n\t\t\t\t  size_t len)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tint type;\n\n\t \n\tif (len == 0) {\n\t\tBTRFS_I(inode)->flags &= ~BTRFS_INODE_COMPRESS;\n\t\tBTRFS_I(inode)->flags &= ~BTRFS_INODE_NOCOMPRESS;\n\t\tBTRFS_I(inode)->prop_compress = BTRFS_COMPRESS_NONE;\n\t\treturn 0;\n\t}\n\n\t \n\tif ((len == 2 && strncmp(\"no\", value, 2) == 0) ||\n\t    (len == 4 && strncmp(\"none\", value, 4) == 0)) {\n\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NOCOMPRESS;\n\t\tBTRFS_I(inode)->flags &= ~BTRFS_INODE_COMPRESS;\n\t\tBTRFS_I(inode)->prop_compress = BTRFS_COMPRESS_NONE;\n\n\t\treturn 0;\n\t}\n\n\tif (!strncmp(\"lzo\", value, 3)) {\n\t\ttype = BTRFS_COMPRESS_LZO;\n\t\tbtrfs_set_fs_incompat(fs_info, COMPRESS_LZO);\n\t} else if (!strncmp(\"zlib\", value, 4)) {\n\t\ttype = BTRFS_COMPRESS_ZLIB;\n\t} else if (!strncmp(\"zstd\", value, 4)) {\n\t\ttype = BTRFS_COMPRESS_ZSTD;\n\t\tbtrfs_set_fs_incompat(fs_info, COMPRESS_ZSTD);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tBTRFS_I(inode)->flags &= ~BTRFS_INODE_NOCOMPRESS;\n\tBTRFS_I(inode)->flags |= BTRFS_INODE_COMPRESS;\n\tBTRFS_I(inode)->prop_compress = type;\n\n\treturn 0;\n}\n\nstatic bool prop_compression_ignore(const struct btrfs_inode *inode)\n{\n\t \n\tif (!S_ISREG(inode->vfs_inode.i_mode) &&\n\t    !S_ISDIR(inode->vfs_inode.i_mode))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic const char *prop_compression_extract(struct inode *inode)\n{\n\tswitch (BTRFS_I(inode)->prop_compress) {\n\tcase BTRFS_COMPRESS_ZLIB:\n\tcase BTRFS_COMPRESS_LZO:\n\tcase BTRFS_COMPRESS_ZSTD:\n\t\treturn btrfs_compress_type2str(BTRFS_I(inode)->prop_compress);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct prop_handler prop_handlers[] = {\n\t{\n\t\t.xattr_name = XATTR_BTRFS_PREFIX \"compression\",\n\t\t.validate = prop_compression_validate,\n\t\t.apply = prop_compression_apply,\n\t\t.extract = prop_compression_extract,\n\t\t.ignore = prop_compression_ignore,\n\t\t.inheritable = 1\n\t},\n};\n\nint btrfs_inode_inherit_props(struct btrfs_trans_handle *trans,\n\t\t\t      struct inode *inode, struct inode *parent)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\tint i;\n\tbool need_reserve = false;\n\n\tif (!test_bit(BTRFS_INODE_HAS_PROPS,\n\t\t      &BTRFS_I(parent)->runtime_flags))\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(prop_handlers); i++) {\n\t\tconst struct prop_handler *h = &prop_handlers[i];\n\t\tconst char *value;\n\t\tu64 num_bytes = 0;\n\n\t\tif (!h->inheritable)\n\t\t\tcontinue;\n\n\t\tif (h->ignore(BTRFS_I(inode)))\n\t\t\tcontinue;\n\n\t\tvalue = h->extract(parent);\n\t\tif (!value)\n\t\t\tcontinue;\n\n\t\t \n\t\tret = h->validate(BTRFS_I(inode), value, strlen(value));\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (need_reserve) {\n\t\t\tnum_bytes = btrfs_calc_insert_metadata_size(fs_info, 1);\n\t\t\tret = btrfs_block_rsv_add(fs_info, trans->block_rsv,\n\t\t\t\t\t\t  num_bytes,\n\t\t\t\t\t\t  BTRFS_RESERVE_NO_FLUSH);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = btrfs_setxattr(trans, inode, h->xattr_name, value,\n\t\t\t\t     strlen(value), 0);\n\t\tif (!ret) {\n\t\t\tret = h->apply(inode, value, strlen(value));\n\t\t\tif (ret)\n\t\t\t\tbtrfs_setxattr(trans, inode, h->xattr_name,\n\t\t\t\t\t       NULL, 0, 0);\n\t\t\telse\n\t\t\t\tset_bit(BTRFS_INODE_HAS_PROPS,\n\t\t\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\t}\n\n\t\tif (need_reserve) {\n\t\t\tbtrfs_block_rsv_release(fs_info, trans->block_rsv,\n\t\t\t\t\tnum_bytes, NULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tneed_reserve = true;\n\t}\n\n\treturn 0;\n}\n\nint __init btrfs_props_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(prop_handlers); i++) {\n\t\tstruct prop_handler *p = &prop_handlers[i];\n\t\tu64 h = btrfs_name_hash(p->xattr_name, strlen(p->xattr_name));\n\n\t\thash_add(prop_handlers_ht, &p->node, h);\n\t}\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}