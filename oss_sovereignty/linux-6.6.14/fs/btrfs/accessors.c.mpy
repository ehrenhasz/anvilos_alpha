{
  "module_name": "accessors.c",
  "hash_id": "b2799befb4c237f3672f07985570b8559723a2a65a22ca40091ca974699a048d",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/accessors.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include \"messages.h\"\n#include \"ctree.h\"\n#include \"accessors.h\"\n\nstatic bool check_setget_bounds(const struct extent_buffer *eb,\n\t\t\t\tconst void *ptr, unsigned off, int size)\n{\n\tconst unsigned long member_offset = (unsigned long)ptr + off;\n\n\tif (unlikely(member_offset + size > eb->len)) {\n\t\tbtrfs_warn(eb->fs_info,\n\t\t\"bad eb member %s: ptr 0x%lx start %llu member offset %lu size %d\",\n\t\t\t(member_offset > eb->len ? \"start\" : \"end\"),\n\t\t\t(unsigned long)ptr, eb->start, member_offset, size);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid btrfs_init_map_token(struct btrfs_map_token *token, struct extent_buffer *eb)\n{\n\ttoken->eb = eb;\n\ttoken->kaddr = page_address(eb->pages[0]);\n\ttoken->offset = 0;\n}\n\n \n\n#define DEFINE_BTRFS_SETGET_BITS(bits)\t\t\t\t\t\\\nu##bits btrfs_get_token_##bits(struct btrfs_map_token *token,\t\t\\\n\t\t\t       const void *ptr, unsigned long off)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tconst unsigned long member_offset = (unsigned long)ptr + off;\t\\\n\tconst unsigned long idx = get_eb_page_index(member_offset);\t\\\n\tconst unsigned long oip = get_eb_offset_in_page(token->eb,\t\\\n\t\t\t\t\t\t\tmember_offset);\t\\\n\tconst int size = sizeof(u##bits);\t\t\t\t\\\n\tu8 lebytes[sizeof(u##bits)];\t\t\t\t\t\\\n\tconst int part = PAGE_SIZE - oip;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tASSERT(token);\t\t\t\t\t\t\t\\\n\tASSERT(token->kaddr);\t\t\t\t\t\t\\\n\tASSERT(check_setget_bounds(token->eb, ptr, off, size));\t\t\\\n\tif (token->offset <= member_offset &&\t\t\t\t\\\n\t    member_offset + size <= token->offset + PAGE_SIZE) {\t\\\n\t\treturn get_unaligned_le##bits(token->kaddr + oip);\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\ttoken->kaddr = page_address(token->eb->pages[idx]);\t\t\\\n\ttoken->offset = idx << PAGE_SHIFT;\t\t\t\t\\\n\tif (INLINE_EXTENT_BUFFER_PAGES == 1 || oip + size <= PAGE_SIZE ) \\\n\t\treturn get_unaligned_le##bits(token->kaddr + oip);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmemcpy(lebytes, token->kaddr + oip, part);\t\t\t\\\n\ttoken->kaddr = page_address(token->eb->pages[idx + 1]);\t\t\\\n\ttoken->offset = (idx + 1) << PAGE_SHIFT;\t\t\t\\\n\tmemcpy(lebytes + part, token->kaddr, size - part);\t\t\\\n\treturn get_unaligned_le##bits(lebytes);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nu##bits btrfs_get_##bits(const struct extent_buffer *eb,\t\t\\\n\t\t\t const void *ptr, unsigned long off)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tconst unsigned long member_offset = (unsigned long)ptr + off;\t\\\n\tconst unsigned long oip = get_eb_offset_in_page(eb, member_offset); \\\n\tconst unsigned long idx = get_eb_page_index(member_offset);\t\\\n\tchar *kaddr = page_address(eb->pages[idx]);\t\t\t\\\n\tconst int size = sizeof(u##bits);\t\t\t\t\\\n\tconst int part = PAGE_SIZE - oip;\t\t\t\t\\\n\tu8 lebytes[sizeof(u##bits)];\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tASSERT(check_setget_bounds(eb, ptr, off, size));\t\t\\\n\tif (INLINE_EXTENT_BUFFER_PAGES == 1 || oip + size <= PAGE_SIZE)\t\\\n\t\treturn get_unaligned_le##bits(kaddr + oip);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmemcpy(lebytes, kaddr + oip, part);\t\t\t\t\\\n\tkaddr = page_address(eb->pages[idx + 1]);\t\t\t\\\n\tmemcpy(lebytes + part, kaddr, size - part);\t\t\t\\\n\treturn get_unaligned_le##bits(lebytes);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nvoid btrfs_set_token_##bits(struct btrfs_map_token *token,\t\t\\\n\t\t\t    const void *ptr, unsigned long off,\t\t\\\n\t\t\t    u##bits val)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tconst unsigned long member_offset = (unsigned long)ptr + off;\t\\\n\tconst unsigned long idx = get_eb_page_index(member_offset);\t\\\n\tconst unsigned long oip = get_eb_offset_in_page(token->eb,\t\\\n\t\t\t\t\t\t\tmember_offset);\t\\\n\tconst int size = sizeof(u##bits);\t\t\t\t\\\n\tu8 lebytes[sizeof(u##bits)];\t\t\t\t\t\\\n\tconst int part = PAGE_SIZE - oip;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tASSERT(token);\t\t\t\t\t\t\t\\\n\tASSERT(token->kaddr);\t\t\t\t\t\t\\\n\tASSERT(check_setget_bounds(token->eb, ptr, off, size));\t\t\\\n\tif (token->offset <= member_offset &&\t\t\t\t\\\n\t    member_offset + size <= token->offset + PAGE_SIZE) {\t\\\n\t\tput_unaligned_le##bits(val, token->kaddr + oip);\t\\\n\t\treturn;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\ttoken->kaddr = page_address(token->eb->pages[idx]);\t\t\\\n\ttoken->offset = idx << PAGE_SHIFT;\t\t\t\t\\\n\tif (INLINE_EXTENT_BUFFER_PAGES == 1 || oip + size <= PAGE_SIZE) { \\\n\t\tput_unaligned_le##bits(val, token->kaddr + oip);\t\\\n\t\treturn;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tput_unaligned_le##bits(val, lebytes);\t\t\t\t\\\n\tmemcpy(token->kaddr + oip, lebytes, part);\t\t\t\\\n\ttoken->kaddr = page_address(token->eb->pages[idx + 1]);\t\t\\\n\ttoken->offset = (idx + 1) << PAGE_SHIFT;\t\t\t\\\n\tmemcpy(token->kaddr, lebytes + part, size - part);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nvoid btrfs_set_##bits(const struct extent_buffer *eb, void *ptr,\t\\\n\t\t      unsigned long off, u##bits val)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tconst unsigned long member_offset = (unsigned long)ptr + off;\t\\\n\tconst unsigned long oip = get_eb_offset_in_page(eb, member_offset); \\\n\tconst unsigned long idx = get_eb_page_index(member_offset);\t\\\n\tchar *kaddr = page_address(eb->pages[idx]);\t\t\t\\\n\tconst int size = sizeof(u##bits);\t\t\t\t\\\n\tconst int part = PAGE_SIZE - oip;\t\t\t\t\\\n\tu8 lebytes[sizeof(u##bits)];\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tASSERT(check_setget_bounds(eb, ptr, off, size));\t\t\\\n\tif (INLINE_EXTENT_BUFFER_PAGES == 1 || oip + size <= PAGE_SIZE) { \\\n\t\tput_unaligned_le##bits(val, kaddr + oip);\t\t\\\n\t\treturn;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tput_unaligned_le##bits(val, lebytes);\t\t\t\t\\\n\tmemcpy(kaddr + oip, lebytes, part);\t\t\t\t\\\n\tkaddr = page_address(eb->pages[idx + 1]);\t\t\t\\\n\tmemcpy(kaddr, lebytes + part, size - part);\t\t\t\\\n}\n\nDEFINE_BTRFS_SETGET_BITS(8)\nDEFINE_BTRFS_SETGET_BITS(16)\nDEFINE_BTRFS_SETGET_BITS(32)\nDEFINE_BTRFS_SETGET_BITS(64)\n\nvoid btrfs_node_key(const struct extent_buffer *eb,\n\t\t    struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr = btrfs_node_key_ptr_offset(eb, nr);\n\tread_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}