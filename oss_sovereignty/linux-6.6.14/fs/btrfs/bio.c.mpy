{
  "module_name": "bio.c",
  "hash_id": "8b91e21e2aa7bb8de4e96e264cfff557cfa30743084aa5069636e5054764fbb8",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/bio.c",
  "human_readable_source": "\n \n\n#include <linux/bio.h>\n#include \"bio.h\"\n#include \"ctree.h\"\n#include \"volumes.h\"\n#include \"raid56.h\"\n#include \"async-thread.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"zoned.h\"\n#include \"file-item.h\"\n\nstatic struct bio_set btrfs_bioset;\nstatic struct bio_set btrfs_clone_bioset;\nstatic struct bio_set btrfs_repair_bioset;\nstatic mempool_t btrfs_failed_bio_pool;\n\nstruct btrfs_failed_bio {\n\tstruct btrfs_bio *bbio;\n\tint num_copies;\n\tatomic_t repair_count;\n};\n\n \nstatic inline bool is_data_bbio(struct btrfs_bio *bbio)\n{\n\treturn bbio->inode && is_data_inode(&bbio->inode->vfs_inode);\n}\n\nstatic bool bbio_has_ordered_extent(struct btrfs_bio *bbio)\n{\n\treturn is_data_bbio(bbio) && btrfs_op(&bbio->bio) == BTRFS_MAP_WRITE;\n}\n\n \nvoid btrfs_bio_init(struct btrfs_bio *bbio, struct btrfs_fs_info *fs_info,\n\t\t    btrfs_bio_end_io_t end_io, void *private)\n{\n\tmemset(bbio, 0, offsetof(struct btrfs_bio, bio));\n\tbbio->fs_info = fs_info;\n\tbbio->end_io = end_io;\n\tbbio->private = private;\n\tatomic_set(&bbio->pending_ios, 1);\n}\n\n \nstruct btrfs_bio *btrfs_bio_alloc(unsigned int nr_vecs, blk_opf_t opf,\n\t\t\t\t  struct btrfs_fs_info *fs_info,\n\t\t\t\t  btrfs_bio_end_io_t end_io, void *private)\n{\n\tstruct btrfs_bio *bbio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(NULL, nr_vecs, opf, GFP_NOFS, &btrfs_bioset);\n\tbbio = btrfs_bio(bio);\n\tbtrfs_bio_init(bbio, fs_info, end_io, private);\n\treturn bbio;\n}\n\nstatic struct btrfs_bio *btrfs_split_bio(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t struct btrfs_bio *orig_bbio,\n\t\t\t\t\t u64 map_length, bool use_append)\n{\n\tstruct btrfs_bio *bbio;\n\tstruct bio *bio;\n\n\tif (use_append) {\n\t\tunsigned int nr_segs;\n\n\t\tbio = bio_split_rw(&orig_bbio->bio, &fs_info->limits, &nr_segs,\n\t\t\t\t   &btrfs_clone_bioset, map_length);\n\t} else {\n\t\tbio = bio_split(&orig_bbio->bio, map_length >> SECTOR_SHIFT,\n\t\t\t\tGFP_NOFS, &btrfs_clone_bioset);\n\t}\n\tbbio = btrfs_bio(bio);\n\tbtrfs_bio_init(bbio, fs_info, NULL, orig_bbio);\n\tbbio->inode = orig_bbio->inode;\n\tbbio->file_offset = orig_bbio->file_offset;\n\torig_bbio->file_offset += map_length;\n\tif (bbio_has_ordered_extent(bbio)) {\n\t\trefcount_inc(&orig_bbio->ordered->refs);\n\t\tbbio->ordered = orig_bbio->ordered;\n\t}\n\tatomic_inc(&orig_bbio->pending_ios);\n\treturn bbio;\n}\n\n \nstatic void btrfs_cleanup_bio(struct btrfs_bio *bbio)\n{\n\tif (bbio_has_ordered_extent(bbio))\n\t\tbtrfs_put_ordered_extent(bbio->ordered);\n\tbio_put(&bbio->bio);\n}\n\nstatic void __btrfs_bio_end_io(struct btrfs_bio *bbio)\n{\n\tif (bbio_has_ordered_extent(bbio)) {\n\t\tstruct btrfs_ordered_extent *ordered = bbio->ordered;\n\n\t\tbbio->end_io(bbio);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t} else {\n\t\tbbio->end_io(bbio);\n\t}\n}\n\nvoid btrfs_bio_end_io(struct btrfs_bio *bbio, blk_status_t status)\n{\n\tbbio->bio.bi_status = status;\n\t__btrfs_bio_end_io(bbio);\n}\n\nstatic void btrfs_orig_write_end_io(struct bio *bio);\n\nstatic void btrfs_bbio_propagate_error(struct btrfs_bio *bbio,\n\t\t\t\t       struct btrfs_bio *orig_bbio)\n{\n\t \n\tif (bbio->bio.bi_end_io == &btrfs_orig_write_end_io) {\n\t\tstruct btrfs_io_stripe *orig_stripe = orig_bbio->bio.bi_private;\n\t\tstruct btrfs_io_context *orig_bioc = orig_stripe->bioc;\n\n\t\tatomic_add(orig_bioc->max_errors, &orig_bioc->error);\n\t} else {\n\t\torig_bbio->bio.bi_status = bbio->bio.bi_status;\n\t}\n}\n\nstatic void btrfs_orig_bbio_end_io(struct btrfs_bio *bbio)\n{\n\tif (bbio->bio.bi_pool == &btrfs_clone_bioset) {\n\t\tstruct btrfs_bio *orig_bbio = bbio->private;\n\n\t\tif (bbio->bio.bi_status)\n\t\t\tbtrfs_bbio_propagate_error(bbio, orig_bbio);\n\t\tbtrfs_cleanup_bio(bbio);\n\t\tbbio = orig_bbio;\n\t}\n\n\tif (atomic_dec_and_test(&bbio->pending_ios))\n\t\t__btrfs_bio_end_io(bbio);\n}\n\nstatic int next_repair_mirror(struct btrfs_failed_bio *fbio, int cur_mirror)\n{\n\tif (cur_mirror == fbio->num_copies)\n\t\treturn cur_mirror + 1 - fbio->num_copies;\n\treturn cur_mirror + 1;\n}\n\nstatic int prev_repair_mirror(struct btrfs_failed_bio *fbio, int cur_mirror)\n{\n\tif (cur_mirror == 1)\n\t\treturn fbio->num_copies;\n\treturn cur_mirror - 1;\n}\n\nstatic void btrfs_repair_done(struct btrfs_failed_bio *fbio)\n{\n\tif (atomic_dec_and_test(&fbio->repair_count)) {\n\t\tbtrfs_orig_bbio_end_io(fbio->bbio);\n\t\tmempool_free(fbio, &btrfs_failed_bio_pool);\n\t}\n}\n\nstatic void btrfs_end_repair_bio(struct btrfs_bio *repair_bbio,\n\t\t\t\t struct btrfs_device *dev)\n{\n\tstruct btrfs_failed_bio *fbio = repair_bbio->private;\n\tstruct btrfs_inode *inode = repair_bbio->inode;\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tstruct bio_vec *bv = bio_first_bvec_all(&repair_bbio->bio);\n\tint mirror = repair_bbio->mirror_num;\n\n\tif (repair_bbio->bio.bi_status ||\n\t    !btrfs_data_csum_ok(repair_bbio, dev, 0, bv)) {\n\t\tbio_reset(&repair_bbio->bio, NULL, REQ_OP_READ);\n\t\trepair_bbio->bio.bi_iter = repair_bbio->saved_iter;\n\n\t\tmirror = next_repair_mirror(fbio, mirror);\n\t\tif (mirror == fbio->bbio->mirror_num) {\n\t\t\tbtrfs_debug(fs_info, \"no mirror left\");\n\t\t\tfbio->bbio->bio.bi_status = BLK_STS_IOERR;\n\t\t\tgoto done;\n\t\t}\n\n\t\tbtrfs_submit_bio(repair_bbio, mirror);\n\t\treturn;\n\t}\n\n\tdo {\n\t\tmirror = prev_repair_mirror(fbio, mirror);\n\t\tbtrfs_repair_io_failure(fs_info, btrfs_ino(inode),\n\t\t\t\t  repair_bbio->file_offset, fs_info->sectorsize,\n\t\t\t\t  repair_bbio->saved_iter.bi_sector << SECTOR_SHIFT,\n\t\t\t\t  bv->bv_page, bv->bv_offset, mirror);\n\t} while (mirror != fbio->bbio->mirror_num);\n\ndone:\n\tbtrfs_repair_done(fbio);\n\tbio_put(&repair_bbio->bio);\n}\n\n \nstatic struct btrfs_failed_bio *repair_one_sector(struct btrfs_bio *failed_bbio,\n\t\t\t\t\t\t  u32 bio_offset,\n\t\t\t\t\t\t  struct bio_vec *bv,\n\t\t\t\t\t\t  struct btrfs_failed_bio *fbio)\n{\n\tstruct btrfs_inode *inode = failed_bbio->inode;\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tconst u32 sectorsize = fs_info->sectorsize;\n\tconst u64 logical = (failed_bbio->saved_iter.bi_sector << SECTOR_SHIFT);\n\tstruct btrfs_bio *repair_bbio;\n\tstruct bio *repair_bio;\n\tint num_copies;\n\tint mirror;\n\n\tbtrfs_debug(fs_info, \"repair read error: read error at %llu\",\n\t\t    failed_bbio->file_offset + bio_offset);\n\n\tnum_copies = btrfs_num_copies(fs_info, logical, sectorsize);\n\tif (num_copies == 1) {\n\t\tbtrfs_debug(fs_info, \"no copy to repair from\");\n\t\tfailed_bbio->bio.bi_status = BLK_STS_IOERR;\n\t\treturn fbio;\n\t}\n\n\tif (!fbio) {\n\t\tfbio = mempool_alloc(&btrfs_failed_bio_pool, GFP_NOFS);\n\t\tfbio->bbio = failed_bbio;\n\t\tfbio->num_copies = num_copies;\n\t\tatomic_set(&fbio->repair_count, 1);\n\t}\n\n\tatomic_inc(&fbio->repair_count);\n\n\trepair_bio = bio_alloc_bioset(NULL, 1, REQ_OP_READ, GFP_NOFS,\n\t\t\t\t      &btrfs_repair_bioset);\n\trepair_bio->bi_iter.bi_sector = failed_bbio->saved_iter.bi_sector;\n\t__bio_add_page(repair_bio, bv->bv_page, bv->bv_len, bv->bv_offset);\n\n\trepair_bbio = btrfs_bio(repair_bio);\n\tbtrfs_bio_init(repair_bbio, fs_info, NULL, fbio);\n\trepair_bbio->inode = failed_bbio->inode;\n\trepair_bbio->file_offset = failed_bbio->file_offset + bio_offset;\n\n\tmirror = next_repair_mirror(fbio, failed_bbio->mirror_num);\n\tbtrfs_debug(fs_info, \"submitting repair read to mirror %d\", mirror);\n\tbtrfs_submit_bio(repair_bbio, mirror);\n\treturn fbio;\n}\n\nstatic void btrfs_check_read_bio(struct btrfs_bio *bbio, struct btrfs_device *dev)\n{\n\tstruct btrfs_inode *inode = bbio->inode;\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tu32 sectorsize = fs_info->sectorsize;\n\tstruct bvec_iter *iter = &bbio->saved_iter;\n\tblk_status_t status = bbio->bio.bi_status;\n\tstruct btrfs_failed_bio *fbio = NULL;\n\tu32 offset = 0;\n\n\t \n\tASSERT(inode);\n\n\t \n\tif (bbio->bio.bi_pool == &btrfs_repair_bioset) {\n\t\tbtrfs_end_repair_bio(bbio, dev);\n\t\treturn;\n\t}\n\n\t \n\tbbio->bio.bi_status = BLK_STS_OK;\n\n\twhile (iter->bi_size) {\n\t\tstruct bio_vec bv = bio_iter_iovec(&bbio->bio, *iter);\n\n\t\tbv.bv_len = min(bv.bv_len, sectorsize);\n\t\tif (status || !btrfs_data_csum_ok(bbio, dev, offset, &bv))\n\t\t\tfbio = repair_one_sector(bbio, offset, &bv, fbio);\n\n\t\tbio_advance_iter_single(&bbio->bio, iter, sectorsize);\n\t\toffset += sectorsize;\n\t}\n\n\tif (bbio->csum != bbio->csum_inline)\n\t\tkfree(bbio->csum);\n\n\tif (fbio)\n\t\tbtrfs_repair_done(fbio);\n\telse\n\t\tbtrfs_orig_bbio_end_io(bbio);\n}\n\nstatic void btrfs_log_dev_io_error(struct bio *bio, struct btrfs_device *dev)\n{\n\tif (!dev || !dev->bdev)\n\t\treturn;\n\tif (bio->bi_status != BLK_STS_IOERR && bio->bi_status != BLK_STS_TARGET)\n\t\treturn;\n\n\tif (btrfs_op(bio) == BTRFS_MAP_WRITE)\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_WRITE_ERRS);\n\telse if (!(bio->bi_opf & REQ_RAHEAD))\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_READ_ERRS);\n\tif (bio->bi_opf & REQ_PREFLUSH)\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_FLUSH_ERRS);\n}\n\nstatic struct workqueue_struct *btrfs_end_io_wq(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct bio *bio)\n{\n\tif (bio->bi_opf & REQ_META)\n\t\treturn fs_info->endio_meta_workers;\n\treturn fs_info->endio_workers;\n}\n\nstatic void btrfs_end_bio_work(struct work_struct *work)\n{\n\tstruct btrfs_bio *bbio = container_of(work, struct btrfs_bio, end_io_work);\n\n\t \n\tif (is_data_bbio(bbio))\n\t\tbtrfs_check_read_bio(bbio, bbio->bio.bi_private);\n\telse\n\t\tbtrfs_orig_bbio_end_io(bbio);\n}\n\nstatic void btrfs_simple_end_io(struct bio *bio)\n{\n\tstruct btrfs_bio *bbio = btrfs_bio(bio);\n\tstruct btrfs_device *dev = bio->bi_private;\n\tstruct btrfs_fs_info *fs_info = bbio->fs_info;\n\n\tbtrfs_bio_counter_dec(fs_info);\n\n\tif (bio->bi_status)\n\t\tbtrfs_log_dev_io_error(bio, dev);\n\n\tif (bio_op(bio) == REQ_OP_READ) {\n\t\tINIT_WORK(&bbio->end_io_work, btrfs_end_bio_work);\n\t\tqueue_work(btrfs_end_io_wq(fs_info, bio), &bbio->end_io_work);\n\t} else {\n\t\tif (bio_op(bio) == REQ_OP_ZONE_APPEND && !bio->bi_status)\n\t\t\tbtrfs_record_physical_zoned(bbio);\n\t\tbtrfs_orig_bbio_end_io(bbio);\n\t}\n}\n\nstatic void btrfs_raid56_end_io(struct bio *bio)\n{\n\tstruct btrfs_io_context *bioc = bio->bi_private;\n\tstruct btrfs_bio *bbio = btrfs_bio(bio);\n\n\tbtrfs_bio_counter_dec(bioc->fs_info);\n\tbbio->mirror_num = bioc->mirror_num;\n\tif (bio_op(bio) == REQ_OP_READ && is_data_bbio(bbio))\n\t\tbtrfs_check_read_bio(bbio, NULL);\n\telse\n\t\tbtrfs_orig_bbio_end_io(bbio);\n\n\tbtrfs_put_bioc(bioc);\n}\n\nstatic void btrfs_orig_write_end_io(struct bio *bio)\n{\n\tstruct btrfs_io_stripe *stripe = bio->bi_private;\n\tstruct btrfs_io_context *bioc = stripe->bioc;\n\tstruct btrfs_bio *bbio = btrfs_bio(bio);\n\n\tbtrfs_bio_counter_dec(bioc->fs_info);\n\n\tif (bio->bi_status) {\n\t\tatomic_inc(&bioc->error);\n\t\tbtrfs_log_dev_io_error(bio, stripe->dev);\n\t}\n\n\t \n\tif (atomic_read(&bioc->error) > bioc->max_errors)\n\t\tbio->bi_status = BLK_STS_IOERR;\n\telse\n\t\tbio->bi_status = BLK_STS_OK;\n\n\tbtrfs_orig_bbio_end_io(bbio);\n\tbtrfs_put_bioc(bioc);\n}\n\nstatic void btrfs_clone_write_end_io(struct bio *bio)\n{\n\tstruct btrfs_io_stripe *stripe = bio->bi_private;\n\n\tif (bio->bi_status) {\n\t\tatomic_inc(&stripe->bioc->error);\n\t\tbtrfs_log_dev_io_error(bio, stripe->dev);\n\t}\n\n\t \n\tbio_endio(stripe->bioc->orig_bio);\n\tbio_put(bio);\n}\n\nstatic void btrfs_submit_dev_bio(struct btrfs_device *dev, struct bio *bio)\n{\n\tif (!dev || !dev->bdev ||\n\t    test_bit(BTRFS_DEV_STATE_MISSING, &dev->dev_state) ||\n\t    (btrfs_op(bio) == BTRFS_MAP_WRITE &&\n\t     !test_bit(BTRFS_DEV_STATE_WRITEABLE, &dev->dev_state))) {\n\t\tbio_io_error(bio);\n\t\treturn;\n\t}\n\n\tbio_set_dev(bio, dev->bdev);\n\n\t \n\tif (bio_op(bio) == REQ_OP_ZONE_APPEND) {\n\t\tu64 physical = bio->bi_iter.bi_sector << SECTOR_SHIFT;\n\t\tu64 zone_start = round_down(physical, dev->fs_info->zone_size);\n\n\t\tASSERT(btrfs_dev_is_sequential(dev, physical));\n\t\tbio->bi_iter.bi_sector = zone_start >> SECTOR_SHIFT;\n\t}\n\tbtrfs_debug_in_rcu(dev->fs_info,\n\t\"%s: rw %d 0x%x, sector=%llu, dev=%lu (%s id %llu), size=%u\",\n\t\t__func__, bio_op(bio), bio->bi_opf, bio->bi_iter.bi_sector,\n\t\t(unsigned long)dev->bdev->bd_dev, btrfs_dev_name(dev),\n\t\tdev->devid, bio->bi_iter.bi_size);\n\n\tbtrfsic_check_bio(bio);\n\n\tif (bio->bi_opf & REQ_BTRFS_CGROUP_PUNT)\n\t\tblkcg_punt_bio_submit(bio);\n\telse\n\t\tsubmit_bio(bio);\n}\n\nstatic void btrfs_submit_mirrored_bio(struct btrfs_io_context *bioc, int dev_nr)\n{\n\tstruct bio *orig_bio = bioc->orig_bio, *bio;\n\n\tASSERT(bio_op(orig_bio) != REQ_OP_READ);\n\n\t \n\tif (dev_nr == bioc->num_stripes - 1) {\n\t\tbio = orig_bio;\n\t\tbio->bi_end_io = btrfs_orig_write_end_io;\n\t} else {\n\t\tbio = bio_alloc_clone(NULL, orig_bio, GFP_NOFS, &fs_bio_set);\n\t\tbio_inc_remaining(orig_bio);\n\t\tbio->bi_end_io = btrfs_clone_write_end_io;\n\t}\n\n\tbio->bi_private = &bioc->stripes[dev_nr];\n\tbio->bi_iter.bi_sector = bioc->stripes[dev_nr].physical >> SECTOR_SHIFT;\n\tbioc->stripes[dev_nr].bioc = bioc;\n\tbtrfs_submit_dev_bio(bioc->stripes[dev_nr].dev, bio);\n}\n\nstatic void __btrfs_submit_bio(struct bio *bio, struct btrfs_io_context *bioc,\n\t\t\t       struct btrfs_io_stripe *smap, int mirror_num)\n{\n\tif (!bioc) {\n\t\t \n\t\tbtrfs_bio(bio)->mirror_num = mirror_num;\n\t\tbio->bi_iter.bi_sector = smap->physical >> SECTOR_SHIFT;\n\t\tif (bio_op(bio) != REQ_OP_READ)\n\t\t\tbtrfs_bio(bio)->orig_physical = smap->physical;\n\t\tbio->bi_private = smap->dev;\n\t\tbio->bi_end_io = btrfs_simple_end_io;\n\t\tbtrfs_submit_dev_bio(smap->dev, bio);\n\t} else if (bioc->map_type & BTRFS_BLOCK_GROUP_RAID56_MASK) {\n\t\t \n\t\tbio->bi_private = bioc;\n\t\tbio->bi_end_io = btrfs_raid56_end_io;\n\t\tif (bio_op(bio) == REQ_OP_READ)\n\t\t\traid56_parity_recover(bio, bioc, mirror_num);\n\t\telse\n\t\t\traid56_parity_write(bio, bioc);\n\t} else {\n\t\t \n\t\tint total_devs = bioc->num_stripes;\n\n\t\tbioc->orig_bio = bio;\n\t\tfor (int dev_nr = 0; dev_nr < total_devs; dev_nr++)\n\t\t\tbtrfs_submit_mirrored_bio(bioc, dev_nr);\n\t}\n}\n\nstatic blk_status_t btrfs_bio_csum(struct btrfs_bio *bbio)\n{\n\tif (bbio->bio.bi_opf & REQ_META)\n\t\treturn btree_csum_one_bio(bbio);\n\treturn btrfs_csum_one_bio(bbio);\n}\n\n \nstruct async_submit_bio {\n\tstruct btrfs_bio *bbio;\n\tstruct btrfs_io_context *bioc;\n\tstruct btrfs_io_stripe smap;\n\tint mirror_num;\n\tstruct btrfs_work work;\n};\n\n \nstatic void run_one_async_start(struct btrfs_work *work)\n{\n\tstruct async_submit_bio *async =\n\t\tcontainer_of(work, struct async_submit_bio, work);\n\tblk_status_t ret;\n\n\tret = btrfs_bio_csum(async->bbio);\n\tif (ret)\n\t\tasync->bbio->bio.bi_status = ret;\n}\n\n \nstatic void run_one_async_done(struct btrfs_work *work)\n{\n\tstruct async_submit_bio *async =\n\t\tcontainer_of(work, struct async_submit_bio, work);\n\tstruct bio *bio = &async->bbio->bio;\n\n\t \n\tif (bio->bi_status) {\n\t\tbtrfs_orig_bbio_end_io(async->bbio);\n\t\treturn;\n\t}\n\n\t \n\tbio->bi_opf |= REQ_BTRFS_CGROUP_PUNT;\n\t__btrfs_submit_bio(bio, async->bioc, &async->smap, async->mirror_num);\n}\n\nstatic void run_one_async_free(struct btrfs_work *work)\n{\n\tkfree(container_of(work, struct async_submit_bio, work));\n}\n\nstatic bool should_async_write(struct btrfs_bio *bbio)\n{\n\t \n\tif (test_bit(BTRFS_FS_CSUM_IMPL_FAST, &bbio->fs_info->flags))\n\t\treturn false;\n\n\t \n\tif (op_is_sync(bbio->bio.bi_opf))\n\t\treturn false;\n\n\t \n\tif ((bbio->bio.bi_opf & REQ_META) && btrfs_is_zoned(bbio->fs_info))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool btrfs_wq_submit_bio(struct btrfs_bio *bbio,\n\t\t\t\tstruct btrfs_io_context *bioc,\n\t\t\t\tstruct btrfs_io_stripe *smap, int mirror_num)\n{\n\tstruct btrfs_fs_info *fs_info = bbio->fs_info;\n\tstruct async_submit_bio *async;\n\n\tasync = kmalloc(sizeof(*async), GFP_NOFS);\n\tif (!async)\n\t\treturn false;\n\n\tasync->bbio = bbio;\n\tasync->bioc = bioc;\n\tasync->smap = *smap;\n\tasync->mirror_num = mirror_num;\n\n\tbtrfs_init_work(&async->work, run_one_async_start, run_one_async_done,\n\t\t\trun_one_async_free);\n\tbtrfs_queue_work(fs_info->workers, &async->work);\n\treturn true;\n}\n\nstatic bool btrfs_submit_chunk(struct btrfs_bio *bbio, int mirror_num)\n{\n\tstruct btrfs_inode *inode = bbio->inode;\n\tstruct btrfs_fs_info *fs_info = bbio->fs_info;\n\tstruct btrfs_bio *orig_bbio = bbio;\n\tstruct bio *bio = &bbio->bio;\n\tu64 logical = bio->bi_iter.bi_sector << SECTOR_SHIFT;\n\tu64 length = bio->bi_iter.bi_size;\n\tu64 map_length = length;\n\tbool use_append = btrfs_use_zone_append(bbio);\n\tstruct btrfs_io_context *bioc = NULL;\n\tstruct btrfs_io_stripe smap;\n\tblk_status_t ret;\n\tint error;\n\n\tbtrfs_bio_counter_inc_blocked(fs_info);\n\terror = btrfs_map_block(fs_info, btrfs_op(bio), logical, &map_length,\n\t\t\t\t&bioc, &smap, &mirror_num, 1);\n\tif (error) {\n\t\tret = errno_to_blk_status(error);\n\t\tgoto fail;\n\t}\n\n\tmap_length = min(map_length, length);\n\tif (use_append)\n\t\tmap_length = min(map_length, fs_info->max_zone_append_size);\n\n\tif (map_length < length) {\n\t\tbbio = btrfs_split_bio(fs_info, bbio, map_length, use_append);\n\t\tbio = &bbio->bio;\n\t}\n\n\t \n\tif (bio_op(bio) == REQ_OP_READ && is_data_bbio(bbio)) {\n\t\tbbio->saved_iter = bio->bi_iter;\n\t\tret = btrfs_lookup_bio_sums(bbio);\n\t\tif (ret)\n\t\t\tgoto fail_put_bio;\n\t}\n\n\tif (btrfs_op(bio) == BTRFS_MAP_WRITE) {\n\t\tif (use_append) {\n\t\t\tbio->bi_opf &= ~REQ_OP_WRITE;\n\t\t\tbio->bi_opf |= REQ_OP_ZONE_APPEND;\n\t\t}\n\n\t\t \n\t\tif (inode && !(inode->flags & BTRFS_INODE_NODATASUM) &&\n\t\t    !test_bit(BTRFS_FS_STATE_NO_CSUMS, &fs_info->fs_state) &&\n\t\t    !btrfs_is_data_reloc_root(inode->root)) {\n\t\t\tif (should_async_write(bbio) &&\n\t\t\t    btrfs_wq_submit_bio(bbio, bioc, &smap, mirror_num))\n\t\t\t\tgoto done;\n\n\t\t\tret = btrfs_bio_csum(bbio);\n\t\t\tif (ret)\n\t\t\t\tgoto fail_put_bio;\n\t\t} else if (use_append) {\n\t\t\tret = btrfs_alloc_dummy_sum(bbio);\n\t\t\tif (ret)\n\t\t\t\tgoto fail_put_bio;\n\t\t}\n\t}\n\n\t__btrfs_submit_bio(bio, bioc, &smap, mirror_num);\ndone:\n\treturn map_length == length;\n\nfail_put_bio:\n\tif (map_length < length)\n\t\tbtrfs_cleanup_bio(bbio);\nfail:\n\tbtrfs_bio_counter_dec(fs_info);\n\tbtrfs_bio_end_io(orig_bbio, ret);\n\t \n\treturn true;\n}\n\nvoid btrfs_submit_bio(struct btrfs_bio *bbio, int mirror_num)\n{\n\t \n\tASSERT(bbio->inode || bbio->file_offset == 0);\n\n\twhile (!btrfs_submit_chunk(bbio, mirror_num))\n\t\t;\n}\n\n \nint btrfs_repair_io_failure(struct btrfs_fs_info *fs_info, u64 ino, u64 start,\n\t\t\t    u64 length, u64 logical, struct page *page,\n\t\t\t    unsigned int pg_offset, int mirror_num)\n{\n\tstruct btrfs_io_stripe smap = { 0 };\n\tstruct bio_vec bvec;\n\tstruct bio bio;\n\tint ret = 0;\n\n\tASSERT(!(fs_info->sb->s_flags & SB_RDONLY));\n\tBUG_ON(!mirror_num);\n\n\tif (btrfs_repair_one_zone(fs_info, logical))\n\t\treturn 0;\n\n\t \n\tbtrfs_bio_counter_inc_blocked(fs_info);\n\tret = btrfs_map_repair_block(fs_info, &smap, logical, length, mirror_num);\n\tif (ret < 0)\n\t\tgoto out_counter_dec;\n\n\tif (!smap.dev->bdev ||\n\t    !test_bit(BTRFS_DEV_STATE_WRITEABLE, &smap.dev->dev_state)) {\n\t\tret = -EIO;\n\t\tgoto out_counter_dec;\n\t}\n\n\tbio_init(&bio, smap.dev->bdev, &bvec, 1, REQ_OP_WRITE | REQ_SYNC);\n\tbio.bi_iter.bi_sector = smap.physical >> SECTOR_SHIFT;\n\t__bio_add_page(&bio, page, length, pg_offset);\n\n\tbtrfsic_check_bio(&bio);\n\tret = submit_bio_wait(&bio);\n\tif (ret) {\n\t\t \n\t\tbtrfs_dev_stat_inc_and_print(smap.dev, BTRFS_DEV_STAT_WRITE_ERRS);\n\t\tgoto out_bio_uninit;\n\t}\n\n\tbtrfs_info_rl_in_rcu(fs_info,\n\t\t\"read error corrected: ino %llu off %llu (dev %s sector %llu)\",\n\t\t\t     ino, start, btrfs_dev_name(smap.dev),\n\t\t\t     smap.physical >> SECTOR_SHIFT);\n\tret = 0;\n\nout_bio_uninit:\n\tbio_uninit(&bio);\nout_counter_dec:\n\tbtrfs_bio_counter_dec(fs_info);\n\treturn ret;\n}\n\n \nvoid btrfs_submit_repair_write(struct btrfs_bio *bbio, int mirror_num, bool dev_replace)\n{\n\tstruct btrfs_fs_info *fs_info = bbio->fs_info;\n\tu64 logical = bbio->bio.bi_iter.bi_sector << SECTOR_SHIFT;\n\tu64 length = bbio->bio.bi_iter.bi_size;\n\tstruct btrfs_io_stripe smap = { 0 };\n\tint ret;\n\n\tASSERT(fs_info);\n\tASSERT(mirror_num > 0);\n\tASSERT(btrfs_op(&bbio->bio) == BTRFS_MAP_WRITE);\n\tASSERT(!bbio->inode);\n\n\tbtrfs_bio_counter_inc_blocked(fs_info);\n\tret = btrfs_map_repair_block(fs_info, &smap, logical, length, mirror_num);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tif (dev_replace) {\n\t\tASSERT(smap.dev == fs_info->dev_replace.srcdev);\n\t\tsmap.dev = fs_info->dev_replace.tgtdev;\n\t}\n\t__btrfs_submit_bio(&bbio->bio, NULL, &smap, mirror_num);\n\treturn;\n\nfail:\n\tbtrfs_bio_counter_dec(fs_info);\n\tbtrfs_bio_end_io(bbio, errno_to_blk_status(ret));\n}\n\nint __init btrfs_bioset_init(void)\n{\n\tif (bioset_init(&btrfs_bioset, BIO_POOL_SIZE,\n\t\t\toffsetof(struct btrfs_bio, bio),\n\t\t\tBIOSET_NEED_BVECS))\n\t\treturn -ENOMEM;\n\tif (bioset_init(&btrfs_clone_bioset, BIO_POOL_SIZE,\n\t\t\toffsetof(struct btrfs_bio, bio), 0))\n\t\tgoto out_free_bioset;\n\tif (bioset_init(&btrfs_repair_bioset, BIO_POOL_SIZE,\n\t\t\toffsetof(struct btrfs_bio, bio),\n\t\t\tBIOSET_NEED_BVECS))\n\t\tgoto out_free_clone_bioset;\n\tif (mempool_init_kmalloc_pool(&btrfs_failed_bio_pool, BIO_POOL_SIZE,\n\t\t\t\t      sizeof(struct btrfs_failed_bio)))\n\t\tgoto out_free_repair_bioset;\n\treturn 0;\n\nout_free_repair_bioset:\n\tbioset_exit(&btrfs_repair_bioset);\nout_free_clone_bioset:\n\tbioset_exit(&btrfs_clone_bioset);\nout_free_bioset:\n\tbioset_exit(&btrfs_bioset);\n\treturn -ENOMEM;\n}\n\nvoid __cold btrfs_bioset_exit(void)\n{\n\tmempool_exit(&btrfs_failed_bio_pool);\n\tbioset_exit(&btrfs_repair_bioset);\n\tbioset_exit(&btrfs_clone_bioset);\n\tbioset_exit(&btrfs_bioset);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}