{
  "module_name": "free-space-cache.h",
  "hash_id": "b8e80e1af942c1f230de2381bce403ad16a3370c8e2860d5cf60bc1206c808f7",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/free-space-cache.h",
  "human_readable_source": " \n \n\n#ifndef BTRFS_FREE_SPACE_CACHE_H\n#define BTRFS_FREE_SPACE_CACHE_H\n\n \nenum btrfs_trim_state {\n\tBTRFS_TRIM_STATE_UNTRIMMED,\n\tBTRFS_TRIM_STATE_TRIMMED,\n\tBTRFS_TRIM_STATE_TRIMMING,\n};\n\nstruct btrfs_free_space {\n\tstruct rb_node offset_index;\n\tstruct rb_node bytes_index;\n\tu64 offset;\n\tu64 bytes;\n\tu64 max_extent_size;\n\tunsigned long *bitmap;\n\tstruct list_head list;\n\tenum btrfs_trim_state trim_state;\n\ts32 bitmap_extents;\n};\n\nstatic inline bool btrfs_free_space_trimmed(struct btrfs_free_space *info)\n{\n\treturn (info->trim_state == BTRFS_TRIM_STATE_TRIMMED);\n}\n\nstatic inline bool btrfs_free_space_trimming_bitmap(\n\t\t\t\t\t    struct btrfs_free_space *info)\n{\n\treturn (info->trim_state == BTRFS_TRIM_STATE_TRIMMING);\n}\n\n \nenum {\n\tBTRFS_STAT_CURR,\n\tBTRFS_STAT_PREV,\n\tBTRFS_STAT_NR_ENTRIES,\n};\n\nstruct btrfs_free_space_ctl {\n\tspinlock_t tree_lock;\n\tstruct rb_root free_space_offset;\n\tstruct rb_root_cached free_space_bytes;\n\tu64 free_space;\n\tint extents_thresh;\n\tint free_extents;\n\tint total_bitmaps;\n\tint unit;\n\tu64 start;\n\ts32 discardable_extents[BTRFS_STAT_NR_ENTRIES];\n\ts64 discardable_bytes[BTRFS_STAT_NR_ENTRIES];\n\tconst struct btrfs_free_space_op *op;\n\tstruct btrfs_block_group *block_group;\n\tstruct mutex cache_writeout_mutex;\n\tstruct list_head trimming_ranges;\n};\n\nstruct btrfs_free_space_op {\n\tbool (*use_bitmap)(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\n};\n\nstruct btrfs_io_ctl {\n\tvoid *cur, *orig;\n\tstruct page *page;\n\tstruct page **pages;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct inode *inode;\n\tunsigned long size;\n\tint index;\n\tint num_pages;\n\tint entries;\n\tint bitmaps;\n};\n\nint __init btrfs_free_space_init(void);\nvoid __cold btrfs_free_space_exit(void);\nstruct inode *lookup_free_space_inode(struct btrfs_block_group *block_group,\n\t\tstruct btrfs_path *path);\nint create_free_space_inode(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_block_group *block_group,\n\t\t\t    struct btrfs_path *path);\nint btrfs_remove_free_space_inode(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct btrfs_block_group *block_group);\n\nint btrfs_truncate_free_space_cache(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_block_group *block_group,\n\t\t\t\t    struct inode *inode);\nint load_free_space_cache(struct btrfs_block_group *block_group);\nint btrfs_wait_cache_io(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_block_group *block_group,\n\t\t\tstruct btrfs_path *path);\nint btrfs_write_out_cache(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_block_group *block_group,\n\t\t\t  struct btrfs_path *path);\n\nvoid btrfs_init_free_space_ctl(struct btrfs_block_group *block_group,\n\t\t\t       struct btrfs_free_space_ctl *ctl);\nint __btrfs_add_free_space(struct btrfs_block_group *block_group, u64 bytenr,\n\t\t\t   u64 size, enum btrfs_trim_state trim_state);\nint btrfs_add_free_space(struct btrfs_block_group *block_group,\n\t\t\t u64 bytenr, u64 size);\nint btrfs_add_free_space_unused(struct btrfs_block_group *block_group,\n\t\t\t\tu64 bytenr, u64 size);\nint btrfs_add_free_space_async_trimmed(struct btrfs_block_group *block_group,\n\t\t\t\t       u64 bytenr, u64 size);\nint btrfs_remove_free_space(struct btrfs_block_group *block_group,\n\t\t\t    u64 bytenr, u64 size);\nvoid btrfs_remove_free_space_cache(struct btrfs_block_group *block_group);\nbool btrfs_is_free_space_trimmed(struct btrfs_block_group *block_group);\nu64 btrfs_find_space_for_alloc(struct btrfs_block_group *block_group,\n\t\t\t       u64 offset, u64 bytes, u64 empty_size,\n\t\t\t       u64 *max_extent_size);\nvoid btrfs_dump_free_space(struct btrfs_block_group *block_group,\n\t\t\t   u64 bytes);\nint btrfs_find_space_cluster(struct btrfs_block_group *block_group,\n\t\t\t     struct btrfs_free_cluster *cluster,\n\t\t\t     u64 offset, u64 bytes, u64 empty_size);\nvoid btrfs_init_free_cluster(struct btrfs_free_cluster *cluster);\nu64 btrfs_alloc_from_cluster(struct btrfs_block_group *block_group,\n\t\t\t     struct btrfs_free_cluster *cluster, u64 bytes,\n\t\t\t     u64 min_start, u64 *max_extent_size);\nvoid btrfs_return_cluster_to_free_space(\n\t\t\t       struct btrfs_block_group *block_group,\n\t\t\t       struct btrfs_free_cluster *cluster);\nint btrfs_trim_block_group(struct btrfs_block_group *block_group,\n\t\t\t   u64 *trimmed, u64 start, u64 end, u64 minlen);\nint btrfs_trim_block_group_extents(struct btrfs_block_group *block_group,\n\t\t\t\t   u64 *trimmed, u64 start, u64 end, u64 minlen,\n\t\t\t\t   bool async);\nint btrfs_trim_block_group_bitmaps(struct btrfs_block_group *block_group,\n\t\t\t\t   u64 *trimmed, u64 start, u64 end, u64 minlen,\n\t\t\t\t   u64 maxlen, bool async);\n\nbool btrfs_free_space_cache_v1_active(struct btrfs_fs_info *fs_info);\nint btrfs_set_free_space_cache_v1_active(struct btrfs_fs_info *fs_info, bool active);\n \n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\nint test_add_free_space_entry(struct btrfs_block_group *cache,\n\t\t\t      u64 offset, u64 bytes, bool bitmap);\nint test_check_exists(struct btrfs_block_group *cache, u64 offset, u64 bytes);\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}