{
  "module_name": "transaction.c",
  "hash_id": "a9e303f17d6af4339b354e2af425fc7b7c861686f6be7e6a8ad1794e5826cd17",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/transaction.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/sched/mm.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/blkdev.h>\n#include <linux/uuid.h>\n#include <linux/timekeeping.h>\n#include \"misc.h\"\n#include \"ctree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"volumes.h\"\n#include \"dev-replace.h\"\n#include \"qgroup.h\"\n#include \"block-group.h\"\n#include \"space-info.h\"\n#include \"zoned.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n#include \"extent-tree.h\"\n#include \"root-tree.h\"\n#include \"defrag.h\"\n#include \"dir-item.h\"\n#include \"uuid-tree.h\"\n#include \"ioctl.h\"\n#include \"relocation.h\"\n#include \"scrub.h\"\n\nstatic struct kmem_cache *btrfs_trans_handle_cachep;\n\n \nstatic const unsigned int btrfs_blocked_trans_types[TRANS_STATE_MAX] = {\n\t[TRANS_STATE_RUNNING]\t\t= 0U,\n\t[TRANS_STATE_COMMIT_PREP]\t= 0U,\n\t[TRANS_STATE_COMMIT_START]\t= (__TRANS_START | __TRANS_ATTACH),\n\t[TRANS_STATE_COMMIT_DOING]\t= (__TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOSTART),\n\t[TRANS_STATE_UNBLOCKED]\t\t= (__TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOLOCK |\n\t\t\t\t\t   __TRANS_JOIN_NOSTART),\n\t[TRANS_STATE_SUPER_COMMITTED]\t= (__TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOLOCK |\n\t\t\t\t\t   __TRANS_JOIN_NOSTART),\n\t[TRANS_STATE_COMPLETED]\t\t= (__TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOLOCK |\n\t\t\t\t\t   __TRANS_JOIN_NOSTART),\n};\n\nvoid btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(refcount_read(&transaction->use_count) == 0);\n\tif (refcount_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(\n\t\t\t\t&transaction->delayed_refs.href_root.rb_root));\n\t\tWARN_ON(!RB_EMPTY_ROOT(\n\t\t\t\t&transaction->delayed_refs.dirty_extent_root));\n\t\tif (transaction->delayed_refs.pending_csums)\n\t\t\tbtrfs_err(transaction->fs_info,\n\t\t\t\t  \"pending csums is %llu\",\n\t\t\t\t  transaction->delayed_refs.pending_csums);\n\t\t \n\t\twhile (!list_empty(&transaction->deleted_bgs)) {\n\t\t\tstruct btrfs_block_group *cache;\n\n\t\t\tcache = list_first_entry(&transaction->deleted_bgs,\n\t\t\t\t\t\t struct btrfs_block_group,\n\t\t\t\t\t\t bg_list);\n\t\t\tlist_del_init(&cache->bg_list);\n\t\t\tbtrfs_unfreeze_block_group(cache);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t}\n\t\tWARN_ON(!list_empty(&transaction->dev_update_list));\n\t\tkfree(transaction);\n\t}\n}\n\nstatic noinline void switch_commit_roots(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_root *root, *tmp;\n\n\t \n\tASSERT(cur_trans->state == TRANS_STATE_COMMIT_DOING);\n\n\tdown_write(&fs_info->commit_root_sem);\n\n\tif (test_bit(BTRFS_FS_RELOC_RUNNING, &fs_info->flags))\n\t\tfs_info->last_reloc_trans = trans->transid;\n\n\tlist_for_each_entry_safe(root, tmp, &cur_trans->switch_commits,\n\t\t\t\t dirty_list) {\n\t\tlist_del_init(&root->dirty_list);\n\t\tfree_extent_buffer(root->commit_root);\n\t\troot->commit_root = btrfs_root_node(root);\n\t\textent_io_tree_release(&root->dirty_log_pages);\n\t\tbtrfs_qgroup_clean_swapped_blocks(root);\n\t}\n\n\t \n\tspin_lock(&cur_trans->dropped_roots_lock);\n\twhile (!list_empty(&cur_trans->dropped_roots)) {\n\t\troot = list_first_entry(&cur_trans->dropped_roots,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\t\tlist_del_init(&root->root_list);\n\t\tspin_unlock(&cur_trans->dropped_roots_lock);\n\t\tbtrfs_free_log(trans, root);\n\t\tbtrfs_drop_and_free_fs_root(fs_info, root);\n\t\tspin_lock(&cur_trans->dropped_roots_lock);\n\t}\n\tspin_unlock(&cur_trans->dropped_roots_lock);\n\n\tup_write(&fs_info->commit_root_sem);\n}\n\nstatic inline void extwriter_counter_inc(struct btrfs_transaction *trans,\n\t\t\t\t\t unsigned int type)\n{\n\tif (type & TRANS_EXTWRITERS)\n\t\tatomic_inc(&trans->num_extwriters);\n}\n\nstatic inline void extwriter_counter_dec(struct btrfs_transaction *trans,\n\t\t\t\t\t unsigned int type)\n{\n\tif (type & TRANS_EXTWRITERS)\n\t\tatomic_dec(&trans->num_extwriters);\n}\n\nstatic inline void extwriter_counter_init(struct btrfs_transaction *trans,\n\t\t\t\t\t  unsigned int type)\n{\n\tatomic_set(&trans->num_extwriters, ((type & TRANS_EXTWRITERS) ? 1 : 0));\n}\n\nstatic inline int extwriter_counter_read(struct btrfs_transaction *trans)\n{\n\treturn atomic_read(&trans->num_extwriters);\n}\n\n \nvoid btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\n\tif (!trans->chunk_bytes_reserved)\n\t\treturn;\n\n\tbtrfs_block_rsv_release(fs_info, &fs_info->chunk_block_rsv,\n\t\t\t\ttrans->chunk_bytes_reserved, NULL);\n\ttrans->chunk_bytes_reserved = 0;\n}\n\n \nstatic noinline int join_transaction(struct btrfs_fs_info *fs_info,\n\t\t\t\t     unsigned int type)\n{\n\tstruct btrfs_transaction *cur_trans;\n\n\tspin_lock(&fs_info->trans_lock);\nloop:\n\t \n\tif (BTRFS_FS_ERROR(fs_info)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn -EROFS;\n\t}\n\n\tcur_trans = fs_info->running_transaction;\n\tif (cur_trans) {\n\t\tif (TRANS_ABORTED(cur_trans)) {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\treturn cur_trans->aborted;\n\t\t}\n\t\tif (btrfs_blocked_trans_types[cur_trans->state] & type) {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\trefcount_inc(&cur_trans->use_count);\n\t\tatomic_inc(&cur_trans->num_writers);\n\t\textwriter_counter_inc(cur_trans, type);\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\tbtrfs_lockdep_acquire(fs_info, btrfs_trans_num_writers);\n\t\tbtrfs_lockdep_acquire(fs_info, btrfs_trans_num_extwriters);\n\t\treturn 0;\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n\n\t \n\tif (type == TRANS_ATTACH || type == TRANS_JOIN_NOSTART)\n\t\treturn -ENOENT;\n\n\t \n\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\n\tcur_trans = kmalloc(sizeof(*cur_trans), GFP_NOFS);\n\tif (!cur_trans)\n\t\treturn -ENOMEM;\n\n\tbtrfs_lockdep_acquire(fs_info, btrfs_trans_num_writers);\n\tbtrfs_lockdep_acquire(fs_info, btrfs_trans_num_extwriters);\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (fs_info->running_transaction) {\n\t\t \n\t\tbtrfs_lockdep_release(fs_info, btrfs_trans_num_extwriters);\n\t\tbtrfs_lockdep_release(fs_info, btrfs_trans_num_writers);\n\t\tkfree(cur_trans);\n\t\tgoto loop;\n\t} else if (BTRFS_FS_ERROR(fs_info)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\tbtrfs_lockdep_release(fs_info, btrfs_trans_num_extwriters);\n\t\tbtrfs_lockdep_release(fs_info, btrfs_trans_num_writers);\n\t\tkfree(cur_trans);\n\t\treturn -EROFS;\n\t}\n\n\tcur_trans->fs_info = fs_info;\n\tatomic_set(&cur_trans->pending_ordered, 0);\n\tinit_waitqueue_head(&cur_trans->pending_wait);\n\tatomic_set(&cur_trans->num_writers, 1);\n\textwriter_counter_init(cur_trans, type);\n\tinit_waitqueue_head(&cur_trans->writer_wait);\n\tinit_waitqueue_head(&cur_trans->commit_wait);\n\tcur_trans->state = TRANS_STATE_RUNNING;\n\t \n\trefcount_set(&cur_trans->use_count, 2);\n\tcur_trans->flags = 0;\n\tcur_trans->start_time = ktime_get_seconds();\n\n\tmemset(&cur_trans->delayed_refs, 0, sizeof(cur_trans->delayed_refs));\n\n\tcur_trans->delayed_refs.href_root = RB_ROOT_CACHED;\n\tcur_trans->delayed_refs.dirty_extent_root = RB_ROOT;\n\tatomic_set(&cur_trans->delayed_refs.num_entries, 0);\n\n\t \n\tsmp_mb();\n\tif (!list_empty(&fs_info->tree_mod_seq_list))\n\t\tWARN(1, KERN_ERR \"BTRFS: tree_mod_seq_list not empty when creating a fresh transaction\\n\");\n\tif (!RB_EMPTY_ROOT(&fs_info->tree_mod_log))\n\t\tWARN(1, KERN_ERR \"BTRFS: tree_mod_log rb tree not empty when creating a fresh transaction\\n\");\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\n\tspin_lock_init(&cur_trans->delayed_refs.lock);\n\n\tINIT_LIST_HEAD(&cur_trans->pending_snapshots);\n\tINIT_LIST_HEAD(&cur_trans->dev_update_list);\n\tINIT_LIST_HEAD(&cur_trans->switch_commits);\n\tINIT_LIST_HEAD(&cur_trans->dirty_bgs);\n\tINIT_LIST_HEAD(&cur_trans->io_bgs);\n\tINIT_LIST_HEAD(&cur_trans->dropped_roots);\n\tmutex_init(&cur_trans->cache_write_mutex);\n\tspin_lock_init(&cur_trans->dirty_bgs_lock);\n\tINIT_LIST_HEAD(&cur_trans->deleted_bgs);\n\tspin_lock_init(&cur_trans->dropped_roots_lock);\n\tlist_add_tail(&cur_trans->list, &fs_info->trans_list);\n\textent_io_tree_init(fs_info, &cur_trans->dirty_pages,\n\t\t\tIO_TREE_TRANS_DIRTY_PAGES);\n\textent_io_tree_init(fs_info, &cur_trans->pinned_extents,\n\t\t\tIO_TREE_FS_PINNED_EXTENTS);\n\tfs_info->generation++;\n\tcur_trans->transid = fs_info->generation;\n\tfs_info->running_transaction = cur_trans;\n\tcur_trans->aborted = 0;\n\tspin_unlock(&fs_info->trans_lock);\n\n\treturn 0;\n}\n\n \nstatic int record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       int force)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret = 0;\n\n\tif ((test_bit(BTRFS_ROOT_SHAREABLE, &root->state) &&\n\t    root->last_trans < trans->transid) || force) {\n\t\tWARN_ON(!force && root->commit_root != root->node);\n\n\t\t \n\t\tset_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state);\n\n\t\t \n\t\tsmp_wmb();\n\n\t\tspin_lock(&fs_info->fs_roots_radix_lock);\n\t\tif (root->last_trans == trans->transid && !force) {\n\t\t\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tradix_tree_tag_set(&fs_info->fs_roots_radix,\n\t\t\t\t   (unsigned long)root->root_key.objectid,\n\t\t\t\t   BTRFS_ROOT_TRANS_TAG);\n\t\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\t\troot->last_trans = trans->transid;\n\n\t\t \n\t\tret = btrfs_init_reloc_root(trans, root);\n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state);\n\t}\n\treturn ret;\n}\n\n\nvoid btrfs_add_dropped_root(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\n\t \n\tspin_lock(&cur_trans->dropped_roots_lock);\n\tlist_add_tail(&root->root_list, &cur_trans->dropped_roots);\n\tspin_unlock(&cur_trans->dropped_roots_lock);\n\n\t \n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\tradix_tree_tag_clear(&fs_info->fs_roots_radix,\n\t\t\t     (unsigned long)root->root_key.objectid,\n\t\t\t     BTRFS_ROOT_TRANS_TAG);\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n}\n\nint btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tif (!test_bit(BTRFS_ROOT_SHAREABLE, &root->state))\n\t\treturn 0;\n\n\t \n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&fs_info->reloc_mutex);\n\tret = record_root_in_trans(trans, root, 0);\n\tmutex_unlock(&fs_info->reloc_mutex);\n\n\treturn ret;\n}\n\nstatic inline int is_transaction_blocked(struct btrfs_transaction *trans)\n{\n\treturn (trans->state >= TRANS_STATE_COMMIT_START &&\n\t\ttrans->state < TRANS_STATE_UNBLOCKED &&\n\t\t!TRANS_ABORTED(trans));\n}\n\n \nstatic void wait_current_trans(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_transaction *cur_trans;\n\n\tspin_lock(&fs_info->trans_lock);\n\tcur_trans = fs_info->running_transaction;\n\tif (cur_trans && is_transaction_blocked(cur_trans)) {\n\t\trefcount_inc(&cur_trans->use_count);\n\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\tbtrfs_might_wait_for_state(fs_info, BTRFS_LOCKDEP_TRANS_UNBLOCKED);\n\t\twait_event(fs_info->transaction_wait,\n\t\t\t   cur_trans->state >= TRANS_STATE_UNBLOCKED ||\n\t\t\t   TRANS_ABORTED(cur_trans));\n\t\tbtrfs_put_transaction(cur_trans);\n\t} else {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t}\n}\n\nstatic int may_wait_transaction(struct btrfs_fs_info *fs_info, int type)\n{\n\tif (test_bit(BTRFS_FS_LOG_RECOVERING, &fs_info->flags))\n\t\treturn 0;\n\n\tif (type == TRANS_START)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic inline bool need_reserve_reloc_root(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (!fs_info->reloc_ctl ||\n\t    !test_bit(BTRFS_ROOT_SHAREABLE, &root->state) ||\n\t    root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t    root->reloc_root)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, unsigned int num_items,\n\t\t  unsigned int type, enum btrfs_reserve_flush_enum flush,\n\t\t  bool enforce_qgroups)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_block_rsv *delayed_refs_rsv = &fs_info->delayed_refs_rsv;\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tbool do_chunk_alloc = false;\n\tint ret;\n\n\tif (BTRFS_FS_ERROR(fs_info))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\trefcount_inc(&h->use_count);\n\t\tWARN_ON(refcount_read(&h->use_count) > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t \n\tif (num_items && root != fs_info->chunk_root) {\n\t\tstruct btrfs_block_rsv *rsv = &fs_info->trans_block_rsv;\n\t\tu64 delayed_refs_bytes = 0;\n\n\t\tqgroup_reserved = num_items * fs_info->nodesize;\n\t\t \n\t\tret = btrfs_qgroup_reserve_meta_prealloc(root, qgroup_reserved,\n\t\t\t\t\t\t\t enforce_qgroups, false);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\n\t\t \n\t\tnum_bytes = btrfs_calc_insert_metadata_size(fs_info, num_items);\n\t\tif (flush == BTRFS_RESERVE_FLUSH_ALL &&\n\t\t    !btrfs_block_rsv_full(delayed_refs_rsv)) {\n\t\t\tdelayed_refs_bytes = btrfs_calc_delayed_ref_bytes(fs_info,\n\t\t\t\t\t\t\t\t\t  num_items);\n\t\t\tnum_bytes += delayed_refs_bytes;\n\t\t}\n\n\t\t \n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += fs_info->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_reserve_metadata_bytes(fs_info, rsv, num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t\tif (delayed_refs_bytes) {\n\t\t\tbtrfs_migrate_to_delayed_refs_rsv(fs_info, delayed_refs_bytes);\n\t\t\tnum_bytes -= delayed_refs_bytes;\n\t\t}\n\t\tbtrfs_block_rsv_add_bytes(rsv, num_bytes, true);\n\n\t\tif (rsv->space_info->force_alloc)\n\t\t\tdo_chunk_alloc = true;\n\t} else if (num_items == 0 && flush == BTRFS_RESERVE_FLUSH_ALL &&\n\t\t   !btrfs_block_rsv_full(delayed_refs_rsv)) {\n\t\t \n\t\tret = btrfs_delayed_refs_rsv_refill(fs_info, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_zalloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t \n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(fs_info->sb);\n\n\tif (may_wait_transaction(fs_info, type))\n\t\twait_current_trans(fs_info);\n\n\tdo {\n\t\tret = join_transaction(fs_info, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(fs_info);\n\t\t\tif (unlikely(type == TRANS_ATTACH ||\n\t\t\t\t     type == TRANS_JOIN_NOSTART))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0)\n\t\tgoto join_fail;\n\n\tcur_trans = fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\trefcount_set(&h->use_count, 1);\n\th->fs_info = root->fs_info;\n\n\th->type = type;\n\tINIT_LIST_HEAD(&h->new_bgs);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START &&\n\t    may_wait_transaction(fs_info, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\n\t \n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_convert_reserved_meta(root, qgroup_reserved);\n\ngot_it:\n\tif (!current->journal_info)\n\t\tcurrent->journal_info = h;\n\n\t \n\tif (do_chunk_alloc && num_bytes) {\n\t\tu64 flags = h->block_rsv->space_info->flags;\n\n\t\tbtrfs_chunk_alloc(h, btrfs_get_alloc_profile(fs_info, flags),\n\t\t\t\t  CHUNK_ALLOC_NO_FORCE);\n\t}\n\n\t \n\tret = btrfs_record_root_in_trans(h, root);\n\tif (ret) {\n\t\t \n\t\tbtrfs_end_transaction(h);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(fs_info, &fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes, NULL);\nreserve_fail:\n\tbtrfs_qgroup_free_meta_prealloc(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}\n\nstruct btrfs_trans_handle *btrfs_start_transaction(struct btrfs_root *root,\n\t\t\t\t\t\t   unsigned int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_ALL, true);\n}\n\nstruct btrfs_trans_handle *btrfs_start_transaction_fallback_global_rsv(\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tunsigned int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_ALL_STEAL, false);\n}\n\nstruct btrfs_trans_handle *btrfs_join_transaction(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN, BTRFS_RESERVE_NO_FLUSH,\n\t\t\t\t true);\n}\n\nstruct btrfs_trans_handle *btrfs_join_transaction_spacecache(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK,\n\t\t\t\t BTRFS_RESERVE_NO_FLUSH, true);\n}\n\n \nstruct btrfs_trans_handle *btrfs_join_transaction_nostart(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOSTART,\n\t\t\t\t BTRFS_RESERVE_NO_FLUSH, true);\n}\n\n \nstruct btrfs_trans_handle *btrfs_attach_transaction(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_ATTACH,\n\t\t\t\t BTRFS_RESERVE_NO_FLUSH, true);\n}\n\n \nstruct btrfs_trans_handle *\nbtrfs_attach_transaction_barrier(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = start_transaction(root, 0, TRANS_ATTACH,\n\t\t\t\t  BTRFS_RESERVE_NO_FLUSH, true);\n\tif (trans == ERR_PTR(-ENOENT)) {\n\t\tint ret;\n\n\t\tret = btrfs_wait_for_commit(root->fs_info, 0);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn trans;\n}\n\n \nstatic noinline void wait_for_commit(struct btrfs_transaction *commit,\n\t\t\t\t     const enum btrfs_trans_state min_state)\n{\n\tstruct btrfs_fs_info *fs_info = commit->fs_info;\n\tu64 transid = commit->transid;\n\tbool put = false;\n\n\t \n\tif (min_state == TRANS_STATE_COMPLETED)\n\t\tbtrfs_might_wait_for_state(fs_info, BTRFS_LOCKDEP_TRANS_COMPLETED);\n\telse\n\t\tbtrfs_might_wait_for_state(fs_info, BTRFS_LOCKDEP_TRANS_SUPER_COMMITTED);\n\n\twhile (1) {\n\t\twait_event(commit->commit_wait, commit->state >= min_state);\n\t\tif (put)\n\t\t\tbtrfs_put_transaction(commit);\n\n\t\tif (min_state < TRANS_STATE_COMPLETED)\n\t\t\tbreak;\n\n\t\t \n\n\t\tspin_lock(&fs_info->trans_lock);\n\t\tcommit = list_first_entry_or_null(&fs_info->trans_list,\n\t\t\t\t\t\t  struct btrfs_transaction,\n\t\t\t\t\t\t  list);\n\t\tif (!commit || commit->transid > transid) {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\tbreak;\n\t\t}\n\t\trefcount_inc(&commit->use_count);\n\t\tput = true;\n\t\tspin_unlock(&fs_info->trans_lock);\n\t}\n}\n\nint btrfs_wait_for_commit(struct btrfs_fs_info *fs_info, u64 transid)\n{\n\tstruct btrfs_transaction *cur_trans = NULL, *t;\n\tint ret = 0;\n\n\tif (transid) {\n\t\tif (transid <= fs_info->last_trans_committed)\n\t\t\tgoto out;\n\n\t\t \n\t\tspin_lock(&fs_info->trans_lock);\n\t\tlist_for_each_entry(t, &fs_info->trans_list, list) {\n\t\t\tif (t->transid == transid) {\n\t\t\t\tcur_trans = t;\n\t\t\t\trefcount_inc(&cur_trans->use_count);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t->transid > transid) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\t \n\t\tif (!cur_trans) {\n\t\t\tif (transid > fs_info->last_trans_committed)\n\t\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t \n\t\tspin_lock(&fs_info->trans_lock);\n\t\tlist_for_each_entry_reverse(t, &fs_info->trans_list,\n\t\t\t\t\t    list) {\n\t\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\t\tif (t->state == TRANS_STATE_COMPLETED)\n\t\t\t\t\tbreak;\n\t\t\t\tcur_trans = t;\n\t\t\t\trefcount_inc(&cur_trans->use_count);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\tif (!cur_trans)\n\t\t\tgoto out;   \n\t}\n\n\twait_for_commit(cur_trans, TRANS_STATE_COMPLETED);\n\tret = cur_trans->aborted;\n\tbtrfs_put_transaction(cur_trans);\nout:\n\treturn ret;\n}\n\nvoid btrfs_throttle(struct btrfs_fs_info *fs_info)\n{\n\twait_current_trans(fs_info);\n}\n\nbool btrfs_should_end_transaction(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START ||\n\t    test_bit(BTRFS_DELAYED_REFS_FLUSHING, &cur_trans->delayed_refs.flags))\n\t\treturn true;\n\n\tif (btrfs_check_space_for_delayed_refs(trans->fs_info))\n\t\treturn true;\n\n\treturn !!btrfs_block_rsv_check(&trans->fs_info->global_block_rsv, 50);\n}\n\nstatic void btrfs_trans_release_metadata(struct btrfs_trans_handle *trans)\n\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\n\tif (!trans->block_rsv) {\n\t\tASSERT(!trans->bytes_reserved);\n\t\treturn;\n\t}\n\n\tif (!trans->bytes_reserved)\n\t\treturn;\n\n\tASSERT(trans->block_rsv == &fs_info->trans_block_rsv);\n\ttrace_btrfs_space_reservation(fs_info, \"transaction\",\n\t\t\t\t      trans->transid, trans->bytes_reserved, 0);\n\tbtrfs_block_rsv_release(fs_info, trans->block_rsv,\n\t\t\t\ttrans->bytes_reserved, NULL);\n\ttrans->bytes_reserved = 0;\n}\n\nstatic int __btrfs_end_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\t   int throttle)\n{\n\tstruct btrfs_fs_info *info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tint err = 0;\n\n\tif (refcount_read(&trans->use_count) > 1) {\n\t\trefcount_dec(&trans->use_count);\n\t\ttrans->block_rsv = trans->orig_rsv;\n\t\treturn 0;\n\t}\n\n\tbtrfs_trans_release_metadata(trans);\n\ttrans->block_rsv = NULL;\n\n\tbtrfs_create_pending_block_groups(trans);\n\n\tbtrfs_trans_release_chunk_metadata(trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(info->sb);\n\n\tWARN_ON(cur_trans != info->running_transaction);\n\tWARN_ON(atomic_read(&cur_trans->num_writers) < 1);\n\tatomic_dec(&cur_trans->num_writers);\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tcond_wake_up(&cur_trans->writer_wait);\n\n\tbtrfs_lockdep_release(info, btrfs_trans_num_extwriters);\n\tbtrfs_lockdep_release(info, btrfs_trans_num_writers);\n\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tif (throttle)\n\t\tbtrfs_run_delayed_iputs(info);\n\n\tif (TRANS_ABORTED(trans) || BTRFS_FS_ERROR(info)) {\n\t\twake_up_process(info->transaction_kthread);\n\t\tif (TRANS_ABORTED(trans))\n\t\t\terr = trans->aborted;\n\t\telse\n\t\t\terr = -EROFS;\n\t}\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\treturn err;\n}\n\nint btrfs_end_transaction(struct btrfs_trans_handle *trans)\n{\n\treturn __btrfs_end_transaction(trans, 0);\n}\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans)\n{\n\treturn __btrfs_end_transaction(trans, 1);\n}\n\n \nint btrfs_write_marked_extents(struct btrfs_fs_info *fs_info,\n\t\t\t       struct extent_io_tree *dirty_pages, int mark)\n{\n\tint err = 0;\n\tint werr = 0;\n\tstruct address_space *mapping = fs_info->btree_inode->i_mapping;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 end;\n\n\twhile (find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t     mark, &cached_state)) {\n\t\tbool wait_writeback = false;\n\n\t\terr = convert_extent_bit(dirty_pages, start, end,\n\t\t\t\t\t EXTENT_NEED_WAIT,\n\t\t\t\t\t mark, &cached_state);\n\t\t \n\t\tif (err == -ENOMEM) {\n\t\t\terr = 0;\n\t\t\twait_writeback = true;\n\t\t}\n\t\tif (!err)\n\t\t\terr = filemap_fdatawrite_range(mapping, start, end);\n\t\tif (err)\n\t\t\twerr = err;\n\t\telse if (wait_writeback)\n\t\t\twerr = filemap_fdatawait_range(mapping, start, end);\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tcond_resched();\n\t\tstart = end + 1;\n\t}\n\treturn werr;\n}\n\n \nstatic int __btrfs_wait_marked_extents(struct btrfs_fs_info *fs_info,\n\t\t\t\t       struct extent_io_tree *dirty_pages)\n{\n\tint err = 0;\n\tint werr = 0;\n\tstruct address_space *mapping = fs_info->btree_inode->i_mapping;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 end;\n\n\twhile (find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t     EXTENT_NEED_WAIT, &cached_state)) {\n\t\t \n\t\terr = clear_extent_bit(dirty_pages, start, end,\n\t\t\t\t       EXTENT_NEED_WAIT, &cached_state);\n\t\tif (err == -ENOMEM)\n\t\t\terr = 0;\n\t\tif (!err)\n\t\t\terr = filemap_fdatawait_range(mapping, start, end);\n\t\tif (err)\n\t\t\twerr = err;\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tcond_resched();\n\t\tstart = end + 1;\n\t}\n\tif (err)\n\t\twerr = err;\n\treturn werr;\n}\n\nstatic int btrfs_wait_extents(struct btrfs_fs_info *fs_info,\n\t\t       struct extent_io_tree *dirty_pages)\n{\n\tbool errors = false;\n\tint err;\n\n\terr = __btrfs_wait_marked_extents(fs_info, dirty_pages);\n\tif (test_and_clear_bit(BTRFS_FS_BTREE_ERR, &fs_info->flags))\n\t\terrors = true;\n\n\tif (errors && !err)\n\t\terr = -EIO;\n\treturn err;\n}\n\nint btrfs_wait_tree_log_extents(struct btrfs_root *log_root, int mark)\n{\n\tstruct btrfs_fs_info *fs_info = log_root->fs_info;\n\tstruct extent_io_tree *dirty_pages = &log_root->dirty_log_pages;\n\tbool errors = false;\n\tint err;\n\n\tASSERT(log_root->root_key.objectid == BTRFS_TREE_LOG_OBJECTID);\n\n\terr = __btrfs_wait_marked_extents(fs_info, dirty_pages);\n\tif ((mark & EXTENT_DIRTY) &&\n\t    test_and_clear_bit(BTRFS_FS_LOG1_ERR, &fs_info->flags))\n\t\terrors = true;\n\n\tif ((mark & EXTENT_NEW) &&\n\t    test_and_clear_bit(BTRFS_FS_LOG2_ERR, &fs_info->flags))\n\t\terrors = true;\n\n\tif (errors && !err)\n\t\terr = -EIO;\n\treturn err;\n}\n\n \nstatic int btrfs_write_and_wait_transaction(struct btrfs_trans_handle *trans)\n{\n\tint ret;\n\tint ret2;\n\tstruct extent_io_tree *dirty_pages = &trans->transaction->dirty_pages;\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tret = btrfs_write_marked_extents(fs_info, dirty_pages, EXTENT_DIRTY);\n\tblk_finish_plug(&plug);\n\tret2 = btrfs_wait_extents(fs_info, dirty_pages);\n\n\textent_io_tree_release(&trans->transaction->dirty_pages);\n\n\tif (ret)\n\t\treturn ret;\n\telse if (ret2)\n\t\treturn ret2;\n\telse\n\t\treturn 0;\n}\n\n \nstatic int update_cowonly_root(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tint ret;\n\tu64 old_root_bytenr;\n\tu64 old_root_used;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\n\told_root_used = btrfs_root_used(&root->root_item);\n\n\twhile (1) {\n\t\told_root_bytenr = btrfs_root_bytenr(&root->root_item);\n\t\tif (old_root_bytenr == root->node->start &&\n\t\t    old_root_used == btrfs_root_used(&root->root_item))\n\t\t\tbreak;\n\n\t\tbtrfs_set_root_node(&root->root_item, root->node);\n\t\tret = btrfs_update_root(trans, tree_root,\n\t\t\t\t\t&root->root_key,\n\t\t\t\t\t&root->root_item);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\told_root_used = btrfs_root_used(&root->root_item);\n\t}\n\n\treturn 0;\n}\n\n \nstatic noinline int commit_cowonly_roots(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct list_head *dirty_bgs = &trans->transaction->dirty_bgs;\n\tstruct list_head *io_bgs = &trans->transaction->io_bgs;\n\tstruct list_head *next;\n\tstruct extent_buffer *eb;\n\tint ret;\n\n\t \n\tASSERT(trans->transaction->state == TRANS_STATE_COMMIT_DOING);\n\n\teb = btrfs_lock_root_node(fs_info->tree_root);\n\tret = btrfs_cow_block(trans, fs_info->tree_root, eb, NULL,\n\t\t\t      0, &eb, BTRFS_NESTING_COW);\n\tbtrfs_tree_unlock(eb);\n\tfree_extent_buffer(eb);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_run_dev_stats(trans);\n\tif (ret)\n\t\treturn ret;\n\tret = btrfs_run_dev_replace(trans);\n\tif (ret)\n\t\treturn ret;\n\tret = btrfs_run_qgroups(trans);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_setup_space_cache(trans);\n\tif (ret)\n\t\treturn ret;\n\nagain:\n\twhile (!list_empty(&fs_info->dirty_cowonly_roots)) {\n\t\tstruct btrfs_root *root;\n\t\tnext = fs_info->dirty_cowonly_roots.next;\n\t\tlist_del_init(next);\n\t\troot = list_entry(next, struct btrfs_root, dirty_list);\n\t\tclear_bit(BTRFS_ROOT_DIRTY, &root->state);\n\n\t\tlist_add_tail(&root->dirty_list,\n\t\t\t      &trans->transaction->switch_commits);\n\t\tret = update_cowonly_root(trans, root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = btrfs_run_delayed_refs(trans, (unsigned long)-1);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (!list_empty(dirty_bgs) || !list_empty(io_bgs)) {\n\t\tret = btrfs_write_dirty_block_groups(trans);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = btrfs_run_delayed_refs(trans, (unsigned long)-1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!list_empty(&fs_info->dirty_cowonly_roots))\n\t\tgoto again;\n\n\t \n\tfs_info->dev_replace.committed_cursor_left =\n\t\tfs_info->dev_replace.cursor_left_last_write_of_item;\n\n\treturn 0;\n}\n\n \nvoid btrfs_maybe_wake_unfinished_drop(struct btrfs_fs_info *fs_info)\n{\n\t \n\tspin_lock(&fs_info->trans_lock);\n\tif (!list_empty(&fs_info->dead_roots)) {\n\t\tstruct btrfs_root *root = list_first_entry(&fs_info->dead_roots,\n\t\t\t\t\t\t\t   struct btrfs_root,\n\t\t\t\t\t\t\t   root_list);\n\t\tif (test_bit(BTRFS_ROOT_UNFINISHED_DROP, &root->state)) {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n\n\tbtrfs_wake_unfinished_drop(fs_info);\n}\n\n \nvoid btrfs_add_dead_root(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (list_empty(&root->root_list)) {\n\t\tbtrfs_grab_root(root);\n\n\t\t \n\t\tif (test_bit(BTRFS_ROOT_UNFINISHED_DROP, &root->state))\n\t\t\tlist_add(&root->root_list, &fs_info->dead_roots);\n\t\telse\n\t\t\tlist_add_tail(&root->root_list, &fs_info->dead_roots);\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n}\n\n \nstatic noinline int commit_fs_roots(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_root *gang[8];\n\tint i;\n\tint ret;\n\n\t \n\tASSERT(trans->transaction->state == TRANS_STATE_COMMIT_DOING);\n\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\twhile (1) {\n\t\tret = radix_tree_gang_lookup_tag(&fs_info->fs_roots_radix,\n\t\t\t\t\t\t (void **)gang, 0,\n\t\t\t\t\t\t ARRAY_SIZE(gang),\n\t\t\t\t\t\t BTRFS_ROOT_TRANS_TAG);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tstruct btrfs_root *root = gang[i];\n\t\t\tint ret2;\n\n\t\t\t \n\t\t\tASSERT(atomic_read(&root->log_writers) == 0);\n\t\t\tASSERT(atomic_read(&root->log_commit[0]) == 0);\n\t\t\tASSERT(atomic_read(&root->log_commit[1]) == 0);\n\n\t\t\tradix_tree_tag_clear(&fs_info->fs_roots_radix,\n\t\t\t\t\t(unsigned long)root->root_key.objectid,\n\t\t\t\t\tBTRFS_ROOT_TRANS_TAG);\n\t\t\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\n\t\t\tbtrfs_free_log(trans, root);\n\t\t\tret2 = btrfs_update_reloc_root(trans, root);\n\t\t\tif (ret2)\n\t\t\t\treturn ret2;\n\n\t\t\t \n\t\t\tclear_bit(BTRFS_ROOT_FORCE_COW, &root->state);\n\t\t\tsmp_mb__after_atomic();\n\n\t\t\tif (root->commit_root != root->node) {\n\t\t\t\tlist_add_tail(&root->dirty_list,\n\t\t\t\t\t&trans->transaction->switch_commits);\n\t\t\t\tbtrfs_set_root_node(&root->root_item,\n\t\t\t\t\t\t    root->node);\n\t\t\t}\n\n\t\t\tret2 = btrfs_update_root(trans, fs_info->tree_root,\n\t\t\t\t\t\t&root->root_key,\n\t\t\t\t\t\t&root->root_item);\n\t\t\tif (ret2)\n\t\t\t\treturn ret2;\n\t\t\tspin_lock(&fs_info->fs_roots_radix_lock);\n\t\t\tbtrfs_qgroup_free_meta_all_pertrans(root);\n\t\t}\n\t}\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\treturn 0;\n}\n\n \nint btrfs_defrag_root(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tif (test_and_set_bit(BTRFS_ROOT_DEFRAG_RUNNING, &root->state))\n\t\treturn 0;\n\n\twhile (1) {\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = btrfs_defrag_leaves(trans, root);\n\n\t\tbtrfs_end_transaction(trans);\n\t\tbtrfs_btree_balance_dirty(info);\n\t\tcond_resched();\n\n\t\tif (btrfs_fs_closing(info) || ret != -EAGAIN)\n\t\t\tbreak;\n\n\t\tif (btrfs_defrag_cancelled(info)) {\n\t\t\tbtrfs_debug(info, \"defrag_root cancelled\");\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tclear_bit(BTRFS_ROOT_DEFRAG_RUNNING, &root->state);\n\treturn ret;\n}\n\n \nstatic int qgroup_account_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *src,\n\t\t\t\t   struct btrfs_root *parent,\n\t\t\t\t   struct btrfs_qgroup_inherit *inherit,\n\t\t\t\t   u64 dst_objectid)\n{\n\tstruct btrfs_fs_info *fs_info = src->fs_info;\n\tint ret;\n\n\t \n\tif (!test_bit(BTRFS_FS_QUOTA_ENABLED, &fs_info->flags))\n\t\treturn 0;\n\n\t \n\tret = record_root_in_trans(trans, src, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = btrfs_run_delayed_refs(trans, (unsigned long)-1);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\treturn ret;\n\t}\n\n\tret = commit_fs_roots(trans);\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_qgroup_account_extents(trans);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = btrfs_qgroup_inherit(trans, src->root_key.objectid, dst_objectid,\n\t\t\t\t   inherit);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = commit_cowonly_roots(trans);\n\tif (ret)\n\t\tgoto out;\n\tswitch_commit_roots(trans);\n\tret = btrfs_write_and_wait_transaction(trans);\n\tif (ret)\n\t\tbtrfs_handle_fs_error(fs_info, ret,\n\t\t\t\"Error while writing out transaction for qgroup\");\n\nout:\n\t \n\tif (!ret)\n\t\tret = record_root_in_trans(trans, parent, 1);\n\treturn ret;\n}\n\n \nstatic noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_pending_snapshot *pending)\n{\n\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_key key;\n\tstruct btrfs_root_item *new_root_item;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *root = pending->root;\n\tstruct btrfs_root *parent_root;\n\tstruct btrfs_block_rsv *rsv;\n\tstruct inode *parent_inode = pending->dir;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *dir_item;\n\tstruct extent_buffer *tmp;\n\tstruct extent_buffer *old;\n\tstruct timespec64 cur_time;\n\tint ret = 0;\n\tu64 to_reserve = 0;\n\tu64 index = 0;\n\tu64 objectid;\n\tu64 root_flags;\n\tunsigned int nofs_flags;\n\tstruct fscrypt_name fname;\n\n\tASSERT(pending->path);\n\tpath = pending->path;\n\n\tASSERT(pending->root_item);\n\tnew_root_item = pending->root_item;\n\n\t \n\tnofs_flags = memalloc_nofs_save();\n\tpending->error = fscrypt_setup_filename(parent_inode,\n\t\t\t\t\t\t&pending->dentry->d_name, 0,\n\t\t\t\t\t\t&fname);\n\tmemalloc_nofs_restore(nofs_flags);\n\tif (pending->error)\n\t\tgoto free_pending;\n\n\tpending->error = btrfs_get_free_objectid(tree_root, &objectid);\n\tif (pending->error)\n\t\tgoto free_fname;\n\n\t \n\tbtrfs_set_skip_qgroup(trans, objectid);\n\n\tbtrfs_reloc_pre_snapshot(pending, &to_reserve);\n\n\tif (to_reserve > 0) {\n\t\tpending->error = btrfs_block_rsv_add(fs_info,\n\t\t\t\t\t\t     &pending->block_rsv,\n\t\t\t\t\t\t     to_reserve,\n\t\t\t\t\t\t     BTRFS_RESERVE_NO_FLUSH);\n\t\tif (pending->error)\n\t\t\tgoto clear_skip_qgroup;\n\t}\n\n\tkey.objectid = objectid;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\n\trsv = trans->block_rsv;\n\ttrans->block_rsv = &pending->block_rsv;\n\ttrans->bytes_reserved = trans->block_rsv->reserved;\n\ttrace_btrfs_space_reservation(fs_info, \"transaction\",\n\t\t\t\t      trans->transid,\n\t\t\t\t      trans->bytes_reserved, 1);\n\tparent_root = BTRFS_I(parent_inode)->root;\n\tret = record_root_in_trans(trans, parent_root, 0);\n\tif (ret)\n\t\tgoto fail;\n\tcur_time = current_time(parent_inode);\n\n\t \n\tret = btrfs_set_inode_index(BTRFS_I(parent_inode), &index);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\t \n\tdir_item = btrfs_lookup_dir_item(NULL, parent_root, path,\n\t\t\t\t\t btrfs_ino(BTRFS_I(parent_inode)),\n\t\t\t\t\t &fname.disk_name, 0);\n\tif (dir_item != NULL && !IS_ERR(dir_item)) {\n\t\tpending->error = -EEXIST;\n\t\tgoto dir_item_existed;\n\t} else if (IS_ERR(dir_item)) {\n\t\tret = PTR_ERR(dir_item);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\tbtrfs_release_path(path);\n\n\t \n\tret = btrfs_run_delayed_items(trans);\n\tif (ret) {\t \n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\tret = record_root_in_trans(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\tbtrfs_set_root_last_snapshot(&root->root_item, trans->transid);\n\tmemcpy(new_root_item, &root->root_item, sizeof(*new_root_item));\n\tbtrfs_check_and_init_root_item(new_root_item);\n\n\troot_flags = btrfs_root_flags(new_root_item);\n\tif (pending->readonly)\n\t\troot_flags |= BTRFS_ROOT_SUBVOL_RDONLY;\n\telse\n\t\troot_flags &= ~BTRFS_ROOT_SUBVOL_RDONLY;\n\tbtrfs_set_root_flags(new_root_item, root_flags);\n\n\tbtrfs_set_root_generation_v2(new_root_item,\n\t\t\ttrans->transid);\n\tgenerate_random_guid(new_root_item->uuid);\n\tmemcpy(new_root_item->parent_uuid, root->root_item.uuid,\n\t\t\tBTRFS_UUID_SIZE);\n\tif (!(root_flags & BTRFS_ROOT_SUBVOL_RDONLY)) {\n\t\tmemset(new_root_item->received_uuid, 0,\n\t\t       sizeof(new_root_item->received_uuid));\n\t\tmemset(&new_root_item->stime, 0, sizeof(new_root_item->stime));\n\t\tmemset(&new_root_item->rtime, 0, sizeof(new_root_item->rtime));\n\t\tbtrfs_set_root_stransid(new_root_item, 0);\n\t\tbtrfs_set_root_rtransid(new_root_item, 0);\n\t}\n\tbtrfs_set_stack_timespec_sec(&new_root_item->otime, cur_time.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&new_root_item->otime, cur_time.tv_nsec);\n\tbtrfs_set_root_otransid(new_root_item, trans->transid);\n\n\told = btrfs_lock_root_node(root);\n\tret = btrfs_cow_block(trans, root, old, NULL, 0, &old,\n\t\t\t      BTRFS_NESTING_COW);\n\tif (ret) {\n\t\tbtrfs_tree_unlock(old);\n\t\tfree_extent_buffer(old);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_copy_root(trans, root, old, &tmp, objectid);\n\t \n\tbtrfs_tree_unlock(old);\n\tfree_extent_buffer(old);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\t \n\tset_bit(BTRFS_ROOT_FORCE_COW, &root->state);\n\tsmp_wmb();\n\n\tbtrfs_set_root_node(new_root_item, tmp);\n\t \n\tkey.offset = trans->transid;\n\tret = btrfs_insert_root(trans, tree_root, &key, new_root_item);\n\tbtrfs_tree_unlock(tmp);\n\tfree_extent_buffer(tmp);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\t \n\tret = btrfs_add_root_ref(trans, objectid,\n\t\t\t\t parent_root->root_key.objectid,\n\t\t\t\t btrfs_ino(BTRFS_I(parent_inode)), index,\n\t\t\t\t &fname.disk_name);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\tkey.offset = (u64)-1;\n\tpending->snap = btrfs_get_new_fs_root(fs_info, objectid, pending->anon_dev);\n\tif (IS_ERR(pending->snap)) {\n\t\tret = PTR_ERR(pending->snap);\n\t\tpending->snap = NULL;\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_reloc_post_snapshot(trans, pending);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\t \n\tret = qgroup_account_snapshot(trans, root, parent_root,\n\t\t\t\t      pending->inherit, objectid);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = btrfs_insert_dir_item(trans, &fname.disk_name,\n\t\t\t\t    BTRFS_I(parent_inode), &key, BTRFS_FT_DIR,\n\t\t\t\t    index);\n\t \n\tBUG_ON(ret == -EEXIST || ret == -EOVERFLOW);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_i_size_write(BTRFS_I(parent_inode), parent_inode->i_size +\n\t\t\t\t\t\t  fname.disk_name.len * 2);\n\tparent_inode->i_mtime = inode_set_ctime_current(parent_inode);\n\tret = btrfs_update_inode_fallback(trans, parent_root, BTRFS_I(parent_inode));\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\tret = btrfs_uuid_tree_add(trans, new_root_item->uuid,\n\t\t\t\t  BTRFS_UUID_KEY_SUBVOL,\n\t\t\t\t  objectid);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\tif (!btrfs_is_empty_uuid(new_root_item->received_uuid)) {\n\t\tret = btrfs_uuid_tree_add(trans, new_root_item->received_uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  objectid);\n\t\tif (ret && ret != -EEXIST) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\nfail:\n\tpending->error = ret;\ndir_item_existed:\n\ttrans->block_rsv = rsv;\n\ttrans->bytes_reserved = 0;\nclear_skip_qgroup:\n\tbtrfs_clear_skip_qgroup(trans);\nfree_fname:\n\tfscrypt_free_filename(&fname);\nfree_pending:\n\tkfree(new_root_item);\n\tpending->root_item = NULL;\n\tbtrfs_free_path(path);\n\tpending->path = NULL;\n\n\treturn ret;\n}\n\n \nstatic noinline int create_pending_snapshots(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_pending_snapshot *pending, *next;\n\tstruct list_head *head = &trans->transaction->pending_snapshots;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(pending, next, head, list) {\n\t\tlist_del(&pending->list);\n\t\tret = create_pending_snapshot(trans, pending);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void update_super_roots(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_super_block *super;\n\n\tsuper = fs_info->super_copy;\n\n\troot_item = &fs_info->chunk_root->root_item;\n\tsuper->chunk_root = root_item->bytenr;\n\tsuper->chunk_root_generation = root_item->generation;\n\tsuper->chunk_root_level = root_item->level;\n\n\troot_item = &fs_info->tree_root->root_item;\n\tsuper->root = root_item->bytenr;\n\tsuper->generation = root_item->generation;\n\tsuper->root_level = root_item->level;\n\tif (btrfs_test_opt(fs_info, SPACE_CACHE))\n\t\tsuper->cache_generation = root_item->generation;\n\telse if (test_bit(BTRFS_FS_CLEANUP_SPACE_CACHE_V1, &fs_info->flags))\n\t\tsuper->cache_generation = 0;\n\tif (test_bit(BTRFS_FS_UPDATE_UUID_TREE_GEN, &fs_info->flags))\n\t\tsuper->uuid_tree_generation = root_item->generation;\n}\n\nint btrfs_transaction_in_commit(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_transaction *trans;\n\tint ret = 0;\n\n\tspin_lock(&info->trans_lock);\n\ttrans = info->running_transaction;\n\tif (trans)\n\t\tret = (trans->state >= TRANS_STATE_COMMIT_START);\n\tspin_unlock(&info->trans_lock);\n\treturn ret;\n}\n\nint btrfs_transaction_blocked(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_transaction *trans;\n\tint ret = 0;\n\n\tspin_lock(&info->trans_lock);\n\ttrans = info->running_transaction;\n\tif (trans)\n\t\tret = is_transaction_blocked(trans);\n\tspin_unlock(&info->trans_lock);\n\treturn ret;\n}\n\nvoid btrfs_commit_transaction_async(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans;\n\n\t \n\tset_bit(BTRFS_FS_COMMIT_TRANS, &fs_info->flags);\n\twake_up_process(fs_info->transaction_kthread);\n\n\t \n\tcur_trans = trans->transaction;\n\trefcount_inc(&cur_trans->use_count);\n\n\tbtrfs_end_transaction(trans);\n\n\t \n\tbtrfs_might_wait_for_state(fs_info, BTRFS_LOCKDEP_TRANS_COMMIT_PREP);\n\twait_event(fs_info->transaction_blocked_wait,\n\t\t   cur_trans->state >= TRANS_STATE_COMMIT_START ||\n\t\t   TRANS_ABORTED(cur_trans));\n\tbtrfs_put_transaction(cur_trans);\n}\n\nstatic void cleanup_transaction(struct btrfs_trans_handle *trans, int err)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\n\tWARN_ON(refcount_read(&trans->use_count) > 1);\n\n\tbtrfs_abort_transaction(trans, err);\n\n\tspin_lock(&fs_info->trans_lock);\n\n\t \n\tBUG_ON(list_empty(&cur_trans->list));\n\n\tif (cur_trans == fs_info->running_transaction) {\n\t\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\t \n\t\tbtrfs_might_wait_for_event(fs_info, btrfs_trans_num_writers);\n\t\twait_event(cur_trans->writer_wait,\n\t\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t\tspin_lock(&fs_info->trans_lock);\n\t}\n\n\t \n\tlist_del_init(&cur_trans->list);\n\n\tspin_unlock(&fs_info->trans_lock);\n\n\tbtrfs_cleanup_one_transaction(trans->transaction, fs_info);\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (cur_trans == fs_info->running_transaction)\n\t\tfs_info->running_transaction = NULL;\n\tspin_unlock(&fs_info->trans_lock);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(fs_info->sb);\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\ttrace_btrfs_transaction_commit(fs_info);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\t \n\tif (!test_bit(BTRFS_FS_RELOC_RUNNING, &fs_info->flags))\n\t\tbtrfs_scrub_cancel(fs_info);\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n}\n\n \nstatic void btrfs_cleanup_pending_block_groups(struct btrfs_trans_handle *trans)\n{\n       struct btrfs_fs_info *fs_info = trans->fs_info;\n       struct btrfs_block_group *block_group, *tmp;\n\n       list_for_each_entry_safe(block_group, tmp, &trans->new_bgs, bg_list) {\n               btrfs_delayed_refs_rsv_release(fs_info, 1);\n               list_del_init(&block_group->bg_list);\n       }\n}\n\nstatic inline int btrfs_start_delalloc_flush(struct btrfs_fs_info *fs_info)\n{\n\t \n\tif (btrfs_test_opt(fs_info, FLUSHONCOMMIT))\n\t\ttry_to_writeback_inodes_sb(fs_info->sb, WB_REASON_SYNC);\n\treturn 0;\n}\n\nstatic inline void btrfs_wait_delalloc_flush(struct btrfs_fs_info *fs_info)\n{\n\tif (btrfs_test_opt(fs_info, FLUSHONCOMMIT))\n\t\tbtrfs_wait_ordered_roots(fs_info, U64_MAX, 0, (u64)-1);\n}\n\n \nstatic void add_pending_snapshot(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\n\tif (!trans->pending_snapshot)\n\t\treturn;\n\n\tlockdep_assert_held(&trans->fs_info->trans_lock);\n\tASSERT(cur_trans->state >= TRANS_STATE_COMMIT_PREP);\n\n\tlist_add(&trans->pending_snapshot->list, &cur_trans->pending_snapshots);\n}\n\nstatic void update_commit_stats(struct btrfs_fs_info *fs_info, ktime_t interval)\n{\n\tfs_info->commit_stats.commit_count++;\n\tfs_info->commit_stats.last_commit_dur = interval;\n\tfs_info->commit_stats.max_commit_dur =\n\t\t\tmax_t(u64, fs_info->commit_stats.max_commit_dur, interval);\n\tfs_info->commit_stats.total_commit_dur += interval;\n}\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tint ret;\n\tktime_t start_time;\n\tktime_t interval;\n\n\tASSERT(refcount_read(&trans->use_count) == 1);\n\tbtrfs_trans_state_lockdep_acquire(fs_info, BTRFS_LOCKDEP_TRANS_COMMIT_PREP);\n\n\tclear_bit(BTRFS_FS_NEED_TRANS_COMMIT, &fs_info->flags);\n\n\t \n\tif (TRANS_ABORTED(cur_trans)) {\n\t\tret = cur_trans->aborted;\n\t\tgoto lockdep_trans_commit_start_release;\n\t}\n\n\tbtrfs_trans_release_metadata(trans);\n\ttrans->block_rsv = NULL;\n\n\t \n\tif (!test_and_set_bit(BTRFS_DELAYED_REFS_FLUSHING,\n\t\t\t      &cur_trans->delayed_refs.flags)) {\n\t\t \n\t\tret = btrfs_run_delayed_refs(trans, 0);\n\t\tif (ret)\n\t\t\tgoto lockdep_trans_commit_start_release;\n\t}\n\n\tbtrfs_create_pending_block_groups(trans);\n\n\tif (!test_bit(BTRFS_TRANS_DIRTY_BG_RUN, &cur_trans->flags)) {\n\t\tint run_it = 0;\n\n\t\t \n\t\tmutex_lock(&fs_info->ro_block_group_mutex);\n\t\tif (!test_and_set_bit(BTRFS_TRANS_DIRTY_BG_RUN,\n\t\t\t\t      &cur_trans->flags))\n\t\t\trun_it = 1;\n\t\tmutex_unlock(&fs_info->ro_block_group_mutex);\n\n\t\tif (run_it) {\n\t\t\tret = btrfs_start_dirty_block_groups(trans);\n\t\t\tif (ret)\n\t\t\t\tgoto lockdep_trans_commit_start_release;\n\t\t}\n\t}\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_PREP) {\n\t\tenum btrfs_trans_state want_state = TRANS_STATE_COMPLETED;\n\n\t\tadd_pending_snapshot(trans);\n\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\trefcount_inc(&cur_trans->use_count);\n\n\t\tif (trans->in_fsync)\n\t\t\twant_state = TRANS_STATE_SUPER_COMMITTED;\n\n\t\tbtrfs_trans_state_lockdep_release(fs_info,\n\t\t\t\t\t\t  BTRFS_LOCKDEP_TRANS_COMMIT_PREP);\n\t\tret = btrfs_end_transaction(trans);\n\t\twait_for_commit(cur_trans, want_state);\n\n\t\tif (TRANS_ABORTED(cur_trans))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_PREP;\n\twake_up(&fs_info->transaction_blocked_wait);\n\tbtrfs_trans_state_lockdep_release(fs_info, BTRFS_LOCKDEP_TRANS_COMMIT_PREP);\n\n\tif (cur_trans->list.prev != &fs_info->trans_list) {\n\t\tenum btrfs_trans_state want_state = TRANS_STATE_COMPLETED;\n\n\t\tif (trans->in_fsync)\n\t\t\twant_state = TRANS_STATE_SUPER_COMMITTED;\n\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state < want_state) {\n\t\t\trefcount_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\t\twait_for_commit(prev_trans, want_state);\n\n\t\t\tret = READ_ONCE(prev_trans->aborted);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t\tif (ret)\n\t\t\t\tgoto lockdep_release;\n\t\t\tspin_lock(&fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\t \n\t\tif (BTRFS_FS_ERROR(fs_info)) {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\tret = -EROFS;\n\t\t\tgoto lockdep_release;\n\t\t}\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&fs_info->transaction_blocked_wait);\n\tspin_unlock(&fs_info->trans_lock);\n\n\t \n\tstart_time = ktime_get_ns();\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(fs_info);\n\tif (ret)\n\t\tgoto lockdep_release;\n\n\tret = btrfs_run_delayed_items(trans);\n\tif (ret)\n\t\tgoto lockdep_release;\n\n\t \n\tbtrfs_lockdep_release(fs_info, btrfs_trans_num_extwriters);\n\tbtrfs_might_wait_for_event(fs_info, btrfs_trans_num_extwriters);\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t \n\tret = btrfs_run_delayed_items(trans);\n\tif (ret) {\n\t\tbtrfs_lockdep_release(fs_info, btrfs_trans_num_writers);\n\t\tgoto cleanup_transaction;\n\t}\n\n\tbtrfs_wait_delalloc_flush(fs_info);\n\n\t \n\tbtrfs_might_wait_for_event(fs_info, btrfs_trans_pending_ordered);\n\twait_event(cur_trans->pending_wait,\n\t\t   atomic_read(&cur_trans->pending_ordered) == 0);\n\n\tbtrfs_scrub_pause(fs_info);\n\t \n\tspin_lock(&fs_info->trans_lock);\n\tadd_pending_snapshot(trans);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&fs_info->trans_lock);\n\n\t \n\tbtrfs_lockdep_release(fs_info, btrfs_trans_num_writers);\n\tbtrfs_might_wait_for_event(fs_info, btrfs_trans_num_writers);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t \n\tbtrfs_trans_state_lockdep_acquire(fs_info, BTRFS_LOCKDEP_TRANS_COMPLETED);\n\tbtrfs_trans_state_lockdep_acquire(fs_info, BTRFS_LOCKDEP_TRANS_SUPER_COMMITTED);\n\tbtrfs_trans_state_lockdep_acquire(fs_info, BTRFS_LOCKDEP_TRANS_UNBLOCKED);\n\n\t \n\tclear_bit(BTRFS_FS_COMMIT_TRANS, &fs_info->flags);\n\n\tif (TRANS_ABORTED(cur_trans)) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_trans_state_lockdep_release(fs_info, BTRFS_LOCKDEP_TRANS_UNBLOCKED);\n\t\tgoto scrub_continue;\n\t}\n\t \n\tmutex_lock(&fs_info->reloc_mutex);\n\n\t \n\tret = create_pending_snapshots(trans);\n\tif (ret)\n\t\tgoto unlock_reloc;\n\n\t \n\tret = btrfs_run_delayed_items(trans);\n\tif (ret)\n\t\tgoto unlock_reloc;\n\n\tret = btrfs_run_delayed_refs(trans, (unsigned long)-1);\n\tif (ret)\n\t\tgoto unlock_reloc;\n\n\t \n\tbtrfs_assert_delayed_root_empty(fs_info);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\tret = commit_fs_roots(trans);\n\tif (ret)\n\t\tgoto unlock_reloc;\n\n\t \n\tbtrfs_free_log_root_tree(trans, fs_info);\n\n\t \n\tret = btrfs_qgroup_account_extents(trans);\n\tif (ret < 0)\n\t\tgoto unlock_reloc;\n\n\tret = commit_cowonly_roots(trans);\n\tif (ret)\n\t\tgoto unlock_reloc;\n\n\t \n\tif (TRANS_ABORTED(cur_trans)) {\n\t\tret = cur_trans->aborted;\n\t\tgoto unlock_reloc;\n\t}\n\n\tcur_trans = fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&fs_info->tree_root->root_item,\n\t\t\t    fs_info->tree_root->node);\n\tlist_add_tail(&fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&fs_info->chunk_root->root_item,\n\t\t\t    fs_info->chunk_root->node);\n\tlist_add_tail(&fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tif (btrfs_fs_incompat(fs_info, EXTENT_TREE_V2)) {\n\t\tbtrfs_set_root_node(&fs_info->block_group_root->root_item,\n\t\t\t\t    fs_info->block_group_root->node);\n\t\tlist_add_tail(&fs_info->block_group_root->dirty_list,\n\t\t\t      &cur_trans->switch_commits);\n\t}\n\n\tswitch_commit_roots(trans);\n\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tASSERT(list_empty(&cur_trans->io_bgs));\n\tupdate_super_roots(fs_info);\n\n\tbtrfs_set_super_log_root(fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(fs_info->super_copy, 0);\n\tmemcpy(fs_info->super_for_commit, fs_info->super_copy,\n\t       sizeof(*fs_info->super_copy));\n\n\tbtrfs_commit_device_sizes(cur_trans);\n\n\tclear_bit(BTRFS_FS_LOG1_ERR, &fs_info->flags);\n\tclear_bit(BTRFS_FS_LOG2_ERR, &fs_info->flags);\n\n\tbtrfs_trans_release_chunk_metadata(trans);\n\n\t \n\tmutex_lock(&fs_info->tree_log_mutex);\n\n\tspin_lock(&fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\tfs_info->running_transaction = NULL;\n\tspin_unlock(&fs_info->trans_lock);\n\tmutex_unlock(&fs_info->reloc_mutex);\n\n\twake_up(&fs_info->transaction_wait);\n\tbtrfs_trans_state_lockdep_release(fs_info, BTRFS_LOCKDEP_TRANS_UNBLOCKED);\n\n\t \n\tif (test_bit(BTRFS_FS_FEATURE_CHANGED, &fs_info->flags) &&\n\t    fs_info->cleaner_kthread)\n\t\twake_up_process(fs_info->cleaner_kthread);\n\n\tret = btrfs_write_and_wait_transaction(trans);\n\tif (ret) {\n\t\tbtrfs_handle_fs_error(fs_info, ret,\n\t\t\t\t      \"Error while writing out transaction\");\n\t\tmutex_unlock(&fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_all_supers(fs_info, 0);\n\t \n\tmutex_unlock(&fs_info->tree_log_mutex);\n\tif (ret)\n\t\tgoto scrub_continue;\n\n\t \n\tcur_trans->state = TRANS_STATE_SUPER_COMMITTED;\n\twake_up(&cur_trans->commit_wait);\n\tbtrfs_trans_state_lockdep_release(fs_info, BTRFS_LOCKDEP_TRANS_SUPER_COMMITTED);\n\n\tbtrfs_finish_extent_commit(trans);\n\n\tif (test_bit(BTRFS_TRANS_HAVE_FREE_BGS, &cur_trans->flags))\n\t\tbtrfs_clear_space_info_full(fs_info);\n\n\tfs_info->last_trans_committed = cur_trans->transid;\n\t \n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\tbtrfs_trans_state_lockdep_release(fs_info, BTRFS_LOCKDEP_TRANS_COMPLETED);\n\n\tspin_lock(&fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(fs_info);\n\n\tinterval = ktime_get_ns() - start_time;\n\n\tbtrfs_scrub_continue(fs_info);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tupdate_commit_stats(fs_info, interval);\n\n\treturn ret;\n\nunlock_reloc:\n\tmutex_unlock(&fs_info->reloc_mutex);\n\tbtrfs_trans_state_lockdep_release(fs_info, BTRFS_LOCKDEP_TRANS_UNBLOCKED);\nscrub_continue:\n\tbtrfs_trans_state_lockdep_release(fs_info, BTRFS_LOCKDEP_TRANS_SUPER_COMMITTED);\n\tbtrfs_trans_state_lockdep_release(fs_info, BTRFS_LOCKDEP_TRANS_COMPLETED);\n\tbtrfs_scrub_continue(fs_info);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans);\n\tbtrfs_cleanup_pending_block_groups(trans);\n\tbtrfs_trans_release_chunk_metadata(trans);\n\ttrans->block_rsv = NULL;\n\tbtrfs_warn(fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, ret);\n\n\treturn ret;\n\nlockdep_release:\n\tbtrfs_lockdep_release(fs_info, btrfs_trans_num_extwriters);\n\tbtrfs_lockdep_release(fs_info, btrfs_trans_num_writers);\n\tgoto cleanup_transaction;\n\nlockdep_trans_commit_start_release:\n\tbtrfs_trans_state_lockdep_release(fs_info, BTRFS_LOCKDEP_TRANS_COMMIT_PREP);\n\tbtrfs_end_transaction(trans);\n\treturn ret;\n}\n\n \nint btrfs_clean_one_deleted_snapshot(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root;\n\tint ret;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (list_empty(&fs_info->dead_roots)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn 0;\n\t}\n\troot = list_first_entry(&fs_info->dead_roots,\n\t\t\tstruct btrfs_root, root_list);\n\tlist_del_init(&root->root_list);\n\tspin_unlock(&fs_info->trans_lock);\n\n\tbtrfs_debug(fs_info, \"cleaner removing %llu\", root->root_key.objectid);\n\n\tbtrfs_kill_all_delayed_nodes(root);\n\n\tif (btrfs_header_backref_rev(root->node) <\n\t\t\tBTRFS_MIXED_BACKREF_REV)\n\t\tret = btrfs_drop_snapshot(root, 0, 0);\n\telse\n\t\tret = btrfs_drop_snapshot(root, 1, 0);\n\n\tbtrfs_put_root(root);\n\treturn (ret < 0) ? 0 : 1;\n}\n\n \nvoid __cold __btrfs_abort_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\t      const char *function,\n\t\t\t\t      unsigned int line, int errno, bool first_hit)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\n\tWRITE_ONCE(trans->aborted, errno);\n\tWRITE_ONCE(trans->transaction->aborted, errno);\n\tif (first_hit && errno == -ENOSPC)\n\t\tbtrfs_dump_space_info_for_trans_abort(fs_info);\n\t \n\twake_up(&fs_info->transaction_wait);\n\twake_up(&fs_info->transaction_blocked_wait);\n\t__btrfs_handle_fs_error(fs_info, function, line, errno, NULL);\n}\n\nint __init btrfs_transaction_init(void)\n{\n\tbtrfs_trans_handle_cachep = kmem_cache_create(\"btrfs_trans_handle\",\n\t\t\tsizeof(struct btrfs_trans_handle), 0,\n\t\t\tSLAB_TEMPORARY | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_trans_handle_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid __cold btrfs_transaction_exit(void)\n{\n\tkmem_cache_destroy(btrfs_trans_handle_cachep);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}