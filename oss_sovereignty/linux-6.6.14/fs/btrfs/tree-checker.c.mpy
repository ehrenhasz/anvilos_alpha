{
  "module_name": "tree-checker.c",
  "hash_id": "5c7ff61fc6f186feedcb2c4468521051313dba98956298c15c138b4de6b254c0",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/tree-checker.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/stddef.h>\n#include <linux/error-injection.h>\n#include \"messages.h\"\n#include \"ctree.h\"\n#include \"tree-checker.h\"\n#include \"disk-io.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"misc.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n#include \"file-item.h\"\n#include \"inode-item.h\"\n\n \n\n \n__printf(3, 4)\n__cold\nstatic void generic_err(const struct extent_buffer *eb, int slot,\n\t\t\tconst char *fmt, ...)\n{\n\tconst struct btrfs_fs_info *fs_info = eb->fs_info;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tbtrfs_crit(fs_info,\n\t\t\"corrupt %s: root=%llu block=%llu slot=%d, %pV\",\n\t\tbtrfs_header_level(eb) == 0 ? \"leaf\" : \"node\",\n\t\tbtrfs_header_owner(eb), btrfs_header_bytenr(eb), slot, &vaf);\n\tva_end(args);\n}\n\n \n__printf(3, 4)\n__cold\nstatic void file_extent_err(const struct extent_buffer *eb, int slot,\n\t\t\t    const char *fmt, ...)\n{\n\tconst struct btrfs_fs_info *fs_info = eb->fs_info;\n\tstruct btrfs_key key;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tbtrfs_item_key_to_cpu(eb, &key, slot);\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tbtrfs_crit(fs_info,\n\t\"corrupt %s: root=%llu block=%llu slot=%d ino=%llu file_offset=%llu, %pV\",\n\t\tbtrfs_header_level(eb) == 0 ? \"leaf\" : \"node\",\n\t\tbtrfs_header_owner(eb), btrfs_header_bytenr(eb), slot,\n\t\tkey.objectid, key.offset, &vaf);\n\tva_end(args);\n}\n\n \n#define CHECK_FE_ALIGNED(leaf, slot, fi, name, alignment)\t\t      \\\n({\t\t\t\t\t\t\t\t\t      \\\n\tif (unlikely(!IS_ALIGNED(btrfs_file_extent_##name((leaf), (fi)),      \\\n\t\t\t\t (alignment))))\t\t\t\t      \\\n\t\tfile_extent_err((leaf), (slot),\t\t\t\t      \\\n\t\"invalid %s for file extent, have %llu, should be aligned to %u\",     \\\n\t\t\t(#name), btrfs_file_extent_##name((leaf), (fi)),      \\\n\t\t\t(alignment));\t\t\t\t\t      \\\n\t(!IS_ALIGNED(btrfs_file_extent_##name((leaf), (fi)), (alignment)));   \\\n})\n\nstatic u64 file_extent_end(struct extent_buffer *leaf,\n\t\t\t   struct btrfs_key *key,\n\t\t\t   struct btrfs_file_extent_item *extent)\n{\n\tu64 end;\n\tu64 len;\n\n\tif (btrfs_file_extent_type(leaf, extent) == BTRFS_FILE_EXTENT_INLINE) {\n\t\tlen = btrfs_file_extent_ram_bytes(leaf, extent);\n\t\tend = ALIGN(key->offset + len, leaf->fs_info->sectorsize);\n\t} else {\n\t\tlen = btrfs_file_extent_num_bytes(leaf, extent);\n\t\tend = key->offset + len;\n\t}\n\treturn end;\n}\n\n \n__printf(3, 4)\n__cold\nstatic void dir_item_err(const struct extent_buffer *eb, int slot,\n\t\t\t const char *fmt, ...)\n{\n\tconst struct btrfs_fs_info *fs_info = eb->fs_info;\n\tstruct btrfs_key key;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tbtrfs_item_key_to_cpu(eb, &key, slot);\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tbtrfs_crit(fs_info,\n\t\t\"corrupt %s: root=%llu block=%llu slot=%d ino=%llu, %pV\",\n\t\tbtrfs_header_level(eb) == 0 ? \"leaf\" : \"node\",\n\t\tbtrfs_header_owner(eb), btrfs_header_bytenr(eb), slot,\n\t\tkey.objectid, &vaf);\n\tva_end(args);\n}\n\n \nstatic bool check_prev_ino(struct extent_buffer *leaf,\n\t\t\t   struct btrfs_key *key, int slot,\n\t\t\t   struct btrfs_key *prev_key)\n{\n\t \n\tif (slot == 0)\n\t\treturn true;\n\n\t \n\tASSERT(key->type == BTRFS_XATTR_ITEM_KEY ||\n\t       key->type == BTRFS_INODE_REF_KEY ||\n\t       key->type == BTRFS_DIR_INDEX_KEY ||\n\t       key->type == BTRFS_DIR_ITEM_KEY ||\n\t       key->type == BTRFS_EXTENT_DATA_KEY);\n\n\t \n\tif (!is_fstree(btrfs_header_owner(leaf)))\n\t\treturn true;\n\n\tif (key->objectid == prev_key->objectid)\n\t\treturn true;\n\n\t \n\tdir_item_err(leaf, slot,\n\t\t\"invalid previous key objectid, have %llu expect %llu\",\n\t\tprev_key->objectid, key->objectid);\n\treturn false;\n}\nstatic int check_extent_data_item(struct extent_buffer *leaf,\n\t\t\t\t  struct btrfs_key *key, int slot,\n\t\t\t\t  struct btrfs_key *prev_key)\n{\n\tstruct btrfs_fs_info *fs_info = leaf->fs_info;\n\tstruct btrfs_file_extent_item *fi;\n\tu32 sectorsize = fs_info->sectorsize;\n\tu32 item_size = btrfs_item_size(leaf, slot);\n\tu64 extent_end;\n\n\tif (unlikely(!IS_ALIGNED(key->offset, sectorsize))) {\n\t\tfile_extent_err(leaf, slot,\n\"unaligned file_offset for file extent, have %llu should be aligned to %u\",\n\t\t\tkey->offset, sectorsize);\n\t\treturn -EUCLEAN;\n\t}\n\n\t \n\tif (unlikely(!check_prev_ino(leaf, key, slot, prev_key)))\n\t\treturn -EUCLEAN;\n\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\n\t \n\tif (unlikely(item_size < BTRFS_FILE_EXTENT_INLINE_DATA_START)) {\n\t\tfile_extent_err(leaf, slot,\n\t\t\t\t\"invalid item size, have %u expect [%zu, %u)\",\n\t\t\t\titem_size, BTRFS_FILE_EXTENT_INLINE_DATA_START,\n\t\t\t\tSZ_4K);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(btrfs_file_extent_type(leaf, fi) >=\n\t\t     BTRFS_NR_FILE_EXTENT_TYPES)) {\n\t\tfile_extent_err(leaf, slot,\n\t\t\"invalid type for file extent, have %u expect range [0, %u]\",\n\t\t\tbtrfs_file_extent_type(leaf, fi),\n\t\t\tBTRFS_NR_FILE_EXTENT_TYPES - 1);\n\t\treturn -EUCLEAN;\n\t}\n\n\t \n\tif (unlikely(btrfs_file_extent_compression(leaf, fi) >=\n\t\t     BTRFS_NR_COMPRESS_TYPES)) {\n\t\tfile_extent_err(leaf, slot,\n\t\"invalid compression for file extent, have %u expect range [0, %u]\",\n\t\t\tbtrfs_file_extent_compression(leaf, fi),\n\t\t\tBTRFS_NR_COMPRESS_TYPES - 1);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(btrfs_file_extent_encryption(leaf, fi))) {\n\t\tfile_extent_err(leaf, slot,\n\t\t\t\"invalid encryption for file extent, have %u expect 0\",\n\t\t\tbtrfs_file_extent_encryption(leaf, fi));\n\t\treturn -EUCLEAN;\n\t}\n\tif (btrfs_file_extent_type(leaf, fi) == BTRFS_FILE_EXTENT_INLINE) {\n\t\t \n\t\tif (unlikely(key->offset)) {\n\t\t\tfile_extent_err(leaf, slot,\n\t\t\"invalid file_offset for inline file extent, have %llu expect 0\",\n\t\t\t\tkey->offset);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\t \n\t\tif (btrfs_file_extent_compression(leaf, fi) !=\n\t\t    BTRFS_COMPRESS_NONE)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (unlikely(item_size != BTRFS_FILE_EXTENT_INLINE_DATA_START +\n\t\t\t\t\t  btrfs_file_extent_ram_bytes(leaf, fi))) {\n\t\t\tfile_extent_err(leaf, slot,\n\t\"invalid ram_bytes for uncompressed inline extent, have %u expect %llu\",\n\t\t\t\titem_size, BTRFS_FILE_EXTENT_INLINE_DATA_START +\n\t\t\t\tbtrfs_file_extent_ram_bytes(leaf, fi));\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tif (unlikely(item_size != sizeof(*fi))) {\n\t\tfile_extent_err(leaf, slot,\n\t\"invalid item size for reg/prealloc file extent, have %u expect %zu\",\n\t\t\titem_size, sizeof(*fi));\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(CHECK_FE_ALIGNED(leaf, slot, fi, ram_bytes, sectorsize) ||\n\t\t     CHECK_FE_ALIGNED(leaf, slot, fi, disk_bytenr, sectorsize) ||\n\t\t     CHECK_FE_ALIGNED(leaf, slot, fi, disk_num_bytes, sectorsize) ||\n\t\t     CHECK_FE_ALIGNED(leaf, slot, fi, offset, sectorsize) ||\n\t\t     CHECK_FE_ALIGNED(leaf, slot, fi, num_bytes, sectorsize)))\n\t\treturn -EUCLEAN;\n\n\t \n\tif (unlikely(check_add_overflow(btrfs_file_extent_num_bytes(leaf, fi),\n\t\t\t\t\tkey->offset, &extent_end))) {\n\t\tfile_extent_err(leaf, slot,\n\t\"extent end overflow, have file offset %llu extent num bytes %llu\",\n\t\t\t\tkey->offset,\n\t\t\t\tbtrfs_file_extent_num_bytes(leaf, fi));\n\t\treturn -EUCLEAN;\n\t}\n\n\t \n\tif (slot > 0 &&\n\t    prev_key->objectid == key->objectid &&\n\t    prev_key->type == BTRFS_EXTENT_DATA_KEY) {\n\t\tstruct btrfs_file_extent_item *prev_fi;\n\t\tu64 prev_end;\n\n\t\tprev_fi = btrfs_item_ptr(leaf, slot - 1,\n\t\t\t\t\t struct btrfs_file_extent_item);\n\t\tprev_end = file_extent_end(leaf, prev_key, prev_fi);\n\t\tif (unlikely(prev_end > key->offset)) {\n\t\t\tfile_extent_err(leaf, slot - 1,\n\"file extent end range (%llu) goes beyond start offset (%llu) of the next file extent\",\n\t\t\t\t\tprev_end, key->offset);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int check_csum_item(struct extent_buffer *leaf, struct btrfs_key *key,\n\t\t\t   int slot, struct btrfs_key *prev_key)\n{\n\tstruct btrfs_fs_info *fs_info = leaf->fs_info;\n\tu32 sectorsize = fs_info->sectorsize;\n\tconst u32 csumsize = fs_info->csum_size;\n\n\tif (unlikely(key->objectid != BTRFS_EXTENT_CSUM_OBJECTID)) {\n\t\tgeneric_err(leaf, slot,\n\t\t\"invalid key objectid for csum item, have %llu expect %llu\",\n\t\t\tkey->objectid, BTRFS_EXTENT_CSUM_OBJECTID);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(!IS_ALIGNED(key->offset, sectorsize))) {\n\t\tgeneric_err(leaf, slot,\n\t\"unaligned key offset for csum item, have %llu should be aligned to %u\",\n\t\t\tkey->offset, sectorsize);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(!IS_ALIGNED(btrfs_item_size(leaf, slot), csumsize))) {\n\t\tgeneric_err(leaf, slot,\n\t\"unaligned item size for csum item, have %u should be aligned to %u\",\n\t\t\tbtrfs_item_size(leaf, slot), csumsize);\n\t\treturn -EUCLEAN;\n\t}\n\tif (slot > 0 && prev_key->type == BTRFS_EXTENT_CSUM_KEY) {\n\t\tu64 prev_csum_end;\n\t\tu32 prev_item_size;\n\n\t\tprev_item_size = btrfs_item_size(leaf, slot - 1);\n\t\tprev_csum_end = (prev_item_size / csumsize) * sectorsize;\n\t\tprev_csum_end += prev_key->offset;\n\t\tif (unlikely(prev_csum_end > key->offset)) {\n\t\t\tgeneric_err(leaf, slot - 1,\n\"csum end range (%llu) goes beyond the start range (%llu) of the next csum item\",\n\t\t\t\t    prev_csum_end, key->offset);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n#define inode_item_err(eb, slot, fmt, ...)\t\t\t\\\n\tdir_item_err(eb, slot, fmt, __VA_ARGS__)\n\nstatic int check_inode_key(struct extent_buffer *leaf, struct btrfs_key *key,\n\t\t\t   int slot)\n{\n\tstruct btrfs_key item_key;\n\tbool is_inode_item;\n\n\tbtrfs_item_key_to_cpu(leaf, &item_key, slot);\n\tis_inode_item = (item_key.type == BTRFS_INODE_ITEM_KEY);\n\n\t \n\tif (item_key.type == BTRFS_XATTR_ITEM_KEY) {\n\t\tif (unlikely(key->objectid != 0 || key->type != 0 ||\n\t\t\t     key->offset != 0))\n\t\t\treturn -EUCLEAN;\n\t\treturn 0;\n\t}\n\n\tif (unlikely((key->objectid < BTRFS_FIRST_FREE_OBJECTID ||\n\t\t      key->objectid > BTRFS_LAST_FREE_OBJECTID) &&\n\t\t     key->objectid != BTRFS_ROOT_TREE_DIR_OBJECTID &&\n\t\t     key->objectid != BTRFS_FREE_INO_OBJECTID)) {\n\t\tif (is_inode_item) {\n\t\t\tgeneric_err(leaf, slot,\n\t\"invalid key objectid: has %llu expect %llu or [%llu, %llu] or %llu\",\n\t\t\t\tkey->objectid, BTRFS_ROOT_TREE_DIR_OBJECTID,\n\t\t\t\tBTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\tBTRFS_LAST_FREE_OBJECTID,\n\t\t\t\tBTRFS_FREE_INO_OBJECTID);\n\t\t} else {\n\t\t\tdir_item_err(leaf, slot,\n\"invalid location key objectid: has %llu expect %llu or [%llu, %llu] or %llu\",\n\t\t\t\tkey->objectid, BTRFS_ROOT_TREE_DIR_OBJECTID,\n\t\t\t\tBTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\tBTRFS_LAST_FREE_OBJECTID,\n\t\t\t\tBTRFS_FREE_INO_OBJECTID);\n\t\t}\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(key->offset != 0)) {\n\t\tif (is_inode_item)\n\t\t\tinode_item_err(leaf, slot,\n\t\t\t\t       \"invalid key offset: has %llu expect 0\",\n\t\t\t\t       key->offset);\n\t\telse\n\t\t\tdir_item_err(leaf, slot,\n\t\t\t\t\"invalid location key offset:has %llu expect 0\",\n\t\t\t\tkey->offset);\n\t\treturn -EUCLEAN;\n\t}\n\treturn 0;\n}\n\nstatic int check_root_key(struct extent_buffer *leaf, struct btrfs_key *key,\n\t\t\t  int slot)\n{\n\tstruct btrfs_key item_key;\n\tbool is_root_item;\n\n\tbtrfs_item_key_to_cpu(leaf, &item_key, slot);\n\tis_root_item = (item_key.type == BTRFS_ROOT_ITEM_KEY);\n\n\t \n\tif (unlikely(is_root_item && key->objectid == BTRFS_TREE_RELOC_OBJECTID &&\n\t\t     !is_fstree(key->offset))) {\n\t\tgeneric_err(leaf, slot,\n\t\t\"invalid reloc tree for root %lld, root id is not a subvolume tree\",\n\t\t\t    key->offset);\n\t\treturn -EUCLEAN;\n\t}\n\n\t \n\tif (unlikely(key->objectid == 0)) {\n\t\tif (is_root_item)\n\t\t\tgeneric_err(leaf, slot, \"invalid root id 0\");\n\t\telse\n\t\t\tdir_item_err(leaf, slot,\n\t\t\t\t     \"invalid location key root id 0\");\n\t\treturn -EUCLEAN;\n\t}\n\n\t \n\tif (unlikely(!is_fstree(key->objectid) && !is_root_item)) {\n\t\tdir_item_err(leaf, slot,\n\t\t\"invalid location key objectid, have %llu expect [%llu, %llu]\",\n\t\t\t\tkey->objectid, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\tBTRFS_LAST_FREE_OBJECTID);\n\t\treturn -EUCLEAN;\n\t}\n\n\t \n\tif (unlikely(key->objectid == BTRFS_TREE_RELOC_OBJECTID &&\n\t\t     key->offset == 0)) {\n\t\tgeneric_err(leaf, slot, \"invalid root id 0 for reloc tree\");\n\t\treturn -EUCLEAN;\n\t}\n\treturn 0;\n}\n\nstatic int check_dir_item(struct extent_buffer *leaf,\n\t\t\t  struct btrfs_key *key, struct btrfs_key *prev_key,\n\t\t\t  int slot)\n{\n\tstruct btrfs_fs_info *fs_info = leaf->fs_info;\n\tstruct btrfs_dir_item *di;\n\tu32 item_size = btrfs_item_size(leaf, slot);\n\tu32 cur = 0;\n\n\tif (unlikely(!check_prev_ino(leaf, key, slot, prev_key)))\n\t\treturn -EUCLEAN;\n\n\tdi = btrfs_item_ptr(leaf, slot, struct btrfs_dir_item);\n\twhile (cur < item_size) {\n\t\tstruct btrfs_key location_key;\n\t\tu32 name_len;\n\t\tu32 data_len;\n\t\tu32 max_name_len;\n\t\tu32 total_size;\n\t\tu32 name_hash;\n\t\tu8 dir_type;\n\t\tint ret;\n\n\t\t \n\t\tif (unlikely(cur + sizeof(*di) > item_size)) {\n\t\t\tdir_item_err(leaf, slot,\n\t\t\"dir item header crosses item boundary, have %zu boundary %u\",\n\t\t\t\tcur + sizeof(*di), item_size);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\t \n\t\tbtrfs_dir_item_key_to_cpu(leaf, di, &location_key);\n\t\tif (location_key.type == BTRFS_ROOT_ITEM_KEY) {\n\t\t\tret = check_root_key(leaf, &location_key, slot);\n\t\t\tif (unlikely(ret < 0))\n\t\t\t\treturn ret;\n\t\t} else if (location_key.type == BTRFS_INODE_ITEM_KEY ||\n\t\t\t   location_key.type == 0) {\n\t\t\tret = check_inode_key(leaf, &location_key, slot);\n\t\t\tif (unlikely(ret < 0))\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tdir_item_err(leaf, slot,\n\t\t\t\"invalid location key type, have %u, expect %u or %u\",\n\t\t\t\t     location_key.type, BTRFS_ROOT_ITEM_KEY,\n\t\t\t\t     BTRFS_INODE_ITEM_KEY);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\t \n\t\tdir_type = btrfs_dir_ftype(leaf, di);\n\t\tif (unlikely(dir_type >= BTRFS_FT_MAX)) {\n\t\t\tdir_item_err(leaf, slot,\n\t\t\t\"invalid dir item type, have %u expect [0, %u)\",\n\t\t\t\tdir_type, BTRFS_FT_MAX);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\tif (unlikely(key->type == BTRFS_XATTR_ITEM_KEY &&\n\t\t\t     dir_type != BTRFS_FT_XATTR)) {\n\t\t\tdir_item_err(leaf, slot,\n\t\t\"invalid dir item type for XATTR key, have %u expect %u\",\n\t\t\t\tdir_type, BTRFS_FT_XATTR);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t\tif (unlikely(dir_type == BTRFS_FT_XATTR &&\n\t\t\t     key->type != BTRFS_XATTR_ITEM_KEY)) {\n\t\t\tdir_item_err(leaf, slot,\n\t\t\t\"xattr dir type found for non-XATTR key\");\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t\tif (dir_type == BTRFS_FT_XATTR)\n\t\t\tmax_name_len = XATTR_NAME_MAX;\n\t\telse\n\t\t\tmax_name_len = BTRFS_NAME_LEN;\n\n\t\t \n\t\tname_len = btrfs_dir_name_len(leaf, di);\n\t\tdata_len = btrfs_dir_data_len(leaf, di);\n\t\tif (unlikely(name_len > max_name_len)) {\n\t\t\tdir_item_err(leaf, slot,\n\t\t\t\"dir item name len too long, have %u max %u\",\n\t\t\t\tname_len, max_name_len);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t\tif (unlikely(name_len + data_len > BTRFS_MAX_XATTR_SIZE(fs_info))) {\n\t\t\tdir_item_err(leaf, slot,\n\t\t\t\"dir item name and data len too long, have %u max %u\",\n\t\t\t\tname_len + data_len,\n\t\t\t\tBTRFS_MAX_XATTR_SIZE(fs_info));\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\tif (unlikely(data_len && dir_type != BTRFS_FT_XATTR)) {\n\t\t\tdir_item_err(leaf, slot,\n\t\t\t\"dir item with invalid data len, have %u expect 0\",\n\t\t\t\tdata_len);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\ttotal_size = sizeof(*di) + name_len + data_len;\n\n\t\t \n\t\tif (unlikely(cur + total_size > item_size)) {\n\t\t\tdir_item_err(leaf, slot,\n\t\t\"dir item data crosses item boundary, have %u boundary %u\",\n\t\t\t\tcur + total_size, item_size);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\t \n\t\tif (key->type == BTRFS_DIR_ITEM_KEY ||\n\t\t    key->type == BTRFS_XATTR_ITEM_KEY) {\n\t\t\tchar namebuf[max(BTRFS_NAME_LEN, XATTR_NAME_MAX)];\n\n\t\t\tread_extent_buffer(leaf, namebuf,\n\t\t\t\t\t(unsigned long)(di + 1), name_len);\n\t\t\tname_hash = btrfs_name_hash(namebuf, name_len);\n\t\t\tif (unlikely(key->offset != name_hash)) {\n\t\t\t\tdir_item_err(leaf, slot,\n\t\t\"name hash mismatch with key, have 0x%016x expect 0x%016llx\",\n\t\t\t\t\tname_hash, key->offset);\n\t\t\t\treturn -EUCLEAN;\n\t\t\t}\n\t\t}\n\t\tcur += total_size;\n\t\tdi = (struct btrfs_dir_item *)((void *)di + total_size);\n\t}\n\treturn 0;\n}\n\n__printf(3, 4)\n__cold\nstatic void block_group_err(const struct extent_buffer *eb, int slot,\n\t\t\t    const char *fmt, ...)\n{\n\tconst struct btrfs_fs_info *fs_info = eb->fs_info;\n\tstruct btrfs_key key;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tbtrfs_item_key_to_cpu(eb, &key, slot);\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tbtrfs_crit(fs_info,\n\t\"corrupt %s: root=%llu block=%llu slot=%d bg_start=%llu bg_len=%llu, %pV\",\n\t\tbtrfs_header_level(eb) == 0 ? \"leaf\" : \"node\",\n\t\tbtrfs_header_owner(eb), btrfs_header_bytenr(eb), slot,\n\t\tkey.objectid, key.offset, &vaf);\n\tva_end(args);\n}\n\nstatic int check_block_group_item(struct extent_buffer *leaf,\n\t\t\t\t  struct btrfs_key *key, int slot)\n{\n\tstruct btrfs_fs_info *fs_info = leaf->fs_info;\n\tstruct btrfs_block_group_item bgi;\n\tu32 item_size = btrfs_item_size(leaf, slot);\n\tu64 chunk_objectid;\n\tu64 flags;\n\tu64 type;\n\n\t \n\tif (unlikely(key->offset == 0)) {\n\t\tblock_group_err(leaf, slot,\n\t\t\t\t\"invalid block group size 0\");\n\t\treturn -EUCLEAN;\n\t}\n\n\tif (unlikely(item_size != sizeof(bgi))) {\n\t\tblock_group_err(leaf, slot,\n\t\t\t\"invalid item size, have %u expect %zu\",\n\t\t\t\titem_size, sizeof(bgi));\n\t\treturn -EUCLEAN;\n\t}\n\n\tread_extent_buffer(leaf, &bgi, btrfs_item_ptr_offset(leaf, slot),\n\t\t\t   sizeof(bgi));\n\tchunk_objectid = btrfs_stack_block_group_chunk_objectid(&bgi);\n\tif (btrfs_fs_incompat(fs_info, EXTENT_TREE_V2)) {\n\t\t \n\t\tif (unlikely(fs_info->nr_global_roots &&\n\t\t\t     chunk_objectid >= fs_info->nr_global_roots)) {\n\t\t\tblock_group_err(leaf, slot,\n\t\"invalid block group global root id, have %llu, needs to be <= %llu\",\n\t\t\t\t\tchunk_objectid,\n\t\t\t\t\tfs_info->nr_global_roots);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t} else if (unlikely(chunk_objectid != BTRFS_FIRST_CHUNK_TREE_OBJECTID)) {\n\t\tblock_group_err(leaf, slot,\n\t\t\"invalid block group chunk objectid, have %llu expect %llu\",\n\t\t\t\tbtrfs_stack_block_group_chunk_objectid(&bgi),\n\t\t\t\tBTRFS_FIRST_CHUNK_TREE_OBJECTID);\n\t\treturn -EUCLEAN;\n\t}\n\n\tif (unlikely(btrfs_stack_block_group_used(&bgi) > key->offset)) {\n\t\tblock_group_err(leaf, slot,\n\t\t\t\"invalid block group used, have %llu expect [0, %llu)\",\n\t\t\t\tbtrfs_stack_block_group_used(&bgi), key->offset);\n\t\treturn -EUCLEAN;\n\t}\n\n\tflags = btrfs_stack_block_group_flags(&bgi);\n\tif (unlikely(hweight64(flags & BTRFS_BLOCK_GROUP_PROFILE_MASK) > 1)) {\n\t\tblock_group_err(leaf, slot,\n\"invalid profile flags, have 0x%llx (%lu bits set) expect no more than 1 bit set\",\n\t\t\tflags & BTRFS_BLOCK_GROUP_PROFILE_MASK,\n\t\t\thweight64(flags & BTRFS_BLOCK_GROUP_PROFILE_MASK));\n\t\treturn -EUCLEAN;\n\t}\n\n\ttype = flags & BTRFS_BLOCK_GROUP_TYPE_MASK;\n\tif (unlikely(type != BTRFS_BLOCK_GROUP_DATA &&\n\t\t     type != BTRFS_BLOCK_GROUP_METADATA &&\n\t\t     type != BTRFS_BLOCK_GROUP_SYSTEM &&\n\t\t     type != (BTRFS_BLOCK_GROUP_METADATA |\n\t\t\t      BTRFS_BLOCK_GROUP_DATA))) {\n\t\tblock_group_err(leaf, slot,\n\"invalid type, have 0x%llx (%lu bits set) expect either 0x%llx, 0x%llx, 0x%llx or 0x%llx\",\n\t\t\ttype, hweight64(type),\n\t\t\tBTRFS_BLOCK_GROUP_DATA, BTRFS_BLOCK_GROUP_METADATA,\n\t\t\tBTRFS_BLOCK_GROUP_SYSTEM,\n\t\t\tBTRFS_BLOCK_GROUP_METADATA | BTRFS_BLOCK_GROUP_DATA);\n\t\treturn -EUCLEAN;\n\t}\n\treturn 0;\n}\n\n__printf(4, 5)\n__cold\nstatic void chunk_err(const struct extent_buffer *leaf,\n\t\t      const struct btrfs_chunk *chunk, u64 logical,\n\t\t      const char *fmt, ...)\n{\n\tconst struct btrfs_fs_info *fs_info = leaf->fs_info;\n\tbool is_sb;\n\tstruct va_format vaf;\n\tva_list args;\n\tint i;\n\tint slot = -1;\n\n\t \n\tis_sb = (leaf->start == BTRFS_SUPER_INFO_OFFSET);\n\n\tif (!is_sb) {\n\t\t \n\t\tfor (i = 0; i < btrfs_header_nritems(leaf); i++) {\n\t\t\tif (btrfs_item_ptr_offset(leaf, i) ==\n\t\t\t\t\t(unsigned long)chunk) {\n\t\t\t\tslot = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (is_sb)\n\t\tbtrfs_crit(fs_info,\n\t\t\"corrupt superblock syschunk array: chunk_start=%llu, %pV\",\n\t\t\t   logical, &vaf);\n\telse\n\t\tbtrfs_crit(fs_info,\n\t\"corrupt leaf: root=%llu block=%llu slot=%d chunk_start=%llu, %pV\",\n\t\t\t   BTRFS_CHUNK_TREE_OBJECTID, leaf->start, slot,\n\t\t\t   logical, &vaf);\n\tva_end(args);\n}\n\n \nint btrfs_check_chunk_valid(struct extent_buffer *leaf,\n\t\t\t    struct btrfs_chunk *chunk, u64 logical)\n{\n\tstruct btrfs_fs_info *fs_info = leaf->fs_info;\n\tu64 length;\n\tu64 chunk_end;\n\tu64 stripe_len;\n\tu16 num_stripes;\n\tu16 sub_stripes;\n\tu64 type;\n\tu64 features;\n\tbool mixed = false;\n\tint raid_index;\n\tint nparity;\n\tint ncopies;\n\n\tlength = btrfs_chunk_length(leaf, chunk);\n\tstripe_len = btrfs_chunk_stripe_len(leaf, chunk);\n\tnum_stripes = btrfs_chunk_num_stripes(leaf, chunk);\n\tsub_stripes = btrfs_chunk_sub_stripes(leaf, chunk);\n\ttype = btrfs_chunk_type(leaf, chunk);\n\traid_index = btrfs_bg_flags_to_raid_index(type);\n\tncopies = btrfs_raid_array[raid_index].ncopies;\n\tnparity = btrfs_raid_array[raid_index].nparity;\n\n\tif (unlikely(!num_stripes)) {\n\t\tchunk_err(leaf, chunk, logical,\n\t\t\t  \"invalid chunk num_stripes, have %u\", num_stripes);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(num_stripes < ncopies)) {\n\t\tchunk_err(leaf, chunk, logical,\n\t\t\t  \"invalid chunk num_stripes < ncopies, have %u < %d\",\n\t\t\t  num_stripes, ncopies);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(nparity && num_stripes == nparity)) {\n\t\tchunk_err(leaf, chunk, logical,\n\t\t\t  \"invalid chunk num_stripes == nparity, have %u == %d\",\n\t\t\t  num_stripes, nparity);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(!IS_ALIGNED(logical, fs_info->sectorsize))) {\n\t\tchunk_err(leaf, chunk, logical,\n\t\t\"invalid chunk logical, have %llu should aligned to %u\",\n\t\t\t  logical, fs_info->sectorsize);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(btrfs_chunk_sector_size(leaf, chunk) != fs_info->sectorsize)) {\n\t\tchunk_err(leaf, chunk, logical,\n\t\t\t  \"invalid chunk sectorsize, have %u expect %u\",\n\t\t\t  btrfs_chunk_sector_size(leaf, chunk),\n\t\t\t  fs_info->sectorsize);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(!length || !IS_ALIGNED(length, fs_info->sectorsize))) {\n\t\tchunk_err(leaf, chunk, logical,\n\t\t\t  \"invalid chunk length, have %llu\", length);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(check_add_overflow(logical, length, &chunk_end))) {\n\t\tchunk_err(leaf, chunk, logical,\n\"invalid chunk logical start and length, have logical start %llu length %llu\",\n\t\t\t  logical, length);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(!is_power_of_2(stripe_len) || stripe_len != BTRFS_STRIPE_LEN)) {\n\t\tchunk_err(leaf, chunk, logical,\n\t\t\t  \"invalid chunk stripe length: %llu\",\n\t\t\t  stripe_len);\n\t\treturn -EUCLEAN;\n\t}\n\t \n\tif (unlikely(length >= btrfs_stripe_nr_to_offset(U32_MAX))) {\n\t\tchunk_err(leaf, chunk, logical,\n\t\t\t  \"chunk length too large: have %llu limit %llu\",\n\t\t\t  length, btrfs_stripe_nr_to_offset(U32_MAX));\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(type & ~(BTRFS_BLOCK_GROUP_TYPE_MASK |\n\t\t\t      BTRFS_BLOCK_GROUP_PROFILE_MASK))) {\n\t\tchunk_err(leaf, chunk, logical,\n\t\t\t  \"unrecognized chunk type: 0x%llx\",\n\t\t\t  ~(BTRFS_BLOCK_GROUP_TYPE_MASK |\n\t\t\t    BTRFS_BLOCK_GROUP_PROFILE_MASK) &\n\t\t\t  btrfs_chunk_type(leaf, chunk));\n\t\treturn -EUCLEAN;\n\t}\n\n\tif (unlikely(!has_single_bit_set(type & BTRFS_BLOCK_GROUP_PROFILE_MASK) &&\n\t\t     (type & BTRFS_BLOCK_GROUP_PROFILE_MASK) != 0)) {\n\t\tchunk_err(leaf, chunk, logical,\n\t\t\"invalid chunk profile flag: 0x%llx, expect 0 or 1 bit set\",\n\t\t\t  type & BTRFS_BLOCK_GROUP_PROFILE_MASK);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely((type & BTRFS_BLOCK_GROUP_TYPE_MASK) == 0)) {\n\t\tchunk_err(leaf, chunk, logical,\n\t\"missing chunk type flag, have 0x%llx one bit must be set in 0x%llx\",\n\t\t\t  type, BTRFS_BLOCK_GROUP_TYPE_MASK);\n\t\treturn -EUCLEAN;\n\t}\n\n\tif (unlikely((type & BTRFS_BLOCK_GROUP_SYSTEM) &&\n\t\t     (type & (BTRFS_BLOCK_GROUP_METADATA |\n\t\t\t      BTRFS_BLOCK_GROUP_DATA)))) {\n\t\tchunk_err(leaf, chunk, logical,\n\t\t\t  \"system chunk with data or metadata type: 0x%llx\",\n\t\t\t  type);\n\t\treturn -EUCLEAN;\n\t}\n\n\tfeatures = btrfs_super_incompat_flags(fs_info->super_copy);\n\tif (features & BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS)\n\t\tmixed = true;\n\n\tif (!mixed) {\n\t\tif (unlikely((type & BTRFS_BLOCK_GROUP_METADATA) &&\n\t\t\t     (type & BTRFS_BLOCK_GROUP_DATA))) {\n\t\t\tchunk_err(leaf, chunk, logical,\n\t\t\t\"mixed chunk type in non-mixed mode: 0x%llx\", type);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t}\n\n\tif (unlikely((type & BTRFS_BLOCK_GROUP_RAID10 &&\n\t\t      sub_stripes != btrfs_raid_array[BTRFS_RAID_RAID10].sub_stripes) ||\n\t\t     (type & BTRFS_BLOCK_GROUP_RAID1 &&\n\t\t      num_stripes != btrfs_raid_array[BTRFS_RAID_RAID1].devs_min) ||\n\t\t     (type & BTRFS_BLOCK_GROUP_RAID1C3 &&\n\t\t      num_stripes != btrfs_raid_array[BTRFS_RAID_RAID1C3].devs_min) ||\n\t\t     (type & BTRFS_BLOCK_GROUP_RAID1C4 &&\n\t\t      num_stripes != btrfs_raid_array[BTRFS_RAID_RAID1C4].devs_min) ||\n\t\t     (type & BTRFS_BLOCK_GROUP_RAID5 &&\n\t\t      num_stripes < btrfs_raid_array[BTRFS_RAID_RAID5].devs_min) ||\n\t\t     (type & BTRFS_BLOCK_GROUP_RAID6 &&\n\t\t      num_stripes < btrfs_raid_array[BTRFS_RAID_RAID6].devs_min) ||\n\t\t     (type & BTRFS_BLOCK_GROUP_DUP &&\n\t\t      num_stripes != btrfs_raid_array[BTRFS_RAID_DUP].dev_stripes) ||\n\t\t     ((type & BTRFS_BLOCK_GROUP_PROFILE_MASK) == 0 &&\n\t\t      num_stripes != btrfs_raid_array[BTRFS_RAID_SINGLE].dev_stripes))) {\n\t\tchunk_err(leaf, chunk, logical,\n\t\t\t\"invalid num_stripes:sub_stripes %u:%u for profile %llu\",\n\t\t\tnum_stripes, sub_stripes,\n\t\t\ttype & BTRFS_BLOCK_GROUP_PROFILE_MASK);\n\t\treturn -EUCLEAN;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int check_leaf_chunk_item(struct extent_buffer *leaf,\n\t\t\t\t struct btrfs_chunk *chunk,\n\t\t\t\t struct btrfs_key *key, int slot)\n{\n\tint num_stripes;\n\n\tif (unlikely(btrfs_item_size(leaf, slot) < sizeof(struct btrfs_chunk))) {\n\t\tchunk_err(leaf, chunk, key->offset,\n\t\t\t\"invalid chunk item size: have %u expect [%zu, %u)\",\n\t\t\tbtrfs_item_size(leaf, slot),\n\t\t\tsizeof(struct btrfs_chunk),\n\t\t\tBTRFS_LEAF_DATA_SIZE(leaf->fs_info));\n\t\treturn -EUCLEAN;\n\t}\n\n\tnum_stripes = btrfs_chunk_num_stripes(leaf, chunk);\n\t \n\tif (num_stripes == 0)\n\t\tgoto out;\n\n\tif (unlikely(btrfs_chunk_item_size(num_stripes) !=\n\t\t     btrfs_item_size(leaf, slot))) {\n\t\tchunk_err(leaf, chunk, key->offset,\n\t\t\t\"invalid chunk item size: have %u expect %lu\",\n\t\t\tbtrfs_item_size(leaf, slot),\n\t\t\tbtrfs_chunk_item_size(num_stripes));\n\t\treturn -EUCLEAN;\n\t}\nout:\n\treturn btrfs_check_chunk_valid(leaf, chunk, key->offset);\n}\n\n__printf(3, 4)\n__cold\nstatic void dev_item_err(const struct extent_buffer *eb, int slot,\n\t\t\t const char *fmt, ...)\n{\n\tstruct btrfs_key key;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tbtrfs_item_key_to_cpu(eb, &key, slot);\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tbtrfs_crit(eb->fs_info,\n\t\"corrupt %s: root=%llu block=%llu slot=%d devid=%llu %pV\",\n\t\tbtrfs_header_level(eb) == 0 ? \"leaf\" : \"node\",\n\t\tbtrfs_header_owner(eb), btrfs_header_bytenr(eb), slot,\n\t\tkey.objectid, &vaf);\n\tva_end(args);\n}\n\nstatic int check_dev_item(struct extent_buffer *leaf,\n\t\t\t  struct btrfs_key *key, int slot)\n{\n\tstruct btrfs_dev_item *ditem;\n\tconst u32 item_size = btrfs_item_size(leaf, slot);\n\n\tif (unlikely(key->objectid != BTRFS_DEV_ITEMS_OBJECTID)) {\n\t\tdev_item_err(leaf, slot,\n\t\t\t     \"invalid objectid: has=%llu expect=%llu\",\n\t\t\t     key->objectid, BTRFS_DEV_ITEMS_OBJECTID);\n\t\treturn -EUCLEAN;\n\t}\n\n\tif (unlikely(item_size != sizeof(*ditem))) {\n\t\tdev_item_err(leaf, slot, \"invalid item size: has %u expect %zu\",\n\t\t\t     item_size, sizeof(*ditem));\n\t\treturn -EUCLEAN;\n\t}\n\n\tditem = btrfs_item_ptr(leaf, slot, struct btrfs_dev_item);\n\tif (unlikely(btrfs_device_id(leaf, ditem) != key->offset)) {\n\t\tdev_item_err(leaf, slot,\n\t\t\t     \"devid mismatch: key has=%llu item has=%llu\",\n\t\t\t     key->offset, btrfs_device_id(leaf, ditem));\n\t\treturn -EUCLEAN;\n\t}\n\n\t \n\tif (unlikely(btrfs_device_bytes_used(leaf, ditem) >\n\t\t     btrfs_device_total_bytes(leaf, ditem))) {\n\t\tdev_item_err(leaf, slot,\n\t\t\t     \"invalid bytes used: have %llu expect [0, %llu]\",\n\t\t\t     btrfs_device_bytes_used(leaf, ditem),\n\t\t\t     btrfs_device_total_bytes(leaf, ditem));\n\t\treturn -EUCLEAN;\n\t}\n\t \n\treturn 0;\n}\n\nstatic int check_inode_item(struct extent_buffer *leaf,\n\t\t\t    struct btrfs_key *key, int slot)\n{\n\tstruct btrfs_fs_info *fs_info = leaf->fs_info;\n\tstruct btrfs_inode_item *iitem;\n\tu64 super_gen = btrfs_super_generation(fs_info->super_copy);\n\tu32 valid_mask = (S_IFMT | S_ISUID | S_ISGID | S_ISVTX | 0777);\n\tconst u32 item_size = btrfs_item_size(leaf, slot);\n\tu32 mode;\n\tint ret;\n\tu32 flags;\n\tu32 ro_flags;\n\n\tret = check_inode_key(leaf, key, slot);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tif (unlikely(item_size != sizeof(*iitem))) {\n\t\tgeneric_err(leaf, slot, \"invalid item size: has %u expect %zu\",\n\t\t\t    item_size, sizeof(*iitem));\n\t\treturn -EUCLEAN;\n\t}\n\n\tiitem = btrfs_item_ptr(leaf, slot, struct btrfs_inode_item);\n\n\t \n\tif (unlikely(btrfs_inode_generation(leaf, iitem) > super_gen + 1)) {\n\t\tinode_item_err(leaf, slot,\n\t\t\t\"invalid inode generation: has %llu expect (0, %llu]\",\n\t\t\t       btrfs_inode_generation(leaf, iitem),\n\t\t\t       super_gen + 1);\n\t\treturn -EUCLEAN;\n\t}\n\t \n\tif (unlikely(btrfs_inode_transid(leaf, iitem) > super_gen + 1)) {\n\t\tinode_item_err(leaf, slot,\n\t\t\t\"invalid inode transid: has %llu expect [0, %llu]\",\n\t\t\t       btrfs_inode_transid(leaf, iitem), super_gen + 1);\n\t\treturn -EUCLEAN;\n\t}\n\n\t \n\tmode = btrfs_inode_mode(leaf, iitem);\n\tif (unlikely(mode & ~valid_mask)) {\n\t\tinode_item_err(leaf, slot,\n\t\t\t       \"unknown mode bit detected: 0x%x\",\n\t\t\t       mode & ~valid_mask);\n\t\treturn -EUCLEAN;\n\t}\n\n\t \n\tif (!has_single_bit_set(mode & S_IFMT)) {\n\t\tif (unlikely(!S_ISLNK(mode) && !S_ISBLK(mode) && !S_ISSOCK(mode))) {\n\t\t\tinode_item_err(leaf, slot,\n\t\t\t\"invalid mode: has 0%o expect valid S_IF* bit(s)\",\n\t\t\t\t       mode & S_IFMT);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t}\n\tif (unlikely(S_ISDIR(mode) && btrfs_inode_nlink(leaf, iitem) > 1)) {\n\t\tinode_item_err(leaf, slot,\n\t\t       \"invalid nlink: has %u expect no more than 1 for dir\",\n\t\t\tbtrfs_inode_nlink(leaf, iitem));\n\t\treturn -EUCLEAN;\n\t}\n\tbtrfs_inode_split_flags(btrfs_inode_flags(leaf, iitem), &flags, &ro_flags);\n\tif (unlikely(flags & ~BTRFS_INODE_FLAG_MASK)) {\n\t\tinode_item_err(leaf, slot,\n\t\t\t       \"unknown incompat flags detected: 0x%x\", flags);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(!sb_rdonly(fs_info->sb) &&\n\t\t     (ro_flags & ~BTRFS_INODE_RO_FLAG_MASK))) {\n\t\tinode_item_err(leaf, slot,\n\t\t\t\"unknown ro-compat flags detected on writeable mount: 0x%x\",\n\t\t\tro_flags);\n\t\treturn -EUCLEAN;\n\t}\n\treturn 0;\n}\n\nstatic int check_root_item(struct extent_buffer *leaf, struct btrfs_key *key,\n\t\t\t   int slot)\n{\n\tstruct btrfs_fs_info *fs_info = leaf->fs_info;\n\tstruct btrfs_root_item ri = { 0 };\n\tconst u64 valid_root_flags = BTRFS_ROOT_SUBVOL_RDONLY |\n\t\t\t\t     BTRFS_ROOT_SUBVOL_DEAD;\n\tint ret;\n\n\tret = check_root_key(leaf, key, slot);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tif (unlikely(btrfs_item_size(leaf, slot) != sizeof(ri) &&\n\t\t     btrfs_item_size(leaf, slot) !=\n\t\t     btrfs_legacy_root_item_size())) {\n\t\tgeneric_err(leaf, slot,\n\t\t\t    \"invalid root item size, have %u expect %zu or %u\",\n\t\t\t    btrfs_item_size(leaf, slot), sizeof(ri),\n\t\t\t    btrfs_legacy_root_item_size());\n\t\treturn -EUCLEAN;\n\t}\n\n\t \n\tread_extent_buffer(leaf, &ri, btrfs_item_ptr_offset(leaf, slot),\n\t\t\t   btrfs_item_size(leaf, slot));\n\n\t \n\tif (unlikely(btrfs_root_generation(&ri) >\n\t\t     btrfs_super_generation(fs_info->super_copy) + 1)) {\n\t\tgeneric_err(leaf, slot,\n\t\t\t\"invalid root generation, have %llu expect (0, %llu]\",\n\t\t\t    btrfs_root_generation(&ri),\n\t\t\t    btrfs_super_generation(fs_info->super_copy) + 1);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(btrfs_root_generation_v2(&ri) >\n\t\t     btrfs_super_generation(fs_info->super_copy) + 1)) {\n\t\tgeneric_err(leaf, slot,\n\t\t\"invalid root v2 generation, have %llu expect (0, %llu]\",\n\t\t\t    btrfs_root_generation_v2(&ri),\n\t\t\t    btrfs_super_generation(fs_info->super_copy) + 1);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(btrfs_root_last_snapshot(&ri) >\n\t\t     btrfs_super_generation(fs_info->super_copy) + 1)) {\n\t\tgeneric_err(leaf, slot,\n\t\t\"invalid root last_snapshot, have %llu expect (0, %llu]\",\n\t\t\t    btrfs_root_last_snapshot(&ri),\n\t\t\t    btrfs_super_generation(fs_info->super_copy) + 1);\n\t\treturn -EUCLEAN;\n\t}\n\n\t \n\tif (unlikely(!IS_ALIGNED(btrfs_root_bytenr(&ri), fs_info->sectorsize))) {\n\t\tgeneric_err(leaf, slot,\n\t\t\"invalid root bytenr, have %llu expect to be aligned to %u\",\n\t\t\t    btrfs_root_bytenr(&ri), fs_info->sectorsize);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(btrfs_root_level(&ri) >= BTRFS_MAX_LEVEL)) {\n\t\tgeneric_err(leaf, slot,\n\t\t\t    \"invalid root level, have %u expect [0, %u]\",\n\t\t\t    btrfs_root_level(&ri), BTRFS_MAX_LEVEL - 1);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(btrfs_root_drop_level(&ri) >= BTRFS_MAX_LEVEL)) {\n\t\tgeneric_err(leaf, slot,\n\t\t\t    \"invalid root level, have %u expect [0, %u]\",\n\t\t\t    btrfs_root_drop_level(&ri), BTRFS_MAX_LEVEL - 1);\n\t\treturn -EUCLEAN;\n\t}\n\n\t \n\tif (unlikely(btrfs_root_flags(&ri) & ~valid_root_flags)) {\n\t\tgeneric_err(leaf, slot,\n\t\t\t    \"invalid root flags, have 0x%llx expect mask 0x%llx\",\n\t\t\t    btrfs_root_flags(&ri), valid_root_flags);\n\t\treturn -EUCLEAN;\n\t}\n\treturn 0;\n}\n\n__printf(3,4)\n__cold\nstatic void extent_err(const struct extent_buffer *eb, int slot,\n\t\t       const char *fmt, ...)\n{\n\tstruct btrfs_key key;\n\tstruct va_format vaf;\n\tva_list args;\n\tu64 bytenr;\n\tu64 len;\n\n\tbtrfs_item_key_to_cpu(eb, &key, slot);\n\tbytenr = key.objectid;\n\tif (key.type == BTRFS_METADATA_ITEM_KEY ||\n\t    key.type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t    key.type == BTRFS_SHARED_BLOCK_REF_KEY)\n\t\tlen = eb->fs_info->nodesize;\n\telse\n\t\tlen = key.offset;\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tbtrfs_crit(eb->fs_info,\n\t\"corrupt %s: block=%llu slot=%d extent bytenr=%llu len=%llu %pV\",\n\t\tbtrfs_header_level(eb) == 0 ? \"leaf\" : \"node\",\n\t\teb->start, slot, bytenr, len, &vaf);\n\tva_end(args);\n}\n\nstatic int check_extent_item(struct extent_buffer *leaf,\n\t\t\t     struct btrfs_key *key, int slot,\n\t\t\t     struct btrfs_key *prev_key)\n{\n\tstruct btrfs_fs_info *fs_info = leaf->fs_info;\n\tstruct btrfs_extent_item *ei;\n\tbool is_tree_block = false;\n\tunsigned long ptr;\t \n\tunsigned long end;\t \n\tconst u32 item_size = btrfs_item_size(leaf, slot);\n\tu64 flags;\n\tu64 generation;\n\tu64 total_refs;\t\t \n\tu64 inline_refs = 0;\t \n\n\tif (unlikely(key->type == BTRFS_METADATA_ITEM_KEY &&\n\t\t     !btrfs_fs_incompat(fs_info, SKINNY_METADATA))) {\n\t\tgeneric_err(leaf, slot,\n\"invalid key type, METADATA_ITEM type invalid when SKINNY_METADATA feature disabled\");\n\t\treturn -EUCLEAN;\n\t}\n\t \n\tif (unlikely(!IS_ALIGNED(key->objectid, fs_info->sectorsize))) {\n\t\tgeneric_err(leaf, slot,\n\t\t\"invalid key objectid, have %llu expect to be aligned to %u\",\n\t\t\t   key->objectid, fs_info->sectorsize);\n\t\treturn -EUCLEAN;\n\t}\n\n\t \n\tif (unlikely(key->type == BTRFS_METADATA_ITEM_KEY &&\n\t\t     key->offset >= BTRFS_MAX_LEVEL)) {\n\t\textent_err(leaf, slot,\n\t\t\t   \"invalid tree level, have %llu expect [0, %u]\",\n\t\t\t   key->offset, BTRFS_MAX_LEVEL - 1);\n\t\treturn -EUCLEAN;\n\t}\n\n\t \n\tif (unlikely(item_size < sizeof(*ei))) {\n\t\textent_err(leaf, slot,\n\t\t\t   \"invalid item size, have %u expect [%zu, %u)\",\n\t\t\t   item_size, sizeof(*ei),\n\t\t\t   BTRFS_LEAF_DATA_SIZE(fs_info));\n\t\treturn -EUCLEAN;\n\t}\n\tend = item_size + btrfs_item_ptr_offset(leaf, slot);\n\n\t \n\tei = btrfs_item_ptr(leaf, slot, struct btrfs_extent_item);\n\tflags = btrfs_extent_flags(leaf, ei);\n\ttotal_refs = btrfs_extent_refs(leaf, ei);\n\tgeneration = btrfs_extent_generation(leaf, ei);\n\tif (unlikely(generation >\n\t\t     btrfs_super_generation(fs_info->super_copy) + 1)) {\n\t\textent_err(leaf, slot,\n\t\t\t   \"invalid generation, have %llu expect (0, %llu]\",\n\t\t\t   generation,\n\t\t\t   btrfs_super_generation(fs_info->super_copy) + 1);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(!has_single_bit_set(flags & (BTRFS_EXTENT_FLAG_DATA |\n\t\t\t\t\t\t  BTRFS_EXTENT_FLAG_TREE_BLOCK)))) {\n\t\textent_err(leaf, slot,\n\t\t\"invalid extent flag, have 0x%llx expect 1 bit set in 0x%llx\",\n\t\t\tflags, BTRFS_EXTENT_FLAG_DATA |\n\t\t\tBTRFS_EXTENT_FLAG_TREE_BLOCK);\n\t\treturn -EUCLEAN;\n\t}\n\tis_tree_block = !!(flags & BTRFS_EXTENT_FLAG_TREE_BLOCK);\n\tif (is_tree_block) {\n\t\tif (unlikely(key->type == BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t     key->offset != fs_info->nodesize)) {\n\t\t\textent_err(leaf, slot,\n\t\t\t\t   \"invalid extent length, have %llu expect %u\",\n\t\t\t\t   key->offset, fs_info->nodesize);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t} else {\n\t\tif (unlikely(key->type != BTRFS_EXTENT_ITEM_KEY)) {\n\t\t\textent_err(leaf, slot,\n\t\t\t\"invalid key type, have %u expect %u for data backref\",\n\t\t\t\t   key->type, BTRFS_EXTENT_ITEM_KEY);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t\tif (unlikely(!IS_ALIGNED(key->offset, fs_info->sectorsize))) {\n\t\t\textent_err(leaf, slot,\n\t\t\t\"invalid extent length, have %llu expect aligned to %u\",\n\t\t\t\t   key->offset, fs_info->sectorsize);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t\tif (unlikely(flags & BTRFS_BLOCK_FLAG_FULL_BACKREF)) {\n\t\t\textent_err(leaf, slot,\n\t\t\t\"invalid extent flag, data has full backref set\");\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t}\n\tptr = (unsigned long)(struct btrfs_extent_item *)(ei + 1);\n\n\t \n\tif (is_tree_block && key->type != BTRFS_METADATA_ITEM_KEY) {\n\t\tstruct btrfs_tree_block_info *info;\n\n\t\tinfo = (struct btrfs_tree_block_info *)ptr;\n\t\tif (unlikely(btrfs_tree_block_level(leaf, info) >= BTRFS_MAX_LEVEL)) {\n\t\t\textent_err(leaf, slot,\n\t\t\t\"invalid tree block info level, have %u expect [0, %u]\",\n\t\t\t\t   btrfs_tree_block_level(leaf, info),\n\t\t\t\t   BTRFS_MAX_LEVEL - 1);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t\tptr = (unsigned long)(struct btrfs_tree_block_info *)(info + 1);\n\t}\n\n\t \n\twhile (ptr < end) {\n\t\tstruct btrfs_extent_inline_ref *iref;\n\t\tstruct btrfs_extent_data_ref *dref;\n\t\tstruct btrfs_shared_data_ref *sref;\n\t\tu64 dref_offset;\n\t\tu64 inline_offset;\n\t\tu8 inline_type;\n\n\t\tif (unlikely(ptr + sizeof(*iref) > end)) {\n\t\t\textent_err(leaf, slot,\n\"inline ref item overflows extent item, ptr %lu iref size %zu end %lu\",\n\t\t\t\t   ptr, sizeof(*iref), end);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t\tiref = (struct btrfs_extent_inline_ref *)ptr;\n\t\tinline_type = btrfs_extent_inline_ref_type(leaf, iref);\n\t\tinline_offset = btrfs_extent_inline_ref_offset(leaf, iref);\n\t\tif (unlikely(ptr + btrfs_extent_inline_ref_size(inline_type) > end)) {\n\t\t\textent_err(leaf, slot,\n\"inline ref item overflows extent item, ptr %lu iref size %u end %lu\",\n\t\t\t\t   ptr, inline_type, end);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\tswitch (inline_type) {\n\t\t \n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\t\tinline_refs++;\n\t\t\tbreak;\n\t\t \n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tif (unlikely(!IS_ALIGNED(inline_offset,\n\t\t\t\t\t\t fs_info->sectorsize))) {\n\t\t\t\textent_err(leaf, slot,\n\t\t\"invalid tree parent bytenr, have %llu expect aligned to %u\",\n\t\t\t\t\t   inline_offset, fs_info->sectorsize);\n\t\t\t\treturn -EUCLEAN;\n\t\t\t}\n\t\t\tinline_refs++;\n\t\t\tbreak;\n\t\t \n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\t\tdref = (struct btrfs_extent_data_ref *)(&iref->offset);\n\t\t\tdref_offset = btrfs_extent_data_ref_offset(leaf, dref);\n\t\t\tif (unlikely(!IS_ALIGNED(dref_offset,\n\t\t\t\t\t\t fs_info->sectorsize))) {\n\t\t\t\textent_err(leaf, slot,\n\t\t\"invalid data ref offset, have %llu expect aligned to %u\",\n\t\t\t\t\t   dref_offset, fs_info->sectorsize);\n\t\t\t\treturn -EUCLEAN;\n\t\t\t}\n\t\t\tinline_refs += btrfs_extent_data_ref_count(leaf, dref);\n\t\t\tbreak;\n\t\t \n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tsref = (struct btrfs_shared_data_ref *)(iref + 1);\n\t\t\tif (unlikely(!IS_ALIGNED(inline_offset,\n\t\t\t\t\t\t fs_info->sectorsize))) {\n\t\t\t\textent_err(leaf, slot,\n\t\t\"invalid data parent bytenr, have %llu expect aligned to %u\",\n\t\t\t\t\t   inline_offset, fs_info->sectorsize);\n\t\t\t\treturn -EUCLEAN;\n\t\t\t}\n\t\t\tinline_refs += btrfs_shared_data_ref_count(leaf, sref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\textent_err(leaf, slot, \"unknown inline ref type: %u\",\n\t\t\t\t   inline_type);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t\tptr += btrfs_extent_inline_ref_size(inline_type);\n\t}\n\t \n\tif (unlikely(ptr != end)) {\n\t\textent_err(leaf, slot,\n\t\t\t   \"invalid extent item size, padding bytes found\");\n\t\treturn -EUCLEAN;\n\t}\n\n\t \n\tif (unlikely(inline_refs > total_refs)) {\n\t\textent_err(leaf, slot,\n\t\t\t\"invalid extent refs, have %llu expect >= inline %llu\",\n\t\t\t   total_refs, inline_refs);\n\t\treturn -EUCLEAN;\n\t}\n\n\tif ((prev_key->type == BTRFS_EXTENT_ITEM_KEY) ||\n\t    (prev_key->type == BTRFS_METADATA_ITEM_KEY)) {\n\t\tu64 prev_end = prev_key->objectid;\n\n\t\tif (prev_key->type == BTRFS_METADATA_ITEM_KEY)\n\t\t\tprev_end += fs_info->nodesize;\n\t\telse\n\t\t\tprev_end += prev_key->offset;\n\n\t\tif (unlikely(prev_end > key->objectid)) {\n\t\t\textent_err(leaf, slot,\n\t\"previous extent [%llu %u %llu] overlaps current extent [%llu %u %llu]\",\n\t\t\t\t   prev_key->objectid, prev_key->type,\n\t\t\t\t   prev_key->offset, key->objectid, key->type,\n\t\t\t\t   key->offset);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int check_simple_keyed_refs(struct extent_buffer *leaf,\n\t\t\t\t   struct btrfs_key *key, int slot)\n{\n\tu32 expect_item_size = 0;\n\n\tif (key->type == BTRFS_SHARED_DATA_REF_KEY)\n\t\texpect_item_size = sizeof(struct btrfs_shared_data_ref);\n\n\tif (unlikely(btrfs_item_size(leaf, slot) != expect_item_size)) {\n\t\tgeneric_err(leaf, slot,\n\t\t\"invalid item size, have %u expect %u for key type %u\",\n\t\t\t    btrfs_item_size(leaf, slot),\n\t\t\t    expect_item_size, key->type);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(!IS_ALIGNED(key->objectid, leaf->fs_info->sectorsize))) {\n\t\tgeneric_err(leaf, slot,\n\"invalid key objectid for shared block ref, have %llu expect aligned to %u\",\n\t\t\t    key->objectid, leaf->fs_info->sectorsize);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(key->type != BTRFS_TREE_BLOCK_REF_KEY &&\n\t\t     !IS_ALIGNED(key->offset, leaf->fs_info->sectorsize))) {\n\t\textent_err(leaf, slot,\n\t\t\"invalid tree parent bytenr, have %llu expect aligned to %u\",\n\t\t\t   key->offset, leaf->fs_info->sectorsize);\n\t\treturn -EUCLEAN;\n\t}\n\treturn 0;\n}\n\nstatic int check_extent_data_ref(struct extent_buffer *leaf,\n\t\t\t\t struct btrfs_key *key, int slot)\n{\n\tstruct btrfs_extent_data_ref *dref;\n\tunsigned long ptr = btrfs_item_ptr_offset(leaf, slot);\n\tconst unsigned long end = ptr + btrfs_item_size(leaf, slot);\n\n\tif (unlikely(btrfs_item_size(leaf, slot) % sizeof(*dref) != 0)) {\n\t\tgeneric_err(leaf, slot,\n\t\"invalid item size, have %u expect aligned to %zu for key type %u\",\n\t\t\t    btrfs_item_size(leaf, slot),\n\t\t\t    sizeof(*dref), key->type);\n\t\treturn -EUCLEAN;\n\t}\n\tif (unlikely(!IS_ALIGNED(key->objectid, leaf->fs_info->sectorsize))) {\n\t\tgeneric_err(leaf, slot,\n\"invalid key objectid for shared block ref, have %llu expect aligned to %u\",\n\t\t\t    key->objectid, leaf->fs_info->sectorsize);\n\t\treturn -EUCLEAN;\n\t}\n\tfor (; ptr < end; ptr += sizeof(*dref)) {\n\t\tu64 offset;\n\n\t\t \n\t\tdref = (struct btrfs_extent_data_ref *)ptr;\n\t\toffset = btrfs_extent_data_ref_offset(leaf, dref);\n\t\tif (unlikely(!IS_ALIGNED(offset, leaf->fs_info->sectorsize))) {\n\t\t\textent_err(leaf, slot,\n\t\"invalid extent data backref offset, have %llu expect aligned to %u\",\n\t\t\t\t   offset, leaf->fs_info->sectorsize);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#define inode_ref_err(eb, slot, fmt, args...)\t\t\t\\\n\tinode_item_err(eb, slot, fmt, ##args)\nstatic int check_inode_ref(struct extent_buffer *leaf,\n\t\t\t   struct btrfs_key *key, struct btrfs_key *prev_key,\n\t\t\t   int slot)\n{\n\tstruct btrfs_inode_ref *iref;\n\tunsigned long ptr;\n\tunsigned long end;\n\n\tif (unlikely(!check_prev_ino(leaf, key, slot, prev_key)))\n\t\treturn -EUCLEAN;\n\t \n\tif (unlikely(btrfs_item_size(leaf, slot) <= sizeof(*iref))) {\n\t\tinode_ref_err(leaf, slot,\n\t\t\t\"invalid item size, have %u expect (%zu, %u)\",\n\t\t\tbtrfs_item_size(leaf, slot),\n\t\t\tsizeof(*iref), BTRFS_LEAF_DATA_SIZE(leaf->fs_info));\n\t\treturn -EUCLEAN;\n\t}\n\n\tptr = btrfs_item_ptr_offset(leaf, slot);\n\tend = ptr + btrfs_item_size(leaf, slot);\n\twhile (ptr < end) {\n\t\tu16 namelen;\n\n\t\tif (unlikely(ptr + sizeof(iref) > end)) {\n\t\t\tinode_ref_err(leaf, slot,\n\t\t\t\"inode ref overflow, ptr %lu end %lu inode_ref_size %zu\",\n\t\t\t\tptr, end, sizeof(iref));\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\tiref = (struct btrfs_inode_ref *)ptr;\n\t\tnamelen = btrfs_inode_ref_name_len(leaf, iref);\n\t\tif (unlikely(ptr + sizeof(*iref) + namelen > end)) {\n\t\t\tinode_ref_err(leaf, slot,\n\t\t\t\t\"inode ref overflow, ptr %lu end %lu namelen %u\",\n\t\t\t\tptr, end, namelen);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\t \n\t\tptr += sizeof(*iref) + namelen;\n\t}\n\treturn 0;\n}\n\n \nstatic enum btrfs_tree_block_status check_leaf_item(struct extent_buffer *leaf,\n\t\t\t\t\t\t    struct btrfs_key *key,\n\t\t\t\t\t\t    int slot,\n\t\t\t\t\t\t    struct btrfs_key *prev_key)\n{\n\tint ret = 0;\n\tstruct btrfs_chunk *chunk;\n\n\tswitch (key->type) {\n\tcase BTRFS_EXTENT_DATA_KEY:\n\t\tret = check_extent_data_item(leaf, key, slot, prev_key);\n\t\tbreak;\n\tcase BTRFS_EXTENT_CSUM_KEY:\n\t\tret = check_csum_item(leaf, key, slot, prev_key);\n\t\tbreak;\n\tcase BTRFS_DIR_ITEM_KEY:\n\tcase BTRFS_DIR_INDEX_KEY:\n\tcase BTRFS_XATTR_ITEM_KEY:\n\t\tret = check_dir_item(leaf, key, prev_key, slot);\n\t\tbreak;\n\tcase BTRFS_INODE_REF_KEY:\n\t\tret = check_inode_ref(leaf, key, prev_key, slot);\n\t\tbreak;\n\tcase BTRFS_BLOCK_GROUP_ITEM_KEY:\n\t\tret = check_block_group_item(leaf, key, slot);\n\t\tbreak;\n\tcase BTRFS_CHUNK_ITEM_KEY:\n\t\tchunk = btrfs_item_ptr(leaf, slot, struct btrfs_chunk);\n\t\tret = check_leaf_chunk_item(leaf, chunk, key, slot);\n\t\tbreak;\n\tcase BTRFS_DEV_ITEM_KEY:\n\t\tret = check_dev_item(leaf, key, slot);\n\t\tbreak;\n\tcase BTRFS_INODE_ITEM_KEY:\n\t\tret = check_inode_item(leaf, key, slot);\n\t\tbreak;\n\tcase BTRFS_ROOT_ITEM_KEY:\n\t\tret = check_root_item(leaf, key, slot);\n\t\tbreak;\n\tcase BTRFS_EXTENT_ITEM_KEY:\n\tcase BTRFS_METADATA_ITEM_KEY:\n\t\tret = check_extent_item(leaf, key, slot, prev_key);\n\t\tbreak;\n\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\tcase BTRFS_SHARED_DATA_REF_KEY:\n\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\tret = check_simple_keyed_refs(leaf, key, slot);\n\t\tbreak;\n\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\tret = check_extent_data_ref(leaf, key, slot);\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\treturn BTRFS_TREE_BLOCK_INVALID_ITEM;\n\treturn BTRFS_TREE_BLOCK_CLEAN;\n}\n\nenum btrfs_tree_block_status __btrfs_check_leaf(struct extent_buffer *leaf)\n{\n\tstruct btrfs_fs_info *fs_info = leaf->fs_info;\n\t \n\tstruct btrfs_key prev_key = {0, 0, 0};\n\tstruct btrfs_key key;\n\tu32 nritems = btrfs_header_nritems(leaf);\n\tint slot;\n\n\tif (unlikely(btrfs_header_level(leaf) != 0)) {\n\t\tgeneric_err(leaf, 0,\n\t\t\t\"invalid level for leaf, have %d expect 0\",\n\t\t\tbtrfs_header_level(leaf));\n\t\treturn BTRFS_TREE_BLOCK_INVALID_LEVEL;\n\t}\n\n\t \n\tif (nritems == 0 && !btrfs_header_flag(leaf, BTRFS_HEADER_FLAG_RELOC)) {\n\t\tu64 owner = btrfs_header_owner(leaf);\n\n\t\t \n\t\tif (unlikely(owner == BTRFS_ROOT_TREE_OBJECTID ||\n\t\t\t     owner == BTRFS_CHUNK_TREE_OBJECTID ||\n\t\t\t     owner == BTRFS_DEV_TREE_OBJECTID ||\n\t\t\t     owner == BTRFS_FS_TREE_OBJECTID ||\n\t\t\t     owner == BTRFS_DATA_RELOC_TREE_OBJECTID)) {\n\t\t\tgeneric_err(leaf, 0,\n\t\t\t\"invalid root, root %llu must never be empty\",\n\t\t\t\t    owner);\n\t\t\treturn BTRFS_TREE_BLOCK_INVALID_NRITEMS;\n\t\t}\n\n\t\t \n\t\tif (unlikely(owner == 0)) {\n\t\t\tgeneric_err(leaf, 0,\n\t\t\t\t\"invalid owner, root 0 is not defined\");\n\t\t\treturn BTRFS_TREE_BLOCK_INVALID_OWNER;\n\t\t}\n\n\t\t \n\t\tif (btrfs_fs_incompat(fs_info, EXTENT_TREE_V2))\n\t\t\treturn BTRFS_TREE_BLOCK_CLEAN;\n\n\t\tif (unlikely(owner == BTRFS_EXTENT_TREE_OBJECTID)) {\n\t\t\tgeneric_err(leaf, 0,\n\t\t\t\"invalid root, root %llu must never be empty\",\n\t\t\t\t    owner);\n\t\t\treturn BTRFS_TREE_BLOCK_INVALID_NRITEMS;\n\t\t}\n\n\t\treturn BTRFS_TREE_BLOCK_CLEAN;\n\t}\n\n\tif (unlikely(nritems == 0))\n\t\treturn BTRFS_TREE_BLOCK_CLEAN;\n\n\t \n\tfor (slot = 0; slot < nritems; slot++) {\n\t\tu32 item_end_expected;\n\t\tu64 item_data_end;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\n\t\t \n\t\tif (unlikely(btrfs_comp_cpu_keys(&prev_key, &key) >= 0)) {\n\t\t\tgeneric_err(leaf, slot,\n\t\"bad key order, prev (%llu %u %llu) current (%llu %u %llu)\",\n\t\t\t\tprev_key.objectid, prev_key.type,\n\t\t\t\tprev_key.offset, key.objectid, key.type,\n\t\t\t\tkey.offset);\n\t\t\treturn BTRFS_TREE_BLOCK_BAD_KEY_ORDER;\n\t\t}\n\n\t\titem_data_end = (u64)btrfs_item_offset(leaf, slot) +\n\t\t\t\tbtrfs_item_size(leaf, slot);\n\t\t \n\t\tif (slot == 0)\n\t\t\titem_end_expected = BTRFS_LEAF_DATA_SIZE(fs_info);\n\t\telse\n\t\t\titem_end_expected = btrfs_item_offset(leaf,\n\t\t\t\t\t\t\t\t slot - 1);\n\t\tif (unlikely(item_data_end != item_end_expected)) {\n\t\t\tgeneric_err(leaf, slot,\n\t\t\t\t\"unexpected item end, have %llu expect %u\",\n\t\t\t\titem_data_end, item_end_expected);\n\t\t\treturn BTRFS_TREE_BLOCK_INVALID_OFFSETS;\n\t\t}\n\n\t\t \n\t\tif (unlikely(item_data_end > BTRFS_LEAF_DATA_SIZE(fs_info))) {\n\t\t\tgeneric_err(leaf, slot,\n\t\t\t\"slot end outside of leaf, have %llu expect range [0, %u]\",\n\t\t\t\titem_data_end, BTRFS_LEAF_DATA_SIZE(fs_info));\n\t\t\treturn BTRFS_TREE_BLOCK_INVALID_OFFSETS;\n\t\t}\n\n\t\t \n\t\tif (unlikely(btrfs_item_ptr_offset(leaf, slot) <\n\t\t\t     btrfs_item_nr_offset(leaf, slot) + sizeof(struct btrfs_item))) {\n\t\t\tgeneric_err(leaf, slot,\n\t\t\"slot overlaps with its data, item end %lu data start %lu\",\n\t\t\t\tbtrfs_item_nr_offset(leaf, slot) +\n\t\t\t\tsizeof(struct btrfs_item),\n\t\t\t\tbtrfs_item_ptr_offset(leaf, slot));\n\t\t\treturn BTRFS_TREE_BLOCK_INVALID_OFFSETS;\n\t\t}\n\n\t\t \n\t\tif (btrfs_header_flag(leaf, BTRFS_HEADER_FLAG_WRITTEN)) {\n\t\t\tenum btrfs_tree_block_status ret;\n\n\t\t\t \n\t\t\tret = check_leaf_item(leaf, &key, slot, &prev_key);\n\t\t\tif (unlikely(ret != BTRFS_TREE_BLOCK_CLEAN))\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tprev_key.objectid = key.objectid;\n\t\tprev_key.type = key.type;\n\t\tprev_key.offset = key.offset;\n\t}\n\n\treturn BTRFS_TREE_BLOCK_CLEAN;\n}\n\nint btrfs_check_leaf(struct extent_buffer *leaf)\n{\n\tenum btrfs_tree_block_status ret;\n\n\tret = __btrfs_check_leaf(leaf);\n\tif (unlikely(ret != BTRFS_TREE_BLOCK_CLEAN))\n\t\treturn -EUCLEAN;\n\treturn 0;\n}\nALLOW_ERROR_INJECTION(btrfs_check_leaf, ERRNO);\n\nenum btrfs_tree_block_status __btrfs_check_node(struct extent_buffer *node)\n{\n\tstruct btrfs_fs_info *fs_info = node->fs_info;\n\tunsigned long nr = btrfs_header_nritems(node);\n\tstruct btrfs_key key, next_key;\n\tint slot;\n\tint level = btrfs_header_level(node);\n\tu64 bytenr;\n\n\tif (unlikely(level <= 0 || level >= BTRFS_MAX_LEVEL)) {\n\t\tgeneric_err(node, 0,\n\t\t\t\"invalid level for node, have %d expect [1, %d]\",\n\t\t\tlevel, BTRFS_MAX_LEVEL - 1);\n\t\treturn BTRFS_TREE_BLOCK_INVALID_LEVEL;\n\t}\n\tif (unlikely(nr == 0 || nr > BTRFS_NODEPTRS_PER_BLOCK(fs_info))) {\n\t\tbtrfs_crit(fs_info,\n\"corrupt node: root=%llu block=%llu, nritems too %s, have %lu expect range [1,%u]\",\n\t\t\t   btrfs_header_owner(node), node->start,\n\t\t\t   nr == 0 ? \"small\" : \"large\", nr,\n\t\t\t   BTRFS_NODEPTRS_PER_BLOCK(fs_info));\n\t\treturn BTRFS_TREE_BLOCK_INVALID_NRITEMS;\n\t}\n\n\tfor (slot = 0; slot < nr - 1; slot++) {\n\t\tbytenr = btrfs_node_blockptr(node, slot);\n\t\tbtrfs_node_key_to_cpu(node, &key, slot);\n\t\tbtrfs_node_key_to_cpu(node, &next_key, slot + 1);\n\n\t\tif (unlikely(!bytenr)) {\n\t\t\tgeneric_err(node, slot,\n\t\t\t\t\"invalid NULL node pointer\");\n\t\t\treturn BTRFS_TREE_BLOCK_INVALID_BLOCKPTR;\n\t\t}\n\t\tif (unlikely(!IS_ALIGNED(bytenr, fs_info->sectorsize))) {\n\t\t\tgeneric_err(node, slot,\n\t\t\t\"unaligned pointer, have %llu should be aligned to %u\",\n\t\t\t\tbytenr, fs_info->sectorsize);\n\t\t\treturn BTRFS_TREE_BLOCK_INVALID_BLOCKPTR;\n\t\t}\n\n\t\tif (unlikely(btrfs_comp_cpu_keys(&key, &next_key) >= 0)) {\n\t\t\tgeneric_err(node, slot,\n\t\"bad key order, current (%llu %u %llu) next (%llu %u %llu)\",\n\t\t\t\tkey.objectid, key.type, key.offset,\n\t\t\t\tnext_key.objectid, next_key.type,\n\t\t\t\tnext_key.offset);\n\t\t\treturn BTRFS_TREE_BLOCK_BAD_KEY_ORDER;\n\t\t}\n\t}\n\treturn BTRFS_TREE_BLOCK_CLEAN;\n}\n\nint btrfs_check_node(struct extent_buffer *node)\n{\n\tenum btrfs_tree_block_status ret;\n\n\tret = __btrfs_check_node(node);\n\tif (unlikely(ret != BTRFS_TREE_BLOCK_CLEAN))\n\t\treturn -EUCLEAN;\n\treturn 0;\n}\nALLOW_ERROR_INJECTION(btrfs_check_node, ERRNO);\n\nint btrfs_check_eb_owner(const struct extent_buffer *eb, u64 root_owner)\n{\n\tconst bool is_subvol = is_fstree(root_owner);\n\tconst u64 eb_owner = btrfs_header_owner(eb);\n\n\t \n\tif (test_bit(BTRFS_FS_STATE_DUMMY_FS_INFO, &eb->fs_info->fs_state))\n\t\treturn 0;\n\t \n\tif (root_owner == 0)\n\t\treturn 0;\n\t \n\tif (root_owner == BTRFS_TREE_LOG_OBJECTID ||\n\t    root_owner == BTRFS_TREE_RELOC_OBJECTID)\n\t\treturn 0;\n\n\tif (!is_subvol) {\n\t\t \n\t\tif (unlikely(root_owner != eb_owner)) {\n\t\t\tbtrfs_crit(eb->fs_info,\n\"corrupted %s, root=%llu block=%llu owner mismatch, have %llu expect %llu\",\n\t\t\t\tbtrfs_header_level(eb) == 0 ? \"leaf\" : \"node\",\n\t\t\t\troot_owner, btrfs_header_bytenr(eb), eb_owner,\n\t\t\t\troot_owner);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tif (unlikely(is_subvol != is_fstree(eb_owner))) {\n\t\tbtrfs_crit(eb->fs_info,\n\"corrupted %s, root=%llu block=%llu owner mismatch, have %llu expect [%llu, %llu]\",\n\t\t\tbtrfs_header_level(eb) == 0 ? \"leaf\" : \"node\",\n\t\t\troot_owner, btrfs_header_bytenr(eb), eb_owner,\n\t\t\tBTRFS_FIRST_FREE_OBJECTID, BTRFS_LAST_FREE_OBJECTID);\n\t\treturn -EUCLEAN;\n\t}\n\treturn 0;\n}\n\nint btrfs_verify_level_key(struct extent_buffer *eb, int level,\n\t\t\t   struct btrfs_key *first_key, u64 parent_transid)\n{\n\tstruct btrfs_fs_info *fs_info = eb->fs_info;\n\tint found_level;\n\tstruct btrfs_key found_key;\n\tint ret;\n\n\tfound_level = btrfs_header_level(eb);\n\tif (found_level != level) {\n\t\tWARN(IS_ENABLED(CONFIG_BTRFS_DEBUG),\n\t\t     KERN_ERR \"BTRFS: tree level check failed\\n\");\n\t\tbtrfs_err(fs_info,\n\"tree level mismatch detected, bytenr=%llu level expected=%u has=%u\",\n\t\t\t  eb->start, level, found_level);\n\t\treturn -EIO;\n\t}\n\n\tif (!first_key)\n\t\treturn 0;\n\n\t \n\tif (btrfs_header_generation(eb) > fs_info->last_trans_committed)\n\t\treturn 0;\n\n\t \n\tif (btrfs_header_nritems(eb) == 0) {\n\t\tbtrfs_err(fs_info,\n\t\t\"invalid tree nritems, bytenr=%llu nritems=0 expect >0\",\n\t\t\t  eb->start);\n\t\tWARN_ON(IS_ENABLED(CONFIG_BTRFS_DEBUG));\n\t\treturn -EUCLEAN;\n\t}\n\n\tif (found_level)\n\t\tbtrfs_node_key_to_cpu(eb, &found_key, 0);\n\telse\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, 0);\n\tret = btrfs_comp_cpu_keys(first_key, &found_key);\n\n\tif (ret) {\n\t\tWARN(IS_ENABLED(CONFIG_BTRFS_DEBUG),\n\t\t     KERN_ERR \"BTRFS: tree first key check failed\\n\");\n\t\tbtrfs_err(fs_info,\n\"tree first key mismatch detected, bytenr=%llu parent_transid=%llu key expected=(%llu,%u,%llu) has=(%llu,%u,%llu)\",\n\t\t\t  eb->start, parent_transid, first_key->objectid,\n\t\t\t  first_key->type, first_key->offset,\n\t\t\t  found_key.objectid, found_key.type,\n\t\t\t  found_key.offset);\n\t}\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}