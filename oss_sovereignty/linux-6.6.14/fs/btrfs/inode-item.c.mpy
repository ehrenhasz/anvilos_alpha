{
  "module_name": "inode-item.c",
  "hash_id": "0b66cb73975958aa57067cfb04721727fde1e4845e553a54fc0eeb08a38cf3b0",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/inode-item.c",
  "human_readable_source": "\n \n\n#include \"ctree.h\"\n#include \"fs.h\"\n#include \"messages.h\"\n#include \"inode-item.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"print-tree.h\"\n#include \"space-info.h\"\n#include \"accessors.h\"\n#include \"extent-tree.h\"\n#include \"file-item.h\"\n\nstruct btrfs_inode_ref *btrfs_find_name_in_backref(struct extent_buffer *leaf,\n\t\t\t\t\t\t   int slot,\n\t\t\t\t\t\t   const struct fscrypt_str *name)\n{\n\tstruct btrfs_inode_ref *ref;\n\tunsigned long ptr;\n\tunsigned long name_ptr;\n\tu32 item_size;\n\tu32 cur_offset = 0;\n\tint len;\n\n\titem_size = btrfs_item_size(leaf, slot);\n\tptr = btrfs_item_ptr_offset(leaf, slot);\n\twhile (cur_offset < item_size) {\n\t\tref = (struct btrfs_inode_ref *)(ptr + cur_offset);\n\t\tlen = btrfs_inode_ref_name_len(leaf, ref);\n\t\tname_ptr = (unsigned long)(ref + 1);\n\t\tcur_offset += len + sizeof(*ref);\n\t\tif (len != name->len)\n\t\t\tcontinue;\n\t\tif (memcmp_extent_buffer(leaf, name->name, name_ptr,\n\t\t\t\t\t name->len) == 0)\n\t\t\treturn ref;\n\t}\n\treturn NULL;\n}\n\nstruct btrfs_inode_extref *btrfs_find_name_in_ext_backref(\n\t\tstruct extent_buffer *leaf, int slot, u64 ref_objectid,\n\t\tconst struct fscrypt_str *name)\n{\n\tstruct btrfs_inode_extref *extref;\n\tunsigned long ptr;\n\tunsigned long name_ptr;\n\tu32 item_size;\n\tu32 cur_offset = 0;\n\tint ref_name_len;\n\n\titem_size = btrfs_item_size(leaf, slot);\n\tptr = btrfs_item_ptr_offset(leaf, slot);\n\n\t \n\twhile (cur_offset < item_size) {\n\t\textref = (struct btrfs_inode_extref *) (ptr + cur_offset);\n\t\tname_ptr = (unsigned long)(&extref->name);\n\t\tref_name_len = btrfs_inode_extref_name_len(leaf, extref);\n\n\t\tif (ref_name_len == name->len &&\n\t\t    btrfs_inode_extref_parent(leaf, extref) == ref_objectid &&\n\t\t    (memcmp_extent_buffer(leaf, name->name, name_ptr,\n\t\t\t\t\t  name->len) == 0))\n\t\t\treturn extref;\n\n\t\tcur_offset += ref_name_len + sizeof(*extref);\n\t}\n\treturn NULL;\n}\n\n \nstruct btrfs_inode_extref *\nbtrfs_lookup_inode_extref(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  const struct fscrypt_str *name,\n\t\t\t  u64 inode_objectid, u64 ref_objectid, int ins_len,\n\t\t\t  int cow)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\n\tkey.objectid = inode_objectid;\n\tkey.type = BTRFS_INODE_EXTREF_KEY;\n\tkey.offset = btrfs_extref_hash(ref_objectid, name->name, name->len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\treturn btrfs_find_name_in_ext_backref(path->nodes[0], path->slots[0],\n\t\t\t\t\t      ref_objectid, name);\n\n}\n\nstatic int btrfs_del_inode_extref(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t  const struct fscrypt_str *name,\n\t\t\t\t  u64 inode_objectid, u64 ref_objectid,\n\t\t\t\t  u64 *index)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\tint del_len = name->len + sizeof(*extref);\n\tunsigned long ptr;\n\tunsigned long item_start;\n\tu32 item_size;\n\n\tkey.objectid = inode_objectid;\n\tkey.type = BTRFS_INODE_EXTREF_KEY;\n\tkey.offset = btrfs_extref_hash(ref_objectid, name->name, name->len);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\textref = btrfs_find_name_in_ext_backref(path->nodes[0], path->slots[0],\n\t\t\t\t\t\tref_objectid, name);\n\tif (!extref) {\n\t\tbtrfs_handle_fs_error(root->fs_info, -ENOENT, NULL);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size(leaf, path->slots[0]);\n\tif (index)\n\t\t*index = btrfs_inode_extref_index(leaf, extref);\n\n\tif (del_len == item_size) {\n\t\t \n\t\tret = btrfs_del_item(trans, root, path);\n\t\tgoto out;\n\t}\n\n\tptr = (unsigned long)extref;\n\titem_start = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\n\tmemmove_extent_buffer(leaf, ptr, ptr + del_len,\n\t\t\t      item_size - (ptr + del_len - item_start));\n\n\tbtrfs_truncate_item(trans, path, item_size - del_len, 1);\n\nout:\n\tbtrfs_free_path(path);\n\n\treturn ret;\n}\n\nint btrfs_del_inode_ref(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *root, const struct fscrypt_str *name,\n\t\t\tu64 inode_objectid, u64 ref_objectid, u64 *index)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_inode_ref *ref;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\tunsigned long item_start;\n\tu32 item_size;\n\tu32 sub_item_len;\n\tint ret;\n\tint search_ext_refs = 0;\n\tint del_len = name->len + sizeof(*ref);\n\n\tkey.objectid = inode_objectid;\n\tkey.offset = ref_objectid;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tsearch_ext_refs = 1;\n\t\tgoto out;\n\t} else if (ret < 0) {\n\t\tgoto out;\n\t}\n\n\tref = btrfs_find_name_in_backref(path->nodes[0], path->slots[0], name);\n\tif (!ref) {\n\t\tret = -ENOENT;\n\t\tsearch_ext_refs = 1;\n\t\tgoto out;\n\t}\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size(leaf, path->slots[0]);\n\n\tif (index)\n\t\t*index = btrfs_inode_ref_index(leaf, ref);\n\n\tif (del_len == item_size) {\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tgoto out;\n\t}\n\tptr = (unsigned long)ref;\n\tsub_item_len = name->len + sizeof(*ref);\n\titem_start = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\tmemmove_extent_buffer(leaf, ptr, ptr + sub_item_len,\n\t\t\t      item_size - (ptr + sub_item_len - item_start));\n\tbtrfs_truncate_item(trans, path, item_size - sub_item_len, 1);\nout:\n\tbtrfs_free_path(path);\n\n\tif (search_ext_refs) {\n\t\t \n\t\treturn btrfs_del_inode_extref(trans, root, name,\n\t\t\t\t\t      inode_objectid, ref_objectid, index);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int btrfs_insert_inode_extref(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     const struct fscrypt_str *name,\n\t\t\t\t     u64 inode_objectid, u64 ref_objectid,\n\t\t\t\t     u64 index)\n{\n\tstruct btrfs_inode_extref *extref;\n\tint ret;\n\tint ins_len = name->len + sizeof(*extref);\n\tunsigned long ptr;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\n\tkey.objectid = inode_objectid;\n\tkey.type = BTRFS_INODE_EXTREF_KEY;\n\tkey.offset = btrfs_extref_hash(ref_objectid, name->name, name->len);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      ins_len);\n\tif (ret == -EEXIST) {\n\t\tif (btrfs_find_name_in_ext_backref(path->nodes[0],\n\t\t\t\t\t\t   path->slots[0],\n\t\t\t\t\t\t   ref_objectid,\n\t\t\t\t\t\t   name))\n\t\t\tgoto out;\n\n\t\tbtrfs_extend_item(trans, path, ins_len);\n\t\tret = 0;\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tptr = (unsigned long)btrfs_item_ptr(leaf, path->slots[0], char);\n\tptr += btrfs_item_size(leaf, path->slots[0]) - ins_len;\n\textref = (struct btrfs_inode_extref *)ptr;\n\n\tbtrfs_set_inode_extref_name_len(path->nodes[0], extref, name->len);\n\tbtrfs_set_inode_extref_index(path->nodes[0], extref, index);\n\tbtrfs_set_inode_extref_parent(path->nodes[0], extref, ref_objectid);\n\n\tptr = (unsigned long)&extref->name;\n\twrite_extent_buffer(path->nodes[0], name->name, ptr, name->len);\n\tbtrfs_mark_buffer_dirty(trans, path->nodes[0]);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nint btrfs_insert_inode_ref(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, const struct fscrypt_str *name,\n\t\t\t   u64 inode_objectid, u64 ref_objectid, u64 index)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_inode_ref *ref;\n\tunsigned long ptr;\n\tint ret;\n\tint ins_len = name->len + sizeof(*ref);\n\n\tkey.objectid = inode_objectid;\n\tkey.offset = ref_objectid;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->skip_release_on_error = 1;\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      ins_len);\n\tif (ret == -EEXIST) {\n\t\tu32 old_size;\n\t\tref = btrfs_find_name_in_backref(path->nodes[0], path->slots[0],\n\t\t\t\t\t\t name);\n\t\tif (ref)\n\t\t\tgoto out;\n\n\t\told_size = btrfs_item_size(path->nodes[0], path->slots[0]);\n\t\tbtrfs_extend_item(trans, path, ins_len);\n\t\tref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t     struct btrfs_inode_ref);\n\t\tref = (struct btrfs_inode_ref *)((unsigned long)ref + old_size);\n\t\tbtrfs_set_inode_ref_name_len(path->nodes[0], ref, name->len);\n\t\tbtrfs_set_inode_ref_index(path->nodes[0], ref, index);\n\t\tptr = (unsigned long)(ref + 1);\n\t\tret = 0;\n\t} else if (ret < 0) {\n\t\tif (ret == -EOVERFLOW) {\n\t\t\tif (btrfs_find_name_in_backref(path->nodes[0],\n\t\t\t\t\t\t       path->slots[0],\n\t\t\t\t\t\t       name))\n\t\t\t\tret = -EEXIST;\n\t\t\telse\n\t\t\t\tret = -EMLINK;\n\t\t}\n\t\tgoto out;\n\t} else {\n\t\tref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t     struct btrfs_inode_ref);\n\t\tbtrfs_set_inode_ref_name_len(path->nodes[0], ref, name->len);\n\t\tbtrfs_set_inode_ref_index(path->nodes[0], ref, index);\n\t\tptr = (unsigned long)(ref + 1);\n\t}\n\twrite_extent_buffer(path->nodes[0], name->name, ptr, name->len);\n\tbtrfs_mark_buffer_dirty(trans, path->nodes[0]);\n\nout:\n\tbtrfs_free_path(path);\n\n\tif (ret == -EMLINK) {\n\t\tstruct btrfs_super_block *disk_super = fs_info->super_copy;\n\t\t \n\t\tif (btrfs_super_incompat_flags(disk_super)\n\t\t    & BTRFS_FEATURE_INCOMPAT_EXTENDED_IREF)\n\t\t\tret = btrfs_insert_inode_extref(trans, root, name,\n\t\t\t\t\t\t\tinode_objectid,\n\t\t\t\t\t\t\tref_objectid, index);\n\t}\n\n\treturn ret;\n}\n\nint btrfs_insert_empty_inode(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid)\n{\n\tstruct btrfs_key key;\n\tint ret;\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(struct btrfs_inode_item));\n\treturn ret;\n}\n\nint btrfs_lookup_inode(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t       *root, struct btrfs_path *path,\n\t\t       struct btrfs_key *location, int mod)\n{\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key found_key;\n\n\tret = btrfs_search_slot(trans, root, location, path, ins_len, cow);\n\tif (ret > 0 && location->type == BTRFS_ROOT_ITEM_KEY &&\n\t    location->offset == (u64)-1 && path->slots[0] != 0) {\n\t\tslot = path->slots[0] - 1;\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\t\tif (found_key.objectid == location->objectid &&\n\t\t    found_key.type == location->type) {\n\t\t\tpath->slots[0]--;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic inline void btrfs_trace_truncate(struct btrfs_inode *inode,\n\t\t\t\t\tstruct extent_buffer *leaf,\n\t\t\t\t\tstruct btrfs_file_extent_item *fi,\n\t\t\t\t\tu64 offset, int extent_type, int slot)\n{\n\tif (!inode)\n\t\treturn;\n\tif (extent_type == BTRFS_FILE_EXTENT_INLINE)\n\t\ttrace_btrfs_truncate_show_fi_inline(inode, leaf, fi, slot,\n\t\t\t\t\t\t    offset);\n\telse\n\t\ttrace_btrfs_truncate_show_fi_regular(inode, leaf, fi, offset);\n}\n\n \nint btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_truncate_control *control)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tu64 new_size = control->new_size;\n\tu64 extent_num_bytes = 0;\n\tu64 extent_offset = 0;\n\tu64 item_end = 0;\n\tu32 found_type = (u8)-1;\n\tint del_item;\n\tint pending_del_nr = 0;\n\tint pending_del_slot = 0;\n\tint extent_type = -1;\n\tint ret;\n\tu64 bytes_deleted = 0;\n\tbool be_nice = false;\n\n\tASSERT(control->inode || !control->clear_extent_range);\n\tASSERT(new_size == 0 || control->min_type == BTRFS_EXTENT_DATA_KEY);\n\n\tcontrol->last_size = new_size;\n\tcontrol->sub_bytes = 0;\n\n\t \n\tif (test_bit(BTRFS_ROOT_SHAREABLE, &root->state))\n\t\tbe_nice = true;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = READA_BACK;\n\n\tkey.objectid = control->ino;\n\tkey.offset = (u64)-1;\n\tkey.type = (u8)-1;\n\nsearch_again:\n\t \n\tif (be_nice && bytes_deleted > SZ_32M &&\n\t    btrfs_should_end_transaction(trans)) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = 0;\n\t\t \n\t\tif (path->slots[0] == 0)\n\t\t\tgoto out;\n\t\tpath->slots[0]--;\n\t}\n\n\twhile (1) {\n\t\tu64 clear_start = 0, clear_len = 0, extent_start = 0;\n\t\tbool refill_delayed_refs_rsv = false;\n\n\t\tfi = NULL;\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tfound_type = found_key.type;\n\n\t\tif (found_key.objectid != control->ino)\n\t\t\tbreak;\n\n\t\tif (found_type < control->min_type)\n\t\t\tbreak;\n\n\t\titem_end = found_key.offset;\n\t\tif (found_type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\textent_type = btrfs_file_extent_type(leaf, fi);\n\t\t\tif (extent_type != BTRFS_FILE_EXTENT_INLINE)\n\t\t\t\titem_end +=\n\t\t\t\t    btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\telse if (extent_type == BTRFS_FILE_EXTENT_INLINE)\n\t\t\t\titem_end += btrfs_file_extent_ram_bytes(leaf, fi);\n\n\t\t\tbtrfs_trace_truncate(control->inode, leaf, fi,\n\t\t\t\t\t     found_key.offset, extent_type,\n\t\t\t\t\t     path->slots[0]);\n\t\t\titem_end--;\n\t\t}\n\t\tif (found_type > control->min_type) {\n\t\t\tdel_item = 1;\n\t\t} else {\n\t\t\tif (item_end < new_size)\n\t\t\t\tbreak;\n\t\t\tif (found_key.offset >= new_size)\n\t\t\t\tdel_item = 1;\n\t\t\telse\n\t\t\t\tdel_item = 0;\n\t\t}\n\n\t\t \n\t\tif (found_type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto delete;\n\n\t\tcontrol->extents_found++;\n\n\t\tif (extent_type != BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tu64 num_dec;\n\n\t\t\tclear_start = found_key.offset;\n\t\t\textent_start = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\t\tif (!del_item) {\n\t\t\t\tu64 orig_num_bytes =\n\t\t\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\textent_num_bytes = ALIGN(new_size -\n\t\t\t\t\t\tfound_key.offset,\n\t\t\t\t\t\tfs_info->sectorsize);\n\t\t\t\tclear_start = ALIGN(new_size, fs_info->sectorsize);\n\n\t\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\t extent_num_bytes);\n\t\t\t\tnum_dec = (orig_num_bytes - extent_num_bytes);\n\t\t\t\tif (extent_start != 0)\n\t\t\t\t\tcontrol->sub_bytes += num_dec;\n\t\t\t\tbtrfs_mark_buffer_dirty(trans, leaf);\n\t\t\t} else {\n\t\t\t\textent_num_bytes =\n\t\t\t\t\tbtrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\t\t\textent_offset = found_key.offset -\n\t\t\t\t\tbtrfs_file_extent_offset(leaf, fi);\n\n\t\t\t\t \n\t\t\t\tnum_dec = btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\tif (extent_start != 0)\n\t\t\t\t\tcontrol->sub_bytes += num_dec;\n\t\t\t}\n\t\t\tclear_len = num_dec;\n\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t \n\t\t\tif (!del_item &&\n\t\t\t    btrfs_file_extent_encryption(leaf, fi) == 0 &&\n\t\t\t    btrfs_file_extent_other_encoding(leaf, fi) == 0 &&\n\t\t\t    btrfs_file_extent_compression(leaf, fi) == 0) {\n\t\t\t\tu32 size = (u32)(new_size - found_key.offset);\n\n\t\t\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);\n\t\t\t\tsize = btrfs_file_extent_calc_inline_size(size);\n\t\t\t\tbtrfs_truncate_item(trans, path, size, 1);\n\t\t\t} else if (!del_item) {\n\t\t\t\t \n\t\t\t\tret = BTRFS_NEED_TRUNCATE_BLOCK;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tclear_len = fs_info->sectorsize;\n\t\t\t}\n\n\t\t\tcontrol->sub_bytes += item_end + 1 - new_size;\n\t\t}\ndelete:\n\t\t \n\t\tif (control->clear_extent_range) {\n\t\t\tret = btrfs_inode_clear_file_extent_range(control->inode,\n\t\t\t\t\t\t  clear_start, clear_len);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (del_item) {\n\t\t\tASSERT(!pending_del_nr ||\n\t\t\t       ((path->slots[0] + 1) == pending_del_slot));\n\n\t\t\tcontrol->last_size = found_key.offset;\n\t\t\tif (!pending_del_nr) {\n\t\t\t\t \n\t\t\t\tpending_del_slot = path->slots[0];\n\t\t\t\tpending_del_nr = 1;\n\t\t\t} else if (path->slots[0] + 1 == pending_del_slot) {\n\t\t\t\t \n\t\t\t\tpending_del_nr++;\n\t\t\t\tpending_del_slot = path->slots[0];\n\t\t\t}\n\t\t} else {\n\t\t\tcontrol->last_size = new_size;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (del_item && extent_start != 0 && !control->skip_ref_updates) {\n\t\t\tstruct btrfs_ref ref = { 0 };\n\n\t\t\tbytes_deleted += extent_num_bytes;\n\n\t\t\tbtrfs_init_generic_ref(&ref, BTRFS_DROP_DELAYED_REF,\n\t\t\t\t\textent_start, extent_num_bytes, 0);\n\t\t\tbtrfs_init_data_ref(&ref, btrfs_header_owner(leaf),\n\t\t\t\t\tcontrol->ino, extent_offset,\n\t\t\t\t\troot->root_key.objectid, false);\n\t\t\tret = btrfs_free_extent(trans, &ref);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (be_nice && btrfs_check_space_for_delayed_refs(fs_info))\n\t\t\t\trefill_delayed_refs_rsv = true;\n\t\t}\n\n\t\tif (found_type == BTRFS_INODE_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tif (path->slots[0] == 0 ||\n\t\t    path->slots[0] != pending_del_slot ||\n\t\t    refill_delayed_refs_rsv) {\n\t\t\tif (pending_del_nr) {\n\t\t\t\tret = btrfs_del_items(trans, root, path,\n\t\t\t\t\t\tpending_del_slot,\n\t\t\t\t\t\tpending_del_nr);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpending_del_nr = 0;\n\t\t\t}\n\t\t\tbtrfs_release_path(path);\n\n\t\t\t \n\t\t\tif (refill_delayed_refs_rsv) {\n\t\t\t\tret = btrfs_delayed_refs_rsv_refill(fs_info,\n\t\t\t\t\t\t\tBTRFS_RESERVE_NO_FLUSH);\n\t\t\t\tif (ret) {\n\t\t\t\t\tret = -EAGAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto search_again;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t}\nout:\n\tif (ret >= 0 && pending_del_nr) {\n\t\tint err;\n\n\t\terr = btrfs_del_items(trans, root, path, pending_del_slot,\n\t\t\t\t      pending_del_nr);\n\t\tif (err) {\n\t\t\tbtrfs_abort_transaction(trans, err);\n\t\t\tret = err;\n\t\t}\n\t}\n\n\tASSERT(control->last_size >= new_size);\n\tif (!ret && control->last_size > new_size)\n\t\tcontrol->last_size = new_size;\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}