{
  "module_name": "delalloc-space.c",
  "hash_id": "b093e97ade30d46b01e1fd2c33bc97660a1f9e2f96324a3b203427417b16af7c",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/delalloc-space.c",
  "human_readable_source": "\n\n#include \"messages.h\"\n#include \"ctree.h\"\n#include \"delalloc-space.h\"\n#include \"block-rsv.h\"\n#include \"btrfs_inode.h\"\n#include \"space-info.h\"\n#include \"transaction.h\"\n#include \"qgroup.h\"\n#include \"block-group.h\"\n#include \"fs.h\"\n\n \n\nint btrfs_alloc_data_chunk_ondemand(struct btrfs_inode *inode, u64 bytes)\n{\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tenum btrfs_reserve_flush_enum flush = BTRFS_RESERVE_FLUSH_DATA;\n\n\t \n\tbytes = ALIGN(bytes, fs_info->sectorsize);\n\n\tif (btrfs_is_free_space_inode(inode))\n\t\tflush = BTRFS_RESERVE_FLUSH_FREE_SPACE_INODE;\n\n\treturn btrfs_reserve_data_bytes(fs_info, bytes, flush);\n}\n\nint btrfs_check_data_free_space(struct btrfs_inode *inode,\n\t\t\t\tstruct extent_changeset **reserved, u64 start,\n\t\t\t\tu64 len, bool noflush)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tenum btrfs_reserve_flush_enum flush = BTRFS_RESERVE_FLUSH_DATA;\n\tint ret;\n\n\t \n\tlen = round_up(start + len, fs_info->sectorsize) -\n\t      round_down(start, fs_info->sectorsize);\n\tstart = round_down(start, fs_info->sectorsize);\n\n\tif (noflush)\n\t\tflush = BTRFS_RESERVE_NO_FLUSH;\n\telse if (btrfs_is_free_space_inode(inode))\n\t\tflush = BTRFS_RESERVE_FLUSH_FREE_SPACE_INODE;\n\n\tret = btrfs_reserve_data_bytes(fs_info, len, flush);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = btrfs_qgroup_reserve_data(inode, reserved, start, len);\n\tif (ret < 0) {\n\t\tbtrfs_free_reserved_data_space_noquota(fs_info, len);\n\t\textent_changeset_free(*reserved);\n\t\t*reserved = NULL;\n\t} else {\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\n \nvoid btrfs_free_reserved_data_space_noquota(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t    u64 len)\n{\n\tstruct btrfs_space_info *data_sinfo;\n\n\tASSERT(IS_ALIGNED(len, fs_info->sectorsize));\n\n\tdata_sinfo = fs_info->data_sinfo;\n\tbtrfs_space_info_free_bytes_may_use(fs_info, data_sinfo, len);\n}\n\n \nvoid btrfs_free_reserved_data_space(struct btrfs_inode *inode,\n\t\t\tstruct extent_changeset *reserved, u64 start, u64 len)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\n\t \n\tlen = round_up(start + len, fs_info->sectorsize) -\n\t      round_down(start, fs_info->sectorsize);\n\tstart = round_down(start, fs_info->sectorsize);\n\n\tbtrfs_free_reserved_data_space_noquota(fs_info, len);\n\tbtrfs_qgroup_free_data(inode, reserved, start, len, NULL);\n}\n\n \nstatic void btrfs_inode_rsv_release(struct btrfs_inode *inode, bool qgroup_free)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tstruct btrfs_block_rsv *block_rsv = &inode->block_rsv;\n\tu64 released = 0;\n\tu64 qgroup_to_release = 0;\n\n\t \n\treleased = btrfs_block_rsv_release(fs_info, block_rsv, 0,\n\t\t\t\t\t   &qgroup_to_release);\n\tif (released > 0)\n\t\ttrace_btrfs_space_reservation(fs_info, \"delalloc\",\n\t\t\t\t\t      btrfs_ino(inode), released, 0);\n\tif (qgroup_free)\n\t\tbtrfs_qgroup_free_meta_prealloc(inode->root, qgroup_to_release);\n\telse\n\t\tbtrfs_qgroup_convert_reserved_meta(inode->root,\n\t\t\t\t\t\t   qgroup_to_release);\n}\n\nstatic void btrfs_calculate_inode_block_rsv_size(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\t struct btrfs_inode *inode)\n{\n\tstruct btrfs_block_rsv *block_rsv = &inode->block_rsv;\n\tu64 reserve_size = 0;\n\tu64 qgroup_rsv_size = 0;\n\tu64 csum_leaves;\n\tunsigned outstanding_extents;\n\n\tlockdep_assert_held(&inode->lock);\n\toutstanding_extents = inode->outstanding_extents;\n\n\t \n\tif (outstanding_extents) {\n\t\treserve_size = btrfs_calc_insert_metadata_size(fs_info,\n\t\t\t\t\t\toutstanding_extents);\n\t\treserve_size += btrfs_calc_metadata_size(fs_info, 1);\n\t}\n\tcsum_leaves = btrfs_csum_bytes_to_leaves(fs_info,\n\t\t\t\t\t\t inode->csum_bytes);\n\treserve_size += btrfs_calc_insert_metadata_size(fs_info,\n\t\t\t\t\t\t\tcsum_leaves);\n\t \n\tqgroup_rsv_size = (u64)outstanding_extents * fs_info->nodesize;\n\n\tspin_lock(&block_rsv->lock);\n\tblock_rsv->size = reserve_size;\n\tblock_rsv->qgroup_rsv_size = qgroup_rsv_size;\n\tspin_unlock(&block_rsv->lock);\n}\n\nstatic void calc_inode_reservations(struct btrfs_fs_info *fs_info,\n\t\t\t\t    u64 num_bytes, u64 disk_num_bytes,\n\t\t\t\t    u64 *meta_reserve, u64 *qgroup_reserve)\n{\n\tu64 nr_extents = count_max_extents(fs_info, num_bytes);\n\tu64 csum_leaves = btrfs_csum_bytes_to_leaves(fs_info, disk_num_bytes);\n\tu64 inode_update = btrfs_calc_metadata_size(fs_info, 1);\n\n\t*meta_reserve = btrfs_calc_insert_metadata_size(fs_info,\n\t\t\t\t\t\tnr_extents + csum_leaves);\n\n\t \n\t*meta_reserve += inode_update;\n\t*qgroup_reserve = nr_extents * fs_info->nodesize;\n}\n\nint btrfs_delalloc_reserve_metadata(struct btrfs_inode *inode, u64 num_bytes,\n\t\t\t\t    u64 disk_num_bytes, bool noflush)\n{\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_block_rsv *block_rsv = &inode->block_rsv;\n\tu64 meta_reserve, qgroup_reserve;\n\tunsigned nr_extents;\n\tenum btrfs_reserve_flush_enum flush = BTRFS_RESERVE_FLUSH_ALL;\n\tint ret = 0;\n\n\t \n\tif (noflush || btrfs_is_free_space_inode(inode)) {\n\t\tflush = BTRFS_RESERVE_NO_FLUSH;\n\t} else {\n\t\tif (current->journal_info)\n\t\t\tflush = BTRFS_RESERVE_FLUSH_LIMIT;\n\t}\n\n\tnum_bytes = ALIGN(num_bytes, fs_info->sectorsize);\n\tdisk_num_bytes = ALIGN(disk_num_bytes, fs_info->sectorsize);\n\n\t \n\tcalc_inode_reservations(fs_info, num_bytes, disk_num_bytes,\n\t\t\t\t&meta_reserve, &qgroup_reserve);\n\tret = btrfs_qgroup_reserve_meta_prealloc(root, qgroup_reserve, true,\n\t\t\t\t\t\t noflush);\n\tif (ret)\n\t\treturn ret;\n\tret = btrfs_reserve_metadata_bytes(fs_info, block_rsv, meta_reserve, flush);\n\tif (ret) {\n\t\tbtrfs_qgroup_free_meta_prealloc(root, qgroup_reserve);\n\t\treturn ret;\n\t}\n\n\t \n\tnr_extents = count_max_extents(fs_info, num_bytes);\n\tspin_lock(&inode->lock);\n\tbtrfs_mod_outstanding_extents(inode, nr_extents);\n\tinode->csum_bytes += disk_num_bytes;\n\tbtrfs_calculate_inode_block_rsv_size(fs_info, inode);\n\tspin_unlock(&inode->lock);\n\n\t \n\tbtrfs_block_rsv_add_bytes(block_rsv, meta_reserve, false);\n\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t      btrfs_ino(inode), meta_reserve, 1);\n\n\tspin_lock(&block_rsv->lock);\n\tblock_rsv->qgroup_rsv_reserved += qgroup_reserve;\n\tspin_unlock(&block_rsv->lock);\n\n\treturn 0;\n}\n\n \nvoid btrfs_delalloc_release_metadata(struct btrfs_inode *inode, u64 num_bytes,\n\t\t\t\t     bool qgroup_free)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\n\tnum_bytes = ALIGN(num_bytes, fs_info->sectorsize);\n\tspin_lock(&inode->lock);\n\tinode->csum_bytes -= num_bytes;\n\tbtrfs_calculate_inode_block_rsv_size(fs_info, inode);\n\tspin_unlock(&inode->lock);\n\n\tif (btrfs_is_testing(fs_info))\n\t\treturn;\n\n\tbtrfs_inode_rsv_release(inode, qgroup_free);\n}\n\n \nvoid btrfs_delalloc_release_extents(struct btrfs_inode *inode, u64 num_bytes)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tunsigned num_extents;\n\n\tspin_lock(&inode->lock);\n\tnum_extents = count_max_extents(fs_info, num_bytes);\n\tbtrfs_mod_outstanding_extents(inode, -num_extents);\n\tbtrfs_calculate_inode_block_rsv_size(fs_info, inode);\n\tspin_unlock(&inode->lock);\n\n\tif (btrfs_is_testing(fs_info))\n\t\treturn;\n\n\tbtrfs_inode_rsv_release(inode, true);\n}\n\n \nint btrfs_delalloc_reserve_space(struct btrfs_inode *inode,\n\t\t\tstruct extent_changeset **reserved, u64 start, u64 len)\n{\n\tint ret;\n\n\tret = btrfs_check_data_free_space(inode, reserved, start, len, false);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = btrfs_delalloc_reserve_metadata(inode, len, len, false);\n\tif (ret < 0) {\n\t\tbtrfs_free_reserved_data_space(inode, *reserved, start, len);\n\t\textent_changeset_free(*reserved);\n\t\t*reserved = NULL;\n\t}\n\treturn ret;\n}\n\n \nvoid btrfs_delalloc_release_space(struct btrfs_inode *inode,\n\t\t\t\t  struct extent_changeset *reserved,\n\t\t\t\t  u64 start, u64 len, bool qgroup_free)\n{\n\tbtrfs_delalloc_release_metadata(inode, len, qgroup_free);\n\tbtrfs_free_reserved_data_space(inode, reserved, start, len);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}