{
  "module_name": "free-space-tree.c",
  "hash_id": "efd6ac6df36170d4441ed59581922ac3d1b1c32693a75797298bdbcc36d7fca4",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/free-space-tree.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/sched/mm.h>\n#include \"messages.h\"\n#include \"ctree.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"free-space-tree.h\"\n#include \"transaction.h\"\n#include \"block-group.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n#include \"extent-tree.h\"\n#include \"root-tree.h\"\n\nstatic int __add_block_group_free_space(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_block_group *block_group,\n\t\t\t\t\tstruct btrfs_path *path);\n\nstatic struct btrfs_root *btrfs_free_space_root(\n\t\t\t\tstruct btrfs_block_group *block_group)\n{\n\tstruct btrfs_key key = {\n\t\t.objectid = BTRFS_FREE_SPACE_TREE_OBJECTID,\n\t\t.type = BTRFS_ROOT_ITEM_KEY,\n\t\t.offset = 0,\n\t};\n\n\tif (btrfs_fs_incompat(block_group->fs_info, EXTENT_TREE_V2))\n\t\tkey.offset = block_group->global_root_id;\n\treturn btrfs_global_root(block_group->fs_info, &key);\n}\n\nvoid set_free_space_tree_thresholds(struct btrfs_block_group *cache)\n{\n\tu32 bitmap_range;\n\tsize_t bitmap_size;\n\tu64 num_bitmaps, total_bitmap_size;\n\n\tif (WARN_ON(cache->length == 0))\n\t\tbtrfs_warn(cache->fs_info, \"block group %llu length is zero\",\n\t\t\t   cache->start);\n\n\t \n\tbitmap_range = cache->fs_info->sectorsize * BTRFS_FREE_SPACE_BITMAP_BITS;\n\tnum_bitmaps = div_u64(cache->length + bitmap_range - 1, bitmap_range);\n\tbitmap_size = sizeof(struct btrfs_item) + BTRFS_FREE_SPACE_BITMAP_SIZE;\n\ttotal_bitmap_size = num_bitmaps * bitmap_size;\n\tcache->bitmap_high_thresh = div_u64(total_bitmap_size,\n\t\t\t\t\t    sizeof(struct btrfs_item));\n\n\t \n\tif (cache->bitmap_high_thresh > 100)\n\t\tcache->bitmap_low_thresh = cache->bitmap_high_thresh - 100;\n\telse\n\t\tcache->bitmap_low_thresh = 0;\n}\n\nstatic int add_new_free_space_info(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_block_group *block_group,\n\t\t\t\t   struct btrfs_path *path)\n{\n\tstruct btrfs_root *root = btrfs_free_space_root(block_group);\n\tstruct btrfs_free_space_info *info;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\n\tkey.objectid = block_group->start;\n\tkey.type = BTRFS_FREE_SPACE_INFO_KEY;\n\tkey.offset = block_group->length;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key, sizeof(*info));\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tinfo = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t      struct btrfs_free_space_info);\n\tbtrfs_set_free_space_extent_count(leaf, info, 0);\n\tbtrfs_set_free_space_flags(leaf, info, 0);\n\tbtrfs_mark_buffer_dirty(trans, leaf);\n\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\treturn ret;\n}\n\nEXPORT_FOR_TESTS\nstruct btrfs_free_space_info *search_free_space_info(\n\t\tstruct btrfs_trans_handle *trans,\n\t\tstruct btrfs_block_group *block_group,\n\t\tstruct btrfs_path *path, int cow)\n{\n\tstruct btrfs_fs_info *fs_info = block_group->fs_info;\n\tstruct btrfs_root *root = btrfs_free_space_root(block_group);\n\tstruct btrfs_key key;\n\tint ret;\n\n\tkey.objectid = block_group->start;\n\tkey.type = BTRFS_FREE_SPACE_INFO_KEY;\n\tkey.offset = block_group->length;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret != 0) {\n\t\tbtrfs_warn(fs_info, \"missing free space info for %llu\",\n\t\t\t   block_group->start);\n\t\tASSERT(0);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\treturn btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_free_space_info);\n}\n\n \nstatic int btrfs_search_prev_slot(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t  struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t\t  int ins_len, int cow)\n{\n\tint ret;\n\n\tret = btrfs_search_slot(trans, root, key, p, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0) {\n\t\tASSERT(0);\n\t\treturn -EIO;\n\t}\n\n\tif (p->slots[0] == 0) {\n\t\tASSERT(0);\n\t\treturn -EIO;\n\t}\n\tp->slots[0]--;\n\n\treturn 0;\n}\n\nstatic inline u32 free_space_bitmap_size(const struct btrfs_fs_info *fs_info,\n\t\t\t\t\t u64 size)\n{\n\treturn DIV_ROUND_UP(size >> fs_info->sectorsize_bits, BITS_PER_BYTE);\n}\n\nstatic unsigned long *alloc_bitmap(u32 bitmap_size)\n{\n\tunsigned long *ret;\n\tunsigned int nofs_flag;\n\tu32 bitmap_rounded_size = round_up(bitmap_size, sizeof(unsigned long));\n\n\t \n\tnofs_flag = memalloc_nofs_save();\n\tret = kvzalloc(bitmap_rounded_size, GFP_KERNEL);\n\tmemalloc_nofs_restore(nofs_flag);\n\treturn ret;\n}\n\nstatic void le_bitmap_set(unsigned long *map, unsigned int start, int len)\n{\n\tu8 *p = ((u8 *)map) + BIT_BYTE(start);\n\tconst unsigned int size = start + len;\n\tint bits_to_set = BITS_PER_BYTE - (start % BITS_PER_BYTE);\n\tu8 mask_to_set = BITMAP_FIRST_BYTE_MASK(start);\n\n\twhile (len - bits_to_set >= 0) {\n\t\t*p |= mask_to_set;\n\t\tlen -= bits_to_set;\n\t\tbits_to_set = BITS_PER_BYTE;\n\t\tmask_to_set = ~0;\n\t\tp++;\n\t}\n\tif (len) {\n\t\tmask_to_set &= BITMAP_LAST_BYTE_MASK(size);\n\t\t*p |= mask_to_set;\n\t}\n}\n\nEXPORT_FOR_TESTS\nint convert_free_space_to_bitmaps(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_block_group *block_group,\n\t\t\t\t  struct btrfs_path *path)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_root *root = btrfs_free_space_root(block_group);\n\tstruct btrfs_free_space_info *info;\n\tstruct btrfs_key key, found_key;\n\tstruct extent_buffer *leaf;\n\tunsigned long *bitmap;\n\tchar *bitmap_cursor;\n\tu64 start, end;\n\tu64 bitmap_range, i;\n\tu32 bitmap_size, flags, expected_extent_count;\n\tu32 extent_count = 0;\n\tint done = 0, nr;\n\tint ret;\n\n\tbitmap_size = free_space_bitmap_size(fs_info, block_group->length);\n\tbitmap = alloc_bitmap(bitmap_size);\n\tif (!bitmap) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tstart = block_group->start;\n\tend = block_group->start + block_group->length;\n\n\tkey.objectid = end - 1;\n\tkey.type = (u8)-1;\n\tkey.offset = (u64)-1;\n\n\twhile (!done) {\n\t\tret = btrfs_search_prev_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tleaf = path->nodes[0];\n\t\tnr = 0;\n\t\tpath->slots[0]++;\n\t\twhile (path->slots[0] > 0) {\n\t\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0] - 1);\n\n\t\t\tif (found_key.type == BTRFS_FREE_SPACE_INFO_KEY) {\n\t\t\t\tASSERT(found_key.objectid == block_group->start);\n\t\t\t\tASSERT(found_key.offset == block_group->length);\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t} else if (found_key.type == BTRFS_FREE_SPACE_EXTENT_KEY) {\n\t\t\t\tu64 first, last;\n\n\t\t\t\tASSERT(found_key.objectid >= start);\n\t\t\t\tASSERT(found_key.objectid < end);\n\t\t\t\tASSERT(found_key.objectid + found_key.offset <= end);\n\n\t\t\t\tfirst = div_u64(found_key.objectid - start,\n\t\t\t\t\t\tfs_info->sectorsize);\n\t\t\t\tlast = div_u64(found_key.objectid + found_key.offset - start,\n\t\t\t\t\t       fs_info->sectorsize);\n\t\t\t\tle_bitmap_set(bitmap, first, last - first);\n\n\t\t\t\textent_count++;\n\t\t\t\tnr++;\n\t\t\t\tpath->slots[0]--;\n\t\t\t} else {\n\t\t\t\tASSERT(0);\n\t\t\t}\n\t\t}\n\n\t\tret = btrfs_del_items(trans, root, path, path->slots[0], nr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbtrfs_release_path(path);\n\t}\n\n\tinfo = search_free_space_info(trans, block_group, path, 1);\n\tif (IS_ERR(info)) {\n\t\tret = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\tleaf = path->nodes[0];\n\tflags = btrfs_free_space_flags(leaf, info);\n\tflags |= BTRFS_FREE_SPACE_USING_BITMAPS;\n\tbtrfs_set_free_space_flags(leaf, info, flags);\n\texpected_extent_count = btrfs_free_space_extent_count(leaf, info);\n\tbtrfs_mark_buffer_dirty(trans, leaf);\n\tbtrfs_release_path(path);\n\n\tif (extent_count != expected_extent_count) {\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"incorrect extent count for %llu; counted %u, expected %u\",\n\t\t\t  block_group->start, extent_count,\n\t\t\t  expected_extent_count);\n\t\tASSERT(0);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tbitmap_cursor = (char *)bitmap;\n\tbitmap_range = fs_info->sectorsize * BTRFS_FREE_SPACE_BITMAP_BITS;\n\ti = start;\n\twhile (i < end) {\n\t\tunsigned long ptr;\n\t\tu64 extent_size;\n\t\tu32 data_size;\n\n\t\textent_size = min(end - i, bitmap_range);\n\t\tdata_size = free_space_bitmap_size(fs_info, extent_size);\n\n\t\tkey.objectid = i;\n\t\tkey.type = BTRFS_FREE_SPACE_BITMAP_KEY;\n\t\tkey.offset = extent_size;\n\n\t\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t\t      data_size);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tleaf = path->nodes[0];\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\twrite_extent_buffer(leaf, bitmap_cursor, ptr,\n\t\t\t\t    data_size);\n\t\tbtrfs_mark_buffer_dirty(trans, leaf);\n\t\tbtrfs_release_path(path);\n\n\t\ti += extent_size;\n\t\tbitmap_cursor += data_size;\n\t}\n\n\tret = 0;\nout:\n\tkvfree(bitmap);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, ret);\n\treturn ret;\n}\n\nEXPORT_FOR_TESTS\nint convert_free_space_to_extents(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_block_group *block_group,\n\t\t\t\t  struct btrfs_path *path)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_root *root = btrfs_free_space_root(block_group);\n\tstruct btrfs_free_space_info *info;\n\tstruct btrfs_key key, found_key;\n\tstruct extent_buffer *leaf;\n\tunsigned long *bitmap;\n\tu64 start, end;\n\tu32 bitmap_size, flags, expected_extent_count;\n\tunsigned long nrbits, start_bit, end_bit;\n\tu32 extent_count = 0;\n\tint done = 0, nr;\n\tint ret;\n\n\tbitmap_size = free_space_bitmap_size(fs_info, block_group->length);\n\tbitmap = alloc_bitmap(bitmap_size);\n\tif (!bitmap) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tstart = block_group->start;\n\tend = block_group->start + block_group->length;\n\n\tkey.objectid = end - 1;\n\tkey.type = (u8)-1;\n\tkey.offset = (u64)-1;\n\n\twhile (!done) {\n\t\tret = btrfs_search_prev_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tleaf = path->nodes[0];\n\t\tnr = 0;\n\t\tpath->slots[0]++;\n\t\twhile (path->slots[0] > 0) {\n\t\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0] - 1);\n\n\t\t\tif (found_key.type == BTRFS_FREE_SPACE_INFO_KEY) {\n\t\t\t\tASSERT(found_key.objectid == block_group->start);\n\t\t\t\tASSERT(found_key.offset == block_group->length);\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t} else if (found_key.type == BTRFS_FREE_SPACE_BITMAP_KEY) {\n\t\t\t\tunsigned long ptr;\n\t\t\t\tchar *bitmap_cursor;\n\t\t\t\tu32 bitmap_pos, data_size;\n\n\t\t\t\tASSERT(found_key.objectid >= start);\n\t\t\t\tASSERT(found_key.objectid < end);\n\t\t\t\tASSERT(found_key.objectid + found_key.offset <= end);\n\n\t\t\t\tbitmap_pos = div_u64(found_key.objectid - start,\n\t\t\t\t\t\t     fs_info->sectorsize *\n\t\t\t\t\t\t     BITS_PER_BYTE);\n\t\t\t\tbitmap_cursor = ((char *)bitmap) + bitmap_pos;\n\t\t\t\tdata_size = free_space_bitmap_size(fs_info,\n\t\t\t\t\t\t\t\tfound_key.offset);\n\n\t\t\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0] - 1);\n\t\t\t\tread_extent_buffer(leaf, bitmap_cursor, ptr,\n\t\t\t\t\t\t   data_size);\n\n\t\t\t\tnr++;\n\t\t\t\tpath->slots[0]--;\n\t\t\t} else {\n\t\t\t\tASSERT(0);\n\t\t\t}\n\t\t}\n\n\t\tret = btrfs_del_items(trans, root, path, path->slots[0], nr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbtrfs_release_path(path);\n\t}\n\n\tinfo = search_free_space_info(trans, block_group, path, 1);\n\tif (IS_ERR(info)) {\n\t\tret = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\tleaf = path->nodes[0];\n\tflags = btrfs_free_space_flags(leaf, info);\n\tflags &= ~BTRFS_FREE_SPACE_USING_BITMAPS;\n\tbtrfs_set_free_space_flags(leaf, info, flags);\n\texpected_extent_count = btrfs_free_space_extent_count(leaf, info);\n\tbtrfs_mark_buffer_dirty(trans, leaf);\n\tbtrfs_release_path(path);\n\n\tnrbits = block_group->length >> block_group->fs_info->sectorsize_bits;\n\tstart_bit = find_next_bit_le(bitmap, nrbits, 0);\n\n\twhile (start_bit < nrbits) {\n\t\tend_bit = find_next_zero_bit_le(bitmap, nrbits, start_bit);\n\t\tASSERT(start_bit < end_bit);\n\n\t\tkey.objectid = start + start_bit * block_group->fs_info->sectorsize;\n\t\tkey.type = BTRFS_FREE_SPACE_EXTENT_KEY;\n\t\tkey.offset = (end_bit - start_bit) * block_group->fs_info->sectorsize;\n\n\t\tret = btrfs_insert_empty_item(trans, root, path, &key, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbtrfs_release_path(path);\n\n\t\textent_count++;\n\n\t\tstart_bit = find_next_bit_le(bitmap, nrbits, end_bit);\n\t}\n\n\tif (extent_count != expected_extent_count) {\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"incorrect extent count for %llu; counted %u, expected %u\",\n\t\t\t  block_group->start, extent_count,\n\t\t\t  expected_extent_count);\n\t\tASSERT(0);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tkvfree(bitmap);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, ret);\n\treturn ret;\n}\n\nstatic int update_free_space_extent_count(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_block_group *block_group,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  int new_extents)\n{\n\tstruct btrfs_free_space_info *info;\n\tu32 flags;\n\tu32 extent_count;\n\tint ret = 0;\n\n\tif (new_extents == 0)\n\t\treturn 0;\n\n\tinfo = search_free_space_info(trans, block_group, path, 1);\n\tif (IS_ERR(info)) {\n\t\tret = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\tflags = btrfs_free_space_flags(path->nodes[0], info);\n\textent_count = btrfs_free_space_extent_count(path->nodes[0], info);\n\n\textent_count += new_extents;\n\tbtrfs_set_free_space_extent_count(path->nodes[0], info, extent_count);\n\tbtrfs_mark_buffer_dirty(trans, path->nodes[0]);\n\tbtrfs_release_path(path);\n\n\tif (!(flags & BTRFS_FREE_SPACE_USING_BITMAPS) &&\n\t    extent_count > block_group->bitmap_high_thresh) {\n\t\tret = convert_free_space_to_bitmaps(trans, block_group, path);\n\t} else if ((flags & BTRFS_FREE_SPACE_USING_BITMAPS) &&\n\t\t   extent_count < block_group->bitmap_low_thresh) {\n\t\tret = convert_free_space_to_extents(trans, block_group, path);\n\t}\n\nout:\n\treturn ret;\n}\n\nEXPORT_FOR_TESTS\nint free_space_test_bit(struct btrfs_block_group *block_group,\n\t\t\tstruct btrfs_path *path, u64 offset)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tu64 found_start, found_end;\n\tunsigned long ptr, i;\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tASSERT(key.type == BTRFS_FREE_SPACE_BITMAP_KEY);\n\n\tfound_start = key.objectid;\n\tfound_end = key.objectid + key.offset;\n\tASSERT(offset >= found_start && offset < found_end);\n\n\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\ti = div_u64(offset - found_start,\n\t\t    block_group->fs_info->sectorsize);\n\treturn !!extent_buffer_test_bit(leaf, ptr, i);\n}\n\nstatic void free_space_set_bits(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_block_group *block_group,\n\t\t\t\tstruct btrfs_path *path, u64 *start, u64 *size,\n\t\t\t\tint bit)\n{\n\tstruct btrfs_fs_info *fs_info = block_group->fs_info;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tu64 end = *start + *size;\n\tu64 found_start, found_end;\n\tunsigned long ptr, first, last;\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tASSERT(key.type == BTRFS_FREE_SPACE_BITMAP_KEY);\n\n\tfound_start = key.objectid;\n\tfound_end = key.objectid + key.offset;\n\tASSERT(*start >= found_start && *start < found_end);\n\tASSERT(end > found_start);\n\n\tif (end > found_end)\n\t\tend = found_end;\n\n\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\tfirst = (*start - found_start) >> fs_info->sectorsize_bits;\n\tlast = (end - found_start) >> fs_info->sectorsize_bits;\n\tif (bit)\n\t\textent_buffer_bitmap_set(leaf, ptr, first, last - first);\n\telse\n\t\textent_buffer_bitmap_clear(leaf, ptr, first, last - first);\n\tbtrfs_mark_buffer_dirty(trans, leaf);\n\n\t*size -= end - *start;\n\t*start = end;\n}\n\n \nstatic int free_space_next_bitmap(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root, struct btrfs_path *p)\n{\n\tstruct btrfs_key key;\n\n\tif (p->slots[0] + 1 < btrfs_header_nritems(p->nodes[0])) {\n\t\tp->slots[0]++;\n\t\treturn 0;\n\t}\n\n\tbtrfs_item_key_to_cpu(p->nodes[0], &key, p->slots[0]);\n\tbtrfs_release_path(p);\n\n\tkey.objectid += key.offset;\n\tkey.type = (u8)-1;\n\tkey.offset = (u64)-1;\n\n\treturn btrfs_search_prev_slot(trans, root, &key, p, 0, 1);\n}\n\n \nstatic int modify_free_space_bitmap(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_block_group *block_group,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    u64 start, u64 size, int remove)\n{\n\tstruct btrfs_root *root = btrfs_free_space_root(block_group);\n\tstruct btrfs_key key;\n\tu64 end = start + size;\n\tu64 cur_start, cur_size;\n\tint prev_bit, next_bit;\n\tint new_extents;\n\tint ret;\n\n\t \n\tif (start > block_group->start) {\n\t\tu64 prev_block = start - block_group->fs_info->sectorsize;\n\n\t\tkey.objectid = prev_block;\n\t\tkey.type = (u8)-1;\n\t\tkey.offset = (u64)-1;\n\n\t\tret = btrfs_search_prev_slot(trans, root, &key, path, 0, 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tprev_bit = free_space_test_bit(block_group, path, prev_block);\n\n\t\t \n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\t\tif (start >= key.objectid + key.offset) {\n\t\t\tret = free_space_next_bitmap(trans, root, path);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tkey.objectid = start;\n\t\tkey.type = (u8)-1;\n\t\tkey.offset = (u64)-1;\n\n\t\tret = btrfs_search_prev_slot(trans, root, &key, path, 0, 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tprev_bit = -1;\n\t}\n\n\t \n\tcur_start = start;\n\tcur_size = size;\n\twhile (1) {\n\t\tfree_space_set_bits(trans, block_group, path, &cur_start, &cur_size,\n\t\t\t\t    !remove);\n\t\tif (cur_size == 0)\n\t\t\tbreak;\n\t\tret = free_space_next_bitmap(trans, root, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (end < block_group->start + block_group->length) {\n\t\t \n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\t\tif (end >= key.objectid + key.offset) {\n\t\t\tret = free_space_next_bitmap(trans, root, path);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tnext_bit = free_space_test_bit(block_group, path, end);\n\t} else {\n\t\tnext_bit = -1;\n\t}\n\n\tif (remove) {\n\t\tnew_extents = -1;\n\t\tif (prev_bit == 1) {\n\t\t\t \n\t\t\tnew_extents++;\n\t\t}\n\t\tif (next_bit == 1) {\n\t\t\t \n\t\t\tnew_extents++;\n\t\t}\n\t} else {\n\t\tnew_extents = 1;\n\t\tif (prev_bit == 1) {\n\t\t\t \n\t\t\tnew_extents--;\n\t\t}\n\t\tif (next_bit == 1) {\n\t\t\t \n\t\t\tnew_extents--;\n\t\t}\n\t}\n\n\tbtrfs_release_path(path);\n\tret = update_free_space_extent_count(trans, block_group, path,\n\t\t\t\t\t     new_extents);\n\nout:\n\treturn ret;\n}\n\nstatic int remove_free_space_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_block_group *block_group,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    u64 start, u64 size)\n{\n\tstruct btrfs_root *root = btrfs_free_space_root(block_group);\n\tstruct btrfs_key key;\n\tu64 found_start, found_end;\n\tu64 end = start + size;\n\tint new_extents = -1;\n\tint ret;\n\n\tkey.objectid = start;\n\tkey.type = (u8)-1;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_prev_slot(trans, root, &key, path, -1, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\tASSERT(key.type == BTRFS_FREE_SPACE_EXTENT_KEY);\n\n\tfound_start = key.objectid;\n\tfound_end = key.objectid + key.offset;\n\tASSERT(start >= found_start && end <= found_end);\n\n\t \n\n\t \n\tret = btrfs_del_item(trans, root, path);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (start > found_start) {\n\t\tkey.objectid = found_start;\n\t\tkey.type = BTRFS_FREE_SPACE_EXTENT_KEY;\n\t\tkey.offset = start - found_start;\n\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, root, path, &key, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnew_extents++;\n\t}\n\n\t \n\tif (end < found_end) {\n\t\tkey.objectid = end;\n\t\tkey.type = BTRFS_FREE_SPACE_EXTENT_KEY;\n\t\tkey.offset = found_end - end;\n\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, root, path, &key, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnew_extents++;\n\t}\n\n\tbtrfs_release_path(path);\n\tret = update_free_space_extent_count(trans, block_group, path,\n\t\t\t\t\t     new_extents);\n\nout:\n\treturn ret;\n}\n\nEXPORT_FOR_TESTS\nint __remove_from_free_space_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_block_group *block_group,\n\t\t\t\t  struct btrfs_path *path, u64 start, u64 size)\n{\n\tstruct btrfs_free_space_info *info;\n\tu32 flags;\n\tint ret;\n\n\tif (test_bit(BLOCK_GROUP_FLAG_NEEDS_FREE_SPACE, &block_group->runtime_flags)) {\n\t\tret = __add_block_group_free_space(trans, block_group, path);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tinfo = search_free_space_info(NULL, block_group, path, 0);\n\tif (IS_ERR(info))\n\t\treturn PTR_ERR(info);\n\tflags = btrfs_free_space_flags(path->nodes[0], info);\n\tbtrfs_release_path(path);\n\n\tif (flags & BTRFS_FREE_SPACE_USING_BITMAPS) {\n\t\treturn modify_free_space_bitmap(trans, block_group, path,\n\t\t\t\t\t\tstart, size, 1);\n\t} else {\n\t\treturn remove_free_space_extent(trans, block_group, path,\n\t\t\t\t\t\tstart, size);\n\t}\n}\n\nint remove_from_free_space_tree(struct btrfs_trans_handle *trans,\n\t\t\t\tu64 start, u64 size)\n{\n\tstruct btrfs_block_group *block_group;\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tif (!btrfs_fs_compat_ro(trans->fs_info, FREE_SPACE_TREE))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tblock_group = btrfs_lookup_block_group(trans->fs_info, start);\n\tif (!block_group) {\n\t\tASSERT(0);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&block_group->free_space_lock);\n\tret = __remove_from_free_space_tree(trans, block_group, path, start,\n\t\t\t\t\t    size);\n\tmutex_unlock(&block_group->free_space_lock);\n\n\tbtrfs_put_block_group(block_group);\nout:\n\tbtrfs_free_path(path);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, ret);\n\treturn ret;\n}\n\nstatic int add_free_space_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_block_group *block_group,\n\t\t\t\t struct btrfs_path *path,\n\t\t\t\t u64 start, u64 size)\n{\n\tstruct btrfs_root *root = btrfs_free_space_root(block_group);\n\tstruct btrfs_key key, new_key;\n\tu64 found_start, found_end;\n\tu64 end = start + size;\n\tint new_extents = 1;\n\tint ret;\n\n\t \n\n\tnew_key.objectid = start;\n\tnew_key.type = BTRFS_FREE_SPACE_EXTENT_KEY;\n\tnew_key.offset = size;\n\n\t \n\tif (start == block_group->start)\n\t\tgoto right;\n\tkey.objectid = start - 1;\n\tkey.type = (u8)-1;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_prev_slot(trans, root, &key, path, -1, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\tif (key.type != BTRFS_FREE_SPACE_EXTENT_KEY) {\n\t\tASSERT(key.type == BTRFS_FREE_SPACE_INFO_KEY);\n\t\tbtrfs_release_path(path);\n\t\tgoto right;\n\t}\n\n\tfound_start = key.objectid;\n\tfound_end = key.objectid + key.offset;\n\tASSERT(found_start >= block_group->start &&\n\t       found_end > block_group->start);\n\tASSERT(found_start < start && found_end <= start);\n\n\t \n\tif (found_end == start) {\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnew_key.objectid = found_start;\n\t\tnew_key.offset += key.offset;\n\t\tnew_extents--;\n\t}\n\tbtrfs_release_path(path);\n\nright:\n\t \n\tif (end == block_group->start + block_group->length)\n\t\tgoto insert;\n\tkey.objectid = end;\n\tkey.type = (u8)-1;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_prev_slot(trans, root, &key, path, -1, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\tif (key.type != BTRFS_FREE_SPACE_EXTENT_KEY) {\n\t\tASSERT(key.type == BTRFS_FREE_SPACE_INFO_KEY);\n\t\tbtrfs_release_path(path);\n\t\tgoto insert;\n\t}\n\n\tfound_start = key.objectid;\n\tfound_end = key.objectid + key.offset;\n\tASSERT(found_start >= block_group->start &&\n\t       found_end > block_group->start);\n\tASSERT((found_start < start && found_end <= start) ||\n\t       (found_start >= end && found_end > end));\n\n\t \n\tif (found_start == end) {\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnew_key.offset += key.offset;\n\t\tnew_extents--;\n\t}\n\tbtrfs_release_path(path);\n\ninsert:\n\t \n\tret = btrfs_insert_empty_item(trans, root, path, &new_key, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tbtrfs_release_path(path);\n\tret = update_free_space_extent_count(trans, block_group, path,\n\t\t\t\t\t     new_extents);\n\nout:\n\treturn ret;\n}\n\nEXPORT_FOR_TESTS\nint __add_to_free_space_tree(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_block_group *block_group,\n\t\t\t     struct btrfs_path *path, u64 start, u64 size)\n{\n\tstruct btrfs_free_space_info *info;\n\tu32 flags;\n\tint ret;\n\n\tif (test_bit(BLOCK_GROUP_FLAG_NEEDS_FREE_SPACE, &block_group->runtime_flags)) {\n\t\tret = __add_block_group_free_space(trans, block_group, path);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tinfo = search_free_space_info(NULL, block_group, path, 0);\n\tif (IS_ERR(info))\n\t\treturn PTR_ERR(info);\n\tflags = btrfs_free_space_flags(path->nodes[0], info);\n\tbtrfs_release_path(path);\n\n\tif (flags & BTRFS_FREE_SPACE_USING_BITMAPS) {\n\t\treturn modify_free_space_bitmap(trans, block_group, path,\n\t\t\t\t\t\tstart, size, 0);\n\t} else {\n\t\treturn add_free_space_extent(trans, block_group, path, start,\n\t\t\t\t\t     size);\n\t}\n}\n\nint add_to_free_space_tree(struct btrfs_trans_handle *trans,\n\t\t\t   u64 start, u64 size)\n{\n\tstruct btrfs_block_group *block_group;\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tif (!btrfs_fs_compat_ro(trans->fs_info, FREE_SPACE_TREE))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tblock_group = btrfs_lookup_block_group(trans->fs_info, start);\n\tif (!block_group) {\n\t\tASSERT(0);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&block_group->free_space_lock);\n\tret = __add_to_free_space_tree(trans, block_group, path, start, size);\n\tmutex_unlock(&block_group->free_space_lock);\n\n\tbtrfs_put_block_group(block_group);\nout:\n\tbtrfs_free_path(path);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, ret);\n\treturn ret;\n}\n\n \nstatic int populate_free_space_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_block_group *block_group)\n{\n\tstruct btrfs_root *extent_root;\n\tstruct btrfs_path *path, *path2;\n\tstruct btrfs_key key;\n\tu64 start, end;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = READA_FORWARD;\n\n\tpath2 = btrfs_alloc_path();\n\tif (!path2) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = add_new_free_space_info(trans, block_group, path2);\n\tif (ret)\n\t\tgoto out;\n\n\tmutex_lock(&block_group->free_space_lock);\n\n\t \n\tkey.objectid = block_group->start;\n\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.offset = 0;\n\n\textent_root = btrfs_extent_root(trans->fs_info, key.objectid);\n\tret = btrfs_search_slot_for_read(extent_root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out_locked;\n\tASSERT(ret == 0);\n\n\tstart = block_group->start;\n\tend = block_group->start + block_group->length;\n\twhile (1) {\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\t\tif (key.type == BTRFS_EXTENT_ITEM_KEY ||\n\t\t    key.type == BTRFS_METADATA_ITEM_KEY) {\n\t\t\tif (key.objectid >= end)\n\t\t\t\tbreak;\n\n\t\t\tif (start < key.objectid) {\n\t\t\t\tret = __add_to_free_space_tree(trans,\n\t\t\t\t\t\t\t       block_group,\n\t\t\t\t\t\t\t       path2, start,\n\t\t\t\t\t\t\t       key.objectid -\n\t\t\t\t\t\t\t       start);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_locked;\n\t\t\t}\n\t\t\tstart = key.objectid;\n\t\t\tif (key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tstart += trans->fs_info->nodesize;\n\t\t\telse\n\t\t\t\tstart += key.offset;\n\t\t} else if (key.type == BTRFS_BLOCK_GROUP_ITEM_KEY) {\n\t\t\tif (key.objectid != block_group->start)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tret = btrfs_next_item(extent_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out_locked;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tif (start < end) {\n\t\tret = __add_to_free_space_tree(trans, block_group, path2,\n\t\t\t\t\t       start, end - start);\n\t\tif (ret)\n\t\t\tgoto out_locked;\n\t}\n\n\tret = 0;\nout_locked:\n\tmutex_unlock(&block_group->free_space_lock);\nout:\n\tbtrfs_free_path(path2);\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nint btrfs_create_free_space_tree(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *free_space_root;\n\tstruct btrfs_block_group *block_group;\n\tstruct rb_node *node;\n\tint ret;\n\n\ttrans = btrfs_start_transaction(tree_root, 0);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tset_bit(BTRFS_FS_CREATING_FREE_SPACE_TREE, &fs_info->flags);\n\tset_bit(BTRFS_FS_FREE_SPACE_TREE_UNTRUSTED, &fs_info->flags);\n\tfree_space_root = btrfs_create_tree(trans,\n\t\t\t\t\t    BTRFS_FREE_SPACE_TREE_OBJECTID);\n\tif (IS_ERR(free_space_root)) {\n\t\tret = PTR_ERR(free_space_root);\n\t\tgoto abort;\n\t}\n\tret = btrfs_global_root_insert(free_space_root);\n\tif (ret) {\n\t\tbtrfs_put_root(free_space_root);\n\t\tgoto abort;\n\t}\n\n\tnode = rb_first_cached(&fs_info->block_group_cache_tree);\n\twhile (node) {\n\t\tblock_group = rb_entry(node, struct btrfs_block_group,\n\t\t\t\t       cache_node);\n\t\tret = populate_free_space_tree(trans, block_group);\n\t\tif (ret)\n\t\t\tgoto abort;\n\t\tnode = rb_next(node);\n\t}\n\n\tbtrfs_set_fs_compat_ro(fs_info, FREE_SPACE_TREE);\n\tbtrfs_set_fs_compat_ro(fs_info, FREE_SPACE_TREE_VALID);\n\tclear_bit(BTRFS_FS_CREATING_FREE_SPACE_TREE, &fs_info->flags);\n\tret = btrfs_commit_transaction(trans);\n\n\t \n\tclear_bit(BTRFS_FS_FREE_SPACE_TREE_UNTRUSTED, &fs_info->flags);\n\treturn ret;\n\nabort:\n\tclear_bit(BTRFS_FS_CREATING_FREE_SPACE_TREE, &fs_info->flags);\n\tclear_bit(BTRFS_FS_FREE_SPACE_TREE_UNTRUSTED, &fs_info->flags);\n\tbtrfs_abort_transaction(trans, ret);\n\tbtrfs_end_transaction(trans);\n\treturn ret;\n}\n\nstatic int clear_free_space_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint nr;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = 0;\n\tkey.type = 0;\n\tkey.offset = 0;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tnr = btrfs_header_nritems(path->nodes[0]);\n\t\tif (!nr)\n\t\t\tbreak;\n\n\t\tpath->slots[0] = 0;\n\t\tret = btrfs_del_items(trans, root, path, 0, nr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tbtrfs_release_path(path);\n\t}\n\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nint btrfs_delete_free_space_tree(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_key key = {\n\t\t.objectid = BTRFS_FREE_SPACE_TREE_OBJECTID,\n\t\t.type = BTRFS_ROOT_ITEM_KEY,\n\t\t.offset = 0,\n\t};\n\tstruct btrfs_root *free_space_root = btrfs_global_root(fs_info, &key);\n\tint ret;\n\n\ttrans = btrfs_start_transaction(tree_root, 0);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tbtrfs_clear_fs_compat_ro(fs_info, FREE_SPACE_TREE);\n\tbtrfs_clear_fs_compat_ro(fs_info, FREE_SPACE_TREE_VALID);\n\n\tret = clear_free_space_tree(trans, free_space_root);\n\tif (ret)\n\t\tgoto abort;\n\n\tret = btrfs_del_root(trans, &free_space_root->root_key);\n\tif (ret)\n\t\tgoto abort;\n\n\tbtrfs_global_root_delete(free_space_root);\n\n\tspin_lock(&fs_info->trans_lock);\n\tlist_del(&free_space_root->dirty_list);\n\tspin_unlock(&fs_info->trans_lock);\n\n\tbtrfs_tree_lock(free_space_root->node);\n\tbtrfs_clear_buffer_dirty(trans, free_space_root->node);\n\tbtrfs_tree_unlock(free_space_root->node);\n\tbtrfs_free_tree_block(trans, btrfs_root_id(free_space_root),\n\t\t\t      free_space_root->node, 0, 1);\n\n\tbtrfs_put_root(free_space_root);\n\n\treturn btrfs_commit_transaction(trans);\n\nabort:\n\tbtrfs_abort_transaction(trans, ret);\n\tbtrfs_end_transaction(trans);\n\treturn ret;\n}\n\nint btrfs_rebuild_free_space_tree(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_key key = {\n\t\t.objectid = BTRFS_FREE_SPACE_TREE_OBJECTID,\n\t\t.type = BTRFS_ROOT_ITEM_KEY,\n\t\t.offset = 0,\n\t};\n\tstruct btrfs_root *free_space_root = btrfs_global_root(fs_info, &key);\n\tstruct rb_node *node;\n\tint ret;\n\n\ttrans = btrfs_start_transaction(free_space_root, 1);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tset_bit(BTRFS_FS_CREATING_FREE_SPACE_TREE, &fs_info->flags);\n\tset_bit(BTRFS_FS_FREE_SPACE_TREE_UNTRUSTED, &fs_info->flags);\n\n\tret = clear_free_space_tree(trans, free_space_root);\n\tif (ret)\n\t\tgoto abort;\n\n\tnode = rb_first_cached(&fs_info->block_group_cache_tree);\n\twhile (node) {\n\t\tstruct btrfs_block_group *block_group;\n\n\t\tblock_group = rb_entry(node, struct btrfs_block_group,\n\t\t\t\t       cache_node);\n\t\tret = populate_free_space_tree(trans, block_group);\n\t\tif (ret)\n\t\t\tgoto abort;\n\t\tnode = rb_next(node);\n\t}\n\n\tbtrfs_set_fs_compat_ro(fs_info, FREE_SPACE_TREE);\n\tbtrfs_set_fs_compat_ro(fs_info, FREE_SPACE_TREE_VALID);\n\tclear_bit(BTRFS_FS_CREATING_FREE_SPACE_TREE, &fs_info->flags);\n\n\tret = btrfs_commit_transaction(trans);\n\tclear_bit(BTRFS_FS_FREE_SPACE_TREE_UNTRUSTED, &fs_info->flags);\n\treturn ret;\nabort:\n\tbtrfs_abort_transaction(trans, ret);\n\tbtrfs_end_transaction(trans);\n\treturn ret;\n}\n\nstatic int __add_block_group_free_space(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_block_group *block_group,\n\t\t\t\t\tstruct btrfs_path *path)\n{\n\tint ret;\n\n\tclear_bit(BLOCK_GROUP_FLAG_NEEDS_FREE_SPACE, &block_group->runtime_flags);\n\n\tret = add_new_free_space_info(trans, block_group, path);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __add_to_free_space_tree(trans, block_group, path,\n\t\t\t\t\tblock_group->start,\n\t\t\t\t\tblock_group->length);\n}\n\nint add_block_group_free_space(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_block_group *block_group)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_path *path = NULL;\n\tint ret = 0;\n\n\tif (!btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE))\n\t\treturn 0;\n\n\tmutex_lock(&block_group->free_space_lock);\n\tif (!test_bit(BLOCK_GROUP_FLAG_NEEDS_FREE_SPACE, &block_group->runtime_flags))\n\t\tgoto out;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = __add_block_group_free_space(trans, block_group, path);\n\nout:\n\tbtrfs_free_path(path);\n\tmutex_unlock(&block_group->free_space_lock);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, ret);\n\treturn ret;\n}\n\nint remove_block_group_free_space(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_block_group *block_group)\n{\n\tstruct btrfs_root *root = btrfs_free_space_root(block_group);\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key, found_key;\n\tstruct extent_buffer *leaf;\n\tu64 start, end;\n\tint done = 0, nr;\n\tint ret;\n\n\tif (!btrfs_fs_compat_ro(trans->fs_info, FREE_SPACE_TREE))\n\t\treturn 0;\n\n\tif (test_bit(BLOCK_GROUP_FLAG_NEEDS_FREE_SPACE, &block_group->runtime_flags)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tstart = block_group->start;\n\tend = block_group->start + block_group->length;\n\n\tkey.objectid = end - 1;\n\tkey.type = (u8)-1;\n\tkey.offset = (u64)-1;\n\n\twhile (!done) {\n\t\tret = btrfs_search_prev_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tleaf = path->nodes[0];\n\t\tnr = 0;\n\t\tpath->slots[0]++;\n\t\twhile (path->slots[0] > 0) {\n\t\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0] - 1);\n\n\t\t\tif (found_key.type == BTRFS_FREE_SPACE_INFO_KEY) {\n\t\t\t\tASSERT(found_key.objectid == block_group->start);\n\t\t\t\tASSERT(found_key.offset == block_group->length);\n\t\t\t\tdone = 1;\n\t\t\t\tnr++;\n\t\t\t\tpath->slots[0]--;\n\t\t\t\tbreak;\n\t\t\t} else if (found_key.type == BTRFS_FREE_SPACE_EXTENT_KEY ||\n\t\t\t\t   found_key.type == BTRFS_FREE_SPACE_BITMAP_KEY) {\n\t\t\t\tASSERT(found_key.objectid >= start);\n\t\t\t\tASSERT(found_key.objectid < end);\n\t\t\t\tASSERT(found_key.objectid + found_key.offset <= end);\n\t\t\t\tnr++;\n\t\t\t\tpath->slots[0]--;\n\t\t\t} else {\n\t\t\t\tASSERT(0);\n\t\t\t}\n\t\t}\n\n\t\tret = btrfs_del_items(trans, root, path, path->slots[0], nr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbtrfs_release_path(path);\n\t}\n\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, ret);\n\treturn ret;\n}\n\nstatic int load_free_space_bitmaps(struct btrfs_caching_control *caching_ctl,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   u32 expected_extent_count)\n{\n\tstruct btrfs_block_group *block_group;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tint prev_bit = 0, bit;\n\t \n\tu64 extent_start = 0;\n\tu64 end, offset;\n\tu64 total_found = 0;\n\tu32 extent_count = 0;\n\tint ret;\n\n\tblock_group = caching_ctl->block_group;\n\tfs_info = block_group->fs_info;\n\troot = btrfs_free_space_root(block_group);\n\n\tend = block_group->start + block_group->length;\n\n\twhile (1) {\n\t\tret = btrfs_next_item(root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\t\tif (key.type == BTRFS_FREE_SPACE_INFO_KEY)\n\t\t\tbreak;\n\n\t\tASSERT(key.type == BTRFS_FREE_SPACE_BITMAP_KEY);\n\t\tASSERT(key.objectid < end && key.objectid + key.offset <= end);\n\n\t\toffset = key.objectid;\n\t\twhile (offset < key.objectid + key.offset) {\n\t\t\tbit = free_space_test_bit(block_group, path, offset);\n\t\t\tif (prev_bit == 0 && bit == 1) {\n\t\t\t\textent_start = offset;\n\t\t\t} else if (prev_bit == 1 && bit == 0) {\n\t\t\t\tu64 space_added;\n\n\t\t\t\tret = btrfs_add_new_free_space(block_group,\n\t\t\t\t\t\t\t       extent_start,\n\t\t\t\t\t\t\t       offset,\n\t\t\t\t\t\t\t       &space_added);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t\ttotal_found += space_added;\n\t\t\t\tif (total_found > CACHING_CTL_WAKE_UP) {\n\t\t\t\t\ttotal_found = 0;\n\t\t\t\t\twake_up(&caching_ctl->wait);\n\t\t\t\t}\n\t\t\t\textent_count++;\n\t\t\t}\n\t\t\tprev_bit = bit;\n\t\t\toffset += fs_info->sectorsize;\n\t\t}\n\t}\n\tif (prev_bit == 1) {\n\t\tret = btrfs_add_new_free_space(block_group, extent_start, end, NULL);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\textent_count++;\n\t}\n\n\tif (extent_count != expected_extent_count) {\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"incorrect extent count for %llu; counted %u, expected %u\",\n\t\t\t  block_group->start, extent_count,\n\t\t\t  expected_extent_count);\n\t\tASSERT(0);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\nstatic int load_free_space_extents(struct btrfs_caching_control *caching_ctl,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   u32 expected_extent_count)\n{\n\tstruct btrfs_block_group *block_group;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tu64 end;\n\tu64 total_found = 0;\n\tu32 extent_count = 0;\n\tint ret;\n\n\tblock_group = caching_ctl->block_group;\n\tfs_info = block_group->fs_info;\n\troot = btrfs_free_space_root(block_group);\n\n\tend = block_group->start + block_group->length;\n\n\twhile (1) {\n\t\tu64 space_added;\n\n\t\tret = btrfs_next_item(root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\t\tif (key.type == BTRFS_FREE_SPACE_INFO_KEY)\n\t\t\tbreak;\n\n\t\tASSERT(key.type == BTRFS_FREE_SPACE_EXTENT_KEY);\n\t\tASSERT(key.objectid < end && key.objectid + key.offset <= end);\n\n\t\tret = btrfs_add_new_free_space(block_group, key.objectid,\n\t\t\t\t\t       key.objectid + key.offset,\n\t\t\t\t\t       &space_added);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\ttotal_found += space_added;\n\t\tif (total_found > CACHING_CTL_WAKE_UP) {\n\t\t\ttotal_found = 0;\n\t\t\twake_up(&caching_ctl->wait);\n\t\t}\n\t\textent_count++;\n\t}\n\n\tif (extent_count != expected_extent_count) {\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"incorrect extent count for %llu; counted %u, expected %u\",\n\t\t\t  block_group->start, extent_count,\n\t\t\t  expected_extent_count);\n\t\tASSERT(0);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\nint load_free_space_tree(struct btrfs_caching_control *caching_ctl)\n{\n\tstruct btrfs_block_group *block_group;\n\tstruct btrfs_free_space_info *info;\n\tstruct btrfs_path *path;\n\tu32 extent_count, flags;\n\tint ret;\n\n\tblock_group = caching_ctl->block_group;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t \n\tpath->skip_locking = 1;\n\tpath->search_commit_root = 1;\n\tpath->reada = READA_FORWARD;\n\n\tinfo = search_free_space_info(NULL, block_group, path, 0);\n\tif (IS_ERR(info)) {\n\t\tret = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\textent_count = btrfs_free_space_extent_count(path->nodes[0], info);\n\tflags = btrfs_free_space_flags(path->nodes[0], info);\n\n\t \n\tif (flags & BTRFS_FREE_SPACE_USING_BITMAPS)\n\t\tret = load_free_space_bitmaps(caching_ctl, path, extent_count);\n\telse\n\t\tret = load_free_space_extents(caching_ctl, path, extent_count);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}