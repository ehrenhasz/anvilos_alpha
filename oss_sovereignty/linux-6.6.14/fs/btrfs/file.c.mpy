{
  "module_name": "file.c",
  "hash_id": "5565b4d5b3c01287195a86db2baa3e83508341f28e1d803302553b3034615179",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/file.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/btrfs.h>\n#include <linux/uio.h>\n#include <linux/iversion.h>\n#include <linux/fsverity.h>\n#include \"ctree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"print-tree.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"qgroup.h\"\n#include \"compression.h\"\n#include \"delalloc-space.h\"\n#include \"reflink.h\"\n#include \"subpage.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n#include \"extent-tree.h\"\n#include \"file-item.h\"\n#include \"ioctl.h\"\n#include \"file.h\"\n#include \"super.h\"\n\n \nstatic noinline int btrfs_copy_from_user(loff_t pos, size_t write_bytes,\n\t\t\t\t\t struct page **prepared_pages,\n\t\t\t\t\t struct iov_iter *i)\n{\n\tsize_t copied = 0;\n\tsize_t total_copied = 0;\n\tint pg = 0;\n\tint offset = offset_in_page(pos);\n\n\twhile (write_bytes > 0) {\n\t\tsize_t count = min_t(size_t,\n\t\t\t\t     PAGE_SIZE - offset, write_bytes);\n\t\tstruct page *page = prepared_pages[pg];\n\t\t \n\t\tcopied = copy_page_from_iter_atomic(page, offset, count, i);\n\n\t\t \n\t\tflush_dcache_page(page);\n\n\t\t \n\t\tif (unlikely(copied < count)) {\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tiov_iter_revert(i, copied);\n\t\t\t\tcopied = 0;\n\t\t\t}\n\t\t\tif (!copied)\n\t\t\t\tbreak;\n\t\t}\n\n\t\twrite_bytes -= copied;\n\t\ttotal_copied += copied;\n\t\toffset += copied;\n\t\tif (offset == PAGE_SIZE) {\n\t\t\tpg++;\n\t\t\toffset = 0;\n\t\t}\n\t}\n\treturn total_copied;\n}\n\n \nstatic void btrfs_drop_pages(struct btrfs_fs_info *fs_info,\n\t\t\t     struct page **pages, size_t num_pages,\n\t\t\t     u64 pos, u64 copied)\n{\n\tsize_t i;\n\tu64 block_start = round_down(pos, fs_info->sectorsize);\n\tu64 block_len = round_up(pos + copied, fs_info->sectorsize) - block_start;\n\n\tASSERT(block_len <= U32_MAX);\n\tfor (i = 0; i < num_pages; i++) {\n\t\t \n\t\tbtrfs_page_clamp_clear_checked(fs_info, pages[i], block_start,\n\t\t\t\t\t       block_len);\n\t\tunlock_page(pages[i]);\n\t\tput_page(pages[i]);\n\t}\n}\n\n \nint btrfs_dirty_pages(struct btrfs_inode *inode, struct page **pages,\n\t\t      size_t num_pages, loff_t pos, size_t write_bytes,\n\t\t      struct extent_state **cached, bool noreserve)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tint err = 0;\n\tint i;\n\tu64 num_bytes;\n\tu64 start_pos;\n\tu64 end_of_last_block;\n\tu64 end_pos = pos + write_bytes;\n\tloff_t isize = i_size_read(&inode->vfs_inode);\n\tunsigned int extra_bits = 0;\n\n\tif (write_bytes == 0)\n\t\treturn 0;\n\n\tif (noreserve)\n\t\textra_bits |= EXTENT_NORESERVE;\n\n\tstart_pos = round_down(pos, fs_info->sectorsize);\n\tnum_bytes = round_up(write_bytes + pos - start_pos,\n\t\t\t     fs_info->sectorsize);\n\tASSERT(num_bytes <= U32_MAX);\n\n\tend_of_last_block = start_pos + num_bytes - 1;\n\n\t \n\tclear_extent_bit(&inode->io_tree, start_pos, end_of_last_block,\n\t\t\t EXTENT_DELALLOC | EXTENT_DO_ACCOUNTING | EXTENT_DEFRAG,\n\t\t\t cached);\n\n\terr = btrfs_set_extent_delalloc(inode, start_pos, end_of_last_block,\n\t\t\t\t\textra_bits, cached);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = pages[i];\n\n\t\tbtrfs_page_clamp_set_uptodate(fs_info, p, start_pos, num_bytes);\n\t\tbtrfs_page_clamp_clear_checked(fs_info, p, start_pos, num_bytes);\n\t\tbtrfs_page_clamp_set_dirty(fs_info, p, start_pos, num_bytes);\n\t}\n\n\t \n\tif (end_pos > isize)\n\t\ti_size_write(&inode->vfs_inode, end_pos);\n\treturn 0;\n}\n\n \nint btrfs_drop_extents(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_inode *inode,\n\t\t       struct btrfs_drop_extents_args *args)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_ref ref = { 0 };\n\tstruct btrfs_key key;\n\tstruct btrfs_key new_key;\n\tu64 ino = btrfs_ino(inode);\n\tu64 search_start = args->start;\n\tu64 disk_bytenr = 0;\n\tu64 num_bytes = 0;\n\tu64 extent_offset = 0;\n\tu64 extent_end = 0;\n\tu64 last_end = args->start;\n\tint del_nr = 0;\n\tint del_slot = 0;\n\tint extent_type;\n\tint recow;\n\tint ret;\n\tint modify_tree = -1;\n\tint update_refs;\n\tint found = 0;\n\tstruct btrfs_path *path = args->path;\n\n\targs->bytes_found = 0;\n\targs->extent_inserted = false;\n\n\t \n\tASSERT(!(args->replace_extent && !args->path));\n\n\tif (!path) {\n\t\tpath = btrfs_alloc_path();\n\t\tif (!path) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (args->drop_cache)\n\t\tbtrfs_drop_extent_map_range(inode, args->start, args->end - 1, false);\n\n\tif (args->start >= inode->disk_i_size && !args->replace_extent)\n\t\tmodify_tree = 0;\n\n\tupdate_refs = (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID);\n\twhile (1) {\n\t\trecow = 0;\n\t\tret = btrfs_lookup_file_extent(trans, root, path, ino,\n\t\t\t\t\t       search_start, modify_tree);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0 && path->slots[0] > 0 && search_start == args->start) {\n\t\t\tleaf = path->nodes[0];\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\t\tif (key.objectid == ino &&\n\t\t\t    key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t\tret = 0;\nnext_slot:\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleaf = path->nodes[0];\n\t\t\trecow = 1;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\n\t\tif (key.objectid > ino)\n\t\t\tbreak;\n\t\tif (WARN_ON_ONCE(key.objectid < ino) ||\n\t\t    key.type < BTRFS_EXTENT_DATA_KEY) {\n\t\t\tASSERT(del_nr == 0);\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\t\tif (key.type > BTRFS_EXTENT_DATA_KEY || key.offset >= args->end)\n\t\t\tbreak;\n\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\textent_type = btrfs_file_extent_type(leaf, fi);\n\n\t\tif (extent_type == BTRFS_FILE_EXTENT_REG ||\n\t\t    extent_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\tdisk_bytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\t\tnum_bytes = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\t\textent_offset = btrfs_file_extent_offset(leaf, fi);\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_ram_bytes(leaf, fi);\n\t\t} else {\n\t\t\t \n\t\t\tBUG();\n\t\t}\n\n\t\t \n\t\tif (extent_end == key.offset && extent_end >= search_start) {\n\t\t\tlast_end = extent_end;\n\t\t\tgoto delete_extent_item;\n\t\t}\n\n\t\tif (extent_end <= search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\tfound = 1;\n\t\tsearch_start = max(key.offset, args->start);\n\t\tif (recow || !modify_tree) {\n\t\t\tmodify_tree = -1;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (args->start > key.offset && args->end < extent_end) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.offset = args->start;\n\t\t\tret = btrfs_duplicate_item(trans, root, path,\n\t\t\t\t\t\t   &new_key);\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tleaf = path->nodes[0];\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0] - 1,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\targs->start - key.offset);\n\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\n\t\t\textent_offset += args->start - key.offset;\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi, extent_offset);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - args->start);\n\t\t\tbtrfs_mark_buffer_dirty(trans, leaf);\n\n\t\t\tif (update_refs && disk_bytenr > 0) {\n\t\t\t\tbtrfs_init_generic_ref(&ref,\n\t\t\t\t\t\tBTRFS_ADD_DELAYED_REF,\n\t\t\t\t\t\tdisk_bytenr, num_bytes, 0);\n\t\t\t\tbtrfs_init_data_ref(&ref,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tnew_key.objectid,\n\t\t\t\t\t\targs->start - extent_offset,\n\t\t\t\t\t\t0, false);\n\t\t\t\tret = btrfs_inc_extent_ref(trans, &ref);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tkey.offset = args->start;\n\t\t}\n\t\t \n\t\tlast_end = extent_end;\n\n\t\t \n\t\tif (args->start <= key.offset && args->end < extent_end) {\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.offset = args->end;\n\t\t\tbtrfs_set_item_key_safe(trans, path, &new_key);\n\n\t\t\textent_offset += args->end - key.offset;\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi, extent_offset);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - args->end);\n\t\t\tbtrfs_mark_buffer_dirty(trans, leaf);\n\t\t\tif (update_refs && disk_bytenr > 0)\n\t\t\t\targs->bytes_found += args->end - key.offset;\n\t\t\tbreak;\n\t\t}\n\n\t\tsearch_start = extent_end;\n\t\t \n\t\tif (args->start > key.offset && args->end >= extent_end) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\targs->start - key.offset);\n\t\t\tbtrfs_mark_buffer_dirty(trans, leaf);\n\t\t\tif (update_refs && disk_bytenr > 0)\n\t\t\t\targs->bytes_found += extent_end - args->start;\n\t\t\tif (args->end == extent_end)\n\t\t\t\tbreak;\n\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\t \n\t\tif (args->start <= key.offset && args->end >= extent_end) {\ndelete_extent_item:\n\t\t\tif (del_nr == 0) {\n\t\t\t\tdel_slot = path->slots[0];\n\t\t\t\tdel_nr = 1;\n\t\t\t} else {\n\t\t\t\tBUG_ON(del_slot + del_nr != path->slots[0]);\n\t\t\t\tdel_nr++;\n\t\t\t}\n\n\t\t\tif (update_refs &&\n\t\t\t    extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\targs->bytes_found += extent_end - key.offset;\n\t\t\t\textent_end = ALIGN(extent_end,\n\t\t\t\t\t\t   fs_info->sectorsize);\n\t\t\t} else if (update_refs && disk_bytenr > 0) {\n\t\t\t\tbtrfs_init_generic_ref(&ref,\n\t\t\t\t\t\tBTRFS_DROP_DELAYED_REF,\n\t\t\t\t\t\tdisk_bytenr, num_bytes, 0);\n\t\t\t\tbtrfs_init_data_ref(&ref,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tkey.objectid,\n\t\t\t\t\t\tkey.offset - extent_offset, 0,\n\t\t\t\t\t\tfalse);\n\t\t\t\tret = btrfs_free_extent(trans, &ref);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\targs->bytes_found += extent_end - key.offset;\n\t\t\t}\n\n\t\t\tif (args->end == extent_end)\n\t\t\t\tbreak;\n\n\t\t\tif (path->slots[0] + 1 < btrfs_header_nritems(leaf)) {\n\t\t\t\tpath->slots[0]++;\n\t\t\t\tgoto next_slot;\n\t\t\t}\n\n\t\t\tret = btrfs_del_items(trans, root, path, del_slot,\n\t\t\t\t\t      del_nr);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdel_nr = 0;\n\t\t\tdel_slot = 0;\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tBUG();\n\t}\n\n\tif (!ret && del_nr > 0) {\n\t\t \n\t\tpath->slots[0] = del_slot;\n\t\tret = btrfs_del_items(trans, root, path, del_slot, del_nr);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t}\n\n\tleaf = path->nodes[0];\n\t \n\tif (!ret && args->replace_extent &&\n\t    path->locks[0] == BTRFS_WRITE_LOCK &&\n\t    btrfs_leaf_free_space(leaf) >=\n\t    sizeof(struct btrfs_item) + args->extent_item_size) {\n\n\t\tkey.objectid = ino;\n\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\tkey.offset = args->start;\n\t\tif (!del_nr && path->slots[0] < btrfs_header_nritems(leaf)) {\n\t\t\tstruct btrfs_key slot_key;\n\n\t\t\tbtrfs_item_key_to_cpu(leaf, &slot_key, path->slots[0]);\n\t\t\tif (btrfs_comp_cpu_keys(&key, &slot_key) > 0)\n\t\t\t\tpath->slots[0]++;\n\t\t}\n\t\tbtrfs_setup_item_for_insert(trans, root, path, &key,\n\t\t\t\t\t    args->extent_item_size);\n\t\targs->extent_inserted = true;\n\t}\n\n\tif (!args->path)\n\t\tbtrfs_free_path(path);\n\telse if (!args->extent_inserted)\n\t\tbtrfs_release_path(path);\nout:\n\targs->drop_end = found ? min(args->end, last_end) : args->end;\n\n\treturn ret;\n}\n\nstatic int extent_mergeable(struct extent_buffer *leaf, int slot,\n\t\t\t    u64 objectid, u64 bytenr, u64 orig_offset,\n\t\t\t    u64 *start, u64 *end)\n{\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tu64 extent_end;\n\n\tif (slot < 0 || slot >= btrfs_header_nritems(leaf))\n\t\treturn 0;\n\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\tif (key.objectid != objectid || key.type != BTRFS_EXTENT_DATA_KEY)\n\t\treturn 0;\n\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tif (btrfs_file_extent_type(leaf, fi) != BTRFS_FILE_EXTENT_REG ||\n\t    btrfs_file_extent_disk_bytenr(leaf, fi) != bytenr ||\n\t    btrfs_file_extent_offset(leaf, fi) != key.offset - orig_offset ||\n\t    btrfs_file_extent_compression(leaf, fi) ||\n\t    btrfs_file_extent_encryption(leaf, fi) ||\n\t    btrfs_file_extent_other_encoding(leaf, fi))\n\t\treturn 0;\n\n\textent_end = key.offset + btrfs_file_extent_num_bytes(leaf, fi);\n\tif ((*start && *start != key.offset) || (*end && *end != extent_end))\n\t\treturn 0;\n\n\t*start = key.offset;\n\t*end = extent_end;\n\treturn 1;\n}\n\n \nint btrfs_mark_extent_written(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_inode *inode, u64 start, u64 end)\n{\n\tstruct btrfs_root *root = inode->root;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_path *path;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_ref ref = { 0 };\n\tstruct btrfs_key key;\n\tstruct btrfs_key new_key;\n\tu64 bytenr;\n\tu64 num_bytes;\n\tu64 extent_end;\n\tu64 orig_offset;\n\tu64 other_start;\n\tu64 other_end;\n\tu64 split;\n\tint del_nr = 0;\n\tint del_slot = 0;\n\tint recow;\n\tint ret = 0;\n\tu64 ino = btrfs_ino(inode);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\trecow = 0;\n\tsplit = start;\n\tkey.objectid = ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = split;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0 && path->slots[0] > 0)\n\t\tpath->slots[0]--;\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tif (key.objectid != ino ||\n\t    key.type != BTRFS_EXTENT_DATA_KEY) {\n\t\tret = -EINVAL;\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\n\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\tif (btrfs_file_extent_type(leaf, fi) != BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tret = -EINVAL;\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\n\textent_end = key.offset + btrfs_file_extent_num_bytes(leaf, fi);\n\tif (key.offset > start || extent_end < end) {\n\t\tret = -EINVAL;\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\n\n\tbytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\tnum_bytes = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\torig_offset = key.offset - btrfs_file_extent_offset(leaf, fi);\n\tmemcpy(&new_key, &key, sizeof(new_key));\n\n\tif (start == key.offset && end < extent_end) {\n\t\tother_start = 0;\n\t\tother_end = start;\n\t\tif (extent_mergeable(leaf, path->slots[0] - 1,\n\t\t\t\t     ino, bytenr, orig_offset,\n\t\t\t\t     &other_start, &other_end)) {\n\t\t\tnew_key.offset = end;\n\t\t\tbtrfs_set_item_key_safe(trans, path, &new_key);\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_generation(leaf, fi,\n\t\t\t\t\t\t\t trans->transid);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - end);\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi,\n\t\t\t\t\t\t     end - orig_offset);\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0] - 1,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_generation(leaf, fi,\n\t\t\t\t\t\t\t trans->transid);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tend - other_start);\n\t\t\tbtrfs_mark_buffer_dirty(trans, leaf);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (start > key.offset && end == extent_end) {\n\t\tother_start = end;\n\t\tother_end = 0;\n\t\tif (extent_mergeable(leaf, path->slots[0] + 1,\n\t\t\t\t     ino, bytenr, orig_offset,\n\t\t\t\t     &other_start, &other_end)) {\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\t\t\tbtrfs_set_file_extent_generation(leaf, fi,\n\t\t\t\t\t\t\t trans->transid);\n\t\t\tpath->slots[0]++;\n\t\t\tnew_key.offset = start;\n\t\t\tbtrfs_set_item_key_safe(trans, path, &new_key);\n\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_generation(leaf, fi,\n\t\t\t\t\t\t\t trans->transid);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tother_end - start);\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi,\n\t\t\t\t\t\t     start - orig_offset);\n\t\t\tbtrfs_mark_buffer_dirty(trans, leaf);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\twhile (start > key.offset || end < extent_end) {\n\t\tif (key.offset == start)\n\t\t\tsplit = end;\n\n\t\tnew_key.offset = split;\n\t\tret = btrfs_duplicate_item(trans, root, path, &new_key);\n\t\tif (ret == -EAGAIN) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto again;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tleaf = path->nodes[0];\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0] - 1,\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tbtrfs_set_file_extent_generation(leaf, fi, trans->transid);\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\tsplit - key.offset);\n\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\n\t\tbtrfs_set_file_extent_generation(leaf, fi, trans->transid);\n\t\tbtrfs_set_file_extent_offset(leaf, fi, split - orig_offset);\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\textent_end - split);\n\t\tbtrfs_mark_buffer_dirty(trans, leaf);\n\n\t\tbtrfs_init_generic_ref(&ref, BTRFS_ADD_DELAYED_REF, bytenr,\n\t\t\t\t       num_bytes, 0);\n\t\tbtrfs_init_data_ref(&ref, root->root_key.objectid, ino,\n\t\t\t\t    orig_offset, 0, false);\n\t\tret = btrfs_inc_extent_ref(trans, &ref);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (split == start) {\n\t\t\tkey.offset = start;\n\t\t} else {\n\t\t\tif (start != key.offset) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpath->slots[0]--;\n\t\t\textent_end = end;\n\t\t}\n\t\trecow = 1;\n\t}\n\n\tother_start = end;\n\tother_end = 0;\n\tbtrfs_init_generic_ref(&ref, BTRFS_DROP_DELAYED_REF, bytenr,\n\t\t\t       num_bytes, 0);\n\tbtrfs_init_data_ref(&ref, root->root_key.objectid, ino, orig_offset,\n\t\t\t    0, false);\n\tif (extent_mergeable(leaf, path->slots[0] + 1,\n\t\t\t     ino, bytenr, orig_offset,\n\t\t\t     &other_start, &other_end)) {\n\t\tif (recow) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto again;\n\t\t}\n\t\textent_end = other_end;\n\t\tdel_slot = path->slots[0] + 1;\n\t\tdel_nr++;\n\t\tret = btrfs_free_extent(trans, &ref);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tother_start = 0;\n\tother_end = start;\n\tif (extent_mergeable(leaf, path->slots[0] - 1,\n\t\t\t     ino, bytenr, orig_offset,\n\t\t\t     &other_start, &other_end)) {\n\t\tif (recow) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto again;\n\t\t}\n\t\tkey.offset = other_start;\n\t\tdel_slot = path->slots[0];\n\t\tdel_nr++;\n\t\tret = btrfs_free_extent(trans, &ref);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (del_nr == 0) {\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t   struct btrfs_file_extent_item);\n\t\tbtrfs_set_file_extent_type(leaf, fi,\n\t\t\t\t\t   BTRFS_FILE_EXTENT_REG);\n\t\tbtrfs_set_file_extent_generation(leaf, fi, trans->transid);\n\t\tbtrfs_mark_buffer_dirty(trans, leaf);\n\t} else {\n\t\tfi = btrfs_item_ptr(leaf, del_slot - 1,\n\t\t\t   struct btrfs_file_extent_item);\n\t\tbtrfs_set_file_extent_type(leaf, fi,\n\t\t\t\t\t   BTRFS_FILE_EXTENT_REG);\n\t\tbtrfs_set_file_extent_generation(leaf, fi, trans->transid);\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\textent_end - key.offset);\n\t\tbtrfs_mark_buffer_dirty(trans, leaf);\n\n\t\tret = btrfs_del_items(trans, root, path, del_slot, del_nr);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n \nstatic int prepare_uptodate_page(struct inode *inode,\n\t\t\t\t struct page *page, u64 pos,\n\t\t\t\t bool force_uptodate)\n{\n\tstruct folio *folio = page_folio(page);\n\tint ret = 0;\n\n\tif (((pos & (PAGE_SIZE - 1)) || force_uptodate) &&\n\t    !PageUptodate(page)) {\n\t\tret = btrfs_read_folio(NULL, folio);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tif (page->mapping != inode->i_mapping || !PagePrivate(page)) {\n\t\t\tunlock_page(page);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic fgf_t get_prepare_fgp_flags(bool nowait)\n{\n\tfgf_t fgp_flags = FGP_LOCK | FGP_ACCESSED | FGP_CREAT;\n\n\tif (nowait)\n\t\tfgp_flags |= FGP_NOWAIT;\n\n\treturn fgp_flags;\n}\n\nstatic gfp_t get_prepare_gfp_flags(struct inode *inode, bool nowait)\n{\n\tgfp_t gfp;\n\n\tgfp = btrfs_alloc_write_mask(inode->i_mapping);\n\tif (nowait) {\n\t\tgfp &= ~__GFP_DIRECT_RECLAIM;\n\t\tgfp |= GFP_NOWAIT;\n\t}\n\n\treturn gfp;\n}\n\n \nstatic noinline int prepare_pages(struct inode *inode, struct page **pages,\n\t\t\t\t  size_t num_pages, loff_t pos,\n\t\t\t\t  size_t write_bytes, bool force_uptodate,\n\t\t\t\t  bool nowait)\n{\n\tint i;\n\tunsigned long index = pos >> PAGE_SHIFT;\n\tgfp_t mask = get_prepare_gfp_flags(inode, nowait);\n\tfgf_t fgp_flags = get_prepare_fgp_flags(nowait);\n\tint err = 0;\n\tint faili;\n\n\tfor (i = 0; i < num_pages; i++) {\nagain:\n\t\tpages[i] = pagecache_get_page(inode->i_mapping, index + i,\n\t\t\t\t\t      fgp_flags, mask | __GFP_WRITE);\n\t\tif (!pages[i]) {\n\t\t\tfaili = i - 1;\n\t\t\tif (nowait)\n\t\t\t\terr = -EAGAIN;\n\t\t\telse\n\t\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\terr = set_page_extent_mapped(pages[i]);\n\t\tif (err < 0) {\n\t\t\tfaili = i;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (i == 0)\n\t\t\terr = prepare_uptodate_page(inode, pages[i], pos,\n\t\t\t\t\t\t    force_uptodate);\n\t\tif (!err && i == num_pages - 1)\n\t\t\terr = prepare_uptodate_page(inode, pages[i],\n\t\t\t\t\t\t    pos + write_bytes, false);\n\t\tif (err) {\n\t\t\tput_page(pages[i]);\n\t\t\tif (!nowait && err == -EAGAIN) {\n\t\t\t\terr = 0;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tfaili = i - 1;\n\t\t\tgoto fail;\n\t\t}\n\t\twait_on_page_writeback(pages[i]);\n\t}\n\n\treturn 0;\nfail:\n\twhile (faili >= 0) {\n\t\tunlock_page(pages[faili]);\n\t\tput_page(pages[faili]);\n\t\tfaili--;\n\t}\n\treturn err;\n\n}\n\n \nstatic noinline int\nlock_and_cleanup_extent_if_need(struct btrfs_inode *inode, struct page **pages,\n\t\t\t\tsize_t num_pages, loff_t pos,\n\t\t\t\tsize_t write_bytes,\n\t\t\t\tu64 *lockstart, u64 *lockend, bool nowait,\n\t\t\t\tstruct extent_state **cached_state)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tu64 start_pos;\n\tu64 last_pos;\n\tint i;\n\tint ret = 0;\n\n\tstart_pos = round_down(pos, fs_info->sectorsize);\n\tlast_pos = round_up(pos + write_bytes, fs_info->sectorsize) - 1;\n\n\tif (start_pos < inode->vfs_inode.i_size) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\n\t\tif (nowait) {\n\t\t\tif (!try_lock_extent(&inode->io_tree, start_pos, last_pos,\n\t\t\t\t\t     cached_state)) {\n\t\t\t\tfor (i = 0; i < num_pages; i++) {\n\t\t\t\t\tunlock_page(pages[i]);\n\t\t\t\t\tput_page(pages[i]);\n\t\t\t\t\tpages[i] = NULL;\n\t\t\t\t}\n\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t} else {\n\t\t\tlock_extent(&inode->io_tree, start_pos, last_pos, cached_state);\n\t\t}\n\n\t\tordered = btrfs_lookup_ordered_range(inode, start_pos,\n\t\t\t\t\t\t     last_pos - start_pos + 1);\n\t\tif (ordered &&\n\t\t    ordered->file_offset + ordered->num_bytes > start_pos &&\n\t\t    ordered->file_offset <= last_pos) {\n\t\t\tunlock_extent(&inode->io_tree, start_pos, last_pos,\n\t\t\t\t      cached_state);\n\t\t\tfor (i = 0; i < num_pages; i++) {\n\t\t\t\tunlock_page(pages[i]);\n\t\t\t\tput_page(pages[i]);\n\t\t\t}\n\t\t\tbtrfs_start_ordered_extent(ordered);\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\n\t\t*lockstart = start_pos;\n\t\t*lockend = last_pos;\n\t\tret = 1;\n\t}\n\n\t \n\tfor (i = 0; i < num_pages; i++)\n\t\tWARN_ON(!PageLocked(pages[i]));\n\n\treturn ret;\n}\n\n \nint btrfs_check_nocow_lock(struct btrfs_inode *inode, loff_t pos,\n\t\t\t   size_t *write_bytes, bool nowait)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tstruct btrfs_root *root = inode->root;\n\tstruct extent_state *cached_state = NULL;\n\tu64 lockstart, lockend;\n\tu64 num_bytes;\n\tint ret;\n\n\tif (!(inode->flags & (BTRFS_INODE_NODATACOW | BTRFS_INODE_PREALLOC)))\n\t\treturn 0;\n\n\tif (!btrfs_drew_try_write_lock(&root->snapshot_lock))\n\t\treturn -EAGAIN;\n\n\tlockstart = round_down(pos, fs_info->sectorsize);\n\tlockend = round_up(pos + *write_bytes,\n\t\t\t   fs_info->sectorsize) - 1;\n\tnum_bytes = lockend - lockstart + 1;\n\n\tif (nowait) {\n\t\tif (!btrfs_try_lock_ordered_range(inode, lockstart, lockend,\n\t\t\t\t\t\t  &cached_state)) {\n\t\t\tbtrfs_drew_write_unlock(&root->snapshot_lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t} else {\n\t\tbtrfs_lock_and_flush_ordered_range(inode, lockstart, lockend,\n\t\t\t\t\t\t   &cached_state);\n\t}\n\tret = can_nocow_extent(&inode->vfs_inode, lockstart, &num_bytes,\n\t\t\tNULL, NULL, NULL, nowait, false);\n\tif (ret <= 0)\n\t\tbtrfs_drew_write_unlock(&root->snapshot_lock);\n\telse\n\t\t*write_bytes = min_t(size_t, *write_bytes ,\n\t\t\t\t     num_bytes - pos + lockstart);\n\tunlock_extent(&inode->io_tree, lockstart, lockend, &cached_state);\n\n\treturn ret;\n}\n\nvoid btrfs_check_nocow_unlock(struct btrfs_inode *inode)\n{\n\tbtrfs_drew_write_unlock(&inode->root->snapshot_lock);\n}\n\nstatic void update_time_for_write(struct inode *inode)\n{\n\tstruct timespec64 now, ctime;\n\n\tif (IS_NOCMTIME(inode))\n\t\treturn;\n\n\tnow = current_time(inode);\n\tif (!timespec64_equal(&inode->i_mtime, &now))\n\t\tinode->i_mtime = now;\n\n\tctime = inode_get_ctime(inode);\n\tif (!timespec64_equal(&ctime, &now))\n\t\tinode_set_ctime_to_ts(inode, now);\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n}\n\nstatic int btrfs_write_check(struct kiocb *iocb, struct iov_iter *from,\n\t\t\t     size_t count)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tloff_t pos = iocb->ki_pos;\n\tint ret;\n\tloff_t oldsize;\n\tloff_t start_pos;\n\n\t \n\tif ((iocb->ki_flags & IOCB_NOWAIT) &&\n\t    !(BTRFS_I(inode)->flags & (BTRFS_INODE_NODATACOW | BTRFS_INODE_PREALLOC)))\n\t\treturn -EAGAIN;\n\n\tret = file_remove_privs(file);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tupdate_time_for_write(inode);\n\n\tstart_pos = round_down(pos, fs_info->sectorsize);\n\toldsize = i_size_read(inode);\n\tif (start_pos > oldsize) {\n\t\t \n\t\tloff_t end_pos = round_up(pos + count, fs_info->sectorsize);\n\n\t\tret = btrfs_cont_expand(BTRFS_I(inode), oldsize, end_pos);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic noinline ssize_t btrfs_buffered_write(struct kiocb *iocb,\n\t\t\t\t\t       struct iov_iter *i)\n{\n\tstruct file *file = iocb->ki_filp;\n\tloff_t pos;\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct page **pages = NULL;\n\tstruct extent_changeset *data_reserved = NULL;\n\tu64 release_bytes = 0;\n\tu64 lockstart;\n\tu64 lockend;\n\tsize_t num_written = 0;\n\tint nrptrs;\n\tssize_t ret;\n\tbool only_release_metadata = false;\n\tbool force_page_uptodate = false;\n\tloff_t old_isize = i_size_read(inode);\n\tunsigned int ilock_flags = 0;\n\tconst bool nowait = (iocb->ki_flags & IOCB_NOWAIT);\n\tunsigned int bdp_flags = (nowait ? BDP_ASYNC : 0);\n\n\tif (nowait)\n\t\tilock_flags |= BTRFS_ILOCK_TRY;\n\n\tret = btrfs_inode_lock(BTRFS_I(inode), ilock_flags);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = generic_write_checks(iocb, i);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tret = btrfs_write_check(iocb, i, ret);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tpos = iocb->ki_pos;\n\tnrptrs = min(DIV_ROUND_UP(iov_iter_count(i), PAGE_SIZE),\n\t\t\tPAGE_SIZE / (sizeof(struct page *)));\n\tnrptrs = min(nrptrs, current->nr_dirtied_pause - current->nr_dirtied);\n\tnrptrs = max(nrptrs, 8);\n\tpages = kmalloc_array(nrptrs, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twhile (iov_iter_count(i) > 0) {\n\t\tstruct extent_state *cached_state = NULL;\n\t\tsize_t offset = offset_in_page(pos);\n\t\tsize_t sector_offset;\n\t\tsize_t write_bytes = min(iov_iter_count(i),\n\t\t\t\t\t nrptrs * (size_t)PAGE_SIZE -\n\t\t\t\t\t offset);\n\t\tsize_t num_pages;\n\t\tsize_t reserve_bytes;\n\t\tsize_t dirty_pages;\n\t\tsize_t copied;\n\t\tsize_t dirty_sectors;\n\t\tsize_t num_sectors;\n\t\tint extents_locked;\n\n\t\t \n\t\tif (unlikely(fault_in_iov_iter_readable(i, write_bytes))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tonly_release_metadata = false;\n\t\tsector_offset = pos & (fs_info->sectorsize - 1);\n\n\t\textent_changeset_release(data_reserved);\n\t\tret = btrfs_check_data_free_space(BTRFS_I(inode),\n\t\t\t\t\t\t  &data_reserved, pos,\n\t\t\t\t\t\t  write_bytes, nowait);\n\t\tif (ret < 0) {\n\t\t\tint can_nocow;\n\n\t\t\tif (nowait && (ret == -ENOSPC || ret == -EAGAIN)) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tcan_nocow = btrfs_check_nocow_lock(BTRFS_I(inode), pos,\n\t\t\t\t\t\t\t   &write_bytes, nowait);\n\t\t\tif (can_nocow < 0)\n\t\t\t\tret = can_nocow;\n\t\t\tif (can_nocow > 0)\n\t\t\t\tret = 0;\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tonly_release_metadata = true;\n\t\t}\n\n\t\tnum_pages = DIV_ROUND_UP(write_bytes + offset, PAGE_SIZE);\n\t\tWARN_ON(num_pages > nrptrs);\n\t\treserve_bytes = round_up(write_bytes + sector_offset,\n\t\t\t\t\t fs_info->sectorsize);\n\t\tWARN_ON(reserve_bytes == 0);\n\t\tret = btrfs_delalloc_reserve_metadata(BTRFS_I(inode),\n\t\t\t\t\t\t      reserve_bytes,\n\t\t\t\t\t\t      reserve_bytes, nowait);\n\t\tif (ret) {\n\t\t\tif (!only_release_metadata)\n\t\t\t\tbtrfs_free_reserved_data_space(BTRFS_I(inode),\n\t\t\t\t\t\tdata_reserved, pos,\n\t\t\t\t\t\twrite_bytes);\n\t\t\telse\n\t\t\t\tbtrfs_check_nocow_unlock(BTRFS_I(inode));\n\n\t\t\tif (nowait && ret == -ENOSPC)\n\t\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_bytes = reserve_bytes;\nagain:\n\t\tret = balance_dirty_pages_ratelimited_flags(inode->i_mapping, bdp_flags);\n\t\tif (ret) {\n\t\t\tbtrfs_delalloc_release_extents(BTRFS_I(inode), reserve_bytes);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tret = prepare_pages(inode, pages, num_pages,\n\t\t\t\t    pos, write_bytes, force_page_uptodate, false);\n\t\tif (ret) {\n\t\t\tbtrfs_delalloc_release_extents(BTRFS_I(inode),\n\t\t\t\t\t\t       reserve_bytes);\n\t\t\tbreak;\n\t\t}\n\n\t\textents_locked = lock_and_cleanup_extent_if_need(\n\t\t\t\tBTRFS_I(inode), pages,\n\t\t\t\tnum_pages, pos, write_bytes, &lockstart,\n\t\t\t\t&lockend, nowait, &cached_state);\n\t\tif (extents_locked < 0) {\n\t\t\tif (!nowait && extents_locked == -EAGAIN)\n\t\t\t\tgoto again;\n\n\t\t\tbtrfs_delalloc_release_extents(BTRFS_I(inode),\n\t\t\t\t\t\t       reserve_bytes);\n\t\t\tret = extents_locked;\n\t\t\tbreak;\n\t\t}\n\n\t\tcopied = btrfs_copy_from_user(pos, write_bytes, pages, i);\n\n\t\tnum_sectors = BTRFS_BYTES_TO_BLKS(fs_info, reserve_bytes);\n\t\tdirty_sectors = round_up(copied + sector_offset,\n\t\t\t\t\tfs_info->sectorsize);\n\t\tdirty_sectors = BTRFS_BYTES_TO_BLKS(fs_info, dirty_sectors);\n\n\t\t \n\t\tif (copied < write_bytes)\n\t\t\tnrptrs = 1;\n\n\t\tif (copied == 0) {\n\t\t\tforce_page_uptodate = true;\n\t\t\tdirty_sectors = 0;\n\t\t\tdirty_pages = 0;\n\t\t} else {\n\t\t\tforce_page_uptodate = false;\n\t\t\tdirty_pages = DIV_ROUND_UP(copied + offset,\n\t\t\t\t\t\t   PAGE_SIZE);\n\t\t}\n\n\t\tif (num_sectors > dirty_sectors) {\n\t\t\t \n\t\t\trelease_bytes -= dirty_sectors << fs_info->sectorsize_bits;\n\t\t\tif (only_release_metadata) {\n\t\t\t\tbtrfs_delalloc_release_metadata(BTRFS_I(inode),\n\t\t\t\t\t\t\trelease_bytes, true);\n\t\t\t} else {\n\t\t\t\tu64 __pos;\n\n\t\t\t\t__pos = round_down(pos,\n\t\t\t\t\t\t   fs_info->sectorsize) +\n\t\t\t\t\t(dirty_pages << PAGE_SHIFT);\n\t\t\t\tbtrfs_delalloc_release_space(BTRFS_I(inode),\n\t\t\t\t\t\tdata_reserved, __pos,\n\t\t\t\t\t\trelease_bytes, true);\n\t\t\t}\n\t\t}\n\n\t\trelease_bytes = round_up(copied + sector_offset,\n\t\t\t\t\tfs_info->sectorsize);\n\n\t\tret = btrfs_dirty_pages(BTRFS_I(inode), pages,\n\t\t\t\t\tdirty_pages, pos, copied,\n\t\t\t\t\t&cached_state, only_release_metadata);\n\n\t\t \n\t\tif (extents_locked)\n\t\t\tunlock_extent(&BTRFS_I(inode)->io_tree, lockstart,\n\t\t\t\t      lockend, &cached_state);\n\t\telse\n\t\t\tfree_extent_state(cached_state);\n\n\t\tbtrfs_delalloc_release_extents(BTRFS_I(inode), reserve_bytes);\n\t\tif (ret) {\n\t\t\tbtrfs_drop_pages(fs_info, pages, num_pages, pos, copied);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_bytes = 0;\n\t\tif (only_release_metadata)\n\t\t\tbtrfs_check_nocow_unlock(BTRFS_I(inode));\n\n\t\tbtrfs_drop_pages(fs_info, pages, num_pages, pos, copied);\n\n\t\tcond_resched();\n\n\t\tpos += copied;\n\t\tnum_written += copied;\n\t}\n\n\tkfree(pages);\n\n\tif (release_bytes) {\n\t\tif (only_release_metadata) {\n\t\t\tbtrfs_check_nocow_unlock(BTRFS_I(inode));\n\t\t\tbtrfs_delalloc_release_metadata(BTRFS_I(inode),\n\t\t\t\t\trelease_bytes, true);\n\t\t} else {\n\t\t\tbtrfs_delalloc_release_space(BTRFS_I(inode),\n\t\t\t\t\tdata_reserved,\n\t\t\t\t\tround_down(pos, fs_info->sectorsize),\n\t\t\t\t\trelease_bytes, true);\n\t\t}\n\t}\n\n\textent_changeset_free(data_reserved);\n\tif (num_written > 0) {\n\t\tpagecache_isize_extended(inode, old_isize, iocb->ki_pos);\n\t\tiocb->ki_pos += num_written;\n\t}\nout:\n\tbtrfs_inode_unlock(BTRFS_I(inode), ilock_flags);\n\treturn num_written ? num_written : ret;\n}\n\nstatic ssize_t check_direct_IO(struct btrfs_fs_info *fs_info,\n\t\t\t       const struct iov_iter *iter, loff_t offset)\n{\n\tconst u32 blocksize_mask = fs_info->sectorsize - 1;\n\n\tif (offset & blocksize_mask)\n\t\treturn -EINVAL;\n\n\tif (iov_iter_alignment(iter) & blocksize_mask)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic ssize_t btrfs_direct_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tloff_t pos;\n\tssize_t written = 0;\n\tssize_t written_buffered;\n\tsize_t prev_left = 0;\n\tloff_t endbyte;\n\tssize_t err;\n\tunsigned int ilock_flags = 0;\n\tstruct iomap_dio *dio;\n\n\tif (iocb->ki_flags & IOCB_NOWAIT)\n\t\tilock_flags |= BTRFS_ILOCK_TRY;\n\n\t \n\tif (iocb->ki_pos + iov_iter_count(from) <= i_size_read(inode) && IS_NOSEC(inode))\n\t\tilock_flags |= BTRFS_ILOCK_SHARED;\n\nrelock:\n\terr = btrfs_inode_lock(BTRFS_I(inode), ilock_flags);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif ((ilock_flags & BTRFS_ILOCK_SHARED) && !IS_NOSEC(inode)) {\n\t\tbtrfs_inode_unlock(BTRFS_I(inode), ilock_flags);\n\t\tilock_flags &= ~BTRFS_ILOCK_SHARED;\n\t\tgoto relock;\n\t}\n\n\terr = generic_write_checks(iocb, from);\n\tif (err <= 0) {\n\t\tbtrfs_inode_unlock(BTRFS_I(inode), ilock_flags);\n\t\treturn err;\n\t}\n\n\terr = btrfs_write_check(iocb, from, err);\n\tif (err < 0) {\n\t\tbtrfs_inode_unlock(BTRFS_I(inode), ilock_flags);\n\t\tgoto out;\n\t}\n\n\tpos = iocb->ki_pos;\n\t \n\tif ((ilock_flags & BTRFS_ILOCK_SHARED) &&\n\t    pos + iov_iter_count(from) > i_size_read(inode)) {\n\t\tbtrfs_inode_unlock(BTRFS_I(inode), ilock_flags);\n\t\tilock_flags &= ~BTRFS_ILOCK_SHARED;\n\t\tgoto relock;\n\t}\n\n\tif (check_direct_IO(fs_info, from, pos)) {\n\t\tbtrfs_inode_unlock(BTRFS_I(inode), ilock_flags);\n\t\tgoto buffered;\n\t}\n\n\t \n\tfrom->nofault = true;\n\tdio = btrfs_dio_write(iocb, from, written);\n\tfrom->nofault = false;\n\n\t \n\tbtrfs_inode_unlock(BTRFS_I(inode), ilock_flags);\n\n\tif (IS_ERR_OR_NULL(dio))\n\t\terr = PTR_ERR_OR_ZERO(dio);\n\telse\n\t\terr = iomap_dio_complete(dio);\n\n\t \n\tif (err > 0)\n\t\twritten = err;\n\n\tif (iov_iter_count(from) > 0 && (err == -EFAULT || err > 0)) {\n\t\tconst size_t left = iov_iter_count(from);\n\t\t \n\t\tif (left == prev_left) {\n\t\t\terr = -ENOTBLK;\n\t\t} else {\n\t\t\tfault_in_iov_iter_readable(from, left);\n\t\t\tprev_left = left;\n\t\t\tgoto relock;\n\t\t}\n\t}\n\n\t \n\tif ((err < 0 && err != -ENOTBLK) || !iov_iter_count(from))\n\t\tgoto out;\n\nbuffered:\n\t \n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tpos = iocb->ki_pos;\n\twritten_buffered = btrfs_buffered_write(iocb, from);\n\tif (written_buffered < 0) {\n\t\terr = written_buffered;\n\t\tgoto out;\n\t}\n\t \n\tendbyte = pos + written_buffered - 1;\n\terr = btrfs_fdatawrite_range(inode, pos, endbyte);\n\tif (err)\n\t\tgoto out;\n\terr = filemap_fdatawait_range(inode->i_mapping, pos, endbyte);\n\tif (err)\n\t\tgoto out;\n\twritten += written_buffered;\n\tiocb->ki_pos = pos + written_buffered;\n\tinvalidate_mapping_pages(file->f_mapping, pos >> PAGE_SHIFT,\n\t\t\t\t endbyte >> PAGE_SHIFT);\nout:\n\treturn err < 0 ? err : written;\n}\n\nstatic ssize_t btrfs_encoded_write(struct kiocb *iocb, struct iov_iter *from,\n\t\t\tconst struct btrfs_ioctl_encoded_io_args *encoded)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tloff_t count;\n\tssize_t ret;\n\n\tbtrfs_inode_lock(BTRFS_I(inode), 0);\n\tcount = encoded->len;\n\tret = generic_write_checks_count(iocb, &count);\n\tif (ret == 0 && count != encoded->len) {\n\t\t \n\t\tret = -EFBIG;\n\t}\n\tif (ret || encoded->len == 0)\n\t\tgoto out;\n\n\tret = btrfs_write_check(iocb, from, encoded->len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = btrfs_do_encoded_write(iocb, from, encoded);\nout:\n\tbtrfs_inode_unlock(BTRFS_I(inode), 0);\n\treturn ret;\n}\n\nssize_t btrfs_do_write_iter(struct kiocb *iocb, struct iov_iter *from,\n\t\t\t    const struct btrfs_ioctl_encoded_io_args *encoded)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct btrfs_inode *inode = BTRFS_I(file_inode(file));\n\tssize_t num_written, num_sync;\n\n\t \n\tif (BTRFS_FS_ERROR(inode->root->fs_info))\n\t\treturn -EROFS;\n\n\tif (encoded && (iocb->ki_flags & IOCB_NOWAIT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (encoded) {\n\t\tnum_written = btrfs_encoded_write(iocb, from, encoded);\n\t\tnum_sync = encoded->len;\n\t} else if (iocb->ki_flags & IOCB_DIRECT) {\n\t\tnum_written = btrfs_direct_write(iocb, from);\n\t\tnum_sync = num_written;\n\t} else {\n\t\tnum_written = btrfs_buffered_write(iocb, from);\n\t\tnum_sync = num_written;\n\t}\n\n\tbtrfs_set_inode_last_sub_trans(inode);\n\n\tif (num_sync > 0) {\n\t\tnum_sync = generic_write_sync(iocb, num_sync);\n\t\tif (num_sync < 0)\n\t\t\tnum_written = num_sync;\n\t}\n\n\treturn num_written;\n}\n\nstatic ssize_t btrfs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\treturn btrfs_do_write_iter(iocb, from, NULL);\n}\n\nint btrfs_release_file(struct inode *inode, struct file *filp)\n{\n\tstruct btrfs_file_private *private = filp->private_data;\n\n\tif (private) {\n\t\tkfree(private->filldir_buf);\n\t\tfree_extent_state(private->llseek_cached_state);\n\t\tkfree(private);\n\t\tfilp->private_data = NULL;\n\t}\n\n\t \n\tif (test_and_clear_bit(BTRFS_INODE_FLUSH_ON_CLOSE,\n\t\t\t       &BTRFS_I(inode)->runtime_flags))\n\t\t\tfilemap_flush(inode->i_mapping);\n\treturn 0;\n}\n\nstatic int start_ordered_ops(struct inode *inode, loff_t start, loff_t end)\n{\n\tint ret;\n\tstruct blk_plug plug;\n\n\t \n\tblk_start_plug(&plug);\n\tret = btrfs_fdatawrite_range(inode, start, end);\n\tblk_finish_plug(&plug);\n\n\treturn ret;\n}\n\nstatic inline bool skip_inode_logging(const struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_inode *inode = BTRFS_I(ctx->inode);\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\n\tif (btrfs_inode_in_log(inode, fs_info->generation) &&\n\t    list_empty(&ctx->ordered_extents))\n\t\treturn true;\n\n\t \n\tif (inode->last_trans <= fs_info->last_trans_committed &&\n\t    (test_bit(BTRFS_INODE_NEEDS_FULL_SYNC, &inode->runtime_flags) ||\n\t     list_empty(&ctx->ordered_extents)))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nint btrfs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct dentry *dentry = file_dentry(file);\n\tstruct inode *inode = d_inode(dentry);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_log_ctx ctx;\n\tint ret = 0, err;\n\tu64 len;\n\tbool full_sync;\n\n\ttrace_btrfs_sync_file(file, datasync);\n\n\tbtrfs_init_log_ctx(&ctx, inode);\n\n\t \n\tstart = 0;\n\tend = LLONG_MAX;\n\tlen = (u64)LLONG_MAX + 1;\n\n\t \n\tret = start_ordered_ops(inode, start, end);\n\tif (ret)\n\t\tgoto out;\n\n\tbtrfs_inode_lock(BTRFS_I(inode), BTRFS_ILOCK_MMAP);\n\n\tatomic_inc(&root->log_batch);\n\n\t \n\tret = start_ordered_ops(inode, start, end);\n\tif (ret) {\n\t\tbtrfs_inode_unlock(BTRFS_I(inode), BTRFS_ILOCK_MMAP);\n\t\tgoto out;\n\t}\n\n\t \n\tfull_sync = test_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t     &BTRFS_I(inode)->runtime_flags);\n\n\t \n\tif (full_sync || btrfs_is_zoned(fs_info)) {\n\t\tret = btrfs_wait_ordered_range(inode, start, len);\n\t} else {\n\t\t \n\t\tbtrfs_get_ordered_extents_for_logging(BTRFS_I(inode),\n\t\t\t\t\t\t      &ctx.ordered_extents);\n\t\tret = filemap_fdatawait_range(inode->i_mapping, start, end);\n\t}\n\n\tif (ret)\n\t\tgoto out_release_extents;\n\n\tatomic_inc(&root->log_batch);\n\n\tsmp_mb();\n\tif (skip_inode_logging(&ctx)) {\n\t\t \n\t\tclear_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\t \n\t\tret = filemap_check_wb_err(inode->i_mapping, file->f_wb_err);\n\t\tgoto out_release_extents;\n\t}\n\n\t \n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_release_extents;\n\t}\n\ttrans->in_fsync = true;\n\n\tret = btrfs_log_dentry_safe(trans, dentry, &ctx);\n\tbtrfs_release_log_ctx_extents(&ctx);\n\tif (ret < 0) {\n\t\t \n\t\tret = BTRFS_LOG_FORCE_COMMIT;\n\t}\n\n\t \n\tbtrfs_inode_unlock(BTRFS_I(inode), BTRFS_ILOCK_MMAP);\n\n\tif (ret == BTRFS_NO_LOG_SYNC) {\n\t\tret = btrfs_end_transaction(trans);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!ret) {\n\t\tret = btrfs_sync_log(trans, root, &ctx);\n\t\tif (!ret) {\n\t\t\tret = btrfs_end_transaction(trans);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (!full_sync) {\n\t\tret = btrfs_end_transaction(trans);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = btrfs_wait_ordered_range(inode, start, len);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t \n\t\ttrans = btrfs_attach_transaction_barrier(root);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\n\t\t\t \n\t\t\tif (ret == -ENOENT)\n\t\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = btrfs_commit_transaction(trans);\nout:\n\tASSERT(list_empty(&ctx.list));\n\tASSERT(list_empty(&ctx.conflict_inodes));\n\terr = file_check_and_advance_wb_err(file);\n\tif (!ret)\n\t\tret = err;\n\treturn ret > 0 ? -EIO : ret;\n\nout_release_extents:\n\tbtrfs_release_log_ctx_extents(&ctx);\n\tbtrfs_inode_unlock(BTRFS_I(inode), BTRFS_ILOCK_MMAP);\n\tgoto out;\n}\n\nstatic const struct vm_operations_struct btrfs_file_vm_ops = {\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= btrfs_page_mkwrite,\n};\n\nstatic int btrfs_file_mmap(struct file\t*filp, struct vm_area_struct *vma)\n{\n\tstruct address_space *mapping = filp->f_mapping;\n\n\tif (!mapping->a_ops->read_folio)\n\t\treturn -ENOEXEC;\n\n\tfile_accessed(filp);\n\tvma->vm_ops = &btrfs_file_vm_ops;\n\n\treturn 0;\n}\n\nstatic int hole_mergeable(struct btrfs_inode *inode, struct extent_buffer *leaf,\n\t\t\t  int slot, u64 start, u64 end)\n{\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\n\tif (slot < 0 || slot >= btrfs_header_nritems(leaf))\n\t\treturn 0;\n\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\tif (key.objectid != btrfs_ino(inode) ||\n\t    key.type != BTRFS_EXTENT_DATA_KEY)\n\t\treturn 0;\n\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\n\tif (btrfs_file_extent_type(leaf, fi) != BTRFS_FILE_EXTENT_REG)\n\t\treturn 0;\n\n\tif (btrfs_file_extent_disk_bytenr(leaf, fi))\n\t\treturn 0;\n\n\tif (key.offset == end)\n\t\treturn 1;\n\tif (key.offset + btrfs_file_extent_num_bytes(leaf, fi) == start)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int fill_holes(struct btrfs_trans_handle *trans,\n\t\tstruct btrfs_inode *inode,\n\t\tstruct btrfs_path *path, u64 offset, u64 end)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_root *root = inode->root;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_map *hole_em;\n\tstruct btrfs_key key;\n\tint ret;\n\n\tif (btrfs_fs_incompat(fs_info, NO_HOLES))\n\t\tgoto out;\n\n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = offset;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret <= 0) {\n\t\t \n\t\tif (ret == 0)\n\t\t\tret = -EINVAL;\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\tif (hole_mergeable(inode, leaf, path->slots[0] - 1, offset, end)) {\n\t\tu64 num_bytes;\n\n\t\tpath->slots[0]--;\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tnum_bytes = btrfs_file_extent_num_bytes(leaf, fi) +\n\t\t\tend - offset;\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_offset(leaf, fi, 0);\n\t\tbtrfs_set_file_extent_generation(leaf, fi, trans->transid);\n\t\tbtrfs_mark_buffer_dirty(trans, leaf);\n\t\tgoto out;\n\t}\n\n\tif (hole_mergeable(inode, leaf, path->slots[0], offset, end)) {\n\t\tu64 num_bytes;\n\n\t\tkey.offset = offset;\n\t\tbtrfs_set_item_key_safe(trans, path, &key);\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tnum_bytes = btrfs_file_extent_num_bytes(leaf, fi) + end -\n\t\t\toffset;\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_offset(leaf, fi, 0);\n\t\tbtrfs_set_file_extent_generation(leaf, fi, trans->transid);\n\t\tbtrfs_mark_buffer_dirty(trans, leaf);\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\n\tret = btrfs_insert_hole_extent(trans, root, btrfs_ino(inode), offset,\n\t\t\t\t       end - offset);\n\tif (ret)\n\t\treturn ret;\n\nout:\n\tbtrfs_release_path(path);\n\n\thole_em = alloc_extent_map();\n\tif (!hole_em) {\n\t\tbtrfs_drop_extent_map_range(inode, offset, end - 1, false);\n\t\tbtrfs_set_inode_full_sync(inode);\n\t} else {\n\t\thole_em->start = offset;\n\t\thole_em->len = end - offset;\n\t\thole_em->ram_bytes = hole_em->len;\n\t\thole_em->orig_start = offset;\n\n\t\thole_em->block_start = EXTENT_MAP_HOLE;\n\t\thole_em->block_len = 0;\n\t\thole_em->orig_block_len = 0;\n\t\thole_em->compress_type = BTRFS_COMPRESS_NONE;\n\t\thole_em->generation = trans->transid;\n\n\t\tret = btrfs_replace_extent_map_range(inode, hole_em, true);\n\t\tfree_extent_map(hole_em);\n\t\tif (ret)\n\t\t\tbtrfs_set_inode_full_sync(inode);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int find_first_non_hole(struct btrfs_inode *inode, u64 *start, u64 *len)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tstruct extent_map *em;\n\tint ret = 0;\n\n\tem = btrfs_get_extent(inode, NULL, 0,\n\t\t\t      round_down(*start, fs_info->sectorsize),\n\t\t\t      round_up(*len, fs_info->sectorsize));\n\tif (IS_ERR(em))\n\t\treturn PTR_ERR(em);\n\n\t \n\tif (em->block_start == EXTENT_MAP_HOLE) {\n\t\tret = 1;\n\t\t*len = em->start + em->len > *start + *len ?\n\t\t       0 : *start + *len - em->start - em->len;\n\t\t*start = em->start + em->len;\n\t}\n\tfree_extent_map(em);\n\treturn ret;\n}\n\nstatic void btrfs_punch_hole_lock_range(struct inode *inode,\n\t\t\t\t\tconst u64 lockstart,\n\t\t\t\t\tconst u64 lockend,\n\t\t\t\t\tstruct extent_state **cached_state)\n{\n\t \n\tconst u64 page_lockstart = round_up(lockstart, PAGE_SIZE);\n\tconst u64 page_lockend = round_down(lockend + 1, PAGE_SIZE) - 1;\n\n\twhile (1) {\n\t\ttruncate_pagecache_range(inode, lockstart, lockend);\n\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t\t    cached_state);\n\t\t \n\t\tif (!filemap_range_has_page(inode->i_mapping, page_lockstart,\n\t\t\t\t\t    page_lockend))\n\t\t\tbreak;\n\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t\t      cached_state);\n\t}\n\n\tbtrfs_assert_inode_range_clean(BTRFS_I(inode), lockstart, lockend);\n}\n\nstatic int btrfs_insert_replace_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_inode *inode,\n\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t     struct btrfs_replace_extent_info *extent_info,\n\t\t\t\t     const u64 replace_len,\n\t\t\t\t     const u64 bytes_to_drop)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_file_extent_item *extent;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tint slot;\n\tstruct btrfs_ref ref = { 0 };\n\tint ret;\n\n\tif (replace_len == 0)\n\t\treturn 0;\n\n\tif (extent_info->disk_offset == 0 &&\n\t    btrfs_fs_incompat(fs_info, NO_HOLES)) {\n\t\tbtrfs_update_inode_bytes(inode, 0, bytes_to_drop);\n\t\treturn 0;\n\t}\n\n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = extent_info->file_offset;\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(struct btrfs_file_extent_item));\n\tif (ret)\n\t\treturn ret;\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\twrite_extent_buffer(leaf, extent_info->extent_buf,\n\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t    sizeof(struct btrfs_file_extent_item));\n\textent = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tASSERT(btrfs_file_extent_type(leaf, extent) != BTRFS_FILE_EXTENT_INLINE);\n\tbtrfs_set_file_extent_offset(leaf, extent, extent_info->data_offset);\n\tbtrfs_set_file_extent_num_bytes(leaf, extent, replace_len);\n\tif (extent_info->is_new_extent)\n\t\tbtrfs_set_file_extent_generation(leaf, extent, trans->transid);\n\tbtrfs_mark_buffer_dirty(trans, leaf);\n\tbtrfs_release_path(path);\n\n\tret = btrfs_inode_set_file_extent_range(inode, extent_info->file_offset,\n\t\t\t\t\t\treplace_len);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (extent_info->disk_offset == 0) {\n\t\tbtrfs_update_inode_bytes(inode, 0, bytes_to_drop);\n\t\treturn 0;\n\t}\n\n\tbtrfs_update_inode_bytes(inode, replace_len, bytes_to_drop);\n\n\tif (extent_info->is_new_extent && extent_info->insertions == 0) {\n\t\tkey.objectid = extent_info->disk_offset;\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.offset = extent_info->disk_len;\n\t\tret = btrfs_alloc_reserved_file_extent(trans, root,\n\t\t\t\t\t\t       btrfs_ino(inode),\n\t\t\t\t\t\t       extent_info->file_offset,\n\t\t\t\t\t\t       extent_info->qgroup_reserved,\n\t\t\t\t\t\t       &key);\n\t} else {\n\t\tu64 ref_offset;\n\n\t\tbtrfs_init_generic_ref(&ref, BTRFS_ADD_DELAYED_REF,\n\t\t\t\t       extent_info->disk_offset,\n\t\t\t\t       extent_info->disk_len, 0);\n\t\tref_offset = extent_info->file_offset - extent_info->data_offset;\n\t\tbtrfs_init_data_ref(&ref, root->root_key.objectid,\n\t\t\t\t    btrfs_ino(inode), ref_offset, 0, false);\n\t\tret = btrfs_inc_extent_ref(trans, &ref);\n\t}\n\n\textent_info->insertions++;\n\n\treturn ret;\n}\n\n \nint btrfs_replace_file_extents(struct btrfs_inode *inode,\n\t\t\t       struct btrfs_path *path, const u64 start,\n\t\t\t       const u64 end,\n\t\t\t       struct btrfs_replace_extent_info *extent_info,\n\t\t\t       struct btrfs_trans_handle **trans_out)\n{\n\tstruct btrfs_drop_extents_args drop_args = { 0 };\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 min_size = btrfs_calc_insert_metadata_size(fs_info, 1);\n\tu64 ino_size = round_up(inode->vfs_inode.i_size, fs_info->sectorsize);\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_block_rsv *rsv;\n\tunsigned int rsv_count;\n\tu64 cur_offset;\n\tu64 len = end - start;\n\tint ret = 0;\n\n\tif (end <= start)\n\t\treturn -EINVAL;\n\n\trsv = btrfs_alloc_block_rsv(fs_info, BTRFS_BLOCK_RSV_TEMP);\n\tif (!rsv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\trsv->size = btrfs_calc_insert_metadata_size(fs_info, 1);\n\trsv->failfast = true;\n\n\t \n\tif (!btrfs_fs_incompat(fs_info, NO_HOLES) || extent_info)\n\t\trsv_count = 3;\n\telse\n\t\trsv_count = 2;\n\n\ttrans = btrfs_start_transaction(root, rsv_count);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\ttrans = NULL;\n\t\tgoto out_free;\n\t}\n\n\tret = btrfs_block_rsv_migrate(&fs_info->trans_block_rsv, rsv,\n\t\t\t\t      min_size, false);\n\tif (WARN_ON(ret))\n\t\tgoto out_trans;\n\ttrans->block_rsv = rsv;\n\n\tcur_offset = start;\n\tdrop_args.path = path;\n\tdrop_args.end = end + 1;\n\tdrop_args.drop_cache = true;\n\twhile (cur_offset < end) {\n\t\tdrop_args.start = cur_offset;\n\t\tret = btrfs_drop_extents(trans, root, inode, &drop_args);\n\t\t \n\t\tif (!extent_info)\n\t\t\tbtrfs_update_inode_bytes(inode, 0,\n\t\t\t\t\t\t drop_args.bytes_found);\n\t\tif (ret != -ENOSPC) {\n\t\t\t \n\t\t\tif (ret &&\n\t\t\t    (ret != -EOPNOTSUPP ||\n\t\t\t     (extent_info && extent_info->is_new_extent)))\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\ttrans->block_rsv = &fs_info->trans_block_rsv;\n\n\t\tif (!extent_info && cur_offset < drop_args.drop_end &&\n\t\t    cur_offset < ino_size) {\n\t\t\tret = fill_holes(trans, inode, path, cur_offset,\n\t\t\t\t\t drop_args.drop_end);\n\t\t\tif (ret) {\n\t\t\t\t \n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!extent_info && cur_offset < drop_args.drop_end) {\n\t\t\t \n\t\t\tret = btrfs_inode_clear_file_extent_range(inode,\n\t\t\t\t\tcur_offset,\n\t\t\t\t\tdrop_args.drop_end - cur_offset);\n\t\t\tif (ret) {\n\t\t\t\t \n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (extent_info &&\n\t\t    drop_args.drop_end > extent_info->file_offset) {\n\t\t\tu64 replace_len = drop_args.drop_end -\n\t\t\t\t\t  extent_info->file_offset;\n\n\t\t\tret = btrfs_insert_replace_extent(trans, inode,\tpath,\n\t\t\t\t\textent_info, replace_len,\n\t\t\t\t\tdrop_args.bytes_found);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\textent_info->data_len -= replace_len;\n\t\t\textent_info->data_offset += replace_len;\n\t\t\textent_info->file_offset += replace_len;\n\t\t}\n\n\t\t \n\t\tinode_inc_iversion(&inode->vfs_inode);\n\n\t\tif (!extent_info || extent_info->update_times)\n\t\t\tinode->vfs_inode.i_mtime = inode_set_ctime_current(&inode->vfs_inode);\n\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tbtrfs_end_transaction(trans);\n\t\tbtrfs_btree_balance_dirty(fs_info);\n\n\t\ttrans = btrfs_start_transaction(root, rsv_count);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = btrfs_block_rsv_migrate(&fs_info->trans_block_rsv,\n\t\t\t\t\t      rsv, min_size, false);\n\t\tif (WARN_ON(ret))\n\t\t\tbreak;\n\t\ttrans->block_rsv = rsv;\n\n\t\tcur_offset = drop_args.drop_end;\n\t\tlen = end - cur_offset;\n\t\tif (!extent_info && len) {\n\t\t\tret = find_first_non_hole(inode, &cur_offset, &len);\n\t\t\tif (unlikely(ret < 0))\n\t\t\t\tbreak;\n\t\t\tif (ret && !len) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (extent_info && !extent_info->is_new_extent)\n\t\tbtrfs_set_inode_full_sync(inode);\n\n\tif (ret)\n\t\tgoto out_trans;\n\n\ttrans->block_rsv = &fs_info->trans_block_rsv;\n\t \n\tif (drop_args.drop_end <= end)\n\t\tdrop_args.drop_end = end + 1;\n\t \n\tif (!extent_info && cur_offset < ino_size &&\n\t    cur_offset < drop_args.drop_end) {\n\t\tret = fill_holes(trans, inode, path, cur_offset,\n\t\t\t\t drop_args.drop_end);\n\t\tif (ret) {\n\t\t\t \n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out_trans;\n\t\t}\n\t} else if (!extent_info && cur_offset < drop_args.drop_end) {\n\t\t \n\t\tret = btrfs_inode_clear_file_extent_range(inode, cur_offset,\n\t\t\t\t\tdrop_args.drop_end - cur_offset);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out_trans;\n\t\t}\n\n\t}\n\tif (extent_info) {\n\t\tret = btrfs_insert_replace_extent(trans, inode, path,\n\t\t\t\textent_info, extent_info->data_len,\n\t\t\t\tdrop_args.bytes_found);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out_trans;\n\t\t}\n\t}\n\nout_trans:\n\tif (!trans)\n\t\tgoto out_free;\n\n\ttrans->block_rsv = &fs_info->trans_block_rsv;\n\tif (ret)\n\t\tbtrfs_end_transaction(trans);\n\telse\n\t\t*trans_out = trans;\nout_free:\n\tbtrfs_free_block_rsv(fs_info, rsv);\nout:\n\treturn ret;\n}\n\nstatic int btrfs_punch_hole(struct file *file, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_state *cached_state = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tu64 lockstart;\n\tu64 lockend;\n\tu64 tail_start;\n\tu64 tail_len;\n\tu64 orig_start = offset;\n\tint ret = 0;\n\tbool same_block;\n\tu64 ino_size;\n\tbool truncated_block = false;\n\tbool updated_inode = false;\n\n\tbtrfs_inode_lock(BTRFS_I(inode), BTRFS_ILOCK_MMAP);\n\n\tret = btrfs_wait_ordered_range(inode, offset, len);\n\tif (ret)\n\t\tgoto out_only_mutex;\n\n\tino_size = round_up(inode->i_size, fs_info->sectorsize);\n\tret = find_first_non_hole(BTRFS_I(inode), &offset, &len);\n\tif (ret < 0)\n\t\tgoto out_only_mutex;\n\tif (ret && !len) {\n\t\t \n\t\tret = 0;\n\t\tgoto out_only_mutex;\n\t}\n\n\tret = file_modified(file);\n\tif (ret)\n\t\tgoto out_only_mutex;\n\n\tlockstart = round_up(offset, fs_info->sectorsize);\n\tlockend = round_down(offset + len, fs_info->sectorsize) - 1;\n\tsame_block = (BTRFS_BYTES_TO_BLKS(fs_info, offset))\n\t\t== (BTRFS_BYTES_TO_BLKS(fs_info, offset + len - 1));\n\t \n\t \n\tif (same_block && len < fs_info->sectorsize) {\n\t\tif (offset < ino_size) {\n\t\t\ttruncated_block = true;\n\t\t\tret = btrfs_truncate_block(BTRFS_I(inode), offset, len,\n\t\t\t\t\t\t   0);\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t\tgoto out_only_mutex;\n\t}\n\n\t \n\tif (offset < ino_size) {\n\t\ttruncated_block = true;\n\t\tret = btrfs_truncate_block(BTRFS_I(inode), offset, 0, 0);\n\t\tif (ret) {\n\t\t\tbtrfs_inode_unlock(BTRFS_I(inode), BTRFS_ILOCK_MMAP);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (offset == orig_start) {\n\t\t \n\t\tlen = offset + len - lockstart;\n\t\toffset = lockstart;\n\t\tret = find_first_non_hole(BTRFS_I(inode), &offset, &len);\n\t\tif (ret < 0)\n\t\t\tgoto out_only_mutex;\n\t\tif (ret && !len) {\n\t\t\tret = 0;\n\t\t\tgoto out_only_mutex;\n\t\t}\n\t\tlockstart = offset;\n\t}\n\n\t \n\ttail_start = lockend + 1;\n\ttail_len = offset + len - tail_start;\n\tif (tail_len) {\n\t\tret = find_first_non_hole(BTRFS_I(inode), &tail_start, &tail_len);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto out_only_mutex;\n\t\tif (!ret) {\n\t\t\t \n\t\t\tif (tail_start + tail_len < ino_size) {\n\t\t\t\ttruncated_block = true;\n\t\t\t\tret = btrfs_truncate_block(BTRFS_I(inode),\n\t\t\t\t\t\t\ttail_start + tail_len,\n\t\t\t\t\t\t\t0, 1);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_only_mutex;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lockend < lockstart) {\n\t\tret = 0;\n\t\tgoto out_only_mutex;\n\t}\n\n\tbtrfs_punch_hole_lock_range(inode, lockstart, lockend, &cached_state);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_replace_file_extents(BTRFS_I(inode), path, lockstart,\n\t\t\t\t\t lockend, NULL, &trans);\n\tbtrfs_free_path(path);\n\tif (ret)\n\t\tgoto out;\n\n\tASSERT(trans != NULL);\n\tinode_inc_iversion(inode);\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tret = btrfs_update_inode(trans, root, BTRFS_I(inode));\n\tupdated_inode = true;\n\tbtrfs_end_transaction(trans);\n\tbtrfs_btree_balance_dirty(fs_info);\nout:\n\tunlock_extent(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t      &cached_state);\nout_only_mutex:\n\tif (!updated_inode && truncated_block && !ret) {\n\t\t \n\t\tstruct timespec64 now = inode_set_ctime_current(inode);\n\n\t\tinode_inc_iversion(inode);\n\t\tinode->i_mtime = now;\n\t\ttrans = btrfs_start_transaction(root, 1);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t} else {\n\t\t\tint ret2;\n\n\t\t\tret = btrfs_update_inode(trans, root, BTRFS_I(inode));\n\t\t\tret2 = btrfs_end_transaction(trans);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\t}\n\tbtrfs_inode_unlock(BTRFS_I(inode), BTRFS_ILOCK_MMAP);\n\treturn ret;\n}\n\n \nstruct falloc_range {\n\tstruct list_head list;\n\tu64 start;\n\tu64 len;\n};\n\n \nstatic int add_falloc_range(struct list_head *head, u64 start, u64 len)\n{\n\tstruct falloc_range *range = NULL;\n\n\tif (!list_empty(head)) {\n\t\t \n\t\trange = list_last_entry(head, struct falloc_range, list);\n\t\tif (range->start + range->len == start) {\n\t\t\trange->len += len;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\trange = kmalloc(sizeof(*range), GFP_KERNEL);\n\tif (!range)\n\t\treturn -ENOMEM;\n\trange->start = start;\n\trange->len = len;\n\tlist_add_tail(&range->list, head);\n\treturn 0;\n}\n\nstatic int btrfs_fallocate_update_isize(struct inode *inode,\n\t\t\t\t\tconst u64 end,\n\t\t\t\t\tconst int mode)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\tint ret2;\n\n\tif (mode & FALLOC_FL_KEEP_SIZE || end <= i_size_read(inode))\n\t\treturn 0;\n\n\ttrans = btrfs_start_transaction(root, 1);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tinode_set_ctime_current(inode);\n\ti_size_write(inode, end);\n\tbtrfs_inode_safe_disk_i_size_write(BTRFS_I(inode), 0);\n\tret = btrfs_update_inode(trans, root, BTRFS_I(inode));\n\tret2 = btrfs_end_transaction(trans);\n\n\treturn ret ? ret : ret2;\n}\n\nenum {\n\tRANGE_BOUNDARY_WRITTEN_EXTENT,\n\tRANGE_BOUNDARY_PREALLOC_EXTENT,\n\tRANGE_BOUNDARY_HOLE,\n};\n\nstatic int btrfs_zero_range_check_range_boundary(struct btrfs_inode *inode,\n\t\t\t\t\t\t u64 offset)\n{\n\tconst u64 sectorsize = inode->root->fs_info->sectorsize;\n\tstruct extent_map *em;\n\tint ret;\n\n\toffset = round_down(offset, sectorsize);\n\tem = btrfs_get_extent(inode, NULL, 0, offset, sectorsize);\n\tif (IS_ERR(em))\n\t\treturn PTR_ERR(em);\n\n\tif (em->block_start == EXTENT_MAP_HOLE)\n\t\tret = RANGE_BOUNDARY_HOLE;\n\telse if (test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\tret = RANGE_BOUNDARY_PREALLOC_EXTENT;\n\telse\n\t\tret = RANGE_BOUNDARY_WRITTEN_EXTENT;\n\n\tfree_extent_map(em);\n\treturn ret;\n}\n\nstatic int btrfs_zero_range(struct inode *inode,\n\t\t\t    loff_t offset,\n\t\t\t    loff_t len,\n\t\t\t    const int mode)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct extent_map *em;\n\tstruct extent_changeset *data_reserved = NULL;\n\tint ret;\n\tu64 alloc_hint = 0;\n\tconst u64 sectorsize = fs_info->sectorsize;\n\tu64 alloc_start = round_down(offset, sectorsize);\n\tu64 alloc_end = round_up(offset + len, sectorsize);\n\tu64 bytes_to_reserve = 0;\n\tbool space_reserved = false;\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, alloc_start,\n\t\t\t      alloc_end - alloc_start);\n\tif (IS_ERR(em)) {\n\t\tret = PTR_ERR(em);\n\t\tgoto out;\n\t}\n\n\t \n\tif (em->start <= alloc_start &&\n\t    test_bit(EXTENT_FLAG_PREALLOC, &em->flags)) {\n\t\tconst u64 em_end = em->start + em->len;\n\n\t\tif (em_end >= offset + len) {\n\t\t\t \n\t\t\tfree_extent_map(em);\n\t\t\tret = btrfs_fallocate_update_isize(inode, offset + len,\n\t\t\t\t\t\t\t   mode);\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\talloc_start = em_end;\n\t\tASSERT(IS_ALIGNED(alloc_start, sectorsize));\n\t\tlen = offset + len - alloc_start;\n\t\toffset = alloc_start;\n\t\talloc_hint = em->block_start + em->len;\n\t}\n\tfree_extent_map(em);\n\n\tif (BTRFS_BYTES_TO_BLKS(fs_info, offset) ==\n\t    BTRFS_BYTES_TO_BLKS(fs_info, offset + len - 1)) {\n\t\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, alloc_start,\n\t\t\t\t      sectorsize);\n\t\tif (IS_ERR(em)) {\n\t\t\tret = PTR_ERR(em);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags)) {\n\t\t\tfree_extent_map(em);\n\t\t\tret = btrfs_fallocate_update_isize(inode, offset + len,\n\t\t\t\t\t\t\t   mode);\n\t\t\tgoto out;\n\t\t}\n\t\tif (len < sectorsize && em->block_start != EXTENT_MAP_HOLE) {\n\t\t\tfree_extent_map(em);\n\t\t\tret = btrfs_truncate_block(BTRFS_I(inode), offset, len,\n\t\t\t\t\t\t   0);\n\t\t\tif (!ret)\n\t\t\t\tret = btrfs_fallocate_update_isize(inode,\n\t\t\t\t\t\t\t\t   offset + len,\n\t\t\t\t\t\t\t\t   mode);\n\t\t\treturn ret;\n\t\t}\n\t\tfree_extent_map(em);\n\t\talloc_start = round_down(offset, sectorsize);\n\t\talloc_end = alloc_start + sectorsize;\n\t\tgoto reserve_space;\n\t}\n\n\talloc_start = round_up(offset, sectorsize);\n\talloc_end = round_down(offset + len, sectorsize);\n\n\t \n\tif (!IS_ALIGNED(offset, sectorsize)) {\n\t\tret = btrfs_zero_range_check_range_boundary(BTRFS_I(inode),\n\t\t\t\t\t\t\t    offset);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret == RANGE_BOUNDARY_HOLE) {\n\t\t\talloc_start = round_down(offset, sectorsize);\n\t\t\tret = 0;\n\t\t} else if (ret == RANGE_BOUNDARY_WRITTEN_EXTENT) {\n\t\t\tret = btrfs_truncate_block(BTRFS_I(inode), offset, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tif (!IS_ALIGNED(offset + len, sectorsize)) {\n\t\tret = btrfs_zero_range_check_range_boundary(BTRFS_I(inode),\n\t\t\t\t\t\t\t    offset + len);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret == RANGE_BOUNDARY_HOLE) {\n\t\t\talloc_end = round_up(offset + len, sectorsize);\n\t\t\tret = 0;\n\t\t} else if (ret == RANGE_BOUNDARY_WRITTEN_EXTENT) {\n\t\t\tret = btrfs_truncate_block(BTRFS_I(inode), offset + len,\n\t\t\t\t\t\t   0, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t}\n\nreserve_space:\n\tif (alloc_start < alloc_end) {\n\t\tstruct extent_state *cached_state = NULL;\n\t\tconst u64 lockstart = alloc_start;\n\t\tconst u64 lockend = alloc_end - 1;\n\n\t\tbytes_to_reserve = alloc_end - alloc_start;\n\t\tret = btrfs_alloc_data_chunk_ondemand(BTRFS_I(inode),\n\t\t\t\t\t\t      bytes_to_reserve);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tspace_reserved = true;\n\t\tbtrfs_punch_hole_lock_range(inode, lockstart, lockend,\n\t\t\t\t\t    &cached_state);\n\t\tret = btrfs_qgroup_reserve_data(BTRFS_I(inode), &data_reserved,\n\t\t\t\t\t\talloc_start, bytes_to_reserve);\n\t\tif (ret) {\n\t\t\tunlock_extent(&BTRFS_I(inode)->io_tree, lockstart,\n\t\t\t\t      lockend, &cached_state);\n\t\t\tgoto out;\n\t\t}\n\t\tret = btrfs_prealloc_file_range(inode, mode, alloc_start,\n\t\t\t\t\t\talloc_end - alloc_start,\n\t\t\t\t\t\ti_blocksize(inode),\n\t\t\t\t\t\toffset + len, &alloc_hint);\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t\t      &cached_state);\n\t\t \n\t\tif (ret) {\n\t\t\tspace_reserved = false;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = btrfs_fallocate_update_isize(inode, offset + len, mode);\n out:\n\tif (ret && space_reserved)\n\t\tbtrfs_free_reserved_data_space(BTRFS_I(inode), data_reserved,\n\t\t\t\t\t       alloc_start, bytes_to_reserve);\n\textent_changeset_free(data_reserved);\n\n\treturn ret;\n}\n\nstatic long btrfs_fallocate(struct file *file, int mode,\n\t\t\t    loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_changeset *data_reserved = NULL;\n\tstruct falloc_range *range;\n\tstruct falloc_range *tmp;\n\tLIST_HEAD(reserve_list);\n\tu64 cur_offset;\n\tu64 last_byte;\n\tu64 alloc_start;\n\tu64 alloc_end;\n\tu64 alloc_hint = 0;\n\tu64 locked_end;\n\tu64 actual_end = 0;\n\tu64 data_space_needed = 0;\n\tu64 data_space_reserved = 0;\n\tu64 qgroup_reserved = 0;\n\tstruct extent_map *em;\n\tint blocksize = BTRFS_I(inode)->root->fs_info->sectorsize;\n\tint ret;\n\n\t \n\tif (btrfs_is_zoned(btrfs_sb(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\talloc_start = round_down(offset, blocksize);\n\talloc_end = round_up(offset + len, blocksize);\n\tcur_offset = alloc_start;\n\n\t \n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |\n\t\t     FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\treturn btrfs_punch_hole(file, offset, len);\n\n\tbtrfs_inode_lock(BTRFS_I(inode), BTRFS_ILOCK_MMAP);\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) && offset + len > inode->i_size) {\n\t\tret = inode_newsize_ok(inode, offset + len);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = file_modified(file);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (alloc_start > inode->i_size) {\n\t\tret = btrfs_cont_expand(BTRFS_I(inode), i_size_read(inode),\n\t\t\t\t\talloc_start);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else if (offset + len > inode->i_size) {\n\t\t \n\t\tret = btrfs_truncate_block(BTRFS_I(inode), inode->i_size, 0, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tret = btrfs_wait_ordered_range(inode, alloc_start,\n\t\t\t\t       alloc_end - alloc_start);\n\tif (ret)\n\t\tgoto out;\n\n\tif (mode & FALLOC_FL_ZERO_RANGE) {\n\t\tret = btrfs_zero_range(inode, offset, len, mode);\n\t\tbtrfs_inode_unlock(BTRFS_I(inode), BTRFS_ILOCK_MMAP);\n\t\treturn ret;\n\t}\n\n\tlocked_end = alloc_end - 1;\n\tlock_extent(&BTRFS_I(inode)->io_tree, alloc_start, locked_end,\n\t\t    &cached_state);\n\n\tbtrfs_assert_inode_range_clean(BTRFS_I(inode), alloc_start, locked_end);\n\n\t \n\twhile (cur_offset < alloc_end) {\n\t\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, cur_offset,\n\t\t\t\t      alloc_end - cur_offset);\n\t\tif (IS_ERR(em)) {\n\t\t\tret = PTR_ERR(em);\n\t\t\tbreak;\n\t\t}\n\t\tlast_byte = min(extent_map_end(em), alloc_end);\n\t\tactual_end = min_t(u64, extent_map_end(em), offset + len);\n\t\tlast_byte = ALIGN(last_byte, blocksize);\n\t\tif (em->block_start == EXTENT_MAP_HOLE ||\n\t\t    (cur_offset >= inode->i_size &&\n\t\t     !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))) {\n\t\t\tconst u64 range_len = last_byte - cur_offset;\n\n\t\t\tret = add_falloc_range(&reserve_list, cur_offset, range_len);\n\t\t\tif (ret < 0) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = btrfs_qgroup_reserve_data(BTRFS_I(inode),\n\t\t\t\t\t&data_reserved, cur_offset, range_len);\n\t\t\tif (ret < 0) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tqgroup_reserved += range_len;\n\t\t\tdata_space_needed += range_len;\n\t\t}\n\t\tfree_extent_map(em);\n\t\tcur_offset = last_byte;\n\t}\n\n\tif (!ret && data_space_needed > 0) {\n\t\t \n\t\tret = btrfs_alloc_data_chunk_ondemand(BTRFS_I(inode),\n\t\t\t\t\t\t      data_space_needed);\n\t\tif (!ret)\n\t\t\tdata_space_reserved = data_space_needed;\n\t}\n\n\t \n\tlist_for_each_entry_safe(range, tmp, &reserve_list, list) {\n\t\tif (!ret) {\n\t\t\tret = btrfs_prealloc_file_range(inode, mode,\n\t\t\t\t\trange->start,\n\t\t\t\t\trange->len, i_blocksize(inode),\n\t\t\t\t\toffset + len, &alloc_hint);\n\t\t\t \n\t\t\tdata_space_reserved -= range->len;\n\t\t\tqgroup_reserved -= range->len;\n\t\t} else if (data_space_reserved > 0) {\n\t\t\tbtrfs_free_reserved_data_space(BTRFS_I(inode),\n\t\t\t\t\t       data_reserved, range->start,\n\t\t\t\t\t       range->len);\n\t\t\tdata_space_reserved -= range->len;\n\t\t\tqgroup_reserved -= range->len;\n\t\t} else if (qgroup_reserved > 0) {\n\t\t\tbtrfs_qgroup_free_data(BTRFS_I(inode), data_reserved,\n\t\t\t\t\t       range->start, range->len, NULL);\n\t\t\tqgroup_reserved -= range->len;\n\t\t}\n\t\tlist_del(&range->list);\n\t\tkfree(range);\n\t}\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\t \n\tret = btrfs_fallocate_update_isize(inode, actual_end, mode);\nout_unlock:\n\tunlock_extent(&BTRFS_I(inode)->io_tree, alloc_start, locked_end,\n\t\t      &cached_state);\nout:\n\tbtrfs_inode_unlock(BTRFS_I(inode), BTRFS_ILOCK_MMAP);\n\textent_changeset_free(data_reserved);\n\treturn ret;\n}\n\n \nstatic bool find_delalloc_subrange(struct btrfs_inode *inode, u64 start, u64 end,\n\t\t\t\t   struct extent_state **cached_state,\n\t\t\t\t   bool *search_io_tree,\n\t\t\t\t   u64 *delalloc_start_ret, u64 *delalloc_end_ret)\n{\n\tu64 len = end + 1 - start;\n\tu64 delalloc_len = 0;\n\tstruct btrfs_ordered_extent *oe;\n\tu64 oe_start;\n\tu64 oe_end;\n\n\t \n\tif (*search_io_tree) {\n\t\tspin_lock(&inode->lock);\n\t\tif (inode->delalloc_bytes > 0) {\n\t\t\tspin_unlock(&inode->lock);\n\t\t\t*delalloc_start_ret = start;\n\t\t\tdelalloc_len = count_range_bits(&inode->io_tree,\n\t\t\t\t\t\t\tdelalloc_start_ret, end,\n\t\t\t\t\t\t\tlen, EXTENT_DELALLOC, 1,\n\t\t\t\t\t\t\tcached_state);\n\t\t} else {\n\t\t\tspin_unlock(&inode->lock);\n\t\t}\n\t}\n\n\tif (delalloc_len > 0) {\n\t\t \n\t\t*delalloc_end_ret = *delalloc_start_ret + delalloc_len - 1;\n\n\t\tif (*delalloc_start_ret == start) {\n\t\t\t \n\t\t\tif (*delalloc_end_ret == end)\n\t\t\t\treturn true;\n\t\t\t \n\t\t\tstart = *delalloc_end_ret + 1;\n\t\t\tlen = end + 1 - start;\n\t\t}\n\t} else {\n\t\t \n\t\t*search_io_tree = false;\n\t}\n\n\t \n\toe = btrfs_lookup_first_ordered_range(inode, start, len);\n\tif (!oe)\n\t\treturn (delalloc_len > 0);\n\n\t \n\toe_start = max(oe->file_offset, start);\n\toe_end = min(oe->file_offset + oe->num_bytes - 1, end);\n\n\tbtrfs_put_ordered_extent(oe);\n\n\t \n\tif (delalloc_len == 0) {\n\t\t*delalloc_start_ret = oe_start;\n\t\t*delalloc_end_ret = oe_end;\n\t\treturn true;\n\t}\n\n\t \n\tif (oe_start < *delalloc_start_ret) {\n\t\tif (oe_end < *delalloc_start_ret)\n\t\t\t*delalloc_end_ret = oe_end;\n\t\t*delalloc_start_ret = oe_start;\n\t} else if (*delalloc_end_ret + 1 == oe_start) {\n\t\t*delalloc_end_ret = oe_end;\n\t}\n\n\treturn true;\n}\n\n \nbool btrfs_find_delalloc_in_range(struct btrfs_inode *inode, u64 start, u64 end,\n\t\t\t\t  struct extent_state **cached_state,\n\t\t\t\t  u64 *delalloc_start_ret, u64 *delalloc_end_ret)\n{\n\tu64 cur_offset = round_down(start, inode->root->fs_info->sectorsize);\n\tu64 prev_delalloc_end = 0;\n\tbool search_io_tree = true;\n\tbool ret = false;\n\n\twhile (cur_offset <= end) {\n\t\tu64 delalloc_start;\n\t\tu64 delalloc_end;\n\t\tbool delalloc;\n\n\t\tdelalloc = find_delalloc_subrange(inode, cur_offset, end,\n\t\t\t\t\t\t  cached_state, &search_io_tree,\n\t\t\t\t\t\t  &delalloc_start,\n\t\t\t\t\t\t  &delalloc_end);\n\t\tif (!delalloc)\n\t\t\tbreak;\n\n\t\tif (prev_delalloc_end == 0) {\n\t\t\t \n\t\t\t*delalloc_start_ret = max(delalloc_start, start);\n\t\t\t*delalloc_end_ret = delalloc_end;\n\t\t\tret = true;\n\t\t} else if (delalloc_start == prev_delalloc_end + 1) {\n\t\t\t \n\t\t\t*delalloc_end_ret = delalloc_end;\n\t\t} else {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tprev_delalloc_end = delalloc_end;\n\t\tcur_offset = delalloc_end + 1;\n\t\tcond_resched();\n\t}\n\n\treturn ret;\n}\n\n \nstatic bool find_desired_extent_in_hole(struct btrfs_inode *inode, int whence,\n\t\t\t\t\tstruct extent_state **cached_state,\n\t\t\t\t\tu64 start, u64 end, u64 *start_ret)\n{\n\tu64 delalloc_start;\n\tu64 delalloc_end;\n\tbool delalloc;\n\n\tdelalloc = btrfs_find_delalloc_in_range(inode, start, end, cached_state,\n\t\t\t\t\t\t&delalloc_start, &delalloc_end);\n\tif (delalloc && whence == SEEK_DATA) {\n\t\t*start_ret = delalloc_start;\n\t\treturn true;\n\t}\n\n\tif (delalloc && whence == SEEK_HOLE) {\n\t\t \n\t\tif (start < delalloc_start) {\n\t\t\t*start_ret = start;\n\t\t\treturn true;\n\t\t}\n\t\t \n\t\tif (delalloc_end < end) {\n\t\t\t*start_ret = delalloc_end + 1;\n\t\t\treturn true;\n\t\t}\n\n\t\t \n\t\treturn false;\n\t}\n\n\tif (!delalloc && whence == SEEK_HOLE) {\n\t\t*start_ret = start;\n\t\treturn true;\n\t}\n\n\t \n\treturn false;\n}\n\nstatic loff_t find_desired_extent(struct file *file, loff_t offset, int whence)\n{\n\tstruct btrfs_inode *inode = BTRFS_I(file->f_mapping->host);\n\tstruct btrfs_file_private *private = file->private_data;\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_state **delalloc_cached_state;\n\tconst loff_t i_size = i_size_read(&inode->vfs_inode);\n\tconst u64 ino = btrfs_ino(inode);\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tu64 last_extent_end;\n\tu64 lockstart;\n\tu64 lockend;\n\tu64 start;\n\tint ret;\n\tbool found = false;\n\n\tif (i_size == 0 || offset >= i_size)\n\t\treturn -ENXIO;\n\n\t \n\tif (whence == SEEK_HOLE &&\n\t    !(inode->flags & BTRFS_INODE_PREALLOC) &&\n\t    inode_get_bytes(&inode->vfs_inode) == i_size)\n\t\treturn i_size;\n\n\tif (!private) {\n\t\tprivate = kzalloc(sizeof(*private), GFP_KERNEL);\n\t\t \n\t\tfile->private_data = private;\n\t}\n\n\tif (private)\n\t\tdelalloc_cached_state = &private->llseek_cached_state;\n\telse\n\t\tdelalloc_cached_state = NULL;\n\n\t \n\tstart = max_t(loff_t, 0, offset);\n\n\tlockstart = round_down(start, fs_info->sectorsize);\n\tlockend = round_up(i_size, fs_info->sectorsize);\n\tif (lockend <= lockstart)\n\t\tlockend = lockstart + fs_info->sectorsize;\n\tlockend--;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = READA_FORWARD;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = start;\n\n\tlast_extent_end = lockstart;\n\n\tlock_extent(&inode->io_tree, lockstart, lockend, &cached_state);\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret > 0 && path->slots[0] > 0) {\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0] - 1);\n\t\tif (key.objectid == ino && key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\tpath->slots[0]--;\n\t}\n\n\twhile (start < i_size) {\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tstruct btrfs_file_extent_item *extent;\n\t\tu64 extent_end;\n\t\tu8 type;\n\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != ino || key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tbreak;\n\n\t\textent_end = btrfs_file_extent_end(path);\n\n\t\t \n\t\tif (extent_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (last_extent_end < key.offset) {\n\t\t\tu64 search_start = last_extent_end;\n\t\t\tu64 found_start;\n\n\t\t\t \n\t\t\tif (start == offset)\n\t\t\t\tsearch_start = offset;\n\n\t\t\tfound = find_desired_extent_in_hole(inode, whence,\n\t\t\t\t\t\t\t    delalloc_cached_state,\n\t\t\t\t\t\t\t    search_start,\n\t\t\t\t\t\t\t    key.offset - 1,\n\t\t\t\t\t\t\t    &found_start);\n\t\t\tif (found) {\n\t\t\t\tstart = found_start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t}\n\n\t\textent = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\ttype = btrfs_file_extent_type(leaf, extent);\n\n\t\t \n\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC ||\n\t\t    (type == BTRFS_FILE_EXTENT_REG &&\n\t\t     btrfs_file_extent_disk_bytenr(leaf, extent) == 0)) {\n\t\t\t \n\t\t\tu64 search_start = key.offset;\n\t\t\tu64 found_start;\n\n\t\t\t \n\t\t\tif (start == offset)\n\t\t\t\tsearch_start = offset;\n\n\t\t\tfound = find_desired_extent_in_hole(inode, whence,\n\t\t\t\t\t\t\t    delalloc_cached_state,\n\t\t\t\t\t\t\t    search_start,\n\t\t\t\t\t\t\t    extent_end - 1,\n\t\t\t\t\t\t\t    &found_start);\n\t\t\tif (found) {\n\t\t\t\tstart = found_start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\tif (whence == SEEK_DATA) {\n\t\t\t\tstart = max_t(u64, key.offset, offset);\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t}\n\n\t\tstart = extent_end;\n\t\tlast_extent_end = extent_end;\n\t\tpath->slots[0]++;\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\t \n\tif (!found && start < i_size) {\n\t\tfound = find_desired_extent_in_hole(inode, whence,\n\t\t\t\t\t\t    delalloc_cached_state, start,\n\t\t\t\t\t\t    i_size - 1, &start);\n\t\tif (!found)\n\t\t\tstart = i_size;\n\t}\n\nout:\n\tunlock_extent(&inode->io_tree, lockstart, lockend, &cached_state);\n\tbtrfs_free_path(path);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (whence == SEEK_DATA && start >= i_size)\n\t\treturn -ENXIO;\n\n\treturn min_t(loff_t, start, i_size);\n}\n\nstatic loff_t btrfs_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\tswitch (whence) {\n\tdefault:\n\t\treturn generic_file_llseek(file, offset, whence);\n\tcase SEEK_DATA:\n\tcase SEEK_HOLE:\n\t\tbtrfs_inode_lock(BTRFS_I(inode), BTRFS_ILOCK_SHARED);\n\t\toffset = find_desired_extent(file, offset, whence);\n\t\tbtrfs_inode_unlock(BTRFS_I(inode), BTRFS_ILOCK_SHARED);\n\t\tbreak;\n\t}\n\n\tif (offset < 0)\n\t\treturn offset;\n\n\treturn vfs_setpos(file, offset, inode->i_sb->s_maxbytes);\n}\n\nstatic int btrfs_file_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\n\tfilp->f_mode |= FMODE_NOWAIT | FMODE_BUF_RASYNC | FMODE_BUF_WASYNC |\n\t\t        FMODE_CAN_ODIRECT;\n\n\tret = fsverity_file_open(inode, filp);\n\tif (ret)\n\t\treturn ret;\n\treturn generic_file_open(inode, filp);\n}\n\nstatic int check_direct_read(struct btrfs_fs_info *fs_info,\n\t\t\t     const struct iov_iter *iter, loff_t offset)\n{\n\tint ret;\n\tint i, seg;\n\n\tret = check_direct_IO(fs_info, iter, offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!iter_is_iovec(iter))\n\t\treturn 0;\n\n\tfor (seg = 0; seg < iter->nr_segs; seg++) {\n\t\tfor (i = seg + 1; i < iter->nr_segs; i++) {\n\t\t\tconst struct iovec *iov1 = iter_iov(iter) + seg;\n\t\t\tconst struct iovec *iov2 = iter_iov(iter) + i;\n\n\t\t\tif (iov1->iov_base == iov2->iov_base)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic ssize_t btrfs_direct_read(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tsize_t prev_left = 0;\n\tssize_t read = 0;\n\tssize_t ret;\n\n\tif (fsverity_active(inode))\n\t\treturn 0;\n\n\tif (check_direct_read(btrfs_sb(inode->i_sb), to, iocb->ki_pos))\n\t\treturn 0;\n\n\tbtrfs_inode_lock(BTRFS_I(inode), BTRFS_ILOCK_SHARED);\nagain:\n\t \n\tpagefault_disable();\n\tto->nofault = true;\n\tret = btrfs_dio_read(iocb, to, read);\n\tto->nofault = false;\n\tpagefault_enable();\n\n\t \n\tif (ret > 0)\n\t\tread = ret;\n\n\tif (iov_iter_count(to) > 0 && (ret == -EFAULT || ret > 0)) {\n\t\tconst size_t left = iov_iter_count(to);\n\n\t\tif (left == prev_left) {\n\t\t\t \n\t\t\tret = read;\n\t\t} else {\n\t\t\t \n\t\t\tfault_in_iov_iter_writeable(to, left);\n\t\t\tprev_left = left;\n\t\t\tgoto again;\n\t\t}\n\t}\n\tbtrfs_inode_unlock(BTRFS_I(inode), BTRFS_ILOCK_SHARED);\n\treturn ret < 0 ? ret : read;\n}\n\nstatic ssize_t btrfs_file_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tssize_t ret = 0;\n\n\tif (iocb->ki_flags & IOCB_DIRECT) {\n\t\tret = btrfs_direct_read(iocb, to);\n\t\tif (ret < 0 || !iov_iter_count(to) ||\n\t\t    iocb->ki_pos >= i_size_read(file_inode(iocb->ki_filp)))\n\t\t\treturn ret;\n\t}\n\n\treturn filemap_read(iocb, to, ret);\n}\n\nconst struct file_operations btrfs_file_operations = {\n\t.llseek\t\t= btrfs_file_llseek,\n\t.read_iter      = btrfs_file_read_iter,\n\t.splice_read\t= filemap_splice_read,\n\t.write_iter\t= btrfs_file_write_iter,\n\t.splice_write\t= iter_file_splice_write,\n\t.mmap\t\t= btrfs_file_mmap,\n\t.open\t\t= btrfs_file_open,\n\t.release\t= btrfs_release_file,\n\t.get_unmapped_area = thp_get_unmapped_area,\n\t.fsync\t\t= btrfs_sync_file,\n\t.fallocate\t= btrfs_fallocate,\n\t.unlocked_ioctl\t= btrfs_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= btrfs_compat_ioctl,\n#endif\n\t.remap_file_range = btrfs_remap_file_range,\n};\n\nint btrfs_fdatawrite_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tint ret;\n\n\t \n\tret = filemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (!ret && test_bit(BTRFS_INODE_HAS_ASYNC_EXTENT,\n\t\t\t     &BTRFS_I(inode)->runtime_flags))\n\t\tret = filemap_fdatawrite_range(inode->i_mapping, start, end);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}