{
  "module_name": "ioctl.c",
  "hash_id": "7041f93961204db2e695afd1437f312d4dee61916a7d7a0f574aa4c3f6132500",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/ioctl.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/bio.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/writeback.h>\n#include <linux/compat.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/uuid.h>\n#include <linux/btrfs.h>\n#include <linux/uaccess.h>\n#include <linux/iversion.h>\n#include <linux/fileattr.h>\n#include <linux/fsverity.h>\n#include <linux/sched/xacct.h>\n#include \"ctree.h\"\n#include \"disk-io.h\"\n#include \"export.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"send.h\"\n#include \"dev-replace.h\"\n#include \"props.h\"\n#include \"sysfs.h\"\n#include \"qgroup.h\"\n#include \"tree-log.h\"\n#include \"compression.h\"\n#include \"space-info.h\"\n#include \"delalloc-space.h\"\n#include \"block-group.h\"\n#include \"subpage.h\"\n#include \"fs.h\"\n#include \"accessors.h\"\n#include \"extent-tree.h\"\n#include \"root-tree.h\"\n#include \"defrag.h\"\n#include \"dir-item.h\"\n#include \"uuid-tree.h\"\n#include \"ioctl.h\"\n#include \"file.h\"\n#include \"scrub.h\"\n#include \"super.h\"\n\n#ifdef CONFIG_64BIT\n \nstruct btrfs_ioctl_timespec_32 {\n\t__u64 sec;\n\t__u32 nsec;\n} __attribute__ ((__packed__));\n\nstruct btrfs_ioctl_received_subvol_args_32 {\n\tchar\tuuid[BTRFS_UUID_SIZE];\t \n\t__u64\tstransid;\t\t \n\t__u64\trtransid;\t\t \n\tstruct btrfs_ioctl_timespec_32 stime;  \n\tstruct btrfs_ioctl_timespec_32 rtime;  \n\t__u64\tflags;\t\t\t \n\t__u64\treserved[16];\t\t \n} __attribute__ ((__packed__));\n\n#define BTRFS_IOC_SET_RECEIVED_SUBVOL_32 _IOWR(BTRFS_IOCTL_MAGIC, 37, \\\n\t\t\t\tstruct btrfs_ioctl_received_subvol_args_32)\n#endif\n\n#if defined(CONFIG_64BIT) && defined(CONFIG_COMPAT)\nstruct btrfs_ioctl_send_args_32 {\n\t__s64 send_fd;\t\t\t \n\t__u64 clone_sources_count;\t \n\tcompat_uptr_t clone_sources;\t \n\t__u64 parent_root;\t\t \n\t__u64 flags;\t\t\t \n\t__u32 version;\t\t\t \n\t__u8  reserved[28];\t\t \n} __attribute__ ((__packed__));\n\n#define BTRFS_IOC_SEND_32 _IOW(BTRFS_IOCTL_MAGIC, 38, \\\n\t\t\t       struct btrfs_ioctl_send_args_32)\n\nstruct btrfs_ioctl_encoded_io_args_32 {\n\tcompat_uptr_t iov;\n\tcompat_ulong_t iovcnt;\n\t__s64 offset;\n\t__u64 flags;\n\t__u64 len;\n\t__u64 unencoded_len;\n\t__u64 unencoded_offset;\n\t__u32 compression;\n\t__u32 encryption;\n\t__u8 reserved[64];\n};\n\n#define BTRFS_IOC_ENCODED_READ_32 _IOR(BTRFS_IOCTL_MAGIC, 64, \\\n\t\t\t\t       struct btrfs_ioctl_encoded_io_args_32)\n#define BTRFS_IOC_ENCODED_WRITE_32 _IOW(BTRFS_IOCTL_MAGIC, 64, \\\n\t\t\t\t\tstruct btrfs_ioctl_encoded_io_args_32)\n#endif\n\n \nstatic unsigned int btrfs_mask_fsflags_for_type(struct inode *inode,\n\t\tunsigned int flags)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn flags;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn flags & ~FS_DIRSYNC_FL;\n\telse\n\t\treturn flags & (FS_NODUMP_FL | FS_NOATIME_FL);\n}\n\n \nstatic unsigned int btrfs_inode_flags_to_fsflags(struct btrfs_inode *binode)\n{\n\tunsigned int iflags = 0;\n\tu32 flags = binode->flags;\n\tu32 ro_flags = binode->ro_flags;\n\n\tif (flags & BTRFS_INODE_SYNC)\n\t\tiflags |= FS_SYNC_FL;\n\tif (flags & BTRFS_INODE_IMMUTABLE)\n\t\tiflags |= FS_IMMUTABLE_FL;\n\tif (flags & BTRFS_INODE_APPEND)\n\t\tiflags |= FS_APPEND_FL;\n\tif (flags & BTRFS_INODE_NODUMP)\n\t\tiflags |= FS_NODUMP_FL;\n\tif (flags & BTRFS_INODE_NOATIME)\n\t\tiflags |= FS_NOATIME_FL;\n\tif (flags & BTRFS_INODE_DIRSYNC)\n\t\tiflags |= FS_DIRSYNC_FL;\n\tif (flags & BTRFS_INODE_NODATACOW)\n\t\tiflags |= FS_NOCOW_FL;\n\tif (ro_flags & BTRFS_INODE_RO_VERITY)\n\t\tiflags |= FS_VERITY_FL;\n\n\tif (flags & BTRFS_INODE_NOCOMPRESS)\n\t\tiflags |= FS_NOCOMP_FL;\n\telse if (flags & BTRFS_INODE_COMPRESS)\n\t\tiflags |= FS_COMPR_FL;\n\n\treturn iflags;\n}\n\n \nvoid btrfs_sync_inode_flags_to_i_flags(struct inode *inode)\n{\n\tstruct btrfs_inode *binode = BTRFS_I(inode);\n\tunsigned int new_fl = 0;\n\n\tif (binode->flags & BTRFS_INODE_SYNC)\n\t\tnew_fl |= S_SYNC;\n\tif (binode->flags & BTRFS_INODE_IMMUTABLE)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (binode->flags & BTRFS_INODE_APPEND)\n\t\tnew_fl |= S_APPEND;\n\tif (binode->flags & BTRFS_INODE_NOATIME)\n\t\tnew_fl |= S_NOATIME;\n\tif (binode->flags & BTRFS_INODE_DIRSYNC)\n\t\tnew_fl |= S_DIRSYNC;\n\tif (binode->ro_flags & BTRFS_INODE_RO_VERITY)\n\t\tnew_fl |= S_VERITY;\n\n\tset_mask_bits(&inode->i_flags,\n\t\t      S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME | S_DIRSYNC |\n\t\t      S_VERITY, new_fl);\n}\n\n \nstatic int check_fsflags(unsigned int old_flags, unsigned int flags)\n{\n\tif (flags & ~(FS_IMMUTABLE_FL | FS_APPEND_FL | \\\n\t\t      FS_NOATIME_FL | FS_NODUMP_FL | \\\n\t\t      FS_SYNC_FL | FS_DIRSYNC_FL | \\\n\t\t      FS_NOCOMP_FL | FS_COMPR_FL |\n\t\t      FS_NOCOW_FL))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((flags & FS_NOCOMP_FL) && (flags & FS_COMPR_FL))\n\t\treturn -EINVAL;\n\n\tif ((flags & FS_COMPR_FL) && (flags & FS_NOCOW_FL))\n\t\treturn -EINVAL;\n\n\t \n\tif ((old_flags & FS_NOCOW_FL) && (flags & (FS_COMPR_FL | FS_NOCOMP_FL)))\n\t\treturn -EINVAL;\n\tif ((flags & FS_NOCOW_FL) && (old_flags & (FS_COMPR_FL | FS_NOCOMP_FL)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int check_fsflags_compatible(struct btrfs_fs_info *fs_info,\n\t\t\t\t    unsigned int flags)\n{\n\tif (btrfs_is_zoned(fs_info) && (flags & FS_NOCOW_FL))\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\n \nint btrfs_fileattr_get(struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct btrfs_inode *binode = BTRFS_I(d_inode(dentry));\n\n\tfileattr_fill_flags(fa, btrfs_inode_flags_to_fsflags(binode));\n\treturn 0;\n}\n\nint btrfs_fileattr_set(struct mnt_idmap *idmap,\n\t\t       struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_inode *binode = BTRFS_I(inode);\n\tstruct btrfs_root *root = binode->root;\n\tstruct btrfs_trans_handle *trans;\n\tunsigned int fsflags, old_fsflags;\n\tint ret;\n\tconst char *comp = NULL;\n\tu32 binode_flags;\n\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\tif (fileattr_has_fsx(fa))\n\t\treturn -EOPNOTSUPP;\n\n\tfsflags = btrfs_mask_fsflags_for_type(inode, fa->flags);\n\told_fsflags = btrfs_inode_flags_to_fsflags(binode);\n\tret = check_fsflags(old_fsflags, fsflags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = check_fsflags_compatible(fs_info, fsflags);\n\tif (ret)\n\t\treturn ret;\n\n\tbinode_flags = binode->flags;\n\tif (fsflags & FS_SYNC_FL)\n\t\tbinode_flags |= BTRFS_INODE_SYNC;\n\telse\n\t\tbinode_flags &= ~BTRFS_INODE_SYNC;\n\tif (fsflags & FS_IMMUTABLE_FL)\n\t\tbinode_flags |= BTRFS_INODE_IMMUTABLE;\n\telse\n\t\tbinode_flags &= ~BTRFS_INODE_IMMUTABLE;\n\tif (fsflags & FS_APPEND_FL)\n\t\tbinode_flags |= BTRFS_INODE_APPEND;\n\telse\n\t\tbinode_flags &= ~BTRFS_INODE_APPEND;\n\tif (fsflags & FS_NODUMP_FL)\n\t\tbinode_flags |= BTRFS_INODE_NODUMP;\n\telse\n\t\tbinode_flags &= ~BTRFS_INODE_NODUMP;\n\tif (fsflags & FS_NOATIME_FL)\n\t\tbinode_flags |= BTRFS_INODE_NOATIME;\n\telse\n\t\tbinode_flags &= ~BTRFS_INODE_NOATIME;\n\n\t \n\tif (!fa->flags_valid) {\n\t\t \n\t\ttrans = btrfs_start_transaction(root, 1);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t\tgoto update_flags;\n\t}\n\n\tif (fsflags & FS_DIRSYNC_FL)\n\t\tbinode_flags |= BTRFS_INODE_DIRSYNC;\n\telse\n\t\tbinode_flags &= ~BTRFS_INODE_DIRSYNC;\n\tif (fsflags & FS_NOCOW_FL) {\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\t \n\t\t\tif (inode->i_size == 0)\n\t\t\t\tbinode_flags |= BTRFS_INODE_NODATACOW |\n\t\t\t\t\t\tBTRFS_INODE_NODATASUM;\n\t\t} else {\n\t\t\tbinode_flags |= BTRFS_INODE_NODATACOW;\n\t\t}\n\t} else {\n\t\t \n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tif (inode->i_size == 0)\n\t\t\t\tbinode_flags &= ~(BTRFS_INODE_NODATACOW |\n\t\t\t\t\t\t  BTRFS_INODE_NODATASUM);\n\t\t} else {\n\t\t\tbinode_flags &= ~BTRFS_INODE_NODATACOW;\n\t\t}\n\t}\n\n\t \n\tif (fsflags & FS_NOCOMP_FL) {\n\t\tbinode_flags &= ~BTRFS_INODE_COMPRESS;\n\t\tbinode_flags |= BTRFS_INODE_NOCOMPRESS;\n\t} else if (fsflags & FS_COMPR_FL) {\n\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\n\t\tbinode_flags |= BTRFS_INODE_COMPRESS;\n\t\tbinode_flags &= ~BTRFS_INODE_NOCOMPRESS;\n\n\t\tcomp = btrfs_compress_type2str(fs_info->compress_type);\n\t\tif (!comp || comp[0] == 0)\n\t\t\tcomp = btrfs_compress_type2str(BTRFS_COMPRESS_ZLIB);\n\t} else {\n\t\tbinode_flags &= ~(BTRFS_INODE_COMPRESS | BTRFS_INODE_NOCOMPRESS);\n\t}\n\n\t \n\ttrans = btrfs_start_transaction(root, 3);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tif (comp) {\n\t\tret = btrfs_set_prop(trans, inode, \"btrfs.compression\", comp,\n\t\t\t\t     strlen(comp), 0);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out_end_trans;\n\t\t}\n\t} else {\n\t\tret = btrfs_set_prop(trans, inode, \"btrfs.compression\", NULL,\n\t\t\t\t     0, 0);\n\t\tif (ret && ret != -ENODATA) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto out_end_trans;\n\t\t}\n\t}\n\nupdate_flags:\n\tbinode->flags = binode_flags;\n\tbtrfs_sync_inode_flags_to_i_flags(inode);\n\tinode_inc_iversion(inode);\n\tinode_set_ctime_current(inode);\n\tret = btrfs_update_inode(trans, root, BTRFS_I(inode));\n\n out_end_trans:\n\tbtrfs_end_transaction(trans);\n\treturn ret;\n}\n\n \nbool btrfs_exclop_start(struct btrfs_fs_info *fs_info,\n\t\t\tenum btrfs_exclusive_operation type)\n{\n\tbool ret = false;\n\n\tspin_lock(&fs_info->super_lock);\n\tif (fs_info->exclusive_operation == BTRFS_EXCLOP_NONE) {\n\t\tfs_info->exclusive_operation = type;\n\t\tret = true;\n\t}\n\tspin_unlock(&fs_info->super_lock);\n\n\treturn ret;\n}\n\n \nbool btrfs_exclop_start_try_lock(struct btrfs_fs_info *fs_info,\n\t\t\t\t enum btrfs_exclusive_operation type)\n{\n\tspin_lock(&fs_info->super_lock);\n\tif (fs_info->exclusive_operation == type ||\n\t    (fs_info->exclusive_operation == BTRFS_EXCLOP_BALANCE_PAUSED &&\n\t     type == BTRFS_EXCLOP_DEV_ADD))\n\t\treturn true;\n\n\tspin_unlock(&fs_info->super_lock);\n\treturn false;\n}\n\nvoid btrfs_exclop_start_unlock(struct btrfs_fs_info *fs_info)\n{\n\tspin_unlock(&fs_info->super_lock);\n}\n\nvoid btrfs_exclop_finish(struct btrfs_fs_info *fs_info)\n{\n\tspin_lock(&fs_info->super_lock);\n\tWRITE_ONCE(fs_info->exclusive_operation, BTRFS_EXCLOP_NONE);\n\tspin_unlock(&fs_info->super_lock);\n\tsysfs_notify(&fs_info->fs_devices->fsid_kobj, NULL, \"exclusive_operation\");\n}\n\nvoid btrfs_exclop_balance(struct btrfs_fs_info *fs_info,\n\t\t\t  enum btrfs_exclusive_operation op)\n{\n\tswitch (op) {\n\tcase BTRFS_EXCLOP_BALANCE_PAUSED:\n\t\tspin_lock(&fs_info->super_lock);\n\t\tASSERT(fs_info->exclusive_operation == BTRFS_EXCLOP_BALANCE ||\n\t\t       fs_info->exclusive_operation == BTRFS_EXCLOP_DEV_ADD ||\n\t\t       fs_info->exclusive_operation == BTRFS_EXCLOP_NONE ||\n\t\t       fs_info->exclusive_operation == BTRFS_EXCLOP_BALANCE_PAUSED);\n\t\tfs_info->exclusive_operation = BTRFS_EXCLOP_BALANCE_PAUSED;\n\t\tspin_unlock(&fs_info->super_lock);\n\t\tbreak;\n\tcase BTRFS_EXCLOP_BALANCE:\n\t\tspin_lock(&fs_info->super_lock);\n\t\tASSERT(fs_info->exclusive_operation == BTRFS_EXCLOP_BALANCE_PAUSED);\n\t\tfs_info->exclusive_operation = BTRFS_EXCLOP_BALANCE;\n\t\tspin_unlock(&fs_info->super_lock);\n\t\tbreak;\n\tdefault:\n\t\tbtrfs_warn(fs_info,\n\t\t\t\"invalid exclop balance operation %d requested\", op);\n\t}\n}\n\nstatic int btrfs_ioctl_getversion(struct inode *inode, int __user *arg)\n{\n\treturn put_user(inode->i_generation, arg);\n}\n\nstatic noinline int btrfs_ioctl_fitrim(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tvoid __user *arg)\n{\n\tstruct btrfs_device *device;\n\tstruct fstrim_range range;\n\tu64 minlen = ULLONG_MAX;\n\tu64 num_devices = 0;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t \n\tif (btrfs_is_zoned(fs_info))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (btrfs_test_opt(fs_info, NOLOGREPLAY))\n\t\treturn -EROFS;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(device, &fs_info->fs_devices->devices,\n\t\t\t\tdev_list) {\n\t\tif (!device->bdev || !bdev_max_discard_sectors(device->bdev))\n\t\t\tcontinue;\n\t\tnum_devices++;\n\t\tminlen = min_t(u64, bdev_discard_granularity(device->bdev),\n\t\t\t\t    minlen);\n\t}\n\trcu_read_unlock();\n\n\tif (!num_devices)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&range, arg, sizeof(range)))\n\t\treturn -EFAULT;\n\n\t \n\tif (range.len < fs_info->sb->s_blocksize)\n\t\treturn -EINVAL;\n\n\trange.minlen = max(range.minlen, minlen);\n\tret = btrfs_trim_fs(fs_info, &range);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &range, sizeof(range)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nint __pure btrfs_is_empty_uuid(u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_UUID_SIZE; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nstatic unsigned int create_subvol_num_items(struct btrfs_qgroup_inherit *inherit)\n{\n\t \n\tunsigned int num_items = 7;\n\n\tif (inherit) {\n\t\t \n\t\tnum_items += 2 * inherit->num_qgroups;\n\t}\n\treturn num_items;\n}\n\nstatic noinline int create_subvol(struct mnt_idmap *idmap,\n\t\t\t\t  struct inode *dir, struct dentry *dentry,\n\t\t\t\t  struct btrfs_qgroup_inherit *inherit)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(dir->i_sb);\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_key key;\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_root *new_root;\n\tstruct btrfs_block_rsv block_rsv;\n\tstruct timespec64 cur_time = current_time(dir);\n\tstruct btrfs_new_inode_args new_inode_args = {\n\t\t.dir = dir,\n\t\t.dentry = dentry,\n\t\t.subvol = true,\n\t};\n\tunsigned int trans_num_items;\n\tint ret;\n\tdev_t anon_dev;\n\tu64 objectid;\n\n\troot_item = kzalloc(sizeof(*root_item), GFP_KERNEL);\n\tif (!root_item)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_get_free_objectid(fs_info->tree_root, &objectid);\n\tif (ret)\n\t\tgoto out_root_item;\n\n\t \n\tif (btrfs_qgroup_level(objectid)) {\n\t\tret = -ENOSPC;\n\t\tgoto out_root_item;\n\t}\n\n\tret = get_anon_bdev(&anon_dev);\n\tif (ret < 0)\n\t\tgoto out_root_item;\n\n\tnew_inode_args.inode = btrfs_new_subvol_inode(idmap, dir);\n\tif (!new_inode_args.inode) {\n\t\tret = -ENOMEM;\n\t\tgoto out_anon_dev;\n\t}\n\tret = btrfs_new_inode_prepare(&new_inode_args, &trans_num_items);\n\tif (ret)\n\t\tgoto out_inode;\n\ttrans_num_items += create_subvol_num_items(inherit);\n\n\tbtrfs_init_block_rsv(&block_rsv, BTRFS_BLOCK_RSV_TEMP);\n\tret = btrfs_subvolume_reserve_metadata(root, &block_rsv,\n\t\t\t\t\t       trans_num_items, false);\n\tif (ret)\n\t\tgoto out_new_inode_args;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tbtrfs_subvolume_release_metadata(root, &block_rsv);\n\t\tgoto out_new_inode_args;\n\t}\n\ttrans->block_rsv = &block_rsv;\n\ttrans->bytes_reserved = block_rsv.size;\n\t \n\tbtrfs_set_log_full_commit(trans);\n\n\tret = btrfs_qgroup_inherit(trans, 0, objectid, inherit);\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = btrfs_alloc_tree_block(trans, root, 0, objectid, NULL, 0, 0, 0,\n\t\t\t\t      BTRFS_NESTING_NORMAL);\n\tif (IS_ERR(leaf)) {\n\t\tret = PTR_ERR(leaf);\n\t\tgoto out;\n\t}\n\n\tbtrfs_mark_buffer_dirty(trans, leaf);\n\n\tinode_item = &root_item->inode;\n\tbtrfs_set_stack_inode_generation(inode_item, 1);\n\tbtrfs_set_stack_inode_size(inode_item, 3);\n\tbtrfs_set_stack_inode_nlink(inode_item, 1);\n\tbtrfs_set_stack_inode_nbytes(inode_item,\n\t\t\t\t     fs_info->nodesize);\n\tbtrfs_set_stack_inode_mode(inode_item, S_IFDIR | 0755);\n\n\tbtrfs_set_root_flags(root_item, 0);\n\tbtrfs_set_root_limit(root_item, 0);\n\tbtrfs_set_stack_inode_flags(inode_item, BTRFS_INODE_ROOT_ITEM_INIT);\n\n\tbtrfs_set_root_bytenr(root_item, leaf->start);\n\tbtrfs_set_root_generation(root_item, trans->transid);\n\tbtrfs_set_root_level(root_item, 0);\n\tbtrfs_set_root_refs(root_item, 1);\n\tbtrfs_set_root_used(root_item, leaf->len);\n\tbtrfs_set_root_last_snapshot(root_item, 0);\n\n\tbtrfs_set_root_generation_v2(root_item,\n\t\t\tbtrfs_root_generation(root_item));\n\tgenerate_random_guid(root_item->uuid);\n\tbtrfs_set_stack_timespec_sec(&root_item->otime, cur_time.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item->otime, cur_time.tv_nsec);\n\troot_item->ctime = root_item->otime;\n\tbtrfs_set_root_ctransid(root_item, trans->transid);\n\tbtrfs_set_root_otransid(root_item, trans->transid);\n\n\tbtrfs_tree_unlock(leaf);\n\n\tbtrfs_set_root_dirid(root_item, BTRFS_FIRST_FREE_OBJECTID);\n\n\tkey.objectid = objectid;\n\tkey.offset = 0;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tret = btrfs_insert_root(trans, fs_info->tree_root, &key,\n\t\t\t\troot_item);\n\tif (ret) {\n\t\t \n\t\tbtrfs_tree_lock(leaf);\n\t\tbtrfs_clear_buffer_dirty(trans, leaf);\n\t\tbtrfs_tree_unlock(leaf);\n\t\tbtrfs_free_tree_block(trans, objectid, leaf, 0, 1);\n\t\tfree_extent_buffer(leaf);\n\t\tgoto out;\n\t}\n\n\tfree_extent_buffer(leaf);\n\tleaf = NULL;\n\n\tnew_root = btrfs_get_new_fs_root(fs_info, objectid, anon_dev);\n\tif (IS_ERR(new_root)) {\n\t\tret = PTR_ERR(new_root);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\n\t \n\tanon_dev = 0;\n\tBTRFS_I(new_inode_args.inode)->root = new_root;\n\t \n\n\tret = btrfs_record_root_in_trans(trans, new_root);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\n\n\tret = btrfs_uuid_tree_add(trans, root_item->uuid,\n\t\t\t\t  BTRFS_UUID_KEY_SUBVOL, objectid);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\n\n\tret = btrfs_create_new_inode(trans, &new_inode_args);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out;\n\t}\n\n\td_instantiate_new(dentry, new_inode_args.inode);\n\tnew_inode_args.inode = NULL;\n\nout:\n\ttrans->block_rsv = NULL;\n\ttrans->bytes_reserved = 0;\n\tbtrfs_subvolume_release_metadata(root, &block_rsv);\n\n\tbtrfs_end_transaction(trans);\nout_new_inode_args:\n\tbtrfs_new_inode_args_destroy(&new_inode_args);\nout_inode:\n\tiput(new_inode_args.inode);\nout_anon_dev:\n\tif (anon_dev)\n\t\tfree_anon_bdev(anon_dev);\nout_root_item:\n\tkfree(root_item);\n\treturn ret;\n}\n\nstatic int create_snapshot(struct btrfs_root *root, struct inode *dir,\n\t\t\t   struct dentry *dentry, bool readonly,\n\t\t\t   struct btrfs_qgroup_inherit *inherit)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(dir->i_sb);\n\tstruct inode *inode;\n\tstruct btrfs_pending_snapshot *pending_snapshot;\n\tunsigned int trans_num_items;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\t \n\tif (btrfs_fs_incompat(fs_info, EXTENT_TREE_V2)) {\n\t\tbtrfs_warn(fs_info,\n\t\t\t   \"extent tree v2 doesn't support snapshotting yet\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!test_bit(BTRFS_ROOT_SHAREABLE, &root->state))\n\t\treturn -EINVAL;\n\n\tif (atomic_read(&root->nr_swapfiles)) {\n\t\tbtrfs_warn(fs_info,\n\t\t\t   \"cannot snapshot subvolume with active swapfile\");\n\t\treturn -ETXTBSY;\n\t}\n\n\tpending_snapshot = kzalloc(sizeof(*pending_snapshot), GFP_KERNEL);\n\tif (!pending_snapshot)\n\t\treturn -ENOMEM;\n\n\tret = get_anon_bdev(&pending_snapshot->anon_dev);\n\tif (ret < 0)\n\t\tgoto free_pending;\n\tpending_snapshot->root_item = kzalloc(sizeof(struct btrfs_root_item),\n\t\t\tGFP_KERNEL);\n\tpending_snapshot->path = btrfs_alloc_path();\n\tif (!pending_snapshot->root_item || !pending_snapshot->path) {\n\t\tret = -ENOMEM;\n\t\tgoto free_pending;\n\t}\n\n\tbtrfs_init_block_rsv(&pending_snapshot->block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_TEMP);\n\t \n\ttrans_num_items = create_subvol_num_items(inherit) + 3;\n\tret = btrfs_subvolume_reserve_metadata(BTRFS_I(dir)->root,\n\t\t\t\t\t       &pending_snapshot->block_rsv,\n\t\t\t\t\t       trans_num_items, false);\n\tif (ret)\n\t\tgoto free_pending;\n\n\tpending_snapshot->dentry = dentry;\n\tpending_snapshot->root = root;\n\tpending_snapshot->readonly = readonly;\n\tpending_snapshot->dir = dir;\n\tpending_snapshot->inherit = inherit;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto fail;\n\t}\n\n\ttrans->pending_snapshot = pending_snapshot;\n\n\tret = btrfs_commit_transaction(trans);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = pending_snapshot->error;\n\tif (ret)\n\t\tgoto fail;\n\n\tret = btrfs_orphan_cleanup(pending_snapshot->snap);\n\tif (ret)\n\t\tgoto fail;\n\n\tinode = btrfs_lookup_dentry(d_inode(dentry->d_parent), dentry);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto fail;\n\t}\n\n\td_instantiate(dentry, inode);\n\tret = 0;\n\tpending_snapshot->anon_dev = 0;\nfail:\n\t \n\tif (ret && pending_snapshot->snap)\n\t\tpending_snapshot->snap->anon_dev = 0;\n\tbtrfs_put_root(pending_snapshot->snap);\n\tbtrfs_subvolume_release_metadata(root, &pending_snapshot->block_rsv);\nfree_pending:\n\tif (pending_snapshot->anon_dev)\n\t\tfree_anon_bdev(pending_snapshot->anon_dev);\n\tkfree(pending_snapshot->root_item);\n\tbtrfs_free_path(pending_snapshot->path);\n\tkfree(pending_snapshot);\n\n\treturn ret;\n}\n\n \n\nstatic int btrfs_may_delete(struct mnt_idmap *idmap,\n\t\t\t    struct inode *dir, struct dentry *victim, int isdir)\n{\n\tint error;\n\n\tif (d_really_is_negative(victim))\n\t\treturn -ENOENT;\n\n\tBUG_ON(d_inode(victim->d_parent) != dir);\n\taudit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);\n\n\terror = inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\tif (check_sticky(idmap, dir, d_inode(victim)) ||\n\t    IS_APPEND(d_inode(victim)) || IS_IMMUTABLE(d_inode(victim)) ||\n\t    IS_SWAPFILE(d_inode(victim)))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!d_is_dir(victim))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (d_is_dir(victim))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\n \nstatic inline int btrfs_may_create(struct mnt_idmap *idmap,\n\t\t\t\t   struct inode *dir, struct dentry *child)\n{\n\tif (d_really_is_positive(child))\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (!fsuidgid_has_mapping(dir->i_sb, idmap))\n\t\treturn -EOVERFLOW;\n\treturn inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC);\n}\n\n \nstatic noinline int btrfs_mksubvol(const struct path *parent,\n\t\t\t\t   struct mnt_idmap *idmap,\n\t\t\t\t   const char *name, int namelen,\n\t\t\t\t   struct btrfs_root *snap_src,\n\t\t\t\t   bool readonly,\n\t\t\t\t   struct btrfs_qgroup_inherit *inherit)\n{\n\tstruct inode *dir = d_inode(parent->dentry);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(dir->i_sb);\n\tstruct dentry *dentry;\n\tstruct fscrypt_str name_str = FSTR_INIT((char *)name, namelen);\n\tint error;\n\n\terror = down_write_killable_nested(&dir->i_rwsem, I_MUTEX_PARENT);\n\tif (error == -EINTR)\n\t\treturn error;\n\n\tdentry = lookup_one(idmap, name, parent->dentry, namelen);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_unlock;\n\n\terror = btrfs_may_create(idmap, dir, dentry);\n\tif (error)\n\t\tgoto out_dput;\n\n\t \n\terror = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,\n\t\t\t\t\t       dir->i_ino, &name_str);\n\tif (error)\n\t\tgoto out_dput;\n\n\tdown_read(&fs_info->subvol_sem);\n\n\tif (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)\n\t\tgoto out_up_read;\n\n\tif (snap_src)\n\t\terror = create_snapshot(snap_src, dir, dentry, readonly, inherit);\n\telse\n\t\terror = create_subvol(idmap, dir, dentry, inherit);\n\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\nout_up_read:\n\tup_read(&fs_info->subvol_sem);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tbtrfs_inode_unlock(BTRFS_I(dir), 0);\n\treturn error;\n}\n\nstatic noinline int btrfs_mksnapshot(const struct path *parent,\n\t\t\t\t   struct mnt_idmap *idmap,\n\t\t\t\t   const char *name, int namelen,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   bool readonly,\n\t\t\t\t   struct btrfs_qgroup_inherit *inherit)\n{\n\tint ret;\n\tbool snapshot_force_cow = false;\n\n\t \n\tbtrfs_drew_read_lock(&root->snapshot_lock);\n\n\tret = btrfs_start_delalloc_snapshot(root, false);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tatomic_inc(&root->snapshot_force_cow);\n\tsnapshot_force_cow = true;\n\n\tbtrfs_wait_ordered_extents(root, U64_MAX, 0, (u64)-1);\n\n\tret = btrfs_mksubvol(parent, idmap, name, namelen,\n\t\t\t     root, readonly, inherit);\nout:\n\tif (snapshot_force_cow)\n\t\tatomic_dec(&root->snapshot_force_cow);\n\tbtrfs_drew_read_unlock(&root->snapshot_lock);\n\treturn ret;\n}\n\n \nstatic int exclop_start_or_cancel_reloc(struct btrfs_fs_info *fs_info,\n\t\t\tenum btrfs_exclusive_operation type, bool cancel)\n{\n\tif (!cancel) {\n\t\t \n\t\tif (!btrfs_exclop_start(fs_info, type))\n\t\t\treturn BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tif (btrfs_exclop_start_try_lock(fs_info, type)) {\n\t\t \n\t\tatomic_inc(&fs_info->reloc_cancel_req);\n\t\tbtrfs_exclop_start_unlock(fs_info);\n\n\t\tif (test_bit(BTRFS_FS_RELOC_RUNNING, &fs_info->flags))\n\t\t\twait_on_bit(&fs_info->flags, BTRFS_FS_RELOC_RUNNING,\n\t\t\t\t    TASK_INTERRUPTIBLE);\n\n\t\treturn -ECANCELED;\n\t}\n\n\t \n\treturn -ENOTCONN;\n}\n\nstatic noinline int btrfs_ioctl_resize(struct file *file,\n\t\t\t\t\tvoid __user *arg)\n{\n\tBTRFS_DEV_LOOKUP_ARGS(args);\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tu64 new_size;\n\tu64 old_size;\n\tu64 devid = 1;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_device *device = NULL;\n\tchar *sizestr;\n\tchar *retptr;\n\tchar *devstr = NULL;\n\tint ret = 0;\n\tint mod = 0;\n\tbool cancel;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto out_drop;\n\t}\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\tsizestr = vol_args->name;\n\tcancel = (strcmp(\"cancel\", sizestr) == 0);\n\tret = exclop_start_or_cancel_reloc(fs_info, BTRFS_EXCLOP_RESIZE, cancel);\n\tif (ret)\n\t\tgoto out_free;\n\t \n\n\tdevstr = strchr(sizestr, ':');\n\tif (devstr) {\n\t\tsizestr = devstr + 1;\n\t\t*devstr = '\\0';\n\t\tdevstr = vol_args->name;\n\t\tret = kstrtoull(devstr, 10, &devid);\n\t\tif (ret)\n\t\t\tgoto out_finish;\n\t\tif (!devid) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_finish;\n\t\t}\n\t\tbtrfs_info(fs_info, \"resizing devid %llu\", devid);\n\t}\n\n\targs.devid = devid;\n\tdevice = btrfs_find_device(fs_info->fs_devices, &args);\n\tif (!device) {\n\t\tbtrfs_info(fs_info, \"resizer unable to find device %llu\",\n\t\t\t   devid);\n\t\tret = -ENODEV;\n\t\tgoto out_finish;\n\t}\n\n\tif (!test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) {\n\t\tbtrfs_info(fs_info,\n\t\t\t   \"resizer unable to apply on readonly device %llu\",\n\t\t       devid);\n\t\tret = -EPERM;\n\t\tgoto out_finish;\n\t}\n\n\tif (!strcmp(sizestr, \"max\"))\n\t\tnew_size = bdev_nr_bytes(device->bdev);\n\telse {\n\t\tif (sizestr[0] == '-') {\n\t\t\tmod = -1;\n\t\t\tsizestr++;\n\t\t} else if (sizestr[0] == '+') {\n\t\t\tmod = 1;\n\t\t\tsizestr++;\n\t\t}\n\t\tnew_size = memparse(sizestr, &retptr);\n\t\tif (*retptr != '\\0' || new_size == 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_finish;\n\t\t}\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state)) {\n\t\tret = -EPERM;\n\t\tgoto out_finish;\n\t}\n\n\told_size = btrfs_device_get_total_bytes(device);\n\n\tif (mod < 0) {\n\t\tif (new_size > old_size) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_finish;\n\t\t}\n\t\tnew_size = old_size - new_size;\n\t} else if (mod > 0) {\n\t\tif (new_size > ULLONG_MAX - old_size) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_finish;\n\t\t}\n\t\tnew_size = old_size + new_size;\n\t}\n\n\tif (new_size < SZ_256M) {\n\t\tret = -EINVAL;\n\t\tgoto out_finish;\n\t}\n\tif (new_size > bdev_nr_bytes(device->bdev)) {\n\t\tret = -EFBIG;\n\t\tgoto out_finish;\n\t}\n\n\tnew_size = round_down(new_size, fs_info->sectorsize);\n\n\tif (new_size > old_size) {\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto out_finish;\n\t\t}\n\t\tret = btrfs_grow_device(trans, device, new_size);\n\t\tbtrfs_commit_transaction(trans);\n\t} else if (new_size < old_size) {\n\t\tret = btrfs_shrink_device(device, new_size);\n\t}  \n\n\tif (ret == 0 && new_size != old_size)\n\t\tbtrfs_info_in_rcu(fs_info,\n\t\t\t\"resize device %s (devid %llu) from %llu to %llu\",\n\t\t\tbtrfs_dev_name(device), device->devid,\n\t\t\told_size, new_size);\nout_finish:\n\tbtrfs_exclop_finish(fs_info);\nout_free:\n\tkfree(vol_args);\nout_drop:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}\n\nstatic noinline int __btrfs_ioctl_snap_create(struct file *file,\n\t\t\t\tstruct mnt_idmap *idmap,\n\t\t\t\tconst char *name, unsigned long fd, int subvol,\n\t\t\t\tbool readonly,\n\t\t\t\tstruct btrfs_qgroup_inherit *inherit)\n{\n\tint namelen;\n\tint ret = 0;\n\n\tif (!S_ISDIR(file_inode(file)->i_mode))\n\t\treturn -ENOTDIR;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\tgoto out;\n\n\tnamelen = strlen(name);\n\tif (strchr(name, '/')) {\n\t\tret = -EINVAL;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (name[0] == '.' &&\n\t   (namelen == 1 || (name[1] == '.' && namelen == 2))) {\n\t\tret = -EEXIST;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (subvol) {\n\t\tret = btrfs_mksubvol(&file->f_path, idmap, name,\n\t\t\t\t     namelen, NULL, readonly, inherit);\n\t} else {\n\t\tstruct fd src = fdget(fd);\n\t\tstruct inode *src_inode;\n\t\tif (!src.file) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_drop_write;\n\t\t}\n\n\t\tsrc_inode = file_inode(src.file);\n\t\tif (src_inode->i_sb != file_inode(file)->i_sb) {\n\t\t\tbtrfs_info(BTRFS_I(file_inode(file))->root->fs_info,\n\t\t\t\t   \"Snapshot src from another FS\");\n\t\t\tret = -EXDEV;\n\t\t} else if (!inode_owner_or_capable(idmap, src_inode)) {\n\t\t\t \n\t\t\tret = -EPERM;\n\t\t} else if (btrfs_ino(BTRFS_I(src_inode)) != BTRFS_FIRST_FREE_OBJECTID) {\n\t\t\t \n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tret = btrfs_mksnapshot(&file->f_path, idmap,\n\t\t\t\t\t       name, namelen,\n\t\t\t\t\t       BTRFS_I(src_inode)->root,\n\t\t\t\t\t       readonly, inherit);\n\t\t}\n\t\tfdput(src);\n\t}\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\treturn ret;\n}\n\nstatic noinline int btrfs_ioctl_snap_create(struct file *file,\n\t\t\t\t\t    void __user *arg, int subvol)\n{\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tint ret;\n\n\tif (!S_ISDIR(file_inode(file)->i_mode))\n\t\treturn -ENOTDIR;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args))\n\t\treturn PTR_ERR(vol_args);\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\n\tret = __btrfs_ioctl_snap_create(file, file_mnt_idmap(file),\n\t\t\t\t\tvol_args->name, vol_args->fd, subvol,\n\t\t\t\t\tfalse, NULL);\n\n\tkfree(vol_args);\n\treturn ret;\n}\n\nstatic noinline int btrfs_ioctl_snap_create_v2(struct file *file,\n\t\t\t\t\t       void __user *arg, int subvol)\n{\n\tstruct btrfs_ioctl_vol_args_v2 *vol_args;\n\tint ret;\n\tbool readonly = false;\n\tstruct btrfs_qgroup_inherit *inherit = NULL;\n\n\tif (!S_ISDIR(file_inode(file)->i_mode))\n\t\treturn -ENOTDIR;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args))\n\t\treturn PTR_ERR(vol_args);\n\tvol_args->name[BTRFS_SUBVOL_NAME_MAX] = '\\0';\n\n\tif (vol_args->flags & ~BTRFS_SUBVOL_CREATE_ARGS_MASK) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto free_args;\n\t}\n\n\tif (vol_args->flags & BTRFS_SUBVOL_RDONLY)\n\t\treadonly = true;\n\tif (vol_args->flags & BTRFS_SUBVOL_QGROUP_INHERIT) {\n\t\tu64 nums;\n\n\t\tif (vol_args->size < sizeof(*inherit) ||\n\t\t    vol_args->size > PAGE_SIZE) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_args;\n\t\t}\n\t\tinherit = memdup_user(vol_args->qgroup_inherit, vol_args->size);\n\t\tif (IS_ERR(inherit)) {\n\t\t\tret = PTR_ERR(inherit);\n\t\t\tgoto free_args;\n\t\t}\n\n\t\tif (inherit->num_qgroups > PAGE_SIZE ||\n\t\t    inherit->num_ref_copies > PAGE_SIZE ||\n\t\t    inherit->num_excl_copies > PAGE_SIZE) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_inherit;\n\t\t}\n\n\t\tnums = inherit->num_qgroups + 2 * inherit->num_ref_copies +\n\t\t       2 * inherit->num_excl_copies;\n\t\tif (vol_args->size != struct_size(inherit, qgroups, nums)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_inherit;\n\t\t}\n\t}\n\n\tret = __btrfs_ioctl_snap_create(file, file_mnt_idmap(file),\n\t\t\t\t\tvol_args->name, vol_args->fd, subvol,\n\t\t\t\t\treadonly, inherit);\n\tif (ret)\n\t\tgoto free_inherit;\nfree_inherit:\n\tkfree(inherit);\nfree_args:\n\tkfree(vol_args);\n\treturn ret;\n}\n\nstatic noinline int btrfs_ioctl_subvol_getflags(struct inode *inode,\n\t\t\t\t\t\tvoid __user *arg)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret = 0;\n\tu64 flags = 0;\n\n\tif (btrfs_ino(BTRFS_I(inode)) != BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn -EINVAL;\n\n\tdown_read(&fs_info->subvol_sem);\n\tif (btrfs_root_readonly(root))\n\t\tflags |= BTRFS_SUBVOL_RDONLY;\n\tup_read(&fs_info->subvol_sem);\n\n\tif (copy_to_user(arg, &flags, sizeof(flags)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}\n\nstatic noinline int btrfs_ioctl_subvol_setflags(struct file *file,\n\t\t\t\t\t      void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\tu64 root_flags;\n\tu64 flags;\n\tint ret = 0;\n\n\tif (!inode_owner_or_capable(file_mnt_idmap(file), inode))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\tgoto out;\n\n\tif (btrfs_ino(BTRFS_I(inode)) != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = -EINVAL;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (copy_from_user(&flags, arg, sizeof(flags))) {\n\t\tret = -EFAULT;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (flags & ~BTRFS_SUBVOL_RDONLY) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_drop_write;\n\t}\n\n\tdown_write(&fs_info->subvol_sem);\n\n\t \n\tif (!!(flags & BTRFS_SUBVOL_RDONLY) == btrfs_root_readonly(root))\n\t\tgoto out_drop_sem;\n\n\troot_flags = btrfs_root_flags(&root->root_item);\n\tif (flags & BTRFS_SUBVOL_RDONLY) {\n\t\tbtrfs_set_root_flags(&root->root_item,\n\t\t\t\t     root_flags | BTRFS_ROOT_SUBVOL_RDONLY);\n\t} else {\n\t\t \n\t\tspin_lock(&root->root_item_lock);\n\t\tif (root->send_in_progress == 0) {\n\t\t\tbtrfs_set_root_flags(&root->root_item,\n\t\t\t\t     root_flags & ~BTRFS_ROOT_SUBVOL_RDONLY);\n\t\t\tspin_unlock(&root->root_item_lock);\n\t\t} else {\n\t\t\tspin_unlock(&root->root_item_lock);\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t   \"Attempt to set subvolume %llu read-write during send\",\n\t\t\t\t   root->root_key.objectid);\n\t\t\tret = -EPERM;\n\t\t\tgoto out_drop_sem;\n\t\t}\n\t}\n\n\ttrans = btrfs_start_transaction(root, 1);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_reset;\n\t}\n\n\tret = btrfs_update_root(trans, fs_info->tree_root,\n\t\t\t\t&root->root_key, &root->root_item);\n\tif (ret < 0) {\n\t\tbtrfs_end_transaction(trans);\n\t\tgoto out_reset;\n\t}\n\n\tret = btrfs_commit_transaction(trans);\n\nout_reset:\n\tif (ret)\n\t\tbtrfs_set_root_flags(&root->root_item, root_flags);\nout_drop_sem:\n\tup_write(&fs_info->subvol_sem);\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\treturn ret;\n}\n\nstatic noinline int key_in_sk(struct btrfs_key *key,\n\t\t\t      struct btrfs_ioctl_search_key *sk)\n{\n\tstruct btrfs_key test;\n\tint ret;\n\n\ttest.objectid = sk->min_objectid;\n\ttest.type = sk->min_type;\n\ttest.offset = sk->min_offset;\n\n\tret = btrfs_comp_cpu_keys(key, &test);\n\tif (ret < 0)\n\t\treturn 0;\n\n\ttest.objectid = sk->max_objectid;\n\ttest.type = sk->max_type;\n\ttest.offset = sk->max_offset;\n\n\tret = btrfs_comp_cpu_keys(key, &test);\n\tif (ret > 0)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic noinline int copy_to_sk(struct btrfs_path *path,\n\t\t\t       struct btrfs_key *key,\n\t\t\t       struct btrfs_ioctl_search_key *sk,\n\t\t\t       u64 *buf_size,\n\t\t\t       char __user *ubuf,\n\t\t\t       unsigned long *sk_offset,\n\t\t\t       int *num_found)\n{\n\tu64 found_transid;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ioctl_search_header sh;\n\tstruct btrfs_key test;\n\tunsigned long item_off;\n\tunsigned long item_len;\n\tint nritems;\n\tint i;\n\tint slot;\n\tint ret = 0;\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (btrfs_header_generation(leaf) > sk->max_transid) {\n\t\ti = nritems;\n\t\tgoto advance_key;\n\t}\n\tfound_transid = btrfs_header_generation(leaf);\n\n\tfor (i = slot; i < nritems; i++) {\n\t\titem_off = btrfs_item_ptr_offset(leaf, i);\n\t\titem_len = btrfs_item_size(leaf, i);\n\n\t\tbtrfs_item_key_to_cpu(leaf, key, i);\n\t\tif (!key_in_sk(key, sk))\n\t\t\tcontinue;\n\n\t\tif (sizeof(sh) + item_len > *buf_size) {\n\t\t\tif (*num_found) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\n\t\t\t*buf_size = sizeof(sh) + item_len;\n\t\t\titem_len = 0;\n\t\t\tret = -EOVERFLOW;\n\t\t}\n\n\t\tif (sizeof(sh) + item_len + *sk_offset > *buf_size) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsh.objectid = key->objectid;\n\t\tsh.offset = key->offset;\n\t\tsh.type = key->type;\n\t\tsh.len = item_len;\n\t\tsh.transid = found_transid;\n\n\t\t \n\t\tif (copy_to_user_nofault(ubuf + *sk_offset, &sh, sizeof(sh))) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t*sk_offset += sizeof(sh);\n\n\t\tif (item_len) {\n\t\t\tchar __user *up = ubuf + *sk_offset;\n\t\t\t \n\t\t\tif (read_extent_buffer_to_user_nofault(leaf, up,\n\t\t\t\t\t\titem_off, item_len)) {\n\t\t\t\tret = 0;\n\t\t\t\t*sk_offset -= sizeof(sh);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*sk_offset += item_len;\n\t\t}\n\t\t(*num_found)++;\n\n\t\tif (ret)  \n\t\t\tgoto out;\n\n\t\tif (*num_found >= sk->nr_items) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\nadvance_key:\n\tret = 0;\n\ttest.objectid = sk->max_objectid;\n\ttest.type = sk->max_type;\n\ttest.offset = sk->max_offset;\n\tif (btrfs_comp_cpu_keys(key, &test) >= 0)\n\t\tret = 1;\n\telse if (key->offset < (u64)-1)\n\t\tkey->offset++;\n\telse if (key->type < (u8)-1) {\n\t\tkey->offset = 0;\n\t\tkey->type++;\n\t} else if (key->objectid < (u64)-1) {\n\t\tkey->offset = 0;\n\t\tkey->type = 0;\n\t\tkey->objectid++;\n\t} else\n\t\tret = 1;\nout:\n\t \n\treturn ret;\n}\n\nstatic noinline int search_ioctl(struct inode *inode,\n\t\t\t\t struct btrfs_ioctl_search_key *sk,\n\t\t\t\t u64 *buf_size,\n\t\t\t\t char __user *ubuf)\n{\n\tstruct btrfs_fs_info *info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tint ret;\n\tint num_found = 0;\n\tunsigned long sk_offset = 0;\n\n\tif (*buf_size < sizeof(struct btrfs_ioctl_search_header)) {\n\t\t*buf_size = sizeof(struct btrfs_ioctl_search_header);\n\t\treturn -EOVERFLOW;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (sk->tree_id == 0) {\n\t\t \n\t\troot = btrfs_grab_root(BTRFS_I(inode)->root);\n\t} else {\n\t\troot = btrfs_get_fs_root(info, sk->tree_id, true);\n\t\tif (IS_ERR(root)) {\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn PTR_ERR(root);\n\t\t}\n\t}\n\n\tkey.objectid = sk->min_objectid;\n\tkey.type = sk->min_type;\n\tkey.offset = sk->min_offset;\n\n\twhile (1) {\n\t\tret = -EFAULT;\n\t\t \n\t\tif (fault_in_subpage_writeable(ubuf + sk_offset,\n\t\t\t\t\t       *buf_size - sk_offset))\n\t\t\tbreak;\n\n\t\tret = btrfs_search_forward(root, &key, path, sk->min_transid);\n\t\tif (ret != 0) {\n\t\t\tif (ret > 0)\n\t\t\t\tret = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tret = copy_to_sk(path, &key, sk, buf_size, ubuf,\n\t\t\t\t &sk_offset, &num_found);\n\t\tbtrfs_release_path(path);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t}\n\tif (ret > 0)\n\t\tret = 0;\nerr:\n\tsk->nr_items = num_found;\n\tbtrfs_put_root(root);\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic noinline int btrfs_ioctl_tree_search(struct inode *inode,\n\t\t\t\t\t    void __user *argp)\n{\n\tstruct btrfs_ioctl_search_args __user *uargs = argp;\n\tstruct btrfs_ioctl_search_key sk;\n\tint ret;\n\tu64 buf_size;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(&sk, &uargs->key, sizeof(sk)))\n\t\treturn -EFAULT;\n\n\tbuf_size = sizeof(uargs->buf);\n\n\tret = search_ioctl(inode, &sk, &buf_size, uargs->buf);\n\n\t \n\tif (ret == -EOVERFLOW)\n\t\tret = 0;\n\n\tif (ret == 0 && copy_to_user(&uargs->key, &sk, sizeof(sk)))\n\t\tret = -EFAULT;\n\treturn ret;\n}\n\nstatic noinline int btrfs_ioctl_tree_search_v2(struct inode *inode,\n\t\t\t\t\t       void __user *argp)\n{\n\tstruct btrfs_ioctl_search_args_v2 __user *uarg = argp;\n\tstruct btrfs_ioctl_search_args_v2 args;\n\tint ret;\n\tu64 buf_size;\n\tconst u64 buf_limit = SZ_16M;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t \n\tif (copy_from_user(&args, uarg, sizeof(args)))\n\t\treturn -EFAULT;\n\n\tbuf_size = args.buf_size;\n\n\t \n\tif (buf_size > buf_limit)\n\t\tbuf_size = buf_limit;\n\n\tret = search_ioctl(inode, &args.key, &buf_size,\n\t\t\t   (char __user *)(&uarg->buf[0]));\n\tif (ret == 0 && copy_to_user(&uarg->key, &args.key, sizeof(args.key)))\n\t\tret = -EFAULT;\n\telse if (ret == -EOVERFLOW &&\n\t\tcopy_to_user(&uarg->buf_size, &buf_size, sizeof(buf_size)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}\n\n \nstatic noinline int btrfs_search_path_in_tree(struct btrfs_fs_info *info,\n\t\t\t\tu64 tree_id, u64 dirid, char *name)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tchar *ptr;\n\tint ret = -1;\n\tint slot;\n\tint len;\n\tint total_len = 0;\n\tstruct btrfs_inode_ref *iref;\n\tstruct extent_buffer *l;\n\tstruct btrfs_path *path;\n\n\tif (dirid == BTRFS_FIRST_FREE_OBJECTID) {\n\t\tname[0]='\\0';\n\t\treturn 0;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tptr = &name[BTRFS_INO_LOOKUP_PATH_MAX - 1];\n\n\troot = btrfs_get_fs_root(info, tree_id, true);\n\tif (IS_ERR(root)) {\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = dirid;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_backwards(root, &key, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\telse if (ret > 0) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tiref = btrfs_item_ptr(l, slot, struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(l, iref);\n\t\tptr -= len + 1;\n\t\ttotal_len += len + 1;\n\t\tif (ptr < name) {\n\t\t\tret = -ENAMETOOLONG;\n\t\t\tgoto out;\n\t\t}\n\n\t\t*(ptr + len) = '/';\n\t\tread_extent_buffer(l, ptr, (unsigned long)(iref + 1), len);\n\n\t\tif (key.offset == BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tbreak;\n\n\t\tbtrfs_release_path(path);\n\t\tkey.objectid = key.offset;\n\t\tkey.offset = (u64)-1;\n\t\tdirid = key.objectid;\n\t}\n\tmemmove(name, ptr, total_len);\n\tname[total_len] = '\\0';\n\tret = 0;\nout:\n\tbtrfs_put_root(root);\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int btrfs_search_path_in_tree_user(struct mnt_idmap *idmap,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct btrfs_ioctl_ino_lookup_user_args *args)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct btrfs_key upper_limit = BTRFS_I(inode)->location;\n\tu64 treeid = BTRFS_I(inode)->root->root_key.objectid;\n\tu64 dirid = args->dirid;\n\tunsigned long item_off;\n\tunsigned long item_len;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_root_ref *rref;\n\tstruct btrfs_root *root = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key, key2;\n\tstruct extent_buffer *leaf;\n\tstruct inode *temp_inode;\n\tchar *ptr;\n\tint slot;\n\tint len;\n\tint total_len = 0;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t \n\tif (dirid != upper_limit.objectid) {\n\t\tptr = &args->path[BTRFS_INO_LOOKUP_USER_PATH_MAX - 1];\n\n\t\troot = btrfs_get_fs_root(fs_info, treeid, true);\n\t\tif (IS_ERR(root)) {\n\t\t\tret = PTR_ERR(root);\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey.objectid = dirid;\n\t\tkey.type = BTRFS_INODE_REF_KEY;\n\t\tkey.offset = (u64)-1;\n\t\twhile (1) {\n\t\t\tret = btrfs_search_backwards(root, &key, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_put;\n\t\t\telse if (ret > 0) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\n\t\t\tleaf = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\n\t\t\tiref = btrfs_item_ptr(leaf, slot, struct btrfs_inode_ref);\n\t\t\tlen = btrfs_inode_ref_name_len(leaf, iref);\n\t\t\tptr -= len + 1;\n\t\t\ttotal_len += len + 1;\n\t\t\tif (ptr < args->path) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\n\t\t\t*(ptr + len) = '/';\n\t\t\tread_extent_buffer(leaf, ptr,\n\t\t\t\t\t(unsigned long)(iref + 1), len);\n\n\t\t\t \n\t\t\tret = btrfs_previous_item(root, path, dirid,\n\t\t\t\t\t\t  BTRFS_INODE_ITEM_KEY);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out_put;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\n\t\t\tleaf = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key2, slot);\n\t\t\tif (key2.objectid != dirid) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\n\t\t\t \n\t\t\tbtrfs_release_path(path);\n\t\t\ttemp_inode = btrfs_iget(sb, key2.objectid, root);\n\t\t\tif (IS_ERR(temp_inode)) {\n\t\t\t\tret = PTR_ERR(temp_inode);\n\t\t\t\tgoto out_put;\n\t\t\t}\n\t\t\tret = inode_permission(idmap, temp_inode,\n\t\t\t\t\t       MAY_READ | MAY_EXEC);\n\t\t\tiput(temp_inode);\n\t\t\tif (ret) {\n\t\t\t\tret = -EACCES;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\n\t\t\tif (key.offset == upper_limit.objectid)\n\t\t\t\tbreak;\n\t\t\tif (key.objectid == BTRFS_FIRST_FREE_OBJECTID) {\n\t\t\t\tret = -EACCES;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\n\t\t\tkey.objectid = key.offset;\n\t\t\tkey.offset = (u64)-1;\n\t\t\tdirid = key.objectid;\n\t\t}\n\n\t\tmemmove(args->path, ptr, total_len);\n\t\targs->path[total_len] = '\\0';\n\t\tbtrfs_put_root(root);\n\t\troot = NULL;\n\t\tbtrfs_release_path(path);\n\t}\n\n\t \n\tkey.objectid = treeid;\n\tkey.type = BTRFS_ROOT_REF_KEY;\n\tkey.offset = args->treeid;\n\tret = btrfs_search_slot(NULL, fs_info->tree_root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\n\titem_off = btrfs_item_ptr_offset(leaf, slot);\n\titem_len = btrfs_item_size(leaf, slot);\n\t \n\trref = btrfs_item_ptr(leaf, slot, struct btrfs_root_ref);\n\tif (args->dirid != btrfs_root_ref_dirid(leaf, rref)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\titem_off += sizeof(struct btrfs_root_ref);\n\titem_len -= sizeof(struct btrfs_root_ref);\n\tread_extent_buffer(leaf, args->name, item_off, item_len);\n\targs->name[item_len] = 0;\n\nout_put:\n\tbtrfs_put_root(root);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic noinline int btrfs_ioctl_ino_lookup(struct btrfs_root *root,\n\t\t\t\t\t   void __user *argp)\n{\n\tstruct btrfs_ioctl_ino_lookup_args *args;\n\tint ret = 0;\n\n\targs = memdup_user(argp, sizeof(*args));\n\tif (IS_ERR(args))\n\t\treturn PTR_ERR(args);\n\n\t \n\tif (args->treeid == 0)\n\t\targs->treeid = root->root_key.objectid;\n\n\tif (args->objectid == BTRFS_FIRST_FREE_OBJECTID) {\n\t\targs->name[0] = 0;\n\t\tgoto out;\n\t}\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_search_path_in_tree(root->fs_info,\n\t\t\t\t\targs->treeid, args->objectid,\n\t\t\t\t\targs->name);\n\nout:\n\tif (ret == 0 && copy_to_user(argp, args, sizeof(*args)))\n\t\tret = -EFAULT;\n\n\tkfree(args);\n\treturn ret;\n}\n\n \nstatic int btrfs_ioctl_ino_lookup_user(struct file *file, void __user *argp)\n{\n\tstruct btrfs_ioctl_ino_lookup_user_args *args;\n\tstruct inode *inode;\n\tint ret;\n\n\targs = memdup_user(argp, sizeof(*args));\n\tif (IS_ERR(args))\n\t\treturn PTR_ERR(args);\n\n\tinode = file_inode(file);\n\n\tif (args->dirid == BTRFS_FIRST_FREE_OBJECTID &&\n\t    BTRFS_I(inode)->location.objectid != BTRFS_FIRST_FREE_OBJECTID) {\n\t\t \n\t\tkfree(args);\n\t\treturn -EACCES;\n\t}\n\n\tret = btrfs_search_path_in_tree_user(file_mnt_idmap(file), inode, args);\n\n\tif (ret == 0 && copy_to_user(argp, args, sizeof(*args)))\n\t\tret = -EFAULT;\n\n\tkfree(args);\n\treturn ret;\n}\n\n \nstatic int btrfs_ioctl_get_subvol_info(struct inode *inode, void __user *argp)\n{\n\tstruct btrfs_ioctl_get_subvol_info_args *subvol_info;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_root_ref *rref;\n\tstruct extent_buffer *leaf;\n\tunsigned long item_off;\n\tunsigned long item_len;\n\tint slot;\n\tint ret = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tsubvol_info = kzalloc(sizeof(*subvol_info), GFP_KERNEL);\n\tif (!subvol_info) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\tfs_info = BTRFS_I(inode)->root->fs_info;\n\n\t \n\tkey.objectid = BTRFS_I(inode)->root->root_key.objectid;\n\troot = btrfs_get_fs_root(fs_info, key.objectid, true);\n\tif (IS_ERR(root)) {\n\t\tret = PTR_ERR(root);\n\t\tgoto out_free;\n\t}\n\troot_item = &root->root_item;\n\n\tsubvol_info->treeid = key.objectid;\n\n\tsubvol_info->generation = btrfs_root_generation(root_item);\n\tsubvol_info->flags = btrfs_root_flags(root_item);\n\n\tmemcpy(subvol_info->uuid, root_item->uuid, BTRFS_UUID_SIZE);\n\tmemcpy(subvol_info->parent_uuid, root_item->parent_uuid,\n\t\t\t\t\t\t    BTRFS_UUID_SIZE);\n\tmemcpy(subvol_info->received_uuid, root_item->received_uuid,\n\t\t\t\t\t\t    BTRFS_UUID_SIZE);\n\n\tsubvol_info->ctransid = btrfs_root_ctransid(root_item);\n\tsubvol_info->ctime.sec = btrfs_stack_timespec_sec(&root_item->ctime);\n\tsubvol_info->ctime.nsec = btrfs_stack_timespec_nsec(&root_item->ctime);\n\n\tsubvol_info->otransid = btrfs_root_otransid(root_item);\n\tsubvol_info->otime.sec = btrfs_stack_timespec_sec(&root_item->otime);\n\tsubvol_info->otime.nsec = btrfs_stack_timespec_nsec(&root_item->otime);\n\n\tsubvol_info->stransid = btrfs_root_stransid(root_item);\n\tsubvol_info->stime.sec = btrfs_stack_timespec_sec(&root_item->stime);\n\tsubvol_info->stime.nsec = btrfs_stack_timespec_nsec(&root_item->stime);\n\n\tsubvol_info->rtransid = btrfs_root_rtransid(root_item);\n\tsubvol_info->rtime.sec = btrfs_stack_timespec_sec(&root_item->rtime);\n\tsubvol_info->rtime.nsec = btrfs_stack_timespec_nsec(&root_item->rtime);\n\n\tif (key.objectid != BTRFS_FS_TREE_OBJECTID) {\n\t\t \n\t\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\t\tkey.offset = 0;\n\t\tret = btrfs_search_slot(NULL, fs_info->tree_root, &key, path, 0, 0);\n\t\tif (ret < 0) {\n\t\t\tgoto out;\n\t\t} else if (path->slots[0] >=\n\t\t\t   btrfs_header_nritems(path->nodes[0])) {\n\t\t\tret = btrfs_next_leaf(fs_info->tree_root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = -EUCLEAN;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid == subvol_info->treeid &&\n\t\t    key.type == BTRFS_ROOT_BACKREF_KEY) {\n\t\t\tsubvol_info->parent_id = key.offset;\n\n\t\t\trref = btrfs_item_ptr(leaf, slot, struct btrfs_root_ref);\n\t\t\tsubvol_info->dirid = btrfs_root_ref_dirid(leaf, rref);\n\n\t\t\titem_off = btrfs_item_ptr_offset(leaf, slot)\n\t\t\t\t\t+ sizeof(struct btrfs_root_ref);\n\t\t\titem_len = btrfs_item_size(leaf, slot)\n\t\t\t\t\t- sizeof(struct btrfs_root_ref);\n\t\t\tread_extent_buffer(leaf, subvol_info->name,\n\t\t\t\t\t   item_off, item_len);\n\t\t} else {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tbtrfs_free_path(path);\n\tpath = NULL;\n\tif (copy_to_user(argp, subvol_info, sizeof(*subvol_info)))\n\t\tret = -EFAULT;\n\nout:\n\tbtrfs_put_root(root);\nout_free:\n\tbtrfs_free_path(path);\n\tkfree(subvol_info);\n\treturn ret;\n}\n\n \nstatic int btrfs_ioctl_get_subvol_rootref(struct btrfs_root *root,\n\t\t\t\t\t  void __user *argp)\n{\n\tstruct btrfs_ioctl_get_subvol_rootref_args *rootrefs;\n\tstruct btrfs_root_ref *rref;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tu64 objectid;\n\tint slot;\n\tint ret;\n\tu8 found;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\trootrefs = memdup_user(argp, sizeof(*rootrefs));\n\tif (IS_ERR(rootrefs)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(rootrefs);\n\t}\n\n\tobjectid = root->root_key.objectid;\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_ROOT_REF_KEY;\n\tkey.offset = rootrefs->min_treeid;\n\tfound = 0;\n\n\troot = root->fs_info->tree_root;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (path->slots[0] >=\n\t\t   btrfs_header_nritems(path->nodes[0])) {\n\t\tret = btrfs_next_leaf(root, path);\n\t\tif (ret < 0) {\n\t\t\tgoto out;\n\t\t} else if (ret > 0) {\n\t\t\tret = -EUCLEAN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\twhile (1) {\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid != objectid || key.type != BTRFS_ROOT_REF_KEY) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (found == BTRFS_MAX_ROOTREF_BUFFER_NUM) {\n\t\t\tret = -EOVERFLOW;\n\t\t\tgoto out;\n\t\t}\n\n\t\trref = btrfs_item_ptr(leaf, slot, struct btrfs_root_ref);\n\t\trootrefs->rootref[found].treeid = key.offset;\n\t\trootrefs->rootref[found].dirid =\n\t\t\t\t  btrfs_root_ref_dirid(leaf, rref);\n\t\tfound++;\n\n\t\tret = btrfs_next_item(root, path);\n\t\tif (ret < 0) {\n\t\t\tgoto out;\n\t\t} else if (ret > 0) {\n\t\t\tret = -EUCLEAN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\n\tif (!ret || ret == -EOVERFLOW) {\n\t\trootrefs->num_items = found;\n\t\t \n\t\tif (found)\n\t\t\trootrefs->min_treeid =\n\t\t\t\trootrefs->rootref[found - 1].treeid + 1;\n\t\tif (copy_to_user(argp, rootrefs, sizeof(*rootrefs)))\n\t\t\tret = -EFAULT;\n\t}\n\n\tkfree(rootrefs);\n\n\treturn ret;\n}\n\nstatic noinline int btrfs_ioctl_snap_destroy(struct file *file,\n\t\t\t\t\t     void __user *arg,\n\t\t\t\t\t     bool destroy_v2)\n{\n\tstruct dentry *parent = file->f_path.dentry;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(parent->d_sb);\n\tstruct dentry *dentry;\n\tstruct inode *dir = d_inode(parent);\n\tstruct inode *inode;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_root *dest = NULL;\n\tstruct btrfs_ioctl_vol_args *vol_args = NULL;\n\tstruct btrfs_ioctl_vol_args_v2 *vol_args2 = NULL;\n\tstruct mnt_idmap *idmap = file_mnt_idmap(file);\n\tchar *subvol_name, *subvol_name_ptr = NULL;\n\tint subvol_namelen;\n\tint err = 0;\n\tbool destroy_parent = false;\n\n\t \n\tif (btrfs_fs_incompat(fs_info, EXTENT_TREE_V2)) {\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"extent tree v2 doesn't support snapshot deletion yet\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (destroy_v2) {\n\t\tvol_args2 = memdup_user(arg, sizeof(*vol_args2));\n\t\tif (IS_ERR(vol_args2))\n\t\t\treturn PTR_ERR(vol_args2);\n\n\t\tif (vol_args2->flags & ~BTRFS_SUBVOL_DELETE_ARGS_MASK) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (!(vol_args2->flags & BTRFS_SUBVOL_SPEC_BY_ID)) {\n\t\t\tvol_args2->name[BTRFS_SUBVOL_NAME_MAX] = 0;\n\t\t\tsubvol_name = vol_args2->name;\n\n\t\t\terr = mnt_want_write_file(file);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tstruct inode *old_dir;\n\n\t\t\tif (vol_args2->subvolid < BTRFS_FIRST_FREE_OBJECTID) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = mnt_want_write_file(file);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tdentry = btrfs_get_dentry(fs_info->sb,\n\t\t\t\t\tBTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\t\tvol_args2->subvolid, 0);\n\t\t\tif (IS_ERR(dentry)) {\n\t\t\t\terr = PTR_ERR(dentry);\n\t\t\t\tgoto out_drop_write;\n\t\t\t}\n\n\t\t\t \n\t\t\tparent = btrfs_get_parent(dentry);\n\n\t\t\t \n\t\t\tdput(dentry);\n\t\t\tif (IS_ERR(parent)) {\n\t\t\t\terr = PTR_ERR(parent);\n\t\t\t\tgoto out_drop_write;\n\t\t\t}\n\t\t\told_dir = dir;\n\t\t\tdir = d_inode(parent);\n\n\t\t\t \n\t\t\tdestroy_parent = true;\n\n\t\t\t \n\t\t\tif (old_dir != dir && idmap != &nop_mnt_idmap) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto free_parent;\n\t\t\t}\n\n\t\t\tsubvol_name_ptr = btrfs_get_subvol_name_from_objectid(\n\t\t\t\t\t\tfs_info, vol_args2->subvolid);\n\t\t\tif (IS_ERR(subvol_name_ptr)) {\n\t\t\t\terr = PTR_ERR(subvol_name_ptr);\n\t\t\t\tgoto free_parent;\n\t\t\t}\n\t\t\t \n\t\t\tsubvol_name = (char *)kbasename(subvol_name_ptr);\n\t\t}\n\t} else {\n\t\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\t\tif (IS_ERR(vol_args))\n\t\t\treturn PTR_ERR(vol_args);\n\n\t\tvol_args->name[BTRFS_PATH_NAME_MAX] = 0;\n\t\tsubvol_name = vol_args->name;\n\n\t\terr = mnt_want_write_file(file);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tsubvol_namelen = strlen(subvol_name);\n\n\tif (strchr(subvol_name, '/') ||\n\t    strncmp(subvol_name, \"..\", subvol_namelen) == 0) {\n\t\terr = -EINVAL;\n\t\tgoto free_subvol_name;\n\t}\n\n\tif (!S_ISDIR(dir->i_mode)) {\n\t\terr = -ENOTDIR;\n\t\tgoto free_subvol_name;\n\t}\n\n\terr = down_write_killable_nested(&dir->i_rwsem, I_MUTEX_PARENT);\n\tif (err == -EINTR)\n\t\tgoto free_subvol_name;\n\tdentry = lookup_one(idmap, subvol_name, parent, subvol_namelen);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out_unlock_dir;\n\t}\n\n\tif (d_really_is_negative(dentry)) {\n\t\terr = -ENOENT;\n\t\tgoto out_dput;\n\t}\n\n\tinode = d_inode(dentry);\n\tdest = BTRFS_I(inode)->root;\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t \n\t\terr = -EPERM;\n\t\tif (!btrfs_test_opt(fs_info, USER_SUBVOL_RM_ALLOWED))\n\t\t\tgoto out_dput;\n\n\t\t \n\t\terr = -EINVAL;\n\t\tif (root == dest)\n\t\t\tgoto out_dput;\n\n\t\terr = inode_permission(idmap, inode, MAY_WRITE | MAY_EXEC);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\n\n\t \n\terr = btrfs_may_delete(idmap, dir, dentry, 1);\n\tif (err)\n\t\tgoto out_dput;\n\n\tif (btrfs_ino(BTRFS_I(inode)) != BTRFS_FIRST_FREE_OBJECTID) {\n\t\terr = -EINVAL;\n\t\tgoto out_dput;\n\t}\n\n\tbtrfs_inode_lock(BTRFS_I(inode), 0);\n\terr = btrfs_delete_subvolume(BTRFS_I(dir), dentry);\n\tbtrfs_inode_unlock(BTRFS_I(inode), 0);\n\tif (!err)\n\t\td_delete_notify(dir, dentry);\n\nout_dput:\n\tdput(dentry);\nout_unlock_dir:\n\tbtrfs_inode_unlock(BTRFS_I(dir), 0);\nfree_subvol_name:\n\tkfree(subvol_name_ptr);\nfree_parent:\n\tif (destroy_parent)\n\t\tdput(parent);\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\tkfree(vol_args2);\n\tkfree(vol_args);\n\treturn err;\n}\n\nstatic int btrfs_ioctl_defrag(struct file *file, void __user *argp)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ioctl_defrag_range_args range = {0};\n\tint ret;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (btrfs_root_readonly(root)) {\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = btrfs_defrag_root(root);\n\t\tbreak;\n\tcase S_IFREG:\n\t\t \n\t\tif (!capable(CAP_SYS_ADMIN) &&\n\t\t    inode_permission(&nop_mnt_idmap, inode, MAY_WRITE)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (argp) {\n\t\t\tif (copy_from_user(&range, argp, sizeof(range))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\tif ((range.flags & BTRFS_DEFRAG_RANGE_COMPRESS)) {\n\t\t\t\trange.flags |= BTRFS_DEFRAG_RANGE_START_IO;\n\t\t\t\trange.extent_thresh = (u32)-1;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\trange.len = (u64)-1;\n\t\t}\n\t\tret = btrfs_defrag_file(file_inode(file), &file->f_ra,\n\t\t\t\t\t&range, BTRFS_OLDEST_GENERATION, 0);\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nout:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_add_dev(struct btrfs_fs_info *fs_info, void __user *arg)\n{\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tbool restore_op = false;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (btrfs_fs_incompat(fs_info, EXTENT_TREE_V2)) {\n\t\tbtrfs_err(fs_info, \"device add not supported on extent tree v2 yet\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!btrfs_exclop_start(fs_info, BTRFS_EXCLOP_DEV_ADD)) {\n\t\tif (!btrfs_exclop_start_try_lock(fs_info, BTRFS_EXCLOP_DEV_ADD))\n\t\t\treturn BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\n\t\t \n\t\tfs_info->exclusive_operation = BTRFS_EXCLOP_DEV_ADD;\n\t\tbtrfs_exclop_start_unlock(fs_info);\n\t\trestore_op = true;\n\t}\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto out;\n\t}\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\tret = btrfs_init_new_device(fs_info, vol_args->name);\n\n\tif (!ret)\n\t\tbtrfs_info(fs_info, \"disk added %s\", vol_args->name);\n\n\tkfree(vol_args);\nout:\n\tif (restore_op)\n\t\tbtrfs_exclop_balance(fs_info, BTRFS_EXCLOP_BALANCE_PAUSED);\n\telse\n\t\tbtrfs_exclop_finish(fs_info);\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_rm_dev_v2(struct file *file, void __user *arg)\n{\n\tBTRFS_DEV_LOOKUP_ARGS(args);\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_ioctl_vol_args_v2 *vol_args;\n\tstruct block_device *bdev = NULL;\n\tvoid *holder;\n\tint ret;\n\tbool cancel = false;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args))\n\t\treturn PTR_ERR(vol_args);\n\n\tif (vol_args->flags & ~BTRFS_DEVICE_REMOVE_ARGS_MASK) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tvol_args->name[BTRFS_SUBVOL_NAME_MAX] = '\\0';\n\tif (vol_args->flags & BTRFS_DEVICE_SPEC_BY_ID) {\n\t\targs.devid = vol_args->devid;\n\t} else if (!strcmp(\"cancel\", vol_args->name)) {\n\t\tcancel = true;\n\t} else {\n\t\tret = btrfs_get_dev_args_from_path(fs_info, &args, vol_args->name);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = exclop_start_or_cancel_reloc(fs_info, BTRFS_EXCLOP_DEV_REMOVE,\n\t\t\t\t\t   cancel);\n\tif (ret)\n\t\tgoto err_drop;\n\n\t \n\tret = btrfs_rm_device(fs_info, &args, &bdev, &holder);\n\n\tbtrfs_exclop_finish(fs_info);\n\n\tif (!ret) {\n\t\tif (vol_args->flags & BTRFS_DEVICE_SPEC_BY_ID)\n\t\t\tbtrfs_info(fs_info, \"device deleted: id %llu\",\n\t\t\t\t\tvol_args->devid);\n\t\telse\n\t\t\tbtrfs_info(fs_info, \"device deleted: %s\",\n\t\t\t\t\tvol_args->name);\n\t}\nerr_drop:\n\tmnt_drop_write_file(file);\n\tif (bdev)\n\t\tblkdev_put(bdev, holder);\nout:\n\tbtrfs_put_dev_args_from_path(&args);\n\tkfree(vol_args);\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_rm_dev(struct file *file, void __user *arg)\n{\n\tBTRFS_DEV_LOOKUP_ARGS(args);\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tstruct block_device *bdev = NULL;\n\tvoid *holder;\n\tint ret;\n\tbool cancel = false;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args))\n\t\treturn PTR_ERR(vol_args);\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\tif (!strcmp(\"cancel\", vol_args->name)) {\n\t\tcancel = true;\n\t} else {\n\t\tret = btrfs_get_dev_args_from_path(fs_info, &args, vol_args->name);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = exclop_start_or_cancel_reloc(fs_info, BTRFS_EXCLOP_DEV_REMOVE,\n\t\t\t\t\t   cancel);\n\tif (ret == 0) {\n\t\tret = btrfs_rm_device(fs_info, &args, &bdev, &holder);\n\t\tif (!ret)\n\t\t\tbtrfs_info(fs_info, \"disk deleted %s\", vol_args->name);\n\t\tbtrfs_exclop_finish(fs_info);\n\t}\n\n\tmnt_drop_write_file(file);\n\tif (bdev)\n\t\tblkdev_put(bdev, holder);\nout:\n\tbtrfs_put_dev_args_from_path(&args);\n\tkfree(vol_args);\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_fs_info(struct btrfs_fs_info *fs_info,\n\t\t\t\tvoid __user *arg)\n{\n\tstruct btrfs_ioctl_fs_info_args *fi_args;\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tu64 flags_in;\n\tint ret = 0;\n\n\tfi_args = memdup_user(arg, sizeof(*fi_args));\n\tif (IS_ERR(fi_args))\n\t\treturn PTR_ERR(fi_args);\n\n\tflags_in = fi_args->flags;\n\tmemset(fi_args, 0, sizeof(*fi_args));\n\n\trcu_read_lock();\n\tfi_args->num_devices = fs_devices->num_devices;\n\n\tlist_for_each_entry_rcu(device, &fs_devices->devices, dev_list) {\n\t\tif (device->devid > fi_args->max_id)\n\t\t\tfi_args->max_id = device->devid;\n\t}\n\trcu_read_unlock();\n\n\tmemcpy(&fi_args->fsid, fs_devices->fsid, sizeof(fi_args->fsid));\n\tfi_args->nodesize = fs_info->nodesize;\n\tfi_args->sectorsize = fs_info->sectorsize;\n\tfi_args->clone_alignment = fs_info->sectorsize;\n\n\tif (flags_in & BTRFS_FS_INFO_FLAG_CSUM_INFO) {\n\t\tfi_args->csum_type = btrfs_super_csum_type(fs_info->super_copy);\n\t\tfi_args->csum_size = btrfs_super_csum_size(fs_info->super_copy);\n\t\tfi_args->flags |= BTRFS_FS_INFO_FLAG_CSUM_INFO;\n\t}\n\n\tif (flags_in & BTRFS_FS_INFO_FLAG_GENERATION) {\n\t\tfi_args->generation = fs_info->generation;\n\t\tfi_args->flags |= BTRFS_FS_INFO_FLAG_GENERATION;\n\t}\n\n\tif (flags_in & BTRFS_FS_INFO_FLAG_METADATA_UUID) {\n\t\tmemcpy(&fi_args->metadata_uuid, fs_devices->metadata_uuid,\n\t\t       sizeof(fi_args->metadata_uuid));\n\t\tfi_args->flags |= BTRFS_FS_INFO_FLAG_METADATA_UUID;\n\t}\n\n\tif (copy_to_user(arg, fi_args, sizeof(*fi_args)))\n\t\tret = -EFAULT;\n\n\tkfree(fi_args);\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_dev_info(struct btrfs_fs_info *fs_info,\n\t\t\t\t void __user *arg)\n{\n\tBTRFS_DEV_LOOKUP_ARGS(args);\n\tstruct btrfs_ioctl_dev_info_args *di_args;\n\tstruct btrfs_device *dev;\n\tint ret = 0;\n\n\tdi_args = memdup_user(arg, sizeof(*di_args));\n\tif (IS_ERR(di_args))\n\t\treturn PTR_ERR(di_args);\n\n\targs.devid = di_args->devid;\n\tif (!btrfs_is_empty_uuid(di_args->uuid))\n\t\targs.uuid = di_args->uuid;\n\n\trcu_read_lock();\n\tdev = btrfs_find_device(fs_info->fs_devices, &args);\n\tif (!dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tdi_args->devid = dev->devid;\n\tdi_args->bytes_used = btrfs_device_get_bytes_used(dev);\n\tdi_args->total_bytes = btrfs_device_get_total_bytes(dev);\n\tmemcpy(di_args->uuid, dev->uuid, sizeof(di_args->uuid));\n\tmemcpy(di_args->fsid, dev->fs_devices->fsid, BTRFS_UUID_SIZE);\n\tif (dev->name)\n\t\tstrscpy(di_args->path, btrfs_dev_name(dev), sizeof(di_args->path));\n\telse\n\t\tdi_args->path[0] = '\\0';\n\nout:\n\trcu_read_unlock();\n\tif (ret == 0 && copy_to_user(arg, di_args, sizeof(*di_args)))\n\t\tret = -EFAULT;\n\n\tkfree(di_args);\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_default_subvol(struct file *file, void __user *argp)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_root *new_root;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_disk_key disk_key;\n\tstruct fscrypt_str name = FSTR_INIT(\"default\", 7);\n\tu64 objectid = 0;\n\tu64 dir_id;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_from_user(&objectid, argp, sizeof(objectid))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (!objectid)\n\t\tobjectid = BTRFS_FS_TREE_OBJECTID;\n\n\tnew_root = btrfs_get_fs_root(fs_info, objectid, true);\n\tif (IS_ERR(new_root)) {\n\t\tret = PTR_ERR(new_root);\n\t\tgoto out;\n\t}\n\tif (!is_fstree(new_root->root_key.objectid)) {\n\t\tret = -ENOENT;\n\t\tgoto out_free;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\ttrans = btrfs_start_transaction(root, 1);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_free;\n\t}\n\n\tdir_id = btrfs_super_root_dir(fs_info->super_copy);\n\tdi = btrfs_lookup_dir_item(trans, fs_info->tree_root, path,\n\t\t\t\t   dir_id, &name, 1);\n\tif (IS_ERR_OR_NULL(di)) {\n\t\tbtrfs_release_path(path);\n\t\tbtrfs_end_transaction(trans);\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"Umm, you don't have the default diritem, this isn't going to work\");\n\t\tret = -ENOENT;\n\t\tgoto out_free;\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, &new_root->root_key);\n\tbtrfs_set_dir_item_key(path->nodes[0], di, &disk_key);\n\tbtrfs_mark_buffer_dirty(trans, path->nodes[0]);\n\tbtrfs_release_path(path);\n\n\tbtrfs_set_fs_incompat(fs_info, DEFAULT_SUBVOL);\n\tbtrfs_end_transaction(trans);\nout_free:\n\tbtrfs_put_root(new_root);\n\tbtrfs_free_path(path);\nout:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}\n\nstatic void get_block_group_info(struct list_head *groups_list,\n\t\t\t\t struct btrfs_ioctl_space_info *space)\n{\n\tstruct btrfs_block_group *block_group;\n\n\tspace->total_bytes = 0;\n\tspace->used_bytes = 0;\n\tspace->flags = 0;\n\tlist_for_each_entry(block_group, groups_list, list) {\n\t\tspace->flags = block_group->flags;\n\t\tspace->total_bytes += block_group->length;\n\t\tspace->used_bytes += block_group->used;\n\t}\n}\n\nstatic long btrfs_ioctl_space_info(struct btrfs_fs_info *fs_info,\n\t\t\t\t   void __user *arg)\n{\n\tstruct btrfs_ioctl_space_args space_args = { 0 };\n\tstruct btrfs_ioctl_space_info space;\n\tstruct btrfs_ioctl_space_info *dest;\n\tstruct btrfs_ioctl_space_info *dest_orig;\n\tstruct btrfs_ioctl_space_info __user *user_dest;\n\tstruct btrfs_space_info *info;\n\tstatic const u64 types[] = {\n\t\tBTRFS_BLOCK_GROUP_DATA,\n\t\tBTRFS_BLOCK_GROUP_SYSTEM,\n\t\tBTRFS_BLOCK_GROUP_METADATA,\n\t\tBTRFS_BLOCK_GROUP_DATA | BTRFS_BLOCK_GROUP_METADATA\n\t};\n\tint num_types = 4;\n\tint alloc_size;\n\tint ret = 0;\n\tu64 slot_count = 0;\n\tint i, c;\n\n\tif (copy_from_user(&space_args,\n\t\t\t   (struct btrfs_ioctl_space_args __user *)arg,\n\t\t\t   sizeof(space_args)))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tinfo = NULL;\n\t\tlist_for_each_entry(tmp, &fs_info->space_info, list) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!info)\n\t\t\tcontinue;\n\n\t\tdown_read(&info->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&info->block_groups[c]))\n\t\t\t\tslot_count++;\n\t\t}\n\t\tup_read(&info->groups_sem);\n\t}\n\n\t \n\tslot_count++;\n\n\t \n\tif (space_args.space_slots == 0) {\n\t\tspace_args.total_spaces = slot_count;\n\t\tgoto out;\n\t}\n\n\tslot_count = min_t(u64, space_args.space_slots, slot_count);\n\n\talloc_size = sizeof(*dest) * slot_count;\n\n\t \n\tif (alloc_size > PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\tspace_args.total_spaces = 0;\n\tdest = kmalloc(alloc_size, GFP_KERNEL);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\tdest_orig = dest;\n\n\t \n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tif (!slot_count)\n\t\t\tbreak;\n\n\t\tinfo = NULL;\n\t\tlist_for_each_entry(tmp, &fs_info->space_info, list) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!info)\n\t\t\tcontinue;\n\t\tdown_read(&info->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&info->block_groups[c])) {\n\t\t\t\tget_block_group_info(&info->block_groups[c],\n\t\t\t\t\t\t     &space);\n\t\t\t\tmemcpy(dest, &space, sizeof(space));\n\t\t\t\tdest++;\n\t\t\t\tspace_args.total_spaces++;\n\t\t\t\tslot_count--;\n\t\t\t}\n\t\t\tif (!slot_count)\n\t\t\t\tbreak;\n\t\t}\n\t\tup_read(&info->groups_sem);\n\t}\n\n\t \n\tif (slot_count) {\n\t\tstruct btrfs_block_rsv *block_rsv = &fs_info->global_block_rsv;\n\n\t\tspin_lock(&block_rsv->lock);\n\t\tspace.total_bytes = block_rsv->size;\n\t\tspace.used_bytes = block_rsv->size - block_rsv->reserved;\n\t\tspin_unlock(&block_rsv->lock);\n\t\tspace.flags = BTRFS_SPACE_INFO_GLOBAL_RSV;\n\t\tmemcpy(dest, &space, sizeof(space));\n\t\tspace_args.total_spaces++;\n\t}\n\n\tuser_dest = (struct btrfs_ioctl_space_info __user *)\n\t\t(arg + sizeof(struct btrfs_ioctl_space_args));\n\n\tif (copy_to_user(user_dest, dest_orig, alloc_size))\n\t\tret = -EFAULT;\n\n\tkfree(dest_orig);\nout:\n\tif (ret == 0 && copy_to_user(arg, &space_args, sizeof(space_args)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}\n\nstatic noinline long btrfs_ioctl_start_sync(struct btrfs_root *root,\n\t\t\t\t\t    void __user *argp)\n{\n\tstruct btrfs_trans_handle *trans;\n\tu64 transid;\n\n\t \n\tbtrfs_orphan_cleanup(root);\n\n\ttrans = btrfs_attach_transaction_barrier(root);\n\tif (IS_ERR(trans)) {\n\t\tif (PTR_ERR(trans) != -ENOENT)\n\t\t\treturn PTR_ERR(trans);\n\n\t\t \n\t\ttransid = root->fs_info->last_trans_committed;\n\t\tgoto out;\n\t}\n\ttransid = trans->transid;\n\tbtrfs_commit_transaction_async(trans);\nout:\n\tif (argp)\n\t\tif (copy_to_user(argp, &transid, sizeof(transid)))\n\t\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic noinline long btrfs_ioctl_wait_sync(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   void __user *argp)\n{\n\t \n\tu64 transid = 0;\n\n\tif (argp)\n\t\tif (copy_from_user(&transid, argp, sizeof(transid)))\n\t\t\treturn -EFAULT;\n\n\treturn btrfs_wait_for_commit(fs_info, transid);\n}\n\nstatic long btrfs_ioctl_scrub(struct file *file, void __user *arg)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(file_inode(file)->i_sb);\n\tstruct btrfs_ioctl_scrub_args *sa;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (btrfs_fs_incompat(fs_info, EXTENT_TREE_V2)) {\n\t\tbtrfs_err(fs_info, \"scrub is not supported on extent tree v2 yet\");\n\t\treturn -EINVAL;\n\t}\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa))\n\t\treturn PTR_ERR(sa);\n\n\tif (sa->flags & ~BTRFS_SCRUB_SUPPORTED_FLAGS) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (!(sa->flags & BTRFS_SCRUB_READONLY)) {\n\t\tret = mnt_want_write_file(file);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = btrfs_scrub_dev(fs_info, sa->devid, sa->start, sa->end,\n\t\t\t      &sa->progress, sa->flags & BTRFS_SCRUB_READONLY,\n\t\t\t      0);\n\n\t \n\tif (copy_to_user(arg, sa, sizeof(*sa)))\n\t\tret = -EFAULT;\n\n\tif (!(sa->flags & BTRFS_SCRUB_READONLY))\n\t\tmnt_drop_write_file(file);\nout:\n\tkfree(sa);\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_scrub_cancel(struct btrfs_fs_info *fs_info)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btrfs_scrub_cancel(fs_info);\n}\n\nstatic long btrfs_ioctl_scrub_progress(struct btrfs_fs_info *fs_info,\n\t\t\t\t       void __user *arg)\n{\n\tstruct btrfs_ioctl_scrub_args *sa;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa))\n\t\treturn PTR_ERR(sa);\n\n\tret = btrfs_scrub_progress(fs_info, sa->devid, &sa->progress);\n\n\tif (ret == 0 && copy_to_user(arg, sa, sizeof(*sa)))\n\t\tret = -EFAULT;\n\n\tkfree(sa);\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_get_dev_stats(struct btrfs_fs_info *fs_info,\n\t\t\t\t      void __user *arg)\n{\n\tstruct btrfs_ioctl_get_dev_stats *sa;\n\tint ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa))\n\t\treturn PTR_ERR(sa);\n\n\tif ((sa->flags & BTRFS_DEV_STATS_RESET) && !capable(CAP_SYS_ADMIN)) {\n\t\tkfree(sa);\n\t\treturn -EPERM;\n\t}\n\n\tret = btrfs_get_dev_stats(fs_info, sa);\n\n\tif (ret == 0 && copy_to_user(arg, sa, sizeof(*sa)))\n\t\tret = -EFAULT;\n\n\tkfree(sa);\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_dev_replace(struct btrfs_fs_info *fs_info,\n\t\t\t\t    void __user *arg)\n{\n\tstruct btrfs_ioctl_dev_replace_args *p;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (btrfs_fs_incompat(fs_info, EXTENT_TREE_V2)) {\n\t\tbtrfs_err(fs_info, \"device replace not supported on extent tree v2 yet\");\n\t\treturn -EINVAL;\n\t}\n\n\tp = memdup_user(arg, sizeof(*p));\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tswitch (p->cmd) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_CMD_START:\n\t\tif (sb_rdonly(fs_info->sb)) {\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!btrfs_exclop_start(fs_info, BTRFS_EXCLOP_DEV_REPLACE)) {\n\t\t\tret = BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t\t} else {\n\t\t\tret = btrfs_dev_replace_by_ioctl(fs_info, p);\n\t\t\tbtrfs_exclop_finish(fs_info);\n\t\t}\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_CMD_STATUS:\n\t\tbtrfs_dev_replace_status(fs_info, p);\n\t\tret = 0;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_CMD_CANCEL:\n\t\tp->result = btrfs_dev_replace_cancel(fs_info);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif ((ret == 0 || ret == -ECANCELED) && copy_to_user(arg, p, sizeof(*p)))\n\t\tret = -EFAULT;\nout:\n\tkfree(p);\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_ino_to_path(struct btrfs_root *root, void __user *arg)\n{\n\tint ret = 0;\n\tint i;\n\tu64 rel_ptr;\n\tint size;\n\tstruct btrfs_ioctl_ino_path_args *ipa = NULL;\n\tstruct inode_fs_paths *ipath = NULL;\n\tstruct btrfs_path *path;\n\n\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\treturn -EPERM;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tipa = memdup_user(arg, sizeof(*ipa));\n\tif (IS_ERR(ipa)) {\n\t\tret = PTR_ERR(ipa);\n\t\tipa = NULL;\n\t\tgoto out;\n\t}\n\n\tsize = min_t(u32, ipa->size, 4096);\n\tipath = init_ipath(size, root, path);\n\tif (IS_ERR(ipath)) {\n\t\tret = PTR_ERR(ipath);\n\t\tipath = NULL;\n\t\tgoto out;\n\t}\n\n\tret = paths_from_inode(ipa->inum, ipath);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < ipath->fspath->elem_cnt; ++i) {\n\t\trel_ptr = ipath->fspath->val[i] -\n\t\t\t  (u64)(unsigned long)ipath->fspath->val;\n\t\tipath->fspath->val[i] = rel_ptr;\n\t}\n\n\tbtrfs_free_path(path);\n\tpath = NULL;\n\tret = copy_to_user((void __user *)(unsigned long)ipa->fspath,\n\t\t\t   ipath->fspath, size);\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tfree_ipath(ipath);\n\tkfree(ipa);\n\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_logical_to_ino(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tvoid __user *arg, int version)\n{\n\tint ret = 0;\n\tint size;\n\tstruct btrfs_ioctl_logical_ino_args *loi;\n\tstruct btrfs_data_container *inodes = NULL;\n\tstruct btrfs_path *path = NULL;\n\tbool ignore_offset;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tloi = memdup_user(arg, sizeof(*loi));\n\tif (IS_ERR(loi))\n\t\treturn PTR_ERR(loi);\n\n\tif (version == 1) {\n\t\tignore_offset = false;\n\t\tsize = min_t(u32, loi->size, SZ_64K);\n\t} else {\n\t\t \n\t\tif (memchr_inv(loi->reserved, 0, sizeof(loi->reserved))) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_loi;\n\t\t}\n\t\t \n\t\tif (loi->flags & ~(BTRFS_LOGICAL_INO_ARGS_IGNORE_OFFSET)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_loi;\n\t\t}\n\t\tignore_offset = loi->flags & BTRFS_LOGICAL_INO_ARGS_IGNORE_OFFSET;\n\t\tsize = min_t(u32, loi->size, SZ_16M);\n\t}\n\n\tinodes = init_data_container(size);\n\tif (IS_ERR(inodes)) {\n\t\tret = PTR_ERR(inodes);\n\t\tgoto out_loi;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tret = iterate_inodes_from_logical(loi->logical, fs_info, path,\n\t\t\t\t\t  inodes, ignore_offset);\n\tbtrfs_free_path(path);\n\tif (ret == -EINVAL)\n\t\tret = -ENOENT;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = copy_to_user((void __user *)(unsigned long)loi->inodes, inodes,\n\t\t\t   size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkvfree(inodes);\nout_loi:\n\tkfree(loi);\n\n\treturn ret;\n}\n\nvoid btrfs_update_ioctl_balance_args(struct btrfs_fs_info *fs_info,\n\t\t\t       struct btrfs_ioctl_balance_args *bargs)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\n\tbargs->flags = bctl->flags;\n\n\tif (test_bit(BTRFS_FS_BALANCE_RUNNING, &fs_info->flags))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_RUNNING;\n\tif (atomic_read(&fs_info->balance_pause_req))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_PAUSE_REQ;\n\tif (atomic_read(&fs_info->balance_cancel_req))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_CANCEL_REQ;\n\n\tmemcpy(&bargs->data, &bctl->data, sizeof(bargs->data));\n\tmemcpy(&bargs->meta, &bctl->meta, sizeof(bargs->meta));\n\tmemcpy(&bargs->sys, &bctl->sys, sizeof(bargs->sys));\n\n\tspin_lock(&fs_info->balance_lock);\n\tmemcpy(&bargs->stat, &bctl->stat, sizeof(bargs->stat));\n\tspin_unlock(&fs_info->balance_lock);\n}\n\n \nstatic int btrfs_try_lock_balance(struct btrfs_fs_info *fs_info, bool *excl_acquired)\n{\n\tint ret;\n\n\t \n\twhile (1) {\n\t\tif (btrfs_exclop_start(fs_info, BTRFS_EXCLOP_BALANCE)) {\n\t\t\t*excl_acquired = true;\n\t\t\tmutex_lock(&fs_info->balance_mutex);\n\t\t\treturn 0;\n\t\t}\n\n\t\tmutex_lock(&fs_info->balance_mutex);\n\t\tif (fs_info->balance_ctl) {\n\t\t\t \n\t\t\tif (test_bit(BTRFS_FS_BALANCE_RUNNING, &fs_info->flags)) {\n\t\t\t\t \n\t\t\t\tret = -EINPROGRESS;\n\t\t\t\tgoto out_failure;\n\n\t\t\t} else {\n\t\t\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\t\t\t \n\t\t\t\tmutex_lock(&fs_info->balance_mutex);\n\n\t\t\t\tif (fs_info->balance_ctl &&\n\t\t\t\t    !test_bit(BTRFS_FS_BALANCE_RUNNING, &fs_info->flags)) {\n\t\t\t\t\t \n\t\t\t\t\t*excl_acquired = false;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tret = BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t\t\tgoto out_failure;\n\t\t}\n\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t}\n\nout_failure:\n\tmutex_unlock(&fs_info->balance_mutex);\n\t*excl_acquired = false;\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_balance(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_ioctl_balance_args *bargs;\n\tstruct btrfs_balance_control *bctl;\n\tbool need_unlock = true;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tbargs = memdup_user(arg, sizeof(*bargs));\n\tif (IS_ERR(bargs)) {\n\t\tret = PTR_ERR(bargs);\n\t\tbargs = NULL;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_try_lock_balance(fs_info, &need_unlock);\n\tif (ret)\n\t\tgoto out;\n\n\tlockdep_assert_held(&fs_info->balance_mutex);\n\n\tif (bargs->flags & BTRFS_BALANCE_RESUME) {\n\t\tif (!fs_info->balance_ctl) {\n\t\t\tret = -ENOTCONN;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tbctl = fs_info->balance_ctl;\n\t\tspin_lock(&fs_info->balance_lock);\n\t\tbctl->flags |= BTRFS_BALANCE_RESUME;\n\t\tspin_unlock(&fs_info->balance_lock);\n\t\tbtrfs_exclop_balance(fs_info, BTRFS_EXCLOP_BALANCE);\n\n\t\tgoto do_balance;\n\t}\n\n\tif (bargs->flags & ~(BTRFS_BALANCE_ARGS_MASK | BTRFS_BALANCE_TYPE_MASK)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (fs_info->balance_ctl) {\n\t\tret = -EINPROGRESS;\n\t\tgoto out_unlock;\n\t}\n\n\tbctl = kzalloc(sizeof(*bctl), GFP_KERNEL);\n\tif (!bctl) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tmemcpy(&bctl->data, &bargs->data, sizeof(bctl->data));\n\tmemcpy(&bctl->meta, &bargs->meta, sizeof(bctl->meta));\n\tmemcpy(&bctl->sys, &bargs->sys, sizeof(bctl->sys));\n\n\tbctl->flags = bargs->flags;\ndo_balance:\n\t \n\tneed_unlock = false;\n\n\tret = btrfs_balance(fs_info, bctl, bargs);\n\tbctl = NULL;\n\n\tif (ret == 0 || ret == -ECANCELED) {\n\t\tif (copy_to_user(arg, bargs, sizeof(*bargs)))\n\t\t\tret = -EFAULT;\n\t}\n\n\tkfree(bctl);\nout_unlock:\n\tmutex_unlock(&fs_info->balance_mutex);\n\tif (need_unlock)\n\t\tbtrfs_exclop_finish(fs_info);\nout:\n\tmnt_drop_write_file(file);\n\tkfree(bargs);\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_balance_ctl(struct btrfs_fs_info *fs_info, int cmd)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase BTRFS_BALANCE_CTL_PAUSE:\n\t\treturn btrfs_pause_balance(fs_info);\n\tcase BTRFS_BALANCE_CTL_CANCEL:\n\t\treturn btrfs_cancel_balance(fs_info);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic long btrfs_ioctl_balance_progress(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t void __user *arg)\n{\n\tstruct btrfs_ioctl_balance_args *bargs;\n\tint ret = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (!fs_info->balance_ctl) {\n\t\tret = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tbargs = kzalloc(sizeof(*bargs), GFP_KERNEL);\n\tif (!bargs) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbtrfs_update_ioctl_balance_args(fs_info, bargs);\n\n\tif (copy_to_user(arg, bargs, sizeof(*bargs)))\n\t\tret = -EFAULT;\n\n\tkfree(bargs);\nout:\n\tmutex_unlock(&fs_info->balance_mutex);\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_quota_ctl(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_ioctl_quota_ctl_args *sa;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\tdown_write(&fs_info->subvol_sem);\n\n\tswitch (sa->cmd) {\n\tcase BTRFS_QUOTA_CTL_ENABLE:\n\t\tret = btrfs_quota_enable(fs_info);\n\t\tbreak;\n\tcase BTRFS_QUOTA_CTL_DISABLE:\n\t\tret = btrfs_quota_disable(fs_info);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tkfree(sa);\n\tup_write(&fs_info->subvol_sem);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_qgroup_assign(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ioctl_qgroup_assign_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tif (sa->assign) {\n\t\tret = btrfs_add_qgroup_relation(trans, sa->src, sa->dst);\n\t} else {\n\t\tret = btrfs_del_qgroup_relation(trans, sa->src, sa->dst);\n\t}\n\n\t \n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\terr = btrfs_run_qgroups(trans);\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\tif (err < 0)\n\t\tbtrfs_handle_fs_error(fs_info, err,\n\t\t\t\t      \"failed to update qgroup status and info\");\n\terr = btrfs_end_transaction(trans);\n\tif (err && !ret)\n\t\tret = err;\n\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_qgroup_create(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ioctl_qgroup_create_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\tif (!sa->qgroupid) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tif (sa->create) {\n\t\tret = btrfs_create_qgroup(trans, sa->qgroupid);\n\t} else {\n\t\tret = btrfs_remove_qgroup(trans, sa->qgroupid);\n\t}\n\n\terr = btrfs_end_transaction(trans);\n\tif (err && !ret)\n\t\tret = err;\n\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_qgroup_limit(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ioctl_qgroup_limit_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\tu64 qgroupid;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tqgroupid = sa->qgroupid;\n\tif (!qgroupid) {\n\t\t \n\t\tqgroupid = root->root_key.objectid;\n\t}\n\n\tret = btrfs_limit_qgroup(trans, qgroupid, &sa->lim);\n\n\terr = btrfs_end_transaction(trans);\n\tif (err && !ret)\n\t\tret = err;\n\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_quota_rescan(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_ioctl_quota_rescan_args *qsa;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tqsa = memdup_user(arg, sizeof(*qsa));\n\tif (IS_ERR(qsa)) {\n\t\tret = PTR_ERR(qsa);\n\t\tgoto drop_write;\n\t}\n\n\tif (qsa->flags) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_qgroup_rescan(fs_info);\n\nout:\n\tkfree(qsa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}\n\nstatic long btrfs_ioctl_quota_rescan_status(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tvoid __user *arg)\n{\n\tstruct btrfs_ioctl_quota_rescan_args qsa = {0};\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) {\n\t\tqsa.flags = 1;\n\t\tqsa.progress = fs_info->qgroup_rescan_progress.objectid;\n\t}\n\n\tif (copy_to_user(arg, &qsa, sizeof(qsa)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long btrfs_ioctl_quota_rescan_wait(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tvoid __user *arg)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btrfs_qgroup_wait_for_completion(fs_info, true);\n}\n\nstatic long _btrfs_ioctl_set_received_subvol(struct file *file,\n\t\t\t\t\t    struct mnt_idmap *idmap,\n\t\t\t\t\t    struct btrfs_ioctl_received_subvol_args *sa)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_root_item *root_item = &root->root_item;\n\tstruct btrfs_trans_handle *trans;\n\tstruct timespec64 ct = current_time(inode);\n\tint ret = 0;\n\tint received_uuid_changed;\n\n\tif (!inode_owner_or_capable(idmap, inode))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdown_write(&fs_info->subvol_sem);\n\n\tif (btrfs_ino(BTRFS_I(inode)) != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (btrfs_root_readonly(root)) {\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t \n\ttrans = btrfs_start_transaction(root, 3);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\ttrans = NULL;\n\t\tgoto out;\n\t}\n\n\tsa->rtransid = trans->transid;\n\tsa->rtime.sec = ct.tv_sec;\n\tsa->rtime.nsec = ct.tv_nsec;\n\n\treceived_uuid_changed = memcmp(root_item->received_uuid, sa->uuid,\n\t\t\t\t       BTRFS_UUID_SIZE);\n\tif (received_uuid_changed &&\n\t    !btrfs_is_empty_uuid(root_item->received_uuid)) {\n\t\tret = btrfs_uuid_tree_remove(trans, root_item->received_uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  root->root_key.objectid);\n\t\tif (ret && ret != -ENOENT) {\n\t\t        btrfs_abort_transaction(trans, ret);\n\t\t        btrfs_end_transaction(trans);\n\t\t        goto out;\n\t\t}\n\t}\n\tmemcpy(root_item->received_uuid, sa->uuid, BTRFS_UUID_SIZE);\n\tbtrfs_set_root_stransid(root_item, sa->stransid);\n\tbtrfs_set_root_rtransid(root_item, sa->rtransid);\n\tbtrfs_set_stack_timespec_sec(&root_item->stime, sa->stime.sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item->stime, sa->stime.nsec);\n\tbtrfs_set_stack_timespec_sec(&root_item->rtime, sa->rtime.sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item->rtime, sa->rtime.nsec);\n\n\tret = btrfs_update_root(trans, fs_info->tree_root,\n\t\t\t\t&root->root_key, &root->root_item);\n\tif (ret < 0) {\n\t\tbtrfs_end_transaction(trans);\n\t\tgoto out;\n\t}\n\tif (received_uuid_changed && !btrfs_is_empty_uuid(sa->uuid)) {\n\t\tret = btrfs_uuid_tree_add(trans, sa->uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  root->root_key.objectid);\n\t\tif (ret < 0 && ret != -EEXIST) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tbtrfs_end_transaction(trans);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = btrfs_commit_transaction(trans);\nout:\n\tup_write(&fs_info->subvol_sem);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}\n\n#ifdef CONFIG_64BIT\nstatic long btrfs_ioctl_set_received_subvol_32(struct file *file,\n\t\t\t\t\t\tvoid __user *arg)\n{\n\tstruct btrfs_ioctl_received_subvol_args_32 *args32 = NULL;\n\tstruct btrfs_ioctl_received_subvol_args *args64 = NULL;\n\tint ret = 0;\n\n\targs32 = memdup_user(arg, sizeof(*args32));\n\tif (IS_ERR(args32))\n\t\treturn PTR_ERR(args32);\n\n\targs64 = kmalloc(sizeof(*args64), GFP_KERNEL);\n\tif (!args64) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(args64->uuid, args32->uuid, BTRFS_UUID_SIZE);\n\targs64->stransid = args32->stransid;\n\targs64->rtransid = args32->rtransid;\n\targs64->stime.sec = args32->stime.sec;\n\targs64->stime.nsec = args32->stime.nsec;\n\targs64->rtime.sec = args32->rtime.sec;\n\targs64->rtime.nsec = args32->rtime.nsec;\n\targs64->flags = args32->flags;\n\n\tret = _btrfs_ioctl_set_received_subvol(file, file_mnt_idmap(file), args64);\n\tif (ret)\n\t\tgoto out;\n\n\tmemcpy(args32->uuid, args64->uuid, BTRFS_UUID_SIZE);\n\targs32->stransid = args64->stransid;\n\targs32->rtransid = args64->rtransid;\n\targs32->stime.sec = args64->stime.sec;\n\targs32->stime.nsec = args64->stime.nsec;\n\targs32->rtime.sec = args64->rtime.sec;\n\targs32->rtime.nsec = args64->rtime.nsec;\n\targs32->flags = args64->flags;\n\n\tret = copy_to_user(arg, args32, sizeof(*args32));\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(args32);\n\tkfree(args64);\n\treturn ret;\n}\n#endif\n\nstatic long btrfs_ioctl_set_received_subvol(struct file *file,\n\t\t\t\t\t    void __user *arg)\n{\n\tstruct btrfs_ioctl_received_subvol_args *sa = NULL;\n\tint ret = 0;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa))\n\t\treturn PTR_ERR(sa);\n\n\tret = _btrfs_ioctl_set_received_subvol(file, file_mnt_idmap(file), sa);\n\n\tif (ret)\n\t\tgoto out;\n\n\tret = copy_to_user(arg, sa, sizeof(*sa));\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(sa);\n\treturn ret;\n}\n\nstatic int btrfs_ioctl_get_fslabel(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tvoid __user *arg)\n{\n\tsize_t len;\n\tint ret;\n\tchar label[BTRFS_LABEL_SIZE];\n\n\tspin_lock(&fs_info->super_lock);\n\tmemcpy(label, fs_info->super_copy->label, BTRFS_LABEL_SIZE);\n\tspin_unlock(&fs_info->super_lock);\n\n\tlen = strnlen(label, BTRFS_LABEL_SIZE);\n\n\tif (len == BTRFS_LABEL_SIZE) {\n\t\tbtrfs_warn(fs_info,\n\t\t\t   \"label is too long, return the first %zu bytes\",\n\t\t\t   --len);\n\t}\n\n\tret = copy_to_user(arg, label, len);\n\n\treturn ret ? -EFAULT : 0;\n}\n\nstatic int btrfs_ioctl_set_fslabel(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_super_block *super_block = fs_info->super_copy;\n\tstruct btrfs_trans_handle *trans;\n\tchar label[BTRFS_LABEL_SIZE];\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(label, arg, sizeof(label)))\n\t\treturn -EFAULT;\n\n\tif (strnlen(label, BTRFS_LABEL_SIZE) == BTRFS_LABEL_SIZE) {\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"unable to set label with more than %d bytes\",\n\t\t\t  BTRFS_LABEL_SIZE - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_unlock;\n\t}\n\n\tspin_lock(&fs_info->super_lock);\n\tstrcpy(super_block->label, label);\n\tspin_unlock(&fs_info->super_lock);\n\tret = btrfs_commit_transaction(trans);\n\nout_unlock:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}\n\n#define INIT_FEATURE_FLAGS(suffix) \\\n\t{ .compat_flags = BTRFS_FEATURE_COMPAT_##suffix, \\\n\t  .compat_ro_flags = BTRFS_FEATURE_COMPAT_RO_##suffix, \\\n\t  .incompat_flags = BTRFS_FEATURE_INCOMPAT_##suffix }\n\nint btrfs_ioctl_get_supported_features(void __user *arg)\n{\n\tstatic const struct btrfs_ioctl_feature_flags features[3] = {\n\t\tINIT_FEATURE_FLAGS(SUPP),\n\t\tINIT_FEATURE_FLAGS(SAFE_SET),\n\t\tINIT_FEATURE_FLAGS(SAFE_CLEAR)\n\t};\n\n\tif (copy_to_user(arg, &features, sizeof(features)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int btrfs_ioctl_get_features(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tvoid __user *arg)\n{\n\tstruct btrfs_super_block *super_block = fs_info->super_copy;\n\tstruct btrfs_ioctl_feature_flags features;\n\n\tfeatures.compat_flags = btrfs_super_compat_flags(super_block);\n\tfeatures.compat_ro_flags = btrfs_super_compat_ro_flags(super_block);\n\tfeatures.incompat_flags = btrfs_super_incompat_flags(super_block);\n\n\tif (copy_to_user(arg, &features, sizeof(features)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int check_feature_bits(struct btrfs_fs_info *fs_info,\n\t\t\t      enum btrfs_feature_set set,\n\t\t\t      u64 change_mask, u64 flags, u64 supported_flags,\n\t\t\t      u64 safe_set, u64 safe_clear)\n{\n\tconst char *type = btrfs_feature_set_name(set);\n\tchar *names;\n\tu64 disallowed, unsupported;\n\tu64 set_mask = flags & change_mask;\n\tu64 clear_mask = ~flags & change_mask;\n\n\tunsupported = set_mask & ~supported_flags;\n\tif (unsupported) {\n\t\tnames = btrfs_printable_features(set, unsupported);\n\t\tif (names) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t   \"this kernel does not support the %s feature bit%s\",\n\t\t\t\t   names, strchr(names, ',') ? \"s\" : \"\");\n\t\t\tkfree(names);\n\t\t} else\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t   \"this kernel does not support %s bits 0x%llx\",\n\t\t\t\t   type, unsupported);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdisallowed = set_mask & ~safe_set;\n\tif (disallowed) {\n\t\tnames = btrfs_printable_features(set, disallowed);\n\t\tif (names) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t   \"can't set the %s feature bit%s while mounted\",\n\t\t\t\t   names, strchr(names, ',') ? \"s\" : \"\");\n\t\t\tkfree(names);\n\t\t} else\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t   \"can't set %s bits 0x%llx while mounted\",\n\t\t\t\t   type, disallowed);\n\t\treturn -EPERM;\n\t}\n\n\tdisallowed = clear_mask & ~safe_clear;\n\tif (disallowed) {\n\t\tnames = btrfs_printable_features(set, disallowed);\n\t\tif (names) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t   \"can't clear the %s feature bit%s while mounted\",\n\t\t\t\t   names, strchr(names, ',') ? \"s\" : \"\");\n\t\t\tkfree(names);\n\t\t} else\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t   \"can't clear %s bits 0x%llx while mounted\",\n\t\t\t\t   type, disallowed);\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\n\n#define check_feature(fs_info, change_mask, flags, mask_base)\t\\\ncheck_feature_bits(fs_info, FEAT_##mask_base, change_mask, flags,\t\\\n\t\t   BTRFS_FEATURE_ ## mask_base ## _SUPP,\t\\\n\t\t   BTRFS_FEATURE_ ## mask_base ## _SAFE_SET,\t\\\n\t\t   BTRFS_FEATURE_ ## mask_base ## _SAFE_CLEAR)\n\nstatic int btrfs_ioctl_set_features(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_super_block *super_block = fs_info->super_copy;\n\tstruct btrfs_ioctl_feature_flags flags[2];\n\tstruct btrfs_trans_handle *trans;\n\tu64 newflags;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(flags, arg, sizeof(flags)))\n\t\treturn -EFAULT;\n\n\t \n\tif (!flags[0].compat_flags && !flags[0].compat_ro_flags &&\n\t    !flags[0].incompat_flags)\n\t\treturn 0;\n\n\tret = check_feature(fs_info, flags[0].compat_flags,\n\t\t\t    flags[1].compat_flags, COMPAT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = check_feature(fs_info, flags[0].compat_ro_flags,\n\t\t\t    flags[1].compat_ro_flags, COMPAT_RO);\n\tif (ret)\n\t\treturn ret;\n\n\tret = check_feature(fs_info, flags[0].incompat_flags,\n\t\t\t    flags[1].incompat_flags, INCOMPAT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_drop_write;\n\t}\n\n\tspin_lock(&fs_info->super_lock);\n\tnewflags = btrfs_super_compat_flags(super_block);\n\tnewflags |= flags[0].compat_flags & flags[1].compat_flags;\n\tnewflags &= ~(flags[0].compat_flags & ~flags[1].compat_flags);\n\tbtrfs_set_super_compat_flags(super_block, newflags);\n\n\tnewflags = btrfs_super_compat_ro_flags(super_block);\n\tnewflags |= flags[0].compat_ro_flags & flags[1].compat_ro_flags;\n\tnewflags &= ~(flags[0].compat_ro_flags & ~flags[1].compat_ro_flags);\n\tbtrfs_set_super_compat_ro_flags(super_block, newflags);\n\n\tnewflags = btrfs_super_incompat_flags(super_block);\n\tnewflags |= flags[0].incompat_flags & flags[1].incompat_flags;\n\tnewflags &= ~(flags[0].incompat_flags & ~flags[1].incompat_flags);\n\tbtrfs_set_super_incompat_flags(super_block, newflags);\n\tspin_unlock(&fs_info->super_lock);\n\n\tret = btrfs_commit_transaction(trans);\nout_drop_write:\n\tmnt_drop_write_file(file);\n\n\treturn ret;\n}\n\nstatic int _btrfs_ioctl_send(struct inode *inode, void __user *argp, bool compat)\n{\n\tstruct btrfs_ioctl_send_args *arg;\n\tint ret;\n\n\tif (compat) {\n#if defined(CONFIG_64BIT) && defined(CONFIG_COMPAT)\n\t\tstruct btrfs_ioctl_send_args_32 args32 = { 0 };\n\n\t\tret = copy_from_user(&args32, argp, sizeof(args32));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\targ = kzalloc(sizeof(*arg), GFP_KERNEL);\n\t\tif (!arg)\n\t\t\treturn -ENOMEM;\n\t\targ->send_fd = args32.send_fd;\n\t\targ->clone_sources_count = args32.clone_sources_count;\n\t\targ->clone_sources = compat_ptr(args32.clone_sources);\n\t\targ->parent_root = args32.parent_root;\n\t\targ->flags = args32.flags;\n\t\targ->version = args32.version;\n\t\tmemcpy(arg->reserved, args32.reserved,\n\t\t       sizeof(args32.reserved));\n#else\n\t\treturn -ENOTTY;\n#endif\n\t} else {\n\t\targ = memdup_user(argp, sizeof(*arg));\n\t\tif (IS_ERR(arg))\n\t\t\treturn PTR_ERR(arg);\n\t}\n\tret = btrfs_ioctl_send(inode, arg);\n\tkfree(arg);\n\treturn ret;\n}\n\nstatic int btrfs_ioctl_encoded_read(struct file *file, void __user *argp,\n\t\t\t\t    bool compat)\n{\n\tstruct btrfs_ioctl_encoded_io_args args = { 0 };\n\tsize_t copy_end_kernel = offsetofend(struct btrfs_ioctl_encoded_io_args,\n\t\t\t\t\t     flags);\n\tsize_t copy_end;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tloff_t pos;\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tret = -EPERM;\n\t\tgoto out_acct;\n\t}\n\n\tif (compat) {\n#if defined(CONFIG_64BIT) && defined(CONFIG_COMPAT)\n\t\tstruct btrfs_ioctl_encoded_io_args_32 args32;\n\n\t\tcopy_end = offsetofend(struct btrfs_ioctl_encoded_io_args_32,\n\t\t\t\t       flags);\n\t\tif (copy_from_user(&args32, argp, copy_end)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_acct;\n\t\t}\n\t\targs.iov = compat_ptr(args32.iov);\n\t\targs.iovcnt = args32.iovcnt;\n\t\targs.offset = args32.offset;\n\t\targs.flags = args32.flags;\n#else\n\t\treturn -ENOTTY;\n#endif\n\t} else {\n\t\tcopy_end = copy_end_kernel;\n\t\tif (copy_from_user(&args, argp, copy_end)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_acct;\n\t\t}\n\t}\n\tif (args.flags != 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_acct;\n\t}\n\n\tret = import_iovec(ITER_DEST, args.iov, args.iovcnt, ARRAY_SIZE(iovstack),\n\t\t\t   &iov, &iter);\n\tif (ret < 0)\n\t\tgoto out_acct;\n\n\tif (iov_iter_count(&iter) == 0) {\n\t\tret = 0;\n\t\tgoto out_iov;\n\t}\n\tpos = args.offset;\n\tret = rw_verify_area(READ, file, &pos, args.len);\n\tif (ret < 0)\n\t\tgoto out_iov;\n\n\tinit_sync_kiocb(&kiocb, file);\n\tkiocb.ki_pos = pos;\n\n\tret = btrfs_encoded_read(&kiocb, &iter, &args);\n\tif (ret >= 0) {\n\t\tfsnotify_access(file);\n\t\tif (copy_to_user(argp + copy_end,\n\t\t\t\t (char *)&args + copy_end_kernel,\n\t\t\t\t sizeof(args) - copy_end_kernel))\n\t\t\tret = -EFAULT;\n\t}\n\nout_iov:\n\tkfree(iov);\nout_acct:\n\tif (ret > 0)\n\t\tadd_rchar(current, ret);\n\tinc_syscr(current);\n\treturn ret;\n}\n\nstatic int btrfs_ioctl_encoded_write(struct file *file, void __user *argp, bool compat)\n{\n\tstruct btrfs_ioctl_encoded_io_args args;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tloff_t pos;\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tret = -EPERM;\n\t\tgoto out_acct;\n\t}\n\n\tif (!(file->f_mode & FMODE_WRITE)) {\n\t\tret = -EBADF;\n\t\tgoto out_acct;\n\t}\n\n\tif (compat) {\n#if defined(CONFIG_64BIT) && defined(CONFIG_COMPAT)\n\t\tstruct btrfs_ioctl_encoded_io_args_32 args32;\n\n\t\tif (copy_from_user(&args32, argp, sizeof(args32))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_acct;\n\t\t}\n\t\targs.iov = compat_ptr(args32.iov);\n\t\targs.iovcnt = args32.iovcnt;\n\t\targs.offset = args32.offset;\n\t\targs.flags = args32.flags;\n\t\targs.len = args32.len;\n\t\targs.unencoded_len = args32.unencoded_len;\n\t\targs.unencoded_offset = args32.unencoded_offset;\n\t\targs.compression = args32.compression;\n\t\targs.encryption = args32.encryption;\n\t\tmemcpy(args.reserved, args32.reserved, sizeof(args.reserved));\n#else\n\t\treturn -ENOTTY;\n#endif\n\t} else {\n\t\tif (copy_from_user(&args, argp, sizeof(args))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_acct;\n\t\t}\n\t}\n\n\tret = -EINVAL;\n\tif (args.flags != 0)\n\t\tgoto out_acct;\n\tif (memchr_inv(args.reserved, 0, sizeof(args.reserved)))\n\t\tgoto out_acct;\n\tif (args.compression == BTRFS_ENCODED_IO_COMPRESSION_NONE &&\n\t    args.encryption == BTRFS_ENCODED_IO_ENCRYPTION_NONE)\n\t\tgoto out_acct;\n\tif (args.compression >= BTRFS_ENCODED_IO_COMPRESSION_TYPES ||\n\t    args.encryption >= BTRFS_ENCODED_IO_ENCRYPTION_TYPES)\n\t\tgoto out_acct;\n\tif (args.unencoded_offset > args.unencoded_len)\n\t\tgoto out_acct;\n\tif (args.len > args.unencoded_len - args.unencoded_offset)\n\t\tgoto out_acct;\n\n\tret = import_iovec(ITER_SOURCE, args.iov, args.iovcnt, ARRAY_SIZE(iovstack),\n\t\t\t   &iov, &iter);\n\tif (ret < 0)\n\t\tgoto out_acct;\n\n\tfile_start_write(file);\n\n\tif (iov_iter_count(&iter) == 0) {\n\t\tret = 0;\n\t\tgoto out_end_write;\n\t}\n\tpos = args.offset;\n\tret = rw_verify_area(WRITE, file, &pos, args.len);\n\tif (ret < 0)\n\t\tgoto out_end_write;\n\n\tinit_sync_kiocb(&kiocb, file);\n\tret = kiocb_set_rw_flags(&kiocb, 0);\n\tif (ret)\n\t\tgoto out_end_write;\n\tkiocb.ki_pos = pos;\n\n\tret = btrfs_do_write_iter(&kiocb, &iter, &args);\n\tif (ret > 0)\n\t\tfsnotify_modify(file);\n\nout_end_write:\n\tfile_end_write(file);\n\tkfree(iov);\nout_acct:\n\tif (ret > 0)\n\t\tadd_wchar(current, ret);\n\tinc_syscw(current);\n\treturn ret;\n}\n\nlong btrfs_ioctl(struct file *file, unsigned int\n\t\tcmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase FS_IOC_GETVERSION:\n\t\treturn btrfs_ioctl_getversion(inode, argp);\n\tcase FS_IOC_GETFSLABEL:\n\t\treturn btrfs_ioctl_get_fslabel(fs_info, argp);\n\tcase FS_IOC_SETFSLABEL:\n\t\treturn btrfs_ioctl_set_fslabel(file, argp);\n\tcase FITRIM:\n\t\treturn btrfs_ioctl_fitrim(fs_info, argp);\n\tcase BTRFS_IOC_SNAP_CREATE:\n\t\treturn btrfs_ioctl_snap_create(file, argp, 0);\n\tcase BTRFS_IOC_SNAP_CREATE_V2:\n\t\treturn btrfs_ioctl_snap_create_v2(file, argp, 0);\n\tcase BTRFS_IOC_SUBVOL_CREATE:\n\t\treturn btrfs_ioctl_snap_create(file, argp, 1);\n\tcase BTRFS_IOC_SUBVOL_CREATE_V2:\n\t\treturn btrfs_ioctl_snap_create_v2(file, argp, 1);\n\tcase BTRFS_IOC_SNAP_DESTROY:\n\t\treturn btrfs_ioctl_snap_destroy(file, argp, false);\n\tcase BTRFS_IOC_SNAP_DESTROY_V2:\n\t\treturn btrfs_ioctl_snap_destroy(file, argp, true);\n\tcase BTRFS_IOC_SUBVOL_GETFLAGS:\n\t\treturn btrfs_ioctl_subvol_getflags(inode, argp);\n\tcase BTRFS_IOC_SUBVOL_SETFLAGS:\n\t\treturn btrfs_ioctl_subvol_setflags(file, argp);\n\tcase BTRFS_IOC_DEFAULT_SUBVOL:\n\t\treturn btrfs_ioctl_default_subvol(file, argp);\n\tcase BTRFS_IOC_DEFRAG:\n\t\treturn btrfs_ioctl_defrag(file, NULL);\n\tcase BTRFS_IOC_DEFRAG_RANGE:\n\t\treturn btrfs_ioctl_defrag(file, argp);\n\tcase BTRFS_IOC_RESIZE:\n\t\treturn btrfs_ioctl_resize(file, argp);\n\tcase BTRFS_IOC_ADD_DEV:\n\t\treturn btrfs_ioctl_add_dev(fs_info, argp);\n\tcase BTRFS_IOC_RM_DEV:\n\t\treturn btrfs_ioctl_rm_dev(file, argp);\n\tcase BTRFS_IOC_RM_DEV_V2:\n\t\treturn btrfs_ioctl_rm_dev_v2(file, argp);\n\tcase BTRFS_IOC_FS_INFO:\n\t\treturn btrfs_ioctl_fs_info(fs_info, argp);\n\tcase BTRFS_IOC_DEV_INFO:\n\t\treturn btrfs_ioctl_dev_info(fs_info, argp);\n\tcase BTRFS_IOC_TREE_SEARCH:\n\t\treturn btrfs_ioctl_tree_search(inode, argp);\n\tcase BTRFS_IOC_TREE_SEARCH_V2:\n\t\treturn btrfs_ioctl_tree_search_v2(inode, argp);\n\tcase BTRFS_IOC_INO_LOOKUP:\n\t\treturn btrfs_ioctl_ino_lookup(root, argp);\n\tcase BTRFS_IOC_INO_PATHS:\n\t\treturn btrfs_ioctl_ino_to_path(root, argp);\n\tcase BTRFS_IOC_LOGICAL_INO:\n\t\treturn btrfs_ioctl_logical_to_ino(fs_info, argp, 1);\n\tcase BTRFS_IOC_LOGICAL_INO_V2:\n\t\treturn btrfs_ioctl_logical_to_ino(fs_info, argp, 2);\n\tcase BTRFS_IOC_SPACE_INFO:\n\t\treturn btrfs_ioctl_space_info(fs_info, argp);\n\tcase BTRFS_IOC_SYNC: {\n\t\tint ret;\n\n\t\tret = btrfs_start_delalloc_roots(fs_info, LONG_MAX, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = btrfs_sync_fs(inode->i_sb, 1);\n\t\t \n\t\twake_up_process(fs_info->transaction_kthread);\n\t\treturn ret;\n\t}\n\tcase BTRFS_IOC_START_SYNC:\n\t\treturn btrfs_ioctl_start_sync(root, argp);\n\tcase BTRFS_IOC_WAIT_SYNC:\n\t\treturn btrfs_ioctl_wait_sync(fs_info, argp);\n\tcase BTRFS_IOC_SCRUB:\n\t\treturn btrfs_ioctl_scrub(file, argp);\n\tcase BTRFS_IOC_SCRUB_CANCEL:\n\t\treturn btrfs_ioctl_scrub_cancel(fs_info);\n\tcase BTRFS_IOC_SCRUB_PROGRESS:\n\t\treturn btrfs_ioctl_scrub_progress(fs_info, argp);\n\tcase BTRFS_IOC_BALANCE_V2:\n\t\treturn btrfs_ioctl_balance(file, argp);\n\tcase BTRFS_IOC_BALANCE_CTL:\n\t\treturn btrfs_ioctl_balance_ctl(fs_info, arg);\n\tcase BTRFS_IOC_BALANCE_PROGRESS:\n\t\treturn btrfs_ioctl_balance_progress(fs_info, argp);\n\tcase BTRFS_IOC_SET_RECEIVED_SUBVOL:\n\t\treturn btrfs_ioctl_set_received_subvol(file, argp);\n#ifdef CONFIG_64BIT\n\tcase BTRFS_IOC_SET_RECEIVED_SUBVOL_32:\n\t\treturn btrfs_ioctl_set_received_subvol_32(file, argp);\n#endif\n\tcase BTRFS_IOC_SEND:\n\t\treturn _btrfs_ioctl_send(inode, argp, false);\n#if defined(CONFIG_64BIT) && defined(CONFIG_COMPAT)\n\tcase BTRFS_IOC_SEND_32:\n\t\treturn _btrfs_ioctl_send(inode, argp, true);\n#endif\n\tcase BTRFS_IOC_GET_DEV_STATS:\n\t\treturn btrfs_ioctl_get_dev_stats(fs_info, argp);\n\tcase BTRFS_IOC_QUOTA_CTL:\n\t\treturn btrfs_ioctl_quota_ctl(file, argp);\n\tcase BTRFS_IOC_QGROUP_ASSIGN:\n\t\treturn btrfs_ioctl_qgroup_assign(file, argp);\n\tcase BTRFS_IOC_QGROUP_CREATE:\n\t\treturn btrfs_ioctl_qgroup_create(file, argp);\n\tcase BTRFS_IOC_QGROUP_LIMIT:\n\t\treturn btrfs_ioctl_qgroup_limit(file, argp);\n\tcase BTRFS_IOC_QUOTA_RESCAN:\n\t\treturn btrfs_ioctl_quota_rescan(file, argp);\n\tcase BTRFS_IOC_QUOTA_RESCAN_STATUS:\n\t\treturn btrfs_ioctl_quota_rescan_status(fs_info, argp);\n\tcase BTRFS_IOC_QUOTA_RESCAN_WAIT:\n\t\treturn btrfs_ioctl_quota_rescan_wait(fs_info, argp);\n\tcase BTRFS_IOC_DEV_REPLACE:\n\t\treturn btrfs_ioctl_dev_replace(fs_info, argp);\n\tcase BTRFS_IOC_GET_SUPPORTED_FEATURES:\n\t\treturn btrfs_ioctl_get_supported_features(argp);\n\tcase BTRFS_IOC_GET_FEATURES:\n\t\treturn btrfs_ioctl_get_features(fs_info, argp);\n\tcase BTRFS_IOC_SET_FEATURES:\n\t\treturn btrfs_ioctl_set_features(file, argp);\n\tcase BTRFS_IOC_GET_SUBVOL_INFO:\n\t\treturn btrfs_ioctl_get_subvol_info(inode, argp);\n\tcase BTRFS_IOC_GET_SUBVOL_ROOTREF:\n\t\treturn btrfs_ioctl_get_subvol_rootref(root, argp);\n\tcase BTRFS_IOC_INO_LOOKUP_USER:\n\t\treturn btrfs_ioctl_ino_lookup_user(file, argp);\n\tcase FS_IOC_ENABLE_VERITY:\n\t\treturn fsverity_ioctl_enable(file, (const void __user *)argp);\n\tcase FS_IOC_MEASURE_VERITY:\n\t\treturn fsverity_ioctl_measure(file, argp);\n\tcase BTRFS_IOC_ENCODED_READ:\n\t\treturn btrfs_ioctl_encoded_read(file, argp, false);\n\tcase BTRFS_IOC_ENCODED_WRITE:\n\t\treturn btrfs_ioctl_encoded_write(file, argp, false);\n#if defined(CONFIG_64BIT) && defined(CONFIG_COMPAT)\n\tcase BTRFS_IOC_ENCODED_READ_32:\n\t\treturn btrfs_ioctl_encoded_read(file, argp, true);\n\tcase BTRFS_IOC_ENCODED_WRITE_32:\n\t\treturn btrfs_ioctl_encoded_write(file, argp, true);\n#endif\n\t}\n\n\treturn -ENOTTY;\n}\n\n#ifdef CONFIG_COMPAT\nlong btrfs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\t \n\tswitch (cmd) {\n\tcase FS_IOC32_GETVERSION:\n\t\tcmd = FS_IOC_GETVERSION;\n\t\tbreak;\n\t}\n\n\treturn btrfs_ioctl(file, cmd, (unsigned long) compat_ptr(arg));\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}