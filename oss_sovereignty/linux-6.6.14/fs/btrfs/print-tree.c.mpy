{
  "module_name": "print-tree.c",
  "hash_id": "c37f35dea54068e69564072cb5b46f86cdd3706a30c2265884b99499bb10b1cd",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/print-tree.c",
  "human_readable_source": "\n \n\n#include \"messages.h\"\n#include \"ctree.h\"\n#include \"disk-io.h\"\n#include \"print-tree.h\"\n#include \"accessors.h\"\n#include \"tree-checker.h\"\n\nstruct root_name_map {\n\tu64 id;\n\tchar name[16];\n};\n\nstatic const struct root_name_map root_map[] = {\n\t{ BTRFS_ROOT_TREE_OBJECTID,\t\t\"ROOT_TREE\"\t\t},\n\t{ BTRFS_EXTENT_TREE_OBJECTID,\t\t\"EXTENT_TREE\"\t\t},\n\t{ BTRFS_CHUNK_TREE_OBJECTID,\t\t\"CHUNK_TREE\"\t\t},\n\t{ BTRFS_DEV_TREE_OBJECTID,\t\t\"DEV_TREE\"\t\t},\n\t{ BTRFS_FS_TREE_OBJECTID,\t\t\"FS_TREE\"\t\t},\n\t{ BTRFS_CSUM_TREE_OBJECTID,\t\t\"CSUM_TREE\"\t\t},\n\t{ BTRFS_TREE_LOG_OBJECTID,\t\t\"TREE_LOG\"\t\t},\n\t{ BTRFS_QUOTA_TREE_OBJECTID,\t\t\"QUOTA_TREE\"\t\t},\n\t{ BTRFS_UUID_TREE_OBJECTID,\t\t\"UUID_TREE\"\t\t},\n\t{ BTRFS_FREE_SPACE_TREE_OBJECTID,\t\"FREE_SPACE_TREE\"\t},\n\t{ BTRFS_BLOCK_GROUP_TREE_OBJECTID,\t\"BLOCK_GROUP_TREE\"\t},\n\t{ BTRFS_DATA_RELOC_TREE_OBJECTID,\t\"DATA_RELOC_TREE\"\t},\n};\n\nconst char *btrfs_root_name(const struct btrfs_key *key, char *buf)\n{\n\tint i;\n\n\tif (key->objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tsnprintf(buf, BTRFS_ROOT_NAME_BUF_LEN,\n\t\t\t \"TREE_RELOC offset=%llu\", key->offset);\n\t\treturn buf;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(root_map); i++) {\n\t\tif (root_map[i].id == key->objectid)\n\t\t\treturn root_map[i].name;\n\t}\n\n\tsnprintf(buf, BTRFS_ROOT_NAME_BUF_LEN, \"%llu\", key->objectid);\n\treturn buf;\n}\n\nstatic void print_chunk(const struct extent_buffer *eb, struct btrfs_chunk *chunk)\n{\n\tint num_stripes = btrfs_chunk_num_stripes(eb, chunk);\n\tint i;\n\tpr_info(\"\\t\\tchunk length %llu owner %llu type %llu num_stripes %d\\n\",\n\t       btrfs_chunk_length(eb, chunk), btrfs_chunk_owner(eb, chunk),\n\t       btrfs_chunk_type(eb, chunk), num_stripes);\n\tfor (i = 0 ; i < num_stripes ; i++) {\n\t\tpr_info(\"\\t\\t\\tstripe %d devid %llu offset %llu\\n\", i,\n\t\t      btrfs_stripe_devid_nr(eb, chunk, i),\n\t\t      btrfs_stripe_offset_nr(eb, chunk, i));\n\t}\n}\nstatic void print_dev_item(const struct extent_buffer *eb,\n\t\t\t   struct btrfs_dev_item *dev_item)\n{\n\tpr_info(\"\\t\\tdev item devid %llu total_bytes %llu bytes used %llu\\n\",\n\t       btrfs_device_id(eb, dev_item),\n\t       btrfs_device_total_bytes(eb, dev_item),\n\t       btrfs_device_bytes_used(eb, dev_item));\n}\nstatic void print_extent_data_ref(const struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_extent_data_ref *ref)\n{\n\tpr_cont(\"extent data backref root %llu objectid %llu offset %llu count %u\\n\",\n\t       btrfs_extent_data_ref_root(eb, ref),\n\t       btrfs_extent_data_ref_objectid(eb, ref),\n\t       btrfs_extent_data_ref_offset(eb, ref),\n\t       btrfs_extent_data_ref_count(eb, ref));\n}\n\nstatic void print_extent_item(const struct extent_buffer *eb, int slot, int type)\n{\n\tstruct btrfs_extent_item *ei;\n\tstruct btrfs_extent_inline_ref *iref;\n\tstruct btrfs_extent_data_ref *dref;\n\tstruct btrfs_shared_data_ref *sref;\n\tstruct btrfs_disk_key key;\n\tunsigned long end;\n\tunsigned long ptr;\n\tu32 item_size = btrfs_item_size(eb, slot);\n\tu64 flags;\n\tu64 offset;\n\tint ref_index = 0;\n\n\tif (unlikely(item_size < sizeof(*ei))) {\n\t\tbtrfs_err(eb->fs_info,\n\t\t\t  \"unexpected extent item size, has %u expect >= %zu\",\n\t\t\t  item_size, sizeof(*ei));\n\t\tbtrfs_handle_fs_error(eb->fs_info, -EUCLEAN, NULL);\n\t}\n\n\tei = btrfs_item_ptr(eb, slot, struct btrfs_extent_item);\n\tflags = btrfs_extent_flags(eb, ei);\n\n\tpr_info(\"\\t\\textent refs %llu gen %llu flags %llu\\n\",\n\t       btrfs_extent_refs(eb, ei), btrfs_extent_generation(eb, ei),\n\t       flags);\n\n\tif ((type == BTRFS_EXTENT_ITEM_KEY) &&\n\t    flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tstruct btrfs_tree_block_info *info;\n\t\tinfo = (struct btrfs_tree_block_info *)(ei + 1);\n\t\tbtrfs_tree_block_key(eb, info, &key);\n\t\tpr_info(\"\\t\\ttree block key (%llu %u %llu) level %d\\n\",\n\t\t       btrfs_disk_key_objectid(&key), key.type,\n\t\t       btrfs_disk_key_offset(&key),\n\t\t       btrfs_tree_block_level(eb, info));\n\t\tiref = (struct btrfs_extent_inline_ref *)(info + 1);\n\t} else {\n\t\tiref = (struct btrfs_extent_inline_ref *)(ei + 1);\n\t}\n\n\tptr = (unsigned long)iref;\n\tend = (unsigned long)ei + item_size;\n\twhile (ptr < end) {\n\t\tiref = (struct btrfs_extent_inline_ref *)ptr;\n\t\ttype = btrfs_extent_inline_ref_type(eb, iref);\n\t\toffset = btrfs_extent_inline_ref_offset(eb, iref);\n\t\tpr_info(\"\\t\\tref#%d: \", ref_index++);\n\t\tswitch (type) {\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\t\tpr_cont(\"tree block backref root %llu\\n\", offset);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tpr_cont(\"shared block backref parent %llu\\n\", offset);\n\t\t\t \n\t\t\tif (!IS_ALIGNED(offset, eb->fs_info->sectorsize))\n\t\t\t\tpr_info(\n\t\t\t\"\\t\\t\\t(parent %llu not aligned to sectorsize %u)\\n\",\n\t\t\t\t\toffset, eb->fs_info->sectorsize);\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\t\tdref = (struct btrfs_extent_data_ref *)(&iref->offset);\n\t\t\tprint_extent_data_ref(eb, dref);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tsref = (struct btrfs_shared_data_ref *)(iref + 1);\n\t\t\tpr_cont(\"shared data backref parent %llu count %u\\n\",\n\t\t\t       offset, btrfs_shared_data_ref_count(eb, sref));\n\t\t\t \n\t\t\tif (!IS_ALIGNED(offset, eb->fs_info->sectorsize))\n\t\t\t\tpr_info(\n\t\t\t\"\\t\\t\\t(parent %llu not aligned to sectorsize %u)\\n\",\n\t\t\t\t     offset, eb->fs_info->sectorsize);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_cont(\"(extent %llu has INVALID ref type %d)\\n\",\n\t\t\t\t  eb->start, type);\n\t\t\treturn;\n\t\t}\n\t\tptr += btrfs_extent_inline_ref_size(type);\n\t}\n\tWARN_ON(ptr > end);\n}\n\nstatic void print_uuid_item(const struct extent_buffer *l, unsigned long offset,\n\t\t\t    u32 item_size)\n{\n\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\tpr_warn(\"BTRFS: uuid item with illegal size %lu!\\n\",\n\t\t\t(unsigned long)item_size);\n\t\treturn;\n\t}\n\twhile (item_size) {\n\t\t__le64 subvol_id;\n\n\t\tread_extent_buffer(l, &subvol_id, offset, sizeof(subvol_id));\n\t\tpr_info(\"\\t\\tsubvol_id %llu\\n\", le64_to_cpu(subvol_id));\n\t\titem_size -= sizeof(u64);\n\t\toffset += sizeof(u64);\n\t}\n}\n\n \nstatic void print_eb_refs_lock(const struct extent_buffer *eb)\n{\n#ifdef CONFIG_BTRFS_DEBUG\n\tbtrfs_info(eb->fs_info, \"refs %u lock_owner %u current %u\",\n\t\t   atomic_read(&eb->refs), eb->lock_owner, current->pid);\n#endif\n}\n\nvoid btrfs_print_leaf(const struct extent_buffer *l)\n{\n\tstruct btrfs_fs_info *fs_info;\n\tint i;\n\tu32 type, nr;\n\tstruct btrfs_root_item *ri;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_block_group_item *bi;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_extent_data_ref *dref;\n\tstruct btrfs_shared_data_ref *sref;\n\tstruct btrfs_dev_extent *dev_extent;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\n\tif (!l)\n\t\treturn;\n\n\tfs_info = l->fs_info;\n\tnr = btrfs_header_nritems(l);\n\n\tbtrfs_info(fs_info,\n\t\t   \"leaf %llu gen %llu total ptrs %d free space %d owner %llu\",\n\t\t   btrfs_header_bytenr(l), btrfs_header_generation(l), nr,\n\t\t   btrfs_leaf_free_space(l), btrfs_header_owner(l));\n\tprint_eb_refs_lock(l);\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tbtrfs_item_key_to_cpu(l, &key, i);\n\t\ttype = key.type;\n\t\tpr_info(\"\\titem %d key (%llu %u %llu) itemoff %d itemsize %d\\n\",\n\t\t\ti, key.objectid, type, key.offset,\n\t\t\tbtrfs_item_offset(l, i), btrfs_item_size(l, i));\n\t\tswitch (type) {\n\t\tcase BTRFS_INODE_ITEM_KEY:\n\t\t\tii = btrfs_item_ptr(l, i, struct btrfs_inode_item);\n\t\t\tpr_info(\"\\t\\tinode generation %llu size %llu mode %o\\n\",\n\t\t\t       btrfs_inode_generation(l, ii),\n\t\t\t       btrfs_inode_size(l, ii),\n\t\t\t       btrfs_inode_mode(l, ii));\n\t\t\tbreak;\n\t\tcase BTRFS_DIR_ITEM_KEY:\n\t\t\tdi = btrfs_item_ptr(l, i, struct btrfs_dir_item);\n\t\t\tbtrfs_dir_item_key_to_cpu(l, di, &found_key);\n\t\t\tpr_info(\"\\t\\tdir oid %llu flags %u\\n\",\n\t\t\t\tfound_key.objectid,\n\t\t\t\tbtrfs_dir_flags(l, di));\n\t\t\tbreak;\n\t\tcase BTRFS_ROOT_ITEM_KEY:\n\t\t\tri = btrfs_item_ptr(l, i, struct btrfs_root_item);\n\t\t\tpr_info(\"\\t\\troot data bytenr %llu refs %u\\n\",\n\t\t\t\tbtrfs_disk_root_bytenr(l, ri),\n\t\t\t\tbtrfs_disk_root_refs(l, ri));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_ITEM_KEY:\n\t\tcase BTRFS_METADATA_ITEM_KEY:\n\t\t\tprint_extent_item(l, i, type);\n\t\t\tbreak;\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\t\tpr_info(\"\\t\\ttree block backref\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tpr_info(\"\\t\\tshared block backref\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\t\tdref = btrfs_item_ptr(l, i,\n\t\t\t\t\t      struct btrfs_extent_data_ref);\n\t\t\tprint_extent_data_ref(l, dref);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tsref = btrfs_item_ptr(l, i,\n\t\t\t\t\t      struct btrfs_shared_data_ref);\n\t\t\tpr_info(\"\\t\\tshared data backref count %u\\n\",\n\t\t\t       btrfs_shared_data_ref_count(l, sref));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_KEY:\n\t\t\tfi = btrfs_item_ptr(l, i,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tif (btrfs_file_extent_type(l, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tpr_info(\"\\t\\tinline extent data size %llu\\n\",\n\t\t\t\t       btrfs_file_extent_ram_bytes(l, fi));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpr_info(\"\\t\\textent data disk bytenr %llu nr %llu\\n\",\n\t\t\t       btrfs_file_extent_disk_bytenr(l, fi),\n\t\t\t       btrfs_file_extent_disk_num_bytes(l, fi));\n\t\t\tpr_info(\"\\t\\textent data offset %llu nr %llu ram %llu\\n\",\n\t\t\t       btrfs_file_extent_offset(l, fi),\n\t\t\t       btrfs_file_extent_num_bytes(l, fi),\n\t\t\t       btrfs_file_extent_ram_bytes(l, fi));\n\t\t\tbreak;\n\t\tcase BTRFS_BLOCK_GROUP_ITEM_KEY:\n\t\t\tbi = btrfs_item_ptr(l, i,\n\t\t\t\t\t    struct btrfs_block_group_item);\n\t\t\tpr_info(\n\t\t   \"\\t\\tblock group used %llu chunk_objectid %llu flags %llu\\n\",\n\t\t\t\tbtrfs_block_group_used(l, bi),\n\t\t\t\tbtrfs_block_group_chunk_objectid(l, bi),\n\t\t\t\tbtrfs_block_group_flags(l, bi));\n\t\t\tbreak;\n\t\tcase BTRFS_CHUNK_ITEM_KEY:\n\t\t\tprint_chunk(l, btrfs_item_ptr(l, i,\n\t\t\t\t\t\t      struct btrfs_chunk));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_ITEM_KEY:\n\t\t\tprint_dev_item(l, btrfs_item_ptr(l, i,\n\t\t\t\t\tstruct btrfs_dev_item));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_EXTENT_KEY:\n\t\t\tdev_extent = btrfs_item_ptr(l, i,\n\t\t\t\t\t\t    struct btrfs_dev_extent);\n\t\t\tpr_info(\"\\t\\tdev extent chunk_tree %llu\\n\\t\\tchunk objectid %llu chunk offset %llu length %llu\\n\",\n\t\t\t       btrfs_dev_extent_chunk_tree(l, dev_extent),\n\t\t\t       btrfs_dev_extent_chunk_objectid(l, dev_extent),\n\t\t\t       btrfs_dev_extent_chunk_offset(l, dev_extent),\n\t\t\t       btrfs_dev_extent_length(l, dev_extent));\n\t\t\tbreak;\n\t\tcase BTRFS_PERSISTENT_ITEM_KEY:\n\t\t\tpr_info(\"\\t\\tpersistent item objectid %llu offset %llu\\n\",\n\t\t\t\t\tkey.objectid, key.offset);\n\t\t\tswitch (key.objectid) {\n\t\t\tcase BTRFS_DEV_STATS_OBJECTID:\n\t\t\t\tpr_info(\"\\t\\tdevice stats\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_info(\"\\t\\tunknown persistent item\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BTRFS_TEMPORARY_ITEM_KEY:\n\t\t\tpr_info(\"\\t\\ttemporary item objectid %llu offset %llu\\n\",\n\t\t\t\t\tkey.objectid, key.offset);\n\t\t\tswitch (key.objectid) {\n\t\t\tcase BTRFS_BALANCE_OBJECTID:\n\t\t\t\tpr_info(\"\\t\\tbalance status\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_info(\"\\t\\tunknown temporary item\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_REPLACE_KEY:\n\t\t\tpr_info(\"\\t\\tdev replace\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_UUID_KEY_SUBVOL:\n\t\tcase BTRFS_UUID_KEY_RECEIVED_SUBVOL:\n\t\t\tprint_uuid_item(l, btrfs_item_ptr_offset(l, i),\n\t\t\t\t\tbtrfs_item_size(l, i));\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid btrfs_print_tree(const struct extent_buffer *c, bool follow)\n{\n\tstruct btrfs_fs_info *fs_info;\n\tint i; u32 nr;\n\tstruct btrfs_key key;\n\tint level;\n\n\tif (!c)\n\t\treturn;\n\tfs_info = c->fs_info;\n\tnr = btrfs_header_nritems(c);\n\tlevel = btrfs_header_level(c);\n\tif (level == 0) {\n\t\tbtrfs_print_leaf(c);\n\t\treturn;\n\t}\n\tbtrfs_info(fs_info,\n\t\t   \"node %llu level %d gen %llu total ptrs %d free spc %u owner %llu\",\n\t\t   btrfs_header_bytenr(c), level, btrfs_header_generation(c),\n\t\t   nr, (u32)BTRFS_NODEPTRS_PER_BLOCK(fs_info) - nr,\n\t\t   btrfs_header_owner(c));\n\tprint_eb_refs_lock(c);\n\tfor (i = 0; i < nr; i++) {\n\t\tbtrfs_node_key_to_cpu(c, &key, i);\n\t\tpr_info(\"\\tkey %d (%llu %u %llu) block %llu gen %llu\\n\",\n\t\t       i, key.objectid, key.type, key.offset,\n\t\t       btrfs_node_blockptr(c, i),\n\t\t       btrfs_node_ptr_generation(c, i));\n\t}\n\tif (!follow)\n\t\treturn;\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct btrfs_tree_parent_check check = {\n\t\t\t.level = level - 1,\n\t\t\t.transid = btrfs_node_ptr_generation(c, i),\n\t\t\t.owner_root = btrfs_header_owner(c),\n\t\t\t.has_first_key = true\n\t\t};\n\t\tstruct extent_buffer *next;\n\n\t\tbtrfs_node_key_to_cpu(c, &check.first_key, i);\n\t\tnext = read_tree_block(fs_info, btrfs_node_blockptr(c, i), &check);\n\t\tif (IS_ERR(next))\n\t\t\tcontinue;\n\t\tif (!extent_buffer_uptodate(next)) {\n\t\t\tfree_extent_buffer(next);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (btrfs_is_leaf(next) &&\n\t\t   level != 1)\n\t\t\tBUG();\n\t\tif (btrfs_header_level(next) !=\n\t\t       level - 1)\n\t\t\tBUG();\n\t\tbtrfs_print_tree(next, follow);\n\t\tfree_extent_buffer(next);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}