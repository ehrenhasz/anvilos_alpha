{
  "module_name": "export.c",
  "hash_id": "0f677603b7446bd36c50124258037554fb32623bb405e2748b82ee1d975e72dd",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/export.c",
  "human_readable_source": "\n\n#include <linux/fs.h>\n#include <linux/types.h>\n#include \"ctree.h\"\n#include \"disk-io.h\"\n#include \"btrfs_inode.h\"\n#include \"print-tree.h\"\n#include \"export.h\"\n#include \"accessors.h\"\n#include \"super.h\"\n\n#define BTRFS_FID_SIZE_NON_CONNECTABLE (offsetof(struct btrfs_fid, \\\n\t\t\t\t\t\t parent_objectid) / 4)\n#define BTRFS_FID_SIZE_CONNECTABLE (offsetof(struct btrfs_fid, \\\n\t\t\t\t\t     parent_root_objectid) / 4)\n#define BTRFS_FID_SIZE_CONNECTABLE_ROOT (sizeof(struct btrfs_fid) / 4)\n\nstatic int btrfs_encode_fh(struct inode *inode, u32 *fh, int *max_len,\n\t\t\t   struct inode *parent)\n{\n\tstruct btrfs_fid *fid = (struct btrfs_fid *)fh;\n\tint len = *max_len;\n\tint type;\n\n\tif (parent && (len < BTRFS_FID_SIZE_CONNECTABLE)) {\n\t\t*max_len = BTRFS_FID_SIZE_CONNECTABLE;\n\t\treturn FILEID_INVALID;\n\t} else if (len < BTRFS_FID_SIZE_NON_CONNECTABLE) {\n\t\t*max_len = BTRFS_FID_SIZE_NON_CONNECTABLE;\n\t\treturn FILEID_INVALID;\n\t}\n\n\tlen  = BTRFS_FID_SIZE_NON_CONNECTABLE;\n\ttype = FILEID_BTRFS_WITHOUT_PARENT;\n\n\tfid->objectid = btrfs_ino(BTRFS_I(inode));\n\tfid->root_objectid = BTRFS_I(inode)->root->root_key.objectid;\n\tfid->gen = inode->i_generation;\n\n\tif (parent) {\n\t\tu64 parent_root_id;\n\n\t\tfid->parent_objectid = BTRFS_I(parent)->location.objectid;\n\t\tfid->parent_gen = parent->i_generation;\n\t\tparent_root_id = BTRFS_I(parent)->root->root_key.objectid;\n\n\t\tif (parent_root_id != fid->root_objectid) {\n\t\t\tfid->parent_root_objectid = parent_root_id;\n\t\t\tlen = BTRFS_FID_SIZE_CONNECTABLE_ROOT;\n\t\t\ttype = FILEID_BTRFS_WITH_PARENT_ROOT;\n\t\t} else {\n\t\t\tlen = BTRFS_FID_SIZE_CONNECTABLE;\n\t\t\ttype = FILEID_BTRFS_WITH_PARENT;\n\t\t}\n\t}\n\n\t*max_len = len;\n\treturn type;\n}\n\n \nstruct dentry *btrfs_get_dentry(struct super_block *sb, u64 objectid,\n\t\t\t\tu64 root_objectid, u64 generation)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *root;\n\tstruct inode *inode;\n\n\tif (objectid < BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn ERR_PTR(-ESTALE);\n\n\troot = btrfs_get_fs_root(fs_info, root_objectid, true);\n\tif (IS_ERR(root))\n\t\treturn ERR_CAST(root);\n\n\tinode = btrfs_iget(sb, objectid, root);\n\tbtrfs_put_root(root);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tif (generation != 0 && generation != inode->i_generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn d_obtain_alias(inode);\n}\n\nstatic struct dentry *btrfs_fh_to_parent(struct super_block *sb, struct fid *fh,\n\t\t\t\t\t int fh_len, int fh_type)\n{\n\tstruct btrfs_fid *fid = (struct btrfs_fid *) fh;\n\tu64 objectid, root_objectid;\n\tu32 generation;\n\n\tif (fh_type == FILEID_BTRFS_WITH_PARENT) {\n\t\tif (fh_len <  BTRFS_FID_SIZE_CONNECTABLE)\n\t\t\treturn NULL;\n\t\troot_objectid = fid->root_objectid;\n\t} else if (fh_type == FILEID_BTRFS_WITH_PARENT_ROOT) {\n\t\tif (fh_len < BTRFS_FID_SIZE_CONNECTABLE_ROOT)\n\t\t\treturn NULL;\n\t\troot_objectid = fid->parent_root_objectid;\n\t} else\n\t\treturn NULL;\n\n\tobjectid = fid->parent_objectid;\n\tgeneration = fid->parent_gen;\n\n\treturn btrfs_get_dentry(sb, objectid, root_objectid, generation);\n}\n\nstatic struct dentry *btrfs_fh_to_dentry(struct super_block *sb, struct fid *fh,\n\t\t\t\t\t int fh_len, int fh_type)\n{\n\tstruct btrfs_fid *fid = (struct btrfs_fid *) fh;\n\tu64 objectid, root_objectid;\n\tu32 generation;\n\n\tif ((fh_type != FILEID_BTRFS_WITH_PARENT ||\n\t     fh_len < BTRFS_FID_SIZE_CONNECTABLE) &&\n\t    (fh_type != FILEID_BTRFS_WITH_PARENT_ROOT ||\n\t     fh_len < BTRFS_FID_SIZE_CONNECTABLE_ROOT) &&\n\t    (fh_type != FILEID_BTRFS_WITHOUT_PARENT ||\n\t     fh_len < BTRFS_FID_SIZE_NON_CONNECTABLE))\n\t\treturn NULL;\n\n\tobjectid = fid->objectid;\n\troot_objectid = fid->root_objectid;\n\tgeneration = fid->gen;\n\n\treturn btrfs_get_dentry(sb, objectid, root_objectid, generation);\n}\n\nstruct dentry *btrfs_get_parent(struct dentry *child)\n{\n\tstruct inode *dir = d_inode(child);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(dir->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_root_ref *ref;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (btrfs_ino(BTRFS_I(dir)) == BTRFS_FIRST_FREE_OBJECTID) {\n\t\tkey.objectid = root->root_key.objectid;\n\t\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\t\tkey.offset = (u64)-1;\n\t\troot = fs_info->tree_root;\n\t} else {\n\t\tkey.objectid = btrfs_ino(BTRFS_I(dir));\n\t\tkey.type = BTRFS_INODE_REF_KEY;\n\t\tkey.offset = (u64)-1;\n\t}\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tBUG_ON(ret == 0);  \n\tif (path->slots[0] == 0) {\n\t\tret = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tpath->slots[0]--;\n\tleaf = path->nodes[0];\n\n\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\tif (found_key.objectid != key.objectid || found_key.type != key.type) {\n\t\tret = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tif (found_key.type == BTRFS_ROOT_BACKREF_KEY) {\n\t\tref = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t     struct btrfs_root_ref);\n\t\tkey.objectid = btrfs_root_ref_dirid(leaf, ref);\n\t} else {\n\t\tkey.objectid = found_key.offset;\n\t}\n\tbtrfs_free_path(path);\n\n\tif (found_key.type == BTRFS_ROOT_BACKREF_KEY) {\n\t\treturn btrfs_get_dentry(fs_info->sb, key.objectid,\n\t\t\t\t\tfound_key.offset, 0);\n\t}\n\n\treturn d_obtain_alias(btrfs_iget(fs_info->sb, key.objectid, root));\nfail:\n\tbtrfs_free_path(path);\n\treturn ERR_PTR(ret);\n}\n\nstatic int btrfs_get_name(struct dentry *parent, char *name,\n\t\t\t  struct dentry *child)\n{\n\tstruct inode *inode = d_inode(child);\n\tstruct inode *dir = d_inode(parent);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_root_ref *rref;\n\tstruct extent_buffer *leaf;\n\tunsigned long name_ptr;\n\tstruct btrfs_key key;\n\tint name_len;\n\tint ret;\n\tu64 ino;\n\n\tif (!S_ISDIR(dir->i_mode))\n\t\treturn -EINVAL;\n\n\tino = btrfs_ino(BTRFS_I(inode));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (ino == BTRFS_FIRST_FREE_OBJECTID) {\n\t\tkey.objectid = BTRFS_I(inode)->root->root_key.objectid;\n\t\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\t\tkey.offset = (u64)-1;\n\t\troot = fs_info->tree_root;\n\t} else {\n\t\tkey.objectid = ino;\n\t\tkey.offset = btrfs_ino(BTRFS_I(dir));\n\t\tkey.type = BTRFS_INODE_REF_KEY;\n\t}\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t} else if (ret > 0) {\n\t\tif (ino == BTRFS_FIRST_FREE_OBJECTID) {\n\t\t\tpath->slots[0]--;\n\t\t} else {\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\tleaf = path->nodes[0];\n\n\tif (ino == BTRFS_FIRST_FREE_OBJECTID) {\n\t\trref = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t     struct btrfs_root_ref);\n\t\tname_ptr = (unsigned long)(rref + 1);\n\t\tname_len = btrfs_root_ref_name_len(leaf, rref);\n\t} else {\n\t\tiref = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tname_ptr = (unsigned long)(iref + 1);\n\t\tname_len = btrfs_inode_ref_name_len(leaf, iref);\n\t}\n\n\tread_extent_buffer(leaf, name, name_ptr, name_len);\n\tbtrfs_free_path(path);\n\n\t \n\tname[name_len] = '\\0';\n\n\treturn 0;\n}\n\nconst struct export_operations btrfs_export_ops = {\n\t.encode_fh\t= btrfs_encode_fh,\n\t.fh_to_dentry\t= btrfs_fh_to_dentry,\n\t.fh_to_parent\t= btrfs_fh_to_parent,\n\t.get_parent\t= btrfs_get_parent,\n\t.get_name\t= btrfs_get_name,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}