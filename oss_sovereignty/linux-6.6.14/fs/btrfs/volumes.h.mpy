{
  "module_name": "volumes.h",
  "hash_id": "99691c454a70e1072521352e368d18413282de79e15f027a1a369c888ab3505c",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/volumes.h",
  "human_readable_source": " \n \n\n#ifndef BTRFS_VOLUMES_H\n#define BTRFS_VOLUMES_H\n\n#include <linux/sort.h>\n#include <linux/btrfs.h>\n#include \"async-thread.h\"\n#include \"messages.h\"\n#include \"tree-checker.h\"\n#include \"rcu-string.h\"\n\n#define BTRFS_MAX_DATA_CHUNK_SIZE\t(10ULL * SZ_1G)\n\nextern struct mutex uuid_mutex;\n\n#define BTRFS_STRIPE_LEN\t\tSZ_64K\n#define BTRFS_STRIPE_LEN_SHIFT\t\t(16)\n#define BTRFS_STRIPE_LEN_MASK\t\t(BTRFS_STRIPE_LEN - 1)\n\nstatic_assert(const_ilog2(BTRFS_STRIPE_LEN) == BTRFS_STRIPE_LEN_SHIFT);\n\n \n#define const_ffs(n) (__builtin_ctzll(n) + 1)\n\n \nstatic_assert(const_ffs(BTRFS_BLOCK_GROUP_RAID0) <\n\t      const_ffs(BTRFS_BLOCK_GROUP_PROFILE_MASK & ~BTRFS_BLOCK_GROUP_RAID0));\nstatic_assert(const_ilog2(BTRFS_BLOCK_GROUP_RAID0) >\n\t      ilog2(BTRFS_BLOCK_GROUP_TYPE_MASK));\n\n \n#define BTRFS_BG_FLAG_TO_INDEX(profile)\t\t\t\t\t\\\n\tilog2((profile) >> (ilog2(BTRFS_BLOCK_GROUP_RAID0) - 1))\n\nenum btrfs_raid_types {\n\t \n\tBTRFS_RAID_SINGLE  = 0,\n\n\tBTRFS_RAID_RAID0   = BTRFS_BG_FLAG_TO_INDEX(BTRFS_BLOCK_GROUP_RAID0),\n\tBTRFS_RAID_RAID1   = BTRFS_BG_FLAG_TO_INDEX(BTRFS_BLOCK_GROUP_RAID1),\n\tBTRFS_RAID_DUP\t   = BTRFS_BG_FLAG_TO_INDEX(BTRFS_BLOCK_GROUP_DUP),\n\tBTRFS_RAID_RAID10  = BTRFS_BG_FLAG_TO_INDEX(BTRFS_BLOCK_GROUP_RAID10),\n\tBTRFS_RAID_RAID5   = BTRFS_BG_FLAG_TO_INDEX(BTRFS_BLOCK_GROUP_RAID5),\n\tBTRFS_RAID_RAID6   = BTRFS_BG_FLAG_TO_INDEX(BTRFS_BLOCK_GROUP_RAID6),\n\tBTRFS_RAID_RAID1C3 = BTRFS_BG_FLAG_TO_INDEX(BTRFS_BLOCK_GROUP_RAID1C3),\n\tBTRFS_RAID_RAID1C4 = BTRFS_BG_FLAG_TO_INDEX(BTRFS_BLOCK_GROUP_RAID1C4),\n\n\tBTRFS_NR_RAID_TYPES\n};\n\n \n#if BITS_PER_LONG==32 && defined(CONFIG_SMP)\n#include <linux/seqlock.h>\n#define __BTRFS_NEED_DEVICE_DATA_ORDERED\n#define btrfs_device_data_ordered_init(device)\t\\\n\tseqcount_init(&device->data_seqcount)\n#else\n#define btrfs_device_data_ordered_init(device) do { } while (0)\n#endif\n\n#define BTRFS_DEV_STATE_WRITEABLE\t(0)\n#define BTRFS_DEV_STATE_IN_FS_METADATA\t(1)\n#define BTRFS_DEV_STATE_MISSING\t\t(2)\n#define BTRFS_DEV_STATE_REPLACE_TGT\t(3)\n#define BTRFS_DEV_STATE_FLUSH_SENT\t(4)\n#define BTRFS_DEV_STATE_NO_READA\t(5)\n\nstruct btrfs_zoned_device_info;\n\nstruct btrfs_device {\n\tstruct list_head dev_list;  \n\tstruct list_head dev_alloc_list;  \n\tstruct list_head post_commit_list;  \n\tstruct btrfs_fs_devices *fs_devices;\n\tstruct btrfs_fs_info *fs_info;\n\n\tstruct rcu_string __rcu *name;\n\n\tu64 generation;\n\n\tstruct block_device *bdev;\n\n\tstruct btrfs_zoned_device_info *zone_info;\n\n\t \n\tvoid *holder;\n\n\t \n\tdev_t devt;\n\tunsigned long dev_state;\n\tblk_status_t last_flush_error;\n\n#ifdef __BTRFS_NEED_DEVICE_DATA_ORDERED\n\tseqcount_t data_seqcount;\n#endif\n\n\t \n\tu64 devid;\n\n\t \n\tu64 total_bytes;\n\n\t \n\tu64 disk_total_bytes;\n\n\t \n\tu64 bytes_used;\n\n\t \n\tu32 io_align;\n\n\t \n\tu32 io_width;\n\t \n\tu64 type;\n\n\t \n\tu32 sector_size;\n\n\t \n\tu8 uuid[BTRFS_UUID_SIZE];\n\n\t \n\tu64 commit_total_bytes;\n\n\t \n\tu64 commit_bytes_used;\n\n\t \n\tstruct bio flush_bio;\n\tstruct completion flush_wait;\n\n\t \n\tstruct scrub_ctx *scrub_ctx;\n\n\t \n\tint dev_stats_valid;\n\n\t \n\tatomic_t dev_stats_ccnt;\n\tatomic_t dev_stat_values[BTRFS_DEV_STAT_VALUES_MAX];\n\n\tstruct extent_io_tree alloc_state;\n\n\tstruct completion kobj_unregister;\n\t \n\tstruct kobject devid_kobj;\n\n\t \n\tu64 scrub_speed_max;\n};\n\n \nstruct btrfs_swapfile_pin {\n\tstruct rb_node node;\n\tvoid *ptr;\n\tstruct inode *inode;\n\t \n\tbool is_block_group;\n\t \n\tint bg_extent_count;\n};\n\n \n#if BITS_PER_LONG==32 && defined(CONFIG_SMP)\n#define BTRFS_DEVICE_GETSET_FUNCS(name)\t\t\t\t\t\\\nstatic inline u64\t\t\t\t\t\t\t\\\nbtrfs_device_get_##name(const struct btrfs_device *dev)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tu64 size;\t\t\t\t\t\t\t\\\n\tunsigned int seq;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tseq = read_seqcount_begin(&dev->data_seqcount);\t\t\\\n\t\tsize = dev->name;\t\t\t\t\t\\\n\t} while (read_seqcount_retry(&dev->data_seqcount, seq));\t\\\n\treturn size;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic inline void\t\t\t\t\t\t\t\\\nbtrfs_device_set_##name(struct btrfs_device *dev, u64 size)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tpreempt_disable();\t\t\t\t\t\t\\\n\twrite_seqcount_begin(&dev->data_seqcount);\t\t\t\\\n\tdev->name = size;\t\t\t\t\t\t\\\n\twrite_seqcount_end(&dev->data_seqcount);\t\t\t\\\n\tpreempt_enable();\t\t\t\t\t\t\\\n}\n#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPTION)\n#define BTRFS_DEVICE_GETSET_FUNCS(name)\t\t\t\t\t\\\nstatic inline u64\t\t\t\t\t\t\t\\\nbtrfs_device_get_##name(const struct btrfs_device *dev)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tu64 size;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tpreempt_disable();\t\t\t\t\t\t\\\n\tsize = dev->name;\t\t\t\t\t\t\\\n\tpreempt_enable();\t\t\t\t\t\t\\\n\treturn size;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic inline void\t\t\t\t\t\t\t\\\nbtrfs_device_set_##name(struct btrfs_device *dev, u64 size)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tpreempt_disable();\t\t\t\t\t\t\\\n\tdev->name = size;\t\t\t\t\t\t\\\n\tpreempt_enable();\t\t\t\t\t\t\\\n}\n#else\n#define BTRFS_DEVICE_GETSET_FUNCS(name)\t\t\t\t\t\\\nstatic inline u64\t\t\t\t\t\t\t\\\nbtrfs_device_get_##name(const struct btrfs_device *dev)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn dev->name;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic inline void\t\t\t\t\t\t\t\\\nbtrfs_device_set_##name(struct btrfs_device *dev, u64 size)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tdev->name = size;\t\t\t\t\t\t\\\n}\n#endif\n\nBTRFS_DEVICE_GETSET_FUNCS(total_bytes);\nBTRFS_DEVICE_GETSET_FUNCS(disk_total_bytes);\nBTRFS_DEVICE_GETSET_FUNCS(bytes_used);\n\nenum btrfs_chunk_allocation_policy {\n\tBTRFS_CHUNK_ALLOC_REGULAR,\n\tBTRFS_CHUNK_ALLOC_ZONED,\n};\n\n \nenum btrfs_read_policy {\n\t \n\tBTRFS_READ_POLICY_PID,\n\tBTRFS_NR_READ_POLICY,\n};\n\nstruct btrfs_fs_devices {\n\tu8 fsid[BTRFS_FSID_SIZE];  \n\n\t \n\tu8 metadata_uuid[BTRFS_FSID_SIZE];\n\n\tstruct list_head fs_list;\n\n\t \n\tu64 num_devices;\n\n\t \n\tu64 open_devices;\n\n\t \n\tu64 rw_devices;\n\n\t \n\tu64 missing_devices;\n\tu64 total_rw_bytes;\n\n\t \n\tu64 total_devices;\n\n\t \n\tu64 latest_generation;\n\n\t \n\tstruct btrfs_device *latest_dev;\n\n\t \n\tstruct mutex device_list_mutex;\n\n\t \n\tstruct list_head devices;\n\n\t \n\tstruct list_head alloc_list;\n\n\tstruct list_head seed_list;\n\n\t \n\tint opened;\n\n\t \n\tbool rotating;\n\t \n\tbool discardable;\n\tbool fsid_change;\n\t \n\tbool seeding;\n\n\tstruct btrfs_fs_info *fs_info;\n\t \n\tstruct kobject fsid_kobj;\n\tstruct kobject *devices_kobj;\n\tstruct kobject *devinfo_kobj;\n\tstruct completion kobj_unregister;\n\n\tenum btrfs_chunk_allocation_policy chunk_alloc_policy;\n\n\t \n\tenum btrfs_read_policy read_policy;\n};\n\n#define BTRFS_MAX_DEVS(info) ((BTRFS_MAX_ITEM_SIZE(info)\t\\\n\t\t\t- sizeof(struct btrfs_chunk))\t\t\\\n\t\t\t/ sizeof(struct btrfs_stripe) + 1)\n\n#define BTRFS_MAX_DEVS_SYS_CHUNK ((BTRFS_SYSTEM_CHUNK_ARRAY_SIZE\t\\\n\t\t\t\t- 2 * sizeof(struct btrfs_disk_key)\t\\\n\t\t\t\t- 2 * sizeof(struct btrfs_chunk))\t\\\n\t\t\t\t/ sizeof(struct btrfs_stripe) + 1)\n\nstruct btrfs_io_stripe {\n\tstruct btrfs_device *dev;\n\tunion {\n\t\t \n\t\tu64 physical;\n\t\t \n\t\tstruct btrfs_io_context *bioc;\n\t};\n};\n\nstruct btrfs_discard_stripe {\n\tstruct btrfs_device *dev;\n\tu64 physical;\n\tu64 length;\n};\n\n \nstruct btrfs_io_context {\n\trefcount_t refs;\n\tstruct btrfs_fs_info *fs_info;\n\tu64 map_type;  \n\tstruct bio *orig_bio;\n\tatomic_t error;\n\tu16 max_errors;\n\n\t \n\tu16 num_stripes;\n\n\t \n\tu16 mirror_num;\n\n\t \n\tu16 replace_nr_stripes;\n\ts16 replace_stripe_src;\n\t \n\tu64 full_stripe_logical;\n\tstruct btrfs_io_stripe stripes[];\n};\n\nstruct btrfs_device_info {\n\tstruct btrfs_device *dev;\n\tu64 dev_offset;\n\tu64 max_avail;\n\tu64 total_avail;\n};\n\nstruct btrfs_raid_attr {\n\tu8 sub_stripes;\t\t \n\tu8 dev_stripes;\t\t \n\tu8 devs_max;\t\t \n\tu8 devs_min;\t\t \n\tu8 tolerated_failures;\t \n\tu8 devs_increment;\t \n\tu8 ncopies;\t\t \n\tu8 nparity;\t\t \n\tu8 mindev_error;\t \n\tconst char raid_name[8];  \n\tu64 bg_flag;\t\t \n};\n\nextern const struct btrfs_raid_attr btrfs_raid_array[BTRFS_NR_RAID_TYPES];\n\nstruct map_lookup {\n\tu64 type;\n\tint io_align;\n\tint io_width;\n\tint num_stripes;\n\tint sub_stripes;\n\tint verified_stripes;  \n\tstruct btrfs_io_stripe stripes[];\n};\n\n#define map_lookup_size(n) (sizeof(struct map_lookup) + \\\n\t\t\t    (sizeof(struct btrfs_io_stripe) * (n)))\n\nstruct btrfs_balance_args;\nstruct btrfs_balance_progress;\nstruct btrfs_balance_control {\n\tstruct btrfs_balance_args data;\n\tstruct btrfs_balance_args meta;\n\tstruct btrfs_balance_args sys;\n\n\tu64 flags;\n\n\tstruct btrfs_balance_progress stat;\n};\n\n \nstruct btrfs_dev_lookup_args {\n\tu64 devid;\n\tu8 *uuid;\n\tu8 *fsid;\n\tbool missing;\n};\n\n \n#define BTRFS_DEV_LOOKUP_ARGS_INIT { .devid = (u64)-1 }\n\n#define BTRFS_DEV_LOOKUP_ARGS(name) \\\n\tstruct btrfs_dev_lookup_args name = BTRFS_DEV_LOOKUP_ARGS_INIT\n\nenum btrfs_map_op {\n\tBTRFS_MAP_READ,\n\tBTRFS_MAP_WRITE,\n\tBTRFS_MAP_GET_READ_MIRRORS,\n};\n\nstatic inline enum btrfs_map_op btrfs_op(struct bio *bio)\n{\n\tswitch (bio_op(bio)) {\n\tcase REQ_OP_WRITE:\n\tcase REQ_OP_ZONE_APPEND:\n\t\treturn BTRFS_MAP_WRITE;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tfallthrough;\n\tcase REQ_OP_READ:\n\t\treturn BTRFS_MAP_READ;\n\t}\n}\n\nstatic inline unsigned long btrfs_chunk_item_size(int num_stripes)\n{\n\tASSERT(num_stripes);\n\treturn sizeof(struct btrfs_chunk) +\n\t\tsizeof(struct btrfs_stripe) * (num_stripes - 1);\n}\n\n \nstatic inline u64 btrfs_stripe_nr_to_offset(u32 stripe_nr)\n{\n\treturn (u64)stripe_nr << BTRFS_STRIPE_LEN_SHIFT;\n}\n\nvoid btrfs_get_bioc(struct btrfs_io_context *bioc);\nvoid btrfs_put_bioc(struct btrfs_io_context *bioc);\nint btrfs_map_block(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,\n\t\t    u64 logical, u64 *length,\n\t\t    struct btrfs_io_context **bioc_ret,\n\t\t    struct btrfs_io_stripe *smap, int *mirror_num_ret,\n\t\t    int need_raid_map);\nint btrfs_map_repair_block(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_io_stripe *smap, u64 logical,\n\t\t\t   u32 length, int mirror_num);\nstruct btrfs_discard_stripe *btrfs_map_discard(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t       u64 logical, u64 *length_ret,\n\t\t\t\t\t       u32 *num_stripes);\nint btrfs_read_sys_array(struct btrfs_fs_info *fs_info);\nint btrfs_read_chunk_tree(struct btrfs_fs_info *fs_info);\nstruct btrfs_block_group *btrfs_create_chunk(struct btrfs_trans_handle *trans,\n\t\t\t\t\t    u64 type);\nvoid btrfs_mapping_tree_free(struct extent_map_tree *tree);\nint btrfs_open_devices(struct btrfs_fs_devices *fs_devices,\n\t\t       blk_mode_t flags, void *holder);\nstruct btrfs_device *btrfs_scan_one_device(const char *path, blk_mode_t flags);\nint btrfs_forget_devices(dev_t devt);\nvoid btrfs_close_devices(struct btrfs_fs_devices *fs_devices);\nvoid btrfs_free_extra_devids(struct btrfs_fs_devices *fs_devices);\nvoid btrfs_assign_next_active_device(struct btrfs_device *device,\n\t\t\t\t     struct btrfs_device *this_dev);\nstruct btrfs_device *btrfs_find_device_by_devspec(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\t  u64 devid,\n\t\t\t\t\t\t  const char *devpath);\nint btrfs_get_dev_args_from_path(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct btrfs_dev_lookup_args *args,\n\t\t\t\t const char *path);\nstruct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tconst u64 *devid, const u8 *uuid,\n\t\t\t\t\tconst char *path);\nvoid btrfs_put_dev_args_from_path(struct btrfs_dev_lookup_args *args);\nint btrfs_rm_device(struct btrfs_fs_info *fs_info,\n\t\t    struct btrfs_dev_lookup_args *args,\n\t\t    struct block_device **bdev, void **holder);\nvoid __exit btrfs_cleanup_fs_uuids(void);\nint btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len);\nint btrfs_grow_device(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_device *device, u64 new_size);\nstruct btrfs_device *btrfs_find_device(const struct btrfs_fs_devices *fs_devices,\n\t\t\t\t       const struct btrfs_dev_lookup_args *args);\nint btrfs_shrink_device(struct btrfs_device *device, u64 new_size);\nint btrfs_init_new_device(struct btrfs_fs_info *fs_info, const char *path);\nint btrfs_balance(struct btrfs_fs_info *fs_info,\n\t\t  struct btrfs_balance_control *bctl,\n\t\t  struct btrfs_ioctl_balance_args *bargs);\nvoid btrfs_describe_block_groups(u64 flags, char *buf, u32 size_buf);\nint btrfs_resume_balance_async(struct btrfs_fs_info *fs_info);\nint btrfs_recover_balance(struct btrfs_fs_info *fs_info);\nint btrfs_pause_balance(struct btrfs_fs_info *fs_info);\nint btrfs_relocate_chunk(struct btrfs_fs_info *fs_info, u64 chunk_offset);\nint btrfs_cancel_balance(struct btrfs_fs_info *fs_info);\nint btrfs_create_uuid_tree(struct btrfs_fs_info *fs_info);\nint btrfs_uuid_scan_kthread(void *data);\nbool btrfs_chunk_writeable(struct btrfs_fs_info *fs_info, u64 chunk_offset);\nvoid btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index);\nint btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats);\nint btrfs_init_devices_late(struct btrfs_fs_info *fs_info);\nint btrfs_init_dev_stats(struct btrfs_fs_info *fs_info);\nint btrfs_run_dev_stats(struct btrfs_trans_handle *trans);\nvoid btrfs_rm_dev_replace_remove_srcdev(struct btrfs_device *srcdev);\nvoid btrfs_rm_dev_replace_free_srcdev(struct btrfs_device *srcdev);\nvoid btrfs_destroy_dev_replace_tgtdev(struct btrfs_device *tgtdev);\nint btrfs_is_parity_mirror(struct btrfs_fs_info *fs_info,\n\t\t\t   u64 logical, u64 len);\nunsigned long btrfs_full_stripe_len(struct btrfs_fs_info *fs_info,\n\t\t\t\t    u64 logical);\nu64 btrfs_calc_stripe_length(const struct extent_map *em);\nint btrfs_nr_parity_stripes(u64 type);\nint btrfs_chunk_alloc_add_chunk_item(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_block_group *bg);\nint btrfs_remove_chunk(struct btrfs_trans_handle *trans, u64 chunk_offset);\nstruct extent_map *btrfs_get_chunk_map(struct btrfs_fs_info *fs_info,\n\t\t\t\t       u64 logical, u64 length);\nvoid btrfs_release_disk_super(struct btrfs_super_block *super);\n\nstatic inline void btrfs_dev_stat_inc(struct btrfs_device *dev,\n\t\t\t\t      int index)\n{\n\tatomic_inc(dev->dev_stat_values + index);\n\t \n\tsmp_mb__before_atomic();\n\tatomic_inc(&dev->dev_stats_ccnt);\n}\n\nstatic inline int btrfs_dev_stat_read(struct btrfs_device *dev,\n\t\t\t\t      int index)\n{\n\treturn atomic_read(dev->dev_stat_values + index);\n}\n\nstatic inline int btrfs_dev_stat_read_and_reset(struct btrfs_device *dev,\n\t\t\t\t\t\tint index)\n{\n\tint ret;\n\n\tret = atomic_xchg(dev->dev_stat_values + index, 0);\n\t \n\tatomic_inc(&dev->dev_stats_ccnt);\n\treturn ret;\n}\n\nstatic inline void btrfs_dev_stat_set(struct btrfs_device *dev,\n\t\t\t\t      int index, unsigned long val)\n{\n\tatomic_set(dev->dev_stat_values + index, val);\n\t \n\tsmp_mb__before_atomic();\n\tatomic_inc(&dev->dev_stats_ccnt);\n}\n\nstatic inline const char *btrfs_dev_name(const struct btrfs_device *device)\n{\n\tif (!device || test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state))\n\t\treturn \"<missing disk>\";\n\telse\n\t\treturn rcu_str_deref(device->name);\n}\n\nvoid btrfs_commit_device_sizes(struct btrfs_transaction *trans);\n\nstruct list_head * __attribute_const__ btrfs_get_fs_uuids(void);\nbool btrfs_check_rw_degradable(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tstruct btrfs_device *failing_dev);\nvoid btrfs_scratch_superblocks(struct btrfs_fs_info *fs_info,\n\t\t\t       struct block_device *bdev,\n\t\t\t       const char *device_path);\n\nenum btrfs_raid_types __attribute_const__ btrfs_bg_flags_to_raid_index(u64 flags);\nint btrfs_bg_type_to_factor(u64 flags);\nconst char *btrfs_bg_type_to_raid_name(u64 flags);\nint btrfs_verify_dev_extents(struct btrfs_fs_info *fs_info);\nbool btrfs_repair_one_zone(struct btrfs_fs_info *fs_info, u64 logical);\n\nbool btrfs_pinned_by_swapfile(struct btrfs_fs_info *fs_info, void *ptr);\nu8 *btrfs_sb_fsid_ptr(struct btrfs_super_block *sb);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}