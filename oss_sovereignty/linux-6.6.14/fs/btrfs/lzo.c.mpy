{
  "module_name": "lzo.c",
  "hash_id": "4dddc38e999f6d90b5030fc597c9ce33b1931130aa332ed5c344e79cdb3a2161",
  "original_prompt": "Ingested from linux-6.6.14/fs/btrfs/lzo.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/lzo.h>\n#include <linux/refcount.h>\n#include \"messages.h\"\n#include \"compression.h\"\n#include \"ctree.h\"\n#include \"super.h\"\n#include \"btrfs_inode.h\"\n\n#define LZO_LEN\t4\n\n \n\n#define WORKSPACE_BUF_LENGTH\t(lzo1x_worst_compress(PAGE_SIZE))\n#define WORKSPACE_CBUF_LENGTH\t(lzo1x_worst_compress(PAGE_SIZE))\n\nstruct workspace {\n\tvoid *mem;\n\tvoid *buf;\t \n\tvoid *cbuf;\t \n\tstruct list_head list;\n};\n\nstatic struct workspace_manager wsm;\n\nvoid lzo_free_workspace(struct list_head *ws)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\n\tkvfree(workspace->buf);\n\tkvfree(workspace->cbuf);\n\tkvfree(workspace->mem);\n\tkfree(workspace);\n}\n\nstruct list_head *lzo_alloc_workspace(unsigned int level)\n{\n\tstruct workspace *workspace;\n\n\tworkspace = kzalloc(sizeof(*workspace), GFP_KERNEL);\n\tif (!workspace)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tworkspace->mem = kvmalloc(LZO1X_MEM_COMPRESS, GFP_KERNEL | __GFP_NOWARN);\n\tworkspace->buf = kvmalloc(WORKSPACE_BUF_LENGTH, GFP_KERNEL | __GFP_NOWARN);\n\tworkspace->cbuf = kvmalloc(WORKSPACE_CBUF_LENGTH, GFP_KERNEL | __GFP_NOWARN);\n\tif (!workspace->mem || !workspace->buf || !workspace->cbuf)\n\t\tgoto fail;\n\n\tINIT_LIST_HEAD(&workspace->list);\n\n\treturn &workspace->list;\nfail:\n\tlzo_free_workspace(&workspace->list);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic inline void write_compress_length(char *buf, size_t len)\n{\n\t__le32 dlen;\n\n\tdlen = cpu_to_le32(len);\n\tmemcpy(buf, &dlen, LZO_LEN);\n}\n\nstatic inline size_t read_compress_length(const char *buf)\n{\n\t__le32 dlen;\n\n\tmemcpy(&dlen, buf, LZO_LEN);\n\treturn le32_to_cpu(dlen);\n}\n\n \nstatic int copy_compressed_data_to_page(char *compressed_data,\n\t\t\t\t\tsize_t compressed_size,\n\t\t\t\t\tstruct page **out_pages,\n\t\t\t\t\tunsigned long max_nr_page,\n\t\t\t\t\tu32 *cur_out,\n\t\t\t\t\tconst u32 sectorsize)\n{\n\tu32 sector_bytes_left;\n\tu32 orig_out;\n\tstruct page *cur_page;\n\tchar *kaddr;\n\n\tif ((*cur_out / PAGE_SIZE) >= max_nr_page)\n\t\treturn -E2BIG;\n\n\t \n\tASSERT((*cur_out / sectorsize) == (*cur_out + LZO_LEN - 1) / sectorsize);\n\n\tcur_page = out_pages[*cur_out / PAGE_SIZE];\n\t \n\tif (!cur_page) {\n\t\tcur_page = alloc_page(GFP_NOFS);\n\t\tif (!cur_page)\n\t\t\treturn -ENOMEM;\n\t\tout_pages[*cur_out / PAGE_SIZE] = cur_page;\n\t}\n\n\tkaddr = kmap_local_page(cur_page);\n\twrite_compress_length(kaddr + offset_in_page(*cur_out),\n\t\t\t      compressed_size);\n\t*cur_out += LZO_LEN;\n\n\torig_out = *cur_out;\n\n\t \n\twhile (*cur_out - orig_out < compressed_size) {\n\t\tu32 copy_len = min_t(u32, sectorsize - *cur_out % sectorsize,\n\t\t\t\t     orig_out + compressed_size - *cur_out);\n\n\t\tkunmap_local(kaddr);\n\n\t\tif ((*cur_out / PAGE_SIZE) >= max_nr_page)\n\t\t\treturn -E2BIG;\n\n\t\tcur_page = out_pages[*cur_out / PAGE_SIZE];\n\t\t \n\t\tif (!cur_page) {\n\t\t\tcur_page = alloc_page(GFP_NOFS);\n\t\t\tif (!cur_page)\n\t\t\t\treturn -ENOMEM;\n\t\t\tout_pages[*cur_out / PAGE_SIZE] = cur_page;\n\t\t}\n\t\tkaddr = kmap_local_page(cur_page);\n\n\t\tmemcpy(kaddr + offset_in_page(*cur_out),\n\t\t       compressed_data + *cur_out - orig_out, copy_len);\n\n\t\t*cur_out += copy_len;\n\t}\n\n\t \n\tsector_bytes_left = round_up(*cur_out, sectorsize) - *cur_out;\n\tif (sector_bytes_left >= LZO_LEN || sector_bytes_left == 0)\n\t\tgoto out;\n\n\t \n\tmemset(kaddr + offset_in_page(*cur_out), 0,\n\t       sector_bytes_left);\n\t*cur_out += sector_bytes_left;\n\nout:\n\tkunmap_local(kaddr);\n\treturn 0;\n}\n\nint lzo_compress_pages(struct list_head *ws, struct address_space *mapping,\n\t\tu64 start, struct page **pages, unsigned long *out_pages,\n\t\tunsigned long *total_in, unsigned long *total_out)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\tconst u32 sectorsize = btrfs_sb(mapping->host->i_sb)->sectorsize;\n\tstruct page *page_in = NULL;\n\tchar *sizes_ptr;\n\tconst unsigned long max_nr_page = *out_pages;\n\tint ret = 0;\n\t \n\tu64 cur_in = start;\n\t \n\tu32 cur_out = 0;\n\tu32 len = *total_out;\n\n\tASSERT(max_nr_page > 0);\n\t*out_pages = 0;\n\t*total_out = 0;\n\t*total_in = 0;\n\n\t \n\tcur_out += LZO_LEN;\n\twhile (cur_in < start + len) {\n\t\tchar *data_in;\n\t\tconst u32 sectorsize_mask = sectorsize - 1;\n\t\tu32 sector_off = (cur_in - start) & sectorsize_mask;\n\t\tu32 in_len;\n\t\tsize_t out_len;\n\n\t\t \n\t\tif (!page_in) {\n\t\t\tpage_in = find_get_page(mapping, cur_in >> PAGE_SHIFT);\n\t\t\tASSERT(page_in);\n\t\t}\n\n\t\t \n\t\tin_len = min_t(u32, start + len - cur_in, sectorsize - sector_off);\n\t\tASSERT(in_len);\n\t\tdata_in = kmap_local_page(page_in);\n\t\tret = lzo1x_1_compress(data_in +\n\t\t\t\t       offset_in_page(cur_in), in_len,\n\t\t\t\t       workspace->cbuf, &out_len,\n\t\t\t\t       workspace->mem);\n\t\tkunmap_local(data_in);\n\t\tif (ret < 0) {\n\t\t\tpr_debug(\"BTRFS: lzo in loop returned %d\\n\", ret);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = copy_compressed_data_to_page(workspace->cbuf, out_len,\n\t\t\t\t\t\t   pages, max_nr_page,\n\t\t\t\t\t\t   &cur_out, sectorsize);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tcur_in += in_len;\n\n\t\t \n\t\tif (cur_in - start > sectorsize * 2 && cur_in - start < cur_out) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (PAGE_ALIGNED(cur_in)) {\n\t\t\tput_page(page_in);\n\t\t\tpage_in = NULL;\n\t\t}\n\t}\n\n\t \n\tsizes_ptr = kmap_local_page(pages[0]);\n\twrite_compress_length(sizes_ptr, cur_out);\n\tkunmap_local(sizes_ptr);\n\n\tret = 0;\n\t*total_out = cur_out;\n\t*total_in = cur_in - start;\nout:\n\tif (page_in)\n\t\tput_page(page_in);\n\t*out_pages = DIV_ROUND_UP(cur_out, PAGE_SIZE);\n\treturn ret;\n}\n\n \nstatic void copy_compressed_segment(struct compressed_bio *cb,\n\t\t\t\t    char *dest, u32 len, u32 *cur_in)\n{\n\tu32 orig_in = *cur_in;\n\n\twhile (*cur_in < orig_in + len) {\n\t\tstruct page *cur_page;\n\t\tu32 copy_len = min_t(u32, PAGE_SIZE - offset_in_page(*cur_in),\n\t\t\t\t\t  orig_in + len - *cur_in);\n\n\t\tASSERT(copy_len);\n\t\tcur_page = cb->compressed_pages[*cur_in / PAGE_SIZE];\n\n\t\tmemcpy_from_page(dest + *cur_in - orig_in, cur_page,\n\t\t\t\t offset_in_page(*cur_in), copy_len);\n\n\t\t*cur_in += copy_len;\n\t}\n}\n\nint lzo_decompress_bio(struct list_head *ws, struct compressed_bio *cb)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\tconst struct btrfs_fs_info *fs_info = cb->bbio.inode->root->fs_info;\n\tconst u32 sectorsize = fs_info->sectorsize;\n\tchar *kaddr;\n\tint ret;\n\t \n\tu32 len_in;\n\t \n\tu32 cur_in = 0;\n\t \n\tu32 cur_out = 0;\n\n\tkaddr = kmap_local_page(cb->compressed_pages[0]);\n\tlen_in = read_compress_length(kaddr);\n\tkunmap_local(kaddr);\n\tcur_in += LZO_LEN;\n\n\t \n\tif (len_in > min_t(size_t, BTRFS_MAX_COMPRESSED, cb->compressed_len) ||\n\t    round_up(len_in, sectorsize) < cb->compressed_len) {\n\t\tbtrfs_err(fs_info,\n\t\t\t\"invalid lzo header, lzo len %u compressed len %u\",\n\t\t\tlen_in, cb->compressed_len);\n\t\treturn -EUCLEAN;\n\t}\n\n\t \n\twhile (cur_in < len_in) {\n\t\tstruct page *cur_page;\n\t\t \n\t\tu32 seg_len;\n\t\tu32 sector_bytes_left;\n\t\tsize_t out_len = lzo1x_worst_compress(sectorsize);\n\n\t\t \n\t\tASSERT(cur_in / sectorsize ==\n\t\t       (cur_in + LZO_LEN - 1) / sectorsize);\n\t\tcur_page = cb->compressed_pages[cur_in / PAGE_SIZE];\n\t\tASSERT(cur_page);\n\t\tkaddr = kmap_local_page(cur_page);\n\t\tseg_len = read_compress_length(kaddr + offset_in_page(cur_in));\n\t\tkunmap_local(kaddr);\n\t\tcur_in += LZO_LEN;\n\n\t\tif (seg_len > WORKSPACE_CBUF_LENGTH) {\n\t\t\t \n\t\t\tbtrfs_err(fs_info, \"unexpectedly large lzo segment len %u\",\n\t\t\t\t\tseg_len);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tcopy_compressed_segment(cb, workspace->cbuf, seg_len, &cur_in);\n\n\t\t \n\t\tret = lzo1x_decompress_safe(workspace->cbuf, seg_len,\n\t\t\t\t\t    workspace->buf, &out_len);\n\t\tif (ret != LZO_E_OK) {\n\t\t\tbtrfs_err(fs_info, \"failed to decompress\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tret = btrfs_decompress_buf2page(workspace->buf, out_len, cb, cur_out);\n\t\tcur_out += out_len;\n\n\t\t \n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t\tret = 0;\n\n\t\t \n\t\tsector_bytes_left = sectorsize - (cur_in % sectorsize);\n\t\tif (sector_bytes_left >= LZO_LEN)\n\t\t\tcontinue;\n\n\t\t \n\t\tcur_in += sector_bytes_left;\n\t}\n\n\treturn 0;\n}\n\nint lzo_decompress(struct list_head *ws, const u8 *data_in,\n\t\tstruct page *dest_page, unsigned long start_byte, size_t srclen,\n\t\tsize_t destlen)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\tsize_t in_len;\n\tsize_t out_len;\n\tsize_t max_segment_len = WORKSPACE_BUF_LENGTH;\n\tint ret = 0;\n\tchar *kaddr;\n\tunsigned long bytes;\n\n\tif (srclen < LZO_LEN || srclen > max_segment_len + LZO_LEN * 2)\n\t\treturn -EUCLEAN;\n\n\tin_len = read_compress_length(data_in);\n\tif (in_len != srclen)\n\t\treturn -EUCLEAN;\n\tdata_in += LZO_LEN;\n\n\tin_len = read_compress_length(data_in);\n\tif (in_len != srclen - LZO_LEN * 2) {\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\tdata_in += LZO_LEN;\n\n\tout_len = PAGE_SIZE;\n\tret = lzo1x_decompress_safe(data_in, in_len, workspace->buf, &out_len);\n\tif (ret != LZO_E_OK) {\n\t\tpr_warn(\"BTRFS: decompress failed!\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (out_len < start_byte) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tdestlen = min_t(unsigned long, destlen, PAGE_SIZE);\n\tbytes = min_t(unsigned long, destlen, out_len - start_byte);\n\n\tkaddr = kmap_local_page(dest_page);\n\tmemcpy(kaddr, workspace->buf + start_byte, bytes);\n\n\t \n\tif (bytes < destlen)\n\t\tmemset(kaddr+bytes, 0, destlen-bytes);\n\tkunmap_local(kaddr);\nout:\n\treturn ret;\n}\n\nconst struct btrfs_compress_op btrfs_lzo_compress = {\n\t.workspace_manager\t= &wsm,\n\t.max_level\t\t= 1,\n\t.default_level\t\t= 1,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}