{
  "module_name": "inode.c",
  "hash_id": "f3475ee3af987afa06aa61729c8db7ac71b5cdaf1ac5ff5bf845c54afc115517",
  "original_prompt": "Ingested from linux-6.6.14/fs/efs/inode.c",
  "human_readable_source": "\n \n\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include \"efs.h\"\n#include <linux/efs_fs_sb.h>\n\nstatic int efs_read_folio(struct file *file, struct folio *folio)\n{\n\treturn block_read_full_folio(folio, efs_get_block);\n}\n\nstatic sector_t _efs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,efs_get_block);\n}\n\nstatic const struct address_space_operations efs_aops = {\n\t.read_folio = efs_read_folio,\n\t.bmap = _efs_bmap\n};\n\nstatic inline void extent_copy(efs_extent *src, efs_extent *dst) {\n\t \n\n\tdst->cooked.ex_magic  =  (unsigned int) src->raw[0];\n\tdst->cooked.ex_bn     = ((unsigned int) src->raw[1] << 16) |\n\t\t\t\t((unsigned int) src->raw[2] <<  8) |\n\t\t\t\t((unsigned int) src->raw[3] <<  0);\n\tdst->cooked.ex_length =  (unsigned int) src->raw[4];\n\tdst->cooked.ex_offset = ((unsigned int) src->raw[5] << 16) |\n\t\t\t\t((unsigned int) src->raw[6] <<  8) |\n\t\t\t\t((unsigned int) src->raw[7] <<  0);\n\treturn;\n}\n\nstruct inode *efs_iget(struct super_block *super, unsigned long ino)\n{\n\tint i, inode_index;\n\tdev_t device;\n\tu32 rdev;\n\tstruct buffer_head *bh;\n\tstruct efs_sb_info    *sb = SUPER_INFO(super);\n\tstruct efs_inode_info *in;\n\tefs_block_t block, offset;\n\tstruct efs_dinode *efs_inode;\n\tstruct inode *inode;\n\n\tinode = iget_locked(super, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tin = INODE_INFO(inode);\n\n\t \n\n\tinode_index = inode->i_ino /\n\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode));\n\n\tblock = sb->fs_start + sb->first_block + \n\t\t(sb->group_size * (inode_index / sb->inode_blocks)) +\n\t\t(inode_index % sb->inode_blocks);\n\n\toffset = (inode->i_ino %\n\t\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode))) *\n\t\tsizeof(struct efs_dinode);\n\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh) {\n\t\tpr_warn(\"%s() failed at block %d\\n\", __func__, block);\n\t\tgoto read_inode_error;\n\t}\n\n\tefs_inode = (struct efs_dinode *) (bh->b_data + offset);\n    \n\tinode->i_mode  = be16_to_cpu(efs_inode->di_mode);\n\tset_nlink(inode, be16_to_cpu(efs_inode->di_nlink));\n\ti_uid_write(inode, (uid_t)be16_to_cpu(efs_inode->di_uid));\n\ti_gid_write(inode, (gid_t)be16_to_cpu(efs_inode->di_gid));\n\tinode->i_size  = be32_to_cpu(efs_inode->di_size);\n\tinode->i_atime.tv_sec = be32_to_cpu(efs_inode->di_atime);\n\tinode->i_mtime.tv_sec = be32_to_cpu(efs_inode->di_mtime);\n\tinode_set_ctime(inode, be32_to_cpu(efs_inode->di_ctime), 0);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\n\t \n\tif (inode->i_size == 0) {\n\t\tinode->i_blocks = 0;\n\t} else {\n\t\tinode->i_blocks = ((inode->i_size - 1) >> EFS_BLOCKSIZE_BITS) + 1;\n\t}\n\n\trdev = be16_to_cpu(efs_inode->di_u.di_dev.odev);\n\tif (rdev == 0xffff) {\n\t\trdev = be32_to_cpu(efs_inode->di_u.di_dev.ndev);\n\t\tif (sysv_major(rdev) > 0xfff)\n\t\t\tdevice = 0;\n\t\telse\n\t\t\tdevice = MKDEV(sysv_major(rdev), sysv_minor(rdev));\n\t} else\n\t\tdevice = old_decode_dev(rdev);\n\n\t \n\tin->numextents = be16_to_cpu(efs_inode->di_numextents);\n\tin->lastextent = 0;\n\n\t \n\tfor(i = 0; i < EFS_DIRECTEXTENTS; i++) {\n\t\textent_copy(&(efs_inode->di_u.di_extents[i]), &(in->extents[i]));\n\t\tif (i < in->numextents && in->extents[i].cooked.ex_magic != 0) {\n\t\t\tpr_warn(\"extent %d has bad magic number in inode %lu\\n\",\n\t\t\t\ti, inode->i_ino);\n\t\t\tbrelse(bh);\n\t\t\tgoto read_inode_error;\n\t\t}\n\t}\n\n\tbrelse(bh);\n\tpr_debug(\"efs_iget(): inode %lu, extents %d, mode %o\\n\",\n\t\t inode->i_ino, in->numextents, inode->i_mode);\n\tswitch (inode->i_mode & S_IFMT) {\n\t\tcase S_IFDIR: \n\t\t\tinode->i_op = &efs_dir_inode_operations; \n\t\t\tinode->i_fop = &efs_dir_operations; \n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &generic_ro_fops;\n\t\t\tinode->i_data.a_ops = &efs_aops;\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode_nohighmem(inode);\n\t\t\tinode->i_data.a_ops = &efs_symlink_aops;\n\t\t\tbreak;\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\t\tinit_special_inode(inode, inode->i_mode, device);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"unsupported inode mode %o\\n\", inode->i_mode);\n\t\t\tgoto read_inode_error;\n\t\t\tbreak;\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n        \nread_inode_error:\n\tpr_warn(\"failed to read inode %lu\\n\", inode->i_ino);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}\n\nstatic inline efs_block_t\nefs_extent_check(efs_extent *ptr, efs_block_t block, struct efs_sb_info *sb) {\n\tefs_block_t start;\n\tefs_block_t length;\n\tefs_block_t offset;\n\n\t \n\tstart  = ptr->cooked.ex_bn;\n\tlength = ptr->cooked.ex_length;\n\toffset = ptr->cooked.ex_offset;\n\n\tif ((block >= offset) && (block < offset+length)) {\n\t\treturn(sb->fs_start + start + block - offset);\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nefs_block_t efs_map_block(struct inode *inode, efs_block_t block) {\n\tstruct efs_sb_info    *sb = SUPER_INFO(inode->i_sb);\n\tstruct efs_inode_info *in = INODE_INFO(inode);\n\tstruct buffer_head    *bh = NULL;\n\n\tint cur, last, first = 1;\n\tint ibase, ioffset, dirext, direxts, indext, indexts;\n\tefs_block_t iblock, result = 0, lastblock = 0;\n\tefs_extent ext, *exts;\n\n\tlast = in->lastextent;\n\n\tif (in->numextents <= EFS_DIRECTEXTENTS) {\n\t\t \n\t\tif ((result = efs_extent_check(&in->extents[last], block, sb)))\n\t\t\treturn result;\n    \n\t\t \n\t\tif (in->numextents == 1) {\n\t\t\tpr_err(\"%s() failed to map (1 extent)\\n\", __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdirexts = in->numextents;\n\n\t\t \n\t\tfor(dirext = 1; dirext < direxts; dirext++) {\n\t\t\tcur = (last + dirext) % in->numextents;\n\t\t\tif ((result = efs_extent_check(&in->extents[cur], block, sb))) {\n\t\t\t\tin->lastextent = cur;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tpr_err(\"%s() failed to map block %u (dir)\\n\", __func__, block);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"%s(): indirect search for logical block %u\\n\",\n\t\t __func__, block);\n\tdirexts = in->extents[0].cooked.ex_offset;\n\tindexts = in->numextents;\n\n\tfor(indext = 0; indext < indexts; indext++) {\n\t\tcur = (last + indext) % indexts;\n\n\t\t \n\t\tibase = 0;\n\t\tfor(dirext = 0; cur < ibase && dirext < direxts; dirext++) {\n\t\t\tibase += in->extents[dirext].cooked.ex_length *\n\t\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\t\t}\n\n\t\tif (dirext == direxts) {\n\t\t\t \n\t\t\tpr_err(\"couldn't find direct extent for indirect extent %d (block %u)\\n\",\n\t\t\t       cur, block);\n\t\t\tif (bh) brelse(bh);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t \n\t\tiblock = sb->fs_start + in->extents[dirext].cooked.ex_bn +\n\t\t\t(cur - ibase) /\n\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\t\tioffset = (cur - ibase) %\n\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\n\t\tif (first || lastblock != iblock) {\n\t\t\tif (bh) brelse(bh);\n\n\t\t\tbh = sb_bread(inode->i_sb, iblock);\n\t\t\tif (!bh) {\n\t\t\t\tpr_err(\"%s() failed at block %d\\n\",\n\t\t\t\t       __func__, iblock);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpr_debug(\"%s(): read indirect extent block %d\\n\",\n\t\t\t\t __func__, iblock);\n\t\t\tfirst = 0;\n\t\t\tlastblock = iblock;\n\t\t}\n\n\t\texts = (efs_extent *) bh->b_data;\n\n\t\textent_copy(&(exts[ioffset]), &ext);\n\n\t\tif (ext.cooked.ex_magic != 0) {\n\t\t\tpr_err(\"extent %d has bad magic number in block %d\\n\",\n\t\t\t       cur, iblock);\n\t\t\tif (bh) brelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((result = efs_extent_check(&ext, block, sb))) {\n\t\t\tif (bh) brelse(bh);\n\t\t\tin->lastextent = cur;\n\t\t\treturn result;\n\t\t}\n\t}\n\tif (bh) brelse(bh);\n\tpr_err(\"%s() failed to map block %u (indir)\\n\", __func__, block);\n\treturn 0;\n}  \n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}