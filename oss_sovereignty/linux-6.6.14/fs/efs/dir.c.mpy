{
  "module_name": "dir.c",
  "hash_id": "60a84c7e0103449709445fb7b89e0b7753a2572de75eabfd11f794ddd57f714b",
  "original_prompt": "Ingested from linux-6.6.14/fs/efs/dir.c",
  "human_readable_source": "\n \n\n#include <linux/buffer_head.h>\n#include \"efs.h\"\n\nstatic int efs_readdir(struct file *, struct dir_context *);\n\nconst struct file_operations efs_dir_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= efs_readdir,\n};\n\nconst struct inode_operations efs_dir_inode_operations = {\n\t.lookup\t\t= efs_lookup,\n};\n\nstatic int efs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tefs_block_t\t\tblock;\n\tint\t\t\tslot;\n\n\tif (inode->i_size & (EFS_DIRBSIZE-1))\n\t\tpr_warn(\"%s(): directory size not a multiple of EFS_DIRBSIZE\\n\",\n\t\t\t__func__);\n\n\t \n\tblock = ctx->pos >> EFS_DIRBSIZE_BITS;\n\n\t \n\tslot  = ctx->pos & 0xff;\n\n\t \n\twhile (block < inode->i_blocks) {\n\t\tstruct efs_dir\t\t*dirblock;\n\t\tstruct buffer_head *bh;\n\n\t\t \n\t\tbh = sb_bread(inode->i_sb, efs_bmap(inode, block));\n\n\t\tif (!bh) {\n\t\t\tpr_err(\"%s(): failed to read dir block %d\\n\",\n\t\t\t       __func__, block);\n\t\t\tbreak;\n\t\t}\n\n\t\tdirblock = (struct efs_dir *) bh->b_data; \n\n\t\tif (be16_to_cpu(dirblock->magic) != EFS_DIRBLK_MAGIC) {\n\t\t\tpr_err(\"%s(): invalid directory block\\n\", __func__);\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (; slot < dirblock->slots; slot++) {\n\t\t\tstruct efs_dentry *dirslot;\n\t\t\tefs_ino_t inodenum;\n\t\t\tconst char *nameptr;\n\t\t\tint namelen;\n\n\t\t\tif (dirblock->space[slot] == 0)\n\t\t\t\tcontinue;\n\n\t\t\tdirslot  = (struct efs_dentry *) (((char *) bh->b_data) + EFS_SLOTAT(dirblock, slot));\n\n\t\t\tinodenum = be32_to_cpu(dirslot->inode);\n\t\t\tnamelen  = dirslot->namelen;\n\t\t\tnameptr  = dirslot->name;\n\t\t\tpr_debug(\"%s(): block %d slot %d/%d: inode %u, name \\\"%s\\\", namelen %u\\n\",\n\t\t\t\t __func__, block, slot, dirblock->slots-1,\n\t\t\t\t inodenum, nameptr, namelen);\n\t\t\tif (!namelen)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tctx->pos = (block << EFS_DIRBSIZE_BITS) | slot;\n\n\t\t\t \n\t\t\tif (nameptr - (char *) dirblock + namelen > EFS_DIRBSIZE) {\n\t\t\t\tpr_warn(\"directory entry %d exceeds directory block\\n\",\n\t\t\t\t\tslot);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!dir_emit(ctx, nameptr, namelen, inodenum, DT_UNKNOWN)) {\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\n\t\tslot = 0;\n\t\tblock++;\n\t}\n\tctx->pos = (block << EFS_DIRBSIZE_BITS) | slot;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}