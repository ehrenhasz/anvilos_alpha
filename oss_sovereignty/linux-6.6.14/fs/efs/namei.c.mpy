{
  "module_name": "namei.c",
  "hash_id": "0135dbf83891f1bf038a32ae9d61f85a11c8397690943beeead3e77afc29357c",
  "original_prompt": "Ingested from linux-6.6.14/fs/efs/namei.c",
  "human_readable_source": "\n \n\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/exportfs.h>\n#include \"efs.h\"\n\n\nstatic efs_ino_t efs_find_entry(struct inode *inode, const char *name, int len)\n{\n\tstruct buffer_head *bh;\n\n\tint\t\t\tslot, namelen;\n\tchar\t\t\t*nameptr;\n\tstruct efs_dir\t\t*dirblock;\n\tstruct efs_dentry\t*dirslot;\n\tefs_ino_t\t\tinodenum;\n\tefs_block_t\t\tblock;\n \n\tif (inode->i_size & (EFS_DIRBSIZE-1))\n\t\tpr_warn(\"%s(): directory size not a multiple of EFS_DIRBSIZE\\n\",\n\t\t\t__func__);\n\n\tfor(block = 0; block < inode->i_blocks; block++) {\n\n\t\tbh = sb_bread(inode->i_sb, efs_bmap(inode, block));\n\t\tif (!bh) {\n\t\t\tpr_err(\"%s(): failed to read dir block %d\\n\",\n\t\t\t       __func__, block);\n\t\t\treturn 0;\n\t\t}\n    \n\t\tdirblock = (struct efs_dir *) bh->b_data;\n\n\t\tif (be16_to_cpu(dirblock->magic) != EFS_DIRBLK_MAGIC) {\n\t\t\tpr_err(\"%s(): invalid directory block\\n\", __func__);\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (slot = 0; slot < dirblock->slots; slot++) {\n\t\t\tdirslot  = (struct efs_dentry *) (((char *) bh->b_data) + EFS_SLOTAT(dirblock, slot));\n\n\t\t\tnamelen  = dirslot->namelen;\n\t\t\tnameptr  = dirslot->name;\n\n\t\t\tif ((namelen == len) && (!memcmp(name, nameptr, len))) {\n\t\t\t\tinodenum = be32_to_cpu(dirslot->inode);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn inodenum;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}\n\nstruct dentry *efs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tefs_ino_t inodenum;\n\tstruct inode *inode = NULL;\n\n\tinodenum = efs_find_entry(dir, dentry->d_name.name, dentry->d_name.len);\n\tif (inodenum)\n\t\tinode = efs_iget(dir->i_sb, inodenum);\n\n\treturn d_splice_alias(inode, dentry);\n}\n\nstatic struct inode *efs_nfs_get_inode(struct super_block *sb, u64 ino,\n\t\tu32 generation)\n{\n\tstruct inode *inode;\n\n\tif (ino == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\tinode = efs_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn inode;\n}\n\nstruct dentry *efs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    efs_nfs_get_inode);\n}\n\nstruct dentry *efs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    efs_nfs_get_inode);\n}\n\nstruct dentry *efs_get_parent(struct dentry *child)\n{\n\tstruct dentry *parent = ERR_PTR(-ENOENT);\n\tefs_ino_t ino;\n\n\tino = efs_find_entry(d_inode(child), \"..\", 2);\n\tif (ino)\n\t\tparent = d_obtain_alias(efs_iget(child->d_sb, ino));\n\n\treturn parent;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}