{
  "module_name": "super.c",
  "hash_id": "c4c5ee03868ad0acb05258bb1bc195798ae7a6fdac4d12c2eb74db0a1dcb783c",
  "original_prompt": "Ingested from linux-6.6.14/fs/efs/super.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/vfs.h>\n#include <linux/blkdev.h>\n\n#include \"efs.h\"\n#include <linux/efs_vh.h>\n#include <linux/efs_fs_sb.h>\n\nstatic int efs_statfs(struct dentry *dentry, struct kstatfs *buf);\nstatic int efs_fill_super(struct super_block *s, void *d, int silent);\n\nstatic struct dentry *efs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, efs_fill_super);\n}\n\nstatic void efs_kill_sb(struct super_block *s)\n{\n\tstruct efs_sb_info *sbi = SUPER_INFO(s);\n\tkill_block_super(s);\n\tkfree(sbi);\n}\n\nstatic struct file_system_type efs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"efs\",\n\t.mount\t\t= efs_mount,\n\t.kill_sb\t= efs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"efs\");\n\nstatic struct pt_types sgi_pt_types[] = {\n\t{0x00,\t\t\"SGI vh\"},\n\t{0x01,\t\t\"SGI trkrepl\"},\n\t{0x02,\t\t\"SGI secrepl\"},\n\t{0x03,\t\t\"SGI raw\"},\n\t{0x04,\t\t\"SGI bsd\"},\n\t{SGI_SYSV,\t\"SGI sysv\"},\n\t{0x06,\t\t\"SGI vol\"},\n\t{SGI_EFS,\t\"SGI efs\"},\n\t{0x08,\t\t\"SGI lv\"},\n\t{0x09,\t\t\"SGI rlv\"},\n\t{0x0A,\t\t\"SGI xfs\"},\n\t{0x0B,\t\t\"SGI xfslog\"},\n\t{0x0C,\t\t\"SGI xlv\"},\n\t{0x82,\t\t\"Linux swap\"},\n\t{0x83,\t\t\"Linux native\"},\n\t{0,\t\tNULL}\n};\n\n\nstatic struct kmem_cache * efs_inode_cachep;\n\nstatic struct inode *efs_alloc_inode(struct super_block *sb)\n{\n\tstruct efs_inode_info *ei;\n\tei = alloc_inode_sb(sb, efs_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}\n\nstatic void efs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(efs_inode_cachep, INODE_INFO(inode));\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct efs_inode_info *ei = (struct efs_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int __init init_inodecache(void)\n{\n\tefs_inode_cachep = kmem_cache_create(\"efs_inode_cache\",\n\t\t\t\tsizeof(struct efs_inode_info), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD|\n\t\t\t\tSLAB_ACCOUNT, init_once);\n\tif (efs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(efs_inode_cachep);\n}\n\nstatic int efs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= SB_RDONLY;\n\treturn 0;\n}\n\nstatic const struct super_operations efs_superblock_operations = {\n\t.alloc_inode\t= efs_alloc_inode,\n\t.free_inode\t= efs_free_inode,\n\t.statfs\t\t= efs_statfs,\n\t.remount_fs\t= efs_remount,\n};\n\nstatic const struct export_operations efs_export_ops = {\n\t.fh_to_dentry\t= efs_fh_to_dentry,\n\t.fh_to_parent\t= efs_fh_to_parent,\n\t.get_parent\t= efs_get_parent,\n};\n\nstatic int __init init_efs_fs(void) {\n\tint err;\n\tpr_info(EFS_VERSION\" - http://aeschi.ch.eu.org/efs/\\n\");\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&efs_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}\n\nstatic void __exit exit_efs_fs(void) {\n\tunregister_filesystem(&efs_fs_type);\n\tdestroy_inodecache();\n}\n\nmodule_init(init_efs_fs)\nmodule_exit(exit_efs_fs)\n\nstatic efs_block_t efs_validate_vh(struct volume_header *vh) {\n\tint\t\ti;\n\t__be32\t\tcs, *ui;\n\tint\t\tcsum;\n\tefs_block_t\tsblock = 0;  \n\tstruct pt_types\t*pt_entry;\n\tint\t\tpt_type, slice = -1;\n\n\tif (be32_to_cpu(vh->vh_magic) != VHMAGIC) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tui = ((__be32 *) (vh + 1)) - 1;\n\tfor(csum = 0; ui >= ((__be32 *) vh);) {\n\t\tcs = *ui--;\n\t\tcsum += be32_to_cpu(cs);\n\t}\n\tif (csum) {\n\t\tpr_warn(\"SGI disklabel: checksum bad, label corrupted\\n\");\n\t\treturn 0;\n\t}\n\n#ifdef DEBUG\n\tpr_debug(\"bf: \\\"%16s\\\"\\n\", vh->vh_bootfile);\n\n\tfor(i = 0; i < NVDIR; i++) {\n\t\tint\tj;\n\t\tchar\tname[VDNAMESIZE+1];\n\n\t\tfor(j = 0; j < VDNAMESIZE; j++) {\n\t\t\tname[j] = vh->vh_vd[i].vd_name[j];\n\t\t}\n\t\tname[j] = (char) 0;\n\n\t\tif (name[0]) {\n\t\t\tpr_debug(\"vh: %8s block: 0x%08x size: 0x%08x\\n\",\n\t\t\t\tname, (int) be32_to_cpu(vh->vh_vd[i].vd_lbn),\n\t\t\t\t(int) be32_to_cpu(vh->vh_vd[i].vd_nbytes));\n\t\t}\n\t}\n#endif\n\n\tfor(i = 0; i < NPARTAB; i++) {\n\t\tpt_type = (int) be32_to_cpu(vh->vh_pt[i].pt_type);\n\t\tfor(pt_entry = sgi_pt_types; pt_entry->pt_name; pt_entry++) {\n\t\t\tif (pt_type == pt_entry->pt_type) break;\n\t\t}\n#ifdef DEBUG\n\t\tif (be32_to_cpu(vh->vh_pt[i].pt_nblks)) {\n\t\t\tpr_debug(\"pt %2d: start: %08d size: %08d type: 0x%02x (%s)\\n\",\n\t\t\t\t i, (int)be32_to_cpu(vh->vh_pt[i].pt_firstlbn),\n\t\t\t\t (int)be32_to_cpu(vh->vh_pt[i].pt_nblks),\n\t\t\t\t pt_type, (pt_entry->pt_name) ?\n\t\t\t\t pt_entry->pt_name : \"unknown\");\n\t\t}\n#endif\n\t\tif (IS_EFS(pt_type)) {\n\t\t\tsblock = be32_to_cpu(vh->vh_pt[i].pt_firstlbn);\n\t\t\tslice = i;\n\t\t}\n\t}\n\n\tif (slice == -1) {\n\t\tpr_notice(\"partition table contained no EFS partitions\\n\");\n#ifdef DEBUG\n\t} else {\n\t\tpr_info(\"using slice %d (type %s, offset 0x%x)\\n\", slice,\n\t\t\t(pt_entry->pt_name) ? pt_entry->pt_name : \"unknown\",\n\t\t\tsblock);\n#endif\n\t}\n\treturn sblock;\n}\n\nstatic int efs_validate_super(struct efs_sb_info *sb, struct efs_super *super) {\n\n\tif (!IS_EFS_MAGIC(be32_to_cpu(super->fs_magic)))\n\t\treturn -1;\n\n\tsb->fs_magic     = be32_to_cpu(super->fs_magic);\n\tsb->total_blocks = be32_to_cpu(super->fs_size);\n\tsb->first_block  = be32_to_cpu(super->fs_firstcg);\n\tsb->group_size   = be32_to_cpu(super->fs_cgfsize);\n\tsb->data_free    = be32_to_cpu(super->fs_tfree);\n\tsb->inode_free   = be32_to_cpu(super->fs_tinode);\n\tsb->inode_blocks = be16_to_cpu(super->fs_cgisize);\n\tsb->total_groups = be16_to_cpu(super->fs_ncg);\n    \n\treturn 0;    \n}\n\nstatic int efs_fill_super(struct super_block *s, void *d, int silent)\n{\n\tstruct efs_sb_info *sb;\n\tstruct buffer_head *bh;\n\tstruct inode *root;\n\n \tsb = kzalloc(sizeof(struct efs_sb_info), GFP_KERNEL);\n\tif (!sb)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = sb;\n\ts->s_time_min = 0;\n\ts->s_time_max = U32_MAX;\n \n\ts->s_magic\t\t= EFS_SUPER_MAGIC;\n\tif (!sb_set_blocksize(s, EFS_BLOCKSIZE)) {\n\t\tpr_err(\"device does not support %d byte blocks\\n\",\n\t\t\tEFS_BLOCKSIZE);\n\t\treturn -EINVAL;\n\t}\n  \n\t \n\tbh = sb_bread(s, 0);\n\n\tif (!bh) {\n\t\tpr_err(\"cannot read volume header\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tsb->fs_start = efs_validate_vh((struct volume_header *) bh->b_data);\n\tbrelse(bh);\n\n\tif (sb->fs_start == -1) {\n\t\treturn -EINVAL;\n\t}\n\n\tbh = sb_bread(s, sb->fs_start + EFS_SUPER);\n\tif (!bh) {\n\t\tpr_err(\"cannot read superblock\\n\");\n\t\treturn -EIO;\n\t}\n\t\t\n\tif (efs_validate_super(sb, (struct efs_super *) bh->b_data)) {\n#ifdef DEBUG\n\t\tpr_warn(\"invalid superblock at block %u\\n\",\n\t\t\tsb->fs_start + EFS_SUPER);\n#endif\n\t\tbrelse(bh);\n\t\treturn -EINVAL;\n\t}\n\tbrelse(bh);\n\n\tif (!sb_rdonly(s)) {\n#ifdef DEBUG\n\t\tpr_info(\"forcing read-only mode\\n\");\n#endif\n\t\ts->s_flags |= SB_RDONLY;\n\t}\n\ts->s_op   = &efs_superblock_operations;\n\ts->s_export_op = &efs_export_ops;\n\troot = efs_iget(s, EFS_ROOTINODE);\n\tif (IS_ERR(root)) {\n\t\tpr_err(\"get root inode failed\\n\");\n\t\treturn PTR_ERR(root);\n\t}\n\n\ts->s_root = d_make_root(root);\n\tif (!(s->s_root)) {\n\t\tpr_err(\"get root dentry failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int efs_statfs(struct dentry *dentry, struct kstatfs *buf) {\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct efs_sb_info *sbi = SUPER_INFO(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type    = EFS_SUPER_MAGIC;\t \n\tbuf->f_bsize   = EFS_BLOCKSIZE;\t\t \n\tbuf->f_blocks  = sbi->total_groups *\t \n\t\t\t(sbi->group_size - sbi->inode_blocks);\n\tbuf->f_bfree   = sbi->data_free;\t \n\tbuf->f_bavail  = sbi->data_free;\t \n\tbuf->f_files   = sbi->total_groups *\t \n\t\t\tsbi->inode_blocks *\n\t\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode));\n\tbuf->f_ffree   = sbi->inode_free;\t \n\tbuf->f_fsid    = u64_to_fsid(id);\n\tbuf->f_namelen = EFS_MAXNAMELEN;\t \n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}