{
  "module_name": "efs.h",
  "hash_id": "5dd225093866e4910d29a5799641dcec6d1b4be10d0baf03d6fff655c7f606e2",
  "original_prompt": "Ingested from linux-6.6.14/fs/efs/efs.h",
  "human_readable_source": " \n \n#ifndef _EFS_EFS_H_\n#define _EFS_EFS_H_\n\n#ifdef pr_fmt\n#undef pr_fmt\n#endif\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n\n#define EFS_VERSION \"1.0a\"\n\n \n#define\tEFS_BLOCKSIZE_BITS\t9\n#define\tEFS_BLOCKSIZE\t\t(1 << EFS_BLOCKSIZE_BITS)\n\ntypedef\tint32_t\t\tefs_block_t;\ntypedef uint32_t\tefs_ino_t;\n\n#define\tEFS_DIRECTEXTENTS\t12\n\n \ntypedef union extent_u {\n\tunsigned char raw[8];\n\tstruct extent_s {\n\t\tunsigned int\tex_magic:8;\t \n\t\tunsigned int\tex_bn:24;\t \n\t\tunsigned int\tex_length:8;\t \n\t\tunsigned int\tex_offset:24;\t \n\t} cooked;\n} efs_extent;\n\ntypedef struct edevs {\n\t__be16\t\todev;\n\t__be32\t\tndev;\n} efs_devs;\n\n \nstruct\tefs_dinode {\n\t__be16\t\tdi_mode;\t \n\t__be16\t\tdi_nlink;\t \n\t__be16\t\tdi_uid;\t\t \n\t__be16\t\tdi_gid;\t\t \n\t__be32\t\tdi_size;\t \n\t__be32\t\tdi_atime;\t \n\t__be32\t\tdi_mtime;\t \n\t__be32\t\tdi_ctime;\t \n\t__be32\t\tdi_gen;\t\t \n\t__be16\t\tdi_numextents;\t \n\tu_char\t\tdi_version;\t \n\tu_char\t\tdi_spare;\t \n\tunion di_addr {\n\t\tefs_extent\tdi_extents[EFS_DIRECTEXTENTS];\n\t\tefs_devs\tdi_dev;\t \n\t} di_u;\n};\n\n \nstruct efs_inode_info {\n\tint\t\tnumextents;\n\tint\t\tlastextent;\n\n\tefs_extent\textents[EFS_DIRECTEXTENTS];\n\tstruct inode\tvfs_inode;\n};\n\n#include <linux/efs_fs_sb.h>\n\n#define EFS_DIRBSIZE_BITS\tEFS_BLOCKSIZE_BITS\n#define EFS_DIRBSIZE\t\t(1 << EFS_DIRBSIZE_BITS)\n\nstruct efs_dentry {\n\t__be32\t\tinode;\n\tunsigned char\tnamelen;\n\tchar\t\tname[3];\n};\n\n#define EFS_DENTSIZE\t(sizeof(struct efs_dentry) - 3 + 1)\n#define EFS_MAXNAMELEN  ((1 << (sizeof(char) * 8)) - 1)\n\n#define EFS_DIRBLK_HEADERSIZE\t4\n#define EFS_DIRBLK_MAGIC\t0xbeef\t \n\nstruct efs_dir {\n\t__be16\tmagic;\n\tunsigned char\tfirstused;\n\tunsigned char\tslots;\n\n\tunsigned char\tspace[EFS_DIRBSIZE - EFS_DIRBLK_HEADERSIZE];\n};\n\n#define EFS_MAXENTS \\\n\t((EFS_DIRBSIZE - EFS_DIRBLK_HEADERSIZE) / \\\n\t (EFS_DENTSIZE + sizeof(char)))\n\n#define EFS_SLOTAT(dir, slot) EFS_REALOFF((dir)->space[slot])\n\n#define EFS_REALOFF(offset) ((offset << 1))\n\n\nstatic inline struct efs_inode_info *INODE_INFO(struct inode *inode)\n{\n\treturn container_of(inode, struct efs_inode_info, vfs_inode);\n}\n\nstatic inline struct efs_sb_info *SUPER_INFO(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\nstruct statfs;\nstruct fid;\n\nextern const struct inode_operations efs_dir_inode_operations;\nextern const struct file_operations efs_dir_operations;\nextern const struct address_space_operations efs_symlink_aops;\n\nextern struct inode *efs_iget(struct super_block *, unsigned long);\nextern efs_block_t efs_map_block(struct inode *, efs_block_t);\nextern int efs_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nextern struct dentry *efs_lookup(struct inode *, struct dentry *, unsigned int);\nextern struct dentry *efs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type);\nextern struct dentry *efs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type);\nextern struct dentry *efs_get_parent(struct dentry *);\nextern int efs_bmap(struct inode *, int);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}