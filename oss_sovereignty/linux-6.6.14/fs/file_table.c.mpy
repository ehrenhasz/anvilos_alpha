{
  "module_name": "file_table.c",
  "hash_id": "7f2f4f3546ad4c73d7dab267d394eac701b89479a7ef7139b30f50ee6bd13725",
  "original_prompt": "Ingested from linux-6.6.14/fs/file_table.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/filelock.h>\n#include <linux/security.h>\n#include <linux/cred.h>\n#include <linux/eventpoll.h>\n#include <linux/rcupdate.h>\n#include <linux/mount.h>\n#include <linux/capability.h>\n#include <linux/cdev.h>\n#include <linux/fsnotify.h>\n#include <linux/sysctl.h>\n#include <linux/percpu_counter.h>\n#include <linux/percpu.h>\n#include <linux/task_work.h>\n#include <linux/ima.h>\n#include <linux/swap.h>\n#include <linux/kmemleak.h>\n\n#include <linux/atomic.h>\n\n#include \"internal.h\"\n\n \nstatic struct files_stat_struct files_stat = {\n\t.max_files = NR_FILE\n};\n\n \nstatic struct kmem_cache *filp_cachep __read_mostly;\n\nstatic struct percpu_counter nr_files __cacheline_aligned_in_smp;\n\n \nstruct backing_file {\n\tstruct file file;\n\tstruct path real_path;\n};\n\nstatic inline struct backing_file *backing_file(struct file *f)\n{\n\treturn container_of(f, struct backing_file, file);\n}\n\nstruct path *backing_file_real_path(struct file *f)\n{\n\treturn &backing_file(f)->real_path;\n}\nEXPORT_SYMBOL_GPL(backing_file_real_path);\n\nstatic void file_free_rcu(struct rcu_head *head)\n{\n\tstruct file *f = container_of(head, struct file, f_rcuhead);\n\n\tput_cred(f->f_cred);\n\tif (unlikely(f->f_mode & FMODE_BACKING))\n\t\tkfree(backing_file(f));\n\telse\n\t\tkmem_cache_free(filp_cachep, f);\n}\n\nstatic inline void file_free(struct file *f)\n{\n\tsecurity_file_free(f);\n\tif (unlikely(f->f_mode & FMODE_BACKING))\n\t\tpath_put(backing_file_real_path(f));\n\tif (likely(!(f->f_mode & FMODE_NOACCOUNT)))\n\t\tpercpu_counter_dec(&nr_files);\n\tcall_rcu(&f->f_rcuhead, file_free_rcu);\n}\n\n \nstatic long get_nr_files(void)\n{\n\treturn percpu_counter_read_positive(&nr_files);\n}\n\n \nunsigned long get_max_files(void)\n{\n\treturn files_stat.max_files;\n}\nEXPORT_SYMBOL_GPL(get_max_files);\n\n#if defined(CONFIG_SYSCTL) && defined(CONFIG_PROC_FS)\n\n \nstatic int proc_nr_files(struct ctl_table *table, int write, void *buffer,\n\t\t\t size_t *lenp, loff_t *ppos)\n{\n\tfiles_stat.nr_files = get_nr_files();\n\treturn proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n}\n\nstatic struct ctl_table fs_stat_sysctls[] = {\n\t{\n\t\t.procname\t= \"file-nr\",\n\t\t.data\t\t= &files_stat,\n\t\t.maxlen\t\t= sizeof(files_stat),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_nr_files,\n\t},\n\t{\n\t\t.procname\t= \"file-max\",\n\t\t.data\t\t= &files_stat.max_files,\n\t\t.maxlen\t\t= sizeof(files_stat.max_files),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t\t.extra1\t\t= SYSCTL_LONG_ZERO,\n\t\t.extra2\t\t= SYSCTL_LONG_MAX,\n\t},\n\t{\n\t\t.procname\t= \"nr_open\",\n\t\t.data\t\t= &sysctl_nr_open,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &sysctl_nr_open_min,\n\t\t.extra2\t\t= &sysctl_nr_open_max,\n\t},\n\t{ }\n};\n\nstatic int __init init_fs_stat_sysctls(void)\n{\n\tregister_sysctl_init(\"fs\", fs_stat_sysctls);\n\tif (IS_ENABLED(CONFIG_BINFMT_MISC)) {\n\t\tstruct ctl_table_header *hdr;\n\t\thdr = register_sysctl_mount_point(\"fs/binfmt_misc\");\n\t\tkmemleak_not_leak(hdr);\n\t}\n\treturn 0;\n}\nfs_initcall(init_fs_stat_sysctls);\n#endif\n\nstatic int init_file(struct file *f, int flags, const struct cred *cred)\n{\n\tint error;\n\n\tf->f_cred = get_cred(cred);\n\terror = security_file_alloc(f);\n\tif (unlikely(error)) {\n\t\tput_cred(f->f_cred);\n\t\treturn error;\n\t}\n\n\tatomic_long_set(&f->f_count, 1);\n\trwlock_init(&f->f_owner.lock);\n\tspin_lock_init(&f->f_lock);\n\tmutex_init(&f->f_pos_lock);\n\tf->f_flags = flags;\n\tf->f_mode = OPEN_FMODE(flags);\n\t \n\n\treturn 0;\n}\n\n \nstruct file *alloc_empty_file(int flags, const struct cred *cred)\n{\n\tstatic long old_max;\n\tstruct file *f;\n\tint error;\n\n\t \n\tif (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {\n\t\t \n\t\tif (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)\n\t\t\tgoto over;\n\t}\n\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terror = init_file(f, flags, cred);\n\tif (unlikely(error)) {\n\t\tkmem_cache_free(filp_cachep, f);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tpercpu_counter_inc(&nr_files);\n\n\treturn f;\n\nover:\n\t \n\tif (get_nr_files() > old_max) {\n\t\tpr_info(\"VFS: file-max limit %lu reached\\n\", get_max_files());\n\t\told_max = get_nr_files();\n\t}\n\treturn ERR_PTR(-ENFILE);\n}\n\n \nstruct file *alloc_empty_file_noaccount(int flags, const struct cred *cred)\n{\n\tstruct file *f;\n\tint error;\n\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terror = init_file(f, flags, cred);\n\tif (unlikely(error)) {\n\t\tkmem_cache_free(filp_cachep, f);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tf->f_mode |= FMODE_NOACCOUNT;\n\n\treturn f;\n}\n\n \nstruct file *alloc_empty_backing_file(int flags, const struct cred *cred)\n{\n\tstruct backing_file *ff;\n\tint error;\n\n\tff = kzalloc(sizeof(struct backing_file), GFP_KERNEL);\n\tif (unlikely(!ff))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terror = init_file(&ff->file, flags, cred);\n\tif (unlikely(error)) {\n\t\tkfree(ff);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tff->file.f_mode |= FMODE_BACKING | FMODE_NOACCOUNT;\n\treturn &ff->file;\n}\n\n \nstatic struct file *alloc_file(const struct path *path, int flags,\n\t\tconst struct file_operations *fop)\n{\n\tstruct file *file;\n\n\tfile = alloc_empty_file(flags, current_cred());\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_path = *path;\n\tfile->f_inode = path->dentry->d_inode;\n\tfile->f_mapping = path->dentry->d_inode->i_mapping;\n\tfile->f_wb_err = filemap_sample_wb_err(file->f_mapping);\n\tfile->f_sb_err = file_sample_sb_err(file);\n\tif (fop->llseek)\n\t\tfile->f_mode |= FMODE_LSEEK;\n\tif ((file->f_mode & FMODE_READ) &&\n\t     likely(fop->read || fop->read_iter))\n\t\tfile->f_mode |= FMODE_CAN_READ;\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t     likely(fop->write || fop->write_iter))\n\t\tfile->f_mode |= FMODE_CAN_WRITE;\n\tfile->f_iocb_flags = iocb_flags(file);\n\tfile->f_mode |= FMODE_OPENED;\n\tfile->f_op = fop;\n\tif ((file->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(path->dentry->d_inode);\n\treturn file;\n}\n\nstruct file *alloc_file_pseudo(struct inode *inode, struct vfsmount *mnt,\n\t\t\t\tconst char *name, int flags,\n\t\t\t\tconst struct file_operations *fops)\n{\n\tstatic const struct dentry_operations anon_ops = {\n\t\t.d_dname = simple_dname\n\t};\n\tstruct qstr this = QSTR_INIT(name, strlen(name));\n\tstruct path path;\n\tstruct file *file;\n\n\tpath.dentry = d_alloc_pseudo(mnt->mnt_sb, &this);\n\tif (!path.dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!mnt->mnt_sb->s_d_op)\n\t\td_set_d_op(path.dentry, &anon_ops);\n\tpath.mnt = mntget(mnt);\n\td_instantiate(path.dentry, inode);\n\tfile = alloc_file(&path, flags, fops);\n\tif (IS_ERR(file)) {\n\t\tihold(inode);\n\t\tpath_put(&path);\n\t}\n\treturn file;\n}\nEXPORT_SYMBOL(alloc_file_pseudo);\n\nstruct file *alloc_file_clone(struct file *base, int flags,\n\t\t\t\tconst struct file_operations *fops)\n{\n\tstruct file *f = alloc_file(&base->f_path, flags, fops);\n\tif (!IS_ERR(f)) {\n\t\tpath_get(&f->f_path);\n\t\tf->f_mapping = base->f_mapping;\n\t}\n\treturn f;\n}\n\n \nstatic void __fput(struct file *file)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct vfsmount *mnt = file->f_path.mnt;\n\tstruct inode *inode = file->f_inode;\n\tfmode_t mode = file->f_mode;\n\n\tif (unlikely(!(file->f_mode & FMODE_OPENED)))\n\t\tgoto out;\n\n\tmight_sleep();\n\n\tfsnotify_close(file);\n\t \n\teventpoll_release(file);\n\tlocks_remove_file(file);\n\n\tima_file_free(file);\n\tif (unlikely(file->f_flags & FASYNC)) {\n\t\tif (file->f_op->fasync)\n\t\t\tfile->f_op->fasync(-1, file, 0);\n\t}\n\tif (file->f_op->release)\n\t\tfile->f_op->release(inode, file);\n\tif (unlikely(S_ISCHR(inode->i_mode) && inode->i_cdev != NULL &&\n\t\t     !(mode & FMODE_PATH))) {\n\t\tcdev_put(inode->i_cdev);\n\t}\n\tfops_put(file->f_op);\n\tput_pid(file->f_owner.pid);\n\tput_file_access(file);\n\tdput(dentry);\n\tif (unlikely(mode & FMODE_NEED_UNMOUNT))\n\t\tdissolve_on_fput(mnt);\n\tmntput(mnt);\nout:\n\tfile_free(file);\n}\n\nstatic LLIST_HEAD(delayed_fput_list);\nstatic void delayed_fput(struct work_struct *unused)\n{\n\tstruct llist_node *node = llist_del_all(&delayed_fput_list);\n\tstruct file *f, *t;\n\n\tllist_for_each_entry_safe(f, t, node, f_llist)\n\t\t__fput(f);\n}\n\nstatic void ____fput(struct callback_head *work)\n{\n\t__fput(container_of(work, struct file, f_rcuhead));\n}\n\n \nvoid flush_delayed_fput(void)\n{\n\tdelayed_fput(NULL);\n}\nEXPORT_SYMBOL_GPL(flush_delayed_fput);\n\nstatic DECLARE_DELAYED_WORK(delayed_fput_work, delayed_fput);\n\nvoid fput(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\n\t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&file->f_rcuhead, ____fput);\n\t\t\tif (!task_work_add(task, &file->f_rcuhead, TWA_RESUME))\n\t\t\t\treturn;\n\t\t\t \n\t\t}\n\n\t\tif (llist_add(&file->f_llist, &delayed_fput_list))\n\t\t\tschedule_delayed_work(&delayed_fput_work, 1);\n\t}\n}\n\n \nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count))\n\t\t__fput(file);\n}\n\nEXPORT_SYMBOL(fput);\nEXPORT_SYMBOL(__fput_sync);\n\nvoid __init files_init(void)\n{\n\tfilp_cachep = kmem_cache_create(\"filp\", sizeof(struct file), 0,\n\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT, NULL);\n\tpercpu_counter_init(&nr_files, 0, GFP_KERNEL);\n}\n\n \nvoid __init files_maxfiles_init(void)\n{\n\tunsigned long n;\n\tunsigned long nr_pages = totalram_pages();\n\tunsigned long memreserve = (nr_pages - nr_free_pages()) * 3/2;\n\n\tmemreserve = min(memreserve, nr_pages - 1);\n\tn = ((nr_pages - memreserve) * (PAGE_SIZE / 1024)) / 10;\n\n\tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}