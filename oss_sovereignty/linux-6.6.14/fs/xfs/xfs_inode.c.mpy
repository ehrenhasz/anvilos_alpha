{
  "module_name": "xfs_inode.c",
  "hash_id": "88624820ec4b115e04129ba22280e9d96e6e9ca62119115c5306d24fb7eef921",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_inode.c",
  "human_readable_source": "\n \n#include <linux/iversion.h>\n\n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_iunlink_item.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_errortag.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_reflink.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_log_priv.h\"\n\nstruct kmem_cache *xfs_inode_cache;\n\n \n#define\tXFS_ITRUNC_MAX_EXTENTS\t2\n\nSTATIC int xfs_iunlink(struct xfs_trans *, struct xfs_inode *);\nSTATIC int xfs_iunlink_remove(struct xfs_trans *tp, struct xfs_perag *pag,\n\tstruct xfs_inode *);\n\n \nxfs_extlen_t\nxfs_get_extsz_hint(\n\tstruct xfs_inode\t*ip)\n{\n\t \n\tif (xfs_is_always_cow_inode(ip))\n\t\treturn 0;\n\tif ((ip->i_diflags & XFS_DIFLAG_EXTSIZE) && ip->i_extsize)\n\t\treturn ip->i_extsize;\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn ip->i_mount->m_sb.sb_rextsize;\n\treturn 0;\n}\n\n \nxfs_extlen_t\nxfs_get_cowextsz_hint(\n\tstruct xfs_inode\t*ip)\n{\n\txfs_extlen_t\t\ta, b;\n\n\ta = 0;\n\tif (ip->i_diflags2 & XFS_DIFLAG2_COWEXTSIZE)\n\t\ta = ip->i_cowextsize;\n\tb = xfs_get_extsz_hint(ip);\n\n\ta = max(a, b);\n\tif (a == 0)\n\t\treturn XFS_DEFAULT_COWEXTSZ_HINT;\n\treturn a;\n}\n\n \nuint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (xfs_need_iread_extents(&ip->i_df))\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}\n\nuint\nxfs_ilock_attr_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (xfs_inode_has_attr_fork(ip) && xfs_need_iread_extents(&ip->i_af))\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}\n\n \nstatic inline void\nxfs_lock_flags_assert(\n\tuint\t\tlock_flags)\n{\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t\t(XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_MMAPLOCK_SHARED | XFS_MMAPLOCK_EXCL)) !=\n\t\t(XFS_MMAPLOCK_SHARED | XFS_MMAPLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t\t(XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_SUBCLASS_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n}\n\n \nvoid\nxfs_ilock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock(ip, lock_flags, _RET_IP_);\n\n\txfs_lock_flags_assert(lock_flags);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tdown_write_nested(&VFS_I(ip)->i_rwsem,\n\t\t\t\t  XFS_IOLOCK_DEP(lock_flags));\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tdown_read_nested(&VFS_I(ip)->i_rwsem,\n\t\t\t\t XFS_IOLOCK_DEP(lock_flags));\n\t}\n\n\tif (lock_flags & XFS_MMAPLOCK_EXCL) {\n\t\tdown_write_nested(&VFS_I(ip)->i_mapping->invalidate_lock,\n\t\t\t\t  XFS_MMAPLOCK_DEP(lock_flags));\n\t} else if (lock_flags & XFS_MMAPLOCK_SHARED) {\n\t\tdown_read_nested(&VFS_I(ip)->i_mapping->invalidate_lock,\n\t\t\t\t XFS_MMAPLOCK_DEP(lock_flags));\n\t}\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrupdate_nested(&ip->i_lock, XFS_ILOCK_DEP(lock_flags));\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmraccess_nested(&ip->i_lock, XFS_ILOCK_DEP(lock_flags));\n}\n\n \nint\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\txfs_lock_flags_assert(lock_flags);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!down_write_trylock(&VFS_I(ip)->i_rwsem))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!down_read_trylock(&VFS_I(ip)->i_rwsem))\n\t\t\tgoto out;\n\t}\n\n\tif (lock_flags & XFS_MMAPLOCK_EXCL) {\n\t\tif (!down_write_trylock(&VFS_I(ip)->i_mapping->invalidate_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_MMAPLOCK_SHARED) {\n\t\tif (!down_read_trylock(&VFS_I(ip)->i_mapping->invalidate_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_mmaplock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_mmaplock;\n\t}\n\treturn 1;\n\nout_undo_mmaplock:\n\tif (lock_flags & XFS_MMAPLOCK_EXCL)\n\t\tup_write(&VFS_I(ip)->i_mapping->invalidate_lock);\n\telse if (lock_flags & XFS_MMAPLOCK_SHARED)\n\t\tup_read(&VFS_I(ip)->i_mapping->invalidate_lock);\nout_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tup_write(&VFS_I(ip)->i_rwsem);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tup_read(&VFS_I(ip)->i_rwsem);\nout:\n\treturn 0;\n}\n\n \nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_lock_flags_assert(lock_flags);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tup_write(&VFS_I(ip)->i_rwsem);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tup_read(&VFS_I(ip)->i_rwsem);\n\n\tif (lock_flags & XFS_MMAPLOCK_EXCL)\n\t\tup_write(&VFS_I(ip)->i_mapping->invalidate_lock);\n\telse if (lock_flags & XFS_MMAPLOCK_SHARED)\n\t\tup_read(&VFS_I(ip)->i_mapping->invalidate_lock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}\n\n \nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_MMAPLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags &\n\t\t~(XFS_IOLOCK_EXCL|XFS_MMAPLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_MMAPLOCK_EXCL)\n\t\tdowngrade_write(&VFS_I(ip)->i_mapping->invalidate_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tdowngrade_write(&VFS_I(ip)->i_rwsem);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}\n\n#if defined(DEBUG) || defined(XFS_WARN)\nstatic inline bool\n__xfs_rwsem_islocked(\n\tstruct rw_semaphore\t*rwsem,\n\tbool\t\t\tshared)\n{\n\tif (!debug_locks)\n\t\treturn rwsem_is_locked(rwsem);\n\n\tif (!shared)\n\t\treturn lockdep_is_held_type(rwsem, 0);\n\n\t \n\treturn lockdep_is_held_type(rwsem, -1);\n}\n\nbool\nxfs_isilocked(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_MMAPLOCK_EXCL|XFS_MMAPLOCK_SHARED)) {\n\t\treturn __xfs_rwsem_islocked(&VFS_I(ip)->i_mapping->invalidate_lock,\n\t\t\t\t(lock_flags & XFS_MMAPLOCK_SHARED));\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) {\n\t\treturn __xfs_rwsem_islocked(&VFS_I(ip)->i_rwsem,\n\t\t\t\t(lock_flags & XFS_IOLOCK_SHARED));\n\t}\n\n\tASSERT(0);\n\treturn false;\n}\n#endif\n\n \n#if (defined(DEBUG) || defined(XFS_WARN)) && defined(CONFIG_LOCKDEP)\nstatic bool\nxfs_lockdep_subclass_ok(\n\tint subclass)\n{\n\treturn subclass < MAX_LOCKDEP_SUBCLASSES;\n}\n#else\n#define xfs_lockdep_subclass_ok(subclass)\t(true)\n#endif\n\n \nstatic inline uint\nxfs_lock_inumorder(\n\tuint\tlock_mode,\n\tuint\tsubclass)\n{\n\tuint\tclass = 0;\n\n\tASSERT(!(lock_mode & (XFS_ILOCK_PARENT | XFS_ILOCK_RTBITMAP |\n\t\t\t      XFS_ILOCK_RTSUM)));\n\tASSERT(xfs_lockdep_subclass_ok(subclass));\n\n\tif (lock_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL)) {\n\t\tASSERT(subclass <= XFS_IOLOCK_MAX_SUBCLASS);\n\t\tclass += subclass << XFS_IOLOCK_SHIFT;\n\t}\n\n\tif (lock_mode & (XFS_MMAPLOCK_SHARED|XFS_MMAPLOCK_EXCL)) {\n\t\tASSERT(subclass <= XFS_MMAPLOCK_MAX_SUBCLASS);\n\t\tclass += subclass << XFS_MMAPLOCK_SHIFT;\n\t}\n\n\tif (lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL)) {\n\t\tASSERT(subclass <= XFS_ILOCK_MAX_SUBCLASS);\n\t\tclass += subclass << XFS_ILOCK_SHIFT;\n\t}\n\n\treturn (lock_mode & ~XFS_LOCK_SUBCLASS_MASK) | class;\n}\n\n \nstatic void\nxfs_lock_inodes(\n\tstruct xfs_inode\t**ips,\n\tint\t\t\tinodes,\n\tuint\t\t\tlock_mode)\n{\n\tint\t\t\tattempts = 0;\n\tuint\t\t\ti;\n\tint\t\t\tj;\n\tbool\t\t\ttry_lock;\n\tstruct xfs_log_item\t*lp;\n\n\t \n\tASSERT(ips && inodes >= 2 && inodes <= 5);\n\tASSERT(lock_mode & (XFS_IOLOCK_EXCL | XFS_MMAPLOCK_EXCL |\n\t\t\t    XFS_ILOCK_EXCL));\n\tASSERT(!(lock_mode & (XFS_IOLOCK_SHARED | XFS_MMAPLOCK_SHARED |\n\t\t\t      XFS_ILOCK_SHARED)));\n\tASSERT(!(lock_mode & XFS_MMAPLOCK_EXCL) ||\n\t\tinodes <= XFS_MMAPLOCK_MAX_SUBCLASS + 1);\n\tASSERT(!(lock_mode & XFS_ILOCK_EXCL) ||\n\t\tinodes <= XFS_ILOCK_MAX_SUBCLASS + 1);\n\n\tif (lock_mode & XFS_IOLOCK_EXCL) {\n\t\tASSERT(!(lock_mode & (XFS_MMAPLOCK_EXCL | XFS_ILOCK_EXCL)));\n\t} else if (lock_mode & XFS_MMAPLOCK_EXCL)\n\t\tASSERT(!(lock_mode & XFS_ILOCK_EXCL));\n\nagain:\n\ttry_lock = false;\n\ti = 0;\n\tfor (; i < inodes; i++) {\n\t\tASSERT(ips[i]);\n\n\t\tif (i && (ips[i] == ips[i - 1]))\t \n\t\t\tcontinue;\n\n\t\t \n\t\tif (!try_lock) {\n\t\t\tfor (j = (i - 1); j >= 0 && !try_lock; j--) {\n\t\t\t\tlp = &ips[j]->i_itemp->ili_item;\n\t\t\t\tif (lp && test_bit(XFS_LI_IN_AIL, &lp->li_flags))\n\t\t\t\t\ttry_lock = true;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!try_lock) {\n\t\t\txfs_ilock(ips[i], xfs_lock_inumorder(lock_mode, i));\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tASSERT(i != 0);\n\t\tif (xfs_ilock_nowait(ips[i], xfs_lock_inumorder(lock_mode, i)))\n\t\t\tcontinue;\n\n\t\t \n\t\tattempts++;\n\t\tfor (j = i - 1; j >= 0; j--) {\n\t\t\t \n\t\t\tif (j != (i - 1) && ips[j] == ips[j + 1])\n\t\t\t\tcontinue;\n\n\t\t\txfs_iunlock(ips[j], lock_mode);\n\t\t}\n\n\t\tif ((attempts % 5) == 0) {\n\t\t\tdelay(1);  \n\t\t}\n\t\tgoto again;\n\t}\n}\n\n \nvoid\nxfs_lock_two_inodes(\n\tstruct xfs_inode\t*ip0,\n\tuint\t\t\tip0_mode,\n\tstruct xfs_inode\t*ip1,\n\tuint\t\t\tip1_mode)\n{\n\tint\t\t\tattempts = 0;\n\tstruct xfs_log_item\t*lp;\n\n\tASSERT(hweight32(ip0_mode) == 1);\n\tASSERT(hweight32(ip1_mode) == 1);\n\tASSERT(!(ip0_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL)));\n\tASSERT(!(ip1_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL)));\n\tASSERT(!(ip0_mode & (XFS_MMAPLOCK_SHARED|XFS_MMAPLOCK_EXCL)));\n\tASSERT(!(ip1_mode & (XFS_MMAPLOCK_SHARED|XFS_MMAPLOCK_EXCL)));\n\tASSERT(ip0->i_ino != ip1->i_ino);\n\n\tif (ip0->i_ino > ip1->i_ino) {\n\t\tswap(ip0, ip1);\n\t\tswap(ip0_mode, ip1_mode);\n\t}\n\n again:\n\txfs_ilock(ip0, xfs_lock_inumorder(ip0_mode, 0));\n\n\t \n\tlp = &ip0->i_itemp->ili_item;\n\tif (lp && test_bit(XFS_LI_IN_AIL, &lp->li_flags)) {\n\t\tif (!xfs_ilock_nowait(ip1, xfs_lock_inumorder(ip1_mode, 1))) {\n\t\t\txfs_iunlock(ip0, ip0_mode);\n\t\t\tif ((++attempts % 5) == 0)\n\t\t\t\tdelay(1);  \n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\txfs_ilock(ip1, xfs_lock_inumorder(ip1_mode, 1));\n\t}\n}\n\nuint\nxfs_ip2xflags(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tflags = 0;\n\n\tif (ip->i_diflags & XFS_DIFLAG_ANY) {\n\t\tif (ip->i_diflags & XFS_DIFLAG_REALTIME)\n\t\t\tflags |= FS_XFLAG_REALTIME;\n\t\tif (ip->i_diflags & XFS_DIFLAG_PREALLOC)\n\t\t\tflags |= FS_XFLAG_PREALLOC;\n\t\tif (ip->i_diflags & XFS_DIFLAG_IMMUTABLE)\n\t\t\tflags |= FS_XFLAG_IMMUTABLE;\n\t\tif (ip->i_diflags & XFS_DIFLAG_APPEND)\n\t\t\tflags |= FS_XFLAG_APPEND;\n\t\tif (ip->i_diflags & XFS_DIFLAG_SYNC)\n\t\t\tflags |= FS_XFLAG_SYNC;\n\t\tif (ip->i_diflags & XFS_DIFLAG_NOATIME)\n\t\t\tflags |= FS_XFLAG_NOATIME;\n\t\tif (ip->i_diflags & XFS_DIFLAG_NODUMP)\n\t\t\tflags |= FS_XFLAG_NODUMP;\n\t\tif (ip->i_diflags & XFS_DIFLAG_RTINHERIT)\n\t\t\tflags |= FS_XFLAG_RTINHERIT;\n\t\tif (ip->i_diflags & XFS_DIFLAG_PROJINHERIT)\n\t\t\tflags |= FS_XFLAG_PROJINHERIT;\n\t\tif (ip->i_diflags & XFS_DIFLAG_NOSYMLINKS)\n\t\t\tflags |= FS_XFLAG_NOSYMLINKS;\n\t\tif (ip->i_diflags & XFS_DIFLAG_EXTSIZE)\n\t\t\tflags |= FS_XFLAG_EXTSIZE;\n\t\tif (ip->i_diflags & XFS_DIFLAG_EXTSZINHERIT)\n\t\t\tflags |= FS_XFLAG_EXTSZINHERIT;\n\t\tif (ip->i_diflags & XFS_DIFLAG_NODEFRAG)\n\t\t\tflags |= FS_XFLAG_NODEFRAG;\n\t\tif (ip->i_diflags & XFS_DIFLAG_FILESTREAM)\n\t\t\tflags |= FS_XFLAG_FILESTREAM;\n\t}\n\n\tif (ip->i_diflags2 & XFS_DIFLAG2_ANY) {\n\t\tif (ip->i_diflags2 & XFS_DIFLAG2_DAX)\n\t\t\tflags |= FS_XFLAG_DAX;\n\t\tif (ip->i_diflags2 & XFS_DIFLAG2_COWEXTSIZE)\n\t\t\tflags |= FS_XFLAG_COWEXTSIZE;\n\t}\n\n\tif (xfs_inode_has_attr_fork(ip))\n\t\tflags |= FS_XFLAG_HASATTR;\n\treturn flags;\n}\n\n \nint\nxfs_lookup(\n\tstruct xfs_inode\t*dp,\n\tconst struct xfs_name\t*name,\n\tstruct xfs_inode\t**ipp,\n\tstruct xfs_name\t\t*ci_name)\n{\n\txfs_ino_t\t\tinum;\n\tint\t\t\terror;\n\n\ttrace_xfs_lookup(dp, name);\n\n\tif (xfs_is_shutdown(dp->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_dir_lookup(NULL, dp, name, &inum, ci_name);\n\tif (error)\n\t\tgoto out_unlock;\n\n\terror = xfs_iget(dp->i_mount, NULL, inum, 0, 0, ipp);\n\tif (error)\n\t\tgoto out_free_name;\n\n\treturn 0;\n\nout_free_name:\n\tif (ci_name)\n\t\tkmem_free(ci_name->name);\nout_unlock:\n\t*ipp = NULL;\n\treturn error;\n}\n\n \nstatic void\nxfs_inode_inherit_flags(\n\tstruct xfs_inode\t*ip,\n\tconst struct xfs_inode\t*pip)\n{\n\tunsigned int\t\tdi_flags = 0;\n\txfs_failaddr_t\t\tfailaddr;\n\tumode_t\t\t\tmode = VFS_I(ip)->i_mode;\n\n\tif (S_ISDIR(mode)) {\n\t\tif (pip->i_diflags & XFS_DIFLAG_RTINHERIT)\n\t\t\tdi_flags |= XFS_DIFLAG_RTINHERIT;\n\t\tif (pip->i_diflags & XFS_DIFLAG_EXTSZINHERIT) {\n\t\t\tdi_flags |= XFS_DIFLAG_EXTSZINHERIT;\n\t\t\tip->i_extsize = pip->i_extsize;\n\t\t}\n\t\tif (pip->i_diflags & XFS_DIFLAG_PROJINHERIT)\n\t\t\tdi_flags |= XFS_DIFLAG_PROJINHERIT;\n\t} else if (S_ISREG(mode)) {\n\t\tif ((pip->i_diflags & XFS_DIFLAG_RTINHERIT) &&\n\t\t    xfs_has_realtime(ip->i_mount))\n\t\t\tdi_flags |= XFS_DIFLAG_REALTIME;\n\t\tif (pip->i_diflags & XFS_DIFLAG_EXTSZINHERIT) {\n\t\t\tdi_flags |= XFS_DIFLAG_EXTSIZE;\n\t\t\tip->i_extsize = pip->i_extsize;\n\t\t}\n\t}\n\tif ((pip->i_diflags & XFS_DIFLAG_NOATIME) &&\n\t    xfs_inherit_noatime)\n\t\tdi_flags |= XFS_DIFLAG_NOATIME;\n\tif ((pip->i_diflags & XFS_DIFLAG_NODUMP) &&\n\t    xfs_inherit_nodump)\n\t\tdi_flags |= XFS_DIFLAG_NODUMP;\n\tif ((pip->i_diflags & XFS_DIFLAG_SYNC) &&\n\t    xfs_inherit_sync)\n\t\tdi_flags |= XFS_DIFLAG_SYNC;\n\tif ((pip->i_diflags & XFS_DIFLAG_NOSYMLINKS) &&\n\t    xfs_inherit_nosymlinks)\n\t\tdi_flags |= XFS_DIFLAG_NOSYMLINKS;\n\tif ((pip->i_diflags & XFS_DIFLAG_NODEFRAG) &&\n\t    xfs_inherit_nodefrag)\n\t\tdi_flags |= XFS_DIFLAG_NODEFRAG;\n\tif (pip->i_diflags & XFS_DIFLAG_FILESTREAM)\n\t\tdi_flags |= XFS_DIFLAG_FILESTREAM;\n\n\tip->i_diflags |= di_flags;\n\n\t \n\tfailaddr = xfs_inode_validate_extsize(ip->i_mount, ip->i_extsize,\n\t\t\tVFS_I(ip)->i_mode, ip->i_diflags);\n\tif (failaddr) {\n\t\tip->i_diflags &= ~(XFS_DIFLAG_EXTSIZE |\n\t\t\t\t   XFS_DIFLAG_EXTSZINHERIT);\n\t\tip->i_extsize = 0;\n\t}\n}\n\n \nstatic void\nxfs_inode_inherit_flags2(\n\tstruct xfs_inode\t*ip,\n\tconst struct xfs_inode\t*pip)\n{\n\txfs_failaddr_t\t\tfailaddr;\n\n\tif (pip->i_diflags2 & XFS_DIFLAG2_COWEXTSIZE) {\n\t\tip->i_diflags2 |= XFS_DIFLAG2_COWEXTSIZE;\n\t\tip->i_cowextsize = pip->i_cowextsize;\n\t}\n\tif (pip->i_diflags2 & XFS_DIFLAG2_DAX)\n\t\tip->i_diflags2 |= XFS_DIFLAG2_DAX;\n\n\t \n\tfailaddr = xfs_inode_validate_cowextsize(ip->i_mount, ip->i_cowextsize,\n\t\t\tVFS_I(ip)->i_mode, ip->i_diflags, ip->i_diflags2);\n\tif (failaddr) {\n\t\tip->i_diflags2 &= ~XFS_DIFLAG2_COWEXTSIZE;\n\t\tip->i_cowextsize = 0;\n\t}\n}\n\n \nint\nxfs_init_new_inode(\n\tstruct mnt_idmap\t*idmap,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*pip,\n\txfs_ino_t\t\tino,\n\tumode_t\t\t\tmode,\n\txfs_nlink_t\t\tnlink,\n\tdev_t\t\t\trdev,\n\tprid_t\t\t\tprid,\n\tbool\t\t\tinit_xattrs,\n\tstruct xfs_inode\t**ipp)\n{\n\tstruct inode\t\t*dir = pip ? VFS_I(pip) : NULL;\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_inode\t*ip;\n\tunsigned int\t\tflags;\n\tint\t\t\terror;\n\tstruct timespec64\ttv;\n\tstruct inode\t\t*inode;\n\n\t \n\tif ((pip && ino == pip->i_ino) || !xfs_verify_dir_ino(mp, ino)) {\n\t\txfs_alert(mp, \"Allocated a known in-use inode 0x%llx!\", ino);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\terror = xfs_iget(mp, tp, ino, XFS_IGET_CREATE, XFS_ILOCK_EXCL, &ip);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(ip != NULL);\n\tinode = VFS_I(ip);\n\tset_nlink(inode, nlink);\n\tinode->i_rdev = rdev;\n\tip->i_projid = prid;\n\n\tif (dir && !(dir->i_mode & S_ISGID) && xfs_has_grpid(mp)) {\n\t\tinode_fsuid_set(inode, idmap);\n\t\tinode->i_gid = dir->i_gid;\n\t\tinode->i_mode = mode;\n\t} else {\n\t\tinode_init_owner(idmap, inode, dir, mode);\n\t}\n\n\t \n\tif (irix_sgid_inherit && (inode->i_mode & S_ISGID) &&\n\t    !vfsgid_in_group_p(i_gid_into_vfsgid(idmap, inode)))\n\t\tinode->i_mode &= ~S_ISGID;\n\n\tip->i_disk_size = 0;\n\tip->i_df.if_nextents = 0;\n\tASSERT(ip->i_nblocks == 0);\n\n\ttv = inode_set_ctime_current(inode);\n\tinode->i_mtime = tv;\n\tinode->i_atime = tv;\n\n\tip->i_extsize = 0;\n\tip->i_diflags = 0;\n\n\tif (xfs_has_v3inodes(mp)) {\n\t\tinode_set_iversion(inode, 1);\n\t\tip->i_cowextsize = 0;\n\t\tip->i_crtime = tv;\n\t}\n\n\tflags = XFS_ILOG_CORE;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tip->i_df.if_format = XFS_DINODE_FMT_DEV;\n\t\tflags |= XFS_ILOG_DEV;\n\t\tbreak;\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\t\tif (pip && (pip->i_diflags & XFS_DIFLAG_ANY))\n\t\t\txfs_inode_inherit_flags(ip, pip);\n\t\tif (pip && (pip->i_diflags2 & XFS_DIFLAG2_ANY))\n\t\t\txfs_inode_inherit_flags2(ip, pip);\n\t\tfallthrough;\n\tcase S_IFLNK:\n\t\tip->i_df.if_format = XFS_DINODE_FMT_EXTENTS;\n\t\tip->i_df.if_bytes = 0;\n\t\tip->i_df.if_u1.if_root = NULL;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\n\t \n\tif (init_xattrs && xfs_has_attr(mp)) {\n\t\tip->i_forkoff = xfs_default_attroffset(ip) >> 3;\n\t\txfs_ifork_init_attr(ip, XFS_DINODE_FMT_EXTENTS, 0);\n\t}\n\n\t \n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, flags);\n\n\t \n\txfs_setup_inode(ip);\n\n\t*ipp = ip;\n\treturn 0;\n}\n\n \nstatic int\t\t\t \nxfs_droplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tdrop_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (VFS_I(ip)->i_nlink)\n\t\treturn 0;\n\n\treturn xfs_iunlink(tp, ip);\n}\n\n \nstatic void\nxfs_bumplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\n\tinc_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n}\n\nint\nxfs_create(\n\tstruct mnt_idmap\t*idmap,\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\tumode_t\t\t\tmode,\n\tdev_t\t\t\trdev,\n\tbool\t\t\tinit_xattrs,\n\txfs_inode_t\t\t**ipp)\n{\n\tint\t\t\tis_dir = S_ISDIR(mode);\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_inode\t*ip = NULL;\n\tstruct xfs_trans\t*tp = NULL;\n\tint\t\t\terror;\n\tbool                    unlock_dp_on_error = false;\n\tprid_t\t\t\tprid;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*gdqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tstruct xfs_trans_res\t*tres;\n\tuint\t\t\tresblks;\n\txfs_ino_t\t\tino;\n\n\ttrace_xfs_create(dp, name);\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\tprid = xfs_get_initial_prid(dp);\n\n\t \n\terror = xfs_qm_vop_dqalloc(dp, mapped_fsuid(idmap, &init_user_ns),\n\t\t\tmapped_fsgid(idmap, &init_user_ns), prid,\n\t\t\tXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT,\n\t\t\t&udqp, &gdqp, &pdqp);\n\tif (error)\n\t\treturn error;\n\n\tif (is_dir) {\n\t\tresblks = XFS_MKDIR_SPACE_RES(mp, name->len);\n\t\ttres = &M_RES(mp)->tr_mkdir;\n\t} else {\n\t\tresblks = XFS_CREATE_SPACE_RES(mp, name->len);\n\t\ttres = &M_RES(mp)->tr_create;\n\t}\n\n\t \n\terror = xfs_trans_alloc_icreate(mp, tres, udqp, gdqp, pdqp, resblks,\n\t\t\t&tp);\n\tif (error == -ENOSPC) {\n\t\t \n\t\txfs_flush_inodes(mp);\n\t\terror = xfs_trans_alloc_icreate(mp, tres, udqp, gdqp, pdqp,\n\t\t\t\tresblks, &tp);\n\t}\n\tif (error)\n\t\tgoto out_release_dquots;\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL | XFS_ILOCK_PARENT);\n\tunlock_dp_on_error = true;\n\n\t \n\terror = xfs_dialloc(&tp, dp->i_ino, mode, &ino);\n\tif (!error)\n\t\terror = xfs_init_new_inode(idmap, tp, dp, ino, mode,\n\t\t\t\tis_dir ? 2 : 1, rdev, prid, init_xattrs, &ip);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\t \n\txfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\n\tunlock_dp_on_error = false;\n\n\terror = xfs_dir_createname(tp, dp, name, ip->i_ino,\n\t\t\t\t\tresblks - XFS_IALLOC_SPACE_RES(mp));\n\tif (error) {\n\t\tASSERT(error != -ENOSPC);\n\t\tgoto out_trans_cancel;\n\t}\n\txfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\n\tif (is_dir) {\n\t\terror = xfs_dir_init(tp, ip, dp);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\txfs_bumplink(tp, dp);\n\t}\n\n\t \n\tif (xfs_has_wsync(mp) || xfs_has_dirsync(mp))\n\t\txfs_trans_set_sync(tp);\n\n\t \n\txfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp, pdqp);\n\n\terror = xfs_trans_commit(tp);\n\tif (error)\n\t\tgoto out_release_inode;\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\t*ipp = ip;\n\treturn 0;\n\n out_trans_cancel:\n\txfs_trans_cancel(tp);\n out_release_inode:\n\t \n\tif (ip) {\n\t\txfs_finish_inode_setup(ip);\n\t\txfs_irele(ip);\n\t}\n out_release_dquots:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\tif (unlock_dp_on_error)\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\nint\nxfs_create_tmpfile(\n\tstruct mnt_idmap\t*idmap,\n\tstruct xfs_inode\t*dp,\n\tumode_t\t\t\tmode,\n\tstruct xfs_inode\t**ipp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_inode\t*ip = NULL;\n\tstruct xfs_trans\t*tp = NULL;\n\tint\t\t\terror;\n\tprid_t                  prid;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*gdqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tstruct xfs_trans_res\t*tres;\n\tuint\t\t\tresblks;\n\txfs_ino_t\t\tino;\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\tprid = xfs_get_initial_prid(dp);\n\n\t \n\terror = xfs_qm_vop_dqalloc(dp, mapped_fsuid(idmap, &init_user_ns),\n\t\t\tmapped_fsgid(idmap, &init_user_ns), prid,\n\t\t\tXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT,\n\t\t\t&udqp, &gdqp, &pdqp);\n\tif (error)\n\t\treturn error;\n\n\tresblks = XFS_IALLOC_SPACE_RES(mp);\n\ttres = &M_RES(mp)->tr_create_tmpfile;\n\n\terror = xfs_trans_alloc_icreate(mp, tres, udqp, gdqp, pdqp, resblks,\n\t\t\t&tp);\n\tif (error)\n\t\tgoto out_release_dquots;\n\n\terror = xfs_dialloc(&tp, dp->i_ino, mode, &ino);\n\tif (!error)\n\t\terror = xfs_init_new_inode(idmap, tp, dp, ino, mode,\n\t\t\t\t0, 0, prid, false, &ip);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tif (xfs_has_wsync(mp))\n\t\txfs_trans_set_sync(tp);\n\n\t \n\txfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp, pdqp);\n\n\terror = xfs_iunlink(tp, ip);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\terror = xfs_trans_commit(tp);\n\tif (error)\n\t\tgoto out_release_inode;\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\t*ipp = ip;\n\treturn 0;\n\n out_trans_cancel:\n\txfs_trans_cancel(tp);\n out_release_inode:\n\t \n\tif (ip) {\n\t\txfs_finish_inode_setup(ip);\n\t\txfs_irele(ip);\n\t}\n out_release_dquots:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\treturn error;\n}\n\nint\nxfs_link(\n\txfs_inode_t\t\t*tdp,\n\txfs_inode_t\t\t*sip,\n\tstruct xfs_name\t\t*target_name)\n{\n\txfs_mount_t\t\t*mp = tdp->i_mount;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror, nospace_error = 0;\n\tint\t\t\tresblks;\n\n\ttrace_xfs_link(tdp, target_name);\n\n\tASSERT(!S_ISDIR(VFS_I(sip)->i_mode));\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(sip);\n\tif (error)\n\t\tgoto std_return;\n\n\terror = xfs_qm_dqattach(tdp);\n\tif (error)\n\t\tgoto std_return;\n\n\tresblks = XFS_LINK_SPACE_RES(mp, target_name->len);\n\terror = xfs_trans_alloc_dir(tdp, &M_RES(mp)->tr_link, sip, &resblks,\n\t\t\t&tp, &nospace_error);\n\tif (error)\n\t\tgoto std_return;\n\n\t \n\tif (unlikely((tdp->i_diflags & XFS_DIFLAG_PROJINHERIT) &&\n\t\t     tdp->i_projid != sip->i_projid)) {\n\t\terror = -EXDEV;\n\t\tgoto error_return;\n\t}\n\n\tif (!resblks) {\n\t\terror = xfs_dir_canenter(tp, tdp, target_name);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t}\n\n\t \n\tif (VFS_I(sip)->i_nlink == 0) {\n\t\tstruct xfs_perag\t*pag;\n\n\t\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, sip->i_ino));\n\t\terror = xfs_iunlink_remove(tp, pag, sip);\n\t\txfs_perag_put(pag);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t}\n\n\terror = xfs_dir_createname(tp, tdp, target_name, sip->i_ino,\n\t\t\t\t   resblks);\n\tif (error)\n\t\tgoto error_return;\n\txfs_trans_ichgtime(tp, tdp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, tdp, XFS_ILOG_CORE);\n\n\txfs_bumplink(tp, sip);\n\n\t \n\tif (xfs_has_wsync(mp) || xfs_has_dirsync(mp))\n\t\txfs_trans_set_sync(tp);\n\n\treturn xfs_trans_commit(tp);\n\n error_return:\n\txfs_trans_cancel(tp);\n std_return:\n\tif (error == -ENOSPC && nospace_error)\n\t\terror = nospace_error;\n\treturn error;\n}\n\n \nstatic void\nxfs_itruncate_clear_reflink_flags(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_ifork\t*dfork;\n\tstruct xfs_ifork\t*cfork;\n\n\tif (!xfs_is_reflink_inode(ip))\n\t\treturn;\n\tdfork = xfs_ifork_ptr(ip, XFS_DATA_FORK);\n\tcfork = xfs_ifork_ptr(ip, XFS_COW_FORK);\n\tif (dfork->if_bytes == 0 && cfork->if_bytes == 0)\n\t\tip->i_diflags2 &= ~XFS_DIFLAG2_REFLINK;\n\tif (cfork->if_bytes == 0)\n\t\txfs_inode_clear_cowblocks_tag(ip);\n}\n\n \nint\nxfs_itruncate_extents_flags(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_fsize_t\t\tnew_size,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp = *tpp;\n\txfs_fileoff_t\t\tfirst_unmap_block;\n\txfs_filblks_t\t\tunmap_len;\n\tint\t\t\terror = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(!atomic_read(&VFS_I(ip)->i_count) ||\n\t       xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(new_size <= XFS_ISIZE(ip));\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(ip->i_itemp->ili_lock_flags == 0);\n\tASSERT(!XFS_NOT_DQATTACHED(mp, ip));\n\n\ttrace_xfs_itruncate_extents_start(ip, new_size);\n\n\tflags |= xfs_bmapi_aflag(whichfork);\n\n\t \n\tfirst_unmap_block = XFS_B_TO_FSB(mp, (xfs_ufsize_t)new_size);\n\tif (!xfs_verify_fileoff(mp, first_unmap_block)) {\n\t\tWARN_ON_ONCE(first_unmap_block > XFS_MAX_FILEOFF);\n\t\treturn 0;\n\t}\n\n\tunmap_len = XFS_MAX_FILEOFF - first_unmap_block + 1;\n\twhile (unmap_len > 0) {\n\t\tASSERT(tp->t_highest_agno == NULLAGNUMBER);\n\t\terror = __xfs_bunmapi(tp, ip, first_unmap_block, &unmap_len,\n\t\t\t\tflags, XFS_ITRUNC_MAX_EXTENTS);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t \n\t\terror = xfs_defer_finish(&tp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (whichfork == XFS_DATA_FORK) {\n\t\t \n\t\terror = xfs_reflink_cancel_cow_blocks(ip, &tp,\n\t\t\t\tfirst_unmap_block, XFS_MAX_FILEOFF, true);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\txfs_itruncate_clear_reflink_flags(ip);\n\t}\n\n\t \n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\ttrace_xfs_itruncate_extents_end(ip, new_size);\n\nout:\n\t*tpp = tp;\n\treturn error;\n}\n\nint\nxfs_release(\n\txfs_inode_t\t*ip)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\tint\t\terror = 0;\n\n\tif (!S_ISREG(VFS_I(ip)->i_mode) || (VFS_I(ip)->i_mode == 0))\n\t\treturn 0;\n\n\t \n\tif (xfs_is_readonly(mp))\n\t\treturn 0;\n\n\tif (!xfs_is_shutdown(mp)) {\n\t\tint truncated;\n\n\t\t \n\t\ttruncated = xfs_iflags_test_and_clear(ip, XFS_ITRUNCATED);\n\t\tif (truncated) {\n\t\t\txfs_iflags_clear(ip, XFS_IDIRTY_RELEASE);\n\t\t\tif (ip->i_delayed_blks > 0) {\n\t\t\t\terror = filemap_flush(VFS_I(ip)->i_mapping);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (VFS_I(ip)->i_nlink == 0)\n\t\treturn 0;\n\n\t \n\tif (!xfs_ilock_nowait(ip, XFS_IOLOCK_EXCL))\n\t\treturn 0;\n\n\tif (xfs_can_free_eofblocks(ip, false)) {\n\t\t \n\t\tif (xfs_iflags_test(ip, XFS_IDIRTY_RELEASE))\n\t\t\tgoto out_unlock;\n\n\t\terror = xfs_free_eofblocks(ip);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\n\t\t \n\t\tif (ip->i_delayed_blks)\n\t\t\txfs_iflags_set(ip, XFS_IDIRTY_RELEASE);\n\t}\n\nout_unlock:\n\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_inactive_truncate(\n\tstruct xfs_inode *ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_itruncate, 0, 0, 0, &tp);\n\tif (error) {\n\t\tASSERT(xfs_is_shutdown(mp));\n\t\treturn error;\n\t}\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t \n\tip->i_disk_size = 0;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, 0);\n\tif (error)\n\t\tgoto error_trans_cancel;\n\n\tASSERT(ip->i_df.if_nextents == 0);\n\n\terror = xfs_trans_commit(tp);\n\tif (error)\n\t\tgoto error_unlock;\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn 0;\n\nerror_trans_cancel:\n\txfs_trans_cancel(tp);\nerror_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_inactive_ifree(\n\tstruct xfs_inode *ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\t \n\tif (unlikely(mp->m_finobt_nores)) {\n\t\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_ifree,\n\t\t\t\tXFS_IFREE_SPACE_RES(mp), 0, XFS_TRANS_RESERVE,\n\t\t\t\t&tp);\n\t} else {\n\t\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_ifree, 0, 0, 0, &tp);\n\t}\n\tif (error) {\n\t\tif (error == -ENOSPC) {\n\t\t\txfs_warn_ratelimited(mp,\n\t\t\t\"Failed to remove inode(s) from unlinked list. \"\n\t\t\t\"Please free space, unmount and run xfs_repair.\");\n\t\t} else {\n\t\t\tASSERT(xfs_is_shutdown(mp));\n\t\t}\n\t\treturn error;\n\t}\n\n\t \n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_ifree(tp, ip);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (error) {\n\t\t \n\t\tif (!xfs_is_shutdown(mp)) {\n\t\t\txfs_notice(mp, \"%s: xfs_ifree returned error %d\",\n\t\t\t\t__func__, error);\n\t\t\txfs_force_shutdown(mp, SHUTDOWN_META_IO_ERROR);\n\t\t}\n\t\txfs_trans_cancel(tp);\n\t\treturn error;\n\t}\n\n\t \n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_ICOUNT, -1);\n\n\treturn xfs_trans_commit(tp);\n}\n\n \nbool\nxfs_inode_needs_inactive(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*cow_ifp = xfs_ifork_ptr(ip, XFS_COW_FORK);\n\n\t \n\tif (VFS_I(ip)->i_mode == 0)\n\t\treturn false;\n\n\t \n\tif (xfs_is_readonly(mp) && !xlog_recovery_needed(mp->m_log))\n\t\treturn false;\n\n\t \n\tif (xfs_is_shutdown(mp) || xfs_has_norecovery(mp))\n\t\treturn false;\n\n\t \n\tif (xfs_is_metadata_inode(ip))\n\t\treturn false;\n\n\t \n\tif (cow_ifp && cow_ifp->if_bytes > 0)\n\t\treturn true;\n\n\t \n\tif (VFS_I(ip)->i_nlink == 0)\n\t\treturn true;\n\n\t \n\treturn xfs_can_free_eofblocks(ip, true);\n}\n\n \nint\nxfs_inactive(\n\txfs_inode_t\t*ip)\n{\n\tstruct xfs_mount\t*mp;\n\tint\t\t\terror = 0;\n\tint\t\t\ttruncate = 0;\n\n\t \n\tif (VFS_I(ip)->i_mode == 0) {\n\t\tASSERT(ip->i_df.if_broot_bytes == 0);\n\t\tgoto out;\n\t}\n\n\tmp = ip->i_mount;\n\tASSERT(!xfs_iflags_test(ip, XFS_IRECOVERY));\n\n\t \n\tif (xfs_is_readonly(mp) && !xlog_recovery_needed(mp->m_log))\n\t\tgoto out;\n\n\t \n\tif (xfs_is_metadata_inode(ip))\n\t\tgoto out;\n\n\t \n\tif (xfs_inode_has_cow_data(ip))\n\t\txfs_reflink_cancel_cow_range(ip, 0, NULLFILEOFF, true);\n\n\tif (VFS_I(ip)->i_nlink != 0) {\n\t\t \n\t\tif (xfs_can_free_eofblocks(ip, true))\n\t\t\terror = xfs_free_eofblocks(ip);\n\n\t\tgoto out;\n\t}\n\n\tif (S_ISREG(VFS_I(ip)->i_mode) &&\n\t    (ip->i_disk_size != 0 || XFS_ISIZE(ip) != 0 ||\n\t     ip->i_df.if_nextents > 0 || ip->i_delayed_blks > 0))\n\t\ttruncate = 1;\n\n\tif (xfs_iflags_test(ip, XFS_IQUOTAUNCHECKED)) {\n\t\t \n\t\txfs_qm_dqdetach(ip);\n\t} else {\n\t\terror = xfs_qm_dqattach(ip);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (S_ISLNK(VFS_I(ip)->i_mode))\n\t\terror = xfs_inactive_symlink(ip);\n\telse if (truncate)\n\t\terror = xfs_inactive_truncate(ip);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tif (xfs_inode_has_attr_fork(ip)) {\n\t\terror = xfs_attr_inactive(ip);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tASSERT(ip->i_forkoff == 0);\n\n\t \n\terror = xfs_inactive_ifree(ip);\n\nout:\n\t \n\txfs_qm_dqdetach(ip);\n\treturn error;\n}\n\n \n\n \nstatic struct xfs_inode *\nxfs_iunlink_lookup(\n\tstruct xfs_perag\t*pag,\n\txfs_agino_t\t\tagino)\n{\n\tstruct xfs_inode\t*ip;\n\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\tif (!ip) {\n\t\t \n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\n\t \n\tif (WARN_ON_ONCE(!ip->i_ino)) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tASSERT(!xfs_iflags_test(ip, XFS_IRECLAIMABLE | XFS_IRECLAIM));\n\trcu_read_unlock();\n\treturn ip;\n}\n\n \nstatic int\nxfs_iunlink_update_backref(\n\tstruct xfs_perag\t*pag,\n\txfs_agino_t\t\tprev_agino,\n\txfs_agino_t\t\tnext_agino)\n{\n\tstruct xfs_inode\t*ip;\n\n\t \n\tif (next_agino == NULLAGINO)\n\t\treturn 0;\n\n\tip = xfs_iunlink_lookup(pag, next_agino);\n\tif (!ip)\n\t\treturn -ENOLINK;\n\n\tip->i_prev_unlinked = prev_agino;\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_iunlink_update_bucket(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_buf\t\t*agibp,\n\tunsigned int\t\tbucket_index,\n\txfs_agino_t\t\tnew_agino)\n{\n\tstruct xfs_agi\t\t*agi = agibp->b_addr;\n\txfs_agino_t\t\told_value;\n\tint\t\t\toffset;\n\n\tASSERT(xfs_verify_agino_or_null(pag, new_agino));\n\n\told_value = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\ttrace_xfs_iunlink_update_bucket(tp->t_mountp, pag->pag_agno, bucket_index,\n\t\t\told_value, new_agino);\n\n\t \n\tif (old_value == new_agino) {\n\t\txfs_buf_mark_corrupt(agibp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tagi->agi_unlinked[bucket_index] = cpu_to_be32(new_agino);\n\toffset = offsetof(struct xfs_agi, agi_unlinked) +\n\t\t\t(sizeof(xfs_agino_t) * bucket_index);\n\txfs_trans_log_buf(tp, agibp, offset, offset + sizeof(xfs_agino_t) - 1);\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_iunlink_reload_next(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agibp,\n\txfs_agino_t\t\tprev_agino,\n\txfs_agino_t\t\tnext_agino)\n{\n\tstruct xfs_perag\t*pag = agibp->b_pag;\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\tstruct xfs_inode\t*next_ip = NULL;\n\txfs_ino_t\t\tino;\n\tint\t\t\terror;\n\n\tASSERT(next_agino != NULLAGINO);\n\n#ifdef DEBUG\n\trcu_read_lock();\n\tnext_ip = radix_tree_lookup(&pag->pag_ici_root, next_agino);\n\tASSERT(next_ip == NULL);\n\trcu_read_unlock();\n#endif\n\n\txfs_info_ratelimited(mp,\n \"Found unrecovered unlinked inode 0x%x in AG 0x%x.  Initiating recovery.\",\n\t\t\tnext_agino, pag->pag_agno);\n\n\t \n\tino = XFS_AGINO_TO_INO(mp, pag->pag_agno, next_agino);\n\terror = xfs_iget(mp, tp, ino, XFS_IGET_UNTRUSTED, 0, &next_ip);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (VFS_I(next_ip)->i_nlink != 0) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto rele;\n\t}\n\n\tnext_ip->i_prev_unlinked = prev_agino;\n\ttrace_xfs_iunlink_reload_next(next_ip);\nrele:\n\tASSERT(!(VFS_I(next_ip)->i_state & I_DONTCACHE));\n\tif (xfs_is_quotacheck_running(mp) && next_ip)\n\t\txfs_iflags_set(next_ip, XFS_IQUOTAUNCHECKED);\n\txfs_irele(next_ip);\n\treturn error;\n}\n\nstatic int\nxfs_iunlink_insert_inode(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_buf\t\t*agibp,\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_agi\t\t*agi = agibp->b_addr;\n\txfs_agino_t\t\tnext_agino;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\tshort\t\t\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tint\t\t\terror;\n\n\t \n\tnext_agino = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\tif (next_agino == agino ||\n\t    !xfs_verify_agino_or_null(pag, next_agino)) {\n\t\txfs_buf_mark_corrupt(agibp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\terror = xfs_iunlink_update_backref(pag, agino, next_agino);\n\tif (error == -ENOLINK)\n\t\terror = xfs_iunlink_reload_next(tp, agibp, agino, next_agino);\n\tif (error)\n\t\treturn error;\n\n\tif (next_agino != NULLAGINO) {\n\t\t \n\t\terror = xfs_iunlink_log_inode(tp, ip, pag, next_agino);\n\t\tif (error)\n\t\t\treturn error;\n\t\tip->i_next_unlinked = next_agino;\n\t}\n\n\t \n\tip->i_prev_unlinked = NULLAGINO;\n\treturn xfs_iunlink_update_bucket(tp, pag, agibp, bucket_index, agino);\n}\n\n \nSTATIC int\nxfs_iunlink(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_perag\t*pag;\n\tstruct xfs_buf\t\t*agibp;\n\tint\t\t\terror;\n\n\tASSERT(VFS_I(ip)->i_nlink == 0);\n\tASSERT(VFS_I(ip)->i_mode != 0);\n\ttrace_xfs_iunlink(ip);\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\n\t \n\terror = xfs_read_agi(pag, tp, &agibp);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_iunlink_insert_inode(tp, pag, agibp, ip);\nout:\n\txfs_perag_put(pag);\n\treturn error;\n}\n\nstatic int\nxfs_iunlink_remove_inode(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_buf\t\t*agibp,\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_agi\t\t*agi = agibp->b_addr;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\txfs_agino_t\t\thead_agino;\n\tshort\t\t\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tint\t\t\terror;\n\n\ttrace_xfs_iunlink_remove(ip);\n\n\t \n\thead_agino = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\tif (!xfs_verify_agino(pag, head_agino)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\tagi, sizeof(*agi));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\terror = xfs_iunlink_log_inode(tp, ip, pag, NULLAGINO);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = xfs_iunlink_update_backref(pag, ip->i_prev_unlinked,\n\t\t\tip->i_next_unlinked);\n\tif (error == -ENOLINK)\n\t\terror = xfs_iunlink_reload_next(tp, agibp, ip->i_prev_unlinked,\n\t\t\t\tip->i_next_unlinked);\n\tif (error)\n\t\treturn error;\n\n\tif (head_agino != agino) {\n\t\tstruct xfs_inode\t*prev_ip;\n\n\t\tprev_ip = xfs_iunlink_lookup(pag, ip->i_prev_unlinked);\n\t\tif (!prev_ip)\n\t\t\treturn -EFSCORRUPTED;\n\n\t\terror = xfs_iunlink_log_inode(tp, prev_ip, pag,\n\t\t\t\tip->i_next_unlinked);\n\t\tprev_ip->i_next_unlinked = ip->i_next_unlinked;\n\t} else {\n\t\t \n\t\terror = xfs_iunlink_update_bucket(tp, pag, agibp, bucket_index,\n\t\t\t\tip->i_next_unlinked);\n\t}\n\n\tip->i_next_unlinked = NULLAGINO;\n\tip->i_prev_unlinked = 0;\n\treturn error;\n}\n\n \nSTATIC int\nxfs_iunlink_remove(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_buf\t\t*agibp;\n\tint\t\t\terror;\n\n\ttrace_xfs_iunlink_remove(ip);\n\n\t \n\terror = xfs_read_agi(pag, tp, &agibp);\n\tif (error)\n\t\treturn error;\n\n\treturn xfs_iunlink_remove_inode(tp, pag, agibp, ip);\n}\n\n \nstatic void\nxfs_ifree_mark_inode_stale(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_inode\t*free_ip,\n\txfs_ino_t\t\tinum)\n{\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\tstruct xfs_inode_log_item *iip;\n\tstruct xfs_inode\t*ip;\n\nretry:\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, XFS_INO_TO_AGINO(mp, inum));\n\n\t \n\tif (!ip) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t \n\tspin_lock(&ip->i_flags_lock);\n\tif (ip->i_ino != inum || __xfs_iflags_test(ip, XFS_ISTALE))\n\t\tgoto out_iflags_unlock;\n\n\t \n\tif (ip != free_ip) {\n\t\tif (!xfs_ilock_nowait(ip, XFS_ILOCK_EXCL)) {\n\t\t\tspin_unlock(&ip->i_flags_lock);\n\t\t\trcu_read_unlock();\n\t\t\tdelay(1);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tip->i_flags |= XFS_ISTALE;\n\n\t \n\tiip = ip->i_itemp;\n\tif (__xfs_iflags_test(ip, XFS_IFLUSHING)) {\n\t\tASSERT(!list_empty(&iip->ili_item.li_bio_list));\n\t\tASSERT(iip->ili_last_fields);\n\t\tgoto out_iunlock;\n\t}\n\n\t \n\tif (!iip || list_empty(&iip->ili_item.li_bio_list))\n\t\tgoto out_iunlock;\n\n\t__xfs_iflags_set(ip, XFS_IFLUSHING);\n\tspin_unlock(&ip->i_flags_lock);\n\trcu_read_unlock();\n\n\t \n\tspin_lock(&iip->ili_lock);\n\tiip->ili_last_fields = iip->ili_fields;\n\tiip->ili_fields = 0;\n\tiip->ili_fsync_fields = 0;\n\tspin_unlock(&iip->ili_lock);\n\tASSERT(iip->ili_last_fields);\n\n\tif (ip != free_ip)\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn;\n\nout_iunlock:\n\tif (ip != free_ip)\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\nout_iflags_unlock:\n\tspin_unlock(&ip->i_flags_lock);\n\trcu_read_unlock();\n}\n\n \nstatic int\nxfs_ifree_cluster(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_inode\t*free_ip,\n\tstruct xfs_icluster\t*xic)\n{\n\tstruct xfs_mount\t*mp = free_ip->i_mount;\n\tstruct xfs_ino_geometry\t*igeo = M_IGEO(mp);\n\tstruct xfs_buf\t\t*bp;\n\txfs_daddr_t\t\tblkno;\n\txfs_ino_t\t\tinum = xic->first_ino;\n\tint\t\t\tnbufs;\n\tint\t\t\ti, j;\n\tint\t\t\tioffset;\n\tint\t\t\terror;\n\n\tnbufs = igeo->ialloc_blks / igeo->blocks_per_cluster;\n\n\tfor (j = 0; j < nbufs; j++, inum += igeo->inodes_per_cluster) {\n\t\t \n\t\tioffset = inum - xic->first_ino;\n\t\tif ((xic->alloc & XFS_INOBT_MASK(ioffset)) == 0) {\n\t\t\tASSERT(ioffset % igeo->inodes_per_cluster == 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tblkno = XFS_AGB_TO_DADDR(mp, XFS_INO_TO_AGNO(mp, inum),\n\t\t\t\t\t XFS_INO_TO_AGBNO(mp, inum));\n\n\t\t \n\t\terror = xfs_trans_get_buf(tp, mp->m_ddev_targp, blkno,\n\t\t\t\tmp->m_bsize * igeo->blocks_per_cluster,\n\t\t\t\tXBF_UNMAPPED, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tbp->b_ops = &xfs_inode_buf_ops;\n\n\t\t \n\t\tfor (i = 0; i < igeo->inodes_per_cluster; i++)\n\t\t\txfs_ifree_mark_inode_stale(pag, free_ip, inum + i);\n\n\t\txfs_trans_stale_inode_buf(tp, bp);\n\t\txfs_trans_binval(tp, bp);\n\t}\n\treturn 0;\n}\n\n \nint\nxfs_ifree(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_perag\t*pag;\n\tstruct xfs_icluster\txic = { 0 };\n\tstruct xfs_inode_log_item *iip = ip->i_itemp;\n\tint\t\t\terror;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(VFS_I(ip)->i_nlink == 0);\n\tASSERT(ip->i_df.if_nextents == 0);\n\tASSERT(ip->i_disk_size == 0 || !S_ISREG(VFS_I(ip)->i_mode));\n\tASSERT(ip->i_nblocks == 0);\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\n\t \n\terror = xfs_difree(tp, pag, ip->i_ino, &xic);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_iunlink_remove(tp, pag, ip);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tif (ip->i_df.if_format == XFS_DINODE_FMT_LOCAL) {\n\t\tkmem_free(ip->i_df.if_u1.if_data);\n\t\tip->i_df.if_u1.if_data = NULL;\n\t\tip->i_df.if_bytes = 0;\n\t}\n\n\tVFS_I(ip)->i_mode = 0;\t\t \n\tip->i_diflags = 0;\n\tip->i_diflags2 = mp->m_ino_geo.new_diflags2;\n\tip->i_forkoff = 0;\t\t \n\tip->i_df.if_format = XFS_DINODE_FMT_EXTENTS;\n\tif (xfs_iflags_test(ip, XFS_IPRESERVE_DM_FIELDS))\n\t\txfs_iflags_clear(ip, XFS_IPRESERVE_DM_FIELDS);\n\n\t \n\tspin_lock(&iip->ili_lock);\n\tiip->ili_fields &= ~(XFS_ILOG_AOWNER | XFS_ILOG_DOWNER);\n\tspin_unlock(&iip->ili_lock);\n\n\t \n\tVFS_I(ip)->i_generation++;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (xic.deleted)\n\t\terror = xfs_ifree_cluster(tp, pag, ip, &xic);\nout:\n\txfs_perag_put(pag);\n\treturn error;\n}\n\n \nstatic void\nxfs_iunpin(\n\tstruct xfs_inode\t*ip)\n{\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\n\ttrace_xfs_inode_unpin_nowait(ip, _RET_IP_);\n\n\t \n\txfs_log_force_seq(ip->i_mount, ip->i_itemp->ili_commit_seq, 0, NULL);\n\n}\n\nstatic void\n__xfs_iunpin_wait(\n\tstruct xfs_inode\t*ip)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&ip->i_flags, __XFS_IPINNED_BIT);\n\tDEFINE_WAIT_BIT(wait, &ip->i_flags, __XFS_IPINNED_BIT);\n\n\txfs_iunpin(ip);\n\n\tdo {\n\t\tprepare_to_wait(wq, &wait.wq_entry, TASK_UNINTERRUPTIBLE);\n\t\tif (xfs_ipincount(ip))\n\t\t\tio_schedule();\n\t} while (xfs_ipincount(ip));\n\tfinish_wait(wq, &wait.wq_entry);\n}\n\nvoid\nxfs_iunpin_wait(\n\tstruct xfs_inode\t*ip)\n{\n\tif (xfs_ipincount(ip))\n\t\t__xfs_iunpin_wait(ip);\n}\n\n \nint\nxfs_remove(\n\txfs_inode_t             *dp,\n\tstruct xfs_name\t\t*name,\n\txfs_inode_t\t\t*ip)\n{\n\txfs_mount_t\t\t*mp = dp->i_mount;\n\txfs_trans_t             *tp = NULL;\n\tint\t\t\tis_dir = S_ISDIR(VFS_I(ip)->i_mode);\n\tint\t\t\tdontcare;\n\tint                     error = 0;\n\tuint\t\t\tresblks;\n\n\ttrace_xfs_remove(dp, name);\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(dp);\n\tif (error)\n\t\tgoto std_return;\n\n\terror = xfs_qm_dqattach(ip);\n\tif (error)\n\t\tgoto std_return;\n\n\t \n\tresblks = XFS_REMOVE_SPACE_RES(mp);\n\terror = xfs_trans_alloc_dir(dp, &M_RES(mp)->tr_remove, ip, &resblks,\n\t\t\t&tp, &dontcare);\n\tif (error) {\n\t\tASSERT(error != -ENOSPC);\n\t\tgoto std_return;\n\t}\n\n\t \n\tif (is_dir) {\n\t\tASSERT(VFS_I(ip)->i_nlink >= 2);\n\t\tif (VFS_I(ip)->i_nlink != 2) {\n\t\t\terror = -ENOTEMPTY;\n\t\t\tgoto out_trans_cancel;\n\t\t}\n\t\tif (!xfs_dir_isempty(ip)) {\n\t\t\terror = -ENOTEMPTY;\n\t\t\tgoto out_trans_cancel;\n\t\t}\n\n\t\t \n\t\terror = xfs_droplink(tp, dp);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\t \n\t\terror = xfs_droplink(tp, ip);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\t \n\t\tif (dp->i_ino != tp->t_mountp->m_sb.sb_rootino) {\n\t\t\terror = xfs_dir_replace(tp, ip, &xfs_name_dotdot,\n\t\t\t\t\ttp->t_mountp->m_sb.sb_rootino, 0);\n\t\t\tif (error)\n\t\t\t\tgoto out_trans_cancel;\n\t\t}\n\t} else {\n\t\t \n\t\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\t}\n\txfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\n\t \n\terror = xfs_droplink(tp, ip);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\terror = xfs_dir_removename(tp, dp, name, ip->i_ino, resblks);\n\tif (error) {\n\t\tASSERT(error != -ENOENT);\n\t\tgoto out_trans_cancel;\n\t}\n\n\t \n\tif (xfs_has_wsync(mp) || xfs_has_dirsync(mp))\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp);\n\tif (error)\n\t\tgoto std_return;\n\n\tif (is_dir && xfs_inode_is_filestream(ip))\n\t\txfs_filestream_deassociate(ip);\n\n\treturn 0;\n\n out_trans_cancel:\n\txfs_trans_cancel(tp);\n std_return:\n\treturn error;\n}\n\n \n#define __XFS_SORT_INODES\t5\nSTATIC void\nxfs_sort_for_rename(\n\tstruct xfs_inode\t*dp1,\t \n\tstruct xfs_inode\t*dp2,\t \n\tstruct xfs_inode\t*ip1,\t \n\tstruct xfs_inode\t*ip2,\t \n\tstruct xfs_inode\t*wip,\t \n\tstruct xfs_inode\t**i_tab, \n\tint\t\t\t*num_inodes)   \n{\n\tint\t\t\ti, j;\n\n\tASSERT(*num_inodes == __XFS_SORT_INODES);\n\tmemset(i_tab, 0, *num_inodes * sizeof(struct xfs_inode *));\n\n\t \n\ti = 0;\n\ti_tab[i++] = dp1;\n\ti_tab[i++] = dp2;\n\ti_tab[i++] = ip1;\n\tif (ip2)\n\t\ti_tab[i++] = ip2;\n\tif (wip)\n\t\ti_tab[i++] = wip;\n\t*num_inodes = i;\n\n\t \n\tfor (i = 0; i < *num_inodes; i++) {\n\t\tfor (j = 1; j < *num_inodes; j++) {\n\t\t\tif (i_tab[j]->i_ino < i_tab[j-1]->i_ino) {\n\t\t\t\tstruct xfs_inode *temp = i_tab[j];\n\t\t\t\ti_tab[j] = i_tab[j-1];\n\t\t\t\ti_tab[j-1] = temp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int\nxfs_finish_rename(\n\tstruct xfs_trans\t*tp)\n{\n\t \n\tif (xfs_has_wsync(tp->t_mountp) || xfs_has_dirsync(tp->t_mountp))\n\t\txfs_trans_set_sync(tp);\n\n\treturn xfs_trans_commit(tp);\n}\n\n \nSTATIC int\nxfs_cross_rename(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp1,\n\tstruct xfs_name\t\t*name1,\n\tstruct xfs_inode\t*ip1,\n\tstruct xfs_inode\t*dp2,\n\tstruct xfs_name\t\t*name2,\n\tstruct xfs_inode\t*ip2,\n\tint\t\t\tspaceres)\n{\n\tint\t\terror = 0;\n\tint\t\tip1_flags = 0;\n\tint\t\tip2_flags = 0;\n\tint\t\tdp2_flags = 0;\n\n\t \n\terror = xfs_dir_replace(tp, dp1, name1, ip2->i_ino, spaceres);\n\tif (error)\n\t\tgoto out_trans_abort;\n\n\t \n\terror = xfs_dir_replace(tp, dp2, name2, ip1->i_ino, spaceres);\n\tif (error)\n\t\tgoto out_trans_abort;\n\n\t \n\tif (dp1 != dp2) {\n\t\tdp2_flags = XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;\n\n\t\tif (S_ISDIR(VFS_I(ip2)->i_mode)) {\n\t\t\terror = xfs_dir_replace(tp, ip2, &xfs_name_dotdot,\n\t\t\t\t\t\tdp1->i_ino, spaceres);\n\t\t\tif (error)\n\t\t\t\tgoto out_trans_abort;\n\n\t\t\t \n\t\t\tif (!S_ISDIR(VFS_I(ip1)->i_mode)) {\n\t\t\t\terror = xfs_droplink(tp, dp2);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out_trans_abort;\n\t\t\t\txfs_bumplink(tp, dp1);\n\t\t\t}\n\n\t\t\t \n\t\t\tip1_flags |= XFS_ICHGTIME_CHG;\n\t\t\tip2_flags |= XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;\n\t\t}\n\n\t\tif (S_ISDIR(VFS_I(ip1)->i_mode)) {\n\t\t\terror = xfs_dir_replace(tp, ip1, &xfs_name_dotdot,\n\t\t\t\t\t\tdp2->i_ino, spaceres);\n\t\t\tif (error)\n\t\t\t\tgoto out_trans_abort;\n\n\t\t\t \n\t\t\tif (!S_ISDIR(VFS_I(ip2)->i_mode)) {\n\t\t\t\terror = xfs_droplink(tp, dp1);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out_trans_abort;\n\t\t\t\txfs_bumplink(tp, dp2);\n\t\t\t}\n\n\t\t\t \n\t\t\tip1_flags |= XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;\n\t\t\tip2_flags |= XFS_ICHGTIME_CHG;\n\t\t}\n\t}\n\n\tif (ip1_flags) {\n\t\txfs_trans_ichgtime(tp, ip1, ip1_flags);\n\t\txfs_trans_log_inode(tp, ip1, XFS_ILOG_CORE);\n\t}\n\tif (ip2_flags) {\n\t\txfs_trans_ichgtime(tp, ip2, ip2_flags);\n\t\txfs_trans_log_inode(tp, ip2, XFS_ILOG_CORE);\n\t}\n\tif (dp2_flags) {\n\t\txfs_trans_ichgtime(tp, dp2, dp2_flags);\n\t\txfs_trans_log_inode(tp, dp2, XFS_ILOG_CORE);\n\t}\n\txfs_trans_ichgtime(tp, dp1, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, dp1, XFS_ILOG_CORE);\n\treturn xfs_finish_rename(tp);\n\nout_trans_abort:\n\txfs_trans_cancel(tp);\n\treturn error;\n}\n\n \nstatic int\nxfs_rename_alloc_whiteout(\n\tstruct mnt_idmap\t*idmap,\n\tstruct xfs_name\t\t*src_name,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_inode\t**wip)\n{\n\tstruct xfs_inode\t*tmpfile;\n\tstruct qstr\t\tname;\n\tint\t\t\terror;\n\n\terror = xfs_create_tmpfile(idmap, dp, S_IFCHR | WHITEOUT_MODE,\n\t\t\t\t   &tmpfile);\n\tif (error)\n\t\treturn error;\n\n\tname.name = src_name->name;\n\tname.len = src_name->len;\n\terror = xfs_inode_init_security(VFS_I(tmpfile), VFS_I(dp), &name);\n\tif (error) {\n\t\txfs_finish_inode_setup(tmpfile);\n\t\txfs_irele(tmpfile);\n\t\treturn error;\n\t}\n\n\t \n\txfs_setup_iops(tmpfile);\n\txfs_finish_inode_setup(tmpfile);\n\tVFS_I(tmpfile)->i_state |= I_LINKABLE;\n\n\t*wip = tmpfile;\n\treturn 0;\n}\n\n \nint\nxfs_rename(\n\tstruct mnt_idmap\t*idmap,\n\tstruct xfs_inode\t*src_dp,\n\tstruct xfs_name\t\t*src_name,\n\tstruct xfs_inode\t*src_ip,\n\tstruct xfs_inode\t*target_dp,\n\tstruct xfs_name\t\t*target_name,\n\tstruct xfs_inode\t*target_ip,\n\tunsigned int\t\tflags)\n{\n\tstruct xfs_mount\t*mp = src_dp->i_mount;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_inode\t*wip = NULL;\t\t \n\tstruct xfs_inode\t*inodes[__XFS_SORT_INODES];\n\tint\t\t\ti;\n\tint\t\t\tnum_inodes = __XFS_SORT_INODES;\n\tbool\t\t\tnew_parent = (src_dp != target_dp);\n\tbool\t\t\tsrc_is_directory = S_ISDIR(VFS_I(src_ip)->i_mode);\n\tint\t\t\tspaceres;\n\tbool\t\t\tretried = false;\n\tint\t\t\terror, nospace_error = 0;\n\n\ttrace_xfs_rename(src_dp, target_dp, src_name, target_name);\n\n\tif ((flags & RENAME_EXCHANGE) && !target_ip)\n\t\treturn -EINVAL;\n\n\t \n\tif (flags & RENAME_WHITEOUT) {\n\t\terror = xfs_rename_alloc_whiteout(idmap, src_name,\n\t\t\t\t\t\t  target_dp, &wip);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tsrc_name->type = XFS_DIR3_FT_CHRDEV;\n\t}\n\n\txfs_sort_for_rename(src_dp, target_dp, src_ip, target_ip, wip,\n\t\t\t\tinodes, &num_inodes);\n\nretry:\n\tnospace_error = 0;\n\tspaceres = XFS_RENAME_SPACE_RES(mp, target_name->len);\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_rename, spaceres, 0, 0, &tp);\n\tif (error == -ENOSPC) {\n\t\tnospace_error = error;\n\t\tspaceres = 0;\n\t\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_rename, 0, 0, 0,\n\t\t\t\t&tp);\n\t}\n\tif (error)\n\t\tgoto out_release_wip;\n\n\t \n\terror = xfs_qm_vop_rename_dqattach(inodes);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\t \n\txfs_lock_inodes(inodes, num_inodes, XFS_ILOCK_EXCL);\n\n\t \n\txfs_trans_ijoin(tp, src_dp, XFS_ILOCK_EXCL);\n\tif (new_parent)\n\t\txfs_trans_ijoin(tp, target_dp, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, src_ip, XFS_ILOCK_EXCL);\n\tif (target_ip)\n\t\txfs_trans_ijoin(tp, target_ip, XFS_ILOCK_EXCL);\n\tif (wip)\n\t\txfs_trans_ijoin(tp, wip, XFS_ILOCK_EXCL);\n\n\t \n\tif (unlikely((target_dp->i_diflags & XFS_DIFLAG_PROJINHERIT) &&\n\t\t     target_dp->i_projid != src_ip->i_projid)) {\n\t\terror = -EXDEV;\n\t\tgoto out_trans_cancel;\n\t}\n\n\t \n\tif (flags & RENAME_EXCHANGE)\n\t\treturn xfs_cross_rename(tp, src_dp, src_name, src_ip,\n\t\t\t\t\ttarget_dp, target_name, target_ip,\n\t\t\t\t\tspaceres);\n\n\t \n\tif (spaceres != 0) {\n\t\terror = xfs_trans_reserve_quota_nblks(tp, target_dp, spaceres,\n\t\t\t\t0, false);\n\t\tif (error == -EDQUOT || error == -ENOSPC) {\n\t\t\tif (!retried) {\n\t\t\t\txfs_trans_cancel(tp);\n\t\t\t\txfs_blockgc_free_quota(target_dp, 0);\n\t\t\t\tretried = true;\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tnospace_error = error;\n\t\t\tspaceres = 0;\n\t\t\terror = 0;\n\t\t}\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\t \n\tif (target_ip == NULL) {\n\t\t \n\t\tif (!spaceres) {\n\t\t\terror = xfs_dir_canenter(tp, target_dp, target_name);\n\t\t\tif (error)\n\t\t\t\tgoto out_trans_cancel;\n\t\t}\n\t} else {\n\t\t \n\t\tif (S_ISDIR(VFS_I(target_ip)->i_mode) &&\n\t\t    (!xfs_dir_isempty(target_ip) ||\n\t\t     (VFS_I(target_ip)->i_nlink > 2))) {\n\t\t\terror = -EEXIST;\n\t\t\tgoto out_trans_cancel;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < num_inodes && inodes[i] != NULL; i++) {\n\t\tif (inodes[i] == wip ||\n\t\t    (inodes[i] == target_ip &&\n\t\t     (VFS_I(target_ip)->i_nlink == 1 || src_is_directory))) {\n\t\t\tstruct xfs_perag\t*pag;\n\t\t\tstruct xfs_buf\t\t*bp;\n\n\t\t\tpag = xfs_perag_get(mp,\n\t\t\t\t\tXFS_INO_TO_AGNO(mp, inodes[i]->i_ino));\n\t\t\terror = xfs_read_agi(pag, tp, &bp);\n\t\t\txfs_perag_put(pag);\n\t\t\tif (error)\n\t\t\t\tgoto out_trans_cancel;\n\t\t}\n\t}\n\n\t \n\tif (wip) {\n\t\tstruct xfs_perag\t*pag;\n\n\t\tASSERT(VFS_I(wip)->i_nlink == 0);\n\n\t\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, wip->i_ino));\n\t\terror = xfs_iunlink_remove(tp, pag, wip);\n\t\txfs_perag_put(pag);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\txfs_bumplink(tp, wip);\n\t\tVFS_I(wip)->i_state &= ~I_LINKABLE;\n\t}\n\n\t \n\tif (target_ip == NULL) {\n\t\t \n\t\terror = xfs_dir_createname(tp, target_dp, target_name,\n\t\t\t\t\t   src_ip->i_ino, spaceres);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\txfs_trans_ichgtime(tp, target_dp,\n\t\t\t\t\tXFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\n\t\tif (new_parent && src_is_directory) {\n\t\t\txfs_bumplink(tp, target_dp);\n\t\t}\n\t} else {  \n\t\t \n\t\terror = xfs_dir_replace(tp, target_dp, target_name,\n\t\t\t\t\tsrc_ip->i_ino, spaceres);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\txfs_trans_ichgtime(tp, target_dp,\n\t\t\t\t\tXFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\n\t\t \n\t\terror = xfs_droplink(tp, target_ip);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\tif (src_is_directory) {\n\t\t\t \n\t\t\terror = xfs_droplink(tp, target_ip);\n\t\t\tif (error)\n\t\t\t\tgoto out_trans_cancel;\n\t\t}\n\t}  \n\n\t \n\tif (new_parent && src_is_directory) {\n\t\t \n\t\terror = xfs_dir_replace(tp, src_ip, &xfs_name_dotdot,\n\t\t\t\t\ttarget_dp->i_ino, spaceres);\n\t\tASSERT(error != -EEXIST);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\t \n\txfs_trans_ichgtime(tp, src_ip, XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, src_ip, XFS_ILOG_CORE);\n\n\t \n\tif (src_is_directory && (new_parent || target_ip != NULL)) {\n\n\t\t \n\t\terror = xfs_droplink(tp, src_dp);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\t \n\tif (wip)\n\t\terror = xfs_dir_replace(tp, src_dp, src_name, wip->i_ino,\n\t\t\t\t\tspaceres);\n\telse\n\t\terror = xfs_dir_removename(tp, src_dp, src_name, src_ip->i_ino,\n\t\t\t\t\t   spaceres);\n\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\txfs_trans_ichgtime(tp, src_dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, src_dp, XFS_ILOG_CORE);\n\tif (new_parent)\n\t\txfs_trans_log_inode(tp, target_dp, XFS_ILOG_CORE);\n\n\terror = xfs_finish_rename(tp);\n\tif (wip)\n\t\txfs_irele(wip);\n\treturn error;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp);\nout_release_wip:\n\tif (wip)\n\t\txfs_irele(wip);\n\tif (error == -ENOSPC && nospace_error)\n\t\terror = nospace_error;\n\treturn error;\n}\n\nstatic int\nxfs_iflush(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_inode_log_item *iip = ip->i_itemp;\n\tstruct xfs_dinode\t*dip;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\terror;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(xfs_iflags_test(ip, XFS_IFLUSHING));\n\tASSERT(ip->i_df.if_format != XFS_DINODE_FMT_BTREE ||\n\t       ip->i_df.if_nextents > XFS_IFORK_MAXEXT(ip, XFS_DATA_FORK));\n\tASSERT(iip->ili_item.li_buf == bp);\n\n\tdip = xfs_buf_offset(bp, ip->i_imap.im_boffset);\n\n\t \n\terror = -EFSCORRUPTED;\n\tif (XFS_TEST_ERROR(dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC),\n\t\t\t       mp, XFS_ERRTAG_IFLUSH_1)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: Bad inode %llu magic number 0x%x, ptr \"PTR_FMT,\n\t\t\t__func__, ip->i_ino, be16_to_cpu(dip->di_magic), dip);\n\t\tgoto flush_out;\n\t}\n\tif (S_ISREG(VFS_I(ip)->i_mode)) {\n\t\tif (XFS_TEST_ERROR(\n\t\t    ip->i_df.if_format != XFS_DINODE_FMT_EXTENTS &&\n\t\t    ip->i_df.if_format != XFS_DINODE_FMT_BTREE,\n\t\t    mp, XFS_ERRTAG_IFLUSH_3)) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\t\"%s: Bad regular inode %llu, ptr \"PTR_FMT,\n\t\t\t\t__func__, ip->i_ino, ip);\n\t\t\tgoto flush_out;\n\t\t}\n\t} else if (S_ISDIR(VFS_I(ip)->i_mode)) {\n\t\tif (XFS_TEST_ERROR(\n\t\t    ip->i_df.if_format != XFS_DINODE_FMT_EXTENTS &&\n\t\t    ip->i_df.if_format != XFS_DINODE_FMT_BTREE &&\n\t\t    ip->i_df.if_format != XFS_DINODE_FMT_LOCAL,\n\t\t    mp, XFS_ERRTAG_IFLUSH_4)) {\n\t\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\t\"%s: Bad directory inode %llu, ptr \"PTR_FMT,\n\t\t\t\t__func__, ip->i_ino, ip);\n\t\t\tgoto flush_out;\n\t\t}\n\t}\n\tif (XFS_TEST_ERROR(ip->i_df.if_nextents + xfs_ifork_nextents(&ip->i_af) >\n\t\t\t\tip->i_nblocks, mp, XFS_ERRTAG_IFLUSH_5)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: detected corrupt incore inode %llu, \"\n\t\t\t\"total extents = %llu nblocks = %lld, ptr \"PTR_FMT,\n\t\t\t__func__, ip->i_ino,\n\t\t\tip->i_df.if_nextents + xfs_ifork_nextents(&ip->i_af),\n\t\t\tip->i_nblocks, ip);\n\t\tgoto flush_out;\n\t}\n\tif (XFS_TEST_ERROR(ip->i_forkoff > mp->m_sb.sb_inodesize,\n\t\t\t\tmp, XFS_ERRTAG_IFLUSH_6)) {\n\t\txfs_alert_tag(mp, XFS_PTAG_IFLUSH,\n\t\t\t\"%s: bad inode %llu, forkoff 0x%x, ptr \"PTR_FMT,\n\t\t\t__func__, ip->i_ino, ip->i_forkoff, ip);\n\t\tgoto flush_out;\n\t}\n\n\t \n\tif (!xfs_has_v3inodes(mp))\n\t\tip->i_flushiter++;\n\n\t \n\tif (ip->i_df.if_format == XFS_DINODE_FMT_LOCAL &&\n\t    xfs_ifork_verify_local_data(ip))\n\t\tgoto flush_out;\n\tif (xfs_inode_has_attr_fork(ip) &&\n\t    ip->i_af.if_format == XFS_DINODE_FMT_LOCAL &&\n\t    xfs_ifork_verify_local_attr(ip))\n\t\tgoto flush_out;\n\n\t \n\txfs_inode_to_disk(ip, dip, iip->ili_item.li_lsn);\n\n\t \n\tif (!xfs_has_v3inodes(mp)) {\n\t\tif (ip->i_flushiter == DI_MAX_FLUSH)\n\t\t\tip->i_flushiter = 0;\n\t}\n\n\txfs_iflush_fork(ip, dip, iip, XFS_DATA_FORK);\n\tif (xfs_inode_has_attr_fork(ip))\n\t\txfs_iflush_fork(ip, dip, iip, XFS_ATTR_FORK);\n\n\t \n\terror = 0;\nflush_out:\n\tspin_lock(&iip->ili_lock);\n\tiip->ili_last_fields = iip->ili_fields;\n\tiip->ili_fields = 0;\n\tiip->ili_fsync_fields = 0;\n\tspin_unlock(&iip->ili_lock);\n\n\t \n\txfs_trans_ail_copy_lsn(mp->m_ail, &iip->ili_flush_lsn,\n\t\t\t\t&iip->ili_item.li_lsn);\n\n\t \n\txfs_dinode_calc_crc(mp, dip);\n\treturn error;\n}\n\n \nint\nxfs_iflush_cluster(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_log_item\t*lip, *n;\n\tstruct xfs_inode\t*ip;\n\tstruct xfs_inode_log_item *iip;\n\tint\t\t\tclcount = 0;\n\tint\t\t\terror = 0;\n\n\t \n\tlist_for_each_entry_safe(lip, n, &bp->b_li_list, li_bio_list) {\n\t\tiip = (struct xfs_inode_log_item *)lip;\n\t\tip = iip->ili_inode;\n\n\t\t \n\t\tif (__xfs_iflags_test(ip, XFS_IRECLAIM | XFS_IFLUSHING))\n\t\t\tcontinue;\n\t\tif (xfs_ipincount(ip))\n\t\t\tcontinue;\n\n\t\t \n\t\tspin_lock(&ip->i_flags_lock);\n\t\tASSERT(!__xfs_iflags_test(ip, XFS_ISTALE));\n\t\tif (__xfs_iflags_test(ip, XFS_IRECLAIM | XFS_IFLUSHING)) {\n\t\t\tspin_unlock(&ip->i_flags_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!xfs_ilock_nowait(ip, XFS_ILOCK_SHARED)) {\n\t\t\tspin_unlock(&ip->i_flags_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__xfs_iflags_set(ip, XFS_IFLUSHING);\n\t\tspin_unlock(&ip->i_flags_lock);\n\n\t\t \n\t\tif (xlog_is_shutdown(mp->m_log)) {\n\t\t\txfs_iunpin_wait(ip);\n\t\t\txfs_iflush_abort(ip);\n\t\t\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\t\t\terror = -EIO;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (xfs_ipincount(ip)) {\n\t\t\txfs_iflags_clear(ip, XFS_IFLUSHING);\n\t\t\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!xfs_inode_clean(ip))\n\t\t\terror = xfs_iflush(ip, bp);\n\t\telse\n\t\t\txfs_iflags_clear(ip, XFS_IFLUSHING);\n\t\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\t\tif (error)\n\t\t\tbreak;\n\t\tclcount++;\n\t}\n\n\tif (error) {\n\t\t \n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\tbp->b_flags |= XBF_ASYNC;\n\t\txfs_buf_ioend_fail(bp);\n\t\treturn error;\n\t}\n\n\tif (!clcount)\n\t\treturn -EAGAIN;\n\n\tXFS_STATS_INC(mp, xs_icluster_flushcnt);\n\tXFS_STATS_ADD(mp, xs_icluster_flushinode, clcount);\n\treturn 0;\n\n}\n\n \nvoid\nxfs_irele(\n\tstruct xfs_inode\t*ip)\n{\n\ttrace_xfs_irele(ip, _RET_IP_);\n\tiput(VFS_I(ip));\n}\n\n \nint\nxfs_log_force_inode(\n\tstruct xfs_inode\t*ip)\n{\n\txfs_csn_t\t\tseq = 0;\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\tif (xfs_ipincount(ip))\n\t\tseq = ip->i_itemp->ili_commit_seq;\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (!seq)\n\t\treturn 0;\n\treturn xfs_log_force_seq(ip->i_mount, seq, XFS_LOG_SYNC, NULL);\n}\n\n \nstatic int\nxfs_iolock_two_inodes_and_break_layout(\n\tstruct inode\t\t*src,\n\tstruct inode\t\t*dest)\n{\n\tint\t\t\terror;\n\n\tif (src > dest)\n\t\tswap(src, dest);\n\nretry:\n\t \n\terror = break_layout(src, true);\n\tif (error)\n\t\treturn error;\n\tif (src != dest) {\n\t\terror = break_layout(dest, true);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\tinode_lock(src);\n\terror = break_layout(src, false);\n\tif (error) {\n\t\tinode_unlock(src);\n\t\tif (error == -EWOULDBLOCK)\n\t\t\tgoto retry;\n\t\treturn error;\n\t}\n\n\tif (src == dest)\n\t\treturn 0;\n\n\t \n\tinode_lock_nested(dest, I_MUTEX_NONDIR2);\n\terror = break_layout(dest, false);\n\tif (error) {\n\t\tinode_unlock(src);\n\t\tinode_unlock(dest);\n\t\tif (error == -EWOULDBLOCK)\n\t\t\tgoto retry;\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nxfs_mmaplock_two_inodes_and_break_dax_layout(\n\tstruct xfs_inode\t*ip1,\n\tstruct xfs_inode\t*ip2)\n{\n\tint\t\t\terror;\n\tbool\t\t\tretry;\n\tstruct page\t\t*page;\n\n\tif (ip1->i_ino > ip2->i_ino)\n\t\tswap(ip1, ip2);\n\nagain:\n\tretry = false;\n\t \n\txfs_ilock(ip1, XFS_MMAPLOCK_EXCL);\n\terror = xfs_break_dax_layouts(VFS_I(ip1), &retry);\n\tif (error || retry) {\n\t\txfs_iunlock(ip1, XFS_MMAPLOCK_EXCL);\n\t\tif (error == 0 && retry)\n\t\t\tgoto again;\n\t\treturn error;\n\t}\n\n\tif (ip1 == ip2)\n\t\treturn 0;\n\n\t \n\txfs_ilock(ip2, xfs_lock_inumorder(XFS_MMAPLOCK_EXCL, 1));\n\t \n\tpage = dax_layout_busy_page(VFS_I(ip2)->i_mapping);\n\tif (page && page_ref_count(page) != 1) {\n\t\txfs_iunlock(ip2, XFS_MMAPLOCK_EXCL);\n\t\txfs_iunlock(ip1, XFS_MMAPLOCK_EXCL);\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}\n\n \nint\nxfs_ilock2_io_mmap(\n\tstruct xfs_inode\t*ip1,\n\tstruct xfs_inode\t*ip2)\n{\n\tint\t\t\tret;\n\n\tret = xfs_iolock_two_inodes_and_break_layout(VFS_I(ip1), VFS_I(ip2));\n\tif (ret)\n\t\treturn ret;\n\n\tif (IS_DAX(VFS_I(ip1)) && IS_DAX(VFS_I(ip2))) {\n\t\tret = xfs_mmaplock_two_inodes_and_break_dax_layout(ip1, ip2);\n\t\tif (ret) {\n\t\t\tinode_unlock(VFS_I(ip2));\n\t\t\tif (ip1 != ip2)\n\t\t\t\tinode_unlock(VFS_I(ip1));\n\t\t\treturn ret;\n\t\t}\n\t} else\n\t\tfilemap_invalidate_lock_two(VFS_I(ip1)->i_mapping,\n\t\t\t\t\t    VFS_I(ip2)->i_mapping);\n\n\treturn 0;\n}\n\n \nvoid\nxfs_iunlock2_io_mmap(\n\tstruct xfs_inode\t*ip1,\n\tstruct xfs_inode\t*ip2)\n{\n\tif (IS_DAX(VFS_I(ip1)) && IS_DAX(VFS_I(ip2))) {\n\t\txfs_iunlock(ip2, XFS_MMAPLOCK_EXCL);\n\t\tif (ip1 != ip2)\n\t\t\txfs_iunlock(ip1, XFS_MMAPLOCK_EXCL);\n\t} else\n\t\tfilemap_invalidate_unlock_two(VFS_I(ip1)->i_mapping,\n\t\t\t\t\t      VFS_I(ip2)->i_mapping);\n\n\tinode_unlock(VFS_I(ip2));\n\tif (ip1 != ip2)\n\t\tinode_unlock(VFS_I(ip1));\n}\n\n \nint\nxfs_inode_reload_unlinked_bucket(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_buf\t\t*agibp;\n\tstruct xfs_agi\t\t*agi;\n\tstruct xfs_perag\t*pag;\n\txfs_agnumber_t\t\tagno = XFS_INO_TO_AGNO(mp, ip->i_ino);\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\txfs_agino_t\t\tprev_agino, next_agino;\n\tunsigned int\t\tbucket;\n\tbool\t\t\tfoundit = false;\n\tint\t\t\terror;\n\n\t \n\tpag = xfs_perag_get(mp, agno);\n\terror = xfs_ialloc_read_agi(pag, tp, &agibp);\n\txfs_perag_put(pag);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (!xfs_inode_unlinked_incomplete(ip)) {\n\t\tfoundit = true;\n\t\tgoto out_agibp;\n\t}\n\n\tbucket = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tagi = agibp->b_addr;\n\n\ttrace_xfs_inode_reload_unlinked_bucket(ip);\n\n\txfs_info_ratelimited(mp,\n \"Found unrecovered unlinked inode 0x%x in AG 0x%x.  Initiating list recovery.\",\n\t\t\tagino, agno);\n\n\tprev_agino = NULLAGINO;\n\tnext_agino = be32_to_cpu(agi->agi_unlinked[bucket]);\n\twhile (next_agino != NULLAGINO) {\n\t\tstruct xfs_inode\t*next_ip = NULL;\n\n\t\t \n\t\tif (next_agino == agino) {\n\t\t\tnext_ip = ip;\n\t\t\tnext_ip->i_prev_unlinked = prev_agino;\n\t\t\tfoundit = true;\n\t\t\tgoto next_inode;\n\t\t}\n\n\t\t \n\t\tnext_ip = xfs_iunlink_lookup(pag, next_agino);\n\t\tif (next_ip)\n\t\t\tgoto next_inode;\n\n\t\t \n\t\terror = xfs_iunlink_reload_next(tp, agibp, prev_agino,\n\t\t\t\tnext_agino);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\t \n\t\tnext_ip = xfs_iunlink_lookup(pag, next_agino);\n\t\tif (!next_ip) {\n\t\t\t \n\t\t\tASSERT(next_ip != NULL);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tbreak;\n\t\t}\n\nnext_inode:\n\t\tprev_agino = next_agino;\n\t\tnext_agino = next_ip->i_next_unlinked;\n\t}\n\nout_agibp:\n\txfs_trans_brelse(tp, agibp);\n\t \n\tif (!error && !foundit)\n\t\terror = -EFSCORRUPTED;\n\treturn error;\n}\n\n \nint\nxfs_inode_reload_unlinked(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\terror = xfs_trans_alloc_empty(ip->i_mount, &tp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\tif (xfs_inode_unlinked_incomplete(ip))\n\t\terror = xfs_inode_reload_unlinked_bucket(tp, ip);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\txfs_trans_cancel(tp);\n\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}