{
  "module_name": "xfs_attr_list.c",
  "hash_id": "ccfef8d5da885e720db63aeeda43b1973d7056f74b9d0c21f8ab5282f019f80e",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_attr_list.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_dir2.h\"\n\nSTATIC int\nxfs_attr_shortform_compare(const void *a, const void *b)\n{\n\txfs_attr_sf_sort_t *sa, *sb;\n\n\tsa = (xfs_attr_sf_sort_t *)a;\n\tsb = (xfs_attr_sf_sort_t *)b;\n\tif (sa->hash < sb->hash) {\n\t\treturn -1;\n\t} else if (sa->hash > sb->hash) {\n\t\treturn 1;\n\t} else {\n\t\treturn sa->entno - sb->entno;\n\t}\n}\n\n#define XFS_ISRESET_CURSOR(cursor) \\\n\t(!((cursor)->initted) && !((cursor)->hashval) && \\\n\t !((cursor)->blkno) && !((cursor)->offset))\n \nstatic int\nxfs_attr_shortform_list(\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct xfs_attrlist_cursor_kern\t*cursor = &context->cursor;\n\tstruct xfs_inode\t\t*dp = context->dp;\n\tstruct xfs_attr_sf_sort\t\t*sbuf, *sbp;\n\tstruct xfs_attr_shortform\t*sf;\n\tstruct xfs_attr_sf_entry\t*sfe;\n\tint\t\t\t\tsbsize, nsbuf, count, i;\n\tint\t\t\t\terror = 0;\n\n\tsf = (struct xfs_attr_shortform *)dp->i_af.if_u1.if_data;\n\tASSERT(sf != NULL);\n\tif (!sf->hdr.count)\n\t\treturn 0;\n\n\ttrace_xfs_attr_list_sf(context);\n\n\t \n\tif (context->bufsize == 0 ||\n\t    (XFS_ISRESET_CURSOR(cursor) &&\n\t     (dp->i_af.if_bytes + sf->hdr.count * 16) < context->bufsize)) {\n\t\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\t\tif (XFS_IS_CORRUPT(context->dp->i_mount,\n\t\t\t\t\t   !xfs_attr_namecheck(sfe->nameval,\n\t\t\t\t\t\t\t       sfe->namelen)))\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\tcontext->put_listent(context,\n\t\t\t\t\t     sfe->flags,\n\t\t\t\t\t     sfe->nameval,\n\t\t\t\t\t     (int)sfe->namelen,\n\t\t\t\t\t     (int)sfe->valuelen);\n\t\t\t \n\t\t\tif (context->seen_enough)\n\t\t\t\tbreak;\n\t\t\tsfe = xfs_attr_sf_nextentry(sfe);\n\t\t}\n\t\ttrace_xfs_attr_list_sf_all(context);\n\t\treturn 0;\n\t}\n\n\t \n\tif (context->bufsize == 0)\n\t\treturn 0;\n\n\t \n\tsbsize = sf->hdr.count * sizeof(*sbuf);\n\tsbp = sbuf = kmem_alloc(sbsize, KM_NOFS);\n\n\t \n\tnsbuf = 0;\n\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\tif (unlikely(\n\t\t    ((char *)sfe < (char *)sf) ||\n\t\t    ((char *)sfe >= ((char *)sf + dp->i_af.if_bytes)))) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_shortform_list\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     context->dp->i_mount, sfe,\n\t\t\t\t\t     sizeof(*sfe));\n\t\t\tkmem_free(sbuf);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tsbp->entno = i;\n\t\tsbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);\n\t\tsbp->name = sfe->nameval;\n\t\tsbp->namelen = sfe->namelen;\n\t\t \n\t\tsbp->valuelen = sfe->valuelen;\n\t\tsbp->flags = sfe->flags;\n\t\tsfe = xfs_attr_sf_nextentry(sfe);\n\t\tsbp++;\n\t\tnsbuf++;\n\t}\n\n\t \n\txfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);\n\n\t \n\tcount = 0;\n\tcursor->initted = 1;\n\tcursor->blkno = 0;\n\tfor (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {\n\t\tif (sbp->hash == cursor->hashval) {\n\t\t\tif (cursor->offset == count) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t} else if (sbp->hash > cursor->hashval) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == nsbuf)\n\t\tgoto out;\n\n\t \n\tfor ( ; i < nsbuf; i++, sbp++) {\n\t\tif (cursor->hashval != sbp->hash) {\n\t\t\tcursor->hashval = sbp->hash;\n\t\t\tcursor->offset = 0;\n\t\t}\n\t\tif (XFS_IS_CORRUPT(context->dp->i_mount,\n\t\t\t\t   !xfs_attr_namecheck(sbp->name,\n\t\t\t\t\t\t       sbp->namelen))) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t\tcontext->put_listent(context,\n\t\t\t\t     sbp->flags,\n\t\t\t\t     sbp->name,\n\t\t\t\t     sbp->namelen,\n\t\t\t\t     sbp->valuelen);\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\nout:\n\tkmem_free(sbuf);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_attr_node_list_lookup(\n\tstruct xfs_attr_list_context\t*context,\n\tstruct xfs_attrlist_cursor_kern\t*cursor,\n\tstruct xfs_buf\t\t\t**pbp)\n{\n\tstruct xfs_da3_icnode_hdr\tnodehdr;\n\tstruct xfs_da_intnode\t\t*node;\n\tstruct xfs_da_node_entry\t*btree;\n\tstruct xfs_inode\t\t*dp = context->dp;\n\tstruct xfs_mount\t\t*mp = dp->i_mount;\n\tstruct xfs_trans\t\t*tp = context->tp;\n\tstruct xfs_buf\t\t\t*bp;\n\tint\t\t\t\ti;\n\tint\t\t\t\terror = 0;\n\tunsigned int\t\t\texpected_level = 0;\n\tuint16_t\t\t\tmagic;\n\n\tASSERT(*pbp == NULL);\n\tcursor->blkno = 0;\n\tfor (;;) {\n\t\terror = xfs_da3_node_read(tp, dp, cursor->blkno, &bp,\n\t\t\t\tXFS_ATTR_FORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tnode = bp->b_addr;\n\t\tmagic = be16_to_cpu(node->hdr.info.magic);\n\t\tif (magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t    magic == XFS_ATTR3_LEAF_MAGIC)\n\t\t\tbreak;\n\t\tif (magic != XFS_DA_NODE_MAGIC &&\n\t\t    magic != XFS_DA3_NODE_MAGIC) {\n\t\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\t\tnode, sizeof(*node));\n\t\t\tgoto out_corruptbuf;\n\t\t}\n\n\t\txfs_da3_node_hdr_from_disk(mp, &nodehdr, node);\n\n\t\t \n\t\tif (nodehdr.level >= XFS_DA_NODE_MAXDEPTH)\n\t\t\tgoto out_corruptbuf;\n\n\t\t \n\t\tif (cursor->blkno == 0)\n\t\t\texpected_level = nodehdr.level - 1;\n\t\telse if (expected_level != nodehdr.level)\n\t\t\tgoto out_corruptbuf;\n\t\telse\n\t\t\texpected_level--;\n\n\t\tbtree = nodehdr.btree;\n\t\tfor (i = 0; i < nodehdr.count; btree++, i++) {\n\t\t\tif (cursor->hashval <= be32_to_cpu(btree->hashval)) {\n\t\t\t\tcursor->blkno = be32_to_cpu(btree->before);\n\t\t\t\ttrace_xfs_attr_list_node_descend(context,\n\t\t\t\t\t\tbtree);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\txfs_trans_brelse(tp, bp);\n\n\t\tif (i == nodehdr.count)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (XFS_IS_CORRUPT(mp, cursor->blkno == 0))\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (expected_level != 0)\n\t\tgoto out_corruptbuf;\n\n\t*pbp = bp;\n\treturn 0;\n\nout_corruptbuf:\n\txfs_buf_mark_corrupt(bp);\n\txfs_trans_brelse(tp, bp);\n\treturn -EFSCORRUPTED;\n}\n\nSTATIC int\nxfs_attr_node_list(\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct xfs_attrlist_cursor_kern\t*cursor = &context->cursor;\n\tstruct xfs_attr3_icleaf_hdr\tleafhdr;\n\tstruct xfs_attr_leafblock\t*leaf;\n\tstruct xfs_da_intnode\t\t*node;\n\tstruct xfs_buf\t\t\t*bp;\n\tstruct xfs_inode\t\t*dp = context->dp;\n\tstruct xfs_mount\t\t*mp = dp->i_mount;\n\tint\t\t\t\terror = 0;\n\n\ttrace_xfs_attr_node_list(context);\n\n\tcursor->initted = 1;\n\n\t \n\tbp = NULL;\n\tif (cursor->blkno > 0) {\n\t\terror = xfs_da3_node_read(context->tp, dp, cursor->blkno, &bp,\n\t\t\t\tXFS_ATTR_FORK);\n\t\tif ((error != 0) && (error != -EFSCORRUPTED))\n\t\t\treturn error;\n\t\tif (bp) {\n\t\t\tstruct xfs_attr_leaf_entry *entries;\n\n\t\t\tnode = bp->b_addr;\n\t\t\tswitch (be16_to_cpu(node->hdr.info.magic)) {\n\t\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\txfs_trans_brelse(context->tp, bp);\n\t\t\t\tbp = NULL;\n\t\t\t\tbreak;\n\t\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\t\tleaf = bp->b_addr;\n\t\t\t\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo,\n\t\t\t\t\t\t\t     &leafhdr, leaf);\n\t\t\t\tentries = xfs_attr3_leaf_entryp(leaf);\n\t\t\t\tif (cursor->hashval > be32_to_cpu(\n\t\t\t\t\t\tentries[leafhdr.count - 1].hashval)) {\n\t\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\t\txfs_trans_brelse(context->tp, bp);\n\t\t\t\t\tbp = NULL;\n\t\t\t\t} else if (cursor->hashval <= be32_to_cpu(\n\t\t\t\t\t\tentries[0].hashval)) {\n\t\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\t\txfs_trans_brelse(context->tp, bp);\n\t\t\t\t\tbp = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\txfs_trans_brelse(context->tp, bp);\n\t\t\t\tbp = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (bp == NULL) {\n\t\terror = xfs_attr_node_list_lookup(context, cursor, &bp);\n\t\tif (error || !bp)\n\t\t\treturn error;\n\t}\n\tASSERT(bp != NULL);\n\n\t \n\tfor (;;) {\n\t\tleaf = bp->b_addr;\n\t\terror = xfs_attr3_leaf_list_int(bp, context);\n\t\tif (error)\n\t\t\tbreak;\n\t\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &leafhdr, leaf);\n\t\tif (context->seen_enough || leafhdr.forw == 0)\n\t\t\tbreak;\n\t\tcursor->blkno = leafhdr.forw;\n\t\txfs_trans_brelse(context->tp, bp);\n\t\terror = xfs_attr3_leaf_read(context->tp, dp, cursor->blkno,\n\t\t\t\t\t    &bp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\txfs_trans_brelse(context->tp, bp);\n\treturn error;\n}\n\n \nint\nxfs_attr3_leaf_list_int(\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct xfs_attrlist_cursor_kern\t*cursor = &context->cursor;\n\tstruct xfs_attr_leafblock\t*leaf;\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\ti;\n\tstruct xfs_mount\t\t*mp = context->dp->i_mount;\n\n\ttrace_xfs_attr_list_leaf(context);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\tcursor->initted = 1;\n\n\t \n\tif (context->resynch) {\n\t\tentry = &entries[0];\n\t\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\t\tif (be32_to_cpu(entry->hashval) == cursor->hashval) {\n\t\t\t\tif (cursor->offset == context->dupcnt) {\n\t\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontext->dupcnt++;\n\t\t\t} else if (be32_to_cpu(entry->hashval) >\n\t\t\t\t\tcursor->hashval) {\n\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ichdr.count) {\n\t\t\ttrace_xfs_attr_list_notfound(context);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tentry = &entries[0];\n\t\ti = 0;\n\t}\n\tcontext->resynch = 0;\n\n\t \n\tfor (; i < ichdr.count; entry++, i++) {\n\t\tchar *name;\n\t\tint namelen, valuelen;\n\n\t\tif (be32_to_cpu(entry->hashval) != cursor->hashval) {\n\t\t\tcursor->hashval = be32_to_cpu(entry->hashval);\n\t\t\tcursor->offset = 0;\n\t\t}\n\n\t\tif ((entry->flags & XFS_ATTR_INCOMPLETE) &&\n\t\t    !context->allow_incomplete)\n\t\t\tcontinue;\n\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\txfs_attr_leaf_name_local_t *name_loc;\n\n\t\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\t\tname = name_loc->nameval;\n\t\t\tnamelen = name_loc->namelen;\n\t\t\tvaluelen = be16_to_cpu(name_loc->valuelen);\n\t\t} else {\n\t\t\txfs_attr_leaf_name_remote_t *name_rmt;\n\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\n\t\t\tname = name_rmt->name;\n\t\t\tnamelen = name_rmt->namelen;\n\t\t\tvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\t}\n\n\t\tif (XFS_IS_CORRUPT(context->dp->i_mount,\n\t\t\t\t   !xfs_attr_namecheck(name, namelen)))\n\t\t\treturn -EFSCORRUPTED;\n\t\tcontext->put_listent(context, entry->flags,\n\t\t\t\t\t      name, namelen, valuelen);\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\ttrace_xfs_attr_list_leaf_end(context);\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_attr_leaf_list(\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct xfs_buf\t\t\t*bp;\n\tint\t\t\t\terror;\n\n\ttrace_xfs_attr_leaf_list(context);\n\n\tcontext->cursor.blkno = 0;\n\terror = xfs_attr3_leaf_read(context->tp, context->dp, 0, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_list_int(bp, context);\n\txfs_trans_brelse(context->tp, bp);\n\treturn error;\n}\n\nint\nxfs_attr_list_ilocked(\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct xfs_inode\t\t*dp = context->dp;\n\n\tASSERT(xfs_isilocked(dp, XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\n\t \n\tif (!xfs_inode_hasattr(dp))\n\t\treturn 0;\n\tif (dp->i_af.if_format == XFS_DINODE_FMT_LOCAL)\n\t\treturn xfs_attr_shortform_list(context);\n\tif (xfs_attr_is_leaf(dp))\n\t\treturn xfs_attr_leaf_list(context);\n\treturn xfs_attr_node_list(context);\n}\n\nint\nxfs_attr_list(\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct xfs_inode\t\t*dp = context->dp;\n\tuint\t\t\t\tlock_mode;\n\tint\t\t\t\terror;\n\n\tXFS_STATS_INC(dp->i_mount, xs_attr_list);\n\n\tif (xfs_is_shutdown(dp->i_mount))\n\t\treturn -EIO;\n\n\tlock_mode = xfs_ilock_attr_map_shared(dp);\n\terror = xfs_attr_list_ilocked(context);\n\txfs_iunlock(dp, lock_mode);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}