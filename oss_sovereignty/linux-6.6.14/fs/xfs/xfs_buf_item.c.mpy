{
  "module_name": "xfs_buf_item.c",
  "hash_id": "8c96c45e4b767df59d5816304a887ef35918a1f06b374ecf8f6d3fe7bfbaeda3",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_buf_item.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_dquot.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_log_priv.h\"\n\n\nstruct kmem_cache\t*xfs_buf_item_cache;\n\nstatic inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}\n\n \nbool\nxfs_buf_log_check_iovec(\n\tstruct xfs_log_iovec\t\t*iovec)\n{\n\tstruct xfs_buf_log_format\t*blfp = iovec->i_addr;\n\tchar\t\t\t\t*bmp_end;\n\tchar\t\t\t\t*item_end;\n\n\tif (offsetof(struct xfs_buf_log_format, blf_data_map) > iovec->i_len)\n\t\treturn false;\n\n\titem_end = (char *)iovec->i_addr + iovec->i_len;\n\tbmp_end = (char *)&blfp->blf_data_map[blfp->blf_map_size];\n\treturn bmp_end <= item_end;\n}\n\nstatic inline int\nxfs_buf_log_format_size(\n\tstruct xfs_buf_log_format *blfp)\n{\n\treturn offsetof(struct xfs_buf_log_format, blf_data_map) +\n\t\t\t(blfp->blf_map_size * sizeof(blfp->blf_data_map[0]));\n}\n\nstatic inline bool\nxfs_buf_item_straddle(\n\tstruct xfs_buf\t\t*bp,\n\tuint\t\t\toffset,\n\tint\t\t\tfirst_bit,\n\tint\t\t\tnbits)\n{\n\tvoid\t\t\t*first, *last;\n\n\tfirst = xfs_buf_offset(bp, offset + (first_bit << XFS_BLF_SHIFT));\n\tlast = xfs_buf_offset(bp,\n\t\t\toffset + ((first_bit + nbits) << XFS_BLF_SHIFT));\n\n\tif (last - first != nbits * XFS_BLF_CHUNK)\n\t\treturn true;\n\treturn false;\n}\n\n \nSTATIC void\nxfs_buf_item_size_segment(\n\tstruct xfs_buf_log_item\t\t*bip,\n\tstruct xfs_buf_log_format\t*blfp,\n\tuint\t\t\t\toffset,\n\tint\t\t\t\t*nvecs,\n\tint\t\t\t\t*nbytes)\n{\n\tstruct xfs_buf\t\t\t*bp = bip->bli_buf;\n\tint\t\t\t\tfirst_bit;\n\tint\t\t\t\tnbits;\n\tint\t\t\t\tnext_bit;\n\tint\t\t\t\tlast_bit;\n\n\tfirst_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size, 0);\n\tif (first_bit == -1)\n\t\treturn;\n\n\t(*nvecs)++;\n\t*nbytes += xfs_buf_log_format_size(blfp);\n\n\tdo {\n\t\tnbits = xfs_contig_bits(blfp->blf_data_map,\n\t\t\t\t\tblfp->blf_map_size, first_bit);\n\t\tASSERT(nbits > 0);\n\n\t\t \n\t\tif (nbits > 1 &&\n\t\t    xfs_buf_item_straddle(bp, offset, first_bit, nbits))\n\t\t\tgoto slow_scan;\n\n\t\t(*nvecs)++;\n\t\t*nbytes += nbits * XFS_BLF_CHUNK;\n\n\t\t \n\t\tfirst_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size,\n\t\t\t\t\t(uint)first_bit + nbits + 1);\n\t} while (first_bit != -1);\n\n\treturn;\n\nslow_scan:\n\t \n\t(*nvecs)++;\n\t*nbytes += XFS_BLF_CHUNK;\n\tlast_bit = first_bit;\n\twhile (last_bit != -1) {\n\t\t \n\t\tnext_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size,\n\t\t\t\t\tlast_bit + 1);\n\t\t \n\t\tif (next_bit == -1) {\n\t\t\tbreak;\n\t\t} else if (next_bit != last_bit + 1 ||\n\t\t           xfs_buf_item_straddle(bp, offset, first_bit, nbits)) {\n\t\t\tlast_bit = next_bit;\n\t\t\tfirst_bit = next_bit;\n\t\t\t(*nvecs)++;\n\t\t\tnbits = 1;\n\t\t} else {\n\t\t\tlast_bit++;\n\t\t\tnbits++;\n\t\t}\n\t\t*nbytes += XFS_BLF_CHUNK;\n\t}\n}\n\n \nSTATIC void\nxfs_buf_item_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\tint\t\t\ti;\n\tint\t\t\tbytes;\n\tuint\t\t\toffset = 0;\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t \n\t\ttrace_xfs_buf_item_size_stale(bip);\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\t*nvecs += bip->bli_format_count;\n\t\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\t\t*nbytes += xfs_buf_log_format_size(&bip->bli_formats[i]);\n\t\t}\n\t\treturn;\n\t}\n\n\tASSERT(bip->bli_flags & XFS_BLI_LOGGED);\n\n\tif (bip->bli_flags & XFS_BLI_ORDERED) {\n\t\t \n\t\ttrace_xfs_buf_item_size_ordered(bip);\n\t\t*nvecs = XFS_LOG_VEC_ORDERED;\n\t\treturn;\n\t}\n\n\t \n\tbytes = 0;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\txfs_buf_item_size_segment(bip, &bip->bli_formats[i], offset,\n\t\t\t\t\t  nvecs, &bytes);\n\t\toffset += BBTOB(bp->b_maps[i].bm_len);\n\t}\n\n\t \n\t*nbytes = round_up(bytes, 512);\n\ttrace_xfs_buf_item_size(bip);\n}\n\nstatic inline void\nxfs_buf_item_copy_iovec(\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp,\n\tstruct xfs_buf\t\t*bp,\n\tuint\t\t\toffset,\n\tint\t\t\tfirst_bit,\n\tuint\t\t\tnbits)\n{\n\toffset += first_bit * XFS_BLF_CHUNK;\n\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_BCHUNK,\n\t\t\txfs_buf_offset(bp, offset),\n\t\t\tnbits * XFS_BLF_CHUNK);\n}\n\nstatic void\nxfs_buf_item_format_segment(\n\tstruct xfs_buf_log_item\t*bip,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp,\n\tuint\t\t\toffset,\n\tstruct xfs_buf_log_format *blfp)\n{\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\tuint\t\t\tbase_size;\n\tint\t\t\tfirst_bit;\n\tint\t\t\tlast_bit;\n\tint\t\t\tnext_bit;\n\tuint\t\t\tnbits;\n\n\t \n\tblfp->blf_flags = bip->__bli_format.blf_flags;\n\n\t \n\tbase_size = xfs_buf_log_format_size(blfp);\n\n\tfirst_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size, 0);\n\tif (!(bip->bli_flags & XFS_BLI_STALE) && first_bit == -1) {\n\t\t \n\t\treturn;\n\t}\n\n\tblfp = xlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_BFORMAT, blfp, base_size);\n\tblfp->blf_size = 1;\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t \n\t\ttrace_xfs_buf_item_format_stale(bip);\n\t\tASSERT(blfp->blf_flags & XFS_BLF_CANCEL);\n\t\treturn;\n\t}\n\n\n\t \n\tdo {\n\t\tASSERT(first_bit >= 0);\n\t\tnbits = xfs_contig_bits(blfp->blf_data_map,\n\t\t\t\t\tblfp->blf_map_size, first_bit);\n\t\tASSERT(nbits > 0);\n\n\t\t \n\t\tif (nbits > 1 &&\n\t\t    xfs_buf_item_straddle(bp, offset, first_bit, nbits))\n\t\t\tgoto slow_scan;\n\n\t\txfs_buf_item_copy_iovec(lv, vecp, bp, offset,\n\t\t\t\t\tfirst_bit, nbits);\n\t\tblfp->blf_size++;\n\n\t\t \n\t\tfirst_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size,\n\t\t\t\t\t(uint)first_bit + nbits + 1);\n\t} while (first_bit != -1);\n\n\treturn;\n\nslow_scan:\n\tASSERT(bp->b_addr == NULL);\n\tlast_bit = first_bit;\n\tnbits = 1;\n\tfor (;;) {\n\t\t \n\t\tnext_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size,\n\t\t\t\t\t(uint)last_bit + 1);\n\t\t \n\t\tif (next_bit == -1) {\n\t\t\txfs_buf_item_copy_iovec(lv, vecp, bp, offset,\n\t\t\t\t\t\tfirst_bit, nbits);\n\t\t\tblfp->blf_size++;\n\t\t\tbreak;\n\t\t} else if (next_bit != last_bit + 1 ||\n\t\t           xfs_buf_item_straddle(bp, offset, first_bit, nbits)) {\n\t\t\txfs_buf_item_copy_iovec(lv, vecp, bp, offset,\n\t\t\t\t\t\tfirst_bit, nbits);\n\t\t\tblfp->blf_size++;\n\t\t\tfirst_bit = next_bit;\n\t\t\tlast_bit = next_bit;\n\t\t\tnbits = 1;\n\t\t} else {\n\t\t\tlast_bit++;\n\t\t\tnbits++;\n\t\t}\n\t}\n}\n\n \nSTATIC void\nxfs_buf_item_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\tuint\t\t\toffset = 0;\n\tint\t\t\ti;\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tASSERT((bip->bli_flags & XFS_BLI_LOGGED) ||\n\t       (bip->bli_flags & XFS_BLI_STALE));\n\tASSERT((bip->bli_flags & XFS_BLI_STALE) ||\n\t       (xfs_blft_from_flags(&bip->__bli_format) > XFS_BLFT_UNKNOWN_BUF\n\t        && xfs_blft_from_flags(&bip->__bli_format) < XFS_BLFT_MAX_BUF));\n\tASSERT(!(bip->bli_flags & XFS_BLI_ORDERED) ||\n\t       (bip->bli_flags & XFS_BLI_STALE));\n\n\n\t \n\tif (bip->bli_flags & XFS_BLI_INODE_BUF) {\n\t\tif (xfs_has_v3inodes(lip->li_log->l_mp) ||\n\t\t    !((bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF) &&\n\t\t      xfs_log_item_in_current_chkpt(lip)))\n\t\t\tbip->__bli_format.blf_flags |= XFS_BLF_INODE_BUF;\n\t\tbip->bli_flags &= ~XFS_BLI_INODE_BUF;\n\t}\n\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\txfs_buf_item_format_segment(bip, lv, &vecp, offset,\n\t\t\t\t\t    &bip->bli_formats[i]);\n\t\toffset += BBTOB(bp->b_maps[i].bm_len);\n\t}\n\n\t \n\ttrace_xfs_buf_item_format(bip);\n}\n\n \nSTATIC void\nxfs_buf_item_pin(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tASSERT((bip->bli_flags & XFS_BLI_LOGGED) ||\n\t       (bip->bli_flags & XFS_BLI_ORDERED) ||\n\t       (bip->bli_flags & XFS_BLI_STALE));\n\n\ttrace_xfs_buf_item_pin(bip);\n\n\txfs_buf_hold(bip->bli_buf);\n\tatomic_inc(&bip->bli_refcount);\n\tatomic_inc(&bip->bli_buf->b_pin_count);\n}\n\n \nSTATIC void\nxfs_buf_item_unpin(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\tremove)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\tint\t\t\tstale = bip->bli_flags & XFS_BLI_STALE;\n\tint\t\t\tfreed;\n\n\tASSERT(bp->b_log_item == bip);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_buf_item_unpin(bip);\n\n\tfreed = atomic_dec_and_test(&bip->bli_refcount);\n\tif (atomic_dec_and_test(&bp->b_pin_count))\n\t\twake_up_all(&bp->b_waiters);\n\n\t \n\tif (!freed) {\n\t\txfs_buf_rele(bp);\n\t\treturn;\n\t}\n\n\tif (stale) {\n\t\tASSERT(bip->bli_flags & XFS_BLI_STALE);\n\t\tASSERT(xfs_buf_islocked(bp));\n\t\tASSERT(bp->b_flags & XBF_STALE);\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(list_empty(&lip->li_trans));\n\t\tASSERT(!bp->b_transp);\n\n\t\ttrace_xfs_buf_item_unpin_stale(bip);\n\n\t\t \n\t\txfs_buf_rele(bp);\n\n\t\t \n\t\tif (bip->bli_flags & XFS_BLI_STALE_INODE) {\n\t\t\txfs_buf_item_done(bp);\n\t\t\txfs_buf_inode_iodone(bp);\n\t\t\tASSERT(list_empty(&bp->b_li_list));\n\t\t} else {\n\t\t\txfs_trans_ail_delete(lip, SHUTDOWN_LOG_IO_ERROR);\n\t\t\txfs_buf_item_relse(bp);\n\t\t\tASSERT(bp->b_log_item == NULL);\n\t\t}\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tif (remove) {\n\t\t \n\t\txfs_buf_lock(bp);\n\t\tbp->b_flags |= XBF_ASYNC;\n\t\txfs_buf_ioend_fail(bp);\n\t\treturn;\n\t}\n\n\t \n\txfs_buf_rele(bp);\n}\n\nSTATIC uint\nxfs_buf_item_push(\n\tstruct xfs_log_item\t*lip,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\tuint\t\t\trval = XFS_ITEM_SUCCESS;\n\n\tif (xfs_buf_ispinned(bp))\n\t\treturn XFS_ITEM_PINNED;\n\tif (!xfs_buf_trylock(bp)) {\n\t\t \n\t\tif (xfs_buf_ispinned(bp))\n\t\t\treturn XFS_ITEM_PINNED;\n\t\treturn XFS_ITEM_LOCKED;\n\t}\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\n\ttrace_xfs_buf_item_push(bip);\n\n\t \n\tif (bp->b_flags & XBF_WRITE_FAIL) {\n\t\txfs_buf_alert_ratelimited(bp, \"XFS: Failing async write\",\n\t    \"Failing async write on buffer block 0x%llx. Retrying async write.\",\n\t\t\t\t\t  (long long)xfs_buf_daddr(bp));\n\t}\n\n\tif (!xfs_buf_delwri_queue(bp, buffer_list))\n\t\trval = XFS_ITEM_FLUSHING;\n\txfs_buf_unlock(bp);\n\treturn rval;\n}\n\n \nbool\nxfs_buf_item_put(\n\tstruct xfs_buf_log_item\t*bip)\n{\n\tstruct xfs_log_item\t*lip = &bip->bli_item;\n\tbool\t\t\taborted;\n\tbool\t\t\tdirty;\n\n\t \n\tif (!atomic_dec_and_test(&bip->bli_refcount))\n\t\treturn false;\n\n\t \n\taborted = test_bit(XFS_LI_ABORTED, &lip->li_flags) ||\n\t\t\txlog_is_shutdown(lip->li_log);\n\tdirty = bip->bli_flags & XFS_BLI_DIRTY;\n\tif (dirty && !aborted)\n\t\treturn false;\n\n\t \n\tif (aborted)\n\t\txfs_trans_ail_delete(lip, 0);\n\txfs_buf_item_relse(bip->bli_buf);\n\treturn true;\n}\n\n \nSTATIC void\nxfs_buf_item_release(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\tbool\t\t\treleased;\n\tbool\t\t\thold = bip->bli_flags & XFS_BLI_HOLD;\n\tbool\t\t\tstale = bip->bli_flags & XFS_BLI_STALE;\n#if defined(DEBUG) || defined(XFS_WARN)\n\tbool\t\t\tordered = bip->bli_flags & XFS_BLI_ORDERED;\n\tbool\t\t\tdirty = bip->bli_flags & XFS_BLI_DIRTY;\n\tbool\t\t\taborted = test_bit(XFS_LI_ABORTED,\n\t\t\t\t\t\t   &lip->li_flags);\n#endif\n\n\ttrace_xfs_buf_item_release(bip);\n\n\t \n\tASSERT((!ordered && dirty == xfs_buf_item_dirty_format(bip)) ||\n\t       (ordered && dirty && !xfs_buf_item_dirty_format(bip)));\n\tASSERT(!stale || (bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\n\t \n\tbp->b_transp = NULL;\n\tbip->bli_flags &= ~(XFS_BLI_LOGGED | XFS_BLI_HOLD | XFS_BLI_ORDERED);\n\n\t \n\treleased = xfs_buf_item_put(bip);\n\tif (hold || (stale && !released))\n\t\treturn;\n\tASSERT(!stale || aborted);\n\txfs_buf_relse(bp);\n}\n\nSTATIC void\nxfs_buf_item_committing(\n\tstruct xfs_log_item\t*lip,\n\txfs_csn_t\t\tseq)\n{\n\treturn xfs_buf_item_release(lip);\n}\n\n \nSTATIC xfs_lsn_t\nxfs_buf_item_committed(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\n\ttrace_xfs_buf_item_committed(bip);\n\n\tif ((bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF) && lip->li_lsn != 0)\n\t\treturn lip->li_lsn;\n\treturn lsn;\n}\n\nstatic const struct xfs_item_ops xfs_buf_item_ops = {\n\t.iop_size\t= xfs_buf_item_size,\n\t.iop_format\t= xfs_buf_item_format,\n\t.iop_pin\t= xfs_buf_item_pin,\n\t.iop_unpin\t= xfs_buf_item_unpin,\n\t.iop_release\t= xfs_buf_item_release,\n\t.iop_committing\t= xfs_buf_item_committing,\n\t.iop_committed\t= xfs_buf_item_committed,\n\t.iop_push\t= xfs_buf_item_push,\n};\n\nSTATIC void\nxfs_buf_item_get_format(\n\tstruct xfs_buf_log_item\t*bip,\n\tint\t\t\tcount)\n{\n\tASSERT(bip->bli_formats == NULL);\n\tbip->bli_format_count = count;\n\n\tif (count == 1) {\n\t\tbip->bli_formats = &bip->__bli_format;\n\t\treturn;\n\t}\n\n\tbip->bli_formats = kmem_zalloc(count * sizeof(struct xfs_buf_log_format),\n\t\t\t\t0);\n}\n\nSTATIC void\nxfs_buf_item_free_format(\n\tstruct xfs_buf_log_item\t*bip)\n{\n\tif (bip->bli_formats != &bip->__bli_format) {\n\t\tkmem_free(bip->bli_formats);\n\t\tbip->bli_formats = NULL;\n\t}\n}\n\n \nint\nxfs_buf_item_init(\n\tstruct xfs_buf\t*bp,\n\tstruct xfs_mount *mp)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_log_item;\n\tint\t\t\tchunks;\n\tint\t\t\tmap_size;\n\tint\t\t\ti;\n\n\t \n\tASSERT(bp->b_mount == mp);\n\tif (bip) {\n\t\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\t\tASSERT(!bp->b_transp);\n\t\tASSERT(bip->bli_buf == bp);\n\t\treturn 0;\n\t}\n\n\tbip = kmem_cache_zalloc(xfs_buf_item_cache, GFP_KERNEL | __GFP_NOFAIL);\n\txfs_log_item_init(mp, &bip->bli_item, XFS_LI_BUF, &xfs_buf_item_ops);\n\tbip->bli_buf = bp;\n\n\t \n\txfs_buf_item_get_format(bip, bp->b_map_count);\n\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tchunks = DIV_ROUND_UP(BBTOB(bp->b_maps[i].bm_len),\n\t\t\t\t      XFS_BLF_CHUNK);\n\t\tmap_size = DIV_ROUND_UP(chunks, NBWORD);\n\n\t\tif (map_size > XFS_BLF_DATAMAP_SIZE) {\n\t\t\tkmem_cache_free(xfs_buf_item_cache, bip);\n\t\t\txfs_err(mp,\n\t\"buffer item dirty bitmap (%u uints) too small to reflect %u bytes!\",\n\t\t\t\t\tmap_size,\n\t\t\t\t\tBBTOB(bp->b_maps[i].bm_len));\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tbip->bli_formats[i].blf_type = XFS_LI_BUF;\n\t\tbip->bli_formats[i].blf_blkno = bp->b_maps[i].bm_bn;\n\t\tbip->bli_formats[i].blf_len = bp->b_maps[i].bm_len;\n\t\tbip->bli_formats[i].blf_map_size = map_size;\n\t}\n\n\tbp->b_log_item = bip;\n\txfs_buf_hold(bp);\n\treturn 0;\n}\n\n\n \nstatic void\nxfs_buf_item_log_segment(\n\tuint\t\t\tfirst,\n\tuint\t\t\tlast,\n\tuint\t\t\t*map)\n{\n\tuint\t\tfirst_bit;\n\tuint\t\tlast_bit;\n\tuint\t\tbits_to_set;\n\tuint\t\tbits_set;\n\tuint\t\tword_num;\n\tuint\t\t*wordp;\n\tuint\t\tbit;\n\tuint\t\tend_bit;\n\tuint\t\tmask;\n\n\tASSERT(first < XFS_BLF_DATAMAP_SIZE * XFS_BLF_CHUNK * NBWORD);\n\tASSERT(last < XFS_BLF_DATAMAP_SIZE * XFS_BLF_CHUNK * NBWORD);\n\n\t \n\tfirst_bit = first >> XFS_BLF_SHIFT;\n\tlast_bit = last >> XFS_BLF_SHIFT;\n\n\t \n\tbits_to_set = last_bit - first_bit + 1;\n\n\t \n\tword_num = first_bit >> BIT_TO_WORD_SHIFT;\n\twordp = &map[word_num];\n\n\t \n\tbit = first_bit & (uint)(NBWORD - 1);\n\n\t \n\tif (bit) {\n\t\tend_bit = min(bit + bits_to_set, (uint)NBWORD);\n\t\tmask = ((1U << (end_bit - bit)) - 1) << bit;\n\t\t*wordp |= mask;\n\t\twordp++;\n\t\tbits_set = end_bit - bit;\n\t} else {\n\t\tbits_set = 0;\n\t}\n\n\t \n\twhile ((bits_to_set - bits_set) >= NBWORD) {\n\t\t*wordp = 0xffffffff;\n\t\tbits_set += NBWORD;\n\t\twordp++;\n\t}\n\n\t \n\tend_bit = bits_to_set - bits_set;\n\tif (end_bit) {\n\t\tmask = (1U << end_bit) - 1;\n\t\t*wordp |= mask;\n\t}\n}\n\n \nvoid\nxfs_buf_item_log(\n\tstruct xfs_buf_log_item\t*bip,\n\tuint\t\t\tfirst,\n\tuint\t\t\tlast)\n{\n\tint\t\t\ti;\n\tuint\t\t\tstart;\n\tuint\t\t\tend;\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\n\t \n\tstart = 0;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tif (start > last)\n\t\t\tbreak;\n\t\tend = start + BBTOB(bp->b_maps[i].bm_len) - 1;\n\n\t\t \n\t\tif (first > end) {\n\t\t\tstart += BBTOB(bp->b_maps[i].bm_len);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (first < start)\n\t\t\tfirst = start;\n\t\tif (end > last)\n\t\t\tend = last;\n\t\txfs_buf_item_log_segment(first - start, end - start,\n\t\t\t\t\t &bip->bli_formats[i].blf_data_map[0]);\n\n\t\tstart += BBTOB(bp->b_maps[i].bm_len);\n\t}\n}\n\n\n \nbool\nxfs_buf_item_dirty_format(\n\tstruct xfs_buf_log_item\t*bip)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tif (!xfs_bitmap_empty(bip->bli_formats[i].blf_data_map,\n\t\t\t     bip->bli_formats[i].blf_map_size))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nSTATIC void\nxfs_buf_item_free(\n\tstruct xfs_buf_log_item\t*bip)\n{\n\txfs_buf_item_free_format(bip);\n\tkmem_free(bip->bli_item.li_lv_shadow);\n\tkmem_cache_free(xfs_buf_item_cache, bip);\n}\n\n \nvoid\nxfs_buf_item_relse(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_log_item;\n\n\ttrace_xfs_buf_item_relse(bp, _RET_IP_);\n\tASSERT(!test_bit(XFS_LI_IN_AIL, &bip->bli_item.li_flags));\n\n\tif (atomic_read(&bip->bli_refcount))\n\t\treturn;\n\tbp->b_log_item = NULL;\n\txfs_buf_rele(bp);\n\txfs_buf_item_free(bip);\n}\n\nvoid\nxfs_buf_item_done(\n\tstruct xfs_buf\t\t*bp)\n{\n\t \n\txfs_trans_ail_delete(&bp->b_log_item->bli_item,\n\t\t\t     (bp->b_flags & _XBF_LOGRECOVERY) ? 0 :\n\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\txfs_buf_item_relse(bp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}