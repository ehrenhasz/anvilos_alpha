{
  "module_name": "xfs_icreate_item.c",
  "hash_id": "9e099458e5d0ff833a8a1f01412c6d2b3400a246c4f472cc3ea1d68ed9b808f5",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_icreate_item.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_log.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_trace.h\"\n\nstruct kmem_cache\t*xfs_icreate_cache;\t\t \n\nstatic inline struct xfs_icreate_item *ICR_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_icreate_item, ic_item);\n}\n\n \nSTATIC void\nxfs_icreate_item_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\t*nvecs += 1;\n\t*nbytes += sizeof(struct xfs_icreate_log);\n}\n\n \nSTATIC void\nxfs_icreate_item_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_icreate_item\t*icp = ICR_ITEM(lip);\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\n\txlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_ICREATE,\n\t\t\t&icp->ic_format,\n\t\t\tsizeof(struct xfs_icreate_log));\n}\n\nSTATIC void\nxfs_icreate_item_release(\n\tstruct xfs_log_item\t*lip)\n{\n\tkmem_free(ICR_ITEM(lip)->ic_item.li_lv_shadow);\n\tkmem_cache_free(xfs_icreate_cache, ICR_ITEM(lip));\n}\n\nstatic const struct xfs_item_ops xfs_icreate_item_ops = {\n\t.flags\t\t= XFS_ITEM_RELEASE_WHEN_COMMITTED,\n\t.iop_size\t= xfs_icreate_item_size,\n\t.iop_format\t= xfs_icreate_item_format,\n\t.iop_release\t= xfs_icreate_item_release,\n};\n\n\n \nvoid\nxfs_icreate_log(\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tagbno,\n\tunsigned int\t\tcount,\n\tunsigned int\t\tinode_size,\n\txfs_agblock_t\t\tlength,\n\tunsigned int\t\tgeneration)\n{\n\tstruct xfs_icreate_item\t*icp;\n\n\ticp = kmem_cache_zalloc(xfs_icreate_cache, GFP_KERNEL | __GFP_NOFAIL);\n\n\txfs_log_item_init(tp->t_mountp, &icp->ic_item, XFS_LI_ICREATE,\n\t\t\t  &xfs_icreate_item_ops);\n\n\ticp->ic_format.icl_type = XFS_LI_ICREATE;\n\ticp->ic_format.icl_size = 1;\t \n\ticp->ic_format.icl_ag = cpu_to_be32(agno);\n\ticp->ic_format.icl_agbno = cpu_to_be32(agbno);\n\ticp->ic_format.icl_count = cpu_to_be32(count);\n\ticp->ic_format.icl_isize = cpu_to_be32(inode_size);\n\ticp->ic_format.icl_length = cpu_to_be32(length);\n\ticp->ic_format.icl_gen = cpu_to_be32(generation);\n\n\txfs_trans_add_item(tp, &icp->ic_item);\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tset_bit(XFS_LI_DIRTY, &icp->ic_item.li_flags);\n}\n\nstatic enum xlog_recover_reorder\nxlog_recover_icreate_reorder(\n\t\tstruct xlog_recover_item *item)\n{\n\t \n\treturn XLOG_REORDER_BUFFER_LIST;\n}\n\n \nSTATIC int\nxlog_recover_icreate_commit_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tlsn)\n{\n\tstruct xfs_mount\t\t*mp = log->l_mp;\n\tstruct xfs_icreate_log\t\t*icl;\n\tstruct xfs_ino_geometry\t\t*igeo = M_IGEO(mp);\n\txfs_agnumber_t\t\t\tagno;\n\txfs_agblock_t\t\t\tagbno;\n\tunsigned int\t\t\tcount;\n\tunsigned int\t\t\tisize;\n\txfs_agblock_t\t\t\tlength;\n\tint\t\t\t\tbb_per_cluster;\n\tint\t\t\t\tcancel_count;\n\tint\t\t\t\tnbufs;\n\tint\t\t\t\ti;\n\n\ticl = (struct xfs_icreate_log *)item->ri_buf[0].i_addr;\n\tif (icl->icl_type != XFS_LI_ICREATE) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad type\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (icl->icl_size != 1) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad icl size\");\n\t\treturn -EINVAL;\n\t}\n\n\tagno = be32_to_cpu(icl->icl_ag);\n\tif (agno >= mp->m_sb.sb_agcount) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad agno\");\n\t\treturn -EINVAL;\n\t}\n\tagbno = be32_to_cpu(icl->icl_agbno);\n\tif (!agbno || agbno == NULLAGBLOCK || agbno >= mp->m_sb.sb_agblocks) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad agbno\");\n\t\treturn -EINVAL;\n\t}\n\tisize = be32_to_cpu(icl->icl_isize);\n\tif (isize != mp->m_sb.sb_inodesize) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad isize\");\n\t\treturn -EINVAL;\n\t}\n\tcount = be32_to_cpu(icl->icl_count);\n\tif (!count) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad count\");\n\t\treturn -EINVAL;\n\t}\n\tlength = be32_to_cpu(icl->icl_length);\n\tif (!length || length >= mp->m_sb.sb_agblocks) {\n\t\txfs_warn(log->l_mp, \"xlog_recover_do_icreate_trans: bad length\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (length != igeo->ialloc_blks &&\n\t    length != igeo->ialloc_min_blks) {\n\t\txfs_warn(log->l_mp,\n\t\t\t \"%s: unsupported chunk length\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((count >> mp->m_sb.sb_inopblog) != length) {\n\t\txfs_warn(log->l_mp,\n\t\t\t \"%s: inconsistent inode count and chunk length\",\n\t\t\t __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbb_per_cluster = XFS_FSB_TO_BB(mp, igeo->blocks_per_cluster);\n\tnbufs = length / igeo->blocks_per_cluster;\n\tfor (i = 0, cancel_count = 0; i < nbufs; i++) {\n\t\txfs_daddr_t\tdaddr;\n\n\t\tdaddr = XFS_AGB_TO_DADDR(mp, agno,\n\t\t\t\tagbno + i * igeo->blocks_per_cluster);\n\t\tif (xlog_is_buffer_cancelled(log, daddr, bb_per_cluster))\n\t\t\tcancel_count++;\n\t}\n\n\t \n\tASSERT(!cancel_count || cancel_count == nbufs);\n\tif (cancel_count) {\n\t\tif (cancel_count != nbufs)\n\t\t\txfs_warn(mp,\n\t\"WARNING: partial inode chunk cancellation, skipped icreate.\");\n\t\ttrace_xfs_log_recover_icreate_cancel(log, icl);\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_log_recover_icreate_recover(log, icl);\n\treturn xfs_ialloc_inode_init(mp, NULL, buffer_list, count, agno, agbno,\n\t\t\t\t     length, be32_to_cpu(icl->icl_gen));\n}\n\nconst struct xlog_recover_item_ops xlog_icreate_item_ops = {\n\t.item_type\t\t= XFS_LI_ICREATE,\n\t.reorder\t\t= xlog_recover_icreate_reorder,\n\t.commit_pass2\t\t= xlog_recover_icreate_commit_pass2,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}