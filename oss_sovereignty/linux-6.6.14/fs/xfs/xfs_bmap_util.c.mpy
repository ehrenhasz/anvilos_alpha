{
  "module_name": "xfs_bmap_util.c",
  "hash_id": "8517e6be3fdc7d95a777ed8574063e958bc226642a560db52f8d39ec63a6a9c8",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_bmap_util.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_reflink.h\"\n\n \n\n \nxfs_daddr_t\nxfs_fsb_to_db(struct xfs_inode *ip, xfs_fsblock_t fsb)\n{\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn XFS_FSB_TO_BB(ip->i_mount, fsb);\n\treturn XFS_FSB_TO_DADDR(ip->i_mount, fsb);\n}\n\n \nint\nxfs_zero_extent(\n\tstruct xfs_inode\t*ip,\n\txfs_fsblock_t\t\tstart_fsb,\n\txfs_off_t\t\tcount_fsb)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_buftarg\t*target = xfs_inode_buftarg(ip);\n\txfs_daddr_t\t\tsector = xfs_fsb_to_db(ip, start_fsb);\n\tsector_t\t\tblock = XFS_BB_TO_FSBT(mp, sector);\n\n\treturn blkdev_issue_zeroout(target->bt_bdev,\n\t\tblock << (mp->m_super->s_blocksize_bits - 9),\n\t\tcount_fsb << (mp->m_super->s_blocksize_bits - 9),\n\t\tGFP_NOFS, 0);\n}\n\n#ifdef CONFIG_XFS_RT\nint\nxfs_bmap_rtalloc(\n\tstruct xfs_bmalloca\t*ap)\n{\n\tstruct xfs_mount\t*mp = ap->ip->i_mount;\n\txfs_fileoff_t\t\torig_offset = ap->offset;\n\txfs_rtblock_t\t\trtb;\n\txfs_extlen_t\t\tprod = 0;   \n\txfs_extlen_t\t\tmod = 0;    \n\txfs_extlen_t\t\tralen = 0;  \n\txfs_extlen_t\t\talign;      \n\txfs_extlen_t\t\torig_length = ap->length;\n\txfs_extlen_t\t\tminlen = mp->m_sb.sb_rextsize;\n\txfs_extlen_t\t\traminlen;\n\tbool\t\t\trtlocked = false;\n\tbool\t\t\tignore_locality = false;\n\tint\t\t\terror;\n\n\talign = xfs_get_extsz_hint(ap->ip);\nretry:\n\tprod = align / mp->m_sb.sb_rextsize;\n\terror = xfs_bmap_extsize_align(mp, &ap->got, &ap->prev,\n\t\t\t\t\talign, 1, ap->eof, 0,\n\t\t\t\t\tap->conv, &ap->offset, &ap->length);\n\tif (error)\n\t\treturn error;\n\tASSERT(ap->length);\n\tASSERT(ap->length % mp->m_sb.sb_rextsize == 0);\n\n\t \n\tif (ap->offset != orig_offset)\n\t\tminlen += orig_offset - ap->offset;\n\n\t \n\tdiv_u64_rem(ap->offset, align, &mod);\n\tif (mod || ap->length % align)\n\t\tprod = 1;\n\t \n\tralen = ap->length / mp->m_sb.sb_rextsize;\n\t \n\tif (ralen * mp->m_sb.sb_rextsize >= XFS_MAX_BMBT_EXTLEN)\n\t\tralen = XFS_MAX_BMBT_EXTLEN / mp->m_sb.sb_rextsize;\n\n\t \n\tif (!rtlocked) {\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL|XFS_ILOCK_RTBITMAP);\n\t\txfs_trans_ijoin(ap->tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_ilock(mp->m_rsumip, XFS_ILOCK_EXCL|XFS_ILOCK_RTSUM);\n\t\txfs_trans_ijoin(ap->tp, mp->m_rsumip, XFS_ILOCK_EXCL);\n\t\trtlocked = true;\n\t}\n\n\t \n\tif (ap->eof && ap->offset == 0) {\n\t\txfs_rtblock_t rtx;  \n\n\t\terror = xfs_rtpick_extent(mp, ap->tp, ralen, &rtx);\n\t\tif (error)\n\t\t\treturn error;\n\t\tap->blkno = rtx * mp->m_sb.sb_rextsize;\n\t} else {\n\t\tap->blkno = 0;\n\t}\n\n\txfs_bmap_adjacent(ap);\n\n\t \n\tif (ignore_locality)\n\t\tap->blkno = 0;\n\telse\n\t\tdo_div(ap->blkno, mp->m_sb.sb_rextsize);\n\trtb = ap->blkno;\n\tap->length = ralen;\n\traminlen = max_t(xfs_extlen_t, 1, minlen / mp->m_sb.sb_rextsize);\n\terror = xfs_rtallocate_extent(ap->tp, ap->blkno, raminlen, ap->length,\n\t\t\t&ralen, ap->wasdel, prod, &rtb);\n\tif (error)\n\t\treturn error;\n\n\tif (rtb != NULLRTBLOCK) {\n\t\tap->blkno = rtb * mp->m_sb.sb_rextsize;\n\t\tap->length = ralen * mp->m_sb.sb_rextsize;\n\t\tap->ip->i_nblocks += ap->length;\n\t\txfs_trans_log_inode(ap->tp, ap->ip, XFS_ILOG_CORE);\n\t\tif (ap->wasdel)\n\t\t\tap->ip->i_delayed_blks -= ap->length;\n\t\t \n\t\txfs_trans_mod_dquot_byino(ap->tp, ap->ip,\n\t\t\tap->wasdel ? XFS_TRANS_DQ_DELRTBCOUNT :\n\t\t\t\t\tXFS_TRANS_DQ_RTBCOUNT, ap->length);\n\t\treturn 0;\n\t}\n\n\tif (align > mp->m_sb.sb_rextsize) {\n\t\t \n\t\tap->offset = orig_offset;\n\t\tap->length = orig_length;\n\t\tminlen = align = mp->m_sb.sb_rextsize;\n\t\tgoto retry;\n\t}\n\n\tif (!ignore_locality && ap->blkno != 0) {\n\t\t \n\t\tignore_locality = true;\n\t\tgoto retry;\n\t}\n\n\tap->blkno = NULLFSBLOCK;\n\tap->length = 0;\n\treturn 0;\n}\n#endif  \n\n \n\n \nxfs_extnum_t\nxfs_bmap_count_leaves(\n\tstruct xfs_ifork\t*ifp,\n\txfs_filblks_t\t\t*count)\n{\n\tstruct xfs_iext_cursor\ticur;\n\tstruct xfs_bmbt_irec\tgot;\n\txfs_extnum_t\t\tnumrecs = 0;\n\n\tfor_each_xfs_iext(ifp, &icur, &got) {\n\t\tif (!isnullstartblock(got.br_startblock)) {\n\t\t\t*count += got.br_blockcount;\n\t\t\tnumrecs++;\n\t\t}\n\t}\n\n\treturn numrecs;\n}\n\n \nint\nxfs_bmap_count_blocks(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_extnum_t\t\t*nextents,\n\txfs_filblks_t\t\t*count)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\txfs_extlen_t\t\tbtblocks = 0;\n\tint\t\t\terror;\n\n\t*nextents = 0;\n\t*count = 0;\n\n\tif (!ifp)\n\t\treturn 0;\n\n\tswitch (ifp->if_format) {\n\tcase XFS_DINODE_FMT_BTREE:\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\terror = xfs_btree_count_blocks(cur, &btblocks);\n\t\txfs_btree_del_cursor(cur, error);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\t*count += btblocks - 1;\n\n\t\tfallthrough;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t*nextents = xfs_bmap_count_leaves(ifp, count);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nxfs_getbmap_report_one(\n\tstruct xfs_inode\t*ip,\n\tstruct getbmapx\t\t*bmv,\n\tstruct kgetbmap\t\t*out,\n\tint64_t\t\t\tbmv_end,\n\tstruct xfs_bmbt_irec\t*got)\n{\n\tstruct kgetbmap\t\t*p = out + bmv->bmv_entries;\n\tbool\t\t\tshared = false;\n\tint\t\t\terror;\n\n\terror = xfs_reflink_trim_around_shared(ip, got, &shared);\n\tif (error)\n\t\treturn error;\n\n\tif (isnullstartblock(got->br_startblock) ||\n\t    got->br_startblock == DELAYSTARTBLOCK) {\n\t\t \n\t\tif (!(bmv->bmv_iflags & BMV_IF_DELALLOC))\n\t\t\treturn 0;\n\n\t\tp->bmv_oflags |= BMV_OF_DELALLOC;\n\t\tp->bmv_block = -2;\n\t} else {\n\t\tp->bmv_block = xfs_fsb_to_db(ip, got->br_startblock);\n\t}\n\n\tif (got->br_state == XFS_EXT_UNWRITTEN &&\n\t    (bmv->bmv_iflags & BMV_IF_PREALLOC))\n\t\tp->bmv_oflags |= BMV_OF_PREALLOC;\n\n\tif (shared)\n\t\tp->bmv_oflags |= BMV_OF_SHARED;\n\n\tp->bmv_offset = XFS_FSB_TO_BB(ip->i_mount, got->br_startoff);\n\tp->bmv_length = XFS_FSB_TO_BB(ip->i_mount, got->br_blockcount);\n\n\tbmv->bmv_offset = p->bmv_offset + p->bmv_length;\n\tbmv->bmv_length = max(0LL, bmv_end - bmv->bmv_offset);\n\tbmv->bmv_entries++;\n\treturn 0;\n}\n\nstatic void\nxfs_getbmap_report_hole(\n\tstruct xfs_inode\t*ip,\n\tstruct getbmapx\t\t*bmv,\n\tstruct kgetbmap\t\t*out,\n\tint64_t\t\t\tbmv_end,\n\txfs_fileoff_t\t\tbno,\n\txfs_fileoff_t\t\tend)\n{\n\tstruct kgetbmap\t\t*p = out + bmv->bmv_entries;\n\n\tif (bmv->bmv_iflags & BMV_IF_NO_HOLES)\n\t\treturn;\n\n\tp->bmv_block = -1;\n\tp->bmv_offset = XFS_FSB_TO_BB(ip->i_mount, bno);\n\tp->bmv_length = XFS_FSB_TO_BB(ip->i_mount, end - bno);\n\n\tbmv->bmv_offset = p->bmv_offset + p->bmv_length;\n\tbmv->bmv_length = max(0LL, bmv_end - bmv->bmv_offset);\n\tbmv->bmv_entries++;\n}\n\nstatic inline bool\nxfs_getbmap_full(\n\tstruct getbmapx\t\t*bmv)\n{\n\treturn bmv->bmv_length == 0 || bmv->bmv_entries >= bmv->bmv_count - 1;\n}\n\nstatic bool\nxfs_getbmap_next_rec(\n\tstruct xfs_bmbt_irec\t*rec,\n\txfs_fileoff_t\t\ttotal_end)\n{\n\txfs_fileoff_t\t\tend = rec->br_startoff + rec->br_blockcount;\n\n\tif (end == total_end)\n\t\treturn false;\n\n\trec->br_startoff += rec->br_blockcount;\n\tif (!isnullstartblock(rec->br_startblock) &&\n\t    rec->br_startblock != DELAYSTARTBLOCK)\n\t\trec->br_startblock += rec->br_blockcount;\n\trec->br_blockcount = total_end - end;\n\treturn true;\n}\n\n \nint\t\t\t\t\t\t \nxfs_getbmap(\n\tstruct xfs_inode\t*ip,\n\tstruct getbmapx\t\t*bmv,\t\t \n\tstruct kgetbmap\t\t*out)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tiflags = bmv->bmv_iflags;\n\tint\t\t\twhichfork, lock, error = 0;\n\tint64_t\t\t\tbmv_end, max_len;\n\txfs_fileoff_t\t\tbno, first_bno;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot, rec;\n\txfs_filblks_t\t\tlen;\n\tstruct xfs_iext_cursor\ticur;\n\n\tif (bmv->bmv_iflags & ~BMV_IF_VALID)\n\t\treturn -EINVAL;\n#ifndef DEBUG\n\t \n\tif (iflags & BMV_IF_COWFORK)\n\t\treturn -EINVAL;\n#endif\n\tif ((iflags & BMV_IF_ATTRFORK) && (iflags & BMV_IF_COWFORK))\n\t\treturn -EINVAL;\n\n\tif (bmv->bmv_length < -1)\n\t\treturn -EINVAL;\n\tbmv->bmv_entries = 0;\n\tif (bmv->bmv_length == 0)\n\t\treturn 0;\n\n\tif (iflags & BMV_IF_ATTRFORK)\n\t\twhichfork = XFS_ATTR_FORK;\n\telse if (iflags & BMV_IF_COWFORK)\n\t\twhichfork = XFS_COW_FORK;\n\telse\n\t\twhichfork = XFS_DATA_FORK;\n\n\txfs_ilock(ip, XFS_IOLOCK_SHARED);\n\tswitch (whichfork) {\n\tcase XFS_ATTR_FORK:\n\t\tlock = xfs_ilock_attr_map_shared(ip);\n\t\tif (!xfs_inode_has_attr_fork(ip))\n\t\t\tgoto out_unlock_ilock;\n\n\t\tmax_len = 1LL << 32;\n\t\tbreak;\n\tcase XFS_COW_FORK:\n\t\tlock = XFS_ILOCK_SHARED;\n\t\txfs_ilock(ip, lock);\n\n\t\t \n\t\tif (!xfs_ifork_ptr(ip, whichfork))\n\t\t\tgoto out_unlock_ilock;\n\n\t\tif (xfs_get_cowextsz_hint(ip))\n\t\t\tmax_len = mp->m_super->s_maxbytes;\n\t\telse\n\t\t\tmax_len = XFS_ISIZE(ip);\n\t\tbreak;\n\tcase XFS_DATA_FORK:\n\t\tif (!(iflags & BMV_IF_DELALLOC) &&\n\t\t    (ip->i_delayed_blks || XFS_ISIZE(ip) > ip->i_disk_size)) {\n\t\t\terror = filemap_write_and_wait(VFS_I(ip)->i_mapping);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock_iolock;\n\n\t\t\t \n\t\t}\n\n\t\tif (xfs_get_extsz_hint(ip) ||\n\t\t    (ip->i_diflags &\n\t\t     (XFS_DIFLAG_PREALLOC | XFS_DIFLAG_APPEND)))\n\t\t\tmax_len = mp->m_super->s_maxbytes;\n\t\telse\n\t\t\tmax_len = XFS_ISIZE(ip);\n\n\t\tlock = xfs_ilock_data_map_shared(ip);\n\t\tbreak;\n\t}\n\n\tifp = xfs_ifork_ptr(ip, whichfork);\n\n\tswitch (ifp->if_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\t \n\t\tgoto out_unlock_ilock;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tgoto out_unlock_ilock;\n\t}\n\n\tif (bmv->bmv_length == -1) {\n\t\tmax_len = XFS_FSB_TO_BB(mp, XFS_B_TO_FSB(mp, max_len));\n\t\tbmv->bmv_length = max(0LL, max_len - bmv->bmv_offset);\n\t}\n\n\tbmv_end = bmv->bmv_offset + bmv->bmv_length;\n\n\tfirst_bno = bno = XFS_BB_TO_FSBT(mp, bmv->bmv_offset);\n\tlen = XFS_BB_TO_FSB(mp, bmv->bmv_length);\n\n\terror = xfs_iread_extents(NULL, ip, whichfork);\n\tif (error)\n\t\tgoto out_unlock_ilock;\n\n\tif (!xfs_iext_lookup_extent(ip, ifp, bno, &icur, &got)) {\n\t\t \n\t\tif (iflags & BMV_IF_DELALLOC)\n\t\t\txfs_getbmap_report_hole(ip, bmv, out, bmv_end, bno,\n\t\t\t\t\tXFS_B_TO_FSB(mp, XFS_ISIZE(ip)));\n\t\tgoto out_unlock_ilock;\n\t}\n\n\twhile (!xfs_getbmap_full(bmv)) {\n\t\txfs_trim_extent(&got, first_bno, len);\n\n\t\t \n\t\tif (got.br_startoff > bno) {\n\t\t\txfs_getbmap_report_hole(ip, bmv, out, bmv_end, bno,\n\t\t\t\t\tgot.br_startoff);\n\t\t\tif (xfs_getbmap_full(bmv))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tbno = got.br_startoff + got.br_blockcount;\n\t\trec = got;\n\t\tdo {\n\t\t\terror = xfs_getbmap_report_one(ip, bmv, out, bmv_end,\n\t\t\t\t\t&rec);\n\t\t\tif (error || xfs_getbmap_full(bmv))\n\t\t\t\tgoto out_unlock_ilock;\n\t\t} while (xfs_getbmap_next_rec(&rec, bno));\n\n\t\tif (!xfs_iext_next_extent(ifp, &icur, &got)) {\n\t\t\txfs_fileoff_t\tend = XFS_B_TO_FSB(mp, XFS_ISIZE(ip));\n\n\t\t\tif (bmv->bmv_entries > 0)\n\t\t\t\tout[bmv->bmv_entries - 1].bmv_oflags |=\n\t\t\t\t\t\t\t\tBMV_OF_LAST;\n\n\t\t\tif (whichfork != XFS_ATTR_FORK && bno < end &&\n\t\t\t    !xfs_getbmap_full(bmv)) {\n\t\t\t\txfs_getbmap_report_hole(ip, bmv, out, bmv_end,\n\t\t\t\t\t\tbno, end);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (bno >= first_bno + len)\n\t\t\tbreak;\n\t}\n\nout_unlock_ilock:\n\txfs_iunlock(ip, lock);\nout_unlock_iolock:\n\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\treturn error;\n}\n\n \nint\nxfs_bmap_punch_delalloc_range(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\tstart_byte,\n\txfs_off_t\t\tend_byte)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp = &ip->i_df;\n\txfs_fileoff_t\t\tstart_fsb = XFS_B_TO_FSBT(mp, start_byte);\n\txfs_fileoff_t\t\tend_fsb = XFS_B_TO_FSB(mp, end_byte);\n\tstruct xfs_bmbt_irec\tgot, del;\n\tstruct xfs_iext_cursor\ticur;\n\tint\t\t\terror = 0;\n\n\tASSERT(!xfs_need_iread_extents(ifp));\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tif (!xfs_iext_lookup_extent_before(ip, ifp, &end_fsb, &icur, &got))\n\t\tgoto out_unlock;\n\n\twhile (got.br_startoff + got.br_blockcount > start_fsb) {\n\t\tdel = got;\n\t\txfs_trim_extent(&del, start_fsb, end_fsb - start_fsb);\n\n\t\t \n\t\tif (!del.br_blockcount ||\n\t\t    !isnullstartblock(del.br_startblock)) {\n\t\t\tif (!xfs_iext_prev_extent(ifp, &icur, &got))\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = xfs_bmap_del_extent_delay(ip, XFS_DATA_FORK, &icur,\n\t\t\t\t\t\t  &got, &del);\n\t\tif (error || !xfs_iext_get_extent(ifp, &icur, &got))\n\t\t\tbreak;\n\t}\n\nout_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\n \nbool\nxfs_can_free_eofblocks(\n\tstruct xfs_inode\t*ip,\n\tbool\t\t\tforce)\n{\n\tstruct xfs_bmbt_irec\timap;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\tend_fsb;\n\txfs_fileoff_t\t\tlast_fsb;\n\tint\t\t\tnimaps = 1;\n\tint\t\t\terror;\n\n\t \n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL) ||\n\t       (VFS_I(ip)->i_state & I_FREEING));\n\n\t \n\tif (!S_ISREG(VFS_I(ip)->i_mode))\n\t\treturn false;\n\n\t \n\tif (VFS_I(ip)->i_size == 0 &&\n\t    VFS_I(ip)->i_mapping->nrpages == 0 &&\n\t    ip->i_delayed_blks == 0)\n\t\treturn false;\n\n\t \n\tif (xfs_need_iread_extents(&ip->i_df))\n\t\treturn false;\n\n\t \n\tif (ip->i_diflags & (XFS_DIFLAG_PREALLOC | XFS_DIFLAG_APPEND))\n\t\tif (!force || ip->i_delayed_blks == 0)\n\t\t\treturn false;\n\n\t \n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)XFS_ISIZE(ip));\n\tif (XFS_IS_REALTIME_INODE(ip) && mp->m_sb.sb_rextsize > 1)\n\t\tend_fsb = roundup_64(end_fsb, mp->m_sb.sb_rextsize);\n\tlast_fsb = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (last_fsb <= end_fsb)\n\t\treturn false;\n\n\t \n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\terror = xfs_bmapi_read(ip, end_fsb, last_fsb - end_fsb, &imap, &nimaps,\n\t\t\t0);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\tif (error || nimaps == 0)\n\t\treturn false;\n\n\t \n\treturn imap.br_startblock != HOLESTARTBLOCK || ip->i_delayed_blks;\n}\n\n \nint\nxfs_free_eofblocks(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\terror;\n\n\t \n\terror = xfs_qm_dqattach(ip);\n\tif (error)\n\t\treturn error;\n\n\t \n\tinode_dio_wait(VFS_I(ip));\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_itruncate, 0, 0, 0, &tp);\n\tif (error) {\n\t\tASSERT(xfs_is_shutdown(mp));\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t \n\terror = xfs_itruncate_extents_flags(&tp, ip, XFS_DATA_FORK,\n\t\t\t\tXFS_ISIZE(ip), XFS_BMAPI_NODISCARD);\n\tif (error)\n\t\tgoto err_cancel;\n\n\terror = xfs_trans_commit(tp);\n\tif (error)\n\t\tgoto out_unlock;\n\n\txfs_inode_clear_eofblocks_tag(ip);\n\tgoto out_unlock;\n\nerr_cancel:\n\t \n\txfs_trans_cancel(tp);\nout_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\nint\nxfs_alloc_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\txfs_off_t\t\tcount;\n\txfs_filblks_t\t\tallocated_fsb;\n\txfs_filblks_t\t\tallocatesize_fsb;\n\txfs_extlen_t\t\textsz, temp;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_fileoff_t\t\tendoffset_fsb;\n\tint\t\t\tnimaps;\n\tint\t\t\trt;\n\txfs_trans_t\t\t*tp;\n\txfs_bmbt_irec_t\t\timaps[1], *imapp;\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_file_space(ip);\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(ip);\n\tif (error)\n\t\treturn error;\n\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\trt = XFS_IS_REALTIME_INODE(ip);\n\textsz = xfs_get_extsz_hint(ip);\n\n\tcount = len;\n\timapp = &imaps[0];\n\tnimaps = 1;\n\tstartoffset_fsb\t= XFS_B_TO_FSBT(mp, offset);\n\tendoffset_fsb = XFS_B_TO_FSB(mp, offset + count);\n\tallocatesize_fsb = endoffset_fsb - startoffset_fsb;\n\n\t \n\twhile (allocatesize_fsb && !error) {\n\t\txfs_fileoff_t\ts, e;\n\t\tunsigned int\tdblocks, rblocks, resblks;\n\n\t\t \n\t\tif (unlikely(extsz)) {\n\t\t\ts = startoffset_fsb;\n\t\t\tdo_div(s, extsz);\n\t\t\ts *= extsz;\n\t\t\te = startoffset_fsb + allocatesize_fsb;\n\t\t\tdiv_u64_rem(startoffset_fsb, extsz, &temp);\n\t\t\tif (temp)\n\t\t\t\te += temp;\n\t\t\tdiv_u64_rem(e, extsz, &temp);\n\t\t\tif (temp)\n\t\t\t\te += extsz - temp;\n\t\t} else {\n\t\t\ts = 0;\n\t\t\te = allocatesize_fsb;\n\t\t}\n\n\t\t \n\t\tresblks = min_t(xfs_fileoff_t, (e - s),\n\t\t\t\t(XFS_MAX_BMBT_EXTLEN * nimaps));\n\t\tif (unlikely(rt)) {\n\t\t\tdblocks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\t\t\trblocks = resblks;\n\t\t} else {\n\t\t\tdblocks = XFS_DIOSTRAT_SPACE_RES(mp, resblks);\n\t\t\trblocks = 0;\n\t\t}\n\n\t\terror = xfs_trans_alloc_inode(ip, &M_RES(mp)->tr_write,\n\t\t\t\tdblocks, rblocks, false, &tp);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\terror = xfs_iext_count_may_overflow(ip, XFS_DATA_FORK,\n\t\t\t\tXFS_IEXT_ADD_NOSPLIT_CNT);\n\t\tif (error == -EFBIG)\n\t\t\terror = xfs_iext_count_upgrade(tp, ip,\n\t\t\t\t\tXFS_IEXT_ADD_NOSPLIT_CNT);\n\t\tif (error)\n\t\t\tgoto error;\n\n\t\terror = xfs_bmapi_write(tp, ip, startoffset_fsb,\n\t\t\t\tallocatesize_fsb, XFS_BMAPI_PREALLOC, 0, imapp,\n\t\t\t\t&nimaps);\n\t\tif (error)\n\t\t\tgoto error;\n\n\t\tip->i_diflags |= XFS_DIFLAG_PREALLOC;\n\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\t\terror = xfs_trans_commit(tp);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tallocated_fsb = imapp->br_blockcount;\n\n\t\tif (nimaps == 0) {\n\t\t\terror = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\n\t\tstartoffset_fsb += allocated_fsb;\n\t\tallocatesize_fsb -= allocated_fsb;\n\t}\n\n\treturn error;\n\nerror:\n\txfs_trans_cancel(tp);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\nstatic int\nxfs_unmap_extent(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tstartoffset_fsb,\n\txfs_filblks_t\t\tlen_fsb,\n\tint\t\t\t*done)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tuint\t\t\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\tint\t\t\terror;\n\n\terror = xfs_trans_alloc_inode(ip, &M_RES(mp)->tr_write, resblks, 0,\n\t\t\tfalse, &tp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_iext_count_may_overflow(ip, XFS_DATA_FORK,\n\t\t\tXFS_IEXT_PUNCH_HOLE_CNT);\n\tif (error == -EFBIG)\n\t\terror = xfs_iext_count_upgrade(tp, ip, XFS_IEXT_PUNCH_HOLE_CNT);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\terror = xfs_bunmapi(tp, ip, startoffset_fsb, len_fsb, 0, 2, done);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\terror = xfs_trans_commit(tp);\nout_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp);\n\tgoto out_unlock;\n}\n\n \nint\nxfs_flush_unmap_range(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\txfs_off_t\t\trounding, start, end;\n\tint\t\t\terror;\n\n\trounding = max_t(xfs_off_t, mp->m_sb.sb_blocksize, PAGE_SIZE);\n\tstart = round_down(offset, rounding);\n\tend = round_up(offset + len, rounding) - 1;\n\n\terror = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (error)\n\t\treturn error;\n\ttruncate_pagecache_range(inode, start, end);\n\treturn 0;\n}\n\nint\nxfs_free_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_fileoff_t\t\tendoffset_fsb;\n\tint\t\t\tdone = 0, error;\n\n\ttrace_xfs_free_file_space(ip);\n\n\terror = xfs_qm_dqattach(ip);\n\tif (error)\n\t\treturn error;\n\n\tif (len <= 0)\t \n\t\treturn 0;\n\n\tstartoffset_fsb = XFS_B_TO_FSB(mp, offset);\n\tendoffset_fsb = XFS_B_TO_FSBT(mp, offset + len);\n\n\t \n\tif (XFS_IS_REALTIME_INODE(ip) && mp->m_sb.sb_rextsize > 1) {\n\t\tstartoffset_fsb = roundup_64(startoffset_fsb,\n\t\t\t\t\t     mp->m_sb.sb_rextsize);\n\t\tendoffset_fsb = rounddown_64(endoffset_fsb,\n\t\t\t\t\t     mp->m_sb.sb_rextsize);\n\t}\n\n\t \n\tif (endoffset_fsb > startoffset_fsb) {\n\t\twhile (!done) {\n\t\t\terror = xfs_unmap_extent(ip, startoffset_fsb,\n\t\t\t\t\tendoffset_fsb - startoffset_fsb, &done);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\t \n\tif (offset >= XFS_ISIZE(ip))\n\t\treturn 0;\n\tif (offset + len > XFS_ISIZE(ip))\n\t\tlen = XFS_ISIZE(ip) - offset;\n\terror = xfs_zero_range(ip, offset, len, NULL);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (offset + len >= XFS_ISIZE(ip) && offset_in_page(offset + len) > 0) {\n\t\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\tround_down(offset + len, PAGE_SIZE), LLONG_MAX);\n\t}\n\n\treturn error;\n}\n\nstatic int\nxfs_prepare_shift(\n\tstruct xfs_inode\t*ip,\n\tloff_t\t\t\toffset)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\terror;\n\n\t \n\tif (xfs_can_free_eofblocks(ip, true)) {\n\t\terror = xfs_free_eofblocks(ip);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\toffset = round_down(offset, mp->m_sb.sb_blocksize);\n\tif (offset)\n\t\toffset -= mp->m_sb.sb_blocksize;\n\n\t \n\terror = xfs_flush_unmap_range(ip, offset, XFS_ISIZE(ip));\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (xfs_inode_has_cow_data(ip)) {\n\t\terror = xfs_reflink_cancel_cow_range(ip, offset, NULLFILEOFF,\n\t\t\t\ttrue);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \nint\nxfs_collapse_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\txfs_fileoff_t\t\tnext_fsb = XFS_B_TO_FSB(mp, offset + len);\n\txfs_fileoff_t\t\tshift_fsb = XFS_B_TO_FSB(mp, len);\n\tbool\t\t\tdone = false;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(xfs_isilocked(ip, XFS_MMAPLOCK_EXCL));\n\n\ttrace_xfs_collapse_file_space(ip);\n\n\terror = xfs_free_file_space(ip, offset, len);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_prepare_shift(ip, offset);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_write, 0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\twhile (!done) {\n\t\terror = xfs_bmap_collapse_extents(tp, ip, &next_fsb, shift_fsb,\n\t\t\t\t&done);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t\tif (done)\n\t\t\tbreak;\n\n\t\t \n\t\terror = xfs_defer_finish(&tp);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\terror = xfs_trans_commit(tp);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\n \nint\nxfs_insert_file_space(\n\tstruct xfs_inode\t*ip,\n\tloff_t\t\t\toffset,\n\tloff_t\t\t\tlen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\txfs_fileoff_t\t\tstop_fsb = XFS_B_TO_FSB(mp, offset);\n\txfs_fileoff_t\t\tnext_fsb = NULLFSBLOCK;\n\txfs_fileoff_t\t\tshift_fsb = XFS_B_TO_FSB(mp, len);\n\tbool\t\t\tdone = false;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(xfs_isilocked(ip, XFS_MMAPLOCK_EXCL));\n\n\ttrace_xfs_insert_file_space(ip);\n\n\terror = xfs_bmap_can_insert_extents(ip, stop_fsb, shift_fsb);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_prepare_shift(ip, offset);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_write,\n\t\t\tXFS_DIOSTRAT_SPACE_RES(mp, 0), 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\terror = xfs_iext_count_may_overflow(ip, XFS_DATA_FORK,\n\t\t\tXFS_IEXT_PUNCH_HOLE_CNT);\n\tif (error == -EFBIG)\n\t\terror = xfs_iext_count_upgrade(tp, ip, XFS_IEXT_PUNCH_HOLE_CNT);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\t \n\terror = xfs_bmap_split_extent(tp, ip, stop_fsb);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tdo {\n\t\terror = xfs_defer_finish(&tp);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\terror = xfs_bmap_insert_extents(tp, ip, &next_fsb, shift_fsb,\n\t\t\t\t&done, stop_fsb);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t} while (!done);\n\n\terror = xfs_trans_commit(tp);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\n \nstatic int\nxfs_swap_extents_check_format(\n\tstruct xfs_inode\t*ip,\t \n\tstruct xfs_inode\t*tip)\t \n{\n\tstruct xfs_ifork\t*ifp = &ip->i_df;\n\tstruct xfs_ifork\t*tifp = &tip->i_df;\n\n\t \n\tif (XFS_IS_QUOTA_ON(ip->i_mount) &&\n\t    (!uid_eq(VFS_I(ip)->i_uid, VFS_I(tip)->i_uid) ||\n\t     !gid_eq(VFS_I(ip)->i_gid, VFS_I(tip)->i_gid) ||\n\t     ip->i_projid != tip->i_projid))\n\t\treturn -EINVAL;\n\n\t \n\tif (ifp->if_format == XFS_DINODE_FMT_LOCAL ||\n\t    tifp->if_format == XFS_DINODE_FMT_LOCAL)\n\t\treturn -EINVAL;\n\n\t \n\tif (ifp->if_nextents < tifp->if_nextents)\n\t\treturn -EINVAL;\n\n\t \n\tif (xfs_has_rmapbt(ip->i_mount))\n\t\treturn 0;\n\n\t \n\tif (ifp->if_format == XFS_DINODE_FMT_EXTENTS &&\n\t    tifp->if_format == XFS_DINODE_FMT_BTREE)\n\t\treturn -EINVAL;\n\n\t \n\tif (tifp->if_format == XFS_DINODE_FMT_EXTENTS &&\n\t    tifp->if_nextents > XFS_IFORK_MAXEXT(ip, XFS_DATA_FORK))\n\t\treturn -EINVAL;\n\n\t \n\tif (ifp->if_format == XFS_DINODE_FMT_EXTENTS &&\n\t    ifp->if_nextents > XFS_IFORK_MAXEXT(tip, XFS_DATA_FORK))\n\t\treturn -EINVAL;\n\n\t \n\tif (tifp->if_format == XFS_DINODE_FMT_BTREE) {\n\t\tif (xfs_inode_has_attr_fork(ip) &&\n\t\t    XFS_BMAP_BMDR_SPACE(tifp->if_broot) > xfs_inode_fork_boff(ip))\n\t\t\treturn -EINVAL;\n\t\tif (tifp->if_nextents <= XFS_IFORK_MAXEXT(ip, XFS_DATA_FORK))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ifp->if_format == XFS_DINODE_FMT_BTREE) {\n\t\tif (xfs_inode_has_attr_fork(tip) &&\n\t\t    XFS_BMAP_BMDR_SPACE(ip->i_df.if_broot) > xfs_inode_fork_boff(tip))\n\t\t\treturn -EINVAL;\n\t\tif (ifp->if_nextents <= XFS_IFORK_MAXEXT(tip, XFS_DATA_FORK))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nxfs_swap_extent_flush(\n\tstruct xfs_inode\t*ip)\n{\n\tint\terror;\n\n\terror = filemap_write_and_wait(VFS_I(ip)->i_mapping);\n\tif (error)\n\t\treturn error;\n\ttruncate_pagecache_range(VFS_I(ip), 0, -1);\n\n\t \n\tif (VFS_I(ip)->i_mapping->nrpages)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_swap_extent_rmap(\n\tstruct xfs_trans\t\t**tpp,\n\tstruct xfs_inode\t\t*ip,\n\tstruct xfs_inode\t\t*tip)\n{\n\tstruct xfs_trans\t\t*tp = *tpp;\n\tstruct xfs_bmbt_irec\t\tirec;\n\tstruct xfs_bmbt_irec\t\tuirec;\n\tstruct xfs_bmbt_irec\t\ttirec;\n\txfs_fileoff_t\t\t\toffset_fsb;\n\txfs_fileoff_t\t\t\tend_fsb;\n\txfs_filblks_t\t\t\tcount_fsb;\n\tint\t\t\t\terror;\n\txfs_filblks_t\t\t\tilen;\n\txfs_filblks_t\t\t\trlen;\n\tint\t\t\t\tnimaps;\n\tuint64_t\t\t\ttip_flags2;\n\n\t \n\ttip_flags2 = tip->i_diflags2;\n\tif (ip->i_diflags2 & XFS_DIFLAG2_REFLINK)\n\t\ttip->i_diflags2 |= XFS_DIFLAG2_REFLINK;\n\n\toffset_fsb = 0;\n\tend_fsb = XFS_B_TO_FSB(ip->i_mount, i_size_read(VFS_I(ip)));\n\tcount_fsb = (xfs_filblks_t)(end_fsb - offset_fsb);\n\n\twhile (count_fsb) {\n\t\t \n\t\tnimaps = 1;\n\t\terror = xfs_bmapi_read(tip, offset_fsb, count_fsb, &tirec,\n\t\t\t\t&nimaps, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimaps == 1);\n\t\tASSERT(tirec.br_startblock != DELAYSTARTBLOCK);\n\n\t\ttrace_xfs_swap_extent_rmap_remap(tip, &tirec);\n\t\tilen = tirec.br_blockcount;\n\n\t\t \n\t\twhile (tirec.br_blockcount) {\n\t\t\tASSERT(tp->t_highest_agno == NULLAGNUMBER);\n\t\t\ttrace_xfs_swap_extent_rmap_remap_piece(tip, &tirec);\n\n\t\t\t \n\t\t\tnimaps = 1;\n\t\t\terror = xfs_bmapi_read(ip, tirec.br_startoff,\n\t\t\t\t\ttirec.br_blockcount, &irec,\n\t\t\t\t\t&nimaps, 0);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\tASSERT(nimaps == 1);\n\t\t\tASSERT(tirec.br_startoff == irec.br_startoff);\n\t\t\ttrace_xfs_swap_extent_rmap_remap_piece(ip, &irec);\n\n\t\t\t \n\t\t\tuirec = tirec;\n\t\t\tuirec.br_blockcount = rlen = min_t(xfs_filblks_t,\n\t\t\t\t\ttirec.br_blockcount,\n\t\t\t\t\tirec.br_blockcount);\n\t\t\ttrace_xfs_swap_extent_rmap_remap_piece(tip, &uirec);\n\n\t\t\tif (xfs_bmap_is_real_extent(&uirec)) {\n\t\t\t\terror = xfs_iext_count_may_overflow(ip,\n\t\t\t\t\t\tXFS_DATA_FORK,\n\t\t\t\t\t\tXFS_IEXT_SWAP_RMAP_CNT);\n\t\t\t\tif (error == -EFBIG)\n\t\t\t\t\terror = xfs_iext_count_upgrade(tp, ip,\n\t\t\t\t\t\t\tXFS_IEXT_SWAP_RMAP_CNT);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (xfs_bmap_is_real_extent(&irec)) {\n\t\t\t\terror = xfs_iext_count_may_overflow(tip,\n\t\t\t\t\t\tXFS_DATA_FORK,\n\t\t\t\t\t\tXFS_IEXT_SWAP_RMAP_CNT);\n\t\t\t\tif (error == -EFBIG)\n\t\t\t\t\terror = xfs_iext_count_upgrade(tp, ip,\n\t\t\t\t\t\t\tXFS_IEXT_SWAP_RMAP_CNT);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\txfs_bmap_unmap_extent(tp, tip, &uirec);\n\n\t\t\t \n\t\t\txfs_bmap_unmap_extent(tp, ip, &irec);\n\n\t\t\t \n\t\t\txfs_bmap_map_extent(tp, ip, &uirec);\n\n\t\t\t \n\t\t\txfs_bmap_map_extent(tp, tip, &irec);\n\n\t\t\terror = xfs_defer_finish(tpp);\n\t\t\ttp = *tpp;\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\ttirec.br_startoff += rlen;\n\t\t\tif (tirec.br_startblock != HOLESTARTBLOCK &&\n\t\t\t    tirec.br_startblock != DELAYSTARTBLOCK)\n\t\t\t\ttirec.br_startblock += rlen;\n\t\t\ttirec.br_blockcount -= rlen;\n\t\t}\n\n\t\t \n\t\tcount_fsb -= ilen;\n\t\toffset_fsb += ilen;\n\t}\n\n\ttip->i_diflags2 = tip_flags2;\n\treturn 0;\n\nout:\n\ttrace_xfs_swap_extent_rmap_error(ip, error, _RET_IP_);\n\ttip->i_diflags2 = tip_flags2;\n\treturn error;\n}\n\n \nSTATIC int\nxfs_swap_extent_forks(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_inode\t*tip,\n\tint\t\t\t*src_log_flags,\n\tint\t\t\t*target_log_flags)\n{\n\txfs_filblks_t\t\taforkblks = 0;\n\txfs_filblks_t\t\ttaforkblks = 0;\n\txfs_extnum_t\t\tjunk;\n\tuint64_t\t\ttmp;\n\tint\t\t\terror;\n\n\t \n\tif (xfs_inode_has_attr_fork(ip) && ip->i_af.if_nextents > 0 &&\n\t    ip->i_af.if_format != XFS_DINODE_FMT_LOCAL) {\n\t\terror = xfs_bmap_count_blocks(tp, ip, XFS_ATTR_FORK, &junk,\n\t\t\t\t&aforkblks);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (xfs_inode_has_attr_fork(tip) && tip->i_af.if_nextents > 0 &&\n\t    tip->i_af.if_format != XFS_DINODE_FMT_LOCAL) {\n\t\terror = xfs_bmap_count_blocks(tp, tip, XFS_ATTR_FORK, &junk,\n\t\t\t\t&taforkblks);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\tif (xfs_has_v3inodes(ip->i_mount)) {\n\t\tif (ip->i_df.if_format == XFS_DINODE_FMT_BTREE)\n\t\t\t(*target_log_flags) |= XFS_ILOG_DOWNER;\n\t\tif (tip->i_df.if_format == XFS_DINODE_FMT_BTREE)\n\t\t\t(*src_log_flags) |= XFS_ILOG_DOWNER;\n\t}\n\n\t \n\tswap(ip->i_df, tip->i_df);\n\n\t \n\ttmp = (uint64_t)ip->i_nblocks;\n\tip->i_nblocks = tip->i_nblocks - taforkblks + aforkblks;\n\ttip->i_nblocks = tmp + taforkblks - aforkblks;\n\n\t \n\tASSERT(tip->i_delayed_blks == 0);\n\ttip->i_delayed_blks = ip->i_delayed_blks;\n\tip->i_delayed_blks = 0;\n\n\tswitch (ip->i_df.if_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t(*src_log_flags) |= XFS_ILOG_DEXT;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tASSERT(!xfs_has_v3inodes(ip->i_mount) ||\n\t\t       (*src_log_flags & XFS_ILOG_DOWNER));\n\t\t(*src_log_flags) |= XFS_ILOG_DBROOT;\n\t\tbreak;\n\t}\n\n\tswitch (tip->i_df.if_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t(*target_log_flags) |= XFS_ILOG_DEXT;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\t(*target_log_flags) |= XFS_ILOG_DBROOT;\n\t\tASSERT(!xfs_has_v3inodes(ip->i_mount) ||\n\t\t       (*target_log_flags & XFS_ILOG_DOWNER));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nxfs_swap_change_owner(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_inode\t*tmpip)\n{\n\tint\t\t\terror;\n\tstruct xfs_trans\t*tp = *tpp;\n\n\tdo {\n\t\terror = xfs_bmbt_change_owner(tp, ip, XFS_DATA_FORK, ip->i_ino,\n\t\t\t\t\t      NULL);\n\t\t \n\t\tif (error != -EAGAIN)\n\t\t\tbreak;\n\n\t\terror = xfs_trans_roll(tpp);\n\t\tif (error)\n\t\t\tbreak;\n\t\ttp = *tpp;\n\n\t\t \n\t\txfs_trans_ijoin(tp, ip, 0);\n\t\txfs_trans_ijoin(tp, tmpip, 0);\n\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t\txfs_trans_log_inode(tp, tmpip, XFS_ILOG_CORE);\n\t} while (true);\n\n\treturn error;\n}\n\nint\nxfs_swap_extents(\n\tstruct xfs_inode\t*ip,\t \n\tstruct xfs_inode\t*tip,\t \n\tstruct xfs_swapext\t*sxp)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_bstat\t*sbp = &sxp->sx_stat;\n\tint\t\t\tsrc_log_flags, target_log_flags;\n\tint\t\t\terror = 0;\n\tuint64_t\t\tf;\n\tint\t\t\tresblks = 0;\n\tunsigned int\t\tflags = 0;\n\tstruct timespec64\tctime;\n\n\t \n\tlock_two_nondirectories(VFS_I(ip), VFS_I(tip));\n\tfilemap_invalidate_lock_two(VFS_I(ip)->i_mapping,\n\t\t\t\t    VFS_I(tip)->i_mapping);\n\n\t \n\tif ((VFS_I(ip)->i_mode & S_IFMT) != (VFS_I(tip)->i_mode & S_IFMT)) {\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (XFS_IS_REALTIME_INODE(ip) != XFS_IS_REALTIME_INODE(tip)) {\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\terror = xfs_qm_dqattach(ip);\n\tif (error)\n\t\tgoto out_unlock;\n\n\terror = xfs_qm_dqattach(tip);\n\tif (error)\n\t\tgoto out_unlock;\n\n\terror = xfs_swap_extent_flush(ip);\n\tif (error)\n\t\tgoto out_unlock;\n\terror = xfs_swap_extent_flush(tip);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tif (xfs_inode_has_cow_data(tip)) {\n\t\terror = xfs_reflink_cancel_cow_range(tip, 0, NULLFILEOFF, true);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (xfs_has_rmapbt(mp)) {\n\t\tint\t\tw = XFS_DATA_FORK;\n\t\tuint32_t\tipnext = ip->i_df.if_nextents;\n\t\tuint32_t\ttipnext\t= tip->i_df.if_nextents;\n\n\t\t \n\t\tresblks = XFS_SWAP_RMAP_SPACE_RES(mp, ipnext, w);\n\t\tresblks +=  XFS_SWAP_RMAP_SPACE_RES(mp, tipnext, w);\n\n\t\t \n\t\tflags |= XFS_TRANS_RES_FDBLKS;\n\t}\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_write, resblks, 0, flags,\n\t\t\t\t&tp);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t \n\txfs_lock_two_inodes(ip, XFS_ILOCK_EXCL, tip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\txfs_trans_ijoin(tp, tip, 0);\n\n\n\t \n\tif (sxp->sx_offset != 0 ||\n\t    sxp->sx_length != ip->i_disk_size ||\n\t    sxp->sx_length != tip->i_disk_size) {\n\t\terror = -EFAULT;\n\t\tgoto out_trans_cancel;\n\t}\n\n\ttrace_xfs_swap_extent_before(ip, 0);\n\ttrace_xfs_swap_extent_before(tip, 1);\n\n\t \n\terror = xfs_swap_extents_check_format(ip, tip);\n\tif (error) {\n\t\txfs_notice(mp,\n\t\t    \"%s: inode 0x%llx format is incompatible for exchanging.\",\n\t\t\t\t__func__, ip->i_ino);\n\t\tgoto out_trans_cancel;\n\t}\n\n\t \n\tctime = inode_get_ctime(VFS_I(ip));\n\tif ((sbp->bs_ctime.tv_sec != ctime.tv_sec) ||\n\t    (sbp->bs_ctime.tv_nsec != ctime.tv_nsec) ||\n\t    (sbp->bs_mtime.tv_sec != VFS_I(ip)->i_mtime.tv_sec) ||\n\t    (sbp->bs_mtime.tv_nsec != VFS_I(ip)->i_mtime.tv_nsec)) {\n\t\terror = -EBUSY;\n\t\tgoto out_trans_cancel;\n\t}\n\n\t \n\tsrc_log_flags = XFS_ILOG_CORE;\n\ttarget_log_flags = XFS_ILOG_CORE;\n\n\tif (xfs_has_rmapbt(mp))\n\t\terror = xfs_swap_extent_rmap(&tp, ip, tip);\n\telse\n\t\terror = xfs_swap_extent_forks(tp, ip, tip, &src_log_flags,\n\t\t\t\t&target_log_flags);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\t \n\tif ((ip->i_diflags2 & XFS_DIFLAG2_REFLINK) ^\n\t    (tip->i_diflags2 & XFS_DIFLAG2_REFLINK)) {\n\t\tf = ip->i_diflags2 & XFS_DIFLAG2_REFLINK;\n\t\tip->i_diflags2 &= ~XFS_DIFLAG2_REFLINK;\n\t\tip->i_diflags2 |= tip->i_diflags2 & XFS_DIFLAG2_REFLINK;\n\t\ttip->i_diflags2 &= ~XFS_DIFLAG2_REFLINK;\n\t\ttip->i_diflags2 |= f & XFS_DIFLAG2_REFLINK;\n\t}\n\n\t \n\tif (xfs_has_reflink(mp)) {\n\t\tASSERT(!ip->i_cowfp ||\n\t\t       ip->i_cowfp->if_format == XFS_DINODE_FMT_EXTENTS);\n\t\tASSERT(!tip->i_cowfp ||\n\t\t       tip->i_cowfp->if_format == XFS_DINODE_FMT_EXTENTS);\n\n\t\tswap(ip->i_cowfp, tip->i_cowfp);\n\n\t\tif (ip->i_cowfp && ip->i_cowfp->if_bytes)\n\t\t\txfs_inode_set_cowblocks_tag(ip);\n\t\telse\n\t\t\txfs_inode_clear_cowblocks_tag(ip);\n\t\tif (tip->i_cowfp && tip->i_cowfp->if_bytes)\n\t\t\txfs_inode_set_cowblocks_tag(tip);\n\t\telse\n\t\t\txfs_inode_clear_cowblocks_tag(tip);\n\t}\n\n\txfs_trans_log_inode(tp, ip,  src_log_flags);\n\txfs_trans_log_inode(tp, tip, target_log_flags);\n\n\t \n\tif (src_log_flags & XFS_ILOG_DOWNER) {\n\t\terror = xfs_swap_change_owner(&tp, ip, tip);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\tif (target_log_flags & XFS_ILOG_DOWNER) {\n\t\terror = xfs_swap_change_owner(&tp, tip, ip);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\t \n\tif (xfs_has_wsync(mp))\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp);\n\n\ttrace_xfs_swap_extent_after(ip, 0);\n\ttrace_xfs_swap_extent_after(tip, 1);\n\nout_unlock_ilock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\txfs_iunlock(tip, XFS_ILOCK_EXCL);\nout_unlock:\n\tfilemap_invalidate_unlock_two(VFS_I(ip)->i_mapping,\n\t\t\t\t      VFS_I(tip)->i_mapping);\n\tunlock_two_nondirectories(VFS_I(ip), VFS_I(tip));\n\treturn error;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp);\n\tgoto out_unlock_ilock;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}