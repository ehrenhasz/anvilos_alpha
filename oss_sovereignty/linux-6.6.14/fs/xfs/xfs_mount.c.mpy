{
  "module_name": "xfs_mount.c",
  "hash_id": "76fcc3915110ca4231a09563641a8279ecd1737340f5afa46bc3b651ff151946",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_mount.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_rmap_btree.h\"\n#include \"xfs_refcount_btree.h\"\n#include \"xfs_reflink.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_health.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ag.h\"\n#include \"scrub/stats.h\"\n\nstatic DEFINE_MUTEX(xfs_uuid_table_mutex);\nstatic int xfs_uuid_table_size;\nstatic uuid_t *xfs_uuid_table;\n\nvoid\nxfs_uuid_table_free(void)\n{\n\tif (xfs_uuid_table_size == 0)\n\t\treturn;\n\tkmem_free(xfs_uuid_table);\n\txfs_uuid_table = NULL;\n\txfs_uuid_table_size = 0;\n}\n\n \nSTATIC int\nxfs_uuid_mount(\n\tstruct xfs_mount\t*mp)\n{\n\tuuid_t\t\t\t*uuid = &mp->m_sb.sb_uuid;\n\tint\t\t\thole, i;\n\n\t \n\tuuid_copy(&mp->m_super->s_uuid, uuid);\n\n\tif (xfs_has_nouuid(mp))\n\t\treturn 0;\n\n\tif (uuid_is_null(uuid)) {\n\t\txfs_warn(mp, \"Filesystem has null UUID - can't mount\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&xfs_uuid_table_mutex);\n\tfor (i = 0, hole = -1; i < xfs_uuid_table_size; i++) {\n\t\tif (uuid_is_null(&xfs_uuid_table[i])) {\n\t\t\thole = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (uuid_equal(uuid, &xfs_uuid_table[i]))\n\t\t\tgoto out_duplicate;\n\t}\n\n\tif (hole < 0) {\n\t\txfs_uuid_table = krealloc(xfs_uuid_table,\n\t\t\t(xfs_uuid_table_size + 1) * sizeof(*xfs_uuid_table),\n\t\t\tGFP_KERNEL | __GFP_NOFAIL);\n\t\thole = xfs_uuid_table_size++;\n\t}\n\txfs_uuid_table[hole] = *uuid;\n\tmutex_unlock(&xfs_uuid_table_mutex);\n\n\treturn 0;\n\n out_duplicate:\n\tmutex_unlock(&xfs_uuid_table_mutex);\n\txfs_warn(mp, \"Filesystem has duplicate UUID %pU - can't mount\", uuid);\n\treturn -EINVAL;\n}\n\nSTATIC void\nxfs_uuid_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\tuuid_t\t\t\t*uuid = &mp->m_sb.sb_uuid;\n\tint\t\t\ti;\n\n\tif (xfs_has_nouuid(mp))\n\t\treturn;\n\n\tmutex_lock(&xfs_uuid_table_mutex);\n\tfor (i = 0; i < xfs_uuid_table_size; i++) {\n\t\tif (uuid_is_null(&xfs_uuid_table[i]))\n\t\t\tcontinue;\n\t\tif (!uuid_equal(uuid, &xfs_uuid_table[i]))\n\t\t\tcontinue;\n\t\tmemset(&xfs_uuid_table[i], 0, sizeof(uuid_t));\n\t\tbreak;\n\t}\n\tASSERT(i < xfs_uuid_table_size);\n\tmutex_unlock(&xfs_uuid_table_mutex);\n}\n\n \nint\nxfs_sb_validate_fsb_count(\n\txfs_sb_t\t*sbp,\n\tuint64_t\tnblocks)\n{\n\tASSERT(PAGE_SHIFT >= sbp->sb_blocklog);\n\tASSERT(sbp->sb_blocklog >= BBSHIFT);\n\n\t \n\tif (nblocks >> (PAGE_SHIFT - sbp->sb_blocklog) > ULONG_MAX)\n\t\treturn -EFBIG;\n\treturn 0;\n}\n\n \nint\nxfs_readsb(\n\tstruct xfs_mount *mp,\n\tint\t\tflags)\n{\n\tunsigned int\tsector_size;\n\tstruct xfs_buf\t*bp;\n\tstruct xfs_sb\t*sbp = &mp->m_sb;\n\tint\t\terror;\n\tint\t\tloud = !(flags & XFS_MFSI_QUIET);\n\tconst struct xfs_buf_ops *buf_ops;\n\n\tASSERT(mp->m_sb_bp == NULL);\n\tASSERT(mp->m_ddev_targp != NULL);\n\n\t \n\tsector_size = xfs_getsize_buftarg(mp->m_ddev_targp);\n\tbuf_ops = NULL;\n\n\t \nreread:\n\terror = xfs_buf_read_uncached(mp->m_ddev_targp, XFS_SB_DADDR,\n\t\t\t\t      BTOBB(sector_size), XBF_NO_IOACCT, &bp,\n\t\t\t\t      buf_ops);\n\tif (error) {\n\t\tif (loud)\n\t\t\txfs_warn(mp, \"SB validate failed with error %d.\", error);\n\t\t \n\t\tif (error == -EFSBADCRC)\n\t\t\terror = -EFSCORRUPTED;\n\t\treturn error;\n\t}\n\n\t \n\txfs_sb_from_disk(sbp, bp->b_addr);\n\n\t \n\tif (sbp->sb_magicnum != XFS_SB_MAGIC) {\n\t\tif (loud)\n\t\t\txfs_warn(mp, \"Invalid superblock magic number\");\n\t\terror = -EINVAL;\n\t\tgoto release_buf;\n\t}\n\n\t \n\tif (sector_size > sbp->sb_sectsize) {\n\t\tif (loud)\n\t\t\txfs_warn(mp, \"device supports %u byte sectors (not %u)\",\n\t\t\t\tsector_size, sbp->sb_sectsize);\n\t\terror = -ENOSYS;\n\t\tgoto release_buf;\n\t}\n\n\tif (buf_ops == NULL) {\n\t\t \n\t\txfs_buf_relse(bp);\n\t\tsector_size = sbp->sb_sectsize;\n\t\tbuf_ops = loud ? &xfs_sb_buf_ops : &xfs_sb_quiet_buf_ops;\n\t\tgoto reread;\n\t}\n\n\tmp->m_features |= xfs_sb_version_to_features(sbp);\n\txfs_reinit_percpu_counters(mp);\n\n\t \n\tbp->b_ops = &xfs_sb_buf_ops;\n\n\tmp->m_sb_bp = bp;\n\txfs_buf_unlock(bp);\n\treturn 0;\n\nrelease_buf:\n\txfs_buf_relse(bp);\n\treturn error;\n}\n\n \nstatic inline int\nxfs_check_new_dalign(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tnew_dalign,\n\tbool\t\t\t*update_sb)\n{\n\tstruct xfs_sb\t\t*sbp = &mp->m_sb;\n\txfs_ino_t\t\tcalc_ino;\n\n\tcalc_ino = xfs_ialloc_calc_rootino(mp, new_dalign);\n\ttrace_xfs_check_new_dalign(mp, new_dalign, calc_ino);\n\n\tif (sbp->sb_rootino == calc_ino) {\n\t\t*update_sb = true;\n\t\treturn 0;\n\t}\n\n\txfs_warn(mp,\n\"Cannot change stripe alignment; would require moving root inode.\");\n\n\t \n\txfs_warn(mp, \"Skipping superblock stripe alignment update.\");\n\t*update_sb = false;\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_validate_new_dalign(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_dalign == 0)\n\t\treturn 0;\n\n\t \n\tif ((BBTOB(mp->m_dalign) & mp->m_blockmask) ||\n\t    (BBTOB(mp->m_swidth) & mp->m_blockmask)) {\n\t\txfs_warn(mp,\n\t\"alignment check failed: sunit/swidth vs. blocksize(%d)\",\n\t\t\tmp->m_sb.sb_blocksize);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmp->m_dalign = XFS_BB_TO_FSBT(mp, mp->m_dalign);\n\tif (mp->m_dalign && (mp->m_sb.sb_agblocks % mp->m_dalign)) {\n\t\txfs_warn(mp,\n\t\"alignment check failed: sunit/swidth vs. agsize(%d)\",\n\t\t\tmp->m_sb.sb_agblocks);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!mp->m_dalign) {\n\t\txfs_warn(mp,\n\t\"alignment check failed: sunit(%d) less than bsize(%d)\",\n\t\t\tmp->m_dalign, mp->m_sb.sb_blocksize);\n\t\treturn -EINVAL;\n\t}\n\n\tmp->m_swidth = XFS_BB_TO_FSBT(mp, mp->m_swidth);\n\n\tif (!xfs_has_dalign(mp)) {\n\t\txfs_warn(mp,\n\"cannot change alignment: superblock does not support data alignment\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_update_alignment(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_sb\t\t*sbp = &mp->m_sb;\n\n\tif (mp->m_dalign) {\n\t\tbool\t\tupdate_sb;\n\t\tint\t\terror;\n\n\t\tif (sbp->sb_unit == mp->m_dalign &&\n\t\t    sbp->sb_width == mp->m_swidth)\n\t\t\treturn 0;\n\n\t\terror = xfs_check_new_dalign(mp, mp->m_dalign, &update_sb);\n\t\tif (error || !update_sb)\n\t\t\treturn error;\n\n\t\tsbp->sb_unit = mp->m_dalign;\n\t\tsbp->sb_width = mp->m_swidth;\n\t\tmp->m_update_sb = true;\n\t} else if (!xfs_has_noalign(mp) && xfs_has_dalign(mp)) {\n\t\tmp->m_dalign = sbp->sb_unit;\n\t\tmp->m_swidth = sbp->sb_width;\n\t}\n\n\treturn 0;\n}\n\n \nvoid\nxfs_set_low_space_thresholds(\n\tstruct xfs_mount\t*mp)\n{\n\tuint64_t\t\tdblocks = mp->m_sb.sb_dblocks;\n\tuint64_t\t\trtexts = mp->m_sb.sb_rextents;\n\tint\t\t\ti;\n\n\tdo_div(dblocks, 100);\n\tdo_div(rtexts, 100);\n\n\tfor (i = 0; i < XFS_LOWSP_MAX; i++) {\n\t\tmp->m_low_space[i] = dblocks * (i + 1);\n\t\tmp->m_low_rtexts[i] = rtexts * (i + 1);\n\t}\n}\n\n \nSTATIC int\nxfs_check_sizes(\n\tstruct xfs_mount *mp)\n{\n\tstruct xfs_buf\t*bp;\n\txfs_daddr_t\td;\n\tint\t\terror;\n\n\td = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks);\n\tif (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_dblocks) {\n\t\txfs_warn(mp, \"filesystem size mismatch detected\");\n\t\treturn -EFBIG;\n\t}\n\terror = xfs_buf_read_uncached(mp->m_ddev_targp,\n\t\t\t\t\td - XFS_FSS_TO_BB(mp, 1),\n\t\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error) {\n\t\txfs_warn(mp, \"last sector read failed\");\n\t\treturn error;\n\t}\n\txfs_buf_relse(bp);\n\n\tif (mp->m_logdev_targp == mp->m_ddev_targp)\n\t\treturn 0;\n\n\td = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_logblocks);\n\tif (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_logblocks) {\n\t\txfs_warn(mp, \"log size mismatch detected\");\n\t\treturn -EFBIG;\n\t}\n\terror = xfs_buf_read_uncached(mp->m_logdev_targp,\n\t\t\t\t\td - XFS_FSB_TO_BB(mp, 1),\n\t\t\t\t\tXFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error) {\n\t\txfs_warn(mp, \"log device read failed\");\n\t\treturn error;\n\t}\n\txfs_buf_relse(bp);\n\treturn 0;\n}\n\n \nint\nxfs_mount_reset_sbqflags(\n\tstruct xfs_mount\t*mp)\n{\n\tmp->m_qflags = 0;\n\n\t \n\tif (mp->m_sb.sb_qflags == 0)\n\t\treturn 0;\n\tspin_lock(&mp->m_sb_lock);\n\tmp->m_sb.sb_qflags = 0;\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (!xfs_fs_writable(mp, SB_FREEZE_WRITE))\n\t\treturn 0;\n\n\treturn xfs_sync_sb(mp, false);\n}\n\nuint64_t\nxfs_default_resblks(xfs_mount_t *mp)\n{\n\tuint64_t resblks;\n\n\t \n\tresblks = mp->m_sb.sb_dblocks;\n\tdo_div(resblks, 20);\n\tresblks = min_t(uint64_t, resblks, 8192);\n\treturn resblks;\n}\n\n \nSTATIC int\nxfs_check_summary_counts(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\terror = 0;\n\n\t \n\tif (mp->m_sb.sb_inprogress) {\n\t\txfs_err(mp, \"sb_inprogress set after log recovery??\");\n\t\tWARN_ON(1);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\tif (xfs_is_clean(mp) &&\n\t    (mp->m_sb.sb_fdblocks > mp->m_sb.sb_dblocks ||\n\t     !xfs_verify_icount(mp, mp->m_sb.sb_icount) ||\n\t     mp->m_sb.sb_ifree > mp->m_sb.sb_icount))\n\t\txfs_fs_mark_sick(mp, XFS_SICK_FS_COUNTERS);\n\n\t \n\tif ((xfs_has_lazysbcount(mp) && !xfs_is_clean(mp)) ||\n\t    xfs_fs_has_sickness(mp, XFS_SICK_FS_COUNTERS)) {\n\t\terror = xfs_initialize_perag_data(mp, mp->m_sb.sb_agcount);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\tif (xfs_has_realtime(mp) && !xfs_is_clean(mp)) {\n\t\terror = xfs_rtalloc_reinit_frextents(mp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nxfs_unmount_check(\n\tstruct xfs_mount\t*mp)\n{\n\tif (xfs_is_shutdown(mp))\n\t\treturn;\n\n\tif (percpu_counter_sum(&mp->m_ifree) >\n\t\t\tpercpu_counter_sum(&mp->m_icount)) {\n\t\txfs_alert(mp, \"ifree/icount mismatch at unmount\");\n\t\txfs_fs_mark_sick(mp, XFS_SICK_FS_COUNTERS);\n\t}\n}\n\n \nstatic void\nxfs_unmount_flush_inodes(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\txfs_extent_busy_wait_all(mp);\n\tflush_workqueue(xfs_discard_wq);\n\n\tset_bit(XFS_OPSTATE_UNMOUNTING, &mp->m_opstate);\n\n\txfs_ail_push_all_sync(mp->m_ail);\n\txfs_inodegc_stop(mp);\n\tcancel_delayed_work_sync(&mp->m_reclaim_work);\n\txfs_reclaim_inodes(mp);\n\txfs_health_unmount(mp);\n}\n\nstatic void\nxfs_mount_setup_inode_geom(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_ino_geometry *igeo = M_IGEO(mp);\n\n\tigeo->attr_fork_offset = xfs_bmap_compute_attr_offset(mp);\n\tASSERT(igeo->attr_fork_offset < XFS_LITINO(mp));\n\n\txfs_ialloc_setup_geometry(mp);\n}\n\n \nstatic inline void\nxfs_agbtree_compute_maxlevels(\n\tstruct xfs_mount\t*mp)\n{\n\tunsigned int\t\tlevels;\n\n\tlevels = max(mp->m_alloc_maxlevels, M_IGEO(mp)->inobt_maxlevels);\n\tlevels = max(levels, mp->m_rmap_maxlevels);\n\tmp->m_agbtree_maxlevels = max(levels, mp->m_refc_maxlevels);\n}\n\n \nint\nxfs_mountfs(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_sb\t\t*sbp = &(mp->m_sb);\n\tstruct xfs_inode\t*rip;\n\tstruct xfs_ino_geometry\t*igeo = M_IGEO(mp);\n\tuint64_t\t\tresblks;\n\tuint\t\t\tquotamount = 0;\n\tuint\t\t\tquotaflags = 0;\n\tint\t\t\terror = 0;\n\n\txfs_sb_mount_common(mp, sbp);\n\n\t \n\tif (xfs_sb_has_mismatched_features2(sbp)) {\n\t\txfs_warn(mp, \"correcting sb_features alignment problem\");\n\t\tsbp->sb_features2 |= sbp->sb_bad_features2;\n\t\tmp->m_update_sb = true;\n\t}\n\n\n\t \n\tif (!(mp->m_sb.sb_versionnum & XFS_SB_VERSION_NLINKBIT)) {\n\t\tmp->m_sb.sb_versionnum |= XFS_SB_VERSION_NLINKBIT;\n\t\tmp->m_features |= XFS_FEAT_NLINK;\n\t\tmp->m_update_sb = true;\n\t}\n\n\t \n\terror = xfs_validate_new_dalign(mp);\n\tif (error)\n\t\tgoto out;\n\n\txfs_alloc_compute_maxlevels(mp);\n\txfs_bmap_compute_maxlevels(mp, XFS_DATA_FORK);\n\txfs_bmap_compute_maxlevels(mp, XFS_ATTR_FORK);\n\txfs_mount_setup_inode_geom(mp);\n\txfs_rmapbt_compute_maxlevels(mp);\n\txfs_refcountbt_compute_maxlevels(mp);\n\n\txfs_agbtree_compute_maxlevels(mp);\n\n\t \n\terror = xfs_update_alignment(mp);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tmp->m_fail_unmount = true;\n\n\terror = xfs_sysfs_init(&mp->m_kobj, &xfs_mp_ktype,\n\t\t\t       NULL, mp->m_super->s_id);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_sysfs_init(&mp->m_stats.xs_kobj, &xfs_stats_ktype,\n\t\t\t       &mp->m_kobj, \"stats\");\n\tif (error)\n\t\tgoto out_remove_sysfs;\n\n\txchk_stats_register(mp->m_scrub_stats, mp->m_debugfs);\n\n\terror = xfs_error_sysfs_init(mp);\n\tif (error)\n\t\tgoto out_remove_scrub_stats;\n\n\terror = xfs_errortag_init(mp);\n\tif (error)\n\t\tgoto out_remove_error_sysfs;\n\n\terror = xfs_uuid_mount(mp);\n\tif (error)\n\t\tgoto out_remove_errortag;\n\n\t \n\tmp->m_allocsize_log =\n\t\tmax_t(uint32_t, sbp->sb_blocklog, mp->m_allocsize_log);\n\tmp->m_allocsize_blocks = 1U << (mp->m_allocsize_log - sbp->sb_blocklog);\n\n\t \n\txfs_set_low_space_thresholds(mp);\n\n\t \n\tif (xfs_has_sparseinodes(mp) &&\n\t    mp->m_sb.sb_spino_align !=\n\t\t\tXFS_B_TO_FSBT(mp, igeo->inode_cluster_size_raw)) {\n\t\txfs_warn(mp,\n\t\"Sparse inode block alignment (%u) must match cluster size (%llu).\",\n\t\t\t mp->m_sb.sb_spino_align,\n\t\t\t XFS_B_TO_FSBT(mp, igeo->inode_cluster_size_raw));\n\t\terror = -EINVAL;\n\t\tgoto out_remove_uuid;\n\t}\n\n\t \n\terror = xfs_check_sizes(mp);\n\tif (error)\n\t\tgoto out_remove_uuid;\n\n\t \n\terror = xfs_rtmount_init(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"RT mount failed\");\n\t\tgoto out_remove_uuid;\n\t}\n\n\t \n\tmp->m_fixedfsid[0] =\n\t\t(get_unaligned_be16(&sbp->sb_uuid.b[8]) << 16) |\n\t\t get_unaligned_be16(&sbp->sb_uuid.b[4]);\n\tmp->m_fixedfsid[1] = get_unaligned_be32(&sbp->sb_uuid.b[0]);\n\n\terror = xfs_da_mount(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"Failed dir/attr init: %d\", error);\n\t\tgoto out_remove_uuid;\n\t}\n\n\t \n\txfs_trans_init(mp);\n\n\t \n\terror = xfs_initialize_perag(mp, sbp->sb_agcount, mp->m_sb.sb_dblocks,\n\t\t\t&mp->m_maxagi);\n\tif (error) {\n\t\txfs_warn(mp, \"Failed per-ag init: %d\", error);\n\t\tgoto out_free_dir;\n\t}\n\n\tif (XFS_IS_CORRUPT(mp, !sbp->sb_logblocks)) {\n\t\txfs_warn(mp, \"no log defined\");\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_free_perag;\n\t}\n\n\terror = xfs_inodegc_register_shrinker(mp);\n\tif (error)\n\t\tgoto out_fail_wait;\n\n\t \n\terror = xfs_log_mount(mp, mp->m_logdev_targp,\n\t\t\t      XFS_FSB_TO_DADDR(mp, sbp->sb_logstart),\n\t\t\t      XFS_FSB_TO_BB(mp, sbp->sb_logblocks));\n\tif (error) {\n\t\txfs_warn(mp, \"log mount failed\");\n\t\tgoto out_inodegc_shrinker;\n\t}\n\n\t \n\txfs_inodegc_start(mp);\n\txfs_blockgc_start(mp);\n\n\t \n\tif (xfs_has_noattr2(mp)) {\n\t\tmp->m_features &= ~XFS_FEAT_ATTR2;\n\t} else if (!xfs_has_attr2(mp) &&\n\t\t   (mp->m_sb.sb_features2 & XFS_SB_VERSION2_ATTR2BIT)) {\n\t\tmp->m_features |= XFS_FEAT_ATTR2;\n\t}\n\n\t \n\terror = xfs_iget(mp, NULL, sbp->sb_rootino, XFS_IGET_UNTRUSTED,\n\t\t\t XFS_ILOCK_EXCL, &rip);\n\tif (error) {\n\t\txfs_warn(mp,\n\t\t\t\"Failed to read root inode 0x%llx, error %d\",\n\t\t\tsbp->sb_rootino, -error);\n\t\tgoto out_log_dealloc;\n\t}\n\n\tASSERT(rip != NULL);\n\n\tif (XFS_IS_CORRUPT(mp, !S_ISDIR(VFS_I(rip)->i_mode))) {\n\t\txfs_warn(mp, \"corrupted root inode %llu: not a directory\",\n\t\t\t(unsigned long long)rip->i_ino);\n\t\txfs_iunlock(rip, XFS_ILOCK_EXCL);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_rele_rip;\n\t}\n\tmp->m_rootip = rip;\t \n\n\txfs_iunlock(rip, XFS_ILOCK_EXCL);\n\n\t \n\terror = xfs_rtmount_inodes(mp);\n\tif (error) {\n\t\t \n\t\txfs_warn(mp, \"failed to read RT inodes\");\n\t\tgoto out_rele_rip;\n\t}\n\n\t \n\terror = xfs_check_summary_counts(mp);\n\tif (error)\n\t\tgoto out_rtunmount;\n\n\t \n\tif (mp->m_update_sb && !xfs_is_readonly(mp)) {\n\t\terror = xfs_sync_sb(mp, false);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"failed to write sb changes\");\n\t\t\tgoto out_rtunmount;\n\t\t}\n\t}\n\n\t \n\tif (XFS_IS_QUOTA_ON(mp)) {\n\t\terror = xfs_qm_newmount(mp, &quotamount, &quotaflags);\n\t\tif (error)\n\t\t\tgoto out_rtunmount;\n\t} else {\n\t\t \n\t\tif (mp->m_sb.sb_qflags & XFS_ALL_QUOTA_ACCT) {\n\t\t\txfs_notice(mp, \"resetting quota flags\");\n\t\t\terror = xfs_mount_reset_sbqflags(mp);\n\t\t\tif (error)\n\t\t\t\tgoto out_rtunmount;\n\t\t}\n\t}\n\n\t \n\terror = xfs_fs_reserve_ag_blocks(mp);\n\tif (error && error == -ENOSPC)\n\t\txfs_warn(mp,\n\t\"ENOSPC reserving per-AG metadata pool, log recovery may fail.\");\n\terror = xfs_log_mount_finish(mp);\n\txfs_fs_unreserve_ag_blocks(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"log mount finish failed\");\n\t\tgoto out_rtunmount;\n\t}\n\n\t \n\tif (xfs_is_readonly(mp) && !xfs_has_norecovery(mp))\n\t\txfs_log_clean(mp);\n\n\t \n\tif (quotamount) {\n\t\tASSERT(mp->m_qflags == 0);\n\t\tmp->m_qflags = quotaflags;\n\n\t\txfs_qm_mount_quotas(mp);\n\t}\n\n\t \n\tif (!xfs_is_readonly(mp)) {\n\t\tresblks = xfs_default_resblks(mp);\n\t\terror = xfs_reserve_blocks(mp, &resblks, NULL);\n\t\tif (error)\n\t\t\txfs_warn(mp,\n\t\"Unable to allocate reserve blocks. Continuing without reserve pool.\");\n\n\t\t \n\t\terror = xfs_fs_reserve_ag_blocks(mp);\n\t\tif (error && error != -ENOSPC)\n\t\t\tgoto out_agresv;\n\t}\n\n\treturn 0;\n\n out_agresv:\n\txfs_fs_unreserve_ag_blocks(mp);\n\txfs_qm_unmount_quotas(mp);\n out_rtunmount:\n\txfs_rtunmount_inodes(mp);\n out_rele_rip:\n\txfs_irele(rip);\n\t \n\txfs_qm_unmount(mp);\n\n\t \n\txfs_inodegc_flush(mp);\n\n\t \n\txfs_unmount_flush_inodes(mp);\n out_log_dealloc:\n\txfs_log_mount_cancel(mp);\n out_inodegc_shrinker:\n\tunregister_shrinker(&mp->m_inodegc_shrinker);\n out_fail_wait:\n\tif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp)\n\t\txfs_buftarg_drain(mp->m_logdev_targp);\n\txfs_buftarg_drain(mp->m_ddev_targp);\n out_free_perag:\n\txfs_free_perag(mp);\n out_free_dir:\n\txfs_da_unmount(mp);\n out_remove_uuid:\n\txfs_uuid_unmount(mp);\n out_remove_errortag:\n\txfs_errortag_del(mp);\n out_remove_error_sysfs:\n\txfs_error_sysfs_del(mp);\n out_remove_scrub_stats:\n\txchk_stats_unregister(mp->m_scrub_stats);\n\txfs_sysfs_del(&mp->m_stats.xs_kobj);\n out_remove_sysfs:\n\txfs_sysfs_del(&mp->m_kobj);\n out:\n\treturn error;\n}\n\n \nvoid\nxfs_unmountfs(\n\tstruct xfs_mount\t*mp)\n{\n\tuint64_t\t\tresblks;\n\tint\t\t\terror;\n\n\t \n\txfs_inodegc_flush(mp);\n\n\txfs_blockgc_stop(mp);\n\txfs_fs_unreserve_ag_blocks(mp);\n\txfs_qm_unmount_quotas(mp);\n\txfs_rtunmount_inodes(mp);\n\txfs_irele(mp->m_rootip);\n\n\txfs_unmount_flush_inodes(mp);\n\n\txfs_qm_unmount(mp);\n\n\t \n\tresblks = 0;\n\terror = xfs_reserve_blocks(mp, &resblks, NULL);\n\tif (error)\n\t\txfs_warn(mp, \"Unable to free reserved block pool. \"\n\t\t\t\t\"Freespace may not be correct on next mount.\");\n\txfs_unmount_check(mp);\n\n\txfs_log_unmount(mp);\n\txfs_da_unmount(mp);\n\txfs_uuid_unmount(mp);\n\n#if defined(DEBUG)\n\txfs_errortag_clearall(mp);\n#endif\n\tunregister_shrinker(&mp->m_inodegc_shrinker);\n\txfs_free_perag(mp);\n\n\txfs_errortag_del(mp);\n\txfs_error_sysfs_del(mp);\n\txchk_stats_unregister(mp->m_scrub_stats);\n\txfs_sysfs_del(&mp->m_stats.xs_kobj);\n\txfs_sysfs_del(&mp->m_kobj);\n}\n\n \nbool\nxfs_fs_writable(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlevel)\n{\n\tASSERT(level > SB_UNFROZEN);\n\tif ((mp->m_super->s_writers.frozen >= level) ||\n\t    xfs_is_shutdown(mp) || xfs_is_readonly(mp))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nint\nxfs_mod_freecounter(\n\tstruct xfs_mount\t*mp,\n\tstruct percpu_counter\t*counter,\n\tint64_t\t\t\tdelta,\n\tbool\t\t\trsvd)\n{\n\tint64_t\t\t\tlcounter;\n\tlong long\t\tres_used;\n\tuint64_t\t\tset_aside = 0;\n\ts32\t\t\tbatch;\n\tbool\t\t\thas_resv_pool;\n\n\tASSERT(counter == &mp->m_fdblocks || counter == &mp->m_frextents);\n\thas_resv_pool = (counter == &mp->m_fdblocks);\n\tif (rsvd)\n\t\tASSERT(has_resv_pool);\n\n\tif (delta > 0) {\n\t\t \n\t\tif (likely(!has_resv_pool ||\n\t\t\t   mp->m_resblks == mp->m_resblks_avail)) {\n\t\t\tpercpu_counter_add(counter, delta);\n\t\t\treturn 0;\n\t\t}\n\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tres_used = (long long)(mp->m_resblks - mp->m_resblks_avail);\n\n\t\tif (res_used > delta) {\n\t\t\tmp->m_resblks_avail += delta;\n\t\t} else {\n\t\t\tdelta -= res_used;\n\t\t\tmp->m_resblks_avail = mp->m_resblks;\n\t\t\tpercpu_counter_add(counter, delta);\n\t\t}\n\t\tspin_unlock(&mp->m_sb_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tif (__percpu_counter_compare(counter, 2 * XFS_FDBLOCKS_BATCH,\n\t\t\t\t     XFS_FDBLOCKS_BATCH) < 0)\n\t\tbatch = 1;\n\telse\n\t\tbatch = XFS_FDBLOCKS_BATCH;\n\n\t \n\tif (has_resv_pool)\n\t\tset_aside = xfs_fdblocks_unavailable(mp);\n\tpercpu_counter_add_batch(counter, delta, batch);\n\tif (__percpu_counter_compare(counter, set_aside,\n\t\t\t\t     XFS_FDBLOCKS_BATCH) >= 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tspin_lock(&mp->m_sb_lock);\n\tpercpu_counter_add(counter, -delta);\n\tif (!has_resv_pool || !rsvd)\n\t\tgoto fdblocks_enospc;\n\n\tlcounter = (long long)mp->m_resblks_avail + delta;\n\tif (lcounter >= 0) {\n\t\tmp->m_resblks_avail = lcounter;\n\t\tspin_unlock(&mp->m_sb_lock);\n\t\treturn 0;\n\t}\n\txfs_warn_once(mp,\n\"Reserve blocks depleted! Consider increasing reserve pool size.\");\n\nfdblocks_enospc:\n\tspin_unlock(&mp->m_sb_lock);\n\treturn -ENOSPC;\n}\n\n \nvoid\nxfs_freesb(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_buf\t\t*bp = mp->m_sb_bp;\n\n\txfs_buf_lock(bp);\n\tmp->m_sb_bp = NULL;\n\txfs_buf_relse(bp);\n}\n\n \nint\nxfs_dev_is_read_only(\n\tstruct xfs_mount\t*mp,\n\tchar\t\t\t*message)\n{\n\tif (xfs_readonly_buftarg(mp->m_ddev_targp) ||\n\t    xfs_readonly_buftarg(mp->m_logdev_targp) ||\n\t    (mp->m_rtdev_targp && xfs_readonly_buftarg(mp->m_rtdev_targp))) {\n\t\txfs_notice(mp, \"%s required on read-only device.\", message);\n\t\txfs_notice(mp, \"write access unavailable, cannot proceed.\");\n\t\treturn -EROFS;\n\t}\n\treturn 0;\n}\n\n \nvoid\nxfs_force_summary_recalc(\n\tstruct xfs_mount\t*mp)\n{\n\tif (!xfs_has_lazysbcount(mp))\n\t\treturn;\n\n\txfs_fs_mark_sick(mp, XFS_SICK_FS_COUNTERS);\n}\n\n \nint\nxfs_add_incompat_log_feature(\n\tstruct xfs_mount\t*mp,\n\tuint32_t\t\tfeature)\n{\n\tstruct xfs_dsb\t\t*dsb;\n\tint\t\t\terror;\n\n\tASSERT(hweight32(feature) == 1);\n\tASSERT(!(feature & XFS_SB_FEAT_INCOMPAT_LOG_UNKNOWN));\n\n\t \n\terror = xfs_log_force(mp, XFS_LOG_SYNC);\n\tif (error)\n\t\treturn error;\n\txfs_ail_push_all(mp->m_ail);\n\n\t \n\txfs_buf_lock(mp->m_sb_bp);\n\txfs_buf_hold(mp->m_sb_bp);\n\n\tif (xfs_is_shutdown(mp)) {\n\t\terror = -EIO;\n\t\tgoto rele;\n\t}\n\n\tif (xfs_sb_has_incompat_log_feature(&mp->m_sb, feature))\n\t\tgoto rele;\n\n\t \n\tdsb = mp->m_sb_bp->b_addr;\n\txfs_sb_to_disk(dsb, &mp->m_sb);\n\tdsb->sb_features_log_incompat |= cpu_to_be32(feature);\n\terror = xfs_bwrite(mp->m_sb_bp);\n\tif (error)\n\t\tgoto shutdown;\n\n\t \n\txfs_sb_add_incompat_log_features(&mp->m_sb, feature);\n\txfs_buf_relse(mp->m_sb_bp);\n\n\t \n\treturn xfs_sync_sb(mp, false);\nshutdown:\n\txfs_force_shutdown(mp, SHUTDOWN_META_IO_ERROR);\nrele:\n\txfs_buf_relse(mp->m_sb_bp);\n\treturn error;\n}\n\n \nbool\nxfs_clear_incompat_log_features(\n\tstruct xfs_mount\t*mp)\n{\n\tbool\t\t\tret = false;\n\n\tif (!xfs_has_crc(mp) ||\n\t    !xfs_sb_has_incompat_log_feature(&mp->m_sb,\n\t\t\t\tXFS_SB_FEAT_INCOMPAT_LOG_ALL) ||\n\t    xfs_is_shutdown(mp))\n\t\treturn false;\n\n\t \n\txfs_buf_lock(mp->m_sb_bp);\n\txfs_buf_hold(mp->m_sb_bp);\n\n\tif (xfs_sb_has_incompat_log_feature(&mp->m_sb,\n\t\t\t\tXFS_SB_FEAT_INCOMPAT_LOG_ALL)) {\n\t\txfs_sb_remove_incompat_log_features(&mp->m_sb);\n\t\tret = true;\n\t}\n\n\txfs_buf_relse(mp->m_sb_bp);\n\treturn ret;\n}\n\n \n#define XFS_DELALLOC_BATCH\t(4096)\nvoid\nxfs_mod_delalloc(\n\tstruct xfs_mount\t*mp,\n\tint64_t\t\t\tdelta)\n{\n\tpercpu_counter_add_batch(&mp->m_delalloc_blks, delta,\n\t\t\tXFS_DELALLOC_BATCH);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}