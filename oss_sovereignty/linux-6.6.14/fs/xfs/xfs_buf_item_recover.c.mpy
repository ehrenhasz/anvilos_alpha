{
  "module_name": "xfs_buf_item_recover.c",
  "hash_id": "8a173af6118a824e471d9a04dd80e9362cb1fea89991d4136daad8e3a1169cc5",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_buf_item_recover.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_quota.h\"\n\n \n#define\tXLOG_BC_TABLE_SIZE\t64\n\n#define XLOG_BUF_CANCEL_BUCKET(log, blkno) \\\n\t((log)->l_buf_cancel_table + ((uint64_t)blkno % XLOG_BC_TABLE_SIZE))\n\n \nstruct xfs_buf_cancel {\n\txfs_daddr_t\t\tbc_blkno;\n\tuint\t\t\tbc_len;\n\tint\t\t\tbc_refcount;\n\tstruct list_head\tbc_list;\n};\n\nstatic struct xfs_buf_cancel *\nxlog_find_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen)\n{\n\tstruct list_head\t*bucket;\n\tstruct xfs_buf_cancel\t*bcp;\n\n\tif (!log->l_buf_cancel_table)\n\t\treturn NULL;\n\n\tbucket = XLOG_BUF_CANCEL_BUCKET(log, blkno);\n\tlist_for_each_entry(bcp, bucket, bc_list) {\n\t\tif (bcp->bc_blkno == blkno && bcp->bc_len == len)\n\t\t\treturn bcp;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool\nxlog_add_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen)\n{\n\tstruct xfs_buf_cancel\t*bcp;\n\n\t \n\tbcp = xlog_find_buffer_cancelled(log, blkno, len);\n\tif (bcp) {\n\t\tbcp->bc_refcount++;\n\t\treturn false;\n\t}\n\n\tbcp = kmem_alloc(sizeof(struct xfs_buf_cancel), 0);\n\tbcp->bc_blkno = blkno;\n\tbcp->bc_len = len;\n\tbcp->bc_refcount = 1;\n\tlist_add_tail(&bcp->bc_list, XLOG_BUF_CANCEL_BUCKET(log, blkno));\n\treturn true;\n}\n\n \nbool\nxlog_is_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen)\n{\n\treturn xlog_find_buffer_cancelled(log, blkno, len) != NULL;\n}\n\n \nstatic bool\nxlog_put_buffer_cancelled(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen)\n{\n\tstruct xfs_buf_cancel\t*bcp;\n\n\tbcp = xlog_find_buffer_cancelled(log, blkno, len);\n\tif (!bcp) {\n\t\tASSERT(0);\n\t\treturn false;\n\t}\n\n\tif (--bcp->bc_refcount == 0) {\n\t\tlist_del(&bcp->bc_list);\n\t\tkmem_free(bcp);\n\t}\n\treturn true;\n}\n\n \n\n \nSTATIC enum xlog_recover_reorder\nxlog_recover_buf_reorder(\n\tstruct xlog_recover_item\t*item)\n{\n\tstruct xfs_buf_log_format\t*buf_f = item->ri_buf[0].i_addr;\n\n\tif (buf_f->blf_flags & XFS_BLF_CANCEL)\n\t\treturn XLOG_REORDER_CANCEL_LIST;\n\tif (buf_f->blf_flags & XFS_BLF_INODE_BUF)\n\t\treturn XLOG_REORDER_INODE_BUFFER_LIST;\n\treturn XLOG_REORDER_BUFFER_LIST;\n}\n\nSTATIC void\nxlog_recover_buf_ra_pass2(\n\tstruct xlog                     *log,\n\tstruct xlog_recover_item        *item)\n{\n\tstruct xfs_buf_log_format\t*buf_f = item->ri_buf[0].i_addr;\n\n\txlog_buf_readahead(log, buf_f->blf_blkno, buf_f->blf_len, NULL);\n}\n\n \nstatic int\nxlog_recover_buf_commit_pass1(\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item)\n{\n\tstruct xfs_buf_log_format\t*bf = item->ri_buf[0].i_addr;\n\n\tif (!xfs_buf_log_check_iovec(&item->ri_buf[0])) {\n\t\txfs_err(log->l_mp, \"bad buffer log item size (%d)\",\n\t\t\t\titem->ri_buf[0].i_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (!(bf->blf_flags & XFS_BLF_CANCEL))\n\t\ttrace_xfs_log_recover_buf_not_cancel(log, bf);\n\telse if (xlog_add_buffer_cancelled(log, bf->blf_blkno, bf->blf_len))\n\t\ttrace_xfs_log_recover_buf_cancel_add(log, bf);\n\telse\n\t\ttrace_xfs_log_recover_buf_cancel_ref_inc(log, bf);\n\treturn 0;\n}\n\n \nstatic void\nxlog_recover_validate_buf_type(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_buf_log_format\t*buf_f,\n\txfs_lsn_t\t\t\tcurrent_lsn)\n{\n\tstruct xfs_da_blkinfo\t\t*info = bp->b_addr;\n\tuint32_t\t\t\tmagic32;\n\tuint16_t\t\t\tmagic16;\n\tuint16_t\t\t\tmagicda;\n\tchar\t\t\t\t*warnmsg = NULL;\n\n\t \n\tif (!xfs_has_crc(mp))\n\t\treturn;\n\n\tmagic32 = be32_to_cpu(*(__be32 *)bp->b_addr);\n\tmagic16 = be16_to_cpu(*(__be16*)bp->b_addr);\n\tmagicda = be16_to_cpu(info->magic);\n\tswitch (xfs_blft_from_flags(buf_f)) {\n\tcase XFS_BLFT_BTREE_BUF:\n\t\tswitch (magic32) {\n\t\tcase XFS_ABTB_CRC_MAGIC:\n\t\tcase XFS_ABTB_MAGIC:\n\t\t\tbp->b_ops = &xfs_bnobt_buf_ops;\n\t\t\tbreak;\n\t\tcase XFS_ABTC_CRC_MAGIC:\n\t\tcase XFS_ABTC_MAGIC:\n\t\t\tbp->b_ops = &xfs_cntbt_buf_ops;\n\t\t\tbreak;\n\t\tcase XFS_IBT_CRC_MAGIC:\n\t\tcase XFS_IBT_MAGIC:\n\t\t\tbp->b_ops = &xfs_inobt_buf_ops;\n\t\t\tbreak;\n\t\tcase XFS_FIBT_CRC_MAGIC:\n\t\tcase XFS_FIBT_MAGIC:\n\t\t\tbp->b_ops = &xfs_finobt_buf_ops;\n\t\t\tbreak;\n\t\tcase XFS_BMAP_CRC_MAGIC:\n\t\tcase XFS_BMAP_MAGIC:\n\t\t\tbp->b_ops = &xfs_bmbt_buf_ops;\n\t\t\tbreak;\n\t\tcase XFS_RMAP_CRC_MAGIC:\n\t\t\tbp->b_ops = &xfs_rmapbt_buf_ops;\n\t\t\tbreak;\n\t\tcase XFS_REFC_CRC_MAGIC:\n\t\t\tbp->b_ops = &xfs_refcountbt_buf_ops;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twarnmsg = \"Bad btree block magic!\";\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase XFS_BLFT_AGF_BUF:\n\t\tif (magic32 != XFS_AGF_MAGIC) {\n\t\t\twarnmsg = \"Bad AGF block magic!\";\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agf_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_AGFL_BUF:\n\t\tif (magic32 != XFS_AGFL_MAGIC) {\n\t\t\twarnmsg = \"Bad AGFL block magic!\";\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agfl_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_AGI_BUF:\n\t\tif (magic32 != XFS_AGI_MAGIC) {\n\t\t\twarnmsg = \"Bad AGI block magic!\";\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_agi_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_UDQUOT_BUF:\n\tcase XFS_BLFT_PDQUOT_BUF:\n\tcase XFS_BLFT_GDQUOT_BUF:\n#ifdef CONFIG_XFS_QUOTA\n\t\tif (magic16 != XFS_DQUOT_MAGIC) {\n\t\t\twarnmsg = \"Bad DQUOT block magic!\";\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dquot_buf_ops;\n#else\n\t\txfs_alert(mp,\n\t\"Trying to recover dquots without QUOTA support built in!\");\n\t\tASSERT(0);\n#endif\n\t\tbreak;\n\tcase XFS_BLFT_DINO_BUF:\n\t\tif (magic16 != XFS_DINODE_MAGIC) {\n\t\t\twarnmsg = \"Bad INODE block magic!\";\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_inode_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_SYMLINK_BUF:\n\t\tif (magic32 != XFS_SYMLINK_MAGIC) {\n\t\t\twarnmsg = \"Bad symlink block magic!\";\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_symlink_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_BLOCK_BUF:\n\t\tif (magic32 != XFS_DIR2_BLOCK_MAGIC &&\n\t\t    magic32 != XFS_DIR3_BLOCK_MAGIC) {\n\t\t\twarnmsg = \"Bad dir block magic!\";\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_block_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_DATA_BUF:\n\t\tif (magic32 != XFS_DIR2_DATA_MAGIC &&\n\t\t    magic32 != XFS_DIR3_DATA_MAGIC) {\n\t\t\twarnmsg = \"Bad dir data magic!\";\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_data_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_FREE_BUF:\n\t\tif (magic32 != XFS_DIR2_FREE_MAGIC &&\n\t\t    magic32 != XFS_DIR3_FREE_MAGIC) {\n\t\t\twarnmsg = \"Bad dir3 free magic!\";\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_free_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_LEAF1_BUF:\n\t\tif (magicda != XFS_DIR2_LEAF1_MAGIC &&\n\t\t    magicda != XFS_DIR3_LEAF1_MAGIC) {\n\t\t\twarnmsg = \"Bad dir leaf1 magic!\";\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_leaf1_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DIR_LEAFN_BUF:\n\t\tif (magicda != XFS_DIR2_LEAFN_MAGIC &&\n\t\t    magicda != XFS_DIR3_LEAFN_MAGIC) {\n\t\t\twarnmsg = \"Bad dir leafn magic!\";\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_DA_NODE_BUF:\n\t\tif (magicda != XFS_DA_NODE_MAGIC &&\n\t\t    magicda != XFS_DA3_NODE_MAGIC) {\n\t\t\twarnmsg = \"Bad da node magic!\";\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_da3_node_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_ATTR_LEAF_BUF:\n\t\tif (magicda != XFS_ATTR_LEAF_MAGIC &&\n\t\t    magicda != XFS_ATTR3_LEAF_MAGIC) {\n\t\t\twarnmsg = \"Bad attr leaf magic!\";\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_ATTR_RMT_BUF:\n\t\tif (magic32 != XFS_ATTR3_RMT_MAGIC) {\n\t\t\twarnmsg = \"Bad attr remote magic!\";\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\t\tbreak;\n\tcase XFS_BLFT_SB_BUF:\n\t\tif (magic32 != XFS_SB_MAGIC) {\n\t\t\twarnmsg = \"Bad SB block magic!\";\n\t\t\tbreak;\n\t\t}\n\t\tbp->b_ops = &xfs_sb_buf_ops;\n\t\tbreak;\n#ifdef CONFIG_XFS_RT\n\tcase XFS_BLFT_RTBITMAP_BUF:\n\tcase XFS_BLFT_RTSUMMARY_BUF:\n\t\t \n\t\tbp->b_ops = &xfs_rtbuf_ops;\n\t\tbreak;\n#endif  \n\tdefault:\n\t\txfs_warn(mp, \"Unknown buffer type %d!\",\n\t\t\t xfs_blft_from_flags(buf_f));\n\t\tbreak;\n\t}\n\n\t \n\tif (current_lsn == NULLCOMMITLSN)\n\t\treturn;\n\n\tif (warnmsg) {\n\t\txfs_warn(mp, warnmsg);\n\t\tASSERT(0);\n\t}\n\n\t \n\tif (bp->b_ops) {\n\t\tstruct xfs_buf_log_item\t*bip;\n\n\t\tbp->b_flags |= _XBF_LOGRECOVERY;\n\t\txfs_buf_item_init(bp, mp);\n\t\tbip = bp->b_log_item;\n\t\tbip->bli_item.li_lsn = current_lsn;\n\t}\n}\n\n \nSTATIC void\nxlog_recover_do_reg_buffer(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xlog_recover_item\t*item,\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_buf_log_format\t*buf_f,\n\txfs_lsn_t\t\t\tcurrent_lsn)\n{\n\tint\t\t\ti;\n\tint\t\t\tbit;\n\tint\t\t\tnbits;\n\txfs_failaddr_t\t\tfa;\n\tconst size_t\t\tsize_disk_dquot = sizeof(struct xfs_disk_dquot);\n\n\ttrace_xfs_log_recover_buf_reg_buf(mp->m_log, buf_f);\n\n\tbit = 0;\n\ti = 1;   \n\twhile (1) {\n\t\tbit = xfs_next_bit(buf_f->blf_data_map,\n\t\t\t\t   buf_f->blf_map_size, bit);\n\t\tif (bit == -1)\n\t\t\tbreak;\n\t\tnbits = xfs_contig_bits(buf_f->blf_data_map,\n\t\t\t\t\tbuf_f->blf_map_size, bit);\n\t\tASSERT(nbits > 0);\n\t\tASSERT(item->ri_buf[i].i_addr != NULL);\n\t\tASSERT(item->ri_buf[i].i_len % XFS_BLF_CHUNK == 0);\n\t\tASSERT(BBTOB(bp->b_length) >=\n\t\t       ((uint)bit << XFS_BLF_SHIFT) + (nbits << XFS_BLF_SHIFT));\n\n\t\t \n\t\tif (item->ri_buf[i].i_len < (nbits << XFS_BLF_SHIFT))\n\t\t\tnbits = item->ri_buf[i].i_len >> XFS_BLF_SHIFT;\n\n\t\t \n\t\tfa = NULL;\n\t\tif (buf_f->blf_flags &\n\t\t   (XFS_BLF_UDQUOT_BUF|XFS_BLF_PDQUOT_BUF|XFS_BLF_GDQUOT_BUF)) {\n\t\t\tif (item->ri_buf[i].i_addr == NULL) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\t\t\"XFS: NULL dquot in %s.\", __func__);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (item->ri_buf[i].i_len < size_disk_dquot) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\t\t\"XFS: dquot too small (%d) in %s.\",\n\t\t\t\t\titem->ri_buf[i].i_len, __func__);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tfa = xfs_dquot_verify(mp, item->ri_buf[i].i_addr, -1);\n\t\t\tif (fa) {\n\t\t\t\txfs_alert(mp,\n\t\"dquot corrupt at %pS trying to replay into block 0x%llx\",\n\t\t\t\t\tfa, xfs_buf_daddr(bp));\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\n\t\tmemcpy(xfs_buf_offset(bp,\n\t\t\t(uint)bit << XFS_BLF_SHIFT),\t \n\t\t\titem->ri_buf[i].i_addr,\t\t \n\t\t\tnbits<<XFS_BLF_SHIFT);\t\t \n next:\n\t\ti++;\n\t\tbit += nbits;\n\t}\n\n\t \n\tASSERT(i == item->ri_total);\n\n\txlog_recover_validate_buf_type(mp, bp, buf_f, current_lsn);\n}\n\n \nSTATIC bool\nxlog_recover_do_dquot_buffer(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xlog\t\t\t*log,\n\tstruct xlog_recover_item\t*item,\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_buf_log_format\t*buf_f)\n{\n\tuint\t\t\ttype;\n\n\ttrace_xfs_log_recover_buf_dquot_buf(log, buf_f);\n\n\t \n\tif (!mp->m_qflags)\n\t\treturn false;\n\n\ttype = 0;\n\tif (buf_f->blf_flags & XFS_BLF_UDQUOT_BUF)\n\t\ttype |= XFS_DQTYPE_USER;\n\tif (buf_f->blf_flags & XFS_BLF_PDQUOT_BUF)\n\t\ttype |= XFS_DQTYPE_PROJ;\n\tif (buf_f->blf_flags & XFS_BLF_GDQUOT_BUF)\n\t\ttype |= XFS_DQTYPE_GROUP;\n\t \n\tif (log->l_quotaoffs_flag & type)\n\t\treturn false;\n\n\txlog_recover_do_reg_buffer(mp, item, bp, buf_f, NULLCOMMITLSN);\n\treturn true;\n}\n\n \nSTATIC int\nxlog_recover_do_inode_buffer(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xlog_recover_item\t*item,\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_buf_log_format\t*buf_f)\n{\n\tint\t\t\t\ti;\n\tint\t\t\t\titem_index = 0;\n\tint\t\t\t\tbit = 0;\n\tint\t\t\t\tnbits = 0;\n\tint\t\t\t\treg_buf_offset = 0;\n\tint\t\t\t\treg_buf_bytes = 0;\n\tint\t\t\t\tnext_unlinked_offset;\n\tint\t\t\t\tinodes_per_buf;\n\txfs_agino_t\t\t\t*logged_nextp;\n\txfs_agino_t\t\t\t*buffer_nextp;\n\n\ttrace_xfs_log_recover_buf_inode_buf(mp->m_log, buf_f);\n\n\t \n\tif (xfs_has_crc(mp))\n\t\tbp->b_ops = &xfs_inode_buf_ops;\n\n\tinodes_per_buf = BBTOB(bp->b_length) >> mp->m_sb.sb_inodelog;\n\tfor (i = 0; i < inodes_per_buf; i++) {\n\t\tnext_unlinked_offset = (i * mp->m_sb.sb_inodesize) +\n\t\t\toffsetof(struct xfs_dinode, di_next_unlinked);\n\n\t\twhile (next_unlinked_offset >=\n\t\t       (reg_buf_offset + reg_buf_bytes)) {\n\t\t\t \n\t\t\tbit += nbits;\n\t\t\tbit = xfs_next_bit(buf_f->blf_data_map,\n\t\t\t\t\t   buf_f->blf_map_size, bit);\n\n\t\t\t \n\t\t\tif (bit == -1)\n\t\t\t\treturn 0;\n\n\t\t\tnbits = xfs_contig_bits(buf_f->blf_data_map,\n\t\t\t\t\t\tbuf_f->blf_map_size, bit);\n\t\t\tASSERT(nbits > 0);\n\t\t\treg_buf_offset = bit << XFS_BLF_SHIFT;\n\t\t\treg_buf_bytes = nbits << XFS_BLF_SHIFT;\n\t\t\titem_index++;\n\t\t}\n\n\t\t \n\t\tif (next_unlinked_offset < reg_buf_offset)\n\t\t\tcontinue;\n\n\t\tASSERT(item->ri_buf[item_index].i_addr != NULL);\n\t\tASSERT((item->ri_buf[item_index].i_len % XFS_BLF_CHUNK) == 0);\n\t\tASSERT((reg_buf_offset + reg_buf_bytes) <= BBTOB(bp->b_length));\n\n\t\t \n\t\tlogged_nextp = item->ri_buf[item_index].i_addr +\n\t\t\t\tnext_unlinked_offset - reg_buf_offset;\n\t\tif (XFS_IS_CORRUPT(mp, *logged_nextp == 0)) {\n\t\t\txfs_alert(mp,\n\t\t\"Bad inode buffer log record (ptr = \"PTR_FMT\", bp = \"PTR_FMT\"). \"\n\t\t\"Trying to replay bad (0) inode di_next_unlinked field.\",\n\t\t\t\titem, bp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tbuffer_nextp = xfs_buf_offset(bp, next_unlinked_offset);\n\t\t*buffer_nextp = *logged_nextp;\n\n\t\t \n\t\txfs_dinode_calc_crc(mp,\n\t\t\t\txfs_buf_offset(bp, i * mp->m_sb.sb_inodesize));\n\n\t}\n\n\treturn 0;\n}\n\n \nstatic xfs_lsn_t\nxlog_recover_get_buf_lsn(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_buf_log_format *buf_f)\n{\n\tuint32_t\t\tmagic32;\n\tuint16_t\t\tmagic16;\n\tuint16_t\t\tmagicda;\n\tvoid\t\t\t*blk = bp->b_addr;\n\tuuid_t\t\t\t*uuid;\n\txfs_lsn_t\t\tlsn = -1;\n\tuint16_t\t\tblft;\n\n\t \n\tif (!xfs_has_crc(mp))\n\t\tgoto recover_immediately;\n\n\t \n\tblft = xfs_blft_from_flags(buf_f);\n\tif (blft == XFS_BLFT_RTBITMAP_BUF || blft == XFS_BLFT_RTSUMMARY_BUF)\n\t\tgoto recover_immediately;\n\n\tmagic32 = be32_to_cpu(*(__be32 *)blk);\n\tswitch (magic32) {\n\tcase XFS_ABTB_CRC_MAGIC:\n\tcase XFS_ABTC_CRC_MAGIC:\n\tcase XFS_ABTB_MAGIC:\n\tcase XFS_ABTC_MAGIC:\n\tcase XFS_RMAP_CRC_MAGIC:\n\tcase XFS_REFC_CRC_MAGIC:\n\tcase XFS_FIBT_CRC_MAGIC:\n\tcase XFS_FIBT_MAGIC:\n\tcase XFS_IBT_CRC_MAGIC:\n\tcase XFS_IBT_MAGIC: {\n\t\tstruct xfs_btree_block *btb = blk;\n\n\t\tlsn = be64_to_cpu(btb->bb_u.s.bb_lsn);\n\t\tuuid = &btb->bb_u.s.bb_uuid;\n\t\tbreak;\n\t}\n\tcase XFS_BMAP_CRC_MAGIC:\n\tcase XFS_BMAP_MAGIC: {\n\t\tstruct xfs_btree_block *btb = blk;\n\n\t\tlsn = be64_to_cpu(btb->bb_u.l.bb_lsn);\n\t\tuuid = &btb->bb_u.l.bb_uuid;\n\t\tbreak;\n\t}\n\tcase XFS_AGF_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_agf *)blk)->agf_lsn);\n\t\tuuid = &((struct xfs_agf *)blk)->agf_uuid;\n\t\tbreak;\n\tcase XFS_AGFL_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_agfl *)blk)->agfl_lsn);\n\t\tuuid = &((struct xfs_agfl *)blk)->agfl_uuid;\n\t\tbreak;\n\tcase XFS_AGI_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_agi *)blk)->agi_lsn);\n\t\tuuid = &((struct xfs_agi *)blk)->agi_uuid;\n\t\tbreak;\n\tcase XFS_SYMLINK_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_dsymlink_hdr *)blk)->sl_lsn);\n\t\tuuid = &((struct xfs_dsymlink_hdr *)blk)->sl_uuid;\n\t\tbreak;\n\tcase XFS_DIR3_BLOCK_MAGIC:\n\tcase XFS_DIR3_DATA_MAGIC:\n\tcase XFS_DIR3_FREE_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_dir3_blk_hdr *)blk)->lsn);\n\t\tuuid = &((struct xfs_dir3_blk_hdr *)blk)->uuid;\n\t\tbreak;\n\tcase XFS_ATTR3_RMT_MAGIC:\n\t\t \n\t\tgoto recover_immediately;\n\tcase XFS_SB_MAGIC:\n\t\t \n\t\tlsn = be64_to_cpu(((struct xfs_dsb *)blk)->sb_lsn);\n\t\tif (xfs_has_metauuid(mp))\n\t\t\tuuid = &((struct xfs_dsb *)blk)->sb_meta_uuid;\n\t\telse\n\t\t\tuuid = &((struct xfs_dsb *)blk)->sb_uuid;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (lsn != (xfs_lsn_t)-1) {\n\t\tif (!uuid_equal(&mp->m_sb.sb_meta_uuid, uuid))\n\t\t\tgoto recover_immediately;\n\t\treturn lsn;\n\t}\n\n\tmagicda = be16_to_cpu(((struct xfs_da_blkinfo *)blk)->magic);\n\tswitch (magicda) {\n\tcase XFS_DIR3_LEAF1_MAGIC:\n\tcase XFS_DIR3_LEAFN_MAGIC:\n\tcase XFS_ATTR3_LEAF_MAGIC:\n\tcase XFS_DA3_NODE_MAGIC:\n\t\tlsn = be64_to_cpu(((struct xfs_da3_blkinfo *)blk)->lsn);\n\t\tuuid = &((struct xfs_da3_blkinfo *)blk)->uuid;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (lsn != (xfs_lsn_t)-1) {\n\t\tif (!uuid_equal(&mp->m_sb.sb_meta_uuid, uuid))\n\t\t\tgoto recover_immediately;\n\t\treturn lsn;\n\t}\n\n\t \n\tmagic16 = be16_to_cpu(*(__be16 *)blk);\n\tswitch (magic16) {\n\tcase XFS_DQUOT_MAGIC:\n\tcase XFS_DINODE_MAGIC:\n\t\tgoto recover_immediately;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\nrecover_immediately:\n\treturn (xfs_lsn_t)-1;\n\n}\n\n \nSTATIC int\nxlog_recover_buf_commit_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tcurrent_lsn)\n{\n\tstruct xfs_buf_log_format\t*buf_f = item->ri_buf[0].i_addr;\n\tstruct xfs_mount\t\t*mp = log->l_mp;\n\tstruct xfs_buf\t\t\t*bp;\n\tint\t\t\t\terror;\n\tuint\t\t\t\tbuf_flags;\n\txfs_lsn_t\t\t\tlsn;\n\n\t \n\tif (buf_f->blf_flags & XFS_BLF_CANCEL) {\n\t\tif (xlog_put_buffer_cancelled(log, buf_f->blf_blkno,\n\t\t\t\tbuf_f->blf_len))\n\t\t\tgoto cancelled;\n\t} else {\n\n\t\tif (xlog_is_buffer_cancelled(log, buf_f->blf_blkno,\n\t\t\t\tbuf_f->blf_len))\n\t\t\tgoto cancelled;\n\t}\n\n\ttrace_xfs_log_recover_buf_recover(log, buf_f);\n\n\tbuf_flags = 0;\n\tif (buf_f->blf_flags & XFS_BLF_INODE_BUF)\n\t\tbuf_flags |= XBF_UNMAPPED;\n\n\terror = xfs_buf_read(mp->m_ddev_targp, buf_f->blf_blkno, buf_f->blf_len,\n\t\t\t  buf_flags, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\n\t \n\tlsn = xlog_recover_get_buf_lsn(mp, bp, buf_f);\n\tif (lsn && lsn != -1 && XFS_LSN_CMP(lsn, current_lsn) >= 0) {\n\t\ttrace_xfs_log_recover_buf_skip(log, buf_f);\n\t\txlog_recover_validate_buf_type(mp, bp, buf_f, NULLCOMMITLSN);\n\n\t\t \n\t\tif (bp->b_ops) {\n\t\t\tbp->b_ops->verify_read(bp);\n\t\t\terror = bp->b_error;\n\t\t}\n\t\tgoto out_release;\n\t}\n\n\tif (buf_f->blf_flags & XFS_BLF_INODE_BUF) {\n\t\terror = xlog_recover_do_inode_buffer(mp, item, bp, buf_f);\n\t\tif (error)\n\t\t\tgoto out_release;\n\t} else if (buf_f->blf_flags &\n\t\t  (XFS_BLF_UDQUOT_BUF|XFS_BLF_PDQUOT_BUF|XFS_BLF_GDQUOT_BUF)) {\n\t\tbool\tdirty;\n\n\t\tdirty = xlog_recover_do_dquot_buffer(mp, log, item, bp, buf_f);\n\t\tif (!dirty)\n\t\t\tgoto out_release;\n\t} else {\n\t\txlog_recover_do_reg_buffer(mp, item, bp, buf_f, current_lsn);\n\t}\n\n\t \n\tif (XFS_DINODE_MAGIC ==\n\t    be16_to_cpu(*((__be16 *)xfs_buf_offset(bp, 0))) &&\n\t    (BBTOB(bp->b_length) != M_IGEO(log->l_mp)->inode_cluster_size)) {\n\t\txfs_buf_stale(bp);\n\t\terror = xfs_bwrite(bp);\n\t} else {\n\t\tASSERT(bp->b_mount == mp);\n\t\tbp->b_flags |= _XBF_LOGRECOVERY;\n\t\txfs_buf_delwri_queue(bp, buffer_list);\n\t}\n\nout_release:\n\txfs_buf_relse(bp);\n\treturn error;\ncancelled:\n\ttrace_xfs_log_recover_buf_cancel(log, buf_f);\n\treturn 0;\n}\n\nconst struct xlog_recover_item_ops xlog_buf_item_ops = {\n\t.item_type\t\t= XFS_LI_BUF,\n\t.reorder\t\t= xlog_recover_buf_reorder,\n\t.ra_pass2\t\t= xlog_recover_buf_ra_pass2,\n\t.commit_pass1\t\t= xlog_recover_buf_commit_pass1,\n\t.commit_pass2\t\t= xlog_recover_buf_commit_pass2,\n};\n\n#ifdef DEBUG\nvoid\nxlog_check_buf_cancel_table(\n\tstruct xlog\t*log)\n{\n\tint\t\ti;\n\n\tfor (i = 0; i < XLOG_BC_TABLE_SIZE; i++)\n\t\tASSERT(list_empty(&log->l_buf_cancel_table[i]));\n}\n#endif\n\nint\nxlog_alloc_buf_cancel_table(\n\tstruct xlog\t*log)\n{\n\tvoid\t\t*p;\n\tint\t\ti;\n\n\tASSERT(log->l_buf_cancel_table == NULL);\n\n\tp = kmalloc_array(XLOG_BC_TABLE_SIZE, sizeof(struct list_head),\n\t\t\t  GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tlog->l_buf_cancel_table = p;\n\tfor (i = 0; i < XLOG_BC_TABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(&log->l_buf_cancel_table[i]);\n\n\treturn 0;\n}\n\nvoid\nxlog_free_buf_cancel_table(\n\tstruct xlog\t*log)\n{\n\tint\t\ti;\n\n\tif (!log->l_buf_cancel_table)\n\t\treturn;\n\n\tfor (i = 0; i < XLOG_BC_TABLE_SIZE; i++) {\n\t\tstruct xfs_buf_cancel\t*bc;\n\n\t\twhile ((bc = list_first_entry_or_null(\n\t\t\t\t&log->l_buf_cancel_table[i],\n\t\t\t\tstruct xfs_buf_cancel, bc_list))) {\n\t\t\tlist_del(&bc->bc_list);\n\t\t\tkmem_free(bc);\n\t\t}\n\t}\n\n\tkmem_free(log->l_buf_cancel_table);\n\tlog->l_buf_cancel_table = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}