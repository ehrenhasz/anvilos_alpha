{
  "module_name": "xfs_super.c",
  "hash_id": "6e40c6536edeaf9ac0c87aed2bb897f8bffc451f46fd5414891c6fe1f1645b3c",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_super.c",
  "human_readable_source": "\n \n\n#include \"xfs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_log.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_ondisk.h\"\n#include \"xfs_rmap_item.h\"\n#include \"xfs_refcount_item.h\"\n#include \"xfs_bmap_item.h\"\n#include \"xfs_reflink.h\"\n#include \"xfs_pwork.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_attr_item.h\"\n#include \"xfs_xattr.h\"\n#include \"xfs_iunlink_item.h\"\n#include \"xfs_dahash_test.h\"\n#include \"scrub/stats.h\"\n\n#include <linux/magic.h>\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n\nstatic const struct super_operations xfs_super_operations;\n\nstatic struct dentry *xfs_debugfs;\t \nstatic struct kset *xfs_kset;\t\t \n#ifdef DEBUG\nstatic struct xfs_kobj xfs_dbg_kobj;\t \n#endif\n\nenum xfs_dax_mode {\n\tXFS_DAX_INODE = 0,\n\tXFS_DAX_ALWAYS = 1,\n\tXFS_DAX_NEVER = 2,\n};\n\nstatic void\nxfs_mount_set_dax_mode(\n\tstruct xfs_mount\t*mp,\n\tenum xfs_dax_mode\tmode)\n{\n\tswitch (mode) {\n\tcase XFS_DAX_INODE:\n\t\tmp->m_features &= ~(XFS_FEAT_DAX_ALWAYS | XFS_FEAT_DAX_NEVER);\n\t\tbreak;\n\tcase XFS_DAX_ALWAYS:\n\t\tmp->m_features |= XFS_FEAT_DAX_ALWAYS;\n\t\tmp->m_features &= ~XFS_FEAT_DAX_NEVER;\n\t\tbreak;\n\tcase XFS_DAX_NEVER:\n\t\tmp->m_features |= XFS_FEAT_DAX_NEVER;\n\t\tmp->m_features &= ~XFS_FEAT_DAX_ALWAYS;\n\t\tbreak;\n\t}\n}\n\nstatic const struct constant_table dax_param_enums[] = {\n\t{\"inode\",\tXFS_DAX_INODE },\n\t{\"always\",\tXFS_DAX_ALWAYS },\n\t{\"never\",\tXFS_DAX_NEVER },\n\t{}\n};\n\n \nenum {\n\tOpt_logbufs, Opt_logbsize, Opt_logdev, Opt_rtdev,\n\tOpt_wsync, Opt_noalign, Opt_swalloc, Opt_sunit, Opt_swidth, Opt_nouuid,\n\tOpt_grpid, Opt_nogrpid, Opt_bsdgroups, Opt_sysvgroups,\n\tOpt_allocsize, Opt_norecovery, Opt_inode64, Opt_inode32, Opt_ikeep,\n\tOpt_noikeep, Opt_largeio, Opt_nolargeio, Opt_attr2, Opt_noattr2,\n\tOpt_filestreams, Opt_quota, Opt_noquota, Opt_usrquota, Opt_grpquota,\n\tOpt_prjquota, Opt_uquota, Opt_gquota, Opt_pquota,\n\tOpt_uqnoenforce, Opt_gqnoenforce, Opt_pqnoenforce, Opt_qnoenforce,\n\tOpt_discard, Opt_nodiscard, Opt_dax, Opt_dax_enum,\n};\n\nstatic const struct fs_parameter_spec xfs_fs_parameters[] = {\n\tfsparam_u32(\"logbufs\",\t\tOpt_logbufs),\n\tfsparam_string(\"logbsize\",\tOpt_logbsize),\n\tfsparam_string(\"logdev\",\tOpt_logdev),\n\tfsparam_string(\"rtdev\",\t\tOpt_rtdev),\n\tfsparam_flag(\"wsync\",\t\tOpt_wsync),\n\tfsparam_flag(\"noalign\",\t\tOpt_noalign),\n\tfsparam_flag(\"swalloc\",\t\tOpt_swalloc),\n\tfsparam_u32(\"sunit\",\t\tOpt_sunit),\n\tfsparam_u32(\"swidth\",\t\tOpt_swidth),\n\tfsparam_flag(\"nouuid\",\t\tOpt_nouuid),\n\tfsparam_flag(\"grpid\",\t\tOpt_grpid),\n\tfsparam_flag(\"nogrpid\",\t\tOpt_nogrpid),\n\tfsparam_flag(\"bsdgroups\",\tOpt_bsdgroups),\n\tfsparam_flag(\"sysvgroups\",\tOpt_sysvgroups),\n\tfsparam_string(\"allocsize\",\tOpt_allocsize),\n\tfsparam_flag(\"norecovery\",\tOpt_norecovery),\n\tfsparam_flag(\"inode64\",\t\tOpt_inode64),\n\tfsparam_flag(\"inode32\",\t\tOpt_inode32),\n\tfsparam_flag(\"ikeep\",\t\tOpt_ikeep),\n\tfsparam_flag(\"noikeep\",\t\tOpt_noikeep),\n\tfsparam_flag(\"largeio\",\t\tOpt_largeio),\n\tfsparam_flag(\"nolargeio\",\tOpt_nolargeio),\n\tfsparam_flag(\"attr2\",\t\tOpt_attr2),\n\tfsparam_flag(\"noattr2\",\t\tOpt_noattr2),\n\tfsparam_flag(\"filestreams\",\tOpt_filestreams),\n\tfsparam_flag(\"quota\",\t\tOpt_quota),\n\tfsparam_flag(\"noquota\",\t\tOpt_noquota),\n\tfsparam_flag(\"usrquota\",\tOpt_usrquota),\n\tfsparam_flag(\"grpquota\",\tOpt_grpquota),\n\tfsparam_flag(\"prjquota\",\tOpt_prjquota),\n\tfsparam_flag(\"uquota\",\t\tOpt_uquota),\n\tfsparam_flag(\"gquota\",\t\tOpt_gquota),\n\tfsparam_flag(\"pquota\",\t\tOpt_pquota),\n\tfsparam_flag(\"uqnoenforce\",\tOpt_uqnoenforce),\n\tfsparam_flag(\"gqnoenforce\",\tOpt_gqnoenforce),\n\tfsparam_flag(\"pqnoenforce\",\tOpt_pqnoenforce),\n\tfsparam_flag(\"qnoenforce\",\tOpt_qnoenforce),\n\tfsparam_flag(\"discard\",\t\tOpt_discard),\n\tfsparam_flag(\"nodiscard\",\tOpt_nodiscard),\n\tfsparam_flag(\"dax\",\t\tOpt_dax),\n\tfsparam_enum(\"dax\",\t\tOpt_dax_enum, dax_param_enums),\n\t{}\n};\n\nstruct proc_xfs_info {\n\tuint64_t\tflag;\n\tchar\t\t*str;\n};\n\nstatic int\nxfs_fs_show_options(\n\tstruct seq_file\t\t*m,\n\tstruct dentry\t\t*root)\n{\n\tstatic struct proc_xfs_info xfs_info_set[] = {\n\t\t \n\t\t{ XFS_FEAT_IKEEP,\t\t\",ikeep\" },\n\t\t{ XFS_FEAT_WSYNC,\t\t\",wsync\" },\n\t\t{ XFS_FEAT_NOALIGN,\t\t\",noalign\" },\n\t\t{ XFS_FEAT_SWALLOC,\t\t\",swalloc\" },\n\t\t{ XFS_FEAT_NOUUID,\t\t\",nouuid\" },\n\t\t{ XFS_FEAT_NORECOVERY,\t\t\",norecovery\" },\n\t\t{ XFS_FEAT_ATTR2,\t\t\",attr2\" },\n\t\t{ XFS_FEAT_FILESTREAMS,\t\t\",filestreams\" },\n\t\t{ XFS_FEAT_GRPID,\t\t\",grpid\" },\n\t\t{ XFS_FEAT_DISCARD,\t\t\",discard\" },\n\t\t{ XFS_FEAT_LARGE_IOSIZE,\t\",largeio\" },\n\t\t{ XFS_FEAT_DAX_ALWAYS,\t\t\",dax=always\" },\n\t\t{ XFS_FEAT_DAX_NEVER,\t\t\",dax=never\" },\n\t\t{ 0, NULL }\n\t};\n\tstruct xfs_mount\t*mp = XFS_M(root->d_sb);\n\tstruct proc_xfs_info\t*xfs_infop;\n\n\tfor (xfs_infop = xfs_info_set; xfs_infop->flag; xfs_infop++) {\n\t\tif (mp->m_features & xfs_infop->flag)\n\t\t\tseq_puts(m, xfs_infop->str);\n\t}\n\n\tseq_printf(m, \",inode%d\", xfs_has_small_inums(mp) ? 32 : 64);\n\n\tif (xfs_has_allocsize(mp))\n\t\tseq_printf(m, \",allocsize=%dk\",\n\t\t\t   (1 << mp->m_allocsize_log) >> 10);\n\n\tif (mp->m_logbufs > 0)\n\t\tseq_printf(m, \",logbufs=%d\", mp->m_logbufs);\n\tif (mp->m_logbsize > 0)\n\t\tseq_printf(m, \",logbsize=%dk\", mp->m_logbsize >> 10);\n\n\tif (mp->m_logname)\n\t\tseq_show_option(m, \"logdev\", mp->m_logname);\n\tif (mp->m_rtname)\n\t\tseq_show_option(m, \"rtdev\", mp->m_rtname);\n\n\tif (mp->m_dalign > 0)\n\t\tseq_printf(m, \",sunit=%d\",\n\t\t\t\t(int)XFS_FSB_TO_BB(mp, mp->m_dalign));\n\tif (mp->m_swidth > 0)\n\t\tseq_printf(m, \",swidth=%d\",\n\t\t\t\t(int)XFS_FSB_TO_BB(mp, mp->m_swidth));\n\n\tif (mp->m_qflags & XFS_UQUOTA_ENFD)\n\t\tseq_puts(m, \",usrquota\");\n\telse if (mp->m_qflags & XFS_UQUOTA_ACCT)\n\t\tseq_puts(m, \",uqnoenforce\");\n\n\tif (mp->m_qflags & XFS_PQUOTA_ENFD)\n\t\tseq_puts(m, \",prjquota\");\n\telse if (mp->m_qflags & XFS_PQUOTA_ACCT)\n\t\tseq_puts(m, \",pqnoenforce\");\n\n\tif (mp->m_qflags & XFS_GQUOTA_ENFD)\n\t\tseq_puts(m, \",grpquota\");\n\telse if (mp->m_qflags & XFS_GQUOTA_ACCT)\n\t\tseq_puts(m, \",gqnoenforce\");\n\n\tif (!(mp->m_qflags & XFS_ALL_QUOTA_ACCT))\n\t\tseq_puts(m, \",noquota\");\n\n\treturn 0;\n}\n\nstatic bool\nxfs_set_inode_alloc_perag(\n\tstruct xfs_perag\t*pag,\n\txfs_ino_t\t\tino,\n\txfs_agnumber_t\t\tmax_metadata)\n{\n\tif (!xfs_is_inode32(pag->pag_mount)) {\n\t\tset_bit(XFS_AGSTATE_ALLOWS_INODES, &pag->pag_opstate);\n\t\tclear_bit(XFS_AGSTATE_PREFERS_METADATA, &pag->pag_opstate);\n\t\treturn false;\n\t}\n\n\tif (ino > XFS_MAXINUMBER_32) {\n\t\tclear_bit(XFS_AGSTATE_ALLOWS_INODES, &pag->pag_opstate);\n\t\tclear_bit(XFS_AGSTATE_PREFERS_METADATA, &pag->pag_opstate);\n\t\treturn false;\n\t}\n\n\tset_bit(XFS_AGSTATE_ALLOWS_INODES, &pag->pag_opstate);\n\tif (pag->pag_agno < max_metadata)\n\t\tset_bit(XFS_AGSTATE_PREFERS_METADATA, &pag->pag_opstate);\n\telse\n\t\tclear_bit(XFS_AGSTATE_PREFERS_METADATA, &pag->pag_opstate);\n\treturn true;\n}\n\n \nxfs_agnumber_t\nxfs_set_inode_alloc(\n\tstruct xfs_mount *mp,\n\txfs_agnumber_t\tagcount)\n{\n\txfs_agnumber_t\tindex;\n\txfs_agnumber_t\tmaxagi = 0;\n\txfs_sb_t\t*sbp = &mp->m_sb;\n\txfs_agnumber_t\tmax_metadata;\n\txfs_agino_t\tagino;\n\txfs_ino_t\tino;\n\n\t \n\tif (M_IGEO(mp)->maxicount) {\n\t\tuint64_t\ticount;\n\n\t\ticount = sbp->sb_dblocks * sbp->sb_imax_pct;\n\t\tdo_div(icount, 100);\n\t\ticount += sbp->sb_agblocks - 1;\n\t\tdo_div(icount, sbp->sb_agblocks);\n\t\tmax_metadata = icount;\n\t} else {\n\t\tmax_metadata = agcount;\n\t}\n\n\t \n\tagino =\tXFS_AGB_TO_AGINO(mp, sbp->sb_agblocks - 1);\n\tino = XFS_AGINO_TO_INO(mp, agcount - 1, agino);\n\n\t \n\tif (xfs_has_small_inums(mp) && ino > XFS_MAXINUMBER_32)\n\t\tset_bit(XFS_OPSTATE_INODE32, &mp->m_opstate);\n\telse\n\t\tclear_bit(XFS_OPSTATE_INODE32, &mp->m_opstate);\n\n\tfor (index = 0; index < agcount; index++) {\n\t\tstruct xfs_perag\t*pag;\n\n\t\tino = XFS_AGINO_TO_INO(mp, index, agino);\n\n\t\tpag = xfs_perag_get(mp, index);\n\t\tif (xfs_set_inode_alloc_perag(pag, ino, max_metadata))\n\t\t\tmaxagi++;\n\t\txfs_perag_put(pag);\n\t}\n\n\treturn xfs_is_inode32(mp) ? maxagi : agcount;\n}\n\nstatic int\nxfs_setup_dax_always(\n\tstruct xfs_mount\t*mp)\n{\n\tif (!mp->m_ddev_targp->bt_daxdev &&\n\t    (!mp->m_rtdev_targp || !mp->m_rtdev_targp->bt_daxdev)) {\n\t\txfs_alert(mp,\n\t\t\t\"DAX unsupported by block device. Turning off DAX.\");\n\t\tgoto disable_dax;\n\t}\n\n\tif (mp->m_super->s_blocksize != PAGE_SIZE) {\n\t\txfs_alert(mp,\n\t\t\t\"DAX not supported for blocksize. Turning off DAX.\");\n\t\tgoto disable_dax;\n\t}\n\n\tif (xfs_has_reflink(mp) &&\n\t    bdev_is_partition(mp->m_ddev_targp->bt_bdev)) {\n\t\txfs_alert(mp,\n\t\t\t\"DAX and reflink cannot work with multi-partitions!\");\n\t\treturn -EINVAL;\n\t}\n\n\txfs_warn(mp, \"DAX enabled. Warning: EXPERIMENTAL, use at your own risk\");\n\treturn 0;\n\ndisable_dax:\n\txfs_mount_set_dax_mode(mp, XFS_DAX_NEVER);\n\treturn 0;\n}\n\nSTATIC int\nxfs_blkdev_get(\n\txfs_mount_t\t\t*mp,\n\tconst char\t\t*name,\n\tstruct block_device\t**bdevp)\n{\n\tint\t\t\terror = 0;\n\n\t*bdevp = blkdev_get_by_path(name, BLK_OPEN_READ | BLK_OPEN_WRITE,\n\t\t\t\t    mp->m_super, &fs_holder_ops);\n\tif (IS_ERR(*bdevp)) {\n\t\terror = PTR_ERR(*bdevp);\n\t\txfs_warn(mp, \"Invalid device [%s], error=%d\", name, error);\n\t}\n\n\treturn error;\n}\n\nSTATIC void\nxfs_shutdown_devices(\n\tstruct xfs_mount\t*mp)\n{\n\t \n\tif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp) {\n\t\tblkdev_issue_flush(mp->m_logdev_targp->bt_bdev);\n\t\tinvalidate_bdev(mp->m_logdev_targp->bt_bdev);\n\t}\n\tif (mp->m_rtdev_targp) {\n\t\tblkdev_issue_flush(mp->m_rtdev_targp->bt_bdev);\n\t\tinvalidate_bdev(mp->m_rtdev_targp->bt_bdev);\n\t}\n\tblkdev_issue_flush(mp->m_ddev_targp->bt_bdev);\n\tinvalidate_bdev(mp->m_ddev_targp->bt_bdev);\n}\n\n \nSTATIC int\nxfs_open_devices(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct super_block\t*sb = mp->m_super;\n\tstruct block_device\t*ddev = sb->s_bdev;\n\tstruct block_device\t*logdev = NULL, *rtdev = NULL;\n\tint\t\t\terror;\n\n\t \n\tup_write(&sb->s_umount);\n\n\t \n\tif (mp->m_logname) {\n\t\terror = xfs_blkdev_get(mp, mp->m_logname, &logdev);\n\t\tif (error)\n\t\t\tgoto out_relock;\n\t}\n\n\tif (mp->m_rtname) {\n\t\terror = xfs_blkdev_get(mp, mp->m_rtname, &rtdev);\n\t\tif (error)\n\t\t\tgoto out_close_logdev;\n\n\t\tif (rtdev == ddev || rtdev == logdev) {\n\t\t\txfs_warn(mp,\n\t\"Cannot mount filesystem with identical rtdev and ddev/logdev.\");\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_close_rtdev;\n\t\t}\n\t}\n\n\t \n\terror = -ENOMEM;\n\tmp->m_ddev_targp = xfs_alloc_buftarg(mp, ddev);\n\tif (!mp->m_ddev_targp)\n\t\tgoto out_close_rtdev;\n\n\tif (rtdev) {\n\t\tmp->m_rtdev_targp = xfs_alloc_buftarg(mp, rtdev);\n\t\tif (!mp->m_rtdev_targp)\n\t\t\tgoto out_free_ddev_targ;\n\t}\n\n\tif (logdev && logdev != ddev) {\n\t\tmp->m_logdev_targp = xfs_alloc_buftarg(mp, logdev);\n\t\tif (!mp->m_logdev_targp)\n\t\t\tgoto out_free_rtdev_targ;\n\t} else {\n\t\tmp->m_logdev_targp = mp->m_ddev_targp;\n\t}\n\n\terror = 0;\nout_relock:\n\tdown_write(&sb->s_umount);\n\treturn error;\n\n out_free_rtdev_targ:\n\tif (mp->m_rtdev_targp)\n\t\txfs_free_buftarg(mp->m_rtdev_targp);\n out_free_ddev_targ:\n\txfs_free_buftarg(mp->m_ddev_targp);\n out_close_rtdev:\n\t if (rtdev)\n\t\t blkdev_put(rtdev, sb);\n out_close_logdev:\n\tif (logdev && logdev != ddev)\n\t\tblkdev_put(logdev, sb);\n\tgoto out_relock;\n}\n\n \nSTATIC int\nxfs_setup_devices(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\terror;\n\n\terror = xfs_setsize_buftarg(mp->m_ddev_targp, mp->m_sb.sb_sectsize);\n\tif (error)\n\t\treturn error;\n\n\tif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp) {\n\t\tunsigned int\tlog_sector_size = BBSIZE;\n\n\t\tif (xfs_has_sector(mp))\n\t\t\tlog_sector_size = mp->m_sb.sb_logsectsize;\n\t\terror = xfs_setsize_buftarg(mp->m_logdev_targp,\n\t\t\t\t\t    log_sector_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (mp->m_rtdev_targp) {\n\t\terror = xfs_setsize_buftarg(mp->m_rtdev_targp,\n\t\t\t\t\t    mp->m_sb.sb_sectsize);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nSTATIC int\nxfs_init_mount_workqueues(\n\tstruct xfs_mount\t*mp)\n{\n\tmp->m_buf_workqueue = alloc_workqueue(\"xfs-buf/%s\",\n\t\t\tXFS_WQFLAGS(WQ_FREEZABLE | WQ_MEM_RECLAIM),\n\t\t\t1, mp->m_super->s_id);\n\tif (!mp->m_buf_workqueue)\n\t\tgoto out;\n\n\tmp->m_unwritten_workqueue = alloc_workqueue(\"xfs-conv/%s\",\n\t\t\tXFS_WQFLAGS(WQ_FREEZABLE | WQ_MEM_RECLAIM),\n\t\t\t0, mp->m_super->s_id);\n\tif (!mp->m_unwritten_workqueue)\n\t\tgoto out_destroy_buf;\n\n\tmp->m_reclaim_workqueue = alloc_workqueue(\"xfs-reclaim/%s\",\n\t\t\tXFS_WQFLAGS(WQ_FREEZABLE | WQ_MEM_RECLAIM),\n\t\t\t0, mp->m_super->s_id);\n\tif (!mp->m_reclaim_workqueue)\n\t\tgoto out_destroy_unwritten;\n\n\tmp->m_blockgc_wq = alloc_workqueue(\"xfs-blockgc/%s\",\n\t\t\tXFS_WQFLAGS(WQ_UNBOUND | WQ_FREEZABLE | WQ_MEM_RECLAIM),\n\t\t\t0, mp->m_super->s_id);\n\tif (!mp->m_blockgc_wq)\n\t\tgoto out_destroy_reclaim;\n\n\tmp->m_inodegc_wq = alloc_workqueue(\"xfs-inodegc/%s\",\n\t\t\tXFS_WQFLAGS(WQ_FREEZABLE | WQ_MEM_RECLAIM),\n\t\t\t1, mp->m_super->s_id);\n\tif (!mp->m_inodegc_wq)\n\t\tgoto out_destroy_blockgc;\n\n\tmp->m_sync_workqueue = alloc_workqueue(\"xfs-sync/%s\",\n\t\t\tXFS_WQFLAGS(WQ_FREEZABLE), 0, mp->m_super->s_id);\n\tif (!mp->m_sync_workqueue)\n\t\tgoto out_destroy_inodegc;\n\n\treturn 0;\n\nout_destroy_inodegc:\n\tdestroy_workqueue(mp->m_inodegc_wq);\nout_destroy_blockgc:\n\tdestroy_workqueue(mp->m_blockgc_wq);\nout_destroy_reclaim:\n\tdestroy_workqueue(mp->m_reclaim_workqueue);\nout_destroy_unwritten:\n\tdestroy_workqueue(mp->m_unwritten_workqueue);\nout_destroy_buf:\n\tdestroy_workqueue(mp->m_buf_workqueue);\nout:\n\treturn -ENOMEM;\n}\n\nSTATIC void\nxfs_destroy_mount_workqueues(\n\tstruct xfs_mount\t*mp)\n{\n\tdestroy_workqueue(mp->m_sync_workqueue);\n\tdestroy_workqueue(mp->m_blockgc_wq);\n\tdestroy_workqueue(mp->m_inodegc_wq);\n\tdestroy_workqueue(mp->m_reclaim_workqueue);\n\tdestroy_workqueue(mp->m_unwritten_workqueue);\n\tdestroy_workqueue(mp->m_buf_workqueue);\n}\n\nstatic void\nxfs_flush_inodes_worker(\n\tstruct work_struct\t*work)\n{\n\tstruct xfs_mount\t*mp = container_of(work, struct xfs_mount,\n\t\t\t\t\t\t   m_flush_inodes_work);\n\tstruct super_block\t*sb = mp->m_super;\n\n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tsync_inodes_sb(sb);\n\t\tup_read(&sb->s_umount);\n\t}\n}\n\n \nvoid\nxfs_flush_inodes(\n\tstruct xfs_mount\t*mp)\n{\n\t \n\tif (flush_work(&mp->m_flush_inodes_work))\n\t\treturn;\n\n\tqueue_work(mp->m_sync_workqueue, &mp->m_flush_inodes_work);\n\tflush_work(&mp->m_flush_inodes_work);\n}\n\n \nSTATIC struct inode *\nxfs_fs_alloc_inode(\n\tstruct super_block\t*sb)\n{\n\tBUG();\n\treturn NULL;\n}\n\n \nSTATIC void\nxfs_fs_destroy_inode(\n\tstruct inode\t\t*inode)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\n\ttrace_xfs_destroy_inode(ip);\n\n\tASSERT(!rwsem_is_locked(&inode->i_rwsem));\n\tXFS_STATS_INC(ip->i_mount, vn_rele);\n\tXFS_STATS_INC(ip->i_mount, vn_remove);\n\txfs_inode_mark_reclaimable(ip);\n}\n\nstatic void\nxfs_fs_dirty_inode(\n\tstruct inode\t\t\t*inode,\n\tint\t\t\t\tflags)\n{\n\tstruct xfs_inode\t\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t\t*mp = ip->i_mount;\n\tstruct xfs_trans\t\t*tp;\n\n\tif (!(inode->i_sb->s_flags & SB_LAZYTIME))\n\t\treturn;\n\n\t \n\tif ((flags & ~I_DIRTY_TIME) != I_DIRTY_SYNC || !(flags & I_DIRTY_TIME))\n\t\treturn;\n\n\tif (xfs_trans_alloc(mp, &M_RES(mp)->tr_fsyncts, 0, 0, 0, &tp))\n\t\treturn;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_TIMESTAMP);\n\txfs_trans_commit(tp);\n}\n\n \nSTATIC void\nxfs_fs_inode_init_once(\n\tvoid\t\t\t*inode)\n{\n\tstruct xfs_inode\t*ip = inode;\n\n\tmemset(ip, 0, sizeof(struct xfs_inode));\n\n\t \n\tinode_init_once(VFS_I(ip));\n\n\t \n\tatomic_set(&ip->i_pincount, 0);\n\tspin_lock_init(&ip->i_flags_lock);\n\n\tmrlock_init(&ip->i_lock, MRLOCK_ALLOW_EQUAL_PRI|MRLOCK_BARRIER,\n\t\t     \"xfsino\", ip->i_ino);\n}\n\n \nSTATIC int\nxfs_fs_drop_inode(\n\tstruct inode\t\t*inode)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\n\t \n\tif (ip->i_flags & XFS_IRECOVERY) {\n\t\tASSERT(xlog_recovery_needed(ip->i_mount->m_log));\n\t\treturn 0;\n\t}\n\n\treturn generic_drop_inode(inode);\n}\n\nstatic void\nxfs_mount_free(\n\tstruct xfs_mount\t*mp)\n{\n\t \n\tif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp)\n\t\txfs_free_buftarg(mp->m_logdev_targp);\n\tif (mp->m_rtdev_targp)\n\t\txfs_free_buftarg(mp->m_rtdev_targp);\n\tif (mp->m_ddev_targp)\n\t\txfs_free_buftarg(mp->m_ddev_targp);\n\n\tdebugfs_remove(mp->m_debugfs);\n\tkfree(mp->m_rtname);\n\tkfree(mp->m_logname);\n\tkmem_free(mp);\n}\n\nSTATIC int\nxfs_fs_sync_fs(\n\tstruct super_block\t*sb,\n\tint\t\t\twait)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\tint\t\t\terror;\n\n\ttrace_xfs_fs_sync_fs(mp, __return_address);\n\n\t \n\tif (!wait)\n\t\treturn 0;\n\n\terror = xfs_log_force(mp, XFS_LOG_SYNC);\n\tif (error)\n\t\treturn error;\n\n\tif (laptop_mode) {\n\t\t \n\t\tflush_delayed_work(&mp->m_log->l_work);\n\t}\n\n\t \n\tif (sb->s_writers.frozen == SB_FREEZE_PAGEFAULT) {\n\t\txfs_inodegc_stop(mp);\n\t\txfs_blockgc_stop(mp);\n\t}\n\n\treturn 0;\n}\n\nSTATIC int\nxfs_fs_statfs(\n\tstruct dentry\t\t*dentry,\n\tstruct kstatfs\t\t*statp)\n{\n\tstruct xfs_mount\t*mp = XFS_M(dentry->d_sb);\n\txfs_sb_t\t\t*sbp = &mp->m_sb;\n\tstruct xfs_inode\t*ip = XFS_I(d_inode(dentry));\n\tuint64_t\t\tfakeinos, id;\n\tuint64_t\t\ticount;\n\tuint64_t\t\tifree;\n\tuint64_t\t\tfdblocks;\n\txfs_extlen_t\t\tlsize;\n\tint64_t\t\t\tffree;\n\n\t \n\txfs_inodegc_push(mp);\n\n\tstatp->f_type = XFS_SUPER_MAGIC;\n\tstatp->f_namelen = MAXNAMELEN - 1;\n\n\tid = huge_encode_dev(mp->m_ddev_targp->bt_dev);\n\tstatp->f_fsid = u64_to_fsid(id);\n\n\ticount = percpu_counter_sum(&mp->m_icount);\n\tifree = percpu_counter_sum(&mp->m_ifree);\n\tfdblocks = percpu_counter_sum(&mp->m_fdblocks);\n\n\tspin_lock(&mp->m_sb_lock);\n\tstatp->f_bsize = sbp->sb_blocksize;\n\tlsize = sbp->sb_logstart ? sbp->sb_logblocks : 0;\n\tstatp->f_blocks = sbp->sb_dblocks - lsize;\n\tspin_unlock(&mp->m_sb_lock);\n\n\t \n\tstatp->f_bfree = max_t(int64_t, 0,\n\t\t\t\tfdblocks - xfs_fdblocks_unavailable(mp));\n\tstatp->f_bavail = statp->f_bfree;\n\n\tfakeinos = XFS_FSB_TO_INO(mp, statp->f_bfree);\n\tstatp->f_files = min(icount + fakeinos, (uint64_t)XFS_MAXINUMBER);\n\tif (M_IGEO(mp)->maxicount)\n\t\tstatp->f_files = min_t(typeof(statp->f_files),\n\t\t\t\t\tstatp->f_files,\n\t\t\t\t\tM_IGEO(mp)->maxicount);\n\n\t \n\tstatp->f_files = max_t(typeof(statp->f_files),\n\t\t\t\t\tstatp->f_files,\n\t\t\t\t\tsbp->sb_icount);\n\n\t \n\tffree = statp->f_files - (icount - ifree);\n\tstatp->f_ffree = max_t(int64_t, ffree, 0);\n\n\n\tif ((ip->i_diflags & XFS_DIFLAG_PROJINHERIT) &&\n\t    ((mp->m_qflags & (XFS_PQUOTA_ACCT|XFS_PQUOTA_ENFD))) ==\n\t\t\t      (XFS_PQUOTA_ACCT|XFS_PQUOTA_ENFD))\n\t\txfs_qm_statvfs(ip, statp);\n\n\tif (XFS_IS_REALTIME_MOUNT(mp) &&\n\t    (ip->i_diflags & (XFS_DIFLAG_RTINHERIT | XFS_DIFLAG_REALTIME))) {\n\t\ts64\tfreertx;\n\n\t\tstatp->f_blocks = sbp->sb_rblocks;\n\t\tfreertx = percpu_counter_sum_positive(&mp->m_frextents);\n\t\tstatp->f_bavail = statp->f_bfree = freertx * sbp->sb_rextsize;\n\t}\n\n\treturn 0;\n}\n\nSTATIC void\nxfs_save_resvblks(struct xfs_mount *mp)\n{\n\tuint64_t resblks = 0;\n\n\tmp->m_resblks_save = mp->m_resblks;\n\txfs_reserve_blocks(mp, &resblks, NULL);\n}\n\nSTATIC void\nxfs_restore_resvblks(struct xfs_mount *mp)\n{\n\tuint64_t resblks;\n\n\tif (mp->m_resblks_save) {\n\t\tresblks = mp->m_resblks_save;\n\t\tmp->m_resblks_save = 0;\n\t} else\n\t\tresblks = xfs_default_resblks(mp);\n\n\txfs_reserve_blocks(mp, &resblks, NULL);\n}\n\n \nSTATIC int\nxfs_fs_freeze(\n\tstruct super_block\t*sb)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\tunsigned int\t\tflags;\n\tint\t\t\tret;\n\n\t \n\tflags = memalloc_nofs_save();\n\txfs_save_resvblks(mp);\n\tret = xfs_log_quiesce(mp);\n\tmemalloc_nofs_restore(flags);\n\n\t \n\tif (ret && !xfs_is_readonly(mp)) {\n\t\txfs_blockgc_start(mp);\n\t\txfs_inodegc_start(mp);\n\t}\n\n\treturn ret;\n}\n\nSTATIC int\nxfs_fs_unfreeze(\n\tstruct super_block\t*sb)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\txfs_restore_resvblks(mp);\n\txfs_log_work_queue(mp);\n\n\t \n\tif (!xfs_is_readonly(mp)) {\n\t\txfs_blockgc_start(mp);\n\t\txfs_inodegc_start(mp);\n\t}\n\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_finish_flags(\n\tstruct xfs_mount\t*mp)\n{\n\t \n\tif (xfs_has_logv2(mp)) {\n\t\tif (mp->m_logbsize <= 0 &&\n\t\t    mp->m_sb.sb_logsunit > XLOG_BIG_RECORD_BSIZE) {\n\t\t\tmp->m_logbsize = mp->m_sb.sb_logsunit;\n\t\t} else if (mp->m_logbsize > 0 &&\n\t\t\t   mp->m_logbsize < mp->m_sb.sb_logsunit) {\n\t\t\txfs_warn(mp,\n\t\t\"logbuf size must be greater than or equal to log stripe size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t \n\t\tif (mp->m_logbsize > XLOG_BIG_RECORD_BSIZE) {\n\t\t\txfs_warn(mp,\n\t\t\"logbuf size for version 1 logs must be 16K or 32K\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (xfs_has_crc(mp) && xfs_has_noattr2(mp)) {\n\t\txfs_warn(mp, \"Cannot mount a V5 filesystem as noattr2. \"\n\t\t\t     \"attr2 is always enabled for V5 filesystems.\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((mp->m_sb.sb_flags & XFS_SBF_READONLY) && !xfs_is_readonly(mp)) {\n\t\txfs_warn(mp,\n\t\t\t\"cannot mount a read-only filesystem as read-write\");\n\t\treturn -EROFS;\n\t}\n\n\tif ((mp->m_qflags & XFS_GQUOTA_ACCT) &&\n\t    (mp->m_qflags & XFS_PQUOTA_ACCT) &&\n\t    !xfs_has_pquotino(mp)) {\n\t\txfs_warn(mp,\n\t\t  \"Super block does not support project and group quota together\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nxfs_init_percpu_counters(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\terror;\n\n\terror = percpu_counter_init(&mp->m_icount, 0, GFP_KERNEL);\n\tif (error)\n\t\treturn -ENOMEM;\n\n\terror = percpu_counter_init(&mp->m_ifree, 0, GFP_KERNEL);\n\tif (error)\n\t\tgoto free_icount;\n\n\terror = percpu_counter_init(&mp->m_fdblocks, 0, GFP_KERNEL);\n\tif (error)\n\t\tgoto free_ifree;\n\n\terror = percpu_counter_init(&mp->m_delalloc_blks, 0, GFP_KERNEL);\n\tif (error)\n\t\tgoto free_fdblocks;\n\n\terror = percpu_counter_init(&mp->m_frextents, 0, GFP_KERNEL);\n\tif (error)\n\t\tgoto free_delalloc;\n\n\treturn 0;\n\nfree_delalloc:\n\tpercpu_counter_destroy(&mp->m_delalloc_blks);\nfree_fdblocks:\n\tpercpu_counter_destroy(&mp->m_fdblocks);\nfree_ifree:\n\tpercpu_counter_destroy(&mp->m_ifree);\nfree_icount:\n\tpercpu_counter_destroy(&mp->m_icount);\n\treturn -ENOMEM;\n}\n\nvoid\nxfs_reinit_percpu_counters(\n\tstruct xfs_mount\t*mp)\n{\n\tpercpu_counter_set(&mp->m_icount, mp->m_sb.sb_icount);\n\tpercpu_counter_set(&mp->m_ifree, mp->m_sb.sb_ifree);\n\tpercpu_counter_set(&mp->m_fdblocks, mp->m_sb.sb_fdblocks);\n\tpercpu_counter_set(&mp->m_frextents, mp->m_sb.sb_frextents);\n}\n\nstatic void\nxfs_destroy_percpu_counters(\n\tstruct xfs_mount\t*mp)\n{\n\tpercpu_counter_destroy(&mp->m_icount);\n\tpercpu_counter_destroy(&mp->m_ifree);\n\tpercpu_counter_destroy(&mp->m_fdblocks);\n\tASSERT(xfs_is_shutdown(mp) ||\n\t       percpu_counter_sum(&mp->m_delalloc_blks) == 0);\n\tpercpu_counter_destroy(&mp->m_delalloc_blks);\n\tpercpu_counter_destroy(&mp->m_frextents);\n}\n\nstatic int\nxfs_inodegc_init_percpu(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_inodegc\t*gc;\n\tint\t\t\tcpu;\n\n\tmp->m_inodegc = alloc_percpu(struct xfs_inodegc);\n\tif (!mp->m_inodegc)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tgc = per_cpu_ptr(mp->m_inodegc, cpu);\n\t\tgc->cpu = cpu;\n\t\tgc->mp = mp;\n\t\tinit_llist_head(&gc->list);\n\t\tgc->items = 0;\n\t\tgc->error = 0;\n\t\tINIT_DELAYED_WORK(&gc->work, xfs_inodegc_worker);\n\t}\n\treturn 0;\n}\n\nstatic void\nxfs_inodegc_free_percpu(\n\tstruct xfs_mount\t*mp)\n{\n\tif (!mp->m_inodegc)\n\t\treturn;\n\tfree_percpu(mp->m_inodegc);\n}\n\nstatic void\nxfs_fs_put_super(\n\tstruct super_block\t*sb)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\txfs_notice(mp, \"Unmounting Filesystem %pU\", &mp->m_sb.sb_uuid);\n\txfs_filestream_unmount(mp);\n\txfs_unmountfs(mp);\n\n\txfs_freesb(mp);\n\txchk_mount_stats_free(mp);\n\tfree_percpu(mp->m_stats.xs_stats);\n\txfs_inodegc_free_percpu(mp);\n\txfs_destroy_percpu_counters(mp);\n\txfs_destroy_mount_workqueues(mp);\n\txfs_shutdown_devices(mp);\n}\n\nstatic long\nxfs_fs_nr_cached_objects(\n\tstruct super_block\t*sb,\n\tstruct shrink_control\t*sc)\n{\n\t \n\tif (WARN_ON_ONCE(!sb->s_fs_info))\n\t\treturn 0;\n\treturn xfs_reclaim_inodes_count(XFS_M(sb));\n}\n\nstatic long\nxfs_fs_free_cached_objects(\n\tstruct super_block\t*sb,\n\tstruct shrink_control\t*sc)\n{\n\treturn xfs_reclaim_inodes_nr(XFS_M(sb), sc->nr_to_scan);\n}\n\nstatic void\nxfs_fs_shutdown(\n\tstruct super_block\t*sb)\n{\n\txfs_force_shutdown(XFS_M(sb), SHUTDOWN_DEVICE_REMOVED);\n}\n\nstatic const struct super_operations xfs_super_operations = {\n\t.alloc_inode\t\t= xfs_fs_alloc_inode,\n\t.destroy_inode\t\t= xfs_fs_destroy_inode,\n\t.dirty_inode\t\t= xfs_fs_dirty_inode,\n\t.drop_inode\t\t= xfs_fs_drop_inode,\n\t.put_super\t\t= xfs_fs_put_super,\n\t.sync_fs\t\t= xfs_fs_sync_fs,\n\t.freeze_fs\t\t= xfs_fs_freeze,\n\t.unfreeze_fs\t\t= xfs_fs_unfreeze,\n\t.statfs\t\t\t= xfs_fs_statfs,\n\t.show_options\t\t= xfs_fs_show_options,\n\t.nr_cached_objects\t= xfs_fs_nr_cached_objects,\n\t.free_cached_objects\t= xfs_fs_free_cached_objects,\n\t.shutdown\t\t= xfs_fs_shutdown,\n};\n\nstatic int\nsuffix_kstrtoint(\n\tconst char\t*s,\n\tunsigned int\tbase,\n\tint\t\t*res)\n{\n\tint\t\tlast, shift_left_factor = 0, _res;\n\tchar\t\t*value;\n\tint\t\tret = 0;\n\n\tvalue = kstrdup(s, GFP_KERNEL);\n\tif (!value)\n\t\treturn -ENOMEM;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(value, base, &_res))\n\t\tret = -EINVAL;\n\tkfree(value);\n\t*res = _res << shift_left_factor;\n\treturn ret;\n}\n\nstatic inline void\nxfs_fs_warn_deprecated(\n\tstruct fs_context\t*fc,\n\tstruct fs_parameter\t*param,\n\tuint64_t\t\tflag,\n\tbool\t\t\tvalue)\n{\n\t \n\tif ((fc->purpose & FS_CONTEXT_FOR_RECONFIGURE) &&\n            !!(XFS_M(fc->root->d_sb)->m_features & flag) == value)\n\t\treturn;\n\txfs_warn(fc->s_fs_info, \"%s mount option is deprecated.\", param->key);\n}\n\n \nstatic int\nxfs_fs_parse_param(\n\tstruct fs_context\t*fc,\n\tstruct fs_parameter\t*param)\n{\n\tstruct xfs_mount\t*parsing_mp = fc->s_fs_info;\n\tstruct fs_parse_result\tresult;\n\tint\t\t\tsize = 0;\n\tint\t\t\topt;\n\n\topt = fs_parse(fc, xfs_fs_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_logbufs:\n\t\tparsing_mp->m_logbufs = result.uint_32;\n\t\treturn 0;\n\tcase Opt_logbsize:\n\t\tif (suffix_kstrtoint(param->string, 10, &parsing_mp->m_logbsize))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\tcase Opt_logdev:\n\t\tkfree(parsing_mp->m_logname);\n\t\tparsing_mp->m_logname = kstrdup(param->string, GFP_KERNEL);\n\t\tif (!parsing_mp->m_logname)\n\t\t\treturn -ENOMEM;\n\t\treturn 0;\n\tcase Opt_rtdev:\n\t\tkfree(parsing_mp->m_rtname);\n\t\tparsing_mp->m_rtname = kstrdup(param->string, GFP_KERNEL);\n\t\tif (!parsing_mp->m_rtname)\n\t\t\treturn -ENOMEM;\n\t\treturn 0;\n\tcase Opt_allocsize:\n\t\tif (suffix_kstrtoint(param->string, 10, &size))\n\t\t\treturn -EINVAL;\n\t\tparsing_mp->m_allocsize_log = ffs(size) - 1;\n\t\tparsing_mp->m_features |= XFS_FEAT_ALLOCSIZE;\n\t\treturn 0;\n\tcase Opt_grpid:\n\tcase Opt_bsdgroups:\n\t\tparsing_mp->m_features |= XFS_FEAT_GRPID;\n\t\treturn 0;\n\tcase Opt_nogrpid:\n\tcase Opt_sysvgroups:\n\t\tparsing_mp->m_features &= ~XFS_FEAT_GRPID;\n\t\treturn 0;\n\tcase Opt_wsync:\n\t\tparsing_mp->m_features |= XFS_FEAT_WSYNC;\n\t\treturn 0;\n\tcase Opt_norecovery:\n\t\tparsing_mp->m_features |= XFS_FEAT_NORECOVERY;\n\t\treturn 0;\n\tcase Opt_noalign:\n\t\tparsing_mp->m_features |= XFS_FEAT_NOALIGN;\n\t\treturn 0;\n\tcase Opt_swalloc:\n\t\tparsing_mp->m_features |= XFS_FEAT_SWALLOC;\n\t\treturn 0;\n\tcase Opt_sunit:\n\t\tparsing_mp->m_dalign = result.uint_32;\n\t\treturn 0;\n\tcase Opt_swidth:\n\t\tparsing_mp->m_swidth = result.uint_32;\n\t\treturn 0;\n\tcase Opt_inode32:\n\t\tparsing_mp->m_features |= XFS_FEAT_SMALL_INUMS;\n\t\treturn 0;\n\tcase Opt_inode64:\n\t\tparsing_mp->m_features &= ~XFS_FEAT_SMALL_INUMS;\n\t\treturn 0;\n\tcase Opt_nouuid:\n\t\tparsing_mp->m_features |= XFS_FEAT_NOUUID;\n\t\treturn 0;\n\tcase Opt_largeio:\n\t\tparsing_mp->m_features |= XFS_FEAT_LARGE_IOSIZE;\n\t\treturn 0;\n\tcase Opt_nolargeio:\n\t\tparsing_mp->m_features &= ~XFS_FEAT_LARGE_IOSIZE;\n\t\treturn 0;\n\tcase Opt_filestreams:\n\t\tparsing_mp->m_features |= XFS_FEAT_FILESTREAMS;\n\t\treturn 0;\n\tcase Opt_noquota:\n\t\tparsing_mp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;\n\t\tparsing_mp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;\n\t\treturn 0;\n\tcase Opt_quota:\n\tcase Opt_uquota:\n\tcase Opt_usrquota:\n\t\tparsing_mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ENFD);\n\t\treturn 0;\n\tcase Opt_qnoenforce:\n\tcase Opt_uqnoenforce:\n\t\tparsing_mp->m_qflags |= XFS_UQUOTA_ACCT;\n\t\tparsing_mp->m_qflags &= ~XFS_UQUOTA_ENFD;\n\t\treturn 0;\n\tcase Opt_pquota:\n\tcase Opt_prjquota:\n\t\tparsing_mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ENFD);\n\t\treturn 0;\n\tcase Opt_pqnoenforce:\n\t\tparsing_mp->m_qflags |= XFS_PQUOTA_ACCT;\n\t\tparsing_mp->m_qflags &= ~XFS_PQUOTA_ENFD;\n\t\treturn 0;\n\tcase Opt_gquota:\n\tcase Opt_grpquota:\n\t\tparsing_mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ENFD);\n\t\treturn 0;\n\tcase Opt_gqnoenforce:\n\t\tparsing_mp->m_qflags |= XFS_GQUOTA_ACCT;\n\t\tparsing_mp->m_qflags &= ~XFS_GQUOTA_ENFD;\n\t\treturn 0;\n\tcase Opt_discard:\n\t\tparsing_mp->m_features |= XFS_FEAT_DISCARD;\n\t\treturn 0;\n\tcase Opt_nodiscard:\n\t\tparsing_mp->m_features &= ~XFS_FEAT_DISCARD;\n\t\treturn 0;\n#ifdef CONFIG_FS_DAX\n\tcase Opt_dax:\n\t\txfs_mount_set_dax_mode(parsing_mp, XFS_DAX_ALWAYS);\n\t\treturn 0;\n\tcase Opt_dax_enum:\n\t\txfs_mount_set_dax_mode(parsing_mp, result.uint_32);\n\t\treturn 0;\n#endif\n\t \n\tcase Opt_ikeep:\n\t\txfs_fs_warn_deprecated(fc, param, XFS_FEAT_IKEEP, true);\n\t\tparsing_mp->m_features |= XFS_FEAT_IKEEP;\n\t\treturn 0;\n\tcase Opt_noikeep:\n\t\txfs_fs_warn_deprecated(fc, param, XFS_FEAT_IKEEP, false);\n\t\tparsing_mp->m_features &= ~XFS_FEAT_IKEEP;\n\t\treturn 0;\n\tcase Opt_attr2:\n\t\txfs_fs_warn_deprecated(fc, param, XFS_FEAT_ATTR2, true);\n\t\tparsing_mp->m_features |= XFS_FEAT_ATTR2;\n\t\treturn 0;\n\tcase Opt_noattr2:\n\t\txfs_fs_warn_deprecated(fc, param, XFS_FEAT_NOATTR2, true);\n\t\tparsing_mp->m_features |= XFS_FEAT_NOATTR2;\n\t\treturn 0;\n\tdefault:\n\t\txfs_warn(parsing_mp, \"unknown mount option [%s].\", param->key);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nxfs_fs_validate_params(\n\tstruct xfs_mount\t*mp)\n{\n\t \n\tif (xfs_has_norecovery(mp) && !xfs_is_readonly(mp)) {\n\t\txfs_warn(mp, \"no-recovery mounts must be read-only.\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (xfs_has_attr2(mp) && xfs_has_noattr2(mp)) {\n\t\txfs_warn(mp, \"attr2 and noattr2 cannot both be specified.\");\n\t\treturn -EINVAL;\n\t}\n\n\n\tif (xfs_has_noalign(mp) && (mp->m_dalign || mp->m_swidth)) {\n\t\txfs_warn(mp,\n\t\"sunit and swidth options incompatible with the noalign option\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_XFS_QUOTA) && mp->m_qflags != 0) {\n\t\txfs_warn(mp, \"quota support not available in this kernel.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((mp->m_dalign && !mp->m_swidth) ||\n\t    (!mp->m_dalign && mp->m_swidth)) {\n\t\txfs_warn(mp, \"sunit and swidth must be specified together\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mp->m_dalign && (mp->m_swidth % mp->m_dalign != 0)) {\n\t\txfs_warn(mp,\n\t\"stripe width (%d) must be a multiple of the stripe unit (%d)\",\n\t\t\tmp->m_swidth, mp->m_dalign);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mp->m_logbufs != -1 &&\n\t    mp->m_logbufs != 0 &&\n\t    (mp->m_logbufs < XLOG_MIN_ICLOGS ||\n\t     mp->m_logbufs > XLOG_MAX_ICLOGS)) {\n\t\txfs_warn(mp, \"invalid logbufs value: %d [not %d-%d]\",\n\t\t\tmp->m_logbufs, XLOG_MIN_ICLOGS, XLOG_MAX_ICLOGS);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mp->m_logbsize != -1 &&\n\t    mp->m_logbsize !=  0 &&\n\t    (mp->m_logbsize < XLOG_MIN_RECORD_BSIZE ||\n\t     mp->m_logbsize > XLOG_MAX_RECORD_BSIZE ||\n\t     !is_power_of_2(mp->m_logbsize))) {\n\t\txfs_warn(mp,\n\t\t\t\"invalid logbufsize: %d [not 16k,32k,64k,128k or 256k]\",\n\t\t\tmp->m_logbsize);\n\t\treturn -EINVAL;\n\t}\n\n\tif (xfs_has_allocsize(mp) &&\n\t    (mp->m_allocsize_log > XFS_MAX_IO_LOG ||\n\t     mp->m_allocsize_log < XFS_MIN_IO_LOG)) {\n\t\txfs_warn(mp, \"invalid log iosize: %d [not %d-%d]\",\n\t\t\tmp->m_allocsize_log, XFS_MIN_IO_LOG, XFS_MAX_IO_LOG);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstruct dentry *\nxfs_debugfs_mkdir(\n\tconst char\t*name,\n\tstruct dentry\t*parent)\n{\n\tstruct dentry\t*child;\n\n\t \n\tchild = debugfs_create_dir(name, parent);\n\tif (IS_ERR(child))\n\t\treturn NULL;\n\n\treturn child;\n}\n\nstatic int\nxfs_fs_fill_super(\n\tstruct super_block\t*sb,\n\tstruct fs_context\t*fc)\n{\n\tstruct xfs_mount\t*mp = sb->s_fs_info;\n\tstruct inode\t\t*root;\n\tint\t\t\tflags = 0, error;\n\n\tmp->m_super = sb;\n\n\terror = xfs_fs_validate_params(mp);\n\tif (error)\n\t\treturn error;\n\n\tsb_min_blocksize(sb, BBSIZE);\n\tsb->s_xattr = xfs_xattr_handlers;\n\tsb->s_export_op = &xfs_export_operations;\n#ifdef CONFIG_XFS_QUOTA\n\tsb->s_qcop = &xfs_quotactl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tsb->s_op = &xfs_super_operations;\n\n\t \n\tif (xfs_globals.mount_delay) {\n\t\txfs_notice(mp, \"Delaying mount for %d seconds.\",\n\t\t\txfs_globals.mount_delay);\n\t\tmsleep(xfs_globals.mount_delay * 1000);\n\t}\n\n\tif (fc->sb_flags & SB_SILENT)\n\t\tflags |= XFS_MFSI_QUIET;\n\n\terror = xfs_open_devices(mp);\n\tif (error)\n\t\treturn error;\n\n\tif (xfs_debugfs) {\n\t\tmp->m_debugfs = xfs_debugfs_mkdir(mp->m_super->s_id,\n\t\t\t\t\t\t  xfs_debugfs);\n\t} else {\n\t\tmp->m_debugfs = NULL;\n\t}\n\n\terror = xfs_init_mount_workqueues(mp);\n\tif (error)\n\t\tgoto out_shutdown_devices;\n\n\terror = xfs_init_percpu_counters(mp);\n\tif (error)\n\t\tgoto out_destroy_workqueues;\n\n\terror = xfs_inodegc_init_percpu(mp);\n\tif (error)\n\t\tgoto out_destroy_counters;\n\n\t \n\tmp->m_stats.xs_stats = alloc_percpu(struct xfsstats);\n\tif (!mp->m_stats.xs_stats) {\n\t\terror = -ENOMEM;\n\t\tgoto out_destroy_inodegc;\n\t}\n\n\terror = xchk_mount_stats_alloc(mp);\n\tif (error)\n\t\tgoto out_free_stats;\n\n\terror = xfs_readsb(mp, flags);\n\tif (error)\n\t\tgoto out_free_scrub_stats;\n\n\terror = xfs_finish_flags(mp);\n\tif (error)\n\t\tgoto out_free_sb;\n\n\terror = xfs_setup_devices(mp);\n\tif (error)\n\t\tgoto out_free_sb;\n\n\t \n\tif (!xfs_has_crc(mp)) {\n#ifdef CONFIG_XFS_SUPPORT_V4\n\t\txfs_warn_once(mp,\n\t\"Deprecated V4 format (crc=0) will not be supported after September 2030.\");\n#else\n\t\txfs_warn(mp,\n\t\"Deprecated V4 format (crc=0) not supported by kernel.\");\n\t\terror = -EINVAL;\n\t\tgoto out_free_sb;\n#endif\n\t}\n\n\t \n\tif (xfs_has_asciici(mp)) {\n#ifdef CONFIG_XFS_SUPPORT_ASCII_CI\n\t\txfs_warn_once(mp,\n\t\"Deprecated ASCII case-insensitivity feature (ascii-ci=1) will not be supported after September 2030.\");\n#else\n\t\txfs_warn(mp,\n\t\"Deprecated ASCII case-insensitivity feature (ascii-ci=1) not supported by kernel.\");\n\t\terror = -EINVAL;\n\t\tgoto out_free_sb;\n#endif\n\t}\n\n\t \n\tif (xfs_has_needsrepair(mp)) {\n\t\txfs_warn(mp, \"Filesystem needs repair.  Please run xfs_repair.\");\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_free_sb;\n\t}\n\n\t \n\tif (mp->m_sb.sb_inprogress) {\n\t\txfs_warn(mp, \"Offline file system operation in progress!\");\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_free_sb;\n\t}\n\n\t \n\tif (mp->m_sb.sb_blocksize > PAGE_SIZE) {\n\t\txfs_warn(mp,\n\t\t\"File system with blocksize %d bytes. \"\n\t\t\"Only pagesize (%ld) or less will currently work.\",\n\t\t\t\tmp->m_sb.sb_blocksize, PAGE_SIZE);\n\t\terror = -ENOSYS;\n\t\tgoto out_free_sb;\n\t}\n\n\t \n\tif (xfs_sb_validate_fsb_count(&mp->m_sb, mp->m_sb.sb_dblocks) ||\n\t    xfs_sb_validate_fsb_count(&mp->m_sb, mp->m_sb.sb_rblocks)) {\n\t\txfs_warn(mp,\n\t\t\"file system too large to be mounted on this system.\");\n\t\terror = -EFBIG;\n\t\tgoto out_free_sb;\n\t}\n\n\t \n\tif (!xfs_verify_fileoff(mp, XFS_B_TO_FSBT(mp, MAX_LFS_FILESIZE))) {\n\t\txfs_warn(mp,\n\"MAX_LFS_FILESIZE block offset (%llu) exceeds extent map maximum (%llu)!\",\n\t\t\t XFS_B_TO_FSBT(mp, MAX_LFS_FILESIZE),\n\t\t\t XFS_MAX_FILEOFF);\n\t\terror = -EINVAL;\n\t\tgoto out_free_sb;\n\t}\n\n\terror = xfs_filestream_mount(mp);\n\tif (error)\n\t\tgoto out_free_sb;\n\n\t \n\tsb->s_magic = XFS_SUPER_MAGIC;\n\tsb->s_blocksize = mp->m_sb.sb_blocksize;\n\tsb->s_blocksize_bits = ffs(sb->s_blocksize) - 1;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_max_links = XFS_MAXLINK;\n\tsb->s_time_gran = 1;\n\tif (xfs_has_bigtime(mp)) {\n\t\tsb->s_time_min = xfs_bigtime_to_unix(XFS_BIGTIME_TIME_MIN);\n\t\tsb->s_time_max = xfs_bigtime_to_unix(XFS_BIGTIME_TIME_MAX);\n\t} else {\n\t\tsb->s_time_min = XFS_LEGACY_TIME_MIN;\n\t\tsb->s_time_max = XFS_LEGACY_TIME_MAX;\n\t}\n\ttrace_xfs_inode_timestamp_range(mp, sb->s_time_min, sb->s_time_max);\n\tsb->s_iflags |= SB_I_CGROUPWB;\n\n\tset_posix_acl_flag(sb);\n\n\t \n\tif (xfs_has_crc(mp))\n\t\tsb->s_flags |= SB_I_VERSION;\n\n\tif (xfs_has_dax_always(mp)) {\n\t\terror = xfs_setup_dax_always(mp);\n\t\tif (error)\n\t\t\tgoto out_filestream_unmount;\n\t}\n\n\tif (xfs_has_discard(mp) && !bdev_max_discard_sectors(sb->s_bdev)) {\n\t\txfs_warn(mp,\n\t\"mounting with \\\"discard\\\" option, but the device does not support discard\");\n\t\tmp->m_features &= ~XFS_FEAT_DISCARD;\n\t}\n\n\tif (xfs_has_reflink(mp)) {\n\t\tif (mp->m_sb.sb_rblocks) {\n\t\t\txfs_alert(mp,\n\t\"reflink not compatible with realtime device!\");\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_filestream_unmount;\n\t\t}\n\n\t\tif (xfs_globals.always_cow) {\n\t\t\txfs_info(mp, \"using DEBUG-only always_cow mode.\");\n\t\t\tmp->m_always_cow = true;\n\t\t}\n\t}\n\n\tif (xfs_has_rmapbt(mp) && mp->m_sb.sb_rblocks) {\n\t\txfs_alert(mp,\n\t\"reverse mapping btree not compatible with realtime device!\");\n\t\terror = -EINVAL;\n\t\tgoto out_filestream_unmount;\n\t}\n\n\terror = xfs_mountfs(mp);\n\tif (error)\n\t\tgoto out_filestream_unmount;\n\n\troot = igrab(VFS_I(mp->m_rootip));\n\tif (!root) {\n\t\terror = -ENOENT;\n\t\tgoto out_unmount;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\terror = -ENOMEM;\n\t\tgoto out_unmount;\n\t}\n\n\treturn 0;\n\n out_filestream_unmount:\n\txfs_filestream_unmount(mp);\n out_free_sb:\n\txfs_freesb(mp);\n out_free_scrub_stats:\n\txchk_mount_stats_free(mp);\n out_free_stats:\n\tfree_percpu(mp->m_stats.xs_stats);\n out_destroy_inodegc:\n\txfs_inodegc_free_percpu(mp);\n out_destroy_counters:\n\txfs_destroy_percpu_counters(mp);\n out_destroy_workqueues:\n\txfs_destroy_mount_workqueues(mp);\n out_shutdown_devices:\n\txfs_shutdown_devices(mp);\n\treturn error;\n\n out_unmount:\n\txfs_filestream_unmount(mp);\n\txfs_unmountfs(mp);\n\tgoto out_free_sb;\n}\n\nstatic int\nxfs_fs_get_tree(\n\tstruct fs_context\t*fc)\n{\n\treturn get_tree_bdev(fc, xfs_fs_fill_super);\n}\n\nstatic int\nxfs_remount_rw(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_sb\t\t*sbp = &mp->m_sb;\n\tint error;\n\n\tif (xfs_has_norecovery(mp)) {\n\t\txfs_warn(mp,\n\t\t\t\"ro->rw transition prohibited on norecovery mount\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (xfs_sb_is_v5(sbp) &&\n\t    xfs_sb_has_ro_compat_feature(sbp, XFS_SB_FEAT_RO_COMPAT_UNKNOWN)) {\n\t\txfs_warn(mp,\n\t\"ro->rw transition prohibited on unknown (0x%x) ro-compat filesystem\",\n\t\t\t(sbp->sb_features_ro_compat &\n\t\t\t\tXFS_SB_FEAT_RO_COMPAT_UNKNOWN));\n\t\treturn -EINVAL;\n\t}\n\n\tclear_bit(XFS_OPSTATE_READONLY, &mp->m_opstate);\n\n\t \n\tif (mp->m_update_sb) {\n\t\terror = xfs_sync_sb(mp, false);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"failed to write sb changes\");\n\t\t\treturn error;\n\t\t}\n\t\tmp->m_update_sb = false;\n\t}\n\n\t \n\txfs_restore_resvblks(mp);\n\txfs_log_work_queue(mp);\n\txfs_blockgc_start(mp);\n\n\t \n\terror = xfs_fs_reserve_ag_blocks(mp);\n\tif (error && error != -ENOSPC)\n\t\treturn error;\n\n\t \n\txfs_inodegc_start(mp);\n\n\treturn 0;\n}\n\nstatic int\nxfs_remount_ro(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_icwalk\ticw = {\n\t\t.icw_flags\t= XFS_ICWALK_FLAG_SYNC,\n\t};\n\tint\t\t\terror;\n\n\t \n\terror = sync_filesystem(mp->m_super);\n\tif (error)\n\t\treturn error;\n\n\t \n\txfs_blockgc_stop(mp);\n\n\t \n\terror = xfs_blockgc_free_space(mp, &icw);\n\tif (error) {\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\treturn error;\n\t}\n\n\t \n\txfs_inodegc_stop(mp);\n\n\t \n\terror = xfs_fs_unreserve_ag_blocks(mp);\n\tif (error) {\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\treturn error;\n\t}\n\n\t \n\txfs_save_resvblks(mp);\n\n\txfs_log_clean(mp);\n\tset_bit(XFS_OPSTATE_READONLY, &mp->m_opstate);\n\n\treturn 0;\n}\n\n \nstatic int\nxfs_fs_reconfigure(\n\tstruct fs_context *fc)\n{\n\tstruct xfs_mount\t*mp = XFS_M(fc->root->d_sb);\n\tstruct xfs_mount        *new_mp = fc->s_fs_info;\n\tint\t\t\tflags = fc->sb_flags;\n\tint\t\t\terror;\n\n\t \n\tif (xfs_has_crc(mp))\n\t\tfc->sb_flags |= SB_I_VERSION;\n\n\terror = xfs_fs_validate_params(new_mp);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (xfs_has_small_inums(mp) && !xfs_has_small_inums(new_mp)) {\n\t\tmp->m_features &= ~XFS_FEAT_SMALL_INUMS;\n\t\tmp->m_maxagi = xfs_set_inode_alloc(mp, mp->m_sb.sb_agcount);\n\t}\n\n\t \n\tif (!xfs_has_small_inums(mp) && xfs_has_small_inums(new_mp)) {\n\t\tmp->m_features |= XFS_FEAT_SMALL_INUMS;\n\t\tmp->m_maxagi = xfs_set_inode_alloc(mp, mp->m_sb.sb_agcount);\n\t}\n\n\t \n\tif (xfs_is_readonly(mp) && !(flags & SB_RDONLY)) {\n\t\terror = xfs_remount_rw(mp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\tif (!xfs_is_readonly(mp) && (flags & SB_RDONLY)) {\n\t\terror = xfs_remount_ro(mp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nxfs_fs_free(\n\tstruct fs_context\t*fc)\n{\n\tstruct xfs_mount\t*mp = fc->s_fs_info;\n\n\t \n\tif (mp)\n\t\txfs_mount_free(mp);\n}\n\nstatic const struct fs_context_operations xfs_context_ops = {\n\t.parse_param = xfs_fs_parse_param,\n\t.get_tree    = xfs_fs_get_tree,\n\t.reconfigure = xfs_fs_reconfigure,\n\t.free        = xfs_fs_free,\n};\n\nstatic int xfs_init_fs_context(\n\tstruct fs_context\t*fc)\n{\n\tstruct xfs_mount\t*mp;\n\n\tmp = kmem_alloc(sizeof(struct xfs_mount), KM_ZERO);\n\tif (!mp)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&mp->m_sb_lock);\n\tINIT_RADIX_TREE(&mp->m_perag_tree, GFP_ATOMIC);\n\tspin_lock_init(&mp->m_perag_lock);\n\tmutex_init(&mp->m_growlock);\n\tINIT_WORK(&mp->m_flush_inodes_work, xfs_flush_inodes_worker);\n\tINIT_DELAYED_WORK(&mp->m_reclaim_work, xfs_reclaim_worker);\n\tmp->m_kobj.kobject.kset = xfs_kset;\n\t \n\tmp->m_finobt_nores = true;\n\n\t \n\tmp->m_logbufs = -1;\n\tmp->m_logbsize = -1;\n\tmp->m_allocsize_log = 16;  \n\n\t \n\tif (fc->sb_flags & SB_RDONLY)\n\t\tset_bit(XFS_OPSTATE_READONLY, &mp->m_opstate);\n\tif (fc->sb_flags & SB_DIRSYNC)\n\t\tmp->m_features |= XFS_FEAT_DIRSYNC;\n\tif (fc->sb_flags & SB_SYNCHRONOUS)\n\t\tmp->m_features |= XFS_FEAT_WSYNC;\n\n\tfc->s_fs_info = mp;\n\tfc->ops = &xfs_context_ops;\n\n\treturn 0;\n}\n\nstatic void\nxfs_kill_sb(\n\tstruct super_block\t\t*sb)\n{\n\tkill_block_super(sb);\n\txfs_mount_free(XFS_M(sb));\n}\n\nstatic struct file_system_type xfs_fs_type = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"xfs\",\n\t.init_fs_context\t= xfs_init_fs_context,\n\t.parameters\t\t= xfs_fs_parameters,\n\t.kill_sb\t\t= xfs_kill_sb,\n\t.fs_flags\t\t= FS_REQUIRES_DEV | FS_ALLOW_IDMAP,\n};\nMODULE_ALIAS_FS(\"xfs\");\n\nSTATIC int __init\nxfs_init_caches(void)\n{\n\tint\t\terror;\n\n\txfs_buf_cache = kmem_cache_create(\"xfs_buf\", sizeof(struct xfs_buf), 0,\n\t\t\t\t\t SLAB_HWCACHE_ALIGN |\n\t\t\t\t\t SLAB_RECLAIM_ACCOUNT |\n\t\t\t\t\t SLAB_MEM_SPREAD,\n\t\t\t\t\t NULL);\n\tif (!xfs_buf_cache)\n\t\tgoto out;\n\n\txfs_log_ticket_cache = kmem_cache_create(\"xfs_log_ticket\",\n\t\t\t\t\t\tsizeof(struct xlog_ticket),\n\t\t\t\t\t\t0, 0, NULL);\n\tif (!xfs_log_ticket_cache)\n\t\tgoto out_destroy_buf_cache;\n\n\terror = xfs_btree_init_cur_caches();\n\tif (error)\n\t\tgoto out_destroy_log_ticket_cache;\n\n\terror = xfs_defer_init_item_caches();\n\tif (error)\n\t\tgoto out_destroy_btree_cur_cache;\n\n\txfs_da_state_cache = kmem_cache_create(\"xfs_da_state\",\n\t\t\t\t\t      sizeof(struct xfs_da_state),\n\t\t\t\t\t      0, 0, NULL);\n\tif (!xfs_da_state_cache)\n\t\tgoto out_destroy_defer_item_cache;\n\n\txfs_ifork_cache = kmem_cache_create(\"xfs_ifork\",\n\t\t\t\t\t   sizeof(struct xfs_ifork),\n\t\t\t\t\t   0, 0, NULL);\n\tif (!xfs_ifork_cache)\n\t\tgoto out_destroy_da_state_cache;\n\n\txfs_trans_cache = kmem_cache_create(\"xfs_trans\",\n\t\t\t\t\t   sizeof(struct xfs_trans),\n\t\t\t\t\t   0, 0, NULL);\n\tif (!xfs_trans_cache)\n\t\tgoto out_destroy_ifork_cache;\n\n\n\t \n\txfs_buf_item_cache = kmem_cache_create(\"xfs_buf_item\",\n\t\t\t\t\t      sizeof(struct xfs_buf_log_item),\n\t\t\t\t\t      0, 0, NULL);\n\tif (!xfs_buf_item_cache)\n\t\tgoto out_destroy_trans_cache;\n\n\txfs_efd_cache = kmem_cache_create(\"xfs_efd_item\",\n\t\t\txfs_efd_log_item_sizeof(XFS_EFD_MAX_FAST_EXTENTS),\n\t\t\t0, 0, NULL);\n\tif (!xfs_efd_cache)\n\t\tgoto out_destroy_buf_item_cache;\n\n\txfs_efi_cache = kmem_cache_create(\"xfs_efi_item\",\n\t\t\txfs_efi_log_item_sizeof(XFS_EFI_MAX_FAST_EXTENTS),\n\t\t\t0, 0, NULL);\n\tif (!xfs_efi_cache)\n\t\tgoto out_destroy_efd_cache;\n\n\txfs_inode_cache = kmem_cache_create(\"xfs_inode\",\n\t\t\t\t\t   sizeof(struct xfs_inode), 0,\n\t\t\t\t\t   (SLAB_HWCACHE_ALIGN |\n\t\t\t\t\t    SLAB_RECLAIM_ACCOUNT |\n\t\t\t\t\t    SLAB_MEM_SPREAD | SLAB_ACCOUNT),\n\t\t\t\t\t   xfs_fs_inode_init_once);\n\tif (!xfs_inode_cache)\n\t\tgoto out_destroy_efi_cache;\n\n\txfs_ili_cache = kmem_cache_create(\"xfs_ili\",\n\t\t\t\t\t sizeof(struct xfs_inode_log_item), 0,\n\t\t\t\t\t SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t\t NULL);\n\tif (!xfs_ili_cache)\n\t\tgoto out_destroy_inode_cache;\n\n\txfs_icreate_cache = kmem_cache_create(\"xfs_icr\",\n\t\t\t\t\t     sizeof(struct xfs_icreate_item),\n\t\t\t\t\t     0, 0, NULL);\n\tif (!xfs_icreate_cache)\n\t\tgoto out_destroy_ili_cache;\n\n\txfs_rud_cache = kmem_cache_create(\"xfs_rud_item\",\n\t\t\t\t\t sizeof(struct xfs_rud_log_item),\n\t\t\t\t\t 0, 0, NULL);\n\tif (!xfs_rud_cache)\n\t\tgoto out_destroy_icreate_cache;\n\n\txfs_rui_cache = kmem_cache_create(\"xfs_rui_item\",\n\t\t\txfs_rui_log_item_sizeof(XFS_RUI_MAX_FAST_EXTENTS),\n\t\t\t0, 0, NULL);\n\tif (!xfs_rui_cache)\n\t\tgoto out_destroy_rud_cache;\n\n\txfs_cud_cache = kmem_cache_create(\"xfs_cud_item\",\n\t\t\t\t\t sizeof(struct xfs_cud_log_item),\n\t\t\t\t\t 0, 0, NULL);\n\tif (!xfs_cud_cache)\n\t\tgoto out_destroy_rui_cache;\n\n\txfs_cui_cache = kmem_cache_create(\"xfs_cui_item\",\n\t\t\txfs_cui_log_item_sizeof(XFS_CUI_MAX_FAST_EXTENTS),\n\t\t\t0, 0, NULL);\n\tif (!xfs_cui_cache)\n\t\tgoto out_destroy_cud_cache;\n\n\txfs_bud_cache = kmem_cache_create(\"xfs_bud_item\",\n\t\t\t\t\t sizeof(struct xfs_bud_log_item),\n\t\t\t\t\t 0, 0, NULL);\n\tif (!xfs_bud_cache)\n\t\tgoto out_destroy_cui_cache;\n\n\txfs_bui_cache = kmem_cache_create(\"xfs_bui_item\",\n\t\t\txfs_bui_log_item_sizeof(XFS_BUI_MAX_FAST_EXTENTS),\n\t\t\t0, 0, NULL);\n\tif (!xfs_bui_cache)\n\t\tgoto out_destroy_bud_cache;\n\n\txfs_attrd_cache = kmem_cache_create(\"xfs_attrd_item\",\n\t\t\t\t\t    sizeof(struct xfs_attrd_log_item),\n\t\t\t\t\t    0, 0, NULL);\n\tif (!xfs_attrd_cache)\n\t\tgoto out_destroy_bui_cache;\n\n\txfs_attri_cache = kmem_cache_create(\"xfs_attri_item\",\n\t\t\t\t\t    sizeof(struct xfs_attri_log_item),\n\t\t\t\t\t    0, 0, NULL);\n\tif (!xfs_attri_cache)\n\t\tgoto out_destroy_attrd_cache;\n\n\txfs_iunlink_cache = kmem_cache_create(\"xfs_iul_item\",\n\t\t\t\t\t     sizeof(struct xfs_iunlink_item),\n\t\t\t\t\t     0, 0, NULL);\n\tif (!xfs_iunlink_cache)\n\t\tgoto out_destroy_attri_cache;\n\n\treturn 0;\n\n out_destroy_attri_cache:\n\tkmem_cache_destroy(xfs_attri_cache);\n out_destroy_attrd_cache:\n\tkmem_cache_destroy(xfs_attrd_cache);\n out_destroy_bui_cache:\n\tkmem_cache_destroy(xfs_bui_cache);\n out_destroy_bud_cache:\n\tkmem_cache_destroy(xfs_bud_cache);\n out_destroy_cui_cache:\n\tkmem_cache_destroy(xfs_cui_cache);\n out_destroy_cud_cache:\n\tkmem_cache_destroy(xfs_cud_cache);\n out_destroy_rui_cache:\n\tkmem_cache_destroy(xfs_rui_cache);\n out_destroy_rud_cache:\n\tkmem_cache_destroy(xfs_rud_cache);\n out_destroy_icreate_cache:\n\tkmem_cache_destroy(xfs_icreate_cache);\n out_destroy_ili_cache:\n\tkmem_cache_destroy(xfs_ili_cache);\n out_destroy_inode_cache:\n\tkmem_cache_destroy(xfs_inode_cache);\n out_destroy_efi_cache:\n\tkmem_cache_destroy(xfs_efi_cache);\n out_destroy_efd_cache:\n\tkmem_cache_destroy(xfs_efd_cache);\n out_destroy_buf_item_cache:\n\tkmem_cache_destroy(xfs_buf_item_cache);\n out_destroy_trans_cache:\n\tkmem_cache_destroy(xfs_trans_cache);\n out_destroy_ifork_cache:\n\tkmem_cache_destroy(xfs_ifork_cache);\n out_destroy_da_state_cache:\n\tkmem_cache_destroy(xfs_da_state_cache);\n out_destroy_defer_item_cache:\n\txfs_defer_destroy_item_caches();\n out_destroy_btree_cur_cache:\n\txfs_btree_destroy_cur_caches();\n out_destroy_log_ticket_cache:\n\tkmem_cache_destroy(xfs_log_ticket_cache);\n out_destroy_buf_cache:\n\tkmem_cache_destroy(xfs_buf_cache);\n out:\n\treturn -ENOMEM;\n}\n\nSTATIC void\nxfs_destroy_caches(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(xfs_iunlink_cache);\n\tkmem_cache_destroy(xfs_attri_cache);\n\tkmem_cache_destroy(xfs_attrd_cache);\n\tkmem_cache_destroy(xfs_bui_cache);\n\tkmem_cache_destroy(xfs_bud_cache);\n\tkmem_cache_destroy(xfs_cui_cache);\n\tkmem_cache_destroy(xfs_cud_cache);\n\tkmem_cache_destroy(xfs_rui_cache);\n\tkmem_cache_destroy(xfs_rud_cache);\n\tkmem_cache_destroy(xfs_icreate_cache);\n\tkmem_cache_destroy(xfs_ili_cache);\n\tkmem_cache_destroy(xfs_inode_cache);\n\tkmem_cache_destroy(xfs_efi_cache);\n\tkmem_cache_destroy(xfs_efd_cache);\n\tkmem_cache_destroy(xfs_buf_item_cache);\n\tkmem_cache_destroy(xfs_trans_cache);\n\tkmem_cache_destroy(xfs_ifork_cache);\n\tkmem_cache_destroy(xfs_da_state_cache);\n\txfs_defer_destroy_item_caches();\n\txfs_btree_destroy_cur_caches();\n\tkmem_cache_destroy(xfs_log_ticket_cache);\n\tkmem_cache_destroy(xfs_buf_cache);\n}\n\nSTATIC int __init\nxfs_init_workqueues(void)\n{\n\t \n\txfs_alloc_wq = alloc_workqueue(\"xfsalloc\",\n\t\t\tXFS_WQFLAGS(WQ_MEM_RECLAIM | WQ_FREEZABLE), 0);\n\tif (!xfs_alloc_wq)\n\t\treturn -ENOMEM;\n\n\txfs_discard_wq = alloc_workqueue(\"xfsdiscard\", XFS_WQFLAGS(WQ_UNBOUND),\n\t\t\t0);\n\tif (!xfs_discard_wq)\n\t\tgoto out_free_alloc_wq;\n\n\treturn 0;\nout_free_alloc_wq:\n\tdestroy_workqueue(xfs_alloc_wq);\n\treturn -ENOMEM;\n}\n\nSTATIC void\nxfs_destroy_workqueues(void)\n{\n\tdestroy_workqueue(xfs_discard_wq);\n\tdestroy_workqueue(xfs_alloc_wq);\n}\n\nSTATIC int __init\ninit_xfs_fs(void)\n{\n\tint\t\t\terror;\n\n\txfs_check_ondisk_structs();\n\n\terror = xfs_dahash_test();\n\tif (error)\n\t\treturn error;\n\n\tprintk(KERN_INFO XFS_VERSION_STRING \" with \"\n\t\t\t XFS_BUILD_OPTIONS \" enabled\\n\");\n\n\txfs_dir_startup();\n\n\terror = xfs_init_caches();\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_init_workqueues();\n\tif (error)\n\t\tgoto out_destroy_caches;\n\n\terror = xfs_mru_cache_init();\n\tif (error)\n\t\tgoto out_destroy_wq;\n\n\terror = xfs_init_procfs();\n\tif (error)\n\t\tgoto out_mru_cache_uninit;\n\n\terror = xfs_sysctl_register();\n\tif (error)\n\t\tgoto out_cleanup_procfs;\n\n\txfs_debugfs = xfs_debugfs_mkdir(\"xfs\", NULL);\n\n\txfs_kset = kset_create_and_add(\"xfs\", NULL, fs_kobj);\n\tif (!xfs_kset) {\n\t\terror = -ENOMEM;\n\t\tgoto out_debugfs_unregister;\n\t}\n\n\txfsstats.xs_kobj.kobject.kset = xfs_kset;\n\n\txfsstats.xs_stats = alloc_percpu(struct xfsstats);\n\tif (!xfsstats.xs_stats) {\n\t\terror = -ENOMEM;\n\t\tgoto out_kset_unregister;\n\t}\n\n\terror = xfs_sysfs_init(&xfsstats.xs_kobj, &xfs_stats_ktype, NULL,\n\t\t\t       \"stats\");\n\tif (error)\n\t\tgoto out_free_stats;\n\n\terror = xchk_global_stats_setup(xfs_debugfs);\n\tif (error)\n\t\tgoto out_remove_stats_kobj;\n\n#ifdef DEBUG\n\txfs_dbg_kobj.kobject.kset = xfs_kset;\n\terror = xfs_sysfs_init(&xfs_dbg_kobj, &xfs_dbg_ktype, NULL, \"debug\");\n\tif (error)\n\t\tgoto out_remove_scrub_stats;\n#endif\n\n\terror = xfs_qm_init();\n\tif (error)\n\t\tgoto out_remove_dbg_kobj;\n\n\terror = register_filesystem(&xfs_fs_type);\n\tif (error)\n\t\tgoto out_qm_exit;\n\treturn 0;\n\n out_qm_exit:\n\txfs_qm_exit();\n out_remove_dbg_kobj:\n#ifdef DEBUG\n\txfs_sysfs_del(&xfs_dbg_kobj);\n out_remove_scrub_stats:\n#endif\n\txchk_global_stats_teardown();\n out_remove_stats_kobj:\n\txfs_sysfs_del(&xfsstats.xs_kobj);\n out_free_stats:\n\tfree_percpu(xfsstats.xs_stats);\n out_kset_unregister:\n\tkset_unregister(xfs_kset);\n out_debugfs_unregister:\n\tdebugfs_remove(xfs_debugfs);\n\txfs_sysctl_unregister();\n out_cleanup_procfs:\n\txfs_cleanup_procfs();\n out_mru_cache_uninit:\n\txfs_mru_cache_uninit();\n out_destroy_wq:\n\txfs_destroy_workqueues();\n out_destroy_caches:\n\txfs_destroy_caches();\n out:\n\treturn error;\n}\n\nSTATIC void __exit\nexit_xfs_fs(void)\n{\n\txfs_qm_exit();\n\tunregister_filesystem(&xfs_fs_type);\n#ifdef DEBUG\n\txfs_sysfs_del(&xfs_dbg_kobj);\n#endif\n\txchk_global_stats_teardown();\n\txfs_sysfs_del(&xfsstats.xs_kobj);\n\tfree_percpu(xfsstats.xs_stats);\n\tkset_unregister(xfs_kset);\n\tdebugfs_remove(xfs_debugfs);\n\txfs_sysctl_unregister();\n\txfs_cleanup_procfs();\n\txfs_mru_cache_uninit();\n\txfs_destroy_workqueues();\n\txfs_destroy_caches();\n\txfs_uuid_table_free();\n}\n\nmodule_init(init_xfs_fs);\nmodule_exit(exit_xfs_fs);\n\nMODULE_AUTHOR(\"Silicon Graphics, Inc.\");\nMODULE_DESCRIPTION(XFS_VERSION_STRING \" with \" XFS_BUILD_OPTIONS \" enabled\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}