{
  "module_name": "xfs_ioctl.c",
  "hash_id": "8eec91c4b69e664db68c411172efa5b3baa489019b6e5e49979e2e03a001909b",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_ioctl.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_iwalk.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_error.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_export.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_btree.h\"\n#include <linux/fsmap.h>\n#include \"xfs_fsmap.h\"\n#include \"scrub/xfs_scrub.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_health.h\"\n#include \"xfs_reflink.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_xattr.h\"\n\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fileattr.h>\n\n \nint\nxfs_find_handle(\n\tunsigned int\t\tcmd,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tint\t\t\thsize;\n\txfs_handle_t\t\thandle;\n\tstruct inode\t\t*inode;\n\tstruct fd\t\tf = {NULL};\n\tstruct path\t\tpath;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*ip;\n\n\tif (cmd == XFS_IOC_FD_TO_HANDLE) {\n\t\tf = fdget(hreq->fd);\n\t\tif (!f.file)\n\t\t\treturn -EBADF;\n\t\tinode = file_inode(f.file);\n\t} else {\n\t\terror = user_path_at(AT_FDCWD, hreq->path, 0, &path);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinode = d_inode(path.dentry);\n\t}\n\tip = XFS_I(inode);\n\n\t \n\terror = -EINVAL;\n\tif (inode->i_sb->s_magic != XFS_SB_MAGIC)\n\t\tgoto out_put;\n\n\terror = -EBADF;\n\tif (!S_ISREG(inode->i_mode) &&\n\t    !S_ISDIR(inode->i_mode) &&\n\t    !S_ISLNK(inode->i_mode))\n\t\tgoto out_put;\n\n\n\tmemcpy(&handle.ha_fsid, ip->i_mount->m_fixedfsid, sizeof(xfs_fsid_t));\n\n\tif (cmd == XFS_IOC_PATH_TO_FSHANDLE) {\n\t\t \n\t\tmemset(&handle.ha_fid, 0, sizeof(handle.ha_fid));\n\t\thsize = sizeof(xfs_fsid_t);\n\t} else {\n\t\thandle.ha_fid.fid_len = sizeof(xfs_fid_t) -\n\t\t\t\t\tsizeof(handle.ha_fid.fid_len);\n\t\thandle.ha_fid.fid_pad = 0;\n\t\thandle.ha_fid.fid_gen = inode->i_generation;\n\t\thandle.ha_fid.fid_ino = ip->i_ino;\n\t\thsize = sizeof(xfs_handle_t);\n\t}\n\n\terror = -EFAULT;\n\tif (copy_to_user(hreq->ohandle, &handle, hsize) ||\n\t    copy_to_user(hreq->ohandlen, &hsize, sizeof(__s32)))\n\t\tgoto out_put;\n\n\terror = 0;\n\n out_put:\n\tif (cmd == XFS_IOC_FD_TO_HANDLE)\n\t\tfdput(f);\n\telse\n\t\tpath_put(&path);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_handle_acceptable(\n\tvoid\t\t\t*context,\n\tstruct dentry\t\t*dentry)\n{\n\treturn 1;\n}\n\n \nstruct dentry *\nxfs_handle_to_dentry(\n\tstruct file\t\t*parfilp,\n\tvoid __user\t\t*uhandle,\n\tu32\t\t\thlen)\n{\n\txfs_handle_t\t\thandle;\n\tstruct xfs_fid64\tfid;\n\n\t \n\tif (!S_ISDIR(file_inode(parfilp)->i_mode))\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (hlen != sizeof(xfs_handle_t))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (copy_from_user(&handle, uhandle, hlen))\n\t\treturn ERR_PTR(-EFAULT);\n\tif (handle.ha_fid.fid_len !=\n\t    sizeof(handle.ha_fid) - sizeof(handle.ha_fid.fid_len))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmemset(&fid, 0, sizeof(struct fid));\n\tfid.ino = handle.ha_fid.fid_ino;\n\tfid.gen = handle.ha_fid.fid_gen;\n\n\treturn exportfs_decode_fh(parfilp->f_path.mnt, (struct fid *)&fid, 3,\n\t\t\tFILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG,\n\t\t\txfs_handle_acceptable, NULL);\n}\n\nSTATIC struct dentry *\nxfs_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\n}\n\nint\nxfs_open_by_handle(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tconst struct cred\t*cred = current_cred();\n\tint\t\t\terror;\n\tint\t\t\tfd;\n\tint\t\t\tpermflag;\n\tstruct file\t\t*filp;\n\tstruct inode\t\t*inode;\n\tstruct dentry\t\t*dentry;\n\tfmode_t\t\t\tfmode;\n\tstruct path\t\tpath;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tinode = d_inode(dentry);\n\n\t \n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))) {\n\t\terror = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n#if BITS_PER_LONG != 32\n\threq->oflags |= O_LARGEFILE;\n#endif\n\n\tpermflag = hreq->oflags;\n\tfmode = OPEN_FMODE(permflag);\n\tif ((!(permflag & O_APPEND) || (permflag & O_TRUNC)) &&\n\t    (fmode & FMODE_WRITE) && IS_APPEND(inode)) {\n\t\terror = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n\tif ((fmode & FMODE_WRITE) && IS_IMMUTABLE(inode)) {\n\t\terror = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n\t \n\tif (S_ISDIR(inode->i_mode) && (fmode & FMODE_WRITE)) {\n\t\terror = -EISDIR;\n\t\tgoto out_dput;\n\t}\n\n\tfd = get_unused_fd_flags(0);\n\tif (fd < 0) {\n\t\terror = fd;\n\t\tgoto out_dput;\n\t}\n\n\tpath.mnt = parfilp->f_path.mnt;\n\tpath.dentry = dentry;\n\tfilp = dentry_open(&path, hreq->oflags, cred);\n\tdput(dentry);\n\tif (IS_ERR(filp)) {\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(filp);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tfilp->f_flags |= O_NOATIME;\n\t\tfilp->f_mode |= FMODE_NOCMTIME;\n\t}\n\n\tfd_install(fd, filp);\n\treturn fd;\n\n out_dput:\n\tdput(dentry);\n\treturn error;\n}\n\nint\nxfs_readlink_by_handle(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tstruct dentry\t\t*dentry;\n\t__u32\t\t\tolen;\n\tint\t\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\t \n\tif (!d_is_symlink(dentry)) {\n\t\terror = -EINVAL;\n\t\tgoto out_dput;\n\t}\n\n\tif (copy_from_user(&olen, hreq->ohandlen, sizeof(__u32))) {\n\t\terror = -EFAULT;\n\t\tgoto out_dput;\n\t}\n\n\terror = vfs_readlink(dentry, hreq->ohandle, olen);\n\n out_dput:\n\tdput(dentry);\n\treturn error;\n}\n\n \nstatic void\nxfs_ioc_attr_put_listent(\n\tstruct xfs_attr_list_context *context,\n\tint\t\t\tflags,\n\tunsigned char\t\t*name,\n\tint\t\t\tnamelen,\n\tint\t\t\tvaluelen)\n{\n\tstruct xfs_attrlist\t*alist = context->buffer;\n\tstruct xfs_attrlist_ent\t*aep;\n\tint\t\t\tarraytop;\n\n\tASSERT(!context->seen_enough);\n\tASSERT(context->count >= 0);\n\tASSERT(context->count < (ATTR_MAX_VALUELEN/8));\n\tASSERT(context->firstu >= sizeof(*alist));\n\tASSERT(context->firstu <= context->bufsize);\n\n\t \n\tif (context->attr_filter != (flags & XFS_ATTR_NSP_ONDISK_MASK))\n\t\treturn;\n\n\tarraytop = sizeof(*alist) +\n\t\t\tcontext->count * sizeof(alist->al_offset[0]);\n\n\t \n\tcontext->firstu -= round_up(offsetof(struct xfs_attrlist_ent, a_name) +\n\t\t\tnamelen + 1, sizeof(uint32_t));\n\tif (context->firstu < arraytop) {\n\t\ttrace_xfs_attr_list_full(context);\n\t\talist->al_more = 1;\n\t\tcontext->seen_enough = 1;\n\t\treturn;\n\t}\n\n\taep = context->buffer + context->firstu;\n\taep->a_valuelen = valuelen;\n\tmemcpy(aep->a_name, name, namelen);\n\taep->a_name[namelen] = 0;\n\talist->al_offset[context->count++] = context->firstu;\n\talist->al_count = context->count;\n\ttrace_xfs_attr_list_add(context);\n}\n\nstatic unsigned int\nxfs_attr_filter(\n\tu32\t\t\tioc_flags)\n{\n\tif (ioc_flags & XFS_IOC_ATTR_ROOT)\n\t\treturn XFS_ATTR_ROOT;\n\tif (ioc_flags & XFS_IOC_ATTR_SECURE)\n\t\treturn XFS_ATTR_SECURE;\n\treturn 0;\n}\n\nstatic unsigned int\nxfs_attr_flags(\n\tu32\t\t\tioc_flags)\n{\n\tif (ioc_flags & XFS_IOC_ATTR_CREATE)\n\t\treturn XATTR_CREATE;\n\tif (ioc_flags & XFS_IOC_ATTR_REPLACE)\n\t\treturn XATTR_REPLACE;\n\treturn 0;\n}\n\nint\nxfs_ioc_attr_list(\n\tstruct xfs_inode\t\t*dp,\n\tvoid __user\t\t\t*ubuf,\n\tsize_t\t\t\t\tbufsize,\n\tint\t\t\t\tflags,\n\tstruct xfs_attrlist_cursor __user *ucursor)\n{\n\tstruct xfs_attr_list_context\tcontext = { };\n\tstruct xfs_attrlist\t\t*alist;\n\tvoid\t\t\t\t*buffer;\n\tint\t\t\t\terror;\n\n\tif (bufsize < sizeof(struct xfs_attrlist) ||\n\t    bufsize > XFS_XATTR_LIST_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tif (flags & ~(XFS_IOC_ATTR_ROOT | XFS_IOC_ATTR_SECURE))\n\t\treturn -EINVAL;\n\tif (flags == (XFS_IOC_ATTR_ROOT | XFS_IOC_ATTR_SECURE))\n\t\treturn -EINVAL;\n\n\t \n\tif (copy_from_user(&context.cursor, ucursor, sizeof(context.cursor)))\n\t\treturn -EFAULT;\n\tif (context.cursor.pad1 || context.cursor.pad2)\n\t\treturn -EINVAL;\n\tif (!context.cursor.initted &&\n\t    (context.cursor.hashval || context.cursor.blkno ||\n\t     context.cursor.offset))\n\t\treturn -EINVAL;\n\n\tbuffer = kvzalloc(bufsize, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\t \n\tcontext.dp = dp;\n\tcontext.resynch = 1;\n\tcontext.attr_filter = xfs_attr_filter(flags);\n\tcontext.buffer = buffer;\n\tcontext.bufsize = round_down(bufsize, sizeof(uint32_t));\n\tcontext.firstu = context.bufsize;\n\tcontext.put_listent = xfs_ioc_attr_put_listent;\n\n\talist = context.buffer;\n\talist->al_count = 0;\n\talist->al_more = 0;\n\talist->al_offset[0] = context.bufsize;\n\n\terror = xfs_attr_list(&context);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (copy_to_user(ubuf, buffer, bufsize) ||\n\t    copy_to_user(ucursor, &context.cursor, sizeof(context.cursor)))\n\t\terror = -EFAULT;\nout_free:\n\tkmem_free(buffer);\n\treturn error;\n}\n\nSTATIC int\nxfs_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tstruct xfs_fsop_attrlist_handlereq __user *p)\n{\n\tstruct xfs_fsop_attrlist_handlereq al_hreq;\n\tstruct dentry\t\t*dentry;\n\tint\t\t\terror = -ENOMEM;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&al_hreq, p, sizeof(al_hreq)))\n\t\treturn -EFAULT;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = xfs_ioc_attr_list(XFS_I(d_inode(dentry)), al_hreq.buffer,\n\t\t\t\t  al_hreq.buflen, al_hreq.flags, &p->pos);\n\tdput(dentry);\n\treturn error;\n}\n\nstatic int\nxfs_attrmulti_attr_get(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tunsigned char\t\t__user *ubuf,\n\tuint32_t\t\t*len,\n\tuint32_t\t\tflags)\n{\n\tstruct xfs_da_args\targs = {\n\t\t.dp\t\t= XFS_I(inode),\n\t\t.attr_filter\t= xfs_attr_filter(flags),\n\t\t.attr_flags\t= xfs_attr_flags(flags),\n\t\t.name\t\t= name,\n\t\t.namelen\t= strlen(name),\n\t\t.valuelen\t= *len,\n\t};\n\tint\t\t\terror;\n\n\tif (*len > XFS_XATTR_SIZE_MAX)\n\t\treturn -EINVAL;\n\n\terror = xfs_attr_get(&args);\n\tif (error)\n\t\tgoto out_kfree;\n\n\t*len = args.valuelen;\n\tif (copy_to_user(ubuf, args.value, args.valuelen))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(args.value);\n\treturn error;\n}\n\nstatic int\nxfs_attrmulti_attr_set(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tconst unsigned char\t__user *ubuf,\n\tuint32_t\t\tlen,\n\tuint32_t\t\tflags)\n{\n\tstruct xfs_da_args\targs = {\n\t\t.dp\t\t= XFS_I(inode),\n\t\t.attr_filter\t= xfs_attr_filter(flags),\n\t\t.attr_flags\t= xfs_attr_flags(flags),\n\t\t.name\t\t= name,\n\t\t.namelen\t= strlen(name),\n\t};\n\tint\t\t\terror;\n\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\n\tif (ubuf) {\n\t\tif (len > XFS_XATTR_SIZE_MAX)\n\t\t\treturn -EINVAL;\n\t\targs.value = memdup_user(ubuf, len);\n\t\tif (IS_ERR(args.value))\n\t\t\treturn PTR_ERR(args.value);\n\t\targs.valuelen = len;\n\t}\n\n\terror = xfs_attr_change(&args);\n\tif (!error && (flags & XFS_IOC_ATTR_ROOT))\n\t\txfs_forget_acl(inode, name);\n\tkfree(args.value);\n\treturn error;\n}\n\nint\nxfs_ioc_attrmulti_one(\n\tstruct file\t\t*parfilp,\n\tstruct inode\t\t*inode,\n\tuint32_t\t\topcode,\n\tvoid __user\t\t*uname,\n\tvoid __user\t\t*value,\n\tuint32_t\t\t*len,\n\tuint32_t\t\tflags)\n{\n\tunsigned char\t\t*name;\n\tint\t\t\terror;\n\n\tif ((flags & XFS_IOC_ATTR_ROOT) && (flags & XFS_IOC_ATTR_SECURE))\n\t\treturn -EINVAL;\n\n\tname = strndup_user(uname, MAXNAMELEN);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\n\tswitch (opcode) {\n\tcase ATTR_OP_GET:\n\t\terror = xfs_attrmulti_attr_get(inode, name, value, len, flags);\n\t\tbreak;\n\tcase ATTR_OP_REMOVE:\n\t\tvalue = NULL;\n\t\t*len = 0;\n\t\tfallthrough;\n\tcase ATTR_OP_SET:\n\t\terror = mnt_want_write_file(parfilp);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = xfs_attrmulti_attr_set(inode, name, value, *len, flags);\n\t\tmnt_drop_write_file(parfilp);\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tbreak;\n\t}\n\n\tkfree(name);\n\treturn error;\n}\n\nSTATIC int\nxfs_attrmulti_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\txfs_attr_multiop_t\t*ops;\n\txfs_fsop_attrmulti_handlereq_t am_hreq;\n\tstruct dentry\t\t*dentry;\n\tunsigned int\t\ti, size;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&am_hreq, arg, sizeof(xfs_fsop_attrmulti_handlereq_t)))\n\t\treturn -EFAULT;\n\n\t \n\tif (am_hreq.opcount >= INT_MAX / sizeof(xfs_attr_multiop_t))\n\t\treturn -E2BIG;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &am_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = -E2BIG;\n\tsize = am_hreq.opcount * sizeof(xfs_attr_multiop_t);\n\tif (!size || size > 16 * PAGE_SIZE)\n\t\tgoto out_dput;\n\n\tops = memdup_user(am_hreq.ops, size);\n\tif (IS_ERR(ops)) {\n\t\terror = PTR_ERR(ops);\n\t\tgoto out_dput;\n\t}\n\n\terror = 0;\n\tfor (i = 0; i < am_hreq.opcount; i++) {\n\t\tops[i].am_error = xfs_ioc_attrmulti_one(parfilp,\n\t\t\t\td_inode(dentry), ops[i].am_opcode,\n\t\t\t\tops[i].am_attrname, ops[i].am_attrvalue,\n\t\t\t\t&ops[i].am_length, ops[i].am_flags);\n\t}\n\n\tif (copy_to_user(am_hreq.ops, ops, size))\n\t\terror = -EFAULT;\n\n\tkfree(ops);\n out_dput:\n\tdput(dentry);\n\treturn error;\n}\n\n \nint\nxfs_fsbulkstat_one_fmt(\n\tstruct xfs_ibulk\t\t*breq,\n\tconst struct xfs_bulkstat\t*bstat)\n{\n\tstruct xfs_bstat\t\tbs1;\n\n\txfs_bulkstat_to_bstat(breq->mp, &bs1, bstat);\n\tif (copy_to_user(breq->ubuffer, &bs1, sizeof(bs1)))\n\t\treturn -EFAULT;\n\treturn xfs_ibulk_advance(breq, sizeof(struct xfs_bstat));\n}\n\nint\nxfs_fsinumbers_fmt(\n\tstruct xfs_ibulk\t\t*breq,\n\tconst struct xfs_inumbers\t*igrp)\n{\n\tstruct xfs_inogrp\t\tig1;\n\n\txfs_inumbers_to_inogrp(&ig1, igrp);\n\tif (copy_to_user(breq->ubuffer, &ig1, sizeof(struct xfs_inogrp)))\n\t\treturn -EFAULT;\n\treturn xfs_ibulk_advance(breq, sizeof(struct xfs_inogrp));\n}\n\nSTATIC int\nxfs_ioc_fsbulkstat(\n\tstruct file\t\t*file,\n\tunsigned int\t\tcmd,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct xfs_mount\t*mp = XFS_I(file_inode(file))->i_mount;\n\tstruct xfs_fsop_bulkreq\tbulkreq;\n\tstruct xfs_ibulk\tbreq = {\n\t\t.mp\t\t= mp,\n\t\t.idmap\t\t= file_mnt_idmap(file),\n\t\t.ocount\t\t= 0,\n\t};\n\txfs_ino_t\t\tlastino;\n\tint\t\t\terror;\n\n\t \n\t \n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\tif (copy_from_user(&bulkreq, arg, sizeof(struct xfs_fsop_bulkreq)))\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&lastino, bulkreq.lastip, sizeof(__s64)))\n\t\treturn -EFAULT;\n\n\tif (bulkreq.icount <= 0)\n\t\treturn -EINVAL;\n\n\tif (bulkreq.ubuffer == NULL)\n\t\treturn -EINVAL;\n\n\tbreq.ubuffer = bulkreq.ubuffer;\n\tbreq.icount = bulkreq.icount;\n\n\t \n\tif (cmd == XFS_IOC_FSINUMBERS) {\n\t\tbreq.startino = lastino ? lastino + 1 : 0;\n\t\terror = xfs_inumbers(&breq, xfs_fsinumbers_fmt);\n\t\tlastino = breq.startino - 1;\n\t} else if (cmd == XFS_IOC_FSBULKSTAT_SINGLE) {\n\t\tbreq.startino = lastino;\n\t\tbreq.icount = 1;\n\t\terror = xfs_bulkstat_one(&breq, xfs_fsbulkstat_one_fmt);\n\t} else {\t \n\t\tbreq.startino = lastino ? lastino + 1 : 0;\n\t\terror = xfs_bulkstat(&breq, xfs_fsbulkstat_one_fmt);\n\t\tlastino = breq.startino - 1;\n\t}\n\n\tif (error)\n\t\treturn error;\n\n\tif (bulkreq.lastip != NULL &&\n\t    copy_to_user(bulkreq.lastip, &lastino, sizeof(xfs_ino_t)))\n\t\treturn -EFAULT;\n\n\tif (bulkreq.ocount != NULL &&\n\t    copy_to_user(bulkreq.ocount, &breq.ocount, sizeof(__s32)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int\nxfs_bulkstat_fmt(\n\tstruct xfs_ibulk\t\t*breq,\n\tconst struct xfs_bulkstat\t*bstat)\n{\n\tif (copy_to_user(breq->ubuffer, bstat, sizeof(struct xfs_bulkstat)))\n\t\treturn -EFAULT;\n\treturn xfs_ibulk_advance(breq, sizeof(struct xfs_bulkstat));\n}\n\n \nstatic int\nxfs_bulk_ireq_setup(\n\tstruct xfs_mount\t*mp,\n\tconst struct xfs_bulk_ireq *hdr,\n\tstruct xfs_ibulk\t*breq,\n\tvoid __user\t\t*ubuffer)\n{\n\tif (hdr->icount == 0 ||\n\t    (hdr->flags & ~XFS_BULK_IREQ_FLAGS_ALL) ||\n\t    memchr_inv(hdr->reserved, 0, sizeof(hdr->reserved)))\n\t\treturn -EINVAL;\n\n\tbreq->startino = hdr->ino;\n\tbreq->ubuffer = ubuffer;\n\tbreq->icount = hdr->icount;\n\tbreq->ocount = 0;\n\tbreq->flags = 0;\n\n\t \n\tif (hdr->flags & XFS_BULK_IREQ_SPECIAL) {\n\t\tif (hdr->flags & XFS_BULK_IREQ_AGNO)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (hdr->ino) {\n\t\tcase XFS_BULK_IREQ_SPECIAL_ROOT:\n\t\t\tbreq->startino = mp->m_sb.sb_rootino;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreq->icount = 1;\n\t}\n\n\t \n\tif (hdr->flags & XFS_BULK_IREQ_AGNO) {\n\t\tif (hdr->agno >= mp->m_sb.sb_agcount)\n\t\t\treturn -EINVAL;\n\n\t\tif (breq->startino == 0)\n\t\t\tbreq->startino = XFS_AGINO_TO_INO(mp, hdr->agno, 0);\n\t\telse if (XFS_INO_TO_AGNO(mp, breq->startino) < hdr->agno)\n\t\t\treturn -EINVAL;\n\n\t\tbreq->flags |= XFS_IBULK_SAME_AG;\n\n\t\t \n\t\tif (XFS_INO_TO_AGNO(mp, breq->startino) > hdr->agno)\n\t\t\treturn -ECANCELED;\n\t} else if (hdr->agno)\n\t\treturn -EINVAL;\n\n\t \n\tif (XFS_INO_TO_AGNO(mp, breq->startino) >= mp->m_sb.sb_agcount)\n\t\treturn -ECANCELED;\n\n\tif (hdr->flags & XFS_BULK_IREQ_NREXT64)\n\t\tbreq->flags |= XFS_IBULK_NREXT64;\n\n\treturn 0;\n}\n\n \nstatic void\nxfs_bulk_ireq_teardown(\n\tstruct xfs_bulk_ireq\t*hdr,\n\tstruct xfs_ibulk\t*breq)\n{\n\thdr->ino = breq->startino;\n\thdr->ocount = breq->ocount;\n}\n\n \nSTATIC int\nxfs_ioc_bulkstat(\n\tstruct file\t\t\t*file,\n\tunsigned int\t\t\tcmd,\n\tstruct xfs_bulkstat_req __user\t*arg)\n{\n\tstruct xfs_mount\t\t*mp = XFS_I(file_inode(file))->i_mount;\n\tstruct xfs_bulk_ireq\t\thdr;\n\tstruct xfs_ibulk\t\tbreq = {\n\t\t.mp\t\t\t= mp,\n\t\t.idmap\t\t\t= file_mnt_idmap(file),\n\t};\n\tint\t\t\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\tif (copy_from_user(&hdr, &arg->hdr, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\terror = xfs_bulk_ireq_setup(mp, &hdr, &breq, arg->bulkstat);\n\tif (error == -ECANCELED)\n\t\tgoto out_teardown;\n\tif (error < 0)\n\t\treturn error;\n\n\terror = xfs_bulkstat(&breq, xfs_bulkstat_fmt);\n\tif (error)\n\t\treturn error;\n\nout_teardown:\n\txfs_bulk_ireq_teardown(&hdr, &breq);\n\tif (copy_to_user(&arg->hdr, &hdr, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nSTATIC int\nxfs_inumbers_fmt(\n\tstruct xfs_ibulk\t\t*breq,\n\tconst struct xfs_inumbers\t*igrp)\n{\n\tif (copy_to_user(breq->ubuffer, igrp, sizeof(struct xfs_inumbers)))\n\t\treturn -EFAULT;\n\treturn xfs_ibulk_advance(breq, sizeof(struct xfs_inumbers));\n}\n\n \nSTATIC int\nxfs_ioc_inumbers(\n\tstruct xfs_mount\t\t*mp,\n\tunsigned int\t\t\tcmd,\n\tstruct xfs_inumbers_req __user\t*arg)\n{\n\tstruct xfs_bulk_ireq\t\thdr;\n\tstruct xfs_ibulk\t\tbreq = {\n\t\t.mp\t\t\t= mp,\n\t};\n\tint\t\t\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\tif (copy_from_user(&hdr, &arg->hdr, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\terror = xfs_bulk_ireq_setup(mp, &hdr, &breq, arg->inumbers);\n\tif (error == -ECANCELED)\n\t\tgoto out_teardown;\n\tif (error < 0)\n\t\treturn error;\n\n\terror = xfs_inumbers(&breq, xfs_inumbers_fmt);\n\tif (error)\n\t\treturn error;\n\nout_teardown:\n\txfs_bulk_ireq_teardown(&hdr, &breq);\n\tif (copy_to_user(&arg->hdr, &hdr, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nSTATIC int\nxfs_ioc_fsgeometry(\n\tstruct xfs_mount\t*mp,\n\tvoid\t\t\t__user *arg,\n\tint\t\t\tstruct_version)\n{\n\tstruct xfs_fsop_geom\tfsgeo;\n\tsize_t\t\t\tlen;\n\n\txfs_fs_geometry(mp, &fsgeo, struct_version);\n\n\tif (struct_version <= 3)\n\t\tlen = sizeof(struct xfs_fsop_geom_v1);\n\telse if (struct_version == 4)\n\t\tlen = sizeof(struct xfs_fsop_geom_v4);\n\telse {\n\t\txfs_fsop_geom_health(mp, &fsgeo);\n\t\tlen = sizeof(fsgeo);\n\t}\n\n\tif (copy_to_user(arg, &fsgeo, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nSTATIC int\nxfs_ioc_ag_geometry(\n\tstruct xfs_mount\t*mp,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct xfs_perag\t*pag;\n\tstruct xfs_ag_geometry\tageo;\n\tint\t\t\terror;\n\n\tif (copy_from_user(&ageo, arg, sizeof(ageo)))\n\t\treturn -EFAULT;\n\tif (ageo.ag_flags)\n\t\treturn -EINVAL;\n\tif (memchr_inv(&ageo.ag_reserved, 0, sizeof(ageo.ag_reserved)))\n\t\treturn -EINVAL;\n\n\tpag = xfs_perag_get(mp, ageo.ag_number);\n\tif (!pag)\n\t\treturn -EINVAL;\n\n\terror = xfs_ag_get_geometry(pag, &ageo);\n\txfs_perag_put(pag);\n\tif (error)\n\t\treturn error;\n\n\tif (copy_to_user(arg, &ageo, sizeof(ageo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \n\nstatic void\nxfs_fill_fsxattr(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tstruct fileattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\n\tfileattr_fill_xflags(fa, xfs_ip2xflags(ip));\n\n\tif (ip->i_diflags & XFS_DIFLAG_EXTSIZE) {\n\t\tfa->fsx_extsize = XFS_FSB_TO_B(mp, ip->i_extsize);\n\t} else if (ip->i_diflags & XFS_DIFLAG_EXTSZINHERIT) {\n\t\t \n\t\tif ((ip->i_diflags & XFS_DIFLAG_RTINHERIT) &&\n\t\t    ip->i_extsize % mp->m_sb.sb_rextsize > 0) {\n\t\t\tfa->fsx_xflags &= ~(FS_XFLAG_EXTSIZE |\n\t\t\t\t\t    FS_XFLAG_EXTSZINHERIT);\n\t\t\tfa->fsx_extsize = 0;\n\t\t} else {\n\t\t\tfa->fsx_extsize = XFS_FSB_TO_B(mp, ip->i_extsize);\n\t\t}\n\t}\n\n\tif (ip->i_diflags2 & XFS_DIFLAG2_COWEXTSIZE)\n\t\tfa->fsx_cowextsize = XFS_FSB_TO_B(mp, ip->i_cowextsize);\n\tfa->fsx_projid = ip->i_projid;\n\tif (ifp && !xfs_need_iread_extents(ifp))\n\t\tfa->fsx_nextents = xfs_iext_count(ifp);\n\telse\n\t\tfa->fsx_nextents = xfs_ifork_nextents(ifp);\n}\n\nSTATIC int\nxfs_ioc_fsgetxattra(\n\txfs_inode_t\t\t*ip,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct fileattr\t\tfa;\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\txfs_fill_fsxattr(ip, XFS_ATTR_FORK, &fa);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\treturn copy_fsxattr_to_user(&fa, arg);\n}\n\nint\nxfs_fileattr_get(\n\tstruct dentry\t\t*dentry,\n\tstruct fileattr\t\t*fa)\n{\n\tstruct xfs_inode\t*ip = XFS_I(d_inode(dentry));\n\n\tif (d_is_special(dentry))\n\t\treturn -ENOTTY;\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\txfs_fill_fsxattr(ip, XFS_DATA_FORK, fa);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\treturn 0;\n}\n\nSTATIC uint16_t\nxfs_flags2diflags(\n\tstruct xfs_inode\t*ip,\n\tunsigned int\t\txflags)\n{\n\t \n\tuint16_t\t\tdi_flags =\n\t\t(ip->i_diflags & XFS_DIFLAG_PREALLOC);\n\n\tif (xflags & FS_XFLAG_IMMUTABLE)\n\t\tdi_flags |= XFS_DIFLAG_IMMUTABLE;\n\tif (xflags & FS_XFLAG_APPEND)\n\t\tdi_flags |= XFS_DIFLAG_APPEND;\n\tif (xflags & FS_XFLAG_SYNC)\n\t\tdi_flags |= XFS_DIFLAG_SYNC;\n\tif (xflags & FS_XFLAG_NOATIME)\n\t\tdi_flags |= XFS_DIFLAG_NOATIME;\n\tif (xflags & FS_XFLAG_NODUMP)\n\t\tdi_flags |= XFS_DIFLAG_NODUMP;\n\tif (xflags & FS_XFLAG_NODEFRAG)\n\t\tdi_flags |= XFS_DIFLAG_NODEFRAG;\n\tif (xflags & FS_XFLAG_FILESTREAM)\n\t\tdi_flags |= XFS_DIFLAG_FILESTREAM;\n\tif (S_ISDIR(VFS_I(ip)->i_mode)) {\n\t\tif (xflags & FS_XFLAG_RTINHERIT)\n\t\t\tdi_flags |= XFS_DIFLAG_RTINHERIT;\n\t\tif (xflags & FS_XFLAG_NOSYMLINKS)\n\t\t\tdi_flags |= XFS_DIFLAG_NOSYMLINKS;\n\t\tif (xflags & FS_XFLAG_EXTSZINHERIT)\n\t\t\tdi_flags |= XFS_DIFLAG_EXTSZINHERIT;\n\t\tif (xflags & FS_XFLAG_PROJINHERIT)\n\t\t\tdi_flags |= XFS_DIFLAG_PROJINHERIT;\n\t} else if (S_ISREG(VFS_I(ip)->i_mode)) {\n\t\tif (xflags & FS_XFLAG_REALTIME)\n\t\t\tdi_flags |= XFS_DIFLAG_REALTIME;\n\t\tif (xflags & FS_XFLAG_EXTSIZE)\n\t\t\tdi_flags |= XFS_DIFLAG_EXTSIZE;\n\t}\n\n\treturn di_flags;\n}\n\nSTATIC uint64_t\nxfs_flags2diflags2(\n\tstruct xfs_inode\t*ip,\n\tunsigned int\t\txflags)\n{\n\tuint64_t\t\tdi_flags2 =\n\t\t(ip->i_diflags2 & (XFS_DIFLAG2_REFLINK |\n\t\t\t\t   XFS_DIFLAG2_BIGTIME |\n\t\t\t\t   XFS_DIFLAG2_NREXT64));\n\n\tif (xflags & FS_XFLAG_DAX)\n\t\tdi_flags2 |= XFS_DIFLAG2_DAX;\n\tif (xflags & FS_XFLAG_COWEXTSIZE)\n\t\tdi_flags2 |= XFS_DIFLAG2_COWEXTSIZE;\n\n\treturn di_flags2;\n}\n\nstatic int\nxfs_ioctl_setattr_xflags(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct fileattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint64_t\t\ti_flags2;\n\n\t \n\tif ((ip->i_df.if_nextents || ip->i_delayed_blks) &&\n\t    XFS_IS_REALTIME_INODE(ip) != (fa->fsx_xflags & FS_XFLAG_REALTIME))\n\t\treturn -EINVAL;\n\n\t \n\tif (fa->fsx_xflags & FS_XFLAG_REALTIME) {\n\t\tif (mp->m_sb.sb_rblocks == 0 || mp->m_sb.sb_rextsize == 0 ||\n\t\t    (ip->i_extsize % mp->m_sb.sb_rextsize))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((fa->fsx_xflags & FS_XFLAG_REALTIME) && xfs_is_reflink_inode(ip))\n\t\tip->i_diflags2 &= ~XFS_DIFLAG2_REFLINK;\n\n\t \n\ti_flags2 = xfs_flags2diflags2(ip, fa->fsx_xflags);\n\tif (i_flags2 && !xfs_has_v3inodes(mp))\n\t\treturn -EINVAL;\n\n\tip->i_diflags = xfs_flags2diflags(ip, fa->fsx_xflags);\n\tip->i_diflags2 = i_flags2;\n\n\txfs_diflags_to_iflags(ip, false);\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\tXFS_STATS_INC(mp, xs_ig_attrchg);\n\treturn 0;\n}\n\nstatic void\nxfs_ioctl_setattr_prepare_dax(\n\tstruct xfs_inode\t*ip,\n\tstruct fileattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode            *inode = VFS_I(ip);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tif (xfs_has_dax_always(mp) || xfs_has_dax_never(mp))\n\t\treturn;\n\n\tif (((fa->fsx_xflags & FS_XFLAG_DAX) &&\n\t    !(ip->i_diflags2 & XFS_DIFLAG2_DAX)) ||\n\t    (!(fa->fsx_xflags & FS_XFLAG_DAX) &&\n\t     (ip->i_diflags2 & XFS_DIFLAG2_DAX)))\n\t\td_mark_dontcache(inode);\n}\n\n \nstatic struct xfs_trans *\nxfs_ioctl_setattr_get_trans(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dquot\t*pdqp)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror = -EROFS;\n\n\tif (xfs_is_readonly(mp))\n\t\tgoto out_error;\n\terror = -EIO;\n\tif (xfs_is_shutdown(mp))\n\t\tgoto out_error;\n\n\terror = xfs_trans_alloc_ichange(ip, NULL, NULL, pdqp,\n\t\t\thas_capability_noaudit(current, CAP_FOWNER), &tp);\n\tif (error)\n\t\tgoto out_error;\n\n\tif (xfs_has_wsync(mp))\n\t\txfs_trans_set_sync(tp);\n\n\treturn tp;\n\nout_error:\n\treturn ERR_PTR(error);\n}\n\n \nstatic int\nxfs_ioctl_setattr_check_extsize(\n\tstruct xfs_inode\t*ip,\n\tstruct fileattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_failaddr_t\t\tfailaddr;\n\tuint16_t\t\tnew_diflags;\n\n\tif (!fa->fsx_valid)\n\t\treturn 0;\n\n\tif (S_ISREG(VFS_I(ip)->i_mode) && ip->i_df.if_nextents &&\n\t    XFS_FSB_TO_B(mp, ip->i_extsize) != fa->fsx_extsize)\n\t\treturn -EINVAL;\n\n\tif (fa->fsx_extsize & mp->m_blockmask)\n\t\treturn -EINVAL;\n\n\tnew_diflags = xfs_flags2diflags(ip, fa->fsx_xflags);\n\n\t \n\tif ((new_diflags & XFS_DIFLAG_RTINHERIT) &&\n\t    (new_diflags & XFS_DIFLAG_EXTSZINHERIT)) {\n\t\tunsigned int\trtextsize_bytes;\n\n\t\trtextsize_bytes = XFS_FSB_TO_B(mp, mp->m_sb.sb_rextsize);\n\t\tif (fa->fsx_extsize % rtextsize_bytes)\n\t\t\treturn -EINVAL;\n\t}\n\n\tfailaddr = xfs_inode_validate_extsize(ip->i_mount,\n\t\t\tXFS_B_TO_FSB(mp, fa->fsx_extsize),\n\t\t\tVFS_I(ip)->i_mode, new_diflags);\n\treturn failaddr != NULL ? -EINVAL : 0;\n}\n\nstatic int\nxfs_ioctl_setattr_check_cowextsize(\n\tstruct xfs_inode\t*ip,\n\tstruct fileattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_failaddr_t\t\tfailaddr;\n\tuint64_t\t\tnew_diflags2;\n\tuint16_t\t\tnew_diflags;\n\n\tif (!fa->fsx_valid)\n\t\treturn 0;\n\n\tif (fa->fsx_cowextsize & mp->m_blockmask)\n\t\treturn -EINVAL;\n\n\tnew_diflags = xfs_flags2diflags(ip, fa->fsx_xflags);\n\tnew_diflags2 = xfs_flags2diflags2(ip, fa->fsx_xflags);\n\n\tfailaddr = xfs_inode_validate_cowextsize(ip->i_mount,\n\t\t\tXFS_B_TO_FSB(mp, fa->fsx_cowextsize),\n\t\t\tVFS_I(ip)->i_mode, new_diflags, new_diflags2);\n\treturn failaddr != NULL ? -EINVAL : 0;\n}\n\nstatic int\nxfs_ioctl_setattr_check_projid(\n\tstruct xfs_inode\t*ip,\n\tstruct fileattr\t\t*fa)\n{\n\tif (!fa->fsx_valid)\n\t\treturn 0;\n\n\t \n\tif (fa->fsx_projid > (uint16_t)-1 &&\n\t    !xfs_has_projid32(ip->i_mount))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nint\nxfs_fileattr_set(\n\tstruct mnt_idmap\t*idmap,\n\tstruct dentry\t\t*dentry,\n\tstruct fileattr\t\t*fa)\n{\n\tstruct xfs_inode\t*ip = XFS_I(d_inode(dentry));\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tstruct xfs_dquot\t*olddquot = NULL;\n\tint\t\t\terror;\n\n\ttrace_xfs_ioctl_setattr(ip);\n\n\tif (d_is_special(dentry))\n\t\treturn -ENOTTY;\n\n\tif (!fa->fsx_valid) {\n\t\tif (fa->flags & ~(FS_IMMUTABLE_FL | FS_APPEND_FL |\n\t\t\t\t  FS_NOATIME_FL | FS_NODUMP_FL |\n\t\t\t\t  FS_SYNC_FL | FS_DAX_FL | FS_PROJINHERIT_FL))\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\terror = xfs_ioctl_setattr_check_projid(ip, fa);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (fa->fsx_valid && XFS_IS_QUOTA_ON(mp)) {\n\t\terror = xfs_qm_vop_dqalloc(ip, VFS_I(ip)->i_uid,\n\t\t\t\tVFS_I(ip)->i_gid, fa->fsx_projid,\n\t\t\t\tXFS_QMOPT_PQUOTA, NULL, NULL, &pdqp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_ioctl_setattr_prepare_dax(ip, fa);\n\n\ttp = xfs_ioctl_setattr_get_trans(ip, pdqp);\n\tif (IS_ERR(tp)) {\n\t\terror = PTR_ERR(tp);\n\t\tgoto error_free_dquots;\n\t}\n\n\terror = xfs_ioctl_setattr_check_extsize(ip, fa);\n\tif (error)\n\t\tgoto error_trans_cancel;\n\n\terror = xfs_ioctl_setattr_check_cowextsize(ip, fa);\n\tif (error)\n\t\tgoto error_trans_cancel;\n\n\terror = xfs_ioctl_setattr_xflags(tp, ip, fa);\n\tif (error)\n\t\tgoto error_trans_cancel;\n\n\tif (!fa->fsx_valid)\n\t\tgoto skip_xattr;\n\t \n\n\tif ((VFS_I(ip)->i_mode & (S_ISUID|S_ISGID)) &&\n\t    !capable_wrt_inode_uidgid(idmap, VFS_I(ip), CAP_FSETID))\n\t\tVFS_I(ip)->i_mode &= ~(S_ISUID|S_ISGID);\n\n\t \n\tif (ip->i_projid != fa->fsx_projid) {\n\t\tif (XFS_IS_PQUOTA_ON(mp)) {\n\t\t\tolddquot = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t&ip->i_pdquot, pdqp);\n\t\t}\n\t\tip->i_projid = fa->fsx_projid;\n\t}\n\n\t \n\tif (ip->i_diflags & (XFS_DIFLAG_EXTSIZE | XFS_DIFLAG_EXTSZINHERIT))\n\t\tip->i_extsize = XFS_B_TO_FSB(mp, fa->fsx_extsize);\n\telse\n\t\tip->i_extsize = 0;\n\n\tif (xfs_has_v3inodes(mp)) {\n\t\tif (ip->i_diflags2 & XFS_DIFLAG2_COWEXTSIZE)\n\t\t\tip->i_cowextsize = XFS_B_TO_FSB(mp, fa->fsx_cowextsize);\n\t\telse\n\t\t\tip->i_cowextsize = 0;\n\t}\n\nskip_xattr:\n\terror = xfs_trans_commit(tp);\n\n\t \n\txfs_qm_dqrele(olddquot);\n\txfs_qm_dqrele(pdqp);\n\n\treturn error;\n\nerror_trans_cancel:\n\txfs_trans_cancel(tp);\nerror_free_dquots:\n\txfs_qm_dqrele(pdqp);\n\treturn error;\n}\n\nstatic bool\nxfs_getbmap_format(\n\tstruct kgetbmap\t\t*p,\n\tstruct getbmapx __user\t*u,\n\tsize_t\t\t\trecsize)\n{\n\tif (put_user(p->bmv_offset, &u->bmv_offset) ||\n\t    put_user(p->bmv_block, &u->bmv_block) ||\n\t    put_user(p->bmv_length, &u->bmv_length) ||\n\t    put_user(0, &u->bmv_count) ||\n\t    put_user(0, &u->bmv_entries))\n\t\treturn false;\n\tif (recsize < sizeof(struct getbmapx))\n\t\treturn true;\n\tif (put_user(0, &u->bmv_iflags) ||\n\t    put_user(p->bmv_oflags, &u->bmv_oflags) ||\n\t    put_user(0, &u->bmv_unused1) ||\n\t    put_user(0, &u->bmv_unused2))\n\t\treturn false;\n\treturn true;\n}\n\nSTATIC int\nxfs_ioc_getbmap(\n\tstruct file\t\t*file,\n\tunsigned int\t\tcmd,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct getbmapx\t\tbmx = { 0 };\n\tstruct kgetbmap\t\t*buf;\n\tsize_t\t\t\trecsize;\n\tint\t\t\terror, i;\n\n\tswitch (cmd) {\n\tcase XFS_IOC_GETBMAPA:\n\t\tbmx.bmv_iflags = BMV_IF_ATTRFORK;\n\t\tfallthrough;\n\tcase XFS_IOC_GETBMAP:\n\t\t \n\t\trecsize = sizeof(struct getbmap);\n\t\tbreak;\n\tcase XFS_IOC_GETBMAPX:\n\t\trecsize = sizeof(struct getbmapx);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&bmx, arg, recsize))\n\t\treturn -EFAULT;\n\n\tif (bmx.bmv_count < 2)\n\t\treturn -EINVAL;\n\tif (bmx.bmv_count >= INT_MAX / recsize)\n\t\treturn -ENOMEM;\n\n\tbuf = kvcalloc(bmx.bmv_count, sizeof(*buf), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\terror = xfs_getbmap(XFS_I(file_inode(file)), &bmx, buf);\n\tif (error)\n\t\tgoto out_free_buf;\n\n\terror = -EFAULT;\n\tif (copy_to_user(arg, &bmx, recsize))\n\t\tgoto out_free_buf;\n\targ += recsize;\n\n\tfor (i = 0; i < bmx.bmv_entries; i++) {\n\t\tif (!xfs_getbmap_format(buf + i, arg, recsize))\n\t\t\tgoto out_free_buf;\n\t\targ += recsize;\n\t}\n\n\terror = 0;\nout_free_buf:\n\tkmem_free(buf);\n\treturn error;\n}\n\nSTATIC int\nxfs_ioc_getfsmap(\n\tstruct xfs_inode\t*ip,\n\tstruct fsmap_head\t__user *arg)\n{\n\tstruct xfs_fsmap_head\txhead = {0};\n\tstruct fsmap_head\thead;\n\tstruct fsmap\t\t*recs;\n\tunsigned int\t\tcount;\n\t__u32\t\t\tlast_flags = 0;\n\tbool\t\t\tdone = false;\n\tint\t\t\terror;\n\n\tif (copy_from_user(&head, arg, sizeof(struct fsmap_head)))\n\t\treturn -EFAULT;\n\tif (memchr_inv(head.fmh_reserved, 0, sizeof(head.fmh_reserved)) ||\n\t    memchr_inv(head.fmh_keys[0].fmr_reserved, 0,\n\t\t       sizeof(head.fmh_keys[0].fmr_reserved)) ||\n\t    memchr_inv(head.fmh_keys[1].fmr_reserved, 0,\n\t\t       sizeof(head.fmh_keys[1].fmr_reserved)))\n\t\treturn -EINVAL;\n\n\t \n\tcount = min_t(unsigned int, head.fmh_count,\n\t\t\t131072 / sizeof(struct fsmap));\n\trecs = kvcalloc(count, sizeof(struct fsmap), GFP_KERNEL);\n\tif (!recs) {\n\t\tcount = min_t(unsigned int, head.fmh_count,\n\t\t\t\tPAGE_SIZE / sizeof(struct fsmap));\n\t\trecs = kvcalloc(count, sizeof(struct fsmap), GFP_KERNEL);\n\t\tif (!recs)\n\t\t\treturn -ENOMEM;\n\t}\n\n\txhead.fmh_iflags = head.fmh_iflags;\n\txfs_fsmap_to_internal(&xhead.fmh_keys[0], &head.fmh_keys[0]);\n\txfs_fsmap_to_internal(&xhead.fmh_keys[1], &head.fmh_keys[1]);\n\n\ttrace_xfs_getfsmap_low_key(ip->i_mount, &xhead.fmh_keys[0]);\n\ttrace_xfs_getfsmap_high_key(ip->i_mount, &xhead.fmh_keys[1]);\n\n\thead.fmh_entries = 0;\n\tdo {\n\t\tstruct fsmap __user\t*user_recs;\n\t\tstruct fsmap\t\t*last_rec;\n\n\t\tuser_recs = &arg->fmh_recs[head.fmh_entries];\n\t\txhead.fmh_entries = 0;\n\t\txhead.fmh_count = min_t(unsigned int, count,\n\t\t\t\t\thead.fmh_count - head.fmh_entries);\n\n\t\t \n\t\terror = xfs_getfsmap(ip->i_mount, &xhead, recs);\n\t\tswitch (error) {\n\t\tcase 0:\n\t\t\t \n\t\t\tdone = true;\n\t\t\tbreak;\n\t\tcase -ECANCELED:\n\t\t\t \n\t\t\terror = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_free;\n\t\t}\n\t\thead.fmh_entries += xhead.fmh_entries;\n\t\thead.fmh_oflags = xhead.fmh_oflags;\n\n\t\t \n\t\tif (head.fmh_count == 0 || xhead.fmh_entries == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (copy_to_user(user_recs, recs,\n\t\t\t\t xhead.fmh_entries * sizeof(struct fsmap))) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t \n\t\tlast_rec = &recs[xhead.fmh_entries - 1];\n\t\tlast_flags = last_rec->fmr_flags;\n\n\t\t \n\t\txfs_fsmap_to_internal(&xhead.fmh_keys[0], last_rec);\n\t\ttrace_xfs_getfsmap_low_key(ip->i_mount, &xhead.fmh_keys[0]);\n\t} while (!done && head.fmh_entries < head.fmh_count);\n\n\t \n\tif (done && head.fmh_count > 0 && head.fmh_entries > 0) {\n\t\tstruct fsmap __user\t*user_rec;\n\n\t\tlast_flags |= FMR_OF_LAST;\n\t\tuser_rec = &arg->fmh_recs[head.fmh_entries - 1];\n\n\t\tif (copy_to_user(&user_rec->fmr_flags, &last_flags,\n\t\t\t\t\tsizeof(last_flags))) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t \n\tif (copy_to_user(arg, &head, sizeof(struct fsmap_head))) {\n\t\terror = -EFAULT;\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tkmem_free(recs);\n\treturn error;\n}\n\nSTATIC int\nxfs_ioc_scrub_metadata(\n\tstruct file\t\t\t*file,\n\tvoid\t\t\t\t__user *arg)\n{\n\tstruct xfs_scrub_metadata\tscrub;\n\tint\t\t\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(&scrub, arg, sizeof(scrub)))\n\t\treturn -EFAULT;\n\n\terror = xfs_scrub_metadata(file, &scrub);\n\tif (error)\n\t\treturn error;\n\n\tif (copy_to_user(arg, &scrub, sizeof(scrub)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nint\nxfs_ioc_swapext(\n\txfs_swapext_t\t*sxp)\n{\n\txfs_inode_t     *ip, *tip;\n\tstruct fd\tf, tmp;\n\tint\t\terror = 0;\n\n\t \n\tf = fdget((int)sxp->sx_fdtarget);\n\tif (!f.file) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!(f.file->f_mode & FMODE_WRITE) ||\n\t    !(f.file->f_mode & FMODE_READ) ||\n\t    (f.file->f_flags & O_APPEND)) {\n\t\terror = -EBADF;\n\t\tgoto out_put_file;\n\t}\n\n\ttmp = fdget((int)sxp->sx_fdtmp);\n\tif (!tmp.file) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_file;\n\t}\n\n\tif (!(tmp.file->f_mode & FMODE_WRITE) ||\n\t    !(tmp.file->f_mode & FMODE_READ) ||\n\t    (tmp.file->f_flags & O_APPEND)) {\n\t\terror = -EBADF;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (IS_SWAPFILE(file_inode(f.file)) ||\n\t    IS_SWAPFILE(file_inode(tmp.file))) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\t \n\tif (f.file->f_op != &xfs_file_operations ||\n\t    tmp.file->f_op != &xfs_file_operations) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tip = XFS_I(file_inode(f.file));\n\ttip = XFS_I(file_inode(tmp.file));\n\n\tif (ip->i_mount != tip->i_mount) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (ip->i_ino == tip->i_ino) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (xfs_is_shutdown(ip->i_mount)) {\n\t\terror = -EIO;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\terror = xfs_swap_extents(ip, tip, sxp);\n\n out_put_tmp_file:\n\tfdput(tmp);\n out_put_file:\n\tfdput(f);\n out:\n\treturn error;\n}\n\nstatic int\nxfs_ioc_getlabel(\n\tstruct xfs_mount\t*mp,\n\tchar\t\t\t__user *user_label)\n{\n\tstruct xfs_sb\t\t*sbp = &mp->m_sb;\n\tchar\t\t\tlabel[XFSLABEL_MAX + 1];\n\n\t \n\tBUILD_BUG_ON(sizeof(sbp->sb_fname) > FSLABEL_MAX);\n\n\t \n\tmemset(label, 0, sizeof(label));\n\tspin_lock(&mp->m_sb_lock);\n\tstrncpy(label, sbp->sb_fname, XFSLABEL_MAX);\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (copy_to_user(user_label, label, sizeof(label)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int\nxfs_ioc_setlabel(\n\tstruct file\t\t*filp,\n\tstruct xfs_mount\t*mp,\n\tchar\t\t\t__user *newlabel)\n{\n\tstruct xfs_sb\t\t*sbp = &mp->m_sb;\n\tchar\t\t\tlabel[XFSLABEL_MAX + 1];\n\tsize_t\t\t\tlen;\n\tint\t\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\t \n\tif (copy_from_user(label, newlabel, XFSLABEL_MAX + 1))\n\t\treturn -EFAULT;\n\tlen = strnlen(label, XFSLABEL_MAX + 1);\n\tif (len > sizeof(sbp->sb_fname))\n\t\treturn -EINVAL;\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\n\tspin_lock(&mp->m_sb_lock);\n\tmemset(sbp->sb_fname, 0, sizeof(sbp->sb_fname));\n\tmemcpy(sbp->sb_fname, label, len);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t \n\terror = xfs_sync_sb_buf(mp);\n\tif (error)\n\t\tgoto out;\n\t \n\tmutex_lock(&mp->m_growlock);\n\terror = xfs_update_secondary_sbs(mp);\n\tmutex_unlock(&mp->m_growlock);\n\n\tinvalidate_bdev(mp->m_ddev_targp->bt_bdev);\n\nout:\n\tmnt_drop_write_file(filp);\n\treturn error;\n}\n\nstatic inline int\nxfs_fs_eofblocks_from_user(\n\tstruct xfs_fs_eofblocks\t\t*src,\n\tstruct xfs_icwalk\t\t*dst)\n{\n\tif (src->eof_version != XFS_EOFBLOCKS_VERSION)\n\t\treturn -EINVAL;\n\n\tif (src->eof_flags & ~XFS_EOF_FLAGS_VALID)\n\t\treturn -EINVAL;\n\n\tif (memchr_inv(&src->pad32, 0, sizeof(src->pad32)) ||\n\t    memchr_inv(src->pad64, 0, sizeof(src->pad64)))\n\t\treturn -EINVAL;\n\n\tdst->icw_flags = 0;\n\tif (src->eof_flags & XFS_EOF_FLAGS_SYNC)\n\t\tdst->icw_flags |= XFS_ICWALK_FLAG_SYNC;\n\tif (src->eof_flags & XFS_EOF_FLAGS_UID)\n\t\tdst->icw_flags |= XFS_ICWALK_FLAG_UID;\n\tif (src->eof_flags & XFS_EOF_FLAGS_GID)\n\t\tdst->icw_flags |= XFS_ICWALK_FLAG_GID;\n\tif (src->eof_flags & XFS_EOF_FLAGS_PRID)\n\t\tdst->icw_flags |= XFS_ICWALK_FLAG_PRID;\n\tif (src->eof_flags & XFS_EOF_FLAGS_MINFILESIZE)\n\t\tdst->icw_flags |= XFS_ICWALK_FLAG_MINFILESIZE;\n\n\tdst->icw_prid = src->eof_prid;\n\tdst->icw_min_file_size = src->eof_min_file_size;\n\n\tdst->icw_uid = INVALID_UID;\n\tif (src->eof_flags & XFS_EOF_FLAGS_UID) {\n\t\tdst->icw_uid = make_kuid(current_user_ns(), src->eof_uid);\n\t\tif (!uid_valid(dst->icw_uid))\n\t\t\treturn -EINVAL;\n\t}\n\n\tdst->icw_gid = INVALID_GID;\n\tif (src->eof_flags & XFS_EOF_FLAGS_GID) {\n\t\tdst->icw_gid = make_kgid(current_user_ns(), src->eof_gid);\n\t\tif (!gid_valid(dst->icw_gid))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \n#define XFS_IOC_ALLOCSP\t\t_IOW ('X', 10, struct xfs_flock64)\n#define XFS_IOC_FREESP\t\t_IOW ('X', 11, struct xfs_flock64)\n#define XFS_IOC_ALLOCSP64\t_IOW ('X', 36, struct xfs_flock64)\n#define XFS_IOC_FREESP64\t_IOW ('X', 37, struct xfs_flock64)\n\n \nlong\nxfs_file_ioctl(\n\tstruct file\t\t*filp,\n\tunsigned int\t\tcmd,\n\tunsigned long\t\tp)\n{\n\tstruct inode\t\t*inode = file_inode(filp);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tvoid\t\t\t__user *arg = (void __user *)p;\n\tint\t\t\terror;\n\n\ttrace_xfs_file_ioctl(ip);\n\n\tswitch (cmd) {\n\tcase FITRIM:\n\t\treturn xfs_ioc_trim(mp, arg);\n\tcase FS_IOC_GETFSLABEL:\n\t\treturn xfs_ioc_getlabel(mp, arg);\n\tcase FS_IOC_SETFSLABEL:\n\t\treturn xfs_ioc_setlabel(filp, mp, arg);\n\tcase XFS_IOC_ALLOCSP:\n\tcase XFS_IOC_FREESP:\n\tcase XFS_IOC_ALLOCSP64:\n\tcase XFS_IOC_FREESP64:\n\t\txfs_warn_once(mp,\n\t\"%s should use fallocate; XFS_IOC_{ALLOC,FREE}SP ioctl unsupported\",\n\t\t\t\tcurrent->comm);\n\t\treturn -ENOTTY;\n\tcase XFS_IOC_DIOINFO: {\n\t\tstruct xfs_buftarg\t*target = xfs_inode_buftarg(ip);\n\t\tstruct dioattr\t\tda;\n\n\t\tda.d_mem =  da.d_miniosz = target->bt_logical_sectorsize;\n\t\tda.d_maxiosz = INT_MAX & ~(da.d_miniosz - 1);\n\n\t\tif (copy_to_user(arg, &da, sizeof(da)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_FSBULKSTAT_SINGLE:\n\tcase XFS_IOC_FSBULKSTAT:\n\tcase XFS_IOC_FSINUMBERS:\n\t\treturn xfs_ioc_fsbulkstat(filp, cmd, arg);\n\n\tcase XFS_IOC_BULKSTAT:\n\t\treturn xfs_ioc_bulkstat(filp, cmd, arg);\n\tcase XFS_IOC_INUMBERS:\n\t\treturn xfs_ioc_inumbers(mp, cmd, arg);\n\n\tcase XFS_IOC_FSGEOMETRY_V1:\n\t\treturn xfs_ioc_fsgeometry(mp, arg, 3);\n\tcase XFS_IOC_FSGEOMETRY_V4:\n\t\treturn xfs_ioc_fsgeometry(mp, arg, 4);\n\tcase XFS_IOC_FSGEOMETRY:\n\t\treturn xfs_ioc_fsgeometry(mp, arg, 5);\n\n\tcase XFS_IOC_AG_GEOMETRY:\n\t\treturn xfs_ioc_ag_geometry(mp, arg);\n\n\tcase XFS_IOC_GETVERSION:\n\t\treturn put_user(inode->i_generation, (int __user *)arg);\n\n\tcase XFS_IOC_FSGETXATTRA:\n\t\treturn xfs_ioc_fsgetxattra(ip, arg);\n\n\tcase XFS_IOC_GETBMAP:\n\tcase XFS_IOC_GETBMAPA:\n\tcase XFS_IOC_GETBMAPX:\n\t\treturn xfs_ioc_getbmap(filp, cmd, arg);\n\n\tcase FS_IOC_GETFSMAP:\n\t\treturn xfs_ioc_getfsmap(ip, arg);\n\n\tcase XFS_IOC_SCRUB_METADATA:\n\t\treturn xfs_ioc_scrub_metadata(filp, arg);\n\n\tcase XFS_IOC_FD_TO_HANDLE:\n\tcase XFS_IOC_PATH_TO_HANDLE:\n\tcase XFS_IOC_PATH_TO_FSHANDLE: {\n\t\txfs_fsop_handlereq_t\threq;\n\n\t\tif (copy_from_user(&hreq, arg, sizeof(hreq)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_find_handle(cmd, &hreq);\n\t}\n\tcase XFS_IOC_OPEN_BY_HANDLE: {\n\t\txfs_fsop_handlereq_t\threq;\n\n\t\tif (copy_from_user(&hreq, arg, sizeof(xfs_fsop_handlereq_t)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_open_by_handle(filp, &hreq);\n\t}\n\n\tcase XFS_IOC_READLINK_BY_HANDLE: {\n\t\txfs_fsop_handlereq_t\threq;\n\n\t\tif (copy_from_user(&hreq, arg, sizeof(xfs_fsop_handlereq_t)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_readlink_by_handle(filp, &hreq);\n\t}\n\tcase XFS_IOC_ATTRLIST_BY_HANDLE:\n\t\treturn xfs_attrlist_by_handle(filp, arg);\n\n\tcase XFS_IOC_ATTRMULTI_BY_HANDLE:\n\t\treturn xfs_attrmulti_by_handle(filp, arg);\n\n\tcase XFS_IOC_SWAPEXT: {\n\t\tstruct xfs_swapext\tsxp;\n\n\t\tif (copy_from_user(&sxp, arg, sizeof(xfs_swapext_t)))\n\t\t\treturn -EFAULT;\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_ioc_swapext(&sxp);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_FSCOUNTS: {\n\t\txfs_fsop_counts_t out;\n\n\t\txfs_fs_counts(mp, &out);\n\n\t\tif (copy_to_user(arg, &out, sizeof(out)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_SET_RESBLKS: {\n\t\txfs_fsop_resblks_t inout;\n\t\tuint64_t\t   in;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (xfs_is_readonly(mp))\n\t\t\treturn -EROFS;\n\n\t\tif (copy_from_user(&inout, arg, sizeof(inout)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tin = inout.resblks;\n\t\terror = xfs_reserve_blocks(mp, &in, &inout);\n\t\tmnt_drop_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (copy_to_user(arg, &inout, sizeof(inout)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_GET_RESBLKS: {\n\t\txfs_fsop_resblks_t out;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\terror = xfs_reserve_blocks(mp, NULL, &out);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (copy_to_user(arg, &out, sizeof(out)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_FSGROWFSDATA: {\n\t\tstruct xfs_growfs_data in;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_data(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_FSGROWFSLOG: {\n\t\tstruct xfs_growfs_log in;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_log(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_FSGROWFSRT: {\n\t\txfs_growfs_rt_t in;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_rt(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_GOINGDOWN: {\n\t\tuint32_t in;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(in, (uint32_t __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\treturn xfs_fs_goingdown(mp, in);\n\t}\n\n\tcase XFS_IOC_ERROR_INJECTION: {\n\t\txfs_error_injection_t in;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\treturn xfs_errortag_add(mp, in.errtag);\n\t}\n\n\tcase XFS_IOC_ERROR_CLEARALL:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\treturn xfs_errortag_clearall(mp);\n\n\tcase XFS_IOC_FREE_EOFBLOCKS: {\n\t\tstruct xfs_fs_eofblocks\teofb;\n\t\tstruct xfs_icwalk\ticw;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (xfs_is_readonly(mp))\n\t\t\treturn -EROFS;\n\n\t\tif (copy_from_user(&eofb, arg, sizeof(eofb)))\n\t\t\treturn -EFAULT;\n\n\t\terror = xfs_fs_eofblocks_from_user(&eofb, &icw);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttrace_xfs_ioc_free_eofblocks(mp, &icw, _RET_IP_);\n\n\t\tsb_start_write(mp->m_super);\n\t\terror = xfs_blockgc_free_space(mp, &icw);\n\t\tsb_end_write(mp->m_super);\n\t\treturn error;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}