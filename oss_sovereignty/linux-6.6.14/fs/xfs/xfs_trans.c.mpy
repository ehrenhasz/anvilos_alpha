{
  "module_name": "xfs_trans.c",
  "hash_id": "7cc8e96799eaafea8269a9ce8e50c6504cdeda16f35b60f42416d5586f9f9cc3",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_trans.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_dquot.h\"\n#include \"xfs_icache.h\"\n\nstruct kmem_cache\t*xfs_trans_cache;\n\n#if defined(CONFIG_TRACEPOINTS)\nstatic void\nxfs_trans_trace_reservations(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_trans_res\t*res;\n\tstruct xfs_trans_res\t*end_res;\n\tint\t\t\ti;\n\n\tres = (struct xfs_trans_res *)M_RES(mp);\n\tend_res = (struct xfs_trans_res *)(M_RES(mp) + 1);\n\tfor (i = 0; res < end_res; i++, res++)\n\t\ttrace_xfs_trans_resv_calc(mp, i, res);\n}\n#else\n# define xfs_trans_trace_reservations(mp)\n#endif\n\n \nvoid\nxfs_trans_init(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_trans_resv_calc(mp, M_RES(mp));\n\txfs_trans_trace_reservations(mp);\n}\n\n \nSTATIC void\nxfs_trans_free(\n\tstruct xfs_trans\t*tp)\n{\n\txfs_extent_busy_sort(&tp->t_busy);\n\txfs_extent_busy_clear(tp->t_mountp, &tp->t_busy, false);\n\n\ttrace_xfs_trans_free(tp, _RET_IP_);\n\txfs_trans_clear_context(tp);\n\tif (!(tp->t_flags & XFS_TRANS_NO_WRITECOUNT))\n\t\tsb_end_intwrite(tp->t_mountp->m_super);\n\txfs_trans_free_dqinfo(tp);\n\tkmem_cache_free(xfs_trans_cache, tp);\n}\n\n \nSTATIC struct xfs_trans *\nxfs_trans_dup(\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_trans\t*ntp;\n\n\ttrace_xfs_trans_dup(tp, _RET_IP_);\n\n\tntp = kmem_cache_zalloc(xfs_trans_cache, GFP_KERNEL | __GFP_NOFAIL);\n\n\t \n\tntp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\tntp->t_mountp = tp->t_mountp;\n\tINIT_LIST_HEAD(&ntp->t_items);\n\tINIT_LIST_HEAD(&ntp->t_busy);\n\tINIT_LIST_HEAD(&ntp->t_dfops);\n\tntp->t_highest_agno = NULLAGNUMBER;\n\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(tp->t_ticket != NULL);\n\n\tntp->t_flags = XFS_TRANS_PERM_LOG_RES |\n\t\t       (tp->t_flags & XFS_TRANS_RESERVE) |\n\t\t       (tp->t_flags & XFS_TRANS_NO_WRITECOUNT) |\n\t\t       (tp->t_flags & XFS_TRANS_RES_FDBLKS);\n\t \n\ttp->t_flags |= XFS_TRANS_NO_WRITECOUNT;\n\tntp->t_ticket = xfs_log_ticket_get(tp->t_ticket);\n\n\tASSERT(tp->t_blk_res >= tp->t_blk_res_used);\n\tntp->t_blk_res = tp->t_blk_res - tp->t_blk_res_used;\n\ttp->t_blk_res = tp->t_blk_res_used;\n\n\tntp->t_rtx_res = tp->t_rtx_res - tp->t_rtx_res_used;\n\ttp->t_rtx_res = tp->t_rtx_res_used;\n\n\txfs_trans_switch_context(tp, ntp);\n\n\t \n\txfs_defer_move(ntp, tp);\n\n\txfs_trans_dup_dqinfo(tp, ntp);\n\treturn ntp;\n}\n\n \nstatic int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tint\t\t\terror = 0;\n\tbool\t\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t \n\tif (blocks > 0) {\n\t\terror = xfs_mod_fdblocks(mp, -((int64_t)blocks), rsvd);\n\t\tif (error != 0)\n\t\t\treturn -ENOSPC;\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t \n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(mp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(mp, resp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, permanent);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t \n\tif (rtextents > 0) {\n\t\terror = xfs_mod_frextents(mp, -((int64_t)rtextents));\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t \nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\txfs_log_ticket_ungrant(mp->m_log, tp->t_ticket);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_mod_fdblocks(mp, (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\treturn error;\n}\n\nint\nxfs_trans_alloc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents,\n\tuint\t\t\tflags,\n\tstruct xfs_trans\t**tpp)\n{\n\tstruct xfs_trans\t*tp;\n\tbool\t\t\twant_retry = true;\n\tint\t\t\terror;\n\n\t \nretry:\n\ttp = kmem_cache_zalloc(xfs_trans_cache, GFP_KERNEL | __GFP_NOFAIL);\n\tif (!(flags & XFS_TRANS_NO_WRITECOUNT))\n\t\tsb_start_intwrite(mp->m_super);\n\txfs_trans_set_context(tp);\n\n\t \n\tWARN_ON(resp->tr_logres > 0 &&\n\t\tmp->m_super->s_writers.frozen == SB_FREEZE_COMPLETE);\n\tASSERT(!(flags & XFS_TRANS_RES_FDBLKS) ||\n\t       xfs_has_lazysbcount(mp));\n\n\ttp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\ttp->t_flags = flags;\n\ttp->t_mountp = mp;\n\tINIT_LIST_HEAD(&tp->t_items);\n\tINIT_LIST_HEAD(&tp->t_busy);\n\tINIT_LIST_HEAD(&tp->t_dfops);\n\ttp->t_highest_agno = NULLAGNUMBER;\n\n\terror = xfs_trans_reserve(tp, resp, blocks, rtextents);\n\tif (error == -ENOSPC && want_retry) {\n\t\txfs_trans_cancel(tp);\n\n\t\t \n\t\terror = xfs_blockgc_flush_all(mp);\n\t\tif (error)\n\t\t\treturn error;\n\t\twant_retry = false;\n\t\tgoto retry;\n\t}\n\tif (error) {\n\t\txfs_trans_cancel(tp);\n\t\treturn error;\n\t}\n\n\ttrace_xfs_trans_alloc(tp, _RET_IP_);\n\n\t*tpp = tp;\n\treturn 0;\n}\n\n \nint\nxfs_trans_alloc_empty(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_trans\t\t**tpp)\n{\n\tstruct xfs_trans_res\t\tresv = {0};\n\n\treturn xfs_trans_alloc(mp, &resv, 0, 0, XFS_TRANS_NO_WRITECOUNT, tpp);\n}\n\n \nvoid\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_has_lazysbcount(mp))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_has_lazysbcount(mp))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t \n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tif (tp->t_blk_res_used > tp->t_blk_res)\n\t\t\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\t} else if (delta > 0 && (tp->t_flags & XFS_TRANS_RES_FDBLKS)) {\n\t\t\tint64_t\tblkres_delta;\n\n\t\t\t \n\t\t\tblkres_delta = min_t(int64_t, delta,\n\t\t\t\t\t     UINT_MAX - tp->t_blk_res);\n\t\t\ttp->t_blk_res += blkres_delta;\n\t\t\tdelta -= blkres_delta;\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_has_lazysbcount(mp))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t \n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_has_lazysbcount(mp))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t \n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t \n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}\n\n \nSTATIC void\nxfs_trans_apply_sb_deltas(\n\txfs_trans_t\t*tp)\n{\n\tstruct xfs_dsb\t*sbp;\n\tstruct xfs_buf\t*bp;\n\tint\t\twhole = 0;\n\n\tbp = xfs_trans_getsb(tp);\n\tsbp = bp->b_addr;\n\n\t \n\tif (!xfs_has_lazysbcount((tp->t_mountp))) {\n\t\tif (tp->t_icount_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_icount, tp->t_icount_delta);\n\t\tif (tp->t_ifree_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_ifree, tp->t_ifree_delta);\n\t\tif (tp->t_fdblocks_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_fdblocks, tp->t_fdblocks_delta);\n\t\tif (tp->t_res_fdblocks_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_fdblocks, tp->t_res_fdblocks_delta);\n\t}\n\n\t \n\tif (tp->t_frextents_delta || tp->t_res_frextents_delta) {\n\t\tstruct xfs_mount\t*mp = tp->t_mountp;\n\t\tint64_t\t\t\trtxdelta;\n\n\t\trtxdelta = tp->t_frextents_delta + tp->t_res_frextents_delta;\n\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tbe64_add_cpu(&sbp->sb_frextents, rtxdelta);\n\t\tmp->m_sb.sb_frextents += rtxdelta;\n\t\tspin_unlock(&mp->m_sb_lock);\n\t}\n\n\tif (tp->t_dblocks_delta) {\n\t\tbe64_add_cpu(&sbp->sb_dblocks, tp->t_dblocks_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_agcount_delta) {\n\t\tbe32_add_cpu(&sbp->sb_agcount, tp->t_agcount_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_imaxpct_delta) {\n\t\tsbp->sb_imax_pct += tp->t_imaxpct_delta;\n\t\twhole = 1;\n\t}\n\tif (tp->t_rextsize_delta) {\n\t\tbe32_add_cpu(&sbp->sb_rextsize, tp->t_rextsize_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rbmblocks_delta) {\n\t\tbe32_add_cpu(&sbp->sb_rbmblocks, tp->t_rbmblocks_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rblocks_delta) {\n\t\tbe64_add_cpu(&sbp->sb_rblocks, tp->t_rblocks_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rextents_delta) {\n\t\tbe64_add_cpu(&sbp->sb_rextents, tp->t_rextents_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rextslog_delta) {\n\t\tsbp->sb_rextslog += tp->t_rextslog_delta;\n\t\twhole = 1;\n\t}\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SB_BUF);\n\tif (whole)\n\t\t \n\t\txfs_trans_log_buf(tp, bp, 0, sizeof(struct xfs_dsb) - 1);\n\telse\n\t\t \n\t\txfs_trans_log_buf(tp, bp, offsetof(struct xfs_dsb, sb_icount),\n\t\t\t\t  offsetof(struct xfs_dsb, sb_frextents) +\n\t\t\t\t  sizeof(sbp->sb_frextents) - 1);\n}\n\n \n#define XFS_ICOUNT_BATCH\t128\n\nvoid\nxfs_trans_unreserve_and_mod_sb(\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tbool\t\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\tint64_t\t\t\tblkdelta = 0;\n\tint64_t\t\t\trtxdelta = 0;\n\tint64_t\t\t\tidelta = 0;\n\tint64_t\t\t\tifreedelta = 0;\n\tint\t\t\terror;\n\n\t \n\tif (tp->t_blk_res > 0)\n\t\tblkdelta = tp->t_blk_res;\n\tif ((tp->t_fdblocks_delta != 0) &&\n\t    (xfs_has_lazysbcount(mp) ||\n\t     (tp->t_flags & XFS_TRANS_SB_DIRTY)))\n\t        blkdelta += tp->t_fdblocks_delta;\n\n\tif (tp->t_rtx_res > 0)\n\t\trtxdelta = tp->t_rtx_res;\n\tif ((tp->t_frextents_delta != 0) &&\n\t    (tp->t_flags & XFS_TRANS_SB_DIRTY))\n\t\trtxdelta += tp->t_frextents_delta;\n\n\tif (xfs_has_lazysbcount(mp) ||\n\t     (tp->t_flags & XFS_TRANS_SB_DIRTY)) {\n\t\tidelta = tp->t_icount_delta;\n\t\tifreedelta = tp->t_ifree_delta;\n\t}\n\n\t \n\tif (blkdelta) {\n\t\terror = xfs_mod_fdblocks(mp, blkdelta, rsvd);\n\t\tASSERT(!error);\n\t}\n\n\tif (idelta)\n\t\tpercpu_counter_add_batch(&mp->m_icount, idelta,\n\t\t\t\t\t XFS_ICOUNT_BATCH);\n\n\tif (ifreedelta)\n\t\tpercpu_counter_add(&mp->m_ifree, ifreedelta);\n\n\tif (rtxdelta) {\n\t\terror = xfs_mod_frextents(mp, rtxdelta);\n\t\tASSERT(!error);\n\t}\n\n\tif (!(tp->t_flags & XFS_TRANS_SB_DIRTY))\n\t\treturn;\n\n\t \n\tspin_lock(&mp->m_sb_lock);\n\tmp->m_sb.sb_fdblocks += tp->t_fdblocks_delta + tp->t_res_fdblocks_delta;\n\tmp->m_sb.sb_icount += idelta;\n\tmp->m_sb.sb_ifree += ifreedelta;\n\t \n\tmp->m_sb.sb_dblocks += tp->t_dblocks_delta;\n\tmp->m_sb.sb_agcount += tp->t_agcount_delta;\n\tmp->m_sb.sb_imax_pct += tp->t_imaxpct_delta;\n\tmp->m_sb.sb_rextsize += tp->t_rextsize_delta;\n\tmp->m_sb.sb_rbmblocks += tp->t_rbmblocks_delta;\n\tmp->m_sb.sb_rblocks += tp->t_rblocks_delta;\n\tmp->m_sb.sb_rextents += tp->t_rextents_delta;\n\tmp->m_sb.sb_rextslog += tp->t_rextslog_delta;\n\tspin_unlock(&mp->m_sb_lock);\n\n\t \n\tASSERT(mp->m_sb.sb_imax_pct >= 0);\n\tASSERT(mp->m_sb.sb_rextslog >= 0);\n\treturn;\n}\n\n \nvoid\nxfs_trans_add_item(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_log_item\t*lip)\n{\n\tASSERT(lip->li_log == tp->t_mountp->m_log);\n\tASSERT(lip->li_ailp == tp->t_mountp->m_ail);\n\tASSERT(list_empty(&lip->li_trans));\n\tASSERT(!test_bit(XFS_LI_DIRTY, &lip->li_flags));\n\n\tlist_add_tail(&lip->li_trans, &tp->t_items);\n\ttrace_xfs_trans_add_item(tp, _RET_IP_);\n}\n\n \nvoid\nxfs_trans_del_item(\n\tstruct xfs_log_item\t*lip)\n{\n\tclear_bit(XFS_LI_DIRTY, &lip->li_flags);\n\tlist_del_init(&lip->li_trans);\n}\n\n \nstatic void\nxfs_trans_free_items(\n\tstruct xfs_trans\t*tp,\n\tbool\t\t\tabort)\n{\n\tstruct xfs_log_item\t*lip, *next;\n\n\ttrace_xfs_trans_free_items(tp, _RET_IP_);\n\n\tlist_for_each_entry_safe(lip, next, &tp->t_items, li_trans) {\n\t\txfs_trans_del_item(lip);\n\t\tif (abort)\n\t\t\tset_bit(XFS_LI_ABORTED, &lip->li_flags);\n\t\tif (lip->li_ops->iop_release)\n\t\t\tlip->li_ops->iop_release(lip);\n\t}\n}\n\nstatic inline void\nxfs_log_item_batch_insert(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\tstruct xfs_log_item\t**log_items,\n\tint\t\t\tnr_items,\n\txfs_lsn_t\t\tcommit_lsn)\n{\n\tint\ti;\n\n\tspin_lock(&ailp->ail_lock);\n\t \n\txfs_trans_ail_update_bulk(ailp, cur, log_items, nr_items, commit_lsn);\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tstruct xfs_log_item *lip = log_items[i];\n\n\t\tif (lip->li_ops->iop_unpin)\n\t\t\tlip->li_ops->iop_unpin(lip, 0);\n\t}\n}\n\n \nvoid\nxfs_trans_committed_bulk(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct list_head\t*lv_chain,\n\txfs_lsn_t\t\tcommit_lsn,\n\tbool\t\t\taborted)\n{\n#define LOG_ITEM_BATCH_SIZE\t32\n\tstruct xfs_log_item\t*log_items[LOG_ITEM_BATCH_SIZE];\n\tstruct xfs_log_vec\t*lv;\n\tstruct xfs_ail_cursor\tcur;\n\tint\t\t\ti = 0;\n\n\tspin_lock(&ailp->ail_lock);\n\txfs_trans_ail_cursor_last(ailp, &cur, commit_lsn);\n\tspin_unlock(&ailp->ail_lock);\n\n\t \n\tlist_for_each_entry(lv, lv_chain, lv_list) {\n\t\tstruct xfs_log_item\t*lip = lv->lv_item;\n\t\txfs_lsn_t\t\titem_lsn;\n\n\t\tif (aborted)\n\t\t\tset_bit(XFS_LI_ABORTED, &lip->li_flags);\n\n\t\tif (lip->li_ops->flags & XFS_ITEM_RELEASE_WHEN_COMMITTED) {\n\t\t\tlip->li_ops->iop_release(lip);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (lip->li_ops->iop_committed)\n\t\t\titem_lsn = lip->li_ops->iop_committed(lip, commit_lsn);\n\t\telse\n\t\t\titem_lsn = commit_lsn;\n\n\t\t \n\t\tif (XFS_LSN_CMP(item_lsn, (xfs_lsn_t)-1) == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (aborted) {\n\t\t\tASSERT(xlog_is_shutdown(ailp->ail_log));\n\t\t\tif (lip->li_ops->iop_unpin)\n\t\t\t\tlip->li_ops->iop_unpin(lip, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (item_lsn != commit_lsn) {\n\n\t\t\t \n\t\t\tspin_lock(&ailp->ail_lock);\n\t\t\tif (XFS_LSN_CMP(item_lsn, lip->li_lsn) > 0)\n\t\t\t\txfs_trans_ail_update(ailp, lip, item_lsn);\n\t\t\telse\n\t\t\t\tspin_unlock(&ailp->ail_lock);\n\t\t\tif (lip->li_ops->iop_unpin)\n\t\t\t\tlip->li_ops->iop_unpin(lip, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tlog_items[i++] = lv->lv_item;\n\t\tif (i >= LOG_ITEM_BATCH_SIZE) {\n\t\t\txfs_log_item_batch_insert(ailp, &cur, log_items,\n\t\t\t\t\tLOG_ITEM_BATCH_SIZE, commit_lsn);\n\t\t\ti = 0;\n\t\t}\n\t}\n\n\t \n\tif (i)\n\t\txfs_log_item_batch_insert(ailp, &cur, log_items, i, commit_lsn);\n\n\tspin_lock(&ailp->ail_lock);\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->ail_lock);\n}\n\n \nstatic int\nxfs_trans_precommit_sort(\n\tvoid\t\t\t*unused_arg,\n\tconst struct list_head\t*a,\n\tconst struct list_head\t*b)\n{\n\tstruct xfs_log_item\t*lia = container_of(a,\n\t\t\t\t\tstruct xfs_log_item, li_trans);\n\tstruct xfs_log_item\t*lib = container_of(b,\n\t\t\t\t\tstruct xfs_log_item, li_trans);\n\tint64_t\t\t\tdiff;\n\n\t \n\tif (!lia->li_ops->iop_sort && !lib->li_ops->iop_sort)\n\t\treturn 0;\n\tif (!lia->li_ops->iop_sort)\n\t\treturn 1;\n\tif (!lib->li_ops->iop_sort)\n\t\treturn -1;\n\n\tdiff = lia->li_ops->iop_sort(lia) - lib->li_ops->iop_sort(lib);\n\tif (diff < 0)\n\t\treturn -1;\n\tif (diff > 0)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int\nxfs_trans_run_precommits(\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_log_item\t*lip, *n;\n\tint\t\t\terror = 0;\n\n\t \n\tlist_sort(NULL, &tp->t_items, xfs_trans_precommit_sort);\n\n\t \n\tlist_for_each_entry_safe(lip, n, &tp->t_items, li_trans) {\n\t\tif (!test_bit(XFS_LI_DIRTY, &lip->li_flags))\n\t\t\tcontinue;\n\t\tif (lip->li_ops->iop_precommit) {\n\t\t\terror = lip->li_ops->iop_precommit(tp, lip);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (error)\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\treturn error;\n}\n\n \nstatic int\n__xfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tbool\t\t\tregrant)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xlog\t\t*log = mp->m_log;\n\txfs_csn_t\t\tcommit_seq = 0;\n\tint\t\t\terror = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\ttrace_xfs_trans_commit(tp, _RET_IP_);\n\n\terror = xfs_trans_run_precommits(tp);\n\tif (error) {\n\t\tif (tp->t_flags & XFS_TRANS_PERM_LOG_RES)\n\t\t\txfs_defer_cancel(tp);\n\t\tgoto out_unreserve;\n\t}\n\n\t \n\tWARN_ON_ONCE(!list_empty(&tp->t_dfops) &&\n\t\t     !(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\tif (!regrant && (tp->t_flags & XFS_TRANS_PERM_LOG_RES)) {\n\t\terror = xfs_defer_finish_noroll(&tp);\n\t\tif (error)\n\t\t\tgoto out_unreserve;\n\n\t\t \n\t\terror = xfs_trans_run_precommits(tp);\n\t\tif (error)\n\t\t\tgoto out_unreserve;\n\t}\n\n\t \n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\t \n\tif (xlog_is_shutdown(log)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t \n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txlog_cil_commit(log, tp, &commit_seq, regrant);\n\n\txfs_trans_free(tp);\n\n\t \n\tif (sync) {\n\t\terror = xfs_log_force_seq(mp, commit_seq, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(mp, xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(mp, xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t \n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tif (regrant && !xlog_is_shutdown(log))\n\t\t\txfs_log_ticket_regrant(log, tp->t_ticket);\n\t\telse\n\t\t\txfs_log_ticket_ungrant(log, tp->t_ticket);\n\t\ttp->t_ticket = NULL;\n\t}\n\txfs_trans_free_items(tp, !!error);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(mp, xs_trans_empty);\n\treturn error;\n}\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp)\n{\n\treturn __xfs_trans_commit(tp, false);\n}\n\n \nvoid\nxfs_trans_cancel(\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xlog\t\t*log = mp->m_log;\n\tbool\t\t\tdirty = (tp->t_flags & XFS_TRANS_DIRTY);\n\n\ttrace_xfs_trans_cancel(tp, _RET_IP_);\n\n\t \n\tif (!list_empty(&tp->t_dfops)) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tdirty = true;\n\t\txfs_defer_cancel(tp);\n\t}\n\n\t \n\tif (dirty && !xfs_is_shutdown(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\t \n\tif (!dirty && !xlog_is_shutdown(log)) {\n\t\tstruct xfs_log_item *lip;\n\n\t\tlist_for_each_entry(lip, &tp->t_items, li_trans)\n\t\t\tASSERT(!xlog_item_is_intent_done(lip));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\txfs_log_ticket_ungrant(log, tp->t_ticket);\n\t\ttp->t_ticket = NULL;\n\t}\n\n\txfs_trans_free_items(tp, dirty);\n\txfs_trans_free(tp);\n}\n\n \nint\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp)\n{\n\tstruct xfs_trans\t*trans = *tpp;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\ttrace_xfs_trans_roll(trans, _RET_IP_);\n\n\t \n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\n\t*tpp = xfs_trans_dup(trans);\n\n\t \n\terror = __xfs_trans_commit(trans, true);\n\tif (error)\n\t\treturn error;\n\n\t \n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\treturn xfs_trans_reserve(*tpp, &tres, 0, 0);\n}\n\n \nint\nxfs_trans_alloc_inode(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans_res\t*resv,\n\tunsigned int\t\tdblocks,\n\tunsigned int\t\trblocks,\n\tbool\t\t\tforce,\n\tstruct xfs_trans\t**tpp)\n{\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tbool\t\t\tretried = false;\n\tint\t\t\terror;\n\nretry:\n\terror = xfs_trans_alloc(mp, resv, dblocks,\n\t\t\trblocks / mp->m_sb.sb_rextsize,\n\t\t\tforce ? XFS_TRANS_RESERVE : 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\terror = xfs_qm_dqattach_locked(ip, false);\n\tif (error) {\n\t\t \n\t\tASSERT(error != -ENOENT);\n\t\tgoto out_cancel;\n\t}\n\n\terror = xfs_trans_reserve_quota_nblks(tp, ip, dblocks, rblocks, force);\n\tif ((error == -EDQUOT || error == -ENOSPC) && !retried) {\n\t\txfs_trans_cancel(tp);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\txfs_blockgc_free_quota(ip, 0);\n\t\tretried = true;\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_cancel;\n\n\t*tpp = tp;\n\treturn 0;\n\nout_cancel:\n\txfs_trans_cancel(tp);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\n \nint\nxfs_trans_alloc_icreate(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans_res\t*resv,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tunsigned int\t\tdblocks,\n\tstruct xfs_trans\t**tpp)\n{\n\tstruct xfs_trans\t*tp;\n\tbool\t\t\tretried = false;\n\tint\t\t\terror;\n\nretry:\n\terror = xfs_trans_alloc(mp, resv, dblocks, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_trans_reserve_quota_icreate(tp, udqp, gdqp, pdqp, dblocks);\n\tif ((error == -EDQUOT || error == -ENOSPC) && !retried) {\n\t\txfs_trans_cancel(tp);\n\t\txfs_blockgc_free_dquots(mp, udqp, gdqp, pdqp, 0);\n\t\tretried = true;\n\t\tgoto retry;\n\t}\n\tif (error) {\n\t\txfs_trans_cancel(tp);\n\t\treturn error;\n\t}\n\n\t*tpp = tp;\n\treturn 0;\n}\n\n \nint\nxfs_trans_alloc_ichange(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dquot\t*new_udqp,\n\tstruct xfs_dquot\t*new_gdqp,\n\tstruct xfs_dquot\t*new_pdqp,\n\tbool\t\t\tforce,\n\tstruct xfs_trans\t**tpp)\n{\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_dquot\t*udqp;\n\tstruct xfs_dquot\t*gdqp;\n\tstruct xfs_dquot\t*pdqp;\n\tbool\t\t\tretried = false;\n\tint\t\t\terror;\n\nretry:\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_ichange, 0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_qm_dqattach_locked(ip, false);\n\tif (error) {\n\t\t \n\t\tASSERT(error != -ENOENT);\n\t\tgoto out_cancel;\n\t}\n\n\t \n\tudqp = (new_udqp != ip->i_udquot) ? new_udqp : NULL;\n\tgdqp = (new_gdqp != ip->i_gdquot) ? new_gdqp : NULL;\n\tpdqp = (new_pdqp != ip->i_pdquot) ? new_pdqp : NULL;\n\tif (udqp || gdqp || pdqp) {\n\t\tunsigned int\tqflags = XFS_QMOPT_RES_REGBLKS;\n\n\t\tif (force)\n\t\t\tqflags |= XFS_QMOPT_FORCE_RES;\n\n\t\t \n\t\terror = xfs_trans_reserve_quota_bydquots(tp, mp, udqp, gdqp,\n\t\t\t\tpdqp, ip->i_nblocks + ip->i_delayed_blks,\n\t\t\t\t1, qflags);\n\t\tif ((error == -EDQUOT || error == -ENOSPC) && !retried) {\n\t\t\txfs_trans_cancel(tp);\n\t\t\txfs_blockgc_free_dquots(mp, udqp, gdqp, pdqp, 0);\n\t\t\tretried = true;\n\t\t\tgoto retry;\n\t\t}\n\t\tif (error)\n\t\t\tgoto out_cancel;\n\t}\n\n\t*tpp = tp;\n\treturn 0;\n\nout_cancel:\n\txfs_trans_cancel(tp);\n\treturn error;\n}\n\n \nint\nxfs_trans_alloc_dir(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_trans_res\t*resv,\n\tstruct xfs_inode\t*ip,\n\tunsigned int\t\t*dblocks,\n\tstruct xfs_trans\t**tpp,\n\tint\t\t\t*nospace_error)\n{\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tunsigned int\t\tresblks;\n\tbool\t\t\tretried = false;\n\tint\t\t\terror;\n\nretry:\n\t*nospace_error = 0;\n\tresblks = *dblocks;\n\terror = xfs_trans_alloc(mp, resv, resblks, 0, 0, &tp);\n\tif (error == -ENOSPC) {\n\t\t*nospace_error = error;\n\t\tresblks = 0;\n\t\terror = xfs_trans_alloc(mp, resv, resblks, 0, 0, &tp);\n\t}\n\tif (error)\n\t\treturn error;\n\n\txfs_lock_two_inodes(dp, XFS_ILOCK_EXCL, ip, XFS_ILOCK_EXCL);\n\n\txfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_qm_dqattach_locked(dp, false);\n\tif (error) {\n\t\t \n\t\tASSERT(error != -ENOENT);\n\t\tgoto out_cancel;\n\t}\n\n\terror = xfs_qm_dqattach_locked(ip, false);\n\tif (error) {\n\t\t \n\t\tASSERT(error != -ENOENT);\n\t\tgoto out_cancel;\n\t}\n\n\tif (resblks == 0)\n\t\tgoto done;\n\n\terror = xfs_trans_reserve_quota_nblks(tp, dp, resblks, 0, false);\n\tif (error == -EDQUOT || error == -ENOSPC) {\n\t\tif (!retried) {\n\t\t\txfs_trans_cancel(tp);\n\t\t\txfs_blockgc_free_quota(dp, 0);\n\t\t\tretried = true;\n\t\t\tgoto retry;\n\t\t}\n\n\t\t*nospace_error = error;\n\t\tresblks = 0;\n\t\terror = 0;\n\t}\n\tif (error)\n\t\tgoto out_cancel;\n\ndone:\n\t*tpp = tp;\n\t*dblocks = resblks;\n\treturn 0;\n\nout_cancel:\n\txfs_trans_cancel(tp);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}