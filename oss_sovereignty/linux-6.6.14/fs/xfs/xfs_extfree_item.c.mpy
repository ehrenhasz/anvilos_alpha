{
  "module_name": "xfs_extfree_item.c",
  "hash_id": "a5ae369c4ecaaa2425d86737d27b9e3727fe5210260ad16dbf59bf3d6849e2ac",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_extfree_item.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_log.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log_recover.h\"\n\nstruct kmem_cache\t*xfs_efi_cache;\nstruct kmem_cache\t*xfs_efd_cache;\n\nstatic const struct xfs_item_ops xfs_efi_item_ops;\n\nstatic inline struct xfs_efi_log_item *EFI_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_efi_log_item, efi_item);\n}\n\nSTATIC void\nxfs_efi_item_free(\n\tstruct xfs_efi_log_item\t*efip)\n{\n\tkmem_free(efip->efi_item.li_lv_shadow);\n\tif (efip->efi_format.efi_nextents > XFS_EFI_MAX_FAST_EXTENTS)\n\t\tkmem_free(efip);\n\telse\n\t\tkmem_cache_free(xfs_efi_cache, efip);\n}\n\n \nSTATIC void\nxfs_efi_release(\n\tstruct xfs_efi_log_item\t*efip)\n{\n\tASSERT(atomic_read(&efip->efi_refcount) > 0);\n\tif (!atomic_dec_and_test(&efip->efi_refcount))\n\t\treturn;\n\n\txfs_trans_ail_delete(&efip->efi_item, 0);\n\txfs_efi_item_free(efip);\n}\n\nSTATIC void\nxfs_efi_item_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_efi_log_item\t*efip = EFI_ITEM(lip);\n\n\t*nvecs += 1;\n\t*nbytes += xfs_efi_log_format_sizeof(efip->efi_format.efi_nextents);\n}\n\n \nSTATIC void\nxfs_efi_item_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_efi_log_item\t*efip = EFI_ITEM(lip);\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\n\tASSERT(atomic_read(&efip->efi_next_extent) ==\n\t\t\t\tefip->efi_format.efi_nextents);\n\n\tefip->efi_format.efi_type = XFS_LI_EFI;\n\tefip->efi_format.efi_size = 1;\n\n\txlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_EFI_FORMAT,\n\t\t\t&efip->efi_format,\n\t\t\txfs_efi_log_format_sizeof(efip->efi_format.efi_nextents));\n}\n\n\n \nSTATIC void\nxfs_efi_item_unpin(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\tremove)\n{\n\tstruct xfs_efi_log_item\t*efip = EFI_ITEM(lip);\n\txfs_efi_release(efip);\n}\n\n \nSTATIC void\nxfs_efi_item_release(\n\tstruct xfs_log_item\t*lip)\n{\n\txfs_efi_release(EFI_ITEM(lip));\n}\n\n \nSTATIC struct xfs_efi_log_item *\nxfs_efi_init(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tnextents)\n\n{\n\tstruct xfs_efi_log_item\t*efip;\n\n\tASSERT(nextents > 0);\n\tif (nextents > XFS_EFI_MAX_FAST_EXTENTS) {\n\t\tefip = kzalloc(xfs_efi_log_item_sizeof(nextents),\n\t\t\t\tGFP_KERNEL | __GFP_NOFAIL);\n\t} else {\n\t\tefip = kmem_cache_zalloc(xfs_efi_cache,\n\t\t\t\t\t GFP_KERNEL | __GFP_NOFAIL);\n\t}\n\n\txfs_log_item_init(mp, &efip->efi_item, XFS_LI_EFI, &xfs_efi_item_ops);\n\tefip->efi_format.efi_nextents = nextents;\n\tefip->efi_format.efi_id = (uintptr_t)(void *)efip;\n\tatomic_set(&efip->efi_next_extent, 0);\n\tatomic_set(&efip->efi_refcount, 2);\n\n\treturn efip;\n}\n\n \nSTATIC int\nxfs_efi_copy_format(xfs_log_iovec_t *buf, xfs_efi_log_format_t *dst_efi_fmt)\n{\n\txfs_efi_log_format_t *src_efi_fmt = buf->i_addr;\n\tuint i;\n\tuint len = xfs_efi_log_format_sizeof(src_efi_fmt->efi_nextents);\n\tuint len32 = xfs_efi_log_format32_sizeof(src_efi_fmt->efi_nextents);\n\tuint len64 = xfs_efi_log_format64_sizeof(src_efi_fmt->efi_nextents);\n\n\tif (buf->i_len == len) {\n\t\tmemcpy(dst_efi_fmt, src_efi_fmt,\n\t\t       offsetof(struct xfs_efi_log_format, efi_extents));\n\t\tfor (i = 0; i < src_efi_fmt->efi_nextents; i++)\n\t\t\tmemcpy(&dst_efi_fmt->efi_extents[i],\n\t\t\t       &src_efi_fmt->efi_extents[i],\n\t\t\t       sizeof(struct xfs_extent));\n\t\treturn 0;\n\t} else if (buf->i_len == len32) {\n\t\txfs_efi_log_format_32_t *src_efi_fmt_32 = buf->i_addr;\n\n\t\tdst_efi_fmt->efi_type     = src_efi_fmt_32->efi_type;\n\t\tdst_efi_fmt->efi_size     = src_efi_fmt_32->efi_size;\n\t\tdst_efi_fmt->efi_nextents = src_efi_fmt_32->efi_nextents;\n\t\tdst_efi_fmt->efi_id       = src_efi_fmt_32->efi_id;\n\t\tfor (i = 0; i < dst_efi_fmt->efi_nextents; i++) {\n\t\t\tdst_efi_fmt->efi_extents[i].ext_start =\n\t\t\t\tsrc_efi_fmt_32->efi_extents[i].ext_start;\n\t\t\tdst_efi_fmt->efi_extents[i].ext_len =\n\t\t\t\tsrc_efi_fmt_32->efi_extents[i].ext_len;\n\t\t}\n\t\treturn 0;\n\t} else if (buf->i_len == len64) {\n\t\txfs_efi_log_format_64_t *src_efi_fmt_64 = buf->i_addr;\n\n\t\tdst_efi_fmt->efi_type     = src_efi_fmt_64->efi_type;\n\t\tdst_efi_fmt->efi_size     = src_efi_fmt_64->efi_size;\n\t\tdst_efi_fmt->efi_nextents = src_efi_fmt_64->efi_nextents;\n\t\tdst_efi_fmt->efi_id       = src_efi_fmt_64->efi_id;\n\t\tfor (i = 0; i < dst_efi_fmt->efi_nextents; i++) {\n\t\t\tdst_efi_fmt->efi_extents[i].ext_start =\n\t\t\t\tsrc_efi_fmt_64->efi_extents[i].ext_start;\n\t\t\tdst_efi_fmt->efi_extents[i].ext_len =\n\t\t\t\tsrc_efi_fmt_64->efi_extents[i].ext_len;\n\t\t}\n\t\treturn 0;\n\t}\n\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, NULL, buf->i_addr,\n\t\t\tbuf->i_len);\n\treturn -EFSCORRUPTED;\n}\n\nstatic inline struct xfs_efd_log_item *EFD_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_efd_log_item, efd_item);\n}\n\nSTATIC void\nxfs_efd_item_free(struct xfs_efd_log_item *efdp)\n{\n\tkmem_free(efdp->efd_item.li_lv_shadow);\n\tif (efdp->efd_format.efd_nextents > XFS_EFD_MAX_FAST_EXTENTS)\n\t\tkmem_free(efdp);\n\telse\n\t\tkmem_cache_free(xfs_efd_cache, efdp);\n}\n\nSTATIC void\nxfs_efd_item_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_efd_log_item\t*efdp = EFD_ITEM(lip);\n\n\t*nvecs += 1;\n\t*nbytes += xfs_efd_log_format_sizeof(efdp->efd_format.efd_nextents);\n}\n\n \nSTATIC void\nxfs_efd_item_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_efd_log_item\t*efdp = EFD_ITEM(lip);\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\n\tASSERT(efdp->efd_next_extent == efdp->efd_format.efd_nextents);\n\n\tefdp->efd_format.efd_type = XFS_LI_EFD;\n\tefdp->efd_format.efd_size = 1;\n\n\txlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_EFD_FORMAT,\n\t\t\t&efdp->efd_format,\n\t\t\txfs_efd_log_format_sizeof(efdp->efd_format.efd_nextents));\n}\n\n \nSTATIC void\nxfs_efd_item_release(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_efd_log_item\t*efdp = EFD_ITEM(lip);\n\n\txfs_efi_release(efdp->efd_efip);\n\txfs_efd_item_free(efdp);\n}\n\nstatic struct xfs_log_item *\nxfs_efd_item_intent(\n\tstruct xfs_log_item\t*lip)\n{\n\treturn &EFD_ITEM(lip)->efd_efip->efi_item;\n}\n\nstatic const struct xfs_item_ops xfs_efd_item_ops = {\n\t.flags\t\t= XFS_ITEM_RELEASE_WHEN_COMMITTED |\n\t\t\t  XFS_ITEM_INTENT_DONE,\n\t.iop_size\t= xfs_efd_item_size,\n\t.iop_format\t= xfs_efd_item_format,\n\t.iop_release\t= xfs_efd_item_release,\n\t.iop_intent\t= xfs_efd_item_intent,\n};\n\n \nstatic struct xfs_efd_log_item *\nxfs_trans_get_efd(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_efi_log_item\t\t*efip,\n\tunsigned int\t\t\tnextents)\n{\n\tstruct xfs_efd_log_item\t\t*efdp;\n\n\tASSERT(nextents > 0);\n\n\tif (nextents > XFS_EFD_MAX_FAST_EXTENTS) {\n\t\tefdp = kzalloc(xfs_efd_log_item_sizeof(nextents),\n\t\t\t\tGFP_KERNEL | __GFP_NOFAIL);\n\t} else {\n\t\tefdp = kmem_cache_zalloc(xfs_efd_cache,\n\t\t\t\t\tGFP_KERNEL | __GFP_NOFAIL);\n\t}\n\n\txfs_log_item_init(tp->t_mountp, &efdp->efd_item, XFS_LI_EFD,\n\t\t\t  &xfs_efd_item_ops);\n\tefdp->efd_efip = efip;\n\tefdp->efd_format.efd_nextents = nextents;\n\tefdp->efd_format.efd_efi_id = efip->efi_format.efi_id;\n\n\txfs_trans_add_item(tp, &efdp->efd_item);\n\treturn efdp;\n}\n\n \nstatic void\nxfs_efd_from_efi(\n\tstruct xfs_efd_log_item\t*efdp)\n{\n\tstruct xfs_efi_log_item *efip = efdp->efd_efip;\n\tuint                    i;\n\n\tASSERT(efip->efi_format.efi_nextents > 0);\n\tASSERT(efdp->efd_next_extent < efip->efi_format.efi_nextents);\n\n\tfor (i = 0; i < efip->efi_format.efi_nextents; i++) {\n\t       efdp->efd_format.efd_extents[i] =\n\t\t       efip->efi_format.efi_extents[i];\n\t}\n\tefdp->efd_next_extent = efip->efi_format.efi_nextents;\n}\n\n \nstatic int\nxfs_trans_free_extent(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_efd_log_item\t\t*efdp,\n\tstruct xfs_extent_free_item\t*xefi)\n{\n\tstruct xfs_owner_info\t\toinfo = { };\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_extent\t\t*extp;\n\tuint\t\t\t\tnext_extent;\n\txfs_agblock_t\t\t\tagbno = XFS_FSB_TO_AGBNO(mp,\n\t\t\t\t\t\t\txefi->xefi_startblock);\n\tint\t\t\t\terror;\n\n\toinfo.oi_owner = xefi->xefi_owner;\n\tif (xefi->xefi_flags & XFS_EFI_ATTR_FORK)\n\t\toinfo.oi_flags |= XFS_OWNER_INFO_ATTR_FORK;\n\tif (xefi->xefi_flags & XFS_EFI_BMBT_BLOCK)\n\t\toinfo.oi_flags |= XFS_OWNER_INFO_BMBT_BLOCK;\n\n\ttrace_xfs_bmap_free_deferred(tp->t_mountp, xefi->xefi_pag->pag_agno, 0,\n\t\t\tagbno, xefi->xefi_blockcount);\n\n\terror = __xfs_free_extent(tp, xefi->xefi_pag, agbno,\n\t\t\txefi->xefi_blockcount, &oinfo, xefi->xefi_agresv,\n\t\t\txefi->xefi_flags & XFS_EFI_SKIP_DISCARD);\n\n\t \n\ttp->t_flags |= XFS_TRANS_DIRTY | XFS_TRANS_HAS_INTENT_DONE;\n\tset_bit(XFS_LI_DIRTY, &efdp->efd_item.li_flags);\n\n\t \n\tif (error == -EAGAIN) {\n\t\txfs_efd_from_efi(efdp);\n\t\treturn error;\n\t}\n\n\tnext_extent = efdp->efd_next_extent;\n\tASSERT(next_extent < efdp->efd_format.efd_nextents);\n\textp = &(efdp->efd_format.efd_extents[next_extent]);\n\textp->ext_start = xefi->xefi_startblock;\n\textp->ext_len = xefi->xefi_blockcount;\n\tefdp->efd_next_extent++;\n\n\treturn error;\n}\n\n \nstatic int\nxfs_extent_free_diff_items(\n\tvoid\t\t\t\t*priv,\n\tconst struct list_head\t\t*a,\n\tconst struct list_head\t\t*b)\n{\n\tstruct xfs_extent_free_item\t*ra;\n\tstruct xfs_extent_free_item\t*rb;\n\n\tra = container_of(a, struct xfs_extent_free_item, xefi_list);\n\trb = container_of(b, struct xfs_extent_free_item, xefi_list);\n\n\treturn ra->xefi_pag->pag_agno - rb->xefi_pag->pag_agno;\n}\n\n \nSTATIC void\nxfs_extent_free_log_item(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_efi_log_item\t\t*efip,\n\tstruct xfs_extent_free_item\t*xefi)\n{\n\tuint\t\t\t\tnext_extent;\n\tstruct xfs_extent\t\t*extp;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tset_bit(XFS_LI_DIRTY, &efip->efi_item.li_flags);\n\n\t \n\tnext_extent = atomic_inc_return(&efip->efi_next_extent) - 1;\n\tASSERT(next_extent < efip->efi_format.efi_nextents);\n\textp = &efip->efi_format.efi_extents[next_extent];\n\textp->ext_start = xefi->xefi_startblock;\n\textp->ext_len = xefi->xefi_blockcount;\n}\n\nstatic struct xfs_log_item *\nxfs_extent_free_create_intent(\n\tstruct xfs_trans\t\t*tp,\n\tstruct list_head\t\t*items,\n\tunsigned int\t\t\tcount,\n\tbool\t\t\t\tsort)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_efi_log_item\t\t*efip = xfs_efi_init(mp, count);\n\tstruct xfs_extent_free_item\t*xefi;\n\n\tASSERT(count > 0);\n\n\txfs_trans_add_item(tp, &efip->efi_item);\n\tif (sort)\n\t\tlist_sort(mp, items, xfs_extent_free_diff_items);\n\tlist_for_each_entry(xefi, items, xefi_list)\n\t\txfs_extent_free_log_item(tp, efip, xefi);\n\treturn &efip->efi_item;\n}\n\n \nstatic struct xfs_log_item *\nxfs_extent_free_create_done(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_log_item\t\t*intent,\n\tunsigned int\t\t\tcount)\n{\n\treturn &xfs_trans_get_efd(tp, EFI_ITEM(intent), count)->efd_item;\n}\n\n \nvoid\nxfs_extent_free_get_group(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_extent_free_item\t*xefi)\n{\n\txfs_agnumber_t\t\t\tagno;\n\n\tagno = XFS_FSB_TO_AGNO(mp, xefi->xefi_startblock);\n\txefi->xefi_pag = xfs_perag_intent_get(mp, agno);\n}\n\n \nstatic inline void\nxfs_extent_free_put_group(\n\tstruct xfs_extent_free_item\t*xefi)\n{\n\txfs_perag_intent_put(xefi->xefi_pag);\n}\n\n \nSTATIC int\nxfs_extent_free_finish_item(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_log_item\t\t*done,\n\tstruct list_head\t\t*item,\n\tstruct xfs_btree_cur\t\t**state)\n{\n\tstruct xfs_extent_free_item\t*xefi;\n\tint\t\t\t\terror;\n\n\txefi = container_of(item, struct xfs_extent_free_item, xefi_list);\n\n\terror = xfs_trans_free_extent(tp, EFD_ITEM(done), xefi);\n\n\t \n\tif (error == -EAGAIN)\n\t\treturn error;\n\n\txfs_extent_free_put_group(xefi);\n\tkmem_cache_free(xfs_extfree_item_cache, xefi);\n\treturn error;\n}\n\n \nSTATIC void\nxfs_extent_free_abort_intent(\n\tstruct xfs_log_item\t\t*intent)\n{\n\txfs_efi_release(EFI_ITEM(intent));\n}\n\n \nSTATIC void\nxfs_extent_free_cancel_item(\n\tstruct list_head\t\t*item)\n{\n\tstruct xfs_extent_free_item\t*xefi;\n\n\txefi = container_of(item, struct xfs_extent_free_item, xefi_list);\n\n\txfs_extent_free_put_group(xefi);\n\tkmem_cache_free(xfs_extfree_item_cache, xefi);\n}\n\nconst struct xfs_defer_op_type xfs_extent_free_defer_type = {\n\t.max_items\t= XFS_EFI_MAX_FAST_EXTENTS,\n\t.create_intent\t= xfs_extent_free_create_intent,\n\t.abort_intent\t= xfs_extent_free_abort_intent,\n\t.create_done\t= xfs_extent_free_create_done,\n\t.finish_item\t= xfs_extent_free_finish_item,\n\t.cancel_item\t= xfs_extent_free_cancel_item,\n};\n\n \nSTATIC int\nxfs_agfl_free_finish_item(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_log_item\t\t*done,\n\tstruct list_head\t\t*item,\n\tstruct xfs_btree_cur\t\t**state)\n{\n\tstruct xfs_owner_info\t\toinfo = { };\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_efd_log_item\t\t*efdp = EFD_ITEM(done);\n\tstruct xfs_extent_free_item\t*xefi;\n\tstruct xfs_extent\t\t*extp;\n\tstruct xfs_buf\t\t\t*agbp;\n\tint\t\t\t\terror;\n\txfs_agblock_t\t\t\tagbno;\n\tuint\t\t\t\tnext_extent;\n\n\txefi = container_of(item, struct xfs_extent_free_item, xefi_list);\n\tASSERT(xefi->xefi_blockcount == 1);\n\tagbno = XFS_FSB_TO_AGBNO(mp, xefi->xefi_startblock);\n\toinfo.oi_owner = xefi->xefi_owner;\n\n\ttrace_xfs_agfl_free_deferred(mp, xefi->xefi_pag->pag_agno, 0, agbno,\n\t\t\txefi->xefi_blockcount);\n\n\terror = xfs_alloc_read_agf(xefi->xefi_pag, tp, 0, &agbp);\n\tif (!error)\n\t\terror = xfs_free_agfl_block(tp, xefi->xefi_pag->pag_agno,\n\t\t\t\tagbno, agbp, &oinfo);\n\n\t \n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tset_bit(XFS_LI_DIRTY, &efdp->efd_item.li_flags);\n\n\tnext_extent = efdp->efd_next_extent;\n\tASSERT(next_extent < efdp->efd_format.efd_nextents);\n\textp = &(efdp->efd_format.efd_extents[next_extent]);\n\textp->ext_start = xefi->xefi_startblock;\n\textp->ext_len = xefi->xefi_blockcount;\n\tefdp->efd_next_extent++;\n\n\txfs_extent_free_put_group(xefi);\n\tkmem_cache_free(xfs_extfree_item_cache, xefi);\n\treturn error;\n}\n\n \nconst struct xfs_defer_op_type xfs_agfl_free_defer_type = {\n\t.max_items\t= XFS_EFI_MAX_FAST_EXTENTS,\n\t.create_intent\t= xfs_extent_free_create_intent,\n\t.abort_intent\t= xfs_extent_free_abort_intent,\n\t.create_done\t= xfs_extent_free_create_done,\n\t.finish_item\t= xfs_agfl_free_finish_item,\n\t.cancel_item\t= xfs_extent_free_cancel_item,\n};\n\n \nstatic inline bool\nxfs_efi_validate_ext(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_extent\t\t*extp)\n{\n\treturn xfs_verify_fsbext(mp, extp->ext_start, extp->ext_len);\n}\n\n \nSTATIC int\nxfs_efi_item_recover(\n\tstruct xfs_log_item\t\t*lip,\n\tstruct list_head\t\t*capture_list)\n{\n\tstruct xfs_trans_res\t\tresv;\n\tstruct xfs_efi_log_item\t\t*efip = EFI_ITEM(lip);\n\tstruct xfs_mount\t\t*mp = lip->li_log->l_mp;\n\tstruct xfs_efd_log_item\t\t*efdp;\n\tstruct xfs_trans\t\t*tp;\n\tint\t\t\t\ti;\n\tint\t\t\t\terror = 0;\n\tbool\t\t\t\trequeue_only = false;\n\n\t \n\tfor (i = 0; i < efip->efi_format.efi_nextents; i++) {\n\t\tif (!xfs_efi_validate_ext(mp,\n\t\t\t\t\t&efip->efi_format.efi_extents[i])) {\n\t\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\t\t&efip->efi_format,\n\t\t\t\t\tsizeof(efip->efi_format));\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\tresv = xlog_recover_resv(&M_RES(mp)->tr_itruncate);\n\terror = xfs_trans_alloc(mp, &resv, 0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\tefdp = xfs_trans_get_efd(tp, efip, efip->efi_format.efi_nextents);\n\n\tfor (i = 0; i < efip->efi_format.efi_nextents; i++) {\n\t\tstruct xfs_extent_free_item\tfake = {\n\t\t\t.xefi_owner\t\t= XFS_RMAP_OWN_UNKNOWN,\n\t\t\t.xefi_agresv\t\t= XFS_AG_RESV_NONE,\n\t\t};\n\t\tstruct xfs_extent\t\t*extp;\n\n\t\textp = &efip->efi_format.efi_extents[i];\n\n\t\tfake.xefi_startblock = extp->ext_start;\n\t\tfake.xefi_blockcount = extp->ext_len;\n\n\t\tif (!requeue_only) {\n\t\t\txfs_extent_free_get_group(mp, &fake);\n\t\t\terror = xfs_trans_free_extent(tp, efdp, &fake);\n\t\t\txfs_extent_free_put_group(&fake);\n\t\t}\n\n\t\t \n\t\tif (error == -EAGAIN || requeue_only) {\n\t\t\terror = xfs_free_extent_later(tp, fake.xefi_startblock,\n\t\t\t\t\tfake.xefi_blockcount,\n\t\t\t\t\t&XFS_RMAP_OINFO_ANY_OWNER,\n\t\t\t\t\tfake.xefi_agresv);\n\t\t\tif (!error) {\n\t\t\t\trequeue_only = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (error == -EFSCORRUPTED)\n\t\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\t\textp, sizeof(*extp));\n\t\tif (error)\n\t\t\tgoto abort_error;\n\n\t}\n\n\treturn xfs_defer_ops_capture_and_commit(tp, capture_list);\n\nabort_error:\n\txfs_trans_cancel(tp);\n\treturn error;\n}\n\nSTATIC bool\nxfs_efi_item_match(\n\tstruct xfs_log_item\t*lip,\n\tuint64_t\t\tintent_id)\n{\n\treturn EFI_ITEM(lip)->efi_format.efi_id == intent_id;\n}\n\n \nstatic struct xfs_log_item *\nxfs_efi_item_relog(\n\tstruct xfs_log_item\t\t*intent,\n\tstruct xfs_trans\t\t*tp)\n{\n\tstruct xfs_efd_log_item\t\t*efdp;\n\tstruct xfs_efi_log_item\t\t*efip;\n\tstruct xfs_extent\t\t*extp;\n\tunsigned int\t\t\tcount;\n\n\tcount = EFI_ITEM(intent)->efi_format.efi_nextents;\n\textp = EFI_ITEM(intent)->efi_format.efi_extents;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tefdp = xfs_trans_get_efd(tp, EFI_ITEM(intent), count);\n\tefdp->efd_next_extent = count;\n\tmemcpy(efdp->efd_format.efd_extents, extp, count * sizeof(*extp));\n\tset_bit(XFS_LI_DIRTY, &efdp->efd_item.li_flags);\n\n\tefip = xfs_efi_init(tp->t_mountp, count);\n\tmemcpy(efip->efi_format.efi_extents, extp, count * sizeof(*extp));\n\tatomic_set(&efip->efi_next_extent, count);\n\txfs_trans_add_item(tp, &efip->efi_item);\n\tset_bit(XFS_LI_DIRTY, &efip->efi_item.li_flags);\n\treturn &efip->efi_item;\n}\n\nstatic const struct xfs_item_ops xfs_efi_item_ops = {\n\t.flags\t\t= XFS_ITEM_INTENT,\n\t.iop_size\t= xfs_efi_item_size,\n\t.iop_format\t= xfs_efi_item_format,\n\t.iop_unpin\t= xfs_efi_item_unpin,\n\t.iop_release\t= xfs_efi_item_release,\n\t.iop_recover\t= xfs_efi_item_recover,\n\t.iop_match\t= xfs_efi_item_match,\n\t.iop_relog\t= xfs_efi_item_relog,\n};\n\n \nSTATIC int\nxlog_recover_efi_commit_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tlsn)\n{\n\tstruct xfs_mount\t\t*mp = log->l_mp;\n\tstruct xfs_efi_log_item\t\t*efip;\n\tstruct xfs_efi_log_format\t*efi_formatp;\n\tint\t\t\t\terror;\n\n\tefi_formatp = item->ri_buf[0].i_addr;\n\n\tif (item->ri_buf[0].i_len < xfs_efi_log_format_sizeof(0)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\titem->ri_buf[0].i_addr, item->ri_buf[0].i_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tefip = xfs_efi_init(mp, efi_formatp->efi_nextents);\n\terror = xfs_efi_copy_format(&item->ri_buf[0], &efip->efi_format);\n\tif (error) {\n\t\txfs_efi_item_free(efip);\n\t\treturn error;\n\t}\n\tatomic_set(&efip->efi_next_extent, efi_formatp->efi_nextents);\n\t \n\txfs_trans_ail_insert(log->l_ailp, &efip->efi_item, lsn);\n\txfs_efi_release(efip);\n\treturn 0;\n}\n\nconst struct xlog_recover_item_ops xlog_efi_item_ops = {\n\t.item_type\t\t= XFS_LI_EFI,\n\t.commit_pass2\t\t= xlog_recover_efi_commit_pass2,\n};\n\n \nSTATIC int\nxlog_recover_efd_commit_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tlsn)\n{\n\tstruct xfs_efd_log_format\t*efd_formatp;\n\tint\t\t\t\tbuflen = item->ri_buf[0].i_len;\n\n\tefd_formatp = item->ri_buf[0].i_addr;\n\n\tif (buflen < sizeof(struct xfs_efd_log_format)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, log->l_mp,\n\t\t\t\tefd_formatp, buflen);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (item->ri_buf[0].i_len != xfs_efd_log_format32_sizeof(\n\t\t\t\t\t\tefd_formatp->efd_nextents) &&\n\t    item->ri_buf[0].i_len != xfs_efd_log_format64_sizeof(\n\t\t\t\t\t\tefd_formatp->efd_nextents)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, log->l_mp,\n\t\t\t\tefd_formatp, buflen);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\txlog_recover_release_intent(log, XFS_LI_EFI, efd_formatp->efd_efi_id);\n\treturn 0;\n}\n\nconst struct xlog_recover_item_ops xlog_efd_item_ops = {\n\t.item_type\t\t= XFS_LI_EFD,\n\t.commit_pass2\t\t= xlog_recover_efd_commit_pass2,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}