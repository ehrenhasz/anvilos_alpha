{
  "module_name": "xfs_reflink.c",
  "hash_id": "92d64fed54a1b638a3d98e69f9d6097fce2f612e46825fd768404b2dec751415",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_reflink.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_refcount_btree.h\"\n#include \"xfs_refcount.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_reflink.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_ag_resv.h\"\n\n \n\n \nstatic int\nxfs_reflink_find_shared(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\txfs_agblock_t\t\tagbno,\n\txfs_extlen_t\t\taglen,\n\txfs_agblock_t\t\t*fbno,\n\txfs_extlen_t\t\t*flen,\n\tbool\t\t\tfind_end_of_shared)\n{\n\tstruct xfs_buf\t\t*agbp;\n\tstruct xfs_btree_cur\t*cur;\n\tint\t\t\terror;\n\n\terror = xfs_alloc_read_agf(pag, tp, 0, &agbp);\n\tif (error)\n\t\treturn error;\n\n\tcur = xfs_refcountbt_init_cursor(pag->pag_mount, tp, agbp, pag);\n\n\terror = xfs_refcount_find_shared(cur, agbno, aglen, fbno, flen,\n\t\t\tfind_end_of_shared);\n\n\txfs_btree_del_cursor(cur, error);\n\n\txfs_trans_brelse(tp, agbp);\n\treturn error;\n}\n\n \nint\nxfs_reflink_trim_around_shared(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_bmbt_irec\t*irec,\n\tbool\t\t\t*shared)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_perag\t*pag;\n\txfs_agblock_t\t\tagbno;\n\txfs_extlen_t\t\taglen;\n\txfs_agblock_t\t\tfbno;\n\txfs_extlen_t\t\tflen;\n\tint\t\t\terror = 0;\n\n\t \n\tif (!xfs_is_cow_inode(ip) || !xfs_bmap_is_written_extent(irec)) {\n\t\t*shared = false;\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_reflink_trim_around_shared(ip, irec);\n\n\tpag = xfs_perag_get(mp, XFS_FSB_TO_AGNO(mp, irec->br_startblock));\n\tagbno = XFS_FSB_TO_AGBNO(mp, irec->br_startblock);\n\taglen = irec->br_blockcount;\n\n\terror = xfs_reflink_find_shared(pag, NULL, agbno, aglen, &fbno, &flen,\n\t\t\ttrue);\n\txfs_perag_put(pag);\n\tif (error)\n\t\treturn error;\n\n\t*shared = false;\n\tif (fbno == NULLAGBLOCK) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (fbno == agbno) {\n\t\t \n\t\tirec->br_blockcount = flen;\n\t\t*shared = true;\n\t\treturn 0;\n\t}\n\n\t \n\tirec->br_blockcount = fbno - agbno;\n\treturn 0;\n}\n\nint\nxfs_bmap_trim_cow(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_bmbt_irec\t*imap,\n\tbool\t\t\t*shared)\n{\n\t \n\tif (xfs_is_always_cow_inode(ip) &&\n\t    !isnullstartblock(imap->br_startblock)) {\n\t\t*shared = true;\n\t\treturn 0;\n\t}\n\n\t \n\treturn xfs_reflink_trim_around_shared(ip, imap, shared);\n}\n\nstatic int\nxfs_reflink_convert_cow_locked(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\toffset_fsb,\n\txfs_filblks_t\t\tcount_fsb)\n{\n\tstruct xfs_iext_cursor\ticur;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_btree_cur\t*dummy_cur = NULL;\n\tint\t\t\tdummy_logflags;\n\tint\t\t\terror = 0;\n\n\tif (!xfs_iext_lookup_extent(ip, ip->i_cowfp, offset_fsb, &icur, &got))\n\t\treturn 0;\n\n\tdo {\n\t\tif (got.br_startoff >= offset_fsb + count_fsb)\n\t\t\tbreak;\n\t\tif (got.br_state == XFS_EXT_NORM)\n\t\t\tcontinue;\n\t\tif (WARN_ON_ONCE(isnullstartblock(got.br_startblock)))\n\t\t\treturn -EIO;\n\n\t\txfs_trim_extent(&got, offset_fsb, count_fsb);\n\t\tif (!got.br_blockcount)\n\t\t\tcontinue;\n\n\t\tgot.br_state = XFS_EXT_NORM;\n\t\terror = xfs_bmap_add_extent_unwritten_real(NULL, ip,\n\t\t\t\tXFS_COW_FORK, &icur, &dummy_cur, &got,\n\t\t\t\t&dummy_logflags);\n\t\tif (error)\n\t\t\treturn error;\n\t} while (xfs_iext_next_extent(ip->i_cowfp, &icur, &got));\n\n\treturn error;\n}\n\n \nint\nxfs_reflink_convert_cow(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tcount)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\txfs_fileoff_t\t\tend_fsb = XFS_B_TO_FSB(mp, offset + count);\n\txfs_filblks_t\t\tcount_fsb = end_fsb - offset_fsb;\n\tint\t\t\terror;\n\n\tASSERT(count != 0);\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_reflink_convert_cow_locked(ip, offset_fsb, count_fsb);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\n \nstatic int\nxfs_find_trim_cow_extent(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_bmbt_irec\t*imap,\n\tstruct xfs_bmbt_irec\t*cmap,\n\tbool\t\t\t*shared,\n\tbool\t\t\t*found)\n{\n\txfs_fileoff_t\t\toffset_fsb = imap->br_startoff;\n\txfs_filblks_t\t\tcount_fsb = imap->br_blockcount;\n\tstruct xfs_iext_cursor\ticur;\n\n\t*found = false;\n\n\t \n\tif (!xfs_iext_lookup_extent(ip, ip->i_cowfp, offset_fsb, &icur, cmap))\n\t\tcmap->br_startoff = offset_fsb + count_fsb;\n\tif (cmap->br_startoff > offset_fsb) {\n\t\txfs_trim_extent(imap, imap->br_startoff,\n\t\t\t\tcmap->br_startoff - imap->br_startoff);\n\t\treturn xfs_bmap_trim_cow(ip, imap, shared);\n\t}\n\n\t*shared = true;\n\tif (isnullstartblock(cmap->br_startblock)) {\n\t\txfs_trim_extent(imap, cmap->br_startoff, cmap->br_blockcount);\n\t\treturn 0;\n\t}\n\n\t \n\txfs_trim_extent(cmap, offset_fsb, count_fsb);\n\t*found = true;\n\treturn 0;\n}\n\nstatic int\nxfs_reflink_convert_unwritten(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_bmbt_irec\t*imap,\n\tstruct xfs_bmbt_irec\t*cmap,\n\tbool\t\t\tconvert_now)\n{\n\txfs_fileoff_t\t\toffset_fsb = imap->br_startoff;\n\txfs_filblks_t\t\tcount_fsb = imap->br_blockcount;\n\tint\t\t\terror;\n\n\t \n\txfs_trim_extent(cmap, offset_fsb, count_fsb);\n\n\t \n\tif (!convert_now || cmap->br_state == XFS_EXT_NORM)\n\t\treturn 0;\n\n\ttrace_xfs_reflink_convert_cow(ip, cmap);\n\n\terror = xfs_reflink_convert_cow_locked(ip, offset_fsb, count_fsb);\n\tif (!error)\n\t\tcmap->br_state = XFS_EXT_NORM;\n\n\treturn error;\n}\n\nstatic int\nxfs_reflink_fill_cow_hole(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_bmbt_irec\t*imap,\n\tstruct xfs_bmbt_irec\t*cmap,\n\tbool\t\t\t*shared,\n\tuint\t\t\t*lockmode,\n\tbool\t\t\tconvert_now)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\txfs_filblks_t\t\tresaligned;\n\txfs_extlen_t\t\tresblks;\n\tint\t\t\tnimaps;\n\tint\t\t\terror;\n\tbool\t\t\tfound;\n\n\tresaligned = xfs_aligned_fsb_count(imap->br_startoff,\n\t\timap->br_blockcount, xfs_get_cowextsz_hint(ip));\n\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, resaligned);\n\n\txfs_iunlock(ip, *lockmode);\n\t*lockmode = 0;\n\n\terror = xfs_trans_alloc_inode(ip, &M_RES(mp)->tr_write, resblks, 0,\n\t\t\tfalse, &tp);\n\tif (error)\n\t\treturn error;\n\n\t*lockmode = XFS_ILOCK_EXCL;\n\n\terror = xfs_find_trim_cow_extent(ip, imap, cmap, shared, &found);\n\tif (error || !*shared)\n\t\tgoto out_trans_cancel;\n\n\tif (found) {\n\t\txfs_trans_cancel(tp);\n\t\tgoto convert;\n\t}\n\n\t \n\tnimaps = 1;\n\terror = xfs_bmapi_write(tp, ip, imap->br_startoff, imap->br_blockcount,\n\t\t\tXFS_BMAPI_COWFORK | XFS_BMAPI_PREALLOC, 0, cmap,\n\t\t\t&nimaps);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\txfs_inode_set_cowblocks_tag(ip);\n\terror = xfs_trans_commit(tp);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (nimaps == 0)\n\t\treturn -ENOSPC;\n\nconvert:\n\treturn xfs_reflink_convert_unwritten(ip, imap, cmap, convert_now);\n\nout_trans_cancel:\n\txfs_trans_cancel(tp);\n\treturn error;\n}\n\nstatic int\nxfs_reflink_fill_delalloc(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_bmbt_irec\t*imap,\n\tstruct xfs_bmbt_irec\t*cmap,\n\tbool\t\t\t*shared,\n\tuint\t\t\t*lockmode,\n\tbool\t\t\tconvert_now)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\tnimaps;\n\tint\t\t\terror;\n\tbool\t\t\tfound;\n\n\tdo {\n\t\txfs_iunlock(ip, *lockmode);\n\t\t*lockmode = 0;\n\n\t\terror = xfs_trans_alloc_inode(ip, &M_RES(mp)->tr_write, 0, 0,\n\t\t\t\tfalse, &tp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t*lockmode = XFS_ILOCK_EXCL;\n\n\t\terror = xfs_find_trim_cow_extent(ip, imap, cmap, shared,\n\t\t\t\t&found);\n\t\tif (error || !*shared)\n\t\t\tgoto out_trans_cancel;\n\n\t\tif (found) {\n\t\t\txfs_trans_cancel(tp);\n\t\t\tbreak;\n\t\t}\n\n\t\tASSERT(isnullstartblock(cmap->br_startblock) ||\n\t\t       cmap->br_startblock == DELAYSTARTBLOCK);\n\n\t\t \n\t\tnimaps = 1;\n\t\terror = xfs_bmapi_write(tp, ip, cmap->br_startoff,\n\t\t\t\tcmap->br_blockcount,\n\t\t\t\tXFS_BMAPI_COWFORK | XFS_BMAPI_PREALLOC, 0,\n\t\t\t\tcmap, &nimaps);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\txfs_inode_set_cowblocks_tag(ip);\n\t\terror = xfs_trans_commit(tp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tif (nimaps == 0)\n\t\t\treturn -ENOSPC;\n\t} while (cmap->br_startoff + cmap->br_blockcount <= imap->br_startoff);\n\n\treturn xfs_reflink_convert_unwritten(ip, imap, cmap, convert_now);\n\nout_trans_cancel:\n\txfs_trans_cancel(tp);\n\treturn error;\n}\n\n \nint\nxfs_reflink_allocate_cow(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_bmbt_irec\t*imap,\n\tstruct xfs_bmbt_irec\t*cmap,\n\tbool\t\t\t*shared,\n\tuint\t\t\t*lockmode,\n\tbool\t\t\tconvert_now)\n{\n\tint\t\t\terror;\n\tbool\t\t\tfound;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (!ip->i_cowfp) {\n\t\tASSERT(!xfs_is_reflink_inode(ip));\n\t\txfs_ifork_init_cow(ip);\n\t}\n\n\terror = xfs_find_trim_cow_extent(ip, imap, cmap, shared, &found);\n\tif (error || !*shared)\n\t\treturn error;\n\n\t \n\tif (found)\n\t\treturn xfs_reflink_convert_unwritten(ip, imap, cmap,\n\t\t\t\tconvert_now);\n\n\t \n\tif (cmap->br_startoff > imap->br_startoff)\n\t\treturn xfs_reflink_fill_cow_hole(ip, imap, cmap, shared,\n\t\t\t\tlockmode, convert_now);\n\n\t \n\tif (isnullstartblock(cmap->br_startblock) ||\n\t    cmap->br_startblock == DELAYSTARTBLOCK)\n\t\treturn xfs_reflink_fill_delalloc(ip, imap, cmap, shared,\n\t\t\t\tlockmode, convert_now);\n\n\t \n\tASSERT(0);\n\treturn -EFSCORRUPTED;\n}\n\n \nint\nxfs_reflink_cancel_cow_blocks(\n\tstruct xfs_inode\t\t*ip,\n\tstruct xfs_trans\t\t**tpp,\n\txfs_fileoff_t\t\t\toffset_fsb,\n\txfs_fileoff_t\t\t\tend_fsb,\n\tbool\t\t\t\tcancel_real)\n{\n\tstruct xfs_ifork\t\t*ifp = xfs_ifork_ptr(ip, XFS_COW_FORK);\n\tstruct xfs_bmbt_irec\t\tgot, del;\n\tstruct xfs_iext_cursor\t\ticur;\n\tint\t\t\t\terror = 0;\n\n\tif (!xfs_inode_has_cow_data(ip))\n\t\treturn 0;\n\tif (!xfs_iext_lookup_extent_before(ip, ifp, &end_fsb, &icur, &got))\n\t\treturn 0;\n\n\t \n\twhile (got.br_startoff + got.br_blockcount > offset_fsb) {\n\t\tdel = got;\n\t\txfs_trim_extent(&del, offset_fsb, end_fsb - offset_fsb);\n\n\t\t \n\t\tif (!del.br_blockcount) {\n\t\t\txfs_iext_prev(ifp, &icur);\n\t\t\tgoto next_extent;\n\t\t}\n\n\t\ttrace_xfs_reflink_cancel_cow(ip, &del);\n\n\t\tif (isnullstartblock(del.br_startblock)) {\n\t\t\terror = xfs_bmap_del_extent_delay(ip, XFS_COW_FORK,\n\t\t\t\t\t&icur, &got, &del);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t} else if (del.br_state == XFS_EXT_UNWRITTEN || cancel_real) {\n\t\t\tASSERT((*tpp)->t_highest_agno == NULLAGNUMBER);\n\n\t\t\t \n\t\t\txfs_refcount_free_cow_extent(*tpp, del.br_startblock,\n\t\t\t\t\tdel.br_blockcount);\n\n\t\t\terror = xfs_free_extent_later(*tpp, del.br_startblock,\n\t\t\t\t\tdel.br_blockcount, NULL,\n\t\t\t\t\tXFS_AG_RESV_NONE);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\terror = xfs_defer_finish(tpp);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\txfs_bmap_del_extent_cow(ip, &icur, &got, &del);\n\n\t\t\t \n\t\t\terror = xfs_quota_unreserve_blkres(ip,\n\t\t\t\t\tdel.br_blockcount);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\txfs_iext_prev(ifp, &icur);\n\t\t}\nnext_extent:\n\t\tif (!xfs_iext_get_extent(ifp, &icur, &got))\n\t\t\tbreak;\n\t}\n\n\t \n\tif (!ifp->if_bytes)\n\t\txfs_inode_clear_cowblocks_tag(ip);\n\treturn error;\n}\n\n \nint\nxfs_reflink_cancel_cow_range(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tcount,\n\tbool\t\t\tcancel_real)\n{\n\tstruct xfs_trans\t*tp;\n\txfs_fileoff_t\t\toffset_fsb;\n\txfs_fileoff_t\t\tend_fsb;\n\tint\t\t\terror;\n\n\ttrace_xfs_reflink_cancel_cow_range(ip, offset, count);\n\tASSERT(ip->i_cowfp);\n\n\toffset_fsb = XFS_B_TO_FSBT(ip->i_mount, offset);\n\tif (count == NULLFILEOFF)\n\t\tend_fsb = NULLFILEOFF;\n\telse\n\t\tend_fsb = XFS_B_TO_FSB(ip->i_mount, offset + count);\n\n\t \n\terror = xfs_trans_alloc(ip->i_mount, &M_RES(ip->i_mount)->tr_write,\n\t\t\t0, 0, 0, &tp);\n\tif (error)\n\t\tgoto out;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t \n\terror = xfs_reflink_cancel_cow_blocks(ip, &tp, offset_fsb, end_fsb,\n\t\t\tcancel_real);\n\tif (error)\n\t\tgoto out_cancel;\n\n\terror = xfs_trans_commit(tp);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n\nout_cancel:\n\txfs_trans_cancel(tp);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\nout:\n\ttrace_xfs_reflink_cancel_cow_range_error(ip, error, _RET_IP_);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_reflink_end_cow_extent(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\t*offset_fsb,\n\txfs_fileoff_t\t\tend_fsb)\n{\n\tstruct xfs_iext_cursor\ticur;\n\tstruct xfs_bmbt_irec\tgot, del, data;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, XFS_COW_FORK);\n\tunsigned int\t\tresblks;\n\tint\t\t\tnmaps;\n\tint\t\t\terror;\n\n\t \n\tif (ifp->if_bytes == 0) {\n\t\t*offset_fsb = end_fsb;\n\t\treturn 0;\n\t}\n\n\tresblks = XFS_EXTENTADD_SPACE_RES(mp, XFS_DATA_FORK);\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_write, resblks, 0,\n\t\t\tXFS_TRANS_RESERVE, &tp);\n\tif (error)\n\t\treturn error;\n\n\t \n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\terror = xfs_iext_count_may_overflow(ip, XFS_DATA_FORK,\n\t\t\tXFS_IEXT_REFLINK_END_COW_CNT);\n\tif (error == -EFBIG)\n\t\terror = xfs_iext_count_upgrade(tp, ip,\n\t\t\t\tXFS_IEXT_REFLINK_END_COW_CNT);\n\tif (error)\n\t\tgoto out_cancel;\n\n\t \n\tif (!xfs_iext_lookup_extent(ip, ifp, *offset_fsb, &icur, &got) ||\n\t    got.br_startoff >= end_fsb) {\n\t\t*offset_fsb = end_fsb;\n\t\tgoto out_cancel;\n\t}\n\n\t \n\twhile (!xfs_bmap_is_written_extent(&got)) {\n\t\tif (!xfs_iext_next_extent(ifp, &icur, &got) ||\n\t\t    got.br_startoff >= end_fsb) {\n\t\t\t*offset_fsb = end_fsb;\n\t\t\tgoto out_cancel;\n\t\t}\n\t}\n\tdel = got;\n\n\t \n\tnmaps = 1;\n\terror = xfs_bmapi_read(ip, del.br_startoff, del.br_blockcount, &data,\n\t\t\t&nmaps, 0);\n\tif (error)\n\t\tgoto out_cancel;\n\n\t \n\tdata.br_blockcount = min(data.br_blockcount, del.br_blockcount);\n\tdel.br_blockcount = data.br_blockcount;\n\n\ttrace_xfs_reflink_cow_remap_from(ip, &del);\n\ttrace_xfs_reflink_cow_remap_to(ip, &data);\n\n\tif (xfs_bmap_is_real_extent(&data)) {\n\t\t \n\t\txfs_bmap_unmap_extent(tp, ip, &data);\n\t\txfs_refcount_decrease_extent(tp, &data);\n\t\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT,\n\t\t\t\t-data.br_blockcount);\n\t} else if (data.br_startblock == DELAYSTARTBLOCK) {\n\t\tint\t\tdone;\n\n\t\t \n\t\terror = xfs_bunmapi(NULL, ip, data.br_startoff,\n\t\t\t\tdata.br_blockcount, 0, 1, &done);\n\t\tif (error)\n\t\t\tgoto out_cancel;\n\t\tASSERT(done);\n\t}\n\n\t \n\txfs_refcount_free_cow_extent(tp, del.br_startblock, del.br_blockcount);\n\n\t \n\txfs_bmap_map_extent(tp, ip, &del);\n\n\t \n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_DELBCOUNT,\n\t\t\t(long)del.br_blockcount);\n\n\t \n\txfs_bmap_del_extent_cow(ip, &icur, &got, &del);\n\n\terror = xfs_trans_commit(tp);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tif (error)\n\t\treturn error;\n\n\t \n\t*offset_fsb = del.br_startoff + del.br_blockcount;\n\treturn 0;\n\nout_cancel:\n\txfs_trans_cancel(tp);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\n \nint\nxfs_reflink_end_cow(\n\tstruct xfs_inode\t\t*ip,\n\txfs_off_t\t\t\toffset,\n\txfs_off_t\t\t\tcount)\n{\n\txfs_fileoff_t\t\t\toffset_fsb;\n\txfs_fileoff_t\t\t\tend_fsb;\n\tint\t\t\t\terror = 0;\n\n\ttrace_xfs_reflink_end_cow(ip, offset, count);\n\n\toffset_fsb = XFS_B_TO_FSBT(ip->i_mount, offset);\n\tend_fsb = XFS_B_TO_FSB(ip->i_mount, offset + count);\n\n\t \n\twhile (end_fsb > offset_fsb && !error)\n\t\terror = xfs_reflink_end_cow_extent(ip, &offset_fsb, end_fsb);\n\n\tif (error)\n\t\ttrace_xfs_reflink_end_cow_error(ip, error, _RET_IP_);\n\treturn error;\n}\n\n \nint\nxfs_reflink_recover_cow(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_perag\t*pag;\n\txfs_agnumber_t\t\tagno;\n\tint\t\t\terror = 0;\n\n\tif (!xfs_has_reflink(mp))\n\t\treturn 0;\n\n\tfor_each_perag(mp, agno, pag) {\n\t\terror = xfs_refcount_recover_cow_leftovers(mp, pag);\n\t\tif (error) {\n\t\t\txfs_perag_rele(pag);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn error;\n}\n\n \n\n \nSTATIC int\nxfs_reflink_set_inode_flag(\n\tstruct xfs_inode\t*src,\n\tstruct xfs_inode\t*dest)\n{\n\tstruct xfs_mount\t*mp = src->i_mount;\n\tint\t\t\terror;\n\tstruct xfs_trans\t*tp;\n\n\tif (xfs_is_reflink_inode(src) && xfs_is_reflink_inode(dest))\n\t\treturn 0;\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_ichange, 0, 0, 0, &tp);\n\tif (error)\n\t\tgoto out_error;\n\n\t \n\tif (src->i_ino == dest->i_ino)\n\t\txfs_ilock(src, XFS_ILOCK_EXCL);\n\telse\n\t\txfs_lock_two_inodes(src, XFS_ILOCK_EXCL, dest, XFS_ILOCK_EXCL);\n\n\tif (!xfs_is_reflink_inode(src)) {\n\t\ttrace_xfs_reflink_set_inode_flag(src);\n\t\txfs_trans_ijoin(tp, src, XFS_ILOCK_EXCL);\n\t\tsrc->i_diflags2 |= XFS_DIFLAG2_REFLINK;\n\t\txfs_trans_log_inode(tp, src, XFS_ILOG_CORE);\n\t\txfs_ifork_init_cow(src);\n\t} else\n\t\txfs_iunlock(src, XFS_ILOCK_EXCL);\n\n\tif (src->i_ino == dest->i_ino)\n\t\tgoto commit_flags;\n\n\tif (!xfs_is_reflink_inode(dest)) {\n\t\ttrace_xfs_reflink_set_inode_flag(dest);\n\t\txfs_trans_ijoin(tp, dest, XFS_ILOCK_EXCL);\n\t\tdest->i_diflags2 |= XFS_DIFLAG2_REFLINK;\n\t\txfs_trans_log_inode(tp, dest, XFS_ILOG_CORE);\n\t\txfs_ifork_init_cow(dest);\n\t} else\n\t\txfs_iunlock(dest, XFS_ILOCK_EXCL);\n\ncommit_flags:\n\terror = xfs_trans_commit(tp);\n\tif (error)\n\t\tgoto out_error;\n\treturn error;\n\nout_error:\n\ttrace_xfs_reflink_set_inode_flag_error(dest, error, _RET_IP_);\n\treturn error;\n}\n\n \nint\nxfs_reflink_update_dest(\n\tstruct xfs_inode\t*dest,\n\txfs_off_t\t\tnewlen,\n\txfs_extlen_t\t\tcowextsize,\n\tunsigned int\t\tremap_flags)\n{\n\tstruct xfs_mount\t*mp = dest->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\tif (newlen <= i_size_read(VFS_I(dest)) && cowextsize == 0)\n\t\treturn 0;\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_ichange, 0, 0, 0, &tp);\n\tif (error)\n\t\tgoto out_error;\n\n\txfs_ilock(dest, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, dest, XFS_ILOCK_EXCL);\n\n\tif (newlen > i_size_read(VFS_I(dest))) {\n\t\ttrace_xfs_reflink_update_inode_size(dest, newlen);\n\t\ti_size_write(VFS_I(dest), newlen);\n\t\tdest->i_disk_size = newlen;\n\t}\n\n\tif (cowextsize) {\n\t\tdest->i_cowextsize = cowextsize;\n\t\tdest->i_diflags2 |= XFS_DIFLAG2_COWEXTSIZE;\n\t}\n\n\txfs_trans_log_inode(tp, dest, XFS_ILOG_CORE);\n\n\terror = xfs_trans_commit(tp);\n\tif (error)\n\t\tgoto out_error;\n\treturn error;\n\nout_error:\n\ttrace_xfs_reflink_update_inode_size_error(dest, error, _RET_IP_);\n\treturn error;\n}\n\n \nstatic int\nxfs_reflink_ag_has_free_space(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\n\tif (!xfs_has_rmapbt(mp))\n\t\treturn 0;\n\n\tpag = xfs_perag_get(mp, agno);\n\tif (xfs_ag_resv_critical(pag, XFS_AG_RESV_RMAPBT) ||\n\t    xfs_ag_resv_critical(pag, XFS_AG_RESV_METADATA))\n\t\terror = -ENOSPC;\n\txfs_perag_put(pag);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_reflink_remap_extent(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_bmbt_irec\t*dmap,\n\txfs_off_t\t\tnew_isize)\n{\n\tstruct xfs_bmbt_irec\tsmap;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\txfs_off_t\t\tnewlen;\n\tint64_t\t\t\tqdelta = 0;\n\tunsigned int\t\tresblks;\n\tbool\t\t\tquota_reserved = true;\n\tbool\t\t\tsmap_real;\n\tbool\t\t\tdmap_written = xfs_bmap_is_written_extent(dmap);\n\tint\t\t\tiext_delta = 0;\n\tint\t\t\tnimaps;\n\tint\t\t\terror;\n\n\t \n\tresblks = XFS_EXTENTADD_SPACE_RES(mp, XFS_DATA_FORK);\n\terror = xfs_trans_alloc_inode(ip, &M_RES(mp)->tr_write,\n\t\t\tresblks + dmap->br_blockcount, 0, false, &tp);\n\tif (error == -EDQUOT || error == -ENOSPC) {\n\t\tquota_reserved = false;\n\t\terror = xfs_trans_alloc_inode(ip, &M_RES(mp)->tr_write,\n\t\t\t\tresblks, 0, false, &tp);\n\t}\n\tif (error)\n\t\tgoto out;\n\n\t \n\tnimaps = 1;\n\terror = xfs_bmapi_read(ip, dmap->br_startoff, dmap->br_blockcount,\n\t\t\t&smap, &nimaps, 0);\n\tif (error)\n\t\tgoto out_cancel;\n\tASSERT(nimaps == 1 && smap.br_startoff == dmap->br_startoff);\n\tsmap_real = xfs_bmap_is_real_extent(&smap);\n\n\t \n\tdmap->br_blockcount = min(dmap->br_blockcount, smap.br_blockcount);\n\tASSERT(dmap->br_blockcount == smap.br_blockcount);\n\n\ttrace_xfs_reflink_remap_extent_dest(ip, &smap);\n\n\t \n\tif (dmap->br_startblock == smap.br_startblock) {\n\t\tif (dmap->br_state != smap.br_state)\n\t\t\terror = -EFSCORRUPTED;\n\t\tgoto out_cancel;\n\t}\n\n\t \n\tif (dmap->br_state == XFS_EXT_UNWRITTEN &&\n\t    smap.br_state == XFS_EXT_UNWRITTEN)\n\t\tgoto out_cancel;\n\n\t \n\tif (dmap_written) {\n\t\terror = xfs_reflink_ag_has_free_space(mp,\n\t\t\t\tXFS_FSB_TO_AGNO(mp, dmap->br_startblock));\n\t\tif (error)\n\t\t\tgoto out_cancel;\n\t}\n\n\t \n\tif (!quota_reserved && !smap_real && dmap_written) {\n\t\terror = xfs_trans_reserve_quota_nblks(tp, ip,\n\t\t\t\tdmap->br_blockcount, 0, false);\n\t\tif (error)\n\t\t\tgoto out_cancel;\n\t}\n\n\tif (smap_real)\n\t\t++iext_delta;\n\n\tif (dmap_written)\n\t\t++iext_delta;\n\n\terror = xfs_iext_count_may_overflow(ip, XFS_DATA_FORK, iext_delta);\n\tif (error == -EFBIG)\n\t\terror = xfs_iext_count_upgrade(tp, ip, iext_delta);\n\tif (error)\n\t\tgoto out_cancel;\n\n\tif (smap_real) {\n\t\t \n\t\txfs_bmap_unmap_extent(tp, ip, &smap);\n\t\txfs_refcount_decrease_extent(tp, &smap);\n\t\tqdelta -= smap.br_blockcount;\n\t} else if (smap.br_startblock == DELAYSTARTBLOCK) {\n\t\tint\t\tdone;\n\n\t\t \n\t\terror = xfs_bunmapi(NULL, ip, smap.br_startoff,\n\t\t\t\tsmap.br_blockcount, 0, 1, &done);\n\t\tif (error)\n\t\t\tgoto out_cancel;\n\t\tASSERT(done);\n\t}\n\n\t \n\tif (dmap_written) {\n\t\txfs_refcount_increase_extent(tp, dmap);\n\t\txfs_bmap_map_extent(tp, ip, dmap);\n\t\tqdelta += dmap->br_blockcount;\n\t}\n\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, qdelta);\n\n\t \n\tnewlen = XFS_FSB_TO_B(mp, dmap->br_startoff + dmap->br_blockcount);\n\tnewlen = min_t(xfs_off_t, newlen, new_isize);\n\tif (newlen > i_size_read(VFS_I(ip))) {\n\t\ttrace_xfs_reflink_update_inode_size(ip, newlen);\n\t\ti_size_write(VFS_I(ip), newlen);\n\t\tip->i_disk_size = newlen;\n\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t}\n\n\t \n\terror = xfs_trans_commit(tp);\n\tgoto out_unlock;\n\nout_cancel:\n\txfs_trans_cancel(tp);\nout_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\nout:\n\tif (error)\n\t\ttrace_xfs_reflink_remap_extent_error(ip, error, _RET_IP_);\n\treturn error;\n}\n\n \nint\nxfs_reflink_remap_blocks(\n\tstruct xfs_inode\t*src,\n\tloff_t\t\t\tpos_in,\n\tstruct xfs_inode\t*dest,\n\tloff_t\t\t\tpos_out,\n\tloff_t\t\t\tremap_len,\n\tloff_t\t\t\t*remapped)\n{\n\tstruct xfs_bmbt_irec\timap;\n\tstruct xfs_mount\t*mp = src->i_mount;\n\txfs_fileoff_t\t\tsrcoff = XFS_B_TO_FSBT(mp, pos_in);\n\txfs_fileoff_t\t\tdestoff = XFS_B_TO_FSBT(mp, pos_out);\n\txfs_filblks_t\t\tlen;\n\txfs_filblks_t\t\tremapped_len = 0;\n\txfs_off_t\t\tnew_isize = pos_out + remap_len;\n\tint\t\t\tnimaps;\n\tint\t\t\terror = 0;\n\n\tlen = min_t(xfs_filblks_t, XFS_B_TO_FSB(mp, remap_len),\n\t\t\tXFS_MAX_FILEOFF);\n\n\ttrace_xfs_reflink_remap_blocks(src, srcoff, len, dest, destoff);\n\n\twhile (len > 0) {\n\t\tunsigned int\tlock_mode;\n\n\t\t \n\t\tnimaps = 1;\n\t\tlock_mode = xfs_ilock_data_map_shared(src);\n\t\terror = xfs_bmapi_read(src, srcoff, len, &imap, &nimaps, 0);\n\t\txfs_iunlock(src, lock_mode);\n\t\tif (error)\n\t\t\tbreak;\n\t\t \n\t\tASSERT(nimaps == 1 && imap.br_startoff == srcoff);\n\t\tif (imap.br_startblock == DELAYSTARTBLOCK) {\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tbreak;\n\t\t}\n\n\t\ttrace_xfs_reflink_remap_extent_src(src, &imap);\n\n\t\t \n\t\timap.br_startoff = destoff;\n\t\terror = xfs_reflink_remap_extent(dest, &imap, new_isize);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tsrcoff += imap.br_blockcount;\n\t\tdestoff += imap.br_blockcount;\n\t\tlen -= imap.br_blockcount;\n\t\tremapped_len += imap.br_blockcount;\n\t}\n\n\tif (error)\n\t\ttrace_xfs_reflink_remap_blocks_error(dest, error, _RET_IP_);\n\t*remapped = min_t(loff_t, remap_len,\n\t\t\t  XFS_FSB_TO_B(src->i_mount, remapped_len));\n\treturn error;\n}\n\n \nstatic int\nxfs_reflink_zero_posteof(\n\tstruct xfs_inode\t*ip,\n\tloff_t\t\t\tpos)\n{\n\tloff_t\t\t\tisize = i_size_read(VFS_I(ip));\n\n\tif (pos <= isize)\n\t\treturn 0;\n\n\ttrace_xfs_zero_eof(ip, isize, pos - isize);\n\treturn xfs_zero_range(ip, isize, pos - isize, NULL);\n}\n\n \nint\nxfs_reflink_remap_prep(\n\tstruct file\t\t*file_in,\n\tloff_t\t\t\tpos_in,\n\tstruct file\t\t*file_out,\n\tloff_t\t\t\tpos_out,\n\tloff_t\t\t\t*len,\n\tunsigned int\t\tremap_flags)\n{\n\tstruct inode\t\t*inode_in = file_inode(file_in);\n\tstruct xfs_inode\t*src = XFS_I(inode_in);\n\tstruct inode\t\t*inode_out = file_inode(file_out);\n\tstruct xfs_inode\t*dest = XFS_I(inode_out);\n\tint\t\t\tret;\n\n\t \n\tret = xfs_ilock2_io_mmap(src, dest);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = -EINVAL;\n\t \n\tif (XFS_IS_REALTIME_INODE(src) || XFS_IS_REALTIME_INODE(dest))\n\t\tgoto out_unlock;\n\n\t \n\tif (IS_DAX(inode_in) != IS_DAX(inode_out))\n\t\tgoto out_unlock;\n\n\tif (!IS_DAX(inode_in))\n\t\tret = generic_remap_file_range_prep(file_in, pos_in, file_out,\n\t\t\t\tpos_out, len, remap_flags);\n\telse\n\t\tret = dax_remap_file_range_prep(file_in, pos_in, file_out,\n\t\t\t\tpos_out, len, remap_flags, &xfs_read_iomap_ops);\n\tif (ret || *len == 0)\n\t\tgoto out_unlock;\n\n\t \n\tret = xfs_qm_dqattach(dest);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tret = xfs_reflink_zero_posteof(dest, pos_out);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tret = xfs_reflink_set_inode_flag(src, dest);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tif (pos_out > XFS_ISIZE(dest)) {\n\t\tloff_t\tflen = *len + (pos_out - XFS_ISIZE(dest));\n\t\tret = xfs_flush_unmap_range(dest, XFS_ISIZE(dest), flen);\n\t} else {\n\t\tret = xfs_flush_unmap_range(dest, pos_out, *len);\n\t}\n\tif (ret)\n\t\tgoto out_unlock;\n\n\treturn 0;\nout_unlock:\n\txfs_iunlock2_io_mmap(src, dest);\n\treturn ret;\n}\n\n \nint\nxfs_reflink_inode_has_shared_extents(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_inode\t\t*ip,\n\tbool\t\t\t\t*has_shared)\n{\n\tstruct xfs_bmbt_irec\t\tgot;\n\tstruct xfs_mount\t\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t\t*ifp;\n\tstruct xfs_iext_cursor\t\ticur;\n\tbool\t\t\t\tfound;\n\tint\t\t\t\terror;\n\n\tifp = xfs_ifork_ptr(ip, XFS_DATA_FORK);\n\terror = xfs_iread_extents(tp, ip, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\t*has_shared = false;\n\tfound = xfs_iext_lookup_extent(ip, ifp, 0, &icur, &got);\n\twhile (found) {\n\t\tstruct xfs_perag\t*pag;\n\t\txfs_agblock_t\t\tagbno;\n\t\txfs_extlen_t\t\taglen;\n\t\txfs_agblock_t\t\trbno;\n\t\txfs_extlen_t\t\trlen;\n\n\t\tif (isnullstartblock(got.br_startblock) ||\n\t\t    got.br_state != XFS_EXT_NORM)\n\t\t\tgoto next;\n\n\t\tpag = xfs_perag_get(mp, XFS_FSB_TO_AGNO(mp, got.br_startblock));\n\t\tagbno = XFS_FSB_TO_AGBNO(mp, got.br_startblock);\n\t\taglen = got.br_blockcount;\n\t\terror = xfs_reflink_find_shared(pag, tp, agbno, aglen,\n\t\t\t\t&rbno, &rlen, false);\n\t\txfs_perag_put(pag);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tif (rbno != NULLAGBLOCK) {\n\t\t\t*has_shared = true;\n\t\t\treturn 0;\n\t\t}\nnext:\n\t\tfound = xfs_iext_next_extent(ifp, &icur, &got);\n\t}\n\n\treturn 0;\n}\n\n \nint\nxfs_reflink_clear_inode_flag(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t**tpp)\n{\n\tbool\t\t\tneeds_flag;\n\tint\t\t\terror = 0;\n\n\tASSERT(xfs_is_reflink_inode(ip));\n\n\terror = xfs_reflink_inode_has_shared_extents(*tpp, ip, &needs_flag);\n\tif (error || needs_flag)\n\t\treturn error;\n\n\t \n\terror = xfs_reflink_cancel_cow_blocks(ip, tpp, 0, XFS_MAX_FILEOFF,\n\t\t\ttrue);\n\tif (error)\n\t\treturn error;\n\n\t \n\ttrace_xfs_reflink_unset_inode_flag(ip);\n\tip->i_diflags2 &= ~XFS_DIFLAG2_REFLINK;\n\txfs_inode_clear_cowblocks_tag(ip);\n\txfs_trans_log_inode(*tpp, ip, XFS_ILOG_CORE);\n\n\treturn error;\n}\n\n \nSTATIC int\nxfs_reflink_try_clear_inode_flag(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror = 0;\n\n\t \n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_write, 0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\terror = xfs_reflink_clear_inode_flag(ip, &tp);\n\tif (error)\n\t\tgoto cancel;\n\n\terror = xfs_trans_commit(tp);\n\tif (error)\n\t\tgoto out;\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn 0;\ncancel:\n\txfs_trans_cancel(tp);\nout:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\n \nint\nxfs_reflink_unshare(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tint\t\t\terror;\n\n\tif (!xfs_is_reflink_inode(ip))\n\t\treturn 0;\n\n\ttrace_xfs_reflink_unshare(ip, offset, len);\n\n\tinode_dio_wait(inode);\n\n\tif (IS_DAX(inode))\n\t\terror = dax_file_unshare(inode, offset, len,\n\t\t\t\t&xfs_dax_write_iomap_ops);\n\telse\n\t\terror = iomap_file_unshare(inode, offset, len,\n\t\t\t\t&xfs_buffered_write_iomap_ops);\n\tif (error)\n\t\tgoto out;\n\n\terror = filemap_write_and_wait_range(inode->i_mapping, offset,\n\t\t\toffset + len - 1);\n\tif (error)\n\t\tgoto out;\n\n\t \n\terror = xfs_reflink_try_clear_inode_flag(ip);\n\tif (error)\n\t\tgoto out;\n\treturn 0;\n\nout:\n\ttrace_xfs_reflink_unshare_error(ip, error, _RET_IP_);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}