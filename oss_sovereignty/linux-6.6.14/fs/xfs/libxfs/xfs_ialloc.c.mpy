{
  "module_name": "xfs_ialloc.c",
  "hash_id": "e642de80b17900593b4c8bd7b10a94d954b64af29c3b17896ddf977156c55c6f",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_ialloc.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_errortag.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_ag.h\"\n\n \nint\t\t\t\t\t \nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t \n\txfs_agino_t\t\tino,\t \n\txfs_lookup_t\t\tdir,\t \n\tint\t\t\t*stat)\t \n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_holemask = 0;\n\tcur->bc_rec.i.ir_count = 0;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}\n\n \nSTATIC int\t\t\t\t \nxfs_inobt_update(\n\tstruct xfs_btree_cur\t*cur,\t \n\txfs_inobt_rec_incore_t\t*irec)\t \n{\n\tunion xfs_btree_rec\trec;\n\n\trec.inobt.ir_startino = cpu_to_be32(irec->ir_startino);\n\tif (xfs_has_sparseinodes(cur->bc_mp)) {\n\t\trec.inobt.ir_u.sp.ir_holemask = cpu_to_be16(irec->ir_holemask);\n\t\trec.inobt.ir_u.sp.ir_count = irec->ir_count;\n\t\trec.inobt.ir_u.sp.ir_freecount = irec->ir_freecount;\n\t} else {\n\t\t \n\t\trec.inobt.ir_u.f.ir_freecount = cpu_to_be32(irec->ir_freecount);\n\t}\n\trec.inobt.ir_free = cpu_to_be64(irec->ir_free);\n\treturn xfs_btree_update(cur, &rec);\n}\n\n \nvoid\nxfs_inobt_btrec_to_irec(\n\tstruct xfs_mount\t\t*mp,\n\tconst union xfs_btree_rec\t*rec,\n\tstruct xfs_inobt_rec_incore\t*irec)\n{\n\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\tif (xfs_has_sparseinodes(mp)) {\n\t\tirec->ir_holemask = be16_to_cpu(rec->inobt.ir_u.sp.ir_holemask);\n\t\tirec->ir_count = rec->inobt.ir_u.sp.ir_count;\n\t\tirec->ir_freecount = rec->inobt.ir_u.sp.ir_freecount;\n\t} else {\n\t\t \n\t\tirec->ir_holemask = XFS_INOBT_HOLEMASK_FULL;\n\t\tirec->ir_count = XFS_INODES_PER_CHUNK;\n\t\tirec->ir_freecount =\n\t\t\t\tbe32_to_cpu(rec->inobt.ir_u.f.ir_freecount);\n\t}\n\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n}\n\n \nxfs_failaddr_t\nxfs_inobt_check_irec(\n\tstruct xfs_btree_cur\t\t\t*cur,\n\tconst struct xfs_inobt_rec_incore\t*irec)\n{\n\tuint64_t\t\t\trealfree;\n\n\t \n\tif (!xfs_verify_agino(cur->bc_ag.pag, irec->ir_startino))\n\t\treturn __this_address;\n\tif (!xfs_verify_agino(cur->bc_ag.pag,\n\t\t\t\tirec->ir_startino + XFS_INODES_PER_CHUNK - 1))\n\t\treturn __this_address;\n\tif (irec->ir_count < XFS_INODES_PER_HOLEMASK_BIT ||\n\t    irec->ir_count > XFS_INODES_PER_CHUNK)\n\t\treturn __this_address;\n\tif (irec->ir_freecount > XFS_INODES_PER_CHUNK)\n\t\treturn __this_address;\n\n\t \n\tif (!xfs_inobt_issparse(irec->ir_holemask))\n\t\trealfree = irec->ir_free;\n\telse\n\t\trealfree = irec->ir_free & xfs_inobt_irec_to_allocmask(irec);\n\tif (hweight64(realfree) != irec->ir_freecount)\n\t\treturn __this_address;\n\n\treturn NULL;\n}\n\nstatic inline int\nxfs_inobt_complain_bad_rec(\n\tstruct xfs_btree_cur\t\t*cur,\n\txfs_failaddr_t\t\t\tfa,\n\tconst struct xfs_inobt_rec_incore *irec)\n{\n\tstruct xfs_mount\t\t*mp = cur->bc_mp;\n\n\txfs_warn(mp,\n\t\t\"%s Inode BTree record corruption in AG %d detected at %pS!\",\n\t\tcur->bc_btnum == XFS_BTNUM_INO ? \"Used\" : \"Free\",\n\t\tcur->bc_ag.pag->pag_agno, fa);\n\txfs_warn(mp,\n\"start inode 0x%x, count 0x%x, free 0x%x freemask 0x%llx, holemask 0x%x\",\n\t\tirec->ir_startino, irec->ir_count, irec->ir_freecount,\n\t\tirec->ir_free, irec->ir_holemask);\n\treturn -EFSCORRUPTED;\n}\n\n \nint\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t\t*cur,\n\tstruct xfs_inobt_rec_incore\t*irec,\n\tint\t\t\t\t*stat)\n{\n\tstruct xfs_mount\t\t*mp = cur->bc_mp;\n\tunion xfs_btree_rec\t\t*rec;\n\txfs_failaddr_t\t\t\tfa;\n\tint\t\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (error || *stat == 0)\n\t\treturn error;\n\n\txfs_inobt_btrec_to_irec(mp, rec, irec);\n\tfa = xfs_inobt_check_irec(cur, irec);\n\tif (fa)\n\t\treturn xfs_inobt_complain_bad_rec(cur, fa, irec);\n\n\treturn 0;\n}\n\n \nint\nxfs_inobt_insert_rec(\n\tstruct xfs_btree_cur\t*cur,\n\tuint16_t\t\tholemask,\n\tuint8_t\t\t\tcount,\n\tint32_t\t\t\tfreecount,\n\txfs_inofree_t\t\tfree,\n\tint\t\t\t*stat)\n{\n\tcur->bc_rec.i.ir_holemask = holemask;\n\tcur->bc_rec.i.ir_count = count;\n\tcur->bc_rec.i.ir_freecount = freecount;\n\tcur->bc_rec.i.ir_free = free;\n\treturn xfs_btree_insert(cur, stat);\n}\n\n \nSTATIC int\nxfs_inobt_insert(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\txfs_agino_t\t\tnewino,\n\txfs_agino_t\t\tnewlen,\n\txfs_btnum_t\t\tbtnum)\n{\n\tstruct xfs_btree_cur\t*cur;\n\txfs_agino_t\t\tthisino;\n\tint\t\t\ti;\n\tint\t\t\terror;\n\n\tcur = xfs_inobt_init_cursor(pag, tp, agbp, btnum);\n\n\tfor (thisino = newino;\n\t     thisino < newino + newlen;\n\t     thisino += XFS_INODES_PER_CHUNK) {\n\t\terror = xfs_inobt_lookup(cur, thisino, XFS_LOOKUP_EQ, &i);\n\t\tif (error) {\n\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\tASSERT(i == 0);\n\n\t\terror = xfs_inobt_insert_rec(cur, XFS_INOBT_HOLEMASK_FULL,\n\t\t\t\t\t     XFS_INODES_PER_CHUNK,\n\t\t\t\t\t     XFS_INODES_PER_CHUNK,\n\t\t\t\t\t     XFS_INOBT_ALL_FREE, &i);\n\t\tif (error) {\n\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\tASSERT(i == 1);\n\t}\n\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\n\treturn 0;\n}\n\n \n#ifdef DEBUG\nstatic int\nxfs_check_agi_freecount(\n\tstruct xfs_btree_cur\t*cur)\n{\n\tif (cur->bc_nlevels == 1) {\n\t\txfs_inobt_rec_incore_t rec;\n\t\tint\t\tfreecount = 0;\n\t\tint\t\terror;\n\t\tint\t\ti;\n\n\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdo {\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tif (i) {\n\t\t\t\tfreecount += rec.ir_freecount;\n\t\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t} while (i == 1);\n\n\t\tif (!xfs_is_shutdown(cur->bc_mp))\n\t\t\tASSERT(freecount == cur->bc_ag.pag->pagi_freecount);\n\t}\n\treturn 0;\n}\n#else\n#define xfs_check_agi_freecount(cur)\t0\n#endif\n\n \nint\nxfs_ialloc_inode_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct list_head\t*buffer_list,\n\tint\t\t\ticount,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tagbno,\n\txfs_agblock_t\t\tlength,\n\tunsigned int\t\tgen)\n{\n\tstruct xfs_buf\t\t*fbuf;\n\tstruct xfs_dinode\t*free;\n\tint\t\t\tnbufs;\n\tint\t\t\tversion;\n\tint\t\t\ti, j;\n\txfs_daddr_t\t\td;\n\txfs_ino_t\t\tino = 0;\n\tint\t\t\terror;\n\n\t \n\tnbufs = length / M_IGEO(mp)->blocks_per_cluster;\n\n\t \n\tif (xfs_has_v3inodes(mp)) {\n\t\tversion = 3;\n\t\tino = XFS_AGINO_TO_INO(mp, agno, XFS_AGB_TO_AGINO(mp, agbno));\n\n\t\t \n\t\tif (tp)\n\t\t\txfs_icreate_log(tp, agno, agbno, icount,\n\t\t\t\t\tmp->m_sb.sb_inodesize, length, gen);\n\t} else\n\t\tversion = 2;\n\n\tfor (j = 0; j < nbufs; j++) {\n\t\t \n\t\td = XFS_AGB_TO_DADDR(mp, agno, agbno +\n\t\t\t\t(j * M_IGEO(mp)->blocks_per_cluster));\n\t\terror = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,\n\t\t\t\tmp->m_bsize * M_IGEO(mp)->blocks_per_cluster,\n\t\t\t\tXBF_UNMAPPED, &fbuf);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tfbuf->b_ops = &xfs_inode_buf_ops;\n\t\txfs_buf_zero(fbuf, 0, BBTOB(fbuf->b_length));\n\t\tfor (i = 0; i < M_IGEO(mp)->inodes_per_cluster; i++) {\n\t\t\tint\tioffset = i << mp->m_sb.sb_inodelog;\n\n\t\t\tfree = xfs_make_iptr(mp, fbuf, i);\n\t\t\tfree->di_magic = cpu_to_be16(XFS_DINODE_MAGIC);\n\t\t\tfree->di_version = version;\n\t\t\tfree->di_gen = cpu_to_be32(gen);\n\t\t\tfree->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\n\t\t\tif (version == 3) {\n\t\t\t\tfree->di_ino = cpu_to_be64(ino);\n\t\t\t\tino++;\n\t\t\t\tuuid_copy(&free->di_uuid,\n\t\t\t\t\t  &mp->m_sb.sb_meta_uuid);\n\t\t\t\txfs_dinode_calc_crc(mp, free);\n\t\t\t} else if (tp) {\n\t\t\t\t \n\t\t\t\txfs_trans_log_buf(tp, fbuf, ioffset,\n\t\t\t\t\t  ioffset + XFS_DINODE_SIZE(mp) - 1);\n\t\t\t}\n\t\t}\n\n\t\tif (tp) {\n\t\t\t \n\t\t\txfs_trans_inode_alloc_buf(tp, fbuf);\n\t\t\tif (version == 3) {\n\t\t\t\t \n\t\t\t\txfs_trans_ordered_buf(tp, fbuf);\n\t\t\t}\n\t\t} else {\n\t\t\tfbuf->b_flags |= XBF_DONE;\n\t\t\txfs_buf_delwri_queue(fbuf, buffer_list);\n\t\t\txfs_buf_relse(fbuf);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nSTATIC void\nxfs_align_sparse_ino(\n\tstruct xfs_mount\t\t*mp,\n\txfs_agino_t\t\t\t*startino,\n\tuint16_t\t\t\t*allocmask)\n{\n\txfs_agblock_t\t\t\tagbno;\n\txfs_agblock_t\t\t\tmod;\n\tint\t\t\t\toffset;\n\n\tagbno = XFS_AGINO_TO_AGBNO(mp, *startino);\n\tmod = agbno % mp->m_sb.sb_inoalignmt;\n\tif (!mod)\n\t\treturn;\n\n\t \n\toffset = XFS_AGB_TO_AGINO(mp, mod);\n\t*startino -= offset;\n\n\t \n\t*allocmask <<= offset / XFS_INODES_PER_HOLEMASK_BIT;\n}\n\n \nSTATIC bool\n__xfs_inobt_can_merge(\n\tstruct xfs_inobt_rec_incore\t*trec,\t \n\tstruct xfs_inobt_rec_incore\t*srec)\t \n{\n\tuint64_t\t\t\ttalloc;\n\tuint64_t\t\t\tsalloc;\n\n\t \n\tif (trec->ir_startino != srec->ir_startino)\n\t\treturn false;\n\n\t \n\tif (!xfs_inobt_issparse(trec->ir_holemask) ||\n\t    !xfs_inobt_issparse(srec->ir_holemask))\n\t\treturn false;\n\n\t \n\tif (!trec->ir_count || !srec->ir_count)\n\t\treturn false;\n\n\t \n\tif (trec->ir_count + srec->ir_count > XFS_INODES_PER_CHUNK)\n\t\treturn false;\n\n\t \n\ttalloc = xfs_inobt_irec_to_allocmask(trec);\n\tsalloc = xfs_inobt_irec_to_allocmask(srec);\n\tif (talloc & salloc)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nSTATIC void\n__xfs_inobt_rec_merge(\n\tstruct xfs_inobt_rec_incore\t*trec,\t \n\tstruct xfs_inobt_rec_incore\t*srec)\t \n{\n\tASSERT(trec->ir_startino == srec->ir_startino);\n\n\t \n\ttrec->ir_count += srec->ir_count;\n\ttrec->ir_freecount += srec->ir_freecount;\n\n\t \n\ttrec->ir_holemask &= srec->ir_holemask;\n\ttrec->ir_free &= srec->ir_free;\n}\n\n \nSTATIC int\nxfs_inobt_insert_sprec(\n\tstruct xfs_perag\t\t*pag,\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_buf\t\t\t*agbp,\n\tint\t\t\t\tbtnum,\n\tstruct xfs_inobt_rec_incore\t*nrec,\t \n\tbool\t\t\t\tmerge)\t \n{\n\tstruct xfs_mount\t\t*mp = pag->pag_mount;\n\tstruct xfs_btree_cur\t\t*cur;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\tstruct xfs_inobt_rec_incore\trec;\n\n\tcur = xfs_inobt_init_cursor(pag, tp, agbp, btnum);\n\n\t \n\terror = xfs_inobt_lookup(cur, nrec->ir_startino, XFS_LOOKUP_EQ, &i);\n\tif (error)\n\t\tgoto error;\n\t \n\tif (i == 0) {\n\t\terror = xfs_inobt_insert_rec(cur, nrec->ir_holemask,\n\t\t\t\t\t     nrec->ir_count, nrec->ir_freecount,\n\t\t\t\t\t     nrec->ir_free, &i);\n\t\tif (error)\n\t\t\tgoto error;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\t \n\tif (merge) {\n\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\tif (error)\n\t\t\tgoto error;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error;\n\t\t}\n\t\tif (XFS_IS_CORRUPT(mp, rec.ir_startino != nrec->ir_startino)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif (XFS_IS_CORRUPT(mp, !__xfs_inobt_can_merge(nrec, &rec))) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error;\n\t\t}\n\n\t\ttrace_xfs_irec_merge_pre(mp, pag->pag_agno, rec.ir_startino,\n\t\t\t\t\t rec.ir_holemask, nrec->ir_startino,\n\t\t\t\t\t nrec->ir_holemask);\n\n\t\t \n\t\t__xfs_inobt_rec_merge(nrec, &rec);\n\n\t\ttrace_xfs_irec_merge_post(mp, pag->pag_agno, nrec->ir_startino,\n\t\t\t\t\t  nrec->ir_holemask);\n\n\t\terror = xfs_inobt_rec_check_count(mp, nrec);\n\t\tif (error)\n\t\t\tgoto error;\n\t}\n\n\terror = xfs_inobt_update(cur, nrec);\n\tif (error)\n\t\tgoto error;\n\nout:\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\treturn 0;\nerror:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_ialloc_ag_alloc(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp)\n{\n\tstruct xfs_agi\t\t*agi;\n\tstruct xfs_alloc_arg\targs;\n\tint\t\t\terror;\n\txfs_agino_t\t\tnewino;\t\t \n\txfs_agino_t\t\tnewlen;\t\t \n\tint\t\t\tisaligned = 0;\t \n\t\t\t\t\t\t \n\t \n\tstruct xfs_inobt_rec_incore rec;\n\tstruct xfs_ino_geometry\t*igeo = M_IGEO(tp->t_mountp);\n\tuint16_t\t\tallocmask = (uint16_t) -1;\n\tint\t\t\tdo_sparse = 0;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = tp->t_mountp;\n\targs.fsbno = NULLFSBLOCK;\n\targs.oinfo = XFS_RMAP_OINFO_INODES;\n\targs.pag = pag;\n\n#ifdef DEBUG\n\t \n\tif (xfs_has_sparseinodes(tp->t_mountp) &&\n\t    igeo->ialloc_min_blks < igeo->ialloc_blks)\n\t\tdo_sparse = get_random_u32_below(2);\n#endif\n\n\t \n\tnewlen = igeo->ialloc_inos;\n\tif (igeo->maxicount &&\n\t    percpu_counter_read_positive(&args.mp->m_icount) + newlen >\n\t\t\t\t\t\t\tigeo->maxicount)\n\t\treturn -ENOSPC;\n\targs.minlen = args.maxlen = igeo->ialloc_blks;\n\t \n\tagi = agbp->b_addr;\n\tnewino = be32_to_cpu(agi->agi_newino);\n\targs.agbno = XFS_AGINO_TO_AGBNO(args.mp, newino) +\n\t\t     igeo->ialloc_blks;\n\tif (do_sparse)\n\t\tgoto sparse_alloc;\n\tif (likely(newino != NULLAGINO &&\n\t\t  (args.agbno < be32_to_cpu(agi->agi_length)))) {\n\t\targs.prod = 1;\n\n\t\t \n\t\targs.alignment = 1;\n\t\targs.minalignslop = igeo->cluster_align - 1;\n\n\t\t \n\t\targs.minleft = igeo->inobt_maxlevels;\n\t\terror = xfs_alloc_vextent_exact_bno(&args,\n\t\t\t\tXFS_AGB_TO_FSB(args.mp, pag->pag_agno,\n\t\t\t\t\t\targs.agbno));\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\targs.minalignslop = 0;\n\t}\n\n\tif (unlikely(args.fsbno == NULLFSBLOCK)) {\n\t\t \n\t\tisaligned = 0;\n\t\tif (igeo->ialloc_align) {\n\t\t\tASSERT(!xfs_has_noalign(args.mp));\n\t\t\targs.alignment = args.mp->m_dalign;\n\t\t\tisaligned = 1;\n\t\t} else\n\t\t\targs.alignment = igeo->cluster_align;\n\t\t \n\t\targs.prod = 1;\n\t\t \n\t\targs.minleft = igeo->inobt_maxlevels;\n\t\terror = xfs_alloc_vextent_near_bno(&args,\n\t\t\t\tXFS_AGB_TO_FSB(args.mp, pag->pag_agno,\n\t\t\t\t\t\tbe32_to_cpu(agi->agi_root)));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\tif (isaligned && args.fsbno == NULLFSBLOCK) {\n\t\targs.alignment = igeo->cluster_align;\n\t\terror = xfs_alloc_vextent_near_bno(&args,\n\t\t\t\tXFS_AGB_TO_FSB(args.mp, pag->pag_agno,\n\t\t\t\t\t\tbe32_to_cpu(agi->agi_root)));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\tif (xfs_has_sparseinodes(args.mp) &&\n\t    igeo->ialloc_min_blks < igeo->ialloc_blks &&\n\t    args.fsbno == NULLFSBLOCK) {\nsparse_alloc:\n\t\targs.alignment = args.mp->m_sb.sb_spino_align;\n\t\targs.prod = 1;\n\n\t\targs.minlen = igeo->ialloc_min_blks;\n\t\targs.maxlen = args.minlen;\n\n\t\t \n\t\targs.min_agbno = args.mp->m_sb.sb_inoalignmt;\n\t\targs.max_agbno = round_down(args.mp->m_sb.sb_agblocks,\n\t\t\t\t\t    args.mp->m_sb.sb_inoalignmt) -\n\t\t\t\t igeo->ialloc_blks;\n\n\t\terror = xfs_alloc_vextent_near_bno(&args,\n\t\t\t\tXFS_AGB_TO_FSB(args.mp, pag->pag_agno,\n\t\t\t\t\t\tbe32_to_cpu(agi->agi_root)));\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tnewlen = XFS_AGB_TO_AGINO(args.mp, args.len);\n\t\tASSERT(newlen <= XFS_INODES_PER_CHUNK);\n\t\tallocmask = (1 << (newlen / XFS_INODES_PER_HOLEMASK_BIT)) - 1;\n\t}\n\n\tif (args.fsbno == NULLFSBLOCK)\n\t\treturn -EAGAIN;\n\n\tASSERT(args.len == args.minlen);\n\n\t \n\terror = xfs_ialloc_inode_init(args.mp, tp, NULL, newlen, pag->pag_agno,\n\t\t\targs.agbno, args.len, get_random_u32());\n\n\tif (error)\n\t\treturn error;\n\t \n\tnewino = XFS_AGB_TO_AGINO(args.mp, args.agbno);\n\n\tif (xfs_inobt_issparse(~allocmask)) {\n\t\t \n\t\txfs_align_sparse_ino(args.mp, &newino, &allocmask);\n\n\t\trec.ir_startino = newino;\n\t\trec.ir_holemask = ~allocmask;\n\t\trec.ir_count = newlen;\n\t\trec.ir_freecount = newlen;\n\t\trec.ir_free = XFS_INOBT_ALL_FREE;\n\n\t\t \n\t\terror = xfs_inobt_insert_sprec(pag, tp, agbp,\n\t\t\t\tXFS_BTNUM_INO, &rec, true);\n\t\tif (error == -EFSCORRUPTED) {\n\t\t\txfs_alert(args.mp,\n\t\"invalid sparse inode record: ino 0x%llx holemask 0x%x count %u\",\n\t\t\t\t  XFS_AGINO_TO_INO(args.mp, pag->pag_agno,\n\t\t\t\t\t\t   rec.ir_startino),\n\t\t\t\t  rec.ir_holemask, rec.ir_count);\n\t\t\txfs_force_shutdown(args.mp, SHUTDOWN_CORRUPT_INCORE);\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tif (xfs_has_finobt(args.mp)) {\n\t\t\terror = xfs_inobt_insert_sprec(pag, tp, agbp,\n\t\t\t\t       XFS_BTNUM_FINO, &rec, false);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t} else {\n\t\t \n\t\terror = xfs_inobt_insert(pag, tp, agbp, newino, newlen,\n\t\t\t\t\t XFS_BTNUM_INO);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (xfs_has_finobt(args.mp)) {\n\t\t\terror = xfs_inobt_insert(pag, tp, agbp, newino,\n\t\t\t\t\t\t newlen, XFS_BTNUM_FINO);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\t \n\tbe32_add_cpu(&agi->agi_count, newlen);\n\tbe32_add_cpu(&agi->agi_freecount, newlen);\n\tpag->pagi_freecount += newlen;\n\tpag->pagi_count += newlen;\n\tagi->agi_newino = cpu_to_be32(newino);\n\n\t \n\txfs_ialloc_log_agi(tp, agbp,\n\t\tXFS_AGI_COUNT | XFS_AGI_FREECOUNT | XFS_AGI_NEWINO);\n\t \n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_ICOUNT, (long)newlen);\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, (long)newlen);\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_ialloc_next_rec(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_inobt_rec_incore_t\t*rec,\n\tint\t\t\t*done,\n\tint\t\t\tleft)\n{\n\tint                     error;\n\tint\t\t\ti;\n\n\tif (left)\n\t\terror = xfs_btree_decrement(cur, 0, &i);\n\telse\n\t\terror = xfs_btree_increment(cur, 0, &i);\n\n\tif (error)\n\t\treturn error;\n\t*done = !i;\n\tif (i) {\n\t\terror = xfs_inobt_get_rec(cur, rec, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (XFS_IS_CORRUPT(cur->bc_mp, i != 1))\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\n\treturn 0;\n}\n\nSTATIC int\nxfs_ialloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_agino_t\t\tagino,\n\txfs_inobt_rec_incore_t\t*rec,\n\tint\t\t\t*done)\n{\n\tint                     error;\n\tint\t\t\ti;\n\n\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_EQ, &i);\n\tif (error)\n\t\treturn error;\n\t*done = !i;\n\tif (i) {\n\t\terror = xfs_inobt_get_rec(cur, rec, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (XFS_IS_CORRUPT(cur->bc_mp, i != 1))\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_inobt_first_free_inode(\n\tstruct xfs_inobt_rec_incore\t*rec)\n{\n\txfs_inofree_t\t\t\trealfree;\n\n\t \n\tif (!xfs_inobt_issparse(rec->ir_holemask))\n\t\treturn xfs_lowbit64(rec->ir_free);\n\n\trealfree = xfs_inobt_irec_to_allocmask(rec);\n\trealfree &= rec->ir_free;\n\n\treturn xfs_lowbit64(realfree);\n}\n\n \nSTATIC int\nxfs_dialloc_ag_inobt(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\txfs_ino_t\t\tparent,\n\txfs_ino_t\t\t*inop)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_agi\t\t*agi = agbp->b_addr;\n\txfs_agnumber_t\t\tpagno = XFS_INO_TO_AGNO(mp, parent);\n\txfs_agino_t\t\tpagino = XFS_INO_TO_AGINO(mp, parent);\n\tstruct xfs_btree_cur\t*cur, *tcur;\n\tstruct xfs_inobt_rec_incore rec, trec;\n\txfs_ino_t\t\tino;\n\tint\t\t\terror;\n\tint\t\t\toffset;\n\tint\t\t\ti, j;\n\tint\t\t\tsearchdistance = 10;\n\n\tASSERT(xfs_perag_initialised_agi(pag));\n\tASSERT(xfs_perag_allows_inodes(pag));\n\tASSERT(pag->pagi_freecount > 0);\n\n restart_pagno:\n\tcur = xfs_inobt_init_cursor(pag, tp, agbp, XFS_BTNUM_INO);\n\t \n\tif (!pagino)\n\t\tpagino = be32_to_cpu(agi->agi_newino);\n\n\terror = xfs_check_agi_freecount(cur);\n\tif (error)\n\t\tgoto error0;\n\n\t \n\tif (pagno == pag->pag_agno) {\n\t\tint\t\tdoneleft;\t \n\t\tint\t\tdoneright;\t \n\n\t\terror = xfs_inobt_lookup(cur, pagino, XFS_LOOKUP_LE, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_inobt_get_rec(cur, &rec, &j);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(mp, j != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\n\t\tif (rec.ir_freecount > 0) {\n\t\t\t \n\t\t\tgoto alloc_inode;\n\t\t}\n\n\n\t\t \n\n\t\t \n\t\terror = xfs_btree_dup_cursor(cur, &tcur);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t \n\t\tif (pagino != NULLAGINO &&\n\t\t    pag->pagl_pagino == pagino &&\n\t\t    pag->pagl_leftrec != NULLAGINO &&\n\t\t    pag->pagl_rightrec != NULLAGINO) {\n\t\t\terror = xfs_ialloc_get_rec(tcur, pag->pagl_leftrec,\n\t\t\t\t\t\t   &trec, &doneleft);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\n\t\t\terror = xfs_ialloc_get_rec(cur, pag->pagl_rightrec,\n\t\t\t\t\t\t   &rec, &doneright);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\t\t} else {\n\t\t\t \n\t\t\terror = xfs_ialloc_next_rec(tcur, &trec, &doneleft, 1);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\n\t\t\t \n\t\t\terror = xfs_ialloc_next_rec(cur, &rec, &doneright, 0);\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\t\t}\n\n\t\t \n\t\twhile (--searchdistance > 0 && (!doneleft || !doneright)) {\n\t\t\tint\tuseleft;   \n\n\t\t\t \n\t\t\tif (!doneleft && !doneright) {\n\t\t\t\tuseleft = pagino -\n\t\t\t\t (trec.ir_startino + XFS_INODES_PER_CHUNK - 1) <\n\t\t\t\t  rec.ir_startino - pagino;\n\t\t\t} else {\n\t\t\t\tuseleft = !doneleft;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (useleft && trec.ir_freecount) {\n\t\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\t\t\tcur = tcur;\n\n\t\t\t\tpag->pagl_leftrec = trec.ir_startino;\n\t\t\t\tpag->pagl_rightrec = rec.ir_startino;\n\t\t\t\tpag->pagl_pagino = pagino;\n\t\t\t\trec = trec;\n\t\t\t\tgoto alloc_inode;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!useleft && rec.ir_freecount) {\n\t\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\n\t\t\t\tpag->pagl_leftrec = trec.ir_startino;\n\t\t\t\tpag->pagl_rightrec = rec.ir_startino;\n\t\t\t\tpag->pagl_pagino = pagino;\n\t\t\t\tgoto alloc_inode;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (useleft) {\n\t\t\t\terror = xfs_ialloc_next_rec(tcur, &trec,\n\t\t\t\t\t\t\t\t &doneleft, 1);\n\t\t\t} else {\n\t\t\t\terror = xfs_ialloc_next_rec(cur, &rec,\n\t\t\t\t\t\t\t\t &doneright, 0);\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\tgoto error1;\n\t\t}\n\n\t\tif (searchdistance <= 0) {\n\t\t\t \n\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\t\t\tpag->pagl_leftrec = trec.ir_startino;\n\t\t\tpag->pagl_rightrec = rec.ir_startino;\n\t\t\tpag->pagl_pagino = pagino;\n\n\t\t} else {\n\t\t\t \n\t\t\tpag->pagl_pagino = NULLAGINO;\n\t\t\tpag->pagl_leftrec = NULLAGINO;\n\t\t\tpag->pagl_rightrec = NULLAGINO;\n\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\t\tgoto restart_pagno;\n\t\t}\n\t}\n\n\t \n\tif (agi->agi_newino != cpu_to_be32(NULLAGINO)) {\n\t\terror = xfs_inobt_lookup(cur, be32_to_cpu(agi->agi_newino),\n\t\t\t\t\t XFS_LOOKUP_EQ, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (i == 1) {\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &j);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\n\t\t\tif (j == 1 && rec.ir_freecount > 0) {\n\t\t\t\t \n\t\t\t\tgoto alloc_inode;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\tif (error)\n\t\tgoto error0;\n\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\n\tfor (;;) {\n\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\t\tif (rec.ir_freecount > 0)\n\t\t\tbreak;\n\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\t}\n\nalloc_inode:\n\toffset = xfs_inobt_first_free_inode(&rec);\n\tASSERT(offset >= 0);\n\tASSERT(offset < XFS_INODES_PER_CHUNK);\n\tASSERT((XFS_AGINO_TO_OFFSET(mp, rec.ir_startino) %\n\t\t\t\t   XFS_INODES_PER_CHUNK) == 0);\n\tino = XFS_AGINO_TO_INO(mp, pag->pag_agno, rec.ir_startino + offset);\n\trec.ir_free &= ~XFS_INOBT_MASK(offset);\n\trec.ir_freecount--;\n\terror = xfs_inobt_update(cur, &rec);\n\tif (error)\n\t\tgoto error0;\n\tbe32_add_cpu(&agi->agi_freecount, -1);\n\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_FREECOUNT);\n\tpag->pagi_freecount--;\n\n\terror = xfs_check_agi_freecount(cur);\n\tif (error)\n\t\tgoto error0;\n\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, -1);\n\t*inop = ino;\n\treturn 0;\nerror1:\n\txfs_btree_del_cursor(tcur, XFS_BTREE_ERROR);\nerror0:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_dialloc_ag_finobt_near(\n\txfs_agino_t\t\t\tpagino,\n\tstruct xfs_btree_cur\t\t**ocur,\n\tstruct xfs_inobt_rec_incore\t*rec)\n{\n\tstruct xfs_btree_cur\t\t*lcur = *ocur;\t \n\tstruct xfs_btree_cur\t\t*rcur;\t \n\tstruct xfs_inobt_rec_incore\trrec;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti, j;\n\n\terror = xfs_inobt_lookup(lcur, pagino, XFS_LOOKUP_LE, &i);\n\tif (error)\n\t\treturn error;\n\n\tif (i == 1) {\n\t\terror = xfs_inobt_get_rec(lcur, rec, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (XFS_IS_CORRUPT(lcur->bc_mp, i != 1))\n\t\t\treturn -EFSCORRUPTED;\n\n\t\t \n\t\tif (pagino >= rec->ir_startino &&\n\t\t    pagino < (rec->ir_startino + XFS_INODES_PER_CHUNK))\n\t\t\treturn 0;\n\t}\n\n\terror = xfs_btree_dup_cursor(lcur, &rcur);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_inobt_lookup(rcur, pagino, XFS_LOOKUP_GE, &j);\n\tif (error)\n\t\tgoto error_rcur;\n\tif (j == 1) {\n\t\terror = xfs_inobt_get_rec(rcur, &rrec, &j);\n\t\tif (error)\n\t\t\tgoto error_rcur;\n\t\tif (XFS_IS_CORRUPT(lcur->bc_mp, j != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error_rcur;\n\t\t}\n\t}\n\n\tif (XFS_IS_CORRUPT(lcur->bc_mp, i != 1 && j != 1)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error_rcur;\n\t}\n\tif (i == 1 && j == 1) {\n\t\t \n\t\tif ((pagino - rec->ir_startino + XFS_INODES_PER_CHUNK - 1) >\n\t\t    (rrec.ir_startino - pagino)) {\n\t\t\t*rec = rrec;\n\t\t\txfs_btree_del_cursor(lcur, XFS_BTREE_NOERROR);\n\t\t\t*ocur = rcur;\n\t\t} else {\n\t\t\txfs_btree_del_cursor(rcur, XFS_BTREE_NOERROR);\n\t\t}\n\t} else if (j == 1) {\n\t\t \n\t\t*rec = rrec;\n\t\txfs_btree_del_cursor(lcur, XFS_BTREE_NOERROR);\n\t\t*ocur = rcur;\n\t} else if (i == 1) {\n\t\t \n\t\txfs_btree_del_cursor(rcur, XFS_BTREE_NOERROR);\n\t}\n\n\treturn 0;\n\nerror_rcur:\n\txfs_btree_del_cursor(rcur, XFS_BTREE_ERROR);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_dialloc_ag_finobt_newino(\n\tstruct xfs_agi\t\t\t*agi,\n\tstruct xfs_btree_cur\t\t*cur,\n\tstruct xfs_inobt_rec_incore\t*rec)\n{\n\tint error;\n\tint i;\n\n\tif (agi->agi_newino != cpu_to_be32(NULLAGINO)) {\n\t\terror = xfs_inobt_lookup(cur, be32_to_cpu(agi->agi_newino),\n\t\t\t\t\t XFS_LOOKUP_EQ, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (i == 1) {\n\t\t\terror = xfs_inobt_get_rec(cur, rec, &i);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (XFS_IS_CORRUPT(cur->bc_mp, i != 1))\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &i);\n\tif (error)\n\t\treturn error;\n\tif (XFS_IS_CORRUPT(cur->bc_mp, i != 1))\n\t\treturn -EFSCORRUPTED;\n\n\terror = xfs_inobt_get_rec(cur, rec, &i);\n\tif (error)\n\t\treturn error;\n\tif (XFS_IS_CORRUPT(cur->bc_mp, i != 1))\n\t\treturn -EFSCORRUPTED;\n\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_dialloc_ag_update_inobt(\n\tstruct xfs_btree_cur\t\t*cur,\t \n\tstruct xfs_inobt_rec_incore\t*frec,\t \n\tint\t\t\t\toffset)  \n{\n\tstruct xfs_inobt_rec_incore\trec;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\n\terror = xfs_inobt_lookup(cur, frec->ir_startino, XFS_LOOKUP_EQ, &i);\n\tif (error)\n\t\treturn error;\n\tif (XFS_IS_CORRUPT(cur->bc_mp, i != 1))\n\t\treturn -EFSCORRUPTED;\n\n\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\tif (error)\n\t\treturn error;\n\tif (XFS_IS_CORRUPT(cur->bc_mp, i != 1))\n\t\treturn -EFSCORRUPTED;\n\tASSERT((XFS_AGINO_TO_OFFSET(cur->bc_mp, rec.ir_startino) %\n\t\t\t\t   XFS_INODES_PER_CHUNK) == 0);\n\n\trec.ir_free &= ~XFS_INOBT_MASK(offset);\n\trec.ir_freecount--;\n\n\tif (XFS_IS_CORRUPT(cur->bc_mp,\n\t\t\t   rec.ir_free != frec->ir_free ||\n\t\t\t   rec.ir_freecount != frec->ir_freecount))\n\t\treturn -EFSCORRUPTED;\n\n\treturn xfs_inobt_update(cur, &rec);\n}\n\n \nstatic int\nxfs_dialloc_ag(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\txfs_ino_t\t\tparent,\n\txfs_ino_t\t\t*inop)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_agi\t\t\t*agi = agbp->b_addr;\n\txfs_agnumber_t\t\t\tpagno = XFS_INO_TO_AGNO(mp, parent);\n\txfs_agino_t\t\t\tpagino = XFS_INO_TO_AGINO(mp, parent);\n\tstruct xfs_btree_cur\t\t*cur;\t \n\tstruct xfs_btree_cur\t\t*icur;\t \n\tstruct xfs_inobt_rec_incore\trec;\n\txfs_ino_t\t\t\tino;\n\tint\t\t\t\terror;\n\tint\t\t\t\toffset;\n\tint\t\t\t\ti;\n\n\tif (!xfs_has_finobt(mp))\n\t\treturn xfs_dialloc_ag_inobt(pag, tp, agbp, parent, inop);\n\n\t \n\tif (!pagino)\n\t\tpagino = be32_to_cpu(agi->agi_newino);\n\n\tcur = xfs_inobt_init_cursor(pag, tp, agbp, XFS_BTNUM_FINO);\n\n\terror = xfs_check_agi_freecount(cur);\n\tif (error)\n\t\tgoto error_cur;\n\n\t \n\tif (pag->pag_agno == pagno)\n\t\terror = xfs_dialloc_ag_finobt_near(pagino, &cur, &rec);\n\telse\n\t\terror = xfs_dialloc_ag_finobt_newino(agi, cur, &rec);\n\tif (error)\n\t\tgoto error_cur;\n\n\toffset = xfs_inobt_first_free_inode(&rec);\n\tASSERT(offset >= 0);\n\tASSERT(offset < XFS_INODES_PER_CHUNK);\n\tASSERT((XFS_AGINO_TO_OFFSET(mp, rec.ir_startino) %\n\t\t\t\t   XFS_INODES_PER_CHUNK) == 0);\n\tino = XFS_AGINO_TO_INO(mp, pag->pag_agno, rec.ir_startino + offset);\n\n\t \n\trec.ir_free &= ~XFS_INOBT_MASK(offset);\n\trec.ir_freecount--;\n\tif (rec.ir_freecount)\n\t\terror = xfs_inobt_update(cur, &rec);\n\telse\n\t\terror = xfs_btree_delete(cur, &i);\n\tif (error)\n\t\tgoto error_cur;\n\n\t \n\ticur = xfs_inobt_init_cursor(pag, tp, agbp, XFS_BTNUM_INO);\n\n\terror = xfs_check_agi_freecount(icur);\n\tif (error)\n\t\tgoto error_icur;\n\n\terror = xfs_dialloc_ag_update_inobt(icur, &rec, offset);\n\tif (error)\n\t\tgoto error_icur;\n\n\t \n\tbe32_add_cpu(&agi->agi_freecount, -1);\n\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_FREECOUNT);\n\tpag->pagi_freecount--;\n\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, -1);\n\n\terror = xfs_check_agi_freecount(icur);\n\tif (error)\n\t\tgoto error_icur;\n\terror = xfs_check_agi_freecount(cur);\n\tif (error)\n\t\tgoto error_icur;\n\n\txfs_btree_del_cursor(icur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t*inop = ino;\n\treturn 0;\n\nerror_icur:\n\txfs_btree_del_cursor(icur, XFS_BTREE_ERROR);\nerror_cur:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\treturn error;\n}\n\nstatic int\nxfs_dialloc_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_buf\t\t*agibp)\n{\n\tstruct xfs_trans\t*tp = *tpp;\n\tstruct xfs_dquot_acct\t*dqinfo;\n\tint\t\t\terror;\n\n\t \n\txfs_trans_bhold(tp, agibp);\n\n\t \n\tdqinfo = tp->t_dqinfo;\n\ttp->t_dqinfo = NULL;\n\n\terror = xfs_trans_roll(&tp);\n\n\t \n\ttp->t_dqinfo = dqinfo;\n\n\t \n\txfs_trans_bjoin(tp, agibp);\n\t*tpp = tp;\n\treturn error;\n}\n\nstatic bool\nxfs_dialloc_good_ag(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\tumode_t\t\t\tmode,\n\tint\t\t\tflags,\n\tbool\t\t\tok_alloc)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_extlen_t\t\tineed;\n\txfs_extlen_t\t\tlongest = 0;\n\tint\t\t\tneedspace;\n\tint\t\t\terror;\n\n\tif (!pag)\n\t\treturn false;\n\tif (!xfs_perag_allows_inodes(pag))\n\t\treturn false;\n\n\tif (!xfs_perag_initialised_agi(pag)) {\n\t\terror = xfs_ialloc_read_agi(pag, tp, NULL);\n\t\tif (error)\n\t\t\treturn false;\n\t}\n\n\tif (pag->pagi_freecount)\n\t\treturn true;\n\tif (!ok_alloc)\n\t\treturn false;\n\n\tif (!xfs_perag_initialised_agf(pag)) {\n\t\terror = xfs_alloc_read_agf(pag, tp, flags, NULL);\n\t\tif (error)\n\t\t\treturn false;\n\t}\n\n\t \n\tineed = M_IGEO(mp)->ialloc_min_blks;\n\tif (flags && ineed > 1)\n\t\tineed += M_IGEO(mp)->cluster_align;\n\tlongest = pag->pagf_longest;\n\tif (!longest)\n\t\tlongest = pag->pagf_flcount > 0;\n\tneedspace = S_ISDIR(mode) || S_ISREG(mode) || S_ISLNK(mode);\n\n\tif (pag->pagf_freeblks < needspace + ineed || longest < ineed)\n\t\treturn false;\n\treturn true;\n}\n\nstatic int\nxfs_dialloc_try_ag(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t**tpp,\n\txfs_ino_t\t\tparent,\n\txfs_ino_t\t\t*new_ino,\n\tbool\t\t\tok_alloc)\n{\n\tstruct xfs_buf\t\t*agbp;\n\txfs_ino_t\t\tino;\n\tint\t\t\terror;\n\n\t \n\terror = xfs_ialloc_read_agi(pag, *tpp, &agbp);\n\tif (error)\n\t\treturn error;\n\n\tif (!pag->pagi_freecount) {\n\t\tif (!ok_alloc) {\n\t\t\terror = -EAGAIN;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\terror = xfs_ialloc_ag_alloc(pag, *tpp, agbp);\n\t\tif (error < 0)\n\t\t\tgoto out_release;\n\n\t\t \n\t\tASSERT(pag->pagi_freecount > 0);\n\t\terror = xfs_dialloc_roll(tpp, agbp);\n\t\tif (error)\n\t\t\tgoto out_release;\n\t}\n\n\t \n\terror = xfs_dialloc_ag(pag, *tpp, agbp, parent, &ino);\n\tif (!error)\n\t\t*new_ino = ino;\n\treturn error;\n\nout_release:\n\txfs_trans_brelse(*tpp, agbp);\n\treturn error;\n}\n\n \nint\nxfs_dialloc(\n\tstruct xfs_trans\t**tpp,\n\txfs_ino_t\t\tparent,\n\tumode_t\t\t\tmode,\n\txfs_ino_t\t\t*new_ino)\n{\n\tstruct xfs_mount\t*mp = (*tpp)->t_mountp;\n\txfs_agnumber_t\t\tagno;\n\tint\t\t\terror = 0;\n\txfs_agnumber_t\t\tstart_agno;\n\tstruct xfs_perag\t*pag;\n\tstruct xfs_ino_geometry\t*igeo = M_IGEO(mp);\n\tbool\t\t\tok_alloc = true;\n\tbool\t\t\tlow_space = false;\n\tint\t\t\tflags;\n\txfs_ino_t\t\tino = NULLFSINO;\n\n\t \n\tif (S_ISDIR(mode))\n\t\tstart_agno = (atomic_inc_return(&mp->m_agirotor) - 1) %\n\t\t\t\tmp->m_maxagi;\n\telse {\n\t\tstart_agno = XFS_INO_TO_AGNO(mp, parent);\n\t\tif (start_agno >= mp->m_maxagi)\n\t\t\tstart_agno = 0;\n\t}\n\n\t \n\tif (igeo->maxicount &&\n\t    percpu_counter_read_positive(&mp->m_icount) + igeo->ialloc_inos\n\t\t\t\t\t\t\t> igeo->maxicount) {\n\t\tok_alloc = false;\n\t}\n\n\t \n\tif (percpu_counter_read_positive(&mp->m_fdblocks) <\n\t\t\tmp->m_low_space[XFS_LOWSP_1_PCNT]) {\n\t\tok_alloc = false;\n\t\tlow_space = true;\n\t}\n\n\t \n\tflags = XFS_ALLOC_FLAG_TRYLOCK;\nretry:\n\tfor_each_perag_wrap_at(mp, start_agno, mp->m_maxagi, agno, pag) {\n\t\tif (xfs_dialloc_good_ag(pag, *tpp, mode, flags, ok_alloc)) {\n\t\t\terror = xfs_dialloc_try_ag(pag, tpp, parent,\n\t\t\t\t\t&ino, ok_alloc);\n\t\t\tif (error != -EAGAIN)\n\t\t\t\tbreak;\n\t\t\terror = 0;\n\t\t}\n\n\t\tif (xfs_is_shutdown(mp)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (pag)\n\t\txfs_perag_rele(pag);\n\tif (error)\n\t\treturn error;\n\tif (ino == NULLFSINO) {\n\t\tif (flags) {\n\t\t\tflags = 0;\n\t\t\tif (low_space)\n\t\t\t\tok_alloc = true;\n\t\t\tgoto retry;\n\t\t}\n\t\treturn -ENOSPC;\n\t}\n\t*new_ino = ino;\n\treturn 0;\n}\n\n \nstatic int\nxfs_difree_inode_chunk(\n\tstruct xfs_trans\t\t*tp,\n\txfs_agnumber_t\t\t\tagno,\n\tstruct xfs_inobt_rec_incore\t*rec)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\txfs_agblock_t\t\t\tsagbno = XFS_AGINO_TO_AGBNO(mp,\n\t\t\t\t\t\t\trec->ir_startino);\n\tint\t\t\t\tstartidx, endidx;\n\tint\t\t\t\tnextbit;\n\txfs_agblock_t\t\t\tagbno;\n\tint\t\t\t\tcontigblk;\n\tDECLARE_BITMAP(holemask, XFS_INOBT_HOLEMASK_BITS);\n\n\tif (!xfs_inobt_issparse(rec->ir_holemask)) {\n\t\t \n\t\treturn xfs_free_extent_later(tp,\n\t\t\t\tXFS_AGB_TO_FSB(mp, agno, sagbno),\n\t\t\t\tM_IGEO(mp)->ialloc_blks, &XFS_RMAP_OINFO_INODES,\n\t\t\t\tXFS_AG_RESV_NONE);\n\t}\n\n\t \n\tASSERT(sizeof(rec->ir_holemask) <= sizeof(holemask[0]));\n\tholemask[0] = rec->ir_holemask;\n\n\t \n\tstartidx = endidx = find_first_zero_bit(holemask,\n\t\t\t\t\t\tXFS_INOBT_HOLEMASK_BITS);\n\tnextbit = startidx + 1;\n\twhile (startidx < XFS_INOBT_HOLEMASK_BITS) {\n\t\tint error;\n\n\t\tnextbit = find_next_zero_bit(holemask, XFS_INOBT_HOLEMASK_BITS,\n\t\t\t\t\t     nextbit);\n\t\t \n\t\tif (nextbit != XFS_INOBT_HOLEMASK_BITS &&\n\t\t    nextbit == endidx + 1) {\n\t\t\tendidx = nextbit;\n\t\t\tgoto next;\n\t\t}\n\n\t\t \n\t\tagbno = sagbno + (startidx * XFS_INODES_PER_HOLEMASK_BIT) /\n\t\t\t\t  mp->m_sb.sb_inopblock;\n\t\tcontigblk = ((endidx - startidx + 1) *\n\t\t\t     XFS_INODES_PER_HOLEMASK_BIT) /\n\t\t\t    mp->m_sb.sb_inopblock;\n\n\t\tASSERT(agbno % mp->m_sb.sb_spino_align == 0);\n\t\tASSERT(contigblk % mp->m_sb.sb_spino_align == 0);\n\t\terror = xfs_free_extent_later(tp,\n\t\t\t\tXFS_AGB_TO_FSB(mp, agno, agbno), contigblk,\n\t\t\t\t&XFS_RMAP_OINFO_INODES, XFS_AG_RESV_NONE);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tstartidx = endidx = nextbit;\n\nnext:\n\t\tnextbit++;\n\t}\n\treturn 0;\n}\n\nSTATIC int\nxfs_difree_inobt(\n\tstruct xfs_perag\t\t*pag,\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_buf\t\t\t*agbp,\n\txfs_agino_t\t\t\tagino,\n\tstruct xfs_icluster\t\t*xic,\n\tstruct xfs_inobt_rec_incore\t*orec)\n{\n\tstruct xfs_mount\t\t*mp = pag->pag_mount;\n\tstruct xfs_agi\t\t\t*agi = agbp->b_addr;\n\tstruct xfs_btree_cur\t\t*cur;\n\tstruct xfs_inobt_rec_incore\trec;\n\tint\t\t\t\tilen;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\tint\t\t\t\toff;\n\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n\tASSERT(XFS_AGINO_TO_AGBNO(mp, agino) < be32_to_cpu(agi->agi_length));\n\n\t \n\tcur = xfs_inobt_init_cursor(pag, tp, agbp, XFS_BTNUM_INO);\n\n\terror = xfs_check_agi_freecount(cur);\n\tif (error)\n\t\tgoto error0;\n\n\t \n\tif ((error = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &i))) {\n\t\txfs_warn(mp, \"%s: xfs_inobt_lookup() returned error %d.\",\n\t\t\t__func__, error);\n\t\tgoto error0;\n\t}\n\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\tif (error) {\n\t\txfs_warn(mp, \"%s: xfs_inobt_get_rec() returned error %d.\",\n\t\t\t__func__, error);\n\t\tgoto error0;\n\t}\n\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\t \n\toff = agino - rec.ir_startino;\n\tASSERT(off >= 0 && off < XFS_INODES_PER_CHUNK);\n\tASSERT(!(rec.ir_free & XFS_INOBT_MASK(off)));\n\t \n\trec.ir_free |= XFS_INOBT_MASK(off);\n\trec.ir_freecount++;\n\n\t \n\tif (!xfs_has_ikeep(mp) && rec.ir_free == XFS_INOBT_ALL_FREE &&\n\t    mp->m_sb.sb_inopblock <= XFS_INODES_PER_CHUNK) {\n\t\txic->deleted = true;\n\t\txic->first_ino = XFS_AGINO_TO_INO(mp, pag->pag_agno,\n\t\t\t\trec.ir_startino);\n\t\txic->alloc = xfs_inobt_irec_to_allocmask(&rec);\n\n\t\t \n\t\tilen = rec.ir_freecount;\n\t\tbe32_add_cpu(&agi->agi_count, -ilen);\n\t\tbe32_add_cpu(&agi->agi_freecount, -(ilen - 1));\n\t\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_COUNT | XFS_AGI_FREECOUNT);\n\t\tpag->pagi_freecount -= ilen - 1;\n\t\tpag->pagi_count -= ilen;\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_ICOUNT, -ilen);\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, -(ilen - 1));\n\n\t\tif ((error = xfs_btree_delete(cur, &i))) {\n\t\t\txfs_warn(mp, \"%s: xfs_btree_delete returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_difree_inode_chunk(tp, pag->pag_agno, &rec);\n\t\tif (error)\n\t\t\tgoto error0;\n\t} else {\n\t\txic->deleted = false;\n\n\t\terror = xfs_inobt_update(cur, &rec);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: xfs_inobt_update returned error %d.\",\n\t\t\t\t__func__, error);\n\t\t\tgoto error0;\n\t\t}\n\n\t\t \n\t\tbe32_add_cpu(&agi->agi_freecount, 1);\n\t\txfs_ialloc_log_agi(tp, agbp, XFS_AGI_FREECOUNT);\n\t\tpag->pagi_freecount++;\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IFREE, 1);\n\t}\n\n\terror = xfs_check_agi_freecount(cur);\n\tif (error)\n\t\tgoto error0;\n\n\t*orec = rec;\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\treturn 0;\n\nerror0:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_difree_finobt(\n\tstruct xfs_perag\t\t*pag,\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_buf\t\t\t*agbp,\n\txfs_agino_t\t\t\tagino,\n\tstruct xfs_inobt_rec_incore\t*ibtrec)  \n{\n\tstruct xfs_mount\t\t*mp = pag->pag_mount;\n\tstruct xfs_btree_cur\t\t*cur;\n\tstruct xfs_inobt_rec_incore\trec;\n\tint\t\t\t\toffset = agino - ibtrec->ir_startino;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\n\tcur = xfs_inobt_init_cursor(pag, tp, agbp, XFS_BTNUM_FINO);\n\n\terror = xfs_inobt_lookup(cur, ibtrec->ir_startino, XFS_LOOKUP_EQ, &i);\n\tif (error)\n\t\tgoto error;\n\tif (i == 0) {\n\t\t \n\t\tif (XFS_IS_CORRUPT(mp, ibtrec->ir_freecount != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error;\n\t\t}\n\n\t\terror = xfs_inobt_insert_rec(cur, ibtrec->ir_holemask,\n\t\t\t\t\t     ibtrec->ir_count,\n\t\t\t\t\t     ibtrec->ir_freecount,\n\t\t\t\t\t     ibtrec->ir_free, &i);\n\t\tif (error)\n\t\t\tgoto error;\n\t\tASSERT(i == 1);\n\n\t\tgoto out;\n\t}\n\n\t \n\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\tif (error)\n\t\tgoto error;\n\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error;\n\t}\n\n\trec.ir_free |= XFS_INOBT_MASK(offset);\n\trec.ir_freecount++;\n\n\tif (XFS_IS_CORRUPT(mp,\n\t\t\t   rec.ir_free != ibtrec->ir_free ||\n\t\t\t   rec.ir_freecount != ibtrec->ir_freecount)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error;\n\t}\n\n\t \n\tif (!xfs_has_ikeep(mp) && rec.ir_free == XFS_INOBT_ALL_FREE &&\n\t    mp->m_sb.sb_inopblock <= XFS_INODES_PER_CHUNK) {\n\t\terror = xfs_btree_delete(cur, &i);\n\t\tif (error)\n\t\t\tgoto error;\n\t\tASSERT(i == 1);\n\t} else {\n\t\terror = xfs_inobt_update(cur, &rec);\n\t\tif (error)\n\t\t\tgoto error;\n\t}\n\nout:\n\terror = xfs_check_agi_freecount(cur);\n\tif (error)\n\t\tgoto error;\n\n\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\treturn 0;\n\nerror:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\treturn error;\n}\n\n \nint\nxfs_difree(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_perag\t*pag,\n\txfs_ino_t\t\tinode,\n\tstruct xfs_icluster\t*xic)\n{\n\t \n\txfs_agblock_t\t\tagbno;\t \n\tstruct xfs_buf\t\t*agbp;\t \n\txfs_agino_t\t\tagino;\t \n\tint\t\t\terror;\t \n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_inobt_rec_incore rec; \n\n\t \n\tif (pag->pag_agno != XFS_INO_TO_AGNO(mp, inode)) {\n\t\txfs_warn(mp, \"%s: agno != pag->pag_agno (%d != %d).\",\n\t\t\t__func__, XFS_INO_TO_AGNO(mp, inode), pag->pag_agno);\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n\tagino = XFS_INO_TO_AGINO(mp, inode);\n\tif (inode != XFS_AGINO_TO_INO(mp, pag->pag_agno, agino))  {\n\t\txfs_warn(mp, \"%s: inode != XFS_AGINO_TO_INO() (%llu != %llu).\",\n\t\t\t__func__, (unsigned long long)inode,\n\t\t\t(unsigned long long)XFS_AGINO_TO_INO(mp, pag->pag_agno, agino));\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n\tagbno = XFS_AGINO_TO_AGBNO(mp, agino);\n\tif (agbno >= mp->m_sb.sb_agblocks)  {\n\t\txfs_warn(mp, \"%s: agbno >= mp->m_sb.sb_agblocks (%d >= %d).\",\n\t\t\t__func__, agbno, mp->m_sb.sb_agblocks);\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n\t \n\terror = xfs_ialloc_read_agi(pag, tp, &agbp);\n\tif (error) {\n\t\txfs_warn(mp, \"%s: xfs_ialloc_read_agi() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t \n\terror = xfs_difree_inobt(pag, tp, agbp, agino, xic, &rec);\n\tif (error)\n\t\tgoto error0;\n\n\t \n\tif (xfs_has_finobt(mp)) {\n\t\terror = xfs_difree_finobt(pag, tp, agbp, agino, &rec);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\treturn 0;\n\nerror0:\n\treturn error;\n}\n\nSTATIC int\nxfs_imap_lookup(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\txfs_agino_t\t\tagino,\n\txfs_agblock_t\t\tagbno,\n\txfs_agblock_t\t\t*chunk_agbno,\n\txfs_agblock_t\t\t*offset_agbno,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\tstruct xfs_inobt_rec_incore rec;\n\tstruct xfs_btree_cur\t*cur;\n\tstruct xfs_buf\t\t*agbp;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\terror = xfs_ialloc_read_agi(pag, tp, &agbp);\n\tif (error) {\n\t\txfs_alert(mp,\n\t\t\t\"%s: xfs_ialloc_read_agi() returned error %d, agno %d\",\n\t\t\t__func__, error, pag->pag_agno);\n\t\treturn error;\n\t}\n\n\t \n\tcur = xfs_inobt_init_cursor(pag, tp, agbp, XFS_BTNUM_INO);\n\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &i);\n\tif (!error) {\n\t\tif (i)\n\t\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n\t\tif (!error && i == 0)\n\t\t\terror = -EINVAL;\n\t}\n\n\txfs_trans_brelse(tp, agbp);\n\txfs_btree_del_cursor(cur, error);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (rec.ir_startino > agino ||\n\t    rec.ir_startino + M_IGEO(mp)->ialloc_inos <= agino)\n\t\treturn -EINVAL;\n\n\t \n\tif ((flags & XFS_IGET_UNTRUSTED) &&\n\t    (rec.ir_free & XFS_INOBT_MASK(agino - rec.ir_startino)))\n\t\treturn -EINVAL;\n\n\t*chunk_agbno = XFS_AGINO_TO_AGBNO(mp, rec.ir_startino);\n\t*offset_agbno = agbno - *chunk_agbno;\n\treturn 0;\n}\n\n \nint\nxfs_imap(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\txfs_ino_t\t\tino,\t \n\tstruct xfs_imap\t\t*imap,\t \n\tuint\t\t\tflags)\t \n{\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\txfs_agblock_t\t\tagbno;\t \n\txfs_agino_t\t\tagino;\t \n\txfs_agblock_t\t\tchunk_agbno;\t \n\txfs_agblock_t\t\tcluster_agbno;\t \n\tint\t\t\terror;\t \n\tint\t\t\toffset;\t \n\txfs_agblock_t\t\toffset_agbno;\t \n\n\tASSERT(ino != NULLFSINO);\n\n\t \n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tagbno = XFS_AGINO_TO_AGBNO(mp, agino);\n\tif (agbno >= mp->m_sb.sb_agblocks ||\n\t    ino != XFS_AGINO_TO_INO(mp, pag->pag_agno, agino)) {\n\t\terror = -EINVAL;\n#ifdef DEBUG\n\t\t \n\t\tif (flags & XFS_IGET_UNTRUSTED)\n\t\t\treturn error;\n\t\tif (agbno >= mp->m_sb.sb_agblocks) {\n\t\t\txfs_alert(mp,\n\t\t\"%s: agbno (0x%llx) >= mp->m_sb.sb_agblocks (0x%lx)\",\n\t\t\t\t__func__, (unsigned long long)agbno,\n\t\t\t\t(unsigned long)mp->m_sb.sb_agblocks);\n\t\t}\n\t\tif (ino != XFS_AGINO_TO_INO(mp, pag->pag_agno, agino)) {\n\t\t\txfs_alert(mp,\n\t\t\"%s: ino (0x%llx) != XFS_AGINO_TO_INO() (0x%llx)\",\n\t\t\t\t__func__, ino,\n\t\t\t\tXFS_AGINO_TO_INO(mp, pag->pag_agno, agino));\n\t\t}\n\t\txfs_stack_trace();\n#endif  \n\t\treturn error;\n\t}\n\n\t \n\tif (flags & XFS_IGET_UNTRUSTED) {\n\t\terror = xfs_imap_lookup(pag, tp, agino, agbno,\n\t\t\t\t\t&chunk_agbno, &offset_agbno, flags);\n\t\tif (error)\n\t\t\treturn error;\n\t\tgoto out_map;\n\t}\n\n\t \n\tif (M_IGEO(mp)->blocks_per_cluster == 1) {\n\t\toffset = XFS_INO_TO_OFFSET(mp, ino);\n\t\tASSERT(offset < mp->m_sb.sb_inopblock);\n\n\t\timap->im_blkno = XFS_AGB_TO_DADDR(mp, pag->pag_agno, agbno);\n\t\timap->im_len = XFS_FSB_TO_BB(mp, 1);\n\t\timap->im_boffset = (unsigned short)(offset <<\n\t\t\t\t\t\t\tmp->m_sb.sb_inodelog);\n\t\treturn 0;\n\t}\n\n\t \n\tif (M_IGEO(mp)->inoalign_mask) {\n\t\toffset_agbno = agbno & M_IGEO(mp)->inoalign_mask;\n\t\tchunk_agbno = agbno - offset_agbno;\n\t} else {\n\t\terror = xfs_imap_lookup(pag, tp, agino, agbno,\n\t\t\t\t\t&chunk_agbno, &offset_agbno, flags);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\nout_map:\n\tASSERT(agbno >= chunk_agbno);\n\tcluster_agbno = chunk_agbno +\n\t\t((offset_agbno / M_IGEO(mp)->blocks_per_cluster) *\n\t\t M_IGEO(mp)->blocks_per_cluster);\n\toffset = ((agbno - cluster_agbno) * mp->m_sb.sb_inopblock) +\n\t\tXFS_INO_TO_OFFSET(mp, ino);\n\n\timap->im_blkno = XFS_AGB_TO_DADDR(mp, pag->pag_agno, cluster_agbno);\n\timap->im_len = XFS_FSB_TO_BB(mp, M_IGEO(mp)->blocks_per_cluster);\n\timap->im_boffset = (unsigned short)(offset << mp->m_sb.sb_inodelog);\n\n\t \n\tif ((imap->im_blkno + imap->im_len) >\n\t    XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks)) {\n\t\txfs_alert(mp,\n\t\"%s: (im_blkno (0x%llx) + im_len (0x%llx)) > sb_dblocks (0x%llx)\",\n\t\t\t__func__, (unsigned long long) imap->im_blkno,\n\t\t\t(unsigned long long) imap->im_len,\n\t\t\tXFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks));\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nvoid\nxfs_ialloc_log_agi(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tuint32_t\t\tfields)\n{\n\tint\t\t\tfirst;\t\t \n\tint\t\t\tlast;\t\t \n\tstatic const short\toffsets[] = {\t \n\t\t\t\t\t \n\t\toffsetof(xfs_agi_t, agi_magicnum),\n\t\toffsetof(xfs_agi_t, agi_versionnum),\n\t\toffsetof(xfs_agi_t, agi_seqno),\n\t\toffsetof(xfs_agi_t, agi_length),\n\t\toffsetof(xfs_agi_t, agi_count),\n\t\toffsetof(xfs_agi_t, agi_root),\n\t\toffsetof(xfs_agi_t, agi_level),\n\t\toffsetof(xfs_agi_t, agi_freecount),\n\t\toffsetof(xfs_agi_t, agi_newino),\n\t\toffsetof(xfs_agi_t, agi_dirino),\n\t\toffsetof(xfs_agi_t, agi_unlinked),\n\t\toffsetof(xfs_agi_t, agi_free_root),\n\t\toffsetof(xfs_agi_t, agi_free_level),\n\t\toffsetof(xfs_agi_t, agi_iblocks),\n\t\tsizeof(xfs_agi_t)\n\t};\n#ifdef DEBUG\n\tstruct xfs_agi\t\t*agi = bp->b_addr;\n\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n#endif\n\n\t \n\tif (fields & XFS_AGI_ALL_BITS_R1) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R1,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n\n\t \n\tfields &= ~XFS_AGI_ALL_BITS_R1;\n\tif (fields) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R2,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n}\n\nstatic xfs_failaddr_t\nxfs_agi_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_agi\t\t*agi = bp->b_addr;\n\txfs_failaddr_t\t\tfa;\n\tuint32_t\t\tagi_seqno = be32_to_cpu(agi->agi_seqno);\n\tuint32_t\t\tagi_length = be32_to_cpu(agi->agi_length);\n\tint\t\t\ti;\n\n\tif (xfs_has_crc(mp)) {\n\t\tif (!uuid_equal(&agi->agi_uuid, &mp->m_sb.sb_meta_uuid))\n\t\t\treturn __this_address;\n\t\tif (!xfs_log_check_lsn(mp, be64_to_cpu(agi->agi_lsn)))\n\t\t\treturn __this_address;\n\t}\n\n\t \n\tif (!xfs_verify_magic(bp, agi->agi_magicnum))\n\t\treturn __this_address;\n\tif (!XFS_AGI_GOOD_VERSION(be32_to_cpu(agi->agi_versionnum)))\n\t\treturn __this_address;\n\n\tfa = xfs_validate_ag_length(bp, agi_seqno, agi_length);\n\tif (fa)\n\t\treturn fa;\n\n\tif (be32_to_cpu(agi->agi_level) < 1 ||\n\t    be32_to_cpu(agi->agi_level) > M_IGEO(mp)->inobt_maxlevels)\n\t\treturn __this_address;\n\n\tif (xfs_has_finobt(mp) &&\n\t    (be32_to_cpu(agi->agi_free_level) < 1 ||\n\t     be32_to_cpu(agi->agi_free_level) > M_IGEO(mp)->inobt_maxlevels))\n\t\treturn __this_address;\n\n\tfor (i = 0; i < XFS_AGI_UNLINKED_BUCKETS; i++) {\n\t\tif (agi->agi_unlinked[i] == cpu_to_be32(NULLAGINO))\n\t\t\tcontinue;\n\t\tif (!xfs_verify_ino(mp, be32_to_cpu(agi->agi_unlinked[i])))\n\t\t\treturn __this_address;\n\t}\n\n\treturn NULL;\n}\n\nstatic void\nxfs_agi_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_mount;\n\txfs_failaddr_t\tfa;\n\n\tif (xfs_has_crc(mp) &&\n\t    !xfs_buf_verify_cksum(bp, XFS_AGI_CRC_OFF))\n\t\txfs_verifier_error(bp, -EFSBADCRC, __this_address);\n\telse {\n\t\tfa = xfs_agi_verify(bp);\n\t\tif (XFS_TEST_ERROR(fa, mp, XFS_ERRTAG_IALLOC_READ_AGI))\n\t\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t}\n}\n\nstatic void\nxfs_agi_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_log_item;\n\tstruct xfs_agi\t\t*agi = bp->b_addr;\n\txfs_failaddr_t\t\tfa;\n\n\tfa = xfs_agi_verify(bp);\n\tif (fa) {\n\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t\treturn;\n\t}\n\n\tif (!xfs_has_crc(mp))\n\t\treturn;\n\n\tif (bip)\n\t\tagi->agi_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\txfs_buf_update_cksum(bp, XFS_AGI_CRC_OFF);\n}\n\nconst struct xfs_buf_ops xfs_agi_buf_ops = {\n\t.name = \"xfs_agi\",\n\t.magic = { cpu_to_be32(XFS_AGI_MAGIC), cpu_to_be32(XFS_AGI_MAGIC) },\n\t.verify_read = xfs_agi_read_verify,\n\t.verify_write = xfs_agi_write_verify,\n\t.verify_struct = xfs_agi_verify,\n};\n\n \nint\nxfs_read_agi(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t**agibpp)\n{\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\tint\t\t\terror;\n\n\ttrace_xfs_read_agi(pag->pag_mount, pag->pag_agno);\n\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, pag->pag_agno, XFS_AGI_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, agibpp, &xfs_agi_buf_ops);\n\tif (error)\n\t\treturn error;\n\tif (tp)\n\t\txfs_trans_buf_set_type(tp, *agibpp, XFS_BLFT_AGI_BUF);\n\n\txfs_buf_set_ref(*agibpp, XFS_AGI_REF);\n\treturn 0;\n}\n\n \nint\nxfs_ialloc_read_agi(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t**agibpp)\n{\n\tstruct xfs_buf\t\t*agibp;\n\tstruct xfs_agi\t\t*agi;\n\tint\t\t\terror;\n\n\ttrace_xfs_ialloc_read_agi(pag->pag_mount, pag->pag_agno);\n\n\terror = xfs_read_agi(pag, tp, &agibp);\n\tif (error)\n\t\treturn error;\n\n\tagi = agibp->b_addr;\n\tif (!xfs_perag_initialised_agi(pag)) {\n\t\tpag->pagi_freecount = be32_to_cpu(agi->agi_freecount);\n\t\tpag->pagi_count = be32_to_cpu(agi->agi_count);\n\t\tset_bit(XFS_AGSTATE_AGI_INIT, &pag->pag_opstate);\n\t}\n\n\t \n\tASSERT(pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n\t\txfs_is_shutdown(pag->pag_mount));\n\tif (agibpp)\n\t\t*agibpp = agibp;\n\telse\n\t\txfs_trans_brelse(tp, agibp);\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_ialloc_count_ondisk(\n\tstruct xfs_btree_cur\t\t*cur,\n\txfs_agino_t\t\t\tlow,\n\txfs_agino_t\t\t\thigh,\n\tunsigned int\t\t\t*allocated)\n{\n\tstruct xfs_inobt_rec_incore\tirec;\n\tunsigned int\t\t\tret = 0;\n\tint\t\t\t\thas_record;\n\tint\t\t\t\terror;\n\n\terror = xfs_inobt_lookup(cur, low, XFS_LOOKUP_LE, &has_record);\n\tif (error)\n\t\treturn error;\n\n\twhile (has_record) {\n\t\tunsigned int\t\ti, hole_idx;\n\n\t\terror = xfs_inobt_get_rec(cur, &irec, &has_record);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (irec.ir_startino > high)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < XFS_INODES_PER_CHUNK; i++) {\n\t\t\tif (irec.ir_startino + i < low)\n\t\t\t\tcontinue;\n\t\t\tif (irec.ir_startino + i > high)\n\t\t\t\tbreak;\n\n\t\t\thole_idx = i / XFS_INODES_PER_HOLEMASK_BIT;\n\t\t\tif (!(irec.ir_holemask & (1U << hole_idx)))\n\t\t\t\tret++;\n\t\t}\n\n\t\terror = xfs_btree_increment(cur, 0, &has_record);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t*allocated = ret;\n\treturn 0;\n}\n\n \nint\nxfs_ialloc_has_inodes_at_extent(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\tenum xbtree_recpacking\t*outcome)\n{\n\txfs_agino_t\t\tagino;\n\txfs_agino_t\t\tlast_agino;\n\tunsigned int\t\tallocated;\n\tint\t\t\terror;\n\n\tagino = XFS_AGB_TO_AGINO(cur->bc_mp, bno);\n\tlast_agino = XFS_AGB_TO_AGINO(cur->bc_mp, bno + len) - 1;\n\n\terror = xfs_ialloc_count_ondisk(cur, agino, last_agino, &allocated);\n\tif (error)\n\t\treturn error;\n\n\tif (allocated == 0)\n\t\t*outcome = XBTREE_RECPACKING_EMPTY;\n\telse if (allocated == last_agino - agino + 1)\n\t\t*outcome = XBTREE_RECPACKING_FULL;\n\telse\n\t\t*outcome = XBTREE_RECPACKING_SPARSE;\n\treturn 0;\n}\n\nstruct xfs_ialloc_count_inodes {\n\txfs_agino_t\t\t\tcount;\n\txfs_agino_t\t\t\tfreecount;\n};\n\n \nSTATIC int\nxfs_ialloc_count_inodes_rec(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst union xfs_btree_rec\t*rec,\n\tvoid\t\t\t\t*priv)\n{\n\tstruct xfs_inobt_rec_incore\tirec;\n\tstruct xfs_ialloc_count_inodes\t*ci = priv;\n\txfs_failaddr_t\t\t\tfa;\n\n\txfs_inobt_btrec_to_irec(cur->bc_mp, rec, &irec);\n\tfa = xfs_inobt_check_irec(cur, &irec);\n\tif (fa)\n\t\treturn xfs_inobt_complain_bad_rec(cur, fa, &irec);\n\n\tci->count += irec.ir_count;\n\tci->freecount += irec.ir_freecount;\n\n\treturn 0;\n}\n\n \nint\nxfs_ialloc_count_inodes(\n\tstruct xfs_btree_cur\t\t*cur,\n\txfs_agino_t\t\t\t*count,\n\txfs_agino_t\t\t\t*freecount)\n{\n\tstruct xfs_ialloc_count_inodes\tci = {0};\n\tint\t\t\t\terror;\n\n\tASSERT(cur->bc_btnum == XFS_BTNUM_INO);\n\terror = xfs_btree_query_all(cur, xfs_ialloc_count_inodes_rec, &ci);\n\tif (error)\n\t\treturn error;\n\n\t*count = ci.count;\n\t*freecount = ci.freecount;\n\treturn 0;\n}\n\n \nvoid\nxfs_ialloc_setup_geometry(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_sb\t\t*sbp = &mp->m_sb;\n\tstruct xfs_ino_geometry\t*igeo = M_IGEO(mp);\n\tuint64_t\t\ticount;\n\tuint\t\t\tinodes;\n\n\tigeo->new_diflags2 = 0;\n\tif (xfs_has_bigtime(mp))\n\t\tigeo->new_diflags2 |= XFS_DIFLAG2_BIGTIME;\n\tif (xfs_has_large_extent_counts(mp))\n\t\tigeo->new_diflags2 |= XFS_DIFLAG2_NREXT64;\n\n\t \n\tigeo->agino_log = sbp->sb_inopblog + sbp->sb_agblklog;\n\tigeo->inobt_mxr[0] = xfs_inobt_maxrecs(mp, sbp->sb_blocksize, 1);\n\tigeo->inobt_mxr[1] = xfs_inobt_maxrecs(mp, sbp->sb_blocksize, 0);\n\tigeo->inobt_mnr[0] = igeo->inobt_mxr[0] / 2;\n\tigeo->inobt_mnr[1] = igeo->inobt_mxr[1] / 2;\n\n\tigeo->ialloc_inos = max_t(uint16_t, XFS_INODES_PER_CHUNK,\n\t\t\tsbp->sb_inopblock);\n\tigeo->ialloc_blks = igeo->ialloc_inos >> sbp->sb_inopblog;\n\n\tif (sbp->sb_spino_align)\n\t\tigeo->ialloc_min_blks = sbp->sb_spino_align;\n\telse\n\t\tigeo->ialloc_min_blks = igeo->ialloc_blks;\n\n\t \n\tinodes = (1LL << XFS_INO_AGINO_BITS(mp)) >> XFS_INODES_PER_CHUNK_LOG;\n\tigeo->inobt_maxlevels = xfs_btree_compute_maxlevels(igeo->inobt_mnr,\n\t\t\tinodes);\n\tASSERT(igeo->inobt_maxlevels <= xfs_iallocbt_maxlevels_ondisk());\n\n\t \n\tif (sbp->sb_imax_pct && igeo->ialloc_blks) {\n\t\t \n\t\ticount = sbp->sb_dblocks * sbp->sb_imax_pct;\n\t\tdo_div(icount, 100);\n\t\tdo_div(icount, igeo->ialloc_blks);\n\t\tigeo->maxicount = XFS_FSB_TO_INO(mp,\n\t\t\t\ticount * igeo->ialloc_blks);\n\t} else {\n\t\tigeo->maxicount = 0;\n\t}\n\n\t \n\tigeo->inode_cluster_size_raw = XFS_INODE_BIG_CLUSTER_SIZE;\n\tif (xfs_has_v3inodes(mp)) {\n\t\tint\tnew_size = igeo->inode_cluster_size_raw;\n\n\t\tnew_size *= mp->m_sb.sb_inodesize / XFS_DINODE_MIN_SIZE;\n\t\tif (mp->m_sb.sb_inoalignmt >= XFS_B_TO_FSBT(mp, new_size))\n\t\t\tigeo->inode_cluster_size_raw = new_size;\n\t}\n\n\t \n\tif (igeo->inode_cluster_size_raw > mp->m_sb.sb_blocksize)\n\t\tigeo->blocks_per_cluster = XFS_B_TO_FSBT(mp,\n\t\t\t\tigeo->inode_cluster_size_raw);\n\telse\n\t\tigeo->blocks_per_cluster = 1;\n\tigeo->inode_cluster_size = XFS_FSB_TO_B(mp, igeo->blocks_per_cluster);\n\tigeo->inodes_per_cluster = XFS_FSB_TO_INO(mp, igeo->blocks_per_cluster);\n\n\t \n\tif (xfs_has_align(mp) &&\n\t    mp->m_sb.sb_inoalignmt >= igeo->blocks_per_cluster)\n\t\tigeo->cluster_align = mp->m_sb.sb_inoalignmt;\n\telse\n\t\tigeo->cluster_align = 1;\n\tigeo->inoalign_mask = igeo->cluster_align - 1;\n\tigeo->cluster_align_inodes = XFS_FSB_TO_INO(mp, igeo->cluster_align);\n\n\t \n\tif (mp->m_dalign && igeo->inoalign_mask &&\n\t    !(mp->m_dalign & igeo->inoalign_mask))\n\t\tigeo->ialloc_align = mp->m_dalign;\n\telse\n\t\tigeo->ialloc_align = 0;\n}\n\n \nxfs_ino_t\nxfs_ialloc_calc_rootino(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tsunit)\n{\n\tstruct xfs_ino_geometry\t*igeo = M_IGEO(mp);\n\txfs_agblock_t\t\tfirst_bno;\n\n\t \n\tfirst_bno = howmany(4 * mp->m_sb.sb_sectsize, mp->m_sb.sb_blocksize);\n\n\t \n\tfirst_bno += 2;\n\n\t \n\tfirst_bno += 1;\n\n\t \n\tfirst_bno += xfs_alloc_min_freelist(mp, NULL);\n\n\t \n\tif (xfs_has_finobt(mp))\n\t\tfirst_bno++;\n\n\t \n\tif (xfs_has_rmapbt(mp))\n\t\tfirst_bno++;\n\n\t \n\tif (xfs_has_reflink(mp))\n\t\tfirst_bno++;\n\n\t \n\tif (xfs_ag_contains_log(mp, 0))\n\t\t first_bno += mp->m_sb.sb_logblocks;\n\n\t \n\tif (xfs_has_dalign(mp) && igeo->ialloc_align > 0)\n\t\tfirst_bno = roundup(first_bno, sunit);\n\telse if (xfs_has_align(mp) &&\n\t\t\tmp->m_sb.sb_inoalignmt > 1)\n\t\tfirst_bno = roundup(first_bno, mp->m_sb.sb_inoalignmt);\n\n\treturn XFS_AGINO_TO_INO(mp, 0, XFS_AGB_TO_AGINO(mp, first_bno));\n}\n\n \nint\nxfs_ialloc_check_shrink(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agibp,\n\txfs_agblock_t\t\tnew_length)\n{\n\tstruct xfs_inobt_rec_incore rec;\n\tstruct xfs_btree_cur\t*cur;\n\txfs_agino_t\t\tagino;\n\tint\t\t\thas;\n\tint\t\t\terror;\n\n\tif (!xfs_has_sparseinodes(pag->pag_mount))\n\t\treturn 0;\n\n\tcur = xfs_inobt_init_cursor(pag, tp, agibp, XFS_BTNUM_INO);\n\n\t \n\tagino = XFS_AGB_TO_AGINO(pag->pag_mount, new_length);\n\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &has);\n\tif (error || !has)\n\t\tgoto out;\n\n\terror = xfs_inobt_get_rec(cur, &rec, &has);\n\tif (error)\n\t\tgoto out;\n\n\tif (!has) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\n\t \n\tif (rec.ir_startino + XFS_INODES_PER_CHUNK > agino) {\n\t\terror = -ENOSPC;\n\t\tgoto out;\n\t}\nout:\n\txfs_btree_del_cursor(cur, error);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}