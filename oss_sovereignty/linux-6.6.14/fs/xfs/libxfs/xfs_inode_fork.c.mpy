{
  "module_name": "xfs_inode_fork.c",
  "hash_id": "222f51ae282bc551180c9dfdf4ba3d4b2ca9584d1acb16be895bcb99aecad352",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_inode_fork.c",
  "human_readable_source": "\n \n\n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_types.h\"\n#include \"xfs_errortag.h\"\n\nstruct kmem_cache *xfs_ifork_cache;\n\nvoid\nxfs_init_local_fork(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tconst void\t\t*data,\n\tint64_t\t\t\tsize)\n{\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tint\t\t\tmem_size = size;\n\tbool\t\t\tzero_terminate;\n\n\t \n\tzero_terminate = S_ISLNK(VFS_I(ip)->i_mode);\n\tif (zero_terminate)\n\t\tmem_size++;\n\n\tif (size) {\n\t\tifp->if_u1.if_data = kmem_alloc(mem_size, KM_NOFS);\n\t\tmemcpy(ifp->if_u1.if_data, data, size);\n\t\tif (zero_terminate)\n\t\t\tifp->if_u1.if_data[size] = '\\0';\n\t} else {\n\t\tifp->if_u1.if_data = NULL;\n\t}\n\n\tifp->if_bytes = size;\n}\n\n \nSTATIC int\nxfs_iformat_local(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dinode\t*dip,\n\tint\t\t\twhichfork,\n\tint\t\t\tsize)\n{\n\t \n\tif (unlikely(size > XFS_DFORK_SIZE(dip, ip->i_mount, whichfork))) {\n\t\txfs_warn(ip->i_mount,\n\t\"corrupt inode %llu (bad size %d for local fork, size = %zd).\",\n\t\t\t(unsigned long long) ip->i_ino, size,\n\t\t\tXFS_DFORK_SIZE(dip, ip->i_mount, whichfork));\n\t\txfs_inode_verifier_error(ip, -EFSCORRUPTED,\n\t\t\t\t\"xfs_iformat_local\", dip, sizeof(*dip),\n\t\t\t\t__this_address);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\txfs_init_local_fork(ip, whichfork, XFS_DFORK_PTR(dip, whichfork), size);\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_iformat_extents(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dinode\t*dip,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tint\t\t\tstate = xfs_bmap_fork_to_state(whichfork);\n\txfs_extnum_t\t\tnex = xfs_dfork_nextents(dip, whichfork);\n\tint\t\t\tsize = nex * sizeof(xfs_bmbt_rec_t);\n\tstruct xfs_iext_cursor\ticur;\n\tstruct xfs_bmbt_rec\t*dp;\n\tstruct xfs_bmbt_irec\tnew;\n\tint\t\t\ti;\n\n\t \n\tif (unlikely(size < 0 || size > XFS_DFORK_SIZE(dip, mp, whichfork))) {\n\t\txfs_warn(ip->i_mount, \"corrupt inode %llu ((a)extents = %llu).\",\n\t\t\tip->i_ino, nex);\n\t\txfs_inode_verifier_error(ip, -EFSCORRUPTED,\n\t\t\t\t\"xfs_iformat_extents(1)\", dip, sizeof(*dip),\n\t\t\t\t__this_address);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tifp->if_bytes = 0;\n\tifp->if_u1.if_root = NULL;\n\tifp->if_height = 0;\n\tif (size) {\n\t\tdp = (xfs_bmbt_rec_t *) XFS_DFORK_PTR(dip, whichfork);\n\n\t\txfs_iext_first(ifp, &icur);\n\t\tfor (i = 0; i < nex; i++, dp++) {\n\t\t\txfs_failaddr_t\tfa;\n\n\t\t\txfs_bmbt_disk_get_all(dp, &new);\n\t\t\tfa = xfs_bmap_validate_extent(ip, whichfork, &new);\n\t\t\tif (fa) {\n\t\t\t\txfs_inode_verifier_error(ip, -EFSCORRUPTED,\n\t\t\t\t\t\t\"xfs_iformat_extents(2)\",\n\t\t\t\t\t\tdp, sizeof(*dp), fa);\n\t\t\t\treturn xfs_bmap_complain_bad_rec(ip, whichfork,\n\t\t\t\t\t\tfa, &new);\n\t\t\t}\n\n\t\t\txfs_iext_insert(ip, &icur, &new, state);\n\t\t\ttrace_xfs_read_extent(ip, &icur, state, _THIS_IP_);\n\t\t\txfs_iext_next(ifp, &icur);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_iformat_btree(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dinode\t*dip,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_bmdr_block_t\t*dfp;\n\tstruct xfs_ifork\t*ifp;\n\t \n\tint\t\t\tnrecs;\n\tint\t\t\tsize;\n\tint\t\t\tlevel;\n\n\tifp = xfs_ifork_ptr(ip, whichfork);\n\tdfp = (xfs_bmdr_block_t *)XFS_DFORK_PTR(dip, whichfork);\n\tsize = XFS_BMAP_BROOT_SPACE(mp, dfp);\n\tnrecs = be16_to_cpu(dfp->bb_numrecs);\n\tlevel = be16_to_cpu(dfp->bb_level);\n\n\t \n\tif (unlikely(ifp->if_nextents <= XFS_IFORK_MAXEXT(ip, whichfork) ||\n\t\t     nrecs == 0 ||\n\t\t     XFS_BMDR_SPACE_CALC(nrecs) >\n\t\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork) ||\n\t\t     ifp->if_nextents > ip->i_nblocks) ||\n\t\t     level == 0 || level > XFS_BM_MAXLEVELS(mp, whichfork)) {\n\t\txfs_warn(mp, \"corrupt inode %llu (btree).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino);\n\t\txfs_inode_verifier_error(ip, -EFSCORRUPTED,\n\t\t\t\t\"xfs_iformat_btree\", dfp, size,\n\t\t\t\t__this_address);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tifp->if_broot_bytes = size;\n\tifp->if_broot = kmem_alloc(size, KM_NOFS);\n\tASSERT(ifp->if_broot != NULL);\n\t \n\txfs_bmdr_to_bmbt(ip, dfp, XFS_DFORK_SIZE(dip, ip->i_mount, whichfork),\n\t\t\t ifp->if_broot, size);\n\n\tifp->if_bytes = 0;\n\tifp->if_u1.if_root = NULL;\n\tifp->if_height = 0;\n\treturn 0;\n}\n\nint\nxfs_iformat_data_fork(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dinode\t*dip)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tint\t\t\terror;\n\n\t \n\tip->i_df.if_format = dip->di_format;\n\tip->i_df.if_nextents = xfs_dfork_data_extents(dip);\n\tsmp_store_release(&ip->i_df.if_needextents,\n\t\t\t   ip->i_df.if_format == XFS_DINODE_FMT_BTREE ? 1 : 0);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tip->i_disk_size = 0;\n\t\tinode->i_rdev = xfs_to_linux_dev_t(xfs_dinode_get_rdev(dip));\n\t\treturn 0;\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\tcase S_IFDIR:\n\t\tswitch (ip->i_df.if_format) {\n\t\tcase XFS_DINODE_FMT_LOCAL:\n\t\t\terror = xfs_iformat_local(ip, dip, XFS_DATA_FORK,\n\t\t\t\t\tbe64_to_cpu(dip->di_size));\n\t\t\tif (!error)\n\t\t\t\terror = xfs_ifork_verify_local_data(ip);\n\t\t\treturn error;\n\t\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t\treturn xfs_iformat_extents(ip, dip, XFS_DATA_FORK);\n\t\tcase XFS_DINODE_FMT_BTREE:\n\t\t\treturn xfs_iformat_btree(ip, dip, XFS_DATA_FORK);\n\t\tdefault:\n\t\t\txfs_inode_verifier_error(ip, -EFSCORRUPTED, __func__,\n\t\t\t\t\tdip, sizeof(*dip), __this_address);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\txfs_inode_verifier_error(ip, -EFSCORRUPTED, __func__, dip,\n\t\t\t\tsizeof(*dip), __this_address);\n\t\treturn -EFSCORRUPTED;\n\t}\n}\n\nstatic uint16_t\nxfs_dfork_attr_shortform_size(\n\tstruct xfs_dinode\t\t*dip)\n{\n\tstruct xfs_attr_shortform\t*atp =\n\t\t(struct xfs_attr_shortform *)XFS_DFORK_APTR(dip);\n\n\treturn be16_to_cpu(atp->hdr.totsize);\n}\n\nvoid\nxfs_ifork_init_attr(\n\tstruct xfs_inode\t*ip,\n\tenum xfs_dinode_fmt\tformat,\n\txfs_extnum_t\t\tnextents)\n{\n\t \n\tip->i_af.if_format = format;\n\tip->i_af.if_nextents = nextents;\n\tsmp_store_release(&ip->i_af.if_needextents,\n\t\t\t   ip->i_af.if_format == XFS_DINODE_FMT_BTREE ? 1 : 0);\n}\n\nvoid\nxfs_ifork_zap_attr(\n\tstruct xfs_inode\t*ip)\n{\n\txfs_idestroy_fork(&ip->i_af);\n\tmemset(&ip->i_af, 0, sizeof(struct xfs_ifork));\n\tip->i_af.if_format = XFS_DINODE_FMT_EXTENTS;\n}\n\nint\nxfs_iformat_attr_fork(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dinode\t*dip)\n{\n\txfs_extnum_t\t\tnaextents = xfs_dfork_attr_extents(dip);\n\tint\t\t\terror = 0;\n\n\t \n\txfs_ifork_init_attr(ip, dip->di_aformat, naextents);\n\n\tswitch (ip->i_af.if_format) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\terror = xfs_iformat_local(ip, dip, XFS_ATTR_FORK,\n\t\t\t\txfs_dfork_attr_shortform_size(dip));\n\t\tif (!error)\n\t\t\terror = xfs_ifork_verify_local_attr(ip);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\terror = xfs_iformat_extents(ip, dip, XFS_ATTR_FORK);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\terror = xfs_iformat_btree(ip, dip, XFS_ATTR_FORK);\n\t\tbreak;\n\tdefault:\n\t\txfs_inode_verifier_error(ip, error, __func__, dip,\n\t\t\t\tsizeof(*dip), __this_address);\n\t\terror = -EFSCORRUPTED;\n\t\tbreak;\n\t}\n\n\tif (error)\n\t\txfs_ifork_zap_attr(ip);\n\treturn error;\n}\n\n \nvoid\nxfs_iroot_realloc(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\trec_diff,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tcur_max;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_btree_block\t*new_broot;\n\tint\t\t\tnew_max;\n\tsize_t\t\t\tnew_size;\n\tchar\t\t\t*np;\n\tchar\t\t\t*op;\n\n\t \n\tif (rec_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = xfs_ifork_ptr(ip, whichfork);\n\tif (rec_diff > 0) {\n\t\t \n\t\tif (ifp->if_broot_bytes == 0) {\n\t\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, rec_diff);\n\t\t\tifp->if_broot = kmem_alloc(new_size, KM_NOFS);\n\t\t\tifp->if_broot_bytes = (int)new_size;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\t\tnew_max = cur_max + rec_diff;\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\t\tifp->if_broot = krealloc(ifp->if_broot, new_size,\n\t\t\t\t\t GFP_NOFS | __GFP_NOFAIL);\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tifp->if_broot_bytes = (int)new_size;\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\txfs_inode_fork_size(ip, whichfork));\n\t\tmemmove(np, op, cur_max * (uint)sizeof(xfs_fsblock_t));\n\t\treturn;\n\t}\n\n\t \n\tASSERT((ifp->if_broot != NULL) && (ifp->if_broot_bytes > 0));\n\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\tnew_max = cur_max + rec_diff;\n\tASSERT(new_max >= 0);\n\tif (new_max > 0)\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\telse\n\t\tnew_size = 0;\n\tif (new_size > 0) {\n\t\tnew_broot = kmem_alloc(new_size, KM_NOFS);\n\t\t \n\t\tmemcpy(new_broot, ifp->if_broot,\n\t\t\tXFS_BMBT_BLOCK_LEN(ip->i_mount));\n\t} else {\n\t\tnew_broot = NULL;\n\t}\n\n\t \n\tif (new_max > 0) {\n\t\t \n\t\top = (char *)XFS_BMBT_REC_ADDR(mp, ifp->if_broot, 1);\n\t\tnp = (char *)XFS_BMBT_REC_ADDR(mp, new_broot, 1);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_bmbt_rec_t));\n\n\t\t \n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, new_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_fsblock_t));\n\t}\n\tkmem_free(ifp->if_broot);\n\tifp->if_broot = new_broot;\n\tifp->if_broot_bytes = (int)new_size;\n\tif (ifp->if_broot)\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\txfs_inode_fork_size(ip, whichfork));\n\treturn;\n}\n\n\n \nvoid\nxfs_idata_realloc(\n\tstruct xfs_inode\t*ip,\n\tint64_t\t\t\tbyte_diff,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tint64_t\t\t\tnew_size = ifp->if_bytes + byte_diff;\n\n\tASSERT(new_size >= 0);\n\tASSERT(new_size <= xfs_inode_fork_size(ip, whichfork));\n\n\tif (byte_diff == 0)\n\t\treturn;\n\n\tif (new_size == 0) {\n\t\tkmem_free(ifp->if_u1.if_data);\n\t\tifp->if_u1.if_data = NULL;\n\t\tifp->if_bytes = 0;\n\t\treturn;\n\t}\n\n\tifp->if_u1.if_data = krealloc(ifp->if_u1.if_data, new_size,\n\t\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\tifp->if_bytes = new_size;\n}\n\nvoid\nxfs_idestroy_fork(\n\tstruct xfs_ifork\t*ifp)\n{\n\tif (ifp->if_broot != NULL) {\n\t\tkmem_free(ifp->if_broot);\n\t\tifp->if_broot = NULL;\n\t}\n\n\tswitch (ifp->if_format) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tkmem_free(ifp->if_u1.if_data);\n\t\tifp->if_u1.if_data = NULL;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif (ifp->if_height)\n\t\t\txfs_iext_destroy(ifp);\n\t\tbreak;\n\t}\n}\n\n \nint\nxfs_iextents_copy(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_bmbt_rec\t*dp,\n\tint\t\t\twhichfork)\n{\n\tint\t\t\tstate = xfs_bmap_fork_to_state(whichfork);\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tstruct xfs_iext_cursor\ticur;\n\tstruct xfs_bmbt_irec\trec;\n\tint64_t\t\t\tcopied = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL | XFS_ILOCK_SHARED));\n\tASSERT(ifp->if_bytes > 0);\n\n\tfor_each_xfs_iext(ifp, &icur, &rec) {\n\t\tif (isnullstartblock(rec.br_startblock))\n\t\t\tcontinue;\n\t\tASSERT(xfs_bmap_validate_extent(ip, whichfork, &rec) == NULL);\n\t\txfs_bmbt_disk_set_all(dp, &rec);\n\t\ttrace_xfs_write_extent(ip, &icur, state, _RET_IP_);\n\t\tcopied += sizeof(struct xfs_bmbt_rec);\n\t\tdp++;\n\t}\n\n\tASSERT(copied > 0);\n\tASSERT(copied <= ifp->if_bytes);\n\treturn copied;\n}\n\n \nvoid\nxfs_iflush_fork(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dinode\t*dip,\n\tstruct xfs_inode_log_item *iip,\n\tint\t\t\twhichfork)\n{\n\tchar\t\t\t*cp;\n\tstruct xfs_ifork\t*ifp;\n\txfs_mount_t\t\t*mp;\n\tstatic const short\tbrootflag[2] =\n\t\t{ XFS_ILOG_DBROOT, XFS_ILOG_ABROOT };\n\tstatic const short\tdataflag[2] =\n\t\t{ XFS_ILOG_DDATA, XFS_ILOG_ADATA };\n\tstatic const short\textflag[2] =\n\t\t{ XFS_ILOG_DEXT, XFS_ILOG_AEXT };\n\n\tif (!iip)\n\t\treturn;\n\tifp = xfs_ifork_ptr(ip, whichfork);\n\t \n\tif (!ifp) {\n\t\tASSERT(whichfork == XFS_ATTR_FORK);\n\t\treturn;\n\t}\n\tcp = XFS_DFORK_PTR(dip, whichfork);\n\tmp = ip->i_mount;\n\tswitch (ifp->if_format) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif ((iip->ili_fields & dataflag[whichfork]) &&\n\t\t    (ifp->if_bytes > 0)) {\n\t\t\tASSERT(ifp->if_u1.if_data != NULL);\n\t\t\tASSERT(ifp->if_bytes <= xfs_inode_fork_size(ip, whichfork));\n\t\t\tmemcpy(cp, ifp->if_u1.if_data, ifp->if_bytes);\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif ((iip->ili_fields & extflag[whichfork]) &&\n\t\t    (ifp->if_bytes > 0)) {\n\t\t\tASSERT(ifp->if_nextents > 0);\n\t\t\t(void)xfs_iextents_copy(ip, (xfs_bmbt_rec_t *)cp,\n\t\t\t\twhichfork);\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif ((iip->ili_fields & brootflag[whichfork]) &&\n\t\t    (ifp->if_broot_bytes > 0)) {\n\t\t\tASSERT(ifp->if_broot != NULL);\n\t\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\t        xfs_inode_fork_size(ip, whichfork));\n\t\t\txfs_bmbt_to_bmdr(mp, ifp->if_broot, ifp->if_broot_bytes,\n\t\t\t\t(xfs_bmdr_block_t *)cp,\n\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork));\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_DEV:\n\t\tif (iip->ili_fields & XFS_ILOG_DEV) {\n\t\t\tASSERT(whichfork == XFS_DATA_FORK);\n\t\t\txfs_dinode_put_rdev(dip,\n\t\t\t\t\tlinux_to_xfs_dev_t(VFS_I(ip)->i_rdev));\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}\n\n \nstruct xfs_ifork *\nxfs_iext_state_to_fork(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tstate)\n{\n\tif (state & BMAP_COWFORK)\n\t\treturn ip->i_cowfp;\n\telse if (state & BMAP_ATTRFORK)\n\t\treturn &ip->i_af;\n\treturn &ip->i_df;\n}\n\n \nvoid\nxfs_ifork_init_cow(\n\tstruct xfs_inode\t*ip)\n{\n\tif (ip->i_cowfp)\n\t\treturn;\n\n\tip->i_cowfp = kmem_cache_zalloc(xfs_ifork_cache,\n\t\t\t\t       GFP_NOFS | __GFP_NOFAIL);\n\tip->i_cowfp->if_format = XFS_DINODE_FMT_EXTENTS;\n}\n\n \nint\nxfs_ifork_verify_local_data(\n\tstruct xfs_inode\t*ip)\n{\n\txfs_failaddr_t\t\tfa = NULL;\n\n\tswitch (VFS_I(ip)->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tfa = xfs_dir2_sf_verify(ip);\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tfa = xfs_symlink_shortform_verify(ip);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (fa) {\n\t\txfs_inode_verifier_error(ip, -EFSCORRUPTED, \"data fork\",\n\t\t\t\tip->i_df.if_u1.if_data, ip->i_df.if_bytes, fa);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\treturn 0;\n}\n\n \nint\nxfs_ifork_verify_local_attr(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_ifork\t*ifp = &ip->i_af;\n\txfs_failaddr_t\t\tfa;\n\n\tif (!xfs_inode_has_attr_fork(ip))\n\t\tfa = __this_address;\n\telse\n\t\tfa = xfs_attr_shortform_verify(ip);\n\n\tif (fa) {\n\t\txfs_inode_verifier_error(ip, -EFSCORRUPTED, \"attr fork\",\n\t\t\t\tifp->if_u1.if_data, ifp->if_bytes, fa);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\treturn 0;\n}\n\nint\nxfs_iext_count_may_overflow(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tint\t\t\tnr_to_add)\n{\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tuint64_t\t\tmax_exts;\n\tuint64_t\t\tnr_exts;\n\n\tif (whichfork == XFS_COW_FORK)\n\t\treturn 0;\n\n\tmax_exts = xfs_iext_max_nextents(xfs_inode_has_large_extent_counts(ip),\n\t\t\t\twhichfork);\n\n\tif (XFS_TEST_ERROR(false, ip->i_mount, XFS_ERRTAG_REDUCE_MAX_IEXTENTS))\n\t\tmax_exts = 10;\n\n\tnr_exts = ifp->if_nextents + nr_to_add;\n\tif (nr_exts < ifp->if_nextents || nr_exts > max_exts)\n\t\treturn -EFBIG;\n\n\treturn 0;\n}\n\n \nint\nxfs_iext_count_upgrade(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tnr_to_add)\n{\n\tASSERT(nr_to_add <= XFS_MAX_EXTCNT_UPGRADE_NR);\n\n\tif (!xfs_has_large_extent_counts(ip->i_mount) ||\n\t    xfs_inode_has_large_extent_counts(ip) ||\n\t    XFS_TEST_ERROR(false, ip->i_mount, XFS_ERRTAG_REDUCE_MAX_IEXTENTS))\n\t\treturn -EFBIG;\n\n\tip->i_diflags2 |= XFS_DIFLAG2_NREXT64;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}