{
  "module_name": "xfs_ialloc_btree.c",
  "hash_id": "d1cd145dc8f250d78c251c4c7a2aac0af025a4ac562372d66903683b5989676e",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_ialloc_btree.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_btree_staging.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_ag.h\"\n\nstatic struct kmem_cache\t*xfs_inobt_cur_cache;\n\nSTATIC int\nxfs_inobt_get_minrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\treturn M_IGEO(cur->bc_mp)->inobt_mnr[level != 0];\n}\n\nSTATIC struct xfs_btree_cur *\nxfs_inobt_dup_cursor(\n\tstruct xfs_btree_cur\t*cur)\n{\n\treturn xfs_inobt_init_cursor(cur->bc_ag.pag, cur->bc_tp,\n\t\t\tcur->bc_ag.agbp, cur->bc_btnum);\n}\n\nSTATIC void\nxfs_inobt_set_root(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst union xfs_btree_ptr\t*nptr,\n\tint\t\t\t\tinc)\t \n{\n\tstruct xfs_buf\t\t*agbp = cur->bc_ag.agbp;\n\tstruct xfs_agi\t\t*agi = agbp->b_addr;\n\n\tagi->agi_root = nptr->s;\n\tbe32_add_cpu(&agi->agi_level, inc);\n\txfs_ialloc_log_agi(cur->bc_tp, agbp, XFS_AGI_ROOT | XFS_AGI_LEVEL);\n}\n\nSTATIC void\nxfs_finobt_set_root(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst union xfs_btree_ptr\t*nptr,\n\tint\t\t\t\tinc)\t \n{\n\tstruct xfs_buf\t\t*agbp = cur->bc_ag.agbp;\n\tstruct xfs_agi\t\t*agi = agbp->b_addr;\n\n\tagi->agi_free_root = nptr->s;\n\tbe32_add_cpu(&agi->agi_free_level, inc);\n\txfs_ialloc_log_agi(cur->bc_tp, agbp,\n\t\t\t   XFS_AGI_FREE_ROOT | XFS_AGI_FREE_LEVEL);\n}\n\n \nstatic inline void\nxfs_inobt_mod_blockcount(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\thowmuch)\n{\n\tstruct xfs_buf\t\t*agbp = cur->bc_ag.agbp;\n\tstruct xfs_agi\t\t*agi = agbp->b_addr;\n\n\tif (!xfs_has_inobtcounts(cur->bc_mp))\n\t\treturn;\n\n\tif (cur->bc_btnum == XFS_BTNUM_FINO)\n\t\tbe32_add_cpu(&agi->agi_fblocks, howmuch);\n\telse if (cur->bc_btnum == XFS_BTNUM_INO)\n\t\tbe32_add_cpu(&agi->agi_iblocks, howmuch);\n\txfs_ialloc_log_agi(cur->bc_tp, agbp, XFS_AGI_IBLOCKS);\n}\n\nSTATIC int\n__xfs_inobt_alloc_block(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst union xfs_btree_ptr\t*start,\n\tunion xfs_btree_ptr\t\t*new,\n\tint\t\t\t\t*stat,\n\tenum xfs_ag_resv_type\t\tresv)\n{\n\txfs_alloc_arg_t\t\targs;\t\t \n\tint\t\t\terror;\t\t \n\txfs_agblock_t\t\tsbno = be32_to_cpu(start->s);\n\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = cur->bc_tp;\n\targs.mp = cur->bc_mp;\n\targs.pag = cur->bc_ag.pag;\n\targs.oinfo = XFS_RMAP_OINFO_INOBT;\n\targs.minlen = 1;\n\targs.maxlen = 1;\n\targs.prod = 1;\n\targs.resv = resv;\n\n\terror = xfs_alloc_vextent_near_bno(&args,\n\t\t\tXFS_AGB_TO_FSB(args.mp, args.pag->pag_agno, sbno));\n\tif (error)\n\t\treturn error;\n\n\tif (args.fsbno == NULLFSBLOCK) {\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\tASSERT(args.len == 1);\n\n\tnew->s = cpu_to_be32(XFS_FSB_TO_AGBNO(args.mp, args.fsbno));\n\t*stat = 1;\n\txfs_inobt_mod_blockcount(cur, 1);\n\treturn 0;\n}\n\nSTATIC int\nxfs_inobt_alloc_block(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst union xfs_btree_ptr\t*start,\n\tunion xfs_btree_ptr\t\t*new,\n\tint\t\t\t\t*stat)\n{\n\treturn __xfs_inobt_alloc_block(cur, start, new, stat, XFS_AG_RESV_NONE);\n}\n\nSTATIC int\nxfs_finobt_alloc_block(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst union xfs_btree_ptr\t*start,\n\tunion xfs_btree_ptr\t\t*new,\n\tint\t\t\t\t*stat)\n{\n\tif (cur->bc_mp->m_finobt_nores)\n\t\treturn xfs_inobt_alloc_block(cur, start, new, stat);\n\treturn __xfs_inobt_alloc_block(cur, start, new, stat,\n\t\t\tXFS_AG_RESV_METADATA);\n}\n\nSTATIC int\n__xfs_inobt_free_block(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_ag_resv_type\tresv)\n{\n\txfs_fsblock_t\t\tfsbno;\n\n\txfs_inobt_mod_blockcount(cur, -1);\n\tfsbno = XFS_DADDR_TO_FSB(cur->bc_mp, xfs_buf_daddr(bp));\n\treturn xfs_free_extent_later(cur->bc_tp, fsbno, 1,\n\t\t\t&XFS_RMAP_OINFO_INOBT, resv);\n}\n\nSTATIC int\nxfs_inobt_free_block(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp)\n{\n\treturn __xfs_inobt_free_block(cur, bp, XFS_AG_RESV_NONE);\n}\n\nSTATIC int\nxfs_finobt_free_block(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp)\n{\n\tif (cur->bc_mp->m_finobt_nores)\n\t\treturn xfs_inobt_free_block(cur, bp);\n\treturn __xfs_inobt_free_block(cur, bp, XFS_AG_RESV_METADATA);\n}\n\nSTATIC int\nxfs_inobt_get_maxrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\treturn M_IGEO(cur->bc_mp)->inobt_mxr[level != 0];\n}\n\nSTATIC void\nxfs_inobt_init_key_from_rec(\n\tunion xfs_btree_key\t\t*key,\n\tconst union xfs_btree_rec\t*rec)\n{\n\tkey->inobt.ir_startino = rec->inobt.ir_startino;\n}\n\nSTATIC void\nxfs_inobt_init_high_key_from_rec(\n\tunion xfs_btree_key\t\t*key,\n\tconst union xfs_btree_rec\t*rec)\n{\n\t__u32\t\t\t\tx;\n\n\tx = be32_to_cpu(rec->inobt.ir_startino);\n\tx += XFS_INODES_PER_CHUNK - 1;\n\tkey->inobt.ir_startino = cpu_to_be32(x);\n}\n\nSTATIC void\nxfs_inobt_init_rec_from_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec)\n{\n\trec->inobt.ir_startino = cpu_to_be32(cur->bc_rec.i.ir_startino);\n\tif (xfs_has_sparseinodes(cur->bc_mp)) {\n\t\trec->inobt.ir_u.sp.ir_holemask =\n\t\t\t\t\tcpu_to_be16(cur->bc_rec.i.ir_holemask);\n\t\trec->inobt.ir_u.sp.ir_count = cur->bc_rec.i.ir_count;\n\t\trec->inobt.ir_u.sp.ir_freecount = cur->bc_rec.i.ir_freecount;\n\t} else {\n\t\t \n\t\trec->inobt.ir_u.f.ir_freecount =\n\t\t\t\t\tcpu_to_be32(cur->bc_rec.i.ir_freecount);\n\t}\n\trec->inobt.ir_free = cpu_to_be64(cur->bc_rec.i.ir_free);\n}\n\n \nSTATIC void\nxfs_inobt_init_ptr_from_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tstruct xfs_agi\t\t*agi = cur->bc_ag.agbp->b_addr;\n\n\tASSERT(cur->bc_ag.pag->pag_agno == be32_to_cpu(agi->agi_seqno));\n\n\tptr->s = agi->agi_root;\n}\n\nSTATIC void\nxfs_finobt_init_ptr_from_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tstruct xfs_agi\t\t*agi = cur->bc_ag.agbp->b_addr;\n\n\tASSERT(cur->bc_ag.pag->pag_agno == be32_to_cpu(agi->agi_seqno));\n\tptr->s = agi->agi_free_root;\n}\n\nSTATIC int64_t\nxfs_inobt_key_diff(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst union xfs_btree_key\t*key)\n{\n\treturn (int64_t)be32_to_cpu(key->inobt.ir_startino) -\n\t\t\t  cur->bc_rec.i.ir_startino;\n}\n\nSTATIC int64_t\nxfs_inobt_diff_two_keys(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst union xfs_btree_key\t*k1,\n\tconst union xfs_btree_key\t*k2,\n\tconst union xfs_btree_key\t*mask)\n{\n\tASSERT(!mask || mask->inobt.ir_startino);\n\n\treturn (int64_t)be32_to_cpu(k1->inobt.ir_startino) -\n\t\t\tbe32_to_cpu(k2->inobt.ir_startino);\n}\n\nstatic xfs_failaddr_t\nxfs_inobt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\txfs_failaddr_t\t\tfa;\n\tunsigned int\t\tlevel;\n\n\tif (!xfs_verify_magic(bp, block->bb_magic))\n\t\treturn __this_address;\n\n\t \n\tif (xfs_has_crc(mp)) {\n\t\tfa = xfs_btree_sblock_v5hdr_verify(bp);\n\t\tif (fa)\n\t\t\treturn fa;\n\t}\n\n\t \n\tlevel = be16_to_cpu(block->bb_level);\n\tif (level >= M_IGEO(mp)->inobt_maxlevels)\n\t\treturn __this_address;\n\n\treturn xfs_btree_sblock_verify(bp,\n\t\t\tM_IGEO(mp)->inobt_mxr[level != 0]);\n}\n\nstatic void\nxfs_inobt_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\txfs_failaddr_t\tfa;\n\n\tif (!xfs_btree_sblock_verify_crc(bp))\n\t\txfs_verifier_error(bp, -EFSBADCRC, __this_address);\n\telse {\n\t\tfa = xfs_inobt_verify(bp);\n\t\tif (fa)\n\t\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t}\n\n\tif (bp->b_error)\n\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n}\n\nstatic void\nxfs_inobt_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\txfs_failaddr_t\tfa;\n\n\tfa = xfs_inobt_verify(bp);\n\tif (fa) {\n\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t\treturn;\n\t}\n\txfs_btree_sblock_calc_crc(bp);\n\n}\n\nconst struct xfs_buf_ops xfs_inobt_buf_ops = {\n\t.name = \"xfs_inobt\",\n\t.magic = { cpu_to_be32(XFS_IBT_MAGIC), cpu_to_be32(XFS_IBT_CRC_MAGIC) },\n\t.verify_read = xfs_inobt_read_verify,\n\t.verify_write = xfs_inobt_write_verify,\n\t.verify_struct = xfs_inobt_verify,\n};\n\nconst struct xfs_buf_ops xfs_finobt_buf_ops = {\n\t.name = \"xfs_finobt\",\n\t.magic = { cpu_to_be32(XFS_FIBT_MAGIC),\n\t\t   cpu_to_be32(XFS_FIBT_CRC_MAGIC) },\n\t.verify_read = xfs_inobt_read_verify,\n\t.verify_write = xfs_inobt_write_verify,\n\t.verify_struct = xfs_inobt_verify,\n};\n\nSTATIC int\nxfs_inobt_keys_inorder(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst union xfs_btree_key\t*k1,\n\tconst union xfs_btree_key\t*k2)\n{\n\treturn be32_to_cpu(k1->inobt.ir_startino) <\n\t\tbe32_to_cpu(k2->inobt.ir_startino);\n}\n\nSTATIC int\nxfs_inobt_recs_inorder(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst union xfs_btree_rec\t*r1,\n\tconst union xfs_btree_rec\t*r2)\n{\n\treturn be32_to_cpu(r1->inobt.ir_startino) + XFS_INODES_PER_CHUNK <=\n\t\tbe32_to_cpu(r2->inobt.ir_startino);\n}\n\nSTATIC enum xbtree_key_contig\nxfs_inobt_keys_contiguous(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst union xfs_btree_key\t*key1,\n\tconst union xfs_btree_key\t*key2,\n\tconst union xfs_btree_key\t*mask)\n{\n\tASSERT(!mask || mask->inobt.ir_startino);\n\n\treturn xbtree_key_contig(be32_to_cpu(key1->inobt.ir_startino),\n\t\t\t\t be32_to_cpu(key2->inobt.ir_startino));\n}\n\nstatic const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_high_key_from_rec\t= xfs_inobt_init_high_key_from_rec,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n\t.diff_two_keys\t\t= xfs_inobt_diff_two_keys,\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n\t.keys_contiguous\t= xfs_inobt_keys_contiguous,\n};\n\nstatic const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_finobt_alloc_block,\n\t.free_block\t\t= xfs_finobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_high_key_from_rec\t= xfs_inobt_init_high_key_from_rec,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_finobt_buf_ops,\n\t.diff_two_keys\t\t= xfs_inobt_diff_two_keys,\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n\t.keys_contiguous\t= xfs_inobt_keys_contiguous,\n};\n\n \nstatic struct xfs_btree_cur *\nxfs_inobt_init_common(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\t\t \n\txfs_btnum_t\t\tbtnum)\t\t \n{\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = xfs_btree_alloc_cursor(mp, tp, btnum,\n\t\t\tM_IGEO(mp)->inobt_maxlevels, xfs_inobt_cur_cache);\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_statoff = XFS_STATS_CALC_INDEX(xs_ibt_2);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_statoff = XFS_STATS_CALC_INDEX(xs_fibt_2);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tif (xfs_has_crc(mp))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_ag.pag = xfs_perag_hold(pag);\n\treturn cur;\n}\n\n \nstruct xfs_btree_cur *\nxfs_inobt_init_cursor(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\txfs_btnum_t\t\tbtnum)\n{\n\tstruct xfs_btree_cur\t*cur;\n\tstruct xfs_agi\t\t*agi = agbp->b_addr;\n\n\tcur = xfs_inobt_init_common(pag, tp, btnum);\n\tif (btnum == XFS_BTNUM_INO)\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\telse\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\tcur->bc_ag.agbp = agbp;\n\treturn cur;\n}\n\n \nstruct xfs_btree_cur *\nxfs_inobt_stage_cursor(\n\tstruct xfs_perag\t*pag,\n\tstruct xbtree_afakeroot\t*afake,\n\txfs_btnum_t\t\tbtnum)\n{\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = xfs_inobt_init_common(pag, NULL, btnum);\n\txfs_btree_stage_afakeroot(cur, afake);\n\treturn cur;\n}\n\n \nvoid\nxfs_inobt_commit_staged_btree(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp)\n{\n\tstruct xfs_agi\t\t*agi = agbp->b_addr;\n\tstruct xbtree_afakeroot\t*afake = cur->bc_ag.afake;\n\tint\t\t\tfields;\n\n\tASSERT(cur->bc_flags & XFS_BTREE_STAGING);\n\n\tif (cur->bc_btnum == XFS_BTNUM_INO) {\n\t\tfields = XFS_AGI_ROOT | XFS_AGI_LEVEL;\n\t\tagi->agi_root = cpu_to_be32(afake->af_root);\n\t\tagi->agi_level = cpu_to_be32(afake->af_levels);\n\t\tif (xfs_has_inobtcounts(cur->bc_mp)) {\n\t\t\tagi->agi_iblocks = cpu_to_be32(afake->af_blocks);\n\t\t\tfields |= XFS_AGI_IBLOCKS;\n\t\t}\n\t\txfs_ialloc_log_agi(tp, agbp, fields);\n\t\txfs_btree_commit_afakeroot(cur, tp, agbp, &xfs_inobt_ops);\n\t} else {\n\t\tfields = XFS_AGI_FREE_ROOT | XFS_AGI_FREE_LEVEL;\n\t\tagi->agi_free_root = cpu_to_be32(afake->af_root);\n\t\tagi->agi_free_level = cpu_to_be32(afake->af_levels);\n\t\tif (xfs_has_inobtcounts(cur->bc_mp)) {\n\t\t\tagi->agi_fblocks = cpu_to_be32(afake->af_blocks);\n\t\t\tfields |= XFS_AGI_IBLOCKS;\n\t\t}\n\t\txfs_ialloc_log_agi(tp, agbp, fields);\n\t\txfs_btree_commit_afakeroot(cur, tp, agbp, &xfs_finobt_ops);\n\t}\n}\n\n \nstatic inline unsigned int\nxfs_inobt_block_maxrecs(\n\tunsigned int\t\tblocklen,\n\tbool\t\t\tleaf)\n{\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_inobt_rec_t);\n\treturn blocklen / (sizeof(xfs_inobt_key_t) + sizeof(xfs_inobt_ptr_t));\n}\n\n \nint\nxfs_inobt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_INOBT_BLOCK_LEN(mp);\n\treturn xfs_inobt_block_maxrecs(blocklen, leaf);\n}\n\n \n#define XFS_MAX_INODE_RECORDS \\\n\t((XFS_MAX_AG_BYTES - (4 * BBSIZE)) / XFS_DINODE_MIN_SIZE) / \\\n\t\t\tXFS_INODES_PER_CHUNK\n\n \nstatic inline unsigned int\nxfs_inobt_maxlevels_ondisk(void)\n{\n\tunsigned int\t\tminrecs[2];\n\tunsigned int\t\tblocklen;\n\n\tblocklen = min(XFS_MIN_BLOCKSIZE - XFS_BTREE_SBLOCK_LEN,\n\t\t       XFS_MIN_CRC_BLOCKSIZE - XFS_BTREE_SBLOCK_CRC_LEN);\n\n\tminrecs[0] = xfs_inobt_block_maxrecs(blocklen, true) / 2;\n\tminrecs[1] = xfs_inobt_block_maxrecs(blocklen, false) / 2;\n\n\treturn xfs_btree_compute_maxlevels(minrecs, XFS_MAX_INODE_RECORDS);\n}\n\n \nstatic inline unsigned int\nxfs_finobt_maxlevels_ondisk(void)\n{\n\tunsigned int\t\tminrecs[2];\n\tunsigned int\t\tblocklen;\n\n\tblocklen = XFS_MIN_CRC_BLOCKSIZE - XFS_BTREE_SBLOCK_CRC_LEN;\n\n\tminrecs[0] = xfs_inobt_block_maxrecs(blocklen, true) / 2;\n\tminrecs[1] = xfs_inobt_block_maxrecs(blocklen, false) / 2;\n\n\treturn xfs_btree_compute_maxlevels(minrecs, XFS_MAX_INODE_RECORDS);\n}\n\n \nunsigned int\nxfs_iallocbt_maxlevels_ondisk(void)\n{\n\treturn max(xfs_inobt_maxlevels_ondisk(),\n\t\t   xfs_finobt_maxlevels_ondisk());\n}\n\n \nuint64_t\nxfs_inobt_irec_to_allocmask(\n\tconst struct xfs_inobt_rec_incore\t*rec)\n{\n\tuint64_t\t\t\tbitmap = 0;\n\tuint64_t\t\t\tinodespbit;\n\tint\t\t\t\tnextbit;\n\tuint\t\t\t\tallocbitmap;\n\n\t \n\tinodespbit = (1 << XFS_INODES_PER_HOLEMASK_BIT) - 1;\n\n\t \n\tallocbitmap = ~rec->ir_holemask & ((1 << XFS_INOBT_HOLEMASK_BITS) - 1);\n\n\t \n\tnextbit = xfs_next_bit(&allocbitmap, 1, 0);\n\twhile (nextbit != -1) {\n\t\tASSERT(nextbit < (sizeof(rec->ir_holemask) * NBBY));\n\n\t\tbitmap |= (inodespbit <<\n\t\t\t   (nextbit * XFS_INODES_PER_HOLEMASK_BIT));\n\n\t\tnextbit = xfs_next_bit(&allocbitmap, 1, nextbit + 1);\n\t}\n\n\treturn bitmap;\n}\n\n#if defined(DEBUG) || defined(XFS_WARN)\n \nint\nxfs_inobt_rec_check_count(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_inobt_rec_incore\t*rec)\n{\n\tint\t\t\t\tinocount = 0;\n\tint\t\t\t\tnextbit = 0;\n\tuint64_t\t\t\tallocbmap;\n\tint\t\t\t\twordsz;\n\n\twordsz = sizeof(allocbmap) / sizeof(unsigned int);\n\tallocbmap = xfs_inobt_irec_to_allocmask(rec);\n\n\tnextbit = xfs_next_bit((uint *) &allocbmap, wordsz, nextbit);\n\twhile (nextbit != -1) {\n\t\tinocount++;\n\t\tnextbit = xfs_next_bit((uint *) &allocbmap, wordsz,\n\t\t\t\t       nextbit + 1);\n\t}\n\n\tif (inocount != rec->ir_count)\n\t\treturn -EFSCORRUPTED;\n\n\treturn 0;\n}\n#endif\t \n\nstatic xfs_extlen_t\nxfs_inobt_max_size(\n\tstruct xfs_perag\t*pag)\n{\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\txfs_agblock_t\t\tagblocks = pag->block_count;\n\n\t \n\tif (M_IGEO(mp)->inobt_mxr[0] == 0)\n\t\treturn 0;\n\n\t \n\tif (xfs_ag_contains_log(mp, pag->pag_agno))\n\t\tagblocks -= mp->m_sb.sb_logblocks;\n\n\treturn xfs_btree_calc_size(M_IGEO(mp)->inobt_mnr,\n\t\t\t\t(uint64_t)agblocks * mp->m_sb.sb_inopblock /\n\t\t\t\t\tXFS_INODES_PER_CHUNK);\n}\n\n \nint\nxfs_inobt_cur(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\txfs_btnum_t\t\twhich,\n\tstruct xfs_btree_cur\t**curpp,\n\tstruct xfs_buf\t\t**agi_bpp)\n{\n\tstruct xfs_btree_cur\t*cur;\n\tint\t\t\terror;\n\n\tASSERT(*agi_bpp == NULL);\n\tASSERT(*curpp == NULL);\n\n\terror = xfs_ialloc_read_agi(pag, tp, agi_bpp);\n\tif (error)\n\t\treturn error;\n\n\tcur = xfs_inobt_init_cursor(pag, tp, *agi_bpp, which);\n\t*curpp = cur;\n\treturn 0;\n}\n\nstatic int\nxfs_inobt_count_blocks(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\txfs_btnum_t\t\tbtnum,\n\txfs_extlen_t\t\t*tree_blocks)\n{\n\tstruct xfs_buf\t\t*agbp = NULL;\n\tstruct xfs_btree_cur\t*cur = NULL;\n\tint\t\t\terror;\n\n\terror = xfs_inobt_cur(pag, tp, btnum, &cur, &agbp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_btree_count_blocks(cur, tree_blocks);\n\txfs_btree_del_cursor(cur, error);\n\txfs_trans_brelse(tp, agbp);\n\n\treturn error;\n}\n\n \nstatic int\nxfs_finobt_read_blocks(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\txfs_extlen_t\t\t*tree_blocks)\n{\n\tstruct xfs_buf\t\t*agbp;\n\tstruct xfs_agi\t\t*agi;\n\tint\t\t\terror;\n\n\terror = xfs_ialloc_read_agi(pag, tp, &agbp);\n\tif (error)\n\t\treturn error;\n\n\tagi = agbp->b_addr;\n\t*tree_blocks = be32_to_cpu(agi->agi_fblocks);\n\txfs_trans_brelse(tp, agbp);\n\treturn 0;\n}\n\n \nint\nxfs_finobt_calc_reserves(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\txfs_extlen_t\t\t*ask,\n\txfs_extlen_t\t\t*used)\n{\n\txfs_extlen_t\t\ttree_len = 0;\n\tint\t\t\terror;\n\n\tif (!xfs_has_finobt(pag->pag_mount))\n\t\treturn 0;\n\n\tif (xfs_has_inobtcounts(pag->pag_mount))\n\t\terror = xfs_finobt_read_blocks(pag, tp, &tree_len);\n\telse\n\t\terror = xfs_inobt_count_blocks(pag, tp, XFS_BTNUM_FINO,\n\t\t\t\t&tree_len);\n\tif (error)\n\t\treturn error;\n\n\t*ask += xfs_inobt_max_size(pag);\n\t*used += tree_len;\n\treturn 0;\n}\n\n \nxfs_extlen_t\nxfs_iallocbt_calc_size(\n\tstruct xfs_mount\t*mp,\n\tunsigned long long\tlen)\n{\n\treturn xfs_btree_calc_size(M_IGEO(mp)->inobt_mnr, len);\n}\n\nint __init\nxfs_inobt_init_cur_cache(void)\n{\n\txfs_inobt_cur_cache = kmem_cache_create(\"xfs_inobt_cur\",\n\t\t\txfs_btree_cur_sizeof(xfs_inobt_maxlevels_ondisk()),\n\t\t\t0, 0, NULL);\n\n\tif (!xfs_inobt_cur_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid\nxfs_inobt_destroy_cur_cache(void)\n{\n\tkmem_cache_destroy(xfs_inobt_cur_cache);\n\txfs_inobt_cur_cache = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}