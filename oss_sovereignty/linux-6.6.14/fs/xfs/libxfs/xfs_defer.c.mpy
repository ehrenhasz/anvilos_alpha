{
  "module_name": "xfs_defer.c",
  "hash_id": "dd98f5692dcacb5a9ecdf3b2e74070b0d5f27102c90890859cfa3a22e411c062",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_defer.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_refcount.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_attr.h\"\n\nstatic struct kmem_cache\t*xfs_defer_pending_cache;\n\n \n\nstatic const struct xfs_defer_op_type *defer_op_types[] = {\n\t[XFS_DEFER_OPS_TYPE_BMAP]\t= &xfs_bmap_update_defer_type,\n\t[XFS_DEFER_OPS_TYPE_REFCOUNT]\t= &xfs_refcount_update_defer_type,\n\t[XFS_DEFER_OPS_TYPE_RMAP]\t= &xfs_rmap_update_defer_type,\n\t[XFS_DEFER_OPS_TYPE_FREE]\t= &xfs_extent_free_defer_type,\n\t[XFS_DEFER_OPS_TYPE_AGFL_FREE]\t= &xfs_agfl_free_defer_type,\n\t[XFS_DEFER_OPS_TYPE_ATTR]\t= &xfs_attr_defer_type,\n};\n\n \nstatic int\nxfs_defer_create_intent(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_defer_pending\t*dfp,\n\tbool\t\t\t\tsort)\n{\n\tconst struct xfs_defer_op_type\t*ops = defer_op_types[dfp->dfp_type];\n\tstruct xfs_log_item\t\t*lip;\n\n\tif (dfp->dfp_intent)\n\t\treturn 1;\n\n\tlip = ops->create_intent(tp, &dfp->dfp_work, dfp->dfp_count, sort);\n\tif (!lip)\n\t\treturn 0;\n\tif (IS_ERR(lip))\n\t\treturn PTR_ERR(lip);\n\n\tdfp->dfp_intent = lip;\n\treturn 1;\n}\n\n \nstatic int\nxfs_defer_create_intents(\n\tstruct xfs_trans\t\t*tp)\n{\n\tstruct xfs_defer_pending\t*dfp;\n\tint\t\t\t\tret = 0;\n\n\tlist_for_each_entry(dfp, &tp->t_dfops, dfp_list) {\n\t\tint\t\t\tret2;\n\n\t\ttrace_xfs_defer_create_intent(tp->t_mountp, dfp);\n\t\tret2 = xfs_defer_create_intent(tp, dfp, true);\n\t\tif (ret2 < 0)\n\t\t\treturn ret2;\n\t\tret |= ret2;\n\t}\n\treturn ret;\n}\n\n \nSTATIC void\nxfs_defer_trans_abort(\n\tstruct xfs_trans\t\t*tp,\n\tstruct list_head\t\t*dop_pending)\n{\n\tstruct xfs_defer_pending\t*dfp;\n\tconst struct xfs_defer_op_type\t*ops;\n\n\ttrace_xfs_defer_trans_abort(tp, _RET_IP_);\n\n\t \n\tlist_for_each_entry(dfp, dop_pending, dfp_list) {\n\t\tops = defer_op_types[dfp->dfp_type];\n\t\ttrace_xfs_defer_pending_abort(tp->t_mountp, dfp);\n\t\tif (dfp->dfp_intent && !dfp->dfp_done) {\n\t\t\tops->abort_intent(dfp->dfp_intent);\n\t\t\tdfp->dfp_intent = NULL;\n\t\t}\n\t}\n}\n\n \nstatic int\nxfs_defer_save_resources(\n\tstruct xfs_defer_resources\t*dres,\n\tstruct xfs_trans\t\t*tp)\n{\n\tstruct xfs_buf_log_item\t\t*bli;\n\tstruct xfs_inode_log_item\t*ili;\n\tstruct xfs_log_item\t\t*lip;\n\n\tBUILD_BUG_ON(NBBY * sizeof(dres->dr_ordered) < XFS_DEFER_OPS_NR_BUFS);\n\n\tlist_for_each_entry(lip, &tp->t_items, li_trans) {\n\t\tswitch (lip->li_type) {\n\t\tcase XFS_LI_BUF:\n\t\t\tbli = container_of(lip, struct xfs_buf_log_item,\n\t\t\t\t\t   bli_item);\n\t\t\tif (bli->bli_flags & XFS_BLI_HOLD) {\n\t\t\t\tif (dres->dr_bufs >= XFS_DEFER_OPS_NR_BUFS) {\n\t\t\t\t\tASSERT(0);\n\t\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t\t}\n\t\t\t\tif (bli->bli_flags & XFS_BLI_ORDERED)\n\t\t\t\t\tdres->dr_ordered |=\n\t\t\t\t\t\t\t(1U << dres->dr_bufs);\n\t\t\t\telse\n\t\t\t\t\txfs_trans_dirty_buf(tp, bli->bli_buf);\n\t\t\t\tdres->dr_bp[dres->dr_bufs++] = bli->bli_buf;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase XFS_LI_INODE:\n\t\t\tili = container_of(lip, struct xfs_inode_log_item,\n\t\t\t\t\t   ili_item);\n\t\t\tif (ili->ili_lock_flags == 0) {\n\t\t\t\tif (dres->dr_inos >= XFS_DEFER_OPS_NR_INODES) {\n\t\t\t\t\tASSERT(0);\n\t\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t\t}\n\t\t\t\txfs_trans_log_inode(tp, ili->ili_inode,\n\t\t\t\t\t\t    XFS_ILOG_CORE);\n\t\t\t\tdres->dr_ip[dres->dr_inos++] = ili->ili_inode;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\nxfs_defer_restore_resources(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_defer_resources\t*dres)\n{\n\tunsigned short\t\t\ti;\n\n\t \n\tfor (i = 0; i < dres->dr_inos; i++)\n\t\txfs_trans_ijoin(tp, dres->dr_ip[i], 0);\n\n\t \n\tfor (i = 0; i < dres->dr_bufs; i++) {\n\t\txfs_trans_bjoin(tp, dres->dr_bp[i]);\n\t\tif (dres->dr_ordered & (1U << i))\n\t\t\txfs_trans_ordered_buf(tp, dres->dr_bp[i]);\n\t\txfs_trans_bhold(tp, dres->dr_bp[i]);\n\t}\n}\n\n \nSTATIC int\nxfs_defer_trans_roll(\n\tstruct xfs_trans\t\t**tpp)\n{\n\tstruct xfs_defer_resources\tdres = { };\n\tint\t\t\t\terror;\n\n\terror = xfs_defer_save_resources(&dres, *tpp);\n\tif (error)\n\t\treturn error;\n\n\ttrace_xfs_defer_trans_roll(*tpp, _RET_IP_);\n\n\t \n\terror = xfs_trans_roll(tpp);\n\n\txfs_defer_restore_resources(*tpp, &dres);\n\n\tif (error)\n\t\ttrace_xfs_defer_trans_roll_error(*tpp, error);\n\treturn error;\n}\n\n \nstatic void\nxfs_defer_cancel_list(\n\tstruct xfs_mount\t\t*mp,\n\tstruct list_head\t\t*dop_list)\n{\n\tstruct xfs_defer_pending\t*dfp;\n\tstruct xfs_defer_pending\t*pli;\n\tstruct list_head\t\t*pwi;\n\tstruct list_head\t\t*n;\n\tconst struct xfs_defer_op_type\t*ops;\n\n\t \n\tlist_for_each_entry_safe(dfp, pli, dop_list, dfp_list) {\n\t\tops = defer_op_types[dfp->dfp_type];\n\t\ttrace_xfs_defer_cancel_list(mp, dfp);\n\t\tlist_del(&dfp->dfp_list);\n\t\tlist_for_each_safe(pwi, n, &dfp->dfp_work) {\n\t\t\tlist_del(pwi);\n\t\t\tdfp->dfp_count--;\n\t\t\ttrace_xfs_defer_cancel_item(mp, dfp, pwi);\n\t\t\tops->cancel_item(pwi);\n\t\t}\n\t\tASSERT(dfp->dfp_count == 0);\n\t\tkmem_cache_free(xfs_defer_pending_cache, dfp);\n\t}\n}\n\n \nstatic int\nxfs_defer_relog(\n\tstruct xfs_trans\t\t**tpp,\n\tstruct list_head\t\t*dfops)\n{\n\tstruct xlog\t\t\t*log = (*tpp)->t_mountp->m_log;\n\tstruct xfs_defer_pending\t*dfp;\n\txfs_lsn_t\t\t\tthreshold_lsn = NULLCOMMITLSN;\n\n\n\tASSERT((*tpp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\n\tlist_for_each_entry(dfp, dfops, dfp_list) {\n\t\t \n\t\tif (dfp->dfp_intent == NULL ||\n\t\t    xfs_log_item_in_current_chkpt(dfp->dfp_intent))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (threshold_lsn == NULLCOMMITLSN) {\n\t\t\tthreshold_lsn = xlog_grant_push_threshold(log, 0);\n\t\t\tif (threshold_lsn == NULLCOMMITLSN)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (XFS_LSN_CMP(dfp->dfp_intent->li_lsn, threshold_lsn) >= 0)\n\t\t\tcontinue;\n\n\t\ttrace_xfs_defer_relog_intent((*tpp)->t_mountp, dfp);\n\t\tXFS_STATS_INC((*tpp)->t_mountp, defer_relog);\n\t\tdfp->dfp_intent = xfs_trans_item_relog(dfp->dfp_intent, *tpp);\n\t}\n\n\tif ((*tpp)->t_flags & XFS_TRANS_DIRTY)\n\t\treturn xfs_defer_trans_roll(tpp);\n\treturn 0;\n}\n\n \nstatic int\nxfs_defer_finish_one(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_defer_pending\t*dfp)\n{\n\tconst struct xfs_defer_op_type\t*ops = defer_op_types[dfp->dfp_type];\n\tstruct xfs_btree_cur\t\t*state = NULL;\n\tstruct list_head\t\t*li, *n;\n\tint\t\t\t\terror;\n\n\ttrace_xfs_defer_pending_finish(tp->t_mountp, dfp);\n\n\tdfp->dfp_done = ops->create_done(tp, dfp->dfp_intent, dfp->dfp_count);\n\tlist_for_each_safe(li, n, &dfp->dfp_work) {\n\t\tlist_del(li);\n\t\tdfp->dfp_count--;\n\t\ttrace_xfs_defer_finish_item(tp->t_mountp, dfp, li);\n\t\terror = ops->finish_item(tp, dfp->dfp_done, li, &state);\n\t\tif (error == -EAGAIN) {\n\t\t\tint\t\tret;\n\n\t\t\t \n\t\t\tlist_add(li, &dfp->dfp_work);\n\t\t\tdfp->dfp_count++;\n\t\t\tdfp->dfp_done = NULL;\n\t\t\tdfp->dfp_intent = NULL;\n\t\t\tret = xfs_defer_create_intent(tp, dfp, false);\n\t\t\tif (ret < 0)\n\t\t\t\terror = ret;\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t \n\tlist_del(&dfp->dfp_list);\n\tkmem_cache_free(xfs_defer_pending_cache, dfp);\nout:\n\tif (ops->finish_cleanup)\n\t\tops->finish_cleanup(tp, state, error);\n\treturn error;\n}\n\n \nint\nxfs_defer_finish_noroll(\n\tstruct xfs_trans\t\t**tp)\n{\n\tstruct xfs_defer_pending\t*dfp = NULL;\n\tint\t\t\t\terror = 0;\n\tLIST_HEAD(dop_pending);\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\n\ttrace_xfs_defer_finish(*tp, _RET_IP_);\n\n\t \n\twhile (!list_empty(&dop_pending) || !list_empty(&(*tp)->t_dfops)) {\n\t\t \n\t\tint has_intents = xfs_defer_create_intents(*tp);\n\n\t\tlist_splice_init(&(*tp)->t_dfops, &dop_pending);\n\n\t\tif (has_intents < 0) {\n\t\t\terror = has_intents;\n\t\t\tgoto out_shutdown;\n\t\t}\n\t\tif (has_intents || dfp) {\n\t\t\terror = xfs_defer_trans_roll(tp);\n\t\t\tif (error)\n\t\t\t\tgoto out_shutdown;\n\n\t\t\t \n\t\t\terror = xfs_defer_relog(tp, &dop_pending);\n\t\t\tif (error)\n\t\t\t\tgoto out_shutdown;\n\t\t}\n\n\t\tdfp = list_first_entry(&dop_pending, struct xfs_defer_pending,\n\t\t\t\t       dfp_list);\n\t\terror = xfs_defer_finish_one(*tp, dfp);\n\t\tif (error && error != -EAGAIN)\n\t\t\tgoto out_shutdown;\n\t}\n\n\ttrace_xfs_defer_finish_done(*tp, _RET_IP_);\n\treturn 0;\n\nout_shutdown:\n\txfs_defer_trans_abort(*tp, &dop_pending);\n\txfs_force_shutdown((*tp)->t_mountp, SHUTDOWN_CORRUPT_INCORE);\n\ttrace_xfs_defer_finish_error(*tp, error);\n\txfs_defer_cancel_list((*tp)->t_mountp, &dop_pending);\n\txfs_defer_cancel(*tp);\n\treturn error;\n}\n\nint\nxfs_defer_finish(\n\tstruct xfs_trans\t**tp)\n{\n\tint\t\t\terror;\n\n\t \n\terror = xfs_defer_finish_noroll(tp);\n\tif (error)\n\t\treturn error;\n\tif ((*tp)->t_flags & XFS_TRANS_DIRTY) {\n\t\terror = xfs_defer_trans_roll(tp);\n\t\tif (error) {\n\t\t\txfs_force_shutdown((*tp)->t_mountp,\n\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t \n\tASSERT(list_empty(&(*tp)->t_dfops));\n\t(*tp)->t_flags &= ~XFS_TRANS_LOWMODE;\n\treturn 0;\n}\n\nvoid\nxfs_defer_cancel(\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\n\ttrace_xfs_defer_cancel(tp, _RET_IP_);\n\txfs_defer_cancel_list(mp, &tp->t_dfops);\n}\n\n \nvoid\nxfs_defer_add(\n\tstruct xfs_trans\t\t*tp,\n\tenum xfs_defer_ops_type\t\ttype,\n\tstruct list_head\t\t*li)\n{\n\tstruct xfs_defer_pending\t*dfp = NULL;\n\tconst struct xfs_defer_op_type\t*ops = defer_op_types[type];\n\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tBUILD_BUG_ON(ARRAY_SIZE(defer_op_types) != XFS_DEFER_OPS_TYPE_MAX);\n\n\t \n\tif (!list_empty(&tp->t_dfops)) {\n\t\tdfp = list_last_entry(&tp->t_dfops,\n\t\t\t\tstruct xfs_defer_pending, dfp_list);\n\t\tif (dfp->dfp_type != type ||\n\t\t    (ops->max_items && dfp->dfp_count >= ops->max_items))\n\t\t\tdfp = NULL;\n\t}\n\tif (!dfp) {\n\t\tdfp = kmem_cache_zalloc(xfs_defer_pending_cache,\n\t\t\t\tGFP_NOFS | __GFP_NOFAIL);\n\t\tdfp->dfp_type = type;\n\t\tdfp->dfp_intent = NULL;\n\t\tdfp->dfp_done = NULL;\n\t\tdfp->dfp_count = 0;\n\t\tINIT_LIST_HEAD(&dfp->dfp_work);\n\t\tlist_add_tail(&dfp->dfp_list, &tp->t_dfops);\n\t}\n\n\tlist_add_tail(li, &dfp->dfp_work);\n\ttrace_xfs_defer_add_item(tp->t_mountp, dfp, li);\n\tdfp->dfp_count++;\n}\n\n \nvoid\nxfs_defer_move(\n\tstruct xfs_trans\t*dtp,\n\tstruct xfs_trans\t*stp)\n{\n\tlist_splice_init(&stp->t_dfops, &dtp->t_dfops);\n\n\t \n\tdtp->t_flags |= (stp->t_flags & XFS_TRANS_LOWMODE);\n\tstp->t_flags &= ~XFS_TRANS_LOWMODE;\n}\n\n \nstatic struct xfs_defer_capture *\nxfs_defer_ops_capture(\n\tstruct xfs_trans\t\t*tp)\n{\n\tstruct xfs_defer_capture\t*dfc;\n\tunsigned short\t\t\ti;\n\tint\t\t\t\terror;\n\n\tif (list_empty(&tp->t_dfops))\n\t\treturn NULL;\n\n\terror = xfs_defer_create_intents(tp);\n\tif (error < 0)\n\t\treturn ERR_PTR(error);\n\n\t \n\tdfc = kmem_zalloc(sizeof(*dfc), KM_NOFS);\n\tINIT_LIST_HEAD(&dfc->dfc_list);\n\tINIT_LIST_HEAD(&dfc->dfc_dfops);\n\n\t \n\tlist_splice_init(&tp->t_dfops, &dfc->dfc_dfops);\n\tdfc->dfc_tpflags = tp->t_flags & XFS_TRANS_LOWMODE;\n\ttp->t_flags &= ~XFS_TRANS_LOWMODE;\n\n\t \n\tdfc->dfc_blkres = tp->t_blk_res - tp->t_blk_res_used;\n\tdfc->dfc_rtxres = tp->t_rtx_res - tp->t_rtx_res_used;\n\n\t \n\tdfc->dfc_logres = tp->t_log_res;\n\n\terror = xfs_defer_save_resources(&dfc->dfc_held, tp);\n\tif (error) {\n\t\t \n\t\txfs_force_shutdown(tp->t_mountp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n\n\t \n\tfor (i = 0; i < dfc->dfc_held.dr_inos; i++) {\n\t\tASSERT(xfs_isilocked(dfc->dfc_held.dr_ip[i], XFS_ILOCK_EXCL));\n\t\tihold(VFS_I(dfc->dfc_held.dr_ip[i]));\n\t}\n\n\tfor (i = 0; i < dfc->dfc_held.dr_bufs; i++)\n\t\txfs_buf_hold(dfc->dfc_held.dr_bp[i]);\n\n\treturn dfc;\n}\n\n \nvoid\nxfs_defer_ops_capture_free(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_defer_capture\t*dfc)\n{\n\tunsigned short\t\t\ti;\n\n\txfs_defer_cancel_list(mp, &dfc->dfc_dfops);\n\n\tfor (i = 0; i < dfc->dfc_held.dr_bufs; i++)\n\t\txfs_buf_relse(dfc->dfc_held.dr_bp[i]);\n\n\tfor (i = 0; i < dfc->dfc_held.dr_inos; i++)\n\t\txfs_irele(dfc->dfc_held.dr_ip[i]);\n\n\tkmem_free(dfc);\n}\n\n \nint\nxfs_defer_ops_capture_and_commit(\n\tstruct xfs_trans\t\t*tp,\n\tstruct list_head\t\t*capture_list)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_defer_capture\t*dfc;\n\tint\t\t\t\terror;\n\n\t \n\tdfc = xfs_defer_ops_capture(tp);\n\tif (IS_ERR(dfc)) {\n\t\txfs_trans_cancel(tp);\n\t\treturn PTR_ERR(dfc);\n\t}\n\tif (!dfc)\n\t\treturn xfs_trans_commit(tp);\n\n\t \n\terror = xfs_trans_commit(tp);\n\tif (error) {\n\t\txfs_defer_ops_capture_free(mp, dfc);\n\t\treturn error;\n\t}\n\n\tlist_add_tail(&dfc->dfc_list, capture_list);\n\treturn 0;\n}\n\n \nvoid\nxfs_defer_ops_continue(\n\tstruct xfs_defer_capture\t*dfc,\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_defer_resources\t*dres)\n{\n\tunsigned int\t\t\ti;\n\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(!(tp->t_flags & XFS_TRANS_DIRTY));\n\n\t \n\tif (dfc->dfc_held.dr_inos == 2)\n\t\txfs_lock_two_inodes(dfc->dfc_held.dr_ip[0], XFS_ILOCK_EXCL,\n\t\t\t\t    dfc->dfc_held.dr_ip[1], XFS_ILOCK_EXCL);\n\telse if (dfc->dfc_held.dr_inos == 1)\n\t\txfs_ilock(dfc->dfc_held.dr_ip[0], XFS_ILOCK_EXCL);\n\n\tfor (i = 0; i < dfc->dfc_held.dr_bufs; i++)\n\t\txfs_buf_lock(dfc->dfc_held.dr_bp[i]);\n\n\t \n\txfs_defer_restore_resources(tp, &dfc->dfc_held);\n\tmemcpy(dres, &dfc->dfc_held, sizeof(struct xfs_defer_resources));\n\tdres->dr_bufs = 0;\n\n\t \n\tlist_splice_init(&dfc->dfc_dfops, &tp->t_dfops);\n\ttp->t_flags |= dfc->dfc_tpflags;\n\n\tkmem_free(dfc);\n}\n\n \nvoid\nxfs_defer_resources_rele(\n\tstruct xfs_defer_resources\t*dres)\n{\n\tunsigned short\t\t\ti;\n\n\tfor (i = 0; i < dres->dr_inos; i++) {\n\t\txfs_iunlock(dres->dr_ip[i], XFS_ILOCK_EXCL);\n\t\txfs_irele(dres->dr_ip[i]);\n\t\tdres->dr_ip[i] = NULL;\n\t}\n\n\tfor (i = 0; i < dres->dr_bufs; i++) {\n\t\txfs_buf_relse(dres->dr_bp[i]);\n\t\tdres->dr_bp[i] = NULL;\n\t}\n\n\tdres->dr_inos = 0;\n\tdres->dr_bufs = 0;\n\tdres->dr_ordered = 0;\n}\n\nstatic inline int __init\nxfs_defer_init_cache(void)\n{\n\txfs_defer_pending_cache = kmem_cache_create(\"xfs_defer_pending\",\n\t\t\tsizeof(struct xfs_defer_pending),\n\t\t\t0, 0, NULL);\n\n\treturn xfs_defer_pending_cache != NULL ? 0 : -ENOMEM;\n}\n\nstatic inline void\nxfs_defer_destroy_cache(void)\n{\n\tkmem_cache_destroy(xfs_defer_pending_cache);\n\txfs_defer_pending_cache = NULL;\n}\n\n \nint __init\nxfs_defer_init_item_caches(void)\n{\n\tint\t\t\t\terror;\n\n\terror = xfs_defer_init_cache();\n\tif (error)\n\t\treturn error;\n\terror = xfs_rmap_intent_init_cache();\n\tif (error)\n\t\tgoto err;\n\terror = xfs_refcount_intent_init_cache();\n\tif (error)\n\t\tgoto err;\n\terror = xfs_bmap_intent_init_cache();\n\tif (error)\n\t\tgoto err;\n\terror = xfs_extfree_intent_init_cache();\n\tif (error)\n\t\tgoto err;\n\terror = xfs_attr_intent_init_cache();\n\tif (error)\n\t\tgoto err;\n\treturn 0;\nerr:\n\txfs_defer_destroy_item_caches();\n\treturn error;\n}\n\n \nvoid\nxfs_defer_destroy_item_caches(void)\n{\n\txfs_attr_intent_destroy_cache();\n\txfs_extfree_intent_destroy_cache();\n\txfs_bmap_intent_destroy_cache();\n\txfs_refcount_intent_destroy_cache();\n\txfs_rmap_intent_destroy_cache();\n\txfs_defer_destroy_cache();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}