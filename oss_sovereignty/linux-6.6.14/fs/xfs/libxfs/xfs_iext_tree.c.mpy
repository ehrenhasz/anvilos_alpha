{
  "module_name": "xfs_iext_tree.c",
  "hash_id": "6cc6e36bd5db26963ab7cbf84291f596024ec7a3bb737f61b20b373cf5c0e7ed",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_iext_tree.c",
  "human_readable_source": "\n \n\n#include \"xfs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trace.h\"\n\n \n#define XFS_IEXT_STARTOFF_MASK\t\txfs_mask64lo(BMBT_STARTOFF_BITLEN)\n#define XFS_IEXT_LENGTH_MASK\t\txfs_mask64lo(BMBT_BLOCKCOUNT_BITLEN)\n#define XFS_IEXT_STARTBLOCK_MASK\txfs_mask64lo(BMBT_STARTBLOCK_BITLEN)\n\nstruct xfs_iext_rec {\n\tuint64_t\t\t\tlo;\n\tuint64_t\t\t\thi;\n};\n\n \nstatic bool xfs_iext_rec_is_empty(struct xfs_iext_rec *rec)\n{\n\treturn rec->hi == 0;\n}\n\nstatic inline void xfs_iext_rec_clear(struct xfs_iext_rec *rec)\n{\n\trec->lo = 0;\n\trec->hi = 0;\n}\n\nstatic void\nxfs_iext_set(\n\tstruct xfs_iext_rec\t*rec,\n\tstruct xfs_bmbt_irec\t*irec)\n{\n\tASSERT((irec->br_startoff & ~XFS_IEXT_STARTOFF_MASK) == 0);\n\tASSERT((irec->br_blockcount & ~XFS_IEXT_LENGTH_MASK) == 0);\n\tASSERT((irec->br_startblock & ~XFS_IEXT_STARTBLOCK_MASK) == 0);\n\n\trec->lo = irec->br_startoff & XFS_IEXT_STARTOFF_MASK;\n\trec->hi = irec->br_blockcount & XFS_IEXT_LENGTH_MASK;\n\n\trec->lo |= (irec->br_startblock << 54);\n\trec->hi |= ((irec->br_startblock & ~xfs_mask64lo(10)) << (22 - 10));\n\n\tif (irec->br_state == XFS_EXT_UNWRITTEN)\n\t\trec->hi |= (1 << 21);\n}\n\nstatic void\nxfs_iext_get(\n\tstruct xfs_bmbt_irec\t*irec,\n\tstruct xfs_iext_rec\t*rec)\n{\n\tirec->br_startoff = rec->lo & XFS_IEXT_STARTOFF_MASK;\n\tirec->br_blockcount = rec->hi & XFS_IEXT_LENGTH_MASK;\n\n\tirec->br_startblock = rec->lo >> 54;\n\tirec->br_startblock |= (rec->hi & xfs_mask64hi(42)) >> (22 - 10);\n\n\tif (rec->hi & (1 << 21))\n\t\tirec->br_state = XFS_EXT_UNWRITTEN;\n\telse\n\t\tirec->br_state = XFS_EXT_NORM;\n}\n\nenum {\n\tNODE_SIZE\t= 256,\n\tKEYS_PER_NODE\t= NODE_SIZE / (sizeof(uint64_t) + sizeof(void *)),\n\tRECS_PER_LEAF\t= (NODE_SIZE - (2 * sizeof(struct xfs_iext_leaf *))) /\n\t\t\t\tsizeof(struct xfs_iext_rec),\n};\n\n \nstruct xfs_iext_node {\n\tuint64_t\t\tkeys[KEYS_PER_NODE];\n#define XFS_IEXT_KEY_INVALID\t(1ULL << 63)\n\tvoid\t\t\t*ptrs[KEYS_PER_NODE];\n};\n\nstruct xfs_iext_leaf {\n\tstruct xfs_iext_rec\trecs[RECS_PER_LEAF];\n\tstruct xfs_iext_leaf\t*prev;\n\tstruct xfs_iext_leaf\t*next;\n};\n\ninline xfs_extnum_t xfs_iext_count(struct xfs_ifork *ifp)\n{\n\treturn ifp->if_bytes / sizeof(struct xfs_iext_rec);\n}\n\nstatic inline int xfs_iext_max_recs(struct xfs_ifork *ifp)\n{\n\tif (ifp->if_height == 1)\n\t\treturn xfs_iext_count(ifp);\n\treturn RECS_PER_LEAF;\n}\n\nstatic inline struct xfs_iext_rec *cur_rec(struct xfs_iext_cursor *cur)\n{\n\treturn &cur->leaf->recs[cur->pos];\n}\n\nstatic inline bool xfs_iext_valid(struct xfs_ifork *ifp,\n\t\tstruct xfs_iext_cursor *cur)\n{\n\tif (!cur->leaf)\n\t\treturn false;\n\tif (cur->pos < 0 || cur->pos >= xfs_iext_max_recs(ifp))\n\t\treturn false;\n\tif (xfs_iext_rec_is_empty(cur_rec(cur)))\n\t\treturn false;\n\treturn true;\n}\n\nstatic void *\nxfs_iext_find_first_leaf(\n\tstruct xfs_ifork\t*ifp)\n{\n\tstruct xfs_iext_node\t*node = ifp->if_u1.if_root;\n\tint\t\t\theight;\n\n\tif (!ifp->if_height)\n\t\treturn NULL;\n\n\tfor (height = ifp->if_height; height > 1; height--) {\n\t\tnode = node->ptrs[0];\n\t\tASSERT(node);\n\t}\n\n\treturn node;\n}\n\nstatic void *\nxfs_iext_find_last_leaf(\n\tstruct xfs_ifork\t*ifp)\n{\n\tstruct xfs_iext_node\t*node = ifp->if_u1.if_root;\n\tint\t\t\theight, i;\n\n\tif (!ifp->if_height)\n\t\treturn NULL;\n\n\tfor (height = ifp->if_height; height > 1; height--) {\n\t\tfor (i = 1; i < KEYS_PER_NODE; i++)\n\t\t\tif (!node->ptrs[i])\n\t\t\t\tbreak;\n\t\tnode = node->ptrs[i - 1];\n\t\tASSERT(node);\n\t}\n\n\treturn node;\n}\n\nvoid\nxfs_iext_first(\n\tstruct xfs_ifork\t*ifp,\n\tstruct xfs_iext_cursor\t*cur)\n{\n\tcur->pos = 0;\n\tcur->leaf = xfs_iext_find_first_leaf(ifp);\n}\n\nvoid\nxfs_iext_last(\n\tstruct xfs_ifork\t*ifp,\n\tstruct xfs_iext_cursor\t*cur)\n{\n\tint\t\t\ti;\n\n\tcur->leaf = xfs_iext_find_last_leaf(ifp);\n\tif (!cur->leaf) {\n\t\tcur->pos = 0;\n\t\treturn;\n\t}\n\n\tfor (i = 1; i < xfs_iext_max_recs(ifp); i++) {\n\t\tif (xfs_iext_rec_is_empty(&cur->leaf->recs[i]))\n\t\t\tbreak;\n\t}\n\tcur->pos = i - 1;\n}\n\nvoid\nxfs_iext_next(\n\tstruct xfs_ifork\t*ifp,\n\tstruct xfs_iext_cursor\t*cur)\n{\n\tif (!cur->leaf) {\n\t\tASSERT(cur->pos <= 0 || cur->pos >= RECS_PER_LEAF);\n\t\txfs_iext_first(ifp, cur);\n\t\treturn;\n\t}\n\n\tASSERT(cur->pos >= 0);\n\tASSERT(cur->pos < xfs_iext_max_recs(ifp));\n\n\tcur->pos++;\n\tif (ifp->if_height > 1 && !xfs_iext_valid(ifp, cur) &&\n\t    cur->leaf->next) {\n\t\tcur->leaf = cur->leaf->next;\n\t\tcur->pos = 0;\n\t}\n}\n\nvoid\nxfs_iext_prev(\n\tstruct xfs_ifork\t*ifp,\n\tstruct xfs_iext_cursor\t*cur)\n{\n\tif (!cur->leaf) {\n\t\tASSERT(cur->pos <= 0 || cur->pos >= RECS_PER_LEAF);\n\t\txfs_iext_last(ifp, cur);\n\t\treturn;\n\t}\n\n\tASSERT(cur->pos >= 0);\n\tASSERT(cur->pos <= RECS_PER_LEAF);\n\nrecurse:\n\tdo {\n\t\tcur->pos--;\n\t\tif (xfs_iext_valid(ifp, cur))\n\t\t\treturn;\n\t} while (cur->pos > 0);\n\n\tif (ifp->if_height > 1 && cur->leaf->prev) {\n\t\tcur->leaf = cur->leaf->prev;\n\t\tcur->pos = RECS_PER_LEAF;\n\t\tgoto recurse;\n\t}\n}\n\nstatic inline int\nxfs_iext_key_cmp(\n\tstruct xfs_iext_node\t*node,\n\tint\t\t\tn,\n\txfs_fileoff_t\t\toffset)\n{\n\tif (node->keys[n] > offset)\n\t\treturn 1;\n\tif (node->keys[n] < offset)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic inline int\nxfs_iext_rec_cmp(\n\tstruct xfs_iext_rec\t*rec,\n\txfs_fileoff_t\t\toffset)\n{\n\tuint64_t\t\trec_offset = rec->lo & XFS_IEXT_STARTOFF_MASK;\n\tuint32_t\t\trec_len = rec->hi & XFS_IEXT_LENGTH_MASK;\n\n\tif (rec_offset > offset)\n\t\treturn 1;\n\tif (rec_offset + rec_len <= offset)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void *\nxfs_iext_find_level(\n\tstruct xfs_ifork\t*ifp,\n\txfs_fileoff_t\t\toffset,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_iext_node\t*node = ifp->if_u1.if_root;\n\tint\t\t\theight, i;\n\n\tif (!ifp->if_height)\n\t\treturn NULL;\n\n\tfor (height = ifp->if_height; height > level; height--) {\n\t\tfor (i = 1; i < KEYS_PER_NODE; i++)\n\t\t\tif (xfs_iext_key_cmp(node, i, offset) > 0)\n\t\t\t\tbreak;\n\n\t\tnode = node->ptrs[i - 1];\n\t\tif (!node)\n\t\t\tbreak;\n\t}\n\n\treturn node;\n}\n\nstatic int\nxfs_iext_node_pos(\n\tstruct xfs_iext_node\t*node,\n\txfs_fileoff_t\t\toffset)\n{\n\tint\t\t\ti;\n\n\tfor (i = 1; i < KEYS_PER_NODE; i++) {\n\t\tif (xfs_iext_key_cmp(node, i, offset) > 0)\n\t\t\tbreak;\n\t}\n\n\treturn i - 1;\n}\n\nstatic int\nxfs_iext_node_insert_pos(\n\tstruct xfs_iext_node\t*node,\n\txfs_fileoff_t\t\toffset)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < KEYS_PER_NODE; i++) {\n\t\tif (xfs_iext_key_cmp(node, i, offset) > 0)\n\t\t\treturn i;\n\t}\n\n\treturn KEYS_PER_NODE;\n}\n\nstatic int\nxfs_iext_node_nr_entries(\n\tstruct xfs_iext_node\t*node,\n\tint\t\t\tstart)\n{\n\tint\t\t\ti;\n\n\tfor (i = start; i < KEYS_PER_NODE; i++) {\n\t\tif (node->keys[i] == XFS_IEXT_KEY_INVALID)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic int\nxfs_iext_leaf_nr_entries(\n\tstruct xfs_ifork\t*ifp,\n\tstruct xfs_iext_leaf\t*leaf,\n\tint\t\t\tstart)\n{\n\tint\t\t\ti;\n\n\tfor (i = start; i < xfs_iext_max_recs(ifp); i++) {\n\t\tif (xfs_iext_rec_is_empty(&leaf->recs[i]))\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic inline uint64_t\nxfs_iext_leaf_key(\n\tstruct xfs_iext_leaf\t*leaf,\n\tint\t\t\tn)\n{\n\treturn leaf->recs[n].lo & XFS_IEXT_STARTOFF_MASK;\n}\n\nstatic void\nxfs_iext_grow(\n\tstruct xfs_ifork\t*ifp)\n{\n\tstruct xfs_iext_node\t*node = kmem_zalloc(NODE_SIZE, KM_NOFS);\n\tint\t\t\ti;\n\n\tif (ifp->if_height == 1) {\n\t\tstruct xfs_iext_leaf *prev = ifp->if_u1.if_root;\n\n\t\tnode->keys[0] = xfs_iext_leaf_key(prev, 0);\n\t\tnode->ptrs[0] = prev;\n\t} else  {\n\t\tstruct xfs_iext_node *prev = ifp->if_u1.if_root;\n\n\t\tASSERT(ifp->if_height > 1);\n\n\t\tnode->keys[0] = prev->keys[0];\n\t\tnode->ptrs[0] = prev;\n\t}\n\n\tfor (i = 1; i < KEYS_PER_NODE; i++)\n\t\tnode->keys[i] = XFS_IEXT_KEY_INVALID;\n\n\tifp->if_u1.if_root = node;\n\tifp->if_height++;\n}\n\nstatic void\nxfs_iext_update_node(\n\tstruct xfs_ifork\t*ifp,\n\txfs_fileoff_t\t\told_offset,\n\txfs_fileoff_t\t\tnew_offset,\n\tint\t\t\tlevel,\n\tvoid\t\t\t*ptr)\n{\n\tstruct xfs_iext_node\t*node = ifp->if_u1.if_root;\n\tint\t\t\theight, i;\n\n\tfor (height = ifp->if_height; height > level; height--) {\n\t\tfor (i = 0; i < KEYS_PER_NODE; i++) {\n\t\t\tif (i > 0 && xfs_iext_key_cmp(node, i, old_offset) > 0)\n\t\t\t\tbreak;\n\t\t\tif (node->keys[i] == old_offset)\n\t\t\t\tnode->keys[i] = new_offset;\n\t\t}\n\t\tnode = node->ptrs[i - 1];\n\t\tASSERT(node);\n\t}\n\n\tASSERT(node == ptr);\n}\n\nstatic struct xfs_iext_node *\nxfs_iext_split_node(\n\tstruct xfs_iext_node\t**nodep,\n\tint\t\t\t*pos,\n\tint\t\t\t*nr_entries)\n{\n\tstruct xfs_iext_node\t*node = *nodep;\n\tstruct xfs_iext_node\t*new = kmem_zalloc(NODE_SIZE, KM_NOFS);\n\tconst int\t\tnr_move = KEYS_PER_NODE / 2;\n\tint\t\t\tnr_keep = nr_move + (KEYS_PER_NODE & 1);\n\tint\t\t\ti = 0;\n\n\t \n\tif (*pos == KEYS_PER_NODE) {\n\t\t*nodep = new;\n\t\t*pos = 0;\n\t\t*nr_entries = 0;\n\t\tgoto done;\n\t}\n\n\n\tfor (i = 0; i < nr_move; i++) {\n\t\tnew->keys[i] = node->keys[nr_keep + i];\n\t\tnew->ptrs[i] = node->ptrs[nr_keep + i];\n\n\t\tnode->keys[nr_keep + i] = XFS_IEXT_KEY_INVALID;\n\t\tnode->ptrs[nr_keep + i] = NULL;\n\t}\n\n\tif (*pos >= nr_keep) {\n\t\t*nodep = new;\n\t\t*pos -= nr_keep;\n\t\t*nr_entries = nr_move;\n\t} else {\n\t\t*nr_entries = nr_keep;\n\t}\ndone:\n\tfor (; i < KEYS_PER_NODE; i++)\n\t\tnew->keys[i] = XFS_IEXT_KEY_INVALID;\n\treturn new;\n}\n\nstatic void\nxfs_iext_insert_node(\n\tstruct xfs_ifork\t*ifp,\n\tuint64_t\t\toffset,\n\tvoid\t\t\t*ptr,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_iext_node\t*node, *new;\n\tint\t\t\ti, pos, nr_entries;\n\nagain:\n\tif (ifp->if_height < level)\n\t\txfs_iext_grow(ifp);\n\n\tnew = NULL;\n\tnode = xfs_iext_find_level(ifp, offset, level);\n\tpos = xfs_iext_node_insert_pos(node, offset);\n\tnr_entries = xfs_iext_node_nr_entries(node, pos);\n\n\tASSERT(pos >= nr_entries || xfs_iext_key_cmp(node, pos, offset) != 0);\n\tASSERT(nr_entries <= KEYS_PER_NODE);\n\n\tif (nr_entries == KEYS_PER_NODE)\n\t\tnew = xfs_iext_split_node(&node, &pos, &nr_entries);\n\n\t \n\tif (node != new && pos == 0 && nr_entries > 0)\n\t\txfs_iext_update_node(ifp, node->keys[0], offset, level, node);\n\n\tfor (i = nr_entries; i > pos; i--) {\n\t\tnode->keys[i] = node->keys[i - 1];\n\t\tnode->ptrs[i] = node->ptrs[i - 1];\n\t}\n\tnode->keys[pos] = offset;\n\tnode->ptrs[pos] = ptr;\n\n\tif (new) {\n\t\toffset = new->keys[0];\n\t\tptr = new;\n\t\tlevel++;\n\t\tgoto again;\n\t}\n}\n\nstatic struct xfs_iext_leaf *\nxfs_iext_split_leaf(\n\tstruct xfs_iext_cursor\t*cur,\n\tint\t\t\t*nr_entries)\n{\n\tstruct xfs_iext_leaf\t*leaf = cur->leaf;\n\tstruct xfs_iext_leaf\t*new = kmem_zalloc(NODE_SIZE, KM_NOFS);\n\tconst int\t\tnr_move = RECS_PER_LEAF / 2;\n\tint\t\t\tnr_keep = nr_move + (RECS_PER_LEAF & 1);\n\tint\t\t\ti;\n\n\t \n\tif (cur->pos == RECS_PER_LEAF) {\n\t\tcur->leaf = new;\n\t\tcur->pos = 0;\n\t\t*nr_entries = 0;\n\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < nr_move; i++) {\n\t\tnew->recs[i] = leaf->recs[nr_keep + i];\n\t\txfs_iext_rec_clear(&leaf->recs[nr_keep + i]);\n\t}\n\n\tif (cur->pos >= nr_keep) {\n\t\tcur->leaf = new;\n\t\tcur->pos -= nr_keep;\n\t\t*nr_entries = nr_move;\n\t} else {\n\t\t*nr_entries = nr_keep;\n\t}\ndone:\n\tif (leaf->next)\n\t\tleaf->next->prev = new;\n\tnew->next = leaf->next;\n\tnew->prev = leaf;\n\tleaf->next = new;\n\treturn new;\n}\n\nstatic void\nxfs_iext_alloc_root(\n\tstruct xfs_ifork\t*ifp,\n\tstruct xfs_iext_cursor\t*cur)\n{\n\tASSERT(ifp->if_bytes == 0);\n\n\tifp->if_u1.if_root = kmem_zalloc(sizeof(struct xfs_iext_rec), KM_NOFS);\n\tifp->if_height = 1;\n\n\t \n\tcur->leaf = ifp->if_u1.if_root;\n\tcur->pos = 0;\n}\n\nstatic void\nxfs_iext_realloc_root(\n\tstruct xfs_ifork\t*ifp,\n\tstruct xfs_iext_cursor\t*cur)\n{\n\tint64_t new_size = ifp->if_bytes + sizeof(struct xfs_iext_rec);\n\tvoid *new;\n\n\t \n\tif (new_size / sizeof(struct xfs_iext_rec) == RECS_PER_LEAF)\n\t\tnew_size = NODE_SIZE;\n\n\tnew = krealloc(ifp->if_u1.if_root, new_size, GFP_NOFS | __GFP_NOFAIL);\n\tmemset(new + ifp->if_bytes, 0, new_size - ifp->if_bytes);\n\tifp->if_u1.if_root = new;\n\tcur->leaf = new;\n}\n\n \nstatic inline void xfs_iext_inc_seq(struct xfs_ifork *ifp)\n{\n\tWRITE_ONCE(ifp->if_seq, READ_ONCE(ifp->if_seq) + 1);\n}\n\nvoid\nxfs_iext_insert(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_iext_cursor\t*cur,\n\tstruct xfs_bmbt_irec\t*irec,\n\tint\t\t\tstate)\n{\n\tstruct xfs_ifork\t*ifp = xfs_iext_state_to_fork(ip, state);\n\txfs_fileoff_t\t\toffset = irec->br_startoff;\n\tstruct xfs_iext_leaf\t*new = NULL;\n\tint\t\t\tnr_entries, i;\n\n\txfs_iext_inc_seq(ifp);\n\n\tif (ifp->if_height == 0)\n\t\txfs_iext_alloc_root(ifp, cur);\n\telse if (ifp->if_height == 1)\n\t\txfs_iext_realloc_root(ifp, cur);\n\n\tnr_entries = xfs_iext_leaf_nr_entries(ifp, cur->leaf, cur->pos);\n\tASSERT(nr_entries <= RECS_PER_LEAF);\n\tASSERT(cur->pos >= nr_entries ||\n\t       xfs_iext_rec_cmp(cur_rec(cur), irec->br_startoff) != 0);\n\n\tif (nr_entries == RECS_PER_LEAF)\n\t\tnew = xfs_iext_split_leaf(cur, &nr_entries);\n\n\t \n\tif (cur->leaf != new && cur->pos == 0 && nr_entries > 0) {\n\t\txfs_iext_update_node(ifp, xfs_iext_leaf_key(cur->leaf, 0),\n\t\t\t\toffset, 1, cur->leaf);\n\t}\n\n\tfor (i = nr_entries; i > cur->pos; i--)\n\t\tcur->leaf->recs[i] = cur->leaf->recs[i - 1];\n\txfs_iext_set(cur_rec(cur), irec);\n\tifp->if_bytes += sizeof(struct xfs_iext_rec);\n\n\ttrace_xfs_iext_insert(ip, cur, state, _RET_IP_);\n\n\tif (new)\n\t\txfs_iext_insert_node(ifp, xfs_iext_leaf_key(new, 0), new, 2);\n}\n\nstatic struct xfs_iext_node *\nxfs_iext_rebalance_node(\n\tstruct xfs_iext_node\t*parent,\n\tint\t\t\t*pos,\n\tstruct xfs_iext_node\t*node,\n\tint\t\t\tnr_entries)\n{\n\t \n\tif (nr_entries == 0)\n\t\treturn node;\n\n\tif (*pos > 0) {\n\t\tstruct xfs_iext_node *prev = parent->ptrs[*pos - 1];\n\t\tint nr_prev = xfs_iext_node_nr_entries(prev, 0), i;\n\n\t\tif (nr_prev + nr_entries <= KEYS_PER_NODE) {\n\t\t\tfor (i = 0; i < nr_entries; i++) {\n\t\t\t\tprev->keys[nr_prev + i] = node->keys[i];\n\t\t\t\tprev->ptrs[nr_prev + i] = node->ptrs[i];\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t}\n\n\tif (*pos + 1 < xfs_iext_node_nr_entries(parent, *pos)) {\n\t\tstruct xfs_iext_node *next = parent->ptrs[*pos + 1];\n\t\tint nr_next = xfs_iext_node_nr_entries(next, 0), i;\n\n\t\tif (nr_entries + nr_next <= KEYS_PER_NODE) {\n\t\t\t \n\t\t\tfor (i = 0; i < nr_next; i++) {\n\t\t\t\tnode->keys[nr_entries + i] = next->keys[i];\n\t\t\t\tnode->ptrs[nr_entries + i] = next->ptrs[i];\n\t\t\t}\n\n\t\t\t++*pos;\n\t\t\treturn next;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void\nxfs_iext_remove_node(\n\tstruct xfs_ifork\t*ifp,\n\txfs_fileoff_t\t\toffset,\n\tvoid\t\t\t*victim)\n{\n\tstruct xfs_iext_node\t*node, *parent;\n\tint\t\t\tlevel = 2, pos, nr_entries, i;\n\n\tASSERT(level <= ifp->if_height);\n\tnode = xfs_iext_find_level(ifp, offset, level);\n\tpos = xfs_iext_node_pos(node, offset);\nagain:\n\tASSERT(node->ptrs[pos]);\n\tASSERT(node->ptrs[pos] == victim);\n\tkmem_free(victim);\n\n\tnr_entries = xfs_iext_node_nr_entries(node, pos) - 1;\n\toffset = node->keys[0];\n\tfor (i = pos; i < nr_entries; i++) {\n\t\tnode->keys[i] = node->keys[i + 1];\n\t\tnode->ptrs[i] = node->ptrs[i + 1];\n\t}\n\tnode->keys[nr_entries] = XFS_IEXT_KEY_INVALID;\n\tnode->ptrs[nr_entries] = NULL;\n\n\tif (pos == 0 && nr_entries > 0) {\n\t\txfs_iext_update_node(ifp, offset, node->keys[0], level, node);\n\t\toffset = node->keys[0];\n\t}\n\n\tif (nr_entries >= KEYS_PER_NODE / 2)\n\t\treturn;\n\n\tif (level < ifp->if_height) {\n\t\t \n\t\tlevel++;\n\t\tparent = xfs_iext_find_level(ifp, offset, level);\n\t\tpos = xfs_iext_node_pos(parent, offset);\n\n\t\tASSERT(pos != KEYS_PER_NODE);\n\t\tASSERT(parent->ptrs[pos] == node);\n\n\t\tnode = xfs_iext_rebalance_node(parent, &pos, node, nr_entries);\n\t\tif (node) {\n\t\t\tvictim = node;\n\t\t\tnode = parent;\n\t\t\tgoto again;\n\t\t}\n\t} else if (nr_entries == 1) {\n\t\t \n\t\tASSERT(node == ifp->if_u1.if_root);\n\t\tifp->if_u1.if_root = node->ptrs[0];\n\t\tifp->if_height--;\n\t\tkmem_free(node);\n\t}\n}\n\nstatic void\nxfs_iext_rebalance_leaf(\n\tstruct xfs_ifork\t*ifp,\n\tstruct xfs_iext_cursor\t*cur,\n\tstruct xfs_iext_leaf\t*leaf,\n\txfs_fileoff_t\t\toffset,\n\tint\t\t\tnr_entries)\n{\n\t \n\tif (nr_entries == 0)\n\t\tgoto remove_node;\n\n\tif (leaf->prev) {\n\t\tint nr_prev = xfs_iext_leaf_nr_entries(ifp, leaf->prev, 0), i;\n\n\t\tif (nr_prev + nr_entries <= RECS_PER_LEAF) {\n\t\t\tfor (i = 0; i < nr_entries; i++)\n\t\t\t\tleaf->prev->recs[nr_prev + i] = leaf->recs[i];\n\n\t\t\tif (cur->leaf == leaf) {\n\t\t\t\tcur->leaf = leaf->prev;\n\t\t\t\tcur->pos += nr_prev;\n\t\t\t}\n\t\t\tgoto remove_node;\n\t\t}\n\t}\n\n\tif (leaf->next) {\n\t\tint nr_next = xfs_iext_leaf_nr_entries(ifp, leaf->next, 0), i;\n\n\t\tif (nr_entries + nr_next <= RECS_PER_LEAF) {\n\t\t\t \n\t\t\tfor (i = 0; i < nr_next; i++) {\n\t\t\t\tleaf->recs[nr_entries + i] =\n\t\t\t\t\tleaf->next->recs[i];\n\t\t\t}\n\n\t\t\tif (cur->leaf == leaf->next) {\n\t\t\t\tcur->leaf = leaf;\n\t\t\t\tcur->pos += nr_entries;\n\t\t\t}\n\n\t\t\toffset = xfs_iext_leaf_key(leaf->next, 0);\n\t\t\tleaf = leaf->next;\n\t\t\tgoto remove_node;\n\t\t}\n\t}\n\n\treturn;\nremove_node:\n\tif (leaf->prev)\n\t\tleaf->prev->next = leaf->next;\n\tif (leaf->next)\n\t\tleaf->next->prev = leaf->prev;\n\txfs_iext_remove_node(ifp, offset, leaf);\n}\n\nstatic void\nxfs_iext_free_last_leaf(\n\tstruct xfs_ifork\t*ifp)\n{\n\tifp->if_height--;\n\tkmem_free(ifp->if_u1.if_root);\n\tifp->if_u1.if_root = NULL;\n}\n\nvoid\nxfs_iext_remove(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_iext_cursor\t*cur,\n\tint\t\t\tstate)\n{\n\tstruct xfs_ifork\t*ifp = xfs_iext_state_to_fork(ip, state);\n\tstruct xfs_iext_leaf\t*leaf = cur->leaf;\n\txfs_fileoff_t\t\toffset = xfs_iext_leaf_key(leaf, 0);\n\tint\t\t\ti, nr_entries;\n\n\ttrace_xfs_iext_remove(ip, cur, state, _RET_IP_);\n\n\tASSERT(ifp->if_height > 0);\n\tASSERT(ifp->if_u1.if_root != NULL);\n\tASSERT(xfs_iext_valid(ifp, cur));\n\n\txfs_iext_inc_seq(ifp);\n\n\tnr_entries = xfs_iext_leaf_nr_entries(ifp, leaf, cur->pos) - 1;\n\tfor (i = cur->pos; i < nr_entries; i++)\n\t\tleaf->recs[i] = leaf->recs[i + 1];\n\txfs_iext_rec_clear(&leaf->recs[nr_entries]);\n\tifp->if_bytes -= sizeof(struct xfs_iext_rec);\n\n\tif (cur->pos == 0 && nr_entries > 0) {\n\t\txfs_iext_update_node(ifp, offset, xfs_iext_leaf_key(leaf, 0), 1,\n\t\t\t\tleaf);\n\t\toffset = xfs_iext_leaf_key(leaf, 0);\n\t} else if (cur->pos == nr_entries) {\n\t\tif (ifp->if_height > 1 && leaf->next)\n\t\t\tcur->leaf = leaf->next;\n\t\telse\n\t\t\tcur->leaf = NULL;\n\t\tcur->pos = 0;\n\t}\n\n\tif (nr_entries >= RECS_PER_LEAF / 2)\n\t\treturn;\n\n\tif (ifp->if_height > 1)\n\t\txfs_iext_rebalance_leaf(ifp, cur, leaf, offset, nr_entries);\n\telse if (nr_entries == 0)\n\t\txfs_iext_free_last_leaf(ifp);\n}\n\n \nbool\nxfs_iext_lookup_extent(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_ifork\t*ifp,\n\txfs_fileoff_t\t\toffset,\n\tstruct xfs_iext_cursor\t*cur,\n\tstruct xfs_bmbt_irec\t*gotp)\n{\n\tXFS_STATS_INC(ip->i_mount, xs_look_exlist);\n\n\tcur->leaf = xfs_iext_find_level(ifp, offset, 1);\n\tif (!cur->leaf) {\n\t\tcur->pos = 0;\n\t\treturn false;\n\t}\n\n\tfor (cur->pos = 0; cur->pos < xfs_iext_max_recs(ifp); cur->pos++) {\n\t\tstruct xfs_iext_rec *rec = cur_rec(cur);\n\n\t\tif (xfs_iext_rec_is_empty(rec))\n\t\t\tbreak;\n\t\tif (xfs_iext_rec_cmp(rec, offset) >= 0)\n\t\t\tgoto found;\n\t}\n\n\t \n\tif (ifp->if_height == 1 || !cur->leaf->next)\n\t\treturn false;\n\tcur->leaf = cur->leaf->next;\n\tcur->pos = 0;\n\tif (!xfs_iext_valid(ifp, cur))\n\t\treturn false;\nfound:\n\txfs_iext_get(gotp, cur_rec(cur));\n\treturn true;\n}\n\n \nbool\nxfs_iext_lookup_extent_before(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_ifork\t*ifp,\n\txfs_fileoff_t\t\t*end,\n\tstruct xfs_iext_cursor\t*cur,\n\tstruct xfs_bmbt_irec\t*gotp)\n{\n\t \n\tif (xfs_iext_lookup_extent(ip, ifp, *end - 1, cur, gotp) &&\n\t    gotp->br_startoff <= *end - 1)\n\t\treturn true;\n\tif (!xfs_iext_prev_extent(ifp, cur, gotp))\n\t\treturn false;\n\t*end = gotp->br_startoff + gotp->br_blockcount;\n\treturn true;\n}\n\nvoid\nxfs_iext_update_extent(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tstate,\n\tstruct xfs_iext_cursor\t*cur,\n\tstruct xfs_bmbt_irec\t*new)\n{\n\tstruct xfs_ifork\t*ifp = xfs_iext_state_to_fork(ip, state);\n\n\txfs_iext_inc_seq(ifp);\n\n\tif (cur->pos == 0) {\n\t\tstruct xfs_bmbt_irec\told;\n\n\t\txfs_iext_get(&old, cur_rec(cur));\n\t\tif (new->br_startoff != old.br_startoff) {\n\t\t\txfs_iext_update_node(ifp, old.br_startoff,\n\t\t\t\t\tnew->br_startoff, 1, cur->leaf);\n\t\t}\n\t}\n\n\ttrace_xfs_bmap_pre_update(ip, cur, state, _RET_IP_);\n\txfs_iext_set(cur_rec(cur), new);\n\ttrace_xfs_bmap_post_update(ip, cur, state, _RET_IP_);\n}\n\n \nbool\nxfs_iext_get_extent(\n\tstruct xfs_ifork\t*ifp,\n\tstruct xfs_iext_cursor\t*cur,\n\tstruct xfs_bmbt_irec\t*gotp)\n{\n\tif (!xfs_iext_valid(ifp, cur))\n\t\treturn false;\n\txfs_iext_get(gotp, cur_rec(cur));\n\treturn true;\n}\n\n \nstatic void\nxfs_iext_destroy_node(\n\tstruct xfs_iext_node\t*node,\n\tint\t\t\tlevel)\n{\n\tint\t\t\ti;\n\n\tif (level > 1) {\n\t\tfor (i = 0; i < KEYS_PER_NODE; i++) {\n\t\t\tif (node->keys[i] == XFS_IEXT_KEY_INVALID)\n\t\t\t\tbreak;\n\t\t\txfs_iext_destroy_node(node->ptrs[i], level - 1);\n\t\t}\n\t}\n\n\tkmem_free(node);\n}\n\nvoid\nxfs_iext_destroy(\n\tstruct xfs_ifork\t*ifp)\n{\n\txfs_iext_destroy_node(ifp->if_u1.if_root, ifp->if_height);\n\n\tifp->if_bytes = 0;\n\tifp->if_height = 0;\n\tifp->if_u1.if_root = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}