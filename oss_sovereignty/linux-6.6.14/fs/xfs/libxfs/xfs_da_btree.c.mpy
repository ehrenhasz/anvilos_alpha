{
  "module_name": "xfs_da_btree.c",
  "hash_id": "7b0047ae91c6b78075b3b51f227a683d398d7e81f9e61ddf3aa907d7a3aaabcf",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_da_btree.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_log.h\"\n#include \"xfs_errortag.h\"\n\n \n\n \n\n \nSTATIC int xfs_da3_root_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_root,\n\t\t\t\t\t    xfs_da_state_blk_t *new_child);\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\nSTATIC void xfs_da3_node_rebalance(xfs_da_state_t *state,\n\t\t\t\t\t xfs_da_state_blk_t *node_blk_1,\n\t\t\t\t\t xfs_da_state_blk_t *node_blk_2);\nSTATIC void xfs_da3_node_add(xfs_da_state_t *state,\n\t\t\t\t   xfs_da_state_blk_t *old_node_blk,\n\t\t\t\t   xfs_da_state_blk_t *new_node_blk);\n\n \nSTATIC int xfs_da3_root_join(xfs_da_state_t *state,\n\t\t\t\t\t   xfs_da_state_blk_t *root_blk);\nSTATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);\nSTATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);\nSTATIC void xfs_da3_node_unbalance(xfs_da_state_t *state,\n\t\t\t\t\t xfs_da_state_blk_t *src_node_blk,\n\t\t\t\t\t xfs_da_state_blk_t *dst_node_blk);\n\n \nSTATIC int\txfs_da3_blk_unlink(xfs_da_state_t *state,\n\t\t\t\t  xfs_da_state_blk_t *drop_blk,\n\t\t\t\t  xfs_da_state_blk_t *save_blk);\n\n\nstruct kmem_cache\t*xfs_da_state_cache;\t \n\n \nstruct xfs_da_state *\nxfs_da_state_alloc(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_da_state\t*state;\n\n\tstate = kmem_cache_zalloc(xfs_da_state_cache, GFP_NOFS | __GFP_NOFAIL);\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\treturn state;\n}\n\n \nSTATIC void\nxfs_da_state_kill_altpath(xfs_da_state_t *state)\n{\n\tint\ti;\n\n\tfor (i = 0; i < state->altpath.active; i++)\n\t\tstate->altpath.blk[i].bp = NULL;\n\tstate->altpath.active = 0;\n}\n\n \nvoid\nxfs_da_state_free(xfs_da_state_t *state)\n{\n\txfs_da_state_kill_altpath(state);\n#ifdef DEBUG\n\tmemset((char *)state, 0, sizeof(*state));\n#endif  \n\tkmem_cache_free(xfs_da_state_cache, state);\n}\n\nvoid\nxfs_da_state_reset(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_args\t*args)\n{\n\txfs_da_state_kill_altpath(state);\n\tmemset(state, 0, sizeof(struct xfs_da_state));\n\tstate->args = args;\n\tstate->mp = state->args->dp->i_mount;\n}\n\nstatic inline int xfs_dabuf_nfsb(struct xfs_mount *mp, int whichfork)\n{\n\tif (whichfork == XFS_DATA_FORK)\n\t\treturn mp->m_dir_geo->fsbcount;\n\treturn mp->m_attr_geo->fsbcount;\n}\n\nvoid\nxfs_da3_node_hdr_from_disk(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_da3_icnode_hdr\t*to,\n\tstruct xfs_da_intnode\t\t*from)\n{\n\tif (xfs_has_crc(mp)) {\n\t\tstruct xfs_da3_intnode\t*from3 = (struct xfs_da3_intnode *)from;\n\n\t\tto->forw = be32_to_cpu(from3->hdr.info.hdr.forw);\n\t\tto->back = be32_to_cpu(from3->hdr.info.hdr.back);\n\t\tto->magic = be16_to_cpu(from3->hdr.info.hdr.magic);\n\t\tto->count = be16_to_cpu(from3->hdr.__count);\n\t\tto->level = be16_to_cpu(from3->hdr.__level);\n\t\tto->btree = from3->__btree;\n\t\tASSERT(to->magic == XFS_DA3_NODE_MAGIC);\n\t} else {\n\t\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\t\tto->back = be32_to_cpu(from->hdr.info.back);\n\t\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\t\tto->count = be16_to_cpu(from->hdr.__count);\n\t\tto->level = be16_to_cpu(from->hdr.__level);\n\t\tto->btree = from->__btree;\n\t\tASSERT(to->magic == XFS_DA_NODE_MAGIC);\n\t}\n}\n\nvoid\nxfs_da3_node_hdr_to_disk(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_da_intnode\t\t*to,\n\tstruct xfs_da3_icnode_hdr\t*from)\n{\n\tif (xfs_has_crc(mp)) {\n\t\tstruct xfs_da3_intnode\t*to3 = (struct xfs_da3_intnode *)to;\n\n\t\tASSERT(from->magic == XFS_DA3_NODE_MAGIC);\n\t\tto3->hdr.info.hdr.forw = cpu_to_be32(from->forw);\n\t\tto3->hdr.info.hdr.back = cpu_to_be32(from->back);\n\t\tto3->hdr.info.hdr.magic = cpu_to_be16(from->magic);\n\t\tto3->hdr.__count = cpu_to_be16(from->count);\n\t\tto3->hdr.__level = cpu_to_be16(from->level);\n\t} else {\n\t\tASSERT(from->magic == XFS_DA_NODE_MAGIC);\n\t\tto->hdr.info.forw = cpu_to_be32(from->forw);\n\t\tto->hdr.info.back = cpu_to_be32(from->back);\n\t\tto->hdr.info.magic = cpu_to_be16(from->magic);\n\t\tto->hdr.__count = cpu_to_be16(from->count);\n\t\tto->hdr.__level = cpu_to_be16(from->level);\n\t}\n}\n\n \nxfs_failaddr_t\nxfs_da3_blkinfo_verify(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da3_blkinfo\t*hdr3)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_da_blkinfo\t*hdr = &hdr3->hdr;\n\n\tif (!xfs_verify_magic16(bp, hdr->magic))\n\t\treturn __this_address;\n\n\tif (xfs_has_crc(mp)) {\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_meta_uuid))\n\t\t\treturn __this_address;\n\t\tif (be64_to_cpu(hdr3->blkno) != xfs_buf_daddr(bp))\n\t\t\treturn __this_address;\n\t\tif (!xfs_log_check_lsn(mp, be64_to_cpu(hdr3->lsn)))\n\t\t\treturn __this_address;\n\t}\n\n\treturn NULL;\n}\n\nstatic xfs_failaddr_t\nxfs_da3_node_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_da_intnode\t*hdr = bp->b_addr;\n\tstruct xfs_da3_icnode_hdr ichdr;\n\txfs_failaddr_t\t\tfa;\n\n\txfs_da3_node_hdr_from_disk(mp, &ichdr, hdr);\n\n\tfa = xfs_da3_blkinfo_verify(bp, bp->b_addr);\n\tif (fa)\n\t\treturn fa;\n\n\tif (ichdr.level == 0)\n\t\treturn __this_address;\n\tif (ichdr.level > XFS_DA_NODE_MAXDEPTH)\n\t\treturn __this_address;\n\tif (ichdr.count == 0)\n\t\treturn __this_address;\n\n\t \n\tif (ichdr.count > mp->m_dir_geo->node_ents &&\n\t    ichdr.count > mp->m_attr_geo->node_ents)\n\t\treturn __this_address;\n\n\t \n\n\treturn NULL;\n}\n\nstatic void\nxfs_da3_node_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_log_item;\n\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\txfs_failaddr_t\t\tfa;\n\n\tfa = xfs_da3_node_verify(bp);\n\tif (fa) {\n\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t\treturn;\n\t}\n\n\tif (!xfs_has_crc(mp))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->info.lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_DA3_NODE_CRC_OFF);\n}\n\n \nstatic void\nxfs_da3_node_read_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_da_blkinfo\t*info = bp->b_addr;\n\txfs_failaddr_t\t\tfa;\n\n\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\tif (!xfs_buf_verify_cksum(bp, XFS_DA3_NODE_CRC_OFF)) {\n\t\t\t\txfs_verifier_error(bp, -EFSBADCRC,\n\t\t\t\t\t\t__this_address);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\tfa = xfs_da3_node_verify(bp);\n\t\t\tif (fa)\n\t\t\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t\t\treturn;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\t\t\tbp->b_ops->verify_read(bp);\n\t\t\treturn;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\tbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\t\t\tbp->b_ops->verify_read(bp);\n\t\t\treturn;\n\t\tdefault:\n\t\t\txfs_verifier_error(bp, -EFSCORRUPTED, __this_address);\n\t\t\tbreak;\n\t}\n}\n\n \nstatic xfs_failaddr_t\nxfs_da3_node_verify_struct(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_da_blkinfo\t*info = bp->b_addr;\n\n\tswitch (be16_to_cpu(info->magic)) {\n\tcase XFS_DA3_NODE_MAGIC:\n\tcase XFS_DA_NODE_MAGIC:\n\t\treturn xfs_da3_node_verify(bp);\n\tcase XFS_ATTR_LEAF_MAGIC:\n\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\t\treturn bp->b_ops->verify_struct(bp);\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\tbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\t\treturn bp->b_ops->verify_struct(bp);\n\tdefault:\n\t\treturn __this_address;\n\t}\n}\n\nconst struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.name = \"xfs_da3_node\",\n\t.magic16 = { cpu_to_be16(XFS_DA_NODE_MAGIC),\n\t\t     cpu_to_be16(XFS_DA3_NODE_MAGIC) },\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n\t.verify_struct = xfs_da3_node_verify_struct,\n};\n\nstatic int\nxfs_da3_node_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_da_blkinfo\t*info = bp->b_addr;\n\n\tswitch (be16_to_cpu(info->magic)) {\n\tcase XFS_DA_NODE_MAGIC:\n\tcase XFS_DA3_NODE_MAGIC:\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DA_NODE_BUF);\n\t\treturn 0;\n\tcase XFS_ATTR_LEAF_MAGIC:\n\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_ATTR_LEAF_BUF);\n\t\treturn 0;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_LEAFN_BUF);\n\t\treturn 0;\n\tdefault:\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, tp->t_mountp,\n\t\t\t\tinfo, sizeof(*info));\n\t\txfs_trans_brelse(tp, bp);\n\t\treturn -EFSCORRUPTED;\n\t}\n}\n\nint\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tint\t\t\terror;\n\n\terror = xfs_da_read_buf(tp, dp, bno, 0, bpp, whichfork,\n\t\t\t&xfs_da3_node_buf_ops);\n\tif (error || !*bpp || !tp)\n\t\treturn error;\n\treturn xfs_da3_node_set_type(tp, *bpp);\n}\n\nint\nxfs_da3_node_read_mapped(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\terror;\n\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, mappedbno,\n\t\t\tXFS_FSB_TO_BB(mp, xfs_dabuf_nfsb(mp, whichfork)), 0,\n\t\t\tbpp, &xfs_da3_node_buf_ops);\n\tif (error || !*bpp)\n\t\treturn error;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\txfs_buf_set_ref(*bpp, XFS_ATTR_BTREE_REF);\n\telse\n\t\txfs_buf_set_ref(*bpp, XFS_DIR_BTREE_REF);\n\n\tif (!tp)\n\t\treturn 0;\n\treturn xfs_da3_node_set_type(tp, *bpp);\n}\n\n \n\n \nint\nxfs_da3_node_create(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tblkno,\n\tint\t\t\tlevel,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_da3_icnode_hdr ichdr = {0};\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = args->dp;\n\n\ttrace_xfs_da_node_create(args);\n\tASSERT(level <= XFS_DA_NODE_MAXDEPTH);\n\n\terror = xfs_da_get_buf(tp, dp, blkno, &bp, whichfork);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_da3_node_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DA_NODE_BUF);\n\tnode = bp->b_addr;\n\n\tif (xfs_has_crc(mp)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tmemset(hdr3, 0, sizeof(struct xfs_da3_node_hdr));\n\t\tichdr.magic = XFS_DA3_NODE_MAGIC;\n\t\thdr3->info.blkno = cpu_to_be64(xfs_buf_daddr(bp));\n\t\thdr3->info.owner = cpu_to_be64(args->dp->i_ino);\n\t\tuuid_copy(&hdr3->info.uuid, &mp->m_sb.sb_meta_uuid);\n\t} else {\n\t\tichdr.magic = XFS_DA_NODE_MAGIC;\n\t}\n\tichdr.level = level;\n\n\txfs_da3_node_hdr_to_disk(dp->i_mount, node, &ichdr);\n\txfs_trans_log_buf(tp, bp,\n\t\tXFS_DA_LOGRANGE(node, &node->hdr, args->geo->node_hdr_size));\n\n\t*bpp = bp;\n\treturn 0;\n}\n\n \nint\t\t\t\t\t\t\t \nxfs_da3_split(\n\tstruct xfs_da_state\t*state)\n{\n\tstruct xfs_da_state_blk\t*oldblk;\n\tstruct xfs_da_state_blk\t*newblk;\n\tstruct xfs_da_state_blk\t*addblk;\n\tstruct xfs_da_intnode\t*node;\n\tint\t\t\tmax;\n\tint\t\t\taction = 0;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_da_split(state->args);\n\n\tif (XFS_TEST_ERROR(false, state->mp, XFS_ERRTAG_DA_LEAF_SPLIT))\n\t\treturn -EIO;\n\n\t \n\tmax = state->path.active - 1;\n\tASSERT((max >= 0) && (max < XFS_DA_NODE_MAXDEPTH));\n\tASSERT(state->path.blk[max].magic == XFS_ATTR_LEAF_MAGIC ||\n\t       state->path.blk[max].magic == XFS_DIR2_LEAFN_MAGIC);\n\n\taddblk = &state->path.blk[max];\t\t \n\tfor (i = max; (i >= 0) && addblk; state->path.active--, i--) {\n\t\toldblk = &state->path.blk[i];\n\t\tnewblk = &state->altpath.blk[i];\n\n\t\t \n\t\tswitch (oldblk->magic) {\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\terror = xfs_attr3_leaf_split(state, oldblk, newblk);\n\t\t\tif ((error != 0) && (error != -ENOSPC)) {\n\t\t\t\treturn error;\t \n\t\t\t}\n\t\t\tif (!error) {\n\t\t\t\taddblk = newblk;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tstate->extravalid = 1;\n\t\t\tif (state->inleaf) {\n\t\t\t\tstate->extraafter = 0;\t \n\t\t\t\ttrace_xfs_attr_leaf_split_before(state->args);\n\t\t\t\terror = xfs_attr3_leaf_split(state, oldblk,\n\t\t\t\t\t\t\t    &state->extrablk);\n\t\t\t} else {\n\t\t\t\tstate->extraafter = 1;\t \n\t\t\t\ttrace_xfs_attr_leaf_split_after(state->args);\n\t\t\t\terror = xfs_attr3_leaf_split(state, newblk,\n\t\t\t\t\t\t\t    &state->extrablk);\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\treturn error;\t \n\t\t\taddblk = newblk;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\t\terror = xfs_dir2_leafn_split(state, oldblk, newblk);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\taddblk = newblk;\n\t\t\tbreak;\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\terror = xfs_da3_node_split(state, oldblk, newblk, addblk,\n\t\t\t\t\t\t\t max - i, &action);\n\t\t\taddblk->bp = NULL;\n\t\t\tif (error)\n\t\t\t\treturn error;\t \n\t\t\t \n\t\t\tif (action)\n\t\t\t\taddblk = newblk;\n\t\t\telse\n\t\t\t\taddblk = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\txfs_da3_fixhashpath(state, &state->path);\n\t}\n\tif (!addblk)\n\t\treturn 0;\n\n\t \n\tASSERT(state->extravalid == 0 ||\n\t       state->path.blk[max].magic == XFS_DIR2_LEAFN_MAGIC);\n\n\t \n\tASSERT(state->path.active == 0);\n\toldblk = &state->path.blk[0];\n\terror = xfs_da3_root_split(state, oldblk, addblk);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tnode = oldblk->bp->b_addr;\n\tif (node->hdr.info.forw) {\n\t\tif (be32_to_cpu(node->hdr.info.forw) != addblk->blkno) {\n\t\t\txfs_buf_mark_corrupt(oldblk->bp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t\tnode = addblk->bp->b_addr;\n\t\tnode->hdr.info.back = cpu_to_be32(oldblk->blkno);\n\t\txfs_trans_log_buf(state->args->trans, addblk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &node->hdr.info,\n\t\t\t\t  sizeof(node->hdr.info)));\n\t}\n\tnode = oldblk->bp->b_addr;\n\tif (node->hdr.info.back) {\n\t\tif (be32_to_cpu(node->hdr.info.back) != addblk->blkno) {\n\t\t\txfs_buf_mark_corrupt(oldblk->bp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t\tnode = addblk->bp->b_addr;\n\t\tnode->hdr.info.forw = cpu_to_be32(oldblk->blkno);\n\t\txfs_trans_log_buf(state->args->trans, addblk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &node->hdr.info,\n\t\t\t\t  sizeof(node->hdr.info)));\n\t}\nout:\n\taddblk->bp = NULL;\n\treturn error;\n}\n\n \nSTATIC int\t\t\t\t\t\t \nxfs_da3_root_split(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*blk1,\n\tstruct xfs_da_state_blk\t*blk2)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_intnode\t*oldroot;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_inode\t*dp;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_dir2_leaf\t*leaf;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\tlevel;\n\tint\t\t\terror;\n\tint\t\t\tsize;\n\n\ttrace_xfs_da_root_split(state->args);\n\n\t \n\targs = state->args;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error)\n\t\treturn error;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\terror = xfs_da_get_buf(tp, dp, blkno, &bp, args->whichfork);\n\tif (error)\n\t\treturn error;\n\tnode = bp->b_addr;\n\toldroot = blk1->bp->b_addr;\n\tif (oldroot->hdr.info.magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t    oldroot->hdr.info.magic == cpu_to_be16(XFS_DA3_NODE_MAGIC)) {\n\t\tstruct xfs_da3_icnode_hdr icnodehdr;\n\n\t\txfs_da3_node_hdr_from_disk(dp->i_mount, &icnodehdr, oldroot);\n\t\tbtree = icnodehdr.btree;\n\t\tsize = (int)((char *)&btree[icnodehdr.count] - (char *)oldroot);\n\t\tlevel = icnodehdr.level;\n\n\t\t \n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DA_NODE_BUF);\n\t} else {\n\t\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\t\tleaf = (xfs_dir2_leaf_t *)oldroot;\n\t\txfs_dir2_leaf_hdr_from_disk(dp->i_mount, &leafhdr, leaf);\n\n\t\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\t\tsize = (int)((char *)&leafhdr.ents[leafhdr.count] -\n\t\t\t(char *)leaf);\n\t\tlevel = 0;\n\n\t\t \n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_LEAFN_BUF);\n\t}\n\n\t \n\tmemcpy(node, oldroot, size);\n\tif (oldroot->hdr.info.magic == cpu_to_be16(XFS_DA3_NODE_MAGIC) ||\n\t    oldroot->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)) {\n\t\tstruct xfs_da3_intnode *node3 = (struct xfs_da3_intnode *)node;\n\n\t\tnode3->hdr.info.blkno = cpu_to_be64(xfs_buf_daddr(bp));\n\t}\n\txfs_trans_log_buf(tp, bp, 0, size - 1);\n\n\tbp->b_ops = blk1->bp->b_ops;\n\txfs_trans_buf_copy_type(bp, blk1->bp);\n\tblk1->bp = bp;\n\tblk1->blkno = blkno;\n\n\t \n\terror = xfs_da3_node_create(args,\n\t\t(args->whichfork == XFS_DATA_FORK) ? args->geo->leafblk : 0,\n\t\tlevel + 1, &bp, args->whichfork);\n\tif (error)\n\t\treturn error;\n\n\tnode = bp->b_addr;\n\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr, node);\n\tbtree = nodehdr.btree;\n\tbtree[0].hashval = cpu_to_be32(blk1->hashval);\n\tbtree[0].before = cpu_to_be32(blk1->blkno);\n\tbtree[1].hashval = cpu_to_be32(blk2->hashval);\n\tbtree[1].before = cpu_to_be32(blk2->blkno);\n\tnodehdr.count = 2;\n\txfs_da3_node_hdr_to_disk(dp->i_mount, node, &nodehdr);\n\n#ifdef DEBUG\n\tif (oldroot->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t    oldroot->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)) {\n\t\tASSERT(blk1->blkno >= args->geo->leafblk &&\n\t\t       blk1->blkno < args->geo->freeblk);\n\t\tASSERT(blk2->blkno >= args->geo->leafblk &&\n\t\t       blk2->blkno < args->geo->freeblk);\n\t}\n#endif\n\n\t \n\txfs_trans_log_buf(tp, bp,\n\t\tXFS_DA_LOGRANGE(node, btree, sizeof(xfs_da_node_entry_t) * 2));\n\n\treturn 0;\n}\n\n \nSTATIC int\t\t\t\t\t\t \nxfs_da3_node_split(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*oldblk,\n\tstruct xfs_da_state_blk\t*newblk,\n\tstruct xfs_da_state_blk\t*addblk,\n\tint\t\t\ttreelevel,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\tnewcount;\n\tint\t\t\terror;\n\tint\t\t\tuseextra;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_split(state->args);\n\n\tnode = oldblk->bp->b_addr;\n\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr, node);\n\n\t \n\tuseextra = state->extravalid && state->args->whichfork == XFS_ATTR_FORK;\n\tnewcount = 1 + useextra;\n\t \n\tif (nodehdr.count + newcount > state->args->geo->node_ents) {\n\t\t \n\t\terror = xfs_da_grow_inode(state->args, &blkno);\n\t\tif (error)\n\t\t\treturn error;\t \n\n\t\terror = xfs_da3_node_create(state->args, blkno, treelevel,\n\t\t\t\t\t   &newblk->bp, state->args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\t \n\t\tnewblk->blkno = blkno;\n\t\tnewblk->magic = XFS_DA_NODE_MAGIC;\n\t\txfs_da3_node_rebalance(state, oldblk, newblk);\n\t\terror = xfs_da3_blk_link(state, oldblk, newblk);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*result = 1;\n\t} else {\n\t\t*result = 0;\n\t}\n\n\t \n\tnode = oldblk->bp->b_addr;\n\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr, node);\n\tif (oldblk->index <= nodehdr.count) {\n\t\toldblk->index++;\n\t\txfs_da3_node_add(state, oldblk, addblk);\n\t\tif (useextra) {\n\t\t\tif (state->extraafter)\n\t\t\t\toldblk->index++;\n\t\t\txfs_da3_node_add(state, oldblk, &state->extrablk);\n\t\t\tstate->extravalid = 0;\n\t\t}\n\t} else {\n\t\tnewblk->index++;\n\t\txfs_da3_node_add(state, newblk, addblk);\n\t\tif (useextra) {\n\t\t\tif (state->extraafter)\n\t\t\t\tnewblk->index++;\n\t\t\txfs_da3_node_add(state, newblk, &state->extrablk);\n\t\t\tstate->extravalid = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nSTATIC void\nxfs_da3_node_rebalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*blk1,\n\tstruct xfs_da_state_blk\t*blk2)\n{\n\tstruct xfs_da_intnode\t*node1;\n\tstruct xfs_da_intnode\t*node2;\n\tstruct xfs_da_node_entry *btree1;\n\tstruct xfs_da_node_entry *btree2;\n\tstruct xfs_da_node_entry *btree_s;\n\tstruct xfs_da_node_entry *btree_d;\n\tstruct xfs_da3_icnode_hdr nodehdr1;\n\tstruct xfs_da3_icnode_hdr nodehdr2;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\tcount;\n\tint\t\t\ttmp;\n\tint\t\t\tswap = 0;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_rebalance(state->args);\n\n\tnode1 = blk1->bp->b_addr;\n\tnode2 = blk2->bp->b_addr;\n\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr1, node1);\n\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr2, node2);\n\tbtree1 = nodehdr1.btree;\n\tbtree2 = nodehdr2.btree;\n\n\t \n\tif (nodehdr1.count > 0 && nodehdr2.count > 0 &&\n\t    ((be32_to_cpu(btree2[0].hashval) < be32_to_cpu(btree1[0].hashval)) ||\n\t     (be32_to_cpu(btree2[nodehdr2.count - 1].hashval) <\n\t\t\tbe32_to_cpu(btree1[nodehdr1.count - 1].hashval)))) {\n\t\tswap(node1, node2);\n\t\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr1, node1);\n\t\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr2, node2);\n\t\tbtree1 = nodehdr1.btree;\n\t\tbtree2 = nodehdr2.btree;\n\t\tswap = 1;\n\t}\n\n\tcount = (nodehdr1.count - nodehdr2.count) / 2;\n\tif (count == 0)\n\t\treturn;\n\ttp = state->args->trans;\n\t \n\tif (count > 0) {\n\t\t \n\t\ttmp = nodehdr2.count;\n\t\tif (tmp > 0) {\n\t\t\ttmp *= (uint)sizeof(xfs_da_node_entry_t);\n\t\t\tbtree_s = &btree2[0];\n\t\t\tbtree_d = &btree2[count];\n\t\t\tmemmove(btree_d, btree_s, tmp);\n\t\t}\n\n\t\t \n\t\tnodehdr2.count += count;\n\t\ttmp = count * (uint)sizeof(xfs_da_node_entry_t);\n\t\tbtree_s = &btree1[nodehdr1.count - count];\n\t\tbtree_d = &btree2[0];\n\t\tmemcpy(btree_d, btree_s, tmp);\n\t\tnodehdr1.count -= count;\n\t} else {\n\t\t \n\t\tcount = -count;\n\t\ttmp = count * (uint)sizeof(xfs_da_node_entry_t);\n\t\tbtree_s = &btree2[0];\n\t\tbtree_d = &btree1[nodehdr1.count];\n\t\tmemcpy(btree_d, btree_s, tmp);\n\t\tnodehdr1.count += count;\n\n\t\txfs_trans_log_buf(tp, blk1->bp,\n\t\t\tXFS_DA_LOGRANGE(node1, btree_d, tmp));\n\n\t\t \n\t\ttmp  = nodehdr2.count - count;\n\t\ttmp *= (uint)sizeof(xfs_da_node_entry_t);\n\t\tbtree_s = &btree2[count];\n\t\tbtree_d = &btree2[0];\n\t\tmemmove(btree_d, btree_s, tmp);\n\t\tnodehdr2.count -= count;\n\t}\n\n\t \n\txfs_da3_node_hdr_to_disk(dp->i_mount, node1, &nodehdr1);\n\txfs_trans_log_buf(tp, blk1->bp,\n\t\tXFS_DA_LOGRANGE(node1, &node1->hdr,\n\t\t\t\tstate->args->geo->node_hdr_size));\n\n\txfs_da3_node_hdr_to_disk(dp->i_mount, node2, &nodehdr2);\n\txfs_trans_log_buf(tp, blk2->bp,\n\t\tXFS_DA_LOGRANGE(node2, &node2->hdr,\n\t\t\t\tstate->args->geo->node_hdr_size +\n\t\t\t\t(sizeof(btree2[0]) * nodehdr2.count)));\n\n\t \n\tif (swap) {\n\t\tnode1 = blk1->bp->b_addr;\n\t\tnode2 = blk2->bp->b_addr;\n\t\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr1, node1);\n\t\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr2, node2);\n\t\tbtree1 = nodehdr1.btree;\n\t\tbtree2 = nodehdr2.btree;\n\t}\n\tblk1->hashval = be32_to_cpu(btree1[nodehdr1.count - 1].hashval);\n\tblk2->hashval = be32_to_cpu(btree2[nodehdr2.count - 1].hashval);\n\n\t \n\tif (blk1->index >= nodehdr1.count) {\n\t\tblk2->index = blk1->index - nodehdr1.count;\n\t\tblk1->index = nodehdr1.count + 1;\t \n\t}\n}\n\n \nSTATIC void\nxfs_da3_node_add(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*oldblk,\n\tstruct xfs_da_state_blk\t*newblk)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_node_entry *btree;\n\tint\t\t\ttmp;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_add(state->args);\n\n\tnode = oldblk->bp->b_addr;\n\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr, node);\n\tbtree = nodehdr.btree;\n\n\tASSERT(oldblk->index >= 0 && oldblk->index <= nodehdr.count);\n\tASSERT(newblk->blkno != 0);\n\tif (state->args->whichfork == XFS_DATA_FORK)\n\t\tASSERT(newblk->blkno >= state->args->geo->leafblk &&\n\t\t       newblk->blkno < state->args->geo->freeblk);\n\n\t \n\ttmp = 0;\n\tif (oldblk->index < nodehdr.count) {\n\t\ttmp = (nodehdr.count - oldblk->index) * (uint)sizeof(*btree);\n\t\tmemmove(&btree[oldblk->index + 1], &btree[oldblk->index], tmp);\n\t}\n\tbtree[oldblk->index].hashval = cpu_to_be32(newblk->hashval);\n\tbtree[oldblk->index].before = cpu_to_be32(newblk->blkno);\n\txfs_trans_log_buf(state->args->trans, oldblk->bp,\n\t\tXFS_DA_LOGRANGE(node, &btree[oldblk->index],\n\t\t\t\ttmp + sizeof(*btree)));\n\n\tnodehdr.count += 1;\n\txfs_da3_node_hdr_to_disk(dp->i_mount, node, &nodehdr);\n\txfs_trans_log_buf(state->args->trans, oldblk->bp,\n\t\tXFS_DA_LOGRANGE(node, &node->hdr,\n\t\t\t\tstate->args->geo->node_hdr_size));\n\n\t \n\toldblk->hashval = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n}\n\n \n\n \nint\nxfs_da3_join(\n\tstruct xfs_da_state\t*state)\n{\n\tstruct xfs_da_state_blk\t*drop_blk;\n\tstruct xfs_da_state_blk\t*save_blk;\n\tint\t\t\taction = 0;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_join(state->args);\n\n\tdrop_blk = &state->path.blk[ state->path.active-1 ];\n\tsave_blk = &state->altpath.blk[ state->path.active-1 ];\n\tASSERT(state->path.blk[0].magic == XFS_DA_NODE_MAGIC);\n\tASSERT(drop_blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       drop_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\n\t \n\tfor (  ; state->path.active >= 2; drop_blk--, save_blk--,\n\t\t state->path.active--) {\n\t\t \n\t\tswitch (drop_blk->magic) {\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\terror = xfs_attr3_leaf_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_attr3_leaf_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\t\terror = xfs_dir2_leafn_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_dir2_leafn_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\t \n\t\t\txfs_da3_node_remove(state, drop_blk);\n\t\t\txfs_da3_fixhashpath(state, &state->path);\n\t\t\terror = xfs_da3_node_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_da3_node_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\t}\n\t\txfs_da3_fixhashpath(state, &state->altpath);\n\t\terror = xfs_da3_blk_unlink(state, drop_blk, save_blk);\n\t\txfs_da_state_kill_altpath(state);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_da_shrink_inode(state->args, drop_blk->blkno,\n\t\t\t\t\t\t\t drop_blk->bp);\n\t\tdrop_blk->bp = NULL;\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t \n\txfs_da3_node_remove(state, drop_blk);\n\txfs_da3_fixhashpath(state, &state->path);\n\terror = xfs_da3_root_join(state, &state->path.blk[0]);\n\treturn error;\n}\n\n#ifdef\tDEBUG\nstatic void\nxfs_da_blkinfo_onlychild_validate(struct xfs_da_blkinfo *blkinfo, __u16 level)\n{\n\t__be16\tmagic = blkinfo->magic;\n\n\tif (level == 1) {\n\t\tASSERT(magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\t} else {\n\t\tASSERT(magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_DA3_NODE_MAGIC));\n\t}\n\tASSERT(!blkinfo->forw);\n\tASSERT(!blkinfo->back);\n}\n#else\t \n#define\txfs_da_blkinfo_onlychild_validate(blkinfo, level)\n#endif\t \n\n \nSTATIC int\nxfs_da3_root_join(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*root_blk)\n{\n\tstruct xfs_da_intnode\t*oldroot;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tchild;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_da3_icnode_hdr oldroothdr;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_root_join(state->args);\n\n\tASSERT(root_blk->magic == XFS_DA_NODE_MAGIC);\n\n\targs = state->args;\n\toldroot = root_blk->bp->b_addr;\n\txfs_da3_node_hdr_from_disk(dp->i_mount, &oldroothdr, oldroot);\n\tASSERT(oldroothdr.forw == 0);\n\tASSERT(oldroothdr.back == 0);\n\n\t \n\tif (oldroothdr.count > 1)\n\t\treturn 0;\n\n\t \n\tchild = be32_to_cpu(oldroothdr.btree[0].before);\n\tASSERT(child != 0);\n\terror = xfs_da3_node_read(args->trans, dp, child, &bp, args->whichfork);\n\tif (error)\n\t\treturn error;\n\txfs_da_blkinfo_onlychild_validate(bp->b_addr, oldroothdr.level);\n\n\t \n\tmemcpy(root_blk->bp->b_addr, bp->b_addr, args->geo->blksize);\n\troot_blk->bp->b_ops = bp->b_ops;\n\txfs_trans_buf_copy_type(root_blk->bp, bp);\n\tif (oldroothdr.magic == XFS_DA3_NODE_MAGIC) {\n\t\tstruct xfs_da3_blkinfo *da3 = root_blk->bp->b_addr;\n\t\tda3->blkno = cpu_to_be64(xfs_buf_daddr(root_blk->bp));\n\t}\n\txfs_trans_log_buf(args->trans, root_blk->bp, 0,\n\t\t\t  args->geo->blksize - 1);\n\terror = xfs_da_shrink_inode(args, child, bp);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_da3_node_toosmall(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*action)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*info;\n\txfs_dablk_t\t\tblkno;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tint\t\t\tcount;\n\tint\t\t\tforward;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tint\t\t\ti;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_toosmall(state->args);\n\n\t \n\tblk = &state->path.blk[ state->path.active-1 ];\n\tinfo = blk->bp->b_addr;\n\tnode = (xfs_da_intnode_t *)info;\n\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr, node);\n\tif (nodehdr.count > (state->args->geo->node_ents >> 1)) {\n\t\t*action = 0;\t \n\t\treturn 0;\t \n\t}\n\n\t \n\tif (nodehdr.count == 0) {\n\t\t \n\t\tforward = (info->forw != 0);\n\t\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (retval) {\n\t\t\t*action = 0;\n\t\t} else {\n\t\t\t*action = 2;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tcount  = state->args->geo->node_ents;\n\tcount -= state->args->geo->node_ents >> 2;\n\tcount -= nodehdr.count;\n\n\t \n\tforward = nodehdr.forw < nodehdr.back;\n\tfor (i = 0; i < 2; forward = !forward, i++) {\n\t\tstruct xfs_da3_icnode_hdr thdr;\n\t\tif (forward)\n\t\t\tblkno = nodehdr.forw;\n\t\telse\n\t\t\tblkno = nodehdr.back;\n\t\tif (blkno == 0)\n\t\t\tcontinue;\n\t\terror = xfs_da3_node_read(state->args->trans, dp, blkno, &bp,\n\t\t\t\tstate->args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tnode = bp->b_addr;\n\t\txfs_da3_node_hdr_from_disk(dp->i_mount, &thdr, node);\n\t\txfs_trans_brelse(state->args->trans, bp);\n\n\t\tif (count - thdr.count >= 0)\n\t\t\tbreak;\t \n\t}\n\tif (i >= 2) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\tif (blkno < blk->blkno) {\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t} else {\n\t\terror = xfs_da3_path_shift(state, &state->path, forward,\n\t\t\t\t\t\t 0, &retval);\n\t}\n\tif (error)\n\t\treturn error;\n\tif (retval) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\t*action = 1;\n\treturn 0;\n}\n\n \nSTATIC uint\nxfs_da3_node_lasthash(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\t*count)\n{\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr, bp->b_addr);\n\tif (count)\n\t\t*count = nodehdr.count;\n\tif (!nodehdr.count)\n\t\treturn 0;\n\treturn be32_to_cpu(nodehdr.btree[nodehdr.count - 1].hashval);\n}\n\n \nvoid\nxfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_fixhashpath(state->args);\n\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leaf_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tnode = blk->bp->b_addr;\n\t\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr, node);\n\t\tbtree = nodehdr.btree;\n\t\tif (be32_to_cpu(btree[blk->index].hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}\n\n \nSTATIC void\nxfs_da3_node_remove(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_node_entry *btree;\n\tint\t\t\tindex;\n\tint\t\t\ttmp;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_remove(state->args);\n\n\tnode = drop_blk->bp->b_addr;\n\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr, node);\n\tASSERT(drop_blk->index < nodehdr.count);\n\tASSERT(drop_blk->index >= 0);\n\n\t \n\tindex = drop_blk->index;\n\tbtree = nodehdr.btree;\n\tif (index < nodehdr.count - 1) {\n\t\ttmp  = nodehdr.count - index - 1;\n\t\ttmp *= (uint)sizeof(xfs_da_node_entry_t);\n\t\tmemmove(&btree[index], &btree[index + 1], tmp);\n\t\txfs_trans_log_buf(state->args->trans, drop_blk->bp,\n\t\t    XFS_DA_LOGRANGE(node, &btree[index], tmp));\n\t\tindex = nodehdr.count - 1;\n\t}\n\tmemset(&btree[index], 0, sizeof(xfs_da_node_entry_t));\n\txfs_trans_log_buf(state->args->trans, drop_blk->bp,\n\t    XFS_DA_LOGRANGE(node, &btree[index], sizeof(btree[index])));\n\tnodehdr.count -= 1;\n\txfs_da3_node_hdr_to_disk(dp->i_mount, node, &nodehdr);\n\txfs_trans_log_buf(state->args->trans, drop_blk->bp,\n\t    XFS_DA_LOGRANGE(node, &node->hdr, state->args->geo->node_hdr_size));\n\n\t \n\tdrop_blk->hashval = be32_to_cpu(btree[index - 1].hashval);\n}\n\n \nSTATIC void\nxfs_da3_node_unbalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk,\n\tstruct xfs_da_state_blk\t*save_blk)\n{\n\tstruct xfs_da_intnode\t*drop_node;\n\tstruct xfs_da_intnode\t*save_node;\n\tstruct xfs_da_node_entry *drop_btree;\n\tstruct xfs_da_node_entry *save_btree;\n\tstruct xfs_da3_icnode_hdr drop_hdr;\n\tstruct xfs_da3_icnode_hdr save_hdr;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\tsindex;\n\tint\t\t\ttmp;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_unbalance(state->args);\n\n\tdrop_node = drop_blk->bp->b_addr;\n\tsave_node = save_blk->bp->b_addr;\n\txfs_da3_node_hdr_from_disk(dp->i_mount, &drop_hdr, drop_node);\n\txfs_da3_node_hdr_from_disk(dp->i_mount, &save_hdr, save_node);\n\tdrop_btree = drop_hdr.btree;\n\tsave_btree = save_hdr.btree;\n\ttp = state->args->trans;\n\n\t \n\tif ((be32_to_cpu(drop_btree[0].hashval) <\n\t\t\tbe32_to_cpu(save_btree[0].hashval)) ||\n\t    (be32_to_cpu(drop_btree[drop_hdr.count - 1].hashval) <\n\t\t\tbe32_to_cpu(save_btree[save_hdr.count - 1].hashval))) {\n\t\t \n\t\ttmp = save_hdr.count * sizeof(xfs_da_node_entry_t);\n\t\tmemmove(&save_btree[drop_hdr.count], &save_btree[0], tmp);\n\n\t\tsindex = 0;\n\t\txfs_trans_log_buf(tp, save_blk->bp,\n\t\t\tXFS_DA_LOGRANGE(save_node, &save_btree[0],\n\t\t\t\t(save_hdr.count + drop_hdr.count) *\n\t\t\t\t\t\tsizeof(xfs_da_node_entry_t)));\n\t} else {\n\t\tsindex = save_hdr.count;\n\t\txfs_trans_log_buf(tp, save_blk->bp,\n\t\t\tXFS_DA_LOGRANGE(save_node, &save_btree[sindex],\n\t\t\t\tdrop_hdr.count * sizeof(xfs_da_node_entry_t)));\n\t}\n\n\t \n\ttmp = drop_hdr.count * (uint)sizeof(xfs_da_node_entry_t);\n\tmemcpy(&save_btree[sindex], &drop_btree[0], tmp);\n\tsave_hdr.count += drop_hdr.count;\n\n\txfs_da3_node_hdr_to_disk(dp->i_mount, save_node, &save_hdr);\n\txfs_trans_log_buf(tp, save_blk->bp,\n\t\tXFS_DA_LOGRANGE(save_node, &save_node->hdr,\n\t\t\t\tstate->args->geo->node_hdr_size));\n\n\t \n\tsave_blk->hashval = be32_to_cpu(save_btree[save_hdr.count - 1].hashval);\n}\n\n \n\n \nint\t\t\t\t\t\t\t \nxfs_da3_node_lookup_int(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*curr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tblkno;\n\txfs_dahash_t\t\thashval;\n\txfs_dahash_t\t\tbtreehashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\tint\t\t\tmax;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tunsigned int\t\texpected_level = 0;\n\tuint16_t\t\tmagic;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\n\t \n\tblkno = args->geo->leafblk;\n\tfor (blk = &state->path.blk[0], state->path.active = 1;\n\t\t\t state->path.active <= XFS_DA_NODE_MAXDEPTH;\n\t\t\t blk++, state->path.active++) {\n\t\t \n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, args->dp, blkno,\n\t\t\t\t\t&blk->bp, args->whichfork);\n\t\tif (error) {\n\t\t\tblk->blkno = 0;\n\t\t\tstate->path.active--;\n\t\t\treturn error;\n\t\t}\n\t\tcurr = blk->bp->b_addr;\n\t\tmagic = be16_to_cpu(curr->magic);\n\n\t\tif (magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t    magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t    magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tblk->hashval = xfs_dir2_leaf_lasthash(args->dp,\n\t\t\t\t\t\t\t      blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (magic != XFS_DA_NODE_MAGIC && magic != XFS_DA3_NODE_MAGIC) {\n\t\t\txfs_buf_mark_corrupt(blk->bp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\n\t\t \n\t\tnode = blk->bp->b_addr;\n\t\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr, node);\n\t\tbtree = nodehdr.btree;\n\n\t\t \n\t\tif (nodehdr.level >= XFS_DA_NODE_MAXDEPTH) {\n\t\t\txfs_buf_mark_corrupt(blk->bp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\t \n\t\tif (blkno == args->geo->leafblk)\n\t\t\texpected_level = nodehdr.level - 1;\n\t\telse if (expected_level != nodehdr.level) {\n\t\t\txfs_buf_mark_corrupt(blk->bp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t} else\n\t\t\texpected_level--;\n\n\t\tmax = nodehdr.count;\n\t\tblk->hashval = be32_to_cpu(btree[max - 1].hashval);\n\n\t\t \n\t\tprobe = span = max / 2;\n\t\thashval = args->hashval;\n\t\twhile (span > 4) {\n\t\t\tspan /= 2;\n\t\t\tbtreehashval = be32_to_cpu(btree[probe].hashval);\n\t\t\tif (btreehashval < hashval)\n\t\t\t\tprobe += span;\n\t\t\telse if (btreehashval > hashval)\n\t\t\t\tprobe -= span;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tASSERT((probe >= 0) && (probe < max));\n\t\tASSERT((span <= 4) ||\n\t\t\t(be32_to_cpu(btree[probe].hashval) == hashval));\n\n\t\t \n\t\twhile (probe > 0 &&\n\t\t       be32_to_cpu(btree[probe].hashval) >= hashval) {\n\t\t\tprobe--;\n\t\t}\n\t\twhile (probe < max &&\n\t\t       be32_to_cpu(btree[probe].hashval) < hashval) {\n\t\t\tprobe++;\n\t\t}\n\n\t\t \n\t\tif (probe == max) {\n\t\t\tblk->index = max - 1;\n\t\t\tblkno = be32_to_cpu(btree[max - 1].before);\n\t\t} else {\n\t\t\tblk->index = probe;\n\t\t\tblkno = be32_to_cpu(btree[probe].before);\n\t\t}\n\n\t\t \n\t\tif (XFS_IS_CORRUPT(dp->i_mount, blkno == args->geo->leafblk))\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_IS_CORRUPT(dp->i_mount, expected_level != 0))\n\t\treturn -EFSCORRUPTED;\n\n\t \n\tfor (;;) {\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC) {\n\t\t\tretval = xfs_dir2_leafn_lookup_int(blk->bp, args,\n\t\t\t\t\t\t\t&blk->index, state);\n\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\tretval = xfs_attr3_leaf_lookup_int(blk->bp, args);\n\t\t\tblk->index = args->index;\n\t\t\targs->blkno = blk->blkno;\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (((retval == -ENOENT) || (retval == -ENOATTR)) &&\n\t\t    (blk->hashval == args->hashval)) {\n\t\t\terror = xfs_da3_path_shift(state, &state->path, 1, 1,\n\t\t\t\t\t\t\t &retval);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (retval == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\t\t \n\t\t\t\tretval = -ENOATTR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t*result = retval;\n\treturn 0;\n}\n\n \n\n \nSTATIC int\nxfs_da3_node_order(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*node1_bp,\n\tstruct xfs_buf\t*node2_bp)\n{\n\tstruct xfs_da_intnode\t*node1;\n\tstruct xfs_da_intnode\t*node2;\n\tstruct xfs_da_node_entry *btree1;\n\tstruct xfs_da_node_entry *btree2;\n\tstruct xfs_da3_icnode_hdr node1hdr;\n\tstruct xfs_da3_icnode_hdr node2hdr;\n\n\tnode1 = node1_bp->b_addr;\n\tnode2 = node2_bp->b_addr;\n\txfs_da3_node_hdr_from_disk(dp->i_mount, &node1hdr, node1);\n\txfs_da3_node_hdr_from_disk(dp->i_mount, &node2hdr, node2);\n\tbtree1 = node1hdr.btree;\n\tbtree2 = node2hdr.btree;\n\n\tif (node1hdr.count > 0 && node2hdr.count > 0 &&\n\t    ((be32_to_cpu(btree2[0].hashval) < be32_to_cpu(btree1[0].hashval)) ||\n\t     (be32_to_cpu(btree2[node2hdr.count - 1].hashval) <\n\t      be32_to_cpu(btree1[node1hdr.count - 1].hashval)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nint\t\t\t\t\t\t\t \nxfs_da3_blk_link(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*old_blk,\n\tstruct xfs_da_state_blk\t*new_blk)\n{\n\tstruct xfs_da_blkinfo\t*old_info;\n\tstruct xfs_da_blkinfo\t*new_info;\n\tstruct xfs_da_blkinfo\t*tmp_info;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\tbefore = 0;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\t \n\targs = state->args;\n\tASSERT(args != NULL);\n\told_info = old_blk->bp->b_addr;\n\tnew_info = new_blk->bp->b_addr;\n\tASSERT(old_blk->magic == XFS_DA_NODE_MAGIC ||\n\t       old_blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       old_blk->magic == XFS_ATTR_LEAF_MAGIC);\n\n\tswitch (old_blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tbefore = xfs_attr_leaf_order(old_blk->bp, new_blk->bp);\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tbefore = xfs_dir2_leafn_order(dp, old_blk->bp, new_blk->bp);\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tbefore = xfs_da3_node_order(dp, old_blk->bp, new_blk->bp);\n\t\tbreak;\n\t}\n\n\t \n\tif (before) {\n\t\t \n\t\ttrace_xfs_da_link_before(args);\n\t\tnew_info->forw = cpu_to_be32(old_blk->blkno);\n\t\tnew_info->back = old_info->back;\n\t\tif (old_info->back) {\n\t\t\terror = xfs_da3_node_read(args->trans, dp,\n\t\t\t\t\t\tbe32_to_cpu(old_info->back),\n\t\t\t\t\t\t&bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == old_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->forw) == old_blk->blkno);\n\t\t\ttmp_info->forw = cpu_to_be32(new_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0, sizeof(*tmp_info)-1);\n\t\t}\n\t\told_info->back = cpu_to_be32(new_blk->blkno);\n\t} else {\n\t\t \n\t\ttrace_xfs_da_link_after(args);\n\t\tnew_info->forw = old_info->forw;\n\t\tnew_info->back = cpu_to_be32(old_blk->blkno);\n\t\tif (old_info->forw) {\n\t\t\terror = xfs_da3_node_read(args->trans, dp,\n\t\t\t\t\t\tbe32_to_cpu(old_info->forw),\n\t\t\t\t\t\t&bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == old_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->back) == old_blk->blkno);\n\t\t\ttmp_info->back = cpu_to_be32(new_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0, sizeof(*tmp_info)-1);\n\t\t}\n\t\told_info->forw = cpu_to_be32(new_blk->blkno);\n\t}\n\n\txfs_trans_log_buf(args->trans, old_blk->bp, 0, sizeof(*tmp_info) - 1);\n\txfs_trans_log_buf(args->trans, new_blk->bp, 0, sizeof(*tmp_info) - 1);\n\treturn 0;\n}\n\n \nSTATIC int\t\t\t\t\t\t \nxfs_da3_blk_unlink(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk,\n\tstruct xfs_da_state_blk\t*save_blk)\n{\n\tstruct xfs_da_blkinfo\t*drop_info;\n\tstruct xfs_da_blkinfo\t*save_info;\n\tstruct xfs_da_blkinfo\t*tmp_info;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\t \n\targs = state->args;\n\tASSERT(args != NULL);\n\tsave_info = save_blk->bp->b_addr;\n\tdrop_info = drop_blk->bp->b_addr;\n\tASSERT(save_blk->magic == XFS_DA_NODE_MAGIC ||\n\t       save_blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       save_blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tASSERT(save_blk->magic == drop_blk->magic);\n\tASSERT((be32_to_cpu(save_info->forw) == drop_blk->blkno) ||\n\t       (be32_to_cpu(save_info->back) == drop_blk->blkno));\n\tASSERT((be32_to_cpu(drop_info->forw) == save_blk->blkno) ||\n\t       (be32_to_cpu(drop_info->back) == save_blk->blkno));\n\n\t \n\tif (be32_to_cpu(save_info->back) == drop_blk->blkno) {\n\t\ttrace_xfs_da_unlink_back(args);\n\t\tsave_info->back = drop_info->back;\n\t\tif (drop_info->back) {\n\t\t\terror = xfs_da3_node_read(args->trans, args->dp,\n\t\t\t\t\t\tbe32_to_cpu(drop_info->back),\n\t\t\t\t\t\t&bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == save_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->forw) == drop_blk->blkno);\n\t\t\ttmp_info->forw = cpu_to_be32(save_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t\t\t\t    sizeof(*tmp_info) - 1);\n\t\t}\n\t} else {\n\t\ttrace_xfs_da_unlink_forward(args);\n\t\tsave_info->forw = drop_info->forw;\n\t\tif (drop_info->forw) {\n\t\t\terror = xfs_da3_node_read(args->trans, args->dp,\n\t\t\t\t\t\tbe32_to_cpu(drop_info->forw),\n\t\t\t\t\t\t&bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == save_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->back) == drop_blk->blkno);\n\t\t\ttmp_info->back = cpu_to_be32(save_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t\t\t\t    sizeof(*tmp_info) - 1);\n\t\t}\n\t}\n\n\txfs_trans_log_buf(args->trans, save_blk->bp, 0, sizeof(*save_info) - 1);\n\treturn 0;\n}\n\n \nint\t\t\t\t\t\t\t \nxfs_da3_path_shift(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path,\n\tint\t\t\tforward,\n\tint\t\t\trelease,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*info;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tblkno = 0;\n\tint\t\t\tlevel;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_path_shift(state->args);\n\n\t \n\targs = state->args;\n\tASSERT(args != NULL);\n\tASSERT(path != NULL);\n\tASSERT((path->active > 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tlevel = (path->active-1) - 1;\t \n\tfor (; level >= 0; level--) {\n\t\tblk = &path->blk[level];\n\t\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr,\n\t\t\t\t\t   blk->bp->b_addr);\n\n\t\tif (forward && (blk->index < nodehdr.count - 1)) {\n\t\t\tblk->index++;\n\t\t\tblkno = be32_to_cpu(nodehdr.btree[blk->index].before);\n\t\t\tbreak;\n\t\t} else if (!forward && (blk->index > 0)) {\n\t\t\tblk->index--;\n\t\t\tblkno = be32_to_cpu(nodehdr.btree[blk->index].before);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (level < 0) {\n\t\t*result = -ENOENT;\t \n\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\treturn 0;\n\t}\n\n\t \n\tfor (blk++, level++; level < path->active; blk++, level++) {\n\t\t \n\t\terror = xfs_da3_node_read(args->trans, dp, blkno, &bp,\n\t\t\t\t\t  args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tif (release)\n\t\t\txfs_trans_brelse(args->trans, blk->bp);\n\t\tblk->blkno = blkno;\n\t\tblk->bp = bp;\n\n\t\tinfo = blk->bp->b_addr;\n\t\tASSERT(info->magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DA3_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\n\t\t \n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\t\t\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr,\n\t\t\t\t\t\t   bp->b_addr);\n\t\t\tbtree = nodehdr.btree;\n\t\t\tblk->hashval = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t\t\tif (forward)\n\t\t\t\tblk->index = 0;\n\t\t\telse\n\t\t\t\tblk->index = nodehdr.count - 1;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_dir2_leaf_lasthash(args->dp,\n\t\t\t\t\t\t\t      blk->bp, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*result = 0;\n\treturn 0;\n}\n\n\n \n\n \nxfs_dahash_t\nxfs_da_hashname(const uint8_t *name, int namelen)\n{\n\txfs_dahash_t hash;\n\n\t \n\tfor (hash = 0; namelen >= 4; namelen -= 4, name += 4)\n\t\thash = (name[0] << 21) ^ (name[1] << 14) ^ (name[2] << 7) ^\n\t\t       (name[3] << 0) ^ rol32(hash, 7 * 4);\n\n\t \n\tswitch (namelen) {\n\tcase 3:\n\t\treturn (name[0] << 14) ^ (name[1] << 7) ^ (name[2] << 0) ^\n\t\t       rol32(hash, 7 * 3);\n\tcase 2:\n\t\treturn (name[0] << 7) ^ (name[1] << 0) ^ rol32(hash, 7 * 2);\n\tcase 1:\n\t\treturn (name[0] << 0) ^ rol32(hash, 7 * 1);\n\tdefault:  \n\t\treturn hash;\n\t}\n}\n\nenum xfs_dacmp\nxfs_da_compname(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\treturn (args->namelen == len && memcmp(args->name, name, len) == 0) ?\n\t\t\t\t\tXFS_CMP_EXACT : XFS_CMP_DIFFERENT;\n}\n\nint\nxfs_da_grow_inode_int(\n\tstruct xfs_da_args\t*args,\n\txfs_fileoff_t\t\t*bno,\n\tint\t\t\tcount)\n{\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_inode\t*dp = args->dp;\n\tint\t\t\tw = args->whichfork;\n\txfs_rfsblock_t\t\tnblks = dp->i_nblocks;\n\tstruct xfs_bmbt_irec\tmap, *mapp;\n\tint\t\t\tnmap, error, got, i, mapi;\n\n\t \n\terror = xfs_bmap_first_unused(tp, dp, count, bno, w);\n\tif (error)\n\t\treturn error;\n\n\t \n\tnmap = 1;\n\terror = xfs_bmapi_write(tp, dp, *bno, count,\n\t\t\txfs_bmapi_aflag(w)|XFS_BMAPI_METADATA|XFS_BMAPI_CONTIG,\n\t\t\targs->total, &map, &nmap);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nmap <= 1);\n\tif (nmap == 1) {\n\t\tmapp = &map;\n\t\tmapi = 1;\n\t} else if (nmap == 0 && count > 1) {\n\t\txfs_fileoff_t\t\tb;\n\t\tint\t\t\tc;\n\n\t\t \n\t\tmapp = kmem_alloc(sizeof(*mapp) * count, 0);\n\t\tfor (b = *bno, mapi = 0; b < *bno + count; ) {\n\t\t\tc = (int)(*bno + count - b);\n\t\t\tnmap = min(XFS_BMAP_MAX_NMAP, c);\n\t\t\terror = xfs_bmapi_write(tp, dp, b, c,\n\t\t\t\t\txfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t\targs->total, &mapp[mapi], &nmap);\n\t\t\tif (error)\n\t\t\t\tgoto out_free_map;\n\t\t\tif (nmap < 1)\n\t\t\t\tbreak;\n\t\t\tmapi += nmap;\n\t\t\tb = mapp[mapi - 1].br_startoff +\n\t\t\t    mapp[mapi - 1].br_blockcount;\n\t\t}\n\t} else {\n\t\tmapi = 0;\n\t\tmapp = NULL;\n\t}\n\n\t \n\tfor (i = 0, got = 0; i < mapi; i++)\n\t\tgot += mapp[i].br_blockcount;\n\tif (got != count || mapp[0].br_startoff != *bno ||\n\t    mapp[mapi - 1].br_startoff + mapp[mapi - 1].br_blockcount !=\n\t    *bno + count) {\n\t\terror = -ENOSPC;\n\t\tgoto out_free_map;\n\t}\n\n\t \n\targs->total -= dp->i_nblocks - nblks;\n\nout_free_map:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\treturn error;\n}\n\n \nint\nxfs_da_grow_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*new_blkno)\n{\n\txfs_fileoff_t\t\tbno;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_grow_inode(args);\n\n\tbno = args->geo->leafblk;\n\terror = xfs_da_grow_inode_int(args, &bno, args->geo->fsbcount);\n\tif (!error)\n\t\t*new_blkno = (xfs_dablk_t)bno;\n\treturn error;\n}\n\n \nSTATIC int\nxfs_da3_swap_lastblock(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*dead_blknop,\n\tstruct xfs_buf\t\t**dead_bufp)\n{\n\tstruct xfs_da_blkinfo\t*dead_info;\n\tstruct xfs_da_blkinfo\t*sib_info;\n\tstruct xfs_da_intnode\t*par_node;\n\tstruct xfs_da_intnode\t*dead_node;\n\tstruct xfs_dir2_leaf\t*dead_leaf2;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr par_hdr;\n\tstruct xfs_inode\t*dp;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_mount\t*mp;\n\tstruct xfs_buf\t\t*dead_buf;\n\tstruct xfs_buf\t\t*last_buf;\n\tstruct xfs_buf\t\t*sib_buf;\n\tstruct xfs_buf\t\t*par_buf;\n\txfs_dahash_t\t\tdead_hash;\n\txfs_fileoff_t\t\tlastoff;\n\txfs_dablk_t\t\tdead_blkno;\n\txfs_dablk_t\t\tlast_blkno;\n\txfs_dablk_t\t\tsib_blkno;\n\txfs_dablk_t\t\tpar_blkno;\n\tint\t\t\terror;\n\tint\t\t\tw;\n\tint\t\t\tentno;\n\tint\t\t\tlevel;\n\tint\t\t\tdead_level;\n\n\ttrace_xfs_da_swap_lastblock(args);\n\n\tdead_buf = *dead_bufp;\n\tdead_blkno = *dead_blknop;\n\ttp = args->trans;\n\tdp = args->dp;\n\tw = args->whichfork;\n\tASSERT(w == XFS_DATA_FORK);\n\tmp = dp->i_mount;\n\tlastoff = args->geo->freeblk;\n\terror = xfs_bmap_last_before(tp, dp, &lastoff, w);\n\tif (error)\n\t\treturn error;\n\tif (XFS_IS_CORRUPT(mp, lastoff == 0))\n\t\treturn -EFSCORRUPTED;\n\t \n\tlast_blkno = (xfs_dablk_t)lastoff - args->geo->fsbcount;\n\terror = xfs_da3_node_read(tp, dp, last_blkno, &last_buf, w);\n\tif (error)\n\t\treturn error;\n\t \n\tmemcpy(dead_buf->b_addr, last_buf->b_addr, args->geo->blksize);\n\txfs_trans_log_buf(tp, dead_buf, 0, args->geo->blksize - 1);\n\tdead_info = dead_buf->b_addr;\n\t \n\tif (dead_info->magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t    dead_info->magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)) {\n\t\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\t\tstruct xfs_dir2_leaf_entry *ents;\n\n\t\tdead_leaf2 = (xfs_dir2_leaf_t *)dead_info;\n\t\txfs_dir2_leaf_hdr_from_disk(dp->i_mount, &leafhdr,\n\t\t\t\t\t    dead_leaf2);\n\t\tents = leafhdr.ents;\n\t\tdead_level = 0;\n\t\tdead_hash = be32_to_cpu(ents[leafhdr.count - 1].hashval);\n\t} else {\n\t\tstruct xfs_da3_icnode_hdr deadhdr;\n\n\t\tdead_node = (xfs_da_intnode_t *)dead_info;\n\t\txfs_da3_node_hdr_from_disk(dp->i_mount, &deadhdr, dead_node);\n\t\tbtree = deadhdr.btree;\n\t\tdead_level = deadhdr.level;\n\t\tdead_hash = be32_to_cpu(btree[deadhdr.count - 1].hashval);\n\t}\n\tsib_buf = par_buf = NULL;\n\t \n\tif ((sib_blkno = be32_to_cpu(dead_info->back))) {\n\t\terror = xfs_da3_node_read(tp, dp, sib_blkno, &sib_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tsib_info = sib_buf->b_addr;\n\t\tif (XFS_IS_CORRUPT(mp,\n\t\t\t\t   be32_to_cpu(sib_info->forw) != last_blkno ||\n\t\t\t\t   sib_info->magic != dead_info->magic)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tsib_info->forw = cpu_to_be32(dead_blkno);\n\t\txfs_trans_log_buf(tp, sib_buf,\n\t\t\tXFS_DA_LOGRANGE(sib_info, &sib_info->forw,\n\t\t\t\t\tsizeof(sib_info->forw)));\n\t\tsib_buf = NULL;\n\t}\n\t \n\tif ((sib_blkno = be32_to_cpu(dead_info->forw))) {\n\t\terror = xfs_da3_node_read(tp, dp, sib_blkno, &sib_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tsib_info = sib_buf->b_addr;\n\t\tif (XFS_IS_CORRUPT(mp,\n\t\t\t\t   be32_to_cpu(sib_info->back) != last_blkno ||\n\t\t\t\t   sib_info->magic != dead_info->magic)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tsib_info->back = cpu_to_be32(dead_blkno);\n\t\txfs_trans_log_buf(tp, sib_buf,\n\t\t\tXFS_DA_LOGRANGE(sib_info, &sib_info->back,\n\t\t\t\t\tsizeof(sib_info->back)));\n\t\tsib_buf = NULL;\n\t}\n\tpar_blkno = args->geo->leafblk;\n\tlevel = -1;\n\t \n\tfor (;;) {\n\t\terror = xfs_da3_node_read(tp, dp, par_blkno, &par_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tpar_node = par_buf->b_addr;\n\t\txfs_da3_node_hdr_from_disk(dp->i_mount, &par_hdr, par_node);\n\t\tif (XFS_IS_CORRUPT(mp,\n\t\t\t\t   level >= 0 && level != par_hdr.level + 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tlevel = par_hdr.level;\n\t\tbtree = par_hdr.btree;\n\t\tfor (entno = 0;\n\t\t     entno < par_hdr.count &&\n\t\t     be32_to_cpu(btree[entno].hashval) < dead_hash;\n\t\t     entno++)\n\t\t\tcontinue;\n\t\tif (XFS_IS_CORRUPT(mp, entno == par_hdr.count)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tpar_blkno = be32_to_cpu(btree[entno].before);\n\t\tif (level == dead_level + 1)\n\t\t\tbreak;\n\t\txfs_trans_brelse(tp, par_buf);\n\t\tpar_buf = NULL;\n\t}\n\t \n\tfor (;;) {\n\t\tfor (;\n\t\t     entno < par_hdr.count &&\n\t\t     be32_to_cpu(btree[entno].before) != last_blkno;\n\t\t     entno++)\n\t\t\tcontinue;\n\t\tif (entno < par_hdr.count)\n\t\t\tbreak;\n\t\tpar_blkno = par_hdr.forw;\n\t\txfs_trans_brelse(tp, par_buf);\n\t\tpar_buf = NULL;\n\t\tif (XFS_IS_CORRUPT(mp, par_blkno == 0)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\terror = xfs_da3_node_read(tp, dp, par_blkno, &par_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tpar_node = par_buf->b_addr;\n\t\txfs_da3_node_hdr_from_disk(dp->i_mount, &par_hdr, par_node);\n\t\tif (XFS_IS_CORRUPT(mp, par_hdr.level != level)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tbtree = par_hdr.btree;\n\t\tentno = 0;\n\t}\n\t \n\tbtree[entno].before = cpu_to_be32(dead_blkno);\n\txfs_trans_log_buf(tp, par_buf,\n\t\tXFS_DA_LOGRANGE(par_node, &btree[entno].before,\n\t\t\t\tsizeof(btree[entno].before)));\n\t*dead_blknop = last_blkno;\n\t*dead_bufp = last_buf;\n\treturn 0;\ndone:\n\tif (par_buf)\n\t\txfs_trans_brelse(tp, par_buf);\n\tif (sib_buf)\n\t\txfs_trans_brelse(tp, sib_buf);\n\txfs_trans_brelse(tp, last_buf);\n\treturn error;\n}\n\n \nint\nxfs_da_shrink_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tdead_blkno,\n\tstruct xfs_buf\t\t*dead_buf)\n{\n\tstruct xfs_inode\t*dp;\n\tint\t\t\tdone, error, w, count;\n\tstruct xfs_trans\t*tp;\n\n\ttrace_xfs_da_shrink_inode(args);\n\n\tdp = args->dp;\n\tw = args->whichfork;\n\ttp = args->trans;\n\tcount = args->geo->fsbcount;\n\tfor (;;) {\n\t\t \n\t\terror = xfs_bunmapi(tp, dp, dead_blkno, count,\n\t\t\t\t    xfs_bmapi_aflag(w), 0, &done);\n\t\tif (error == -ENOSPC) {\n\t\t\tif (w != XFS_DATA_FORK)\n\t\t\t\tbreak;\n\t\t\terror = xfs_da3_swap_lastblock(args, &dead_blkno,\n\t\t\t\t\t\t      &dead_buf);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\txfs_trans_binval(tp, dead_buf);\n\treturn error;\n}\n\nstatic int\nxfs_dabuf_map(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\tunsigned int\t\tflags,\n\tint\t\t\twhichfork,\n\tstruct xfs_buf_map\t**mapp,\n\tint\t\t\t*nmaps)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\tnfsb = xfs_dabuf_nfsb(mp, whichfork);\n\tstruct xfs_bmbt_irec\tirec, *irecs = &irec;\n\tstruct xfs_buf_map\t*map = *mapp;\n\txfs_fileoff_t\t\toff = bno;\n\tint\t\t\terror = 0, nirecs, i;\n\n\tif (nfsb > 1)\n\t\tirecs = kmem_zalloc(sizeof(irec) * nfsb, KM_NOFS);\n\n\tnirecs = nfsb;\n\terror = xfs_bmapi_read(dp, bno, nfsb, irecs, &nirecs,\n\t\t\txfs_bmapi_aflag(whichfork));\n\tif (error)\n\t\tgoto out_free_irecs;\n\n\t \n\tif (nirecs > 1) {\n\t\tmap = kmem_zalloc(nirecs * sizeof(struct xfs_buf_map), KM_NOFS);\n\t\tif (!map) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out_free_irecs;\n\t\t}\n\t\t*mapp = map;\n\t}\n\n\tfor (i = 0; i < nirecs; i++) {\n\t\tif (irecs[i].br_startblock == HOLESTARTBLOCK ||\n\t\t    irecs[i].br_startblock == DELAYSTARTBLOCK)\n\t\t\tgoto invalid_mapping;\n\t\tif (off != irecs[i].br_startoff)\n\t\t\tgoto invalid_mapping;\n\n\t\tmap[i].bm_bn = XFS_FSB_TO_DADDR(mp, irecs[i].br_startblock);\n\t\tmap[i].bm_len = XFS_FSB_TO_BB(mp, irecs[i].br_blockcount);\n\t\toff += irecs[i].br_blockcount;\n\t}\n\n\tif (off != bno + nfsb)\n\t\tgoto invalid_mapping;\n\n\t*nmaps = nirecs;\nout_free_irecs:\n\tif (irecs != &irec)\n\t\tkmem_free(irecs);\n\treturn error;\n\ninvalid_mapping:\n\t \n\tif (XFS_IS_CORRUPT(mp, !(flags & XFS_DABUF_MAP_HOLE_OK))) {\n\t\terror = -EFSCORRUPTED;\n\t\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\t\txfs_alert(mp, \"%s: bno %u inode %llu\",\n\t\t\t\t\t__func__, bno, dp->i_ino);\n\n\t\t\tfor (i = 0; i < nirecs; i++) {\n\t\t\t\txfs_alert(mp,\n\"[%02d] br_startoff %lld br_startblock %lld br_blockcount %lld br_state %d\",\n\t\t\t\t\ti, irecs[i].br_startoff,\n\t\t\t\t\tirecs[i].br_startblock,\n\t\t\t\t\tirecs[i].br_blockcount,\n\t\t\t\t\tirecs[i].br_state);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t*nmaps = 0;\n\t}\n\tgoto out_free_irecs;\n}\n\n \nint\nxfs_da_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap, *mapp = &map;\n\tint\t\t\tnmap = 1;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\terror = xfs_dabuf_map(dp, bno, 0, whichfork, &mapp, &nmap);\n\tif (error || nmap == 0)\n\t\tgoto out_free;\n\n\terror = xfs_trans_get_buf_map(tp, mp->m_ddev_targp, mapp, nmap, 0, &bp);\n\tif (error)\n\t\tgoto out_free;\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}\n\n \nint\nxfs_da_read_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\tunsigned int\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap, *mapp = &map;\n\tint\t\t\tnmap = 1;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\terror = xfs_dabuf_map(dp, bno, flags, whichfork, &mapp, &nmap);\n\tif (error || !nmap)\n\t\tgoto out_free;\n\n\terror = xfs_trans_read_buf_map(mp, tp, mp->m_ddev_targp, mapp, nmap, 0,\n\t\t\t&bp, ops);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\txfs_buf_set_ref(bp, XFS_ATTR_BTREE_REF);\n\telse\n\t\txfs_buf_set_ref(bp, XFS_DIR_BTREE_REF);\n\t*bpp = bp;\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}\n\n \nint\nxfs_da_reada_buf(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\tunsigned int\t\tflags,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, flags, whichfork, &mapp, &nmap);\n\tif (error || !nmap)\n\t\tgoto out_free;\n\n\txfs_buf_readahead_map(dp->i_mount->m_ddev_targp, mapp, nmap, ops);\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}