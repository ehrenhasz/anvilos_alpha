{
  "module_name": "xfs_rmap.c",
  "hash_id": "f2ac5e70c3fd47cb2ddae2ae0ca8def67c4268b1616295daac24b0cc2537126a",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_rmap.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_rmap_btree.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_errortag.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_ag.h\"\n\nstruct kmem_cache\t*xfs_rmap_intent_cache;\n\n \nint\nxfs_rmap_lookup_le(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_agblock_t\t\tbno,\n\tuint64_t\t\towner,\n\tuint64_t\t\toffset,\n\tunsigned int\t\tflags,\n\tstruct xfs_rmap_irec\t*irec,\n\tint\t\t\t*stat)\n{\n\tint\t\t\tget_stat = 0;\n\tint\t\t\terror;\n\n\tcur->bc_rec.r.rm_startblock = bno;\n\tcur->bc_rec.r.rm_blockcount = 0;\n\tcur->bc_rec.r.rm_owner = owner;\n\tcur->bc_rec.r.rm_offset = offset;\n\tcur->bc_rec.r.rm_flags = flags;\n\n\terror = xfs_btree_lookup(cur, XFS_LOOKUP_LE, stat);\n\tif (error || !(*stat) || !irec)\n\t\treturn error;\n\n\terror = xfs_rmap_get_rec(cur, irec, &get_stat);\n\tif (error)\n\t\treturn error;\n\tif (!get_stat)\n\t\treturn -EFSCORRUPTED;\n\n\treturn 0;\n}\n\n \nint\nxfs_rmap_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\tuint64_t\t\towner,\n\tuint64_t\t\toffset,\n\tunsigned int\t\tflags,\n\tint\t\t\t*stat)\n{\n\tcur->bc_rec.r.rm_startblock = bno;\n\tcur->bc_rec.r.rm_blockcount = len;\n\tcur->bc_rec.r.rm_owner = owner;\n\tcur->bc_rec.r.rm_offset = offset;\n\tcur->bc_rec.r.rm_flags = flags;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}\n\n \nSTATIC int\nxfs_rmap_update(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_rmap_irec\t*irec)\n{\n\tunion xfs_btree_rec\trec;\n\tint\t\t\terror;\n\n\ttrace_xfs_rmap_update(cur->bc_mp, cur->bc_ag.pag->pag_agno,\n\t\t\tirec->rm_startblock, irec->rm_blockcount,\n\t\t\tirec->rm_owner, irec->rm_offset, irec->rm_flags);\n\n\trec.rmap.rm_startblock = cpu_to_be32(irec->rm_startblock);\n\trec.rmap.rm_blockcount = cpu_to_be32(irec->rm_blockcount);\n\trec.rmap.rm_owner = cpu_to_be64(irec->rm_owner);\n\trec.rmap.rm_offset = cpu_to_be64(\n\t\t\txfs_rmap_irec_offset_pack(irec));\n\terror = xfs_btree_update(cur, &rec);\n\tif (error)\n\t\ttrace_xfs_rmap_update_error(cur->bc_mp,\n\t\t\t\tcur->bc_ag.pag->pag_agno, error, _RET_IP_);\n\treturn error;\n}\n\nint\nxfs_rmap_insert(\n\tstruct xfs_btree_cur\t*rcur,\n\txfs_agblock_t\t\tagbno,\n\txfs_extlen_t\t\tlen,\n\tuint64_t\t\towner,\n\tuint64_t\t\toffset,\n\tunsigned int\t\tflags)\n{\n\tint\t\t\ti;\n\tint\t\t\terror;\n\n\ttrace_xfs_rmap_insert(rcur->bc_mp, rcur->bc_ag.pag->pag_agno, agbno,\n\t\t\tlen, owner, offset, flags);\n\n\terror = xfs_rmap_lookup_eq(rcur, agbno, len, owner, offset, flags, &i);\n\tif (error)\n\t\tgoto done;\n\tif (XFS_IS_CORRUPT(rcur->bc_mp, i != 0)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto done;\n\t}\n\n\trcur->bc_rec.r.rm_startblock = agbno;\n\trcur->bc_rec.r.rm_blockcount = len;\n\trcur->bc_rec.r.rm_owner = owner;\n\trcur->bc_rec.r.rm_offset = offset;\n\trcur->bc_rec.r.rm_flags = flags;\n\terror = xfs_btree_insert(rcur, &i);\n\tif (error)\n\t\tgoto done;\n\tif (XFS_IS_CORRUPT(rcur->bc_mp, i != 1)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto done;\n\t}\ndone:\n\tif (error)\n\t\ttrace_xfs_rmap_insert_error(rcur->bc_mp,\n\t\t\t\trcur->bc_ag.pag->pag_agno, error, _RET_IP_);\n\treturn error;\n}\n\nSTATIC int\nxfs_rmap_delete(\n\tstruct xfs_btree_cur\t*rcur,\n\txfs_agblock_t\t\tagbno,\n\txfs_extlen_t\t\tlen,\n\tuint64_t\t\towner,\n\tuint64_t\t\toffset,\n\tunsigned int\t\tflags)\n{\n\tint\t\t\ti;\n\tint\t\t\terror;\n\n\ttrace_xfs_rmap_delete(rcur->bc_mp, rcur->bc_ag.pag->pag_agno, agbno,\n\t\t\tlen, owner, offset, flags);\n\n\terror = xfs_rmap_lookup_eq(rcur, agbno, len, owner, offset, flags, &i);\n\tif (error)\n\t\tgoto done;\n\tif (XFS_IS_CORRUPT(rcur->bc_mp, i != 1)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto done;\n\t}\n\n\terror = xfs_btree_delete(rcur, &i);\n\tif (error)\n\t\tgoto done;\n\tif (XFS_IS_CORRUPT(rcur->bc_mp, i != 1)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto done;\n\t}\ndone:\n\tif (error)\n\t\ttrace_xfs_rmap_delete_error(rcur->bc_mp,\n\t\t\t\trcur->bc_ag.pag->pag_agno, error, _RET_IP_);\n\treturn error;\n}\n\n \nxfs_failaddr_t\nxfs_rmap_btrec_to_irec(\n\tconst union xfs_btree_rec\t*rec,\n\tstruct xfs_rmap_irec\t\t*irec)\n{\n\tirec->rm_startblock = be32_to_cpu(rec->rmap.rm_startblock);\n\tirec->rm_blockcount = be32_to_cpu(rec->rmap.rm_blockcount);\n\tirec->rm_owner = be64_to_cpu(rec->rmap.rm_owner);\n\treturn xfs_rmap_irec_offset_unpack(be64_to_cpu(rec->rmap.rm_offset),\n\t\t\tirec);\n}\n\n \nxfs_failaddr_t\nxfs_rmap_check_irec(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst struct xfs_rmap_irec\t*irec)\n{\n\tstruct xfs_mount\t\t*mp = cur->bc_mp;\n\tbool\t\t\t\tis_inode;\n\tbool\t\t\t\tis_unwritten;\n\tbool\t\t\t\tis_bmbt;\n\tbool\t\t\t\tis_attr;\n\n\tif (irec->rm_blockcount == 0)\n\t\treturn __this_address;\n\tif (irec->rm_startblock <= XFS_AGFL_BLOCK(mp)) {\n\t\tif (irec->rm_owner != XFS_RMAP_OWN_FS)\n\t\t\treturn __this_address;\n\t\tif (irec->rm_blockcount != XFS_AGFL_BLOCK(mp) + 1)\n\t\t\treturn __this_address;\n\t} else {\n\t\t \n\t\tif (!xfs_verify_agbext(cur->bc_ag.pag, irec->rm_startblock,\n\t\t\t\t\t\t       irec->rm_blockcount))\n\t\t\treturn __this_address;\n\t}\n\n\tif (!(xfs_verify_ino(mp, irec->rm_owner) ||\n\t      (irec->rm_owner <= XFS_RMAP_OWN_FS &&\n\t       irec->rm_owner >= XFS_RMAP_OWN_MIN)))\n\t\treturn __this_address;\n\n\t \n\tis_inode = !XFS_RMAP_NON_INODE_OWNER(irec->rm_owner);\n\tis_bmbt = irec->rm_flags & XFS_RMAP_BMBT_BLOCK;\n\tis_attr = irec->rm_flags & XFS_RMAP_ATTR_FORK;\n\tis_unwritten = irec->rm_flags & XFS_RMAP_UNWRITTEN;\n\n\tif (is_bmbt && irec->rm_offset != 0)\n\t\treturn __this_address;\n\n\tif (!is_inode && irec->rm_offset != 0)\n\t\treturn __this_address;\n\n\tif (is_unwritten && (is_bmbt || !is_inode || is_attr))\n\t\treturn __this_address;\n\n\tif (!is_inode && (is_bmbt || is_unwritten || is_attr))\n\t\treturn __this_address;\n\n\t \n\tif (is_inode && !is_bmbt &&\n\t    !xfs_verify_fileext(mp, irec->rm_offset, irec->rm_blockcount))\n\t\treturn __this_address;\n\n\treturn NULL;\n}\n\nstatic inline int\nxfs_rmap_complain_bad_rec(\n\tstruct xfs_btree_cur\t\t*cur,\n\txfs_failaddr_t\t\t\tfa,\n\tconst struct xfs_rmap_irec\t*irec)\n{\n\tstruct xfs_mount\t\t*mp = cur->bc_mp;\n\n\txfs_warn(mp,\n\t\t\"Reverse Mapping BTree record corruption in AG %d detected at %pS!\",\n\t\tcur->bc_ag.pag->pag_agno, fa);\n\txfs_warn(mp,\n\t\t\"Owner 0x%llx, flags 0x%x, start block 0x%x block count 0x%x\",\n\t\tirec->rm_owner, irec->rm_flags, irec->rm_startblock,\n\t\tirec->rm_blockcount);\n\treturn -EFSCORRUPTED;\n}\n\n \nint\nxfs_rmap_get_rec(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_rmap_irec\t*irec,\n\tint\t\t\t*stat)\n{\n\tunion xfs_btree_rec\t*rec;\n\txfs_failaddr_t\t\tfa;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (error || !*stat)\n\t\treturn error;\n\n\tfa = xfs_rmap_btrec_to_irec(rec, irec);\n\tif (!fa)\n\t\tfa = xfs_rmap_check_irec(cur, irec);\n\tif (fa)\n\t\treturn xfs_rmap_complain_bad_rec(cur, fa, irec);\n\n\treturn 0;\n}\n\nstruct xfs_find_left_neighbor_info {\n\tstruct xfs_rmap_irec\thigh;\n\tstruct xfs_rmap_irec\t*irec;\n};\n\n \nSTATIC int\nxfs_rmap_find_left_neighbor_helper(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst struct xfs_rmap_irec\t*rec,\n\tvoid\t\t\t\t*priv)\n{\n\tstruct xfs_find_left_neighbor_info\t*info = priv;\n\n\ttrace_xfs_rmap_find_left_neighbor_candidate(cur->bc_mp,\n\t\t\tcur->bc_ag.pag->pag_agno, rec->rm_startblock,\n\t\t\trec->rm_blockcount, rec->rm_owner, rec->rm_offset,\n\t\t\trec->rm_flags);\n\n\tif (rec->rm_owner != info->high.rm_owner)\n\t\treturn 0;\n\tif (!XFS_RMAP_NON_INODE_OWNER(rec->rm_owner) &&\n\t    !(rec->rm_flags & XFS_RMAP_BMBT_BLOCK) &&\n\t    rec->rm_offset + rec->rm_blockcount - 1 != info->high.rm_offset)\n\t\treturn 0;\n\n\t*info->irec = *rec;\n\treturn -ECANCELED;\n}\n\n \nSTATIC int\nxfs_rmap_find_left_neighbor(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_agblock_t\t\tbno,\n\tuint64_t\t\towner,\n\tuint64_t\t\toffset,\n\tunsigned int\t\tflags,\n\tstruct xfs_rmap_irec\t*irec,\n\tint\t\t\t*stat)\n{\n\tstruct xfs_find_left_neighbor_info\tinfo;\n\tint\t\t\tfound = 0;\n\tint\t\t\terror;\n\n\t*stat = 0;\n\tif (bno == 0)\n\t\treturn 0;\n\tinfo.high.rm_startblock = bno - 1;\n\tinfo.high.rm_owner = owner;\n\tif (!XFS_RMAP_NON_INODE_OWNER(owner) &&\n\t    !(flags & XFS_RMAP_BMBT_BLOCK)) {\n\t\tif (offset == 0)\n\t\t\treturn 0;\n\t\tinfo.high.rm_offset = offset - 1;\n\t} else\n\t\tinfo.high.rm_offset = 0;\n\tinfo.high.rm_flags = flags;\n\tinfo.high.rm_blockcount = 0;\n\tinfo.irec = irec;\n\n\ttrace_xfs_rmap_find_left_neighbor_query(cur->bc_mp,\n\t\t\tcur->bc_ag.pag->pag_agno, bno, 0, owner, offset, flags);\n\n\t \n\terror = xfs_rmap_lookup_le(cur, bno, owner, offset, flags, irec,\n\t\t\t&found);\n\tif (error)\n\t\treturn error;\n\tif (found)\n\t\terror = xfs_rmap_find_left_neighbor_helper(cur, irec, &info);\n\tif (!error)\n\t\terror = xfs_rmap_query_range(cur, &info.high, &info.high,\n\t\t\t\txfs_rmap_find_left_neighbor_helper, &info);\n\tif (error != -ECANCELED)\n\t\treturn error;\n\n\t*stat = 1;\n\ttrace_xfs_rmap_find_left_neighbor_result(cur->bc_mp,\n\t\t\tcur->bc_ag.pag->pag_agno, irec->rm_startblock,\n\t\t\tirec->rm_blockcount, irec->rm_owner, irec->rm_offset,\n\t\t\tirec->rm_flags);\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_rmap_lookup_le_range_helper(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst struct xfs_rmap_irec\t*rec,\n\tvoid\t\t\t\t*priv)\n{\n\tstruct xfs_find_left_neighbor_info\t*info = priv;\n\n\ttrace_xfs_rmap_lookup_le_range_candidate(cur->bc_mp,\n\t\t\tcur->bc_ag.pag->pag_agno, rec->rm_startblock,\n\t\t\trec->rm_blockcount, rec->rm_owner, rec->rm_offset,\n\t\t\trec->rm_flags);\n\n\tif (rec->rm_owner != info->high.rm_owner)\n\t\treturn 0;\n\tif (!XFS_RMAP_NON_INODE_OWNER(rec->rm_owner) &&\n\t    !(rec->rm_flags & XFS_RMAP_BMBT_BLOCK) &&\n\t    (rec->rm_offset > info->high.rm_offset ||\n\t     rec->rm_offset + rec->rm_blockcount <= info->high.rm_offset))\n\t\treturn 0;\n\n\t*info->irec = *rec;\n\treturn -ECANCELED;\n}\n\n \nint\nxfs_rmap_lookup_le_range(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_agblock_t\t\tbno,\n\tuint64_t\t\towner,\n\tuint64_t\t\toffset,\n\tunsigned int\t\tflags,\n\tstruct xfs_rmap_irec\t*irec,\n\tint\t\t\t*stat)\n{\n\tstruct xfs_find_left_neighbor_info\tinfo;\n\tint\t\t\tfound = 0;\n\tint\t\t\terror;\n\n\tinfo.high.rm_startblock = bno;\n\tinfo.high.rm_owner = owner;\n\tif (!XFS_RMAP_NON_INODE_OWNER(owner) && !(flags & XFS_RMAP_BMBT_BLOCK))\n\t\tinfo.high.rm_offset = offset;\n\telse\n\t\tinfo.high.rm_offset = 0;\n\tinfo.high.rm_flags = flags;\n\tinfo.high.rm_blockcount = 0;\n\t*stat = 0;\n\tinfo.irec = irec;\n\n\ttrace_xfs_rmap_lookup_le_range(cur->bc_mp, cur->bc_ag.pag->pag_agno,\n\t\t\tbno, 0, owner, offset, flags);\n\n\t \n\terror = xfs_rmap_lookup_le(cur, bno, owner, offset, flags, irec,\n\t\t\t&found);\n\tif (error)\n\t\treturn error;\n\tif (found)\n\t\terror = xfs_rmap_lookup_le_range_helper(cur, irec, &info);\n\tif (!error)\n\t\terror = xfs_rmap_query_range(cur, &info.high, &info.high,\n\t\t\t\txfs_rmap_lookup_le_range_helper, &info);\n\tif (error != -ECANCELED)\n\t\treturn error;\n\n\t*stat = 1;\n\ttrace_xfs_rmap_lookup_le_range_result(cur->bc_mp,\n\t\t\tcur->bc_ag.pag->pag_agno, irec->rm_startblock,\n\t\t\tirec->rm_blockcount, irec->rm_owner, irec->rm_offset,\n\t\t\tirec->rm_flags);\n\treturn 0;\n}\n\n \nstatic int\nxfs_rmap_free_check_owner(\n\tstruct xfs_mount\t*mp,\n\tuint64_t\t\tltoff,\n\tstruct xfs_rmap_irec\t*rec,\n\txfs_filblks_t\t\tlen,\n\tuint64_t\t\towner,\n\tuint64_t\t\toffset,\n\tunsigned int\t\tflags)\n{\n\tint\t\t\terror = 0;\n\n\tif (owner == XFS_RMAP_OWN_UNKNOWN)\n\t\treturn 0;\n\n\t \n\tif (XFS_IS_CORRUPT(mp,\n\t\t\t   (flags & XFS_RMAP_UNWRITTEN) !=\n\t\t\t   (rec->rm_flags & XFS_RMAP_UNWRITTEN))) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\n\t \n\tif (XFS_IS_CORRUPT(mp, owner != rec->rm_owner)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\n\t \n\tif (XFS_RMAP_NON_INODE_OWNER(owner))\n\t\tgoto out;\n\n\tif (flags & XFS_RMAP_BMBT_BLOCK) {\n\t\tif (XFS_IS_CORRUPT(mp,\n\t\t\t\t   !(rec->rm_flags & XFS_RMAP_BMBT_BLOCK))) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (XFS_IS_CORRUPT(mp, rec->rm_offset > offset)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t\tif (XFS_IS_CORRUPT(mp,\n\t\t\t\t   offset + len > ltoff + rec->rm_blockcount)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn error;\n}\n\n \nSTATIC int\nxfs_rmap_unmap(\n\tstruct xfs_btree_cur\t\t*cur,\n\txfs_agblock_t\t\t\tbno,\n\txfs_extlen_t\t\t\tlen,\n\tbool\t\t\t\tunwritten,\n\tconst struct xfs_owner_info\t*oinfo)\n{\n\tstruct xfs_mount\t\t*mp = cur->bc_mp;\n\tstruct xfs_rmap_irec\t\tltrec;\n\tuint64_t\t\t\tltoff;\n\tint\t\t\t\terror = 0;\n\tint\t\t\t\ti;\n\tuint64_t\t\t\towner;\n\tuint64_t\t\t\toffset;\n\tunsigned int\t\t\tflags;\n\tbool\t\t\t\tignore_off;\n\n\txfs_owner_info_unpack(oinfo, &owner, &offset, &flags);\n\tignore_off = XFS_RMAP_NON_INODE_OWNER(owner) ||\n\t\t\t(flags & XFS_RMAP_BMBT_BLOCK);\n\tif (unwritten)\n\t\tflags |= XFS_RMAP_UNWRITTEN;\n\ttrace_xfs_rmap_unmap(mp, cur->bc_ag.pag->pag_agno, bno, len,\n\t\t\tunwritten, oinfo);\n\n\t \n\terror = xfs_rmap_lookup_le(cur, bno, owner, offset, flags, &ltrec, &i);\n\tif (error)\n\t\tgoto out_error;\n\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_error;\n\t}\n\n\ttrace_xfs_rmap_lookup_le_range_result(cur->bc_mp,\n\t\t\tcur->bc_ag.pag->pag_agno, ltrec.rm_startblock,\n\t\t\tltrec.rm_blockcount, ltrec.rm_owner,\n\t\t\tltrec.rm_offset, ltrec.rm_flags);\n\tltoff = ltrec.rm_offset;\n\n\t \n\tif (owner == XFS_RMAP_OWN_NULL) {\n\t\tif (XFS_IS_CORRUPT(mp,\n\t\t\t\t   bno <\n\t\t\t\t   ltrec.rm_startblock + ltrec.rm_blockcount)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_error;\n\t\t}\n\t\tgoto out_done;\n\t}\n\n\t \n\tif (owner == XFS_RMAP_OWN_UNKNOWN &&\n\t    ltrec.rm_startblock + ltrec.rm_blockcount <= bno) {\n\t\tstruct xfs_rmap_irec    rtrec;\n\n\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t\tif (i == 0)\n\t\t\tgoto out_done;\n\t\terror = xfs_rmap_get_rec(cur, &rtrec, &i);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (rtrec.rm_startblock >= bno + len)\n\t\t\tgoto out_done;\n\t}\n\n\t \n\tif (XFS_IS_CORRUPT(mp,\n\t\t\t   ltrec.rm_startblock > bno ||\n\t\t\t   ltrec.rm_startblock + ltrec.rm_blockcount <\n\t\t\t   bno + len)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_error;\n\t}\n\n\t \n\terror = xfs_rmap_free_check_owner(mp, ltoff, &ltrec, len, owner,\n\t\t\toffset, flags);\n\tif (error)\n\t\tgoto out_error;\n\n\tif (ltrec.rm_startblock == bno && ltrec.rm_blockcount == len) {\n\t\t \n\t\ttrace_xfs_rmap_delete(mp, cur->bc_ag.pag->pag_agno,\n\t\t\t\tltrec.rm_startblock, ltrec.rm_blockcount,\n\t\t\t\tltrec.rm_owner, ltrec.rm_offset,\n\t\t\t\tltrec.rm_flags);\n\t\terror = xfs_btree_delete(cur, &i);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_error;\n\t\t}\n\t} else if (ltrec.rm_startblock == bno) {\n\t\t \n\t\tltrec.rm_startblock += len;\n\t\tltrec.rm_blockcount -= len;\n\t\tif (!ignore_off)\n\t\t\tltrec.rm_offset += len;\n\t\terror = xfs_rmap_update(cur, &ltrec);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t} else if (ltrec.rm_startblock + ltrec.rm_blockcount == bno + len) {\n\t\t \n\t\tltrec.rm_blockcount -= len;\n\t\terror = xfs_rmap_update(cur, &ltrec);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t} else {\n\n\t\t \n\t\txfs_extlen_t\torig_len = ltrec.rm_blockcount;\n\n\t\tltrec.rm_blockcount = bno - ltrec.rm_startblock;\n\t\terror = xfs_rmap_update(cur, &ltrec);\n\t\tif (error)\n\t\t\tgoto out_error;\n\n\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto out_error;\n\n\t\tcur->bc_rec.r.rm_startblock = bno + len;\n\t\tcur->bc_rec.r.rm_blockcount = orig_len - len -\n\t\t\t\t\t\t     ltrec.rm_blockcount;\n\t\tcur->bc_rec.r.rm_owner = ltrec.rm_owner;\n\t\tif (ignore_off)\n\t\t\tcur->bc_rec.r.rm_offset = 0;\n\t\telse\n\t\t\tcur->bc_rec.r.rm_offset = offset + len;\n\t\tcur->bc_rec.r.rm_flags = flags;\n\t\ttrace_xfs_rmap_insert(mp, cur->bc_ag.pag->pag_agno,\n\t\t\t\tcur->bc_rec.r.rm_startblock,\n\t\t\t\tcur->bc_rec.r.rm_blockcount,\n\t\t\t\tcur->bc_rec.r.rm_owner,\n\t\t\t\tcur->bc_rec.r.rm_offset,\n\t\t\t\tcur->bc_rec.r.rm_flags);\n\t\terror = xfs_btree_insert(cur, &i);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t}\n\nout_done:\n\ttrace_xfs_rmap_unmap_done(mp, cur->bc_ag.pag->pag_agno, bno, len,\n\t\t\tunwritten, oinfo);\nout_error:\n\tif (error)\n\t\ttrace_xfs_rmap_unmap_error(mp, cur->bc_ag.pag->pag_agno,\n\t\t\t\terror, _RET_IP_);\n\treturn error;\n}\n\n \nint\nxfs_rmap_free(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_buf\t\t\t*agbp,\n\tstruct xfs_perag\t\t*pag,\n\txfs_agblock_t\t\t\tbno,\n\txfs_extlen_t\t\t\tlen,\n\tconst struct xfs_owner_info\t*oinfo)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_btree_cur\t\t*cur;\n\tint\t\t\t\terror;\n\n\tif (!xfs_has_rmapbt(mp))\n\t\treturn 0;\n\n\tcur = xfs_rmapbt_init_cursor(mp, tp, agbp, pag);\n\n\terror = xfs_rmap_unmap(cur, bno, len, false, oinfo);\n\n\txfs_btree_del_cursor(cur, error);\n\treturn error;\n}\n\n \nstatic bool\nxfs_rmap_is_mergeable(\n\tstruct xfs_rmap_irec\t*irec,\n\tuint64_t\t\towner,\n\tunsigned int\t\tflags)\n{\n\tif (irec->rm_owner == XFS_RMAP_OWN_NULL)\n\t\treturn false;\n\tif (irec->rm_owner != owner)\n\t\treturn false;\n\tif ((flags & XFS_RMAP_UNWRITTEN) ^\n\t    (irec->rm_flags & XFS_RMAP_UNWRITTEN))\n\t\treturn false;\n\tif ((flags & XFS_RMAP_ATTR_FORK) ^\n\t    (irec->rm_flags & XFS_RMAP_ATTR_FORK))\n\t\treturn false;\n\tif ((flags & XFS_RMAP_BMBT_BLOCK) ^\n\t    (irec->rm_flags & XFS_RMAP_BMBT_BLOCK))\n\t\treturn false;\n\treturn true;\n}\n\n \nSTATIC int\nxfs_rmap_map(\n\tstruct xfs_btree_cur\t\t*cur,\n\txfs_agblock_t\t\t\tbno,\n\txfs_extlen_t\t\t\tlen,\n\tbool\t\t\t\tunwritten,\n\tconst struct xfs_owner_info\t*oinfo)\n{\n\tstruct xfs_mount\t\t*mp = cur->bc_mp;\n\tstruct xfs_rmap_irec\t\tltrec;\n\tstruct xfs_rmap_irec\t\tgtrec;\n\tint\t\t\t\thave_gt;\n\tint\t\t\t\thave_lt;\n\tint\t\t\t\terror = 0;\n\tint\t\t\t\ti;\n\tuint64_t\t\t\towner;\n\tuint64_t\t\t\toffset;\n\tunsigned int\t\t\tflags = 0;\n\tbool\t\t\t\tignore_off;\n\n\txfs_owner_info_unpack(oinfo, &owner, &offset, &flags);\n\tASSERT(owner != 0);\n\tignore_off = XFS_RMAP_NON_INODE_OWNER(owner) ||\n\t\t\t(flags & XFS_RMAP_BMBT_BLOCK);\n\tif (unwritten)\n\t\tflags |= XFS_RMAP_UNWRITTEN;\n\ttrace_xfs_rmap_map(mp, cur->bc_ag.pag->pag_agno, bno, len,\n\t\t\tunwritten, oinfo);\n\tASSERT(!xfs_rmap_should_skip_owner_update(oinfo));\n\n\t \n\terror = xfs_rmap_lookup_le(cur, bno, owner, offset, flags, &ltrec,\n\t\t\t&have_lt);\n\tif (error)\n\t\tgoto out_error;\n\tif (have_lt) {\n\t\ttrace_xfs_rmap_lookup_le_range_result(cur->bc_mp,\n\t\t\t\tcur->bc_ag.pag->pag_agno, ltrec.rm_startblock,\n\t\t\t\tltrec.rm_blockcount, ltrec.rm_owner,\n\t\t\t\tltrec.rm_offset, ltrec.rm_flags);\n\n\t\tif (!xfs_rmap_is_mergeable(&ltrec, owner, flags))\n\t\t\thave_lt = 0;\n\t}\n\n\tif (XFS_IS_CORRUPT(mp,\n\t\t\t   have_lt != 0 &&\n\t\t\t   ltrec.rm_startblock + ltrec.rm_blockcount > bno)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_error;\n\t}\n\n\t \n\terror = xfs_btree_increment(cur, 0, &have_gt);\n\tif (error)\n\t\tgoto out_error;\n\tif (have_gt) {\n\t\terror = xfs_rmap_get_rec(cur, &gtrec, &have_gt);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t\tif (XFS_IS_CORRUPT(mp, have_gt != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (XFS_IS_CORRUPT(mp, bno + len > gtrec.rm_startblock)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_error;\n\t\t}\n\t\ttrace_xfs_rmap_find_right_neighbor_result(cur->bc_mp,\n\t\t\tcur->bc_ag.pag->pag_agno, gtrec.rm_startblock,\n\t\t\tgtrec.rm_blockcount, gtrec.rm_owner,\n\t\t\tgtrec.rm_offset, gtrec.rm_flags);\n\t\tif (!xfs_rmap_is_mergeable(&gtrec, owner, flags))\n\t\t\thave_gt = 0;\n\t}\n\n\t \n\tif (have_lt &&\n\t    ltrec.rm_startblock + ltrec.rm_blockcount == bno &&\n\t    (ignore_off || ltrec.rm_offset + ltrec.rm_blockcount == offset)) {\n\t\t \n\t\tltrec.rm_blockcount += len;\n\t\tif (have_gt &&\n\t\t    bno + len == gtrec.rm_startblock &&\n\t\t    (ignore_off || offset + len == gtrec.rm_offset) &&\n\t\t    (unsigned long)ltrec.rm_blockcount + len +\n\t\t\t\tgtrec.rm_blockcount <= XFS_RMAP_LEN_MAX) {\n\t\t\t \n\t\t\tltrec.rm_blockcount += gtrec.rm_blockcount;\n\t\t\ttrace_xfs_rmap_delete(mp, cur->bc_ag.pag->pag_agno,\n\t\t\t\t\tgtrec.rm_startblock,\n\t\t\t\t\tgtrec.rm_blockcount,\n\t\t\t\t\tgtrec.rm_owner,\n\t\t\t\t\tgtrec.rm_offset,\n\t\t\t\t\tgtrec.rm_flags);\n\t\t\terror = xfs_btree_delete(cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto out_error;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\terror = xfs_btree_decrement(cur, 0, &have_gt);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t\terror = xfs_rmap_update(cur, &ltrec);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t} else if (have_gt &&\n\t\t   bno + len == gtrec.rm_startblock &&\n\t\t   (ignore_off || offset + len == gtrec.rm_offset)) {\n\t\t \n\t\tgtrec.rm_startblock = bno;\n\t\tgtrec.rm_blockcount += len;\n\t\tif (!ignore_off)\n\t\t\tgtrec.rm_offset = offset;\n\t\terror = xfs_rmap_update(cur, &gtrec);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t} else {\n\t\t \n\t\tcur->bc_rec.r.rm_startblock = bno;\n\t\tcur->bc_rec.r.rm_blockcount = len;\n\t\tcur->bc_rec.r.rm_owner = owner;\n\t\tcur->bc_rec.r.rm_offset = offset;\n\t\tcur->bc_rec.r.rm_flags = flags;\n\t\ttrace_xfs_rmap_insert(mp, cur->bc_ag.pag->pag_agno, bno, len,\n\t\t\towner, offset, flags);\n\t\terror = xfs_btree_insert(cur, &i);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_error;\n\t\t}\n\t}\n\n\ttrace_xfs_rmap_map_done(mp, cur->bc_ag.pag->pag_agno, bno, len,\n\t\t\tunwritten, oinfo);\nout_error:\n\tif (error)\n\t\ttrace_xfs_rmap_map_error(mp, cur->bc_ag.pag->pag_agno,\n\t\t\t\terror, _RET_IP_);\n\treturn error;\n}\n\n \nint\nxfs_rmap_alloc(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_buf\t\t\t*agbp,\n\tstruct xfs_perag\t\t*pag,\n\txfs_agblock_t\t\t\tbno,\n\txfs_extlen_t\t\t\tlen,\n\tconst struct xfs_owner_info\t*oinfo)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_btree_cur\t\t*cur;\n\tint\t\t\t\terror;\n\n\tif (!xfs_has_rmapbt(mp))\n\t\treturn 0;\n\n\tcur = xfs_rmapbt_init_cursor(mp, tp, agbp, pag);\n\terror = xfs_rmap_map(cur, bno, len, false, oinfo);\n\n\txfs_btree_del_cursor(cur, error);\n\treturn error;\n}\n\n#define RMAP_LEFT_CONTIG\t(1 << 0)\n#define RMAP_RIGHT_CONTIG\t(1 << 1)\n#define RMAP_LEFT_FILLING\t(1 << 2)\n#define RMAP_RIGHT_FILLING\t(1 << 3)\n#define RMAP_LEFT_VALID\t\t(1 << 6)\n#define RMAP_RIGHT_VALID\t(1 << 7)\n\n#define LEFT\t\tr[0]\n#define RIGHT\t\tr[1]\n#define PREV\t\tr[2]\n#define NEW\t\tr[3]\n\n \nSTATIC int\nxfs_rmap_convert(\n\tstruct xfs_btree_cur\t\t*cur,\n\txfs_agblock_t\t\t\tbno,\n\txfs_extlen_t\t\t\tlen,\n\tbool\t\t\t\tunwritten,\n\tconst struct xfs_owner_info\t*oinfo)\n{\n\tstruct xfs_mount\t\t*mp = cur->bc_mp;\n\tstruct xfs_rmap_irec\t\tr[4];\t \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\tuint64_t\t\towner;\n\tuint64_t\t\toffset;\n\tuint64_t\t\tnew_endoff;\n\tunsigned int\t\toldext;\n\tunsigned int\t\tnewext;\n\tunsigned int\t\tflags = 0;\n\tint\t\t\ti;\n\tint\t\t\tstate = 0;\n\tint\t\t\terror;\n\n\txfs_owner_info_unpack(oinfo, &owner, &offset, &flags);\n\tASSERT(!(XFS_RMAP_NON_INODE_OWNER(owner) ||\n\t\t\t(flags & (XFS_RMAP_ATTR_FORK | XFS_RMAP_BMBT_BLOCK))));\n\toldext = unwritten ? XFS_RMAP_UNWRITTEN : 0;\n\tnew_endoff = offset + len;\n\ttrace_xfs_rmap_convert(mp, cur->bc_ag.pag->pag_agno, bno, len,\n\t\t\tunwritten, oinfo);\n\n\t \n\terror = xfs_rmap_lookup_le(cur, bno, owner, offset, oldext, &PREV, &i);\n\tif (error)\n\t\tgoto done;\n\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto done;\n\t}\n\n\ttrace_xfs_rmap_lookup_le_range_result(cur->bc_mp,\n\t\t\tcur->bc_ag.pag->pag_agno, PREV.rm_startblock,\n\t\t\tPREV.rm_blockcount, PREV.rm_owner,\n\t\t\tPREV.rm_offset, PREV.rm_flags);\n\n\tASSERT(PREV.rm_offset <= offset);\n\tASSERT(PREV.rm_offset + PREV.rm_blockcount >= new_endoff);\n\tASSERT((PREV.rm_flags & XFS_RMAP_UNWRITTEN) == oldext);\n\tnewext = ~oldext & XFS_RMAP_UNWRITTEN;\n\n\t \n\tif (PREV.rm_offset == offset)\n\t\tstate |= RMAP_LEFT_FILLING;\n\tif (PREV.rm_offset + PREV.rm_blockcount == new_endoff)\n\t\tstate |= RMAP_RIGHT_FILLING;\n\n\t \n\terror = xfs_btree_decrement(cur, 0, &i);\n\tif (error)\n\t\tgoto done;\n\tif (i) {\n\t\tstate |= RMAP_LEFT_VALID;\n\t\terror = xfs_rmap_get_rec(cur, &LEFT, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tif (XFS_IS_CORRUPT(mp,\n\t\t\t\t   LEFT.rm_startblock + LEFT.rm_blockcount >\n\t\t\t\t   bno)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\ttrace_xfs_rmap_find_left_neighbor_result(cur->bc_mp,\n\t\t\t\tcur->bc_ag.pag->pag_agno, LEFT.rm_startblock,\n\t\t\t\tLEFT.rm_blockcount, LEFT.rm_owner,\n\t\t\t\tLEFT.rm_offset, LEFT.rm_flags);\n\t\tif (LEFT.rm_startblock + LEFT.rm_blockcount == bno &&\n\t\t    LEFT.rm_offset + LEFT.rm_blockcount == offset &&\n\t\t    xfs_rmap_is_mergeable(&LEFT, owner, newext))\n\t\t\tstate |= RMAP_LEFT_CONTIG;\n\t}\n\n\t \n\terror = xfs_btree_increment(cur, 0, &i);\n\tif (error)\n\t\tgoto done;\n\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto done;\n\t}\n\terror = xfs_btree_increment(cur, 0, &i);\n\tif (error)\n\t\tgoto done;\n\tif (i) {\n\t\tstate |= RMAP_RIGHT_VALID;\n\t\terror = xfs_rmap_get_rec(cur, &RIGHT, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tif (XFS_IS_CORRUPT(mp, bno + len > RIGHT.rm_startblock)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\ttrace_xfs_rmap_find_right_neighbor_result(cur->bc_mp,\n\t\t\t\tcur->bc_ag.pag->pag_agno, RIGHT.rm_startblock,\n\t\t\t\tRIGHT.rm_blockcount, RIGHT.rm_owner,\n\t\t\t\tRIGHT.rm_offset, RIGHT.rm_flags);\n\t\tif (bno + len == RIGHT.rm_startblock &&\n\t\t    offset + len == RIGHT.rm_offset &&\n\t\t    xfs_rmap_is_mergeable(&RIGHT, owner, newext))\n\t\t\tstate |= RMAP_RIGHT_CONTIG;\n\t}\n\n\t \n\tif ((state & (RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG |\n\t\t\t RMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG)) ==\n\t    (RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG |\n\t     RMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG) &&\n\t    (unsigned long)LEFT.rm_blockcount + len +\n\t     RIGHT.rm_blockcount > XFS_RMAP_LEN_MAX)\n\t\tstate &= ~RMAP_RIGHT_CONTIG;\n\n\ttrace_xfs_rmap_convert_state(mp, cur->bc_ag.pag->pag_agno, state,\n\t\t\t_RET_IP_);\n\n\t \n\terror = xfs_rmap_lookup_le(cur, bno, owner, offset, oldext, NULL, &i);\n\tif (error)\n\t\tgoto done;\n\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto done;\n\t}\n\n\t \n\tswitch (state & (RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG |\n\t\t\t RMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG)) {\n\tcase RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG |\n\t     RMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG:\n\t\t \n\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\ttrace_xfs_rmap_delete(mp, cur->bc_ag.pag->pag_agno,\n\t\t\t\tRIGHT.rm_startblock, RIGHT.rm_blockcount,\n\t\t\t\tRIGHT.rm_owner, RIGHT.rm_offset,\n\t\t\t\tRIGHT.rm_flags);\n\t\terror = xfs_btree_delete(cur, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\terror = xfs_btree_decrement(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\ttrace_xfs_rmap_delete(mp, cur->bc_ag.pag->pag_agno,\n\t\t\t\tPREV.rm_startblock, PREV.rm_blockcount,\n\t\t\t\tPREV.rm_owner, PREV.rm_offset,\n\t\t\t\tPREV.rm_flags);\n\t\terror = xfs_btree_delete(cur, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\terror = xfs_btree_decrement(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tNEW = LEFT;\n\t\tNEW.rm_blockcount += PREV.rm_blockcount + RIGHT.rm_blockcount;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase RMAP_LEFT_FILLING | RMAP_RIGHT_FILLING | RMAP_LEFT_CONTIG:\n\t\t \n\t\ttrace_xfs_rmap_delete(mp, cur->bc_ag.pag->pag_agno,\n\t\t\t\tPREV.rm_startblock, PREV.rm_blockcount,\n\t\t\t\tPREV.rm_owner, PREV.rm_offset,\n\t\t\t\tPREV.rm_flags);\n\t\terror = xfs_btree_delete(cur, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\terror = xfs_btree_decrement(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tNEW = LEFT;\n\t\tNEW.rm_blockcount += PREV.rm_blockcount;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase RMAP_LEFT_FILLING | RMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG:\n\t\t \n\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\ttrace_xfs_rmap_delete(mp, cur->bc_ag.pag->pag_agno,\n\t\t\t\tRIGHT.rm_startblock, RIGHT.rm_blockcount,\n\t\t\t\tRIGHT.rm_owner, RIGHT.rm_offset,\n\t\t\t\tRIGHT.rm_flags);\n\t\terror = xfs_btree_delete(cur, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\terror = xfs_btree_decrement(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tNEW = PREV;\n\t\tNEW.rm_blockcount = len + RIGHT.rm_blockcount;\n\t\tNEW.rm_flags = newext;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase RMAP_LEFT_FILLING | RMAP_RIGHT_FILLING:\n\t\t \n\t\tNEW = PREV;\n\t\tNEW.rm_flags = newext;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG:\n\t\t \n\t\tNEW = PREV;\n\t\tNEW.rm_offset += len;\n\t\tNEW.rm_startblock += len;\n\t\tNEW.rm_blockcount -= len;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\terror = xfs_btree_decrement(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tNEW = LEFT;\n\t\tNEW.rm_blockcount += len;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase RMAP_LEFT_FILLING:\n\t\t \n\t\tNEW = PREV;\n\t\tNEW.rm_startblock += len;\n\t\tNEW.rm_offset += len;\n\t\tNEW.rm_blockcount -= len;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tNEW.rm_startblock = bno;\n\t\tNEW.rm_owner = owner;\n\t\tNEW.rm_offset = offset;\n\t\tNEW.rm_blockcount = len;\n\t\tNEW.rm_flags = newext;\n\t\tcur->bc_rec.r = NEW;\n\t\ttrace_xfs_rmap_insert(mp, cur->bc_ag.pag->pag_agno, bno,\n\t\t\t\tlen, owner, offset, newext);\n\t\terror = xfs_btree_insert(cur, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase RMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG:\n\t\t \n\t\tNEW = PREV;\n\t\tNEW.rm_blockcount -= len;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tNEW = RIGHT;\n\t\tNEW.rm_offset = offset;\n\t\tNEW.rm_startblock = bno;\n\t\tNEW.rm_blockcount += len;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase RMAP_RIGHT_FILLING:\n\t\t \n\t\tNEW = PREV;\n\t\tNEW.rm_blockcount -= len;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\terror = xfs_rmap_lookup_eq(cur, bno, len, owner, offset,\n\t\t\t\toldext, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 0)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tNEW.rm_startblock = bno;\n\t\tNEW.rm_owner = owner;\n\t\tNEW.rm_offset = offset;\n\t\tNEW.rm_blockcount = len;\n\t\tNEW.rm_flags = newext;\n\t\tcur->bc_rec.r = NEW;\n\t\ttrace_xfs_rmap_insert(mp, cur->bc_ag.pag->pag_agno, bno,\n\t\t\t\tlen, owner, offset, newext);\n\t\terror = xfs_btree_insert(cur, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\t \n\t\t \n\t\tNEW.rm_startblock = bno + len;\n\t\tNEW.rm_owner = owner;\n\t\tNEW.rm_offset = new_endoff;\n\t\tNEW.rm_blockcount = PREV.rm_offset + PREV.rm_blockcount -\n\t\t\t\tnew_endoff;\n\t\tNEW.rm_flags = PREV.rm_flags;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\t \n\t\tNEW = PREV;\n\t\tNEW.rm_blockcount = offset - PREV.rm_offset;\n\t\tcur->bc_rec.r = NEW;\n\t\ttrace_xfs_rmap_insert(mp, cur->bc_ag.pag->pag_agno,\n\t\t\t\tNEW.rm_startblock, NEW.rm_blockcount,\n\t\t\t\tNEW.rm_owner, NEW.rm_offset,\n\t\t\t\tNEW.rm_flags);\n\t\terror = xfs_btree_insert(cur, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\t \n\t\terror = xfs_rmap_lookup_eq(cur, bno, len, owner, offset,\n\t\t\t\toldext, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 0)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\t \n\t\tcur->bc_rec.r.rm_flags &= ~XFS_RMAP_UNWRITTEN;\n\t\tcur->bc_rec.r.rm_flags |= newext;\n\t\ttrace_xfs_rmap_insert(mp, cur->bc_ag.pag->pag_agno, bno, len,\n\t\t\t\towner, offset, newext);\n\t\terror = xfs_btree_insert(cur, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG | RMAP_RIGHT_CONTIG:\n\tcase RMAP_RIGHT_FILLING | RMAP_LEFT_CONTIG | RMAP_RIGHT_CONTIG:\n\tcase RMAP_LEFT_FILLING | RMAP_RIGHT_CONTIG:\n\tcase RMAP_RIGHT_FILLING | RMAP_LEFT_CONTIG:\n\tcase RMAP_LEFT_CONTIG | RMAP_RIGHT_CONTIG:\n\tcase RMAP_LEFT_CONTIG:\n\tcase RMAP_RIGHT_CONTIG:\n\t\t \n\t\tASSERT(0);\n\t}\n\n\ttrace_xfs_rmap_convert_done(mp, cur->bc_ag.pag->pag_agno, bno, len,\n\t\t\tunwritten, oinfo);\ndone:\n\tif (error)\n\t\ttrace_xfs_rmap_convert_error(cur->bc_mp,\n\t\t\t\tcur->bc_ag.pag->pag_agno, error, _RET_IP_);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_rmap_convert_shared(\n\tstruct xfs_btree_cur\t\t*cur,\n\txfs_agblock_t\t\t\tbno,\n\txfs_extlen_t\t\t\tlen,\n\tbool\t\t\t\tunwritten,\n\tconst struct xfs_owner_info\t*oinfo)\n{\n\tstruct xfs_mount\t\t*mp = cur->bc_mp;\n\tstruct xfs_rmap_irec\t\tr[4];\t \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\tuint64_t\t\towner;\n\tuint64_t\t\toffset;\n\tuint64_t\t\tnew_endoff;\n\tunsigned int\t\toldext;\n\tunsigned int\t\tnewext;\n\tunsigned int\t\tflags = 0;\n\tint\t\t\ti;\n\tint\t\t\tstate = 0;\n\tint\t\t\terror;\n\n\txfs_owner_info_unpack(oinfo, &owner, &offset, &flags);\n\tASSERT(!(XFS_RMAP_NON_INODE_OWNER(owner) ||\n\t\t\t(flags & (XFS_RMAP_ATTR_FORK | XFS_RMAP_BMBT_BLOCK))));\n\toldext = unwritten ? XFS_RMAP_UNWRITTEN : 0;\n\tnew_endoff = offset + len;\n\ttrace_xfs_rmap_convert(mp, cur->bc_ag.pag->pag_agno, bno, len,\n\t\t\tunwritten, oinfo);\n\n\t \n\terror = xfs_rmap_lookup_le_range(cur, bno, owner, offset, oldext,\n\t\t\t&PREV, &i);\n\tif (error)\n\t\tgoto done;\n\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto done;\n\t}\n\n\tASSERT(PREV.rm_offset <= offset);\n\tASSERT(PREV.rm_offset + PREV.rm_blockcount >= new_endoff);\n\tASSERT((PREV.rm_flags & XFS_RMAP_UNWRITTEN) == oldext);\n\tnewext = ~oldext & XFS_RMAP_UNWRITTEN;\n\n\t \n\tif (PREV.rm_offset == offset)\n\t\tstate |= RMAP_LEFT_FILLING;\n\tif (PREV.rm_offset + PREV.rm_blockcount == new_endoff)\n\t\tstate |= RMAP_RIGHT_FILLING;\n\n\t \n\terror = xfs_rmap_find_left_neighbor(cur, bno, owner, offset, newext,\n\t\t\t&LEFT, &i);\n\tif (error)\n\t\tgoto done;\n\tif (i) {\n\t\tstate |= RMAP_LEFT_VALID;\n\t\tif (XFS_IS_CORRUPT(mp,\n\t\t\t\t   LEFT.rm_startblock + LEFT.rm_blockcount >\n\t\t\t\t   bno)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tif (xfs_rmap_is_mergeable(&LEFT, owner, newext))\n\t\t\tstate |= RMAP_LEFT_CONTIG;\n\t}\n\n\t \n\terror = xfs_rmap_lookup_eq(cur, bno + len, len, owner, offset + len,\n\t\t\tnewext, &i);\n\tif (error)\n\t\tgoto done;\n\tif (i) {\n\t\tstate |= RMAP_RIGHT_VALID;\n\t\terror = xfs_rmap_get_rec(cur, &RIGHT, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tif (XFS_IS_CORRUPT(mp, bno + len > RIGHT.rm_startblock)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\ttrace_xfs_rmap_find_right_neighbor_result(cur->bc_mp,\n\t\t\t\tcur->bc_ag.pag->pag_agno, RIGHT.rm_startblock,\n\t\t\t\tRIGHT.rm_blockcount, RIGHT.rm_owner,\n\t\t\t\tRIGHT.rm_offset, RIGHT.rm_flags);\n\t\tif (xfs_rmap_is_mergeable(&RIGHT, owner, newext))\n\t\t\tstate |= RMAP_RIGHT_CONTIG;\n\t}\n\n\t \n\tif ((state & (RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG |\n\t\t\t RMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG)) ==\n\t    (RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG |\n\t     RMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG) &&\n\t    (unsigned long)LEFT.rm_blockcount + len +\n\t     RIGHT.rm_blockcount > XFS_RMAP_LEN_MAX)\n\t\tstate &= ~RMAP_RIGHT_CONTIG;\n\n\ttrace_xfs_rmap_convert_state(mp, cur->bc_ag.pag->pag_agno, state,\n\t\t\t_RET_IP_);\n\t \n\tswitch (state & (RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG |\n\t\t\t RMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG)) {\n\tcase RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG |\n\t     RMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG:\n\t\t \n\t\terror = xfs_rmap_delete(cur, RIGHT.rm_startblock,\n\t\t\t\tRIGHT.rm_blockcount, RIGHT.rm_owner,\n\t\t\t\tRIGHT.rm_offset, RIGHT.rm_flags);\n\t\tif (error)\n\t\t\tgoto done;\n\t\terror = xfs_rmap_delete(cur, PREV.rm_startblock,\n\t\t\t\tPREV.rm_blockcount, PREV.rm_owner,\n\t\t\t\tPREV.rm_offset, PREV.rm_flags);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tNEW = LEFT;\n\t\terror = xfs_rmap_lookup_eq(cur, NEW.rm_startblock,\n\t\t\t\tNEW.rm_blockcount, NEW.rm_owner,\n\t\t\t\tNEW.rm_offset, NEW.rm_flags, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tNEW.rm_blockcount += PREV.rm_blockcount + RIGHT.rm_blockcount;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase RMAP_LEFT_FILLING | RMAP_RIGHT_FILLING | RMAP_LEFT_CONTIG:\n\t\t \n\t\terror = xfs_rmap_delete(cur, PREV.rm_startblock,\n\t\t\t\tPREV.rm_blockcount, PREV.rm_owner,\n\t\t\t\tPREV.rm_offset, PREV.rm_flags);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tNEW = LEFT;\n\t\terror = xfs_rmap_lookup_eq(cur, NEW.rm_startblock,\n\t\t\t\tNEW.rm_blockcount, NEW.rm_owner,\n\t\t\t\tNEW.rm_offset, NEW.rm_flags, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tNEW.rm_blockcount += PREV.rm_blockcount;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase RMAP_LEFT_FILLING | RMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG:\n\t\t \n\t\terror = xfs_rmap_delete(cur, RIGHT.rm_startblock,\n\t\t\t\tRIGHT.rm_blockcount, RIGHT.rm_owner,\n\t\t\t\tRIGHT.rm_offset, RIGHT.rm_flags);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tNEW = PREV;\n\t\terror = xfs_rmap_lookup_eq(cur, NEW.rm_startblock,\n\t\t\t\tNEW.rm_blockcount, NEW.rm_owner,\n\t\t\t\tNEW.rm_offset, NEW.rm_flags, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tNEW.rm_blockcount += RIGHT.rm_blockcount;\n\t\tNEW.rm_flags = RIGHT.rm_flags;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase RMAP_LEFT_FILLING | RMAP_RIGHT_FILLING:\n\t\t \n\t\tNEW = PREV;\n\t\terror = xfs_rmap_lookup_eq(cur, NEW.rm_startblock,\n\t\t\t\tNEW.rm_blockcount, NEW.rm_owner,\n\t\t\t\tNEW.rm_offset, NEW.rm_flags, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tNEW.rm_flags = newext;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG:\n\t\t \n\t\tNEW = PREV;\n\t\terror = xfs_rmap_delete(cur, NEW.rm_startblock,\n\t\t\t\tNEW.rm_blockcount, NEW.rm_owner,\n\t\t\t\tNEW.rm_offset, NEW.rm_flags);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tNEW.rm_offset += len;\n\t\tNEW.rm_startblock += len;\n\t\tNEW.rm_blockcount -= len;\n\t\terror = xfs_rmap_insert(cur, NEW.rm_startblock,\n\t\t\t\tNEW.rm_blockcount, NEW.rm_owner,\n\t\t\t\tNEW.rm_offset, NEW.rm_flags);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tNEW = LEFT;\n\t\terror = xfs_rmap_lookup_eq(cur, NEW.rm_startblock,\n\t\t\t\tNEW.rm_blockcount, NEW.rm_owner,\n\t\t\t\tNEW.rm_offset, NEW.rm_flags, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tNEW.rm_blockcount += len;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase RMAP_LEFT_FILLING:\n\t\t \n\t\tNEW = PREV;\n\t\terror = xfs_rmap_delete(cur, NEW.rm_startblock,\n\t\t\t\tNEW.rm_blockcount, NEW.rm_owner,\n\t\t\t\tNEW.rm_offset, NEW.rm_flags);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tNEW.rm_offset += len;\n\t\tNEW.rm_startblock += len;\n\t\tNEW.rm_blockcount -= len;\n\t\terror = xfs_rmap_insert(cur, NEW.rm_startblock,\n\t\t\t\tNEW.rm_blockcount, NEW.rm_owner,\n\t\t\t\tNEW.rm_offset, NEW.rm_flags);\n\t\tif (error)\n\t\t\tgoto done;\n\t\terror = xfs_rmap_insert(cur, bno, len, owner, offset, newext);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase RMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG:\n\t\t \n\t\tNEW = PREV;\n\t\terror = xfs_rmap_lookup_eq(cur, NEW.rm_startblock,\n\t\t\t\tNEW.rm_blockcount, NEW.rm_owner,\n\t\t\t\tNEW.rm_offset, NEW.rm_flags, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tNEW.rm_blockcount = offset - NEW.rm_offset;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tNEW = RIGHT;\n\t\terror = xfs_rmap_delete(cur, NEW.rm_startblock,\n\t\t\t\tNEW.rm_blockcount, NEW.rm_owner,\n\t\t\t\tNEW.rm_offset, NEW.rm_flags);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tNEW.rm_offset = offset;\n\t\tNEW.rm_startblock = bno;\n\t\tNEW.rm_blockcount += len;\n\t\terror = xfs_rmap_insert(cur, NEW.rm_startblock,\n\t\t\t\tNEW.rm_blockcount, NEW.rm_owner,\n\t\t\t\tNEW.rm_offset, NEW.rm_flags);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase RMAP_RIGHT_FILLING:\n\t\t \n\t\tNEW = PREV;\n\t\terror = xfs_rmap_lookup_eq(cur, NEW.rm_startblock,\n\t\t\t\tNEW.rm_blockcount, NEW.rm_owner,\n\t\t\t\tNEW.rm_offset, NEW.rm_flags, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tNEW.rm_blockcount -= len;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\terror = xfs_rmap_insert(cur, bno, len, owner, offset, newext);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase 0:\n\t\t \n\t\t \n\t\tNEW.rm_startblock = bno + len;\n\t\tNEW.rm_owner = owner;\n\t\tNEW.rm_offset = new_endoff;\n\t\tNEW.rm_blockcount = PREV.rm_offset + PREV.rm_blockcount -\n\t\t\t\tnew_endoff;\n\t\tNEW.rm_flags = PREV.rm_flags;\n\t\terror = xfs_rmap_insert(cur, NEW.rm_startblock,\n\t\t\t\tNEW.rm_blockcount, NEW.rm_owner, NEW.rm_offset,\n\t\t\t\tNEW.rm_flags);\n\t\tif (error)\n\t\t\tgoto done;\n\t\t \n\t\tNEW = PREV;\n\t\terror = xfs_rmap_lookup_eq(cur, NEW.rm_startblock,\n\t\t\t\tNEW.rm_blockcount, NEW.rm_owner,\n\t\t\t\tNEW.rm_offset, NEW.rm_flags, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tNEW.rm_blockcount = offset - NEW.rm_offset;\n\t\terror = xfs_rmap_update(cur, &NEW);\n\t\tif (error)\n\t\t\tgoto done;\n\t\t \n\t\tNEW.rm_startblock = bno;\n\t\tNEW.rm_blockcount = len;\n\t\tNEW.rm_owner = owner;\n\t\tNEW.rm_offset = offset;\n\t\tNEW.rm_flags = newext;\n\t\terror = xfs_rmap_insert(cur, NEW.rm_startblock,\n\t\t\t\tNEW.rm_blockcount, NEW.rm_owner, NEW.rm_offset,\n\t\t\t\tNEW.rm_flags);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG | RMAP_RIGHT_CONTIG:\n\tcase RMAP_RIGHT_FILLING | RMAP_LEFT_CONTIG | RMAP_RIGHT_CONTIG:\n\tcase RMAP_LEFT_FILLING | RMAP_RIGHT_CONTIG:\n\tcase RMAP_RIGHT_FILLING | RMAP_LEFT_CONTIG:\n\tcase RMAP_LEFT_CONTIG | RMAP_RIGHT_CONTIG:\n\tcase RMAP_LEFT_CONTIG:\n\tcase RMAP_RIGHT_CONTIG:\n\t\t \n\t\tASSERT(0);\n\t}\n\n\ttrace_xfs_rmap_convert_done(mp, cur->bc_ag.pag->pag_agno, bno, len,\n\t\t\tunwritten, oinfo);\ndone:\n\tif (error)\n\t\ttrace_xfs_rmap_convert_error(cur->bc_mp,\n\t\t\t\tcur->bc_ag.pag->pag_agno, error, _RET_IP_);\n\treturn error;\n}\n\n#undef\tNEW\n#undef\tLEFT\n#undef\tRIGHT\n#undef\tPREV\n\n \nSTATIC int\nxfs_rmap_unmap_shared(\n\tstruct xfs_btree_cur\t\t*cur,\n\txfs_agblock_t\t\t\tbno,\n\txfs_extlen_t\t\t\tlen,\n\tbool\t\t\t\tunwritten,\n\tconst struct xfs_owner_info\t*oinfo)\n{\n\tstruct xfs_mount\t\t*mp = cur->bc_mp;\n\tstruct xfs_rmap_irec\t\tltrec;\n\tuint64_t\t\t\tltoff;\n\tint\t\t\t\terror = 0;\n\tint\t\t\t\ti;\n\tuint64_t\t\t\towner;\n\tuint64_t\t\t\toffset;\n\tunsigned int\t\t\tflags;\n\n\txfs_owner_info_unpack(oinfo, &owner, &offset, &flags);\n\tif (unwritten)\n\t\tflags |= XFS_RMAP_UNWRITTEN;\n\ttrace_xfs_rmap_unmap(mp, cur->bc_ag.pag->pag_agno, bno, len,\n\t\t\tunwritten, oinfo);\n\n\t \n\terror = xfs_rmap_lookup_le_range(cur, bno, owner, offset, flags,\n\t\t\t&ltrec, &i);\n\tif (error)\n\t\tgoto out_error;\n\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_error;\n\t}\n\tltoff = ltrec.rm_offset;\n\n\t \n\tif (XFS_IS_CORRUPT(mp,\n\t\t\t   ltrec.rm_startblock > bno ||\n\t\t\t   ltrec.rm_startblock + ltrec.rm_blockcount <\n\t\t\t   bno + len)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_error;\n\t}\n\n\t \n\tif (XFS_IS_CORRUPT(mp, owner != ltrec.rm_owner)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_error;\n\t}\n\n\t \n\tif (XFS_IS_CORRUPT(mp,\n\t\t\t   (flags & XFS_RMAP_UNWRITTEN) !=\n\t\t\t   (ltrec.rm_flags & XFS_RMAP_UNWRITTEN))) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_error;\n\t}\n\n\t \n\tif (XFS_IS_CORRUPT(mp, ltrec.rm_offset > offset)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_error;\n\t}\n\tif (XFS_IS_CORRUPT(mp, offset > ltoff + ltrec.rm_blockcount)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_error;\n\t}\n\n\tif (ltrec.rm_startblock == bno && ltrec.rm_blockcount == len) {\n\t\t \n\t\terror = xfs_rmap_delete(cur, ltrec.rm_startblock,\n\t\t\t\tltrec.rm_blockcount, ltrec.rm_owner,\n\t\t\t\tltrec.rm_offset, ltrec.rm_flags);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t} else if (ltrec.rm_startblock == bno) {\n\t\t \n\n\t\t \n\t\terror = xfs_rmap_delete(cur, ltrec.rm_startblock,\n\t\t\t\tltrec.rm_blockcount, ltrec.rm_owner,\n\t\t\t\tltrec.rm_offset, ltrec.rm_flags);\n\t\tif (error)\n\t\t\tgoto out_error;\n\n\t\t \n\t\tltrec.rm_startblock += len;\n\t\tltrec.rm_blockcount -= len;\n\t\tltrec.rm_offset += len;\n\t\terror = xfs_rmap_insert(cur, ltrec.rm_startblock,\n\t\t\t\tltrec.rm_blockcount, ltrec.rm_owner,\n\t\t\t\tltrec.rm_offset, ltrec.rm_flags);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t} else if (ltrec.rm_startblock + ltrec.rm_blockcount == bno + len) {\n\t\t \n\t\terror = xfs_rmap_lookup_eq(cur, ltrec.rm_startblock,\n\t\t\t\tltrec.rm_blockcount, ltrec.rm_owner,\n\t\t\t\tltrec.rm_offset, ltrec.rm_flags, &i);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_error;\n\t\t}\n\t\tltrec.rm_blockcount -= len;\n\t\terror = xfs_rmap_update(cur, &ltrec);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t} else {\n\t\t \n\t\txfs_extlen_t\torig_len = ltrec.rm_blockcount;\n\n\t\t \n\t\terror = xfs_rmap_lookup_eq(cur, ltrec.rm_startblock,\n\t\t\t\tltrec.rm_blockcount, ltrec.rm_owner,\n\t\t\t\tltrec.rm_offset, ltrec.rm_flags, &i);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_error;\n\t\t}\n\t\tltrec.rm_blockcount = bno - ltrec.rm_startblock;\n\t\terror = xfs_rmap_update(cur, &ltrec);\n\t\tif (error)\n\t\t\tgoto out_error;\n\n\t\t \n\t\terror = xfs_rmap_insert(cur, bno + len,\n\t\t\t\torig_len - len - ltrec.rm_blockcount,\n\t\t\t\tltrec.rm_owner, offset + len,\n\t\t\t\tltrec.rm_flags);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t}\n\n\ttrace_xfs_rmap_unmap_done(mp, cur->bc_ag.pag->pag_agno, bno, len,\n\t\t\tunwritten, oinfo);\nout_error:\n\tif (error)\n\t\ttrace_xfs_rmap_unmap_error(cur->bc_mp,\n\t\t\t\tcur->bc_ag.pag->pag_agno, error, _RET_IP_);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_rmap_map_shared(\n\tstruct xfs_btree_cur\t\t*cur,\n\txfs_agblock_t\t\t\tbno,\n\txfs_extlen_t\t\t\tlen,\n\tbool\t\t\t\tunwritten,\n\tconst struct xfs_owner_info\t*oinfo)\n{\n\tstruct xfs_mount\t\t*mp = cur->bc_mp;\n\tstruct xfs_rmap_irec\t\tltrec;\n\tstruct xfs_rmap_irec\t\tgtrec;\n\tint\t\t\t\thave_gt;\n\tint\t\t\t\thave_lt;\n\tint\t\t\t\terror = 0;\n\tint\t\t\t\ti;\n\tuint64_t\t\t\towner;\n\tuint64_t\t\t\toffset;\n\tunsigned int\t\t\tflags = 0;\n\n\txfs_owner_info_unpack(oinfo, &owner, &offset, &flags);\n\tif (unwritten)\n\t\tflags |= XFS_RMAP_UNWRITTEN;\n\ttrace_xfs_rmap_map(mp, cur->bc_ag.pag->pag_agno, bno, len,\n\t\t\tunwritten, oinfo);\n\n\t \n\terror = xfs_rmap_find_left_neighbor(cur, bno, owner, offset, flags,\n\t\t\t&ltrec, &have_lt);\n\tif (error)\n\t\tgoto out_error;\n\tif (have_lt &&\n\t    !xfs_rmap_is_mergeable(&ltrec, owner, flags))\n\t\thave_lt = 0;\n\n\t \n\terror = xfs_rmap_lookup_eq(cur, bno + len, len, owner, offset + len,\n\t\t\tflags, &have_gt);\n\tif (error)\n\t\tgoto out_error;\n\tif (have_gt) {\n\t\terror = xfs_rmap_get_rec(cur, &gtrec, &have_gt);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t\tif (XFS_IS_CORRUPT(mp, have_gt != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_error;\n\t\t}\n\t\ttrace_xfs_rmap_find_right_neighbor_result(cur->bc_mp,\n\t\t\tcur->bc_ag.pag->pag_agno, gtrec.rm_startblock,\n\t\t\tgtrec.rm_blockcount, gtrec.rm_owner,\n\t\t\tgtrec.rm_offset, gtrec.rm_flags);\n\n\t\tif (!xfs_rmap_is_mergeable(&gtrec, owner, flags))\n\t\t\thave_gt = 0;\n\t}\n\n\tif (have_lt &&\n\t    ltrec.rm_startblock + ltrec.rm_blockcount == bno &&\n\t    ltrec.rm_offset + ltrec.rm_blockcount == offset) {\n\t\t \n\t\tltrec.rm_blockcount += len;\n\t\tif (have_gt &&\n\t\t    bno + len == gtrec.rm_startblock &&\n\t\t    offset + len == gtrec.rm_offset) {\n\t\t\t \n\t\t\tltrec.rm_blockcount += gtrec.rm_blockcount;\n\t\t\terror = xfs_rmap_delete(cur, gtrec.rm_startblock,\n\t\t\t\t\tgtrec.rm_blockcount, gtrec.rm_owner,\n\t\t\t\t\tgtrec.rm_offset, gtrec.rm_flags);\n\t\t\tif (error)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t \n\t\terror = xfs_rmap_lookup_eq(cur, ltrec.rm_startblock,\n\t\t\t\tltrec.rm_blockcount, ltrec.rm_owner,\n\t\t\t\tltrec.rm_offset, ltrec.rm_flags, &i);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\terror = xfs_rmap_update(cur, &ltrec);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t} else if (have_gt &&\n\t\t   bno + len == gtrec.rm_startblock &&\n\t\t   offset + len == gtrec.rm_offset) {\n\t\t \n\t\t \n\t\terror = xfs_rmap_delete(cur, gtrec.rm_startblock,\n\t\t\t\tgtrec.rm_blockcount, gtrec.rm_owner,\n\t\t\t\tgtrec.rm_offset, gtrec.rm_flags);\n\t\tif (error)\n\t\t\tgoto out_error;\n\n\t\t \n\t\tgtrec.rm_startblock = bno;\n\t\tgtrec.rm_blockcount += len;\n\t\tgtrec.rm_offset = offset;\n\t\terror = xfs_rmap_insert(cur, gtrec.rm_startblock,\n\t\t\t\tgtrec.rm_blockcount, gtrec.rm_owner,\n\t\t\t\tgtrec.rm_offset, gtrec.rm_flags);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t} else {\n\t\t \n\t\terror = xfs_rmap_insert(cur, bno, len, owner, offset, flags);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t}\n\n\ttrace_xfs_rmap_map_done(mp, cur->bc_ag.pag->pag_agno, bno, len,\n\t\t\tunwritten, oinfo);\nout_error:\n\tif (error)\n\t\ttrace_xfs_rmap_map_error(cur->bc_mp,\n\t\t\t\tcur->bc_ag.pag->pag_agno, error, _RET_IP_);\n\treturn error;\n}\n\n \nint\nxfs_rmap_map_raw(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_rmap_irec\t*rmap)\n{\n\tstruct xfs_owner_info\toinfo;\n\n\toinfo.oi_owner = rmap->rm_owner;\n\toinfo.oi_offset = rmap->rm_offset;\n\toinfo.oi_flags = 0;\n\tif (rmap->rm_flags & XFS_RMAP_ATTR_FORK)\n\t\toinfo.oi_flags |= XFS_OWNER_INFO_ATTR_FORK;\n\tif (rmap->rm_flags & XFS_RMAP_BMBT_BLOCK)\n\t\toinfo.oi_flags |= XFS_OWNER_INFO_BMBT_BLOCK;\n\n\tif (rmap->rm_flags || XFS_RMAP_NON_INODE_OWNER(rmap->rm_owner))\n\t\treturn xfs_rmap_map(cur, rmap->rm_startblock,\n\t\t\t\trmap->rm_blockcount,\n\t\t\t\trmap->rm_flags & XFS_RMAP_UNWRITTEN,\n\t\t\t\t&oinfo);\n\n\treturn xfs_rmap_map_shared(cur, rmap->rm_startblock,\n\t\t\trmap->rm_blockcount,\n\t\t\trmap->rm_flags & XFS_RMAP_UNWRITTEN,\n\t\t\t&oinfo);\n}\n\nstruct xfs_rmap_query_range_info {\n\txfs_rmap_query_range_fn\tfn;\n\tvoid\t\t\t\t*priv;\n};\n\n \nSTATIC int\nxfs_rmap_query_range_helper(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst union xfs_btree_rec\t*rec,\n\tvoid\t\t\t\t*priv)\n{\n\tstruct xfs_rmap_query_range_info\t*query = priv;\n\tstruct xfs_rmap_irec\t\t\tirec;\n\txfs_failaddr_t\t\t\t\tfa;\n\n\tfa = xfs_rmap_btrec_to_irec(rec, &irec);\n\tif (!fa)\n\t\tfa = xfs_rmap_check_irec(cur, &irec);\n\tif (fa)\n\t\treturn xfs_rmap_complain_bad_rec(cur, fa, &irec);\n\n\treturn query->fn(cur, &irec, query->priv);\n}\n\n \nint\nxfs_rmap_query_range(\n\tstruct xfs_btree_cur\t\t\t*cur,\n\tconst struct xfs_rmap_irec\t\t*low_rec,\n\tconst struct xfs_rmap_irec\t\t*high_rec,\n\txfs_rmap_query_range_fn\t\t\tfn,\n\tvoid\t\t\t\t\t*priv)\n{\n\tunion xfs_btree_irec\t\t\tlow_brec = { .r = *low_rec };\n\tunion xfs_btree_irec\t\t\thigh_brec = { .r = *high_rec };\n\tstruct xfs_rmap_query_range_info\tquery = { .priv = priv, .fn = fn };\n\n\treturn xfs_btree_query_range(cur, &low_brec, &high_brec,\n\t\t\txfs_rmap_query_range_helper, &query);\n}\n\n \nint\nxfs_rmap_query_all(\n\tstruct xfs_btree_cur\t\t\t*cur,\n\txfs_rmap_query_range_fn\t\t\tfn,\n\tvoid\t\t\t\t\t*priv)\n{\n\tstruct xfs_rmap_query_range_info\tquery;\n\n\tquery.priv = priv;\n\tquery.fn = fn;\n\treturn xfs_btree_query_all(cur, xfs_rmap_query_range_helper, &query);\n}\n\n \nvoid\nxfs_rmap_finish_one_cleanup(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_btree_cur\t*rcur,\n\tint\t\t\terror)\n{\n\tstruct xfs_buf\t\t*agbp;\n\n\tif (rcur == NULL)\n\t\treturn;\n\tagbp = rcur->bc_ag.agbp;\n\txfs_btree_del_cursor(rcur, error);\n\tif (error)\n\t\txfs_trans_brelse(tp, agbp);\n}\n\n \nint\nxfs_rmap_finish_one(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_rmap_intent\t\t*ri,\n\tstruct xfs_btree_cur\t\t**pcur)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_btree_cur\t\t*rcur;\n\tstruct xfs_buf\t\t\t*agbp = NULL;\n\tint\t\t\t\terror = 0;\n\tstruct xfs_owner_info\t\toinfo;\n\txfs_agblock_t\t\t\tbno;\n\tbool\t\t\t\tunwritten;\n\n\tbno = XFS_FSB_TO_AGBNO(mp, ri->ri_bmap.br_startblock);\n\n\ttrace_xfs_rmap_deferred(mp, ri->ri_pag->pag_agno, ri->ri_type, bno,\n\t\t\tri->ri_owner, ri->ri_whichfork,\n\t\t\tri->ri_bmap.br_startoff, ri->ri_bmap.br_blockcount,\n\t\t\tri->ri_bmap.br_state);\n\n\tif (XFS_TEST_ERROR(false, mp, XFS_ERRTAG_RMAP_FINISH_ONE))\n\t\treturn -EIO;\n\n\t \n\trcur = *pcur;\n\tif (rcur != NULL && rcur->bc_ag.pag != ri->ri_pag) {\n\t\txfs_rmap_finish_one_cleanup(tp, rcur, 0);\n\t\trcur = NULL;\n\t\t*pcur = NULL;\n\t}\n\tif (rcur == NULL) {\n\t\t \n\t\terror = xfs_free_extent_fix_freelist(tp, ri->ri_pag, &agbp);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (XFS_IS_CORRUPT(tp->t_mountp, !agbp))\n\t\t\treturn -EFSCORRUPTED;\n\n\t\trcur = xfs_rmapbt_init_cursor(mp, tp, agbp, ri->ri_pag);\n\t}\n\t*pcur = rcur;\n\n\txfs_rmap_ino_owner(&oinfo, ri->ri_owner, ri->ri_whichfork,\n\t\t\tri->ri_bmap.br_startoff);\n\tunwritten = ri->ri_bmap.br_state == XFS_EXT_UNWRITTEN;\n\tbno = XFS_FSB_TO_AGBNO(rcur->bc_mp, ri->ri_bmap.br_startblock);\n\n\tswitch (ri->ri_type) {\n\tcase XFS_RMAP_ALLOC:\n\tcase XFS_RMAP_MAP:\n\t\terror = xfs_rmap_map(rcur, bno, ri->ri_bmap.br_blockcount,\n\t\t\t\tunwritten, &oinfo);\n\t\tbreak;\n\tcase XFS_RMAP_MAP_SHARED:\n\t\terror = xfs_rmap_map_shared(rcur, bno,\n\t\t\t\tri->ri_bmap.br_blockcount, unwritten, &oinfo);\n\t\tbreak;\n\tcase XFS_RMAP_FREE:\n\tcase XFS_RMAP_UNMAP:\n\t\terror = xfs_rmap_unmap(rcur, bno, ri->ri_bmap.br_blockcount,\n\t\t\t\tunwritten, &oinfo);\n\t\tbreak;\n\tcase XFS_RMAP_UNMAP_SHARED:\n\t\terror = xfs_rmap_unmap_shared(rcur, bno,\n\t\t\t\tri->ri_bmap.br_blockcount, unwritten, &oinfo);\n\t\tbreak;\n\tcase XFS_RMAP_CONVERT:\n\t\terror = xfs_rmap_convert(rcur, bno, ri->ri_bmap.br_blockcount,\n\t\t\t\t!unwritten, &oinfo);\n\t\tbreak;\n\tcase XFS_RMAP_CONVERT_SHARED:\n\t\terror = xfs_rmap_convert_shared(rcur, bno,\n\t\t\t\tri->ri_bmap.br_blockcount, !unwritten, &oinfo);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t}\n\n\treturn error;\n}\n\n \nstatic bool\nxfs_rmap_update_is_needed(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\twhichfork)\n{\n\treturn xfs_has_rmapbt(mp) && whichfork != XFS_COW_FORK;\n}\n\n \nstatic void\n__xfs_rmap_add(\n\tstruct xfs_trans\t\t*tp,\n\tenum xfs_rmap_intent_type\ttype,\n\tuint64_t\t\t\towner,\n\tint\t\t\t\twhichfork,\n\tstruct xfs_bmbt_irec\t\t*bmap)\n{\n\tstruct xfs_rmap_intent\t\t*ri;\n\n\ttrace_xfs_rmap_defer(tp->t_mountp,\n\t\t\tXFS_FSB_TO_AGNO(tp->t_mountp, bmap->br_startblock),\n\t\t\ttype,\n\t\t\tXFS_FSB_TO_AGBNO(tp->t_mountp, bmap->br_startblock),\n\t\t\towner, whichfork,\n\t\t\tbmap->br_startoff,\n\t\t\tbmap->br_blockcount,\n\t\t\tbmap->br_state);\n\n\tri = kmem_cache_alloc(xfs_rmap_intent_cache, GFP_NOFS | __GFP_NOFAIL);\n\tINIT_LIST_HEAD(&ri->ri_list);\n\tri->ri_type = type;\n\tri->ri_owner = owner;\n\tri->ri_whichfork = whichfork;\n\tri->ri_bmap = *bmap;\n\n\txfs_rmap_update_get_group(tp->t_mountp, ri);\n\txfs_defer_add(tp, XFS_DEFER_OPS_TYPE_RMAP, &ri->ri_list);\n}\n\n \nvoid\nxfs_rmap_map_extent(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tstruct xfs_bmbt_irec\t*PREV)\n{\n\tenum xfs_rmap_intent_type type = XFS_RMAP_MAP;\n\n\tif (!xfs_rmap_update_is_needed(tp->t_mountp, whichfork))\n\t\treturn;\n\n\tif (whichfork != XFS_ATTR_FORK && xfs_is_reflink_inode(ip))\n\t\ttype = XFS_RMAP_MAP_SHARED;\n\n\t__xfs_rmap_add(tp, type, ip->i_ino, whichfork, PREV);\n}\n\n \nvoid\nxfs_rmap_unmap_extent(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tstruct xfs_bmbt_irec\t*PREV)\n{\n\tenum xfs_rmap_intent_type type = XFS_RMAP_UNMAP;\n\n\tif (!xfs_rmap_update_is_needed(tp->t_mountp, whichfork))\n\t\treturn;\n\n\tif (whichfork != XFS_ATTR_FORK && xfs_is_reflink_inode(ip))\n\t\ttype = XFS_RMAP_UNMAP_SHARED;\n\n\t__xfs_rmap_add(tp, type, ip->i_ino, whichfork, PREV);\n}\n\n \nvoid\nxfs_rmap_convert_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tstruct xfs_bmbt_irec\t*PREV)\n{\n\tenum xfs_rmap_intent_type type = XFS_RMAP_CONVERT;\n\n\tif (!xfs_rmap_update_is_needed(mp, whichfork))\n\t\treturn;\n\n\tif (whichfork != XFS_ATTR_FORK && xfs_is_reflink_inode(ip))\n\t\ttype = XFS_RMAP_CONVERT_SHARED;\n\n\t__xfs_rmap_add(tp, type, ip->i_ino, whichfork, PREV);\n}\n\n \nvoid\nxfs_rmap_alloc_extent(\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\tuint64_t\t\towner)\n{\n\tstruct xfs_bmbt_irec\tbmap;\n\n\tif (!xfs_rmap_update_is_needed(tp->t_mountp, XFS_DATA_FORK))\n\t\treturn;\n\n\tbmap.br_startblock = XFS_AGB_TO_FSB(tp->t_mountp, agno, bno);\n\tbmap.br_blockcount = len;\n\tbmap.br_startoff = 0;\n\tbmap.br_state = XFS_EXT_NORM;\n\n\t__xfs_rmap_add(tp, XFS_RMAP_ALLOC, owner, XFS_DATA_FORK, &bmap);\n}\n\n \nvoid\nxfs_rmap_free_extent(\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\tuint64_t\t\towner)\n{\n\tstruct xfs_bmbt_irec\tbmap;\n\n\tif (!xfs_rmap_update_is_needed(tp->t_mountp, XFS_DATA_FORK))\n\t\treturn;\n\n\tbmap.br_startblock = XFS_AGB_TO_FSB(tp->t_mountp, agno, bno);\n\tbmap.br_blockcount = len;\n\tbmap.br_startoff = 0;\n\tbmap.br_state = XFS_EXT_NORM;\n\n\t__xfs_rmap_add(tp, XFS_RMAP_FREE, owner, XFS_DATA_FORK, &bmap);\n}\n\n \nint\nxfs_rmap_compare(\n\tconst struct xfs_rmap_irec\t*a,\n\tconst struct xfs_rmap_irec\t*b)\n{\n\t__u64\t\t\t\toa;\n\t__u64\t\t\t\tob;\n\n\toa = xfs_rmap_irec_offset_pack(a);\n\tob = xfs_rmap_irec_offset_pack(b);\n\n\tif (a->rm_startblock < b->rm_startblock)\n\t\treturn -1;\n\telse if (a->rm_startblock > b->rm_startblock)\n\t\treturn 1;\n\telse if (a->rm_owner < b->rm_owner)\n\t\treturn -1;\n\telse if (a->rm_owner > b->rm_owner)\n\t\treturn 1;\n\telse if (oa < ob)\n\t\treturn -1;\n\telse if (oa > ob)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nint\nxfs_rmap_has_records(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\tenum xbtree_recpacking\t*outcome)\n{\n\tunion xfs_btree_key\tmask = {\n\t\t.rmap.rm_startblock = cpu_to_be32(-1U),\n\t};\n\tunion xfs_btree_irec\tlow;\n\tunion xfs_btree_irec\thigh;\n\n\tmemset(&low, 0, sizeof(low));\n\tlow.r.rm_startblock = bno;\n\tmemset(&high, 0xFF, sizeof(high));\n\thigh.r.rm_startblock = bno + len - 1;\n\n\treturn xfs_btree_has_records(cur, &low, &high, &mask, outcome);\n}\n\nstruct xfs_rmap_ownercount {\n\t \n\tstruct xfs_rmap_irec\tgood;\n\n\t \n\tstruct xfs_rmap_irec\tlow;\n\tstruct xfs_rmap_irec\thigh;\n\n\tstruct xfs_rmap_matches\t*results;\n\n\t \n\tbool\t\t\tstop_on_nonmatch;\n};\n\n \nstatic inline bool\nxfs_rmap_shareable(\n\tstruct xfs_mount\t\t*mp,\n\tconst struct xfs_rmap_irec\t*rmap)\n{\n\tif (!xfs_has_reflink(mp))\n\t\treturn false;\n\tif (XFS_RMAP_NON_INODE_OWNER(rmap->rm_owner))\n\t\treturn false;\n\tif (rmap->rm_flags & (XFS_RMAP_ATTR_FORK |\n\t\t\t      XFS_RMAP_BMBT_BLOCK))\n\t\treturn false;\n\treturn true;\n}\n\nstatic inline void\nxfs_rmap_ownercount_init(\n\tstruct xfs_rmap_ownercount\t*roc,\n\txfs_agblock_t\t\t\tbno,\n\txfs_extlen_t\t\t\tlen,\n\tconst struct xfs_owner_info\t*oinfo,\n\tstruct xfs_rmap_matches\t\t*results)\n{\n\tmemset(roc, 0, sizeof(*roc));\n\troc->results = results;\n\n\troc->low.rm_startblock = bno;\n\tmemset(&roc->high, 0xFF, sizeof(roc->high));\n\troc->high.rm_startblock = bno + len - 1;\n\n\tmemset(results, 0, sizeof(*results));\n\troc->good.rm_startblock = bno;\n\troc->good.rm_blockcount = len;\n\troc->good.rm_owner = oinfo->oi_owner;\n\troc->good.rm_offset = oinfo->oi_offset;\n\tif (oinfo->oi_flags & XFS_OWNER_INFO_ATTR_FORK)\n\t\troc->good.rm_flags |= XFS_RMAP_ATTR_FORK;\n\tif (oinfo->oi_flags & XFS_OWNER_INFO_BMBT_BLOCK)\n\t\troc->good.rm_flags |= XFS_RMAP_BMBT_BLOCK;\n}\n\n \nSTATIC int\nxfs_rmap_count_owners_helper(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst struct xfs_rmap_irec\t*rec,\n\tvoid\t\t\t\t*priv)\n{\n\tstruct xfs_rmap_ownercount\t*roc = priv;\n\tstruct xfs_rmap_irec\t\tcheck = *rec;\n\tunsigned int\t\t\tkeyflags;\n\tbool\t\t\t\tfiledata;\n\tint64_t\t\t\t\tdelta;\n\n\tfiledata = !XFS_RMAP_NON_INODE_OWNER(check.rm_owner) &&\n\t\t   !(check.rm_flags & XFS_RMAP_BMBT_BLOCK);\n\n\t \n\tdelta = (int64_t)roc->good.rm_startblock - check.rm_startblock;\n\tif (delta > 0) {\n\t\tcheck.rm_startblock += delta;\n\t\tcheck.rm_blockcount -= delta;\n\t\tif (filedata)\n\t\t\tcheck.rm_offset += delta;\n\t}\n\n\t \n\tdelta = (check.rm_startblock + check.rm_blockcount) -\n\t\t(roc->good.rm_startblock + roc->good.rm_blockcount);\n\tif (delta > 0)\n\t\tcheck.rm_blockcount -= delta;\n\n\t \n\tkeyflags = check.rm_flags & (XFS_RMAP_ATTR_FORK | XFS_RMAP_BMBT_BLOCK);\n\n\tif (check.rm_startblock\t== roc->good.rm_startblock &&\n\t    check.rm_blockcount\t== roc->good.rm_blockcount &&\n\t    check.rm_owner\t== roc->good.rm_owner &&\n\t    check.rm_offset\t== roc->good.rm_offset &&\n\t    keyflags\t\t== roc->good.rm_flags) {\n\t\troc->results->matches++;\n\t} else {\n\t\troc->results->non_owner_matches++;\n\t\tif (xfs_rmap_shareable(cur->bc_mp, &roc->good) ^\n\t\t    xfs_rmap_shareable(cur->bc_mp, &check))\n\t\t\troc->results->bad_non_owner_matches++;\n\t}\n\n\tif (roc->results->non_owner_matches && roc->stop_on_nonmatch)\n\t\treturn -ECANCELED;\n\n\treturn 0;\n}\n\n \nint\nxfs_rmap_count_owners(\n\tstruct xfs_btree_cur\t\t*cur,\n\txfs_agblock_t\t\t\tbno,\n\txfs_extlen_t\t\t\tlen,\n\tconst struct xfs_owner_info\t*oinfo,\n\tstruct xfs_rmap_matches\t\t*results)\n{\n\tstruct xfs_rmap_ownercount\troc;\n\tint\t\t\t\terror;\n\n\txfs_rmap_ownercount_init(&roc, bno, len, oinfo, results);\n\terror = xfs_rmap_query_range(cur, &roc.low, &roc.high,\n\t\t\txfs_rmap_count_owners_helper, &roc);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (!results->matches)\n\t\tresults->bad_non_owner_matches = 0;\n\n\treturn 0;\n}\n\n \nint\nxfs_rmap_has_other_keys(\n\tstruct xfs_btree_cur\t\t*cur,\n\txfs_agblock_t\t\t\tbno,\n\txfs_extlen_t\t\t\tlen,\n\tconst struct xfs_owner_info\t*oinfo,\n\tbool\t\t\t\t*has_other)\n{\n\tstruct xfs_rmap_matches\t\tres;\n\tstruct xfs_rmap_ownercount\troc;\n\tint\t\t\t\terror;\n\n\txfs_rmap_ownercount_init(&roc, bno, len, oinfo, &res);\n\troc.stop_on_nonmatch = true;\n\n\terror = xfs_rmap_query_range(cur, &roc.low, &roc.high,\n\t\t\txfs_rmap_count_owners_helper, &roc);\n\tif (error == -ECANCELED) {\n\t\t*has_other = true;\n\t\treturn 0;\n\t}\n\tif (error)\n\t\treturn error;\n\n\t*has_other = false;\n\treturn 0;\n}\n\nconst struct xfs_owner_info XFS_RMAP_OINFO_SKIP_UPDATE = {\n\t.oi_owner = XFS_RMAP_OWN_NULL,\n};\nconst struct xfs_owner_info XFS_RMAP_OINFO_ANY_OWNER = {\n\t.oi_owner = XFS_RMAP_OWN_UNKNOWN,\n};\nconst struct xfs_owner_info XFS_RMAP_OINFO_FS = {\n\t.oi_owner = XFS_RMAP_OWN_FS,\n};\nconst struct xfs_owner_info XFS_RMAP_OINFO_LOG = {\n\t.oi_owner = XFS_RMAP_OWN_LOG,\n};\nconst struct xfs_owner_info XFS_RMAP_OINFO_AG = {\n\t.oi_owner = XFS_RMAP_OWN_AG,\n};\nconst struct xfs_owner_info XFS_RMAP_OINFO_INOBT = {\n\t.oi_owner = XFS_RMAP_OWN_INOBT,\n};\nconst struct xfs_owner_info XFS_RMAP_OINFO_INODES = {\n\t.oi_owner = XFS_RMAP_OWN_INODES,\n};\nconst struct xfs_owner_info XFS_RMAP_OINFO_REFC = {\n\t.oi_owner = XFS_RMAP_OWN_REFC,\n};\nconst struct xfs_owner_info XFS_RMAP_OINFO_COW = {\n\t.oi_owner = XFS_RMAP_OWN_COW,\n};\n\nint __init\nxfs_rmap_intent_init_cache(void)\n{\n\txfs_rmap_intent_cache = kmem_cache_create(\"xfs_rmap_intent\",\n\t\t\tsizeof(struct xfs_rmap_intent),\n\t\t\t0, 0, NULL);\n\n\treturn xfs_rmap_intent_cache != NULL ? 0 : -ENOMEM;\n}\n\nvoid\nxfs_rmap_intent_destroy_cache(void)\n{\n\tkmem_cache_destroy(xfs_rmap_intent_cache);\n\txfs_rmap_intent_cache = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}