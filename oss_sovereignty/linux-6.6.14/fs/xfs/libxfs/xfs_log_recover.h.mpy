{
  "module_name": "xfs_log_recover.h",
  "hash_id": "9b5a11e0b85676ecce9d7436dba756f74e22fff7ec01ad9ede14cbaae26c462b",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_log_recover.h",
  "human_readable_source": "\n \n#ifndef\t__XFS_LOG_RECOVER_H__\n#define __XFS_LOG_RECOVER_H__\n\n \nstruct xlog_recover_item;\n\n \nenum xlog_recover_reorder {\n\tXLOG_REORDER_BUFFER_LIST,\n\tXLOG_REORDER_ITEM_LIST,\n\tXLOG_REORDER_INODE_BUFFER_LIST,\n\tXLOG_REORDER_CANCEL_LIST,\n};\n\nstruct xlog_recover_item_ops {\n\tuint16_t\titem_type;\t \n\n\t \n\tenum xlog_recover_reorder (*reorder)(struct xlog_recover_item *item);\n\n\t \n\tvoid (*ra_pass2)(struct xlog *log, struct xlog_recover_item *item);\n\n\t \n\tint (*commit_pass1)(struct xlog *log, struct xlog_recover_item *item);\n\n\t \n\tint (*commit_pass2)(struct xlog *log, struct list_head *buffer_list,\n\t\t\t    struct xlog_recover_item *item, xfs_lsn_t lsn);\n};\n\nextern const struct xlog_recover_item_ops xlog_icreate_item_ops;\nextern const struct xlog_recover_item_ops xlog_buf_item_ops;\nextern const struct xlog_recover_item_ops xlog_inode_item_ops;\nextern const struct xlog_recover_item_ops xlog_dquot_item_ops;\nextern const struct xlog_recover_item_ops xlog_quotaoff_item_ops;\nextern const struct xlog_recover_item_ops xlog_bui_item_ops;\nextern const struct xlog_recover_item_ops xlog_bud_item_ops;\nextern const struct xlog_recover_item_ops xlog_efi_item_ops;\nextern const struct xlog_recover_item_ops xlog_efd_item_ops;\nextern const struct xlog_recover_item_ops xlog_rui_item_ops;\nextern const struct xlog_recover_item_ops xlog_rud_item_ops;\nextern const struct xlog_recover_item_ops xlog_cui_item_ops;\nextern const struct xlog_recover_item_ops xlog_cud_item_ops;\nextern const struct xlog_recover_item_ops xlog_attri_item_ops;\nextern const struct xlog_recover_item_ops xlog_attrd_item_ops;\n\n \n\n#define XLOG_RHASH_BITS  4\n#define XLOG_RHASH_SIZE\t16\n#define XLOG_RHASH_SHIFT 2\n#define XLOG_RHASH(tid)\t\\\n\t((((uint32_t)tid)>>XLOG_RHASH_SHIFT) & (XLOG_RHASH_SIZE-1))\n\n#define XLOG_MAX_REGIONS_IN_ITEM   (XFS_MAX_BLOCKSIZE / XFS_BLF_CHUNK / 2 + 1)\n\n\n \nstruct xlog_recover_item {\n\tstruct list_head\tri_list;\n\tint\t\t\tri_cnt;\t \n\tint\t\t\tri_total;\t \n\tstruct xfs_log_iovec\t*ri_buf;\t \n\tconst struct xlog_recover_item_ops *ri_ops;\n};\n\nstruct xlog_recover {\n\tstruct hlist_node\tr_list;\n\txlog_tid_t\t\tr_log_tid;\t \n\txfs_trans_header_t\tr_theader;\t \n\tint\t\t\tr_state;\t \n\txfs_lsn_t\t\tr_lsn;\t\t \n\tstruct list_head\tr_itemq;\t \n};\n\n#define ITEM_TYPE(i)\t(*(unsigned short *)(i)->ri_buf[0].i_addr)\n\n#define\tXLOG_RECOVER_CRCPASS\t0\n#define\tXLOG_RECOVER_PASS1\t1\n#define\tXLOG_RECOVER_PASS2\t2\n\nvoid xlog_buf_readahead(struct xlog *log, xfs_daddr_t blkno, uint len,\n\t\tconst struct xfs_buf_ops *ops);\nbool xlog_is_buffer_cancelled(struct xlog *log, xfs_daddr_t blkno, uint len);\n\nint xlog_recover_iget(struct xfs_mount *mp, xfs_ino_t ino,\n\t\tstruct xfs_inode **ipp);\nvoid xlog_recover_release_intent(struct xlog *log, unsigned short intent_type,\n\t\tuint64_t intent_id);\nint xlog_alloc_buf_cancel_table(struct xlog *log);\nvoid xlog_free_buf_cancel_table(struct xlog *log);\n\n#ifdef DEBUG\nvoid xlog_check_buf_cancel_table(struct xlog *log);\n#else\n#define xlog_check_buf_cancel_table(log) do { } while (0)\n#endif\n\n \nstatic inline struct xfs_trans_res\nxlog_recover_resv(const struct xfs_trans_res *r)\n{\n\tstruct xfs_trans_res ret = {\n\t\t.tr_logres\t= r->tr_logres,\n\t\t.tr_logcount\t= 1,\n\t\t.tr_logflags\t= r->tr_logflags,\n\t};\n\n\treturn ret;\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}