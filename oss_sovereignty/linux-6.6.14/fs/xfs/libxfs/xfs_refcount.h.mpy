{
  "module_name": "xfs_refcount.h",
  "hash_id": "e300be74de2c982a322eda9f4468ea4d656d926eda7cce5b6028f877aa4ec87b",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_refcount.h",
  "human_readable_source": "\n \n#ifndef __XFS_REFCOUNT_H__\n#define __XFS_REFCOUNT_H__\n\nstruct xfs_trans;\nstruct xfs_mount;\nstruct xfs_perag;\nstruct xfs_btree_cur;\nstruct xfs_bmbt_irec;\nstruct xfs_refcount_irec;\n\nextern int xfs_refcount_lookup_le(struct xfs_btree_cur *cur,\n\t\tenum xfs_refc_domain domain, xfs_agblock_t bno, int *stat);\nextern int xfs_refcount_lookup_ge(struct xfs_btree_cur *cur,\n\t\tenum xfs_refc_domain domain, xfs_agblock_t bno, int *stat);\nextern int xfs_refcount_lookup_eq(struct xfs_btree_cur *cur,\n\t\tenum xfs_refc_domain domain, xfs_agblock_t bno, int *stat);\nextern int xfs_refcount_get_rec(struct xfs_btree_cur *cur,\n\t\tstruct xfs_refcount_irec *irec, int *stat);\n\nstatic inline uint32_t\nxfs_refcount_encode_startblock(\n\txfs_agblock_t\t\tstartblock,\n\tenum xfs_refc_domain\tdomain)\n{\n\tuint32_t\t\tstart;\n\n\t \n\tstart = startblock & ~XFS_REFC_COWFLAG;\n\tif (domain != XFS_REFC_DOMAIN_SHARED)\n\t\tstart |= XFS_REFC_COWFLAG;\n\n\treturn start;\n}\n\nenum xfs_refcount_intent_type {\n\tXFS_REFCOUNT_INCREASE = 1,\n\tXFS_REFCOUNT_DECREASE,\n\tXFS_REFCOUNT_ALLOC_COW,\n\tXFS_REFCOUNT_FREE_COW,\n};\n\nstruct xfs_refcount_intent {\n\tstruct list_head\t\t\tri_list;\n\tstruct xfs_perag\t\t\t*ri_pag;\n\tenum xfs_refcount_intent_type\t\tri_type;\n\txfs_extlen_t\t\t\t\tri_blockcount;\n\txfs_fsblock_t\t\t\t\tri_startblock;\n};\n\n \nstatic inline bool\nxfs_refcount_check_domain(\n\tconst struct xfs_refcount_irec\t*irec)\n{\n\tif (irec->rc_domain == XFS_REFC_DOMAIN_COW && irec->rc_refcount != 1)\n\t\treturn false;\n\tif (irec->rc_domain == XFS_REFC_DOMAIN_SHARED && irec->rc_refcount < 2)\n\t\treturn false;\n\treturn true;\n}\n\nvoid xfs_refcount_update_get_group(struct xfs_mount *mp,\n\t\tstruct xfs_refcount_intent *ri);\n\nvoid xfs_refcount_increase_extent(struct xfs_trans *tp,\n\t\tstruct xfs_bmbt_irec *irec);\nvoid xfs_refcount_decrease_extent(struct xfs_trans *tp,\n\t\tstruct xfs_bmbt_irec *irec);\n\nextern void xfs_refcount_finish_one_cleanup(struct xfs_trans *tp,\n\t\tstruct xfs_btree_cur *rcur, int error);\nextern int xfs_refcount_finish_one(struct xfs_trans *tp,\n\t\tstruct xfs_refcount_intent *ri, struct xfs_btree_cur **pcur);\n\nextern int xfs_refcount_find_shared(struct xfs_btree_cur *cur,\n\t\txfs_agblock_t agbno, xfs_extlen_t aglen, xfs_agblock_t *fbno,\n\t\txfs_extlen_t *flen, bool find_end_of_shared);\n\nvoid xfs_refcount_alloc_cow_extent(struct xfs_trans *tp, xfs_fsblock_t fsb,\n\t\txfs_extlen_t len);\nvoid xfs_refcount_free_cow_extent(struct xfs_trans *tp, xfs_fsblock_t fsb,\n\t\txfs_extlen_t len);\nextern int xfs_refcount_recover_cow_leftovers(struct xfs_mount *mp,\n\t\tstruct xfs_perag *pag);\n\n \n#define XFS_REFCOUNT_ITEM_OVERHEAD\t32\n\nextern int xfs_refcount_has_records(struct xfs_btree_cur *cur,\n\t\tenum xfs_refc_domain domain, xfs_agblock_t bno,\n\t\txfs_extlen_t len, enum xbtree_recpacking *outcome);\nunion xfs_btree_rec;\nextern void xfs_refcount_btrec_to_irec(const union xfs_btree_rec *rec,\n\t\tstruct xfs_refcount_irec *irec);\nxfs_failaddr_t xfs_refcount_check_irec(struct xfs_btree_cur *cur,\n\t\tconst struct xfs_refcount_irec *irec);\nextern int xfs_refcount_insert(struct xfs_btree_cur *cur,\n\t\tstruct xfs_refcount_irec *irec, int *stat);\n\nextern struct kmem_cache\t*xfs_refcount_intent_cache;\n\nint __init xfs_refcount_intent_init_cache(void);\nvoid xfs_refcount_intent_destroy_cache(void);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}