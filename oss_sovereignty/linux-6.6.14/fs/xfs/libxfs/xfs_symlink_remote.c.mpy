{
  "module_name": "xfs_symlink_remote.c",
  "hash_id": "e91c1586a0718d0003114e195e17618e4fce86803a3e1173562371ae01e99c1a",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_symlink_remote.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_log.h\"\n\n\n \nint\nxfs_symlink_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tpathlen)\n{\n\tint buflen = XFS_SYMLINK_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\n\treturn (pathlen + buflen - 1) / buflen;\n}\n\nint\nxfs_symlink_hdr_set(\n\tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tino,\n\tuint32_t\t\toffset,\n\tuint32_t\t\tsize,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dsymlink_hdr\t*dsl = bp->b_addr;\n\n\tif (!xfs_has_crc(mp))\n\t\treturn 0;\n\n\tmemset(dsl, 0, sizeof(struct xfs_dsymlink_hdr));\n\tdsl->sl_magic = cpu_to_be32(XFS_SYMLINK_MAGIC);\n\tdsl->sl_offset = cpu_to_be32(offset);\n\tdsl->sl_bytes = cpu_to_be32(size);\n\tuuid_copy(&dsl->sl_uuid, &mp->m_sb.sb_meta_uuid);\n\tdsl->sl_owner = cpu_to_be64(ino);\n\tdsl->sl_blkno = cpu_to_be64(xfs_buf_daddr(bp));\n\tbp->b_ops = &xfs_symlink_buf_ops;\n\n\treturn sizeof(struct xfs_dsymlink_hdr);\n}\n\n \nbool\nxfs_symlink_hdr_ok(\n\txfs_ino_t\t\tino,\n\tuint32_t\t\toffset,\n\tuint32_t\t\tsize,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dsymlink_hdr *dsl = bp->b_addr;\n\n\tif (offset != be32_to_cpu(dsl->sl_offset))\n\t\treturn false;\n\tif (size != be32_to_cpu(dsl->sl_bytes))\n\t\treturn false;\n\tif (ino != be64_to_cpu(dsl->sl_owner))\n\t\treturn false;\n\n\t \n\treturn true;\n}\n\nstatic xfs_failaddr_t\nxfs_symlink_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_dsymlink_hdr\t*dsl = bp->b_addr;\n\n\tif (!xfs_has_crc(mp))\n\t\treturn __this_address;\n\tif (!xfs_verify_magic(bp, dsl->sl_magic))\n\t\treturn __this_address;\n\tif (!uuid_equal(&dsl->sl_uuid, &mp->m_sb.sb_meta_uuid))\n\t\treturn __this_address;\n\tif (xfs_buf_daddr(bp) != be64_to_cpu(dsl->sl_blkno))\n\t\treturn __this_address;\n\tif (be32_to_cpu(dsl->sl_offset) +\n\t\t\t\tbe32_to_cpu(dsl->sl_bytes) >= XFS_SYMLINK_MAXLEN)\n\t\treturn __this_address;\n\tif (dsl->sl_owner == 0)\n\t\treturn __this_address;\n\tif (!xfs_log_check_lsn(mp, be64_to_cpu(dsl->sl_lsn)))\n\t\treturn __this_address;\n\n\treturn NULL;\n}\n\nstatic void\nxfs_symlink_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_mount;\n\txfs_failaddr_t\tfa;\n\n\t \n\tif (!xfs_has_crc(mp))\n\t\treturn;\n\n\tif (!xfs_buf_verify_cksum(bp, XFS_SYMLINK_CRC_OFF))\n\t\txfs_verifier_error(bp, -EFSBADCRC, __this_address);\n\telse {\n\t\tfa = xfs_symlink_verify(bp);\n\t\tif (fa)\n\t\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t}\n}\n\nstatic void\nxfs_symlink_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_log_item;\n\txfs_failaddr_t\t\tfa;\n\n\t \n\tif (!xfs_has_crc(mp))\n\t\treturn;\n\n\tfa = xfs_symlink_verify(bp);\n\tif (fa) {\n\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t\treturn;\n\t}\n\n\tif (bip) {\n\t\tstruct xfs_dsymlink_hdr *dsl = bp->b_addr;\n\t\tdsl->sl_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\t}\n\txfs_buf_update_cksum(bp, XFS_SYMLINK_CRC_OFF);\n}\n\nconst struct xfs_buf_ops xfs_symlink_buf_ops = {\n\t.name = \"xfs_symlink\",\n\t.magic = { 0, cpu_to_be32(XFS_SYMLINK_MAGIC) },\n\t.verify_read = xfs_symlink_read_verify,\n\t.verify_write = xfs_symlink_write_verify,\n\t.verify_struct = xfs_symlink_verify,\n};\n\nvoid\nxfs_symlink_local_to_remote(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_ifork\t*ifp)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tchar\t\t\t*buf;\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SYMLINK_BUF);\n\n\tif (!xfs_has_crc(mp)) {\n\t\tbp->b_ops = NULL;\n\t\tmemcpy(bp->b_addr, ifp->if_u1.if_data, ifp->if_bytes);\n\t\txfs_trans_log_buf(tp, bp, 0, ifp->if_bytes - 1);\n\t\treturn;\n\t}\n\n\t \n\tASSERT(BBTOB(bp->b_length) >=\n\t\t\tifp->if_bytes + sizeof(struct xfs_dsymlink_hdr));\n\n\tbp->b_ops = &xfs_symlink_buf_ops;\n\n\tbuf = bp->b_addr;\n\tbuf += xfs_symlink_hdr_set(mp, ip->i_ino, 0, ifp->if_bytes, bp);\n\tmemcpy(buf, ifp->if_u1.if_data, ifp->if_bytes);\n\txfs_trans_log_buf(tp, bp, 0, sizeof(struct xfs_dsymlink_hdr) +\n\t\t\t\t\tifp->if_bytes - 1);\n}\n\n \nxfs_failaddr_t\nxfs_symlink_shortform_verify(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, XFS_DATA_FORK);\n\tchar\t\t\t*sfp = (char *)ifp->if_u1.if_data;\n\tint\t\t\tsize = ifp->if_bytes;\n\tchar\t\t\t*endp = sfp + size;\n\n\tASSERT(ifp->if_format == XFS_DINODE_FMT_LOCAL);\n\n\t \n\tif (!size)\n\t\treturn __this_address;\n\n\t \n\tif (size < 0 || size > XFS_SYMLINK_MAXLEN)\n\t\treturn __this_address;\n\n\t \n\tif (memchr(sfp, 0, size - 1))\n\t\treturn __this_address;\n\n\t \n\tif (*endp != 0)\n\t\treturn __this_address;\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}