{
  "module_name": "xfs_log_rlimit.c",
  "hash_id": "be515ddf5789fcc6ddc6cb6258697a9197871fd6405629e88ee2ac8e753f9142",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_log_rlimit.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_trace.h\"\n\n \nSTATIC int\nxfs_log_calc_max_attrsetm_res(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\n\tsize = xfs_attr_leaf_entsize_local_max(mp->m_attr_geo->blksize) -\n\t       MAXNAMELEN - 1;\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tnblks += XFS_B_TO_FSB(mp, size);\n\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, size, XFS_ATTR_FORK);\n\n\treturn  M_RES(mp)->tr_attrsetm.tr_logres +\n\t\tM_RES(mp)->tr_attrsetrt.tr_logres * nblks;\n}\n\n \nstatic void\nxfs_log_calc_trans_resv_for_minlogblocks(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans_resv\t*resv)\n{\n\tunsigned int\t\trmap_maxlevels = mp->m_rmap_maxlevels;\n\n\t \n\tif (xfs_has_rmapbt(mp) && xfs_has_reflink(mp))\n\t\tmp->m_rmap_maxlevels = XFS_OLD_REFLINK_RMAP_MAXLEVELS;\n\n\txfs_trans_resv_calc(mp, resv);\n\n\tif (xfs_has_reflink(mp)) {\n\t\t \n\t\tresv->tr_write.tr_logcount = XFS_WRITE_LOG_COUNT_REFLINK;\n\t\tresv->tr_itruncate.tr_logcount =\n\t\t\t\tXFS_ITRUNCATE_LOG_COUNT_REFLINK;\n\t\tresv->tr_qm_dqalloc.tr_logcount = XFS_WRITE_LOG_COUNT_REFLINK;\n\t} else if (xfs_has_rmapbt(mp)) {\n\t\t \n\t\tresv->tr_write.tr_logcount = XFS_WRITE_LOG_COUNT;\n\t\tresv->tr_itruncate.tr_logcount = XFS_ITRUNCATE_LOG_COUNT;\n\t\tresv->tr_qm_dqalloc.tr_logcount = XFS_WRITE_LOG_COUNT;\n\t}\n\n\t \n\tresv->tr_write.tr_logres =\n\t\t\txfs_calc_write_reservation_minlogsize(mp);\n\tresv->tr_itruncate.tr_logres =\n\t\t\txfs_calc_itruncate_reservation_minlogsize(mp);\n\tresv->tr_qm_dqalloc.tr_logres =\n\t\t\txfs_calc_qm_dqalloc_reservation_minlogsize(mp);\n\n\t \n\tmp->m_rmap_maxlevels = rmap_maxlevels;\n}\n\n \nvoid\nxfs_log_get_max_trans_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans_res\t*max_resp)\n{\n\tstruct xfs_trans_resv\tresv = {};\n\tstruct xfs_trans_res\t*resp;\n\tstruct xfs_trans_res\t*end_resp;\n\tunsigned int\t\ti;\n\tint\t\t\tlog_space = 0;\n\tint\t\t\tattr_space;\n\n\tattr_space = xfs_log_calc_max_attrsetm_res(mp);\n\n\txfs_log_calc_trans_resv_for_minlogblocks(mp, &resv);\n\n\tresp = (struct xfs_trans_res *)&resv;\n\tend_resp = (struct xfs_trans_res *)(&resv + 1);\n\tfor (i = 0; resp < end_resp; i++, resp++) {\n\t\tint\t\ttmp = resp->tr_logcount > 1 ?\n\t\t\t\t      resp->tr_logres * resp->tr_logcount :\n\t\t\t\t      resp->tr_logres;\n\n\t\ttrace_xfs_trans_resv_calc_minlogsize(mp, i, resp);\n\t\tif (log_space < tmp) {\n\t\t\tlog_space = tmp;\n\t\t\t*max_resp = *resp;\t\t \n\t\t}\n\t}\n\n\tif (attr_space > log_space) {\n\t\t*max_resp = resv.tr_attrsetm;\t \n\t\tmax_resp->tr_logres = attr_space;\n\t}\n\ttrace_xfs_log_get_max_trans_res(mp, max_resp);\n}\n\n \nint\nxfs_log_calc_minimum_size(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_trans_res\ttres = {0};\n\tint\t\t\tmax_logres;\n\tint\t\t\tmin_logblks = 0;\n\tint\t\t\tlsunit = 0;\n\n\txfs_log_get_max_trans_res(mp, &tres);\n\n\tmax_logres = xfs_log_calc_unit_res(mp, tres.tr_logres);\n\tif (tres.tr_logcount > 1)\n\t\tmax_logres *= tres.tr_logcount;\n\n\tif (xfs_has_logv2(mp) && mp->m_sb.sb_logsunit > 1)\n\t\tlsunit = BTOBB(mp->m_sb.sb_logsunit);\n\n\t \n\tif (lsunit) {\n\t\tmin_logblks = roundup_64(BTOBB(max_logres), lsunit) +\n\t\t\t      2 * lsunit;\n\t} else\n\t\tmin_logblks = BTOBB(max_logres) + 2 * BBSIZE;\n\tmin_logblks *= XFS_MIN_LOG_FACTOR;\n\n\treturn XFS_BB_TO_FSB(mp, min_logblks);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}