{
  "module_name": "xfs_bmap.c",
  "hash_id": "175dc185fd171adc222ed2989bc78174c024e1f2307d88c9183d85b3a64b26ec",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_bmap.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_errortag.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_ag_resv.h\"\n#include \"xfs_refcount.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_iomap.h\"\n\nstruct kmem_cache\t\t*xfs_bmap_intent_cache;\n\n \n\n \nvoid\nxfs_bmap_compute_maxlevels(\n\txfs_mount_t\t*mp,\t\t \n\tint\t\twhichfork)\t \n{\n\tuint64_t\tmaxblocks;\t \n\txfs_extnum_t\tmaxleafents;\t \n\tint\t\tlevel;\t\t \n\tint\t\tmaxrootrecs;\t \n\tint\t\tminleafrecs;\t \n\tint\t\tminnoderecs;\t \n\tint\t\tsz;\t\t \n\n\t \n\tmaxleafents = xfs_iext_max_nextents(xfs_has_large_extent_counts(mp),\n\t\t\t\twhichfork);\n\tif (whichfork == XFS_DATA_FORK)\n\t\tsz = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\n\telse\n\t\tsz = XFS_BMDR_SPACE_CALC(MINABTPTRS);\n\n\tmaxrootrecs = xfs_bmdr_maxrecs(sz, 0);\n\tminleafrecs = mp->m_bmap_dmnr[0];\n\tminnoderecs = mp->m_bmap_dmnr[1];\n\tmaxblocks = howmany_64(maxleafents, minleafrecs);\n\tfor (level = 1; maxblocks > 1; level++) {\n\t\tif (maxblocks <= maxrootrecs)\n\t\t\tmaxblocks = 1;\n\t\telse\n\t\t\tmaxblocks = howmany_64(maxblocks, minnoderecs);\n\t}\n\tmp->m_bm_maxlevels[whichfork] = level;\n\tASSERT(mp->m_bm_maxlevels[whichfork] <= xfs_bmbt_maxlevels_ondisk());\n}\n\nunsigned int\nxfs_bmap_compute_attr_offset(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_sb.sb_inodesize == 256)\n\t\treturn XFS_LITINO(mp) - XFS_BMDR_SPACE_CALC(MINABTPTRS);\n\treturn XFS_BMDR_SPACE_CALC(6 * MINABTPTRS);\n}\n\nSTATIC int\t\t\t\t \nxfs_bmbt_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_bmbt_irec\t*irec,\n\tint\t\t\t*stat)\t \n{\n\tcur->bc_rec.b = *irec;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}\n\nSTATIC int\t\t\t\t \nxfs_bmbt_lookup_first(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t \n{\n\tcur->bc_rec.b.br_startoff = 0;\n\tcur->bc_rec.b.br_startblock = 0;\n\tcur->bc_rec.b.br_blockcount = 0;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_GE, stat);\n}\n\n \nstatic inline bool xfs_bmap_needs_btree(struct xfs_inode *ip, int whichfork)\n{\n\tstruct xfs_ifork *ifp = xfs_ifork_ptr(ip, whichfork);\n\n\treturn whichfork != XFS_COW_FORK &&\n\t\tifp->if_format == XFS_DINODE_FMT_EXTENTS &&\n\t\tifp->if_nextents > XFS_IFORK_MAXEXT(ip, whichfork);\n}\n\n \nstatic inline bool xfs_bmap_wants_extents(struct xfs_inode *ip, int whichfork)\n{\n\tstruct xfs_ifork *ifp = xfs_ifork_ptr(ip, whichfork);\n\n\treturn whichfork != XFS_COW_FORK &&\n\t\tifp->if_format == XFS_DINODE_FMT_BTREE &&\n\t\tifp->if_nextents <= XFS_IFORK_MAXEXT(ip, whichfork);\n}\n\n \nSTATIC int\nxfs_bmbt_update(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_bmbt_irec\t*irec)\n{\n\tunion xfs_btree_rec\trec;\n\n\txfs_bmbt_disk_set_all(&rec.bmbt, irec);\n\treturn xfs_btree_update(cur, &rec);\n}\n\n \nSTATIC xfs_filblks_t\nxfs_bmap_worst_indlen(\n\txfs_inode_t\t*ip,\t\t \n\txfs_filblks_t\tlen)\t\t \n{\n\tint\t\tlevel;\t\t \n\tint\t\tmaxrecs;\t \n\txfs_mount_t\t*mp;\t\t \n\txfs_filblks_t\trval;\t\t \n\n\tmp = ip->i_mount;\n\tmaxrecs = mp->m_bmap_dmxr[0];\n\tfor (level = 0, rval = 0;\n\t     level < XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK);\n\t     level++) {\n\t\tlen += maxrecs - 1;\n\t\tdo_div(len, maxrecs);\n\t\trval += len;\n\t\tif (len == 1)\n\t\t\treturn rval + XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK) -\n\t\t\t\tlevel - 1;\n\t\tif (level == 0)\n\t\t\tmaxrecs = mp->m_bmap_dmxr[1];\n\t}\n\treturn rval;\n}\n\n \nuint\nxfs_default_attroffset(\n\tstruct xfs_inode\t*ip)\n{\n\tif (ip->i_df.if_format == XFS_DINODE_FMT_DEV)\n\t\treturn roundup(sizeof(xfs_dev_t), 8);\n\treturn M_IGEO(ip->i_mount)->attr_fork_offset;\n}\n\n \nSTATIC void\nxfs_bmap_forkoff_reset(\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tif (whichfork == XFS_ATTR_FORK &&\n\t    ip->i_df.if_format != XFS_DINODE_FMT_DEV &&\n\t    ip->i_df.if_format != XFS_DINODE_FMT_BTREE) {\n\t\tuint\tdfl_forkoff = xfs_default_attroffset(ip) >> 3;\n\n\t\tif (dfl_forkoff > ip->i_forkoff)\n\t\t\tip->i_forkoff = dfl_forkoff;\n\t}\n}\n\n#ifdef DEBUG\nSTATIC struct xfs_buf *\nxfs_bmap_get_bp(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fsblock_t\t\tbno)\n{\n\tstruct xfs_log_item\t*lip;\n\tint\t\t\ti;\n\n\tif (!cur)\n\t\treturn NULL;\n\n\tfor (i = 0; i < cur->bc_maxlevels; i++) {\n\t\tif (!cur->bc_levels[i].bp)\n\t\t\tbreak;\n\t\tif (xfs_buf_daddr(cur->bc_levels[i].bp) == bno)\n\t\t\treturn cur->bc_levels[i].bp;\n\t}\n\n\t \n\tlist_for_each_entry(lip, &cur->bc_tp->t_items, li_trans) {\n\t\tstruct xfs_buf_log_item\t*bip = (struct xfs_buf_log_item *)lip;\n\n\t\tif (bip->bli_item.li_type == XFS_LI_BUF &&\n\t\t    xfs_buf_daddr(bip->bli_buf) == bno)\n\t\t\treturn bip->bli_buf;\n\t}\n\n\treturn NULL;\n}\n\nSTATIC void\nxfs_check_block(\n\tstruct xfs_btree_block\t*block,\n\txfs_mount_t\t\t*mp,\n\tint\t\t\troot,\n\tshort\t\t\tsz)\n{\n\tint\t\t\ti, j, dmxr;\n\t__be64\t\t\t*pp, *thispa;\t \n\txfs_bmbt_key_t\t\t*prevp, *keyp;\n\n\tASSERT(be16_to_cpu(block->bb_level) > 0);\n\n\tprevp = NULL;\n\tfor( i = 1; i <= xfs_btree_get_numrecs(block); i++) {\n\t\tdmxr = mp->m_bmap_dmxr[0];\n\t\tkeyp = XFS_BMBT_KEY_ADDR(mp, block, i);\n\n\t\tif (prevp) {\n\t\t\tASSERT(be64_to_cpu(prevp->br_startoff) <\n\t\t\t       be64_to_cpu(keyp->br_startoff));\n\t\t}\n\t\tprevp = keyp;\n\n\t\t \n\t\tif (root)\n\t\t\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, i, sz);\n\t\telse\n\t\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, i, dmxr);\n\n\t\tfor (j = i+1; j <= be16_to_cpu(block->bb_numrecs); j++) {\n\t\t\tif (root)\n\t\t\t\tthispa = XFS_BMAP_BROOT_PTR_ADDR(mp, block, j, sz);\n\t\t\telse\n\t\t\t\tthispa = XFS_BMBT_PTR_ADDR(mp, block, j, dmxr);\n\t\t\tif (*thispa == *pp) {\n\t\t\t\txfs_warn(mp, \"%s: thispa(%d) == pp(%d) %lld\",\n\t\t\t\t\t__func__, j, i,\n\t\t\t\t\t(unsigned long long)be64_to_cpu(*thispa));\n\t\t\t\txfs_err(mp, \"%s: ptrs are equal in node\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nSTATIC void\nxfs_bmap_check_leaf_extents(\n\tstruct xfs_btree_cur\t*cur,\t \n\txfs_inode_t\t\t*ip,\t\t \n\tint\t\t\twhichfork)\t \n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tstruct xfs_btree_block\t*block;\t \n\txfs_fsblock_t\t\tbno;\t \n\tstruct xfs_buf\t\t*bp;\t \n\tint\t\t\terror;\t \n\txfs_extnum_t\t\ti=0, j;\t \n\tint\t\t\tlevel;\t \n\t__be64\t\t\t*pp;\t \n\txfs_bmbt_rec_t\t\t*ep;\t \n\txfs_bmbt_rec_t\t\tlast = {0, 0};  \n\txfs_bmbt_rec_t\t\t*nextp;\t \n\tint\t\t\tbp_release = 0;\n\n\tif (ifp->if_format != XFS_DINODE_FMT_BTREE)\n\t\treturn;\n\n\t \n\tif (ip->i_df.if_nextents > 10000)\n\t\treturn;\n\n\tbno = NULLFSBLOCK;\n\tblock = ifp->if_broot;\n\t \n\tlevel = be16_to_cpu(block->bb_level);\n\tASSERT(level > 0);\n\txfs_check_block(block, mp, 1, ifp->if_broot_bytes);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, 1, ifp->if_broot_bytes);\n\tbno = be64_to_cpu(*pp);\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks);\n\n\t \n\twhile (level-- > 0) {\n\t\t \n\t\tbp_release = 0;\n\t\tbp = xfs_bmap_get_bp(cur, XFS_FSB_TO_DADDR(mp, bno));\n\t\tif (!bp) {\n\t\t\tbp_release = 1;\n\t\t\terror = xfs_btree_read_bufl(mp, NULL, bno, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\tgoto error_norelse;\n\t\t}\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t\tif (level == 0)\n\t\t\tbreak;\n\n\t\t \n\n\t\txfs_check_block(block, mp, 0, 0);\n\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\n\t\tbno = be64_to_cpu(*pp);\n\t\tif (XFS_IS_CORRUPT(mp, !xfs_verify_fsbno(mp, bno))) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\t\tif (bp_release) {\n\t\t\tbp_release = 0;\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t}\n\n\t \n\ti = 0;\n\n\t \n\tfor (;;) {\n\t\txfs_fsblock_t\tnextbno;\n\t\txfs_extnum_t\tnum_recs;\n\n\n\t\tnum_recs = xfs_btree_get_numrecs(block);\n\n\t\t \n\n\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\n\t\t \n\n\t\tep = XFS_BMBT_REC_ADDR(mp, block, 1);\n\t\tif (i) {\n\t\t\tASSERT(xfs_bmbt_disk_get_startoff(&last) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(&last) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(ep));\n\t\t}\n\t\tfor (j = 1; j < num_recs; j++) {\n\t\t\tnextp = XFS_BMBT_REC_ADDR(mp, block, j + 1);\n\t\t\tASSERT(xfs_bmbt_disk_get_startoff(ep) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(ep) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(nextp));\n\t\t\tep = nextp;\n\t\t}\n\n\t\tlast = *ep;\n\t\ti += num_recs;\n\t\tif (bp_release) {\n\t\t\tbp_release = 0;\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t\tbno = nextbno;\n\t\t \n\t\tif (bno == NULLFSBLOCK)\n\t\t\tbreak;\n\n\t\tbp_release = 0;\n\t\tbp = xfs_bmap_get_bp(cur, XFS_FSB_TO_DADDR(mp, bno));\n\t\tif (!bp) {\n\t\t\tbp_release = 1;\n\t\t\terror = xfs_btree_read_bufl(mp, NULL, bno, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\tgoto error_norelse;\n\t\t}\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t}\n\n\treturn;\n\nerror0:\n\txfs_warn(mp, \"%s: at error0\", __func__);\n\tif (bp_release)\n\t\txfs_trans_brelse(NULL, bp);\nerror_norelse:\n\txfs_warn(mp, \"%s: BAD after btree leaves for %llu extents\",\n\t\t__func__, i);\n\txfs_err(mp, \"%s: CORRUPTED BTREE OR SOMETHING\", __func__);\n\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\treturn;\n}\n\n \nSTATIC void\nxfs_bmap_validate_ret(\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tuint32_t\t\tflags,\n\txfs_bmbt_irec_t\t\t*mval,\n\tint\t\t\tnmap,\n\tint\t\t\tret_nmap)\n{\n\tint\t\t\ti;\t\t \n\n\tASSERT(ret_nmap <= nmap);\n\n\tfor (i = 0; i < ret_nmap; i++) {\n\t\tASSERT(mval[i].br_blockcount > 0);\n\t\tif (!(flags & XFS_BMAPI_ENTIRE)) {\n\t\t\tASSERT(mval[i].br_startoff >= bno);\n\t\t\tASSERT(mval[i].br_blockcount <= len);\n\t\t\tASSERT(mval[i].br_startoff + mval[i].br_blockcount <=\n\t\t\t       bno + len);\n\t\t} else {\n\t\t\tASSERT(mval[i].br_startoff < bno + len);\n\t\t\tASSERT(mval[i].br_startoff + mval[i].br_blockcount >\n\t\t\t       bno);\n\t\t}\n\t\tASSERT(i == 0 ||\n\t\t       mval[i - 1].br_startoff + mval[i - 1].br_blockcount ==\n\t\t       mval[i].br_startoff);\n\t\tASSERT(mval[i].br_startblock != DELAYSTARTBLOCK &&\n\t\t       mval[i].br_startblock != HOLESTARTBLOCK);\n\t\tASSERT(mval[i].br_state == XFS_EXT_NORM ||\n\t\t       mval[i].br_state == XFS_EXT_UNWRITTEN);\n\t}\n}\n\n#else\n#define xfs_bmap_check_leaf_extents(cur, ip, whichfork)\t\tdo { } while (0)\n#define\txfs_bmap_validate_ret(bno,len,flags,mval,onmap,nmap)\tdo { } while (0)\n#endif  \n\n \n\n \nSTATIC int\t\t\t\t \nxfs_bmap_btree_to_extents(\n\tstruct xfs_trans\t*tp,\t \n\tstruct xfs_inode\t*ip,\t \n\tstruct xfs_btree_cur\t*cur,\t \n\tint\t\t\t*logflagsp,  \n\tint\t\t\twhichfork)   \n{\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_btree_block\t*rblock = ifp->if_broot;\n\tstruct xfs_btree_block\t*cblock; \n\txfs_fsblock_t\t\tcbno;\t \n\tstruct xfs_buf\t\t*cbp;\t \n\tint\t\t\terror;\t \n\t__be64\t\t\t*pp;\t \n\tstruct xfs_owner_info\toinfo;\n\n\t \n\tif (!xfs_bmap_wants_extents(ip, whichfork))\n\t\treturn 0;\n\n\tASSERT(cur);\n\tASSERT(whichfork != XFS_COW_FORK);\n\tASSERT(ifp->if_format == XFS_DINODE_FMT_BTREE);\n\tASSERT(be16_to_cpu(rblock->bb_level) == 1);\n\tASSERT(be16_to_cpu(rblock->bb_numrecs) == 1);\n\tASSERT(xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0) == 1);\n\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, rblock, 1, ifp->if_broot_bytes);\n\tcbno = be64_to_cpu(*pp);\n#ifdef DEBUG\n\tif (XFS_IS_CORRUPT(cur->bc_mp, !xfs_btree_check_lptr(cur, cbno, 1)))\n\t\treturn -EFSCORRUPTED;\n#endif\n\terror = xfs_btree_read_bufl(mp, tp, cbno, &cbp, XFS_BMAP_BTREE_REF,\n\t\t\t\t&xfs_bmbt_buf_ops);\n\tif (error)\n\t\treturn error;\n\tcblock = XFS_BUF_TO_BLOCK(cbp);\n\tif ((error = xfs_btree_check_block(cur, cblock, 0, cbp)))\n\t\treturn error;\n\n\txfs_rmap_ino_bmbt_owner(&oinfo, ip->i_ino, whichfork);\n\terror = xfs_free_extent_later(cur->bc_tp, cbno, 1, &oinfo,\n\t\t\tXFS_AG_RESV_NONE);\n\tif (error)\n\t\treturn error;\n\n\tip->i_nblocks--;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, -1L);\n\txfs_trans_binval(tp, cbp);\n\tif (cur->bc_levels[0].bp == cbp)\n\t\tcur->bc_levels[0].bp = NULL;\n\txfs_iroot_realloc(ip, -1, whichfork);\n\tASSERT(ifp->if_broot == NULL);\n\tifp->if_format = XFS_DINODE_FMT_EXTENTS;\n\t*logflagsp |= XFS_ILOG_CORE | xfs_ilog_fext(whichfork);\n\treturn 0;\n}\n\n \nSTATIC int\t\t\t\t\t \nxfs_bmap_extents_to_btree(\n\tstruct xfs_trans\t*tp,\t\t \n\tstruct xfs_inode\t*ip,\t\t \n\tstruct xfs_btree_cur\t**curp,\t\t \n\tint\t\t\twasdel,\t\t \n\tint\t\t\t*logflagsp,\t \n\tint\t\t\twhichfork)\t \n{\n\tstruct xfs_btree_block\t*ablock;\t \n\tstruct xfs_buf\t\t*abp;\t\t \n\tstruct xfs_alloc_arg\targs;\t\t \n\tstruct xfs_bmbt_rec\t*arp;\t\t \n\tstruct xfs_btree_block\t*block;\t\t \n\tstruct xfs_btree_cur\t*cur;\t\t \n\tint\t\t\terror;\t\t \n\tstruct xfs_ifork\t*ifp;\t\t \n\tstruct xfs_bmbt_key\t*kp;\t\t \n\tstruct xfs_mount\t*mp;\t\t \n\txfs_bmbt_ptr_t\t\t*pp;\t\t \n\tstruct xfs_iext_cursor\ticur;\n\tstruct xfs_bmbt_irec\trec;\n\txfs_extnum_t\t\tcnt = 0;\n\n\tmp = ip->i_mount;\n\tASSERT(whichfork != XFS_COW_FORK);\n\tifp = xfs_ifork_ptr(ip, whichfork);\n\tASSERT(ifp->if_format == XFS_DINODE_FMT_EXTENTS);\n\n\t \n\txfs_iroot_realloc(ip, 1, whichfork);\n\n\t \n\tblock = ifp->if_broot;\n\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BTNUM_BMAP, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS);\n\t \n\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\tcur->bc_ino.flags = wasdel ? XFS_BTCUR_BMBT_WASDEL : 0;\n\t \n\tifp->if_format = XFS_DINODE_FMT_BTREE;\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = mp;\n\txfs_rmap_ino_bmbt_owner(&args.oinfo, ip->i_ino, whichfork);\n\n\targs.minlen = args.maxlen = args.prod = 1;\n\targs.wasdel = wasdel;\n\t*logflagsp = 0;\n\terror = xfs_alloc_vextent_start_ag(&args,\n\t\t\t\tXFS_INO_TO_FSB(mp, ip->i_ino));\n\tif (error)\n\t\tgoto out_root_realloc;\n\n\t \n\tif (WARN_ON_ONCE(args.fsbno == NULLFSBLOCK)) {\n\t\terror = -ENOSPC;\n\t\tgoto out_root_realloc;\n\t}\n\n\tcur->bc_ino.allocated++;\n\tip->i_nblocks++;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, 1L);\n\terror = xfs_trans_get_buf(tp, mp->m_ddev_targp,\n\t\t\tXFS_FSB_TO_DADDR(mp, args.fsbno),\n\t\t\tmp->m_bsize, 0, &abp);\n\tif (error)\n\t\tgoto out_unreserve_dquot;\n\n\t \n\tabp->b_ops = &xfs_bmbt_buf_ops;\n\tablock = XFS_BUF_TO_BLOCK(abp);\n\txfs_btree_init_block_int(mp, ablock, xfs_buf_daddr(abp),\n\t\t\t\tXFS_BTNUM_BMAP, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS);\n\n\tfor_each_xfs_iext(ifp, &icur, &rec) {\n\t\tif (isnullstartblock(rec.br_startblock))\n\t\t\tcontinue;\n\t\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1 + cnt);\n\t\txfs_bmbt_disk_set_all(arp, &rec);\n\t\tcnt++;\n\t}\n\tASSERT(cnt == ifp->if_nextents);\n\txfs_btree_set_numrecs(ablock, cnt);\n\n\t \n\tkp = XFS_BMBT_KEY_ADDR(mp, block, 1);\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tkp->br_startoff = cpu_to_be64(xfs_bmbt_disk_get_startoff(arp));\n\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, xfs_bmbt_get_maxrecs(cur,\n\t\t\t\t\t\tbe16_to_cpu(block->bb_level)));\n\t*pp = cpu_to_be64(args.fsbno);\n\n\t \n\txfs_btree_log_block(cur, abp, XFS_BB_ALL_BITS);\n\txfs_btree_log_recs(cur, abp, 1, be16_to_cpu(ablock->bb_numrecs));\n\tASSERT(*curp == NULL);\n\t*curp = cur;\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fbroot(whichfork);\n\treturn 0;\n\nout_unreserve_dquot:\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, -1L);\nout_root_realloc:\n\txfs_iroot_realloc(ip, -1, whichfork);\n\tifp->if_format = XFS_DINODE_FMT_EXTENTS;\n\tASSERT(ifp->if_broot == NULL);\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\n\treturn error;\n}\n\n \nvoid\nxfs_bmap_local_to_extents_empty(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\n\tASSERT(whichfork != XFS_COW_FORK);\n\tASSERT(ifp->if_format == XFS_DINODE_FMT_LOCAL);\n\tASSERT(ifp->if_bytes == 0);\n\tASSERT(ifp->if_nextents == 0);\n\n\txfs_bmap_forkoff_reset(ip, whichfork);\n\tifp->if_u1.if_root = NULL;\n\tifp->if_height = 0;\n\tifp->if_format = XFS_DINODE_FMT_EXTENTS;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n}\n\n\nSTATIC int\t\t\t\t \nxfs_bmap_local_to_extents(\n\txfs_trans_t\t*tp,\t\t \n\txfs_inode_t\t*ip,\t\t \n\txfs_extlen_t\ttotal,\t\t \n\tint\t\t*logflagsp,\t \n\tint\t\twhichfork,\n\tvoid\t\t(*init_fn)(struct xfs_trans *tp,\n\t\t\t\t   struct xfs_buf *bp,\n\t\t\t\t   struct xfs_inode *ip,\n\t\t\t\t   struct xfs_ifork *ifp))\n{\n\tint\t\terror = 0;\n\tint\t\tflags;\t\t \n\tstruct xfs_ifork *ifp;\t\t \n\txfs_alloc_arg_t\targs;\t\t \n\tstruct xfs_buf\t*bp;\t\t \n\tstruct xfs_bmbt_irec rec;\n\tstruct xfs_iext_cursor icur;\n\n\t \n\tASSERT(!(S_ISREG(VFS_I(ip)->i_mode) && whichfork == XFS_DATA_FORK));\n\tifp = xfs_ifork_ptr(ip, whichfork);\n\tASSERT(ifp->if_format == XFS_DINODE_FMT_LOCAL);\n\n\tif (!ifp->if_bytes) {\n\t\txfs_bmap_local_to_extents_empty(tp, ip, whichfork);\n\t\tflags = XFS_ILOG_CORE;\n\t\tgoto done;\n\t}\n\n\tflags = 0;\n\terror = 0;\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = ip->i_mount;\n\targs.total = total;\n\targs.minlen = args.maxlen = args.prod = 1;\n\txfs_rmap_ino_owner(&args.oinfo, ip->i_ino, whichfork, 0);\n\n\t \n\targs.total = total;\n\targs.minlen = args.maxlen = args.prod = 1;\n\terror = xfs_alloc_vextent_start_ag(&args,\n\t\t\tXFS_INO_TO_FSB(args.mp, ip->i_ino));\n\tif (error)\n\t\tgoto done;\n\n\t \n\tASSERT(args.fsbno != NULLFSBLOCK);\n\tASSERT(args.len == 1);\n\terror = xfs_trans_get_buf(tp, args.mp->m_ddev_targp,\n\t\t\tXFS_FSB_TO_DADDR(args.mp, args.fsbno),\n\t\t\targs.mp->m_bsize, 0, &bp);\n\tif (error)\n\t\tgoto done;\n\n\t \n\tinit_fn(tp, bp, ip, ifp);\n\n\t \n\txfs_idata_realloc(ip, -ifp->if_bytes, whichfork);\n\txfs_bmap_local_to_extents_empty(tp, ip, whichfork);\n\tflags |= XFS_ILOG_CORE;\n\n\tifp->if_u1.if_root = NULL;\n\tifp->if_height = 0;\n\n\trec.br_startoff = 0;\n\trec.br_startblock = args.fsbno;\n\trec.br_blockcount = 1;\n\trec.br_state = XFS_EXT_NORM;\n\txfs_iext_first(ifp, &icur);\n\txfs_iext_insert(ip, &icur, &rec, 0);\n\n\tifp->if_nextents = 1;\n\tip->i_nblocks = 1;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, 1L);\n\tflags |= xfs_ilog_fext(whichfork);\n\ndone:\n\t*logflagsp = flags;\n\treturn error;\n}\n\n \nSTATIC int\t\t\t\t\t \nxfs_bmap_add_attrfork_btree(\n\txfs_trans_t\t\t*tp,\t\t \n\txfs_inode_t\t\t*ip,\t\t \n\tint\t\t\t*flags)\t\t \n{\n\tstruct xfs_btree_block\t*block = ip->i_df.if_broot;\n\tstruct xfs_btree_cur\t*cur;\t\t \n\tint\t\t\terror;\t\t \n\txfs_mount_t\t\t*mp;\t\t \n\tint\t\t\tstat;\t\t \n\n\tmp = ip->i_mount;\n\n\tif (XFS_BMAP_BMDR_SPACE(block) <= xfs_inode_data_fork_size(ip))\n\t\t*flags |= XFS_ILOG_DBROOT;\n\telse {\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, XFS_DATA_FORK);\n\t\terror = xfs_bmbt_lookup_first(cur, &stat);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\t \n\t\tif (XFS_IS_CORRUPT(mp, stat != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\t\tif ((error = xfs_btree_new_iroot(cur, flags, &stat)))\n\t\t\tgoto error0;\n\t\tif (stat == 0) {\n\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tcur->bc_ino.allocated = 0;\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t}\n\treturn 0;\nerror0:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\treturn error;\n}\n\n \nSTATIC int\t\t\t\t\t \nxfs_bmap_add_attrfork_extents(\n\tstruct xfs_trans\t*tp,\t\t \n\tstruct xfs_inode\t*ip,\t\t \n\tint\t\t\t*flags)\t\t \n{\n\tstruct xfs_btree_cur\t*cur;\t\t \n\tint\t\t\terror;\t\t \n\n\tif (ip->i_df.if_nextents * sizeof(struct xfs_bmbt_rec) <=\n\t    xfs_inode_data_fork_size(ip))\n\t\treturn 0;\n\tcur = NULL;\n\terror = xfs_bmap_extents_to_btree(tp, ip, &cur, 0, flags,\n\t\t\t\t\t  XFS_DATA_FORK);\n\tif (cur) {\n\t\tcur->bc_ino.allocated = 0;\n\t\txfs_btree_del_cursor(cur, error);\n\t}\n\treturn error;\n}\n\n \nSTATIC int\t\t\t\t\t \nxfs_bmap_add_attrfork_local(\n\tstruct xfs_trans\t*tp,\t\t \n\tstruct xfs_inode\t*ip,\t\t \n\tint\t\t\t*flags)\t\t \n{\n\tstruct xfs_da_args\tdargs;\t\t \n\n\tif (ip->i_df.if_bytes <= xfs_inode_data_fork_size(ip))\n\t\treturn 0;\n\n\tif (S_ISDIR(VFS_I(ip)->i_mode)) {\n\t\tmemset(&dargs, 0, sizeof(dargs));\n\t\tdargs.geo = ip->i_mount->m_dir_geo;\n\t\tdargs.dp = ip;\n\t\tdargs.total = dargs.geo->fsbcount;\n\t\tdargs.whichfork = XFS_DATA_FORK;\n\t\tdargs.trans = tp;\n\t\treturn xfs_dir2_sf_to_block(&dargs);\n\t}\n\n\tif (S_ISLNK(VFS_I(ip)->i_mode))\n\t\treturn xfs_bmap_local_to_extents(tp, ip, 1, flags,\n\t\t\t\t\t\t XFS_DATA_FORK,\n\t\t\t\t\t\t xfs_symlink_local_to_remote);\n\n\t \n\tASSERT(0);\n\treturn -EFSCORRUPTED;\n}\n\n \nstatic int\nxfs_bmap_set_attrforkoff(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tsize,\n\tint\t\t\t*version)\n{\n\tint\t\t\tdefault_size = xfs_default_attroffset(ip) >> 3;\n\n\tswitch (ip->i_df.if_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tip->i_forkoff = default_size;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\tcase XFS_DINODE_FMT_EXTENTS:\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tip->i_forkoff = xfs_attr_shortform_bytesfit(ip, size);\n\t\tif (!ip->i_forkoff)\n\t\t\tip->i_forkoff = default_size;\n\t\telse if (xfs_has_attr2(ip->i_mount) && version)\n\t\t\t*version = 2;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint\t\t\t\t\t\t \nxfs_bmap_add_attrfork(\n\txfs_inode_t\t\t*ip,\t\t \n\tint\t\t\tsize,\t\t \n\tint\t\t\trsvd)\t\t \n{\n\txfs_mount_t\t\t*mp;\t\t \n\txfs_trans_t\t\t*tp;\t\t \n\tint\t\t\tblks;\t\t \n\tint\t\t\tversion = 1;\t \n\tint\t\t\tlogflags;\t \n\tint\t\t\terror;\t\t \n\n\tASSERT(xfs_inode_has_attr_fork(ip) == 0);\n\n\tmp = ip->i_mount;\n\tASSERT(!XFS_NOT_DQATTACHED(mp, ip));\n\n\tblks = XFS_ADDAFORK_SPACE_RES(mp);\n\n\terror = xfs_trans_alloc_inode(ip, &M_RES(mp)->tr_addafork, blks, 0,\n\t\t\trsvd, &tp);\n\tif (error)\n\t\treturn error;\n\tif (xfs_inode_has_attr_fork(ip))\n\t\tgoto trans_cancel;\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\terror = xfs_bmap_set_attrforkoff(ip, size, &version);\n\tif (error)\n\t\tgoto trans_cancel;\n\n\txfs_ifork_init_attr(ip, XFS_DINODE_FMT_EXTENTS, 0);\n\tlogflags = 0;\n\tswitch (ip->i_df.if_format) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\terror = xfs_bmap_add_attrfork_local(tp, ip, &logflags);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\terror = xfs_bmap_add_attrfork_extents(tp, ip, &logflags);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\terror = xfs_bmap_add_attrfork_btree(tp, ip, &logflags);\n\t\tbreak;\n\tdefault:\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (error)\n\t\tgoto trans_cancel;\n\tif (!xfs_has_attr(mp) ||\n\t   (!xfs_has_attr2(mp) && version == 2)) {\n\t\tbool log_sb = false;\n\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tif (!xfs_has_attr(mp)) {\n\t\t\txfs_add_attr(mp);\n\t\t\tlog_sb = true;\n\t\t}\n\t\tif (!xfs_has_attr2(mp) && version == 2) {\n\t\t\txfs_add_attr2(mp);\n\t\t\tlog_sb = true;\n\t\t}\n\t\tspin_unlock(&mp->m_sb_lock);\n\t\tif (log_sb)\n\t\t\txfs_log_sb(tp);\n\t}\n\n\terror = xfs_trans_commit(tp);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n\ntrans_cancel:\n\txfs_trans_cancel(tp);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\n \n\nstruct xfs_iread_state {\n\tstruct xfs_iext_cursor\ticur;\n\txfs_extnum_t\t\tloaded;\n};\n\nint\nxfs_bmap_complain_bad_rec(\n\tstruct xfs_inode\t\t*ip,\n\tint\t\t\t\twhichfork,\n\txfs_failaddr_t\t\t\tfa,\n\tconst struct xfs_bmbt_irec\t*irec)\n{\n\tstruct xfs_mount\t\t*mp = ip->i_mount;\n\tconst char\t\t\t*forkname;\n\n\tswitch (whichfork) {\n\tcase XFS_DATA_FORK:\tforkname = \"data\"; break;\n\tcase XFS_ATTR_FORK:\tforkname = \"attr\"; break;\n\tcase XFS_COW_FORK:\tforkname = \"CoW\"; break;\n\tdefault:\t\tforkname = \"???\"; break;\n\t}\n\n\txfs_warn(mp,\n \"Bmap BTree record corruption in inode 0x%llx %s fork detected at %pS!\",\n\t\t\t\tip->i_ino, forkname, fa);\n\txfs_warn(mp,\n\t\t\"Offset 0x%llx, start block 0x%llx, block count 0x%llx state 0x%x\",\n\t\tirec->br_startoff, irec->br_startblock, irec->br_blockcount,\n\t\tirec->br_state);\n\n\treturn -EFSCORRUPTED;\n}\n\n \nstatic int\nxfs_iread_bmbt_block(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tvoid\t\t\t*priv)\n{\n\tstruct xfs_iread_state\t*ir = priv;\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\tstruct xfs_inode\t*ip = cur->bc_ino.ip;\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_bmbt_rec\t*frp;\n\txfs_extnum_t\t\tnum_recs;\n\txfs_extnum_t\t\tj;\n\tint\t\t\twhichfork = cur->bc_ino.whichfork;\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n\t \n\tnum_recs = xfs_btree_get_numrecs(block);\n\tif (unlikely(ir->loaded + num_recs > ifp->if_nextents)) {\n\t\txfs_warn(ip->i_mount, \"corrupt dinode %llu, (btree extents).\",\n\t\t\t\t(unsigned long long)ip->i_ino);\n\t\txfs_inode_verifier_error(ip, -EFSCORRUPTED, __func__, block,\n\t\t\t\tsizeof(*block), __this_address);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\tfrp = XFS_BMBT_REC_ADDR(mp, block, 1);\n\tfor (j = 0; j < num_recs; j++, frp++, ir->loaded++) {\n\t\tstruct xfs_bmbt_irec\tnew;\n\t\txfs_failaddr_t\t\tfa;\n\n\t\txfs_bmbt_disk_get_all(frp, &new);\n\t\tfa = xfs_bmap_validate_extent(ip, whichfork, &new);\n\t\tif (fa) {\n\t\t\txfs_inode_verifier_error(ip, -EFSCORRUPTED,\n\t\t\t\t\t\"xfs_iread_extents(2)\", frp,\n\t\t\t\t\tsizeof(*frp), fa);\n\t\t\treturn xfs_bmap_complain_bad_rec(ip, whichfork, fa,\n\t\t\t\t\t&new);\n\t\t}\n\t\txfs_iext_insert(ip, &ir->icur, &new,\n\t\t\t\txfs_bmap_fork_to_state(whichfork));\n\t\ttrace_xfs_read_extent(ip, &ir->icur,\n\t\t\t\txfs_bmap_fork_to_state(whichfork), _THIS_IP_);\n\t\txfs_iext_next(ifp, &ir->icur);\n\t}\n\n\treturn 0;\n}\n\n \nint\nxfs_iread_extents(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_iread_state\tir;\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_btree_cur\t*cur;\n\tint\t\t\terror;\n\n\tif (!xfs_need_iread_extents(ifp))\n\t\treturn 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tir.loaded = 0;\n\txfs_iext_first(ifp, &ir.icur);\n\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\terror = xfs_btree_visit_blocks(cur, xfs_iread_bmbt_block,\n\t\t\tXFS_BTREE_VISIT_RECORDS, &ir);\n\txfs_btree_del_cursor(cur, error);\n\tif (error)\n\t\tgoto out;\n\n\tif (XFS_IS_CORRUPT(mp, ir.loaded != ifp->if_nextents)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\tASSERT(ir.loaded == xfs_iext_count(ifp));\n\t \n\tsmp_store_release(&ifp->if_needextents, 0);\n\treturn 0;\nout:\n\txfs_iext_destroy(ifp);\n\treturn error;\n}\n\n \nint\t\t\t\t\t\t \nxfs_bmap_first_unused(\n\tstruct xfs_trans\t*tp,\t\t \n\tstruct xfs_inode\t*ip,\t\t \n\txfs_extlen_t\t\tlen,\t\t \n\txfs_fileoff_t\t\t*first_unused,\t \n\tint\t\t\twhichfork)\t \n{\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_iext_cursor\ticur;\n\txfs_fileoff_t\t\tlastaddr = 0;\n\txfs_fileoff_t\t\tlowest, max;\n\tint\t\t\terror;\n\n\tif (ifp->if_format == XFS_DINODE_FMT_LOCAL) {\n\t\t*first_unused = 0;\n\t\treturn 0;\n\t}\n\n\tASSERT(xfs_ifork_has_extents(ifp));\n\n\terror = xfs_iread_extents(tp, ip, whichfork);\n\tif (error)\n\t\treturn error;\n\n\tlowest = max = *first_unused;\n\tfor_each_xfs_iext(ifp, &icur, &got) {\n\t\t \n\t\tif (got.br_startoff >= lowest + len &&\n\t\t    got.br_startoff - max >= len)\n\t\t\tbreak;\n\t\tlastaddr = got.br_startoff + got.br_blockcount;\n\t\tmax = XFS_FILEOFF_MAX(lastaddr, lowest);\n\t}\n\n\t*first_unused = max;\n\treturn 0;\n}\n\n \nint\t\t\t\t\t\t \nxfs_bmap_last_before(\n\tstruct xfs_trans\t*tp,\t\t \n\tstruct xfs_inode\t*ip,\t\t \n\txfs_fileoff_t\t\t*last_block,\t \n\tint\t\t\twhichfork)\t \n{\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_iext_cursor\ticur;\n\tint\t\t\terror;\n\n\tswitch (ifp->if_format) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\t*last_block = 0;\n\t\treturn 0;\n\tcase XFS_DINODE_FMT_BTREE:\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\terror = xfs_iread_extents(tp, ip, whichfork);\n\tif (error)\n\t\treturn error;\n\n\tif (!xfs_iext_lookup_extent_before(ip, ifp, last_block, &icur, &got))\n\t\t*last_block = 0;\n\treturn 0;\n}\n\nint\nxfs_bmap_last_extent(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tstruct xfs_bmbt_irec\t*rec,\n\tint\t\t\t*is_empty)\n{\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tstruct xfs_iext_cursor\ticur;\n\tint\t\t\terror;\n\n\terror = xfs_iread_extents(tp, ip, whichfork);\n\tif (error)\n\t\treturn error;\n\n\txfs_iext_last(ifp, &icur);\n\tif (!xfs_iext_get_extent(ifp, &icur, rec))\n\t\t*is_empty = 1;\n\telse\n\t\t*is_empty = 0;\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_bmap_isaeof(\n\tstruct xfs_bmalloca\t*bma,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\trec;\n\tint\t\t\tis_empty;\n\tint\t\t\terror;\n\n\tbma->aeof = false;\n\terror = xfs_bmap_last_extent(NULL, bma->ip, whichfork, &rec,\n\t\t\t\t     &is_empty);\n\tif (error)\n\t\treturn error;\n\n\tif (is_empty) {\n\t\tbma->aeof = true;\n\t\treturn 0;\n\t}\n\n\t \n\tbma->aeof = bma->offset >= rec.br_startoff + rec.br_blockcount ||\n\t\t(bma->offset >= rec.br_startoff &&\n\t\t isnullstartblock(rec.br_startblock));\n\treturn 0;\n}\n\n \nint\nxfs_bmap_last_offset(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\t*last_block,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tstruct xfs_bmbt_irec\trec;\n\tint\t\t\tis_empty;\n\tint\t\t\terror;\n\n\t*last_block = 0;\n\n\tif (ifp->if_format == XFS_DINODE_FMT_LOCAL)\n\t\treturn 0;\n\n\tif (XFS_IS_CORRUPT(ip->i_mount, !xfs_ifork_has_extents(ifp)))\n\t\treturn -EFSCORRUPTED;\n\n\terror = xfs_bmap_last_extent(NULL, ip, whichfork, &rec, &is_empty);\n\tif (error || is_empty)\n\t\treturn error;\n\n\t*last_block = rec.br_startoff + rec.br_blockcount;\n\treturn 0;\n}\n\n \n\n \nSTATIC int\t\t\t\t \nxfs_bmap_add_extent_delay_real(\n\tstruct xfs_bmalloca\t*bma,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = bma->ip->i_mount;\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(bma->ip, whichfork);\n\tstruct xfs_bmbt_irec\t*new = &bma->got;\n\tint\t\t\terror;\t \n\tint\t\t\ti;\t \n\txfs_fileoff_t\t\tnew_endoff;\t \n\txfs_bmbt_irec_t\t\tr[3];\t \n\t\t\t\t\t \n\tint\t\t\trval=0;\t \n\tuint32_t\t\tstate = xfs_bmap_fork_to_state(whichfork);\n\txfs_filblks_t\t\tda_new;  \n\txfs_filblks_t\t\tda_old;  \n\txfs_filblks_t\t\ttemp=0;\t \n\tint\t\t\ttmp_rval;\t \n\tstruct xfs_bmbt_irec\told;\n\n\tASSERT(whichfork != XFS_ATTR_FORK);\n\tASSERT(!isnullstartblock(new->br_startblock));\n\tASSERT(!bma->cur ||\n\t       (bma->cur->bc_ino.flags & XFS_BTCUR_BMBT_WASDEL));\n\n\tXFS_STATS_INC(mp, xs_add_exlist);\n\n#define\tLEFT\t\tr[0]\n#define\tRIGHT\t\tr[1]\n#define\tPREV\t\tr[2]\n\n\t \n\txfs_iext_get_extent(ifp, &bma->icur, &PREV);\n\tnew_endoff = new->br_startoff + new->br_blockcount;\n\tASSERT(isnullstartblock(PREV.br_startblock));\n\tASSERT(PREV.br_startoff <= new->br_startoff);\n\tASSERT(PREV.br_startoff + PREV.br_blockcount >= new_endoff);\n\n\tda_old = startblockval(PREV.br_startblock);\n\tda_new = 0;\n\n\t \n\tif (PREV.br_startoff == new->br_startoff)\n\t\tstate |= BMAP_LEFT_FILLING;\n\tif (PREV.br_startoff + PREV.br_blockcount == new_endoff)\n\t\tstate |= BMAP_RIGHT_FILLING;\n\n\t \n\tif (xfs_iext_peek_prev_extent(ifp, &bma->icur, &LEFT)) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\tif (isnullstartblock(LEFT.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\tif ((state & BMAP_LEFT_VALID) && !(state & BMAP_LEFT_DELAY) &&\n\t    LEFT.br_startoff + LEFT.br_blockcount == new->br_startoff &&\n\t    LEFT.br_startblock + LEFT.br_blockcount == new->br_startblock &&\n\t    LEFT.br_state == new->br_state &&\n\t    LEFT.br_blockcount + new->br_blockcount <= XFS_MAX_BMBT_EXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\t \n\tif (xfs_iext_peek_next_extent(ifp, &bma->icur, &RIGHT)) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\tif (isnullstartblock(RIGHT.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\tif ((state & BMAP_RIGHT_VALID) && !(state & BMAP_RIGHT_DELAY) &&\n\t    new_endoff == RIGHT.br_startoff &&\n\t    new->br_startblock + new->br_blockcount == RIGHT.br_startblock &&\n\t    new->br_state == RIGHT.br_state &&\n\t    new->br_blockcount + RIGHT.br_blockcount <= XFS_MAX_BMBT_EXTLEN &&\n\t    ((state & (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING)) !=\n\t\t      (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING) ||\n\t     LEFT.br_blockcount + new->br_blockcount + RIGHT.br_blockcount\n\t\t\t<= XFS_MAX_BMBT_EXTLEN))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\terror = 0;\n\t \n\tswitch (state & (BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t\t\t BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t     BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t \n\t\tLEFT.br_blockcount += PREV.br_blockcount + RIGHT.br_blockcount;\n\n\t\txfs_iext_remove(bma->ip, &bma->icur, state);\n\t\txfs_iext_remove(bma->ip, &bma->icur, state);\n\t\txfs_iext_prev(ifp, &bma->icur);\n\t\txfs_iext_update_extent(bma->ip, state, &bma->icur, &LEFT);\n\t\tifp->if_nextents--;\n\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, &RIGHT, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_btree_delete(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_btree_decrement(bma->cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_bmbt_update(bma->cur, &LEFT);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\t\t \n\t\told = LEFT;\n\t\tLEFT.br_blockcount += PREV.br_blockcount;\n\n\t\txfs_iext_remove(bma->ip, &bma->icur, state);\n\t\txfs_iext_prev(ifp, &bma->icur);\n\t\txfs_iext_update_extent(bma->ip, state, &bma->icur, &LEFT);\n\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, &old, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_bmbt_update(bma->cur, &LEFT);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t \n\t\tPREV.br_startblock = new->br_startblock;\n\t\tPREV.br_blockcount += RIGHT.br_blockcount;\n\t\tPREV.br_state = new->br_state;\n\n\t\txfs_iext_next(ifp, &bma->icur);\n\t\txfs_iext_remove(bma->ip, &bma->icur, state);\n\t\txfs_iext_prev(ifp, &bma->icur);\n\t\txfs_iext_update_extent(bma->ip, state, &bma->icur, &PREV);\n\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, &RIGHT, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_bmbt_update(bma->cur, &PREV);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:\n\t\t \n\t\tPREV.br_startblock = new->br_startblock;\n\t\tPREV.br_state = new->br_state;\n\t\txfs_iext_update_extent(bma->ip, state, &bma->icur, &PREV);\n\t\tifp->if_nextents++;\n\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 0)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG:\n\t\t \n\t\told = LEFT;\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\t\tstartblockval(PREV.br_startblock));\n\n\t\tLEFT.br_blockcount += new->br_blockcount;\n\n\t\tPREV.br_blockcount = temp;\n\t\tPREV.br_startoff += new->br_blockcount;\n\t\tPREV.br_startblock = nullstartblock(da_new);\n\n\t\txfs_iext_update_extent(bma->ip, state, &bma->icur, &PREV);\n\t\txfs_iext_prev(ifp, &bma->icur);\n\t\txfs_iext_update_extent(bma->ip, state, &bma->icur, &LEFT);\n\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, &old, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_bmbt_update(bma->cur, &LEFT);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING:\n\t\t \n\t\txfs_iext_update_extent(bma->ip, state, &bma->icur, new);\n\t\tifp->if_nextents++;\n\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 0)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tif (xfs_bmap_needs_btree(bma->ip, whichfork)) {\n\t\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\t\t&bma->cur, 1, &tmp_rval, whichfork);\n\t\t\trval |= tmp_rval;\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock) -\n\t\t\t(bma->cur ? bma->cur->bc_ino.allocated : 0));\n\n\t\tPREV.br_startoff = new_endoff;\n\t\tPREV.br_blockcount = temp;\n\t\tPREV.br_startblock = nullstartblock(da_new);\n\t\txfs_iext_next(ifp, &bma->icur);\n\t\txfs_iext_insert(bma->ip, &bma->icur, &PREV, state);\n\t\txfs_iext_prev(ifp, &bma->icur);\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t \n\t\told = RIGHT;\n\t\tRIGHT.br_startoff = new->br_startoff;\n\t\tRIGHT.br_startblock = new->br_startblock;\n\t\tRIGHT.br_blockcount += new->br_blockcount;\n\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, &old, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_bmbt_update(bma->cur, &RIGHT);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock));\n\n\t\tPREV.br_blockcount = temp;\n\t\tPREV.br_startblock = nullstartblock(da_new);\n\n\t\txfs_iext_update_extent(bma->ip, state, &bma->icur, &PREV);\n\t\txfs_iext_next(ifp, &bma->icur);\n\t\txfs_iext_update_extent(bma->ip, state, &bma->icur, &RIGHT);\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING:\n\t\t \n\t\txfs_iext_update_extent(bma->ip, state, &bma->icur, new);\n\t\tifp->if_nextents++;\n\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 0)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tif (xfs_bmap_needs_btree(bma->ip, whichfork)) {\n\t\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\t&bma->cur, 1, &tmp_rval, whichfork);\n\t\t\trval |= tmp_rval;\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock) -\n\t\t\t(bma->cur ? bma->cur->bc_ino.allocated : 0));\n\n\t\tPREV.br_startblock = nullstartblock(da_new);\n\t\tPREV.br_blockcount = temp;\n\t\txfs_iext_insert(bma->ip, &bma->icur, &PREV, state);\n\t\txfs_iext_next(ifp, &bma->icur);\n\t\tbreak;\n\n\tcase 0:\n\t\t \n\t\told = PREV;\n\n\t\t \n\t\tLEFT = *new;\n\n\t\t \n\t\tRIGHT.br_state = PREV.br_state;\n\t\tRIGHT.br_startoff = new_endoff;\n\t\tRIGHT.br_blockcount =\n\t\t\tPREV.br_startoff + PREV.br_blockcount - new_endoff;\n\t\tRIGHT.br_startblock =\n\t\t\tnullstartblock(xfs_bmap_worst_indlen(bma->ip,\n\t\t\t\t\tRIGHT.br_blockcount));\n\n\t\t \n\t\tPREV.br_blockcount = new->br_startoff - PREV.br_startoff;\n\t\tPREV.br_startblock =\n\t\t\tnullstartblock(xfs_bmap_worst_indlen(bma->ip,\n\t\t\t\t\tPREV.br_blockcount));\n\t\txfs_iext_update_extent(bma->ip, state, &bma->icur, &PREV);\n\n\t\txfs_iext_next(ifp, &bma->icur);\n\t\txfs_iext_insert(bma->ip, &bma->icur, &RIGHT, state);\n\t\txfs_iext_insert(bma->ip, &bma->icur, &LEFT, state);\n\t\tifp->if_nextents++;\n\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 0)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tif (xfs_bmap_needs_btree(bma->ip, whichfork)) {\n\t\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\t\t&bma->cur, 1, &tmp_rval, whichfork);\n\t\t\trval |= tmp_rval;\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tda_new = startblockval(PREV.br_startblock) +\n\t\t\t startblockval(RIGHT.br_startblock);\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_CONTIG:\n\tcase BMAP_RIGHT_CONTIG:\n\t\t \n\t\tASSERT(0);\n\t}\n\n\t \n\tif (!(bma->flags & XFS_BMAPI_NORMAP))\n\t\txfs_rmap_map_extent(bma->tp, bma->ip, whichfork, new);\n\n\t \n\tif (xfs_bmap_needs_btree(bma->ip, whichfork)) {\n\t\tint\ttmp_logflags;\t \n\n\t\tASSERT(bma->cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\t&bma->cur, da_old > 0, &tmp_logflags,\n\t\t\t\twhichfork);\n\t\tbma->logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto done;\n\t}\n\n\tif (da_new != da_old)\n\t\txfs_mod_delalloc(mp, (int64_t)da_new - da_old);\n\n\tif (bma->cur) {\n\t\tda_new += bma->cur->bc_ino.allocated;\n\t\tbma->cur->bc_ino.allocated = 0;\n\t}\n\n\t \n\tif (da_new != da_old) {\n\t\tASSERT(state == 0 || da_new < da_old);\n\t\terror = xfs_mod_fdblocks(mp, (int64_t)(da_old - da_new),\n\t\t\t\tfalse);\n\t}\n\n\txfs_bmap_check_leaf_extents(bma->cur, bma->ip, whichfork);\ndone:\n\tif (whichfork != XFS_COW_FORK)\n\t\tbma->logflags |= rval;\n\treturn error;\n#undef\tLEFT\n#undef\tRIGHT\n#undef\tPREV\n}\n\n \nint\t\t\t\t\t \nxfs_bmap_add_extent_unwritten_real(\n\tstruct xfs_trans\t*tp,\n\txfs_inode_t\t\t*ip,\t \n\tint\t\t\twhichfork,\n\tstruct xfs_iext_cursor\t*icur,\n\tstruct xfs_btree_cur\t**curp,\t \n\txfs_bmbt_irec_t\t\t*new,\t \n\tint\t\t\t*logflagsp)  \n{\n\tstruct xfs_btree_cur\t*cur;\t \n\tint\t\t\terror;\t \n\tint\t\t\ti;\t \n\tstruct xfs_ifork\t*ifp;\t \n\txfs_fileoff_t\t\tnew_endoff;\t \n\txfs_bmbt_irec_t\t\tr[3];\t \n\t\t\t\t\t \n\tint\t\t\trval=0;\t \n\tuint32_t\t\tstate = xfs_bmap_fork_to_state(whichfork);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_bmbt_irec\told;\n\n\t*logflagsp = 0;\n\n\tcur = *curp;\n\tifp = xfs_ifork_ptr(ip, whichfork);\n\n\tASSERT(!isnullstartblock(new->br_startblock));\n\n\tXFS_STATS_INC(mp, xs_add_exlist);\n\n#define\tLEFT\t\tr[0]\n#define\tRIGHT\t\tr[1]\n#define\tPREV\t\tr[2]\n\n\t \n\terror = 0;\n\txfs_iext_get_extent(ifp, icur, &PREV);\n\tASSERT(new->br_state != PREV.br_state);\n\tnew_endoff = new->br_startoff + new->br_blockcount;\n\tASSERT(PREV.br_startoff <= new->br_startoff);\n\tASSERT(PREV.br_startoff + PREV.br_blockcount >= new_endoff);\n\n\t \n\tif (PREV.br_startoff == new->br_startoff)\n\t\tstate |= BMAP_LEFT_FILLING;\n\tif (PREV.br_startoff + PREV.br_blockcount == new_endoff)\n\t\tstate |= BMAP_RIGHT_FILLING;\n\n\t \n\tif (xfs_iext_peek_prev_extent(ifp, icur, &LEFT)) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\tif (isnullstartblock(LEFT.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\tif ((state & BMAP_LEFT_VALID) && !(state & BMAP_LEFT_DELAY) &&\n\t    LEFT.br_startoff + LEFT.br_blockcount == new->br_startoff &&\n\t    LEFT.br_startblock + LEFT.br_blockcount == new->br_startblock &&\n\t    LEFT.br_state == new->br_state &&\n\t    LEFT.br_blockcount + new->br_blockcount <= XFS_MAX_BMBT_EXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\t \n\tif (xfs_iext_peek_next_extent(ifp, icur, &RIGHT)) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\tif (isnullstartblock(RIGHT.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\tif ((state & BMAP_RIGHT_VALID) && !(state & BMAP_RIGHT_DELAY) &&\n\t    new_endoff == RIGHT.br_startoff &&\n\t    new->br_startblock + new->br_blockcount == RIGHT.br_startblock &&\n\t    new->br_state == RIGHT.br_state &&\n\t    new->br_blockcount + RIGHT.br_blockcount <= XFS_MAX_BMBT_EXTLEN &&\n\t    ((state & (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING)) !=\n\t\t      (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING) ||\n\t     LEFT.br_blockcount + new->br_blockcount + RIGHT.br_blockcount\n\t\t\t<= XFS_MAX_BMBT_EXTLEN))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\t \n\tswitch (state & (BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t\t\t BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t     BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t \n\t\tLEFT.br_blockcount += PREV.br_blockcount + RIGHT.br_blockcount;\n\n\t\txfs_iext_remove(ip, icur, state);\n\t\txfs_iext_remove(ip, icur, state);\n\t\txfs_iext_prev(ifp, icur);\n\t\txfs_iext_update_extent(ip, state, icur, &LEFT);\n\t\tifp->if_nextents -= 2;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(cur, &RIGHT, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_bmbt_update(cur, &LEFT);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\t\t \n\t\tLEFT.br_blockcount += PREV.br_blockcount;\n\n\t\txfs_iext_remove(ip, icur, state);\n\t\txfs_iext_prev(ifp, icur);\n\t\txfs_iext_update_extent(ip, state, icur, &LEFT);\n\t\tifp->if_nextents--;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(cur, &PREV, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_bmbt_update(cur, &LEFT);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t \n\t\tPREV.br_blockcount += RIGHT.br_blockcount;\n\t\tPREV.br_state = new->br_state;\n\n\t\txfs_iext_next(ifp, icur);\n\t\txfs_iext_remove(ip, icur, state);\n\t\txfs_iext_prev(ifp, icur);\n\t\txfs_iext_update_extent(ip, state, icur, &PREV);\n\t\tifp->if_nextents--;\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(cur, &RIGHT, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_bmbt_update(cur, &PREV);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:\n\t\t \n\t\tPREV.br_state = new->br_state;\n\t\txfs_iext_update_extent(ip, state, icur, &PREV);\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(cur, new, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_bmbt_update(cur, &PREV);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG:\n\t\t \n\t\tLEFT.br_blockcount += new->br_blockcount;\n\n\t\told = PREV;\n\t\tPREV.br_startoff += new->br_blockcount;\n\t\tPREV.br_startblock += new->br_blockcount;\n\t\tPREV.br_blockcount -= new->br_blockcount;\n\n\t\txfs_iext_update_extent(ip, state, icur, &PREV);\n\t\txfs_iext_prev(ifp, icur);\n\t\txfs_iext_update_extent(ip, state, icur, &LEFT);\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(cur, &old, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_bmbt_update(cur, &PREV);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\terror = xfs_btree_decrement(cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\terror = xfs_bmbt_update(cur, &LEFT);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING:\n\t\t \n\t\told = PREV;\n\t\tPREV.br_startoff += new->br_blockcount;\n\t\tPREV.br_startblock += new->br_blockcount;\n\t\tPREV.br_blockcount -= new->br_blockcount;\n\n\t\txfs_iext_update_extent(ip, state, icur, &PREV);\n\t\txfs_iext_insert(ip, icur, new, state);\n\t\tifp->if_nextents++;\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(cur, &old, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_bmbt_update(cur, &PREV);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tcur->bc_rec.b = *new;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t \n\t\told = PREV;\n\t\tPREV.br_blockcount -= new->br_blockcount;\n\n\t\tRIGHT.br_startoff = new->br_startoff;\n\t\tRIGHT.br_startblock = new->br_startblock;\n\t\tRIGHT.br_blockcount += new->br_blockcount;\n\n\t\txfs_iext_update_extent(ip, state, icur, &PREV);\n\t\txfs_iext_next(ifp, icur);\n\t\txfs_iext_update_extent(ip, state, icur, &RIGHT);\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(cur, &old, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_bmbt_update(cur, &PREV);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\terror = xfs_bmbt_update(cur, &RIGHT);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING:\n\t\t \n\t\told = PREV;\n\t\tPREV.br_blockcount -= new->br_blockcount;\n\n\t\txfs_iext_update_extent(ip, state, icur, &PREV);\n\t\txfs_iext_next(ifp, icur);\n\t\txfs_iext_insert(ip, icur, new, state);\n\t\tifp->if_nextents++;\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(cur, &old, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_bmbt_update(cur, &PREV);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\terror = xfs_bmbt_lookup_eq(cur, new, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 0)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\t \n\t\told = PREV;\n\t\tPREV.br_blockcount = new->br_startoff - PREV.br_startoff;\n\n\t\tr[0] = *new;\n\t\tr[1].br_startoff = new_endoff;\n\t\tr[1].br_blockcount =\n\t\t\told.br_startoff + old.br_blockcount - new_endoff;\n\t\tr[1].br_startblock = new->br_startblock + new->br_blockcount;\n\t\tr[1].br_state = PREV.br_state;\n\n\t\txfs_iext_update_extent(ip, state, icur, &PREV);\n\t\txfs_iext_next(ifp, icur);\n\t\txfs_iext_insert(ip, icur, &r[1], state);\n\t\txfs_iext_insert(ip, icur, &r[0], state);\n\t\tifp->if_nextents += 2;\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(cur, &old, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t \n\t\t\terror = xfs_bmbt_update(cur, &r[1]);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\t \n\t\t\tcur->bc_rec.b = PREV;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t \n\t\t\terror = xfs_bmbt_lookup_eq(cur, new, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 0)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t \n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_CONTIG:\n\tcase BMAP_RIGHT_CONTIG:\n\t\t \n\t\tASSERT(0);\n\t}\n\n\t \n\txfs_rmap_convert_extent(mp, tp, ip, whichfork, new);\n\n\t \n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tint\ttmp_logflags;\t \n\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, &cur, 0,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\t*logflagsp |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto done;\n\t}\n\n\t \n\tif (cur) {\n\t\tcur->bc_ino.allocated = 0;\n\t\t*curp = cur;\n\t}\n\n\txfs_bmap_check_leaf_extents(*curp, ip, whichfork);\ndone:\n\t*logflagsp |= rval;\n\treturn error;\n#undef\tLEFT\n#undef\tRIGHT\n#undef\tPREV\n}\n\n \nSTATIC void\nxfs_bmap_add_extent_hole_delay(\n\txfs_inode_t\t\t*ip,\t \n\tint\t\t\twhichfork,\n\tstruct xfs_iext_cursor\t*icur,\n\txfs_bmbt_irec_t\t\t*new)\t \n{\n\tstruct xfs_ifork\t*ifp;\t \n\txfs_bmbt_irec_t\t\tleft;\t \n\txfs_filblks_t\t\tnewlen=0;\t \n\txfs_filblks_t\t\toldlen=0;\t \n\txfs_bmbt_irec_t\t\tright;\t \n\tuint32_t\t\tstate = xfs_bmap_fork_to_state(whichfork);\n\txfs_filblks_t\t\ttemp;\t  \n\n\tifp = xfs_ifork_ptr(ip, whichfork);\n\tASSERT(isnullstartblock(new->br_startblock));\n\n\t \n\tif (xfs_iext_peek_prev_extent(ifp, icur, &left)) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\tif (isnullstartblock(left.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\t \n\tif (xfs_iext_get_extent(ifp, icur, &right)) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\tif (isnullstartblock(right.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\t \n\tif ((state & BMAP_LEFT_VALID) && (state & BMAP_LEFT_DELAY) &&\n\t    left.br_startoff + left.br_blockcount == new->br_startoff &&\n\t    left.br_blockcount + new->br_blockcount <= XFS_MAX_BMBT_EXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\tif ((state & BMAP_RIGHT_VALID) && (state & BMAP_RIGHT_DELAY) &&\n\t    new->br_startoff + new->br_blockcount == right.br_startoff &&\n\t    new->br_blockcount + right.br_blockcount <= XFS_MAX_BMBT_EXTLEN &&\n\t    (!(state & BMAP_LEFT_CONTIG) ||\n\t     (left.br_blockcount + new->br_blockcount +\n\t      right.br_blockcount <= XFS_MAX_BMBT_EXTLEN)))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\t \n\tswitch (state & (BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\t\t \n\t\ttemp = left.br_blockcount + new->br_blockcount +\n\t\t\tright.br_blockcount;\n\n\t\toldlen = startblockval(left.br_startblock) +\n\t\t\tstartblockval(new->br_startblock) +\n\t\t\tstartblockval(right.br_startblock);\n\t\tnewlen = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip, temp),\n\t\t\t\t\t oldlen);\n\t\tleft.br_startblock = nullstartblock(newlen);\n\t\tleft.br_blockcount = temp;\n\n\t\txfs_iext_remove(ip, icur, state);\n\t\txfs_iext_prev(ifp, icur);\n\t\txfs_iext_update_extent(ip, state, icur, &left);\n\t\tbreak;\n\n\tcase BMAP_LEFT_CONTIG:\n\t\t \n\t\ttemp = left.br_blockcount + new->br_blockcount;\n\n\t\toldlen = startblockval(left.br_startblock) +\n\t\t\tstartblockval(new->br_startblock);\n\t\tnewlen = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip, temp),\n\t\t\t\t\t oldlen);\n\t\tleft.br_blockcount = temp;\n\t\tleft.br_startblock = nullstartblock(newlen);\n\n\t\txfs_iext_prev(ifp, icur);\n\t\txfs_iext_update_extent(ip, state, icur, &left);\n\t\tbreak;\n\n\tcase BMAP_RIGHT_CONTIG:\n\t\t \n\t\ttemp = new->br_blockcount + right.br_blockcount;\n\t\toldlen = startblockval(new->br_startblock) +\n\t\t\tstartblockval(right.br_startblock);\n\t\tnewlen = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip, temp),\n\t\t\t\t\t oldlen);\n\t\tright.br_startoff = new->br_startoff;\n\t\tright.br_startblock = nullstartblock(newlen);\n\t\tright.br_blockcount = temp;\n\t\txfs_iext_update_extent(ip, state, icur, &right);\n\t\tbreak;\n\n\tcase 0:\n\t\t \n\t\toldlen = newlen = 0;\n\t\txfs_iext_insert(ip, icur, new, state);\n\t\tbreak;\n\t}\n\tif (oldlen != newlen) {\n\t\tASSERT(oldlen > newlen);\n\t\txfs_mod_fdblocks(ip->i_mount, (int64_t)(oldlen - newlen),\n\t\t\t\t false);\n\t\t \n\t\txfs_mod_delalloc(ip->i_mount, (int64_t)newlen - oldlen);\n\t}\n}\n\n \nSTATIC int\t\t\t\t \nxfs_bmap_add_extent_hole_real(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tstruct xfs_iext_cursor\t*icur,\n\tstruct xfs_btree_cur\t**curp,\n\tstruct xfs_bmbt_irec\t*new,\n\tint\t\t\t*logflagsp,\n\tuint32_t\t\tflags)\n{\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_btree_cur\t*cur = *curp;\n\tint\t\t\terror;\t \n\tint\t\t\ti;\t \n\txfs_bmbt_irec_t\t\tleft;\t \n\txfs_bmbt_irec_t\t\tright;\t \n\tint\t\t\trval=0;\t \n\tuint32_t\t\tstate = xfs_bmap_fork_to_state(whichfork);\n\tstruct xfs_bmbt_irec\told;\n\n\tASSERT(!isnullstartblock(new->br_startblock));\n\tASSERT(!cur || !(cur->bc_ino.flags & XFS_BTCUR_BMBT_WASDEL));\n\n\tXFS_STATS_INC(mp, xs_add_exlist);\n\n\t \n\tif (xfs_iext_peek_prev_extent(ifp, icur, &left)) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\tif (isnullstartblock(left.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\t \n\tif (xfs_iext_get_extent(ifp, icur, &right)) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\tif (isnullstartblock(right.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\t \n\tif ((state & BMAP_LEFT_VALID) && !(state & BMAP_LEFT_DELAY) &&\n\t    left.br_startoff + left.br_blockcount == new->br_startoff &&\n\t    left.br_startblock + left.br_blockcount == new->br_startblock &&\n\t    left.br_state == new->br_state &&\n\t    left.br_blockcount + new->br_blockcount <= XFS_MAX_BMBT_EXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\tif ((state & BMAP_RIGHT_VALID) && !(state & BMAP_RIGHT_DELAY) &&\n\t    new->br_startoff + new->br_blockcount == right.br_startoff &&\n\t    new->br_startblock + new->br_blockcount == right.br_startblock &&\n\t    new->br_state == right.br_state &&\n\t    new->br_blockcount + right.br_blockcount <= XFS_MAX_BMBT_EXTLEN &&\n\t    (!(state & BMAP_LEFT_CONTIG) ||\n\t     left.br_blockcount + new->br_blockcount +\n\t     right.br_blockcount <= XFS_MAX_BMBT_EXTLEN))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\terror = 0;\n\t \n\tswitch (state & (BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\t\t \n\t\tleft.br_blockcount += new->br_blockcount + right.br_blockcount;\n\n\t\txfs_iext_remove(ip, icur, state);\n\t\txfs_iext_prev(ifp, icur);\n\t\txfs_iext_update_extent(ip, state, icur, &left);\n\t\tifp->if_nextents--;\n\n\t\tif (cur == NULL) {\n\t\t\trval = XFS_ILOG_CORE | xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(cur, &right, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_btree_delete(cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_btree_decrement(cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_bmbt_update(cur, &left);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_CONTIG:\n\t\t \n\t\told = left;\n\t\tleft.br_blockcount += new->br_blockcount;\n\n\t\txfs_iext_prev(ifp, icur);\n\t\txfs_iext_update_extent(ip, state, icur, &left);\n\n\t\tif (cur == NULL) {\n\t\t\trval = xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(cur, &old, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_bmbt_update(cur, &left);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_CONTIG:\n\t\t \n\t\told = right;\n\n\t\tright.br_startoff = new->br_startoff;\n\t\tright.br_startblock = new->br_startblock;\n\t\tright.br_blockcount += new->br_blockcount;\n\t\txfs_iext_update_extent(ip, state, icur, &right);\n\n\t\tif (cur == NULL) {\n\t\t\trval = xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(cur, &old, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_bmbt_update(cur, &right);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\t \n\t\txfs_iext_insert(ip, icur, new, state);\n\t\tifp->if_nextents++;\n\n\t\tif (cur == NULL) {\n\t\t\trval = XFS_ILOG_CORE | xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(cur, new, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 0)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\terror = xfs_btree_insert(cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tif (!(flags & XFS_BMAPI_NORMAP))\n\t\txfs_rmap_map_extent(tp, ip, whichfork, new);\n\n\t \n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tint\ttmp_logflags;\t \n\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, curp, 0,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\t*logflagsp |= tmp_logflags;\n\t\tcur = *curp;\n\t\tif (error)\n\t\t\tgoto done;\n\t}\n\n\t \n\tif (cur)\n\t\tcur->bc_ino.allocated = 0;\n\n\txfs_bmap_check_leaf_extents(cur, ip, whichfork);\ndone:\n\t*logflagsp |= rval;\n\treturn error;\n}\n\n \n\n \nint\nxfs_bmap_extsize_align(\n\txfs_mount_t\t*mp,\n\txfs_bmbt_irec_t\t*gotp,\t\t \n\txfs_bmbt_irec_t\t*prevp,\t\t \n\txfs_extlen_t\textsz,\t\t \n\tint\t\trt,\t\t \n\tint\t\teof,\t\t \n\tint\t\tdelay,\t\t \n\tint\t\tconvert,\t \n\txfs_fileoff_t\t*offp,\t\t \n\txfs_extlen_t\t*lenp)\t\t \n{\n\txfs_fileoff_t\torig_off;\t \n\txfs_extlen_t\torig_alen;\t \n\txfs_fileoff_t\torig_end;\t \n\txfs_fileoff_t\tnexto;\t\t \n\txfs_fileoff_t\tprevo;\t\t \n\txfs_fileoff_t\talign_off;\t \n\txfs_extlen_t\talign_alen;\t \n\txfs_extlen_t\ttemp;\t\t \n\n\tif (convert)\n\t\treturn 0;\n\n\torig_off = align_off = *offp;\n\torig_alen = align_alen = *lenp;\n\torig_end = orig_off + orig_alen;\n\n\t \n\tif (!delay && !eof &&\n\t    (orig_off >= gotp->br_startoff) &&\n\t    (orig_end <= gotp->br_startoff + gotp->br_blockcount)) {\n\t\treturn 0;\n\t}\n\n\t \n\tdiv_u64_rem(orig_off, extsz, &temp);\n\tif (temp) {\n\t\talign_alen += temp;\n\t\talign_off -= temp;\n\t}\n\n\t \n\ttemp = (align_alen % extsz);\n\tif (temp)\n\t\talign_alen += extsz - temp;\n\n\t \n\twhile (align_alen > XFS_MAX_BMBT_EXTLEN)\n\t\talign_alen -= extsz;\n\tASSERT(align_alen <= XFS_MAX_BMBT_EXTLEN);\n\n\t \n\tif (prevp->br_startoff != NULLFILEOFF) {\n\t\tif (prevp->br_startblock == HOLESTARTBLOCK)\n\t\t\tprevo = prevp->br_startoff;\n\t\telse\n\t\t\tprevo = prevp->br_startoff + prevp->br_blockcount;\n\t} else\n\t\tprevo = 0;\n\tif (align_off != orig_off && align_off < prevo)\n\t\talign_off = prevo;\n\t \n\tif (!eof && gotp->br_startoff != NULLFILEOFF) {\n\t\tif ((delay && gotp->br_startblock == HOLESTARTBLOCK) ||\n\t\t    (!delay && gotp->br_startblock == DELAYSTARTBLOCK))\n\t\t\tnexto = gotp->br_startoff + gotp->br_blockcount;\n\t\telse\n\t\t\tnexto = gotp->br_startoff;\n\t} else\n\t\tnexto = NULLFILEOFF;\n\tif (!eof &&\n\t    align_off + align_alen != orig_end &&\n\t    align_off + align_alen > nexto)\n\t\talign_off = nexto > align_alen ? nexto - align_alen : 0;\n\t \n\tif (align_off != orig_off && align_off < prevo)\n\t\talign_off = prevo;\n\tif (align_off + align_alen != orig_end &&\n\t    align_off + align_alen > nexto &&\n\t    nexto != NULLFILEOFF) {\n\t\tASSERT(nexto > prevo);\n\t\talign_alen = nexto - align_off;\n\t}\n\n\t \n\tif (rt && (temp = (align_alen % mp->m_sb.sb_rextsize))) {\n\t\t \n\t\tif (orig_off < align_off ||\n\t\t    orig_end > align_off + align_alen ||\n\t\t    align_alen - temp < orig_alen)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (align_off + temp <= orig_off) {\n\t\t\talign_alen -= temp;\n\t\t\talign_off += temp;\n\t\t}\n\t\t \n\t\telse if (align_off + align_alen - temp >= orig_end)\n\t\t\talign_alen -= temp;\n\t\t \n\t\telse {\n\t\t\talign_alen -= orig_off - align_off;\n\t\t\talign_off = orig_off;\n\t\t\talign_alen -= align_alen % mp->m_sb.sb_rextsize;\n\t\t}\n\t\t \n\t\tif (orig_off < align_off || orig_end > align_off + align_alen)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tASSERT(orig_off >= align_off);\n\t\t \n\t\tASSERT(orig_end <= align_off + align_alen ||\n\t\t       align_alen + extsz > XFS_MAX_BMBT_EXTLEN);\n\t}\n\n#ifdef DEBUG\n\tif (!eof && gotp->br_startoff != NULLFILEOFF)\n\t\tASSERT(align_off + align_alen <= gotp->br_startoff);\n\tif (prevp->br_startoff != NULLFILEOFF)\n\t\tASSERT(align_off >= prevp->br_startoff + prevp->br_blockcount);\n#endif\n\n\t*lenp = align_alen;\n\t*offp = align_off;\n\treturn 0;\n}\n\n#define XFS_ALLOC_GAP_UNITS\t4\n\nvoid\nxfs_bmap_adjacent(\n\tstruct xfs_bmalloca\t*ap)\t \n{\n\txfs_fsblock_t\tadjust;\t\t \n\txfs_mount_t\t*mp;\t\t \n\tint\t\trt;\t\t \n\n#define\tISVALID(x,y)\t\\\n\t(rt ? \\\n\t\t(x) < mp->m_sb.sb_rblocks : \\\n\t\tXFS_FSB_TO_AGNO(mp, x) == XFS_FSB_TO_AGNO(mp, y) && \\\n\t\tXFS_FSB_TO_AGNO(mp, x) < mp->m_sb.sb_agcount && \\\n\t\tXFS_FSB_TO_AGBNO(mp, x) < mp->m_sb.sb_agblocks)\n\n\tmp = ap->ip->i_mount;\n\trt = XFS_IS_REALTIME_INODE(ap->ip) &&\n\t\t(ap->datatype & XFS_ALLOC_USERDATA);\n\t \n\tif (ap->eof && ap->prev.br_startoff != NULLFILEOFF &&\n\t    !isnullstartblock(ap->prev.br_startblock) &&\n\t    ISVALID(ap->prev.br_startblock + ap->prev.br_blockcount,\n\t\t    ap->prev.br_startblock)) {\n\t\tap->blkno = ap->prev.br_startblock + ap->prev.br_blockcount;\n\t\t \n\t\tadjust = ap->offset -\n\t\t\t(ap->prev.br_startoff + ap->prev.br_blockcount);\n\t\tif (adjust &&\n\t\t    ISVALID(ap->blkno + adjust, ap->prev.br_startblock))\n\t\t\tap->blkno += adjust;\n\t}\n\t \n\telse if (!ap->eof) {\n\t\txfs_fsblock_t\tgotbno;\t\t \n\t\txfs_fsblock_t\tgotdiff=0;\t \n\t\txfs_fsblock_t\tprevbno;\t \n\t\txfs_fsblock_t\tprevdiff=0;\t \n\n\t\t \n\t\tif (ap->prev.br_startoff != NULLFILEOFF &&\n\t\t    !isnullstartblock(ap->prev.br_startblock) &&\n\t\t    (prevbno = ap->prev.br_startblock +\n\t\t\t       ap->prev.br_blockcount) &&\n\t\t    ISVALID(prevbno, ap->prev.br_startblock)) {\n\t\t\t \n\t\t\tadjust = prevdiff = ap->offset -\n\t\t\t\t(ap->prev.br_startoff +\n\t\t\t\t ap->prev.br_blockcount);\n\t\t\t \n\t\t\tif (prevdiff <= XFS_ALLOC_GAP_UNITS * ap->length &&\n\t\t\t    ISVALID(prevbno + prevdiff,\n\t\t\t\t    ap->prev.br_startblock))\n\t\t\t\tprevbno += adjust;\n\t\t\telse\n\t\t\t\tprevdiff += adjust;\n\t\t}\n\t\t \n\t\telse\n\t\t\tprevbno = NULLFSBLOCK;\n\t\t \n\t\tif (!isnullstartblock(ap->got.br_startblock)) {\n\t\t\t \n\t\t\tadjust = gotdiff = ap->got.br_startoff - ap->offset;\n\t\t\t \n\t\t\tgotbno = ap->got.br_startblock;\n\t\t\t \n\t\t\tif (gotdiff <= XFS_ALLOC_GAP_UNITS * ap->length &&\n\t\t\t    ISVALID(gotbno - gotdiff, gotbno))\n\t\t\t\tgotbno -= adjust;\n\t\t\telse if (ISVALID(gotbno - ap->length, gotbno)) {\n\t\t\t\tgotbno -= ap->length;\n\t\t\t\tgotdiff += adjust - ap->length;\n\t\t\t} else\n\t\t\t\tgotdiff += adjust;\n\t\t}\n\t\t \n\t\telse\n\t\t\tgotbno = NULLFSBLOCK;\n\t\t \n\t\tif (prevbno != NULLFSBLOCK && gotbno != NULLFSBLOCK)\n\t\t\tap->blkno = prevdiff <= gotdiff ? prevbno : gotbno;\n\t\telse if (prevbno != NULLFSBLOCK)\n\t\t\tap->blkno = prevbno;\n\t\telse if (gotbno != NULLFSBLOCK)\n\t\t\tap->blkno = gotbno;\n\t}\n#undef ISVALID\n}\n\nint\nxfs_bmap_longest_free_extent(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\txfs_extlen_t\t\t*blen)\n{\n\txfs_extlen_t\t\tlongest;\n\tint\t\t\terror = 0;\n\n\tif (!xfs_perag_initialised_agf(pag)) {\n\t\terror = xfs_alloc_read_agf(pag, tp, XFS_ALLOC_FLAG_TRYLOCK,\n\t\t\t\tNULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tlongest = xfs_alloc_longest_free_extent(pag,\n\t\t\t\txfs_alloc_min_freelist(pag->pag_mount, pag),\n\t\t\t\txfs_ag_resv_needed(pag, XFS_AG_RESV_NONE));\n\tif (*blen < longest)\n\t\t*blen = longest;\n\n\treturn 0;\n}\n\nstatic xfs_extlen_t\nxfs_bmap_select_minlen(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\tblen)\n{\n\n\t \n\tif (blen < ap->minlen)\n\t\treturn ap->minlen;\n\n\t \n\tif (blen < args->maxlen)\n\t\treturn blen;\n\treturn args->maxlen;\n}\n\nstatic int\nxfs_bmap_btalloc_select_lengths(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\t*blen)\n{\n\tstruct xfs_mount\t*mp = args->mp;\n\tstruct xfs_perag\t*pag;\n\txfs_agnumber_t\t\tagno, startag;\n\tint\t\t\terror = 0;\n\n\tif (ap->tp->t_flags & XFS_TRANS_LOWMODE) {\n\t\targs->total = ap->minlen;\n\t\targs->minlen = ap->minlen;\n\t\treturn 0;\n\t}\n\n\targs->total = ap->total;\n\tstartag = XFS_FSB_TO_AGNO(mp, ap->blkno);\n\tif (startag == NULLAGNUMBER)\n\t\tstartag = 0;\n\n\t*blen = 0;\n\tfor_each_perag_wrap(mp, startag, agno, pag) {\n\t\terror = xfs_bmap_longest_free_extent(pag, args->tp, blen);\n\t\tif (error && error != -EAGAIN)\n\t\t\tbreak;\n\t\terror = 0;\n\t\tif (*blen >= args->maxlen)\n\t\t\tbreak;\n\t}\n\tif (pag)\n\t\txfs_perag_rele(pag);\n\n\targs->minlen = xfs_bmap_select_minlen(ap, args, *blen);\n\treturn error;\n}\n\n \nstatic void\nxfs_bmap_btalloc_accounting(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args)\n{\n\tif (ap->flags & XFS_BMAPI_COWFORK) {\n\t\t \n\t\tif (ap->wasdel) {\n\t\t\txfs_mod_delalloc(ap->ip->i_mount, -(int64_t)args->len);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tap->ip->i_delayed_blks += args->len;\n\t\txfs_trans_mod_dquot_byino(ap->tp, ap->ip, XFS_TRANS_DQ_RES_BLKS,\n\t\t\t\t-(long)args->len);\n\t\treturn;\n\t}\n\n\t \n\tap->ip->i_nblocks += args->len;\n\txfs_trans_log_inode(ap->tp, ap->ip, XFS_ILOG_CORE);\n\tif (ap->wasdel) {\n\t\tap->ip->i_delayed_blks -= args->len;\n\t\txfs_mod_delalloc(ap->ip->i_mount, -(int64_t)args->len);\n\t}\n\txfs_trans_mod_dquot_byino(ap->tp, ap->ip,\n\t\tap->wasdel ? XFS_TRANS_DQ_DELBCOUNT : XFS_TRANS_DQ_BCOUNT,\n\t\targs->len);\n}\n\nstatic int\nxfs_bmap_compute_alignments(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args)\n{\n\tstruct xfs_mount\t*mp = args->mp;\n\txfs_extlen_t\t\talign = 0;  \n\tint\t\t\tstripe_align = 0;\n\n\t \n\tif (mp->m_swidth && xfs_has_swalloc(mp))\n\t\tstripe_align = mp->m_swidth;\n\telse if (mp->m_dalign)\n\t\tstripe_align = mp->m_dalign;\n\n\tif (ap->flags & XFS_BMAPI_COWFORK)\n\t\talign = xfs_get_cowextsz_hint(ap->ip);\n\telse if (ap->datatype & XFS_ALLOC_USERDATA)\n\t\talign = xfs_get_extsz_hint(ap->ip);\n\tif (align) {\n\t\tif (xfs_bmap_extsize_align(mp, &ap->got, &ap->prev, align, 0,\n\t\t\t\t\tap->eof, 0, ap->conv, &ap->offset,\n\t\t\t\t\t&ap->length))\n\t\t\tASSERT(0);\n\t\tASSERT(ap->length);\n\t}\n\n\t \n\tif (align) {\n\t\targs->prod = align;\n\t\tdiv_u64_rem(ap->offset, args->prod, &args->mod);\n\t\tif (args->mod)\n\t\t\targs->mod = args->prod - args->mod;\n\t} else if (mp->m_sb.sb_blocksize >= PAGE_SIZE) {\n\t\targs->prod = 1;\n\t\targs->mod = 0;\n\t} else {\n\t\targs->prod = PAGE_SIZE >> mp->m_sb.sb_blocklog;\n\t\tdiv_u64_rem(ap->offset, args->prod, &args->mod);\n\t\tif (args->mod)\n\t\t\targs->mod = args->prod - args->mod;\n\t}\n\n\treturn stripe_align;\n}\n\nstatic void\nxfs_bmap_process_allocated_extent(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_fileoff_t\t\torig_offset,\n\txfs_extlen_t\t\torig_length)\n{\n\tap->blkno = args->fsbno;\n\tap->length = args->len;\n\t \n\tif (ap->length <= orig_length)\n\t\tap->offset = orig_offset;\n\telse if (ap->offset + ap->length < orig_offset + orig_length)\n\t\tap->offset = orig_offset + orig_length - ap->length;\n\txfs_bmap_btalloc_accounting(ap, args);\n}\n\n#ifdef DEBUG\nstatic int\nxfs_bmap_exact_minlen_extent_alloc(\n\tstruct xfs_bmalloca\t*ap)\n{\n\tstruct xfs_mount\t*mp = ap->ip->i_mount;\n\tstruct xfs_alloc_arg\targs = { .tp = ap->tp, .mp = mp };\n\txfs_fileoff_t\t\torig_offset;\n\txfs_extlen_t\t\torig_length;\n\tint\t\t\terror;\n\n\tASSERT(ap->length);\n\n\tif (ap->minlen != 1) {\n\t\tap->blkno = NULLFSBLOCK;\n\t\tap->length = 0;\n\t\treturn 0;\n\t}\n\n\torig_offset = ap->offset;\n\torig_length = ap->length;\n\n\targs.alloc_minlen_only = 1;\n\n\txfs_bmap_compute_alignments(ap, &args);\n\n\t \n\tap->blkno = XFS_AGB_TO_FSB(mp, 0, 0);\n\n\targs.oinfo = XFS_RMAP_OINFO_SKIP_UPDATE;\n\targs.minlen = args.maxlen = ap->minlen;\n\targs.total = ap->total;\n\n\targs.alignment = 1;\n\targs.minalignslop = 0;\n\n\targs.minleft = ap->minleft;\n\targs.wasdel = ap->wasdel;\n\targs.resv = XFS_AG_RESV_NONE;\n\targs.datatype = ap->datatype;\n\n\terror = xfs_alloc_vextent_first_ag(&args, ap->blkno);\n\tif (error)\n\t\treturn error;\n\n\tif (args.fsbno != NULLFSBLOCK) {\n\t\txfs_bmap_process_allocated_extent(ap, &args, orig_offset,\n\t\t\torig_length);\n\t} else {\n\t\tap->blkno = NULLFSBLOCK;\n\t\tap->length = 0;\n\t}\n\n\treturn 0;\n}\n#else\n\n#define xfs_bmap_exact_minlen_extent_alloc(bma) (-EFSCORRUPTED)\n\n#endif\n\n \nstatic int\nxfs_bmap_btalloc_at_eof(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\tblen,\n\tint\t\t\tstripe_align,\n\tbool\t\t\tag_only)\n{\n\tstruct xfs_mount\t*mp = args->mp;\n\tstruct xfs_perag\t*caller_pag = args->pag;\n\tint\t\t\terror;\n\n\t \n\tif (ap->offset) {\n\t\txfs_extlen_t\tnextminlen = 0;\n\n\t\t \n\t\targs->alignment = 1;\n\t\tif (blen > stripe_align && blen <= args->maxlen)\n\t\t\tnextminlen = blen - stripe_align;\n\t\telse\n\t\t\tnextminlen = args->minlen;\n\t\tif (nextminlen + stripe_align > args->minlen + 1)\n\t\t\targs->minalignslop = nextminlen + stripe_align -\n\t\t\t\t\targs->minlen - 1;\n\t\telse\n\t\t\targs->minalignslop = 0;\n\n\t\tif (!caller_pag)\n\t\t\targs->pag = xfs_perag_get(mp, XFS_FSB_TO_AGNO(mp, ap->blkno));\n\t\terror = xfs_alloc_vextent_exact_bno(args, ap->blkno);\n\t\tif (!caller_pag) {\n\t\t\txfs_perag_put(args->pag);\n\t\t\targs->pag = NULL;\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (args->fsbno != NULLFSBLOCK)\n\t\t\treturn 0;\n\t\t \n\t\targs->alignment = stripe_align;\n\t\targs->minlen = nextminlen;\n\t\targs->minalignslop = 0;\n\t} else {\n\t\t \n\t\targs->alignment = stripe_align;\n\t\tif (blen > args->alignment &&\n\t\t    blen <= args->maxlen + args->alignment)\n\t\t\targs->minlen = blen - args->alignment;\n\t\targs->minalignslop = 0;\n\t}\n\n\tif (ag_only) {\n\t\terror = xfs_alloc_vextent_near_bno(args, ap->blkno);\n\t} else {\n\t\targs->pag = NULL;\n\t\terror = xfs_alloc_vextent_start_ag(args, ap->blkno);\n\t\tASSERT(args->pag == NULL);\n\t\targs->pag = caller_pag;\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (args->fsbno != NULLFSBLOCK)\n\t\treturn 0;\n\n\t \n\targs->alignment = 1;\n\treturn 0;\n}\n\n \nint\nxfs_bmap_btalloc_low_space(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args)\n{\n\tint\t\t\terror;\n\n\tif (args->minlen > ap->minlen) {\n\t\targs->minlen = ap->minlen;\n\t\terror = xfs_alloc_vextent_start_ag(args, ap->blkno);\n\t\tif (error || args->fsbno != NULLFSBLOCK)\n\t\t\treturn error;\n\t}\n\n\t \n\targs->total = ap->minlen;\n\terror = xfs_alloc_vextent_first_ag(args, 0);\n\tif (error)\n\t\treturn error;\n\tap->tp->t_flags |= XFS_TRANS_LOWMODE;\n\treturn 0;\n}\n\nstatic int\nxfs_bmap_btalloc_filestreams(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\tint\t\t\tstripe_align)\n{\n\txfs_extlen_t\t\tblen = 0;\n\tint\t\t\terror = 0;\n\n\n\terror = xfs_filestream_select_ag(ap, args, &blen);\n\tif (error)\n\t\treturn error;\n\tASSERT(args->pag);\n\n\t \n\tif (ap->tp->t_flags & XFS_TRANS_LOWMODE) {\n\t\targs->minlen = ap->minlen;\n\t\tASSERT(args->fsbno == NULLFSBLOCK);\n\t\tgoto out_low_space;\n\t}\n\n\targs->minlen = xfs_bmap_select_minlen(ap, args, blen);\n\tif (ap->aeof)\n\t\terror = xfs_bmap_btalloc_at_eof(ap, args, blen, stripe_align,\n\t\t\t\ttrue);\n\n\tif (!error && args->fsbno == NULLFSBLOCK)\n\t\terror = xfs_alloc_vextent_near_bno(args, ap->blkno);\n\nout_low_space:\n\t \n\txfs_perag_rele(args->pag);\n\targs->pag = NULL;\n\tif (error || args->fsbno != NULLFSBLOCK)\n\t\treturn error;\n\n\treturn xfs_bmap_btalloc_low_space(ap, args);\n}\n\nstatic int\nxfs_bmap_btalloc_best_length(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\tint\t\t\tstripe_align)\n{\n\txfs_extlen_t\t\tblen = 0;\n\tint\t\t\terror;\n\n\tap->blkno = XFS_INO_TO_FSB(args->mp, ap->ip->i_ino);\n\txfs_bmap_adjacent(ap);\n\n\t \n\terror = xfs_bmap_btalloc_select_lengths(ap, args, &blen);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (ap->aeof && !(ap->tp->t_flags & XFS_TRANS_LOWMODE)) {\n\t\terror = xfs_bmap_btalloc_at_eof(ap, args, blen, stripe_align,\n\t\t\t\tfalse);\n\t\tif (error || args->fsbno != NULLFSBLOCK)\n\t\t\treturn error;\n\t}\n\n\terror = xfs_alloc_vextent_start_ag(args, ap->blkno);\n\tif (error || args->fsbno != NULLFSBLOCK)\n\t\treturn error;\n\n\treturn xfs_bmap_btalloc_low_space(ap, args);\n}\n\nstatic int\nxfs_bmap_btalloc(\n\tstruct xfs_bmalloca\t*ap)\n{\n\tstruct xfs_mount\t*mp = ap->ip->i_mount;\n\tstruct xfs_alloc_arg\targs = {\n\t\t.tp\t\t= ap->tp,\n\t\t.mp\t\t= mp,\n\t\t.fsbno\t\t= NULLFSBLOCK,\n\t\t.oinfo\t\t= XFS_RMAP_OINFO_SKIP_UPDATE,\n\t\t.minleft\t= ap->minleft,\n\t\t.wasdel\t\t= ap->wasdel,\n\t\t.resv\t\t= XFS_AG_RESV_NONE,\n\t\t.datatype\t= ap->datatype,\n\t\t.alignment\t= 1,\n\t\t.minalignslop\t= 0,\n\t};\n\txfs_fileoff_t\t\torig_offset;\n\txfs_extlen_t\t\torig_length;\n\tint\t\t\terror;\n\tint\t\t\tstripe_align;\n\n\tASSERT(ap->length);\n\torig_offset = ap->offset;\n\torig_length = ap->length;\n\n\tstripe_align = xfs_bmap_compute_alignments(ap, &args);\n\n\t \n\targs.maxlen = min(ap->length, mp->m_ag_max_usable);\n\n\tif ((ap->datatype & XFS_ALLOC_USERDATA) &&\n\t    xfs_inode_is_filestream(ap->ip))\n\t\terror = xfs_bmap_btalloc_filestreams(ap, &args, stripe_align);\n\telse\n\t\terror = xfs_bmap_btalloc_best_length(ap, &args, stripe_align);\n\tif (error)\n\t\treturn error;\n\n\tif (args.fsbno != NULLFSBLOCK) {\n\t\txfs_bmap_process_allocated_extent(ap, &args, orig_offset,\n\t\t\torig_length);\n\t} else {\n\t\tap->blkno = NULLFSBLOCK;\n\t\tap->length = 0;\n\t}\n\treturn 0;\n}\n\n \nvoid\nxfs_trim_extent(\n\tstruct xfs_bmbt_irec\t*irec,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen)\n{\n\txfs_fileoff_t\t\tdistance;\n\txfs_fileoff_t\t\tend = bno + len;\n\n\tif (irec->br_startoff + irec->br_blockcount <= bno ||\n\t    irec->br_startoff >= end) {\n\t\tirec->br_blockcount = 0;\n\t\treturn;\n\t}\n\n\tif (irec->br_startoff < bno) {\n\t\tdistance = bno - irec->br_startoff;\n\t\tif (isnullstartblock(irec->br_startblock))\n\t\t\tirec->br_startblock = DELAYSTARTBLOCK;\n\t\tif (irec->br_startblock != DELAYSTARTBLOCK &&\n\t\t    irec->br_startblock != HOLESTARTBLOCK)\n\t\t\tirec->br_startblock += distance;\n\t\tirec->br_startoff += distance;\n\t\tirec->br_blockcount -= distance;\n\t}\n\n\tif (end < irec->br_startoff + irec->br_blockcount) {\n\t\tdistance = irec->br_startoff + irec->br_blockcount - end;\n\t\tirec->br_blockcount -= distance;\n\t}\n}\n\n \nSTATIC void\nxfs_bmapi_trim_map(\n\tstruct xfs_bmbt_irec\t*mval,\n\tstruct xfs_bmbt_irec\t*got,\n\txfs_fileoff_t\t\t*bno,\n\txfs_filblks_t\t\tlen,\n\txfs_fileoff_t\t\tobno,\n\txfs_fileoff_t\t\tend,\n\tint\t\t\tn,\n\tuint32_t\t\tflags)\n{\n\tif ((flags & XFS_BMAPI_ENTIRE) ||\n\t    got->br_startoff + got->br_blockcount <= obno) {\n\t\t*mval = *got;\n\t\tif (isnullstartblock(got->br_startblock))\n\t\t\tmval->br_startblock = DELAYSTARTBLOCK;\n\t\treturn;\n\t}\n\n\tif (obno > *bno)\n\t\t*bno = obno;\n\tASSERT((*bno >= obno) || (n == 0));\n\tASSERT(*bno < end);\n\tmval->br_startoff = *bno;\n\tif (isnullstartblock(got->br_startblock))\n\t\tmval->br_startblock = DELAYSTARTBLOCK;\n\telse\n\t\tmval->br_startblock = got->br_startblock +\n\t\t\t\t\t(*bno - got->br_startoff);\n\t \n\tmval->br_blockcount = XFS_FILBLKS_MIN(end - *bno,\n\t\t\tgot->br_blockcount - (*bno - got->br_startoff));\n\tmval->br_state = got->br_state;\n\tASSERT(mval->br_blockcount <= len);\n\treturn;\n}\n\n \nSTATIC void\nxfs_bmapi_update_map(\n\tstruct xfs_bmbt_irec\t**map,\n\txfs_fileoff_t\t\t*bno,\n\txfs_filblks_t\t\t*len,\n\txfs_fileoff_t\t\tobno,\n\txfs_fileoff_t\t\tend,\n\tint\t\t\t*n,\n\tuint32_t\t\tflags)\n{\n\txfs_bmbt_irec_t\t*mval = *map;\n\n\tASSERT((flags & XFS_BMAPI_ENTIRE) ||\n\t       ((mval->br_startoff + mval->br_blockcount) <= end));\n\tASSERT((flags & XFS_BMAPI_ENTIRE) || (mval->br_blockcount <= *len) ||\n\t       (mval->br_startoff < obno));\n\n\t*bno = mval->br_startoff + mval->br_blockcount;\n\t*len = end - *bno;\n\tif (*n > 0 && mval->br_startoff == mval[-1].br_startoff) {\n\t\t \n\t\tASSERT(mval->br_startblock == mval[-1].br_startblock);\n\t\tASSERT(mval->br_blockcount > mval[-1].br_blockcount);\n\t\tASSERT(mval->br_state == mval[-1].br_state);\n\t\tmval[-1].br_blockcount = mval->br_blockcount;\n\t\tmval[-1].br_state = mval->br_state;\n\t} else if (*n > 0 && mval->br_startblock != DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock != DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock != HOLESTARTBLOCK &&\n\t\t   mval->br_startblock == mval[-1].br_startblock +\n\t\t\t\t\t  mval[-1].br_blockcount &&\n\t\t   mval[-1].br_state == mval->br_state) {\n\t\tASSERT(mval->br_startoff ==\n\t\t       mval[-1].br_startoff + mval[-1].br_blockcount);\n\t\tmval[-1].br_blockcount += mval->br_blockcount;\n\t} else if (*n > 0 &&\n\t\t   mval->br_startblock == DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock == DELAYSTARTBLOCK &&\n\t\t   mval->br_startoff ==\n\t\t   mval[-1].br_startoff + mval[-1].br_blockcount) {\n\t\tmval[-1].br_blockcount += mval->br_blockcount;\n\t\tmval[-1].br_state = mval->br_state;\n\t} else if (!((*n == 0) &&\n\t\t     ((mval->br_startoff + mval->br_blockcount) <=\n\t\t      obno))) {\n\t\tmval++;\n\t\t(*n)++;\n\t}\n\t*map = mval;\n}\n\n \nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tuint32_t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\twhichfork = xfs_bmapi_whichfork(flags);\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tstruct xfs_bmbt_irec\tgot;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\tstruct xfs_iext_cursor\ticur;\n\tint\t\t\terror;\n\tbool\t\t\teof = false;\n\tint\t\t\tn = 0;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK | XFS_BMAPI_ENTIRE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (WARN_ON_ONCE(!ifp))\n\t\treturn -EFSCORRUPTED;\n\n\tif (XFS_IS_CORRUPT(mp, !xfs_ifork_has_extents(ifp)) ||\n\t    XFS_TEST_ERROR(false, mp, XFS_ERRTAG_BMAPIFORMAT))\n\t\treturn -EFSCORRUPTED;\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(mp, xs_blk_mapr);\n\n\terror = xfs_iread_extents(NULL, ip, whichfork);\n\tif (error)\n\t\treturn error;\n\n\tif (!xfs_iext_lookup_extent(ip, ifp, bno, &icur, &got))\n\t\teof = true;\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t \n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t \n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t \n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!xfs_iext_next_extent(ifp, &icur, &got))\n\t\t\teof = true;\n\t}\n\t*nmap = n;\n\treturn 0;\n}\n\n \nint\nxfs_bmapi_reserve_delalloc(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_fileoff_t\t\toff,\n\txfs_filblks_t\t\tlen,\n\txfs_filblks_t\t\tprealloc,\n\tstruct xfs_bmbt_irec\t*got,\n\tstruct xfs_iext_cursor\t*icur,\n\tint\t\t\teof)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\txfs_extlen_t\t\talen;\n\txfs_extlen_t\t\tindlen;\n\tint\t\t\terror;\n\txfs_fileoff_t\t\taoff = off;\n\n\t \n\talen = XFS_FILBLKS_MIN(len + prealloc, XFS_MAX_BMBT_EXTLEN);\n\tif (!eof)\n\t\talen = XFS_FILBLKS_MIN(alen, got->br_startoff - aoff);\n\tif (prealloc && alen >= len)\n\t\tprealloc = alen - len;\n\n\t \n\tif (whichfork == XFS_COW_FORK) {\n\t\tstruct xfs_bmbt_irec\tprev;\n\t\txfs_extlen_t\t\textsz = xfs_get_cowextsz_hint(ip);\n\n\t\tif (!xfs_iext_peek_prev_extent(ifp, icur, &prev))\n\t\t\tprev.br_startoff = NULLFILEOFF;\n\n\t\terror = xfs_bmap_extsize_align(mp, got, &prev, extsz, 0, eof,\n\t\t\t\t\t       1, 0, &aoff, &alen);\n\t\tASSERT(!error);\n\t}\n\n\t \n\terror = xfs_quota_reserve_blkres(ip, alen);\n\tif (error)\n\t\treturn error;\n\n\t \n\tindlen = (xfs_extlen_t)xfs_bmap_worst_indlen(ip, alen);\n\tASSERT(indlen > 0);\n\n\terror = xfs_mod_fdblocks(mp, -((int64_t)alen), false);\n\tif (error)\n\t\tgoto out_unreserve_quota;\n\n\terror = xfs_mod_fdblocks(mp, -((int64_t)indlen), false);\n\tif (error)\n\t\tgoto out_unreserve_blocks;\n\n\n\tip->i_delayed_blks += alen;\n\txfs_mod_delalloc(ip->i_mount, alen + indlen);\n\n\tgot->br_startoff = aoff;\n\tgot->br_startblock = nullstartblock(indlen);\n\tgot->br_blockcount = alen;\n\tgot->br_state = XFS_EXT_NORM;\n\n\txfs_bmap_add_extent_hole_delay(ip, whichfork, icur, got);\n\n\t \n\tif (whichfork == XFS_DATA_FORK && prealloc)\n\t\txfs_inode_set_eofblocks_tag(ip);\n\tif (whichfork == XFS_COW_FORK && (prealloc || aoff < off || alen > len))\n\t\txfs_inode_set_cowblocks_tag(ip);\n\n\treturn 0;\n\nout_unreserve_blocks:\n\txfs_mod_fdblocks(mp, alen, false);\nout_unreserve_quota:\n\tif (XFS_IS_QUOTA_ON(mp))\n\t\txfs_quota_unreserve_blkres(ip, alen);\n\treturn error;\n}\n\nstatic int\nxfs_bmap_alloc_userdata(\n\tstruct xfs_bmalloca\t*bma)\n{\n\tstruct xfs_mount\t*mp = bma->ip->i_mount;\n\tint\t\t\twhichfork = xfs_bmapi_whichfork(bma->flags);\n\tint\t\t\terror;\n\n\t \n\tbma->datatype = XFS_ALLOC_NOBUSY;\n\tif (whichfork == XFS_DATA_FORK || whichfork == XFS_COW_FORK) {\n\t\tbma->datatype |= XFS_ALLOC_USERDATA;\n\t\tif (bma->offset == 0)\n\t\t\tbma->datatype |= XFS_ALLOC_INITIAL_USER_DATA;\n\n\t\tif (mp->m_dalign && bma->length >= mp->m_dalign) {\n\t\t\terror = xfs_bmap_isaeof(bma, whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (XFS_IS_REALTIME_INODE(bma->ip))\n\t\t\treturn xfs_bmap_rtalloc(bma);\n\t}\n\n\tif (unlikely(XFS_TEST_ERROR(false, mp,\n\t\t\tXFS_ERRTAG_BMAP_ALLOC_MINLEN_EXTENT)))\n\t\treturn xfs_bmap_exact_minlen_extent_alloc(bma);\n\n\treturn xfs_bmap_btalloc(bma);\n}\n\nstatic int\nxfs_bmapi_allocate(\n\tstruct xfs_bmalloca\t*bma)\n{\n\tstruct xfs_mount\t*mp = bma->ip->i_mount;\n\tint\t\t\twhichfork = xfs_bmapi_whichfork(bma->flags);\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(bma->ip, whichfork);\n\tint\t\t\ttmp_logflags = 0;\n\tint\t\t\terror;\n\n\tASSERT(bma->length > 0);\n\n\t \n\tif (bma->wasdel) {\n\t\tbma->length = (xfs_extlen_t)bma->got.br_blockcount;\n\t\tbma->offset = bma->got.br_startoff;\n\t\tif (!xfs_iext_peek_prev_extent(ifp, &bma->icur, &bma->prev))\n\t\t\tbma->prev.br_startoff = NULLFILEOFF;\n\t} else {\n\t\tbma->length = XFS_FILBLKS_MIN(bma->length, XFS_MAX_BMBT_EXTLEN);\n\t\tif (!bma->eof)\n\t\t\tbma->length = XFS_FILBLKS_MIN(bma->length,\n\t\t\t\t\tbma->got.br_startoff - bma->offset);\n\t}\n\n\tif (bma->flags & XFS_BMAPI_CONTIG)\n\t\tbma->minlen = bma->length;\n\telse\n\t\tbma->minlen = 1;\n\n\tif (bma->flags & XFS_BMAPI_METADATA) {\n\t\tif (unlikely(XFS_TEST_ERROR(false, mp,\n\t\t\t\tXFS_ERRTAG_BMAP_ALLOC_MINLEN_EXTENT)))\n\t\t\terror = xfs_bmap_exact_minlen_extent_alloc(bma);\n\t\telse\n\t\t\terror = xfs_bmap_btalloc(bma);\n\t} else {\n\t\terror = xfs_bmap_alloc_userdata(bma);\n\t}\n\tif (error || bma->blkno == NULLFSBLOCK)\n\t\treturn error;\n\n\tif (bma->flags & XFS_BMAPI_ZERO) {\n\t\terror = xfs_zero_extent(bma->ip, bma->blkno, bma->length);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (ifp->if_format == XFS_DINODE_FMT_BTREE && !bma->cur)\n\t\tbma->cur = xfs_bmbt_init_cursor(mp, bma->tp, bma->ip, whichfork);\n\t \n\tbma->nallocs++;\n\n\tif (bma->cur)\n\t\tbma->cur->bc_ino.flags =\n\t\t\tbma->wasdel ? XFS_BTCUR_BMBT_WASDEL : 0;\n\n\tbma->got.br_startoff = bma->offset;\n\tbma->got.br_startblock = bma->blkno;\n\tbma->got.br_blockcount = bma->length;\n\tbma->got.br_state = XFS_EXT_NORM;\n\n\tif (bma->flags & XFS_BMAPI_PREALLOC)\n\t\tbma->got.br_state = XFS_EXT_UNWRITTEN;\n\n\tif (bma->wasdel)\n\t\terror = xfs_bmap_add_extent_delay_real(bma, whichfork);\n\telse\n\t\terror = xfs_bmap_add_extent_hole_real(bma->tp, bma->ip,\n\t\t\t\twhichfork, &bma->icur, &bma->cur, &bma->got,\n\t\t\t\t&bma->logflags, bma->flags);\n\n\tbma->logflags |= tmp_logflags;\n\tif (error)\n\t\treturn error;\n\n\t \n\txfs_iext_get_extent(ifp, &bma->icur, &bma->got);\n\n\tASSERT(bma->got.br_startoff <= bma->offset);\n\tASSERT(bma->got.br_startoff + bma->got.br_blockcount >=\n\t       bma->offset + bma->length);\n\tASSERT(bma->got.br_state == XFS_EXT_NORM ||\n\t       bma->got.br_state == XFS_EXT_UNWRITTEN);\n\treturn 0;\n}\n\nSTATIC int\nxfs_bmapi_convert_unwritten(\n\tstruct xfs_bmalloca\t*bma,\n\tstruct xfs_bmbt_irec\t*mval,\n\txfs_filblks_t\t\tlen,\n\tuint32_t\t\tflags)\n{\n\tint\t\t\twhichfork = xfs_bmapi_whichfork(flags);\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(bma->ip, whichfork);\n\tint\t\t\ttmp_logflags = 0;\n\tint\t\t\terror;\n\n\t \n\tif (mval->br_state == XFS_EXT_UNWRITTEN &&\n\t    (flags & XFS_BMAPI_PREALLOC))\n\t\treturn 0;\n\n\t \n\tif (mval->br_state == XFS_EXT_NORM &&\n\t    (flags & (XFS_BMAPI_PREALLOC | XFS_BMAPI_CONVERT)) !=\n\t\t\t(XFS_BMAPI_PREALLOC | XFS_BMAPI_CONVERT))\n\t\treturn 0;\n\n\t \n\tASSERT(mval->br_blockcount <= len);\n\tif (ifp->if_format == XFS_DINODE_FMT_BTREE && !bma->cur) {\n\t\tbma->cur = xfs_bmbt_init_cursor(bma->ip->i_mount, bma->tp,\n\t\t\t\t\tbma->ip, whichfork);\n\t}\n\tmval->br_state = (mval->br_state == XFS_EXT_UNWRITTEN)\n\t\t\t\t? XFS_EXT_NORM : XFS_EXT_UNWRITTEN;\n\n\t \n\tif (flags & XFS_BMAPI_ZERO) {\n\t\terror = xfs_zero_extent(bma->ip, mval->br_startblock,\n\t\t\t\t\tmval->br_blockcount);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = xfs_bmap_add_extent_unwritten_real(bma->tp, bma->ip, whichfork,\n\t\t\t&bma->icur, &bma->cur, mval, &tmp_logflags);\n\t \n\tif (whichfork != XFS_COW_FORK)\n\t\tbma->logflags |= tmp_logflags | XFS_ILOG_CORE;\n\tif (error)\n\t\treturn error;\n\n\t \n\txfs_iext_get_extent(ifp, &bma->icur, &bma->got);\n\n\t \n\tif (mval->br_blockcount < len)\n\t\treturn -EAGAIN;\n\treturn 0;\n}\n\nxfs_extlen_t\nxfs_bmapi_minleft(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tfork)\n{\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, fork);\n\n\tif (tp && tp->t_highest_agno != NULLAGNUMBER)\n\t\treturn 0;\n\tif (ifp->if_format != XFS_DINODE_FMT_BTREE)\n\t\treturn 1;\n\treturn be16_to_cpu(ifp->if_broot->bb_level) + 1;\n}\n\n \nstatic void\nxfs_bmapi_finish(\n\tstruct xfs_bmalloca\t*bma,\n\tint\t\t\twhichfork,\n\tint\t\t\terror)\n{\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(bma->ip, whichfork);\n\n\tif ((bma->logflags & xfs_ilog_fext(whichfork)) &&\n\t    ifp->if_format != XFS_DINODE_FMT_EXTENTS)\n\t\tbma->logflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((bma->logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t ifp->if_format != XFS_DINODE_FMT_BTREE)\n\t\tbma->logflags &= ~xfs_ilog_fbroot(whichfork);\n\n\tif (bma->logflags)\n\t\txfs_trans_log_inode(bma->tp, bma->ip, bma->logflags);\n\tif (bma->cur)\n\t\txfs_btree_del_cursor(bma->cur, error);\n}\n\n \nint\nxfs_bmapi_write(\n\tstruct xfs_trans\t*tp,\t\t \n\tstruct xfs_inode\t*ip,\t\t \n\txfs_fileoff_t\t\tbno,\t\t \n\txfs_filblks_t\t\tlen,\t\t \n\tuint32_t\t\tflags,\t\t \n\txfs_extlen_t\t\ttotal,\t\t \n\tstruct xfs_bmbt_irec\t*mval,\t\t \n\tint\t\t\t*nmap)\t\t \n{\n\tstruct xfs_bmalloca\tbma = {\n\t\t.tp\t\t= tp,\n\t\t.ip\t\t= ip,\n\t\t.total\t\t= total,\n\t};\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\twhichfork = xfs_bmapi_whichfork(flags);\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\txfs_fileoff_t\t\tend;\t\t \n\tbool\t\t\teof = false;\t \n\tint\t\t\terror;\t\t \n\tint\t\t\tn;\t\t \n\txfs_fileoff_t\t\tobno;\t\t \n\n#ifdef DEBUG\n\txfs_fileoff_t\t\torig_bno;\t \n\tint\t\t\torig_flags;\t \n\txfs_filblks_t\t\torig_len;\t \n\tstruct xfs_bmbt_irec\t*orig_mval;\t \n\tint\t\t\torig_nmap;\t \n\n\torig_bno = bno;\n\torig_len = len;\n\torig_flags = flags;\n\torig_mval = mval;\n\torig_nmap = *nmap;\n#endif\n\n\tASSERT(*nmap >= 1);\n\tASSERT(*nmap <= XFS_BMAP_MAX_NMAP);\n\tASSERT(tp != NULL);\n\tASSERT(len > 0);\n\tASSERT(ifp->if_format != XFS_DINODE_FMT_LOCAL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(!(flags & XFS_BMAPI_REMAP));\n\n\t \n\tASSERT((flags & (XFS_BMAPI_METADATA | XFS_BMAPI_ZERO)) !=\n\t\t\t(XFS_BMAPI_METADATA | XFS_BMAPI_ZERO));\n\t \n\tASSERT((flags & (XFS_BMAPI_PREALLOC | XFS_BMAPI_ZERO)) !=\n\t\t\t(XFS_BMAPI_PREALLOC | XFS_BMAPI_ZERO));\n\n\tif (XFS_IS_CORRUPT(mp, !xfs_ifork_has_extents(ifp)) ||\n\t    XFS_TEST_ERROR(false, mp, XFS_ERRTAG_BMAPIFORMAT)) {\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(mp, xs_blk_mapw);\n\n\terror = xfs_iread_extents(tp, ip, whichfork);\n\tif (error)\n\t\tgoto error0;\n\n\tif (!xfs_iext_lookup_extent(ip, ifp, bno, &bma.icur, &bma.got))\n\t\teof = true;\n\tif (!xfs_iext_peek_prev_extent(ifp, &bma.icur, &bma.prev))\n\t\tbma.prev.br_startoff = NULLFILEOFF;\n\tbma.minleft = xfs_bmapi_minleft(tp, ip, whichfork);\n\n\tn = 0;\n\tend = bno + len;\n\tobno = bno;\n\twhile (bno < end && n < *nmap) {\n\t\tbool\t\t\tneed_alloc = false, wasdelay = false;\n\n\t\t \n\t\tif (eof || bma.got.br_startoff > bno) {\n\t\t\t \n\t\t\tASSERT(!((flags & XFS_BMAPI_CONVERT) &&\n\t\t\t         (flags & XFS_BMAPI_COWFORK)));\n\n\t\t\tneed_alloc = true;\n\t\t} else if (isnullstartblock(bma.got.br_startblock)) {\n\t\t\twasdelay = true;\n\t\t}\n\n\t\t \n\t\tif (need_alloc || wasdelay) {\n\t\t\tbma.eof = eof;\n\t\t\tbma.conv = !!(flags & XFS_BMAPI_CONVERT);\n\t\t\tbma.wasdel = wasdelay;\n\t\t\tbma.offset = bno;\n\t\t\tbma.flags = flags;\n\n\t\t\t \n\t\t\tif (len > (xfs_filblks_t)XFS_MAX_BMBT_EXTLEN)\n\t\t\t\tbma.length = XFS_MAX_BMBT_EXTLEN;\n\t\t\telse\n\t\t\t\tbma.length = len;\n\n\t\t\tASSERT(len > 0);\n\t\t\tASSERT(bma.length > 0);\n\t\t\terror = xfs_bmapi_allocate(&bma);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (bma.blkno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (whichfork == XFS_COW_FORK)\n\t\t\t\txfs_refcount_alloc_cow_extent(tp, bma.blkno,\n\t\t\t\t\t\tbma.length);\n\t\t}\n\n\t\t \n\t\txfs_bmapi_trim_map(mval, &bma.got, &bno, len, obno,\n\t\t\t\t\t\t\tend, n, flags);\n\n\t\t \n\t\terror = xfs_bmapi_convert_unwritten(&bma, mval, len, flags);\n\t\tif (error == -EAGAIN)\n\t\t\tcontinue;\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t \n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t \n\t\tif (bno >= end || n >= *nmap || bma.nallocs >= *nmap)\n\t\t\tbreak;\n\n\t\t \n\t\tbma.prev = bma.got;\n\t\tif (!xfs_iext_next_extent(ifp, &bma.icur, &bma.got))\n\t\t\teof = true;\n\t}\n\t*nmap = n;\n\n\terror = xfs_bmap_btree_to_extents(tp, ip, bma.cur, &bma.logflags,\n\t\t\twhichfork);\n\tif (error)\n\t\tgoto error0;\n\n\tASSERT(ifp->if_format != XFS_DINODE_FMT_BTREE ||\n\t       ifp->if_nextents > XFS_IFORK_MAXEXT(ip, whichfork));\n\txfs_bmapi_finish(&bma, whichfork, 0);\n\txfs_bmap_validate_ret(orig_bno, orig_len, orig_flags, orig_mval,\n\t\torig_nmap, *nmap);\n\treturn 0;\nerror0:\n\txfs_bmapi_finish(&bma, whichfork, error);\n\treturn error;\n}\n\n \nint\nxfs_bmapi_convert_delalloc(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_off_t\t\toffset,\n\tstruct iomap\t\t*iomap,\n\tunsigned int\t\t*seq)\n{\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\tstruct xfs_bmalloca\tbma = { NULL };\n\tuint16_t\t\tflags = 0;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\tif (whichfork == XFS_COW_FORK)\n\t\tflags |= IOMAP_F_SHARED;\n\n\t \n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_write, 0, 0,\n\t\t\t\tXFS_TRANS_RESERVE, &tp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\terror = xfs_iext_count_may_overflow(ip, whichfork,\n\t\t\tXFS_IEXT_ADD_NOSPLIT_CNT);\n\tif (error == -EFBIG)\n\t\terror = xfs_iext_count_upgrade(tp, ip,\n\t\t\t\tXFS_IEXT_ADD_NOSPLIT_CNT);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tif (!xfs_iext_lookup_extent(ip, ifp, offset_fsb, &bma.icur, &bma.got) ||\n\t    bma.got.br_startoff > offset_fsb) {\n\t\t \n\t\tWARN_ON_ONCE(whichfork != XFS_COW_FORK);\n\t\terror = -EAGAIN;\n\t\tgoto out_trans_cancel;\n\t}\n\n\t \n\tif (!isnullstartblock(bma.got.br_startblock)) {\n\t\txfs_bmbt_to_iomap(ip, iomap, &bma.got, 0, flags,\n\t\t\t\txfs_iomap_inode_sequence(ip, flags));\n\t\t*seq = READ_ONCE(ifp->if_seq);\n\t\tgoto out_trans_cancel;\n\t}\n\n\tbma.tp = tp;\n\tbma.ip = ip;\n\tbma.wasdel = true;\n\tbma.offset = bma.got.br_startoff;\n\tbma.length = max_t(xfs_filblks_t, bma.got.br_blockcount,\n\t\t\tXFS_MAX_BMBT_EXTLEN);\n\tbma.minleft = xfs_bmapi_minleft(tp, ip, whichfork);\n\n\t \n\tbma.flags = XFS_BMAPI_PREALLOC;\n\tif (whichfork == XFS_COW_FORK)\n\t\tbma.flags |= XFS_BMAPI_COWFORK;\n\n\tif (!xfs_iext_peek_prev_extent(ifp, &bma.icur, &bma.prev))\n\t\tbma.prev.br_startoff = NULLFILEOFF;\n\n\terror = xfs_bmapi_allocate(&bma);\n\tif (error)\n\t\tgoto out_finish;\n\n\terror = -ENOSPC;\n\tif (WARN_ON_ONCE(bma.blkno == NULLFSBLOCK))\n\t\tgoto out_finish;\n\terror = -EFSCORRUPTED;\n\tif (WARN_ON_ONCE(!xfs_valid_startblock(ip, bma.got.br_startblock)))\n\t\tgoto out_finish;\n\n\tXFS_STATS_ADD(mp, xs_xstrat_bytes, XFS_FSB_TO_B(mp, bma.length));\n\tXFS_STATS_INC(mp, xs_xstrat_quick);\n\n\tASSERT(!isnullstartblock(bma.got.br_startblock));\n\txfs_bmbt_to_iomap(ip, iomap, &bma.got, 0, flags,\n\t\t\t\txfs_iomap_inode_sequence(ip, flags));\n\t*seq = READ_ONCE(ifp->if_seq);\n\n\tif (whichfork == XFS_COW_FORK)\n\t\txfs_refcount_alloc_cow_extent(tp, bma.blkno, bma.length);\n\n\terror = xfs_bmap_btree_to_extents(tp, ip, bma.cur, &bma.logflags,\n\t\t\twhichfork);\n\tif (error)\n\t\tgoto out_finish;\n\n\txfs_bmapi_finish(&bma, whichfork, 0);\n\terror = xfs_trans_commit(tp);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n\nout_finish:\n\txfs_bmapi_finish(&bma, whichfork, error);\nout_trans_cancel:\n\txfs_trans_cancel(tp);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\nint\nxfs_bmapi_remap(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\txfs_fsblock_t\t\tstartblock,\n\tuint32_t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_btree_cur\t*cur = NULL;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_iext_cursor\ticur;\n\tint\t\t\twhichfork = xfs_bmapi_whichfork(flags);\n\tint\t\t\tlogflags = 0, error;\n\n\tifp = xfs_ifork_ptr(ip, whichfork);\n\tASSERT(len > 0);\n\tASSERT(len <= (xfs_filblks_t)XFS_MAX_BMBT_EXTLEN);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK | XFS_BMAPI_PREALLOC |\n\t\t\t   XFS_BMAPI_NORMAP)));\n\tASSERT((flags & (XFS_BMAPI_ATTRFORK | XFS_BMAPI_PREALLOC)) !=\n\t\t\t(XFS_BMAPI_ATTRFORK | XFS_BMAPI_PREALLOC));\n\n\tif (XFS_IS_CORRUPT(mp, !xfs_ifork_has_extents(ifp)) ||\n\t    XFS_TEST_ERROR(false, mp, XFS_ERRTAG_BMAPIFORMAT)) {\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\terror = xfs_iread_extents(tp, ip, whichfork);\n\tif (error)\n\t\treturn error;\n\n\tif (xfs_iext_lookup_extent(ip, ifp, bno, &icur, &got)) {\n\t\t \n\t\tASSERT(got.br_startoff > bno);\n\t\tASSERT(got.br_startoff - bno >= len);\n\t}\n\n\tip->i_nblocks += len;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (ifp->if_format == XFS_DINODE_FMT_BTREE) {\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_ino.flags = 0;\n\t}\n\n\tgot.br_startoff = bno;\n\tgot.br_startblock = startblock;\n\tgot.br_blockcount = len;\n\tif (flags & XFS_BMAPI_PREALLOC)\n\t\tgot.br_state = XFS_EXT_UNWRITTEN;\n\telse\n\t\tgot.br_state = XFS_EXT_NORM;\n\n\terror = xfs_bmap_add_extent_hole_real(tp, ip, whichfork, &icur,\n\t\t\t&cur, &got, &logflags, flags);\n\tif (error)\n\t\tgoto error0;\n\n\terror = xfs_bmap_btree_to_extents(tp, ip, cur, &logflags, whichfork);\n\nerror0:\n\tif (ip->i_df.if_format != XFS_DINODE_FMT_EXTENTS)\n\t\tlogflags &= ~XFS_ILOG_DEXT;\n\telse if (ip->i_df.if_format != XFS_DINODE_FMT_BTREE)\n\t\tlogflags &= ~XFS_ILOG_DBROOT;\n\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (cur)\n\t\txfs_btree_del_cursor(cur, error);\n\treturn error;\n}\n\n \nstatic xfs_filblks_t\nxfs_bmap_split_indlen(\n\txfs_filblks_t\t\t\tores,\t\t \n\txfs_filblks_t\t\t\t*indlen1,\t \n\txfs_filblks_t\t\t\t*indlen2,\t \n\txfs_filblks_t\t\t\tavail)\t\t \n{\n\txfs_filblks_t\t\t\tlen1 = *indlen1;\n\txfs_filblks_t\t\t\tlen2 = *indlen2;\n\txfs_filblks_t\t\t\tnres = len1 + len2;  \n\txfs_filblks_t\t\t\tstolen = 0;\n\txfs_filblks_t\t\t\tresfactor;\n\n\t \n\tif (ores < nres && avail)\n\t\tstolen = XFS_FILBLKS_MIN(nres - ores, avail);\n\tores += stolen;\n\n\t  \n\tif (ores >= nres)\n\t\treturn stolen;\n\n\t \n\tresfactor = (ores * 100);\n\tdo_div(resfactor, nres);\n\tlen1 *= resfactor;\n\tdo_div(len1, 100);\n\tlen2 *= resfactor;\n\tdo_div(len2, 100);\n\tASSERT(len1 + len2 <= ores);\n\tASSERT(len1 < *indlen1 && len2 < *indlen2);\n\n\t \n\tores -= (len1 + len2);\n\tASSERT((*indlen1 - len1) + (*indlen2 - len2) >= ores);\n\tif (ores && !len2 && *indlen2) {\n\t\tlen2++;\n\t\tores--;\n\t}\n\twhile (ores) {\n\t\tif (len1 < *indlen1) {\n\t\t\tlen1++;\n\t\t\tores--;\n\t\t}\n\t\tif (!ores)\n\t\t\tbreak;\n\t\tif (len2 < *indlen2) {\n\t\t\tlen2++;\n\t\t\tores--;\n\t\t}\n\t}\n\n\t*indlen1 = len1;\n\t*indlen2 = len2;\n\n\treturn stolen;\n}\n\nint\nxfs_bmap_del_extent_delay(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tstruct xfs_iext_cursor\t*icur,\n\tstruct xfs_bmbt_irec\t*got,\n\tstruct xfs_bmbt_irec\t*del)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tstruct xfs_bmbt_irec\tnew;\n\tint64_t\t\t\tda_old, da_new, da_diff = 0;\n\txfs_fileoff_t\t\tdel_endoff, got_endoff;\n\txfs_filblks_t\t\tgot_indlen, new_indlen, stolen;\n\tuint32_t\t\tstate = xfs_bmap_fork_to_state(whichfork);\n\tint\t\t\terror = 0;\n\tbool\t\t\tisrt;\n\n\tXFS_STATS_INC(mp, xs_del_exlist);\n\n\tisrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);\n\tdel_endoff = del->br_startoff + del->br_blockcount;\n\tgot_endoff = got->br_startoff + got->br_blockcount;\n\tda_old = startblockval(got->br_startblock);\n\tda_new = 0;\n\n\tASSERT(del->br_blockcount > 0);\n\tASSERT(got->br_startoff <= del->br_startoff);\n\tASSERT(got_endoff >= del_endoff);\n\n\tif (isrt) {\n\t\tuint64_t rtexts = XFS_FSB_TO_B(mp, del->br_blockcount);\n\n\t\tdo_div(rtexts, mp->m_sb.sb_rextsize);\n\t\txfs_mod_frextents(mp, rtexts);\n\t}\n\n\t \n\tASSERT(!isrt);\n\terror = xfs_quota_unreserve_blkres(ip, del->br_blockcount);\n\tif (error)\n\t\treturn error;\n\tip->i_delayed_blks -= del->br_blockcount;\n\n\tif (got->br_startoff == del->br_startoff)\n\t\tstate |= BMAP_LEFT_FILLING;\n\tif (got_endoff == del_endoff)\n\t\tstate |= BMAP_RIGHT_FILLING;\n\n\tswitch (state & (BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING)) {\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:\n\t\t \n\t\txfs_iext_remove(ip, icur, state);\n\t\txfs_iext_prev(ifp, icur);\n\t\tbreak;\n\tcase BMAP_LEFT_FILLING:\n\t\t \n\t\tgot->br_startoff = del_endoff;\n\t\tgot->br_blockcount -= del->br_blockcount;\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip,\n\t\t\t\tgot->br_blockcount), da_old);\n\t\tgot->br_startblock = nullstartblock((int)da_new);\n\t\txfs_iext_update_extent(ip, state, icur, got);\n\t\tbreak;\n\tcase BMAP_RIGHT_FILLING:\n\t\t \n\t\tgot->br_blockcount = got->br_blockcount - del->br_blockcount;\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip,\n\t\t\t\tgot->br_blockcount), da_old);\n\t\tgot->br_startblock = nullstartblock((int)da_new);\n\t\txfs_iext_update_extent(ip, state, icur, got);\n\t\tbreak;\n\tcase 0:\n\t\t \n\t\tgot->br_blockcount = del->br_startoff - got->br_startoff;\n\t\tgot_indlen = xfs_bmap_worst_indlen(ip, got->br_blockcount);\n\n\t\tnew.br_blockcount = got_endoff - del_endoff;\n\t\tnew_indlen = xfs_bmap_worst_indlen(ip, new.br_blockcount);\n\n\t\tWARN_ON_ONCE(!got_indlen || !new_indlen);\n\t\tstolen = xfs_bmap_split_indlen(da_old, &got_indlen, &new_indlen,\n\t\t\t\t\t\t       del->br_blockcount);\n\n\t\tgot->br_startblock = nullstartblock((int)got_indlen);\n\n\t\tnew.br_startoff = del_endoff;\n\t\tnew.br_state = got->br_state;\n\t\tnew.br_startblock = nullstartblock((int)new_indlen);\n\n\t\txfs_iext_update_extent(ip, state, icur, got);\n\t\txfs_iext_next(ifp, icur);\n\t\txfs_iext_insert(ip, icur, &new, state);\n\n\t\tda_new = got_indlen + new_indlen - stolen;\n\t\tdel->br_blockcount -= stolen;\n\t\tbreak;\n\t}\n\n\tASSERT(da_old >= da_new);\n\tda_diff = da_old - da_new;\n\tif (!isrt)\n\t\tda_diff += del->br_blockcount;\n\tif (da_diff) {\n\t\txfs_mod_fdblocks(mp, da_diff, false);\n\t\txfs_mod_delalloc(mp, -da_diff);\n\t}\n\treturn error;\n}\n\nvoid\nxfs_bmap_del_extent_cow(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_iext_cursor\t*icur,\n\tstruct xfs_bmbt_irec\t*got,\n\tstruct xfs_bmbt_irec\t*del)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, XFS_COW_FORK);\n\tstruct xfs_bmbt_irec\tnew;\n\txfs_fileoff_t\t\tdel_endoff, got_endoff;\n\tuint32_t\t\tstate = BMAP_COWFORK;\n\n\tXFS_STATS_INC(mp, xs_del_exlist);\n\n\tdel_endoff = del->br_startoff + del->br_blockcount;\n\tgot_endoff = got->br_startoff + got->br_blockcount;\n\n\tASSERT(del->br_blockcount > 0);\n\tASSERT(got->br_startoff <= del->br_startoff);\n\tASSERT(got_endoff >= del_endoff);\n\tASSERT(!isnullstartblock(got->br_startblock));\n\n\tif (got->br_startoff == del->br_startoff)\n\t\tstate |= BMAP_LEFT_FILLING;\n\tif (got_endoff == del_endoff)\n\t\tstate |= BMAP_RIGHT_FILLING;\n\n\tswitch (state & (BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING)) {\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:\n\t\t \n\t\txfs_iext_remove(ip, icur, state);\n\t\txfs_iext_prev(ifp, icur);\n\t\tbreak;\n\tcase BMAP_LEFT_FILLING:\n\t\t \n\t\tgot->br_startoff = del_endoff;\n\t\tgot->br_blockcount -= del->br_blockcount;\n\t\tgot->br_startblock = del->br_startblock + del->br_blockcount;\n\t\txfs_iext_update_extent(ip, state, icur, got);\n\t\tbreak;\n\tcase BMAP_RIGHT_FILLING:\n\t\t \n\t\tgot->br_blockcount -= del->br_blockcount;\n\t\txfs_iext_update_extent(ip, state, icur, got);\n\t\tbreak;\n\tcase 0:\n\t\t \n\t\tgot->br_blockcount = del->br_startoff - got->br_startoff;\n\n\t\tnew.br_startoff = del_endoff;\n\t\tnew.br_blockcount = got_endoff - del_endoff;\n\t\tnew.br_state = got->br_state;\n\t\tnew.br_startblock = del->br_startblock + del->br_blockcount;\n\n\t\txfs_iext_update_extent(ip, state, icur, got);\n\t\txfs_iext_next(ifp, icur);\n\t\txfs_iext_insert(ip, icur, &new, state);\n\t\tbreak;\n\t}\n\tip->i_delayed_blks -= del->br_blockcount;\n}\n\n \nSTATIC int\t\t\t\t \nxfs_bmap_del_extent_real(\n\txfs_inode_t\t\t*ip,\t \n\txfs_trans_t\t\t*tp,\t \n\tstruct xfs_iext_cursor\t*icur,\n\tstruct xfs_btree_cur\t*cur,\t \n\txfs_bmbt_irec_t\t\t*del,\t \n\tint\t\t\t*logflagsp,  \n\tint\t\t\twhichfork,  \n\tuint32_t\t\tbflags)\t \n{\n\txfs_fsblock_t\t\tdel_endblock=0;\t \n\txfs_fileoff_t\t\tdel_endoff;\t \n\tint\t\t\tdo_fx;\t \n\tint\t\t\terror;\t \n\tint\t\t\tflags = 0; \n\tstruct xfs_bmbt_irec\tgot;\t \n\txfs_fileoff_t\t\tgot_endoff;\t \n\tint\t\t\ti;\t \n\tstruct xfs_ifork\t*ifp;\t \n\txfs_mount_t\t\t*mp;\t \n\txfs_filblks_t\t\tnblks;\t \n\txfs_bmbt_irec_t\t\tnew;\t \n\t \n\tuint\t\t\tqfield;\t \n\tuint32_t\t\tstate = xfs_bmap_fork_to_state(whichfork);\n\tstruct xfs_bmbt_irec\told;\n\n\tmp = ip->i_mount;\n\tXFS_STATS_INC(mp, xs_del_exlist);\n\n\tifp = xfs_ifork_ptr(ip, whichfork);\n\tASSERT(del->br_blockcount > 0);\n\txfs_iext_get_extent(ifp, icur, &got);\n\tASSERT(got.br_startoff <= del->br_startoff);\n\tdel_endoff = del->br_startoff + del->br_blockcount;\n\tgot_endoff = got.br_startoff + got.br_blockcount;\n\tASSERT(got_endoff >= del_endoff);\n\tASSERT(!isnullstartblock(got.br_startblock));\n\tqfield = 0;\n\terror = 0;\n\n\t \n\tif (tp->t_blk_res == 0 &&\n\t    ifp->if_format == XFS_DINODE_FMT_EXTENTS &&\n\t    ifp->if_nextents >= XFS_IFORK_MAXEXT(ip, whichfork) &&\n\t    del->br_startoff > got.br_startoff && del_endoff < got_endoff)\n\t\treturn -ENOSPC;\n\n\tflags = XFS_ILOG_CORE;\n\tif (whichfork == XFS_DATA_FORK && XFS_IS_REALTIME_INODE(ip)) {\n\t\txfs_filblks_t\tlen;\n\t\txfs_extlen_t\tmod;\n\n\t\tlen = div_u64_rem(del->br_blockcount, mp->m_sb.sb_rextsize,\n\t\t\t\t  &mod);\n\t\tASSERT(mod == 0);\n\n\t\tif (!(bflags & XFS_BMAPI_REMAP)) {\n\t\t\txfs_fsblock_t\tbno;\n\n\t\t\tbno = div_u64_rem(del->br_startblock,\n\t\t\t\t\tmp->m_sb.sb_rextsize, &mod);\n\t\t\tASSERT(mod == 0);\n\n\t\t\terror = xfs_rtfree_extent(tp, bno, (xfs_extlen_t)len);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tdo_fx = 0;\n\t\tnblks = len * mp->m_sb.sb_rextsize;\n\t\tqfield = XFS_TRANS_DQ_RTBCOUNT;\n\t} else {\n\t\tdo_fx = 1;\n\t\tnblks = del->br_blockcount;\n\t\tqfield = XFS_TRANS_DQ_BCOUNT;\n\t}\n\n\tdel_endblock = del->br_startblock + del->br_blockcount;\n\tif (cur) {\n\t\terror = xfs_bmbt_lookup_eq(cur, &got, &i);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (got.br_startoff == del->br_startoff)\n\t\tstate |= BMAP_LEFT_FILLING;\n\tif (got_endoff == del_endoff)\n\t\tstate |= BMAP_RIGHT_FILLING;\n\n\tswitch (state & (BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING)) {\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:\n\t\t \n\t\txfs_iext_remove(ip, icur, state);\n\t\txfs_iext_prev(ifp, icur);\n\t\tifp->if_nextents--;\n\n\t\tflags |= XFS_ILOG_CORE;\n\t\tif (!cur) {\n\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tbreak;\n\t\t}\n\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\tgoto done;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\tcase BMAP_LEFT_FILLING:\n\t\t \n\t\tgot.br_startoff = del_endoff;\n\t\tgot.br_startblock = del_endblock;\n\t\tgot.br_blockcount -= del->br_blockcount;\n\t\txfs_iext_update_extent(ip, state, icur, &got);\n\t\tif (!cur) {\n\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tbreak;\n\t\t}\n\t\terror = xfs_bmbt_update(cur, &got);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tbreak;\n\tcase BMAP_RIGHT_FILLING:\n\t\t \n\t\tgot.br_blockcount -= del->br_blockcount;\n\t\txfs_iext_update_extent(ip, state, icur, &got);\n\t\tif (!cur) {\n\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tbreak;\n\t\t}\n\t\terror = xfs_bmbt_update(cur, &got);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tbreak;\n\tcase 0:\n\t\t \n\n\t\told = got;\n\n\t\tgot.br_blockcount = del->br_startoff - got.br_startoff;\n\t\txfs_iext_update_extent(ip, state, icur, &got);\n\n\t\tnew.br_startoff = del_endoff;\n\t\tnew.br_blockcount = got_endoff - del_endoff;\n\t\tnew.br_state = got.br_state;\n\t\tnew.br_startblock = del_endblock;\n\n\t\tflags |= XFS_ILOG_CORE;\n\t\tif (cur) {\n\t\t\terror = xfs_bmbt_update(cur, &got);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tcur->bc_rec.b = new;\n\t\t\terror = xfs_btree_insert(cur, &i);\n\t\t\tif (error && error != -ENOSPC)\n\t\t\t\tgoto done;\n\t\t\t \n\t\t\tif (error == -ENOSPC) {\n\t\t\t\t \n\t\t\t\terror = xfs_bmbt_lookup_eq(cur, &got, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto done;\n\t\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\terror = xfs_bmbt_update(cur, &old);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto done;\n\t\t\t\t \n\t\t\t\txfs_iext_update_extent(ip, state, icur, &old);\n\t\t\t\tflags = 0;\n\t\t\t\terror = -ENOSPC;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else\n\t\t\tflags |= xfs_ilog_fext(whichfork);\n\n\t\tifp->if_nextents++;\n\t\txfs_iext_next(ifp, icur);\n\t\txfs_iext_insert(ip, icur, &new, state);\n\t\tbreak;\n\t}\n\n\t \n\txfs_rmap_unmap_extent(tp, ip, whichfork, del);\n\n\t \n\tif (do_fx && !(bflags & XFS_BMAPI_REMAP)) {\n\t\tif (xfs_is_reflink_inode(ip) && whichfork == XFS_DATA_FORK) {\n\t\t\txfs_refcount_decrease_extent(tp, del);\n\t\t} else {\n\t\t\terror = __xfs_free_extent_later(tp, del->br_startblock,\n\t\t\t\t\tdel->br_blockcount, NULL,\n\t\t\t\t\tXFS_AG_RESV_NONE,\n\t\t\t\t\t((bflags & XFS_BMAPI_NODISCARD) ||\n\t\t\t\t\tdel->br_state == XFS_EXT_UNWRITTEN));\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tif (nblks)\n\t\tip->i_nblocks -= nblks;\n\t \n\tif (qfield && !(bflags & XFS_BMAPI_REMAP))\n\t\txfs_trans_mod_dquot_byino(tp, ip, qfield, (long)-nblks);\n\ndone:\n\t*logflagsp = flags;\n\treturn error;\n}\n\n \nint\t\t\t\t\t\t \n__xfs_bunmapi(\n\tstruct xfs_trans\t*tp,\t\t \n\tstruct xfs_inode\t*ip,\t\t \n\txfs_fileoff_t\t\tstart,\t\t \n\txfs_filblks_t\t\t*rlen,\t\t \n\tuint32_t\t\tflags,\t\t \n\txfs_extnum_t\t\tnexts)\t\t \n{\n\tstruct xfs_btree_cur\t*cur;\t\t \n\tstruct xfs_bmbt_irec\tdel;\t\t \n\tint\t\t\terror;\t\t \n\txfs_extnum_t\t\textno;\t\t \n\tstruct xfs_bmbt_irec\tgot;\t\t \n\tstruct xfs_ifork\t*ifp;\t\t \n\tint\t\t\tisrt;\t\t \n\tint\t\t\tlogflags;\t \n\txfs_extlen_t\t\tmod;\t\t \n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\ttmp_logflags;\t \n\tint\t\t\twasdel;\t\t \n\tint\t\t\twhichfork;\t \n\txfs_fsblock_t\t\tsum;\n\txfs_filblks_t\t\tlen = *rlen;\t \n\txfs_fileoff_t\t\tend;\n\tstruct xfs_iext_cursor\ticur;\n\tbool\t\t\tdone = false;\n\n\ttrace_xfs_bunmap(ip, start, len, flags, _RET_IP_);\n\n\twhichfork = xfs_bmapi_whichfork(flags);\n\tASSERT(whichfork != XFS_COW_FORK);\n\tifp = xfs_ifork_ptr(ip, whichfork);\n\tif (XFS_IS_CORRUPT(mp, !xfs_ifork_has_extents(ifp)))\n\t\treturn -EFSCORRUPTED;\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(len > 0);\n\tASSERT(nexts >= 0);\n\n\terror = xfs_iread_extents(tp, ip, whichfork);\n\tif (error)\n\t\treturn error;\n\n\tif (xfs_iext_count(ifp) == 0) {\n\t\t*rlen = 0;\n\t\treturn 0;\n\t}\n\tXFS_STATS_INC(mp, xs_blk_unmap);\n\tisrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);\n\tend = start + len;\n\n\tif (!xfs_iext_lookup_extent_before(ip, ifp, &end, &icur, &got)) {\n\t\t*rlen = 0;\n\t\treturn 0;\n\t}\n\tend--;\n\n\tlogflags = 0;\n\tif (ifp->if_format == XFS_DINODE_FMT_BTREE) {\n\t\tASSERT(ifp->if_format == XFS_DINODE_FMT_BTREE);\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_ino.flags = 0;\n\t} else\n\t\tcur = NULL;\n\n\tif (isrt) {\n\t\t \n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL|XFS_ILOCK_RTBITMAP);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_ilock(mp->m_rsumip, XFS_ILOCK_EXCL|XFS_ILOCK_RTSUM);\n\t\txfs_trans_ijoin(tp, mp->m_rsumip, XFS_ILOCK_EXCL);\n\t}\n\n\textno = 0;\n\twhile (end != (xfs_fileoff_t)-1 && end >= start &&\n\t       (nexts == 0 || extno < nexts)) {\n\t\t \n\t\tif (got.br_startoff > end &&\n\t\t    !xfs_iext_prev_extent(ifp, &icur, &got)) {\n\t\t\tdone = true;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tend = XFS_FILEOFF_MIN(end,\n\t\t\tgot.br_startoff + got.br_blockcount - 1);\n\t\tif (end < start)\n\t\t\tbreak;\n\t\t \n\t\tdel = got;\n\t\twasdel = isnullstartblock(del.br_startblock);\n\n\t\tif (got.br_startoff < start) {\n\t\t\tdel.br_startoff = start;\n\t\t\tdel.br_blockcount -= start - got.br_startoff;\n\t\t\tif (!wasdel)\n\t\t\t\tdel.br_startblock += start - got.br_startoff;\n\t\t}\n\t\tif (del.br_startoff + del.br_blockcount > end + 1)\n\t\t\tdel.br_blockcount = end + 1 - del.br_startoff;\n\n\t\tif (!isrt)\n\t\t\tgoto delete;\n\n\t\tsum = del.br_startblock + del.br_blockcount;\n\t\tdiv_u64_rem(sum, mp->m_sb.sb_rextsize, &mod);\n\t\tif (mod) {\n\t\t\t \n\t\t\tif (del.br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\t \n\t\t\t\tASSERT(end >= mod);\n\t\t\t\tend -= mod > del.br_blockcount ?\n\t\t\t\t\tdel.br_blockcount : mod;\n\t\t\t\tif (end < got.br_startoff &&\n\t\t\t\t    !xfs_iext_prev_extent(ifp, &icur, &got)) {\n\t\t\t\t\tdone = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\tASSERT(tp->t_blk_res > 0);\n\t\t\t \n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_startoff += del.br_blockcount - mod;\n\t\t\t\tdel.br_startblock += del.br_blockcount - mod;\n\t\t\t\tdel.br_blockcount = mod;\n\t\t\t}\n\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp, ip,\n\t\t\t\t\twhichfork, &icur, &cur, &del,\n\t\t\t\t\t&logflags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tgoto nodelete;\n\t\t}\n\t\tdiv_u64_rem(del.br_startblock, mp->m_sb.sb_rextsize, &mod);\n\t\tif (mod) {\n\t\t\txfs_extlen_t off = mp->m_sb.sb_rextsize - mod;\n\n\t\t\t \n\t\t\tif (del.br_blockcount > off) {\n\t\t\t\tdel.br_blockcount -= off;\n\t\t\t\tdel.br_startoff += off;\n\t\t\t\tdel.br_startblock += off;\n\t\t\t} else if (del.br_startoff == start &&\n\t\t\t\t   (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t\t    tp->t_blk_res == 0)) {\n\t\t\t\t \n\t\t\t\tASSERT(end >= del.br_blockcount);\n\t\t\t\tend -= del.br_blockcount;\n\t\t\t\tif (got.br_startoff > end &&\n\t\t\t\t    !xfs_iext_prev_extent(ifp, &icur, &got)) {\n\t\t\t\t\tdone = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (del.br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\tstruct xfs_bmbt_irec\tprev;\n\t\t\t\txfs_fileoff_t\t\tunwrite_start;\n\n\t\t\t\t \n\t\t\t\tif (!xfs_iext_prev_extent(ifp, &icur, &prev))\n\t\t\t\t\tASSERT(0);\n\t\t\t\tASSERT(prev.br_state == XFS_EXT_NORM);\n\t\t\t\tASSERT(!isnullstartblock(prev.br_startblock));\n\t\t\t\tASSERT(del.br_startblock ==\n\t\t\t\t       prev.br_startblock + prev.br_blockcount);\n\t\t\t\tunwrite_start = max3(start,\n\t\t\t\t\t\t     del.br_startoff - mod,\n\t\t\t\t\t\t     prev.br_startoff);\n\t\t\t\tmod = unwrite_start - prev.br_startoff;\n\t\t\t\tprev.br_startoff = unwrite_start;\n\t\t\t\tprev.br_startblock += mod;\n\t\t\t\tprev.br_blockcount -= mod;\n\t\t\t\tprev.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, whichfork, &icur, &cur,\n\t\t\t\t\t\t&prev, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t} else {\n\t\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, whichfork, &icur, &cur,\n\t\t\t\t\t\t&del, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t}\n\t\t}\n\ndelete:\n\t\tif (wasdel) {\n\t\t\terror = xfs_bmap_del_extent_delay(ip, whichfork, &icur,\n\t\t\t\t\t&got, &del);\n\t\t} else {\n\t\t\terror = xfs_bmap_del_extent_real(ip, tp, &icur, cur,\n\t\t\t\t\t&del, &tmp_logflags, whichfork,\n\t\t\t\t\tflags);\n\t\t\tlogflags |= tmp_logflags;\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tend = del.br_startoff - 1;\nnodelete:\n\t\t \n\t\tif (end != (xfs_fileoff_t)-1 && end >= start) {\n\t\t\tif (!xfs_iext_get_extent(ifp, &icur, &got) ||\n\t\t\t    (got.br_startoff > end &&\n\t\t\t     !xfs_iext_prev_extent(ifp, &icur, &got))) {\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\textno++;\n\t\t}\n\t}\n\tif (done || end == (xfs_fileoff_t)-1 || end < start)\n\t\t*rlen = 0;\n\telse\n\t\t*rlen = end - start + 1;\n\n\t \n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, &cur, 0,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t} else {\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, cur, &logflags,\n\t\t\twhichfork);\n\t}\n\nerror0:\n\t \n\tif ((logflags & xfs_ilog_fext(whichfork)) &&\n\t    ifp->if_format != XFS_DINODE_FMT_EXTENTS)\n\t\tlogflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t ifp->if_format != XFS_DINODE_FMT_BTREE)\n\t\tlogflags &= ~xfs_ilog_fbroot(whichfork);\n\t \n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (cur) {\n\t\tif (!error)\n\t\t\tcur->bc_ino.allocated = 0;\n\t\txfs_btree_del_cursor(cur, error);\n\t}\n\treturn error;\n}\n\n \nint\nxfs_bunmapi(\n\txfs_trans_t\t\t*tp,\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tuint32_t\t\tflags,\n\txfs_extnum_t\t\tnexts,\n\tint\t\t\t*done)\n{\n\tint\t\t\terror;\n\n\terror = __xfs_bunmapi(tp, ip, bno, &len, flags, nexts);\n\t*done = (len == 0);\n\treturn error;\n}\n\n \nSTATIC bool\nxfs_bmse_can_merge(\n\tstruct xfs_bmbt_irec\t*left,\t \n\tstruct xfs_bmbt_irec\t*got,\t \n\txfs_fileoff_t\t\tshift)\t \n{\n\txfs_fileoff_t\t\tstartoff;\n\n\tstartoff = got->br_startoff - shift;\n\n\t \n\tif ((left->br_startoff + left->br_blockcount != startoff) ||\n\t    (left->br_startblock + left->br_blockcount != got->br_startblock) ||\n\t    (left->br_state != got->br_state) ||\n\t    (left->br_blockcount + got->br_blockcount > XFS_MAX_BMBT_EXTLEN))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nSTATIC int\nxfs_bmse_merge(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_inode\t\t*ip,\n\tint\t\t\t\twhichfork,\n\txfs_fileoff_t\t\t\tshift,\t\t \n\tstruct xfs_iext_cursor\t\t*icur,\n\tstruct xfs_bmbt_irec\t\t*got,\t\t \n\tstruct xfs_bmbt_irec\t\t*left,\t\t \n\tstruct xfs_btree_cur\t\t*cur,\n\tint\t\t\t\t*logflags)\t \n{\n\tstruct xfs_ifork\t\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tstruct xfs_bmbt_irec\t\tnew;\n\txfs_filblks_t\t\t\tblockcount;\n\tint\t\t\t\terror, i;\n\tstruct xfs_mount\t\t*mp = ip->i_mount;\n\n\tblockcount = left->br_blockcount + got->br_blockcount;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(xfs_bmse_can_merge(left, got, shift));\n\n\tnew = *left;\n\tnew.br_blockcount = blockcount;\n\n\t \n\tifp->if_nextents--;\n\t*logflags |= XFS_ILOG_CORE;\n\tif (!cur) {\n\t\t*logflags |= XFS_ILOG_DEXT;\n\t\tgoto done;\n\t}\n\n\t \n\terror = xfs_bmbt_lookup_eq(cur, got, &i);\n\tif (error)\n\t\treturn error;\n\tif (XFS_IS_CORRUPT(mp, i != 1))\n\t\treturn -EFSCORRUPTED;\n\n\terror = xfs_btree_delete(cur, &i);\n\tif (error)\n\t\treturn error;\n\tif (XFS_IS_CORRUPT(mp, i != 1))\n\t\treturn -EFSCORRUPTED;\n\n\t \n\terror = xfs_bmbt_lookup_eq(cur, left, &i);\n\tif (error)\n\t\treturn error;\n\tif (XFS_IS_CORRUPT(mp, i != 1))\n\t\treturn -EFSCORRUPTED;\n\n\terror = xfs_bmbt_update(cur, &new);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = xfs_bmap_btree_to_extents(tp, ip, cur, logflags, whichfork);\n\tif (error)\n\t\treturn error;\n\ndone:\n\txfs_iext_remove(ip, icur, 0);\n\txfs_iext_prev(ifp, icur);\n\txfs_iext_update_extent(ip, xfs_bmap_fork_to_state(whichfork), icur,\n\t\t\t&new);\n\n\t \n\txfs_rmap_unmap_extent(tp, ip, whichfork, got);\n\tmemcpy(&new, got, sizeof(new));\n\tnew.br_startoff = left->br_startoff + left->br_blockcount;\n\txfs_rmap_map_extent(tp, ip, whichfork, &new);\n\treturn 0;\n}\n\nstatic int\nxfs_bmap_shift_update_extent(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tstruct xfs_iext_cursor\t*icur,\n\tstruct xfs_bmbt_irec\t*got,\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*logflags,\n\txfs_fileoff_t\t\tstartoff)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_bmbt_irec\tprev = *got;\n\tint\t\t\terror, i;\n\n\t*logflags |= XFS_ILOG_CORE;\n\n\tgot->br_startoff = startoff;\n\n\tif (cur) {\n\t\terror = xfs_bmbt_lookup_eq(cur, &prev, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1))\n\t\t\treturn -EFSCORRUPTED;\n\n\t\terror = xfs_bmbt_update(cur, got);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\t*logflags |= XFS_ILOG_DEXT;\n\t}\n\n\txfs_iext_update_extent(ip, xfs_bmap_fork_to_state(whichfork), icur,\n\t\t\tgot);\n\n\t \n\txfs_rmap_unmap_extent(tp, ip, whichfork, &prev);\n\txfs_rmap_map_extent(tp, ip, whichfork, got);\n\treturn 0;\n}\n\nint\nxfs_bmap_collapse_extents(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\t*next_fsb,\n\txfs_fileoff_t\t\toffset_shift_fsb,\n\tbool\t\t\t*done)\n{\n\tint\t\t\twhichfork = XFS_DATA_FORK;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur = NULL;\n\tstruct xfs_bmbt_irec\tgot, prev;\n\tstruct xfs_iext_cursor\ticur;\n\txfs_fileoff_t\t\tnew_startoff;\n\tint\t\t\terror = 0;\n\tint\t\t\tlogflags = 0;\n\n\tif (XFS_IS_CORRUPT(mp, !xfs_ifork_has_extents(ifp)) ||\n\t    XFS_TEST_ERROR(false, mp, XFS_ERRTAG_BMAPIFORMAT)) {\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL | XFS_ILOCK_EXCL));\n\n\terror = xfs_iread_extents(tp, ip, whichfork);\n\tif (error)\n\t\treturn error;\n\n\tif (ifp->if_format == XFS_DINODE_FMT_BTREE) {\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_ino.flags = 0;\n\t}\n\n\tif (!xfs_iext_lookup_extent(ip, ifp, *next_fsb, &icur, &got)) {\n\t\t*done = true;\n\t\tgoto del_cursor;\n\t}\n\tif (XFS_IS_CORRUPT(mp, isnullstartblock(got.br_startblock))) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto del_cursor;\n\t}\n\n\tnew_startoff = got.br_startoff - offset_shift_fsb;\n\tif (xfs_iext_peek_prev_extent(ifp, &icur, &prev)) {\n\t\tif (new_startoff < prev.br_startoff + prev.br_blockcount) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto del_cursor;\n\t\t}\n\n\t\tif (xfs_bmse_can_merge(&prev, &got, offset_shift_fsb)) {\n\t\t\terror = xfs_bmse_merge(tp, ip, whichfork,\n\t\t\t\t\toffset_shift_fsb, &icur, &got, &prev,\n\t\t\t\t\tcur, &logflags);\n\t\t\tif (error)\n\t\t\t\tgoto del_cursor;\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tif (got.br_startoff < offset_shift_fsb) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto del_cursor;\n\t\t}\n\t}\n\n\terror = xfs_bmap_shift_update_extent(tp, ip, whichfork, &icur, &got,\n\t\t\tcur, &logflags, new_startoff);\n\tif (error)\n\t\tgoto del_cursor;\n\ndone:\n\tif (!xfs_iext_next_extent(ifp, &icur, &got)) {\n\t\t*done = true;\n\t\tgoto del_cursor;\n\t}\n\n\t*next_fsb = got.br_startoff;\ndel_cursor:\n\tif (cur)\n\t\txfs_btree_del_cursor(cur, error);\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\treturn error;\n}\n\n \nint\nxfs_bmap_can_insert_extents(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\toff,\n\txfs_fileoff_t\t\tshift)\n{\n\tstruct xfs_bmbt_irec\tgot;\n\tint\t\t\tis_empty;\n\tint\t\t\terror = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\n\tif (xfs_is_shutdown(ip->i_mount))\n\t\treturn -EIO;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_bmap_last_extent(NULL, ip, XFS_DATA_FORK, &got, &is_empty);\n\tif (!error && !is_empty && got.br_startoff >= off &&\n\t    ((got.br_startoff + shift) & BMBT_STARTOFF_MASK) < got.br_startoff)\n\t\terror = -EINVAL;\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}\n\nint\nxfs_bmap_insert_extents(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\t*next_fsb,\n\txfs_fileoff_t\t\toffset_shift_fsb,\n\tbool\t\t\t*done,\n\txfs_fileoff_t\t\tstop_fsb)\n{\n\tint\t\t\twhichfork = XFS_DATA_FORK;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur = NULL;\n\tstruct xfs_bmbt_irec\tgot, next;\n\tstruct xfs_iext_cursor\ticur;\n\txfs_fileoff_t\t\tnew_startoff;\n\tint\t\t\terror = 0;\n\tint\t\t\tlogflags = 0;\n\n\tif (XFS_IS_CORRUPT(mp, !xfs_ifork_has_extents(ifp)) ||\n\t    XFS_TEST_ERROR(false, mp, XFS_ERRTAG_BMAPIFORMAT)) {\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL | XFS_ILOCK_EXCL));\n\n\terror = xfs_iread_extents(tp, ip, whichfork);\n\tif (error)\n\t\treturn error;\n\n\tif (ifp->if_format == XFS_DINODE_FMT_BTREE) {\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_ino.flags = 0;\n\t}\n\n\tif (*next_fsb == NULLFSBLOCK) {\n\t\txfs_iext_last(ifp, &icur);\n\t\tif (!xfs_iext_get_extent(ifp, &icur, &got) ||\n\t\t    stop_fsb > got.br_startoff) {\n\t\t\t*done = true;\n\t\t\tgoto del_cursor;\n\t\t}\n\t} else {\n\t\tif (!xfs_iext_lookup_extent(ip, ifp, *next_fsb, &icur, &got)) {\n\t\t\t*done = true;\n\t\t\tgoto del_cursor;\n\t\t}\n\t}\n\tif (XFS_IS_CORRUPT(mp, isnullstartblock(got.br_startblock))) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto del_cursor;\n\t}\n\n\tif (XFS_IS_CORRUPT(mp, stop_fsb > got.br_startoff)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto del_cursor;\n\t}\n\n\tnew_startoff = got.br_startoff + offset_shift_fsb;\n\tif (xfs_iext_peek_next_extent(ifp, &icur, &next)) {\n\t\tif (new_startoff + got.br_blockcount > next.br_startoff) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto del_cursor;\n\t\t}\n\n\t\t \n\t\tif (xfs_bmse_can_merge(&got, &next, offset_shift_fsb))\n\t\t\tWARN_ON_ONCE(1);\n\t}\n\n\terror = xfs_bmap_shift_update_extent(tp, ip, whichfork, &icur, &got,\n\t\t\tcur, &logflags, new_startoff);\n\tif (error)\n\t\tgoto del_cursor;\n\n\tif (!xfs_iext_prev_extent(ifp, &icur, &got) ||\n\t    stop_fsb >= got.br_startoff + got.br_blockcount) {\n\t\t*done = true;\n\t\tgoto del_cursor;\n\t}\n\n\t*next_fsb = got.br_startoff;\ndel_cursor:\n\tif (cur)\n\t\txfs_btree_del_cursor(cur, error);\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\treturn error;\n}\n\n \nint\nxfs_bmap_split_extent(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tsplit_fsb)\n{\n\tint\t\t\t\twhichfork = XFS_DATA_FORK;\n\tstruct xfs_ifork\t\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\tstruct xfs_btree_cur\t\t*cur = NULL;\n\tstruct xfs_bmbt_irec\t\tgot;\n\tstruct xfs_bmbt_irec\t\tnew;  \n\tstruct xfs_mount\t\t*mp = ip->i_mount;\n\txfs_fsblock_t\t\t\tgotblkcnt;  \n\tstruct xfs_iext_cursor\t\ticur;\n\tint\t\t\t\terror = 0;\n\tint\t\t\t\tlogflags = 0;\n\tint\t\t\t\ti = 0;\n\n\tif (XFS_IS_CORRUPT(mp, !xfs_ifork_has_extents(ifp)) ||\n\t    XFS_TEST_ERROR(false, mp, XFS_ERRTAG_BMAPIFORMAT)) {\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\t \n\terror = xfs_iread_extents(tp, ip, whichfork);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (!xfs_iext_lookup_extent(ip, ifp, split_fsb, &icur, &got) ||\n\t    got.br_startoff >= split_fsb)\n\t\treturn 0;\n\n\tgotblkcnt = split_fsb - got.br_startoff;\n\tnew.br_startoff = split_fsb;\n\tnew.br_startblock = got.br_startblock + gotblkcnt;\n\tnew.br_blockcount = got.br_blockcount - gotblkcnt;\n\tnew.br_state = got.br_state;\n\n\tif (ifp->if_format == XFS_DINODE_FMT_BTREE) {\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_ino.flags = 0;\n\t\terror = xfs_bmbt_lookup_eq(cur, &got, &i);\n\t\tif (error)\n\t\t\tgoto del_cursor;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto del_cursor;\n\t\t}\n\t}\n\n\tgot.br_blockcount = gotblkcnt;\n\txfs_iext_update_extent(ip, xfs_bmap_fork_to_state(whichfork), &icur,\n\t\t\t&got);\n\n\tlogflags = XFS_ILOG_CORE;\n\tif (cur) {\n\t\terror = xfs_bmbt_update(cur, &got);\n\t\tif (error)\n\t\t\tgoto del_cursor;\n\t} else\n\t\tlogflags |= XFS_ILOG_DEXT;\n\n\t \n\txfs_iext_next(ifp, &icur);\n\txfs_iext_insert(ip, &icur, &new, 0);\n\tifp->if_nextents++;\n\n\tif (cur) {\n\t\terror = xfs_bmbt_lookup_eq(cur, &new, &i);\n\t\tif (error)\n\t\t\tgoto del_cursor;\n\t\tif (XFS_IS_CORRUPT(mp, i != 0)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto del_cursor;\n\t\t}\n\t\terror = xfs_btree_insert(cur, &i);\n\t\tif (error)\n\t\t\tgoto del_cursor;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto del_cursor;\n\t\t}\n\t}\n\n\t \n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tint tmp_logflags;  \n\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, &cur, 0,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t}\n\ndel_cursor:\n\tif (cur) {\n\t\tcur->bc_ino.allocated = 0;\n\t\txfs_btree_del_cursor(cur, error);\n\t}\n\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\treturn error;\n}\n\n \nstatic bool\nxfs_bmap_is_update_needed(\n\tstruct xfs_bmbt_irec\t*bmap)\n{\n\treturn  bmap->br_startblock != HOLESTARTBLOCK &&\n\t\tbmap->br_startblock != DELAYSTARTBLOCK;\n}\n\n \nstatic int\n__xfs_bmap_add(\n\tstruct xfs_trans\t\t*tp,\n\tenum xfs_bmap_intent_type\ttype,\n\tstruct xfs_inode\t\t*ip,\n\tint\t\t\t\twhichfork,\n\tstruct xfs_bmbt_irec\t\t*bmap)\n{\n\tstruct xfs_bmap_intent\t\t*bi;\n\n\ttrace_xfs_bmap_defer(tp->t_mountp,\n\t\t\tXFS_FSB_TO_AGNO(tp->t_mountp, bmap->br_startblock),\n\t\t\ttype,\n\t\t\tXFS_FSB_TO_AGBNO(tp->t_mountp, bmap->br_startblock),\n\t\t\tip->i_ino, whichfork,\n\t\t\tbmap->br_startoff,\n\t\t\tbmap->br_blockcount,\n\t\t\tbmap->br_state);\n\n\tbi = kmem_cache_alloc(xfs_bmap_intent_cache, GFP_NOFS | __GFP_NOFAIL);\n\tINIT_LIST_HEAD(&bi->bi_list);\n\tbi->bi_type = type;\n\tbi->bi_owner = ip;\n\tbi->bi_whichfork = whichfork;\n\tbi->bi_bmap = *bmap;\n\n\txfs_bmap_update_get_group(tp->t_mountp, bi);\n\txfs_defer_add(tp, XFS_DEFER_OPS_TYPE_BMAP, &bi->bi_list);\n\treturn 0;\n}\n\n \nvoid\nxfs_bmap_map_extent(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_bmbt_irec\t*PREV)\n{\n\tif (!xfs_bmap_is_update_needed(PREV))\n\t\treturn;\n\n\t__xfs_bmap_add(tp, XFS_BMAP_MAP, ip, XFS_DATA_FORK, PREV);\n}\n\n \nvoid\nxfs_bmap_unmap_extent(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_bmbt_irec\t*PREV)\n{\n\tif (!xfs_bmap_is_update_needed(PREV))\n\t\treturn;\n\n\t__xfs_bmap_add(tp, XFS_BMAP_UNMAP, ip, XFS_DATA_FORK, PREV);\n}\n\n \nint\nxfs_bmap_finish_one(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_bmap_intent\t\t*bi)\n{\n\tstruct xfs_bmbt_irec\t\t*bmap = &bi->bi_bmap;\n\tint\t\t\t\terror = 0;\n\n\tASSERT(tp->t_highest_agno == NULLAGNUMBER);\n\n\ttrace_xfs_bmap_deferred(tp->t_mountp,\n\t\t\tXFS_FSB_TO_AGNO(tp->t_mountp, bmap->br_startblock),\n\t\t\tbi->bi_type,\n\t\t\tXFS_FSB_TO_AGBNO(tp->t_mountp, bmap->br_startblock),\n\t\t\tbi->bi_owner->i_ino, bi->bi_whichfork,\n\t\t\tbmap->br_startoff, bmap->br_blockcount,\n\t\t\tbmap->br_state);\n\n\tif (WARN_ON_ONCE(bi->bi_whichfork != XFS_DATA_FORK))\n\t\treturn -EFSCORRUPTED;\n\n\tif (XFS_TEST_ERROR(false, tp->t_mountp,\n\t\t\tXFS_ERRTAG_BMAP_FINISH_ONE))\n\t\treturn -EIO;\n\n\tswitch (bi->bi_type) {\n\tcase XFS_BMAP_MAP:\n\t\terror = xfs_bmapi_remap(tp, bi->bi_owner, bmap->br_startoff,\n\t\t\t\tbmap->br_blockcount, bmap->br_startblock, 0);\n\t\tbmap->br_blockcount = 0;\n\t\tbreak;\n\tcase XFS_BMAP_UNMAP:\n\t\terror = __xfs_bunmapi(tp, bi->bi_owner, bmap->br_startoff,\n\t\t\t\t&bmap->br_blockcount, XFS_BMAPI_REMAP, 1);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t}\n\n\treturn error;\n}\n\n \nxfs_failaddr_t\nxfs_bmap_validate_extent(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tstruct xfs_bmbt_irec\t*irec)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!xfs_verify_fileext(mp, irec->br_startoff, irec->br_blockcount))\n\t\treturn __this_address;\n\n\tif (XFS_IS_REALTIME_INODE(ip) && whichfork == XFS_DATA_FORK) {\n\t\tif (!xfs_verify_rtext(mp, irec->br_startblock,\n\t\t\t\t\t  irec->br_blockcount))\n\t\t\treturn __this_address;\n\t} else {\n\t\tif (!xfs_verify_fsbext(mp, irec->br_startblock,\n\t\t\t\t\t   irec->br_blockcount))\n\t\t\treturn __this_address;\n\t}\n\tif (irec->br_state != XFS_EXT_NORM && whichfork != XFS_DATA_FORK)\n\t\treturn __this_address;\n\treturn NULL;\n}\n\nint __init\nxfs_bmap_intent_init_cache(void)\n{\n\txfs_bmap_intent_cache = kmem_cache_create(\"xfs_bmap_intent\",\n\t\t\tsizeof(struct xfs_bmap_intent),\n\t\t\t0, 0, NULL);\n\n\treturn xfs_bmap_intent_cache != NULL ? 0 : -ENOMEM;\n}\n\nvoid\nxfs_bmap_intent_destroy_cache(void)\n{\n\tkmem_cache_destroy(xfs_bmap_intent_cache);\n\txfs_bmap_intent_cache = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}