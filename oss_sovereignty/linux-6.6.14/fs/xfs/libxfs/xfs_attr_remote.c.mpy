{
  "module_name": "xfs_attr_remote.c",
  "hash_id": "f87b4c7cf99ff1b3b6261d7ffcb9f18196b0a5bf1d2efa08b29d5bba1f09844e",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_attr_remote.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n\n#define ATTR_RMTVALUE_MAPSIZE\t1\t \n\n \n\n \nint\nxfs_attr3_rmt_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tattrlen)\n{\n\tif (xfs_has_crc(mp)) {\n\t\tint buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\t\treturn (attrlen + buflen - 1) / buflen;\n\t}\n\treturn XFS_B_TO_FSB(mp, attrlen);\n}\n\n \nstatic xfs_failaddr_t\nxfs_attr3_rmt_hdr_ok(\n\tvoid\t\t\t*ptr,\n\txfs_ino_t\t\tino,\n\tuint32_t\t\toffset,\n\tuint32_t\t\tsize,\n\txfs_daddr_t\t\tbno)\n{\n\tstruct xfs_attr3_rmt_hdr *rmt = ptr;\n\n\tif (bno != be64_to_cpu(rmt->rm_blkno))\n\t\treturn __this_address;\n\tif (offset != be32_to_cpu(rmt->rm_offset))\n\t\treturn __this_address;\n\tif (size != be32_to_cpu(rmt->rm_bytes))\n\t\treturn __this_address;\n\tif (ino != be64_to_cpu(rmt->rm_owner))\n\t\treturn __this_address;\n\n\t \n\treturn NULL;\n}\n\nstatic xfs_failaddr_t\nxfs_attr3_rmt_verify(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tvoid\t\t\t*ptr,\n\tint\t\t\tfsbsize,\n\txfs_daddr_t\t\tbno)\n{\n\tstruct xfs_attr3_rmt_hdr *rmt = ptr;\n\n\tif (!xfs_verify_magic(bp, rmt->rm_magic))\n\t\treturn __this_address;\n\tif (!uuid_equal(&rmt->rm_uuid, &mp->m_sb.sb_meta_uuid))\n\t\treturn __this_address;\n\tif (be64_to_cpu(rmt->rm_blkno) != bno)\n\t\treturn __this_address;\n\tif (be32_to_cpu(rmt->rm_bytes) > fsbsize - sizeof(*rmt))\n\t\treturn __this_address;\n\tif (be32_to_cpu(rmt->rm_offset) +\n\t\t\t\tbe32_to_cpu(rmt->rm_bytes) > XFS_XATTR_SIZE_MAX)\n\t\treturn __this_address;\n\tif (rmt->rm_owner == 0)\n\t\treturn __this_address;\n\n\treturn NULL;\n}\n\nstatic int\n__xfs_attr3_rmt_read_verify(\n\tstruct xfs_buf\t*bp,\n\tbool\t\tcheck_crc,\n\txfs_failaddr_t\t*failaddr)\n{\n\tstruct xfs_mount *mp = bp->b_mount;\n\tchar\t\t*ptr;\n\tint\t\tlen;\n\txfs_daddr_t\tbno;\n\tint\t\tblksize = mp->m_attr_geo->blksize;\n\n\t \n\tif (!xfs_has_crc(mp))\n\t\treturn 0;\n\n\tptr = bp->b_addr;\n\tbno = xfs_buf_daddr(bp);\n\tlen = BBTOB(bp->b_length);\n\tASSERT(len >= blksize);\n\n\twhile (len > 0) {\n\t\tif (check_crc &&\n\t\t    !xfs_verify_cksum(ptr, blksize, XFS_ATTR3_RMT_CRC_OFF)) {\n\t\t\t*failaddr = __this_address;\n\t\t\treturn -EFSBADCRC;\n\t\t}\n\t\t*failaddr = xfs_attr3_rmt_verify(mp, bp, ptr, blksize, bno);\n\t\tif (*failaddr)\n\t\t\treturn -EFSCORRUPTED;\n\t\tlen -= blksize;\n\t\tptr += blksize;\n\t\tbno += BTOBB(blksize);\n\t}\n\n\tif (len != 0) {\n\t\t*failaddr = __this_address;\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nxfs_attr3_rmt_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\txfs_failaddr_t\tfa;\n\tint\t\terror;\n\n\terror = __xfs_attr3_rmt_read_verify(bp, true, &fa);\n\tif (error)\n\t\txfs_verifier_error(bp, error, fa);\n}\n\nstatic xfs_failaddr_t\nxfs_attr3_rmt_verify_struct(\n\tstruct xfs_buf\t*bp)\n{\n\txfs_failaddr_t\tfa;\n\tint\t\terror;\n\n\terror = __xfs_attr3_rmt_read_verify(bp, false, &fa);\n\treturn error ? fa : NULL;\n}\n\nstatic void\nxfs_attr3_rmt_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_mount;\n\txfs_failaddr_t\tfa;\n\tint\t\tblksize = mp->m_attr_geo->blksize;\n\tchar\t\t*ptr;\n\tint\t\tlen;\n\txfs_daddr_t\tbno;\n\n\t \n\tif (!xfs_has_crc(mp))\n\t\treturn;\n\n\tptr = bp->b_addr;\n\tbno = xfs_buf_daddr(bp);\n\tlen = BBTOB(bp->b_length);\n\tASSERT(len >= blksize);\n\n\twhile (len > 0) {\n\t\tstruct xfs_attr3_rmt_hdr *rmt = (struct xfs_attr3_rmt_hdr *)ptr;\n\n\t\tfa = xfs_attr3_rmt_verify(mp, bp, ptr, blksize, bno);\n\t\tif (fa) {\n\t\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (rmt->rm_lsn != cpu_to_be64(NULLCOMMITLSN)) {\n\t\t\txfs_verifier_error(bp, -EFSCORRUPTED, __this_address);\n\t\t\treturn;\n\t\t}\n\t\txfs_update_cksum(ptr, blksize, XFS_ATTR3_RMT_CRC_OFF);\n\n\t\tlen -= blksize;\n\t\tptr += blksize;\n\t\tbno += BTOBB(blksize);\n\t}\n\n\tif (len != 0)\n\t\txfs_verifier_error(bp, -EFSCORRUPTED, __this_address);\n}\n\nconst struct xfs_buf_ops xfs_attr3_rmt_buf_ops = {\n\t.name = \"xfs_attr3_rmt\",\n\t.magic = { 0, cpu_to_be32(XFS_ATTR3_RMT_MAGIC) },\n\t.verify_read = xfs_attr3_rmt_read_verify,\n\t.verify_write = xfs_attr3_rmt_write_verify,\n\t.verify_struct = xfs_attr3_rmt_verify_struct,\n};\n\nSTATIC int\nxfs_attr3_rmt_hdr_set(\n\tstruct xfs_mount\t*mp,\n\tvoid\t\t\t*ptr,\n\txfs_ino_t\t\tino,\n\tuint32_t\t\toffset,\n\tuint32_t\t\tsize,\n\txfs_daddr_t\t\tbno)\n{\n\tstruct xfs_attr3_rmt_hdr *rmt = ptr;\n\n\tif (!xfs_has_crc(mp))\n\t\treturn 0;\n\n\trmt->rm_magic = cpu_to_be32(XFS_ATTR3_RMT_MAGIC);\n\trmt->rm_offset = cpu_to_be32(offset);\n\trmt->rm_bytes = cpu_to_be32(size);\n\tuuid_copy(&rmt->rm_uuid, &mp->m_sb.sb_meta_uuid);\n\trmt->rm_owner = cpu_to_be64(ino);\n\trmt->rm_blkno = cpu_to_be64(bno);\n\n\t \n\trmt->rm_lsn = cpu_to_be64(NULLCOMMITLSN);\n\n\treturn sizeof(struct xfs_attr3_rmt_hdr);\n}\n\n \nSTATIC int\nxfs_attr_rmtval_copyout(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp,\n\txfs_ino_t\tino,\n\tint\t\t*offset,\n\tint\t\t*valuelen,\n\tuint8_t\t\t**dst)\n{\n\tchar\t\t*src = bp->b_addr;\n\txfs_daddr_t\tbno = xfs_buf_daddr(bp);\n\tint\t\tlen = BBTOB(bp->b_length);\n\tint\t\tblksize = mp->m_attr_geo->blksize;\n\n\tASSERT(len >= blksize);\n\n\twhile (len > 0 && *valuelen > 0) {\n\t\tint hdr_size = 0;\n\t\tint byte_cnt = XFS_ATTR3_RMT_BUF_SPACE(mp, blksize);\n\n\t\tbyte_cnt = min(*valuelen, byte_cnt);\n\n\t\tif (xfs_has_crc(mp)) {\n\t\t\tif (xfs_attr3_rmt_hdr_ok(src, ino, *offset,\n\t\t\t\t\t\t  byte_cnt, bno)) {\n\t\t\t\txfs_alert(mp,\n\"remote attribute header mismatch bno/off/len/owner (0x%llx/0x%x/Ox%x/0x%llx)\",\n\t\t\t\t\tbno, *offset, byte_cnt, ino);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\t\t\thdr_size = sizeof(struct xfs_attr3_rmt_hdr);\n\t\t}\n\n\t\tmemcpy(*dst, src + hdr_size, byte_cnt);\n\n\t\t \n\t\tlen -= blksize;\n\t\tsrc += blksize;\n\t\tbno += BTOBB(blksize);\n\n\t\t \n\t\t*valuelen -= byte_cnt;\n\t\t*dst += byte_cnt;\n\t\t*offset += byte_cnt;\n\t}\n\treturn 0;\n}\n\nSTATIC void\nxfs_attr_rmtval_copyin(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp,\n\txfs_ino_t\tino,\n\tint\t\t*offset,\n\tint\t\t*valuelen,\n\tuint8_t\t\t**src)\n{\n\tchar\t\t*dst = bp->b_addr;\n\txfs_daddr_t\tbno = xfs_buf_daddr(bp);\n\tint\t\tlen = BBTOB(bp->b_length);\n\tint\t\tblksize = mp->m_attr_geo->blksize;\n\n\tASSERT(len >= blksize);\n\n\twhile (len > 0 && *valuelen > 0) {\n\t\tint hdr_size;\n\t\tint byte_cnt = XFS_ATTR3_RMT_BUF_SPACE(mp, blksize);\n\n\t\tbyte_cnt = min(*valuelen, byte_cnt);\n\t\thdr_size = xfs_attr3_rmt_hdr_set(mp, dst, ino, *offset,\n\t\t\t\t\t\t byte_cnt, bno);\n\n\t\tmemcpy(dst + hdr_size, *src, byte_cnt);\n\n\t\t \n\t\tif (byte_cnt + hdr_size < blksize) {\n\t\t\tASSERT(*valuelen - byte_cnt == 0);\n\t\t\tASSERT(len == blksize);\n\t\t\tmemset(dst + hdr_size + byte_cnt, 0,\n\t\t\t\t\tblksize - hdr_size - byte_cnt);\n\t\t}\n\n\t\t \n\t\tlen -= blksize;\n\t\tdst += blksize;\n\t\tbno += BTOBB(blksize);\n\n\t\t \n\t\t*valuelen -= byte_cnt;\n\t\t*src += byte_cnt;\n\t\t*offset += byte_cnt;\n\t}\n}\n\n \nint\nxfs_attr_rmtval_get(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_bmbt_irec\tmap[ATTR_RMTVALUE_MAPSIZE];\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tlblkno = args->rmtblkno;\n\tuint8_t\t\t\t*dst = args->value;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\tblkcnt = args->rmtblkcnt;\n\tint\t\t\ti;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_get(args);\n\n\tASSERT(args->valuelen != 0);\n\tASSERT(args->rmtvaluelen == args->valuelen);\n\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tnmap = ATTR_RMTVALUE_MAPSIZE;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap >= 1);\n\n\t\tfor (i = 0; (i < nmap) && (valuelen > 0); i++) {\n\t\t\txfs_daddr_t\tdblkno;\n\t\t\tint\t\tdblkcnt;\n\n\t\t\tASSERT((map[i].br_startblock != DELAYSTARTBLOCK) &&\n\t\t\t       (map[i].br_startblock != HOLESTARTBLOCK));\n\t\t\tdblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\terror = xfs_buf_read(mp->m_ddev_targp, dblkno, dblkcnt,\n\t\t\t\t\t0, &bp, &xfs_attr3_rmt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\terror = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino,\n\t\t\t\t\t\t\t&offset, &valuelen,\n\t\t\t\t\t\t\t&dst);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t \n\t\t\tlblkno += map[i].br_blockcount;\n\t\t\tblkcnt -= map[i].br_blockcount;\n\t\t}\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}\n\n \nint\nxfs_attr_rmt_find_hole(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\terror;\n\tint\t\t\tblkcnt;\n\txfs_fileoff_t\t\tlfileoff = 0;\n\n\t \n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->rmtvaluelen);\n\terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n\t\t\t\t\t\t   XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\n\targs->rmtblkno = (xfs_dablk_t)lfileoff;\n\targs->rmtblkcnt = blkcnt;\n\n\treturn 0;\n}\n\nint\nxfs_attr_rmtval_set_value(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_bmbt_irec\tmap;\n\txfs_dablk_t\t\tlblkno;\n\tuint8_t\t\t\t*src = args->value;\n\tint\t\t\tblkcnt;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\toffset = 0;\n\n\t \n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tstruct xfs_buf\t*bp;\n\t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n\n\t\tASSERT(blkcnt > 0);\n\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\terror = xfs_buf_get(mp->m_ddev_targp, dblkno, dblkcnt, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\n\t\txfs_attr_rmtval_copyin(mp, bp, args->dp->i_ino, &offset,\n\t\t\t\t       &valuelen, &src);\n\n\t\terror = xfs_bwrite(bp);\t \n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\n\t\t \n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}\n\n \nint\nxfs_attr_rmtval_stale(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_bmbt_irec\t*map,\n\txfs_buf_flags_t\t\tincore_flags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (XFS_IS_CORRUPT(mp, map->br_startblock == DELAYSTARTBLOCK) ||\n\t    XFS_IS_CORRUPT(mp, map->br_startblock == HOLESTARTBLOCK))\n\t\treturn -EFSCORRUPTED;\n\n\terror = xfs_buf_incore(mp->m_ddev_targp,\n\t\t\tXFS_FSB_TO_DADDR(mp, map->br_startblock),\n\t\t\tXFS_FSB_TO_BB(mp, map->br_blockcount),\n\t\t\tincore_flags, &bp);\n\tif (error) {\n\t\tif (error == -ENOENT)\n\t\t\treturn 0;\n\t\treturn error;\n\t}\n\n\txfs_buf_stale(bp);\n\txfs_buf_relse(bp);\n\treturn 0;\n}\n\n \nint\nxfs_attr_rmtval_find_space(\n\tstruct xfs_attr_intent\t\t*attr)\n{\n\tstruct xfs_da_args\t\t*args = attr->xattri_da_args;\n\tstruct xfs_bmbt_irec\t\t*map = &attr->xattri_map;\n\tint\t\t\t\terror;\n\n\tattr->xattri_lblkno = 0;\n\tattr->xattri_blkcnt = 0;\n\targs->rmtblkcnt = 0;\n\targs->rmtblkno = 0;\n\tmemset(map, 0, sizeof(struct xfs_bmbt_irec));\n\n\terror = xfs_attr_rmt_find_hole(args);\n\tif (error)\n\t\treturn error;\n\n\tattr->xattri_blkcnt = args->rmtblkcnt;\n\tattr->xattri_lblkno = args->rmtblkno;\n\n\treturn 0;\n}\n\n \nint\nxfs_attr_rmtval_set_blk(\n\tstruct xfs_attr_intent\t\t*attr)\n{\n\tstruct xfs_da_args\t\t*args = attr->xattri_da_args;\n\tstruct xfs_inode\t\t*dp = args->dp;\n\tstruct xfs_bmbt_irec\t\t*map = &attr->xattri_map;\n\tint nmap;\n\tint error;\n\n\tnmap = 1;\n\terror = xfs_bmapi_write(args->trans, dp,\n\t\t\t(xfs_fileoff_t)attr->xattri_lblkno,\n\t\t\tattr->xattri_blkcnt, XFS_BMAPI_ATTRFORK, args->total,\n\t\t\tmap, &nmap);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nmap == 1);\n\tASSERT((map->br_startblock != DELAYSTARTBLOCK) &&\n\t       (map->br_startblock != HOLESTARTBLOCK));\n\n\t \n\tattr->xattri_lblkno += map->br_blockcount;\n\tattr->xattri_blkcnt -= map->br_blockcount;\n\n\treturn 0;\n}\n\n \nint\nxfs_attr_rmtval_invalidate(\n\tstruct xfs_da_args\t*args)\n{\n\txfs_dablk_t\t\tlblkno;\n\tint\t\t\tblkcnt;\n\tint\t\t\terror;\n\n\t \n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\twhile (blkcnt > 0) {\n\t\tstruct xfs_bmbt_irec\tmap;\n\t\tint\t\t\tnmap;\n\n\t\t \n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap, XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (XFS_IS_CORRUPT(args->dp->i_mount, nmap != 1))\n\t\t\treturn -EFSCORRUPTED;\n\t\terror = xfs_attr_rmtval_stale(args->dp, &map, XBF_TRYLOCK);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\treturn 0;\n}\n\n \nint\nxfs_attr_rmtval_remove(\n\tstruct xfs_attr_intent\t\t*attr)\n{\n\tstruct xfs_da_args\t\t*args = attr->xattri_da_args;\n\tint\t\t\t\terror, done;\n\n\t \n\terror = xfs_bunmapi(args->trans, args->dp, args->rmtblkno,\n\t\t\t    args->rmtblkcnt, XFS_BMAPI_ATTRFORK, 1, &done);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (!done) {\n\t\ttrace_xfs_attr_rmtval_remove_return(attr->xattri_dela_state,\n\t\t\t\t\t\t    args->dp);\n\t\treturn -EAGAIN;\n\t}\n\n\targs->rmtblkno = 0;\n\targs->rmtblkcnt = 0;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}