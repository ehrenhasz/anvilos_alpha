{
  "module_name": "xfs_alloc.c",
  "hash_id": "8f12aa7b8621262e7e9ad56365b436af0a1f692ea3372729033ee7e046f1e108",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_alloc.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_errortag.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_log.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_ag_resv.h\"\n#include \"xfs_bmap.h\"\n\nstruct kmem_cache\t*xfs_extfree_item_cache;\n\nstruct workqueue_struct *xfs_alloc_wq;\n\n#define XFS_ABSDIFF(a,b)\t(((a) <= (b)) ? ((b) - (a)) : ((a) - (b)))\n\n#define\tXFSA_FIXUP_BNO_OK\t1\n#define\tXFSA_FIXUP_CNT_OK\t2\n\n \nunsigned int\nxfs_agfl_size(\n\tstruct xfs_mount\t*mp)\n{\n\tunsigned int\t\tsize = mp->m_sb.sb_sectsize;\n\n\tif (xfs_has_crc(mp))\n\t\tsize -= sizeof(struct xfs_agfl);\n\n\treturn size / sizeof(xfs_agblock_t);\n}\n\nunsigned int\nxfs_refc_block(\n\tstruct xfs_mount\t*mp)\n{\n\tif (xfs_has_rmapbt(mp))\n\t\treturn XFS_RMAP_BLOCK(mp) + 1;\n\tif (xfs_has_finobt(mp))\n\t\treturn XFS_FIBT_BLOCK(mp) + 1;\n\treturn XFS_IBT_BLOCK(mp) + 1;\n}\n\nxfs_extlen_t\nxfs_prealloc_blocks(\n\tstruct xfs_mount\t*mp)\n{\n\tif (xfs_has_reflink(mp))\n\t\treturn xfs_refc_block(mp) + 1;\n\tif (xfs_has_rmapbt(mp))\n\t\treturn XFS_RMAP_BLOCK(mp) + 1;\n\tif (xfs_has_finobt(mp))\n\t\treturn XFS_FIBT_BLOCK(mp) + 1;\n\treturn XFS_IBT_BLOCK(mp) + 1;\n}\n\n \n#define XFS_ALLOCBT_AGFL_RESERVE\t4\n\n \nunsigned int\nxfs_alloc_set_aside(\n\tstruct xfs_mount\t*mp)\n{\n\treturn mp->m_sb.sb_agcount * (XFS_ALLOCBT_AGFL_RESERVE + 4);\n}\n\n \nunsigned int\nxfs_alloc_ag_max_usable(\n\tstruct xfs_mount\t*mp)\n{\n\tunsigned int\t\tblocks;\n\n\tblocks = XFS_BB_TO_FSB(mp, XFS_FSS_TO_BB(mp, 4));  \n\tblocks += XFS_ALLOCBT_AGFL_RESERVE;\n\tblocks += 3;\t\t\t \n\tif (xfs_has_finobt(mp))\n\t\tblocks++;\t\t \n\tif (xfs_has_rmapbt(mp))\n\t\tblocks++;\t\t \n\tif (xfs_has_reflink(mp))\n\t\tblocks++;\t\t \n\n\treturn mp->m_sb.sb_agblocks - blocks;\n}\n\n \nSTATIC int\t\t\t\t \nxfs_alloc_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\t \n\txfs_agblock_t\t\tbno,\t \n\txfs_extlen_t\t\tlen,\t \n\tint\t\t\t*stat)\t \n{\n\tint\t\t\terror;\n\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\terror = xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n\tcur->bc_ag.abt.active = (*stat == 1);\n\treturn error;\n}\n\n \nint\t\t\t\t \nxfs_alloc_lookup_ge(\n\tstruct xfs_btree_cur\t*cur,\t \n\txfs_agblock_t\t\tbno,\t \n\txfs_extlen_t\t\tlen,\t \n\tint\t\t\t*stat)\t \n{\n\tint\t\t\terror;\n\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\terror = xfs_btree_lookup(cur, XFS_LOOKUP_GE, stat);\n\tcur->bc_ag.abt.active = (*stat == 1);\n\treturn error;\n}\n\n \nint\t\t\t\t\t \nxfs_alloc_lookup_le(\n\tstruct xfs_btree_cur\t*cur,\t \n\txfs_agblock_t\t\tbno,\t \n\txfs_extlen_t\t\tlen,\t \n\tint\t\t\t*stat)\t \n{\n\tint\t\t\terror;\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\terror = xfs_btree_lookup(cur, XFS_LOOKUP_LE, stat);\n\tcur->bc_ag.abt.active = (*stat == 1);\n\treturn error;\n}\n\nstatic inline bool\nxfs_alloc_cur_active(\n\tstruct xfs_btree_cur\t*cur)\n{\n\treturn cur && cur->bc_ag.abt.active;\n}\n\n \nSTATIC int\t\t\t\t \nxfs_alloc_update(\n\tstruct xfs_btree_cur\t*cur,\t \n\txfs_agblock_t\t\tbno,\t \n\txfs_extlen_t\t\tlen)\t \n{\n\tunion xfs_btree_rec\trec;\n\n\trec.alloc.ar_startblock = cpu_to_be32(bno);\n\trec.alloc.ar_blockcount = cpu_to_be32(len);\n\treturn xfs_btree_update(cur, &rec);\n}\n\n \nvoid\nxfs_alloc_btrec_to_irec(\n\tconst union xfs_btree_rec\t*rec,\n\tstruct xfs_alloc_rec_incore\t*irec)\n{\n\tirec->ar_startblock = be32_to_cpu(rec->alloc.ar_startblock);\n\tirec->ar_blockcount = be32_to_cpu(rec->alloc.ar_blockcount);\n}\n\n \nxfs_failaddr_t\nxfs_alloc_check_irec(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst struct xfs_alloc_rec_incore *irec)\n{\n\tstruct xfs_perag\t\t*pag = cur->bc_ag.pag;\n\n\tif (irec->ar_blockcount == 0)\n\t\treturn __this_address;\n\n\t \n\tif (!xfs_verify_agbext(pag, irec->ar_startblock, irec->ar_blockcount))\n\t\treturn __this_address;\n\n\treturn NULL;\n}\n\nstatic inline int\nxfs_alloc_complain_bad_rec(\n\tstruct xfs_btree_cur\t\t*cur,\n\txfs_failaddr_t\t\t\tfa,\n\tconst struct xfs_alloc_rec_incore *irec)\n{\n\tstruct xfs_mount\t\t*mp = cur->bc_mp;\n\n\txfs_warn(mp,\n\t\t\"%s Freespace BTree record corruption in AG %d detected at %pS!\",\n\t\tcur->bc_btnum == XFS_BTNUM_BNO ? \"Block\" : \"Size\",\n\t\tcur->bc_ag.pag->pag_agno, fa);\n\txfs_warn(mp,\n\t\t\"start block 0x%x block count 0x%x\", irec->ar_startblock,\n\t\tirec->ar_blockcount);\n\treturn -EFSCORRUPTED;\n}\n\n \nint\t\t\t\t\t \nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t \n\txfs_agblock_t\t\t*bno,\t \n\txfs_extlen_t\t\t*len,\t \n\tint\t\t\t*stat)\t \n{\n\tstruct xfs_alloc_rec_incore irec;\n\tunion xfs_btree_rec\t*rec;\n\txfs_failaddr_t\t\tfa;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (error || !(*stat))\n\t\treturn error;\n\n\txfs_alloc_btrec_to_irec(rec, &irec);\n\tfa = xfs_alloc_check_irec(cur, &irec);\n\tif (fa)\n\t\treturn xfs_alloc_complain_bad_rec(cur, fa, &irec);\n\n\t*bno = irec.ar_startblock;\n\t*len = irec.ar_blockcount;\n\treturn 0;\n}\n\n \nSTATIC bool\nxfs_alloc_compute_aligned(\n\txfs_alloc_arg_t\t*args,\t\t \n\txfs_agblock_t\tfoundbno,\t \n\txfs_extlen_t\tfoundlen,\t \n\txfs_agblock_t\t*resbno,\t \n\txfs_extlen_t\t*reslen,\t \n\tunsigned\t*busy_gen)\n{\n\txfs_agblock_t\tbno = foundbno;\n\txfs_extlen_t\tlen = foundlen;\n\txfs_extlen_t\tdiff;\n\tbool\t\tbusy;\n\n\t \n\tbusy = xfs_extent_busy_trim(args, &bno, &len, busy_gen);\n\n\t \n\tif (bno < args->min_agbno && bno + len > args->min_agbno) {\n\t\tdiff = args->min_agbno - bno;\n\t\tif (len > diff) {\n\t\t\tbno += diff;\n\t\t\tlen -= diff;\n\t\t}\n\t}\n\n\tif (args->alignment > 1 && len >= args->minlen) {\n\t\txfs_agblock_t\taligned_bno = roundup(bno, args->alignment);\n\n\t\tdiff = aligned_bno - bno;\n\n\t\t*resbno = aligned_bno;\n\t\t*reslen = diff >= len ? 0 : len - diff;\n\t} else {\n\t\t*resbno = bno;\n\t\t*reslen = len;\n\t}\n\n\treturn busy;\n}\n\n \nSTATIC xfs_extlen_t\t\t\t \nxfs_alloc_compute_diff(\n\txfs_agblock_t\twantbno,\t \n\txfs_extlen_t\twantlen,\t \n\txfs_extlen_t\talignment,\t \n\tint\t\tdatatype,\t \n\txfs_agblock_t\tfreebno,\t \n\txfs_extlen_t\tfreelen,\t \n\txfs_agblock_t\t*newbnop)\t \n{\n\txfs_agblock_t\tfreeend;\t \n\txfs_agblock_t\tnewbno1;\t \n\txfs_agblock_t\tnewbno2;\t \n\txfs_extlen_t\tnewlen1=0;\t \n\txfs_extlen_t\tnewlen2=0;\t \n\txfs_agblock_t\twantend;\t \n\tbool\t\tuserdata = datatype & XFS_ALLOC_USERDATA;\n\n\tASSERT(freelen >= wantlen);\n\tfreeend = freebno + freelen;\n\twantend = wantbno + wantlen;\n\t \n\tif (freebno >= wantbno || (userdata && freeend < wantend)) {\n\t\tif ((newbno1 = roundup(freebno, alignment)) >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t} else if (freeend >= wantend && alignment > 1) {\n\t\tnewbno1 = roundup(wantbno, alignment);\n\t\tnewbno2 = newbno1 - alignment;\n\t\tif (newbno1 >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t\telse\n\t\t\tnewlen1 = XFS_EXTLEN_MIN(wantlen, freeend - newbno1);\n\t\tif (newbno2 < freebno)\n\t\t\tnewbno2 = NULLAGBLOCK;\n\t\telse\n\t\t\tnewlen2 = XFS_EXTLEN_MIN(wantlen, freeend - newbno2);\n\t\tif (newbno1 != NULLAGBLOCK && newbno2 != NULLAGBLOCK) {\n\t\t\tif (newlen1 < newlen2 ||\n\t\t\t    (newlen1 == newlen2 &&\n\t\t\t     XFS_ABSDIFF(newbno1, wantbno) >\n\t\t\t     XFS_ABSDIFF(newbno2, wantbno)))\n\t\t\t\tnewbno1 = newbno2;\n\t\t} else if (newbno2 != NULLAGBLOCK)\n\t\t\tnewbno1 = newbno2;\n\t} else if (freeend >= wantend) {\n\t\tnewbno1 = wantbno;\n\t} else if (alignment > 1) {\n\t\tnewbno1 = roundup(freeend - wantlen, alignment);\n\t\tif (newbno1 > freeend - wantlen &&\n\t\t    newbno1 - alignment >= freebno)\n\t\t\tnewbno1 -= alignment;\n\t\telse if (newbno1 >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t} else\n\t\tnewbno1 = freeend - wantlen;\n\t*newbnop = newbno1;\n\treturn newbno1 == NULLAGBLOCK ? 0 : XFS_ABSDIFF(newbno1, wantbno);\n}\n\n \nSTATIC void\nxfs_alloc_fix_len(\n\txfs_alloc_arg_t\t*args)\t\t \n{\n\txfs_extlen_t\tk;\n\txfs_extlen_t\trlen;\n\n\tASSERT(args->mod < args->prod);\n\trlen = args->len;\n\tASSERT(rlen >= args->minlen);\n\tASSERT(rlen <= args->maxlen);\n\tif (args->prod <= 1 || rlen < args->mod || rlen == args->maxlen ||\n\t    (args->mod == 0 && rlen < args->prod))\n\t\treturn;\n\tk = rlen % args->prod;\n\tif (k == args->mod)\n\t\treturn;\n\tif (k > args->mod)\n\t\trlen = rlen - (k - args->mod);\n\telse\n\t\trlen = rlen - args->prod + (args->mod - k);\n\t \n\tif ((int)rlen < (int)args->minlen)\n\t\treturn;\n\tASSERT(rlen >= args->minlen && rlen <= args->maxlen);\n\tASSERT(rlen % args->prod == args->mod);\n\tASSERT(args->pag->pagf_freeblks + args->pag->pagf_flcount >=\n\t\trlen + args->minleft);\n\targs->len = rlen;\n}\n\n \nSTATIC int\t\t\t\t \nxfs_alloc_fixup_trees(\n\tstruct xfs_btree_cur *cnt_cur,\t \n\tstruct xfs_btree_cur *bno_cur,\t \n\txfs_agblock_t\tfbno,\t\t \n\txfs_extlen_t\tflen,\t\t \n\txfs_agblock_t\trbno,\t\t \n\txfs_extlen_t\trlen,\t\t \n\tint\t\tflags)\t\t \n{\n\tint\t\terror;\t\t \n\tint\t\ti;\t\t \n\txfs_agblock_t\tnfbno1;\t\t \n\txfs_agblock_t\tnfbno2;\t\t \n\txfs_extlen_t\tnflen1=0;\t \n\txfs_extlen_t\tnflen2=0;\t \n\tstruct xfs_mount *mp;\n\n\tmp = cnt_cur->bc_mp;\n\n\t \n\tif (flags & XFSA_FIXUP_CNT_OK) {\n#ifdef DEBUG\n\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &nfbno1, &nflen1, &i)))\n\t\t\treturn error;\n\t\tif (XFS_IS_CORRUPT(mp,\n\t\t\t\t   i != 1 ||\n\t\t\t\t   nfbno1 != fbno ||\n\t\t\t\t   nflen1 != flen))\n\t\t\treturn -EFSCORRUPTED;\n#endif\n\t} else {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, fbno, flen, &i)))\n\t\t\treturn error;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1))\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\t \n\tif (flags & XFSA_FIXUP_BNO_OK) {\n#ifdef DEBUG\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &nfbno1, &nflen1, &i)))\n\t\t\treturn error;\n\t\tif (XFS_IS_CORRUPT(mp,\n\t\t\t\t   i != 1 ||\n\t\t\t\t   nfbno1 != fbno ||\n\t\t\t\t   nflen1 != flen))\n\t\t\treturn -EFSCORRUPTED;\n#endif\n\t} else {\n\t\tif ((error = xfs_alloc_lookup_eq(bno_cur, fbno, flen, &i)))\n\t\t\treturn error;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1))\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\n#ifdef DEBUG\n\tif (bno_cur->bc_nlevels == 1 && cnt_cur->bc_nlevels == 1) {\n\t\tstruct xfs_btree_block\t*bnoblock;\n\t\tstruct xfs_btree_block\t*cntblock;\n\n\t\tbnoblock = XFS_BUF_TO_BLOCK(bno_cur->bc_levels[0].bp);\n\t\tcntblock = XFS_BUF_TO_BLOCK(cnt_cur->bc_levels[0].bp);\n\n\t\tif (XFS_IS_CORRUPT(mp,\n\t\t\t\t   bnoblock->bb_numrecs !=\n\t\t\t\t   cntblock->bb_numrecs))\n\t\t\treturn -EFSCORRUPTED;\n\t}\n#endif\n\n\t \n\tif (rbno == fbno && rlen == flen)\n\t\tnfbno1 = nfbno2 = NULLAGBLOCK;\n\telse if (rbno == fbno) {\n\t\tnfbno1 = rbno + rlen;\n\t\tnflen1 = flen - rlen;\n\t\tnfbno2 = NULLAGBLOCK;\n\t} else if (rbno + rlen == fbno + flen) {\n\t\tnfbno1 = fbno;\n\t\tnflen1 = flen - rlen;\n\t\tnfbno2 = NULLAGBLOCK;\n\t} else {\n\t\tnfbno1 = fbno;\n\t\tnflen1 = rbno - fbno;\n\t\tnfbno2 = rbno + rlen;\n\t\tnflen2 = (fbno + flen) - nfbno2;\n\t}\n\t \n\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\treturn error;\n\tif (XFS_IS_CORRUPT(mp, i != 1))\n\t\treturn -EFSCORRUPTED;\n\t \n\tif (nfbno1 != NULLAGBLOCK) {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nfbno1, nflen1, &i)))\n\t\t\treturn error;\n\t\tif (XFS_IS_CORRUPT(mp, i != 0))\n\t\t\treturn -EFSCORRUPTED;\n\t\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\t\treturn error;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1))\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\tif (nfbno2 != NULLAGBLOCK) {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nfbno2, nflen2, &i)))\n\t\t\treturn error;\n\t\tif (XFS_IS_CORRUPT(mp, i != 0))\n\t\t\treturn -EFSCORRUPTED;\n\t\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\t\treturn error;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1))\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\t \n\tif (nfbno1 == NULLAGBLOCK) {\n\t\t \n\t\tif ((error = xfs_btree_delete(bno_cur, &i)))\n\t\t\treturn error;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1))\n\t\t\treturn -EFSCORRUPTED;\n\t} else {\n\t\t \n\t\tif ((error = xfs_alloc_update(bno_cur, nfbno1, nflen1)))\n\t\t\treturn error;\n\t}\n\tif (nfbno2 != NULLAGBLOCK) {\n\t\t \n\t\tif ((error = xfs_alloc_lookup_eq(bno_cur, nfbno2, nflen2, &i)))\n\t\t\treturn error;\n\t\tif (XFS_IS_CORRUPT(mp, i != 0))\n\t\t\treturn -EFSCORRUPTED;\n\t\tif ((error = xfs_btree_insert(bno_cur, &i)))\n\t\t\treturn error;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1))\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}\n\n \nstatic xfs_failaddr_t\nxfs_agfl_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_mount;\n\tstruct xfs_agfl\t*agfl = XFS_BUF_TO_AGFL(bp);\n\t__be32\t\t*agfl_bno = xfs_buf_to_agfl_bno(bp);\n\tint\t\ti;\n\n\tif (!xfs_has_crc(mp))\n\t\treturn NULL;\n\n\tif (!xfs_verify_magic(bp, agfl->agfl_magicnum))\n\t\treturn __this_address;\n\tif (!uuid_equal(&agfl->agfl_uuid, &mp->m_sb.sb_meta_uuid))\n\t\treturn __this_address;\n\t \n\tif (bp->b_pag && be32_to_cpu(agfl->agfl_seqno) != bp->b_pag->pag_agno)\n\t\treturn __this_address;\n\n\tfor (i = 0; i < xfs_agfl_size(mp); i++) {\n\t\tif (be32_to_cpu(agfl_bno[i]) != NULLAGBLOCK &&\n\t\t    be32_to_cpu(agfl_bno[i]) >= mp->m_sb.sb_agblocks)\n\t\t\treturn __this_address;\n\t}\n\n\tif (!xfs_log_check_lsn(mp, be64_to_cpu(XFS_BUF_TO_AGFL(bp)->agfl_lsn)))\n\t\treturn __this_address;\n\treturn NULL;\n}\n\nstatic void\nxfs_agfl_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_mount;\n\txfs_failaddr_t\tfa;\n\n\t \n\tif (!xfs_has_crc(mp))\n\t\treturn;\n\n\tif (!xfs_buf_verify_cksum(bp, XFS_AGFL_CRC_OFF))\n\t\txfs_verifier_error(bp, -EFSBADCRC, __this_address);\n\telse {\n\t\tfa = xfs_agfl_verify(bp);\n\t\tif (fa)\n\t\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t}\n}\n\nstatic void\nxfs_agfl_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_log_item;\n\txfs_failaddr_t\t\tfa;\n\n\t \n\tif (!xfs_has_crc(mp))\n\t\treturn;\n\n\tfa = xfs_agfl_verify(bp);\n\tif (fa) {\n\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t\treturn;\n\t}\n\n\tif (bip)\n\t\tXFS_BUF_TO_AGFL(bp)->agfl_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_AGFL_CRC_OFF);\n}\n\nconst struct xfs_buf_ops xfs_agfl_buf_ops = {\n\t.name = \"xfs_agfl\",\n\t.magic = { cpu_to_be32(XFS_AGFL_MAGIC), cpu_to_be32(XFS_AGFL_MAGIC) },\n\t.verify_read = xfs_agfl_read_verify,\n\t.verify_write = xfs_agfl_write_verify,\n\t.verify_struct = xfs_agfl_verify,\n};\n\n \nint\nxfs_alloc_read_agfl(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\terror = xfs_trans_read_buf(\n\t\t\tmp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, pag->pag_agno, XFS_AGFL_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, &xfs_agfl_buf_ops);\n\tif (error)\n\t\treturn error;\n\txfs_buf_set_ref(bp, XFS_AGFL_REF);\n\t*bpp = bp;\n\treturn 0;\n}\n\nSTATIC int\nxfs_alloc_update_counters(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\tlong\t\t\tlen)\n{\n\tstruct xfs_agf\t\t*agf = agbp->b_addr;\n\n\tagbp->b_pag->pagf_freeblks += len;\n\tbe32_add_cpu(&agf->agf_freeblks, len);\n\n\tif (unlikely(be32_to_cpu(agf->agf_freeblks) >\n\t\t     be32_to_cpu(agf->agf_length))) {\n\t\txfs_buf_mark_corrupt(agbp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\txfs_alloc_log_agf(tp, agbp, XFS_AGF_FREEBLKS);\n\treturn 0;\n}\n\n \nstruct xfs_alloc_cur {\n\tstruct xfs_btree_cur\t\t*cnt;\t \n\tstruct xfs_btree_cur\t\t*bnolt;\n\tstruct xfs_btree_cur\t\t*bnogt;\n\txfs_extlen_t\t\t\tcur_len; \n\txfs_agblock_t\t\t\trec_bno; \n\txfs_extlen_t\t\t\trec_len; \n\txfs_agblock_t\t\t\tbno;\t \n\txfs_extlen_t\t\t\tlen;\t \n\txfs_extlen_t\t\t\tdiff;\t \n\tunsigned int\t\t\tbusy_gen; \n\tbool\t\t\t\tbusy;\n};\n\n \nstatic int\nxfs_alloc_cur_setup(\n\tstruct xfs_alloc_arg\t*args,\n\tstruct xfs_alloc_cur\t*acur)\n{\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tacur->cur_len = args->maxlen;\n\tacur->rec_bno = 0;\n\tacur->rec_len = 0;\n\tacur->bno = 0;\n\tacur->len = 0;\n\tacur->diff = -1;\n\tacur->busy = false;\n\tacur->busy_gen = 0;\n\n\t \n\tif (!acur->cnt)\n\t\tacur->cnt = xfs_allocbt_init_cursor(args->mp, args->tp,\n\t\t\t\t\targs->agbp, args->pag, XFS_BTNUM_CNT);\n\terror = xfs_alloc_lookup_ge(acur->cnt, 0, args->maxlen, &i);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (!acur->bnolt)\n\t\tacur->bnolt = xfs_allocbt_init_cursor(args->mp, args->tp,\n\t\t\t\t\targs->agbp, args->pag, XFS_BTNUM_BNO);\n\tif (!acur->bnogt)\n\t\tacur->bnogt = xfs_allocbt_init_cursor(args->mp, args->tp,\n\t\t\t\t\targs->agbp, args->pag, XFS_BTNUM_BNO);\n\treturn i == 1 ? 0 : -ENOSPC;\n}\n\nstatic void\nxfs_alloc_cur_close(\n\tstruct xfs_alloc_cur\t*acur,\n\tbool\t\t\terror)\n{\n\tint\t\t\tcur_error = XFS_BTREE_NOERROR;\n\n\tif (error)\n\t\tcur_error = XFS_BTREE_ERROR;\n\n\tif (acur->cnt)\n\t\txfs_btree_del_cursor(acur->cnt, cur_error);\n\tif (acur->bnolt)\n\t\txfs_btree_del_cursor(acur->bnolt, cur_error);\n\tif (acur->bnogt)\n\t\txfs_btree_del_cursor(acur->bnogt, cur_error);\n\tacur->cnt = acur->bnolt = acur->bnogt = NULL;\n}\n\n \nstatic int\nxfs_alloc_cur_check(\n\tstruct xfs_alloc_arg\t*args,\n\tstruct xfs_alloc_cur\t*acur,\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*new)\n{\n\tint\t\t\terror, i;\n\txfs_agblock_t\t\tbno, bnoa, bnew;\n\txfs_extlen_t\t\tlen, lena, diff = -1;\n\tbool\t\t\tbusy;\n\tunsigned\t\tbusy_gen = 0;\n\tbool\t\t\tdeactivate = false;\n\tbool\t\t\tisbnobt = cur->bc_btnum == XFS_BTNUM_BNO;\n\n\t*new = 0;\n\n\terror = xfs_alloc_get_rec(cur, &bno, &len, &i);\n\tif (error)\n\t\treturn error;\n\tif (XFS_IS_CORRUPT(args->mp, i != 1))\n\t\treturn -EFSCORRUPTED;\n\n\t \n\tif (len < args->minlen) {\n\t\tdeactivate = !isbnobt;\n\t\tgoto out;\n\t}\n\n\tbusy = xfs_alloc_compute_aligned(args, bno, len, &bnoa, &lena,\n\t\t\t\t\t &busy_gen);\n\tacur->busy |= busy;\n\tif (busy)\n\t\tacur->busy_gen = busy_gen;\n\t \n\tif (bnoa < args->min_agbno || bnoa > args->max_agbno) {\n\t\tdeactivate = isbnobt;\n\t\tgoto out;\n\t}\n\tif (lena < args->minlen)\n\t\tgoto out;\n\n\targs->len = XFS_EXTLEN_MIN(lena, args->maxlen);\n\txfs_alloc_fix_len(args);\n\tASSERT(args->len >= args->minlen);\n\tif (args->len < acur->len)\n\t\tgoto out;\n\n\t \n\tdiff = xfs_alloc_compute_diff(args->agbno, args->len,\n\t\t\t\t      args->alignment, args->datatype,\n\t\t\t\t      bnoa, lena, &bnew);\n\tif (bnew == NULLAGBLOCK)\n\t\tgoto out;\n\n\t \n\tif (diff > acur->diff) {\n\t\tdeactivate = isbnobt;\n\t\tgoto out;\n\t}\n\n\tASSERT(args->len > acur->len ||\n\t       (args->len == acur->len && diff <= acur->diff));\n\tacur->rec_bno = bno;\n\tacur->rec_len = len;\n\tacur->bno = bnew;\n\tacur->len = args->len;\n\tacur->diff = diff;\n\t*new = 1;\n\n\t \n\tif (acur->diff == 0 && acur->len == args->maxlen)\n\t\tdeactivate = true;\nout:\n\tif (deactivate)\n\t\tcur->bc_ag.abt.active = false;\n\ttrace_xfs_alloc_cur_check(args->mp, cur->bc_btnum, bno, len, diff,\n\t\t\t\t  *new);\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_alloc_cur_finish(\n\tstruct xfs_alloc_arg\t*args,\n\tstruct xfs_alloc_cur\t*acur)\n{\n\tstruct xfs_agf __maybe_unused *agf = args->agbp->b_addr;\n\tint\t\t\terror;\n\n\tASSERT(acur->cnt && acur->bnolt);\n\tASSERT(acur->bno >= acur->rec_bno);\n\tASSERT(acur->bno + acur->len <= acur->rec_bno + acur->rec_len);\n\tASSERT(acur->rec_bno + acur->rec_len <= be32_to_cpu(agf->agf_length));\n\n\terror = xfs_alloc_fixup_trees(acur->cnt, acur->bnolt, acur->rec_bno,\n\t\t\t\t      acur->rec_len, acur->bno, acur->len, 0);\n\tif (error)\n\t\treturn error;\n\n\targs->agbno = acur->bno;\n\targs->len = acur->len;\n\targs->wasfromfl = 0;\n\n\ttrace_xfs_alloc_cur(args);\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_alloc_cntbt_iter(\n\tstruct xfs_alloc_arg\t\t*args,\n\tstruct xfs_alloc_cur\t\t*acur)\n{\n\tstruct xfs_btree_cur\t*cur = acur->cnt;\n\txfs_agblock_t\t\tbno;\n\txfs_extlen_t\t\tlen, cur_len;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tif (!xfs_alloc_cur_active(cur))\n\t\treturn 0;\n\n\t \n\tcur_len = acur->cur_len;\n\terror = xfs_alloc_lookup_ge(cur, args->agbno, cur_len, &i);\n\tif (error)\n\t\treturn error;\n\tif (i == 0)\n\t\treturn 0;\n\terror = xfs_alloc_get_rec(cur, &bno, &len, &i);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = xfs_alloc_cur_check(args, acur, cur, &i);\n\tif (error)\n\t\treturn error;\n\tASSERT(len >= acur->cur_len);\n\tacur->cur_len = len;\n\n\t \n\tif (bno > args->agbno) {\n\t\terror = xfs_btree_decrement(cur, 0, &i);\n\t\tif (!error && i) {\n\t\t\terror = xfs_alloc_get_rec(cur, &bno, &len, &i);\n\t\t\tif (!error && i && len == acur->cur_len)\n\t\t\t\terror = xfs_alloc_cur_check(args, acur, cur,\n\t\t\t\t\t\t\t    &i);\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\tcur_len <<= 1;\n\tif (!acur->len || acur->cur_len >= cur_len)\n\t\tacur->cur_len++;\n\telse\n\t\tacur->cur_len = cur_len;\n\n\treturn error;\n}\n\n \nSTATIC int\t\t\t \nxfs_alloc_ag_vextent_small(\n\tstruct xfs_alloc_arg\t*args,\t \n\tstruct xfs_btree_cur\t*ccur,\t \n\txfs_agblock_t\t\t*fbnop,\t \n\txfs_extlen_t\t\t*flenp,\t \n\tint\t\t\t*stat)\t \n{\n\tstruct xfs_agf\t\t*agf = args->agbp->b_addr;\n\tint\t\t\terror = 0;\n\txfs_agblock_t\t\tfbno = NULLAGBLOCK;\n\txfs_extlen_t\t\tflen = 0;\n\tint\t\t\ti = 0;\n\n\t \n\tif (ccur)\n\t\terror = xfs_btree_decrement(ccur, 0, &i);\n\tif (error)\n\t\tgoto error;\n\tif (i) {\n\t\terror = xfs_alloc_get_rec(ccur, &fbno, &flen, &i);\n\t\tif (error)\n\t\t\tgoto error;\n\t\tif (XFS_IS_CORRUPT(args->mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (args->minlen != 1 || args->alignment != 1 ||\n\t    args->resv == XFS_AG_RESV_AGFL ||\n\t    be32_to_cpu(agf->agf_flcount) <= args->minleft)\n\t\tgoto out;\n\n\terror = xfs_alloc_get_freelist(args->pag, args->tp, args->agbp,\n\t\t\t&fbno, 0);\n\tif (error)\n\t\tgoto error;\n\tif (fbno == NULLAGBLOCK)\n\t\tgoto out;\n\n\txfs_extent_busy_reuse(args->mp, args->pag, fbno, 1,\n\t\t\t      (args->datatype & XFS_ALLOC_NOBUSY));\n\n\tif (args->datatype & XFS_ALLOC_USERDATA) {\n\t\tstruct xfs_buf\t*bp;\n\n\t\terror = xfs_trans_get_buf(args->tp, args->mp->m_ddev_targp,\n\t\t\t\tXFS_AGB_TO_DADDR(args->mp, args->agno, fbno),\n\t\t\t\targs->mp->m_bsize, 0, &bp);\n\t\tif (error)\n\t\t\tgoto error;\n\t\txfs_trans_binval(args->tp, bp);\n\t}\n\t*fbnop = args->agbno = fbno;\n\t*flenp = args->len = 1;\n\tif (XFS_IS_CORRUPT(args->mp, fbno >= be32_to_cpu(agf->agf_length))) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error;\n\t}\n\targs->wasfromfl = 1;\n\ttrace_xfs_alloc_small_freelist(args);\n\n\t \n\terror = xfs_rmap_free(args->tp, args->agbp, args->pag, fbno, 1,\n\t\t\t      &XFS_RMAP_OINFO_AG);\n\tif (error)\n\t\tgoto error;\n\n\t*stat = 0;\n\treturn 0;\n\nout:\n\t \n\tif (flen < args->minlen) {\n\t\targs->agbno = NULLAGBLOCK;\n\t\ttrace_xfs_alloc_small_notenough(args);\n\t\tflen = 0;\n\t}\n\t*fbnop = fbno;\n\t*flenp = flen;\n\t*stat = 1;\n\ttrace_xfs_alloc_small_done(args);\n\treturn 0;\n\nerror:\n\ttrace_xfs_alloc_small_error(args);\n\treturn error;\n}\n\n \nSTATIC int\t\t\t \nxfs_alloc_ag_vextent_exact(\n\txfs_alloc_arg_t\t*args)\t \n{\n\tstruct xfs_agf __maybe_unused *agf = args->agbp->b_addr;\n\tstruct xfs_btree_cur *bno_cur; \n\tstruct xfs_btree_cur *cnt_cur; \n\tint\t\terror;\n\txfs_agblock_t\tfbno;\t \n\txfs_extlen_t\tflen;\t \n\txfs_agblock_t\ttbno;\t \n\txfs_extlen_t\ttlen;\t \n\txfs_agblock_t\ttend;\t \n\tint\t\ti;\t \n\tunsigned\tbusy_gen;\n\n\tASSERT(args->alignment == 1);\n\n\t \n\tbno_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\t\t\t\t  args->pag, XFS_BTNUM_BNO);\n\n\t \n\terror = xfs_alloc_lookup_le(bno_cur, args->agbno, args->minlen, &i);\n\tif (error)\n\t\tgoto error0;\n\tif (!i)\n\t\tgoto not_found;\n\n\t \n\terror = xfs_alloc_get_rec(bno_cur, &fbno, &flen, &i);\n\tif (error)\n\t\tgoto error0;\n\tif (XFS_IS_CORRUPT(args->mp, i != 1)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(fbno <= args->agbno);\n\n\t \n\ttbno = fbno;\n\ttlen = flen;\n\txfs_extent_busy_trim(args, &tbno, &tlen, &busy_gen);\n\n\t \n\tif (tbno > args->agbno)\n\t\tgoto not_found;\n\tif (tlen < args->minlen)\n\t\tgoto not_found;\n\ttend = tbno + tlen;\n\tif (tend < args->agbno + args->minlen)\n\t\tgoto not_found;\n\n\t \n\targs->len = XFS_AGBLOCK_MIN(tend, args->agbno + args->maxlen)\n\t\t\t\t\t\t- args->agbno;\n\txfs_alloc_fix_len(args);\n\tASSERT(args->agbno + args->len <= tend);\n\n\t \n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\t\t\t\targs->pag, XFS_BTNUM_CNT);\n\tASSERT(args->agbno + args->len <= be32_to_cpu(agf->agf_length));\n\terror = xfs_alloc_fixup_trees(cnt_cur, bno_cur, fbno, flen, args->agbno,\n\t\t\t\t      args->len, XFSA_FIXUP_BNO_OK);\n\tif (error) {\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\t\tgoto error0;\n\t}\n\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\n\targs->wasfromfl = 0;\n\ttrace_xfs_alloc_exact_done(args);\n\treturn 0;\n\nnot_found:\n\t \n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\targs->agbno = NULLAGBLOCK;\n\ttrace_xfs_alloc_exact_notfound(args);\n\treturn 0;\n\nerror0:\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\ttrace_xfs_alloc_exact_error(args);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_alloc_walk_iter(\n\tstruct xfs_alloc_arg\t*args,\n\tstruct xfs_alloc_cur\t*acur,\n\tstruct xfs_btree_cur\t*cur,\n\tbool\t\t\tincrement,\n\tbool\t\t\tfind_one,  \n\tint\t\t\tcount,     \n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\t*stat = 0;\n\n\t \n\twhile (xfs_alloc_cur_active(cur) && count) {\n\t\terror = xfs_alloc_cur_check(args, acur, cur, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (i == 1) {\n\t\t\t*stat = 1;\n\t\t\tif (find_one)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!xfs_alloc_cur_active(cur))\n\t\t\tbreak;\n\n\t\tif (increment)\n\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\telse\n\t\t\terror = xfs_btree_decrement(cur, 0, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (i == 0)\n\t\t\tcur->bc_ag.abt.active = false;\n\n\t\tif (count > 0)\n\t\t\tcount--;\n\t}\n\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_alloc_ag_vextent_locality(\n\tstruct xfs_alloc_arg\t*args,\n\tstruct xfs_alloc_cur\t*acur,\n\tint\t\t\t*stat)\n{\n\tstruct xfs_btree_cur\t*fbcur = NULL;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\tbool\t\t\tfbinc;\n\n\tASSERT(acur->len == 0);\n\n\t*stat = 0;\n\n\terror = xfs_alloc_lookup_ge(acur->cnt, args->agbno, acur->cur_len, &i);\n\tif (error)\n\t\treturn error;\n\terror = xfs_alloc_lookup_le(acur->bnolt, args->agbno, 0, &i);\n\tif (error)\n\t\treturn error;\n\terror = xfs_alloc_lookup_ge(acur->bnogt, args->agbno, 0, &i);\n\tif (error)\n\t\treturn error;\n\n\t \n\twhile (xfs_alloc_cur_active(acur->bnolt) ||\n\t       xfs_alloc_cur_active(acur->bnogt) ||\n\t       xfs_alloc_cur_active(acur->cnt)) {\n\n\t\ttrace_xfs_alloc_cur_lookup(args);\n\n\t\t \n\t\terror = xfs_alloc_walk_iter(args, acur, acur->bnolt, false,\n\t\t\t\t\t    true, 1, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (i == 1) {\n\t\t\ttrace_xfs_alloc_cur_left(args);\n\t\t\tfbcur = acur->bnogt;\n\t\t\tfbinc = true;\n\t\t\tbreak;\n\t\t}\n\t\terror = xfs_alloc_walk_iter(args, acur, acur->bnogt, true, true,\n\t\t\t\t\t    1, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (i == 1) {\n\t\t\ttrace_xfs_alloc_cur_right(args);\n\t\t\tfbcur = acur->bnolt;\n\t\t\tfbinc = false;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\terror = xfs_alloc_cntbt_iter(args, acur);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (!xfs_alloc_cur_active(acur->cnt)) {\n\t\t\ttrace_xfs_alloc_cur_lookup_done(args);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!xfs_alloc_cur_active(acur->cnt) && !acur->len && !acur->busy) {\n\t\terror = xfs_btree_decrement(acur->cnt, 0, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (i) {\n\t\t\tacur->cnt->bc_ag.abt.active = true;\n\t\t\tfbcur = acur->cnt;\n\t\t\tfbinc = false;\n\t\t}\n\t}\n\n\t \n\tif (fbcur) {\n\t\terror = xfs_alloc_walk_iter(args, acur, fbcur, fbinc, true, -1,\n\t\t\t\t\t    &i);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (acur->len)\n\t\t*stat = 1;\n\n\treturn 0;\n}\n\n \nstatic int\nxfs_alloc_ag_vextent_lastblock(\n\tstruct xfs_alloc_arg\t*args,\n\tstruct xfs_alloc_cur\t*acur,\n\txfs_agblock_t\t\t*bno,\n\txfs_extlen_t\t\t*len,\n\tbool\t\t\t*allocated)\n{\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n#ifdef DEBUG\n\t \n\tif (get_random_u32_below(2))\n\t\treturn 0;\n#endif\n\n\t \n\tif (*len || args->alignment > 1) {\n\t\tacur->cnt->bc_levels[0].ptr = 1;\n\t\tdo {\n\t\t\terror = xfs_alloc_get_rec(acur->cnt, bno, len, &i);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (XFS_IS_CORRUPT(args->mp, i != 1))\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\tif (*len >= args->minlen)\n\t\t\t\tbreak;\n\t\t\terror = xfs_btree_increment(acur->cnt, 0, &i);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} while (i);\n\t\tASSERT(*len >= args->minlen);\n\t\tif (!i)\n\t\t\treturn 0;\n\t}\n\n\terror = xfs_alloc_walk_iter(args, acur, acur->cnt, true, false, -1, &i);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (acur->len == 0)\n\t\treturn 0;\n\n\ttrace_xfs_alloc_near_first(args);\n\t*allocated = true;\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_alloc_ag_vextent_near(\n\tstruct xfs_alloc_arg\t*args,\n\tuint32_t\t\talloc_flags)\n{\n\tstruct xfs_alloc_cur\tacur = {};\n\tint\t\t\terror;\t\t \n\tint\t\t\ti;\t\t \n\txfs_agblock_t\t\tbno;\n\txfs_extlen_t\t\tlen;\n\n\t \n\tif (!args->min_agbno && !args->max_agbno)\n\t\targs->max_agbno = args->mp->m_sb.sb_agblocks - 1;\n\tASSERT(args->min_agbno <= args->max_agbno);\n\n\t \n\tif (args->agbno < args->min_agbno)\n\t\targs->agbno = args->min_agbno;\n\tif (args->agbno > args->max_agbno)\n\t\targs->agbno = args->max_agbno;\n\n\t \n\talloc_flags |= XFS_ALLOC_FLAG_TRYFLUSH;\nrestart:\n\tlen = 0;\n\n\t \n\terror = xfs_alloc_cur_setup(args, &acur);\n\tif (error == -ENOSPC) {\n\t\terror = xfs_alloc_ag_vextent_small(args, acur.cnt, &bno,\n\t\t\t\t&len, &i);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tif (i == 0 || len == 0) {\n\t\t\ttrace_xfs_alloc_near_noentry(args);\n\t\t\tgoto out;\n\t\t}\n\t\tASSERT(i == 1);\n\t} else if (error) {\n\t\tgoto out;\n\t}\n\n\t \n\tif (xfs_btree_islastblock(acur.cnt, 0)) {\n\t\tbool\t\tallocated = false;\n\n\t\terror = xfs_alloc_ag_vextent_lastblock(args, &acur, &bno, &len,\n\t\t\t\t&allocated);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tif (allocated)\n\t\t\tgoto alloc_finish;\n\t}\n\n\t \n\terror = xfs_alloc_ag_vextent_locality(args, &acur, &i);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tif (!acur.len) {\n\t\tif (acur.busy) {\n\t\t\t \n\t\t\ttrace_xfs_alloc_near_busy(args);\n\t\t\terror = xfs_extent_busy_flush(args->tp, args->pag,\n\t\t\t\t\tacur.busy_gen, alloc_flags);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\talloc_flags &= ~XFS_ALLOC_FLAG_TRYFLUSH;\n\t\t\tgoto restart;\n\t\t}\n\t\ttrace_xfs_alloc_size_neither(args);\n\t\targs->agbno = NULLAGBLOCK;\n\t\tgoto out;\n\t}\n\nalloc_finish:\n\t \n\terror = xfs_alloc_cur_finish(args, &acur);\n\nout:\n\txfs_alloc_cur_close(&acur, error);\n\treturn error;\n}\n\n \nstatic int\nxfs_alloc_ag_vextent_size(\n\tstruct xfs_alloc_arg\t*args,\n\tuint32_t\t\talloc_flags)\n{\n\tstruct xfs_agf\t\t*agf = args->agbp->b_addr;\n\tstruct xfs_btree_cur\t*bno_cur;\n\tstruct xfs_btree_cur\t*cnt_cur;\n\txfs_agblock_t\t\tfbno;\t\t \n\txfs_extlen_t\t\tflen;\t\t \n\txfs_agblock_t\t\trbno;\t\t \n\txfs_extlen_t\t\trlen;\t\t \n\tbool\t\t\tbusy;\n\tunsigned\t\tbusy_gen;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\t \n\talloc_flags |= XFS_ALLOC_FLAG_TRYFLUSH;\nrestart:\n\t \n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\t\t\t\targs->pag, XFS_BTNUM_CNT);\n\tbno_cur = NULL;\n\n\t \n\tif ((error = xfs_alloc_lookup_ge(cnt_cur, 0,\n\t\t\targs->maxlen + args->alignment - 1, &i)))\n\t\tgoto error0;\n\n\t \n\tif (!i) {\n\t\terror = xfs_alloc_ag_vextent_small(args, cnt_cur,\n\t\t\t\t\t\t   &fbno, &flen, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (i == 0 || flen == 0) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_size_noentry(args);\n\t\t\treturn 0;\n\t\t}\n\t\tASSERT(i == 1);\n\t\tbusy = xfs_alloc_compute_aligned(args, fbno, flen, &rbno,\n\t\t\t\t&rlen, &busy_gen);\n\t} else {\n\t\t \n\t\tfor (;;) {\n\t\t\terror = xfs_alloc_get_rec(cnt_cur, &fbno, &flen, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (XFS_IS_CORRUPT(args->mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto error0;\n\t\t\t}\n\n\t\t\tbusy = xfs_alloc_compute_aligned(args, fbno, flen,\n\t\t\t\t\t&rbno, &rlen, &busy_gen);\n\n\t\t\tif (rlen >= args->maxlen)\n\t\t\t\tbreak;\n\n\t\t\terror = xfs_btree_increment(cnt_cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (i)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\ttrace_xfs_alloc_size_busy(args);\n\t\t\terror = xfs_extent_busy_flush(args->tp, args->pag,\n\t\t\t\t\tbusy_gen, alloc_flags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\n\t\t\talloc_flags &= ~XFS_ALLOC_FLAG_TRYFLUSH;\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\t \n\trlen = XFS_EXTLEN_MIN(args->maxlen, rlen);\n\tif (XFS_IS_CORRUPT(args->mp,\n\t\t\t   rlen != 0 &&\n\t\t\t   (rlen > flen ||\n\t\t\t    rbno + rlen > fbno + flen))) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tif (rlen < args->maxlen) {\n\t\txfs_agblock_t\tbestfbno;\n\t\txfs_extlen_t\tbestflen;\n\t\txfs_agblock_t\tbestrbno;\n\t\txfs_extlen_t\tbestrlen;\n\n\t\tbestrlen = rlen;\n\t\tbestrbno = rbno;\n\t\tbestflen = flen;\n\t\tbestfbno = fbno;\n\t\tfor (;;) {\n\t\t\tif ((error = xfs_btree_decrement(cnt_cur, 0, &i)))\n\t\t\t\tgoto error0;\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &fbno, &flen,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto error0;\n\t\t\tif (XFS_IS_CORRUPT(args->mp, i != 1)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t\tif (flen < bestrlen)\n\t\t\t\tbreak;\n\t\t\tbusy = xfs_alloc_compute_aligned(args, fbno, flen,\n\t\t\t\t\t&rbno, &rlen, &busy_gen);\n\t\t\trlen = XFS_EXTLEN_MIN(args->maxlen, rlen);\n\t\t\tif (XFS_IS_CORRUPT(args->mp,\n\t\t\t\t\t   rlen != 0 &&\n\t\t\t\t\t   (rlen > flen ||\n\t\t\t\t\t    rbno + rlen > fbno + flen))) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t\tif (rlen > bestrlen) {\n\t\t\t\tbestrlen = rlen;\n\t\t\t\tbestrbno = rbno;\n\t\t\t\tbestflen = flen;\n\t\t\t\tbestfbno = fbno;\n\t\t\t\tif (rlen == args->maxlen)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, bestfbno, bestflen,\n\t\t\t\t&i)))\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(args->mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\t\trlen = bestrlen;\n\t\trbno = bestrbno;\n\t\tflen = bestflen;\n\t\tfbno = bestfbno;\n\t}\n\targs->wasfromfl = 0;\n\t \n\targs->len = rlen;\n\tif (rlen < args->minlen) {\n\t\tif (busy) {\n\t\t\t \n\t\t\ttrace_xfs_alloc_size_busy(args);\n\t\t\terror = xfs_extent_busy_flush(args->tp, args->pag,\n\t\t\t\t\tbusy_gen, alloc_flags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\n\t\t\talloc_flags &= ~XFS_ALLOC_FLAG_TRYFLUSH;\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\tgoto restart;\n\t\t}\n\t\tgoto out_nominleft;\n\t}\n\txfs_alloc_fix_len(args);\n\n\trlen = args->len;\n\tif (XFS_IS_CORRUPT(args->mp, rlen > flen)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\t \n\tbno_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\t\t\t\targs->pag, XFS_BTNUM_BNO);\n\tif ((error = xfs_alloc_fixup_trees(cnt_cur, bno_cur, fbno, flen,\n\t\t\trbno, rlen, XFSA_FIXUP_CNT_OK)))\n\t\tgoto error0;\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\tcnt_cur = bno_cur = NULL;\n\targs->len = rlen;\n\targs->agbno = rbno;\n\tif (XFS_IS_CORRUPT(args->mp,\n\t\t\t   args->agbno + args->len >\n\t\t\t   be32_to_cpu(agf->agf_length))) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\ttrace_xfs_alloc_size_done(args);\n\treturn 0;\n\nerror0:\n\ttrace_xfs_alloc_size_error(args);\n\tif (cnt_cur)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\tif (bno_cur)\n\t\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\treturn error;\n\nout_nominleft:\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\ttrace_xfs_alloc_size_nominleft(args);\n\targs->agbno = NULLAGBLOCK;\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_free_ag_extent(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_buf\t\t\t*agbp,\n\txfs_agnumber_t\t\t\tagno,\n\txfs_agblock_t\t\t\tbno,\n\txfs_extlen_t\t\t\tlen,\n\tconst struct xfs_owner_info\t*oinfo,\n\tenum xfs_ag_resv_type\t\ttype)\n{\n\tstruct xfs_mount\t\t*mp;\n\tstruct xfs_btree_cur\t\t*bno_cur;\n\tstruct xfs_btree_cur\t\t*cnt_cur;\n\txfs_agblock_t\t\t\tgtbno;  \n\txfs_extlen_t\t\t\tgtlen;  \n\txfs_agblock_t\t\t\tltbno;  \n\txfs_extlen_t\t\t\tltlen;  \n\txfs_agblock_t\t\t\tnbno;  \n\txfs_extlen_t\t\t\tnlen;  \n\tint\t\t\t\thaveleft;  \n\tint\t\t\t\thaveright;  \n\tint\t\t\t\ti;\n\tint\t\t\t\terror;\n\tstruct xfs_perag\t\t*pag = agbp->b_pag;\n\n\tbno_cur = cnt_cur = NULL;\n\tmp = tp->t_mountp;\n\n\tif (!xfs_rmap_should_skip_owner_update(oinfo)) {\n\t\terror = xfs_rmap_free(tp, agbp, pag, bno, len, oinfo);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t \n\tbno_cur = xfs_allocbt_init_cursor(mp, tp, agbp, pag, XFS_BTNUM_BNO);\n\t \n\tif ((error = xfs_alloc_lookup_le(bno_cur, bno, len, &haveleft)))\n\t\tgoto error0;\n\tif (haveleft) {\n\t\t \n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &ltbno, &ltlen, &i)))\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\t\t \n\t\tif (ltbno + ltlen < bno)\n\t\t\thaveleft = 0;\n\t\telse {\n\t\t\t \n\t\t\tif (XFS_IS_CORRUPT(mp, ltbno + ltlen > bno)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif ((error = xfs_btree_increment(bno_cur, 0, &haveright)))\n\t\tgoto error0;\n\tif (haveright) {\n\t\t \n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &gtbno, &gtlen, &i)))\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\t\t \n\t\tif (bno + len < gtbno)\n\t\t\thaveright = 0;\n\t\telse {\n\t\t\t \n\t\t\tif (XFS_IS_CORRUPT(mp, bno + len > gtbno)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tcnt_cur = xfs_allocbt_init_cursor(mp, tp, agbp, pag, XFS_BTNUM_CNT);\n\t \n\tif (haveleft && haveright) {\n\t\t \n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, ltbno, ltlen, &i)))\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\t\t \n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, gtbno, gtlen, &i)))\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\t\t \n\t\tif ((error = xfs_btree_delete(bno_cur, &i)))\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\t\t \n\t\tif ((error = xfs_btree_decrement(bno_cur, 0, &i)))\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n#ifdef DEBUG\n\t\t \n\t\t{\n\t\t\txfs_agblock_t\txxbno;\n\t\t\txfs_extlen_t\txxlen;\n\n\t\t\tif ((error = xfs_alloc_get_rec(bno_cur, &xxbno, &xxlen,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto error0;\n\t\t\tif (XFS_IS_CORRUPT(mp,\n\t\t\t\t\t   i != 1 ||\n\t\t\t\t\t   xxbno != ltbno ||\n\t\t\t\t\t   xxlen != ltlen)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t}\n#endif\n\t\t \n\t\tnbno = ltbno;\n\t\tnlen = len + ltlen + gtlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t \n\telse if (haveleft) {\n\t\t \n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, ltbno, ltlen, &i)))\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\t\t \n\t\tif ((error = xfs_btree_decrement(bno_cur, 0, &i)))\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\t\tnbno = ltbno;\n\t\tnlen = len + ltlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t \n\telse if (haveright) {\n\t\t \n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, gtbno, gtlen, &i)))\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\t\t \n\t\tnbno = bno;\n\t\tnlen = len + gtlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t \n\telse {\n\t\tnbno = bno;\n\t\tnlen = len;\n\t\tif ((error = xfs_btree_insert(bno_cur, &i)))\n\t\t\tgoto error0;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto error0;\n\t\t}\n\t}\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\tbno_cur = NULL;\n\t \n\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nbno, nlen, &i)))\n\t\tgoto error0;\n\tif (XFS_IS_CORRUPT(mp, i != 0)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\tgoto error0;\n\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\tcnt_cur = NULL;\n\n\t \n\terror = xfs_alloc_update_counters(tp, agbp, len);\n\txfs_ag_resv_free_extent(agbp->b_pag, type, tp, len);\n\tif (error)\n\t\tgoto error0;\n\n\tXFS_STATS_INC(mp, xs_freex);\n\tXFS_STATS_ADD(mp, xs_freeb, len);\n\n\ttrace_xfs_free_extent(mp, agno, bno, len, type, haveleft, haveright);\n\n\treturn 0;\n\n error0:\n\ttrace_xfs_free_extent(mp, agno, bno, len, type, -1, -1);\n\tif (bno_cur)\n\t\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\tif (cnt_cur)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\treturn error;\n}\n\n \n\n \nvoid\nxfs_alloc_compute_maxlevels(\n\txfs_mount_t\t*mp)\t \n{\n\tmp->m_alloc_maxlevels = xfs_btree_compute_maxlevels(mp->m_alloc_mnr,\n\t\t\t(mp->m_sb.sb_agblocks + 1) / 2);\n\tASSERT(mp->m_alloc_maxlevels <= xfs_allocbt_maxlevels_ondisk());\n}\n\n \nxfs_extlen_t\nxfs_alloc_longest_free_extent(\n\tstruct xfs_perag\t*pag,\n\txfs_extlen_t\t\tneed,\n\txfs_extlen_t\t\treserved)\n{\n\txfs_extlen_t\t\tdelta = 0;\n\n\t \n\tif (need > pag->pagf_flcount)\n\t\tdelta = need - pag->pagf_flcount;\n\n\t \n\tif (pag->pagf_freeblks - pag->pagf_longest < reserved)\n\t\tdelta += reserved - (pag->pagf_freeblks - pag->pagf_longest);\n\n\t \n\tif (pag->pagf_longest > delta)\n\t\treturn min_t(xfs_extlen_t, pag->pag_mount->m_ag_max_usable,\n\t\t\t\tpag->pagf_longest - delta);\n\n\t \n\treturn pag->pagf_flcount > 0 || pag->pagf_longest > 0;\n}\n\n \nunsigned int\nxfs_alloc_min_freelist(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag)\n{\n\t \n\tstatic const uint8_t\tfake_levels[XFS_BTNUM_AGF] = {1, 1, 1};\n\tconst uint8_t\t\t*levels = pag ? pag->pagf_levels : fake_levels;\n\tunsigned int\t\tmin_free;\n\n\tASSERT(mp->m_alloc_maxlevels > 0);\n\n\t \n\tmin_free = min_t(unsigned int, levels[XFS_BTNUM_BNOi] + 1,\n\t\t\t\t       mp->m_alloc_maxlevels);\n\t \n\tmin_free += min_t(unsigned int, levels[XFS_BTNUM_CNTi] + 1,\n\t\t\t\t       mp->m_alloc_maxlevels);\n\t \n\tif (xfs_has_rmapbt(mp))\n\t\tmin_free += min_t(unsigned int, levels[XFS_BTNUM_RMAPi] + 1,\n\t\t\t\t\t\tmp->m_rmap_maxlevels);\n\n\treturn min_free;\n}\n\n \nstatic bool\nxfs_alloc_space_available(\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\tmin_free,\n\tint\t\t\tflags)\n{\n\tstruct xfs_perag\t*pag = args->pag;\n\txfs_extlen_t\t\talloc_len, longest;\n\txfs_extlen_t\t\treservation;  \n\tint\t\t\tavailable;\n\txfs_extlen_t\t\tagflcount;\n\n\tif (flags & XFS_ALLOC_FLAG_FREEING)\n\t\treturn true;\n\n\treservation = xfs_ag_resv_needed(pag, args->resv);\n\n\t \n\talloc_len = args->minlen + (args->alignment - 1) + args->minalignslop;\n\tlongest = xfs_alloc_longest_free_extent(pag, min_free, reservation);\n\tif (longest < alloc_len)\n\t\treturn false;\n\n\t \n\tagflcount = min_t(xfs_extlen_t, pag->pagf_flcount, min_free);\n\tavailable = (int)(pag->pagf_freeblks + agflcount -\n\t\t\t  reservation - min_free - args->minleft);\n\tif (available < (int)max(args->total, alloc_len))\n\t\treturn false;\n\n\t \n\tif (available < (int)args->maxlen && !(flags & XFS_ALLOC_FLAG_CHECK)) {\n\t\targs->maxlen = available;\n\t\tASSERT(args->maxlen > 0);\n\t\tASSERT(args->maxlen >= args->minlen);\n\t}\n\n\treturn true;\n}\n\nint\nxfs_free_agfl_block(\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tagbno,\n\tstruct xfs_buf\t\t*agbp,\n\tstruct xfs_owner_info\t*oinfo)\n{\n\tint\t\t\terror;\n\tstruct xfs_buf\t\t*bp;\n\n\terror = xfs_free_ag_extent(tp, agbp, agno, agbno, 1, oinfo,\n\t\t\t\t   XFS_AG_RESV_AGFL);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_trans_get_buf(tp, tp->t_mountp->m_ddev_targp,\n\t\t\tXFS_AGB_TO_DADDR(tp->t_mountp, agno, agbno),\n\t\t\ttp->t_mountp->m_bsize, 0, &bp);\n\tif (error)\n\t\treturn error;\n\txfs_trans_binval(tp, bp);\n\n\treturn 0;\n}\n\n \nstatic bool\nxfs_agfl_needs_reset(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_agf\t\t*agf)\n{\n\tuint32_t\t\tf = be32_to_cpu(agf->agf_flfirst);\n\tuint32_t\t\tl = be32_to_cpu(agf->agf_fllast);\n\tuint32_t\t\tc = be32_to_cpu(agf->agf_flcount);\n\tint\t\t\tagfl_size = xfs_agfl_size(mp);\n\tint\t\t\tactive;\n\n\t \n\tif (f >= agfl_size || l >= agfl_size)\n\t\treturn true;\n\tif (c > agfl_size)\n\t\treturn true;\n\n\t \n\tif (c && l >= f)\n\t\tactive = l - f + 1;\n\telse if (c)\n\t\tactive = agfl_size - f + l + 1;\n\telse\n\t\tactive = 0;\n\n\treturn active != c;\n}\n\n \nstatic void\nxfs_agfl_reset(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\tstruct xfs_perag\t*pag)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_agf\t\t*agf = agbp->b_addr;\n\n\tASSERT(xfs_perag_agfl_needs_reset(pag));\n\ttrace_xfs_agfl_reset(mp, agf, 0, _RET_IP_);\n\n\txfs_warn(mp,\n\t       \"WARNING: Reset corrupted AGFL on AG %u. %d blocks leaked. \"\n\t       \"Please unmount and run xfs_repair.\",\n\t         pag->pag_agno, pag->pagf_flcount);\n\n\tagf->agf_flfirst = 0;\n\tagf->agf_fllast = cpu_to_be32(xfs_agfl_size(mp) - 1);\n\tagf->agf_flcount = 0;\n\txfs_alloc_log_agf(tp, agbp, XFS_AGF_FLFIRST | XFS_AGF_FLLAST |\n\t\t\t\t    XFS_AGF_FLCOUNT);\n\n\tpag->pagf_flcount = 0;\n\tclear_bit(XFS_AGSTATE_AGFL_NEEDS_RESET, &pag->pag_opstate);\n}\n\n \nstatic int\nxfs_defer_agfl_block(\n\tstruct xfs_trans\t\t*tp,\n\txfs_agnumber_t\t\t\tagno,\n\txfs_agblock_t\t\t\tagbno,\n\tstruct xfs_owner_info\t\t*oinfo)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_extent_free_item\t*xefi;\n\txfs_fsblock_t\t\t\tfsbno = XFS_AGB_TO_FSB(mp, agno, agbno);\n\n\tASSERT(xfs_extfree_item_cache != NULL);\n\tASSERT(oinfo != NULL);\n\n\tif (XFS_IS_CORRUPT(mp, !xfs_verify_fsbno(mp, fsbno)))\n\t\treturn -EFSCORRUPTED;\n\n\txefi = kmem_cache_zalloc(xfs_extfree_item_cache,\n\t\t\t       GFP_KERNEL | __GFP_NOFAIL);\n\txefi->xefi_startblock = fsbno;\n\txefi->xefi_blockcount = 1;\n\txefi->xefi_owner = oinfo->oi_owner;\n\txefi->xefi_agresv = XFS_AG_RESV_AGFL;\n\n\ttrace_xfs_agfl_free_defer(mp, agno, 0, agbno, 1);\n\n\txfs_extent_free_get_group(mp, xefi);\n\txfs_defer_add(tp, XFS_DEFER_OPS_TYPE_AGFL_FREE, &xefi->xefi_list);\n\treturn 0;\n}\n\n \nint\n__xfs_free_extent_later(\n\tstruct xfs_trans\t\t*tp,\n\txfs_fsblock_t\t\t\tbno,\n\txfs_filblks_t\t\t\tlen,\n\tconst struct xfs_owner_info\t*oinfo,\n\tenum xfs_ag_resv_type\t\ttype,\n\tbool\t\t\t\tskip_discard)\n{\n\tstruct xfs_extent_free_item\t*xefi;\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n#ifdef DEBUG\n\txfs_agnumber_t\t\t\tagno;\n\txfs_agblock_t\t\t\tagbno;\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(len > 0);\n\tASSERT(len <= XFS_MAX_BMBT_EXTLEN);\n\tASSERT(!isnullstartblock(bno));\n\tagno = XFS_FSB_TO_AGNO(mp, bno);\n\tagbno = XFS_FSB_TO_AGBNO(mp, bno);\n\tASSERT(agno < mp->m_sb.sb_agcount);\n\tASSERT(agbno < mp->m_sb.sb_agblocks);\n\tASSERT(len < mp->m_sb.sb_agblocks);\n\tASSERT(agbno + len <= mp->m_sb.sb_agblocks);\n#endif\n\tASSERT(xfs_extfree_item_cache != NULL);\n\tASSERT(type != XFS_AG_RESV_AGFL);\n\n\tif (XFS_IS_CORRUPT(mp, !xfs_verify_fsbext(mp, bno, len)))\n\t\treturn -EFSCORRUPTED;\n\n\txefi = kmem_cache_zalloc(xfs_extfree_item_cache,\n\t\t\t       GFP_KERNEL | __GFP_NOFAIL);\n\txefi->xefi_startblock = bno;\n\txefi->xefi_blockcount = (xfs_extlen_t)len;\n\txefi->xefi_agresv = type;\n\tif (skip_discard)\n\t\txefi->xefi_flags |= XFS_EFI_SKIP_DISCARD;\n\tif (oinfo) {\n\t\tASSERT(oinfo->oi_offset == 0);\n\n\t\tif (oinfo->oi_flags & XFS_OWNER_INFO_ATTR_FORK)\n\t\t\txefi->xefi_flags |= XFS_EFI_ATTR_FORK;\n\t\tif (oinfo->oi_flags & XFS_OWNER_INFO_BMBT_BLOCK)\n\t\t\txefi->xefi_flags |= XFS_EFI_BMBT_BLOCK;\n\t\txefi->xefi_owner = oinfo->oi_owner;\n\t} else {\n\t\txefi->xefi_owner = XFS_RMAP_OWN_NULL;\n\t}\n\ttrace_xfs_bmap_free_defer(mp,\n\t\t\tXFS_FSB_TO_AGNO(tp->t_mountp, bno), 0,\n\t\t\tXFS_FSB_TO_AGBNO(tp->t_mountp, bno), len);\n\n\txfs_extent_free_get_group(mp, xefi);\n\txfs_defer_add(tp, XFS_DEFER_OPS_TYPE_FREE, &xefi->xefi_list);\n\treturn 0;\n}\n\n#ifdef DEBUG\n \nSTATIC int\nxfs_exact_minlen_extent_available(\n\tstruct xfs_alloc_arg\t*args,\n\tstruct xfs_buf\t\t*agbp,\n\tint\t\t\t*stat)\n{\n\tstruct xfs_btree_cur\t*cnt_cur;\n\txfs_agblock_t\t\tfbno;\n\txfs_extlen_t\t\tflen;\n\tint\t\t\terror = 0;\n\n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, agbp,\n\t\t\t\t\targs->pag, XFS_BTNUM_CNT);\n\terror = xfs_alloc_lookup_ge(cnt_cur, 0, args->minlen, stat);\n\tif (error)\n\t\tgoto out;\n\n\tif (*stat == 0) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\n\terror = xfs_alloc_get_rec(cnt_cur, &fbno, &flen, stat);\n\tif (error)\n\t\tgoto out;\n\n\tif (*stat == 1 && flen != args->minlen)\n\t\t*stat = 0;\n\nout:\n\txfs_btree_del_cursor(cnt_cur, error);\n\n\treturn error;\n}\n#endif\n\n \nint\t\t\t \nxfs_alloc_fix_freelist(\n\tstruct xfs_alloc_arg\t*args,\t \n\tuint32_t\t\talloc_flags)\n{\n\tstruct xfs_mount\t*mp = args->mp;\n\tstruct xfs_perag\t*pag = args->pag;\n\tstruct xfs_trans\t*tp = args->tp;\n\tstruct xfs_buf\t\t*agbp = NULL;\n\tstruct xfs_buf\t\t*agflbp = NULL;\n\tstruct xfs_alloc_arg\ttargs;\t \n\txfs_agblock_t\t\tbno;\t \n\txfs_extlen_t\t\tneed;\t \n\tint\t\t\terror = 0;\n\n\t \n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\n\tif (!xfs_perag_initialised_agf(pag)) {\n\t\terror = xfs_alloc_read_agf(pag, tp, alloc_flags, &agbp);\n\t\tif (error) {\n\t\t\t \n\t\t\tif (error == -EAGAIN)\n\t\t\t\terror = 0;\n\t\t\tgoto out_no_agbp;\n\t\t}\n\t}\n\n\t \n\tif (xfs_perag_prefers_metadata(pag) &&\n\t    (args->datatype & XFS_ALLOC_USERDATA) &&\n\t    (alloc_flags & XFS_ALLOC_FLAG_TRYLOCK)) {\n\t\tASSERT(!(alloc_flags & XFS_ALLOC_FLAG_FREEING));\n\t\tgoto out_agbp_relse;\n\t}\n\n\tneed = xfs_alloc_min_freelist(mp, pag);\n\tif (!xfs_alloc_space_available(args, need, alloc_flags |\n\t\t\tXFS_ALLOC_FLAG_CHECK))\n\t\tgoto out_agbp_relse;\n\n\t \n\tif (!agbp) {\n\t\terror = xfs_alloc_read_agf(pag, tp, alloc_flags, &agbp);\n\t\tif (error) {\n\t\t\t \n\t\t\tif (error == -EAGAIN)\n\t\t\t\terror = 0;\n\t\t\tgoto out_no_agbp;\n\t\t}\n\t}\n\n\t \n\tif (xfs_perag_agfl_needs_reset(pag))\n\t\txfs_agfl_reset(tp, agbp, pag);\n\n\t \n\tneed = xfs_alloc_min_freelist(mp, pag);\n\tif (!xfs_alloc_space_available(args, need, alloc_flags))\n\t\tgoto out_agbp_relse;\n\n#ifdef DEBUG\n\tif (args->alloc_minlen_only) {\n\t\tint stat;\n\n\t\terror = xfs_exact_minlen_extent_available(args, agbp, &stat);\n\t\tif (error || !stat)\n\t\t\tgoto out_agbp_relse;\n\t}\n#endif\n\t \n\tmemset(&targs, 0, sizeof(targs));\n\t \n\tif (alloc_flags & XFS_ALLOC_FLAG_NORMAP)\n\t\ttargs.oinfo = XFS_RMAP_OINFO_SKIP_UPDATE;\n\telse\n\t\ttargs.oinfo = XFS_RMAP_OINFO_AG;\n\twhile (!(alloc_flags & XFS_ALLOC_FLAG_NOSHRINK) &&\n\t\t\tpag->pagf_flcount > need) {\n\t\terror = xfs_alloc_get_freelist(pag, tp, agbp, &bno, 0);\n\t\tif (error)\n\t\t\tgoto out_agbp_relse;\n\n\t\t \n\t\terror = xfs_defer_agfl_block(tp, args->agno, bno, &targs.oinfo);\n\t\tif (error)\n\t\t\tgoto out_agbp_relse;\n\t}\n\n\ttargs.tp = tp;\n\ttargs.mp = mp;\n\ttargs.agbp = agbp;\n\ttargs.agno = args->agno;\n\ttargs.alignment = targs.minlen = targs.prod = 1;\n\ttargs.pag = pag;\n\terror = xfs_alloc_read_agfl(pag, tp, &agflbp);\n\tif (error)\n\t\tgoto out_agbp_relse;\n\n\t \n\twhile (pag->pagf_flcount < need) {\n\t\ttargs.agbno = 0;\n\t\ttargs.maxlen = need - pag->pagf_flcount;\n\t\ttargs.resv = XFS_AG_RESV_AGFL;\n\n\t\t \n\t\terror = xfs_alloc_ag_vextent_size(&targs, alloc_flags);\n\t\tif (error)\n\t\t\tgoto out_agflbp_relse;\n\n\t\t \n\t\tif (targs.agbno == NULLAGBLOCK) {\n\t\t\tif (alloc_flags & XFS_ALLOC_FLAG_FREEING)\n\t\t\t\tbreak;\n\t\t\tgoto out_agflbp_relse;\n\t\t}\n\n\t\tif (!xfs_rmap_should_skip_owner_update(&targs.oinfo)) {\n\t\t\terror = xfs_rmap_alloc(tp, agbp, pag,\n\t\t\t\t       targs.agbno, targs.len, &targs.oinfo);\n\t\t\tif (error)\n\t\t\t\tgoto out_agflbp_relse;\n\t\t}\n\t\terror = xfs_alloc_update_counters(tp, agbp,\n\t\t\t\t\t\t  -((long)(targs.len)));\n\t\tif (error)\n\t\t\tgoto out_agflbp_relse;\n\n\t\t \n\t\tfor (bno = targs.agbno; bno < targs.agbno + targs.len; bno++) {\n\t\t\terror = xfs_alloc_put_freelist(pag, tp, agbp,\n\t\t\t\t\t\t\tagflbp, bno, 0);\n\t\t\tif (error)\n\t\t\t\tgoto out_agflbp_relse;\n\t\t}\n\t}\n\txfs_trans_brelse(tp, agflbp);\n\targs->agbp = agbp;\n\treturn 0;\n\nout_agflbp_relse:\n\txfs_trans_brelse(tp, agflbp);\nout_agbp_relse:\n\tif (agbp)\n\t\txfs_trans_brelse(tp, agbp);\nout_no_agbp:\n\targs->agbp = NULL;\n\treturn error;\n}\n\n \nint\nxfs_alloc_get_freelist(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\txfs_agblock_t\t\t*bnop,\n\tint\t\t\tbtreeblk)\n{\n\tstruct xfs_agf\t\t*agf = agbp->b_addr;\n\tstruct xfs_buf\t\t*agflbp;\n\txfs_agblock_t\t\tbno;\n\t__be32\t\t\t*agfl_bno;\n\tint\t\t\terror;\n\tuint32_t\t\tlogflags;\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\n\t \n\tif (!agf->agf_flcount) {\n\t\t*bnop = NULLAGBLOCK;\n\t\treturn 0;\n\t}\n\t \n\terror = xfs_alloc_read_agfl(pag, tp, &agflbp);\n\tif (error)\n\t\treturn error;\n\n\n\t \n\tagfl_bno = xfs_buf_to_agfl_bno(agflbp);\n\tbno = be32_to_cpu(agfl_bno[be32_to_cpu(agf->agf_flfirst)]);\n\tif (XFS_IS_CORRUPT(tp->t_mountp, !xfs_verify_agbno(pag, bno)))\n\t\treturn -EFSCORRUPTED;\n\n\tbe32_add_cpu(&agf->agf_flfirst, 1);\n\txfs_trans_brelse(tp, agflbp);\n\tif (be32_to_cpu(agf->agf_flfirst) == xfs_agfl_size(mp))\n\t\tagf->agf_flfirst = 0;\n\n\tASSERT(!xfs_perag_agfl_needs_reset(pag));\n\tbe32_add_cpu(&agf->agf_flcount, -1);\n\tpag->pagf_flcount--;\n\n\tlogflags = XFS_AGF_FLFIRST | XFS_AGF_FLCOUNT;\n\tif (btreeblk) {\n\t\tbe32_add_cpu(&agf->agf_btreeblks, 1);\n\t\tpag->pagf_btreeblks++;\n\t\tlogflags |= XFS_AGF_BTREEBLKS;\n\t}\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\t*bnop = bno;\n\n\treturn 0;\n}\n\n \nvoid\nxfs_alloc_log_agf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tuint32_t\t\tfields)\n{\n\tint\tfirst;\t\t \n\tint\tlast;\t\t \n\tstatic const short\toffsets[] = {\n\t\toffsetof(xfs_agf_t, agf_magicnum),\n\t\toffsetof(xfs_agf_t, agf_versionnum),\n\t\toffsetof(xfs_agf_t, agf_seqno),\n\t\toffsetof(xfs_agf_t, agf_length),\n\t\toffsetof(xfs_agf_t, agf_roots[0]),\n\t\toffsetof(xfs_agf_t, agf_levels[0]),\n\t\toffsetof(xfs_agf_t, agf_flfirst),\n\t\toffsetof(xfs_agf_t, agf_fllast),\n\t\toffsetof(xfs_agf_t, agf_flcount),\n\t\toffsetof(xfs_agf_t, agf_freeblks),\n\t\toffsetof(xfs_agf_t, agf_longest),\n\t\toffsetof(xfs_agf_t, agf_btreeblks),\n\t\toffsetof(xfs_agf_t, agf_uuid),\n\t\toffsetof(xfs_agf_t, agf_rmap_blocks),\n\t\toffsetof(xfs_agf_t, agf_refcount_blocks),\n\t\toffsetof(xfs_agf_t, agf_refcount_root),\n\t\toffsetof(xfs_agf_t, agf_refcount_level),\n\t\t \n\t\toffsetof(xfs_agf_t, agf_spare64),\n\t\tsizeof(xfs_agf_t)\n\t};\n\n\ttrace_xfs_agf(tp->t_mountp, bp->b_addr, fields, _RET_IP_);\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGF_BUF);\n\n\txfs_btree_offsets(fields, offsets, XFS_AGF_NUM_BITS, &first, &last);\n\txfs_trans_log_buf(tp, bp, (uint)first, (uint)last);\n}\n\n \nint\nxfs_alloc_put_freelist(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*agbp,\n\tstruct xfs_buf\t\t*agflbp,\n\txfs_agblock_t\t\tbno,\n\tint\t\t\tbtreeblk)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_agf\t\t*agf = agbp->b_addr;\n\t__be32\t\t\t*blockp;\n\tint\t\t\terror;\n\tuint32_t\t\tlogflags;\n\t__be32\t\t\t*agfl_bno;\n\tint\t\t\tstartoff;\n\n\tif (!agflbp) {\n\t\terror = xfs_alloc_read_agfl(pag, tp, &agflbp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tbe32_add_cpu(&agf->agf_fllast, 1);\n\tif (be32_to_cpu(agf->agf_fllast) == xfs_agfl_size(mp))\n\t\tagf->agf_fllast = 0;\n\n\tASSERT(!xfs_perag_agfl_needs_reset(pag));\n\tbe32_add_cpu(&agf->agf_flcount, 1);\n\tpag->pagf_flcount++;\n\n\tlogflags = XFS_AGF_FLLAST | XFS_AGF_FLCOUNT;\n\tif (btreeblk) {\n\t\tbe32_add_cpu(&agf->agf_btreeblks, -1);\n\t\tpag->pagf_btreeblks--;\n\t\tlogflags |= XFS_AGF_BTREEBLKS;\n\t}\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\n\tASSERT(be32_to_cpu(agf->agf_flcount) <= xfs_agfl_size(mp));\n\n\tagfl_bno = xfs_buf_to_agfl_bno(agflbp);\n\tblockp = &agfl_bno[be32_to_cpu(agf->agf_fllast)];\n\t*blockp = cpu_to_be32(bno);\n\tstartoff = (char *)blockp - (char *)agflbp->b_addr;\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\n\txfs_trans_buf_set_type(tp, agflbp, XFS_BLFT_AGFL_BUF);\n\txfs_trans_log_buf(tp, agflbp, startoff,\n\t\t\t  startoff + sizeof(xfs_agblock_t) - 1);\n\treturn 0;\n}\n\n \nxfs_failaddr_t\nxfs_validate_ag_length(\n\tstruct xfs_buf\t\t*bp,\n\tuint32_t\t\tseqno,\n\tuint32_t\t\tlength)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\t \n\tif (bp->b_pag && seqno != bp->b_pag->pag_agno)\n\t\treturn __this_address;\n\n\t \n\tif (length != mp->m_sb.sb_agblocks) {\n\t\t \n\t\tif (bp->b_pag && seqno != mp->m_sb.sb_agcount - 1)\n\t\t\treturn __this_address;\n\t\tif (length < XFS_MIN_AG_BLOCKS)\n\t\t\treturn __this_address;\n\t\tif (length > mp->m_sb.sb_agblocks)\n\t\t\treturn __this_address;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic xfs_failaddr_t\nxfs_agf_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_agf\t\t*agf = bp->b_addr;\n\txfs_failaddr_t\t\tfa;\n\tuint32_t\t\tagf_seqno = be32_to_cpu(agf->agf_seqno);\n\tuint32_t\t\tagf_length = be32_to_cpu(agf->agf_length);\n\n\tif (xfs_has_crc(mp)) {\n\t\tif (!uuid_equal(&agf->agf_uuid, &mp->m_sb.sb_meta_uuid))\n\t\t\treturn __this_address;\n\t\tif (!xfs_log_check_lsn(mp, be64_to_cpu(agf->agf_lsn)))\n\t\t\treturn __this_address;\n\t}\n\n\tif (!xfs_verify_magic(bp, agf->agf_magicnum))\n\t\treturn __this_address;\n\n\tif (!XFS_AGF_GOOD_VERSION(be32_to_cpu(agf->agf_versionnum)))\n\t\treturn __this_address;\n\n\t \n\tfa = xfs_validate_ag_length(bp, agf_seqno, agf_length);\n\tif (fa)\n\t\treturn fa;\n\n\tif (be32_to_cpu(agf->agf_flfirst) >= xfs_agfl_size(mp))\n\t\treturn __this_address;\n\tif (be32_to_cpu(agf->agf_fllast) >= xfs_agfl_size(mp))\n\t\treturn __this_address;\n\tif (be32_to_cpu(agf->agf_flcount) > xfs_agfl_size(mp))\n\t\treturn __this_address;\n\n\tif (be32_to_cpu(agf->agf_freeblks) < be32_to_cpu(agf->agf_longest) ||\n\t    be32_to_cpu(agf->agf_freeblks) > agf_length)\n\t\treturn __this_address;\n\n\tif (be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) < 1 ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) < 1 ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) >\n\t\t\t\t\t\tmp->m_alloc_maxlevels ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) >\n\t\t\t\t\t\tmp->m_alloc_maxlevels)\n\t\treturn __this_address;\n\n\tif (xfs_has_lazysbcount(mp) &&\n\t    be32_to_cpu(agf->agf_btreeblks) > agf_length)\n\t\treturn __this_address;\n\n\tif (xfs_has_rmapbt(mp)) {\n\t\tif (be32_to_cpu(agf->agf_rmap_blocks) > agf_length)\n\t\t\treturn __this_address;\n\n\t\tif (be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) < 1 ||\n\t\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) >\n\t\t\t\t\t\t\tmp->m_rmap_maxlevels)\n\t\t\treturn __this_address;\n\t}\n\n\tif (xfs_has_reflink(mp)) {\n\t\tif (be32_to_cpu(agf->agf_refcount_blocks) > agf_length)\n\t\t\treturn __this_address;\n\n\t\tif (be32_to_cpu(agf->agf_refcount_level) < 1 ||\n\t\t    be32_to_cpu(agf->agf_refcount_level) > mp->m_refc_maxlevels)\n\t\t\treturn __this_address;\n\t}\n\n\treturn NULL;\n}\n\nstatic void\nxfs_agf_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_mount;\n\txfs_failaddr_t\tfa;\n\n\tif (xfs_has_crc(mp) &&\n\t    !xfs_buf_verify_cksum(bp, XFS_AGF_CRC_OFF))\n\t\txfs_verifier_error(bp, -EFSBADCRC, __this_address);\n\telse {\n\t\tfa = xfs_agf_verify(bp);\n\t\tif (XFS_TEST_ERROR(fa, mp, XFS_ERRTAG_ALLOC_READ_AGF))\n\t\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t}\n}\n\nstatic void\nxfs_agf_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_log_item;\n\tstruct xfs_agf\t\t*agf = bp->b_addr;\n\txfs_failaddr_t\t\tfa;\n\n\tfa = xfs_agf_verify(bp);\n\tif (fa) {\n\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t\treturn;\n\t}\n\n\tif (!xfs_has_crc(mp))\n\t\treturn;\n\n\tif (bip)\n\t\tagf->agf_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_AGF_CRC_OFF);\n}\n\nconst struct xfs_buf_ops xfs_agf_buf_ops = {\n\t.name = \"xfs_agf\",\n\t.magic = { cpu_to_be32(XFS_AGF_MAGIC), cpu_to_be32(XFS_AGF_MAGIC) },\n\t.verify_read = xfs_agf_read_verify,\n\t.verify_write = xfs_agf_write_verify,\n\t.verify_struct = xfs_agf_verify,\n};\n\n \nint\nxfs_read_agf(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\tint\t\t\tflags,\n\tstruct xfs_buf\t\t**agfbpp)\n{\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\tint\t\t\terror;\n\n\ttrace_xfs_read_agf(pag->pag_mount, pag->pag_agno);\n\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, pag->pag_agno, XFS_AGF_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), flags, agfbpp, &xfs_agf_buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_buf_set_ref(*agfbpp, XFS_AGF_REF);\n\treturn 0;\n}\n\n \nint\nxfs_alloc_read_agf(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\tint\t\t\tflags,\n\tstruct xfs_buf\t\t**agfbpp)\n{\n\tstruct xfs_buf\t\t*agfbp;\n\tstruct xfs_agf\t\t*agf;\n\tint\t\t\terror;\n\tint\t\t\tallocbt_blks;\n\n\ttrace_xfs_alloc_read_agf(pag->pag_mount, pag->pag_agno);\n\n\t \n\tASSERT((flags & (XFS_ALLOC_FLAG_FREEING | XFS_ALLOC_FLAG_TRYLOCK)) !=\n\t\t\t(XFS_ALLOC_FLAG_FREEING | XFS_ALLOC_FLAG_TRYLOCK));\n\terror = xfs_read_agf(pag, tp,\n\t\t\t(flags & XFS_ALLOC_FLAG_TRYLOCK) ? XBF_TRYLOCK : 0,\n\t\t\t&agfbp);\n\tif (error)\n\t\treturn error;\n\n\tagf = agfbp->b_addr;\n\tif (!xfs_perag_initialised_agf(pag)) {\n\t\tpag->pagf_freeblks = be32_to_cpu(agf->agf_freeblks);\n\t\tpag->pagf_btreeblks = be32_to_cpu(agf->agf_btreeblks);\n\t\tpag->pagf_flcount = be32_to_cpu(agf->agf_flcount);\n\t\tpag->pagf_longest = be32_to_cpu(agf->agf_longest);\n\t\tpag->pagf_levels[XFS_BTNUM_BNOi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]);\n\t\tpag->pagf_levels[XFS_BTNUM_CNTi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]);\n\t\tpag->pagf_levels[XFS_BTNUM_RMAPi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAPi]);\n\t\tpag->pagf_refcount_level = be32_to_cpu(agf->agf_refcount_level);\n\t\tif (xfs_agfl_needs_reset(pag->pag_mount, agf))\n\t\t\tset_bit(XFS_AGSTATE_AGFL_NEEDS_RESET, &pag->pag_opstate);\n\t\telse\n\t\t\tclear_bit(XFS_AGSTATE_AGFL_NEEDS_RESET, &pag->pag_opstate);\n\n\t\t \n\t\tallocbt_blks = pag->pagf_btreeblks;\n\t\tif (xfs_has_rmapbt(pag->pag_mount))\n\t\t\tallocbt_blks -= be32_to_cpu(agf->agf_rmap_blocks) - 1;\n\t\tif (allocbt_blks > 0)\n\t\t\tatomic64_add(allocbt_blks,\n\t\t\t\t\t&pag->pag_mount->m_allocbt_blks);\n\n\t\tset_bit(XFS_AGSTATE_AGF_INIT, &pag->pag_opstate);\n\t}\n#ifdef DEBUG\n\telse if (!xfs_is_shutdown(pag->pag_mount)) {\n\t\tASSERT(pag->pagf_freeblks == be32_to_cpu(agf->agf_freeblks));\n\t\tASSERT(pag->pagf_btreeblks == be32_to_cpu(agf->agf_btreeblks));\n\t\tASSERT(pag->pagf_flcount == be32_to_cpu(agf->agf_flcount));\n\t\tASSERT(pag->pagf_longest == be32_to_cpu(agf->agf_longest));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_BNOi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_CNTi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]));\n\t}\n#endif\n\tif (agfbpp)\n\t\t*agfbpp = agfbp;\n\telse\n\t\txfs_trans_brelse(tp, agfbp);\n\treturn 0;\n}\n\n \nstatic int\nxfs_alloc_vextent_check_args(\n\tstruct xfs_alloc_arg\t*args,\n\txfs_fsblock_t\t\ttarget,\n\txfs_agnumber_t\t\t*minimum_agno)\n{\n\tstruct xfs_mount\t*mp = args->mp;\n\txfs_agblock_t\t\tagsize;\n\n\targs->fsbno = NULLFSBLOCK;\n\n\t*minimum_agno = 0;\n\tif (args->tp->t_highest_agno != NULLAGNUMBER)\n\t\t*minimum_agno = args->tp->t_highest_agno;\n\n\t \n\tagsize = mp->m_sb.sb_agblocks;\n\tif (args->maxlen > agsize)\n\t\targs->maxlen = agsize;\n\tif (args->alignment == 0)\n\t\targs->alignment = 1;\n\n\tASSERT(args->minlen > 0);\n\tASSERT(args->maxlen > 0);\n\tASSERT(args->alignment > 0);\n\tASSERT(args->resv != XFS_AG_RESV_AGFL);\n\n\tASSERT(XFS_FSB_TO_AGNO(mp, target) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, target) < agsize);\n\tASSERT(args->minlen <= args->maxlen);\n\tASSERT(args->minlen <= agsize);\n\tASSERT(args->mod < args->prod);\n\n\tif (XFS_FSB_TO_AGNO(mp, target) >= mp->m_sb.sb_agcount ||\n\t    XFS_FSB_TO_AGBNO(mp, target) >= agsize ||\n\t    args->minlen > args->maxlen || args->minlen > agsize ||\n\t    args->mod >= args->prod) {\n\t\ttrace_xfs_alloc_vextent_badargs(args);\n\t\treturn -ENOSPC;\n\t}\n\n\tif (args->agno != NULLAGNUMBER && *minimum_agno > args->agno) {\n\t\ttrace_xfs_alloc_vextent_skip_deadlock(args);\n\t\treturn -ENOSPC;\n\t}\n\treturn 0;\n\n}\n\n \nstatic int\nxfs_alloc_vextent_prepare_ag(\n\tstruct xfs_alloc_arg\t*args,\n\tuint32_t\t\talloc_flags)\n{\n\tbool\t\t\tneed_pag = !args->pag;\n\tint\t\t\terror;\n\n\tif (need_pag)\n\t\targs->pag = xfs_perag_get(args->mp, args->agno);\n\n\targs->agbp = NULL;\n\terror = xfs_alloc_fix_freelist(args, alloc_flags);\n\tif (error) {\n\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\tif (need_pag)\n\t\t\txfs_perag_put(args->pag);\n\t\targs->agbno = NULLAGBLOCK;\n\t\treturn error;\n\t}\n\tif (!args->agbp) {\n\t\t \n\t\ttrace_xfs_alloc_vextent_noagbp(args);\n\t\targs->agbno = NULLAGBLOCK;\n\t\treturn 0;\n\t}\n\targs->wasfromfl = 0;\n\treturn 0;\n}\n\n \nstatic int\nxfs_alloc_vextent_finish(\n\tstruct xfs_alloc_arg\t*args,\n\txfs_agnumber_t\t\tminimum_agno,\n\tint\t\t\talloc_error,\n\tbool\t\t\tdrop_perag)\n{\n\tstruct xfs_mount\t*mp = args->mp;\n\tint\t\t\terror = 0;\n\n\t \n\tif (args->agbp &&\n\t    (args->tp->t_highest_agno == NULLAGNUMBER ||\n\t     args->agno > minimum_agno))\n\t\targs->tp->t_highest_agno = args->agno;\n\n\t \n\tif (alloc_error || args->agbno == NULLAGBLOCK) {\n\t\targs->fsbno = NULLFSBLOCK;\n\t\terror = alloc_error;\n\t\tgoto out_drop_perag;\n\t}\n\n\targs->fsbno = XFS_AGB_TO_FSB(mp, args->agno, args->agbno);\n\n\tASSERT(args->len >= args->minlen);\n\tASSERT(args->len <= args->maxlen);\n\tASSERT(args->agbno % args->alignment == 0);\n\tXFS_AG_CHECK_DADDR(mp, XFS_FSB_TO_DADDR(mp, args->fsbno), args->len);\n\n\t \n\tif (!xfs_rmap_should_skip_owner_update(&args->oinfo)) {\n\t\terror = xfs_rmap_alloc(args->tp, args->agbp, args->pag,\n\t\t\t\t       args->agbno, args->len, &args->oinfo);\n\t\tif (error)\n\t\t\tgoto out_drop_perag;\n\t}\n\n\tif (!args->wasfromfl) {\n\t\terror = xfs_alloc_update_counters(args->tp, args->agbp,\n\t\t\t\t\t\t  -((long)(args->len)));\n\t\tif (error)\n\t\t\tgoto out_drop_perag;\n\n\t\tASSERT(!xfs_extent_busy_search(mp, args->pag, args->agbno,\n\t\t\t\targs->len));\n\t}\n\n\txfs_ag_resv_alloc_extent(args->pag, args->resv, args);\n\n\tXFS_STATS_INC(mp, xs_allocx);\n\tXFS_STATS_ADD(mp, xs_allocb, args->len);\n\n\ttrace_xfs_alloc_vextent_finish(args);\n\nout_drop_perag:\n\tif (drop_perag && args->pag) {\n\t\txfs_perag_rele(args->pag);\n\t\targs->pag = NULL;\n\t}\n\treturn error;\n}\n\n \nint\nxfs_alloc_vextent_this_ag(\n\tstruct xfs_alloc_arg\t*args,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_mount\t*mp = args->mp;\n\txfs_agnumber_t\t\tminimum_agno;\n\tuint32_t\t\talloc_flags = 0;\n\tint\t\t\terror;\n\n\tASSERT(args->pag != NULL);\n\tASSERT(args->pag->pag_agno == agno);\n\n\targs->agno = agno;\n\targs->agbno = 0;\n\n\ttrace_xfs_alloc_vextent_this_ag(args);\n\n\terror = xfs_alloc_vextent_check_args(args, XFS_AGB_TO_FSB(mp, agno, 0),\n\t\t\t&minimum_agno);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\treturn 0;\n\t\treturn error;\n\t}\n\n\terror = xfs_alloc_vextent_prepare_ag(args, alloc_flags);\n\tif (!error && args->agbp)\n\t\terror = xfs_alloc_ag_vextent_size(args, alloc_flags);\n\n\treturn xfs_alloc_vextent_finish(args, minimum_agno, error, false);\n}\n\n \nstatic int\nxfs_alloc_vextent_iterate_ags(\n\tstruct xfs_alloc_arg\t*args,\n\txfs_agnumber_t\t\tminimum_agno,\n\txfs_agnumber_t\t\tstart_agno,\n\txfs_agblock_t\t\ttarget_agbno,\n\tuint32_t\t\talloc_flags)\n{\n\tstruct xfs_mount\t*mp = args->mp;\n\txfs_agnumber_t\t\trestart_agno = minimum_agno;\n\txfs_agnumber_t\t\tagno;\n\tint\t\t\terror = 0;\n\n\tif (alloc_flags & XFS_ALLOC_FLAG_TRYLOCK)\n\t\trestart_agno = 0;\nrestart:\n\tfor_each_perag_wrap_range(mp, start_agno, restart_agno,\n\t\t\tmp->m_sb.sb_agcount, agno, args->pag) {\n\t\targs->agno = agno;\n\t\terror = xfs_alloc_vextent_prepare_ag(args, alloc_flags);\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (!args->agbp) {\n\t\t\ttrace_xfs_alloc_vextent_loopfailed(args);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (args->agno == start_agno && target_agbno) {\n\t\t\targs->agbno = target_agbno;\n\t\t\terror = xfs_alloc_ag_vextent_near(args, alloc_flags);\n\t\t} else {\n\t\t\targs->agbno = 0;\n\t\t\terror = xfs_alloc_ag_vextent_size(args, alloc_flags);\n\t\t}\n\t\tbreak;\n\t}\n\tif (error) {\n\t\txfs_perag_rele(args->pag);\n\t\targs->pag = NULL;\n\t\treturn error;\n\t}\n\tif (args->agbp)\n\t\treturn 0;\n\n\t \n\tif (alloc_flags & XFS_ALLOC_FLAG_TRYLOCK) {\n\t\talloc_flags &= ~XFS_ALLOC_FLAG_TRYLOCK;\n\t\trestart_agno = minimum_agno;\n\t\tgoto restart;\n\t}\n\n\tASSERT(args->pag == NULL);\n\ttrace_xfs_alloc_vextent_allfailed(args);\n\treturn 0;\n}\n\n \nint\nxfs_alloc_vextent_start_ag(\n\tstruct xfs_alloc_arg\t*args,\n\txfs_fsblock_t\t\ttarget)\n{\n\tstruct xfs_mount\t*mp = args->mp;\n\txfs_agnumber_t\t\tminimum_agno;\n\txfs_agnumber_t\t\tstart_agno;\n\txfs_agnumber_t\t\trotorstep = xfs_rotorstep;\n\tbool\t\t\tbump_rotor = false;\n\tuint32_t\t\talloc_flags = XFS_ALLOC_FLAG_TRYLOCK;\n\tint\t\t\terror;\n\n\tASSERT(args->pag == NULL);\n\n\targs->agno = NULLAGNUMBER;\n\targs->agbno = NULLAGBLOCK;\n\n\ttrace_xfs_alloc_vextent_start_ag(args);\n\n\terror = xfs_alloc_vextent_check_args(args, target, &minimum_agno);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\treturn 0;\n\t\treturn error;\n\t}\n\n\tif ((args->datatype & XFS_ALLOC_INITIAL_USER_DATA) &&\n\t    xfs_is_inode32(mp)) {\n\t\ttarget = XFS_AGB_TO_FSB(mp,\n\t\t\t\t((mp->m_agfrotor / rotorstep) %\n\t\t\t\tmp->m_sb.sb_agcount), 0);\n\t\tbump_rotor = 1;\n\t}\n\n\tstart_agno = max(minimum_agno, XFS_FSB_TO_AGNO(mp, target));\n\terror = xfs_alloc_vextent_iterate_ags(args, minimum_agno, start_agno,\n\t\t\tXFS_FSB_TO_AGBNO(mp, target), alloc_flags);\n\n\tif (bump_rotor) {\n\t\tif (args->agno == start_agno)\n\t\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\telse\n\t\t\tmp->m_agfrotor = (args->agno * rotorstep + 1) %\n\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t}\n\n\treturn xfs_alloc_vextent_finish(args, minimum_agno, error, true);\n}\n\n \nint\nxfs_alloc_vextent_first_ag(\n\tstruct xfs_alloc_arg\t*args,\n\txfs_fsblock_t\t\ttarget)\n {\n\tstruct xfs_mount\t*mp = args->mp;\n\txfs_agnumber_t\t\tminimum_agno;\n\txfs_agnumber_t\t\tstart_agno;\n\tuint32_t\t\talloc_flags = XFS_ALLOC_FLAG_TRYLOCK;\n\tint\t\t\terror;\n\n\tASSERT(args->pag == NULL);\n\n\targs->agno = NULLAGNUMBER;\n\targs->agbno = NULLAGBLOCK;\n\n\ttrace_xfs_alloc_vextent_first_ag(args);\n\n\terror = xfs_alloc_vextent_check_args(args, target, &minimum_agno);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\treturn 0;\n\t\treturn error;\n\t}\n\n\tstart_agno = max(minimum_agno, XFS_FSB_TO_AGNO(mp, target));\n\terror = xfs_alloc_vextent_iterate_ags(args, minimum_agno, start_agno,\n\t\t\tXFS_FSB_TO_AGBNO(mp, target), alloc_flags);\n\treturn xfs_alloc_vextent_finish(args, minimum_agno, error, true);\n}\n\n \nint\nxfs_alloc_vextent_exact_bno(\n\tstruct xfs_alloc_arg\t*args,\n\txfs_fsblock_t\t\ttarget)\n{\n\tstruct xfs_mount\t*mp = args->mp;\n\txfs_agnumber_t\t\tminimum_agno;\n\tint\t\t\terror;\n\n\tASSERT(args->pag != NULL);\n\tASSERT(args->pag->pag_agno == XFS_FSB_TO_AGNO(mp, target));\n\n\targs->agno = XFS_FSB_TO_AGNO(mp, target);\n\targs->agbno = XFS_FSB_TO_AGBNO(mp, target);\n\n\ttrace_xfs_alloc_vextent_exact_bno(args);\n\n\terror = xfs_alloc_vextent_check_args(args, target, &minimum_agno);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\treturn 0;\n\t\treturn error;\n\t}\n\n\terror = xfs_alloc_vextent_prepare_ag(args, 0);\n\tif (!error && args->agbp)\n\t\terror = xfs_alloc_ag_vextent_exact(args);\n\n\treturn xfs_alloc_vextent_finish(args, minimum_agno, error, false);\n}\n\n \nint\nxfs_alloc_vextent_near_bno(\n\tstruct xfs_alloc_arg\t*args,\n\txfs_fsblock_t\t\ttarget)\n{\n\tstruct xfs_mount\t*mp = args->mp;\n\txfs_agnumber_t\t\tminimum_agno;\n\tbool\t\t\tneeds_perag = args->pag == NULL;\n\tuint32_t\t\talloc_flags = 0;\n\tint\t\t\terror;\n\n\tif (!needs_perag)\n\t\tASSERT(args->pag->pag_agno == XFS_FSB_TO_AGNO(mp, target));\n\n\targs->agno = XFS_FSB_TO_AGNO(mp, target);\n\targs->agbno = XFS_FSB_TO_AGBNO(mp, target);\n\n\ttrace_xfs_alloc_vextent_near_bno(args);\n\n\terror = xfs_alloc_vextent_check_args(args, target, &minimum_agno);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\treturn 0;\n\t\treturn error;\n\t}\n\n\tif (needs_perag)\n\t\targs->pag = xfs_perag_grab(mp, args->agno);\n\n\terror = xfs_alloc_vextent_prepare_ag(args, alloc_flags);\n\tif (!error && args->agbp)\n\t\terror = xfs_alloc_ag_vextent_near(args, alloc_flags);\n\n\treturn xfs_alloc_vextent_finish(args, minimum_agno, error, needs_perag);\n}\n\n \nint\nxfs_free_extent_fix_freelist(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_buf\t\t**agbp)\n{\n\tstruct xfs_alloc_arg\targs;\n\tint\t\t\terror;\n\n\tmemset(&args, 0, sizeof(struct xfs_alloc_arg));\n\targs.tp = tp;\n\targs.mp = tp->t_mountp;\n\targs.agno = pag->pag_agno;\n\targs.pag = pag;\n\n\t \n\tif (args.agno >= args.mp->m_sb.sb_agcount)\n\t\treturn -EFSCORRUPTED;\n\n\terror = xfs_alloc_fix_freelist(&args, XFS_ALLOC_FLAG_FREEING);\n\tif (error)\n\t\treturn error;\n\n\t*agbp = args.agbp;\n\treturn 0;\n}\n\n \nint\n__xfs_free_extent(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_perag\t\t*pag,\n\txfs_agblock_t\t\t\tagbno,\n\txfs_extlen_t\t\t\tlen,\n\tconst struct xfs_owner_info\t*oinfo,\n\tenum xfs_ag_resv_type\t\ttype,\n\tbool\t\t\t\tskip_discard)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_buf\t\t\t*agbp;\n\tstruct xfs_agf\t\t\t*agf;\n\tint\t\t\t\terror;\n\tunsigned int\t\t\tbusy_flags = 0;\n\n\tASSERT(len != 0);\n\tASSERT(type != XFS_AG_RESV_AGFL);\n\n\tif (XFS_TEST_ERROR(false, mp,\n\t\t\tXFS_ERRTAG_FREE_EXTENT))\n\t\treturn -EIO;\n\n\terror = xfs_free_extent_fix_freelist(tp, pag, &agbp);\n\tif (error)\n\t\treturn error;\n\tagf = agbp->b_addr;\n\n\tif (XFS_IS_CORRUPT(mp, agbno >= mp->m_sb.sb_agblocks)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto err_release;\n\t}\n\n\t \n\tif (XFS_IS_CORRUPT(mp, agbno + len > be32_to_cpu(agf->agf_length))) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto err_release;\n\t}\n\n\terror = xfs_free_ag_extent(tp, agbp, pag->pag_agno, agbno, len, oinfo,\n\t\t\ttype);\n\tif (error)\n\t\tgoto err_release;\n\n\tif (skip_discard)\n\t\tbusy_flags |= XFS_EXTENT_BUSY_SKIP_DISCARD;\n\txfs_extent_busy_insert(tp, pag, agbno, len, busy_flags);\n\treturn 0;\n\nerr_release:\n\txfs_trans_brelse(tp, agbp);\n\treturn error;\n}\n\nstruct xfs_alloc_query_range_info {\n\txfs_alloc_query_range_fn\tfn;\n\tvoid\t\t\t\t*priv;\n};\n\n \nSTATIC int\nxfs_alloc_query_range_helper(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst union xfs_btree_rec\t*rec,\n\tvoid\t\t\t\t*priv)\n{\n\tstruct xfs_alloc_query_range_info\t*query = priv;\n\tstruct xfs_alloc_rec_incore\t\tirec;\n\txfs_failaddr_t\t\t\t\tfa;\n\n\txfs_alloc_btrec_to_irec(rec, &irec);\n\tfa = xfs_alloc_check_irec(cur, &irec);\n\tif (fa)\n\t\treturn xfs_alloc_complain_bad_rec(cur, fa, &irec);\n\n\treturn query->fn(cur, &irec, query->priv);\n}\n\n \nint\nxfs_alloc_query_range(\n\tstruct xfs_btree_cur\t\t\t*cur,\n\tconst struct xfs_alloc_rec_incore\t*low_rec,\n\tconst struct xfs_alloc_rec_incore\t*high_rec,\n\txfs_alloc_query_range_fn\t\tfn,\n\tvoid\t\t\t\t\t*priv)\n{\n\tunion xfs_btree_irec\t\t\tlow_brec = { .a = *low_rec };\n\tunion xfs_btree_irec\t\t\thigh_brec = { .a = *high_rec };\n\tstruct xfs_alloc_query_range_info\tquery = { .priv = priv, .fn = fn };\n\n\tASSERT(cur->bc_btnum == XFS_BTNUM_BNO);\n\treturn xfs_btree_query_range(cur, &low_brec, &high_brec,\n\t\t\txfs_alloc_query_range_helper, &query);\n}\n\n \nint\nxfs_alloc_query_all(\n\tstruct xfs_btree_cur\t\t\t*cur,\n\txfs_alloc_query_range_fn\t\tfn,\n\tvoid\t\t\t\t\t*priv)\n{\n\tstruct xfs_alloc_query_range_info\tquery;\n\n\tASSERT(cur->bc_btnum == XFS_BTNUM_BNO);\n\tquery.priv = priv;\n\tquery.fn = fn;\n\treturn xfs_btree_query_all(cur, xfs_alloc_query_range_helper, &query);\n}\n\n \nint\nxfs_alloc_has_records(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\tenum xbtree_recpacking\t*outcome)\n{\n\tunion xfs_btree_irec\tlow;\n\tunion xfs_btree_irec\thigh;\n\n\tmemset(&low, 0, sizeof(low));\n\tlow.a.ar_startblock = bno;\n\tmemset(&high, 0xFF, sizeof(high));\n\thigh.a.ar_startblock = bno + len - 1;\n\n\treturn xfs_btree_has_records(cur, &low, &high, NULL, outcome);\n}\n\n \nint\nxfs_agfl_walk(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_agf\t\t*agf,\n\tstruct xfs_buf\t\t*agflbp,\n\txfs_agfl_walk_fn\twalk_fn,\n\tvoid\t\t\t*priv)\n{\n\t__be32\t\t\t*agfl_bno;\n\tunsigned int\t\ti;\n\tint\t\t\terror;\n\n\tagfl_bno = xfs_buf_to_agfl_bno(agflbp);\n\ti = be32_to_cpu(agf->agf_flfirst);\n\n\t \n\tif (agf->agf_flcount == cpu_to_be32(0))\n\t\treturn 0;\n\n\t \n\tfor (;;) {\n\t\terror = walk_fn(mp, be32_to_cpu(agfl_bno[i]), priv);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (i == be32_to_cpu(agf->agf_fllast))\n\t\t\tbreak;\n\t\tif (++i == xfs_agfl_size(mp))\n\t\t\ti = 0;\n\t}\n\n\treturn 0;\n}\n\nint __init\nxfs_extfree_intent_init_cache(void)\n{\n\txfs_extfree_item_cache = kmem_cache_create(\"xfs_extfree_intent\",\n\t\t\tsizeof(struct xfs_extent_free_item),\n\t\t\t0, 0, NULL);\n\n\treturn xfs_extfree_item_cache != NULL ? 0 : -ENOMEM;\n}\n\nvoid\nxfs_extfree_intent_destroy_cache(void)\n{\n\tkmem_cache_destroy(xfs_extfree_item_cache);\n\txfs_extfree_item_cache = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}