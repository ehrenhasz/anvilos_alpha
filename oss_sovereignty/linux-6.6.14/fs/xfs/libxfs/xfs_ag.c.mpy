{
  "module_name": "xfs_ag.c",
  "hash_id": "cf738a7bd64e506a35faacf80c354bb952673d48bba1ad6405eeb8ff54f97380",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_ag.c",
  "human_readable_source": " \n \n\n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_rmap_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_ag_resv.h\"\n#include \"xfs_health.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_icache.h\"\n\n\n \nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\ttrace_xfs_perag_get(pag, _RET_IP_);\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tatomic_inc(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\treturn pag;\n}\n\n \nstruct xfs_perag *\nxfs_perag_get_tag(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tfirst,\n\tunsigned int\t\ttag)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tfound;\n\n\trcu_read_lock();\n\tfound = radix_tree_gang_lookup_tag(&mp->m_perag_tree,\n\t\t\t\t\t(void **)&pag, first, 1, tag);\n\tif (found <= 0) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\ttrace_xfs_perag_get_tag(pag, _RET_IP_);\n\tatomic_inc(&pag->pag_ref);\n\trcu_read_unlock();\n\treturn pag;\n}\n\n \nstruct xfs_perag *\nxfs_perag_hold(\n\tstruct xfs_perag\t*pag)\n{\n\tASSERT(atomic_read(&pag->pag_ref) > 0 ||\n\t       atomic_read(&pag->pag_active_ref) > 0);\n\n\ttrace_xfs_perag_hold(pag, _RET_IP_);\n\tatomic_inc(&pag->pag_ref);\n\treturn pag;\n}\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\ttrace_xfs_perag_put(pag, _RET_IP_);\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tatomic_dec(&pag->pag_ref);\n}\n\n \nstruct xfs_perag *\nxfs_perag_grab(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\ttrace_xfs_perag_grab(pag, _RET_IP_);\n\t\tif (!atomic_inc_not_zero(&pag->pag_active_ref))\n\t\t\tpag = NULL;\n\t}\n\trcu_read_unlock();\n\treturn pag;\n}\n\n \nstruct xfs_perag *\nxfs_perag_grab_tag(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tfirst,\n\tint\t\t\ttag)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tfound;\n\n\trcu_read_lock();\n\tfound = radix_tree_gang_lookup_tag(&mp->m_perag_tree,\n\t\t\t\t\t(void **)&pag, first, 1, tag);\n\tif (found <= 0) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\ttrace_xfs_perag_grab_tag(pag, _RET_IP_);\n\tif (!atomic_inc_not_zero(&pag->pag_active_ref))\n\t\tpag = NULL;\n\trcu_read_unlock();\n\treturn pag;\n}\n\nvoid\nxfs_perag_rele(\n\tstruct xfs_perag\t*pag)\n{\n\ttrace_xfs_perag_rele(pag, _RET_IP_);\n\tif (atomic_dec_and_test(&pag->pag_active_ref))\n\t\twake_up(&pag->pag_active_wq);\n}\n\n \nint\nxfs_initialize_perag_data(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagcount)\n{\n\txfs_agnumber_t\t\tindex;\n\tstruct xfs_perag\t*pag;\n\tstruct xfs_sb\t\t*sbp = &mp->m_sb;\n\tuint64_t\t\tifree = 0;\n\tuint64_t\t\tialloc = 0;\n\tuint64_t\t\tbfree = 0;\n\tuint64_t\t\tbfreelst = 0;\n\tuint64_t\t\tbtree = 0;\n\tuint64_t\t\tfdblocks;\n\tint\t\t\terror = 0;\n\n\tfor (index = 0; index < agcount; index++) {\n\t\t \n\t\tpag = xfs_perag_get(mp, index);\n\t\terror = xfs_alloc_read_agf(pag, NULL, 0, NULL);\n\t\tif (!error)\n\t\t\terror = xfs_ialloc_read_agi(pag, NULL, NULL);\n\t\tif (error) {\n\t\t\txfs_perag_put(pag);\n\t\t\treturn error;\n\t\t}\n\n\t\tifree += pag->pagi_freecount;\n\t\tialloc += pag->pagi_count;\n\t\tbfree += pag->pagf_freeblks;\n\t\tbfreelst += pag->pagf_flcount;\n\t\tbtree += pag->pagf_btreeblks;\n\t\txfs_perag_put(pag);\n\t}\n\tfdblocks = bfree + bfreelst + btree;\n\n\t \n\tif (fdblocks > sbp->sb_dblocks || ifree > ialloc) {\n\t\txfs_alert(mp, \"AGF corruption. Please run xfs_repair.\");\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\n\t \n\tspin_lock(&mp->m_sb_lock);\n\tsbp->sb_ifree = ifree;\n\tsbp->sb_icount = ialloc;\n\tsbp->sb_fdblocks = fdblocks;\n\tspin_unlock(&mp->m_sb_lock);\n\n\txfs_reinit_percpu_counters(mp);\nout:\n\txfs_fs_mark_healthy(mp, XFS_SICK_FS_COUNTERS);\n\treturn error;\n}\n\nSTATIC void\n__xfs_free_perag(\n\tstruct rcu_head\t*head)\n{\n\tstruct xfs_perag *pag = container_of(head, struct xfs_perag, rcu_head);\n\n\tASSERT(!delayed_work_pending(&pag->pag_blockgc_work));\n\tkmem_free(pag);\n}\n\n \nvoid\nxfs_free_perag(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_perag\t*pag;\n\txfs_agnumber_t\t\tagno;\n\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\tspin_lock(&mp->m_perag_lock);\n\t\tpag = radix_tree_delete(&mp->m_perag_tree, agno);\n\t\tspin_unlock(&mp->m_perag_lock);\n\t\tASSERT(pag);\n\t\tXFS_IS_CORRUPT(pag->pag_mount, atomic_read(&pag->pag_ref) != 0);\n\t\txfs_defer_drain_free(&pag->pag_intents_drain);\n\n\t\tcancel_delayed_work_sync(&pag->pag_blockgc_work);\n\t\txfs_buf_hash_destroy(pag);\n\n\t\t \n\t\txfs_perag_rele(pag);\n\t\tXFS_IS_CORRUPT(pag->pag_mount,\n\t\t\t\tatomic_read(&pag->pag_active_ref) != 0);\n\t\tcall_rcu(&pag->rcu_head, __xfs_free_perag);\n\t}\n}\n\n \nstatic xfs_agblock_t\n__xfs_ag_block_count(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agnumber_t\t\tagcount,\n\txfs_rfsblock_t\t\tdblocks)\n{\n\tASSERT(agno < agcount);\n\n\tif (agno < agcount - 1)\n\t\treturn mp->m_sb.sb_agblocks;\n\treturn dblocks - (agno * mp->m_sb.sb_agblocks);\n}\n\nxfs_agblock_t\nxfs_ag_block_count(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\treturn __xfs_ag_block_count(mp, agno, mp->m_sb.sb_agcount,\n\t\t\tmp->m_sb.sb_dblocks);\n}\n\n \nstatic void\n__xfs_agino_range(\n\tstruct xfs_mount\t*mp,\n\txfs_agblock_t\t\teoag,\n\txfs_agino_t\t\t*first,\n\txfs_agino_t\t\t*last)\n{\n\txfs_agblock_t\t\tbno;\n\n\t \n\tbno = round_up(XFS_AGFL_BLOCK(mp) + 1, M_IGEO(mp)->cluster_align);\n\t*first = XFS_AGB_TO_AGINO(mp, bno);\n\n\t \n\tbno = round_down(eoag, M_IGEO(mp)->cluster_align);\n\t*last = XFS_AGB_TO_AGINO(mp, bno) - 1;\n}\n\nvoid\nxfs_agino_range(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agino_t\t\t*first,\n\txfs_agino_t\t\t*last)\n{\n\treturn __xfs_agino_range(mp, xfs_ag_block_count(mp, agno), first, last);\n}\n\nint\nxfs_initialize_perag(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagcount,\n\txfs_rfsblock_t\t\tdblocks,\n\txfs_agnumber_t\t\t*maxagi)\n{\n\tstruct xfs_perag\t*pag;\n\txfs_agnumber_t\t\tindex;\n\txfs_agnumber_t\t\tfirst_initialised = NULLAGNUMBER;\n\tint\t\t\terror;\n\n\t \n\tfor (index = 0; index < agcount; index++) {\n\t\tpag = xfs_perag_get(mp, index);\n\t\tif (pag) {\n\t\t\txfs_perag_put(pag);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpag = kmem_zalloc(sizeof(*pag), KM_MAYFAIL);\n\t\tif (!pag) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out_unwind_new_pags;\n\t\t}\n\t\tpag->pag_agno = index;\n\t\tpag->pag_mount = mp;\n\n\t\terror = radix_tree_preload(GFP_NOFS);\n\t\tif (error)\n\t\t\tgoto out_free_pag;\n\n\t\tspin_lock(&mp->m_perag_lock);\n\t\tif (radix_tree_insert(&mp->m_perag_tree, index, pag)) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tspin_unlock(&mp->m_perag_lock);\n\t\t\tradix_tree_preload_end();\n\t\t\terror = -EEXIST;\n\t\t\tgoto out_free_pag;\n\t\t}\n\t\tspin_unlock(&mp->m_perag_lock);\n\t\tradix_tree_preload_end();\n\n#ifdef __KERNEL__\n\t\t \n\t\tspin_lock_init(&pag->pag_ici_lock);\n\t\tspin_lock_init(&pag->pagb_lock);\n\t\tspin_lock_init(&pag->pag_state_lock);\n\t\tINIT_DELAYED_WORK(&pag->pag_blockgc_work, xfs_blockgc_worker);\n\t\tINIT_RADIX_TREE(&pag->pag_ici_root, GFP_ATOMIC);\n\t\txfs_defer_drain_init(&pag->pag_intents_drain);\n\t\tinit_waitqueue_head(&pag->pagb_wait);\n\t\tinit_waitqueue_head(&pag->pag_active_wq);\n\t\tpag->pagb_count = 0;\n\t\tpag->pagb_tree = RB_ROOT;\n#endif  \n\n\t\terror = xfs_buf_hash_init(pag);\n\t\tif (error)\n\t\t\tgoto out_remove_pag;\n\n\t\t \n\t\tatomic_set(&pag->pag_active_ref, 1);\n\n\t\t \n\t\tif (first_initialised == NULLAGNUMBER)\n\t\t\tfirst_initialised = index;\n\n\t\t \n\t\tpag->block_count = __xfs_ag_block_count(mp, index, agcount,\n\t\t\t\tdblocks);\n\t\tpag->min_block = XFS_AGFL_BLOCK(mp);\n\t\t__xfs_agino_range(mp, pag->block_count, &pag->agino_min,\n\t\t\t\t&pag->agino_max);\n\t}\n\n\tindex = xfs_set_inode_alloc(mp, agcount);\n\n\tif (maxagi)\n\t\t*maxagi = index;\n\n\tmp->m_ag_prealloc_blocks = xfs_prealloc_blocks(mp);\n\treturn 0;\n\nout_remove_pag:\n\txfs_defer_drain_free(&pag->pag_intents_drain);\n\tradix_tree_delete(&mp->m_perag_tree, index);\nout_free_pag:\n\tkmem_free(pag);\nout_unwind_new_pags:\n\t \n\tfor (index = first_initialised; index < agcount; index++) {\n\t\tpag = radix_tree_delete(&mp->m_perag_tree, index);\n\t\tif (!pag)\n\t\t\tbreak;\n\t\txfs_buf_hash_destroy(pag);\n\t\txfs_defer_drain_free(&pag->pag_intents_drain);\n\t\tkmem_free(pag);\n\t}\n\treturn error;\n}\n\nstatic int\nxfs_get_aghdr_buf(\n\tstruct xfs_mount\t*mp,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\terror = xfs_buf_get_uncached(mp->m_ddev_targp, numblks, 0, &bp);\n\tif (error)\n\t\treturn error;\n\n\tbp->b_maps[0].bm_bn = blkno;\n\tbp->b_ops = ops;\n\n\t*bpp = bp;\n\treturn 0;\n}\n\n \nstatic void\nxfs_btroot_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct aghdr_init_data\t*id)\n{\n\txfs_btree_init_block(mp, bp, id->type, 0, 0, id->agno);\n}\n\n \nstatic void\nxfs_freesp_init_recs(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct aghdr_init_data\t*id)\n{\n\tstruct xfs_alloc_rec\t*arec;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\n\tarec = XFS_ALLOC_REC_ADDR(mp, XFS_BUF_TO_BLOCK(bp), 1);\n\tarec->ar_startblock = cpu_to_be32(mp->m_ag_prealloc_blocks);\n\n\tif (xfs_ag_contains_log(mp, id->agno)) {\n\t\tstruct xfs_alloc_rec\t*nrec;\n\t\txfs_agblock_t\t\tstart = XFS_FSB_TO_AGBNO(mp,\n\t\t\t\t\t\t\tmp->m_sb.sb_logstart);\n\n\t\tASSERT(start >= mp->m_ag_prealloc_blocks);\n\t\tif (start != mp->m_ag_prealloc_blocks) {\n\t\t\t \n\t\t\tarec->ar_blockcount = cpu_to_be32(start -\n\t\t\t\t\t\tmp->m_ag_prealloc_blocks);\n\t\t\tbe16_add_cpu(&block->bb_numrecs, 1);\n\t\t\tnrec = arec + 1;\n\n\t\t\t \n\t\t\tnrec->ar_startblock = cpu_to_be32(\n\t\t\t\t\tbe32_to_cpu(arec->ar_startblock) +\n\t\t\t\t\tbe32_to_cpu(arec->ar_blockcount));\n\t\t\tarec = nrec;\n\t\t}\n\t\t \n\t\tbe32_add_cpu(&arec->ar_startblock, mp->m_sb.sb_logblocks);\n\t}\n\n\t \n\tarec->ar_blockcount = cpu_to_be32(id->agsize -\n\t\t\t\t\t  be32_to_cpu(arec->ar_startblock));\n\tif (arec->ar_blockcount)\n\t\tbe16_add_cpu(&block->bb_numrecs, 1);\n}\n\n \nstatic void\nxfs_bnoroot_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct aghdr_init_data\t*id)\n{\n\txfs_btree_init_block(mp, bp, XFS_BTNUM_BNO, 0, 0, id->agno);\n\txfs_freesp_init_recs(mp, bp, id);\n}\n\nstatic void\nxfs_cntroot_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct aghdr_init_data\t*id)\n{\n\txfs_btree_init_block(mp, bp, XFS_BTNUM_CNT, 0, 0, id->agno);\n\txfs_freesp_init_recs(mp, bp, id);\n}\n\n \nstatic void\nxfs_rmaproot_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct aghdr_init_data\t*id)\n{\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_rmap_rec\t*rrec;\n\n\txfs_btree_init_block(mp, bp, XFS_BTNUM_RMAP, 0, 4, id->agno);\n\n\t \n\trrec = XFS_RMAP_REC_ADDR(block, 1);\n\trrec->rm_startblock = 0;\n\trrec->rm_blockcount = cpu_to_be32(XFS_BNO_BLOCK(mp));\n\trrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_FS);\n\trrec->rm_offset = 0;\n\n\t \n\trrec = XFS_RMAP_REC_ADDR(block, 2);\n\trrec->rm_startblock = cpu_to_be32(XFS_BNO_BLOCK(mp));\n\trrec->rm_blockcount = cpu_to_be32(2);\n\trrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_AG);\n\trrec->rm_offset = 0;\n\n\t \n\trrec = XFS_RMAP_REC_ADDR(block, 3);\n\trrec->rm_startblock = cpu_to_be32(XFS_IBT_BLOCK(mp));\n\trrec->rm_blockcount = cpu_to_be32(XFS_RMAP_BLOCK(mp) -\n\t\t\t\t\t  XFS_IBT_BLOCK(mp));\n\trrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_INOBT);\n\trrec->rm_offset = 0;\n\n\t \n\trrec = XFS_RMAP_REC_ADDR(block, 4);\n\trrec->rm_startblock = cpu_to_be32(XFS_RMAP_BLOCK(mp));\n\trrec->rm_blockcount = cpu_to_be32(1);\n\trrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_AG);\n\trrec->rm_offset = 0;\n\n\t \n\tif (xfs_has_reflink(mp)) {\n\t\trrec = XFS_RMAP_REC_ADDR(block, 5);\n\t\trrec->rm_startblock = cpu_to_be32(xfs_refc_block(mp));\n\t\trrec->rm_blockcount = cpu_to_be32(1);\n\t\trrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_REFC);\n\t\trrec->rm_offset = 0;\n\t\tbe16_add_cpu(&block->bb_numrecs, 1);\n\t}\n\n\t \n\tif (xfs_ag_contains_log(mp, id->agno)) {\n\t\trrec = XFS_RMAP_REC_ADDR(block,\n\t\t\t\tbe16_to_cpu(block->bb_numrecs) + 1);\n\t\trrec->rm_startblock = cpu_to_be32(\n\t\t\t\tXFS_FSB_TO_AGBNO(mp, mp->m_sb.sb_logstart));\n\t\trrec->rm_blockcount = cpu_to_be32(mp->m_sb.sb_logblocks);\n\t\trrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_LOG);\n\t\trrec->rm_offset = 0;\n\t\tbe16_add_cpu(&block->bb_numrecs, 1);\n\t}\n}\n\n \nstatic void\nxfs_sbblock_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct aghdr_init_data\t*id)\n{\n\tstruct xfs_dsb\t\t*dsb = bp->b_addr;\n\n\txfs_sb_to_disk(dsb, &mp->m_sb);\n\tdsb->sb_inprogress = 1;\n}\n\nstatic void\nxfs_agfblock_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct aghdr_init_data\t*id)\n{\n\tstruct xfs_agf\t\t*agf = bp->b_addr;\n\txfs_extlen_t\t\ttmpsize;\n\n\tagf->agf_magicnum = cpu_to_be32(XFS_AGF_MAGIC);\n\tagf->agf_versionnum = cpu_to_be32(XFS_AGF_VERSION);\n\tagf->agf_seqno = cpu_to_be32(id->agno);\n\tagf->agf_length = cpu_to_be32(id->agsize);\n\tagf->agf_roots[XFS_BTNUM_BNOi] = cpu_to_be32(XFS_BNO_BLOCK(mp));\n\tagf->agf_roots[XFS_BTNUM_CNTi] = cpu_to_be32(XFS_CNT_BLOCK(mp));\n\tagf->agf_levels[XFS_BTNUM_BNOi] = cpu_to_be32(1);\n\tagf->agf_levels[XFS_BTNUM_CNTi] = cpu_to_be32(1);\n\tif (xfs_has_rmapbt(mp)) {\n\t\tagf->agf_roots[XFS_BTNUM_RMAPi] =\n\t\t\t\t\tcpu_to_be32(XFS_RMAP_BLOCK(mp));\n\t\tagf->agf_levels[XFS_BTNUM_RMAPi] = cpu_to_be32(1);\n\t\tagf->agf_rmap_blocks = cpu_to_be32(1);\n\t}\n\n\tagf->agf_flfirst = cpu_to_be32(1);\n\tagf->agf_fllast = 0;\n\tagf->agf_flcount = 0;\n\ttmpsize = id->agsize - mp->m_ag_prealloc_blocks;\n\tagf->agf_freeblks = cpu_to_be32(tmpsize);\n\tagf->agf_longest = cpu_to_be32(tmpsize);\n\tif (xfs_has_crc(mp))\n\t\tuuid_copy(&agf->agf_uuid, &mp->m_sb.sb_meta_uuid);\n\tif (xfs_has_reflink(mp)) {\n\t\tagf->agf_refcount_root = cpu_to_be32(\n\t\t\t\txfs_refc_block(mp));\n\t\tagf->agf_refcount_level = cpu_to_be32(1);\n\t\tagf->agf_refcount_blocks = cpu_to_be32(1);\n\t}\n\n\tif (xfs_ag_contains_log(mp, id->agno)) {\n\t\tint64_t\tlogblocks = mp->m_sb.sb_logblocks;\n\n\t\tbe32_add_cpu(&agf->agf_freeblks, -logblocks);\n\t\tagf->agf_longest = cpu_to_be32(id->agsize -\n\t\t\tXFS_FSB_TO_AGBNO(mp, mp->m_sb.sb_logstart) - logblocks);\n\t}\n}\n\nstatic void\nxfs_agflblock_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct aghdr_init_data\t*id)\n{\n\tstruct xfs_agfl\t\t*agfl = XFS_BUF_TO_AGFL(bp);\n\t__be32\t\t\t*agfl_bno;\n\tint\t\t\tbucket;\n\n\tif (xfs_has_crc(mp)) {\n\t\tagfl->agfl_magicnum = cpu_to_be32(XFS_AGFL_MAGIC);\n\t\tagfl->agfl_seqno = cpu_to_be32(id->agno);\n\t\tuuid_copy(&agfl->agfl_uuid, &mp->m_sb.sb_meta_uuid);\n\t}\n\n\tagfl_bno = xfs_buf_to_agfl_bno(bp);\n\tfor (bucket = 0; bucket < xfs_agfl_size(mp); bucket++)\n\t\tagfl_bno[bucket] = cpu_to_be32(NULLAGBLOCK);\n}\n\nstatic void\nxfs_agiblock_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct aghdr_init_data\t*id)\n{\n\tstruct xfs_agi\t\t*agi = bp->b_addr;\n\tint\t\t\tbucket;\n\n\tagi->agi_magicnum = cpu_to_be32(XFS_AGI_MAGIC);\n\tagi->agi_versionnum = cpu_to_be32(XFS_AGI_VERSION);\n\tagi->agi_seqno = cpu_to_be32(id->agno);\n\tagi->agi_length = cpu_to_be32(id->agsize);\n\tagi->agi_count = 0;\n\tagi->agi_root = cpu_to_be32(XFS_IBT_BLOCK(mp));\n\tagi->agi_level = cpu_to_be32(1);\n\tagi->agi_freecount = 0;\n\tagi->agi_newino = cpu_to_be32(NULLAGINO);\n\tagi->agi_dirino = cpu_to_be32(NULLAGINO);\n\tif (xfs_has_crc(mp))\n\t\tuuid_copy(&agi->agi_uuid, &mp->m_sb.sb_meta_uuid);\n\tif (xfs_has_finobt(mp)) {\n\t\tagi->agi_free_root = cpu_to_be32(XFS_FIBT_BLOCK(mp));\n\t\tagi->agi_free_level = cpu_to_be32(1);\n\t}\n\tfor (bucket = 0; bucket < XFS_AGI_UNLINKED_BUCKETS; bucket++)\n\t\tagi->agi_unlinked[bucket] = cpu_to_be32(NULLAGINO);\n\tif (xfs_has_inobtcounts(mp)) {\n\t\tagi->agi_iblocks = cpu_to_be32(1);\n\t\tif (xfs_has_finobt(mp))\n\t\t\tagi->agi_fblocks = cpu_to_be32(1);\n\t}\n}\n\ntypedef void (*aghdr_init_work_f)(struct xfs_mount *mp, struct xfs_buf *bp,\n\t\t\t\t  struct aghdr_init_data *id);\nstatic int\nxfs_ag_init_hdr(\n\tstruct xfs_mount\t*mp,\n\tstruct aghdr_init_data\t*id,\n\taghdr_init_work_f\twork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\terror = xfs_get_aghdr_buf(mp, id->daddr, id->numblks, &bp, ops);\n\tif (error)\n\t\treturn error;\n\n\t(*work)(mp, bp, id);\n\n\txfs_buf_delwri_queue(bp, &id->buffer_list);\n\txfs_buf_relse(bp);\n\treturn 0;\n}\n\nstruct xfs_aghdr_grow_data {\n\txfs_daddr_t\t\tdaddr;\n\tsize_t\t\t\tnumblks;\n\tconst struct xfs_buf_ops *ops;\n\taghdr_init_work_f\twork;\n\txfs_btnum_t\t\ttype;\n\tbool\t\t\tneed_init;\n};\n\n \nint\nxfs_ag_init_headers(\n\tstruct xfs_mount\t*mp,\n\tstruct aghdr_init_data\t*id)\n\n{\n\tstruct xfs_aghdr_grow_data aghdr_data[] = {\n\t{  \n\t\t.daddr = XFS_AG_DADDR(mp, id->agno, XFS_SB_DADDR),\n\t\t.numblks = XFS_FSS_TO_BB(mp, 1),\n\t\t.ops = &xfs_sb_buf_ops,\n\t\t.work = &xfs_sbblock_init,\n\t\t.need_init = true\n\t},\n\t{  \n\t\t.daddr = XFS_AG_DADDR(mp, id->agno, XFS_AGF_DADDR(mp)),\n\t\t.numblks = XFS_FSS_TO_BB(mp, 1),\n\t\t.ops = &xfs_agf_buf_ops,\n\t\t.work = &xfs_agfblock_init,\n\t\t.need_init = true\n\t},\n\t{  \n\t\t.daddr = XFS_AG_DADDR(mp, id->agno, XFS_AGFL_DADDR(mp)),\n\t\t.numblks = XFS_FSS_TO_BB(mp, 1),\n\t\t.ops = &xfs_agfl_buf_ops,\n\t\t.work = &xfs_agflblock_init,\n\t\t.need_init = true\n\t},\n\t{  \n\t\t.daddr = XFS_AG_DADDR(mp, id->agno, XFS_AGI_DADDR(mp)),\n\t\t.numblks = XFS_FSS_TO_BB(mp, 1),\n\t\t.ops = &xfs_agi_buf_ops,\n\t\t.work = &xfs_agiblock_init,\n\t\t.need_init = true\n\t},\n\t{  \n\t\t.daddr = XFS_AGB_TO_DADDR(mp, id->agno, XFS_BNO_BLOCK(mp)),\n\t\t.numblks = BTOBB(mp->m_sb.sb_blocksize),\n\t\t.ops = &xfs_bnobt_buf_ops,\n\t\t.work = &xfs_bnoroot_init,\n\t\t.need_init = true\n\t},\n\t{  \n\t\t.daddr = XFS_AGB_TO_DADDR(mp, id->agno, XFS_CNT_BLOCK(mp)),\n\t\t.numblks = BTOBB(mp->m_sb.sb_blocksize),\n\t\t.ops = &xfs_cntbt_buf_ops,\n\t\t.work = &xfs_cntroot_init,\n\t\t.need_init = true\n\t},\n\t{  \n\t\t.daddr = XFS_AGB_TO_DADDR(mp, id->agno, XFS_IBT_BLOCK(mp)),\n\t\t.numblks = BTOBB(mp->m_sb.sb_blocksize),\n\t\t.ops = &xfs_inobt_buf_ops,\n\t\t.work = &xfs_btroot_init,\n\t\t.type = XFS_BTNUM_INO,\n\t\t.need_init = true\n\t},\n\t{  \n\t\t.daddr = XFS_AGB_TO_DADDR(mp, id->agno, XFS_FIBT_BLOCK(mp)),\n\t\t.numblks = BTOBB(mp->m_sb.sb_blocksize),\n\t\t.ops = &xfs_finobt_buf_ops,\n\t\t.work = &xfs_btroot_init,\n\t\t.type = XFS_BTNUM_FINO,\n\t\t.need_init =  xfs_has_finobt(mp)\n\t},\n\t{  \n\t\t.daddr = XFS_AGB_TO_DADDR(mp, id->agno, XFS_RMAP_BLOCK(mp)),\n\t\t.numblks = BTOBB(mp->m_sb.sb_blocksize),\n\t\t.ops = &xfs_rmapbt_buf_ops,\n\t\t.work = &xfs_rmaproot_init,\n\t\t.need_init = xfs_has_rmapbt(mp)\n\t},\n\t{  \n\t\t.daddr = XFS_AGB_TO_DADDR(mp, id->agno, xfs_refc_block(mp)),\n\t\t.numblks = BTOBB(mp->m_sb.sb_blocksize),\n\t\t.ops = &xfs_refcountbt_buf_ops,\n\t\t.work = &xfs_btroot_init,\n\t\t.type = XFS_BTNUM_REFC,\n\t\t.need_init = xfs_has_reflink(mp)\n\t},\n\t{  \n\t\t.daddr = XFS_BUF_DADDR_NULL,\n\t}\n\t};\n\tstruct  xfs_aghdr_grow_data *dp;\n\tint\t\t\terror = 0;\n\n\t \n\tid->nfree += id->agsize - mp->m_ag_prealloc_blocks;\n\tfor (dp = &aghdr_data[0]; dp->daddr != XFS_BUF_DADDR_NULL; dp++) {\n\t\tif (!dp->need_init)\n\t\t\tcontinue;\n\n\t\tid->daddr = dp->daddr;\n\t\tid->numblks = dp->numblks;\n\t\tid->type = dp->type;\n\t\terror = xfs_ag_init_hdr(mp, id, dp->work, dp->ops);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\treturn error;\n}\n\nint\nxfs_ag_shrink_space(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t**tpp,\n\txfs_extlen_t\t\tdelta)\n{\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\tstruct xfs_alloc_arg\targs = {\n\t\t.tp\t= *tpp,\n\t\t.mp\t= mp,\n\t\t.pag\t= pag,\n\t\t.minlen = delta,\n\t\t.maxlen = delta,\n\t\t.oinfo\t= XFS_RMAP_OINFO_SKIP_UPDATE,\n\t\t.resv\t= XFS_AG_RESV_NONE,\n\t\t.prod\t= 1\n\t};\n\tstruct xfs_buf\t\t*agibp, *agfbp;\n\tstruct xfs_agi\t\t*agi;\n\tstruct xfs_agf\t\t*agf;\n\txfs_agblock_t\t\taglen;\n\tint\t\t\terror, err2;\n\n\tASSERT(pag->pag_agno == mp->m_sb.sb_agcount - 1);\n\terror = xfs_ialloc_read_agi(pag, *tpp, &agibp);\n\tif (error)\n\t\treturn error;\n\n\tagi = agibp->b_addr;\n\n\terror = xfs_alloc_read_agf(pag, *tpp, 0, &agfbp);\n\tif (error)\n\t\treturn error;\n\n\tagf = agfbp->b_addr;\n\taglen = be32_to_cpu(agi->agi_length);\n\t \n\tif (XFS_IS_CORRUPT(mp, agf->agf_length != agi->agi_length))\n\t\treturn -EFSCORRUPTED;\n\tif (delta >= aglen)\n\t\treturn -EINVAL;\n\n\t \n\terror = xfs_ialloc_check_shrink(pag, *tpp, agibp, aglen - delta);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = xfs_ag_resv_free(pag);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = xfs_alloc_vextent_exact_bno(&args,\n\t\t\tXFS_AGB_TO_FSB(mp, pag->pag_agno, aglen - delta));\n\tif (!error && args.agbno == NULLAGBLOCK)\n\t\terror = -ENOSPC;\n\n\tif (error) {\n\t\t \n\t\txfs_trans_bhold(*tpp, agfbp);\n\t\terr2 = xfs_trans_roll(tpp);\n\t\tif (err2)\n\t\t\treturn err2;\n\t\txfs_trans_bjoin(*tpp, agfbp);\n\t\tgoto resv_init_out;\n\t}\n\n\t \n\tbe32_add_cpu(&agi->agi_length, -delta);\n\tbe32_add_cpu(&agf->agf_length, -delta);\n\n\terr2 = xfs_ag_resv_init(pag, *tpp);\n\tif (err2) {\n\t\tbe32_add_cpu(&agi->agi_length, delta);\n\t\tbe32_add_cpu(&agf->agf_length, delta);\n\t\tif (err2 != -ENOSPC)\n\t\t\tgoto resv_err;\n\n\t\terr2 = __xfs_free_extent_later(*tpp, args.fsbno, delta, NULL,\n\t\t\t\tXFS_AG_RESV_NONE, true);\n\t\tif (err2)\n\t\t\tgoto resv_err;\n\n\t\t \n\t\terror = xfs_defer_finish(tpp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = -ENOSPC;\n\t\tgoto resv_init_out;\n\t}\n\n\t \n\tpag->block_count -= delta;\n\t__xfs_agino_range(pag->pag_mount, pag->block_count, &pag->agino_min,\n\t\t\t\t&pag->agino_max);\n\n\txfs_ialloc_log_agi(*tpp, agibp, XFS_AGI_LENGTH);\n\txfs_alloc_log_agf(*tpp, agfbp, XFS_AGF_LENGTH);\n\treturn 0;\n\nresv_init_out:\n\terr2 = xfs_ag_resv_init(pag, *tpp);\n\tif (!err2)\n\t\treturn error;\nresv_err:\n\txfs_warn(mp, \"Error %d reserving per-AG metadata reserve pool.\", err2);\n\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\treturn err2;\n}\n\n \nint\nxfs_ag_extend_space(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_trans\t*tp,\n\txfs_extlen_t\t\tlen)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_agi\t\t*agi;\n\tstruct xfs_agf\t\t*agf;\n\tint\t\t\terror;\n\n\tASSERT(pag->pag_agno == pag->pag_mount->m_sb.sb_agcount - 1);\n\n\terror = xfs_ialloc_read_agi(pag, tp, &bp);\n\tif (error)\n\t\treturn error;\n\n\tagi = bp->b_addr;\n\tbe32_add_cpu(&agi->agi_length, len);\n\txfs_ialloc_log_agi(tp, bp, XFS_AGI_LENGTH);\n\n\t \n\terror = xfs_alloc_read_agf(pag, tp, 0, &bp);\n\tif (error)\n\t\treturn error;\n\n\tagf = bp->b_addr;\n\tbe32_add_cpu(&agf->agf_length, len);\n\tASSERT(agf->agf_length == agi->agi_length);\n\txfs_alloc_log_agf(tp, bp, XFS_AGF_LENGTH);\n\n\t \n\terror = xfs_rmap_free(tp, bp, pag, be32_to_cpu(agf->agf_length) - len,\n\t\t\t\tlen, &XFS_RMAP_OINFO_SKIP_UPDATE);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_free_extent(tp, pag, be32_to_cpu(agf->agf_length) - len,\n\t\t\tlen, &XFS_RMAP_OINFO_SKIP_UPDATE, XFS_AG_RESV_NONE);\n\tif (error)\n\t\treturn error;\n\n\t \n\tpag->block_count = be32_to_cpu(agf->agf_length);\n\t__xfs_agino_range(pag->pag_mount, pag->block_count, &pag->agino_min,\n\t\t\t\t&pag->agino_max);\n\treturn 0;\n}\n\n \nint\nxfs_ag_get_geometry(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_ag_geometry\t*ageo)\n{\n\tstruct xfs_buf\t\t*agi_bp;\n\tstruct xfs_buf\t\t*agf_bp;\n\tstruct xfs_agi\t\t*agi;\n\tstruct xfs_agf\t\t*agf;\n\tunsigned int\t\tfreeblks;\n\tint\t\t\terror;\n\n\t \n\terror = xfs_ialloc_read_agi(pag, NULL, &agi_bp);\n\tif (error)\n\t\treturn error;\n\terror = xfs_alloc_read_agf(pag, NULL, 0, &agf_bp);\n\tif (error)\n\t\tgoto out_agi;\n\n\t \n\tmemset(ageo, 0, sizeof(*ageo));\n\tageo->ag_number = pag->pag_agno;\n\n\tagi = agi_bp->b_addr;\n\tageo->ag_icount = be32_to_cpu(agi->agi_count);\n\tageo->ag_ifree = be32_to_cpu(agi->agi_freecount);\n\n\tagf = agf_bp->b_addr;\n\tageo->ag_length = be32_to_cpu(agf->agf_length);\n\tfreeblks = pag->pagf_freeblks +\n\t\t   pag->pagf_flcount +\n\t\t   pag->pagf_btreeblks -\n\t\t   xfs_ag_resv_needed(pag, XFS_AG_RESV_NONE);\n\tageo->ag_freeblks = freeblks;\n\txfs_ag_geom_health(pag, ageo);\n\n\t \n\txfs_buf_relse(agf_bp);\nout_agi:\n\txfs_buf_relse(agi_bp);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}