{
  "module_name": "xfs_dir2_data.c",
  "hash_id": "7526e662e6192f581245625e7d0cd8cbe9ae4099a1a4cd3d84c8b86f861f0878",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_dir2_data.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_log.h\"\n\nstatic xfs_failaddr_t xfs_dir2_data_freefind_verify(\n\t\tstruct xfs_dir2_data_hdr *hdr, struct xfs_dir2_data_free *bf,\n\t\tstruct xfs_dir2_data_unused *dup,\n\t\tstruct xfs_dir2_data_free **bf_ent);\n\nstruct xfs_dir2_data_free *\nxfs_dir2_data_bestfree_p(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_dir2_data_hdr\t*hdr)\n{\n\tif (xfs_has_crc(mp))\n\t\treturn ((struct xfs_dir3_data_hdr *)hdr)->best_free;\n\treturn hdr->bestfree;\n}\n\n \n__be16 *\nxfs_dir2_data_entry_tag_p(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_dir2_data_entry\t*dep)\n{\n\treturn (__be16 *)((char *)dep +\n\t\txfs_dir2_data_entsize(mp, dep->namelen) - sizeof(__be16));\n}\n\nuint8_t\nxfs_dir2_data_get_ftype(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_dir2_data_entry\t*dep)\n{\n\tif (xfs_has_ftype(mp)) {\n\t\tuint8_t\t\t\tftype = dep->name[dep->namelen];\n\n\t\tif (likely(ftype < XFS_DIR3_FT_MAX))\n\t\t\treturn ftype;\n\t}\n\n\treturn XFS_DIR3_FT_UNKNOWN;\n}\n\nvoid\nxfs_dir2_data_put_ftype(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_dir2_data_entry\t*dep,\n\tuint8_t\t\t\t\tftype)\n{\n\tASSERT(ftype < XFS_DIR3_FT_MAX);\n\tASSERT(dep->namelen != 0);\n\n\tif (xfs_has_ftype(mp))\n\t\tdep->name[dep->namelen] = ftype;\n}\n\n \nstatic inline unsigned int\nxfs_dir2_data_max_leaf_entries(\n\tstruct xfs_da_geometry\t\t*geo)\n{\n\treturn (geo->blksize - sizeof(struct xfs_dir2_block_tail) -\n\t\tgeo->data_entry_offset) /\n\t\t\tsizeof(struct xfs_dir2_leaf_entry);\n}\n\n \nxfs_failaddr_t\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t \n\tstruct xfs_buf\t\t*bp)\t\t \n{\n\txfs_dir2_dataptr_t\taddr;\t\t \n\txfs_dir2_data_free_t\t*bf;\t\t \n\txfs_dir2_block_tail_t\t*btp=NULL;\t \n\tint\t\t\tcount;\t\t \n\txfs_dir2_data_hdr_t\t*hdr;\t\t \n\txfs_dir2_data_free_t\t*dfp;\t\t \n\tint\t\t\tfreeseen;\t \n\txfs_dahash_t\t\thash;\t\t \n\tint\t\t\ti;\t\t \n\tint\t\t\tlastfree;\t \n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t \n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tint\t\t\tstale;\t\t \n\tstruct xfs_name\t\tname;\n\tunsigned int\t\toffset;\n\tunsigned int\t\tend;\n\tstruct xfs_da_geometry\t*geo = mp->m_dir_geo;\n\n\t \n\tif (dp && !S_ISDIR(VFS_I(dp)->i_mode))\n\t\treturn __this_address;\n\n\thdr = bp->b_addr;\n\toffset = geo->data_entry_offset;\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\n\t\tif (be32_to_cpu(btp->count) >=\n\t\t    xfs_dir2_data_max_leaf_entries(geo))\n\t\t\treturn __this_address;\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tbreak;\n\tdefault:\n\t\treturn __this_address;\n\t}\n\tend = xfs_dir3_data_end_offset(geo, hdr);\n\tif (!end)\n\t\treturn __this_address;\n\n\t \n\tbf = xfs_dir2_data_bestfree_p(mp, hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tif (bf[0].offset)\n\t\t\treturn __this_address;\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tif (bf[1].offset)\n\t\t\treturn __this_address;\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tif (bf[2].offset)\n\t\t\treturn __this_address;\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tif (be16_to_cpu(bf[0].length) < be16_to_cpu(bf[1].length))\n\t\treturn __this_address;\n\tif (be16_to_cpu(bf[1].length) < be16_to_cpu(bf[2].length))\n\t\treturn __this_address;\n\t \n\twhile (offset < end) {\n\t\tstruct xfs_dir2_data_unused\t*dup = bp->b_addr + offset;\n\t\tstruct xfs_dir2_data_entry\t*dep = bp->b_addr + offset;\n\n\t\t \n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\txfs_failaddr_t\tfa;\n\n\t\t\tif (lastfree != 0)\n\t\t\t\treturn __this_address;\n\t\t\tif (offset + be16_to_cpu(dup->length) > end)\n\t\t\t\treturn __this_address;\n\t\t\tif (be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) !=\n\t\t\t    offset)\n\t\t\t\treturn __this_address;\n\t\t\tfa = xfs_dir2_data_freefind_verify(hdr, bf, dup, &dfp);\n\t\t\tif (fa)\n\t\t\t\treturn fa;\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tif ((freeseen & (1 << i)) != 0)\n\t\t\t\t\treturn __this_address;\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tif (be16_to_cpu(dup->length) >\n\t\t\t\t    be16_to_cpu(bf[2].length))\n\t\t\t\t\treturn __this_address;\n\t\t\t}\n\t\t\toffset += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (dep->namelen == 0)\n\t\t\treturn __this_address;\n\t\tif (!xfs_verify_dir_ino(mp, be64_to_cpu(dep->inumber)))\n\t\t\treturn __this_address;\n\t\tif (offset + xfs_dir2_data_entsize(mp, dep->namelen) > end)\n\t\t\treturn __this_address;\n\t\tif (be16_to_cpu(*xfs_dir2_data_entry_tag_p(mp, dep)) != offset)\n\t\t\treturn __this_address;\n\t\tif (xfs_dir2_data_get_ftype(mp, dep) >= XFS_DIR3_FT_MAX)\n\t\t\treturn __this_address;\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = xfs_dir2_hashname(mp, &name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i >= be32_to_cpu(btp->count))\n\t\t\t\treturn __this_address;\n\t\t}\n\t\toffset += xfs_dir2_data_entsize(mp, dep->namelen);\n\t}\n\t \n\tif (freeseen != 7)\n\t\treturn __this_address;\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0 && be32_to_cpu(lep[i].hashval) <\n\t\t\t\t     be32_to_cpu(lep[i - 1].hashval))\n\t\t\t\treturn __this_address;\n\t\t}\n\t\tif (count != be32_to_cpu(btp->count) - be32_to_cpu(btp->stale))\n\t\t\treturn __this_address;\n\t\tif (stale != be32_to_cpu(btp->stale))\n\t\t\treturn __this_address;\n\t}\n\treturn NULL;\n}\n\n#ifdef DEBUG\nvoid\nxfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp)\n{\n\txfs_failaddr_t\t\tfa;\n\n\tfa = __xfs_dir3_data_check(dp, bp);\n\tif (!fa)\n\t\treturn;\n\txfs_corruption_error(__func__, XFS_ERRLEVEL_LOW, dp->i_mount,\n\t\t\tbp->b_addr, BBTOB(bp->b_length), __FILE__, __LINE__,\n\t\t\tfa);\n\tASSERT(0);\n}\n#endif\n\nstatic xfs_failaddr_t\nxfs_dir3_data_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (!xfs_verify_magic(bp, hdr3->magic))\n\t\treturn __this_address;\n\n\tif (xfs_has_crc(mp)) {\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_meta_uuid))\n\t\t\treturn __this_address;\n\t\tif (be64_to_cpu(hdr3->blkno) != xfs_buf_daddr(bp))\n\t\t\treturn __this_address;\n\t\tif (!xfs_log_check_lsn(mp, be64_to_cpu(hdr3->lsn)))\n\t\t\treturn __this_address;\n\t}\n\treturn __xfs_dir3_data_check(NULL, bp);\n}\n\n \nstatic void\nxfs_dir3_data_reada_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\t\tbp->b_ops = &xfs_dir3_block_buf_ops;\n\t\tbp->b_ops->verify_read(bp);\n\t\treturn;\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\t\tbp->b_ops = &xfs_dir3_data_buf_ops;\n\t\tbp->b_ops->verify_read(bp);\n\t\treturn;\n\tdefault:\n\t\txfs_verifier_error(bp, -EFSCORRUPTED, __this_address);\n\t\tbreak;\n\t}\n}\n\nstatic void\nxfs_dir3_data_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\txfs_failaddr_t\t\tfa;\n\n\tif (xfs_has_crc(mp) &&\n\t    !xfs_buf_verify_cksum(bp, XFS_DIR3_DATA_CRC_OFF))\n\t\txfs_verifier_error(bp, -EFSBADCRC, __this_address);\n\telse {\n\t\tfa = xfs_dir3_data_verify(bp);\n\t\tif (fa)\n\t\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t}\n}\n\nstatic void\nxfs_dir3_data_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_log_item;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\txfs_failaddr_t\t\tfa;\n\n\tfa = xfs_dir3_data_verify(bp);\n\tif (fa) {\n\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t\treturn;\n\t}\n\n\tif (!xfs_has_crc(mp))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_DIR3_DATA_CRC_OFF);\n}\n\nconst struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.name = \"xfs_dir3_data\",\n\t.magic = { cpu_to_be32(XFS_DIR2_DATA_MAGIC),\n\t\t   cpu_to_be32(XFS_DIR3_DATA_MAGIC) },\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n\t.verify_struct = xfs_dir3_data_verify,\n};\n\nstatic const struct xfs_buf_ops xfs_dir3_data_reada_buf_ops = {\n\t.name = \"xfs_dir3_data_reada\",\n\t.magic = { cpu_to_be32(XFS_DIR2_DATA_MAGIC),\n\t\t   cpu_to_be32(XFS_DIR3_DATA_MAGIC) },\n\t.verify_read = xfs_dir3_data_reada_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};\n\nstatic xfs_failaddr_t\nxfs_dir3_data_header_check(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\n\tif (xfs_has_crc(mp)) {\n\t\tstruct xfs_dir3_data_hdr *hdr3 = bp->b_addr;\n\n\t\tif (be64_to_cpu(hdr3->hdr.owner) != dp->i_ino)\n\t\t\treturn __this_address;\n\t}\n\n\treturn NULL;\n}\n\nint\nxfs_dir3_data_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\tunsigned int\t\tflags,\n\tstruct xfs_buf\t\t**bpp)\n{\n\txfs_failaddr_t\t\tfa;\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, flags, bpp, XFS_DATA_FORK,\n\t\t\t&xfs_dir3_data_buf_ops);\n\tif (err || !*bpp)\n\t\treturn err;\n\n\t \n\tfa = xfs_dir3_data_header_check(dp, *bpp);\n\tif (fa) {\n\t\t__xfs_buf_mark_corrupt(*bpp, fa);\n\t\txfs_trans_brelse(tp, *bpp);\n\t\t*bpp = NULL;\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_DATA_BUF);\n\treturn err;\n}\n\nint\nxfs_dir3_data_readahead(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\tunsigned int\t\tflags)\n{\n\treturn xfs_da_reada_buf(dp, bno, flags, XFS_DATA_FORK,\n\t\t\t\t&xfs_dir3_data_reada_buf_ops);\n}\n\n \nstatic xfs_failaddr_t\nxfs_dir2_data_freefind_verify(\n\tstruct xfs_dir2_data_hdr\t*hdr,\n\tstruct xfs_dir2_data_free\t*bf,\n\tstruct xfs_dir2_data_unused\t*dup,\n\tstruct xfs_dir2_data_free\t**bf_ent)\n{\n\tstruct xfs_dir2_data_free\t*dfp;\n\txfs_dir2_data_aoff_t\t\toff;\n\tbool\t\t\t\tmatched = false;\n\tbool\t\t\t\tseenzero = false;\n\n\t*bf_ent = NULL;\n\toff = (xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr);\n\n\t \n\tfor (dfp = &bf[0]; dfp < &bf[XFS_DIR2_DATA_FD_COUNT]; dfp++) {\n\t\tif (!dfp->offset) {\n\t\t\tif (dfp->length)\n\t\t\t\treturn __this_address;\n\t\t\tseenzero = true;\n\t\t\tcontinue;\n\t\t}\n\t\tif (seenzero)\n\t\t\treturn __this_address;\n\t\tif (be16_to_cpu(dfp->offset) == off) {\n\t\t\tmatched = true;\n\t\t\tif (dfp->length != dup->length)\n\t\t\t\treturn __this_address;\n\t\t} else if (be16_to_cpu(dfp->offset) > off) {\n\t\t\tif (off + be16_to_cpu(dup->length) >\n\t\t\t\t\tbe16_to_cpu(dfp->offset))\n\t\t\t\treturn __this_address;\n\t\t} else {\n\t\t\tif (be16_to_cpu(dfp->offset) +\n\t\t\t\t\tbe16_to_cpu(dfp->length) > off)\n\t\t\t\treturn __this_address;\n\t\t}\n\t\tif (!matched &&\n\t\t    be16_to_cpu(dfp->length) < be16_to_cpu(dup->length))\n\t\t\treturn __this_address;\n\t\tif (dfp > &bf[0] &&\n\t\t    be16_to_cpu(dfp[-1].length) < be16_to_cpu(dfp[0].length))\n\t\t\treturn __this_address;\n\t}\n\n\t \n\t*bf_ent = xfs_dir2_data_freefind(hdr, bf, dup);\n\treturn NULL;\n}\n\n \nxfs_dir2_data_free_t *\nxfs_dir2_data_freefind(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t \n\tstruct xfs_dir2_data_free *bf,\t\t \n\tstruct xfs_dir2_data_unused *dup)\t \n{\n\txfs_dir2_data_free_t\t*dfp;\t\t \n\txfs_dir2_data_aoff_t\toff;\t\t \n\n\toff = (xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr);\n\n\t \n\tif (be16_to_cpu(dup->length) <\n\t    be16_to_cpu(bf[XFS_DIR2_DATA_FD_COUNT - 1].length))\n\t\treturn NULL;\n\t \n\tfor (dfp = &bf[0]; dfp < &bf[XFS_DIR2_DATA_FD_COUNT]; dfp++) {\n\t\tif (!dfp->offset)\n\t\t\treturn NULL;\n\t\tif (be16_to_cpu(dfp->offset) == off)\n\t\t\treturn dfp;\n\t}\n\t \n\treturn NULL;\n}\n\n \nxfs_dir2_data_free_t *\t\t\t\t \nxfs_dir2_data_freeinsert(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t \n\tstruct xfs_dir2_data_free *dfp,\t\t \n\tstruct xfs_dir2_data_unused *dup,\t \n\tint\t\t\t*loghead)\t \n{\n\txfs_dir2_data_free_t\tnew;\t\t \n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\tnew.length = dup->length;\n\tnew.offset = cpu_to_be16((char *)dup - (char *)hdr);\n\n\t \n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[0].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = dfp[0];\n\t\tdfp[0] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[0];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[1].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[1];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[2].length)) {\n\t\tdfp[2] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[2];\n\t}\n\treturn NULL;\n}\n\n \nSTATIC void\nxfs_dir2_data_freeremove(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t \n\tstruct xfs_dir2_data_free *bf,\t\t \n\tstruct xfs_dir2_data_free *dfp,\t\t \n\tint\t\t\t*loghead)\t \n{\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t \n\tif (dfp == &bf[0]) {\n\t\tbf[0] = bf[1];\n\t\tbf[1] = bf[2];\n\t}\n\t \n\telse if (dfp == &bf[1])\n\t\tbf[1] = bf[2];\n\t \n\telse\n\t\tASSERT(dfp == &bf[2]);\n\t \n\tbf[2].length = 0;\n\tbf[2].offset = 0;\n\t*loghead = 1;\n}\n\n \nvoid\nxfs_dir2_data_freescan(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_dir2_data_hdr\t*hdr,\n\tint\t\t\t\t*loghead)\n{\n\tstruct xfs_da_geometry\t\t*geo = mp->m_dir_geo;\n\tstruct xfs_dir2_data_free\t*bf = xfs_dir2_data_bestfree_p(mp, hdr);\n\tvoid\t\t\t\t*addr = hdr;\n\tunsigned int\t\t\toffset = geo->data_entry_offset;\n\tunsigned int\t\t\tend;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t \n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\n\tend = xfs_dir3_data_end_offset(geo, addr);\n\twhile (offset < end) {\n\t\tstruct xfs_dir2_data_unused\t*dup = addr + offset;\n\t\tstruct xfs_dir2_data_entry\t*dep = addr + offset;\n\n\t\t \n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT(offset ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\toffset += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tASSERT(offset ==\n\t\t       be16_to_cpu(*xfs_dir2_data_entry_tag_p(mp, dep)));\n\t\toffset += xfs_dir2_data_entsize(mp, dep->namelen);\n\t}\n}\n\n \nint\t\t\t\t\t\t \nxfs_dir3_data_init(\n\tstruct xfs_da_args\t\t*args,\t \n\txfs_dir2_db_t\t\t\tblkno,\t \n\tstruct xfs_buf\t\t\t**bpp)\t \n{\n\tstruct xfs_trans\t\t*tp = args->trans;\n\tstruct xfs_inode\t\t*dp = args->dp;\n\tstruct xfs_mount\t\t*mp = dp->i_mount;\n\tstruct xfs_da_geometry\t\t*geo = args->geo;\n\tstruct xfs_buf\t\t\t*bp;\n\tstruct xfs_dir2_data_hdr\t*hdr;\n\tstruct xfs_dir2_data_unused\t*dup;\n\tstruct xfs_dir2_data_free \t*bf;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\n\t \n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, blkno),\n\t\t\t       &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_dir3_data_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_DATA_BUF);\n\n\t \n\thdr = bp->b_addr;\n\tif (xfs_has_crc(mp)) {\n\t\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\t\tmemset(hdr3, 0, sizeof(*hdr3));\n\t\thdr3->magic = cpu_to_be32(XFS_DIR3_DATA_MAGIC);\n\t\thdr3->blkno = cpu_to_be64(xfs_buf_daddr(bp));\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_meta_uuid);\n\n\t} else\n\t\thdr->magic = cpu_to_be32(XFS_DIR2_DATA_MAGIC);\n\n\tbf = xfs_dir2_data_bestfree_p(mp, hdr);\n\tbf[0].offset = cpu_to_be16(geo->data_entry_offset);\n\tbf[0].length = cpu_to_be16(geo->blksize - geo->data_entry_offset);\n\tfor (i = 1; i < XFS_DIR2_DATA_FD_COUNT; i++) {\n\t\tbf[i].length = 0;\n\t\tbf[i].offset = 0;\n\t}\n\n\t \n\tdup = bp->b_addr + geo->data_entry_offset;\n\tdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\tdup->length = bf[0].length;\n\t*xfs_dir2_data_unused_tag_p(dup) = cpu_to_be16((char *)dup - (char *)hdr);\n\n\t \n\txfs_dir2_data_log_header(args, bp);\n\txfs_dir2_data_log_unused(args, bp, dup);\n\t*bpp = bp;\n\treturn 0;\n}\n\n \nvoid\nxfs_dir2_data_log_entry(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_entry_t\t*dep)\t\t \n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dep - (char *)hdr),\n\t\t(uint)((char *)(xfs_dir2_data_entry_tag_p(mp, dep) + 1) -\n\t\t       (char *)hdr - 1));\n}\n\n \nvoid\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0, args->geo->data_entry_offset - 1);\n}\n\n \nvoid\nxfs_dir2_data_log_unused(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup)\t\t \n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t \n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dup - (char *)hdr),\n\t\t(uint)((char *)&dup->length + sizeof(dup->length) -\n\t\t       1 - (char *)hdr));\n\t \n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr),\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr +\n\t\t       sizeof(xfs_dir2_data_off_t) - 1));\n}\n\n \nvoid\nxfs_dir2_data_make_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_aoff_t\toffset,\t\t \n\txfs_dir2_data_aoff_t\tlen,\t\t \n\tint\t\t\t*needlogp,\t \n\tint\t\t\t*needscanp)\t \n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t \n\txfs_dir2_data_free_t\t*dfp;\t\t \n\tint\t\t\tneedscan;\t \n\txfs_dir2_data_unused_t\t*newdup;\t \n\txfs_dir2_data_unused_t\t*postdup;\t \n\txfs_dir2_data_unused_t\t*prevdup;\t \n\tunsigned int\t\tend;\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\n\t \n\tend = xfs_dir3_data_end_offset(args->geo, hdr);\n\tASSERT(end != 0);\n\n\t \n\tif (offset > args->geo->data_entry_offset) {\n\t\t__be16\t\t\t*tagp;\t \n\n\t\ttagp = (__be16 *)((char *)hdr + offset) - 1;\n\t\tprevdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t\tif (be16_to_cpu(prevdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tprevdup = NULL;\n\t} else\n\t\tprevdup = NULL;\n\t \n\tif (offset + len < end) {\n\t\tpostdup =\n\t\t\t(xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tif (be16_to_cpu(postdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tpostdup = NULL;\n\t} else\n\t\tpostdup = NULL;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t \n\tbf = xfs_dir2_data_bestfree_p(args->dp->i_mount, hdr);\n\tif (prevdup && postdup) {\n\t\txfs_dir2_data_free_t\t*dfp2;\t \n\n\t\t \n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tdfp2 = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\t \n\t\tneedscan = (bf[2].length != 0);\n\t\t \n\t\tbe16_add_cpu(&prevdup->length, len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\tif (!needscan) {\n\t\t\t \n\t\t\tASSERT(dfp && dfp2);\n\t\t\tif (dfp == &bf[1]) {\n\t\t\t\tdfp = &bf[0];\n\t\t\t\tASSERT(dfp2 == dfp);\n\t\t\t\tdfp2 = &bf[1];\n\t\t\t}\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp2, needlogp);\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\t \n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, prevdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp == &bf[0]);\n\t\t\tASSERT(dfp->length == prevdup->length);\n\t\t\tASSERT(!dfp[1].length);\n\t\t\tASSERT(!dfp[2].length);\n\t\t}\n\t}\n\t \n\telse if (prevdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tbe16_add_cpu(&prevdup->length, len);\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\t \n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, prevdup, needlogp);\n\t\t}\n\t\t \n\t\telse {\n\t\t\tneedscan = be16_to_cpu(prevdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t \n\telse if (postdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t \n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t\t}\n\t\t \n\t\telse {\n\t\t\tneedscan = be16_to_cpu(newdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t \n\telse {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t}\n\t*needscanp = needscan;\n}\n\n \nstatic inline xfs_failaddr_t\nxfs_dir2_data_check_free(\n\tstruct xfs_dir2_data_hdr\t*hdr,\n\tstruct xfs_dir2_data_unused\t*dup,\n\txfs_dir2_data_aoff_t\t\toffset,\n\txfs_dir2_data_aoff_t\t\tlen)\n{\n\tif (hdr->magic != cpu_to_be32(XFS_DIR2_DATA_MAGIC) &&\n\t    hdr->magic != cpu_to_be32(XFS_DIR3_DATA_MAGIC) &&\n\t    hdr->magic != cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) &&\n\t    hdr->magic != cpu_to_be32(XFS_DIR3_BLOCK_MAGIC))\n\t\treturn __this_address;\n\tif (be16_to_cpu(dup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\treturn __this_address;\n\tif (offset < (char *)dup - (char *)hdr)\n\t\treturn __this_address;\n\tif (offset + len > (char *)dup + be16_to_cpu(dup->length) - (char *)hdr)\n\t\treturn __this_address;\n\tif ((char *)dup - (char *)hdr !=\n\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)))\n\t\treturn __this_address;\n\treturn NULL;\n}\n\n \nstatic inline xfs_failaddr_t\nxfs_dir2_data_check_new_free(\n\tstruct xfs_dir2_data_hdr\t*hdr,\n\tstruct xfs_dir2_data_free\t*dfp,\n\tstruct xfs_dir2_data_unused\t*newdup)\n{\n\tif (dfp == NULL)\n\t\treturn __this_address;\n\tif (dfp->length != newdup->length)\n\t\treturn __this_address;\n\tif (be16_to_cpu(dfp->offset) != (char *)newdup - (char *)hdr)\n\t\treturn __this_address;\n\treturn NULL;\n}\n\n \nint\nxfs_dir2_data_use_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup,\t\t \n\txfs_dir2_data_aoff_t\toffset,\t\t \n\txfs_dir2_data_aoff_t\tlen,\t\t \n\tint\t\t\t*needlogp,\t \n\tint\t\t\t*needscanp)\t \n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t \n\txfs_dir2_data_free_t\t*dfp;\t\t \n\txfs_dir2_data_unused_t\t*newdup;\t \n\txfs_dir2_data_unused_t\t*newdup2;\t \n\tstruct xfs_dir2_data_free *bf;\n\txfs_failaddr_t\t\tfa;\n\tint\t\t\tmatchback;\t \n\tint\t\t\tmatchfront;\t \n\tint\t\t\tneedscan;\t \n\tint\t\t\toldlen;\t\t \n\n\thdr = bp->b_addr;\n\tfa = xfs_dir2_data_check_free(hdr, dup, offset, len);\n\tif (fa)\n\t\tgoto corrupt;\n\t \n\toldlen = be16_to_cpu(dup->length);\n\tbf = xfs_dir2_data_bestfree_p(args->dp->i_mount, hdr);\n\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\tASSERT(dfp || oldlen <= be16_to_cpu(bf[2].length));\n\t \n\tmatchfront = (char *)dup - (char *)hdr == offset;\n\tmatchback = (char *)dup + oldlen - (char *)hdr == offset + len;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t \n\tif (matchfront && matchback) {\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].offset != 0);\n\t\t\tif (!needscan)\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t}\n\t}\n\t \n\telse if (matchfront) {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(oldlen - len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t \n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tfa = xfs_dir2_data_check_new_free(hdr, dfp, newdup);\n\t\t\tif (fa)\n\t\t\t\tgoto corrupt;\n\t\t\t \n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t \n\telse if (matchback) {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t \n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tfa = xfs_dir2_data_check_new_free(hdr, dfp, newdup);\n\t\t\tif (fa)\n\t\t\t\tgoto corrupt;\n\t\t\t \n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t \n\telse {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\tnewdup2 = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup2->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup2->length = cpu_to_be16(oldlen - len - be16_to_cpu(newdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup2) =\n\t\t\tcpu_to_be16((char *)newdup2 - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup2);\n\t\t \n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].length != 0);\n\t\t\tif (!needscan) {\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup2,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t}\n\t\t}\n\t}\n\t*needscanp = needscan;\n\treturn 0;\ncorrupt:\n\txfs_corruption_error(__func__, XFS_ERRLEVEL_LOW, args->dp->i_mount,\n\t\t\thdr, sizeof(*hdr), __FILE__, __LINE__, fa);\n\treturn -EFSCORRUPTED;\n}\n\n \nunsigned int\nxfs_dir3_data_end_offset(\n\tstruct xfs_da_geometry\t\t*geo,\n\tstruct xfs_dir2_data_hdr\t*hdr)\n{\n\tvoid\t\t\t\t*p;\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tp = xfs_dir2_block_leaf_p(xfs_dir2_block_tail_p(geo, hdr));\n\t\treturn p - (void *)hdr;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\treturn geo->blksize;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}