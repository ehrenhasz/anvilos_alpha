{
  "module_name": "xfs_dir2_node.c",
  "hash_id": "5f45858ab9f80a729258528960e22af79885699c8f33cf776c5a7b00f64080ba",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_dir2_node.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_log.h\"\n\n \nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\nstatic void xfs_dir2_leafn_rebalance(xfs_da_state_t *state,\n\t\t\t\t     xfs_da_state_blk_t *blk1,\n\t\t\t\t     xfs_da_state_blk_t *blk2);\nstatic int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);\n\n \nstatic xfs_dir2_db_t\nxfs_dir2_db_to_fdb(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn xfs_dir2_byte_to_db(geo, XFS_DIR2_FREE_OFFSET) +\n\t\t\t(db / geo->free_max_bests);\n}\n\n \nstatic int\nxfs_dir2_db_to_fdindex(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn db % geo->free_max_bests;\n}\n\n \n#ifdef DEBUG\nstatic xfs_failaddr_t\nxfs_dir3_leafn_check(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\txfs_dir2_leaf_hdr_from_disk(dp->i_mount, &leafhdr, leaf);\n\n\tif (leafhdr.magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\tstruct xfs_dir3_leaf_hdr *leaf3 = bp->b_addr;\n\t\tif (be64_to_cpu(leaf3->info.blkno) != xfs_buf_daddr(bp))\n\t\t\treturn __this_address;\n\t} else if (leafhdr.magic != XFS_DIR2_LEAFN_MAGIC)\n\t\treturn __this_address;\n\n\treturn xfs_dir3_leaf_check_int(dp->i_mount, &leafhdr, leaf, false);\n}\n\nstatic inline void\nxfs_dir3_leaf_check(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp)\n{\n\txfs_failaddr_t\t\tfa;\n\n\tfa = xfs_dir3_leafn_check(dp, bp);\n\tif (!fa)\n\t\treturn;\n\txfs_corruption_error(__func__, XFS_ERRLEVEL_LOW, dp->i_mount,\n\t\t\tbp->b_addr, BBTOB(bp->b_length), __FILE__, __LINE__,\n\t\t\tfa);\n\tASSERT(0);\n}\n#else\n#define\txfs_dir3_leaf_check(dp, bp)\n#endif\n\nstatic xfs_failaddr_t\nxfs_dir3_free_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_dir2_free_hdr *hdr = bp->b_addr;\n\n\tif (!xfs_verify_magic(bp, hdr->magic))\n\t\treturn __this_address;\n\n\tif (xfs_has_crc(mp)) {\n\t\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_meta_uuid))\n\t\t\treturn __this_address;\n\t\tif (be64_to_cpu(hdr3->blkno) != xfs_buf_daddr(bp))\n\t\t\treturn __this_address;\n\t\tif (!xfs_log_check_lsn(mp, be64_to_cpu(hdr3->lsn)))\n\t\t\treturn __this_address;\n\t}\n\n\t \n\n\treturn NULL;\n}\n\nstatic void\nxfs_dir3_free_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\txfs_failaddr_t\t\tfa;\n\n\tif (xfs_has_crc(mp) &&\n\t    !xfs_buf_verify_cksum(bp, XFS_DIR3_FREE_CRC_OFF))\n\t\txfs_verifier_error(bp, -EFSBADCRC, __this_address);\n\telse {\n\t\tfa = xfs_dir3_free_verify(bp);\n\t\tif (fa)\n\t\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t}\n}\n\nstatic void\nxfs_dir3_free_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_log_item;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\txfs_failaddr_t\t\tfa;\n\n\tfa = xfs_dir3_free_verify(bp);\n\tif (fa) {\n\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t\treturn;\n\t}\n\n\tif (!xfs_has_crc(mp))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_DIR3_FREE_CRC_OFF);\n}\n\nconst struct xfs_buf_ops xfs_dir3_free_buf_ops = {\n\t.name = \"xfs_dir3_free\",\n\t.magic = { cpu_to_be32(XFS_DIR2_FREE_MAGIC),\n\t\t   cpu_to_be32(XFS_DIR3_FREE_MAGIC) },\n\t.verify_read = xfs_dir3_free_read_verify,\n\t.verify_write = xfs_dir3_free_write_verify,\n\t.verify_struct = xfs_dir3_free_verify,\n};\n\n \nstatic xfs_failaddr_t\nxfs_dir3_free_header_check(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\tmaxbests = mp->m_dir_geo->free_max_bests;\n\tunsigned int\t\tfirstdb;\n\n\tfirstdb = (xfs_dir2_da_to_db(mp->m_dir_geo, fbno) -\n\t\t   xfs_dir2_byte_to_db(mp->m_dir_geo, XFS_DIR2_FREE_OFFSET)) *\n\t\t\tmaxbests;\n\tif (xfs_has_crc(mp)) {\n\t\tstruct xfs_dir3_free_hdr *hdr3 = bp->b_addr;\n\n\t\tif (be32_to_cpu(hdr3->firstdb) != firstdb)\n\t\t\treturn __this_address;\n\t\tif (be32_to_cpu(hdr3->nvalid) > maxbests)\n\t\t\treturn __this_address;\n\t\tif (be32_to_cpu(hdr3->nvalid) < be32_to_cpu(hdr3->nused))\n\t\t\treturn __this_address;\n\t\tif (be64_to_cpu(hdr3->hdr.owner) != dp->i_ino)\n\t\t\treturn __this_address;\n\t} else {\n\t\tstruct xfs_dir2_free_hdr *hdr = bp->b_addr;\n\n\t\tif (be32_to_cpu(hdr->firstdb) != firstdb)\n\t\t\treturn __this_address;\n\t\tif (be32_to_cpu(hdr->nvalid) > maxbests)\n\t\t\treturn __this_address;\n\t\tif (be32_to_cpu(hdr->nvalid) < be32_to_cpu(hdr->nused))\n\t\t\treturn __this_address;\n\t}\n\treturn NULL;\n}\n\nstatic int\n__xfs_dir3_free_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\tunsigned int\t\tflags,\n\tstruct xfs_buf\t\t**bpp)\n{\n\txfs_failaddr_t\t\tfa;\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, fbno, flags, bpp, XFS_DATA_FORK,\n\t\t\t&xfs_dir3_free_buf_ops);\n\tif (err || !*bpp)\n\t\treturn err;\n\n\t \n\tfa = xfs_dir3_free_header_check(dp, fbno, *bpp);\n\tif (fa) {\n\t\t__xfs_buf_mark_corrupt(*bpp, fa);\n\t\txfs_trans_brelse(tp, *bpp);\n\t\t*bpp = NULL;\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\tif (tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_FREE_BUF);\n\n\treturn 0;\n}\n\nvoid\nxfs_dir2_free_hdr_from_disk(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_dir3_icfree_hdr\t*to,\n\tstruct xfs_dir2_free\t\t*from)\n{\n\tif (xfs_has_crc(mp)) {\n\t\tstruct xfs_dir3_free\t*from3 = (struct xfs_dir3_free *)from;\n\n\t\tto->magic = be32_to_cpu(from3->hdr.hdr.magic);\n\t\tto->firstdb = be32_to_cpu(from3->hdr.firstdb);\n\t\tto->nvalid = be32_to_cpu(from3->hdr.nvalid);\n\t\tto->nused = be32_to_cpu(from3->hdr.nused);\n\t\tto->bests = from3->bests;\n\n\t\tASSERT(to->magic == XFS_DIR3_FREE_MAGIC);\n\t} else {\n\t\tto->magic = be32_to_cpu(from->hdr.magic);\n\t\tto->firstdb = be32_to_cpu(from->hdr.firstdb);\n\t\tto->nvalid = be32_to_cpu(from->hdr.nvalid);\n\t\tto->nused = be32_to_cpu(from->hdr.nused);\n\t\tto->bests = from->bests;\n\n\t\tASSERT(to->magic == XFS_DIR2_FREE_MAGIC);\n\t}\n}\n\nstatic void\nxfs_dir2_free_hdr_to_disk(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_dir2_free\t\t*to,\n\tstruct xfs_dir3_icfree_hdr\t*from)\n{\n\tif (xfs_has_crc(mp)) {\n\t\tstruct xfs_dir3_free\t*to3 = (struct xfs_dir3_free *)to;\n\n\t\tASSERT(from->magic == XFS_DIR3_FREE_MAGIC);\n\n\t\tto3->hdr.hdr.magic = cpu_to_be32(from->magic);\n\t\tto3->hdr.firstdb = cpu_to_be32(from->firstdb);\n\t\tto3->hdr.nvalid = cpu_to_be32(from->nvalid);\n\t\tto3->hdr.nused = cpu_to_be32(from->nused);\n\t} else {\n\t\tASSERT(from->magic == XFS_DIR2_FREE_MAGIC);\n\n\t\tto->hdr.magic = cpu_to_be32(from->magic);\n\t\tto->hdr.firstdb = cpu_to_be32(from->firstdb);\n\t\tto->hdr.nvalid = cpu_to_be32(from->nvalid);\n\t\tto->hdr.nused = cpu_to_be32(from->nused);\n\t}\n}\n\nint\nxfs_dir2_free_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\treturn __xfs_dir3_free_read(tp, dp, fbno, 0, bpp);\n}\n\nstatic int\nxfs_dir2_free_try_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\treturn __xfs_dir3_free_read(tp, dp, fbno, XFS_DABUF_MAP_HOLE_OK, bpp);\n}\n\nstatic int\nxfs_dir3_free_get_buf(\n\txfs_da_args_t\t\t*args,\n\txfs_dir2_db_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tstruct xfs_dir3_icfree_hdr hdr;\n\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, fbno),\n\t\t\t&bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_FREE_BUF);\n\tbp->b_ops = &xfs_dir3_free_buf_ops;\n\n\t \n\tmemset(bp->b_addr, 0, sizeof(struct xfs_dir3_free_hdr));\n\tmemset(&hdr, 0, sizeof(hdr));\n\n\tif (xfs_has_crc(mp)) {\n\t\tstruct xfs_dir3_free_hdr *hdr3 = bp->b_addr;\n\n\t\thdr.magic = XFS_DIR3_FREE_MAGIC;\n\n\t\thdr3->hdr.blkno = cpu_to_be64(xfs_buf_daddr(bp));\n\t\thdr3->hdr.owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->hdr.uuid, &mp->m_sb.sb_meta_uuid);\n\t} else\n\t\thdr.magic = XFS_DIR2_FREE_MAGIC;\n\txfs_dir2_free_hdr_to_disk(mp, bp->b_addr, &hdr);\n\t*bpp = bp;\n\treturn 0;\n}\n\n \nSTATIC void\nxfs_dir2_free_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_dir3_icfree_hdr *hdr,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\t\t \n\tint\t\t\tlast)\t\t \n{\n\tstruct xfs_dir2_free\t*free = bp->b_addr;\n\n\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (char *)&hdr->bests[first] - (char *)free,\n\t\t\t  (char *)&hdr->bests[last] - (char *)free +\n\t\t\t   sizeof(hdr->bests[0]) - 1);\n}\n\n \nstatic void\nxfs_dir2_free_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\txfs_dir2_free_t\t\t*free;\t\t \n\n\tfree = bp->b_addr;\n\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n#endif\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->geo->free_hdr_size - 1);\n}\n\n \nint\t\t\t\t\t\t \nxfs_dir2_leaf_to_node(\n\txfs_da_args_t\t\t*args,\t\t \n\tstruct xfs_buf\t\t*lbp)\t\t \n{\n\txfs_inode_t\t\t*dp;\t\t \n\tint\t\t\terror;\t\t \n\tstruct xfs_buf\t\t*fbp;\t\t \n\txfs_dir2_db_t\t\tfdb;\t\t \n\t__be16\t\t\t*from;\t\t \n\tint\t\t\ti;\t\t \n\txfs_dir2_leaf_t\t\t*leaf;\t\t \n\txfs_dir2_leaf_tail_t\t*ltp;\t\t \n\tint\t\t\tn;\t\t \n\txfs_dir2_data_off_t\toff;\t\t \n\txfs_trans_t\t\t*tp;\t\t \n\tstruct xfs_dir3_icfree_hdr freehdr;\n\n\ttrace_xfs_dir2_leaf_to_node(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\t \n\tif ((error = xfs_dir2_grow_inode(args, XFS_DIR2_FREE_SPACE, &fdb))) {\n\t\treturn error;\n\t}\n\tASSERT(fdb == xfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET));\n\t \n\terror = xfs_dir3_free_get_buf(args, fdb, &fbp);\n\tif (error)\n\t\treturn error;\n\n\txfs_dir2_free_hdr_from_disk(dp->i_mount, &freehdr, fbp->b_addr);\n\tleaf = lbp->b_addr;\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tif (be32_to_cpu(ltp->bestcount) >\n\t\t\t\t(uint)dp->i_disk_size / args->geo->blksize) {\n\t\txfs_buf_mark_corrupt(lbp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\tfrom = xfs_dir2_leaf_bests_p(ltp);\n\tfor (i = n = 0; i < be32_to_cpu(ltp->bestcount); i++, from++) {\n\t\toff = be16_to_cpu(*from);\n\t\tif (off != NULLDATAOFF)\n\t\t\tn++;\n\t\tfreehdr.bests[i] = cpu_to_be16(off);\n\t}\n\n\t \n\tfreehdr.nused = n;\n\tfreehdr.nvalid = be32_to_cpu(ltp->bestcount);\n\n\txfs_dir2_free_hdr_to_disk(dp->i_mount, fbp->b_addr, &freehdr);\n\txfs_dir2_free_log_bests(args, &freehdr, fbp, 0, freehdr.nvalid - 1);\n\txfs_dir2_free_log_header(args, fbp);\n\n\t \n\tif (leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC))\n\t\tleaf->hdr.info.magic = cpu_to_be16(XFS_DIR2_LEAFN_MAGIC);\n\telse\n\t\tleaf->hdr.info.magic = cpu_to_be16(XFS_DIR3_LEAFN_MAGIC);\n\tlbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\txfs_trans_buf_set_type(tp, lbp, XFS_BLFT_DIR_LEAFN_BUF);\n\txfs_dir3_leaf_log_header(args, lbp);\n\txfs_dir3_leaf_check(dp, lbp);\n\treturn 0;\n}\n\n \nstatic int\t\t\t\t\t \nxfs_dir2_leafn_add(\n\tstruct xfs_buf\t\t*bp,\t\t \n\tstruct xfs_da_args\t*args,\t\t \n\tint\t\t\tindex)\t\t \n{\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *lep;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tint\t\t\tcompact;\t \n\tint\t\t\thighstale = 0;\t \n\tint\t\t\tlfloghigh;\t \n\tint\t\t\tlfloglow;\t \n\tint\t\t\tlowstale = 0;\t \n\n\ttrace_xfs_dir2_leafn_add(args, index);\n\n\txfs_dir2_leaf_hdr_from_disk(dp->i_mount, &leafhdr, leaf);\n\tents = leafhdr.ents;\n\n\t \n\tif (index < 0) {\n\t\txfs_buf_mark_corrupt(bp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\n\tif (leafhdr.count == args->geo->leaf_max_ents) {\n\t\tif (!leafhdr.stale)\n\t\t\treturn -ENOSPC;\n\t\tcompact = leafhdr.stale > 1;\n\t} else\n\t\tcompact = 0;\n\tASSERT(index == 0 || be32_to_cpu(ents[index - 1].hashval) <= args->hashval);\n\tASSERT(index == leafhdr.count ||\n\t       be32_to_cpu(ents[index].hashval) >= args->hashval);\n\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK)\n\t\treturn 0;\n\n\t \n\tif (compact)\n\t\txfs_dir3_leaf_compact_x1(&leafhdr, ents, &index, &lowstale,\n\t\t\t\t\t &highstale, &lfloglow, &lfloghigh);\n\telse if (leafhdr.stale) {\n\t\t \n\t\tlfloglow = leafhdr.count;\n\t\tlfloghigh = -1;\n\t}\n\n\t \n\tlep = xfs_dir3_leaf_find_entry(&leafhdr, ents, index, compact, lowstale,\n\t\t\t\t       highstale, &lfloglow, &lfloghigh);\n\n\tlep->hashval = cpu_to_be32(args->hashval);\n\tlep->address = cpu_to_be32(xfs_dir2_db_off_to_dataptr(args->geo,\n\t\t\t\targs->blkno, args->index));\n\n\txfs_dir2_leaf_hdr_to_disk(dp->i_mount, leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, bp);\n\txfs_dir3_leaf_log_ents(args, &leafhdr, bp, lfloglow, lfloghigh);\n\txfs_dir3_leaf_check(dp, bp);\n\treturn 0;\n}\n\n#ifdef DEBUG\nstatic void\nxfs_dir2_free_hdr_check(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\n\txfs_dir2_db_t\tdb)\n{\n\tstruct xfs_dir3_icfree_hdr hdr;\n\n\txfs_dir2_free_hdr_from_disk(dp->i_mount, &hdr, bp->b_addr);\n\n\tASSERT((hdr.firstdb % dp->i_mount->m_dir_geo->free_max_bests) == 0);\n\tASSERT(hdr.firstdb <= db);\n\tASSERT(db < hdr.firstdb + hdr.nvalid);\n}\n#else\n#define xfs_dir2_free_hdr_check(dp, bp, db)\n#endif\t \n\n \nxfs_dahash_t\t\t\t\t\t \nxfs_dir2_leaf_lasthash(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\t\t\t \n\tint\t\t*count)\t\t\t \n{\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\txfs_dir2_leaf_hdr_from_disk(dp->i_mount, &leafhdr, bp->b_addr);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC ||\n\t       leafhdr.magic == XFS_DIR2_LEAF1_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAF1_MAGIC);\n\n\tif (count)\n\t\t*count = leafhdr.count;\n\tif (!leafhdr.count)\n\t\treturn 0;\n\treturn be32_to_cpu(leafhdr.ents[leafhdr.count - 1].hashval);\n}\n\n \nSTATIC int\nxfs_dir2_leafn_lookup_for_addname(\n\tstruct xfs_buf\t\t*bp,\t\t \n\txfs_da_args_t\t\t*args,\t\t \n\tint\t\t\t*indexp,\t \n\txfs_da_state_t\t\t*state)\t\t \n{\n\tstruct xfs_buf\t\t*curbp = NULL;\t \n\txfs_dir2_db_t\t\tcurdb = -1;\t \n\txfs_dir2_db_t\t\tcurfdb = -1;\t \n\txfs_inode_t\t\t*dp;\t\t \n\tint\t\t\terror;\t\t \n\tint\t\t\tfi;\t\t \n\txfs_dir2_free_t\t\t*free = NULL;\t \n\tint\t\t\tindex;\t\t \n\txfs_dir2_leaf_t\t\t*leaf;\t\t \n\tint\t\t\tlength;\t\t \n\txfs_dir2_leaf_entry_t\t*lep;\t\t \n\txfs_mount_t\t\t*mp;\t\t \n\txfs_dir2_db_t\t\tnewdb;\t\t \n\txfs_dir2_db_t\t\tnewfdb;\t\t \n\txfs_trans_t\t\t*tp;\t\t \n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tleaf = bp->b_addr;\n\txfs_dir2_leaf_hdr_from_disk(mp, &leafhdr, leaf);\n\n\txfs_dir3_leaf_check(dp, bp);\n\tASSERT(leafhdr.count > 0);\n\n\t \n\tindex = xfs_dir2_leaf_search_hash(args, bp);\n\t \n\tif (state->extravalid) {\n\t\t \n\t\tcurbp = state->extrablk.bp;\n\t\tcurfdb = state->extrablk.blkno;\n\t\tfree = curbp->b_addr;\n\t\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n\t}\n\tlength = xfs_dir2_data_entsize(mp, args->namelen);\n\t \n\tfor (lep = &leafhdr.ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     lep++, index++) {\n\t\t \n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t \n\t\tnewdb = xfs_dir2_dataptr_to_db(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address));\n\t\t \n\t\tif (newdb != curdb) {\n\t\t\tstruct xfs_dir3_icfree_hdr freehdr;\n\n\t\t\tcurdb = newdb;\n\t\t\t \n\t\t\tnewfdb = xfs_dir2_db_to_fdb(args->geo, newdb);\n\t\t\t \n\t\t\tif (newfdb != curfdb) {\n\t\t\t\t \n\t\t\t\tif (curbp)\n\t\t\t\t\txfs_trans_brelse(tp, curbp);\n\n\t\t\t\terror = xfs_dir2_free_read(tp, dp,\n\t\t\t\t\t\txfs_dir2_db_to_da(args->geo,\n\t\t\t\t\t\t\t\t  newfdb),\n\t\t\t\t\t\t&curbp);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t\tfree = curbp->b_addr;\n\n\t\t\t\txfs_dir2_free_hdr_check(dp, curbp, curdb);\n\t\t\t}\n\t\t\t \n\t\t\tfi = xfs_dir2_db_to_fdindex(args->geo, curdb);\n\t\t\t \n\t\t\txfs_dir2_free_hdr_from_disk(mp, &freehdr, free);\n\t\t\tif (XFS_IS_CORRUPT(mp,\n\t\t\t\t\t   freehdr.bests[fi] ==\n\t\t\t\t\t   cpu_to_be16(NULLDATAOFF))) {\n\t\t\t\tif (curfdb != newfdb)\n\t\t\t\t\txfs_trans_brelse(tp, curbp);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\t\t\tcurfdb = newfdb;\n\t\t\tif (be16_to_cpu(freehdr.bests[fi]) >= length)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\t \n\tfi = -1;\nout:\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\tif (curbp) {\n\t\t \n\t\tstate->extravalid = 1;\n\t\tstate->extrablk.bp = curbp;\n\t\tstate->extrablk.index = fi;\n\t\tstate->extrablk.blkno = curfdb;\n\n\t\t \n\t\tstate->extrablk.magic = XFS_DIR2_FREE_MAGIC;\n\t} else {\n\t\tstate->extravalid = 0;\n\t}\n\t \n\t*indexp = index;\n\treturn -ENOENT;\n}\n\n \nSTATIC int\nxfs_dir2_leafn_lookup_for_entry(\n\tstruct xfs_buf\t\t*bp,\t\t \n\txfs_da_args_t\t\t*args,\t\t \n\tint\t\t\t*indexp,\t \n\txfs_da_state_t\t\t*state)\t\t \n{\n\tstruct xfs_buf\t\t*curbp = NULL;\t \n\txfs_dir2_db_t\t\tcurdb = -1;\t \n\txfs_dir2_data_entry_t\t*dep;\t\t \n\txfs_inode_t\t\t*dp;\t\t \n\tint\t\t\terror;\t\t \n\tint\t\t\tindex;\t\t \n\txfs_dir2_leaf_t\t\t*leaf;\t\t \n\txfs_dir2_leaf_entry_t\t*lep;\t\t \n\txfs_mount_t\t\t*mp;\t\t \n\txfs_dir2_db_t\t\tnewdb;\t\t \n\txfs_trans_t\t\t*tp;\t\t \n\tenum xfs_dacmp\t\tcmp;\t\t \n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tleaf = bp->b_addr;\n\txfs_dir2_leaf_hdr_from_disk(mp, &leafhdr, leaf);\n\n\txfs_dir3_leaf_check(dp, bp);\n\tif (leafhdr.count <= 0) {\n\t\txfs_buf_mark_corrupt(bp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\tindex = xfs_dir2_leaf_search_hash(args, bp);\n\t \n\tif (state->extravalid) {\n\t\tcurbp = state->extrablk.bp;\n\t\tcurdb = state->extrablk.blkno;\n\t}\n\t \n\tfor (lep = &leafhdr.ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     lep++, index++) {\n\t\t \n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t \n\t\tnewdb = xfs_dir2_dataptr_to_db(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address));\n\t\t \n\t\tif (newdb != curdb) {\n\t\t\t \n\t\t\tif (curbp && (args->cmpresult == XFS_CMP_DIFFERENT ||\n\t\t\t\t\t\tcurdb != state->extrablk.blkno))\n\t\t\t\txfs_trans_brelse(tp, curbp);\n\t\t\t \n\t\t\tif (args->cmpresult != XFS_CMP_DIFFERENT &&\n\t\t\t\t\tnewdb == state->extrablk.blkno) {\n\t\t\t\tASSERT(state->extravalid);\n\t\t\t\tcurbp = state->extrablk.bp;\n\t\t\t} else {\n\t\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t\txfs_dir2_db_to_da(args->geo,\n\t\t\t\t\t\t\t\t  newdb),\n\t\t\t\t\t\t0, &curbp);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t\txfs_dir3_data_check(dp, curbp);\n\t\t\tcurdb = newdb;\n\t\t}\n\t\t \n\t\tdep = (xfs_dir2_data_entry_t *)((char *)curbp->b_addr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(lep->address)));\n\t\t \n\t\tcmp = xfs_dir2_compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\t \n\t\t\tif (args->cmpresult != XFS_CMP_DIFFERENT &&\n\t\t\t\t\t\tcurdb != state->extrablk.blkno)\n\t\t\t\txfs_trans_brelse(tp, state->extrablk.bp);\n\t\t\targs->cmpresult = cmp;\n\t\t\targs->inumber = be64_to_cpu(dep->inumber);\n\t\t\targs->filetype = xfs_dir2_data_get_ftype(mp, dep);\n\t\t\t*indexp = index;\n\t\t\tstate->extravalid = 1;\n\t\t\tstate->extrablk.bp = curbp;\n\t\t\tstate->extrablk.blkno = curdb;\n\t\t\tstate->extrablk.index = (int)((char *)dep -\n\t\t\t\t\t\t\t(char *)curbp->b_addr);\n\t\t\tstate->extrablk.magic = XFS_DIR2_DATA_MAGIC;\n\t\t\tcurbp->b_ops = &xfs_dir3_data_buf_ops;\n\t\t\txfs_trans_buf_set_type(tp, curbp, XFS_BLFT_DIR_DATA_BUF);\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tASSERT(index == leafhdr.count || (args->op_flags & XFS_DA_OP_OKNOENT));\n\tif (curbp) {\n\t\tif (args->cmpresult == XFS_CMP_DIFFERENT) {\n\t\t\t \n\t\t\tstate->extravalid = 1;\n\t\t\tstate->extrablk.bp = curbp;\n\t\t\tstate->extrablk.index = -1;\n\t\t\tstate->extrablk.blkno = curdb;\n\t\t\tstate->extrablk.magic = XFS_DIR2_DATA_MAGIC;\n\t\t\tcurbp->b_ops = &xfs_dir3_data_buf_ops;\n\t\t\txfs_trans_buf_set_type(tp, curbp, XFS_BLFT_DIR_DATA_BUF);\n\t\t} else {\n\t\t\t \n\t\t\tif (state->extrablk.bp != curbp)\n\t\t\t\txfs_trans_brelse(tp, curbp);\n\t\t}\n\t} else {\n\t\tstate->extravalid = 0;\n\t}\n\t*indexp = index;\n\treturn -ENOENT;\n}\n\n \nint\nxfs_dir2_leafn_lookup_int(\n\tstruct xfs_buf\t\t*bp,\t\t \n\txfs_da_args_t\t\t*args,\t\t \n\tint\t\t\t*indexp,\t \n\txfs_da_state_t\t\t*state)\t\t \n{\n\tif (args->op_flags & XFS_DA_OP_ADDNAME)\n\t\treturn xfs_dir2_leafn_lookup_for_addname(bp, args, indexp,\n\t\t\t\t\t\t\tstate);\n\treturn xfs_dir2_leafn_lookup_for_entry(bp, args, indexp, state);\n}\n\n \nstatic void\nxfs_dir3_leafn_moveents(\n\txfs_da_args_t\t\t\t*args,\t \n\tstruct xfs_buf\t\t\t*bp_s,\t \n\tstruct xfs_dir3_icleaf_hdr\t*shdr,\n\tstruct xfs_dir2_leaf_entry\t*sents,\n\tint\t\t\t\tstart_s, \n\tstruct xfs_buf\t\t\t*bp_d,\t \n\tstruct xfs_dir3_icleaf_hdr\t*dhdr,\n\tstruct xfs_dir2_leaf_entry\t*dents,\n\tint\t\t\t\tstart_d, \n\tint\t\t\t\tcount)\t \n{\n\tint\t\t\t\tstale;\t \n\n\ttrace_xfs_dir2_leafn_moveents(args, start_s, start_d, count);\n\n\t \n\tif (count == 0)\n\t\treturn;\n\n\t \n\tif (start_d < dhdr->count) {\n\t\tmemmove(&dents[start_d + count], &dents[start_d],\n\t\t\t(dhdr->count - start_d) * sizeof(xfs_dir2_leaf_entry_t));\n\t\txfs_dir3_leaf_log_ents(args, dhdr, bp_d, start_d + count,\n\t\t\t\t       count + dhdr->count - 1);\n\t}\n\t \n\tif (shdr->stale) {\n\t\tint\ti;\t\t\t \n\n\t\tfor (i = start_s, stale = 0; i < start_s + count; i++) {\n\t\t\tif (sents[i].address ==\n\t\t\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t}\n\t} else\n\t\tstale = 0;\n\t \n\tmemcpy(&dents[start_d], &sents[start_s],\n\t\tcount * sizeof(xfs_dir2_leaf_entry_t));\n\txfs_dir3_leaf_log_ents(args, dhdr, bp_d, start_d, start_d + count - 1);\n\n\t \n\tif (start_s + count < shdr->count) {\n\t\tmemmove(&sents[start_s], &sents[start_s + count],\n\t\t\tcount * sizeof(xfs_dir2_leaf_entry_t));\n\t\txfs_dir3_leaf_log_ents(args, shdr, bp_s, start_s,\n\t\t\t\t       start_s + count - 1);\n\t}\n\n\t \n\tshdr->count -= count;\n\tshdr->stale -= stale;\n\tdhdr->count += count;\n\tdhdr->stale += stale;\n}\n\n \nint\t\t\t\t\t\t \nxfs_dir2_leafn_order(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*leaf1_bp,\t\t \n\tstruct xfs_buf\t\t*leaf2_bp)\t\t \n{\n\tstruct xfs_dir2_leaf\t*leaf1 = leaf1_bp->b_addr;\n\tstruct xfs_dir2_leaf\t*leaf2 = leaf2_bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents1;\n\tstruct xfs_dir2_leaf_entry *ents2;\n\tstruct xfs_dir3_icleaf_hdr hdr1;\n\tstruct xfs_dir3_icleaf_hdr hdr2;\n\n\txfs_dir2_leaf_hdr_from_disk(dp->i_mount, &hdr1, leaf1);\n\txfs_dir2_leaf_hdr_from_disk(dp->i_mount, &hdr2, leaf2);\n\tents1 = hdr1.ents;\n\tents2 = hdr2.ents;\n\n\tif (hdr1.count > 0 && hdr2.count > 0 &&\n\t    (be32_to_cpu(ents2[0].hashval) < be32_to_cpu(ents1[0].hashval) ||\n\t     be32_to_cpu(ents2[hdr2.count - 1].hashval) <\n\t\t\t\tbe32_to_cpu(ents1[hdr1.count - 1].hashval)))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic void\nxfs_dir2_leafn_rebalance(\n\txfs_da_state_t\t\t*state,\t\t \n\txfs_da_state_blk_t\t*blk1,\t\t \n\txfs_da_state_blk_t\t*blk2)\t\t \n{\n\txfs_da_args_t\t\t*args;\t\t \n\tint\t\t\tcount;\t\t \n\tint\t\t\tisleft;\t\t \n\txfs_dir2_leaf_t\t\t*leaf1;\t\t \n\txfs_dir2_leaf_t\t\t*leaf2;\t\t \n\tint\t\t\tmid;\t\t \n#if defined(DEBUG) || defined(XFS_WARN)\n\tint\t\t\toldstale;\t \n#endif\n\tint\t\t\toldsum;\t\t \n\tint\t\t\tswap_blocks;\t \n\tstruct xfs_dir2_leaf_entry *ents1;\n\tstruct xfs_dir2_leaf_entry *ents2;\n\tstruct xfs_dir3_icleaf_hdr hdr1;\n\tstruct xfs_dir3_icleaf_hdr hdr2;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\t \n\tswap_blocks = xfs_dir2_leafn_order(dp, blk1->bp, blk2->bp);\n\tif (swap_blocks)\n\t\tswap(blk1, blk2);\n\n\tleaf1 = blk1->bp->b_addr;\n\tleaf2 = blk2->bp->b_addr;\n\txfs_dir2_leaf_hdr_from_disk(dp->i_mount, &hdr1, leaf1);\n\txfs_dir2_leaf_hdr_from_disk(dp->i_mount, &hdr2, leaf2);\n\tents1 = hdr1.ents;\n\tents2 = hdr2.ents;\n\n\toldsum = hdr1.count + hdr2.count;\n#if defined(DEBUG) || defined(XFS_WARN)\n\toldstale = hdr1.stale + hdr2.stale;\n#endif\n\tmid = oldsum >> 1;\n\n\t \n\tif (oldsum & 1) {\n\t\txfs_dahash_t\tmidhash;\t \n\n\t\tif (mid >= hdr1.count)\n\t\t\tmidhash = be32_to_cpu(ents2[mid - hdr1.count].hashval);\n\t\telse\n\t\t\tmidhash = be32_to_cpu(ents1[mid].hashval);\n\t\tisleft = args->hashval <= midhash;\n\t}\n\t \n\telse\n\t\tisleft = 1;\n\t \n\tcount = hdr1.count - mid + (isleft == 0);\n\tif (count > 0)\n\t\txfs_dir3_leafn_moveents(args, blk1->bp, &hdr1, ents1,\n\t\t\t\t\thdr1.count - count, blk2->bp,\n\t\t\t\t\t&hdr2, ents2, 0, count);\n\telse if (count < 0)\n\t\txfs_dir3_leafn_moveents(args, blk2->bp, &hdr2, ents2, 0,\n\t\t\t\t\tblk1->bp, &hdr1, ents1,\n\t\t\t\t\thdr1.count, count);\n\n\tASSERT(hdr1.count + hdr2.count == oldsum);\n\tASSERT(hdr1.stale + hdr2.stale == oldstale);\n\n\t \n\txfs_dir2_leaf_hdr_to_disk(dp->i_mount, leaf1, &hdr1);\n\txfs_dir2_leaf_hdr_to_disk(dp->i_mount, leaf2, &hdr2);\n\txfs_dir3_leaf_log_header(args, blk1->bp);\n\txfs_dir3_leaf_log_header(args, blk2->bp);\n\n\txfs_dir3_leaf_check(dp, blk1->bp);\n\txfs_dir3_leaf_check(dp, blk2->bp);\n\n\t \n\tif (hdr1.count < hdr2.count)\n\t\tstate->inleaf = swap_blocks;\n\telse if (hdr1.count > hdr2.count)\n\t\tstate->inleaf = !swap_blocks;\n\telse\n\t\tstate->inleaf = swap_blocks ^ (blk1->index <= hdr1.count);\n\t \n\tif (!state->inleaf)\n\t\tblk2->index = blk1->index - hdr1.count;\n\n\t \n\tif (blk2->index < 0) {\n\t\tstate->inleaf = 1;\n\t\tblk2->index = 0;\n\t\txfs_alert(dp->i_mount,\n\t\"%s: picked the wrong leaf? reverting original leaf: blk1->index %d\",\n\t\t\t__func__, blk1->index);\n\t}\n}\n\nstatic int\nxfs_dir3_data_block_free(\n\txfs_da_args_t\t\t*args,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tstruct xfs_dir2_free\t*free,\n\txfs_dir2_db_t\t\tfdb,\n\tint\t\t\tfindex,\n\tstruct xfs_buf\t\t*fbp,\n\tint\t\t\tlongest)\n{\n\tint\t\t\tlogfree = 0;\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\tstruct xfs_inode\t*dp = args->dp;\n\n\txfs_dir2_free_hdr_from_disk(dp->i_mount, &freehdr, free);\n\tif (hdr) {\n\t\t \n\t\tfreehdr.bests[findex] = cpu_to_be16(longest);\n\t\txfs_dir2_free_log_bests(args, &freehdr, fbp, findex, findex);\n\t\treturn 0;\n\t}\n\n\t \n\tfreehdr.nused--;\n\n\t \n\tif (findex == freehdr.nvalid - 1) {\n\t\tint\ti;\t\t \n\n\t\tfor (i = findex - 1; i >= 0; i--) {\n\t\t\tif (freehdr.bests[i] != cpu_to_be16(NULLDATAOFF))\n\t\t\t\tbreak;\n\t\t}\n\t\tfreehdr.nvalid = i + 1;\n\t\tlogfree = 0;\n\t} else {\n\t\t \n\t\tfreehdr.bests[findex] = cpu_to_be16(NULLDATAOFF);\n\t\tlogfree = 1;\n\t}\n\n\txfs_dir2_free_hdr_to_disk(dp->i_mount, free, &freehdr);\n\txfs_dir2_free_log_header(args, fbp);\n\n\t \n\tif (!freehdr.nused) {\n\t\tint error;\n\n\t\terror = xfs_dir2_shrink_inode(args, fdb, fbp);\n\t\tif (error == 0) {\n\t\t\tfbp = NULL;\n\t\t\tlogfree = 0;\n\t\t} else if (error != -ENOSPC || args->total != 0)\n\t\t\treturn error;\n\t\t \n\t}\n\n\t \n\tif (logfree)\n\t\txfs_dir2_free_log_bests(args, &freehdr, fbp, findex, findex);\n\treturn 0;\n}\n\n \nstatic int\t\t\t\t\t \nxfs_dir2_leafn_remove(\n\txfs_da_args_t\t\t*args,\t\t \n\tstruct xfs_buf\t\t*bp,\t\t \n\tint\t\t\tindex,\t\t \n\txfs_da_state_blk_t\t*dblk,\t\t \n\tint\t\t\t*rval)\t\t \n{\n\tstruct xfs_da_geometry\t*geo = args->geo;\n\txfs_dir2_data_hdr_t\t*hdr;\t\t \n\txfs_dir2_db_t\t\tdb;\t\t \n\tstruct xfs_buf\t\t*dbp;\t\t \n\txfs_dir2_data_entry_t\t*dep;\t\t \n\txfs_inode_t\t\t*dp;\t\t \n\txfs_dir2_leaf_t\t\t*leaf;\t\t \n\txfs_dir2_leaf_entry_t\t*lep;\t\t \n\tint\t\t\tlongest;\t \n\tint\t\t\toff;\t\t \n\tint\t\t\tneedlog;\t \n\tint\t\t\tneedscan;\t \n\txfs_trans_t\t\t*tp;\t\t \n\tstruct xfs_dir2_data_free *bf;\t\t \n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_leafn_remove(args, index);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tleaf = bp->b_addr;\n\txfs_dir2_leaf_hdr_from_disk(dp->i_mount, &leafhdr, leaf);\n\n\t \n\tlep = &leafhdr.ents[index];\n\n\t \n\tdb = xfs_dir2_dataptr_to_db(geo, be32_to_cpu(lep->address));\n\tASSERT(dblk->blkno == db);\n\toff = xfs_dir2_dataptr_to_off(geo, be32_to_cpu(lep->address));\n\tASSERT(dblk->index == off);\n\n\t \n\tleafhdr.stale++;\n\txfs_dir2_leaf_hdr_to_disk(dp->i_mount, leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, bp);\n\n\tlep->address = cpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\txfs_dir3_leaf_log_ents(args, &leafhdr, bp, index, index);\n\n\t \n\tdbp = dblk->bp;\n\thdr = dbp->b_addr;\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr + off);\n\tbf = xfs_dir2_data_bestfree_p(dp->i_mount, hdr);\n\tlongest = be16_to_cpu(bf[0].length);\n\tneedlog = needscan = 0;\n\txfs_dir2_data_make_free(args, dbp, off,\n\t\txfs_dir2_data_entsize(dp->i_mount, dep->namelen), &needlog,\n\t\t&needscan);\n\t \n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp->i_mount, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\txfs_dir3_data_check(dp, dbp);\n\t \n\tif (longest < be16_to_cpu(bf[0].length)) {\n\t\tint\t\terror;\t\t \n\t\tstruct xfs_buf\t*fbp;\t\t \n\t\txfs_dir2_db_t\tfdb;\t\t \n\t\tint\t\tfindex;\t\t \n\t\txfs_dir2_free_t\t*free;\t\t \n\n\t\t \n\t\tfdb = xfs_dir2_db_to_fdb(geo, db);\n\t\terror = xfs_dir2_free_read(tp, dp, xfs_dir2_db_to_da(geo, fdb),\n\t\t\t\t\t   &fbp);\n\t\tif (error)\n\t\t\treturn error;\n\t\tfree = fbp->b_addr;\n#ifdef DEBUG\n\t{\n\t\tstruct xfs_dir3_icfree_hdr freehdr;\n\n\t\txfs_dir2_free_hdr_from_disk(dp->i_mount, &freehdr, free);\n\t\tASSERT(freehdr.firstdb == geo->free_max_bests *\n\t\t\t(fdb - xfs_dir2_byte_to_db(geo, XFS_DIR2_FREE_OFFSET)));\n\t}\n#endif\n\t\t \n\t\tfindex = xfs_dir2_db_to_fdindex(geo, db);\n\t\tlongest = be16_to_cpu(bf[0].length);\n\t\t \n\t\tif (longest == geo->blksize - geo->data_entry_offset) {\n\t\t\t \n\t\t\terror = xfs_dir2_shrink_inode(args, db, dbp);\n\t\t\tif (error == 0) {\n\t\t\t\tdblk->bp = NULL;\n\t\t\t\thdr = NULL;\n\t\t\t}\n\t\t\t \n\t\t\telse if (!(error == -ENOSPC && args->total == 0))\n\t\t\t\treturn error;\n\t\t}\n\t\t \n\t\terror = xfs_dir3_data_block_free(args, hdr, free,\n\t\t\t\t\t\t fdb, findex, fbp, longest);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_dir3_leaf_check(dp, bp);\n\t \n\t*rval = (geo->leaf_hdr_size +\n\t\t (uint)sizeof(leafhdr.ents) * (leafhdr.count - leafhdr.stale)) <\n\t\tgeo->magicpct;\n\treturn 0;\n}\n\n \nint\t\t\t\t\t\t \nxfs_dir2_leafn_split(\n\txfs_da_state_t\t\t*state,\t\t \n\txfs_da_state_blk_t\t*oldblk,\t \n\txfs_da_state_blk_t\t*newblk)\t \n{\n\txfs_da_args_t\t\t*args;\t\t \n\txfs_dablk_t\t\tblkno;\t\t \n\tint\t\t\terror;\t\t \n\tstruct xfs_inode\t*dp;\n\n\t \n\targs = state->args;\n\tdp = args->dp;\n\tASSERT(oldblk->magic == XFS_DIR2_LEAFN_MAGIC);\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\treturn error;\n\t}\n\t \n\terror = xfs_dir3_leaf_get_buf(args, xfs_dir2_da_to_db(args->geo, blkno),\n\t\t\t\t      &newblk->bp, XFS_DIR2_LEAFN_MAGIC);\n\tif (error)\n\t\treturn error;\n\n\tnewblk->blkno = blkno;\n\tnewblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t \n\txfs_dir2_leafn_rebalance(state, oldblk, newblk);\n\terror = xfs_da3_blk_link(state, oldblk, newblk);\n\tif (error) {\n\t\treturn error;\n\t}\n\t \n\tif (state->inleaf)\n\t\terror = xfs_dir2_leafn_add(oldblk->bp, args, oldblk->index);\n\telse\n\t\terror = xfs_dir2_leafn_add(newblk->bp, args, newblk->index);\n\t \n\toldblk->hashval = xfs_dir2_leaf_lasthash(dp, oldblk->bp, NULL);\n\tnewblk->hashval = xfs_dir2_leaf_lasthash(dp, newblk->bp, NULL);\n\txfs_dir3_leaf_check(dp, oldblk->bp);\n\txfs_dir3_leaf_check(dp, newblk->bp);\n\treturn error;\n}\n\n \nint\t\t\t\t\t\t \nxfs_dir2_leafn_toosmall(\n\txfs_da_state_t\t\t*state,\t\t \n\tint\t\t\t*action)\t \n{\n\txfs_da_state_blk_t\t*blk;\t\t \n\txfs_dablk_t\t\tblkno;\t\t \n\tstruct xfs_buf\t\t*bp;\t\t \n\tint\t\t\tbytes;\t\t \n\tint\t\t\tcount;\t\t \n\tint\t\t\terror;\t\t \n\tint\t\t\tforward;\t \n\tint\t\t\ti;\t\t \n\txfs_dir2_leaf_t\t\t*leaf;\t\t \n\tint\t\t\trval;\t\t \n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\t \n\tblk = &state->path.blk[state->path.active - 1];\n\tleaf = blk->bp->b_addr;\n\txfs_dir2_leaf_hdr_from_disk(dp->i_mount, &leafhdr, leaf);\n\tents = leafhdr.ents;\n\txfs_dir3_leaf_check(dp, blk->bp);\n\n\tcount = leafhdr.count - leafhdr.stale;\n\tbytes = state->args->geo->leaf_hdr_size + count * sizeof(ents[0]);\n\tif (bytes > (state->args->geo->blksize >> 1)) {\n\t\t \n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\t \n\tif (count == 0) {\n\t\t \n\t\tforward = (leafhdr.forw != 0);\n\t\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward, 0,\n\t\t\t&rval);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*action = rval ? 2 : 0;\n\t\treturn 0;\n\t}\n\t \n\tforward = leafhdr.forw < leafhdr.back;\n\tfor (i = 0, bp = NULL; i < 2; forward = !forward, i++) {\n\t\tstruct xfs_dir3_icleaf_hdr hdr2;\n\n\t\tblkno = forward ? leafhdr.forw : leafhdr.back;\n\t\tif (blkno == 0)\n\t\t\tcontinue;\n\t\t \n\t\terror = xfs_dir3_leafn_read(state->args->trans, dp, blkno, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tcount = leafhdr.count - leafhdr.stale;\n\t\tbytes = state->args->geo->blksize -\n\t\t\t(state->args->geo->blksize >> 2);\n\n\t\tleaf = bp->b_addr;\n\t\txfs_dir2_leaf_hdr_from_disk(dp->i_mount, &hdr2, leaf);\n\t\tents = hdr2.ents;\n\t\tcount += hdr2.count - hdr2.stale;\n\t\tbytes -= count * sizeof(ents[0]);\n\n\t\t \n\t\tif (bytes >= 0)\n\t\t\tbreak;\n\t\txfs_trans_brelse(state->args->trans, bp);\n\t}\n\t \n\tif (i >= 2) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\tif (blkno < blk->blkno)\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward, 0,\n\t\t\t&rval);\n\telse\n\t\terror = xfs_da3_path_shift(state, &state->path, forward, 0,\n\t\t\t&rval);\n\tif (error) {\n\t\treturn error;\n\t}\n\t*action = rval ? 0 : 1;\n\treturn 0;\n}\n\n \nvoid\nxfs_dir2_leafn_unbalance(\n\txfs_da_state_t\t\t*state,\t\t \n\txfs_da_state_blk_t\t*drop_blk,\t \n\txfs_da_state_blk_t\t*save_blk)\t \n{\n\txfs_da_args_t\t\t*args;\t\t \n\txfs_dir2_leaf_t\t\t*drop_leaf;\t \n\txfs_dir2_leaf_t\t\t*save_leaf;\t \n\tstruct xfs_dir3_icleaf_hdr savehdr;\n\tstruct xfs_dir3_icleaf_hdr drophdr;\n\tstruct xfs_dir2_leaf_entry *sents;\n\tstruct xfs_dir2_leaf_entry *dents;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\tASSERT(drop_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\tASSERT(save_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\tdrop_leaf = drop_blk->bp->b_addr;\n\tsave_leaf = save_blk->bp->b_addr;\n\n\txfs_dir2_leaf_hdr_from_disk(dp->i_mount, &savehdr, save_leaf);\n\txfs_dir2_leaf_hdr_from_disk(dp->i_mount, &drophdr, drop_leaf);\n\tsents = savehdr.ents;\n\tdents = drophdr.ents;\n\n\t \n\tif (drophdr.stale)\n\t\txfs_dir3_leaf_compact(args, &drophdr, drop_blk->bp);\n\tif (savehdr.stale)\n\t\txfs_dir3_leaf_compact(args, &savehdr, save_blk->bp);\n\n\t \n\tdrop_blk->hashval = be32_to_cpu(dents[drophdr.count - 1].hashval);\n\tif (xfs_dir2_leafn_order(dp, save_blk->bp, drop_blk->bp))\n\t\txfs_dir3_leafn_moveents(args, drop_blk->bp, &drophdr, dents, 0,\n\t\t\t\t\tsave_blk->bp, &savehdr, sents, 0,\n\t\t\t\t\tdrophdr.count);\n\telse\n\t\txfs_dir3_leafn_moveents(args, drop_blk->bp, &drophdr, dents, 0,\n\t\t\t\t\tsave_blk->bp, &savehdr, sents,\n\t\t\t\t\tsavehdr.count, drophdr.count);\n\tsave_blk->hashval = be32_to_cpu(sents[savehdr.count - 1].hashval);\n\n\t \n\txfs_dir2_leaf_hdr_to_disk(dp->i_mount, save_leaf, &savehdr);\n\txfs_dir2_leaf_hdr_to_disk(dp->i_mount, drop_leaf, &drophdr);\n\txfs_dir3_leaf_log_header(args, save_blk->bp);\n\txfs_dir3_leaf_log_header(args, drop_blk->bp);\n\n\txfs_dir3_leaf_check(dp, save_blk->bp);\n\txfs_dir3_leaf_check(dp, drop_blk->bp);\n}\n\n \nstatic int\nxfs_dir2_node_add_datablk(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_da_state_blk\t*fblk,\n\txfs_dir2_db_t\t\t*dbno,\n\tstruct xfs_buf\t\t**dbpp,\n\tstruct xfs_buf\t\t**fbpp,\n\tstruct xfs_dir3_icfree_hdr *hdr,\n\tint\t\t\t*findex)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_dir2_data_free *bf;\n\txfs_dir2_db_t\t\tfbno;\n\tstruct xfs_buf\t\t*fbp;\n\tstruct xfs_buf\t\t*dbp;\n\tint\t\t\terror;\n\n\t \n\tif (args->total == 0)\n\t\treturn -ENOSPC;\n\n\t \n\terror = xfs_dir2_grow_inode(args, XFS_DIR2_DATA_SPACE, dbno);\n\tif (error)\n\t\treturn error;\n\terror = xfs_dir3_data_init(args, *dbno, &dbp);\n\tif (error)\n\t\treturn error;\n\n\t \n\tfbno = xfs_dir2_db_to_fdb(args->geo, *dbno);\n\terror = xfs_dir2_free_try_read(tp, dp,\n\t\t\t       xfs_dir2_db_to_da(args->geo, fbno), &fbp);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (!fbp) {\n\t\terror = xfs_dir2_grow_inode(args, XFS_DIR2_FREE_SPACE, &fbno);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (XFS_IS_CORRUPT(mp,\n\t\t\t\t   xfs_dir2_db_to_fdb(args->geo, *dbno) !=\n\t\t\t\t   fbno)) {\n\t\t\txfs_alert(mp,\n\"%s: dir ino %llu needed freesp block %lld for data block %lld, got %lld\",\n\t\t\t\t__func__, (unsigned long long)dp->i_ino,\n\t\t\t\t(long long)xfs_dir2_db_to_fdb(args->geo, *dbno),\n\t\t\t\t(long long)*dbno, (long long)fbno);\n\t\t\tif (fblk) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\" fblk \"PTR_FMT\" blkno %llu index %d magic 0x%x\",\n\t\t\t\t\tfblk, (unsigned long long)fblk->blkno,\n\t\t\t\t\tfblk->index, fblk->magic);\n\t\t\t} else {\n\t\t\t\txfs_alert(mp, \" ... fblk is NULL\");\n\t\t\t}\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\t \n\t\terror = xfs_dir3_free_get_buf(args, fbno, &fbp);\n\t\tif (error)\n\t\t\treturn error;\n\t\txfs_dir2_free_hdr_from_disk(mp, hdr, fbp->b_addr);\n\n\t\t \n\t\thdr->firstdb = (fbno - xfs_dir2_byte_to_db(args->geo,\n\t\t\t\t\t\t\tXFS_DIR2_FREE_OFFSET)) *\n\t\t\t\targs->geo->free_max_bests;\n\t} else {\n\t\txfs_dir2_free_hdr_from_disk(mp, hdr, fbp->b_addr);\n\t}\n\n\t \n\t*findex = xfs_dir2_db_to_fdindex(args->geo, *dbno);\n\n\t \n\tif (*findex >= hdr->nvalid) {\n\t\tASSERT(*findex < args->geo->free_max_bests);\n\t\thdr->nvalid = *findex + 1;\n\t\thdr->bests[*findex] = cpu_to_be16(NULLDATAOFF);\n\t}\n\n\t \n\tif (hdr->bests[*findex] == cpu_to_be16(NULLDATAOFF)) {\n\t\thdr->nused++;\n\t\txfs_dir2_free_hdr_to_disk(mp, fbp->b_addr, hdr);\n\t\txfs_dir2_free_log_header(args, fbp);\n\t}\n\n\t \n\tbf = xfs_dir2_data_bestfree_p(mp, dbp->b_addr);\n\thdr->bests[*findex] = bf[0].length;\n\n\t*dbpp = dbp;\n\t*fbpp = fbp;\n\treturn 0;\n}\n\nstatic int\nxfs_dir2_node_find_freeblk(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_da_state_blk\t*fblk,\n\txfs_dir2_db_t\t\t*dbnop,\n\tstruct xfs_buf\t\t**fbpp,\n\tstruct xfs_dir3_icfree_hdr *hdr,\n\tint\t\t\t*findexp,\n\tint\t\t\tlength)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_buf\t\t*fbp = NULL;\n\txfs_dir2_db_t\t\tfirstfbno;\n\txfs_dir2_db_t\t\tlastfbno;\n\txfs_dir2_db_t\t\tifbno = -1;\n\txfs_dir2_db_t\t\tdbno = -1;\n\txfs_dir2_db_t\t\tfbno;\n\txfs_fileoff_t\t\tfo;\n\tint\t\t\tfindex = 0;\n\tint\t\t\terror;\n\n\t \n\tif (fblk) {\n\t\tfbp = fblk->bp;\n\t\tfindex = fblk->index;\n\t\txfs_dir2_free_hdr_from_disk(dp->i_mount, hdr, fbp->b_addr);\n\t\tif (findex >= 0) {\n\t\t\t \n\t\t\tASSERT(findex < hdr->nvalid);\n\t\t\tASSERT(be16_to_cpu(hdr->bests[findex]) != NULLDATAOFF);\n\t\t\tASSERT(be16_to_cpu(hdr->bests[findex]) >= length);\n\t\t\tdbno = hdr->firstdb + findex;\n\t\t\tgoto found_block;\n\t\t}\n\n\t\t \n\t\tifbno = fblk->blkno;\n\t\txfs_trans_brelse(tp, fbp);\n\t\tfbp = NULL;\n\t\tfblk->bp = NULL;\n\t}\n\n\t \n\terror = xfs_bmap_last_offset(dp, &fo, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\tlastfbno = xfs_dir2_da_to_db(args->geo, (xfs_dablk_t)fo);\n\tfirstfbno = xfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET);\n\n\tfor (fbno = lastfbno - 1; fbno >= firstfbno; fbno--) {\n\t\t \n\t\tif (fbno == ifbno)\n\t\t\tcontinue;\n\n\t\t \n\t\terror = xfs_dir2_free_try_read(tp, dp,\n\t\t\t\txfs_dir2_db_to_da(args->geo, fbno),\n\t\t\t\t&fbp);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (!fbp)\n\t\t\tcontinue;\n\n\t\txfs_dir2_free_hdr_from_disk(dp->i_mount, hdr, fbp->b_addr);\n\n\t\t \n\t\tfor (findex = hdr->nvalid - 1; findex >= 0; findex--) {\n\t\t\tif (be16_to_cpu(hdr->bests[findex]) != NULLDATAOFF &&\n\t\t\t    be16_to_cpu(hdr->bests[findex]) >= length) {\n\t\t\t\tdbno = hdr->firstdb + findex;\n\t\t\t\tgoto found_block;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\txfs_trans_brelse(tp, fbp);\n\t}\n\nfound_block:\n\t*dbnop = dbno;\n\t*fbpp = fbp;\n\t*findexp = findex;\n\treturn 0;\n}\n\n \nstatic int\nxfs_dir2_node_addname_int(\n\tstruct xfs_da_args\t*args,\t\t \n\tstruct xfs_da_state_blk\t*fblk)\t\t \n{\n\tstruct xfs_dir2_data_unused *dup;\t \n\tstruct xfs_dir2_data_entry *dep;\t \n\tstruct xfs_dir2_data_hdr *hdr;\t\t \n\tstruct xfs_dir2_data_free *bf;\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\tstruct xfs_buf\t\t*dbp;\t\t \n\tstruct xfs_buf\t\t*fbp;\t\t \n\txfs_dir2_data_aoff_t\taoff;\n\txfs_dir2_db_t\t\tdbno;\t\t \n\tint\t\t\terror;\t\t \n\tint\t\t\tfindex;\t\t \n\tint\t\t\tlength;\t\t \n\tint\t\t\tlogfree = 0;\t \n\tint\t\t\tneedlog = 0;\t \n\tint\t\t\tneedscan = 0;\t \n\t__be16\t\t\t*tagp;\t\t \n\n\tlength = xfs_dir2_data_entsize(dp->i_mount, args->namelen);\n\terror = xfs_dir2_node_find_freeblk(args, fblk, &dbno, &fbp, &freehdr,\n\t\t\t\t\t   &findex, length);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK) {\n\t\tif (dbno == -1)\n\t\t\treturn -ENOSPC;\n\t\treturn 0;\n\t}\n\n\t \n\tif (dbno == -1) {\n\t\t \n\t\tlogfree = 1;\n\t\terror = xfs_dir2_node_add_datablk(args, fblk, &dbno, &dbp, &fbp,\n\t\t\t\t\t\t  &freehdr, &findex);\n\t} else {\n\t\t \n\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, dbno),\n\t\t\t\t\t   0, &dbp);\n\t}\n\tif (error)\n\t\treturn error;\n\n\t \n\thdr = dbp->b_addr;\n\tbf = xfs_dir2_data_bestfree_p(dp->i_mount, hdr);\n\tASSERT(be16_to_cpu(bf[0].length) >= length);\n\n\t \n\tdup = (xfs_dir2_data_unused_t *)\n\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\n\t \n\taoff = (xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr);\n\terror = xfs_dir2_data_use_free(args, dbp, dup, aoff, length,\n\t\t\t&needlog, &needscan);\n\tif (error) {\n\t\txfs_trans_brelse(tp, dbp);\n\t\treturn error;\n\t}\n\n\t \n\tdep = (xfs_dir2_data_entry_t *)dup;\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdep->namelen = args->namelen;\n\tmemcpy(dep->name, args->name, dep->namelen);\n\txfs_dir2_data_put_ftype(dp->i_mount, dep, args->filetype);\n\ttagp = xfs_dir2_data_entry_tag_p(dp->i_mount, dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, dbp, dep);\n\n\t \n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp->i_mount, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\n\t \n\tif (freehdr.bests[findex] != bf[0].length) {\n\t\tfreehdr.bests[findex] = bf[0].length;\n\t\tlogfree = 1;\n\t}\n\n\t \n\tif (logfree)\n\t\txfs_dir2_free_log_bests(args, &freehdr, fbp, findex, findex);\n\n\t \n\targs->blkno = (xfs_dablk_t)dbno;\n\targs->index = be16_to_cpu(*tagp);\n\treturn 0;\n}\n\n \nint\t\t\t\t\t\t \nxfs_dir2_node_addname(\n\txfs_da_args_t\t\t*args)\t\t \n{\n\txfs_da_state_blk_t\t*blk;\t\t \n\tint\t\t\terror;\t\t \n\tint\t\t\trval;\t\t \n\txfs_da_state_t\t\t*state;\t\t \n\n\ttrace_xfs_dir2_node_addname(args);\n\n\t \n\tstate = xfs_da_state_alloc(args);\n\t \n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error)\n\t\trval = error;\n\tif (rval != -ENOENT) {\n\t\tgoto done;\n\t}\n\t \n\trval = xfs_dir2_node_addname_int(args,\n\t\tstate->extravalid ? &state->extrablk : NULL);\n\tif (rval) {\n\t\tgoto done;\n\t}\n\tblk = &state->path.blk[state->path.active - 1];\n\tASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\t \n\trval = xfs_dir2_leafn_add(blk->bp, args, blk->index);\n\tif (rval == 0) {\n\t\t \n\t\tif (!(args->op_flags & XFS_DA_OP_JUSTCHECK))\n\t\t\txfs_da3_fixhashpath(state, &state->path);\n\t} else {\n\t\t \n\t\tif (args->total == 0) {\n\t\t\tASSERT(rval == -ENOSPC);\n\t\t\tgoto done;\n\t\t}\n\t\t \n\t\trval = xfs_da3_split(state);\n\t}\ndone:\n\txfs_da_state_free(state);\n\treturn rval;\n}\n\n \nint\t\t\t\t\t\t \nxfs_dir2_node_lookup(\n\txfs_da_args_t\t*args)\t\t\t \n{\n\tint\t\terror;\t\t\t \n\tint\t\ti;\t\t\t \n\tint\t\trval;\t\t\t \n\txfs_da_state_t\t*state;\t\t\t \n\n\ttrace_xfs_dir2_node_lookup(args);\n\n\t \n\tstate = xfs_da_state_alloc(args);\n\n\t \n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error)\n\t\trval = error;\n\telse if (rval == -ENOENT && args->cmpresult == XFS_CMP_CASE) {\n\t\t \n\t\txfs_dir2_data_entry_t\t*dep;\n\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t\t((char *)state->extrablk.bp->b_addr +\n\t\t\t\t\t\t state->extrablk.index);\n\t\trval = xfs_dir_cilookup_result(args, dep->name, dep->namelen);\n\t}\n\t \n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\t \n\tif (state->extravalid && state->extrablk.bp) {\n\t\txfs_trans_brelse(args->trans, state->extrablk.bp);\n\t\tstate->extrablk.bp = NULL;\n\t}\n\txfs_da_state_free(state);\n\treturn rval;\n}\n\n \nint\t\t\t\t\t\t \nxfs_dir2_node_removename(\n\tstruct xfs_da_args\t*args)\t\t \n{\n\tstruct xfs_da_state_blk\t*blk;\t\t \n\tint\t\t\terror;\t\t \n\tint\t\t\trval;\t\t \n\tstruct xfs_da_state\t*state;\t\t \n\n\ttrace_xfs_dir2_node_removename(args);\n\n\t \n\tstate = xfs_da_state_alloc(args);\n\n\t \n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error)\n\t\tgoto out_free;\n\n\t \n\tif (rval != -EEXIST) {\n\t\terror = rval;\n\t\tgoto out_free;\n\t}\n\n\tblk = &state->path.blk[state->path.active - 1];\n\tASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\tASSERT(state->extravalid);\n\t \n\terror = xfs_dir2_leafn_remove(args, blk->bp, blk->index,\n\t\t&state->extrablk, &rval);\n\tif (error)\n\t\tgoto out_free;\n\t \n\txfs_da3_fixhashpath(state, &state->path);\n\t \n\tif (rval && state->path.active > 1)\n\t\terror = xfs_da3_join(state);\n\t \n\tif (!error)\n\t\terror = xfs_dir2_node_to_leaf(state);\nout_free:\n\txfs_da_state_free(state);\n\treturn error;\n}\n\n \nint\t\t\t\t\t\t \nxfs_dir2_node_replace(\n\txfs_da_args_t\t\t*args)\t\t \n{\n\txfs_da_state_blk_t\t*blk;\t\t \n\txfs_dir2_data_hdr_t\t*hdr;\t\t \n\txfs_dir2_data_entry_t\t*dep;\t\t \n\tint\t\t\terror;\t\t \n\tint\t\t\ti;\t\t \n\txfs_ino_t\t\tinum;\t\t \n\tint\t\t\tftype;\t\t \n\tint\t\t\trval;\t\t \n\txfs_da_state_t\t\t*state;\t\t \n\n\ttrace_xfs_dir2_node_replace(args);\n\n\t \n\tstate = xfs_da_state_alloc(args);\n\n\t \n\tinum = args->inumber;\n\tftype = args->filetype;\n\n\t \n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error) {\n\t\trval = error;\n\t}\n\t \n\tif (rval == -EEXIST) {\n\t\tstruct xfs_dir3_icleaf_hdr\tleafhdr;\n\n\t\t \n\t\tblk = &state->path.blk[state->path.active - 1];\n\t\tASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\t\tASSERT(state->extravalid);\n\n\t\txfs_dir2_leaf_hdr_from_disk(state->mp, &leafhdr,\n\t\t\t\t\t    blk->bp->b_addr);\n\t\t \n\t\thdr = state->extrablk.bp->b_addr;\n\t\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC));\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t      ((char *)hdr +\n\t\t       xfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\tbe32_to_cpu(leafhdr.ents[blk->index].address)));\n\t\tASSERT(inum != be64_to_cpu(dep->inumber));\n\t\t \n\t\tdep->inumber = cpu_to_be64(inum);\n\t\txfs_dir2_data_put_ftype(state->mp, dep, ftype);\n\t\txfs_dir2_data_log_entry(args, state->extrablk.bp, dep);\n\t\trval = 0;\n\t}\n\t \n\telse if (state->extravalid) {\n\t\txfs_trans_brelse(args->trans, state->extrablk.bp);\n\t\tstate->extrablk.bp = NULL;\n\t}\n\t \n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\txfs_da_state_free(state);\n\treturn rval;\n}\n\n \nint\t\t\t\t\t\t \nxfs_dir2_node_trim_free(\n\txfs_da_args_t\t\t*args,\t\t \n\txfs_fileoff_t\t\tfo,\t\t \n\tint\t\t\t*rvalp)\t\t \n{\n\tstruct xfs_buf\t\t*bp;\t\t \n\txfs_inode_t\t\t*dp;\t\t \n\tint\t\t\terror;\t\t \n\txfs_dir2_free_t\t\t*free;\t\t \n\txfs_trans_t\t\t*tp;\t\t \n\tstruct xfs_dir3_icfree_hdr freehdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\n\t*rvalp = 0;\n\n\t \n\terror = xfs_dir2_free_try_read(tp, dp, fo, &bp);\n\tif (error)\n\t\treturn error;\n\t \n\tif (!bp)\n\t\treturn 0;\n\tfree = bp->b_addr;\n\txfs_dir2_free_hdr_from_disk(dp->i_mount, &freehdr, free);\n\n\t \n\tif (freehdr.nused > 0) {\n\t\txfs_trans_brelse(tp, bp);\n\t\treturn 0;\n\t}\n\t \n\terror = xfs_dir2_shrink_inode(args,\n\t\t\txfs_dir2_da_to_db(args->geo, (xfs_dablk_t)fo), bp);\n\tif (error) {\n\t\t \n\t\tASSERT(error != -ENOSPC);\n\t\txfs_trans_brelse(tp, bp);\n\t\treturn error;\n\t}\n\t \n\t*rvalp = 1;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}