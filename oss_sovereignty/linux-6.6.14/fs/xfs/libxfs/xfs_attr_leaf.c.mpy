{
  "module_name": "xfs_attr_leaf.c",
  "hash_id": "e86e0f7fd49605cf2dc410a8d0fd472ce7302ffbc26cdd2239180df39134ce42",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_attr_leaf.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_log.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_errortag.h\"\n\n\n \n\n \n\n \nSTATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);\nSTATIC int xfs_attr3_leaf_add_work(struct xfs_buf *leaf_buffer,\n\t\t\t\t   struct xfs_attr3_icleaf_hdr *ichdr,\n\t\t\t\t   struct xfs_da_args *args, int freemap_index);\nSTATIC void xfs_attr3_leaf_compact(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_attr3_icleaf_hdr *ichdr,\n\t\t\t\t   struct xfs_buf *leaf_buffer);\nSTATIC void xfs_attr3_leaf_rebalance(xfs_da_state_t *state,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk1,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk2);\nSTATIC int xfs_attr3_leaf_figure_balance(xfs_da_state_t *state,\n\t\t\txfs_da_state_blk_t *leaf_blk_1,\n\t\t\tstruct xfs_attr3_icleaf_hdr *ichdr1,\n\t\t\txfs_da_state_blk_t *leaf_blk_2,\n\t\t\tstruct xfs_attr3_icleaf_hdr *ichdr2,\n\t\t\tint *number_entries_in_blk1,\n\t\t\tint *number_usedbytes_in_blk1);\n\n \nSTATIC void xfs_attr3_leaf_moveents(struct xfs_da_args *args,\n\t\t\tstruct xfs_attr_leafblock *src_leaf,\n\t\t\tstruct xfs_attr3_icleaf_hdr *src_ichdr, int src_start,\n\t\t\tstruct xfs_attr_leafblock *dst_leaf,\n\t\t\tstruct xfs_attr3_icleaf_hdr *dst_ichdr, int dst_start,\n\t\t\tint move_count);\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\n \n\nstatic void\nxfs_attr3_leaf_firstused_from_disk(\n\tstruct xfs_da_geometry\t\t*geo,\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tstruct xfs_attr3_leaf_hdr\t*hdr3;\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\thdr3 = (struct xfs_attr3_leaf_hdr *) from;\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t} else {\n\t\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\t}\n\n\t \n\tif (to->firstused == XFS_ATTR3_LEAF_NULLOFF) {\n\t\tASSERT(!to->count && !to->usedbytes);\n\t\tASSERT(geo->blksize > USHRT_MAX);\n\t\tto->firstused = geo->blksize;\n\t}\n}\n\nstatic void\nxfs_attr3_leaf_firstused_to_disk(\n\tstruct xfs_da_geometry\t\t*geo,\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tstruct xfs_attr3_leaf_hdr\t*hdr3;\n\tuint32_t\t\t\tfirstused;\n\n\t \n\tASSERT(from->firstused != XFS_ATTR3_LEAF_NULLOFF);\n\n\t \n\tfirstused = from->firstused;\n\tif (firstused > USHRT_MAX) {\n\t\tASSERT(from->firstused == geo->blksize);\n\t\tfirstused = XFS_ATTR3_LEAF_NULLOFF;\n\t}\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\thdr3 = (struct xfs_attr3_leaf_hdr *) to;\n\t\thdr3->firstused = cpu_to_be16(firstused);\n\t} else {\n\t\tto->hdr.firstused = cpu_to_be16(firstused);\n\t}\n}\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_da_geometry\t\t*geo,\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\txfs_attr3_leaf_firstused_from_disk(geo, to, from);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\txfs_attr3_leaf_firstused_from_disk(geo, to, from);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}\n\nvoid\nxfs_attr3_leaf_hdr_to_disk(\n\tstruct xfs_da_geometry\t\t*geo,\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tint\t\t\t\ti;\n\n\tASSERT(from->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       from->magic == XFS_ATTR3_LEAF_MAGIC);\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)to;\n\n\t\thdr3->info.hdr.forw = cpu_to_be32(from->forw);\n\t\thdr3->info.hdr.back = cpu_to_be32(from->back);\n\t\thdr3->info.hdr.magic = cpu_to_be16(from->magic);\n\t\thdr3->count = cpu_to_be16(from->count);\n\t\thdr3->usedbytes = cpu_to_be16(from->usedbytes);\n\t\txfs_attr3_leaf_firstused_to_disk(geo, to, from);\n\t\thdr3->holes = from->holes;\n\t\thdr3->pad1 = 0;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\thdr3->freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\t\thdr3->freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->hdr.info.forw = cpu_to_be32(from->forw);\n\tto->hdr.info.back = cpu_to_be32(from->back);\n\tto->hdr.info.magic = cpu_to_be16(from->magic);\n\tto->hdr.count = cpu_to_be16(from->count);\n\tto->hdr.usedbytes = cpu_to_be16(from->usedbytes);\n\txfs_attr3_leaf_firstused_to_disk(geo, to, from);\n\tto->hdr.holes = from->holes;\n\tto->hdr.pad1 = 0;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->hdr.freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\tto->hdr.freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t}\n}\n\nstatic xfs_failaddr_t\nxfs_attr3_leaf_verify_entry(\n\tstruct xfs_mount\t\t\t*mp,\n\tchar\t\t\t\t\t*buf_end,\n\tstruct xfs_attr_leafblock\t\t*leaf,\n\tstruct xfs_attr3_icleaf_hdr\t\t*leafhdr,\n\tstruct xfs_attr_leaf_entry\t\t*ent,\n\tint\t\t\t\t\tidx,\n\t__u32\t\t\t\t\t*last_hashval)\n{\n\tstruct xfs_attr_leaf_name_local\t\t*lentry;\n\tstruct xfs_attr_leaf_name_remote\t*rentry;\n\tchar\t\t\t\t\t*name_end;\n\tunsigned int\t\t\t\tnameidx;\n\tunsigned int\t\t\t\tnamesize;\n\t__u32\t\t\t\t\thashval;\n\n\t \n\thashval = be32_to_cpu(ent->hashval);\n\tif (hashval < *last_hashval)\n\t\treturn __this_address;\n\t*last_hashval = hashval;\n\n\tnameidx = be16_to_cpu(ent->nameidx);\n\tif (nameidx < leafhdr->firstused || nameidx >= mp->m_attr_geo->blksize)\n\t\treturn __this_address;\n\n\t \n\tif (ent->flags & XFS_ATTR_LOCAL) {\n\t\tlentry = xfs_attr3_leaf_name_local(leaf, idx);\n\t\tnamesize = xfs_attr_leaf_entsize_local(lentry->namelen,\n\t\t\t\tbe16_to_cpu(lentry->valuelen));\n\t\tname_end = (char *)lentry + namesize;\n\t\tif (lentry->namelen == 0)\n\t\t\treturn __this_address;\n\t} else {\n\t\trentry = xfs_attr3_leaf_name_remote(leaf, idx);\n\t\tnamesize = xfs_attr_leaf_entsize_remote(rentry->namelen);\n\t\tname_end = (char *)rentry + namesize;\n\t\tif (rentry->namelen == 0)\n\t\t\treturn __this_address;\n\t\tif (!(ent->flags & XFS_ATTR_INCOMPLETE) &&\n\t\t    rentry->valueblk == 0)\n\t\t\treturn __this_address;\n\t}\n\n\tif (name_end > buf_end)\n\t\treturn __this_address;\n\n\treturn NULL;\n}\n\n \nstatic xfs_failaddr_t\nxfs_attr3_leaf_verify(\n\tstruct xfs_buf\t\t\t*bp)\n{\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_mount\t\t*mp = bp->b_mount;\n\tstruct xfs_attr_leafblock\t*leaf = bp->b_addr;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\tstruct xfs_attr_leaf_entry\t*ent;\n\tchar\t\t\t\t*buf_end;\n\tuint32_t\t\t\tend;\t \n\t__u32\t\t\t\tlast_hashval = 0;\n\tint\t\t\t\ti;\n\txfs_failaddr_t\t\t\tfa;\n\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, leaf);\n\n\tfa = xfs_da3_blkinfo_verify(bp, bp->b_addr);\n\tif (fa)\n\t\treturn fa;\n\n\t \n\tif (ichdr.firstused > mp->m_attr_geo->blksize)\n\t\treturn __this_address;\n\tif (ichdr.firstused < xfs_attr3_leaf_hdr_size(leaf))\n\t\treturn __this_address;\n\n\t \n\tentries = xfs_attr3_leaf_entryp(bp->b_addr);\n\tif ((char *)&entries[ichdr.count] >\n\t    (char *)bp->b_addr + ichdr.firstused)\n\t\treturn __this_address;\n\n\t \n\tbuf_end = (char *)bp->b_addr + mp->m_attr_geo->blksize;\n\tfor (i = 0, ent = entries; i < ichdr.count; ent++, i++) {\n\t\tfa = xfs_attr3_leaf_verify_entry(mp, buf_end, leaf, &ichdr,\n\t\t\t\tent, i, &last_hashval);\n\t\tif (fa)\n\t\t\treturn fa;\n\t}\n\n\t \n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tif (ichdr.freemap[i].base > mp->m_attr_geo->blksize)\n\t\t\treturn __this_address;\n\t\tif (ichdr.freemap[i].base & 0x3)\n\t\t\treturn __this_address;\n\t\tif (ichdr.freemap[i].size > mp->m_attr_geo->blksize)\n\t\t\treturn __this_address;\n\t\tif (ichdr.freemap[i].size & 0x3)\n\t\t\treturn __this_address;\n\n\t\t \n\t\tend = (uint32_t)ichdr.freemap[i].base + ichdr.freemap[i].size;\n\t\tif (end < ichdr.freemap[i].base)\n\t\t\treturn __this_address;\n\t\tif (end > mp->m_attr_geo->blksize)\n\t\t\treturn __this_address;\n\t}\n\n\treturn NULL;\n}\n\nstatic void\nxfs_attr3_leaf_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_log_item;\n\tstruct xfs_attr3_leaf_hdr *hdr3 = bp->b_addr;\n\txfs_failaddr_t\t\tfa;\n\n\tfa = xfs_attr3_leaf_verify(bp);\n\tif (fa) {\n\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t\treturn;\n\t}\n\n\tif (!xfs_has_crc(mp))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->info.lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_ATTR3_LEAF_CRC_OFF);\n}\n\n \nstatic void\nxfs_attr3_leaf_read_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\txfs_failaddr_t\t\tfa;\n\n\tif (xfs_has_crc(mp) &&\n\t     !xfs_buf_verify_cksum(bp, XFS_ATTR3_LEAF_CRC_OFF))\n\t\txfs_verifier_error(bp, -EFSBADCRC, __this_address);\n\telse {\n\t\tfa = xfs_attr3_leaf_verify(bp);\n\t\tif (fa)\n\t\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t}\n}\n\nconst struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.name = \"xfs_attr3_leaf\",\n\t.magic16 = { cpu_to_be16(XFS_ATTR_LEAF_MAGIC),\n\t\t     cpu_to_be16(XFS_ATTR3_LEAF_MAGIC) },\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n\t.verify_struct = xfs_attr3_leaf_verify,\n};\n\nint\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, 0, bpp, XFS_ATTR_FORK,\n\t\t\t&xfs_attr3_leaf_buf_ops);\n\tif (!err && tp && *bpp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}\n\n \n\n \nstatic bool\nxfs_attr_match(\n\tstruct xfs_da_args\t*args,\n\tuint8_t\t\t\tnamelen,\n\tunsigned char\t\t*name,\n\tint\t\t\tflags)\n{\n\n\tif (args->namelen != namelen)\n\t\treturn false;\n\tif (memcmp(args->name, name, namelen) != 0)\n\t\treturn false;\n\n\t \n\tif ((args->op_flags & XFS_DA_OP_RECOVERY) &&\n\t    args->attr_filter == (flags & XFS_ATTR_NSP_ONDISK_MASK))\n\t\treturn true;\n\n\t \n\tif (args->attr_filter !=\n\t    (flags & (XFS_ATTR_NSP_ONDISK_MASK | XFS_ATTR_INCOMPLETE)))\n\t\treturn false;\n\treturn true;\n}\n\nstatic int\nxfs_attr_copy_value(\n\tstruct xfs_da_args\t*args,\n\tunsigned char\t\t*value,\n\tint\t\t\tvaluelen)\n{\n\t \n\tif (!args->valuelen) {\n\t\targs->valuelen = valuelen;\n\t\treturn 0;\n\t}\n\n\t \n\tif (args->valuelen < valuelen) {\n\t\targs->valuelen = valuelen;\n\t\treturn -ERANGE;\n\t}\n\n\tif (!args->value) {\n\t\targs->value = kvmalloc(valuelen, GFP_KERNEL | __GFP_NOLOCKDEP);\n\t\tif (!args->value)\n\t\t\treturn -ENOMEM;\n\t}\n\targs->valuelen = valuelen;\n\n\t \n\tif (args->rmtblkno)\n\t\treturn xfs_attr_rmtval_get(args);\n\n\t \n\tif (!value)\n\t\treturn -EINVAL;\n\tmemcpy(args->value, value, valuelen);\n\treturn 0;\n}\n\n \n\n \nint\nxfs_attr_shortform_bytesfit(\n\tstruct xfs_inode\t*dp,\n\tint\t\t\tbytes)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint64_t\t\t\tdsize;\n\tint\t\t\tminforkoff;\n\tint\t\t\tmaxforkoff;\n\tint\t\t\toffset;\n\n\t \n\tif (bytes > XFS_LITINO(mp))\n\t\treturn 0;\n\n\t \n\toffset = (XFS_LITINO(mp) - bytes) >> 3;\n\n\tif (dp->i_df.if_format == XFS_DINODE_FMT_DEV) {\n\t\tminforkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\t}\n\n\t \n\tif (bytes <= xfs_inode_attr_fork_size(dp))\n\t\treturn dp->i_forkoff;\n\n\t \n\tif (!xfs_has_attr2(mp))\n\t\treturn 0;\n\n\tdsize = dp->i_df.if_bytes;\n\n\tswitch (dp->i_df.if_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t \n\t\tif (!dp->i_forkoff && dp->i_df.if_bytes >\n\t\t    xfs_default_attroffset(dp))\n\t\t\tdsize = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\t \n\t\tif (dp->i_forkoff) {\n\t\t\tif (offset < dp->i_forkoff)\n\t\t\t\treturn 0;\n\t\t\treturn dp->i_forkoff;\n\t\t}\n\t\tdsize = XFS_BMAP_BROOT_SPACE(mp, dp->i_df.if_broot);\n\t\tbreak;\n\t}\n\n\t \n\tminforkoff = max_t(int64_t, dsize, XFS_BMDR_SPACE_CALC(MINDBTPTRS));\n\tminforkoff = roundup(minforkoff, 8) >> 3;\n\n\t \n\tmaxforkoff = XFS_LITINO(mp) - XFS_BMDR_SPACE_CALC(MINABTPTRS);\n\tmaxforkoff = maxforkoff >> 3;\t \n\n\tif (offset >= maxforkoff)\n\t\treturn maxforkoff;\n\tif (offset >= minforkoff)\n\t\treturn offset;\n\treturn 0;\n}\n\n \nSTATIC void\nxfs_sbversion_add_attr2(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp)\n{\n\tif (xfs_has_noattr2(mp))\n\t\treturn;\n\tif (mp->m_sb.sb_features2 & XFS_SB_VERSION2_ATTR2BIT)\n\t\treturn;\n\tif (!xfs_has_attr2(mp))\n\t\treturn;\n\n\tspin_lock(&mp->m_sb_lock);\n\txfs_add_attr2(mp);\n\tspin_unlock(&mp->m_sb_lock);\n\txfs_log_sb(tp);\n}\n\n \nvoid\nxfs_attr_shortform_create(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_ifork\t*ifp = &dp->i_af;\n\tstruct xfs_attr_sf_hdr\t*hdr;\n\n\ttrace_xfs_attr_sf_create(args);\n\n\tASSERT(ifp->if_bytes == 0);\n\tif (ifp->if_format == XFS_DINODE_FMT_EXTENTS)\n\t\tifp->if_format = XFS_DINODE_FMT_LOCAL;\n\txfs_idata_realloc(dp, sizeof(*hdr), XFS_ATTR_FORK);\n\thdr = (struct xfs_attr_sf_hdr *)ifp->if_u1.if_data;\n\tmemset(hdr, 0, sizeof(*hdr));\n\thdr->totsize = cpu_to_be16(sizeof(*hdr));\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n}\n\n \nint\nxfs_attr_sf_findname(\n\tstruct xfs_da_args\t *args,\n\tstruct xfs_attr_sf_entry **sfep,\n\tunsigned int\t\t *basep)\n{\n\tstruct xfs_attr_shortform *sf;\n\tstruct xfs_attr_sf_entry *sfe;\n\tunsigned int\t\tbase = sizeof(struct xfs_attr_sf_hdr);\n\tint\t\t\tsize = 0;\n\tint\t\t\tend;\n\tint\t\t\ti;\n\n\tsf = (struct xfs_attr_shortform *)args->dp->i_af.if_u1.if_data;\n\tsfe = &sf->list[0];\n\tend = sf->hdr.count;\n\tfor (i = 0; i < end; sfe = xfs_attr_sf_nextentry(sfe),\n\t\t\t     base += size, i++) {\n\t\tsize = xfs_attr_sf_entsize(sfe);\n\t\tif (!xfs_attr_match(args, sfe->namelen, sfe->nameval,\n\t\t\t\t    sfe->flags))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\tif (sfep != NULL)\n\t\t*sfep = sfe;\n\n\tif (basep != NULL)\n\t\t*basep = base;\n\n\tif (i == end)\n\t\treturn -ENOATTR;\n\treturn -EEXIST;\n}\n\n \nvoid\nxfs_attr_shortform_add(\n\tstruct xfs_da_args\t\t*args,\n\tint\t\t\t\tforkoff)\n{\n\tstruct xfs_attr_shortform\t*sf;\n\tstruct xfs_attr_sf_entry\t*sfe;\n\tint\t\t\t\toffset, size;\n\tstruct xfs_mount\t\t*mp;\n\tstruct xfs_inode\t\t*dp;\n\tstruct xfs_ifork\t\t*ifp;\n\n\ttrace_xfs_attr_sf_add(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tdp->i_forkoff = forkoff;\n\n\tifp = &dp->i_af;\n\tASSERT(ifp->if_format == XFS_DINODE_FMT_LOCAL);\n\tsf = (struct xfs_attr_shortform *)ifp->if_u1.if_data;\n\tif (xfs_attr_sf_findname(args, &sfe, NULL) == -EEXIST)\n\t\tASSERT(0);\n\n\toffset = (char *)sfe - (char *)sf;\n\tsize = xfs_attr_sf_entsize_byname(args->namelen, args->valuelen);\n\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\n\tsf = (struct xfs_attr_shortform *)ifp->if_u1.if_data;\n\tsfe = (struct xfs_attr_sf_entry *)((char *)sf + offset);\n\n\tsfe->namelen = args->namelen;\n\tsfe->valuelen = args->valuelen;\n\tsfe->flags = args->attr_filter;\n\tmemcpy(sfe->nameval, args->name, args->namelen);\n\tmemcpy(&sfe->nameval[args->namelen], args->value, args->valuelen);\n\tsf->hdr.count++;\n\tbe16_add_cpu(&sf->hdr.totsize, size);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n\n\txfs_sbversion_add_attr2(mp, args->trans);\n}\n\n \nvoid\nxfs_attr_fork_remove(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp)\n{\n\tASSERT(ip->i_af.if_nextents == 0);\n\n\txfs_ifork_zap_attr(ip);\n\tip->i_forkoff = 0;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n}\n\n \nint\nxfs_attr_sf_removename(\n\tstruct xfs_da_args\t\t*args)\n{\n\tstruct xfs_attr_shortform\t*sf;\n\tstruct xfs_attr_sf_entry\t*sfe;\n\tint\t\t\t\tsize = 0, end, totsize;\n\tunsigned int\t\t\tbase;\n\tstruct xfs_mount\t\t*mp;\n\tstruct xfs_inode\t\t*dp;\n\tint\t\t\t\terror;\n\n\ttrace_xfs_attr_sf_remove(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tsf = (struct xfs_attr_shortform *)dp->i_af.if_u1.if_data;\n\n\terror = xfs_attr_sf_findname(args, &sfe, &base);\n\n\t \n\tif (error == -ENOATTR && (args->op_flags & XFS_DA_OP_RECOVERY))\n\t\treturn 0;\n\tif (error != -EEXIST)\n\t\treturn error;\n\tsize = xfs_attr_sf_entsize(sfe);\n\n\t \n\tend = base + size;\n\ttotsize = be16_to_cpu(sf->hdr.totsize);\n\tif (end != totsize)\n\t\tmemmove(&((char *)sf)[base], &((char *)sf)[end], totsize - end);\n\tsf->hdr.count--;\n\tbe16_add_cpu(&sf->hdr.totsize, -size);\n\n\t \n\ttotsize -= size;\n\tif (totsize == sizeof(xfs_attr_sf_hdr_t) && xfs_has_attr2(mp) &&\n\t    (dp->i_df.if_format != XFS_DINODE_FMT_BTREE) &&\n\t    !(args->op_flags & (XFS_DA_OP_ADDNAME | XFS_DA_OP_REPLACE))) {\n\t\txfs_attr_fork_remove(dp, args->trans);\n\t} else {\n\t\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\t\tdp->i_forkoff = xfs_attr_shortform_bytesfit(dp, totsize);\n\t\tASSERT(dp->i_forkoff);\n\t\tASSERT(totsize > sizeof(xfs_attr_sf_hdr_t) ||\n\t\t\t\t(args->op_flags & XFS_DA_OP_ADDNAME) ||\n\t\t\t\t!xfs_has_attr2(mp) ||\n\t\t\t\tdp->i_df.if_format == XFS_DINODE_FMT_BTREE);\n\t\txfs_trans_log_inode(args->trans, dp,\n\t\t\t\t\tXFS_ILOG_CORE | XFS_ILOG_ADATA);\n\t}\n\n\txfs_sbversion_add_attr2(mp, args->trans);\n\n\treturn 0;\n}\n\n \n \nint\nxfs_attr_shortform_lookup(xfs_da_args_t *args)\n{\n\tstruct xfs_attr_shortform *sf;\n\tstruct xfs_attr_sf_entry *sfe;\n\tint i;\n\tstruct xfs_ifork *ifp;\n\n\ttrace_xfs_attr_sf_lookup(args);\n\n\tifp = &args->dp->i_af;\n\tASSERT(ifp->if_format == XFS_DINODE_FMT_LOCAL);\n\tsf = (struct xfs_attr_shortform *)ifp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count;\n\t\t\t\tsfe = xfs_attr_sf_nextentry(sfe), i++) {\n\t\tif (xfs_attr_match(args, sfe->namelen, sfe->nameval,\n\t\t\t\tsfe->flags))\n\t\t\treturn -EEXIST;\n\t}\n\treturn -ENOATTR;\n}\n\n \nint\nxfs_attr_shortform_getvalue(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_shortform *sf;\n\tstruct xfs_attr_sf_entry *sfe;\n\tint\t\t\ti;\n\n\tASSERT(args->dp->i_af.if_format == XFS_DINODE_FMT_LOCAL);\n\tsf = (struct xfs_attr_shortform *)args->dp->i_af.if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count;\n\t\t\t\tsfe = xfs_attr_sf_nextentry(sfe), i++) {\n\t\tif (xfs_attr_match(args, sfe->namelen, sfe->nameval,\n\t\t\t\tsfe->flags))\n\t\t\treturn xfs_attr_copy_value(args,\n\t\t\t\t&sfe->nameval[args->namelen], sfe->valuelen);\n\t}\n\treturn -ENOATTR;\n}\n\n \nint\nxfs_attr_shortform_to_leaf(\n\tstruct xfs_da_args\t\t*args)\n{\n\tstruct xfs_inode\t\t*dp;\n\tstruct xfs_attr_shortform\t*sf;\n\tstruct xfs_attr_sf_entry\t*sfe;\n\tstruct xfs_da_args\t\tnargs;\n\tchar\t\t\t\t*tmpbuffer;\n\tint\t\t\t\terror, i, size;\n\txfs_dablk_t\t\t\tblkno;\n\tstruct xfs_buf\t\t\t*bp;\n\tstruct xfs_ifork\t\t*ifp;\n\n\ttrace_xfs_attr_sf_to_leaf(args);\n\n\tdp = args->dp;\n\tifp = &dp->i_af;\n\tsf = (struct xfs_attr_shortform *)ifp->if_u1.if_data;\n\tsize = be16_to_cpu(sf->hdr.totsize);\n\ttmpbuffer = kmem_alloc(size, 0);\n\tASSERT(tmpbuffer != NULL);\n\tmemcpy(tmpbuffer, ifp->if_u1.if_data, size);\n\tsf = (struct xfs_attr_shortform *)tmpbuffer;\n\n\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\txfs_bmap_local_to_extents_empty(args->trans, dp, XFS_ATTR_FORK);\n\n\tbp = NULL;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error)\n\t\tgoto out;\n\n\tASSERT(blkno == 0);\n\terror = xfs_attr3_leaf_create(args, blkno, &bp);\n\tif (error)\n\t\tgoto out;\n\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.dp = dp;\n\tnargs.geo = args->geo;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; i++) {\n\t\tnargs.name = sfe->nameval;\n\t\tnargs.namelen = sfe->namelen;\n\t\tnargs.value = &sfe->nameval[nargs.namelen];\n\t\tnargs.valuelen = sfe->valuelen;\n\t\tnargs.hashval = xfs_da_hashname(sfe->nameval,\n\t\t\t\t\t\tsfe->namelen);\n\t\tnargs.attr_filter = sfe->flags & XFS_ATTR_NSP_ONDISK_MASK;\n\t\terror = xfs_attr3_leaf_lookup_int(bp, &nargs);  \n\t\tASSERT(error == -ENOATTR);\n\t\terror = xfs_attr3_leaf_add(bp, &nargs);\n\t\tASSERT(error != -ENOSPC);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tsfe = xfs_attr_sf_nextentry(sfe);\n\t}\n\terror = 0;\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}\n\n \nint\nxfs_attr_shortform_allfit(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tstruct xfs_attr3_icleaf_hdr leafhdr;\n\tint\t\t\tbytes;\n\tint\t\t\ti;\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &leafhdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\tbytes = sizeof(struct xfs_attr_sf_hdr);\n\tfor (i = 0; i < leafhdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t \n\t\tif (!(entry->flags & XFS_ATTR_LOCAL))\n\t\t\treturn 0;\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tif (name_loc->namelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tif (be16_to_cpu(name_loc->valuelen) >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tbytes += xfs_attr_sf_entsize_byname(name_loc->namelen,\n\t\t\t\t\tbe16_to_cpu(name_loc->valuelen));\n\t}\n\tif (xfs_has_attr2(dp->i_mount) &&\n\t    (dp->i_df.if_format != XFS_DINODE_FMT_BTREE) &&\n\t    (bytes == sizeof(struct xfs_attr_sf_hdr)))\n\t\treturn -1;\n\treturn xfs_attr_shortform_bytesfit(dp, bytes);\n}\n\n \nxfs_failaddr_t\nxfs_attr_shortform_verify(\n\tstruct xfs_inode\t\t*ip)\n{\n\tstruct xfs_attr_shortform\t*sfp;\n\tstruct xfs_attr_sf_entry\t*sfep;\n\tstruct xfs_attr_sf_entry\t*next_sfep;\n\tchar\t\t\t\t*endp;\n\tstruct xfs_ifork\t\t*ifp;\n\tint\t\t\t\ti;\n\tint64_t\t\t\t\tsize;\n\n\tASSERT(ip->i_af.if_format == XFS_DINODE_FMT_LOCAL);\n\tifp = xfs_ifork_ptr(ip, XFS_ATTR_FORK);\n\tsfp = (struct xfs_attr_shortform *)ifp->if_u1.if_data;\n\tsize = ifp->if_bytes;\n\n\t \n\tif (size < sizeof(struct xfs_attr_sf_hdr))\n\t\treturn __this_address;\n\n\tendp = (char *)sfp + size;\n\n\t \n\tsfep = &sfp->list[0];\n\tfor (i = 0; i < sfp->hdr.count; i++) {\n\t\t \n\t\tif (((char *)sfep + sizeof(*sfep)) >= endp)\n\t\t\treturn __this_address;\n\n\t\t \n\t\tif (sfep->namelen == 0)\n\t\t\treturn __this_address;\n\n\t\t \n\t\tnext_sfep = xfs_attr_sf_nextentry(sfep);\n\t\tif ((char *)next_sfep > endp)\n\t\t\treturn __this_address;\n\n\t\t \n\t\tif (sfep->flags & ~XFS_ATTR_NSP_ONDISK_MASK)\n\t\t\treturn __this_address;\n\n\t\t \n\t\tif (hweight8(sfep->flags & XFS_ATTR_NSP_ONDISK_MASK) > 1)\n\t\t\treturn __this_address;\n\n\t\tsfep = next_sfep;\n\t}\n\tif ((void *)sfep != (void *)endp)\n\t\treturn __this_address;\n\n\treturn NULL;\n}\n\n \nint\nxfs_attr3_leaf_to_shortform(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tforkoff)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_da_args\tnargs;\n\tstruct xfs_inode\t*dp = args->dp;\n\tchar\t\t\t*tmpbuffer;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_to_sf(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, 0);\n\tif (!tmpbuffer)\n\t\treturn -ENOMEM;\n\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\n\tleaf = (xfs_attr_leafblock_t *)tmpbuffer;\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\t \n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\n\t \n\terror = xfs_da_shrink_inode(args, 0, bp);\n\tif (error)\n\t\tgoto out;\n\n\tif (forkoff == -1) {\n\t\t \n\t\tif (!(args->op_flags & XFS_DA_OP_REPLACE)) {\n\t\t\tASSERT(xfs_has_attr2(dp->i_mount));\n\t\t\tASSERT(dp->i_df.if_format != XFS_DINODE_FMT_BTREE);\n\t\t\txfs_attr_fork_remove(dp, args->trans);\n\t\t}\n\t\tgoto out;\n\t}\n\n\txfs_attr_shortform_create(args);\n\n\t \n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.geo = args->geo;\n\tnargs.dp = dp;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t \n\t\tif (!entry->nameidx)\n\t\t\tcontinue;\n\t\tASSERT(entry->flags & XFS_ATTR_LOCAL);\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tnargs.name = name_loc->nameval;\n\t\tnargs.namelen = name_loc->namelen;\n\t\tnargs.value = &name_loc->nameval[nargs.namelen];\n\t\tnargs.valuelen = be16_to_cpu(name_loc->valuelen);\n\t\tnargs.hashval = be32_to_cpu(entry->hashval);\n\t\tnargs.attr_filter = entry->flags & XFS_ATTR_NSP_ONDISK_MASK;\n\t\txfs_attr_shortform_add(&nargs, forkoff);\n\t}\n\terror = 0;\n\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}\n\n \nint\nxfs_attr3_leaf_to_node(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr icleafhdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_da3_icnode_hdr icnodehdr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp1 = NULL;\n\tstruct xfs_buf\t\t*bp2 = NULL;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_leaf_to_node(args);\n\n\tif (XFS_TEST_ERROR(false, mp, XFS_ERRTAG_ATTR_LEAF_TO_NODE)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error)\n\t\tgoto out;\n\terror = xfs_attr3_leaf_read(args->trans, dp, 0, &bp1);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_da_get_buf(args->trans, dp, blkno, &bp2, XFS_ATTR_FORK);\n\tif (error)\n\t\tgoto out;\n\n\t \n\txfs_trans_buf_set_type(args->trans, bp2, XFS_BLFT_ATTR_LEAF_BUF);\n\tbp2->b_ops = bp1->b_ops;\n\tmemcpy(bp2->b_addr, bp1->b_addr, args->geo->blksize);\n\tif (xfs_has_crc(mp)) {\n\t\tstruct xfs_da3_blkinfo *hdr3 = bp2->b_addr;\n\t\thdr3->blkno = cpu_to_be64(xfs_buf_daddr(bp2));\n\t}\n\txfs_trans_log_buf(args->trans, bp2, 0, args->geo->blksize - 1);\n\n\t \n\terror = xfs_da3_node_create(args, 0, 1, &bp1, XFS_ATTR_FORK);\n\tif (error)\n\t\tgoto out;\n\tnode = bp1->b_addr;\n\txfs_da3_node_hdr_from_disk(mp, &icnodehdr, node);\n\n\tleaf = bp2->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &icleafhdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\t \n\ticnodehdr.btree[0].hashval = entries[icleafhdr.count - 1].hashval;\n\ticnodehdr.btree[0].before = cpu_to_be32(blkno);\n\ticnodehdr.count = 1;\n\txfs_da3_node_hdr_to_disk(dp->i_mount, node, &icnodehdr);\n\txfs_trans_log_buf(args->trans, bp1, 0, args->geo->blksize - 1);\n\terror = 0;\nout:\n\treturn error;\n}\n\n \n\n \nSTATIC int\nxfs_attr3_leaf_create(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tblkno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_leaf_create(args);\n\n\terror = xfs_da_get_buf(args->trans, args->dp, blkno, &bp,\n\t\t\t\t\t    XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\txfs_trans_buf_set_type(args->trans, bp, XFS_BLFT_ATTR_LEAF_BUF);\n\tleaf = bp->b_addr;\n\tmemset(leaf, 0, args->geo->blksize);\n\n\tmemset(&ichdr, 0, sizeof(ichdr));\n\tichdr.firstused = args->geo->blksize;\n\n\tif (xfs_has_crc(mp)) {\n\t\tstruct xfs_da3_blkinfo *hdr3 = bp->b_addr;\n\n\t\tichdr.magic = XFS_ATTR3_LEAF_MAGIC;\n\n\t\thdr3->blkno = cpu_to_be64(xfs_buf_daddr(bp));\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_meta_uuid);\n\n\t\tichdr.freemap[0].base = sizeof(struct xfs_attr3_leaf_hdr);\n\t} else {\n\t\tichdr.magic = XFS_ATTR_LEAF_MAGIC;\n\t\tichdr.freemap[0].base = sizeof(struct xfs_attr_leaf_hdr);\n\t}\n\tichdr.freemap[0].size = ichdr.firstused - ichdr.freemap[0].base;\n\n\txfs_attr3_leaf_hdr_to_disk(args->geo, leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp, 0, args->geo->blksize - 1);\n\n\t*bpp = bp;\n\treturn 0;\n}\n\n \nint\nxfs_attr3_leaf_split(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*oldblk,\n\tstruct xfs_da_state_blk\t*newblk)\n{\n\txfs_dablk_t blkno;\n\tint error;\n\n\ttrace_xfs_attr_leaf_split(state->args);\n\n\t \n\tASSERT(oldblk->magic == XFS_ATTR_LEAF_MAGIC);\n\terror = xfs_da_grow_inode(state->args, &blkno);\n\tif (error)\n\t\treturn error;\n\terror = xfs_attr3_leaf_create(state->args, blkno, &newblk->bp);\n\tif (error)\n\t\treturn error;\n\tnewblk->blkno = blkno;\n\tnewblk->magic = XFS_ATTR_LEAF_MAGIC;\n\n\t \n\txfs_attr3_leaf_rebalance(state, oldblk, newblk);\n\terror = xfs_da3_blk_link(state, oldblk, newblk);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (state->inleaf) {\n\t\ttrace_xfs_attr_leaf_add_old(state->args);\n\t\terror = xfs_attr3_leaf_add(oldblk->bp, state->args);\n\t} else {\n\t\ttrace_xfs_attr_leaf_add_new(state->args);\n\t\terror = xfs_attr3_leaf_add(newblk->bp, state->args);\n\t}\n\n\t \n\toldblk->hashval = xfs_attr_leaf_lasthash(oldblk->bp, NULL);\n\tnewblk->hashval = xfs_attr_leaf_lasthash(newblk->bp, NULL);\n\treturn error;\n}\n\n \nint\nxfs_attr3_leaf_add(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tint\t\t\ttablesize;\n\tint\t\t\tentsize;\n\tint\t\t\tsum;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tASSERT(args->index >= 0 && args->index <= ichdr.count);\n\tentsize = xfs_attr_leaf_newentsize(args, NULL);\n\n\t \n\ttablesize = (ichdr.count + 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\tfor (sum = 0, i = XFS_ATTR_LEAF_MAPSIZE - 1; i >= 0; i--) {\n\t\tif (tablesize > ichdr.firstused) {\n\t\t\tsum += ichdr.freemap[i].size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ichdr.freemap[i].size)\n\t\t\tcontinue;\t \n\t\ttmp = entsize;\n\t\tif (ichdr.freemap[i].base < ichdr.firstused)\n\t\t\ttmp += sizeof(xfs_attr_leaf_entry_t);\n\t\tif (ichdr.freemap[i].size >= tmp) {\n\t\t\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, i);\n\t\t\tgoto out_log_hdr;\n\t\t}\n\t\tsum += ichdr.freemap[i].size;\n\t}\n\n\t \n\tif (!ichdr.holes && sum < entsize)\n\t\treturn -ENOSPC;\n\n\t \n\txfs_attr3_leaf_compact(args, &ichdr, bp);\n\n\t \n\tif (ichdr.freemap[0].size < (entsize + sizeof(xfs_attr_leaf_entry_t))) {\n\t\ttmp = -ENOSPC;\n\t\tgoto out_log_hdr;\n\t}\n\n\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, 0);\n\nout_log_hdr:\n\txfs_attr3_leaf_hdr_to_disk(args->geo, leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\tXFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\txfs_attr3_leaf_hdr_size(leaf)));\n\treturn tmp;\n}\n\n \nSTATIC int\nxfs_attr3_leaf_add_work(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_attr3_icleaf_hdr *ichdr,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tmapindex)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_mount\t*mp;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add_work(args);\n\n\tleaf = bp->b_addr;\n\tASSERT(mapindex >= 0 && mapindex < XFS_ATTR_LEAF_MAPSIZE);\n\tASSERT(args->index >= 0 && args->index <= ichdr->count);\n\n\t \n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (args->index < ichdr->count) {\n\t\ttmp  = ichdr->count - args->index;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tmemmove(entry + 1, entry, tmp);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(*entry)));\n\t}\n\tichdr->count++;\n\n\t \n\tmp = args->trans->t_mountp;\n\tASSERT(ichdr->freemap[mapindex].base < args->geo->blksize);\n\tASSERT((ichdr->freemap[mapindex].base & 0x3) == 0);\n\tASSERT(ichdr->freemap[mapindex].size >=\n\t\txfs_attr_leaf_newentsize(args, NULL));\n\tASSERT(ichdr->freemap[mapindex].size < args->geo->blksize);\n\tASSERT((ichdr->freemap[mapindex].size & 0x3) == 0);\n\n\tichdr->freemap[mapindex].size -= xfs_attr_leaf_newentsize(args, &tmp);\n\n\tentry->nameidx = cpu_to_be16(ichdr->freemap[mapindex].base +\n\t\t\t\t     ichdr->freemap[mapindex].size);\n\tentry->hashval = cpu_to_be32(args->hashval);\n\tentry->flags = args->attr_filter;\n\tif (tmp)\n\t\tentry->flags |= XFS_ATTR_LOCAL;\n\tif (args->op_flags & XFS_DA_OP_REPLACE) {\n\t\tif (!(args->op_flags & XFS_DA_OP_LOGGED))\n\t\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\tif ((args->blkno2 == args->blkno) &&\n\t\t    (args->index2 <= args->index)) {\n\t\t\targs->index2++;\n\t\t}\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tASSERT((args->index == 0) ||\n\t       (be32_to_cpu(entry->hashval) >= be32_to_cpu((entry-1)->hashval)));\n\tASSERT((args->index == ichdr->count - 1) ||\n\t       (be32_to_cpu(entry->hashval) <= be32_to_cpu((entry+1)->hashval)));\n\n\t \n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tname_loc->namelen = args->namelen;\n\t\tname_loc->valuelen = cpu_to_be16(args->valuelen);\n\t\tmemcpy((char *)name_loc->nameval, args->name, args->namelen);\n\t\tmemcpy((char *)&name_loc->nameval[args->namelen], args->value,\n\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->namelen = args->namelen;\n\t\tmemcpy((char *)name_rmt->name, args->name, args->namelen);\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\t \n\t\tname_rmt->valuelen = 0;\n\t\tname_rmt->valueblk = 0;\n\t\targs->rmtblkno = 1;\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\t\targs->rmtvaluelen = args->valuelen;\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   xfs_attr_leaf_entsize(leaf, args->index)));\n\n\t \n\tif (be16_to_cpu(entry->nameidx) < ichdr->firstused)\n\t\tichdr->firstused = be16_to_cpu(entry->nameidx);\n\n\tASSERT(ichdr->firstused >= ichdr->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf));\n\ttmp = (ichdr->count - 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tif (ichdr->freemap[i].base == tmp) {\n\t\t\tichdr->freemap[i].base += sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr->freemap[i].size -=\n\t\t\t\tmin_t(uint16_t, ichdr->freemap[i].size,\n\t\t\t\t\t\tsizeof(xfs_attr_leaf_entry_t));\n\t\t}\n\t}\n\tichdr->usedbytes += xfs_attr_leaf_entsize(leaf, args->index);\n\treturn 0;\n}\n\n \nSTATIC void\nxfs_attr3_leaf_compact(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_attr3_icleaf_hdr *ichdr_dst,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_attr_leafblock *leaf_src;\n\tstruct xfs_attr_leafblock *leaf_dst;\n\tstruct xfs_attr3_icleaf_hdr ichdr_src;\n\tstruct xfs_trans\t*trans = args->trans;\n\tchar\t\t\t*tmpbuffer;\n\n\ttrace_xfs_attr_leaf_compact(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, 0);\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\tleaf_src = (xfs_attr_leafblock_t *)tmpbuffer;\n\tleaf_dst = bp->b_addr;\n\n\t \n\tmemcpy(bp->b_addr, tmpbuffer, xfs_attr3_leaf_hdr_size(leaf_src));\n\n\t \n\tichdr_src = *ichdr_dst;\t \n\tichdr_dst->firstused = args->geo->blksize;\n\tichdr_dst->usedbytes = 0;\n\tichdr_dst->count = 0;\n\tichdr_dst->holes = 0;\n\tichdr_dst->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_src);\n\tichdr_dst->freemap[0].size = ichdr_dst->firstused -\n\t\t\t\t\t\tichdr_dst->freemap[0].base;\n\n\t \n\txfs_attr3_leaf_hdr_to_disk(args->geo, leaf_dst, ichdr_dst);\n\n\t \n\txfs_attr3_leaf_moveents(args, leaf_src, &ichdr_src, 0,\n\t\t\t\tleaf_dst, ichdr_dst, 0, ichdr_src.count);\n\t \n\txfs_trans_log_buf(trans, bp, 0, args->geo->blksize - 1);\n\n\tkmem_free(tmpbuffer);\n}\n\n \nstatic int\nxfs_attr3_leaf_order(\n\tstruct xfs_buf\t*leaf1_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf1hdr,\n\tstruct xfs_buf\t*leaf2_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf2hdr)\n{\n\tstruct xfs_attr_leaf_entry *entries1;\n\tstruct xfs_attr_leaf_entry *entries2;\n\n\tentries1 = xfs_attr3_leaf_entryp(leaf1_bp->b_addr);\n\tentries2 = xfs_attr3_leaf_entryp(leaf2_bp->b_addr);\n\tif (leaf1hdr->count > 0 && leaf2hdr->count > 0 &&\n\t    ((be32_to_cpu(entries2[0].hashval) <\n\t      be32_to_cpu(entries1[0].hashval)) ||\n\t     (be32_to_cpu(entries2[leaf2hdr->count - 1].hashval) <\n\t      be32_to_cpu(entries1[leaf1hdr->count - 1].hashval)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint\nxfs_attr_leaf_order(\n\tstruct xfs_buf\t*leaf1_bp,\n\tstruct xfs_buf\t*leaf2_bp)\n{\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\tstruct xfs_mount *mp = leaf1_bp->b_mount;\n\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr1, leaf1_bp->b_addr);\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr2, leaf2_bp->b_addr);\n\treturn xfs_attr3_leaf_order(leaf1_bp, &ichdr1, leaf2_bp, &ichdr2);\n}\n\n \nSTATIC void\nxfs_attr3_leaf_rebalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*blk1,\n\tstruct xfs_da_state_blk\t*blk2)\n{\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\tstruct xfs_attr_leaf_entry *entries1;\n\tstruct xfs_attr_leaf_entry *entries2;\n\tint\t\t\tcount;\n\tint\t\t\ttotallen;\n\tint\t\t\tmax;\n\tint\t\t\tspace;\n\tint\t\t\tswap;\n\n\t \n\tASSERT(blk1->magic == XFS_ATTR_LEAF_MAGIC);\n\tASSERT(blk2->magic == XFS_ATTR_LEAF_MAGIC);\n\tleaf1 = blk1->bp->b_addr;\n\tleaf2 = blk2->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(state->args->geo, &ichdr1, leaf1);\n\txfs_attr3_leaf_hdr_from_disk(state->args->geo, &ichdr2, leaf2);\n\tASSERT(ichdr2.count == 0);\n\targs = state->args;\n\n\ttrace_xfs_attr_leaf_rebalance(args);\n\n\t \n\tswap = 0;\n\tif (xfs_attr3_leaf_order(blk1->bp, &ichdr1, blk2->bp, &ichdr2)) {\n\t\tswap(blk1, blk2);\n\n\t\t \n\t\tswap(ichdr1, ichdr2);\n\n\t\tleaf1 = blk1->bp->b_addr;\n\t\tleaf2 = blk2->bp->b_addr;\n\t\tswap = 1;\n\t}\n\n\t \n\tstate->inleaf = xfs_attr3_leaf_figure_balance(state, blk1, &ichdr1,\n\t\t\t\t\t\t      blk2, &ichdr2,\n\t\t\t\t\t\t      &count, &totallen);\n\tif (swap)\n\t\tstate->inleaf = !state->inleaf;\n\n\t \n\tif (count < ichdr1.count) {\n\t\t \n\t\t \n\t\tcount = ichdr1.count - count;\n\t\tspace  = ichdr1.usedbytes - totallen;\n\t\tspace += count * sizeof(xfs_attr_leaf_entry_t);\n\n\t\t \n\t\tmax  = ichdr2.firstused - xfs_attr3_leaf_hdr_size(leaf1);\n\t\tmax -= ichdr2.count * sizeof(xfs_attr_leaf_entry_t);\n\t\tif (space > max)\n\t\t\txfs_attr3_leaf_compact(args, &ichdr2, blk2->bp);\n\n\t\t \n\t\txfs_attr3_leaf_moveents(args, leaf1, &ichdr1,\n\t\t\t\tichdr1.count - count, leaf2, &ichdr2, 0, count);\n\n\t} else if (count > ichdr1.count) {\n\t\t \n\t\tASSERT(0);\n\n\t\t \n\t\t \n\t\tcount -= ichdr1.count;\n\t\tspace  = totallen - ichdr1.usedbytes;\n\t\tspace += count * sizeof(xfs_attr_leaf_entry_t);\n\n\t\t \n\t\tmax  = ichdr1.firstused - xfs_attr3_leaf_hdr_size(leaf1);\n\t\tmax -= ichdr1.count * sizeof(xfs_attr_leaf_entry_t);\n\t\tif (space > max)\n\t\t\txfs_attr3_leaf_compact(args, &ichdr1, blk1->bp);\n\n\t\t \n\t\txfs_attr3_leaf_moveents(args, leaf2, &ichdr2, 0, leaf1, &ichdr1,\n\t\t\t\t\tichdr1.count, count);\n\t}\n\n\txfs_attr3_leaf_hdr_to_disk(state->args->geo, leaf1, &ichdr1);\n\txfs_attr3_leaf_hdr_to_disk(state->args->geo, leaf2, &ichdr2);\n\txfs_trans_log_buf(args->trans, blk1->bp, 0, args->geo->blksize - 1);\n\txfs_trans_log_buf(args->trans, blk2->bp, 0, args->geo->blksize - 1);\n\n\t \n\tentries1 = xfs_attr3_leaf_entryp(leaf1);\n\tentries2 = xfs_attr3_leaf_entryp(leaf2);\n\tblk1->hashval = be32_to_cpu(entries1[ichdr1.count - 1].hashval);\n\tblk2->hashval = be32_to_cpu(entries2[ichdr2.count - 1].hashval);\n\n\t \n\tif (blk1->index > ichdr1.count) {\n\t\tASSERT(state->inleaf == 0);\n\t\tblk2->index = blk1->index - ichdr1.count;\n\t\targs->index = args->index2 = blk2->index;\n\t\targs->blkno = args->blkno2 = blk2->blkno;\n\t} else if (blk1->index == ichdr1.count) {\n\t\tif (state->inleaf) {\n\t\t\targs->index = blk1->index;\n\t\t\targs->blkno = blk1->blkno;\n\t\t\targs->index2 = 0;\n\t\t\targs->blkno2 = blk2->blkno;\n\t\t} else {\n\t\t\t \n\t\t\tblk2->index = blk1->index - ichdr1.count;\n\t\t\targs->index = blk2->index;\n\t\t\targs->blkno = blk2->blkno;\n\t\t\tif (!state->extravalid) {\n\t\t\t\t \n\t\t\t\targs->index2 = blk2->index;\n\t\t\t\targs->blkno2 = blk2->blkno;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tASSERT(state->inleaf == 1);\n\t\targs->index = args->index2 = blk1->index;\n\t\targs->blkno = args->blkno2 = blk1->blkno;\n\t}\n}\n\n \nSTATIC int\nxfs_attr3_leaf_figure_balance(\n\tstruct xfs_da_state\t\t*state,\n\tstruct xfs_da_state_blk\t\t*blk1,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr1,\n\tstruct xfs_da_state_blk\t\t*blk2,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr2,\n\tint\t\t\t\t*countarg,\n\tint\t\t\t\t*usedbytesarg)\n{\n\tstruct xfs_attr_leafblock\t*leaf1 = blk1->bp->b_addr;\n\tstruct xfs_attr_leafblock\t*leaf2 = blk2->bp->b_addr;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tcount;\n\tint\t\t\t\tmax;\n\tint\t\t\t\tindex;\n\tint\t\t\t\ttotallen = 0;\n\tint\t\t\t\thalf;\n\tint\t\t\t\tlastdelta;\n\tint\t\t\t\tfoundit = 0;\n\tint\t\t\t\ttmp;\n\n\t \n\tmax = ichdr1->count + ichdr2->count;\n\thalf = (max + 1) * sizeof(*entry);\n\thalf += ichdr1->usedbytes + ichdr2->usedbytes +\n\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\thalf /= 2;\n\tlastdelta = state->args->geo->blksize;\n\tentry = xfs_attr3_leaf_entryp(leaf1);\n\tfor (count = index = 0; count < max; entry++, index++, count++) {\n\n#define XFS_ATTR_ABS(A)\t(((A) < 0) ? -(A) : (A))\n\t\t \n\t\tif (count == blk1->index) {\n\t\t\ttmp = totallen + sizeof(*entry) +\n\t\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\t\t\tif (XFS_ATTR_ABS(half - tmp) > lastdelta)\n\t\t\t\tbreak;\n\t\t\tlastdelta = XFS_ATTR_ABS(half - tmp);\n\t\t\ttotallen = tmp;\n\t\t\tfoundit = 1;\n\t\t}\n\n\t\t \n\t\tif (count == ichdr1->count) {\n\t\t\tleaf1 = leaf2;\n\t\t\tentry = xfs_attr3_leaf_entryp(leaf1);\n\t\t\tindex = 0;\n\t\t}\n\n\t\t \n\t\ttmp = totallen + sizeof(*entry) + xfs_attr_leaf_entsize(leaf1,\n\t\t\t\t\t\t\t\t\tindex);\n\t\tif (XFS_ATTR_ABS(half - tmp) > lastdelta)\n\t\t\tbreak;\n\t\tlastdelta = XFS_ATTR_ABS(half - tmp);\n\t\ttotallen = tmp;\n#undef XFS_ATTR_ABS\n\t}\n\n\t \n\ttotallen -= count * sizeof(*entry);\n\tif (foundit) {\n\t\ttotallen -= sizeof(*entry) +\n\t\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\t}\n\n\t*countarg = count;\n\t*usedbytesarg = totallen;\n\treturn foundit;\n}\n\n \n\n \nint\nxfs_attr3_leaf_toosmall(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*action)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\tbytes;\n\tint\t\t\tforward;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_toosmall(state->args);\n\n\t \n\tblk = &state->path.blk[ state->path.active-1 ];\n\tleaf = blk->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(state->args->geo, &ichdr, leaf);\n\tbytes = xfs_attr3_leaf_hdr_size(leaf) +\n\t\tichdr.count * sizeof(xfs_attr_leaf_entry_t) +\n\t\tichdr.usedbytes;\n\tif (bytes > (state->args->geo->blksize >> 1)) {\n\t\t*action = 0;\t \n\t\treturn 0;\n\t}\n\n\t \n\tif (ichdr.count == 0) {\n\t\t \n\t\tforward = (ichdr.forw != 0);\n\t\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (retval) {\n\t\t\t*action = 0;\n\t\t} else {\n\t\t\t*action = 2;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\t \n\tforward = ichdr.forw < ichdr.back;\n\tfor (i = 0; i < 2; forward = !forward, i++) {\n\t\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\t\tif (forward)\n\t\t\tblkno = ichdr.forw;\n\t\telse\n\t\t\tblkno = ichdr.back;\n\t\tif (blkno == 0)\n\t\t\tcontinue;\n\t\terror = xfs_attr3_leaf_read(state->args->trans, state->args->dp,\n\t\t\t\t\tblkno, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\txfs_attr3_leaf_hdr_from_disk(state->args->geo, &ichdr2, bp->b_addr);\n\n\t\tbytes = state->args->geo->blksize -\n\t\t\t(state->args->geo->blksize >> 2) -\n\t\t\tichdr.usedbytes - ichdr2.usedbytes -\n\t\t\t((ichdr.count + ichdr2.count) *\n\t\t\t\t\tsizeof(xfs_attr_leaf_entry_t)) -\n\t\t\txfs_attr3_leaf_hdr_size(leaf);\n\n\t\txfs_trans_brelse(state->args->trans, bp);\n\t\tif (bytes >= 0)\n\t\t\tbreak;\t \n\t}\n\tif (i >= 2) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\tif (blkno < blk->blkno) {\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t} else {\n\t\terror = xfs_da3_path_shift(state, &state->path, forward,\n\t\t\t\t\t\t 0, &retval);\n\t}\n\tif (error)\n\t\treturn error;\n\tif (retval) {\n\t\t*action = 0;\n\t} else {\n\t\t*action = 1;\n\t}\n\treturn 0;\n}\n\n \nint\nxfs_attr3_leaf_remove(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tint\t\t\tbefore;\n\tint\t\t\tafter;\n\tint\t\t\tsmallest;\n\tint\t\t\tentsize;\n\tint\t\t\ttablesize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_remove(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\n\tASSERT(ichdr.count > 0 && ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index >= 0 && args->index < ichdr.count);\n\tASSERT(ichdr.firstused >= ichdr.count * sizeof(*entry) +\n\t\t\t\t\txfs_attr3_leaf_hdr_size(leaf));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t \n\ttablesize = ichdr.count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\ttmp = ichdr.freemap[0].size;\n\tbefore = after = -1;\n\tsmallest = XFS_ATTR_LEAF_MAPSIZE - 1;\n\tentsize = xfs_attr_leaf_entsize(leaf, args->index);\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tASSERT(ichdr.freemap[i].base < args->geo->blksize);\n\t\tASSERT(ichdr.freemap[i].size < args->geo->blksize);\n\t\tif (ichdr.freemap[i].base == tablesize) {\n\t\t\tichdr.freemap[i].base -= sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr.freemap[i].size += sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\n\t\tif (ichdr.freemap[i].base + ichdr.freemap[i].size ==\n\t\t\t\tbe16_to_cpu(entry->nameidx)) {\n\t\t\tbefore = i;\n\t\t} else if (ichdr.freemap[i].base ==\n\t\t\t\t(be16_to_cpu(entry->nameidx) + entsize)) {\n\t\t\tafter = i;\n\t\t} else if (ichdr.freemap[i].size < tmp) {\n\t\t\ttmp = ichdr.freemap[i].size;\n\t\t\tsmallest = i;\n\t\t}\n\t}\n\n\t \n\tif ((before >= 0) || (after >= 0)) {\n\t\tif ((before >= 0) && (after >= 0)) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t\tichdr.freemap[before].size += ichdr.freemap[after].size;\n\t\t\tichdr.freemap[after].base = 0;\n\t\t\tichdr.freemap[after].size = 0;\n\t\t} else if (before >= 0) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t} else {\n\t\t\tichdr.freemap[after].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[after].size += entsize;\n\t\t}\n\t} else {\n\t\t \n\t\tif (ichdr.freemap[smallest].size < entsize) {\n\t\t\tichdr.freemap[smallest].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[smallest].size = entsize;\n\t\t}\n\t}\n\n\t \n\tif (be16_to_cpu(entry->nameidx) == ichdr.firstused)\n\t\tsmallest = 1;\n\telse\n\t\tsmallest = 0;\n\n\t \n\tmemset(xfs_attr3_leaf_name(leaf, args->index), 0, entsize);\n\tichdr.usedbytes -= entsize;\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   entsize));\n\n\ttmp = (ichdr.count - args->index) * sizeof(xfs_attr_leaf_entry_t);\n\tmemmove(entry, entry + 1, tmp);\n\tichdr.count--;\n\txfs_trans_log_buf(args->trans, bp,\n\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(xfs_attr_leaf_entry_t)));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[ichdr.count];\n\tmemset(entry, 0, sizeof(xfs_attr_leaf_entry_t));\n\n\t \n\tif (smallest) {\n\t\ttmp = args->geo->blksize;\n\t\tentry = xfs_attr3_leaf_entryp(leaf);\n\t\tfor (i = ichdr.count - 1; i >= 0; entry++, i--) {\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t\t\tif (be16_to_cpu(entry->nameidx) < tmp)\n\t\t\t\ttmp = be16_to_cpu(entry->nameidx);\n\t\t}\n\t\tichdr.firstused = tmp;\n\t\tASSERT(ichdr.firstused != 0);\n\t} else {\n\t\tichdr.holes = 1;\t \n\t}\n\txfs_attr3_leaf_hdr_to_disk(args->geo, leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\t\t  xfs_attr3_leaf_hdr_size(leaf)));\n\n\t \n\ttmp = ichdr.usedbytes + xfs_attr3_leaf_hdr_size(leaf) +\n\t      ichdr.count * sizeof(xfs_attr_leaf_entry_t);\n\n\treturn tmp < args->geo->magicpct;  \n}\n\n \nvoid\nxfs_attr3_leaf_unbalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk,\n\tstruct xfs_da_state_blk\t*save_blk)\n{\n\tstruct xfs_attr_leafblock *drop_leaf = drop_blk->bp->b_addr;\n\tstruct xfs_attr_leafblock *save_leaf = save_blk->bp->b_addr;\n\tstruct xfs_attr3_icleaf_hdr drophdr;\n\tstruct xfs_attr3_icleaf_hdr savehdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\n\ttrace_xfs_attr_leaf_unbalance(state->args);\n\n\txfs_attr3_leaf_hdr_from_disk(state->args->geo, &drophdr, drop_leaf);\n\txfs_attr3_leaf_hdr_from_disk(state->args->geo, &savehdr, save_leaf);\n\tentry = xfs_attr3_leaf_entryp(drop_leaf);\n\n\t \n\tdrop_blk->hashval = be32_to_cpu(entry[drophdr.count - 1].hashval);\n\n\t \n\tif (savehdr.holes == 0) {\n\t\t \n\t\tif (xfs_attr3_leaf_order(save_blk->bp, &savehdr,\n\t\t\t\t\t drop_blk->bp, &drophdr)) {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\tdrophdr.count);\n\t\t} else {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\tsave_leaf, &savehdr,\n\t\t\t\t\t\tsavehdr.count, drophdr.count);\n\t\t}\n\t} else {\n\t\t \n\t\tstruct xfs_attr_leafblock *tmp_leaf;\n\t\tstruct xfs_attr3_icleaf_hdr tmphdr;\n\n\t\ttmp_leaf = kmem_zalloc(state->args->geo->blksize, 0);\n\n\t\t \n\t\tmemcpy(tmp_leaf, save_leaf, xfs_attr3_leaf_hdr_size(save_leaf));\n\n\t\tmemset(&tmphdr, 0, sizeof(tmphdr));\n\t\ttmphdr.magic = savehdr.magic;\n\t\ttmphdr.forw = savehdr.forw;\n\t\ttmphdr.back = savehdr.back;\n\t\ttmphdr.firstused = state->args->geo->blksize;\n\n\t\t \n\t\txfs_attr3_leaf_hdr_to_disk(state->args->geo, tmp_leaf, &tmphdr);\n\n\t\tif (xfs_attr3_leaf_order(save_blk->bp, &savehdr,\n\t\t\t\t\t drop_blk->bp, &drophdr)) {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, 0,\n\t\t\t\t\t\tdrophdr.count);\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, tmphdr.count,\n\t\t\t\t\t\tsavehdr.count);\n\t\t} else {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, 0,\n\t\t\t\t\t\tsavehdr.count);\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, tmphdr.count,\n\t\t\t\t\t\tdrophdr.count);\n\t\t}\n\t\tmemcpy(save_leaf, tmp_leaf, state->args->geo->blksize);\n\t\tsavehdr = tmphdr;  \n\t\tkmem_free(tmp_leaf);\n\t}\n\n\txfs_attr3_leaf_hdr_to_disk(state->args->geo, save_leaf, &savehdr);\n\txfs_trans_log_buf(state->args->trans, save_blk->bp, 0,\n\t\t\t\t\t   state->args->geo->blksize - 1);\n\n\t \n\tentry = xfs_attr3_leaf_entryp(save_leaf);\n\tsave_blk->hashval = be32_to_cpu(entry[savehdr.count - 1].hashval);\n}\n\n \n\n \nint\nxfs_attr3_leaf_lookup_int(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\txfs_dahash_t\t\thashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\n\ttrace_xfs_attr_leaf_lookup(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tif (ichdr.count >= args->geo->blksize / 8) {\n\t\txfs_buf_mark_corrupt(bp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\thashval = args->hashval;\n\tprobe = span = ichdr.count / 2;\n\tfor (entry = &entries[probe]; span > 4; entry = &entries[probe]) {\n\t\tspan /= 2;\n\t\tif (be32_to_cpu(entry->hashval) < hashval)\n\t\t\tprobe += span;\n\t\telse if (be32_to_cpu(entry->hashval) > hashval)\n\t\t\tprobe -= span;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!(probe >= 0 && (!ichdr.count || probe < ichdr.count))) {\n\t\txfs_buf_mark_corrupt(bp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (!(span <= 4 || be32_to_cpu(entry->hashval) == hashval)) {\n\t\txfs_buf_mark_corrupt(bp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\twhile (probe > 0 && be32_to_cpu(entry->hashval) >= hashval) {\n\t\tentry--;\n\t\tprobe--;\n\t}\n\twhile (probe < ichdr.count &&\n\t       be32_to_cpu(entry->hashval) < hashval) {\n\t\tentry++;\n\t\tprobe++;\n\t}\n\tif (probe == ichdr.count || be32_to_cpu(entry->hashval) != hashval) {\n\t\targs->index = probe;\n\t\treturn -ENOATTR;\n\t}\n\n\t \n\tfor (; probe < ichdr.count && (be32_to_cpu(entry->hashval) == hashval);\n\t\t\tentry++, probe++) {\n \n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\tname_loc = xfs_attr3_leaf_name_local(leaf, probe);\n\t\t\tif (!xfs_attr_match(args, name_loc->namelen,\n\t\t\t\t\tname_loc->nameval, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\treturn -EEXIST;\n\t\t} else {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, probe);\n\t\t\tif (!xfs_attr_match(args, name_rmt->namelen,\n\t\t\t\t\tname_rmt->name, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs->dp->i_mount,\n\t\t\t\t\t\t\targs->rmtvaluelen);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\targs->index = probe;\n\treturn -ENOATTR;\n}\n\n \nint\nxfs_attr3_leaf_getvalue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index < ichdr.count);\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tASSERT(name_loc->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0);\n\t\treturn xfs_attr_copy_value(args,\n\t\t\t\t\t&name_loc->nameval[args->namelen],\n\t\t\t\t\tbe16_to_cpu(name_loc->valuelen));\n\t}\n\n\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\tASSERT(name_rmt->namelen == args->namelen);\n\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t       args->rmtvaluelen);\n\treturn xfs_attr_copy_value(args, NULL, args->rmtvaluelen);\n}\n\n \n\n \n \nSTATIC void\nxfs_attr3_leaf_moveents(\n\tstruct xfs_da_args\t\t*args,\n\tstruct xfs_attr_leafblock\t*leaf_s,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_s,\n\tint\t\t\t\tstart_s,\n\tstruct xfs_attr_leafblock\t*leaf_d,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_d,\n\tint\t\t\t\tstart_d,\n\tint\t\t\t\tcount)\n{\n\tstruct xfs_attr_leaf_entry\t*entry_s;\n\tstruct xfs_attr_leaf_entry\t*entry_d;\n\tint\t\t\t\tdesti;\n\tint\t\t\t\ttmp;\n\tint\t\t\t\ti;\n\n\t \n\tif (count == 0)\n\t\treturn;\n\n\t \n\tASSERT(ichdr_s->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       ichdr_s->magic == XFS_ATTR3_LEAF_MAGIC);\n\tASSERT(ichdr_s->magic == ichdr_d->magic);\n\tASSERT(ichdr_s->count > 0 && ichdr_s->count < args->geo->blksize / 8);\n\tASSERT(ichdr_s->firstused >= (ichdr_s->count * sizeof(*entry_s))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_s));\n\tASSERT(ichdr_d->count < args->geo->blksize / 8);\n\tASSERT(ichdr_d->firstused >= (ichdr_d->count * sizeof(*entry_d))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d));\n\n\tASSERT(start_s < ichdr_s->count);\n\tASSERT(start_d <= ichdr_d->count);\n\tASSERT(count <= ichdr_s->count);\n\n\n\t \n\tif (start_d < ichdr_d->count) {\n\t\ttmp  = ichdr_d->count - start_d;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d + count];\n\t\tmemmove(entry_d, entry_s, tmp);\n\t}\n\n\t \n\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\tdesti = start_d;\n\tfor (i = 0; i < count; entry_s++, entry_d++, desti++, i++) {\n\t\tASSERT(be16_to_cpu(entry_s->nameidx) >= ichdr_s->firstused);\n\t\ttmp = xfs_attr_leaf_entsize(leaf_s, start_s + i);\n#ifdef GROT\n\t\t \n\t\tif (entry_s->flags & XFS_ATTR_INCOMPLETE) {  \n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tentry_d--;\t \n\t\t\tdesti--;\n\t\t\tif ((start_s + i) < offset)\n\t\t\t\tresult++;\t \n\t\t} else {\n#endif  \n\t\t\tichdr_d->firstused -= tmp;\n\t\t\t \n\t\t\tentry_d->hashval = entry_s->hashval;\n\t\t\tentry_d->nameidx = cpu_to_be16(ichdr_d->firstused);\n\t\t\tentry_d->flags = entry_s->flags;\n\t\t\tASSERT(be16_to_cpu(entry_d->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemmove(xfs_attr3_leaf_name(leaf_d, desti),\n\t\t\t\txfs_attr3_leaf_name(leaf_s, start_s + i), tmp);\n\t\t\tASSERT(be16_to_cpu(entry_s->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_d->usedbytes += tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tichdr_d->count += 1;\n\t\t\ttmp = ichdr_d->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d);\n\t\t\tASSERT(ichdr_d->firstused >= tmp);\n#ifdef GROT\n\t\t}\n#endif  \n\t}\n\n\t \n\tif (start_s == ichdr_s->count) {\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t} else {\n\t\t \n\t\ttmp  = (ichdr_s->count - count) * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s + count];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tmemmove(entry_d, entry_s, tmp);\n\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[ichdr_s->count];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t}\n\n\t \n\tichdr_d->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_d);\n\tichdr_d->freemap[0].base += ichdr_d->count * sizeof(xfs_attr_leaf_entry_t);\n\tichdr_d->freemap[0].size = ichdr_d->firstused - ichdr_d->freemap[0].base;\n\tichdr_d->freemap[1].base = 0;\n\tichdr_d->freemap[2].base = 0;\n\tichdr_d->freemap[1].size = 0;\n\tichdr_d->freemap[2].size = 0;\n\tichdr_s->holes = 1;\t \n}\n\n \nxfs_dahash_t\nxfs_attr_leaf_lasthash(\n\tstruct xfs_buf\t*bp,\n\tint\t\t*count)\n{\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_mount *mp = bp->b_mount;\n\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, bp->b_addr);\n\tentries = xfs_attr3_leaf_entryp(bp->b_addr);\n\tif (count)\n\t\t*count = ichdr.count;\n\tif (!ichdr.count)\n\t\treturn 0;\n\treturn be32_to_cpu(entries[ichdr.count - 1].hashval);\n}\n\n \nSTATIC int\nxfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index)\n{\n\tstruct xfs_attr_leaf_entry *entries;\n\txfs_attr_leaf_name_local_t *name_loc;\n\txfs_attr_leaf_name_remote_t *name_rmt;\n\tint size;\n\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tif (entries[index].flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_local(name_loc->namelen,\n\t\t\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_remote(name_rmt->namelen);\n\t}\n\treturn size;\n}\n\n \nint\nxfs_attr_leaf_newentsize(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*local)\n{\n\tint\t\t\tsize;\n\n\tsize = xfs_attr_leaf_entsize_local(args->namelen, args->valuelen);\n\tif (size < xfs_attr_leaf_entsize_local_max(args->geo->blksize)) {\n\t\tif (local)\n\t\t\t*local = 1;\n\t\treturn size;\n\t}\n\tif (local)\n\t\t*local = 0;\n\treturn xfs_attr_leaf_entsize_remote(args->namelen);\n}\n\n\n \n\n \nint\nxfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif  \n\n\ttrace_xfs_attr_leaf_clearflag(args);\n\t \n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif  \n\n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\treturn 0;\n}\n\n \nint\nxfs_attr3_leaf_setflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n#endif\n\n\ttrace_xfs_attr_leaf_setflag(args);\n\n\t \n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n#endif\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT((entry->flags & XFS_ATTR_INCOMPLETE) == 0);\n\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\tXFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif ((entry->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\treturn 0;\n}\n\n \nint\nxfs_attr3_leaf_flipflags(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr_leaf_entry *entry1;\n\tstruct xfs_attr_leaf_entry *entry2;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp1;\n\tstruct xfs_buf\t\t*bp2;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen1, namelen2;\n\tchar *name1, *name2;\n#endif  \n\n\ttrace_xfs_attr_leaf_flipflags(args);\n\n\t \n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, &bp1);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (args->blkno2 != args->blkno) {\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno2,\n\t\t\t\t\t   &bp2);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tbp2 = bp1;\n\t}\n\n\tleaf1 = bp1->b_addr;\n\tentry1 = &xfs_attr3_leaf_entryp(leaf1)[args->index];\n\n\tleaf2 = bp2->b_addr;\n\tentry2 = &xfs_attr3_leaf_entryp(leaf2)[args->index2];\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr1, leaf1);\n\tASSERT(args->index < ichdr1.count);\n\tASSERT(args->index >= 0);\n\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr2, leaf2);\n\tASSERT(args->index2 < ichdr2.count);\n\tASSERT(args->index2 >= 0);\n\n\tif (entry1->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf1, args->index);\n\t\tnamelen1 = name_loc->namelen;\n\t\tname1 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tnamelen1 = name_rmt->namelen;\n\t\tname1 = (char *)name_rmt->name;\n\t}\n\tif (entry2->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf2, args->index2);\n\t\tnamelen2 = name_loc->namelen;\n\t\tname2 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tnamelen2 = name_rmt->namelen;\n\t\tname2 = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry1->hashval) == be32_to_cpu(entry2->hashval));\n\tASSERT(namelen1 == namelen2);\n\tASSERT(memcmp(name1, name2, namelen1) == 0);\n#endif  \n\n\tASSERT(entry1->flags & XFS_ATTR_INCOMPLETE);\n\tASSERT((entry2->flags & XFS_ATTR_INCOMPLETE) == 0);\n\n\tentry1->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t  XFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry1->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\tentry2->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t  XFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2)));\n\tif ((entry2->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t XFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}