{
  "module_name": "xfs_dir2.c",
  "hash_id": "672563d013b23a2544042ef05c4ff9ff49d85a41c53079512e9e8c6b6146a08d",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_dir2.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_errortag.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n\nconst struct xfs_name xfs_name_dotdot = {\n\t.name\t= (const unsigned char *)\"..\",\n\t.len\t= 2,\n\t.type\t= XFS_DIR3_FT_DIR,\n};\n\n \nunsigned char\nxfs_mode_to_ftype(\n\tint\t\tmode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\t\treturn XFS_DIR3_FT_REG_FILE;\n\tcase S_IFDIR:\n\t\treturn XFS_DIR3_FT_DIR;\n\tcase S_IFCHR:\n\t\treturn XFS_DIR3_FT_CHRDEV;\n\tcase S_IFBLK:\n\t\treturn XFS_DIR3_FT_BLKDEV;\n\tcase S_IFIFO:\n\t\treturn XFS_DIR3_FT_FIFO;\n\tcase S_IFSOCK:\n\t\treturn XFS_DIR3_FT_SOCK;\n\tcase S_IFLNK:\n\t\treturn XFS_DIR3_FT_SYMLINK;\n\tdefault:\n\t\treturn XFS_DIR3_FT_UNKNOWN;\n\t}\n}\n\n \nxfs_dahash_t\nxfs_ascii_ci_hashname(\n\tconst struct xfs_name\t*name)\n{\n\txfs_dahash_t\t\thash;\n\tint\t\t\ti;\n\n\tfor (i = 0, hash = 0; i < name->len; i++)\n\t\thash = xfs_ascii_ci_xfrm(name->name[i]) ^ rol32(hash, 7);\n\n\treturn hash;\n}\n\nenum xfs_dacmp\nxfs_ascii_ci_compname(\n\tstruct xfs_da_args\t*args,\n\tconst unsigned char\t*name,\n\tint\t\t\tlen)\n{\n\tenum xfs_dacmp\t\tresult;\n\tint\t\t\ti;\n\n\tif (args->namelen != len)\n\t\treturn XFS_CMP_DIFFERENT;\n\n\tresult = XFS_CMP_EXACT;\n\tfor (i = 0; i < len; i++) {\n\t\tif (args->name[i] == name[i])\n\t\t\tcontinue;\n\t\tif (xfs_ascii_ci_xfrm(args->name[i]) !=\n\t\t    xfs_ascii_ci_xfrm(name[i]))\n\t\t\treturn XFS_CMP_DIFFERENT;\n\t\tresult = XFS_CMP_CASE;\n\t}\n\n\treturn result;\n}\n\nint\nxfs_da_mount(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_da_geometry\t*dageo;\n\n\n\tASSERT(mp->m_sb.sb_versionnum & XFS_SB_VERSION_DIRV2BIT);\n\tASSERT(xfs_dir2_dirblock_bytes(&mp->m_sb) <= XFS_MAX_BLOCKSIZE);\n\n\tmp->m_dir_geo = kmem_zalloc(sizeof(struct xfs_da_geometry),\n\t\t\t\t    KM_MAYFAIL);\n\tmp->m_attr_geo = kmem_zalloc(sizeof(struct xfs_da_geometry),\n\t\t\t\t     KM_MAYFAIL);\n\tif (!mp->m_dir_geo || !mp->m_attr_geo) {\n\t\tkmem_free(mp->m_dir_geo);\n\t\tkmem_free(mp->m_attr_geo);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tdageo = mp->m_dir_geo;\n\tdageo->blklog = mp->m_sb.sb_blocklog + mp->m_sb.sb_dirblklog;\n\tdageo->fsblog = mp->m_sb.sb_blocklog;\n\tdageo->blksize = xfs_dir2_dirblock_bytes(&mp->m_sb);\n\tdageo->fsbcount = 1 << mp->m_sb.sb_dirblklog;\n\tif (xfs_has_crc(mp)) {\n\t\tdageo->node_hdr_size = sizeof(struct xfs_da3_node_hdr);\n\t\tdageo->leaf_hdr_size = sizeof(struct xfs_dir3_leaf_hdr);\n\t\tdageo->free_hdr_size = sizeof(struct xfs_dir3_free_hdr);\n\t\tdageo->data_entry_offset =\n\t\t\t\tsizeof(struct xfs_dir3_data_hdr);\n\t} else {\n\t\tdageo->node_hdr_size = sizeof(struct xfs_da_node_hdr);\n\t\tdageo->leaf_hdr_size = sizeof(struct xfs_dir2_leaf_hdr);\n\t\tdageo->free_hdr_size = sizeof(struct xfs_dir2_free_hdr);\n\t\tdageo->data_entry_offset =\n\t\t\t\tsizeof(struct xfs_dir2_data_hdr);\n\t}\n\tdageo->leaf_max_ents = (dageo->blksize - dageo->leaf_hdr_size) /\n\t\t\tsizeof(struct xfs_dir2_leaf_entry);\n\tdageo->free_max_bests = (dageo->blksize - dageo->free_hdr_size) /\n\t\t\tsizeof(xfs_dir2_data_off_t);\n\n\tdageo->data_first_offset = dageo->data_entry_offset +\n\t\t\txfs_dir2_data_entsize(mp, 1) +\n\t\t\txfs_dir2_data_entsize(mp, 2);\n\n\t \n\tdageo->datablk = xfs_dir2_byte_to_da(dageo, XFS_DIR2_DATA_OFFSET);\n\tdageo->leafblk = xfs_dir2_byte_to_da(dageo, XFS_DIR2_LEAF_OFFSET);\n\tdageo->freeblk = xfs_dir2_byte_to_da(dageo, XFS_DIR2_FREE_OFFSET);\n\tdageo->node_ents = (dageo->blksize - dageo->node_hdr_size) /\n\t\t\t\t(uint)sizeof(xfs_da_node_entry_t);\n\tdageo->max_extents = (XFS_DIR2_MAX_SPACES * XFS_DIR2_SPACE_SIZE) >>\n\t\t\t\t\tmp->m_sb.sb_blocklog;\n\tdageo->magicpct = (dageo->blksize * 37) / 100;\n\n\t \n\tdageo = mp->m_attr_geo;\n\tdageo->blklog = mp->m_sb.sb_blocklog;\n\tdageo->fsblog = mp->m_sb.sb_blocklog;\n\tdageo->blksize = 1 << dageo->blklog;\n\tdageo->fsbcount = 1;\n\tdageo->node_hdr_size = mp->m_dir_geo->node_hdr_size;\n\tdageo->node_ents = (dageo->blksize - dageo->node_hdr_size) /\n\t\t\t\t(uint)sizeof(xfs_da_node_entry_t);\n\n\tif (xfs_has_large_extent_counts(mp))\n\t\tdageo->max_extents = XFS_MAX_EXTCNT_ATTR_FORK_LARGE;\n\telse\n\t\tdageo->max_extents = XFS_MAX_EXTCNT_ATTR_FORK_SMALL;\n\n\tdageo->magicpct = (dageo->blksize * 37) / 100;\n\treturn 0;\n}\n\nvoid\nxfs_da_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\tkmem_free(mp->m_dir_geo);\n\tkmem_free(mp->m_attr_geo);\n}\n\n \nint\nxfs_dir_isempty(\n\txfs_inode_t\t*dp)\n{\n\txfs_dir2_sf_hdr_t\t*sfp;\n\n\tASSERT(S_ISDIR(VFS_I(dp)->i_mode));\n\tif (dp->i_disk_size == 0)\t \n\t\treturn 1;\n\tif (dp->i_disk_size > xfs_inode_data_fork_size(dp))\n\t\treturn 0;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\treturn !sfp->count;\n}\n\n \nint\nxfs_dir_ino_validate(\n\txfs_mount_t\t*mp,\n\txfs_ino_t\tino)\n{\n\tbool\t\tino_ok = xfs_verify_dir_ino(mp, ino);\n\n\tif (XFS_IS_CORRUPT(mp, !ino_ok) ||\n\t    XFS_TEST_ERROR(false, mp, XFS_ERRTAG_DIR_INO_VALIDATE)) {\n\t\txfs_warn(mp, \"Invalid inode number 0x%Lx\",\n\t\t\t\t(unsigned long long) ino);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}\n\n \nint\nxfs_dir_init(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\txfs_inode_t\t*pdp)\n{\n\tstruct xfs_da_args *args;\n\tint\t\terror;\n\n\tASSERT(S_ISDIR(VFS_I(dp)->i_mode));\n\terror = xfs_dir_ino_validate(tp->t_mountp, pdp->i_ino);\n\tif (error)\n\t\treturn error;\n\n\targs = kmem_zalloc(sizeof(*args), KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->dp = dp;\n\targs->trans = tp;\n\terror = xfs_dir2_sf_create(args, pdp->i_ino);\n\tkmem_free(args);\n\treturn error;\n}\n\n \nint\nxfs_dir_createname(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\tconst struct xfs_name\t*name,\n\txfs_ino_t\t\tinum,\t\t \n\txfs_extlen_t\t\ttotal)\t\t \n{\n\tstruct xfs_da_args\t*args;\n\tint\t\t\trval;\n\tbool\t\t\tv;\n\n\tASSERT(S_ISDIR(VFS_I(dp)->i_mode));\n\n\tif (inum) {\n\t\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\t\tif (rval)\n\t\t\treturn rval;\n\t\tXFS_STATS_INC(dp->i_mount, xs_dir_create);\n\t}\n\n\targs = kmem_zalloc(sizeof(*args), KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = xfs_dir2_hashname(dp->i_mount, name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\tif (!inum)\n\t\targs->op_flags |= XFS_DA_OP_JUSTCHECK;\n\n\tif (dp->i_df.if_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_addname(args);\n\telse\n\t\trval = xfs_dir2_node_addname(args);\n\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}\n\n \nint\nxfs_dir_cilookup_result(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\tif (args->cmpresult == XFS_CMP_DIFFERENT)\n\t\treturn -ENOENT;\n\tif (args->cmpresult != XFS_CMP_CASE ||\n\t\t\t\t\t!(args->op_flags & XFS_DA_OP_CILOOKUP))\n\t\treturn -EEXIST;\n\n\targs->value = kmem_alloc(len, KM_NOFS | KM_MAYFAIL);\n\tif (!args->value)\n\t\treturn -ENOMEM;\n\n\tmemcpy(args->value, name, len);\n\targs->valuelen = len;\n\treturn -EEXIST;\n}\n\n \n\nint\nxfs_dir_lookup(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\tconst struct xfs_name\t*name,\n\txfs_ino_t\t\t*inum,\t   \n\tstruct xfs_name\t\t*ci_name)  \n{\n\tstruct xfs_da_args\t*args;\n\tint\t\t\trval;\n\tbool\t\t\tv;\n\tint\t\t\tlock_mode;\n\n\tASSERT(S_ISDIR(VFS_I(dp)->i_mode));\n\tXFS_STATS_INC(dp->i_mount, xs_dir_lookup);\n\n\t \n\targs = kmem_zalloc(sizeof(*args), KM_NOFS);\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = xfs_dir2_hashname(dp->i_mount, name);\n\targs->dp = dp;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_OKNOENT;\n\tif (ci_name)\n\t\targs->op_flags |= XFS_DA_OP_CILOOKUP;\n\n\tlock_mode = xfs_ilock_data_map_shared(dp);\n\tif (dp->i_df.if_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_lookup(args);\n\t\tgoto out_check_rval;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_lookup(args);\n\t\tgoto out_check_rval;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_lookup(args);\n\telse\n\t\trval = xfs_dir2_node_lookup(args);\n\nout_check_rval:\n\tif (rval == -EEXIST)\n\t\trval = 0;\n\tif (!rval) {\n\t\t*inum = args->inumber;\n\t\tif (ci_name) {\n\t\t\tci_name->name = args->value;\n\t\t\tci_name->len = args->valuelen;\n\t\t}\n\t}\nout_free:\n\txfs_iunlock(dp, lock_mode);\n\tkmem_free(args);\n\treturn rval;\n}\n\n \nint\nxfs_dir_removename(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_ino_t\t\tino,\n\txfs_extlen_t\t\ttotal)\t\t \n{\n\tstruct xfs_da_args\t*args;\n\tint\t\t\trval;\n\tbool\t\t\tv;\n\n\tASSERT(S_ISDIR(VFS_I(dp)->i_mode));\n\tXFS_STATS_INC(dp->i_mount, xs_dir_remove);\n\n\targs = kmem_zalloc(sizeof(*args), KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = xfs_dir2_hashname(dp->i_mount, name);\n\targs->inumber = ino;\n\targs->dp = dp;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\n\tif (dp->i_df.if_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_removename(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_removename(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_removename(args);\n\telse\n\t\trval = xfs_dir2_node_removename(args);\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}\n\n \nint\nxfs_dir_replace(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\tconst struct xfs_name\t*name,\t\t \n\txfs_ino_t\t\tinum,\t\t \n\txfs_extlen_t\t\ttotal)\t\t \n{\n\tstruct xfs_da_args\t*args;\n\tint\t\t\trval;\n\tbool\t\t\tv;\n\n\tASSERT(S_ISDIR(VFS_I(dp)->i_mode));\n\n\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\tif (rval)\n\t\treturn rval;\n\n\targs = kmem_zalloc(sizeof(*args), KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = xfs_dir2_hashname(dp->i_mount, name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\n\tif (dp->i_df.if_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_replace(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_replace(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_replace(args);\n\telse\n\t\trval = xfs_dir2_node_replace(args);\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}\n\n \nint\nxfs_dir_canenter(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name)\t\t \n{\n\treturn xfs_dir_createname(tp, dp, name, 0, 0);\n}\n\n \n\n \nint\nxfs_dir2_grow_inode(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tspace,\t \n\txfs_dir2_db_t\t\t*dbp)\t \n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\txfs_fileoff_t\t\tbno;\t \n\tint\t\t\tcount;\t \n\tint\t\t\terror;\n\n\ttrace_xfs_dir2_grow_inode(args, space);\n\n\t \n\tbno = XFS_B_TO_FSBT(mp, space * XFS_DIR2_SPACE_SIZE);\n\tcount = args->geo->fsbcount;\n\n\terror = xfs_da_grow_inode_int(args, &bno, count);\n\tif (error)\n\t\treturn error;\n\n\t*dbp = xfs_dir2_da_to_db(args->geo, (xfs_dablk_t)bno);\n\n\t \n\tif (space == XFS_DIR2_DATA_SPACE) {\n\t\txfs_fsize_t\tsize;\t\t \n\n\t\tsize = XFS_FSB_TO_B(mp, bno + count);\n\t\tif (size > dp->i_disk_size) {\n\t\t\tdp->i_disk_size = size;\n\t\t\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint\nxfs_dir2_isblock(\n\tstruct xfs_da_args\t*args,\n\tbool\t\t\t*isblock)\n{\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\txfs_fileoff_t\t\teof;\n\tint\t\t\terror;\n\n\terror = xfs_bmap_last_offset(args->dp, &eof, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\t*isblock = false;\n\tif (XFS_FSB_TO_B(mp, eof) != args->geo->blksize)\n\t\treturn 0;\n\n\t*isblock = true;\n\tif (XFS_IS_CORRUPT(mp, args->dp->i_disk_size != args->geo->blksize))\n\t\treturn -EFSCORRUPTED;\n\treturn 0;\n}\n\n \nint\nxfs_dir2_isleaf(\n\tstruct xfs_da_args\t*args,\n\tbool\t\t\t*isleaf)\n{\n\txfs_fileoff_t\t\teof;\n\tint\t\t\terror;\n\n\terror = xfs_bmap_last_offset(args->dp, &eof, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\t*isleaf = false;\n\tif (eof != args->geo->leafblk + args->geo->fsbcount)\n\t\treturn 0;\n\n\t*isleaf = true;\n\treturn 0;\n}\n\n \nint\nxfs_dir2_shrink_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dir2_db_t\t\tdb,\n\tstruct xfs_buf\t\t*bp)\n{\n\txfs_fileoff_t\t\tbno;\t\t \n\txfs_dablk_t\t\tda;\t\t \n\tint\t\t\tdone;\t\t \n\tstruct xfs_inode\t*dp;\n\tint\t\t\terror;\n\tstruct xfs_mount\t*mp;\n\tstruct xfs_trans\t*tp;\n\n\ttrace_xfs_dir2_shrink_inode(args, db);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tda = xfs_dir2_db_to_da(args->geo, db);\n\n\t \n\terror = xfs_bunmapi(tp, dp, da, args->geo->fsbcount, 0, 0, &done);\n\tif (error) {\n\t\t \n\t\treturn error;\n\t}\n\tASSERT(done);\n\t \n\txfs_trans_binval(tp, bp);\n\t \n\tif (db >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET))\n\t\treturn 0;\n\t \n\tif (dp->i_disk_size > xfs_dir2_db_off_to_byte(args->geo, db + 1, 0))\n\t\treturn 0;\n\tbno = da;\n\tif ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {\n\t\t \n\t\treturn error;\n\t}\n\tif (db == args->geo->datablk)\n\t\tASSERT(bno == 0);\n\telse\n\t\tASSERT(bno > 0);\n\t \n\tdp->i_disk_size = XFS_FSB_TO_B(mp, bno);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\treturn 0;\n}\n\n \nbool\nxfs_dir2_namecheck(\n\tconst void\t*name,\n\tsize_t\t\tlength)\n{\n\t \n\tif (length >= MAXNAMELEN)\n\t\treturn false;\n\n\t \n\treturn !memchr(name, '/', length) && !memchr(name, 0, length);\n}\n\nxfs_dahash_t\nxfs_dir2_hashname(\n\tstruct xfs_mount\t*mp,\n\tconst struct xfs_name\t*name)\n{\n\tif (unlikely(xfs_has_asciici(mp)))\n\t\treturn xfs_ascii_ci_hashname(name);\n\treturn xfs_da_hashname(name->name, name->len);\n}\n\nenum xfs_dacmp\nxfs_dir2_compname(\n\tstruct xfs_da_args\t*args,\n\tconst unsigned char\t*name,\n\tint\t\t\tlen)\n{\n\tif (unlikely(xfs_has_asciici(args->dp->i_mount)))\n\t\treturn xfs_ascii_ci_compname(args, name, len);\n\treturn xfs_da_compname(args, name, len);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}