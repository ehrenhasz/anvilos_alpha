{
  "module_name": "xfs_sb.c",
  "hash_id": "27a95cc9ba35b4da1fd6e8b2e4875ffe5cbeb5bc1dd778a9ef2f88fe3d840c71",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_sb.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_rmap_btree.h\"\n#include \"xfs_refcount_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_health.h\"\n#include \"xfs_ag.h\"\n\n \n\n \nstatic bool\nxfs_sb_validate_v5_features(\n\tstruct xfs_sb\t*sbp)\n{\n\t \n\tif (sbp->sb_versionnum & ~XFS_SB_VERSION_OKBITS)\n\t\treturn false;\n\n\t \n\tif (sbp->sb_features2 & ~(XFS_SB_VERSION2_OKBITS |\n\t\t\t\t  XFS_SB_VERSION2_CRCBIT))\n\t\treturn false;\n\n\t \n\n#define V5_VERS_FLAGS\t(XFS_SB_VERSION_NLINKBIT\t| \\\n\t\t\tXFS_SB_VERSION_ALIGNBIT\t\t| \\\n\t\t\tXFS_SB_VERSION_LOGV2BIT\t\t| \\\n\t\t\tXFS_SB_VERSION_EXTFLGBIT\t| \\\n\t\t\tXFS_SB_VERSION_DIRV2BIT\t\t| \\\n\t\t\tXFS_SB_VERSION_MOREBITSBIT)\n\n#define V5_FEAT_FLAGS\t(XFS_SB_VERSION2_LAZYSBCOUNTBIT\t| \\\n\t\t\tXFS_SB_VERSION2_ATTR2BIT\t| \\\n\t\t\tXFS_SB_VERSION2_PROJID32BIT\t| \\\n\t\t\tXFS_SB_VERSION2_CRCBIT)\n\n\tif ((sbp->sb_versionnum & V5_VERS_FLAGS) != V5_VERS_FLAGS)\n\t\treturn false;\n\tif ((sbp->sb_features2 & V5_FEAT_FLAGS) != V5_FEAT_FLAGS)\n\t\treturn false;\n\treturn true;\n}\n\n \nbool\nxfs_sb_good_version(\n\tstruct xfs_sb\t*sbp)\n{\n\t \n\tif (xfs_sb_is_v5(sbp))\n\t\treturn xfs_sb_validate_v5_features(sbp);\n\n\t \n\tif (XFS_SB_VERSION_NUM(sbp) != XFS_SB_VERSION_4)\n\t\treturn false;\n\n\t \n\tif ((sbp->sb_versionnum & ~XFS_SB_VERSION_OKBITS) ||\n\t    ((sbp->sb_versionnum & XFS_SB_VERSION_MOREBITSBIT) &&\n\t     (sbp->sb_features2 & ~XFS_SB_VERSION2_OKBITS)))\n\t\treturn false;\n\n\t \n\tif (!(sbp->sb_versionnum & XFS_SB_VERSION_DIRV2BIT))\n\t\treturn false;\n\tif (!(sbp->sb_versionnum & XFS_SB_VERSION_EXTFLGBIT))\n\t\treturn false;\n\n\t \n\treturn true;\n}\n\nuint64_t\nxfs_sb_version_to_features(\n\tstruct xfs_sb\t*sbp)\n{\n\tuint64_t\tfeatures = 0;\n\n\t \n\tif (sbp->sb_rblocks > 0)\n\t\tfeatures |= XFS_FEAT_REALTIME;\n\tif (sbp->sb_versionnum & XFS_SB_VERSION_NLINKBIT)\n\t\tfeatures |= XFS_FEAT_NLINK;\n\tif (sbp->sb_versionnum & XFS_SB_VERSION_ATTRBIT)\n\t\tfeatures |= XFS_FEAT_ATTR;\n\tif (sbp->sb_versionnum & XFS_SB_VERSION_QUOTABIT)\n\t\tfeatures |= XFS_FEAT_QUOTA;\n\tif (sbp->sb_versionnum & XFS_SB_VERSION_ALIGNBIT)\n\t\tfeatures |= XFS_FEAT_ALIGN;\n\tif (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT)\n\t\tfeatures |= XFS_FEAT_LOGV2;\n\tif (sbp->sb_versionnum & XFS_SB_VERSION_DALIGNBIT)\n\t\tfeatures |= XFS_FEAT_DALIGN;\n\tif (sbp->sb_versionnum & XFS_SB_VERSION_EXTFLGBIT)\n\t\tfeatures |= XFS_FEAT_EXTFLG;\n\tif (sbp->sb_versionnum & XFS_SB_VERSION_SECTORBIT)\n\t\tfeatures |= XFS_FEAT_SECTOR;\n\tif (sbp->sb_versionnum & XFS_SB_VERSION_BORGBIT)\n\t\tfeatures |= XFS_FEAT_ASCIICI;\n\tif (sbp->sb_versionnum & XFS_SB_VERSION_MOREBITSBIT) {\n\t\tif (sbp->sb_features2 & XFS_SB_VERSION2_LAZYSBCOUNTBIT)\n\t\t\tfeatures |= XFS_FEAT_LAZYSBCOUNT;\n\t\tif (sbp->sb_features2 & XFS_SB_VERSION2_ATTR2BIT)\n\t\t\tfeatures |= XFS_FEAT_ATTR2;\n\t\tif (sbp->sb_features2 & XFS_SB_VERSION2_PROJID32BIT)\n\t\t\tfeatures |= XFS_FEAT_PROJID32;\n\t\tif (sbp->sb_features2 & XFS_SB_VERSION2_FTYPE)\n\t\t\tfeatures |= XFS_FEAT_FTYPE;\n\t}\n\n\tif (!xfs_sb_is_v5(sbp))\n\t\treturn features;\n\n\t \n\tfeatures |= XFS_FEAT_ALIGN | XFS_FEAT_LOGV2 | XFS_FEAT_EXTFLG |\n\t\t    XFS_FEAT_LAZYSBCOUNT | XFS_FEAT_ATTR2 | XFS_FEAT_PROJID32 |\n\t\t    XFS_FEAT_V3INODES | XFS_FEAT_CRC | XFS_FEAT_PQUOTINO;\n\n\t \n\tif (sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_FINOBT)\n\t\tfeatures |= XFS_FEAT_FINOBT;\n\tif (sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_RMAPBT)\n\t\tfeatures |= XFS_FEAT_RMAPBT;\n\tif (sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_REFLINK)\n\t\tfeatures |= XFS_FEAT_REFLINK;\n\tif (sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_INOBTCNT)\n\t\tfeatures |= XFS_FEAT_INOBTCNT;\n\tif (sbp->sb_features_incompat & XFS_SB_FEAT_INCOMPAT_FTYPE)\n\t\tfeatures |= XFS_FEAT_FTYPE;\n\tif (sbp->sb_features_incompat & XFS_SB_FEAT_INCOMPAT_SPINODES)\n\t\tfeatures |= XFS_FEAT_SPINODES;\n\tif (sbp->sb_features_incompat & XFS_SB_FEAT_INCOMPAT_META_UUID)\n\t\tfeatures |= XFS_FEAT_META_UUID;\n\tif (sbp->sb_features_incompat & XFS_SB_FEAT_INCOMPAT_BIGTIME)\n\t\tfeatures |= XFS_FEAT_BIGTIME;\n\tif (sbp->sb_features_incompat & XFS_SB_FEAT_INCOMPAT_NEEDSREPAIR)\n\t\tfeatures |= XFS_FEAT_NEEDSREPAIR;\n\tif (sbp->sb_features_incompat & XFS_SB_FEAT_INCOMPAT_NREXT64)\n\t\tfeatures |= XFS_FEAT_NREXT64;\n\n\treturn features;\n}\n\n \nSTATIC int\nxfs_validate_sb_read(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_sb\t\t*sbp)\n{\n\tif (!xfs_sb_is_v5(sbp))\n\t\treturn 0;\n\n\t \n\tif (xfs_sb_has_compat_feature(sbp, XFS_SB_FEAT_COMPAT_UNKNOWN)) {\n\t\txfs_warn(mp,\n\"Superblock has unknown compatible features (0x%x) enabled.\",\n\t\t\t(sbp->sb_features_compat & XFS_SB_FEAT_COMPAT_UNKNOWN));\n\t\txfs_warn(mp,\n\"Using a more recent kernel is recommended.\");\n\t}\n\n\tif (xfs_sb_has_ro_compat_feature(sbp, XFS_SB_FEAT_RO_COMPAT_UNKNOWN)) {\n\t\txfs_alert(mp,\n\"Superblock has unknown read-only compatible features (0x%x) enabled.\",\n\t\t\t(sbp->sb_features_ro_compat &\n\t\t\t\t\tXFS_SB_FEAT_RO_COMPAT_UNKNOWN));\n\t\tif (!xfs_is_readonly(mp)) {\n\t\t\txfs_warn(mp,\n\"Attempted to mount read-only compatible filesystem read-write.\");\n\t\t\txfs_warn(mp,\n\"Filesystem can only be safely mounted read only.\");\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (xfs_sb_has_incompat_feature(sbp, XFS_SB_FEAT_INCOMPAT_UNKNOWN)) {\n\t\txfs_warn(mp,\n\"Superblock has unknown incompatible features (0x%x) enabled.\",\n\t\t\t(sbp->sb_features_incompat &\n\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_UNKNOWN));\n\t\txfs_warn(mp,\n\"Filesystem cannot be safely mounted by this kernel.\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_validate_sb_write(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_sb\t\t*sbp)\n{\n\t \n\tif (xfs_buf_daddr(bp) == XFS_SB_DADDR && !sbp->sb_inprogress &&\n\t    (sbp->sb_fdblocks > sbp->sb_dblocks ||\n\t     !xfs_verify_icount(mp, sbp->sb_icount) ||\n\t     sbp->sb_ifree > sbp->sb_icount)) {\n\t\txfs_warn(mp, \"SB summary counter sanity check failed\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (!xfs_sb_is_v5(sbp))\n\t\treturn 0;\n\n\t \n\tif (xfs_sb_has_compat_feature(sbp, XFS_SB_FEAT_COMPAT_UNKNOWN)) {\n\t\txfs_warn(mp,\n\"Corruption detected in superblock compatible features (0x%x)!\",\n\t\t\t(sbp->sb_features_compat & XFS_SB_FEAT_COMPAT_UNKNOWN));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (!xfs_is_readonly(mp) &&\n\t    xfs_sb_has_ro_compat_feature(sbp, XFS_SB_FEAT_RO_COMPAT_UNKNOWN)) {\n\t\txfs_alert(mp,\n\"Corruption detected in superblock read-only compatible features (0x%x)!\",\n\t\t\t(sbp->sb_features_ro_compat &\n\t\t\t\t\tXFS_SB_FEAT_RO_COMPAT_UNKNOWN));\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (xfs_sb_has_incompat_feature(sbp, XFS_SB_FEAT_INCOMPAT_UNKNOWN)) {\n\t\txfs_warn(mp,\n\"Corruption detected in superblock incompatible features (0x%x)!\",\n\t\t\t(sbp->sb_features_incompat &\n\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_UNKNOWN));\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (xfs_sb_has_incompat_log_feature(sbp,\n\t\t\tXFS_SB_FEAT_INCOMPAT_LOG_UNKNOWN)) {\n\t\txfs_warn(mp,\n\"Corruption detected in superblock incompatible log features (0x%x)!\",\n\t\t\t(sbp->sb_features_log_incompat &\n\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_LOG_UNKNOWN));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\tif (!xfs_log_check_lsn(mp, sbp->sb_lsn))\n\t\treturn -EFSCORRUPTED;\n\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_validate_sb_common(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_sb\t\t*sbp)\n{\n\tstruct xfs_dsb\t\t*dsb = bp->b_addr;\n\tuint32_t\t\tagcount = 0;\n\tuint32_t\t\trem;\n\tbool\t\t\thas_dalign;\n\n\tif (!xfs_verify_magic(bp, dsb->sb_magicnum)) {\n\t\txfs_warn(mp,\n\"Superblock has bad magic number 0x%x. Not an XFS filesystem?\",\n\t\t\tbe32_to_cpu(dsb->sb_magicnum));\n\t\treturn -EWRONGFS;\n\t}\n\n\tif (!xfs_sb_good_version(sbp)) {\n\t\txfs_warn(mp,\n\"Superblock has unknown features enabled or corrupted feature masks.\");\n\t\treturn -EWRONGFS;\n\t}\n\n\t \n\tif (xfs_sb_is_v5(sbp)) {\n\t\tif (sbp->sb_blocksize < XFS_MIN_CRC_BLOCKSIZE) {\n\t\t\txfs_notice(mp,\n\"Block size (%u bytes) too small for Version 5 superblock (minimum %d bytes)\",\n\t\t\t\tsbp->sb_blocksize, XFS_MIN_CRC_BLOCKSIZE);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\t \n\t\tif (sbp->sb_qflags & (XFS_OQUOTA_ENFD | XFS_OQUOTA_CHKD)) {\n\t\t\txfs_notice(mp,\n\t\t\t   \"Version 5 of Super block has XFS_OQUOTA bits.\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\t \n\t\tif (sbp->sb_features_incompat & XFS_SB_FEAT_INCOMPAT_SPINODES) {\n\t\t\tuint32_t\talign;\n\n\t\t\talign = XFS_INODES_PER_CHUNK * sbp->sb_inodesize\n\t\t\t\t\t>> sbp->sb_blocklog;\n\t\t\tif (sbp->sb_inoalignmt != align) {\n\t\t\t\txfs_warn(mp,\n\"Inode block alignment (%u) must match chunk size (%u) for sparse inodes.\",\n\t\t\t\t\t sbp->sb_inoalignmt, align);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t} else if (sbp->sb_qflags & (XFS_PQUOTA_ENFD | XFS_GQUOTA_ENFD |\n\t\t\t\tXFS_PQUOTA_CHKD | XFS_GQUOTA_CHKD)) {\n\t\t\txfs_notice(mp,\n\"Superblock earlier than Version 5 has XFS_{P|G}QUOTA_{ENFD|CHKD} bits.\");\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (unlikely(\n\t    sbp->sb_logstart == 0 && mp->m_logdev_targp == mp->m_ddev_targp)) {\n\t\txfs_warn(mp,\n\t\t\"filesystem is marked as having an external log; \"\n\t\t\"specify logdev on the mount command line.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(\n\t    sbp->sb_logstart != 0 && mp->m_logdev_targp != mp->m_ddev_targp)) {\n\t\txfs_warn(mp,\n\t\t\"filesystem is marked as having an internal log; \"\n\t\t\"do not specify logdev on the mount command line.\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (sbp->sb_agblocks) {\n\t\tagcount = div_u64_rem(sbp->sb_dblocks, sbp->sb_agblocks, &rem);\n\t\tif (rem)\n\t\t\tagcount++;\n\t}\n\n\t \n\tif (unlikely(\n\t    sbp->sb_agcount <= 0\t\t\t\t\t||\n\t    sbp->sb_sectsize < XFS_MIN_SECTORSIZE\t\t\t||\n\t    sbp->sb_sectsize > XFS_MAX_SECTORSIZE\t\t\t||\n\t    sbp->sb_sectlog < XFS_MIN_SECTORSIZE_LOG\t\t\t||\n\t    sbp->sb_sectlog > XFS_MAX_SECTORSIZE_LOG\t\t\t||\n\t    sbp->sb_sectsize != (1 << sbp->sb_sectlog)\t\t\t||\n\t    sbp->sb_blocksize < XFS_MIN_BLOCKSIZE\t\t\t||\n\t    sbp->sb_blocksize > XFS_MAX_BLOCKSIZE\t\t\t||\n\t    sbp->sb_blocklog < XFS_MIN_BLOCKSIZE_LOG\t\t\t||\n\t    sbp->sb_blocklog > XFS_MAX_BLOCKSIZE_LOG\t\t\t||\n\t    sbp->sb_blocksize != (1 << sbp->sb_blocklog)\t\t||\n\t    sbp->sb_dirblklog + sbp->sb_blocklog > XFS_MAX_BLOCKSIZE_LOG ||\n\t    sbp->sb_inodesize < XFS_DINODE_MIN_SIZE\t\t\t||\n\t    sbp->sb_inodesize > XFS_DINODE_MAX_SIZE\t\t\t||\n\t    sbp->sb_inodelog < XFS_DINODE_MIN_LOG\t\t\t||\n\t    sbp->sb_inodelog > XFS_DINODE_MAX_LOG\t\t\t||\n\t    sbp->sb_inodesize != (1 << sbp->sb_inodelog)\t\t||\n\t    sbp->sb_inopblock != howmany(sbp->sb_blocksize,sbp->sb_inodesize) ||\n\t    XFS_FSB_TO_B(mp, sbp->sb_agblocks) < XFS_MIN_AG_BYTES\t||\n\t    XFS_FSB_TO_B(mp, sbp->sb_agblocks) > XFS_MAX_AG_BYTES\t||\n\t    sbp->sb_agblklog != xfs_highbit32(sbp->sb_agblocks - 1) + 1\t||\n\t    agcount == 0 || agcount != sbp->sb_agcount\t\t\t||\n\t    (sbp->sb_blocklog - sbp->sb_inodelog != sbp->sb_inopblog)\t||\n\t    (sbp->sb_rextsize * sbp->sb_blocksize > XFS_MAX_RTEXTSIZE)\t||\n\t    (sbp->sb_rextsize * sbp->sb_blocksize < XFS_MIN_RTEXTSIZE)\t||\n\t    (sbp->sb_imax_pct > 100  )\t||\n\t    sbp->sb_dblocks == 0\t\t\t\t\t||\n\t    sbp->sb_dblocks > XFS_MAX_DBLOCKS(sbp)\t\t\t||\n\t    sbp->sb_dblocks < XFS_MIN_DBLOCKS(sbp)\t\t\t||\n\t    sbp->sb_shared_vn != 0)) {\n\t\txfs_notice(mp, \"SB sanity check failed\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\tif (sbp->sb_logblocks > XFS_MAX_LOG_BLOCKS) {\n\t\txfs_notice(mp,\n\t\t\"Log size 0x%x blocks too large, maximum size is 0x%llx blocks\",\n\t\t\t sbp->sb_logblocks, XFS_MAX_LOG_BLOCKS);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FSB_TO_B(mp, sbp->sb_logblocks) > XFS_MAX_LOG_BYTES) {\n\t\txfs_warn(mp,\n\t\t\"log size 0x%llx bytes too large, maximum size is 0x%llx bytes\",\n\t\t\t XFS_FSB_TO_B(mp, sbp->sb_logblocks),\n\t\t\t XFS_MAX_LOG_BYTES);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\tif (sbp->sb_versionnum & XFS_SB_VERSION_SECTORBIT) {\n\t\tif (sbp->sb_logsectsize != (1U << sbp->sb_logsectlog)) {\n\t\t\txfs_notice(mp,\n\t\t\t\"log sector size in bytes/log2 (0x%x/0x%x) must match\",\n\t\t\t\tsbp->sb_logsectsize, 1U << sbp->sb_logsectlog);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t} else if (sbp->sb_logsectsize || sbp->sb_logsectlog) {\n\t\txfs_notice(mp,\n\t\t\"log sector size in bytes/log2 (0x%x/0x%x) are not zero\",\n\t\t\tsbp->sb_logsectsize, sbp->sb_logsectlog);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (sbp->sb_logsunit > 1) {\n\t\tif (sbp->sb_logsunit % sbp->sb_blocksize) {\n\t\t\txfs_notice(mp,\n\t\t\"log stripe unit 0x%x bytes must be a multiple of block size\",\n\t\t\t\tsbp->sb_logsunit);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (sbp->sb_logsunit > XLOG_MAX_RECORD_BSIZE) {\n\t\t\txfs_notice(mp,\n\t\t\"log stripe unit 0x%x bytes over maximum size (0x%x bytes)\",\n\t\t\t\tsbp->sb_logsunit, XLOG_MAX_RECORD_BSIZE);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\t \n\tif (sbp->sb_rextsize * sbp->sb_blocksize > XFS_MAX_RTEXTSIZE ||\n\t    sbp->sb_rextsize * sbp->sb_blocksize < XFS_MIN_RTEXTSIZE) {\n\t\txfs_notice(mp,\n\t\t\t\"realtime extent sanity check failed\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (sbp->sb_rblocks == 0) {\n\t\tif (sbp->sb_rextents != 0 || sbp->sb_rbmblocks != 0 ||\n\t\t    sbp->sb_rextslog != 0 || sbp->sb_frextents != 0) {\n\t\t\txfs_notice(mp,\n\t\t\t\t\"realtime zeroed geometry check failed\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t} else {\n\t\tuint64_t\trexts;\n\t\tuint64_t\trbmblocks;\n\n\t\trexts = div_u64(sbp->sb_rblocks, sbp->sb_rextsize);\n\t\trbmblocks = howmany_64(sbp->sb_rextents,\n\t\t\t\t       NBBY * sbp->sb_blocksize);\n\n\t\tif (sbp->sb_rextents != rexts ||\n\t\t    sbp->sb_rextslog != xfs_highbit32(sbp->sb_rextents) ||\n\t\t    sbp->sb_rbmblocks != rbmblocks) {\n\t\t\txfs_notice(mp,\n\t\t\t\t\"realtime geometry sanity check failed\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\t \n\thas_dalign = sbp->sb_versionnum & XFS_SB_VERSION_DALIGNBIT;\n\tif (!!sbp->sb_unit ^ has_dalign) {\n\t\txfs_notice(mp, \"SB stripe alignment sanity check failed\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (!xfs_validate_stripe_geometry(mp, XFS_FSB_TO_B(mp, sbp->sb_unit),\n\t\t\tXFS_FSB_TO_B(mp, sbp->sb_width), 0, false))\n\t\treturn -EFSCORRUPTED;\n\n\t \n\tswitch (sbp->sb_inodesize) {\n\tcase 256:\n\tcase 512:\n\tcase 1024:\n\tcase 2048:\n\t\tbreak;\n\tdefault:\n\t\txfs_warn(mp, \"inode size of %d bytes not supported\",\n\t\t\t\tsbp->sb_inodesize);\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}\n\nvoid\nxfs_sb_quota_from_disk(struct xfs_sb *sbp)\n{\n\t \n\tif (sbp->sb_uquotino == 0)\n\t\tsbp->sb_uquotino = NULLFSINO;\n\tif (sbp->sb_gquotino == 0)\n\t\tsbp->sb_gquotino = NULLFSINO;\n\tif (sbp->sb_pquotino == 0)\n\t\tsbp->sb_pquotino = NULLFSINO;\n\n\t \n\tif (xfs_sb_is_v5(sbp))\n\t\treturn;\n\n\tif (sbp->sb_qflags & XFS_OQUOTA_ENFD)\n\t\tsbp->sb_qflags |= (sbp->sb_qflags & XFS_PQUOTA_ACCT) ?\n\t\t\t\t\tXFS_PQUOTA_ENFD : XFS_GQUOTA_ENFD;\n\tif (sbp->sb_qflags & XFS_OQUOTA_CHKD)\n\t\tsbp->sb_qflags |= (sbp->sb_qflags & XFS_PQUOTA_ACCT) ?\n\t\t\t\t\tXFS_PQUOTA_CHKD : XFS_GQUOTA_CHKD;\n\tsbp->sb_qflags &= ~(XFS_OQUOTA_ENFD | XFS_OQUOTA_CHKD);\n\n\tif (sbp->sb_qflags & XFS_PQUOTA_ACCT &&\n\t    sbp->sb_gquotino != NULLFSINO)  {\n\t\t \n\t\tsbp->sb_pquotino = sbp->sb_gquotino;\n\t\tsbp->sb_gquotino = NULLFSINO;\n\t}\n}\n\nstatic void\n__xfs_sb_from_disk(\n\tstruct xfs_sb\t*to,\n\tstruct xfs_dsb\t*from,\n\tbool\t\tconvert_xquota)\n{\n\tto->sb_magicnum = be32_to_cpu(from->sb_magicnum);\n\tto->sb_blocksize = be32_to_cpu(from->sb_blocksize);\n\tto->sb_dblocks = be64_to_cpu(from->sb_dblocks);\n\tto->sb_rblocks = be64_to_cpu(from->sb_rblocks);\n\tto->sb_rextents = be64_to_cpu(from->sb_rextents);\n\tmemcpy(&to->sb_uuid, &from->sb_uuid, sizeof(to->sb_uuid));\n\tto->sb_logstart = be64_to_cpu(from->sb_logstart);\n\tto->sb_rootino = be64_to_cpu(from->sb_rootino);\n\tto->sb_rbmino = be64_to_cpu(from->sb_rbmino);\n\tto->sb_rsumino = be64_to_cpu(from->sb_rsumino);\n\tto->sb_rextsize = be32_to_cpu(from->sb_rextsize);\n\tto->sb_agblocks = be32_to_cpu(from->sb_agblocks);\n\tto->sb_agcount = be32_to_cpu(from->sb_agcount);\n\tto->sb_rbmblocks = be32_to_cpu(from->sb_rbmblocks);\n\tto->sb_logblocks = be32_to_cpu(from->sb_logblocks);\n\tto->sb_versionnum = be16_to_cpu(from->sb_versionnum);\n\tto->sb_sectsize = be16_to_cpu(from->sb_sectsize);\n\tto->sb_inodesize = be16_to_cpu(from->sb_inodesize);\n\tto->sb_inopblock = be16_to_cpu(from->sb_inopblock);\n\tmemcpy(&to->sb_fname, &from->sb_fname, sizeof(to->sb_fname));\n\tto->sb_blocklog = from->sb_blocklog;\n\tto->sb_sectlog = from->sb_sectlog;\n\tto->sb_inodelog = from->sb_inodelog;\n\tto->sb_inopblog = from->sb_inopblog;\n\tto->sb_agblklog = from->sb_agblklog;\n\tto->sb_rextslog = from->sb_rextslog;\n\tto->sb_inprogress = from->sb_inprogress;\n\tto->sb_imax_pct = from->sb_imax_pct;\n\tto->sb_icount = be64_to_cpu(from->sb_icount);\n\tto->sb_ifree = be64_to_cpu(from->sb_ifree);\n\tto->sb_fdblocks = be64_to_cpu(from->sb_fdblocks);\n\tto->sb_frextents = be64_to_cpu(from->sb_frextents);\n\tto->sb_uquotino = be64_to_cpu(from->sb_uquotino);\n\tto->sb_gquotino = be64_to_cpu(from->sb_gquotino);\n\tto->sb_qflags = be16_to_cpu(from->sb_qflags);\n\tto->sb_flags = from->sb_flags;\n\tto->sb_shared_vn = from->sb_shared_vn;\n\tto->sb_inoalignmt = be32_to_cpu(from->sb_inoalignmt);\n\tto->sb_unit = be32_to_cpu(from->sb_unit);\n\tto->sb_width = be32_to_cpu(from->sb_width);\n\tto->sb_dirblklog = from->sb_dirblklog;\n\tto->sb_logsectlog = from->sb_logsectlog;\n\tto->sb_logsectsize = be16_to_cpu(from->sb_logsectsize);\n\tto->sb_logsunit = be32_to_cpu(from->sb_logsunit);\n\tto->sb_features2 = be32_to_cpu(from->sb_features2);\n\tto->sb_bad_features2 = be32_to_cpu(from->sb_bad_features2);\n\tto->sb_features_compat = be32_to_cpu(from->sb_features_compat);\n\tto->sb_features_ro_compat = be32_to_cpu(from->sb_features_ro_compat);\n\tto->sb_features_incompat = be32_to_cpu(from->sb_features_incompat);\n\tto->sb_features_log_incompat =\n\t\t\t\tbe32_to_cpu(from->sb_features_log_incompat);\n\t \n\tto->sb_crc = 0;\n\tto->sb_spino_align = be32_to_cpu(from->sb_spino_align);\n\tto->sb_pquotino = be64_to_cpu(from->sb_pquotino);\n\tto->sb_lsn = be64_to_cpu(from->sb_lsn);\n\t \n\tif (xfs_sb_is_v5(to) &&\n\t    (to->sb_features_incompat & XFS_SB_FEAT_INCOMPAT_META_UUID))\n\t\tuuid_copy(&to->sb_meta_uuid, &from->sb_meta_uuid);\n\telse\n\t\tuuid_copy(&to->sb_meta_uuid, &from->sb_uuid);\n\t \n\tif (convert_xquota)\n\t\txfs_sb_quota_from_disk(to);\n}\n\nvoid\nxfs_sb_from_disk(\n\tstruct xfs_sb\t*to,\n\tstruct xfs_dsb\t*from)\n{\n\t__xfs_sb_from_disk(to, from, true);\n}\n\nstatic void\nxfs_sb_quota_to_disk(\n\tstruct xfs_dsb\t*to,\n\tstruct xfs_sb\t*from)\n{\n\tuint16_t\tqflags = from->sb_qflags;\n\n\tto->sb_uquotino = cpu_to_be64(from->sb_uquotino);\n\n\t \n\tif (xfs_sb_is_v5(from)) {\n\t\tto->sb_qflags = cpu_to_be16(from->sb_qflags);\n\t\tto->sb_gquotino = cpu_to_be64(from->sb_gquotino);\n\t\tto->sb_pquotino = cpu_to_be64(from->sb_pquotino);\n\t\treturn;\n\t}\n\n\t \n\tqflags &= ~(XFS_PQUOTA_ENFD | XFS_PQUOTA_CHKD |\n\t\t\tXFS_GQUOTA_ENFD | XFS_GQUOTA_CHKD);\n\n\tif (from->sb_qflags &\n\t\t\t(XFS_PQUOTA_ENFD | XFS_GQUOTA_ENFD))\n\t\tqflags |= XFS_OQUOTA_ENFD;\n\tif (from->sb_qflags &\n\t\t\t(XFS_PQUOTA_CHKD | XFS_GQUOTA_CHKD))\n\t\tqflags |= XFS_OQUOTA_CHKD;\n\tto->sb_qflags = cpu_to_be16(qflags);\n\n\t \n\tif (from->sb_qflags & XFS_GQUOTA_ACCT)\n\t\tto->sb_gquotino = cpu_to_be64(from->sb_gquotino);\n\telse if (from->sb_qflags & XFS_PQUOTA_ACCT)\n\t\tto->sb_gquotino = cpu_to_be64(from->sb_pquotino);\n\telse {\n\t\t \n\t\tif (from->sb_gquotino == NULLFSINO &&\n\t\t    from->sb_pquotino == NULLFSINO)\n\t\t\tto->sb_gquotino = cpu_to_be64(NULLFSINO);\n\t}\n\n\tto->sb_pquotino = 0;\n}\n\nvoid\nxfs_sb_to_disk(\n\tstruct xfs_dsb\t*to,\n\tstruct xfs_sb\t*from)\n{\n\txfs_sb_quota_to_disk(to, from);\n\n\tto->sb_magicnum = cpu_to_be32(from->sb_magicnum);\n\tto->sb_blocksize = cpu_to_be32(from->sb_blocksize);\n\tto->sb_dblocks = cpu_to_be64(from->sb_dblocks);\n\tto->sb_rblocks = cpu_to_be64(from->sb_rblocks);\n\tto->sb_rextents = cpu_to_be64(from->sb_rextents);\n\tmemcpy(&to->sb_uuid, &from->sb_uuid, sizeof(to->sb_uuid));\n\tto->sb_logstart = cpu_to_be64(from->sb_logstart);\n\tto->sb_rootino = cpu_to_be64(from->sb_rootino);\n\tto->sb_rbmino = cpu_to_be64(from->sb_rbmino);\n\tto->sb_rsumino = cpu_to_be64(from->sb_rsumino);\n\tto->sb_rextsize = cpu_to_be32(from->sb_rextsize);\n\tto->sb_agblocks = cpu_to_be32(from->sb_agblocks);\n\tto->sb_agcount = cpu_to_be32(from->sb_agcount);\n\tto->sb_rbmblocks = cpu_to_be32(from->sb_rbmblocks);\n\tto->sb_logblocks = cpu_to_be32(from->sb_logblocks);\n\tto->sb_versionnum = cpu_to_be16(from->sb_versionnum);\n\tto->sb_sectsize = cpu_to_be16(from->sb_sectsize);\n\tto->sb_inodesize = cpu_to_be16(from->sb_inodesize);\n\tto->sb_inopblock = cpu_to_be16(from->sb_inopblock);\n\tmemcpy(&to->sb_fname, &from->sb_fname, sizeof(to->sb_fname));\n\tto->sb_blocklog = from->sb_blocklog;\n\tto->sb_sectlog = from->sb_sectlog;\n\tto->sb_inodelog = from->sb_inodelog;\n\tto->sb_inopblog = from->sb_inopblog;\n\tto->sb_agblklog = from->sb_agblklog;\n\tto->sb_rextslog = from->sb_rextslog;\n\tto->sb_inprogress = from->sb_inprogress;\n\tto->sb_imax_pct = from->sb_imax_pct;\n\tto->sb_icount = cpu_to_be64(from->sb_icount);\n\tto->sb_ifree = cpu_to_be64(from->sb_ifree);\n\tto->sb_fdblocks = cpu_to_be64(from->sb_fdblocks);\n\tto->sb_frextents = cpu_to_be64(from->sb_frextents);\n\n\tto->sb_flags = from->sb_flags;\n\tto->sb_shared_vn = from->sb_shared_vn;\n\tto->sb_inoalignmt = cpu_to_be32(from->sb_inoalignmt);\n\tto->sb_unit = cpu_to_be32(from->sb_unit);\n\tto->sb_width = cpu_to_be32(from->sb_width);\n\tto->sb_dirblklog = from->sb_dirblklog;\n\tto->sb_logsectlog = from->sb_logsectlog;\n\tto->sb_logsectsize = cpu_to_be16(from->sb_logsectsize);\n\tto->sb_logsunit = cpu_to_be32(from->sb_logsunit);\n\n\t \n\tfrom->sb_bad_features2 = from->sb_features2;\n\tto->sb_features2 = cpu_to_be32(from->sb_features2);\n\tto->sb_bad_features2 = cpu_to_be32(from->sb_bad_features2);\n\n\tif (!xfs_sb_is_v5(from))\n\t\treturn;\n\n\tto->sb_features_compat = cpu_to_be32(from->sb_features_compat);\n\tto->sb_features_ro_compat =\n\t\t\tcpu_to_be32(from->sb_features_ro_compat);\n\tto->sb_features_incompat =\n\t\t\tcpu_to_be32(from->sb_features_incompat);\n\tto->sb_features_log_incompat =\n\t\t\tcpu_to_be32(from->sb_features_log_incompat);\n\tto->sb_spino_align = cpu_to_be32(from->sb_spino_align);\n\tto->sb_lsn = cpu_to_be64(from->sb_lsn);\n\tif (from->sb_features_incompat & XFS_SB_FEAT_INCOMPAT_META_UUID)\n\t\tuuid_copy(&to->sb_meta_uuid, &from->sb_meta_uuid);\n}\n\n \nstatic void\nxfs_sb_read_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_sb\t\tsb;\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_dsb\t\t*dsb = bp->b_addr;\n\tint\t\t\terror;\n\n\t \n\tif (dsb->sb_magicnum == cpu_to_be32(XFS_SB_MAGIC) &&\n\t    (((be16_to_cpu(dsb->sb_versionnum) & XFS_SB_VERSION_NUMBITS) ==\n\t\t\t\t\t\tXFS_SB_VERSION_5) ||\n\t     dsb->sb_crc != 0)) {\n\n\t\tif (!xfs_buf_verify_cksum(bp, XFS_SB_CRC_OFF)) {\n\t\t\t \n\t\t\tif (xfs_buf_daddr(bp) == XFS_SB_DADDR ||\n\t\t\t    xfs_has_crc(mp)) {\n\t\t\t\terror = -EFSBADCRC;\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\t__xfs_sb_from_disk(&sb, dsb, false);\n\terror = xfs_validate_sb_common(mp, bp, &sb);\n\tif (error)\n\t\tgoto out_error;\n\terror = xfs_validate_sb_read(mp, &sb);\n\nout_error:\n\tif (error == -EFSCORRUPTED || error == -EFSBADCRC)\n\t\txfs_verifier_error(bp, error, __this_address);\n\telse if (error)\n\t\txfs_buf_ioerror(bp, error);\n}\n\n \nstatic void\nxfs_sb_quiet_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_dsb\t*dsb = bp->b_addr;\n\n\tif (dsb->sb_magicnum == cpu_to_be32(XFS_SB_MAGIC)) {\n\t\t \n\t\txfs_sb_read_verify(bp);\n\t\treturn;\n\t}\n\t \n\txfs_buf_ioerror(bp, -EWRONGFS);\n}\n\nstatic void\nxfs_sb_write_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_sb\t\tsb;\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_log_item;\n\tstruct xfs_dsb\t\t*dsb = bp->b_addr;\n\tint\t\t\terror;\n\n\t \n\t__xfs_sb_from_disk(&sb, dsb, false);\n\terror = xfs_validate_sb_common(mp, bp, &sb);\n\tif (error)\n\t\tgoto out_error;\n\terror = xfs_validate_sb_write(mp, bp, &sb);\n\tif (error)\n\t\tgoto out_error;\n\n\tif (!xfs_sb_is_v5(&sb))\n\t\treturn;\n\n\tif (bip)\n\t\tdsb->sb_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_SB_CRC_OFF);\n\treturn;\n\nout_error:\n\txfs_verifier_error(bp, error, __this_address);\n}\n\nconst struct xfs_buf_ops xfs_sb_buf_ops = {\n\t.name = \"xfs_sb\",\n\t.magic = { cpu_to_be32(XFS_SB_MAGIC), cpu_to_be32(XFS_SB_MAGIC) },\n\t.verify_read = xfs_sb_read_verify,\n\t.verify_write = xfs_sb_write_verify,\n};\n\nconst struct xfs_buf_ops xfs_sb_quiet_buf_ops = {\n\t.name = \"xfs_sb_quiet\",\n\t.magic = { cpu_to_be32(XFS_SB_MAGIC), cpu_to_be32(XFS_SB_MAGIC) },\n\t.verify_read = xfs_sb_quiet_read_verify,\n\t.verify_write = xfs_sb_write_verify,\n};\n\n \nvoid\nxfs_sb_mount_common(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_sb\t\t*sbp)\n{\n\tmp->m_agfrotor = 0;\n\tatomic_set(&mp->m_agirotor, 0);\n\tmp->m_maxagi = mp->m_sb.sb_agcount;\n\tmp->m_blkbit_log = sbp->sb_blocklog + XFS_NBBYLOG;\n\tmp->m_blkbb_log = sbp->sb_blocklog - BBSHIFT;\n\tmp->m_sectbb_log = sbp->sb_sectlog - BBSHIFT;\n\tmp->m_agno_log = xfs_highbit32(sbp->sb_agcount - 1) + 1;\n\tmp->m_blockmask = sbp->sb_blocksize - 1;\n\tmp->m_blockwsize = sbp->sb_blocksize >> XFS_WORDLOG;\n\tmp->m_blockwmask = mp->m_blockwsize - 1;\n\n\tmp->m_alloc_mxr[0] = xfs_allocbt_maxrecs(mp, sbp->sb_blocksize, 1);\n\tmp->m_alloc_mxr[1] = xfs_allocbt_maxrecs(mp, sbp->sb_blocksize, 0);\n\tmp->m_alloc_mnr[0] = mp->m_alloc_mxr[0] / 2;\n\tmp->m_alloc_mnr[1] = mp->m_alloc_mxr[1] / 2;\n\n\tmp->m_bmap_dmxr[0] = xfs_bmbt_maxrecs(mp, sbp->sb_blocksize, 1);\n\tmp->m_bmap_dmxr[1] = xfs_bmbt_maxrecs(mp, sbp->sb_blocksize, 0);\n\tmp->m_bmap_dmnr[0] = mp->m_bmap_dmxr[0] / 2;\n\tmp->m_bmap_dmnr[1] = mp->m_bmap_dmxr[1] / 2;\n\n\tmp->m_rmap_mxr[0] = xfs_rmapbt_maxrecs(sbp->sb_blocksize, 1);\n\tmp->m_rmap_mxr[1] = xfs_rmapbt_maxrecs(sbp->sb_blocksize, 0);\n\tmp->m_rmap_mnr[0] = mp->m_rmap_mxr[0] / 2;\n\tmp->m_rmap_mnr[1] = mp->m_rmap_mxr[1] / 2;\n\n\tmp->m_refc_mxr[0] = xfs_refcountbt_maxrecs(sbp->sb_blocksize, true);\n\tmp->m_refc_mxr[1] = xfs_refcountbt_maxrecs(sbp->sb_blocksize, false);\n\tmp->m_refc_mnr[0] = mp->m_refc_mxr[0] / 2;\n\tmp->m_refc_mnr[1] = mp->m_refc_mxr[1] / 2;\n\n\tmp->m_bsize = XFS_FSB_TO_BB(mp, 1);\n\tmp->m_alloc_set_aside = xfs_alloc_set_aside(mp);\n\tmp->m_ag_max_usable = xfs_alloc_ag_max_usable(mp);\n}\n\n \nvoid\nxfs_log_sb(\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_buf\t\t*bp = xfs_trans_getsb(tp);\n\n\t \n\tif (xfs_has_lazysbcount(mp)) {\n\t\tmp->m_sb.sb_icount = percpu_counter_sum(&mp->m_icount);\n\t\tmp->m_sb.sb_ifree = min_t(uint64_t,\n\t\t\t\tpercpu_counter_sum(&mp->m_ifree),\n\t\t\t\tmp->m_sb.sb_icount);\n\t\tmp->m_sb.sb_fdblocks = percpu_counter_sum(&mp->m_fdblocks);\n\t}\n\n\txfs_sb_to_disk(bp->b_addr, &mp->m_sb);\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SB_BUF);\n\txfs_trans_log_buf(tp, bp, 0, sizeof(struct xfs_dsb) - 1);\n}\n\n \nint\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_sb, 0, 0,\n\t\t\tXFS_TRANS_NO_WRITECOUNT, &tp);\n\tif (error)\n\t\treturn error;\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp);\n}\n\n \nint\nxfs_update_secondary_sbs(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_perag\t*pag;\n\txfs_agnumber_t\t\tagno = 1;\n\tint\t\t\tsaved_error = 0;\n\tint\t\t\terror = 0;\n\tLIST_HEAD\t\t(buffer_list);\n\n\t \n\tfor_each_perag_from(mp, agno, pag) {\n\t\tstruct xfs_buf\t\t*bp;\n\n\t\terror = xfs_buf_get(mp->m_ddev_targp,\n\t\t\t\t XFS_AG_DADDR(mp, pag->pag_agno, XFS_SB_DADDR),\n\t\t\t\t XFS_FSS_TO_BB(mp, 1), &bp);\n\t\t \n\t\tif (error) {\n\t\t\txfs_warn(mp,\n\t\t\"error allocating secondary superblock for ag %d\",\n\t\t\t\tpag->pag_agno);\n\t\t\tif (!saved_error)\n\t\t\t\tsaved_error = error;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbp->b_ops = &xfs_sb_buf_ops;\n\t\txfs_buf_oneshot(bp);\n\t\txfs_buf_zero(bp, 0, BBTOB(bp->b_length));\n\t\txfs_sb_to_disk(bp->b_addr, &mp->m_sb);\n\t\txfs_buf_delwri_queue(bp, &buffer_list);\n\t\txfs_buf_relse(bp);\n\n\t\t \n\t\tif (agno % 16)\n\t\t\tcontinue;\n\n\t\terror = xfs_buf_delwri_submit(&buffer_list);\n\t\tif (error) {\n\t\t\txfs_warn(mp,\n\t\t\"write error %d updating a secondary superblock near ag %d\",\n\t\t\t\terror, pag->pag_agno);\n\t\t\tif (!saved_error)\n\t\t\t\tsaved_error = error;\n\t\t\tcontinue;\n\t\t}\n\t}\n\terror = xfs_buf_delwri_submit(&buffer_list);\n\tif (error) {\n\t\txfs_warn(mp,\n\t\t\"write error %d updating a secondary superblock near ag %d\",\n\t\t\terror, agno);\n\t}\n\n\treturn saved_error ? saved_error : error;\n}\n\n \nint\nxfs_sync_sb_buf(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_sb, 0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\tbp = xfs_trans_getsb(tp);\n\txfs_log_sb(tp);\n\txfs_trans_bhold(tp, bp);\n\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp);\n\tif (error)\n\t\tgoto out;\n\t \n\terror = xfs_bwrite(bp);\nout:\n\txfs_buf_relse(bp);\n\treturn error;\n}\n\nvoid\nxfs_fs_geometry(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_fsop_geom\t*geo,\n\tint\t\t\tstruct_version)\n{\n\tstruct xfs_sb\t\t*sbp = &mp->m_sb;\n\n\tmemset(geo, 0, sizeof(struct xfs_fsop_geom));\n\n\tgeo->blocksize = sbp->sb_blocksize;\n\tgeo->rtextsize = sbp->sb_rextsize;\n\tgeo->agblocks = sbp->sb_agblocks;\n\tgeo->agcount = sbp->sb_agcount;\n\tgeo->logblocks = sbp->sb_logblocks;\n\tgeo->sectsize = sbp->sb_sectsize;\n\tgeo->inodesize = sbp->sb_inodesize;\n\tgeo->imaxpct = sbp->sb_imax_pct;\n\tgeo->datablocks = sbp->sb_dblocks;\n\tgeo->rtblocks = sbp->sb_rblocks;\n\tgeo->rtextents = sbp->sb_rextents;\n\tgeo->logstart = sbp->sb_logstart;\n\tBUILD_BUG_ON(sizeof(geo->uuid) != sizeof(sbp->sb_uuid));\n\tmemcpy(geo->uuid, &sbp->sb_uuid, sizeof(sbp->sb_uuid));\n\n\tif (struct_version < 2)\n\t\treturn;\n\n\tgeo->sunit = sbp->sb_unit;\n\tgeo->swidth = sbp->sb_width;\n\n\tif (struct_version < 3)\n\t\treturn;\n\n\tgeo->version = XFS_FSOP_GEOM_VERSION;\n\tgeo->flags = XFS_FSOP_GEOM_FLAGS_NLINK |\n\t\t     XFS_FSOP_GEOM_FLAGS_DIRV2 |\n\t\t     XFS_FSOP_GEOM_FLAGS_EXTFLG;\n\tif (xfs_has_attr(mp))\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_ATTR;\n\tif (xfs_has_quota(mp))\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_QUOTA;\n\tif (xfs_has_align(mp))\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_IALIGN;\n\tif (xfs_has_dalign(mp))\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_DALIGN;\n\tif (xfs_has_asciici(mp))\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_DIRV2CI;\n\tif (xfs_has_lazysbcount(mp))\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_LAZYSB;\n\tif (xfs_has_attr2(mp))\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_ATTR2;\n\tif (xfs_has_projid32(mp))\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_PROJID32;\n\tif (xfs_has_crc(mp))\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_V5SB;\n\tif (xfs_has_ftype(mp))\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_FTYPE;\n\tif (xfs_has_finobt(mp))\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_FINOBT;\n\tif (xfs_has_sparseinodes(mp))\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_SPINODES;\n\tif (xfs_has_rmapbt(mp))\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_RMAPBT;\n\tif (xfs_has_reflink(mp))\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_REFLINK;\n\tif (xfs_has_bigtime(mp))\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_BIGTIME;\n\tif (xfs_has_inobtcounts(mp))\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_INOBTCNT;\n\tif (xfs_has_sector(mp)) {\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_SECTOR;\n\t\tgeo->logsectsize = sbp->sb_logsectsize;\n\t} else {\n\t\tgeo->logsectsize = BBSIZE;\n\t}\n\tif (xfs_has_large_extent_counts(mp))\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_NREXT64;\n\tgeo->rtsectsize = sbp->sb_blocksize;\n\tgeo->dirblocksize = xfs_dir2_dirblock_bytes(sbp);\n\n\tif (struct_version < 4)\n\t\treturn;\n\n\tif (xfs_has_logv2(mp))\n\t\tgeo->flags |= XFS_FSOP_GEOM_FLAGS_LOGV2;\n\n\tgeo->logsunit = sbp->sb_logsunit;\n\n\tif (struct_version < 5)\n\t\treturn;\n\n\tgeo->version = XFS_FSOP_GEOM_VERSION_V5;\n}\n\n \nint\nxfs_sb_read_secondary(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tASSERT(agno != 0 && agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_SB_BLOCK(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, &xfs_sb_buf_ops);\n\tif (error)\n\t\treturn error;\n\txfs_buf_set_ref(bp, XFS_SSB_REF);\n\t*bpp = bp;\n\treturn 0;\n}\n\n \nint\nxfs_sb_get_secondary(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tASSERT(agno != 0 && agno != NULLAGNUMBER);\n\terror = xfs_trans_get_buf(tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_SB_BLOCK(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_sb_buf_ops;\n\txfs_buf_oneshot(bp);\n\t*bpp = bp;\n\treturn 0;\n}\n\n \nbool\nxfs_validate_stripe_geometry(\n\tstruct xfs_mount\t*mp,\n\t__s64\t\t\tsunit,\n\t__s64\t\t\tswidth,\n\tint\t\t\tsectorsize,\n\tbool\t\t\tsilent)\n{\n\tif (swidth > INT_MAX) {\n\t\tif (!silent)\n\t\t\txfs_notice(mp,\n\"stripe width (%lld) is too large\", swidth);\n\t\treturn false;\n\t}\n\n\tif (sunit > swidth) {\n\t\tif (!silent)\n\t\t\txfs_notice(mp,\n\"stripe unit (%lld) is larger than the stripe width (%lld)\", sunit, swidth);\n\t\treturn false;\n\t}\n\n\tif (sectorsize && (int)sunit % sectorsize) {\n\t\tif (!silent)\n\t\t\txfs_notice(mp,\n\"stripe unit (%lld) must be a multiple of the sector size (%d)\",\n\t\t\t\t   sunit, sectorsize);\n\t\treturn false;\n\t}\n\n\tif (sunit && !swidth) {\n\t\tif (!silent)\n\t\t\txfs_notice(mp,\n\"invalid stripe unit (%lld) and stripe width of 0\", sunit);\n\t\treturn false;\n\t}\n\n\tif (!sunit && swidth) {\n\t\tif (!silent)\n\t\t\txfs_notice(mp,\n\"invalid stripe width (%lld) and stripe unit of 0\", swidth);\n\t\treturn false;\n\t}\n\n\tif (sunit && (int)swidth % (int)sunit) {\n\t\tif (!silent)\n\t\t\txfs_notice(mp,\n\"stripe width (%lld) must be a multiple of the stripe unit (%lld)\",\n\t\t\t\t   swidth, sunit);\n\t\treturn false;\n\t}\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}