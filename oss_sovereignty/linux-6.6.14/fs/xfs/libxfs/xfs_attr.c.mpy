{
  "module_name": "xfs_attr.c",
  "hash_id": "19f8ee3386cde416bf1121452f2b082309659241943dbf3fe8e8678633d6a0b6",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/libxfs/xfs_attr.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_attr_item.h\"\n#include \"xfs_xattr.h\"\n\nstruct kmem_cache\t\t*xfs_attr_intent_cache;\n\n \n\n \n\n \nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\n\n \nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_hasname(struct xfs_da_args *args, struct xfs_buf **bp);\nSTATIC int xfs_attr_leaf_try_add(struct xfs_da_args *args);\n\n \nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC void xfs_attr_restore_rmt_blk(struct xfs_da_args *args);\nstatic int xfs_attr_node_try_addname(struct xfs_attr_intent *attr);\nSTATIC int xfs_attr_node_addname_find_attr(struct xfs_attr_intent *attr);\nSTATIC int xfs_attr_node_remove_attr(struct xfs_attr_intent *attr);\nSTATIC int xfs_attr_node_lookup(struct xfs_da_args *args,\n\t\tstruct xfs_da_state *state);\n\nint\nxfs_inode_hasattr(\n\tstruct xfs_inode\t*ip)\n{\n\tif (!xfs_inode_has_attr_fork(ip))\n\t\treturn 0;\n\tif (ip->i_af.if_format == XFS_DINODE_FMT_EXTENTS &&\n\t    ip->i_af.if_nextents == 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nbool\nxfs_attr_is_leaf(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_ifork\t*ifp = &ip->i_af;\n\tstruct xfs_iext_cursor\ticur;\n\tstruct xfs_bmbt_irec\timap;\n\n\tif (ifp->if_nextents != 1 || ifp->if_format != XFS_DINODE_FMT_EXTENTS)\n\t\treturn false;\n\n\txfs_iext_first(ifp, &icur);\n\txfs_iext_get_extent(ifp, &icur, &imap);\n\treturn imap.br_startoff == 0 && imap.br_blockcount == 1;\n}\n\n \n#if 0\n \nstatic int\nxfs_attr_fillstate(xfs_da_state_t *state)\n{\n\txfs_da_state_path_t *path;\n\txfs_da_state_blk_t *blk;\n\tint level;\n\n\ttrace_xfs_attr_fillstate(state->args);\n\n\t \n\tpath = &state->path;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->bp) {\n\t\t\tblk->disk_blkno = xfs_buf_daddr(blk->bp);\n\t\t\tblk->bp = NULL;\n\t\t} else {\n\t\t\tblk->disk_blkno = 0;\n\t\t}\n\t}\n\n\t \n\tpath = &state->altpath;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->bp) {\n\t\t\tblk->disk_blkno = xfs_buf_daddr(blk->bp);\n\t\t\tblk->bp = NULL;\n\t\t} else {\n\t\t\tblk->disk_blkno = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nxfs_attr_refillstate(xfs_da_state_t *state)\n{\n\txfs_da_state_path_t *path;\n\txfs_da_state_blk_t *blk;\n\tint level, error;\n\n\ttrace_xfs_attr_refillstate(state->args);\n\n\t \n\tpath = &state->path;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->disk_blkno) {\n\t\t\terror = xfs_da3_node_read_mapped(state->args->trans,\n\t\t\t\t\tstate->args->dp, blk->disk_blkno,\n\t\t\t\t\t&blk->bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tblk->bp = NULL;\n\t\t}\n\t}\n\n\t \n\tpath = &state->altpath;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->disk_blkno) {\n\t\t\terror = xfs_da3_node_read_mapped(state->args->trans,\n\t\t\t\t\tstate->args->dp, blk->disk_blkno,\n\t\t\t\t\t&blk->bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tblk->bp = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#else\nstatic int xfs_attr_fillstate(xfs_da_state_t *state) { return 0; }\n#endif\n\n \n\n \nint\nxfs_attr_get_ilocked(\n\tstruct xfs_da_args\t*args)\n{\n\tASSERT(xfs_isilocked(args->dp, XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\n\tif (!xfs_inode_hasattr(args->dp))\n\t\treturn -ENOATTR;\n\n\tif (args->dp->i_af.if_format == XFS_DINODE_FMT_LOCAL)\n\t\treturn xfs_attr_shortform_getvalue(args);\n\tif (xfs_attr_is_leaf(args->dp))\n\t\treturn xfs_attr_leaf_get(args);\n\treturn xfs_attr_node_get(args);\n}\n\n \nint\nxfs_attr_get(\n\tstruct xfs_da_args\t*args)\n{\n\tuint\t\t\tlock_mode;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(args->dp->i_mount, xs_attr_get);\n\n\tif (xfs_is_shutdown(args->dp->i_mount))\n\t\treturn -EIO;\n\n\targs->geo = args->dp->i_mount->m_attr_geo;\n\targs->whichfork = XFS_ATTR_FORK;\n\targs->hashval = xfs_da_hashname(args->name, args->namelen);\n\n\t \n\targs->op_flags = XFS_DA_OP_OKNOENT;\n\n\tlock_mode = xfs_ilock_attr_map_shared(args->dp);\n\terror = xfs_attr_get_ilocked(args);\n\txfs_iunlock(args->dp, lock_mode);\n\n\treturn error;\n}\n\n \nint\nxfs_attr_calc_size(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*local)\n{\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\n\t \n\tsize = xfs_attr_leaf_newentsize(args, local);\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tif (*local) {\n\t\tif (size > (args->geo->blksize / 2)) {\n\t\t\t \n\t\t\tnblks *= 2;\n\t\t}\n\t} else {\n\t\t \n\t\tuint\tdblocks = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\t\tnblks += dblocks;\n\t\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);\n\t}\n\n\treturn nblks;\n}\n\n \nvoid\nxfs_init_attr_trans(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_trans_res\t*tres,\n\tunsigned int\t\t*total)\n{\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\n\tif (args->value) {\n\t\ttres->tr_logres = M_RES(mp)->tr_attrsetm.tr_logres +\n\t\t\t\t M_RES(mp)->tr_attrsetrt.tr_logres *\n\t\t\t\t args->total;\n\t\ttres->tr_logcount = XFS_ATTRSET_LOG_COUNT;\n\t\ttres->tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\t\t*total = args->total;\n\t} else {\n\t\t*tres = M_RES(mp)->tr_attrrm;\n\t\t*total = XFS_ATTRRM_SPACE_RES(mp);\n\t}\n}\n\n \nSTATIC int\nxfs_attr_try_sf_addname(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_da_args\t*args)\n{\n\n\tint\t\t\terror;\n\n\t \n\tif (dp->i_af.if_format == XFS_DINODE_FMT_EXTENTS)\n\t\txfs_attr_shortform_create(args);\n\n\terror = xfs_attr_shortform_addname(args);\n\tif (error == -ENOSPC)\n\t\treturn error;\n\n\t \n\tif (!error && !(args->op_flags & XFS_DA_OP_NOTIME))\n\t\txfs_trans_ichgtime(args->trans, dp, XFS_ICHGTIME_CHG);\n\n\tif (xfs_has_wsync(dp->i_mount))\n\t\txfs_trans_set_sync(args->trans);\n\n\treturn error;\n}\n\nstatic int\nxfs_attr_sf_addname(\n\tstruct xfs_attr_intent\t\t*attr)\n{\n\tstruct xfs_da_args\t\t*args = attr->xattri_da_args;\n\tstruct xfs_inode\t\t*dp = args->dp;\n\tint\t\t\t\terror = 0;\n\n\terror = xfs_attr_try_sf_addname(dp, args);\n\tif (error != -ENOSPC) {\n\t\tASSERT(!error || error == -EEXIST);\n\t\tattr->xattri_dela_state = XFS_DAS_DONE;\n\t\tgoto out;\n\t}\n\n\t \n\terror = xfs_attr_shortform_to_leaf(args);\n\tif (error)\n\t\treturn error;\n\n\tattr->xattri_dela_state = XFS_DAS_LEAF_ADD;\nout:\n\ttrace_xfs_attr_sf_addname_return(attr->xattri_dela_state, args->dp);\n\treturn error;\n}\n\n \nstatic enum xfs_delattr_state\nxfs_attr_complete_op(\n\tstruct xfs_attr_intent\t*attr,\n\tenum xfs_delattr_state\treplace_state)\n{\n\tstruct xfs_da_args\t*args = attr->xattri_da_args;\n\tbool\t\t\tdo_replace = args->op_flags & XFS_DA_OP_REPLACE;\n\n\targs->op_flags &= ~XFS_DA_OP_REPLACE;\n\tif (do_replace) {\n\t\targs->attr_filter &= ~XFS_ATTR_INCOMPLETE;\n\t\treturn replace_state;\n\t}\n\treturn XFS_DAS_DONE;\n}\n\nstatic int\nxfs_attr_leaf_addname(\n\tstruct xfs_attr_intent\t*attr)\n{\n\tstruct xfs_da_args\t*args = attr->xattri_da_args;\n\tint\t\t\terror;\n\n\tASSERT(xfs_attr_is_leaf(args->dp));\n\n\t \n\terror = xfs_attr_leaf_try_add(args);\n\n\tif (error == -ENOSPC) {\n\t\terror = xfs_attr3_leaf_to_node(args);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tattr->xattri_dela_state = XFS_DAS_NODE_ADD;\n\t\tgoto out;\n\t}\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (args->rmtblkno)\n\t\tattr->xattri_dela_state = XFS_DAS_LEAF_SET_RMT;\n\telse\n\t\tattr->xattri_dela_state = xfs_attr_complete_op(attr,\n\t\t\t\t\t\t\tXFS_DAS_LEAF_REPLACE);\nout:\n\ttrace_xfs_attr_leaf_addname_return(attr->xattri_dela_state, args->dp);\n\treturn error;\n}\n\n \nstatic int\nxfs_attr_node_addname(\n\tstruct xfs_attr_intent\t*attr)\n{\n\tstruct xfs_da_args\t*args = attr->xattri_da_args;\n\tint\t\t\terror;\n\n\terror = xfs_attr_node_addname_find_attr(attr);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr_node_try_addname(attr);\n\tif (error == -ENOSPC) {\n\t\terror = xfs_attr3_leaf_to_node(args);\n\t\tif (error)\n\t\t\treturn error;\n\t\t \n\t\tgoto out;\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (args->rmtblkno)\n\t\tattr->xattri_dela_state = XFS_DAS_NODE_SET_RMT;\n\telse\n\t\tattr->xattri_dela_state = xfs_attr_complete_op(attr,\n\t\t\t\t\t\t\tXFS_DAS_NODE_REPLACE);\nout:\n\ttrace_xfs_attr_node_addname_return(attr->xattri_dela_state, args->dp);\n\treturn error;\n}\n\nstatic int\nxfs_attr_rmtval_alloc(\n\tstruct xfs_attr_intent\t\t*attr)\n{\n\tstruct xfs_da_args              *args = attr->xattri_da_args;\n\tint\t\t\t\terror = 0;\n\n\t \n\tif (attr->xattri_blkcnt > 0) {\n\t\terror = xfs_attr_rmtval_set_blk(attr);\n\t\tif (error)\n\t\t\treturn error;\n\t\t \n\t\tif (attr->xattri_blkcnt > 0)\n\t\t\tgoto out;\n\t}\n\n\terror = xfs_attr_rmtval_set_value(args);\n\tif (error)\n\t\treturn error;\n\n\tattr->xattri_dela_state = xfs_attr_complete_op(attr,\n\t\t\t\t\t\t++attr->xattri_dela_state);\n\t \n\tif (attr->xattri_dela_state == XFS_DAS_DONE)\n\t\terror = xfs_attr3_leaf_clearflag(args);\nout:\n\ttrace_xfs_attr_rmtval_alloc(attr->xattri_dela_state, args->dp);\n\treturn error;\n}\n\n \nstatic int\nxfs_attr_leaf_mark_incomplete(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_da_state\t*state)\n{\n\tint\t\t\terror;\n\n\t \n\terror = xfs_attr_fillstate(state);\n\tif (error)\n\t\treturn error;\n\n\t \n\treturn xfs_attr3_leaf_setflag(args);\n}\n\n \nstatic inline void\nxfs_attr_item_init_da_state(\n\tstruct xfs_attr_intent\t*attr)\n{\n\tstruct xfs_da_args\t*args = attr->xattri_da_args;\n\n\tif (!attr->xattri_da_state)\n\t\tattr->xattri_da_state = xfs_da_state_alloc(args);\n\telse\n\t\txfs_da_state_reset(attr->xattri_da_state, args);\n}\n\n \nstatic\nint xfs_attr_node_removename_setup(\n\tstruct xfs_attr_intent\t\t*attr)\n{\n\tstruct xfs_da_args\t\t*args = attr->xattri_da_args;\n\tstruct xfs_da_state\t\t*state;\n\tint\t\t\t\terror;\n\n\txfs_attr_item_init_da_state(attr);\n\terror = xfs_attr_node_lookup(args, attr->xattri_da_state);\n\tif (error != -EEXIST)\n\t\tgoto out;\n\terror = 0;\n\n\tstate = attr->xattri_da_state;\n\tASSERT(state->path.blk[state->path.active - 1].bp != NULL);\n\tASSERT(state->path.blk[state->path.active - 1].magic ==\n\t\tXFS_ATTR_LEAF_MAGIC);\n\n\terror = xfs_attr_leaf_mark_incomplete(args, state);\n\tif (error)\n\t\tgoto out;\n\tif (args->rmtblkno > 0)\n\t\terror = xfs_attr_rmtval_invalidate(args);\nout:\n\tif (error) {\n\t\txfs_da_state_free(attr->xattri_da_state);\n\t\tattr->xattri_da_state = NULL;\n\t}\n\n\treturn error;\n}\n\n \nstatic int\nxfs_attr_leaf_remove_attr(\n\tstruct xfs_attr_intent\t\t*attr)\n{\n\tstruct xfs_da_args              *args = attr->xattri_da_args;\n\tstruct xfs_inode\t\t*dp = args->dp;\n\tstruct xfs_buf\t\t\t*bp = NULL;\n\tint\t\t\t\tforkoff;\n\tint\t\t\t\terror;\n\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno,\n\t\t\t\t   &bp);\n\tif (error)\n\t\treturn error;\n\n\txfs_attr3_leaf_remove(bp, args);\n\n\tforkoff = xfs_attr_shortform_allfit(bp, dp);\n\tif (forkoff)\n\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t \n\n\treturn error;\n}\n\n \nstatic int\nxfs_attr_leaf_shrink(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\tforkoff;\n\tint\t\t\terror;\n\n\tif (!xfs_attr_is_leaf(dp))\n\t\treturn 0;\n\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, 0, &bp);\n\tif (error)\n\t\treturn error;\n\n\tforkoff = xfs_attr_shortform_allfit(bp, dp);\n\tif (forkoff) {\n\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t \n\t} else {\n\t\txfs_trans_brelse(args->trans, bp);\n\t}\n\n\treturn error;\n}\n\n \nint\nxfs_attr_set_iter(\n\tstruct xfs_attr_intent\t\t*attr)\n{\n\tstruct xfs_da_args              *args = attr->xattri_da_args;\n\tint\t\t\t\terror = 0;\n\n\t \nnext_state:\n\tswitch (attr->xattri_dela_state) {\n\tcase XFS_DAS_UNINIT:\n\t\tASSERT(0);\n\t\treturn -EFSCORRUPTED;\n\tcase XFS_DAS_SF_ADD:\n\t\treturn xfs_attr_sf_addname(attr);\n\tcase XFS_DAS_LEAF_ADD:\n\t\treturn xfs_attr_leaf_addname(attr);\n\tcase XFS_DAS_NODE_ADD:\n\t\treturn xfs_attr_node_addname(attr);\n\n\tcase XFS_DAS_SF_REMOVE:\n\t\terror = xfs_attr_sf_removename(args);\n\t\tattr->xattri_dela_state = xfs_attr_complete_op(attr,\n\t\t\t\t\t\txfs_attr_init_add_state(args));\n\t\tbreak;\n\tcase XFS_DAS_LEAF_REMOVE:\n\t\terror = xfs_attr_leaf_removename(args);\n\t\tattr->xattri_dela_state = xfs_attr_complete_op(attr,\n\t\t\t\t\t\txfs_attr_init_add_state(args));\n\t\tbreak;\n\tcase XFS_DAS_NODE_REMOVE:\n\t\terror = xfs_attr_node_removename_setup(attr);\n\t\tif (error == -ENOATTR &&\n\t\t    (args->op_flags & XFS_DA_OP_RECOVERY)) {\n\t\t\tattr->xattri_dela_state = xfs_attr_complete_op(attr,\n\t\t\t\t\t\txfs_attr_init_add_state(args));\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\t\tattr->xattri_dela_state = XFS_DAS_NODE_REMOVE_RMT;\n\t\tif (args->rmtblkno == 0)\n\t\t\tattr->xattri_dela_state++;\n\t\tbreak;\n\n\tcase XFS_DAS_LEAF_SET_RMT:\n\tcase XFS_DAS_NODE_SET_RMT:\n\t\terror = xfs_attr_rmtval_find_space(attr);\n\t\tif (error)\n\t\t\treturn error;\n\t\tattr->xattri_dela_state++;\n\t\tfallthrough;\n\n\tcase XFS_DAS_LEAF_ALLOC_RMT:\n\tcase XFS_DAS_NODE_ALLOC_RMT:\n\t\terror = xfs_attr_rmtval_alloc(attr);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (attr->xattri_dela_state == XFS_DAS_DONE)\n\t\t\tbreak;\n\t\tgoto next_state;\n\n\tcase XFS_DAS_LEAF_REPLACE:\n\tcase XFS_DAS_NODE_REPLACE:\n\t\t \n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\treturn error;\n\t\t \n\t\tattr->xattri_dela_state++;\n\t\tbreak;\n\n\tcase XFS_DAS_LEAF_REMOVE_OLD:\n\tcase XFS_DAS_NODE_REMOVE_OLD:\n\t\t \n\t\txfs_attr_restore_rmt_blk(args);\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_invalidate(args);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tattr->xattri_dela_state++;\n\t\t}\n\n\t\tattr->xattri_dela_state++;\n\t\tgoto next_state;\n\n\tcase XFS_DAS_LEAF_REMOVE_RMT:\n\tcase XFS_DAS_NODE_REMOVE_RMT:\n\t\terror = xfs_attr_rmtval_remove(attr);\n\t\tif (error == -EAGAIN) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tattr->xattri_dela_state++;\n\t\tbreak;\n\n\tcase XFS_DAS_LEAF_REMOVE_ATTR:\n\t\terror = xfs_attr_leaf_remove_attr(attr);\n\t\tattr->xattri_dela_state = xfs_attr_complete_op(attr,\n\t\t\t\t\t\txfs_attr_init_add_state(args));\n\t\tbreak;\n\n\tcase XFS_DAS_NODE_REMOVE_ATTR:\n\t\terror = xfs_attr_node_remove_attr(attr);\n\t\tif (!error)\n\t\t\terror = xfs_attr_leaf_shrink(args);\n\t\tattr->xattri_dela_state = xfs_attr_complete_op(attr,\n\t\t\t\t\t\txfs_attr_init_add_state(args));\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n\n\ttrace_xfs_attr_set_iter_return(attr->xattri_dela_state, args->dp);\n\treturn error;\n}\n\n\n \nstatic int\nxfs_attr_lookup(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_buf\t\t*bp = NULL;\n\tstruct xfs_da_state\t*state;\n\tint\t\t\terror;\n\n\tif (!xfs_inode_hasattr(dp))\n\t\treturn -ENOATTR;\n\n\tif (dp->i_af.if_format == XFS_DINODE_FMT_LOCAL)\n\t\treturn xfs_attr_sf_findname(args, NULL, NULL);\n\n\tif (xfs_attr_is_leaf(dp)) {\n\t\terror = xfs_attr_leaf_hasname(args, &bp);\n\n\t\tif (bp)\n\t\t\txfs_trans_brelse(args->trans, bp);\n\n\t\treturn error;\n\t}\n\n\tstate = xfs_da_state_alloc(args);\n\terror = xfs_attr_node_lookup(args, state);\n\txfs_da_state_free(state);\n\treturn error;\n}\n\nstatic int\nxfs_attr_intent_init(\n\tstruct xfs_da_args\t*args,\n\tunsigned int\t\top_flags,\t \n\tstruct xfs_attr_intent\t**attr)\t\t \n{\n\n\tstruct xfs_attr_intent\t*new;\n\n\tnew = kmem_cache_zalloc(xfs_attr_intent_cache, GFP_NOFS | __GFP_NOFAIL);\n\tnew->xattri_op_flags = op_flags;\n\tnew->xattri_da_args = args;\n\n\t*attr = new;\n\treturn 0;\n}\n\n \nstatic int\nxfs_attr_defer_add(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_intent\t*new;\n\tint\t\t\terror = 0;\n\n\terror = xfs_attr_intent_init(args, XFS_ATTRI_OP_FLAGS_SET, &new);\n\tif (error)\n\t\treturn error;\n\n\tnew->xattri_dela_state = xfs_attr_init_add_state(args);\n\txfs_defer_add(args->trans, XFS_DEFER_OPS_TYPE_ATTR, &new->xattri_list);\n\ttrace_xfs_attr_defer_add(new->xattri_dela_state, args->dp);\n\n\treturn 0;\n}\n\n \nstatic int\nxfs_attr_defer_replace(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_intent\t*new;\n\tint\t\t\terror = 0;\n\n\terror = xfs_attr_intent_init(args, XFS_ATTRI_OP_FLAGS_REPLACE, &new);\n\tif (error)\n\t\treturn error;\n\n\tnew->xattri_dela_state = xfs_attr_init_replace_state(args);\n\txfs_defer_add(args->trans, XFS_DEFER_OPS_TYPE_ATTR, &new->xattri_list);\n\ttrace_xfs_attr_defer_replace(new->xattri_dela_state, args->dp);\n\n\treturn 0;\n}\n\n \nstatic int\nxfs_attr_defer_remove(\n\tstruct xfs_da_args\t*args)\n{\n\n\tstruct xfs_attr_intent\t*new;\n\tint\t\t\terror;\n\n\terror  = xfs_attr_intent_init(args, XFS_ATTRI_OP_FLAGS_REMOVE, &new);\n\tif (error)\n\t\treturn error;\n\n\tnew->xattri_dela_state = xfs_attr_init_remove_state(args);\n\txfs_defer_add(args->trans, XFS_DEFER_OPS_TYPE_ATTR, &new->xattri_list);\n\ttrace_xfs_attr_defer_remove(new->xattri_dela_state, args->dp);\n\n\treturn 0;\n}\n\n \nint\nxfs_attr_set(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_trans_res\ttres;\n\tbool\t\t\trsvd = (args->attr_filter & XFS_ATTR_ROOT);\n\tint\t\t\terror, local;\n\tint\t\t\trmt_blks = 0;\n\tunsigned int\t\ttotal;\n\n\tif (xfs_is_shutdown(dp->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(dp);\n\tif (error)\n\t\treturn error;\n\n\targs->geo = mp->m_attr_geo;\n\targs->whichfork = XFS_ATTR_FORK;\n\targs->hashval = xfs_da_hashname(args->name, args->namelen);\n\n\t \n\targs->op_flags = XFS_DA_OP_OKNOENT |\n\t\t\t\t\t(args->op_flags & XFS_DA_OP_LOGGED);\n\n\tif (args->value) {\n\t\tXFS_STATS_INC(mp, xs_attr_set);\n\t\targs->total = xfs_attr_calc_size(args, &local);\n\n\t\t \n\t\tif (xfs_inode_has_attr_fork(dp) == 0) {\n\t\t\tint sf_size = sizeof(struct xfs_attr_sf_hdr) +\n\t\t\t\txfs_attr_sf_entsize_byname(args->namelen,\n\t\t\t\t\t\targs->valuelen);\n\n\t\t\terror = xfs_bmap_add_attrfork(dp, sf_size, rsvd);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (!local)\n\t\t\trmt_blks = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\t} else {\n\t\tXFS_STATS_INC(mp, xs_attr_remove);\n\t\trmt_blks = xfs_attr3_rmt_blocks(mp, XFS_XATTR_SIZE_MAX);\n\t}\n\n\t \n\txfs_init_attr_trans(args, &tres, &total);\n\terror = xfs_trans_alloc_inode(dp, &tres, total, 0, rsvd, &args->trans);\n\tif (error)\n\t\treturn error;\n\n\tif (args->value || xfs_inode_hasattr(dp)) {\n\t\terror = xfs_iext_count_may_overflow(dp, XFS_ATTR_FORK,\n\t\t\t\tXFS_IEXT_ATTR_MANIP_CNT(rmt_blks));\n\t\tif (error == -EFBIG)\n\t\t\terror = xfs_iext_count_upgrade(args->trans, dp,\n\t\t\t\t\tXFS_IEXT_ATTR_MANIP_CNT(rmt_blks));\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\terror = xfs_attr_lookup(args);\n\tswitch (error) {\n\tcase -EEXIST:\n\t\t \n\t\tif (!args->value) {\n\t\t\terror = xfs_attr_defer_remove(args);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (args->attr_flags & XATTR_CREATE)\n\t\t\tgoto out_trans_cancel;\n\n\t\terror = xfs_attr_defer_replace(args);\n\t\tbreak;\n\tcase -ENOATTR:\n\t\t \n\t\tif (!args->value)\n\t\t\tgoto out_trans_cancel;\n\n\t\t \n\t\tif (args->attr_flags & XATTR_REPLACE)\n\t\t\tgoto out_trans_cancel;\n\n\t\terror = xfs_attr_defer_add(args);\n\t\tbreak;\n\tdefault:\n\t\tgoto out_trans_cancel;\n\t}\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\t \n\tif (xfs_has_wsync(mp))\n\t\txfs_trans_set_sync(args->trans);\n\n\tif (!(args->op_flags & XFS_DA_OP_NOTIME))\n\t\txfs_trans_ichgtime(args->trans, dp, XFS_ICHGTIME_CHG);\n\n\t \n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args->trans);\nout_unlock:\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n\nout_trans_cancel:\n\tif (args->trans)\n\t\txfs_trans_cancel(args->trans);\n\tgoto out_unlock;\n}\n\n \n\nstatic inline int xfs_attr_sf_totsize(struct xfs_inode *dp)\n{\n\tstruct xfs_attr_shortform *sf;\n\n\tsf = (struct xfs_attr_shortform *)dp->i_af.if_u1.if_data;\n\treturn be16_to_cpu(sf->hdr.totsize);\n}\n\n \nstatic int\nxfs_attr_shortform_addname(\n\tstruct xfs_da_args\t*args)\n{\n\tint\t\t\tnewsize, forkoff;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_sf_addname(args);\n\n\terror = xfs_attr_shortform_lookup(args);\n\tswitch (error) {\n\tcase -ENOATTR:\n\t\tif (args->op_flags & XFS_DA_OP_REPLACE)\n\t\t\treturn error;\n\t\tbreak;\n\tcase -EEXIST:\n\t\tif (!(args->op_flags & XFS_DA_OP_REPLACE))\n\t\t\treturn error;\n\n\t\terror = xfs_attr_sf_removename(args);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\targs->op_flags &= ~XFS_DA_OP_REPLACE;\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\treturn error;\n\t}\n\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\n\tnewsize = xfs_attr_sf_totsize(args->dp);\n\tnewsize += xfs_attr_sf_entsize_byname(args->namelen, args->valuelen);\n\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}\n\n\n \n\n \nstatic void\nxfs_attr_save_rmt_blk(\n\tstruct xfs_da_args\t*args)\n{\n\targs->blkno2 = args->blkno;\n\targs->index2 = args->index;\n\targs->rmtblkno2 = args->rmtblkno;\n\targs->rmtblkcnt2 = args->rmtblkcnt;\n\targs->rmtvaluelen2 = args->rmtvaluelen;\n\targs->rmtblkno = 0;\n\targs->rmtblkcnt = 0;\n\targs->rmtvaluelen = 0;\n}\n\n \nstatic void\nxfs_attr_restore_rmt_blk(\n\tstruct xfs_da_args\t*args)\n{\n\targs->blkno = args->blkno2;\n\targs->index = args->index2;\n\targs->rmtblkno = args->rmtblkno2;\n\targs->rmtblkcnt = args->rmtblkcnt2;\n\targs->rmtvaluelen = args->rmtvaluelen2;\n}\n\n \nSTATIC int\nxfs_attr_leaf_try_add(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, 0, &bp);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = xfs_attr3_leaf_lookup_int(bp, args);\n\tswitch (error) {\n\tcase -ENOATTR:\n\t\tif (args->op_flags & XFS_DA_OP_REPLACE)\n\t\t\tgoto out_brelse;\n\t\tbreak;\n\tcase -EEXIST:\n\t\tif (!(args->op_flags & XFS_DA_OP_REPLACE))\n\t\t\tgoto out_brelse;\n\n\t\ttrace_xfs_attr_leaf_replace(args);\n\t\t \n\t\txfs_attr_save_rmt_blk(args);\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tgoto out_brelse;\n\t}\n\n\treturn xfs_attr3_leaf_add(bp, args);\n\nout_brelse:\n\txfs_trans_brelse(args->trans, bp);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_attr_leaf_hasname(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t**bp)\n{\n\tint                     error = 0;\n\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, 0, bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_lookup_int(*bp, args);\n\tif (error != -ENOATTR && error != -EEXIST)\n\t\txfs_trans_brelse(args->trans, *bp);\n\n\treturn error;\n}\n\n \nSTATIC int\nxfs_attr_leaf_removename(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror, forkoff;\n\n\ttrace_xfs_attr_leaf_removename(args);\n\n\t \n\tdp = args->dp;\n\n\terror = xfs_attr_leaf_hasname(args, &bp);\n\tif (error == -ENOATTR) {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\tif (args->op_flags & XFS_DA_OP_RECOVERY)\n\t\t\treturn 0;\n\t\treturn error;\n\t} else if (error != -EEXIST)\n\t\treturn error;\n\n\txfs_attr3_leaf_remove(bp, args);\n\n\t \n\tforkoff = xfs_attr_shortform_allfit(bp, dp);\n\tif (forkoff)\n\t\treturn xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t \n\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_attr_leaf_get(xfs_da_args_t *args)\n{\n\tstruct xfs_buf *bp;\n\tint error;\n\n\ttrace_xfs_attr_leaf_get(args);\n\n\terror = xfs_attr_leaf_hasname(args, &bp);\n\n\tif (error == -ENOATTR)  {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn error;\n\t} else if (error != -EEXIST)\n\t\treturn error;\n\n\n\terror = xfs_attr3_leaf_getvalue(bp, args);\n\txfs_trans_brelse(args->trans, bp);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_attr_node_lookup(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_da_state\t*state)\n{\n\tint\t\t\tretval, error;\n\n\t \n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error)\n\t\treturn error;\n\n\treturn retval;\n}\n\n \n\nSTATIC int\nxfs_attr_node_addname_find_attr(\n\t struct xfs_attr_intent\t*attr)\n{\n\tstruct xfs_da_args\t*args = attr->xattri_da_args;\n\tint\t\t\terror;\n\n\t \n\txfs_attr_item_init_da_state(attr);\n\terror = xfs_attr_node_lookup(args, attr->xattri_da_state);\n\tswitch (error) {\n\tcase -ENOATTR:\n\t\tif (args->op_flags & XFS_DA_OP_REPLACE)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase -EEXIST:\n\t\tif (!(args->op_flags & XFS_DA_OP_REPLACE))\n\t\t\tgoto error;\n\n\n\t\ttrace_xfs_attr_node_replace(args);\n\t\t \n\t\txfs_attr_save_rmt_blk(args);\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tgoto error;\n\t}\n\n\treturn 0;\nerror:\n\tif (attr->xattri_da_state) {\n\t\txfs_da_state_free(attr->xattri_da_state);\n\t\tattr->xattri_da_state = NULL;\n\t}\n\treturn error;\n}\n\n \nstatic int\nxfs_attr_node_try_addname(\n\tstruct xfs_attr_intent\t\t*attr)\n{\n\tstruct xfs_da_state\t\t*state = attr->xattri_da_state;\n\tstruct xfs_da_state_blk\t\t*blk;\n\tint\t\t\t\terror;\n\n\ttrace_xfs_attr_node_addname(state->args);\n\n\tblk = &state->path.blk[state->path.active-1];\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\n\terror = xfs_attr3_leaf_add(blk->bp, state->args);\n\tif (error == -ENOSPC) {\n\t\tif (state->path.active == 1) {\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\terror = xfs_da3_split(state);\n\t\tif (error)\n\t\t\tgoto out;\n\t} else {\n\t\t \n\t\txfs_da3_fixhashpath(state, &state->path);\n\t}\n\nout:\n\txfs_da_state_free(state);\n\tattr->xattri_da_state = NULL;\n\treturn error;\n}\n\nstatic int\nxfs_attr_node_removename(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_da_state\t*state)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tint\t\t\tretval;\n\n\t \n\tblk = &state->path.blk[state->path.active-1];\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tretval = xfs_attr3_leaf_remove(blk->bp, args);\n\txfs_da3_fixhashpath(state, &state->path);\n\n\treturn retval;\n}\n\nstatic int\nxfs_attr_node_remove_attr(\n\tstruct xfs_attr_intent\t\t*attr)\n{\n\tstruct xfs_da_args\t\t*args = attr->xattri_da_args;\n\tstruct xfs_da_state\t\t*state = xfs_da_state_alloc(args);\n\tint\t\t\t\tretval = 0;\n\tint\t\t\t\terror = 0;\n\n\t \n\targs->attr_filter |= XFS_ATTR_INCOMPLETE;\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_attr_node_removename(args, state);\n\n\t \n\tif (retval && (state->path.active > 1)) {\n\t\terror = xfs_da3_join(state);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tretval = error = 0;\n\nout:\n\txfs_da_state_free(state);\n\tif (error)\n\t\treturn error;\n\treturn retval;\n}\n\n \nSTATIC int\nxfs_attr_node_get(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_da_state\t*state;\n\tstruct xfs_da_state_blk\t*blk;\n\tint\t\t\ti;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_node_get(args);\n\n\t \n\tstate = xfs_da_state_alloc(args);\n\terror = xfs_attr_node_lookup(args, state);\n\tif (error != -EEXIST)\n\t\tgoto out_release;\n\n\t \n\tblk = &state->path.blk[state->path.active - 1];\n\terror = xfs_attr3_leaf_getvalue(blk->bp, args);\n\n\t \nout_release:\n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\n\txfs_da_state_free(state);\n\treturn error;\n}\n\n \nbool\nxfs_attr_namecheck(\n\tconst void\t*name,\n\tsize_t\t\tlength)\n{\n\t \n\tif (length >= MAXNAMELEN)\n\t\treturn false;\n\n\t \n\treturn !memchr(name, 0, length);\n}\n\nint __init\nxfs_attr_intent_init_cache(void)\n{\n\txfs_attr_intent_cache = kmem_cache_create(\"xfs_attr_intent\",\n\t\t\tsizeof(struct xfs_attr_intent),\n\t\t\t0, 0, NULL);\n\n\treturn xfs_attr_intent_cache != NULL ? 0 : -ENOMEM;\n}\n\nvoid\nxfs_attr_intent_destroy_cache(void)\n{\n\tkmem_cache_destroy(xfs_attr_intent_cache);\n\txfs_attr_intent_cache = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}