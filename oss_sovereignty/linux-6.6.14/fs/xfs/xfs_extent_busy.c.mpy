{
  "module_name": "xfs_extent_busy.c",
  "hash_id": "206350688de341da35f95ba6a8b4fd695dea62c6a100fdccf9b20df05cbc5f0b",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_extent_busy.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_log.h\"\n#include \"xfs_ag.h\"\n\nstatic void\nxfs_extent_busy_insert_list(\n\tstruct xfs_perag\t*pag,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\tunsigned int\t\tflags,\n\tstruct list_head\t*busy_list)\n{\n\tstruct xfs_extent_busy\t*new;\n\tstruct xfs_extent_busy\t*busyp;\n\tstruct rb_node\t\t**rbp;\n\tstruct rb_node\t\t*parent = NULL;\n\n\tnew = kmem_zalloc(sizeof(struct xfs_extent_busy), 0);\n\tnew->agno = pag->pag_agno;\n\tnew->bno = bno;\n\tnew->length = len;\n\tINIT_LIST_HEAD(&new->list);\n\tnew->flags = flags;\n\n\t \n\ttrace_xfs_extent_busy(pag->pag_mount, pag->pag_agno, bno, len);\n\n\tspin_lock(&pag->pagb_lock);\n\trbp = &pag->pagb_tree.rb_node;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbusyp = rb_entry(parent, struct xfs_extent_busy, rb_node);\n\n\t\tif (new->bno < busyp->bno) {\n\t\t\trbp = &(*rbp)->rb_left;\n\t\t\tASSERT(new->bno + new->length <= busyp->bno);\n\t\t} else if (new->bno > busyp->bno) {\n\t\t\trbp = &(*rbp)->rb_right;\n\t\t\tASSERT(bno >= busyp->bno + busyp->length);\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t}\n\t}\n\n\trb_link_node(&new->rb_node, parent, rbp);\n\trb_insert_color(&new->rb_node, &pag->pagb_tree);\n\n\t \n\tlist_add_tail(&new->list, busy_list);\n\tspin_unlock(&pag->pagb_lock);\n}\n\nvoid\nxfs_extent_busy_insert(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_perag\t*pag,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\tunsigned int\t\tflags)\n{\n\txfs_extent_busy_insert_list(pag, bno, len, flags, &tp->t_busy);\n}\n\nvoid\nxfs_extent_busy_insert_discard(\n\tstruct xfs_perag\t*pag,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\tstruct list_head\t*busy_list)\n{\n\txfs_extent_busy_insert_list(pag, bno, len, XFS_EXTENT_BUSY_DISCARDED,\n\t\t\tbusy_list);\n}\n\n \nint\nxfs_extent_busy_search(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen)\n{\n\tstruct rb_node\t\t*rbp;\n\tstruct xfs_extent_busy\t*busyp;\n\tint\t\t\tmatch = 0;\n\n\t \n\tspin_lock(&pag->pagb_lock);\n\trbp = pag->pagb_tree.rb_node;\n\twhile (rbp) {\n\t\tbusyp = rb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\tif (bno < busyp->bno) {\n\t\t\t \n\t\t\tif (bno + len > busyp->bno)\n\t\t\t\tmatch = -1;\n\t\t\trbp = rbp->rb_left;\n\t\t} else if (bno > busyp->bno) {\n\t\t\t \n\t\t\tif (bno < busyp->bno + busyp->length)\n\t\t\t\tmatch = -1;\n\t\t\trbp = rbp->rb_right;\n\t\t} else {\n\t\t\t \n\t\t\tmatch = (busyp->length == len) ? 1 : -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&pag->pagb_lock);\n\treturn match;\n}\n\n \nSTATIC bool\nxfs_extent_busy_update_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_extent_busy\t*busyp,\n\txfs_agblock_t\t\tfbno,\n\txfs_extlen_t\t\tflen,\n\tbool\t\t\tuserdata) __releases(&pag->pagb_lock)\n\t\t\t\t\t  __acquires(&pag->pagb_lock)\n{\n\txfs_agblock_t\t\tfend = fbno + flen;\n\txfs_agblock_t\t\tbbno = busyp->bno;\n\txfs_agblock_t\t\tbend = bbno + busyp->length;\n\n\t \n\tif (busyp->flags & XFS_EXTENT_BUSY_DISCARDED) {\n\t\tspin_unlock(&pag->pagb_lock);\n\t\tdelay(1);\n\t\tspin_lock(&pag->pagb_lock);\n\t\treturn false;\n\t}\n\n\t \n\tif (userdata)\n\t\tgoto out_force_log;\n\n\tif (bbno < fbno && bend > fend) {\n\t\t \n\n\t\t \n\t\tgoto out_force_log;\n\t} else if (bbno >= fbno && bend <= fend) {\n\t\t \n\n\t\t \n\t\trb_erase(&busyp->rb_node, &pag->pagb_tree);\n\t\tbusyp->length = 0;\n\t\treturn false;\n\t} else if (fend < bend) {\n\t\t \n\t\tbusyp->bno = fend;\n\t\tbusyp->length = bend - fend;\n\t} else if (bbno < fbno) {\n\t\t \n\t\tbusyp->length = fbno - busyp->bno;\n\t} else {\n\t\tASSERT(0);\n\t}\n\n\ttrace_xfs_extent_busy_reuse(mp, pag->pag_agno, fbno, flen);\n\treturn true;\n\nout_force_log:\n\tspin_unlock(&pag->pagb_lock);\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\ttrace_xfs_extent_busy_force(mp, pag->pag_agno, fbno, flen);\n\tspin_lock(&pag->pagb_lock);\n\treturn false;\n}\n\n\n \nvoid\nxfs_extent_busy_reuse(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_agblock_t\t\tfbno,\n\txfs_extlen_t\t\tflen,\n\tbool\t\t\tuserdata)\n{\n\tstruct rb_node\t\t*rbp;\n\n\tASSERT(flen > 0);\n\tspin_lock(&pag->pagb_lock);\nrestart:\n\trbp = pag->pagb_tree.rb_node;\n\twhile (rbp) {\n\t\tstruct xfs_extent_busy *busyp =\n\t\t\trb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\txfs_agblock_t\tbbno = busyp->bno;\n\t\txfs_agblock_t\tbend = bbno + busyp->length;\n\n\t\tif (fbno + flen <= bbno) {\n\t\t\trbp = rbp->rb_left;\n\t\t\tcontinue;\n\t\t} else if (fbno >= bend) {\n\t\t\trbp = rbp->rb_right;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!xfs_extent_busy_update_extent(mp, pag, busyp, fbno, flen,\n\t\t\t\t\t\t  userdata))\n\t\t\tgoto restart;\n\t}\n\tspin_unlock(&pag->pagb_lock);\n}\n\n \nbool\nxfs_extent_busy_trim(\n\tstruct xfs_alloc_arg\t*args,\n\txfs_agblock_t\t\t*bno,\n\txfs_extlen_t\t\t*len,\n\tunsigned\t\t*busy_gen)\n{\n\txfs_agblock_t\t\tfbno;\n\txfs_extlen_t\t\tflen;\n\tstruct rb_node\t\t*rbp;\n\tbool\t\t\tret = false;\n\n\tASSERT(*len > 0);\n\n\tspin_lock(&args->pag->pagb_lock);\n\tfbno = *bno;\n\tflen = *len;\n\trbp = args->pag->pagb_tree.rb_node;\n\twhile (rbp && flen >= args->minlen) {\n\t\tstruct xfs_extent_busy *busyp =\n\t\t\trb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\txfs_agblock_t\tfend = fbno + flen;\n\t\txfs_agblock_t\tbbno = busyp->bno;\n\t\txfs_agblock_t\tbend = bbno + busyp->length;\n\n\t\tif (fend <= bbno) {\n\t\t\trbp = rbp->rb_left;\n\t\t\tcontinue;\n\t\t} else if (fbno >= bend) {\n\t\t\trbp = rbp->rb_right;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (bbno <= fbno) {\n\t\t\t \n\n\t\t\t \n\t\t\tif (fend <= bend)\n\t\t\t\tgoto fail;\n\n\t\t\t \n\t\t\tfbno = bend;\n\t\t} else if (bend >= fend) {\n\t\t\t \n\n\t\t\t \n\t\t\tfend = bbno;\n\t\t} else {\n\t\t\t \n\n\t\t\t \n\t\t\tif (bbno - fbno >= args->maxlen) {\n\t\t\t\t \n\t\t\t\tfend = bbno;\n\t\t\t} else if (fend - bend >= args->maxlen * 4) {\n\t\t\t\t \n\t\t\t\tfbno = bend;\n\t\t\t} else if (bbno - fbno >= args->minlen) {\n\t\t\t\t \n\t\t\t\tfend = bbno;\n\t\t\t} else {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\tflen = fend - fbno;\n\t}\nout:\n\n\tif (fbno != *bno || flen != *len) {\n\t\ttrace_xfs_extent_busy_trim(args->mp, args->agno, *bno, *len,\n\t\t\t\t\t  fbno, flen);\n\t\t*bno = fbno;\n\t\t*len = flen;\n\t\t*busy_gen = args->pag->pagb_gen;\n\t\tret = true;\n\t}\n\tspin_unlock(&args->pag->pagb_lock);\n\treturn ret;\nfail:\n\t \n\tflen = 0;\n\tgoto out;\n}\n\nSTATIC void\nxfs_extent_busy_clear_one(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_extent_busy\t*busyp)\n{\n\tif (busyp->length) {\n\t\ttrace_xfs_extent_busy_clear(mp, busyp->agno, busyp->bno,\n\t\t\t\t\t\tbusyp->length);\n\t\trb_erase(&busyp->rb_node, &pag->pagb_tree);\n\t}\n\n\tlist_del_init(&busyp->list);\n\tkmem_free(busyp);\n}\n\nstatic void\nxfs_extent_busy_put_pag(\n\tstruct xfs_perag\t*pag,\n\tbool\t\t\twakeup)\n\t\t__releases(pag->pagb_lock)\n{\n\tif (wakeup) {\n\t\tpag->pagb_gen++;\n\t\twake_up_all(&pag->pagb_wait);\n\t}\n\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n}\n\n \nvoid\nxfs_extent_busy_clear(\n\tstruct xfs_mount\t*mp,\n\tstruct list_head\t*list,\n\tbool\t\t\tdo_discard)\n{\n\tstruct xfs_extent_busy\t*busyp, *n;\n\tstruct xfs_perag\t*pag = NULL;\n\txfs_agnumber_t\t\tagno = NULLAGNUMBER;\n\tbool\t\t\twakeup = false;\n\n\tlist_for_each_entry_safe(busyp, n, list, list) {\n\t\tif (busyp->agno != agno) {\n\t\t\tif (pag)\n\t\t\t\txfs_extent_busy_put_pag(pag, wakeup);\n\t\t\tagno = busyp->agno;\n\t\t\tpag = xfs_perag_get(mp, agno);\n\t\t\tspin_lock(&pag->pagb_lock);\n\t\t\twakeup = false;\n\t\t}\n\n\t\tif (do_discard && busyp->length &&\n\t\t    !(busyp->flags & XFS_EXTENT_BUSY_SKIP_DISCARD)) {\n\t\t\tbusyp->flags = XFS_EXTENT_BUSY_DISCARDED;\n\t\t} else {\n\t\t\txfs_extent_busy_clear_one(mp, pag, busyp);\n\t\t\twakeup = true;\n\t\t}\n\t}\n\n\tif (pag)\n\t\txfs_extent_busy_put_pag(pag, wakeup);\n}\n\n \nint\nxfs_extent_busy_flush(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_perag\t*pag,\n\tunsigned\t\tbusy_gen,\n\tuint32_t\t\talloc_flags)\n{\n\tDEFINE_WAIT\t\t(wait);\n\tint\t\t\terror;\n\n\terror = xfs_log_force(tp->t_mountp, XFS_LOG_SYNC);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (!list_empty(&tp->t_busy)) {\n\t\tif (alloc_flags & XFS_ALLOC_FLAG_TRYFLUSH)\n\t\t\treturn 0;\n\n\t\tif (busy_gen != READ_ONCE(pag->pagb_gen))\n\t\t\treturn 0;\n\n\t\tif (alloc_flags & XFS_ALLOC_FLAG_FREEING)\n\t\t\treturn -EAGAIN;\n\t}\n\n\t \n\tdo {\n\t\tprepare_to_wait(&pag->pagb_wait, &wait, TASK_KILLABLE);\n\t\tif  (busy_gen != READ_ONCE(pag->pagb_gen))\n\t\t\tbreak;\n\t\tschedule();\n\t} while (1);\n\n\tfinish_wait(&pag->pagb_wait, &wait);\n\treturn 0;\n}\n\nvoid\nxfs_extent_busy_wait_all(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_perag\t*pag;\n\tDEFINE_WAIT\t\t(wait);\n\txfs_agnumber_t\t\tagno;\n\n\tfor_each_perag(mp, agno, pag) {\n\t\tdo {\n\t\t\tprepare_to_wait(&pag->pagb_wait, &wait, TASK_KILLABLE);\n\t\t\tif  (RB_EMPTY_ROOT(&pag->pagb_tree))\n\t\t\t\tbreak;\n\t\t\tschedule();\n\t\t} while (1);\n\t\tfinish_wait(&pag->pagb_wait, &wait);\n\t}\n}\n\n \nint\nxfs_extent_busy_ag_cmp(\n\tvoid\t\t\t*priv,\n\tconst struct list_head\t*l1,\n\tconst struct list_head\t*l2)\n{\n\tstruct xfs_extent_busy\t*b1 =\n\t\tcontainer_of(l1, struct xfs_extent_busy, list);\n\tstruct xfs_extent_busy\t*b2 =\n\t\tcontainer_of(l2, struct xfs_extent_busy, list);\n\ts32 diff;\n\n\tdiff = b1->agno - b2->agno;\n\tif (!diff)\n\t\tdiff = b1->bno - b2->bno;\n\treturn diff;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}