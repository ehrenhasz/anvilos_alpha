{
  "module_name": "xfs_fsmap.c",
  "hash_id": "e7d4abe849296d9b93e55a30a2cdc14875adb98316808485bd22e7fda541d59e",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_fsmap.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_rmap_btree.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bit.h\"\n#include <linux/fsmap.h>\n#include \"xfs_fsmap.h\"\n#include \"xfs_refcount.h\"\n#include \"xfs_refcount_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_ag.h\"\n\n \nstatic void\nxfs_fsmap_from_internal(\n\tstruct fsmap\t\t*dest,\n\tstruct xfs_fsmap\t*src)\n{\n\tdest->fmr_device = src->fmr_device;\n\tdest->fmr_flags = src->fmr_flags;\n\tdest->fmr_physical = BBTOB(src->fmr_physical);\n\tdest->fmr_owner = src->fmr_owner;\n\tdest->fmr_offset = BBTOB(src->fmr_offset);\n\tdest->fmr_length = BBTOB(src->fmr_length);\n\tdest->fmr_reserved[0] = 0;\n\tdest->fmr_reserved[1] = 0;\n\tdest->fmr_reserved[2] = 0;\n}\n\n \nvoid\nxfs_fsmap_to_internal(\n\tstruct xfs_fsmap\t*dest,\n\tstruct fsmap\t\t*src)\n{\n\tdest->fmr_device = src->fmr_device;\n\tdest->fmr_flags = src->fmr_flags;\n\tdest->fmr_physical = BTOBBT(src->fmr_physical);\n\tdest->fmr_owner = src->fmr_owner;\n\tdest->fmr_offset = BTOBBT(src->fmr_offset);\n\tdest->fmr_length = BTOBBT(src->fmr_length);\n}\n\n \nstatic int\nxfs_fsmap_owner_to_rmap(\n\tstruct xfs_rmap_irec\t*dest,\n\tconst struct xfs_fsmap\t*src)\n{\n\tif (!(src->fmr_flags & FMR_OF_SPECIAL_OWNER)) {\n\t\tdest->rm_owner = src->fmr_owner;\n\t\treturn 0;\n\t}\n\n\tswitch (src->fmr_owner) {\n\tcase 0:\t\t\t \n\tcase -1ULL:\t\t \n\t\tdest->rm_owner = 0;\n\t\tbreak;\n\tcase XFS_FMR_OWN_FREE:\n\t\tdest->rm_owner = XFS_RMAP_OWN_NULL;\n\t\tbreak;\n\tcase XFS_FMR_OWN_UNKNOWN:\n\t\tdest->rm_owner = XFS_RMAP_OWN_UNKNOWN;\n\t\tbreak;\n\tcase XFS_FMR_OWN_FS:\n\t\tdest->rm_owner = XFS_RMAP_OWN_FS;\n\t\tbreak;\n\tcase XFS_FMR_OWN_LOG:\n\t\tdest->rm_owner = XFS_RMAP_OWN_LOG;\n\t\tbreak;\n\tcase XFS_FMR_OWN_AG:\n\t\tdest->rm_owner = XFS_RMAP_OWN_AG;\n\t\tbreak;\n\tcase XFS_FMR_OWN_INOBT:\n\t\tdest->rm_owner = XFS_RMAP_OWN_INOBT;\n\t\tbreak;\n\tcase XFS_FMR_OWN_INODES:\n\t\tdest->rm_owner = XFS_RMAP_OWN_INODES;\n\t\tbreak;\n\tcase XFS_FMR_OWN_REFC:\n\t\tdest->rm_owner = XFS_RMAP_OWN_REFC;\n\t\tbreak;\n\tcase XFS_FMR_OWN_COW:\n\t\tdest->rm_owner = XFS_RMAP_OWN_COW;\n\t\tbreak;\n\tcase XFS_FMR_OWN_DEFECTIVE:\t \n\t\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nxfs_fsmap_owner_from_rmap(\n\tstruct xfs_fsmap\t\t*dest,\n\tconst struct xfs_rmap_irec\t*src)\n{\n\tdest->fmr_flags = 0;\n\tif (!XFS_RMAP_NON_INODE_OWNER(src->rm_owner)) {\n\t\tdest->fmr_owner = src->rm_owner;\n\t\treturn 0;\n\t}\n\tdest->fmr_flags |= FMR_OF_SPECIAL_OWNER;\n\n\tswitch (src->rm_owner) {\n\tcase XFS_RMAP_OWN_FS:\n\t\tdest->fmr_owner = XFS_FMR_OWN_FS;\n\t\tbreak;\n\tcase XFS_RMAP_OWN_LOG:\n\t\tdest->fmr_owner = XFS_FMR_OWN_LOG;\n\t\tbreak;\n\tcase XFS_RMAP_OWN_AG:\n\t\tdest->fmr_owner = XFS_FMR_OWN_AG;\n\t\tbreak;\n\tcase XFS_RMAP_OWN_INOBT:\n\t\tdest->fmr_owner = XFS_FMR_OWN_INOBT;\n\t\tbreak;\n\tcase XFS_RMAP_OWN_INODES:\n\t\tdest->fmr_owner = XFS_FMR_OWN_INODES;\n\t\tbreak;\n\tcase XFS_RMAP_OWN_REFC:\n\t\tdest->fmr_owner = XFS_FMR_OWN_REFC;\n\t\tbreak;\n\tcase XFS_RMAP_OWN_COW:\n\t\tdest->fmr_owner = XFS_FMR_OWN_COW;\n\t\tbreak;\n\tcase XFS_RMAP_OWN_NULL:\t \n\t\tdest->fmr_owner = XFS_FMR_OWN_FREE;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}\n\n \nstruct xfs_getfsmap_info {\n\tstruct xfs_fsmap_head\t*head;\n\tstruct fsmap\t\t*fsmap_recs;\t \n\tstruct xfs_buf\t\t*agf_bp;\t \n\tstruct xfs_perag\t*pag;\t\t \n\txfs_daddr_t\t\tnext_daddr;\t \n\t \n\txfs_daddr_t\t\tlow_daddr;\n\tu64\t\t\tmissing_owner;\t \n\tu32\t\t\tdev;\t\t \n\t \n\tstruct xfs_rmap_irec\tlow;\n\tstruct xfs_rmap_irec\thigh;\t\t \n\tbool\t\t\tlast;\t\t \n};\n\n \nstruct xfs_getfsmap_dev {\n\tu32\t\t\tdev;\n\tint\t\t\t(*fn)(struct xfs_trans *tp,\n\t\t\t\t      const struct xfs_fsmap *keys,\n\t\t\t\t      struct xfs_getfsmap_info *info);\n};\n\n \nstatic int\nxfs_getfsmap_dev_compare(\n\tconst void\t\t\t*p1,\n\tconst void\t\t\t*p2)\n{\n\tconst struct xfs_getfsmap_dev\t*d1 = p1;\n\tconst struct xfs_getfsmap_dev\t*d2 = p2;\n\n\treturn d1->dev - d2->dev;\n}\n\n \nSTATIC int\nxfs_getfsmap_is_shared(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_getfsmap_info\t*info,\n\tconst struct xfs_rmap_irec\t*rec,\n\tbool\t\t\t\t*stat)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_btree_cur\t\t*cur;\n\txfs_agblock_t\t\t\tfbno;\n\txfs_extlen_t\t\t\tflen;\n\tint\t\t\t\terror;\n\n\t*stat = false;\n\tif (!xfs_has_reflink(mp))\n\t\treturn 0;\n\t \n\tif (!info->pag)\n\t\treturn 0;\n\n\t \n\tflen = 0;\n\tcur = xfs_refcountbt_init_cursor(mp, tp, info->agf_bp, info->pag);\n\n\terror = xfs_refcount_find_shared(cur, rec->rm_startblock,\n\t\t\trec->rm_blockcount, &fbno, &flen, false);\n\n\txfs_btree_del_cursor(cur, error);\n\tif (error)\n\t\treturn error;\n\n\t*stat = flen > 0;\n\treturn 0;\n}\n\nstatic inline void\nxfs_getfsmap_format(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_fsmap\t\t*xfm,\n\tstruct xfs_getfsmap_info\t*info)\n{\n\tstruct fsmap\t\t\t*rec;\n\n\ttrace_xfs_getfsmap_mapping(mp, xfm);\n\n\trec = &info->fsmap_recs[info->head->fmh_entries++];\n\txfs_fsmap_from_internal(rec, xfm);\n}\n\nstatic inline bool\nxfs_getfsmap_rec_before_start(\n\tstruct xfs_getfsmap_info\t*info,\n\tconst struct xfs_rmap_irec\t*rec,\n\txfs_daddr_t\t\t\trec_daddr)\n{\n\tif (info->low_daddr != -1ULL)\n\t\treturn rec_daddr < info->low_daddr;\n\tif (info->low.rm_blockcount)\n\t\treturn xfs_rmap_compare(rec, &info->low) < 0;\n\treturn false;\n}\n\n \nSTATIC int\nxfs_getfsmap_helper(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_getfsmap_info\t*info,\n\tconst struct xfs_rmap_irec\t*rec,\n\txfs_daddr_t\t\t\trec_daddr,\n\txfs_daddr_t\t\t\tlen_daddr)\n{\n\tstruct xfs_fsmap\t\tfmr;\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tbool\t\t\t\tshared;\n\tint\t\t\t\terror;\n\n\tif (fatal_signal_pending(current))\n\t\treturn -EINTR;\n\n\tif (len_daddr == 0)\n\t\tlen_daddr = XFS_FSB_TO_BB(mp, rec->rm_blockcount);\n\n\t \n\tif (xfs_getfsmap_rec_before_start(info, rec, rec_daddr)) {\n\t\trec_daddr += len_daddr;\n\t\tif (info->next_daddr < rec_daddr)\n\t\t\tinfo->next_daddr = rec_daddr;\n\t\treturn 0;\n\t}\n\n\t \n\tif (info->head->fmh_count == 0) {\n\t\tif (info->head->fmh_entries == UINT_MAX)\n\t\t\treturn -ECANCELED;\n\n\t\tif (rec_daddr > info->next_daddr)\n\t\t\tinfo->head->fmh_entries++;\n\n\t\tif (info->last)\n\t\t\treturn 0;\n\n\t\tinfo->head->fmh_entries++;\n\n\t\trec_daddr += len_daddr;\n\t\tif (info->next_daddr < rec_daddr)\n\t\t\tinfo->next_daddr = rec_daddr;\n\t\treturn 0;\n\t}\n\n\t \n\tif (rec_daddr > info->next_daddr) {\n\t\tif (info->head->fmh_entries >= info->head->fmh_count)\n\t\t\treturn -ECANCELED;\n\n\t\tfmr.fmr_device = info->dev;\n\t\tfmr.fmr_physical = info->next_daddr;\n\t\tfmr.fmr_owner = info->missing_owner;\n\t\tfmr.fmr_offset = 0;\n\t\tfmr.fmr_length = rec_daddr - info->next_daddr;\n\t\tfmr.fmr_flags = FMR_OF_SPECIAL_OWNER;\n\t\txfs_getfsmap_format(mp, &fmr, info);\n\t}\n\n\tif (info->last)\n\t\tgoto out;\n\n\t \n\tif (info->head->fmh_entries >= info->head->fmh_count)\n\t\treturn -ECANCELED;\n\n\ttrace_xfs_fsmap_mapping(mp, info->dev,\n\t\t\tinfo->pag ? info->pag->pag_agno : NULLAGNUMBER, rec);\n\n\tfmr.fmr_device = info->dev;\n\tfmr.fmr_physical = rec_daddr;\n\terror = xfs_fsmap_owner_from_rmap(&fmr, rec);\n\tif (error)\n\t\treturn error;\n\tfmr.fmr_offset = XFS_FSB_TO_BB(mp, rec->rm_offset);\n\tfmr.fmr_length = len_daddr;\n\tif (rec->rm_flags & XFS_RMAP_UNWRITTEN)\n\t\tfmr.fmr_flags |= FMR_OF_PREALLOC;\n\tif (rec->rm_flags & XFS_RMAP_ATTR_FORK)\n\t\tfmr.fmr_flags |= FMR_OF_ATTR_FORK;\n\tif (rec->rm_flags & XFS_RMAP_BMBT_BLOCK)\n\t\tfmr.fmr_flags |= FMR_OF_EXTENT_MAP;\n\tif (fmr.fmr_flags == 0) {\n\t\terror = xfs_getfsmap_is_shared(tp, info, rec, &shared);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (shared)\n\t\t\tfmr.fmr_flags |= FMR_OF_SHARED;\n\t}\n\n\txfs_getfsmap_format(mp, &fmr, info);\nout:\n\trec_daddr += len_daddr;\n\tif (info->next_daddr < rec_daddr)\n\t\tinfo->next_daddr = rec_daddr;\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_getfsmap_datadev_helper(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst struct xfs_rmap_irec\t*rec,\n\tvoid\t\t\t\t*priv)\n{\n\tstruct xfs_mount\t\t*mp = cur->bc_mp;\n\tstruct xfs_getfsmap_info\t*info = priv;\n\txfs_fsblock_t\t\t\tfsb;\n\txfs_daddr_t\t\t\trec_daddr;\n\n\tfsb = XFS_AGB_TO_FSB(mp, cur->bc_ag.pag->pag_agno, rec->rm_startblock);\n\trec_daddr = XFS_FSB_TO_DADDR(mp, fsb);\n\n\treturn xfs_getfsmap_helper(cur->bc_tp, info, rec, rec_daddr, 0);\n}\n\n \nSTATIC int\nxfs_getfsmap_datadev_bnobt_helper(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst struct xfs_alloc_rec_incore *rec,\n\tvoid\t\t\t\t*priv)\n{\n\tstruct xfs_mount\t\t*mp = cur->bc_mp;\n\tstruct xfs_getfsmap_info\t*info = priv;\n\tstruct xfs_rmap_irec\t\tirec;\n\txfs_daddr_t\t\t\trec_daddr;\n\n\trec_daddr = XFS_AGB_TO_DADDR(mp, cur->bc_ag.pag->pag_agno,\n\t\t\trec->ar_startblock);\n\n\tirec.rm_startblock = rec->ar_startblock;\n\tirec.rm_blockcount = rec->ar_blockcount;\n\tirec.rm_owner = XFS_RMAP_OWN_NULL;\t \n\tirec.rm_offset = 0;\n\tirec.rm_flags = 0;\n\n\treturn xfs_getfsmap_helper(cur->bc_tp, info, &irec, rec_daddr, 0);\n}\n\n \nstatic void\nxfs_getfsmap_set_irec_flags(\n\tstruct xfs_rmap_irec\t*irec,\n\tconst struct xfs_fsmap\t*fmr)\n{\n\tirec->rm_flags = 0;\n\tif (fmr->fmr_flags & FMR_OF_ATTR_FORK)\n\t\tirec->rm_flags |= XFS_RMAP_ATTR_FORK;\n\tif (fmr->fmr_flags & FMR_OF_EXTENT_MAP)\n\t\tirec->rm_flags |= XFS_RMAP_BMBT_BLOCK;\n\tif (fmr->fmr_flags & FMR_OF_PREALLOC)\n\t\tirec->rm_flags |= XFS_RMAP_UNWRITTEN;\n}\n\n \nSTATIC int\nxfs_getfsmap_logdev(\n\tstruct xfs_trans\t\t*tp,\n\tconst struct xfs_fsmap\t\t*keys,\n\tstruct xfs_getfsmap_info\t*info)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_rmap_irec\t\trmap;\n\txfs_daddr_t\t\t\trec_daddr, len_daddr;\n\txfs_fsblock_t\t\t\tstart_fsb, end_fsb;\n\tuint64_t\t\t\teofs;\n\n\teofs = XFS_FSB_TO_BB(mp, mp->m_sb.sb_logblocks);\n\tif (keys[0].fmr_physical >= eofs)\n\t\treturn 0;\n\tstart_fsb = XFS_BB_TO_FSBT(mp,\n\t\t\t\tkeys[0].fmr_physical + keys[0].fmr_length);\n\tend_fsb = XFS_BB_TO_FSB(mp, min(eofs - 1, keys[1].fmr_physical));\n\n\t \n\tif (keys[0].fmr_length > 0)\n\t\tinfo->low_daddr = XFS_FSB_TO_BB(mp, start_fsb);\n\n\ttrace_xfs_fsmap_low_key_linear(mp, info->dev, start_fsb);\n\ttrace_xfs_fsmap_high_key_linear(mp, info->dev, end_fsb);\n\n\tif (start_fsb > 0)\n\t\treturn 0;\n\n\t \n\trmap.rm_startblock = 0;\n\trmap.rm_blockcount = mp->m_sb.sb_logblocks;\n\trmap.rm_owner = XFS_RMAP_OWN_LOG;\n\trmap.rm_offset = 0;\n\trmap.rm_flags = 0;\n\n\trec_daddr = XFS_FSB_TO_BB(mp, rmap.rm_startblock);\n\tlen_daddr = XFS_FSB_TO_BB(mp, rmap.rm_blockcount);\n\treturn xfs_getfsmap_helper(tp, info, &rmap, rec_daddr, len_daddr);\n}\n\n#ifdef CONFIG_XFS_RT\n \nSTATIC int\nxfs_getfsmap_rtdev_rtbitmap_helper(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_trans\t\t*tp,\n\tconst struct xfs_rtalloc_rec\t*rec,\n\tvoid\t\t\t\t*priv)\n{\n\tstruct xfs_getfsmap_info\t*info = priv;\n\tstruct xfs_rmap_irec\t\tirec;\n\txfs_rtblock_t\t\t\trtbno;\n\txfs_daddr_t\t\t\trec_daddr, len_daddr;\n\n\trtbno = rec->ar_startext * mp->m_sb.sb_rextsize;\n\trec_daddr = XFS_FSB_TO_BB(mp, rtbno);\n\tirec.rm_startblock = rtbno;\n\n\trtbno = rec->ar_extcount * mp->m_sb.sb_rextsize;\n\tlen_daddr = XFS_FSB_TO_BB(mp, rtbno);\n\tirec.rm_blockcount = rtbno;\n\n\tirec.rm_owner = XFS_RMAP_OWN_NULL;\t \n\tirec.rm_offset = 0;\n\tirec.rm_flags = 0;\n\n\treturn xfs_getfsmap_helper(tp, info, &irec, rec_daddr, len_daddr);\n}\n\n \nSTATIC int\nxfs_getfsmap_rtdev_rtbitmap(\n\tstruct xfs_trans\t\t*tp,\n\tconst struct xfs_fsmap\t\t*keys,\n\tstruct xfs_getfsmap_info\t*info)\n{\n\n\tstruct xfs_rtalloc_rec\t\talow = { 0 };\n\tstruct xfs_rtalloc_rec\t\tahigh = { 0 };\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\txfs_rtblock_t\t\t\tstart_rtb;\n\txfs_rtblock_t\t\t\tend_rtb;\n\tuint64_t\t\t\teofs;\n\tint\t\t\t\terror;\n\n\teofs = XFS_FSB_TO_BB(mp, mp->m_sb.sb_rextents * mp->m_sb.sb_rextsize);\n\tif (keys[0].fmr_physical >= eofs)\n\t\treturn 0;\n\tstart_rtb = XFS_BB_TO_FSBT(mp,\n\t\t\t\tkeys[0].fmr_physical + keys[0].fmr_length);\n\tend_rtb = XFS_BB_TO_FSB(mp, min(eofs - 1, keys[1].fmr_physical));\n\n\tinfo->missing_owner = XFS_FMR_OWN_UNKNOWN;\n\n\t \n\tif (keys[0].fmr_length > 0) {\n\t\tinfo->low_daddr = XFS_FSB_TO_BB(mp, start_rtb);\n\t\tif (info->low_daddr >= eofs)\n\t\t\treturn 0;\n\t}\n\n\ttrace_xfs_fsmap_low_key_linear(mp, info->dev, start_rtb);\n\ttrace_xfs_fsmap_high_key_linear(mp, info->dev, end_rtb);\n\n\txfs_ilock(mp->m_rbmip, XFS_ILOCK_SHARED | XFS_ILOCK_RTBITMAP);\n\n\t \n\talow.ar_startext = start_rtb;\n\tahigh.ar_startext = end_rtb;\n\tdo_div(alow.ar_startext, mp->m_sb.sb_rextsize);\n\tif (do_div(ahigh.ar_startext, mp->m_sb.sb_rextsize))\n\t\tahigh.ar_startext++;\n\terror = xfs_rtalloc_query_range(mp, tp, &alow, &ahigh,\n\t\t\txfs_getfsmap_rtdev_rtbitmap_helper, info);\n\tif (error)\n\t\tgoto err;\n\n\t \n\tinfo->last = true;\n\tahigh.ar_startext = min(mp->m_sb.sb_rextents, ahigh.ar_startext);\n\n\terror = xfs_getfsmap_rtdev_rtbitmap_helper(mp, tp, &ahigh, info);\n\tif (error)\n\t\tgoto err;\nerr:\n\txfs_iunlock(mp->m_rbmip, XFS_ILOCK_SHARED | XFS_ILOCK_RTBITMAP);\n\treturn error;\n}\n#endif  \n\nstatic inline bool\nrmap_not_shareable(struct xfs_mount *mp, const struct xfs_rmap_irec *r)\n{\n\tif (!xfs_has_reflink(mp))\n\t\treturn true;\n\tif (XFS_RMAP_NON_INODE_OWNER(r->rm_owner))\n\t\treturn true;\n\tif (r->rm_flags & (XFS_RMAP_ATTR_FORK | XFS_RMAP_BMBT_BLOCK |\n\t\t\t   XFS_RMAP_UNWRITTEN))\n\t\treturn true;\n\treturn false;\n}\n\n \nSTATIC int\n__xfs_getfsmap_datadev(\n\tstruct xfs_trans\t\t*tp,\n\tconst struct xfs_fsmap\t\t*keys,\n\tstruct xfs_getfsmap_info\t*info,\n\tint\t\t\t\t(*query_fn)(struct xfs_trans *,\n\t\t\t\t\t\t    struct xfs_getfsmap_info *,\n\t\t\t\t\t\t    struct xfs_btree_cur **,\n\t\t\t\t\t\t    void *),\n\tvoid\t\t\t\t*priv)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_perag\t\t*pag;\n\tstruct xfs_btree_cur\t\t*bt_cur = NULL;\n\txfs_fsblock_t\t\t\tstart_fsb;\n\txfs_fsblock_t\t\t\tend_fsb;\n\txfs_agnumber_t\t\t\tstart_ag;\n\txfs_agnumber_t\t\t\tend_ag;\n\tuint64_t\t\t\teofs;\n\tint\t\t\t\terror = 0;\n\n\teofs = XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks);\n\tif (keys[0].fmr_physical >= eofs)\n\t\treturn 0;\n\tstart_fsb = XFS_DADDR_TO_FSB(mp, keys[0].fmr_physical);\n\tend_fsb = XFS_DADDR_TO_FSB(mp, min(eofs - 1, keys[1].fmr_physical));\n\n\t \n\tinfo->low.rm_offset = XFS_BB_TO_FSBT(mp, keys[0].fmr_offset);\n\terror = xfs_fsmap_owner_to_rmap(&info->low, &keys[0]);\n\tif (error)\n\t\treturn error;\n\tinfo->low.rm_blockcount = XFS_BB_TO_FSBT(mp, keys[0].fmr_length);\n\txfs_getfsmap_set_irec_flags(&info->low, &keys[0]);\n\n\t \n\tif (info->low.rm_blockcount == 0) {\n\t\t \n\t} else if (rmap_not_shareable(mp, &info->low)) {\n\t\t \n\t\tinfo->low.rm_owner = 0;\n\t\tinfo->low.rm_offset = 0;\n\n\t\tstart_fsb += info->low.rm_blockcount;\n\t\tif (XFS_FSB_TO_DADDR(mp, start_fsb) >= eofs)\n\t\t\treturn 0;\n\t} else {\n\t\t \n\t\tinfo->low.rm_offset += info->low.rm_blockcount;\n\t}\n\tinfo->low.rm_startblock = XFS_FSB_TO_AGBNO(mp, start_fsb);\n\n\tinfo->high.rm_startblock = -1U;\n\tinfo->high.rm_owner = ULLONG_MAX;\n\tinfo->high.rm_offset = ULLONG_MAX;\n\tinfo->high.rm_blockcount = 0;\n\tinfo->high.rm_flags = XFS_RMAP_KEY_FLAGS | XFS_RMAP_REC_FLAGS;\n\n\tstart_ag = XFS_FSB_TO_AGNO(mp, start_fsb);\n\tend_ag = XFS_FSB_TO_AGNO(mp, end_fsb);\n\n\tfor_each_perag_range(mp, start_ag, end_ag, pag) {\n\t\t \n\t\tinfo->pag = pag;\n\t\tif (pag->pag_agno == end_ag) {\n\t\t\tinfo->high.rm_startblock = XFS_FSB_TO_AGBNO(mp,\n\t\t\t\t\tend_fsb);\n\t\t\tinfo->high.rm_offset = XFS_BB_TO_FSBT(mp,\n\t\t\t\t\tkeys[1].fmr_offset);\n\t\t\terror = xfs_fsmap_owner_to_rmap(&info->high, &keys[1]);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\txfs_getfsmap_set_irec_flags(&info->high, &keys[1]);\n\t\t}\n\n\t\tif (bt_cur) {\n\t\t\txfs_btree_del_cursor(bt_cur, XFS_BTREE_NOERROR);\n\t\t\tbt_cur = NULL;\n\t\t\txfs_trans_brelse(tp, info->agf_bp);\n\t\t\tinfo->agf_bp = NULL;\n\t\t}\n\n\t\terror = xfs_alloc_read_agf(pag, tp, 0, &info->agf_bp);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\ttrace_xfs_fsmap_low_key(mp, info->dev, pag->pag_agno,\n\t\t\t\t&info->low);\n\t\ttrace_xfs_fsmap_high_key(mp, info->dev, pag->pag_agno,\n\t\t\t\t&info->high);\n\n\t\terror = query_fn(tp, info, &bt_cur, priv);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\t \n\t\tif (pag->pag_agno == start_ag)\n\t\t\tmemset(&info->low, 0, sizeof(info->low));\n\n\t\t \n\t\tif (pag->pag_agno == end_ag) {\n\t\t\tinfo->last = true;\n\t\t\terror = query_fn(tp, info, &bt_cur, priv);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t\tinfo->pag = NULL;\n\t}\n\n\tif (bt_cur)\n\t\txfs_btree_del_cursor(bt_cur, error < 0 ? XFS_BTREE_ERROR :\n\t\t\t\t\t\t\t XFS_BTREE_NOERROR);\n\tif (info->agf_bp) {\n\t\txfs_trans_brelse(tp, info->agf_bp);\n\t\tinfo->agf_bp = NULL;\n\t}\n\tif (info->pag) {\n\t\txfs_perag_rele(info->pag);\n\t\tinfo->pag = NULL;\n\t} else if (pag) {\n\t\t \n\t\txfs_perag_rele(pag);\n\t}\n\n\treturn error;\n}\n\n \nSTATIC int\nxfs_getfsmap_datadev_rmapbt_query(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_getfsmap_info\t*info,\n\tstruct xfs_btree_cur\t\t**curpp,\n\tvoid\t\t\t\t*priv)\n{\n\t \n\tif (info->last)\n\t\treturn xfs_getfsmap_datadev_helper(*curpp, &info->high, info);\n\n\t \n\t*curpp = xfs_rmapbt_init_cursor(tp->t_mountp, tp, info->agf_bp,\n\t\t\tinfo->pag);\n\treturn xfs_rmap_query_range(*curpp, &info->low, &info->high,\n\t\t\txfs_getfsmap_datadev_helper, info);\n}\n\n \nSTATIC int\nxfs_getfsmap_datadev_rmapbt(\n\tstruct xfs_trans\t\t*tp,\n\tconst struct xfs_fsmap\t\t*keys,\n\tstruct xfs_getfsmap_info\t*info)\n{\n\tinfo->missing_owner = XFS_FMR_OWN_FREE;\n\treturn __xfs_getfsmap_datadev(tp, keys, info,\n\t\t\txfs_getfsmap_datadev_rmapbt_query, NULL);\n}\n\n \nSTATIC int\nxfs_getfsmap_datadev_bnobt_query(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_getfsmap_info\t*info,\n\tstruct xfs_btree_cur\t\t**curpp,\n\tvoid\t\t\t\t*priv)\n{\n\tstruct xfs_alloc_rec_incore\t*key = priv;\n\n\t \n\tif (info->last)\n\t\treturn xfs_getfsmap_datadev_bnobt_helper(*curpp, &key[1], info);\n\n\t \n\t*curpp = xfs_allocbt_init_cursor(tp->t_mountp, tp, info->agf_bp,\n\t\t\tinfo->pag, XFS_BTNUM_BNO);\n\tkey->ar_startblock = info->low.rm_startblock;\n\tkey[1].ar_startblock = info->high.rm_startblock;\n\treturn xfs_alloc_query_range(*curpp, key, &key[1],\n\t\t\txfs_getfsmap_datadev_bnobt_helper, info);\n}\n\n \nSTATIC int\nxfs_getfsmap_datadev_bnobt(\n\tstruct xfs_trans\t\t*tp,\n\tconst struct xfs_fsmap\t\t*keys,\n\tstruct xfs_getfsmap_info\t*info)\n{\n\tstruct xfs_alloc_rec_incore\takeys[2];\n\n\tmemset(akeys, 0, sizeof(akeys));\n\tinfo->missing_owner = XFS_FMR_OWN_UNKNOWN;\n\treturn __xfs_getfsmap_datadev(tp, keys, info,\n\t\t\txfs_getfsmap_datadev_bnobt_query, &akeys[0]);\n}\n\n \nSTATIC bool\nxfs_getfsmap_is_valid_device(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_fsmap\t*fm)\n{\n\tif (fm->fmr_device == 0 || fm->fmr_device == UINT_MAX ||\n\t    fm->fmr_device == new_encode_dev(mp->m_ddev_targp->bt_dev))\n\t\treturn true;\n\tif (mp->m_logdev_targp &&\n\t    fm->fmr_device == new_encode_dev(mp->m_logdev_targp->bt_dev))\n\t\treturn true;\n\tif (mp->m_rtdev_targp &&\n\t    fm->fmr_device == new_encode_dev(mp->m_rtdev_targp->bt_dev))\n\t\treturn true;\n\treturn false;\n}\n\n \nSTATIC bool\nxfs_getfsmap_check_keys(\n\tstruct xfs_fsmap\t\t*low_key,\n\tstruct xfs_fsmap\t\t*high_key)\n{\n\tif (low_key->fmr_flags & (FMR_OF_SPECIAL_OWNER | FMR_OF_EXTENT_MAP)) {\n\t\tif (low_key->fmr_offset)\n\t\t\treturn false;\n\t}\n\tif (high_key->fmr_flags != -1U &&\n\t    (high_key->fmr_flags & (FMR_OF_SPECIAL_OWNER |\n\t\t\t\t    FMR_OF_EXTENT_MAP))) {\n\t\tif (high_key->fmr_offset && high_key->fmr_offset != -1ULL)\n\t\t\treturn false;\n\t}\n\tif (high_key->fmr_length && high_key->fmr_length != -1ULL)\n\t\treturn false;\n\n\tif (low_key->fmr_device > high_key->fmr_device)\n\t\treturn false;\n\tif (low_key->fmr_device < high_key->fmr_device)\n\t\treturn true;\n\n\tif (low_key->fmr_physical > high_key->fmr_physical)\n\t\treturn false;\n\tif (low_key->fmr_physical < high_key->fmr_physical)\n\t\treturn true;\n\n\tif (low_key->fmr_owner > high_key->fmr_owner)\n\t\treturn false;\n\tif (low_key->fmr_owner < high_key->fmr_owner)\n\t\treturn true;\n\n\tif (low_key->fmr_offset > high_key->fmr_offset)\n\t\treturn false;\n\tif (low_key->fmr_offset < high_key->fmr_offset)\n\t\treturn true;\n\n\treturn false;\n}\n\n \n#ifdef CONFIG_XFS_RT\n#define XFS_GETFSMAP_DEVS\t3\n#else\n#define XFS_GETFSMAP_DEVS\t2\n#endif  \n\n \nint\nxfs_getfsmap(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_fsmap_head\t\t*head,\n\tstruct fsmap\t\t\t*fsmap_recs)\n{\n\tstruct xfs_trans\t\t*tp = NULL;\n\tstruct xfs_fsmap\t\tdkeys[2];\t \n\tstruct xfs_getfsmap_dev\t\thandlers[XFS_GETFSMAP_DEVS];\n\tstruct xfs_getfsmap_info\tinfo = { NULL };\n\tbool\t\t\t\tuse_rmap;\n\tint\t\t\t\ti;\n\tint\t\t\t\terror = 0;\n\n\tif (head->fmh_iflags & ~FMH_IF_VALID)\n\t\treturn -EINVAL;\n\tif (!xfs_getfsmap_is_valid_device(mp, &head->fmh_keys[0]) ||\n\t    !xfs_getfsmap_is_valid_device(mp, &head->fmh_keys[1]))\n\t\treturn -EINVAL;\n\tif (!xfs_getfsmap_check_keys(&head->fmh_keys[0], &head->fmh_keys[1]))\n\t\treturn -EINVAL;\n\n\tuse_rmap = xfs_has_rmapbt(mp) &&\n\t\t   has_capability_noaudit(current, CAP_SYS_ADMIN);\n\thead->fmh_entries = 0;\n\n\t \n\tmemset(handlers, 0, sizeof(handlers));\n\thandlers[0].dev = new_encode_dev(mp->m_ddev_targp->bt_dev);\n\tif (use_rmap)\n\t\thandlers[0].fn = xfs_getfsmap_datadev_rmapbt;\n\telse\n\t\thandlers[0].fn = xfs_getfsmap_datadev_bnobt;\n\tif (mp->m_logdev_targp != mp->m_ddev_targp) {\n\t\thandlers[1].dev = new_encode_dev(mp->m_logdev_targp->bt_dev);\n\t\thandlers[1].fn = xfs_getfsmap_logdev;\n\t}\n#ifdef CONFIG_XFS_RT\n\tif (mp->m_rtdev_targp) {\n\t\thandlers[2].dev = new_encode_dev(mp->m_rtdev_targp->bt_dev);\n\t\thandlers[2].fn = xfs_getfsmap_rtdev_rtbitmap;\n\t}\n#endif  \n\n\txfs_sort(handlers, XFS_GETFSMAP_DEVS, sizeof(struct xfs_getfsmap_dev),\n\t\t\txfs_getfsmap_dev_compare);\n\n\t \n\tdkeys[0] = head->fmh_keys[0];\n\tmemset(&dkeys[1], 0xFF, sizeof(struct xfs_fsmap));\n\n\tinfo.next_daddr = head->fmh_keys[0].fmr_physical +\n\t\t\t  head->fmh_keys[0].fmr_length;\n\tinfo.fsmap_recs = fsmap_recs;\n\tinfo.head = head;\n\n\t \n\tfor (i = 0; i < XFS_GETFSMAP_DEVS; i++) {\n\t\t \n\t\tif (!handlers[i].fn)\n\t\t\tcontinue;\n\t\tif (head->fmh_keys[0].fmr_device > handlers[i].dev)\n\t\t\tcontinue;\n\t\tif (head->fmh_keys[1].fmr_device < handlers[i].dev)\n\t\t\tbreak;\n\n\t\t \n\t\tif (handlers[i].dev == head->fmh_keys[1].fmr_device)\n\t\t\tdkeys[1] = head->fmh_keys[1];\n\t\tif (handlers[i].dev > head->fmh_keys[0].fmr_device)\n\t\t\tmemset(&dkeys[0], 0, sizeof(struct xfs_fsmap));\n\n\t\t \n\t\terror = xfs_trans_alloc_empty(mp, &tp);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tinfo.dev = handlers[i].dev;\n\t\tinfo.last = false;\n\t\tinfo.pag = NULL;\n\t\tinfo.low_daddr = -1ULL;\n\t\tinfo.low.rm_blockcount = 0;\n\t\terror = handlers[i].fn(tp, dkeys, &info);\n\t\tif (error)\n\t\t\tbreak;\n\t\txfs_trans_cancel(tp);\n\t\ttp = NULL;\n\t\tinfo.next_daddr = 0;\n\t}\n\n\tif (tp)\n\t\txfs_trans_cancel(tp);\n\thead->fmh_oflags = FMH_OF_DEV_T;\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}