{
  "module_name": "xfs_discard.c",
  "hash_id": "03d6b8828647e5bd35054f852a7820e11ece4d6d751d10bef7fa3bf9b267ca9d",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_discard.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_ag.h\"\n\n \n\nstruct workqueue_struct *xfs_discard_wq;\n\nstatic void\nxfs_discard_endio_work(\n\tstruct work_struct\t*work)\n{\n\tstruct xfs_busy_extents\t*extents =\n\t\tcontainer_of(work, struct xfs_busy_extents, endio_work);\n\n\txfs_extent_busy_clear(extents->mount, &extents->extent_list, false);\n\tkmem_free(extents->owner);\n}\n\n \nstatic void\nxfs_discard_endio(\n\tstruct bio\t\t*bio)\n{\n\tstruct xfs_busy_extents\t*extents = bio->bi_private;\n\n\tINIT_WORK(&extents->endio_work, xfs_discard_endio_work);\n\tqueue_work(xfs_discard_wq, &extents->endio_work);\n\tbio_put(bio);\n}\n\n \nint\nxfs_discard_extents(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_busy_extents\t*extents)\n{\n\tstruct xfs_extent_busy\t*busyp;\n\tstruct bio\t\t*bio = NULL;\n\tstruct blk_plug\t\tplug;\n\tint\t\t\terror = 0;\n\n\tblk_start_plug(&plug);\n\tlist_for_each_entry(busyp, &extents->extent_list, list) {\n\t\ttrace_xfs_discard_extent(mp, busyp->agno, busyp->bno,\n\t\t\t\t\t busyp->length);\n\n\t\terror = __blkdev_issue_discard(mp->m_ddev_targp->bt_bdev,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, busyp->agno, busyp->bno),\n\t\t\t\tXFS_FSB_TO_BB(mp, busyp->length),\n\t\t\t\tGFP_NOFS, &bio);\n\t\tif (error && error != -EOPNOTSUPP) {\n\t\t\txfs_info(mp,\n\t \"discard failed for extent [0x%llx,%u], error %d\",\n\t\t\t\t (unsigned long long)busyp->bno,\n\t\t\t\t busyp->length,\n\t\t\t\t error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bio) {\n\t\tbio->bi_private = extents;\n\t\tbio->bi_end_io = xfs_discard_endio;\n\t\tsubmit_bio(bio);\n\t} else {\n\t\txfs_discard_endio_work(&extents->endio_work);\n\t}\n\tblk_finish_plug(&plug);\n\n\treturn error;\n}\n\n\nstatic int\nxfs_trim_gather_extents(\n\tstruct xfs_perag\t*pag,\n\txfs_daddr_t\t\tstart,\n\txfs_daddr_t\t\tend,\n\txfs_daddr_t\t\tminlen,\n\tstruct xfs_alloc_rec_incore *tcur,\n\tstruct xfs_busy_extents\t*extents,\n\tuint64_t\t\t*blocks_trimmed)\n{\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\tstruct xfs_btree_cur\t*cur;\n\tstruct xfs_buf\t\t*agbp;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\tint\t\t\tbatch = 100;\n\n\t \n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\terror = xfs_alloc_read_agf(pag, NULL, 0, &agbp);\n\tif (error)\n\t\treturn error;\n\n\tcur = xfs_allocbt_init_cursor(mp, NULL, agbp, pag, XFS_BTNUM_CNT);\n\n\t \n\tif (tcur->ar_startblock == NULLAGBLOCK)\n\t\terror = xfs_alloc_lookup_ge(cur, 0, tcur->ar_blockcount, &i);\n\telse\n\t\terror = xfs_alloc_lookup_le(cur, tcur->ar_startblock,\n\t\t\t\ttcur->ar_blockcount, &i);\n\tif (error)\n\t\tgoto out_del_cursor;\n\tif (i == 0) {\n\t\t \n\t\ttcur->ar_blockcount = 0;\n\t\tgoto out_del_cursor;\n\t}\n\n\t \n\twhile (i) {\n\t\txfs_agblock_t\tfbno;\n\t\txfs_extlen_t\tflen;\n\t\txfs_daddr_t\tdbno;\n\t\txfs_extlen_t\tdlen;\n\n\t\terror = xfs_alloc_get_rec(cur, &fbno, &flen, &i);\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (XFS_IS_CORRUPT(mp, i != 1)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (--batch <= 0) {\n\t\t\t \n\t\t\ttcur->ar_startblock = fbno;\n\t\t\ttcur->ar_blockcount = flen;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tdbno = XFS_AGB_TO_DADDR(mp, pag->pag_agno, fbno);\n\t\tdlen = XFS_FSB_TO_BB(mp, flen);\n\n\t\t \n\t\tif (dlen < minlen) {\n\t\t\ttrace_xfs_discard_toosmall(mp, pag->pag_agno, fbno, flen);\n\t\t\ttcur->ar_blockcount = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (dbno + dlen < start || dbno > end) {\n\t\t\ttrace_xfs_discard_exclude(mp, pag->pag_agno, fbno, flen);\n\t\t\tgoto next_extent;\n\t\t}\n\n\t\t \n\t\tif (xfs_extent_busy_search(mp, pag, fbno, flen)) {\n\t\t\ttrace_xfs_discard_busy(mp, pag->pag_agno, fbno, flen);\n\t\t\tgoto next_extent;\n\t\t}\n\n\t\txfs_extent_busy_insert_discard(pag, fbno, flen,\n\t\t\t\t&extents->extent_list);\n\t\t*blocks_trimmed += flen;\nnext_extent:\n\t\terror = xfs_btree_decrement(cur, 0, &i);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\t \n\t\tif (i == 0)\n\t\t\ttcur->ar_blockcount = 0;\n\t}\n\n\t \n\tif (error)\n\t\txfs_extent_busy_clear(mp, &extents->extent_list, false);\nout_del_cursor:\n\txfs_btree_del_cursor(cur, error);\n\txfs_buf_relse(agbp);\n\treturn error;\n}\n\nstatic bool\nxfs_trim_should_stop(void)\n{\n\treturn fatal_signal_pending(current) || freezing(current);\n}\n\n \nstatic int\nxfs_trim_extents(\n\tstruct xfs_perag\t*pag,\n\txfs_daddr_t\t\tstart,\n\txfs_daddr_t\t\tend,\n\txfs_daddr_t\t\tminlen,\n\tuint64_t\t\t*blocks_trimmed)\n{\n\tstruct xfs_alloc_rec_incore tcur = {\n\t\t.ar_blockcount = pag->pagf_longest,\n\t\t.ar_startblock = NULLAGBLOCK,\n\t};\n\tint\t\t\terror = 0;\n\n\tdo {\n\t\tstruct xfs_busy_extents\t*extents;\n\n\t\textents = kzalloc(sizeof(*extents), GFP_KERNEL);\n\t\tif (!extents) {\n\t\t\terror = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\textents->mount = pag->pag_mount;\n\t\textents->owner = extents;\n\t\tINIT_LIST_HEAD(&extents->extent_list);\n\n\t\terror = xfs_trim_gather_extents(pag, start, end, minlen,\n\t\t\t\t&tcur, extents, blocks_trimmed);\n\t\tif (error) {\n\t\t\tkfree(extents);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\terror = xfs_discard_extents(pag->pag_mount, extents);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tif (xfs_trim_should_stop())\n\t\t\tbreak;\n\n\t} while (tcur.ar_blockcount != 0);\n\n\treturn error;\n\n}\n\n \nint\nxfs_ioc_trim(\n\tstruct xfs_mount\t\t*mp,\n\tstruct fstrim_range __user\t*urange)\n{\n\tstruct xfs_perag\t*pag;\n\tunsigned int\t\tgranularity =\n\t\tbdev_discard_granularity(mp->m_ddev_targp->bt_bdev);\n\tstruct fstrim_range\trange;\n\txfs_daddr_t\t\tstart, end, minlen;\n\txfs_agnumber_t\t\tagno;\n\tuint64_t\t\tblocks_trimmed = 0;\n\tint\t\t\terror, last_error = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!bdev_max_discard_sectors(mp->m_ddev_targp->bt_bdev))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (xfs_has_norecovery(mp))\n\t\treturn -EROFS;\n\n\tif (copy_from_user(&range, urange, sizeof(range)))\n\t\treturn -EFAULT;\n\n\trange.minlen = max_t(u64, granularity, range.minlen);\n\tminlen = BTOBB(range.minlen);\n\t \n\tif (range.start >= XFS_FSB_TO_B(mp, mp->m_sb.sb_dblocks) ||\n\t    range.minlen > XFS_FSB_TO_B(mp, mp->m_ag_max_usable) ||\n\t    range.len < mp->m_sb.sb_blocksize)\n\t\treturn -EINVAL;\n\n\tstart = BTOBB(range.start);\n\tend = start + BTOBBT(range.len) - 1;\n\n\tif (end > XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks) - 1)\n\t\tend = XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks) - 1;\n\n\tagno = xfs_daddr_to_agno(mp, start);\n\tfor_each_perag_range(mp, agno, xfs_daddr_to_agno(mp, end), pag) {\n\t\terror = xfs_trim_extents(pag, start, end, minlen,\n\t\t\t\t\t  &blocks_trimmed);\n\t\tif (error)\n\t\t\tlast_error = error;\n\n\t\tif (xfs_trim_should_stop()) {\n\t\t\txfs_perag_rele(pag);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (last_error)\n\t\treturn last_error;\n\n\trange.len = XFS_FSB_TO_B(mp, blocks_trimmed);\n\tif (copy_to_user(urange, &range, sizeof(range)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}