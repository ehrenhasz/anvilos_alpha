{
  "module_name": "xfs_sysfs.c",
  "hash_id": "6aee9f0ba3015df28cb320d3c1e71684ce2418cc24ddf0e55f052ac2112d3f61",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_sysfs.c",
  "human_readable_source": "\n \n\n#include \"xfs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_log.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_mount.h\"\n\nstruct xfs_sysfs_attr {\n\tstruct attribute attr;\n\tssize_t (*show)(struct kobject *kobject, char *buf);\n\tssize_t (*store)(struct kobject *kobject, const char *buf,\n\t\t\t size_t count);\n};\n\nstatic inline struct xfs_sysfs_attr *\nto_attr(struct attribute *attr)\n{\n\treturn container_of(attr, struct xfs_sysfs_attr, attr);\n}\n\n#define XFS_SYSFS_ATTR_RW(name) \\\n\tstatic struct xfs_sysfs_attr xfs_sysfs_attr_##name = __ATTR_RW(name)\n#define XFS_SYSFS_ATTR_RO(name) \\\n\tstatic struct xfs_sysfs_attr xfs_sysfs_attr_##name = __ATTR_RO(name)\n#define XFS_SYSFS_ATTR_WO(name) \\\n\tstatic struct xfs_sysfs_attr xfs_sysfs_attr_##name = __ATTR_WO(name)\n\n#define ATTR_LIST(name) &xfs_sysfs_attr_##name.attr\n\nSTATIC ssize_t\nxfs_sysfs_object_show(\n\tstruct kobject\t\t*kobject,\n\tstruct attribute\t*attr,\n\tchar\t\t\t*buf)\n{\n\tstruct xfs_sysfs_attr *xfs_attr = to_attr(attr);\n\n\treturn xfs_attr->show ? xfs_attr->show(kobject, buf) : 0;\n}\n\nSTATIC ssize_t\nxfs_sysfs_object_store(\n\tstruct kobject\t\t*kobject,\n\tstruct attribute\t*attr,\n\tconst char\t\t*buf,\n\tsize_t\t\t\tcount)\n{\n\tstruct xfs_sysfs_attr *xfs_attr = to_attr(attr);\n\n\treturn xfs_attr->store ? xfs_attr->store(kobject, buf, count) : 0;\n}\n\nstatic const struct sysfs_ops xfs_sysfs_ops = {\n\t.show = xfs_sysfs_object_show,\n\t.store = xfs_sysfs_object_store,\n};\n\nstatic struct attribute *xfs_mp_attrs[] = {\n\tNULL,\n};\nATTRIBUTE_GROUPS(xfs_mp);\n\nconst struct kobj_type xfs_mp_ktype = {\n\t.release = xfs_sysfs_release,\n\t.sysfs_ops = &xfs_sysfs_ops,\n\t.default_groups = xfs_mp_groups,\n};\n\n#ifdef DEBUG\n \n\nSTATIC ssize_t\nbug_on_assert_store(\n\tstruct kobject\t\t*kobject,\n\tconst char\t\t*buf,\n\tsize_t\t\t\tcount)\n{\n\tint\t\t\tret;\n\tint\t\t\tval;\n\n\tret = kstrtoint(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val == 1)\n\t\txfs_globals.bug_on_assert = true;\n\telse if (val == 0)\n\t\txfs_globals.bug_on_assert = false;\n\telse\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nSTATIC ssize_t\nbug_on_assert_show(\n\tstruct kobject\t\t*kobject,\n\tchar\t\t\t*buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", xfs_globals.bug_on_assert);\n}\nXFS_SYSFS_ATTR_RW(bug_on_assert);\n\nSTATIC ssize_t\nlog_recovery_delay_store(\n\tstruct kobject\t*kobject,\n\tconst char\t*buf,\n\tsize_t\t\tcount)\n{\n\tint\t\tret;\n\tint\t\tval;\n\n\tret = kstrtoint(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val < 0 || val > 60)\n\t\treturn -EINVAL;\n\n\txfs_globals.log_recovery_delay = val;\n\n\treturn count;\n}\n\nSTATIC ssize_t\nlog_recovery_delay_show(\n\tstruct kobject\t*kobject,\n\tchar\t\t*buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", xfs_globals.log_recovery_delay);\n}\nXFS_SYSFS_ATTR_RW(log_recovery_delay);\n\nSTATIC ssize_t\nmount_delay_store(\n\tstruct kobject\t*kobject,\n\tconst char\t*buf,\n\tsize_t\t\tcount)\n{\n\tint\t\tret;\n\tint\t\tval;\n\n\tret = kstrtoint(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val < 0 || val > 60)\n\t\treturn -EINVAL;\n\n\txfs_globals.mount_delay = val;\n\n\treturn count;\n}\n\nSTATIC ssize_t\nmount_delay_show(\n\tstruct kobject\t*kobject,\n\tchar\t\t*buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", xfs_globals.mount_delay);\n}\nXFS_SYSFS_ATTR_RW(mount_delay);\n\nstatic ssize_t\nalways_cow_store(\n\tstruct kobject\t*kobject,\n\tconst char\t*buf,\n\tsize_t\t\tcount)\n{\n\tssize_t\t\tret;\n\n\tret = kstrtobool(buf, &xfs_globals.always_cow);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\nstatic ssize_t\nalways_cow_show(\n\tstruct kobject\t*kobject,\n\tchar\t\t*buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", xfs_globals.always_cow);\n}\nXFS_SYSFS_ATTR_RW(always_cow);\n\n#ifdef DEBUG\n \nSTATIC ssize_t\npwork_threads_store(\n\tstruct kobject\t*kobject,\n\tconst char\t*buf,\n\tsize_t\t\tcount)\n{\n\tint\t\tret;\n\tint\t\tval;\n\n\tret = kstrtoint(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val < -1 || val > num_possible_cpus())\n\t\treturn -EINVAL;\n\n\txfs_globals.pwork_threads = val;\n\n\treturn count;\n}\n\nSTATIC ssize_t\npwork_threads_show(\n\tstruct kobject\t*kobject,\n\tchar\t\t*buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", xfs_globals.pwork_threads);\n}\nXFS_SYSFS_ATTR_RW(pwork_threads);\n\nstatic ssize_t\nlarp_store(\n\tstruct kobject\t*kobject,\n\tconst char\t*buf,\n\tsize_t\t\tcount)\n{\n\tssize_t\t\tret;\n\n\tret = kstrtobool(buf, &xfs_globals.larp);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\nSTATIC ssize_t\nlarp_show(\n\tstruct kobject\t*kobject,\n\tchar\t\t*buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", xfs_globals.larp);\n}\nXFS_SYSFS_ATTR_RW(larp);\n#endif  \n\nstatic struct attribute *xfs_dbg_attrs[] = {\n\tATTR_LIST(bug_on_assert),\n\tATTR_LIST(log_recovery_delay),\n\tATTR_LIST(mount_delay),\n\tATTR_LIST(always_cow),\n#ifdef DEBUG\n\tATTR_LIST(pwork_threads),\n\tATTR_LIST(larp),\n#endif\n\tNULL,\n};\nATTRIBUTE_GROUPS(xfs_dbg);\n\nconst struct kobj_type xfs_dbg_ktype = {\n\t.release = xfs_sysfs_release,\n\t.sysfs_ops = &xfs_sysfs_ops,\n\t.default_groups = xfs_dbg_groups,\n};\n\n#endif  \n\n \n\nstatic inline struct xstats *\nto_xstats(struct kobject *kobject)\n{\n\tstruct xfs_kobj *kobj = to_kobj(kobject);\n\n\treturn container_of(kobj, struct xstats, xs_kobj);\n}\n\nSTATIC ssize_t\nstats_show(\n\tstruct kobject\t*kobject,\n\tchar\t\t*buf)\n{\n\tstruct xstats\t*stats = to_xstats(kobject);\n\n\treturn xfs_stats_format(stats->xs_stats, buf);\n}\nXFS_SYSFS_ATTR_RO(stats);\n\nSTATIC ssize_t\nstats_clear_store(\n\tstruct kobject\t*kobject,\n\tconst char\t*buf,\n\tsize_t\t\tcount)\n{\n\tint\t\tret;\n\tint\t\tval;\n\tstruct xstats\t*stats = to_xstats(kobject);\n\n\tret = kstrtoint(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\txfs_stats_clearall(stats->xs_stats);\n\treturn count;\n}\nXFS_SYSFS_ATTR_WO(stats_clear);\n\nstatic struct attribute *xfs_stats_attrs[] = {\n\tATTR_LIST(stats),\n\tATTR_LIST(stats_clear),\n\tNULL,\n};\nATTRIBUTE_GROUPS(xfs_stats);\n\nconst struct kobj_type xfs_stats_ktype = {\n\t.release = xfs_sysfs_release,\n\t.sysfs_ops = &xfs_sysfs_ops,\n\t.default_groups = xfs_stats_groups,\n};\n\n \n\nstatic inline struct xlog *\nto_xlog(struct kobject *kobject)\n{\n\tstruct xfs_kobj *kobj = to_kobj(kobject);\n\n\treturn container_of(kobj, struct xlog, l_kobj);\n}\n\nSTATIC ssize_t\nlog_head_lsn_show(\n\tstruct kobject\t*kobject,\n\tchar\t\t*buf)\n{\n\tint cycle;\n\tint block;\n\tstruct xlog *log = to_xlog(kobject);\n\n\tspin_lock(&log->l_icloglock);\n\tcycle = log->l_curr_cycle;\n\tblock = log->l_curr_block;\n\tspin_unlock(&log->l_icloglock);\n\n\treturn sysfs_emit(buf, \"%d:%d\\n\", cycle, block);\n}\nXFS_SYSFS_ATTR_RO(log_head_lsn);\n\nSTATIC ssize_t\nlog_tail_lsn_show(\n\tstruct kobject\t*kobject,\n\tchar\t\t*buf)\n{\n\tint cycle;\n\tint block;\n\tstruct xlog *log = to_xlog(kobject);\n\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &cycle, &block);\n\treturn sysfs_emit(buf, \"%d:%d\\n\", cycle, block);\n}\nXFS_SYSFS_ATTR_RO(log_tail_lsn);\n\nSTATIC ssize_t\nreserve_grant_head_show(\n\tstruct kobject\t*kobject,\n\tchar\t\t*buf)\n\n{\n\tint cycle;\n\tint bytes;\n\tstruct xlog *log = to_xlog(kobject);\n\n\txlog_crack_grant_head(&log->l_reserve_head.grant, &cycle, &bytes);\n\treturn sysfs_emit(buf, \"%d:%d\\n\", cycle, bytes);\n}\nXFS_SYSFS_ATTR_RO(reserve_grant_head);\n\nSTATIC ssize_t\nwrite_grant_head_show(\n\tstruct kobject\t*kobject,\n\tchar\t\t*buf)\n{\n\tint cycle;\n\tint bytes;\n\tstruct xlog *log = to_xlog(kobject);\n\n\txlog_crack_grant_head(&log->l_write_head.grant, &cycle, &bytes);\n\treturn sysfs_emit(buf, \"%d:%d\\n\", cycle, bytes);\n}\nXFS_SYSFS_ATTR_RO(write_grant_head);\n\nstatic struct attribute *xfs_log_attrs[] = {\n\tATTR_LIST(log_head_lsn),\n\tATTR_LIST(log_tail_lsn),\n\tATTR_LIST(reserve_grant_head),\n\tATTR_LIST(write_grant_head),\n\tNULL,\n};\nATTRIBUTE_GROUPS(xfs_log);\n\nconst struct kobj_type xfs_log_ktype = {\n\t.release = xfs_sysfs_release,\n\t.sysfs_ops = &xfs_sysfs_ops,\n\t.default_groups = xfs_log_groups,\n};\n\n \nstatic inline struct xfs_error_cfg *\nto_error_cfg(struct kobject *kobject)\n{\n\tstruct xfs_kobj *kobj = to_kobj(kobject);\n\treturn container_of(kobj, struct xfs_error_cfg, kobj);\n}\n\nstatic inline struct xfs_mount *\nerr_to_mp(struct kobject *kobject)\n{\n\tstruct xfs_kobj *kobj = to_kobj(kobject);\n\treturn container_of(kobj, struct xfs_mount, m_error_kobj);\n}\n\nstatic ssize_t\nmax_retries_show(\n\tstruct kobject\t*kobject,\n\tchar\t\t*buf)\n{\n\tint\t\tretries;\n\tstruct xfs_error_cfg *cfg = to_error_cfg(kobject);\n\n\tif (cfg->max_retries == XFS_ERR_RETRY_FOREVER)\n\t\tretries = -1;\n\telse\n\t\tretries = cfg->max_retries;\n\n\treturn sysfs_emit(buf, \"%d\\n\", retries);\n}\n\nstatic ssize_t\nmax_retries_store(\n\tstruct kobject\t*kobject,\n\tconst char\t*buf,\n\tsize_t\t\tcount)\n{\n\tstruct xfs_error_cfg *cfg = to_error_cfg(kobject);\n\tint\t\tret;\n\tint\t\tval;\n\n\tret = kstrtoint(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val < -1)\n\t\treturn -EINVAL;\n\n\tif (val == -1)\n\t\tcfg->max_retries = XFS_ERR_RETRY_FOREVER;\n\telse\n\t\tcfg->max_retries = val;\n\treturn count;\n}\nXFS_SYSFS_ATTR_RW(max_retries);\n\nstatic ssize_t\nretry_timeout_seconds_show(\n\tstruct kobject\t*kobject,\n\tchar\t\t*buf)\n{\n\tint\t\ttimeout;\n\tstruct xfs_error_cfg *cfg = to_error_cfg(kobject);\n\n\tif (cfg->retry_timeout == XFS_ERR_RETRY_FOREVER)\n\t\ttimeout = -1;\n\telse\n\t\ttimeout = jiffies_to_msecs(cfg->retry_timeout) / MSEC_PER_SEC;\n\n\treturn sysfs_emit(buf, \"%d\\n\", timeout);\n}\n\nstatic ssize_t\nretry_timeout_seconds_store(\n\tstruct kobject\t*kobject,\n\tconst char\t*buf,\n\tsize_t\t\tcount)\n{\n\tstruct xfs_error_cfg *cfg = to_error_cfg(kobject);\n\tint\t\tret;\n\tint\t\tval;\n\n\tret = kstrtoint(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (val < -1 || val > 86400)\n\t\treturn -EINVAL;\n\n\tif (val == -1)\n\t\tcfg->retry_timeout = XFS_ERR_RETRY_FOREVER;\n\telse {\n\t\tcfg->retry_timeout = msecs_to_jiffies(val * MSEC_PER_SEC);\n\t\tASSERT(msecs_to_jiffies(val * MSEC_PER_SEC) < LONG_MAX);\n\t}\n\treturn count;\n}\nXFS_SYSFS_ATTR_RW(retry_timeout_seconds);\n\nstatic ssize_t\nfail_at_unmount_show(\n\tstruct kobject\t*kobject,\n\tchar\t\t*buf)\n{\n\tstruct xfs_mount\t*mp = err_to_mp(kobject);\n\n\treturn sysfs_emit(buf, \"%d\\n\", mp->m_fail_unmount);\n}\n\nstatic ssize_t\nfail_at_unmount_store(\n\tstruct kobject\t*kobject,\n\tconst char\t*buf,\n\tsize_t\t\tcount)\n{\n\tstruct xfs_mount\t*mp = err_to_mp(kobject);\n\tint\t\tret;\n\tint\t\tval;\n\n\tret = kstrtoint(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val < 0 || val > 1)\n\t\treturn -EINVAL;\n\n\tmp->m_fail_unmount = val;\n\treturn count;\n}\nXFS_SYSFS_ATTR_RW(fail_at_unmount);\n\nstatic struct attribute *xfs_error_attrs[] = {\n\tATTR_LIST(max_retries),\n\tATTR_LIST(retry_timeout_seconds),\n\tNULL,\n};\nATTRIBUTE_GROUPS(xfs_error);\n\nstatic const struct kobj_type xfs_error_cfg_ktype = {\n\t.release = xfs_sysfs_release,\n\t.sysfs_ops = &xfs_sysfs_ops,\n\t.default_groups = xfs_error_groups,\n};\n\nstatic const struct kobj_type xfs_error_ktype = {\n\t.release = xfs_sysfs_release,\n\t.sysfs_ops = &xfs_sysfs_ops,\n};\n\n \nstruct xfs_error_init {\n\tchar\t\t*name;\n\tint\t\tmax_retries;\n\tint\t\tretry_timeout;\t \n};\n\nstatic const struct xfs_error_init xfs_error_meta_init[XFS_ERR_ERRNO_MAX] = {\n\t{ .name = \"default\",\n\t  .max_retries = XFS_ERR_RETRY_FOREVER,\n\t  .retry_timeout = XFS_ERR_RETRY_FOREVER,\n\t},\n\t{ .name = \"EIO\",\n\t  .max_retries = XFS_ERR_RETRY_FOREVER,\n\t  .retry_timeout = XFS_ERR_RETRY_FOREVER,\n\t},\n\t{ .name = \"ENOSPC\",\n\t  .max_retries = XFS_ERR_RETRY_FOREVER,\n\t  .retry_timeout = XFS_ERR_RETRY_FOREVER,\n\t},\n\t{ .name = \"ENODEV\",\n\t  .max_retries = 0,\t \n\t  .retry_timeout = 0,\n\t},\n};\n\nstatic int\nxfs_error_sysfs_init_class(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tclass,\n\tconst char\t\t*parent_name,\n\tstruct xfs_kobj\t\t*parent_kobj,\n\tconst struct xfs_error_init init[])\n{\n\tstruct xfs_error_cfg\t*cfg;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tASSERT(class < XFS_ERR_CLASS_MAX);\n\n\terror = xfs_sysfs_init(parent_kobj, &xfs_error_ktype,\n\t\t\t\t&mp->m_error_kobj, parent_name);\n\tif (error)\n\t\treturn error;\n\n\tfor (i = 0; i < XFS_ERR_ERRNO_MAX; i++) {\n\t\tcfg = &mp->m_error_cfg[class][i];\n\t\terror = xfs_sysfs_init(&cfg->kobj, &xfs_error_cfg_ktype,\n\t\t\t\t\tparent_kobj, init[i].name);\n\t\tif (error)\n\t\t\tgoto out_error;\n\n\t\tcfg->max_retries = init[i].max_retries;\n\t\tif (init[i].retry_timeout == XFS_ERR_RETRY_FOREVER)\n\t\t\tcfg->retry_timeout = XFS_ERR_RETRY_FOREVER;\n\t\telse\n\t\t\tcfg->retry_timeout = msecs_to_jiffies(\n\t\t\t\t\tinit[i].retry_timeout * MSEC_PER_SEC);\n\t}\n\treturn 0;\n\nout_error:\n\t \n\tfor (i--; i >= 0; i--) {\n\t\tcfg = &mp->m_error_cfg[class][i];\n\t\txfs_sysfs_del(&cfg->kobj);\n\t}\n\txfs_sysfs_del(parent_kobj);\n\treturn error;\n}\n\nint\nxfs_error_sysfs_init(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\terror;\n\n\t \n\terror = xfs_sysfs_init(&mp->m_error_kobj, &xfs_error_ktype,\n\t\t\t\t&mp->m_kobj, \"error\");\n\tif (error)\n\t\treturn error;\n\n\terror = sysfs_create_file(&mp->m_error_kobj.kobject,\n\t\t\t\t  ATTR_LIST(fail_at_unmount));\n\n\tif (error)\n\t\tgoto out_error;\n\n\t \n\terror = xfs_error_sysfs_init_class(mp, XFS_ERR_METADATA,\n\t\t\t\t\"metadata\", &mp->m_error_meta_kobj,\n\t\t\t\txfs_error_meta_init);\n\tif (error)\n\t\tgoto out_error;\n\n\treturn 0;\n\nout_error:\n\txfs_sysfs_del(&mp->m_error_kobj);\n\treturn error;\n}\n\nvoid\nxfs_error_sysfs_del(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_error_cfg\t*cfg;\n\tint\t\t\ti, j;\n\n\tfor (i = 0; i < XFS_ERR_CLASS_MAX; i++) {\n\t\tfor (j = 0; j < XFS_ERR_ERRNO_MAX; j++) {\n\t\t\tcfg = &mp->m_error_cfg[i][j];\n\n\t\t\txfs_sysfs_del(&cfg->kobj);\n\t\t}\n\t}\n\txfs_sysfs_del(&mp->m_error_meta_kobj);\n\txfs_sysfs_del(&mp->m_error_kobj);\n}\n\nstruct xfs_error_cfg *\nxfs_error_get_cfg(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\terror_class,\n\tint\t\t\terror)\n{\n\tstruct xfs_error_cfg\t*cfg;\n\n\tif (error < 0)\n\t\terror = -error;\n\n\tswitch (error) {\n\tcase EIO:\n\t\tcfg = &mp->m_error_cfg[error_class][XFS_ERR_EIO];\n\t\tbreak;\n\tcase ENOSPC:\n\t\tcfg = &mp->m_error_cfg[error_class][XFS_ERR_ENOSPC];\n\t\tbreak;\n\tcase ENODEV:\n\t\tcfg = &mp->m_error_cfg[error_class][XFS_ERR_ENODEV];\n\t\tbreak;\n\tdefault:\n\t\tcfg = &mp->m_error_cfg[error_class][XFS_ERR_DEFAULT];\n\t\tbreak;\n\t}\n\n\treturn cfg;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}