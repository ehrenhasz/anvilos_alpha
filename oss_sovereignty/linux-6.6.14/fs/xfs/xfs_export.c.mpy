{
  "module_name": "xfs_export.c",
  "hash_id": "b7672bc97ad2fb6d208d68c09a7b6d7ebe3054457ea65674558e2c6fae22412e",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_export.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_export.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_pnfs.h\"\n\n \nstatic int xfs_fileid_length(int fileid_type)\n{\n\tswitch (fileid_type) {\n\tcase FILEID_INO32_GEN:\n\t\treturn 2;\n\tcase FILEID_INO32_GEN_PARENT:\n\t\treturn 4;\n\tcase FILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG:\n\t\treturn 3;\n\tcase FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:\n\t\treturn 6;\n\t}\n\treturn FILEID_INVALID;\n}\n\nSTATIC int\nxfs_fs_encode_fh(\n\tstruct inode\t*inode,\n\t__u32\t\t*fh,\n\tint\t\t*max_len,\n\tstruct inode\t*parent)\n{\n\tstruct xfs_mount\t*mp = XFS_M(inode->i_sb);\n\tstruct fid\t\t*fid = (struct fid *)fh;\n\tstruct xfs_fid64\t*fid64 = (struct xfs_fid64 *)fh;\n\tint\t\t\tfileid_type;\n\tint\t\t\tlen;\n\n\t \n\tif (!parent)\n\t\tfileid_type = FILEID_INO32_GEN;\n\telse\n\t\tfileid_type = FILEID_INO32_GEN_PARENT;\n\n\t \n\tif (!xfs_has_small_inums(mp) || xfs_is_inode32(mp))\n\t\tfileid_type |= XFS_FILEID_TYPE_64FLAG;\n\n\t \n\tlen = xfs_fileid_length(fileid_type);\n\tif (*max_len < len) {\n\t\t*max_len = len;\n\t\treturn FILEID_INVALID;\n\t}\n\t*max_len = len;\n\n\tswitch (fileid_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tfid->i32.parent_ino = XFS_I(parent)->i_ino;\n\t\tfid->i32.parent_gen = parent->i_generation;\n\t\tfallthrough;\n\tcase FILEID_INO32_GEN:\n\t\tfid->i32.ino = XFS_I(inode)->i_ino;\n\t\tfid->i32.gen = inode->i_generation;\n\t\tbreak;\n\tcase FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:\n\t\tfid64->parent_ino = XFS_I(parent)->i_ino;\n\t\tfid64->parent_gen = parent->i_generation;\n\t\tfallthrough;\n\tcase FILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG:\n\t\tfid64->ino = XFS_I(inode)->i_ino;\n\t\tfid64->gen = inode->i_generation;\n\t\tbreak;\n\t}\n\n\treturn fileid_type;\n}\n\nSTATIC struct inode *\nxfs_nfs_get_inode(\n\tstruct super_block\t*sb,\n\tu64\t\t\tino,\n\tu32\t\t\tgeneration)\n{\n \txfs_mount_t\t\t*mp = XFS_M(sb);\n\txfs_inode_t\t\t*ip;\n\tint\t\t\terror;\n\n\t \n\tif (ino == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\n\t \n\terror = xfs_iget(mp, NULL, ino, XFS_IGET_UNTRUSTED, 0, &ip);\n\tif (error) {\n\n\t\t \n\t\tswitch (error) {\n\t\tcase -EINVAL:\n\t\tcase -ENOENT:\n\t\tcase -EFSCORRUPTED:\n\t\t\terror = -ESTALE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn ERR_PTR(error);\n\t}\n\n\t \n\tif (xfs_inode_unlinked_incomplete(ip)) {\n\t\terror = xfs_inode_reload_unlinked(ip);\n\t\tif (error) {\n\t\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\t\txfs_irele(ip);\n\t\t\treturn ERR_PTR(error);\n\t\t}\n\t}\n\n\tif (VFS_I(ip)->i_generation != generation) {\n\t\txfs_irele(ip);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn VFS_I(ip);\n}\n\nSTATIC struct dentry *\nxfs_fs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t int fh_len, int fileid_type)\n{\n\tstruct xfs_fid64\t*fid64 = (struct xfs_fid64 *)fid;\n\tstruct inode\t\t*inode = NULL;\n\n\tif (fh_len < xfs_fileid_length(fileid_type))\n\t\treturn NULL;\n\n\tswitch (fileid_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\tcase FILEID_INO32_GEN:\n\t\tinode = xfs_nfs_get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\tcase FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:\n\tcase FILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG:\n\t\tinode = xfs_nfs_get_inode(sb, fid64->ino, fid64->gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}\n\nSTATIC struct dentry *\nxfs_fs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\t int fh_len, int fileid_type)\n{\n\tstruct xfs_fid64\t*fid64 = (struct xfs_fid64 *)fid;\n\tstruct inode\t\t*inode = NULL;\n\n\tif (fh_len < xfs_fileid_length(fileid_type))\n\t\treturn NULL;\n\n\tswitch (fileid_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = xfs_nfs_get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t\t      fid->i32.parent_gen);\n\t\tbreak;\n\tcase FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:\n\t\tinode = xfs_nfs_get_inode(sb, fid64->parent_ino,\n\t\t\t\t\t      fid64->parent_gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}\n\nSTATIC struct dentry *\nxfs_fs_get_parent(\n\tstruct dentry\t\t*child)\n{\n\tint\t\t\terror;\n\tstruct xfs_inode\t*cip;\n\n\terror = xfs_lookup(XFS_I(d_inode(child)), &xfs_name_dotdot, &cip, NULL);\n\tif (unlikely(error))\n\t\treturn ERR_PTR(error);\n\n\treturn d_obtain_alias(VFS_I(cip));\n}\n\nSTATIC int\nxfs_fs_nfs_commit_metadata(\n\tstruct inode\t\t*inode)\n{\n\treturn xfs_log_force_inode(XFS_I(inode));\n}\n\nconst struct export_operations xfs_export_operations = {\n\t.encode_fh\t\t= xfs_fs_encode_fh,\n\t.fh_to_dentry\t\t= xfs_fs_fh_to_dentry,\n\t.fh_to_parent\t\t= xfs_fs_fh_to_parent,\n\t.get_parent\t\t= xfs_fs_get_parent,\n\t.commit_metadata\t= xfs_fs_nfs_commit_metadata,\n#ifdef CONFIG_EXPORTFS_BLOCK_OPS\n\t.get_uuid\t\t= xfs_fs_get_uuid,\n\t.map_blocks\t\t= xfs_fs_map_blocks,\n\t.commit_blocks\t\t= xfs_fs_commit_blocks,\n#endif\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}