{
  "module_name": "fscounters.c",
  "hash_id": "97e769c6dbea9a1a4def15d59603a32a7f217856cc3fcee6e521db9fa7cb1710",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/fscounters.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_health.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_icache.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/common.h\"\n#include \"scrub/trace.h\"\n\n \n\nstruct xchk_fscounters {\n\tstruct xfs_scrub\t*sc;\n\tuint64_t\t\ticount;\n\tuint64_t\t\tifree;\n\tuint64_t\t\tfdblocks;\n\tuint64_t\t\tfrextents;\n\tunsigned long long\ticount_min;\n\tunsigned long long\ticount_max;\n\tbool\t\t\tfrozen;\n};\n\n \n#define XCHK_FSCOUNT_MIN_VARIANCE\t(512)\n\n \nSTATIC int\nxchk_fscount_warmup(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\tstruct xfs_buf\t\t*agi_bp = NULL;\n\tstruct xfs_buf\t\t*agf_bp = NULL;\n\tstruct xfs_perag\t*pag = NULL;\n\txfs_agnumber_t\t\tagno;\n\tint\t\t\terror = 0;\n\n\tfor_each_perag(mp, agno, pag) {\n\t\tif (xchk_should_terminate(sc, &error))\n\t\t\tbreak;\n\t\tif (xfs_perag_initialised_agi(pag) &&\n\t\t    xfs_perag_initialised_agf(pag))\n\t\t\tcontinue;\n\n\t\t \n\t\terror = xfs_ialloc_read_agi(pag, sc->tp, &agi_bp);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = xfs_alloc_read_agf(pag, sc->tp, 0, &agf_bp);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!xfs_perag_initialised_agi(pag) ||\n\t\t    !xfs_perag_initialised_agf(pag)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tbreak;\n\t\t}\n\n\t\txfs_buf_relse(agf_bp);\n\t\tagf_bp = NULL;\n\t\txfs_buf_relse(agi_bp);\n\t\tagi_bp = NULL;\n\t}\n\n\tif (agf_bp)\n\t\txfs_buf_relse(agf_bp);\n\tif (agi_bp)\n\t\txfs_buf_relse(agi_bp);\n\tif (pag)\n\t\txfs_perag_rele(pag);\n\treturn error;\n}\n\nstatic inline int\nxchk_fsfreeze(\n\tstruct xfs_scrub\t*sc)\n{\n\tint\t\t\terror;\n\n\terror = freeze_super(sc->mp->m_super, FREEZE_HOLDER_KERNEL);\n\ttrace_xchk_fsfreeze(sc, error);\n\treturn error;\n}\n\nstatic inline int\nxchk_fsthaw(\n\tstruct xfs_scrub\t*sc)\n{\n\tint\t\t\terror;\n\n\t \n\terror = thaw_super(sc->mp->m_super, FREEZE_HOLDER_KERNEL);\n\ttrace_xchk_fsthaw(sc, error);\n\treturn error;\n}\n\n \nSTATIC int\nxchk_fscounters_freeze(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xchk_fscounters\t*fsc = sc->buf;\n\tint\t\t\terror = 0;\n\n\tif (sc->flags & XCHK_HAVE_FREEZE_PROT) {\n\t\tsc->flags &= ~XCHK_HAVE_FREEZE_PROT;\n\t\tmnt_drop_write_file(sc->file);\n\t}\n\n\t \n\twhile ((error = xchk_fsfreeze(sc)) == -EBUSY) {\n\t\tif (xchk_should_terminate(sc, &error))\n\t\t\treturn error;\n\n\t\tdelay(HZ / 10);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tfsc->frozen = true;\n\treturn 0;\n}\n\n \nSTATIC void\nxchk_fscounters_cleanup(\n\tvoid\t\t\t*buf)\n{\n\tstruct xchk_fscounters\t*fsc = buf;\n\tstruct xfs_scrub\t*sc = fsc->sc;\n\tint\t\t\terror;\n\n\tif (!fsc->frozen)\n\t\treturn;\n\n\terror = xchk_fsthaw(sc);\n\tif (error)\n\t\txfs_emerg(sc->mp, \"still frozen after scrub, err=%d\", error);\n\telse\n\t\tfsc->frozen = false;\n}\n\nint\nxchk_setup_fscounters(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xchk_fscounters\t*fsc;\n\tint\t\t\terror;\n\n\t \n\tif (!xfs_has_lazysbcount(sc->mp))\n\t\txchk_fsgates_enable(sc, XCHK_FSGATES_DRAIN);\n\n\tsc->buf = kzalloc(sizeof(struct xchk_fscounters), XCHK_GFP_FLAGS);\n\tif (!sc->buf)\n\t\treturn -ENOMEM;\n\tsc->buf_cleanup = xchk_fscounters_cleanup;\n\tfsc = sc->buf;\n\tfsc->sc = sc;\n\n\txfs_icount_range(sc->mp, &fsc->icount_min, &fsc->icount_max);\n\n\t \n\terror = xchk_fscount_warmup(sc);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (sc->flags & XCHK_TRY_HARDER) {\n\t\terror = xchk_fscounters_freeze(sc);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn xfs_trans_alloc_empty(sc->mp, &sc->tp);\n}\n\n \n\n \nstatic int\nxchk_fscount_btreeblks(\n\tstruct xfs_scrub\t*sc,\n\tstruct xchk_fscounters\t*fsc,\n\txfs_agnumber_t\t\tagno)\n{\n\txfs_extlen_t\t\tblocks;\n\tint\t\t\terror;\n\n\terror = xchk_ag_init_existing(sc, agno, &sc->sa);\n\tif (error)\n\t\tgoto out_free;\n\n\terror = xfs_btree_count_blocks(sc->sa.bno_cur, &blocks);\n\tif (error)\n\t\tgoto out_free;\n\tfsc->fdblocks += blocks - 1;\n\n\terror = xfs_btree_count_blocks(sc->sa.cnt_cur, &blocks);\n\tif (error)\n\t\tgoto out_free;\n\tfsc->fdblocks += blocks - 1;\n\nout_free:\n\txchk_ag_free(sc, &sc->sa);\n\treturn error;\n}\n\n \nSTATIC int\nxchk_fscount_aggregate_agcounts(\n\tstruct xfs_scrub\t*sc,\n\tstruct xchk_fscounters\t*fsc)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\tstruct xfs_perag\t*pag;\n\tuint64_t\t\tdelayed;\n\txfs_agnumber_t\t\tagno;\n\tint\t\t\ttries = 8;\n\tint\t\t\terror = 0;\n\nretry:\n\tfsc->icount = 0;\n\tfsc->ifree = 0;\n\tfsc->fdblocks = 0;\n\n\tfor_each_perag(mp, agno, pag) {\n\t\tif (xchk_should_terminate(sc, &error))\n\t\t\tbreak;\n\n\t\t \n\t\tif (!xfs_perag_initialised_agi(pag) ||\n\t\t    !xfs_perag_initialised_agf(pag)) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tfsc->icount += pag->pagi_count;\n\t\tfsc->ifree += pag->pagi_freecount;\n\n\t\t \n\t\tfsc->fdblocks += pag->pagf_freeblks;\n\t\tfsc->fdblocks += pag->pagf_flcount;\n\t\tif (xfs_has_lazysbcount(sc->mp)) {\n\t\t\tfsc->fdblocks += pag->pagf_btreeblks;\n\t\t} else {\n\t\t\terror = xchk_fscount_btreeblks(sc, fsc, agno);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tfsc->fdblocks -= pag->pag_meta_resv.ar_reserved;\n\t\tfsc->fdblocks -= pag->pag_rmapbt_resv.ar_orig_reserved;\n\n\t}\n\tif (pag)\n\t\txfs_perag_rele(pag);\n\tif (error) {\n\t\txchk_set_incomplete(sc);\n\t\treturn error;\n\t}\n\n\t \n\tfsc->fdblocks -= mp->m_resblks_avail;\n\n\t \n\tdelayed = percpu_counter_sum(&mp->m_delalloc_blks);\n\tfsc->fdblocks -= delayed;\n\n\ttrace_xchk_fscounters_calc(mp, fsc->icount, fsc->ifree, fsc->fdblocks,\n\t\t\tdelayed);\n\n\n\t \n\tif (fsc->icount < fsc->icount_min || fsc->icount > fsc->icount_max ||\n\t    fsc->fdblocks > mp->m_sb.sb_dblocks ||\n\t    fsc->ifree > fsc->icount_max)\n\t\treturn -EFSCORRUPTED;\n\n\t \n\tif (fsc->ifree > fsc->icount) {\n\t\tif (tries--)\n\t\t\tgoto retry;\n\t\treturn -EDEADLOCK;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_XFS_RT\nSTATIC int\nxchk_fscount_add_frextent(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_trans\t\t*tp,\n\tconst struct xfs_rtalloc_rec\t*rec,\n\tvoid\t\t\t\t*priv)\n{\n\tstruct xchk_fscounters\t\t*fsc = priv;\n\tint\t\t\t\terror = 0;\n\n\tfsc->frextents += rec->ar_extcount;\n\n\txchk_should_terminate(fsc->sc, &error);\n\treturn error;\n}\n\n \nSTATIC int\nxchk_fscount_count_frextents(\n\tstruct xfs_scrub\t*sc,\n\tstruct xchk_fscounters\t*fsc)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\tint\t\t\terror;\n\n\tfsc->frextents = 0;\n\tif (!xfs_has_realtime(mp))\n\t\treturn 0;\n\n\txfs_ilock(sc->mp->m_rbmip, XFS_ILOCK_SHARED | XFS_ILOCK_RTBITMAP);\n\terror = xfs_rtalloc_query_all(sc->mp, sc->tp,\n\t\t\txchk_fscount_add_frextent, fsc);\n\tif (error) {\n\t\txchk_set_incomplete(sc);\n\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\txfs_iunlock(sc->mp->m_rbmip, XFS_ILOCK_SHARED | XFS_ILOCK_RTBITMAP);\n\treturn error;\n}\n#else\nSTATIC int\nxchk_fscount_count_frextents(\n\tstruct xfs_scrub\t*sc,\n\tstruct xchk_fscounters\t*fsc)\n{\n\tfsc->frextents = 0;\n\treturn 0;\n}\n#endif  \n\n \n\n \nstatic inline bool\nxchk_fscount_within_range(\n\tstruct xfs_scrub\t*sc,\n\tconst int64_t\t\told_value,\n\tstruct percpu_counter\t*counter,\n\tuint64_t\t\texpected)\n{\n\tint64_t\t\t\tmin_value, max_value;\n\tint64_t\t\t\tcurr_value = percpu_counter_sum(counter);\n\n\ttrace_xchk_fscounters_within_range(sc->mp, expected, curr_value,\n\t\t\told_value);\n\n\t \n\tif (curr_value < 0)\n\t\treturn false;\n\n\t \n\tif (curr_value == expected)\n\t\treturn true;\n\n\tmin_value = min(old_value, curr_value);\n\tmax_value = max(old_value, curr_value);\n\n\t \n\tif (expected >= min_value && expected <= max_value)\n\t\treturn true;\n\n\t \n\treturn false;\n}\n\n \nint\nxchk_fscounters(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\tstruct xchk_fscounters\t*fsc = sc->buf;\n\tint64_t\t\t\ticount, ifree, fdblocks, frextents;\n\tbool\t\t\ttry_again = false;\n\tint\t\t\terror;\n\n\t \n\ticount = percpu_counter_sum(&mp->m_icount);\n\tifree = percpu_counter_sum(&mp->m_ifree);\n\tfdblocks = percpu_counter_sum(&mp->m_fdblocks);\n\tfrextents = percpu_counter_sum(&mp->m_frextents);\n\n\t \n\tif (icount < 0 || ifree < 0)\n\t\txchk_set_corrupt(sc);\n\n\t \n\tif (fdblocks < 0 || frextents < 0) {\n\t\tif (!fsc->frozen)\n\t\t\treturn -EDEADLOCK;\n\n\t\txchk_set_corrupt(sc);\n\t\treturn 0;\n\t}\n\n\t \n\tif (icount < fsc->icount_min || icount > fsc->icount_max)\n\t\txchk_set_corrupt(sc);\n\n\t \n\tif (fdblocks > mp->m_sb.sb_dblocks)\n\t\txchk_set_corrupt(sc);\n\n\t \n\tif (frextents > mp->m_sb.sb_rextents)\n\t\txchk_set_corrupt(sc);\n\n\t \n\tif (ifree > icount && ifree - icount > XCHK_FSCOUNT_MIN_VARIANCE)\n\t\txchk_set_corrupt(sc);\n\n\t \n\terror = xchk_fscount_aggregate_agcounts(sc, fsc);\n\tif (!xchk_process_error(sc, 0, XFS_SB_BLOCK(mp), &error))\n\t\treturn error;\n\n\t \n\terror = xchk_fscount_count_frextents(sc, fsc);\n\tif (!xchk_process_error(sc, 0, XFS_SB_BLOCK(mp), &error))\n\t\treturn error;\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_INCOMPLETE)\n\t\treturn 0;\n\n\t \n\tif (!xchk_fscount_within_range(sc, icount, &mp->m_icount,\n\t\t\t\tfsc->icount)) {\n\t\tif (fsc->frozen)\n\t\t\txchk_set_corrupt(sc);\n\t\telse\n\t\t\ttry_again = true;\n\t}\n\n\tif (!xchk_fscount_within_range(sc, ifree, &mp->m_ifree, fsc->ifree)) {\n\t\tif (fsc->frozen)\n\t\t\txchk_set_corrupt(sc);\n\t\telse\n\t\t\ttry_again = true;\n\t}\n\n\tif (!xchk_fscount_within_range(sc, fdblocks, &mp->m_fdblocks,\n\t\t\tfsc->fdblocks)) {\n\t\tif (fsc->frozen)\n\t\t\txchk_set_corrupt(sc);\n\t\telse\n\t\t\ttry_again = true;\n\t}\n\n\tif (!xchk_fscount_within_range(sc, frextents, &mp->m_frextents,\n\t\t\tfsc->frextents)) {\n\t\tif (fsc->frozen)\n\t\t\txchk_set_corrupt(sc);\n\t\telse\n\t\t\ttry_again = true;\n\t}\n\n\tif (try_again)\n\t\treturn -EDEADLOCK;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}