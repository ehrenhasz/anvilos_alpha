{
  "module_name": "xfile.c",
  "hash_id": "db3ebd25f9f1e86635c2afe93f8880cc78cd0601e41a908c7dcf2641d7f74604",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/xfile.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"scrub/xfile.h\"\n#include \"scrub/xfarray.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/trace.h\"\n#include <linux/shmem_fs.h>\n\n \n\n \nstatic struct lock_class_key xfile_i_mutex_key;\n\n \nint\nxfile_create(\n\tconst char\t\t*description,\n\tloff_t\t\t\tisize,\n\tstruct xfile\t\t**xfilep)\n{\n\tstruct inode\t\t*inode;\n\tstruct xfile\t\t*xf;\n\tint\t\t\terror = -ENOMEM;\n\n\txf = kmalloc(sizeof(struct xfile), XCHK_GFP_FLAGS);\n\tif (!xf)\n\t\treturn -ENOMEM;\n\n\txf->file = shmem_file_setup(description, isize, 0);\n\tif (!xf->file)\n\t\tgoto out_xfile;\n\tif (IS_ERR(xf->file)) {\n\t\terror = PTR_ERR(xf->file);\n\t\tgoto out_xfile;\n\t}\n\n\t \n\txf->file->f_mode |= FMODE_PREAD | FMODE_PWRITE | FMODE_NOCMTIME |\n\t\t\t    FMODE_LSEEK;\n\txf->file->f_flags |= O_RDWR | O_LARGEFILE | O_NOATIME;\n\tinode = file_inode(xf->file);\n\tinode->i_flags |= S_PRIVATE | S_NOCMTIME | S_NOATIME;\n\tinode->i_mode &= ~0177;\n\tinode->i_uid = GLOBAL_ROOT_UID;\n\tinode->i_gid = GLOBAL_ROOT_GID;\n\n\tlockdep_set_class(&inode->i_rwsem, &xfile_i_mutex_key);\n\n\ttrace_xfile_create(xf);\n\n\t*xfilep = xf;\n\treturn 0;\nout_xfile:\n\tkfree(xf);\n\treturn error;\n}\n\n \nvoid\nxfile_destroy(\n\tstruct xfile\t\t*xf)\n{\n\tstruct inode\t\t*inode = file_inode(xf->file);\n\n\ttrace_xfile_destroy(xf);\n\n\tlockdep_set_class(&inode->i_rwsem, &inode->i_sb->s_type->i_mutex_key);\n\tfput(xf->file);\n\tkfree(xf);\n}\n\n \nssize_t\nxfile_pread(\n\tstruct xfile\t\t*xf,\n\tvoid\t\t\t*buf,\n\tsize_t\t\t\tcount,\n\tloff_t\t\t\tpos)\n{\n\tstruct inode\t\t*inode = file_inode(xf->file);\n\tstruct address_space\t*mapping = inode->i_mapping;\n\tstruct page\t\t*page = NULL;\n\tssize_t\t\t\tread = 0;\n\tunsigned int\t\tpflags;\n\tint\t\t\terror = 0;\n\n\tif (count > MAX_RW_COUNT)\n\t\treturn -E2BIG;\n\tif (inode->i_sb->s_maxbytes - pos < count)\n\t\treturn -EFBIG;\n\n\ttrace_xfile_pread(xf, pos, count);\n\n\tpflags = memalloc_nofs_save();\n\twhile (count > 0) {\n\t\tvoid\t\t*p, *kaddr;\n\t\tunsigned int\tlen;\n\n\t\tlen = min_t(ssize_t, count, PAGE_SIZE - offset_in_page(pos));\n\n\t\t \n\t\tpage = shmem_read_mapping_page_gfp(mapping, pos >> PAGE_SHIFT,\n\t\t\t\t__GFP_NOWARN);\n\t\tif (IS_ERR(page)) {\n\t\t\terror = PTR_ERR(page);\n\t\t\tif (error != -ENOMEM)\n\t\t\t\tbreak;\n\n\t\t\tmemset(buf, 0, len);\n\t\t\tgoto advance;\n\t\t}\n\n\t\tif (PageUptodate(page)) {\n\t\t\t \n\t\t\tkaddr = kmap_local_page(page);\n\t\t\tp = kaddr + offset_in_page(pos);\n\t\t\tmemcpy(buf, p, len);\n\t\t\tkunmap_local(kaddr);\n\t\t} else {\n\t\t\tmemset(buf, 0, len);\n\t\t}\n\t\tput_page(page);\n\nadvance:\n\t\tcount -= len;\n\t\tpos += len;\n\t\tbuf += len;\n\t\tread += len;\n\t}\n\tmemalloc_nofs_restore(pflags);\n\n\tif (read > 0)\n\t\treturn read;\n\treturn error;\n}\n\n \nssize_t\nxfile_pwrite(\n\tstruct xfile\t\t*xf,\n\tconst void\t\t*buf,\n\tsize_t\t\t\tcount,\n\tloff_t\t\t\tpos)\n{\n\tstruct inode\t\t*inode = file_inode(xf->file);\n\tstruct address_space\t*mapping = inode->i_mapping;\n\tconst struct address_space_operations *aops = mapping->a_ops;\n\tstruct page\t\t*page = NULL;\n\tssize_t\t\t\twritten = 0;\n\tunsigned int\t\tpflags;\n\tint\t\t\terror = 0;\n\n\tif (count > MAX_RW_COUNT)\n\t\treturn -E2BIG;\n\tif (inode->i_sb->s_maxbytes - pos < count)\n\t\treturn -EFBIG;\n\n\ttrace_xfile_pwrite(xf, pos, count);\n\n\tpflags = memalloc_nofs_save();\n\twhile (count > 0) {\n\t\tvoid\t\t*fsdata = NULL;\n\t\tvoid\t\t*p, *kaddr;\n\t\tunsigned int\tlen;\n\t\tint\t\tret;\n\n\t\tlen = min_t(ssize_t, count, PAGE_SIZE - offset_in_page(pos));\n\n\t\t \n\t\terror = aops->write_begin(NULL, mapping, pos, len, &page,\n\t\t\t\t&fsdata);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\t \n\t\tkaddr = kmap_local_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\tmemset(kaddr, 0, PAGE_SIZE);\n\t\t\tSetPageUptodate(page);\n\t\t}\n\t\tp = kaddr + offset_in_page(pos);\n\t\tmemcpy(p, buf, len);\n\t\tkunmap_local(kaddr);\n\n\t\tret = aops->write_end(NULL, mapping, pos, len, len, page,\n\t\t\t\tfsdata);\n\t\tif (ret < 0) {\n\t\t\terror = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\twritten += ret;\n\t\tif (ret != len)\n\t\t\tbreak;\n\n\t\tcount -= ret;\n\t\tpos += ret;\n\t\tbuf += ret;\n\t}\n\tmemalloc_nofs_restore(pflags);\n\n\tif (written > 0)\n\t\treturn written;\n\treturn error;\n}\n\n \nloff_t\nxfile_seek_data(\n\tstruct xfile\t\t*xf,\n\tloff_t\t\t\tpos)\n{\n\tloff_t\t\t\tret;\n\n\tret = vfs_llseek(xf->file, pos, SEEK_DATA);\n\ttrace_xfile_seek_data(xf, pos, ret);\n\treturn ret;\n}\n\n \nint\nxfile_stat(\n\tstruct xfile\t\t*xf,\n\tstruct xfile_stat\t*statbuf)\n{\n\tstruct kstat\t\tks;\n\tint\t\t\terror;\n\n\terror = vfs_getattr_nosec(&xf->file->f_path, &ks,\n\t\t\tSTATX_SIZE | STATX_BLOCKS, AT_STATX_DONT_SYNC);\n\tif (error)\n\t\treturn error;\n\n\tstatbuf->size = ks.size;\n\tstatbuf->bytes = ks.blocks << SECTOR_SHIFT;\n\treturn 0;\n}\n\n \nint\nxfile_get_page(\n\tstruct xfile\t\t*xf,\n\tloff_t\t\t\tpos,\n\tunsigned int\t\tlen,\n\tstruct xfile_page\t*xfpage)\n{\n\tstruct inode\t\t*inode = file_inode(xf->file);\n\tstruct address_space\t*mapping = inode->i_mapping;\n\tconst struct address_space_operations *aops = mapping->a_ops;\n\tstruct page\t\t*page = NULL;\n\tvoid\t\t\t*fsdata = NULL;\n\tloff_t\t\t\tkey = round_down(pos, PAGE_SIZE);\n\tunsigned int\t\tpflags;\n\tint\t\t\terror;\n\n\tif (inode->i_sb->s_maxbytes - pos < len)\n\t\treturn -ENOMEM;\n\tif (len > PAGE_SIZE - offset_in_page(pos))\n\t\treturn -ENOTBLK;\n\n\ttrace_xfile_get_page(xf, pos, len);\n\n\tpflags = memalloc_nofs_save();\n\n\t \n\terror = aops->write_begin(NULL, mapping, key, PAGE_SIZE, &page,\n\t\t\t&fsdata);\n\tif (error)\n\t\tgoto out_pflags;\n\n\t \n\tif (i_size_read(inode) < pos + len)\n\t\ti_size_write(inode, pos + len);\n\n\t \n\tif (!PageUptodate(page)) {\n\t\tvoid\t*kaddr;\n\n\t\tkaddr = kmap_local_page(page);\n\t\tmemset(kaddr, 0, PAGE_SIZE);\n\t\tkunmap_local(kaddr);\n\t\tSetPageUptodate(page);\n\t}\n\n\t \n\tset_page_dirty(page);\n\tget_page(page);\n\n\txfpage->page = page;\n\txfpage->fsdata = fsdata;\n\txfpage->pos = key;\nout_pflags:\n\tmemalloc_nofs_restore(pflags);\n\treturn error;\n}\n\n \nint\nxfile_put_page(\n\tstruct xfile\t\t*xf,\n\tstruct xfile_page\t*xfpage)\n{\n\tstruct inode\t\t*inode = file_inode(xf->file);\n\tstruct address_space\t*mapping = inode->i_mapping;\n\tconst struct address_space_operations *aops = mapping->a_ops;\n\tunsigned int\t\tpflags;\n\tint\t\t\tret;\n\n\ttrace_xfile_put_page(xf, xfpage->pos, PAGE_SIZE);\n\n\t \n\tput_page(xfpage->page);\n\n\tpflags = memalloc_nofs_save();\n\tret = aops->write_end(NULL, mapping, xfpage->pos, PAGE_SIZE, PAGE_SIZE,\n\t\t\txfpage->page, xfpage->fsdata);\n\tmemalloc_nofs_restore(pflags);\n\tmemset(xfpage, 0, sizeof(struct xfile_page));\n\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != PAGE_SIZE)\n\t\treturn -EIO;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}