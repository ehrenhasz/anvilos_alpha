{
  "module_name": "bmap.c",
  "hash_id": "4514dfb366ec5c8347fc008543b34e6c6e8d7463f0fafd501fc8753d593eaa1f",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/bmap.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_rmap_btree.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/common.h\"\n#include \"scrub/btree.h\"\n#include \"xfs_ag.h\"\n\n \nint\nxchk_setup_inode_bmap(\n\tstruct xfs_scrub\t*sc)\n{\n\tint\t\t\terror;\n\n\tif (xchk_need_intent_drain(sc))\n\t\txchk_fsgates_enable(sc, XCHK_FSGATES_DRAIN);\n\n\terror = xchk_iget_for_scrubbing(sc);\n\tif (error)\n\t\tgoto out;\n\n\txchk_ilock(sc, XFS_IOLOCK_EXCL);\n\n\t \n\tif (S_ISREG(VFS_I(sc->ip)->i_mode) &&\n\t    sc->sm->sm_type != XFS_SCRUB_TYPE_BMBTA) {\n\t\tstruct address_space\t*mapping = VFS_I(sc->ip)->i_mapping;\n\n\t\txchk_ilock(sc, XFS_MMAPLOCK_EXCL);\n\n\t\tinode_dio_wait(VFS_I(sc->ip));\n\n\t\t \n\t\terror = filemap_fdatawrite(mapping);\n\t\tif (!error)\n\t\t\terror = filemap_fdatawait_keep_errors(mapping);\n\t\tif (error && (error != -ENOSPC && error != -EIO))\n\t\t\tgoto out;\n\t}\n\n\t \n\terror = xchk_trans_alloc(sc, 0);\n\tif (error)\n\t\tgoto out;\n\n\txchk_ilock(sc, XFS_ILOCK_EXCL);\nout:\n\t \n\treturn error;\n}\n\n \n\nstruct xchk_bmap_info {\n\tstruct xfs_scrub\t*sc;\n\n\t \n\tstruct xfs_iext_cursor\ticur;\n\n\t \n\tstruct xfs_bmbt_irec\tprev_rec;\n\n\t \n\tbool\t\t\tis_rt;\n\n\t \n\tbool\t\t\tis_shared;\n\n\t \n\tbool\t\t\twas_loaded;\n\n\t \n\tint\t\t\twhichfork;\n};\n\n \nstatic inline bool\nxchk_bmap_get_rmap(\n\tstruct xchk_bmap_info\t*info,\n\tstruct xfs_bmbt_irec\t*irec,\n\txfs_agblock_t\t\tagbno,\n\tuint64_t\t\towner,\n\tstruct xfs_rmap_irec\t*rmap)\n{\n\txfs_fileoff_t\t\toffset;\n\tunsigned int\t\trflags = 0;\n\tint\t\t\thas_rmap;\n\tint\t\t\terror;\n\n\tif (info->whichfork == XFS_ATTR_FORK)\n\t\trflags |= XFS_RMAP_ATTR_FORK;\n\tif (irec->br_state == XFS_EXT_UNWRITTEN)\n\t\trflags |= XFS_RMAP_UNWRITTEN;\n\n\t \n\tif (info->whichfork == XFS_COW_FORK)\n\t\toffset = 0;\n\telse\n\t\toffset = irec->br_startoff;\n\n\t \n\tif (info->is_shared) {\n\t\terror = xfs_rmap_lookup_le_range(info->sc->sa.rmap_cur, agbno,\n\t\t\t\towner, offset, rflags, rmap, &has_rmap);\n\t} else {\n\t\terror = xfs_rmap_lookup_le(info->sc->sa.rmap_cur, agbno,\n\t\t\t\towner, offset, rflags, rmap, &has_rmap);\n\t}\n\tif (!xchk_should_check_xref(info->sc, &error, &info->sc->sa.rmap_cur))\n\t\treturn false;\n\n\tif (!has_rmap)\n\t\txchk_fblock_xref_set_corrupt(info->sc, info->whichfork,\n\t\t\tirec->br_startoff);\n\treturn has_rmap;\n}\n\n \nSTATIC void\nxchk_bmap_xref_rmap(\n\tstruct xchk_bmap_info\t*info,\n\tstruct xfs_bmbt_irec\t*irec,\n\txfs_agblock_t\t\tagbno)\n{\n\tstruct xfs_rmap_irec\trmap;\n\tunsigned long long\trmap_end;\n\tuint64_t\t\towner = info->sc->ip->i_ino;\n\n\tif (!info->sc->sa.rmap_cur || xchk_skip_xref(info->sc->sm))\n\t\treturn;\n\n\t \n\tif (!xchk_bmap_get_rmap(info, irec, agbno, owner, &rmap))\n\t\treturn;\n\n\t \n\tif (rmap.rm_startblock != agbno)\n\t\txchk_fblock_xref_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\n\trmap_end = (unsigned long long)rmap.rm_startblock + rmap.rm_blockcount;\n\tif (rmap_end != agbno + irec->br_blockcount)\n\t\txchk_fblock_xref_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\n\t \n\tif (rmap.rm_offset != irec->br_startoff)\n\t\txchk_fblock_xref_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\n\trmap_end = (unsigned long long)rmap.rm_offset + rmap.rm_blockcount;\n\tif (rmap_end != irec->br_startoff + irec->br_blockcount)\n\t\txchk_fblock_xref_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\n\t \n\tif (rmap.rm_owner != owner)\n\t\txchk_fblock_xref_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\n\t \n\tif (!!(irec->br_state == XFS_EXT_UNWRITTEN) !=\n\t    !!(rmap.rm_flags & XFS_RMAP_UNWRITTEN))\n\t\txchk_fblock_xref_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\n\tif (!!(info->whichfork == XFS_ATTR_FORK) !=\n\t    !!(rmap.rm_flags & XFS_RMAP_ATTR_FORK))\n\t\txchk_fblock_xref_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\tif (rmap.rm_flags & XFS_RMAP_BMBT_BLOCK)\n\t\txchk_fblock_xref_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n}\n\n \nSTATIC void\nxchk_bmap_xref_rmap_cow(\n\tstruct xchk_bmap_info\t*info,\n\tstruct xfs_bmbt_irec\t*irec,\n\txfs_agblock_t\t\tagbno)\n{\n\tstruct xfs_rmap_irec\trmap;\n\tunsigned long long\trmap_end;\n\tuint64_t\t\towner = XFS_RMAP_OWN_COW;\n\n\tif (!info->sc->sa.rmap_cur || xchk_skip_xref(info->sc->sm))\n\t\treturn;\n\n\t \n\tif (!xchk_bmap_get_rmap(info, irec, agbno, owner, &rmap))\n\t\treturn;\n\n\t \n\tif (rmap.rm_startblock > agbno)\n\t\txchk_fblock_xref_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\n\trmap_end = (unsigned long long)rmap.rm_startblock + rmap.rm_blockcount;\n\tif (rmap_end < agbno + irec->br_blockcount)\n\t\txchk_fblock_xref_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\n\t \n\tif (rmap.rm_owner != owner)\n\t\txchk_fblock_xref_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\n\t \n\tif (rmap.rm_flags & XFS_RMAP_ATTR_FORK)\n\t\txchk_fblock_xref_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\tif (rmap.rm_flags & XFS_RMAP_BMBT_BLOCK)\n\t\txchk_fblock_xref_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\tif (rmap.rm_flags & XFS_RMAP_UNWRITTEN)\n\t\txchk_fblock_xref_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n}\n\n \nSTATIC void\nxchk_bmap_rt_iextent_xref(\n\tstruct xfs_inode\t*ip,\n\tstruct xchk_bmap_info\t*info,\n\tstruct xfs_bmbt_irec\t*irec)\n{\n\txchk_xref_is_used_rt_space(info->sc, irec->br_startblock,\n\t\t\tirec->br_blockcount);\n}\n\n \nSTATIC void\nxchk_bmap_iextent_xref(\n\tstruct xfs_inode\t*ip,\n\tstruct xchk_bmap_info\t*info,\n\tstruct xfs_bmbt_irec\t*irec)\n{\n\tstruct xfs_owner_info\toinfo;\n\tstruct xfs_mount\t*mp = info->sc->mp;\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\txfs_extlen_t\t\tlen;\n\tint\t\t\terror;\n\n\tagno = XFS_FSB_TO_AGNO(mp, irec->br_startblock);\n\tagbno = XFS_FSB_TO_AGBNO(mp, irec->br_startblock);\n\tlen = irec->br_blockcount;\n\n\terror = xchk_ag_init_existing(info->sc, agno, &info->sc->sa);\n\tif (!xchk_fblock_process_error(info->sc, info->whichfork,\n\t\t\tirec->br_startoff, &error))\n\t\tgoto out_free;\n\n\txchk_xref_is_used_space(info->sc, agbno, len);\n\txchk_xref_is_not_inode_chunk(info->sc, agbno, len);\n\tswitch (info->whichfork) {\n\tcase XFS_DATA_FORK:\n\t\txchk_bmap_xref_rmap(info, irec, agbno);\n\t\tif (!xfs_is_reflink_inode(info->sc->ip)) {\n\t\t\txfs_rmap_ino_owner(&oinfo, info->sc->ip->i_ino,\n\t\t\t\t\tinfo->whichfork, irec->br_startoff);\n\t\t\txchk_xref_is_only_owned_by(info->sc, agbno,\n\t\t\t\t\tirec->br_blockcount, &oinfo);\n\t\t\txchk_xref_is_not_shared(info->sc, agbno,\n\t\t\t\t\tirec->br_blockcount);\n\t\t}\n\t\txchk_xref_is_not_cow_staging(info->sc, agbno,\n\t\t\t\tirec->br_blockcount);\n\t\tbreak;\n\tcase XFS_ATTR_FORK:\n\t\txchk_bmap_xref_rmap(info, irec, agbno);\n\t\txfs_rmap_ino_owner(&oinfo, info->sc->ip->i_ino,\n\t\t\t\tinfo->whichfork, irec->br_startoff);\n\t\txchk_xref_is_only_owned_by(info->sc, agbno, irec->br_blockcount,\n\t\t\t\t&oinfo);\n\t\txchk_xref_is_not_shared(info->sc, agbno,\n\t\t\t\tirec->br_blockcount);\n\t\txchk_xref_is_not_cow_staging(info->sc, agbno,\n\t\t\t\tirec->br_blockcount);\n\t\tbreak;\n\tcase XFS_COW_FORK:\n\t\txchk_bmap_xref_rmap_cow(info, irec, agbno);\n\t\txchk_xref_is_only_owned_by(info->sc, agbno, irec->br_blockcount,\n\t\t\t\t&XFS_RMAP_OINFO_COW);\n\t\txchk_xref_is_cow_staging(info->sc, agbno,\n\t\t\t\tirec->br_blockcount);\n\t\txchk_xref_is_not_shared(info->sc, agbno,\n\t\t\t\tirec->br_blockcount);\n\t\tbreak;\n\t}\n\nout_free:\n\txchk_ag_free(info->sc, &info->sc->sa);\n}\n\n \nSTATIC void\nxchk_bmap_dirattr_extent(\n\tstruct xfs_inode\t*ip,\n\tstruct xchk_bmap_info\t*info,\n\tstruct xfs_bmbt_irec\t*irec)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\toff;\n\n\tif (!S_ISDIR(VFS_I(ip)->i_mode) && info->whichfork != XFS_ATTR_FORK)\n\t\treturn;\n\n\tif (!xfs_verify_dablk(mp, irec->br_startoff))\n\t\txchk_fblock_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\n\toff = irec->br_startoff + irec->br_blockcount - 1;\n\tif (!xfs_verify_dablk(mp, off))\n\t\txchk_fblock_set_corrupt(info->sc, info->whichfork, off);\n}\n\n \nSTATIC void\nxchk_bmap_iextent(\n\tstruct xfs_inode\t*ip,\n\tstruct xchk_bmap_info\t*info,\n\tstruct xfs_bmbt_irec\t*irec)\n{\n\tstruct xfs_mount\t*mp = info->sc->mp;\n\n\t \n\tif (irec->br_startoff < info->prev_rec.br_startoff +\n\t\t\t\tinfo->prev_rec.br_blockcount)\n\t\txchk_fblock_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\n\tif (!xfs_verify_fileext(mp, irec->br_startoff, irec->br_blockcount))\n\t\txchk_fblock_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\n\txchk_bmap_dirattr_extent(ip, info, irec);\n\n\t \n\tif (info->is_rt &&\n\t    !xfs_verify_rtext(mp, irec->br_startblock, irec->br_blockcount))\n\t\txchk_fblock_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\tif (!info->is_rt &&\n\t    !xfs_verify_fsbext(mp, irec->br_startblock, irec->br_blockcount))\n\t\txchk_fblock_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\n\t \n\tif (irec->br_state == XFS_EXT_UNWRITTEN &&\n\t    info->whichfork == XFS_ATTR_FORK)\n\t\txchk_fblock_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\n\tif (info->sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn;\n\n\tif (info->is_rt)\n\t\txchk_bmap_rt_iextent_xref(ip, info, irec);\n\telse\n\t\txchk_bmap_iextent_xref(ip, info, irec);\n}\n\n \nSTATIC int\nxchk_bmapbt_rec(\n\tstruct xchk_btree\t*bs,\n\tconst union xfs_btree_rec *rec)\n{\n\tstruct xfs_bmbt_irec\tirec;\n\tstruct xfs_bmbt_irec\tiext_irec;\n\tstruct xfs_iext_cursor\ticur;\n\tstruct xchk_bmap_info\t*info = bs->private;\n\tstruct xfs_inode\t*ip = bs->cur->bc_ino.ip;\n\tstruct xfs_buf\t\t*bp = NULL;\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, info->whichfork);\n\tuint64_t\t\towner;\n\tint\t\t\ti;\n\n\t \n\tif (xfs_has_crc(bs->cur->bc_mp) &&\n\t    bs->cur->bc_levels[0].ptr == 1) {\n\t\tfor (i = 0; i < bs->cur->bc_nlevels - 1; i++) {\n\t\t\tblock = xfs_btree_get_block(bs->cur, i, &bp);\n\t\t\towner = be64_to_cpu(block->bb_u.l.bb_owner);\n\t\t\tif (owner != ip->i_ino)\n\t\t\t\txchk_fblock_set_corrupt(bs->sc,\n\t\t\t\t\t\tinfo->whichfork, 0);\n\t\t}\n\t}\n\n\t \n\tif (!info->was_loaded)\n\t\treturn 0;\n\n\txfs_bmbt_disk_get_all(&rec->bmbt, &irec);\n\tif (xfs_bmap_validate_extent(ip, info->whichfork, &irec) != NULL) {\n\t\txchk_fblock_set_corrupt(bs->sc, info->whichfork,\n\t\t\t\tirec.br_startoff);\n\t\treturn 0;\n\t}\n\n\tif (!xfs_iext_lookup_extent(ip, ifp, irec.br_startoff, &icur,\n\t\t\t\t&iext_irec) ||\n\t    irec.br_startoff != iext_irec.br_startoff ||\n\t    irec.br_startblock != iext_irec.br_startblock ||\n\t    irec.br_blockcount != iext_irec.br_blockcount ||\n\t    irec.br_state != iext_irec.br_state)\n\t\txchk_fblock_set_corrupt(bs->sc, info->whichfork,\n\t\t\t\tirec.br_startoff);\n\treturn 0;\n}\n\n \nSTATIC int\nxchk_bmap_btree(\n\tstruct xfs_scrub\t*sc,\n\tint\t\t\twhichfork,\n\tstruct xchk_bmap_info\t*info)\n{\n\tstruct xfs_owner_info\toinfo;\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(sc->ip, whichfork);\n\tstruct xfs_mount\t*mp = sc->mp;\n\tstruct xfs_inode\t*ip = sc->ip;\n\tstruct xfs_btree_cur\t*cur;\n\tint\t\t\terror;\n\n\t \n\tinfo->was_loaded = !xfs_need_iread_extents(ifp);\n\n\terror = xfs_iread_extents(sc->tp, ip, whichfork);\n\tif (!xchk_fblock_process_error(sc, whichfork, 0, &error))\n\t\tgoto out;\n\n\t \n\tcur = xfs_bmbt_init_cursor(mp, sc->tp, ip, whichfork);\n\txfs_rmap_ino_bmbt_owner(&oinfo, ip->i_ino, whichfork);\n\terror = xchk_btree(sc, cur, xchk_bmapbt_rec, &oinfo, info);\n\txfs_btree_del_cursor(cur, error);\nout:\n\treturn error;\n}\n\nstruct xchk_bmap_check_rmap_info {\n\tstruct xfs_scrub\t*sc;\n\tint\t\t\twhichfork;\n\tstruct xfs_iext_cursor\ticur;\n};\n\n \nSTATIC int\nxchk_bmap_check_rmap(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst struct xfs_rmap_irec\t*rec,\n\tvoid\t\t\t\t*priv)\n{\n\tstruct xfs_bmbt_irec\t\tirec;\n\tstruct xfs_rmap_irec\t\tcheck_rec;\n\tstruct xchk_bmap_check_rmap_info\t*sbcri = priv;\n\tstruct xfs_ifork\t\t*ifp;\n\tstruct xfs_scrub\t\t*sc = sbcri->sc;\n\tbool\t\t\t\thave_map;\n\n\t \n\tif (rec->rm_owner != sc->ip->i_ino)\n\t\treturn 0;\n\tif ((sbcri->whichfork == XFS_ATTR_FORK) ^\n\t    !!(rec->rm_flags & XFS_RMAP_ATTR_FORK))\n\t\treturn 0;\n\tif (rec->rm_flags & XFS_RMAP_BMBT_BLOCK)\n\t\treturn 0;\n\n\t \n\tifp = xfs_ifork_ptr(sc->ip, sbcri->whichfork);\n\tif (!ifp) {\n\t\txchk_fblock_set_corrupt(sc, sbcri->whichfork,\n\t\t\t\trec->rm_offset);\n\t\tgoto out;\n\t}\n\thave_map = xfs_iext_lookup_extent(sc->ip, ifp, rec->rm_offset,\n\t\t\t&sbcri->icur, &irec);\n\tif (!have_map)\n\t\txchk_fblock_set_corrupt(sc, sbcri->whichfork,\n\t\t\t\trec->rm_offset);\n\t \n\tcheck_rec = *rec;\n\twhile (have_map) {\n\t\tif (irec.br_startoff != check_rec.rm_offset)\n\t\t\txchk_fblock_set_corrupt(sc, sbcri->whichfork,\n\t\t\t\t\tcheck_rec.rm_offset);\n\t\tif (irec.br_startblock != XFS_AGB_TO_FSB(sc->mp,\n\t\t\t\tcur->bc_ag.pag->pag_agno,\n\t\t\t\tcheck_rec.rm_startblock))\n\t\t\txchk_fblock_set_corrupt(sc, sbcri->whichfork,\n\t\t\t\t\tcheck_rec.rm_offset);\n\t\tif (irec.br_blockcount > check_rec.rm_blockcount)\n\t\t\txchk_fblock_set_corrupt(sc, sbcri->whichfork,\n\t\t\t\t\tcheck_rec.rm_offset);\n\t\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\t\tbreak;\n\t\tcheck_rec.rm_startblock += irec.br_blockcount;\n\t\tcheck_rec.rm_offset += irec.br_blockcount;\n\t\tcheck_rec.rm_blockcount -= irec.br_blockcount;\n\t\tif (check_rec.rm_blockcount == 0)\n\t\t\tbreak;\n\t\thave_map = xfs_iext_next_extent(ifp, &sbcri->icur, &irec);\n\t\tif (!have_map)\n\t\t\txchk_fblock_set_corrupt(sc, sbcri->whichfork,\n\t\t\t\t\tcheck_rec.rm_offset);\n\t}\n\nout:\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn -ECANCELED;\n\treturn 0;\n}\n\n \nSTATIC int\nxchk_bmap_check_ag_rmaps(\n\tstruct xfs_scrub\t\t*sc,\n\tint\t\t\t\twhichfork,\n\tstruct xfs_perag\t\t*pag)\n{\n\tstruct xchk_bmap_check_rmap_info\tsbcri;\n\tstruct xfs_btree_cur\t\t*cur;\n\tstruct xfs_buf\t\t\t*agf;\n\tint\t\t\t\terror;\n\n\terror = xfs_alloc_read_agf(pag, sc->tp, 0, &agf);\n\tif (error)\n\t\treturn error;\n\n\tcur = xfs_rmapbt_init_cursor(sc->mp, sc->tp, agf, pag);\n\n\tsbcri.sc = sc;\n\tsbcri.whichfork = whichfork;\n\terror = xfs_rmap_query_all(cur, xchk_bmap_check_rmap, &sbcri);\n\tif (error == -ECANCELED)\n\t\terror = 0;\n\n\txfs_btree_del_cursor(cur, error);\n\txfs_trans_brelse(sc->tp, agf);\n\treturn error;\n}\n\n \nstatic bool\nxchk_bmap_want_check_rmaps(\n\tstruct xchk_bmap_info\t*info)\n{\n\tstruct xfs_scrub\t*sc = info->sc;\n\tstruct xfs_ifork\t*ifp;\n\n\tif (!xfs_has_rmapbt(sc->mp))\n\t\treturn false;\n\tif (info->whichfork == XFS_COW_FORK)\n\t\treturn false;\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn false;\n\n\t \n\tif (info->is_rt)\n\t\treturn false;\n\n\t \n\tifp = xfs_ifork_ptr(sc->ip, info->whichfork);\n\tif (ifp->if_format == XFS_DINODE_FMT_EXTENTS && ifp->if_nextents == 0) {\n\t\tif (info->whichfork == XFS_DATA_FORK &&\n\t\t    i_size_read(VFS_I(sc->ip)) == 0)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nSTATIC int\nxchk_bmap_check_rmaps(\n\tstruct xfs_scrub\t*sc,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_perag\t*pag;\n\txfs_agnumber_t\t\tagno;\n\tint\t\t\terror;\n\n\tfor_each_perag(sc->mp, agno, pag) {\n\t\terror = xchk_bmap_check_ag_rmaps(sc, whichfork, pag);\n\t\tif (error ||\n\t\t    (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)) {\n\t\t\txfs_perag_rele(pag);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nSTATIC void\nxchk_bmap_iextent_delalloc(\n\tstruct xfs_inode\t*ip,\n\tstruct xchk_bmap_info\t*info,\n\tstruct xfs_bmbt_irec\t*irec)\n{\n\tstruct xfs_mount\t*mp = info->sc->mp;\n\n\t \n\tif (irec->br_startoff < info->prev_rec.br_startoff +\n\t\t\t\tinfo->prev_rec.br_blockcount)\n\t\txchk_fblock_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\n\tif (!xfs_verify_fileext(mp, irec->br_startoff, irec->br_blockcount))\n\t\txchk_fblock_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\n\t \n\tif (irec->br_blockcount > XFS_MAX_BMBT_EXTLEN)\n\t\txchk_fblock_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n}\n\n \nstatic bool\nxchk_bmap_iext_mapping(\n\tstruct xchk_bmap_info\t\t*info,\n\tconst struct xfs_bmbt_irec\t*irec)\n{\n\t \n\tif (irec->br_startblock == HOLESTARTBLOCK)\n\t\treturn false;\n\tif (irec->br_blockcount > XFS_MAX_BMBT_EXTLEN)\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic inline bool\nxchk_are_bmaps_contiguous(\n\tconst struct xfs_bmbt_irec\t*b1,\n\tconst struct xfs_bmbt_irec\t*b2)\n{\n\t \n\tif (!xfs_bmap_is_real_extent(b1))\n\t\treturn false;\n\tif (!xfs_bmap_is_real_extent(b2))\n\t\treturn false;\n\n\t \n\tif (b1->br_startoff + b1->br_blockcount != b2->br_startoff)\n\t\treturn false;\n\tif (b1->br_startblock + b1->br_blockcount != b2->br_startblock)\n\t\treturn false;\n\tif (b1->br_state != b2->br_state)\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic bool\nxchk_bmap_iext_iter(\n\tstruct xchk_bmap_info\t*info,\n\tstruct xfs_bmbt_irec\t*irec)\n{\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_ifork\t*ifp;\n\tunsigned int\t\tnr = 0;\n\n\tifp = xfs_ifork_ptr(info->sc->ip, info->whichfork);\n\n\t \n\txfs_iext_next(ifp, &info->icur);\n\tif (!xfs_iext_get_extent(ifp, &info->icur, irec))\n\t\treturn false;\n\n\tif (!xchk_bmap_iext_mapping(info, irec)) {\n\t\txchk_fblock_set_corrupt(info->sc, info->whichfork,\n\t\t\t\tirec->br_startoff);\n\t\treturn false;\n\t}\n\tnr++;\n\n\t \n\twhile (xfs_iext_peek_next_extent(ifp, &info->icur, &got)) {\n\t\tif (!xchk_are_bmaps_contiguous(irec, &got))\n\t\t\tbreak;\n\n\t\tif (!xchk_bmap_iext_mapping(info, &got)) {\n\t\t\txchk_fblock_set_corrupt(info->sc, info->whichfork,\n\t\t\t\t\tgot.br_startoff);\n\t\t\treturn false;\n\t\t}\n\t\tnr++;\n\n\t\tirec->br_blockcount += got.br_blockcount;\n\t\txfs_iext_next(ifp, &info->icur);\n\t}\n\n\t \n\tif (nr > 1 && info->whichfork != XFS_COW_FORK &&\n\t    howmany_64(irec->br_blockcount, XFS_MAX_BMBT_EXTLEN) < nr)\n\t\txchk_ino_set_preen(info->sc, info->sc->ip->i_ino);\n\n\treturn true;\n}\n\n \nSTATIC int\nxchk_bmap(\n\tstruct xfs_scrub\t*sc,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\tirec;\n\tstruct xchk_bmap_info\tinfo = { NULL };\n\tstruct xfs_mount\t*mp = sc->mp;\n\tstruct xfs_inode\t*ip = sc->ip;\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\txfs_fileoff_t\t\tendoff;\n\tint\t\t\terror = 0;\n\n\t \n\tif (!ifp)\n\t\treturn -ENOENT;\n\n\tinfo.is_rt = whichfork == XFS_DATA_FORK && XFS_IS_REALTIME_INODE(ip);\n\tinfo.whichfork = whichfork;\n\tinfo.is_shared = whichfork == XFS_DATA_FORK && xfs_is_reflink_inode(ip);\n\tinfo.sc = sc;\n\n\tswitch (whichfork) {\n\tcase XFS_COW_FORK:\n\t\t \n\t\tif (!xfs_has_reflink(mp)) {\n\t\t\txchk_ino_set_corrupt(sc, sc->ip->i_ino);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase XFS_ATTR_FORK:\n\t\tif (!xfs_has_attr(mp) && !xfs_has_attr2(mp))\n\t\t\txchk_ino_set_corrupt(sc, sc->ip->i_ino);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(whichfork == XFS_DATA_FORK);\n\t\tbreak;\n\t}\n\n\t \n\tswitch (ifp->if_format) {\n\tcase XFS_DINODE_FMT_UUID:\n\tcase XFS_DINODE_FMT_DEV:\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\t \n\t\tif (whichfork == XFS_COW_FORK)\n\t\t\txchk_fblock_set_corrupt(sc, whichfork, 0);\n\t\treturn 0;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif (whichfork == XFS_COW_FORK) {\n\t\t\txchk_fblock_set_corrupt(sc, whichfork, 0);\n\t\t\treturn 0;\n\t\t}\n\n\t\terror = xchk_bmap_btree(sc, whichfork, &info);\n\t\tif (error)\n\t\t\treturn error;\n\t\tbreak;\n\tdefault:\n\t\txchk_fblock_set_corrupt(sc, whichfork, 0);\n\t\treturn 0;\n\t}\n\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn 0;\n\n\t \n\terror = xfs_bmap_last_offset(ip, &endoff, whichfork);\n\tif (!xchk_fblock_process_error(sc, whichfork, 0, &error))\n\t\treturn error;\n\n\t \n\twhile (xchk_bmap_iext_iter(&info, &irec)) {\n\t\tif (xchk_should_terminate(sc, &error) ||\n\t\t    (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT))\n\t\t\treturn 0;\n\n\t\tif (irec.br_startoff >= endoff) {\n\t\t\txchk_fblock_set_corrupt(sc, whichfork,\n\t\t\t\t\tirec.br_startoff);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (isnullstartblock(irec.br_startblock))\n\t\t\txchk_bmap_iextent_delalloc(ip, &info, &irec);\n\t\telse\n\t\t\txchk_bmap_iextent(ip, &info, &irec);\n\t\tmemcpy(&info.prev_rec, &irec, sizeof(struct xfs_bmbt_irec));\n\t}\n\n\tif (xchk_bmap_want_check_rmaps(&info)) {\n\t\terror = xchk_bmap_check_rmaps(sc, whichfork);\n\t\tif (!xchk_fblock_xref_process_error(sc, whichfork, 0, &error))\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \nint\nxchk_bmap_data(\n\tstruct xfs_scrub\t*sc)\n{\n\treturn xchk_bmap(sc, XFS_DATA_FORK);\n}\n\n \nint\nxchk_bmap_attr(\n\tstruct xfs_scrub\t*sc)\n{\n\treturn xchk_bmap(sc, XFS_ATTR_FORK);\n}\n\n \nint\nxchk_bmap_cow(\n\tstruct xfs_scrub\t*sc)\n{\n\treturn xchk_bmap(sc, XFS_COW_FORK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}