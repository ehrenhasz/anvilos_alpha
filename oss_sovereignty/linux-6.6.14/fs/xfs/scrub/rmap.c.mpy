{
  "module_name": "rmap.c",
  "hash_id": "a0bedd215edab283f0f744792ff14764f71c14637695c1a39cb8e807c97ba6e5",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/rmap.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_refcount.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_refcount_btree.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/common.h\"\n#include \"scrub/btree.h\"\n#include \"scrub/bitmap.h\"\n\n \nint\nxchk_setup_ag_rmapbt(\n\tstruct xfs_scrub\t*sc)\n{\n\tif (xchk_need_intent_drain(sc))\n\t\txchk_fsgates_enable(sc, XCHK_FSGATES_DRAIN);\n\n\treturn xchk_setup_ag_btree(sc, false);\n}\n\n \n\nstruct xchk_rmap {\n\t \n\tstruct xfs_rmap_irec\toverlap_rec;\n\n\t \n\tstruct xfs_rmap_irec\tprev_rec;\n\n\t \n\tstruct xagb_bitmap\tfs_owned;\n\tstruct xagb_bitmap\tlog_owned;\n\tstruct xagb_bitmap\tag_owned;\n\tstruct xagb_bitmap\tinobt_owned;\n\tstruct xagb_bitmap\trefcbt_owned;\n\n\t \n\tbool\t\t\tbitmaps_complete;\n};\n\n \nSTATIC void\nxchk_rmapbt_xref_refc(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_rmap_irec\t*irec)\n{\n\txfs_agblock_t\t\tfbno;\n\txfs_extlen_t\t\tflen;\n\tbool\t\t\tnon_inode;\n\tbool\t\t\tis_bmbt;\n\tbool\t\t\tis_attr;\n\tbool\t\t\tis_unwritten;\n\tint\t\t\terror;\n\n\tif (!sc->sa.refc_cur || xchk_skip_xref(sc->sm))\n\t\treturn;\n\n\tnon_inode = XFS_RMAP_NON_INODE_OWNER(irec->rm_owner);\n\tis_bmbt = irec->rm_flags & XFS_RMAP_BMBT_BLOCK;\n\tis_attr = irec->rm_flags & XFS_RMAP_ATTR_FORK;\n\tis_unwritten = irec->rm_flags & XFS_RMAP_UNWRITTEN;\n\n\t \n\terror = xfs_refcount_find_shared(sc->sa.refc_cur, irec->rm_startblock,\n\t\t\tirec->rm_blockcount, &fbno, &flen, false);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.refc_cur))\n\t\treturn;\n\tif (flen != 0 && (non_inode || is_attr || is_bmbt || is_unwritten))\n\t\txchk_btree_xref_set_corrupt(sc, sc->sa.refc_cur, 0);\n}\n\n \nSTATIC void\nxchk_rmapbt_xref(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_rmap_irec\t*irec)\n{\n\txfs_agblock_t\t\tagbno = irec->rm_startblock;\n\txfs_extlen_t\t\tlen = irec->rm_blockcount;\n\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn;\n\n\txchk_xref_is_used_space(sc, agbno, len);\n\tif (irec->rm_owner == XFS_RMAP_OWN_INODES)\n\t\txchk_xref_is_inode_chunk(sc, agbno, len);\n\telse\n\t\txchk_xref_is_not_inode_chunk(sc, agbno, len);\n\tif (irec->rm_owner == XFS_RMAP_OWN_COW)\n\t\txchk_xref_is_cow_staging(sc, irec->rm_startblock,\n\t\t\t\tirec->rm_blockcount);\n\telse\n\t\txchk_rmapbt_xref_refc(sc, irec);\n}\n\n \nSTATIC void\nxchk_rmapbt_check_unwritten_in_keyflags(\n\tstruct xchk_btree\t*bs)\n{\n\tstruct xfs_scrub\t*sc = bs->sc;\n\tstruct xfs_btree_cur\t*cur = bs->cur;\n\tstruct xfs_btree_block\t*keyblock;\n\tunion xfs_btree_key\t*lkey, *hkey;\n\t__be64\t\t\tbadflag = cpu_to_be64(XFS_RMAP_OFF_UNWRITTEN);\n\tunsigned int\t\tlevel;\n\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_PREEN)\n\t\treturn;\n\n\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\tstruct xfs_buf\t*bp;\n\t\tunsigned int\tptr;\n\n\t\t \n\t\tif (cur->bc_levels[level].ptr > 1)\n\t\t\tcontinue;\n\n\t\tkeyblock = xfs_btree_get_block(cur, level, &bp);\n\t\tfor (ptr = 1; ptr <= be16_to_cpu(keyblock->bb_numrecs); ptr++) {\n\t\t\tlkey = xfs_btree_key_addr(cur, ptr, keyblock);\n\n\t\t\tif (lkey->rmap.rm_offset & badflag) {\n\t\t\t\txchk_btree_set_preen(sc, cur, level);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\thkey = xfs_btree_high_key_addr(cur, ptr, keyblock);\n\t\t\tif (hkey->rmap.rm_offset & badflag) {\n\t\t\t\txchk_btree_set_preen(sc, cur, level);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic inline bool\nxchk_rmapbt_is_shareable(\n\tstruct xfs_scrub\t\t*sc,\n\tconst struct xfs_rmap_irec\t*irec)\n{\n\tif (!xfs_has_reflink(sc->mp))\n\t\treturn false;\n\tif (XFS_RMAP_NON_INODE_OWNER(irec->rm_owner))\n\t\treturn false;\n\tif (irec->rm_flags & (XFS_RMAP_BMBT_BLOCK | XFS_RMAP_ATTR_FORK |\n\t\t\t      XFS_RMAP_UNWRITTEN))\n\t\treturn false;\n\treturn true;\n}\n\n \nSTATIC void\nxchk_rmapbt_check_overlapping(\n\tstruct xchk_btree\t\t*bs,\n\tstruct xchk_rmap\t\t*cr,\n\tconst struct xfs_rmap_irec\t*irec)\n{\n\txfs_agblock_t\t\t\tpnext, inext;\n\n\tif (bs->sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn;\n\n\t \n\tif (cr->overlap_rec.rm_blockcount == 0)\n\t\tgoto set_prev;\n\n\t \n\tpnext = cr->overlap_rec.rm_startblock + cr->overlap_rec.rm_blockcount;\n\tif (pnext <= irec->rm_startblock)\n\t\tgoto set_prev;\n\n\t \n\tif (!xchk_rmapbt_is_shareable(bs->sc, &cr->overlap_rec) ||\n\t    !xchk_rmapbt_is_shareable(bs->sc, irec))\n\t\txchk_btree_set_corrupt(bs->sc, bs->cur, 0);\n\n\t \n\tinext = irec->rm_startblock + irec->rm_blockcount;\n\tif (pnext > inext)\n\t\treturn;\n\nset_prev:\n\tmemcpy(&cr->overlap_rec, irec, sizeof(struct xfs_rmap_irec));\n}\n\n \nstatic inline bool\nxchk_rmap_mergeable(\n\tstruct xchk_rmap\t\t*cr,\n\tconst struct xfs_rmap_irec\t*r2)\n{\n\tconst struct xfs_rmap_irec\t*r1 = &cr->prev_rec;\n\n\t \n\tif (cr->prev_rec.rm_blockcount == 0)\n\t\treturn false;\n\n\tif (r1->rm_owner != r2->rm_owner)\n\t\treturn false;\n\tif (r1->rm_startblock + r1->rm_blockcount != r2->rm_startblock)\n\t\treturn false;\n\tif ((unsigned long long)r1->rm_blockcount + r2->rm_blockcount >\n\t    XFS_RMAP_LEN_MAX)\n\t\treturn false;\n\tif (XFS_RMAP_NON_INODE_OWNER(r2->rm_owner))\n\t\treturn true;\n\t \n\tif (r1->rm_flags != r2->rm_flags)\n\t\treturn false;\n\tif (r1->rm_flags & XFS_RMAP_BMBT_BLOCK)\n\t\treturn true;\n\treturn r1->rm_offset + r1->rm_blockcount == r2->rm_offset;\n}\n\n \nSTATIC void\nxchk_rmapbt_check_mergeable(\n\tstruct xchk_btree\t\t*bs,\n\tstruct xchk_rmap\t\t*cr,\n\tconst struct xfs_rmap_irec\t*irec)\n{\n\tif (bs->sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn;\n\n\tif (xchk_rmap_mergeable(cr, irec))\n\t\txchk_btree_set_corrupt(bs->sc, bs->cur, 0);\n\n\tmemcpy(&cr->prev_rec, irec, sizeof(struct xfs_rmap_irec));\n}\n\n \nSTATIC int\nxchk_rmapbt_mark_bitmap(\n\tstruct xchk_btree\t\t*bs,\n\tstruct xchk_rmap\t\t*cr,\n\tconst struct xfs_rmap_irec\t*irec)\n{\n\tstruct xfs_scrub\t\t*sc = bs->sc;\n\tstruct xagb_bitmap\t\t*bmp = NULL;\n\txfs_extlen_t\t\t\tfsbcount = irec->rm_blockcount;\n\n\t \n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn 0;\n\n\t \n\tif (!cr->bitmaps_complete)\n\t\treturn 0;\n\n\tswitch (irec->rm_owner) {\n\tcase XFS_RMAP_OWN_FS:\n\t\tbmp = &cr->fs_owned;\n\t\tbreak;\n\tcase XFS_RMAP_OWN_LOG:\n\t\tbmp = &cr->log_owned;\n\t\tbreak;\n\tcase XFS_RMAP_OWN_AG:\n\t\tbmp = &cr->ag_owned;\n\t\tbreak;\n\tcase XFS_RMAP_OWN_INOBT:\n\t\tbmp = &cr->inobt_owned;\n\t\tbreak;\n\tcase XFS_RMAP_OWN_REFC:\n\t\tbmp = &cr->refcbt_owned;\n\t\tbreak;\n\t}\n\n\tif (!bmp)\n\t\treturn 0;\n\n\tif (xagb_bitmap_test(bmp, irec->rm_startblock, &fsbcount)) {\n\t\t \n\t\tif (fsbcount < irec->rm_blockcount)\n\t\t\txchk_btree_xref_set_corrupt(bs->sc,\n\t\t\t\t\tbs->sc->sa.rmap_cur, 0);\n\t} else {\n\t\t \n\t\txchk_btree_xref_set_corrupt(bs->sc, bs->sc->sa.rmap_cur, 0);\n\t}\n\n\t \n\treturn xagb_bitmap_clear(bmp, irec->rm_startblock, irec->rm_blockcount);\n}\n\n \nSTATIC int\nxchk_rmapbt_rec(\n\tstruct xchk_btree\t*bs,\n\tconst union xfs_btree_rec *rec)\n{\n\tstruct xchk_rmap\t*cr = bs->private;\n\tstruct xfs_rmap_irec\tirec;\n\n\tif (xfs_rmap_btrec_to_irec(rec, &irec) != NULL ||\n\t    xfs_rmap_check_irec(bs->cur, &irec) != NULL) {\n\t\txchk_btree_set_corrupt(bs->sc, bs->cur, 0);\n\t\treturn 0;\n\t}\n\n\txchk_rmapbt_check_unwritten_in_keyflags(bs);\n\txchk_rmapbt_check_mergeable(bs, cr, &irec);\n\txchk_rmapbt_check_overlapping(bs, cr, &irec);\n\txchk_rmapbt_xref(bs->sc, &irec);\n\n\treturn xchk_rmapbt_mark_bitmap(bs, cr, &irec);\n}\n\n \nSTATIC int\nxchk_rmapbt_walk_agfl(\n\tstruct xfs_mount\t*mp,\n\txfs_agblock_t\t\tagbno,\n\tvoid\t\t\t*priv)\n{\n\tstruct xagb_bitmap\t*bitmap = priv;\n\n\treturn xagb_bitmap_set(bitmap, agbno, 1);\n}\n\n \nSTATIC int\nxchk_rmapbt_walk_ag_metadata(\n\tstruct xfs_scrub\t*sc,\n\tstruct xchk_rmap\t*cr)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\tstruct xfs_buf\t\t*agfl_bp;\n\tstruct xfs_agf\t\t*agf = sc->sa.agf_bp->b_addr;\n\tstruct xfs_btree_cur\t*cur;\n\tint\t\t\terror;\n\n\t \n\terror = xagb_bitmap_set(&cr->fs_owned, XFS_SB_BLOCK(mp),\n\t\t\tXFS_AGFL_BLOCK(mp) - XFS_SB_BLOCK(mp) + 1);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tif (xfs_ag_contains_log(mp, sc->sa.pag->pag_agno)) {\n\t\terror = xagb_bitmap_set(&cr->log_owned,\n\t\t\t\tXFS_FSB_TO_AGBNO(mp, mp->m_sb.sb_logstart),\n\t\t\t\tmp->m_sb.sb_logblocks);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t \n\tcur = sc->sa.bno_cur;\n\tif (!cur)\n\t\tcur = xfs_allocbt_init_cursor(sc->mp, sc->tp, sc->sa.agf_bp,\n\t\t\t\tsc->sa.pag, XFS_BTNUM_BNO);\n\terror = xagb_bitmap_set_btblocks(&cr->ag_owned, cur);\n\tif (cur != sc->sa.bno_cur)\n\t\txfs_btree_del_cursor(cur, error);\n\tif (error)\n\t\tgoto out;\n\n\tcur = sc->sa.cnt_cur;\n\tif (!cur)\n\t\tcur = xfs_allocbt_init_cursor(sc->mp, sc->tp, sc->sa.agf_bp,\n\t\t\t\tsc->sa.pag, XFS_BTNUM_CNT);\n\terror = xagb_bitmap_set_btblocks(&cr->ag_owned, cur);\n\tif (cur != sc->sa.cnt_cur)\n\t\txfs_btree_del_cursor(cur, error);\n\tif (error)\n\t\tgoto out;\n\n\terror = xagb_bitmap_set_btblocks(&cr->ag_owned, sc->sa.rmap_cur);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_alloc_read_agfl(sc->sa.pag, sc->tp, &agfl_bp);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_agfl_walk(sc->mp, agf, agfl_bp, xchk_rmapbt_walk_agfl,\n\t\t\t&cr->ag_owned);\n\txfs_trans_brelse(sc->tp, agfl_bp);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tcur = sc->sa.ino_cur;\n\tif (!cur)\n\t\tcur = xfs_inobt_init_cursor(sc->sa.pag, sc->tp, sc->sa.agi_bp,\n\t\t\t\tXFS_BTNUM_INO);\n\terror = xagb_bitmap_set_btblocks(&cr->inobt_owned, cur);\n\tif (cur != sc->sa.ino_cur)\n\t\txfs_btree_del_cursor(cur, error);\n\tif (error)\n\t\tgoto out;\n\n\tif (xfs_has_finobt(sc->mp)) {\n\t\tcur = sc->sa.fino_cur;\n\t\tif (!cur)\n\t\t\tcur = xfs_inobt_init_cursor(sc->sa.pag, sc->tp,\n\t\t\t\t\tsc->sa.agi_bp, XFS_BTNUM_FINO);\n\t\terror = xagb_bitmap_set_btblocks(&cr->inobt_owned, cur);\n\t\tif (cur != sc->sa.fino_cur)\n\t\t\txfs_btree_del_cursor(cur, error);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (xfs_has_reflink(sc->mp)) {\n\t\tcur = sc->sa.refc_cur;\n\t\tif (!cur)\n\t\t\tcur = xfs_refcountbt_init_cursor(sc->mp, sc->tp,\n\t\t\t\t\tsc->sa.agf_bp, sc->sa.pag);\n\t\terror = xagb_bitmap_set_btblocks(&cr->refcbt_owned, cur);\n\t\tif (cur != sc->sa.refc_cur)\n\t\t\txfs_btree_del_cursor(cur, error);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\nout:\n\t \n\tif (error)\n\t\txchk_btree_xref_process_error(sc, sc->sa.rmap_cur,\n\t\t\t\tsc->sa.rmap_cur->bc_nlevels - 1, &error);\n\telse\n\t\tcr->bitmaps_complete = true;\n\treturn 0;\n}\n\n \nSTATIC void\nxchk_rmapbt_check_bitmaps(\n\tstruct xfs_scrub\t*sc,\n\tstruct xchk_rmap\t*cr)\n{\n\tstruct xfs_btree_cur\t*cur = sc->sa.rmap_cur;\n\tunsigned int\t\tlevel;\n\n\tif (sc->sm->sm_flags & (XFS_SCRUB_OFLAG_CORRUPT |\n\t\t\t\tXFS_SCRUB_OFLAG_XFAIL))\n\t\treturn;\n\tif (!cur)\n\t\treturn;\n\tlevel = cur->bc_nlevels - 1;\n\n\t \n\tif (xagb_bitmap_hweight(&cr->fs_owned) != 0)\n\t\txchk_btree_xref_set_corrupt(sc, cur, level);\n\n\tif (xagb_bitmap_hweight(&cr->log_owned) != 0)\n\t\txchk_btree_xref_set_corrupt(sc, cur, level);\n\n\tif (xagb_bitmap_hweight(&cr->ag_owned) != 0)\n\t\txchk_btree_xref_set_corrupt(sc, cur, level);\n\n\tif (xagb_bitmap_hweight(&cr->inobt_owned) != 0)\n\t\txchk_btree_xref_set_corrupt(sc, cur, level);\n\n\tif (xagb_bitmap_hweight(&cr->refcbt_owned) != 0)\n\t\txchk_btree_xref_set_corrupt(sc, cur, level);\n}\n\n \nint\nxchk_rmapbt(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xchk_rmap\t*cr;\n\tint\t\t\terror;\n\n\tcr = kzalloc(sizeof(struct xchk_rmap), XCHK_GFP_FLAGS);\n\tif (!cr)\n\t\treturn -ENOMEM;\n\n\txagb_bitmap_init(&cr->fs_owned);\n\txagb_bitmap_init(&cr->log_owned);\n\txagb_bitmap_init(&cr->ag_owned);\n\txagb_bitmap_init(&cr->inobt_owned);\n\txagb_bitmap_init(&cr->refcbt_owned);\n\n\terror = xchk_rmapbt_walk_ag_metadata(sc, cr);\n\tif (error)\n\t\tgoto out;\n\n\terror = xchk_btree(sc, sc->sa.rmap_cur, xchk_rmapbt_rec,\n\t\t\t&XFS_RMAP_OINFO_AG, cr);\n\tif (error)\n\t\tgoto out;\n\n\txchk_rmapbt_check_bitmaps(sc, cr);\n\nout:\n\txagb_bitmap_destroy(&cr->refcbt_owned);\n\txagb_bitmap_destroy(&cr->inobt_owned);\n\txagb_bitmap_destroy(&cr->ag_owned);\n\txagb_bitmap_destroy(&cr->log_owned);\n\txagb_bitmap_destroy(&cr->fs_owned);\n\tkfree(cr);\n\treturn error;\n}\n\n \nvoid\nxchk_xref_is_only_owned_by(\n\tstruct xfs_scrub\t\t*sc,\n\txfs_agblock_t\t\t\tbno,\n\txfs_extlen_t\t\t\tlen,\n\tconst struct xfs_owner_info\t*oinfo)\n{\n\tstruct xfs_rmap_matches\t\tres;\n\tint\t\t\t\terror;\n\n\tif (!sc->sa.rmap_cur || xchk_skip_xref(sc->sm))\n\t\treturn;\n\n\terror = xfs_rmap_count_owners(sc->sa.rmap_cur, bno, len, oinfo, &res);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.rmap_cur))\n\t\treturn;\n\tif (res.matches != 1)\n\t\txchk_btree_xref_set_corrupt(sc, sc->sa.rmap_cur, 0);\n\tif (res.bad_non_owner_matches)\n\t\txchk_btree_xref_set_corrupt(sc, sc->sa.rmap_cur, 0);\n\tif (res.non_owner_matches)\n\t\txchk_btree_xref_set_corrupt(sc, sc->sa.rmap_cur, 0);\n}\n\n \nvoid\nxchk_xref_is_not_owned_by(\n\tstruct xfs_scrub\t\t*sc,\n\txfs_agblock_t\t\t\tbno,\n\txfs_extlen_t\t\t\tlen,\n\tconst struct xfs_owner_info\t*oinfo)\n{\n\tstruct xfs_rmap_matches\t\tres;\n\tint\t\t\t\terror;\n\n\tif (!sc->sa.rmap_cur || xchk_skip_xref(sc->sm))\n\t\treturn;\n\n\terror = xfs_rmap_count_owners(sc->sa.rmap_cur, bno, len, oinfo, &res);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.rmap_cur))\n\t\treturn;\n\tif (res.matches != 0)\n\t\txchk_btree_xref_set_corrupt(sc, sc->sa.rmap_cur, 0);\n\tif (res.bad_non_owner_matches)\n\t\txchk_btree_xref_set_corrupt(sc, sc->sa.rmap_cur, 0);\n}\n\n \nvoid\nxchk_xref_has_no_owner(\n\tstruct xfs_scrub\t*sc,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen)\n{\n\tenum xbtree_recpacking\toutcome;\n\tint\t\t\terror;\n\n\tif (!sc->sa.rmap_cur || xchk_skip_xref(sc->sm))\n\t\treturn;\n\n\terror = xfs_rmap_has_records(sc->sa.rmap_cur, bno, len, &outcome);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.rmap_cur))\n\t\treturn;\n\tif (outcome != XBTREE_RECPACKING_EMPTY)\n\t\txchk_btree_xref_set_corrupt(sc, sc->sa.rmap_cur, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}