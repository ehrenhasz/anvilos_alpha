{
  "module_name": "xfarray.c",
  "hash_id": "8738c1ece59255e837ab025dea939e7f0049f52c3402ef7092c856a590cb8df9",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/xfarray.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"scrub/xfile.h\"\n#include \"scrub/xfarray.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/trace.h\"\n\n \n\n \nstatic inline void *xfarray_scratch(struct xfarray *array)\n{\n\treturn (array + 1);\n}\n\n \nstatic xfarray_idx_t\nxfarray_idx(\n\tstruct xfarray\t*array,\n\tloff_t\t\tpos)\n{\n\tif (array->obj_size_log >= 0)\n\t\treturn (xfarray_idx_t)pos >> array->obj_size_log;\n\n\treturn div_u64((xfarray_idx_t)pos, array->obj_size);\n}\n\n \nstatic inline loff_t xfarray_pos(struct xfarray *array, xfarray_idx_t idx)\n{\n\tif (array->obj_size_log >= 0)\n\t\treturn idx << array->obj_size_log;\n\n\treturn idx * array->obj_size;\n}\n\n \nint\nxfarray_create(\n\tconst char\t\t*description,\n\tunsigned long long\trequired_capacity,\n\tsize_t\t\t\tobj_size,\n\tstruct xfarray\t\t**arrayp)\n{\n\tstruct xfarray\t\t*array;\n\tstruct xfile\t\t*xfile;\n\tint\t\t\terror;\n\n\tASSERT(obj_size < PAGE_SIZE);\n\n\terror = xfile_create(description, 0, &xfile);\n\tif (error)\n\t\treturn error;\n\n\terror = -ENOMEM;\n\tarray = kzalloc(sizeof(struct xfarray) + obj_size, XCHK_GFP_FLAGS);\n\tif (!array)\n\t\tgoto out_xfile;\n\n\tarray->xfile = xfile;\n\tarray->obj_size = obj_size;\n\n\tif (is_power_of_2(obj_size))\n\t\tarray->obj_size_log = ilog2(obj_size);\n\telse\n\t\tarray->obj_size_log = -1;\n\n\tarray->max_nr = xfarray_idx(array, MAX_LFS_FILESIZE);\n\ttrace_xfarray_create(array, required_capacity);\n\n\tif (required_capacity > 0) {\n\t\tif (array->max_nr < required_capacity) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out_xfarray;\n\t\t}\n\t\tarray->max_nr = required_capacity;\n\t}\n\n\t*arrayp = array;\n\treturn 0;\n\nout_xfarray:\n\tkfree(array);\nout_xfile:\n\txfile_destroy(xfile);\n\treturn error;\n}\n\n \nvoid\nxfarray_destroy(\n\tstruct xfarray\t*array)\n{\n\txfile_destroy(array->xfile);\n\tkfree(array);\n}\n\n \nint\nxfarray_load(\n\tstruct xfarray\t*array,\n\txfarray_idx_t\tidx,\n\tvoid\t\t*ptr)\n{\n\tif (idx >= array->nr)\n\t\treturn -ENODATA;\n\n\treturn xfile_obj_load(array->xfile, ptr, array->obj_size,\n\t\t\txfarray_pos(array, idx));\n}\n\n \nstatic inline bool\nxfarray_is_unset(\n\tstruct xfarray\t*array,\n\tloff_t\t\tpos)\n{\n\tvoid\t\t*temp = xfarray_scratch(array);\n\tint\t\terror;\n\n\tif (array->unset_slots == 0)\n\t\treturn false;\n\n\terror = xfile_obj_load(array->xfile, temp, array->obj_size, pos);\n\tif (!error && xfarray_element_is_null(array, temp))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nint\nxfarray_unset(\n\tstruct xfarray\t*array,\n\txfarray_idx_t\tidx)\n{\n\tvoid\t\t*temp = xfarray_scratch(array);\n\tloff_t\t\tpos = xfarray_pos(array, idx);\n\tint\t\terror;\n\n\tif (idx >= array->nr)\n\t\treturn -ENODATA;\n\n\tif (idx == array->nr - 1) {\n\t\tarray->nr--;\n\t\treturn 0;\n\t}\n\n\tif (xfarray_is_unset(array, pos))\n\t\treturn 0;\n\n\tmemset(temp, 0, array->obj_size);\n\terror = xfile_obj_store(array->xfile, temp, array->obj_size, pos);\n\tif (error)\n\t\treturn error;\n\n\tarray->unset_slots++;\n\treturn 0;\n}\n\n \nint\nxfarray_store(\n\tstruct xfarray\t*array,\n\txfarray_idx_t\tidx,\n\tconst void\t*ptr)\n{\n\tint\t\tret;\n\n\tif (idx >= array->max_nr)\n\t\treturn -EFBIG;\n\n\tASSERT(!xfarray_element_is_null(array, ptr));\n\n\tret = xfile_obj_store(array->xfile, ptr, array->obj_size,\n\t\t\txfarray_pos(array, idx));\n\tif (ret)\n\t\treturn ret;\n\n\tarray->nr = max(array->nr, idx + 1);\n\treturn 0;\n}\n\n \nbool\nxfarray_element_is_null(\n\tstruct xfarray\t*array,\n\tconst void\t*ptr)\n{\n\treturn !memchr_inv(ptr, 0, array->obj_size);\n}\n\n \nint\nxfarray_store_anywhere(\n\tstruct xfarray\t*array,\n\tconst void\t*ptr)\n{\n\tvoid\t\t*temp = xfarray_scratch(array);\n\tloff_t\t\tendpos = xfarray_pos(array, array->nr);\n\tloff_t\t\tpos;\n\tint\t\terror;\n\n\t \n\tfor (pos = 0;\n\t     pos < endpos && array->unset_slots > 0;\n\t     pos += array->obj_size) {\n\t\terror = xfile_obj_load(array->xfile, temp, array->obj_size,\n\t\t\t\tpos);\n\t\tif (error || !xfarray_element_is_null(array, temp))\n\t\t\tcontinue;\n\n\t\terror = xfile_obj_store(array->xfile, ptr, array->obj_size,\n\t\t\t\tpos);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tarray->unset_slots--;\n\t\treturn 0;\n\t}\n\n\t \n\tarray->unset_slots = 0;\n\treturn xfarray_append(array, ptr);\n}\n\n \nuint64_t\nxfarray_length(\n\tstruct xfarray\t*array)\n{\n\treturn array->nr;\n}\n\n \nstatic inline int\nxfarray_find_data(\n\tstruct xfarray\t*array,\n\txfarray_idx_t\t*cur,\n\tloff_t\t\t*pos)\n{\n\tunsigned int\tpgoff = offset_in_page(*pos);\n\tloff_t\t\tend_pos = *pos + array->obj_size - 1;\n\tloff_t\t\tnew_pos;\n\n\t \n\tif (pgoff != 0 && pgoff + array->obj_size - 1 < PAGE_SIZE)\n\t\treturn 0;\n\n\t \n\tnew_pos = xfile_seek_data(array->xfile, end_pos);\n\tif (new_pos == -ENXIO)\n\t\treturn -ENODATA;\n\tif (new_pos < 0)\n\t\treturn new_pos;\n\tif (new_pos == end_pos)\n\t\treturn 0;\n\n\t \n\tnew_pos = roundup_64(new_pos, array->obj_size);\n\t*cur = xfarray_idx(array, new_pos);\n\t*pos = xfarray_pos(array, *cur);\n\treturn 0;\n}\n\n \nint\nxfarray_load_next(\n\tstruct xfarray\t*array,\n\txfarray_idx_t\t*idx,\n\tvoid\t\t*rec)\n{\n\txfarray_idx_t\tcur = *idx;\n\tloff_t\t\tpos = xfarray_pos(array, cur);\n\tint\t\terror;\n\n\tdo {\n\t\tif (cur >= array->nr)\n\t\t\treturn -ENODATA;\n\n\t\t \n\t\terror = xfarray_find_data(array, &cur, &pos);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfarray_load(array, cur, rec);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tcur++;\n\t\tpos += array->obj_size;\n\t} while (xfarray_element_is_null(array, rec));\n\n\t*idx = cur;\n\treturn 0;\n}\n\n \n\n#ifdef DEBUG\n# define xfarray_sort_bump_loads(si)\tdo { (si)->loads++; } while (0)\n# define xfarray_sort_bump_stores(si)\tdo { (si)->stores++; } while (0)\n# define xfarray_sort_bump_compares(si)\tdo { (si)->compares++; } while (0)\n# define xfarray_sort_bump_heapsorts(si) do { (si)->heapsorts++; } while (0)\n#else\n# define xfarray_sort_bump_loads(si)\n# define xfarray_sort_bump_stores(si)\n# define xfarray_sort_bump_compares(si)\n# define xfarray_sort_bump_heapsorts(si)\n#endif  \n\n \nstatic inline int\nxfarray_sort_load(\n\tstruct xfarray_sortinfo\t*si,\n\txfarray_idx_t\t\tidx,\n\tvoid\t\t\t*ptr)\n{\n\txfarray_sort_bump_loads(si);\n\treturn xfarray_load(si->array, idx, ptr);\n}\n\n \nstatic inline int\nxfarray_sort_store(\n\tstruct xfarray_sortinfo\t*si,\n\txfarray_idx_t\t\tidx,\n\tvoid\t\t\t*ptr)\n{\n\txfarray_sort_bump_stores(si);\n\treturn xfarray_store(si->array, idx, ptr);\n}\n\n \nstatic inline int\nxfarray_sort_cmp(\n\tstruct xfarray_sortinfo\t*si,\n\tconst void\t\t*a,\n\tconst void\t\t*b)\n{\n\txfarray_sort_bump_compares(si);\n\treturn si->cmp_fn(a, b);\n}\n\n \nstatic inline xfarray_idx_t *xfarray_sortinfo_lo(struct xfarray_sortinfo *si)\n{\n\treturn (xfarray_idx_t *)(si + 1);\n}\n\n \nstatic inline xfarray_idx_t *xfarray_sortinfo_hi(struct xfarray_sortinfo *si)\n{\n\treturn xfarray_sortinfo_lo(si) + si->max_stack_depth;\n}\n\n \nstatic inline size_t\nxfarray_pivot_rec_sz(\n\tstruct xfarray\t\t*array)\n{\n\treturn round_up(array->obj_size, 8) + sizeof(xfarray_idx_t);\n}\n\n \nstatic inline int\nxfarray_sortinfo_alloc(\n\tstruct xfarray\t\t*array,\n\txfarray_cmp_fn\t\tcmp_fn,\n\tunsigned int\t\tflags,\n\tstruct xfarray_sortinfo\t**infop)\n{\n\tstruct xfarray_sortinfo\t*si;\n\tsize_t\t\t\tnr_bytes = sizeof(struct xfarray_sortinfo);\n\tsize_t\t\t\tpivot_rec_sz = xfarray_pivot_rec_sz(array);\n\tint\t\t\tmax_stack_depth;\n\n\t \n\tBUILD_BUG_ON(XFARRAY_QSORT_PIVOT_NR >= XFARRAY_ISORT_NR);\n\n\t \n\tmax_stack_depth = ilog2(array->nr) + 1 - (XFARRAY_ISORT_SHIFT - 1);\n\tif (max_stack_depth < 1)\n\t\tmax_stack_depth = 1;\n\n\t \n\tnr_bytes += max_stack_depth * sizeof(xfarray_idx_t) * 2;\n\n\t \n\tnr_bytes += max_t(size_t,\n\t\t\t(XFARRAY_QSORT_PIVOT_NR + 1) * pivot_rec_sz,\n\t\t\tXFARRAY_ISORT_NR * array->obj_size);\n\n\tsi = kvzalloc(nr_bytes, XCHK_GFP_FLAGS);\n\tif (!si)\n\t\treturn -ENOMEM;\n\n\tsi->array = array;\n\tsi->cmp_fn = cmp_fn;\n\tsi->flags = flags;\n\tsi->max_stack_depth = max_stack_depth;\n\tsi->max_stack_used = 1;\n\n\txfarray_sortinfo_lo(si)[0] = 0;\n\txfarray_sortinfo_hi(si)[0] = array->nr - 1;\n\n\ttrace_xfarray_sort(si, nr_bytes);\n\t*infop = si;\n\treturn 0;\n}\n\n \nstatic inline bool\nxfarray_sort_terminated(\n\tstruct xfarray_sortinfo\t*si,\n\tint\t\t\t*error)\n{\n\t \n\tcond_resched();\n\n\tif ((si->flags & XFARRAY_SORT_KILLABLE) &&\n\t    fatal_signal_pending(current)) {\n\t\tif (*error == 0)\n\t\t\t*error = -EINTR;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic inline bool\nxfarray_want_isort(\n\tstruct xfarray_sortinfo *si,\n\txfarray_idx_t\t\tstart,\n\txfarray_idx_t\t\tend)\n{\n\t \n\treturn (end - start) < XFARRAY_ISORT_NR;\n}\n\n \nstatic inline void *xfarray_sortinfo_isort_scratch(struct xfarray_sortinfo *si)\n{\n\treturn xfarray_sortinfo_hi(si) + si->max_stack_depth;\n}\n\n \nSTATIC int\nxfarray_isort(\n\tstruct xfarray_sortinfo\t*si,\n\txfarray_idx_t\t\tlo,\n\txfarray_idx_t\t\thi)\n{\n\tvoid\t\t\t*scratch = xfarray_sortinfo_isort_scratch(si);\n\tloff_t\t\t\tlo_pos = xfarray_pos(si->array, lo);\n\tloff_t\t\t\tlen = xfarray_pos(si->array, hi - lo + 1);\n\tint\t\t\terror;\n\n\ttrace_xfarray_isort(si, lo, hi);\n\n\txfarray_sort_bump_loads(si);\n\terror = xfile_obj_load(si->array->xfile, scratch, len, lo_pos);\n\tif (error)\n\t\treturn error;\n\n\txfarray_sort_bump_heapsorts(si);\n\tsort(scratch, hi - lo + 1, si->array->obj_size, si->cmp_fn, NULL);\n\n\txfarray_sort_bump_stores(si);\n\treturn xfile_obj_store(si->array->xfile, scratch, len, lo_pos);\n}\n\n \nstatic inline int\nxfarray_sort_get_page(\n\tstruct xfarray_sortinfo\t*si,\n\tloff_t\t\t\tpos,\n\tuint64_t\t\tlen)\n{\n\tint\t\t\terror;\n\n\terror = xfile_get_page(si->array->xfile, pos, len, &si->xfpage);\n\tif (error)\n\t\treturn error;\n\n\t \n\tsi->page_kaddr = kmap_local_page(si->xfpage.page);\n\treturn 0;\n}\n\n \nstatic inline int\nxfarray_sort_put_page(\n\tstruct xfarray_sortinfo\t*si)\n{\n\tif (!si->page_kaddr)\n\t\treturn 0;\n\n\tkunmap_local(si->page_kaddr);\n\tsi->page_kaddr = NULL;\n\n\treturn xfile_put_page(si->array->xfile, &si->xfpage);\n}\n\n \nstatic inline bool\nxfarray_want_pagesort(\n\tstruct xfarray_sortinfo\t*si,\n\txfarray_idx_t\t\tlo,\n\txfarray_idx_t\t\thi)\n{\n\tpgoff_t\t\t\tlo_page;\n\tpgoff_t\t\t\thi_page;\n\tloff_t\t\t\tend_pos;\n\n\t \n\tlo_page = xfarray_pos(si->array, lo) >> PAGE_SHIFT;\n\tend_pos = xfarray_pos(si->array, hi) + si->array->obj_size - 1;\n\thi_page = end_pos >> PAGE_SHIFT;\n\n\treturn lo_page == hi_page;\n}\n\n \nSTATIC int\nxfarray_pagesort(\n\tstruct xfarray_sortinfo\t*si,\n\txfarray_idx_t\t\tlo,\n\txfarray_idx_t\t\thi)\n{\n\tvoid\t\t\t*startp;\n\tloff_t\t\t\tlo_pos = xfarray_pos(si->array, lo);\n\tuint64_t\t\tlen = xfarray_pos(si->array, hi - lo);\n\tint\t\t\terror = 0;\n\n\ttrace_xfarray_pagesort(si, lo, hi);\n\n\txfarray_sort_bump_loads(si);\n\terror = xfarray_sort_get_page(si, lo_pos, len);\n\tif (error)\n\t\treturn error;\n\n\txfarray_sort_bump_heapsorts(si);\n\tstartp = si->page_kaddr + offset_in_page(lo_pos);\n\tsort(startp, hi - lo + 1, si->array->obj_size, si->cmp_fn, NULL);\n\n\txfarray_sort_bump_stores(si);\n\treturn xfarray_sort_put_page(si);\n}\n\n \nstatic inline void *xfarray_sortinfo_pivot(struct xfarray_sortinfo *si)\n{\n\treturn xfarray_sortinfo_hi(si) + si->max_stack_depth;\n}\n\n \nstatic inline void *\nxfarray_sortinfo_pivot_array(\n\tstruct xfarray_sortinfo\t*si)\n{\n\treturn xfarray_sortinfo_pivot(si) + si->array->obj_size;\n}\n\n \nstatic inline void *\nxfarray_pivot_array_rec(\n\tvoid\t\t\t*pa,\n\tsize_t\t\t\tpa_recsz,\n\tunsigned int\t\tpa_idx)\n{\n\treturn pa + (pa_recsz * pa_idx);\n}\n\n \nstatic inline xfarray_idx_t *\nxfarray_pivot_array_idx(\n\tvoid\t\t\t*pa,\n\tsize_t\t\t\tpa_recsz,\n\tunsigned int\t\tpa_idx)\n{\n\treturn xfarray_pivot_array_rec(pa, pa_recsz, pa_idx + 1) -\n\t\t\tsizeof(xfarray_idx_t);\n}\n\n \nSTATIC int\nxfarray_qsort_pivot(\n\tstruct xfarray_sortinfo\t*si,\n\txfarray_idx_t\t\tlo,\n\txfarray_idx_t\t\thi)\n{\n\tvoid\t\t\t*pivot = xfarray_sortinfo_pivot(si);\n\tvoid\t\t\t*parray = xfarray_sortinfo_pivot_array(si);\n\tvoid\t\t\t*recp;\n\txfarray_idx_t\t\t*idxp;\n\txfarray_idx_t\t\tstep = (hi - lo) / (XFARRAY_QSORT_PIVOT_NR - 1);\n\tsize_t\t\t\tpivot_rec_sz = xfarray_pivot_rec_sz(si->array);\n\tint\t\t\ti, j;\n\tint\t\t\terror;\n\n\tASSERT(step > 0);\n\n\t \n\tidxp = xfarray_pivot_array_idx(parray, pivot_rec_sz, 0);\n\t*idxp = lo;\n\tfor (i = 1; i < XFARRAY_QSORT_PIVOT_NR - 1; i++) {\n\t\tidxp = xfarray_pivot_array_idx(parray, pivot_rec_sz, i);\n\t\t*idxp = lo + (i * step);\n\t}\n\tidxp = xfarray_pivot_array_idx(parray, pivot_rec_sz,\n\t\t\tXFARRAY_QSORT_PIVOT_NR - 1);\n\t*idxp = hi;\n\n\t \n\tfor (i = 0; i < XFARRAY_QSORT_PIVOT_NR; i++) {\n\t\txfarray_idx_t\tidx;\n\n\t\trecp = xfarray_pivot_array_rec(parray, pivot_rec_sz, i);\n\t\tidxp = xfarray_pivot_array_idx(parray, pivot_rec_sz, i);\n\n\t\t \n\t\tif (likely(si->array->unset_slots == 0)) {\n\t\t\terror = xfarray_sort_load(si, *idxp, recp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tidx = *idxp;\n\t\txfarray_sort_bump_loads(si);\n\t\terror = xfarray_load_next(si->array, &idx, recp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfarray_sort_bump_heapsorts(si);\n\tsort(parray, XFARRAY_QSORT_PIVOT_NR, pivot_rec_sz, si->cmp_fn, NULL);\n\n\t \n\trecp = xfarray_pivot_array_rec(parray, pivot_rec_sz,\n\t\t\tXFARRAY_QSORT_PIVOT_NR / 2);\n\tmemcpy(pivot, recp, si->array->obj_size);\n\n\t \n\tidxp = xfarray_pivot_array_idx(parray, pivot_rec_sz,\n\t\t\tXFARRAY_QSORT_PIVOT_NR / 2);\n\tif (*idxp == lo)\n\t\treturn 0;\n\n\t \n\tfor (i = 0, j = -1; i < XFARRAY_QSORT_PIVOT_NR; i++) {\n\t\tidxp = xfarray_pivot_array_idx(parray, pivot_rec_sz, i);\n\t\tif (*idxp == lo)\n\t\t\tj = i;\n\t}\n\tif (j < 0) {\n\t\tASSERT(j >= 0);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\terror = xfarray_sort_store(si, lo, pivot);\n\tif (error)\n\t\treturn error;\n\n\trecp = xfarray_pivot_array_rec(parray, pivot_rec_sz, j);\n\tidxp = xfarray_pivot_array_idx(parray, pivot_rec_sz,\n\t\t\tXFARRAY_QSORT_PIVOT_NR / 2);\n\treturn xfarray_sort_store(si, *idxp, recp);\n}\n\n \nstatic inline int\nxfarray_qsort_push(\n\tstruct xfarray_sortinfo\t*si,\n\txfarray_idx_t\t\t*si_lo,\n\txfarray_idx_t\t\t*si_hi,\n\txfarray_idx_t\t\tlo,\n\txfarray_idx_t\t\thi)\n{\n\t \n\tif (si->stack_depth >= si->max_stack_depth - 1) {\n\t\tASSERT(si->stack_depth < si->max_stack_depth - 1);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tsi->max_stack_used = max_t(uint8_t, si->max_stack_used,\n\t\t\t\t\t    si->stack_depth + 2);\n\n\tsi_lo[si->stack_depth + 1] = lo + 1;\n\tsi_hi[si->stack_depth + 1] = si_hi[si->stack_depth];\n\tsi_hi[si->stack_depth++] = lo - 1;\n\n\t \n\tif (si_hi[si->stack_depth]     - si_lo[si->stack_depth] >\n\t    si_hi[si->stack_depth - 1] - si_lo[si->stack_depth - 1]) {\n\t\tswap(si_lo[si->stack_depth], si_lo[si->stack_depth - 1]);\n\t\tswap(si_hi[si->stack_depth], si_hi[si->stack_depth - 1]);\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline int\nxfarray_sort_load_cached(\n\tstruct xfarray_sortinfo\t*si,\n\txfarray_idx_t\t\tidx,\n\tvoid\t\t\t*ptr)\n{\n\tloff_t\t\t\tidx_pos = xfarray_pos(si->array, idx);\n\tpgoff_t\t\t\tstartpage;\n\tpgoff_t\t\t\tendpage;\n\tint\t\t\terror = 0;\n\n\t \n\tstartpage = idx_pos >> PAGE_SHIFT;\n\tendpage = (idx_pos + si->array->obj_size - 1) >> PAGE_SHIFT;\n\tif (startpage != endpage) {\n\t\terror = xfarray_sort_put_page(si);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (xfarray_sort_terminated(si, &error))\n\t\t\treturn error;\n\n\t\treturn xfile_obj_load(si->array->xfile, ptr,\n\t\t\t\tsi->array->obj_size, idx_pos);\n\t}\n\n\t \n\tif (xfile_page_cached(&si->xfpage) &&\n\t    xfile_page_index(&si->xfpage) != startpage) {\n\t\terror = xfarray_sort_put_page(si);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\tif (!xfile_page_cached(&si->xfpage)) {\n\t\tif (xfarray_sort_terminated(si, &error))\n\t\t\treturn error;\n\n\t\terror = xfarray_sort_get_page(si, startpage << PAGE_SHIFT,\n\t\t\t\tPAGE_SIZE);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tmemcpy(ptr, si->page_kaddr + offset_in_page(idx_pos),\n\t\t\tsi->array->obj_size);\n\treturn 0;\n}\n\n \n\n \n#define QSORT_MAX_RECS\t\t(1ULL << 63)\n\nint\nxfarray_sort(\n\tstruct xfarray\t\t*array,\n\txfarray_cmp_fn\t\tcmp_fn,\n\tunsigned int\t\tflags)\n{\n\tstruct xfarray_sortinfo\t*si;\n\txfarray_idx_t\t\t*si_lo, *si_hi;\n\tvoid\t\t\t*pivot;\n\tvoid\t\t\t*scratch = xfarray_scratch(array);\n\txfarray_idx_t\t\tlo, hi;\n\tint\t\t\terror = 0;\n\n\tif (array->nr < 2)\n\t\treturn 0;\n\tif (array->nr >= QSORT_MAX_RECS)\n\t\treturn -E2BIG;\n\n\terror = xfarray_sortinfo_alloc(array, cmp_fn, flags, &si);\n\tif (error)\n\t\treturn error;\n\tsi_lo = xfarray_sortinfo_lo(si);\n\tsi_hi = xfarray_sortinfo_hi(si);\n\tpivot = xfarray_sortinfo_pivot(si);\n\n\twhile (si->stack_depth >= 0) {\n\t\tlo = si_lo[si->stack_depth];\n\t\thi = si_hi[si->stack_depth];\n\n\t\ttrace_xfarray_qsort(si, lo, hi);\n\n\t\t \n\t\tif (lo >= hi) {\n\t\t\tsi->stack_depth--;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (xfarray_want_pagesort(si, lo, hi)) {\n\t\t\terror = xfarray_pagesort(si, lo, hi);\n\t\t\tif (error)\n\t\t\t\tgoto out_free;\n\t\t\tsi->stack_depth--;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (xfarray_want_isort(si, lo, hi)) {\n\t\t\terror = xfarray_isort(si, lo, hi);\n\t\t\tif (error)\n\t\t\t\tgoto out_free;\n\t\t\tsi->stack_depth--;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\terror = xfarray_qsort_pivot(si, lo, hi);\n\t\tif (error)\n\t\t\tgoto out_free;\n\n\t\t \n\t\twhile (lo < hi) {\n\t\t\t \n\t\t\terror = xfarray_sort_load_cached(si, hi, scratch);\n\t\t\tif (error)\n\t\t\t\tgoto out_free;\n\t\t\twhile (xfarray_sort_cmp(si, scratch, pivot) >= 0 &&\n\t\t\t\t\t\t\t\tlo < hi) {\n\t\t\t\thi--;\n\t\t\t\terror = xfarray_sort_load_cached(si, hi,\n\t\t\t\t\t\tscratch);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\terror = xfarray_sort_put_page(si);\n\t\t\tif (error)\n\t\t\t\tgoto out_free;\n\n\t\t\tif (xfarray_sort_terminated(si, &error))\n\t\t\t\tgoto out_free;\n\n\t\t\t \n\t\t\tif (lo < hi) {\n\t\t\t\terror = xfarray_sort_store(si, lo++, scratch);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t \n\t\t\terror = xfarray_sort_load_cached(si, lo, scratch);\n\t\t\tif (error)\n\t\t\t\tgoto out_free;\n\t\t\twhile (xfarray_sort_cmp(si, scratch, pivot) <= 0 &&\n\t\t\t\t\t\t\t\tlo < hi) {\n\t\t\t\tlo++;\n\t\t\t\terror = xfarray_sort_load_cached(si, lo,\n\t\t\t\t\t\tscratch);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\terror = xfarray_sort_put_page(si);\n\t\t\tif (error)\n\t\t\t\tgoto out_free;\n\n\t\t\tif (xfarray_sort_terminated(si, &error))\n\t\t\t\tgoto out_free;\n\n\t\t\t \n\t\t\tif (lo < hi) {\n\t\t\t\terror = xfarray_sort_store(si, hi--, scratch);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tif (xfarray_sort_terminated(si, &error))\n\t\t\t\tgoto out_free;\n\t\t}\n\n\t\t \n\t\terror = xfarray_sort_store(si, lo, pivot);\n\t\tif (error)\n\t\t\tgoto out_free;\n\n\t\t \n\t\terror = xfarray_qsort_push(si, si_lo, si_hi, lo, hi);\n\t\tif (error)\n\t\t\tgoto out_free;\n\n\t\tif (xfarray_sort_terminated(si, &error))\n\t\t\tgoto out_free;\n\t}\n\nout_free:\n\ttrace_xfarray_sort_stats(si, error);\n\tkvfree(si);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}