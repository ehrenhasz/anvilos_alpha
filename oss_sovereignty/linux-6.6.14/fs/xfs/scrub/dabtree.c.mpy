{
  "module_name": "dabtree.c",
  "hash_id": "04cbc94eb81880bc2ccd97433811e1a8696a598f9ceb18ed12cc8d4c6823faa2",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/dabtree.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/common.h\"\n#include \"scrub/trace.h\"\n#include \"scrub/dabtree.h\"\n\n \n\n \nbool\nxchk_da_process_error(\n\tstruct xchk_da_btree\t*ds,\n\tint\t\t\tlevel,\n\tint\t\t\t*error)\n{\n\tstruct xfs_scrub\t*sc = ds->sc;\n\n\tif (*error == 0)\n\t\treturn true;\n\n\tswitch (*error) {\n\tcase -EDEADLOCK:\n\tcase -ECHRNG:\n\t\t \n\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);\n\t\tbreak;\n\tcase -EFSBADCRC:\n\tcase -EFSCORRUPTED:\n\t\t \n\t\tsc->sm->sm_flags |= XFS_SCRUB_OFLAG_CORRUPT;\n\t\t*error = 0;\n\t\tfallthrough;\n\tdefault:\n\t\ttrace_xchk_file_op_error(sc, ds->dargs.whichfork,\n\t\t\t\txfs_dir2_da_to_db(ds->dargs.geo,\n\t\t\t\t\tds->state->path.blk[level].blkno),\n\t\t\t\t*error, __return_address);\n\t\tbreak;\n\t}\n\treturn false;\n}\n\n \nvoid\nxchk_da_set_corrupt(\n\tstruct xchk_da_btree\t*ds,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_scrub\t*sc = ds->sc;\n\n\tsc->sm->sm_flags |= XFS_SCRUB_OFLAG_CORRUPT;\n\n\ttrace_xchk_fblock_error(sc, ds->dargs.whichfork,\n\t\t\txfs_dir2_da_to_db(ds->dargs.geo,\n\t\t\t\tds->state->path.blk[level].blkno),\n\t\t\t__return_address);\n}\n\nstatic struct xfs_da_node_entry *\nxchk_da_btree_node_entry(\n\tstruct xchk_da_btree\t\t*ds,\n\tint\t\t\t\tlevel)\n{\n\tstruct xfs_da_state_blk\t\t*blk = &ds->state->path.blk[level];\n\tstruct xfs_da3_icnode_hdr\thdr;\n\n\tASSERT(blk->magic == XFS_DA_NODE_MAGIC);\n\n\txfs_da3_node_hdr_from_disk(ds->sc->mp, &hdr, blk->bp->b_addr);\n\treturn hdr.btree + blk->index;\n}\n\n \nint\nxchk_da_btree_hash(\n\tstruct xchk_da_btree\t\t*ds,\n\tint\t\t\t\tlevel,\n\t__be32\t\t\t\t*hashp)\n{\n\tstruct xfs_da_node_entry\t*entry;\n\txfs_dahash_t\t\t\thash;\n\txfs_dahash_t\t\t\tparent_hash;\n\n\t \n\thash = be32_to_cpu(*hashp);\n\tif (hash < ds->hashes[level])\n\t\txchk_da_set_corrupt(ds, level);\n\tds->hashes[level] = hash;\n\n\tif (level == 0)\n\t\treturn 0;\n\n\t \n\tentry = xchk_da_btree_node_entry(ds, level - 1);\n\tparent_hash = be32_to_cpu(entry->hashval);\n\tif (parent_hash < hash)\n\t\txchk_da_set_corrupt(ds, level);\n\n\treturn 0;\n}\n\n \nSTATIC bool\nxchk_da_btree_ptr_ok(\n\tstruct xchk_da_btree\t*ds,\n\tint\t\t\tlevel,\n\txfs_dablk_t\t\tblkno)\n{\n\tif (blkno < ds->lowest || (ds->highest != 0 && blkno >= ds->highest)) {\n\t\txchk_da_set_corrupt(ds, level);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic void\nxchk_da_btree_read_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_da_blkinfo\t*info = bp->b_addr;\n\n\tswitch (be16_to_cpu(info->magic)) {\n\tcase XFS_DIR2_LEAF1_MAGIC:\n\tcase XFS_DIR3_LEAF1_MAGIC:\n\t\tbp->b_ops = &xfs_dir3_leaf1_buf_ops;\n\t\tbp->b_ops->verify_read(bp);\n\t\treturn;\n\tdefault:\n\t\t \n\t\tbp->b_ops = &xfs_da3_node_buf_ops;\n\t\tbp->b_ops->verify_read(bp);\n\t\treturn;\n\t}\n}\nstatic void\nxchk_da_btree_write_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_da_blkinfo\t*info = bp->b_addr;\n\n\tswitch (be16_to_cpu(info->magic)) {\n\tcase XFS_DIR2_LEAF1_MAGIC:\n\tcase XFS_DIR3_LEAF1_MAGIC:\n\t\tbp->b_ops = &xfs_dir3_leaf1_buf_ops;\n\t\tbp->b_ops->verify_write(bp);\n\t\treturn;\n\tdefault:\n\t\t \n\t\tbp->b_ops = &xfs_da3_node_buf_ops;\n\t\tbp->b_ops->verify_write(bp);\n\t\treturn;\n\t}\n}\nstatic void *\nxchk_da_btree_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_da_blkinfo\t*info = bp->b_addr;\n\n\tswitch (be16_to_cpu(info->magic)) {\n\tcase XFS_DIR2_LEAF1_MAGIC:\n\tcase XFS_DIR3_LEAF1_MAGIC:\n\t\tbp->b_ops = &xfs_dir3_leaf1_buf_ops;\n\t\treturn bp->b_ops->verify_struct(bp);\n\tdefault:\n\t\tbp->b_ops = &xfs_da3_node_buf_ops;\n\t\treturn bp->b_ops->verify_struct(bp);\n\t}\n}\n\nstatic const struct xfs_buf_ops xchk_da_btree_buf_ops = {\n\t.name = \"xchk_da_btree\",\n\t.verify_read = xchk_da_btree_read_verify,\n\t.verify_write = xchk_da_btree_write_verify,\n\t.verify_struct = xchk_da_btree_verify,\n};\n\n \nSTATIC int\nxchk_da_btree_block_check_sibling(\n\tstruct xchk_da_btree\t*ds,\n\tint\t\t\tlevel,\n\tint\t\t\tdirection,\n\txfs_dablk_t\t\tsibling)\n{\n\tstruct xfs_da_state_path *path = &ds->state->path;\n\tstruct xfs_da_state_path *altpath = &ds->state->altpath;\n\tint\t\t\tretval;\n\tint\t\t\tplevel;\n\tint\t\t\terror;\n\n\tmemcpy(altpath, path, sizeof(ds->state->altpath));\n\n\t \n\tif (sibling == 0) {\n\t\terror = xfs_da3_path_shift(ds->state, altpath, direction,\n\t\t\t\tfalse, &retval);\n\t\tif (error == 0 && retval == 0)\n\t\t\txchk_da_set_corrupt(ds, level);\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\t \n\terror = xfs_da3_path_shift(ds->state, altpath, direction, false,\n\t\t\t&retval);\n\tif (!xchk_da_process_error(ds, level, &error))\n\t\tgoto out;\n\tif (retval) {\n\t\txchk_da_set_corrupt(ds, level);\n\t\tgoto out;\n\t}\n\tif (altpath->blk[level].bp)\n\t\txchk_buffer_recheck(ds->sc, altpath->blk[level].bp);\n\n\t \n\tif (altpath->blk[level].blkno != sibling)\n\t\txchk_da_set_corrupt(ds, level);\n\nout:\n\t \n\tfor (plevel = 0; plevel < altpath->active; plevel++) {\n\t\tif (altpath->blk[plevel].bp == NULL ||\n\t\t    (plevel < path->active &&\n\t\t     altpath->blk[plevel].bp == path->blk[plevel].bp))\n\t\t\tcontinue;\n\n\t\txfs_trans_brelse(ds->dargs.trans, altpath->blk[plevel].bp);\n\t\taltpath->blk[plevel].bp = NULL;\n\t}\n\n\treturn error;\n}\n\n \nSTATIC int\nxchk_da_btree_block_check_siblings(\n\tstruct xchk_da_btree\t*ds,\n\tint\t\t\tlevel,\n\tstruct xfs_da_blkinfo\t*hdr)\n{\n\txfs_dablk_t\t\tforw;\n\txfs_dablk_t\t\tback;\n\tint\t\t\terror = 0;\n\n\tforw = be32_to_cpu(hdr->forw);\n\tback = be32_to_cpu(hdr->back);\n\n\t \n\tif (level == 0) {\n\t\tif (forw != 0 || back != 0)\n\t\t\txchk_da_set_corrupt(ds, level);\n\t\treturn 0;\n\t}\n\n\t \n\terror = xchk_da_btree_block_check_sibling(ds, level, 0, back);\n\tif (error)\n\t\tgoto out;\n\terror = xchk_da_btree_block_check_sibling(ds, level, 1, forw);\n\nout:\n\tmemset(&ds->state->altpath, 0, sizeof(ds->state->altpath));\n\treturn error;\n}\n\n \nSTATIC int\nxchk_da_btree_block(\n\tstruct xchk_da_btree\t\t*ds,\n\tint\t\t\t\tlevel,\n\txfs_dablk_t\t\t\tblkno)\n{\n\tstruct xfs_da_state_blk\t\t*blk;\n\tstruct xfs_da_intnode\t\t*node;\n\tstruct xfs_da_node_entry\t*btree;\n\tstruct xfs_da3_blkinfo\t\t*hdr3;\n\tstruct xfs_da_args\t\t*dargs = &ds->dargs;\n\tstruct xfs_inode\t\t*ip = ds->dargs.dp;\n\txfs_ino_t\t\t\towner;\n\tint\t\t\t\t*pmaxrecs;\n\tstruct xfs_da3_icnode_hdr\tnodehdr;\n\tint\t\t\t\terror = 0;\n\n\tblk = &ds->state->path.blk[level];\n\tds->state->path.active = level + 1;\n\n\t \n\tif (blk->bp) {\n\t\txfs_trans_brelse(dargs->trans, blk->bp);\n\t\tblk->bp = NULL;\n\t}\n\n\t \n\tblk->blkno = blkno;\n\tif (!xchk_da_btree_ptr_ok(ds, level, blkno))\n\t\tgoto out_nobuf;\n\n\t \n\terror = xfs_da_read_buf(dargs->trans, dargs->dp, blk->blkno,\n\t\t\tXFS_DABUF_MAP_HOLE_OK, &blk->bp, dargs->whichfork,\n\t\t\t&xchk_da_btree_buf_ops);\n\tif (!xchk_da_process_error(ds, level, &error))\n\t\tgoto out_nobuf;\n\tif (blk->bp)\n\t\txchk_buffer_recheck(ds->sc, blk->bp);\n\n\t \n\tif (ds->dargs.whichfork == XFS_DATA_FORK && level == 0 &&\n\t\t\tblk->bp == NULL)\n\t\tgoto out_nobuf;\n\n\t \n\tif (blk->bp == NULL) {\n\t\txchk_da_set_corrupt(ds, level);\n\t\tgoto out_nobuf;\n\t}\n\n\thdr3 = blk->bp->b_addr;\n\tblk->magic = be16_to_cpu(hdr3->hdr.magic);\n\tpmaxrecs = &ds->maxrecs[level];\n\n\t \n\tif (xfs_has_crc(ds->sc->mp) && hdr3->hdr.pad)\n\t\txchk_da_set_corrupt(ds, level);\n\n\t \n\tif (xfs_has_crc(ip->i_mount)) {\n\t\towner = be64_to_cpu(hdr3->owner);\n\t\tif (owner != ip->i_ino)\n\t\t\txchk_da_set_corrupt(ds, level);\n\t}\n\n\t \n\terror = xchk_da_btree_block_check_siblings(ds, level, &hdr3->hdr);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\txfs_trans_buf_set_type(dargs->trans, blk->bp,\n\t\t\t\tXFS_BLFT_ATTR_LEAF_BUF);\n\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, pmaxrecs);\n\t\tif (ds->tree_level != 0)\n\t\t\txchk_da_set_corrupt(ds, level);\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\txfs_trans_buf_set_type(dargs->trans, blk->bp,\n\t\t\t\tXFS_BLFT_DIR_LEAFN_BUF);\n\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\tblk->hashval = xfs_dir2_leaf_lasthash(ip, blk->bp, pmaxrecs);\n\t\tif (ds->tree_level != 0)\n\t\t\txchk_da_set_corrupt(ds, level);\n\t\tbreak;\n\tcase XFS_DIR2_LEAF1_MAGIC:\n\tcase XFS_DIR3_LEAF1_MAGIC:\n\t\txfs_trans_buf_set_type(dargs->trans, blk->bp,\n\t\t\t\tXFS_BLFT_DIR_LEAF1_BUF);\n\t\tblk->magic = XFS_DIR2_LEAF1_MAGIC;\n\t\tblk->hashval = xfs_dir2_leaf_lasthash(ip, blk->bp, pmaxrecs);\n\t\tif (ds->tree_level != 0)\n\t\t\txchk_da_set_corrupt(ds, level);\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\tcase XFS_DA3_NODE_MAGIC:\n\t\txfs_trans_buf_set_type(dargs->trans, blk->bp,\n\t\t\t\tXFS_BLFT_DA_NODE_BUF);\n\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\t\tnode = blk->bp->b_addr;\n\t\txfs_da3_node_hdr_from_disk(ip->i_mount, &nodehdr, node);\n\t\tbtree = nodehdr.btree;\n\t\t*pmaxrecs = nodehdr.count;\n\t\tblk->hashval = be32_to_cpu(btree[*pmaxrecs - 1].hashval);\n\t\tif (level == 0) {\n\t\t\tif (nodehdr.level >= XFS_DA_NODE_MAXDEPTH) {\n\t\t\t\txchk_da_set_corrupt(ds, level);\n\t\t\t\tgoto out_freebp;\n\t\t\t}\n\t\t\tds->tree_level = nodehdr.level;\n\t\t} else {\n\t\t\tif (ds->tree_level != nodehdr.level) {\n\t\t\t\txchk_da_set_corrupt(ds, level);\n\t\t\t\tgoto out_freebp;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tbreak;\n\tdefault:\n\t\txchk_da_set_corrupt(ds, level);\n\t\tgoto out_freebp;\n\t}\n\n\t \n\tif (level > 0) {\n\t\tstruct xfs_da_node_entry\t*key;\n\n\t\tkey = xchk_da_btree_node_entry(ds, level - 1);\n\t\tif (be32_to_cpu(key->hashval) != blk->hashval) {\n\t\t\txchk_da_set_corrupt(ds, level);\n\t\t\tgoto out_freebp;\n\t\t}\n\t}\n\nout:\n\treturn error;\nout_freebp:\n\txfs_trans_brelse(dargs->trans, blk->bp);\n\tblk->bp = NULL;\nout_nobuf:\n\tblk->blkno = 0;\n\treturn error;\n}\n\n \nint\nxchk_da_btree(\n\tstruct xfs_scrub\t\t*sc,\n\tint\t\t\t\twhichfork,\n\txchk_da_btree_rec_fn\t\tscrub_fn,\n\tvoid\t\t\t\t*private)\n{\n\tstruct xchk_da_btree\t\t*ds;\n\tstruct xfs_mount\t\t*mp = sc->mp;\n\tstruct xfs_da_state_blk\t\t*blks;\n\tstruct xfs_da_node_entry\t*key;\n\txfs_dablk_t\t\t\tblkno;\n\tint\t\t\t\tlevel;\n\tint\t\t\t\terror;\n\n\t \n\tif (!xfs_ifork_has_extents(xfs_ifork_ptr(sc->ip, whichfork)))\n\t\treturn 0;\n\n\t \n\tds = kzalloc(sizeof(struct xchk_da_btree), XCHK_GFP_FLAGS);\n\tif (!ds)\n\t\treturn -ENOMEM;\n\tds->dargs.dp = sc->ip;\n\tds->dargs.whichfork = whichfork;\n\tds->dargs.trans = sc->tp;\n\tds->dargs.op_flags = XFS_DA_OP_OKNOENT;\n\tds->state = xfs_da_state_alloc(&ds->dargs);\n\tds->sc = sc;\n\tds->private = private;\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tds->dargs.geo = mp->m_attr_geo;\n\t\tds->lowest = 0;\n\t\tds->highest = 0;\n\t} else {\n\t\tds->dargs.geo = mp->m_dir_geo;\n\t\tds->lowest = ds->dargs.geo->leafblk;\n\t\tds->highest = ds->dargs.geo->freeblk;\n\t}\n\tblkno = ds->lowest;\n\tlevel = 0;\n\n\t \n\tblks = ds->state->path.blk;\n\terror = xchk_da_btree_block(ds, level, blkno);\n\tif (error)\n\t\tgoto out_state;\n\t \n\tif (blks[level].bp == NULL)\n\t\tgoto out_state;\n\n\tblks[level].index = 0;\n\twhile (level >= 0 && level < XFS_DA_NODE_MAXDEPTH) {\n\t\t \n\t\tif (blks[level].magic != XFS_DA_NODE_MAGIC) {\n\t\t\t \n\t\t\tif (blks[level].index >= ds->maxrecs[level]) {\n\t\t\t\tif (level > 0)\n\t\t\t\t\tblks[level - 1].index++;\n\t\t\t\tds->tree_level++;\n\t\t\t\tlevel--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\terror = scrub_fn(ds, level);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tif (xchk_should_terminate(sc, &error) ||\n\t\t\t    (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT))\n\t\t\t\tbreak;\n\n\t\t\tblks[level].index++;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t \n\t\tif (blks[level].index >= ds->maxrecs[level]) {\n\t\t\tif (level > 0)\n\t\t\t\tblks[level - 1].index++;\n\t\t\tds->tree_level++;\n\t\t\tlevel--;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tkey = xchk_da_btree_node_entry(ds, level);\n\t\terror = xchk_da_btree_hash(ds, level, &key->hashval);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t \n\t\tblkno = be32_to_cpu(key->before);\n\t\tlevel++;\n\t\tif (level >= XFS_DA_NODE_MAXDEPTH) {\n\t\t\t \n\t\t\txchk_da_set_corrupt(ds, level - 1);\n\t\t\tbreak;\n\t\t}\n\t\tds->tree_level--;\n\t\terror = xchk_da_btree_block(ds, level, blkno);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tif (blks[level].bp == NULL)\n\t\t\tgoto out;\n\n\t\tblks[level].index = 0;\n\t}\n\nout:\n\t \n\tfor (level = 0; level < XFS_DA_NODE_MAXDEPTH; level++) {\n\t\tif (blks[level].bp == NULL)\n\t\t\tcontinue;\n\t\txfs_trans_brelse(sc->tp, blks[level].bp);\n\t\tblks[level].bp = NULL;\n\t}\n\nout_state:\n\txfs_da_state_free(ds->state);\n\tkfree(ds);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}