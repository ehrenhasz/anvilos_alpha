{
  "module_name": "scrub.c",
  "hash_id": "050a8caba2255508ed04bc0a21a82ca84bd3d07fbdf4a480977b24aa6cc702c8",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/scrub.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_errortag.h\"\n#include \"xfs_error.h\"\n#include \"xfs_scrub.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/common.h\"\n#include \"scrub/trace.h\"\n#include \"scrub/repair.h\"\n#include \"scrub/health.h\"\n#include \"scrub/stats.h\"\n#include \"scrub/xfile.h\"\n\n \n\n \nstatic int\nxchk_probe(\n\tstruct xfs_scrub\t*sc)\n{\n\tint\t\t\terror = 0;\n\n\tif (xchk_should_terminate(sc, &error))\n\t\treturn error;\n\n\treturn 0;\n}\n\n \n\nstatic inline void\nxchk_fsgates_disable(\n\tstruct xfs_scrub\t*sc)\n{\n\tif (!(sc->flags & XCHK_FSGATES_ALL))\n\t\treturn;\n\n\ttrace_xchk_fsgates_disable(sc, sc->flags & XCHK_FSGATES_ALL);\n\n\tif (sc->flags & XCHK_FSGATES_DRAIN)\n\t\txfs_drain_wait_disable();\n\n\tsc->flags &= ~XCHK_FSGATES_ALL;\n}\n\n \nSTATIC int\nxchk_teardown(\n\tstruct xfs_scrub\t*sc,\n\tint\t\t\terror)\n{\n\txchk_ag_free(sc, &sc->sa);\n\tif (sc->tp) {\n\t\tif (error == 0 && (sc->sm->sm_flags & XFS_SCRUB_IFLAG_REPAIR))\n\t\t\terror = xfs_trans_commit(sc->tp);\n\t\telse\n\t\t\txfs_trans_cancel(sc->tp);\n\t\tsc->tp = NULL;\n\t}\n\tif (sc->ip) {\n\t\tif (sc->ilock_flags)\n\t\t\txchk_iunlock(sc, sc->ilock_flags);\n\t\txchk_irele(sc, sc->ip);\n\t\tsc->ip = NULL;\n\t}\n\tif (sc->flags & XCHK_HAVE_FREEZE_PROT) {\n\t\tsc->flags &= ~XCHK_HAVE_FREEZE_PROT;\n\t\tmnt_drop_write_file(sc->file);\n\t}\n\tif (sc->xfile) {\n\t\txfile_destroy(sc->xfile);\n\t\tsc->xfile = NULL;\n\t}\n\tif (sc->buf) {\n\t\tif (sc->buf_cleanup)\n\t\t\tsc->buf_cleanup(sc->buf);\n\t\tkvfree(sc->buf);\n\t\tsc->buf_cleanup = NULL;\n\t\tsc->buf = NULL;\n\t}\n\n\txchk_fsgates_disable(sc);\n\treturn error;\n}\n\n \n\nstatic const struct xchk_meta_ops meta_scrub_ops[] = {\n\t[XFS_SCRUB_TYPE_PROBE] = {\t \n\t\t.type\t= ST_NONE,\n\t\t.setup\t= xchk_setup_fs,\n\t\t.scrub\t= xchk_probe,\n\t\t.repair = xrep_probe,\n\t},\n\t[XFS_SCRUB_TYPE_SB] = {\t\t \n\t\t.type\t= ST_PERAG,\n\t\t.setup\t= xchk_setup_agheader,\n\t\t.scrub\t= xchk_superblock,\n\t\t.repair\t= xrep_superblock,\n\t},\n\t[XFS_SCRUB_TYPE_AGF] = {\t \n\t\t.type\t= ST_PERAG,\n\t\t.setup\t= xchk_setup_agheader,\n\t\t.scrub\t= xchk_agf,\n\t\t.repair\t= xrep_agf,\n\t},\n\t[XFS_SCRUB_TYPE_AGFL]= {\t \n\t\t.type\t= ST_PERAG,\n\t\t.setup\t= xchk_setup_agheader,\n\t\t.scrub\t= xchk_agfl,\n\t\t.repair\t= xrep_agfl,\n\t},\n\t[XFS_SCRUB_TYPE_AGI] = {\t \n\t\t.type\t= ST_PERAG,\n\t\t.setup\t= xchk_setup_agheader,\n\t\t.scrub\t= xchk_agi,\n\t\t.repair\t= xrep_agi,\n\t},\n\t[XFS_SCRUB_TYPE_BNOBT] = {\t \n\t\t.type\t= ST_PERAG,\n\t\t.setup\t= xchk_setup_ag_allocbt,\n\t\t.scrub\t= xchk_bnobt,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_CNTBT] = {\t \n\t\t.type\t= ST_PERAG,\n\t\t.setup\t= xchk_setup_ag_allocbt,\n\t\t.scrub\t= xchk_cntbt,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_INOBT] = {\t \n\t\t.type\t= ST_PERAG,\n\t\t.setup\t= xchk_setup_ag_iallocbt,\n\t\t.scrub\t= xchk_inobt,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_FINOBT] = {\t \n\t\t.type\t= ST_PERAG,\n\t\t.setup\t= xchk_setup_ag_iallocbt,\n\t\t.scrub\t= xchk_finobt,\n\t\t.has\t= xfs_has_finobt,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_RMAPBT] = {\t \n\t\t.type\t= ST_PERAG,\n\t\t.setup\t= xchk_setup_ag_rmapbt,\n\t\t.scrub\t= xchk_rmapbt,\n\t\t.has\t= xfs_has_rmapbt,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_REFCNTBT] = {\t \n\t\t.type\t= ST_PERAG,\n\t\t.setup\t= xchk_setup_ag_refcountbt,\n\t\t.scrub\t= xchk_refcountbt,\n\t\t.has\t= xfs_has_reflink,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_INODE] = {\t \n\t\t.type\t= ST_INODE,\n\t\t.setup\t= xchk_setup_inode,\n\t\t.scrub\t= xchk_inode,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_BMBTD] = {\t \n\t\t.type\t= ST_INODE,\n\t\t.setup\t= xchk_setup_inode_bmap,\n\t\t.scrub\t= xchk_bmap_data,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_BMBTA] = {\t \n\t\t.type\t= ST_INODE,\n\t\t.setup\t= xchk_setup_inode_bmap,\n\t\t.scrub\t= xchk_bmap_attr,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_BMBTC] = {\t \n\t\t.type\t= ST_INODE,\n\t\t.setup\t= xchk_setup_inode_bmap,\n\t\t.scrub\t= xchk_bmap_cow,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_DIR] = {\t \n\t\t.type\t= ST_INODE,\n\t\t.setup\t= xchk_setup_directory,\n\t\t.scrub\t= xchk_directory,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_XATTR] = {\t \n\t\t.type\t= ST_INODE,\n\t\t.setup\t= xchk_setup_xattr,\n\t\t.scrub\t= xchk_xattr,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_SYMLINK] = {\t \n\t\t.type\t= ST_INODE,\n\t\t.setup\t= xchk_setup_symlink,\n\t\t.scrub\t= xchk_symlink,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_PARENT] = {\t \n\t\t.type\t= ST_INODE,\n\t\t.setup\t= xchk_setup_parent,\n\t\t.scrub\t= xchk_parent,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_RTBITMAP] = {\t \n\t\t.type\t= ST_FS,\n\t\t.setup\t= xchk_setup_rtbitmap,\n\t\t.scrub\t= xchk_rtbitmap,\n\t\t.has\t= xfs_has_realtime,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_RTSUM] = {\t \n\t\t.type\t= ST_FS,\n\t\t.setup\t= xchk_setup_rtsummary,\n\t\t.scrub\t= xchk_rtsummary,\n\t\t.has\t= xfs_has_realtime,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_UQUOTA] = {\t \n\t\t.type\t= ST_FS,\n\t\t.setup\t= xchk_setup_quota,\n\t\t.scrub\t= xchk_quota,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_GQUOTA] = {\t \n\t\t.type\t= ST_FS,\n\t\t.setup\t= xchk_setup_quota,\n\t\t.scrub\t= xchk_quota,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_PQUOTA] = {\t \n\t\t.type\t= ST_FS,\n\t\t.setup\t= xchk_setup_quota,\n\t\t.scrub\t= xchk_quota,\n\t\t.repair\t= xrep_notsupported,\n\t},\n\t[XFS_SCRUB_TYPE_FSCOUNTERS] = {\t \n\t\t.type\t= ST_FS,\n\t\t.setup\t= xchk_setup_fscounters,\n\t\t.scrub\t= xchk_fscounters,\n\t\t.repair\t= xrep_notsupported,\n\t},\n};\n\nstatic int\nxchk_validate_inputs(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_scrub_metadata\t*sm)\n{\n\tint\t\t\t\terror;\n\tconst struct xchk_meta_ops\t*ops;\n\n\terror = -EINVAL;\n\t \n\tsm->sm_flags &= ~XFS_SCRUB_FLAGS_OUT;\n\tif (sm->sm_flags & ~XFS_SCRUB_FLAGS_IN)\n\t\tgoto out;\n\t \n\tif (memchr_inv(sm->sm_reserved, 0, sizeof(sm->sm_reserved)))\n\t\tgoto out;\n\n\terror = -ENOENT;\n\t \n\tif (sm->sm_type >= XFS_SCRUB_TYPE_NR)\n\t\tgoto out;\n\tops = &meta_scrub_ops[sm->sm_type];\n\tif (ops->setup == NULL || ops->scrub == NULL)\n\t\tgoto out;\n\t \n\tif (ops->has && !ops->has(mp))\n\t\tgoto out;\n\n\terror = -EINVAL;\n\t \n\tswitch (ops->type) {\n\tcase ST_NONE:\n\tcase ST_FS:\n\t\tif (sm->sm_ino || sm->sm_gen || sm->sm_agno)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase ST_PERAG:\n\t\tif (sm->sm_ino || sm->sm_gen ||\n\t\t    sm->sm_agno >= mp->m_sb.sb_agcount)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase ST_INODE:\n\t\tif (sm->sm_agno || (sm->sm_gen && !sm->sm_ino))\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\t \n\tif ((sm->sm_flags & XFS_SCRUB_IFLAG_FORCE_REBUILD) &&\n\t    !(sm->sm_flags & XFS_SCRUB_IFLAG_REPAIR))\n\t\treturn -EINVAL;\n\n\t \n\tif (sm->sm_flags & XFS_SCRUB_IFLAG_REPAIR) {\n\t\terror = -EOPNOTSUPP;\n\t\tif (!xfs_has_crc(mp))\n\t\t\tgoto out;\n\n\t\terror = -EROFS;\n\t\tif (xfs_is_readonly(mp))\n\t\t\tgoto out;\n\t}\n\n\terror = 0;\nout:\n\treturn error;\n}\n\n#ifdef CONFIG_XFS_ONLINE_REPAIR\nstatic inline void xchk_postmortem(struct xfs_scrub *sc)\n{\n\t \n\tif ((sc->sm->sm_flags & XFS_SCRUB_IFLAG_REPAIR) &&\n\t    (sc->sm->sm_flags & (XFS_SCRUB_OFLAG_CORRUPT |\n\t\t\t\t XFS_SCRUB_OFLAG_XCORRUPT)))\n\t\txrep_failure(sc->mp);\n}\n#else\nstatic inline void xchk_postmortem(struct xfs_scrub *sc)\n{\n\t \n\tif (sc->sm->sm_flags & (XFS_SCRUB_OFLAG_CORRUPT |\n\t\t\t\tXFS_SCRUB_OFLAG_XCORRUPT))\n\t\txfs_alert_ratelimited(sc->mp,\n\t\t\t\t\"Corruption detected during scrub.\");\n}\n#endif  \n\n \nint\nxfs_scrub_metadata(\n\tstruct file\t\t\t*file,\n\tstruct xfs_scrub_metadata\t*sm)\n{\n\tstruct xchk_stats_run\t\trun = { };\n\tstruct xfs_scrub\t\t*sc;\n\tstruct xfs_mount\t\t*mp = XFS_I(file_inode(file))->i_mount;\n\tu64\t\t\t\tcheck_start;\n\tint\t\t\t\terror = 0;\n\n\tBUILD_BUG_ON(sizeof(meta_scrub_ops) !=\n\t\t(sizeof(struct xchk_meta_ops) * XFS_SCRUB_TYPE_NR));\n\n\ttrace_xchk_start(XFS_I(file_inode(file)), sm, error);\n\n\t \n\terror = -ESHUTDOWN;\n\tif (xfs_is_shutdown(mp))\n\t\tgoto out;\n\terror = -ENOTRECOVERABLE;\n\tif (xfs_has_norecovery(mp))\n\t\tgoto out;\n\n\terror = xchk_validate_inputs(mp, sm);\n\tif (error)\n\t\tgoto out;\n\n\txfs_warn_mount(mp, XFS_OPSTATE_WARNED_SCRUB,\n \"EXPERIMENTAL online scrub feature in use. Use at your own risk!\");\n\n\tsc = kzalloc(sizeof(struct xfs_scrub), XCHK_GFP_FLAGS);\n\tif (!sc) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsc->mp = mp;\n\tsc->file = file;\n\tsc->sm = sm;\n\tsc->ops = &meta_scrub_ops[sm->sm_type];\n\tsc->sick_mask = xchk_health_mask_for_scrub_type(sm->sm_type);\nretry_op:\n\t \n\tif (sm->sm_flags & XFS_SCRUB_IFLAG_REPAIR) {\n\t\terror = mnt_want_write_file(sc->file);\n\t\tif (error)\n\t\t\tgoto out_sc;\n\n\t\tsc->flags |= XCHK_HAVE_FREEZE_PROT;\n\t}\n\n\t \n\terror = sc->ops->setup(sc);\n\tif (error == -EDEADLOCK && !(sc->flags & XCHK_TRY_HARDER))\n\t\tgoto try_harder;\n\tif (error == -ECHRNG && !(sc->flags & XCHK_NEED_DRAIN))\n\t\tgoto need_drain;\n\tif (error)\n\t\tgoto out_teardown;\n\n\t \n\tcheck_start = xchk_stats_now();\n\terror = sc->ops->scrub(sc);\n\trun.scrub_ns += xchk_stats_elapsed_ns(check_start);\n\tif (error == -EDEADLOCK && !(sc->flags & XCHK_TRY_HARDER))\n\t\tgoto try_harder;\n\tif (error == -ECHRNG && !(sc->flags & XCHK_NEED_DRAIN))\n\t\tgoto need_drain;\n\tif (error || (sm->sm_flags & XFS_SCRUB_OFLAG_INCOMPLETE))\n\t\tgoto out_teardown;\n\n\txchk_update_health(sc);\n\n\tif ((sc->sm->sm_flags & XFS_SCRUB_IFLAG_REPAIR) &&\n\t    !(sc->flags & XREP_ALREADY_FIXED)) {\n\t\tbool needs_fix = xchk_needs_repair(sc->sm);\n\n\t\t \n\t\tif (sc->sm->sm_flags & XFS_SCRUB_IFLAG_FORCE_REBUILD)\n\t\t\tneeds_fix = true;\n\n\t\t \n\t\tif (XFS_TEST_ERROR(needs_fix, mp, XFS_ERRTAG_FORCE_SCRUB_REPAIR))\n\t\t\tneeds_fix = true;\n\n\t\t \n\t\tif (!needs_fix) {\n\t\t\tsc->sm->sm_flags |= XFS_SCRUB_OFLAG_NO_REPAIR_NEEDED;\n\t\t\tgoto out_nofix;\n\t\t}\n\n\t\t \n\t\terror = xrep_attempt(sc, &run);\n\t\tif (error == -EAGAIN) {\n\t\t\t \n\t\t\terror = xchk_teardown(sc, 0);\n\t\t\tif (error) {\n\t\t\t\txrep_failure(mp);\n\t\t\t\tgoto out_sc;\n\t\t\t}\n\t\t\tgoto retry_op;\n\t\t}\n\t}\n\nout_nofix:\n\txchk_postmortem(sc);\nout_teardown:\n\terror = xchk_teardown(sc, error);\nout_sc:\n\tif (error != -ENOENT)\n\t\txchk_stats_merge(mp, sm, &run);\n\tkfree(sc);\nout:\n\ttrace_xchk_done(XFS_I(file_inode(file)), sm, error);\n\tif (error == -EFSCORRUPTED || error == -EFSBADCRC) {\n\t\tsm->sm_flags |= XFS_SCRUB_OFLAG_CORRUPT;\n\t\terror = 0;\n\t}\n\treturn error;\nneed_drain:\n\terror = xchk_teardown(sc, 0);\n\tif (error)\n\t\tgoto out_sc;\n\tsc->flags |= XCHK_NEED_DRAIN;\n\trun.retries++;\n\tgoto retry_op;\ntry_harder:\n\t \n\terror = xchk_teardown(sc, 0);\n\tif (error)\n\t\tgoto out_sc;\n\tsc->flags |= XCHK_TRY_HARDER;\n\trun.retries++;\n\tgoto retry_op;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}