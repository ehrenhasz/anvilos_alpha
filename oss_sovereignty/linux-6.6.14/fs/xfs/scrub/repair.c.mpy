{
  "module_name": "repair.c",
  "hash_id": "ad4da2624de2889ffa165599edba570d42e6d0f201fb72ee1663b66bbf0a32dc",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/repair.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_rmap_btree.h\"\n#include \"xfs_refcount_btree.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_ag_resv.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_defer.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/common.h\"\n#include \"scrub/trace.h\"\n#include \"scrub/repair.h\"\n#include \"scrub/bitmap.h\"\n#include \"scrub/stats.h\"\n\n \nint\nxrep_attempt(\n\tstruct xfs_scrub\t*sc,\n\tstruct xchk_stats_run\t*run)\n{\n\tu64\t\t\trepair_start;\n\tint\t\t\terror = 0;\n\n\ttrace_xrep_attempt(XFS_I(file_inode(sc->file)), sc->sm, error);\n\n\txchk_ag_btcur_free(&sc->sa);\n\n\t \n\tASSERT(sc->ops->repair);\n\trun->repair_attempted = true;\n\trepair_start = xchk_stats_now();\n\terror = sc->ops->repair(sc);\n\ttrace_xrep_done(XFS_I(file_inode(sc->file)), sc->sm, error);\n\trun->repair_ns += xchk_stats_elapsed_ns(repair_start);\n\tswitch (error) {\n\tcase 0:\n\t\t \n\t\tsc->sm->sm_flags &= ~XFS_SCRUB_FLAGS_OUT;\n\t\tsc->flags |= XREP_ALREADY_FIXED;\n\t\trun->repair_succeeded = true;\n\t\treturn -EAGAIN;\n\tcase -ECHRNG:\n\t\tsc->flags |= XCHK_NEED_DRAIN;\n\t\trun->retries++;\n\t\treturn -EAGAIN;\n\tcase -EDEADLOCK:\n\t\t \n\t\tif (!(sc->flags & XCHK_TRY_HARDER)) {\n\t\t\tsc->flags |= XCHK_TRY_HARDER;\n\t\t\trun->retries++;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\t \n\t\treturn 0;\n\tdefault:\n\t\t \n\t\tASSERT(error != -EAGAIN);\n\t\treturn error;\n\t}\n}\n\n \nvoid\nxrep_failure(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_alert_ratelimited(mp,\n\"Corruption not fixed during online repair.  Unmount and run xfs_repair.\");\n}\n\n \nint\nxrep_probe(\n\tstruct xfs_scrub\t*sc)\n{\n\tint\t\t\terror = 0;\n\n\tif (xchk_should_terminate(sc, &error))\n\t\treturn error;\n\n\treturn 0;\n}\n\n \nint\nxrep_roll_ag_trans(\n\tstruct xfs_scrub\t*sc)\n{\n\tint\t\t\terror;\n\n\t \n\tif (sc->sa.agi_bp) {\n\t\txfs_ialloc_log_agi(sc->tp, sc->sa.agi_bp, XFS_AGI_MAGICNUM);\n\t\txfs_trans_bhold(sc->tp, sc->sa.agi_bp);\n\t}\n\n\tif (sc->sa.agf_bp) {\n\t\txfs_alloc_log_agf(sc->tp, sc->sa.agf_bp, XFS_AGF_MAGICNUM);\n\t\txfs_trans_bhold(sc->tp, sc->sa.agf_bp);\n\t}\n\n\t \n\terror = xfs_trans_roll(&sc->tp);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (sc->sa.agi_bp)\n\t\txfs_trans_bjoin(sc->tp, sc->sa.agi_bp);\n\tif (sc->sa.agf_bp)\n\t\txfs_trans_bjoin(sc->tp, sc->sa.agf_bp);\n\n\treturn 0;\n}\n\n \nint\nxrep_defer_finish(\n\tstruct xfs_scrub\t*sc)\n{\n\tint\t\t\terror;\n\n\t \n\tif (sc->sa.agi_bp) {\n\t\txfs_ialloc_log_agi(sc->tp, sc->sa.agi_bp, XFS_AGI_MAGICNUM);\n\t\txfs_trans_bhold(sc->tp, sc->sa.agi_bp);\n\t}\n\n\tif (sc->sa.agf_bp) {\n\t\txfs_alloc_log_agf(sc->tp, sc->sa.agf_bp, XFS_AGF_MAGICNUM);\n\t\txfs_trans_bhold(sc->tp, sc->sa.agf_bp);\n\t}\n\n\t \n\terror = xfs_defer_finish(&sc->tp);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (sc->sa.agi_bp)\n\t\txfs_trans_bhold_release(sc->tp, sc->sa.agi_bp);\n\tif (sc->sa.agf_bp)\n\t\txfs_trans_bhold_release(sc->tp, sc->sa.agf_bp);\n\n\treturn 0;\n}\n\n \nbool\nxrep_ag_has_space(\n\tstruct xfs_perag\t*pag,\n\txfs_extlen_t\t\tnr_blocks,\n\tenum xfs_ag_resv_type\ttype)\n{\n\treturn  !xfs_ag_resv_critical(pag, XFS_AG_RESV_RMAPBT) &&\n\t\t!xfs_ag_resv_critical(pag, XFS_AG_RESV_METADATA) &&\n\t\tpag->pagf_freeblks > xfs_ag_resv_needed(pag, type) + nr_blocks;\n}\n\n \nxfs_extlen_t\nxrep_calc_ag_resblks(\n\tstruct xfs_scrub\t\t*sc)\n{\n\tstruct xfs_mount\t\t*mp = sc->mp;\n\tstruct xfs_scrub_metadata\t*sm = sc->sm;\n\tstruct xfs_perag\t\t*pag;\n\tstruct xfs_buf\t\t\t*bp;\n\txfs_agino_t\t\t\ticount = NULLAGINO;\n\txfs_extlen_t\t\t\taglen = NULLAGBLOCK;\n\txfs_extlen_t\t\t\tusedlen;\n\txfs_extlen_t\t\t\tfreelen;\n\txfs_extlen_t\t\t\tbnobt_sz;\n\txfs_extlen_t\t\t\tinobt_sz;\n\txfs_extlen_t\t\t\trmapbt_sz;\n\txfs_extlen_t\t\t\trefcbt_sz;\n\tint\t\t\t\terror;\n\n\tif (!(sm->sm_flags & XFS_SCRUB_IFLAG_REPAIR))\n\t\treturn 0;\n\n\tpag = xfs_perag_get(mp, sm->sm_agno);\n\tif (xfs_perag_initialised_agi(pag)) {\n\t\t \n\t\ticount = pag->pagi_count;\n\t} else {\n\t\t \n\t\terror = xfs_ialloc_read_agi(pag, NULL, &bp);\n\t\tif (!error) {\n\t\t\ticount = pag->pagi_count;\n\t\t\txfs_buf_relse(bp);\n\t\t}\n\t}\n\n\t \n\terror = xfs_alloc_read_agf(pag, NULL, 0, &bp);\n\tif (error) {\n\t\taglen = pag->block_count;\n\t\tfreelen = aglen;\n\t\tusedlen = aglen;\n\t} else {\n\t\tstruct xfs_agf\t*agf = bp->b_addr;\n\n\t\taglen = be32_to_cpu(agf->agf_length);\n\t\tfreelen = be32_to_cpu(agf->agf_freeblks);\n\t\tusedlen = aglen - freelen;\n\t\txfs_buf_relse(bp);\n\t}\n\n\t \n\tif (icount == NULLAGINO ||\n\t    !xfs_verify_agino(pag, icount)) {\n\t\ticount = pag->agino_max - pag->agino_min + 1;\n\t}\n\n\t \n\tif (aglen == NULLAGBLOCK ||\n\t    aglen != pag->block_count ||\n\t    freelen >= aglen) {\n\t\taglen = pag->block_count;\n\t\tfreelen = aglen;\n\t\tusedlen = aglen;\n\t}\n\txfs_perag_put(pag);\n\n\ttrace_xrep_calc_ag_resblks(mp, sm->sm_agno, icount, aglen,\n\t\t\tfreelen, usedlen);\n\n\t \n\tbnobt_sz = 2 * xfs_allocbt_calc_size(mp, freelen);\n\tif (xfs_has_sparseinodes(mp))\n\t\tinobt_sz = xfs_iallocbt_calc_size(mp, icount /\n\t\t\t\tXFS_INODES_PER_HOLEMASK_BIT);\n\telse\n\t\tinobt_sz = xfs_iallocbt_calc_size(mp, icount /\n\t\t\t\tXFS_INODES_PER_CHUNK);\n\tif (xfs_has_finobt(mp))\n\t\tinobt_sz *= 2;\n\tif (xfs_has_reflink(mp))\n\t\trefcbt_sz = xfs_refcountbt_calc_size(mp, usedlen);\n\telse\n\t\trefcbt_sz = 0;\n\tif (xfs_has_rmapbt(mp)) {\n\t\t \n\t\tif (xfs_has_reflink(mp))\n\t\t\trmapbt_sz = xfs_rmapbt_calc_size(mp,\n\t\t\t\t\t(unsigned long long)aglen * 2);\n\t\telse\n\t\t\trmapbt_sz = xfs_rmapbt_calc_size(mp, usedlen);\n\t} else {\n\t\trmapbt_sz = 0;\n\t}\n\n\ttrace_xrep_calc_ag_resblks_btsize(mp, sm->sm_agno, bnobt_sz,\n\t\t\tinobt_sz, rmapbt_sz, refcbt_sz);\n\n\treturn max(max(bnobt_sz, inobt_sz), max(rmapbt_sz, refcbt_sz));\n}\n\n \n\n \nint\nxrep_fix_freelist(\n\tstruct xfs_scrub\t*sc,\n\tbool\t\t\tcan_shrink)\n{\n\tstruct xfs_alloc_arg\targs = {0};\n\n\targs.mp = sc->mp;\n\targs.tp = sc->tp;\n\targs.agno = sc->sa.pag->pag_agno;\n\targs.alignment = 1;\n\targs.pag = sc->sa.pag;\n\n\treturn xfs_alloc_fix_freelist(&args,\n\t\t\tcan_shrink ? 0 : XFS_ALLOC_FLAG_NOSHRINK);\n}\n\n \n\nstruct xrep_findroot {\n\tstruct xfs_scrub\t\t*sc;\n\tstruct xfs_buf\t\t\t*agfl_bp;\n\tstruct xfs_agf\t\t\t*agf;\n\tstruct xrep_find_ag_btree\t*btree_info;\n};\n\n \nSTATIC int\nxrep_findroot_agfl_walk(\n\tstruct xfs_mount\t*mp,\n\txfs_agblock_t\t\tbno,\n\tvoid\t\t\t*priv)\n{\n\txfs_agblock_t\t\t*agbno = priv;\n\n\treturn (*agbno == bno) ? -ECANCELED : 0;\n}\n\n \nSTATIC int\nxrep_findroot_block(\n\tstruct xrep_findroot\t\t*ri,\n\tstruct xrep_find_ag_btree\t*fab,\n\tuint64_t\t\t\towner,\n\txfs_agblock_t\t\t\tagbno,\n\tbool\t\t\t\t*done_with_block)\n{\n\tstruct xfs_mount\t\t*mp = ri->sc->mp;\n\tstruct xfs_buf\t\t\t*bp;\n\tstruct xfs_btree_block\t\t*btblock;\n\txfs_daddr_t\t\t\tdaddr;\n\tint\t\t\t\tblock_level;\n\tint\t\t\t\terror = 0;\n\n\tdaddr = XFS_AGB_TO_DADDR(mp, ri->sc->sa.pag->pag_agno, agbno);\n\n\t \n\tif (owner == XFS_RMAP_OWN_AG) {\n\t\terror = xfs_agfl_walk(mp, ri->agf, ri->agfl_bp,\n\t\t\t\txrep_findroot_agfl_walk, &agbno);\n\t\tif (error == -ECANCELED)\n\t\t\treturn 0;\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\terror = xfs_trans_read_buf(mp, ri->sc->tp, mp->m_ddev_targp, daddr,\n\t\t\tmp->m_bsize, 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\n\t \n\tbtblock = XFS_BUF_TO_BLOCK(bp);\n\tASSERT(fab->buf_ops->magic[1] != 0);\n\tif (btblock->bb_magic != fab->buf_ops->magic[1])\n\t\tgoto out;\n\n\t \n\tif (bp->b_ops) {\n\t\tif (bp->b_ops != fab->buf_ops)\n\t\t\tgoto out;\n\t} else {\n\t\tASSERT(!xfs_trans_buf_is_dirty(bp));\n\t\tif (!uuid_equal(&btblock->bb_u.s.bb_uuid,\n\t\t\t\t&mp->m_sb.sb_meta_uuid))\n\t\t\tgoto out;\n\t\t \n\t\tbp->b_ops = fab->buf_ops;\n\t\tfab->buf_ops->verify_read(bp);\n\t\tif (bp->b_error) {\n\t\t\tbp->b_ops = NULL;\n\t\t\tbp->b_error = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t}\n\n\t \n\t*done_with_block = true;\n\n\t \n\tblock_level = xfs_btree_get_level(btblock);\n\tif (block_level + 1 == fab->height) {\n\t\tfab->root = NULLAGBLOCK;\n\t\tgoto out;\n\t} else if (block_level < fab->height) {\n\t\tgoto out;\n\t}\n\n\t \n\tfab->height = block_level + 1;\n\n\t \n\tif (btblock->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK) &&\n\t    btblock->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK))\n\t\tfab->root = agbno;\n\telse\n\t\tfab->root = NULLAGBLOCK;\n\n\ttrace_xrep_findroot_block(mp, ri->sc->sa.pag->pag_agno, agbno,\n\t\t\tbe32_to_cpu(btblock->bb_magic), fab->height - 1);\nout:\n\txfs_trans_brelse(ri->sc->tp, bp);\n\treturn error;\n}\n\n \nSTATIC int\nxrep_findroot_rmap(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst struct xfs_rmap_irec\t*rec,\n\tvoid\t\t\t\t*priv)\n{\n\tstruct xrep_findroot\t\t*ri = priv;\n\tstruct xrep_find_ag_btree\t*fab;\n\txfs_agblock_t\t\t\tb;\n\tbool\t\t\t\tdone;\n\tint\t\t\t\terror = 0;\n\n\t \n\tif (!XFS_RMAP_NON_INODE_OWNER(rec->rm_owner))\n\t\treturn 0;\n\n\t \n\tfor (b = 0; b < rec->rm_blockcount; b++) {\n\t\tdone = false;\n\t\tfor (fab = ri->btree_info; fab->buf_ops; fab++) {\n\t\t\tif (rec->rm_owner != fab->rmap_owner)\n\t\t\t\tcontinue;\n\t\t\terror = xrep_findroot_block(ri, fab,\n\t\t\t\t\trec->rm_owner, rec->rm_startblock + b,\n\t\t\t\t\t&done);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (done)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint\nxrep_find_ag_btree_roots(\n\tstruct xfs_scrub\t\t*sc,\n\tstruct xfs_buf\t\t\t*agf_bp,\n\tstruct xrep_find_ag_btree\t*btree_info,\n\tstruct xfs_buf\t\t\t*agfl_bp)\n{\n\tstruct xfs_mount\t\t*mp = sc->mp;\n\tstruct xrep_findroot\t\tri;\n\tstruct xrep_find_ag_btree\t*fab;\n\tstruct xfs_btree_cur\t\t*cur;\n\tint\t\t\t\terror;\n\n\tASSERT(xfs_buf_islocked(agf_bp));\n\tASSERT(agfl_bp == NULL || xfs_buf_islocked(agfl_bp));\n\n\tri.sc = sc;\n\tri.btree_info = btree_info;\n\tri.agf = agf_bp->b_addr;\n\tri.agfl_bp = agfl_bp;\n\tfor (fab = btree_info; fab->buf_ops; fab++) {\n\t\tASSERT(agfl_bp || fab->rmap_owner != XFS_RMAP_OWN_AG);\n\t\tASSERT(XFS_RMAP_NON_INODE_OWNER(fab->rmap_owner));\n\t\tfab->root = NULLAGBLOCK;\n\t\tfab->height = 0;\n\t}\n\n\tcur = xfs_rmapbt_init_cursor(mp, sc->tp, agf_bp, sc->sa.pag);\n\terror = xfs_rmap_query_all(cur, xrep_findroot_rmap, &ri);\n\txfs_btree_del_cursor(cur, error);\n\n\treturn error;\n}\n\n \nvoid\nxrep_force_quotacheck(\n\tstruct xfs_scrub\t*sc,\n\txfs_dqtype_t\t\ttype)\n{\n\tuint\t\t\tflag;\n\n\tflag = xfs_quota_chkd_flag(type);\n\tif (!(flag & sc->mp->m_qflags))\n\t\treturn;\n\n\tmutex_lock(&sc->mp->m_quotainfo->qi_quotaofflock);\n\tsc->mp->m_qflags &= ~flag;\n\tspin_lock(&sc->mp->m_sb_lock);\n\tsc->mp->m_sb.sb_qflags &= ~flag;\n\tspin_unlock(&sc->mp->m_sb_lock);\n\txfs_log_sb(sc->tp);\n\tmutex_unlock(&sc->mp->m_quotainfo->qi_quotaofflock);\n}\n\n \nint\nxrep_ino_dqattach(\n\tstruct xfs_scrub\t*sc)\n{\n\tint\t\t\terror;\n\n\terror = xfs_qm_dqattach_locked(sc->ip, false);\n\tswitch (error) {\n\tcase -EFSBADCRC:\n\tcase -EFSCORRUPTED:\n\tcase -ENOENT:\n\t\txfs_err_ratelimited(sc->mp,\n\"inode %llu repair encountered quota error %d, quotacheck forced.\",\n\t\t\t\t(unsigned long long)sc->ip->i_ino, error);\n\t\tif (XFS_IS_UQUOTA_ON(sc->mp) && !sc->ip->i_udquot)\n\t\t\txrep_force_quotacheck(sc, XFS_DQTYPE_USER);\n\t\tif (XFS_IS_GQUOTA_ON(sc->mp) && !sc->ip->i_gdquot)\n\t\t\txrep_force_quotacheck(sc, XFS_DQTYPE_GROUP);\n\t\tif (XFS_IS_PQUOTA_ON(sc->mp) && !sc->ip->i_pdquot)\n\t\t\txrep_force_quotacheck(sc, XFS_DQTYPE_PROJ);\n\t\tfallthrough;\n\tcase -ESRCH:\n\t\terror = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}