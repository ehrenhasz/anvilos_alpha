{
  "module_name": "bitmap.c",
  "hash_id": "3ade654d46fab027223d32329410ab00127f2dafe3155156354ea4167daacf0f",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/bitmap.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_btree.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/bitmap.h\"\n\n#include <linux/interval_tree_generic.h>\n\nstruct xbitmap_node {\n\tstruct rb_node\tbn_rbnode;\n\n\t \n\tuint64_t\tbn_start;\n\n\t \n\tuint64_t\tbn_last;\n\n\t \n\tuint64_t\t__bn_subtree_last;\n};\n\n \n\n#define START(node) ((node)->bn_start)\n#define LAST(node)  ((node)->bn_last)\n\n \nstatic inline void\nxbitmap_tree_insert(struct xbitmap_node *node, struct rb_root_cached *root);\n\nstatic inline void\nxbitmap_tree_remove(struct xbitmap_node *node, struct rb_root_cached *root);\n\nstatic inline struct xbitmap_node *\nxbitmap_tree_iter_first(struct rb_root_cached *root, uint64_t start,\n\t\t\tuint64_t last);\n\nstatic inline struct xbitmap_node *\nxbitmap_tree_iter_next(struct xbitmap_node *node, uint64_t start,\n\t\t       uint64_t last);\n\nINTERVAL_TREE_DEFINE(struct xbitmap_node, bn_rbnode, uint64_t,\n\t\t__bn_subtree_last, START, LAST, static inline, xbitmap_tree)\n\n \n#define for_each_xbitmap_extent(bn, bitmap) \\\n\tfor ((bn) = rb_entry_safe(rb_first(&(bitmap)->xb_root.rb_root), \\\n\t\t\t\t   struct xbitmap_node, bn_rbnode); \\\n\t     (bn) != NULL; \\\n\t     (bn) = rb_entry_safe(rb_next(&(bn)->bn_rbnode), \\\n\t\t\t\t   struct xbitmap_node, bn_rbnode))\n\n \nint\nxbitmap_clear(\n\tstruct xbitmap\t\t*bitmap,\n\tuint64_t\t\tstart,\n\tuint64_t\t\tlen)\n{\n\tstruct xbitmap_node\t*bn;\n\tstruct xbitmap_node\t*new_bn;\n\tuint64_t\t\tlast = start + len - 1;\n\n\twhile ((bn = xbitmap_tree_iter_first(&bitmap->xb_root, start, last))) {\n\t\tif (bn->bn_start < start && bn->bn_last > last) {\n\t\t\tuint64_t\told_last = bn->bn_last;\n\n\t\t\t \n\t\t\txbitmap_tree_remove(bn, &bitmap->xb_root);\n\t\t\tbn->bn_last = start - 1;\n\t\t\txbitmap_tree_insert(bn, &bitmap->xb_root);\n\n\t\t\t \n\t\t\tnew_bn = kmalloc(sizeof(struct xbitmap_node),\n\t\t\t\t\tXCHK_GFP_FLAGS);\n\t\t\tif (!new_bn)\n\t\t\t\treturn -ENOMEM;\n\t\t\tnew_bn->bn_start = last + 1;\n\t\t\tnew_bn->bn_last = old_last;\n\t\t\txbitmap_tree_insert(new_bn, &bitmap->xb_root);\n\t\t} else if (bn->bn_start < start) {\n\t\t\t \n\t\t\txbitmap_tree_remove(bn, &bitmap->xb_root);\n\t\t\tbn->bn_last = start - 1;\n\t\t\txbitmap_tree_insert(bn, &bitmap->xb_root);\n\t\t} else if (bn->bn_last > last) {\n\t\t\t \n\t\t\txbitmap_tree_remove(bn, &bitmap->xb_root);\n\t\t\tbn->bn_start = last + 1;\n\t\t\txbitmap_tree_insert(bn, &bitmap->xb_root);\n\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\txbitmap_tree_remove(bn, &bitmap->xb_root);\n\t\t\tkfree(bn);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint\nxbitmap_set(\n\tstruct xbitmap\t\t*bitmap,\n\tuint64_t\t\tstart,\n\tuint64_t\t\tlen)\n{\n\tstruct xbitmap_node\t*left;\n\tstruct xbitmap_node\t*right;\n\tuint64_t\t\tlast = start + len - 1;\n\tint\t\t\terror;\n\n\t \n\tleft = xbitmap_tree_iter_first(&bitmap->xb_root, start, last);\n\tif (left && left->bn_start <= start && left->bn_last >= last)\n\t\treturn 0;\n\n\t \n\terror = xbitmap_clear(bitmap, start, len);\n\tif (error)\n\t\treturn error;\n\n\t \n\tleft = xbitmap_tree_iter_first(&bitmap->xb_root, start - 1, start - 1);\n\tASSERT(!left || left->bn_last + 1 == start);\n\n\t \n\tright = xbitmap_tree_iter_first(&bitmap->xb_root, last + 1, last + 1);\n\tASSERT(!right || right->bn_start == last + 1);\n\n\tif (left && right) {\n\t\t \n\t\txbitmap_tree_remove(left, &bitmap->xb_root);\n\t\txbitmap_tree_remove(right, &bitmap->xb_root);\n\t\tleft->bn_last = right->bn_last;\n\t\txbitmap_tree_insert(left, &bitmap->xb_root);\n\t\tkfree(right);\n\t} else if (left) {\n\t\t \n\t\txbitmap_tree_remove(left, &bitmap->xb_root);\n\t\tleft->bn_last = last;\n\t\txbitmap_tree_insert(left, &bitmap->xb_root);\n\t} else if (right) {\n\t\t \n\t\txbitmap_tree_remove(right, &bitmap->xb_root);\n\t\tright->bn_start = start;\n\t\txbitmap_tree_insert(right, &bitmap->xb_root);\n\t} else {\n\t\t \n\t\tleft = kmalloc(sizeof(struct xbitmap_node), XCHK_GFP_FLAGS);\n\t\tif (!left)\n\t\t\treturn -ENOMEM;\n\t\tleft->bn_start = start;\n\t\tleft->bn_last = last;\n\t\txbitmap_tree_insert(left, &bitmap->xb_root);\n\t}\n\n\treturn 0;\n}\n\n \nvoid\nxbitmap_destroy(\n\tstruct xbitmap\t\t*bitmap)\n{\n\tstruct xbitmap_node\t*bn;\n\n\twhile ((bn = xbitmap_tree_iter_first(&bitmap->xb_root, 0, -1ULL))) {\n\t\txbitmap_tree_remove(bn, &bitmap->xb_root);\n\t\tkfree(bn);\n\t}\n}\n\n \nvoid\nxbitmap_init(\n\tstruct xbitmap\t\t*bitmap)\n{\n\tbitmap->xb_root = RB_ROOT_CACHED;\n}\n\n \nint\nxbitmap_disunion(\n\tstruct xbitmap\t\t*bitmap,\n\tstruct xbitmap\t\t*sub)\n{\n\tstruct xbitmap_node\t*bn;\n\tint\t\t\terror;\n\n\tif (xbitmap_empty(bitmap) || xbitmap_empty(sub))\n\t\treturn 0;\n\n\tfor_each_xbitmap_extent(bn, sub) {\n\t\terror = xbitmap_clear(bitmap, bn->bn_start,\n\t\t\t\tbn->bn_last - bn->bn_start + 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \n\n \nSTATIC int\nxagb_bitmap_visit_btblock(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tvoid\t\t\t*priv)\n{\n\tstruct xagb_bitmap\t*bitmap = priv;\n\tstruct xfs_buf\t\t*bp;\n\txfs_fsblock_t\t\tfsbno;\n\txfs_agblock_t\t\tagbno;\n\n\txfs_btree_get_block(cur, level, &bp);\n\tif (!bp)\n\t\treturn 0;\n\n\tfsbno = XFS_DADDR_TO_FSB(cur->bc_mp, xfs_buf_daddr(bp));\n\tagbno = XFS_FSB_TO_AGBNO(cur->bc_mp, fsbno);\n\n\treturn xagb_bitmap_set(bitmap, agbno, 1);\n}\n\n \nint\nxagb_bitmap_set_btblocks(\n\tstruct xagb_bitmap\t*bitmap,\n\tstruct xfs_btree_cur\t*cur)\n{\n\treturn xfs_btree_visit_blocks(cur, xagb_bitmap_visit_btblock,\n\t\t\tXFS_BTREE_VISIT_ALL, bitmap);\n}\n\n \nint\nxagb_bitmap_set_btcur_path(\n\tstruct xagb_bitmap\t*bitmap,\n\tstruct xfs_btree_cur\t*cur)\n{\n\tint\t\t\ti;\n\tint\t\t\terror;\n\n\tfor (i = 0; i < cur->bc_nlevels && cur->bc_levels[i].ptr == 1; i++) {\n\t\terror = xagb_bitmap_visit_btblock(cur, i, bitmap);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \nuint64_t\nxbitmap_hweight(\n\tstruct xbitmap\t\t*bitmap)\n{\n\tstruct xbitmap_node\t*bn;\n\tuint64_t\t\tret = 0;\n\n\tfor_each_xbitmap_extent(bn, bitmap)\n\t\tret += bn->bn_last - bn->bn_start + 1;\n\n\treturn ret;\n}\n\n \nint\nxbitmap_walk(\n\tstruct xbitmap\t\t*bitmap,\n\txbitmap_walk_fn\t\tfn,\n\tvoid\t\t\t*priv)\n{\n\tstruct xbitmap_node\t*bn;\n\tint\t\t\terror = 0;\n\n\tfor_each_xbitmap_extent(bn, bitmap) {\n\t\terror = fn(bn->bn_start, bn->bn_last - bn->bn_start + 1, priv);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}\n\n \nbool\nxbitmap_empty(\n\tstruct xbitmap\t\t*bitmap)\n{\n\treturn bitmap->xb_root.rb_root.rb_node == NULL;\n}\n\n \nbool\nxbitmap_test(\n\tstruct xbitmap\t\t*bitmap,\n\tuint64_t\t\tstart,\n\tuint64_t\t\t*len)\n{\n\tstruct xbitmap_node\t*bn;\n\tuint64_t\t\tlast = start + *len - 1;\n\n\tbn = xbitmap_tree_iter_first(&bitmap->xb_root, start, last);\n\tif (!bn)\n\t\treturn false;\n\tif (bn->bn_start <= start) {\n\t\tif (bn->bn_last < last)\n\t\t\t*len = bn->bn_last - start + 1;\n\t\treturn true;\n\t}\n\t*len = bn->bn_start - start;\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}