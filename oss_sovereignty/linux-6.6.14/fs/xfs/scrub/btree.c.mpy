{
  "module_name": "btree.c",
  "hash_id": "d8d1bb6e4404c63b7b19292ffc0e55eda3896f69976aa3fa244d1fdbc01a96ec",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/btree.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_btree.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/common.h\"\n#include \"scrub/btree.h\"\n#include \"scrub/trace.h\"\n\n \n\n \nstatic bool\n__xchk_btree_process_error(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*error,\n\t__u32\t\t\terrflag,\n\tvoid\t\t\t*ret_ip)\n{\n\tif (*error == 0)\n\t\treturn true;\n\n\tswitch (*error) {\n\tcase -EDEADLOCK:\n\tcase -ECHRNG:\n\t\t \n\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);\n\t\tbreak;\n\tcase -EFSBADCRC:\n\tcase -EFSCORRUPTED:\n\t\t \n\t\tsc->sm->sm_flags |= errflag;\n\t\t*error = 0;\n\t\tfallthrough;\n\tdefault:\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\ttrace_xchk_ifork_btree_op_error(sc, cur, level,\n\t\t\t\t\t*error, ret_ip);\n\t\telse\n\t\t\ttrace_xchk_btree_op_error(sc, cur, level,\n\t\t\t\t\t*error, ret_ip);\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nbool\nxchk_btree_process_error(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*error)\n{\n\treturn __xchk_btree_process_error(sc, cur, level, error,\n\t\t\tXFS_SCRUB_OFLAG_CORRUPT, __return_address);\n}\n\nbool\nxchk_btree_xref_process_error(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*error)\n{\n\treturn __xchk_btree_process_error(sc, cur, level, error,\n\t\t\tXFS_SCRUB_OFLAG_XFAIL, __return_address);\n}\n\n \nstatic void\n__xchk_btree_set_corrupt(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\t__u32\t\t\terrflag,\n\tvoid\t\t\t*ret_ip)\n{\n\tsc->sm->sm_flags |= errflag;\n\n\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\ttrace_xchk_ifork_btree_error(sc, cur, level,\n\t\t\t\tret_ip);\n\telse\n\t\ttrace_xchk_btree_error(sc, cur, level,\n\t\t\t\tret_ip);\n}\n\nvoid\nxchk_btree_set_corrupt(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\t__xchk_btree_set_corrupt(sc, cur, level, XFS_SCRUB_OFLAG_CORRUPT,\n\t\t\t__return_address);\n}\n\nvoid\nxchk_btree_xref_set_corrupt(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\t__xchk_btree_set_corrupt(sc, cur, level, XFS_SCRUB_OFLAG_XCORRUPT,\n\t\t\t__return_address);\n}\n\nvoid\nxchk_btree_set_preen(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\t__xchk_btree_set_corrupt(sc, cur, level, XFS_SCRUB_OFLAG_PREEN,\n\t\t\t__return_address);\n}\n\n \nSTATIC void\nxchk_btree_rec(\n\tstruct xchk_btree\t*bs)\n{\n\tstruct xfs_btree_cur\t*cur = bs->cur;\n\tunion xfs_btree_rec\t*rec;\n\tunion xfs_btree_key\tkey;\n\tunion xfs_btree_key\thkey;\n\tunion xfs_btree_key\t*keyp;\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_btree_block\t*keyblock;\n\tstruct xfs_buf\t\t*bp;\n\n\tblock = xfs_btree_get_block(cur, 0, &bp);\n\trec = xfs_btree_rec_addr(cur, cur->bc_levels[0].ptr, block);\n\n\ttrace_xchk_btree_rec(bs->sc, cur, 0);\n\n\t \n\tif (bs->lastrec_valid &&\n\t    !cur->bc_ops->recs_inorder(cur, &bs->lastrec, rec))\n\t\txchk_btree_set_corrupt(bs->sc, cur, 0);\n\tmemcpy(&bs->lastrec, rec, cur->bc_ops->rec_len);\n\tbs->lastrec_valid = true;\n\n\tif (cur->bc_nlevels == 1)\n\t\treturn;\n\n\t \n\tcur->bc_ops->init_key_from_rec(&key, rec);\n\tkeyblock = xfs_btree_get_block(cur, 1, &bp);\n\tkeyp = xfs_btree_key_addr(cur, cur->bc_levels[1].ptr, keyblock);\n\tif (xfs_btree_keycmp_lt(cur, &key, keyp))\n\t\txchk_btree_set_corrupt(bs->sc, cur, 1);\n\n\tif (!(cur->bc_flags & XFS_BTREE_OVERLAPPING))\n\t\treturn;\n\n\t \n\tcur->bc_ops->init_high_key_from_rec(&hkey, rec);\n\tkeyp = xfs_btree_high_key_addr(cur, cur->bc_levels[1].ptr, keyblock);\n\tif (xfs_btree_keycmp_lt(cur, keyp, &hkey))\n\t\txchk_btree_set_corrupt(bs->sc, cur, 1);\n}\n\n \nSTATIC void\nxchk_btree_key(\n\tstruct xchk_btree\t*bs,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_cur\t*cur = bs->cur;\n\tunion xfs_btree_key\t*key;\n\tunion xfs_btree_key\t*keyp;\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_btree_block\t*keyblock;\n\tstruct xfs_buf\t\t*bp;\n\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\tkey = xfs_btree_key_addr(cur, cur->bc_levels[level].ptr, block);\n\n\ttrace_xchk_btree_key(bs->sc, cur, level);\n\n\t \n\tif (bs->lastkey[level - 1].valid &&\n\t    !cur->bc_ops->keys_inorder(cur, &bs->lastkey[level - 1].key, key))\n\t\txchk_btree_set_corrupt(bs->sc, cur, level);\n\tmemcpy(&bs->lastkey[level - 1].key, key, cur->bc_ops->key_len);\n\tbs->lastkey[level - 1].valid = true;\n\n\tif (level + 1 >= cur->bc_nlevels)\n\t\treturn;\n\n\t \n\tkeyblock = xfs_btree_get_block(cur, level + 1, &bp);\n\tkeyp = xfs_btree_key_addr(cur, cur->bc_levels[level + 1].ptr, keyblock);\n\tif (xfs_btree_keycmp_lt(cur, key, keyp))\n\t\txchk_btree_set_corrupt(bs->sc, cur, level);\n\n\tif (!(cur->bc_flags & XFS_BTREE_OVERLAPPING))\n\t\treturn;\n\n\t \n\tkey = xfs_btree_high_key_addr(cur, cur->bc_levels[level].ptr, block);\n\tkeyp = xfs_btree_high_key_addr(cur, cur->bc_levels[level + 1].ptr,\n\t\t\tkeyblock);\n\tif (xfs_btree_keycmp_lt(cur, keyp, key))\n\t\txchk_btree_set_corrupt(bs->sc, cur, level);\n}\n\n \nstatic bool\nxchk_btree_ptr_ok(\n\tstruct xchk_btree\t*bs,\n\tint\t\t\tlevel,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tbool\t\t\tres;\n\n\t \n\tif ((bs->cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    level == bs->cur->bc_nlevels)\n\t\treturn true;\n\n\t \n\tif (bs->cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\tres = xfs_btree_check_lptr(bs->cur, be64_to_cpu(ptr->l), level);\n\telse\n\t\tres = xfs_btree_check_sptr(bs->cur, be32_to_cpu(ptr->s), level);\n\tif (!res)\n\t\txchk_btree_set_corrupt(bs->sc, bs->cur, level);\n\n\treturn res;\n}\n\n \nSTATIC int\nxchk_btree_block_check_sibling(\n\tstruct xchk_btree\t*bs,\n\tint\t\t\tlevel,\n\tint\t\t\tdirection,\n\tunion xfs_btree_ptr\t*sibling)\n{\n\tstruct xfs_btree_cur\t*cur = bs->cur;\n\tstruct xfs_btree_block\t*pblock;\n\tstruct xfs_buf\t\t*pbp;\n\tstruct xfs_btree_cur\t*ncur = NULL;\n\tunion xfs_btree_ptr\t*pp;\n\tint\t\t\tsuccess;\n\tint\t\t\terror;\n\n\terror = xfs_btree_dup_cursor(cur, &ncur);\n\tif (!xchk_btree_process_error(bs->sc, cur, level + 1, &error) ||\n\t    !ncur)\n\t\treturn error;\n\n\t \n\tif (xfs_btree_ptr_is_null(cur, sibling)) {\n\t\tif (direction > 0)\n\t\t\terror = xfs_btree_increment(ncur, level + 1, &success);\n\t\telse\n\t\t\terror = xfs_btree_decrement(ncur, level + 1, &success);\n\t\tif (error == 0 && success)\n\t\t\txchk_btree_set_corrupt(bs->sc, cur, level);\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tif (direction > 0)\n\t\terror = xfs_btree_increment(ncur, level + 1, &success);\n\telse\n\t\terror = xfs_btree_decrement(ncur, level + 1, &success);\n\tif (!xchk_btree_process_error(bs->sc, cur, level + 1, &error))\n\t\tgoto out;\n\tif (!success) {\n\t\txchk_btree_set_corrupt(bs->sc, cur, level + 1);\n\t\tgoto out;\n\t}\n\n\t \n\tpblock = xfs_btree_get_block(ncur, level + 1, &pbp);\n\tpp = xfs_btree_ptr_addr(ncur, ncur->bc_levels[level + 1].ptr, pblock);\n\tif (!xchk_btree_ptr_ok(bs, level + 1, pp))\n\t\tgoto out;\n\tif (pbp)\n\t\txchk_buffer_recheck(bs->sc, pbp);\n\n\tif (xfs_btree_diff_two_ptrs(cur, pp, sibling))\n\t\txchk_btree_set_corrupt(bs->sc, cur, level);\nout:\n\txfs_btree_del_cursor(ncur, XFS_BTREE_ERROR);\n\treturn error;\n}\n\n \nSTATIC int\nxchk_btree_block_check_siblings(\n\tstruct xchk_btree\t*bs,\n\tstruct xfs_btree_block\t*block)\n{\n\tstruct xfs_btree_cur\t*cur = bs->cur;\n\tunion xfs_btree_ptr\tleftsib;\n\tunion xfs_btree_ptr\trightsib;\n\tint\t\t\tlevel;\n\tint\t\t\terror = 0;\n\n\txfs_btree_get_sibling(cur, block, &leftsib, XFS_BB_LEFTSIB);\n\txfs_btree_get_sibling(cur, block, &rightsib, XFS_BB_RIGHTSIB);\n\tlevel = xfs_btree_get_level(block);\n\n\t \n\tif (level == cur->bc_nlevels - 1) {\n\t\tif (!xfs_btree_ptr_is_null(cur, &leftsib) ||\n\t\t    !xfs_btree_ptr_is_null(cur, &rightsib))\n\t\t\txchk_btree_set_corrupt(bs->sc, cur, level);\n\t\tgoto out;\n\t}\n\n\t \n\terror = xchk_btree_block_check_sibling(bs, level, -1, &leftsib);\n\tif (error)\n\t\treturn error;\n\terror = xchk_btree_block_check_sibling(bs, level, 1, &rightsib);\n\tif (error)\n\t\treturn error;\nout:\n\treturn error;\n}\n\nstruct check_owner {\n\tstruct list_head\tlist;\n\txfs_daddr_t\t\tdaddr;\n\tint\t\t\tlevel;\n};\n\n \nSTATIC int\nxchk_btree_check_block_owner(\n\tstruct xchk_btree\t*bs,\n\tint\t\t\tlevel,\n\txfs_daddr_t\t\tdaddr)\n{\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\txfs_btnum_t\t\tbtnum;\n\tbool\t\t\tinit_sa;\n\tint\t\t\terror = 0;\n\n\tif (!bs->cur)\n\t\treturn 0;\n\n\tbtnum = bs->cur->bc_btnum;\n\tagno = xfs_daddr_to_agno(bs->cur->bc_mp, daddr);\n\tagbno = xfs_daddr_to_agbno(bs->cur->bc_mp, daddr);\n\n\tinit_sa = bs->cur->bc_flags & XFS_BTREE_LONG_PTRS;\n\tif (init_sa) {\n\t\terror = xchk_ag_init_existing(bs->sc, agno, &bs->sc->sa);\n\t\tif (!xchk_btree_xref_process_error(bs->sc, bs->cur,\n\t\t\t\tlevel, &error))\n\t\t\tgoto out_free;\n\t}\n\n\txchk_xref_is_used_space(bs->sc, agbno, 1);\n\t \n\tif (!bs->sc->sa.bno_cur && btnum == XFS_BTNUM_BNO)\n\t\tbs->cur = NULL;\n\n\txchk_xref_is_only_owned_by(bs->sc, agbno, 1, bs->oinfo);\n\tif (!bs->sc->sa.rmap_cur && btnum == XFS_BTNUM_RMAP)\n\t\tbs->cur = NULL;\n\nout_free:\n\tif (init_sa)\n\t\txchk_ag_free(bs->sc, &bs->sc->sa);\n\n\treturn error;\n}\n\n \nSTATIC int\nxchk_btree_check_owner(\n\tstruct xchk_btree\t*bs,\n\tint\t\t\tlevel,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_btree_cur\t*cur = bs->cur;\n\n\t \n\tif (bp == NULL) {\n\t\tif (!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE))\n\t\t\txchk_btree_set_corrupt(bs->sc, bs->cur, level);\n\t\treturn 0;\n\t}\n\n\t \n\tif (cur->bc_btnum == XFS_BTNUM_BNO || cur->bc_btnum == XFS_BTNUM_RMAP) {\n\t\tstruct check_owner\t*co;\n\n\t\tco = kmalloc(sizeof(struct check_owner), XCHK_GFP_FLAGS);\n\t\tif (!co)\n\t\t\treturn -ENOMEM;\n\n\t\tINIT_LIST_HEAD(&co->list);\n\t\tco->level = level;\n\t\tco->daddr = xfs_buf_daddr(bp);\n\t\tlist_add_tail(&co->list, &bs->to_check);\n\t\treturn 0;\n\t}\n\n\treturn xchk_btree_check_block_owner(bs, level, xfs_buf_daddr(bp));\n}\n\n \nstatic inline bool\nxchk_btree_check_iroot_minrecs(\n\tstruct xchk_btree\t*bs)\n{\n\t \n\tif (bs->cur->bc_btnum == XFS_BTNUM_BMAP &&\n\t    bs->cur->bc_ino.whichfork == XFS_DATA_FORK &&\n\t    xfs_inode_has_attr_fork(bs->sc->ip))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nSTATIC void\nxchk_btree_check_minrecs(\n\tstruct xchk_btree\t*bs,\n\tint\t\t\tlevel,\n\tstruct xfs_btree_block\t*block)\n{\n\tstruct xfs_btree_cur\t*cur = bs->cur;\n\tunsigned int\t\troot_level = cur->bc_nlevels - 1;\n\tunsigned int\t\tnumrecs = be16_to_cpu(block->bb_numrecs);\n\n\t \n\tif (numrecs >= cur->bc_ops->get_minrecs(cur, level))\n\t\treturn;\n\n\t \n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    level == cur->bc_nlevels - 2) {\n\t\tstruct xfs_btree_block\t*root_block;\n\t\tstruct xfs_buf\t\t*root_bp;\n\t\tint\t\t\troot_maxrecs;\n\n\t\troot_block = xfs_btree_get_block(cur, root_level, &root_bp);\n\t\troot_maxrecs = cur->bc_ops->get_dmaxrecs(cur, root_level);\n\t\tif (xchk_btree_check_iroot_minrecs(bs) &&\n\t\t    (be16_to_cpu(root_block->bb_numrecs) != 1 ||\n\t\t     numrecs <= root_maxrecs))\n\t\t\txchk_btree_set_corrupt(bs->sc, cur, level);\n\t\treturn;\n\t}\n\n\t \n\tif (level < root_level)\n\t\txchk_btree_set_corrupt(bs->sc, cur, level);\n}\n\n \nSTATIC void\nxchk_btree_block_check_keys(\n\tstruct xchk_btree\t*bs,\n\tint\t\t\tlevel,\n\tstruct xfs_btree_block\t*block)\n{\n\tunion xfs_btree_key\tblock_key;\n\tunion xfs_btree_key\t*block_high_key;\n\tunion xfs_btree_key\t*parent_low_key, *parent_high_key;\n\tstruct xfs_btree_cur\t*cur = bs->cur;\n\tstruct xfs_btree_block\t*parent_block;\n\tstruct xfs_buf\t\t*bp;\n\n\tif (level == cur->bc_nlevels - 1)\n\t\treturn;\n\n\txfs_btree_get_keys(cur, block, &block_key);\n\n\t \n\tparent_block = xfs_btree_get_block(cur, level + 1, &bp);\n\tparent_low_key = xfs_btree_key_addr(cur, cur->bc_levels[level + 1].ptr,\n\t\t\tparent_block);\n\tif (xfs_btree_keycmp_ne(cur, &block_key, parent_low_key)) {\n\t\txchk_btree_set_corrupt(bs->sc, bs->cur, level);\n\t\treturn;\n\t}\n\n\tif (!(cur->bc_flags & XFS_BTREE_OVERLAPPING))\n\t\treturn;\n\n\t \n\tparent_high_key = xfs_btree_high_key_addr(cur,\n\t\t\tcur->bc_levels[level + 1].ptr, parent_block);\n\tblock_high_key = xfs_btree_high_key_from_key(cur, &block_key);\n\tif (xfs_btree_keycmp_ne(cur, block_high_key, parent_high_key))\n\t\txchk_btree_set_corrupt(bs->sc, bs->cur, level);\n}\n\n \nSTATIC int\nxchk_btree_get_block(\n\tstruct xchk_btree\t*bs,\n\tint\t\t\tlevel,\n\tunion xfs_btree_ptr\t*pp,\n\tstruct xfs_btree_block\t**pblock,\n\tstruct xfs_buf\t\t**pbp)\n{\n\txfs_failaddr_t\t\tfailed_at;\n\tint\t\t\terror;\n\n\t*pblock = NULL;\n\t*pbp = NULL;\n\n\terror = xfs_btree_lookup_get_block(bs->cur, level, pp, pblock);\n\tif (!xchk_btree_process_error(bs->sc, bs->cur, level, &error) ||\n\t    !*pblock)\n\t\treturn error;\n\n\txfs_btree_get_block(bs->cur, level, pbp);\n\tif (bs->cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\tfailed_at = __xfs_btree_check_lblock(bs->cur, *pblock,\n\t\t\t\tlevel, *pbp);\n\telse\n\t\tfailed_at = __xfs_btree_check_sblock(bs->cur, *pblock,\n\t\t\t\t level, *pbp);\n\tif (failed_at) {\n\t\txchk_btree_set_corrupt(bs->sc, bs->cur, level);\n\t\treturn 0;\n\t}\n\tif (*pbp)\n\t\txchk_buffer_recheck(bs->sc, *pbp);\n\n\txchk_btree_check_minrecs(bs, level, *pblock);\n\n\t \n\terror = xchk_btree_check_owner(bs, level, *pbp);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = xchk_btree_block_check_siblings(bs, *pblock);\n\tif (error)\n\t\treturn error;\n\n\txchk_btree_block_check_keys(bs, level, *pblock);\n\treturn 0;\n}\n\n \nSTATIC void\nxchk_btree_block_keys(\n\tstruct xchk_btree\t*bs,\n\tint\t\t\tlevel,\n\tstruct xfs_btree_block\t*block)\n{\n\tunion xfs_btree_key\tblock_keys;\n\tstruct xfs_btree_cur\t*cur = bs->cur;\n\tunion xfs_btree_key\t*high_bk;\n\tunion xfs_btree_key\t*parent_keys;\n\tunion xfs_btree_key\t*high_pk;\n\tstruct xfs_btree_block\t*parent_block;\n\tstruct xfs_buf\t\t*bp;\n\n\tif (level >= cur->bc_nlevels - 1)\n\t\treturn;\n\n\t \n\txfs_btree_get_keys(cur, block, &block_keys);\n\n\t \n\tparent_block = xfs_btree_get_block(cur, level + 1, &bp);\n\tparent_keys = xfs_btree_key_addr(cur, cur->bc_levels[level + 1].ptr,\n\t\t\tparent_block);\n\n\tif (xfs_btree_keycmp_ne(cur, &block_keys, parent_keys))\n\t\txchk_btree_set_corrupt(bs->sc, cur, 1);\n\n\tif (!(cur->bc_flags & XFS_BTREE_OVERLAPPING))\n\t\treturn;\n\n\t \n\thigh_bk = xfs_btree_high_key_from_key(cur, &block_keys);\n\thigh_pk = xfs_btree_high_key_addr(cur, cur->bc_levels[level + 1].ptr,\n\t\t\tparent_block);\n\n\tif (xfs_btree_keycmp_ne(cur, high_bk, high_pk))\n\t\txchk_btree_set_corrupt(bs->sc, cur, 1);\n}\n\n \nint\nxchk_btree(\n\tstruct xfs_scrub\t\t*sc,\n\tstruct xfs_btree_cur\t\t*cur,\n\txchk_btree_rec_fn\t\tscrub_fn,\n\tconst struct xfs_owner_info\t*oinfo,\n\tvoid\t\t\t\t*private)\n{\n\tunion xfs_btree_ptr\t\tptr;\n\tstruct xchk_btree\t\t*bs;\n\tunion xfs_btree_ptr\t\t*pp;\n\tunion xfs_btree_rec\t\t*recp;\n\tstruct xfs_btree_block\t\t*block;\n\tstruct xfs_buf\t\t\t*bp;\n\tstruct check_owner\t\t*co;\n\tstruct check_owner\t\t*n;\n\tsize_t\t\t\t\tcur_sz;\n\tint\t\t\t\tlevel;\n\tint\t\t\t\terror = 0;\n\n\t \n\tcur_sz = xchk_btree_sizeof(cur->bc_nlevels);\n\tif (cur_sz > PAGE_SIZE) {\n\t\txchk_btree_set_corrupt(sc, cur, 0);\n\t\treturn 0;\n\t}\n\tbs = kzalloc(cur_sz, XCHK_GFP_FLAGS);\n\tif (!bs)\n\t\treturn -ENOMEM;\n\tbs->cur = cur;\n\tbs->scrub_rec = scrub_fn;\n\tbs->oinfo = oinfo;\n\tbs->private = private;\n\tbs->sc = sc;\n\n\t \n\tINIT_LIST_HEAD(&bs->to_check);\n\n\t \n\tlevel = cur->bc_nlevels - 1;\n\tcur->bc_ops->init_ptr_from_cur(cur, &ptr);\n\tif (!xchk_btree_ptr_ok(bs, cur->bc_nlevels, &ptr))\n\t\tgoto out;\n\terror = xchk_btree_get_block(bs, level, &ptr, &block, &bp);\n\tif (error || !block)\n\t\tgoto out;\n\n\tcur->bc_levels[level].ptr = 1;\n\n\twhile (level < cur->bc_nlevels) {\n\t\tblock = xfs_btree_get_block(cur, level, &bp);\n\n\t\tif (level == 0) {\n\t\t\t \n\t\t\tif (cur->bc_levels[level].ptr >\n\t\t\t    be16_to_cpu(block->bb_numrecs)) {\n\t\t\t\txchk_btree_block_keys(bs, level, block);\n\t\t\t\tif (level < cur->bc_nlevels - 1)\n\t\t\t\t\tcur->bc_levels[level + 1].ptr++;\n\t\t\t\tlevel++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\txchk_btree_rec(bs);\n\n\t\t\t \n\t\t\trecp = xfs_btree_rec_addr(cur, cur->bc_levels[0].ptr,\n\t\t\t\t\tblock);\n\t\t\terror = bs->scrub_rec(bs, recp);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tif (xchk_should_terminate(sc, &error) ||\n\t\t\t    (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT))\n\t\t\t\tbreak;\n\n\t\t\tcur->bc_levels[level].ptr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (cur->bc_levels[level].ptr >\n\t\t\t\t\tbe16_to_cpu(block->bb_numrecs)) {\n\t\t\txchk_btree_block_keys(bs, level, block);\n\t\t\tif (level < cur->bc_nlevels - 1)\n\t\t\t\tcur->bc_levels[level + 1].ptr++;\n\t\t\tlevel++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\txchk_btree_key(bs, level);\n\n\t\t \n\t\tpp = xfs_btree_ptr_addr(cur, cur->bc_levels[level].ptr, block);\n\t\tif (!xchk_btree_ptr_ok(bs, level, pp)) {\n\t\t\tcur->bc_levels[level].ptr++;\n\t\t\tcontinue;\n\t\t}\n\t\tlevel--;\n\t\terror = xchk_btree_get_block(bs, level, pp, &block, &bp);\n\t\tif (error || !block)\n\t\t\tgoto out;\n\n\t\tcur->bc_levels[level].ptr = 1;\n\t}\n\nout:\n\t \n\tlist_for_each_entry_safe(co, n, &bs->to_check, list) {\n\t\tif (!error && bs->cur)\n\t\t\terror = xchk_btree_check_block_owner(bs, co->level,\n\t\t\t\t\tco->daddr);\n\t\tlist_del(&co->list);\n\t\tkfree(co);\n\t}\n\tkfree(bs);\n\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}