{
  "module_name": "refcount.c",
  "hash_id": "5f76c4aea4335ef678fc9d94b77590582bee4858ca121ab7d89afbcd150cc4d6",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/refcount.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_refcount.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/common.h\"\n#include \"scrub/btree.h\"\n#include \"scrub/trace.h\"\n\n \nint\nxchk_setup_ag_refcountbt(\n\tstruct xfs_scrub\t*sc)\n{\n\tif (xchk_need_intent_drain(sc))\n\t\txchk_fsgates_enable(sc, XCHK_FSGATES_DRAIN);\n\treturn xchk_setup_ag_btree(sc, false);\n}\n\n \n\n \nstruct xchk_refcnt_frag {\n\tstruct list_head\tlist;\n\tstruct xfs_rmap_irec\trm;\n};\n\nstruct xchk_refcnt_check {\n\tstruct xfs_scrub\t*sc;\n\tstruct list_head\tfragments;\n\n\t \n\txfs_agblock_t\t\tbno;\n\txfs_extlen_t\t\tlen;\n\txfs_nlink_t\t\trefcount;\n\n\t \n\txfs_nlink_t\t\tseen;\n};\n\n \nSTATIC int\nxchk_refcountbt_rmap_check(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst struct xfs_rmap_irec\t*rec,\n\tvoid\t\t\t\t*priv)\n{\n\tstruct xchk_refcnt_check\t*refchk = priv;\n\tstruct xchk_refcnt_frag\t\t*frag;\n\txfs_agblock_t\t\t\trm_last;\n\txfs_agblock_t\t\t\trc_last;\n\tint\t\t\t\terror = 0;\n\n\tif (xchk_should_terminate(refchk->sc, &error))\n\t\treturn error;\n\n\trm_last = rec->rm_startblock + rec->rm_blockcount - 1;\n\trc_last = refchk->bno + refchk->len - 1;\n\n\t \n\tif (refchk->refcount == 1 && rec->rm_owner != XFS_RMAP_OWN_COW) {\n\t\txchk_btree_xref_set_corrupt(refchk->sc, cur, 0);\n\t\treturn 0;\n\t}\n\n\tif (rec->rm_startblock <= refchk->bno && rm_last >= rc_last) {\n\t\t \n\t\trefchk->seen++;\n\t} else {\n\t\t \n\t\tfrag = kmalloc(sizeof(struct xchk_refcnt_frag),\n\t\t\t\tXCHK_GFP_FLAGS);\n\t\tif (!frag)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(&frag->rm, rec, sizeof(frag->rm));\n\t\tlist_add_tail(&frag->list, &refchk->fragments);\n\t}\n\n\treturn 0;\n}\n\n \nSTATIC void\nxchk_refcountbt_process_rmap_fragments(\n\tstruct xchk_refcnt_check\t*refchk)\n{\n\tstruct list_head\t\tworklist;\n\tstruct xchk_refcnt_frag\t\t*frag;\n\tstruct xchk_refcnt_frag\t\t*n;\n\txfs_agblock_t\t\t\tbno;\n\txfs_agblock_t\t\t\trbno;\n\txfs_agblock_t\t\t\tnext_rbno;\n\txfs_nlink_t\t\t\tnr;\n\txfs_nlink_t\t\t\ttarget_nr;\n\n\ttarget_nr = refchk->refcount - refchk->seen;\n\tif (target_nr == 0)\n\t\treturn;\n\n\t \n\tINIT_LIST_HEAD(&worklist);\n\trbno = NULLAGBLOCK;\n\n\t \n\tbno = 0;\n\tlist_for_each_entry(frag, &refchk->fragments, list) {\n\t\tif (frag->rm.rm_startblock < bno)\n\t\t\tgoto done;\n\t\tbno = frag->rm.rm_startblock;\n\t}\n\n\t \n\tnr = 0;\n\tlist_for_each_entry_safe(frag, n, &refchk->fragments, list) {\n\t\tif (frag->rm.rm_startblock > refchk->bno || nr > target_nr)\n\t\t\tbreak;\n\t\tbno = frag->rm.rm_startblock + frag->rm.rm_blockcount;\n\t\tif (bno < rbno)\n\t\t\trbno = bno;\n\t\tlist_move_tail(&frag->list, &worklist);\n\t\tnr++;\n\t}\n\n\t \n\tif (nr != target_nr)\n\t\tgoto done;\n\n\twhile (!list_empty(&refchk->fragments)) {\n\t\t \n\t\tnr = 0;\n\t\tnext_rbno = NULLAGBLOCK;\n\t\tlist_for_each_entry_safe(frag, n, &worklist, list) {\n\t\t\tbno = frag->rm.rm_startblock + frag->rm.rm_blockcount;\n\t\t\tif (bno != rbno) {\n\t\t\t\tif (bno < next_rbno)\n\t\t\t\t\tnext_rbno = bno;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlist_del(&frag->list);\n\t\t\tkfree(frag);\n\t\t\tnr++;\n\t\t}\n\n\t\t \n\t\tlist_for_each_entry_safe(frag, n, &refchk->fragments, list) {\n\t\t\tbno = frag->rm.rm_startblock + frag->rm.rm_blockcount;\n\t\t\tif (frag->rm.rm_startblock != rbno)\n\t\t\t\tgoto done;\n\t\t\tlist_move_tail(&frag->list, &worklist);\n\t\t\tif (next_rbno > bno)\n\t\t\t\tnext_rbno = bno;\n\t\t\tnr--;\n\t\t\tif (nr == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (nr)\n\t\t\tgoto done;\n\n\t\trbno = next_rbno;\n\t}\n\n\t \n\tif (rbno < refchk->bno + refchk->len)\n\t\tgoto done;\n\n\t \n\trefchk->seen = refchk->refcount;\ndone:\n\t \n\tlist_for_each_entry_safe(frag, n, &worklist, list) {\n\t\tlist_del(&frag->list);\n\t\tkfree(frag);\n\t}\n\tlist_for_each_entry_safe(frag, n, &refchk->fragments, list) {\n\t\tlist_del(&frag->list);\n\t\tkfree(frag);\n\t}\n}\n\n \nSTATIC void\nxchk_refcountbt_xref_rmap(\n\tstruct xfs_scrub\t\t*sc,\n\tconst struct xfs_refcount_irec\t*irec)\n{\n\tstruct xchk_refcnt_check\trefchk = {\n\t\t.sc\t\t\t= sc,\n\t\t.bno\t\t\t= irec->rc_startblock,\n\t\t.len\t\t\t= irec->rc_blockcount,\n\t\t.refcount\t\t= irec->rc_refcount,\n\t\t.seen = 0,\n\t};\n\tstruct xfs_rmap_irec\t\tlow;\n\tstruct xfs_rmap_irec\t\thigh;\n\tstruct xchk_refcnt_frag\t\t*frag;\n\tstruct xchk_refcnt_frag\t\t*n;\n\tint\t\t\t\terror;\n\n\tif (!sc->sa.rmap_cur || xchk_skip_xref(sc->sm))\n\t\treturn;\n\n\t \n\tmemset(&low, 0, sizeof(low));\n\tlow.rm_startblock = irec->rc_startblock;\n\tmemset(&high, 0xFF, sizeof(high));\n\thigh.rm_startblock = irec->rc_startblock + irec->rc_blockcount - 1;\n\n\tINIT_LIST_HEAD(&refchk.fragments);\n\terror = xfs_rmap_query_range(sc->sa.rmap_cur, &low, &high,\n\t\t\t&xchk_refcountbt_rmap_check, &refchk);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.rmap_cur))\n\t\tgoto out_free;\n\n\txchk_refcountbt_process_rmap_fragments(&refchk);\n\tif (irec->rc_refcount != refchk.seen) {\n\t\ttrace_xchk_refcount_incorrect(sc->sa.pag, irec, refchk.seen);\n\t\txchk_btree_xref_set_corrupt(sc, sc->sa.rmap_cur, 0);\n\t}\n\nout_free:\n\tlist_for_each_entry_safe(frag, n, &refchk.fragments, list) {\n\t\tlist_del(&frag->list);\n\t\tkfree(frag);\n\t}\n}\n\n \nSTATIC void\nxchk_refcountbt_xref(\n\tstruct xfs_scrub\t\t*sc,\n\tconst struct xfs_refcount_irec\t*irec)\n{\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn;\n\n\txchk_xref_is_used_space(sc, irec->rc_startblock, irec->rc_blockcount);\n\txchk_xref_is_not_inode_chunk(sc, irec->rc_startblock,\n\t\t\tirec->rc_blockcount);\n\txchk_refcountbt_xref_rmap(sc, irec);\n}\n\nstruct xchk_refcbt_records {\n\t \n\tstruct xfs_refcount_irec prev_rec;\n\n\t \n\txfs_agblock_t\t\tnext_unshared_agbno;\n\n\t \n\txfs_agblock_t\t\tcow_blocks;\n\n\t \n\tenum xfs_refc_domain\tprev_domain;\n};\n\nSTATIC int\nxchk_refcountbt_rmap_check_gap(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst struct xfs_rmap_irec\t*rec,\n\tvoid\t\t\t\t*priv)\n{\n\txfs_agblock_t\t\t\t*next_bno = priv;\n\n\tif (*next_bno != NULLAGBLOCK && rec->rm_startblock < *next_bno)\n\t\treturn -ECANCELED;\n\n\t*next_bno = rec->rm_startblock + rec->rm_blockcount;\n\treturn 0;\n}\n\n \nstatic inline void\nxchk_refcountbt_xref_gaps(\n\tstruct xfs_scrub\t*sc,\n\tstruct xchk_refcbt_records *rrc,\n\txfs_agblock_t\t\tbno)\n{\n\tstruct xfs_rmap_irec\tlow;\n\tstruct xfs_rmap_irec\thigh;\n\txfs_agblock_t\t\tnext_bno = NULLAGBLOCK;\n\tint\t\t\terror;\n\n\tif (bno <= rrc->next_unshared_agbno || !sc->sa.rmap_cur ||\n            xchk_skip_xref(sc->sm))\n\t\treturn;\n\n\tmemset(&low, 0, sizeof(low));\n\tlow.rm_startblock = rrc->next_unshared_agbno;\n\tmemset(&high, 0xFF, sizeof(high));\n\thigh.rm_startblock = bno - 1;\n\n\terror = xfs_rmap_query_range(sc->sa.rmap_cur, &low, &high,\n\t\t\txchk_refcountbt_rmap_check_gap, &next_bno);\n\tif (error == -ECANCELED)\n\t\txchk_btree_xref_set_corrupt(sc, sc->sa.rmap_cur, 0);\n\telse\n\t\txchk_should_check_xref(sc, &error, &sc->sa.rmap_cur);\n}\n\nstatic inline bool\nxchk_refcount_mergeable(\n\tstruct xchk_refcbt_records\t*rrc,\n\tconst struct xfs_refcount_irec\t*r2)\n{\n\tconst struct xfs_refcount_irec\t*r1 = &rrc->prev_rec;\n\n\t \n\tif (r1->rc_blockcount > 0)\n\t\treturn false;\n\n\tif (r1->rc_domain != r2->rc_domain)\n\t\treturn false;\n\tif (r1->rc_startblock + r1->rc_blockcount != r2->rc_startblock)\n\t\treturn false;\n\tif (r1->rc_refcount != r2->rc_refcount)\n\t\treturn false;\n\tif ((unsigned long long)r1->rc_blockcount + r2->rc_blockcount >\n\t\t\tMAXREFCEXTLEN)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nSTATIC void\nxchk_refcountbt_check_mergeable(\n\tstruct xchk_btree\t\t*bs,\n\tstruct xchk_refcbt_records\t*rrc,\n\tconst struct xfs_refcount_irec\t*irec)\n{\n\tif (bs->sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn;\n\n\tif (xchk_refcount_mergeable(rrc, irec))\n\t\txchk_btree_set_corrupt(bs->sc, bs->cur, 0);\n\n\tmemcpy(&rrc->prev_rec, irec, sizeof(struct xfs_refcount_irec));\n}\n\n \nSTATIC int\nxchk_refcountbt_rec(\n\tstruct xchk_btree\t*bs,\n\tconst union xfs_btree_rec *rec)\n{\n\tstruct xfs_refcount_irec irec;\n\tstruct xchk_refcbt_records *rrc = bs->private;\n\n\txfs_refcount_btrec_to_irec(rec, &irec);\n\tif (xfs_refcount_check_irec(bs->cur, &irec) != NULL) {\n\t\txchk_btree_set_corrupt(bs->sc, bs->cur, 0);\n\t\treturn 0;\n\t}\n\n\tif (irec.rc_domain == XFS_REFC_DOMAIN_COW)\n\t\trrc->cow_blocks += irec.rc_blockcount;\n\n\t \n\tif (irec.rc_domain == XFS_REFC_DOMAIN_SHARED &&\n\t    rrc->prev_domain == XFS_REFC_DOMAIN_COW)\n\t\txchk_btree_set_corrupt(bs->sc, bs->cur, 0);\n\trrc->prev_domain = irec.rc_domain;\n\n\txchk_refcountbt_check_mergeable(bs, rrc, &irec);\n\txchk_refcountbt_xref(bs->sc, &irec);\n\n\t \n\tif (irec.rc_domain == XFS_REFC_DOMAIN_SHARED) {\n\t\txchk_refcountbt_xref_gaps(bs->sc, rrc, irec.rc_startblock);\n\t\trrc->next_unshared_agbno = irec.rc_startblock +\n\t\t\t\t\t   irec.rc_blockcount;\n\t}\n\n\treturn 0;\n}\n\n \nSTATIC void\nxchk_refcount_xref_rmap(\n\tstruct xfs_scrub\t*sc,\n\txfs_filblks_t\t\tcow_blocks)\n{\n\txfs_extlen_t\t\trefcbt_blocks = 0;\n\txfs_filblks_t\t\tblocks;\n\tint\t\t\terror;\n\n\tif (!sc->sa.rmap_cur || xchk_skip_xref(sc->sm))\n\t\treturn;\n\n\t \n\terror = xfs_btree_count_blocks(sc->sa.refc_cur, &refcbt_blocks);\n\tif (!xchk_btree_process_error(sc, sc->sa.refc_cur, 0, &error))\n\t\treturn;\n\terror = xchk_count_rmap_ownedby_ag(sc, sc->sa.rmap_cur,\n\t\t\t&XFS_RMAP_OINFO_REFC, &blocks);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.rmap_cur))\n\t\treturn;\n\tif (blocks != refcbt_blocks)\n\t\txchk_btree_xref_set_corrupt(sc, sc->sa.rmap_cur, 0);\n\n\t \n\terror = xchk_count_rmap_ownedby_ag(sc, sc->sa.rmap_cur,\n\t\t\t&XFS_RMAP_OINFO_COW, &blocks);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.rmap_cur))\n\t\treturn;\n\tif (blocks != cow_blocks)\n\t\txchk_btree_xref_set_corrupt(sc, sc->sa.rmap_cur, 0);\n}\n\n \nint\nxchk_refcountbt(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xchk_refcbt_records rrc = {\n\t\t.cow_blocks\t\t= 0,\n\t\t.next_unshared_agbno\t= 0,\n\t\t.prev_domain\t\t= XFS_REFC_DOMAIN_SHARED,\n\t};\n\tint\t\t\terror;\n\n\terror = xchk_btree(sc, sc->sa.refc_cur, xchk_refcountbt_rec,\n\t\t\t&XFS_RMAP_OINFO_REFC, &rrc);\n\tif (error)\n\t\treturn error;\n\n\t \n\txchk_refcountbt_xref_gaps(sc, &rrc, sc->mp->m_sb.sb_agblocks);\n\n\txchk_refcount_xref_rmap(sc, rrc.cow_blocks);\n\n\treturn 0;\n}\n\n \nvoid\nxchk_xref_is_cow_staging(\n\tstruct xfs_scrub\t\t*sc,\n\txfs_agblock_t\t\t\tagbno,\n\txfs_extlen_t\t\t\tlen)\n{\n\tstruct xfs_refcount_irec\trc;\n\tint\t\t\t\thas_refcount;\n\tint\t\t\t\terror;\n\n\tif (!sc->sa.refc_cur || xchk_skip_xref(sc->sm))\n\t\treturn;\n\n\t \n\terror = xfs_refcount_lookup_le(sc->sa.refc_cur, XFS_REFC_DOMAIN_COW,\n\t\t\tagbno, &has_refcount);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.refc_cur))\n\t\treturn;\n\tif (!has_refcount) {\n\t\txchk_btree_xref_set_corrupt(sc, sc->sa.refc_cur, 0);\n\t\treturn;\n\t}\n\n\terror = xfs_refcount_get_rec(sc->sa.refc_cur, &rc, &has_refcount);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.refc_cur))\n\t\treturn;\n\tif (!has_refcount) {\n\t\txchk_btree_xref_set_corrupt(sc, sc->sa.refc_cur, 0);\n\t\treturn;\n\t}\n\n\t \n\tif (rc.rc_domain != XFS_REFC_DOMAIN_COW)\n\t\txchk_btree_xref_set_corrupt(sc, sc->sa.refc_cur, 0);\n\n\t \n\tif (rc.rc_blockcount < len)\n\t\txchk_btree_xref_set_corrupt(sc, sc->sa.refc_cur, 0);\n}\n\n \nvoid\nxchk_xref_is_not_shared(\n\tstruct xfs_scrub\t*sc,\n\txfs_agblock_t\t\tagbno,\n\txfs_extlen_t\t\tlen)\n{\n\tenum xbtree_recpacking\toutcome;\n\tint\t\t\terror;\n\n\tif (!sc->sa.refc_cur || xchk_skip_xref(sc->sm))\n\t\treturn;\n\n\terror = xfs_refcount_has_records(sc->sa.refc_cur,\n\t\t\tXFS_REFC_DOMAIN_SHARED, agbno, len, &outcome);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.refc_cur))\n\t\treturn;\n\tif (outcome != XBTREE_RECPACKING_EMPTY)\n\t\txchk_btree_xref_set_corrupt(sc, sc->sa.refc_cur, 0);\n}\n\n \nvoid\nxchk_xref_is_not_cow_staging(\n\tstruct xfs_scrub\t*sc,\n\txfs_agblock_t\t\tagbno,\n\txfs_extlen_t\t\tlen)\n{\n\tenum xbtree_recpacking\toutcome;\n\tint\t\t\terror;\n\n\tif (!sc->sa.refc_cur || xchk_skip_xref(sc->sm))\n\t\treturn;\n\n\terror = xfs_refcount_has_records(sc->sa.refc_cur, XFS_REFC_DOMAIN_COW,\n\t\t\tagbno, len, &outcome);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.refc_cur))\n\t\treturn;\n\tif (outcome != XBTREE_RECPACKING_EMPTY)\n\t\txchk_btree_xref_set_corrupt(sc, sc->sa.refc_cur, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}