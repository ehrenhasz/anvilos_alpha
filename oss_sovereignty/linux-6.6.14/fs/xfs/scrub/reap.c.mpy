{
  "module_name": "reap.c",
  "hash_id": "90bc168a7af81c565473341d40865ef7c1cf1b992f16091a022e1519988d40e3",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/reap.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_rmap_btree.h\"\n#include \"xfs_refcount_btree.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_ag_resv.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/common.h\"\n#include \"scrub/trace.h\"\n#include \"scrub/repair.h\"\n#include \"scrub/bitmap.h\"\n#include \"scrub/reap.h\"\n\n \n\n \nstruct xreap_state {\n\tstruct xfs_scrub\t\t*sc;\n\n\t \n\tconst struct xfs_owner_info\t*oinfo;\n\tenum xfs_ag_resv_type\t\tresv;\n\n\t \n\tbool\t\t\t\tforce_roll;\n\n\t \n\tunsigned int\t\t\tdeferred;\n\n\t \n\tunsigned int\t\t\tinvalidated;\n\n\t \n\tunsigned long long\t\ttotal_deferred;\n};\n\n \nSTATIC int\nxreap_put_freelist(\n\tstruct xfs_scrub\t*sc,\n\txfs_agblock_t\t\tagbno)\n{\n\tstruct xfs_buf\t\t*agfl_bp;\n\tint\t\t\terror;\n\n\t \n\terror = xrep_fix_freelist(sc, true);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = xfs_rmap_alloc(sc->tp, sc->sa.agf_bp, sc->sa.pag, agbno, 1,\n\t\t\t&XFS_RMAP_OINFO_AG);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = xfs_alloc_read_agfl(sc->sa.pag, sc->tp, &agfl_bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_alloc_put_freelist(sc->sa.pag, sc->tp, sc->sa.agf_bp,\n\t\t\tagfl_bp, agbno, 0);\n\tif (error)\n\t\treturn error;\n\txfs_extent_busy_insert(sc->tp, sc->sa.pag, agbno, 1,\n\t\t\tXFS_EXTENT_BUSY_SKIP_DISCARD);\n\n\treturn 0;\n}\n\n \nstatic inline bool xreap_dirty(const struct xreap_state *rs)\n{\n\tif (rs->force_roll)\n\t\treturn true;\n\tif (rs->deferred)\n\t\treturn true;\n\tif (rs->invalidated)\n\t\treturn true;\n\tif (rs->total_deferred)\n\t\treturn true;\n\treturn false;\n}\n\n#define XREAP_MAX_BINVAL\t(2048)\n\n \nstatic inline bool xreap_want_roll(const struct xreap_state *rs)\n{\n\tif (rs->force_roll)\n\t\treturn true;\n\tif (rs->deferred > XREP_MAX_ITRUNCATE_EFIS)\n\t\treturn true;\n\tif (rs->invalidated > XREAP_MAX_BINVAL)\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline void xreap_reset(struct xreap_state *rs)\n{\n\trs->total_deferred += rs->deferred;\n\trs->deferred = 0;\n\trs->invalidated = 0;\n\trs->force_roll = false;\n}\n\n#define XREAP_MAX_DEFER_CHAIN\t\t(2048)\n\n \nstatic inline bool\nxreap_want_defer_finish(const struct xreap_state *rs)\n{\n\tif (rs->force_roll)\n\t\treturn true;\n\tif (rs->total_deferred > XREAP_MAX_DEFER_CHAIN)\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline void xreap_defer_finish_reset(struct xreap_state *rs)\n{\n\trs->total_deferred = 0;\n\trs->deferred = 0;\n\trs->invalidated = 0;\n\trs->force_roll = false;\n}\n\n \nSTATIC void\nxreap_agextent_binval(\n\tstruct xreap_state\t*rs,\n\txfs_agblock_t\t\tagbno,\n\txfs_extlen_t\t\t*aglenp)\n{\n\tstruct xfs_scrub\t*sc = rs->sc;\n\tstruct xfs_perag\t*pag = sc->sa.pag;\n\tstruct xfs_mount\t*mp = sc->mp;\n\txfs_agnumber_t\t\tagno = sc->sa.pag->pag_agno;\n\txfs_agblock_t\t\tagbno_next = agbno + *aglenp;\n\txfs_agblock_t\t\tbno = agbno;\n\n\t \n\tif (!xfs_verify_agbno(pag, agbno) ||\n\t    !xfs_verify_agbno(pag, agbno_next - 1))\n\t\treturn;\n\n\t \n\twhile (bno < agbno_next) {\n\t\txfs_agblock_t\tfsbcount;\n\t\txfs_agblock_t\tmax_fsbs;\n\n\t\t \n\t\tmax_fsbs = min_t(xfs_agblock_t, agbno_next - bno,\n\t\t\t\txfs_attr3_rmt_blocks(mp, XFS_XATTR_SIZE_MAX));\n\n\t\tfor (fsbcount = 1; fsbcount < max_fsbs; fsbcount++) {\n\t\t\tstruct xfs_buf\t*bp = NULL;\n\t\t\txfs_daddr_t\tdaddr;\n\t\t\tint\t\terror;\n\n\t\t\tdaddr = XFS_AGB_TO_DADDR(mp, agno, bno);\n\t\t\terror = xfs_buf_incore(mp->m_ddev_targp, daddr,\n\t\t\t\t\tXFS_FSB_TO_BB(mp, fsbcount),\n\t\t\t\t\tXBF_LIVESCAN, &bp);\n\t\t\tif (error)\n\t\t\t\tcontinue;\n\n\t\t\txfs_trans_bjoin(sc->tp, bp);\n\t\t\txfs_trans_binval(sc->tp, bp);\n\t\t\trs->invalidated++;\n\n\t\t\t \n\t\t\tif (rs->invalidated > XREAP_MAX_BINVAL) {\n\t\t\t\t*aglenp -= agbno_next - bno;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tbno++;\n\t}\n\nout:\n\ttrace_xreap_agextent_binval(sc->sa.pag, agbno, *aglenp);\n}\n\n \nSTATIC int\nxreap_agextent_select(\n\tstruct xreap_state\t*rs,\n\txfs_agblock_t\t\tagbno,\n\txfs_agblock_t\t\tagbno_next,\n\tbool\t\t\t*crosslinked,\n\txfs_extlen_t\t\t*aglenp)\n{\n\tstruct xfs_scrub\t*sc = rs->sc;\n\tstruct xfs_btree_cur\t*cur;\n\txfs_agblock_t\t\tbno = agbno + 1;\n\txfs_extlen_t\t\tlen = 1;\n\tint\t\t\terror;\n\n\t \n\tcur = xfs_rmapbt_init_cursor(sc->mp, sc->tp, sc->sa.agf_bp,\n\t\t\tsc->sa.pag);\n\terror = xfs_rmap_has_other_keys(cur, agbno, 1, rs->oinfo,\n\t\t\tcrosslinked);\n\tif (error)\n\t\tgoto out_cur;\n\n\t \n\tif (rs->resv == XFS_AG_RESV_AGFL)\n\t\tgoto out_found;\n\n\t \n\twhile (bno < agbno_next) {\n\t\tbool\t\talso_crosslinked;\n\n\t\terror = xfs_rmap_has_other_keys(cur, bno, 1, rs->oinfo,\n\t\t\t\t&also_crosslinked);\n\t\tif (error)\n\t\t\tgoto out_cur;\n\n\t\tif (*crosslinked != also_crosslinked)\n\t\t\tbreak;\n\n\t\tlen++;\n\t\tbno++;\n\t}\n\nout_found:\n\t*aglenp = len;\n\ttrace_xreap_agextent_select(sc->sa.pag, agbno, len, *crosslinked);\nout_cur:\n\txfs_btree_del_cursor(cur, error);\n\treturn error;\n}\n\n \nSTATIC int\nxreap_agextent_iter(\n\tstruct xreap_state\t*rs,\n\txfs_agblock_t\t\tagbno,\n\txfs_extlen_t\t\t*aglenp,\n\tbool\t\t\tcrosslinked)\n{\n\tstruct xfs_scrub\t*sc = rs->sc;\n\txfs_fsblock_t\t\tfsbno;\n\tint\t\t\terror = 0;\n\n\tfsbno = XFS_AGB_TO_FSB(sc->mp, sc->sa.pag->pag_agno, agbno);\n\n\t \n\tif (crosslinked) {\n\t\ttrace_xreap_dispose_unmap_extent(sc->sa.pag, agbno, *aglenp);\n\n\t\trs->force_roll = true;\n\t\treturn xfs_rmap_free(sc->tp, sc->sa.agf_bp, sc->sa.pag, agbno,\n\t\t\t\t*aglenp, rs->oinfo);\n\t}\n\n\ttrace_xreap_dispose_free_extent(sc->sa.pag, agbno, *aglenp);\n\n\t \n\txreap_agextent_binval(rs, agbno, aglenp);\n\tif (*aglenp == 0) {\n\t\tASSERT(xreap_want_roll(rs));\n\t\treturn 0;\n\t}\n\n\t \n\tif (rs->resv == XFS_AG_RESV_AGFL) {\n\t\tASSERT(*aglenp == 1);\n\t\terror = xreap_put_freelist(sc, agbno);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\trs->force_roll = true;\n\t\treturn 0;\n\t}\n\n\t \n\terror = __xfs_free_extent_later(sc->tp, fsbno, *aglenp, rs->oinfo,\n\t\t\trs->resv, true);\n\tif (error)\n\t\treturn error;\n\n\trs->deferred++;\n\treturn 0;\n}\n\n \nSTATIC int\nxreap_agmeta_extent(\n\tuint64_t\t\tfsbno,\n\tuint64_t\t\tlen,\n\tvoid\t\t\t*priv)\n{\n\tstruct xreap_state\t*rs = priv;\n\tstruct xfs_scrub\t*sc = rs->sc;\n\txfs_agblock_t\t\tagbno = fsbno;\n\txfs_agblock_t\t\tagbno_next = agbno + len;\n\tint\t\t\terror = 0;\n\n\tASSERT(len <= XFS_MAX_BMBT_EXTLEN);\n\tASSERT(sc->ip == NULL);\n\n\twhile (agbno < agbno_next) {\n\t\txfs_extlen_t\taglen;\n\t\tbool\t\tcrosslinked;\n\n\t\terror = xreap_agextent_select(rs, agbno, agbno_next,\n\t\t\t\t&crosslinked, &aglen);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = xreap_agextent_iter(rs, agbno, &aglen, crosslinked);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (xreap_want_defer_finish(rs)) {\n\t\t\terror = xrep_defer_finish(sc);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\txreap_defer_finish_reset(rs);\n\t\t} else if (xreap_want_roll(rs)) {\n\t\t\terror = xrep_roll_ag_trans(sc);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\txreap_reset(rs);\n\t\t}\n\n\t\tagbno += aglen;\n\t}\n\n\treturn 0;\n}\n\n \nint\nxrep_reap_agblocks(\n\tstruct xfs_scrub\t\t*sc,\n\tstruct xagb_bitmap\t\t*bitmap,\n\tconst struct xfs_owner_info\t*oinfo,\n\tenum xfs_ag_resv_type\t\ttype)\n{\n\tstruct xreap_state\t\trs = {\n\t\t.sc\t\t\t= sc,\n\t\t.oinfo\t\t\t= oinfo,\n\t\t.resv\t\t\t= type,\n\t};\n\tint\t\t\t\terror;\n\n\tASSERT(xfs_has_rmapbt(sc->mp));\n\tASSERT(sc->ip == NULL);\n\n\terror = xagb_bitmap_walk(bitmap, xreap_agmeta_extent, &rs);\n\tif (error)\n\t\treturn error;\n\n\tif (xreap_dirty(&rs))\n\t\treturn xrep_defer_finish(sc);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}