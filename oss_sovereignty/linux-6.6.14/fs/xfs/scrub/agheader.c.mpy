{
  "module_name": "agheader.c",
  "hash_id": "de79937eec27bfd722d766899af80d6e74201208cdae22cb06056dfdeba0eb79",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/agheader.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_ag.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/common.h\"\n\nint\nxchk_setup_agheader(\n\tstruct xfs_scrub\t*sc)\n{\n\tif (xchk_need_intent_drain(sc))\n\t\txchk_fsgates_enable(sc, XCHK_FSGATES_DRAIN);\n\treturn xchk_setup_fs(sc);\n}\n\n \n\n \nSTATIC void\nxchk_superblock_xref(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\txfs_agnumber_t\t\tagno = sc->sm->sm_agno;\n\txfs_agblock_t\t\tagbno;\n\tint\t\t\terror;\n\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn;\n\n\tagbno = XFS_SB_BLOCK(mp);\n\n\terror = xchk_ag_init_existing(sc, agno, &sc->sa);\n\tif (!xchk_xref_process_error(sc, agno, agbno, &error))\n\t\treturn;\n\n\txchk_xref_is_used_space(sc, agbno, 1);\n\txchk_xref_is_not_inode_chunk(sc, agbno, 1);\n\txchk_xref_is_only_owned_by(sc, agbno, 1, &XFS_RMAP_OINFO_FS);\n\txchk_xref_is_not_shared(sc, agbno, 1);\n\txchk_xref_is_not_cow_staging(sc, agbno, 1);\n\n\t \n}\n\n \nint\nxchk_superblock(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_dsb\t\t*sb;\n\tstruct xfs_perag\t*pag;\n\txfs_agnumber_t\t\tagno;\n\tuint32_t\t\tv2_ok;\n\t__be32\t\t\tfeatures_mask;\n\tint\t\t\terror;\n\t__be16\t\t\tvernum_mask;\n\n\tagno = sc->sm->sm_agno;\n\tif (agno == 0)\n\t\treturn 0;\n\n\t \n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag)\n\t\treturn -ENOENT;\n\n\terror = xfs_sb_read_secondary(mp, sc->tp, agno, &bp);\n\t \n\tswitch (error) {\n\tcase -EINVAL:\t \n\tcase -ENOSYS:\n\tcase -EFBIG:\n\t\terror = -EFSCORRUPTED;\n\t\tfallthrough;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!xchk_process_error(sc, agno, XFS_SB_BLOCK(mp), &error))\n\t\tgoto out_pag;\n\n\tsb = bp->b_addr;\n\n\t \n\tif (sb->sb_blocksize != cpu_to_be32(mp->m_sb.sb_blocksize))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_dblocks != cpu_to_be64(mp->m_sb.sb_dblocks))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_rblocks != cpu_to_be64(mp->m_sb.sb_rblocks))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_rextents != cpu_to_be64(mp->m_sb.sb_rextents))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (!uuid_equal(&sb->sb_uuid, &mp->m_sb.sb_uuid))\n\t\txchk_block_set_preen(sc, bp);\n\n\tif (sb->sb_logstart != cpu_to_be64(mp->m_sb.sb_logstart))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_rootino != cpu_to_be64(mp->m_sb.sb_rootino))\n\t\txchk_block_set_preen(sc, bp);\n\n\tif (sb->sb_rbmino != cpu_to_be64(mp->m_sb.sb_rbmino))\n\t\txchk_block_set_preen(sc, bp);\n\n\tif (sb->sb_rsumino != cpu_to_be64(mp->m_sb.sb_rsumino))\n\t\txchk_block_set_preen(sc, bp);\n\n\tif (sb->sb_rextsize != cpu_to_be32(mp->m_sb.sb_rextsize))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_agblocks != cpu_to_be32(mp->m_sb.sb_agblocks))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_agcount != cpu_to_be32(mp->m_sb.sb_agcount))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_rbmblocks != cpu_to_be32(mp->m_sb.sb_rbmblocks))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_logblocks != cpu_to_be32(mp->m_sb.sb_logblocks))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\t \n\tvernum_mask = cpu_to_be16(~XFS_SB_VERSION_OKBITS |\n\t\t\t\t  XFS_SB_VERSION_NUMBITS |\n\t\t\t\t  XFS_SB_VERSION_ALIGNBIT |\n\t\t\t\t  XFS_SB_VERSION_DALIGNBIT |\n\t\t\t\t  XFS_SB_VERSION_SHAREDBIT |\n\t\t\t\t  XFS_SB_VERSION_LOGV2BIT |\n\t\t\t\t  XFS_SB_VERSION_SECTORBIT |\n\t\t\t\t  XFS_SB_VERSION_EXTFLGBIT |\n\t\t\t\t  XFS_SB_VERSION_DIRV2BIT);\n\tif ((sb->sb_versionnum & vernum_mask) !=\n\t    (cpu_to_be16(mp->m_sb.sb_versionnum) & vernum_mask))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\t \n\tvernum_mask = cpu_to_be16(XFS_SB_VERSION_ATTRBIT |\n\t\t\t\t  XFS_SB_VERSION_NLINKBIT |\n\t\t\t\t  XFS_SB_VERSION_QUOTABIT);\n\tif ((sb->sb_versionnum & vernum_mask) !=\n\t    (cpu_to_be16(mp->m_sb.sb_versionnum) & vernum_mask))\n\t\txchk_block_set_preen(sc, bp);\n\n\tif (sb->sb_sectsize != cpu_to_be16(mp->m_sb.sb_sectsize))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_inodesize != cpu_to_be16(mp->m_sb.sb_inodesize))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_inopblock != cpu_to_be16(mp->m_sb.sb_inopblock))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (memcmp(sb->sb_fname, mp->m_sb.sb_fname, sizeof(sb->sb_fname)))\n\t\txchk_block_set_preen(sc, bp);\n\n\tif (sb->sb_blocklog != mp->m_sb.sb_blocklog)\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_sectlog != mp->m_sb.sb_sectlog)\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_inodelog != mp->m_sb.sb_inodelog)\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_inopblog != mp->m_sb.sb_inopblog)\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_agblklog != mp->m_sb.sb_agblklog)\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_rextslog != mp->m_sb.sb_rextslog)\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_imax_pct != mp->m_sb.sb_imax_pct)\n\t\txchk_block_set_preen(sc, bp);\n\n\t \n\n\tif (sb->sb_uquotino != cpu_to_be64(mp->m_sb.sb_uquotino))\n\t\txchk_block_set_preen(sc, bp);\n\n\tif (sb->sb_gquotino != cpu_to_be64(mp->m_sb.sb_gquotino))\n\t\txchk_block_set_preen(sc, bp);\n\n\t \n\n\tif (sb->sb_flags != mp->m_sb.sb_flags)\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_shared_vn != mp->m_sb.sb_shared_vn)\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_inoalignmt != cpu_to_be32(mp->m_sb.sb_inoalignmt))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_unit != cpu_to_be32(mp->m_sb.sb_unit))\n\t\txchk_block_set_preen(sc, bp);\n\n\tif (sb->sb_width != cpu_to_be32(mp->m_sb.sb_width))\n\t\txchk_block_set_preen(sc, bp);\n\n\tif (sb->sb_dirblklog != mp->m_sb.sb_dirblklog)\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_logsectlog != mp->m_sb.sb_logsectlog)\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_logsectsize != cpu_to_be16(mp->m_sb.sb_logsectsize))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\tif (sb->sb_logsunit != cpu_to_be32(mp->m_sb.sb_logsunit))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\t \n\tif (!xfs_sb_version_hasmorebits(&mp->m_sb)) {\n\t\tif (sb->sb_features2 != 0)\n\t\t\txchk_block_set_corrupt(sc, bp);\n\t} else {\n\t\tv2_ok = XFS_SB_VERSION2_OKBITS;\n\t\tif (xfs_sb_is_v5(&mp->m_sb))\n\t\t\tv2_ok |= XFS_SB_VERSION2_CRCBIT;\n\n\t\tif (!!(sb->sb_features2 & cpu_to_be32(~v2_ok)))\n\t\t\txchk_block_set_corrupt(sc, bp);\n\n\t\tif (sb->sb_features2 != sb->sb_bad_features2)\n\t\t\txchk_block_set_preen(sc, bp);\n\t}\n\n\t \n\tfeatures_mask = cpu_to_be32(XFS_SB_VERSION2_LAZYSBCOUNTBIT |\n\t\t\t\t    XFS_SB_VERSION2_PROJID32BIT |\n\t\t\t\t    XFS_SB_VERSION2_CRCBIT |\n\t\t\t\t    XFS_SB_VERSION2_FTYPE);\n\tif ((sb->sb_features2 & features_mask) !=\n\t    (cpu_to_be32(mp->m_sb.sb_features2) & features_mask))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\t \n\tfeatures_mask = cpu_to_be32(XFS_SB_VERSION2_ATTR2BIT);\n\tif ((sb->sb_features2 & features_mask) !=\n\t    (cpu_to_be32(mp->m_sb.sb_features2) & features_mask))\n\t\txchk_block_set_preen(sc, bp);\n\n\tif (!xfs_has_crc(mp)) {\n\t\t \n\t\tif (memchr_inv(&sb->sb_features_compat, 0,\n\t\t\t\tsizeof(struct xfs_dsb) -\n\t\t\t\toffsetof(struct xfs_dsb, sb_features_compat)))\n\t\t\txchk_block_set_corrupt(sc, bp);\n\t} else {\n\t\t \n\t\tif (sb->sb_features_compat !=\n\t\t\t\tcpu_to_be32(mp->m_sb.sb_features_compat))\n\t\t\txchk_block_set_corrupt(sc, bp);\n\n\t\t \n\t\tif (sb->sb_features_ro_compat !=\n\t\t\t\tcpu_to_be32(mp->m_sb.sb_features_ro_compat))\n\t\t\txchk_block_set_corrupt(sc, bp);\n\n\t\t \n\t\tfeatures_mask = cpu_to_be32(XFS_SB_FEAT_INCOMPAT_NEEDSREPAIR);\n\t\tif ((cpu_to_be32(mp->m_sb.sb_features_incompat) ^\n\t\t\t\tsb->sb_features_incompat) & features_mask)\n\t\t\txchk_block_set_preen(sc, bp);\n\n\t\t \n\t\tif ((cpu_to_be32(mp->m_sb.sb_features_incompat) ^\n\t\t\t\tsb->sb_features_incompat) & ~features_mask)\n\t\t\txchk_block_set_corrupt(sc, bp);\n\n\t\t \n\t\tif (sb->sb_features_log_incompat)\n\t\t\txchk_block_set_preen(sc, bp);\n\n\t\t \n\n\t\tif (sb->sb_spino_align != cpu_to_be32(mp->m_sb.sb_spino_align))\n\t\t\txchk_block_set_corrupt(sc, bp);\n\n\t\tif (sb->sb_pquotino != cpu_to_be64(mp->m_sb.sb_pquotino))\n\t\t\txchk_block_set_preen(sc, bp);\n\n\t\t \n\t}\n\n\tif (xfs_has_metauuid(mp)) {\n\t\t \n\t\tif (!uuid_equal(&sb->sb_meta_uuid, &mp->m_sb.sb_meta_uuid))\n\t\t\txchk_block_set_corrupt(sc, bp);\n\t}\n\n\t \n\tif (memchr_inv(sb + 1, 0,\n\t\t\tBBTOB(bp->b_length) - sizeof(struct xfs_dsb)))\n\t\txchk_block_set_corrupt(sc, bp);\n\n\txchk_superblock_xref(sc, bp);\nout_pag:\n\txfs_perag_put(pag);\n\treturn error;\n}\n\n \n\n \nSTATIC int\nxchk_agf_record_bno_lengths(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst struct xfs_alloc_rec_incore *rec,\n\tvoid\t\t\t\t*priv)\n{\n\txfs_extlen_t\t\t\t*blocks = priv;\n\n\t(*blocks) += rec->ar_blockcount;\n\treturn 0;\n}\n\n \nstatic inline void\nxchk_agf_xref_freeblks(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_agf\t\t*agf = sc->sa.agf_bp->b_addr;\n\txfs_extlen_t\t\tblocks = 0;\n\tint\t\t\terror;\n\n\tif (!sc->sa.bno_cur)\n\t\treturn;\n\n\terror = xfs_alloc_query_all(sc->sa.bno_cur,\n\t\t\txchk_agf_record_bno_lengths, &blocks);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.bno_cur))\n\t\treturn;\n\tif (blocks != be32_to_cpu(agf->agf_freeblks))\n\t\txchk_block_xref_set_corrupt(sc, sc->sa.agf_bp);\n}\n\n \nstatic inline void\nxchk_agf_xref_cntbt(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_agf\t\t*agf = sc->sa.agf_bp->b_addr;\n\txfs_agblock_t\t\tagbno;\n\txfs_extlen_t\t\tblocks;\n\tint\t\t\thave;\n\tint\t\t\terror;\n\n\tif (!sc->sa.cnt_cur)\n\t\treturn;\n\n\t \n\terror = xfs_alloc_lookup_le(sc->sa.cnt_cur, 0, -1U, &have);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.cnt_cur))\n\t\treturn;\n\tif (!have) {\n\t\tif (agf->agf_freeblks != cpu_to_be32(0))\n\t\t\txchk_block_xref_set_corrupt(sc, sc->sa.agf_bp);\n\t\treturn;\n\t}\n\n\t \n\terror = xfs_alloc_get_rec(sc->sa.cnt_cur, &agbno, &blocks, &have);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.cnt_cur))\n\t\treturn;\n\tif (!have || blocks != be32_to_cpu(agf->agf_longest))\n\t\txchk_block_xref_set_corrupt(sc, sc->sa.agf_bp);\n}\n\n \nSTATIC void\nxchk_agf_xref_btreeblks(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_agf\t\t*agf = sc->sa.agf_bp->b_addr;\n\tstruct xfs_mount\t*mp = sc->mp;\n\txfs_agblock_t\t\tblocks;\n\txfs_agblock_t\t\tbtreeblks;\n\tint\t\t\terror;\n\n\t \n\tif (!xfs_has_lazysbcount(sc->mp))\n\t\treturn;\n\n\t \n\tif (sc->sa.rmap_cur) {\n\t\terror = xfs_btree_count_blocks(sc->sa.rmap_cur, &blocks);\n\t\tif (!xchk_should_check_xref(sc, &error, &sc->sa.rmap_cur))\n\t\t\treturn;\n\t\tbtreeblks = blocks - 1;\n\t\tif (blocks != be32_to_cpu(agf->agf_rmap_blocks))\n\t\t\txchk_block_xref_set_corrupt(sc, sc->sa.agf_bp);\n\t} else {\n\t\tbtreeblks = 0;\n\t}\n\n\t \n\tif ((xfs_has_rmapbt(mp) && !sc->sa.rmap_cur) ||\n\t    !sc->sa.bno_cur || !sc->sa.cnt_cur)\n\t\treturn;\n\n\t \n\terror = xfs_btree_count_blocks(sc->sa.bno_cur, &blocks);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.bno_cur))\n\t\treturn;\n\tbtreeblks += blocks - 1;\n\n\terror = xfs_btree_count_blocks(sc->sa.cnt_cur, &blocks);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.cnt_cur))\n\t\treturn;\n\tbtreeblks += blocks - 1;\n\n\tif (btreeblks != be32_to_cpu(agf->agf_btreeblks))\n\t\txchk_block_xref_set_corrupt(sc, sc->sa.agf_bp);\n}\n\n \nstatic inline void\nxchk_agf_xref_refcblks(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_agf\t\t*agf = sc->sa.agf_bp->b_addr;\n\txfs_agblock_t\t\tblocks;\n\tint\t\t\terror;\n\n\tif (!sc->sa.refc_cur)\n\t\treturn;\n\n\terror = xfs_btree_count_blocks(sc->sa.refc_cur, &blocks);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.refc_cur))\n\t\treturn;\n\tif (blocks != be32_to_cpu(agf->agf_refcount_blocks))\n\t\txchk_block_xref_set_corrupt(sc, sc->sa.agf_bp);\n}\n\n \nSTATIC void\nxchk_agf_xref(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\txfs_agblock_t\t\tagbno;\n\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn;\n\n\tagbno = XFS_AGF_BLOCK(mp);\n\n\txchk_ag_btcur_init(sc, &sc->sa);\n\n\txchk_xref_is_used_space(sc, agbno, 1);\n\txchk_agf_xref_freeblks(sc);\n\txchk_agf_xref_cntbt(sc);\n\txchk_xref_is_not_inode_chunk(sc, agbno, 1);\n\txchk_xref_is_only_owned_by(sc, agbno, 1, &XFS_RMAP_OINFO_FS);\n\txchk_agf_xref_btreeblks(sc);\n\txchk_xref_is_not_shared(sc, agbno, 1);\n\txchk_xref_is_not_cow_staging(sc, agbno, 1);\n\txchk_agf_xref_refcblks(sc);\n\n\t \n}\n\n \nint\nxchk_agf(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\tstruct xfs_agf\t\t*agf;\n\tstruct xfs_perag\t*pag;\n\txfs_agnumber_t\t\tagno = sc->sm->sm_agno;\n\txfs_agblock_t\t\tagbno;\n\txfs_agblock_t\t\teoag;\n\txfs_agblock_t\t\tagfl_first;\n\txfs_agblock_t\t\tagfl_last;\n\txfs_agblock_t\t\tagfl_count;\n\txfs_agblock_t\t\tfl_count;\n\tint\t\t\tlevel;\n\tint\t\t\terror = 0;\n\n\terror = xchk_ag_read_headers(sc, agno, &sc->sa);\n\tif (!xchk_process_error(sc, agno, XFS_AGF_BLOCK(sc->mp), &error))\n\t\tgoto out;\n\txchk_buffer_recheck(sc, sc->sa.agf_bp);\n\n\tagf = sc->sa.agf_bp->b_addr;\n\tpag = sc->sa.pag;\n\n\t \n\teoag = be32_to_cpu(agf->agf_length);\n\tif (eoag != pag->block_count)\n\t\txchk_block_set_corrupt(sc, sc->sa.agf_bp);\n\n\t \n\tagbno = be32_to_cpu(agf->agf_roots[XFS_BTNUM_BNO]);\n\tif (!xfs_verify_agbno(pag, agbno))\n\t\txchk_block_set_corrupt(sc, sc->sa.agf_bp);\n\n\tagbno = be32_to_cpu(agf->agf_roots[XFS_BTNUM_CNT]);\n\tif (!xfs_verify_agbno(pag, agbno))\n\t\txchk_block_set_corrupt(sc, sc->sa.agf_bp);\n\n\tlevel = be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]);\n\tif (level <= 0 || level > mp->m_alloc_maxlevels)\n\t\txchk_block_set_corrupt(sc, sc->sa.agf_bp);\n\n\tlevel = be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]);\n\tif (level <= 0 || level > mp->m_alloc_maxlevels)\n\t\txchk_block_set_corrupt(sc, sc->sa.agf_bp);\n\n\tif (xfs_has_rmapbt(mp)) {\n\t\tagbno = be32_to_cpu(agf->agf_roots[XFS_BTNUM_RMAP]);\n\t\tif (!xfs_verify_agbno(pag, agbno))\n\t\t\txchk_block_set_corrupt(sc, sc->sa.agf_bp);\n\n\t\tlevel = be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]);\n\t\tif (level <= 0 || level > mp->m_rmap_maxlevels)\n\t\t\txchk_block_set_corrupt(sc, sc->sa.agf_bp);\n\t}\n\n\tif (xfs_has_reflink(mp)) {\n\t\tagbno = be32_to_cpu(agf->agf_refcount_root);\n\t\tif (!xfs_verify_agbno(pag, agbno))\n\t\t\txchk_block_set_corrupt(sc, sc->sa.agf_bp);\n\n\t\tlevel = be32_to_cpu(agf->agf_refcount_level);\n\t\tif (level <= 0 || level > mp->m_refc_maxlevels)\n\t\t\txchk_block_set_corrupt(sc, sc->sa.agf_bp);\n\t}\n\n\t \n\tagfl_first = be32_to_cpu(agf->agf_flfirst);\n\tagfl_last = be32_to_cpu(agf->agf_fllast);\n\tagfl_count = be32_to_cpu(agf->agf_flcount);\n\tif (agfl_last > agfl_first)\n\t\tfl_count = agfl_last - agfl_first + 1;\n\telse\n\t\tfl_count = xfs_agfl_size(mp) - agfl_first + agfl_last + 1;\n\tif (agfl_count != 0 && fl_count != agfl_count)\n\t\txchk_block_set_corrupt(sc, sc->sa.agf_bp);\n\n\t \n\tif (pag->pagf_freeblks != be32_to_cpu(agf->agf_freeblks))\n\t\txchk_block_set_corrupt(sc, sc->sa.agf_bp);\n\tif (pag->pagf_flcount != be32_to_cpu(agf->agf_flcount))\n\t\txchk_block_set_corrupt(sc, sc->sa.agf_bp);\n\tif (xfs_has_lazysbcount(sc->mp) &&\n\t    pag->pagf_btreeblks != be32_to_cpu(agf->agf_btreeblks))\n\t\txchk_block_set_corrupt(sc, sc->sa.agf_bp);\n\n\txchk_agf_xref(sc);\nout:\n\treturn error;\n}\n\n \n\nstruct xchk_agfl_info {\n\t \n\tunsigned int\t\tagflcount;\n\n\t \n\tunsigned int\t\tnr_entries;\n\n\t \n\txfs_agblock_t\t\t*entries;\n\n\tstruct xfs_buf\t\t*agfl_bp;\n\tstruct xfs_scrub\t*sc;\n};\n\n \nSTATIC void\nxchk_agfl_block_xref(\n\tstruct xfs_scrub\t*sc,\n\txfs_agblock_t\t\tagbno)\n{\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn;\n\n\txchk_xref_is_used_space(sc, agbno, 1);\n\txchk_xref_is_not_inode_chunk(sc, agbno, 1);\n\txchk_xref_is_only_owned_by(sc, agbno, 1, &XFS_RMAP_OINFO_AG);\n\txchk_xref_is_not_shared(sc, agbno, 1);\n\txchk_xref_is_not_cow_staging(sc, agbno, 1);\n}\n\n \nSTATIC int\nxchk_agfl_block(\n\tstruct xfs_mount\t*mp,\n\txfs_agblock_t\t\tagbno,\n\tvoid\t\t\t*priv)\n{\n\tstruct xchk_agfl_info\t*sai = priv;\n\tstruct xfs_scrub\t*sc = sai->sc;\n\n\tif (xfs_verify_agbno(sc->sa.pag, agbno) &&\n\t    sai->nr_entries < sai->agflcount)\n\t\tsai->entries[sai->nr_entries++] = agbno;\n\telse\n\t\txchk_block_set_corrupt(sc, sai->agfl_bp);\n\n\txchk_agfl_block_xref(sc, agbno);\n\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn -ECANCELED;\n\n\treturn 0;\n}\n\nstatic int\nxchk_agblock_cmp(\n\tconst void\t\t*pa,\n\tconst void\t\t*pb)\n{\n\tconst xfs_agblock_t\t*a = pa;\n\tconst xfs_agblock_t\t*b = pb;\n\n\treturn (int)*a - (int)*b;\n}\n\n \nSTATIC void\nxchk_agfl_xref(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\txfs_agblock_t\t\tagbno;\n\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn;\n\n\tagbno = XFS_AGFL_BLOCK(mp);\n\n\txchk_ag_btcur_init(sc, &sc->sa);\n\n\txchk_xref_is_used_space(sc, agbno, 1);\n\txchk_xref_is_not_inode_chunk(sc, agbno, 1);\n\txchk_xref_is_only_owned_by(sc, agbno, 1, &XFS_RMAP_OINFO_FS);\n\txchk_xref_is_not_shared(sc, agbno, 1);\n\txchk_xref_is_not_cow_staging(sc, agbno, 1);\n\n\t \n}\n\n \nint\nxchk_agfl(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xchk_agfl_info\tsai = {\n\t\t.sc\t\t= sc,\n\t};\n\tstruct xfs_agf\t\t*agf;\n\txfs_agnumber_t\t\tagno = sc->sm->sm_agno;\n\tunsigned int\t\ti;\n\tint\t\t\terror;\n\n\t \n\terror = xchk_ag_read_headers(sc, agno, &sc->sa);\n\tif (!xchk_process_error(sc, agno, XFS_AGFL_BLOCK(sc->mp), &error))\n\t\treturn error;\n\tif (!sc->sa.agf_bp)\n\t\treturn -EFSCORRUPTED;\n\n\t \n\terror = xfs_alloc_read_agfl(sc->sa.pag, sc->tp, &sai.agfl_bp);\n\tif (!xchk_process_error(sc, agno, XFS_AGFL_BLOCK(sc->mp), &error))\n\t\treturn error;\n\txchk_buffer_recheck(sc, sai.agfl_bp);\n\n\txchk_agfl_xref(sc);\n\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\tgoto out;\n\n\t \n\tagf = sc->sa.agf_bp->b_addr;\n\tsai.agflcount = be32_to_cpu(agf->agf_flcount);\n\tif (sai.agflcount > xfs_agfl_size(sc->mp)) {\n\t\txchk_block_set_corrupt(sc, sc->sa.agf_bp);\n\t\tgoto out;\n\t}\n\tsai.entries = kvcalloc(sai.agflcount, sizeof(xfs_agblock_t),\n\t\t\t       XCHK_GFP_FLAGS);\n\tif (!sai.entries) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\terror = xfs_agfl_walk(sc->mp, sc->sa.agf_bp->b_addr, sai.agfl_bp,\n\t\t\txchk_agfl_block, &sai);\n\tif (error == -ECANCELED) {\n\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\tif (error)\n\t\tgoto out_free;\n\n\tif (sai.agflcount != sai.nr_entries) {\n\t\txchk_block_set_corrupt(sc, sc->sa.agf_bp);\n\t\tgoto out_free;\n\t}\n\n\t \n\tsort(sai.entries, sai.nr_entries, sizeof(sai.entries[0]),\n\t\t\txchk_agblock_cmp, NULL);\n\tfor (i = 1; i < sai.nr_entries; i++) {\n\t\tif (sai.entries[i] == sai.entries[i - 1]) {\n\t\t\txchk_block_set_corrupt(sc, sc->sa.agf_bp);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_free:\n\tkvfree(sai.entries);\nout:\n\treturn error;\n}\n\n \n\n \nstatic inline void\nxchk_agi_xref_icounts(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_agi\t\t*agi = sc->sa.agi_bp->b_addr;\n\txfs_agino_t\t\ticount;\n\txfs_agino_t\t\tfreecount;\n\tint\t\t\terror;\n\n\tif (!sc->sa.ino_cur)\n\t\treturn;\n\n\terror = xfs_ialloc_count_inodes(sc->sa.ino_cur, &icount, &freecount);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.ino_cur))\n\t\treturn;\n\tif (be32_to_cpu(agi->agi_count) != icount ||\n\t    be32_to_cpu(agi->agi_freecount) != freecount)\n\t\txchk_block_xref_set_corrupt(sc, sc->sa.agi_bp);\n}\n\n \nstatic inline void\nxchk_agi_xref_fiblocks(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_agi\t\t*agi = sc->sa.agi_bp->b_addr;\n\txfs_agblock_t\t\tblocks;\n\tint\t\t\terror = 0;\n\n\tif (!xfs_has_inobtcounts(sc->mp))\n\t\treturn;\n\n\tif (sc->sa.ino_cur) {\n\t\terror = xfs_btree_count_blocks(sc->sa.ino_cur, &blocks);\n\t\tif (!xchk_should_check_xref(sc, &error, &sc->sa.ino_cur))\n\t\t\treturn;\n\t\tif (blocks != be32_to_cpu(agi->agi_iblocks))\n\t\t\txchk_block_xref_set_corrupt(sc, sc->sa.agi_bp);\n\t}\n\n\tif (sc->sa.fino_cur) {\n\t\terror = xfs_btree_count_blocks(sc->sa.fino_cur, &blocks);\n\t\tif (!xchk_should_check_xref(sc, &error, &sc->sa.fino_cur))\n\t\t\treturn;\n\t\tif (blocks != be32_to_cpu(agi->agi_fblocks))\n\t\t\txchk_block_xref_set_corrupt(sc, sc->sa.agi_bp);\n\t}\n}\n\n \nSTATIC void\nxchk_agi_xref(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\txfs_agblock_t\t\tagbno;\n\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn;\n\n\tagbno = XFS_AGI_BLOCK(mp);\n\n\txchk_ag_btcur_init(sc, &sc->sa);\n\n\txchk_xref_is_used_space(sc, agbno, 1);\n\txchk_xref_is_not_inode_chunk(sc, agbno, 1);\n\txchk_agi_xref_icounts(sc);\n\txchk_xref_is_only_owned_by(sc, agbno, 1, &XFS_RMAP_OINFO_FS);\n\txchk_xref_is_not_shared(sc, agbno, 1);\n\txchk_xref_is_not_cow_staging(sc, agbno, 1);\n\txchk_agi_xref_fiblocks(sc);\n\n\t \n}\n\n \nint\nxchk_agi(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\tstruct xfs_agi\t\t*agi;\n\tstruct xfs_perag\t*pag;\n\tstruct xfs_ino_geometry\t*igeo = M_IGEO(sc->mp);\n\txfs_agnumber_t\t\tagno = sc->sm->sm_agno;\n\txfs_agblock_t\t\tagbno;\n\txfs_agblock_t\t\teoag;\n\txfs_agino_t\t\tagino;\n\txfs_agino_t\t\tfirst_agino;\n\txfs_agino_t\t\tlast_agino;\n\txfs_agino_t\t\ticount;\n\tint\t\t\ti;\n\tint\t\t\tlevel;\n\tint\t\t\terror = 0;\n\n\terror = xchk_ag_read_headers(sc, agno, &sc->sa);\n\tif (!xchk_process_error(sc, agno, XFS_AGI_BLOCK(sc->mp), &error))\n\t\tgoto out;\n\txchk_buffer_recheck(sc, sc->sa.agi_bp);\n\n\tagi = sc->sa.agi_bp->b_addr;\n\tpag = sc->sa.pag;\n\n\t \n\teoag = be32_to_cpu(agi->agi_length);\n\tif (eoag != pag->block_count)\n\t\txchk_block_set_corrupt(sc, sc->sa.agi_bp);\n\n\t \n\tagbno = be32_to_cpu(agi->agi_root);\n\tif (!xfs_verify_agbno(pag, agbno))\n\t\txchk_block_set_corrupt(sc, sc->sa.agi_bp);\n\n\tlevel = be32_to_cpu(agi->agi_level);\n\tif (level <= 0 || level > igeo->inobt_maxlevels)\n\t\txchk_block_set_corrupt(sc, sc->sa.agi_bp);\n\n\tif (xfs_has_finobt(mp)) {\n\t\tagbno = be32_to_cpu(agi->agi_free_root);\n\t\tif (!xfs_verify_agbno(pag, agbno))\n\t\t\txchk_block_set_corrupt(sc, sc->sa.agi_bp);\n\n\t\tlevel = be32_to_cpu(agi->agi_free_level);\n\t\tif (level <= 0 || level > igeo->inobt_maxlevels)\n\t\t\txchk_block_set_corrupt(sc, sc->sa.agi_bp);\n\t}\n\n\t \n\txfs_agino_range(mp, agno, &first_agino, &last_agino);\n\ticount = be32_to_cpu(agi->agi_count);\n\tif (icount > last_agino - first_agino + 1 ||\n\t    icount < be32_to_cpu(agi->agi_freecount))\n\t\txchk_block_set_corrupt(sc, sc->sa.agi_bp);\n\n\t \n\tagino = be32_to_cpu(agi->agi_newino);\n\tif (!xfs_verify_agino_or_null(pag, agino))\n\t\txchk_block_set_corrupt(sc, sc->sa.agi_bp);\n\n\tagino = be32_to_cpu(agi->agi_dirino);\n\tif (!xfs_verify_agino_or_null(pag, agino))\n\t\txchk_block_set_corrupt(sc, sc->sa.agi_bp);\n\n\t \n\tfor (i = 0; i < XFS_AGI_UNLINKED_BUCKETS; i++) {\n\t\tagino = be32_to_cpu(agi->agi_unlinked[i]);\n\t\tif (!xfs_verify_agino_or_null(pag, agino))\n\t\t\txchk_block_set_corrupt(sc, sc->sa.agi_bp);\n\t}\n\n\tif (agi->agi_pad32 != cpu_to_be32(0))\n\t\txchk_block_set_corrupt(sc, sc->sa.agi_bp);\n\n\t \n\tif (pag->pagi_count != be32_to_cpu(agi->agi_count))\n\t\txchk_block_set_corrupt(sc, sc->sa.agi_bp);\n\tif (pag->pagi_freecount != be32_to_cpu(agi->agi_freecount))\n\t\txchk_block_set_corrupt(sc, sc->sa.agi_bp);\n\n\txchk_agi_xref(sc);\nout:\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}