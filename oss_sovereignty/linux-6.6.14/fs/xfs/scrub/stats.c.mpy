{
  "module_name": "stats.c",
  "hash_id": "c95c76d0f3574139ccc9a447059c821c1ef61f560ce32e7f34ddc55f2ab00639",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/stats.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_super.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/stats.h\"\n#include \"scrub/trace.h\"\n\nstruct xchk_scrub_stats {\n\t \n\n\t \n\tuint32_t\t\tinvocations;\n\tuint32_t\t\tclean;\n\tuint32_t\t\tcorrupt;\n\tuint32_t\t\tpreen;\n\tuint32_t\t\txfail;\n\tuint32_t\t\txcorrupt;\n\tuint32_t\t\tincomplete;\n\tuint32_t\t\twarning;\n\tuint32_t\t\tretries;\n\n\t \n\tuint32_t\t\trepair_invocations;\n\tuint32_t\t\trepair_success;\n\n\t \n\n\t \n\tuint64_t\t\tchecktime_us;\n\tuint64_t\t\trepairtime_us;\n\n\t \n\tspinlock_t\t\tcss_lock;\n};\n\nstruct xchk_stats {\n\tstruct dentry\t\t*cs_debugfs;\n\tstruct xchk_scrub_stats\tcs_stats[XFS_SCRUB_TYPE_NR];\n};\n\n\nstatic struct xchk_stats\tglobal_stats;\n\nstatic const char *name_map[XFS_SCRUB_TYPE_NR] = {\n\t[XFS_SCRUB_TYPE_SB]\t\t= \"sb\",\n\t[XFS_SCRUB_TYPE_AGF]\t\t= \"agf\",\n\t[XFS_SCRUB_TYPE_AGFL]\t\t= \"agfl\",\n\t[XFS_SCRUB_TYPE_AGI]\t\t= \"agi\",\n\t[XFS_SCRUB_TYPE_BNOBT]\t\t= \"bnobt\",\n\t[XFS_SCRUB_TYPE_CNTBT]\t\t= \"cntbt\",\n\t[XFS_SCRUB_TYPE_INOBT]\t\t= \"inobt\",\n\t[XFS_SCRUB_TYPE_FINOBT]\t\t= \"finobt\",\n\t[XFS_SCRUB_TYPE_RMAPBT]\t\t= \"rmapbt\",\n\t[XFS_SCRUB_TYPE_REFCNTBT]\t= \"refcountbt\",\n\t[XFS_SCRUB_TYPE_INODE]\t\t= \"inode\",\n\t[XFS_SCRUB_TYPE_BMBTD]\t\t= \"bmapbtd\",\n\t[XFS_SCRUB_TYPE_BMBTA]\t\t= \"bmapbta\",\n\t[XFS_SCRUB_TYPE_BMBTC]\t\t= \"bmapbtc\",\n\t[XFS_SCRUB_TYPE_DIR]\t\t= \"directory\",\n\t[XFS_SCRUB_TYPE_XATTR]\t\t= \"xattr\",\n\t[XFS_SCRUB_TYPE_SYMLINK]\t= \"symlink\",\n\t[XFS_SCRUB_TYPE_PARENT]\t\t= \"parent\",\n\t[XFS_SCRUB_TYPE_RTBITMAP]\t= \"rtbitmap\",\n\t[XFS_SCRUB_TYPE_RTSUM]\t\t= \"rtsummary\",\n\t[XFS_SCRUB_TYPE_UQUOTA]\t\t= \"usrquota\",\n\t[XFS_SCRUB_TYPE_GQUOTA]\t\t= \"grpquota\",\n\t[XFS_SCRUB_TYPE_PQUOTA]\t\t= \"prjquota\",\n\t[XFS_SCRUB_TYPE_FSCOUNTERS]\t= \"fscounters\",\n};\n\n \nSTATIC ssize_t\nxchk_stats_format(\n\tstruct xchk_stats\t*cs,\n\tchar\t\t\t*buf,\n\tsize_t\t\t\tremaining)\n{\n\tstruct xchk_scrub_stats\t*css = &cs->cs_stats[0];\n\tunsigned int\t\ti;\n\tssize_t\t\t\tcopied = 0;\n\tint\t\t\tret = 0;\n\n\tfor (i = 0; i < XFS_SCRUB_TYPE_NR; i++, css++) {\n\t\tif (!name_map[i])\n\t\t\tcontinue;\n\n\t\tret = scnprintf(buf, remaining,\n \"%s %u %u %u %u %u %u %u %u %u %llu %u %u %llu\\n\",\n\t\t\t\tname_map[i],\n\t\t\t\t(unsigned int)css->invocations,\n\t\t\t\t(unsigned int)css->clean,\n\t\t\t\t(unsigned int)css->corrupt,\n\t\t\t\t(unsigned int)css->preen,\n\t\t\t\t(unsigned int)css->xfail,\n\t\t\t\t(unsigned int)css->xcorrupt,\n\t\t\t\t(unsigned int)css->incomplete,\n\t\t\t\t(unsigned int)css->warning,\n\t\t\t\t(unsigned int)css->retries,\n\t\t\t\t(unsigned long long)css->checktime_us,\n\t\t\t\t(unsigned int)css->repair_invocations,\n\t\t\t\t(unsigned int)css->repair_success,\n\t\t\t\t(unsigned long long)css->repairtime_us);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tremaining -= ret;\n\t\tcopied += ret;\n\t\tbuf +=  ret;\n\t}\n\n\treturn copied > 0 ? copied : ret;\n}\n\n \nSTATIC size_t\nxchk_stats_estimate_bufsize(\n\tstruct xchk_stats\t*cs)\n{\n\tstruct xchk_scrub_stats\t*css = &cs->cs_stats[0];\n\tunsigned int\t\ti;\n\tsize_t\t\t\tfield_width;\n\tsize_t\t\t\tret = 0;\n\n\t \n\tfield_width = 11 * (offsetof(struct xchk_scrub_stats, checktime_us) /\n\t\t\t    sizeof(uint32_t));\n\n\t \n\tfield_width += 21 * ((offsetof(struct xchk_scrub_stats, css_lock) -\n\t\t\t      offsetof(struct xchk_scrub_stats, checktime_us)) /\n\t\t\t     sizeof(uint64_t));\n\n\tfor (i = 0; i < XFS_SCRUB_TYPE_NR; i++, css++) {\n\t\tif (!name_map[i])\n\t\t\tcontinue;\n\n\t\t \n\t\tret += 1 + strlen(name_map[i]);\n\n\t\t \n\t\tret += field_width + 1;\n\t}\n\n\treturn ret;\n}\n\n \nSTATIC void\nxchk_stats_clearall(\n\tstruct xchk_stats\t*cs)\n{\n\tstruct xchk_scrub_stats\t*css = &cs->cs_stats[0];\n\tunsigned int\t\ti;\n\n\tfor (i = 0; i < XFS_SCRUB_TYPE_NR; i++, css++) {\n\t\tspin_lock(&css->css_lock);\n\t\tmemset(css, 0, offsetof(struct xchk_scrub_stats, css_lock));\n\t\tspin_unlock(&css->css_lock);\n\t}\n}\n\n#define XFS_SCRUB_OFLAG_UNCLEAN\t(XFS_SCRUB_OFLAG_CORRUPT | \\\n\t\t\t\t XFS_SCRUB_OFLAG_PREEN | \\\n\t\t\t\t XFS_SCRUB_OFLAG_XFAIL | \\\n\t\t\t\t XFS_SCRUB_OFLAG_XCORRUPT | \\\n\t\t\t\t XFS_SCRUB_OFLAG_INCOMPLETE | \\\n\t\t\t\t XFS_SCRUB_OFLAG_WARNING)\n\nSTATIC void\nxchk_stats_merge_one(\n\tstruct xchk_stats\t\t*cs,\n\tconst struct xfs_scrub_metadata\t*sm,\n\tconst struct xchk_stats_run\t*run)\n{\n\tstruct xchk_scrub_stats\t\t*css;\n\n\tif (sm->sm_type >= XFS_SCRUB_TYPE_NR) {\n\t\tASSERT(sm->sm_type < XFS_SCRUB_TYPE_NR);\n\t\treturn;\n\t}\n\n\tcss = &cs->cs_stats[sm->sm_type];\n\tspin_lock(&css->css_lock);\n\tcss->invocations++;\n\tif (!(sm->sm_flags & XFS_SCRUB_OFLAG_UNCLEAN))\n\t\tcss->clean++;\n\tif (sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\tcss->corrupt++;\n\tif (sm->sm_flags & XFS_SCRUB_OFLAG_PREEN)\n\t\tcss->preen++;\n\tif (sm->sm_flags & XFS_SCRUB_OFLAG_XFAIL)\n\t\tcss->xfail++;\n\tif (sm->sm_flags & XFS_SCRUB_OFLAG_XCORRUPT)\n\t\tcss->xcorrupt++;\n\tif (sm->sm_flags & XFS_SCRUB_OFLAG_INCOMPLETE)\n\t\tcss->incomplete++;\n\tif (sm->sm_flags & XFS_SCRUB_OFLAG_WARNING)\n\t\tcss->warning++;\n\tcss->retries += run->retries;\n\tcss->checktime_us += howmany_64(run->scrub_ns, NSEC_PER_USEC);\n\n\tif (run->repair_attempted)\n\t\tcss->repair_invocations++;\n\tif (run->repair_succeeded)\n\t\tcss->repair_success++;\n\tcss->repairtime_us += howmany_64(run->repair_ns, NSEC_PER_USEC);\n\tspin_unlock(&css->css_lock);\n}\n\n \nvoid\nxchk_stats_merge(\n\tstruct xfs_mount\t\t*mp,\n\tconst struct xfs_scrub_metadata\t*sm,\n\tconst struct xchk_stats_run\t*run)\n{\n\txchk_stats_merge_one(&global_stats, sm, run);\n\txchk_stats_merge_one(mp->m_scrub_stats, sm, run);\n}\n\n \n\nstatic ssize_t\nxchk_scrub_stats_read(\n\tstruct file\t\t*file,\n\tchar __user\t\t*ubuf,\n\tsize_t\t\t\tcount,\n\tloff_t\t\t\t*ppos)\n{\n\tstruct xchk_stats\t*cs = file->private_data;\n\tchar\t\t\t*buf;\n\tsize_t\t\t\tbufsize;\n\tssize_t\t\t\tavail, ret;\n\n\t \n\tif (*ppos > 0)\n\t\treturn 0;\n\n\tbufsize = xchk_stats_estimate_bufsize(cs);\n\n\tbuf = kvmalloc(bufsize, XCHK_GFP_FLAGS);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tavail = xchk_stats_format(cs, buf, bufsize);\n\tif (avail < 0) {\n\t\tret = avail;\n\t\tgoto out;\n\t}\n\n\tret = simple_read_from_buffer(ubuf, count, ppos, buf, avail);\nout:\n\tkvfree(buf);\n\treturn ret;\n}\n\nstatic const struct file_operations scrub_stats_fops = {\n\t.open\t\t\t= simple_open,\n\t.read\t\t\t= xchk_scrub_stats_read,\n};\n\nstatic ssize_t\nxchk_clear_scrub_stats_write(\n\tstruct file\t\t*file,\n\tconst char __user\t*ubuf,\n\tsize_t\t\t\tcount,\n\tloff_t\t\t\t*ppos)\n{\n\tstruct xchk_stats\t*cs = file->private_data;\n\tunsigned int\t\tval;\n\tint\t\t\tret;\n\n\tret = kstrtouint_from_user(ubuf, count, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\txchk_stats_clearall(cs);\n\treturn count;\n}\n\nstatic const struct file_operations clear_scrub_stats_fops = {\n\t.open\t\t\t= simple_open,\n\t.write\t\t\t= xchk_clear_scrub_stats_write,\n};\n\n \nSTATIC int\nxchk_stats_init(\n\tstruct xchk_stats\t*cs,\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xchk_scrub_stats\t*css = &cs->cs_stats[0];\n\tunsigned int\t\ti;\n\n\tfor (i = 0; i < XFS_SCRUB_TYPE_NR; i++, css++)\n\t\tspin_lock_init(&css->css_lock);\n\n\treturn 0;\n}\n\n \nvoid\nxchk_stats_register(\n\tstruct xchk_stats\t*cs,\n\tstruct dentry\t\t*parent)\n{\n\tif (!parent)\n\t\treturn;\n\n\tcs->cs_debugfs = xfs_debugfs_mkdir(\"scrub\", parent);\n\tif (!cs->cs_debugfs)\n\t\treturn;\n\n\tdebugfs_create_file(\"stats\", 0644, cs->cs_debugfs, cs,\n\t\t\t&scrub_stats_fops);\n\tdebugfs_create_file(\"clear_stats\", 0400, cs->cs_debugfs, cs,\n\t\t\t&clear_scrub_stats_fops);\n}\n\n \nSTATIC int\nxchk_stats_teardown(\n\tstruct xchk_stats\t*cs)\n{\n\treturn 0;\n}\n\n \nvoid\nxchk_stats_unregister(\n\tstruct xchk_stats\t*cs)\n{\n\tdebugfs_remove(cs->cs_debugfs);\n}\n\n \nint __init\nxchk_global_stats_setup(\n\tstruct dentry\t\t*parent)\n{\n\tint\t\t\terror;\n\n\terror = xchk_stats_init(&global_stats, NULL);\n\tif (error)\n\t\treturn error;\n\n\txchk_stats_register(&global_stats, parent);\n\treturn 0;\n}\n\n \nvoid\nxchk_global_stats_teardown(void)\n{\n\txchk_stats_unregister(&global_stats);\n\txchk_stats_teardown(&global_stats);\n}\n\n \nint\nxchk_mount_stats_alloc(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xchk_stats\t*cs;\n\tint\t\t\terror;\n\n\tcs = kvzalloc(sizeof(struct xchk_stats), GFP_KERNEL);\n\tif (!cs)\n\t\treturn -ENOMEM;\n\n\terror = xchk_stats_init(cs, mp);\n\tif (error)\n\t\tgoto out_free;\n\n\tmp->m_scrub_stats = cs;\n\treturn 0;\nout_free:\n\tkvfree(cs);\n\treturn error;\n}\n\n \nvoid\nxchk_mount_stats_free(\n\tstruct xfs_mount\t*mp)\n{\n\txchk_stats_teardown(mp->m_scrub_stats);\n\tkvfree(mp->m_scrub_stats);\n\tmp->m_scrub_stats = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}