{
  "module_name": "inode.c",
  "hash_id": "0d72ac3004e4f5e6431dfa7a0b944498e86b0e65578608e6f91668ff0280968a",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/inode.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_reflink.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_bmap_util.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/common.h\"\n#include \"scrub/btree.h\"\n#include \"scrub/trace.h\"\n\n \nstatic inline int\nxchk_prepare_iscrub(\n\tstruct xfs_scrub\t*sc)\n{\n\tint\t\t\terror;\n\n\txchk_ilock(sc, XFS_IOLOCK_EXCL);\n\n\terror = xchk_trans_alloc(sc, 0);\n\tif (error)\n\t\treturn error;\n\n\txchk_ilock(sc, XFS_ILOCK_EXCL);\n\treturn 0;\n}\n\n \nstatic inline int\nxchk_install_handle_iscrub(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_inode\t*ip)\n{\n\tint\t\t\terror;\n\n\terror = xchk_install_handle_inode(sc, ip);\n\tif (error)\n\t\treturn error;\n\n\treturn xchk_prepare_iscrub(sc);\n}\n\n \nint\nxchk_setup_inode(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_imap\t\timap;\n\tstruct xfs_inode\t*ip;\n\tstruct xfs_mount\t*mp = sc->mp;\n\tstruct xfs_inode\t*ip_in = XFS_I(file_inode(sc->file));\n\tstruct xfs_buf\t\t*agi_bp;\n\tstruct xfs_perag\t*pag;\n\txfs_agnumber_t\t\tagno = XFS_INO_TO_AGNO(mp, sc->sm->sm_ino);\n\tint\t\t\terror;\n\n\tif (xchk_need_intent_drain(sc))\n\t\txchk_fsgates_enable(sc, XCHK_FSGATES_DRAIN);\n\n\t \n\tif (sc->sm->sm_ino == 0 || sc->sm->sm_ino == ip_in->i_ino) {\n\t\terror = xchk_install_live_inode(sc, ip_in);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\treturn xchk_prepare_iscrub(sc);\n\t}\n\n\t \n\tif (xfs_internal_inum(mp, sc->sm->sm_ino))\n\t\treturn -ENOENT;\n\tif (!xfs_verify_ino(sc->mp, sc->sm->sm_ino))\n\t\treturn -ENOENT;\n\n\t \n\terror = xchk_iget(sc, sc->sm->sm_ino, &ip);\n\tif (!error)\n\t\treturn xchk_install_handle_iscrub(sc, ip);\n\tif (error == -ENOENT)\n\t\treturn error;\n\tif (error != -EFSCORRUPTED && error != -EFSBADCRC && error != -EINVAL)\n\t\tgoto out_error;\n\n\t \n\terror = xchk_trans_alloc(sc, 0);\n\tif (error)\n\t\tgoto out_error;\n\n\terror = xchk_iget_agi(sc, sc->sm->sm_ino, &agi_bp, &ip);\n\tif (error == 0) {\n\t\t \n\t\txchk_trans_cancel(sc);\n\t\treturn xchk_install_handle_iscrub(sc, ip);\n\t}\n\tif (error == -ENOENT)\n\t\tgoto out_gone;\n\tif (error != -EFSCORRUPTED && error != -EFSBADCRC && error != -EINVAL)\n\t\tgoto out_cancel;\n\n\t \n\tif (agi_bp == NULL) {\n\t\tASSERT(agi_bp != NULL);\n\t\terror = -ECANCELED;\n\t\tgoto out_cancel;\n\t}\n\n\t \n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, sc->sm->sm_ino));\n\tif (!pag) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_cancel;\n\t}\n\n\terror = xfs_imap(pag, sc->tp, sc->sm->sm_ino, &imap,\n\t\t\tXFS_IGET_UNTRUSTED);\n\txfs_perag_put(pag);\n\tif (error == -EINVAL || error == -ENOENT)\n\t\tgoto out_gone;\n\tif (error)\n\t\tgoto out_cancel;\n\n\t \n\treturn 0;\n\nout_cancel:\n\txchk_trans_cancel(sc);\nout_error:\n\ttrace_xchk_op_error(sc, agno, XFS_INO_TO_AGBNO(mp, sc->sm->sm_ino),\n\t\t\terror, __return_address);\n\treturn error;\nout_gone:\n\t \n\txchk_trans_cancel(sc);\n\treturn -ENOENT;\n}\n\n \n\n \nSTATIC void\nxchk_inode_extsize(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_dinode\t*dip,\n\txfs_ino_t\t\tino,\n\tuint16_t\t\tmode,\n\tuint16_t\t\tflags)\n{\n\txfs_failaddr_t\t\tfa;\n\tuint32_t\t\tvalue = be32_to_cpu(dip->di_extsize);\n\n\tfa = xfs_inode_validate_extsize(sc->mp, value, mode, flags);\n\tif (fa)\n\t\txchk_ino_set_corrupt(sc, ino);\n\n\t \n\tif ((flags & XFS_DIFLAG_RTINHERIT) &&\n\t    (flags & XFS_DIFLAG_EXTSZINHERIT) &&\n\t    value % sc->mp->m_sb.sb_rextsize > 0)\n\t\txchk_ino_set_warning(sc, ino);\n}\n\n \nSTATIC void\nxchk_inode_cowextsize(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_dinode\t*dip,\n\txfs_ino_t\t\tino,\n\tuint16_t\t\tmode,\n\tuint16_t\t\tflags,\n\tuint64_t\t\tflags2)\n{\n\txfs_failaddr_t\t\tfa;\n\n\tfa = xfs_inode_validate_cowextsize(sc->mp,\n\t\t\tbe32_to_cpu(dip->di_cowextsize), mode, flags,\n\t\t\tflags2);\n\tif (fa)\n\t\txchk_ino_set_corrupt(sc, ino);\n}\n\n \nSTATIC void\nxchk_inode_flags(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_dinode\t*dip,\n\txfs_ino_t\t\tino,\n\tuint16_t\t\tmode,\n\tuint16_t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\n\t \n\tif (flags & ~XFS_DIFLAG_ANY)\n\t\tgoto bad;\n\n\t \n\tif ((flags & XFS_DIFLAG_REALTIME) && !mp->m_rtdev_targp)\n\t\tgoto bad;\n\n\t \n\tif ((flags & XFS_DIFLAG_NEWRTBM) && ino != mp->m_sb.sb_rbmino)\n\t\tgoto bad;\n\n\t \n\tif ((flags & (XFS_DIFLAG_RTINHERIT |\n\t\t     XFS_DIFLAG_EXTSZINHERIT |\n\t\t     XFS_DIFLAG_PROJINHERIT |\n\t\t     XFS_DIFLAG_NOSYMLINKS)) &&\n\t    !S_ISDIR(mode))\n\t\tgoto bad;\n\n\t \n\tif ((flags & (XFS_DIFLAG_REALTIME | FS_XFLAG_EXTSIZE)) &&\n\t    !S_ISREG(mode))\n\t\tgoto bad;\n\n\t \n\tif ((flags & XFS_DIFLAG_FILESTREAM) && (flags & XFS_DIFLAG_REALTIME))\n\t\tgoto bad;\n\n\treturn;\nbad:\n\txchk_ino_set_corrupt(sc, ino);\n}\n\n \nSTATIC void\nxchk_inode_flags2(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_dinode\t*dip,\n\txfs_ino_t\t\tino,\n\tuint16_t\t\tmode,\n\tuint16_t\t\tflags,\n\tuint64_t\t\tflags2)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\n\t \n\tif (flags2 & ~XFS_DIFLAG2_ANY)\n\t\txchk_ino_set_warning(sc, ino);\n\n\t \n\tif ((flags2 & XFS_DIFLAG2_REFLINK) &&\n\t    !xfs_has_reflink(mp))\n\t\tgoto bad;\n\n\t \n\n\t \n\tif ((flags2 & XFS_DIFLAG2_DAX) && !(S_ISREG(mode) || S_ISDIR(mode)))\n\t\tgoto bad;\n\n\t \n\tif ((flags2 & XFS_DIFLAG2_REFLINK) && !S_ISREG(mode))\n\t\tgoto bad;\n\n\t \n\tif ((flags & XFS_DIFLAG_REALTIME) && (flags2 & XFS_DIFLAG2_REFLINK))\n\t\tgoto bad;\n\n\t \n\tif (xfs_dinode_has_bigtime(dip) && !xfs_has_bigtime(mp))\n\t\tgoto bad;\n\n\treturn;\nbad:\n\txchk_ino_set_corrupt(sc, ino);\n}\n\nstatic inline void\nxchk_dinode_nsec(\n\tstruct xfs_scrub\t*sc,\n\txfs_ino_t\t\tino,\n\tstruct xfs_dinode\t*dip,\n\tconst xfs_timestamp_t\tts)\n{\n\tstruct timespec64\ttv;\n\n\ttv = xfs_inode_from_disk_ts(dip, ts);\n\tif (tv.tv_nsec < 0 || tv.tv_nsec >= NSEC_PER_SEC)\n\t\txchk_ino_set_corrupt(sc, ino);\n}\n\n \nSTATIC void\nxchk_dinode(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_dinode\t*dip,\n\txfs_ino_t\t\tino)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\tsize_t\t\t\tfork_recs;\n\tunsigned long long\tisize;\n\tuint64_t\t\tflags2;\n\txfs_extnum_t\t\tnextents;\n\txfs_extnum_t\t\tnaextents;\n\tprid_t\t\t\tprid;\n\tuint16_t\t\tflags;\n\tuint16_t\t\tmode;\n\n\tflags = be16_to_cpu(dip->di_flags);\n\tif (dip->di_version >= 3)\n\t\tflags2 = be64_to_cpu(dip->di_flags2);\n\telse\n\t\tflags2 = 0;\n\n\t \n\tmode = be16_to_cpu(dip->di_mode);\n\tswitch (mode & S_IFMT) {\n\tcase S_IFLNK:\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\txchk_ino_set_corrupt(sc, ino);\n\t\tbreak;\n\t}\n\n\t \n\tswitch (dip->di_version) {\n\tcase 1:\n\t\t \n\t\txchk_ino_set_preen(sc, ino);\n\t\tprid = 0;\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tif (dip->di_onlink != 0)\n\t\t\txchk_ino_set_corrupt(sc, ino);\n\n\t\tif (dip->di_mode == 0 && sc->ip)\n\t\t\txchk_ino_set_corrupt(sc, ino);\n\n\t\tif (dip->di_projid_hi != 0 &&\n\t\t    !xfs_has_projid32(mp))\n\t\t\txchk_ino_set_corrupt(sc, ino);\n\n\t\tprid = be16_to_cpu(dip->di_projid_lo);\n\t\tbreak;\n\tdefault:\n\t\txchk_ino_set_corrupt(sc, ino);\n\t\treturn;\n\t}\n\n\tif (xfs_has_projid32(mp))\n\t\tprid |= (prid_t)be16_to_cpu(dip->di_projid_hi) << 16;\n\n\t \n\tif (dip->di_uid == cpu_to_be32(-1U) ||\n\t    dip->di_gid == cpu_to_be32(-1U))\n\t\txchk_ino_set_warning(sc, ino);\n\n\t \n\tif (prid == -1U)\n\t\txchk_ino_set_warning(sc, ino);\n\n\t \n\tswitch (dip->di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tif (!S_ISCHR(mode) && !S_ISBLK(mode) &&\n\t\t    !S_ISFIFO(mode) && !S_ISSOCK(mode))\n\t\t\txchk_ino_set_corrupt(sc, ino);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif (!S_ISDIR(mode) && !S_ISLNK(mode))\n\t\t\txchk_ino_set_corrupt(sc, ino);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif (!S_ISREG(mode) && !S_ISDIR(mode) && !S_ISLNK(mode))\n\t\t\txchk_ino_set_corrupt(sc, ino);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\t\txchk_ino_set_corrupt(sc, ino);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_UUID:\n\tdefault:\n\t\txchk_ino_set_corrupt(sc, ino);\n\t\tbreak;\n\t}\n\n\t \n\txchk_dinode_nsec(sc, ino, dip, dip->di_atime);\n\txchk_dinode_nsec(sc, ino, dip, dip->di_mtime);\n\txchk_dinode_nsec(sc, ino, dip, dip->di_ctime);\n\n\t \n\tisize = be64_to_cpu(dip->di_size);\n\tif (isize & (1ULL << 63))\n\t\txchk_ino_set_corrupt(sc, ino);\n\n\t \n\tif (!S_ISDIR(mode) && !S_ISREG(mode) && !S_ISLNK(mode) && isize != 0)\n\t\txchk_ino_set_corrupt(sc, ino);\n\n\t \n\tif (S_ISDIR(mode) && (isize == 0 || isize >= XFS_DIR2_SPACE_SIZE))\n\t\txchk_ino_set_corrupt(sc, ino);\n\n\t \n\tif (S_ISLNK(mode) && (isize == 0 || isize >= XFS_SYMLINK_MAXLEN))\n\t\txchk_ino_set_corrupt(sc, ino);\n\n\t \n\tif (isize > mp->m_super->s_maxbytes)\n\t\txchk_ino_set_warning(sc, ino);\n\n\t \n\tif (flags2 & XFS_DIFLAG2_REFLINK) {\n\t\t;  \n\t} else if (flags & XFS_DIFLAG_REALTIME) {\n\t\t \n\t\tif (be64_to_cpu(dip->di_nblocks) >=\n\t\t    mp->m_sb.sb_dblocks + mp->m_sb.sb_rblocks)\n\t\t\txchk_ino_set_corrupt(sc, ino);\n\t} else {\n\t\tif (be64_to_cpu(dip->di_nblocks) >= mp->m_sb.sb_dblocks)\n\t\t\txchk_ino_set_corrupt(sc, ino);\n\t}\n\n\txchk_inode_flags(sc, dip, ino, mode, flags);\n\n\txchk_inode_extsize(sc, dip, ino, mode, flags);\n\n\tnextents = xfs_dfork_data_extents(dip);\n\tnaextents = xfs_dfork_attr_extents(dip);\n\n\t \n\tfork_recs =  XFS_DFORK_DSIZE(dip, mp) / sizeof(struct xfs_bmbt_rec);\n\tswitch (dip->di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif (nextents > fork_recs)\n\t\t\txchk_ino_set_corrupt(sc, ino);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif (nextents <= fork_recs)\n\t\t\txchk_ino_set_corrupt(sc, ino);\n\t\tbreak;\n\tdefault:\n\t\tif (nextents != 0)\n\t\t\txchk_ino_set_corrupt(sc, ino);\n\t\tbreak;\n\t}\n\n\t \n\tif (XFS_DFORK_APTR(dip) >= (char *)dip + mp->m_sb.sb_inodesize)\n\t\txchk_ino_set_corrupt(sc, ino);\n\tif (naextents != 0 && dip->di_forkoff == 0)\n\t\txchk_ino_set_corrupt(sc, ino);\n\tif (dip->di_forkoff == 0 && dip->di_aformat != XFS_DINODE_FMT_EXTENTS)\n\t\txchk_ino_set_corrupt(sc, ino);\n\n\t \n\tif (dip->di_aformat != XFS_DINODE_FMT_LOCAL &&\n\t    dip->di_aformat != XFS_DINODE_FMT_EXTENTS &&\n\t    dip->di_aformat != XFS_DINODE_FMT_BTREE)\n\t\txchk_ino_set_corrupt(sc, ino);\n\n\t \n\tfork_recs =  XFS_DFORK_ASIZE(dip, mp) / sizeof(struct xfs_bmbt_rec);\n\tswitch (dip->di_aformat) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif (naextents > fork_recs)\n\t\t\txchk_ino_set_corrupt(sc, ino);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif (naextents <= fork_recs)\n\t\t\txchk_ino_set_corrupt(sc, ino);\n\t\tbreak;\n\tdefault:\n\t\tif (naextents != 0)\n\t\t\txchk_ino_set_corrupt(sc, ino);\n\t}\n\n\tif (dip->di_version >= 3) {\n\t\txchk_dinode_nsec(sc, ino, dip, dip->di_crtime);\n\t\txchk_inode_flags2(sc, dip, ino, mode, flags, flags2);\n\t\txchk_inode_cowextsize(sc, dip, ino, mode, flags,\n\t\t\t\tflags2);\n\t}\n}\n\n \nstatic void\nxchk_inode_xref_finobt(\n\tstruct xfs_scrub\t\t*sc,\n\txfs_ino_t\t\t\tino)\n{\n\tstruct xfs_inobt_rec_incore\trec;\n\txfs_agino_t\t\t\tagino;\n\tint\t\t\t\thas_record;\n\tint\t\t\t\terror;\n\n\tif (!sc->sa.fino_cur || xchk_skip_xref(sc->sm))\n\t\treturn;\n\n\tagino = XFS_INO_TO_AGINO(sc->mp, ino);\n\n\t \n\terror = xfs_inobt_lookup(sc->sa.fino_cur, agino, XFS_LOOKUP_LE,\n\t\t\t&has_record);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.fino_cur) ||\n\t    !has_record)\n\t\treturn;\n\n\terror = xfs_inobt_get_rec(sc->sa.fino_cur, &rec, &has_record);\n\tif (!xchk_should_check_xref(sc, &error, &sc->sa.fino_cur) ||\n\t    !has_record)\n\t\treturn;\n\n\t \n\tif (rec.ir_startino > agino ||\n\t    rec.ir_startino + XFS_INODES_PER_CHUNK <= agino)\n\t\treturn;\n\n\tif (rec.ir_free & XFS_INOBT_MASK(agino - rec.ir_startino))\n\t\txchk_btree_xref_set_corrupt(sc, sc->sa.fino_cur, 0);\n}\n\n \nSTATIC void\nxchk_inode_xref_bmap(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_dinode\t*dip)\n{\n\txfs_extnum_t\t\tnextents;\n\txfs_filblks_t\t\tcount;\n\txfs_filblks_t\t\tacount;\n\tint\t\t\terror;\n\n\tif (xchk_skip_xref(sc->sm))\n\t\treturn;\n\n\t \n\terror = xfs_bmap_count_blocks(sc->tp, sc->ip, XFS_DATA_FORK,\n\t\t\t&nextents, &count);\n\tif (!xchk_should_check_xref(sc, &error, NULL))\n\t\treturn;\n\tif (nextents < xfs_dfork_data_extents(dip))\n\t\txchk_ino_xref_set_corrupt(sc, sc->ip->i_ino);\n\n\terror = xfs_bmap_count_blocks(sc->tp, sc->ip, XFS_ATTR_FORK,\n\t\t\t&nextents, &acount);\n\tif (!xchk_should_check_xref(sc, &error, NULL))\n\t\treturn;\n\tif (nextents != xfs_dfork_attr_extents(dip))\n\t\txchk_ino_xref_set_corrupt(sc, sc->ip->i_ino);\n\n\t \n\tif (count + acount != be64_to_cpu(dip->di_nblocks))\n\t\txchk_ino_xref_set_corrupt(sc, sc->ip->i_ino);\n}\n\n \nSTATIC void\nxchk_inode_xref(\n\tstruct xfs_scrub\t*sc,\n\txfs_ino_t\t\tino,\n\tstruct xfs_dinode\t*dip)\n{\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\tint\t\t\terror;\n\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn;\n\n\tagno = XFS_INO_TO_AGNO(sc->mp, ino);\n\tagbno = XFS_INO_TO_AGBNO(sc->mp, ino);\n\n\terror = xchk_ag_init_existing(sc, agno, &sc->sa);\n\tif (!xchk_xref_process_error(sc, agno, agbno, &error))\n\t\tgoto out_free;\n\n\txchk_xref_is_used_space(sc, agbno, 1);\n\txchk_inode_xref_finobt(sc, ino);\n\txchk_xref_is_only_owned_by(sc, agbno, 1, &XFS_RMAP_OINFO_INODES);\n\txchk_xref_is_not_shared(sc, agbno, 1);\n\txchk_xref_is_not_cow_staging(sc, agbno, 1);\n\txchk_inode_xref_bmap(sc, dip);\n\nout_free:\n\txchk_ag_free(sc, &sc->sa);\n}\n\n \nstatic void\nxchk_inode_check_reflink_iflag(\n\tstruct xfs_scrub\t*sc,\n\txfs_ino_t\t\tino)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\tbool\t\t\thas_shared;\n\tint\t\t\terror;\n\n\tif (!xfs_has_reflink(mp))\n\t\treturn;\n\n\terror = xfs_reflink_inode_has_shared_extents(sc->tp, sc->ip,\n\t\t\t&has_shared);\n\tif (!xchk_xref_process_error(sc, XFS_INO_TO_AGNO(mp, ino),\n\t\t\tXFS_INO_TO_AGBNO(mp, ino), &error))\n\t\treturn;\n\tif (xfs_is_reflink_inode(sc->ip) && !has_shared)\n\t\txchk_ino_set_preen(sc, ino);\n\telse if (!xfs_is_reflink_inode(sc->ip) && has_shared)\n\t\txchk_ino_set_corrupt(sc, ino);\n}\n\n \nint\nxchk_inode(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_dinode\tdi;\n\tint\t\t\terror = 0;\n\n\t \n\tif (!sc->ip) {\n\t\txchk_ino_set_corrupt(sc, sc->sm->sm_ino);\n\t\treturn 0;\n\t}\n\n\t \n\txfs_inode_to_disk(sc->ip, &di, 0);\n\txchk_dinode(sc, &di, sc->ip->i_ino);\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\tgoto out;\n\n\t \n\tif (S_ISREG(VFS_I(sc->ip)->i_mode))\n\t\txchk_inode_check_reflink_iflag(sc, sc->ip->i_ino);\n\n\txchk_inode_xref(sc, sc->ip->i_ino, &di);\nout:\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}