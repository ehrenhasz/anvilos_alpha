{
  "module_name": "attr.c",
  "hash_id": "a52d90db89ed99f89fe4eccfd3fdc3ed033014502ef078a45c5ebf69b08b575c",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/attr.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_sf.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/common.h\"\n#include \"scrub/dabtree.h\"\n#include \"scrub/attr.h\"\n\n \nstatic void\nxchk_xattr_buf_cleanup(\n\tvoid\t\t\t*priv)\n{\n\tstruct xchk_xattr_buf\t*ab = priv;\n\n\tkvfree(ab->freemap);\n\tab->freemap = NULL;\n\tkvfree(ab->usedmap);\n\tab->usedmap = NULL;\n\tkvfree(ab->value);\n\tab->value = NULL;\n\tab->value_sz = 0;\n}\n\n \nstatic inline bool\nxchk_xattr_want_freemap(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_ifork\t*ifp;\n\n\tif (sc->flags & XCHK_TRY_HARDER)\n\t\treturn true;\n\n\tif (!sc->ip)\n\t\treturn true;\n\n\tifp = xfs_ifork_ptr(sc->ip, XFS_ATTR_FORK);\n\tif (!ifp)\n\t\treturn false;\n\n\treturn xfs_ifork_has_extents(ifp);\n}\n\n \nstatic int\nxchk_setup_xattr_buf(\n\tstruct xfs_scrub\t*sc,\n\tsize_t\t\t\tvalue_size)\n{\n\tsize_t\t\t\tbmp_sz;\n\tstruct xchk_xattr_buf\t*ab = sc->buf;\n\tvoid\t\t\t*new_val;\n\n\tbmp_sz = sizeof(long) * BITS_TO_LONGS(sc->mp->m_attr_geo->blksize);\n\n\tif (ab)\n\t\tgoto resize_value;\n\n\tab = kvzalloc(sizeof(struct xchk_xattr_buf), XCHK_GFP_FLAGS);\n\tif (!ab)\n\t\treturn -ENOMEM;\n\tsc->buf = ab;\n\tsc->buf_cleanup = xchk_xattr_buf_cleanup;\n\n\tab->usedmap = kvmalloc(bmp_sz, XCHK_GFP_FLAGS);\n\tif (!ab->usedmap)\n\t\treturn -ENOMEM;\n\n\tif (xchk_xattr_want_freemap(sc)) {\n\t\tab->freemap = kvmalloc(bmp_sz, XCHK_GFP_FLAGS);\n\t\tif (!ab->freemap)\n\t\t\treturn -ENOMEM;\n\t}\n\nresize_value:\n\tif (ab->value_sz >= value_size)\n\t\treturn 0;\n\n\tif (ab->value) {\n\t\tkvfree(ab->value);\n\t\tab->value = NULL;\n\t\tab->value_sz = 0;\n\t}\n\n\tnew_val = kvmalloc(value_size, XCHK_GFP_FLAGS);\n\tif (!new_val)\n\t\treturn -ENOMEM;\n\n\tab->value = new_val;\n\tab->value_sz = value_size;\n\treturn 0;\n}\n\n \nint\nxchk_setup_xattr(\n\tstruct xfs_scrub\t*sc)\n{\n\tint\t\t\terror;\n\n\t \n\tif (sc->flags & XCHK_TRY_HARDER) {\n\t\terror = xchk_setup_xattr_buf(sc, XATTR_SIZE_MAX);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn xchk_setup_inode_contents(sc, 0);\n}\n\n \n\nstruct xchk_xattr {\n\tstruct xfs_attr_list_context\tcontext;\n\tstruct xfs_scrub\t\t*sc;\n};\n\n \nstatic void\nxchk_xattr_listent(\n\tstruct xfs_attr_list_context\t*context,\n\tint\t\t\t\tflags,\n\tunsigned char\t\t\t*name,\n\tint\t\t\t\tnamelen,\n\tint\t\t\t\tvaluelen)\n{\n\tstruct xfs_da_args\t\targs = {\n\t\t.op_flags\t\t= XFS_DA_OP_NOTIME,\n\t\t.attr_filter\t\t= flags & XFS_ATTR_NSP_ONDISK_MASK,\n\t\t.geo\t\t\t= context->dp->i_mount->m_attr_geo,\n\t\t.whichfork\t\t= XFS_ATTR_FORK,\n\t\t.dp\t\t\t= context->dp,\n\t\t.name\t\t\t= name,\n\t\t.namelen\t\t= namelen,\n\t\t.hashval\t\t= xfs_da_hashname(name, namelen),\n\t\t.trans\t\t\t= context->tp,\n\t\t.valuelen\t\t= valuelen,\n\t};\n\tstruct xchk_xattr_buf\t\t*ab;\n\tstruct xchk_xattr\t\t*sx;\n\tint\t\t\t\terror = 0;\n\n\tsx = container_of(context, struct xchk_xattr, context);\n\tab = sx->sc->buf;\n\n\tif (xchk_should_terminate(sx->sc, &error)) {\n\t\tcontext->seen_enough = error;\n\t\treturn;\n\t}\n\n\tif (flags & XFS_ATTR_INCOMPLETE) {\n\t\t \n\t\txchk_ino_set_preen(sx->sc, context->dp->i_ino);\n\t\treturn;\n\t}\n\n\t \n\tif (hweight32(flags & XFS_ATTR_NSP_ONDISK_MASK) > 1) {\n\t\txchk_fblock_set_corrupt(sx->sc, XFS_ATTR_FORK, args.blkno);\n\t\tgoto fail_xref;\n\t}\n\n\t \n\tif (!xfs_attr_namecheck(name, namelen)) {\n\t\txchk_fblock_set_corrupt(sx->sc, XFS_ATTR_FORK, args.blkno);\n\t\tgoto fail_xref;\n\t}\n\n\t \n\tif (flags & XFS_ATTR_LOCAL)\n\t\tgoto fail_xref;\n\n\t \n\terror = xchk_setup_xattr_buf(sx->sc, valuelen);\n\tif (error == -ENOMEM)\n\t\terror = -EDEADLOCK;\n\tif (error) {\n\t\tcontext->seen_enough = error;\n\t\treturn;\n\t}\n\n\targs.value = ab->value;\n\n\terror = xfs_attr_get_ilocked(&args);\n\t \n\tif (error == -ENODATA)\n\t\terror = -EFSCORRUPTED;\n\tif (!xchk_fblock_process_error(sx->sc, XFS_ATTR_FORK, args.blkno,\n\t\t\t&error))\n\t\tgoto fail_xref;\n\tif (args.valuelen != valuelen)\n\t\txchk_fblock_set_corrupt(sx->sc, XFS_ATTR_FORK,\n\t\t\t\t\t     args.blkno);\nfail_xref:\n\tif (sx->sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\tcontext->seen_enough = 1;\n\treturn;\n}\n\n \nSTATIC bool\nxchk_xattr_set_map(\n\tstruct xfs_scrub\t*sc,\n\tunsigned long\t\t*map,\n\tunsigned int\t\tstart,\n\tunsigned int\t\tlen)\n{\n\tunsigned int\t\tmapsize = sc->mp->m_attr_geo->blksize;\n\tbool\t\t\tret = true;\n\n\tif (start >= mapsize)\n\t\treturn false;\n\tif (start + len > mapsize) {\n\t\tlen = mapsize - start;\n\t\tret = false;\n\t}\n\n\tif (find_next_bit(map, mapsize, start) < start + len)\n\t\tret = false;\n\tbitmap_set(map, start, len);\n\n\treturn ret;\n}\n\n \nSTATIC bool\nxchk_xattr_check_freemap(\n\tstruct xfs_scrub\t\t*sc,\n\tstruct xfs_attr3_icleaf_hdr\t*leafhdr)\n{\n\tstruct xchk_xattr_buf\t\t*ab = sc->buf;\n\tunsigned int\t\t\tmapsize = sc->mp->m_attr_geo->blksize;\n\tint\t\t\t\ti;\n\n\t \n\tbitmap_zero(ab->freemap, mapsize);\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tif (!xchk_xattr_set_map(sc, ab->freemap,\n\t\t\t\tleafhdr->freemap[i].base,\n\t\t\t\tleafhdr->freemap[i].size))\n\t\t\treturn false;\n\t}\n\n\t \n\treturn !bitmap_intersects(ab->freemap, ab->usedmap, mapsize);\n}\n\n \nSTATIC void\nxchk_xattr_entry(\n\tstruct xchk_da_btree\t\t*ds,\n\tint\t\t\t\tlevel,\n\tchar\t\t\t\t*buf_end,\n\tstruct xfs_attr_leafblock\t*leaf,\n\tstruct xfs_attr3_icleaf_hdr\t*leafhdr,\n\tstruct xfs_attr_leaf_entry\t*ent,\n\tint\t\t\t\tidx,\n\tunsigned int\t\t\t*usedbytes,\n\t__u32\t\t\t\t*last_hashval)\n{\n\tstruct xfs_mount\t\t*mp = ds->state->mp;\n\tstruct xchk_xattr_buf\t\t*ab = ds->sc->buf;\n\tchar\t\t\t\t*name_end;\n\tstruct xfs_attr_leaf_name_local\t*lentry;\n\tstruct xfs_attr_leaf_name_remote *rentry;\n\tunsigned int\t\t\tnameidx;\n\tunsigned int\t\t\tnamesize;\n\n\tif (ent->pad2 != 0)\n\t\txchk_da_set_corrupt(ds, level);\n\n\t \n\tif (be32_to_cpu(ent->hashval) < *last_hashval)\n\t\txchk_da_set_corrupt(ds, level);\n\t*last_hashval = be32_to_cpu(ent->hashval);\n\n\tnameidx = be16_to_cpu(ent->nameidx);\n\tif (nameidx < leafhdr->firstused ||\n\t    nameidx >= mp->m_attr_geo->blksize) {\n\t\txchk_da_set_corrupt(ds, level);\n\t\treturn;\n\t}\n\n\t \n\tif (ent->flags & XFS_ATTR_LOCAL) {\n\t\tlentry = xfs_attr3_leaf_name_local(leaf, idx);\n\t\tnamesize = xfs_attr_leaf_entsize_local(lentry->namelen,\n\t\t\t\tbe16_to_cpu(lentry->valuelen));\n\t\tname_end = (char *)lentry + namesize;\n\t\tif (lentry->namelen == 0)\n\t\t\txchk_da_set_corrupt(ds, level);\n\t} else {\n\t\trentry = xfs_attr3_leaf_name_remote(leaf, idx);\n\t\tnamesize = xfs_attr_leaf_entsize_remote(rentry->namelen);\n\t\tname_end = (char *)rentry + namesize;\n\t\tif (rentry->namelen == 0 || rentry->valueblk == 0)\n\t\t\txchk_da_set_corrupt(ds, level);\n\t}\n\tif (name_end > buf_end)\n\t\txchk_da_set_corrupt(ds, level);\n\n\tif (!xchk_xattr_set_map(ds->sc, ab->usedmap, nameidx, namesize))\n\t\txchk_da_set_corrupt(ds, level);\n\tif (!(ds->sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT))\n\t\t*usedbytes += namesize;\n}\n\n \nSTATIC int\nxchk_xattr_block(\n\tstruct xchk_da_btree\t\t*ds,\n\tint\t\t\t\tlevel)\n{\n\tstruct xfs_attr3_icleaf_hdr\tleafhdr;\n\tstruct xfs_mount\t\t*mp = ds->state->mp;\n\tstruct xfs_da_state_blk\t\t*blk = &ds->state->path.blk[level];\n\tstruct xfs_buf\t\t\t*bp = blk->bp;\n\txfs_dablk_t\t\t\t*last_checked = ds->private;\n\tstruct xfs_attr_leafblock\t*leaf = bp->b_addr;\n\tstruct xfs_attr_leaf_entry\t*ent;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\tstruct xchk_xattr_buf\t\t*ab = ds->sc->buf;\n\tchar\t\t\t\t*buf_end;\n\tsize_t\t\t\t\toff;\n\t__u32\t\t\t\tlast_hashval = 0;\n\tunsigned int\t\t\tusedbytes = 0;\n\tunsigned int\t\t\thdrsize;\n\tint\t\t\t\ti;\n\n\tif (*last_checked == blk->blkno)\n\t\treturn 0;\n\n\t*last_checked = blk->blkno;\n\tbitmap_zero(ab->usedmap, mp->m_attr_geo->blksize);\n\n\t \n\tif (xfs_has_crc(ds->sc->mp)) {\n\t\tstruct xfs_attr3_leafblock\t*leaf3 = bp->b_addr;\n\n\t\tif (leaf3->hdr.pad1 != 0 || leaf3->hdr.pad2 != 0 ||\n\t\t    leaf3->hdr.info.hdr.pad != 0)\n\t\t\txchk_da_set_corrupt(ds, level);\n\t} else {\n\t\tif (leaf->hdr.pad1 != 0 || leaf->hdr.info.pad != 0)\n\t\t\txchk_da_set_corrupt(ds, level);\n\t}\n\n\t \n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &leafhdr, leaf);\n\thdrsize = xfs_attr3_leaf_hdr_size(leaf);\n\n\tif (leafhdr.usedbytes > mp->m_attr_geo->blksize)\n\t\txchk_da_set_corrupt(ds, level);\n\tif (leafhdr.firstused > mp->m_attr_geo->blksize)\n\t\txchk_da_set_corrupt(ds, level);\n\tif (leafhdr.firstused < hdrsize)\n\t\txchk_da_set_corrupt(ds, level);\n\tif (!xchk_xattr_set_map(ds->sc, ab->usedmap, 0, hdrsize))\n\t\txchk_da_set_corrupt(ds, level);\n\n\tif (ds->sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\tgoto out;\n\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tif ((char *)&entries[leafhdr.count] > (char *)leaf + leafhdr.firstused)\n\t\txchk_da_set_corrupt(ds, level);\n\n\tbuf_end = (char *)bp->b_addr + mp->m_attr_geo->blksize;\n\tfor (i = 0, ent = entries; i < leafhdr.count; ent++, i++) {\n\t\t \n\t\toff = (char *)ent - (char *)leaf;\n\t\tif (!xchk_xattr_set_map(ds->sc, ab->usedmap, off,\n\t\t\t\tsizeof(xfs_attr_leaf_entry_t))) {\n\t\t\txchk_da_set_corrupt(ds, level);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\txchk_xattr_entry(ds, level, buf_end, leaf, &leafhdr,\n\t\t\t\tent, i, &usedbytes, &last_hashval);\n\n\t\tif (ds->sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\t\tgoto out;\n\t}\n\n\tif (!xchk_xattr_check_freemap(ds->sc, &leafhdr))\n\t\txchk_da_set_corrupt(ds, level);\n\n\tif (leafhdr.usedbytes != usedbytes)\n\t\txchk_da_set_corrupt(ds, level);\n\nout:\n\treturn 0;\n}\n\n \nSTATIC int\nxchk_xattr_rec(\n\tstruct xchk_da_btree\t\t*ds,\n\tint\t\t\t\tlevel)\n{\n\tstruct xfs_mount\t\t*mp = ds->state->mp;\n\tstruct xfs_da_state_blk\t\t*blk = &ds->state->path.blk[level];\n\tstruct xfs_attr_leaf_name_local\t*lentry;\n\tstruct xfs_attr_leaf_name_remote\t*rentry;\n\tstruct xfs_buf\t\t\t*bp;\n\tstruct xfs_attr_leaf_entry\t*ent;\n\txfs_dahash_t\t\t\tcalc_hash;\n\txfs_dahash_t\t\t\thash;\n\tint\t\t\t\tnameidx;\n\tint\t\t\t\thdrsize;\n\tunsigned int\t\t\tbadflags;\n\tint\t\t\t\terror;\n\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\n\tent = xfs_attr3_leaf_entryp(blk->bp->b_addr) + blk->index;\n\n\t \n\terror = xchk_xattr_block(ds, level);\n\tif (error)\n\t\tgoto out;\n\tif (ds->sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\tgoto out;\n\n\t \n\terror = xchk_da_btree_hash(ds, level, &ent->hashval);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tbp = blk->bp;\n\thdrsize = xfs_attr3_leaf_hdr_size(bp->b_addr);\n\tnameidx = be16_to_cpu(ent->nameidx);\n\tif (nameidx < hdrsize || nameidx >= mp->m_attr_geo->blksize) {\n\t\txchk_da_set_corrupt(ds, level);\n\t\tgoto out;\n\t}\n\n\t \n\thash = be32_to_cpu(ent->hashval);\n\tbadflags = ~(XFS_ATTR_LOCAL | XFS_ATTR_ROOT | XFS_ATTR_SECURE |\n\t\t\tXFS_ATTR_INCOMPLETE);\n\tif ((ent->flags & badflags) != 0)\n\t\txchk_da_set_corrupt(ds, level);\n\tif (ent->flags & XFS_ATTR_LOCAL) {\n\t\tlentry = (struct xfs_attr_leaf_name_local *)\n\t\t\t\t(((char *)bp->b_addr) + nameidx);\n\t\tif (lentry->namelen <= 0) {\n\t\t\txchk_da_set_corrupt(ds, level);\n\t\t\tgoto out;\n\t\t}\n\t\tcalc_hash = xfs_da_hashname(lentry->nameval, lentry->namelen);\n\t} else {\n\t\trentry = (struct xfs_attr_leaf_name_remote *)\n\t\t\t\t(((char *)bp->b_addr) + nameidx);\n\t\tif (rentry->namelen <= 0) {\n\t\t\txchk_da_set_corrupt(ds, level);\n\t\t\tgoto out;\n\t\t}\n\t\tcalc_hash = xfs_da_hashname(rentry->name, rentry->namelen);\n\t}\n\tif (calc_hash != hash)\n\t\txchk_da_set_corrupt(ds, level);\n\nout:\n\treturn error;\n}\n\n \nSTATIC int\nxchk_xattr_check_sf(\n\tstruct xfs_scrub\t\t*sc)\n{\n\tstruct xchk_xattr_buf\t\t*ab = sc->buf;\n\tstruct xfs_attr_shortform\t*sf;\n\tstruct xfs_attr_sf_entry\t*sfe;\n\tstruct xfs_attr_sf_entry\t*next;\n\tstruct xfs_ifork\t\t*ifp;\n\tunsigned char\t\t\t*end;\n\tint\t\t\t\ti;\n\tint\t\t\t\terror = 0;\n\n\tifp = xfs_ifork_ptr(sc->ip, XFS_ATTR_FORK);\n\n\tbitmap_zero(ab->usedmap, ifp->if_bytes);\n\tsf = (struct xfs_attr_shortform *)sc->ip->i_af.if_u1.if_data;\n\tend = (unsigned char *)ifp->if_u1.if_data + ifp->if_bytes;\n\txchk_xattr_set_map(sc, ab->usedmap, 0, sizeof(sf->hdr));\n\n\tsfe = &sf->list[0];\n\tif ((unsigned char *)sfe > end) {\n\t\txchk_fblock_set_corrupt(sc, XFS_ATTR_FORK, 0);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < sf->hdr.count; i++) {\n\t\tunsigned char\t\t*name = sfe->nameval;\n\t\tunsigned char\t\t*value = &sfe->nameval[sfe->namelen];\n\n\t\tif (xchk_should_terminate(sc, &error))\n\t\t\treturn error;\n\n\t\tnext = xfs_attr_sf_nextentry(sfe);\n\t\tif ((unsigned char *)next > end) {\n\t\t\txchk_fblock_set_corrupt(sc, XFS_ATTR_FORK, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!xchk_xattr_set_map(sc, ab->usedmap,\n\t\t\t\t(char *)sfe - (char *)sf,\n\t\t\t\tsizeof(struct xfs_attr_sf_entry))) {\n\t\t\txchk_fblock_set_corrupt(sc, XFS_ATTR_FORK, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!xchk_xattr_set_map(sc, ab->usedmap,\n\t\t\t\t(char *)name - (char *)sf,\n\t\t\t\tsfe->namelen)) {\n\t\t\txchk_fblock_set_corrupt(sc, XFS_ATTR_FORK, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!xchk_xattr_set_map(sc, ab->usedmap,\n\t\t\t\t(char *)value - (char *)sf,\n\t\t\t\tsfe->valuelen)) {\n\t\t\txchk_fblock_set_corrupt(sc, XFS_ATTR_FORK, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tsfe = next;\n\t}\n\n\treturn 0;\n}\n\n \nint\nxchk_xattr(\n\tstruct xfs_scrub\t\t*sc)\n{\n\tstruct xchk_xattr\t\tsx = {\n\t\t.sc\t\t\t= sc,\n\t\t.context\t\t= {\n\t\t\t.dp\t\t= sc->ip,\n\t\t\t.tp\t\t= sc->tp,\n\t\t\t.resynch\t= 1,\n\t\t\t.put_listent\t= xchk_xattr_listent,\n\t\t\t.allow_incomplete = true,\n\t\t},\n\t};\n\txfs_dablk_t\t\t\tlast_checked = -1U;\n\tint\t\t\t\terror = 0;\n\n\tif (!xfs_inode_hasattr(sc->ip))\n\t\treturn -ENOENT;\n\n\t \n\terror = xchk_setup_xattr_buf(sc, 0);\n\tif (error == -ENOMEM)\n\t\treturn -EDEADLOCK;\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (sc->ip->i_af.if_format == XFS_DINODE_FMT_LOCAL)\n\t\terror = xchk_xattr_check_sf(sc);\n\telse\n\t\terror = xchk_da_btree(sc, XFS_ATTR_FORK, xchk_xattr_rec,\n\t\t\t\t&last_checked);\n\tif (error)\n\t\treturn error;\n\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn 0;\n\n\t \n\terror = xfs_attr_list_ilocked(&sx.context);\n\tif (!xchk_fblock_process_error(sc, XFS_ATTR_FORK, 0, &error))\n\t\treturn error;\n\n\t \n\tif (sx.context.seen_enough < 0)\n\t\treturn sx.context.seen_enough;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}