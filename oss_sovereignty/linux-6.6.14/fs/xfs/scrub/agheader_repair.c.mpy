{
  "module_name": "agheader_repair.c",
  "hash_id": "a24c55c6100e2ca61ffb55060a291f69015ca554d05be38ab743c614a295b4f8",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/agheader_repair.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_rmap_btree.h\"\n#include \"xfs_refcount_btree.h\"\n#include \"xfs_ag.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/common.h\"\n#include \"scrub/trace.h\"\n#include \"scrub/repair.h\"\n#include \"scrub/bitmap.h\"\n#include \"scrub/reap.h\"\n\n \n\n \nint\nxrep_superblock(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\tstruct xfs_buf\t\t*bp;\n\txfs_agnumber_t\t\tagno;\n\tint\t\t\terror;\n\n\t \n\tagno = sc->sm->sm_agno;\n\tif (agno == 0)\n\t\treturn -EOPNOTSUPP;\n\n\terror = xfs_sb_get_secondary(mp, sc->tp, agno, &bp);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (xchk_should_terminate(sc, &error))\n\t\treturn error;\n\n\t \n\txfs_buf_zero(bp, 0, BBTOB(bp->b_length));\n\txfs_sb_to_disk(bp->b_addr, &mp->m_sb);\n\n\t \n\tif (xfs_has_crc(mp)) {\n\t\tstruct xfs_dsb\t\t*sb = bp->b_addr;\n\n\t\tsb->sb_features_incompat &=\n\t\t\t\t~cpu_to_be32(XFS_SB_FEAT_INCOMPAT_NEEDSREPAIR);\n\t\tsb->sb_features_log_incompat = 0;\n\t}\n\n\t \n\txfs_trans_buf_set_type(sc->tp, bp, XFS_BLFT_SB_BUF);\n\txfs_trans_log_buf(sc->tp, bp, 0, BBTOB(bp->b_length) - 1);\n\treturn error;\n}\n\n \n\nstruct xrep_agf_allocbt {\n\tstruct xfs_scrub\t*sc;\n\txfs_agblock_t\t\tfreeblks;\n\txfs_agblock_t\t\tlongest;\n};\n\n \nSTATIC int\nxrep_agf_walk_allocbt(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst struct xfs_alloc_rec_incore *rec,\n\tvoid\t\t\t\t*priv)\n{\n\tstruct xrep_agf_allocbt\t\t*raa = priv;\n\tint\t\t\t\terror = 0;\n\n\tif (xchk_should_terminate(raa->sc, &error))\n\t\treturn error;\n\n\traa->freeblks += rec->ar_blockcount;\n\tif (rec->ar_blockcount > raa->longest)\n\t\traa->longest = rec->ar_blockcount;\n\treturn error;\n}\n\n \nSTATIC int\nxrep_agf_check_agfl_block(\n\tstruct xfs_mount\t*mp,\n\txfs_agblock_t\t\tagbno,\n\tvoid\t\t\t*priv)\n{\n\tstruct xfs_scrub\t*sc = priv;\n\n\tif (!xfs_verify_agbno(sc->sa.pag, agbno))\n\t\treturn -EFSCORRUPTED;\n\treturn 0;\n}\n\n \nenum {\n\tXREP_AGF_BNOBT = 0,\n\tXREP_AGF_CNTBT,\n\tXREP_AGF_RMAPBT,\n\tXREP_AGF_REFCOUNTBT,\n\tXREP_AGF_END,\n\tXREP_AGF_MAX\n};\n\n \nstatic inline bool\nxrep_check_btree_root(\n\tstruct xfs_scrub\t\t*sc,\n\tstruct xrep_find_ag_btree\t*fab)\n{\n\treturn xfs_verify_agbno(sc->sa.pag, fab->root) &&\n\t       fab->height <= fab->maxlevels;\n}\n\n \nSTATIC int\nxrep_agf_find_btrees(\n\tstruct xfs_scrub\t\t*sc,\n\tstruct xfs_buf\t\t\t*agf_bp,\n\tstruct xrep_find_ag_btree\t*fab,\n\tstruct xfs_buf\t\t\t*agfl_bp)\n{\n\tstruct xfs_agf\t\t\t*old_agf = agf_bp->b_addr;\n\tint\t\t\t\terror;\n\n\t \n\terror = xrep_find_ag_btree_roots(sc, agf_bp, fab, agfl_bp);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (!xrep_check_btree_root(sc, &fab[XREP_AGF_BNOBT]) ||\n\t    !xrep_check_btree_root(sc, &fab[XREP_AGF_CNTBT]) ||\n\t    !xrep_check_btree_root(sc, &fab[XREP_AGF_RMAPBT]))\n\t\treturn -EFSCORRUPTED;\n\n\t \n\tif (fab[XREP_AGF_RMAPBT].root !=\n\t    be32_to_cpu(old_agf->agf_roots[XFS_BTNUM_RMAPi]))\n\t\treturn -EFSCORRUPTED;\n\n\t \n\tif (xfs_has_reflink(sc->mp) &&\n\t    !xrep_check_btree_root(sc, &fab[XREP_AGF_REFCOUNTBT]))\n\t\treturn -EFSCORRUPTED;\n\n\treturn 0;\n}\n\n \nSTATIC void\nxrep_agf_init_header(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_buf\t\t*agf_bp,\n\tstruct xfs_agf\t\t*old_agf)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\tstruct xfs_perag\t*pag = sc->sa.pag;\n\tstruct xfs_agf\t\t*agf = agf_bp->b_addr;\n\n\tmemcpy(old_agf, agf, sizeof(*old_agf));\n\tmemset(agf, 0, BBTOB(agf_bp->b_length));\n\tagf->agf_magicnum = cpu_to_be32(XFS_AGF_MAGIC);\n\tagf->agf_versionnum = cpu_to_be32(XFS_AGF_VERSION);\n\tagf->agf_seqno = cpu_to_be32(pag->pag_agno);\n\tagf->agf_length = cpu_to_be32(pag->block_count);\n\tagf->agf_flfirst = old_agf->agf_flfirst;\n\tagf->agf_fllast = old_agf->agf_fllast;\n\tagf->agf_flcount = old_agf->agf_flcount;\n\tif (xfs_has_crc(mp))\n\t\tuuid_copy(&agf->agf_uuid, &mp->m_sb.sb_meta_uuid);\n\n\t \n\tASSERT(xfs_perag_initialised_agf(pag));\n\tclear_bit(XFS_AGSTATE_AGF_INIT, &pag->pag_opstate);\n}\n\n \nSTATIC void\nxrep_agf_set_roots(\n\tstruct xfs_scrub\t\t*sc,\n\tstruct xfs_agf\t\t\t*agf,\n\tstruct xrep_find_ag_btree\t*fab)\n{\n\tagf->agf_roots[XFS_BTNUM_BNOi] =\n\t\t\tcpu_to_be32(fab[XREP_AGF_BNOBT].root);\n\tagf->agf_levels[XFS_BTNUM_BNOi] =\n\t\t\tcpu_to_be32(fab[XREP_AGF_BNOBT].height);\n\n\tagf->agf_roots[XFS_BTNUM_CNTi] =\n\t\t\tcpu_to_be32(fab[XREP_AGF_CNTBT].root);\n\tagf->agf_levels[XFS_BTNUM_CNTi] =\n\t\t\tcpu_to_be32(fab[XREP_AGF_CNTBT].height);\n\n\tagf->agf_roots[XFS_BTNUM_RMAPi] =\n\t\t\tcpu_to_be32(fab[XREP_AGF_RMAPBT].root);\n\tagf->agf_levels[XFS_BTNUM_RMAPi] =\n\t\t\tcpu_to_be32(fab[XREP_AGF_RMAPBT].height);\n\n\tif (xfs_has_reflink(sc->mp)) {\n\t\tagf->agf_refcount_root =\n\t\t\t\tcpu_to_be32(fab[XREP_AGF_REFCOUNTBT].root);\n\t\tagf->agf_refcount_level =\n\t\t\t\tcpu_to_be32(fab[XREP_AGF_REFCOUNTBT].height);\n\t}\n}\n\n \nSTATIC int\nxrep_agf_calc_from_btrees(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_buf\t\t*agf_bp)\n{\n\tstruct xrep_agf_allocbt\traa = { .sc = sc };\n\tstruct xfs_btree_cur\t*cur = NULL;\n\tstruct xfs_agf\t\t*agf = agf_bp->b_addr;\n\tstruct xfs_mount\t*mp = sc->mp;\n\txfs_agblock_t\t\tbtreeblks;\n\txfs_agblock_t\t\tblocks;\n\tint\t\t\terror;\n\n\t \n\tcur = xfs_allocbt_init_cursor(mp, sc->tp, agf_bp,\n\t\t\tsc->sa.pag, XFS_BTNUM_BNO);\n\terror = xfs_alloc_query_all(cur, xrep_agf_walk_allocbt, &raa);\n\tif (error)\n\t\tgoto err;\n\terror = xfs_btree_count_blocks(cur, &blocks);\n\tif (error)\n\t\tgoto err;\n\txfs_btree_del_cursor(cur, error);\n\tbtreeblks = blocks - 1;\n\tagf->agf_freeblks = cpu_to_be32(raa.freeblks);\n\tagf->agf_longest = cpu_to_be32(raa.longest);\n\n\t \n\tcur = xfs_allocbt_init_cursor(mp, sc->tp, agf_bp,\n\t\t\tsc->sa.pag, XFS_BTNUM_CNT);\n\terror = xfs_btree_count_blocks(cur, &blocks);\n\tif (error)\n\t\tgoto err;\n\txfs_btree_del_cursor(cur, error);\n\tbtreeblks += blocks - 1;\n\n\t \n\tcur = xfs_rmapbt_init_cursor(mp, sc->tp, agf_bp, sc->sa.pag);\n\terror = xfs_btree_count_blocks(cur, &blocks);\n\tif (error)\n\t\tgoto err;\n\txfs_btree_del_cursor(cur, error);\n\tagf->agf_rmap_blocks = cpu_to_be32(blocks);\n\tbtreeblks += blocks - 1;\n\n\tagf->agf_btreeblks = cpu_to_be32(btreeblks);\n\n\t \n\tif (xfs_has_reflink(mp)) {\n\t\tcur = xfs_refcountbt_init_cursor(mp, sc->tp, agf_bp,\n\t\t\t\tsc->sa.pag);\n\t\terror = xfs_btree_count_blocks(cur, &blocks);\n\t\tif (error)\n\t\t\tgoto err;\n\t\txfs_btree_del_cursor(cur, error);\n\t\tagf->agf_refcount_blocks = cpu_to_be32(blocks);\n\t}\n\n\treturn 0;\nerr:\n\txfs_btree_del_cursor(cur, error);\n\treturn error;\n}\n\n \nSTATIC int\nxrep_agf_commit_new(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_buf\t\t*agf_bp)\n{\n\tstruct xfs_perag\t*pag;\n\tstruct xfs_agf\t\t*agf = agf_bp->b_addr;\n\n\t \n\txfs_force_summary_recalc(sc->mp);\n\n\t \n\txfs_trans_buf_set_type(sc->tp, agf_bp, XFS_BLFT_AGF_BUF);\n\txfs_trans_log_buf(sc->tp, agf_bp, 0, BBTOB(agf_bp->b_length) - 1);\n\n\t \n\tpag = sc->sa.pag;\n\tpag->pagf_btreeblks = be32_to_cpu(agf->agf_btreeblks);\n\tpag->pagf_freeblks = be32_to_cpu(agf->agf_freeblks);\n\tpag->pagf_longest = be32_to_cpu(agf->agf_longest);\n\tpag->pagf_levels[XFS_BTNUM_BNOi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]);\n\tpag->pagf_levels[XFS_BTNUM_CNTi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]);\n\tpag->pagf_levels[XFS_BTNUM_RMAPi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAPi]);\n\tpag->pagf_refcount_level = be32_to_cpu(agf->agf_refcount_level);\n\tset_bit(XFS_AGSTATE_AGF_INIT, &pag->pag_opstate);\n\n\treturn 0;\n}\n\n \nint\nxrep_agf(\n\tstruct xfs_scrub\t\t*sc)\n{\n\tstruct xrep_find_ag_btree\tfab[XREP_AGF_MAX] = {\n\t\t[XREP_AGF_BNOBT] = {\n\t\t\t.rmap_owner = XFS_RMAP_OWN_AG,\n\t\t\t.buf_ops = &xfs_bnobt_buf_ops,\n\t\t\t.maxlevels = sc->mp->m_alloc_maxlevels,\n\t\t},\n\t\t[XREP_AGF_CNTBT] = {\n\t\t\t.rmap_owner = XFS_RMAP_OWN_AG,\n\t\t\t.buf_ops = &xfs_cntbt_buf_ops,\n\t\t\t.maxlevels = sc->mp->m_alloc_maxlevels,\n\t\t},\n\t\t[XREP_AGF_RMAPBT] = {\n\t\t\t.rmap_owner = XFS_RMAP_OWN_AG,\n\t\t\t.buf_ops = &xfs_rmapbt_buf_ops,\n\t\t\t.maxlevels = sc->mp->m_rmap_maxlevels,\n\t\t},\n\t\t[XREP_AGF_REFCOUNTBT] = {\n\t\t\t.rmap_owner = XFS_RMAP_OWN_REFC,\n\t\t\t.buf_ops = &xfs_refcountbt_buf_ops,\n\t\t\t.maxlevels = sc->mp->m_refc_maxlevels,\n\t\t},\n\t\t[XREP_AGF_END] = {\n\t\t\t.buf_ops = NULL,\n\t\t},\n\t};\n\tstruct xfs_agf\t\t\told_agf;\n\tstruct xfs_mount\t\t*mp = sc->mp;\n\tstruct xfs_buf\t\t\t*agf_bp;\n\tstruct xfs_buf\t\t\t*agfl_bp;\n\tstruct xfs_agf\t\t\t*agf;\n\tint\t\t\t\terror;\n\n\t \n\tif (!xfs_has_rmapbt(mp))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\terror = xfs_trans_read_buf(mp, sc->tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, sc->sa.pag->pag_agno,\n\t\t\t\t\t\tXFS_AGF_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &agf_bp, NULL);\n\tif (error)\n\t\treturn error;\n\tagf_bp->b_ops = &xfs_agf_buf_ops;\n\tagf = agf_bp->b_addr;\n\n\t \n\terror = xfs_alloc_read_agfl(sc->sa.pag, sc->tp, &agfl_bp);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = xfs_agfl_walk(sc->mp, agf_bp->b_addr, agfl_bp,\n\t\t\txrep_agf_check_agfl_block, sc);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = xrep_agf_find_btrees(sc, agf_bp, fab, agfl_bp);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (xchk_should_terminate(sc, &error))\n\t\treturn error;\n\n\t \n\txrep_agf_init_header(sc, agf_bp, &old_agf);\n\txrep_agf_set_roots(sc, agf, fab);\n\terror = xrep_agf_calc_from_btrees(sc, agf_bp);\n\tif (error)\n\t\tgoto out_revert;\n\n\t \n\treturn xrep_agf_commit_new(sc, agf_bp);\n\nout_revert:\n\t \n\tclear_bit(XFS_AGSTATE_AGF_INIT, &sc->sa.pag->pag_opstate);\n\tmemcpy(agf, &old_agf, sizeof(old_agf));\n\treturn error;\n}\n\n \n\nstruct xrep_agfl {\n\t \n\tstruct xagb_bitmap\tcrossed;\n\n\t \n\tstruct xagb_bitmap\tagmetablocks;\n\n\t \n\tstruct xagb_bitmap\t*freesp;\n\n\t \n\tstruct xfs_btree_cur\t*rmap_cur;\n\n\tstruct xfs_scrub\t*sc;\n};\n\n \nSTATIC int\nxrep_agfl_walk_rmap(\n\tstruct xfs_btree_cur\t*cur,\n\tconst struct xfs_rmap_irec *rec,\n\tvoid\t\t\t*priv)\n{\n\tstruct xrep_agfl\t*ra = priv;\n\tint\t\t\terror = 0;\n\n\tif (xchk_should_terminate(ra->sc, &error))\n\t\treturn error;\n\n\t \n\tif (rec->rm_owner == XFS_RMAP_OWN_AG) {\n\t\terror = xagb_bitmap_set(ra->freesp, rec->rm_startblock,\n\t\t\t\trec->rm_blockcount);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn xagb_bitmap_set_btcur_path(&ra->agmetablocks, cur);\n}\n\n \nSTATIC int\nxrep_agfl_check_extent(\n\tuint64_t\t\tstart,\n\tuint64_t\t\tlen,\n\tvoid\t\t\t*priv)\n{\n\tstruct xrep_agfl\t*ra = priv;\n\txfs_agblock_t\t\tagbno = start;\n\txfs_agblock_t\t\tlast_agbno = agbno + len - 1;\n\tint\t\t\terror;\n\n\twhile (agbno <= last_agbno) {\n\t\tbool\t\tother_owners;\n\n\t\terror = xfs_rmap_has_other_keys(ra->rmap_cur, agbno, 1,\n\t\t\t\t&XFS_RMAP_OINFO_AG, &other_owners);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (other_owners) {\n\t\t\terror = xagb_bitmap_set(&ra->crossed, agbno, 1);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (xchk_should_terminate(ra->sc, &error))\n\t\t\treturn error;\n\t\tagbno++;\n\t}\n\n\treturn 0;\n}\n\n \nSTATIC int\nxrep_agfl_collect_blocks(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_buf\t\t*agf_bp,\n\tstruct xagb_bitmap\t*agfl_extents,\n\txfs_agblock_t\t\t*flcount)\n{\n\tstruct xrep_agfl\tra;\n\tstruct xfs_mount\t*mp = sc->mp;\n\tstruct xfs_btree_cur\t*cur;\n\tint\t\t\terror;\n\n\tra.sc = sc;\n\tra.freesp = agfl_extents;\n\txagb_bitmap_init(&ra.agmetablocks);\n\txagb_bitmap_init(&ra.crossed);\n\n\t \n\tcur = xfs_rmapbt_init_cursor(mp, sc->tp, agf_bp, sc->sa.pag);\n\terror = xfs_rmap_query_all(cur, xrep_agfl_walk_rmap, &ra);\n\txfs_btree_del_cursor(cur, error);\n\tif (error)\n\t\tgoto out_bmp;\n\n\t \n\tcur = xfs_allocbt_init_cursor(mp, sc->tp, agf_bp,\n\t\t\tsc->sa.pag, XFS_BTNUM_BNO);\n\terror = xagb_bitmap_set_btblocks(&ra.agmetablocks, cur);\n\txfs_btree_del_cursor(cur, error);\n\tif (error)\n\t\tgoto out_bmp;\n\n\t \n\tcur = xfs_allocbt_init_cursor(mp, sc->tp, agf_bp,\n\t\t\tsc->sa.pag, XFS_BTNUM_CNT);\n\terror = xagb_bitmap_set_btblocks(&ra.agmetablocks, cur);\n\txfs_btree_del_cursor(cur, error);\n\tif (error)\n\t\tgoto out_bmp;\n\n\t \n\terror = xagb_bitmap_disunion(agfl_extents, &ra.agmetablocks);\n\tif (error)\n\t\tgoto out_bmp;\n\n\t \n\tra.rmap_cur = xfs_rmapbt_init_cursor(mp, sc->tp, agf_bp, sc->sa.pag);\n\terror = xagb_bitmap_walk(agfl_extents, xrep_agfl_check_extent, &ra);\n\txfs_btree_del_cursor(ra.rmap_cur, error);\n\tif (error)\n\t\tgoto out_bmp;\n\terror = xagb_bitmap_disunion(agfl_extents, &ra.crossed);\n\tif (error)\n\t\tgoto out_bmp;\n\n\t \n\t*flcount = min_t(uint64_t, xagb_bitmap_hweight(agfl_extents),\n\t\t\t xfs_agfl_size(mp));\n\nout_bmp:\n\txagb_bitmap_destroy(&ra.crossed);\n\txagb_bitmap_destroy(&ra.agmetablocks);\n\treturn error;\n}\n\n \nSTATIC void\nxrep_agfl_update_agf(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_buf\t\t*agf_bp,\n\txfs_agblock_t\t\tflcount)\n{\n\tstruct xfs_agf\t\t*agf = agf_bp->b_addr;\n\n\tASSERT(flcount <= xfs_agfl_size(sc->mp));\n\n\t \n\txfs_force_summary_recalc(sc->mp);\n\n\t \n\tif (xfs_perag_initialised_agf(sc->sa.pag)) {\n\t\tsc->sa.pag->pagf_flcount = flcount;\n\t\tclear_bit(XFS_AGSTATE_AGFL_NEEDS_RESET,\n\t\t\t\t&sc->sa.pag->pag_opstate);\n\t}\n\tagf->agf_flfirst = cpu_to_be32(0);\n\tagf->agf_flcount = cpu_to_be32(flcount);\n\tif (flcount)\n\t\tagf->agf_fllast = cpu_to_be32(flcount - 1);\n\telse\n\t\tagf->agf_fllast = cpu_to_be32(xfs_agfl_size(sc->mp) - 1);\n\n\txfs_alloc_log_agf(sc->tp, agf_bp,\n\t\t\tXFS_AGF_FLFIRST | XFS_AGF_FLLAST | XFS_AGF_FLCOUNT);\n}\n\nstruct xrep_agfl_fill {\n\tstruct xagb_bitmap\tused_extents;\n\tstruct xfs_scrub\t*sc;\n\t__be32\t\t\t*agfl_bno;\n\txfs_agblock_t\t\tflcount;\n\tunsigned int\t\tfl_off;\n};\n\n \nstatic int\nxrep_agfl_fill(\n\tuint64_t\t\tstart,\n\tuint64_t\t\tlen,\n\tvoid\t\t\t*priv)\n{\n\tstruct xrep_agfl_fill\t*af = priv;\n\tstruct xfs_scrub\t*sc = af->sc;\n\txfs_agblock_t\t\tagbno = start;\n\tint\t\t\terror;\n\n\ttrace_xrep_agfl_insert(sc->sa.pag, agbno, len);\n\n\twhile (agbno < start + len && af->fl_off < af->flcount)\n\t\taf->agfl_bno[af->fl_off++] = cpu_to_be32(agbno++);\n\n\terror = xagb_bitmap_set(&af->used_extents, start, agbno - 1);\n\tif (error)\n\t\treturn error;\n\n\tif (af->fl_off == af->flcount)\n\t\treturn -ECANCELED;\n\n\treturn 0;\n}\n\n \nSTATIC int\nxrep_agfl_init_header(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_buf\t\t*agfl_bp,\n\tstruct xagb_bitmap\t*agfl_extents,\n\txfs_agblock_t\t\tflcount)\n{\n\tstruct xrep_agfl_fill\taf = {\n\t\t.sc\t\t= sc,\n\t\t.flcount\t= flcount,\n\t};\n\tstruct xfs_mount\t*mp = sc->mp;\n\tstruct xfs_agfl\t\t*agfl;\n\tint\t\t\terror;\n\n\tASSERT(flcount <= xfs_agfl_size(mp));\n\n\t \n\tagfl = XFS_BUF_TO_AGFL(agfl_bp);\n\tmemset(agfl, 0xFF, BBTOB(agfl_bp->b_length));\n\tagfl->agfl_magicnum = cpu_to_be32(XFS_AGFL_MAGIC);\n\tagfl->agfl_seqno = cpu_to_be32(sc->sa.pag->pag_agno);\n\tuuid_copy(&agfl->agfl_uuid, &mp->m_sb.sb_meta_uuid);\n\n\t \n\txagb_bitmap_init(&af.used_extents);\n\taf.agfl_bno = xfs_buf_to_agfl_bno(agfl_bp),\n\txagb_bitmap_walk(agfl_extents, xrep_agfl_fill, &af);\n\terror = xagb_bitmap_disunion(agfl_extents, &af.used_extents);\n\tif (error)\n\t\treturn error;\n\n\t \n\txfs_trans_buf_set_type(sc->tp, agfl_bp, XFS_BLFT_AGFL_BUF);\n\txfs_trans_log_buf(sc->tp, agfl_bp, 0, BBTOB(agfl_bp->b_length) - 1);\n\txagb_bitmap_destroy(&af.used_extents);\n\treturn 0;\n}\n\n \nint\nxrep_agfl(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xagb_bitmap\tagfl_extents;\n\tstruct xfs_mount\t*mp = sc->mp;\n\tstruct xfs_buf\t\t*agf_bp;\n\tstruct xfs_buf\t\t*agfl_bp;\n\txfs_agblock_t\t\tflcount;\n\tint\t\t\terror;\n\n\t \n\tif (!xfs_has_rmapbt(mp))\n\t\treturn -EOPNOTSUPP;\n\n\txagb_bitmap_init(&agfl_extents);\n\n\t \n\terror = xfs_alloc_read_agf(sc->sa.pag, sc->tp, 0, &agf_bp);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = xfs_trans_read_buf(mp, sc->tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, sc->sa.pag->pag_agno,\n\t\t\t\t\t\tXFS_AGFL_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &agfl_bp, NULL);\n\tif (error)\n\t\treturn error;\n\tagfl_bp->b_ops = &xfs_agfl_buf_ops;\n\n\t \n\terror = xrep_agfl_collect_blocks(sc, agf_bp, &agfl_extents, &flcount);\n\tif (error)\n\t\tgoto err;\n\n\t \n\tif (xchk_should_terminate(sc, &error))\n\t\tgoto err;\n\n\t \n\txrep_agfl_update_agf(sc, agf_bp, flcount);\n\terror = xrep_agfl_init_header(sc, agfl_bp, &agfl_extents, flcount);\n\tif (error)\n\t\tgoto err;\n\n\t \n\tsc->sa.agf_bp = agf_bp;\n\terror = xrep_roll_ag_trans(sc);\n\tif (error)\n\t\tgoto err;\n\n\t \n\terror = xrep_reap_agblocks(sc, &agfl_extents, &XFS_RMAP_OINFO_AG,\n\t\t\tXFS_AG_RESV_AGFL);\nerr:\n\txagb_bitmap_destroy(&agfl_extents);\n\treturn error;\n}\n\n \n\n \nenum {\n\tXREP_AGI_INOBT = 0,\n\tXREP_AGI_FINOBT,\n\tXREP_AGI_END,\n\tXREP_AGI_MAX\n};\n\n \nSTATIC int\nxrep_agi_find_btrees(\n\tstruct xfs_scrub\t\t*sc,\n\tstruct xrep_find_ag_btree\t*fab)\n{\n\tstruct xfs_buf\t\t\t*agf_bp;\n\tstruct xfs_mount\t\t*mp = sc->mp;\n\tint\t\t\t\terror;\n\n\t \n\terror = xfs_alloc_read_agf(sc->sa.pag, sc->tp, 0, &agf_bp);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = xrep_find_ag_btree_roots(sc, agf_bp, fab, NULL);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (!xrep_check_btree_root(sc, &fab[XREP_AGI_INOBT]))\n\t\treturn -EFSCORRUPTED;\n\n\t \n\tif (xfs_has_finobt(mp) &&\n\t    !xrep_check_btree_root(sc, &fab[XREP_AGI_FINOBT]))\n\t\treturn -EFSCORRUPTED;\n\n\treturn 0;\n}\n\n \nSTATIC void\nxrep_agi_init_header(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_buf\t\t*agi_bp,\n\tstruct xfs_agi\t\t*old_agi)\n{\n\tstruct xfs_agi\t\t*agi = agi_bp->b_addr;\n\tstruct xfs_perag\t*pag = sc->sa.pag;\n\tstruct xfs_mount\t*mp = sc->mp;\n\n\tmemcpy(old_agi, agi, sizeof(*old_agi));\n\tmemset(agi, 0, BBTOB(agi_bp->b_length));\n\tagi->agi_magicnum = cpu_to_be32(XFS_AGI_MAGIC);\n\tagi->agi_versionnum = cpu_to_be32(XFS_AGI_VERSION);\n\tagi->agi_seqno = cpu_to_be32(pag->pag_agno);\n\tagi->agi_length = cpu_to_be32(pag->block_count);\n\tagi->agi_newino = cpu_to_be32(NULLAGINO);\n\tagi->agi_dirino = cpu_to_be32(NULLAGINO);\n\tif (xfs_has_crc(mp))\n\t\tuuid_copy(&agi->agi_uuid, &mp->m_sb.sb_meta_uuid);\n\n\t \n\tmemcpy(&agi->agi_unlinked, &old_agi->agi_unlinked,\n\t\t\tsizeof(agi->agi_unlinked));\n\n\t \n\tASSERT(xfs_perag_initialised_agi(pag));\n\tclear_bit(XFS_AGSTATE_AGI_INIT, &pag->pag_opstate);\n}\n\n \nSTATIC void\nxrep_agi_set_roots(\n\tstruct xfs_scrub\t\t*sc,\n\tstruct xfs_agi\t\t\t*agi,\n\tstruct xrep_find_ag_btree\t*fab)\n{\n\tagi->agi_root = cpu_to_be32(fab[XREP_AGI_INOBT].root);\n\tagi->agi_level = cpu_to_be32(fab[XREP_AGI_INOBT].height);\n\n\tif (xfs_has_finobt(sc->mp)) {\n\t\tagi->agi_free_root = cpu_to_be32(fab[XREP_AGI_FINOBT].root);\n\t\tagi->agi_free_level = cpu_to_be32(fab[XREP_AGI_FINOBT].height);\n\t}\n}\n\n \nSTATIC int\nxrep_agi_calc_from_btrees(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_buf\t\t*agi_bp)\n{\n\tstruct xfs_btree_cur\t*cur;\n\tstruct xfs_agi\t\t*agi = agi_bp->b_addr;\n\tstruct xfs_mount\t*mp = sc->mp;\n\txfs_agino_t\t\tcount;\n\txfs_agino_t\t\tfreecount;\n\tint\t\t\terror;\n\n\tcur = xfs_inobt_init_cursor(sc->sa.pag, sc->tp, agi_bp, XFS_BTNUM_INO);\n\terror = xfs_ialloc_count_inodes(cur, &count, &freecount);\n\tif (error)\n\t\tgoto err;\n\tif (xfs_has_inobtcounts(mp)) {\n\t\txfs_agblock_t\tblocks;\n\n\t\terror = xfs_btree_count_blocks(cur, &blocks);\n\t\tif (error)\n\t\t\tgoto err;\n\t\tagi->agi_iblocks = cpu_to_be32(blocks);\n\t}\n\txfs_btree_del_cursor(cur, error);\n\n\tagi->agi_count = cpu_to_be32(count);\n\tagi->agi_freecount = cpu_to_be32(freecount);\n\n\tif (xfs_has_finobt(mp) && xfs_has_inobtcounts(mp)) {\n\t\txfs_agblock_t\tblocks;\n\n\t\tcur = xfs_inobt_init_cursor(sc->sa.pag, sc->tp, agi_bp,\n\t\t\t\tXFS_BTNUM_FINO);\n\t\terror = xfs_btree_count_blocks(cur, &blocks);\n\t\tif (error)\n\t\t\tgoto err;\n\t\txfs_btree_del_cursor(cur, error);\n\t\tagi->agi_fblocks = cpu_to_be32(blocks);\n\t}\n\n\treturn 0;\nerr:\n\txfs_btree_del_cursor(cur, error);\n\treturn error;\n}\n\n \nSTATIC int\nxrep_agi_commit_new(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_buf\t\t*agi_bp)\n{\n\tstruct xfs_perag\t*pag;\n\tstruct xfs_agi\t\t*agi = agi_bp->b_addr;\n\n\t \n\txfs_force_summary_recalc(sc->mp);\n\n\t \n\txfs_trans_buf_set_type(sc->tp, agi_bp, XFS_BLFT_AGI_BUF);\n\txfs_trans_log_buf(sc->tp, agi_bp, 0, BBTOB(agi_bp->b_length) - 1);\n\n\t \n\tpag = sc->sa.pag;\n\tpag->pagi_count = be32_to_cpu(agi->agi_count);\n\tpag->pagi_freecount = be32_to_cpu(agi->agi_freecount);\n\tset_bit(XFS_AGSTATE_AGI_INIT, &pag->pag_opstate);\n\n\treturn 0;\n}\n\n \nint\nxrep_agi(\n\tstruct xfs_scrub\t\t*sc)\n{\n\tstruct xrep_find_ag_btree\tfab[XREP_AGI_MAX] = {\n\t\t[XREP_AGI_INOBT] = {\n\t\t\t.rmap_owner = XFS_RMAP_OWN_INOBT,\n\t\t\t.buf_ops = &xfs_inobt_buf_ops,\n\t\t\t.maxlevels = M_IGEO(sc->mp)->inobt_maxlevels,\n\t\t},\n\t\t[XREP_AGI_FINOBT] = {\n\t\t\t.rmap_owner = XFS_RMAP_OWN_INOBT,\n\t\t\t.buf_ops = &xfs_finobt_buf_ops,\n\t\t\t.maxlevels = M_IGEO(sc->mp)->inobt_maxlevels,\n\t\t},\n\t\t[XREP_AGI_END] = {\n\t\t\t.buf_ops = NULL\n\t\t},\n\t};\n\tstruct xfs_agi\t\t\told_agi;\n\tstruct xfs_mount\t\t*mp = sc->mp;\n\tstruct xfs_buf\t\t\t*agi_bp;\n\tstruct xfs_agi\t\t\t*agi;\n\tint\t\t\t\terror;\n\n\t \n\tif (!xfs_has_rmapbt(mp))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\terror = xfs_trans_read_buf(mp, sc->tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, sc->sa.pag->pag_agno,\n\t\t\t\t\t\tXFS_AGI_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &agi_bp, NULL);\n\tif (error)\n\t\treturn error;\n\tagi_bp->b_ops = &xfs_agi_buf_ops;\n\tagi = agi_bp->b_addr;\n\n\t \n\terror = xrep_agi_find_btrees(sc, fab);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (xchk_should_terminate(sc, &error))\n\t\treturn error;\n\n\t \n\txrep_agi_init_header(sc, agi_bp, &old_agi);\n\txrep_agi_set_roots(sc, agi, fab);\n\terror = xrep_agi_calc_from_btrees(sc, agi_bp);\n\tif (error)\n\t\tgoto out_revert;\n\n\t \n\treturn xrep_agi_commit_new(sc, agi_bp);\n\nout_revert:\n\t \n\tclear_bit(XFS_AGSTATE_AGI_INIT, &sc->sa.pag->pag_opstate);\n\tmemcpy(agi, &old_agi, sizeof(old_agi));\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}