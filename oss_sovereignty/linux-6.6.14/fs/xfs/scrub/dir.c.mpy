{
  "module_name": "dir.c",
  "hash_id": "131abb2c9a0b5f9295970b6f9b4b8183cfe1a4d5d6e32460b9e0ba47ae312da8",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/dir.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/common.h\"\n#include \"scrub/dabtree.h\"\n#include \"scrub/readdir.h\"\n\n \nint\nxchk_setup_directory(\n\tstruct xfs_scrub\t*sc)\n{\n\treturn xchk_setup_inode_contents(sc, 0);\n}\n\n \n\n \n\n \nSTATIC void\nxchk_dir_check_ftype(\n\tstruct xfs_scrub\t*sc,\n\txfs_fileoff_t\t\toffset,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tftype)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\n\tif (!xfs_has_ftype(mp)) {\n\t\tif (ftype != XFS_DIR3_FT_UNKNOWN && ftype != XFS_DIR3_FT_DIR)\n\t\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, offset);\n\t\treturn;\n\t}\n\n\tif (xfs_mode_to_ftype(VFS_I(ip)->i_mode) != ftype)\n\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, offset);\n}\n\n \nSTATIC int\nxchk_dir_actor(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_inode\t*dp,\n\txfs_dir2_dataptr_t\tdapos,\n\tconst struct xfs_name\t*name,\n\txfs_ino_t\t\tino,\n\tvoid\t\t\t*priv)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_inode\t*ip;\n\txfs_ino_t\t\tlookup_ino;\n\txfs_dablk_t\t\toffset;\n\tint\t\t\terror = 0;\n\n\toffset = xfs_dir2_db_to_da(mp->m_dir_geo,\n\t\t\txfs_dir2_dataptr_to_db(mp->m_dir_geo, dapos));\n\n\tif (xchk_should_terminate(sc, &error))\n\t\treturn error;\n\n\t \n\tif (!xfs_verify_dir_ino(mp, ino)) {\n\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, offset);\n\t\treturn -ECANCELED;\n\t}\n\n\t \n\tif (!xfs_dir2_namecheck(name->name, name->len)) {\n\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, offset);\n\t\treturn -ECANCELED;\n\t}\n\n\tif (!strncmp(\".\", name->name, name->len)) {\n\t\t \n\t\tif (ino != dp->i_ino)\n\t\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, offset);\n\t} else if (!strncmp(\"..\", name->name, name->len)) {\n\t\t \n\t\tif (dp->i_ino == mp->m_sb.sb_rootino && ino != dp->i_ino)\n\t\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, offset);\n\t}\n\n\t \n\terror = xchk_dir_lookup(sc, dp, name, &lookup_ino);\n\t \n\tif (error == -ENOENT)\n\t\terror = -EFSCORRUPTED;\n\tif (!xchk_fblock_process_error(sc, XFS_DATA_FORK, offset, &error))\n\t\tgoto out;\n\tif (lookup_ino != ino) {\n\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, offset);\n\t\treturn -ECANCELED;\n\t}\n\n\t \n\terror = xchk_iget(sc, ino, &ip);\n\tif (error == -EINVAL || error == -ENOENT) {\n\t\terror = -EFSCORRUPTED;\n\t\txchk_fblock_process_error(sc, XFS_DATA_FORK, 0, &error);\n\t\tgoto out;\n\t}\n\tif (!xchk_fblock_xref_process_error(sc, XFS_DATA_FORK, offset, &error))\n\t\tgoto out;\n\n\txchk_dir_check_ftype(sc, offset, ip, name->type);\n\txchk_irele(sc, ip);\nout:\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn -ECANCELED;\n\treturn error;\n}\n\n \nSTATIC int\nxchk_dir_rec(\n\tstruct xchk_da_btree\t\t*ds,\n\tint\t\t\t\tlevel)\n{\n\tstruct xfs_name\t\t\tdname = { };\n\tstruct xfs_da_state_blk\t\t*blk = &ds->state->path.blk[level];\n\tstruct xfs_mount\t\t*mp = ds->state->mp;\n\tstruct xfs_inode\t\t*dp = ds->dargs.dp;\n\tstruct xfs_da_geometry\t\t*geo = mp->m_dir_geo;\n\tstruct xfs_dir2_data_entry\t*dent;\n\tstruct xfs_buf\t\t\t*bp;\n\tstruct xfs_dir2_leaf_entry\t*ent;\n\tunsigned int\t\t\tend;\n\tunsigned int\t\t\titer_off;\n\txfs_ino_t\t\t\tino;\n\txfs_dablk_t\t\t\trec_bno;\n\txfs_dir2_db_t\t\t\tdb;\n\txfs_dir2_data_aoff_t\t\toff;\n\txfs_dir2_dataptr_t\t\tptr;\n\txfs_dahash_t\t\t\tcalc_hash;\n\txfs_dahash_t\t\t\thash;\n\tstruct xfs_dir3_icleaf_hdr\thdr;\n\tunsigned int\t\t\ttag;\n\tint\t\t\t\terror;\n\n\tASSERT(blk->magic == XFS_DIR2_LEAF1_MAGIC ||\n\t       blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\n\txfs_dir2_leaf_hdr_from_disk(mp, &hdr, blk->bp->b_addr);\n\tent = hdr.ents + blk->index;\n\n\t \n\terror = xchk_da_btree_hash(ds, level, &ent->hashval);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tptr = be32_to_cpu(ent->address);\n\tif (ptr == 0)\n\t\treturn 0;\n\n\t \n\tdb = xfs_dir2_dataptr_to_db(geo, ptr);\n\toff = xfs_dir2_dataptr_to_off(geo, ptr);\n\trec_bno = xfs_dir2_db_to_da(geo, db);\n\n\tif (rec_bno >= geo->leafblk) {\n\t\txchk_da_set_corrupt(ds, level);\n\t\tgoto out;\n\t}\n\terror = xfs_dir3_data_read(ds->dargs.trans, dp, rec_bno,\n\t\t\tXFS_DABUF_MAP_HOLE_OK, &bp);\n\tif (!xchk_fblock_process_error(ds->sc, XFS_DATA_FORK, rec_bno,\n\t\t\t&error))\n\t\tgoto out;\n\tif (!bp) {\n\t\txchk_fblock_set_corrupt(ds->sc, XFS_DATA_FORK, rec_bno);\n\t\tgoto out;\n\t}\n\txchk_buffer_recheck(ds->sc, bp);\n\n\tif (ds->sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\tgoto out_relse;\n\n\tdent = bp->b_addr + off;\n\n\t \n\titer_off = geo->data_entry_offset;\n\tend = xfs_dir3_data_end_offset(geo, bp->b_addr);\n\tif (!end) {\n\t\txchk_fblock_set_corrupt(ds->sc, XFS_DATA_FORK, rec_bno);\n\t\tgoto out_relse;\n\t}\n\tfor (;;) {\n\t\tstruct xfs_dir2_data_entry\t*dep = bp->b_addr + iter_off;\n\t\tstruct xfs_dir2_data_unused\t*dup = bp->b_addr + iter_off;\n\n\t\tif (iter_off >= end) {\n\t\t\txchk_fblock_set_corrupt(ds->sc, XFS_DATA_FORK, rec_bno);\n\t\t\tgoto out_relse;\n\t\t}\n\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\titer_off += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\t\tif (dep == dent)\n\t\t\tbreak;\n\t\titer_off += xfs_dir2_data_entsize(mp, dep->namelen);\n\t}\n\n\t \n\tino = be64_to_cpu(dent->inumber);\n\thash = be32_to_cpu(ent->hashval);\n\ttag = be16_to_cpup(xfs_dir2_data_entry_tag_p(mp, dent));\n\tif (!xfs_verify_dir_ino(mp, ino) || tag != off)\n\t\txchk_fblock_set_corrupt(ds->sc, XFS_DATA_FORK, rec_bno);\n\tif (dent->namelen == 0) {\n\t\txchk_fblock_set_corrupt(ds->sc, XFS_DATA_FORK, rec_bno);\n\t\tgoto out_relse;\n\t}\n\n\t \n\tdname.name = dent->name;\n\tdname.len = dent->namelen;\n\tcalc_hash = xfs_dir2_hashname(mp, &dname);\n\tif (calc_hash != hash)\n\t\txchk_fblock_set_corrupt(ds->sc, XFS_DATA_FORK, rec_bno);\n\nout_relse:\n\txfs_trans_brelse(ds->dargs.trans, bp);\nout:\n\treturn error;\n}\n\n \nSTATIC void\nxchk_directory_check_free_entry(\n\tstruct xfs_scrub\t\t*sc,\n\txfs_dablk_t\t\t\tlblk,\n\tstruct xfs_dir2_data_free\t*bf,\n\tstruct xfs_dir2_data_unused\t*dup)\n{\n\tstruct xfs_dir2_data_free\t*dfp;\n\tunsigned int\t\t\tdup_length;\n\n\tdup_length = be16_to_cpu(dup->length);\n\n\t \n\tif (dup_length < be16_to_cpu(bf[XFS_DIR2_DATA_FD_COUNT - 1].length))\n\t\treturn;\n\n\tfor (dfp = &bf[XFS_DIR2_DATA_FD_COUNT - 1]; dfp >= bf; dfp--)\n\t\tif (dup_length == be16_to_cpu(dfp->length))\n\t\t\treturn;\n\n\t \n\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n}\n\n \nSTATIC int\nxchk_directory_data_bestfree(\n\tstruct xfs_scrub\t\t*sc,\n\txfs_dablk_t\t\t\tlblk,\n\tbool\t\t\t\tis_block)\n{\n\tstruct xfs_dir2_data_unused\t*dup;\n\tstruct xfs_dir2_data_free\t*dfp;\n\tstruct xfs_buf\t\t\t*bp;\n\tstruct xfs_dir2_data_free\t*bf;\n\tstruct xfs_mount\t\t*mp = sc->mp;\n\tu16\t\t\t\ttag;\n\tunsigned int\t\t\tnr_bestfrees = 0;\n\tunsigned int\t\t\tnr_frees = 0;\n\tunsigned int\t\t\tsmallest_bestfree;\n\tint\t\t\t\tnewlen;\n\tunsigned int\t\t\toffset;\n\tunsigned int\t\t\tend;\n\tint\t\t\t\terror;\n\n\tif (is_block) {\n\t\t \n\t\tif (lblk != XFS_B_TO_FSBT(mp, XFS_DIR2_DATA_OFFSET))\n\t\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\t\terror = xfs_dir3_block_read(sc->tp, sc->ip, &bp);\n\t} else {\n\t\t \n\t\terror = xfs_dir3_data_read(sc->tp, sc->ip, lblk, 0, &bp);\n\t}\n\tif (!xchk_fblock_process_error(sc, XFS_DATA_FORK, lblk, &error))\n\t\tgoto out;\n\txchk_buffer_recheck(sc, bp);\n\n\t \n\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\tgoto out_buf;\n\n\t \n\tbf = xfs_dir2_data_bestfree_p(mp, bp->b_addr);\n\tsmallest_bestfree = UINT_MAX;\n\tfor (dfp = &bf[0]; dfp < &bf[XFS_DIR2_DATA_FD_COUNT]; dfp++) {\n\t\toffset = be16_to_cpu(dfp->offset);\n\t\tif (offset == 0)\n\t\t\tcontinue;\n\t\tif (offset >= mp->m_dir_geo->blksize) {\n\t\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\t\t\tgoto out_buf;\n\t\t}\n\t\tdup = bp->b_addr + offset;\n\t\ttag = be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup));\n\n\t\t \n\t\tif (dup->freetag != cpu_to_be16(XFS_DIR2_DATA_FREE_TAG) ||\n\t\t    be16_to_cpu(dup->length) != be16_to_cpu(dfp->length) ||\n\t\t    tag != offset) {\n\t\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\t\t\tgoto out_buf;\n\t\t}\n\n\t\t \n\t\tif (smallest_bestfree < be16_to_cpu(dfp->length)) {\n\t\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\t\t\tgoto out_buf;\n\t\t}\n\n\t\tsmallest_bestfree = be16_to_cpu(dfp->length);\n\t\tnr_bestfrees++;\n\t}\n\n\t \n\toffset = mp->m_dir_geo->data_entry_offset;\n\tend = xfs_dir3_data_end_offset(mp->m_dir_geo, bp->b_addr);\n\n\t \n\twhile (offset < end) {\n\t\tdup = bp->b_addr + offset;\n\n\t\t \n\t\tif (dup->freetag != cpu_to_be16(XFS_DIR2_DATA_FREE_TAG)) {\n\t\t\tstruct xfs_dir2_data_entry *dep = bp->b_addr + offset;\n\n\t\t\tnewlen = xfs_dir2_data_entsize(mp, dep->namelen);\n\t\t\tif (newlen <= 0) {\n\t\t\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK,\n\t\t\t\t\t\tlblk);\n\t\t\t\tgoto out_buf;\n\t\t\t}\n\t\t\toffset += newlen;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\ttag = be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup));\n\t\tif (tag != offset) {\n\t\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\t\t\tgoto out_buf;\n\t\t}\n\n\t\t \n\t\txchk_directory_check_free_entry(sc, lblk, bf, dup);\n\t\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\t\tgoto out_buf;\n\n\t\t \n\t\tnewlen = be16_to_cpu(dup->length);\n\t\tif (newlen <= 0) {\n\t\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\t\t\tgoto out_buf;\n\t\t}\n\t\toffset += newlen;\n\t\tif (offset <= end)\n\t\t\tnr_frees++;\n\t}\n\n\t \n\tif (offset != end)\n\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\n\t \n\tif (nr_frees < nr_bestfrees)\n\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\nout_buf:\n\txfs_trans_brelse(sc->tp, bp);\nout:\n\treturn error;\n}\n\n \nSTATIC void\nxchk_directory_check_freesp(\n\tstruct xfs_scrub\t\t*sc,\n\txfs_dablk_t\t\t\tlblk,\n\tstruct xfs_buf\t\t\t*dbp,\n\tunsigned int\t\t\tlen)\n{\n\tstruct xfs_dir2_data_free\t*dfp;\n\n\tdfp = xfs_dir2_data_bestfree_p(sc->mp, dbp->b_addr);\n\n\tif (len != be16_to_cpu(dfp->length))\n\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\n\tif (len > 0 && be16_to_cpu(dfp->offset) == 0)\n\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n}\n\n \nSTATIC int\nxchk_directory_leaf1_bestfree(\n\tstruct xfs_scrub\t\t*sc,\n\tstruct xfs_da_args\t\t*args,\n\txfs_dir2_db_t\t\t\tlast_data_db,\n\txfs_dablk_t\t\t\tlblk)\n{\n\tstruct xfs_dir3_icleaf_hdr\tleafhdr;\n\tstruct xfs_dir2_leaf_tail\t*ltp;\n\tstruct xfs_dir2_leaf\t\t*leaf;\n\tstruct xfs_buf\t\t\t*dbp;\n\tstruct xfs_buf\t\t\t*bp;\n\tstruct xfs_da_geometry\t\t*geo = sc->mp->m_dir_geo;\n\t__be16\t\t\t\t*bestp;\n\t__u16\t\t\t\tbest;\n\t__u32\t\t\t\thash;\n\t__u32\t\t\t\tlasthash = 0;\n\t__u32\t\t\t\tbestcount;\n\tunsigned int\t\t\tstale = 0;\n\tint\t\t\t\ti;\n\tint\t\t\t\terror;\n\n\t \n\terror = xfs_dir3_leaf_read(sc->tp, sc->ip, lblk, &bp);\n\tif (!xchk_fblock_process_error(sc, XFS_DATA_FORK, lblk, &error))\n\t\treturn error;\n\txchk_buffer_recheck(sc, bp);\n\n\tleaf = bp->b_addr;\n\txfs_dir2_leaf_hdr_from_disk(sc->ip->i_mount, &leafhdr, leaf);\n\tltp = xfs_dir2_leaf_tail_p(geo, leaf);\n\tbestcount = be32_to_cpu(ltp->bestcount);\n\tbestp = xfs_dir2_leaf_bests_p(ltp);\n\n\tif (xfs_has_crc(sc->mp)) {\n\t\tstruct xfs_dir3_leaf_hdr\t*hdr3 = bp->b_addr;\n\n\t\tif (hdr3->pad != cpu_to_be32(0))\n\t\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\t}\n\n\t \n\tif (bestcount != last_data_db + 1) {\n\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\t\tgoto out;\n\t}\n\n\t \n\tif (leafhdr.count > geo->leaf_max_ents) {\n\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\t\tgoto out;\n\t}\n\n\t \n\tif ((char *)&leafhdr.ents[leafhdr.count] > (char *)bestp) {\n\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < leafhdr.count; i++) {\n\t\thash = be32_to_cpu(leafhdr.ents[i].hashval);\n\t\tif (i > 0 && lasthash > hash)\n\t\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\t\tlasthash = hash;\n\t\tif (leafhdr.ents[i].address ==\n\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tstale++;\n\t}\n\tif (leafhdr.stale != stale)\n\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < bestcount; i++, bestp++) {\n\t\tbest = be16_to_cpu(*bestp);\n\t\terror = xfs_dir3_data_read(sc->tp, sc->ip,\n\t\t\t\txfs_dir2_db_to_da(args->geo, i),\n\t\t\t\tXFS_DABUF_MAP_HOLE_OK,\n\t\t\t\t&dbp);\n\t\tif (!xchk_fblock_process_error(sc, XFS_DATA_FORK, lblk,\n\t\t\t\t&error))\n\t\t\tbreak;\n\n\t\tif (!dbp) {\n\t\t\tif (best != NULLDATAOFF) {\n\t\t\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK,\n\t\t\t\t\t\tlblk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (best == NULLDATAOFF)\n\t\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\t\telse\n\t\t\txchk_directory_check_freesp(sc, lblk, dbp, best);\n\t\txfs_trans_brelse(sc->tp, dbp);\n\t\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\t\tbreak;\n\t}\nout:\n\txfs_trans_brelse(sc->tp, bp);\n\treturn error;\n}\n\n \nSTATIC int\nxchk_directory_free_bestfree(\n\tstruct xfs_scrub\t\t*sc,\n\tstruct xfs_da_args\t\t*args,\n\txfs_dablk_t\t\t\tlblk)\n{\n\tstruct xfs_dir3_icfree_hdr\tfreehdr;\n\tstruct xfs_buf\t\t\t*dbp;\n\tstruct xfs_buf\t\t\t*bp;\n\t__u16\t\t\t\tbest;\n\tunsigned int\t\t\tstale = 0;\n\tint\t\t\t\ti;\n\tint\t\t\t\terror;\n\n\t \n\terror = xfs_dir2_free_read(sc->tp, sc->ip, lblk, &bp);\n\tif (!xchk_fblock_process_error(sc, XFS_DATA_FORK, lblk, &error))\n\t\treturn error;\n\txchk_buffer_recheck(sc, bp);\n\n\tif (xfs_has_crc(sc->mp)) {\n\t\tstruct xfs_dir3_free_hdr\t*hdr3 = bp->b_addr;\n\n\t\tif (hdr3->pad != cpu_to_be32(0))\n\t\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\t}\n\n\t \n\txfs_dir2_free_hdr_from_disk(sc->ip->i_mount, &freehdr, bp->b_addr);\n\tfor (i = 0; i < freehdr.nvalid; i++) {\n\t\tbest = be16_to_cpu(freehdr.bests[i]);\n\t\tif (best == NULLDATAOFF) {\n\t\t\tstale++;\n\t\t\tcontinue;\n\t\t}\n\t\terror = xfs_dir3_data_read(sc->tp, sc->ip,\n\t\t\t\t(freehdr.firstdb + i) * args->geo->fsbcount,\n\t\t\t\t0, &dbp);\n\t\tif (!xchk_fblock_process_error(sc, XFS_DATA_FORK, lblk,\n\t\t\t\t&error))\n\t\t\tgoto out;\n\t\txchk_directory_check_freesp(sc, lblk, dbp, best);\n\t\txfs_trans_brelse(sc->tp, dbp);\n\t}\n\n\tif (freehdr.nused + stale != freehdr.nvalid)\n\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\nout:\n\txfs_trans_brelse(sc->tp, bp);\n\treturn error;\n}\n\n \nSTATIC int\nxchk_directory_blocks(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_da_args\targs = {\n\t\t.dp\t\t= sc ->ip,\n\t\t.whichfork\t= XFS_DATA_FORK,\n\t\t.geo\t\t= sc->mp->m_dir_geo,\n\t\t.trans\t\t= sc->tp,\n\t};\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(sc->ip, XFS_DATA_FORK);\n\tstruct xfs_mount\t*mp = sc->mp;\n\txfs_fileoff_t\t\tleaf_lblk;\n\txfs_fileoff_t\t\tfree_lblk;\n\txfs_fileoff_t\t\tlblk;\n\tstruct xfs_iext_cursor\ticur;\n\txfs_dablk_t\t\tdabno;\n\txfs_dir2_db_t\t\tlast_data_db = 0;\n\tbool\t\t\tfound;\n\tbool\t\t\tis_block = false;\n\tint\t\t\terror;\n\n\t \n\tif (ifp->if_format != XFS_DINODE_FMT_EXTENTS &&\n\t    ifp->if_format != XFS_DINODE_FMT_BTREE)\n\t\treturn 0;\n\n\tlblk = XFS_B_TO_FSB(mp, XFS_DIR2_DATA_OFFSET);\n\tleaf_lblk = XFS_B_TO_FSB(mp, XFS_DIR2_LEAF_OFFSET);\n\tfree_lblk = XFS_B_TO_FSB(mp, XFS_DIR2_FREE_OFFSET);\n\n\t \n\terror = xfs_dir2_isblock(&args, &is_block);\n\tif (!xchk_fblock_process_error(sc, XFS_DATA_FORK, lblk, &error))\n\t\tgoto out;\n\n\t \n\tfound = xfs_iext_lookup_extent(sc->ip, ifp, lblk, &icur, &got);\n\twhile (found && !(sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)) {\n\t\t \n\t\tif (got.br_startoff >= leaf_lblk)\n\t\t\tbreak;\n\n\t\t \n\t\tfor (lblk = roundup((xfs_dablk_t)got.br_startoff,\n\t\t\t\targs.geo->fsbcount);\n\t\t     lblk < got.br_startoff + got.br_blockcount;\n\t\t     lblk += args.geo->fsbcount) {\n\t\t\tlast_data_db = xfs_dir2_da_to_db(args.geo, lblk);\n\t\t\terror = xchk_directory_data_bestfree(sc, lblk,\n\t\t\t\t\tis_block);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\t\tdabno = got.br_startoff + got.br_blockcount;\n\t\tlblk = roundup(dabno, args.geo->fsbcount);\n\t\tfound = xfs_iext_lookup_extent(sc->ip, ifp, lblk, &icur, &got);\n\t}\n\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\tgoto out;\n\n\t \n\tif (xfs_iext_lookup_extent(sc->ip, ifp, leaf_lblk, &icur, &got) &&\n\t    got.br_startoff == leaf_lblk &&\n\t    got.br_blockcount == args.geo->fsbcount &&\n\t    !xfs_iext_next_extent(ifp, &icur, &got)) {\n\t\tif (is_block) {\n\t\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\t\t\tgoto out;\n\t\t}\n\t\terror = xchk_directory_leaf1_bestfree(sc, &args, last_data_db,\n\t\t\t\tleaf_lblk);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\tgoto out;\n\n\t \n\tlblk = free_lblk;\n\tfound = xfs_iext_lookup_extent(sc->ip, ifp, lblk, &icur, &got);\n\twhile (found && !(sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)) {\n\t\t \n\t\tlblk = got.br_startoff;\n\t\tif (lblk & ~0xFFFFFFFFULL) {\n\t\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\t\t\tgoto out;\n\t\t}\n\t\tif (is_block) {\n\t\t\txchk_fblock_set_corrupt(sc, XFS_DATA_FORK, lblk);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tfor (lblk = roundup((xfs_dablk_t)got.br_startoff,\n\t\t\t\targs.geo->fsbcount);\n\t\t     lblk < got.br_startoff + got.br_blockcount;\n\t\t     lblk += args.geo->fsbcount) {\n\t\t\terror = xchk_directory_free_bestfree(sc, &args,\n\t\t\t\t\tlblk);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\t\tdabno = got.br_startoff + got.br_blockcount;\n\t\tlblk = roundup(dabno, args.geo->fsbcount);\n\t\tfound = xfs_iext_lookup_extent(sc->ip, ifp, lblk, &icur, &got);\n\t}\nout:\n\treturn error;\n}\n\n \nint\nxchk_directory(\n\tstruct xfs_scrub\t*sc)\n{\n\tint\t\t\terror;\n\n\tif (!S_ISDIR(VFS_I(sc->ip)->i_mode))\n\t\treturn -ENOENT;\n\n\t \n\tif (sc->ip->i_disk_size < xfs_dir2_sf_hdr_size(0)) {\n\t\txchk_ino_set_corrupt(sc, sc->ip->i_ino);\n\t\treturn 0;\n\t}\n\n\t \n\terror = xchk_da_btree(sc, XFS_DATA_FORK, xchk_dir_rec, NULL);\n\tif (error)\n\t\treturn error;\n\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn 0;\n\n\t \n\terror = xchk_directory_blocks(sc);\n\tif (error)\n\t\treturn error;\n\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn 0;\n\n\t \n\terror = xchk_dir_walk(sc, sc->ip, xchk_dir_actor, NULL);\n\tif (error == -ECANCELED)\n\t\terror = 0;\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}