{
  "module_name": "common.c",
  "hash_id": "cae06663fb5f583c47691a6e039e66949a2d2aee155962dd34c661aa77324068",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/scrub/common.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_refcount_btree.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_rmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_reflink.h\"\n#include \"xfs_ag.h\"\n#include \"scrub/scrub.h\"\n#include \"scrub/common.h\"\n#include \"scrub/trace.h\"\n#include \"scrub/repair.h\"\n#include \"scrub/health.h\"\n\n \n\n \n\n \nstatic bool\n__xchk_process_error(\n\tstruct xfs_scrub\t*sc,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tbno,\n\tint\t\t\t*error,\n\t__u32\t\t\terrflag,\n\tvoid\t\t\t*ret_ip)\n{\n\tswitch (*error) {\n\tcase 0:\n\t\treturn true;\n\tcase -EDEADLOCK:\n\tcase -ECHRNG:\n\t\t \n\t\ttrace_xchk_deadlock_retry(\n\t\t\t\tsc->ip ? sc->ip : XFS_I(file_inode(sc->file)),\n\t\t\t\tsc->sm, *error);\n\t\tbreak;\n\tcase -EFSBADCRC:\n\tcase -EFSCORRUPTED:\n\t\t \n\t\tsc->sm->sm_flags |= errflag;\n\t\t*error = 0;\n\t\tfallthrough;\n\tdefault:\n\t\ttrace_xchk_op_error(sc, agno, bno, *error,\n\t\t\t\tret_ip);\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nbool\nxchk_process_error(\n\tstruct xfs_scrub\t*sc,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tbno,\n\tint\t\t\t*error)\n{\n\treturn __xchk_process_error(sc, agno, bno, error,\n\t\t\tXFS_SCRUB_OFLAG_CORRUPT, __return_address);\n}\n\nbool\nxchk_xref_process_error(\n\tstruct xfs_scrub\t*sc,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tbno,\n\tint\t\t\t*error)\n{\n\treturn __xchk_process_error(sc, agno, bno, error,\n\t\t\tXFS_SCRUB_OFLAG_XFAIL, __return_address);\n}\n\n \nstatic bool\n__xchk_fblock_process_error(\n\tstruct xfs_scrub\t*sc,\n\tint\t\t\twhichfork,\n\txfs_fileoff_t\t\toffset,\n\tint\t\t\t*error,\n\t__u32\t\t\terrflag,\n\tvoid\t\t\t*ret_ip)\n{\n\tswitch (*error) {\n\tcase 0:\n\t\treturn true;\n\tcase -EDEADLOCK:\n\tcase -ECHRNG:\n\t\t \n\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);\n\t\tbreak;\n\tcase -EFSBADCRC:\n\tcase -EFSCORRUPTED:\n\t\t \n\t\tsc->sm->sm_flags |= errflag;\n\t\t*error = 0;\n\t\tfallthrough;\n\tdefault:\n\t\ttrace_xchk_file_op_error(sc, whichfork, offset, *error,\n\t\t\t\tret_ip);\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nbool\nxchk_fblock_process_error(\n\tstruct xfs_scrub\t*sc,\n\tint\t\t\twhichfork,\n\txfs_fileoff_t\t\toffset,\n\tint\t\t\t*error)\n{\n\treturn __xchk_fblock_process_error(sc, whichfork, offset, error,\n\t\t\tXFS_SCRUB_OFLAG_CORRUPT, __return_address);\n}\n\nbool\nxchk_fblock_xref_process_error(\n\tstruct xfs_scrub\t*sc,\n\tint\t\t\twhichfork,\n\txfs_fileoff_t\t\toffset,\n\tint\t\t\t*error)\n{\n\treturn __xchk_fblock_process_error(sc, whichfork, offset, error,\n\t\t\tXFS_SCRUB_OFLAG_XFAIL, __return_address);\n}\n\n \n\n \nvoid\nxchk_block_set_preen(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_buf\t\t*bp)\n{\n\tsc->sm->sm_flags |= XFS_SCRUB_OFLAG_PREEN;\n\ttrace_xchk_block_preen(sc, xfs_buf_daddr(bp), __return_address);\n}\n\n \nvoid\nxchk_ino_set_preen(\n\tstruct xfs_scrub\t*sc,\n\txfs_ino_t\t\tino)\n{\n\tsc->sm->sm_flags |= XFS_SCRUB_OFLAG_PREEN;\n\ttrace_xchk_ino_preen(sc, ino, __return_address);\n}\n\n \nvoid\nxchk_set_corrupt(\n\tstruct xfs_scrub\t*sc)\n{\n\tsc->sm->sm_flags |= XFS_SCRUB_OFLAG_CORRUPT;\n\ttrace_xchk_fs_error(sc, 0, __return_address);\n}\n\n \nvoid\nxchk_block_set_corrupt(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_buf\t\t*bp)\n{\n\tsc->sm->sm_flags |= XFS_SCRUB_OFLAG_CORRUPT;\n\ttrace_xchk_block_error(sc, xfs_buf_daddr(bp), __return_address);\n}\n\n \nvoid\nxchk_block_xref_set_corrupt(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_buf\t\t*bp)\n{\n\tsc->sm->sm_flags |= XFS_SCRUB_OFLAG_XCORRUPT;\n\ttrace_xchk_block_error(sc, xfs_buf_daddr(bp), __return_address);\n}\n\n \nvoid\nxchk_ino_set_corrupt(\n\tstruct xfs_scrub\t*sc,\n\txfs_ino_t\t\tino)\n{\n\tsc->sm->sm_flags |= XFS_SCRUB_OFLAG_CORRUPT;\n\ttrace_xchk_ino_error(sc, ino, __return_address);\n}\n\n \nvoid\nxchk_ino_xref_set_corrupt(\n\tstruct xfs_scrub\t*sc,\n\txfs_ino_t\t\tino)\n{\n\tsc->sm->sm_flags |= XFS_SCRUB_OFLAG_XCORRUPT;\n\ttrace_xchk_ino_error(sc, ino, __return_address);\n}\n\n \nvoid\nxchk_fblock_set_corrupt(\n\tstruct xfs_scrub\t*sc,\n\tint\t\t\twhichfork,\n\txfs_fileoff_t\t\toffset)\n{\n\tsc->sm->sm_flags |= XFS_SCRUB_OFLAG_CORRUPT;\n\ttrace_xchk_fblock_error(sc, whichfork, offset, __return_address);\n}\n\n \nvoid\nxchk_fblock_xref_set_corrupt(\n\tstruct xfs_scrub\t*sc,\n\tint\t\t\twhichfork,\n\txfs_fileoff_t\t\toffset)\n{\n\tsc->sm->sm_flags |= XFS_SCRUB_OFLAG_XCORRUPT;\n\ttrace_xchk_fblock_error(sc, whichfork, offset, __return_address);\n}\n\n \nvoid\nxchk_ino_set_warning(\n\tstruct xfs_scrub\t*sc,\n\txfs_ino_t\t\tino)\n{\n\tsc->sm->sm_flags |= XFS_SCRUB_OFLAG_WARNING;\n\ttrace_xchk_ino_warning(sc, ino, __return_address);\n}\n\n \nvoid\nxchk_fblock_set_warning(\n\tstruct xfs_scrub\t*sc,\n\tint\t\t\twhichfork,\n\txfs_fileoff_t\t\toffset)\n{\n\tsc->sm->sm_flags |= XFS_SCRUB_OFLAG_WARNING;\n\ttrace_xchk_fblock_warning(sc, whichfork, offset, __return_address);\n}\n\n \nvoid\nxchk_set_incomplete(\n\tstruct xfs_scrub\t*sc)\n{\n\tsc->sm->sm_flags |= XFS_SCRUB_OFLAG_INCOMPLETE;\n\ttrace_xchk_incomplete(sc, __return_address);\n}\n\n \n\nstruct xchk_rmap_ownedby_info {\n\tconst struct xfs_owner_info\t*oinfo;\n\txfs_filblks_t\t\t\t*blocks;\n};\n\nSTATIC int\nxchk_count_rmap_ownedby_irec(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst struct xfs_rmap_irec\t*rec,\n\tvoid\t\t\t\t*priv)\n{\n\tstruct xchk_rmap_ownedby_info\t*sroi = priv;\n\tbool\t\t\t\tirec_attr;\n\tbool\t\t\t\toinfo_attr;\n\n\tirec_attr = rec->rm_flags & XFS_RMAP_ATTR_FORK;\n\toinfo_attr = sroi->oinfo->oi_flags & XFS_OWNER_INFO_ATTR_FORK;\n\n\tif (rec->rm_owner != sroi->oinfo->oi_owner)\n\t\treturn 0;\n\n\tif (XFS_RMAP_NON_INODE_OWNER(rec->rm_owner) || irec_attr == oinfo_attr)\n\t\t(*sroi->blocks) += rec->rm_blockcount;\n\n\treturn 0;\n}\n\n \nint\nxchk_count_rmap_ownedby_ag(\n\tstruct xfs_scrub\t\t*sc,\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst struct xfs_owner_info\t*oinfo,\n\txfs_filblks_t\t\t\t*blocks)\n{\n\tstruct xchk_rmap_ownedby_info\tsroi = {\n\t\t.oinfo\t\t\t= oinfo,\n\t\t.blocks\t\t\t= blocks,\n\t};\n\n\t*blocks = 0;\n\treturn xfs_rmap_query_all(cur, xchk_count_rmap_ownedby_irec,\n\t\t\t&sroi);\n}\n\n \n\n \nstatic inline bool\nwant_ag_read_header_failure(\n\tstruct xfs_scrub\t*sc,\n\tunsigned int\t\ttype)\n{\n\t \n\tif (sc->sm->sm_type != XFS_SCRUB_TYPE_AGF &&\n\t    sc->sm->sm_type != XFS_SCRUB_TYPE_AGFL &&\n\t    sc->sm->sm_type != XFS_SCRUB_TYPE_AGI)\n\t\treturn true;\n\t \n\tif (sc->sm->sm_type == type)\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic inline int\nxchk_perag_read_headers(\n\tstruct xfs_scrub\t*sc,\n\tstruct xchk_ag\t\t*sa)\n{\n\tint\t\t\terror;\n\n\terror = xfs_ialloc_read_agi(sa->pag, sc->tp, &sa->agi_bp);\n\tif (error && want_ag_read_header_failure(sc, XFS_SCRUB_TYPE_AGI))\n\t\treturn error;\n\n\terror = xfs_alloc_read_agf(sa->pag, sc->tp, 0, &sa->agf_bp);\n\tif (error && want_ag_read_header_failure(sc, XFS_SCRUB_TYPE_AGF))\n\t\treturn error;\n\n\treturn 0;\n}\n\n \nstatic int\nxchk_perag_drain_and_lock(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xchk_ag\t\t*sa = &sc->sa;\n\tint\t\t\terror = 0;\n\n\tASSERT(sa->pag != NULL);\n\tASSERT(sa->agi_bp == NULL);\n\tASSERT(sa->agf_bp == NULL);\n\n\tdo {\n\t\tif (xchk_should_terminate(sc, &error))\n\t\t\treturn error;\n\n\t\terror = xchk_perag_read_headers(sc, sa);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tif (sc->ip)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (!xfs_perag_intent_busy(sa->pag))\n\t\t\treturn 0;\n\n\t\tif (sa->agf_bp) {\n\t\t\txfs_trans_brelse(sc->tp, sa->agf_bp);\n\t\t\tsa->agf_bp = NULL;\n\t\t}\n\n\t\tif (sa->agi_bp) {\n\t\t\txfs_trans_brelse(sc->tp, sa->agi_bp);\n\t\t\tsa->agi_bp = NULL;\n\t\t}\n\n\t\tif (!(sc->flags & XCHK_FSGATES_DRAIN))\n\t\t\treturn -ECHRNG;\n\t\terror = xfs_perag_intent_drain(sa->pag);\n\t\tif (error == -ERESTARTSYS)\n\t\t\terror = -EINTR;\n\t} while (!error);\n\n\treturn error;\n}\n\n \nint\nxchk_ag_read_headers(\n\tstruct xfs_scrub\t*sc,\n\txfs_agnumber_t\t\tagno,\n\tstruct xchk_ag\t\t*sa)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\n\tASSERT(!sa->pag);\n\tsa->pag = xfs_perag_get(mp, agno);\n\tif (!sa->pag)\n\t\treturn -ENOENT;\n\n\treturn xchk_perag_drain_and_lock(sc);\n}\n\n \nvoid\nxchk_ag_btcur_free(\n\tstruct xchk_ag\t\t*sa)\n{\n\tif (sa->refc_cur)\n\t\txfs_btree_del_cursor(sa->refc_cur, XFS_BTREE_ERROR);\n\tif (sa->rmap_cur)\n\t\txfs_btree_del_cursor(sa->rmap_cur, XFS_BTREE_ERROR);\n\tif (sa->fino_cur)\n\t\txfs_btree_del_cursor(sa->fino_cur, XFS_BTREE_ERROR);\n\tif (sa->ino_cur)\n\t\txfs_btree_del_cursor(sa->ino_cur, XFS_BTREE_ERROR);\n\tif (sa->cnt_cur)\n\t\txfs_btree_del_cursor(sa->cnt_cur, XFS_BTREE_ERROR);\n\tif (sa->bno_cur)\n\t\txfs_btree_del_cursor(sa->bno_cur, XFS_BTREE_ERROR);\n\n\tsa->refc_cur = NULL;\n\tsa->rmap_cur = NULL;\n\tsa->fino_cur = NULL;\n\tsa->ino_cur = NULL;\n\tsa->bno_cur = NULL;\n\tsa->cnt_cur = NULL;\n}\n\n \nvoid\nxchk_ag_btcur_init(\n\tstruct xfs_scrub\t*sc,\n\tstruct xchk_ag\t\t*sa)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\n\tif (sa->agf_bp &&\n\t    xchk_ag_btree_healthy_enough(sc, sa->pag, XFS_BTNUM_BNO)) {\n\t\t \n\t\tsa->bno_cur = xfs_allocbt_init_cursor(mp, sc->tp, sa->agf_bp,\n\t\t\t\tsa->pag, XFS_BTNUM_BNO);\n\t}\n\n\tif (sa->agf_bp &&\n\t    xchk_ag_btree_healthy_enough(sc, sa->pag, XFS_BTNUM_CNT)) {\n\t\t \n\t\tsa->cnt_cur = xfs_allocbt_init_cursor(mp, sc->tp, sa->agf_bp,\n\t\t\t\tsa->pag, XFS_BTNUM_CNT);\n\t}\n\n\t \n\tif (sa->agi_bp &&\n\t    xchk_ag_btree_healthy_enough(sc, sa->pag, XFS_BTNUM_INO)) {\n\t\tsa->ino_cur = xfs_inobt_init_cursor(sa->pag, sc->tp, sa->agi_bp,\n\t\t\t\tXFS_BTNUM_INO);\n\t}\n\n\t \n\tif (sa->agi_bp && xfs_has_finobt(mp) &&\n\t    xchk_ag_btree_healthy_enough(sc, sa->pag, XFS_BTNUM_FINO)) {\n\t\tsa->fino_cur = xfs_inobt_init_cursor(sa->pag, sc->tp, sa->agi_bp,\n\t\t\t\tXFS_BTNUM_FINO);\n\t}\n\n\t \n\tif (sa->agf_bp && xfs_has_rmapbt(mp) &&\n\t    xchk_ag_btree_healthy_enough(sc, sa->pag, XFS_BTNUM_RMAP)) {\n\t\tsa->rmap_cur = xfs_rmapbt_init_cursor(mp, sc->tp, sa->agf_bp,\n\t\t\t\tsa->pag);\n\t}\n\n\t \n\tif (sa->agf_bp && xfs_has_reflink(mp) &&\n\t    xchk_ag_btree_healthy_enough(sc, sa->pag, XFS_BTNUM_REFC)) {\n\t\tsa->refc_cur = xfs_refcountbt_init_cursor(mp, sc->tp,\n\t\t\t\tsa->agf_bp, sa->pag);\n\t}\n}\n\n \nvoid\nxchk_ag_free(\n\tstruct xfs_scrub\t*sc,\n\tstruct xchk_ag\t\t*sa)\n{\n\txchk_ag_btcur_free(sa);\n\tif (sa->agf_bp) {\n\t\txfs_trans_brelse(sc->tp, sa->agf_bp);\n\t\tsa->agf_bp = NULL;\n\t}\n\tif (sa->agi_bp) {\n\t\txfs_trans_brelse(sc->tp, sa->agi_bp);\n\t\tsa->agi_bp = NULL;\n\t}\n\tif (sa->pag) {\n\t\txfs_perag_put(sa->pag);\n\t\tsa->pag = NULL;\n\t}\n}\n\n \nint\nxchk_ag_init(\n\tstruct xfs_scrub\t*sc,\n\txfs_agnumber_t\t\tagno,\n\tstruct xchk_ag\t\t*sa)\n{\n\tint\t\t\terror;\n\n\terror = xchk_ag_read_headers(sc, agno, sa);\n\tif (error)\n\t\treturn error;\n\n\txchk_ag_btcur_init(sc, sa);\n\treturn 0;\n}\n\n \n\nvoid\nxchk_trans_cancel(\n\tstruct xfs_scrub\t*sc)\n{\n\txfs_trans_cancel(sc->tp);\n\tsc->tp = NULL;\n}\n\n \nint\nxchk_trans_alloc(\n\tstruct xfs_scrub\t*sc,\n\tuint\t\t\tresblks)\n{\n\tif (sc->sm->sm_flags & XFS_SCRUB_IFLAG_REPAIR)\n\t\treturn xfs_trans_alloc(sc->mp, &M_RES(sc->mp)->tr_itruncate,\n\t\t\t\tresblks, 0, 0, &sc->tp);\n\n\treturn xfs_trans_alloc_empty(sc->mp, &sc->tp);\n}\n\n \nint\nxchk_setup_fs(\n\tstruct xfs_scrub\t*sc)\n{\n\tuint\t\t\tresblks;\n\n\tresblks = xrep_calc_ag_resblks(sc);\n\treturn xchk_trans_alloc(sc, resblks);\n}\n\n \nint\nxchk_setup_ag_btree(\n\tstruct xfs_scrub\t*sc,\n\tbool\t\t\tforce_log)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\tint\t\t\terror;\n\n\t \n\tif (force_log) {\n\t\terror = xchk_checkpoint_log(mp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = xchk_setup_fs(sc);\n\tif (error)\n\t\treturn error;\n\n\treturn xchk_ag_init(sc, sc->sm->sm_agno, &sc->sa);\n}\n\n \nint\nxchk_checkpoint_log(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\terror;\n\n\terror = xfs_log_force(mp, XFS_LOG_SYNC);\n\tif (error)\n\t\treturn error;\n\txfs_ail_push_all_sync(mp->m_ail);\n\treturn 0;\n}\n\n \nint\nxchk_iget(\n\tstruct xfs_scrub\t*sc,\n\txfs_ino_t\t\tinum,\n\tstruct xfs_inode\t**ipp)\n{\n\treturn xfs_iget(sc->mp, sc->tp, inum, XFS_IGET_UNTRUSTED, 0, ipp);\n}\n\n \nint\nxchk_iget_agi(\n\tstruct xfs_scrub\t*sc,\n\txfs_ino_t\t\tinum,\n\tstruct xfs_buf\t\t**agi_bpp,\n\tstruct xfs_inode\t**ipp)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\tstruct xfs_trans\t*tp = sc->tp;\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror;\n\n\tASSERT(sc->tp != NULL);\n\nagain:\n\t*agi_bpp = NULL;\n\t*ipp = NULL;\n\terror = 0;\n\n\tif (xchk_should_terminate(sc, &error))\n\t\treturn error;\n\n\t \n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, inum));\n\terror = xfs_ialloc_read_agi(pag, tp, agi_bpp);\n\txfs_perag_put(pag);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_iget(mp, tp, inum,\n\t\t\tXFS_IGET_NORETRY | XFS_IGET_UNTRUSTED, 0, ipp);\n\tif (error == -EAGAIN) {\n\t\t \n\t\txfs_trans_brelse(tp, *agi_bpp);\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\tif (error)\n\t\treturn error;\n\n\t \n\tASSERT(*ipp != NULL);\n\txfs_trans_brelse(tp, *agi_bpp);\n\t*agi_bpp = NULL;\n\treturn 0;\n}\n\n \nint\nxchk_install_handle_inode(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_inode\t*ip)\n{\n\tif (VFS_I(ip)->i_generation != sc->sm->sm_gen) {\n\t\txchk_irele(sc, ip);\n\t\treturn -ENOENT;\n\t}\n\n\tsc->ip = ip;\n\treturn 0;\n}\n\n \nint\nxchk_install_live_inode(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_inode\t*ip)\n{\n\tif (!igrab(VFS_I(ip))) {\n\t\txchk_ino_set_corrupt(sc, ip->i_ino);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tsc->ip = ip;\n\treturn 0;\n}\n\n \nint\nxchk_iget_for_scrubbing(\n\tstruct xfs_scrub\t*sc)\n{\n\tstruct xfs_imap\t\timap;\n\tstruct xfs_mount\t*mp = sc->mp;\n\tstruct xfs_perag\t*pag;\n\tstruct xfs_buf\t\t*agi_bp;\n\tstruct xfs_inode\t*ip_in = XFS_I(file_inode(sc->file));\n\tstruct xfs_inode\t*ip = NULL;\n\txfs_agnumber_t\t\tagno = XFS_INO_TO_AGNO(mp, sc->sm->sm_ino);\n\tint\t\t\terror;\n\n\tASSERT(sc->tp == NULL);\n\n\t \n\tif (sc->sm->sm_ino == 0 || sc->sm->sm_ino == ip_in->i_ino)\n\t\treturn xchk_install_live_inode(sc, ip_in);\n\n\t \n\tif (xfs_internal_inum(mp, sc->sm->sm_ino))\n\t\treturn -ENOENT;\n\tif (!xfs_verify_ino(sc->mp, sc->sm->sm_ino))\n\t\treturn -ENOENT;\n\n\t \n\terror = xchk_iget(sc, sc->sm->sm_ino, &ip);\n\tif (!error)\n\t\treturn xchk_install_handle_inode(sc, ip);\n\tif (error == -ENOENT)\n\t\treturn error;\n\tif (error != -EINVAL)\n\t\tgoto out_error;\n\n\t \n\terror = xchk_trans_alloc(sc, 0);\n\tif (error)\n\t\tgoto out_error;\n\n\terror = xchk_iget_agi(sc, sc->sm->sm_ino, &agi_bp, &ip);\n\tif (error == 0) {\n\t\t \n\t\txchk_trans_cancel(sc);\n\t\treturn xchk_install_handle_inode(sc, ip);\n\t}\n\tif (error == -ENOENT)\n\t\tgoto out_gone;\n\tif (error != -EINVAL)\n\t\tgoto out_cancel;\n\n\t \n\tif (agi_bp == NULL) {\n\t\tASSERT(agi_bp != NULL);\n\t\terror = -ECANCELED;\n\t\tgoto out_cancel;\n\t}\n\n\t \n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, sc->sm->sm_ino));\n\tif (!pag) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_cancel;\n\t}\n\n\terror = xfs_imap(pag, sc->tp, sc->sm->sm_ino, &imap,\n\t\t\tXFS_IGET_UNTRUSTED);\n\txfs_perag_put(pag);\n\tif (error == -EINVAL || error == -ENOENT)\n\t\tgoto out_gone;\n\tif (!error)\n\t\terror = -EFSCORRUPTED;\n\nout_cancel:\n\txchk_trans_cancel(sc);\nout_error:\n\ttrace_xchk_op_error(sc, agno, XFS_INO_TO_AGBNO(mp, sc->sm->sm_ino),\n\t\t\terror, __return_address);\n\treturn error;\nout_gone:\n\t \n\txchk_trans_cancel(sc);\n\treturn -ENOENT;\n}\n\n \nvoid\nxchk_irele(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_inode\t*ip)\n{\n\tif (current->journal_info != NULL) {\n\t\tASSERT(current->journal_info == sc->tp);\n\n\t\t \n\t\tspin_lock(&VFS_I(ip)->i_lock);\n\t\tVFS_I(ip)->i_state &= ~I_DONTCACHE;\n\t\tspin_unlock(&VFS_I(ip)->i_lock);\n\t} else if (atomic_read(&VFS_I(ip)->i_count) == 1) {\n\t\t \n\t\td_mark_dontcache(VFS_I(ip));\n\t}\n\n\txfs_irele(ip);\n}\n\n \nint\nxchk_setup_inode_contents(\n\tstruct xfs_scrub\t*sc,\n\tunsigned int\t\tresblks)\n{\n\tint\t\t\terror;\n\n\terror = xchk_iget_for_scrubbing(sc);\n\tif (error)\n\t\treturn error;\n\n\t \n\txchk_ilock(sc, XFS_IOLOCK_EXCL);\n\n\terror = xchk_trans_alloc(sc, resblks);\n\tif (error)\n\t\tgoto out;\n\txchk_ilock(sc, XFS_ILOCK_EXCL);\nout:\n\t \n\treturn error;\n}\n\nvoid\nxchk_ilock(\n\tstruct xfs_scrub\t*sc,\n\tunsigned int\t\tilock_flags)\n{\n\txfs_ilock(sc->ip, ilock_flags);\n\tsc->ilock_flags |= ilock_flags;\n}\n\nbool\nxchk_ilock_nowait(\n\tstruct xfs_scrub\t*sc,\n\tunsigned int\t\tilock_flags)\n{\n\tif (xfs_ilock_nowait(sc->ip, ilock_flags)) {\n\t\tsc->ilock_flags |= ilock_flags;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid\nxchk_iunlock(\n\tstruct xfs_scrub\t*sc,\n\tunsigned int\t\tilock_flags)\n{\n\tsc->ilock_flags &= ~ilock_flags;\n\txfs_iunlock(sc->ip, ilock_flags);\n}\n\n \nbool\nxchk_should_check_xref(\n\tstruct xfs_scrub\t*sc,\n\tint\t\t\t*error,\n\tstruct xfs_btree_cur\t**curpp)\n{\n\t \n\tif (xchk_skip_xref(sc->sm))\n\t\treturn false;\n\n\tif (*error == 0)\n\t\treturn true;\n\n\tif (curpp) {\n\t\t \n\t\tif (!*curpp)\n\t\t\treturn false;\n\n\t\t \n\t\txfs_btree_del_cursor(*curpp, XFS_BTREE_ERROR);\n\t\t*curpp = NULL;\n\t}\n\n\tsc->sm->sm_flags |= XFS_SCRUB_OFLAG_XFAIL;\n\ttrace_xchk_xref_error(sc, *error, __return_address);\n\n\t \n\t*error = 0;\n\treturn false;\n}\n\n \nvoid\nxchk_buffer_recheck(\n\tstruct xfs_scrub\t*sc,\n\tstruct xfs_buf\t\t*bp)\n{\n\txfs_failaddr_t\t\tfa;\n\n\tif (bp->b_ops == NULL) {\n\t\txchk_block_set_corrupt(sc, bp);\n\t\treturn;\n\t}\n\tif (bp->b_ops->verify_struct == NULL) {\n\t\txchk_set_incomplete(sc);\n\t\treturn;\n\t}\n\tfa = bp->b_ops->verify_struct(bp);\n\tif (!fa)\n\t\treturn;\n\tsc->sm->sm_flags |= XFS_SCRUB_OFLAG_CORRUPT;\n\ttrace_xchk_block_error(sc, xfs_buf_daddr(bp), fa);\n}\n\nstatic inline int\nxchk_metadata_inode_subtype(\n\tstruct xfs_scrub\t*sc,\n\tunsigned int\t\tscrub_type)\n{\n\t__u32\t\t\tsmtype = sc->sm->sm_type;\n\tint\t\t\terror;\n\n\tsc->sm->sm_type = scrub_type;\n\n\tswitch (scrub_type) {\n\tcase XFS_SCRUB_TYPE_INODE:\n\t\terror = xchk_inode(sc);\n\t\tbreak;\n\tcase XFS_SCRUB_TYPE_BMBTD:\n\t\terror = xchk_bmap_data(sc);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tbreak;\n\t}\n\n\tsc->sm->sm_type = smtype;\n\treturn error;\n}\n\n \nint\nxchk_metadata_inode_forks(\n\tstruct xfs_scrub\t*sc)\n{\n\tbool\t\t\tshared;\n\tint\t\t\terror;\n\n\tif (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT)\n\t\treturn 0;\n\n\t \n\terror = xchk_metadata_inode_subtype(sc, XFS_SCRUB_TYPE_INODE);\n\tif (error || (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT))\n\t\treturn error;\n\n\t \n\tif (sc->ip->i_diflags & XFS_DIFLAG_REALTIME) {\n\t\txchk_ino_set_corrupt(sc, sc->ip->i_ino);\n\t\treturn 0;\n\t}\n\n\t \n\tif (xfs_is_reflink_inode(sc->ip)) {\n\t\txchk_ino_set_corrupt(sc, sc->ip->i_ino);\n\t\treturn 0;\n\t}\n\n\t \n\tif (xfs_inode_hasattr(sc->ip)) {\n\t\txchk_ino_set_corrupt(sc, sc->ip->i_ino);\n\t\treturn 0;\n\t}\n\n\t \n\terror = xchk_metadata_inode_subtype(sc, XFS_SCRUB_TYPE_BMBTD);\n\tif (error || (sc->sm->sm_flags & XFS_SCRUB_OFLAG_CORRUPT))\n\t\treturn error;\n\n\t \n\tif (xfs_has_reflink(sc->mp)) {\n\t\terror = xfs_reflink_inode_has_shared_extents(sc->tp, sc->ip,\n\t\t\t\t&shared);\n\t\tif (!xchk_fblock_process_error(sc, XFS_DATA_FORK, 0,\n\t\t\t\t&error))\n\t\t\treturn error;\n\t\tif (shared)\n\t\t\txchk_ino_set_corrupt(sc, sc->ip->i_ino);\n\t}\n\n\treturn 0;\n}\n\n \nvoid\nxchk_fsgates_enable(\n\tstruct xfs_scrub\t*sc,\n\tunsigned int\t\tscrub_fsgates)\n{\n\tASSERT(!(scrub_fsgates & ~XCHK_FSGATES_ALL));\n\tASSERT(!(sc->flags & scrub_fsgates));\n\n\ttrace_xchk_fsgates_enable(sc, scrub_fsgates);\n\n\tif (scrub_fsgates & XCHK_FSGATES_DRAIN)\n\t\txfs_drain_wait_enable();\n\n\tsc->flags |= scrub_fsgates;\n}\n\n \nint\nxchk_inode_is_allocated(\n\tstruct xfs_scrub\t*sc,\n\txfs_agino_t\t\tagino,\n\tbool\t\t\t*inuse)\n{\n\tstruct xfs_mount\t*mp = sc->mp;\n\tstruct xfs_perag\t*pag = sc->sa.pag;\n\txfs_ino_t\t\tino;\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\n\t \n\tif (pag == NULL) {\n\t\tASSERT(pag != NULL);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (sc->sa.agi_bp == NULL) {\n\t\tASSERT(sc->sa.agi_bp != NULL);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tino = XFS_AGINO_TO_INO(sc->mp, pag->pag_agno, agino);\n\tif (!xfs_verify_ino(mp, ino))\n\t\treturn -EINVAL;\n\n\terror = -ENODATA;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\tif (!ip) {\n\t\t \n\t\tgoto out_rcu;\n\t}\n\n\t \n\tspin_lock(&ip->i_flags_lock);\n\tif (ip->i_ino != ino)\n\t\tgoto out_skip;\n\n\ttrace_xchk_inode_is_allocated(ip);\n\n\t \n\n#ifdef DEBUG\n\t \n\tif (!(ip->i_flags & (XFS_NEED_INACTIVE | XFS_INEW | XFS_IRECLAIMABLE |\n\t\t\t     XFS_INACTIVATING))) {\n\t\t \n\t\tASSERT(VFS_I(ip)->i_mode != 0);\n\t}\n\n\t \n\tif (ip->i_flags & XFS_INEW) {\n\t\t \n\t\tASSERT(VFS_I(ip)->i_mode != 0);\n\t}\n\n\t \n\tif ((ip->i_flags & XFS_NEED_INACTIVE) &&\n\t    !(ip->i_flags & XFS_INACTIVATING)) {\n\t\t \n\t\tASSERT(VFS_I(ip)->i_mode != 0);\n\t}\n#endif\n\n\t \n\n\t \n\n\t \n\n\t \n\n\t*inuse = VFS_I(ip)->i_mode != 0;\n\terror = 0;\n\nout_skip:\n\tspin_unlock(&ip->i_flags_lock);\nout_rcu:\n\trcu_read_unlock();\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}