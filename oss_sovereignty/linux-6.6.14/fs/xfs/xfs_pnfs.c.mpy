{
  "module_name": "xfs_pnfs.c",
  "hash_id": "c0a0513b89943535a482eefbeb085c406c378674c2aeca2ddc9933bcb77c8838",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_pnfs.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_pnfs.h\"\n\n \nint\nxfs_break_leased_layouts(\n\tstruct inode\t\t*inode,\n\tuint\t\t\t*iolock,\n\tbool\t\t\t*did_unlock)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\terror;\n\n\twhile ((error = break_layout(inode, false)) == -EWOULDBLOCK) {\n\t\txfs_iunlock(ip, *iolock);\n\t\t*did_unlock = true;\n\t\terror = break_layout(inode, true);\n\t\t*iolock &= ~XFS_IOLOCK_SHARED;\n\t\t*iolock |= XFS_IOLOCK_EXCL;\n\t\txfs_ilock(ip, *iolock);\n\t}\n\n\treturn error;\n}\n\n \nint\nxfs_fs_get_uuid(\n\tstruct super_block\t*sb,\n\tu8\t\t\t*buf,\n\tu32\t\t\t*len,\n\tu64\t\t\t*offset)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\txfs_notice_once(mp,\n\"Using experimental pNFS feature, use at your own risk!\");\n\n\tif (*len < sizeof(uuid_t))\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, &mp->m_sb.sb_uuid, sizeof(uuid_t));\n\t*len = sizeof(uuid_t);\n\t*offset = offsetof(struct xfs_dsb, sb_uuid);\n\treturn 0;\n}\n\n \nstatic int\nxfs_fs_map_update_inode(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\terror = xfs_trans_alloc(ip->i_mount, &M_RES(ip->i_mount)->tr_writeid,\n\t\t\t0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\tVFS_I(ip)->i_mode &= ~S_ISUID;\n\tif (VFS_I(ip)->i_mode & S_IXGRP)\n\t\tVFS_I(ip)->i_mode &= ~S_ISGID;\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\tip->i_diflags |= XFS_DIFLAG_PREALLOC;\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\treturn xfs_trans_commit(tp);\n}\n\n \nint\nxfs_fs_map_blocks(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\toffset,\n\tu64\t\t\tlength,\n\tstruct iomap\t\t*iomap,\n\tbool\t\t\twrite,\n\tu32\t\t\t*device_generation)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_bmbt_irec\timap;\n\txfs_fileoff_t\t\toffset_fsb, end_fsb;\n\tloff_t\t\t\tlimit;\n\tint\t\t\tbmapi_flags = XFS_BMAPI_ENTIRE;\n\tint\t\t\tnimaps = 1;\n\tuint\t\t\tlock_flags;\n\tint\t\t\terror = 0;\n\tu64\t\t\tseq;\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\t \n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn -ENXIO;\n\n\t \n\tif (xfs_is_reflink_inode(ip))\n\t\treturn -ENXIO;\n\n\t \n\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n\n\terror = -EINVAL;\n\tlimit = mp->m_super->s_maxbytes;\n\tif (!write)\n\t\tlimit = max(limit, round_up(i_size_read(inode),\n\t\t\t\t     inode->i_sb->s_blocksize));\n\tif (offset > limit)\n\t\tgoto out_unlock;\n\tif (offset > limit - length)\n\t\tlength = limit - offset;\n\n\terror = filemap_write_and_wait(inode->i_mapping);\n\tif (error)\n\t\tgoto out_unlock;\n\terror = invalidate_inode_pages2(inode->i_mapping);\n\tif (WARN_ON_ONCE(error))\n\t\tgoto out_unlock;\n\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + length);\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\n\tlock_flags = xfs_ilock_data_map_shared(ip);\n\terror = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb,\n\t\t\t\t&imap, &nimaps, bmapi_flags);\n\tseq = xfs_iomap_inode_sequence(ip, 0);\n\n\tASSERT(!nimaps || imap.br_startblock != DELAYSTARTBLOCK);\n\n\tif (!error && write &&\n\t    (!nimaps || imap.br_startblock == HOLESTARTBLOCK)) {\n\t\tif (offset + length > XFS_ISIZE(ip))\n\t\t\tend_fsb = xfs_iomap_eof_align_last_fsb(ip, end_fsb);\n\t\telse if (nimaps && imap.br_startblock == HOLESTARTBLOCK)\n\t\t\tend_fsb = min(end_fsb, imap.br_startoff +\n\t\t\t\t\t       imap.br_blockcount);\n\t\txfs_iunlock(ip, lock_flags);\n\n\t\terror = xfs_iomap_write_direct(ip, offset_fsb,\n\t\t\t\tend_fsb - offset_fsb, 0, &imap, &seq);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\n\t\t \n\t\terror = xfs_fs_map_update_inode(ip);\n\t\tif (!error)\n\t\t\terror = xfs_log_force_inode(ip);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\n\t} else {\n\t\txfs_iunlock(ip, lock_flags);\n\t}\n\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\n\terror = xfs_bmbt_to_iomap(ip, iomap, &imap, 0, 0, seq);\n\t*device_generation = mp->m_generation;\n\treturn error;\nout_unlock:\n\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\treturn error;\n}\n\n \nstatic int\nxfs_pnfs_validate_isize(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\tisize)\n{\n\tstruct xfs_bmbt_irec\timap;\n\tint\t\t\tnimaps = 1;\n\tint\t\t\terror = 0;\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\terror = xfs_bmapi_read(ip, XFS_B_TO_FSBT(ip->i_mount, isize - 1), 1,\n\t\t\t\t&imap, &nimaps, 0);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\tif (error)\n\t\treturn error;\n\n\tif (imap.br_startblock == HOLESTARTBLOCK ||\n\t    imap.br_startblock == DELAYSTARTBLOCK ||\n\t    imap.br_state == XFS_EXT_UNWRITTEN)\n\t\treturn -EIO;\n\treturn 0;\n}\n\n \nint\nxfs_fs_commit_blocks(\n\tstruct inode\t\t*inode,\n\tstruct iomap\t\t*maps,\n\tint\t\t\tnr_maps,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tbool\t\t\tupdate_isize = false;\n\tint\t\t\terror, i;\n\tloff_t\t\t\tsize;\n\n\tASSERT(iattr->ia_valid & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME));\n\n\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n\n\tsize = i_size_read(inode);\n\tif ((iattr->ia_valid & ATTR_SIZE) && iattr->ia_size > size) {\n\t\tupdate_isize = true;\n\t\tsize = iattr->ia_size;\n\t}\n\n\tfor (i = 0; i < nr_maps; i++) {\n\t\tu64 start, length, end;\n\n\t\tstart = maps[i].offset;\n\t\tif (start > size)\n\t\t\tcontinue;\n\n\t\tend = start + maps[i].length;\n\t\tif (end > size)\n\t\t\tend = size;\n\n\t\tlength = end - start;\n\t\tif (!length)\n\t\t\tcontinue;\n\n\t\t \n\t\terror = invalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\tstart >> PAGE_SHIFT,\n\t\t\t\t\t(end - 1) >> PAGE_SHIFT);\n\t\tWARN_ON_ONCE(error);\n\n\t\terror = xfs_iomap_write_unwritten(ip, start, length, false);\n\t\tif (error)\n\t\t\tgoto out_drop_iolock;\n\t}\n\n\tif (update_isize) {\n\t\terror = xfs_pnfs_validate_isize(ip, size);\n\t\tif (error)\n\t\t\tgoto out_drop_iolock;\n\t}\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_ichange, 0, 0, 0, &tp);\n\tif (error)\n\t\tgoto out_drop_iolock;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tASSERT(!(iattr->ia_valid & (ATTR_UID | ATTR_GID)));\n\tsetattr_copy(&nop_mnt_idmap, inode, iattr);\n\tif (update_isize) {\n\t\ti_size_write(inode, iattr->ia_size);\n\t\tip->i_disk_size = iattr->ia_size;\n\t}\n\n\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp);\n\nout_drop_iolock:\n\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}