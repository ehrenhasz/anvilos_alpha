{
  "module_name": "xfs_inode_item.c",
  "hash_id": "c25e966525c2d9fb208de92bb437c7902ab5cdc2fbf01c95c92b0da34f8ee244",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_inode_item.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_log.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_error.h\"\n\n#include <linux/iversion.h>\n\nstruct kmem_cache\t*xfs_ili_cache;\t\t \n\nstatic inline struct xfs_inode_log_item *INODE_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_inode_log_item, ili_item);\n}\n\nstatic uint64_t\nxfs_inode_item_sort(\n\tstruct xfs_log_item\t*lip)\n{\n\treturn INODE_ITEM(lip)->ili_inode->i_ino;\n}\n\n \nstatic int\nxfs_inode_item_precommit(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_inode_log_item *iip = INODE_ITEM(lip);\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tunsigned int\t\tflags = iip->ili_dirty_flags;\n\n\t \n\tif (inode->i_state & I_DIRTY_TIME) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\n\t \n\tif ((flags & (XFS_ILOG_CORE | XFS_ILOG_TIMESTAMP)) &&\n\t    xfs_has_bigtime(ip->i_mount) &&\n\t    !xfs_inode_has_bigtime(ip)) {\n\t\tip->i_diflags2 |= XFS_DIFLAG2_BIGTIME;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\t \n\tif ((ip->i_diflags & XFS_DIFLAG_RTINHERIT) &&\n\t    (ip->i_diflags & XFS_DIFLAG_EXTSZINHERIT) &&\n\t    (ip->i_extsize % ip->i_mount->m_sb.sb_rextsize) > 0) {\n\t\tip->i_diflags &= ~(XFS_DIFLAG_EXTSIZE |\n\t\t\t\t   XFS_DIFLAG_EXTSZINHERIT);\n\t\tip->i_extsize = 0;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\t \n\tspin_lock(&iip->ili_lock);\n\tiip->ili_fsync_fields |= (flags & ~XFS_ILOG_IVERSION);\n\tif (flags & XFS_ILOG_IVERSION)\n\t\tflags = ((flags & ~XFS_ILOG_IVERSION) | XFS_ILOG_CORE);\n\n\tif (!iip->ili_item.li_buf) {\n\t\tstruct xfs_buf\t*bp;\n\t\tint\t\terror;\n\n\t\t \n\t\tspin_unlock(&iip->ili_lock);\n\t\terror = xfs_imap_to_bp(ip->i_mount, tp, &ip->i_imap, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\txfs_buf_hold(bp);\n\t\tspin_lock(&iip->ili_lock);\n\t\tiip->ili_item.li_buf = bp;\n\t\tbp->b_flags |= _XBF_INODES;\n\t\tlist_add_tail(&iip->ili_item.li_bio_list, &bp->b_li_list);\n\t\txfs_trans_brelse(tp, bp);\n\t}\n\n\t \n\tiip->ili_fields |= (flags | iip->ili_last_fields);\n\tspin_unlock(&iip->ili_lock);\n\n\t \n\tiip->ili_dirty_flags = 0;\n\treturn 0;\n}\n\n \nSTATIC void\nxfs_inode_item_data_fork_size(\n\tstruct xfs_inode_log_item *iip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\n\tswitch (ip->i_df.if_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif ((iip->ili_fields & XFS_ILOG_DEXT) &&\n\t\t    ip->i_df.if_nextents > 0 &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\t \n\t\t\t*nbytes += xfs_inode_data_fork_size(ip);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif ((iip->ili_fields & XFS_ILOG_DBROOT) &&\n\t\t    ip->i_df.if_broot_bytes > 0) {\n\t\t\t*nbytes += ip->i_df.if_broot_bytes;\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif ((iip->ili_fields & XFS_ILOG_DDATA) &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\t*nbytes += xlog_calc_iovec_len(ip->i_df.if_bytes);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_DEV:\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}\n\nSTATIC void\nxfs_inode_item_attr_fork_size(\n\tstruct xfs_inode_log_item *iip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\n\tswitch (ip->i_af.if_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif ((iip->ili_fields & XFS_ILOG_AEXT) &&\n\t\t    ip->i_af.if_nextents > 0 &&\n\t\t    ip->i_af.if_bytes > 0) {\n\t\t\t \n\t\t\t*nbytes += xfs_inode_attr_fork_size(ip);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif ((iip->ili_fields & XFS_ILOG_ABROOT) &&\n\t\t    ip->i_af.if_broot_bytes > 0) {\n\t\t\t*nbytes += ip->i_af.if_broot_bytes;\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif ((iip->ili_fields & XFS_ILOG_ADATA) &&\n\t\t    ip->i_af.if_bytes > 0) {\n\t\t\t*nbytes += xlog_calc_iovec_len(ip->i_af.if_bytes);\n\t\t\t*nvecs += 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}\n\n \nSTATIC void\nxfs_inode_item_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_inode_log_item *iip = INODE_ITEM(lip);\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\n\t*nvecs += 2;\n\t*nbytes += sizeof(struct xfs_inode_log_format) +\n\t\t   xfs_log_dinode_size(ip->i_mount);\n\n\txfs_inode_item_data_fork_size(iip, nvecs, nbytes);\n\tif (xfs_inode_has_attr_fork(ip))\n\t\txfs_inode_item_attr_fork_size(iip, nvecs, nbytes);\n}\n\nSTATIC void\nxfs_inode_item_format_data_fork(\n\tstruct xfs_inode_log_item *iip,\n\tstruct xfs_inode_log_format *ilf,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tsize_t\t\t\tdata_bytes;\n\n\tswitch (ip->i_df.if_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DBROOT | XFS_ILOG_DEV);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_DEXT) &&\n\t\t    ip->i_df.if_nextents > 0 &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\tstruct xfs_bmbt_rec *p;\n\n\t\t\tASSERT(xfs_iext_count(&ip->i_df) > 0);\n\n\t\t\tp = xlog_prepare_iovec(lv, vecp, XLOG_REG_TYPE_IEXT);\n\t\t\tdata_bytes = xfs_iextents_copy(ip, p, XFS_DATA_FORK);\n\t\t\txlog_finish_iovec(lv, *vecp, data_bytes);\n\n\t\t\tASSERT(data_bytes <= ip->i_df.if_bytes);\n\n\t\t\tilf->ilf_dsize = data_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_DEXT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DEXT | XFS_ILOG_DEV);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_DBROOT) &&\n\t\t    ip->i_df.if_broot_bytes > 0) {\n\t\t\tASSERT(ip->i_df.if_broot != NULL);\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IBROOT,\n\t\t\t\t\tip->i_df.if_broot,\n\t\t\t\t\tip->i_df.if_broot_bytes);\n\t\t\tilf->ilf_dsize = ip->i_df.if_broot_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tASSERT(!(iip->ili_fields &\n\t\t\t\t XFS_ILOG_DBROOT));\n\t\t\tiip->ili_fields &= ~XFS_ILOG_DBROOT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DEXT | XFS_ILOG_DBROOT | XFS_ILOG_DEV);\n\t\tif ((iip->ili_fields & XFS_ILOG_DDATA) &&\n\t\t    ip->i_df.if_bytes > 0) {\n\t\t\tASSERT(ip->i_df.if_u1.if_data != NULL);\n\t\t\tASSERT(ip->i_disk_size > 0);\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_ILOCAL,\n\t\t\t\t\tip->i_df.if_u1.if_data,\n\t\t\t\t\tip->i_df.if_bytes);\n\t\t\tilf->ilf_dsize = (unsigned)ip->i_df.if_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_DDATA;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_DEV:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_DDATA | XFS_ILOG_DBROOT | XFS_ILOG_DEXT);\n\t\tif (iip->ili_fields & XFS_ILOG_DEV)\n\t\t\tilf->ilf_u.ilfu_rdev = sysv_encode_dev(VFS_I(ip)->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}\n\nSTATIC void\nxfs_inode_item_format_attr_fork(\n\tstruct xfs_inode_log_item *iip,\n\tstruct xfs_inode_log_format *ilf,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp)\n{\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tsize_t\t\t\tdata_bytes;\n\n\tswitch (ip->i_af.if_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_ADATA | XFS_ILOG_ABROOT);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_AEXT) &&\n\t\t    ip->i_af.if_nextents > 0 &&\n\t\t    ip->i_af.if_bytes > 0) {\n\t\t\tstruct xfs_bmbt_rec *p;\n\n\t\t\tASSERT(xfs_iext_count(&ip->i_af) ==\n\t\t\t\tip->i_af.if_nextents);\n\n\t\t\tp = xlog_prepare_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_EXT);\n\t\t\tdata_bytes = xfs_iextents_copy(ip, p, XFS_ATTR_FORK);\n\t\t\txlog_finish_iovec(lv, *vecp, data_bytes);\n\n\t\t\tilf->ilf_asize = data_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_AEXT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_ADATA | XFS_ILOG_AEXT);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_ABROOT) &&\n\t\t    ip->i_af.if_broot_bytes > 0) {\n\t\t\tASSERT(ip->i_af.if_broot != NULL);\n\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_BROOT,\n\t\t\t\t\tip->i_af.if_broot,\n\t\t\t\t\tip->i_af.if_broot_bytes);\n\t\t\tilf->ilf_asize = ip->i_af.if_broot_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_ABROOT;\n\t\t}\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_AEXT | XFS_ILOG_ABROOT);\n\n\t\tif ((iip->ili_fields & XFS_ILOG_ADATA) &&\n\t\t    ip->i_af.if_bytes > 0) {\n\t\t\tASSERT(ip->i_af.if_u1.if_data != NULL);\n\t\t\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_LOCAL,\n\t\t\t\t\tip->i_af.if_u1.if_data,\n\t\t\t\t\tip->i_af.if_bytes);\n\t\t\tilf->ilf_asize = (unsigned)ip->i_af.if_bytes;\n\t\t\tilf->ilf_size++;\n\t\t} else {\n\t\t\tiip->ili_fields &= ~XFS_ILOG_ADATA;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}\n\n \nstatic inline xfs_log_timestamp_t\nxfs_inode_to_log_dinode_ts(\n\tstruct xfs_inode\t\t*ip,\n\tconst struct timespec64\t\ttv)\n{\n\tstruct xfs_log_legacy_timestamp\t*lits;\n\txfs_log_timestamp_t\t\tits;\n\n\tif (xfs_inode_has_bigtime(ip))\n\t\treturn xfs_inode_encode_bigtime(tv);\n\n\tlits = (struct xfs_log_legacy_timestamp *)&its;\n\tlits->t_sec = tv.tv_sec;\n\tlits->t_nsec = tv.tv_nsec;\n\n\treturn its;\n}\n\n \nstatic void\nxfs_copy_dm_fields_to_log_dinode(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_log_dinode\t*to)\n{\n\tstruct xfs_dinode\t*dip;\n\n\tdip = xfs_buf_offset(ip->i_itemp->ili_item.li_buf,\n\t\t\t     ip->i_imap.im_boffset);\n\n\tif (xfs_iflags_test(ip, XFS_IPRESERVE_DM_FIELDS)) {\n\t\tto->di_dmevmask = be32_to_cpu(dip->di_dmevmask);\n\t\tto->di_dmstate = be16_to_cpu(dip->di_dmstate);\n\t} else {\n\t\tto->di_dmevmask = 0;\n\t\tto->di_dmstate = 0;\n\t}\n}\n\nstatic inline void\nxfs_inode_to_log_dinode_iext_counters(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_log_dinode\t*to)\n{\n\tif (xfs_inode_has_large_extent_counts(ip)) {\n\t\tto->di_big_nextents = xfs_ifork_nextents(&ip->i_df);\n\t\tto->di_big_anextents = xfs_ifork_nextents(&ip->i_af);\n\t\tto->di_nrext64_pad = 0;\n\t} else {\n\t\tto->di_nextents = xfs_ifork_nextents(&ip->i_df);\n\t\tto->di_anextents = xfs_ifork_nextents(&ip->i_af);\n\t}\n}\n\nstatic void\nxfs_inode_to_log_dinode(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_log_dinode\t*to,\n\txfs_lsn_t\t\tlsn)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\tto->di_magic = XFS_DINODE_MAGIC;\n\tto->di_format = xfs_ifork_format(&ip->i_df);\n\tto->di_uid = i_uid_read(inode);\n\tto->di_gid = i_gid_read(inode);\n\tto->di_projid_lo = ip->i_projid & 0xffff;\n\tto->di_projid_hi = ip->i_projid >> 16;\n\n\tmemset(to->di_pad3, 0, sizeof(to->di_pad3));\n\tto->di_atime = xfs_inode_to_log_dinode_ts(ip, inode->i_atime);\n\tto->di_mtime = xfs_inode_to_log_dinode_ts(ip, inode->i_mtime);\n\tto->di_ctime = xfs_inode_to_log_dinode_ts(ip, inode_get_ctime(inode));\n\tto->di_nlink = inode->i_nlink;\n\tto->di_gen = inode->i_generation;\n\tto->di_mode = inode->i_mode;\n\n\tto->di_size = ip->i_disk_size;\n\tto->di_nblocks = ip->i_nblocks;\n\tto->di_extsize = ip->i_extsize;\n\tto->di_forkoff = ip->i_forkoff;\n\tto->di_aformat = xfs_ifork_format(&ip->i_af);\n\tto->di_flags = ip->i_diflags;\n\n\txfs_copy_dm_fields_to_log_dinode(ip, to);\n\n\t \n\tto->di_next_unlinked = NULLAGINO;\n\n\tif (xfs_has_v3inodes(ip->i_mount)) {\n\t\tto->di_version = 3;\n\t\tto->di_changecount = inode_peek_iversion(inode);\n\t\tto->di_crtime = xfs_inode_to_log_dinode_ts(ip, ip->i_crtime);\n\t\tto->di_flags2 = ip->i_diflags2;\n\t\tto->di_cowextsize = ip->i_cowextsize;\n\t\tto->di_ino = ip->i_ino;\n\t\tto->di_lsn = lsn;\n\t\tmemset(to->di_pad2, 0, sizeof(to->di_pad2));\n\t\tuuid_copy(&to->di_uuid, &ip->i_mount->m_sb.sb_meta_uuid);\n\t\tto->di_v3_pad = 0;\n\t} else {\n\t\tto->di_version = 2;\n\t\tto->di_flushiter = ip->i_flushiter;\n\t\tmemset(to->di_v2_pad, 0, sizeof(to->di_v2_pad));\n\t}\n\n\txfs_inode_to_log_dinode_iext_counters(ip, to);\n}\n\n \nstatic void\nxfs_inode_item_format_core(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp)\n{\n\tstruct xfs_log_dinode\t*dic;\n\n\tdic = xlog_prepare_iovec(lv, vecp, XLOG_REG_TYPE_ICORE);\n\txfs_inode_to_log_dinode(ip, dic, ip->i_itemp->ili_item.li_lsn);\n\txlog_finish_iovec(lv, *vecp, xfs_log_dinode_size(ip->i_mount));\n}\n\n \nSTATIC void\nxfs_inode_item_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_inode_log_item *iip = INODE_ITEM(lip);\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\tstruct xfs_inode_log_format *ilf;\n\n\tilf = xlog_prepare_iovec(lv, &vecp, XLOG_REG_TYPE_IFORMAT);\n\tilf->ilf_type = XFS_LI_INODE;\n\tilf->ilf_ino = ip->i_ino;\n\tilf->ilf_blkno = ip->i_imap.im_blkno;\n\tilf->ilf_len = ip->i_imap.im_len;\n\tilf->ilf_boffset = ip->i_imap.im_boffset;\n\tilf->ilf_fields = XFS_ILOG_CORE;\n\tilf->ilf_size = 2;  \n\n\t \n\tilf->ilf_dsize = 0;\n\tilf->ilf_asize = 0;\n\tilf->ilf_pad = 0;\n\tmemset(&ilf->ilf_u, 0, sizeof(ilf->ilf_u));\n\n\txlog_finish_iovec(lv, vecp, sizeof(*ilf));\n\n\txfs_inode_item_format_core(ip, lv, &vecp);\n\txfs_inode_item_format_data_fork(iip, ilf, lv, &vecp);\n\tif (xfs_inode_has_attr_fork(ip)) {\n\t\txfs_inode_item_format_attr_fork(iip, ilf, lv, &vecp);\n\t} else {\n\t\tiip->ili_fields &=\n\t\t\t~(XFS_ILOG_ADATA | XFS_ILOG_ABROOT | XFS_ILOG_AEXT);\n\t}\n\n\t \n\tilf->ilf_fields |= (iip->ili_fields & ~XFS_ILOG_TIMESTAMP);\n}\n\n \nSTATIC void\nxfs_inode_item_pin(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_inode\t*ip = INODE_ITEM(lip)->ili_inode;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(lip->li_buf);\n\n\ttrace_xfs_inode_pin(ip, _RET_IP_);\n\tatomic_inc(&ip->i_pincount);\n}\n\n\n \nSTATIC void\nxfs_inode_item_unpin(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\tremove)\n{\n\tstruct xfs_inode\t*ip = INODE_ITEM(lip)->ili_inode;\n\n\ttrace_xfs_inode_unpin(ip, _RET_IP_);\n\tASSERT(lip->li_buf || xfs_iflags_test(ip, XFS_ISTALE));\n\tASSERT(atomic_read(&ip->i_pincount) > 0);\n\tif (atomic_dec_and_test(&ip->i_pincount))\n\t\twake_up_bit(&ip->i_flags, __XFS_IPINNED_BIT);\n}\n\nSTATIC uint\nxfs_inode_item_push(\n\tstruct xfs_log_item\t*lip,\n\tstruct list_head\t*buffer_list)\n\t\t__releases(&lip->li_ailp->ail_lock)\n\t\t__acquires(&lip->li_ailp->ail_lock)\n{\n\tstruct xfs_inode_log_item *iip = INODE_ITEM(lip);\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tstruct xfs_buf\t\t*bp = lip->li_buf;\n\tuint\t\t\trval = XFS_ITEM_SUCCESS;\n\tint\t\t\terror;\n\n\tif (!bp || (ip->i_flags & XFS_ISTALE)) {\n\t\t \n\t\treturn XFS_ITEM_PINNED;\n\t}\n\n\tif (xfs_ipincount(ip) > 0 || xfs_buf_ispinned(bp))\n\t\treturn XFS_ITEM_PINNED;\n\n\tif (xfs_iflags_test(ip, XFS_IFLUSHING))\n\t\treturn XFS_ITEM_FLUSHING;\n\n\tif (!xfs_buf_trylock(bp))\n\t\treturn XFS_ITEM_LOCKED;\n\n\tspin_unlock(&lip->li_ailp->ail_lock);\n\n\t \n\txfs_buf_hold(bp);\n\terror = xfs_iflush_cluster(bp);\n\tif (!error) {\n\t\tif (!xfs_buf_delwri_queue(bp, buffer_list))\n\t\t\trval = XFS_ITEM_FLUSHING;\n\t\txfs_buf_relse(bp);\n\t} else {\n\t\t \n\t\tif (error == -EAGAIN)\n\t\t\txfs_buf_relse(bp);\n\t\trval = XFS_ITEM_LOCKED;\n\t}\n\n\tspin_lock(&lip->li_ailp->ail_lock);\n\treturn rval;\n}\n\n \nSTATIC void\nxfs_inode_item_release(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_inode_log_item *iip = INODE_ITEM(lip);\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\tunsigned short\t\tlock_flags;\n\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tlock_flags = iip->ili_lock_flags;\n\tiip->ili_lock_flags = 0;\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n}\n\n \nSTATIC xfs_lsn_t\nxfs_inode_item_committed(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n\tstruct xfs_inode_log_item *iip = INODE_ITEM(lip);\n\tstruct xfs_inode\t*ip = iip->ili_inode;\n\n\tif (xfs_iflags_test(ip, XFS_ISTALE)) {\n\t\txfs_inode_item_unpin(lip, 0);\n\t\treturn -1;\n\t}\n\treturn lsn;\n}\n\nSTATIC void\nxfs_inode_item_committing(\n\tstruct xfs_log_item\t*lip,\n\txfs_csn_t\t\tseq)\n{\n\tINODE_ITEM(lip)->ili_commit_seq = seq;\n\treturn xfs_inode_item_release(lip);\n}\n\nstatic const struct xfs_item_ops xfs_inode_item_ops = {\n\t.iop_sort\t= xfs_inode_item_sort,\n\t.iop_precommit\t= xfs_inode_item_precommit,\n\t.iop_size\t= xfs_inode_item_size,\n\t.iop_format\t= xfs_inode_item_format,\n\t.iop_pin\t= xfs_inode_item_pin,\n\t.iop_unpin\t= xfs_inode_item_unpin,\n\t.iop_release\t= xfs_inode_item_release,\n\t.iop_committed\t= xfs_inode_item_committed,\n\t.iop_push\t= xfs_inode_item_push,\n\t.iop_committing\t= xfs_inode_item_committing,\n};\n\n\n \nvoid\nxfs_inode_item_init(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_inode_log_item *iip;\n\n\tASSERT(ip->i_itemp == NULL);\n\tiip = ip->i_itemp = kmem_cache_zalloc(xfs_ili_cache,\n\t\t\t\t\t      GFP_KERNEL | __GFP_NOFAIL);\n\n\tiip->ili_inode = ip;\n\tspin_lock_init(&iip->ili_lock);\n\txfs_log_item_init(mp, &iip->ili_item, XFS_LI_INODE,\n\t\t\t\t\t\t&xfs_inode_item_ops);\n}\n\n \nvoid\nxfs_inode_item_destroy(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_inode_log_item *iip = ip->i_itemp;\n\n\tASSERT(iip->ili_item.li_buf == NULL);\n\n\tip->i_itemp = NULL;\n\tkmem_free(iip->ili_item.li_lv_shadow);\n\tkmem_cache_free(xfs_ili_cache, iip);\n}\n\n\n \nstatic void\nxfs_iflush_ail_updates(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct list_head\t*list)\n{\n\tstruct xfs_log_item\t*lip;\n\txfs_lsn_t\t\ttail_lsn = 0;\n\n\t \n\tspin_lock(&ailp->ail_lock);\n\tlist_for_each_entry(lip, list, li_bio_list) {\n\t\txfs_lsn_t\tlsn;\n\n\t\tclear_bit(XFS_LI_FAILED, &lip->li_flags);\n\t\tif (INODE_ITEM(lip)->ili_flush_lsn != lip->li_lsn)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!test_bit(XFS_LI_IN_AIL, &lip->li_flags)) {\n\t\t\tASSERT(xlog_is_shutdown(lip->li_log));\n\t\t\tcontinue;\n\t\t}\n\n\t\tlsn = xfs_ail_delete_one(ailp, lip);\n\t\tif (!tail_lsn && lsn)\n\t\t\ttail_lsn = lsn;\n\t}\n\txfs_ail_update_finish(ailp, tail_lsn);\n}\n\n \nstatic void\nxfs_iflush_finish(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tstruct xfs_log_item\t*lip, *n;\n\n\tlist_for_each_entry_safe(lip, n, list, li_bio_list) {\n\t\tstruct xfs_inode_log_item *iip = INODE_ITEM(lip);\n\t\tbool\tdrop_buffer = false;\n\n\t\tspin_lock(&iip->ili_lock);\n\n\t\t \n\t\tASSERT(iip->ili_item.li_buf == bp);\n\t\tif (!iip->ili_fields) {\n\t\t\tiip->ili_item.li_buf = NULL;\n\t\t\tlist_del_init(&lip->li_bio_list);\n\t\t\tdrop_buffer = true;\n\t\t}\n\t\tiip->ili_last_fields = 0;\n\t\tiip->ili_flush_lsn = 0;\n\t\tspin_unlock(&iip->ili_lock);\n\t\txfs_iflags_clear(iip->ili_inode, XFS_IFLUSHING);\n\t\tif (drop_buffer)\n\t\t\txfs_buf_rele(bp);\n\t}\n}\n\n \nvoid\nxfs_buf_inode_iodone(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_log_item\t*lip, *n;\n\tLIST_HEAD(flushed_inodes);\n\tLIST_HEAD(ail_updates);\n\n\t \n\tlist_for_each_entry_safe(lip, n, &bp->b_li_list, li_bio_list) {\n\t\tstruct xfs_inode_log_item *iip = INODE_ITEM(lip);\n\n\t\tif (xfs_iflags_test(iip->ili_inode, XFS_ISTALE)) {\n\t\t\txfs_iflush_abort(iip->ili_inode);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!iip->ili_last_fields)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (iip->ili_flush_lsn == lip->li_lsn ||\n\t\t    test_bit(XFS_LI_FAILED, &lip->li_flags))\n\t\t\tlist_move_tail(&lip->li_bio_list, &ail_updates);\n\t\telse\n\t\t\tlist_move_tail(&lip->li_bio_list, &flushed_inodes);\n\t}\n\n\tif (!list_empty(&ail_updates)) {\n\t\txfs_iflush_ail_updates(bp->b_mount->m_ail, &ail_updates);\n\t\tlist_splice_tail(&ail_updates, &flushed_inodes);\n\t}\n\n\txfs_iflush_finish(bp, &flushed_inodes);\n\tif (!list_empty(&flushed_inodes))\n\t\tlist_splice_tail(&flushed_inodes, &bp->b_li_list);\n}\n\nvoid\nxfs_buf_inode_io_fail(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_log_item\t*lip;\n\n\tlist_for_each_entry(lip, &bp->b_li_list, li_bio_list)\n\t\tset_bit(XFS_LI_FAILED, &lip->li_flags);\n}\n\n \nstatic void\nxfs_iflush_abort_clean(\n\tstruct xfs_inode_log_item *iip)\n{\n\tiip->ili_last_fields = 0;\n\tiip->ili_fields = 0;\n\tiip->ili_fsync_fields = 0;\n\tiip->ili_flush_lsn = 0;\n\tiip->ili_item.li_buf = NULL;\n\tlist_del_init(&iip->ili_item.li_bio_list);\n}\n\n \nvoid\nxfs_iflush_abort(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_inode_log_item *iip = ip->i_itemp;\n\tstruct xfs_buf\t\t*bp;\n\n\tif (!iip) {\n\t\t \n\t\txfs_iflags_clear(ip, XFS_IFLUSHING);\n\t\treturn;\n\t}\n\n\t \n\tclear_bit(XFS_LI_FAILED, &iip->ili_item.li_flags);\n\txfs_trans_ail_delete(&iip->ili_item, 0);\n\n\t \n\tspin_lock(&iip->ili_lock);\n\tbp = iip->ili_item.li_buf;\n\txfs_iflush_abort_clean(iip);\n\tspin_unlock(&iip->ili_lock);\n\n\txfs_iflags_clear(ip, XFS_IFLUSHING);\n\tif (bp)\n\t\txfs_buf_rele(bp);\n}\n\n \nvoid\nxfs_iflush_shutdown_abort(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_inode_log_item *iip = ip->i_itemp;\n\tstruct xfs_buf\t\t*bp;\n\n\tif (!iip) {\n\t\t \n\t\txfs_iflags_clear(ip, XFS_IFLUSHING);\n\t\treturn;\n\t}\n\n\tspin_lock(&iip->ili_lock);\n\tbp = iip->ili_item.li_buf;\n\tif (!bp) {\n\t\tspin_unlock(&iip->ili_lock);\n\t\txfs_iflush_abort(ip);\n\t\treturn;\n\t}\n\n\t \n\txfs_buf_hold(bp);\n\tspin_unlock(&iip->ili_lock);\n\txfs_buf_lock(bp);\n\n\tspin_lock(&iip->ili_lock);\n\tif (!iip->ili_item.li_buf) {\n\t\t \n\t\tASSERT(list_empty(&iip->ili_item.li_bio_list));\n\t\tASSERT(!test_bit(XFS_LI_IN_AIL, &iip->ili_item.li_flags));\n\t\txfs_iflush_abort_clean(iip);\n\t\tspin_unlock(&iip->ili_lock);\n\t\txfs_iflags_clear(ip, XFS_IFLUSHING);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\t \n\tASSERT(iip->ili_item.li_buf == bp);\n\tspin_unlock(&iip->ili_lock);\n\txfs_iflush_abort(ip);\n\txfs_buf_relse(bp);\n}\n\n\n \nint\nxfs_inode_item_format_convert(\n\tstruct xfs_log_iovec\t\t*buf,\n\tstruct xfs_inode_log_format\t*in_f)\n{\n\tstruct xfs_inode_log_format_32\t*in_f32 = buf->i_addr;\n\n\tif (buf->i_len != sizeof(*in_f32)) {\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, NULL);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tin_f->ilf_type = in_f32->ilf_type;\n\tin_f->ilf_size = in_f32->ilf_size;\n\tin_f->ilf_fields = in_f32->ilf_fields;\n\tin_f->ilf_asize = in_f32->ilf_asize;\n\tin_f->ilf_dsize = in_f32->ilf_dsize;\n\tin_f->ilf_ino = in_f32->ilf_ino;\n\tmemcpy(&in_f->ilf_u, &in_f32->ilf_u, sizeof(in_f->ilf_u));\n\tin_f->ilf_blkno = in_f32->ilf_blkno;\n\tin_f->ilf_len = in_f32->ilf_len;\n\tin_f->ilf_boffset = in_f32->ilf_boffset;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}