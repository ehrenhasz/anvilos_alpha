{
  "module_name": "xfs_inode.h",
  "hash_id": "e8b4ae7fd03953b0b2ddb9892e49366abb7d534bed56f7ef7af072e247b06905",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_inode.h",
  "human_readable_source": "\n \n#ifndef\t__XFS_INODE_H__\n#define\t__XFS_INODE_H__\n\n#include \"xfs_inode_buf.h\"\n#include \"xfs_inode_fork.h\"\n\n \nstruct xfs_dinode;\nstruct xfs_inode;\nstruct xfs_buf;\nstruct xfs_bmbt_irec;\nstruct xfs_inode_log_item;\nstruct xfs_mount;\nstruct xfs_trans;\nstruct xfs_dquot;\n\ntypedef struct xfs_inode {\n\t \n\tstruct xfs_mount\t*i_mount;\t \n\tstruct xfs_dquot\t*i_udquot;\t \n\tstruct xfs_dquot\t*i_gdquot;\t \n\tstruct xfs_dquot\t*i_pdquot;\t \n\n\t \n\txfs_ino_t\t\ti_ino;\t\t \n\tstruct xfs_imap\t\ti_imap;\t\t \n\n\t \n\tstruct xfs_ifork\t*i_cowfp;\t \n\tstruct xfs_ifork\ti_df;\t\t \n\tstruct xfs_ifork\ti_af;\t\t \n\n\t \n\tstruct xfs_inode_log_item *i_itemp;\t \n\tmrlock_t\t\ti_lock;\t\t \n\tatomic_t\t\ti_pincount;\t \n\tstruct llist_node\ti_gclist;\t \n\n\t \n\tuint16_t\t\ti_checked;\n\tuint16_t\t\ti_sick;\n\n\tspinlock_t\t\ti_flags_lock;\t \n\t \n\tunsigned long\t\ti_flags;\t \n\tuint64_t\t\ti_delayed_blks;\t \n\txfs_fsize_t\t\ti_disk_size;\t \n\txfs_rfsblock_t\t\ti_nblocks;\t \n\tprid_t\t\t\ti_projid;\t \n\txfs_extlen_t\t\ti_extsize;\t \n\t \n\tunion {\n\t\txfs_extlen_t\ti_cowextsize;\t \n\t\tuint16_t\ti_flushiter;\t \n\t};\n\tuint8_t\t\t\ti_forkoff;\t \n\tuint16_t\t\ti_diflags;\t \n\tuint64_t\t\ti_diflags2;\t \n\tstruct timespec64\ti_crtime;\t \n\n\t \n\txfs_agino_t\t\ti_next_unlinked;\n\n\t \n\txfs_agino_t\t\ti_prev_unlinked;\n\n\t \n\tstruct inode\t\ti_vnode;\t \n\n\t \n\tspinlock_t\t\ti_ioend_lock;\n\tstruct work_struct\ti_ioend_work;\n\tstruct list_head\ti_ioend_list;\n} xfs_inode_t;\n\nstatic inline bool xfs_inode_on_unlinked_list(const struct xfs_inode *ip)\n{\n\treturn ip->i_prev_unlinked != 0;\n}\n\nstatic inline bool xfs_inode_has_attr_fork(struct xfs_inode *ip)\n{\n\treturn ip->i_forkoff > 0;\n}\n\nstatic inline struct xfs_ifork *\nxfs_ifork_ptr(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork)\n{\n\tswitch (whichfork) {\n\tcase XFS_DATA_FORK:\n\t\treturn &ip->i_df;\n\tcase XFS_ATTR_FORK:\n\t\tif (!xfs_inode_has_attr_fork(ip))\n\t\t\treturn NULL;\n\t\treturn &ip->i_af;\n\tcase XFS_COW_FORK:\n\t\treturn ip->i_cowfp;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn NULL;\n\t}\n}\n\nstatic inline unsigned int xfs_inode_fork_boff(struct xfs_inode *ip)\n{\n\treturn ip->i_forkoff << 3;\n}\n\nstatic inline unsigned int xfs_inode_data_fork_size(struct xfs_inode *ip)\n{\n\tif (xfs_inode_has_attr_fork(ip))\n\t\treturn xfs_inode_fork_boff(ip);\n\n\treturn XFS_LITINO(ip->i_mount);\n}\n\nstatic inline unsigned int xfs_inode_attr_fork_size(struct xfs_inode *ip)\n{\n\tif (xfs_inode_has_attr_fork(ip))\n\t\treturn XFS_LITINO(ip->i_mount) - xfs_inode_fork_boff(ip);\n\treturn 0;\n}\n\nstatic inline unsigned int\nxfs_inode_fork_size(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork)\n{\n\tswitch (whichfork) {\n\tcase XFS_DATA_FORK:\n\t\treturn xfs_inode_data_fork_size(ip);\n\tcase XFS_ATTR_FORK:\n\t\treturn xfs_inode_attr_fork_size(ip);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic inline struct xfs_inode *XFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct xfs_inode, i_vnode);\n}\n\n \nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}\n\n \nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(VFS_I(ip)->i_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_disk_size;\n}\n\n \nstatic inline xfs_fsize_t\nxfs_new_eof(struct xfs_inode *ip, xfs_fsize_t new_size)\n{\n\txfs_fsize_t i_size = i_size_read(VFS_I(ip));\n\n\tif (new_size > i_size || new_size < 0)\n\t\tnew_size = i_size;\n\treturn new_size > ip->i_disk_size ? new_size : 0;\n}\n\n \nstatic inline void\n__xfs_iflags_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tip->i_flags |= flags;\n}\n\nstatic inline void\nxfs_iflags_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\t__xfs_iflags_set(ip, flags);\n\tspin_unlock(&ip->i_flags_lock);\n}\n\nstatic inline void\nxfs_iflags_clear(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\tip->i_flags &= ~flags;\n\tspin_unlock(&ip->i_flags_lock);\n}\n\nstatic inline int\n__xfs_iflags_test(xfs_inode_t *ip, unsigned short flags)\n{\n\treturn (ip->i_flags & flags);\n}\n\nstatic inline int\nxfs_iflags_test(xfs_inode_t *ip, unsigned short flags)\n{\n\tint ret;\n\tspin_lock(&ip->i_flags_lock);\n\tret = __xfs_iflags_test(ip, flags);\n\tspin_unlock(&ip->i_flags_lock);\n\treturn ret;\n}\n\nstatic inline int\nxfs_iflags_test_and_clear(xfs_inode_t *ip, unsigned short flags)\n{\n\tint ret;\n\n\tspin_lock(&ip->i_flags_lock);\n\tret = ip->i_flags & flags;\n\tif (ret)\n\t\tip->i_flags &= ~flags;\n\tspin_unlock(&ip->i_flags_lock);\n\treturn ret;\n}\n\nstatic inline int\nxfs_iflags_test_and_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tint ret;\n\n\tspin_lock(&ip->i_flags_lock);\n\tret = ip->i_flags & flags;\n\tif (!ret)\n\t\tip->i_flags |= flags;\n\tspin_unlock(&ip->i_flags_lock);\n\treturn ret;\n}\n\nstatic inline prid_t\nxfs_get_initial_prid(struct xfs_inode *dp)\n{\n\tif (dp->i_diflags & XFS_DIFLAG_PROJINHERIT)\n\t\treturn dp->i_projid;\n\n\treturn XFS_PROJID_DEFAULT;\n}\n\nstatic inline bool xfs_is_reflink_inode(struct xfs_inode *ip)\n{\n\treturn ip->i_diflags2 & XFS_DIFLAG2_REFLINK;\n}\n\nstatic inline bool xfs_is_metadata_inode(struct xfs_inode *ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\treturn ip == mp->m_rbmip || ip == mp->m_rsumip ||\n\t\txfs_is_quota_inode(&mp->m_sb, ip->i_ino);\n}\n\n \nstatic inline bool xfs_inode_has_cow_data(struct xfs_inode *ip)\n{\n\treturn ip->i_cowfp && ip->i_cowfp->if_bytes;\n}\n\nstatic inline bool xfs_inode_has_bigtime(struct xfs_inode *ip)\n{\n\treturn ip->i_diflags2 & XFS_DIFLAG2_BIGTIME;\n}\n\nstatic inline bool xfs_inode_has_large_extent_counts(struct xfs_inode *ip)\n{\n\treturn ip->i_diflags2 & XFS_DIFLAG2_NREXT64;\n}\n\n \n#define xfs_inode_buftarg(ip) \\\n\t(XFS_IS_REALTIME_INODE(ip) ? \\\n\t\t(ip)->i_mount->m_rtdev_targp : (ip)->i_mount->m_ddev_targp)\n\n \n#define XFS_IRECLAIM\t\t(1 << 0)  \n#define XFS_ISTALE\t\t(1 << 1)  \n#define XFS_IRECLAIMABLE\t(1 << 2)  \n#define XFS_INEW\t\t(1 << 3)  \n#define XFS_IPRESERVE_DM_FIELDS\t(1 << 4)  \n#define XFS_ITRUNCATED\t\t(1 << 5)  \n#define XFS_IDIRTY_RELEASE\t(1 << 6)  \n#define XFS_IFLUSHING\t\t(1 << 7)  \n#define __XFS_IPINNED_BIT\t8\t  \n#define XFS_IPINNED\t\t(1 << __XFS_IPINNED_BIT)\n#define XFS_IEOFBLOCKS\t\t(1 << 9)  \n#define XFS_NEED_INACTIVE\t(1 << 10)  \n \n#define XFS_IRECOVERY\t\t(1 << 11)\n#define XFS_ICOWBLOCKS\t\t(1 << 12) \n\n \n#define XFS_INACTIVATING\t(1 << 13)\n\n \n#define XFS_IQUOTAUNCHECKED\t(1 << 14)\n\n \n#define XFS_ALL_IRECLAIM_FLAGS\t(XFS_IRECLAIMABLE | \\\n\t\t\t\t XFS_IRECLAIM | \\\n\t\t\t\t XFS_NEED_INACTIVE | \\\n\t\t\t\t XFS_INACTIVATING)\n\n \n#define XFS_IRECLAIM_RESET_FLAGS\t\\\n\t(XFS_IRECLAIMABLE | XFS_IRECLAIM | \\\n\t XFS_IDIRTY_RELEASE | XFS_ITRUNCATED | XFS_NEED_INACTIVE | \\\n\t XFS_INACTIVATING | XFS_IQUOTAUNCHECKED)\n\n \n#define\tXFS_IOLOCK_EXCL\t\t(1u << 0)\n#define\tXFS_IOLOCK_SHARED\t(1u << 1)\n#define\tXFS_ILOCK_EXCL\t\t(1u << 2)\n#define\tXFS_ILOCK_SHARED\t(1u << 3)\n#define\tXFS_MMAPLOCK_EXCL\t(1u << 4)\n#define\tXFS_MMAPLOCK_SHARED\t(1u << 5)\n\n#define XFS_LOCK_MASK\t\t(XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED \\\n\t\t\t\t| XFS_ILOCK_EXCL | XFS_ILOCK_SHARED \\\n\t\t\t\t| XFS_MMAPLOCK_EXCL | XFS_MMAPLOCK_SHARED)\n\n#define XFS_LOCK_FLAGS \\\n\t{ XFS_IOLOCK_EXCL,\t\"IOLOCK_EXCL\" }, \\\n\t{ XFS_IOLOCK_SHARED,\t\"IOLOCK_SHARED\" }, \\\n\t{ XFS_ILOCK_EXCL,\t\"ILOCK_EXCL\" }, \\\n\t{ XFS_ILOCK_SHARED,\t\"ILOCK_SHARED\" }, \\\n\t{ XFS_MMAPLOCK_EXCL,\t\"MMAPLOCK_EXCL\" }, \\\n\t{ XFS_MMAPLOCK_SHARED,\t\"MMAPLOCK_SHARED\" }\n\n\n \n#define XFS_IOLOCK_SHIFT\t\t16\n#define XFS_IOLOCK_MAX_SUBCLASS\t\t3\n#define XFS_IOLOCK_DEP_MASK\t\t0x000f0000u\n\n#define XFS_MMAPLOCK_SHIFT\t\t20\n#define XFS_MMAPLOCK_NUMORDER\t\t0\n#define XFS_MMAPLOCK_MAX_SUBCLASS\t3\n#define XFS_MMAPLOCK_DEP_MASK\t\t0x00f00000u\n\n#define XFS_ILOCK_SHIFT\t\t\t24\n#define XFS_ILOCK_PARENT_VAL\t\t5u\n#define XFS_ILOCK_MAX_SUBCLASS\t\t(XFS_ILOCK_PARENT_VAL - 1)\n#define XFS_ILOCK_RTBITMAP_VAL\t\t6u\n#define XFS_ILOCK_RTSUM_VAL\t\t7u\n#define XFS_ILOCK_DEP_MASK\t\t0xff000000u\n#define\tXFS_ILOCK_PARENT\t\t(XFS_ILOCK_PARENT_VAL << XFS_ILOCK_SHIFT)\n#define\tXFS_ILOCK_RTBITMAP\t\t(XFS_ILOCK_RTBITMAP_VAL << XFS_ILOCK_SHIFT)\n#define\tXFS_ILOCK_RTSUM\t\t\t(XFS_ILOCK_RTSUM_VAL << XFS_ILOCK_SHIFT)\n\n#define XFS_LOCK_SUBCLASS_MASK\t(XFS_IOLOCK_DEP_MASK | \\\n\t\t\t\t XFS_MMAPLOCK_DEP_MASK | \\\n\t\t\t\t XFS_ILOCK_DEP_MASK)\n\n#define XFS_IOLOCK_DEP(flags)\t(((flags) & XFS_IOLOCK_DEP_MASK) \\\n\t\t\t\t\t>> XFS_IOLOCK_SHIFT)\n#define XFS_MMAPLOCK_DEP(flags)\t(((flags) & XFS_MMAPLOCK_DEP_MASK) \\\n\t\t\t\t\t>> XFS_MMAPLOCK_SHIFT)\n#define XFS_ILOCK_DEP(flags)\t(((flags) & XFS_ILOCK_DEP_MASK) \\\n\t\t\t\t\t>> XFS_ILOCK_SHIFT)\n\n \nenum layout_break_reason {\n        BREAK_WRITE,\n        BREAK_UNMAP,\n};\n\n \n#define XFS_INHERIT_GID(pip)\t\\\n\t(xfs_has_grpid((pip)->i_mount) || (VFS_I(pip)->i_mode & S_ISGID))\n\nint\t\txfs_release(struct xfs_inode *ip);\nint\t\txfs_inactive(struct xfs_inode *ip);\nint\t\txfs_lookup(struct xfs_inode *dp, const struct xfs_name *name,\n\t\t\t   struct xfs_inode **ipp, struct xfs_name *ci_name);\nint\t\txfs_create(struct mnt_idmap *idmap,\n\t\t\t   struct xfs_inode *dp, struct xfs_name *name,\n\t\t\t   umode_t mode, dev_t rdev, bool need_xattr,\n\t\t\t   struct xfs_inode **ipp);\nint\t\txfs_create_tmpfile(struct mnt_idmap *idmap,\n\t\t\t   struct xfs_inode *dp, umode_t mode,\n\t\t\t   struct xfs_inode **ipp);\nint\t\txfs_remove(struct xfs_inode *dp, struct xfs_name *name,\n\t\t\t   struct xfs_inode *ip);\nint\t\txfs_link(struct xfs_inode *tdp, struct xfs_inode *sip,\n\t\t\t struct xfs_name *target_name);\nint\t\txfs_rename(struct mnt_idmap *idmap,\n\t\t\t   struct xfs_inode *src_dp, struct xfs_name *src_name,\n\t\t\t   struct xfs_inode *src_ip, struct xfs_inode *target_dp,\n\t\t\t   struct xfs_name *target_name,\n\t\t\t   struct xfs_inode *target_ip, unsigned int flags);\n\nvoid\t\txfs_ilock(xfs_inode_t *, uint);\nint\t\txfs_ilock_nowait(xfs_inode_t *, uint);\nvoid\t\txfs_iunlock(xfs_inode_t *, uint);\nvoid\t\txfs_ilock_demote(xfs_inode_t *, uint);\nbool\t\txfs_isilocked(struct xfs_inode *, uint);\nuint\t\txfs_ilock_data_map_shared(struct xfs_inode *);\nuint\t\txfs_ilock_attr_map_shared(struct xfs_inode *);\n\nuint\t\txfs_ip2xflags(struct xfs_inode *);\nint\t\txfs_ifree(struct xfs_trans *, struct xfs_inode *);\nint\t\txfs_itruncate_extents_flags(struct xfs_trans **,\n\t\t\t\tstruct xfs_inode *, int, xfs_fsize_t, int);\nvoid\t\txfs_iext_realloc(xfs_inode_t *, int, int);\n\nint\t\txfs_log_force_inode(struct xfs_inode *ip);\nvoid\t\txfs_iunpin_wait(xfs_inode_t *);\n#define xfs_ipincount(ip)\t((unsigned int) atomic_read(&ip->i_pincount))\n\nint\t\txfs_iflush_cluster(struct xfs_buf *);\nvoid\t\txfs_lock_two_inodes(struct xfs_inode *ip0, uint ip0_mode,\n\t\t\t\tstruct xfs_inode *ip1, uint ip1_mode);\n\nxfs_extlen_t\txfs_get_extsz_hint(struct xfs_inode *ip);\nxfs_extlen_t\txfs_get_cowextsz_hint(struct xfs_inode *ip);\n\nint xfs_init_new_inode(struct mnt_idmap *idmap, struct xfs_trans *tp,\n\t\tstruct xfs_inode *pip, xfs_ino_t ino, umode_t mode,\n\t\txfs_nlink_t nlink, dev_t rdev, prid_t prid, bool init_xattrs,\n\t\tstruct xfs_inode **ipp);\n\nstatic inline int\nxfs_itruncate_extents(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_fsize_t\t\tnew_size)\n{\n\treturn xfs_itruncate_extents_flags(tpp, ip, whichfork, new_size, 0);\n}\n\n \nint\txfs_break_dax_layouts(struct inode *inode, bool *retry);\nint\txfs_break_layouts(struct inode *inode, uint *iolock,\n\t\tenum layout_break_reason reason);\n\n \nextern void xfs_setup_inode(struct xfs_inode *ip);\nextern void xfs_setup_iops(struct xfs_inode *ip);\nextern void xfs_diflags_to_iflags(struct xfs_inode *ip, bool init);\n\n \nstatic inline void xfs_finish_inode_setup(struct xfs_inode *ip)\n{\n\txfs_iflags_clear(ip, XFS_INEW);\n\tbarrier();\n\tunlock_new_inode(VFS_I(ip));\n}\n\nstatic inline void xfs_setup_existing_inode(struct xfs_inode *ip)\n{\n\txfs_setup_inode(ip);\n\txfs_setup_iops(ip);\n\txfs_finish_inode_setup(ip);\n}\n\nvoid xfs_irele(struct xfs_inode *ip);\n\nextern struct kmem_cache\t*xfs_inode_cache;\n\n \n#define XFS_DEFAULT_COWEXTSZ_HINT 32\n\nbool xfs_inode_needs_inactive(struct xfs_inode *ip);\n\nvoid xfs_end_io(struct work_struct *work);\n\nint xfs_ilock2_io_mmap(struct xfs_inode *ip1, struct xfs_inode *ip2);\nvoid xfs_iunlock2_io_mmap(struct xfs_inode *ip1, struct xfs_inode *ip2);\n\nstatic inline bool\nxfs_inode_unlinked_incomplete(\n\tstruct xfs_inode\t*ip)\n{\n\treturn VFS_I(ip)->i_nlink == 0 && !xfs_inode_on_unlinked_list(ip);\n}\nint xfs_inode_reload_unlinked_bucket(struct xfs_trans *tp, struct xfs_inode *ip);\nint xfs_inode_reload_unlinked(struct xfs_inode *ip);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}