{
  "module_name": "xfs_log.h",
  "hash_id": "82bf34ecbe9b895c37b4102b314dbe526acbbc0787aabb43cd8cf6d2cb144bc4",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_log.h",
  "human_readable_source": "\n \n#ifndef\t__XFS_LOG_H__\n#define __XFS_LOG_H__\n\nstruct xfs_cil_ctx;\n\nstruct xfs_log_vec {\n\tstruct list_head\tlv_list;\t \n\tuint32_t\t\tlv_order_id;\t \n\tint\t\t\tlv_niovecs;\t \n\tstruct xfs_log_iovec\t*lv_iovecp;\t \n\tstruct xfs_log_item\t*lv_item;\t \n\tchar\t\t\t*lv_buf;\t \n\tint\t\t\tlv_bytes;\t \n\tint\t\t\tlv_buf_len;\t \n\tint\t\t\tlv_size;\t \n};\n\n#define XFS_LOG_VEC_ORDERED\t(-1)\n\n \nstatic inline int\nxlog_calc_iovec_len(int len)\n{\n\treturn roundup(len, sizeof(uint32_t));\n}\n\nvoid *xlog_prepare_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type);\n\nstatic inline void\nxlog_finish_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec *vec,\n\t\tint data_len)\n{\n\tstruct xlog_op_header\t*oph = vec->i_addr;\n\tint\t\t\tlen;\n\n\t \n\tlen = xlog_calc_iovec_len(data_len);\n\tif (len - data_len != 0) {\n\t\tchar\t*buf = vec->i_addr + sizeof(struct xlog_op_header);\n\n\t\tmemset(buf + data_len, 0, len - data_len);\n\t}\n\n\t \n\toph->oh_len = cpu_to_be32(len);\n\n\tlen += sizeof(struct xlog_op_header);\n\tlv->lv_buf_len += len;\n\tlv->lv_bytes += len;\n\tvec->i_len = len;\n\n\t \n\tASSERT((void *)lv->lv_buf + lv->lv_bytes <= (void *)lv + lv->lv_size);\n}\n\n \nstatic inline void *\nxlog_copy_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type, void *data, int len)\n{\n\tvoid *buf;\n\n\tbuf = xlog_prepare_iovec(lv, vecp, type);\n\tmemcpy(buf, data, len);\n\txlog_finish_iovec(lv, *vecp, len);\n\treturn buf;\n}\n\nstatic inline void *\nxlog_copy_from_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tconst struct xfs_log_iovec *src)\n{\n\treturn xlog_copy_iovec(lv, vecp, src->i_type, src->i_addr, src->i_len);\n}\n\n \nstatic inline xfs_lsn_t\t_lsn_cmp(xfs_lsn_t lsn1, xfs_lsn_t lsn2)\n{\n\tif (CYCLE_LSN(lsn1) != CYCLE_LSN(lsn2))\n\t\treturn (CYCLE_LSN(lsn1)<CYCLE_LSN(lsn2))? -999 : 999;\n\n\tif (BLOCK_LSN(lsn1) != BLOCK_LSN(lsn2))\n\t\treturn (BLOCK_LSN(lsn1)<BLOCK_LSN(lsn2))? -999 : 999;\n\n\treturn 0;\n}\n\n#define\tXFS_LSN_CMP(x,y) _lsn_cmp(x,y)\n\n \n#define XFS_LOG_SYNC\t\t0x1\n\n \nstruct xfs_mount;\nstruct xlog_in_core;\nstruct xlog_ticket;\nstruct xfs_log_item;\nstruct xfs_item_ops;\nstruct xfs_trans;\nstruct xlog;\n\nint\t  xfs_log_force(struct xfs_mount *mp, uint flags);\nint\t  xfs_log_force_seq(struct xfs_mount *mp, xfs_csn_t seq, uint flags,\n\t\tint *log_forced);\nint\t  xfs_log_mount(struct xfs_mount\t*mp,\n\t\t\tstruct xfs_buftarg\t*log_target,\n\t\t\txfs_daddr_t\t\tstart_block,\n\t\t\tint\t\t \tnum_bblocks);\nint\t  xfs_log_mount_finish(struct xfs_mount *mp);\nvoid\txfs_log_mount_cancel(struct xfs_mount *);\nxfs_lsn_t xlog_assign_tail_lsn(struct xfs_mount *mp);\nxfs_lsn_t xlog_assign_tail_lsn_locked(struct xfs_mount *mp);\nvoid\txfs_log_space_wake(struct xfs_mount *mp);\nint\txfs_log_reserve(struct xfs_mount *mp, int length, int count,\n\t\t\tstruct xlog_ticket **ticket, bool permanent);\nint\txfs_log_regrant(struct xfs_mount *mp, struct xlog_ticket *tic);\nvoid\txfs_log_unmount(struct xfs_mount *mp);\nbool\txfs_log_writable(struct xfs_mount *mp);\n\nstruct xlog_ticket *xfs_log_ticket_get(struct xlog_ticket *ticket);\nvoid\t  xfs_log_ticket_put(struct xlog_ticket *ticket);\n\nvoid\txlog_cil_process_committed(struct list_head *list);\nbool\txfs_log_item_in_current_chkpt(struct xfs_log_item *lip);\n\nvoid\txfs_log_work_queue(struct xfs_mount *mp);\nint\txfs_log_quiesce(struct xfs_mount *mp);\nvoid\txfs_log_clean(struct xfs_mount *mp);\nbool\txfs_log_check_lsn(struct xfs_mount *, xfs_lsn_t);\n\nxfs_lsn_t xlog_grant_push_threshold(struct xlog *log, int need_bytes);\nbool\t  xlog_force_shutdown(struct xlog *log, uint32_t shutdown_flags);\n\nvoid xlog_use_incompat_feat(struct xlog *log);\nvoid xlog_drop_incompat_feat(struct xlog *log);\nint xfs_attr_use_log_assist(struct xfs_mount *mp);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}