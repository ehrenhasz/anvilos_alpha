{
  "module_name": "xfs_refcount_item.c",
  "hash_id": "b3f62915788a897b3d6a3e7e968dd5e8f2284fd121d817d4e786b5795d388256",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_refcount_item.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_refcount_item.h\"\n#include \"xfs_log.h\"\n#include \"xfs_refcount.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_ag.h\"\n\nstruct kmem_cache\t*xfs_cui_cache;\nstruct kmem_cache\t*xfs_cud_cache;\n\nstatic const struct xfs_item_ops xfs_cui_item_ops;\n\nstatic inline struct xfs_cui_log_item *CUI_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_cui_log_item, cui_item);\n}\n\nSTATIC void\nxfs_cui_item_free(\n\tstruct xfs_cui_log_item\t*cuip)\n{\n\tkmem_free(cuip->cui_item.li_lv_shadow);\n\tif (cuip->cui_format.cui_nextents > XFS_CUI_MAX_FAST_EXTENTS)\n\t\tkmem_free(cuip);\n\telse\n\t\tkmem_cache_free(xfs_cui_cache, cuip);\n}\n\n \nSTATIC void\nxfs_cui_release(\n\tstruct xfs_cui_log_item\t*cuip)\n{\n\tASSERT(atomic_read(&cuip->cui_refcount) > 0);\n\tif (!atomic_dec_and_test(&cuip->cui_refcount))\n\t\treturn;\n\n\txfs_trans_ail_delete(&cuip->cui_item, 0);\n\txfs_cui_item_free(cuip);\n}\n\n\nSTATIC void\nxfs_cui_item_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_cui_log_item\t*cuip = CUI_ITEM(lip);\n\n\t*nvecs += 1;\n\t*nbytes += xfs_cui_log_format_sizeof(cuip->cui_format.cui_nextents);\n}\n\n \nSTATIC void\nxfs_cui_item_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_cui_log_item\t*cuip = CUI_ITEM(lip);\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\n\tASSERT(atomic_read(&cuip->cui_next_extent) ==\n\t\t\tcuip->cui_format.cui_nextents);\n\n\tcuip->cui_format.cui_type = XFS_LI_CUI;\n\tcuip->cui_format.cui_size = 1;\n\n\txlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_CUI_FORMAT, &cuip->cui_format,\n\t\t\txfs_cui_log_format_sizeof(cuip->cui_format.cui_nextents));\n}\n\n \nSTATIC void\nxfs_cui_item_unpin(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\tremove)\n{\n\tstruct xfs_cui_log_item\t*cuip = CUI_ITEM(lip);\n\n\txfs_cui_release(cuip);\n}\n\n \nSTATIC void\nxfs_cui_item_release(\n\tstruct xfs_log_item\t*lip)\n{\n\txfs_cui_release(CUI_ITEM(lip));\n}\n\n \nSTATIC struct xfs_cui_log_item *\nxfs_cui_init(\n\tstruct xfs_mount\t\t*mp,\n\tuint\t\t\t\tnextents)\n\n{\n\tstruct xfs_cui_log_item\t\t*cuip;\n\n\tASSERT(nextents > 0);\n\tif (nextents > XFS_CUI_MAX_FAST_EXTENTS)\n\t\tcuip = kmem_zalloc(xfs_cui_log_item_sizeof(nextents),\n\t\t\t\t0);\n\telse\n\t\tcuip = kmem_cache_zalloc(xfs_cui_cache,\n\t\t\t\t\t GFP_KERNEL | __GFP_NOFAIL);\n\n\txfs_log_item_init(mp, &cuip->cui_item, XFS_LI_CUI, &xfs_cui_item_ops);\n\tcuip->cui_format.cui_nextents = nextents;\n\tcuip->cui_format.cui_id = (uintptr_t)(void *)cuip;\n\tatomic_set(&cuip->cui_next_extent, 0);\n\tatomic_set(&cuip->cui_refcount, 2);\n\n\treturn cuip;\n}\n\nstatic inline struct xfs_cud_log_item *CUD_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_cud_log_item, cud_item);\n}\n\nSTATIC void\nxfs_cud_item_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\t*nvecs += 1;\n\t*nbytes += sizeof(struct xfs_cud_log_format);\n}\n\n \nSTATIC void\nxfs_cud_item_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_cud_log_item\t*cudp = CUD_ITEM(lip);\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\n\tcudp->cud_format.cud_type = XFS_LI_CUD;\n\tcudp->cud_format.cud_size = 1;\n\n\txlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_CUD_FORMAT, &cudp->cud_format,\n\t\t\tsizeof(struct xfs_cud_log_format));\n}\n\n \nSTATIC void\nxfs_cud_item_release(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_cud_log_item\t*cudp = CUD_ITEM(lip);\n\n\txfs_cui_release(cudp->cud_cuip);\n\tkmem_free(cudp->cud_item.li_lv_shadow);\n\tkmem_cache_free(xfs_cud_cache, cudp);\n}\n\nstatic struct xfs_log_item *\nxfs_cud_item_intent(\n\tstruct xfs_log_item\t*lip)\n{\n\treturn &CUD_ITEM(lip)->cud_cuip->cui_item;\n}\n\nstatic const struct xfs_item_ops xfs_cud_item_ops = {\n\t.flags\t\t= XFS_ITEM_RELEASE_WHEN_COMMITTED |\n\t\t\t  XFS_ITEM_INTENT_DONE,\n\t.iop_size\t= xfs_cud_item_size,\n\t.iop_format\t= xfs_cud_item_format,\n\t.iop_release\t= xfs_cud_item_release,\n\t.iop_intent\t= xfs_cud_item_intent,\n};\n\nstatic struct xfs_cud_log_item *\nxfs_trans_get_cud(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_cui_log_item\t\t*cuip)\n{\n\tstruct xfs_cud_log_item\t\t*cudp;\n\n\tcudp = kmem_cache_zalloc(xfs_cud_cache, GFP_KERNEL | __GFP_NOFAIL);\n\txfs_log_item_init(tp->t_mountp, &cudp->cud_item, XFS_LI_CUD,\n\t\t\t  &xfs_cud_item_ops);\n\tcudp->cud_cuip = cuip;\n\tcudp->cud_format.cud_cui_id = cuip->cui_format.cui_id;\n\n\txfs_trans_add_item(tp, &cudp->cud_item);\n\treturn cudp;\n}\n\n \nstatic int\nxfs_trans_log_finish_refcount_update(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_cud_log_item\t\t*cudp,\n\tstruct xfs_refcount_intent\t*ri,\n\tstruct xfs_btree_cur\t\t**pcur)\n{\n\tint\t\t\t\terror;\n\n\terror = xfs_refcount_finish_one(tp, ri, pcur);\n\n\t \n\ttp->t_flags |= XFS_TRANS_DIRTY | XFS_TRANS_HAS_INTENT_DONE;\n\tset_bit(XFS_LI_DIRTY, &cudp->cud_item.li_flags);\n\n\treturn error;\n}\n\n \nstatic int\nxfs_refcount_update_diff_items(\n\tvoid\t\t\t\t*priv,\n\tconst struct list_head\t\t*a,\n\tconst struct list_head\t\t*b)\n{\n\tstruct xfs_refcount_intent\t*ra;\n\tstruct xfs_refcount_intent\t*rb;\n\n\tra = container_of(a, struct xfs_refcount_intent, ri_list);\n\trb = container_of(b, struct xfs_refcount_intent, ri_list);\n\n\treturn ra->ri_pag->pag_agno - rb->ri_pag->pag_agno;\n}\n\n \nstatic void\nxfs_trans_set_refcount_flags(\n\tstruct xfs_phys_extent\t\t*pmap,\n\tenum xfs_refcount_intent_type\ttype)\n{\n\tpmap->pe_flags = 0;\n\tswitch (type) {\n\tcase XFS_REFCOUNT_INCREASE:\n\tcase XFS_REFCOUNT_DECREASE:\n\tcase XFS_REFCOUNT_ALLOC_COW:\n\tcase XFS_REFCOUNT_FREE_COW:\n\t\tpmap->pe_flags |= type;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n}\n\n \nSTATIC void\nxfs_refcount_update_log_item(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_cui_log_item\t\t*cuip,\n\tstruct xfs_refcount_intent\t*ri)\n{\n\tuint\t\t\t\tnext_extent;\n\tstruct xfs_phys_extent\t\t*pmap;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tset_bit(XFS_LI_DIRTY, &cuip->cui_item.li_flags);\n\n\t \n\tnext_extent = atomic_inc_return(&cuip->cui_next_extent) - 1;\n\tASSERT(next_extent < cuip->cui_format.cui_nextents);\n\tpmap = &cuip->cui_format.cui_extents[next_extent];\n\tpmap->pe_startblock = ri->ri_startblock;\n\tpmap->pe_len = ri->ri_blockcount;\n\txfs_trans_set_refcount_flags(pmap, ri->ri_type);\n}\n\nstatic struct xfs_log_item *\nxfs_refcount_update_create_intent(\n\tstruct xfs_trans\t\t*tp,\n\tstruct list_head\t\t*items,\n\tunsigned int\t\t\tcount,\n\tbool\t\t\t\tsort)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_cui_log_item\t\t*cuip = xfs_cui_init(mp, count);\n\tstruct xfs_refcount_intent\t*ri;\n\n\tASSERT(count > 0);\n\n\txfs_trans_add_item(tp, &cuip->cui_item);\n\tif (sort)\n\t\tlist_sort(mp, items, xfs_refcount_update_diff_items);\n\tlist_for_each_entry(ri, items, ri_list)\n\t\txfs_refcount_update_log_item(tp, cuip, ri);\n\treturn &cuip->cui_item;\n}\n\n \nstatic struct xfs_log_item *\nxfs_refcount_update_create_done(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_log_item\t\t*intent,\n\tunsigned int\t\t\tcount)\n{\n\treturn &xfs_trans_get_cud(tp, CUI_ITEM(intent))->cud_item;\n}\n\n \nvoid\nxfs_refcount_update_get_group(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_refcount_intent\t*ri)\n{\n\txfs_agnumber_t\t\t\tagno;\n\n\tagno = XFS_FSB_TO_AGNO(mp, ri->ri_startblock);\n\tri->ri_pag = xfs_perag_intent_get(mp, agno);\n}\n\n \nstatic inline void\nxfs_refcount_update_put_group(\n\tstruct xfs_refcount_intent\t*ri)\n{\n\txfs_perag_intent_put(ri->ri_pag);\n}\n\n \nSTATIC int\nxfs_refcount_update_finish_item(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_log_item\t\t*done,\n\tstruct list_head\t\t*item,\n\tstruct xfs_btree_cur\t\t**state)\n{\n\tstruct xfs_refcount_intent\t*ri;\n\tint\t\t\t\terror;\n\n\tri = container_of(item, struct xfs_refcount_intent, ri_list);\n\terror = xfs_trans_log_finish_refcount_update(tp, CUD_ITEM(done), ri,\n\t\t\tstate);\n\n\t \n\tif (!error && ri->ri_blockcount > 0) {\n\t\tASSERT(ri->ri_type == XFS_REFCOUNT_INCREASE ||\n\t\t       ri->ri_type == XFS_REFCOUNT_DECREASE);\n\t\treturn -EAGAIN;\n\t}\n\n\txfs_refcount_update_put_group(ri);\n\tkmem_cache_free(xfs_refcount_intent_cache, ri);\n\treturn error;\n}\n\n \nSTATIC void\nxfs_refcount_update_abort_intent(\n\tstruct xfs_log_item\t\t*intent)\n{\n\txfs_cui_release(CUI_ITEM(intent));\n}\n\n \nSTATIC void\nxfs_refcount_update_cancel_item(\n\tstruct list_head\t\t*item)\n{\n\tstruct xfs_refcount_intent\t*ri;\n\n\tri = container_of(item, struct xfs_refcount_intent, ri_list);\n\n\txfs_refcount_update_put_group(ri);\n\tkmem_cache_free(xfs_refcount_intent_cache, ri);\n}\n\nconst struct xfs_defer_op_type xfs_refcount_update_defer_type = {\n\t.max_items\t= XFS_CUI_MAX_FAST_EXTENTS,\n\t.create_intent\t= xfs_refcount_update_create_intent,\n\t.abort_intent\t= xfs_refcount_update_abort_intent,\n\t.create_done\t= xfs_refcount_update_create_done,\n\t.finish_item\t= xfs_refcount_update_finish_item,\n\t.finish_cleanup = xfs_refcount_finish_one_cleanup,\n\t.cancel_item\t= xfs_refcount_update_cancel_item,\n};\n\n \nstatic inline bool\nxfs_cui_validate_phys(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_phys_extent\t\t*pmap)\n{\n\tif (!xfs_has_reflink(mp))\n\t\treturn false;\n\n\tif (pmap->pe_flags & ~XFS_REFCOUNT_EXTENT_FLAGS)\n\t\treturn false;\n\n\tswitch (pmap->pe_flags & XFS_REFCOUNT_EXTENT_TYPE_MASK) {\n\tcase XFS_REFCOUNT_INCREASE:\n\tcase XFS_REFCOUNT_DECREASE:\n\tcase XFS_REFCOUNT_ALLOC_COW:\n\tcase XFS_REFCOUNT_FREE_COW:\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn xfs_verify_fsbext(mp, pmap->pe_startblock, pmap->pe_len);\n}\n\n \nSTATIC int\nxfs_cui_item_recover(\n\tstruct xfs_log_item\t\t*lip,\n\tstruct list_head\t\t*capture_list)\n{\n\tstruct xfs_trans_res\t\tresv;\n\tstruct xfs_cui_log_item\t\t*cuip = CUI_ITEM(lip);\n\tstruct xfs_cud_log_item\t\t*cudp;\n\tstruct xfs_trans\t\t*tp;\n\tstruct xfs_btree_cur\t\t*rcur = NULL;\n\tstruct xfs_mount\t\t*mp = lip->li_log->l_mp;\n\tunsigned int\t\t\trefc_type;\n\tbool\t\t\t\trequeue_only = false;\n\tint\t\t\t\ti;\n\tint\t\t\t\terror = 0;\n\n\t \n\tfor (i = 0; i < cuip->cui_format.cui_nextents; i++) {\n\t\tif (!xfs_cui_validate_phys(mp,\n\t\t\t\t\t&cuip->cui_format.cui_extents[i])) {\n\t\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\t\t&cuip->cui_format,\n\t\t\t\t\tsizeof(cuip->cui_format));\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\t \n\tresv = xlog_recover_resv(&M_RES(mp)->tr_itruncate);\n\terror = xfs_trans_alloc(mp, &resv, mp->m_refc_maxlevels * 2, 0,\n\t\t\tXFS_TRANS_RESERVE, &tp);\n\tif (error)\n\t\treturn error;\n\n\tcudp = xfs_trans_get_cud(tp, cuip);\n\n\tfor (i = 0; i < cuip->cui_format.cui_nextents; i++) {\n\t\tstruct xfs_refcount_intent\tfake = { };\n\t\tstruct xfs_phys_extent\t\t*pmap;\n\n\t\tpmap = &cuip->cui_format.cui_extents[i];\n\t\trefc_type = pmap->pe_flags & XFS_REFCOUNT_EXTENT_TYPE_MASK;\n\t\tswitch (refc_type) {\n\t\tcase XFS_REFCOUNT_INCREASE:\n\t\tcase XFS_REFCOUNT_DECREASE:\n\t\tcase XFS_REFCOUNT_ALLOC_COW:\n\t\tcase XFS_REFCOUNT_FREE_COW:\n\t\t\tfake.ri_type = refc_type;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\t\t&cuip->cui_format,\n\t\t\t\t\tsizeof(cuip->cui_format));\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto abort_error;\n\t\t}\n\n\t\tfake.ri_startblock = pmap->pe_startblock;\n\t\tfake.ri_blockcount = pmap->pe_len;\n\n\t\tif (!requeue_only) {\n\t\t\txfs_refcount_update_get_group(mp, &fake);\n\t\t\terror = xfs_trans_log_finish_refcount_update(tp, cudp,\n\t\t\t\t\t&fake, &rcur);\n\t\t\txfs_refcount_update_put_group(&fake);\n\t\t}\n\t\tif (error == -EFSCORRUPTED)\n\t\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\t\t&cuip->cui_format,\n\t\t\t\t\tsizeof(cuip->cui_format));\n\t\tif (error)\n\t\t\tgoto abort_error;\n\n\t\t \n\t\tif (fake.ri_blockcount > 0) {\n\t\t\tstruct xfs_bmbt_irec\tirec = {\n\t\t\t\t.br_startblock\t= fake.ri_startblock,\n\t\t\t\t.br_blockcount\t= fake.ri_blockcount,\n\t\t\t};\n\n\t\t\tswitch (fake.ri_type) {\n\t\t\tcase XFS_REFCOUNT_INCREASE:\n\t\t\t\txfs_refcount_increase_extent(tp, &irec);\n\t\t\t\tbreak;\n\t\t\tcase XFS_REFCOUNT_DECREASE:\n\t\t\t\txfs_refcount_decrease_extent(tp, &irec);\n\t\t\t\tbreak;\n\t\t\tcase XFS_REFCOUNT_ALLOC_COW:\n\t\t\t\txfs_refcount_alloc_cow_extent(tp,\n\t\t\t\t\t\tirec.br_startblock,\n\t\t\t\t\t\tirec.br_blockcount);\n\t\t\t\tbreak;\n\t\t\tcase XFS_REFCOUNT_FREE_COW:\n\t\t\t\txfs_refcount_free_cow_extent(tp,\n\t\t\t\t\t\tirec.br_startblock,\n\t\t\t\t\t\tirec.br_blockcount);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tASSERT(0);\n\t\t\t}\n\t\t\trequeue_only = true;\n\t\t}\n\t}\n\n\txfs_refcount_finish_one_cleanup(tp, rcur, error);\n\treturn xfs_defer_ops_capture_and_commit(tp, capture_list);\n\nabort_error:\n\txfs_refcount_finish_one_cleanup(tp, rcur, error);\n\txfs_trans_cancel(tp);\n\treturn error;\n}\n\nSTATIC bool\nxfs_cui_item_match(\n\tstruct xfs_log_item\t*lip,\n\tuint64_t\t\tintent_id)\n{\n\treturn CUI_ITEM(lip)->cui_format.cui_id == intent_id;\n}\n\n \nstatic struct xfs_log_item *\nxfs_cui_item_relog(\n\tstruct xfs_log_item\t\t*intent,\n\tstruct xfs_trans\t\t*tp)\n{\n\tstruct xfs_cud_log_item\t\t*cudp;\n\tstruct xfs_cui_log_item\t\t*cuip;\n\tstruct xfs_phys_extent\t\t*pmap;\n\tunsigned int\t\t\tcount;\n\n\tcount = CUI_ITEM(intent)->cui_format.cui_nextents;\n\tpmap = CUI_ITEM(intent)->cui_format.cui_extents;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tcudp = xfs_trans_get_cud(tp, CUI_ITEM(intent));\n\tset_bit(XFS_LI_DIRTY, &cudp->cud_item.li_flags);\n\n\tcuip = xfs_cui_init(tp->t_mountp, count);\n\tmemcpy(cuip->cui_format.cui_extents, pmap, count * sizeof(*pmap));\n\tatomic_set(&cuip->cui_next_extent, count);\n\txfs_trans_add_item(tp, &cuip->cui_item);\n\tset_bit(XFS_LI_DIRTY, &cuip->cui_item.li_flags);\n\treturn &cuip->cui_item;\n}\n\nstatic const struct xfs_item_ops xfs_cui_item_ops = {\n\t.flags\t\t= XFS_ITEM_INTENT,\n\t.iop_size\t= xfs_cui_item_size,\n\t.iop_format\t= xfs_cui_item_format,\n\t.iop_unpin\t= xfs_cui_item_unpin,\n\t.iop_release\t= xfs_cui_item_release,\n\t.iop_recover\t= xfs_cui_item_recover,\n\t.iop_match\t= xfs_cui_item_match,\n\t.iop_relog\t= xfs_cui_item_relog,\n};\n\nstatic inline void\nxfs_cui_copy_format(\n\tstruct xfs_cui_log_format\t*dst,\n\tconst struct xfs_cui_log_format\t*src)\n{\n\tunsigned int\t\t\ti;\n\n\tmemcpy(dst, src, offsetof(struct xfs_cui_log_format, cui_extents));\n\n\tfor (i = 0; i < src->cui_nextents; i++)\n\t\tmemcpy(&dst->cui_extents[i], &src->cui_extents[i],\n\t\t\t\tsizeof(struct xfs_phys_extent));\n}\n\n \nSTATIC int\nxlog_recover_cui_commit_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tlsn)\n{\n\tstruct xfs_mount\t\t*mp = log->l_mp;\n\tstruct xfs_cui_log_item\t\t*cuip;\n\tstruct xfs_cui_log_format\t*cui_formatp;\n\tsize_t\t\t\t\tlen;\n\n\tcui_formatp = item->ri_buf[0].i_addr;\n\n\tif (item->ri_buf[0].i_len < xfs_cui_log_format_sizeof(0)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\titem->ri_buf[0].i_addr, item->ri_buf[0].i_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tlen = xfs_cui_log_format_sizeof(cui_formatp->cui_nextents);\n\tif (item->ri_buf[0].i_len != len) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\titem->ri_buf[0].i_addr, item->ri_buf[0].i_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tcuip = xfs_cui_init(mp, cui_formatp->cui_nextents);\n\txfs_cui_copy_format(&cuip->cui_format, cui_formatp);\n\tatomic_set(&cuip->cui_next_extent, cui_formatp->cui_nextents);\n\t \n\txfs_trans_ail_insert(log->l_ailp, &cuip->cui_item, lsn);\n\txfs_cui_release(cuip);\n\treturn 0;\n}\n\nconst struct xlog_recover_item_ops xlog_cui_item_ops = {\n\t.item_type\t\t= XFS_LI_CUI,\n\t.commit_pass2\t\t= xlog_recover_cui_commit_pass2,\n};\n\n \nSTATIC int\nxlog_recover_cud_commit_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tlsn)\n{\n\tstruct xfs_cud_log_format\t*cud_formatp;\n\n\tcud_formatp = item->ri_buf[0].i_addr;\n\tif (item->ri_buf[0].i_len != sizeof(struct xfs_cud_log_format)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, log->l_mp,\n\t\t\t\titem->ri_buf[0].i_addr, item->ri_buf[0].i_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\txlog_recover_release_intent(log, XFS_LI_CUI, cud_formatp->cud_cui_id);\n\treturn 0;\n}\n\nconst struct xlog_recover_item_ops xlog_cud_item_ops = {\n\t.item_type\t\t= XFS_LI_CUD,\n\t.commit_pass2\t\t= xlog_recover_cud_commit_pass2,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}