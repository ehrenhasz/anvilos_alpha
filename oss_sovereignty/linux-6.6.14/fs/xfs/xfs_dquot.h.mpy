{
  "module_name": "xfs_dquot.h",
  "hash_id": "cbea3fa1b932b5f0cad77782a03cc77271e04ac557cd8d0e8d61c3fef7c7e5e5",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_dquot.h",
  "human_readable_source": "\n \n#ifndef __XFS_DQUOT_H__\n#define __XFS_DQUOT_H__\n\n \n\nstruct xfs_mount;\nstruct xfs_trans;\n\nenum {\n\tXFS_QLOWSP_1_PCNT = 0,\n\tXFS_QLOWSP_3_PCNT,\n\tXFS_QLOWSP_5_PCNT,\n\tXFS_QLOWSP_MAX\n};\n\nstruct xfs_dquot_res {\n\t \n\txfs_qcnt_t\t\treserved;\n\n\t \n\txfs_qcnt_t\t\tcount;\n\n\t \n\txfs_qcnt_t\t\thardlimit;\n\txfs_qcnt_t\t\tsoftlimit;\n\n\t \n\ttime64_t\t\ttimer;\n};\n\nstatic inline bool\nxfs_dquot_res_over_limits(\n\tconst struct xfs_dquot_res\t*qres)\n{\n\tif ((qres->softlimit && qres->softlimit < qres->reserved) ||\n\t    (qres->hardlimit && qres->hardlimit < qres->reserved))\n\t\treturn true;\n\treturn false;\n}\n\n \nstruct xfs_dquot {\n\tstruct list_head\tq_lru;\n\tstruct xfs_mount\t*q_mount;\n\txfs_dqtype_t\t\tq_type;\n\tuint16_t\t\tq_flags;\n\txfs_dqid_t\t\tq_id;\n\tuint\t\t\tq_nrefs;\n\tint\t\t\tq_bufoffset;\n\txfs_daddr_t\t\tq_blkno;\n\txfs_fileoff_t\t\tq_fileoffset;\n\n\tstruct xfs_dquot_res\tq_blk;\t \n\tstruct xfs_dquot_res\tq_ino;\t \n\tstruct xfs_dquot_res\tq_rtb;\t \n\n\tstruct xfs_dq_logitem\tq_logitem;\n\n\txfs_qcnt_t\t\tq_prealloc_lo_wmark;\n\txfs_qcnt_t\t\tq_prealloc_hi_wmark;\n\tint64_t\t\t\tq_low_space[XFS_QLOWSP_MAX];\n\tstruct mutex\t\tq_qlock;\n\tstruct completion\tq_flush;\n\tatomic_t\t\tq_pincount;\n\tstruct wait_queue_head\tq_pinwait;\n};\n\n \nenum {\n\tXFS_QLOCK_NORMAL = 0,\n\tXFS_QLOCK_NESTED,\n};\n\n \nstatic inline void xfs_dqflock(struct xfs_dquot *dqp)\n{\n\twait_for_completion(&dqp->q_flush);\n}\n\nstatic inline bool xfs_dqflock_nowait(struct xfs_dquot *dqp)\n{\n\treturn try_wait_for_completion(&dqp->q_flush);\n}\n\nstatic inline void xfs_dqfunlock(struct xfs_dquot *dqp)\n{\n\tcomplete(&dqp->q_flush);\n}\n\nstatic inline int xfs_dqlock_nowait(struct xfs_dquot *dqp)\n{\n\treturn mutex_trylock(&dqp->q_qlock);\n}\n\nstatic inline void xfs_dqlock(struct xfs_dquot *dqp)\n{\n\tmutex_lock(&dqp->q_qlock);\n}\n\nstatic inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}\n\nstatic inline int\nxfs_dquot_type(const struct xfs_dquot *dqp)\n{\n\treturn dqp->q_type & XFS_DQTYPE_REC_MASK;\n}\n\nstatic inline int xfs_this_quota_on(struct xfs_mount *mp, xfs_dqtype_t type)\n{\n\tswitch (type) {\n\tcase XFS_DQTYPE_USER:\n\t\treturn XFS_IS_UQUOTA_ON(mp);\n\tcase XFS_DQTYPE_GROUP:\n\t\treturn XFS_IS_GQUOTA_ON(mp);\n\tcase XFS_DQTYPE_PROJ:\n\t\treturn XFS_IS_PQUOTA_ON(mp);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic inline struct xfs_dquot *xfs_inode_dquot(\n\tstruct xfs_inode\t*ip,\n\txfs_dqtype_t\t\ttype)\n{\n\tswitch (type) {\n\tcase XFS_DQTYPE_USER:\n\t\treturn ip->i_udquot;\n\tcase XFS_DQTYPE_GROUP:\n\t\treturn ip->i_gdquot;\n\tcase XFS_DQTYPE_PROJ:\n\t\treturn ip->i_pdquot;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\n \nstatic inline bool\nxfs_dquot_is_enforced(\n\tconst struct xfs_dquot\t*dqp)\n{\n\tswitch (xfs_dquot_type(dqp)) {\n\tcase XFS_DQTYPE_USER:\n\t\treturn XFS_IS_UQUOTA_ENFORCED(dqp->q_mount);\n\tcase XFS_DQTYPE_GROUP:\n\t\treturn XFS_IS_GQUOTA_ENFORCED(dqp->q_mount);\n\tcase XFS_DQTYPE_PROJ:\n\t\treturn XFS_IS_PQUOTA_ENFORCED(dqp->q_mount);\n\t}\n\tASSERT(0);\n\treturn false;\n}\n\n \nstatic inline bool xfs_dquot_lowsp(struct xfs_dquot *dqp)\n{\n\tint64_t freesp;\n\n\tfreesp = dqp->q_blk.hardlimit - dqp->q_blk.reserved;\n\tif (freesp < dqp->q_low_space[XFS_QLOWSP_1_PCNT])\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid xfs_dquot_to_disk(struct xfs_disk_dquot *ddqp, struct xfs_dquot *dqp);\n\n#define XFS_DQ_IS_LOCKED(dqp)\t(mutex_is_locked(&((dqp)->q_qlock)))\n#define XFS_DQ_IS_DIRTY(dqp)\t((dqp)->q_flags & XFS_DQFLAG_DIRTY)\n\nvoid\t\txfs_qm_dqdestroy(struct xfs_dquot *dqp);\nint\t\txfs_qm_dqflush(struct xfs_dquot *dqp, struct xfs_buf **bpp);\nvoid\t\txfs_qm_dqunpin_wait(struct xfs_dquot *dqp);\nvoid\t\txfs_qm_adjust_dqtimers(struct xfs_dquot *d);\nvoid\t\txfs_qm_adjust_dqlimits(struct xfs_dquot *d);\nxfs_dqid_t\txfs_qm_id_for_quotatype(struct xfs_inode *ip,\n\t\t\t\txfs_dqtype_t type);\nint\t\txfs_qm_dqget(struct xfs_mount *mp, xfs_dqid_t id,\n\t\t\t\txfs_dqtype_t type, bool can_alloc,\n\t\t\t\tstruct xfs_dquot **dqpp);\nint\t\txfs_qm_dqget_inode(struct xfs_inode *ip, xfs_dqtype_t type,\n\t\t\t\tbool can_alloc, struct xfs_dquot **dqpp);\nint\t\txfs_qm_dqget_next(struct xfs_mount *mp, xfs_dqid_t id,\n\t\t\t\txfs_dqtype_t type, struct xfs_dquot **dqpp);\nint\t\txfs_qm_dqget_uncached(struct xfs_mount *mp,\n\t\t\t\txfs_dqid_t id, xfs_dqtype_t type,\n\t\t\t\tstruct xfs_dquot **dqpp);\nvoid\t\txfs_qm_dqput(struct xfs_dquot *dqp);\n\nvoid\t\txfs_dqlock2(struct xfs_dquot *, struct xfs_dquot *);\n\nvoid\t\txfs_dquot_set_prealloc_limits(struct xfs_dquot *);\n\nstatic inline struct xfs_dquot *xfs_qm_dqhold(struct xfs_dquot *dqp)\n{\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs++;\n\txfs_dqunlock(dqp);\n\treturn dqp;\n}\n\ntypedef int (*xfs_qm_dqiterate_fn)(struct xfs_dquot *dq,\n\t\txfs_dqtype_t type, void *priv);\nint xfs_qm_dqiterate(struct xfs_mount *mp, xfs_dqtype_t type,\n\t\txfs_qm_dqiterate_fn iter_fn, void *priv);\n\ntime64_t xfs_dquot_set_timeout(struct xfs_mount *mp, time64_t timeout);\ntime64_t xfs_dquot_set_grace_period(time64_t grace);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}