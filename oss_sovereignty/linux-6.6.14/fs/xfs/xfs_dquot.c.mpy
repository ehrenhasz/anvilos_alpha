{
  "module_name": "xfs_dquot.c",
  "hash_id": "98905d8bf2cbb8e99551b9fe8b5db7a2b0d821cdc4ba6a9f4c62f9dd08c3983d",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_dquot.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_error.h\"\n\n \n\nstruct kmem_cache\t\t*xfs_dqtrx_cache;\nstatic struct kmem_cache\t*xfs_dquot_cache;\n\nstatic struct lock_class_key xfs_dquot_group_class;\nstatic struct lock_class_key xfs_dquot_project_class;\n\n \nvoid\nxfs_qm_dqdestroy(\n\tstruct xfs_dquot\t*dqp)\n{\n\tASSERT(list_empty(&dqp->q_lru));\n\n\tkmem_free(dqp->q_logitem.qli_item.li_lv_shadow);\n\tmutex_destroy(&dqp->q_qlock);\n\n\tXFS_STATS_DEC(dqp->q_mount, xs_qm_dquot);\n\tkmem_cache_free(xfs_dquot_cache, dqp);\n}\n\n \nvoid\nxfs_qm_adjust_dqlimits(\n\tstruct xfs_dquot\t*dq)\n{\n\tstruct xfs_mount\t*mp = dq->q_mount;\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_def_quota\t*defq;\n\tint\t\t\tprealloc = 0;\n\n\tASSERT(dq->q_id);\n\tdefq = xfs_get_defquota(q, xfs_dquot_type(dq));\n\n\tif (!dq->q_blk.softlimit) {\n\t\tdq->q_blk.softlimit = defq->blk.soft;\n\t\tprealloc = 1;\n\t}\n\tif (!dq->q_blk.hardlimit) {\n\t\tdq->q_blk.hardlimit = defq->blk.hard;\n\t\tprealloc = 1;\n\t}\n\tif (!dq->q_ino.softlimit)\n\t\tdq->q_ino.softlimit = defq->ino.soft;\n\tif (!dq->q_ino.hardlimit)\n\t\tdq->q_ino.hardlimit = defq->ino.hard;\n\tif (!dq->q_rtb.softlimit)\n\t\tdq->q_rtb.softlimit = defq->rtb.soft;\n\tif (!dq->q_rtb.hardlimit)\n\t\tdq->q_rtb.hardlimit = defq->rtb.hard;\n\n\tif (prealloc)\n\t\txfs_dquot_set_prealloc_limits(dq);\n}\n\n \ntime64_t\nxfs_dquot_set_timeout(\n\tstruct xfs_mount\t*mp,\n\ttime64_t\t\ttimeout)\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\n\treturn clamp_t(time64_t, timeout, qi->qi_expiry_min,\n\t\t\t\t\t  qi->qi_expiry_max);\n}\n\n \ntime64_t\nxfs_dquot_set_grace_period(\n\ttime64_t\t\tgrace)\n{\n\treturn clamp_t(time64_t, grace, XFS_DQ_GRACE_MIN, XFS_DQ_GRACE_MAX);\n}\n\n \nstatic inline void\nxfs_qm_adjust_res_timer(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot_res\t*res,\n\tstruct xfs_quota_limits\t*qlim)\n{\n\tASSERT(res->hardlimit == 0 || res->softlimit <= res->hardlimit);\n\n\tif ((res->softlimit && res->count > res->softlimit) ||\n\t    (res->hardlimit && res->count > res->hardlimit)) {\n\t\tif (res->timer == 0)\n\t\t\tres->timer = xfs_dquot_set_timeout(mp,\n\t\t\t\t\tktime_get_real_seconds() + qlim->time);\n\t} else {\n\t\tres->timer = 0;\n\t}\n}\n\n \nvoid\nxfs_qm_adjust_dqtimers(\n\tstruct xfs_dquot\t*dq)\n{\n\tstruct xfs_mount\t*mp = dq->q_mount;\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct xfs_def_quota\t*defq;\n\n\tASSERT(dq->q_id);\n\tdefq = xfs_get_defquota(qi, xfs_dquot_type(dq));\n\n\txfs_qm_adjust_res_timer(dq->q_mount, &dq->q_blk, &defq->blk);\n\txfs_qm_adjust_res_timer(dq->q_mount, &dq->q_ino, &defq->ino);\n\txfs_qm_adjust_res_timer(dq->q_mount, &dq->q_rtb, &defq->rtb);\n}\n\n \nSTATIC void\nxfs_qm_init_dquot_blk(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\txfs_dqtype_t\t\ttype,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_dqblk\t*d;\n\txfs_dqid_t\t\tcurid;\n\tunsigned int\t\tqflag;\n\tunsigned int\t\tblftype;\n\tint\t\t\ti;\n\n\tASSERT(tp);\n\tASSERT(xfs_buf_islocked(bp));\n\n\tswitch (type) {\n\tcase XFS_DQTYPE_USER:\n\t\tqflag = XFS_UQUOTA_CHKD;\n\t\tblftype = XFS_BLF_UDQUOT_BUF;\n\t\tbreak;\n\tcase XFS_DQTYPE_PROJ:\n\t\tqflag = XFS_PQUOTA_CHKD;\n\t\tblftype = XFS_BLF_PDQUOT_BUF;\n\t\tbreak;\n\tcase XFS_DQTYPE_GROUP:\n\t\tqflag = XFS_GQUOTA_CHKD;\n\t\tblftype = XFS_BLF_GDQUOT_BUF;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\td = bp->b_addr;\n\n\t \n\tcurid = id - (id % q->qi_dqperchunk);\n\tmemset(d, 0, BBTOB(q->qi_dqchunklen));\n\tfor (i = 0; i < q->qi_dqperchunk; i++, d++, curid++) {\n\t\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\t\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\t\td->dd_diskdq.d_id = cpu_to_be32(curid);\n\t\td->dd_diskdq.d_type = type;\n\t\tif (curid > 0 && xfs_has_bigtime(mp))\n\t\t\td->dd_diskdq.d_type |= XFS_DQTYPE_BIGTIME;\n\t\tif (xfs_has_crc(mp)) {\n\t\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_meta_uuid);\n\t\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t\t}\n\t}\n\n\txfs_trans_dquot_buf(tp, bp, blftype);\n\n\t \n\tif (!(mp->m_qflags & qflag))\n\t\txfs_trans_ordered_buf(tp, bp);\n\telse\n\t\txfs_trans_log_buf(tp, bp, 0, BBTOB(q->qi_dqchunklen) - 1);\n}\n\n \nvoid\nxfs_dquot_set_prealloc_limits(struct xfs_dquot *dqp)\n{\n\tuint64_t space;\n\n\tdqp->q_prealloc_hi_wmark = dqp->q_blk.hardlimit;\n\tdqp->q_prealloc_lo_wmark = dqp->q_blk.softlimit;\n\tif (!dqp->q_prealloc_lo_wmark) {\n\t\tdqp->q_prealloc_lo_wmark = dqp->q_prealloc_hi_wmark;\n\t\tdo_div(dqp->q_prealloc_lo_wmark, 100);\n\t\tdqp->q_prealloc_lo_wmark *= 95;\n\t}\n\n\tspace = dqp->q_prealloc_hi_wmark;\n\n\tdo_div(space, 100);\n\tdqp->q_low_space[XFS_QLOWSP_1_PCNT] = space;\n\tdqp->q_low_space[XFS_QLOWSP_3_PCNT] = space * 3;\n\tdqp->q_low_space[XFS_QLOWSP_5_PCNT] = space * 5;\n}\n\n \nSTATIC int\nxfs_dquot_disk_alloc(\n\tstruct xfs_dquot\t*dqp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_bmbt_irec\tmap;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dqtype_t\t\tqtype = xfs_dquot_type(dqp);\n\tstruct xfs_inode\t*quotip = xfs_quota_inode(mp, qtype);\n\tint\t\t\tnmaps = 1;\n\tint\t\t\terror;\n\n\ttrace_xfs_dqalloc(dqp);\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_qm_dqalloc,\n\t\t\tXFS_QM_DQALLOC_SPACE_RES(mp), 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(quotip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, quotip, 0);\n\n\tif (!xfs_this_quota_on(dqp->q_mount, qtype)) {\n\t\t \n\t\terror = -ESRCH;\n\t\tgoto err_cancel;\n\t}\n\n\terror = xfs_iext_count_may_overflow(quotip, XFS_DATA_FORK,\n\t\t\tXFS_IEXT_ADD_NOSPLIT_CNT);\n\tif (error == -EFBIG)\n\t\terror = xfs_iext_count_upgrade(tp, quotip,\n\t\t\t\tXFS_IEXT_ADD_NOSPLIT_CNT);\n\tif (error)\n\t\tgoto err_cancel;\n\n\t \n\terror = xfs_bmapi_write(tp, quotip, dqp->q_fileoffset,\n\t\t\tXFS_DQUOT_CLUSTER_SIZE_FSB, XFS_BMAPI_METADATA, 0, &map,\n\t\t\t&nmaps);\n\tif (error)\n\t\tgoto err_cancel;\n\n\tASSERT(map.br_blockcount == XFS_DQUOT_CLUSTER_SIZE_FSB);\n\tASSERT(nmaps == 1);\n\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t \n\tdqp->q_blkno = XFS_FSB_TO_DADDR(mp, map.br_startblock);\n\n\t \n\terror = xfs_trans_get_buf(tp, mp->m_ddev_targp, dqp->q_blkno,\n\t\t\tmp->m_quotainfo->qi_dqchunklen, 0, &bp);\n\tif (error)\n\t\tgoto err_cancel;\n\tbp->b_ops = &xfs_dquot_buf_ops;\n\n\t \n\txfs_qm_init_dquot_blk(tp, mp, dqp->q_id, qtype, bp);\n\txfs_buf_set_ref(bp, XFS_DQUOT_REF);\n\n\t \n\txfs_trans_bhold(tp, bp);\n\terror = xfs_trans_commit(tp);\n\txfs_iunlock(quotip, XFS_ILOCK_EXCL);\n\tif (error) {\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\treturn 0;\n\nerr_cancel:\n\txfs_trans_cancel(tp);\n\txfs_iunlock(quotip, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_dquot_disk_read(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*dqp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_bmbt_irec\tmap;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dqtype_t\t\tqtype = xfs_dquot_type(dqp);\n\tstruct xfs_inode\t*quotip = xfs_quota_inode(mp, qtype);\n\tuint\t\t\tlock_mode;\n\tint\t\t\tnmaps = 1;\n\tint\t\t\terror;\n\n\tlock_mode = xfs_ilock_data_map_shared(quotip);\n\tif (!xfs_this_quota_on(mp, qtype)) {\n\t\t \n\t\txfs_iunlock(quotip, lock_mode);\n\t\treturn -ESRCH;\n\t}\n\n\t \n\terror = xfs_bmapi_read(quotip, dqp->q_fileoffset,\n\t\t\tXFS_DQUOT_CLUSTER_SIZE_FSB, &map, &nmaps, 0);\n\txfs_iunlock(quotip, lock_mode);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nmaps == 1);\n\tASSERT(map.br_blockcount >= 1);\n\tASSERT(map.br_startblock != DELAYSTARTBLOCK);\n\tif (map.br_startblock == HOLESTARTBLOCK)\n\t\treturn -ENOENT;\n\n\ttrace_xfs_dqtobp_read(dqp);\n\n\t \n\tdqp->q_blkno = XFS_FSB_TO_DADDR(mp, map.br_startblock);\n\n\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dqp->q_blkno,\n\t\t\tmp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t&xfs_dquot_buf_ops);\n\tif (error) {\n\t\tASSERT(bp == NULL);\n\t\treturn error;\n\t}\n\n\tASSERT(xfs_buf_islocked(bp));\n\txfs_buf_set_ref(bp, XFS_DQUOT_REF);\n\t*bpp = bp;\n\n\treturn 0;\n}\n\n \nSTATIC struct xfs_dquot *\nxfs_dquot_alloc(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\txfs_dqtype_t\t\ttype)\n{\n\tstruct xfs_dquot\t*dqp;\n\n\tdqp = kmem_cache_zalloc(xfs_dquot_cache, GFP_KERNEL | __GFP_NOFAIL);\n\n\tdqp->q_type = type;\n\tdqp->q_id = id;\n\tdqp->q_mount = mp;\n\tINIT_LIST_HEAD(&dqp->q_lru);\n\tmutex_init(&dqp->q_qlock);\n\tinit_waitqueue_head(&dqp->q_pinwait);\n\tdqp->q_fileoffset = (xfs_fileoff_t)id / mp->m_quotainfo->qi_dqperchunk;\n\t \n\tdqp->q_bufoffset = (id % mp->m_quotainfo->qi_dqperchunk) *\n\t\t\tsizeof(struct xfs_dqblk);\n\n\t \n\tinit_completion(&dqp->q_flush);\n\tcomplete(&dqp->q_flush);\n\n\t \n\tswitch (type) {\n\tcase XFS_DQTYPE_USER:\n\t\t \n\t\tbreak;\n\tcase XFS_DQTYPE_GROUP:\n\t\tlockdep_set_class(&dqp->q_qlock, &xfs_dquot_group_class);\n\t\tbreak;\n\tcase XFS_DQTYPE_PROJ:\n\t\tlockdep_set_class(&dqp->q_qlock, &xfs_dquot_project_class);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n\n\txfs_qm_dquot_logitem_init(dqp);\n\n\tXFS_STATS_INC(mp, xs_qm_dquot);\n\treturn dqp;\n}\n\n \nstatic bool\nxfs_dquot_check_type(\n\tstruct xfs_dquot\t*dqp,\n\tstruct xfs_disk_dquot\t*ddqp)\n{\n\tuint8_t\t\t\tddqp_type;\n\tuint8_t\t\t\tdqp_type;\n\n\tddqp_type = ddqp->d_type & XFS_DQTYPE_REC_MASK;\n\tdqp_type = xfs_dquot_type(dqp);\n\n\tif (be32_to_cpu(ddqp->d_id) != dqp->q_id)\n\t\treturn false;\n\n\t \n\tif (xfs_has_crc(dqp->q_mount) ||\n\t    dqp_type == XFS_DQTYPE_USER || dqp->q_id != 0)\n\t\treturn ddqp_type == dqp_type;\n\n\t \n\treturn ddqp_type == XFS_DQTYPE_GROUP || ddqp_type == XFS_DQTYPE_PROJ;\n}\n\n \nSTATIC int\nxfs_dquot_from_disk(\n\tstruct xfs_dquot\t*dqp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_disk_dquot\t*ddqp = bp->b_addr + dqp->q_bufoffset;\n\n\t \n\tif (!xfs_dquot_check_type(dqp, ddqp)) {\n\t\txfs_alert_tag(bp->b_mount, XFS_PTAG_VERIFIER_ERROR,\n\t\t\t  \"Metadata corruption detected at %pS, quota %u\",\n\t\t\t  __this_address, dqp->q_id);\n\t\txfs_alert(bp->b_mount, \"Unmount and run xfs_repair\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\tdqp->q_type = ddqp->d_type;\n\tdqp->q_blk.hardlimit = be64_to_cpu(ddqp->d_blk_hardlimit);\n\tdqp->q_blk.softlimit = be64_to_cpu(ddqp->d_blk_softlimit);\n\tdqp->q_ino.hardlimit = be64_to_cpu(ddqp->d_ino_hardlimit);\n\tdqp->q_ino.softlimit = be64_to_cpu(ddqp->d_ino_softlimit);\n\tdqp->q_rtb.hardlimit = be64_to_cpu(ddqp->d_rtb_hardlimit);\n\tdqp->q_rtb.softlimit = be64_to_cpu(ddqp->d_rtb_softlimit);\n\n\tdqp->q_blk.count = be64_to_cpu(ddqp->d_bcount);\n\tdqp->q_ino.count = be64_to_cpu(ddqp->d_icount);\n\tdqp->q_rtb.count = be64_to_cpu(ddqp->d_rtbcount);\n\n\tdqp->q_blk.timer = xfs_dquot_from_disk_ts(ddqp, ddqp->d_btimer);\n\tdqp->q_ino.timer = xfs_dquot_from_disk_ts(ddqp, ddqp->d_itimer);\n\tdqp->q_rtb.timer = xfs_dquot_from_disk_ts(ddqp, ddqp->d_rtbtimer);\n\n\t \n\tdqp->q_blk.reserved = dqp->q_blk.count;\n\tdqp->q_ino.reserved = dqp->q_ino.count;\n\tdqp->q_rtb.reserved = dqp->q_rtb.count;\n\n\t \n\txfs_dquot_set_prealloc_limits(dqp);\n\treturn 0;\n}\n\n \nvoid\nxfs_dquot_to_disk(\n\tstruct xfs_disk_dquot\t*ddqp,\n\tstruct xfs_dquot\t*dqp)\n{\n\tddqp->d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\tddqp->d_version = XFS_DQUOT_VERSION;\n\tddqp->d_type = dqp->q_type;\n\tddqp->d_id = cpu_to_be32(dqp->q_id);\n\tddqp->d_pad0 = 0;\n\tddqp->d_pad = 0;\n\n\tddqp->d_blk_hardlimit = cpu_to_be64(dqp->q_blk.hardlimit);\n\tddqp->d_blk_softlimit = cpu_to_be64(dqp->q_blk.softlimit);\n\tddqp->d_ino_hardlimit = cpu_to_be64(dqp->q_ino.hardlimit);\n\tddqp->d_ino_softlimit = cpu_to_be64(dqp->q_ino.softlimit);\n\tddqp->d_rtb_hardlimit = cpu_to_be64(dqp->q_rtb.hardlimit);\n\tddqp->d_rtb_softlimit = cpu_to_be64(dqp->q_rtb.softlimit);\n\n\tddqp->d_bcount = cpu_to_be64(dqp->q_blk.count);\n\tddqp->d_icount = cpu_to_be64(dqp->q_ino.count);\n\tddqp->d_rtbcount = cpu_to_be64(dqp->q_rtb.count);\n\n\tddqp->d_bwarns = 0;\n\tddqp->d_iwarns = 0;\n\tddqp->d_rtbwarns = 0;\n\n\tddqp->d_btimer = xfs_dquot_to_disk_ts(dqp, dqp->q_blk.timer);\n\tddqp->d_itimer = xfs_dquot_to_disk_ts(dqp, dqp->q_ino.timer);\n\tddqp->d_rtbtimer = xfs_dquot_to_disk_ts(dqp, dqp->q_rtb.timer);\n}\n\n \nstatic int\nxfs_qm_dqread(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\txfs_dqtype_t\t\ttype,\n\tbool\t\t\tcan_alloc,\n\tstruct xfs_dquot\t**dqpp)\n{\n\tstruct xfs_dquot\t*dqp;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tdqp = xfs_dquot_alloc(mp, id, type);\n\ttrace_xfs_dqread(dqp);\n\n\t \n\terror = xfs_dquot_disk_read(mp, dqp, &bp);\n\tif (error == -ENOENT && can_alloc)\n\t\terror = xfs_dquot_disk_alloc(dqp, &bp);\n\tif (error)\n\t\tgoto err;\n\n\t \n\tASSERT(xfs_buf_islocked(bp));\n\terror = xfs_dquot_from_disk(dqp, bp);\n\txfs_buf_relse(bp);\n\tif (error)\n\t\tgoto err;\n\n\t*dqpp = dqp;\n\treturn error;\n\nerr:\n\ttrace_xfs_dqread_fail(dqp);\n\txfs_qm_dqdestroy(dqp);\n\t*dqpp = NULL;\n\treturn error;\n}\n\n \nstatic int\nxfs_dq_get_next_id(\n\tstruct xfs_mount\t*mp,\n\txfs_dqtype_t\t\ttype,\n\txfs_dqid_t\t\t*id)\n{\n\tstruct xfs_inode\t*quotip = xfs_quota_inode(mp, type);\n\txfs_dqid_t\t\tnext_id = *id + 1;  \n\tuint\t\t\tlock_flags;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_iext_cursor\tcur;\n\txfs_fsblock_t\t\tstart;\n\tint\t\t\terror = 0;\n\n\t \n\tif (next_id < *id)\n\t\treturn -ENOENT;\n\n\t \n\tif (next_id % mp->m_quotainfo->qi_dqperchunk) {\n\t\t*id = next_id;\n\t\treturn 0;\n\t}\n\n\t \n\tstart = (xfs_fsblock_t)next_id / mp->m_quotainfo->qi_dqperchunk;\n\n\tlock_flags = xfs_ilock_data_map_shared(quotip);\n\terror = xfs_iread_extents(NULL, quotip, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\tif (xfs_iext_lookup_extent(quotip, &quotip->i_df, start, &cur, &got)) {\n\t\t \n\t\tif (got.br_startoff < start)\n\t\t\tgot.br_startoff = start;\n\t\t*id = got.br_startoff * mp->m_quotainfo->qi_dqperchunk;\n\t} else {\n\t\terror = -ENOENT;\n\t}\n\n\txfs_iunlock(quotip, lock_flags);\n\n\treturn error;\n}\n\n \nstatic struct xfs_dquot *\nxfs_qm_dqget_cache_lookup(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_quotainfo\t*qi,\n\tstruct radix_tree_root\t*tree,\n\txfs_dqid_t\t\tid)\n{\n\tstruct xfs_dquot\t*dqp;\n\nrestart:\n\tmutex_lock(&qi->qi_tree_lock);\n\tdqp = radix_tree_lookup(tree, id);\n\tif (!dqp) {\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\tXFS_STATS_INC(mp, xs_qm_dqcachemisses);\n\t\treturn NULL;\n\t}\n\n\txfs_dqlock(dqp);\n\tif (dqp->q_flags & XFS_DQFLAG_FREEING) {\n\t\txfs_dqunlock(dqp);\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\ttrace_xfs_dqget_freeing(dqp);\n\t\tdelay(1);\n\t\tgoto restart;\n\t}\n\n\tdqp->q_nrefs++;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n\ttrace_xfs_dqget_hit(dqp);\n\tXFS_STATS_INC(mp, xs_qm_dqcachehits);\n\treturn dqp;\n}\n\n \nstatic int\nxfs_qm_dqget_cache_insert(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_quotainfo\t*qi,\n\tstruct radix_tree_root\t*tree,\n\txfs_dqid_t\t\tid,\n\tstruct xfs_dquot\t*dqp)\n{\n\tint\t\t\terror;\n\n\tmutex_lock(&qi->qi_tree_lock);\n\terror = radix_tree_insert(tree, id, dqp);\n\tif (unlikely(error)) {\n\t\t \n\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\ttrace_xfs_dqget_dup(dqp);\n\t\treturn error;\n\t}\n\n\t \n\txfs_dqlock(dqp);\n\tdqp->q_nrefs = 1;\n\n\tqi->qi_dquots++;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n\treturn 0;\n}\n\n \nstatic int\nxfs_qm_dqget_checks(\n\tstruct xfs_mount\t*mp,\n\txfs_dqtype_t\t\ttype)\n{\n\tswitch (type) {\n\tcase XFS_DQTYPE_USER:\n\t\tif (!XFS_IS_UQUOTA_ON(mp))\n\t\t\treturn -ESRCH;\n\t\treturn 0;\n\tcase XFS_DQTYPE_GROUP:\n\t\tif (!XFS_IS_GQUOTA_ON(mp))\n\t\t\treturn -ESRCH;\n\t\treturn 0;\n\tcase XFS_DQTYPE_PROJ:\n\t\tif (!XFS_IS_PQUOTA_ON(mp))\n\t\t\treturn -ESRCH;\n\t\treturn 0;\n\tdefault:\n\t\tWARN_ON_ONCE(0);\n\t\treturn -EINVAL;\n\t}\n}\n\n \nint\nxfs_qm_dqget(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\txfs_dqtype_t\t\ttype,\n\tbool\t\t\tcan_alloc,\n\tstruct xfs_dquot\t**O_dqpp)\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root\t*tree = xfs_dquot_tree(qi, type);\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\terror = xfs_qm_dqget_checks(mp, type);\n\tif (error)\n\t\treturn error;\n\nrestart:\n\tdqp = xfs_qm_dqget_cache_lookup(mp, qi, tree, id);\n\tif (dqp) {\n\t\t*O_dqpp = dqp;\n\t\treturn 0;\n\t}\n\n\terror = xfs_qm_dqread(mp, id, type, can_alloc, &dqp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_qm_dqget_cache_insert(mp, qi, tree, id, dqp);\n\tif (error) {\n\t\t \n\t\txfs_qm_dqdestroy(dqp);\n\t\tXFS_STATS_INC(mp, xs_qm_dquot_dups);\n\t\tgoto restart;\n\t}\n\n\ttrace_xfs_dqget_miss(dqp);\n\t*O_dqpp = dqp;\n\treturn 0;\n}\n\n \nint\nxfs_qm_dqget_uncached(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\txfs_dqtype_t\t\ttype,\n\tstruct xfs_dquot\t**dqpp)\n{\n\tint\t\t\terror;\n\n\terror = xfs_qm_dqget_checks(mp, type);\n\tif (error)\n\t\treturn error;\n\n\treturn xfs_qm_dqread(mp, id, type, 0, dqpp);\n}\n\n \nxfs_dqid_t\nxfs_qm_id_for_quotatype(\n\tstruct xfs_inode\t*ip,\n\txfs_dqtype_t\t\ttype)\n{\n\tswitch (type) {\n\tcase XFS_DQTYPE_USER:\n\t\treturn i_uid_read(VFS_I(ip));\n\tcase XFS_DQTYPE_GROUP:\n\t\treturn i_gid_read(VFS_I(ip));\n\tcase XFS_DQTYPE_PROJ:\n\t\treturn ip->i_projid;\n\t}\n\tASSERT(0);\n\treturn 0;\n}\n\n \nint\nxfs_qm_dqget_inode(\n\tstruct xfs_inode\t*ip,\n\txfs_dqtype_t\t\ttype,\n\tbool\t\t\tcan_alloc,\n\tstruct xfs_dquot\t**O_dqpp)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root\t*tree = xfs_dquot_tree(qi, type);\n\tstruct xfs_dquot\t*dqp;\n\txfs_dqid_t\t\tid;\n\tint\t\t\terror;\n\n\terror = xfs_qm_dqget_checks(mp, type);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(xfs_inode_dquot(ip, type) == NULL);\n\n\tid = xfs_qm_id_for_quotatype(ip, type);\n\nrestart:\n\tdqp = xfs_qm_dqget_cache_lookup(mp, qi, tree, id);\n\tif (dqp) {\n\t\t*O_dqpp = dqp;\n\t\treturn 0;\n\t}\n\n\t \n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqread(mp, id, type, can_alloc, &dqp);\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (xfs_this_quota_on(mp, type)) {\n\t\tstruct xfs_dquot\t*dqp1;\n\n\t\tdqp1 = xfs_inode_dquot(ip, type);\n\t\tif (dqp1) {\n\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\tdqp = dqp1;\n\t\t\txfs_dqlock(dqp);\n\t\t\tgoto dqret;\n\t\t}\n\t} else {\n\t\t \n\t\txfs_qm_dqdestroy(dqp);\n\t\treturn -ESRCH;\n\t}\n\n\terror = xfs_qm_dqget_cache_insert(mp, qi, tree, id, dqp);\n\tif (error) {\n\t\t \n\t\txfs_qm_dqdestroy(dqp);\n\t\tXFS_STATS_INC(mp, xs_qm_dquot_dups);\n\t\tgoto restart;\n\t}\n\ndqret:\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\ttrace_xfs_dqget_miss(dqp);\n\t*O_dqpp = dqp;\n\treturn 0;\n}\n\n \nint\nxfs_qm_dqget_next(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\txfs_dqtype_t\t\ttype,\n\tstruct xfs_dquot\t**dqpp)\n{\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror = 0;\n\n\t*dqpp = NULL;\n\tfor (; !error; error = xfs_dq_get_next_id(mp, type, &id)) {\n\t\terror = xfs_qm_dqget(mp, id, type, false, &dqp);\n\t\tif (error == -ENOENT)\n\t\t\tcontinue;\n\t\telse if (error != 0)\n\t\t\tbreak;\n\n\t\tif (!XFS_IS_DQUOT_UNINITIALIZED(dqp)) {\n\t\t\t*dqpp = dqp;\n\t\t\treturn 0;\n\t\t}\n\n\t\txfs_qm_dqput(dqp);\n\t}\n\n\treturn error;\n}\n\n \nvoid\nxfs_qm_dqput(\n\tstruct xfs_dquot\t*dqp)\n{\n\tASSERT(dqp->q_nrefs > 0);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\ttrace_xfs_dqput(dqp);\n\n\tif (--dqp->q_nrefs == 0) {\n\t\tstruct xfs_quotainfo\t*qi = dqp->q_mount->m_quotainfo;\n\t\ttrace_xfs_dqput_free(dqp);\n\n\t\tif (list_lru_add(&qi->qi_lru, &dqp->q_lru))\n\t\t\tXFS_STATS_INC(dqp->q_mount, xs_qm_dquot_unused);\n\t}\n\txfs_dqunlock(dqp);\n}\n\n \nvoid\nxfs_qm_dqrele(\n\tstruct xfs_dquot\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t \n\txfs_qm_dqput(dqp);\n}\n\n \nstatic void\nxfs_qm_dqflush_done(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_dq_logitem\t*qip = (struct xfs_dq_logitem *)lip;\n\tstruct xfs_dquot\t*dqp = qip->qli_dquot;\n\tstruct xfs_ail\t\t*ailp = lip->li_ailp;\n\txfs_lsn_t\t\ttail_lsn;\n\n\t \n\tif (test_bit(XFS_LI_IN_AIL, &lip->li_flags) &&\n\t    ((lip->li_lsn == qip->qli_flush_lsn) ||\n\t     test_bit(XFS_LI_FAILED, &lip->li_flags))) {\n\n\t\tspin_lock(&ailp->ail_lock);\n\t\txfs_clear_li_failed(lip);\n\t\tif (lip->li_lsn == qip->qli_flush_lsn) {\n\t\t\t \n\t\t\ttail_lsn = xfs_ail_delete_one(ailp, lip);\n\t\t\txfs_ail_update_finish(ailp, tail_lsn);\n\t\t} else {\n\t\t\tspin_unlock(&ailp->ail_lock);\n\t\t}\n\t}\n\n\t \n\txfs_dqfunlock(dqp);\n}\n\nvoid\nxfs_buf_dquot_iodone(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_log_item\t*lip, *n;\n\n\tlist_for_each_entry_safe(lip, n, &bp->b_li_list, li_bio_list) {\n\t\tlist_del_init(&lip->li_bio_list);\n\t\txfs_qm_dqflush_done(lip);\n\t}\n}\n\nvoid\nxfs_buf_dquot_io_fail(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_log_item\t*lip;\n\n\tspin_lock(&bp->b_mount->m_ail->ail_lock);\n\tlist_for_each_entry(lip, &bp->b_li_list, li_bio_list)\n\t\txfs_set_li_failed(lip, bp);\n\tspin_unlock(&bp->b_mount->m_ail->ail_lock);\n}\n\n \nstatic xfs_failaddr_t\nxfs_qm_dqflush_check(\n\tstruct xfs_dquot\t*dqp)\n{\n\txfs_dqtype_t\t\ttype = xfs_dquot_type(dqp);\n\n\tif (type != XFS_DQTYPE_USER &&\n\t    type != XFS_DQTYPE_GROUP &&\n\t    type != XFS_DQTYPE_PROJ)\n\t\treturn __this_address;\n\n\tif (dqp->q_id == 0)\n\t\treturn NULL;\n\n\tif (dqp->q_blk.softlimit && dqp->q_blk.count > dqp->q_blk.softlimit &&\n\t    !dqp->q_blk.timer)\n\t\treturn __this_address;\n\n\tif (dqp->q_ino.softlimit && dqp->q_ino.count > dqp->q_ino.softlimit &&\n\t    !dqp->q_ino.timer)\n\t\treturn __this_address;\n\n\tif (dqp->q_rtb.softlimit && dqp->q_rtb.count > dqp->q_rtb.softlimit &&\n\t    !dqp->q_rtb.timer)\n\t\treturn __this_address;\n\n\t \n\tif (dqp->q_type & XFS_DQTYPE_BIGTIME) {\n\t\tif (!xfs_has_bigtime(dqp->q_mount))\n\t\t\treturn __this_address;\n\t\tif (dqp->q_id == 0)\n\t\t\treturn __this_address;\n\t}\n\n\treturn NULL;\n}\n\n \nint\nxfs_qm_dqflush(\n\tstruct xfs_dquot\t*dqp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_log_item\t*lip = &dqp->q_logitem.qli_item;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_dqblk\t*dqblk;\n\txfs_failaddr_t\t\tfa;\n\tint\t\t\terror;\n\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tASSERT(!completion_done(&dqp->q_flush));\n\n\ttrace_xfs_dqflush(dqp);\n\n\t*bpp = NULL;\n\n\txfs_qm_dqunpin_wait(dqp);\n\n\t \n\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dqp->q_blkno,\n\t\t\t\t   mp->m_quotainfo->qi_dqchunklen, XBF_TRYLOCK,\n\t\t\t\t   &bp, &xfs_dquot_buf_ops);\n\tif (error == -EAGAIN)\n\t\tgoto out_unlock;\n\tif (error)\n\t\tgoto out_abort;\n\n\tfa = xfs_qm_dqflush_check(dqp);\n\tif (fa) {\n\t\txfs_alert(mp, \"corrupt dquot ID 0x%x in memory at %pS\",\n\t\t\t\tdqp->q_id, fa);\n\t\txfs_buf_relse(bp);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_abort;\n\t}\n\n\t \n\tdqblk = bp->b_addr + dqp->q_bufoffset;\n\txfs_dquot_to_disk(&dqblk->dd_diskdq, dqp);\n\n\t \n\tdqp->q_flags &= ~XFS_DQFLAG_DIRTY;\n\n\txfs_trans_ail_copy_lsn(mp->m_ail, &dqp->q_logitem.qli_flush_lsn,\n\t\t\t\t\t&dqp->q_logitem.qli_item.li_lsn);\n\n\t \n\tif (xfs_has_crc(mp)) {\n\t\tdqblk->dd_lsn = cpu_to_be64(dqp->q_logitem.qli_item.li_lsn);\n\t\txfs_update_cksum((char *)dqblk, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\t \n\tbp->b_flags |= _XBF_DQUOTS;\n\tlist_add_tail(&dqp->q_logitem.qli_item.li_bio_list, &bp->b_li_list);\n\n\t \n\tif (xfs_buf_ispinned(bp)) {\n\t\ttrace_xfs_dqflush_force(dqp);\n\t\txfs_log_force(mp, 0);\n\t}\n\n\ttrace_xfs_dqflush_done(dqp);\n\t*bpp = bp;\n\treturn 0;\n\nout_abort:\n\tdqp->q_flags &= ~XFS_DQFLAG_DIRTY;\n\txfs_trans_ail_delete(lip, 0);\n\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\nout_unlock:\n\txfs_dqfunlock(dqp);\n\treturn error;\n}\n\n \nvoid\nxfs_dqlock2(\n\tstruct xfs_dquot\t*d1,\n\tstruct xfs_dquot\t*d2)\n{\n\tif (d1 && d2) {\n\t\tASSERT(d1 != d2);\n\t\tif (d1->q_id > d2->q_id) {\n\t\t\tmutex_lock(&d2->q_qlock);\n\t\t\tmutex_lock_nested(&d1->q_qlock, XFS_QLOCK_NESTED);\n\t\t} else {\n\t\t\tmutex_lock(&d1->q_qlock);\n\t\t\tmutex_lock_nested(&d2->q_qlock, XFS_QLOCK_NESTED);\n\t\t}\n\t} else if (d1) {\n\t\tmutex_lock(&d1->q_qlock);\n\t} else if (d2) {\n\t\tmutex_lock(&d2->q_qlock);\n\t}\n}\n\nint __init\nxfs_qm_init(void)\n{\n\txfs_dquot_cache = kmem_cache_create(\"xfs_dquot\",\n\t\t\t\t\t  sizeof(struct xfs_dquot),\n\t\t\t\t\t  0, 0, NULL);\n\tif (!xfs_dquot_cache)\n\t\tgoto out;\n\n\txfs_dqtrx_cache = kmem_cache_create(\"xfs_dqtrx\",\n\t\t\t\t\t     sizeof(struct xfs_dquot_acct),\n\t\t\t\t\t     0, 0, NULL);\n\tif (!xfs_dqtrx_cache)\n\t\tgoto out_free_dquot_cache;\n\n\treturn 0;\n\nout_free_dquot_cache:\n\tkmem_cache_destroy(xfs_dquot_cache);\nout:\n\treturn -ENOMEM;\n}\n\nvoid\nxfs_qm_exit(void)\n{\n\tkmem_cache_destroy(xfs_dqtrx_cache);\n\tkmem_cache_destroy(xfs_dquot_cache);\n}\n\n \nint\nxfs_qm_dqiterate(\n\tstruct xfs_mount\t*mp,\n\txfs_dqtype_t\t\ttype,\n\txfs_qm_dqiterate_fn\titer_fn,\n\tvoid\t\t\t*priv)\n{\n\tstruct xfs_dquot\t*dq;\n\txfs_dqid_t\t\tid = 0;\n\tint\t\t\terror;\n\n\tdo {\n\t\terror = xfs_qm_dqget_next(mp, id, type, &dq);\n\t\tif (error == -ENOENT)\n\t\t\treturn 0;\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = iter_fn(dq, type, priv);\n\t\tid = dq->q_id + 1;\n\t\txfs_qm_dqput(dq);\n\t} while (error == 0 && id != 0);\n\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}