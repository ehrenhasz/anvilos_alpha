{
  "module_name": "xfs_ioctl32.c",
  "hash_id": "0e59381674d19a95a477e40dc1e88fbd5684524cf8f5f48d6fbad9a26bf6c577",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_ioctl32.c",
  "human_readable_source": "\n \n#include <linux/mount.h>\n#include <linux/fsmap.h>\n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_iwalk.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_sb.h\"\n\n#define  _NATIVE_IOC(cmd, type) \\\n\t  _IOC(_IOC_DIR(cmd), _IOC_TYPE(cmd), _IOC_NR(cmd), sizeof(type))\n\n#ifdef BROKEN_X86_ALIGNMENT\nSTATIC int\nxfs_compat_ioc_fsgeometry_v1(\n\tstruct xfs_mount\t  *mp,\n\tcompat_xfs_fsop_geom_v1_t __user *arg32)\n{\n\tstruct xfs_fsop_geom\t  fsgeo;\n\n\txfs_fs_geometry(mp, &fsgeo, 3);\n\t \n\tif (copy_to_user(arg32, &fsgeo, sizeof(struct compat_xfs_fsop_geom_v1)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nSTATIC int\nxfs_compat_growfs_data_copyin(\n\tstruct xfs_growfs_data\t *in,\n\tcompat_xfs_growfs_data_t __user *arg32)\n{\n\tif (get_user(in->newblocks, &arg32->newblocks) ||\n\t    get_user(in->imaxpct,   &arg32->imaxpct))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nSTATIC int\nxfs_compat_growfs_rt_copyin(\n\tstruct xfs_growfs_rt\t *in,\n\tcompat_xfs_growfs_rt_t\t__user *arg32)\n{\n\tif (get_user(in->newblocks, &arg32->newblocks) ||\n\t    get_user(in->extsize,   &arg32->extsize))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nSTATIC int\nxfs_fsinumbers_fmt_compat(\n\tstruct xfs_ibulk\t\t*breq,\n\tconst struct xfs_inumbers\t*ig)\n{\n\tstruct compat_xfs_inogrp __user\t*p32 = breq->ubuffer;\n\tstruct xfs_inogrp\t\tig1;\n\tstruct xfs_inogrp\t\t*igrp = &ig1;\n\n\txfs_inumbers_to_inogrp(&ig1, ig);\n\n\tif (put_user(igrp->xi_startino,   &p32->xi_startino) ||\n\t    put_user(igrp->xi_alloccount, &p32->xi_alloccount) ||\n\t    put_user(igrp->xi_allocmask,  &p32->xi_allocmask))\n\t\treturn -EFAULT;\n\n\treturn xfs_ibulk_advance(breq, sizeof(struct compat_xfs_inogrp));\n}\n\n#else\n#define xfs_fsinumbers_fmt_compat xfs_fsinumbers_fmt\n#endif\t \n\nSTATIC int\nxfs_ioctl32_bstime_copyin(\n\txfs_bstime_t\t\t*bstime,\n\tcompat_xfs_bstime_t\t__user *bstime32)\n{\n\told_time32_t\t\tsec32;\t \n\n\tif (get_user(sec32,\t\t&bstime32->tv_sec)\t||\n\t    get_user(bstime->tv_nsec,\t&bstime32->tv_nsec))\n\t\treturn -EFAULT;\n\tbstime->tv_sec = sec32;\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_ioctl32_bstat_copyin(\n\tstruct xfs_bstat\t\t*bstat,\n\tstruct compat_xfs_bstat\t__user\t*bstat32)\n{\n\tif (get_user(bstat->bs_ino,\t&bstat32->bs_ino)\t||\n\t    get_user(bstat->bs_mode,\t&bstat32->bs_mode)\t||\n\t    get_user(bstat->bs_nlink,\t&bstat32->bs_nlink)\t||\n\t    get_user(bstat->bs_uid,\t&bstat32->bs_uid)\t||\n\t    get_user(bstat->bs_gid,\t&bstat32->bs_gid)\t||\n\t    get_user(bstat->bs_rdev,\t&bstat32->bs_rdev)\t||\n\t    get_user(bstat->bs_blksize,\t&bstat32->bs_blksize)\t||\n\t    get_user(bstat->bs_size,\t&bstat32->bs_size)\t||\n\t    xfs_ioctl32_bstime_copyin(&bstat->bs_atime, &bstat32->bs_atime) ||\n\t    xfs_ioctl32_bstime_copyin(&bstat->bs_mtime, &bstat32->bs_mtime) ||\n\t    xfs_ioctl32_bstime_copyin(&bstat->bs_ctime, &bstat32->bs_ctime) ||\n\t    get_user(bstat->bs_blocks,\t&bstat32->bs_size)\t||\n\t    get_user(bstat->bs_xflags,\t&bstat32->bs_size)\t||\n\t    get_user(bstat->bs_extsize,\t&bstat32->bs_extsize)\t||\n\t    get_user(bstat->bs_extents,\t&bstat32->bs_extents)\t||\n\t    get_user(bstat->bs_gen,\t&bstat32->bs_gen)\t||\n\t    get_user(bstat->bs_projid_lo, &bstat32->bs_projid_lo) ||\n\t    get_user(bstat->bs_projid_hi, &bstat32->bs_projid_hi) ||\n\t    get_user(bstat->bs_forkoff,\t&bstat32->bs_forkoff)\t||\n\t    get_user(bstat->bs_dmevmask, &bstat32->bs_dmevmask)\t||\n\t    get_user(bstat->bs_dmstate,\t&bstat32->bs_dmstate)\t||\n\t    get_user(bstat->bs_aextents, &bstat32->bs_aextents))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \n\nSTATIC int\nxfs_bstime_store_compat(\n\tcompat_xfs_bstime_t\t__user *p32,\n\tconst xfs_bstime_t\t*p)\n{\n\t__s32\t\t\tsec32;\n\n\tsec32 = p->tv_sec;\n\tif (put_user(sec32, &p32->tv_sec) ||\n\t    put_user(p->tv_nsec, &p32->tv_nsec))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_fsbulkstat_one_fmt_compat(\n\tstruct xfs_ibulk\t\t*breq,\n\tconst struct xfs_bulkstat\t*bstat)\n{\n\tstruct compat_xfs_bstat\t__user\t*p32 = breq->ubuffer;\n\tstruct xfs_bstat\t\tbs1;\n\tstruct xfs_bstat\t\t*buffer = &bs1;\n\n\txfs_bulkstat_to_bstat(breq->mp, &bs1, bstat);\n\n\tif (put_user(buffer->bs_ino,\t  &p32->bs_ino)\t\t||\n\t    put_user(buffer->bs_mode,\t  &p32->bs_mode)\t||\n\t    put_user(buffer->bs_nlink,\t  &p32->bs_nlink)\t||\n\t    put_user(buffer->bs_uid,\t  &p32->bs_uid)\t\t||\n\t    put_user(buffer->bs_gid,\t  &p32->bs_gid)\t\t||\n\t    put_user(buffer->bs_rdev,\t  &p32->bs_rdev)\t||\n\t    put_user(buffer->bs_blksize,  &p32->bs_blksize)\t||\n\t    put_user(buffer->bs_size,\t  &p32->bs_size)\t||\n\t    xfs_bstime_store_compat(&p32->bs_atime, &buffer->bs_atime) ||\n\t    xfs_bstime_store_compat(&p32->bs_mtime, &buffer->bs_mtime) ||\n\t    xfs_bstime_store_compat(&p32->bs_ctime, &buffer->bs_ctime) ||\n\t    put_user(buffer->bs_blocks,\t  &p32->bs_blocks)\t||\n\t    put_user(buffer->bs_xflags,\t  &p32->bs_xflags)\t||\n\t    put_user(buffer->bs_extsize,  &p32->bs_extsize)\t||\n\t    put_user(buffer->bs_extents,  &p32->bs_extents)\t||\n\t    put_user(buffer->bs_gen,\t  &p32->bs_gen)\t\t||\n\t    put_user(buffer->bs_projid,\t  &p32->bs_projid)\t||\n\t    put_user(buffer->bs_projid_hi,\t&p32->bs_projid_hi)\t||\n\t    put_user(buffer->bs_forkoff,  &p32->bs_forkoff)\t||\n\t    put_user(buffer->bs_dmevmask, &p32->bs_dmevmask)\t||\n\t    put_user(buffer->bs_dmstate,  &p32->bs_dmstate)\t||\n\t    put_user(buffer->bs_aextents, &p32->bs_aextents))\n\t\treturn -EFAULT;\n\n\treturn xfs_ibulk_advance(breq, sizeof(struct compat_xfs_bstat));\n}\n\n \nSTATIC int\nxfs_compat_ioc_fsbulkstat(\n\tstruct file\t\t*file,\n\tunsigned int\t\t  cmd,\n\tstruct compat_xfs_fsop_bulkreq __user *p32)\n{\n\tstruct xfs_mount\t*mp = XFS_I(file_inode(file))->i_mount;\n\tu32\t\t\taddr;\n\tstruct xfs_fsop_bulkreq\tbulkreq;\n\tstruct xfs_ibulk\tbreq = {\n\t\t.mp\t\t= mp,\n\t\t.idmap\t\t= file_mnt_idmap(file),\n\t\t.ocount\t\t= 0,\n\t};\n\txfs_ino_t\t\tlastino;\n\tint\t\t\terror;\n\n\t \n\tinumbers_fmt_pf\t\tinumbers_func = xfs_fsinumbers_fmt_compat;\n\tbulkstat_one_fmt_pf\tbs_one_func = xfs_fsbulkstat_one_fmt_compat;\n\n#ifdef CONFIG_X86_X32_ABI\n\tif (in_x32_syscall()) {\n\t\t \n\t\tinumbers_func = xfs_fsinumbers_fmt;\n\t\tbs_one_func = xfs_fsbulkstat_one_fmt;\n\t}\n#endif\n\n\t \n\t \n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\tif (get_user(addr, &p32->lastip))\n\t\treturn -EFAULT;\n\tbulkreq.lastip = compat_ptr(addr);\n\tif (get_user(bulkreq.icount, &p32->icount) ||\n\t    get_user(addr, &p32->ubuffer))\n\t\treturn -EFAULT;\n\tbulkreq.ubuffer = compat_ptr(addr);\n\tif (get_user(addr, &p32->ocount))\n\t\treturn -EFAULT;\n\tbulkreq.ocount = compat_ptr(addr);\n\n\tif (copy_from_user(&lastino, bulkreq.lastip, sizeof(__s64)))\n\t\treturn -EFAULT;\n\n\tif (bulkreq.icount <= 0)\n\t\treturn -EINVAL;\n\n\tif (bulkreq.ubuffer == NULL)\n\t\treturn -EINVAL;\n\n\tbreq.ubuffer = bulkreq.ubuffer;\n\tbreq.icount = bulkreq.icount;\n\n\t \n\tif (cmd == XFS_IOC_FSINUMBERS_32) {\n\t\tbreq.startino = lastino ? lastino + 1 : 0;\n\t\terror = xfs_inumbers(&breq, inumbers_func);\n\t\tlastino = breq.startino - 1;\n\t} else if (cmd == XFS_IOC_FSBULKSTAT_SINGLE_32) {\n\t\tbreq.startino = lastino;\n\t\tbreq.icount = 1;\n\t\terror = xfs_bulkstat_one(&breq, bs_one_func);\n\t\tlastino = breq.startino;\n\t} else if (cmd == XFS_IOC_FSBULKSTAT_32) {\n\t\tbreq.startino = lastino ? lastino + 1 : 0;\n\t\terror = xfs_bulkstat(&breq, bs_one_func);\n\t\tlastino = breq.startino - 1;\n\t} else {\n\t\terror = -EINVAL;\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (bulkreq.lastip != NULL &&\n\t    copy_to_user(bulkreq.lastip, &lastino, sizeof(xfs_ino_t)))\n\t\treturn -EFAULT;\n\n\tif (bulkreq.ocount != NULL &&\n\t    copy_to_user(bulkreq.ocount, &breq.ocount, sizeof(__s32)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nSTATIC int\nxfs_compat_handlereq_copyin(\n\txfs_fsop_handlereq_t\t\t*hreq,\n\tcompat_xfs_fsop_handlereq_t\t__user *arg32)\n{\n\tcompat_xfs_fsop_handlereq_t\threq32;\n\n\tif (copy_from_user(&hreq32, arg32, sizeof(compat_xfs_fsop_handlereq_t)))\n\t\treturn -EFAULT;\n\n\threq->fd = hreq32.fd;\n\threq->path = compat_ptr(hreq32.path);\n\threq->oflags = hreq32.oflags;\n\threq->ihandle = compat_ptr(hreq32.ihandle);\n\threq->ihandlen = hreq32.ihandlen;\n\threq->ohandle = compat_ptr(hreq32.ohandle);\n\threq->ohandlen = compat_ptr(hreq32.ohandlen);\n\n\treturn 0;\n}\n\nSTATIC struct dentry *\nxfs_compat_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\tcompat_xfs_fsop_handlereq_t *hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp,\n\t\t\tcompat_ptr(hreq->ihandle), hreq->ihandlen);\n}\n\nSTATIC int\nxfs_compat_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tcompat_xfs_fsop_attrlist_handlereq_t __user *p)\n{\n\tcompat_xfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tint\t\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&al_hreq, p, sizeof(al_hreq)))\n\t\treturn -EFAULT;\n\n\tdentry = xfs_compat_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = xfs_ioc_attr_list(XFS_I(d_inode(dentry)),\n\t\t\tcompat_ptr(al_hreq.buffer), al_hreq.buflen,\n\t\t\tal_hreq.flags, &p->pos);\n\tdput(dentry);\n\treturn error;\n}\n\nSTATIC int\nxfs_compat_attrmulti_by_handle(\n\tstruct file\t\t\t\t*parfilp,\n\tvoid\t\t\t\t\t__user *arg)\n{\n\tint\t\t\t\t\terror;\n\tcompat_xfs_attr_multiop_t\t\t*ops;\n\tcompat_xfs_fsop_attrmulti_handlereq_t\tam_hreq;\n\tstruct dentry\t\t\t\t*dentry;\n\tunsigned int\t\t\t\ti, size;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&am_hreq, arg,\n\t\t\t   sizeof(compat_xfs_fsop_attrmulti_handlereq_t)))\n\t\treturn -EFAULT;\n\n\t \n\tif (am_hreq.opcount >= INT_MAX / sizeof(compat_xfs_attr_multiop_t))\n\t\treturn -E2BIG;\n\n\tdentry = xfs_compat_handlereq_to_dentry(parfilp, &am_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = -E2BIG;\n\tsize = am_hreq.opcount * sizeof(compat_xfs_attr_multiop_t);\n\tif (!size || size > 16 * PAGE_SIZE)\n\t\tgoto out_dput;\n\n\tops = memdup_user(compat_ptr(am_hreq.ops), size);\n\tif (IS_ERR(ops)) {\n\t\terror = PTR_ERR(ops);\n\t\tgoto out_dput;\n\t}\n\n\terror = 0;\n\tfor (i = 0; i < am_hreq.opcount; i++) {\n\t\tops[i].am_error = xfs_ioc_attrmulti_one(parfilp,\n\t\t\t\td_inode(dentry), ops[i].am_opcode,\n\t\t\t\tcompat_ptr(ops[i].am_attrname),\n\t\t\t\tcompat_ptr(ops[i].am_attrvalue),\n\t\t\t\t&ops[i].am_length, ops[i].am_flags);\n\t}\n\n\tif (copy_to_user(compat_ptr(am_hreq.ops), ops, size))\n\t\terror = -EFAULT;\n\n\tkfree(ops);\n out_dput:\n\tdput(dentry);\n\treturn error;\n}\n\nlong\nxfs_file_compat_ioctl(\n\tstruct file\t\t*filp,\n\tunsigned\t\tcmd,\n\tunsigned long\t\tp)\n{\n\tstruct inode\t\t*inode = file_inode(filp);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tvoid\t\t\t__user *arg = compat_ptr(p);\n\tint\t\t\terror;\n\n\ttrace_xfs_file_compat_ioctl(ip);\n\n\tswitch (cmd) {\n#if defined(BROKEN_X86_ALIGNMENT)\n\tcase XFS_IOC_FSGEOMETRY_V1_32:\n\t\treturn xfs_compat_ioc_fsgeometry_v1(ip->i_mount, arg);\n\tcase XFS_IOC_FSGROWFSDATA_32: {\n\t\tstruct xfs_growfs_data\tin;\n\n\t\tif (xfs_compat_growfs_data_copyin(&in, arg))\n\t\t\treturn -EFAULT;\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_data(ip->i_mount, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\tcase XFS_IOC_FSGROWFSRT_32: {\n\t\tstruct xfs_growfs_rt\tin;\n\n\t\tif (xfs_compat_growfs_rt_copyin(&in, arg))\n\t\t\treturn -EFAULT;\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_rt(ip->i_mount, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n#endif\n\t \n\tcase XFS_IOC_GETVERSION_32:\n\t\tcmd = _NATIVE_IOC(cmd, long);\n\t\treturn xfs_file_ioctl(filp, cmd, p);\n\tcase XFS_IOC_SWAPEXT_32: {\n\t\tstruct xfs_swapext\t  sxp;\n\t\tstruct compat_xfs_swapext __user *sxu = arg;\n\n\t\t \n\t\tif (copy_from_user(&sxp, sxu,\n\t\t\t\t   offsetof(struct xfs_swapext, sx_stat)) ||\n\t\t    xfs_ioctl32_bstat_copyin(&sxp.sx_stat, &sxu->sx_stat))\n\t\t\treturn -EFAULT;\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_ioc_swapext(&sxp);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\tcase XFS_IOC_FSBULKSTAT_32:\n\tcase XFS_IOC_FSBULKSTAT_SINGLE_32:\n\tcase XFS_IOC_FSINUMBERS_32:\n\t\treturn xfs_compat_ioc_fsbulkstat(filp, cmd, arg);\n\tcase XFS_IOC_FD_TO_HANDLE_32:\n\tcase XFS_IOC_PATH_TO_HANDLE_32:\n\tcase XFS_IOC_PATH_TO_FSHANDLE_32: {\n\t\tstruct xfs_fsop_handlereq\threq;\n\n\t\tif (xfs_compat_handlereq_copyin(&hreq, arg))\n\t\t\treturn -EFAULT;\n\t\tcmd = _NATIVE_IOC(cmd, struct xfs_fsop_handlereq);\n\t\treturn xfs_find_handle(cmd, &hreq);\n\t}\n\tcase XFS_IOC_OPEN_BY_HANDLE_32: {\n\t\tstruct xfs_fsop_handlereq\threq;\n\n\t\tif (xfs_compat_handlereq_copyin(&hreq, arg))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_open_by_handle(filp, &hreq);\n\t}\n\tcase XFS_IOC_READLINK_BY_HANDLE_32: {\n\t\tstruct xfs_fsop_handlereq\threq;\n\n\t\tif (xfs_compat_handlereq_copyin(&hreq, arg))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_readlink_by_handle(filp, &hreq);\n\t}\n\tcase XFS_IOC_ATTRLIST_BY_HANDLE_32:\n\t\treturn xfs_compat_attrlist_by_handle(filp, arg);\n\tcase XFS_IOC_ATTRMULTI_BY_HANDLE_32:\n\t\treturn xfs_compat_attrmulti_by_handle(filp, arg);\n\tdefault:\n\t\t \n\t\treturn xfs_file_ioctl(filp, cmd, (unsigned long)arg);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}