{
  "module_name": "xfs_mru_cache.c",
  "hash_id": "cc40264205207b052b7ed04d3e3afbda2ce448c30c5e3f598615fa5a9e69c672",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_mru_cache.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_mru_cache.h\"\n\n \n\n \nstruct xfs_mru_cache {\n\tstruct radix_tree_root\tstore;      \n\tstruct list_head\t*lists;     \n\tstruct list_head\treap_list;  \n\tspinlock_t\t\tlock;       \n\tunsigned int\t\tgrp_count;  \n\tunsigned int\t\tgrp_time;   \n\tunsigned int\t\tlru_grp;    \n\tunsigned long\t\ttime_zero;  \n\txfs_mru_cache_free_func_t free_func;  \n\tstruct delayed_work\twork;       \n\tunsigned int\t\tqueued;\t    \n\tvoid\t\t\t*data;\n};\n\nstatic struct workqueue_struct\t*xfs_mru_reap_wq;\n\n \nSTATIC unsigned long\n_xfs_mru_cache_migrate(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tnow)\n{\n\tunsigned int\t\tgrp;\n\tunsigned int\t\tmigrated = 0;\n\tstruct list_head\t*lru_list;\n\n\t \n\tif (!mru->time_zero)\n\t\treturn 0;\n\n\t \n\twhile (mru->time_zero <= now - mru->grp_count * mru->grp_time) {\n\n\t\t \n\t\tlru_list = mru->lists + mru->lru_grp;\n\t\tif (!list_empty(lru_list))\n\t\t\tlist_splice_init(lru_list, mru->reap_list.prev);\n\n\t\t \n\t\tmru->lru_grp = (mru->lru_grp + 1) % mru->grp_count;\n\t\tmru->time_zero += mru->grp_time;\n\n\t\t \n\t\tif (++migrated == mru->grp_count) {\n\t\t\tmru->lru_grp = 0;\n\t\t\tmru->time_zero = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tfor (grp = 0; grp < mru->grp_count; grp++) {\n\n\t\t \n\t\tlru_list = mru->lists + ((mru->lru_grp + grp) % mru->grp_count);\n\t\tif (!list_empty(lru_list))\n\t\t\treturn mru->time_zero +\n\t\t\t       (mru->grp_count + grp) * mru->grp_time;\n\t}\n\n\t \n\tmru->lru_grp = 0;\n\tmru->time_zero = 0;\n\treturn 0;\n}\n\n \nSTATIC void\n_xfs_mru_cache_list_insert(\n\tstruct xfs_mru_cache\t*mru,\n\tstruct xfs_mru_cache_elem *elem)\n{\n\tunsigned int\t\tgrp = 0;\n\tunsigned long\t\tnow = jiffies;\n\n\t \n\tif (!_xfs_mru_cache_migrate(mru, now)) {\n\t\tmru->time_zero = now;\n\t\tif (!mru->queued) {\n\t\t\tmru->queued = 1;\n\t\t\tqueue_delayed_work(xfs_mru_reap_wq, &mru->work,\n\t\t\t                   mru->grp_count * mru->grp_time);\n\t\t}\n\t} else {\n\t\tgrp = (now - mru->time_zero) / mru->grp_time;\n\t\tgrp = (mru->lru_grp + grp) % mru->grp_count;\n\t}\n\n\t \n\tlist_add_tail(&elem->list_node, mru->lists + grp);\n}\n\n \nSTATIC void\n_xfs_mru_cache_clear_reap_list(\n\tstruct xfs_mru_cache\t*mru)\n\t\t__releases(mru->lock) __acquires(mru->lock)\n{\n\tstruct xfs_mru_cache_elem *elem, *next;\n\tstruct list_head\ttmp;\n\n\tINIT_LIST_HEAD(&tmp);\n\tlist_for_each_entry_safe(elem, next, &mru->reap_list, list_node) {\n\n\t\t \n\t\tradix_tree_delete(&mru->store, elem->key);\n\n\t\t \n\t\tlist_move(&elem->list_node, &tmp);\n\t}\n\tspin_unlock(&mru->lock);\n\n\tlist_for_each_entry_safe(elem, next, &tmp, list_node) {\n\t\tlist_del_init(&elem->list_node);\n\t\tmru->free_func(mru->data, elem);\n\t}\n\n\tspin_lock(&mru->lock);\n}\n\n \nSTATIC void\n_xfs_mru_cache_reap(\n\tstruct work_struct\t*work)\n{\n\tstruct xfs_mru_cache\t*mru =\n\t\tcontainer_of(work, struct xfs_mru_cache, work.work);\n\tunsigned long\t\tnow, next;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn;\n\n\tspin_lock(&mru->lock);\n\tnext = _xfs_mru_cache_migrate(mru, jiffies);\n\t_xfs_mru_cache_clear_reap_list(mru);\n\n\tmru->queued = next;\n\tif ((mru->queued > 0)) {\n\t\tnow = jiffies;\n\t\tif (next <= now)\n\t\t\tnext = 0;\n\t\telse\n\t\t\tnext -= now;\n\t\tqueue_delayed_work(xfs_mru_reap_wq, &mru->work, next);\n\t}\n\n\tspin_unlock(&mru->lock);\n}\n\nint\nxfs_mru_cache_init(void)\n{\n\txfs_mru_reap_wq = alloc_workqueue(\"xfs_mru_cache\",\n\t\t\tXFS_WQFLAGS(WQ_MEM_RECLAIM | WQ_FREEZABLE), 1);\n\tif (!xfs_mru_reap_wq)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid\nxfs_mru_cache_uninit(void)\n{\n\tdestroy_workqueue(xfs_mru_reap_wq);\n}\n\n \nint\nxfs_mru_cache_create(\n\tstruct xfs_mru_cache\t**mrup,\n\tvoid\t\t\t*data,\n\tunsigned int\t\tlifetime_ms,\n\tunsigned int\t\tgrp_count,\n\txfs_mru_cache_free_func_t free_func)\n{\n\tstruct xfs_mru_cache\t*mru = NULL;\n\tint\t\t\terr = 0, grp;\n\tunsigned int\t\tgrp_time;\n\n\tif (mrup)\n\t\t*mrup = NULL;\n\n\tif (!mrup || !grp_count || !lifetime_ms || !free_func)\n\t\treturn -EINVAL;\n\n\tif (!(grp_time = msecs_to_jiffies(lifetime_ms) / grp_count))\n\t\treturn -EINVAL;\n\n\tif (!(mru = kmem_zalloc(sizeof(*mru), 0)))\n\t\treturn -ENOMEM;\n\n\t \n\tmru->grp_count = grp_count + 1;\n\tmru->lists = kmem_zalloc(mru->grp_count * sizeof(*mru->lists), 0);\n\n\tif (!mru->lists) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tfor (grp = 0; grp < mru->grp_count; grp++)\n\t\tINIT_LIST_HEAD(mru->lists + grp);\n\n\t \n\tINIT_RADIX_TREE(&mru->store, GFP_ATOMIC);\n\tINIT_LIST_HEAD(&mru->reap_list);\n\tspin_lock_init(&mru->lock);\n\tINIT_DELAYED_WORK(&mru->work, _xfs_mru_cache_reap);\n\n\tmru->grp_time  = grp_time;\n\tmru->free_func = free_func;\n\tmru->data = data;\n\t*mrup = mru;\n\nexit:\n\tif (err && mru && mru->lists)\n\t\tkmem_free(mru->lists);\n\tif (err && mru)\n\t\tkmem_free(mru);\n\n\treturn err;\n}\n\n \nstatic void\nxfs_mru_cache_flush(\n\tstruct xfs_mru_cache\t*mru)\n{\n\tif (!mru || !mru->lists)\n\t\treturn;\n\n\tspin_lock(&mru->lock);\n\tif (mru->queued) {\n\t\tspin_unlock(&mru->lock);\n\t\tcancel_delayed_work_sync(&mru->work);\n\t\tspin_lock(&mru->lock);\n\t}\n\n\t_xfs_mru_cache_migrate(mru, jiffies + mru->grp_count * mru->grp_time);\n\t_xfs_mru_cache_clear_reap_list(mru);\n\n\tspin_unlock(&mru->lock);\n}\n\nvoid\nxfs_mru_cache_destroy(\n\tstruct xfs_mru_cache\t*mru)\n{\n\tif (!mru || !mru->lists)\n\t\treturn;\n\n\txfs_mru_cache_flush(mru);\n\n\tkmem_free(mru->lists);\n\tkmem_free(mru);\n}\n\n \nint\nxfs_mru_cache_insert(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey,\n\tstruct xfs_mru_cache_elem *elem)\n{\n\tint\t\t\terror;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn -EINVAL;\n\n\tif (radix_tree_preload(GFP_NOFS))\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&elem->list_node);\n\telem->key = key;\n\n\tspin_lock(&mru->lock);\n\terror = radix_tree_insert(&mru->store, key, elem);\n\tradix_tree_preload_end();\n\tif (!error)\n\t\t_xfs_mru_cache_list_insert(mru, elem);\n\tspin_unlock(&mru->lock);\n\n\treturn error;\n}\n\n \nstruct xfs_mru_cache_elem *\nxfs_mru_cache_remove(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey)\n{\n\tstruct xfs_mru_cache_elem *elem;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn NULL;\n\n\tspin_lock(&mru->lock);\n\telem = radix_tree_delete(&mru->store, key);\n\tif (elem)\n\t\tlist_del(&elem->list_node);\n\tspin_unlock(&mru->lock);\n\n\treturn elem;\n}\n\n \nvoid\nxfs_mru_cache_delete(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey)\n{\n\tstruct xfs_mru_cache_elem *elem;\n\n\telem = xfs_mru_cache_remove(mru, key);\n\tif (elem)\n\t\tmru->free_func(mru->data, elem);\n}\n\n \nstruct xfs_mru_cache_elem *\nxfs_mru_cache_lookup(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey)\n{\n\tstruct xfs_mru_cache_elem *elem;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn NULL;\n\n\tspin_lock(&mru->lock);\n\telem = radix_tree_lookup(&mru->store, key);\n\tif (elem) {\n\t\tlist_del(&elem->list_node);\n\t\t_xfs_mru_cache_list_insert(mru, elem);\n\t\t__release(mru_lock);  \n\t} else\n\t\tspin_unlock(&mru->lock);\n\n\treturn elem;\n}\n\n \nvoid\nxfs_mru_cache_done(\n\tstruct xfs_mru_cache\t*mru)\n\t\t__releases(mru->lock)\n{\n\tspin_unlock(&mru->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}