{
  "module_name": "xfs_log_recover.c",
  "hash_id": "688ce3f6e5c60a9b0dcc6525000f427a8d378366d13af14d5c740c8c85d8bdcb",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_log_recover.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_log.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_reflink.h\"\n\n#define BLK_AVG(blk1, blk2)\t((blk1+blk2) >> 1)\n\nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*,\n\txfs_daddr_t\t*);\nSTATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*,\n\txfs_lsn_t);\nSTATIC int\nxlog_do_recovery_pass(\n        struct xlog *, xfs_daddr_t, xfs_daddr_t, int, xfs_daddr_t *);\n\n \n\n \nstatic inline bool\nxlog_verify_bno(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tbbcount)\n{\n\tif (blk_no < 0 || blk_no >= log->l_logBBsize)\n\t\treturn false;\n\tif (bbcount <= 0 || (blk_no + bbcount) > log->l_logBBsize)\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic char *\nxlog_alloc_buffer(\n\tstruct xlog\t*log,\n\tint\t\tnbblks)\n{\n\t \n\tif (XFS_IS_CORRUPT(log->l_mp, !xlog_verify_bno(log, 0, nbblks))) {\n\t\txfs_warn(log->l_mp, \"Invalid block length (0x%x) for buffer\",\n\t\t\tnbblks);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (nbblks > 1 && log->l_sectBBsize > 1)\n\t\tnbblks += log->l_sectBBsize;\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\treturn kvzalloc(BBTOB(nbblks), GFP_KERNEL | __GFP_RETRY_MAYFAIL);\n}\n\n \nstatic inline unsigned int\nxlog_align(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no)\n{\n\treturn BBTOB(blk_no & ((xfs_daddr_t)log->l_sectBBsize - 1));\n}\n\nstatic int\nxlog_do_io(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblk_no,\n\tunsigned int\t\tnbblks,\n\tchar\t\t\t*data,\n\tenum req_op\t\top)\n{\n\tint\t\t\terror;\n\n\tif (XFS_IS_CORRUPT(log->l_mp, !xlog_verify_bno(log, blk_no, nbblks))) {\n\t\txfs_warn(log->l_mp,\n\t\t\t \"Invalid log block/length (0x%llx, 0x%x) for buffer\",\n\t\t\t blk_no, nbblks);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tblk_no = round_down(blk_no, log->l_sectBBsize);\n\tnbblks = round_up(nbblks, log->l_sectBBsize);\n\tASSERT(nbblks > 0);\n\n\terror = xfs_rw_bdev(log->l_targ->bt_bdev, log->l_logBBstart + blk_no,\n\t\t\tBBTOB(nbblks), data, op);\n\tif (error && !xlog_is_shutdown(log)) {\n\t\txfs_alert(log->l_mp,\n\t\t\t  \"log recovery %s I/O error at daddr 0x%llx len %d error %d\",\n\t\t\t  op == REQ_OP_WRITE ? \"write\" : \"read\",\n\t\t\t  blk_no, nbblks, error);\n\t}\n\treturn error;\n}\n\nSTATIC int\nxlog_bread_noalign(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tchar\t\t*data)\n{\n\treturn xlog_do_io(log, blk_no, nbblks, data, REQ_OP_READ);\n}\n\nSTATIC int\nxlog_bread(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tchar\t\t*data,\n\tchar\t\t**offset)\n{\n\tint\t\terror;\n\n\terror = xlog_do_io(log, blk_no, nbblks, data, REQ_OP_READ);\n\tif (!error)\n\t\t*offset = data + xlog_align(log, blk_no);\n\treturn error;\n}\n\nSTATIC int\nxlog_bwrite(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tblk_no,\n\tint\t\tnbblks,\n\tchar\t\t*data)\n{\n\treturn xlog_do_io(log, blk_no, nbblks, data, REQ_OP_WRITE);\n}\n\n#ifdef DEBUG\n \nSTATIC void\nxlog_header_check_dump(\n\txfs_mount_t\t\t*mp,\n\txlog_rec_header_t\t*head)\n{\n\txfs_debug(mp, \"%s:  SB : uuid = %pU, fmt = %d\",\n\t\t__func__, &mp->m_sb.sb_uuid, XLOG_FMT);\n\txfs_debug(mp, \"    log : uuid = %pU, fmt = %d\",\n\t\t&head->h_fs_uuid, be32_to_cpu(head->h_fmt));\n}\n#else\n#define xlog_header_check_dump(mp, head)\n#endif\n\n \nSTATIC int\nxlog_header_check_recover(\n\txfs_mount_t\t\t*mp,\n\txlog_rec_header_t\t*head)\n{\n\tASSERT(head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM));\n\n\t \n\tif (XFS_IS_CORRUPT(mp, head->h_fmt != cpu_to_be32(XLOG_FMT))) {\n\t\txfs_warn(mp,\n\t\"dirty log written in incompatible format - can't recover\");\n\t\txlog_header_check_dump(mp, head);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (XFS_IS_CORRUPT(mp, !uuid_equal(&mp->m_sb.sb_uuid,\n\t\t\t\t\t   &head->h_fs_uuid))) {\n\t\txfs_warn(mp,\n\t\"dirty log entry has mismatched uuid - can't recover\");\n\t\txlog_header_check_dump(mp, head);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}\n\n \nSTATIC int\nxlog_header_check_mount(\n\txfs_mount_t\t\t*mp,\n\txlog_rec_header_t\t*head)\n{\n\tASSERT(head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM));\n\n\tif (uuid_is_null(&head->h_fs_uuid)) {\n\t\t \n\t\txfs_warn(mp, \"null uuid in log - IRIX style log\");\n\t} else if (XFS_IS_CORRUPT(mp, !uuid_equal(&mp->m_sb.sb_uuid,\n\t\t\t\t\t\t  &head->h_fs_uuid))) {\n\t\txfs_warn(mp, \"log has mismatched uuid - can't recover\");\n\t\txlog_header_check_dump(mp, head);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}\n\n \nSTATIC int\nxlog_find_cycle_start(\n\tstruct xlog\t*log,\n\tchar\t\t*buffer,\n\txfs_daddr_t\tfirst_blk,\n\txfs_daddr_t\t*last_blk,\n\tuint\t\tcycle)\n{\n\tchar\t\t*offset;\n\txfs_daddr_t\tmid_blk;\n\txfs_daddr_t\tend_blk;\n\tuint\t\tmid_cycle;\n\tint\t\terror;\n\n\tend_blk = *last_blk;\n\tmid_blk = BLK_AVG(first_blk, end_blk);\n\twhile (mid_blk != first_blk && mid_blk != end_blk) {\n\t\terror = xlog_bread(log, mid_blk, 1, buffer, &offset);\n\t\tif (error)\n\t\t\treturn error;\n\t\tmid_cycle = xlog_get_cycle(offset);\n\t\tif (mid_cycle == cycle)\n\t\t\tend_blk = mid_blk;    \n\t\telse\n\t\t\tfirst_blk = mid_blk;  \n\t\tmid_blk = BLK_AVG(first_blk, end_blk);\n\t}\n\tASSERT((mid_blk == first_blk && mid_blk+1 == end_blk) ||\n\t       (mid_blk == end_blk && mid_blk-1 == first_blk));\n\n\t*last_blk = end_blk;\n\n\treturn 0;\n}\n\n \nSTATIC int\nxlog_find_verify_cycle(\n\tstruct xlog\t*log,\n\txfs_daddr_t\tstart_blk,\n\tint\t\tnbblks,\n\tuint\t\tstop_on_cycle_no,\n\txfs_daddr_t\t*new_blk)\n{\n\txfs_daddr_t\ti, j;\n\tuint\t\tcycle;\n\tchar\t\t*buffer;\n\txfs_daddr_t\tbufblks;\n\tchar\t\t*buf = NULL;\n\tint\t\terror = 0;\n\n\t \n\tbufblks = roundup_pow_of_two(nbblks);\n\twhile (bufblks > log->l_logBBsize)\n\t\tbufblks >>= 1;\n\twhile (!(buffer = xlog_alloc_buffer(log, bufblks))) {\n\t\tbufblks >>= 1;\n\t\tif (bufblks < log->l_sectBBsize)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = start_blk; i < start_blk + nbblks; i += bufblks) {\n\t\tint\tbcount;\n\n\t\tbcount = min(bufblks, (start_blk + nbblks - i));\n\n\t\terror = xlog_bread(log, i, bcount, buffer, &buf);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tfor (j = 0; j < bcount; j++) {\n\t\t\tcycle = xlog_get_cycle(buf);\n\t\t\tif (cycle == stop_on_cycle_no) {\n\t\t\t\t*new_blk = i+j;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbuf += BBSIZE;\n\t\t}\n\t}\n\n\t*new_blk = -1;\n\nout:\n\tkmem_free(buffer);\n\treturn error;\n}\n\nstatic inline int\nxlog_logrec_hblks(struct xlog *log, struct xlog_rec_header *rh)\n{\n\tif (xfs_has_logv2(log->l_mp)) {\n\t\tint\th_size = be32_to_cpu(rh->h_size);\n\n\t\tif ((be32_to_cpu(rh->h_version) & XLOG_VERSION_2) &&\n\t\t    h_size > XLOG_HEADER_CYCLE_SIZE)\n\t\t\treturn DIV_ROUND_UP(h_size, XLOG_HEADER_CYCLE_SIZE);\n\t}\n\treturn 1;\n}\n\n \nSTATIC int\nxlog_find_verify_log_record(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tstart_blk,\n\txfs_daddr_t\t\t*last_blk,\n\tint\t\t\textra_bblks)\n{\n\txfs_daddr_t\t\ti;\n\tchar\t\t\t*buffer;\n\tchar\t\t\t*offset = NULL;\n\txlog_rec_header_t\t*head = NULL;\n\tint\t\t\terror = 0;\n\tint\t\t\tsmallmem = 0;\n\tint\t\t\tnum_blks = *last_blk - start_blk;\n\tint\t\t\txhdrs;\n\n\tASSERT(start_blk != 0 || *last_blk != start_blk);\n\n\tbuffer = xlog_alloc_buffer(log, num_blks);\n\tif (!buffer) {\n\t\tbuffer = xlog_alloc_buffer(log, 1);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t\tsmallmem = 1;\n\t} else {\n\t\terror = xlog_bread(log, start_blk, num_blks, buffer, &offset);\n\t\tif (error)\n\t\t\tgoto out;\n\t\toffset += ((num_blks - 1) << BBSHIFT);\n\t}\n\n\tfor (i = (*last_blk) - 1; i >= 0; i--) {\n\t\tif (i < start_blk) {\n\t\t\t \n\t\t\txfs_warn(log->l_mp,\n\t\t\"Log inconsistent (didn't find previous header)\");\n\t\t\tASSERT(0);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (smallmem) {\n\t\t\terror = xlog_bread(log, i, 1, buffer, &offset);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\thead = (xlog_rec_header_t *)offset;\n\n\t\tif (head->h_magicno == cpu_to_be32(XLOG_HEADER_MAGIC_NUM))\n\t\t\tbreak;\n\n\t\tif (!smallmem)\n\t\t\toffset -= BBSIZE;\n\t}\n\n\t \n\tif (i == -1) {\n\t\terror = 1;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((error = xlog_header_check_mount(log->l_mp, head)))\n\t\tgoto out;\n\n\t \n\txhdrs = xlog_logrec_hblks(log, head);\n\n\tif (*last_blk - i + extra_bblks !=\n\t    BTOBB(be32_to_cpu(head->h_len)) + xhdrs)\n\t\t*last_blk = i;\n\nout:\n\tkmem_free(buffer);\n\treturn error;\n}\n\n \nSTATIC int\nxlog_find_head(\n\tstruct xlog\t*log,\n\txfs_daddr_t\t*return_head_blk)\n{\n\tchar\t\t*buffer;\n\tchar\t\t*offset;\n\txfs_daddr_t\tnew_blk, first_blk, start_blk, last_blk, head_blk;\n\tint\t\tnum_scan_bblks;\n\tuint\t\tfirst_half_cycle, last_half_cycle;\n\tuint\t\tstop_on_cycle;\n\tint\t\terror, log_bbnum = log->l_logBBsize;\n\n\t \n\terror = xlog_find_zeroed(log, &first_blk);\n\tif (error < 0) {\n\t\txfs_warn(log->l_mp, \"empty log check failed\");\n\t\treturn error;\n\t}\n\tif (error == 1) {\n\t\t*return_head_blk = first_blk;\n\n\t\t \n\t\tif (!first_blk) {\n\t\t\t \n\t\t\txfs_warn(log->l_mp, \"totally zeroed log\");\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfirst_blk = 0;\t\t\t \n\tbuffer = xlog_alloc_buffer(log, 1);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\terror = xlog_bread(log, 0, 1, buffer, &offset);\n\tif (error)\n\t\tgoto out_free_buffer;\n\n\tfirst_half_cycle = xlog_get_cycle(offset);\n\n\tlast_blk = head_blk = log_bbnum - 1;\t \n\terror = xlog_bread(log, last_blk, 1, buffer, &offset);\n\tif (error)\n\t\tgoto out_free_buffer;\n\n\tlast_half_cycle = xlog_get_cycle(offset);\n\tASSERT(last_half_cycle != 0);\n\n\t \n\tif (first_half_cycle == last_half_cycle) {\n\t\t \n\t\thead_blk = log_bbnum;\n\t\tstop_on_cycle = last_half_cycle - 1;\n\t} else {\n\t\t \n\t\tstop_on_cycle = last_half_cycle;\n\t\terror = xlog_find_cycle_start(log, buffer, first_blk, &head_blk,\n\t\t\t\tlast_half_cycle);\n\t\tif (error)\n\t\t\tgoto out_free_buffer;\n\t}\n\n\t \n\tnum_scan_bblks = min_t(int, log_bbnum, XLOG_TOTAL_REC_SHIFT(log));\n\tif (head_blk >= num_scan_bblks) {\n\t\t \n\t\tstart_blk = head_blk - num_scan_bblks;\n\t\tif ((error = xlog_find_verify_cycle(log,\n\t\t\t\t\t\tstart_blk, num_scan_bblks,\n\t\t\t\t\t\tstop_on_cycle, &new_blk)))\n\t\t\tgoto out_free_buffer;\n\t\tif (new_blk != -1)\n\t\t\thead_blk = new_blk;\n\t} else {\t\t \n\t\t \n\t\tASSERT(head_blk <= INT_MAX &&\n\t\t\t(xfs_daddr_t) num_scan_bblks >= head_blk);\n\t\tstart_blk = log_bbnum - (num_scan_bblks - head_blk);\n\t\tif ((error = xlog_find_verify_cycle(log, start_blk,\n\t\t\t\t\tnum_scan_bblks - (int)head_blk,\n\t\t\t\t\t(stop_on_cycle - 1), &new_blk)))\n\t\t\tgoto out_free_buffer;\n\t\tif (new_blk != -1) {\n\t\t\thead_blk = new_blk;\n\t\t\tgoto validate_head;\n\t\t}\n\n\t\t \n\t\tstart_blk = 0;\n\t\tASSERT(head_blk <= INT_MAX);\n\t\tif ((error = xlog_find_verify_cycle(log,\n\t\t\t\t\tstart_blk, (int)head_blk,\n\t\t\t\t\tstop_on_cycle, &new_blk)))\n\t\t\tgoto out_free_buffer;\n\t\tif (new_blk != -1)\n\t\t\thead_blk = new_blk;\n\t}\n\nvalidate_head:\n\t \n\tnum_scan_bblks = XLOG_REC_SHIFT(log);\n\tif (head_blk >= num_scan_bblks) {\n\t\tstart_blk = head_blk - num_scan_bblks;  \n\n\t\t \n\t\terror = xlog_find_verify_log_record(log, start_blk, &head_blk, 0);\n\t\tif (error == 1)\n\t\t\terror = -EIO;\n\t\tif (error)\n\t\t\tgoto out_free_buffer;\n\t} else {\n\t\tstart_blk = 0;\n\t\tASSERT(head_blk <= INT_MAX);\n\t\terror = xlog_find_verify_log_record(log, start_blk, &head_blk, 0);\n\t\tif (error < 0)\n\t\t\tgoto out_free_buffer;\n\t\tif (error == 1) {\n\t\t\t \n\t\t\tstart_blk = log_bbnum - (num_scan_bblks - head_blk);\n\t\t\tnew_blk = log_bbnum;\n\t\t\tASSERT(start_blk <= INT_MAX &&\n\t\t\t\t(xfs_daddr_t) log_bbnum-start_blk >= 0);\n\t\t\tASSERT(head_blk <= INT_MAX);\n\t\t\terror = xlog_find_verify_log_record(log, start_blk,\n\t\t\t\t\t\t\t&new_blk, (int)head_blk);\n\t\t\tif (error == 1)\n\t\t\t\terror = -EIO;\n\t\t\tif (error)\n\t\t\t\tgoto out_free_buffer;\n\t\t\tif (new_blk != log_bbnum)\n\t\t\t\thead_blk = new_blk;\n\t\t} else if (error)\n\t\t\tgoto out_free_buffer;\n\t}\n\n\tkmem_free(buffer);\n\tif (head_blk == log_bbnum)\n\t\t*return_head_blk = 0;\n\telse\n\t\t*return_head_blk = head_blk;\n\t \n\treturn 0;\n\nout_free_buffer:\n\tkmem_free(buffer);\n\tif (error)\n\t\txfs_warn(log->l_mp, \"failed to find log head\");\n\treturn error;\n}\n\n \nSTATIC int\nxlog_rseek_logrec_hdr(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\thead_blk,\n\txfs_daddr_t\t\ttail_blk,\n\tint\t\t\tcount,\n\tchar\t\t\t*buffer,\n\txfs_daddr_t\t\t*rblk,\n\tstruct xlog_rec_header\t**rhead,\n\tbool\t\t\t*wrapped)\n{\n\tint\t\t\ti;\n\tint\t\t\terror;\n\tint\t\t\tfound = 0;\n\tchar\t\t\t*offset = NULL;\n\txfs_daddr_t\t\tend_blk;\n\n\t*wrapped = false;\n\n\t \n\tend_blk = head_blk > tail_blk ? tail_blk : 0;\n\tfor (i = (int) head_blk - 1; i >= end_blk; i--) {\n\t\terror = xlog_bread(log, i, 1, buffer, &offset);\n\t\tif (error)\n\t\t\tgoto out_error;\n\n\t\tif (*(__be32 *) offset == cpu_to_be32(XLOG_HEADER_MAGIC_NUM)) {\n\t\t\t*rblk = i;\n\t\t\t*rhead = (struct xlog_rec_header *) offset;\n\t\t\tif (++found == count)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (tail_blk >= head_blk && found != count) {\n\t\tfor (i = log->l_logBBsize - 1; i >= (int) tail_blk; i--) {\n\t\t\terror = xlog_bread(log, i, 1, buffer, &offset);\n\t\t\tif (error)\n\t\t\t\tgoto out_error;\n\n\t\t\tif (*(__be32 *)offset ==\n\t\t\t    cpu_to_be32(XLOG_HEADER_MAGIC_NUM)) {\n\t\t\t\t*wrapped = true;\n\t\t\t\t*rblk = i;\n\t\t\t\t*rhead = (struct xlog_rec_header *) offset;\n\t\t\t\tif (++found == count)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n\nout_error:\n\treturn error;\n}\n\n \nSTATIC int\nxlog_seek_logrec_hdr(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\thead_blk,\n\txfs_daddr_t\t\ttail_blk,\n\tint\t\t\tcount,\n\tchar\t\t\t*buffer,\n\txfs_daddr_t\t\t*rblk,\n\tstruct xlog_rec_header\t**rhead,\n\tbool\t\t\t*wrapped)\n{\n\tint\t\t\ti;\n\tint\t\t\terror;\n\tint\t\t\tfound = 0;\n\tchar\t\t\t*offset = NULL;\n\txfs_daddr_t\t\tend_blk;\n\n\t*wrapped = false;\n\n\t \n\tend_blk = head_blk > tail_blk ? head_blk : log->l_logBBsize - 1;\n\tfor (i = (int) tail_blk; i <= end_blk; i++) {\n\t\terror = xlog_bread(log, i, 1, buffer, &offset);\n\t\tif (error)\n\t\t\tgoto out_error;\n\n\t\tif (*(__be32 *) offset == cpu_to_be32(XLOG_HEADER_MAGIC_NUM)) {\n\t\t\t*rblk = i;\n\t\t\t*rhead = (struct xlog_rec_header *) offset;\n\t\t\tif (++found == count)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (tail_blk > head_blk && found != count) {\n\t\tfor (i = 0; i < (int) head_blk; i++) {\n\t\t\terror = xlog_bread(log, i, 1, buffer, &offset);\n\t\t\tif (error)\n\t\t\t\tgoto out_error;\n\n\t\t\tif (*(__be32 *)offset ==\n\t\t\t    cpu_to_be32(XLOG_HEADER_MAGIC_NUM)) {\n\t\t\t\t*wrapped = true;\n\t\t\t\t*rblk = i;\n\t\t\t\t*rhead = (struct xlog_rec_header *) offset;\n\t\t\t\tif (++found == count)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n\nout_error:\n\treturn error;\n}\n\n \nstatic inline int\nxlog_tail_distance(\n\tstruct xlog\t*log,\n\txfs_daddr_t\thead_blk,\n\txfs_daddr_t\ttail_blk)\n{\n\tif (head_blk < tail_blk)\n\t\treturn tail_blk - head_blk;\n\n\treturn tail_blk + (log->l_logBBsize - head_blk);\n}\n\n \nSTATIC int\nxlog_verify_tail(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\thead_blk,\n\txfs_daddr_t\t\t*tail_blk,\n\tint\t\t\thsize)\n{\n\tstruct xlog_rec_header\t*thead;\n\tchar\t\t\t*buffer;\n\txfs_daddr_t\t\tfirst_bad;\n\tint\t\t\terror = 0;\n\tbool\t\t\twrapped;\n\txfs_daddr_t\t\ttmp_tail;\n\txfs_daddr_t\t\torig_tail = *tail_blk;\n\n\tbuffer = xlog_alloc_buffer(log, 1);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\t \n\terror = xlog_seek_logrec_hdr(log, head_blk, *tail_blk, 1, buffer,\n\t\t\t&tmp_tail, &thead, &wrapped);\n\tif (error < 0)\n\t\tgoto out;\n\tif (*tail_blk != tmp_tail)\n\t\t*tail_blk = tmp_tail;\n\n\t \n\tfirst_bad = 0;\n\terror = xlog_do_recovery_pass(log, head_blk, *tail_blk,\n\t\t\t\t      XLOG_RECOVER_CRCPASS, &first_bad);\n\twhile ((error == -EFSBADCRC || error == -EFSCORRUPTED) && first_bad) {\n\t\tint\ttail_distance;\n\n\t\t \n\t\ttail_distance = xlog_tail_distance(log, head_blk, first_bad);\n\t\tif (tail_distance > BTOBB(XLOG_MAX_ICLOGS * hsize))\n\t\t\tbreak;\n\n\t\t \n\t\terror = xlog_seek_logrec_hdr(log, head_blk, first_bad, 2,\n\t\t\t\tbuffer, &tmp_tail, &thead, &wrapped);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\t*tail_blk = tmp_tail;\n\t\tfirst_bad = 0;\n\t\terror = xlog_do_recovery_pass(log, head_blk, *tail_blk,\n\t\t\t\t\t      XLOG_RECOVER_CRCPASS, &first_bad);\n\t}\n\n\tif (!error && *tail_blk != orig_tail)\n\t\txfs_warn(log->l_mp,\n\t\t\"Tail block (0x%llx) overwrite detected. Updated to 0x%llx\",\n\t\t\t orig_tail, *tail_blk);\nout:\n\tkmem_free(buffer);\n\treturn error;\n}\n\n \nSTATIC int\nxlog_verify_head(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\t*head_blk,\t \n\txfs_daddr_t\t\t*tail_blk,\t \n\tchar\t\t\t*buffer,\n\txfs_daddr_t\t\t*rhead_blk,\t \n\tstruct xlog_rec_header\t**rhead,\t \n\tbool\t\t\t*wrapped)\t \n{\n\tstruct xlog_rec_header\t*tmp_rhead;\n\tchar\t\t\t*tmp_buffer;\n\txfs_daddr_t\t\tfirst_bad;\n\txfs_daddr_t\t\ttmp_rhead_blk;\n\tint\t\t\tfound;\n\tint\t\t\terror;\n\tbool\t\t\ttmp_wrapped;\n\n\t \n\ttmp_buffer = xlog_alloc_buffer(log, 1);\n\tif (!tmp_buffer)\n\t\treturn -ENOMEM;\n\terror = xlog_rseek_logrec_hdr(log, *head_blk, *tail_blk,\n\t\t\t\t      XLOG_MAX_ICLOGS, tmp_buffer,\n\t\t\t\t      &tmp_rhead_blk, &tmp_rhead, &tmp_wrapped);\n\tkmem_free(tmp_buffer);\n\tif (error < 0)\n\t\treturn error;\n\n\t \n\terror = xlog_do_recovery_pass(log, *head_blk, tmp_rhead_blk,\n\t\t\t\t      XLOG_RECOVER_CRCPASS, &first_bad);\n\tif ((error == -EFSBADCRC || error == -EFSCORRUPTED) && first_bad) {\n\t\t \n\t\terror = 0;\n\t\txfs_warn(log->l_mp,\n\"Torn write (CRC failure) detected at log block 0x%llx. Truncating head block from 0x%llx.\",\n\t\t\t first_bad, *head_blk);\n\n\t\t \n\t\tfound = xlog_rseek_logrec_hdr(log, first_bad, *tail_blk, 1,\n\t\t\t\tbuffer, rhead_blk, rhead, wrapped);\n\t\tif (found < 0)\n\t\t\treturn found;\n\t\tif (found == 0)\t\t \n\t\t\treturn -EIO;\n\n\t\t \n\t\t*head_blk = first_bad;\n\t\t*tail_blk = BLOCK_LSN(be64_to_cpu((*rhead)->h_tail_lsn));\n\t\tif (*head_blk == *tail_blk) {\n\t\t\tASSERT(0);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (error)\n\t\treturn error;\n\n\treturn xlog_verify_tail(log, *head_blk, tail_blk,\n\t\t\t\tbe32_to_cpu((*rhead)->h_size));\n}\n\n \nstatic inline xfs_daddr_t\nxlog_wrap_logbno(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tbno)\n{\n\tint\t\t\tmod;\n\n\tdiv_s64_rem(bno, log->l_logBBsize, &mod);\n\treturn mod;\n}\n\n \nstatic int\nxlog_check_unmount_rec(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\t*head_blk,\n\txfs_daddr_t\t\t*tail_blk,\n\tstruct xlog_rec_header\t*rhead,\n\txfs_daddr_t\t\trhead_blk,\n\tchar\t\t\t*buffer,\n\tbool\t\t\t*clean)\n{\n\tstruct xlog_op_header\t*op_head;\n\txfs_daddr_t\t\tumount_data_blk;\n\txfs_daddr_t\t\tafter_umount_blk;\n\tint\t\t\thblks;\n\tint\t\t\terror;\n\tchar\t\t\t*offset;\n\n\t*clean = false;\n\n\t \n\thblks = xlog_logrec_hblks(log, rhead);\n\tafter_umount_blk = xlog_wrap_logbno(log,\n\t\t\trhead_blk + hblks + BTOBB(be32_to_cpu(rhead->h_len)));\n\n\tif (*head_blk == after_umount_blk &&\n\t    be32_to_cpu(rhead->h_num_logops) == 1) {\n\t\tumount_data_blk = xlog_wrap_logbno(log, rhead_blk + hblks);\n\t\terror = xlog_bread(log, umount_data_blk, 1, buffer, &offset);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\top_head = (struct xlog_op_header *)offset;\n\t\tif (op_head->oh_flags & XLOG_UNMOUNT_TRANS) {\n\t\t\t \n\t\t\txlog_assign_atomic_lsn(&log->l_tail_lsn,\n\t\t\t\t\tlog->l_curr_cycle, after_umount_blk);\n\t\t\txlog_assign_atomic_lsn(&log->l_last_sync_lsn,\n\t\t\t\t\tlog->l_curr_cycle, after_umount_blk);\n\t\t\t*tail_blk = after_umount_blk;\n\n\t\t\t*clean = true;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void\nxlog_set_state(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\thead_blk,\n\tstruct xlog_rec_header\t*rhead,\n\txfs_daddr_t\t\trhead_blk,\n\tbool\t\t\tbump_cycle)\n{\n\t \n\tlog->l_prev_block = rhead_blk;\n\tlog->l_curr_block = (int)head_blk;\n\tlog->l_curr_cycle = be32_to_cpu(rhead->h_cycle);\n\tif (bump_cycle)\n\t\tlog->l_curr_cycle++;\n\tatomic64_set(&log->l_tail_lsn, be64_to_cpu(rhead->h_tail_lsn));\n\tatomic64_set(&log->l_last_sync_lsn, be64_to_cpu(rhead->h_lsn));\n\txlog_assign_grant_head(&log->l_reserve_head.grant, log->l_curr_cycle,\n\t\t\t\t\tBBTOB(log->l_curr_block));\n\txlog_assign_grant_head(&log->l_write_head.grant, log->l_curr_cycle,\n\t\t\t\t\tBBTOB(log->l_curr_block));\n}\n\n \nSTATIC int\nxlog_find_tail(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\t*head_blk,\n\txfs_daddr_t\t\t*tail_blk)\n{\n\txlog_rec_header_t\t*rhead;\n\tchar\t\t\t*offset = NULL;\n\tchar\t\t\t*buffer;\n\tint\t\t\terror;\n\txfs_daddr_t\t\trhead_blk;\n\txfs_lsn_t\t\ttail_lsn;\n\tbool\t\t\twrapped = false;\n\tbool\t\t\tclean = false;\n\n\t \n\tif ((error = xlog_find_head(log, head_blk)))\n\t\treturn error;\n\tASSERT(*head_blk < INT_MAX);\n\n\tbuffer = xlog_alloc_buffer(log, 1);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\tif (*head_blk == 0) {\t\t\t\t \n\t\terror = xlog_bread(log, 0, 1, buffer, &offset);\n\t\tif (error)\n\t\t\tgoto done;\n\n\t\tif (xlog_get_cycle(offset) == 0) {\n\t\t\t*tail_blk = 0;\n\t\t\t \n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\terror = xlog_rseek_logrec_hdr(log, *head_blk, *head_blk, 1, buffer,\n\t\t\t\t      &rhead_blk, &rhead, &wrapped);\n\tif (error < 0)\n\t\tgoto done;\n\tif (!error) {\n\t\txfs_warn(log->l_mp, \"%s: couldn't find sync record\", __func__);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto done;\n\t}\n\t*tail_blk = BLOCK_LSN(be64_to_cpu(rhead->h_tail_lsn));\n\n\t \n\txlog_set_state(log, *head_blk, rhead, rhead_blk, wrapped);\n\ttail_lsn = atomic64_read(&log->l_tail_lsn);\n\n\t \n\terror = xlog_check_unmount_rec(log, head_blk, tail_blk, rhead,\n\t\t\t\t       rhead_blk, buffer, &clean);\n\tif (error)\n\t\tgoto done;\n\n\t \n\tif (!clean) {\n\t\txfs_daddr_t\torig_head = *head_blk;\n\n\t\terror = xlog_verify_head(log, head_blk, tail_blk, buffer,\n\t\t\t\t\t &rhead_blk, &rhead, &wrapped);\n\t\tif (error)\n\t\t\tgoto done;\n\n\t\t \n\t\tif (*head_blk != orig_head) {\n\t\t\txlog_set_state(log, *head_blk, rhead, rhead_blk,\n\t\t\t\t       wrapped);\n\t\t\ttail_lsn = atomic64_read(&log->l_tail_lsn);\n\t\t\terror = xlog_check_unmount_rec(log, head_blk, tail_blk,\n\t\t\t\t\t\t       rhead, rhead_blk, buffer,\n\t\t\t\t\t\t       &clean);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tif (clean)\n\t\tset_bit(XFS_OPSTATE_CLEAN, &log->l_mp->m_opstate);\n\n\t \n\tif (!xfs_readonly_buftarg(log->l_targ))\n\t\terror = xlog_clear_stale_blocks(log, tail_lsn);\n\ndone:\n\tkmem_free(buffer);\n\n\tif (error)\n\t\txfs_warn(log->l_mp, \"failed to locate log tail\");\n\treturn error;\n}\n\n \nSTATIC int\nxlog_find_zeroed(\n\tstruct xlog\t*log,\n\txfs_daddr_t\t*blk_no)\n{\n\tchar\t\t*buffer;\n\tchar\t\t*offset;\n\tuint\t        first_cycle, last_cycle;\n\txfs_daddr_t\tnew_blk, last_blk, start_blk;\n\txfs_daddr_t     num_scan_bblks;\n\tint\t        error, log_bbnum = log->l_logBBsize;\n\n\t*blk_no = 0;\n\n\t \n\tbuffer = xlog_alloc_buffer(log, 1);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\terror = xlog_bread(log, 0, 1, buffer, &offset);\n\tif (error)\n\t\tgoto out_free_buffer;\n\n\tfirst_cycle = xlog_get_cycle(offset);\n\tif (first_cycle == 0) {\t\t \n\t\t*blk_no = 0;\n\t\tkmem_free(buffer);\n\t\treturn 1;\n\t}\n\n\t \n\terror = xlog_bread(log, log_bbnum-1, 1, buffer, &offset);\n\tif (error)\n\t\tgoto out_free_buffer;\n\n\tlast_cycle = xlog_get_cycle(offset);\n\tif (last_cycle != 0) {\t\t \n\t\tkmem_free(buffer);\n\t\treturn 0;\n\t}\n\n\t \n\tlast_blk = log_bbnum-1;\n\terror = xlog_find_cycle_start(log, buffer, 0, &last_blk, 0);\n\tif (error)\n\t\tgoto out_free_buffer;\n\n\t \n\tnum_scan_bblks = XLOG_TOTAL_REC_SHIFT(log);\n\tASSERT(num_scan_bblks <= INT_MAX);\n\n\tif (last_blk < num_scan_bblks)\n\t\tnum_scan_bblks = last_blk;\n\tstart_blk = last_blk - num_scan_bblks;\n\n\t \n\tif ((error = xlog_find_verify_cycle(log, start_blk,\n\t\t\t\t\t (int)num_scan_bblks, 0, &new_blk)))\n\t\tgoto out_free_buffer;\n\tif (new_blk != -1)\n\t\tlast_blk = new_blk;\n\n\t \n\terror = xlog_find_verify_log_record(log, start_blk, &last_blk, 0);\n\tif (error == 1)\n\t\terror = -EIO;\n\tif (error)\n\t\tgoto out_free_buffer;\n\n\t*blk_no = last_blk;\nout_free_buffer:\n\tkmem_free(buffer);\n\tif (error)\n\t\treturn error;\n\treturn 1;\n}\n\n \nSTATIC void\nxlog_add_record(\n\tstruct xlog\t\t*log,\n\tchar\t\t\t*buf,\n\tint\t\t\tcycle,\n\tint\t\t\tblock,\n\tint\t\t\ttail_cycle,\n\tint\t\t\ttail_block)\n{\n\txlog_rec_header_t\t*recp = (xlog_rec_header_t *)buf;\n\n\tmemset(buf, 0, BBSIZE);\n\trecp->h_magicno = cpu_to_be32(XLOG_HEADER_MAGIC_NUM);\n\trecp->h_cycle = cpu_to_be32(cycle);\n\trecp->h_version = cpu_to_be32(\n\t\t\txfs_has_logv2(log->l_mp) ? 2 : 1);\n\trecp->h_lsn = cpu_to_be64(xlog_assign_lsn(cycle, block));\n\trecp->h_tail_lsn = cpu_to_be64(xlog_assign_lsn(tail_cycle, tail_block));\n\trecp->h_fmt = cpu_to_be32(XLOG_FMT);\n\tmemcpy(&recp->h_fs_uuid, &log->l_mp->m_sb.sb_uuid, sizeof(uuid_t));\n}\n\nSTATIC int\nxlog_write_log_records(\n\tstruct xlog\t*log,\n\tint\t\tcycle,\n\tint\t\tstart_block,\n\tint\t\tblocks,\n\tint\t\ttail_cycle,\n\tint\t\ttail_block)\n{\n\tchar\t\t*offset;\n\tchar\t\t*buffer;\n\tint\t\tbalign, ealign;\n\tint\t\tsectbb = log->l_sectBBsize;\n\tint\t\tend_block = start_block + blocks;\n\tint\t\tbufblks;\n\tint\t\terror = 0;\n\tint\t\ti, j = 0;\n\n\t \n\tbufblks = roundup_pow_of_two(blocks);\n\twhile (bufblks > log->l_logBBsize)\n\t\tbufblks >>= 1;\n\twhile (!(buffer = xlog_alloc_buffer(log, bufblks))) {\n\t\tbufblks >>= 1;\n\t\tif (bufblks < sectbb)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tbalign = round_down(start_block, sectbb);\n\tif (balign != start_block) {\n\t\terror = xlog_bread_noalign(log, start_block, 1, buffer);\n\t\tif (error)\n\t\t\tgoto out_free_buffer;\n\n\t\tj = start_block - balign;\n\t}\n\n\tfor (i = start_block; i < end_block; i += bufblks) {\n\t\tint\t\tbcount, endcount;\n\n\t\tbcount = min(bufblks, end_block - start_block);\n\t\tendcount = bcount - j;\n\n\t\t \n\t\tealign = round_down(end_block, sectbb);\n\t\tif (j == 0 && (start_block + endcount > ealign)) {\n\t\t\terror = xlog_bread_noalign(log, ealign, sectbb,\n\t\t\t\t\tbuffer + BBTOB(ealign - start_block));\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\toffset = buffer + xlog_align(log, start_block);\n\t\tfor (; j < endcount; j++) {\n\t\t\txlog_add_record(log, offset, cycle, i+j,\n\t\t\t\t\ttail_cycle, tail_block);\n\t\t\toffset += BBSIZE;\n\t\t}\n\t\terror = xlog_bwrite(log, start_block, endcount, buffer);\n\t\tif (error)\n\t\t\tbreak;\n\t\tstart_block += endcount;\n\t\tj = 0;\n\t}\n\nout_free_buffer:\n\tkmem_free(buffer);\n\treturn error;\n}\n\n \nSTATIC int\nxlog_clear_stale_blocks(\n\tstruct xlog\t*log,\n\txfs_lsn_t\ttail_lsn)\n{\n\tint\t\ttail_cycle, head_cycle;\n\tint\t\ttail_block, head_block;\n\tint\t\ttail_distance, max_distance;\n\tint\t\tdistance;\n\tint\t\terror;\n\n\ttail_cycle = CYCLE_LSN(tail_lsn);\n\ttail_block = BLOCK_LSN(tail_lsn);\n\thead_cycle = log->l_curr_cycle;\n\thead_block = log->l_curr_block;\n\n\t \n\tif (head_cycle == tail_cycle) {\n\t\t \n\t\tif (XFS_IS_CORRUPT(log->l_mp,\n\t\t\t\t   head_block < tail_block ||\n\t\t\t\t   head_block >= log->l_logBBsize))\n\t\t\treturn -EFSCORRUPTED;\n\t\ttail_distance = tail_block + (log->l_logBBsize - head_block);\n\t} else {\n\t\t \n\t\tif (XFS_IS_CORRUPT(log->l_mp,\n\t\t\t\t   head_block >= tail_block ||\n\t\t\t\t   head_cycle != tail_cycle + 1))\n\t\t\treturn -EFSCORRUPTED;\n\t\ttail_distance = tail_block - head_block;\n\t}\n\n\t \n\tif (tail_distance <= 0) {\n\t\tASSERT(tail_distance == 0);\n\t\treturn 0;\n\t}\n\n\tmax_distance = XLOG_TOTAL_REC_SHIFT(log);\n\t \n\tmax_distance = min(max_distance, tail_distance);\n\n\tif ((head_block + max_distance) <= log->l_logBBsize) {\n\t\t \n\t\terror = xlog_write_log_records(log, (head_cycle - 1),\n\t\t\t\thead_block, max_distance, tail_cycle,\n\t\t\t\ttail_block);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\t \n\t\tdistance = log->l_logBBsize - head_block;\n\t\terror = xlog_write_log_records(log, (head_cycle - 1),\n\t\t\t\thead_block, distance, tail_cycle,\n\t\t\t\ttail_block);\n\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tdistance = max_distance - (log->l_logBBsize - head_block);\n\t\terror = xlog_write_log_records(log, head_cycle, 0, distance,\n\t\t\t\ttail_cycle, tail_block);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \nvoid\nxlog_recover_release_intent(\n\tstruct xlog\t\t*log,\n\tunsigned short\t\tintent_type,\n\tuint64_t\t\tintent_id)\n{\n\tstruct xfs_ail_cursor\tcur;\n\tstruct xfs_log_item\t*lip;\n\tstruct xfs_ail\t\t*ailp = log->l_ailp;\n\n\tspin_lock(&ailp->ail_lock);\n\tfor (lip = xfs_trans_ail_cursor_first(ailp, &cur, 0); lip != NULL;\n\t     lip = xfs_trans_ail_cursor_next(ailp, &cur)) {\n\t\tif (lip->li_type != intent_type)\n\t\t\tcontinue;\n\t\tif (!lip->li_ops->iop_match(lip, intent_id))\n\t\t\tcontinue;\n\n\t\tspin_unlock(&ailp->ail_lock);\n\t\tlip->li_ops->iop_release(lip);\n\t\tspin_lock(&ailp->ail_lock);\n\t\tbreak;\n\t}\n\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->ail_lock);\n}\n\nint\nxlog_recover_iget(\n\tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp)\n{\n\tint\t\t\terror;\n\n\terror = xfs_iget(mp, NULL, ino, 0, 0, ipp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_qm_dqattach(*ipp);\n\tif (error) {\n\t\txfs_irele(*ipp);\n\t\treturn error;\n\t}\n\n\tif (VFS_I(*ipp)->i_nlink == 0)\n\t\txfs_iflags_set(*ipp, XFS_IRECOVERY);\n\n\treturn 0;\n}\n\n \nstatic const struct xlog_recover_item_ops *xlog_recover_item_ops[] = {\n\t&xlog_buf_item_ops,\n\t&xlog_inode_item_ops,\n\t&xlog_dquot_item_ops,\n\t&xlog_quotaoff_item_ops,\n\t&xlog_icreate_item_ops,\n\t&xlog_efi_item_ops,\n\t&xlog_efd_item_ops,\n\t&xlog_rui_item_ops,\n\t&xlog_rud_item_ops,\n\t&xlog_cui_item_ops,\n\t&xlog_cud_item_ops,\n\t&xlog_bui_item_ops,\n\t&xlog_bud_item_ops,\n\t&xlog_attri_item_ops,\n\t&xlog_attrd_item_ops,\n};\n\nstatic const struct xlog_recover_item_ops *\nxlog_find_item_ops(\n\tstruct xlog_recover_item\t\t*item)\n{\n\tunsigned int\t\t\t\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(xlog_recover_item_ops); i++)\n\t\tif (ITEM_TYPE(item) == xlog_recover_item_ops[i]->item_type)\n\t\t\treturn xlog_recover_item_ops[i];\n\n\treturn NULL;\n}\n\n \nSTATIC int\nxlog_recover_reorder_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\tint\t\t\tpass)\n{\n\tstruct xlog_recover_item *item, *n;\n\tint\t\t\terror = 0;\n\tLIST_HEAD(sort_list);\n\tLIST_HEAD(cancel_list);\n\tLIST_HEAD(buffer_list);\n\tLIST_HEAD(inode_buffer_list);\n\tLIST_HEAD(item_list);\n\n\tlist_splice_init(&trans->r_itemq, &sort_list);\n\tlist_for_each_entry_safe(item, n, &sort_list, ri_list) {\n\t\tenum xlog_recover_reorder\tfate = XLOG_REORDER_ITEM_LIST;\n\n\t\titem->ri_ops = xlog_find_item_ops(item);\n\t\tif (!item->ri_ops) {\n\t\t\txfs_warn(log->l_mp,\n\t\t\t\t\"%s: unrecognized type of log operation (%d)\",\n\t\t\t\t__func__, ITEM_TYPE(item));\n\t\t\tASSERT(0);\n\t\t\t \n\t\t\tif (!list_empty(&sort_list))\n\t\t\t\tlist_splice_init(&sort_list, &trans->r_itemq);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (item->ri_ops->reorder)\n\t\t\tfate = item->ri_ops->reorder(item);\n\n\t\tswitch (fate) {\n\t\tcase XLOG_REORDER_BUFFER_LIST:\n\t\t\tlist_move_tail(&item->ri_list, &buffer_list);\n\t\t\tbreak;\n\t\tcase XLOG_REORDER_CANCEL_LIST:\n\t\t\ttrace_xfs_log_recover_item_reorder_head(log,\n\t\t\t\t\ttrans, item, pass);\n\t\t\tlist_move(&item->ri_list, &cancel_list);\n\t\t\tbreak;\n\t\tcase XLOG_REORDER_INODE_BUFFER_LIST:\n\t\t\tlist_move(&item->ri_list, &inode_buffer_list);\n\t\t\tbreak;\n\t\tcase XLOG_REORDER_ITEM_LIST:\n\t\t\ttrace_xfs_log_recover_item_reorder_tail(log,\n\t\t\t\t\t\t\ttrans, item, pass);\n\t\t\tlist_move_tail(&item->ri_list, &item_list);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tASSERT(list_empty(&sort_list));\n\tif (!list_empty(&buffer_list))\n\t\tlist_splice(&buffer_list, &trans->r_itemq);\n\tif (!list_empty(&item_list))\n\t\tlist_splice_tail(&item_list, &trans->r_itemq);\n\tif (!list_empty(&inode_buffer_list))\n\t\tlist_splice_tail(&inode_buffer_list, &trans->r_itemq);\n\tif (!list_empty(&cancel_list))\n\t\tlist_splice_tail(&cancel_list, &trans->r_itemq);\n\treturn error;\n}\n\nvoid\nxlog_buf_readahead(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\tblkno,\n\tuint\t\t\tlen,\n\tconst struct xfs_buf_ops *ops)\n{\n\tif (!xlog_is_buffer_cancelled(log, blkno, len))\n\t\txfs_buf_readahead(log->l_mp->m_ddev_targp, blkno, len, ops);\n}\n\nSTATIC int\nxlog_recover_items_pass2(\n\tstruct xlog                     *log,\n\tstruct xlog_recover             *trans,\n\tstruct list_head                *buffer_list,\n\tstruct list_head                *item_list)\n{\n\tstruct xlog_recover_item\t*item;\n\tint\t\t\t\terror = 0;\n\n\tlist_for_each_entry(item, item_list, ri_list) {\n\t\ttrace_xfs_log_recover_item_recover(log, trans, item,\n\t\t\t\tXLOG_RECOVER_PASS2);\n\n\t\tif (item->ri_ops->commit_pass2)\n\t\t\terror = item->ri_ops->commit_pass2(log, buffer_list,\n\t\t\t\t\titem, trans->r_lsn);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn error;\n}\n\n \nSTATIC int\nxlog_recover_commit_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\tint\t\t\tpass,\n\tstruct list_head\t*buffer_list)\n{\n\tint\t\t\t\terror = 0;\n\tint\t\t\t\titems_queued = 0;\n\tstruct xlog_recover_item\t*item;\n\tstruct xlog_recover_item\t*next;\n\tLIST_HEAD\t\t\t(ra_list);\n\tLIST_HEAD\t\t\t(done_list);\n\n\t#define XLOG_RECOVER_COMMIT_QUEUE_MAX 100\n\n\thlist_del_init(&trans->r_list);\n\n\terror = xlog_recover_reorder_trans(log, trans, pass);\n\tif (error)\n\t\treturn error;\n\n\tlist_for_each_entry_safe(item, next, &trans->r_itemq, ri_list) {\n\t\ttrace_xfs_log_recover_item_recover(log, trans, item, pass);\n\n\t\tswitch (pass) {\n\t\tcase XLOG_RECOVER_PASS1:\n\t\t\tif (item->ri_ops->commit_pass1)\n\t\t\t\terror = item->ri_ops->commit_pass1(log, item);\n\t\t\tbreak;\n\t\tcase XLOG_RECOVER_PASS2:\n\t\t\tif (item->ri_ops->ra_pass2)\n\t\t\t\titem->ri_ops->ra_pass2(log, item);\n\t\t\tlist_move_tail(&item->ri_list, &ra_list);\n\t\t\titems_queued++;\n\t\t\tif (items_queued >= XLOG_RECOVER_COMMIT_QUEUE_MAX) {\n\t\t\t\terror = xlog_recover_items_pass2(log, trans,\n\t\t\t\t\t\tbuffer_list, &ra_list);\n\t\t\t\tlist_splice_tail_init(&ra_list, &done_list);\n\t\t\t\titems_queued = 0;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (!list_empty(&ra_list)) {\n\t\tif (!error)\n\t\t\terror = xlog_recover_items_pass2(log, trans,\n\t\t\t\t\tbuffer_list, &ra_list);\n\t\tlist_splice_tail_init(&ra_list, &done_list);\n\t}\n\n\tif (!list_empty(&done_list))\n\t\tlist_splice_init(&done_list, &trans->r_itemq);\n\n\treturn error;\n}\n\nSTATIC void\nxlog_recover_add_item(\n\tstruct list_head\t*head)\n{\n\tstruct xlog_recover_item *item;\n\n\titem = kmem_zalloc(sizeof(struct xlog_recover_item), 0);\n\tINIT_LIST_HEAD(&item->ri_list);\n\tlist_add_tail(&item->ri_list, head);\n}\n\nSTATIC int\nxlog_recover_add_to_cont_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\tchar\t\t\t*dp,\n\tint\t\t\tlen)\n{\n\tstruct xlog_recover_item *item;\n\tchar\t\t\t*ptr, *old_ptr;\n\tint\t\t\told_len;\n\n\t \n\tif (list_empty(&trans->r_itemq)) {\n\t\tASSERT(len <= sizeof(struct xfs_trans_header));\n\t\tif (len > sizeof(struct xfs_trans_header)) {\n\t\t\txfs_warn(log->l_mp, \"%s: bad header length\", __func__);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\txlog_recover_add_item(&trans->r_itemq);\n\t\tptr = (char *)&trans->r_theader +\n\t\t\t\tsizeof(struct xfs_trans_header) - len;\n\t\tmemcpy(ptr, dp, len);\n\t\treturn 0;\n\t}\n\n\t \n\titem = list_entry(trans->r_itemq.prev, struct xlog_recover_item,\n\t\t\t  ri_list);\n\n\told_ptr = item->ri_buf[item->ri_cnt-1].i_addr;\n\told_len = item->ri_buf[item->ri_cnt-1].i_len;\n\n\tptr = kvrealloc(old_ptr, old_len, len + old_len, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tmemcpy(&ptr[old_len], dp, len);\n\titem->ri_buf[item->ri_cnt-1].i_len += len;\n\titem->ri_buf[item->ri_cnt-1].i_addr = ptr;\n\ttrace_xfs_log_recover_item_add_cont(log, trans, item, 0);\n\treturn 0;\n}\n\n \nSTATIC int\nxlog_recover_add_to_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\tchar\t\t\t*dp,\n\tint\t\t\tlen)\n{\n\tstruct xfs_inode_log_format\t*in_f;\t\t\t \n\tstruct xlog_recover_item *item;\n\tchar\t\t\t*ptr;\n\n\tif (!len)\n\t\treturn 0;\n\tif (list_empty(&trans->r_itemq)) {\n\t\t \n\t\tif (*(uint *)dp != XFS_TRANS_HEADER_MAGIC) {\n\t\t\txfs_warn(log->l_mp, \"%s: bad header magic number\",\n\t\t\t\t__func__);\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tif (len > sizeof(struct xfs_trans_header)) {\n\t\t\txfs_warn(log->l_mp, \"%s: bad header length\", __func__);\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\t \n\t\tif (len == sizeof(struct xfs_trans_header))\n\t\t\txlog_recover_add_item(&trans->r_itemq);\n\t\tmemcpy(&trans->r_theader, dp, len);\n\t\treturn 0;\n\t}\n\n\tptr = kmem_alloc(len, 0);\n\tmemcpy(ptr, dp, len);\n\tin_f = (struct xfs_inode_log_format *)ptr;\n\n\t \n\titem = list_entry(trans->r_itemq.prev, struct xlog_recover_item,\n\t\t\t  ri_list);\n\tif (item->ri_total != 0 &&\n\t     item->ri_total == item->ri_cnt) {\n\t\t \n\t\txlog_recover_add_item(&trans->r_itemq);\n\t\titem = list_entry(trans->r_itemq.prev,\n\t\t\t\t\tstruct xlog_recover_item, ri_list);\n\t}\n\n\tif (item->ri_total == 0) {\t\t \n\t\tif (in_f->ilf_size == 0 ||\n\t\t    in_f->ilf_size > XLOG_MAX_REGIONS_IN_ITEM) {\n\t\t\txfs_warn(log->l_mp,\n\t\t\"bad number of regions (%d) in inode log format\",\n\t\t\t\t  in_f->ilf_size);\n\t\t\tASSERT(0);\n\t\t\tkmem_free(ptr);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\titem->ri_total = in_f->ilf_size;\n\t\titem->ri_buf =\n\t\t\tkmem_zalloc(item->ri_total * sizeof(xfs_log_iovec_t),\n\t\t\t\t    0);\n\t}\n\n\tif (item->ri_total <= item->ri_cnt) {\n\t\txfs_warn(log->l_mp,\n\t\"log item region count (%d) overflowed size (%d)\",\n\t\t\t\titem->ri_cnt, item->ri_total);\n\t\tASSERT(0);\n\t\tkmem_free(ptr);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\titem->ri_buf[item->ri_cnt].i_addr = ptr;\n\titem->ri_buf[item->ri_cnt].i_len  = len;\n\titem->ri_cnt++;\n\ttrace_xfs_log_recover_item_add(log, trans, item, 0);\n\treturn 0;\n}\n\n \nSTATIC void\nxlog_recover_free_trans(\n\tstruct xlog_recover\t*trans)\n{\n\tstruct xlog_recover_item *item, *n;\n\tint\t\t\ti;\n\n\thlist_del_init(&trans->r_list);\n\n\tlist_for_each_entry_safe(item, n, &trans->r_itemq, ri_list) {\n\t\t \n\t\tlist_del(&item->ri_list);\n\t\tfor (i = 0; i < item->ri_cnt; i++)\n\t\t\tkmem_free(item->ri_buf[i].i_addr);\n\t\t \n\t\tkmem_free(item->ri_buf);\n\t\tkmem_free(item);\n\t}\n\t \n\tkmem_free(trans);\n}\n\n \nSTATIC int\nxlog_recovery_process_trans(\n\tstruct xlog\t\t*log,\n\tstruct xlog_recover\t*trans,\n\tchar\t\t\t*dp,\n\tunsigned int\t\tlen,\n\tunsigned int\t\tflags,\n\tint\t\t\tpass,\n\tstruct list_head\t*buffer_list)\n{\n\tint\t\t\terror = 0;\n\tbool\t\t\tfreeit = false;\n\n\t \n\tflags &= ~XLOG_END_TRANS;\n\tif (flags & XLOG_WAS_CONT_TRANS)\n\t\tflags &= ~XLOG_CONTINUE_TRANS;\n\n\t \n\tswitch (flags) {\n\t \n\tcase 0:\n\tcase XLOG_CONTINUE_TRANS:\n\t\terror = xlog_recover_add_to_trans(log, trans, dp, len);\n\t\tbreak;\n\tcase XLOG_WAS_CONT_TRANS:\n\t\terror = xlog_recover_add_to_cont_trans(log, trans, dp, len);\n\t\tbreak;\n\tcase XLOG_COMMIT_TRANS:\n\t\terror = xlog_recover_commit_trans(log, trans, pass,\n\t\t\t\t\t\t  buffer_list);\n\t\t \n\t\tfreeit = true;\n\t\tbreak;\n\n\t \n\tcase XLOG_UNMOUNT_TRANS:\n\t\t \n\t\txfs_warn(log->l_mp, \"%s: Unmount LR\", __func__);\n\t\tfreeit = true;\n\t\tbreak;\n\tcase XLOG_START_TRANS:\n\tdefault:\n\t\txfs_warn(log->l_mp, \"%s: bad flag 0x%x\", __func__, flags);\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tbreak;\n\t}\n\tif (error || freeit)\n\t\txlog_recover_free_trans(trans);\n\treturn error;\n}\n\n \nSTATIC struct xlog_recover *\nxlog_recover_ophdr_to_trans(\n\tstruct hlist_head\trhash[],\n\tstruct xlog_rec_header\t*rhead,\n\tstruct xlog_op_header\t*ohead)\n{\n\tstruct xlog_recover\t*trans;\n\txlog_tid_t\t\ttid;\n\tstruct hlist_head\t*rhp;\n\n\ttid = be32_to_cpu(ohead->oh_tid);\n\trhp = &rhash[XLOG_RHASH(tid)];\n\thlist_for_each_entry(trans, rhp, r_list) {\n\t\tif (trans->r_log_tid == tid)\n\t\t\treturn trans;\n\t}\n\n\t \n\tif (!(ohead->oh_flags & XLOG_START_TRANS))\n\t\treturn NULL;\n\n\tASSERT(be32_to_cpu(ohead->oh_len) == 0);\n\n\t \n\ttrans = kmem_zalloc(sizeof(struct xlog_recover), 0);\n\ttrans->r_log_tid = tid;\n\ttrans->r_lsn = be64_to_cpu(rhead->h_lsn);\n\tINIT_LIST_HEAD(&trans->r_itemq);\n\tINIT_HLIST_NODE(&trans->r_list);\n\thlist_add_head(&trans->r_list, rhp);\n\n\t \n\treturn NULL;\n}\n\nSTATIC int\nxlog_recover_process_ophdr(\n\tstruct xlog\t\t*log,\n\tstruct hlist_head\trhash[],\n\tstruct xlog_rec_header\t*rhead,\n\tstruct xlog_op_header\t*ohead,\n\tchar\t\t\t*dp,\n\tchar\t\t\t*end,\n\tint\t\t\tpass,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xlog_recover\t*trans;\n\tunsigned int\t\tlen;\n\tint\t\t\terror;\n\n\t \n\tif (ohead->oh_clientid != XFS_TRANSACTION &&\n\t    ohead->oh_clientid != XFS_LOG) {\n\t\txfs_warn(log->l_mp, \"%s: bad clientid 0x%x\",\n\t\t\t__func__, ohead->oh_clientid);\n\t\tASSERT(0);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\tlen = be32_to_cpu(ohead->oh_len);\n\tif (dp + len > end) {\n\t\txfs_warn(log->l_mp, \"%s: bad length 0x%x\", __func__, len);\n\t\tWARN_ON(1);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\ttrans = xlog_recover_ophdr_to_trans(rhash, rhead, ohead);\n\tif (!trans) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tif (log->l_recovery_lsn != trans->r_lsn &&\n\t    ohead->oh_flags & XLOG_COMMIT_TRANS) {\n\t\terror = xfs_buf_delwri_submit(buffer_list);\n\t\tif (error)\n\t\t\treturn error;\n\t\tlog->l_recovery_lsn = trans->r_lsn;\n\t}\n\n\treturn xlog_recovery_process_trans(log, trans, dp, len,\n\t\t\t\t\t   ohead->oh_flags, pass, buffer_list);\n}\n\n \nSTATIC int\nxlog_recover_process_data(\n\tstruct xlog\t\t*log,\n\tstruct hlist_head\trhash[],\n\tstruct xlog_rec_header\t*rhead,\n\tchar\t\t\t*dp,\n\tint\t\t\tpass,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xlog_op_header\t*ohead;\n\tchar\t\t\t*end;\n\tint\t\t\tnum_logops;\n\tint\t\t\terror;\n\n\tend = dp + be32_to_cpu(rhead->h_len);\n\tnum_logops = be32_to_cpu(rhead->h_num_logops);\n\n\t \n\tif (xlog_header_check_recover(log->l_mp, rhead))\n\t\treturn -EIO;\n\n\ttrace_xfs_log_recover_record(log, rhead, pass);\n\twhile ((dp < end) && num_logops) {\n\n\t\tohead = (struct xlog_op_header *)dp;\n\t\tdp += sizeof(*ohead);\n\t\tASSERT(dp <= end);\n\n\t\t \n\t\terror = xlog_recover_process_ophdr(log, rhash, rhead, ohead,\n\t\t\t\t\t\t   dp, end, pass, buffer_list);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdp += be32_to_cpu(ohead->oh_len);\n\t\tnum_logops--;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nxlog_finish_defer_ops(\n\tstruct xfs_mount\t*mp,\n\tstruct list_head\t*capture_list)\n{\n\tstruct xfs_defer_capture *dfc, *next;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror = 0;\n\n\tlist_for_each_entry_safe(dfc, next, capture_list, dfc_list) {\n\t\tstruct xfs_trans_res\tresv;\n\t\tstruct xfs_defer_resources dres;\n\n\t\t \n\t\tresv.tr_logres = dfc->dfc_logres;\n\t\tresv.tr_logcount = 1;\n\t\tresv.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\n\t\terror = xfs_trans_alloc(mp, &resv, dfc->dfc_blkres,\n\t\t\t\tdfc->dfc_rtxres, XFS_TRANS_RESERVE, &tp);\n\t\tif (error) {\n\t\t\txlog_force_shutdown(mp->m_log, SHUTDOWN_LOG_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\n\t\t \n\t\tlist_del_init(&dfc->dfc_list);\n\t\txfs_defer_ops_continue(dfc, tp, &dres);\n\t\terror = xfs_trans_commit(tp);\n\t\txfs_defer_resources_rele(&dres);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tASSERT(list_empty(capture_list));\n\treturn 0;\n}\n\n \nstatic void\nxlog_abort_defer_ops(\n\tstruct xfs_mount\t\t*mp,\n\tstruct list_head\t\t*capture_list)\n{\n\tstruct xfs_defer_capture\t*dfc;\n\tstruct xfs_defer_capture\t*next;\n\n\tlist_for_each_entry_safe(dfc, next, capture_list, dfc_list) {\n\t\tlist_del_init(&dfc->dfc_list);\n\t\txfs_defer_ops_capture_free(mp, dfc);\n\t}\n}\n\n \nSTATIC int\nxlog_recover_process_intents(\n\tstruct xlog\t\t*log)\n{\n\tLIST_HEAD(capture_list);\n\tstruct xfs_ail_cursor\tcur;\n\tstruct xfs_log_item\t*lip;\n\tstruct xfs_ail\t\t*ailp;\n\tint\t\t\terror = 0;\n#if defined(DEBUG) || defined(XFS_WARN)\n\txfs_lsn_t\t\tlast_lsn;\n#endif\n\n\tailp = log->l_ailp;\n\tspin_lock(&ailp->ail_lock);\n#if defined(DEBUG) || defined(XFS_WARN)\n\tlast_lsn = xlog_assign_lsn(log->l_curr_cycle, log->l_curr_block);\n#endif\n\tfor (lip = xfs_trans_ail_cursor_first(ailp, &cur, 0);\n\t     lip != NULL;\n\t     lip = xfs_trans_ail_cursor_next(ailp, &cur)) {\n\t\tconst struct xfs_item_ops\t*ops;\n\n\t\tif (!xlog_item_is_intent(lip))\n\t\t\tbreak;\n\n\t\t \n\t\tASSERT(XFS_LSN_CMP(last_lsn, lip->li_lsn) >= 0);\n\n\t\t \n\t\tspin_unlock(&ailp->ail_lock);\n\t\tops = lip->li_ops;\n\t\terror = ops->iop_recover(lip, &capture_list);\n\t\tspin_lock(&ailp->ail_lock);\n\t\tif (error) {\n\t\t\ttrace_xlog_intent_recovery_failed(log->l_mp, error,\n\t\t\t\t\tops->iop_recover);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->ail_lock);\n\tif (error)\n\t\tgoto err;\n\n\terror = xlog_finish_defer_ops(log->l_mp, &capture_list);\n\tif (error)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\txlog_abort_defer_ops(log->l_mp, &capture_list);\n\treturn error;\n}\n\n \nSTATIC void\nxlog_recover_cancel_intents(\n\tstruct xlog\t\t*log)\n{\n\tstruct xfs_log_item\t*lip;\n\tstruct xfs_ail_cursor\tcur;\n\tstruct xfs_ail\t\t*ailp;\n\n\tailp = log->l_ailp;\n\tspin_lock(&ailp->ail_lock);\n\tlip = xfs_trans_ail_cursor_first(ailp, &cur, 0);\n\twhile (lip != NULL) {\n\t\tif (!xlog_item_is_intent(lip))\n\t\t\tbreak;\n\n\t\tspin_unlock(&ailp->ail_lock);\n\t\tlip->li_ops->iop_release(lip);\n\t\tspin_lock(&ailp->ail_lock);\n\t\tlip = xfs_trans_ail_cursor_next(ailp, &cur);\n\t}\n\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->ail_lock);\n}\n\n \nSTATIC void\nxlog_recover_clear_agi_bucket(\n\tstruct xfs_perag\t*pag,\n\tint\t\t\tbucket)\n{\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_agi\t\t*agi;\n\tstruct xfs_buf\t\t*agibp;\n\tint\t\t\toffset;\n\tint\t\t\terror;\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_clearagi, 0, 0, 0, &tp);\n\tif (error)\n\t\tgoto out_error;\n\n\terror = xfs_read_agi(pag, tp, &agibp);\n\tif (error)\n\t\tgoto out_abort;\n\n\tagi = agibp->b_addr;\n\tagi->agi_unlinked[bucket] = cpu_to_be32(NULLAGINO);\n\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t (sizeof(xfs_agino_t) * bucket);\n\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\n\terror = xfs_trans_commit(tp);\n\tif (error)\n\t\tgoto out_error;\n\treturn;\n\nout_abort:\n\txfs_trans_cancel(tp);\nout_error:\n\txfs_warn(mp, \"%s: failed to clear agi %d. Continuing.\", __func__,\n\t\t\tpag->pag_agno);\n\treturn;\n}\n\nstatic int\nxlog_recover_iunlink_bucket(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_agi\t\t*agi,\n\tint\t\t\tbucket)\n{\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\tstruct xfs_inode\t*prev_ip = NULL;\n\tstruct xfs_inode\t*ip;\n\txfs_agino_t\t\tprev_agino, agino;\n\tint\t\t\terror = 0;\n\n\tagino = be32_to_cpu(agi->agi_unlinked[bucket]);\n\twhile (agino != NULLAGINO) {\n\t\terror = xfs_iget(mp, NULL,\n\t\t\t\tXFS_AGINO_TO_INO(mp, pag->pag_agno, agino),\n\t\t\t\t0, 0, &ip);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tASSERT(VFS_I(ip)->i_nlink == 0);\n\t\tASSERT(VFS_I(ip)->i_mode != 0);\n\t\txfs_iflags_clear(ip, XFS_IRECOVERY);\n\t\tagino = ip->i_next_unlinked;\n\n\t\tif (prev_ip) {\n\t\t\tip->i_prev_unlinked = prev_agino;\n\t\t\txfs_irele(prev_ip);\n\n\t\t\t \n\t\t\terror = xfs_inodegc_flush(mp);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tprev_agino = agino;\n\t\tprev_ip = ip;\n\t}\n\n\tif (prev_ip) {\n\t\tint\terror2;\n\n\t\tip->i_prev_unlinked = prev_agino;\n\t\txfs_irele(prev_ip);\n\n\t\terror2 = xfs_inodegc_flush(mp);\n\t\tif (error2 && !error)\n\t\t\treturn error2;\n\t}\n\treturn error;\n}\n\n \nstatic void\nxlog_recover_iunlink_ag(\n\tstruct xfs_perag\t*pag)\n{\n\tstruct xfs_agi\t\t*agi;\n\tstruct xfs_buf\t\t*agibp;\n\tint\t\t\tbucket;\n\tint\t\t\terror;\n\n\terror = xfs_read_agi(pag, NULL, &agibp);\n\tif (error) {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tagi = agibp->b_addr;\n\txfs_buf_unlock(agibp);\n\n\tfor (bucket = 0; bucket < XFS_AGI_UNLINKED_BUCKETS; bucket++) {\n\t\terror = xlog_recover_iunlink_bucket(pag, agi, bucket);\n\t\tif (error) {\n\t\t\t \n\t\t\txlog_recover_clear_agi_bucket(pag, bucket);\n\t\t}\n\t}\n\n\txfs_buf_rele(agibp);\n}\n\nstatic void\nxlog_recover_process_iunlinks(\n\tstruct xlog\t*log)\n{\n\tstruct xfs_perag\t*pag;\n\txfs_agnumber_t\t\tagno;\n\n\tfor_each_perag(log->l_mp, agno, pag)\n\t\txlog_recover_iunlink_ag(pag);\n}\n\nSTATIC void\nxlog_unpack_data(\n\tstruct xlog_rec_header\t*rhead,\n\tchar\t\t\t*dp,\n\tstruct xlog\t\t*log)\n{\n\tint\t\t\ti, j, k;\n\n\tfor (i = 0; i < BTOBB(be32_to_cpu(rhead->h_len)) &&\n\t\t  i < (XLOG_HEADER_CYCLE_SIZE / BBSIZE); i++) {\n\t\t*(__be32 *)dp = *(__be32 *)&rhead->h_cycle_data[i];\n\t\tdp += BBSIZE;\n\t}\n\n\tif (xfs_has_logv2(log->l_mp)) {\n\t\txlog_in_core_2_t *xhdr = (xlog_in_core_2_t *)rhead;\n\t\tfor ( ; i < BTOBB(be32_to_cpu(rhead->h_len)); i++) {\n\t\t\tj = i / (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\tk = i % (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t*(__be32 *)dp = xhdr[j].hic_xheader.xh_cycle_data[k];\n\t\t\tdp += BBSIZE;\n\t\t}\n\t}\n}\n\n \nSTATIC int\nxlog_recover_process(\n\tstruct xlog\t\t*log,\n\tstruct hlist_head\trhash[],\n\tstruct xlog_rec_header\t*rhead,\n\tchar\t\t\t*dp,\n\tint\t\t\tpass,\n\tstruct list_head\t*buffer_list)\n{\n\t__le32\t\t\told_crc = rhead->h_crc;\n\t__le32\t\t\tcrc;\n\n\tcrc = xlog_cksum(log, rhead, dp, be32_to_cpu(rhead->h_len));\n\n\t \n\tif (pass == XLOG_RECOVER_CRCPASS) {\n\t\tif (old_crc && crc != old_crc)\n\t\t\treturn -EFSBADCRC;\n\t\treturn 0;\n\t}\n\n\t \n\tif (crc != old_crc) {\n\t\tif (old_crc || xfs_has_crc(log->l_mp)) {\n\t\t\txfs_alert(log->l_mp,\n\t\t\"log record CRC mismatch: found 0x%x, expected 0x%x.\",\n\t\t\t\t\tle32_to_cpu(old_crc),\n\t\t\t\t\tle32_to_cpu(crc));\n\t\t\txfs_hex_dump(dp, 32);\n\t\t}\n\n\t\t \n\t\tif (xfs_has_crc(log->l_mp)) {\n\t\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, log->l_mp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\txlog_unpack_data(rhead, dp, log);\n\n\treturn xlog_recover_process_data(log, rhash, rhead, dp, pass,\n\t\t\t\t\t buffer_list);\n}\n\nSTATIC int\nxlog_valid_rec_header(\n\tstruct xlog\t\t*log,\n\tstruct xlog_rec_header\t*rhead,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tbufsize)\n{\n\tint\t\t\thlen;\n\n\tif (XFS_IS_CORRUPT(log->l_mp,\n\t\t\t   rhead->h_magicno != cpu_to_be32(XLOG_HEADER_MAGIC_NUM)))\n\t\treturn -EFSCORRUPTED;\n\tif (XFS_IS_CORRUPT(log->l_mp,\n\t\t\t   (!rhead->h_version ||\n\t\t\t   (be32_to_cpu(rhead->h_version) &\n\t\t\t    (~XLOG_VERSION_OKBITS))))) {\n\t\txfs_warn(log->l_mp, \"%s: unrecognised log version (%d).\",\n\t\t\t__func__, be32_to_cpu(rhead->h_version));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\thlen = be32_to_cpu(rhead->h_len);\n\tif (XFS_IS_CORRUPT(log->l_mp, hlen <= 0 || hlen > bufsize))\n\t\treturn -EFSCORRUPTED;\n\n\tif (XFS_IS_CORRUPT(log->l_mp,\n\t\t\t   blkno > log->l_logBBsize || blkno > INT_MAX))\n\t\treturn -EFSCORRUPTED;\n\treturn 0;\n}\n\n \nSTATIC int\nxlog_do_recovery_pass(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\thead_blk,\n\txfs_daddr_t\t\ttail_blk,\n\tint\t\t\tpass,\n\txfs_daddr_t\t\t*first_bad)\t \n{\n\txlog_rec_header_t\t*rhead;\n\txfs_daddr_t\t\tblk_no, rblk_no;\n\txfs_daddr_t\t\trhead_blk;\n\tchar\t\t\t*offset;\n\tchar\t\t\t*hbp, *dbp;\n\tint\t\t\terror = 0, h_size, h_len;\n\tint\t\t\terror2 = 0;\n\tint\t\t\tbblks, split_bblks;\n\tint\t\t\thblks, split_hblks, wrapped_hblks;\n\tint\t\t\ti;\n\tstruct hlist_head\trhash[XLOG_RHASH_SIZE];\n\tLIST_HEAD\t\t(buffer_list);\n\n\tASSERT(head_blk != tail_blk);\n\tblk_no = rhead_blk = tail_blk;\n\n\tfor (i = 0; i < XLOG_RHASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&rhash[i]);\n\n\t \n\tif (xfs_has_logv2(log->l_mp)) {\n\t\t \n\t\thbp = xlog_alloc_buffer(log, 1);\n\t\tif (!hbp)\n\t\t\treturn -ENOMEM;\n\n\t\terror = xlog_bread(log, tail_blk, 1, hbp, &offset);\n\t\tif (error)\n\t\t\tgoto bread_err1;\n\n\t\trhead = (xlog_rec_header_t *)offset;\n\n\t\t \n\t\th_size = be32_to_cpu(rhead->h_size);\n\t\th_len = be32_to_cpu(rhead->h_len);\n\t\tif (h_len > h_size && h_len <= log->l_mp->m_logbsize &&\n\t\t    rhead->h_num_logops == cpu_to_be32(1)) {\n\t\t\txfs_warn(log->l_mp,\n\t\t\"invalid iclog size (%d bytes), using lsunit (%d bytes)\",\n\t\t\t\t h_size, log->l_mp->m_logbsize);\n\t\t\th_size = log->l_mp->m_logbsize;\n\t\t}\n\n\t\terror = xlog_valid_rec_header(log, rhead, tail_blk, h_size);\n\t\tif (error)\n\t\t\tgoto bread_err1;\n\n\t\thblks = xlog_logrec_hblks(log, rhead);\n\t\tif (hblks != 1) {\n\t\t\tkmem_free(hbp);\n\t\t\thbp = xlog_alloc_buffer(log, hblks);\n\t\t}\n\t} else {\n\t\tASSERT(log->l_sectBBsize == 1);\n\t\thblks = 1;\n\t\thbp = xlog_alloc_buffer(log, 1);\n\t\th_size = XLOG_BIG_RECORD_BSIZE;\n\t}\n\n\tif (!hbp)\n\t\treturn -ENOMEM;\n\tdbp = xlog_alloc_buffer(log, BTOBB(h_size));\n\tif (!dbp) {\n\t\tkmem_free(hbp);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(rhash, 0, sizeof(rhash));\n\tif (tail_blk > head_blk) {\n\t\t \n\t\twhile (blk_no < log->l_logBBsize) {\n\t\t\t \n\t\t\toffset = hbp;\n\t\t\tsplit_hblks = 0;\n\t\t\twrapped_hblks = 0;\n\t\t\tif (blk_no + hblks <= log->l_logBBsize) {\n\t\t\t\t \n\t\t\t\terror = xlog_bread(log, blk_no, hblks, hbp,\n\t\t\t\t\t\t   &offset);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (blk_no != log->l_logBBsize) {\n\t\t\t\t\t \n\t\t\t\t\tASSERT(blk_no <= INT_MAX);\n\t\t\t\t\tsplit_hblks = log->l_logBBsize - (int)blk_no;\n\t\t\t\t\tASSERT(split_hblks > 0);\n\t\t\t\t\terror = xlog_bread(log, blk_no,\n\t\t\t\t\t\t\t   split_hblks, hbp,\n\t\t\t\t\t\t\t   &offset);\n\t\t\t\t\tif (error)\n\t\t\t\t\t\tgoto bread_err2;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\twrapped_hblks = hblks - split_hblks;\n\t\t\t\terror = xlog_bread_noalign(log, 0,\n\t\t\t\t\t\twrapped_hblks,\n\t\t\t\t\t\toffset + BBTOB(split_hblks));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t}\n\t\t\trhead = (xlog_rec_header_t *)offset;\n\t\t\terror = xlog_valid_rec_header(log, rhead,\n\t\t\t\t\tsplit_hblks ? blk_no : 0, h_size);\n\t\t\tif (error)\n\t\t\t\tgoto bread_err2;\n\n\t\t\tbblks = (int)BTOBB(be32_to_cpu(rhead->h_len));\n\t\t\tblk_no += hblks;\n\n\t\t\t \n\t\t\tif (blk_no + bblks <= log->l_logBBsize ||\n\t\t\t    blk_no >= log->l_logBBsize) {\n\t\t\t\trblk_no = xlog_wrap_logbno(log, blk_no);\n\t\t\t\terror = xlog_bread(log, rblk_no, bblks, dbp,\n\t\t\t\t\t\t   &offset);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\toffset = dbp;\n\t\t\t\tsplit_bblks = 0;\n\t\t\t\tif (blk_no != log->l_logBBsize) {\n\t\t\t\t\t \n\t\t\t\t\tASSERT(!wrapped_hblks);\n\t\t\t\t\tASSERT(blk_no <= INT_MAX);\n\t\t\t\t\tsplit_bblks =\n\t\t\t\t\t\tlog->l_logBBsize - (int)blk_no;\n\t\t\t\t\tASSERT(split_bblks > 0);\n\t\t\t\t\terror = xlog_bread(log, blk_no,\n\t\t\t\t\t\t\tsplit_bblks, dbp,\n\t\t\t\t\t\t\t&offset);\n\t\t\t\t\tif (error)\n\t\t\t\t\t\tgoto bread_err2;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\terror = xlog_bread_noalign(log, 0,\n\t\t\t\t\t\tbblks - split_bblks,\n\t\t\t\t\t\toffset + BBTOB(split_bblks));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto bread_err2;\n\t\t\t}\n\n\t\t\terror = xlog_recover_process(log, rhash, rhead, offset,\n\t\t\t\t\t\t     pass, &buffer_list);\n\t\t\tif (error)\n\t\t\t\tgoto bread_err2;\n\n\t\t\tblk_no += bblks;\n\t\t\trhead_blk = blk_no;\n\t\t}\n\n\t\tASSERT(blk_no >= log->l_logBBsize);\n\t\tblk_no -= log->l_logBBsize;\n\t\trhead_blk = blk_no;\n\t}\n\n\t \n\twhile (blk_no < head_blk) {\n\t\terror = xlog_bread(log, blk_no, hblks, hbp, &offset);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\trhead = (xlog_rec_header_t *)offset;\n\t\terror = xlog_valid_rec_header(log, rhead, blk_no, h_size);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\t \n\t\tbblks = (int)BTOBB(be32_to_cpu(rhead->h_len));\n\t\terror = xlog_bread(log, blk_no+hblks, bblks, dbp,\n\t\t\t\t   &offset);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\terror = xlog_recover_process(log, rhash, rhead, offset, pass,\n\t\t\t\t\t     &buffer_list);\n\t\tif (error)\n\t\t\tgoto bread_err2;\n\n\t\tblk_no += bblks + hblks;\n\t\trhead_blk = blk_no;\n\t}\n\n bread_err2:\n\tkmem_free(dbp);\n bread_err1:\n\tkmem_free(hbp);\n\n\t \n\tif (!list_empty(&buffer_list))\n\t\terror2 = xfs_buf_delwri_submit(&buffer_list);\n\n\tif (error && first_bad)\n\t\t*first_bad = rhead_blk;\n\n\t \n\tfor (i = 0; i < XLOG_RHASH_SIZE; i++) {\n\t\tstruct hlist_node\t*tmp;\n\t\tstruct xlog_recover\t*trans;\n\n\t\thlist_for_each_entry_safe(trans, tmp, &rhash[i], r_list)\n\t\t\txlog_recover_free_trans(trans);\n\t}\n\n\treturn error ? error : error2;\n}\n\n \nSTATIC int\nxlog_do_log_recovery(\n\tstruct xlog\t*log,\n\txfs_daddr_t\thead_blk,\n\txfs_daddr_t\ttail_blk)\n{\n\tint\t\terror;\n\n\tASSERT(head_blk != tail_blk);\n\n\t \n\terror = xlog_alloc_buf_cancel_table(log);\n\tif (error)\n\t\treturn error;\n\n\terror = xlog_do_recovery_pass(log, head_blk, tail_blk,\n\t\t\t\t      XLOG_RECOVER_PASS1, NULL);\n\tif (error != 0)\n\t\tgoto out_cancel;\n\n\t \n\terror = xlog_do_recovery_pass(log, head_blk, tail_blk,\n\t\t\t\t      XLOG_RECOVER_PASS2, NULL);\n\tif (!error)\n\t\txlog_check_buf_cancel_table(log);\nout_cancel:\n\txlog_free_buf_cancel_table(log);\n\treturn error;\n}\n\n \nSTATIC int\nxlog_do_recover(\n\tstruct xlog\t\t*log,\n\txfs_daddr_t\t\thead_blk,\n\txfs_daddr_t\t\ttail_blk)\n{\n\tstruct xfs_mount\t*mp = log->l_mp;\n\tstruct xfs_buf\t\t*bp = mp->m_sb_bp;\n\tstruct xfs_sb\t\t*sbp = &mp->m_sb;\n\tint\t\t\terror;\n\n\ttrace_xfs_log_recover(log, head_blk, tail_blk);\n\n\t \n\terror = xlog_do_log_recovery(log, head_blk, tail_blk);\n\tif (error)\n\t\treturn error;\n\n\tif (xlog_is_shutdown(log))\n\t\treturn -EIO;\n\n\t \n\txlog_assign_tail_lsn(mp);\n\n\t \n\txfs_buf_lock(bp);\n\txfs_buf_hold(bp);\n\terror = _xfs_buf_read(bp, XBF_READ);\n\tif (error) {\n\t\tif (!xlog_is_shutdown(log)) {\n\t\t\txfs_buf_ioerror_alert(bp, __this_address);\n\t\t\tASSERT(0);\n\t\t}\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t \n\txfs_sb_from_disk(sbp, bp->b_addr);\n\txfs_buf_relse(bp);\n\n\t \n\tmp->m_features |= xfs_sb_version_to_features(sbp);\n\txfs_reinit_percpu_counters(mp);\n\terror = xfs_initialize_perag(mp, sbp->sb_agcount, sbp->sb_dblocks,\n\t\t\t&mp->m_maxagi);\n\tif (error) {\n\t\txfs_warn(mp, \"Failed post-recovery per-ag init: %d\", error);\n\t\treturn error;\n\t}\n\tmp->m_alloc_set_aside = xfs_alloc_set_aside(mp);\n\n\t \n\tclear_bit(XLOG_ACTIVE_RECOVERY, &log->l_opstate);\n\treturn 0;\n}\n\n \nint\nxlog_recover(\n\tstruct xlog\t*log)\n{\n\txfs_daddr_t\thead_blk, tail_blk;\n\tint\t\terror;\n\n\t \n\terror = xlog_find_tail(log, &head_blk, &tail_blk);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (xfs_has_crc(log->l_mp) &&\n\t    !xfs_log_check_lsn(log->l_mp, log->l_mp->m_sb.sb_lsn))\n\t\treturn -EINVAL;\n\n\tif (tail_blk != head_blk) {\n\t\t \n\t\tif ((error = xfs_dev_is_read_only(log->l_mp, \"recovery\"))) {\n\t\t\treturn error;\n\t\t}\n\n\t\t \n\t\tif (xfs_sb_is_v5(&log->l_mp->m_sb) &&\n\t\t    xfs_sb_has_incompat_log_feature(&log->l_mp->m_sb,\n\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_LOG_UNKNOWN)) {\n\t\t\txfs_warn(log->l_mp,\n\"Superblock has unknown incompatible log features (0x%x) enabled.\",\n\t\t\t\t(log->l_mp->m_sb.sb_features_log_incompat &\n\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_LOG_UNKNOWN));\n\t\t\txfs_warn(log->l_mp,\n\"The log can not be fully and/or safely recovered by this kernel.\");\n\t\t\txfs_warn(log->l_mp,\n\"Please recover the log on a kernel that supports the unknown features.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (xfs_globals.log_recovery_delay) {\n\t\t\txfs_notice(log->l_mp,\n\t\t\t\t\"Delaying log recovery for %d seconds.\",\n\t\t\t\txfs_globals.log_recovery_delay);\n\t\t\tmsleep(xfs_globals.log_recovery_delay * 1000);\n\t\t}\n\n\t\txfs_notice(log->l_mp, \"Starting recovery (logdev: %s)\",\n\t\t\t\tlog->l_mp->m_logname ? log->l_mp->m_logname\n\t\t\t\t\t\t     : \"internal\");\n\n\t\terror = xlog_do_recover(log, head_blk, tail_blk);\n\t\tset_bit(XLOG_RECOVERY_NEEDED, &log->l_opstate);\n\t}\n\treturn error;\n}\n\n \nint\nxlog_recover_finish(\n\tstruct xlog\t*log)\n{\n\tint\terror;\n\n\terror = xlog_recover_process_intents(log);\n\tif (error) {\n\t\t \n\t\txlog_recover_cancel_intents(log);\n\t\txfs_alert(log->l_mp, \"Failed to recover intents\");\n\t\txlog_force_shutdown(log, SHUTDOWN_LOG_IO_ERROR);\n\t\treturn error;\n\t}\n\n\t \n\txfs_log_force(log->l_mp, XFS_LOG_SYNC);\n\n\t \n\tif (xfs_clear_incompat_log_features(log->l_mp)) {\n\t\terror = xfs_sync_sb(log->l_mp, false);\n\t\tif (error < 0) {\n\t\t\txfs_alert(log->l_mp,\n\t\"Failed to clear log incompat features on recovery\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\txlog_recover_process_iunlinks(log);\n\n\t \n\terror = xfs_reflink_recover_cow(log->l_mp);\n\tif (error) {\n\t\txfs_alert(log->l_mp,\n\t\"Failed to recover leftover CoW staging extents, err %d.\",\n\t\t\t\terror);\n\t\t \n\t\txlog_force_shutdown(log, SHUTDOWN_LOG_IO_ERROR);\n\t}\n\n\treturn 0;\n}\n\nvoid\nxlog_recover_cancel(\n\tstruct xlog\t*log)\n{\n\tif (xlog_recovery_needed(log))\n\t\txlog_recover_cancel_intents(log);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}