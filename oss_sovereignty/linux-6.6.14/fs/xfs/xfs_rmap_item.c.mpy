{
  "module_name": "xfs_rmap_item.c",
  "hash_id": "22b3ad1627d22710c1fade8b6f74e245173707f72e663c0d435b058d6f7c53e9",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_rmap_item.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_rmap_item.h\"\n#include \"xfs_log.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_ag.h\"\n\nstruct kmem_cache\t*xfs_rui_cache;\nstruct kmem_cache\t*xfs_rud_cache;\n\nstatic const struct xfs_item_ops xfs_rui_item_ops;\n\nstatic inline struct xfs_rui_log_item *RUI_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_rui_log_item, rui_item);\n}\n\nSTATIC void\nxfs_rui_item_free(\n\tstruct xfs_rui_log_item\t*ruip)\n{\n\tkmem_free(ruip->rui_item.li_lv_shadow);\n\tif (ruip->rui_format.rui_nextents > XFS_RUI_MAX_FAST_EXTENTS)\n\t\tkmem_free(ruip);\n\telse\n\t\tkmem_cache_free(xfs_rui_cache, ruip);\n}\n\n \nSTATIC void\nxfs_rui_release(\n\tstruct xfs_rui_log_item\t*ruip)\n{\n\tASSERT(atomic_read(&ruip->rui_refcount) > 0);\n\tif (!atomic_dec_and_test(&ruip->rui_refcount))\n\t\treturn;\n\n\txfs_trans_ail_delete(&ruip->rui_item, 0);\n\txfs_rui_item_free(ruip);\n}\n\nSTATIC void\nxfs_rui_item_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_rui_log_item\t*ruip = RUI_ITEM(lip);\n\n\t*nvecs += 1;\n\t*nbytes += xfs_rui_log_format_sizeof(ruip->rui_format.rui_nextents);\n}\n\n \nSTATIC void\nxfs_rui_item_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_rui_log_item\t*ruip = RUI_ITEM(lip);\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\n\tASSERT(atomic_read(&ruip->rui_next_extent) ==\n\t\t\truip->rui_format.rui_nextents);\n\n\truip->rui_format.rui_type = XFS_LI_RUI;\n\truip->rui_format.rui_size = 1;\n\n\txlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_RUI_FORMAT, &ruip->rui_format,\n\t\t\txfs_rui_log_format_sizeof(ruip->rui_format.rui_nextents));\n}\n\n \nSTATIC void\nxfs_rui_item_unpin(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\tremove)\n{\n\tstruct xfs_rui_log_item\t*ruip = RUI_ITEM(lip);\n\n\txfs_rui_release(ruip);\n}\n\n \nSTATIC void\nxfs_rui_item_release(\n\tstruct xfs_log_item\t*lip)\n{\n\txfs_rui_release(RUI_ITEM(lip));\n}\n\n \nSTATIC struct xfs_rui_log_item *\nxfs_rui_init(\n\tstruct xfs_mount\t\t*mp,\n\tuint\t\t\t\tnextents)\n\n{\n\tstruct xfs_rui_log_item\t\t*ruip;\n\n\tASSERT(nextents > 0);\n\tif (nextents > XFS_RUI_MAX_FAST_EXTENTS)\n\t\truip = kmem_zalloc(xfs_rui_log_item_sizeof(nextents), 0);\n\telse\n\t\truip = kmem_cache_zalloc(xfs_rui_cache,\n\t\t\t\t\t GFP_KERNEL | __GFP_NOFAIL);\n\n\txfs_log_item_init(mp, &ruip->rui_item, XFS_LI_RUI, &xfs_rui_item_ops);\n\truip->rui_format.rui_nextents = nextents;\n\truip->rui_format.rui_id = (uintptr_t)(void *)ruip;\n\tatomic_set(&ruip->rui_next_extent, 0);\n\tatomic_set(&ruip->rui_refcount, 2);\n\n\treturn ruip;\n}\n\nstatic inline struct xfs_rud_log_item *RUD_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_rud_log_item, rud_item);\n}\n\nSTATIC void\nxfs_rud_item_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\t*nvecs += 1;\n\t*nbytes += sizeof(struct xfs_rud_log_format);\n}\n\n \nSTATIC void\nxfs_rud_item_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_rud_log_item\t*rudp = RUD_ITEM(lip);\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\n\trudp->rud_format.rud_type = XFS_LI_RUD;\n\trudp->rud_format.rud_size = 1;\n\n\txlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_RUD_FORMAT, &rudp->rud_format,\n\t\t\tsizeof(struct xfs_rud_log_format));\n}\n\n \nSTATIC void\nxfs_rud_item_release(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_rud_log_item\t*rudp = RUD_ITEM(lip);\n\n\txfs_rui_release(rudp->rud_ruip);\n\tkmem_free(rudp->rud_item.li_lv_shadow);\n\tkmem_cache_free(xfs_rud_cache, rudp);\n}\n\nstatic struct xfs_log_item *\nxfs_rud_item_intent(\n\tstruct xfs_log_item\t*lip)\n{\n\treturn &RUD_ITEM(lip)->rud_ruip->rui_item;\n}\n\nstatic const struct xfs_item_ops xfs_rud_item_ops = {\n\t.flags\t\t= XFS_ITEM_RELEASE_WHEN_COMMITTED |\n\t\t\t  XFS_ITEM_INTENT_DONE,\n\t.iop_size\t= xfs_rud_item_size,\n\t.iop_format\t= xfs_rud_item_format,\n\t.iop_release\t= xfs_rud_item_release,\n\t.iop_intent\t= xfs_rud_item_intent,\n};\n\nstatic struct xfs_rud_log_item *\nxfs_trans_get_rud(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_rui_log_item\t\t*ruip)\n{\n\tstruct xfs_rud_log_item\t\t*rudp;\n\n\trudp = kmem_cache_zalloc(xfs_rud_cache, GFP_KERNEL | __GFP_NOFAIL);\n\txfs_log_item_init(tp->t_mountp, &rudp->rud_item, XFS_LI_RUD,\n\t\t\t  &xfs_rud_item_ops);\n\trudp->rud_ruip = ruip;\n\trudp->rud_format.rud_rui_id = ruip->rui_format.rui_id;\n\n\txfs_trans_add_item(tp, &rudp->rud_item);\n\treturn rudp;\n}\n\n \nstatic void\nxfs_trans_set_rmap_flags(\n\tstruct xfs_map_extent\t\t*map,\n\tenum xfs_rmap_intent_type\ttype,\n\tint\t\t\t\twhichfork,\n\txfs_exntst_t\t\t\tstate)\n{\n\tmap->me_flags = 0;\n\tif (state == XFS_EXT_UNWRITTEN)\n\t\tmap->me_flags |= XFS_RMAP_EXTENT_UNWRITTEN;\n\tif (whichfork == XFS_ATTR_FORK)\n\t\tmap->me_flags |= XFS_RMAP_EXTENT_ATTR_FORK;\n\tswitch (type) {\n\tcase XFS_RMAP_MAP:\n\t\tmap->me_flags |= XFS_RMAP_EXTENT_MAP;\n\t\tbreak;\n\tcase XFS_RMAP_MAP_SHARED:\n\t\tmap->me_flags |= XFS_RMAP_EXTENT_MAP_SHARED;\n\t\tbreak;\n\tcase XFS_RMAP_UNMAP:\n\t\tmap->me_flags |= XFS_RMAP_EXTENT_UNMAP;\n\t\tbreak;\n\tcase XFS_RMAP_UNMAP_SHARED:\n\t\tmap->me_flags |= XFS_RMAP_EXTENT_UNMAP_SHARED;\n\t\tbreak;\n\tcase XFS_RMAP_CONVERT:\n\t\tmap->me_flags |= XFS_RMAP_EXTENT_CONVERT;\n\t\tbreak;\n\tcase XFS_RMAP_CONVERT_SHARED:\n\t\tmap->me_flags |= XFS_RMAP_EXTENT_CONVERT_SHARED;\n\t\tbreak;\n\tcase XFS_RMAP_ALLOC:\n\t\tmap->me_flags |= XFS_RMAP_EXTENT_ALLOC;\n\t\tbreak;\n\tcase XFS_RMAP_FREE:\n\t\tmap->me_flags |= XFS_RMAP_EXTENT_FREE;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n}\n\n \nstatic int\nxfs_trans_log_finish_rmap_update(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_rud_log_item\t\t*rudp,\n\tstruct xfs_rmap_intent\t\t*ri,\n\tstruct xfs_btree_cur\t\t**pcur)\n{\n\tint\t\t\t\terror;\n\n\terror = xfs_rmap_finish_one(tp, ri, pcur);\n\n\t \n\ttp->t_flags |= XFS_TRANS_DIRTY | XFS_TRANS_HAS_INTENT_DONE;\n\tset_bit(XFS_LI_DIRTY, &rudp->rud_item.li_flags);\n\n\treturn error;\n}\n\n \nstatic int\nxfs_rmap_update_diff_items(\n\tvoid\t\t\t\t*priv,\n\tconst struct list_head\t\t*a,\n\tconst struct list_head\t\t*b)\n{\n\tstruct xfs_rmap_intent\t\t*ra;\n\tstruct xfs_rmap_intent\t\t*rb;\n\n\tra = container_of(a, struct xfs_rmap_intent, ri_list);\n\trb = container_of(b, struct xfs_rmap_intent, ri_list);\n\n\treturn ra->ri_pag->pag_agno - rb->ri_pag->pag_agno;\n}\n\n \nSTATIC void\nxfs_rmap_update_log_item(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_rui_log_item\t\t*ruip,\n\tstruct xfs_rmap_intent\t\t*ri)\n{\n\tuint\t\t\t\tnext_extent;\n\tstruct xfs_map_extent\t\t*map;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tset_bit(XFS_LI_DIRTY, &ruip->rui_item.li_flags);\n\n\t \n\tnext_extent = atomic_inc_return(&ruip->rui_next_extent) - 1;\n\tASSERT(next_extent < ruip->rui_format.rui_nextents);\n\tmap = &ruip->rui_format.rui_extents[next_extent];\n\tmap->me_owner = ri->ri_owner;\n\tmap->me_startblock = ri->ri_bmap.br_startblock;\n\tmap->me_startoff = ri->ri_bmap.br_startoff;\n\tmap->me_len = ri->ri_bmap.br_blockcount;\n\txfs_trans_set_rmap_flags(map, ri->ri_type, ri->ri_whichfork,\n\t\t\tri->ri_bmap.br_state);\n}\n\nstatic struct xfs_log_item *\nxfs_rmap_update_create_intent(\n\tstruct xfs_trans\t\t*tp,\n\tstruct list_head\t\t*items,\n\tunsigned int\t\t\tcount,\n\tbool\t\t\t\tsort)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_rui_log_item\t\t*ruip = xfs_rui_init(mp, count);\n\tstruct xfs_rmap_intent\t\t*ri;\n\n\tASSERT(count > 0);\n\n\txfs_trans_add_item(tp, &ruip->rui_item);\n\tif (sort)\n\t\tlist_sort(mp, items, xfs_rmap_update_diff_items);\n\tlist_for_each_entry(ri, items, ri_list)\n\t\txfs_rmap_update_log_item(tp, ruip, ri);\n\treturn &ruip->rui_item;\n}\n\n \nstatic struct xfs_log_item *\nxfs_rmap_update_create_done(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_log_item\t\t*intent,\n\tunsigned int\t\t\tcount)\n{\n\treturn &xfs_trans_get_rud(tp, RUI_ITEM(intent))->rud_item;\n}\n\n \nvoid\nxfs_rmap_update_get_group(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_rmap_intent\t*ri)\n{\n\txfs_agnumber_t\t\tagno;\n\n\tagno = XFS_FSB_TO_AGNO(mp, ri->ri_bmap.br_startblock);\n\tri->ri_pag = xfs_perag_intent_get(mp, agno);\n}\n\n \nstatic inline void\nxfs_rmap_update_put_group(\n\tstruct xfs_rmap_intent\t*ri)\n{\n\txfs_perag_intent_put(ri->ri_pag);\n}\n\n \nSTATIC int\nxfs_rmap_update_finish_item(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_log_item\t\t*done,\n\tstruct list_head\t\t*item,\n\tstruct xfs_btree_cur\t\t**state)\n{\n\tstruct xfs_rmap_intent\t\t*ri;\n\tint\t\t\t\terror;\n\n\tri = container_of(item, struct xfs_rmap_intent, ri_list);\n\n\terror = xfs_trans_log_finish_rmap_update(tp, RUD_ITEM(done), ri,\n\t\t\tstate);\n\n\txfs_rmap_update_put_group(ri);\n\tkmem_cache_free(xfs_rmap_intent_cache, ri);\n\treturn error;\n}\n\n \nSTATIC void\nxfs_rmap_update_abort_intent(\n\tstruct xfs_log_item\t*intent)\n{\n\txfs_rui_release(RUI_ITEM(intent));\n}\n\n \nSTATIC void\nxfs_rmap_update_cancel_item(\n\tstruct list_head\t\t*item)\n{\n\tstruct xfs_rmap_intent\t\t*ri;\n\n\tri = container_of(item, struct xfs_rmap_intent, ri_list);\n\n\txfs_rmap_update_put_group(ri);\n\tkmem_cache_free(xfs_rmap_intent_cache, ri);\n}\n\nconst struct xfs_defer_op_type xfs_rmap_update_defer_type = {\n\t.max_items\t= XFS_RUI_MAX_FAST_EXTENTS,\n\t.create_intent\t= xfs_rmap_update_create_intent,\n\t.abort_intent\t= xfs_rmap_update_abort_intent,\n\t.create_done\t= xfs_rmap_update_create_done,\n\t.finish_item\t= xfs_rmap_update_finish_item,\n\t.finish_cleanup = xfs_rmap_finish_one_cleanup,\n\t.cancel_item\t= xfs_rmap_update_cancel_item,\n};\n\n \nstatic inline bool\nxfs_rui_validate_map(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_map_extent\t\t*map)\n{\n\tif (!xfs_has_rmapbt(mp))\n\t\treturn false;\n\n\tif (map->me_flags & ~XFS_RMAP_EXTENT_FLAGS)\n\t\treturn false;\n\n\tswitch (map->me_flags & XFS_RMAP_EXTENT_TYPE_MASK) {\n\tcase XFS_RMAP_EXTENT_MAP:\n\tcase XFS_RMAP_EXTENT_MAP_SHARED:\n\tcase XFS_RMAP_EXTENT_UNMAP:\n\tcase XFS_RMAP_EXTENT_UNMAP_SHARED:\n\tcase XFS_RMAP_EXTENT_CONVERT:\n\tcase XFS_RMAP_EXTENT_CONVERT_SHARED:\n\tcase XFS_RMAP_EXTENT_ALLOC:\n\tcase XFS_RMAP_EXTENT_FREE:\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (!XFS_RMAP_NON_INODE_OWNER(map->me_owner) &&\n\t    !xfs_verify_ino(mp, map->me_owner))\n\t\treturn false;\n\n\tif (!xfs_verify_fileext(mp, map->me_startoff, map->me_len))\n\t\treturn false;\n\n\treturn xfs_verify_fsbext(mp, map->me_startblock, map->me_len);\n}\n\n \nSTATIC int\nxfs_rui_item_recover(\n\tstruct xfs_log_item\t\t*lip,\n\tstruct list_head\t\t*capture_list)\n{\n\tstruct xfs_trans_res\t\tresv;\n\tstruct xfs_rui_log_item\t\t*ruip = RUI_ITEM(lip);\n\tstruct xfs_rud_log_item\t\t*rudp;\n\tstruct xfs_trans\t\t*tp;\n\tstruct xfs_btree_cur\t\t*rcur = NULL;\n\tstruct xfs_mount\t\t*mp = lip->li_log->l_mp;\n\tint\t\t\t\ti;\n\tint\t\t\t\terror = 0;\n\n\t \n\tfor (i = 0; i < ruip->rui_format.rui_nextents; i++) {\n\t\tif (!xfs_rui_validate_map(mp,\n\t\t\t\t\t&ruip->rui_format.rui_extents[i])) {\n\t\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\t\t&ruip->rui_format,\n\t\t\t\t\tsizeof(ruip->rui_format));\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\tresv = xlog_recover_resv(&M_RES(mp)->tr_itruncate);\n\terror = xfs_trans_alloc(mp, &resv, mp->m_rmap_maxlevels, 0,\n\t\t\tXFS_TRANS_RESERVE, &tp);\n\tif (error)\n\t\treturn error;\n\trudp = xfs_trans_get_rud(tp, ruip);\n\n\tfor (i = 0; i < ruip->rui_format.rui_nextents; i++) {\n\t\tstruct xfs_rmap_intent\tfake = { };\n\t\tstruct xfs_map_extent\t*map;\n\n\t\tmap = &ruip->rui_format.rui_extents[i];\n\t\tswitch (map->me_flags & XFS_RMAP_EXTENT_TYPE_MASK) {\n\t\tcase XFS_RMAP_EXTENT_MAP:\n\t\t\tfake.ri_type = XFS_RMAP_MAP;\n\t\t\tbreak;\n\t\tcase XFS_RMAP_EXTENT_MAP_SHARED:\n\t\t\tfake.ri_type = XFS_RMAP_MAP_SHARED;\n\t\t\tbreak;\n\t\tcase XFS_RMAP_EXTENT_UNMAP:\n\t\t\tfake.ri_type = XFS_RMAP_UNMAP;\n\t\t\tbreak;\n\t\tcase XFS_RMAP_EXTENT_UNMAP_SHARED:\n\t\t\tfake.ri_type = XFS_RMAP_UNMAP_SHARED;\n\t\t\tbreak;\n\t\tcase XFS_RMAP_EXTENT_CONVERT:\n\t\t\tfake.ri_type = XFS_RMAP_CONVERT;\n\t\t\tbreak;\n\t\tcase XFS_RMAP_EXTENT_CONVERT_SHARED:\n\t\t\tfake.ri_type = XFS_RMAP_CONVERT_SHARED;\n\t\t\tbreak;\n\t\tcase XFS_RMAP_EXTENT_ALLOC:\n\t\t\tfake.ri_type = XFS_RMAP_ALLOC;\n\t\t\tbreak;\n\t\tcase XFS_RMAP_EXTENT_FREE:\n\t\t\tfake.ri_type = XFS_RMAP_FREE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\t\t&ruip->rui_format,\n\t\t\t\t\tsizeof(ruip->rui_format));\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto abort_error;\n\t\t}\n\n\t\tfake.ri_owner = map->me_owner;\n\t\tfake.ri_whichfork = (map->me_flags & XFS_RMAP_EXTENT_ATTR_FORK) ?\n\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\t\tfake.ri_bmap.br_startblock = map->me_startblock;\n\t\tfake.ri_bmap.br_startoff = map->me_startoff;\n\t\tfake.ri_bmap.br_blockcount = map->me_len;\n\t\tfake.ri_bmap.br_state = (map->me_flags & XFS_RMAP_EXTENT_UNWRITTEN) ?\n\t\t\t\tXFS_EXT_UNWRITTEN : XFS_EXT_NORM;\n\n\t\txfs_rmap_update_get_group(mp, &fake);\n\t\terror = xfs_trans_log_finish_rmap_update(tp, rudp, &fake,\n\t\t\t\t&rcur);\n\t\tif (error == -EFSCORRUPTED)\n\t\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\t\tmap, sizeof(*map));\n\t\txfs_rmap_update_put_group(&fake);\n\t\tif (error)\n\t\t\tgoto abort_error;\n\n\t}\n\n\txfs_rmap_finish_one_cleanup(tp, rcur, error);\n\treturn xfs_defer_ops_capture_and_commit(tp, capture_list);\n\nabort_error:\n\txfs_rmap_finish_one_cleanup(tp, rcur, error);\n\txfs_trans_cancel(tp);\n\treturn error;\n}\n\nSTATIC bool\nxfs_rui_item_match(\n\tstruct xfs_log_item\t*lip,\n\tuint64_t\t\tintent_id)\n{\n\treturn RUI_ITEM(lip)->rui_format.rui_id == intent_id;\n}\n\n \nstatic struct xfs_log_item *\nxfs_rui_item_relog(\n\tstruct xfs_log_item\t\t*intent,\n\tstruct xfs_trans\t\t*tp)\n{\n\tstruct xfs_rud_log_item\t\t*rudp;\n\tstruct xfs_rui_log_item\t\t*ruip;\n\tstruct xfs_map_extent\t\t*map;\n\tunsigned int\t\t\tcount;\n\n\tcount = RUI_ITEM(intent)->rui_format.rui_nextents;\n\tmap = RUI_ITEM(intent)->rui_format.rui_extents;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\trudp = xfs_trans_get_rud(tp, RUI_ITEM(intent));\n\tset_bit(XFS_LI_DIRTY, &rudp->rud_item.li_flags);\n\n\truip = xfs_rui_init(tp->t_mountp, count);\n\tmemcpy(ruip->rui_format.rui_extents, map, count * sizeof(*map));\n\tatomic_set(&ruip->rui_next_extent, count);\n\txfs_trans_add_item(tp, &ruip->rui_item);\n\tset_bit(XFS_LI_DIRTY, &ruip->rui_item.li_flags);\n\treturn &ruip->rui_item;\n}\n\nstatic const struct xfs_item_ops xfs_rui_item_ops = {\n\t.flags\t\t= XFS_ITEM_INTENT,\n\t.iop_size\t= xfs_rui_item_size,\n\t.iop_format\t= xfs_rui_item_format,\n\t.iop_unpin\t= xfs_rui_item_unpin,\n\t.iop_release\t= xfs_rui_item_release,\n\t.iop_recover\t= xfs_rui_item_recover,\n\t.iop_match\t= xfs_rui_item_match,\n\t.iop_relog\t= xfs_rui_item_relog,\n};\n\nstatic inline void\nxfs_rui_copy_format(\n\tstruct xfs_rui_log_format\t*dst,\n\tconst struct xfs_rui_log_format\t*src)\n{\n\tunsigned int\t\t\ti;\n\n\tmemcpy(dst, src, offsetof(struct xfs_rui_log_format, rui_extents));\n\n\tfor (i = 0; i < src->rui_nextents; i++)\n\t\tmemcpy(&dst->rui_extents[i], &src->rui_extents[i],\n\t\t\t\tsizeof(struct xfs_map_extent));\n}\n\n \nSTATIC int\nxlog_recover_rui_commit_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tlsn)\n{\n\tstruct xfs_mount\t\t*mp = log->l_mp;\n\tstruct xfs_rui_log_item\t\t*ruip;\n\tstruct xfs_rui_log_format\t*rui_formatp;\n\tsize_t\t\t\t\tlen;\n\n\trui_formatp = item->ri_buf[0].i_addr;\n\n\tif (item->ri_buf[0].i_len < xfs_rui_log_format_sizeof(0)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\titem->ri_buf[0].i_addr, item->ri_buf[0].i_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tlen = xfs_rui_log_format_sizeof(rui_formatp->rui_nextents);\n\tif (item->ri_buf[0].i_len != len) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\titem->ri_buf[0].i_addr, item->ri_buf[0].i_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\truip = xfs_rui_init(mp, rui_formatp->rui_nextents);\n\txfs_rui_copy_format(&ruip->rui_format, rui_formatp);\n\tatomic_set(&ruip->rui_next_extent, rui_formatp->rui_nextents);\n\t \n\txfs_trans_ail_insert(log->l_ailp, &ruip->rui_item, lsn);\n\txfs_rui_release(ruip);\n\treturn 0;\n}\n\nconst struct xlog_recover_item_ops xlog_rui_item_ops = {\n\t.item_type\t\t= XFS_LI_RUI,\n\t.commit_pass2\t\t= xlog_recover_rui_commit_pass2,\n};\n\n \nSTATIC int\nxlog_recover_rud_commit_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tlsn)\n{\n\tstruct xfs_rud_log_format\t*rud_formatp;\n\n\trud_formatp = item->ri_buf[0].i_addr;\n\tif (item->ri_buf[0].i_len != sizeof(struct xfs_rud_log_format)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, log->l_mp,\n\t\t\t\trud_formatp, item->ri_buf[0].i_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\txlog_recover_release_intent(log, XFS_LI_RUI, rud_formatp->rud_rui_id);\n\treturn 0;\n}\n\nconst struct xlog_recover_item_ops xlog_rud_item_ops = {\n\t.item_type\t\t= XFS_LI_RUD,\n\t.commit_pass2\t\t= xlog_recover_rud_commit_pass2,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}