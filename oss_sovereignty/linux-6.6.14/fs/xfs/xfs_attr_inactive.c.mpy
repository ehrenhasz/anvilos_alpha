{
  "module_name": "xfs_attr_inactive.c",
  "hash_id": "72ae0280d43785b165a59c86112c314958b3e25f2e2e6c1c06d2ea3098804fe7",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_attr_inactive.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n\n \nSTATIC int\nxfs_attr3_rmt_stale(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tblkno,\n\tint\t\t\tblkcnt)\n{\n\tstruct xfs_bmbt_irec\tmap;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t \n\twhile (blkcnt > 0) {\n\t\t \n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)blkno, blkcnt,\n\t\t\t\t       &map, &nmap, XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (XFS_IS_CORRUPT(dp->i_mount, nmap != 1))\n\t\t\treturn -EFSCORRUPTED;\n\n\t\t \n\t\terror = xfs_attr_rmtval_stale(dp, &map, 0);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\n\treturn 0;\n}\n\n \nSTATIC int\nxfs_attr3_leaf_inactive(\n\tstruct xfs_trans\t\t**trans,\n\tstruct xfs_inode\t\t*dp,\n\tstruct xfs_buf\t\t\t*bp)\n{\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_mount\t\t*mp = bp->b_mount;\n\tstruct xfs_attr_leafblock\t*leaf = bp->b_addr;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tint\t\t\t\terror = 0;\n\tint\t\t\t\ti;\n\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, leaf);\n\n\t \n\tentry = xfs_attr3_leaf_entryp(leaf);\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tint\t\tblkcnt;\n\n\t\tif (!entry->nameidx || (entry->flags & XFS_ATTR_LOCAL))\n\t\t\tcontinue;\n\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\n\t\tif (!name_rmt->valueblk)\n\t\t\tcontinue;\n\n\t\tblkcnt = xfs_attr3_rmt_blocks(dp->i_mount,\n\t\t\t\tbe32_to_cpu(name_rmt->valuelen));\n\t\terror = xfs_attr3_rmt_stale(dp,\n\t\t\t\tbe32_to_cpu(name_rmt->valueblk), blkcnt);\n\t\tif (error)\n\t\t\tgoto err;\n\t}\n\n\txfs_trans_brelse(*trans, bp);\nerr:\n\treturn error;\n}\n\n \nSTATIC int\nxfs_attr3_node_inactive(\n\tstruct xfs_trans\t**trans,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_blkinfo\t*info;\n\txfs_dablk_t\t\tchild_fsb;\n\txfs_daddr_t\t\tparent_blkno, child_blkno;\n\tstruct xfs_buf\t\t*child_bp;\n\tstruct xfs_da3_icnode_hdr ichdr;\n\tint\t\t\terror, i;\n\n\t \n\tif (level > XFS_DA_NODE_MAXDEPTH) {\n\t\txfs_buf_mark_corrupt(bp);\n\t\txfs_trans_brelse(*trans, bp);\t \n\t\treturn -EFSCORRUPTED;\n\t}\n\n\txfs_da3_node_hdr_from_disk(dp->i_mount, &ichdr, bp->b_addr);\n\tparent_blkno = xfs_buf_daddr(bp);\n\tif (!ichdr.count) {\n\t\txfs_trans_brelse(*trans, bp);\n\t\treturn 0;\n\t}\n\tchild_fsb = be32_to_cpu(ichdr.btree[0].before);\n\txfs_trans_brelse(*trans, bp);\t \n\tbp = NULL;\n\n\t \n\tfor (i = 0; i < ichdr.count; i++) {\n\t\t \n\t\terror = xfs_da3_node_read(*trans, dp, child_fsb, &child_bp,\n\t\t\t\t\t  XFS_ATTR_FORK);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tchild_blkno = xfs_buf_daddr(child_bp);\n\n\t\t \n\t\tinfo = child_bp->b_addr;\n\t\tswitch (info->magic) {\n\t\tcase cpu_to_be16(XFS_DA_NODE_MAGIC):\n\t\tcase cpu_to_be16(XFS_DA3_NODE_MAGIC):\n\t\t\terror = xfs_attr3_node_inactive(trans, dp, child_bp,\n\t\t\t\t\t\t\tlevel + 1);\n\t\t\tbreak;\n\t\tcase cpu_to_be16(XFS_ATTR_LEAF_MAGIC):\n\t\tcase cpu_to_be16(XFS_ATTR3_LEAF_MAGIC):\n\t\t\terror = xfs_attr3_leaf_inactive(trans, dp, child_bp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txfs_buf_mark_corrupt(child_bp);\n\t\t\txfs_trans_brelse(*trans, child_bp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tbreak;\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\terror = xfs_trans_get_buf(*trans, mp->m_ddev_targp,\n\t\t\t\tchild_blkno,\n\t\t\t\tXFS_FSB_TO_BB(mp, mp->m_attr_geo->fsbcount), 0,\n\t\t\t\t&child_bp);\n\t\tif (error)\n\t\t\treturn error;\n\t\txfs_trans_binval(*trans, child_bp);\n\t\tchild_bp = NULL;\n\n\t\t \n\t\tif (i + 1 < ichdr.count) {\n\t\t\tstruct xfs_da3_icnode_hdr phdr;\n\n\t\t\terror = xfs_da3_node_read_mapped(*trans, dp,\n\t\t\t\t\tparent_blkno, &bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\txfs_da3_node_hdr_from_disk(dp->i_mount, &phdr,\n\t\t\t\t\t\t  bp->b_addr);\n\t\t\tchild_fsb = be32_to_cpu(phdr.btree[i + 1].before);\n\t\t\txfs_trans_brelse(*trans, bp);\n\t\t\tbp = NULL;\n\t\t}\n\t\t \n\t\terror = xfs_trans_roll_inode(trans, dp);\n\t\tif (error)\n\t\t\treturn  error;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nxfs_attr3_root_inactive(\n\tstruct xfs_trans\t**trans,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_blkinfo\t*info;\n\tstruct xfs_buf\t\t*bp;\n\txfs_daddr_t\t\tblkno;\n\tint\t\t\terror;\n\n\t \n\terror = xfs_da3_node_read(*trans, dp, 0, &bp, XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\tblkno = xfs_buf_daddr(bp);\n\n\t \n\tinfo = bp->b_addr;\n\tswitch (info->magic) {\n\tcase cpu_to_be16(XFS_DA_NODE_MAGIC):\n\tcase cpu_to_be16(XFS_DA3_NODE_MAGIC):\n\t\terror = xfs_attr3_node_inactive(trans, dp, bp, 1);\n\t\tbreak;\n\tcase cpu_to_be16(XFS_ATTR_LEAF_MAGIC):\n\tcase cpu_to_be16(XFS_ATTR3_LEAF_MAGIC):\n\t\terror = xfs_attr3_leaf_inactive(trans, dp, bp);\n\t\tbreak;\n\tdefault:\n\t\terror = -EFSCORRUPTED;\n\t\txfs_buf_mark_corrupt(bp);\n\t\txfs_trans_brelse(*trans, bp);\n\t\tbreak;\n\t}\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = xfs_trans_get_buf(*trans, mp->m_ddev_targp, blkno,\n\t\t\tXFS_FSB_TO_BB(mp, mp->m_attr_geo->fsbcount), 0, &bp);\n\tif (error)\n\t\treturn error;\n\terror = bp->b_error;\n\tif (error) {\n\t\txfs_trans_brelse(*trans, bp);\n\t\treturn error;\n\t}\n\txfs_trans_binval(*trans, bp);\t \n\t \n\terror = xfs_trans_roll_inode(trans, dp);\n\n\treturn error;\n}\n\n \nint\nxfs_attr_inactive(\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_mount\t*mp;\n\tint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\tint\t\t\terror = 0;\n\n\tmp = dp->i_mount;\n\n\txfs_ilock(dp, lock_mode);\n\tif (!xfs_inode_has_attr_fork(dp))\n\t\tgoto out_destroy_fork;\n\txfs_iunlock(dp, lock_mode);\n\n\tlock_mode = 0;\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_attrinval, 0, 0, 0, &trans);\n\tif (error)\n\t\tgoto out_destroy_fork;\n\n\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(dp, lock_mode);\n\n\tif (!xfs_inode_has_attr_fork(dp))\n\t\tgoto out_cancel;\n\n\t \n\txfs_trans_ijoin(trans, dp, 0);\n\n\t \n\tif (dp->i_af.if_nextents > 0) {\n\t\terror = xfs_attr3_root_inactive(&trans, dp);\n\t\tif (error)\n\t\t\tgoto out_cancel;\n\n\t\terror = xfs_itruncate_extents(&trans, dp, XFS_ATTR_FORK, 0);\n\t\tif (error)\n\t\t\tgoto out_cancel;\n\t}\n\n\t \n\txfs_attr_fork_remove(dp, trans);\n\n\terror = xfs_trans_commit(trans);\n\txfs_iunlock(dp, lock_mode);\n\treturn error;\n\nout_cancel:\n\txfs_trans_cancel(trans);\nout_destroy_fork:\n\t \n\txfs_ifork_zap_attr(dp);\n\tif (lock_mode)\n\t\txfs_iunlock(dp, lock_mode);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}