{
  "module_name": "xfs_log_cil.c",
  "hash_id": "59dc825f1532a720c8ef54fa27d87b83d1b0162f9f15734cea642c99c5dfc578",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_log_cil.c",
  "human_readable_source": "\n \n\n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_discard.h\"\n\n \nstatic struct xlog_ticket *\nxlog_cil_ticket_alloc(\n\tstruct xlog\t*log)\n{\n\tstruct xlog_ticket *tic;\n\n\ttic = xlog_ticket_alloc(log, 0, 1, 0);\n\n\t \n\ttic->t_curr_res = 0;\n\ttic->t_iclog_hdrs = 0;\n\treturn tic;\n}\n\nstatic inline void\nxlog_cil_set_iclog_hdr_count(struct xfs_cil *cil)\n{\n\tstruct xlog\t*log = cil->xc_log;\n\n\tatomic_set(&cil->xc_iclog_hdrs,\n\t\t   (XLOG_CIL_BLOCKING_SPACE_LIMIT(log) /\n\t\t\t(log->l_iclog_size - log->l_iclog_hsize)));\n}\n\n \nstatic bool\nxlog_item_in_current_chkpt(\n\tstruct xfs_cil\t\t*cil,\n\tstruct xfs_log_item\t*lip)\n{\n\tif (test_bit(XLOG_CIL_EMPTY, &cil->xc_flags))\n\t\treturn false;\n\n\t \n\treturn lip->li_seq == READ_ONCE(cil->xc_current_sequence);\n}\n\nbool\nxfs_log_item_in_current_chkpt(\n\tstruct xfs_log_item *lip)\n{\n\treturn xlog_item_in_current_chkpt(lip->li_log->l_cilp, lip);\n}\n\n \nstatic void xlog_cil_push_work(struct work_struct *work);\n\nstatic struct xfs_cil_ctx *\nxlog_cil_ctx_alloc(void)\n{\n\tstruct xfs_cil_ctx\t*ctx;\n\n\tctx = kmem_zalloc(sizeof(*ctx), KM_NOFS);\n\tINIT_LIST_HEAD(&ctx->committing);\n\tINIT_LIST_HEAD(&ctx->busy_extents.extent_list);\n\tINIT_LIST_HEAD(&ctx->log_items);\n\tINIT_LIST_HEAD(&ctx->lv_chain);\n\tINIT_WORK(&ctx->push_work, xlog_cil_push_work);\n\treturn ctx;\n}\n\n \nstatic void\nxlog_cil_push_pcp_aggregate(\n\tstruct xfs_cil\t\t*cil,\n\tstruct xfs_cil_ctx\t*ctx)\n{\n\tstruct xlog_cil_pcp\t*cilpcp;\n\tint\t\t\tcpu;\n\n\tfor_each_cpu(cpu, &ctx->cil_pcpmask) {\n\t\tcilpcp = per_cpu_ptr(cil->xc_pcp, cpu);\n\n\t\tctx->ticket->t_curr_res += cilpcp->space_reserved;\n\t\tcilpcp->space_reserved = 0;\n\n\t\tif (!list_empty(&cilpcp->busy_extents)) {\n\t\t\tlist_splice_init(&cilpcp->busy_extents,\n\t\t\t\t\t&ctx->busy_extents.extent_list);\n\t\t}\n\t\tif (!list_empty(&cilpcp->log_items))\n\t\t\tlist_splice_init(&cilpcp->log_items, &ctx->log_items);\n\n\t\t \n\t\tcilpcp->space_used = 0;\n\t}\n}\n\n \nstatic void\nxlog_cil_insert_pcp_aggregate(\n\tstruct xfs_cil\t\t*cil,\n\tstruct xfs_cil_ctx\t*ctx)\n{\n\tstruct xlog_cil_pcp\t*cilpcp;\n\tint\t\t\tcpu;\n\tint\t\t\tcount = 0;\n\n\t \n\tif (!test_and_clear_bit(XLOG_CIL_PCP_SPACE, &cil->xc_flags))\n\t\treturn;\n\n\t \n\tfor_each_cpu(cpu, &ctx->cil_pcpmask) {\n\t\tint\told, prev;\n\n\t\tcilpcp = per_cpu_ptr(cil->xc_pcp, cpu);\n\t\tdo {\n\t\t\told = cilpcp->space_used;\n\t\t\tprev = cmpxchg(&cilpcp->space_used, old, 0);\n\t\t} while (old != prev);\n\t\tcount += old;\n\t}\n\tatomic_add(count, &ctx->space_used);\n}\n\nstatic void\nxlog_cil_ctx_switch(\n\tstruct xfs_cil\t\t*cil,\n\tstruct xfs_cil_ctx\t*ctx)\n{\n\txlog_cil_set_iclog_hdr_count(cil);\n\tset_bit(XLOG_CIL_EMPTY, &cil->xc_flags);\n\tset_bit(XLOG_CIL_PCP_SPACE, &cil->xc_flags);\n\tctx->sequence = ++cil->xc_current_sequence;\n\tctx->cil = cil;\n\tcil->xc_ctx = ctx;\n}\n\n \nvoid\nxlog_cil_init_post_recovery(\n\tstruct xlog\t*log)\n{\n\tlog->l_cilp->xc_ctx->ticket = xlog_cil_ticket_alloc(log);\n\tlog->l_cilp->xc_ctx->sequence = 1;\n\txlog_cil_set_iclog_hdr_count(log->l_cilp);\n}\n\nstatic inline int\nxlog_cil_iovec_space(\n\tuint\tniovecs)\n{\n\treturn round_up((sizeof(struct xfs_log_vec) +\n\t\t\t\t\tniovecs * sizeof(struct xfs_log_iovec)),\n\t\t\tsizeof(uint64_t));\n}\n\n \nstatic void\nxlog_cil_alloc_shadow_bufs(\n\tstruct xlog\t\t*log,\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_log_item\t*lip;\n\n\tlist_for_each_entry(lip, &tp->t_items, li_trans) {\n\t\tstruct xfs_log_vec *lv;\n\t\tint\tniovecs = 0;\n\t\tint\tnbytes = 0;\n\t\tint\tbuf_size;\n\t\tbool\tordered = false;\n\n\t\t \n\t\tif (!test_bit(XFS_LI_DIRTY, &lip->li_flags))\n\t\t\tcontinue;\n\n\t\t \n\t\tlip->li_ops->iop_size(lip, &niovecs, &nbytes);\n\n\t\t \n\t\tif (niovecs == XFS_LOG_VEC_ORDERED) {\n\t\t\tordered = true;\n\t\t\tniovecs = 0;\n\t\t\tnbytes = 0;\n\t\t}\n\n\t\t \n\t\tnbytes += niovecs *\n\t\t\t(sizeof(uint64_t) + sizeof(struct xlog_op_header));\n\t\tnbytes = round_up(nbytes, sizeof(uint64_t));\n\n\t\t \n\t\tbuf_size = nbytes + xlog_cil_iovec_space(niovecs);\n\n\t\t \n\t\tif (!lip->li_lv_shadow ||\n\t\t    buf_size > lip->li_lv_shadow->lv_size) {\n\t\t\t \n\t\t\tkmem_free(lip->li_lv_shadow);\n\t\t\tlv = xlog_kvmalloc(buf_size);\n\n\t\t\tmemset(lv, 0, xlog_cil_iovec_space(niovecs));\n\n\t\t\tINIT_LIST_HEAD(&lv->lv_list);\n\t\t\tlv->lv_item = lip;\n\t\t\tlv->lv_size = buf_size;\n\t\t\tif (ordered)\n\t\t\t\tlv->lv_buf_len = XFS_LOG_VEC_ORDERED;\n\t\t\telse\n\t\t\t\tlv->lv_iovecp = (struct xfs_log_iovec *)&lv[1];\n\t\t\tlip->li_lv_shadow = lv;\n\t\t} else {\n\t\t\t \n\t\t\tlv = lip->li_lv_shadow;\n\t\t\tif (ordered)\n\t\t\t\tlv->lv_buf_len = XFS_LOG_VEC_ORDERED;\n\t\t\telse\n\t\t\t\tlv->lv_buf_len = 0;\n\t\t\tlv->lv_bytes = 0;\n\t\t}\n\n\t\t \n\t\tlv->lv_niovecs = niovecs;\n\n\t\t \n\t\tlv->lv_buf = (char *)lv + xlog_cil_iovec_space(niovecs);\n\t}\n\n}\n\n \nSTATIC void\nxfs_cil_prepare_item(\n\tstruct xlog\t\t*log,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_vec\t*old_lv,\n\tint\t\t\t*diff_len)\n{\n\t \n\tif (lv->lv_buf_len != XFS_LOG_VEC_ORDERED)\n\t\t*diff_len += lv->lv_bytes;\n\n\t \n\tif (!old_lv) {\n\t\tif (lv->lv_item->li_ops->iop_pin)\n\t\t\tlv->lv_item->li_ops->iop_pin(lv->lv_item);\n\t\tlv->lv_item->li_lv_shadow = NULL;\n\t} else if (old_lv != lv) {\n\t\tASSERT(lv->lv_buf_len != XFS_LOG_VEC_ORDERED);\n\n\t\t*diff_len -= old_lv->lv_bytes;\n\t\tlv->lv_item->li_lv_shadow = old_lv;\n\t}\n\n\t \n\tlv->lv_item->li_lv = lv;\n\n\t \n\tif (!lv->lv_item->li_seq)\n\t\tlv->lv_item->li_seq = log->l_cilp->xc_ctx->sequence;\n}\n\n \nstatic void\nxlog_cil_insert_format_items(\n\tstruct xlog\t\t*log,\n\tstruct xfs_trans\t*tp,\n\tint\t\t\t*diff_len)\n{\n\tstruct xfs_log_item\t*lip;\n\n\t \n\tif (list_empty(&tp->t_items)) {\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(lip, &tp->t_items, li_trans) {\n\t\tstruct xfs_log_vec *lv;\n\t\tstruct xfs_log_vec *old_lv = NULL;\n\t\tstruct xfs_log_vec *shadow;\n\t\tbool\tordered = false;\n\n\t\t \n\t\tif (!test_bit(XFS_LI_DIRTY, &lip->li_flags))\n\t\t\tcontinue;\n\n\t\t \n\t\tshadow = lip->li_lv_shadow;\n\t\tif (shadow->lv_buf_len == XFS_LOG_VEC_ORDERED)\n\t\t\tordered = true;\n\n\t\t \n\t\tif (!shadow->lv_niovecs && !ordered)\n\t\t\tcontinue;\n\n\t\t \n\t\told_lv = lip->li_lv;\n\t\tif (lip->li_lv && shadow->lv_size <= lip->li_lv->lv_size) {\n\t\t\t \n\t\t\tlv = lip->li_lv;\n\n\t\t\tif (ordered)\n\t\t\t\tgoto insert;\n\n\t\t\t \n\t\t\t*diff_len -= lv->lv_bytes;\n\n\t\t\t \n\t\t\tlv->lv_niovecs = shadow->lv_niovecs;\n\n\t\t\t \n\t\t\tlv->lv_buf_len = 0;\n\t\t\tlv->lv_bytes = 0;\n\t\t\tlv->lv_buf = (char *)lv +\n\t\t\t\t\txlog_cil_iovec_space(lv->lv_niovecs);\n\t\t} else {\n\t\t\t \n\t\t\tlv = shadow;\n\t\t\tlv->lv_item = lip;\n\t\t\tif (ordered) {\n\t\t\t\t \n\t\t\t\tASSERT(lip->li_lv == NULL);\n\t\t\t\tgoto insert;\n\t\t\t}\n\t\t}\n\n\t\tASSERT(IS_ALIGNED((unsigned long)lv->lv_buf, sizeof(uint64_t)));\n\t\tlip->li_ops->iop_format(lip, lv);\ninsert:\n\t\txfs_cil_prepare_item(log, lv, old_lv, diff_len);\n\t}\n}\n\n \nstatic inline bool\nxlog_cil_over_hard_limit(\n\tstruct xlog\t*log,\n\tint32_t\t\tspace_used)\n{\n\tif (waitqueue_active(&log->l_cilp->xc_push_wait))\n\t\treturn true;\n\tif (space_used >= XLOG_CIL_BLOCKING_SPACE_LIMIT(log))\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic void\nxlog_cil_insert_items(\n\tstruct xlog\t\t*log,\n\tstruct xfs_trans\t*tp,\n\tuint32_t\t\treleased_space)\n{\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tstruct xfs_cil_ctx\t*ctx = cil->xc_ctx;\n\tstruct xfs_log_item\t*lip;\n\tint\t\t\tlen = 0;\n\tint\t\t\tiovhdr_res = 0, split_res = 0, ctx_res = 0;\n\tint\t\t\tspace_used;\n\tint\t\t\torder;\n\tunsigned int\t\tcpu_nr;\n\tstruct xlog_cil_pcp\t*cilpcp;\n\n\tASSERT(tp);\n\n\t \n\txlog_cil_insert_format_items(log, tp, &len);\n\n\t \n\tlen -= released_space;\n\n\t \n\tcpu_nr = get_cpu();\n\tcilpcp = this_cpu_ptr(cil->xc_pcp);\n\n\t \n\tif (!cpumask_test_cpu(cpu_nr, &ctx->cil_pcpmask))\n\t\tcpumask_test_and_set_cpu(cpu_nr, &ctx->cil_pcpmask);\n\n\t \n\tif (test_bit(XLOG_CIL_EMPTY, &cil->xc_flags) &&\n\t    test_and_clear_bit(XLOG_CIL_EMPTY, &cil->xc_flags))\n\t\tctx_res = ctx->ticket->t_unit_res;\n\n\t \n\tspace_used = atomic_read(&ctx->space_used) + cilpcp->space_used + len;\n\tif (atomic_read(&cil->xc_iclog_hdrs) > 0 ||\n\t    xlog_cil_over_hard_limit(log, space_used)) {\n\t\tsplit_res = log->l_iclog_hsize +\n\t\t\t\t\tsizeof(struct xlog_op_header);\n\t\tif (ctx_res)\n\t\t\tctx_res += split_res * (tp->t_ticket->t_iclog_hdrs - 1);\n\t\telse\n\t\t\tctx_res = split_res * tp->t_ticket->t_iclog_hdrs;\n\t\tatomic_sub(tp->t_ticket->t_iclog_hdrs, &cil->xc_iclog_hdrs);\n\t}\n\tcilpcp->space_reserved += ctx_res;\n\n\t \n\tif (!test_bit(XLOG_CIL_PCP_SPACE, &cil->xc_flags)) {\n\t\tatomic_add(len, &ctx->space_used);\n\t} else if (cilpcp->space_used + len >\n\t\t\t(XLOG_CIL_SPACE_LIMIT(log) / num_online_cpus())) {\n\t\tspace_used = atomic_add_return(cilpcp->space_used + len,\n\t\t\t\t\t\t&ctx->space_used);\n\t\tcilpcp->space_used = 0;\n\n\t\t \n\t\tif (space_used >= XLOG_CIL_SPACE_LIMIT(log))\n\t\t\txlog_cil_insert_pcp_aggregate(cil, ctx);\n\t} else {\n\t\tcilpcp->space_used += len;\n\t}\n\t \n\tif (!list_empty(&tp->t_busy))\n\t\tlist_splice_init(&tp->t_busy, &cilpcp->busy_extents);\n\n\t \n\torder = atomic_inc_return(&ctx->order_id);\n\tlist_for_each_entry(lip, &tp->t_items, li_trans) {\n\t\t \n\t\tif (!test_bit(XFS_LI_DIRTY, &lip->li_flags))\n\t\t\tcontinue;\n\n\t\tlip->li_order_id = order;\n\t\tif (!list_empty(&lip->li_cil))\n\t\t\tcontinue;\n\t\tlist_add_tail(&lip->li_cil, &cilpcp->log_items);\n\t}\n\tput_cpu();\n\n\t \n\ttp->t_ticket->t_curr_res -= ctx_res + len;\n\tif (WARN_ON(tp->t_ticket->t_curr_res < 0)) {\n\t\txfs_warn(log->l_mp, \"Transaction log reservation overrun:\");\n\t\txfs_warn(log->l_mp,\n\t\t\t \"  log items: %d bytes (iov hdrs: %d bytes)\",\n\t\t\t len, iovhdr_res);\n\t\txfs_warn(log->l_mp, \"  split region headers: %d bytes\",\n\t\t\t split_res);\n\t\txfs_warn(log->l_mp, \"  ctx ticket: %d bytes\", ctx_res);\n\t\txlog_print_trans(tp);\n\t\txlog_force_shutdown(log, SHUTDOWN_LOG_IO_ERROR);\n\t}\n}\n\nstatic void\nxlog_cil_free_logvec(\n\tstruct list_head\t*lv_chain)\n{\n\tstruct xfs_log_vec\t*lv;\n\n\twhile (!list_empty(lv_chain)) {\n\t\tlv = list_first_entry(lv_chain, struct xfs_log_vec, lv_list);\n\t\tlist_del_init(&lv->lv_list);\n\t\tkmem_free(lv);\n\t}\n}\n\n \nstatic void\nxlog_cil_committed(\n\tstruct xfs_cil_ctx\t*ctx)\n{\n\tstruct xfs_mount\t*mp = ctx->cil->xc_log->l_mp;\n\tbool\t\t\tabort = xlog_is_shutdown(ctx->cil->xc_log);\n\n\t \n\tif (abort) {\n\t\tspin_lock(&ctx->cil->xc_push_lock);\n\t\twake_up_all(&ctx->cil->xc_start_wait);\n\t\twake_up_all(&ctx->cil->xc_commit_wait);\n\t\tspin_unlock(&ctx->cil->xc_push_lock);\n\t}\n\n\txfs_trans_committed_bulk(ctx->cil->xc_log->l_ailp, &ctx->lv_chain,\n\t\t\t\t\tctx->start_lsn, abort);\n\n\txfs_extent_busy_sort(&ctx->busy_extents.extent_list);\n\txfs_extent_busy_clear(mp, &ctx->busy_extents.extent_list,\n\t\t\t      xfs_has_discard(mp) && !abort);\n\n\tspin_lock(&ctx->cil->xc_push_lock);\n\tlist_del(&ctx->committing);\n\tspin_unlock(&ctx->cil->xc_push_lock);\n\n\txlog_cil_free_logvec(&ctx->lv_chain);\n\n\tif (!list_empty(&ctx->busy_extents.extent_list)) {\n\t\tctx->busy_extents.mount = mp;\n\t\tctx->busy_extents.owner = ctx;\n\t\txfs_discard_extents(mp, &ctx->busy_extents);\n\t\treturn;\n\t}\n\n\tkmem_free(ctx);\n}\n\nvoid\nxlog_cil_process_committed(\n\tstruct list_head\t*list)\n{\n\tstruct xfs_cil_ctx\t*ctx;\n\n\twhile ((ctx = list_first_entry_or_null(list,\n\t\t\tstruct xfs_cil_ctx, iclog_entry))) {\n\t\tlist_del(&ctx->iclog_entry);\n\t\txlog_cil_committed(ctx);\n\t}\n}\n\n \nvoid\nxlog_cil_set_ctx_write_state(\n\tstruct xfs_cil_ctx\t*ctx,\n\tstruct xlog_in_core\t*iclog)\n{\n\tstruct xfs_cil\t\t*cil = ctx->cil;\n\txfs_lsn_t\t\tlsn = be64_to_cpu(iclog->ic_header.h_lsn);\n\n\tASSERT(!ctx->commit_lsn);\n\tif (!ctx->start_lsn) {\n\t\tspin_lock(&cil->xc_push_lock);\n\t\t \n\t\tctx->start_lsn = lsn;\n\t\twake_up_all(&cil->xc_start_wait);\n\t\tspin_unlock(&cil->xc_push_lock);\n\n\t\t \n\t\tspin_lock(&cil->xc_log->l_icloglock);\n\t\ticlog->ic_flags |= XLOG_ICL_NEED_FLUSH;\n\t\tspin_unlock(&cil->xc_log->l_icloglock);\n\t\treturn;\n\t}\n\n\t \n\tatomic_inc(&iclog->ic_refcnt);\n\n\t \n\tspin_lock(&cil->xc_log->l_icloglock);\n\tlist_add_tail(&ctx->iclog_entry, &iclog->ic_callbacks);\n\tspin_unlock(&cil->xc_log->l_icloglock);\n\n\t \n\tspin_lock(&cil->xc_push_lock);\n\tctx->commit_iclog = iclog;\n\tctx->commit_lsn = lsn;\n\twake_up_all(&cil->xc_commit_wait);\n\tspin_unlock(&cil->xc_push_lock);\n}\n\n\n \nenum _record_type {\n\t_START_RECORD,\n\t_COMMIT_RECORD,\n};\n\nstatic int\nxlog_cil_order_write(\n\tstruct xfs_cil\t\t*cil,\n\txfs_csn_t\t\tsequence,\n\tenum _record_type\trecord)\n{\n\tstruct xfs_cil_ctx\t*ctx;\n\nrestart:\n\tspin_lock(&cil->xc_push_lock);\n\tlist_for_each_entry(ctx, &cil->xc_committing, committing) {\n\t\t \n\t\tif (xlog_is_shutdown(cil->xc_log)) {\n\t\t\tspin_unlock(&cil->xc_push_lock);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tif (ctx->sequence >= sequence)\n\t\t\tcontinue;\n\n\t\t \n\t\tswitch (record) {\n\t\tcase _START_RECORD:\n\t\t\tif (!ctx->start_lsn) {\n\t\t\t\txlog_wait(&cil->xc_start_wait, &cil->xc_push_lock);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase _COMMIT_RECORD:\n\t\t\tif (!ctx->commit_lsn) {\n\t\t\t\txlog_wait(&cil->xc_commit_wait, &cil->xc_push_lock);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&cil->xc_push_lock);\n\treturn 0;\n}\n\n \nstatic int\nxlog_cil_write_chain(\n\tstruct xfs_cil_ctx\t*ctx,\n\tuint32_t\t\tchain_len)\n{\n\tstruct xlog\t\t*log = ctx->cil->xc_log;\n\tint\t\t\terror;\n\n\terror = xlog_cil_order_write(ctx->cil, ctx->sequence, _START_RECORD);\n\tif (error)\n\t\treturn error;\n\treturn xlog_write(log, ctx, &ctx->lv_chain, ctx->ticket, chain_len);\n}\n\n \nstatic int\nxlog_cil_write_commit_record(\n\tstruct xfs_cil_ctx\t*ctx)\n{\n\tstruct xlog\t\t*log = ctx->cil->xc_log;\n\tstruct xlog_op_header\tophdr = {\n\t\t.oh_clientid = XFS_TRANSACTION,\n\t\t.oh_tid = cpu_to_be32(ctx->ticket->t_tid),\n\t\t.oh_flags = XLOG_COMMIT_TRANS,\n\t};\n\tstruct xfs_log_iovec\treg = {\n\t\t.i_addr = &ophdr,\n\t\t.i_len = sizeof(struct xlog_op_header),\n\t\t.i_type = XLOG_REG_TYPE_COMMIT,\n\t};\n\tstruct xfs_log_vec\tvec = {\n\t\t.lv_niovecs = 1,\n\t\t.lv_iovecp = &reg,\n\t};\n\tint\t\t\terror;\n\tLIST_HEAD(lv_chain);\n\tlist_add(&vec.lv_list, &lv_chain);\n\n\tif (xlog_is_shutdown(log))\n\t\treturn -EIO;\n\n\terror = xlog_cil_order_write(ctx->cil, ctx->sequence, _COMMIT_RECORD);\n\tif (error)\n\t\treturn error;\n\n\t \n\tctx->ticket->t_curr_res -= reg.i_len;\n\terror = xlog_write(log, ctx, &lv_chain, ctx->ticket, reg.i_len);\n\tif (error)\n\t\txlog_force_shutdown(log, SHUTDOWN_LOG_IO_ERROR);\n\treturn error;\n}\n\nstruct xlog_cil_trans_hdr {\n\tstruct xlog_op_header\toph[2];\n\tstruct xfs_trans_header\tthdr;\n\tstruct xfs_log_iovec\tlhdr[2];\n};\n\n \nstatic void\nxlog_cil_build_trans_hdr(\n\tstruct xfs_cil_ctx\t*ctx,\n\tstruct xlog_cil_trans_hdr *hdr,\n\tstruct xfs_log_vec\t*lvhdr,\n\tint\t\t\tnum_iovecs)\n{\n\tstruct xlog_ticket\t*tic = ctx->ticket;\n\t__be32\t\t\ttid = cpu_to_be32(tic->t_tid);\n\n\tmemset(hdr, 0, sizeof(*hdr));\n\n\t \n\thdr->oph[0].oh_tid = tid;\n\thdr->oph[0].oh_clientid = XFS_TRANSACTION;\n\thdr->oph[0].oh_flags = XLOG_START_TRANS;\n\n\t \n\thdr->lhdr[0].i_addr = &hdr->oph[0];\n\thdr->lhdr[0].i_len = sizeof(struct xlog_op_header);\n\thdr->lhdr[0].i_type = XLOG_REG_TYPE_LRHEADER;\n\n\t \n\thdr->oph[1].oh_tid = tid;\n\thdr->oph[1].oh_clientid = XFS_TRANSACTION;\n\thdr->oph[1].oh_len = cpu_to_be32(sizeof(struct xfs_trans_header));\n\n\t \n\thdr->thdr.th_magic = XFS_TRANS_HEADER_MAGIC;\n\thdr->thdr.th_type = XFS_TRANS_CHECKPOINT;\n\thdr->thdr.th_tid = tic->t_tid;\n\thdr->thdr.th_num_items = num_iovecs;\n\n\t \n\thdr->lhdr[1].i_addr = &hdr->oph[1];\n\thdr->lhdr[1].i_len = sizeof(struct xlog_op_header) +\n\t\t\t\tsizeof(struct xfs_trans_header);\n\thdr->lhdr[1].i_type = XLOG_REG_TYPE_TRANSHDR;\n\n\tlvhdr->lv_niovecs = 2;\n\tlvhdr->lv_iovecp = &hdr->lhdr[0];\n\tlvhdr->lv_bytes = hdr->lhdr[0].i_len + hdr->lhdr[1].i_len;\n\n\ttic->t_curr_res -= lvhdr->lv_bytes;\n}\n\n \nstatic int\nxlog_cil_order_cmp(\n\tvoid\t\t\t*priv,\n\tconst struct list_head\t*a,\n\tconst struct list_head\t*b)\n{\n\tstruct xfs_log_vec\t*l1 = container_of(a, struct xfs_log_vec, lv_list);\n\tstruct xfs_log_vec\t*l2 = container_of(b, struct xfs_log_vec, lv_list);\n\n\treturn l1->lv_order_id > l2->lv_order_id;\n}\n\n \nstatic void\nxlog_cil_build_lv_chain(\n\tstruct xfs_cil_ctx\t*ctx,\n\tstruct list_head\t*whiteouts,\n\tuint32_t\t\t*num_iovecs,\n\tuint32_t\t\t*num_bytes)\n{\n\twhile (!list_empty(&ctx->log_items)) {\n\t\tstruct xfs_log_item\t*item;\n\t\tstruct xfs_log_vec\t*lv;\n\n\t\titem = list_first_entry(&ctx->log_items,\n\t\t\t\t\tstruct xfs_log_item, li_cil);\n\n\t\tif (test_bit(XFS_LI_WHITEOUT, &item->li_flags)) {\n\t\t\tlist_move(&item->li_cil, whiteouts);\n\t\t\ttrace_xfs_cil_whiteout_skip(item);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlv = item->li_lv;\n\t\tlv->lv_order_id = item->li_order_id;\n\n\t\t \n\t\tif (lv->lv_buf_len != XFS_LOG_VEC_ORDERED)\n\t\t\t*num_bytes += lv->lv_bytes;\n\t\t*num_iovecs += lv->lv_niovecs;\n\t\tlist_add_tail(&lv->lv_list, &ctx->lv_chain);\n\n\t\tlist_del_init(&item->li_cil);\n\t\titem->li_order_id = 0;\n\t\titem->li_lv = NULL;\n\t}\n}\n\nstatic void\nxlog_cil_cleanup_whiteouts(\n\tstruct list_head\t*whiteouts)\n{\n\twhile (!list_empty(whiteouts)) {\n\t\tstruct xfs_log_item *item = list_first_entry(whiteouts,\n\t\t\t\t\t\tstruct xfs_log_item, li_cil);\n\t\tlist_del_init(&item->li_cil);\n\t\ttrace_xfs_cil_whiteout_unpin(item);\n\t\titem->li_ops->iop_unpin(item, 1);\n\t}\n}\n\n \nstatic void\nxlog_cil_push_work(\n\tstruct work_struct\t*work)\n{\n\tstruct xfs_cil_ctx\t*ctx =\n\t\tcontainer_of(work, struct xfs_cil_ctx, push_work);\n\tstruct xfs_cil\t\t*cil = ctx->cil;\n\tstruct xlog\t\t*log = cil->xc_log;\n\tstruct xfs_cil_ctx\t*new_ctx;\n\tint\t\t\tnum_iovecs = 0;\n\tint\t\t\tnum_bytes = 0;\n\tint\t\t\terror = 0;\n\tstruct xlog_cil_trans_hdr thdr;\n\tstruct xfs_log_vec\tlvhdr = {};\n\txfs_csn_t\t\tpush_seq;\n\tbool\t\t\tpush_commit_stable;\n\tLIST_HEAD\t\t(whiteouts);\n\tstruct xlog_ticket\t*ticket;\n\n\tnew_ctx = xlog_cil_ctx_alloc();\n\tnew_ctx->ticket = xlog_cil_ticket_alloc(log);\n\n\tdown_write(&cil->xc_ctx_lock);\n\n\tspin_lock(&cil->xc_push_lock);\n\tpush_seq = cil->xc_push_seq;\n\tASSERT(push_seq <= ctx->sequence);\n\tpush_commit_stable = cil->xc_push_commit_stable;\n\tcil->xc_push_commit_stable = false;\n\n\t \n\tif (waitqueue_active(&cil->xc_push_wait))\n\t\twake_up_all(&cil->xc_push_wait);\n\n\txlog_cil_push_pcp_aggregate(cil, ctx);\n\n\t \n\tif (test_bit(XLOG_CIL_EMPTY, &cil->xc_flags)) {\n\t\tcil->xc_push_seq = 0;\n\t\tspin_unlock(&cil->xc_push_lock);\n\t\tgoto out_skip;\n\t}\n\n\n\t \n\tif (push_seq < ctx->sequence) {\n\t\tspin_unlock(&cil->xc_push_lock);\n\t\tgoto out_skip;\n\t}\n\n\t \n\tlist_add(&ctx->committing, &cil->xc_committing);\n\tspin_unlock(&cil->xc_push_lock);\n\n\txlog_cil_build_lv_chain(ctx, &whiteouts, &num_iovecs, &num_bytes);\n\n\t \n\tspin_lock(&cil->xc_push_lock);\n\txlog_cil_ctx_switch(cil, new_ctx);\n\tspin_unlock(&cil->xc_push_lock);\n\tup_write(&cil->xc_ctx_lock);\n\n\t \n\tlist_sort(NULL, &ctx->lv_chain, xlog_cil_order_cmp);\n\n\t \n\txlog_cil_build_trans_hdr(ctx, &thdr, &lvhdr, num_iovecs);\n\tnum_bytes += lvhdr.lv_bytes;\n\tlist_add(&lvhdr.lv_list, &ctx->lv_chain);\n\n\t \n\terror = xlog_cil_write_chain(ctx, num_bytes);\n\tlist_del(&lvhdr.lv_list);\n\tif (error)\n\t\tgoto out_abort_free_ticket;\n\n\terror = xlog_cil_write_commit_record(ctx);\n\tif (error)\n\t\tgoto out_abort_free_ticket;\n\n\t \n\tticket = ctx->ticket;\n\n\t \n\tspin_lock(&log->l_icloglock);\n\tif (ctx->start_lsn != ctx->commit_lsn) {\n\t\txfs_lsn_t\tplsn;\n\n\t\tplsn = be64_to_cpu(ctx->commit_iclog->ic_prev->ic_header.h_lsn);\n\t\tif (plsn && XFS_LSN_CMP(plsn, ctx->commit_lsn) < 0) {\n\t\t\t \n\t\t\txlog_wait_on_iclog(ctx->commit_iclog->ic_prev);\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t}\n\n\t\t \n\t\tctx->commit_iclog->ic_flags |= XLOG_ICL_NEED_FLUSH;\n\t}\n\n\t \n\tctx->commit_iclog->ic_flags |= XLOG_ICL_NEED_FUA;\n\tif (push_commit_stable &&\n\t    ctx->commit_iclog->ic_state == XLOG_STATE_ACTIVE)\n\t\txlog_state_switch_iclogs(log, ctx->commit_iclog, 0);\n\tticket = ctx->ticket;\n\txlog_state_release_iclog(log, ctx->commit_iclog, ticket);\n\n\t \n\n\tspin_unlock(&log->l_icloglock);\n\txlog_cil_cleanup_whiteouts(&whiteouts);\n\txfs_log_ticket_ungrant(log, ticket);\n\treturn;\n\nout_skip:\n\tup_write(&cil->xc_ctx_lock);\n\txfs_log_ticket_put(new_ctx->ticket);\n\tkmem_free(new_ctx);\n\treturn;\n\nout_abort_free_ticket:\n\tASSERT(xlog_is_shutdown(log));\n\txlog_cil_cleanup_whiteouts(&whiteouts);\n\tif (!ctx->commit_iclog) {\n\t\txfs_log_ticket_ungrant(log, ctx->ticket);\n\t\txlog_cil_committed(ctx);\n\t\treturn;\n\t}\n\tspin_lock(&log->l_icloglock);\n\tticket = ctx->ticket;\n\txlog_state_release_iclog(log, ctx->commit_iclog, ticket);\n\t \n\tspin_unlock(&log->l_icloglock);\n\txfs_log_ticket_ungrant(log, ticket);\n}\n\n \nstatic void\nxlog_cil_push_background(\n\tstruct xlog\t*log) __releases(cil->xc_ctx_lock)\n{\n\tstruct xfs_cil\t*cil = log->l_cilp;\n\tint\t\tspace_used = atomic_read(&cil->xc_ctx->space_used);\n\n\t \n\tASSERT(!test_bit(XLOG_CIL_EMPTY, &cil->xc_flags));\n\n\t \n\tif (space_used < XLOG_CIL_SPACE_LIMIT(log) ||\n\t    (cil->xc_push_seq == cil->xc_current_sequence &&\n\t     space_used < XLOG_CIL_BLOCKING_SPACE_LIMIT(log) &&\n\t     !waitqueue_active(&cil->xc_push_wait))) {\n\t\tup_read(&cil->xc_ctx_lock);\n\t\treturn;\n\t}\n\n\tspin_lock(&cil->xc_push_lock);\n\tif (cil->xc_push_seq < cil->xc_current_sequence) {\n\t\tcil->xc_push_seq = cil->xc_current_sequence;\n\t\tqueue_work(cil->xc_push_wq, &cil->xc_ctx->push_work);\n\t}\n\n\t \n\tup_read(&cil->xc_ctx_lock);\n\n\t \n\tif (xlog_cil_over_hard_limit(log, space_used)) {\n\t\ttrace_xfs_log_cil_wait(log, cil->xc_ctx->ticket);\n\t\tASSERT(space_used < log->l_logsize);\n\t\txlog_wait(&cil->xc_push_wait, &cil->xc_push_lock);\n\t\treturn;\n\t}\n\n\tspin_unlock(&cil->xc_push_lock);\n\n}\n\n \nstatic void\nxlog_cil_push_now(\n\tstruct xlog\t*log,\n\txfs_lsn_t\tpush_seq,\n\tbool\t\tasync)\n{\n\tstruct xfs_cil\t*cil = log->l_cilp;\n\n\tif (!cil)\n\t\treturn;\n\n\tASSERT(push_seq && push_seq <= cil->xc_current_sequence);\n\n\t \n\tif (!async)\n\t\tflush_workqueue(cil->xc_push_wq);\n\n\tspin_lock(&cil->xc_push_lock);\n\n\t \n\tcil->xc_push_commit_stable = async;\n\n\t \n\tif (test_bit(XLOG_CIL_EMPTY, &cil->xc_flags) ||\n\t    push_seq <= cil->xc_push_seq) {\n\t\tspin_unlock(&cil->xc_push_lock);\n\t\treturn;\n\t}\n\n\tcil->xc_push_seq = push_seq;\n\tqueue_work(cil->xc_push_wq, &cil->xc_ctx->push_work);\n\tspin_unlock(&cil->xc_push_lock);\n}\n\nbool\nxlog_cil_empty(\n\tstruct xlog\t*log)\n{\n\tstruct xfs_cil\t*cil = log->l_cilp;\n\tbool\t\tempty = false;\n\n\tspin_lock(&cil->xc_push_lock);\n\tif (test_bit(XLOG_CIL_EMPTY, &cil->xc_flags))\n\t\tempty = true;\n\tspin_unlock(&cil->xc_push_lock);\n\treturn empty;\n}\n\n \nstatic uint32_t\nxlog_cil_process_intents(\n\tstruct xfs_cil\t\t*cil,\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_log_item\t*lip, *ilip, *next;\n\tuint32_t\t\tlen = 0;\n\n\tlist_for_each_entry_safe(lip, next, &tp->t_items, li_trans) {\n\t\tif (!(lip->li_ops->flags & XFS_ITEM_INTENT_DONE))\n\t\t\tcontinue;\n\n\t\tilip = lip->li_ops->iop_intent(lip);\n\t\tif (!ilip || !xlog_item_in_current_chkpt(cil, ilip))\n\t\t\tcontinue;\n\t\tset_bit(XFS_LI_WHITEOUT, &ilip->li_flags);\n\t\ttrace_xfs_cil_whiteout_mark(ilip);\n\t\tlen += ilip->li_lv->lv_bytes;\n\t\tkmem_free(ilip->li_lv);\n\t\tilip->li_lv = NULL;\n\n\t\txfs_trans_del_item(lip);\n\t\tlip->li_ops->iop_release(lip);\n\t}\n\treturn len;\n}\n\n \nvoid\nxlog_cil_commit(\n\tstruct xlog\t\t*log,\n\tstruct xfs_trans\t*tp,\n\txfs_csn_t\t\t*commit_seq,\n\tbool\t\t\tregrant)\n{\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tstruct xfs_log_item\t*lip, *next;\n\tuint32_t\t\treleased_space = 0;\n\n\t \n\txlog_cil_alloc_shadow_bufs(log, tp);\n\n\t \n\tdown_read(&cil->xc_ctx_lock);\n\n\tif (tp->t_flags & XFS_TRANS_HAS_INTENT_DONE)\n\t\treleased_space = xlog_cil_process_intents(cil, tp);\n\n\txlog_cil_insert_items(log, tp, released_space);\n\n\tif (regrant && !xlog_is_shutdown(log))\n\t\txfs_log_ticket_regrant(log, tp->t_ticket);\n\telse\n\t\txfs_log_ticket_ungrant(log, tp->t_ticket);\n\ttp->t_ticket = NULL;\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t \n\ttrace_xfs_trans_commit_items(tp, _RET_IP_);\n\tlist_for_each_entry_safe(lip, next, &tp->t_items, li_trans) {\n\t\txfs_trans_del_item(lip);\n\t\tif (lip->li_ops->iop_committing)\n\t\t\tlip->li_ops->iop_committing(lip, cil->xc_ctx->sequence);\n\t}\n\tif (commit_seq)\n\t\t*commit_seq = cil->xc_ctx->sequence;\n\n\t \n\txlog_cil_push_background(log);\n}\n\n \nvoid\nxlog_cil_flush(\n\tstruct xlog\t*log)\n{\n\txfs_csn_t\tseq = log->l_cilp->xc_current_sequence;\n\n\ttrace_xfs_log_force(log->l_mp, seq, _RET_IP_);\n\txlog_cil_push_now(log, seq, true);\n\n\t \n\tif (test_bit(XLOG_CIL_EMPTY, &log->l_cilp->xc_flags))\n\t\txfs_log_force(log->l_mp, 0);\n}\n\n \nxfs_lsn_t\nxlog_cil_force_seq(\n\tstruct xlog\t*log,\n\txfs_csn_t\tsequence)\n{\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tstruct xfs_cil_ctx\t*ctx;\n\txfs_lsn_t\t\tcommit_lsn = NULLCOMMITLSN;\n\n\tASSERT(sequence <= cil->xc_current_sequence);\n\n\tif (!sequence)\n\t\tsequence = cil->xc_current_sequence;\n\ttrace_xfs_log_force(log->l_mp, sequence, _RET_IP_);\n\n\t \nrestart:\n\txlog_cil_push_now(log, sequence, false);\n\n\t \n\tspin_lock(&cil->xc_push_lock);\n\tlist_for_each_entry(ctx, &cil->xc_committing, committing) {\n\t\t \n\t\tif (xlog_is_shutdown(log))\n\t\t\tgoto out_shutdown;\n\t\tif (ctx->sequence > sequence)\n\t\t\tcontinue;\n\t\tif (!ctx->commit_lsn) {\n\t\t\t \n\t\t\tXFS_STATS_INC(log->l_mp, xs_log_force_sleep);\n\t\t\txlog_wait(&cil->xc_commit_wait, &cil->xc_push_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\tif (ctx->sequence != sequence)\n\t\t\tcontinue;\n\t\t \n\t\tcommit_lsn = ctx->commit_lsn;\n\t}\n\n\t \n\tif (sequence == cil->xc_current_sequence &&\n\t    !test_bit(XLOG_CIL_EMPTY, &cil->xc_flags)) {\n\t\tspin_unlock(&cil->xc_push_lock);\n\t\tgoto restart;\n\t}\n\n\tspin_unlock(&cil->xc_push_lock);\n\treturn commit_lsn;\n\n\t \nout_shutdown:\n\tspin_unlock(&cil->xc_push_lock);\n\treturn 0;\n}\n\n \nint\nxlog_cil_init(\n\tstruct xlog\t\t*log)\n{\n\tstruct xfs_cil\t\t*cil;\n\tstruct xfs_cil_ctx\t*ctx;\n\tstruct xlog_cil_pcp\t*cilpcp;\n\tint\t\t\tcpu;\n\n\tcil = kmem_zalloc(sizeof(*cil), KM_MAYFAIL);\n\tif (!cil)\n\t\treturn -ENOMEM;\n\t \n\tcil->xc_push_wq = alloc_workqueue(\"xfs-cil/%s\",\n\t\t\tXFS_WQFLAGS(WQ_FREEZABLE | WQ_MEM_RECLAIM | WQ_UNBOUND),\n\t\t\t4, log->l_mp->m_super->s_id);\n\tif (!cil->xc_push_wq)\n\t\tgoto out_destroy_cil;\n\n\tcil->xc_log = log;\n\tcil->xc_pcp = alloc_percpu(struct xlog_cil_pcp);\n\tif (!cil->xc_pcp)\n\t\tgoto out_destroy_wq;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcilpcp = per_cpu_ptr(cil->xc_pcp, cpu);\n\t\tINIT_LIST_HEAD(&cilpcp->busy_extents);\n\t\tINIT_LIST_HEAD(&cilpcp->log_items);\n\t}\n\n\tINIT_LIST_HEAD(&cil->xc_committing);\n\tspin_lock_init(&cil->xc_push_lock);\n\tinit_waitqueue_head(&cil->xc_push_wait);\n\tinit_rwsem(&cil->xc_ctx_lock);\n\tinit_waitqueue_head(&cil->xc_start_wait);\n\tinit_waitqueue_head(&cil->xc_commit_wait);\n\tlog->l_cilp = cil;\n\n\tctx = xlog_cil_ctx_alloc();\n\txlog_cil_ctx_switch(cil, ctx);\n\treturn 0;\n\nout_destroy_wq:\n\tdestroy_workqueue(cil->xc_push_wq);\nout_destroy_cil:\n\tkmem_free(cil);\n\treturn -ENOMEM;\n}\n\nvoid\nxlog_cil_destroy(\n\tstruct xlog\t*log)\n{\n\tstruct xfs_cil\t*cil = log->l_cilp;\n\n\tif (cil->xc_ctx) {\n\t\tif (cil->xc_ctx->ticket)\n\t\t\txfs_log_ticket_put(cil->xc_ctx->ticket);\n\t\tkmem_free(cil->xc_ctx);\n\t}\n\n\tASSERT(test_bit(XLOG_CIL_EMPTY, &cil->xc_flags));\n\tfree_percpu(cil->xc_pcp);\n\tdestroy_workqueue(cil->xc_push_wq);\n\tkmem_free(cil);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}