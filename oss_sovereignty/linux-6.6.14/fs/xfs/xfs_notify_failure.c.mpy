{
  "module_name": "xfs_notify_failure.c",
  "hash_id": "85507e4765483982b3618125778d2ed08e7ecc0759d075862fad49187c7cb48d",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_notify_failure.c",
  "human_readable_source": "\n \n\n#include \"xfs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_rmap.h\"\n#include \"xfs_rmap_btree.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_ag.h\"\n\n#include <linux/mm.h>\n#include <linux/dax.h>\n\nstruct xfs_failure_info {\n\txfs_agblock_t\t\tstartblock;\n\txfs_extlen_t\t\tblockcount;\n\tint\t\t\tmf_flags;\n\tbool\t\t\twant_shutdown;\n};\n\nstatic pgoff_t\nxfs_failure_pgoff(\n\tstruct xfs_mount\t\t*mp,\n\tconst struct xfs_rmap_irec\t*rec,\n\tconst struct xfs_failure_info\t*notify)\n{\n\tloff_t\t\t\t\tpos = XFS_FSB_TO_B(mp, rec->rm_offset);\n\n\tif (notify->startblock > rec->rm_startblock)\n\t\tpos += XFS_FSB_TO_B(mp,\n\t\t\t\tnotify->startblock - rec->rm_startblock);\n\treturn pos >> PAGE_SHIFT;\n}\n\nstatic unsigned long\nxfs_failure_pgcnt(\n\tstruct xfs_mount\t\t*mp,\n\tconst struct xfs_rmap_irec\t*rec,\n\tconst struct xfs_failure_info\t*notify)\n{\n\txfs_agblock_t\t\t\tend_rec;\n\txfs_agblock_t\t\t\tend_notify;\n\txfs_agblock_t\t\t\tstart_cross;\n\txfs_agblock_t\t\t\tend_cross;\n\n\tstart_cross = max(rec->rm_startblock, notify->startblock);\n\n\tend_rec = rec->rm_startblock + rec->rm_blockcount;\n\tend_notify = notify->startblock + notify->blockcount;\n\tend_cross = min(end_rec, end_notify);\n\n\treturn XFS_FSB_TO_B(mp, end_cross - start_cross) >> PAGE_SHIFT;\n}\n\nstatic int\nxfs_dax_failure_fn(\n\tstruct xfs_btree_cur\t\t*cur,\n\tconst struct xfs_rmap_irec\t*rec,\n\tvoid\t\t\t\t*data)\n{\n\tstruct xfs_mount\t\t*mp = cur->bc_mp;\n\tstruct xfs_inode\t\t*ip;\n\tstruct xfs_failure_info\t\t*notify = data;\n\tint\t\t\t\terror = 0;\n\n\tif (XFS_RMAP_NON_INODE_OWNER(rec->rm_owner) ||\n\t    (rec->rm_flags & (XFS_RMAP_ATTR_FORK | XFS_RMAP_BMBT_BLOCK))) {\n\t\tnotify->want_shutdown = true;\n\t\treturn 0;\n\t}\n\n\t \n\terror = xfs_iget(mp, cur->bc_tp, rec->rm_owner, XFS_IGET_INCORE,\n\t\t\t 0, &ip);\n\t \n\tif (error == -ENODATA)\n\t\treturn 0;\n\tif (error) {\n\t\tnotify->want_shutdown = true;\n\t\treturn 0;\n\t}\n\n\terror = mf_dax_kill_procs(VFS_I(ip)->i_mapping,\n\t\t\t\t  xfs_failure_pgoff(mp, rec, notify),\n\t\t\t\t  xfs_failure_pgcnt(mp, rec, notify),\n\t\t\t\t  notify->mf_flags);\n\txfs_irele(ip);\n\treturn error;\n}\n\nstatic int\nxfs_dax_notify_ddev_failure(\n\tstruct xfs_mount\t*mp,\n\txfs_daddr_t\t\tdaddr,\n\txfs_daddr_t\t\tbblen,\n\tint\t\t\tmf_flags)\n{\n\tstruct xfs_failure_info\tnotify = { .mf_flags = mf_flags };\n\tstruct xfs_trans\t*tp = NULL;\n\tstruct xfs_btree_cur\t*cur = NULL;\n\tstruct xfs_buf\t\t*agf_bp = NULL;\n\tint\t\t\terror = 0;\n\txfs_fsblock_t\t\tfsbno = XFS_DADDR_TO_FSB(mp, daddr);\n\txfs_agnumber_t\t\tagno = XFS_FSB_TO_AGNO(mp, fsbno);\n\txfs_fsblock_t\t\tend_fsbno = XFS_DADDR_TO_FSB(mp,\n\t\t\t\t\t\t\t     daddr + bblen - 1);\n\txfs_agnumber_t\t\tend_agno = XFS_FSB_TO_AGNO(mp, end_fsbno);\n\n\terror = xfs_trans_alloc_empty(mp, &tp);\n\tif (error)\n\t\treturn error;\n\n\tfor (; agno <= end_agno; agno++) {\n\t\tstruct xfs_rmap_irec\tri_low = { };\n\t\tstruct xfs_rmap_irec\tri_high;\n\t\tstruct xfs_agf\t\t*agf;\n\t\tstruct xfs_perag\t*pag;\n\t\txfs_agblock_t\t\trange_agend;\n\n\t\tpag = xfs_perag_get(mp, agno);\n\t\terror = xfs_alloc_read_agf(pag, tp, 0, &agf_bp);\n\t\tif (error) {\n\t\t\txfs_perag_put(pag);\n\t\t\tbreak;\n\t\t}\n\n\t\tcur = xfs_rmapbt_init_cursor(mp, tp, agf_bp, pag);\n\n\t\t \n\t\tmemset(&ri_high, 0xFF, sizeof(ri_high));\n\t\tri_low.rm_startblock = XFS_FSB_TO_AGBNO(mp, fsbno);\n\t\tif (agno == end_agno)\n\t\t\tri_high.rm_startblock = XFS_FSB_TO_AGBNO(mp, end_fsbno);\n\n\t\tagf = agf_bp->b_addr;\n\t\trange_agend = min(be32_to_cpu(agf->agf_length) - 1,\n\t\t\t\tri_high.rm_startblock);\n\t\tnotify.startblock = ri_low.rm_startblock;\n\t\tnotify.blockcount = range_agend + 1 - ri_low.rm_startblock;\n\n\t\terror = xfs_rmap_query_range(cur, &ri_low, &ri_high,\n\t\t\t\txfs_dax_failure_fn, &notify);\n\t\txfs_btree_del_cursor(cur, error);\n\t\txfs_trans_brelse(tp, agf_bp);\n\t\txfs_perag_put(pag);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tfsbno = XFS_AGB_TO_FSB(mp, agno + 1, 0);\n\t}\n\n\txfs_trans_cancel(tp);\n\tif (error || notify.want_shutdown) {\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_ONDISK);\n\t\tif (!error)\n\t\t\terror = -EFSCORRUPTED;\n\t}\n\treturn error;\n}\n\nstatic int\nxfs_dax_notify_failure(\n\tstruct dax_device\t*dax_dev,\n\tu64\t\t\toffset,\n\tu64\t\t\tlen,\n\tint\t\t\tmf_flags)\n{\n\tstruct xfs_mount\t*mp = dax_holder(dax_dev);\n\tu64\t\t\tddev_start;\n\tu64\t\t\tddev_end;\n\n\tif (!(mp->m_super->s_flags & SB_BORN)) {\n\t\txfs_warn(mp, \"filesystem is not ready for notify_failure()!\");\n\t\treturn -EIO;\n\t}\n\n\tif (mp->m_rtdev_targp && mp->m_rtdev_targp->bt_daxdev == dax_dev) {\n\t\txfs_debug(mp,\n\t\t\t \"notify_failure() not supported on realtime device!\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (mp->m_logdev_targp && mp->m_logdev_targp->bt_daxdev == dax_dev &&\n\t    mp->m_logdev_targp != mp->m_ddev_targp) {\n\t\txfs_err(mp, \"ondisk log corrupt, shutting down fs!\");\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_ONDISK);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (!xfs_has_rmapbt(mp)) {\n\t\txfs_debug(mp, \"notify_failure() needs rmapbt enabled!\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tddev_start = mp->m_ddev_targp->bt_dax_part_off;\n\tddev_end = ddev_start + bdev_nr_bytes(mp->m_ddev_targp->bt_bdev) - 1;\n\n\t \n\tif (offset + len - 1 < ddev_start)\n\t\treturn -ENXIO;\n\tif (offset > ddev_end)\n\t\treturn -ENXIO;\n\n\t \n\tif (offset > ddev_start)\n\t\toffset -= ddev_start;\n\telse {\n\t\tlen -= ddev_start - offset;\n\t\toffset = 0;\n\t}\n\tif (offset + len - 1 > ddev_end)\n\t\tlen = ddev_end - offset + 1;\n\n\treturn xfs_dax_notify_ddev_failure(mp, BTOBB(offset), BTOBB(len),\n\t\t\tmf_flags);\n}\n\nconst struct dax_holder_operations xfs_dax_holder_operations = {\n\t.notify_failure\t\t= xfs_dax_notify_failure,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}