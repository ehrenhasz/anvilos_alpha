{
  "module_name": "xfs_file.c",
  "hash_id": "0e65cac3bce1228cf81da61828bfa92a554bc7f83ccc62388fd0fee0a59f8bfc",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_file.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_pnfs.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_reflink.h\"\n\n#include <linux/dax.h>\n#include <linux/falloc.h>\n#include <linux/backing-dev.h>\n#include <linux/mman.h>\n#include <linux/fadvise.h>\n#include <linux/mount.h>\n\nstatic const struct vm_operations_struct xfs_file_vm_ops;\n\n \nstatic bool\nxfs_is_falloc_aligned(\n\tstruct xfs_inode\t*ip,\n\tloff_t\t\t\tpos,\n\tlong long int\t\tlen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint64_t\t\tmask;\n\n\tif (XFS_IS_REALTIME_INODE(ip)) {\n\t\tif (!is_power_of_2(mp->m_sb.sb_rextsize)) {\n\t\t\tu64\trextbytes;\n\t\t\tu32\tmod;\n\n\t\t\trextbytes = XFS_FSB_TO_B(mp, mp->m_sb.sb_rextsize);\n\t\t\tdiv_u64_rem(pos, rextbytes, &mod);\n\t\t\tif (mod)\n\t\t\t\treturn false;\n\t\t\tdiv_u64_rem(len, rextbytes, &mod);\n\t\t\treturn mod == 0;\n\t\t}\n\t\tmask = XFS_FSB_TO_B(mp, mp->m_sb.sb_rextsize) - 1;\n\t} else {\n\t\tmask = mp->m_sb.sb_blocksize - 1;\n\t}\n\n\treturn !((pos | len) & mask);\n}\n\n \nSTATIC int\nxfs_dir_fsync(\n\tstruct file\t\t*file,\n\tloff_t\t\t\tstart,\n\tloff_t\t\t\tend,\n\tint\t\t\tdatasync)\n{\n\tstruct xfs_inode\t*ip = XFS_I(file->f_mapping->host);\n\n\ttrace_xfs_dir_fsync(ip);\n\treturn xfs_log_force_inode(ip);\n}\n\nstatic xfs_csn_t\nxfs_fsync_seq(\n\tstruct xfs_inode\t*ip,\n\tbool\t\t\tdatasync)\n{\n\tif (!xfs_ipincount(ip))\n\t\treturn 0;\n\tif (datasync && !(ip->i_itemp->ili_fsync_fields & ~XFS_ILOG_TIMESTAMP))\n\t\treturn 0;\n\treturn ip->i_itemp->ili_commit_seq;\n}\n\n \nstatic  int\nxfs_fsync_flush_log(\n\tstruct xfs_inode\t*ip,\n\tbool\t\t\tdatasync,\n\tint\t\t\t*log_flushed)\n{\n\tint\t\t\terror = 0;\n\txfs_csn_t\t\tseq;\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\tseq = xfs_fsync_seq(ip, datasync);\n\tif (seq) {\n\t\terror = xfs_log_force_seq(ip->i_mount, seq, XFS_LOG_SYNC,\n\t\t\t\t\t  log_flushed);\n\n\t\tspin_lock(&ip->i_itemp->ili_lock);\n\t\tip->i_itemp->ili_fsync_fields = 0;\n\t\tspin_unlock(&ip->i_itemp->ili_lock);\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\treturn error;\n}\n\nSTATIC int\nxfs_file_fsync(\n\tstruct file\t\t*file,\n\tloff_t\t\t\tstart,\n\tloff_t\t\t\tend,\n\tint\t\t\tdatasync)\n{\n\tstruct xfs_inode\t*ip = XFS_I(file->f_mapping->host);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\terror, err2;\n\tint\t\t\tlog_flushed = 0;\n\n\ttrace_xfs_file_fsync(ip);\n\n\terror = file_write_and_wait_range(file, start, end);\n\tif (error)\n\t\treturn error;\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\txfs_iflags_clear(ip, XFS_ITRUNCATED);\n\n\t \n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\terror = blkdev_issue_flush(mp->m_rtdev_targp->bt_bdev);\n\telse if (mp->m_logdev_targp != mp->m_ddev_targp)\n\t\terror = blkdev_issue_flush(mp->m_ddev_targp->bt_bdev);\n\n\t \n\tif (xfs_ipincount(ip)) {\n\t\terr2 = xfs_fsync_flush_log(ip, datasync, &log_flushed);\n\t\tif (err2 && !error)\n\t\t\terror = err2;\n\t}\n\n\t \n\tif (!log_flushed && !XFS_IS_REALTIME_INODE(ip) &&\n\t    mp->m_logdev_targp == mp->m_ddev_targp) {\n\t\terr2 = blkdev_issue_flush(mp->m_ddev_targp->bt_bdev);\n\t\tif (err2 && !error)\n\t\t\terror = err2;\n\t}\n\n\treturn error;\n}\n\nstatic int\nxfs_ilock_iocb(\n\tstruct kiocb\t\t*iocb,\n\tunsigned int\t\tlock_mode)\n{\n\tstruct xfs_inode\t*ip = XFS_I(file_inode(iocb->ki_filp));\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\tif (!xfs_ilock_nowait(ip, lock_mode))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\txfs_ilock(ip, lock_mode);\n\t}\n\n\treturn 0;\n}\n\nSTATIC ssize_t\nxfs_file_dio_read(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*to)\n{\n\tstruct xfs_inode\t*ip = XFS_I(file_inode(iocb->ki_filp));\n\tssize_t\t\t\tret;\n\n\ttrace_xfs_file_direct_read(iocb, to);\n\n\tif (!iov_iter_count(to))\n\t\treturn 0;  \n\n\tfile_accessed(iocb->ki_filp);\n\n\tret = xfs_ilock_iocb(iocb, XFS_IOLOCK_SHARED);\n\tif (ret)\n\t\treturn ret;\n\tret = iomap_dio_rw(iocb, to, &xfs_read_iomap_ops, NULL, 0, NULL, 0);\n\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\n\treturn ret;\n}\n\nstatic noinline ssize_t\nxfs_file_dax_read(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*to)\n{\n\tstruct xfs_inode\t*ip = XFS_I(iocb->ki_filp->f_mapping->host);\n\tssize_t\t\t\tret = 0;\n\n\ttrace_xfs_file_dax_read(iocb, to);\n\n\tif (!iov_iter_count(to))\n\t\treturn 0;  \n\n\tret = xfs_ilock_iocb(iocb, XFS_IOLOCK_SHARED);\n\tif (ret)\n\t\treturn ret;\n\tret = dax_iomap_rw(iocb, to, &xfs_read_iomap_ops);\n\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\n\tfile_accessed(iocb->ki_filp);\n\treturn ret;\n}\n\nSTATIC ssize_t\nxfs_file_buffered_read(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*to)\n{\n\tstruct xfs_inode\t*ip = XFS_I(file_inode(iocb->ki_filp));\n\tssize_t\t\t\tret;\n\n\ttrace_xfs_file_buffered_read(iocb, to);\n\n\tret = xfs_ilock_iocb(iocb, XFS_IOLOCK_SHARED);\n\tif (ret)\n\t\treturn ret;\n\tret = generic_file_read_iter(iocb, to);\n\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\n\treturn ret;\n}\n\nSTATIC ssize_t\nxfs_file_read_iter(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*to)\n{\n\tstruct inode\t\t*inode = file_inode(iocb->ki_filp);\n\tstruct xfs_mount\t*mp = XFS_I(inode)->i_mount;\n\tssize_t\t\t\tret = 0;\n\n\tXFS_STATS_INC(mp, xs_read_calls);\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\tif (IS_DAX(inode))\n\t\tret = xfs_file_dax_read(iocb, to);\n\telse if (iocb->ki_flags & IOCB_DIRECT)\n\t\tret = xfs_file_dio_read(iocb, to);\n\telse\n\t\tret = xfs_file_buffered_read(iocb, to);\n\n\tif (ret > 0)\n\t\tXFS_STATS_ADD(mp, xs_read_bytes, ret);\n\treturn ret;\n}\n\nSTATIC ssize_t\nxfs_file_splice_read(\n\tstruct file\t\t*in,\n\tloff_t\t\t\t*ppos,\n\tstruct pipe_inode_info\t*pipe,\n\tsize_t\t\t\tlen,\n\tunsigned int\t\tflags)\n{\n\tstruct inode\t\t*inode = file_inode(in);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tssize_t\t\t\tret = 0;\n\n\tXFS_STATS_INC(mp, xs_read_calls);\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\ttrace_xfs_file_splice_read(ip, *ppos, len);\n\n\txfs_ilock(ip, XFS_IOLOCK_SHARED);\n\tret = filemap_splice_read(in, ppos, pipe, len, flags);\n\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\tif (ret > 0)\n\t\tXFS_STATS_ADD(mp, xs_read_bytes, ret);\n\treturn ret;\n}\n\n \nSTATIC ssize_t\nxfs_file_write_checks(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*from,\n\tunsigned int\t\t*iolock)\n{\n\tstruct file\t\t*file = iocb->ki_filp;\n\tstruct inode\t\t*inode = file->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tssize_t\t\t\terror = 0;\n\tsize_t\t\t\tcount = iov_iter_count(from);\n\tbool\t\t\tdrained_dio = false;\n\tloff_t\t\t\tisize;\n\nrestart:\n\terror = generic_write_checks(iocb, from);\n\tif (error <= 0)\n\t\treturn error;\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\terror = break_layout(inode, false);\n\t\tif (error == -EWOULDBLOCK)\n\t\t\terror = -EAGAIN;\n\t} else {\n\t\terror = xfs_break_layouts(inode, iolock, BREAK_WRITE);\n\t}\n\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (*iolock == XFS_IOLOCK_SHARED && !IS_NOSEC(inode)) {\n\t\txfs_iunlock(ip, *iolock);\n\t\t*iolock = XFS_IOLOCK_EXCL;\n\t\terror = xfs_ilock_iocb(iocb, *iolock);\n\t\tif (error) {\n\t\t\t*iolock = 0;\n\t\t\treturn error;\n\t\t}\n\t\tgoto restart;\n\t}\n\n\t \n\tif (iocb->ki_pos <= i_size_read(inode))\n\t\tgoto out;\n\n\tspin_lock(&ip->i_flags_lock);\n\tisize = i_size_read(inode);\n\tif (iocb->ki_pos > isize) {\n\t\tspin_unlock(&ip->i_flags_lock);\n\n\t\tif (iocb->ki_flags & IOCB_NOWAIT)\n\t\t\treturn -EAGAIN;\n\n\t\tif (!drained_dio) {\n\t\t\tif (*iolock == XFS_IOLOCK_SHARED) {\n\t\t\t\txfs_iunlock(ip, *iolock);\n\t\t\t\t*iolock = XFS_IOLOCK_EXCL;\n\t\t\t\txfs_ilock(ip, *iolock);\n\t\t\t\tiov_iter_reexpand(from, count);\n\t\t\t}\n\t\t\t \n\t\t\tinode_dio_wait(inode);\n\t\t\tdrained_dio = true;\n\t\t\tgoto restart;\n\t\t}\n\n\t\ttrace_xfs_zero_eof(ip, isize, iocb->ki_pos - isize);\n\t\terror = xfs_zero_range(ip, isize, iocb->ki_pos - isize, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t} else\n\t\tspin_unlock(&ip->i_flags_lock);\n\nout:\n\treturn kiocb_modified(iocb);\n}\n\nstatic int\nxfs_dio_write_end_io(\n\tstruct kiocb\t\t*iocb,\n\tssize_t\t\t\tsize,\n\tint\t\t\terror,\n\tunsigned\t\tflags)\n{\n\tstruct inode\t\t*inode = file_inode(iocb->ki_filp);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tloff_t\t\t\toffset = iocb->ki_pos;\n\tunsigned int\t\tnofs_flag;\n\n\ttrace_xfs_end_io_direct_write(ip, offset, size);\n\n\tif (xfs_is_shutdown(ip->i_mount))\n\t\treturn -EIO;\n\n\tif (error)\n\t\treturn error;\n\tif (!size)\n\t\treturn 0;\n\n\t \n\tXFS_STATS_ADD(ip->i_mount, xs_write_bytes, size);\n\n\t \n\tnofs_flag = memalloc_nofs_save();\n\n\tif (flags & IOMAP_DIO_COW) {\n\t\terror = xfs_reflink_end_cow(ip, offset, size);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (flags & IOMAP_DIO_UNWRITTEN) {\n\t\terror = xfs_iomap_write_unwritten(ip, offset, size, true);\n\t\tgoto out;\n\t}\n\n\t \n\tif (offset + size <= i_size_read(inode))\n\t\tgoto out;\n\n\tspin_lock(&ip->i_flags_lock);\n\tif (offset + size > i_size_read(inode)) {\n\t\ti_size_write(inode, offset + size);\n\t\tspin_unlock(&ip->i_flags_lock);\n\t\terror = xfs_setfilesize(ip, offset, size);\n\t} else {\n\t\tspin_unlock(&ip->i_flags_lock);\n\t}\n\nout:\n\tmemalloc_nofs_restore(nofs_flag);\n\treturn error;\n}\n\nstatic const struct iomap_dio_ops xfs_dio_write_ops = {\n\t.end_io\t\t= xfs_dio_write_end_io,\n};\n\n \nstatic noinline ssize_t\nxfs_file_dio_write_aligned(\n\tstruct xfs_inode\t*ip,\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*from)\n{\n\tunsigned int\t\tiolock = XFS_IOLOCK_SHARED;\n\tssize_t\t\t\tret;\n\n\tret = xfs_ilock_iocb(iocb, iolock);\n\tif (ret)\n\t\treturn ret;\n\tret = xfs_file_write_checks(iocb, from, &iolock);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tif (iolock == XFS_IOLOCK_EXCL) {\n\t\txfs_ilock_demote(ip, XFS_IOLOCK_EXCL);\n\t\tiolock = XFS_IOLOCK_SHARED;\n\t}\n\ttrace_xfs_file_direct_write(iocb, from);\n\tret = iomap_dio_rw(iocb, from, &xfs_direct_write_iomap_ops,\n\t\t\t   &xfs_dio_write_ops, 0, NULL, 0);\nout_unlock:\n\tif (iolock)\n\t\txfs_iunlock(ip, iolock);\n\treturn ret;\n}\n\n \nstatic noinline ssize_t\nxfs_file_dio_write_unaligned(\n\tstruct xfs_inode\t*ip,\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*from)\n{\n\tsize_t\t\t\tisize = i_size_read(VFS_I(ip));\n\tsize_t\t\t\tcount = iov_iter_count(from);\n\tunsigned int\t\tiolock = XFS_IOLOCK_SHARED;\n\tunsigned int\t\tflags = IOMAP_DIO_OVERWRITE_ONLY;\n\tssize_t\t\t\tret;\n\n\t \n\tif (iocb->ki_pos > isize || iocb->ki_pos + count >= isize) {\n\t\tif (iocb->ki_flags & IOCB_NOWAIT)\n\t\t\treturn -EAGAIN;\nretry_exclusive:\n\t\tiolock = XFS_IOLOCK_EXCL;\n\t\tflags = IOMAP_DIO_FORCE_WAIT;\n\t}\n\n\tret = xfs_ilock_iocb(iocb, iolock);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (xfs_is_cow_inode(ip)) {\n\t\ttrace_xfs_reflink_bounce_dio_write(iocb, from);\n\t\tret = -ENOTBLK;\n\t\tgoto out_unlock;\n\t}\n\n\tret = xfs_file_write_checks(iocb, from, &iolock);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tif (flags & IOMAP_DIO_FORCE_WAIT)\n\t\tinode_dio_wait(VFS_I(ip));\n\n\ttrace_xfs_file_direct_write(iocb, from);\n\tret = iomap_dio_rw(iocb, from, &xfs_direct_write_iomap_ops,\n\t\t\t   &xfs_dio_write_ops, flags, NULL, 0);\n\n\t \n\tif (ret == -EAGAIN && !(iocb->ki_flags & IOCB_NOWAIT)) {\n\t\tASSERT(flags & IOMAP_DIO_OVERWRITE_ONLY);\n\t\txfs_iunlock(ip, iolock);\n\t\tgoto retry_exclusive;\n\t}\n\nout_unlock:\n\tif (iolock)\n\t\txfs_iunlock(ip, iolock);\n\treturn ret;\n}\n\nstatic ssize_t\nxfs_file_dio_write(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*from)\n{\n\tstruct xfs_inode\t*ip = XFS_I(file_inode(iocb->ki_filp));\n\tstruct xfs_buftarg      *target = xfs_inode_buftarg(ip);\n\tsize_t\t\t\tcount = iov_iter_count(from);\n\n\t \n\tif ((iocb->ki_pos | count) & target->bt_logical_sectormask)\n\t\treturn -EINVAL;\n\tif ((iocb->ki_pos | count) & ip->i_mount->m_blockmask)\n\t\treturn xfs_file_dio_write_unaligned(ip, iocb, from);\n\treturn xfs_file_dio_write_aligned(ip, iocb, from);\n}\n\nstatic noinline ssize_t\nxfs_file_dax_write(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*from)\n{\n\tstruct inode\t\t*inode = iocb->ki_filp->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tunsigned int\t\tiolock = XFS_IOLOCK_EXCL;\n\tssize_t\t\t\tret, error = 0;\n\tloff_t\t\t\tpos;\n\n\tret = xfs_ilock_iocb(iocb, iolock);\n\tif (ret)\n\t\treturn ret;\n\tret = xfs_file_write_checks(iocb, from, &iolock);\n\tif (ret)\n\t\tgoto out;\n\n\tpos = iocb->ki_pos;\n\n\ttrace_xfs_file_dax_write(iocb, from);\n\tret = dax_iomap_rw(iocb, from, &xfs_dax_write_iomap_ops);\n\tif (ret > 0 && iocb->ki_pos > i_size_read(inode)) {\n\t\ti_size_write(inode, iocb->ki_pos);\n\t\terror = xfs_setfilesize(ip, pos, ret);\n\t}\nout:\n\tif (iolock)\n\t\txfs_iunlock(ip, iolock);\n\tif (error)\n\t\treturn error;\n\n\tif (ret > 0) {\n\t\tXFS_STATS_ADD(ip->i_mount, xs_write_bytes, ret);\n\n\t\t \n\t\tret = generic_write_sync(iocb, ret);\n\t}\n\treturn ret;\n}\n\nSTATIC ssize_t\nxfs_file_buffered_write(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*from)\n{\n\tstruct inode\t\t*inode = iocb->ki_filp->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tssize_t\t\t\tret;\n\tbool\t\t\tcleared_space = false;\n\tunsigned int\t\tiolock;\n\nwrite_retry:\n\tiolock = XFS_IOLOCK_EXCL;\n\tret = xfs_ilock_iocb(iocb, iolock);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xfs_file_write_checks(iocb, from, &iolock);\n\tif (ret)\n\t\tgoto out;\n\n\ttrace_xfs_file_buffered_write(iocb, from);\n\tret = iomap_file_buffered_write(iocb, from,\n\t\t\t&xfs_buffered_write_iomap_ops);\n\n\t \n\tif (ret == -EDQUOT && !cleared_space) {\n\t\txfs_iunlock(ip, iolock);\n\t\txfs_blockgc_free_quota(ip, XFS_ICWALK_FLAG_SYNC);\n\t\tcleared_space = true;\n\t\tgoto write_retry;\n\t} else if (ret == -ENOSPC && !cleared_space) {\n\t\tstruct xfs_icwalk\ticw = {0};\n\n\t\tcleared_space = true;\n\t\txfs_flush_inodes(ip->i_mount);\n\n\t\txfs_iunlock(ip, iolock);\n\t\ticw.icw_flags = XFS_ICWALK_FLAG_SYNC;\n\t\txfs_blockgc_free_space(ip->i_mount, &icw);\n\t\tgoto write_retry;\n\t}\n\nout:\n\tif (iolock)\n\t\txfs_iunlock(ip, iolock);\n\n\tif (ret > 0) {\n\t\tXFS_STATS_ADD(ip->i_mount, xs_write_bytes, ret);\n\t\t \n\t\tret = generic_write_sync(iocb, ret);\n\t}\n\treturn ret;\n}\n\nSTATIC ssize_t\nxfs_file_write_iter(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*from)\n{\n\tstruct inode\t\t*inode = iocb->ki_filp->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tssize_t\t\t\tret;\n\tsize_t\t\t\tocount = iov_iter_count(from);\n\n\tXFS_STATS_INC(ip->i_mount, xs_write_calls);\n\n\tif (ocount == 0)\n\t\treturn 0;\n\n\tif (xfs_is_shutdown(ip->i_mount))\n\t\treturn -EIO;\n\n\tif (IS_DAX(inode))\n\t\treturn xfs_file_dax_write(iocb, from);\n\n\tif (iocb->ki_flags & IOCB_DIRECT) {\n\t\t \n\t\tret = xfs_file_dio_write(iocb, from);\n\t\tif (ret != -ENOTBLK)\n\t\t\treturn ret;\n\t}\n\n\treturn xfs_file_buffered_write(iocb, from);\n}\n\nstatic void\nxfs_wait_dax_page(\n\tstruct inode\t\t*inode)\n{\n\tstruct xfs_inode        *ip = XFS_I(inode);\n\n\txfs_iunlock(ip, XFS_MMAPLOCK_EXCL);\n\tschedule();\n\txfs_ilock(ip, XFS_MMAPLOCK_EXCL);\n}\n\nint\nxfs_break_dax_layouts(\n\tstruct inode\t\t*inode,\n\tbool\t\t\t*retry)\n{\n\tstruct page\t\t*page;\n\n\tASSERT(xfs_isilocked(XFS_I(inode), XFS_MMAPLOCK_EXCL));\n\n\tpage = dax_layout_busy_page(inode->i_mapping);\n\tif (!page)\n\t\treturn 0;\n\n\t*retry = true;\n\treturn ___wait_var_event(&page->_refcount,\n\t\t\tatomic_read(&page->_refcount) == 1, TASK_INTERRUPTIBLE,\n\t\t\t0, 0, xfs_wait_dax_page(inode));\n}\n\nint\nxfs_break_layouts(\n\tstruct inode\t\t*inode,\n\tuint\t\t\t*iolock,\n\tenum layout_break_reason reason)\n{\n\tbool\t\t\tretry;\n\tint\t\t\terror;\n\n\tASSERT(xfs_isilocked(XFS_I(inode), XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL));\n\n\tdo {\n\t\tretry = false;\n\t\tswitch (reason) {\n\t\tcase BREAK_UNMAP:\n\t\t\terror = xfs_break_dax_layouts(inode, &retry);\n\t\t\tif (error || retry)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase BREAK_WRITE:\n\t\t\terror = xfs_break_leased_layouts(inode, iolock, &retry);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\terror = -EINVAL;\n\t\t}\n\t} while (error == 0 && retry);\n\n\treturn error;\n}\n\n \nstatic inline bool xfs_file_sync_writes(struct file *filp)\n{\n\tstruct xfs_inode\t*ip = XFS_I(file_inode(filp));\n\n\tif (xfs_has_wsync(ip->i_mount))\n\t\treturn true;\n\tif (filp->f_flags & (__O_SYNC | O_DSYNC))\n\t\treturn true;\n\tif (IS_SYNC(file_inode(filp)))\n\t\treturn true;\n\n\treturn false;\n}\n\n#define\tXFS_FALLOC_FL_SUPPORTED\t\t\t\t\t\t\\\n\t\t(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |\t\t\\\n\t\t FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_ZERO_RANGE |\t\\\n\t\t FALLOC_FL_INSERT_RANGE | FALLOC_FL_UNSHARE_RANGE)\n\nSTATIC long\nxfs_file_fallocate(\n\tstruct file\t\t*file,\n\tint\t\t\tmode,\n\tloff_t\t\t\toffset,\n\tloff_t\t\t\tlen)\n{\n\tstruct inode\t\t*inode = file_inode(file);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tlong\t\t\terror;\n\tuint\t\t\tiolock = XFS_IOLOCK_EXCL | XFS_MMAPLOCK_EXCL;\n\tloff_t\t\t\tnew_size = 0;\n\tbool\t\t\tdo_file_insert = false;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\tif (mode & ~XFS_FALLOC_FL_SUPPORTED)\n\t\treturn -EOPNOTSUPP;\n\n\txfs_ilock(ip, iolock);\n\terror = xfs_break_layouts(inode, &iolock, BREAK_UNMAP);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t \n\tinode_dio_wait(inode);\n\n\t \n\tif (mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE |\n\t\t    FALLOC_FL_COLLAPSE_RANGE)) {\n\t\terror = xfs_flush_unmap_range(ip, offset, len);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\t}\n\n\terror = file_modified(file);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE) {\n\t\terror = xfs_free_file_space(ip, offset, len);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\t} else if (mode & FALLOC_FL_COLLAPSE_RANGE) {\n\t\tif (!xfs_is_falloc_aligned(ip, offset, len)) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tif (offset + len >= i_size_read(inode)) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tnew_size = i_size_read(inode) - len;\n\n\t\terror = xfs_collapse_file_space(ip, offset, len);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\t} else if (mode & FALLOC_FL_INSERT_RANGE) {\n\t\tloff_t\t\tisize = i_size_read(inode);\n\n\t\tif (!xfs_is_falloc_aligned(ip, offset, len)) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tif (inode->i_sb->s_maxbytes - isize < len) {\n\t\t\terror = -EFBIG;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tnew_size = isize + len;\n\n\t\t \n\t\tif (offset >= isize) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tdo_file_insert = true;\n\t} else {\n\t\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t\t    offset + len > i_size_read(inode)) {\n\t\t\tnew_size = offset + len;\n\t\t\terror = inode_newsize_ok(inode, new_size);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (mode & FALLOC_FL_ZERO_RANGE) {\n\t\t\t \n\t\t\tunsigned int blksize = i_blocksize(inode);\n\n\t\t\ttrace_xfs_zero_file_space(ip);\n\n\t\t\terror = xfs_free_file_space(ip, offset, len);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tlen = round_up(offset + len, blksize) -\n\t\t\t      round_down(offset, blksize);\n\t\t\toffset = round_down(offset, blksize);\n\t\t} else if (mode & FALLOC_FL_UNSHARE_RANGE) {\n\t\t\terror = xfs_reflink_unshare(ip, offset, len);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock;\n\t\t} else {\n\t\t\t \n\t\t\tif (xfs_is_always_cow_inode(ip)) {\n\t\t\t\terror = -EOPNOTSUPP;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\tif (!xfs_is_always_cow_inode(ip)) {\n\t\t\terror = xfs_alloc_file_space(ip, offset, len);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t \n\tif (new_size) {\n\t\tstruct iattr iattr;\n\n\t\tiattr.ia_valid = ATTR_SIZE;\n\t\tiattr.ia_size = new_size;\n\t\terror = xfs_vn_setattr_size(file_mnt_idmap(file),\n\t\t\t\t\t    file_dentry(file), &iattr);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (do_file_insert) {\n\t\terror = xfs_insert_file_space(ip, offset, len);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (xfs_file_sync_writes(file))\n\t\terror = xfs_log_force_inode(ip);\n\nout_unlock:\n\txfs_iunlock(ip, iolock);\n\treturn error;\n}\n\nSTATIC int\nxfs_file_fadvise(\n\tstruct file\t*file,\n\tloff_t\t\tstart,\n\tloff_t\t\tend,\n\tint\t\tadvice)\n{\n\tstruct xfs_inode *ip = XFS_I(file_inode(file));\n\tint ret;\n\tint lockflags = 0;\n\n\t \n\tif (advice == POSIX_FADV_WILLNEED) {\n\t\tlockflags = XFS_IOLOCK_SHARED;\n\t\txfs_ilock(ip, lockflags);\n\t}\n\tret = generic_fadvise(file, start, end, advice);\n\tif (lockflags)\n\t\txfs_iunlock(ip, lockflags);\n\treturn ret;\n}\n\nSTATIC loff_t\nxfs_file_remap_range(\n\tstruct file\t\t*file_in,\n\tloff_t\t\t\tpos_in,\n\tstruct file\t\t*file_out,\n\tloff_t\t\t\tpos_out,\n\tloff_t\t\t\tlen,\n\tunsigned int\t\tremap_flags)\n{\n\tstruct inode\t\t*inode_in = file_inode(file_in);\n\tstruct xfs_inode\t*src = XFS_I(inode_in);\n\tstruct inode\t\t*inode_out = file_inode(file_out);\n\tstruct xfs_inode\t*dest = XFS_I(inode_out);\n\tstruct xfs_mount\t*mp = src->i_mount;\n\tloff_t\t\t\tremapped = 0;\n\txfs_extlen_t\t\tcowextsize;\n\tint\t\t\tret;\n\n\tif (remap_flags & ~(REMAP_FILE_DEDUP | REMAP_FILE_ADVISORY))\n\t\treturn -EINVAL;\n\n\tif (!xfs_has_reflink(mp))\n\t\treturn -EOPNOTSUPP;\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\t \n\tret = xfs_reflink_remap_prep(file_in, pos_in, file_out, pos_out,\n\t\t\t&len, remap_flags);\n\tif (ret || len == 0)\n\t\treturn ret;\n\n\ttrace_xfs_reflink_remap_range(src, pos_in, len, dest, pos_out);\n\n\tret = xfs_reflink_remap_blocks(src, pos_in, dest, pos_out, len,\n\t\t\t&remapped);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tcowextsize = 0;\n\tif (pos_in == 0 && len == i_size_read(inode_in) &&\n\t    (src->i_diflags2 & XFS_DIFLAG2_COWEXTSIZE) &&\n\t    pos_out == 0 && len >= i_size_read(inode_out) &&\n\t    !(dest->i_diflags2 & XFS_DIFLAG2_COWEXTSIZE))\n\t\tcowextsize = src->i_cowextsize;\n\n\tret = xfs_reflink_update_dest(dest, pos_out + len, cowextsize,\n\t\t\tremap_flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (xfs_file_sync_writes(file_in) || xfs_file_sync_writes(file_out))\n\t\txfs_log_force_inode(dest);\nout_unlock:\n\txfs_iunlock2_io_mmap(src, dest);\n\tif (ret)\n\t\ttrace_xfs_reflink_remap_range_error(dest, ret, _RET_IP_);\n\treturn remapped > 0 ? remapped : ret;\n}\n\nSTATIC int\nxfs_file_open(\n\tstruct inode\t*inode,\n\tstruct file\t*file)\n{\n\tif (xfs_is_shutdown(XFS_M(inode->i_sb)))\n\t\treturn -EIO;\n\tfile->f_mode |= FMODE_NOWAIT | FMODE_BUF_RASYNC | FMODE_BUF_WASYNC |\n\t\t\tFMODE_DIO_PARALLEL_WRITE | FMODE_CAN_ODIRECT;\n\treturn generic_file_open(inode, file);\n}\n\nSTATIC int\nxfs_dir_open(\n\tstruct inode\t*inode,\n\tstruct file\t*file)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tunsigned int\tmode;\n\tint\t\terror;\n\n\terror = xfs_file_open(inode, file);\n\tif (error)\n\t\treturn error;\n\n\t \n\tmode = xfs_ilock_data_map_shared(ip);\n\tif (ip->i_df.if_nextents > 0)\n\t\terror = xfs_dir3_data_readahead(ip, 0, 0);\n\txfs_iunlock(ip, mode);\n\treturn error;\n}\n\nSTATIC int\nxfs_file_release(\n\tstruct inode\t*inode,\n\tstruct file\t*filp)\n{\n\treturn xfs_release(XFS_I(inode));\n}\n\nSTATIC int\nxfs_file_readdir(\n\tstruct file\t*file,\n\tstruct dir_context *ctx)\n{\n\tstruct inode\t*inode = file_inode(file);\n\txfs_inode_t\t*ip = XFS_I(inode);\n\tsize_t\t\tbufsize;\n\n\t \n\tbufsize = (size_t)min_t(loff_t, XFS_READDIR_BUFSIZE, ip->i_disk_size);\n\n\treturn xfs_readdir(NULL, ip, ctx, bufsize);\n}\n\nSTATIC loff_t\nxfs_file_llseek(\n\tstruct file\t*file,\n\tloff_t\t\toffset,\n\tint\t\twhence)\n{\n\tstruct inode\t\t*inode = file->f_mapping->host;\n\n\tif (xfs_is_shutdown(XFS_I(inode)->i_mount))\n\t\treturn -EIO;\n\n\tswitch (whence) {\n\tdefault:\n\t\treturn generic_file_llseek(file, offset, whence);\n\tcase SEEK_HOLE:\n\t\toffset = iomap_seek_hole(inode, offset, &xfs_seek_iomap_ops);\n\t\tbreak;\n\tcase SEEK_DATA:\n\t\toffset = iomap_seek_data(inode, offset, &xfs_seek_iomap_ops);\n\t\tbreak;\n\t}\n\n\tif (offset < 0)\n\t\treturn offset;\n\treturn vfs_setpos(file, offset, inode->i_sb->s_maxbytes);\n}\n\n#ifdef CONFIG_FS_DAX\nstatic inline vm_fault_t\nxfs_dax_fault(\n\tstruct vm_fault\t\t*vmf,\n\tunsigned int\t\torder,\n\tbool\t\t\twrite_fault,\n\tpfn_t\t\t\t*pfn)\n{\n\treturn dax_iomap_fault(vmf, order, pfn, NULL,\n\t\t\t(write_fault && !vmf->cow_page) ?\n\t\t\t\t&xfs_dax_write_iomap_ops :\n\t\t\t\t&xfs_read_iomap_ops);\n}\n#else\nstatic inline vm_fault_t\nxfs_dax_fault(\n\tstruct vm_fault\t\t*vmf,\n\tunsigned int\t\torder,\n\tbool\t\t\twrite_fault,\n\tpfn_t\t\t\t*pfn)\n{\n\tASSERT(0);\n\treturn VM_FAULT_SIGBUS;\n}\n#endif\n\n \nstatic vm_fault_t\n__xfs_filemap_fault(\n\tstruct vm_fault\t\t*vmf,\n\tunsigned int\t\torder,\n\tbool\t\t\twrite_fault)\n{\n\tstruct inode\t\t*inode = file_inode(vmf->vma->vm_file);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tvm_fault_t\t\tret;\n\n\ttrace_xfs_filemap_fault(ip, order, write_fault);\n\n\tif (write_fault) {\n\t\tsb_start_pagefault(inode->i_sb);\n\t\tfile_update_time(vmf->vma->vm_file);\n\t}\n\n\tif (IS_DAX(inode)) {\n\t\tpfn_t pfn;\n\n\t\txfs_ilock(XFS_I(inode), XFS_MMAPLOCK_SHARED);\n\t\tret = xfs_dax_fault(vmf, order, write_fault, &pfn);\n\t\tif (ret & VM_FAULT_NEEDDSYNC)\n\t\t\tret = dax_finish_sync_fault(vmf, order, pfn);\n\t\txfs_iunlock(XFS_I(inode), XFS_MMAPLOCK_SHARED);\n\t} else {\n\t\tif (write_fault) {\n\t\t\txfs_ilock(XFS_I(inode), XFS_MMAPLOCK_SHARED);\n\t\t\tret = iomap_page_mkwrite(vmf,\n\t\t\t\t\t&xfs_page_mkwrite_iomap_ops);\n\t\t\txfs_iunlock(XFS_I(inode), XFS_MMAPLOCK_SHARED);\n\t\t} else {\n\t\t\tret = filemap_fault(vmf);\n\t\t}\n\t}\n\n\tif (write_fault)\n\t\tsb_end_pagefault(inode->i_sb);\n\treturn ret;\n}\n\nstatic inline bool\nxfs_is_write_fault(\n\tstruct vm_fault\t\t*vmf)\n{\n\treturn (vmf->flags & FAULT_FLAG_WRITE) &&\n\t       (vmf->vma->vm_flags & VM_SHARED);\n}\n\nstatic vm_fault_t\nxfs_filemap_fault(\n\tstruct vm_fault\t\t*vmf)\n{\n\t \n\treturn __xfs_filemap_fault(vmf, 0,\n\t\t\tIS_DAX(file_inode(vmf->vma->vm_file)) &&\n\t\t\txfs_is_write_fault(vmf));\n}\n\nstatic vm_fault_t\nxfs_filemap_huge_fault(\n\tstruct vm_fault\t\t*vmf,\n\tunsigned int\t\torder)\n{\n\tif (!IS_DAX(file_inode(vmf->vma->vm_file)))\n\t\treturn VM_FAULT_FALLBACK;\n\n\t \n\treturn __xfs_filemap_fault(vmf, order,\n\t\t\txfs_is_write_fault(vmf));\n}\n\nstatic vm_fault_t\nxfs_filemap_page_mkwrite(\n\tstruct vm_fault\t\t*vmf)\n{\n\treturn __xfs_filemap_fault(vmf, 0, true);\n}\n\n \nstatic vm_fault_t\nxfs_filemap_pfn_mkwrite(\n\tstruct vm_fault\t\t*vmf)\n{\n\n\treturn __xfs_filemap_fault(vmf, 0, true);\n}\n\nstatic const struct vm_operations_struct xfs_file_vm_ops = {\n\t.fault\t\t= xfs_filemap_fault,\n\t.huge_fault\t= xfs_filemap_huge_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= xfs_filemap_page_mkwrite,\n\t.pfn_mkwrite\t= xfs_filemap_pfn_mkwrite,\n};\n\nSTATIC int\nxfs_file_mmap(\n\tstruct file\t\t*file,\n\tstruct vm_area_struct\t*vma)\n{\n\tstruct inode\t\t*inode = file_inode(file);\n\tstruct xfs_buftarg\t*target = xfs_inode_buftarg(XFS_I(inode));\n\n\t \n\tif (!daxdev_mapping_supported(vma, target->bt_daxdev))\n\t\treturn -EOPNOTSUPP;\n\n\tfile_accessed(file);\n\tvma->vm_ops = &xfs_file_vm_ops;\n\tif (IS_DAX(inode))\n\t\tvm_flags_set(vma, VM_HUGEPAGE);\n\treturn 0;\n}\n\nconst struct file_operations xfs_file_operations = {\n\t.llseek\t\t= xfs_file_llseek,\n\t.read_iter\t= xfs_file_read_iter,\n\t.write_iter\t= xfs_file_write_iter,\n\t.splice_read\t= xfs_file_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n\t.iopoll\t\t= iocb_bio_iopoll,\n\t.unlocked_ioctl\t= xfs_file_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= xfs_file_compat_ioctl,\n#endif\n\t.mmap\t\t= xfs_file_mmap,\n\t.mmap_supported_flags = MAP_SYNC,\n\t.open\t\t= xfs_file_open,\n\t.release\t= xfs_file_release,\n\t.fsync\t\t= xfs_file_fsync,\n\t.get_unmapped_area = thp_get_unmapped_area,\n\t.fallocate\t= xfs_file_fallocate,\n\t.fadvise\t= xfs_file_fadvise,\n\t.remap_file_range = xfs_file_remap_range,\n};\n\nconst struct file_operations xfs_dir_file_operations = {\n\t.open\t\t= xfs_dir_open,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= xfs_file_readdir,\n\t.llseek\t\t= generic_file_llseek,\n\t.unlocked_ioctl\t= xfs_file_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= xfs_file_compat_ioctl,\n#endif\n\t.fsync\t\t= xfs_dir_fsync,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}