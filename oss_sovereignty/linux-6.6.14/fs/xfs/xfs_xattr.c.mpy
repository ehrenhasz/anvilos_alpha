{
  "module_name": "xfs_xattr.c",
  "hash_id": "9004eefeb8d897f769d6e63e49c6908c899ee2446dc260d38212d37b0490b76a",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_xattr.c",
  "human_readable_source": "\n \n\n#include \"xfs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_log.h\"\n#include \"xfs_xattr.h\"\n\n#include <linux/posix_acl_xattr.h>\n\n \nstatic inline int\nxfs_attr_grab_log_assist(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\terror = 0;\n\n\t \n\txlog_use_incompat_feat(mp->m_log);\n\n\t \n\tif (xfs_sb_version_haslogxattrs(&mp->m_sb))\n\t\treturn 0;\n\n\t \n\tif (!xfs_has_reflink(mp) && !xfs_has_rmapbt(mp)) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto drop_incompat;\n\t}\n\n\t \n\terror = xfs_add_incompat_log_feature(mp,\n\t\t\tXFS_SB_FEAT_INCOMPAT_LOG_XATTRS);\n\tif (error)\n\t\tgoto drop_incompat;\n\n\txfs_warn_mount(mp, XFS_OPSTATE_WARNED_LARP,\n \"EXPERIMENTAL logged extended attributes feature in use. Use at your own risk!\");\n\n\treturn 0;\ndrop_incompat:\n\txlog_drop_incompat_feat(mp->m_log);\n\treturn error;\n}\n\nstatic inline void\nxfs_attr_rele_log_assist(\n\tstruct xfs_mount\t*mp)\n{\n\txlog_drop_incompat_feat(mp->m_log);\n}\n\nstatic inline bool\nxfs_attr_want_log_assist(\n\tstruct xfs_mount\t*mp)\n{\n#ifdef DEBUG\n\t \n\treturn xfs_has_crc(mp) && xfs_globals.larp;\n#else\n\treturn false;\n#endif\n}\n\n \nint\nxfs_attr_change(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tbool\t\t\tuse_logging = false;\n\tint\t\t\terror;\n\n\tASSERT(!(args->op_flags & XFS_DA_OP_LOGGED));\n\n\tif (xfs_attr_want_log_assist(mp)) {\n\t\terror = xfs_attr_grab_log_assist(mp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\targs->op_flags |= XFS_DA_OP_LOGGED;\n\t\tuse_logging = true;\n\t}\n\n\terror = xfs_attr_set(args);\n\n\tif (use_logging)\n\t\txfs_attr_rele_log_assist(mp);\n\treturn error;\n}\n\n\nstatic int\nxfs_xattr_get(const struct xattr_handler *handler, struct dentry *unused,\n\t\tstruct inode *inode, const char *name, void *value, size_t size)\n{\n\tstruct xfs_da_args\targs = {\n\t\t.dp\t\t= XFS_I(inode),\n\t\t.attr_filter\t= handler->flags,\n\t\t.name\t\t= name,\n\t\t.namelen\t= strlen(name),\n\t\t.value\t\t= value,\n\t\t.valuelen\t= size,\n\t};\n\tint\t\t\terror;\n\n\terror = xfs_attr_get(&args);\n\tif (error)\n\t\treturn error;\n\treturn args.valuelen;\n}\n\nstatic int\nxfs_xattr_set(const struct xattr_handler *handler,\n\t      struct mnt_idmap *idmap, struct dentry *unused,\n\t      struct inode *inode, const char *name, const void *value,\n\t      size_t size, int flags)\n{\n\tstruct xfs_da_args\targs = {\n\t\t.dp\t\t= XFS_I(inode),\n\t\t.attr_filter\t= handler->flags,\n\t\t.attr_flags\t= flags,\n\t\t.name\t\t= name,\n\t\t.namelen\t= strlen(name),\n\t\t.value\t\t= (void *)value,\n\t\t.valuelen\t= size,\n\t};\n\tint\t\t\terror;\n\n\terror = xfs_attr_change(&args);\n\tif (!error && (handler->flags & XFS_ATTR_ROOT))\n\t\txfs_forget_acl(inode, name);\n\treturn error;\n}\n\nstatic const struct xattr_handler xfs_xattr_user_handler = {\n\t.prefix\t= XATTR_USER_PREFIX,\n\t.flags\t= 0,  \n\t.get\t= xfs_xattr_get,\n\t.set\t= xfs_xattr_set,\n};\n\nstatic const struct xattr_handler xfs_xattr_trusted_handler = {\n\t.prefix\t= XATTR_TRUSTED_PREFIX,\n\t.flags\t= XFS_ATTR_ROOT,\n\t.get\t= xfs_xattr_get,\n\t.set\t= xfs_xattr_set,\n};\n\nstatic const struct xattr_handler xfs_xattr_security_handler = {\n\t.prefix\t= XATTR_SECURITY_PREFIX,\n\t.flags\t= XFS_ATTR_SECURE,\n\t.get\t= xfs_xattr_get,\n\t.set\t= xfs_xattr_set,\n};\n\nconst struct xattr_handler *xfs_xattr_handlers[] = {\n\t&xfs_xattr_user_handler,\n\t&xfs_xattr_trusted_handler,\n\t&xfs_xattr_security_handler,\n\tNULL\n};\n\nstatic void\n__xfs_xattr_put_listent(\n\tstruct xfs_attr_list_context *context,\n\tchar *prefix,\n\tint prefix_len,\n\tunsigned char *name,\n\tint namelen)\n{\n\tchar *offset;\n\tint arraytop;\n\n\tif (context->count < 0 || context->seen_enough)\n\t\treturn;\n\n\tif (!context->buffer)\n\t\tgoto compute_size;\n\n\tarraytop = context->count + prefix_len + namelen + 1;\n\tif (arraytop > context->firstu) {\n\t\tcontext->count = -1;\t \n\t\tcontext->seen_enough = 1;\n\t\treturn;\n\t}\n\toffset = context->buffer + context->count;\n\tmemcpy(offset, prefix, prefix_len);\n\toffset += prefix_len;\n\tstrncpy(offset, (char *)name, namelen);\t\t\t \n\toffset += namelen;\n\t*offset = '\\0';\n\ncompute_size:\n\tcontext->count += prefix_len + namelen + 1;\n\treturn;\n}\n\nstatic void\nxfs_xattr_put_listent(\n\tstruct xfs_attr_list_context *context,\n\tint\t\tflags,\n\tunsigned char\t*name,\n\tint\t\tnamelen,\n\tint\t\tvaluelen)\n{\n\tchar *prefix;\n\tint prefix_len;\n\n\tASSERT(context->count >= 0);\n\n\tif (flags & XFS_ATTR_ROOT) {\n#ifdef CONFIG_XFS_POSIX_ACL\n\t\tif (namelen == SGI_ACL_FILE_SIZE &&\n\t\t    strncmp(name, SGI_ACL_FILE,\n\t\t\t    SGI_ACL_FILE_SIZE) == 0) {\n\t\t\t__xfs_xattr_put_listent(\n\t\t\t\t\tcontext, XATTR_SYSTEM_PREFIX,\n\t\t\t\t\tXATTR_SYSTEM_PREFIX_LEN,\n\t\t\t\t\tXATTR_POSIX_ACL_ACCESS,\n\t\t\t\t\tstrlen(XATTR_POSIX_ACL_ACCESS));\n\t\t} else if (namelen == SGI_ACL_DEFAULT_SIZE &&\n\t\t\t strncmp(name, SGI_ACL_DEFAULT,\n\t\t\t\t SGI_ACL_DEFAULT_SIZE) == 0) {\n\t\t\t__xfs_xattr_put_listent(\n\t\t\t\t\tcontext, XATTR_SYSTEM_PREFIX,\n\t\t\t\t\tXATTR_SYSTEM_PREFIX_LEN,\n\t\t\t\t\tXATTR_POSIX_ACL_DEFAULT,\n\t\t\t\t\tstrlen(XATTR_POSIX_ACL_DEFAULT));\n\t\t}\n#endif\n\n\t\t \n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn;\n\n\t\tprefix = XATTR_TRUSTED_PREFIX;\n\t\tprefix_len = XATTR_TRUSTED_PREFIX_LEN;\n\t} else if (flags & XFS_ATTR_SECURE) {\n\t\tprefix = XATTR_SECURITY_PREFIX;\n\t\tprefix_len = XATTR_SECURITY_PREFIX_LEN;\n\t} else {\n\t\tprefix = XATTR_USER_PREFIX;\n\t\tprefix_len = XATTR_USER_PREFIX_LEN;\n\t}\n\n\t__xfs_xattr_put_listent(context, prefix, prefix_len, name,\n\t\t\t\tnamelen);\n\treturn;\n}\n\nssize_t\nxfs_vn_listxattr(\n\tstruct dentry\t*dentry,\n\tchar\t\t*data,\n\tsize_t\t\tsize)\n{\n\tstruct xfs_attr_list_context context;\n\tstruct inode\t*inode = d_inode(dentry);\n\tint\t\terror;\n\n\t \n\tmemset(&context, 0, sizeof(context));\n\tcontext.dp = XFS_I(inode);\n\tcontext.resynch = 1;\n\tcontext.buffer = size ? data : NULL;\n\tcontext.bufsize = size;\n\tcontext.firstu = context.bufsize;\n\tcontext.put_listent = xfs_xattr_put_listent;\n\n\terror = xfs_attr_list(&context);\n\tif (error)\n\t\treturn error;\n\tif (context.count < 0)\n\t\treturn -ERANGE;\n\n\treturn context.count;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}