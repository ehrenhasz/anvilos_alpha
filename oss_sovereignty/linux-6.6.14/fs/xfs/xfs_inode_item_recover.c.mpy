{
  "module_name": "xfs_inode_item_recover.c",
  "hash_id": "2c081fe26bcefae82e78a1907e765bf65428a542d64be4a3906fcf61d2da782e",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_inode_item_recover.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_bmap_btree.h\"\n\nSTATIC void\nxlog_recover_inode_ra_pass2(\n\tstruct xlog                     *log,\n\tstruct xlog_recover_item        *item)\n{\n\tif (item->ri_buf[0].i_len == sizeof(struct xfs_inode_log_format)) {\n\t\tstruct xfs_inode_log_format\t*ilfp = item->ri_buf[0].i_addr;\n\n\t\txlog_buf_readahead(log, ilfp->ilf_blkno, ilfp->ilf_len,\n\t\t\t\t   &xfs_inode_buf_ra_ops);\n\t} else {\n\t\tstruct xfs_inode_log_format_32\t*ilfp = item->ri_buf[0].i_addr;\n\n\t\txlog_buf_readahead(log, ilfp->ilf_blkno, ilfp->ilf_len,\n\t\t\t\t   &xfs_inode_buf_ra_ops);\n\t}\n}\n\n \n\nSTATIC int\nxfs_recover_inode_owner_change(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip,\n\tstruct xfs_inode_log_format *in_f,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\n\tASSERT(in_f->ilf_fields & (XFS_ILOG_DOWNER|XFS_ILOG_AOWNER));\n\n\tip = xfs_inode_alloc(mp, in_f->ilf_ino);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\t \n\tASSERT(dip->di_version >= 3);\n\n\terror = xfs_inode_from_disk(ip, dip);\n\tif (error)\n\t\tgoto out_free_ip;\n\n\tif (in_f->ilf_fields & XFS_ILOG_DOWNER) {\n\t\tASSERT(in_f->ilf_fields & XFS_ILOG_DBROOT);\n\t\terror = xfs_bmbt_change_owner(NULL, ip, XFS_DATA_FORK,\n\t\t\t\t\t      ip->i_ino, buffer_list);\n\t\tif (error)\n\t\t\tgoto out_free_ip;\n\t}\n\n\tif (in_f->ilf_fields & XFS_ILOG_AOWNER) {\n\t\tASSERT(in_f->ilf_fields & XFS_ILOG_ABROOT);\n\t\terror = xfs_bmbt_change_owner(NULL, ip, XFS_ATTR_FORK,\n\t\t\t\t\t      ip->i_ino, buffer_list);\n\t\tif (error)\n\t\t\tgoto out_free_ip;\n\t}\n\nout_free_ip:\n\txfs_inode_free(ip);\n\treturn error;\n}\n\nstatic inline bool xfs_log_dinode_has_bigtime(const struct xfs_log_dinode *ld)\n{\n\treturn ld->di_version >= 3 &&\n\t       (ld->di_flags2 & XFS_DIFLAG2_BIGTIME);\n}\n\n \nstatic inline xfs_timestamp_t\nxfs_log_dinode_to_disk_ts(\n\tstruct xfs_log_dinode\t\t*from,\n\tconst xfs_log_timestamp_t\tits)\n{\n\tstruct xfs_legacy_timestamp\t*lts;\n\tstruct xfs_log_legacy_timestamp\t*lits;\n\txfs_timestamp_t\t\t\tts;\n\n\tif (xfs_log_dinode_has_bigtime(from))\n\t\treturn cpu_to_be64(its);\n\n\tlts = (struct xfs_legacy_timestamp *)&ts;\n\tlits = (struct xfs_log_legacy_timestamp *)&its;\n\tlts->t_sec = cpu_to_be32(lits->t_sec);\n\tlts->t_nsec = cpu_to_be32(lits->t_nsec);\n\n\treturn ts;\n}\n\nstatic inline bool xfs_log_dinode_has_large_extent_counts(\n\t\tconst struct xfs_log_dinode *ld)\n{\n\treturn ld->di_version >= 3 &&\n\t       (ld->di_flags2 & XFS_DIFLAG2_NREXT64);\n}\n\nstatic inline void\nxfs_log_dinode_to_disk_iext_counters(\n\tstruct xfs_log_dinode\t*from,\n\tstruct xfs_dinode\t*to)\n{\n\tif (xfs_log_dinode_has_large_extent_counts(from)) {\n\t\tto->di_big_nextents = cpu_to_be64(from->di_big_nextents);\n\t\tto->di_big_anextents = cpu_to_be32(from->di_big_anextents);\n\t\tto->di_nrext64_pad = cpu_to_be16(from->di_nrext64_pad);\n\t} else {\n\t\tto->di_nextents = cpu_to_be32(from->di_nextents);\n\t\tto->di_anextents = cpu_to_be16(from->di_anextents);\n\t}\n\n}\n\nSTATIC void\nxfs_log_dinode_to_disk(\n\tstruct xfs_log_dinode\t*from,\n\tstruct xfs_dinode\t*to,\n\txfs_lsn_t\t\tlsn)\n{\n\tto->di_magic = cpu_to_be16(from->di_magic);\n\tto->di_mode = cpu_to_be16(from->di_mode);\n\tto->di_version = from->di_version;\n\tto->di_format = from->di_format;\n\tto->di_onlink = 0;\n\tto->di_uid = cpu_to_be32(from->di_uid);\n\tto->di_gid = cpu_to_be32(from->di_gid);\n\tto->di_nlink = cpu_to_be32(from->di_nlink);\n\tto->di_projid_lo = cpu_to_be16(from->di_projid_lo);\n\tto->di_projid_hi = cpu_to_be16(from->di_projid_hi);\n\n\tto->di_atime = xfs_log_dinode_to_disk_ts(from, from->di_atime);\n\tto->di_mtime = xfs_log_dinode_to_disk_ts(from, from->di_mtime);\n\tto->di_ctime = xfs_log_dinode_to_disk_ts(from, from->di_ctime);\n\n\tto->di_size = cpu_to_be64(from->di_size);\n\tto->di_nblocks = cpu_to_be64(from->di_nblocks);\n\tto->di_extsize = cpu_to_be32(from->di_extsize);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat = from->di_aformat;\n\tto->di_dmevmask = cpu_to_be32(from->di_dmevmask);\n\tto->di_dmstate = cpu_to_be16(from->di_dmstate);\n\tto->di_flags = cpu_to_be16(from->di_flags);\n\tto->di_gen = cpu_to_be32(from->di_gen);\n\n\tif (from->di_version == 3) {\n\t\tto->di_changecount = cpu_to_be64(from->di_changecount);\n\t\tto->di_crtime = xfs_log_dinode_to_disk_ts(from,\n\t\t\t\t\t\t\t  from->di_crtime);\n\t\tto->di_flags2 = cpu_to_be64(from->di_flags2);\n\t\tto->di_cowextsize = cpu_to_be32(from->di_cowextsize);\n\t\tto->di_ino = cpu_to_be64(from->di_ino);\n\t\tto->di_lsn = cpu_to_be64(lsn);\n\t\tmemset(to->di_pad2, 0, sizeof(to->di_pad2));\n\t\tuuid_copy(&to->di_uuid, &from->di_uuid);\n\t\tto->di_v3_pad = 0;\n\t} else {\n\t\tto->di_flushiter = cpu_to_be16(from->di_flushiter);\n\t\tmemset(to->di_v2_pad, 0, sizeof(to->di_v2_pad));\n\t}\n\n\txfs_log_dinode_to_disk_iext_counters(from, to);\n}\n\nSTATIC int\nxlog_dinode_verify_extent_counts(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_log_dinode\t*ldip)\n{\n\txfs_extnum_t\t\tnextents;\n\txfs_aextnum_t\t\tanextents;\n\n\tif (xfs_log_dinode_has_large_extent_counts(ldip)) {\n\t\tif (!xfs_has_large_extent_counts(mp) ||\n\t\t    (ldip->di_nrext64_pad != 0)) {\n\t\t\tXFS_CORRUPTION_ERROR(\n\t\t\t\t\"Bad log dinode large extent count format\",\n\t\t\t\tXFS_ERRLEVEL_LOW, mp, ldip, sizeof(*ldip));\n\t\t\txfs_alert(mp,\n\t\t\t\t\"Bad inode 0x%llx, large extent counts %d, padding 0x%x\",\n\t\t\t\tldip->di_ino, xfs_has_large_extent_counts(mp),\n\t\t\t\tldip->di_nrext64_pad);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tnextents = ldip->di_big_nextents;\n\t\tanextents = ldip->di_big_anextents;\n\t} else {\n\t\tif (ldip->di_version == 3 && ldip->di_v3_pad != 0) {\n\t\t\tXFS_CORRUPTION_ERROR(\n\t\t\t\t\"Bad log dinode di_v3_pad\",\n\t\t\t\tXFS_ERRLEVEL_LOW, mp, ldip, sizeof(*ldip));\n\t\t\txfs_alert(mp,\n\t\t\t\t\"Bad inode 0x%llx, di_v3_pad 0x%llx\",\n\t\t\t\tldip->di_ino, ldip->di_v3_pad);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tnextents = ldip->di_nextents;\n\t\tanextents = ldip->di_anextents;\n\t}\n\n\tif (unlikely(nextents + anextents > ldip->di_nblocks)) {\n\t\tXFS_CORRUPTION_ERROR(\"Bad log dinode extent counts\",\n\t\t\t\tXFS_ERRLEVEL_LOW, mp, ldip, sizeof(*ldip));\n\t\txfs_alert(mp,\n\t\t\t\"Bad inode 0x%llx, large extent counts %d, nextents 0x%llx, anextents 0x%x, nblocks 0x%llx\",\n\t\t\tldip->di_ino, xfs_has_large_extent_counts(mp), nextents,\n\t\t\tanextents, ldip->di_nblocks);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\treturn 0;\n}\n\nSTATIC int\nxlog_recover_inode_commit_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tcurrent_lsn)\n{\n\tstruct xfs_inode_log_format\t*in_f;\n\tstruct xfs_mount\t\t*mp = log->l_mp;\n\tstruct xfs_buf\t\t\t*bp;\n\tstruct xfs_dinode\t\t*dip;\n\tint\t\t\t\tlen;\n\tchar\t\t\t\t*src;\n\tchar\t\t\t\t*dest;\n\tint\t\t\t\terror;\n\tint\t\t\t\tattr_index;\n\tuint\t\t\t\tfields;\n\tstruct xfs_log_dinode\t\t*ldip;\n\tuint\t\t\t\tisize;\n\tint\t\t\t\tneed_free = 0;\n\n\tif (item->ri_buf[0].i_len == sizeof(struct xfs_inode_log_format)) {\n\t\tin_f = item->ri_buf[0].i_addr;\n\t} else {\n\t\tin_f = kmem_alloc(sizeof(struct xfs_inode_log_format), 0);\n\t\tneed_free = 1;\n\t\terror = xfs_inode_item_format_convert(&item->ri_buf[0], in_f);\n\t\tif (error)\n\t\t\tgoto error;\n\t}\n\n\t \n\tif (xlog_is_buffer_cancelled(log, in_f->ilf_blkno, in_f->ilf_len)) {\n\t\terror = 0;\n\t\ttrace_xfs_log_recover_inode_cancel(log, in_f);\n\t\tgoto error;\n\t}\n\ttrace_xfs_log_recover_inode_recover(log, in_f);\n\n\terror = xfs_buf_read(mp->m_ddev_targp, in_f->ilf_blkno, in_f->ilf_len,\n\t\t\t0, &bp, &xfs_inode_buf_ops);\n\tif (error)\n\t\tgoto error;\n\tASSERT(in_f->ilf_fields & XFS_ILOG_CORE);\n\tdip = xfs_buf_offset(bp, in_f->ilf_boffset);\n\n\t \n\tif (XFS_IS_CORRUPT(mp, !xfs_verify_magic16(bp, dip->di_magic))) {\n\t\txfs_alert(mp,\n\t\"%s: Bad inode magic number, dip = \"PTR_FMT\", dino bp = \"PTR_FMT\", ino = %lld\",\n\t\t\t__func__, dip, bp, in_f->ilf_ino);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\tldip = item->ri_buf[1].i_addr;\n\tif (XFS_IS_CORRUPT(mp, ldip->di_magic != XFS_DINODE_MAGIC)) {\n\t\txfs_alert(mp,\n\t\t\t\"%s: Bad inode log record, rec ptr \"PTR_FMT\", ino %lld\",\n\t\t\t__func__, item, in_f->ilf_ino);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\n\t \n\tif (dip->di_version >= 3) {\n\t\txfs_lsn_t\tlsn = be64_to_cpu(dip->di_lsn);\n\n\t\tif (lsn && lsn != -1 && XFS_LSN_CMP(lsn, current_lsn) > 0) {\n\t\t\ttrace_xfs_log_recover_inode_skip(log, in_f);\n\t\t\terror = 0;\n\t\t\tgoto out_owner_change;\n\t\t}\n\t}\n\n\t \n\tif (!xfs_has_v3inodes(mp)) {\n\t\tif (ldip->di_flushiter < be16_to_cpu(dip->di_flushiter)) {\n\t\t\t \n\t\t\tif (be16_to_cpu(dip->di_flushiter) == DI_MAX_FLUSH &&\n\t\t\t    ldip->di_flushiter < (DI_MAX_FLUSH >> 1)) {\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\ttrace_xfs_log_recover_inode_skip(log, in_f);\n\t\t\t\terror = 0;\n\t\t\t\tgoto out_release;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tldip->di_flushiter = 0;\n\t}\n\n\n\tif (unlikely(S_ISREG(ldip->di_mode))) {\n\t\tif ((ldip->di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (ldip->di_format != XFS_DINODE_FMT_BTREE)) {\n\t\t\tXFS_CORRUPTION_ERROR(\n\t\t\t\t\"Bad log dinode data fork format for regular file\",\n\t\t\t\tXFS_ERRLEVEL_LOW, mp, ldip, sizeof(*ldip));\n\t\t\txfs_alert(mp,\n\t\t\t\t\"Bad inode 0x%llx, data fork format 0x%x\",\n\t\t\t\tin_f->ilf_ino, ldip->di_format);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_release;\n\t\t}\n\t} else if (unlikely(S_ISDIR(ldip->di_mode))) {\n\t\tif ((ldip->di_format != XFS_DINODE_FMT_EXTENTS) &&\n\t\t    (ldip->di_format != XFS_DINODE_FMT_BTREE) &&\n\t\t    (ldip->di_format != XFS_DINODE_FMT_LOCAL)) {\n\t\t\tXFS_CORRUPTION_ERROR(\n\t\t\t\t\"Bad log dinode data fork format for directory\",\n\t\t\t\tXFS_ERRLEVEL_LOW, mp, ldip, sizeof(*ldip));\n\t\t\txfs_alert(mp,\n\t\t\t\t\"Bad inode 0x%llx, data fork format 0x%x\",\n\t\t\t\tin_f->ilf_ino, ldip->di_format);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\n\terror = xlog_dinode_verify_extent_counts(mp, ldip);\n\tif (error)\n\t\tgoto out_release;\n\n\tif (unlikely(ldip->di_forkoff > mp->m_sb.sb_inodesize)) {\n\t\tXFS_CORRUPTION_ERROR(\"Bad log dinode fork offset\",\n\t\t\t\tXFS_ERRLEVEL_LOW, mp, ldip, sizeof(*ldip));\n\t\txfs_alert(mp,\n\t\t\t\"Bad inode 0x%llx, di_forkoff 0x%x\",\n\t\t\tin_f->ilf_ino, ldip->di_forkoff);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\tisize = xfs_log_dinode_size(mp);\n\tif (unlikely(item->ri_buf[1].i_len > isize)) {\n\t\tXFS_CORRUPTION_ERROR(\"Bad log dinode size\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     mp, ldip, sizeof(*ldip));\n\t\txfs_alert(mp,\n\t\t\t\"Bad inode 0x%llx log dinode size 0x%x\",\n\t\t\tin_f->ilf_ino, item->ri_buf[1].i_len);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_release;\n\t}\n\n\t \n\txfs_log_dinode_to_disk(ldip, dip, current_lsn);\n\n\tfields = in_f->ilf_fields;\n\tif (fields & XFS_ILOG_DEV)\n\t\txfs_dinode_put_rdev(dip, in_f->ilf_u.ilfu_rdev);\n\n\tif (in_f->ilf_size == 2)\n\t\tgoto out_owner_change;\n\tlen = item->ri_buf[2].i_len;\n\tsrc = item->ri_buf[2].i_addr;\n\tASSERT(in_f->ilf_size <= 4);\n\tASSERT((in_f->ilf_size == 3) || (fields & XFS_ILOG_AFORK));\n\tASSERT(!(fields & XFS_ILOG_DFORK) ||\n\t       (len == xlog_calc_iovec_len(in_f->ilf_dsize)));\n\n\tswitch (fields & XFS_ILOG_DFORK) {\n\tcase XFS_ILOG_DDATA:\n\tcase XFS_ILOG_DEXT:\n\t\tmemcpy(XFS_DFORK_DPTR(dip), src, len);\n\t\tbreak;\n\n\tcase XFS_ILOG_DBROOT:\n\t\txfs_bmbt_to_bmdr(mp, (struct xfs_btree_block *)src, len,\n\t\t\t\t (struct xfs_bmdr_block *)XFS_DFORK_DPTR(dip),\n\t\t\t\t XFS_DFORK_DSIZE(dip, mp));\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tASSERT((fields & XFS_ILOG_DFORK) == 0);\n\t\tbreak;\n\t}\n\n\t \n\tif (in_f->ilf_fields & XFS_ILOG_AFORK) {\n\t\tif (in_f->ilf_fields & XFS_ILOG_DFORK) {\n\t\t\tattr_index = 3;\n\t\t} else {\n\t\t\tattr_index = 2;\n\t\t}\n\t\tlen = item->ri_buf[attr_index].i_len;\n\t\tsrc = item->ri_buf[attr_index].i_addr;\n\t\tASSERT(len == xlog_calc_iovec_len(in_f->ilf_asize));\n\n\t\tswitch (in_f->ilf_fields & XFS_ILOG_AFORK) {\n\t\tcase XFS_ILOG_ADATA:\n\t\tcase XFS_ILOG_AEXT:\n\t\t\tdest = XFS_DFORK_APTR(dip);\n\t\t\tASSERT(len <= XFS_DFORK_ASIZE(dip, mp));\n\t\t\tmemcpy(dest, src, len);\n\t\t\tbreak;\n\n\t\tcase XFS_ILOG_ABROOT:\n\t\t\tdest = XFS_DFORK_APTR(dip);\n\t\t\txfs_bmbt_to_bmdr(mp, (struct xfs_btree_block *)src,\n\t\t\t\t\t len, (struct xfs_bmdr_block *)dest,\n\t\t\t\t\t XFS_DFORK_ASIZE(dip, mp));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\txfs_warn(log->l_mp, \"%s: Invalid flag\", __func__);\n\t\t\tASSERT(0);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\nout_owner_change:\n\t \n\tif ((in_f->ilf_fields & (XFS_ILOG_DOWNER|XFS_ILOG_AOWNER)) &&\n\t    (dip->di_mode != 0))\n\t\terror = xfs_recover_inode_owner_change(mp, dip, in_f,\n\t\t\t\t\t\t       buffer_list);\n\t \n\txfs_dinode_calc_crc(log->l_mp, dip);\n\n\tASSERT(bp->b_mount == mp);\n\tbp->b_flags |= _XBF_LOGRECOVERY;\n\txfs_buf_delwri_queue(bp, buffer_list);\n\nout_release:\n\txfs_buf_relse(bp);\nerror:\n\tif (need_free)\n\t\tkmem_free(in_f);\n\treturn error;\n}\n\nconst struct xlog_recover_item_ops xlog_inode_item_ops = {\n\t.item_type\t\t= XFS_LI_INODE,\n\t.ra_pass2\t\t= xlog_recover_inode_ra_pass2,\n\t.commit_pass2\t\t= xlog_recover_inode_commit_pass2,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}