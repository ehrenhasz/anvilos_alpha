{
  "module_name": "xfs_itable.c",
  "hash_id": "0919ff1199b907d9c0e1baa1afea35899372319722460faf9a179674afcd461d",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_itable.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_iwalk.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_error.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_health.h\"\n#include \"xfs_trans.h\"\n\n \n\nstruct xfs_bstat_chunk {\n\tbulkstat_one_fmt_pf\tformatter;\n\tstruct xfs_ibulk\t*breq;\n\tstruct xfs_bulkstat\t*buf;\n};\n\n \nSTATIC int\nxfs_bulkstat_one_int(\n\tstruct xfs_mount\t*mp,\n\tstruct mnt_idmap\t*idmap,\n\tstruct xfs_trans\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_bstat_chunk\t*bc)\n{\n\tstruct user_namespace\t*sb_userns = mp->m_super->s_user_ns;\n\tstruct xfs_inode\t*ip;\t\t \n\tstruct inode\t\t*inode;\n\tstruct xfs_bulkstat\t*buf = bc->buf;\n\txfs_extnum_t\t\tnextents;\n\tint\t\t\terror = -EINVAL;\n\tvfsuid_t\t\tvfsuid;\n\tvfsgid_t\t\tvfsgid;\n\n\tif (xfs_internal_inum(mp, ino))\n\t\tgoto out_advance;\n\n\terror = xfs_iget(mp, tp, ino,\n\t\t\t (XFS_IGET_DONTCACHE | XFS_IGET_UNTRUSTED),\n\t\t\t XFS_ILOCK_SHARED, &ip);\n\tif (error == -ENOENT || error == -EINVAL)\n\t\tgoto out_advance;\n\tif (error)\n\t\tgoto out;\n\n\t \n\tif (xfs_inode_unlinked_incomplete(ip)) {\n\t\terror = xfs_inode_reload_unlinked_bucket(tp, ip);\n\t\tif (error) {\n\t\t\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\t\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\t\txfs_irele(ip);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tASSERT(ip != NULL);\n\tASSERT(ip->i_imap.im_blkno != 0);\n\tinode = VFS_I(ip);\n\tvfsuid = i_uid_into_vfsuid(idmap, inode);\n\tvfsgid = i_gid_into_vfsgid(idmap, inode);\n\n\t \n\tbuf->bs_projectid = ip->i_projid;\n\tbuf->bs_ino = ino;\n\tbuf->bs_uid = from_kuid(sb_userns, vfsuid_into_kuid(vfsuid));\n\tbuf->bs_gid = from_kgid(sb_userns, vfsgid_into_kgid(vfsgid));\n\tbuf->bs_size = ip->i_disk_size;\n\n\tbuf->bs_nlink = inode->i_nlink;\n\tbuf->bs_atime = inode->i_atime.tv_sec;\n\tbuf->bs_atime_nsec = inode->i_atime.tv_nsec;\n\tbuf->bs_mtime = inode->i_mtime.tv_sec;\n\tbuf->bs_mtime_nsec = inode->i_mtime.tv_nsec;\n\tbuf->bs_ctime = inode_get_ctime(inode).tv_sec;\n\tbuf->bs_ctime_nsec = inode_get_ctime(inode).tv_nsec;\n\tbuf->bs_gen = inode->i_generation;\n\tbuf->bs_mode = inode->i_mode;\n\n\tbuf->bs_xflags = xfs_ip2xflags(ip);\n\tbuf->bs_extsize_blks = ip->i_extsize;\n\n\tnextents = xfs_ifork_nextents(&ip->i_df);\n\tif (!(bc->breq->flags & XFS_IBULK_NREXT64))\n\t\tbuf->bs_extents = min(nextents, XFS_MAX_EXTCNT_DATA_FORK_SMALL);\n\telse\n\t\tbuf->bs_extents64 = nextents;\n\n\txfs_bulkstat_health(ip, buf);\n\tbuf->bs_aextents = xfs_ifork_nextents(&ip->i_af);\n\tbuf->bs_forkoff = xfs_inode_fork_boff(ip);\n\tbuf->bs_version = XFS_BULKSTAT_VERSION_V5;\n\n\tif (xfs_has_v3inodes(mp)) {\n\t\tbuf->bs_btime = ip->i_crtime.tv_sec;\n\t\tbuf->bs_btime_nsec = ip->i_crtime.tv_nsec;\n\t\tif (ip->i_diflags2 & XFS_DIFLAG2_COWEXTSIZE)\n\t\t\tbuf->bs_cowextsize_blks = ip->i_cowextsize;\n\t}\n\n\tswitch (ip->i_df.if_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tbuf->bs_rdev = sysv_encode_dev(inode->i_rdev);\n\t\tbuf->bs_blksize = BLKDEV_IOSIZE;\n\t\tbuf->bs_blocks = 0;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tbuf->bs_rdev = 0;\n\t\tbuf->bs_blksize = mp->m_sb.sb_blocksize;\n\t\tbuf->bs_blocks = 0;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tbuf->bs_rdev = 0;\n\t\tbuf->bs_blksize = mp->m_sb.sb_blocksize;\n\t\tbuf->bs_blocks = ip->i_nblocks + ip->i_delayed_blks;\n\t\tbreak;\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\txfs_irele(ip);\n\n\terror = bc->formatter(bc->breq, buf);\n\tif (error == -ECANCELED)\n\t\tgoto out_advance;\n\tif (error)\n\t\tgoto out;\n\nout_advance:\n\t \n\tbc->breq->startino = ino + 1;\nout:\n\treturn error;\n}\n\n \nint\nxfs_bulkstat_one(\n\tstruct xfs_ibulk\t*breq,\n\tbulkstat_one_fmt_pf\tformatter)\n{\n\tstruct xfs_bstat_chunk\tbc = {\n\t\t.formatter\t= formatter,\n\t\t.breq\t\t= breq,\n\t};\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\tif (breq->idmap != &nop_mnt_idmap) {\n\t\txfs_warn_ratelimited(breq->mp,\n\t\t\t\"bulkstat not supported inside of idmapped mounts.\");\n\t\treturn -EINVAL;\n\t}\n\n\tASSERT(breq->icount == 1);\n\n\tbc.buf = kmem_zalloc(sizeof(struct xfs_bulkstat),\n\t\t\tKM_MAYFAIL);\n\tif (!bc.buf)\n\t\treturn -ENOMEM;\n\n\t \n\terror = xfs_trans_alloc_empty(breq->mp, &tp);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_bulkstat_one_int(breq->mp, breq->idmap, tp,\n\t\t\tbreq->startino, &bc);\n\txfs_trans_cancel(tp);\nout:\n\tkmem_free(bc.buf);\n\n\t \n\tif (error == -ECANCELED)\n\t\terror = 0;\n\n\treturn error;\n}\n\nstatic int\nxfs_bulkstat_iwalk(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\txfs_ino_t\t\tino,\n\tvoid\t\t\t*data)\n{\n\tstruct xfs_bstat_chunk\t*bc = data;\n\tint\t\t\terror;\n\n\terror = xfs_bulkstat_one_int(mp, bc->breq->idmap, tp, ino, data);\n\t \n\tif (error == -ENOENT || error == -EINVAL)\n\t\treturn 0;\n\treturn error;\n}\n\n \nstatic inline bool\nxfs_bulkstat_already_done(\n\tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tstartino)\n{\n\txfs_agnumber_t\t\tagno = XFS_INO_TO_AGNO(mp, startino);\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, startino);\n\n\treturn agno >= mp->m_sb.sb_agcount ||\n\t       startino != XFS_AGINO_TO_INO(mp, agno, agino);\n}\n\n \nint\nxfs_bulkstat(\n\tstruct xfs_ibulk\t*breq,\n\tbulkstat_one_fmt_pf\tformatter)\n{\n\tstruct xfs_bstat_chunk\tbc = {\n\t\t.formatter\t= formatter,\n\t\t.breq\t\t= breq,\n\t};\n\tstruct xfs_trans\t*tp;\n\tunsigned int\t\tiwalk_flags = 0;\n\tint\t\t\terror;\n\n\tif (breq->idmap != &nop_mnt_idmap) {\n\t\txfs_warn_ratelimited(breq->mp,\n\t\t\t\"bulkstat not supported inside of idmapped mounts.\");\n\t\treturn -EINVAL;\n\t}\n\tif (xfs_bulkstat_already_done(breq->mp, breq->startino))\n\t\treturn 0;\n\n\tbc.buf = kmem_zalloc(sizeof(struct xfs_bulkstat),\n\t\t\tKM_MAYFAIL);\n\tif (!bc.buf)\n\t\treturn -ENOMEM;\n\n\t \n\terror = xfs_trans_alloc_empty(breq->mp, &tp);\n\tif (error)\n\t\tgoto out;\n\n\tif (breq->flags & XFS_IBULK_SAME_AG)\n\t\tiwalk_flags |= XFS_IWALK_SAME_AG;\n\n\terror = xfs_iwalk(breq->mp, tp, breq->startino, iwalk_flags,\n\t\t\txfs_bulkstat_iwalk, breq->icount, &bc);\n\txfs_trans_cancel(tp);\nout:\n\tkmem_free(bc.buf);\n\n\t \n\tif (breq->ocount > 0)\n\t\terror = 0;\n\n\treturn error;\n}\n\n \nvoid\nxfs_bulkstat_to_bstat(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_bstat\t\t*bs1,\n\tconst struct xfs_bulkstat\t*bstat)\n{\n\t \n\tmemset(bs1, 0, sizeof(struct xfs_bstat));\n\tbs1->bs_ino = bstat->bs_ino;\n\tbs1->bs_mode = bstat->bs_mode;\n\tbs1->bs_nlink = bstat->bs_nlink;\n\tbs1->bs_uid = bstat->bs_uid;\n\tbs1->bs_gid = bstat->bs_gid;\n\tbs1->bs_rdev = bstat->bs_rdev;\n\tbs1->bs_blksize = bstat->bs_blksize;\n\tbs1->bs_size = bstat->bs_size;\n\tbs1->bs_atime.tv_sec = bstat->bs_atime;\n\tbs1->bs_mtime.tv_sec = bstat->bs_mtime;\n\tbs1->bs_ctime.tv_sec = bstat->bs_ctime;\n\tbs1->bs_atime.tv_nsec = bstat->bs_atime_nsec;\n\tbs1->bs_mtime.tv_nsec = bstat->bs_mtime_nsec;\n\tbs1->bs_ctime.tv_nsec = bstat->bs_ctime_nsec;\n\tbs1->bs_blocks = bstat->bs_blocks;\n\tbs1->bs_xflags = bstat->bs_xflags;\n\tbs1->bs_extsize = XFS_FSB_TO_B(mp, bstat->bs_extsize_blks);\n\tbs1->bs_extents = bstat->bs_extents;\n\tbs1->bs_gen = bstat->bs_gen;\n\tbs1->bs_projid_lo = bstat->bs_projectid & 0xFFFF;\n\tbs1->bs_forkoff = bstat->bs_forkoff;\n\tbs1->bs_projid_hi = bstat->bs_projectid >> 16;\n\tbs1->bs_sick = bstat->bs_sick;\n\tbs1->bs_checked = bstat->bs_checked;\n\tbs1->bs_cowextsize = XFS_FSB_TO_B(mp, bstat->bs_cowextsize_blks);\n\tbs1->bs_dmevmask = 0;\n\tbs1->bs_dmstate = 0;\n\tbs1->bs_aextents = bstat->bs_aextents;\n}\n\nstruct xfs_inumbers_chunk {\n\tinumbers_fmt_pf\t\tformatter;\n\tstruct xfs_ibulk\t*breq;\n};\n\n \n\n \nSTATIC int\nxfs_inumbers_walk(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\tconst struct xfs_inobt_rec_incore *irec,\n\tvoid\t\t\t*data)\n{\n\tstruct xfs_inumbers\tinogrp = {\n\t\t.xi_startino\t= XFS_AGINO_TO_INO(mp, agno, irec->ir_startino),\n\t\t.xi_alloccount\t= irec->ir_count - irec->ir_freecount,\n\t\t.xi_allocmask\t= ~irec->ir_free,\n\t\t.xi_version\t= XFS_INUMBERS_VERSION_V5,\n\t};\n\tstruct xfs_inumbers_chunk *ic = data;\n\tint\t\t\terror;\n\n\terror = ic->formatter(ic->breq, &inogrp);\n\tif (error && error != -ECANCELED)\n\t\treturn error;\n\n\tic->breq->startino = XFS_AGINO_TO_INO(mp, agno, irec->ir_startino) +\n\t\t\tXFS_INODES_PER_CHUNK;\n\treturn error;\n}\n\n \nint\nxfs_inumbers(\n\tstruct xfs_ibulk\t*breq,\n\tinumbers_fmt_pf\t\tformatter)\n{\n\tstruct xfs_inumbers_chunk ic = {\n\t\t.formatter\t= formatter,\n\t\t.breq\t\t= breq,\n\t};\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror = 0;\n\n\tif (xfs_bulkstat_already_done(breq->mp, breq->startino))\n\t\treturn 0;\n\n\t \n\terror = xfs_trans_alloc_empty(breq->mp, &tp);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_inobt_walk(breq->mp, tp, breq->startino, breq->flags,\n\t\t\txfs_inumbers_walk, breq->icount, &ic);\n\txfs_trans_cancel(tp);\nout:\n\n\t \n\tif (breq->ocount > 0)\n\t\terror = 0;\n\n\treturn error;\n}\n\n \nvoid\nxfs_inumbers_to_inogrp(\n\tstruct xfs_inogrp\t\t*ig1,\n\tconst struct xfs_inumbers\t*ig)\n{\n\t \n\tmemset(ig1, 0, sizeof(struct xfs_inogrp));\n\tig1->xi_startino = ig->xi_startino;\n\tig1->xi_alloccount = ig->xi_alloccount;\n\tig1->xi_allocmask = ig->xi_allocmask;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}