{
  "module_name": "xfs_acl.c",
  "hash_id": "46b2e5fd2da84b379ca3877c48e8f82f8930c79fa61555b732a3c6b44c10b252",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_acl.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_xattr.h\"\n\n#include <linux/posix_acl_xattr.h>\n\n \n\nSTATIC struct posix_acl *\nxfs_acl_from_disk(\n\tstruct xfs_mount\t*mp,\n\tconst struct xfs_acl\t*aclp,\n\tint\t\t\tlen,\n\tint\t\t\tmax_entries)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tconst struct xfs_acl_entry *ace;\n\tunsigned int count, i;\n\n\tif (len < sizeof(*aclp)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, aclp,\n\t\t\t\tlen);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > max_entries || XFS_ACL_SIZE(count) != len) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, aclp,\n\t\t\t\tlen);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\n\t\t \n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tacl_e->e_uid = make_kuid(&init_user_ns,\n\t\t\t\t\t\t be32_to_cpu(ace->ae_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_gid = make_kgid(&init_user_ns,\n\t\t\t\t\t\t be32_to_cpu(ace->ae_id));\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\nSTATIC void\nxfs_acl_to_disk(struct xfs_acl *aclp, const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *acl_e;\n\tstruct xfs_acl_entry *ace;\n\tint i;\n\n\taclp->acl_cnt = cpu_to_be32(acl->a_count);\n\tfor (i = 0; i < acl->a_count; i++) {\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e = &acl->a_entries[i];\n\n\t\tace->ae_tag = cpu_to_be32(acl_e->e_tag);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tace->ae_id = cpu_to_be32(\n\t\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tace->ae_id = cpu_to_be32(\n\t\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tace->ae_id = cpu_to_be32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\n\t\tace->ae_perm = cpu_to_be16(acl_e->e_perm);\n\t}\n}\n\nstruct posix_acl *\nxfs_get_acl(struct inode *inode, int type, bool rcu)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct posix_acl\t*acl = NULL;\n\tstruct xfs_da_args\targs = {\n\t\t.dp\t\t= ip,\n\t\t.attr_filter\t= XFS_ATTR_ROOT,\n\t\t.valuelen\t= XFS_ACL_MAX_SIZE(mp),\n\t};\n\tint\t\t\terror;\n\n\tif (rcu)\n\t\treturn ERR_PTR(-ECHILD);\n\n\ttrace_xfs_get_acl(ip);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\targs.name = SGI_ACL_FILE;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\targs.name = SGI_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\targs.namelen = strlen(args.name);\n\n\t \n\terror = xfs_attr_get(&args);\n\tif (!error) {\n\t\tacl = xfs_acl_from_disk(mp, args.value, args.valuelen,\n\t\t\t\t\tXFS_ACL_MAX_ENTRIES(mp));\n\t} else if (error != -ENOATTR) {\n\t\tacl = ERR_PTR(error);\n\t}\n\n\tkmem_free(args.value);\n\treturn acl;\n}\n\nint\n__xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_da_args\targs = {\n\t\t.dp\t\t= ip,\n\t\t.attr_filter\t= XFS_ATTR_ROOT,\n\t};\n\tint\t\t\terror;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\targs.name = SGI_ACL_FILE;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\targs.name = SGI_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\targs.namelen = strlen(args.name);\n\n\tif (acl) {\n\t\targs.valuelen = XFS_ACL_SIZE(acl->a_count);\n\t\targs.value = kvzalloc(args.valuelen, GFP_KERNEL);\n\t\tif (!args.value)\n\t\t\treturn -ENOMEM;\n\t\txfs_acl_to_disk(args.value, acl);\n\t}\n\n\terror = xfs_attr_change(&args);\n\tkmem_free(args.value);\n\n\t \n\tif (!acl && error == -ENOATTR)\n\t\terror = 0;\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}\n\nstatic int\nxfs_acl_set_mode(\n\tstruct inode\t\t*inode,\n\tumode_t\t\t\tmode)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_ichange, 0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\tinode->i_mode = mode;\n\tinode_set_ctime_current(inode);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (xfs_has_wsync(mp))\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp);\n}\n\nint\nxfs_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t    struct posix_acl *acl, int type)\n{\n\tumode_t mode;\n\tbool set_mode = false;\n\tint error = 0;\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (!acl)\n\t\tgoto set_acl;\n\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_update_mode(idmap, inode, &mode, &acl);\n\t\tif (error)\n\t\t\treturn error;\n\t\tset_mode = true;\n\t}\n\n set_acl:\n\t \n\terror =  __xfs_set_acl(inode, acl, type);\n\tif (!error && set_mode && mode != inode->i_mode)\n\t\terror = xfs_acl_set_mode(inode, mode);\n\treturn error;\n}\n\n \nvoid\nxfs_forget_acl(\n\tstruct inode\t\t*inode,\n\tconst char\t\t*name)\n{\n\tif (!strcmp(name, SGI_ACL_FILE))\n\t\tforget_cached_acl(inode, ACL_TYPE_ACCESS);\n\telse if (!strcmp(name, SGI_ACL_DEFAULT))\n\t\tforget_cached_acl(inode, ACL_TYPE_DEFAULT);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}