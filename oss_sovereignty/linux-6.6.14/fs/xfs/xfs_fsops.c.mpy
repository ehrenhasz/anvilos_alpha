{
  "module_name": "xfs_fsops.c",
  "hash_id": "c2c98c41c2cd54dc08866cbd7ce7c464cbace21a6c72cf67e342970acc693652",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_fsops.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_log.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_ag_resv.h\"\n#include \"xfs_trace.h\"\n\n \nstatic int\nxfs_resizefs_init_new_ags(\n\tstruct xfs_trans\t*tp,\n\tstruct aghdr_init_data\t*id,\n\txfs_agnumber_t\t\toagcount,\n\txfs_agnumber_t\t\tnagcount,\n\txfs_rfsblock_t\t\tdelta,\n\tstruct xfs_perag\t*last_pag,\n\tbool\t\t\t*lastag_extended)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_rfsblock_t\t\tnb = mp->m_sb.sb_dblocks + delta;\n\tint\t\t\terror;\n\n\t*lastag_extended = false;\n\n\tINIT_LIST_HEAD(&id->buffer_list);\n\tfor (id->agno = nagcount - 1;\n\t     id->agno >= oagcount;\n\t     id->agno--, delta -= id->agsize) {\n\n\t\tif (id->agno == nagcount - 1)\n\t\t\tid->agsize = nb - (id->agno *\n\t\t\t\t\t(xfs_rfsblock_t)mp->m_sb.sb_agblocks);\n\t\telse\n\t\t\tid->agsize = mp->m_sb.sb_agblocks;\n\n\t\terror = xfs_ag_init_headers(mp, id);\n\t\tif (error) {\n\t\t\txfs_buf_delwri_cancel(&id->buffer_list);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = xfs_buf_delwri_submit(&id->buffer_list);\n\tif (error)\n\t\treturn error;\n\n\tif (delta) {\n\t\t*lastag_extended = true;\n\t\terror = xfs_ag_extend_space(last_pag, tp, delta);\n\t}\n\treturn error;\n}\n\n \nstatic int\nxfs_growfs_data_private(\n\tstruct xfs_mount\t*mp,\t\t \n\tstruct xfs_growfs_data\t*in)\t\t \n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\txfs_agnumber_t\t\tnagcount;\n\txfs_agnumber_t\t\tnagimax = 0;\n\txfs_rfsblock_t\t\tnb, nb_div, nb_mod;\n\tint64_t\t\t\tdelta;\n\tbool\t\t\tlastag_extended = false;\n\txfs_agnumber_t\t\toagcount;\n\tstruct xfs_trans\t*tp;\n\tstruct aghdr_init_data\tid = {};\n\tstruct xfs_perag\t*last_pag;\n\n\tnb = in->newblocks;\n\terror = xfs_sb_validate_fsb_count(&mp->m_sb, nb);\n\tif (error)\n\t\treturn error;\n\n\tif (nb > mp->m_sb.sb_dblocks) {\n\t\terror = xfs_buf_read_uncached(mp->m_ddev_targp,\n\t\t\t\tXFS_FSB_TO_BB(mp, nb) - XFS_FSS_TO_BB(mp, 1),\n\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t\txfs_buf_relse(bp);\n\t}\n\n\tnb_div = nb;\n\tnb_mod = do_div(nb_div, mp->m_sb.sb_agblocks);\n\tif (nb_mod && nb_mod >= XFS_MIN_AG_BLOCKS)\n\t\tnb_div++;\n\telse if (nb_mod)\n\t\tnb = nb_div * mp->m_sb.sb_agblocks;\n\n\tif (nb_div > XFS_MAX_AGNUMBER + 1) {\n\t\tnb_div = XFS_MAX_AGNUMBER + 1;\n\t\tnb = nb_div * mp->m_sb.sb_agblocks;\n\t}\n\tnagcount = nb_div;\n\tdelta = nb - mp->m_sb.sb_dblocks;\n\t \n\tif (delta < 0 && nagcount < 2)\n\t\treturn -EINVAL;\n\n\toagcount = mp->m_sb.sb_agcount;\n\t \n\tif (nagcount > oagcount) {\n\t\terror = xfs_initialize_perag(mp, nagcount, nb, &nagimax);\n\t\tif (error)\n\t\t\treturn error;\n\t} else if (nagcount < oagcount) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tif (delta > 0)\n\t\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_growdata,\n\t\t\t\tXFS_GROWFS_SPACE_RES(mp), 0, XFS_TRANS_RESERVE,\n\t\t\t\t&tp);\n\telse\n\t\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_growdata, -delta, 0,\n\t\t\t\t0, &tp);\n\tif (error)\n\t\treturn error;\n\n\tlast_pag = xfs_perag_get(mp, oagcount - 1);\n\tif (delta > 0) {\n\t\terror = xfs_resizefs_init_new_ags(tp, &id, oagcount, nagcount,\n\t\t\t\tdelta, last_pag, &lastag_extended);\n\t} else {\n\t\txfs_warn_mount(mp, XFS_OPSTATE_WARNED_SHRINK,\n\t\"EXPERIMENTAL online shrink feature in use. Use at your own risk!\");\n\n\t\terror = xfs_ag_shrink_space(last_pag, &tp, -delta);\n\t}\n\txfs_perag_put(last_pag);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\t \n\tif (nagcount > oagcount)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_AGCOUNT, nagcount - oagcount);\n\tif (delta)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_DBLOCKS, delta);\n\tif (id.nfree)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FDBLOCKS, id.nfree);\n\n\t \n\tif (xfs_has_lazysbcount(mp))\n\t\txfs_log_sb(tp);\n\n\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (nagimax)\n\t\tmp->m_maxagi = nagimax;\n\txfs_set_low_space_thresholds(mp);\n\tmp->m_alloc_set_aside = xfs_alloc_set_aside(mp);\n\n\tif (delta > 0) {\n\t\t \n\t\tif (lastag_extended) {\n\t\t\tstruct xfs_perag\t*pag;\n\n\t\t\tpag = xfs_perag_get(mp, id.agno);\n\t\t\terror = xfs_ag_resv_free(pag);\n\t\t\txfs_perag_put(pag);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t \n\t\terror = xfs_fs_reserve_ag_blocks(mp);\n\t\tif (error == -ENOSPC)\n\t\t\terror = 0;\n\t}\n\treturn error;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp);\n\treturn error;\n}\n\nstatic int\nxfs_growfs_log_private(\n\tstruct xfs_mount\t*mp,\t \n\tstruct xfs_growfs_log\t*in)\t \n{\n\txfs_extlen_t\t\tnb;\n\n\tnb = in->newblocks;\n\tif (nb < XFS_MIN_LOG_BLOCKS || nb < XFS_B_TO_FSB(mp, XFS_MIN_LOG_BYTES))\n\t\treturn -EINVAL;\n\tif (nb == mp->m_sb.sb_logblocks &&\n\t    in->isint == (mp->m_sb.sb_logstart != 0))\n\t\treturn -EINVAL;\n\t \n\treturn -ENOSYS;\n}\n\nstatic int\nxfs_growfs_imaxpct(\n\tstruct xfs_mount\t*mp,\n\t__u32\t\t\timaxpct)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\tdpct;\n\tint\t\t\terror;\n\n\tif (imaxpct > 100)\n\t\treturn -EINVAL;\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_growdata,\n\t\t\tXFS_GROWFS_SPACE_RES(mp), 0, XFS_TRANS_RESERVE, &tp);\n\tif (error)\n\t\treturn error;\n\n\tdpct = imaxpct - mp->m_sb.sb_imax_pct;\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_IMAXPCT, dpct);\n\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp);\n}\n\n \nint\nxfs_growfs_data(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_growfs_data\t*in)\n{\n\tint\t\t\terror = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!mutex_trylock(&mp->m_growlock))\n\t\treturn -EWOULDBLOCK;\n\n\t \n\tif (in->imaxpct != mp->m_sb.sb_imax_pct) {\n\t\terror = xfs_growfs_imaxpct(mp, in->imaxpct);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t}\n\n\tif (in->newblocks != mp->m_sb.sb_dblocks) {\n\t\terror = xfs_growfs_data_private(mp, in);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t}\n\n\t \n\tif (mp->m_sb.sb_imax_pct) {\n\t\tuint64_t icount = mp->m_sb.sb_dblocks * mp->m_sb.sb_imax_pct;\n\t\tdo_div(icount, 100);\n\t\tM_IGEO(mp)->maxicount = XFS_FSB_TO_INO(mp, icount);\n\t} else\n\t\tM_IGEO(mp)->maxicount = 0;\n\n\t \n\terror = xfs_update_secondary_sbs(mp);\n\nout_error:\n\t \n\tmp->m_generation++;\n\tmutex_unlock(&mp->m_growlock);\n\treturn error;\n}\n\nint\nxfs_growfs_log(\n\txfs_mount_t\t\t*mp,\n\tstruct xfs_growfs_log\t*in)\n{\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!mutex_trylock(&mp->m_growlock))\n\t\treturn -EWOULDBLOCK;\n\terror = xfs_growfs_log_private(mp, in);\n\tmutex_unlock(&mp->m_growlock);\n\treturn error;\n}\n\n \n\nvoid\nxfs_fs_counts(\n\txfs_mount_t\t\t*mp,\n\txfs_fsop_counts_t\t*cnt)\n{\n\tcnt->allocino = percpu_counter_read_positive(&mp->m_icount);\n\tcnt->freeino = percpu_counter_read_positive(&mp->m_ifree);\n\tcnt->freedata = percpu_counter_read_positive(&mp->m_fdblocks) -\n\t\t\t\t\t\txfs_fdblocks_unavailable(mp);\n\tcnt->freertx = percpu_counter_read_positive(&mp->m_frextents);\n}\n\n \n\nint\nxfs_reserve_blocks(\n\txfs_mount_t             *mp,\n\tuint64_t              *inval,\n\txfs_fsop_resblks_t      *outval)\n{\n\tint64_t\t\t\tlcounter, delta;\n\tint64_t\t\t\tfdblks_delta = 0;\n\tuint64_t\t\trequest;\n\tint64_t\t\t\tfree;\n\tint\t\t\terror = 0;\n\n\t \n\tif (inval == (uint64_t *)NULL) {\n\t\tif (!outval)\n\t\t\treturn -EINVAL;\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t\treturn 0;\n\t}\n\n\trequest = *inval;\n\n\t \n\tspin_lock(&mp->m_sb_lock);\n\n\t \n\tif (mp->m_resblks > request) {\n\t\tlcounter = mp->m_resblks_avail - request;\n\t\tif (lcounter  > 0) {\t\t \n\t\t\tfdblks_delta = lcounter;\n\t\t\tmp->m_resblks_avail -= lcounter;\n\t\t}\n\t\tmp->m_resblks = request;\n\t\tif (fdblks_delta) {\n\t\t\tspin_unlock(&mp->m_sb_lock);\n\t\t\terror = xfs_mod_fdblocks(mp, fdblks_delta, 0);\n\t\t\tspin_lock(&mp->m_sb_lock);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\t \n\tfree = percpu_counter_sum(&mp->m_fdblocks) -\n\t\t\t\t\t\txfs_fdblocks_unavailable(mp);\n\tdelta = request - mp->m_resblks;\n\tmp->m_resblks = request;\n\tif (delta > 0 && free > 0) {\n\t\t \n\t\tfdblks_delta = min(free, delta);\n\t\tspin_unlock(&mp->m_sb_lock);\n\t\terror = xfs_mod_fdblocks(mp, -fdblks_delta, 0);\n\t\tif (!error)\n\t\t\txfs_mod_fdblocks(mp, fdblks_delta, 0);\n\t\tspin_lock(&mp->m_sb_lock);\n\t}\nout:\n\tif (outval) {\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t}\n\n\tspin_unlock(&mp->m_sb_lock);\n\treturn error;\n}\n\nint\nxfs_fs_goingdown(\n\txfs_mount_t\t*mp,\n\tuint32_t\tinflags)\n{\n\tswitch (inflags) {\n\tcase XFS_FSOP_GOING_FLAGS_DEFAULT: {\n\t\tif (!freeze_bdev(mp->m_super->s_bdev)) {\n\t\t\txfs_force_shutdown(mp, SHUTDOWN_FORCE_UMOUNT);\n\t\t\tthaw_bdev(mp->m_super->s_bdev);\n\t\t}\n\t\tbreak;\n\t}\n\tcase XFS_FSOP_GOING_FLAGS_LOGFLUSH:\n\t\txfs_force_shutdown(mp, SHUTDOWN_FORCE_UMOUNT);\n\t\tbreak;\n\tcase XFS_FSOP_GOING_FLAGS_NOLOGFLUSH:\n\t\txfs_force_shutdown(mp,\n\t\t\t\tSHUTDOWN_FORCE_UMOUNT | SHUTDOWN_LOG_IO_ERROR);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nvoid\nxfs_do_force_shutdown(\n\tstruct xfs_mount *mp,\n\tuint32_t\tflags,\n\tchar\t\t*fname,\n\tint\t\tlnnum)\n{\n\tint\t\ttag;\n\tconst char\t*why;\n\n\n\tif (test_and_set_bit(XFS_OPSTATE_SHUTDOWN, &mp->m_opstate)) {\n\t\txlog_shutdown_wait(mp->m_log);\n\t\treturn;\n\t}\n\tif (mp->m_sb_bp)\n\t\tmp->m_sb_bp->b_flags |= XBF_DONE;\n\n\tif (flags & SHUTDOWN_FORCE_UMOUNT)\n\t\txfs_alert(mp, \"User initiated shutdown received.\");\n\n\tif (xlog_force_shutdown(mp->m_log, flags)) {\n\t\ttag = XFS_PTAG_SHUTDOWN_LOGERROR;\n\t\twhy = \"Log I/O Error\";\n\t} else if (flags & SHUTDOWN_CORRUPT_INCORE) {\n\t\ttag = XFS_PTAG_SHUTDOWN_CORRUPT;\n\t\twhy = \"Corruption of in-memory data\";\n\t} else if (flags & SHUTDOWN_CORRUPT_ONDISK) {\n\t\ttag = XFS_PTAG_SHUTDOWN_CORRUPT;\n\t\twhy = \"Corruption of on-disk metadata\";\n\t} else if (flags & SHUTDOWN_DEVICE_REMOVED) {\n\t\ttag = XFS_PTAG_SHUTDOWN_IOERROR;\n\t\twhy = \"Block device removal\";\n\t} else {\n\t\ttag = XFS_PTAG_SHUTDOWN_IOERROR;\n\t\twhy = \"Metadata I/O Error\";\n\t}\n\n\ttrace_xfs_force_shutdown(mp, tag, flags, fname, lnnum);\n\n\txfs_alert_tag(mp, tag,\n\"%s (0x%x) detected at %pS (%s:%d).  Shutting down filesystem.\",\n\t\t\twhy, flags, __return_address, fname, lnnum);\n\txfs_alert(mp,\n\t\t\"Please unmount the filesystem and rectify the problem(s)\");\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}\n\n \nint\nxfs_fs_reserve_ag_blocks(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_agnumber_t\t\tagno;\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\terr2;\n\n\tmp->m_finobt_nores = false;\n\tfor_each_perag(mp, agno, pag) {\n\t\terr2 = xfs_ag_resv_init(pag, NULL);\n\t\tif (err2 && !error)\n\t\t\terror = err2;\n\t}\n\n\tif (error && error != -ENOSPC) {\n\t\txfs_warn(mp,\n\t\"Error %d reserving per-AG metadata reserve pool.\", error);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n\n\treturn error;\n}\n\n \nint\nxfs_fs_unreserve_ag_blocks(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_agnumber_t\t\tagno;\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\terr2;\n\n\tfor_each_perag(mp, agno, pag) {\n\t\terr2 = xfs_ag_resv_free(pag);\n\t\tif (err2 && !error)\n\t\t\terror = err2;\n\t}\n\n\tif (error)\n\t\txfs_warn(mp,\n\t\"Error %d freeing per-AG metadata reserve pool.\", error);\n\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}