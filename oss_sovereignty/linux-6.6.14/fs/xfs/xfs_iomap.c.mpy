{
  "module_name": "xfs_iomap.c",
  "hash_id": "bd17c0f82eebeb31b2b8e50669e6d39b5fd0762081e811cb0b74480d11c6a35b",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_iomap.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_errortag.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_dquot.h\"\n#include \"xfs_reflink.h\"\n\n#define XFS_ALLOC_ALIGN(mp, off) \\\n\t(((off) >> mp->m_allocsize_log) << mp->m_allocsize_log)\n\nstatic int\nxfs_alert_fsblock_zero(\n\txfs_inode_t\t*ip,\n\txfs_bmbt_irec_t\t*imap)\n{\n\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\"blkcnt: %llx extent-state: %x\",\n\t\t(unsigned long long)ip->i_ino,\n\t\t(unsigned long long)imap->br_startblock,\n\t\t(unsigned long long)imap->br_startoff,\n\t\t(unsigned long long)imap->br_blockcount,\n\t\timap->br_state);\n\treturn -EFSCORRUPTED;\n}\n\nu64\nxfs_iomap_inode_sequence(\n\tstruct xfs_inode\t*ip,\n\tu16\t\t\tiomap_flags)\n{\n\tu64\t\t\tcookie = 0;\n\n\tif (iomap_flags & IOMAP_F_XATTR)\n\t\treturn READ_ONCE(ip->i_af.if_seq);\n\tif ((iomap_flags & IOMAP_F_SHARED) && ip->i_cowfp)\n\t\tcookie = (u64)READ_ONCE(ip->i_cowfp->if_seq) << 32;\n\treturn cookie | READ_ONCE(ip->i_df.if_seq);\n}\n\n \nstatic bool\nxfs_iomap_valid(\n\tstruct inode\t\t*inode,\n\tconst struct iomap\t*iomap)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\n\tif (iomap->validity_cookie !=\n\t\t\txfs_iomap_inode_sequence(ip, iomap->flags)) {\n\t\ttrace_xfs_iomap_invalid(ip, iomap);\n\t\treturn false;\n\t}\n\n\tXFS_ERRORTAG_DELAY(ip->i_mount, XFS_ERRTAG_WRITE_DELAY_MS);\n\treturn true;\n}\n\nstatic const struct iomap_folio_ops xfs_iomap_folio_ops = {\n\t.iomap_valid\t\t= xfs_iomap_valid,\n};\n\nint\nxfs_bmbt_to_iomap(\n\tstruct xfs_inode\t*ip,\n\tstruct iomap\t\t*iomap,\n\tstruct xfs_bmbt_irec\t*imap,\n\tunsigned int\t\tmapping_flags,\n\tu16\t\t\tiomap_flags,\n\tu64\t\t\tsequence_cookie)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_buftarg\t*target = xfs_inode_buftarg(ip);\n\n\tif (unlikely(!xfs_valid_startblock(ip, imap->br_startblock)))\n\t\treturn xfs_alert_fsblock_zero(ip, imap);\n\n\tif (imap->br_startblock == HOLESTARTBLOCK) {\n\t\tiomap->addr = IOMAP_NULL_ADDR;\n\t\tiomap->type = IOMAP_HOLE;\n\t} else if (imap->br_startblock == DELAYSTARTBLOCK ||\n\t\t   isnullstartblock(imap->br_startblock)) {\n\t\tiomap->addr = IOMAP_NULL_ADDR;\n\t\tiomap->type = IOMAP_DELALLOC;\n\t} else {\n\t\tiomap->addr = BBTOB(xfs_fsb_to_db(ip, imap->br_startblock));\n\t\tif (mapping_flags & IOMAP_DAX)\n\t\t\tiomap->addr += target->bt_dax_part_off;\n\n\t\tif (imap->br_state == XFS_EXT_UNWRITTEN)\n\t\t\tiomap->type = IOMAP_UNWRITTEN;\n\t\telse\n\t\t\tiomap->type = IOMAP_MAPPED;\n\n\t}\n\tiomap->offset = XFS_FSB_TO_B(mp, imap->br_startoff);\n\tiomap->length = XFS_FSB_TO_B(mp, imap->br_blockcount);\n\tif (mapping_flags & IOMAP_DAX)\n\t\tiomap->dax_dev = target->bt_daxdev;\n\telse\n\t\tiomap->bdev = target->bt_bdev;\n\tiomap->flags = iomap_flags;\n\n\tif (xfs_ipincount(ip) &&\n\t    (ip->i_itemp->ili_fsync_fields & ~XFS_ILOG_TIMESTAMP))\n\t\tiomap->flags |= IOMAP_F_DIRTY;\n\n\tiomap->validity_cookie = sequence_cookie;\n\tiomap->folio_ops = &xfs_iomap_folio_ops;\n\treturn 0;\n}\n\nstatic void\nxfs_hole_to_iomap(\n\tstruct xfs_inode\t*ip,\n\tstruct iomap\t\t*iomap,\n\txfs_fileoff_t\t\toffset_fsb,\n\txfs_fileoff_t\t\tend_fsb)\n{\n\tstruct xfs_buftarg\t*target = xfs_inode_buftarg(ip);\n\n\tiomap->addr = IOMAP_NULL_ADDR;\n\tiomap->type = IOMAP_HOLE;\n\tiomap->offset = XFS_FSB_TO_B(ip->i_mount, offset_fsb);\n\tiomap->length = XFS_FSB_TO_B(ip->i_mount, end_fsb - offset_fsb);\n\tiomap->bdev = target->bt_bdev;\n\tiomap->dax_dev = target->bt_daxdev;\n}\n\nstatic inline xfs_fileoff_t\nxfs_iomap_end_fsb(\n\tstruct xfs_mount\t*mp,\n\tloff_t\t\t\toffset,\n\tloff_t\t\t\tcount)\n{\n\tASSERT(offset <= mp->m_super->s_maxbytes);\n\treturn min(XFS_B_TO_FSB(mp, offset + count),\n\t\t   XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes));\n}\n\nstatic xfs_extlen_t\nxfs_eof_alignment(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_extlen_t\t\talign = 0;\n\n\tif (!XFS_IS_REALTIME_INODE(ip)) {\n\t\t \n\t\tif (mp->m_swidth && xfs_has_swalloc(mp))\n\t\t\talign = mp->m_swidth;\n\t\telse if (mp->m_dalign)\n\t\t\talign = mp->m_dalign;\n\n\t\tif (align && XFS_ISIZE(ip) < XFS_FSB_TO_B(mp, align))\n\t\t\talign = 0;\n\t}\n\n\treturn align;\n}\n\n \nxfs_fileoff_t\nxfs_iomap_eof_align_last_fsb(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tend_fsb)\n{\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, XFS_DATA_FORK);\n\txfs_extlen_t\t\textsz = xfs_get_extsz_hint(ip);\n\txfs_extlen_t\t\talign = xfs_eof_alignment(ip);\n\tstruct xfs_bmbt_irec\tirec;\n\tstruct xfs_iext_cursor\ticur;\n\n\tASSERT(!xfs_need_iread_extents(ifp));\n\n\t \n\tif (extsz) {\n\t\tif (align)\n\t\t\talign = roundup_64(align, extsz);\n\t\telse\n\t\t\talign = extsz;\n\t}\n\n\tif (align) {\n\t\txfs_fileoff_t\taligned_end_fsb = roundup_64(end_fsb, align);\n\n\t\txfs_iext_last(ifp, &icur);\n\t\tif (!xfs_iext_get_extent(ifp, &icur, &irec) ||\n\t\t    aligned_end_fsb >= irec.br_startoff + irec.br_blockcount)\n\t\t\treturn aligned_end_fsb;\n\t}\n\n\treturn end_fsb;\n}\n\nint\nxfs_iomap_write_direct(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\toffset_fsb,\n\txfs_fileoff_t\t\tcount_fsb,\n\tunsigned int\t\tflags,\n\tstruct xfs_bmbt_irec\t*imap,\n\tu64\t\t\t*seq)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\txfs_filblks_t\t\tresaligned;\n\tint\t\t\tnimaps;\n\tunsigned int\t\tdblocks, rblocks;\n\tbool\t\t\tforce = false;\n\tint\t\t\terror;\n\tint\t\t\tbmapi_flags = XFS_BMAPI_PREALLOC;\n\tint\t\t\tnr_exts = XFS_IEXT_ADD_NOSPLIT_CNT;\n\n\tASSERT(count_fsb > 0);\n\n\tresaligned = xfs_aligned_fsb_count(offset_fsb, count_fsb,\n\t\t\t\t\t   xfs_get_extsz_hint(ip));\n\tif (unlikely(XFS_IS_REALTIME_INODE(ip))) {\n\t\tdblocks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\t\trblocks = resaligned;\n\t} else {\n\t\tdblocks = XFS_DIOSTRAT_SPACE_RES(mp, resaligned);\n\t\trblocks = 0;\n\t}\n\n\terror = xfs_qm_dqattach(ip);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (flags & IOMAP_DAX) {\n\t\tbmapi_flags = XFS_BMAPI_CONVERT | XFS_BMAPI_ZERO;\n\t\tif (imap->br_state == XFS_EXT_UNWRITTEN) {\n\t\t\tforce = true;\n\t\t\tnr_exts = XFS_IEXT_WRITE_UNWRITTEN_CNT;\n\t\t\tdblocks = XFS_DIOSTRAT_SPACE_RES(mp, 0) << 1;\n\t\t}\n\t}\n\n\terror = xfs_trans_alloc_inode(ip, &M_RES(mp)->tr_write, dblocks,\n\t\t\trblocks, force, &tp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_iext_count_may_overflow(ip, XFS_DATA_FORK, nr_exts);\n\tif (error == -EFBIG)\n\t\terror = xfs_iext_count_upgrade(tp, ip, nr_exts);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\t \n\tnimaps = 1;\n\terror = xfs_bmapi_write(tp, ip, offset_fsb, count_fsb, bmapi_flags, 0,\n\t\t\t\timap, &nimaps);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\t \n\terror = xfs_trans_commit(tp);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t \n\tif (nimaps == 0) {\n\t\terror = -ENOSPC;\n\t\tgoto out_unlock;\n\t}\n\n\tif (unlikely(!xfs_valid_startblock(ip, imap->br_startblock)))\n\t\terror = xfs_alert_fsblock_zero(ip, imap);\n\nout_unlock:\n\t*seq = xfs_iomap_inode_sequence(ip, 0);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp);\n\tgoto out_unlock;\n}\n\nSTATIC bool\nxfs_quota_need_throttle(\n\tstruct xfs_inode\t*ip,\n\txfs_dqtype_t\t\ttype,\n\txfs_fsblock_t\t\talloc_blocks)\n{\n\tstruct xfs_dquot\t*dq = xfs_inode_dquot(ip, type);\n\n\tif (!dq || !xfs_this_quota_on(ip->i_mount, type))\n\t\treturn false;\n\n\t \n\tif (!dq->q_prealloc_hi_wmark)\n\t\treturn false;\n\n\t \n\tif (dq->q_blk.reserved + alloc_blocks < dq->q_prealloc_lo_wmark)\n\t\treturn false;\n\n\treturn true;\n}\n\nSTATIC void\nxfs_quota_calc_throttle(\n\tstruct xfs_inode\t*ip,\n\txfs_dqtype_t\t\ttype,\n\txfs_fsblock_t\t\t*qblocks,\n\tint\t\t\t*qshift,\n\tint64_t\t\t\t*qfreesp)\n{\n\tstruct xfs_dquot\t*dq = xfs_inode_dquot(ip, type);\n\tint64_t\t\t\tfreesp;\n\tint\t\t\tshift = 0;\n\n\t \n\tif (!dq || dq->q_blk.reserved >= dq->q_prealloc_hi_wmark) {\n\t\t*qblocks = 0;\n\t\t*qfreesp = 0;\n\t\treturn;\n\t}\n\n\tfreesp = dq->q_prealloc_hi_wmark - dq->q_blk.reserved;\n\tif (freesp < dq->q_low_space[XFS_QLOWSP_5_PCNT]) {\n\t\tshift = 2;\n\t\tif (freesp < dq->q_low_space[XFS_QLOWSP_3_PCNT])\n\t\t\tshift += 2;\n\t\tif (freesp < dq->q_low_space[XFS_QLOWSP_1_PCNT])\n\t\t\tshift += 2;\n\t}\n\n\tif (freesp < *qfreesp)\n\t\t*qfreesp = freesp;\n\n\t \n\tif ((freesp >> shift) < (*qblocks >> *qshift)) {\n\t\t*qblocks = freesp;\n\t\t*qshift = shift;\n\t}\n}\n\n \nSTATIC xfs_fsblock_t\nxfs_iomap_prealloc_size(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tloff_t\t\t\toffset,\n\tloff_t\t\t\tcount,\n\tstruct xfs_iext_cursor\t*icur)\n{\n\tstruct xfs_iext_cursor\tncur = *icur;\n\tstruct xfs_bmbt_irec\tprev, got;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, whichfork);\n\txfs_fileoff_t\t\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\tint64_t\t\t\tfreesp;\n\txfs_fsblock_t\t\tqblocks;\n\txfs_fsblock_t\t\talloc_blocks = 0;\n\txfs_extlen_t\t\tplen;\n\tint\t\t\tshift = 0;\n\tint\t\t\tqshift = 0;\n\n\t \n\tif (XFS_ISIZE(ip) < XFS_FSB_TO_B(mp, mp->m_allocsize_blocks))\n\t\treturn 0;\n\n\t \n\tif (XFS_ISIZE(ip) < XFS_FSB_TO_B(mp, mp->m_dalign) ||\n\t    !xfs_iext_prev_extent(ifp, &ncur, &prev) ||\n\t    prev.br_startoff + prev.br_blockcount < offset_fsb)\n\t\treturn mp->m_allocsize_blocks;\n\n\t \n\tplen = prev.br_blockcount;\n\twhile (xfs_iext_prev_extent(ifp, &ncur, &got)) {\n\t\tif (plen > XFS_MAX_BMBT_EXTLEN / 2 ||\n\t\t    isnullstartblock(got.br_startblock) ||\n\t\t    got.br_startoff + got.br_blockcount != prev.br_startoff ||\n\t\t    got.br_startblock + got.br_blockcount != prev.br_startblock)\n\t\t\tbreak;\n\t\tplen += got.br_blockcount;\n\t\tprev = got;\n\t}\n\n\t \n\talloc_blocks = plen * 2;\n\tif (alloc_blocks > XFS_MAX_BMBT_EXTLEN)\n\t\talloc_blocks = XFS_B_TO_FSB(mp, offset);\n\tqblocks = alloc_blocks;\n\n\t \n\talloc_blocks = XFS_FILEOFF_MIN(roundup_pow_of_two(XFS_MAX_BMBT_EXTLEN),\n\t\t\t\t       alloc_blocks);\n\n\tfreesp = percpu_counter_read_positive(&mp->m_fdblocks);\n\tif (freesp < mp->m_low_space[XFS_LOWSP_5_PCNT]) {\n\t\tshift = 2;\n\t\tif (freesp < mp->m_low_space[XFS_LOWSP_4_PCNT])\n\t\t\tshift++;\n\t\tif (freesp < mp->m_low_space[XFS_LOWSP_3_PCNT])\n\t\t\tshift++;\n\t\tif (freesp < mp->m_low_space[XFS_LOWSP_2_PCNT])\n\t\t\tshift++;\n\t\tif (freesp < mp->m_low_space[XFS_LOWSP_1_PCNT])\n\t\t\tshift++;\n\t}\n\n\t \n\tif (xfs_quota_need_throttle(ip, XFS_DQTYPE_USER, alloc_blocks))\n\t\txfs_quota_calc_throttle(ip, XFS_DQTYPE_USER, &qblocks, &qshift,\n\t\t\t\t\t&freesp);\n\tif (xfs_quota_need_throttle(ip, XFS_DQTYPE_GROUP, alloc_blocks))\n\t\txfs_quota_calc_throttle(ip, XFS_DQTYPE_GROUP, &qblocks, &qshift,\n\t\t\t\t\t&freesp);\n\tif (xfs_quota_need_throttle(ip, XFS_DQTYPE_PROJ, alloc_blocks))\n\t\txfs_quota_calc_throttle(ip, XFS_DQTYPE_PROJ, &qblocks, &qshift,\n\t\t\t\t\t&freesp);\n\n\t \n\talloc_blocks = min(alloc_blocks, qblocks);\n\tshift = max(shift, qshift);\n\n\tif (shift)\n\t\talloc_blocks >>= shift;\n\t \n\tif (alloc_blocks)\n\t\talloc_blocks = rounddown_pow_of_two(alloc_blocks);\n\tif (alloc_blocks > XFS_MAX_BMBT_EXTLEN)\n\t\talloc_blocks = XFS_MAX_BMBT_EXTLEN;\n\n\t \n\twhile (alloc_blocks && alloc_blocks >= freesp)\n\t\talloc_blocks >>= 4;\n\tif (alloc_blocks < mp->m_allocsize_blocks)\n\t\talloc_blocks = mp->m_allocsize_blocks;\n\ttrace_xfs_iomap_prealloc_size(ip, alloc_blocks, shift,\n\t\t\t\t      mp->m_allocsize_blocks);\n\treturn alloc_blocks;\n}\n\nint\nxfs_iomap_write_unwritten(\n\txfs_inode_t\t*ip,\n\txfs_off_t\toffset,\n\txfs_off_t\tcount,\n\tbool\t\tupdate_isize)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_fileoff_t\toffset_fsb;\n\txfs_filblks_t\tcount_fsb;\n\txfs_filblks_t\tnumblks_fsb;\n\tint\t\tnimaps;\n\txfs_trans_t\t*tp;\n\txfs_bmbt_irec_t imap;\n\tstruct inode\t*inode = VFS_I(ip);\n\txfs_fsize_t\ti_size;\n\tuint\t\tresblks;\n\tint\t\terror;\n\n\ttrace_xfs_unwritten_convert(ip, offset, count);\n\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\tcount_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + count);\n\tcount_fsb = (xfs_filblks_t)(count_fsb - offset_fsb);\n\n\t \n\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0) << 1;\n\n\t \n\terror = xfs_qm_dqattach(ip);\n\tif (error)\n\t\treturn error;\n\n\tdo {\n\t\t \n\t\terror = xfs_trans_alloc_inode(ip, &M_RES(mp)->tr_write, resblks,\n\t\t\t\t0, true, &tp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = xfs_iext_count_may_overflow(ip, XFS_DATA_FORK,\n\t\t\t\tXFS_IEXT_WRITE_UNWRITTEN_CNT);\n\t\tif (error == -EFBIG)\n\t\t\terror = xfs_iext_count_upgrade(tp, ip,\n\t\t\t\t\tXFS_IEXT_WRITE_UNWRITTEN_CNT);\n\t\tif (error)\n\t\t\tgoto error_on_bmapi_transaction;\n\n\t\t \n\t\tnimaps = 1;\n\t\terror = xfs_bmapi_write(tp, ip, offset_fsb, count_fsb,\n\t\t\t\t\tXFS_BMAPI_CONVERT, resblks, &imap,\n\t\t\t\t\t&nimaps);\n\t\tif (error)\n\t\t\tgoto error_on_bmapi_transaction;\n\n\t\t \n\t\ti_size = XFS_FSB_TO_B(mp, offset_fsb + count_fsb);\n\t\tif (i_size > offset + count)\n\t\t\ti_size = offset + count;\n\t\tif (update_isize && i_size > i_size_read(inode))\n\t\t\ti_size_write(inode, i_size);\n\t\ti_size = xfs_new_eof(ip, i_size);\n\t\tif (i_size) {\n\t\t\tip->i_disk_size = i_size;\n\t\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t\t}\n\n\t\terror = xfs_trans_commit(tp);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (unlikely(!xfs_valid_startblock(ip, imap.br_startblock)))\n\t\t\treturn xfs_alert_fsblock_zero(ip, &imap);\n\n\t\tif ((numblks_fsb = imap.br_blockcount) == 0) {\n\t\t\t \n\t\t\tASSERT(imap.br_blockcount);\n\t\t\tbreak;\n\t\t}\n\t\toffset_fsb += numblks_fsb;\n\t\tcount_fsb -= numblks_fsb;\n\t} while (count_fsb > 0);\n\n\treturn 0;\n\nerror_on_bmapi_transaction:\n\txfs_trans_cancel(tp);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\nstatic inline bool\nimap_needs_alloc(\n\tstruct inode\t\t*inode,\n\tunsigned\t\tflags,\n\tstruct xfs_bmbt_irec\t*imap,\n\tint\t\t\tnimaps)\n{\n\t \n\tif (flags & IOMAP_ZERO)\n\t\treturn false;\n\tif (!nimaps ||\n\t    imap->br_startblock == HOLESTARTBLOCK ||\n\t    imap->br_startblock == DELAYSTARTBLOCK)\n\t\treturn true;\n\t \n\tif ((flags & IOMAP_DAX) && imap->br_state == XFS_EXT_UNWRITTEN)\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool\nimap_needs_cow(\n\tstruct xfs_inode\t*ip,\n\tunsigned int\t\tflags,\n\tstruct xfs_bmbt_irec\t*imap,\n\tint\t\t\tnimaps)\n{\n\tif (!xfs_is_cow_inode(ip))\n\t\treturn false;\n\n\t \n\tif (flags & IOMAP_ZERO) {\n\t\tif (!nimaps ||\n\t\t    imap->br_startblock == HOLESTARTBLOCK ||\n\t\t    imap->br_state == XFS_EXT_UNWRITTEN)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int\nxfs_ilock_for_iomap(\n\tstruct xfs_inode\t*ip,\n\tunsigned\t\tflags,\n\tunsigned\t\t*lockmode)\n{\n\tunsigned int\t\tmode = *lockmode;\n\tbool\t\t\tis_write = flags & (IOMAP_WRITE | IOMAP_ZERO);\n\n\t \n\tif (xfs_is_cow_inode(ip) && is_write)\n\t\tmode = XFS_ILOCK_EXCL;\n\n\t \n\tif (xfs_need_iread_extents(&ip->i_df)) {\n\t\tif (flags & IOMAP_NOWAIT)\n\t\t\treturn -EAGAIN;\n\t\tmode = XFS_ILOCK_EXCL;\n\t}\n\nrelock:\n\tif (flags & IOMAP_NOWAIT) {\n\t\tif (!xfs_ilock_nowait(ip, mode))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\txfs_ilock(ip, mode);\n\t}\n\n\t \n\tif (mode == XFS_ILOCK_SHARED && is_write && xfs_is_cow_inode(ip)) {\n\t\txfs_iunlock(ip, mode);\n\t\tmode = XFS_ILOCK_EXCL;\n\t\tgoto relock;\n\t}\n\n\t*lockmode = mode;\n\treturn 0;\n}\n\n \nstatic bool\nimap_spans_range(\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_fileoff_t\t\toffset_fsb,\n\txfs_fileoff_t\t\tend_fsb)\n{\n\tif (imap->br_startoff > offset_fsb)\n\t\treturn false;\n\tif (imap->br_startoff + imap->br_blockcount < end_fsb)\n\t\treturn false;\n\treturn true;\n}\n\nstatic int\nxfs_direct_write_iomap_begin(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\toffset,\n\tloff_t\t\t\tlength,\n\tunsigned\t\tflags,\n\tstruct iomap\t\t*iomap,\n\tstruct iomap\t\t*srcmap)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_bmbt_irec\timap, cmap;\n\txfs_fileoff_t\t\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\txfs_fileoff_t\t\tend_fsb = xfs_iomap_end_fsb(mp, offset, length);\n\tint\t\t\tnimaps = 1, error = 0;\n\tbool\t\t\tshared = false;\n\tu16\t\t\tiomap_flags = 0;\n\tunsigned int\t\tlockmode = XFS_ILOCK_SHARED;\n\tu64\t\t\tseq;\n\n\tASSERT(flags & (IOMAP_WRITE | IOMAP_ZERO));\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\t \n\tif (offset + length > i_size_read(inode))\n\t\tiomap_flags |= IOMAP_F_DIRTY;\n\n\terror = xfs_ilock_for_iomap(ip, flags, &lockmode);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb, &imap,\n\t\t\t       &nimaps, 0);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tif (imap_needs_cow(ip, flags, &imap, nimaps)) {\n\t\terror = -EAGAIN;\n\t\tif (flags & IOMAP_NOWAIT)\n\t\t\tgoto out_unlock;\n\n\t\t \n\t\terror = xfs_reflink_allocate_cow(ip, &imap, &cmap, &shared,\n\t\t\t\t&lockmode,\n\t\t\t\t(flags & IOMAP_DIRECT) || IS_DAX(inode));\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\t\tif (shared)\n\t\t\tgoto out_found_cow;\n\t\tend_fsb = imap.br_startoff + imap.br_blockcount;\n\t\tlength = XFS_FSB_TO_B(mp, end_fsb) - offset;\n\t}\n\n\tif (imap_needs_alloc(inode, flags, &imap, nimaps))\n\t\tgoto allocate_blocks;\n\n\t \n\tif (flags & (IOMAP_NOWAIT | IOMAP_OVERWRITE_ONLY)) {\n\t\terror = -EAGAIN;\n\t\tif (!imap_spans_range(&imap, offset_fsb, end_fsb))\n\t\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (flags & IOMAP_OVERWRITE_ONLY) {\n\t\terror = -EAGAIN;\n\t\tif (imap.br_state != XFS_EXT_NORM &&\n\t            ((offset | length) & mp->m_blockmask))\n\t\t\tgoto out_unlock;\n\t}\n\n\tseq = xfs_iomap_inode_sequence(ip, iomap_flags);\n\txfs_iunlock(ip, lockmode);\n\ttrace_xfs_iomap_found(ip, offset, length, XFS_DATA_FORK, &imap);\n\treturn xfs_bmbt_to_iomap(ip, iomap, &imap, flags, iomap_flags, seq);\n\nallocate_blocks:\n\terror = -EAGAIN;\n\tif (flags & (IOMAP_NOWAIT | IOMAP_OVERWRITE_ONLY))\n\t\tgoto out_unlock;\n\n\t \n\tlength = min_t(loff_t, length, 1024 * PAGE_SIZE);\n\tend_fsb = xfs_iomap_end_fsb(mp, offset, length);\n\n\tif (offset + length > XFS_ISIZE(ip))\n\t\tend_fsb = xfs_iomap_eof_align_last_fsb(ip, end_fsb);\n\telse if (nimaps && imap.br_startblock == HOLESTARTBLOCK)\n\t\tend_fsb = min(end_fsb, imap.br_startoff + imap.br_blockcount);\n\txfs_iunlock(ip, lockmode);\n\n\terror = xfs_iomap_write_direct(ip, offset_fsb, end_fsb - offset_fsb,\n\t\t\tflags, &imap, &seq);\n\tif (error)\n\t\treturn error;\n\n\ttrace_xfs_iomap_alloc(ip, offset, length, XFS_DATA_FORK, &imap);\n\treturn xfs_bmbt_to_iomap(ip, iomap, &imap, flags,\n\t\t\t\t iomap_flags | IOMAP_F_NEW, seq);\n\nout_found_cow:\n\tlength = XFS_FSB_TO_B(mp, cmap.br_startoff + cmap.br_blockcount);\n\ttrace_xfs_iomap_found(ip, offset, length - offset, XFS_COW_FORK, &cmap);\n\tif (imap.br_startblock != HOLESTARTBLOCK) {\n\t\tseq = xfs_iomap_inode_sequence(ip, 0);\n\t\terror = xfs_bmbt_to_iomap(ip, srcmap, &imap, flags, 0, seq);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\t}\n\tseq = xfs_iomap_inode_sequence(ip, IOMAP_F_SHARED);\n\txfs_iunlock(ip, lockmode);\n\treturn xfs_bmbt_to_iomap(ip, iomap, &cmap, flags, IOMAP_F_SHARED, seq);\n\nout_unlock:\n\tif (lockmode)\n\t\txfs_iunlock(ip, lockmode);\n\treturn error;\n}\n\nconst struct iomap_ops xfs_direct_write_iomap_ops = {\n\t.iomap_begin\t\t= xfs_direct_write_iomap_begin,\n};\n\nstatic int\nxfs_dax_write_iomap_end(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\tpos,\n\tloff_t\t\t\tlength,\n\tssize_t\t\t\twritten,\n\tunsigned\t\tflags,\n\tstruct iomap\t\t*iomap)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\n\tif (!xfs_is_cow_inode(ip))\n\t\treturn 0;\n\n\tif (!written) {\n\t\txfs_reflink_cancel_cow_range(ip, pos, length, true);\n\t\treturn 0;\n\t}\n\n\treturn xfs_reflink_end_cow(ip, pos, written);\n}\n\nconst struct iomap_ops xfs_dax_write_iomap_ops = {\n\t.iomap_begin\t= xfs_direct_write_iomap_begin,\n\t.iomap_end\t= xfs_dax_write_iomap_end,\n};\n\nstatic int\nxfs_buffered_write_iomap_begin(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\toffset,\n\tloff_t\t\t\tcount,\n\tunsigned\t\tflags,\n\tstruct iomap\t\t*iomap,\n\tstruct iomap\t\t*srcmap)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\txfs_fileoff_t\t\tend_fsb = xfs_iomap_end_fsb(mp, offset, count);\n\tstruct xfs_bmbt_irec\timap, cmap;\n\tstruct xfs_iext_cursor\ticur, ccur;\n\txfs_fsblock_t\t\tprealloc_blocks = 0;\n\tbool\t\t\teof = false, cow_eof = false, shared = false;\n\tint\t\t\tallocfork = XFS_DATA_FORK;\n\tint\t\t\terror = 0;\n\tunsigned int\t\tlockmode = XFS_ILOCK_EXCL;\n\tu64\t\t\tseq;\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\t \n\tif (xfs_get_extsz_hint(ip))\n\t\treturn xfs_direct_write_iomap_begin(inode, offset, count,\n\t\t\t\tflags, iomap, srcmap);\n\n\tASSERT(!XFS_IS_REALTIME_INODE(ip));\n\n\terror = xfs_qm_dqattach(ip);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_ilock_for_iomap(ip, flags, &lockmode);\n\tif (error)\n\t\treturn error;\n\n\tif (XFS_IS_CORRUPT(mp, !xfs_ifork_has_extents(&ip->i_df)) ||\n\t    XFS_TEST_ERROR(false, mp, XFS_ERRTAG_BMAPIFORMAT)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_unlock;\n\t}\n\n\tXFS_STATS_INC(mp, xs_blk_mapw);\n\n\terror = xfs_iread_extents(NULL, ip, XFS_DATA_FORK);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t \n\teof = !xfs_iext_lookup_extent(ip, &ip->i_df, offset_fsb, &icur, &imap);\n\tif (eof)\n\t\timap.br_startoff = end_fsb;  \n\n\t \n\tif ((flags & (IOMAP_UNSHARE | IOMAP_ZERO)) &&\n\t    imap.br_startoff > offset_fsb) {\n\t\txfs_hole_to_iomap(ip, iomap, offset_fsb, imap.br_startoff);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (xfs_is_cow_inode(ip)) {\n\t\tif (!ip->i_cowfp) {\n\t\t\tASSERT(!xfs_is_reflink_inode(ip));\n\t\t\txfs_ifork_init_cow(ip);\n\t\t}\n\t\tcow_eof = !xfs_iext_lookup_extent(ip, ip->i_cowfp, offset_fsb,\n\t\t\t\t&ccur, &cmap);\n\t\tif (!cow_eof && cmap.br_startoff <= offset_fsb) {\n\t\t\ttrace_xfs_reflink_cow_found(ip, &cmap);\n\t\t\tgoto found_cow;\n\t\t}\n\t}\n\n\tif (imap.br_startoff <= offset_fsb) {\n\t\t \n\t\tif (!xfs_is_cow_inode(ip) ||\n\t\t    ((flags & IOMAP_ZERO) && imap.br_state != XFS_EXT_NORM)) {\n\t\t\ttrace_xfs_iomap_found(ip, offset, count, XFS_DATA_FORK,\n\t\t\t\t\t&imap);\n\t\t\tgoto found_imap;\n\t\t}\n\n\t\txfs_trim_extent(&imap, offset_fsb, end_fsb - offset_fsb);\n\n\t\t \n\t\terror = xfs_bmap_trim_cow(ip, &imap, &shared);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\n\t\t \n\t\tif (!shared) {\n\t\t\ttrace_xfs_iomap_found(ip, offset, count, XFS_DATA_FORK,\n\t\t\t\t\t&imap);\n\t\t\tgoto found_imap;\n\t\t}\n\n\t\t \n\t\tallocfork = XFS_COW_FORK;\n\t\tend_fsb = imap.br_startoff + imap.br_blockcount;\n\t} else {\n\t\t \n\t\tcount = min_t(loff_t, count, 1024 * PAGE_SIZE);\n\t\tend_fsb = xfs_iomap_end_fsb(mp, offset, count);\n\n\t\tif (xfs_is_always_cow_inode(ip))\n\t\t\tallocfork = XFS_COW_FORK;\n\t}\n\n\tif (eof && offset + count > XFS_ISIZE(ip)) {\n\t\t \n\t\tif (xfs_has_allocsize(mp))\n\t\t\tprealloc_blocks = mp->m_allocsize_blocks;\n\t\telse if (allocfork == XFS_DATA_FORK)\n\t\t\tprealloc_blocks = xfs_iomap_prealloc_size(ip, allocfork,\n\t\t\t\t\t\toffset, count, &icur);\n\t\telse\n\t\t\tprealloc_blocks = xfs_iomap_prealloc_size(ip, allocfork,\n\t\t\t\t\t\toffset, count, &ccur);\n\t\tif (prealloc_blocks) {\n\t\t\txfs_extlen_t\talign;\n\t\t\txfs_off_t\tend_offset;\n\t\t\txfs_fileoff_t\tp_end_fsb;\n\n\t\t\tend_offset = XFS_ALLOC_ALIGN(mp, offset + count - 1);\n\t\t\tp_end_fsb = XFS_B_TO_FSBT(mp, end_offset) +\n\t\t\t\t\tprealloc_blocks;\n\n\t\t\talign = xfs_eof_alignment(ip);\n\t\t\tif (align)\n\t\t\t\tp_end_fsb = roundup_64(p_end_fsb, align);\n\n\t\t\tp_end_fsb = min(p_end_fsb,\n\t\t\t\tXFS_B_TO_FSB(mp, mp->m_super->s_maxbytes));\n\t\t\tASSERT(p_end_fsb > offset_fsb);\n\t\t\tprealloc_blocks = p_end_fsb - end_fsb;\n\t\t}\n\t}\n\nretry:\n\terror = xfs_bmapi_reserve_delalloc(ip, allocfork, offset_fsb,\n\t\t\tend_fsb - offset_fsb, prealloc_blocks,\n\t\t\tallocfork == XFS_DATA_FORK ? &imap : &cmap,\n\t\t\tallocfork == XFS_DATA_FORK ? &icur : &ccur,\n\t\t\tallocfork == XFS_DATA_FORK ? eof : cow_eof);\n\tswitch (error) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOSPC:\n\tcase -EDQUOT:\n\t\t \n\t\ttrace_xfs_delalloc_enospc(ip, offset, count);\n\t\tif (prealloc_blocks) {\n\t\t\tprealloc_blocks = 0;\n\t\t\tgoto retry;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tgoto out_unlock;\n\t}\n\n\tif (allocfork == XFS_COW_FORK) {\n\t\ttrace_xfs_iomap_alloc(ip, offset, count, allocfork, &cmap);\n\t\tgoto found_cow;\n\t}\n\n\t \n\tseq = xfs_iomap_inode_sequence(ip, IOMAP_F_NEW);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\ttrace_xfs_iomap_alloc(ip, offset, count, allocfork, &imap);\n\treturn xfs_bmbt_to_iomap(ip, iomap, &imap, flags, IOMAP_F_NEW, seq);\n\nfound_imap:\n\tseq = xfs_iomap_inode_sequence(ip, 0);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn xfs_bmbt_to_iomap(ip, iomap, &imap, flags, 0, seq);\n\nfound_cow:\n\tseq = xfs_iomap_inode_sequence(ip, 0);\n\tif (imap.br_startoff <= offset_fsb) {\n\t\terror = xfs_bmbt_to_iomap(ip, srcmap, &imap, flags, 0, seq);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\t\tseq = xfs_iomap_inode_sequence(ip, IOMAP_F_SHARED);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\treturn xfs_bmbt_to_iomap(ip, iomap, &cmap, flags,\n\t\t\t\t\t IOMAP_F_SHARED, seq);\n\t}\n\n\txfs_trim_extent(&cmap, offset_fsb, imap.br_startoff - offset_fsb);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn xfs_bmbt_to_iomap(ip, iomap, &cmap, flags, 0, seq);\n\nout_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\nstatic int\nxfs_buffered_write_delalloc_punch(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\toffset,\n\tloff_t\t\t\tlength)\n{\n\treturn xfs_bmap_punch_delalloc_range(XFS_I(inode), offset,\n\t\t\toffset + length);\n}\n\nstatic int\nxfs_buffered_write_iomap_end(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\toffset,\n\tloff_t\t\t\tlength,\n\tssize_t\t\t\twritten,\n\tunsigned\t\tflags,\n\tstruct iomap\t\t*iomap)\n{\n\n\tstruct xfs_mount\t*mp = XFS_M(inode->i_sb);\n\tint\t\t\terror;\n\n\terror = iomap_file_buffered_write_punch_delalloc(inode, iomap, offset,\n\t\t\tlength, written, &xfs_buffered_write_delalloc_punch);\n\tif (error && !xfs_is_shutdown(mp)) {\n\t\txfs_alert(mp, \"%s: unable to clean up ino 0x%llx\",\n\t\t\t__func__, XFS_I(inode)->i_ino);\n\t\treturn error;\n\t}\n\treturn 0;\n}\n\nconst struct iomap_ops xfs_buffered_write_iomap_ops = {\n\t.iomap_begin\t\t= xfs_buffered_write_iomap_begin,\n\t.iomap_end\t\t= xfs_buffered_write_iomap_end,\n};\n\n \nconst struct iomap_ops xfs_page_mkwrite_iomap_ops = {\n\t.iomap_begin\t\t= xfs_buffered_write_iomap_begin,\n};\n\nstatic int\nxfs_read_iomap_begin(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\toffset,\n\tloff_t\t\t\tlength,\n\tunsigned\t\tflags,\n\tstruct iomap\t\t*iomap,\n\tstruct iomap\t\t*srcmap)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_bmbt_irec\timap;\n\txfs_fileoff_t\t\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\txfs_fileoff_t\t\tend_fsb = xfs_iomap_end_fsb(mp, offset, length);\n\tint\t\t\tnimaps = 1, error = 0;\n\tbool\t\t\tshared = false;\n\tunsigned int\t\tlockmode = XFS_ILOCK_SHARED;\n\tu64\t\t\tseq;\n\n\tASSERT(!(flags & (IOMAP_WRITE | IOMAP_ZERO)));\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\terror = xfs_ilock_for_iomap(ip, flags, &lockmode);\n\tif (error)\n\t\treturn error;\n\terror = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb, &imap,\n\t\t\t       &nimaps, 0);\n\tif (!error && ((flags & IOMAP_REPORT) || IS_DAX(inode)))\n\t\terror = xfs_reflink_trim_around_shared(ip, &imap, &shared);\n\tseq = xfs_iomap_inode_sequence(ip, shared ? IOMAP_F_SHARED : 0);\n\txfs_iunlock(ip, lockmode);\n\n\tif (error)\n\t\treturn error;\n\ttrace_xfs_iomap_found(ip, offset, length, XFS_DATA_FORK, &imap);\n\treturn xfs_bmbt_to_iomap(ip, iomap, &imap, flags,\n\t\t\t\t shared ? IOMAP_F_SHARED : 0, seq);\n}\n\nconst struct iomap_ops xfs_read_iomap_ops = {\n\t.iomap_begin\t\t= xfs_read_iomap_begin,\n};\n\nstatic int\nxfs_seek_iomap_begin(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\toffset,\n\tloff_t\t\t\tlength,\n\tunsigned\t\tflags,\n\tstruct iomap\t\t*iomap,\n\tstruct iomap\t\t*srcmap)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\txfs_fileoff_t\t\tend_fsb = XFS_B_TO_FSB(mp, offset + length);\n\txfs_fileoff_t\t\tcow_fsb = NULLFILEOFF, data_fsb = NULLFILEOFF;\n\tstruct xfs_iext_cursor\ticur;\n\tstruct xfs_bmbt_irec\timap, cmap;\n\tint\t\t\terror = 0;\n\tunsigned\t\tlockmode;\n\tu64\t\t\tseq;\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\tlockmode = xfs_ilock_data_map_shared(ip);\n\terror = xfs_iread_extents(NULL, ip, XFS_DATA_FORK);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tif (xfs_iext_lookup_extent(ip, &ip->i_df, offset_fsb, &icur, &imap)) {\n\t\t \n\t\tif (imap.br_startoff <= offset_fsb)\n\t\t\tgoto done;\n\t\tdata_fsb = imap.br_startoff;\n\t} else {\n\t\t \n\t\tdata_fsb = xfs_iomap_end_fsb(mp, offset, length);\n\t}\n\n\t \n\tif (xfs_inode_has_cow_data(ip) &&\n\t    xfs_iext_lookup_extent(ip, ip->i_cowfp, offset_fsb, &icur, &cmap))\n\t\tcow_fsb = cmap.br_startoff;\n\tif (cow_fsb != NULLFILEOFF && cow_fsb <= offset_fsb) {\n\t\tif (data_fsb < cow_fsb + cmap.br_blockcount)\n\t\t\tend_fsb = min(end_fsb, data_fsb);\n\t\txfs_trim_extent(&cmap, offset_fsb, end_fsb);\n\t\tseq = xfs_iomap_inode_sequence(ip, IOMAP_F_SHARED);\n\t\terror = xfs_bmbt_to_iomap(ip, iomap, &cmap, flags,\n\t\t\t\tIOMAP_F_SHARED, seq);\n\t\t \n\t\tiomap->type = IOMAP_UNWRITTEN;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (cow_fsb != NULLFILEOFF && cow_fsb < data_fsb)\n\t\timap.br_blockcount = cow_fsb - offset_fsb;\n\telse\n\t\timap.br_blockcount = data_fsb - offset_fsb;\n\timap.br_startoff = offset_fsb;\n\timap.br_startblock = HOLESTARTBLOCK;\n\timap.br_state = XFS_EXT_NORM;\ndone:\n\tseq = xfs_iomap_inode_sequence(ip, 0);\n\txfs_trim_extent(&imap, offset_fsb, end_fsb);\n\terror = xfs_bmbt_to_iomap(ip, iomap, &imap, flags, 0, seq);\nout_unlock:\n\txfs_iunlock(ip, lockmode);\n\treturn error;\n}\n\nconst struct iomap_ops xfs_seek_iomap_ops = {\n\t.iomap_begin\t\t= xfs_seek_iomap_begin,\n};\n\nstatic int\nxfs_xattr_iomap_begin(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\toffset,\n\tloff_t\t\t\tlength,\n\tunsigned\t\tflags,\n\tstruct iomap\t\t*iomap,\n\tstruct iomap\t\t*srcmap)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\txfs_fileoff_t\t\tend_fsb = XFS_B_TO_FSB(mp, offset + length);\n\tstruct xfs_bmbt_irec\timap;\n\tint\t\t\tnimaps = 1, error = 0;\n\tunsigned\t\tlockmode;\n\tint\t\t\tseq;\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\tlockmode = xfs_ilock_attr_map_shared(ip);\n\n\t \n\tif (!xfs_inode_has_attr_fork(ip) || !ip->i_af.if_nextents) {\n\t\terror = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\tASSERT(ip->i_af.if_format != XFS_DINODE_FMT_LOCAL);\n\terror = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb, &imap,\n\t\t\t       &nimaps, XFS_BMAPI_ATTRFORK);\nout_unlock:\n\n\tseq = xfs_iomap_inode_sequence(ip, IOMAP_F_XATTR);\n\txfs_iunlock(ip, lockmode);\n\n\tif (error)\n\t\treturn error;\n\tASSERT(nimaps);\n\treturn xfs_bmbt_to_iomap(ip, iomap, &imap, flags, IOMAP_F_XATTR, seq);\n}\n\nconst struct iomap_ops xfs_xattr_iomap_ops = {\n\t.iomap_begin\t\t= xfs_xattr_iomap_begin,\n};\n\nint\nxfs_zero_range(\n\tstruct xfs_inode\t*ip,\n\tloff_t\t\t\tpos,\n\tloff_t\t\t\tlen,\n\tbool\t\t\t*did_zero)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\tif (IS_DAX(inode))\n\t\treturn dax_zero_range(inode, pos, len, did_zero,\n\t\t\t\t      &xfs_dax_write_iomap_ops);\n\treturn iomap_zero_range(inode, pos, len, did_zero,\n\t\t\t\t&xfs_buffered_write_iomap_ops);\n}\n\nint\nxfs_truncate_page(\n\tstruct xfs_inode\t*ip,\n\tloff_t\t\t\tpos,\n\tbool\t\t\t*did_zero)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\tif (IS_DAX(inode))\n\t\treturn dax_truncate_page(inode, pos, did_zero,\n\t\t\t\t\t&xfs_dax_write_iomap_ops);\n\treturn iomap_truncate_page(inode, pos, did_zero,\n\t\t\t\t   &xfs_buffered_write_iomap_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}