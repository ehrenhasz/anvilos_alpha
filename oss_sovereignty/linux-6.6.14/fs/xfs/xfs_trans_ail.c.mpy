{
  "module_name": "xfs_trans_ail.c",
  "hash_id": "876f36df26e74ae3bd13b49366c0d0f28b08126d8fe2a39e3b6eb5ff036fabfe",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_trans_ail.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_errortag.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_log_priv.h\"\n\n#ifdef DEBUG\n \nSTATIC void\nxfs_ail_check(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t*lip)\n\t__must_hold(&ailp->ail_lock)\n{\n\tstruct xfs_log_item\t*prev_lip;\n\tstruct xfs_log_item\t*next_lip;\n\txfs_lsn_t\t\tprev_lsn = NULLCOMMITLSN;\n\txfs_lsn_t\t\tnext_lsn = NULLCOMMITLSN;\n\txfs_lsn_t\t\tlsn;\n\tbool\t\t\tin_ail;\n\n\n\tif (list_empty(&ailp->ail_head))\n\t\treturn;\n\n\t \n\tin_ail = test_bit(XFS_LI_IN_AIL, &lip->li_flags);\n\tprev_lip = list_entry(lip->li_ail.prev, struct xfs_log_item, li_ail);\n\tif (&prev_lip->li_ail != &ailp->ail_head)\n\t\tprev_lsn = prev_lip->li_lsn;\n\tnext_lip = list_entry(lip->li_ail.next, struct xfs_log_item, li_ail);\n\tif (&next_lip->li_ail != &ailp->ail_head)\n\t\tnext_lsn = next_lip->li_lsn;\n\tlsn = lip->li_lsn;\n\n\tif (in_ail &&\n\t    (prev_lsn == NULLCOMMITLSN || XFS_LSN_CMP(prev_lsn, lsn) <= 0) &&\n\t    (next_lsn == NULLCOMMITLSN || XFS_LSN_CMP(next_lsn, lsn) >= 0))\n\t\treturn;\n\n\tspin_unlock(&ailp->ail_lock);\n\tASSERT(in_ail);\n\tASSERT(prev_lsn == NULLCOMMITLSN || XFS_LSN_CMP(prev_lsn, lsn) <= 0);\n\tASSERT(next_lsn == NULLCOMMITLSN || XFS_LSN_CMP(next_lsn, lsn) >= 0);\n\tspin_lock(&ailp->ail_lock);\n}\n#else  \n#define\txfs_ail_check(a,l)\n#endif  \n\n \nstatic struct xfs_log_item *\nxfs_ail_max(\n\tstruct xfs_ail  *ailp)\n{\n\tif (list_empty(&ailp->ail_head))\n\t\treturn NULL;\n\n\treturn list_entry(ailp->ail_head.prev, struct xfs_log_item, li_ail);\n}\n\n \nstatic struct xfs_log_item *\nxfs_ail_next(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t*lip)\n{\n\tif (lip->li_ail.next == &ailp->ail_head)\n\t\treturn NULL;\n\n\treturn list_first_entry(&lip->li_ail, struct xfs_log_item, li_ail);\n}\n\n \nstatic xfs_lsn_t\n__xfs_ail_min_lsn(\n\tstruct xfs_ail\t\t*ailp)\n{\n\tstruct xfs_log_item\t*lip = xfs_ail_min(ailp);\n\n\tif (lip)\n\t\treturn lip->li_lsn;\n\treturn 0;\n}\n\nxfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t\t*ailp)\n{\n\txfs_lsn_t\t\tlsn;\n\n\tspin_lock(&ailp->ail_lock);\n\tlsn = __xfs_ail_min_lsn(ailp);\n\tspin_unlock(&ailp->ail_lock);\n\n\treturn lsn;\n}\n\n \nstatic xfs_lsn_t\nxfs_ail_max_lsn(\n\tstruct xfs_ail\t\t*ailp)\n{\n\txfs_lsn_t       \tlsn = 0;\n\tstruct xfs_log_item\t*lip;\n\n\tspin_lock(&ailp->ail_lock);\n\tlip = xfs_ail_max(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->ail_lock);\n\n\treturn lsn;\n}\n\n \nSTATIC void\nxfs_trans_ail_cursor_init(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tcur->item = NULL;\n\tlist_add_tail(&cur->list, &ailp->ail_cursors);\n}\n\n \nstruct xfs_log_item *\nxfs_trans_ail_cursor_next(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tstruct xfs_log_item\t*lip = cur->item;\n\n\tif ((uintptr_t)lip & 1)\n\t\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tcur->item = xfs_ail_next(ailp, lip);\n\treturn lip;\n}\n\n \nvoid\nxfs_trans_ail_cursor_done(\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tcur->item = NULL;\n\tlist_del_init(&cur->list);\n}\n\n \nSTATIC void\nxfs_trans_ail_cursor_clear(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_ail_cursor\t*cur;\n\n\tlist_for_each_entry(cur, &ailp->ail_cursors, list) {\n\t\tif (cur->item == lip)\n\t\t\tcur->item = (struct xfs_log_item *)\n\t\t\t\t\t((uintptr_t)cur->item | 1);\n\t}\n}\n\n \nstruct xfs_log_item *\nxfs_trans_ail_cursor_first(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\txfs_lsn_t\t\tlsn)\n{\n\tstruct xfs_log_item\t*lip;\n\n\txfs_trans_ail_cursor_init(ailp, cur);\n\n\tif (lsn == 0) {\n\t\tlip = xfs_ail_min(ailp);\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lip, &ailp->ail_head, li_ail) {\n\t\tif (XFS_LSN_CMP(lip->li_lsn, lsn) >= 0)\n\t\t\tgoto out;\n\t}\n\treturn NULL;\n\nout:\n\tif (lip)\n\t\tcur->item = xfs_ail_next(ailp, lip);\n\treturn lip;\n}\n\nstatic struct xfs_log_item *\n__xfs_trans_ail_cursor_last(\n\tstruct xfs_ail\t\t*ailp,\n\txfs_lsn_t\t\tlsn)\n{\n\tstruct xfs_log_item\t*lip;\n\n\tlist_for_each_entry_reverse(lip, &ailp->ail_head, li_ail) {\n\t\tif (XFS_LSN_CMP(lip->li_lsn, lsn) <= 0)\n\t\t\treturn lip;\n\t}\n\treturn NULL;\n}\n\n \nstruct xfs_log_item *\nxfs_trans_ail_cursor_last(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_trans_ail_cursor_init(ailp, cur);\n\tcur->item = __xfs_trans_ail_cursor_last(ailp, lsn);\n\treturn cur->item;\n}\n\n \nstatic void\nxfs_ail_splice(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\tstruct list_head\t*list,\n\txfs_lsn_t\t\tlsn)\n{\n\tstruct xfs_log_item\t*lip;\n\n\tASSERT(!list_empty(list));\n\n\t \n\tlip = cur ? cur->item : NULL;\n\tif (!lip || (uintptr_t)lip & 1)\n\t\tlip = __xfs_trans_ail_cursor_last(ailp, lsn);\n\n\t \n\tif (cur)\n\t\tcur->item = list_entry(list->prev, struct xfs_log_item, li_ail);\n\n\t \n\tif (lip)\n\t\tlist_splice(list, &lip->li_ail);\n\telse\n\t\tlist_splice(list, &ailp->ail_head);\n}\n\n \nstatic void\nxfs_ail_delete(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t*lip)\n{\n\txfs_ail_check(ailp, lip);\n\tlist_del(&lip->li_ail);\n\txfs_trans_ail_cursor_clear(ailp, lip);\n}\n\n \nstatic inline int\nxfsaild_resubmit_item(\n\tstruct xfs_log_item\t*lip,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_buf\t\t*bp = lip->li_buf;\n\n\tif (!xfs_buf_trylock(bp))\n\t\treturn XFS_ITEM_LOCKED;\n\n\tif (!xfs_buf_delwri_queue(bp, buffer_list)) {\n\t\txfs_buf_unlock(bp);\n\t\treturn XFS_ITEM_FLUSHING;\n\t}\n\n\t \n\tlist_for_each_entry(lip, &bp->b_li_list, li_bio_list) {\n\t\tif (bp->b_flags & _XBF_INODES)\n\t\t\tclear_bit(XFS_LI_FAILED, &lip->li_flags);\n\t\telse\n\t\t\txfs_clear_li_failed(lip);\n\t}\n\n\txfs_buf_unlock(bp);\n\treturn XFS_ITEM_SUCCESS;\n}\n\nstatic inline uint\nxfsaild_push_item(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t*lip)\n{\n\t \n\tif (XFS_TEST_ERROR(false, ailp->ail_log->l_mp, XFS_ERRTAG_LOG_ITEM_PIN))\n\t\treturn XFS_ITEM_PINNED;\n\n\t \n\tif (!lip->li_ops->iop_push)\n\t\treturn XFS_ITEM_PINNED;\n\tif (test_bit(XFS_LI_FAILED, &lip->li_flags))\n\t\treturn xfsaild_resubmit_item(lip, &ailp->ail_buf_list);\n\treturn lip->li_ops->iop_push(lip, &ailp->ail_buf_list);\n}\n\nstatic long\nxfsaild_push(\n\tstruct xfs_ail\t\t*ailp)\n{\n\tstruct xfs_mount\t*mp = ailp->ail_log->l_mp;\n\tstruct xfs_ail_cursor\tcur;\n\tstruct xfs_log_item\t*lip;\n\txfs_lsn_t\t\tlsn;\n\txfs_lsn_t\t\ttarget = NULLCOMMITLSN;\n\tlong\t\t\ttout;\n\tint\t\t\tstuck = 0;\n\tint\t\t\tflushing = 0;\n\tint\t\t\tcount = 0;\n\n\t \n\tif (ailp->ail_log_flush && ailp->ail_last_pushed_lsn == 0 &&\n\t    (!list_empty_careful(&ailp->ail_buf_list) ||\n\t     xfs_ail_min_lsn(ailp))) {\n\t\tailp->ail_log_flush = 0;\n\n\t\tXFS_STATS_INC(mp, xs_push_ail_flush);\n\t\txlog_cil_flush(ailp->ail_log);\n\t}\n\n\tspin_lock(&ailp->ail_lock);\n\n\t \n\tif (waitqueue_active(&ailp->ail_empty)) {\n\t\tlip = xfs_ail_max(ailp);\n\t\tif (lip)\n\t\t\ttarget = lip->li_lsn;\n\t} else {\n\t\t \n\t\tsmp_rmb();\n\t\ttarget = ailp->ail_target;\n\t\tailp->ail_target_prev = target;\n\t}\n\n\t \n\tlip = xfs_trans_ail_cursor_first(ailp, &cur, ailp->ail_last_pushed_lsn);\n\tif (!lip)\n\t\tgoto out_done;\n\n\tXFS_STATS_INC(mp, xs_push_ail);\n\n\tASSERT(target != NULLCOMMITLSN);\n\n\tlsn = lip->li_lsn;\n\twhile ((XFS_LSN_CMP(lip->li_lsn, target) <= 0)) {\n\t\tint\tlock_result;\n\n\t\t \n\t\tlock_result = xfsaild_push_item(ailp, lip);\n\t\tswitch (lock_result) {\n\t\tcase XFS_ITEM_SUCCESS:\n\t\t\tXFS_STATS_INC(mp, xs_push_ail_success);\n\t\t\ttrace_xfs_ail_push(lip);\n\n\t\t\tailp->ail_last_pushed_lsn = lsn;\n\t\t\tbreak;\n\n\t\tcase XFS_ITEM_FLUSHING:\n\t\t\t \n\t\t\tXFS_STATS_INC(mp, xs_push_ail_flushing);\n\t\t\ttrace_xfs_ail_flushing(lip);\n\n\t\t\tflushing++;\n\t\t\tailp->ail_last_pushed_lsn = lsn;\n\t\t\tbreak;\n\n\t\tcase XFS_ITEM_PINNED:\n\t\t\tXFS_STATS_INC(mp, xs_push_ail_pinned);\n\t\t\ttrace_xfs_ail_pinned(lip);\n\n\t\t\tstuck++;\n\t\t\tailp->ail_log_flush++;\n\t\t\tbreak;\n\t\tcase XFS_ITEM_LOCKED:\n\t\t\tXFS_STATS_INC(mp, xs_push_ail_locked);\n\t\t\ttrace_xfs_ail_locked(lip);\n\n\t\t\tstuck++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount++;\n\n\t\t \n\t\tif (stuck > 100)\n\t\t\tbreak;\n\n\t\tlip = xfs_trans_ail_cursor_next(ailp, &cur);\n\t\tif (lip == NULL)\n\t\t\tbreak;\n\t\tlsn = lip->li_lsn;\n\t}\n\nout_done:\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->ail_lock);\n\n\tif (xfs_buf_delwri_submit_nowait(&ailp->ail_buf_list))\n\t\tailp->ail_log_flush++;\n\n\tif (!count || XFS_LSN_CMP(lsn, target) >= 0) {\n\t\t \n\t\ttout = 50;\n\t\tailp->ail_last_pushed_lsn = 0;\n\t} else if (((stuck + flushing) * 100) / count > 90) {\n\t\t \n\t\ttout = 20;\n\t\tailp->ail_last_pushed_lsn = 0;\n\t} else {\n\t\t \n\t\ttout = 10;\n\t}\n\n\treturn tout;\n}\n\nstatic int\nxfsaild(\n\tvoid\t\t*data)\n{\n\tstruct xfs_ail\t*ailp = data;\n\tlong\t\ttout = 0;\t \n\tunsigned int\tnoreclaim_flag;\n\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\tset_freezable();\n\n\twhile (1) {\n\t\tif (tout && tout <= 20)\n\t\t\tset_current_state(TASK_KILLABLE|TASK_FREEZABLE);\n\t\telse\n\t\t\tset_current_state(TASK_INTERRUPTIBLE|TASK_FREEZABLE);\n\n\t\t \n\t\tif (kthread_should_stop()) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\n\t\t\t \n\t\t\tASSERT(list_empty(&ailp->ail_buf_list) ||\n\t\t\t       xlog_is_shutdown(ailp->ail_log));\n\t\t\txfs_buf_delwri_cancel(&ailp->ail_buf_list);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock(&ailp->ail_lock);\n\n\t\t \n\t\tsmp_rmb();\n\t\tif (!xfs_ail_min(ailp) &&\n\t\t    ailp->ail_target == ailp->ail_target_prev &&\n\t\t    list_empty(&ailp->ail_buf_list)) {\n\t\t\tspin_unlock(&ailp->ail_lock);\n\t\t\tschedule();\n\t\t\ttout = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&ailp->ail_lock);\n\n\t\tif (tout)\n\t\t\tschedule_timeout(msecs_to_jiffies(tout));\n\n\t\t__set_current_state(TASK_RUNNING);\n\n\t\ttry_to_freeze();\n\n\t\ttout = xfsaild_push(ailp);\n\t}\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\treturn 0;\n}\n\n \nvoid\nxfs_ail_push(\n\tstruct xfs_ail\t\t*ailp,\n\txfs_lsn_t\t\tthreshold_lsn)\n{\n\tstruct xfs_log_item\t*lip;\n\n\tlip = xfs_ail_min(ailp);\n\tif (!lip || xlog_is_shutdown(ailp->ail_log) ||\n\t    XFS_LSN_CMP(threshold_lsn, ailp->ail_target) <= 0)\n\t\treturn;\n\n\t \n\tsmp_wmb();\n\txfs_trans_ail_copy_lsn(ailp, &ailp->ail_target, &threshold_lsn);\n\tsmp_wmb();\n\n\twake_up_process(ailp->ail_task);\n}\n\n \nvoid\nxfs_ail_push_all(\n\tstruct xfs_ail  *ailp)\n{\n\txfs_lsn_t       threshold_lsn = xfs_ail_max_lsn(ailp);\n\n\tif (threshold_lsn)\n\t\txfs_ail_push(ailp, threshold_lsn);\n}\n\n \nvoid\nxfs_ail_push_all_sync(\n\tstruct xfs_ail  *ailp)\n{\n\tDEFINE_WAIT(wait);\n\n\tspin_lock(&ailp->ail_lock);\n\twhile (xfs_ail_max(ailp) != NULL) {\n\t\tprepare_to_wait(&ailp->ail_empty, &wait, TASK_UNINTERRUPTIBLE);\n\t\twake_up_process(ailp->ail_task);\n\t\tspin_unlock(&ailp->ail_lock);\n\t\tschedule();\n\t\tspin_lock(&ailp->ail_lock);\n\t}\n\tspin_unlock(&ailp->ail_lock);\n\n\tfinish_wait(&ailp->ail_empty, &wait);\n}\n\nvoid\nxfs_ail_update_finish(\n\tstruct xfs_ail\t\t*ailp,\n\txfs_lsn_t\t\told_lsn) __releases(ailp->ail_lock)\n{\n\tstruct xlog\t\t*log = ailp->ail_log;\n\n\t \n\tif (!old_lsn || old_lsn == __xfs_ail_min_lsn(ailp)) {\n\t\tspin_unlock(&ailp->ail_lock);\n\t\treturn;\n\t}\n\n\tif (!xlog_is_shutdown(log))\n\t\txlog_assign_tail_lsn_locked(log->l_mp);\n\n\tif (list_empty(&ailp->ail_head))\n\t\twake_up_all(&ailp->ail_empty);\n\tspin_unlock(&ailp->ail_lock);\n\txfs_log_space_wake(log->l_mp);\n}\n\n \nvoid\nxfs_trans_ail_update_bulk(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\tstruct xfs_log_item\t**log_items,\n\tint\t\t\tnr_items,\n\txfs_lsn_t\t\tlsn) __releases(ailp->ail_lock)\n{\n\tstruct xfs_log_item\t*mlip;\n\txfs_lsn_t\t\ttail_lsn = 0;\n\tint\t\t\ti;\n\tLIST_HEAD(tmp);\n\n\tASSERT(nr_items > 0);\t\t \n\tmlip = xfs_ail_min(ailp);\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tstruct xfs_log_item *lip = log_items[i];\n\t\tif (test_and_set_bit(XFS_LI_IN_AIL, &lip->li_flags)) {\n\t\t\t \n\t\t\tif (XFS_LSN_CMP(lsn, lip->li_lsn) <= 0)\n\t\t\t\tcontinue;\n\n\t\t\ttrace_xfs_ail_move(lip, lip->li_lsn, lsn);\n\t\t\tif (mlip == lip && !tail_lsn)\n\t\t\t\ttail_lsn = lip->li_lsn;\n\n\t\t\txfs_ail_delete(ailp, lip);\n\t\t} else {\n\t\t\ttrace_xfs_ail_insert(lip, 0, lsn);\n\t\t}\n\t\tlip->li_lsn = lsn;\n\t\tlist_add_tail(&lip->li_ail, &tmp);\n\t}\n\n\tif (!list_empty(&tmp))\n\t\txfs_ail_splice(ailp, cur, &tmp, lsn);\n\n\txfs_ail_update_finish(ailp, tail_lsn);\n}\n\n \nvoid\nxfs_trans_ail_insert(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n\tspin_lock(&ailp->ail_lock);\n\txfs_trans_ail_update_bulk(ailp, NULL, &lip, 1, lsn);\n}\n\n \nxfs_lsn_t\nxfs_ail_delete_one(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_log_item\t*mlip = xfs_ail_min(ailp);\n\txfs_lsn_t\t\tlsn = lip->li_lsn;\n\n\ttrace_xfs_ail_delete(lip, mlip->li_lsn, lip->li_lsn);\n\txfs_ail_delete(ailp, lip);\n\tclear_bit(XFS_LI_IN_AIL, &lip->li_flags);\n\tlip->li_lsn = 0;\n\n\tif (mlip == lip)\n\t\treturn lsn;\n\treturn 0;\n}\n\nvoid\nxfs_trans_ail_delete(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\tshutdown_type)\n{\n\tstruct xfs_ail\t\t*ailp = lip->li_ailp;\n\tstruct xlog\t\t*log = ailp->ail_log;\n\txfs_lsn_t\t\ttail_lsn;\n\n\tspin_lock(&ailp->ail_lock);\n\tif (!test_bit(XFS_LI_IN_AIL, &lip->li_flags)) {\n\t\tspin_unlock(&ailp->ail_lock);\n\t\tif (shutdown_type && !xlog_is_shutdown(log)) {\n\t\t\txfs_alert_tag(log->l_mp, XFS_PTAG_AILDELETE,\n\t\"%s: attempting to delete a log item that is not in the AIL\",\n\t\t\t\t\t__func__);\n\t\t\txlog_force_shutdown(log, shutdown_type);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\txfs_clear_li_failed(lip);\n\ttail_lsn = xfs_ail_delete_one(ailp, lip);\n\txfs_ail_update_finish(ailp, tail_lsn);\n}\n\nint\nxfs_trans_ail_init(\n\txfs_mount_t\t*mp)\n{\n\tstruct xfs_ail\t*ailp;\n\n\tailp = kmem_zalloc(sizeof(struct xfs_ail), KM_MAYFAIL);\n\tif (!ailp)\n\t\treturn -ENOMEM;\n\n\tailp->ail_log = mp->m_log;\n\tINIT_LIST_HEAD(&ailp->ail_head);\n\tINIT_LIST_HEAD(&ailp->ail_cursors);\n\tspin_lock_init(&ailp->ail_lock);\n\tINIT_LIST_HEAD(&ailp->ail_buf_list);\n\tinit_waitqueue_head(&ailp->ail_empty);\n\n\tailp->ail_task = kthread_run(xfsaild, ailp, \"xfsaild/%s\",\n\t\t\t\tmp->m_super->s_id);\n\tif (IS_ERR(ailp->ail_task))\n\t\tgoto out_free_ailp;\n\n\tmp->m_ail = ailp;\n\treturn 0;\n\nout_free_ailp:\n\tkmem_free(ailp);\n\treturn -ENOMEM;\n}\n\nvoid\nxfs_trans_ail_destroy(\n\txfs_mount_t\t*mp)\n{\n\tstruct xfs_ail\t*ailp = mp->m_ail;\n\n\tkthread_stop(ailp->ail_task);\n\tkmem_free(ailp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}