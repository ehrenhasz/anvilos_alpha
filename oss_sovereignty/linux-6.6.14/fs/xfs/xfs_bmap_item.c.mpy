{
  "module_name": "xfs_bmap_item.c",
  "hash_id": "75c7c9fd1890af9e838f0b59f394083e1df18c03796307ef93fb2201a81c1a7d",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_bmap_item.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_bmap_item.h\"\n#include \"xfs_log.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_ag.h\"\n\nstruct kmem_cache\t*xfs_bui_cache;\nstruct kmem_cache\t*xfs_bud_cache;\n\nstatic const struct xfs_item_ops xfs_bui_item_ops;\n\nstatic inline struct xfs_bui_log_item *BUI_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_bui_log_item, bui_item);\n}\n\nSTATIC void\nxfs_bui_item_free(\n\tstruct xfs_bui_log_item\t*buip)\n{\n\tkmem_free(buip->bui_item.li_lv_shadow);\n\tkmem_cache_free(xfs_bui_cache, buip);\n}\n\n \nSTATIC void\nxfs_bui_release(\n\tstruct xfs_bui_log_item\t*buip)\n{\n\tASSERT(atomic_read(&buip->bui_refcount) > 0);\n\tif (!atomic_dec_and_test(&buip->bui_refcount))\n\t\treturn;\n\n\txfs_trans_ail_delete(&buip->bui_item, 0);\n\txfs_bui_item_free(buip);\n}\n\n\nSTATIC void\nxfs_bui_item_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_bui_log_item\t*buip = BUI_ITEM(lip);\n\n\t*nvecs += 1;\n\t*nbytes += xfs_bui_log_format_sizeof(buip->bui_format.bui_nextents);\n}\n\n \nSTATIC void\nxfs_bui_item_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_bui_log_item\t*buip = BUI_ITEM(lip);\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\n\tASSERT(atomic_read(&buip->bui_next_extent) ==\n\t\t\tbuip->bui_format.bui_nextents);\n\n\tbuip->bui_format.bui_type = XFS_LI_BUI;\n\tbuip->bui_format.bui_size = 1;\n\n\txlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_BUI_FORMAT, &buip->bui_format,\n\t\t\txfs_bui_log_format_sizeof(buip->bui_format.bui_nextents));\n}\n\n \nSTATIC void\nxfs_bui_item_unpin(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\tremove)\n{\n\tstruct xfs_bui_log_item\t*buip = BUI_ITEM(lip);\n\n\txfs_bui_release(buip);\n}\n\n \nSTATIC void\nxfs_bui_item_release(\n\tstruct xfs_log_item\t*lip)\n{\n\txfs_bui_release(BUI_ITEM(lip));\n}\n\n \nSTATIC struct xfs_bui_log_item *\nxfs_bui_init(\n\tstruct xfs_mount\t\t*mp)\n\n{\n\tstruct xfs_bui_log_item\t\t*buip;\n\n\tbuip = kmem_cache_zalloc(xfs_bui_cache, GFP_KERNEL | __GFP_NOFAIL);\n\n\txfs_log_item_init(mp, &buip->bui_item, XFS_LI_BUI, &xfs_bui_item_ops);\n\tbuip->bui_format.bui_nextents = XFS_BUI_MAX_FAST_EXTENTS;\n\tbuip->bui_format.bui_id = (uintptr_t)(void *)buip;\n\tatomic_set(&buip->bui_next_extent, 0);\n\tatomic_set(&buip->bui_refcount, 2);\n\n\treturn buip;\n}\n\nstatic inline struct xfs_bud_log_item *BUD_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_bud_log_item, bud_item);\n}\n\nSTATIC void\nxfs_bud_item_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\t*nvecs += 1;\n\t*nbytes += sizeof(struct xfs_bud_log_format);\n}\n\n \nSTATIC void\nxfs_bud_item_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_bud_log_item\t*budp = BUD_ITEM(lip);\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\n\tbudp->bud_format.bud_type = XFS_LI_BUD;\n\tbudp->bud_format.bud_size = 1;\n\n\txlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_BUD_FORMAT, &budp->bud_format,\n\t\t\tsizeof(struct xfs_bud_log_format));\n}\n\n \nSTATIC void\nxfs_bud_item_release(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_bud_log_item\t*budp = BUD_ITEM(lip);\n\n\txfs_bui_release(budp->bud_buip);\n\tkmem_free(budp->bud_item.li_lv_shadow);\n\tkmem_cache_free(xfs_bud_cache, budp);\n}\n\nstatic struct xfs_log_item *\nxfs_bud_item_intent(\n\tstruct xfs_log_item\t*lip)\n{\n\treturn &BUD_ITEM(lip)->bud_buip->bui_item;\n}\n\nstatic const struct xfs_item_ops xfs_bud_item_ops = {\n\t.flags\t\t= XFS_ITEM_RELEASE_WHEN_COMMITTED |\n\t\t\t  XFS_ITEM_INTENT_DONE,\n\t.iop_size\t= xfs_bud_item_size,\n\t.iop_format\t= xfs_bud_item_format,\n\t.iop_release\t= xfs_bud_item_release,\n\t.iop_intent\t= xfs_bud_item_intent,\n};\n\nstatic struct xfs_bud_log_item *\nxfs_trans_get_bud(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_bui_log_item\t\t*buip)\n{\n\tstruct xfs_bud_log_item\t\t*budp;\n\n\tbudp = kmem_cache_zalloc(xfs_bud_cache, GFP_KERNEL | __GFP_NOFAIL);\n\txfs_log_item_init(tp->t_mountp, &budp->bud_item, XFS_LI_BUD,\n\t\t\t  &xfs_bud_item_ops);\n\tbudp->bud_buip = buip;\n\tbudp->bud_format.bud_bui_id = buip->bui_format.bui_id;\n\n\txfs_trans_add_item(tp, &budp->bud_item);\n\treturn budp;\n}\n\n \nstatic int\nxfs_trans_log_finish_bmap_update(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_bud_log_item\t\t*budp,\n\tstruct xfs_bmap_intent\t\t*bi)\n{\n\tint\t\t\t\terror;\n\n\terror = xfs_bmap_finish_one(tp, bi);\n\n\t \n\ttp->t_flags |= XFS_TRANS_DIRTY | XFS_TRANS_HAS_INTENT_DONE;\n\tset_bit(XFS_LI_DIRTY, &budp->bud_item.li_flags);\n\n\treturn error;\n}\n\n \nstatic int\nxfs_bmap_update_diff_items(\n\tvoid\t\t\t\t*priv,\n\tconst struct list_head\t\t*a,\n\tconst struct list_head\t\t*b)\n{\n\tstruct xfs_bmap_intent\t\t*ba;\n\tstruct xfs_bmap_intent\t\t*bb;\n\n\tba = container_of(a, struct xfs_bmap_intent, bi_list);\n\tbb = container_of(b, struct xfs_bmap_intent, bi_list);\n\treturn ba->bi_owner->i_ino - bb->bi_owner->i_ino;\n}\n\n \nstatic void\nxfs_trans_set_bmap_flags(\n\tstruct xfs_map_extent\t\t*map,\n\tenum xfs_bmap_intent_type\ttype,\n\tint\t\t\t\twhichfork,\n\txfs_exntst_t\t\t\tstate)\n{\n\tmap->me_flags = 0;\n\tswitch (type) {\n\tcase XFS_BMAP_MAP:\n\tcase XFS_BMAP_UNMAP:\n\t\tmap->me_flags = type;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\tif (state == XFS_EXT_UNWRITTEN)\n\t\tmap->me_flags |= XFS_BMAP_EXTENT_UNWRITTEN;\n\tif (whichfork == XFS_ATTR_FORK)\n\t\tmap->me_flags |= XFS_BMAP_EXTENT_ATTR_FORK;\n}\n\n \nSTATIC void\nxfs_bmap_update_log_item(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_bui_log_item\t\t*buip,\n\tstruct xfs_bmap_intent\t\t*bi)\n{\n\tuint\t\t\t\tnext_extent;\n\tstruct xfs_map_extent\t\t*map;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tset_bit(XFS_LI_DIRTY, &buip->bui_item.li_flags);\n\n\t \n\tnext_extent = atomic_inc_return(&buip->bui_next_extent) - 1;\n\tASSERT(next_extent < buip->bui_format.bui_nextents);\n\tmap = &buip->bui_format.bui_extents[next_extent];\n\tmap->me_owner = bi->bi_owner->i_ino;\n\tmap->me_startblock = bi->bi_bmap.br_startblock;\n\tmap->me_startoff = bi->bi_bmap.br_startoff;\n\tmap->me_len = bi->bi_bmap.br_blockcount;\n\txfs_trans_set_bmap_flags(map, bi->bi_type, bi->bi_whichfork,\n\t\t\tbi->bi_bmap.br_state);\n}\n\nstatic struct xfs_log_item *\nxfs_bmap_update_create_intent(\n\tstruct xfs_trans\t\t*tp,\n\tstruct list_head\t\t*items,\n\tunsigned int\t\t\tcount,\n\tbool\t\t\t\tsort)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_bui_log_item\t\t*buip = xfs_bui_init(mp);\n\tstruct xfs_bmap_intent\t\t*bi;\n\n\tASSERT(count == XFS_BUI_MAX_FAST_EXTENTS);\n\n\txfs_trans_add_item(tp, &buip->bui_item);\n\tif (sort)\n\t\tlist_sort(mp, items, xfs_bmap_update_diff_items);\n\tlist_for_each_entry(bi, items, bi_list)\n\t\txfs_bmap_update_log_item(tp, buip, bi);\n\treturn &buip->bui_item;\n}\n\n \nstatic struct xfs_log_item *\nxfs_bmap_update_create_done(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_log_item\t\t*intent,\n\tunsigned int\t\t\tcount)\n{\n\treturn &xfs_trans_get_bud(tp, BUI_ITEM(intent))->bud_item;\n}\n\n \nvoid\nxfs_bmap_update_get_group(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_bmap_intent\t*bi)\n{\n\txfs_agnumber_t\t\tagno;\n\n\tagno = XFS_FSB_TO_AGNO(mp, bi->bi_bmap.br_startblock);\n\n\t \n\tbi->bi_pag = xfs_perag_intent_get(mp, agno);\n}\n\n \nstatic inline void\nxfs_bmap_update_put_group(\n\tstruct xfs_bmap_intent\t*bi)\n{\n\txfs_perag_intent_put(bi->bi_pag);\n}\n\n \nSTATIC int\nxfs_bmap_update_finish_item(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_log_item\t\t*done,\n\tstruct list_head\t\t*item,\n\tstruct xfs_btree_cur\t\t**state)\n{\n\tstruct xfs_bmap_intent\t\t*bi;\n\tint\t\t\t\terror;\n\n\tbi = container_of(item, struct xfs_bmap_intent, bi_list);\n\n\terror = xfs_trans_log_finish_bmap_update(tp, BUD_ITEM(done), bi);\n\tif (!error && bi->bi_bmap.br_blockcount > 0) {\n\t\tASSERT(bi->bi_type == XFS_BMAP_UNMAP);\n\t\treturn -EAGAIN;\n\t}\n\n\txfs_bmap_update_put_group(bi);\n\tkmem_cache_free(xfs_bmap_intent_cache, bi);\n\treturn error;\n}\n\n \nSTATIC void\nxfs_bmap_update_abort_intent(\n\tstruct xfs_log_item\t\t*intent)\n{\n\txfs_bui_release(BUI_ITEM(intent));\n}\n\n \nSTATIC void\nxfs_bmap_update_cancel_item(\n\tstruct list_head\t\t*item)\n{\n\tstruct xfs_bmap_intent\t\t*bi;\n\n\tbi = container_of(item, struct xfs_bmap_intent, bi_list);\n\n\txfs_bmap_update_put_group(bi);\n\tkmem_cache_free(xfs_bmap_intent_cache, bi);\n}\n\nconst struct xfs_defer_op_type xfs_bmap_update_defer_type = {\n\t.max_items\t= XFS_BUI_MAX_FAST_EXTENTS,\n\t.create_intent\t= xfs_bmap_update_create_intent,\n\t.abort_intent\t= xfs_bmap_update_abort_intent,\n\t.create_done\t= xfs_bmap_update_create_done,\n\t.finish_item\t= xfs_bmap_update_finish_item,\n\t.cancel_item\t= xfs_bmap_update_cancel_item,\n};\n\n \nstatic inline bool\nxfs_bui_validate(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_bui_log_item\t\t*buip)\n{\n\tstruct xfs_map_extent\t\t*map;\n\n\t \n\tif (buip->bui_format.bui_nextents != XFS_BUI_MAX_FAST_EXTENTS)\n\t\treturn false;\n\n\tmap = &buip->bui_format.bui_extents[0];\n\n\tif (map->me_flags & ~XFS_BMAP_EXTENT_FLAGS)\n\t\treturn false;\n\n\tswitch (map->me_flags & XFS_BMAP_EXTENT_TYPE_MASK) {\n\tcase XFS_BMAP_MAP:\n\tcase XFS_BMAP_UNMAP:\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (!xfs_verify_ino(mp, map->me_owner))\n\t\treturn false;\n\n\tif (!xfs_verify_fileext(mp, map->me_startoff, map->me_len))\n\t\treturn false;\n\n\treturn xfs_verify_fsbext(mp, map->me_startblock, map->me_len);\n}\n\n \nSTATIC int\nxfs_bui_item_recover(\n\tstruct xfs_log_item\t\t*lip,\n\tstruct list_head\t\t*capture_list)\n{\n\tstruct xfs_bmap_intent\t\tfake = { };\n\tstruct xfs_trans_res\t\tresv;\n\tstruct xfs_bui_log_item\t\t*buip = BUI_ITEM(lip);\n\tstruct xfs_trans\t\t*tp;\n\tstruct xfs_inode\t\t*ip = NULL;\n\tstruct xfs_mount\t\t*mp = lip->li_log->l_mp;\n\tstruct xfs_map_extent\t\t*map;\n\tstruct xfs_bud_log_item\t\t*budp;\n\tint\t\t\t\tiext_delta;\n\tint\t\t\t\terror = 0;\n\n\tif (!xfs_bui_validate(mp, buip)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\t&buip->bui_format, sizeof(buip->bui_format));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tmap = &buip->bui_format.bui_extents[0];\n\tfake.bi_whichfork = (map->me_flags & XFS_BMAP_EXTENT_ATTR_FORK) ?\n\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tfake.bi_type = map->me_flags & XFS_BMAP_EXTENT_TYPE_MASK;\n\n\terror = xlog_recover_iget(mp, map->me_owner, &ip);\n\tif (error)\n\t\treturn error;\n\n\t \n\tresv = xlog_recover_resv(&M_RES(mp)->tr_itruncate);\n\terror = xfs_trans_alloc(mp, &resv,\n\t\t\tXFS_EXTENTADD_SPACE_RES(mp, XFS_DATA_FORK), 0, 0, &tp);\n\tif (error)\n\t\tgoto err_rele;\n\n\tbudp = xfs_trans_get_bud(tp, buip);\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\tif (fake.bi_type == XFS_BMAP_MAP)\n\t\tiext_delta = XFS_IEXT_ADD_NOSPLIT_CNT;\n\telse\n\t\tiext_delta = XFS_IEXT_PUNCH_HOLE_CNT;\n\n\terror = xfs_iext_count_may_overflow(ip, fake.bi_whichfork, iext_delta);\n\tif (error == -EFBIG)\n\t\terror = xfs_iext_count_upgrade(tp, ip, iext_delta);\n\tif (error)\n\t\tgoto err_cancel;\n\n\tfake.bi_owner = ip;\n\tfake.bi_bmap.br_startblock = map->me_startblock;\n\tfake.bi_bmap.br_startoff = map->me_startoff;\n\tfake.bi_bmap.br_blockcount = map->me_len;\n\tfake.bi_bmap.br_state = (map->me_flags & XFS_BMAP_EXTENT_UNWRITTEN) ?\n\t\t\tXFS_EXT_UNWRITTEN : XFS_EXT_NORM;\n\n\txfs_bmap_update_get_group(mp, &fake);\n\terror = xfs_trans_log_finish_bmap_update(tp, budp, &fake);\n\tif (error == -EFSCORRUPTED)\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, map,\n\t\t\t\tsizeof(*map));\n\txfs_bmap_update_put_group(&fake);\n\tif (error)\n\t\tgoto err_cancel;\n\n\tif (fake.bi_bmap.br_blockcount > 0) {\n\t\tASSERT(fake.bi_type == XFS_BMAP_UNMAP);\n\t\txfs_bmap_unmap_extent(tp, ip, &fake.bi_bmap);\n\t}\n\n\t \n\terror = xfs_defer_ops_capture_and_commit(tp, capture_list);\n\tif (error)\n\t\tgoto err_unlock;\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\txfs_irele(ip);\n\treturn 0;\n\nerr_cancel:\n\txfs_trans_cancel(tp);\nerr_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\nerr_rele:\n\txfs_irele(ip);\n\treturn error;\n}\n\nSTATIC bool\nxfs_bui_item_match(\n\tstruct xfs_log_item\t*lip,\n\tuint64_t\t\tintent_id)\n{\n\treturn BUI_ITEM(lip)->bui_format.bui_id == intent_id;\n}\n\n \nstatic struct xfs_log_item *\nxfs_bui_item_relog(\n\tstruct xfs_log_item\t\t*intent,\n\tstruct xfs_trans\t\t*tp)\n{\n\tstruct xfs_bud_log_item\t\t*budp;\n\tstruct xfs_bui_log_item\t\t*buip;\n\tstruct xfs_map_extent\t\t*map;\n\tunsigned int\t\t\tcount;\n\n\tcount = BUI_ITEM(intent)->bui_format.bui_nextents;\n\tmap = BUI_ITEM(intent)->bui_format.bui_extents;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbudp = xfs_trans_get_bud(tp, BUI_ITEM(intent));\n\tset_bit(XFS_LI_DIRTY, &budp->bud_item.li_flags);\n\n\tbuip = xfs_bui_init(tp->t_mountp);\n\tmemcpy(buip->bui_format.bui_extents, map, count * sizeof(*map));\n\tatomic_set(&buip->bui_next_extent, count);\n\txfs_trans_add_item(tp, &buip->bui_item);\n\tset_bit(XFS_LI_DIRTY, &buip->bui_item.li_flags);\n\treturn &buip->bui_item;\n}\n\nstatic const struct xfs_item_ops xfs_bui_item_ops = {\n\t.flags\t\t= XFS_ITEM_INTENT,\n\t.iop_size\t= xfs_bui_item_size,\n\t.iop_format\t= xfs_bui_item_format,\n\t.iop_unpin\t= xfs_bui_item_unpin,\n\t.iop_release\t= xfs_bui_item_release,\n\t.iop_recover\t= xfs_bui_item_recover,\n\t.iop_match\t= xfs_bui_item_match,\n\t.iop_relog\t= xfs_bui_item_relog,\n};\n\nstatic inline void\nxfs_bui_copy_format(\n\tstruct xfs_bui_log_format\t*dst,\n\tconst struct xfs_bui_log_format\t*src)\n{\n\tunsigned int\t\t\ti;\n\n\tmemcpy(dst, src, offsetof(struct xfs_bui_log_format, bui_extents));\n\n\tfor (i = 0; i < src->bui_nextents; i++)\n\t\tmemcpy(&dst->bui_extents[i], &src->bui_extents[i],\n\t\t\t\tsizeof(struct xfs_map_extent));\n}\n\n \nSTATIC int\nxlog_recover_bui_commit_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tlsn)\n{\n\tstruct xfs_mount\t\t*mp = log->l_mp;\n\tstruct xfs_bui_log_item\t\t*buip;\n\tstruct xfs_bui_log_format\t*bui_formatp;\n\tsize_t\t\t\t\tlen;\n\n\tbui_formatp = item->ri_buf[0].i_addr;\n\n\tif (item->ri_buf[0].i_len < xfs_bui_log_format_sizeof(0)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\titem->ri_buf[0].i_addr, item->ri_buf[0].i_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (bui_formatp->bui_nextents != XFS_BUI_MAX_FAST_EXTENTS) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\titem->ri_buf[0].i_addr, item->ri_buf[0].i_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tlen = xfs_bui_log_format_sizeof(bui_formatp->bui_nextents);\n\tif (item->ri_buf[0].i_len != len) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\titem->ri_buf[0].i_addr, item->ri_buf[0].i_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tbuip = xfs_bui_init(mp);\n\txfs_bui_copy_format(&buip->bui_format, bui_formatp);\n\tatomic_set(&buip->bui_next_extent, bui_formatp->bui_nextents);\n\t \n\txfs_trans_ail_insert(log->l_ailp, &buip->bui_item, lsn);\n\txfs_bui_release(buip);\n\treturn 0;\n}\n\nconst struct xlog_recover_item_ops xlog_bui_item_ops = {\n\t.item_type\t\t= XFS_LI_BUI,\n\t.commit_pass2\t\t= xlog_recover_bui_commit_pass2,\n};\n\n \nSTATIC int\nxlog_recover_bud_commit_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tlsn)\n{\n\tstruct xfs_bud_log_format\t*bud_formatp;\n\n\tbud_formatp = item->ri_buf[0].i_addr;\n\tif (item->ri_buf[0].i_len != sizeof(struct xfs_bud_log_format)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, log->l_mp,\n\t\t\t\titem->ri_buf[0].i_addr, item->ri_buf[0].i_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\txlog_recover_release_intent(log, XFS_LI_BUI, bud_formatp->bud_bui_id);\n\treturn 0;\n}\n\nconst struct xlog_recover_item_ops xlog_bud_item_ops = {\n\t.item_type\t\t= XFS_LI_BUD,\n\t.commit_pass2\t\t= xlog_recover_bud_commit_pass2,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}