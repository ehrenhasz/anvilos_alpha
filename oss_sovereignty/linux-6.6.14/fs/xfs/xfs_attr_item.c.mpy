{
  "module_name": "xfs_attr_item.c",
  "hash_id": "43221f09fd7a7a2982058eaf35d732e4e8cd4910cefa77267d6d167968189721",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_attr_item.c",
  "human_readable_source": "\n \n\n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_errortag.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log_recover.h\"\n\nstruct kmem_cache\t\t*xfs_attri_cache;\nstruct kmem_cache\t\t*xfs_attrd_cache;\n\nstatic const struct xfs_item_ops xfs_attri_item_ops;\nstatic const struct xfs_item_ops xfs_attrd_item_ops;\nstatic struct xfs_attrd_log_item *xfs_trans_get_attrd(struct xfs_trans *tp,\n\t\t\t\t\tstruct xfs_attri_log_item *attrip);\n\nstatic inline struct xfs_attri_log_item *ATTRI_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_attri_log_item, attri_item);\n}\n\n \n\nstatic inline struct xfs_attri_log_nameval *\nxfs_attri_log_nameval_get(\n\tstruct xfs_attri_log_nameval\t*nv)\n{\n\tif (!refcount_inc_not_zero(&nv->refcount))\n\t\treturn NULL;\n\treturn nv;\n}\n\nstatic inline void\nxfs_attri_log_nameval_put(\n\tstruct xfs_attri_log_nameval\t*nv)\n{\n\tif (!nv)\n\t\treturn;\n\tif (refcount_dec_and_test(&nv->refcount))\n\t\tkvfree(nv);\n}\n\nstatic inline struct xfs_attri_log_nameval *\nxfs_attri_log_nameval_alloc(\n\tconst void\t\t\t*name,\n\tunsigned int\t\t\tname_len,\n\tconst void\t\t\t*value,\n\tunsigned int\t\t\tvalue_len)\n{\n\tstruct xfs_attri_log_nameval\t*nv;\n\n\t \n\tnv = xlog_kvmalloc(sizeof(struct xfs_attri_log_nameval) +\n\t\t\t\t\tname_len + value_len);\n\n\tnv->name.i_addr = nv + 1;\n\tnv->name.i_len = name_len;\n\tnv->name.i_type = XLOG_REG_TYPE_ATTR_NAME;\n\tmemcpy(nv->name.i_addr, name, name_len);\n\n\tif (value_len) {\n\t\tnv->value.i_addr = nv->name.i_addr + name_len;\n\t\tnv->value.i_len = value_len;\n\t\tmemcpy(nv->value.i_addr, value, value_len);\n\t} else {\n\t\tnv->value.i_addr = NULL;\n\t\tnv->value.i_len = 0;\n\t}\n\tnv->value.i_type = XLOG_REG_TYPE_ATTR_VALUE;\n\n\trefcount_set(&nv->refcount, 1);\n\treturn nv;\n}\n\nSTATIC void\nxfs_attri_item_free(\n\tstruct xfs_attri_log_item\t*attrip)\n{\n\tkmem_free(attrip->attri_item.li_lv_shadow);\n\txfs_attri_log_nameval_put(attrip->attri_nameval);\n\tkmem_cache_free(xfs_attri_cache, attrip);\n}\n\n \nSTATIC void\nxfs_attri_release(\n\tstruct xfs_attri_log_item\t*attrip)\n{\n\tASSERT(atomic_read(&attrip->attri_refcount) > 0);\n\tif (!atomic_dec_and_test(&attrip->attri_refcount))\n\t\treturn;\n\n\txfs_trans_ail_delete(&attrip->attri_item, 0);\n\txfs_attri_item_free(attrip);\n}\n\nSTATIC void\nxfs_attri_item_size(\n\tstruct xfs_log_item\t\t*lip,\n\tint\t\t\t\t*nvecs,\n\tint\t\t\t\t*nbytes)\n{\n\tstruct xfs_attri_log_item       *attrip = ATTRI_ITEM(lip);\n\tstruct xfs_attri_log_nameval\t*nv = attrip->attri_nameval;\n\n\t*nvecs += 2;\n\t*nbytes += sizeof(struct xfs_attri_log_format) +\n\t\t\txlog_calc_iovec_len(nv->name.i_len);\n\n\tif (!nv->value.i_len)\n\t\treturn;\n\n\t*nvecs += 1;\n\t*nbytes += xlog_calc_iovec_len(nv->value.i_len);\n}\n\n \nSTATIC void\nxfs_attri_item_format(\n\tstruct xfs_log_item\t\t*lip,\n\tstruct xfs_log_vec\t\t*lv)\n{\n\tstruct xfs_attri_log_item\t*attrip = ATTRI_ITEM(lip);\n\tstruct xfs_log_iovec\t\t*vecp = NULL;\n\tstruct xfs_attri_log_nameval\t*nv = attrip->attri_nameval;\n\n\tattrip->attri_format.alfi_type = XFS_LI_ATTRI;\n\tattrip->attri_format.alfi_size = 1;\n\n\t \n\n\tASSERT(nv->name.i_len > 0);\n\tattrip->attri_format.alfi_size++;\n\n\tif (nv->value.i_len > 0)\n\t\tattrip->attri_format.alfi_size++;\n\n\txlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_ATTRI_FORMAT,\n\t\t\t&attrip->attri_format,\n\t\t\tsizeof(struct xfs_attri_log_format));\n\txlog_copy_from_iovec(lv, &vecp, &nv->name);\n\tif (nv->value.i_len > 0)\n\t\txlog_copy_from_iovec(lv, &vecp, &nv->value);\n}\n\n \nSTATIC void\nxfs_attri_item_unpin(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\tremove)\n{\n\txfs_attri_release(ATTRI_ITEM(lip));\n}\n\n\nSTATIC void\nxfs_attri_item_release(\n\tstruct xfs_log_item\t*lip)\n{\n\txfs_attri_release(ATTRI_ITEM(lip));\n}\n\n \nSTATIC struct xfs_attri_log_item *\nxfs_attri_init(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_attri_log_nameval\t*nv)\n{\n\tstruct xfs_attri_log_item\t*attrip;\n\n\tattrip = kmem_cache_zalloc(xfs_attri_cache, GFP_NOFS | __GFP_NOFAIL);\n\n\t \n\tattrip->attri_nameval = xfs_attri_log_nameval_get(nv);\n\tASSERT(attrip->attri_nameval);\n\n\txfs_log_item_init(mp, &attrip->attri_item, XFS_LI_ATTRI,\n\t\t\t  &xfs_attri_item_ops);\n\tattrip->attri_format.alfi_id = (uintptr_t)(void *)attrip;\n\tatomic_set(&attrip->attri_refcount, 2);\n\n\treturn attrip;\n}\n\nstatic inline struct xfs_attrd_log_item *ATTRD_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_attrd_log_item, attrd_item);\n}\n\nSTATIC void\nxfs_attrd_item_free(struct xfs_attrd_log_item *attrdp)\n{\n\tkmem_free(attrdp->attrd_item.li_lv_shadow);\n\tkmem_cache_free(xfs_attrd_cache, attrdp);\n}\n\nSTATIC void\nxfs_attrd_item_size(\n\tstruct xfs_log_item\t\t*lip,\n\tint\t\t\t\t*nvecs,\n\tint\t\t\t\t*nbytes)\n{\n\t*nvecs += 1;\n\t*nbytes += sizeof(struct xfs_attrd_log_format);\n}\n\n \nSTATIC void\nxfs_attrd_item_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_attrd_log_item\t*attrdp = ATTRD_ITEM(lip);\n\tstruct xfs_log_iovec\t\t*vecp = NULL;\n\n\tattrdp->attrd_format.alfd_type = XFS_LI_ATTRD;\n\tattrdp->attrd_format.alfd_size = 1;\n\n\txlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_ATTRD_FORMAT,\n\t\t\t&attrdp->attrd_format,\n\t\t\tsizeof(struct xfs_attrd_log_format));\n}\n\n \nSTATIC void\nxfs_attrd_item_release(\n\tstruct xfs_log_item\t\t*lip)\n{\n\tstruct xfs_attrd_log_item\t*attrdp = ATTRD_ITEM(lip);\n\n\txfs_attri_release(attrdp->attrd_attrip);\n\txfs_attrd_item_free(attrdp);\n}\n\nstatic struct xfs_log_item *\nxfs_attrd_item_intent(\n\tstruct xfs_log_item\t*lip)\n{\n\treturn &ATTRD_ITEM(lip)->attrd_attrip->attri_item;\n}\n\n \nSTATIC int\nxfs_xattri_finish_update(\n\tstruct xfs_attr_intent\t\t*attr,\n\tstruct xfs_attrd_log_item\t*attrdp)\n{\n\tstruct xfs_da_args\t\t*args = attr->xattri_da_args;\n\tint\t\t\t\terror;\n\n\tif (XFS_TEST_ERROR(false, args->dp->i_mount, XFS_ERRTAG_LARP)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\terror = xfs_attr_set_iter(attr);\n\tif (!error && attr->xattri_dela_state != XFS_DAS_DONE)\n\t\terror = -EAGAIN;\nout:\n\t \n\targs->trans->t_flags |= XFS_TRANS_DIRTY | XFS_TRANS_HAS_INTENT_DONE;\n\n\t \n\tif (attrdp)\n\t\tset_bit(XFS_LI_DIRTY, &attrdp->attrd_item.li_flags);\n\n\treturn error;\n}\n\n \nSTATIC void\nxfs_attr_log_item(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_attri_log_item\t*attrip,\n\tconst struct xfs_attr_intent\t*attr)\n{\n\tstruct xfs_attri_log_format\t*attrp;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tset_bit(XFS_LI_DIRTY, &attrip->attri_item.li_flags);\n\n\t \n\tattrp = &attrip->attri_format;\n\tattrp->alfi_ino = attr->xattri_da_args->dp->i_ino;\n\tASSERT(!(attr->xattri_op_flags & ~XFS_ATTRI_OP_FLAGS_TYPE_MASK));\n\tattrp->alfi_op_flags = attr->xattri_op_flags;\n\tattrp->alfi_value_len = attr->xattri_nameval->value.i_len;\n\tattrp->alfi_name_len = attr->xattri_nameval->name.i_len;\n\tASSERT(!(attr->xattri_da_args->attr_filter & ~XFS_ATTRI_FILTER_MASK));\n\tattrp->alfi_attr_filter = attr->xattri_da_args->attr_filter;\n}\n\n \nstatic struct xfs_log_item *\nxfs_attr_create_intent(\n\tstruct xfs_trans\t\t*tp,\n\tstruct list_head\t\t*items,\n\tunsigned int\t\t\tcount,\n\tbool\t\t\t\tsort)\n{\n\tstruct xfs_mount\t\t*mp = tp->t_mountp;\n\tstruct xfs_attri_log_item\t*attrip;\n\tstruct xfs_attr_intent\t\t*attr;\n\tstruct xfs_da_args\t\t*args;\n\n\tASSERT(count == 1);\n\n\t \n\tattr = list_first_entry_or_null(items, struct xfs_attr_intent,\n\t\t\txattri_list);\n\targs = attr->xattri_da_args;\n\n\tif (!(args->op_flags & XFS_DA_OP_LOGGED))\n\t\treturn NULL;\n\n\t \n\tif (!attr->xattri_nameval) {\n\t\t \n\t\tattr->xattri_nameval = xfs_attri_log_nameval_alloc(args->name,\n\t\t\t\targs->namelen, args->value, args->valuelen);\n\t}\n\n\tattrip = xfs_attri_init(mp, attr->xattri_nameval);\n\txfs_trans_add_item(tp, &attrip->attri_item);\n\txfs_attr_log_item(tp, attrip, attr);\n\n\treturn &attrip->attri_item;\n}\n\nstatic inline void\nxfs_attr_free_item(\n\tstruct xfs_attr_intent\t\t*attr)\n{\n\tif (attr->xattri_da_state)\n\t\txfs_da_state_free(attr->xattri_da_state);\n\txfs_attri_log_nameval_put(attr->xattri_nameval);\n\tif (attr->xattri_da_args->op_flags & XFS_DA_OP_RECOVERY)\n\t\tkmem_free(attr);\n\telse\n\t\tkmem_cache_free(xfs_attr_intent_cache, attr);\n}\n\n \nSTATIC int\nxfs_attr_finish_item(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_log_item\t\t*done,\n\tstruct list_head\t\t*item,\n\tstruct xfs_btree_cur\t\t**state)\n{\n\tstruct xfs_attr_intent\t\t*attr;\n\tstruct xfs_attrd_log_item\t*done_item = NULL;\n\tint\t\t\t\terror;\n\n\tattr = container_of(item, struct xfs_attr_intent, xattri_list);\n\tif (done)\n\t\tdone_item = ATTRD_ITEM(done);\n\n\t \n\tattr->xattri_da_args->trans = tp;\n\n\terror = xfs_xattri_finish_update(attr, done_item);\n\tif (error != -EAGAIN)\n\t\txfs_attr_free_item(attr);\n\n\treturn error;\n}\n\n \nSTATIC void\nxfs_attr_abort_intent(\n\tstruct xfs_log_item\t\t*intent)\n{\n\txfs_attri_release(ATTRI_ITEM(intent));\n}\n\n \nSTATIC void\nxfs_attr_cancel_item(\n\tstruct list_head\t\t*item)\n{\n\tstruct xfs_attr_intent\t\t*attr;\n\n\tattr = container_of(item, struct xfs_attr_intent, xattri_list);\n\txfs_attr_free_item(attr);\n}\n\nSTATIC bool\nxfs_attri_item_match(\n\tstruct xfs_log_item\t*lip,\n\tuint64_t\t\tintent_id)\n{\n\treturn ATTRI_ITEM(lip)->attri_format.alfi_id == intent_id;\n}\n\n \nstatic inline bool\nxfs_attri_validate(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_attri_log_format\t*attrp)\n{\n\tunsigned int\t\t\top = attrp->alfi_op_flags &\n\t\t\t\t\t     XFS_ATTRI_OP_FLAGS_TYPE_MASK;\n\n\tif (attrp->__pad != 0)\n\t\treturn false;\n\n\tif (attrp->alfi_op_flags & ~XFS_ATTRI_OP_FLAGS_TYPE_MASK)\n\t\treturn false;\n\n\tif (attrp->alfi_attr_filter & ~XFS_ATTRI_FILTER_MASK)\n\t\treturn false;\n\n\t \n\tswitch (op) {\n\tcase XFS_ATTRI_OP_FLAGS_SET:\n\tcase XFS_ATTRI_OP_FLAGS_REPLACE:\n\tcase XFS_ATTRI_OP_FLAGS_REMOVE:\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (attrp->alfi_value_len > XATTR_SIZE_MAX)\n\t\treturn false;\n\n\tif ((attrp->alfi_name_len > XATTR_NAME_MAX) ||\n\t    (attrp->alfi_name_len == 0))\n\t\treturn false;\n\n\treturn xfs_verify_ino(mp, attrp->alfi_ino);\n}\n\n \nSTATIC int\nxfs_attri_item_recover(\n\tstruct xfs_log_item\t\t*lip,\n\tstruct list_head\t\t*capture_list)\n{\n\tstruct xfs_attri_log_item\t*attrip = ATTRI_ITEM(lip);\n\tstruct xfs_attr_intent\t\t*attr;\n\tstruct xfs_mount\t\t*mp = lip->li_log->l_mp;\n\tstruct xfs_inode\t\t*ip;\n\tstruct xfs_da_args\t\t*args;\n\tstruct xfs_trans\t\t*tp;\n\tstruct xfs_trans_res\t\tresv;\n\tstruct xfs_attri_log_format\t*attrp;\n\tstruct xfs_attri_log_nameval\t*nv = attrip->attri_nameval;\n\tint\t\t\t\terror;\n\tint\t\t\t\ttotal;\n\tint\t\t\t\tlocal;\n\tstruct xfs_attrd_log_item\t*done_item = NULL;\n\n\t \n\tattrp = &attrip->attri_format;\n\tif (!xfs_attri_validate(mp, attrp) ||\n\t    !xfs_attr_namecheck(nv->name.i_addr, nv->name.i_len))\n\t\treturn -EFSCORRUPTED;\n\n\terror = xlog_recover_iget(mp,  attrp->alfi_ino, &ip);\n\tif (error)\n\t\treturn error;\n\n\tattr = kmem_zalloc(sizeof(struct xfs_attr_intent) +\n\t\t\t   sizeof(struct xfs_da_args), KM_NOFS);\n\targs = (struct xfs_da_args *)(attr + 1);\n\n\tattr->xattri_da_args = args;\n\tattr->xattri_op_flags = attrp->alfi_op_flags &\n\t\t\t\t\t\tXFS_ATTRI_OP_FLAGS_TYPE_MASK;\n\n\t \n\tattr->xattri_nameval = xfs_attri_log_nameval_get(nv);\n\tASSERT(attr->xattri_nameval);\n\n\targs->dp = ip;\n\targs->geo = mp->m_attr_geo;\n\targs->whichfork = XFS_ATTR_FORK;\n\targs->name = nv->name.i_addr;\n\targs->namelen = nv->name.i_len;\n\targs->hashval = xfs_da_hashname(args->name, args->namelen);\n\targs->attr_filter = attrp->alfi_attr_filter & XFS_ATTRI_FILTER_MASK;\n\targs->op_flags = XFS_DA_OP_RECOVERY | XFS_DA_OP_OKNOENT |\n\t\t\t XFS_DA_OP_LOGGED;\n\n\tASSERT(xfs_sb_version_haslogxattrs(&mp->m_sb));\n\n\tswitch (attr->xattri_op_flags) {\n\tcase XFS_ATTRI_OP_FLAGS_SET:\n\tcase XFS_ATTRI_OP_FLAGS_REPLACE:\n\t\targs->value = nv->value.i_addr;\n\t\targs->valuelen = nv->value.i_len;\n\t\targs->total = xfs_attr_calc_size(args, &local);\n\t\tif (xfs_inode_hasattr(args->dp))\n\t\t\tattr->xattri_dela_state = xfs_attr_init_replace_state(args);\n\t\telse\n\t\t\tattr->xattri_dela_state = xfs_attr_init_add_state(args);\n\t\tbreak;\n\tcase XFS_ATTRI_OP_FLAGS_REMOVE:\n\t\tif (!xfs_inode_hasattr(args->dp))\n\t\t\tgoto out;\n\t\tattr->xattri_dela_state = xfs_attr_init_remove_state(args);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\n\txfs_init_attr_trans(args, &resv, &total);\n\tresv = xlog_recover_resv(&resv);\n\terror = xfs_trans_alloc(mp, &resv, total, 0, XFS_TRANS_RESERVE, &tp);\n\tif (error)\n\t\tgoto out;\n\n\targs->trans = tp;\n\tdone_item = xfs_trans_get_attrd(tp, attrip);\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\terror = xfs_xattri_finish_update(attr, done_item);\n\tif (error == -EAGAIN) {\n\t\t \n\t\txfs_defer_add(tp, XFS_DEFER_OPS_TYPE_ATTR, &attr->xattri_list);\n\t\terror = xfs_defer_ops_capture_and_commit(tp, capture_list);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\txfs_irele(ip);\n\t\treturn 0;\n\t}\n\tif (error) {\n\t\txfs_trans_cancel(tp);\n\t\tgoto out_unlock;\n\t}\n\n\terror = xfs_defer_ops_capture_and_commit(tp, capture_list);\nout_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\txfs_irele(ip);\nout:\n\txfs_attr_free_item(attr);\n\treturn error;\n}\n\n \nstatic struct xfs_log_item *\nxfs_attri_item_relog(\n\tstruct xfs_log_item\t\t*intent,\n\tstruct xfs_trans\t\t*tp)\n{\n\tstruct xfs_attrd_log_item\t*attrdp;\n\tstruct xfs_attri_log_item\t*old_attrip;\n\tstruct xfs_attri_log_item\t*new_attrip;\n\tstruct xfs_attri_log_format\t*new_attrp;\n\tstruct xfs_attri_log_format\t*old_attrp;\n\n\told_attrip = ATTRI_ITEM(intent);\n\told_attrp = &old_attrip->attri_format;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tattrdp = xfs_trans_get_attrd(tp, old_attrip);\n\tset_bit(XFS_LI_DIRTY, &attrdp->attrd_item.li_flags);\n\n\t \n\tnew_attrip = xfs_attri_init(tp->t_mountp, old_attrip->attri_nameval);\n\tnew_attrp = &new_attrip->attri_format;\n\n\tnew_attrp->alfi_ino = old_attrp->alfi_ino;\n\tnew_attrp->alfi_op_flags = old_attrp->alfi_op_flags;\n\tnew_attrp->alfi_value_len = old_attrp->alfi_value_len;\n\tnew_attrp->alfi_name_len = old_attrp->alfi_name_len;\n\tnew_attrp->alfi_attr_filter = old_attrp->alfi_attr_filter;\n\n\txfs_trans_add_item(tp, &new_attrip->attri_item);\n\tset_bit(XFS_LI_DIRTY, &new_attrip->attri_item.li_flags);\n\n\treturn &new_attrip->attri_item;\n}\n\nSTATIC int\nxlog_recover_attri_commit_pass2(\n\tstruct xlog                     *log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item        *item,\n\txfs_lsn_t                       lsn)\n{\n\tstruct xfs_mount                *mp = log->l_mp;\n\tstruct xfs_attri_log_item       *attrip;\n\tstruct xfs_attri_log_format     *attri_formatp;\n\tstruct xfs_attri_log_nameval\t*nv;\n\tconst void\t\t\t*attr_value = NULL;\n\tconst void\t\t\t*attr_name;\n\tsize_t\t\t\t\tlen;\n\n\tattri_formatp = item->ri_buf[0].i_addr;\n\tattr_name = item->ri_buf[1].i_addr;\n\n\t \n\tlen = sizeof(struct xfs_attri_log_format);\n\tif (item->ri_buf[0].i_len != len) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\titem->ri_buf[0].i_addr, item->ri_buf[0].i_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (!xfs_attri_validate(mp, attri_formatp)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\titem->ri_buf[0].i_addr, item->ri_buf[0].i_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\tif (item->ri_buf[1].i_len !=\n\t\t\txlog_calc_iovec_len(attri_formatp->alfi_name_len)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\titem->ri_buf[0].i_addr, item->ri_buf[0].i_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (!xfs_attr_namecheck(attr_name, attri_formatp->alfi_name_len)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\titem->ri_buf[1].i_addr, item->ri_buf[1].i_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\tif (attri_formatp->alfi_value_len != 0) {\n\t\tif (item->ri_buf[2].i_len != xlog_calc_iovec_len(attri_formatp->alfi_value_len)) {\n\t\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\t\titem->ri_buf[0].i_addr,\n\t\t\t\t\titem->ri_buf[0].i_len);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tattr_value = item->ri_buf[2].i_addr;\n\t}\n\n\t \n\tnv = xfs_attri_log_nameval_alloc(attr_name,\n\t\t\tattri_formatp->alfi_name_len, attr_value,\n\t\t\tattri_formatp->alfi_value_len);\n\n\tattrip = xfs_attri_init(mp, nv);\n\tmemcpy(&attrip->attri_format, attri_formatp, len);\n\n\t \n\txfs_trans_ail_insert(log->l_ailp, &attrip->attri_item, lsn);\n\txfs_attri_release(attrip);\n\txfs_attri_log_nameval_put(nv);\n\treturn 0;\n}\n\n \nstatic struct xfs_attrd_log_item *\nxfs_trans_get_attrd(struct xfs_trans\t\t*tp,\n\t\t  struct xfs_attri_log_item\t*attrip)\n{\n\tstruct xfs_attrd_log_item\t\t*attrdp;\n\n\tASSERT(tp != NULL);\n\n\tattrdp = kmem_cache_zalloc(xfs_attrd_cache, GFP_NOFS | __GFP_NOFAIL);\n\n\txfs_log_item_init(tp->t_mountp, &attrdp->attrd_item, XFS_LI_ATTRD,\n\t\t\t  &xfs_attrd_item_ops);\n\tattrdp->attrd_attrip = attrip;\n\tattrdp->attrd_format.alfd_alf_id = attrip->attri_format.alfi_id;\n\n\txfs_trans_add_item(tp, &attrdp->attrd_item);\n\treturn attrdp;\n}\n\n \nstatic struct xfs_log_item *\nxfs_attr_create_done(\n\tstruct xfs_trans\t\t*tp,\n\tstruct xfs_log_item\t\t*intent,\n\tunsigned int\t\t\tcount)\n{\n\tif (!intent)\n\t\treturn NULL;\n\n\treturn &xfs_trans_get_attrd(tp, ATTRI_ITEM(intent))->attrd_item;\n}\n\nconst struct xfs_defer_op_type xfs_attr_defer_type = {\n\t.max_items\t= 1,\n\t.create_intent\t= xfs_attr_create_intent,\n\t.abort_intent\t= xfs_attr_abort_intent,\n\t.create_done\t= xfs_attr_create_done,\n\t.finish_item\t= xfs_attr_finish_item,\n\t.cancel_item\t= xfs_attr_cancel_item,\n};\n\n \nSTATIC int\nxlog_recover_attrd_commit_pass2(\n\tstruct xlog\t\t\t*log,\n\tstruct list_head\t\t*buffer_list,\n\tstruct xlog_recover_item\t*item,\n\txfs_lsn_t\t\t\tlsn)\n{\n\tstruct xfs_attrd_log_format\t*attrd_formatp;\n\n\tattrd_formatp = item->ri_buf[0].i_addr;\n\tif (item->ri_buf[0].i_len != sizeof(struct xfs_attrd_log_format)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, log->l_mp,\n\t\t\t\titem->ri_buf[0].i_addr, item->ri_buf[0].i_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\txlog_recover_release_intent(log, XFS_LI_ATTRI,\n\t\t\t\t    attrd_formatp->alfd_alf_id);\n\treturn 0;\n}\n\nstatic const struct xfs_item_ops xfs_attri_item_ops = {\n\t.flags\t\t= XFS_ITEM_INTENT,\n\t.iop_size\t= xfs_attri_item_size,\n\t.iop_format\t= xfs_attri_item_format,\n\t.iop_unpin\t= xfs_attri_item_unpin,\n\t.iop_release    = xfs_attri_item_release,\n\t.iop_recover\t= xfs_attri_item_recover,\n\t.iop_match\t= xfs_attri_item_match,\n\t.iop_relog\t= xfs_attri_item_relog,\n};\n\nconst struct xlog_recover_item_ops xlog_attri_item_ops = {\n\t.item_type\t= XFS_LI_ATTRI,\n\t.commit_pass2\t= xlog_recover_attri_commit_pass2,\n};\n\nstatic const struct xfs_item_ops xfs_attrd_item_ops = {\n\t.flags\t\t= XFS_ITEM_RELEASE_WHEN_COMMITTED |\n\t\t\t  XFS_ITEM_INTENT_DONE,\n\t.iop_size\t= xfs_attrd_item_size,\n\t.iop_format\t= xfs_attrd_item_format,\n\t.iop_release    = xfs_attrd_item_release,\n\t.iop_intent\t= xfs_attrd_item_intent,\n};\n\nconst struct xlog_recover_item_ops xlog_attrd_item_ops = {\n\t.item_type\t= XFS_LI_ATTRD,\n\t.commit_pass2\t= xlog_recover_attrd_commit_pass2,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}