{
  "module_name": "xfs_iops.c",
  "hash_id": "e847ac1c59e248fdbccdeee832c9580018bab657f0709c80ea31efdb415b962d",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_iops.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_xattr.h\"\n\n#include <linux/posix_acl.h>\n#include <linux/security.h>\n#include <linux/iversion.h>\n#include <linux/fiemap.h>\n\n \nstatic struct lock_class_key xfs_nondir_ilock_class;\nstatic struct lock_class_key xfs_dir_ilock_class;\n\nstatic int\nxfs_initxattrs(\n\tstruct inode\t\t*inode,\n\tconst struct xattr\t*xattr_array,\n\tvoid\t\t\t*fs_info)\n{\n\tconst struct xattr\t*xattr;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\terror = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\tstruct xfs_da_args\targs = {\n\t\t\t.dp\t\t= ip,\n\t\t\t.attr_filter\t= XFS_ATTR_SECURE,\n\t\t\t.name\t\t= xattr->name,\n\t\t\t.namelen\t= strlen(xattr->name),\n\t\t\t.value\t\t= xattr->value,\n\t\t\t.valuelen\t= xattr->value_len,\n\t\t};\n\t\terror = xfs_attr_change(&args);\n\t\tif (error < 0)\n\t\t\tbreak;\n\t}\n\treturn error;\n}\n\n \nint\nxfs_inode_init_security(\n\tstruct inode\t*inode,\n\tstruct inode\t*dir,\n\tconst struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t     &xfs_initxattrs, NULL);\n}\n\nstatic void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = XFS_DIR3_FT_UNKNOWN;\n}\n\nstatic int\nxfs_dentry_mode_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype(mode);\n\n\tif (unlikely(namep->type == XFS_DIR3_FT_UNKNOWN))\n\t\treturn -EFSCORRUPTED;\n\n\treturn 0;\n}\n\nSTATIC void\nxfs_cleanup_inode(\n\tstruct inode\t*dir,\n\tstruct inode\t*inode,\n\tstruct dentry\t*dentry)\n{\n\tstruct xfs_name\tteardown;\n\n\t \n\txfs_dentry_to_name(&teardown, dentry);\n\n\txfs_remove(XFS_I(dir), &teardown, XFS_I(inode));\n}\n\n \nstatic inline bool\nxfs_create_need_xattr(\n\tstruct inode\t*dir,\n\tstruct posix_acl *default_acl,\n\tstruct posix_acl *acl)\n{\n\tif (acl)\n\t\treturn true;\n\tif (default_acl)\n\t\treturn true;\n#if IS_ENABLED(CONFIG_SECURITY)\n\tif (dir->i_sb->s_security)\n\t\treturn true;\n#endif\n\treturn false;\n}\n\n\nSTATIC int\nxfs_generic_create(\n\tstruct mnt_idmap\t*idmap,\n\tstruct inode\t\t*dir,\n\tstruct dentry\t\t*dentry,\n\tumode_t\t\t\tmode,\n\tdev_t\t\t\trdev,\n\tstruct file\t\t*tmpfile)\t \n{\n\tstruct inode\t*inode;\n\tstruct xfs_inode *ip = NULL;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\t \n\tif (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\tif (unlikely(!sysv_valid_dev(rdev) || MAJOR(rdev) & ~0x1ff))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\trdev = 0;\n\t}\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = xfs_dentry_mode_to_name(&name, dentry, mode);\n\tif (unlikely(error))\n\t\tgoto out_free_acl;\n\n\tif (!tmpfile) {\n\t\terror = xfs_create(idmap, XFS_I(dir), &name, mode, rdev,\n\t\t\t\txfs_create_need_xattr(dir, default_acl, acl),\n\t\t\t\t&ip);\n\t} else {\n\t\terror = xfs_create_tmpfile(idmap, XFS_I(dir), mode, &ip);\n\t}\n\tif (unlikely(error))\n\t\tgoto out_free_acl;\n\n\tinode = VFS_I(ip);\n\n\terror = xfs_inode_init_security(inode, dir, &dentry->d_name);\n\tif (unlikely(error))\n\t\tgoto out_cleanup_inode;\n\n\tif (default_acl) {\n\t\terror = __xfs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tif (error)\n\t\t\tgoto out_cleanup_inode;\n\t}\n\tif (acl) {\n\t\terror = __xfs_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tif (error)\n\t\t\tgoto out_cleanup_inode;\n\t}\n\n\txfs_setup_iops(ip);\n\n\tif (tmpfile) {\n\t\t \n\t\tset_nlink(inode, 1);\n\t\td_tmpfile(tmpfile, inode);\n\t} else\n\t\td_instantiate(dentry, inode);\n\n\txfs_finish_inode_setup(ip);\n\n out_free_acl:\n\tposix_acl_release(default_acl);\n\tposix_acl_release(acl);\n\treturn error;\n\n out_cleanup_inode:\n\txfs_finish_inode_setup(ip);\n\tif (!tmpfile)\n\t\txfs_cleanup_inode(dir, inode, dentry);\n\txfs_irele(ip);\n\tgoto out_free_acl;\n}\n\nSTATIC int\nxfs_vn_mknod(\n\tstruct mnt_idmap\t*idmap,\n\tstruct inode\t\t*dir,\n\tstruct dentry\t\t*dentry,\n\tumode_t\t\t\tmode,\n\tdev_t\t\t\trdev)\n{\n\treturn xfs_generic_create(idmap, dir, dentry, mode, rdev, NULL);\n}\n\nSTATIC int\nxfs_vn_create(\n\tstruct mnt_idmap\t*idmap,\n\tstruct inode\t\t*dir,\n\tstruct dentry\t\t*dentry,\n\tumode_t\t\t\tmode,\n\tbool\t\t\tflags)\n{\n\treturn xfs_generic_create(idmap, dir, dentry, mode, 0, NULL);\n}\n\nSTATIC int\nxfs_vn_mkdir(\n\tstruct mnt_idmap\t*idmap,\n\tstruct inode\t\t*dir,\n\tstruct dentry\t\t*dentry,\n\tumode_t\t\t\tmode)\n{\n\treturn xfs_generic_create(idmap, dir, dentry, mode | S_IFDIR, 0, NULL);\n}\n\nSTATIC struct dentry *\nxfs_vn_lookup(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tunsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct xfs_inode *cip;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\tif (dentry->d_name.len >= MAXNAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\txfs_dentry_to_name(&name, dentry);\n\terror = xfs_lookup(XFS_I(dir), &name, &cip, NULL);\n\tif (likely(!error))\n\t\tinode = VFS_I(cip);\n\telse if (likely(error == -ENOENT))\n\t\tinode = NULL;\n\telse\n\t\tinode = ERR_PTR(error);\n\treturn d_splice_alias(inode, dentry);\n}\n\nSTATIC struct dentry *\nxfs_vn_ci_lookup(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tunsigned int flags)\n{\n\tstruct xfs_inode *ip;\n\tstruct xfs_name\txname;\n\tstruct xfs_name ci_name;\n\tstruct qstr\tdname;\n\tint\t\terror;\n\n\tif (dentry->d_name.len >= MAXNAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\txfs_dentry_to_name(&xname, dentry);\n\terror = xfs_lookup(XFS_I(dir), &xname, &ip, &ci_name);\n\tif (unlikely(error)) {\n\t\tif (unlikely(error != -ENOENT))\n\t\t\treturn ERR_PTR(error);\n\t\t \n\t\treturn NULL;\n\t}\n\n\t \n\tif (!ci_name.name)\n\t\treturn d_splice_alias(VFS_I(ip), dentry);\n\n\t \n\tdname.name = ci_name.name;\n\tdname.len = ci_name.len;\n\tdentry = d_add_ci(dentry, VFS_I(ip), &dname);\n\tkmem_free(ci_name.name);\n\treturn dentry;\n}\n\nSTATIC int\nxfs_vn_link(\n\tstruct dentry\t*old_dentry,\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry)\n{\n\tstruct inode\t*inode = d_inode(old_dentry);\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\terror = xfs_dentry_mode_to_name(&name, dentry, inode->i_mode);\n\tif (unlikely(error))\n\t\treturn error;\n\n\terror = xfs_link(XFS_I(dir), XFS_I(inode), &name);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tihold(inode);\n\td_instantiate(dentry, inode);\n\treturn 0;\n}\n\nSTATIC int\nxfs_vn_unlink(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry)\n{\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\txfs_dentry_to_name(&name, dentry);\n\n\terror = xfs_remove(XFS_I(dir), &name, XFS_I(d_inode(dentry)));\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (xfs_has_asciici(XFS_M(dir->i_sb)))\n\t\td_invalidate(dentry);\n\treturn 0;\n}\n\nSTATIC int\nxfs_vn_symlink(\n\tstruct mnt_idmap\t*idmap,\n\tstruct inode\t\t*dir,\n\tstruct dentry\t\t*dentry,\n\tconst char\t\t*symname)\n{\n\tstruct inode\t*inode;\n\tstruct xfs_inode *cip = NULL;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\tumode_t\t\tmode;\n\n\tmode = S_IFLNK |\n\t\t(irix_symlink_mode ? 0777 & ~current_umask() : S_IRWXUGO);\n\terror = xfs_dentry_mode_to_name(&name, dentry, mode);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\terror = xfs_symlink(idmap, XFS_I(dir), &name, symname, mode, &cip);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tinode = VFS_I(cip);\n\n\terror = xfs_inode_init_security(inode, dir, &dentry->d_name);\n\tif (unlikely(error))\n\t\tgoto out_cleanup_inode;\n\n\txfs_setup_iops(cip);\n\n\td_instantiate(dentry, inode);\n\txfs_finish_inode_setup(cip);\n\treturn 0;\n\n out_cleanup_inode:\n\txfs_finish_inode_setup(cip);\n\txfs_cleanup_inode(dir, inode, dentry);\n\txfs_irele(cip);\n out:\n\treturn error;\n}\n\nSTATIC int\nxfs_vn_rename(\n\tstruct mnt_idmap\t*idmap,\n\tstruct inode\t\t*odir,\n\tstruct dentry\t\t*odentry,\n\tstruct inode\t\t*ndir,\n\tstruct dentry\t\t*ndentry,\n\tunsigned int\t\tflags)\n{\n\tstruct inode\t*new_inode = d_inode(ndentry);\n\tint\t\tomode = 0;\n\tint\t\terror;\n\tstruct xfs_name\toname;\n\tstruct xfs_name\tnname;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\treturn -EINVAL;\n\n\t \n\tif (flags & RENAME_EXCHANGE)\n\t\tomode = d_inode(ndentry)->i_mode;\n\n\terror = xfs_dentry_mode_to_name(&oname, odentry, omode);\n\tif (omode && unlikely(error))\n\t\treturn error;\n\n\terror = xfs_dentry_mode_to_name(&nname, ndentry,\n\t\t\t\t\td_inode(odentry)->i_mode);\n\tif (unlikely(error))\n\t\treturn error;\n\n\treturn xfs_rename(idmap, XFS_I(odir), &oname,\n\t\t\t  XFS_I(d_inode(odentry)), XFS_I(ndir), &nname,\n\t\t\t  new_inode ? XFS_I(new_inode) : NULL, flags);\n}\n\n \nSTATIC const char *\nxfs_vn_get_link(\n\tstruct dentry\t\t*dentry,\n\tstruct inode\t\t*inode,\n\tstruct delayed_call\t*done)\n{\n\tchar\t\t\t*link;\n\tint\t\t\terror = -ENOMEM;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tlink = kmalloc(XFS_SYMLINK_MAXLEN+1, GFP_KERNEL);\n\tif (!link)\n\t\tgoto out_err;\n\n\terror = xfs_readlink(XFS_I(d_inode(dentry)), link);\n\tif (unlikely(error))\n\t\tgoto out_kfree;\n\n\tset_delayed_call(done, kfree_link, link);\n\treturn link;\n\n out_kfree:\n\tkfree(link);\n out_err:\n\treturn ERR_PTR(error);\n}\n\nstatic uint32_t\nxfs_stat_blksize(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\t \n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn XFS_FSB_TO_B(mp, xfs_get_extsz_hint(ip));\n\n\t \n\tif (xfs_has_large_iosize(mp)) {\n\t\tif (mp->m_swidth)\n\t\t\treturn XFS_FSB_TO_B(mp, mp->m_swidth);\n\t\tif (xfs_has_allocsize(mp))\n\t\t\treturn 1U << mp->m_allocsize_log;\n\t}\n\n\treturn PAGE_SIZE;\n}\n\nSTATIC int\nxfs_vn_getattr(\n\tstruct mnt_idmap\t*idmap,\n\tconst struct path\t*path,\n\tstruct kstat\t\t*stat,\n\tu32\t\t\trequest_mask,\n\tunsigned int\t\tquery_flags)\n{\n\tstruct inode\t\t*inode = d_inode(path->dentry);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tvfsuid_t\t\tvfsuid = i_uid_into_vfsuid(idmap, inode);\n\tvfsgid_t\t\tvfsgid = i_gid_into_vfsgid(idmap, inode);\n\n\ttrace_xfs_getattr(ip);\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\tstat->size = XFS_ISIZE(ip);\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = vfsuid_into_kuid(vfsuid);\n\tstat->gid = vfsgid_into_kgid(vfsgid);\n\tstat->ino = ip->i_ino;\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode_get_ctime(inode);\n\tstat->blocks = XFS_FSB_TO_BB(mp, ip->i_nblocks + ip->i_delayed_blks);\n\n\tif (xfs_has_v3inodes(mp)) {\n\t\tif (request_mask & STATX_BTIME) {\n\t\t\tstat->result_mask |= STATX_BTIME;\n\t\t\tstat->btime = ip->i_crtime;\n\t\t}\n\t}\n\n\tif ((request_mask & STATX_CHANGE_COOKIE) && IS_I_VERSION(inode)) {\n\t\tstat->change_cookie = inode_query_iversion(inode);\n\t\tstat->result_mask |= STATX_CHANGE_COOKIE;\n\t}\n\n\t \n\tif (ip->i_diflags & XFS_DIFLAG_IMMUTABLE)\n\t\tstat->attributes |= STATX_ATTR_IMMUTABLE;\n\tif (ip->i_diflags & XFS_DIFLAG_APPEND)\n\t\tstat->attributes |= STATX_ATTR_APPEND;\n\tif (ip->i_diflags & XFS_DIFLAG_NODUMP)\n\t\tstat->attributes |= STATX_ATTR_NODUMP;\n\n\tstat->attributes_mask |= (STATX_ATTR_IMMUTABLE |\n\t\t\t\t  STATX_ATTR_APPEND |\n\t\t\t\t  STATX_ATTR_NODUMP);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tstat->blksize = BLKDEV_IOSIZE;\n\t\tstat->rdev = inode->i_rdev;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tif (request_mask & STATX_DIOALIGN) {\n\t\t\tstruct xfs_buftarg\t*target = xfs_inode_buftarg(ip);\n\t\t\tstruct block_device\t*bdev = target->bt_bdev;\n\n\t\t\tstat->result_mask |= STATX_DIOALIGN;\n\t\t\tstat->dio_mem_align = bdev_dma_alignment(bdev) + 1;\n\t\t\tstat->dio_offset_align = bdev_logical_block_size(bdev);\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tstat->blksize = xfs_stat_blksize(ip);\n\t\tstat->rdev = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nxfs_vn_change_ok(\n\tstruct mnt_idmap\t*idmap,\n\tstruct dentry\t\t*dentry,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_mount\t*mp = XFS_I(d_inode(dentry))->i_mount;\n\n\tif (xfs_is_readonly(mp))\n\t\treturn -EROFS;\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\treturn setattr_prepare(idmap, dentry, iattr);\n}\n\n \nstatic int\nxfs_setattr_nonsize(\n\tstruct mnt_idmap\t*idmap,\n\tstruct dentry\t\t*dentry,\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tint\t\t\tmask = iattr->ia_valid;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\tkuid_t\t\t\tuid = GLOBAL_ROOT_UID;\n\tkgid_t\t\t\tgid = GLOBAL_ROOT_GID;\n\tstruct xfs_dquot\t*udqp = NULL, *gdqp = NULL;\n\tstruct xfs_dquot\t*old_udqp = NULL, *old_gdqp = NULL;\n\n\tASSERT((mask & ATTR_SIZE) == 0);\n\n\t \n\tif (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {\n\t\tuint\tqflags = 0;\n\n\t\tif ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\tuid = from_vfsuid(idmap, i_user_ns(inode),\n\t\t\t\t\t  iattr->ia_vfsuid);\n\t\t\tqflags |= XFS_QMOPT_UQUOTA;\n\t\t} else {\n\t\t\tuid = inode->i_uid;\n\t\t}\n\t\tif ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\tgid = from_vfsgid(idmap, i_user_ns(inode),\n\t\t\t\t\t  iattr->ia_vfsgid);\n\t\t\tqflags |= XFS_QMOPT_GQUOTA;\n\t\t}  else {\n\t\t\tgid = inode->i_gid;\n\t\t}\n\n\t\t \n\t\tASSERT(udqp == NULL);\n\t\tASSERT(gdqp == NULL);\n\t\terror = xfs_qm_vop_dqalloc(ip, uid, gid, ip->i_projid,\n\t\t\t\t\t   qflags, &udqp, &gdqp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = xfs_trans_alloc_ichange(ip, udqp, gdqp, NULL,\n\t\t\thas_capability_noaudit(current, CAP_FOWNER), &tp);\n\tif (error)\n\t\tgoto out_dqrele;\n\n\t \n\tif (XFS_IS_UQUOTA_ON(mp) &&\n\t    i_uid_needs_update(idmap, iattr, inode)) {\n\t\tASSERT(udqp);\n\t\told_udqp = xfs_qm_vop_chown(tp, ip, &ip->i_udquot, udqp);\n\t}\n\tif (XFS_IS_GQUOTA_ON(mp) &&\n\t    i_gid_needs_update(idmap, iattr, inode)) {\n\t\tASSERT(xfs_has_pquotino(mp) || !XFS_IS_PQUOTA_ON(mp));\n\t\tASSERT(gdqp);\n\t\told_gdqp = xfs_qm_vop_chown(tp, ip, &ip->i_gdquot, gdqp);\n\t}\n\n\tsetattr_copy(idmap, inode, iattr);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(mp, xs_ig_attrchg);\n\n\tif (xfs_has_wsync(mp))\n\t\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp);\n\n\t \n\txfs_qm_dqrele(old_udqp);\n\txfs_qm_dqrele(old_gdqp);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (mask & ATTR_MODE) {\n\t\terror = posix_acl_chmod(idmap, dentry, inode->i_mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n\nout_dqrele:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_setattr_size(\n\tstruct mnt_idmap\t*idmap,\n\tstruct dentry\t\t*dentry,\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\txfs_off_t\t\toldsize, newsize;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tuint\t\t\tlock_flags = 0;\n\tbool\t\t\tdid_zeroing = false;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(xfs_isilocked(ip, XFS_MMAPLOCK_EXCL));\n\tASSERT(S_ISREG(inode->i_mode));\n\tASSERT((iattr->ia_valid & (ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_ATIME_SET|\n\t\tATTR_MTIME_SET|ATTR_TIMES_SET)) == 0);\n\n\toldsize = inode->i_size;\n\tnewsize = iattr->ia_size;\n\n\t \n\tif (newsize == 0 && oldsize == 0 && ip->i_df.if_nextents == 0) {\n\t\tif (!(iattr->ia_valid & (ATTR_CTIME|ATTR_MTIME)))\n\t\t\treturn 0;\n\n\t\t \n\t\tiattr->ia_valid &= ~ATTR_SIZE;\n\t\treturn xfs_setattr_nonsize(idmap, dentry, ip, iattr);\n\t}\n\n\t \n\terror = xfs_qm_dqattach(ip);\n\tif (error)\n\t\treturn error;\n\n\t \n\tinode_dio_wait(inode);\n\n\t \n\tif (newsize > oldsize) {\n\t\ttrace_xfs_zero_eof(ip, oldsize, newsize - oldsize);\n\t\terror = xfs_zero_range(ip, oldsize, newsize - oldsize,\n\t\t\t\t&did_zeroing);\n\t} else {\n\t\t \n\t\terror = filemap_write_and_wait_range(inode->i_mapping, newsize,\n\t\t\t\t\t\t     newsize);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_truncate_page(ip, newsize, &did_zeroing);\n\t}\n\n\tif (error)\n\t\treturn error;\n\n\t \n\ttruncate_setsize(inode, newsize);\n\n\t \n\tif (did_zeroing ||\n\t    (newsize > ip->i_disk_size && oldsize != ip->i_disk_size)) {\n\t\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\tip->i_disk_size, newsize - 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_itruncate, 0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\tlock_flags |= XFS_ILOCK_EXCL;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t \n\tif (newsize != oldsize &&\n\t    !(iattr->ia_valid & (ATTR_CTIME | ATTR_MTIME))) {\n\t\tiattr->ia_ctime = iattr->ia_mtime =\n\t\t\tcurrent_time(inode);\n\t\tiattr->ia_valid |= ATTR_CTIME | ATTR_MTIME;\n\t}\n\n\t \n\tip->i_disk_size = newsize;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (newsize <= oldsize) {\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, newsize);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\t \n\t\txfs_iflags_set(ip, XFS_ITRUNCATED);\n\n\t\t \n\t\txfs_inode_clear_eofblocks_tag(ip);\n\t}\n\n\tASSERT(!(iattr->ia_valid & (ATTR_UID | ATTR_GID)));\n\tsetattr_copy(idmap, inode, iattr);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(mp, xs_ig_attrchg);\n\n\tif (xfs_has_wsync(mp))\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp);\nout_unlock:\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n\treturn error;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp);\n\tgoto out_unlock;\n}\n\nint\nxfs_vn_setattr_size(\n\tstruct mnt_idmap\t*idmap,\n\tstruct dentry\t\t*dentry,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_inode\t*ip = XFS_I(d_inode(dentry));\n\tint error;\n\n\ttrace_xfs_setattr(ip);\n\n\terror = xfs_vn_change_ok(idmap, dentry, iattr);\n\tif (error)\n\t\treturn error;\n\treturn xfs_setattr_size(idmap, dentry, ip, iattr);\n}\n\nSTATIC int\nxfs_vn_setattr(\n\tstruct mnt_idmap\t*idmap,\n\tstruct dentry\t\t*dentry,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct inode\t\t*inode = d_inode(dentry);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\terror;\n\n\tif (iattr->ia_valid & ATTR_SIZE) {\n\t\tuint\t\t\tiolock;\n\n\t\txfs_ilock(ip, XFS_MMAPLOCK_EXCL);\n\t\tiolock = XFS_IOLOCK_EXCL | XFS_MMAPLOCK_EXCL;\n\n\t\terror = xfs_break_layouts(inode, &iolock, BREAK_UNMAP);\n\t\tif (error) {\n\t\t\txfs_iunlock(ip, XFS_MMAPLOCK_EXCL);\n\t\t\treturn error;\n\t\t}\n\n\t\terror = xfs_vn_setattr_size(idmap, dentry, iattr);\n\t\txfs_iunlock(ip, XFS_MMAPLOCK_EXCL);\n\t} else {\n\t\ttrace_xfs_setattr(ip);\n\n\t\terror = xfs_vn_change_ok(idmap, dentry, iattr);\n\t\tif (!error)\n\t\t\terror = xfs_setattr_nonsize(idmap, dentry, ip, iattr);\n\t}\n\n\treturn error;\n}\n\nSTATIC int\nxfs_vn_update_time(\n\tstruct inode\t\t*inode,\n\tint\t\t\tflags)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tlog_flags = XFS_ILOG_TIMESTAMP;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tstruct timespec64\tnow;\n\n\ttrace_xfs_update_time(ip);\n\n\tif (inode->i_sb->s_flags & SB_LAZYTIME) {\n\t\tif (!((flags & S_VERSION) &&\n\t\t      inode_maybe_inc_iversion(inode, false))) {\n\t\t\tgeneric_update_time(inode, flags);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tlog_flags |= XFS_ILOG_CORE;\n\t}\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_fsyncts, 0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tif (flags & (S_CTIME|S_MTIME))\n\t\tnow = inode_set_ctime_current(inode);\n\telse\n\t\tnow = current_time(inode);\n\n\tif (flags & S_MTIME)\n\t\tinode->i_mtime = now;\n\tif (flags & S_ATIME)\n\t\tinode->i_atime = now;\n\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, log_flags);\n\treturn xfs_trans_commit(tp);\n}\n\nSTATIC int\nxfs_vn_fiemap(\n\tstruct inode\t\t*inode,\n\tstruct fiemap_extent_info *fieinfo,\n\tu64\t\t\tstart,\n\tu64\t\t\tlength)\n{\n\tint\t\t\terror;\n\n\txfs_ilock(XFS_I(inode), XFS_IOLOCK_SHARED);\n\tif (fieinfo->fi_flags & FIEMAP_FLAG_XATTR) {\n\t\tfieinfo->fi_flags &= ~FIEMAP_FLAG_XATTR;\n\t\terror = iomap_fiemap(inode, fieinfo, start, length,\n\t\t\t\t&xfs_xattr_iomap_ops);\n\t} else {\n\t\terror = iomap_fiemap(inode, fieinfo, start, length,\n\t\t\t\t&xfs_read_iomap_ops);\n\t}\n\txfs_iunlock(XFS_I(inode), XFS_IOLOCK_SHARED);\n\n\treturn error;\n}\n\nSTATIC int\nxfs_vn_tmpfile(\n\tstruct mnt_idmap\t*idmap,\n\tstruct inode\t\t*dir,\n\tstruct file\t\t*file,\n\tumode_t\t\t\tmode)\n{\n\tint err = xfs_generic_create(idmap, dir, file->f_path.dentry, mode, 0, file);\n\n\treturn finish_open_simple(file, err);\n}\n\nstatic const struct inode_operations xfs_inode_operations = {\n\t.get_inode_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.fiemap\t\t\t= xfs_vn_fiemap,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.fileattr_get\t\t= xfs_fileattr_get,\n\t.fileattr_set\t\t= xfs_fileattr_set,\n};\n\nstatic const struct inode_operations xfs_dir_inode_operations = {\n\t.create\t\t\t= xfs_vn_create,\n\t.lookup\t\t\t= xfs_vn_lookup,\n\t.link\t\t\t= xfs_vn_link,\n\t.unlink\t\t\t= xfs_vn_unlink,\n\t.symlink\t\t= xfs_vn_symlink,\n\t.mkdir\t\t\t= xfs_vn_mkdir,\n\t \n\t.rmdir\t\t\t= xfs_vn_unlink,\n\t.mknod\t\t\t= xfs_vn_mknod,\n\t.rename\t\t\t= xfs_vn_rename,\n\t.get_inode_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.tmpfile\t\t= xfs_vn_tmpfile,\n\t.fileattr_get\t\t= xfs_fileattr_get,\n\t.fileattr_set\t\t= xfs_fileattr_set,\n};\n\nstatic const struct inode_operations xfs_dir_ci_inode_operations = {\n\t.create\t\t\t= xfs_vn_create,\n\t.lookup\t\t\t= xfs_vn_ci_lookup,\n\t.link\t\t\t= xfs_vn_link,\n\t.unlink\t\t\t= xfs_vn_unlink,\n\t.symlink\t\t= xfs_vn_symlink,\n\t.mkdir\t\t\t= xfs_vn_mkdir,\n\t \n\t.rmdir\t\t\t= xfs_vn_unlink,\n\t.mknod\t\t\t= xfs_vn_mknod,\n\t.rename\t\t\t= xfs_vn_rename,\n\t.get_inode_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.tmpfile\t\t= xfs_vn_tmpfile,\n\t.fileattr_get\t\t= xfs_fileattr_get,\n\t.fileattr_set\t\t= xfs_fileattr_set,\n};\n\nstatic const struct inode_operations xfs_symlink_inode_operations = {\n\t.get_link\t\t= xfs_vn_get_link,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n};\n\n \nstatic bool\nxfs_inode_supports_dax(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\t \n\tif (!S_ISREG(VFS_I(ip)->i_mode))\n\t\treturn false;\n\n\t \n\tif (mp->m_sb.sb_blocksize != PAGE_SIZE)\n\t\treturn false;\n\n\t \n\treturn xfs_inode_buftarg(ip)->bt_daxdev != NULL;\n}\n\nstatic bool\nxfs_inode_should_enable_dax(\n\tstruct xfs_inode *ip)\n{\n\tif (!IS_ENABLED(CONFIG_FS_DAX))\n\t\treturn false;\n\tif (xfs_has_dax_never(ip->i_mount))\n\t\treturn false;\n\tif (!xfs_inode_supports_dax(ip))\n\t\treturn false;\n\tif (xfs_has_dax_always(ip->i_mount))\n\t\treturn true;\n\tif (ip->i_diflags2 & XFS_DIFLAG2_DAX)\n\t\treturn true;\n\treturn false;\n}\n\nvoid\nxfs_diflags_to_iflags(\n\tstruct xfs_inode\t*ip,\n\tbool init)\n{\n\tstruct inode            *inode = VFS_I(ip);\n\tunsigned int            xflags = xfs_ip2xflags(ip);\n\tunsigned int            flags = 0;\n\n\tASSERT(!(IS_DAX(inode) && init));\n\n\tif (xflags & FS_XFLAG_IMMUTABLE)\n\t\tflags |= S_IMMUTABLE;\n\tif (xflags & FS_XFLAG_APPEND)\n\t\tflags |= S_APPEND;\n\tif (xflags & FS_XFLAG_SYNC)\n\t\tflags |= S_SYNC;\n\tif (xflags & FS_XFLAG_NOATIME)\n\t\tflags |= S_NOATIME;\n\tif (init && xfs_inode_should_enable_dax(ip))\n\t\tflags |= S_DAX;\n\n\t \n\tinode->i_flags &= ~(S_IMMUTABLE | S_APPEND | S_SYNC | S_NOATIME);\n\tinode->i_flags |= flags;\n}\n\n \nvoid\nxfs_setup_inode(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = &ip->i_vnode;\n\tgfp_t\t\t\tgfp_mask;\n\n\tinode->i_ino = ip->i_ino;\n\tinode->i_state |= I_NEW;\n\n\tinode_sb_list_add(inode);\n\t \n\tinode_fake_hash(inode);\n\n\ti_size_write(inode, ip->i_disk_size);\n\txfs_diflags_to_iflags(ip, true);\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t \n\t\tlockdep_set_class(&inode->i_rwsem,\n\t\t\t\t  &inode->i_sb->s_type->i_mutex_dir_key);\n\t\tlockdep_set_class(&ip->i_lock.mr_lock, &xfs_dir_ilock_class);\n\t} else {\n\t\tlockdep_set_class(&ip->i_lock.mr_lock, &xfs_nondir_ilock_class);\n\t}\n\n\t \n\tgfp_mask = mapping_gfp_mask(inode->i_mapping);\n\tmapping_set_gfp_mask(inode->i_mapping, (gfp_mask & ~(__GFP_FS)));\n\n\t \n\tif (!xfs_inode_has_attr_fork(ip)) {\n\t\tinode_has_no_xattr(inode);\n\t\tcache_no_acl(inode);\n\t}\n}\n\nvoid\nxfs_setup_iops(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = &ip->i_vnode;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_op = &xfs_inode_operations;\n\t\tinode->i_fop = &xfs_file_operations;\n\t\tif (IS_DAX(inode))\n\t\t\tinode->i_mapping->a_ops = &xfs_dax_aops;\n\t\telse\n\t\t\tinode->i_mapping->a_ops = &xfs_address_space_operations;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tif (xfs_has_asciici(XFS_M(inode->i_sb)))\n\t\t\tinode->i_op = &xfs_dir_ci_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &xfs_dir_inode_operations;\n\t\tinode->i_fop = &xfs_dir_file_operations;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &xfs_symlink_inode_operations;\n\t\tbreak;\n\tdefault:\n\t\tinode->i_op = &xfs_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}