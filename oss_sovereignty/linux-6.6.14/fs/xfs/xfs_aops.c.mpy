{
  "module_name": "xfs_aops.c",
  "hash_id": "6733036b9f1041199020619713b1b03fa2e2dc831ee655bda2e36611cd678866",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_aops.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_reflink.h\"\n#include \"xfs_errortag.h\"\n#include \"xfs_error.h\"\n\nstruct xfs_writepage_ctx {\n\tstruct iomap_writepage_ctx ctx;\n\tunsigned int\t\tdata_seq;\n\tunsigned int\t\tcow_seq;\n};\n\nstatic inline struct xfs_writepage_ctx *\nXFS_WPC(struct iomap_writepage_ctx *ctx)\n{\n\treturn container_of(ctx, struct xfs_writepage_ctx, ctx);\n}\n\n \nstatic inline bool xfs_ioend_is_append(struct iomap_ioend *ioend)\n{\n\treturn ioend->io_offset + ioend->io_size >\n\t\tXFS_I(ioend->io_inode)->i_disk_size;\n}\n\n \nint\nxfs_setfilesize(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\tsize_t\t\t\tsize)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\txfs_fsize_t\t\tisize;\n\tint\t\t\terror;\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_fsyncts, 0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tisize = xfs_new_eof(ip, offset + size);\n\tif (!isize) {\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(tp);\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_setfilesize(ip, offset, size);\n\n\tip->i_disk_size = isize;\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\treturn xfs_trans_commit(tp);\n}\n\n \nSTATIC void\nxfs_end_ioend(\n\tstruct iomap_ioend\t*ioend)\n{\n\tstruct xfs_inode\t*ip = XFS_I(ioend->io_inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_off_t\t\toffset = ioend->io_offset;\n\tsize_t\t\t\tsize = ioend->io_size;\n\tunsigned int\t\tnofs_flag;\n\tint\t\t\terror;\n\n\t \n\tnofs_flag = memalloc_nofs_save();\n\n\t \n\tif (xfs_is_shutdown(mp)) {\n\t\terror = -EIO;\n\t\tgoto done;\n\t}\n\n\t \n\terror = blk_status_to_errno(ioend->io_bio->bi_status);\n\tif (unlikely(error)) {\n\t\tif (ioend->io_flags & IOMAP_F_SHARED) {\n\t\t\txfs_reflink_cancel_cow_range(ip, offset, size, true);\n\t\t\txfs_bmap_punch_delalloc_range(ip, offset,\n\t\t\t\t\toffset + size);\n\t\t}\n\t\tgoto done;\n\t}\n\n\t \n\tif (ioend->io_flags & IOMAP_F_SHARED)\n\t\terror = xfs_reflink_end_cow(ip, offset, size);\n\telse if (ioend->io_type == IOMAP_UNWRITTEN)\n\t\terror = xfs_iomap_write_unwritten(ip, offset, size, false);\n\n\tif (!error && xfs_ioend_is_append(ioend))\n\t\terror = xfs_setfilesize(ip, ioend->io_offset, ioend->io_size);\ndone:\n\tiomap_finish_ioends(ioend, error);\n\tmemalloc_nofs_restore(nofs_flag);\n}\n\n \nvoid\nxfs_end_io(\n\tstruct work_struct\t*work)\n{\n\tstruct xfs_inode\t*ip =\n\t\tcontainer_of(work, struct xfs_inode, i_ioend_work);\n\tstruct iomap_ioend\t*ioend;\n\tstruct list_head\ttmp;\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&ip->i_ioend_lock, flags);\n\tlist_replace_init(&ip->i_ioend_list, &tmp);\n\tspin_unlock_irqrestore(&ip->i_ioend_lock, flags);\n\n\tiomap_sort_ioends(&tmp);\n\twhile ((ioend = list_first_entry_or_null(&tmp, struct iomap_ioend,\n\t\t\tio_list))) {\n\t\tlist_del_init(&ioend->io_list);\n\t\tiomap_ioend_try_merge(ioend, &tmp);\n\t\txfs_end_ioend(ioend);\n\t\tcond_resched();\n\t}\n}\n\nSTATIC void\nxfs_end_bio(\n\tstruct bio\t\t*bio)\n{\n\tstruct iomap_ioend\t*ioend = bio->bi_private;\n\tstruct xfs_inode\t*ip = XFS_I(ioend->io_inode);\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&ip->i_ioend_lock, flags);\n\tif (list_empty(&ip->i_ioend_list))\n\t\tWARN_ON_ONCE(!queue_work(ip->i_mount->m_unwritten_workqueue,\n\t\t\t\t\t &ip->i_ioend_work));\n\tlist_add_tail(&ioend->io_list, &ip->i_ioend_list);\n\tspin_unlock_irqrestore(&ip->i_ioend_lock, flags);\n}\n\n \nstatic bool\nxfs_imap_valid(\n\tstruct iomap_writepage_ctx\t*wpc,\n\tstruct xfs_inode\t\t*ip,\n\tloff_t\t\t\t\toffset)\n{\n\tif (offset < wpc->iomap.offset ||\n\t    offset >= wpc->iomap.offset + wpc->iomap.length)\n\t\treturn false;\n\t \n\tif (wpc->iomap.flags & IOMAP_F_SHARED)\n\t\treturn true;\n\n\t \n\tif (XFS_WPC(wpc)->data_seq != READ_ONCE(ip->i_df.if_seq)) {\n\t\ttrace_xfs_wb_data_iomap_invalid(ip, &wpc->iomap,\n\t\t\t\tXFS_WPC(wpc)->data_seq, XFS_DATA_FORK);\n\t\treturn false;\n\t}\n\tif (xfs_inode_has_cow_data(ip) &&\n\t    XFS_WPC(wpc)->cow_seq != READ_ONCE(ip->i_cowfp->if_seq)) {\n\t\ttrace_xfs_wb_cow_iomap_invalid(ip, &wpc->iomap,\n\t\t\t\tXFS_WPC(wpc)->cow_seq, XFS_COW_FORK);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic int\nxfs_convert_blocks(\n\tstruct iomap_writepage_ctx *wpc,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tloff_t\t\t\toffset)\n{\n\tint\t\t\terror;\n\tunsigned\t\t*seq;\n\n\tif (whichfork == XFS_COW_FORK)\n\t\tseq = &XFS_WPC(wpc)->cow_seq;\n\telse\n\t\tseq = &XFS_WPC(wpc)->data_seq;\n\n\t \n\tdo {\n\t\terror = xfs_bmapi_convert_delalloc(ip, whichfork, offset,\n\t\t\t\t&wpc->iomap, seq);\n\t\tif (error)\n\t\t\treturn error;\n\t} while (wpc->iomap.offset + wpc->iomap.length <= offset);\n\n\treturn 0;\n}\n\nstatic int\nxfs_map_blocks(\n\tstruct iomap_writepage_ctx *wpc,\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\toffset)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tssize_t\t\t\tcount = i_blocksize(inode);\n\txfs_fileoff_t\t\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\txfs_fileoff_t\t\tend_fsb = XFS_B_TO_FSB(mp, offset + count);\n\txfs_fileoff_t\t\tcow_fsb;\n\tint\t\t\twhichfork;\n\tstruct xfs_bmbt_irec\timap;\n\tstruct xfs_iext_cursor\ticur;\n\tint\t\t\tretries = 0;\n\tint\t\t\terror = 0;\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\tXFS_ERRORTAG_DELAY(mp, XFS_ERRTAG_WB_DELAY_MS);\n\n\t \n\tif (xfs_imap_valid(wpc, ip, offset))\n\t\treturn 0;\n\n\t \nretry:\n\tcow_fsb = NULLFILEOFF;\n\twhichfork = XFS_DATA_FORK;\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\tASSERT(!xfs_need_iread_extents(&ip->i_df));\n\n\t \n\tif (xfs_inode_has_cow_data(ip) &&\n\t    xfs_iext_lookup_extent(ip, ip->i_cowfp, offset_fsb, &icur, &imap))\n\t\tcow_fsb = imap.br_startoff;\n\tif (cow_fsb != NULLFILEOFF && cow_fsb <= offset_fsb) {\n\t\tXFS_WPC(wpc)->cow_seq = READ_ONCE(ip->i_cowfp->if_seq);\n\t\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\t\twhichfork = XFS_COW_FORK;\n\t\tgoto allocate_blocks;\n\t}\n\n\t \n\tif (xfs_imap_valid(wpc, ip, offset)) {\n\t\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!xfs_iext_lookup_extent(ip, &ip->i_df, offset_fsb, &icur, &imap))\n\t\timap.br_startoff = end_fsb;\t \n\tXFS_WPC(wpc)->data_seq = READ_ONCE(ip->i_df.if_seq);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\t \n\tif (imap.br_startoff > offset_fsb) {\n\t\timap.br_blockcount = imap.br_startoff - offset_fsb;\n\t\timap.br_startoff = offset_fsb;\n\t\timap.br_startblock = HOLESTARTBLOCK;\n\t\timap.br_state = XFS_EXT_NORM;\n\t}\n\n\t \n\tif (cow_fsb != NULLFILEOFF &&\n\t    cow_fsb < imap.br_startoff + imap.br_blockcount)\n\t\timap.br_blockcount = cow_fsb - imap.br_startoff;\n\n\t \n\tif (imap.br_startblock != HOLESTARTBLOCK &&\n\t    isnullstartblock(imap.br_startblock))\n\t\tgoto allocate_blocks;\n\n\txfs_bmbt_to_iomap(ip, &wpc->iomap, &imap, 0, 0, XFS_WPC(wpc)->data_seq);\n\ttrace_xfs_map_blocks_found(ip, offset, count, whichfork, &imap);\n\treturn 0;\nallocate_blocks:\n\terror = xfs_convert_blocks(wpc, ip, whichfork, offset);\n\tif (error) {\n\t\t \n\t\tif (error == -EAGAIN && whichfork == XFS_COW_FORK && !retries++)\n\t\t\tgoto retry;\n\t\tASSERT(error != -EAGAIN);\n\t\treturn error;\n\t}\n\n\t \n\tif (whichfork != XFS_COW_FORK && cow_fsb != NULLFILEOFF) {\n\t\tloff_t\t\tcow_offset = XFS_FSB_TO_B(mp, cow_fsb);\n\n\t\tif (cow_offset < wpc->iomap.offset + wpc->iomap.length)\n\t\t\twpc->iomap.length = cow_offset - wpc->iomap.offset;\n\t}\n\n\tASSERT(wpc->iomap.offset <= offset);\n\tASSERT(wpc->iomap.offset + wpc->iomap.length > offset);\n\ttrace_xfs_map_blocks_alloc(ip, offset, count, whichfork, &imap);\n\treturn 0;\n}\n\nstatic int\nxfs_prepare_ioend(\n\tstruct iomap_ioend\t*ioend,\n\tint\t\t\tstatus)\n{\n\tunsigned int\t\tnofs_flag;\n\n\t \n\tnofs_flag = memalloc_nofs_save();\n\n\t \n\tif (!status && (ioend->io_flags & IOMAP_F_SHARED)) {\n\t\tstatus = xfs_reflink_convert_cow(XFS_I(ioend->io_inode),\n\t\t\t\tioend->io_offset, ioend->io_size);\n\t}\n\n\tmemalloc_nofs_restore(nofs_flag);\n\n\t \n\tif (xfs_ioend_is_append(ioend) || ioend->io_type == IOMAP_UNWRITTEN ||\n\t    (ioend->io_flags & IOMAP_F_SHARED))\n\t\tioend->io_bio->bi_end_io = xfs_end_bio;\n\treturn status;\n}\n\n \nstatic void\nxfs_discard_folio(\n\tstruct folio\t\t*folio,\n\tloff_t\t\t\tpos)\n{\n\tstruct xfs_inode\t*ip = XFS_I(folio->mapping->host);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\terror;\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn;\n\n\txfs_alert_ratelimited(mp,\n\t\t\"page discard on page \"PTR_FMT\", inode 0x%llx, pos %llu.\",\n\t\t\tfolio, ip->i_ino, pos);\n\n\t \n\terror = xfs_bmap_punch_delalloc_range(ip, pos,\n\t\t\t\tfolio_pos(folio) + folio_size(folio));\n\n\tif (error && !xfs_is_shutdown(mp))\n\t\txfs_alert(mp, \"page discard unable to remove delalloc mapping.\");\n}\n\nstatic const struct iomap_writeback_ops xfs_writeback_ops = {\n\t.map_blocks\t\t= xfs_map_blocks,\n\t.prepare_ioend\t\t= xfs_prepare_ioend,\n\t.discard_folio\t\t= xfs_discard_folio,\n};\n\nSTATIC int\nxfs_vm_writepages(\n\tstruct address_space\t*mapping,\n\tstruct writeback_control *wbc)\n{\n\tstruct xfs_writepage_ctx wpc = { };\n\n\t \n\tif (WARN_ON_ONCE(current->journal_info))\n\t\treturn 0;\n\n\txfs_iflags_clear(XFS_I(mapping->host), XFS_ITRUNCATED);\n\treturn iomap_writepages(mapping, wbc, &wpc.ctx, &xfs_writeback_ops);\n}\n\nSTATIC int\nxfs_dax_writepages(\n\tstruct address_space\t*mapping,\n\tstruct writeback_control *wbc)\n{\n\tstruct xfs_inode\t*ip = XFS_I(mapping->host);\n\n\txfs_iflags_clear(ip, XFS_ITRUNCATED);\n\treturn dax_writeback_mapping_range(mapping,\n\t\t\txfs_inode_buftarg(ip)->bt_daxdev, wbc);\n}\n\nSTATIC sector_t\nxfs_vm_bmap(\n\tstruct address_space\t*mapping,\n\tsector_t\t\tblock)\n{\n\tstruct xfs_inode\t*ip = XFS_I(mapping->host);\n\n\ttrace_xfs_vm_bmap(ip);\n\n\t \n\tif (xfs_is_cow_inode(ip) || XFS_IS_REALTIME_INODE(ip))\n\t\treturn 0;\n\treturn iomap_bmap(mapping, block, &xfs_read_iomap_ops);\n}\n\nSTATIC int\nxfs_vm_read_folio(\n\tstruct file\t\t*unused,\n\tstruct folio\t\t*folio)\n{\n\treturn iomap_read_folio(folio, &xfs_read_iomap_ops);\n}\n\nSTATIC void\nxfs_vm_readahead(\n\tstruct readahead_control\t*rac)\n{\n\tiomap_readahead(rac, &xfs_read_iomap_ops);\n}\n\nstatic int\nxfs_iomap_swapfile_activate(\n\tstruct swap_info_struct\t\t*sis,\n\tstruct file\t\t\t*swap_file,\n\tsector_t\t\t\t*span)\n{\n\tsis->bdev = xfs_inode_buftarg(XFS_I(file_inode(swap_file)))->bt_bdev;\n\treturn iomap_swapfile_activate(sis, swap_file, span,\n\t\t\t&xfs_read_iomap_ops);\n}\n\nconst struct address_space_operations xfs_address_space_operations = {\n\t.read_folio\t\t= xfs_vm_read_folio,\n\t.readahead\t\t= xfs_vm_readahead,\n\t.writepages\t\t= xfs_vm_writepages,\n\t.dirty_folio\t\t= iomap_dirty_folio,\n\t.release_folio\t\t= iomap_release_folio,\n\t.invalidate_folio\t= iomap_invalidate_folio,\n\t.bmap\t\t\t= xfs_vm_bmap,\n\t.migrate_folio\t\t= filemap_migrate_folio,\n\t.is_partially_uptodate  = iomap_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n\t.swap_activate\t\t= xfs_iomap_swapfile_activate,\n};\n\nconst struct address_space_operations xfs_dax_aops = {\n\t.writepages\t\t= xfs_dax_writepages,\n\t.dirty_folio\t\t= noop_dirty_folio,\n\t.swap_activate\t\t= xfs_iomap_swapfile_activate,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}