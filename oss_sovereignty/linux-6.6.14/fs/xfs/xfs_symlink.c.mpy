{
  "module_name": "xfs_symlink.c",
  "hash_id": "81c608613a188d5e16eb59964a6b5785e649d1f2cc0b3ec66cfdb24dfad9327a",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_symlink.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_error.h\"\n\n \nint\nxfs_readlink_bmap_ilocked(\n\tstruct xfs_inode\t*ip,\n\tchar\t\t\t*link)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_bmbt_irec\tmval[XFS_SYMLINK_MAPS];\n\tstruct xfs_buf\t\t*bp;\n\txfs_daddr_t\t\td;\n\tchar\t\t\t*cur_chunk;\n\tint\t\t\tpathlen = ip->i_disk_size;\n\tint\t\t\tnmaps = XFS_SYMLINK_MAPS;\n\tint\t\t\tbyte_cnt;\n\tint\t\t\tn;\n\tint\t\t\terror = 0;\n\tint\t\t\tfsblocks = 0;\n\tint\t\t\toffset;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\n\tfsblocks = xfs_symlink_blocks(mp, pathlen);\n\terror = xfs_bmapi_read(ip, 0, fsblocks, mval, &nmaps, 0);\n\tif (error)\n\t\tgoto out;\n\n\toffset = 0;\n\tfor (n = 0; n < nmaps; n++) {\n\t\td = XFS_FSB_TO_DADDR(mp, mval[n].br_startblock);\n\t\tbyte_cnt = XFS_FSB_TO_B(mp, mval[n].br_blockcount);\n\n\t\terror = xfs_buf_read(mp->m_ddev_targp, d, BTOBB(byte_cnt), 0,\n\t\t\t\t&bp, &xfs_symlink_buf_ops);\n\t\tif (error)\n\t\t\treturn error;\n\t\tbyte_cnt = XFS_SYMLINK_BUF_SPACE(mp, byte_cnt);\n\t\tif (pathlen < byte_cnt)\n\t\t\tbyte_cnt = pathlen;\n\n\t\tcur_chunk = bp->b_addr;\n\t\tif (xfs_has_crc(mp)) {\n\t\t\tif (!xfs_symlink_hdr_ok(ip->i_ino, offset,\n\t\t\t\t\t\t\tbyte_cnt, bp)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\txfs_alert(mp,\n\"symlink header does not match required off/len/owner (0x%x/Ox%x,0x%llx)\",\n\t\t\t\t\toffset, byte_cnt, ip->i_ino);\n\t\t\t\txfs_buf_relse(bp);\n\t\t\t\tgoto out;\n\n\t\t\t}\n\n\t\t\tcur_chunk += sizeof(struct xfs_dsymlink_hdr);\n\t\t}\n\n\t\tmemcpy(link + offset, cur_chunk, byte_cnt);\n\n\t\tpathlen -= byte_cnt;\n\t\toffset += byte_cnt;\n\n\t\txfs_buf_relse(bp);\n\t}\n\tASSERT(pathlen == 0);\n\n\tlink[ip->i_disk_size] = '\\0';\n\terror = 0;\n\n out:\n\treturn error;\n}\n\nint\nxfs_readlink(\n\tstruct xfs_inode\t*ip,\n\tchar\t\t\t*link)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fsize_t\t\tpathlen;\n\tint\t\t\terror = -EFSCORRUPTED;\n\n\ttrace_xfs_readlink(ip);\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\n\tpathlen = ip->i_disk_size;\n\tif (!pathlen)\n\t\tgoto out;\n\n\tif (pathlen < 0 || pathlen > XFS_SYMLINK_MAXLEN) {\n\t\txfs_alert(mp, \"%s: inode (%llu) bad symlink length (%lld)\",\n\t\t\t __func__, (unsigned long long) ip->i_ino,\n\t\t\t (long long) pathlen);\n\t\tASSERT(0);\n\t\tgoto out;\n\t}\n\n\tif (ip->i_df.if_format == XFS_DINODE_FMT_LOCAL) {\n\t\t \n\t\tif (XFS_IS_CORRUPT(ip->i_mount, !ip->i_df.if_u1.if_data))\n\t\t\tgoto out;\n\n\t\tmemcpy(link, ip->i_df.if_u1.if_data, pathlen + 1);\n\t\terror = 0;\n\t} else {\n\t\terror = xfs_readlink_bmap_ilocked(ip, link);\n\t}\n\n out:\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\treturn error;\n}\n\nint\nxfs_symlink(\n\tstruct mnt_idmap\t*idmap,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_name\t\t*link_name,\n\tconst char\t\t*target_path,\n\tumode_t\t\t\tmode,\n\tstruct xfs_inode\t**ipp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_trans\t*tp = NULL;\n\tstruct xfs_inode\t*ip = NULL;\n\tint\t\t\terror = 0;\n\tint\t\t\tpathlen;\n\tbool                    unlock_dp_on_error = false;\n\txfs_fileoff_t\t\tfirst_fsb;\n\txfs_filblks_t\t\tfs_blocks;\n\tint\t\t\tnmaps;\n\tstruct xfs_bmbt_irec\tmval[XFS_SYMLINK_MAPS];\n\txfs_daddr_t\t\td;\n\tconst char\t\t*cur_chunk;\n\tint\t\t\tbyte_cnt;\n\tint\t\t\tn;\n\tstruct xfs_buf\t\t*bp;\n\tprid_t\t\t\tprid;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*gdqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tuint\t\t\tresblks;\n\txfs_ino_t\t\tino;\n\n\t*ipp = NULL;\n\n\ttrace_xfs_symlink(dp, link_name);\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\t \n\tpathlen = strlen(target_path);\n\tif (pathlen >= XFS_SYMLINK_MAXLEN)       \n\t\treturn -ENAMETOOLONG;\n\tASSERT(pathlen > 0);\n\n\tprid = xfs_get_initial_prid(dp);\n\n\t \n\terror = xfs_qm_vop_dqalloc(dp, mapped_fsuid(idmap, &init_user_ns),\n\t\t\tmapped_fsgid(idmap, &init_user_ns), prid,\n\t\t\tXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT,\n\t\t\t&udqp, &gdqp, &pdqp);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (pathlen <= XFS_LITINO(mp))\n\t\tfs_blocks = 0;\n\telse\n\t\tfs_blocks = xfs_symlink_blocks(mp, pathlen);\n\tresblks = XFS_SYMLINK_SPACE_RES(mp, link_name->len, fs_blocks);\n\n\terror = xfs_trans_alloc_icreate(mp, &M_RES(mp)->tr_symlink, udqp, gdqp,\n\t\t\tpdqp, resblks, &tp);\n\tif (error)\n\t\tgoto out_release_dquots;\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL | XFS_ILOCK_PARENT);\n\tunlock_dp_on_error = true;\n\n\t \n\tif (dp->i_diflags & XFS_DIFLAG_NOSYMLINKS) {\n\t\terror = -EPERM;\n\t\tgoto out_trans_cancel;\n\t}\n\n\t \n\terror = xfs_dialloc(&tp, dp->i_ino, S_IFLNK, &ino);\n\tif (!error)\n\t\terror = xfs_init_new_inode(idmap, tp, dp, ino,\n\t\t\t\tS_IFLNK | (mode & ~S_IFMT), 1, 0, prid,\n\t\t\t\tfalse, &ip);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\t \n\txfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\n\tunlock_dp_on_error = false;\n\n\t \n\txfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp, pdqp);\n\n\tresblks -= XFS_IALLOC_SPACE_RES(mp);\n\t \n\tif (pathlen <= xfs_inode_data_fork_size(ip)) {\n\t\txfs_init_local_fork(ip, XFS_DATA_FORK, target_path, pathlen);\n\n\t\tip->i_disk_size = pathlen;\n\t\tip->i_df.if_format = XFS_DINODE_FMT_LOCAL;\n\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_DDATA | XFS_ILOG_CORE);\n\t} else {\n\t\tint\toffset;\n\n\t\tfirst_fsb = 0;\n\t\tnmaps = XFS_SYMLINK_MAPS;\n\n\t\terror = xfs_bmapi_write(tp, ip, first_fsb, fs_blocks,\n\t\t\t\t  XFS_BMAPI_METADATA, resblks, mval, &nmaps);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\tresblks -= fs_blocks;\n\t\tip->i_disk_size = pathlen;\n\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\t\tcur_chunk = target_path;\n\t\toffset = 0;\n\t\tfor (n = 0; n < nmaps; n++) {\n\t\t\tchar\t*buf;\n\n\t\t\td = XFS_FSB_TO_DADDR(mp, mval[n].br_startblock);\n\t\t\tbyte_cnt = XFS_FSB_TO_B(mp, mval[n].br_blockcount);\n\t\t\terror = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,\n\t\t\t\t\t       BTOBB(byte_cnt), 0, &bp);\n\t\t\tif (error)\n\t\t\t\tgoto out_trans_cancel;\n\t\t\tbp->b_ops = &xfs_symlink_buf_ops;\n\n\t\t\tbyte_cnt = XFS_SYMLINK_BUF_SPACE(mp, byte_cnt);\n\t\t\tbyte_cnt = min(byte_cnt, pathlen);\n\n\t\t\tbuf = bp->b_addr;\n\t\t\tbuf += xfs_symlink_hdr_set(mp, ip->i_ino, offset,\n\t\t\t\t\t\t   byte_cnt, bp);\n\n\t\t\tmemcpy(buf, cur_chunk, byte_cnt);\n\n\t\t\tcur_chunk += byte_cnt;\n\t\t\tpathlen -= byte_cnt;\n\t\t\toffset += byte_cnt;\n\n\t\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SYMLINK_BUF);\n\t\t\txfs_trans_log_buf(tp, bp, 0, (buf + byte_cnt - 1) -\n\t\t\t\t\t\t\t(char *)bp->b_addr);\n\t\t}\n\t\tASSERT(pathlen == 0);\n\t}\n\ti_size_write(VFS_I(ip), ip->i_disk_size);\n\n\t \n\terror = xfs_dir_createname(tp, dp, link_name, ip->i_ino, resblks);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\txfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\n\t \n\tif (xfs_has_wsync(mp) || xfs_has_dirsync(mp))\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp);\n\tif (error)\n\t\tgoto out_release_inode;\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\t*ipp = ip;\n\treturn 0;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp);\nout_release_inode:\n\t \n\tif (ip) {\n\t\txfs_finish_inode_setup(ip);\n\t\txfs_irele(ip);\n\t}\nout_release_dquots:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\tif (unlock_dp_on_error)\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_inactive_symlink_rmt(\n\tstruct xfs_inode *ip)\n{\n\tstruct xfs_buf\t*bp;\n\tint\t\tdone;\n\tint\t\terror;\n\tint\t\ti;\n\txfs_mount_t\t*mp;\n\txfs_bmbt_irec_t\tmval[XFS_SYMLINK_MAPS];\n\tint\t\tnmaps;\n\tint\t\tsize;\n\txfs_trans_t\t*tp;\n\n\tmp = ip->i_mount;\n\tASSERT(!xfs_need_iread_extents(&ip->i_df));\n\t \n\tASSERT(ip->i_df.if_nextents > 0 && ip->i_df.if_nextents <= 2);\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_itruncate, 0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t \n\tsize = (int)ip->i_disk_size;\n\tip->i_disk_size = 0;\n\tVFS_I(ip)->i_mode = (VFS_I(ip)->i_mode & ~S_IFMT) | S_IFREG;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t \n\tdone = 0;\n\tnmaps = ARRAY_SIZE(mval);\n\terror = xfs_bmapi_read(ip, 0, xfs_symlink_blocks(mp, size),\n\t\t\t\tmval, &nmaps, 0);\n\tif (error)\n\t\tgoto error_trans_cancel;\n\t \n\tfor (i = 0; i < nmaps; i++) {\n\t\terror = xfs_trans_get_buf(tp, mp->m_ddev_targp,\n\t\t\t\tXFS_FSB_TO_DADDR(mp, mval[i].br_startblock),\n\t\t\t\tXFS_FSB_TO_BB(mp, mval[i].br_blockcount), 0,\n\t\t\t\t&bp);\n\t\tif (error)\n\t\t\tgoto error_trans_cancel;\n\t\txfs_trans_binval(tp, bp);\n\t}\n\t \n\terror = xfs_bunmapi(tp, ip, 0, size, 0, nmaps, &done);\n\tif (error)\n\t\tgoto error_trans_cancel;\n\tASSERT(done);\n\n\t \n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(tp);\n\tif (error) {\n\t\tASSERT(xfs_is_shutdown(mp));\n\t\tgoto error_unlock;\n\t}\n\n\t \n\tif (ip->i_df.if_bytes)\n\t\txfs_idata_realloc(ip, -ip->i_df.if_bytes, XFS_DATA_FORK);\n\tASSERT(ip->i_df.if_bytes == 0);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn 0;\n\nerror_trans_cancel:\n\txfs_trans_cancel(tp);\nerror_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\n \nint\nxfs_inactive_symlink(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tpathlen;\n\n\ttrace_xfs_inactive_symlink(ip);\n\n\tif (xfs_is_shutdown(mp))\n\t\treturn -EIO;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tpathlen = (int)ip->i_disk_size;\n\tASSERT(pathlen);\n\n\tif (pathlen <= 0 || pathlen > XFS_SYMLINK_MAXLEN) {\n\t\txfs_alert(mp, \"%s: inode (0x%llx) bad symlink length (%d)\",\n\t\t\t __func__, (unsigned long long)ip->i_ino, pathlen);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tASSERT(0);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\tif (ip->i_df.if_format == XFS_DINODE_FMT_LOCAL) {\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\treturn 0;\n\t}\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t \n\treturn xfs_inactive_symlink_rmt(ip);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}