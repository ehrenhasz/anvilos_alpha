{
  "module_name": "xfs_iunlink_item.c",
  "hash_id": "cb745caec50abd88a9646f85790c002620ebf180387ae3ec8cc3a845733c85aa",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_iunlink_item.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_iunlink_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n\nstruct kmem_cache\t*xfs_iunlink_cache;\n\nstatic inline struct xfs_iunlink_item *IUL_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_iunlink_item, item);\n}\n\nstatic void\nxfs_iunlink_item_release(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_iunlink_item\t*iup = IUL_ITEM(lip);\n\n\txfs_perag_put(iup->pag);\n\tkmem_cache_free(xfs_iunlink_cache, IUL_ITEM(lip));\n}\n\n\nstatic uint64_t\nxfs_iunlink_item_sort(\n\tstruct xfs_log_item\t*lip)\n{\n\treturn IUL_ITEM(lip)->ip->i_ino;\n}\n\n \nstatic int\nxfs_iunlink_log_dinode(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_iunlink_item\t*iup)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_inode\t*ip = iup->ip;\n\tstruct xfs_dinode\t*dip;\n\tstruct xfs_buf\t\t*ibp;\n\tint\t\t\toffset;\n\tint\t\t\terror;\n\n\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &ibp);\n\tif (error)\n\t\treturn error;\n\t \n\tif (ibp->b_flags & XBF_STALE)\n\t\tgoto out;\n\n\tdip = xfs_buf_offset(ibp, ip->i_imap.im_boffset);\n\n\t \n\tif (be32_to_cpu(dip->di_next_unlinked) != iup->old_agino) {\n\t\txfs_inode_verifier_error(ip, -EFSCORRUPTED, __func__, dip,\n\t\t\t\tsizeof(*dip), __this_address);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\n\ttrace_xfs_iunlink_update_dinode(mp, iup->pag->pag_agno,\n\t\t\tXFS_INO_TO_AGINO(mp, ip->i_ino),\n\t\t\tbe32_to_cpu(dip->di_next_unlinked), iup->next_agino);\n\n\tdip->di_next_unlinked = cpu_to_be32(iup->next_agino);\n\toffset = ip->i_imap.im_boffset +\n\t\t\toffsetof(struct xfs_dinode, di_next_unlinked);\n\n\txfs_dinode_calc_crc(mp, dip);\n\txfs_trans_inode_buf(tp, ibp);\n\txfs_trans_log_buf(tp, ibp, offset, offset + sizeof(xfs_agino_t) - 1);\n\treturn 0;\nout:\n\txfs_trans_brelse(tp, ibp);\n\treturn error;\n}\n\n \nstatic int\nxfs_iunlink_item_precommit(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_iunlink_item\t*iup = IUL_ITEM(lip);\n\tint\t\t\terror;\n\n\terror = xfs_iunlink_log_dinode(tp, iup);\n\tlist_del(&lip->li_trans);\n\txfs_iunlink_item_release(lip);\n\treturn error;\n}\n\nstatic const struct xfs_item_ops xfs_iunlink_item_ops = {\n\t.iop_release\t= xfs_iunlink_item_release,\n\t.iop_sort\t= xfs_iunlink_item_sort,\n\t.iop_precommit\t= xfs_iunlink_item_precommit,\n};\n\n\n \nint\nxfs_iunlink_log_inode(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_perag\t*pag,\n\txfs_agino_t\t\tnext_agino)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_iunlink_item\t*iup;\n\n\tASSERT(xfs_verify_agino_or_null(pag, next_agino));\n\tASSERT(xfs_verify_agino_or_null(pag, ip->i_next_unlinked));\n\n\t \n\tif (ip->i_next_unlinked == next_agino) {\n\t\tif (next_agino != NULLAGINO)\n\t\t\treturn -EFSCORRUPTED;\n\t\treturn 0;\n\t}\n\n\tiup = kmem_cache_zalloc(xfs_iunlink_cache, GFP_KERNEL | __GFP_NOFAIL);\n\txfs_log_item_init(mp, &iup->item, XFS_LI_IUNLINK,\n\t\t\t  &xfs_iunlink_item_ops);\n\n\tiup->ip = ip;\n\tiup->next_agino = next_agino;\n\tiup->old_agino = ip->i_next_unlinked;\n\tiup->pag = xfs_perag_hold(pag);\n\n\txfs_trans_add_item(tp, &iup->item);\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tset_bit(XFS_LI_DIRTY, &iup->item.li_flags);\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}