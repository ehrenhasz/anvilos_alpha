{
  "module_name": "xfs_pwork.c",
  "hash_id": "f891a090cc634b78d3d956d33a20b94d07e8caa692ccf9662339780d0b3bc147",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_pwork.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_pwork.h\"\n#include <linux/nmi.h>\n\n \n\n \nstatic void\nxfs_pwork_work(\n\tstruct work_struct\t*work)\n{\n\tstruct xfs_pwork\t*pwork;\n\tstruct xfs_pwork_ctl\t*pctl;\n\tint\t\t\terror;\n\n\tpwork = container_of(work, struct xfs_pwork, work);\n\tpctl = pwork->pctl;\n\terror = pctl->work_fn(pctl->mp, pwork);\n\tif (error && !pctl->error)\n\t\tpctl->error = error;\n\tif (atomic_dec_and_test(&pctl->nr_work))\n\t\twake_up(&pctl->poll_wait);\n}\n\n \nint\nxfs_pwork_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_pwork_ctl\t*pctl,\n\txfs_pwork_work_fn\twork_fn,\n\tconst char\t\t*tag)\n{\n\tunsigned int\t\tnr_threads = 0;\n\n#ifdef DEBUG\n\tif (xfs_globals.pwork_threads >= 0)\n\t\tnr_threads = xfs_globals.pwork_threads;\n#endif\n\ttrace_xfs_pwork_init(mp, nr_threads, current->pid);\n\n\tpctl->wq = alloc_workqueue(\"%s-%d\",\n\t\t\tWQ_UNBOUND | WQ_SYSFS | WQ_FREEZABLE, nr_threads, tag,\n\t\t\tcurrent->pid);\n\tif (!pctl->wq)\n\t\treturn -ENOMEM;\n\tpctl->work_fn = work_fn;\n\tpctl->error = 0;\n\tpctl->mp = mp;\n\tatomic_set(&pctl->nr_work, 0);\n\tinit_waitqueue_head(&pctl->poll_wait);\n\n\treturn 0;\n}\n\n \nvoid\nxfs_pwork_queue(\n\tstruct xfs_pwork_ctl\t*pctl,\n\tstruct xfs_pwork\t*pwork)\n{\n\tINIT_WORK(&pwork->work, xfs_pwork_work);\n\tpwork->pctl = pctl;\n\tatomic_inc(&pctl->nr_work);\n\tqueue_work(pctl->wq, &pwork->work);\n}\n\n \nint\nxfs_pwork_destroy(\n\tstruct xfs_pwork_ctl\t*pctl)\n{\n\tdestroy_workqueue(pctl->wq);\n\tpctl->wq = NULL;\n\treturn pctl->error;\n}\n\n \nvoid\nxfs_pwork_poll(\n\tstruct xfs_pwork_ctl\t*pctl)\n{\n\twhile (wait_event_timeout(pctl->poll_wait,\n\t\t\t\tatomic_read(&pctl->nr_work) == 0, HZ) == 0)\n\t\ttouch_softlockup_watchdog();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}