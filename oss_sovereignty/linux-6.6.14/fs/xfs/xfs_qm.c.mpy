{
  "module_name": "xfs_qm.c",
  "hash_id": "1e5ec1b321c2a6f1e96c8d90bef1702d7f3ea4027ababbafdff2c89cc32ff595",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_qm.c",
  "human_readable_source": "\n \n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_iwalk.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_error.h\"\n#include \"xfs_ag.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_log_priv.h\"\n\n \nSTATIC int\txfs_qm_init_quotainos(struct xfs_mount *mp);\nSTATIC int\txfs_qm_init_quotainfo(struct xfs_mount *mp);\n\nSTATIC void\txfs_qm_destroy_quotainos(struct xfs_quotainfo *qi);\nSTATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);\n \n#define XFS_DQ_LOOKUP_BATCH\t32\n\nSTATIC int\nxfs_qm_dquot_walk(\n\tstruct xfs_mount\t*mp,\n\txfs_dqtype_t\t\ttype,\n\tint\t\t\t(*execute)(struct xfs_dquot *dqp, void *data),\n\tvoid\t\t\t*data)\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root\t*tree = xfs_dquot_tree(qi, type);\n\tuint32_t\t\tnext_index;\n\tint\t\t\tlast_error = 0;\n\tint\t\t\tskipped;\n\tint\t\t\tnr_found;\n\nrestart:\n\tskipped = 0;\n\tnext_index = 0;\n\tnr_found = 0;\n\n\twhile (1) {\n\t\tstruct xfs_dquot *batch[XFS_DQ_LOOKUP_BATCH];\n\t\tint\t\terror;\n\t\tint\t\ti;\n\n\t\tmutex_lock(&qi->qi_tree_lock);\n\t\tnr_found = radix_tree_gang_lookup(tree, (void **)batch,\n\t\t\t\t\tnext_index, XFS_DQ_LOOKUP_BATCH);\n\t\tif (!nr_found) {\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tstruct xfs_dquot *dqp = batch[i];\n\n\t\t\tnext_index = dqp->q_id + 1;\n\n\t\t\terror = execute(batch[i], data);\n\t\t\tif (error == -EAGAIN) {\n\t\t\t\tskipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\tlast_error = error;\n\t\t}\n\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\t \n\t\tif (last_error == -EFSCORRUPTED) {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (!next_index)\n\t\t\tbreak;\n\t}\n\n\tif (skipped) {\n\t\tdelay(1);\n\t\tgoto restart;\n\t}\n\n\treturn last_error;\n}\n\n\n \nSTATIC int\nxfs_qm_dqpurge(\n\tstruct xfs_dquot\t*dqp,\n\tvoid\t\t\t*data)\n{\n\tstruct xfs_quotainfo\t*qi = dqp->q_mount->m_quotainfo;\n\tint\t\t\terror = -EAGAIN;\n\n\txfs_dqlock(dqp);\n\tif ((dqp->q_flags & XFS_DQFLAG_FREEING) || dqp->q_nrefs != 0)\n\t\tgoto out_unlock;\n\n\tdqp->q_flags |= XFS_DQFLAG_FREEING;\n\n\txfs_dqflock(dqp);\n\n\t \n\tif (XFS_DQ_IS_DIRTY(dqp)) {\n\t\tstruct xfs_buf\t*bp = NULL;\n\n\t\t \n\t\terror = xfs_qm_dqflush(dqp, &bp);\n\t\tif (!error) {\n\t\t\terror = xfs_bwrite(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t} else if (error == -EAGAIN) {\n\t\t\tdqp->q_flags &= ~XFS_DQFLAG_FREEING;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\txfs_dqflock(dqp);\n\t}\n\n\tASSERT(atomic_read(&dqp->q_pincount) == 0);\n\tASSERT(xlog_is_shutdown(dqp->q_logitem.qli_item.li_log) ||\n\t\t!test_bit(XFS_LI_IN_AIL, &dqp->q_logitem.qli_item.li_flags));\n\n\txfs_dqfunlock(dqp);\n\txfs_dqunlock(dqp);\n\n\tradix_tree_delete(xfs_dquot_tree(qi, xfs_dquot_type(dqp)), dqp->q_id);\n\tqi->qi_dquots--;\n\n\t \n\tASSERT(!list_empty(&dqp->q_lru));\n\tlist_lru_del(&qi->qi_lru, &dqp->q_lru);\n\tXFS_STATS_DEC(dqp->q_mount, xs_qm_dquot_unused);\n\n\txfs_qm_dqdestroy(dqp);\n\treturn 0;\n\nout_unlock:\n\txfs_dqunlock(dqp);\n\treturn error;\n}\n\n \nstatic void\nxfs_qm_dqpurge_all(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_qm_dquot_walk(mp, XFS_DQTYPE_USER, xfs_qm_dqpurge, NULL);\n\txfs_qm_dquot_walk(mp, XFS_DQTYPE_GROUP, xfs_qm_dqpurge, NULL);\n\txfs_qm_dquot_walk(mp, XFS_DQTYPE_PROJ, xfs_qm_dqpurge, NULL);\n}\n\n \nvoid\nxfs_qm_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_quotainfo) {\n\t\txfs_qm_dqpurge_all(mp);\n\t\txfs_qm_destroy_quotainfo(mp);\n\t}\n}\n\n \nvoid\nxfs_qm_unmount_quotas(\n\txfs_mount_t\t*mp)\n{\n\t \n\tASSERT(mp->m_rootip);\n\txfs_qm_dqdetach(mp->m_rootip);\n\tif (mp->m_rbmip)\n\t\txfs_qm_dqdetach(mp->m_rbmip);\n\tif (mp->m_rsumip)\n\t\txfs_qm_dqdetach(mp->m_rsumip);\n\n\t \n\tif (mp->m_quotainfo) {\n\t\tif (mp->m_quotainfo->qi_uquotaip) {\n\t\t\txfs_irele(mp->m_quotainfo->qi_uquotaip);\n\t\t\tmp->m_quotainfo->qi_uquotaip = NULL;\n\t\t}\n\t\tif (mp->m_quotainfo->qi_gquotaip) {\n\t\t\txfs_irele(mp->m_quotainfo->qi_gquotaip);\n\t\t\tmp->m_quotainfo->qi_gquotaip = NULL;\n\t\t}\n\t\tif (mp->m_quotainfo->qi_pquotaip) {\n\t\t\txfs_irele(mp->m_quotainfo->qi_pquotaip);\n\t\t\tmp->m_quotainfo->qi_pquotaip = NULL;\n\t\t}\n\t}\n}\n\nSTATIC int\nxfs_qm_dqattach_one(\n\tstruct xfs_inode\t*ip,\n\txfs_dqtype_t\t\ttype,\n\tbool\t\t\tdoalloc,\n\tstruct xfs_dquot\t**IO_idqpp)\n{\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\terror = 0;\n\n\t \n\tdqp = *IO_idqpp;\n\tif (dqp) {\n\t\ttrace_xfs_dqattach_found(dqp);\n\t\treturn 0;\n\t}\n\n\t \n\terror = xfs_qm_dqget_inode(ip, type, doalloc, &dqp);\n\tif (error)\n\t\treturn error;\n\n\ttrace_xfs_dqattach_get(dqp);\n\n\t \n\t*IO_idqpp = dqp;\n\txfs_dqunlock(dqp);\n\treturn 0;\n}\n\nstatic bool\nxfs_qm_need_dqattach(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_ON(mp))\n\t\treturn false;\n\tif (!XFS_NOT_DQATTACHED(mp, ip))\n\t\treturn false;\n\tif (xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn false;\n\treturn true;\n}\n\n \nint\nxfs_qm_dqattach_locked(\n\txfs_inode_t\t*ip,\n\tbool\t\tdoalloc)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\tint\t\terror = 0;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (XFS_IS_UQUOTA_ON(mp) && !ip->i_udquot) {\n\t\terror = xfs_qm_dqattach_one(ip, XFS_DQTYPE_USER,\n\t\t\t\tdoalloc, &ip->i_udquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_udquot);\n\t}\n\n\tif (XFS_IS_GQUOTA_ON(mp) && !ip->i_gdquot) {\n\t\terror = xfs_qm_dqattach_one(ip, XFS_DQTYPE_GROUP,\n\t\t\t\tdoalloc, &ip->i_gdquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_gdquot);\n\t}\n\n\tif (XFS_IS_PQUOTA_ON(mp) && !ip->i_pdquot) {\n\t\terror = xfs_qm_dqattach_one(ip, XFS_DQTYPE_PROJ,\n\t\t\t\tdoalloc, &ip->i_pdquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_pdquot);\n\t}\n\ndone:\n\t \n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\treturn error;\n}\n\nint\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, false);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}\n\n \nvoid\nxfs_qm_dqdetach(\n\txfs_inode_t\t*ip)\n{\n\tif (!(ip->i_udquot || ip->i_gdquot || ip->i_pdquot))\n\t\treturn;\n\n\ttrace_xfs_dquot_dqdetach(ip);\n\n\tASSERT(!xfs_is_quota_inode(&ip->i_mount->m_sb, ip->i_ino));\n\tif (ip->i_udquot) {\n\t\txfs_qm_dqrele(ip->i_udquot);\n\t\tip->i_udquot = NULL;\n\t}\n\tif (ip->i_gdquot) {\n\t\txfs_qm_dqrele(ip->i_gdquot);\n\t\tip->i_gdquot = NULL;\n\t}\n\tif (ip->i_pdquot) {\n\t\txfs_qm_dqrele(ip->i_pdquot);\n\t\tip->i_pdquot = NULL;\n\t}\n}\n\nstruct xfs_qm_isolate {\n\tstruct list_head\tbuffers;\n\tstruct list_head\tdispose;\n};\n\nstatic enum lru_status\nxfs_qm_dquot_isolate(\n\tstruct list_head\t*item,\n\tstruct list_lru_one\t*lru,\n\tspinlock_t\t\t*lru_lock,\n\tvoid\t\t\t*arg)\n\t\t__releases(lru_lock) __acquires(lru_lock)\n{\n\tstruct xfs_dquot\t*dqp = container_of(item,\n\t\t\t\t\t\tstruct xfs_dquot, q_lru);\n\tstruct xfs_qm_isolate\t*isol = arg;\n\n\tif (!xfs_dqlock_nowait(dqp))\n\t\tgoto out_miss_busy;\n\n\t \n\tif (dqp->q_flags & XFS_DQFLAG_FREEING)\n\t\tgoto out_miss_unlock;\n\n\t \n\tif (dqp->q_nrefs) {\n\t\txfs_dqunlock(dqp);\n\t\tXFS_STATS_INC(dqp->q_mount, xs_qm_dqwants);\n\n\t\ttrace_xfs_dqreclaim_want(dqp);\n\t\tlist_lru_isolate(lru, &dqp->q_lru);\n\t\tXFS_STATS_DEC(dqp->q_mount, xs_qm_dquot_unused);\n\t\treturn LRU_REMOVED;\n\t}\n\n\t \n\tif (!xfs_dqflock_nowait(dqp))\n\t\tgoto out_miss_unlock;\n\n\tif (XFS_DQ_IS_DIRTY(dqp)) {\n\t\tstruct xfs_buf\t*bp = NULL;\n\t\tint\t\terror;\n\n\t\ttrace_xfs_dqreclaim_dirty(dqp);\n\n\t\t \n\t\tspin_unlock(lru_lock);\n\n\t\terror = xfs_qm_dqflush(dqp, &bp);\n\t\tif (error)\n\t\t\tgoto out_unlock_dirty;\n\n\t\txfs_buf_delwri_queue(bp, &isol->buffers);\n\t\txfs_buf_relse(bp);\n\t\tgoto out_unlock_dirty;\n\t}\n\txfs_dqfunlock(dqp);\n\n\t \n\tdqp->q_flags |= XFS_DQFLAG_FREEING;\n\txfs_dqunlock(dqp);\n\n\tASSERT(dqp->q_nrefs == 0);\n\tlist_lru_isolate_move(lru, &dqp->q_lru, &isol->dispose);\n\tXFS_STATS_DEC(dqp->q_mount, xs_qm_dquot_unused);\n\ttrace_xfs_dqreclaim_done(dqp);\n\tXFS_STATS_INC(dqp->q_mount, xs_qm_dqreclaims);\n\treturn LRU_REMOVED;\n\nout_miss_unlock:\n\txfs_dqunlock(dqp);\nout_miss_busy:\n\ttrace_xfs_dqreclaim_busy(dqp);\n\tXFS_STATS_INC(dqp->q_mount, xs_qm_dqreclaim_misses);\n\treturn LRU_SKIP;\n\nout_unlock_dirty:\n\ttrace_xfs_dqreclaim_busy(dqp);\n\tXFS_STATS_INC(dqp->q_mount, xs_qm_dqreclaim_misses);\n\txfs_dqunlock(dqp);\n\tspin_lock(lru_lock);\n\treturn LRU_RETRY;\n}\n\nstatic unsigned long\nxfs_qm_shrink_scan(\n\tstruct shrinker\t\t*shrink,\n\tstruct shrink_control\t*sc)\n{\n\tstruct xfs_quotainfo\t*qi = container_of(shrink,\n\t\t\t\t\tstruct xfs_quotainfo, qi_shrinker);\n\tstruct xfs_qm_isolate\tisol;\n\tunsigned long\t\tfreed;\n\tint\t\t\terror;\n\n\tif ((sc->gfp_mask & (__GFP_FS|__GFP_DIRECT_RECLAIM)) != (__GFP_FS|__GFP_DIRECT_RECLAIM))\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&isol.buffers);\n\tINIT_LIST_HEAD(&isol.dispose);\n\n\tfreed = list_lru_shrink_walk(&qi->qi_lru, sc,\n\t\t\t\t     xfs_qm_dquot_isolate, &isol);\n\n\terror = xfs_buf_delwri_submit(&isol.buffers);\n\tif (error)\n\t\txfs_warn(NULL, \"%s: dquot reclaim failed\", __func__);\n\n\twhile (!list_empty(&isol.dispose)) {\n\t\tstruct xfs_dquot\t*dqp;\n\n\t\tdqp = list_first_entry(&isol.dispose, struct xfs_dquot, q_lru);\n\t\tlist_del_init(&dqp->q_lru);\n\t\txfs_qm_dqfree_one(dqp);\n\t}\n\n\treturn freed;\n}\n\nstatic unsigned long\nxfs_qm_shrink_count(\n\tstruct shrinker\t\t*shrink,\n\tstruct shrink_control\t*sc)\n{\n\tstruct xfs_quotainfo\t*qi = container_of(shrink,\n\t\t\t\t\tstruct xfs_quotainfo, qi_shrinker);\n\n\treturn list_lru_shrink_count(&qi->qi_lru, sc);\n}\n\nSTATIC void\nxfs_qm_set_defquota(\n\tstruct xfs_mount\t*mp,\n\txfs_dqtype_t\t\ttype,\n\tstruct xfs_quotainfo\t*qinf)\n{\n\tstruct xfs_dquot\t*dqp;\n\tstruct xfs_def_quota\t*defq;\n\tint\t\t\terror;\n\n\terror = xfs_qm_dqget_uncached(mp, 0, type, &dqp);\n\tif (error)\n\t\treturn;\n\n\tdefq = xfs_get_defquota(qinf, xfs_dquot_type(dqp));\n\n\t \n\tdefq->blk.hard = dqp->q_blk.hardlimit;\n\tdefq->blk.soft = dqp->q_blk.softlimit;\n\tdefq->ino.hard = dqp->q_ino.hardlimit;\n\tdefq->ino.soft = dqp->q_ino.softlimit;\n\tdefq->rtb.hard = dqp->q_rtb.hardlimit;\n\tdefq->rtb.soft = dqp->q_rtb.softlimit;\n\txfs_qm_dqdestroy(dqp);\n}\n\n \nstatic void\nxfs_qm_init_timelimits(\n\tstruct xfs_mount\t*mp,\n\txfs_dqtype_t\t\ttype)\n{\n\tstruct xfs_quotainfo\t*qinf = mp->m_quotainfo;\n\tstruct xfs_def_quota\t*defq;\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\tdefq = xfs_get_defquota(qinf, type);\n\n\tdefq->blk.time = XFS_QM_BTIMELIMIT;\n\tdefq->ino.time = XFS_QM_ITIMELIMIT;\n\tdefq->rtb.time = XFS_QM_RTBTIMELIMIT;\n\n\t \n\terror = xfs_qm_dqget_uncached(mp, 0, type, &dqp);\n\tif (error)\n\t\treturn;\n\n\t \n\tif (dqp->q_blk.timer)\n\t\tdefq->blk.time = dqp->q_blk.timer;\n\tif (dqp->q_ino.timer)\n\t\tdefq->ino.time = dqp->q_ino.timer;\n\tif (dqp->q_rtb.timer)\n\t\tdefq->rtb.time = dqp->q_rtb.timer;\n\n\txfs_qm_dqdestroy(dqp);\n}\n\n \nSTATIC int\nxfs_qm_init_quotainfo(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_quotainfo\t*qinf;\n\tint\t\t\terror;\n\n\tASSERT(XFS_IS_QUOTA_ON(mp));\n\n\tqinf = mp->m_quotainfo = kmem_zalloc(sizeof(struct xfs_quotainfo), 0);\n\n\terror = list_lru_init(&qinf->qi_lru);\n\tif (error)\n\t\tgoto out_free_qinf;\n\n\t \n\terror = xfs_qm_init_quotainos(mp);\n\tif (error)\n\t\tgoto out_free_lru;\n\n\tINIT_RADIX_TREE(&qinf->qi_uquota_tree, GFP_NOFS);\n\tINIT_RADIX_TREE(&qinf->qi_gquota_tree, GFP_NOFS);\n\tINIT_RADIX_TREE(&qinf->qi_pquota_tree, GFP_NOFS);\n\tmutex_init(&qinf->qi_tree_lock);\n\n\t \n\tmutex_init(&qinf->qi_quotaofflock);\n\n\t \n\tqinf->qi_dqchunklen = XFS_FSB_TO_BB(mp, XFS_DQUOT_CLUSTER_SIZE_FSB);\n\tqinf->qi_dqperchunk = xfs_calc_dquots_per_chunk(qinf->qi_dqchunklen);\n\tif (xfs_has_bigtime(mp)) {\n\t\tqinf->qi_expiry_min =\n\t\t\txfs_dq_bigtime_to_unix(XFS_DQ_BIGTIME_EXPIRY_MIN);\n\t\tqinf->qi_expiry_max =\n\t\t\txfs_dq_bigtime_to_unix(XFS_DQ_BIGTIME_EXPIRY_MAX);\n\t} else {\n\t\tqinf->qi_expiry_min = XFS_DQ_LEGACY_EXPIRY_MIN;\n\t\tqinf->qi_expiry_max = XFS_DQ_LEGACY_EXPIRY_MAX;\n\t}\n\ttrace_xfs_quota_expiry_range(mp, qinf->qi_expiry_min,\n\t\t\tqinf->qi_expiry_max);\n\n\tmp->m_qflags |= (mp->m_sb.sb_qflags & XFS_ALL_QUOTA_CHKD);\n\n\txfs_qm_init_timelimits(mp, XFS_DQTYPE_USER);\n\txfs_qm_init_timelimits(mp, XFS_DQTYPE_GROUP);\n\txfs_qm_init_timelimits(mp, XFS_DQTYPE_PROJ);\n\n\tif (XFS_IS_UQUOTA_ON(mp))\n\t\txfs_qm_set_defquota(mp, XFS_DQTYPE_USER, qinf);\n\tif (XFS_IS_GQUOTA_ON(mp))\n\t\txfs_qm_set_defquota(mp, XFS_DQTYPE_GROUP, qinf);\n\tif (XFS_IS_PQUOTA_ON(mp))\n\t\txfs_qm_set_defquota(mp, XFS_DQTYPE_PROJ, qinf);\n\n\tqinf->qi_shrinker.count_objects = xfs_qm_shrink_count;\n\tqinf->qi_shrinker.scan_objects = xfs_qm_shrink_scan;\n\tqinf->qi_shrinker.seeks = DEFAULT_SEEKS;\n\tqinf->qi_shrinker.flags = SHRINKER_NUMA_AWARE;\n\n\terror = register_shrinker(&qinf->qi_shrinker, \"xfs-qm:%s\",\n\t\t\t\t  mp->m_super->s_id);\n\tif (error)\n\t\tgoto out_free_inos;\n\n\treturn 0;\n\nout_free_inos:\n\tmutex_destroy(&qinf->qi_quotaofflock);\n\tmutex_destroy(&qinf->qi_tree_lock);\n\txfs_qm_destroy_quotainos(qinf);\nout_free_lru:\n\tlist_lru_destroy(&qinf->qi_lru);\nout_free_qinf:\n\tkmem_free(qinf);\n\tmp->m_quotainfo = NULL;\n\treturn error;\n}\n\n \nvoid\nxfs_qm_destroy_quotainfo(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_quotainfo\t*qi;\n\n\tqi = mp->m_quotainfo;\n\tASSERT(qi != NULL);\n\n\tunregister_shrinker(&qi->qi_shrinker);\n\tlist_lru_destroy(&qi->qi_lru);\n\txfs_qm_destroy_quotainos(qi);\n\tmutex_destroy(&qi->qi_tree_lock);\n\tmutex_destroy(&qi->qi_quotaofflock);\n\tkmem_free(qi);\n\tmp->m_quotainfo = NULL;\n}\n\n \nSTATIC int\nxfs_qm_qino_alloc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t**ipp,\n\tunsigned int\t\tflags)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tbool\t\t\tneed_alloc = true;\n\n\t*ipp = NULL;\n\t \n\tif (!xfs_has_pquotino(mp) &&\n\t\t\t(flags & (XFS_QMOPT_PQUOTA|XFS_QMOPT_GQUOTA))) {\n\t\txfs_ino_t ino = NULLFSINO;\n\n\t\tif ((flags & XFS_QMOPT_PQUOTA) &&\n\t\t\t     (mp->m_sb.sb_gquotino != NULLFSINO)) {\n\t\t\tino = mp->m_sb.sb_gquotino;\n\t\t\tif (XFS_IS_CORRUPT(mp,\n\t\t\t\t\t   mp->m_sb.sb_pquotino != NULLFSINO))\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t} else if ((flags & XFS_QMOPT_GQUOTA) &&\n\t\t\t     (mp->m_sb.sb_pquotino != NULLFSINO)) {\n\t\t\tino = mp->m_sb.sb_pquotino;\n\t\t\tif (XFS_IS_CORRUPT(mp,\n\t\t\t\t\t   mp->m_sb.sb_gquotino != NULLFSINO))\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (ino != NULLFSINO) {\n\t\t\terror = xfs_iget(mp, NULL, ino, 0, 0, ipp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tmp->m_sb.sb_gquotino = NULLFSINO;\n\t\t\tmp->m_sb.sb_pquotino = NULLFSINO;\n\t\t\tneed_alloc = false;\n\t\t}\n\t}\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_create,\n\t\t\tneed_alloc ? XFS_QM_QINOCREATE_SPACE_RES(mp) : 0,\n\t\t\t0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\tif (need_alloc) {\n\t\txfs_ino_t\tino;\n\n\t\terror = xfs_dialloc(&tp, 0, S_IFREG, &ino);\n\t\tif (!error)\n\t\t\terror = xfs_init_new_inode(&nop_mnt_idmap, tp, NULL, ino,\n\t\t\t\t\tS_IFREG, 1, 0, 0, false, ipp);\n\t\tif (error) {\n\t\t\txfs_trans_cancel(tp);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t \n\tspin_lock(&mp->m_sb_lock);\n\tif (flags & XFS_QMOPT_SBVERSION) {\n\t\tASSERT(!xfs_has_quota(mp));\n\n\t\txfs_add_quota(mp);\n\t\tmp->m_sb.sb_uquotino = NULLFSINO;\n\t\tmp->m_sb.sb_gquotino = NULLFSINO;\n\t\tmp->m_sb.sb_pquotino = NULLFSINO;\n\n\t\t \n\t\tmp->m_sb.sb_qflags = mp->m_qflags & XFS_ALL_QUOTA_ACCT;\n\t}\n\tif (flags & XFS_QMOPT_UQUOTA)\n\t\tmp->m_sb.sb_uquotino = (*ipp)->i_ino;\n\telse if (flags & XFS_QMOPT_GQUOTA)\n\t\tmp->m_sb.sb_gquotino = (*ipp)->i_ino;\n\telse\n\t\tmp->m_sb.sb_pquotino = (*ipp)->i_ino;\n\tspin_unlock(&mp->m_sb_lock);\n\txfs_log_sb(tp);\n\n\terror = xfs_trans_commit(tp);\n\tif (error) {\n\t\tASSERT(xfs_is_shutdown(mp));\n\t\txfs_alert(mp, \"%s failed (error %d)!\", __func__, error);\n\t}\n\tif (need_alloc)\n\t\txfs_finish_inode_setup(*ipp);\n\treturn error;\n}\n\n\nSTATIC void\nxfs_qm_reset_dqcounts(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dqid_t\t\tid,\n\txfs_dqtype_t\t\ttype)\n{\n\tstruct xfs_dqblk\t*dqb;\n\tint\t\t\tj;\n\n\ttrace_xfs_reset_dqcounts(bp, _RET_IP_);\n\n\t \n#ifdef DEBUG\n\tj = (int)XFS_FSB_TO_B(mp, XFS_DQUOT_CLUSTER_SIZE_FSB) /\n\t\tsizeof(struct xfs_dqblk);\n\tASSERT(mp->m_quotainfo->qi_dqperchunk == j);\n#endif\n\tdqb = bp->b_addr;\n\tfor (j = 0; j < mp->m_quotainfo->qi_dqperchunk; j++) {\n\t\tstruct xfs_disk_dquot\t*ddq;\n\n\t\tddq = (struct xfs_disk_dquot *)&dqb[j];\n\n\t\t \n\t\tif (xfs_dqblk_verify(mp, &dqb[j], id + j) ||\n\t\t    (dqb[j].dd_diskdq.d_type & XFS_DQTYPE_REC_MASK) != type)\n\t\t\txfs_dqblk_repair(mp, &dqb[j], id + j, type);\n\n\t\t \n\t\tddq->d_type = type;\n\t\tddq->d_bcount = 0;\n\t\tddq->d_icount = 0;\n\t\tddq->d_rtbcount = 0;\n\n\t\t \n\t\tif (ddq->d_id != 0) {\n\t\t\tddq->d_btimer = 0;\n\t\t\tddq->d_itimer = 0;\n\t\t\tddq->d_rtbtimer = 0;\n\t\t\tddq->d_bwarns = 0;\n\t\t\tddq->d_iwarns = 0;\n\t\t\tddq->d_rtbwarns = 0;\n\t\t\tif (xfs_has_bigtime(mp))\n\t\t\t\tddq->d_type |= XFS_DQTYPE_BIGTIME;\n\t\t}\n\n\t\tif (xfs_has_crc(mp)) {\n\t\t\txfs_update_cksum((char *)&dqb[j],\n\t\t\t\t\t sizeof(struct xfs_dqblk),\n\t\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t\t}\n\t}\n}\n\nSTATIC int\nxfs_qm_reset_dqcounts_all(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tfirstid,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tblkcnt,\n\txfs_dqtype_t\t\ttype,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror = 0;\n\n\tASSERT(blkcnt > 0);\n\n\t \n\twhile (blkcnt--) {\n\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t      XFS_FSB_TO_DADDR(mp, bno),\n\t\t\t      mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t      &xfs_dquot_buf_ops);\n\n\t\t \n\t\tif (error == -EFSCORRUPTED) {\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t      XFS_FSB_TO_DADDR(mp, bno),\n\t\t\t\t      mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t\t      NULL);\n\t\t}\n\n\t\tif (error)\n\t\t\tbreak;\n\n\t\t \n\t\tbp->b_ops = &xfs_dquot_buf_ops;\n\t\txfs_qm_reset_dqcounts(mp, bp, firstid, type);\n\t\txfs_buf_delwri_queue(bp, buffer_list);\n\t\txfs_buf_relse(bp);\n\n\t\t \n\t\tbno++;\n\t\tfirstid += mp->m_quotainfo->qi_dqperchunk;\n\t}\n\n\treturn error;\n}\n\n \nSTATIC int\nxfs_qm_reset_dqcounts_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*qip,\n\txfs_dqtype_t\t\ttype,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_bmbt_irec\t*map;\n\tint\t\t\ti, nmaps;\t \n\tint\t\t\terror;\t\t \n\txfs_fileoff_t\t\tlblkno;\n\txfs_filblks_t\t\tmaxlblkcnt;\n\txfs_dqid_t\t\tfirstid;\n\txfs_fsblock_t\t\trablkno;\n\txfs_filblks_t\t\trablkcnt;\n\n\terror = 0;\n\t \n\tif (qip->i_nblocks == 0)\n\t\treturn 0;\n\n\tmap = kmem_alloc(XFS_DQITER_MAP_SIZE * sizeof(*map), 0);\n\n\tlblkno = 0;\n\tmaxlblkcnt = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tdo {\n\t\tuint\t\tlock_mode;\n\n\t\tnmaps = XFS_DQITER_MAP_SIZE;\n\t\t \n\t\tlock_mode = xfs_ilock_data_map_shared(qip);\n\t\terror = xfs_bmapi_read(qip, lblkno, maxlblkcnt - lblkno,\n\t\t\t\t       map, &nmaps, 0);\n\t\txfs_iunlock(qip, lock_mode);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tASSERT(nmaps <= XFS_DQITER_MAP_SIZE);\n\t\tfor (i = 0; i < nmaps; i++) {\n\t\t\tASSERT(map[i].br_startblock != DELAYSTARTBLOCK);\n\t\t\tASSERT(map[i].br_blockcount);\n\n\n\t\t\tlblkno += map[i].br_blockcount;\n\n\t\t\tif (map[i].br_startblock == HOLESTARTBLOCK)\n\t\t\t\tcontinue;\n\n\t\t\tfirstid = (xfs_dqid_t) map[i].br_startoff *\n\t\t\t\tmp->m_quotainfo->qi_dqperchunk;\n\t\t\t \n\t\t\tif ((i+1 < nmaps) &&\n\t\t\t    (map[i+1].br_startblock != HOLESTARTBLOCK)) {\n\t\t\t\trablkcnt =  map[i+1].br_blockcount;\n\t\t\t\trablkno = map[i+1].br_startblock;\n\t\t\t\twhile (rablkcnt--) {\n\t\t\t\t\txfs_buf_readahead(mp->m_ddev_targp,\n\t\t\t\t\t       XFS_FSB_TO_DADDR(mp, rablkno),\n\t\t\t\t\t       mp->m_quotainfo->qi_dqchunklen,\n\t\t\t\t\t       &xfs_dquot_buf_ops);\n\t\t\t\t\trablkno++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\terror = xfs_qm_reset_dqcounts_all(mp, firstid,\n\t\t\t\t\t\t   map[i].br_startblock,\n\t\t\t\t\t\t   map[i].br_blockcount,\n\t\t\t\t\t\t   type, buffer_list);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\t} while (nmaps > 0);\n\nout:\n\tkmem_free(map);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_qm_quotacheck_dqadjust(\n\tstruct xfs_inode\t*ip,\n\txfs_dqtype_t\t\ttype,\n\txfs_qcnt_t\t\tnblks,\n\txfs_qcnt_t\t\trtblks)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_dquot\t*dqp;\n\txfs_dqid_t\t\tid;\n\tint\t\t\terror;\n\n\tid = xfs_qm_id_for_quotatype(ip, type);\n\terror = xfs_qm_dqget(mp, id, type, true, &dqp);\n\tif (error) {\n\t\t \n\t\tASSERT(error != -ESRCH);\n\t\tASSERT(error != -ENOENT);\n\t\treturn error;\n\t}\n\n\ttrace_xfs_dqadjust(dqp);\n\n\t \n\tdqp->q_ino.count++;\n\tdqp->q_ino.reserved++;\n\tif (nblks) {\n\t\tdqp->q_blk.count += nblks;\n\t\tdqp->q_blk.reserved += nblks;\n\t}\n\tif (rtblks) {\n\t\tdqp->q_rtb.count += rtblks;\n\t\tdqp->q_rtb.reserved += rtblks;\n\t}\n\n\t \n\tif (dqp->q_id) {\n\t\txfs_qm_adjust_dqlimits(dqp);\n\t\txfs_qm_adjust_dqtimers(dqp);\n\t}\n\n\tdqp->q_flags |= XFS_DQFLAG_DIRTY;\n\txfs_qm_dqput(dqp);\n\treturn 0;\n}\n\n \n \nSTATIC int\nxfs_qm_dqusage_adjust(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\txfs_ino_t\t\tino,\n\tvoid\t\t\t*data)\n{\n\tstruct xfs_inode\t*ip;\n\txfs_qcnt_t\t\tnblks;\n\txfs_filblks_t\t\trtblks = 0;\t \n\tint\t\t\terror;\n\n\tASSERT(XFS_IS_QUOTA_ON(mp));\n\n\t \n\tif (xfs_is_quota_inode(&mp->m_sb, ino))\n\t\treturn 0;\n\n\t \n\terror = xfs_iget(mp, tp, ino, XFS_IGET_DONTCACHE, 0, &ip);\n\tif (error == -EINVAL || error == -ENOENT)\n\t\treturn 0;\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (xfs_inode_unlinked_incomplete(ip)) {\n\t\terror = xfs_inode_reload_unlinked(ip);\n\t\tif (error) {\n\t\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\t\tgoto error0;\n\t\t}\n\t}\n\n\tASSERT(ip->i_delayed_blks == 0);\n\n\tif (XFS_IS_REALTIME_INODE(ip)) {\n\t\tstruct xfs_ifork\t*ifp = xfs_ifork_ptr(ip, XFS_DATA_FORK);\n\n\t\terror = xfs_iread_extents(tp, ip, XFS_DATA_FORK);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_bmap_count_leaves(ifp, &rtblks);\n\t}\n\n\tnblks = (xfs_qcnt_t)ip->i_nblocks - rtblks;\n\txfs_iflags_clear(ip, XFS_IQUOTAUNCHECKED);\n\n\t \n\tif (XFS_IS_UQUOTA_ON(mp)) {\n\t\terror = xfs_qm_quotacheck_dqadjust(ip, XFS_DQTYPE_USER, nblks,\n\t\t\t\trtblks);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (XFS_IS_GQUOTA_ON(mp)) {\n\t\terror = xfs_qm_quotacheck_dqadjust(ip, XFS_DQTYPE_GROUP, nblks,\n\t\t\t\trtblks);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (XFS_IS_PQUOTA_ON(mp)) {\n\t\terror = xfs_qm_quotacheck_dqadjust(ip, XFS_DQTYPE_PROJ, nblks,\n\t\t\t\trtblks);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\nerror0:\n\txfs_irele(ip);\n\treturn error;\n}\n\nSTATIC int\nxfs_qm_flush_one(\n\tstruct xfs_dquot\t*dqp,\n\tvoid\t\t\t*data)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct list_head\t*buffer_list = data;\n\tstruct xfs_buf\t\t*bp = NULL;\n\tint\t\t\terror = 0;\n\n\txfs_dqlock(dqp);\n\tif (dqp->q_flags & XFS_DQFLAG_FREEING)\n\t\tgoto out_unlock;\n\tif (!XFS_DQ_IS_DIRTY(dqp))\n\t\tgoto out_unlock;\n\n\t \n\tif (!xfs_dqflock_nowait(dqp)) {\n\t\t \n\t\terror = xfs_buf_incore(mp->m_ddev_targp, dqp->q_blkno,\n\t\t\t\tmp->m_quotainfo->qi_dqchunklen, 0, &bp);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\n\t\tif (!(bp->b_flags & _XBF_DELWRI_Q)) {\n\t\t\terror = -EAGAIN;\n\t\t\txfs_buf_relse(bp);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\txfs_buf_unlock(bp);\n\n\t\txfs_buf_delwri_pushbuf(bp, buffer_list);\n\t\txfs_buf_rele(bp);\n\n\t\terror = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\terror = xfs_qm_dqflush(dqp, &bp);\n\tif (error)\n\t\tgoto out_unlock;\n\n\txfs_buf_delwri_queue(bp, buffer_list);\n\txfs_buf_relse(bp);\nout_unlock:\n\txfs_dqunlock(dqp);\n\treturn error;\n}\n\n \nSTATIC int\nxfs_qm_quotacheck(\n\txfs_mount_t\t*mp)\n{\n\tint\t\t\terror, error2;\n\tuint\t\t\tflags;\n\tLIST_HEAD\t\t(buffer_list);\n\tstruct xfs_inode\t*uip = mp->m_quotainfo->qi_uquotaip;\n\tstruct xfs_inode\t*gip = mp->m_quotainfo->qi_gquotaip;\n\tstruct xfs_inode\t*pip = mp->m_quotainfo->qi_pquotaip;\n\n\tflags = 0;\n\n\tASSERT(uip || gip || pip);\n\tASSERT(XFS_IS_QUOTA_ON(mp));\n\n\txfs_notice(mp, \"Quotacheck needed: Please wait.\");\n\n\t \n\tif (uip) {\n\t\terror = xfs_qm_reset_dqcounts_buf(mp, uip, XFS_DQTYPE_USER,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_UQUOTA_CHKD;\n\t}\n\n\tif (gip) {\n\t\terror = xfs_qm_reset_dqcounts_buf(mp, gip, XFS_DQTYPE_GROUP,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_GQUOTA_CHKD;\n\t}\n\n\tif (pip) {\n\t\terror = xfs_qm_reset_dqcounts_buf(mp, pip, XFS_DQTYPE_PROJ,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_PQUOTA_CHKD;\n\t}\n\n\txfs_set_quotacheck_running(mp);\n\terror = xfs_iwalk_threaded(mp, 0, 0, xfs_qm_dqusage_adjust, 0, true,\n\t\t\tNULL);\n\txfs_clear_quotacheck_running(mp);\n\n\t \n\tif (error)\n\t\tgoto error_purge;\n\n\t \n\tif (XFS_IS_UQUOTA_ON(mp)) {\n\t\terror = xfs_qm_dquot_walk(mp, XFS_DQTYPE_USER, xfs_qm_flush_one,\n\t\t\t\t\t  &buffer_list);\n\t}\n\tif (XFS_IS_GQUOTA_ON(mp)) {\n\t\terror2 = xfs_qm_dquot_walk(mp, XFS_DQTYPE_GROUP, xfs_qm_flush_one,\n\t\t\t\t\t   &buffer_list);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\tif (XFS_IS_PQUOTA_ON(mp)) {\n\t\terror2 = xfs_qm_dquot_walk(mp, XFS_DQTYPE_PROJ, xfs_qm_flush_one,\n\t\t\t\t\t   &buffer_list);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\terror2 = xfs_buf_delwri_submit(&buffer_list);\n\tif (!error)\n\t\terror = error2;\n\n\t \n\tif (error)\n\t\tgoto error_purge;\n\n\t \n\tmp->m_qflags &= ~XFS_ALL_QUOTA_CHKD;\n\tmp->m_qflags |= flags;\n\nerror_return:\n\txfs_buf_delwri_cancel(&buffer_list);\n\n\tif (error) {\n\t\txfs_warn(mp,\n\t\"Quotacheck: Unsuccessful (Error %d): Disabling quotas.\",\n\t\t\terror);\n\t\t \n\t\tASSERT(mp->m_quotainfo != NULL);\n\t\txfs_qm_destroy_quotainfo(mp);\n\t\tif (xfs_mount_reset_sbqflags(mp)) {\n\t\t\txfs_warn(mp,\n\t\t\t\t\"Quotacheck: Failed to reset quota flags.\");\n\t\t}\n\t} else\n\t\txfs_notice(mp, \"Quotacheck: Done.\");\n\treturn error;\n\nerror_purge:\n\t \n\txfs_inodegc_flush(mp);\n\txfs_qm_dqpurge_all(mp);\n\tgoto error_return;\n\n}\n\n \nvoid\nxfs_qm_mount_quotas(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\terror = 0;\n\tuint\t\t\tsbf;\n\n\t \n\tif (mp->m_sb.sb_rextents) {\n\t\txfs_notice(mp, \"Cannot turn on quotas for realtime filesystem\");\n\t\tmp->m_qflags = 0;\n\t\tgoto write_changes;\n\t}\n\n\tASSERT(XFS_IS_QUOTA_ON(mp));\n\n\t \n\terror = xfs_qm_init_quotainfo(mp);\n\tif (error) {\n\t\t \n\t\tASSERT(mp->m_quotainfo == NULL);\n\t\tmp->m_qflags = 0;\n\t\tgoto write_changes;\n\t}\n\t \n\tif (XFS_QM_NEED_QUOTACHECK(mp)) {\n\t\terror = xfs_qm_quotacheck(mp);\n\t\tif (error) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t}\n\t \n\tif (!XFS_IS_UQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_UQUOTA_CHKD;\n\tif (!XFS_IS_GQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_GQUOTA_CHKD;\n\tif (!XFS_IS_PQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_PQUOTA_CHKD;\n\n write_changes:\n\t \n\tspin_lock(&mp->m_sb_lock);\n\tsbf = mp->m_sb.sb_qflags;\n\tmp->m_sb.sb_qflags = mp->m_qflags & XFS_MOUNT_QUOTA_ALL;\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (sbf != (mp->m_qflags & XFS_MOUNT_QUOTA_ALL)) {\n\t\tif (xfs_sync_sb(mp, false)) {\n\t\t\t \n\t\t\tASSERT(!(XFS_IS_QUOTA_ON(mp)));\n\t\t\txfs_alert(mp, \"%s: Superblock update failed!\",\n\t\t\t\t__func__);\n\t\t}\n\t}\n\n\tif (error) {\n\t\txfs_warn(mp, \"Failed to initialize disk quotas.\");\n\t\treturn;\n\t}\n}\n\n \nSTATIC int\nxfs_qm_init_quotainos(\n\txfs_mount_t\t*mp)\n{\n\tstruct xfs_inode\t*uip = NULL;\n\tstruct xfs_inode\t*gip = NULL;\n\tstruct xfs_inode\t*pip = NULL;\n\tint\t\t\terror;\n\tuint\t\t\tflags = 0;\n\n\tASSERT(mp->m_quotainfo);\n\n\t \n\tif (xfs_has_quota(mp)) {\n\t\tif (XFS_IS_UQUOTA_ON(mp) &&\n\t\t    mp->m_sb.sb_uquotino != NULLFSINO) {\n\t\t\tASSERT(mp->m_sb.sb_uquotino > 0);\n\t\t\terror = xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,\n\t\t\t\t\t     0, 0, &uip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif (XFS_IS_GQUOTA_ON(mp) &&\n\t\t    mp->m_sb.sb_gquotino != NULLFSINO) {\n\t\t\tASSERT(mp->m_sb.sb_gquotino > 0);\n\t\t\terror = xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,\n\t\t\t\t\t     0, 0, &gip);\n\t\t\tif (error)\n\t\t\t\tgoto error_rele;\n\t\t}\n\t\tif (XFS_IS_PQUOTA_ON(mp) &&\n\t\t    mp->m_sb.sb_pquotino != NULLFSINO) {\n\t\t\tASSERT(mp->m_sb.sb_pquotino > 0);\n\t\t\terror = xfs_iget(mp, NULL, mp->m_sb.sb_pquotino,\n\t\t\t\t\t     0, 0, &pip);\n\t\t\tif (error)\n\t\t\t\tgoto error_rele;\n\t\t}\n\t} else {\n\t\tflags |= XFS_QMOPT_SBVERSION;\n\t}\n\n\t \n\tif (XFS_IS_UQUOTA_ON(mp) && uip == NULL) {\n\t\terror = xfs_qm_qino_alloc(mp, &uip,\n\t\t\t\t\t      flags | XFS_QMOPT_UQUOTA);\n\t\tif (error)\n\t\t\tgoto error_rele;\n\n\t\tflags &= ~XFS_QMOPT_SBVERSION;\n\t}\n\tif (XFS_IS_GQUOTA_ON(mp) && gip == NULL) {\n\t\terror = xfs_qm_qino_alloc(mp, &gip,\n\t\t\t\t\t  flags | XFS_QMOPT_GQUOTA);\n\t\tif (error)\n\t\t\tgoto error_rele;\n\n\t\tflags &= ~XFS_QMOPT_SBVERSION;\n\t}\n\tif (XFS_IS_PQUOTA_ON(mp) && pip == NULL) {\n\t\terror = xfs_qm_qino_alloc(mp, &pip,\n\t\t\t\t\t  flags | XFS_QMOPT_PQUOTA);\n\t\tif (error)\n\t\t\tgoto error_rele;\n\t}\n\n\tmp->m_quotainfo->qi_uquotaip = uip;\n\tmp->m_quotainfo->qi_gquotaip = gip;\n\tmp->m_quotainfo->qi_pquotaip = pip;\n\n\treturn 0;\n\nerror_rele:\n\tif (uip)\n\t\txfs_irele(uip);\n\tif (gip)\n\t\txfs_irele(gip);\n\tif (pip)\n\t\txfs_irele(pip);\n\treturn error;\n}\n\nSTATIC void\nxfs_qm_destroy_quotainos(\n\tstruct xfs_quotainfo\t*qi)\n{\n\tif (qi->qi_uquotaip) {\n\t\txfs_irele(qi->qi_uquotaip);\n\t\tqi->qi_uquotaip = NULL;  \n\t}\n\tif (qi->qi_gquotaip) {\n\t\txfs_irele(qi->qi_gquotaip);\n\t\tqi->qi_gquotaip = NULL;\n\t}\n\tif (qi->qi_pquotaip) {\n\t\txfs_irele(qi->qi_pquotaip);\n\t\tqi->qi_pquotaip = NULL;\n\t}\n}\n\nSTATIC void\nxfs_qm_dqfree_one(\n\tstruct xfs_dquot\t*dqp)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\n\tmutex_lock(&qi->qi_tree_lock);\n\tradix_tree_delete(xfs_dquot_tree(qi, xfs_dquot_type(dqp)), dqp->q_id);\n\n\tqi->qi_dquots--;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n\txfs_qm_dqdestroy(dqp);\n}\n\n \n\n\n \nint\nxfs_qm_vop_dqalloc(\n\tstruct xfs_inode\t*ip,\n\tkuid_t\t\t\tuid,\n\tkgid_t\t\t\tgid,\n\tprid_t\t\t\tprid,\n\tuint\t\t\tflags,\n\tstruct xfs_dquot\t**O_udqpp,\n\tstruct xfs_dquot\t**O_gdqpp,\n\tstruct xfs_dquot\t**O_pdqpp)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct user_namespace\t*user_ns = inode->i_sb->s_user_ns;\n\tstruct xfs_dquot\t*uq = NULL;\n\tstruct xfs_dquot\t*gq = NULL;\n\tstruct xfs_dquot\t*pq = NULL;\n\tint\t\t\terror;\n\tuint\t\t\tlockflags;\n\n\tif (!XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tlockflags = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lockflags);\n\n\tif ((flags & XFS_QMOPT_INHERIT) && XFS_INHERIT_GID(ip))\n\t\tgid = inode->i_gid;\n\n\t \n\tif (XFS_NOT_DQATTACHED(mp, ip)) {\n\t\terror = xfs_qm_dqattach_locked(ip, true);\n\t\tif (error) {\n\t\t\txfs_iunlock(ip, lockflags);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((flags & XFS_QMOPT_UQUOTA) && XFS_IS_UQUOTA_ON(mp)) {\n\t\tASSERT(O_udqpp);\n\t\tif (!uid_eq(inode->i_uid, uid)) {\n\t\t\t \n\t\t\txfs_iunlock(ip, lockflags);\n\t\t\terror = xfs_qm_dqget(mp, from_kuid(user_ns, uid),\n\t\t\t\t\tXFS_DQTYPE_USER, true, &uq);\n\t\t\tif (error) {\n\t\t\t\tASSERT(error != -ENOENT);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t \n\t\t\txfs_dqunlock(uq);\n\t\t\tlockflags = XFS_ILOCK_SHARED;\n\t\t\txfs_ilock(ip, lockflags);\n\t\t} else {\n\t\t\t \n\t\t\tASSERT(ip->i_udquot);\n\t\t\tuq = xfs_qm_dqhold(ip->i_udquot);\n\t\t}\n\t}\n\tif ((flags & XFS_QMOPT_GQUOTA) && XFS_IS_GQUOTA_ON(mp)) {\n\t\tASSERT(O_gdqpp);\n\t\tif (!gid_eq(inode->i_gid, gid)) {\n\t\t\txfs_iunlock(ip, lockflags);\n\t\t\terror = xfs_qm_dqget(mp, from_kgid(user_ns, gid),\n\t\t\t\t\tXFS_DQTYPE_GROUP, true, &gq);\n\t\t\tif (error) {\n\t\t\t\tASSERT(error != -ENOENT);\n\t\t\t\tgoto error_rele;\n\t\t\t}\n\t\t\txfs_dqunlock(gq);\n\t\t\tlockflags = XFS_ILOCK_SHARED;\n\t\t\txfs_ilock(ip, lockflags);\n\t\t} else {\n\t\t\tASSERT(ip->i_gdquot);\n\t\t\tgq = xfs_qm_dqhold(ip->i_gdquot);\n\t\t}\n\t}\n\tif ((flags & XFS_QMOPT_PQUOTA) && XFS_IS_PQUOTA_ON(mp)) {\n\t\tASSERT(O_pdqpp);\n\t\tif (ip->i_projid != prid) {\n\t\t\txfs_iunlock(ip, lockflags);\n\t\t\terror = xfs_qm_dqget(mp, prid,\n\t\t\t\t\tXFS_DQTYPE_PROJ, true, &pq);\n\t\t\tif (error) {\n\t\t\t\tASSERT(error != -ENOENT);\n\t\t\t\tgoto error_rele;\n\t\t\t}\n\t\t\txfs_dqunlock(pq);\n\t\t\tlockflags = XFS_ILOCK_SHARED;\n\t\t\txfs_ilock(ip, lockflags);\n\t\t} else {\n\t\t\tASSERT(ip->i_pdquot);\n\t\t\tpq = xfs_qm_dqhold(ip->i_pdquot);\n\t\t}\n\t}\n\ttrace_xfs_dquot_dqalloc(ip);\n\n\txfs_iunlock(ip, lockflags);\n\tif (O_udqpp)\n\t\t*O_udqpp = uq;\n\telse\n\t\txfs_qm_dqrele(uq);\n\tif (O_gdqpp)\n\t\t*O_gdqpp = gq;\n\telse\n\t\txfs_qm_dqrele(gq);\n\tif (O_pdqpp)\n\t\t*O_pdqpp = pq;\n\telse\n\t\txfs_qm_dqrele(pq);\n\treturn 0;\n\nerror_rele:\n\txfs_qm_dqrele(gq);\n\txfs_qm_dqrele(uq);\n\treturn error;\n}\n\n \nstruct xfs_dquot *\nxfs_qm_vop_chown(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dquot\t**IO_olddq,\n\tstruct xfs_dquot\t*newdq)\n{\n\tstruct xfs_dquot\t*prevdq;\n\tuint\t\tbfield = XFS_IS_REALTIME_INODE(ip) ?\n\t\t\t\t XFS_TRANS_DQ_RTBCOUNT : XFS_TRANS_DQ_BCOUNT;\n\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(XFS_IS_QUOTA_ON(ip->i_mount));\n\n\t \n\tprevdq = *IO_olddq;\n\tASSERT(prevdq);\n\tASSERT(prevdq != newdq);\n\n\txfs_trans_mod_dquot(tp, prevdq, bfield, -(ip->i_nblocks));\n\txfs_trans_mod_dquot(tp, prevdq, XFS_TRANS_DQ_ICOUNT, -1);\n\n\t \n\txfs_trans_mod_dquot(tp, newdq, bfield, ip->i_nblocks);\n\txfs_trans_mod_dquot(tp, newdq, XFS_TRANS_DQ_ICOUNT, 1);\n\n\t \n\txfs_trans_mod_dquot(tp, newdq, XFS_TRANS_DQ_RES_BLKS,\n\t\t\t-ip->i_delayed_blks);\n\n\t \n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\txfs_dqlock(prevdq);\n\tASSERT(prevdq->q_blk.reserved >= ip->i_delayed_blks);\n\tprevdq->q_blk.reserved -= ip->i_delayed_blks;\n\txfs_dqunlock(prevdq);\n\n\t \n\t*IO_olddq = xfs_qm_dqhold(newdq);\n\n\treturn prevdq;\n}\n\nint\nxfs_qm_vop_rename_dqattach(\n\tstruct xfs_inode\t**i_tab)\n{\n\tstruct xfs_mount\t*mp = i_tab[0]->i_mount;\n\tint\t\t\ti;\n\n\tif (!XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tfor (i = 0; (i < 4 && i_tab[i]); i++) {\n\t\tstruct xfs_inode\t*ip = i_tab[i];\n\t\tint\t\t\terror;\n\n\t\t \n\t\tif (i == 0 || ip != i_tab[i-1]) {\n\t\t\tif (XFS_NOT_DQATTACHED(mp, ip)) {\n\t\t\t\terror = xfs_qm_dqattach(ip);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid\nxfs_qm_vop_create_dqattach(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_ON(mp))\n\t\treturn;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (udqp && XFS_IS_UQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_udquot == NULL);\n\t\tASSERT(i_uid_read(VFS_I(ip)) == udqp->q_id);\n\n\t\tip->i_udquot = xfs_qm_dqhold(udqp);\n\t\txfs_trans_mod_dquot(tp, udqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n\tif (gdqp && XFS_IS_GQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_gdquot == NULL);\n\t\tASSERT(i_gid_read(VFS_I(ip)) == gdqp->q_id);\n\n\t\tip->i_gdquot = xfs_qm_dqhold(gdqp);\n\t\txfs_trans_mod_dquot(tp, gdqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n\tif (pdqp && XFS_IS_PQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_pdquot == NULL);\n\t\tASSERT(ip->i_projid == pdqp->q_id);\n\n\t\tip->i_pdquot = xfs_qm_dqhold(pdqp);\n\t\txfs_trans_mod_dquot(tp, pdqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n}\n\n \nbool\nxfs_inode_near_dquot_enforcement(\n\tstruct xfs_inode\t*ip,\n\txfs_dqtype_t\t\ttype)\n{\n\tstruct xfs_dquot\t*dqp;\n\tint64_t\t\t\tfreesp;\n\n\t \n\tdqp = xfs_inode_dquot(ip, type);\n\tif (!dqp || !xfs_dquot_is_enforced(dqp))\n\t\treturn false;\n\n\tif (xfs_dquot_res_over_limits(&dqp->q_ino) ||\n\t    xfs_dquot_res_over_limits(&dqp->q_rtb))\n\t\treturn true;\n\n\t \n\tif (!dqp->q_prealloc_hi_wmark)\n\t\treturn false;\n\n\tif (dqp->q_blk.reserved < dqp->q_prealloc_lo_wmark)\n\t\treturn false;\n\n\tif (dqp->q_blk.reserved >= dqp->q_prealloc_hi_wmark)\n\t\treturn true;\n\n\tfreesp = dqp->q_prealloc_hi_wmark - dqp->q_blk.reserved;\n\tif (freesp < dqp->q_low_space[XFS_QLOWSP_5_PCNT])\n\t\treturn true;\n\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}