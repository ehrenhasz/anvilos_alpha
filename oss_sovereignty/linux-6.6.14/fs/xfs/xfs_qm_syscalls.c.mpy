{
  "module_name": "xfs_qm_syscalls.c",
  "hash_id": "3dcf3cf2a44b698ca6842c4ea90691386c9c09e5c1798e3871ab81e4cba43e99",
  "original_prompt": "Ingested from linux-6.6.14/fs/xfs/xfs_qm_syscalls.c",
  "human_readable_source": "\n \n\n\n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_icache.h\"\n\nint\nxfs_qm_scall_quotaoff(\n\txfs_mount_t\t\t*mp,\n\tuint\t\t\tflags)\n{\n\t \n\tif ((mp->m_qflags & flags) == 0)\n\t\treturn -EEXIST;\n\n\t \n\tif (flags & XFS_ALL_QUOTA_ACCT)\n\t\txfs_info(mp, \"disabling of quota accounting not supported.\");\n\n\tmutex_lock(&mp->m_quotainfo->qi_quotaofflock);\n\tmp->m_qflags &= ~(flags & XFS_ALL_QUOTA_ENFD);\n\tspin_lock(&mp->m_sb_lock);\n\tmp->m_sb.sb_qflags = mp->m_qflags;\n\tspin_unlock(&mp->m_sb_lock);\n\tmutex_unlock(&mp->m_quotainfo->qi_quotaofflock);\n\n\t \n\treturn xfs_sync_sb(mp, false);\n}\n\nSTATIC int\nxfs_qm_scall_trunc_qfile(\n\tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tino)\n{\n\tstruct xfs_inode\t*ip;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\tif (ino == NULLFSINO)\n\t\treturn 0;\n\n\terror = xfs_iget(mp, NULL, ino, 0, 0, &ip);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_itruncate, 0, 0, 0, &tp);\n\tif (error) {\n\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t\tgoto out_put;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\tip->i_disk_size = 0;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp);\n\t\tgoto out_unlock;\n\t}\n\n\tASSERT(ip->i_df.if_nextents == 0);\n\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\terror = xfs_trans_commit(tp);\n\nout_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL | XFS_IOLOCK_EXCL);\nout_put:\n\txfs_irele(ip);\n\treturn error;\n}\n\nint\nxfs_qm_scall_trunc_qfiles(\n\txfs_mount_t\t*mp,\n\tuint\t\tflags)\n{\n\tint\t\terror = -EINVAL;\n\n\tif (!xfs_has_quota(mp) || flags == 0 ||\n\t    (flags & ~XFS_QMOPT_QUOTALL)) {\n\t\txfs_debug(mp, \"%s: flags=%x m_qflags=%x\",\n\t\t\t__func__, flags, mp->m_qflags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags & XFS_QMOPT_UQUOTA) {\n\t\terror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_uquotino);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (flags & XFS_QMOPT_GQUOTA) {\n\t\terror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_gquotino);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (flags & XFS_QMOPT_PQUOTA)\n\t\terror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_pquotino);\n\n\treturn error;\n}\n\n \nint\nxfs_qm_scall_quotaon(\n\txfs_mount_t\t*mp,\n\tuint\t\tflags)\n{\n\tint\t\terror;\n\tuint\t\tqf;\n\n\t \n\tflags &= XFS_ALL_QUOTA_ENFD;\n\n\tif (flags == 0) {\n\t\txfs_debug(mp, \"%s: zero flags, m_qflags=%x\",\n\t\t\t__func__, mp->m_qflags);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (((mp->m_sb.sb_qflags & XFS_UQUOTA_ACCT) == 0 &&\n\t     (flags & XFS_UQUOTA_ENFD)) ||\n\t    ((mp->m_sb.sb_qflags & XFS_GQUOTA_ACCT) == 0 &&\n\t     (flags & XFS_GQUOTA_ENFD)) ||\n\t    ((mp->m_sb.sb_qflags & XFS_PQUOTA_ACCT) == 0 &&\n\t     (flags & XFS_PQUOTA_ENFD))) {\n\t\txfs_debug(mp,\n\t\t\t\"%s: Can't enforce without acct, flags=%x sbflags=%x\",\n\t\t\t__func__, flags, mp->m_sb.sb_qflags);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif ((mp->m_qflags & flags) == flags)\n\t\treturn -EEXIST;\n\n\t \n\tspin_lock(&mp->m_sb_lock);\n\tqf = mp->m_sb.sb_qflags;\n\tmp->m_sb.sb_qflags = qf | flags;\n\tspin_unlock(&mp->m_sb_lock);\n\n\t \n\tif ((qf & flags) == flags)\n\t\treturn -EEXIST;\n\n\terror = xfs_sync_sb(mp, false);\n\tif (error)\n\t\treturn error;\n\t \n\tif  (((mp->m_sb.sb_qflags & XFS_UQUOTA_ACCT) !=\n\t     (mp->m_qflags & XFS_UQUOTA_ACCT)) ||\n\t     ((mp->m_sb.sb_qflags & XFS_PQUOTA_ACCT) !=\n\t     (mp->m_qflags & XFS_PQUOTA_ACCT)) ||\n\t     ((mp->m_sb.sb_qflags & XFS_GQUOTA_ACCT) !=\n\t     (mp->m_qflags & XFS_GQUOTA_ACCT)))\n\t\treturn 0;\n\n\tif (!XFS_IS_QUOTA_ON(mp))\n\t\treturn -ESRCH;\n\n\t \n\tmutex_lock(&mp->m_quotainfo->qi_quotaofflock);\n\tmp->m_qflags |= (flags & XFS_ALL_QUOTA_ENFD);\n\tmutex_unlock(&mp->m_quotainfo->qi_quotaofflock);\n\n\treturn 0;\n}\n\n#define XFS_QC_MASK (QC_LIMIT_MASK | QC_TIMER_MASK)\n\n \nstatic inline bool\nxfs_setqlim_limits(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot_res\t*res,\n\tstruct xfs_quota_limits\t*qlim,\n\txfs_qcnt_t\t\thard,\n\txfs_qcnt_t\t\tsoft,\n\tconst char\t\t*tag)\n{\n\t \n\tif (hard != 0 && hard < soft) {\n\t\txfs_debug(mp, \"%shard %lld < %ssoft %lld\", tag, hard, tag,\n\t\t\t\tsoft);\n\t\treturn false;\n\t}\n\n\tres->hardlimit = hard;\n\tres->softlimit = soft;\n\tif (qlim) {\n\t\tqlim->hard = hard;\n\t\tqlim->soft = soft;\n\t}\n\n\treturn true;\n}\n\nstatic inline void\nxfs_setqlim_timer(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot_res\t*res,\n\tstruct xfs_quota_limits\t*qlim,\n\ts64\t\t\ttimer)\n{\n\tif (qlim) {\n\t\t \n\t\tres->timer = xfs_dquot_set_grace_period(timer);\n\t\tqlim->time = res->timer;\n\t} else {\n\t\t \n\t\tres->timer = xfs_dquot_set_timeout(mp, timer);\n\t}\n}\n\n \nint\nxfs_qm_scall_setqlim(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\txfs_dqtype_t\t\ttype,\n\tstruct qc_dqblk\t\t*newlim)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_dquot\t*dqp;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_def_quota\t*defq;\n\tstruct xfs_dquot_res\t*res;\n\tstruct xfs_quota_limits\t*qlim;\n\tint\t\t\terror;\n\txfs_qcnt_t\t\thard, soft;\n\n\tif (newlim->d_fieldmask & ~XFS_QC_MASK)\n\t\treturn -EINVAL;\n\tif ((newlim->d_fieldmask & XFS_QC_MASK) == 0)\n\t\treturn 0;\n\n\t \n\terror = xfs_qm_dqget(mp, id, type, true, &dqp);\n\tif (error) {\n\t\tASSERT(error != -ENOENT);\n\t\treturn error;\n\t}\n\n\tdefq = xfs_get_defquota(q, xfs_dquot_type(dqp));\n\txfs_dqunlock(dqp);\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_qm_setqlim, 0, 0, 0, &tp);\n\tif (error)\n\t\tgoto out_rele;\n\n\txfs_dqlock(dqp);\n\txfs_trans_dqjoin(tp, dqp);\n\n\t \n\n\t \n\thard = (newlim->d_fieldmask & QC_SPC_HARD) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_spc_hardlimit) :\n\t\t\tdqp->q_blk.hardlimit;\n\tsoft = (newlim->d_fieldmask & QC_SPC_SOFT) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_spc_softlimit) :\n\t\t\tdqp->q_blk.softlimit;\n\tres = &dqp->q_blk;\n\tqlim = id == 0 ? &defq->blk : NULL;\n\n\tif (xfs_setqlim_limits(mp, res, qlim, hard, soft, \"blk\"))\n\t\txfs_dquot_set_prealloc_limits(dqp);\n\tif (newlim->d_fieldmask & QC_SPC_TIMER)\n\t\txfs_setqlim_timer(mp, res, qlim, newlim->d_spc_timer);\n\n\t \n\thard = (newlim->d_fieldmask & QC_RT_SPC_HARD) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_rt_spc_hardlimit) :\n\t\t\tdqp->q_rtb.hardlimit;\n\tsoft = (newlim->d_fieldmask & QC_RT_SPC_SOFT) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_rt_spc_softlimit) :\n\t\t\tdqp->q_rtb.softlimit;\n\tres = &dqp->q_rtb;\n\tqlim = id == 0 ? &defq->rtb : NULL;\n\n\txfs_setqlim_limits(mp, res, qlim, hard, soft, \"rtb\");\n\tif (newlim->d_fieldmask & QC_RT_SPC_TIMER)\n\t\txfs_setqlim_timer(mp, res, qlim, newlim->d_rt_spc_timer);\n\n\t \n\thard = (newlim->d_fieldmask & QC_INO_HARD) ?\n\t\t(xfs_qcnt_t) newlim->d_ino_hardlimit :\n\t\t\tdqp->q_ino.hardlimit;\n\tsoft = (newlim->d_fieldmask & QC_INO_SOFT) ?\n\t\t(xfs_qcnt_t) newlim->d_ino_softlimit :\n\t\t\tdqp->q_ino.softlimit;\n\tres = &dqp->q_ino;\n\tqlim = id == 0 ? &defq->ino : NULL;\n\n\txfs_setqlim_limits(mp, res, qlim, hard, soft, \"ino\");\n\tif (newlim->d_fieldmask & QC_INO_TIMER)\n\t\txfs_setqlim_timer(mp, res, qlim, newlim->d_ino_timer);\n\n\tif (id != 0) {\n\t\t \n\t\txfs_qm_adjust_dqtimers(dqp);\n\t}\n\tdqp->q_flags |= XFS_DQFLAG_DIRTY;\n\txfs_trans_log_dquot(tp, dqp);\n\n\terror = xfs_trans_commit(tp);\n\nout_rele:\n\txfs_qm_dqrele(dqp);\n\treturn error;\n}\n\n \nstatic void\nxfs_qm_scall_getquota_fill_qc(\n\tstruct xfs_mount\t*mp,\n\txfs_dqtype_t\t\ttype,\n\tconst struct xfs_dquot\t*dqp,\n\tstruct qc_dqblk\t\t*dst)\n{\n\tmemset(dst, 0, sizeof(*dst));\n\tdst->d_spc_hardlimit = XFS_FSB_TO_B(mp, dqp->q_blk.hardlimit);\n\tdst->d_spc_softlimit = XFS_FSB_TO_B(mp, dqp->q_blk.softlimit);\n\tdst->d_ino_hardlimit = dqp->q_ino.hardlimit;\n\tdst->d_ino_softlimit = dqp->q_ino.softlimit;\n\tdst->d_space = XFS_FSB_TO_B(mp, dqp->q_blk.reserved);\n\tdst->d_ino_count = dqp->q_ino.reserved;\n\tdst->d_spc_timer = dqp->q_blk.timer;\n\tdst->d_ino_timer = dqp->q_ino.timer;\n\tdst->d_ino_warns = 0;\n\tdst->d_spc_warns = 0;\n\tdst->d_rt_spc_hardlimit = XFS_FSB_TO_B(mp, dqp->q_rtb.hardlimit);\n\tdst->d_rt_spc_softlimit = XFS_FSB_TO_B(mp, dqp->q_rtb.softlimit);\n\tdst->d_rt_space = XFS_FSB_TO_B(mp, dqp->q_rtb.reserved);\n\tdst->d_rt_spc_timer = dqp->q_rtb.timer;\n\tdst->d_rt_spc_warns = 0;\n\n\t \n\tif (!xfs_dquot_is_enforced(dqp)) {\n\t\tdst->d_spc_timer = 0;\n\t\tdst->d_ino_timer = 0;\n\t\tdst->d_rt_spc_timer = 0;\n\t}\n\n#ifdef DEBUG\n\tif (xfs_dquot_is_enforced(dqp) && dqp->q_id != 0) {\n\t\tif ((dst->d_space > dst->d_spc_softlimit) &&\n\t\t    (dst->d_spc_softlimit > 0)) {\n\t\t\tASSERT(dst->d_spc_timer != 0);\n\t\t}\n\t\tif ((dst->d_ino_count > dqp->q_ino.softlimit) &&\n\t\t    (dqp->q_ino.softlimit > 0)) {\n\t\t\tASSERT(dst->d_ino_timer != 0);\n\t\t}\n\t}\n#endif\n}\n\n \nint\nxfs_qm_scall_getquota(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\txfs_dqtype_t\t\ttype,\n\tstruct qc_dqblk\t\t*dst)\n{\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\t \n\tif (id == 0)\n\t\txfs_inodegc_push(mp);\n\n\t \n\terror = xfs_qm_dqget(mp, id, type, false, &dqp);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (XFS_IS_DQUOT_UNINITIALIZED(dqp)) {\n\t\terror = -ENOENT;\n\t\tgoto out_put;\n\t}\n\n\txfs_qm_scall_getquota_fill_qc(mp, type, dqp, dst);\n\nout_put:\n\txfs_qm_dqput(dqp);\n\treturn error;\n}\n\n \nint\nxfs_qm_scall_getquota_next(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\t*id,\n\txfs_dqtype_t\t\ttype,\n\tstruct qc_dqblk\t\t*dst)\n{\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\t \n\tif (*id == 0)\n\t\txfs_inodegc_push(mp);\n\n\terror = xfs_qm_dqget_next(mp, *id, type, &dqp);\n\tif (error)\n\t\treturn error;\n\n\t \n\t*id = dqp->q_id;\n\n\txfs_qm_scall_getquota_fill_qc(mp, type, dqp, dst);\n\n\txfs_qm_dqput(dqp);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}