{
  "module_name": "splice.c",
  "hash_id": "b5fed0648d3b52a6c69f9801d4d733713440081f048118e167774c75b39025c8",
  "original_prompt": "Ingested from linux-6.6.14/fs/splice.c",
  "human_readable_source": "\n \n#include <linux/bvec.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/splice.h>\n#include <linux/memcontrol.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/uio.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/gfp.h>\n#include <linux/net.h>\n#include <linux/socket.h>\n#include <linux/sched/signal.h>\n\n#include \"internal.h\"\n\n \nstatic noinline void noinline pipe_clear_nowait(struct file *file)\n{\n\tfmode_t fmode = READ_ONCE(file->f_mode);\n\n\tdo {\n\t\tif (!(fmode & FMODE_NOWAIT))\n\t\t\tbreak;\n\t} while (!try_cmpxchg(&file->f_mode, &fmode, fmode & ~FMODE_NOWAIT));\n}\n\n \nstatic bool page_cache_pipe_buf_try_steal(struct pipe_inode_info *pipe,\n\t\tstruct pipe_buffer *buf)\n{\n\tstruct folio *folio = page_folio(buf->page);\n\tstruct address_space *mapping;\n\n\tfolio_lock(folio);\n\n\tmapping = folio_mapping(folio);\n\tif (mapping) {\n\t\tWARN_ON(!folio_test_uptodate(folio));\n\n\t\t \n\t\tfolio_wait_writeback(folio);\n\n\t\tif (!filemap_release_folio(folio, GFP_KERNEL))\n\t\t\tgoto out_unlock;\n\n\t\t \n\t\tif (remove_mapping(mapping, folio)) {\n\t\t\tbuf->flags |= PIPE_BUF_FLAG_LRU;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t \nout_unlock:\n\tfolio_unlock(folio);\n\treturn false;\n}\n\nstatic void page_cache_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t\tstruct pipe_buffer *buf)\n{\n\tput_page(buf->page);\n\tbuf->flags &= ~PIPE_BUF_FLAG_LRU;\n}\n\n \nstatic int page_cache_pipe_buf_confirm(struct pipe_inode_info *pipe,\n\t\t\t\t       struct pipe_buffer *buf)\n{\n\tstruct folio *folio = page_folio(buf->page);\n\tint err;\n\n\tif (!folio_test_uptodate(folio)) {\n\t\tfolio_lock(folio);\n\n\t\t \n\t\tif (!folio->mapping) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif (!folio_test_uptodate(folio)) {\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tfolio_unlock(folio);\n\t}\n\n\treturn 0;\nerror:\n\tfolio_unlock(folio);\n\treturn err;\n}\n\nconst struct pipe_buf_operations page_cache_pipe_buf_ops = {\n\t.confirm\t= page_cache_pipe_buf_confirm,\n\t.release\t= page_cache_pipe_buf_release,\n\t.try_steal\t= page_cache_pipe_buf_try_steal,\n\t.get\t\t= generic_pipe_buf_get,\n};\n\nstatic bool user_page_pipe_buf_try_steal(struct pipe_inode_info *pipe,\n\t\tstruct pipe_buffer *buf)\n{\n\tif (!(buf->flags & PIPE_BUF_FLAG_GIFT))\n\t\treturn false;\n\n\tbuf->flags |= PIPE_BUF_FLAG_LRU;\n\treturn generic_pipe_buf_try_steal(pipe, buf);\n}\n\nstatic const struct pipe_buf_operations user_page_pipe_buf_ops = {\n\t.release\t= page_cache_pipe_buf_release,\n\t.try_steal\t= user_page_pipe_buf_try_steal,\n\t.get\t\t= generic_pipe_buf_get,\n};\n\nstatic void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->rd_wait))\n\t\twake_up_interruptible(&pipe->rd_wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}\n\n \nssize_t splice_to_pipe(struct pipe_inode_info *pipe,\n\t\t       struct splice_pipe_desc *spd)\n{\n\tunsigned int spd_pages = spd->nr_pages;\n\tunsigned int tail = pipe->tail;\n\tunsigned int head = pipe->head;\n\tunsigned int mask = pipe->ring_size - 1;\n\tint ret = 0, page_nr = 0;\n\n\tif (!spd_pages)\n\t\treturn 0;\n\n\tif (unlikely(!pipe->readers)) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\n\twhile (!pipe_full(head, tail, pipe->max_usage)) {\n\t\tstruct pipe_buffer *buf = &pipe->bufs[head & mask];\n\n\t\tbuf->page = spd->pages[page_nr];\n\t\tbuf->offset = spd->partial[page_nr].offset;\n\t\tbuf->len = spd->partial[page_nr].len;\n\t\tbuf->private = spd->partial[page_nr].private;\n\t\tbuf->ops = spd->ops;\n\t\tbuf->flags = 0;\n\n\t\thead++;\n\t\tpipe->head = head;\n\t\tpage_nr++;\n\t\tret += buf->len;\n\n\t\tif (!--spd->nr_pages)\n\t\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tret = -EAGAIN;\n\nout:\n\twhile (page_nr < spd_pages)\n\t\tspd->spd_release(spd, page_nr++);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(splice_to_pipe);\n\nssize_t add_to_pipe(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tunsigned int head = pipe->head;\n\tunsigned int tail = pipe->tail;\n\tunsigned int mask = pipe->ring_size - 1;\n\tint ret;\n\n\tif (unlikely(!pipe->readers)) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tret = -EPIPE;\n\t} else if (pipe_full(head, tail, pipe->max_usage)) {\n\t\tret = -EAGAIN;\n\t} else {\n\t\tpipe->bufs[head & mask] = *buf;\n\t\tpipe->head = head + 1;\n\t\treturn buf->len;\n\t}\n\tpipe_buf_release(pipe, buf);\n\treturn ret;\n}\nEXPORT_SYMBOL(add_to_pipe);\n\n \nint splice_grow_spd(const struct pipe_inode_info *pipe, struct splice_pipe_desc *spd)\n{\n\tunsigned int max_usage = READ_ONCE(pipe->max_usage);\n\n\tspd->nr_pages_max = max_usage;\n\tif (max_usage <= PIPE_DEF_BUFFERS)\n\t\treturn 0;\n\n\tspd->pages = kmalloc_array(max_usage, sizeof(struct page *), GFP_KERNEL);\n\tspd->partial = kmalloc_array(max_usage, sizeof(struct partial_page),\n\t\t\t\t     GFP_KERNEL);\n\n\tif (spd->pages && spd->partial)\n\t\treturn 0;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n\treturn -ENOMEM;\n}\n\nvoid splice_shrink_spd(struct splice_pipe_desc *spd)\n{\n\tif (spd->nr_pages_max <= PIPE_DEF_BUFFERS)\n\t\treturn;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n}\n\n \nssize_t copy_splice_read(struct file *in, loff_t *ppos,\n\t\t\t struct pipe_inode_info *pipe,\n\t\t\t size_t len, unsigned int flags)\n{\n\tstruct iov_iter to;\n\tstruct bio_vec *bv;\n\tstruct kiocb kiocb;\n\tstruct page **pages;\n\tssize_t ret;\n\tsize_t used, npages, chunk, remain, keep = 0;\n\tint i;\n\n\t \n\tused = pipe_occupancy(pipe->head, pipe->tail);\n\tnpages = max_t(ssize_t, pipe->max_usage - used, 0);\n\tlen = min_t(size_t, len, npages * PAGE_SIZE);\n\tnpages = DIV_ROUND_UP(len, PAGE_SIZE);\n\n\tbv = kzalloc(array_size(npages, sizeof(bv[0])) +\n\t\t     array_size(npages, sizeof(struct page *)), GFP_KERNEL);\n\tif (!bv)\n\t\treturn -ENOMEM;\n\n\tpages = (struct page **)(bv + npages);\n\tnpages = alloc_pages_bulk_array(GFP_USER, npages, pages);\n\tif (!npages) {\n\t\tkfree(bv);\n\t\treturn -ENOMEM;\n\t}\n\n\tremain = len = min_t(size_t, len, npages * PAGE_SIZE);\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchunk = min_t(size_t, PAGE_SIZE, remain);\n\t\tbv[i].bv_page = pages[i];\n\t\tbv[i].bv_offset = 0;\n\t\tbv[i].bv_len = chunk;\n\t\tremain -= chunk;\n\t}\n\n\t \n\tiov_iter_bvec(&to, ITER_DEST, bv, npages, len);\n\tinit_sync_kiocb(&kiocb, in);\n\tkiocb.ki_pos = *ppos;\n\tret = call_read_iter(in, &kiocb, &to);\n\n\tif (ret > 0) {\n\t\tkeep = DIV_ROUND_UP(ret, PAGE_SIZE);\n\t\t*ppos = kiocb.ki_pos;\n\t}\n\n\t \n\tif (ret == -EFAULT)\n\t\tret = -EAGAIN;\n\n\t \n\tif (keep < npages)\n\t\trelease_pages(pages + keep, npages - keep);\n\n\t \n\tremain = ret;\n\tfor (i = 0; i < keep; i++) {\n\t\tstruct pipe_buffer *buf = pipe_head_buf(pipe);\n\n\t\tchunk = min_t(size_t, remain, PAGE_SIZE);\n\t\t*buf = (struct pipe_buffer) {\n\t\t\t.ops\t= &default_pipe_buf_ops,\n\t\t\t.page\t= bv[i].bv_page,\n\t\t\t.offset\t= 0,\n\t\t\t.len\t= chunk,\n\t\t};\n\t\tpipe->head++;\n\t\tremain -= chunk;\n\t}\n\n\tkfree(bv);\n\treturn ret;\n}\nEXPORT_SYMBOL(copy_splice_read);\n\nconst struct pipe_buf_operations default_pipe_buf_ops = {\n\t.release\t= generic_pipe_buf_release,\n\t.try_steal\t= generic_pipe_buf_try_steal,\n\t.get\t\t= generic_pipe_buf_get,\n};\n\n \nconst struct pipe_buf_operations nosteal_pipe_buf_ops = {\n\t.release\t= generic_pipe_buf_release,\n\t.get\t\t= generic_pipe_buf_get,\n};\nEXPORT_SYMBOL(nosteal_pipe_buf_ops);\n\nstatic void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wr_wait))\n\t\twake_up_interruptible(&pipe->wr_wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}\n\n \nstatic int splice_from_pipe_feed(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t  splice_actor *actor)\n{\n\tunsigned int head = pipe->head;\n\tunsigned int tail = pipe->tail;\n\tunsigned int mask = pipe->ring_size - 1;\n\tint ret;\n\n\twhile (!pipe_empty(head, tail)) {\n\t\tstruct pipe_buffer *buf = &pipe->bufs[tail & mask];\n\n\t\tsd->len = buf->len;\n\t\tif (sd->len > sd->total_len)\n\t\t\tsd->len = sd->total_len;\n\n\t\tret = pipe_buf_confirm(pipe, buf);\n\t\tif (unlikely(ret)) {\n\t\t\tif (ret == -ENODATA)\n\t\t\t\tret = 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = actor(pipe, buf, sd);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tbuf->offset += ret;\n\t\tbuf->len -= ret;\n\n\t\tsd->num_spliced += ret;\n\t\tsd->len -= ret;\n\t\tsd->pos += ret;\n\t\tsd->total_len -= ret;\n\n\t\tif (!buf->len) {\n\t\t\tpipe_buf_release(pipe, buf);\n\t\t\ttail++;\n\t\t\tpipe->tail = tail;\n\t\t\tif (pipe->files)\n\t\t\t\tsd->need_wakeup = true;\n\t\t}\n\n\t\tif (!sd->total_len)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic inline bool eat_empty_buffer(struct pipe_inode_info *pipe)\n{\n\tunsigned int tail = pipe->tail;\n\tunsigned int mask = pipe->ring_size - 1;\n\tstruct pipe_buffer *buf = &pipe->bufs[tail & mask];\n\n\tif (unlikely(!buf->len)) {\n\t\tpipe_buf_release(pipe, buf);\n\t\tpipe->tail = tail+1;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\t \n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\nrepeat:\n\twhile (pipe_empty(pipe->head, pipe->tail)) {\n\t\tif (!pipe->writers)\n\t\t\treturn 0;\n\n\t\tif (sd->num_spliced)\n\t\t\treturn 0;\n\n\t\tif (sd->flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tif (sd->need_wakeup) {\n\t\t\twakeup_pipe_writers(pipe);\n\t\t\tsd->need_wakeup = false;\n\t\t}\n\n\t\tpipe_wait_readable(pipe);\n\t}\n\n\tif (eat_empty_buffer(pipe))\n\t\tgoto repeat;\n\n\treturn 1;\n}\n\n \nstatic void splice_from_pipe_begin(struct splice_desc *sd)\n{\n\tsd->num_spliced = 0;\n\tsd->need_wakeup = false;\n}\n\n \nstatic void splice_from_pipe_end(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\tif (sd->need_wakeup)\n\t\twakeup_pipe_writers(pipe);\n}\n\n \nssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t   splice_actor *actor)\n{\n\tint ret;\n\n\tsplice_from_pipe_begin(sd);\n\tdo {\n\t\tcond_resched();\n\t\tret = splice_from_pipe_next(pipe, sd);\n\t\tif (ret > 0)\n\t\t\tret = splice_from_pipe_feed(pipe, sd, actor);\n\t} while (ret > 0);\n\tsplice_from_pipe_end(pipe, sd);\n\n\treturn sd->num_spliced ? sd->num_spliced : ret;\n}\nEXPORT_SYMBOL(__splice_from_pipe);\n\n \nssize_t splice_from_pipe(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t loff_t *ppos, size_t len, unsigned int flags,\n\t\t\t splice_actor *actor)\n{\n\tssize_t ret;\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\n\tpipe_lock(pipe);\n\tret = __splice_from_pipe(pipe, &sd, actor);\n\tpipe_unlock(pipe);\n\n\treturn ret;\n}\n\n \nssize_t\niter_file_splice_write(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t  loff_t *ppos, size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\tint nbufs = pipe->max_usage;\n\tstruct bio_vec *array = kcalloc(nbufs, sizeof(struct bio_vec),\n\t\t\t\t\tGFP_KERNEL);\n\tssize_t ret;\n\n\tif (unlikely(!array))\n\t\treturn -ENOMEM;\n\n\tpipe_lock(pipe);\n\n\tsplice_from_pipe_begin(&sd);\n\twhile (sd.total_len) {\n\t\tstruct iov_iter from;\n\t\tunsigned int head, tail, mask;\n\t\tsize_t left;\n\t\tint n;\n\n\t\tret = splice_from_pipe_next(pipe, &sd);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tif (unlikely(nbufs < pipe->max_usage)) {\n\t\t\tkfree(array);\n\t\t\tnbufs = pipe->max_usage;\n\t\t\tarray = kcalloc(nbufs, sizeof(struct bio_vec),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!array) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\thead = pipe->head;\n\t\ttail = pipe->tail;\n\t\tmask = pipe->ring_size - 1;\n\n\t\t \n\t\tleft = sd.total_len;\n\t\tfor (n = 0; !pipe_empty(head, tail) && left && n < nbufs; tail++) {\n\t\t\tstruct pipe_buffer *buf = &pipe->bufs[tail & mask];\n\t\t\tsize_t this_len = buf->len;\n\n\t\t\t \n\t\t\tif (!this_len)\n\t\t\t\tcontinue;\n\t\t\tthis_len = min(this_len, left);\n\n\t\t\tret = pipe_buf_confirm(pipe, buf);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\tif (ret == -ENODATA)\n\t\t\t\t\tret = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tbvec_set_page(&array[n], buf->page, this_len,\n\t\t\t\t      buf->offset);\n\t\t\tleft -= this_len;\n\t\t\tn++;\n\t\t}\n\n\t\tiov_iter_bvec(&from, ITER_SOURCE, array, n, sd.total_len - left);\n\t\tret = vfs_iter_write(out, &from, &sd.pos, 0);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tsd.num_spliced += ret;\n\t\tsd.total_len -= ret;\n\t\t*ppos = sd.pos;\n\n\t\t \n\t\ttail = pipe->tail;\n\t\twhile (ret) {\n\t\t\tstruct pipe_buffer *buf = &pipe->bufs[tail & mask];\n\t\t\tif (ret >= buf->len) {\n\t\t\t\tret -= buf->len;\n\t\t\t\tbuf->len = 0;\n\t\t\t\tpipe_buf_release(pipe, buf);\n\t\t\t\ttail++;\n\t\t\t\tpipe->tail = tail;\n\t\t\t\tif (pipe->files)\n\t\t\t\t\tsd.need_wakeup = true;\n\t\t\t} else {\n\t\t\t\tbuf->offset += ret;\n\t\t\t\tbuf->len -= ret;\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tkfree(array);\n\tsplice_from_pipe_end(pipe, &sd);\n\n\tpipe_unlock(pipe);\n\n\tif (sd.num_spliced)\n\t\tret = sd.num_spliced;\n\n\treturn ret;\n}\n\nEXPORT_SYMBOL(iter_file_splice_write);\n\n#ifdef CONFIG_NET\n \nssize_t splice_to_socket(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t loff_t *ppos, size_t len, unsigned int flags)\n{\n\tstruct socket *sock = sock_from_file(out);\n\tstruct bio_vec bvec[16];\n\tstruct msghdr msg = {};\n\tssize_t ret = 0;\n\tsize_t spliced = 0;\n\tbool need_wakeup = false;\n\n\tpipe_lock(pipe);\n\n\twhile (len > 0) {\n\t\tunsigned int head, tail, mask, bc = 0;\n\t\tsize_t remain = len;\n\n\t\t \n\t\tret = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\twhile (pipe_empty(pipe->head, pipe->tail)) {\n\t\t\tret = 0;\n\t\t\tif (!pipe->writers)\n\t\t\t\tgoto out;\n\n\t\t\tif (spliced)\n\t\t\t\tgoto out;\n\n\t\t\tret = -EAGAIN;\n\t\t\tif (flags & SPLICE_F_NONBLOCK)\n\t\t\t\tgoto out;\n\n\t\t\tret = -ERESTARTSYS;\n\t\t\tif (signal_pending(current))\n\t\t\t\tgoto out;\n\n\t\t\tif (need_wakeup) {\n\t\t\t\twakeup_pipe_writers(pipe);\n\t\t\t\tneed_wakeup = false;\n\t\t\t}\n\n\t\t\tpipe_wait_readable(pipe);\n\t\t}\n\n\t\thead = pipe->head;\n\t\ttail = pipe->tail;\n\t\tmask = pipe->ring_size - 1;\n\n\t\twhile (!pipe_empty(head, tail)) {\n\t\t\tstruct pipe_buffer *buf = &pipe->bufs[tail & mask];\n\t\t\tsize_t seg;\n\n\t\t\tif (!buf->len) {\n\t\t\t\ttail++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tseg = min_t(size_t, remain, buf->len);\n\n\t\t\tret = pipe_buf_confirm(pipe, buf);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\tif (ret == -ENODATA)\n\t\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbvec_set_page(&bvec[bc++], buf->page, seg, buf->offset);\n\t\t\tremain -= seg;\n\t\t\tif (remain == 0 || bc >= ARRAY_SIZE(bvec))\n\t\t\t\tbreak;\n\t\t\ttail++;\n\t\t}\n\n\t\tif (!bc)\n\t\t\tbreak;\n\n\t\tmsg.msg_flags = MSG_SPLICE_PAGES;\n\t\tif (flags & SPLICE_F_MORE)\n\t\t\tmsg.msg_flags |= MSG_MORE;\n\t\tif (remain && pipe_occupancy(pipe->head, tail) > 0)\n\t\t\tmsg.msg_flags |= MSG_MORE;\n\t\tif (out->f_flags & O_NONBLOCK)\n\t\t\tmsg.msg_flags |= MSG_DONTWAIT;\n\n\t\tiov_iter_bvec(&msg.msg_iter, ITER_SOURCE, bvec, bc,\n\t\t\t      len - remain);\n\t\tret = sock_sendmsg(sock, &msg);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tspliced += ret;\n\t\tlen -= ret;\n\t\ttail = pipe->tail;\n\t\twhile (ret > 0) {\n\t\t\tstruct pipe_buffer *buf = &pipe->bufs[tail & mask];\n\t\t\tsize_t seg = min_t(size_t, ret, buf->len);\n\n\t\t\tbuf->offset += seg;\n\t\t\tbuf->len -= seg;\n\t\t\tret -= seg;\n\n\t\t\tif (!buf->len) {\n\t\t\t\tpipe_buf_release(pipe, buf);\n\t\t\t\ttail++;\n\t\t\t}\n\t\t}\n\n\t\tif (tail != pipe->tail) {\n\t\t\tpipe->tail = tail;\n\t\t\tif (pipe->files)\n\t\t\t\tneed_wakeup = true;\n\t\t}\n\t}\n\nout:\n\tpipe_unlock(pipe);\n\tif (need_wakeup)\n\t\twakeup_pipe_writers(pipe);\n\treturn spliced ?: ret;\n}\n#endif\n\nstatic int warn_unsupported(struct file *file, const char *op)\n{\n\tpr_debug_ratelimited(\n\t\t\"splice %s not supported for file %pD4 (pid: %d comm: %.20s)\\n\",\n\t\top, file, current->pid, current->comm);\n\treturn -EINVAL;\n}\n\n \nstatic long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n{\n\tif (unlikely(!out->f_op->splice_write))\n\t\treturn warn_unsupported(out, \"write\");\n\treturn out->f_op->splice_write(pipe, out, ppos, len, flags);\n}\n\n \nstatic void do_splice_eof(struct splice_desc *sd)\n{\n\tif (sd->splice_eof)\n\t\tsd->splice_eof(sd);\n}\n\n \nlong vfs_splice_read(struct file *in, loff_t *ppos,\n\t\t     struct pipe_inode_info *pipe, size_t len,\n\t\t     unsigned int flags)\n{\n\tunsigned int p_space;\n\tint ret;\n\n\tif (unlikely(!(in->f_mode & FMODE_READ)))\n\t\treturn -EBADF;\n\tif (!len)\n\t\treturn 0;\n\n\t \n\tp_space = pipe->max_usage - pipe_occupancy(pipe->head, pipe->tail);\n\tlen = min_t(size_t, len, p_space << PAGE_SHIFT);\n\n\tret = rw_verify_area(READ, in, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tif (unlikely(len > MAX_RW_COUNT))\n\t\tlen = MAX_RW_COUNT;\n\n\tif (unlikely(!in->f_op->splice_read))\n\t\treturn warn_unsupported(in, \"read\");\n\t \n\tif ((in->f_flags & O_DIRECT) || IS_DAX(in->f_mapping->host))\n\t\treturn copy_splice_read(in, ppos, pipe, len, flags);\n\treturn in->f_op->splice_read(in, ppos, pipe, len, flags);\n}\nEXPORT_SYMBOL_GPL(vfs_splice_read);\n\n \nssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,\n\t\t\t       splice_direct_actor *actor)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret, bytes;\n\tsize_t len;\n\tint i, flags, more;\n\n\t \n\tif (unlikely(!(in->f_mode & FMODE_LSEEK)))\n\t\treturn -EINVAL;\n\n\t \n\tpipe = current->splice_pipe;\n\tif (unlikely(!pipe)) {\n\t\tpipe = alloc_pipe_info();\n\t\tif (!pipe)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tpipe->readers = 1;\n\n\t\tcurrent->splice_pipe = pipe;\n\t}\n\n\t \n\tbytes = 0;\n\tlen = sd->total_len;\n\n\t \n\tflags = sd->flags;\n\tsd->flags &= ~SPLICE_F_NONBLOCK;\n\n\t \n\tmore = sd->flags & SPLICE_F_MORE;\n\tsd->flags |= SPLICE_F_MORE;\n\n\tWARN_ON_ONCE(!pipe_empty(pipe->head, pipe->tail));\n\n\twhile (len) {\n\t\tsize_t read_len;\n\t\tloff_t pos = sd->pos, prev_pos = pos;\n\n\t\tret = vfs_splice_read(in, &pos, pipe, len, flags);\n\t\tif (unlikely(ret <= 0))\n\t\t\tgoto read_failure;\n\n\t\tread_len = ret;\n\t\tsd->total_len = read_len;\n\n\t\t \n\t\tif (read_len >= len && !more)\n\t\t\tsd->flags &= ~SPLICE_F_MORE;\n\n\t\t \n\t\tret = actor(pipe, sd);\n\t\tif (unlikely(ret <= 0)) {\n\t\t\tsd->pos = prev_pos;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tbytes += ret;\n\t\tlen -= ret;\n\t\tsd->pos = pos;\n\n\t\tif (ret < read_len) {\n\t\t\tsd->pos = prev_pos + ret;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\ndone:\n\tpipe->tail = pipe->head = 0;\n\tfile_accessed(in);\n\treturn bytes;\n\nread_failure:\n\t \n\tif (ret == 0 && !more && len > 0 && bytes)\n\t\tdo_splice_eof(sd);\nout_release:\n\t \n\tfor (i = 0; i < pipe->ring_size; i++) {\n\t\tstruct pipe_buffer *buf = &pipe->bufs[i];\n\n\t\tif (buf->ops)\n\t\t\tpipe_buf_release(pipe, buf);\n\t}\n\n\tif (!bytes)\n\t\tbytes = ret;\n\n\tgoto done;\n}\nEXPORT_SYMBOL(splice_direct_to_actor);\n\nstatic int direct_splice_actor(struct pipe_inode_info *pipe,\n\t\t\t       struct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\n\treturn do_splice_from(pipe, file, sd->opos, sd->total_len,\n\t\t\t      sd->flags);\n}\n\nstatic void direct_file_splice_eof(struct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\n\tif (file->f_op->splice_eof)\n\t\tfile->f_op->splice_eof(file);\n}\n\n \nlong do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\n\t\t      loff_t *opos, size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= len,\n\t\t.total_len\t= len,\n\t\t.flags\t\t= flags,\n\t\t.pos\t\t= *ppos,\n\t\t.u.file\t\t= out,\n\t\t.splice_eof\t= direct_file_splice_eof,\n\t\t.opos\t\t= opos,\n\t};\n\tlong ret;\n\n\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\n\tif (unlikely(out->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tret = rw_verify_area(WRITE, out, opos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tret = splice_direct_to_actor(in, &sd, direct_splice_actor);\n\tif (ret > 0)\n\t\t*ppos = sd.pos;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(do_splice_direct);\n\nstatic int wait_for_space(struct pipe_inode_info *pipe, unsigned flags)\n{\n\tfor (;;) {\n\t\tif (unlikely(!pipe->readers)) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\treturn -EPIPE;\n\t\t}\n\t\tif (!pipe_full(pipe->head, pipe->tail, pipe->max_usage))\n\t\t\treturn 0;\n\t\tif (flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\t\tpipe_wait_writable(pipe);\n\t}\n}\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nlong splice_file_to_pipe(struct file *in,\n\t\t\t struct pipe_inode_info *opipe,\n\t\t\t loff_t *offset,\n\t\t\t size_t len, unsigned int flags)\n{\n\tlong ret;\n\n\tpipe_lock(opipe);\n\tret = wait_for_space(opipe, flags);\n\tif (!ret)\n\t\tret = vfs_splice_read(in, offset, opipe, len, flags);\n\tpipe_unlock(opipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\treturn ret;\n}\n\n \nlong do_splice(struct file *in, loff_t *off_in, struct file *out,\n\t       loff_t *off_out, size_t len, unsigned int flags)\n{\n\tstruct pipe_inode_info *ipipe;\n\tstruct pipe_inode_info *opipe;\n\tloff_t offset;\n\tlong ret;\n\n\tif (unlikely(!(in->f_mode & FMODE_READ) ||\n\t\t     !(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\n\tipipe = get_pipe_info(in, true);\n\topipe = get_pipe_info(out, true);\n\n\tif (ipipe && opipe) {\n\t\tif (off_in || off_out)\n\t\t\treturn -ESPIPE;\n\n\t\t \n\t\tif (ipipe == opipe)\n\t\t\treturn -EINVAL;\n\n\t\tif ((in->f_flags | out->f_flags) & O_NONBLOCK)\n\t\t\tflags |= SPLICE_F_NONBLOCK;\n\n\t\tret = splice_pipe_to_pipe(ipipe, opipe, len, flags);\n\t} else if (ipipe) {\n\t\tif (off_in)\n\t\t\treturn -ESPIPE;\n\t\tif (off_out) {\n\t\t\tif (!(out->f_mode & FMODE_PWRITE))\n\t\t\t\treturn -EINVAL;\n\t\t\toffset = *off_out;\n\t\t} else {\n\t\t\toffset = out->f_pos;\n\t\t}\n\n\t\tif (unlikely(out->f_flags & O_APPEND))\n\t\t\treturn -EINVAL;\n\n\t\tret = rw_verify_area(WRITE, out, &offset, len);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\n\t\tif (in->f_flags & O_NONBLOCK)\n\t\t\tflags |= SPLICE_F_NONBLOCK;\n\n\t\tfile_start_write(out);\n\t\tret = do_splice_from(ipipe, out, &offset, len, flags);\n\t\tfile_end_write(out);\n\n\t\tif (!off_out)\n\t\t\tout->f_pos = offset;\n\t\telse\n\t\t\t*off_out = offset;\n\t} else if (opipe) {\n\t\tif (off_out)\n\t\t\treturn -ESPIPE;\n\t\tif (off_in) {\n\t\t\tif (!(in->f_mode & FMODE_PREAD))\n\t\t\t\treturn -EINVAL;\n\t\t\toffset = *off_in;\n\t\t} else {\n\t\t\toffset = in->f_pos;\n\t\t}\n\n\t\tif (out->f_flags & O_NONBLOCK)\n\t\t\tflags |= SPLICE_F_NONBLOCK;\n\n\t\tret = splice_file_to_pipe(in, opipe, &offset, len, flags);\n\n\t\tif (!off_in)\n\t\t\tin->f_pos = offset;\n\t\telse\n\t\t\t*off_in = offset;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret > 0) {\n\t\t \n\t\tfsnotify_modify(out);\n\t\tfsnotify_access(in);\n\t}\n\n\treturn ret;\n}\n\nstatic long __do_splice(struct file *in, loff_t __user *off_in,\n\t\t\tstruct file *out, loff_t __user *off_out,\n\t\t\tsize_t len, unsigned int flags)\n{\n\tstruct pipe_inode_info *ipipe;\n\tstruct pipe_inode_info *opipe;\n\tloff_t offset, *__off_in = NULL, *__off_out = NULL;\n\tlong ret;\n\n\tipipe = get_pipe_info(in, true);\n\topipe = get_pipe_info(out, true);\n\n\tif (ipipe) {\n\t\tif (off_in)\n\t\t\treturn -ESPIPE;\n\t\tpipe_clear_nowait(in);\n\t}\n\tif (opipe) {\n\t\tif (off_out)\n\t\t\treturn -ESPIPE;\n\t\tpipe_clear_nowait(out);\n\t}\n\n\tif (off_out) {\n\t\tif (copy_from_user(&offset, off_out, sizeof(loff_t)))\n\t\t\treturn -EFAULT;\n\t\t__off_out = &offset;\n\t}\n\tif (off_in) {\n\t\tif (copy_from_user(&offset, off_in, sizeof(loff_t)))\n\t\t\treturn -EFAULT;\n\t\t__off_in = &offset;\n\t}\n\n\tret = do_splice(in, __off_in, out, __off_out, len, flags);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (__off_out && copy_to_user(off_out, __off_out, sizeof(loff_t)))\n\t\treturn -EFAULT;\n\tif (__off_in && copy_to_user(off_in, __off_in, sizeof(loff_t)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\nstatic int iter_to_pipe(struct iov_iter *from,\n\t\t\tstruct pipe_inode_info *pipe,\n\t\t\tunsigned flags)\n{\n\tstruct pipe_buffer buf = {\n\t\t.ops = &user_page_pipe_buf_ops,\n\t\t.flags = flags\n\t};\n\tsize_t total = 0;\n\tint ret = 0;\n\n\twhile (iov_iter_count(from)) {\n\t\tstruct page *pages[16];\n\t\tssize_t left;\n\t\tsize_t start;\n\t\tint i, n;\n\n\t\tleft = iov_iter_get_pages2(from, pages, ~0UL, 16, &start);\n\t\tif (left <= 0) {\n\t\t\tret = left;\n\t\t\tbreak;\n\t\t}\n\n\t\tn = DIV_ROUND_UP(left + start, PAGE_SIZE);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tint size = min_t(int, left, PAGE_SIZE - start);\n\n\t\t\tbuf.page = pages[i];\n\t\t\tbuf.offset = start;\n\t\t\tbuf.len = size;\n\t\t\tret = add_to_pipe(pipe, &buf);\n\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\tiov_iter_revert(from, left);\n\t\t\t\t\n\t\t\t\twhile (++i < n)\n\t\t\t\t\tput_page(pages[i]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttotal += ret;\n\t\t\tleft -= size;\n\t\t\tstart = 0;\n\t\t}\n\t}\nout:\n\treturn total ? total : ret;\n}\n\nstatic int pipe_to_user(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n\t\t\tstruct splice_desc *sd)\n{\n\tint n = copy_page_to_iter(buf->page, buf->offset, sd->len, sd->u.data);\n\treturn n == sd->len ? n : -EFAULT;\n}\n\n \nstatic long vmsplice_to_user(struct file *file, struct iov_iter *iter,\n\t\t\t     unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe = get_pipe_info(file, true);\n\tstruct splice_desc sd = {\n\t\t.total_len = iov_iter_count(iter),\n\t\t.flags = flags,\n\t\t.u.data = iter\n\t};\n\tlong ret = 0;\n\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tpipe_clear_nowait(file);\n\n\tif (sd.total_len) {\n\t\tpipe_lock(pipe);\n\t\tret = __splice_from_pipe(pipe, &sd, pipe_to_user);\n\t\tpipe_unlock(pipe);\n\t}\n\n\tif (ret > 0)\n\t\tfsnotify_access(file);\n\n\treturn ret;\n}\n\n \nstatic long vmsplice_to_pipe(struct file *file, struct iov_iter *iter,\n\t\t\t     unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret = 0;\n\tunsigned buf_flag = 0;\n\n\tif (flags & SPLICE_F_GIFT)\n\t\tbuf_flag = PIPE_BUF_FLAG_GIFT;\n\n\tpipe = get_pipe_info(file, true);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tpipe_clear_nowait(file);\n\n\tpipe_lock(pipe);\n\tret = wait_for_space(pipe, flags);\n\tif (!ret)\n\t\tret = iter_to_pipe(iter, pipe, buf_flag);\n\tpipe_unlock(pipe);\n\tif (ret > 0) {\n\t\twakeup_pipe_readers(pipe);\n\t\tfsnotify_modify(file);\n\t}\n\treturn ret;\n}\n\nstatic int vmsplice_type(struct fd f, int *type)\n{\n\tif (!f.file)\n\t\treturn -EBADF;\n\tif (f.file->f_mode & FMODE_WRITE) {\n\t\t*type = ITER_SOURCE;\n\t} else if (f.file->f_mode & FMODE_READ) {\n\t\t*type = ITER_DEST;\n\t} else {\n\t\tfdput(f);\n\t\treturn -EBADF;\n\t}\n\treturn 0;\n}\n\n \nSYSCALL_DEFINE4(vmsplice, int, fd, const struct iovec __user *, uiov,\n\t\tunsigned long, nr_segs, unsigned int, flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t error;\n\tstruct fd f;\n\tint type;\n\n\tif (unlikely(flags & ~SPLICE_F_ALL))\n\t\treturn -EINVAL;\n\n\tf = fdget(fd);\n\terror = vmsplice_type(f, &type);\n\tif (error)\n\t\treturn error;\n\n\terror = import_iovec(type, uiov, nr_segs,\n\t\t\t     ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (error < 0)\n\t\tgoto out_fdput;\n\n\tif (!iov_iter_count(&iter))\n\t\terror = 0;\n\telse if (type == ITER_SOURCE)\n\t\terror = vmsplice_to_pipe(f.file, &iter, flags);\n\telse\n\t\terror = vmsplice_to_user(f.file, &iter, flags);\n\n\tkfree(iov);\nout_fdput:\n\tfdput(f);\n\treturn error;\n}\n\nSYSCALL_DEFINE6(splice, int, fd_in, loff_t __user *, off_in,\n\t\tint, fd_out, loff_t __user *, off_out,\n\t\tsize_t, len, unsigned int, flags)\n{\n\tstruct fd in, out;\n\tlong error;\n\n\tif (unlikely(!len))\n\t\treturn 0;\n\n\tif (unlikely(flags & ~SPLICE_F_ALL))\n\t\treturn -EINVAL;\n\n\terror = -EBADF;\n\tin = fdget(fd_in);\n\tif (in.file) {\n\t\tout = fdget(fd_out);\n\t\tif (out.file) {\n\t\t\terror = __do_splice(in.file, off_in, out.file, off_out,\n\t\t\t\t\t\tlen, flags);\n\t\t\tfdput(out);\n\t\t}\n\t\tfdput(in);\n\t}\n\treturn error;\n}\n\n \nstatic int ipipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t \n\tif (!pipe_empty(pipe->head, pipe->tail))\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (pipe_empty(pipe->head, pipe->tail)) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (!pipe->writers)\n\t\t\tbreak;\n\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tpipe_wait_readable(pipe);\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}\n\n \nstatic int opipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t \n\tif (!pipe_full(pipe->head, pipe->tail, pipe->max_usage))\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (pipe_full(pipe->head, pipe->tail, pipe->max_usage)) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tpipe_wait_writable(pipe);\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}\n\n \nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tunsigned int i_head, o_head;\n\tunsigned int i_tail, o_tail;\n\tunsigned int i_mask, o_mask;\n\tint ret = 0;\n\tbool input_wakeup = false;\n\n\nretry:\n\tret = ipipe_prep(ipipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = opipe_prep(opipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpipe_double_lock(ipipe, opipe);\n\n\ti_tail = ipipe->tail;\n\ti_mask = ipipe->ring_size - 1;\n\to_head = opipe->head;\n\to_mask = opipe->ring_size - 1;\n\n\tdo {\n\t\tsize_t o_len;\n\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\ti_head = ipipe->head;\n\t\to_tail = opipe->tail;\n\n\t\tif (pipe_empty(i_head, i_tail) && !ipipe->writers)\n\t\t\tbreak;\n\n\t\t \n\t\tif (pipe_empty(i_head, i_tail) ||\n\t\t    pipe_full(o_head, o_tail, opipe->max_usage)) {\n\t\t\t \n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tpipe_unlock(ipipe);\n\t\t\tpipe_unlock(opipe);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tibuf = &ipipe->bufs[i_tail & i_mask];\n\t\tobuf = &opipe->bufs[o_head & o_mask];\n\n\t\tif (len >= ibuf->len) {\n\t\t\t \n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\ti_tail++;\n\t\t\tipipe->tail = i_tail;\n\t\t\tinput_wakeup = true;\n\t\t\to_len = obuf->len;\n\t\t\to_head++;\n\t\t\topipe->head = o_head;\n\t\t} else {\n\t\t\t \n\t\t\tif (!pipe_buf_get(ipipe, ibuf)) {\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*obuf = *ibuf;\n\n\t\t\t \n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_CAN_MERGE;\n\n\t\t\tobuf->len = len;\n\t\t\tibuf->offset += len;\n\t\t\tibuf->len -= len;\n\t\t\to_len = len;\n\t\t\to_head++;\n\t\t\topipe->head = o_head;\n\t\t}\n\t\tret += o_len;\n\t\tlen -= o_len;\n\t} while (len);\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t \n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\tif (input_wakeup)\n\t\twakeup_pipe_writers(ipipe);\n\n\treturn ret;\n}\n\n \nstatic int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tunsigned int i_head, o_head;\n\tunsigned int i_tail, o_tail;\n\tunsigned int i_mask, o_mask;\n\tint ret = 0;\n\n\t \n\tpipe_double_lock(ipipe, opipe);\n\n\ti_tail = ipipe->tail;\n\ti_mask = ipipe->ring_size - 1;\n\to_head = opipe->head;\n\to_mask = opipe->ring_size - 1;\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\ti_head = ipipe->head;\n\t\to_tail = opipe->tail;\n\n\t\t \n\t\tif (pipe_empty(i_head, i_tail) ||\n\t\t    pipe_full(o_head, o_tail, opipe->max_usage))\n\t\t\tbreak;\n\n\t\tibuf = &ipipe->bufs[i_tail & i_mask];\n\t\tobuf = &opipe->bufs[o_head & o_mask];\n\n\t\t \n\t\tif (!pipe_buf_get(ipipe, ibuf)) {\n\t\t\tif (ret == 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\t*obuf = *ibuf;\n\n\t\t \n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_CAN_MERGE;\n\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\n\t\to_head++;\n\t\topipe->head = o_head;\n\t\ti_tail++;\n\t} while (len);\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t \n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\treturn ret;\n}\n\n \nlong do_tee(struct file *in, struct file *out, size_t len, unsigned int flags)\n{\n\tstruct pipe_inode_info *ipipe = get_pipe_info(in, true);\n\tstruct pipe_inode_info *opipe = get_pipe_info(out, true);\n\tint ret = -EINVAL;\n\n\tif (unlikely(!(in->f_mode & FMODE_READ) ||\n\t\t     !(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\n\t \n\tif (ipipe && opipe && ipipe != opipe) {\n\t\tif ((in->f_flags | out->f_flags) & O_NONBLOCK)\n\t\t\tflags |= SPLICE_F_NONBLOCK;\n\n\t\t \n\t\tret = ipipe_prep(ipipe, flags);\n\t\tif (!ret) {\n\t\t\tret = opipe_prep(opipe, flags);\n\t\t\tif (!ret)\n\t\t\t\tret = link_pipe(ipipe, opipe, len, flags);\n\t\t}\n\t}\n\n\tif (ret > 0) {\n\t\tfsnotify_access(in);\n\t\tfsnotify_modify(out);\n\t}\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE4(tee, int, fdin, int, fdout, size_t, len, unsigned int, flags)\n{\n\tstruct fd in, out;\n\tint error;\n\n\tif (unlikely(flags & ~SPLICE_F_ALL))\n\t\treturn -EINVAL;\n\n\tif (unlikely(!len))\n\t\treturn 0;\n\n\terror = -EBADF;\n\tin = fdget(fdin);\n\tif (in.file) {\n\t\tout = fdget(fdout);\n\t\tif (out.file) {\n\t\t\terror = do_tee(in.file, out.file, len, flags);\n\t\t\tfdput(out);\n\t\t}\n \t\tfdput(in);\n \t}\n\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}