{
  "module_name": "nfsacl.c",
  "hash_id": "857395cff0fa4b7ec865f862bd45fedea13fcf640ccf9e7eef594b4e28cfccdd",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs_common/nfsacl.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfsacl.h>\n#include <linux/nfs3.h>\n#include <linux/sort.h>\n\nMODULE_LICENSE(\"GPL\");\n\nstruct nfsacl_encode_desc {\n\tstruct xdr_array2_desc desc;\n\tunsigned int count;\n\tstruct posix_acl *acl;\n\tint typeflag;\n\tkuid_t uid;\n\tkgid_t gid;\n};\n\nstruct nfsacl_simple_acl {\n\tstruct posix_acl acl;\n\tstruct posix_acl_entry ace[4];\n};\n\nstatic int\nxdr_nfsace_encode(struct xdr_array2_desc *desc, void *elem)\n{\n\tstruct nfsacl_encode_desc *nfsacl_desc =\n\t\t(struct nfsacl_encode_desc *) desc;\n\t__be32 *p = elem;\n\n\tstruct posix_acl_entry *entry =\n\t\t&nfsacl_desc->acl->a_entries[nfsacl_desc->count++];\n\n\t*p++ = htonl(entry->e_tag | nfsacl_desc->typeflag);\n\tswitch(entry->e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\t\t*p++ = htonl(from_kuid(&init_user_ns, nfsacl_desc->uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP_OBJ:\n\t\t\t*p++ = htonl(from_kgid(&init_user_ns, nfsacl_desc->gid));\n\t\t\tbreak;\n\t\tcase ACL_USER:\n\t\t\t*p++ = htonl(from_kuid(&init_user_ns, entry->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\t*p++ = htonl(from_kgid(&init_user_ns, entry->e_gid));\n\t\t\tbreak;\n\t\tdefault:   \n\t\t\t*p++ = 0;\n\t\t\tbreak;\n\t}\n\t*p++ = htonl(entry->e_perm & S_IRWXO);\n\treturn 0;\n}\n\n \nint nfsacl_encode(struct xdr_buf *buf, unsigned int base, struct inode *inode,\n\t\t  struct posix_acl *acl, int encode_entries, int typeflag)\n{\n\tint entries = (acl && acl->a_count) ? max_t(int, acl->a_count, 4) : 0;\n\tstruct nfsacl_encode_desc nfsacl_desc = {\n\t\t.desc = {\n\t\t\t.elem_size = 12,\n\t\t\t.array_len = encode_entries ? entries : 0,\n\t\t\t.xcode = xdr_nfsace_encode,\n\t\t},\n\t\t.acl = acl,\n\t\t.typeflag = typeflag,\n\t\t.uid = inode->i_uid,\n\t\t.gid = inode->i_gid,\n\t};\n\tstruct nfsacl_simple_acl aclbuf;\n\tint err;\n\n\tif (entries > NFS_ACL_MAX_ENTRIES ||\n\t    xdr_encode_word(buf, base, entries))\n\t\treturn -EINVAL;\n\tif (encode_entries && acl && acl->a_count == 3) {\n\t\tstruct posix_acl *acl2 = &aclbuf.acl;\n\n\t\t \n\t\tposix_acl_init(acl2, 4);\n\n\t\t \n\t\tacl2->a_entries[0] = acl->a_entries[0];   \n\t\tacl2->a_entries[1] = acl->a_entries[1];   \n\t\tacl2->a_entries[2] = acl->a_entries[1];   \n\t\tacl2->a_entries[2].e_tag = ACL_MASK;\n\t\tacl2->a_entries[3] = acl->a_entries[2];   \n\t\tnfsacl_desc.acl = acl2;\n\t}\n\terr = xdr_encode_array2(buf, base + 4, &nfsacl_desc.desc);\n\tif (!err)\n\t\terr = 8 + nfsacl_desc.desc.elem_size *\n\t\t\t  nfsacl_desc.desc.array_len;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nfsacl_encode);\n\n \nbool nfs_stream_encode_acl(struct xdr_stream *xdr, struct inode *inode,\n\t\t\t   struct posix_acl *acl, int encode_entries,\n\t\t\t   int typeflag)\n{\n\tconst size_t elem_size = XDR_UNIT * 3;\n\tu32 entries = (acl && acl->a_count) ? max_t(int, acl->a_count, 4) : 0;\n\tstruct nfsacl_encode_desc nfsacl_desc = {\n\t\t.desc = {\n\t\t\t.elem_size = elem_size,\n\t\t\t.array_len = encode_entries ? entries : 0,\n\t\t\t.xcode = xdr_nfsace_encode,\n\t\t},\n\t\t.acl = acl,\n\t\t.typeflag = typeflag,\n\t\t.uid = inode->i_uid,\n\t\t.gid = inode->i_gid,\n\t};\n\tstruct nfsacl_simple_acl aclbuf;\n\tunsigned int base;\n\tint err;\n\n\tif (entries > NFS_ACL_MAX_ENTRIES)\n\t\treturn false;\n\tif (xdr_stream_encode_u32(xdr, entries) < 0)\n\t\treturn false;\n\n\tif (encode_entries && acl && acl->a_count == 3) {\n\t\tstruct posix_acl *acl2 = &aclbuf.acl;\n\n\t\t \n\t\tposix_acl_init(acl2, 4);\n\n\t\t \n\t\tacl2->a_entries[0] = acl->a_entries[0];   \n\t\tacl2->a_entries[1] = acl->a_entries[1];   \n\t\tacl2->a_entries[2] = acl->a_entries[1];   \n\t\tacl2->a_entries[2].e_tag = ACL_MASK;\n\t\tacl2->a_entries[3] = acl->a_entries[2];   \n\t\tnfsacl_desc.acl = acl2;\n\t}\n\n\tbase = xdr_stream_pos(xdr);\n\tif (!xdr_reserve_space(xdr, XDR_UNIT +\n\t\t\t       elem_size * nfsacl_desc.desc.array_len))\n\t\treturn false;\n\terr = xdr_encode_array2(xdr->buf, base, &nfsacl_desc.desc);\n\tif (err)\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(nfs_stream_encode_acl);\n\n\nstruct nfsacl_decode_desc {\n\tstruct xdr_array2_desc desc;\n\tunsigned int count;\n\tstruct posix_acl *acl;\n};\n\nstatic int\nxdr_nfsace_decode(struct xdr_array2_desc *desc, void *elem)\n{\n\tstruct nfsacl_decode_desc *nfsacl_desc =\n\t\t(struct nfsacl_decode_desc *) desc;\n\t__be32 *p = elem;\n\tstruct posix_acl_entry *entry;\n\tunsigned int id;\n\n\tif (!nfsacl_desc->acl) {\n\t\tif (desc->array_len > NFS_ACL_MAX_ENTRIES)\n\t\t\treturn -EINVAL;\n\t\tnfsacl_desc->acl = posix_acl_alloc(desc->array_len, GFP_KERNEL);\n\t\tif (!nfsacl_desc->acl)\n\t\t\treturn -ENOMEM;\n\t\tnfsacl_desc->count = 0;\n\t}\n\n\tentry = &nfsacl_desc->acl->a_entries[nfsacl_desc->count++];\n\tentry->e_tag = ntohl(*p++) & ~NFS_ACL_DEFAULT;\n\tid = ntohl(*p++);\n\tentry->e_perm = ntohl(*p++);\n\n\tswitch(entry->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_uid = make_kuid(&init_user_ns, id);\n\t\t\tif (!uid_valid(entry->e_uid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_gid = make_kgid(&init_user_ns, id);\n\t\t\tif (!gid_valid(entry->e_gid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_OTHER:\n\t\t\tif (entry->e_perm & ~S_IRWXO)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase ACL_MASK:\n\t\t\t \n\t\t\tentry->e_perm &= S_IRWXO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ncmp_acl_entry(const void *x, const void *y)\n{\n\tconst struct posix_acl_entry *a = x, *b = y;\n\n\tif (a->e_tag != b->e_tag)\n\t\treturn a->e_tag - b->e_tag;\n\telse if ((a->e_tag == ACL_USER) && uid_gt(a->e_uid, b->e_uid))\n\t\treturn 1;\n\telse if ((a->e_tag == ACL_USER) && uid_lt(a->e_uid, b->e_uid))\n\t\treturn -1;\n\telse if ((a->e_tag == ACL_GROUP) && gid_gt(a->e_gid, b->e_gid))\n\t\treturn 1;\n\telse if ((a->e_tag == ACL_GROUP) && gid_lt(a->e_gid, b->e_gid))\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}\n\n \nstatic int\nposix_acl_from_nfsacl(struct posix_acl *acl)\n{\n\tstruct posix_acl_entry *pa, *pe,\n\t       *group_obj = NULL, *mask = NULL;\n\n\tif (!acl)\n\t\treturn 0;\n\n\tsort(acl->a_entries, acl->a_count, sizeof(struct posix_acl_entry),\n\t     cmp_acl_entry, NULL);\n\n\t \n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmask = pa;\n\t\t\t\tfallthrough;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (acl->a_count == 4 && group_obj && mask &&\n\t    mask->e_perm == group_obj->e_perm) {\n\t\t \n\t\tmemmove(mask, mask+1, (3 - (mask - acl->a_entries)) *\n\t\t\t\t      sizeof(struct posix_acl_entry));\n\t\tacl->a_count = 3;\n\t}\n\treturn 0;\n}\n\n \nint nfsacl_decode(struct xdr_buf *buf, unsigned int base, unsigned int *aclcnt,\n\t\t  struct posix_acl **pacl)\n{\n\tstruct nfsacl_decode_desc nfsacl_desc = {\n\t\t.desc = {\n\t\t\t.elem_size = 12,\n\t\t\t.xcode = pacl ? xdr_nfsace_decode : NULL,\n\t\t},\n\t};\n\tu32 entries;\n\tint err;\n\n\tif (xdr_decode_word(buf, base, &entries) ||\n\t    entries > NFS_ACL_MAX_ENTRIES)\n\t\treturn -EINVAL;\n\tnfsacl_desc.desc.array_maxlen = entries;\n\terr = xdr_decode_array2(buf, base + 4, &nfsacl_desc.desc);\n\tif (err)\n\t\treturn err;\n\tif (pacl) {\n\t\tif (entries != nfsacl_desc.desc.array_len ||\n\t\t    posix_acl_from_nfsacl(nfsacl_desc.acl) != 0) {\n\t\t\tposix_acl_release(nfsacl_desc.acl);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*pacl = nfsacl_desc.acl;\n\t}\n\tif (aclcnt)\n\t\t*aclcnt = entries;\n\treturn 8 + nfsacl_desc.desc.elem_size *\n\t\t   nfsacl_desc.desc.array_len;\n}\nEXPORT_SYMBOL_GPL(nfsacl_decode);\n\n \nbool nfs_stream_decode_acl(struct xdr_stream *xdr, unsigned int *aclcnt,\n\t\t\t   struct posix_acl **pacl)\n{\n\tconst size_t elem_size = XDR_UNIT * 3;\n\tstruct nfsacl_decode_desc nfsacl_desc = {\n\t\t.desc = {\n\t\t\t.elem_size = elem_size,\n\t\t\t.xcode = pacl ? xdr_nfsace_decode : NULL,\n\t\t},\n\t};\n\tunsigned int base;\n\tu32 entries;\n\n\tif (xdr_stream_decode_u32(xdr, &entries) < 0)\n\t\treturn false;\n\tif (entries > NFS_ACL_MAX_ENTRIES)\n\t\treturn false;\n\n\tbase = xdr_stream_pos(xdr);\n\tif (!xdr_inline_decode(xdr, XDR_UNIT + elem_size * entries))\n\t\treturn false;\n\tnfsacl_desc.desc.array_maxlen = entries;\n\tif (xdr_decode_array2(xdr->buf, base, &nfsacl_desc.desc))\n\t\treturn false;\n\n\tif (pacl) {\n\t\tif (entries != nfsacl_desc.desc.array_len ||\n\t\t    posix_acl_from_nfsacl(nfsacl_desc.acl) != 0) {\n\t\t\tposix_acl_release(nfsacl_desc.acl);\n\t\t\treturn false;\n\t\t}\n\t\t*pacl = nfsacl_desc.acl;\n\t}\n\tif (aclcnt)\n\t\t*aclcnt = entries;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(nfs_stream_decode_acl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}