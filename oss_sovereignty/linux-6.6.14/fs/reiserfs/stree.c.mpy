{
  "module_name": "stree.c",
  "hash_id": "229950d167d71076248731881f1611d20ac2991016e2f93383d16a290ecb4875",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/stree.c",
  "human_readable_source": " \n\n \n\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include \"reiserfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n\n \ninline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}\n\n \ninline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}\n\n \ninline int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key)\n{\n\t__u32 n;\n\tn = le32_to_cpu(le_key->k_dir_id);\n\tif (n < cpu_key->on_disk_key.k_dir_id)\n\t\treturn -1;\n\tif (n > cpu_key->on_disk_key.k_dir_id)\n\t\treturn 1;\n\tn = le32_to_cpu(le_key->k_objectid);\n\tif (n < cpu_key->on_disk_key.k_objectid)\n\t\treturn -1;\n\tif (n > cpu_key->on_disk_key.k_objectid)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic inline int comp_keys(const struct reiserfs_key *le_key,\n\t\t\t    const struct cpu_key *cpu_key)\n{\n\tint retval;\n\n\tretval = comp_short_keys(le_key, cpu_key);\n\tif (retval)\n\t\treturn retval;\n\tif (le_key_k_offset(le_key_version(le_key), le_key) <\n\t    cpu_key_k_offset(cpu_key))\n\t\treturn -1;\n\tif (le_key_k_offset(le_key_version(le_key), le_key) >\n\t    cpu_key_k_offset(cpu_key))\n\t\treturn 1;\n\n\tif (cpu_key->key_length == 3)\n\t\treturn 0;\n\n\t \n\tif (le_key_k_type(le_key_version(le_key), le_key) <\n\t    cpu_key_k_type(cpu_key))\n\t\treturn -1;\n\n\tif (le_key_k_type(le_key_version(le_key), le_key) >\n\t    cpu_key_k_type(cpu_key))\n\t\treturn 1;\n\n\treturn 0;\n}\n\ninline int comp_short_le_keys(const struct reiserfs_key *key1,\n\t\t\t      const struct reiserfs_key *key2)\n{\n\t__u32 *k1_u32, *k2_u32;\n\tint key_length = REISERFS_SHORT_KEY_LEN;\n\n\tk1_u32 = (__u32 *) key1;\n\tk2_u32 = (__u32 *) key2;\n\tfor (; key_length--; ++k1_u32, ++k2_u32) {\n\t\tif (le32_to_cpu(*k1_u32) < le32_to_cpu(*k2_u32))\n\t\t\treturn -1;\n\t\tif (le32_to_cpu(*k1_u32) > le32_to_cpu(*k2_u32))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ninline void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from)\n{\n\tint version;\n\tto->on_disk_key.k_dir_id = le32_to_cpu(from->k_dir_id);\n\tto->on_disk_key.k_objectid = le32_to_cpu(from->k_objectid);\n\n\t \n\tversion = le_key_version(from);\n\tto->version = version;\n\tto->on_disk_key.k_offset = le_key_k_offset(version, from);\n\tto->on_disk_key.k_type = le_key_k_type(version, from);\n}\n\n \ninline int comp_le_keys(const struct reiserfs_key *k1,\n\t\t\tconst struct reiserfs_key *k2)\n{\n\treturn memcmp(k1, k2, sizeof(struct reiserfs_key));\n}\n\n \n \nstatic inline int bin_search(const void *key,\t \n\t\t\t     const void *base,\t \n\t\t\t     int num,\t \n\t\t\t      \n\t\t\t     int width,\n\t\t\t     int *pos  \n    )\n{\n\tint rbound, lbound, j;\n\n\tfor (j = ((rbound = num - 1) + (lbound = 0)) / 2;\n\t     lbound <= rbound; j = (rbound + lbound) / 2)\n\t\tswitch (comp_keys\n\t\t\t((struct reiserfs_key *)((char *)base + j * width),\n\t\t\t (struct cpu_key *)key)) {\n\t\tcase -1:\n\t\t\tlbound = j + 1;\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\trbound = j - 1;\n\t\t\tcontinue;\n\t\tcase 0:\n\t\t\t*pos = j;\n\t\t\treturn ITEM_FOUND;\t \n\t\t}\n\n\t \n\t*pos = lbound;\n\treturn ITEM_NOT_FOUND;\n}\n\n\n \nconst struct reiserfs_key MIN_KEY = { 0, 0, {{0, 0},} };\n\n \nstatic const struct reiserfs_key MAX_KEY = {\n\tcpu_to_le32(0xffffffff),\n\tcpu_to_le32(0xffffffff),\n\t{{cpu_to_le32(0xffffffff),\n\t  cpu_to_le32(0xffffffff)},}\n};\n\n \nstatic inline const struct reiserfs_key *get_lkey(const struct treepath *chk_path,\n\t\t\t\t\t\t  const struct super_block *sb)\n{\n\tint position, path_offset = chk_path->path_length;\n\tstruct buffer_head *parent;\n\n\tRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5010: invalid offset in the path\");\n\n\t \n\twhile (path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {\n\n\t\tRFALSE(!buffer_uptodate\n\t\t       (PATH_OFFSET_PBUFFER(chk_path, path_offset)),\n\t\t       \"PAP-5020: parent is not uptodate\");\n\n\t\t \n\t\tif (!B_IS_IN_TREE\n\t\t    (parent =\n\t\t     PATH_OFFSET_PBUFFER(chk_path, path_offset)))\n\t\t\treturn &MAX_KEY;\n\t\t \n\t\tif ((position =\n\t\t     PATH_OFFSET_POSITION(chk_path,\n\t\t\t\t\t  path_offset)) >\n\t\t    B_NR_ITEMS(parent))\n\t\t\treturn &MAX_KEY;\n\t\t \n\t\tif (B_N_CHILD_NUM(parent, position) !=\n\t\t    PATH_OFFSET_PBUFFER(chk_path,\n\t\t\t\t\tpath_offset + 1)->b_blocknr)\n\t\t\treturn &MAX_KEY;\n\t\t \n\t\tif (position)\n\t\t\treturn internal_key(parent, position - 1);\n\t}\n\t \n\tif (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->\n\t    b_blocknr == SB_ROOT_BLOCK(sb))\n\t\treturn &MIN_KEY;\n\treturn &MAX_KEY;\n}\n\n \ninline const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t\t   const struct super_block *sb)\n{\n\tint position, path_offset = chk_path->path_length;\n\tstruct buffer_head *parent;\n\n\tRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5030: invalid offset in the path\");\n\n\twhile (path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {\n\n\t\tRFALSE(!buffer_uptodate\n\t\t       (PATH_OFFSET_PBUFFER(chk_path, path_offset)),\n\t\t       \"PAP-5040: parent is not uptodate\");\n\n\t\t \n\t\tif (!B_IS_IN_TREE\n\t\t    (parent =\n\t\t     PATH_OFFSET_PBUFFER(chk_path, path_offset)))\n\t\t\treturn &MIN_KEY;\n\t\t \n\t\tif ((position =\n\t\t     PATH_OFFSET_POSITION(chk_path,\n\t\t\t\t\t  path_offset)) >\n\t\t    B_NR_ITEMS(parent))\n\t\t\treturn &MIN_KEY;\n\t\t \n\t\tif (B_N_CHILD_NUM(parent, position) !=\n\t\t    PATH_OFFSET_PBUFFER(chk_path,\n\t\t\t\t\tpath_offset + 1)->b_blocknr)\n\t\t\treturn &MIN_KEY;\n\n\t\t \n\t\tif (position != B_NR_ITEMS(parent))\n\t\t\treturn internal_key(parent, position);\n\t}\n\n\t \n\tif (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->\n\t    b_blocknr == SB_ROOT_BLOCK(sb))\n\t\treturn &MAX_KEY;\n\treturn &MIN_KEY;\n}\n\n \nstatic inline int key_in_buffer(\n\t\t\t\t \n\t\t\t\tstruct treepath *chk_path,\n\t\t\t\t \n\t\t\t\tconst struct cpu_key *key,\n\t\t\t\tstruct super_block *sb\n    )\n{\n\n\tRFALSE(!key || chk_path->path_length < FIRST_PATH_ELEMENT_OFFSET\n\t       || chk_path->path_length > MAX_HEIGHT,\n\t       \"PAP-5050: pointer to the key(%p) is NULL or invalid path length(%d)\",\n\t       key, chk_path->path_length);\n\tRFALSE(!PATH_PLAST_BUFFER(chk_path)->b_bdev,\n\t       \"PAP-5060: device must not be NODEV\");\n\n\tif (comp_keys(get_lkey(chk_path, sb), key) == 1)\n\t\t \n\t\treturn 0;\n\t \n\tif (comp_keys(get_rkey(chk_path, sb), key) != 1)\n\t\t \n\t\treturn 0;\n\treturn 1;\n}\n\nint reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}\n\n \nvoid pathrelse_and_restore(struct super_block *sb,\n\t\t\t   struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"clm-4000: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET) {\n\t\tstruct buffer_head *bh;\n\t\tbh = PATH_OFFSET_PBUFFER(search_path, path_offset--);\n\t\treiserfs_restore_prepared_buffer(sb, bh);\n\t\tbrelse(bh);\n\t}\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}\n\n \nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}\n\nstatic int has_valid_deh_location(struct buffer_head *bh, struct item_head *ih)\n{\n\tstruct reiserfs_de_head *deh;\n\tint i;\n\n\tdeh = B_I_DEH(bh, ih);\n\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\tif (deh_location(&deh[i]) > ih_item_len(ih)) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5094\",\n\t\t\t\t\t \"directory entry location seems wrong %h\",\n\t\t\t\t\t &deh[i]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic int is_leaf(char *buf, int blocksize, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint used_space;\n\tint prev_location;\n\tint i;\n\tint nr;\n\n\tblkh = (struct block_head *)buf;\n\tif (blkh_level(blkh) != DISK_LEAF_NODE_LEVEL) {\n\t\treiserfs_warning(NULL, \"reiserfs-5080\",\n\t\t\t\t \"this should be caught earlier\");\n\t\treturn 0;\n\t}\n\n\tnr = blkh_nr_item(blkh);\n\tif (nr < 1 || nr > ((blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN))) {\n\t\t \n\t\treiserfs_warning(NULL, \"reiserfs-5081\",\n\t\t\t\t \"nr_item seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\tih = (struct item_head *)(buf + BLKH_SIZE) + nr - 1;\n\tused_space = BLKH_SIZE + IH_SIZE * nr + (blocksize - ih_location(ih));\n\n\t \n\tif (used_space != blocksize - blkh_free_space(blkh)) {\n\t\treiserfs_warning(NULL, \"reiserfs-5082\",\n\t\t\t\t \"free space seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\t \n\n\t \n\tih = (struct item_head *)(buf + BLKH_SIZE);\n\tprev_location = blocksize;\n\tfor (i = 0; i < nr; i++, ih++) {\n\t\tif (le_ih_k_type(ih) == TYPE_ANY) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5083\",\n\t\t\t\t\t \"wrong item type for item %h\",\n\t\t\t\t\t ih);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ih_location(ih) >= blocksize\n\t\t    || ih_location(ih) < IH_SIZE * nr) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5084\",\n\t\t\t\t\t \"item location seems wrong: %h\",\n\t\t\t\t\t ih);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ih_item_len(ih) < 1\n\t\t    || ih_item_len(ih) > MAX_ITEM_LEN(blocksize)) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5085\",\n\t\t\t\t\t \"item length seems wrong: %h\",\n\t\t\t\t\t ih);\n\t\t\treturn 0;\n\t\t}\n\t\tif (prev_location - ih_location(ih) != ih_item_len(ih)) {\n\t\t\treiserfs_warning(NULL, \"reiserfs-5086\",\n\t\t\t\t\t \"item location seems wrong \"\n\t\t\t\t\t \"(second one): %h\", ih);\n\t\t\treturn 0;\n\t\t}\n\t\tif (is_direntry_le_ih(ih)) {\n\t\t\tif (ih_item_len(ih) < (ih_entry_count(ih) * IH_SIZE)) {\n\t\t\t\treiserfs_warning(NULL, \"reiserfs-5093\",\n\t\t\t\t\t\t \"item entry count seems wrong %h\",\n\t\t\t\t\t\t ih);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn has_valid_deh_location(bh, ih);\n\t\t}\n\t\tprev_location = ih_location(ih);\n\t}\n\n\t \n\treturn 1;\n}\n\n \nstatic int is_internal(char *buf, int blocksize, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tint nr;\n\tint used_space;\n\n\tblkh = (struct block_head *)buf;\n\tnr = blkh_level(blkh);\n\tif (nr <= DISK_LEAF_NODE_LEVEL || nr > MAX_HEIGHT) {\n\t\t \n\t\treiserfs_warning(NULL, \"reiserfs-5087\",\n\t\t\t\t \"this should be caught earlier\");\n\t\treturn 0;\n\t}\n\n\tnr = blkh_nr_item(blkh);\n\t \n\tif (nr > (blocksize - BLKH_SIZE - DC_SIZE) / (KEY_SIZE + DC_SIZE)) {\n\t\treiserfs_warning(NULL, \"reiserfs-5088\",\n\t\t\t\t \"number of key seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\n\tused_space = BLKH_SIZE + KEY_SIZE * nr + DC_SIZE * (nr + 1);\n\tif (used_space != blocksize - blkh_free_space(blkh)) {\n\t\treiserfs_warning(NULL, \"reiserfs-5089\",\n\t\t\t\t \"free space seems wrong: %z\", bh);\n\t\treturn 0;\n\t}\n\n\t \n\treturn 1;\n}\n\n \nstatic int is_tree_node(struct buffer_head *bh, int level)\n{\n\tif (B_LEVEL(bh) != level) {\n\t\treiserfs_warning(NULL, \"reiserfs-5090\", \"node level %d does \"\n\t\t\t\t \"not match to the expected one %d\",\n\t\t\t\t B_LEVEL(bh), level);\n\t\treturn 0;\n\t}\n\tif (level == DISK_LEAF_NODE_LEVEL)\n\t\treturn is_leaf(bh->b_data, bh->b_size, bh);\n\n\treturn is_internal(bh->b_data, bh->b_size, bh);\n}\n\n#define SEARCH_BY_KEY_READA 16\n\n \nstatic int search_by_key_reada(struct super_block *s,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tb_blocknr_t *b, int num)\n{\n\tint i, j;\n\tint depth = -1;\n\n\tfor (i = 0; i < num; i++) {\n\t\tbh[i] = sb_getblk(s, b[i]);\n\t}\n\t \n\tfor (j = 0; j < i; j++) {\n\t\t \n\t\tif (!buffer_uptodate(bh[j])) {\n\t\t\tif (depth == -1)\n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tbh_readahead(bh[j], REQ_RAHEAD);\n\t\t}\n\t\tbrelse(bh[j]);\n\t}\n\treturn depth;\n}\n\n \n \nint search_by_key(struct super_block *sb, const struct cpu_key *key,\n\t\t  struct treepath *search_path, int stop_level)\n{\n\tb_blocknr_t block_number;\n\tint expected_level;\n\tstruct buffer_head *bh;\n\tstruct path_element *last_element;\n\tint node_level, retval;\n\tint fs_gen;\n\tstruct buffer_head *reada_bh[SEARCH_BY_KEY_READA];\n\tb_blocknr_t reada_blocks[SEARCH_BY_KEY_READA];\n\tint reada_count = 0;\n\n#ifdef CONFIG_REISERFS_CHECK\n\tint repeat_counter = 0;\n#endif\n\n\tPROC_INFO_INC(sb, search_by_key);\n\n\t \n\n\tpathrelse(search_path);\n\n\t \n\tblock_number = SB_ROOT_BLOCK(sb);\n\texpected_level = -1;\n\twhile (1) {\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (!(++repeat_counter % 50000))\n\t\t\treiserfs_warning(sb, \"PAP-5100\",\n\t\t\t\t\t \"%s: there were %d iterations of \"\n\t\t\t\t\t \"while loop looking for key %K\",\n\t\t\t\t\t current->comm, repeat_counter,\n\t\t\t\t\t key);\n#endif\n\n\t\t \n\t\tlast_element =\n\t\t    PATH_OFFSET_PELEMENT(search_path,\n\t\t\t\t\t ++search_path->path_length);\n\t\tfs_gen = get_generation(sb);\n\n\t\t \n\t\tif ((bh = last_element->pe_buffer =\n\t\t     sb_getblk(sb, block_number))) {\n\n\t\t\t \n\t\t\tint depth = -1;\n\n\t\t\tif (!buffer_uptodate(bh) && reada_count > 1)\n\t\t\t\tdepth = search_by_key_reada(sb, reada_bh,\n\t\t\t\t\t\t    reada_blocks, reada_count);\n\n\t\t\tif (!buffer_uptodate(bh) && depth == -1)\n\t\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\n\t\t\tbh_read_nowait(bh, 0);\n\t\t\twait_on_buffer(bh);\n\n\t\t\tif (depth != -1)\n\t\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tgoto io_error;\n\t\t} else {\nio_error:\n\t\t\tsearch_path->path_length--;\n\t\t\tpathrelse(search_path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\treada_count = 0;\n\t\tif (expected_level == -1)\n\t\t\texpected_level = SB_TREE_HEIGHT(sb);\n\t\texpected_level--;\n\n\t\t \n\t\tif (fs_changed(fs_gen, sb) &&\n\t\t    (!B_IS_IN_TREE(bh) ||\n\t\t     B_LEVEL(bh) != expected_level ||\n\t\t     !key_in_buffer(search_path, key, sb))) {\n\t\t\tPROC_INFO_INC(sb, search_by_key_fs_changed);\n\t\t\tPROC_INFO_INC(sb, search_by_key_restarted);\n\t\t\tPROC_INFO_INC(sb,\n\t\t\t\t      sbk_restarted[expected_level - 1]);\n\t\t\tpathrelse(search_path);\n\n\t\t\t \n\t\t\tblock_number = SB_ROOT_BLOCK(sb);\n\t\t\texpected_level = -1;\n\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tRFALSE(comp_keys(&MAX_KEY, key) &&\n\t\t       !key_in_buffer(search_path, key, sb),\n\t\t       \"PAP-5130: key is not in the buffer\");\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (REISERFS_SB(sb)->cur_tb) {\n\t\t\tprint_cur_tb(\"5140\");\n\t\t\treiserfs_panic(sb, \"PAP-5140\",\n\t\t\t\t       \"schedule occurred in do_balance!\");\n\t\t}\n#endif\n\n\t\t \n\t\tif (!is_tree_node(bh, expected_level)) {\n\t\t\treiserfs_error(sb, \"vs-5150\",\n\t\t\t\t       \"invalid format found in block %ld. \"\n\t\t\t\t       \"Fsck?\", bh->b_blocknr);\n\t\t\tpathrelse(search_path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t \n\t\tnode_level = B_LEVEL(bh);\n\n\t\tPROC_INFO_BH_STAT(sb, bh, node_level - 1);\n\n\t\tRFALSE(node_level < stop_level,\n\t\t       \"vs-5152: tree level (%d) is less than stop level (%d)\",\n\t\t       node_level, stop_level);\n\n\t\tretval = bin_search(key, item_head(bh, 0),\n\t\t\t\t      B_NR_ITEMS(bh),\n\t\t\t\t      (node_level ==\n\t\t\t\t       DISK_LEAF_NODE_LEVEL) ? IH_SIZE :\n\t\t\t\t      KEY_SIZE,\n\t\t\t\t      &last_element->pe_position);\n\t\tif (node_level == stop_level) {\n\t\t\treturn retval;\n\t\t}\n\n\t\t \n\t\t \n\t\tif (retval == ITEM_FOUND)\n\t\t\tlast_element->pe_position++;\n\n\t\t \n\n\t\t \n\t\tblock_number =\n\t\t    B_N_CHILD_NUM(bh, last_element->pe_position);\n\n\t\t \n\t\tif ((search_path->reada & PATH_READA) &&\n\t\t    node_level == DISK_LEAF_NODE_LEVEL + 1) {\n\t\t\tint pos = last_element->pe_position;\n\t\t\tint limit = B_NR_ITEMS(bh);\n\t\t\tstruct reiserfs_key *le_key;\n\n\t\t\tif (search_path->reada & PATH_READA_BACK)\n\t\t\t\tlimit = 0;\n\t\t\twhile (reada_count < SEARCH_BY_KEY_READA) {\n\t\t\t\tif (pos == limit)\n\t\t\t\t\tbreak;\n\t\t\t\treada_blocks[reada_count++] =\n\t\t\t\t    B_N_CHILD_NUM(bh, pos);\n\t\t\t\tif (search_path->reada & PATH_READA_BACK)\n\t\t\t\t\tpos--;\n\t\t\t\telse\n\t\t\t\t\tpos++;\n\n\t\t\t\t \n\t\t\t\tle_key = internal_key(bh, pos);\n\t\t\t\tif (le32_to_cpu(le_key->k_objectid) !=\n\t\t\t\t    key->on_disk_key.k_objectid) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n \n \nint search_for_position_by_key(struct super_block *sb,\n\t\t\t        \n\t\t\t       const struct cpu_key *p_cpu_key,\n\t\t\t        \n\t\t\t       struct treepath *search_path)\n{\n\tstruct item_head *p_le_ih;\t \n\tint blk_size;\n\tloff_t item_offset, offset;\n\tstruct reiserfs_dir_entry de;\n\tint retval;\n\n\t \n\tif (is_direntry_cpu_key(p_cpu_key))\n\t\treturn search_by_entry_key(sb, p_cpu_key, search_path,\n\t\t\t\t\t   &de);\n\n\t \n\n\t \n\tretval = search_item(sb, p_cpu_key, search_path);\n\tif (retval == IO_ERROR)\n\t\treturn retval;\n\tif (retval == ITEM_FOUND) {\n\n\t\tRFALSE(!ih_item_len\n\t\t       (item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path))),\n\t\t       \"PAP-5165: item length equals zero\");\n\n\t\tpos_in_item(search_path) = 0;\n\t\treturn POSITION_FOUND;\n\t}\n\n\tRFALSE(!PATH_LAST_POSITION(search_path),\n\t       \"PAP-5170: position equals zero\");\n\n\t \n\tp_le_ih =\n\t    item_head(PATH_PLAST_BUFFER(search_path),\n\t\t\t   --PATH_LAST_POSITION(search_path));\n\tblk_size = sb->s_blocksize;\n\n\tif (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))\n\t\treturn FILE_NOT_FOUND;\n\n\t \n\n\titem_offset = le_ih_k_offset(p_le_ih);\n\toffset = cpu_key_k_offset(p_cpu_key);\n\n\t \n\tif (item_offset <= offset &&\n\t    item_offset + op_bytes_number(p_le_ih, blk_size) > offset) {\n\t\tpos_in_item(search_path) = offset - item_offset;\n\t\tif (is_indirect_le_ih(p_le_ih)) {\n\t\t\tpos_in_item(search_path) /= blk_size;\n\t\t}\n\t\treturn POSITION_FOUND;\n\t}\n\n\t \n\tif (is_indirect_le_ih(p_le_ih))\n\t\tpos_in_item(search_path) =\n\t\t    ih_item_len(p_le_ih) / UNFM_P_SIZE;\n\telse\n\t\tpos_in_item(search_path) = ih_item_len(p_le_ih);\n\n\treturn POSITION_NOT_FOUND;\n}\n\n \nint comp_items(const struct item_head *stored_ih, const struct treepath *path)\n{\n\tstruct buffer_head *bh = PATH_PLAST_BUFFER(path);\n\tstruct item_head *ih;\n\n\t \n\tif (!B_IS_IN_TREE(bh))\n\t\treturn 1;\n\n\t \n\tif (PATH_LAST_POSITION(path) >= B_NR_ITEMS(bh))\n\t\treturn 1;\n\n\t \n\tih = tp_item_head(path);\n\treturn memcmp(stored_ih, ih, IH_SIZE);\n}\n\n \nstatic inline int prepare_for_direct_item(struct treepath *path,\n\t\t\t\t\t  struct item_head *le_ih,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  loff_t new_file_length, int *cut_size)\n{\n\tloff_t round_len;\n\n\tif (new_file_length == max_reiserfs_offset(inode)) {\n\t\t \n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\treturn M_DELETE;\n\t}\n\t \n\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_6) {\n\t\tround_len = ROUND_UP(new_file_length);\n\t\t \n\t\tif (round_len < le_ih_k_offset(le_ih)) {\n\t\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\t\treturn M_DELETE;\t \n\t\t}\n\t\t \n\t\tpos_in_item(path) = round_len - (le_ih_k_offset(le_ih) - 1);\n\t\t*cut_size = -(ih_item_len(le_ih) - pos_in_item(path));\n\n\t\treturn M_CUT;\t \n\t}\n\n\t \n\n\tif (new_file_length < le_ih_k_offset(le_ih)) {\n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\treturn M_DELETE;\t \n\t}\n\n\t \n\t*cut_size = -(ih_item_len(le_ih) -\n\t\t      (pos_in_item(path) =\n\t\t       new_file_length + 1 - le_ih_k_offset(le_ih)));\n\treturn M_CUT;\t\t \n}\n\nstatic inline int prepare_for_direntry_item(struct treepath *path,\n\t\t\t\t\t    struct item_head *le_ih,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    loff_t new_file_length,\n\t\t\t\t\t    int *cut_size)\n{\n\tif (le_ih_k_offset(le_ih) == DOT_OFFSET &&\n\t    new_file_length == max_reiserfs_offset(inode)) {\n\t\tRFALSE(ih_entry_count(le_ih) != 2,\n\t\t       \"PAP-5220: incorrect empty directory item (%h)\", le_ih);\n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\t \n\t\treturn M_DELETE;\n\t}\n\n\tif (ih_entry_count(le_ih) == 1) {\n\t\t \n\t\t*cut_size = -(IH_SIZE + ih_item_len(le_ih));\n\t\treturn M_DELETE;\n\t}\n\n\t \n\t*cut_size =\n\t    -(DEH_SIZE +\n\t      entry_length(get_last_bh(path), le_ih, pos_in_item(path)));\n\treturn M_CUT;\n}\n\n#define JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD (2 * JOURNAL_PER_BALANCE_CNT + 1)\n\n \nstatic char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode,\n\t\t\t\t      struct treepath *path,\n\t\t\t\t      const struct cpu_key *item_key,\n\t\t\t\t       \n\t\t\t\t      int *removed,\n\t\t\t\t      int *cut_size,\n\t\t\t\t       \n\t\t\t\t      unsigned long long new_file_length\n    )\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct item_head *p_le_ih = tp_item_head(path);\n\tstruct buffer_head *bh = PATH_PLAST_BUFFER(path);\n\n\tBUG_ON(!th->t_trans_id);\n\n\t \n\tif (is_statdata_le_ih(p_le_ih)) {\n\n\t\tRFALSE(new_file_length != max_reiserfs_offset(inode),\n\t\t       \"PAP-5210: mode must be M_DELETE\");\n\n\t\t*cut_size = -(IH_SIZE + ih_item_len(p_le_ih));\n\t\treturn M_DELETE;\n\t}\n\n\t \n\tif (is_direntry_le_ih(p_le_ih))\n\t\treturn prepare_for_direntry_item(path, p_le_ih, inode,\n\t\t\t\t\t\t new_file_length,\n\t\t\t\t\t\t cut_size);\n\n\t \n\tif (is_direct_le_ih(p_le_ih))\n\t\treturn prepare_for_direct_item(path, p_le_ih, inode,\n\t\t\t\t\t       new_file_length, cut_size);\n\n\t \n\t{\n\t    int blk_size = sb->s_blocksize;\n\t    struct item_head s_ih;\n\t    int need_re_search;\n\t    int delete = 0;\n\t    int result = M_CUT;\n\t    int pos = 0;\n\n\t    if ( new_file_length == max_reiserfs_offset (inode) ) {\n\t\t \n\t\tnew_file_length = 0;\n\t\tdelete = 1;\n\t    }\n\n\t    do {\n\t\tneed_re_search = 0;\n\t\t*cut_size = 0;\n\t\tbh = PATH_PLAST_BUFFER(path);\n\t\tcopy_item_head(&s_ih, tp_item_head(path));\n\t\tpos = I_UNFM_NUM(&s_ih);\n\n\t\twhile (le_ih_k_offset (&s_ih) + (pos - 1) * blk_size > new_file_length) {\n\t\t    __le32 *unfm;\n\t\t    __u32 block;\n\n\t\t     \n\t\t    if (!delete && (*cut_size) != 0 &&\n\t\t\treiserfs_transaction_free_space(th) < JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD)\n\t\t\tbreak;\n\n\t\t    unfm = (__le32 *)ih_item_body(bh, &s_ih) + pos - 1;\n\t\t    block = get_block_num(unfm, 0);\n\n\t\t    if (block != 0) {\n\t\t\treiserfs_prepare_for_journal(sb, bh, 1);\n\t\t\tput_block_num(unfm, 0, 0);\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\treiserfs_free_block(th, inode, block, 1);\n\t\t    }\n\n\t\t    reiserfs_cond_resched(sb);\n\n\t\t    if (item_moved (&s_ih, path))  {\n\t\t\tneed_re_search = 1;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    pos --;\n\t\t    (*removed)++;\n\t\t    (*cut_size) -= UNFM_P_SIZE;\n\n\t\t    if (pos == 0) {\n\t\t\t(*cut_size) -= IH_SIZE;\n\t\t\tresult = M_DELETE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t \n\t\treiserfs_restore_prepared_buffer(sb, bh);\n\t    } while (need_re_search &&\n\t\t     search_for_position_by_key(sb, item_key, path) == POSITION_FOUND);\n\t    pos_in_item(path) = pos * UNFM_P_SIZE;\n\n\t    if (*cut_size == 0) {\n\t\t \n\t\tresult = M_CONVERT;\n\t    }\n\t    return result;\n\t}\n}\n\n \nstatic int calc_deleted_bytes_number(struct tree_balance *tb, char mode)\n{\n\tint del_size;\n\tstruct item_head *p_le_ih = tp_item_head(tb->tb_path);\n\n\tif (is_statdata_le_ih(p_le_ih))\n\t\treturn 0;\n\n\tdel_size =\n\t    (mode ==\n\t     M_DELETE) ? ih_item_len(p_le_ih) : -tb->insert_size[0];\n\tif (is_direntry_le_ih(p_le_ih)) {\n\t\t \n\t\treturn del_size;\n\t}\n\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tdel_size = (del_size / UNFM_P_SIZE) *\n\t\t\t\t(PATH_PLAST_BUFFER(tb->tb_path)->b_size);\n\treturn del_size;\n}\n\nstatic void init_tb_struct(struct reiserfs_transaction_handle *th,\n\t\t\t   struct tree_balance *tb,\n\t\t\t   struct super_block *sb,\n\t\t\t   struct treepath *path, int size)\n{\n\n\tBUG_ON(!th->t_trans_id);\n\n\tmemset(tb, '\\0', sizeof(struct tree_balance));\n\ttb->transaction_handle = th;\n\ttb->tb_sb = sb;\n\ttb->tb_path = path;\n\tPATH_OFFSET_PBUFFER(path, ILLEGAL_PATH_ELEMENT_OFFSET) = NULL;\n\tPATH_OFFSET_POSITION(path, ILLEGAL_PATH_ELEMENT_OFFSET) = 0;\n\ttb->insert_size[0] = size;\n}\n\nvoid padd_item(char *item, int total_length, int length)\n{\n\tint i;\n\n\tfor (i = total_length; i > length;)\n\t\titem[--i] = 0;\n}\n\n#ifdef REISERQUOTA_DEBUG\nchar key2type(struct reiserfs_key *ih)\n{\n\tif (is_direntry_le_key(2, ih))\n\t\treturn 'd';\n\tif (is_direct_le_key(2, ih))\n\t\treturn 'D';\n\tif (is_indirect_le_key(2, ih))\n\t\treturn 'i';\n\tif (is_statdata_le_key(2, ih))\n\t\treturn 's';\n\treturn 'u';\n}\n\nchar head2type(struct item_head *ih)\n{\n\tif (is_direntry_le_ih(ih))\n\t\treturn 'd';\n\tif (is_direct_le_ih(ih))\n\t\treturn 'D';\n\tif (is_indirect_le_ih(ih))\n\t\treturn 'i';\n\tif (is_statdata_le_ih(ih))\n\t\treturn 's';\n\treturn 'u';\n}\n#endif\n\n \nint reiserfs_delete_item(struct reiserfs_transaction_handle *th,\n\t\t\t struct treepath *path, const struct cpu_key *item_key,\n\t\t\t struct inode *inode, struct buffer_head *un_bh)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct tree_balance s_del_balance;\n\tstruct item_head s_ih;\n\tstruct item_head *q_ih;\n\tint quota_cut_bytes;\n\tint ret_value, del_size, removed;\n\tint depth;\n\n#ifdef CONFIG_REISERFS_CHECK\n\tchar mode;\n#endif\n\n\tBUG_ON(!th->t_trans_id);\n\n\tinit_tb_struct(th, &s_del_balance, sb, path,\n\t\t       0   );\n\n\twhile (1) {\n\t\tremoved = 0;\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\tmode =\n#endif\n\t\t    prepare_for_delete_or_cut(th, inode, path,\n\t\t\t\t\t      item_key, &removed,\n\t\t\t\t\t      &del_size,\n\t\t\t\t\t      max_reiserfs_offset(inode));\n\n\t\tRFALSE(mode != M_DELETE, \"PAP-5320: mode must be M_DELETE\");\n\n\t\tcopy_item_head(&s_ih, tp_item_head(path));\n\t\ts_del_balance.insert_size[0] = del_size;\n\n\t\tret_value = fix_nodes(M_DELETE, &s_del_balance, NULL, NULL);\n\t\tif (ret_value != REPEAT_SEARCH)\n\t\t\tbreak;\n\n\t\tPROC_INFO_INC(sb, delete_item_restarted);\n\n\t\t \n\t\tret_value =\n\t\t    search_for_position_by_key(sb, item_key, path);\n\t\tif (ret_value == IO_ERROR)\n\t\t\tbreak;\n\t\tif (ret_value == FILE_NOT_FOUND) {\n\t\t\treiserfs_warning(sb, \"vs-5340\",\n\t\t\t\t\t \"no items of the file %K found\",\n\t\t\t\t\t item_key);\n\t\t\tbreak;\n\t\t}\n\t}\t\t\t \n\n\tif (ret_value != CARRY_ON) {\n\t\tunfix_nodes(&s_del_balance);\n\t\treturn 0;\n\t}\n\n\t \n\tret_value = calc_deleted_bytes_number(&s_del_balance, M_DELETE);\n\tq_ih = tp_item_head(path);\n\tquota_cut_bytes = ih_item_len(q_ih);\n\n\t \n\tif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(q_ih)) {\n\t\tif ((le_ih_k_offset(q_ih) & (sb->s_blocksize - 1)) == 1) {\n\t\t\tquota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;\n\t\t} else {\n\t\t\tquota_cut_bytes = 0;\n\t\t}\n\t}\n\n\tif (un_bh) {\n\t\tint off;\n\t\tchar *data;\n\n\t\t \n\t\t \n\n\t\tdata = kmap_atomic(un_bh->b_page);\n\t\toff = ((le_ih_k_offset(&s_ih) - 1) & (PAGE_SIZE - 1));\n\t\tmemcpy(data + off,\n\t\t       ih_item_body(PATH_PLAST_BUFFER(path), &s_ih),\n\t\t       ret_value);\n\t\tkunmap_atomic(data);\n\t}\n\n\t \n\tdo_balance(&s_del_balance, NULL, NULL, M_DELETE);\n\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota delete_item(): freeing %u, id=%u type=%c\",\n\t\t       quota_cut_bytes, inode->i_uid, head2type(&s_ih));\n#endif\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_free_space_nodirty(inode, quota_cut_bytes);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\t \n\treturn ret_value;\n}\n\n \n\n \nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct tree_balance tb;\n\tINITIALIZE_PATH(path);\n\tint item_len = 0;\n\tint tb_init = 0;\n\tstruct cpu_key cpu_key;\n\tint retval;\n\tint quota_cut_bytes = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tle_key2cpu_key(&cpu_key, key);\n\n\twhile (1) {\n\t\tretval = search_item(th->t_super, &cpu_key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(th->t_super, \"vs-5350\",\n\t\t\t\t       \"i/o failure occurred trying \"\n\t\t\t\t       \"to delete %K\", &cpu_key);\n\t\t\tbreak;\n\t\t}\n\t\tif (retval != ITEM_FOUND) {\n\t\t\tpathrelse(&path);\n\t\t\t \n\t\t\tif (!\n\t\t\t    ((unsigned long long)\n\t\t\t     GET_HASH_VALUE(le_key_k_offset\n\t\t\t\t\t    (le_key_version(key), key)) == 0\n\t\t\t     && (unsigned long long)\n\t\t\t     GET_GENERATION_NUMBER(le_key_k_offset\n\t\t\t\t\t\t   (le_key_version(key),\n\t\t\t\t\t\t    key)) == 1))\n\t\t\t\treiserfs_warning(th->t_super, \"vs-5355\",\n\t\t\t\t\t\t \"%k not found\", key);\n\t\t\tbreak;\n\t\t}\n\t\tif (!tb_init) {\n\t\t\ttb_init = 1;\n\t\t\titem_len = ih_item_len(tp_item_head(&path));\n\t\t\tinit_tb_struct(th, &tb, th->t_super, &path,\n\t\t\t\t       -(IH_SIZE + item_len));\n\t\t}\n\t\tquota_cut_bytes = ih_item_len(tp_item_head(&path));\n\n\t\tretval = fix_nodes(M_DELETE, &tb, NULL, NULL);\n\t\tif (retval == REPEAT_SEARCH) {\n\t\t\tPROC_INFO_INC(th->t_super, delete_solid_item_restarted);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (retval == CARRY_ON) {\n\t\t\tdo_balance(&tb, NULL, NULL, M_DELETE);\n\t\t\t \n\t\t\tif (inode) {\n\t\t\t\tint depth;\n#ifdef REISERQUOTA_DEBUG\n\t\t\t\treiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"reiserquota delete_solid_item(): freeing %u id=%u type=%c\",\n\t\t\t\t\t       quota_cut_bytes, inode->i_uid,\n\t\t\t\t\t       key2type(key));\n#endif\n\t\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t\tdquot_free_space_nodirty(inode,\n\t\t\t\t\t\t\t quota_cut_bytes);\n\t\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\treiserfs_warning(th->t_super, \"vs-5360\",\n\t\t\t\t \"could not delete %K due to fix_nodes failure\",\n\t\t\t\t &cpu_key);\n\t\tunfix_nodes(&tb);\n\t\tbreak;\n\t}\n\n\treiserfs_check_path(&path);\n}\n\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode)\n{\n\tint err;\n\tinode->i_size = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\t \n\terr =\n\t    reiserfs_do_truncate(th, inode, NULL, 0   );\n\tif (err)\n\t\treturn err;\n\n#if defined( USE_INODE_GENERATION_COUNTER )\n\tif (!old_format_only(th->t_super)) {\n\t\t__le32 *inode_generation;\n\n\t\tinode_generation =\n\t\t    &REISERFS_SB(th->t_super)->s_rs->s_inode_generation;\n\t\tle32_add_cpu(inode_generation, 1);\n\t}\n \n#endif\n\treiserfs_delete_solid_item(th, inode, INODE_PKEY(inode));\n\n\treturn err;\n}\n\nstatic void unmap_buffers(struct page *page, loff_t pos)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct buffer_head *next;\n\tunsigned long tail_index;\n\tunsigned long cur_index;\n\n\tif (page) {\n\t\tif (page_has_buffers(page)) {\n\t\t\ttail_index = pos & (PAGE_SIZE - 1);\n\t\t\tcur_index = 0;\n\t\t\thead = page_buffers(page);\n\t\t\tbh = head;\n\t\t\tdo {\n\t\t\t\tnext = bh->b_this_page;\n\n\t\t\t\t \n\t\t\t\tcur_index += bh->b_size;\n\t\t\t\tif (cur_index > tail_index) {\n\t\t\t\t\treiserfs_unmap_buffer(bh);\n\t\t\t\t}\n\t\t\t\tbh = next;\n\t\t\t} while (bh != head);\n\t\t}\n\t}\n}\n\nstatic int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    struct page *page,\n\t\t\t\t    struct treepath *path,\n\t\t\t\t    const struct cpu_key *item_key,\n\t\t\t\t    loff_t new_file_size, char *mode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint block_size = sb->s_blocksize;\n\tint cut_bytes;\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(new_file_size != inode->i_size);\n\n\t \n\tif (atomic_read(&inode->i_count) > 1 ||\n\t    !tail_has_to_be_packed(inode) ||\n\t    !page || (REISERFS_I(inode)->i_flags & i_nopack_mask)) {\n\t\t \n\t\t*mode = M_SKIP_BALANCING;\n\t\tcut_bytes =\n\t\t    block_size - (new_file_size & (block_size - 1));\n\t\tpathrelse(path);\n\t\treturn cut_bytes;\n\t}\n\n\t \n\treturn indirect2direct(th, inode, page, path, item_key,\n\t\t\t       new_file_size, mode);\n}\n\n \nstatic void indirect_to_direct_roll_back(struct reiserfs_transaction_handle *th,\n\t\t\t\t\t struct inode *inode, struct treepath *path)\n{\n\tstruct cpu_key tail_key;\n\tint tail_len;\n\tint removed;\n\tBUG_ON(!th->t_trans_id);\n\n\tmake_cpu_key(&tail_key, inode, inode->i_size + 1, TYPE_DIRECT, 4);\n\ttail_key.key_length = 4;\n\n\ttail_len =\n\t    (cpu_key_k_offset(&tail_key) & (inode->i_sb->s_blocksize - 1)) - 1;\n\twhile (tail_len) {\n\t\t \n\t\tif (search_for_position_by_key(inode->i_sb, &tail_key, path) ==\n\t\t    POSITION_NOT_FOUND)\n\t\t\treiserfs_panic(inode->i_sb, \"vs-5615\",\n\t\t\t\t       \"found invalid item\");\n\t\tRFALSE(path->pos_in_item !=\n\t\t       ih_item_len(tp_item_head(path)) - 1,\n\t\t       \"vs-5616: appended bytes found\");\n\t\tPATH_LAST_POSITION(path)--;\n\n\t\tremoved =\n\t\t    reiserfs_delete_item(th, path, &tail_key, inode,\n\t\t\t\t\t NULL   );\n\t\tRFALSE(removed <= 0\n\t\t       || removed > tail_len,\n\t\t       \"vs-5617: there was tail %d bytes, removed item length %d bytes\",\n\t\t       tail_len, removed);\n\t\ttail_len -= removed;\n\t\tset_cpu_key_k_offset(&tail_key,\n\t\t\t\t     cpu_key_k_offset(&tail_key) - removed);\n\t}\n\treiserfs_warning(inode->i_sb, \"reiserfs-5091\", \"indirect_to_direct \"\n\t\t\t \"conversion has been rolled back due to \"\n\t\t\t \"lack of disk space\");\n\tmark_inode_dirty(inode);\n}\n\n \nint reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,\n\t\t\t   struct treepath *path,\n\t\t\t   struct cpu_key *item_key,\n\t\t\t   struct inode *inode,\n\t\t\t   struct page *page, loff_t new_file_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\t \n\tstruct tree_balance s_cut_balance;\n\tstruct item_head *p_le_ih;\n\tint cut_size = 0;\t \n\tint ret_value = CARRY_ON;\n\tint removed = 0;\t \n\tint is_inode_locked = 0;\n\tchar mode;\t\t \n\tint retval2 = -1;\n\tint quota_cut_bytes;\n\tloff_t tail_pos = 0;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tinit_tb_struct(th, &s_cut_balance, inode->i_sb, path,\n\t\t       cut_size);\n\n\t \n\twhile (1) {\n\t\t \n\n\t\tmode =\n\t\t    prepare_for_delete_or_cut(th, inode, path,\n\t\t\t\t\t      item_key, &removed,\n\t\t\t\t\t      &cut_size, new_file_size);\n\t\tif (mode == M_CONVERT) {\n\t\t\t \n\t\t\tRFALSE(ret_value != CARRY_ON,\n\t\t\t       \"PAP-5570: can not convert twice\");\n\n\t\t\tret_value =\n\t\t\t    maybe_indirect_to_direct(th, inode, page,\n\t\t\t\t\t\t     path, item_key,\n\t\t\t\t\t\t     new_file_size, &mode);\n\t\t\tif (mode == M_SKIP_BALANCING)\n\t\t\t\t \n\t\t\t\treturn ret_value;\n\n\t\t\tis_inode_locked = 1;\n\n\t\t\t \n\t\t\tretval2 = ret_value;\n\n\t\t\t \n\t\t\tset_cpu_key_k_type(item_key, TYPE_INDIRECT);\n\t\t\titem_key->key_length = 4;\n\t\t\tnew_file_size -=\n\t\t\t    (new_file_size & (sb->s_blocksize - 1));\n\t\t\ttail_pos = new_file_size;\n\t\t\tset_cpu_key_k_offset(item_key, new_file_size + 1);\n\t\t\tif (search_for_position_by_key\n\t\t\t    (sb, item_key,\n\t\t\t     path) == POSITION_NOT_FOUND) {\n\t\t\t\tprint_block(PATH_PLAST_BUFFER(path), 3,\n\t\t\t\t\t    PATH_LAST_POSITION(path) - 1,\n\t\t\t\t\t    PATH_LAST_POSITION(path) + 1);\n\t\t\t\treiserfs_panic(sb, \"PAP-5580\", \"item to \"\n\t\t\t\t\t       \"convert does not exist (%K)\",\n\t\t\t\t\t       item_key);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (cut_size == 0) {\n\t\t\tpathrelse(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\ts_cut_balance.insert_size[0] = cut_size;\n\n\t\tret_value = fix_nodes(mode, &s_cut_balance, NULL, NULL);\n\t\tif (ret_value != REPEAT_SEARCH)\n\t\t\tbreak;\n\n\t\tPROC_INFO_INC(sb, cut_from_item_restarted);\n\n\t\tret_value =\n\t\t    search_for_position_by_key(sb, item_key, path);\n\t\tif (ret_value == POSITION_FOUND)\n\t\t\tcontinue;\n\n\t\treiserfs_warning(sb, \"PAP-5610\", \"item %K not found\",\n\t\t\t\t item_key);\n\t\tunfix_nodes(&s_cut_balance);\n\t\treturn (ret_value == IO_ERROR) ? -EIO : -ENOENT;\n\t}\t\t\t \n\n\t \n\tif (ret_value != CARRY_ON) {\n\t\tif (is_inode_locked) {\n\t\t\t \n\t\t\tindirect_to_direct_roll_back(th, inode, path);\n\t\t}\n\t\tif (ret_value == NO_DISK_SPACE)\n\t\t\treiserfs_warning(sb, \"reiserfs-5092\",\n\t\t\t\t\t \"NO_DISK_SPACE\");\n\t\tunfix_nodes(&s_cut_balance);\n\t\treturn -EIO;\n\t}\n\n\t \n\n\tRFALSE(mode == M_PASTE || mode == M_INSERT, \"invalid mode\");\n\n\t \n\tquota_cut_bytes =\n\t    (mode ==\n\t     M_DELETE) ? ih_item_len(tp_item_head(path)) : -s_cut_balance.\n\t    insert_size[0];\n\tif (retval2 == -1)\n\t\tret_value = calc_deleted_bytes_number(&s_cut_balance, mode);\n\telse\n\t\tret_value = retval2;\n\n\t \n\tp_le_ih = tp_item_head(s_cut_balance.tb_path);\n\tif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(p_le_ih)) {\n\t\tif (mode == M_DELETE &&\n\t\t    (le_ih_k_offset(p_le_ih) & (sb->s_blocksize - 1)) ==\n\t\t    1) {\n\t\t\t \n\t\t\tREISERFS_I(inode)->i_first_direct_byte = U32_MAX;\n\t\t\tquota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;\n\t\t} else {\n\t\t\tquota_cut_bytes = 0;\n\t\t}\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\tif (is_inode_locked) {\n\t\tstruct item_head *le_ih =\n\t\t    tp_item_head(s_cut_balance.tb_path);\n\t\t \n\t\tif (!is_indirect_le_ih(le_ih))\n\t\t\treiserfs_panic(sb, \"vs-5652\",\n\t\t\t\t       \"item must be indirect %h\", le_ih);\n\n\t\tif (mode == M_DELETE && ih_item_len(le_ih) != UNFM_P_SIZE)\n\t\t\treiserfs_panic(sb, \"vs-5653\", \"completing \"\n\t\t\t\t       \"indirect2direct conversion indirect \"\n\t\t\t\t       \"item %h being deleted must be of \"\n\t\t\t\t       \"4 byte long\", le_ih);\n\n\t\tif (mode == M_CUT\n\t\t    && s_cut_balance.insert_size[0] != -UNFM_P_SIZE) {\n\t\t\treiserfs_panic(sb, \"vs-5654\", \"can not complete \"\n\t\t\t\t       \"indirect2direct conversion of %h \"\n\t\t\t\t       \"(CUT, insert_size==%d)\",\n\t\t\t\t       le_ih, s_cut_balance.insert_size[0]);\n\t\t}\n\t\t \n\t}\n#endif\n\n\tdo_balance(&s_cut_balance, NULL, NULL, mode);\n\tif (is_inode_locked) {\n\t\t \n\t\tunmap_buffers(page, tail_pos);\n\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\t}\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota cut_from_item(): freeing %u id=%u type=%c\",\n\t\t       quota_cut_bytes, inode->i_uid, '?');\n#endif\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tdquot_free_space_nodirty(inode, quota_cut_bytes);\n\treiserfs_write_lock_nested(sb, depth);\n\treturn ret_value;\n}\n\nstatic void truncate_directory(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode)\n{\n\tBUG_ON(!th->t_trans_id);\n\tif (inode->i_nlink)\n\t\treiserfs_error(inode->i_sb, \"vs-5655\", \"link count != 0\");\n\n\tset_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), DOT_OFFSET);\n\tset_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_DIRENTRY);\n\treiserfs_delete_solid_item(th, inode, INODE_PKEY(inode));\n\treiserfs_update_sd(th, inode);\n\tset_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), SD_OFFSET);\n\tset_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_STAT_DATA);\n}\n\n \nint reiserfs_do_truncate(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode,\t \n\t\t\t struct page *page,\t \n\t\t\t  \n\t\t\t int update_timestamps\n    )\n{\n\tINITIALIZE_PATH(s_search_path);\t \n\tstruct item_head *p_le_ih;\t \n\n\t \n\tstruct cpu_key s_item_key;\n\tloff_t file_size,\t \n\t new_file_size;\t \n\tint deleted;\t\t \n\tint retval;\n\tint err = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\tif (!\n\t    (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)\n\t     || S_ISLNK(inode->i_mode)))\n\t\treturn 0;\n\n\t \n\tif (S_ISDIR(inode->i_mode)) {\n\t\ttruncate_directory(th, inode);\n\t\treturn 0;\n\t}\n\n\t \n\tnew_file_size = inode->i_size;\n\n\t \n\tmake_cpu_key(&s_item_key, inode, max_reiserfs_offset(inode),\n\t\t     TYPE_DIRECT, 3);\n\n\tretval =\n\t    search_for_position_by_key(inode->i_sb, &s_item_key,\n\t\t\t\t       &s_search_path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(inode->i_sb, \"vs-5657\",\n\t\t\t       \"i/o failure occurred trying to truncate %K\",\n\t\t\t       &s_item_key);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\tif (retval == POSITION_FOUND || retval == FILE_NOT_FOUND) {\n\t\treiserfs_error(inode->i_sb, \"PAP-5660\",\n\t\t\t       \"wrong result %d of search for %K\", retval,\n\t\t\t       &s_item_key);\n\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\ts_search_path.pos_in_item--;\n\n\t \n\tp_le_ih = tp_item_head(&s_search_path);\n\tif (is_statdata_le_ih(p_le_ih))\n\t\tfile_size = 0;\n\telse {\n\t\tloff_t offset = le_ih_k_offset(p_le_ih);\n\t\tint bytes =\n\t\t    op_bytes_number(p_le_ih, inode->i_sb->s_blocksize);\n\n\t\t \n\t\tfile_size = offset + bytes - 1;\n\t}\n\t \n\tif (new_file_size == 0)\n\t\ts_search_path.reada = PATH_READA | PATH_READA_BACK;\n\n\tif (file_size == 0 || file_size < new_file_size) {\n\t\tgoto update_and_out;\n\t}\n\n\t \n\tset_cpu_key_k_offset(&s_item_key, file_size);\n\n\tdo {\n\t\t \n\t\tdeleted =\n\t\t    reiserfs_cut_from_item(th, &s_search_path, &s_item_key,\n\t\t\t\t\t   inode, page, new_file_size);\n\t\tif (deleted < 0) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-5665\",\n\t\t\t\t\t \"reiserfs_cut_from_item failed\");\n\t\t\treiserfs_check_path(&s_search_path);\n\t\t\treturn 0;\n\t\t}\n\n\t\tRFALSE(deleted > file_size,\n\t\t       \"PAP-5670: reiserfs_cut_from_item: too many bytes deleted: deleted %d, file_size %lu, item_key %K\",\n\t\t       deleted, file_size, &s_item_key);\n\n\t\t \n\t\tfile_size -= deleted;\n\n\t\tset_cpu_key_k_offset(&s_item_key, file_size);\n\n\t\t \n\n\t\t \n\t\tif (journal_transaction_should_end(th, 0) ||\n\t\t    reiserfs_transaction_free_space(th) <= JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD) {\n\t\t\tpathrelse(&s_search_path);\n\n\t\t\tif (update_timestamps) {\n\t\t\t\tinode->i_mtime = current_time(inode);\n\t\t\t\tinode_set_ctime_current(inode);\n\t\t\t}\n\t\t\treiserfs_update_sd(th, inode);\n\n\t\t\terr = journal_end(th);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = journal_begin(th, inode->i_sb,\n\t\t\t\t\t    JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD + JOURNAL_PER_BALANCE_CNT * 4) ;\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\treiserfs_update_inode_transaction(inode);\n\t\t}\n\t} while (file_size > ROUND_UP(new_file_size) &&\n\t\t search_for_position_by_key(inode->i_sb, &s_item_key,\n\t\t\t\t\t    &s_search_path) == POSITION_FOUND);\n\n\tRFALSE(file_size > ROUND_UP(new_file_size),\n\t       \"PAP-5680: truncate did not finish: new_file_size %lld, current %lld, oid %d\",\n\t       new_file_size, file_size, s_item_key.on_disk_key.k_objectid);\n\nupdate_and_out:\n\tif (update_timestamps) {\n\t\t \n\t\tinode->i_mtime = current_time(inode);\n\t\tinode_set_ctime_current(inode);\n\t}\n\treiserfs_update_sd(th, inode);\n\nout:\n\tpathrelse(&s_search_path);\n\treturn err;\n}\n\n#ifdef CONFIG_REISERFS_CHECK\n \nstatic void check_research_for_paste(struct treepath *path,\n\t\t\t\t     const struct cpu_key *key)\n{\n\tstruct item_head *found_ih = tp_item_head(path);\n\n\tif (is_direct_le_ih(found_ih)) {\n\t\tif (le_ih_k_offset(found_ih) +\n\t\t    op_bytes_number(found_ih,\n\t\t\t\t    get_last_bh(path)->b_size) !=\n\t\t    cpu_key_k_offset(key)\n\t\t    || op_bytes_number(found_ih,\n\t\t\t\t       get_last_bh(path)->b_size) !=\n\t\t    pos_in_item(path))\n\t\t\treiserfs_panic(NULL, \"PAP-5720\", \"found direct item \"\n\t\t\t\t       \"%h or position (%d) does not match \"\n\t\t\t\t       \"to key %K\", found_ih,\n\t\t\t\t       pos_in_item(path), key);\n\t}\n\tif (is_indirect_le_ih(found_ih)) {\n\t\tif (le_ih_k_offset(found_ih) +\n\t\t    op_bytes_number(found_ih,\n\t\t\t\t    get_last_bh(path)->b_size) !=\n\t\t    cpu_key_k_offset(key)\n\t\t    || I_UNFM_NUM(found_ih) != pos_in_item(path)\n\t\t    || get_ih_free_space(found_ih) != 0)\n\t\t\treiserfs_panic(NULL, \"PAP-5730\", \"found indirect \"\n\t\t\t\t       \"item (%h) or position (%d) does not \"\n\t\t\t\t       \"match to key (%K)\",\n\t\t\t\t       found_ih, pos_in_item(path), key);\n\t}\n}\n#endif\t\t\t\t \n\n \nint reiserfs_paste_into_item(struct reiserfs_transaction_handle *th,\n\t\t\t      \n\t\t\t     struct treepath *search_path,\n\t\t\t      \n\t\t\t     const struct cpu_key *key,\n\t\t\t      \n\t\t\t     struct inode *inode,\n\t\t\t      \n\t\t\t     const char *body,\n\t\t\t      \n\t\t\t     int pasted_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct tree_balance s_paste_balance;\n\tint retval;\n\tint fs_gen;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tfs_gen = get_generation(inode->i_sb);\n\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota paste_into_item(): allocating %u id=%u type=%c\",\n\t\t       pasted_size, inode->i_uid,\n\t\t       key2type(&key->on_disk_key));\n#endif\n\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tretval = dquot_alloc_space_nodirty(inode, pasted_size);\n\treiserfs_write_lock_nested(sb, depth);\n\tif (retval) {\n\t\tpathrelse(search_path);\n\t\treturn retval;\n\t}\n\tinit_tb_struct(th, &s_paste_balance, th->t_super, search_path,\n\t\t       pasted_size);\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\ts_paste_balance.key = key->on_disk_key;\n#endif\n\n\t \n\tif (fs_changed(fs_gen, inode->i_sb)) {\n\t\tgoto search_again;\n\t}\n\n\twhile ((retval =\n\t\tfix_nodes(M_PASTE, &s_paste_balance, NULL,\n\t\t\t  body)) == REPEAT_SEARCH) {\nsearch_again:\n\t\t \n\t\tPROC_INFO_INC(th->t_super, paste_into_item_restarted);\n\t\tretval =\n\t\t    search_for_position_by_key(th->t_super, key,\n\t\t\t\t\t       search_path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"PAP-5710\",\n\t\t\t\t\t \"entry or pasted byte (%K) exists\",\n\t\t\t\t\t key);\n\t\t\tretval = -EEXIST;\n\t\t\tgoto error_out;\n\t\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t\tcheck_research_for_paste(search_path, key);\n#endif\n\t}\n\n\t \n\tif (retval == CARRY_ON) {\n\t\tdo_balance(&s_paste_balance, NULL   , body, M_PASTE);\n\t\treturn 0;\n\t}\n\tretval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;\nerror_out:\n\t \n\tunfix_nodes(&s_paste_balance);\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota paste_into_item(): freeing %u id=%u type=%c\",\n\t\t       pasted_size, inode->i_uid,\n\t\t       key2type(&key->on_disk_key));\n#endif\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tdquot_free_space_nodirty(inode, pasted_size);\n\treiserfs_write_lock_nested(sb, depth);\n\treturn retval;\n}\n\n \nint reiserfs_insert_item(struct reiserfs_transaction_handle *th,\n\t\t\t struct treepath *path, const struct cpu_key *key,\n\t\t\t struct item_head *ih, struct inode *inode,\n\t\t\t const char *body)\n{\n\tstruct tree_balance s_ins_balance;\n\tint retval;\n\tint fs_gen = 0;\n\tint quota_bytes = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tif (inode) {\t\t \n\t\tint depth;\n\t\tfs_gen = get_generation(inode->i_sb);\n\t\tquota_bytes = ih_item_len(ih);\n\n\t\t \n\t\tif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(ih))\n\t\t\tquota_bytes = inode->i_sb->s_blocksize + UNFM_P_SIZE;\n#ifdef REISERQUOTA_DEBUG\n\t\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"reiserquota insert_item(): allocating %u id=%u type=%c\",\n\t\t\t       quota_bytes, inode->i_uid, head2type(ih));\n#endif\n\t\t \n\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tretval = dquot_alloc_space_nodirty(inode, quota_bytes);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\tif (retval) {\n\t\t\tpathrelse(path);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tinit_tb_struct(th, &s_ins_balance, th->t_super, path,\n\t\t       IH_SIZE + ih_item_len(ih));\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\ts_ins_balance.key = key->on_disk_key;\n#endif\n\t \n\tif (inode && fs_changed(fs_gen, inode->i_sb)) {\n\t\tgoto search_again;\n\t}\n\n\twhile ((retval =\n\t\tfix_nodes(M_INSERT, &s_ins_balance, ih,\n\t\t\t  body)) == REPEAT_SEARCH) {\nsearch_again:\n\t\t \n\t\tPROC_INFO_INC(th->t_super, insert_item_restarted);\n\t\tretval = search_item(th->t_super, key, path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tif (retval == ITEM_FOUND) {\n\t\t\treiserfs_warning(th->t_super, \"PAP-5760\",\n\t\t\t\t\t \"key %K already exists in the tree\",\n\t\t\t\t\t key);\n\t\t\tretval = -EEXIST;\n\t\t\tgoto error_out;\n\t\t}\n\t}\n\n\t \n\tif (retval == CARRY_ON) {\n\t\tdo_balance(&s_ins_balance, ih, body, M_INSERT);\n\t\treturn 0;\n\t}\n\n\tretval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;\nerror_out:\n\t \n\tunfix_nodes(&s_ins_balance);\n#ifdef REISERQUOTA_DEBUG\n\tif (inode)\n\t\treiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota insert_item(): freeing %u id=%u type=%c\",\n\t\t       quota_bytes, inode->i_uid, head2type(ih));\n#endif\n\tif (inode) {\n\t\tint depth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tdquot_free_space_nodirty(inode, quota_bytes);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t}\n\treturn retval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}