{
  "module_name": "xattr_security.c",
  "hash_id": "c89316ef6816ad4dd9d19615e20841bd470d90cecd16f74bf87cb15aa6eb0cb6",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/xattr_security.c",
  "human_readable_source": "\n#include \"reiserfs.h\"\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xattr.h\"\n#include <linux/security.h>\n#include <linux/uaccess.h>\n\nstatic int\nsecurity_get(const struct xattr_handler *handler, struct dentry *unused,\n\t     struct inode *inode, const char *name, void *buffer, size_t size)\n{\n\tif (IS_PRIVATE(inode))\n\t\treturn -EPERM;\n\n\treturn reiserfs_xattr_get(inode, xattr_full_name(handler, name),\n\t\t\t\t  buffer, size);\n}\n\nstatic int\nsecurity_set(const struct xattr_handler *handler,\n\t     struct mnt_idmap *idmap, struct dentry *unused,\n\t     struct inode *inode, const char *name, const void *buffer,\n\t     size_t size, int flags)\n{\n\tif (IS_PRIVATE(inode))\n\t\treturn -EPERM;\n\n\treturn reiserfs_xattr_set(inode,\n\t\t\t\t  xattr_full_name(handler, name),\n\t\t\t\t  buffer, size, flags);\n}\n\nstatic bool security_list(struct dentry *dentry)\n{\n\treturn !IS_PRIVATE(d_inode(dentry));\n}\n\nstatic int\nreiserfs_initxattrs(struct inode *inode, const struct xattr *xattr_array,\n\t\t    void *fs_info)\n{\n\tstruct reiserfs_security_handle *sec = fs_info;\n\n\tsec->value = kmemdup(xattr_array->value, xattr_array->value_len,\n\t\t\t     GFP_KERNEL);\n\tif (!sec->value)\n\t\treturn -ENOMEM;\n\n\tsec->name = xattr_array->name;\n\tsec->length = xattr_array->value_len;\n\treturn 0;\n}\n\n \nint reiserfs_security_init(struct inode *dir, struct inode *inode,\n\t\t\t   const struct qstr *qstr,\n\t\t\t   struct reiserfs_security_handle *sec)\n{\n\tint blocks = 0;\n\tint error;\n\n\tsec->name = NULL;\n\tsec->value = NULL;\n\tsec->length = 0;\n\n\t \n\tif (IS_PRIVATE(dir))\n\t\treturn 0;\n\n\terror = security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t     &reiserfs_initxattrs, sec);\n\tif (error) {\n\t\tsec->name = NULL;\n\t\tsec->value = NULL;\n\t\tsec->length = 0;\n\t\treturn error;\n\t}\n\n\tif (sec->length && reiserfs_xattrs_initialized(inode->i_sb)) {\n\t\tblocks = reiserfs_xattr_jcreate_nblocks(inode) +\n\t\t\t reiserfs_xattr_nblocks(inode, sec->length);\n\t\t \n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\t}\n\treturn blocks;\n}\n\nint reiserfs_security_write(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode,\n\t\t\t    struct reiserfs_security_handle *sec)\n{\n\tchar xattr_name[XATTR_NAME_MAX + 1] = XATTR_SECURITY_PREFIX;\n\tint error;\n\n\tif (XATTR_SECURITY_PREFIX_LEN + strlen(sec->name) > XATTR_NAME_MAX)\n\t\treturn -EINVAL;\n\n\tstrlcat(xattr_name, sec->name, sizeof(xattr_name));\n\n\terror = reiserfs_xattr_set_handle(th, inode, xattr_name, sec->value,\n\t\t\t\t\t  sec->length, XATTR_CREATE);\n\tif (error == -ENODATA || error == -EOPNOTSUPP)\n\t\terror = 0;\n\n\treturn error;\n}\n\nvoid reiserfs_security_free(struct reiserfs_security_handle *sec)\n{\n\tkfree(sec->value);\n\tsec->name = NULL;\n\tsec->value = NULL;\n}\n\nconst struct xattr_handler reiserfs_xattr_security_handler = {\n\t.prefix = XATTR_SECURITY_PREFIX,\n\t.get = security_get,\n\t.set = security_set,\n\t.list = security_list,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}