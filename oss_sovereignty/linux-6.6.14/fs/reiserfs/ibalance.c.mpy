{
  "module_name": "ibalance.c",
  "hash_id": "3fb0bbfa9c04bac0122ec028d33f5540d3395cf7ce012b6f87d67e86d68f8afe",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/ibalance.c",
  "human_readable_source": " \n\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include \"reiserfs.h\"\n#include <linux/buffer_head.h>\n\n \nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\n \n#define INTERNAL_SHIFT_FROM_S_TO_L 0\n#define INTERNAL_SHIFT_FROM_R_TO_S 1\n#define INTERNAL_SHIFT_FROM_L_TO_S 2\n#define INTERNAL_SHIFT_FROM_S_TO_R 3\n#define INTERNAL_INSERT_TO_S 4\n#define INTERNAL_INSERT_TO_L 5\n#define INTERNAL_INSERT_TO_R 6\n\nstatic void internal_define_dest_src_infos(int shift_mode,\n\t\t\t\t\t   struct tree_balance *tb,\n\t\t\t\t\t   int h,\n\t\t\t\t\t   struct buffer_info *dest_bi,\n\t\t\t\t\t   struct buffer_info *src_bi,\n\t\t\t\t\t   int *d_key, struct buffer_head **cf)\n{\n\tmemset(dest_bi, 0, sizeof(struct buffer_info));\n\tmemset(src_bi, 0, sizeof(struct buffer_info));\n\t \n\tswitch (shift_mode) {\n\n\t \n\tcase INTERNAL_SHIFT_FROM_S_TO_L:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\tcase INTERNAL_SHIFT_FROM_L_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->L[h];\n\t\tsrc_bi->bi_parent = tb->FL[h];\n\t\tsrc_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\t \n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\n\t \n\tcase INTERNAL_SHIFT_FROM_R_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->R[h];\n\t\tsrc_bi->bi_parent = tb->FR[h];\n\t\tsrc_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_SHIFT_FROM_S_TO_R:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_L:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_S:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_R:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tbreak;\n\n\tdefault:\n\t\treiserfs_panic(tb->tb_sb, \"ibalance-1\",\n\t\t\t       \"shift type is unknown (%d)\",\n\t\t\t       shift_mode);\n\t}\n}\n\n \nstatic void internal_insert_childs(struct buffer_info *cur_bi,\n\t\t\t\t   int to, int count,\n\t\t\t\t   struct item_head *inserted,\n\t\t\t\t   struct buffer_head **bh)\n{\n\tstruct buffer_head *cur = cur_bi->bi_bh;\n\tstruct block_head *blkh;\n\tint nr;\n\tstruct reiserfs_key *ih;\n\tstruct disk_child new_dc[2];\n\tstruct disk_child *dc;\n\tint i;\n\n\tif (count <= 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(cur);\n\tnr = blkh_nr_item(blkh);\n\n\tRFALSE(count > 2, \"too many children (%d) are to be inserted\", count);\n\tRFALSE(B_FREE_SPACE(cur) < count * (KEY_SIZE + DC_SIZE),\n\t       \"no enough free space (%d), needed %d bytes\",\n\t       B_FREE_SPACE(cur), count * (KEY_SIZE + DC_SIZE));\n\n\t \n\tdc = B_N_CHILD(cur, to + 1);\n\n\tmemmove(dc + count, dc, (nr + 1 - (to + 1)) * DC_SIZE);\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tput_dc_size(&new_dc[i],\n\t\t\t    MAX_CHILD_SIZE(bh[i]) - B_FREE_SPACE(bh[i]));\n\t\tput_dc_block_number(&new_dc[i], bh[i]->b_blocknr);\n\t}\n\tmemcpy(dc, new_dc, DC_SIZE * count);\n\n\t \n\tih = internal_key(cur, ((to == -1) ? 0 : to));\n\n\tmemmove(ih + count, ih,\n\t\t(nr - to) * KEY_SIZE + (nr + 1 + count) * DC_SIZE);\n\n\t \n\tmemcpy(ih, inserted, KEY_SIZE);\n\tif (count > 1)\n\t\tmemcpy(ih + 1, inserted + 1, KEY_SIZE);\n\n\t \n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + count);\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) - count * (DC_SIZE +\n\t\t\t\t\t\t\t     KEY_SIZE));\n\n\tdo_balance_mark_internal_dirty(cur_bi->tb, cur, 0);\n\n\t \n\tcheck_internal(cur);\n\t \n\n\tif (cur_bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(cur_bi->bi_parent, cur_bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (count * (DC_SIZE + KEY_SIZE)));\n\t\tdo_balance_mark_internal_dirty(cur_bi->tb, cur_bi->bi_parent,\n\t\t\t\t\t       0);\n\n\t\t \n\t\tcheck_internal(cur_bi->bi_parent);\n\t\t \n\t}\n\n}\n\n \nstatic void internal_delete_pointers_items(struct buffer_info *cur_bi,\n\t\t\t\t\t   int first_p,\n\t\t\t\t\t   int first_i, int del_num)\n{\n\tstruct buffer_head *cur = cur_bi->bi_bh;\n\tint nr;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\tstruct disk_child *dc;\n\n\tRFALSE(cur == NULL, \"buffer is 0\");\n\tRFALSE(del_num < 0,\n\t       \"negative number of items (%d) can not be deleted\", del_num);\n\tRFALSE(first_p < 0 || first_p + del_num > B_NR_ITEMS(cur) + 1\n\t       || first_i < 0,\n\t       \"first pointer order (%d) < 0 or \"\n\t       \"no so many pointers (%d), only (%d) or \"\n\t       \"first key order %d < 0\", first_p, first_p + del_num,\n\t       B_NR_ITEMS(cur) + 1, first_i);\n\tif (del_num == 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(cur);\n\tnr = blkh_nr_item(blkh);\n\n\tif (first_p == 0 && del_num == nr + 1) {\n\t\tRFALSE(first_i != 0,\n\t\t       \"1st deleted key must have order 0, not %d\", first_i);\n\t\tmake_empty_node(cur_bi);\n\t\treturn;\n\t}\n\n\tRFALSE(first_i + del_num > B_NR_ITEMS(cur),\n\t       \"first_i = %d del_num = %d \"\n\t       \"no so many keys (%d) in the node (%b)(%z)\",\n\t       first_i, del_num, first_i + del_num, cur, cur);\n\n\t \n\tdc = B_N_CHILD(cur, first_p);\n\n\tmemmove(dc, dc + del_num, (nr + 1 - first_p - del_num) * DC_SIZE);\n\tkey = internal_key(cur, first_i);\n\tmemmove(key, key + del_num,\n\t\t(nr - first_i - del_num) * KEY_SIZE + (nr + 1 -\n\t\t\t\t\t\t       del_num) * DC_SIZE);\n\n\t \n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) - del_num);\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) +\n\t\t\t    (del_num * (KEY_SIZE + DC_SIZE)));\n\n\tdo_balance_mark_internal_dirty(cur_bi->tb, cur, 0);\n\t \n\tcheck_internal(cur);\n\t \n\n\tif (cur_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(cur_bi->bi_parent, cur_bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) - (del_num * (KEY_SIZE + DC_SIZE)));\n\n\t\tdo_balance_mark_internal_dirty(cur_bi->tb, cur_bi->bi_parent,\n\t\t\t\t\t       0);\n\t\t \n\t\tcheck_internal(cur_bi->bi_parent);\n\t\t \n\t}\n}\n\n \nstatic void internal_delete_childs(struct buffer_info *cur_bi, int from, int n)\n{\n\tint i_from;\n\n\ti_from = (from == 0) ? from : from - 1;\n\n\t \n\tinternal_delete_pointers_items(cur_bi, from, i_from, n);\n}\n\n \nstatic void internal_copy_pointers_items(struct buffer_info *dest_bi,\n\t\t\t\t\t struct buffer_head *src,\n\t\t\t\t\t int last_first, int cpy_num)\n{\n\t \n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tint nr_dest, nr_src;\n\tint dest_order, src_order;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\tstruct disk_child *dc;\n\n\tnr_src = B_NR_ITEMS(src);\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"src (%p) or dest (%p) buffer is 0\", src, dest);\n\tRFALSE(last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST,\n\t       \"invalid last_first parameter (%d)\", last_first);\n\tRFALSE(nr_src < cpy_num - 1,\n\t       \"no so many items (%d) in src (%d)\", cpy_num, nr_src);\n\tRFALSE(cpy_num < 0, \"cpy_num less than 0 (%d)\", cpy_num);\n\tRFALSE(cpy_num - 1 + B_NR_ITEMS(dest) > (int)MAX_NR_KEY(dest),\n\t       \"cpy_num (%d) + item number in dest (%d) can not be > MAX_NR_KEY(%d)\",\n\t       cpy_num, B_NR_ITEMS(dest), MAX_NR_KEY(dest));\n\n\tif (cpy_num == 0)\n\t\treturn;\n\n\t \n\tblkh = B_BLK_HEAD(dest);\n\tnr_dest = blkh_nr_item(blkh);\n\n\t \n\t \n\t(last_first == LAST_TO_FIRST) ? (dest_order = 0, src_order =\n\t\t\t\t\t nr_src - cpy_num + 1) : (dest_order =\n\t\t\t\t\t\t\t\t  nr_dest,\n\t\t\t\t\t\t\t\t  src_order =\n\t\t\t\t\t\t\t\t  0);\n\n\t \n\tdc = B_N_CHILD(dest, dest_order);\n\n\tmemmove(dc + cpy_num, dc, (nr_dest - dest_order) * DC_SIZE);\n\n\t \n\tmemcpy(dc, B_N_CHILD(src, src_order), DC_SIZE * cpy_num);\n\n\t \n\tkey = internal_key(dest, dest_order);\n\tmemmove(key + cpy_num - 1, key,\n\t\tKEY_SIZE * (nr_dest - dest_order) + DC_SIZE * (nr_dest +\n\t\t\t\t\t\t\t       cpy_num));\n\n\t \n\tmemcpy(key, internal_key(src, src_order), KEY_SIZE * (cpy_num - 1));\n\n\t \n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + (cpy_num - 1));\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) - (KEY_SIZE * (cpy_num - 1) +\n\t\t\t\t\t\t     DC_SIZE * cpy_num));\n\n\tdo_balance_mark_internal_dirty(dest_bi->tb, dest, 0);\n\n\t \n\tcheck_internal(dest);\n\t \n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (KEY_SIZE * (cpy_num - 1) +\n\t\t\t\t\t     DC_SIZE * cpy_num));\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t\t \n\t\tcheck_internal(dest_bi->bi_parent);\n\t\t \n\t}\n\n}\n\n \nstatic void internal_move_pointers_items(struct buffer_info *dest_bi,\n\t\t\t\t\t struct buffer_info *src_bi,\n\t\t\t\t\t int last_first, int cpy_num,\n\t\t\t\t\t int del_par)\n{\n\tint first_pointer;\n\tint first_item;\n\n\tinternal_copy_pointers_items(dest_bi, src_bi->bi_bh, last_first,\n\t\t\t\t     cpy_num);\n\n\tif (last_first == FIRST_TO_LAST) {\t \n\t\tfirst_pointer = 0;\n\t\tfirst_item = 0;\n\t\t \n\t\tinternal_delete_pointers_items(src_bi, first_pointer,\n\t\t\t\t\t       first_item, cpy_num - del_par);\n\t} else {\t\t \n\t\tint i, j;\n\n\t\ti = (cpy_num - del_par ==\n\t\t     (j =\n\t\t      B_NR_ITEMS(src_bi->bi_bh)) + 1) ? 0 : j - cpy_num +\n\t\t    del_par;\n\n\t\tinternal_delete_pointers_items(src_bi,\n\t\t\t\t\t       j + 1 - cpy_num + del_par, i,\n\t\t\t\t\t       cpy_num - del_par);\n\t}\n}\n\n \nstatic void internal_insert_key(struct buffer_info *dest_bi,\n\t\t\t\t \n\t\t\t\tint dest_position_before,\n\t\t\t\tstruct buffer_head *src, int src_position)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tint nr;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"source(%p) or dest(%p) buffer is 0\", src, dest);\n\tRFALSE(dest_position_before < 0 || src_position < 0,\n\t       \"source(%d) or dest(%d) key number less than 0\",\n\t       src_position, dest_position_before);\n\tRFALSE(dest_position_before > B_NR_ITEMS(dest) ||\n\t       src_position >= B_NR_ITEMS(src),\n\t       \"invalid position in dest (%d (key number %d)) or in src (%d (key number %d))\",\n\t       dest_position_before, B_NR_ITEMS(dest),\n\t       src_position, B_NR_ITEMS(src));\n\tRFALSE(B_FREE_SPACE(dest) < KEY_SIZE,\n\t       \"no enough free space (%d) in dest buffer\", B_FREE_SPACE(dest));\n\n\tblkh = B_BLK_HEAD(dest);\n\tnr = blkh_nr_item(blkh);\n\n\t \n\tkey = internal_key(dest, dest_position_before);\n\tmemmove(key + 1, key,\n\t\t(nr - dest_position_before) * KEY_SIZE + (nr + 1) * DC_SIZE);\n\n\t \n\tmemcpy(key, internal_key(src, src_position), KEY_SIZE);\n\n\t \n\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh, blkh_free_space(blkh) - KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(dest_bi->tb, dest, 0);\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + KEY_SIZE);\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t}\n}\n\n \n \nstatic void internal_shift_left(\n\t\t\t\t \n\t\t\t\tint mode,\n\t\t\t\tstruct tree_balance *tb,\n\t\t\t\tint h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\n\tinternal_define_dest_src_infos(mode, tb, h, &dest_bi, &src_bi,\n\t\t\t\t       &d_key_position, &cf);\n\n\t \n\n\tif (pointer_amount) {\n\t\t \n\t\tinternal_insert_key(&dest_bi, B_NR_ITEMS(dest_bi.bi_bh), cf,\n\t\t\t\t    d_key_position);\n\n\t\tif (B_NR_ITEMS(src_bi.bi_bh) == pointer_amount - 1) {\n\t\t\tif (src_bi.bi_position    == 0)\n\t\t\t\treplace_key(tb, cf, d_key_position,\n\t\t\t\t\t    src_bi.\n\t\t\t\t\t    bi_parent   , 0);\n\t\t} else\n\t\t\treplace_key(tb, cf, d_key_position, src_bi.bi_bh,\n\t\t\t\t    pointer_amount - 1);\n\t}\n\t \n\tinternal_move_pointers_items(&dest_bi, &src_bi, FIRST_TO_LAST,\n\t\t\t\t     pointer_amount, 0);\n\n}\n\n \n \nstatic void internal_shift1_left(struct tree_balance *tb,\n\t\t\t\t int h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\n\tinternal_define_dest_src_infos(INTERNAL_SHIFT_FROM_S_TO_L, tb, h,\n\t\t\t\t       &dest_bi, &src_bi, &d_key_position, &cf);\n\n\t \n\tif (pointer_amount > 0)\n\t\tinternal_insert_key(&dest_bi, B_NR_ITEMS(dest_bi.bi_bh), cf,\n\t\t\t\t    d_key_position);\n\n\t \n\tinternal_move_pointers_items(&dest_bi, &src_bi, FIRST_TO_LAST,\n\t\t\t\t     pointer_amount, 1);\n}\n\n \nstatic void internal_shift_right(\n\t\t\t\t  \n\t\t\t\t int mode,\n\t\t\t\t struct tree_balance *tb,\n\t\t\t\t int h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\tint nr;\n\n\tinternal_define_dest_src_infos(mode, tb, h, &dest_bi, &src_bi,\n\t\t\t\t       &d_key_position, &cf);\n\n\tnr = B_NR_ITEMS(src_bi.bi_bh);\n\n\tif (pointer_amount > 0) {\n\t\t \n\t\tinternal_insert_key(&dest_bi, 0, cf, d_key_position);\n\t\tif (nr == pointer_amount - 1) {\n\t\t\tRFALSE(src_bi.bi_bh != PATH_H_PBUFFER(tb->tb_path, h)   ||\n\t\t\t       dest_bi.bi_bh != tb->R[h],\n\t\t\t       \"src (%p) must be == tb->S[h](%p) when it disappears\",\n\t\t\t       src_bi.bi_bh, PATH_H_PBUFFER(tb->tb_path, h));\n\t\t\t \n\t\t\tif (tb->CFL[h])\n\t\t\t\treplace_key(tb, cf, d_key_position, tb->CFL[h],\n\t\t\t\t\t    tb->lkey[h]);\n\t\t} else\n\t\t\treplace_key(tb, cf, d_key_position, src_bi.bi_bh,\n\t\t\t\t    nr - pointer_amount);\n\t}\n\n\t \n\tinternal_move_pointers_items(&dest_bi, &src_bi, LAST_TO_FIRST,\n\t\t\t\t     pointer_amount, 0);\n}\n\n \n \nstatic void internal_shift1_right(struct tree_balance *tb,\n\t\t\t\t  int h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\n\tinternal_define_dest_src_infos(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t       &dest_bi, &src_bi, &d_key_position, &cf);\n\n\t \n\tif (pointer_amount > 0)\n\t\tinternal_insert_key(&dest_bi, 0, cf, d_key_position);\n\n\t \n\tinternal_move_pointers_items(&dest_bi, &src_bi, LAST_TO_FIRST,\n\t\t\t\t     pointer_amount, 1);\n}\n\n \nstatic void balance_internal_when_delete(struct tree_balance *tb,\n\t\t\t\t\t int h, int child_pos)\n{\n\tint insert_num;\n\tint n;\n\tstruct buffer_head *tbSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tstruct buffer_info bi;\n\n\tinsert_num = tb->insert_size[h] / ((int)(DC_SIZE + KEY_SIZE));\n\n\t \n\tbi.tb = tb;\n\tbi.bi_bh = tbSh;\n\tbi.bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\tbi.bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tinternal_delete_childs(&bi, child_pos, -insert_num);\n\n\tRFALSE(tb->blknum[h] > 1,\n\t       \"tb->blknum[%d]=%d when insert_size < 0\", h, tb->blknum[h]);\n\n\tn = B_NR_ITEMS(tbSh);\n\n\tif (tb->lnum[h] == 0 && tb->rnum[h] == 0) {\n\t\tif (tb->blknum[h] == 0) {\n\t\t\t \n\t\t\tstruct buffer_head *new_root;\n\n\t\t\tRFALSE(n\n\t\t\t       || B_FREE_SPACE(tbSh) !=\n\t\t\t       MAX_CHILD_SIZE(tbSh) - DC_SIZE,\n\t\t\t       \"buffer must have only 0 keys (%d)\", n);\n\t\t\tRFALSE(bi.bi_parent, \"root has parent (%p)\",\n\t\t\t       bi.bi_parent);\n\n\t\t\t \n\t\t\tif (!tb->L[h - 1] || !B_NR_ITEMS(tb->L[h - 1]))\n\t\t\t\tnew_root = tb->R[h - 1];\n\t\t\telse\n\t\t\t\tnew_root = tb->L[h - 1];\n\t\t\t \n\t\t\tPUT_SB_ROOT_BLOCK(tb->tb_sb, new_root->b_blocknr);\n\t\t\t \n\t\t\tPUT_SB_TREE_HEIGHT(tb->tb_sb,\n\t\t\t\t\t   SB_TREE_HEIGHT(tb->tb_sb) - 1);\n\n\t\t\tdo_balance_mark_sb_dirty(tb,\n\t\t\t\t\t\t REISERFS_SB(tb->tb_sb)->s_sbh,\n\t\t\t\t\t\t 1);\n\t\t\t \n\t\t\t \n\t\t\tif (h > 1)\n\t\t\t\tcheck_internal(new_root);\n\t\t\t \n\n\t\t\t \n\t\t\treiserfs_invalidate_buffer(tb, tbSh);\n\t\t\treturn;\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (tb->L[h] && tb->lnum[h] == -B_NR_ITEMS(tb->L[h]) - 1) {\n\n\t\tRFALSE(tb->rnum[h] != 0,\n\t\t       \"invalid tb->rnum[%d]==%d when joining S[h] with L[h]\",\n\t\t       h, tb->rnum[h]);\n\n\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h, n + 1);\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\n\t\treturn;\n\t}\n\n\t \n\tif (tb->R[h] && tb->rnum[h] == -B_NR_ITEMS(tb->R[h]) - 1) {\n\t\tRFALSE(tb->lnum[h] != 0,\n\t\t       \"invalid tb->lnum[%d]==%d when joining S[h] with R[h]\",\n\t\t       h, tb->lnum[h]);\n\n\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h, n + 1);\n\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\t\treturn;\n\t}\n\n\t \n\tif (tb->lnum[h] < 0) {\n\t\tRFALSE(tb->rnum[h] != 0,\n\t\t       \"wrong tb->rnum[%d]==%d when borrow from L[h]\", h,\n\t\t       tb->rnum[h]);\n\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_L_TO_S, tb, h,\n\t\t\t\t     -tb->lnum[h]);\n\t\treturn;\n\t}\n\n\t \n\tif (tb->rnum[h] < 0) {\n\t\tRFALSE(tb->lnum[h] != 0,\n\t\t       \"invalid tb->lnum[%d]==%d when borrow from R[h]\",\n\t\t       h, tb->lnum[h]);\n\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_R_TO_S, tb, h, -tb->rnum[h]);\t \n\t\treturn;\n\t}\n\n\t \n\tif (tb->lnum[h] > 0) {\n\t\tRFALSE(tb->rnum[h] == 0 || tb->lnum[h] + tb->rnum[h] != n + 1,\n\t\t       \"invalid tb->lnum[%d]==%d or tb->rnum[%d]==%d when S[h](item number == %d) is split between them\",\n\t\t       h, tb->lnum[h], h, tb->rnum[h], n);\n\n\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h, tb->lnum[h]);\t \n\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t     tb->rnum[h]);\n\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\n\t\treturn;\n\t}\n\treiserfs_panic(tb->tb_sb, \"ibalance-2\",\n\t\t       \"unexpected tb->lnum[%d]==%d or tb->rnum[%d]==%d\",\n\t\t       h, tb->lnum[h], h, tb->rnum[h]);\n}\n\n \nstatic void replace_lkey(struct tree_balance *tb, int h, struct item_head *key)\n{\n\tRFALSE(tb->L[h] == NULL || tb->CFL[h] == NULL,\n\t       \"L[h](%p) and CFL[h](%p) must exist in replace_lkey\",\n\t       tb->L[h], tb->CFL[h]);\n\n\tif (B_NR_ITEMS(PATH_H_PBUFFER(tb->tb_path, h)) == 0)\n\t\treturn;\n\n\tmemcpy(internal_key(tb->CFL[h], tb->lkey[h]), key, KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, tb->CFL[h], 0);\n}\n\n \nstatic void replace_rkey(struct tree_balance *tb, int h, struct item_head *key)\n{\n\tRFALSE(tb->R[h] == NULL || tb->CFR[h] == NULL,\n\t       \"R[h](%p) and CFR[h](%p) must exist in replace_rkey\",\n\t       tb->R[h], tb->CFR[h]);\n\tRFALSE(B_NR_ITEMS(tb->R[h]) == 0,\n\t       \"R[h] can not be empty if it exists (item number=%d)\",\n\t       B_NR_ITEMS(tb->R[h]));\n\n\tmemcpy(internal_key(tb->CFR[h], tb->rkey[h]), key, KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, tb->CFR[h], 0);\n}\n\n\n \n\nint balance_internal(struct tree_balance *tb,\n\t\t     int h,\t \n\t\t     int child_pos,\n\t\t      \n\t\t     struct item_head *insert_key,\n\t\t      \n\t\t     struct buffer_head **insert_ptr)\n{\n\tstruct buffer_head *tbSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tstruct buffer_info bi;\n\n\t \n\tint order;\n\tint insert_num, n, k;\n\tstruct buffer_head *S_new;\n\tstruct item_head new_insert_key;\n\tstruct buffer_head *new_insert_ptr = NULL;\n\tstruct item_head *new_insert_key_addr = insert_key;\n\n\tRFALSE(h < 1, \"h (%d) can not be < 1 on internal level\", h);\n\n\tPROC_INFO_INC(tb->tb_sb, balance_at[h]);\n\n\torder =\n\t    (tbSh) ? PATH_H_POSITION(tb->tb_path,\n\t\t\t\t     h + 1)   : 0;\n\n\t \n\tinsert_num = tb->insert_size[h] / ((int)(KEY_SIZE + DC_SIZE));\n\n\t \n\tRFALSE(insert_num < -2 || insert_num > 2,\n\t       \"incorrect number of items inserted to the internal node (%d)\",\n\t       insert_num);\n\tRFALSE(h > 1 && (insert_num > 1 || insert_num < -1),\n\t       \"incorrect number of items (%d) inserted to the internal node on a level (h=%d) higher than last internal level\",\n\t       insert_num, h);\n\n\t \n\tif (insert_num < 0) {\n\t\tbalance_internal_when_delete(tb, h, child_pos);\n\t\treturn order;\n\t}\n\n\tk = 0;\n\tif (tb->lnum[h] > 0) {\n\t\t \n\t\tn = B_NR_ITEMS(tb->L[h]);\t \n\t\tif (tb->lnum[h] <= child_pos) {\n\t\t\t \n\t\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h,\n\t\t\t\t\t    tb->lnum[h]);\n\t\t\tchild_pos -= tb->lnum[h];\n\t\t} else if (tb->lnum[h] > child_pos + insert_num) {\n\t\t\t \n\t\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h,\n\t\t\t\t\t    tb->lnum[h] - insert_num);\n\t\t\t \n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->L[h];\n\t\t\tbi.bi_parent = tb->FL[h];\n\t\t\tbi.bi_position = get_left_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t        \n\t\t\t\t\t       n + child_pos + 1,\n\t\t\t\t\t       insert_num, insert_key,\n\t\t\t\t\t       insert_ptr);\n\n\t\t\tinsert_num = 0;\n\t\t} else {\n\t\t\tstruct disk_child *dc;\n\n\t\t\t \n\t\t\tinternal_shift1_left(tb, h, child_pos + 1);\n\t\t\t \n\t\t\tk = tb->lnum[h] - child_pos - 1;\n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->L[h];\n\t\t\tbi.bi_parent = tb->FL[h];\n\t\t\tbi.bi_position = get_left_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t        \n\t\t\t\t\t       n + child_pos + 1, k,\n\t\t\t\t\t       insert_key, insert_ptr);\n\n\t\t\treplace_lkey(tb, h, insert_key + k);\n\n\t\t\t \n\t\t\tdc = B_N_CHILD(tbSh, 0);\n\t\t\tput_dc_size(dc,\n\t\t\t\t    MAX_CHILD_SIZE(insert_ptr[k]) -\n\t\t\t\t    B_FREE_SPACE(insert_ptr[k]));\n\t\t\tput_dc_block_number(dc, insert_ptr[k]->b_blocknr);\n\n\t\t\tdo_balance_mark_internal_dirty(tb, tbSh, 0);\n\n\t\t\tk++;\n\t\t\tinsert_key += k;\n\t\t\tinsert_ptr += k;\n\t\t\tinsert_num -= k;\n\t\t\tchild_pos = 0;\n\t\t}\n\t}\n\t \n\tif (tb->rnum[h] > 0) {\n\t\t \n\t\t \n\t\tn = B_NR_ITEMS(tbSh);\t \n\t\tif (n - tb->rnum[h] >= child_pos)\n\t\t\t \n\t\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t\t     tb->rnum[h]);\n\t\telse if (n + insert_num - tb->rnum[h] < child_pos) {\n\t\t\t \n\t\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t\t     tb->rnum[h] - insert_num);\n\n\t\t\t \n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->R[h];\n\t\t\tbi.bi_parent = tb->FR[h];\n\t\t\tbi.bi_position = get_right_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t        \n\t\t\t\t\t       child_pos - n - insert_num +\n\t\t\t\t\t       tb->rnum[h] - 1,\n\t\t\t\t\t       insert_num, insert_key,\n\t\t\t\t\t       insert_ptr);\n\t\t\tinsert_num = 0;\n\t\t} else {\n\t\t\tstruct disk_child *dc;\n\n\t\t\t \n\t\t\tinternal_shift1_right(tb, h, n - child_pos + 1);\n\t\t\t \n\t\t\tk = tb->rnum[h] - n + child_pos - 1;\n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->R[h];\n\t\t\tbi.bi_parent = tb->FR[h];\n\t\t\tbi.bi_position = get_right_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t        \n\t\t\t\t\t       0, k, insert_key + 1,\n\t\t\t\t\t       insert_ptr + 1);\n\n\t\t\treplace_rkey(tb, h, insert_key + insert_num - k - 1);\n\n\t\t\t \n\t\t\tdc = B_N_CHILD(tb->R[h], 0);\n\t\t\tput_dc_size(dc,\n\t\t\t\t    MAX_CHILD_SIZE(insert_ptr\n\t\t\t\t\t\t   [insert_num - k - 1]) -\n\t\t\t\t    B_FREE_SPACE(insert_ptr\n\t\t\t\t\t\t [insert_num - k - 1]));\n\t\t\tput_dc_block_number(dc,\n\t\t\t\t\t    insert_ptr[insert_num - k -\n\t\t\t\t\t\t       1]->b_blocknr);\n\n\t\t\tdo_balance_mark_internal_dirty(tb, tb->R[h], 0);\n\n\t\t\tinsert_num -= (k + 1);\n\t\t}\n\t}\n\n\t \n\tRFALSE(tb->blknum[h] > 2, \"blknum can not be > 2 for internal level\");\n\tRFALSE(tb->blknum[h] < 0, \"blknum can not be < 0\");\n\n\tif (!tb->blknum[h]) {\t \n\t\tRFALSE(!tbSh, \"S[h] is equal NULL\");\n\n\t\t \n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\t\treturn order;\n\t}\n\n\tif (!tbSh) {\n\t\t \n\t\tstruct disk_child *dc;\n\t\tstruct buffer_head *tbSh_1 = PATH_H_PBUFFER(tb->tb_path, h - 1);\n\t\tstruct block_head *blkh;\n\n\t\tif (tb->blknum[h] != 1)\n\t\t\treiserfs_panic(NULL, \"ibalance-3\", \"One new node \"\n\t\t\t\t       \"required for creating the new root\");\n\t\t \n\t\ttbSh = get_FEB(tb);\n\t\tblkh = B_BLK_HEAD(tbSh);\n\t\tset_blkh_level(blkh, h + 1);\n\n\t\t \n\n\t\tdc = B_N_CHILD(tbSh, 0);\n\t\tput_dc_block_number(dc, tbSh_1->b_blocknr);\n\t\tput_dc_size(dc,\n\t\t\t    (MAX_CHILD_SIZE(tbSh_1) - B_FREE_SPACE(tbSh_1)));\n\n\t\ttb->insert_size[h] -= DC_SIZE;\n\t\tset_blkh_free_space(blkh, blkh_free_space(blkh) - DC_SIZE);\n\n\t\tdo_balance_mark_internal_dirty(tb, tbSh, 0);\n\n\t\t \n\t\tcheck_internal(tbSh);\n\t\t \n\n\t\t \n\t\tPATH_OFFSET_PBUFFER(tb->tb_path, ILLEGAL_PATH_ELEMENT_OFFSET) =\n\t\t    tbSh;\n\n\t\t \n\t\tPUT_SB_ROOT_BLOCK(tb->tb_sb, tbSh->b_blocknr);\n\t\tPUT_SB_TREE_HEIGHT(tb->tb_sb, SB_TREE_HEIGHT(tb->tb_sb) + 1);\n\t\tdo_balance_mark_sb_dirty(tb, REISERFS_SB(tb->tb_sb)->s_sbh, 1);\n\t}\n\n\tif (tb->blknum[h] == 2) {\n\t\tint snum;\n\t\tstruct buffer_info dest_bi, src_bi;\n\n\t\t \n\t\tS_new = get_FEB(tb);\n\n\t\tset_blkh_level(B_BLK_HEAD(S_new), h + 1);\n\n\t\tdest_bi.tb = tb;\n\t\tdest_bi.bi_bh = S_new;\n\t\tdest_bi.bi_parent = NULL;\n\t\tdest_bi.bi_position = 0;\n\t\tsrc_bi.tb = tb;\n\t\tsrc_bi.bi_bh = tbSh;\n\t\tsrc_bi.bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi.bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\t\tn = B_NR_ITEMS(tbSh);\t \n\t\tsnum = (insert_num + n + 1) / 2;\n\t\tif (n - snum >= child_pos) {\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tmemcpy(&new_insert_key, internal_key(tbSh, n - snum),\n\t\t\t       KEY_SIZE);\n\t\t\t \n\t\t\tinternal_move_pointers_items(&dest_bi, &src_bi,\n\t\t\t\t\t\t     LAST_TO_FIRST, snum, 0);\n\t\t} else if (n + insert_num - snum < child_pos) {\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tmemcpy(&new_insert_key,\n\t\t\t       internal_key(tbSh, n + insert_num - snum),\n\t\t\t       KEY_SIZE);\n\t\t\t \n\t\t\tinternal_move_pointers_items(&dest_bi, &src_bi,\n\t\t\t\t\t\t     LAST_TO_FIRST,\n\t\t\t\t\t\t     snum - insert_num, 0);\n\n\t\t\t \n\t\t\tinternal_insert_childs(&dest_bi,\n\t\t\t\t\t        \n\t\t\t\t\t       child_pos - n - insert_num +\n\t\t\t\t\t       snum - 1,\n\t\t\t\t\t       insert_num, insert_key,\n\t\t\t\t\t       insert_ptr);\n\n\t\t\tinsert_num = 0;\n\t\t} else {\n\t\t\tstruct disk_child *dc;\n\n\t\t\t \n\t\t\t \n\t\t\tinternal_move_pointers_items(&dest_bi, &src_bi,\n\t\t\t\t\t\t     LAST_TO_FIRST,\n\t\t\t\t\t\t     n - child_pos + 1, 1);\n\t\t\t \n\t\t\tk = snum - n + child_pos - 1;\n\n\t\t\tinternal_insert_childs(&dest_bi,   0, k,\n\t\t\t\t\t       insert_key + 1, insert_ptr + 1);\n\n\t\t\t \n\t\t\tmemcpy(&new_insert_key, insert_key + insert_num - k - 1,\n\t\t\t       KEY_SIZE);\n\t\t\t \n\n\t\t\tdc = B_N_CHILD(S_new, 0);\n\t\t\tput_dc_size(dc,\n\t\t\t\t    (MAX_CHILD_SIZE\n\t\t\t\t     (insert_ptr[insert_num - k - 1]) -\n\t\t\t\t     B_FREE_SPACE(insert_ptr\n\t\t\t\t\t\t  [insert_num - k - 1])));\n\t\t\tput_dc_block_number(dc,\n\t\t\t\t\t    insert_ptr[insert_num - k -\n\t\t\t\t\t\t       1]->b_blocknr);\n\n\t\t\tdo_balance_mark_internal_dirty(tb, S_new, 0);\n\n\t\t\tinsert_num -= (k + 1);\n\t\t}\n\t\t \n\t\tnew_insert_ptr = S_new;\n\n\t\tRFALSE(!buffer_journaled(S_new) || buffer_journal_dirty(S_new)\n\t\t       || buffer_dirty(S_new), \"cm-00001: bad S_new (%b)\",\n\t\t       S_new);\n\n\t\t \n\t}\n\n\tn = B_NR_ITEMS(tbSh);\t \n\n\tif (0 <= child_pos && child_pos <= n && insert_num > 0) {\n\t\tbi.tb = tb;\n\t\tbi.bi_bh = tbSh;\n\t\tbi.bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tbi.bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tinternal_insert_childs(&bi,\t \n\t\t\t\t        \n\t\t\t\t       child_pos, insert_num, insert_key,\n\t\t\t\t       insert_ptr);\n\t}\n\n\tinsert_ptr[0] = new_insert_ptr;\n\tif (new_insert_ptr)\n\t\tmemcpy(new_insert_key_addr, &new_insert_key, KEY_SIZE);\n\n\treturn order;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}