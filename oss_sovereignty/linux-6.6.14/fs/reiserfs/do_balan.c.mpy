{
  "module_name": "do_balan.c",
  "hash_id": "98fcb0d954b11f0d2c932d5083407ee4d84e3f76f2eb9e3a7abb2278734941b4",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/do_balan.c",
  "human_readable_source": " \n\n \n\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include \"reiserfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline void buffer_info_init_left(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->L[0];\n\tbi->bi_parent   = tb->FL[0];\n\tbi->bi_position = get_left_neighbor_position(tb, 0);\n}\n\nstatic inline void buffer_info_init_right(struct tree_balance *tb,\n                                          struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->R[0];\n\tbi->bi_parent   = tb->FR[0];\n\tbi->bi_position = get_right_neighbor_position(tb, 0);\n}\n\nstatic inline void buffer_info_init_tbS0(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh        = PATH_PLAST_BUFFER(tb->tb_path);\n\tbi->bi_parent   = PATH_H_PPARENT(tb->tb_path, 0);\n\tbi->bi_position = PATH_H_POSITION(tb->tb_path, 1);\n}\n\nstatic inline void buffer_info_init_bh(struct tree_balance *tb,\n                                       struct buffer_info *bi,\n                                       struct buffer_head *bh)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = bh;\n\tbi->bi_parent   = NULL;\n\tbi->bi_position = 0;\n}\n\ninline void do_balance_mark_leaf_dirty(struct tree_balance *tb,\n\t\t\t\t       struct buffer_head *bh, int flag)\n{\n\tjournal_mark_dirty(tb->transaction_handle, bh);\n}\n\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n#define do_balance_mark_sb_dirty do_balance_mark_leaf_dirty\n\n \n\nstatic void balance_leaf_when_delete_del(struct tree_balance *tb)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint item_pos = PATH_LAST_POSITION(tb->tb_path);\n\tstruct buffer_info bi;\n#ifdef CONFIG_REISERFS_CHECK\n\tstruct item_head *ih = item_head(tbS0, item_pos);\n#endif\n\n\tRFALSE(ih_item_len(ih) + IH_SIZE != -tb->insert_size[0],\n\t       \"vs-12013: mode Delete, insert size %d, ih to be deleted %h\",\n\t       -tb->insert_size[0], ih);\n\n\tbuffer_info_init_tbS0(tb, &bi);\n\tleaf_delete_items(&bi, 0, item_pos, 1, -1);\n\n\tif (!item_pos && tb->CFL[0]) {\n\t\tif (B_NR_ITEMS(tbS0)) {\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);\n\t\t} else {\n\t\t\tif (!PATH_H_POSITION(tb->tb_path, 1))\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\t\t}\n\t}\n\n\tRFALSE(!item_pos && !tb->CFL[0],\n\t       \"PAP-12020: tb->CFL[0]==%p, tb->L[0]==%p\", tb->CFL[0],\n\t       tb->L[0]);\n}\n\n \nstatic void balance_leaf_when_delete_cut(struct tree_balance *tb)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint item_pos = PATH_LAST_POSITION(tb->tb_path);\n\tstruct item_head *ih = item_head(tbS0, item_pos);\n\tint pos_in_item = tb->tb_path->pos_in_item;\n\tstruct buffer_info bi;\n\tbuffer_info_init_tbS0(tb, &bi);\n\n\tif (is_direntry_le_ih(ih)) {\n\t\t \n\t\ttb->insert_size[0] = -1;\n\t\tleaf_cut_from_buffer(&bi, item_pos, pos_in_item,\n\t\t\t\t     -tb->insert_size[0]);\n\n\t\tRFALSE(!item_pos && !pos_in_item && !tb->CFL[0],\n\t\t       \"PAP-12030: can not change delimiting key. CFL[0]=%p\",\n\t\t       tb->CFL[0]);\n\n\t\tif (!item_pos && !pos_in_item && tb->CFL[0])\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);\n\t} else {\n\t\tleaf_cut_from_buffer(&bi, item_pos, pos_in_item,\n\t\t\t\t     -tb->insert_size[0]);\n\n\t\tRFALSE(!ih_item_len(ih),\n\t\t       \"PAP-12035: cut must leave non-zero dynamic \"\n\t\t       \"length of item\");\n\t}\n}\n\nstatic int balance_leaf_when_delete_left(struct tree_balance *tb)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\n\t \n\tif (tb->lnum[0] == -1) {\n\t\t \n\t\tif (tb->rnum[0] == -1) {\n\t\t\tif (tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0)) {\n\t\t\t\t \n\t\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0 &&\n\t\t\t\t    1 < B_NR_ITEMS(tb->FR[0]))\n\t\t\t\t\treplace_key(tb, tb->CFL[0],\n\t\t\t\t\t\t    tb->lkey[0], tb->FR[0], 1);\n\n\t\t\t\tleaf_move_items(LEAF_FROM_S_TO_L, tb, n, -1,\n\t\t\t\t\t\tNULL);\n\t\t\t\tleaf_move_items(LEAF_FROM_R_TO_L, tb,\n\t\t\t\t\t\tB_NR_ITEMS(tb->R[0]), -1,\n\t\t\t\t\t\tNULL);\n\n\t\t\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\t\t\treiserfs_invalidate_buffer(tb, tb->R[0]);\n\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t \n\t\t\tleaf_move_items(LEAF_FROM_S_TO_R, tb, n, -1, NULL);\n\t\t\tleaf_move_items(LEAF_FROM_L_TO_R, tb,\n\t\t\t\t\tB_NR_ITEMS(tb->L[0]), -1, NULL);\n\n\t\t\t \n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\t\treiserfs_invalidate_buffer(tb, tb->L[0]);\n\n\t\t\treturn -1;\n\t\t}\n\n\t\tRFALSE(tb->rnum[0] != 0,\n\t\t       \"PAP-12045: rnum must be 0 (%d)\", tb->rnum[0]);\n\t\t \n\t\tleaf_shift_left(tb, n, -1);\n\n\t\treiserfs_invalidate_buffer(tb, tbS0);\n\n\t\treturn 0;\n\t}\n\n\t \n\n\tRFALSE((tb->lnum[0] + tb->rnum[0] < n) ||\n\t       (tb->lnum[0] + tb->rnum[0] > n + 1),\n\t       \"PAP-12050: rnum(%d) and lnum(%d) and item \"\n\t       \"number(%d) in S[0] are not consistent\",\n\t       tb->rnum[0], tb->lnum[0], n);\n\tRFALSE((tb->lnum[0] + tb->rnum[0] == n) &&\n\t       (tb->lbytes != -1 || tb->rbytes != -1),\n\t       \"PAP-12055: bad rbytes (%d)/lbytes (%d) \"\n\t       \"parameters when items are not split\",\n\t       tb->rbytes, tb->lbytes);\n\tRFALSE((tb->lnum[0] + tb->rnum[0] == n + 1) &&\n\t       (tb->lbytes < 1 || tb->rbytes != -1),\n\t       \"PAP-12060: bad rbytes (%d)/lbytes (%d) \"\n\t       \"parameters when items are split\",\n\t       tb->rbytes, tb->lbytes);\n\n\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\n\treiserfs_invalidate_buffer(tb, tbS0);\n\n\treturn 0;\n}\n\n \nstatic int balance_leaf_when_delete(struct tree_balance *tb, int flag)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct buffer_info bi;\n\tint n;\n\n\tRFALSE(tb->FR[0] && B_LEVEL(tb->FR[0]) != DISK_LEAF_NODE_LEVEL + 1,\n\t       \"vs- 12000: level: wrong FR %z\", tb->FR[0]);\n\tRFALSE(tb->blknum[0] > 1,\n\t       \"PAP-12005: tb->blknum == %d, can not be > 1\", tb->blknum[0]);\n\tRFALSE(!tb->blknum[0] && !PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"PAP-12010: tree can not be empty\");\n\n\tbuffer_info_init_tbS0(tb, &bi);\n\n\t \n\n\tBUG_ON(flag != M_DELETE && flag != M_CUT);\n\tif (flag == M_DELETE)\n\t\tbalance_leaf_when_delete_del(tb);\n\telse  \n\t\tbalance_leaf_when_delete_cut(tb);\n\n\n\t \n\tn = B_NR_ITEMS(tbS0);\n\n\n\t \n\tif (tb->lnum[0])\n\t\treturn balance_leaf_when_delete_left(tb);\n\n\tif (tb->rnum[0] == -1) {\n\t\t \n\t\tleaf_shift_right(tb, n, -1);\n\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\treturn 0;\n\t}\n\n\tRFALSE(tb->rnum[0],\n\t       \"PAP-12065: bad rnum parameter must be 0 (%d)\", tb->rnum[0]);\n\treturn 0;\n}\n\nstatic unsigned int balance_leaf_insert_left(struct tree_balance *tb,\n\t\t\t\t\t     struct item_head *const ih,\n\t\t\t\t\t     const char * const body)\n{\n\tint ret;\n\tstruct buffer_info bi;\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tunsigned body_shift_bytes = 0;\n\n\tif (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {\n\t\t \n\t\tint new_item_len, shift;\n\n\t\tret = leaf_shift_left(tb, tb->lnum[0] - 1, -1);\n\n\t\t \n\t\tnew_item_len = ih_item_len(ih) - tb->lbytes;\n\n\t\t \n\t\tput_ih_item_len(ih, ih_item_len(ih) - new_item_len);\n\n\t\tRFALSE(ih_item_len(ih) <= 0,\n\t\t       \"PAP-12080: there is nothing to insert into L[0]: \"\n\t\t       \"ih_item_len=%d\", ih_item_len(ih));\n\n\t\t \n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_insert_into_buf(&bi, n + tb->item_pos - ret, ih, body,\n\t\t\t     min_t(int, tb->zeroes_num, ih_item_len(ih)));\n\n\t\t \n\t\tshift = 0;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\n\t\tadd_le_ih_k_offset(ih, tb->lbytes << shift);\n\n\t\tput_ih_item_len(ih, new_item_len);\n\t\tif (tb->lbytes > tb->zeroes_num) {\n\t\t\tbody_shift_bytes = tb->lbytes - tb->zeroes_num;\n\t\t\ttb->zeroes_num = 0;\n\t\t} else\n\t\t\ttb->zeroes_num -= tb->lbytes;\n\n\t\tRFALSE(ih_item_len(ih) <= 0,\n\t\t       \"PAP-12085: there is nothing to insert into S[0]: \"\n\t\t       \"ih_item_len=%d\", ih_item_len(ih));\n\t} else {\n\t\t \n\t\t \n\t\tret = leaf_shift_left(tb, tb->lnum[0] - 1, tb->lbytes);\n\n\t\t \n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_insert_into_buf(&bi, n + tb->item_pos - ret, ih, body,\n\t\t\t\t     tb->zeroes_num);\n\t\ttb->insert_size[0] = 0;\n\t\ttb->zeroes_num = 0;\n\t}\n\treturn body_shift_bytes;\n}\n\nstatic void balance_leaf_paste_left_shift_dirent(struct tree_balance *tb,\n\t\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t\t const char * const body)\n{\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tstruct buffer_info bi;\n\n\tRFALSE(tb->zeroes_num,\n\t       \"PAP-12090: invalid parameter in case of a directory\");\n\n\t \n\tif (tb->lbytes > tb->pos_in_item) {\n\t\t \n\t\tstruct item_head *pasted;\n\t\tint ret, l_pos_in_item = tb->pos_in_item;\n\n\t\t \n\t\tret = leaf_shift_left(tb, tb->lnum[0], tb->lbytes - 1);\n\t\tif (ret && !tb->item_pos) {\n\t\t\tpasted = item_head(tb->L[0], B_NR_ITEMS(tb->L[0]) - 1);\n\t\t\tl_pos_in_item += ih_entry_count(pasted) -\n\t\t\t\t\t (tb->lbytes - 1);\n\t\t}\n\n\t\t \n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, n + tb->item_pos - ret,\n\t\t\t\t     l_pos_in_item, tb->insert_size[0],\n\t\t\t\t     body, tb->zeroes_num);\n\n\t\t \n\n\t\t \n\n\t\t \n\t\tleaf_paste_entries(&bi, n + tb->item_pos - ret,\n\t\t\t\t   l_pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *) body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\t\ttb->insert_size[0] = 0;\n\t} else {\n\t\t \n\t\t \n\t\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\t}\n\n\t \n\ttb->pos_in_item -= tb->lbytes;\n}\n\nstatic unsigned int balance_leaf_paste_left_shift(struct tree_balance *tb,\n\t\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t\t  const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tstruct buffer_info bi;\n\tint body_shift_bytes = 0;\n\n\tif (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {\n\t\tbalance_leaf_paste_left_shift_dirent(tb, ih, body);\n\t\treturn 0;\n\t}\n\n\tRFALSE(tb->lbytes <= 0,\n\t       \"PAP-12095: there is nothing to shift to L[0]. \"\n\t       \"lbytes=%d\", tb->lbytes);\n\tRFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)),\n\t       \"PAP-12100: incorrect position to paste: \"\n\t       \"item_len=%d, pos_in_item=%d\",\n\t       ih_item_len(item_head(tbS0, tb->item_pos)), tb->pos_in_item);\n\n\t \n\tif (tb->lbytes >= tb->pos_in_item) {\n\t\tstruct item_head *tbS0_pos_ih, *tbL0_ih;\n\t\tstruct item_head *tbS0_0_ih;\n\t\tstruct reiserfs_key *left_delim_key;\n\t\tint ret, l_n, version, temp_l;\n\n\t\ttbS0_pos_ih = item_head(tbS0, tb->item_pos);\n\t\ttbS0_0_ih = item_head(tbS0, 0);\n\n\t\t \n\t\tl_n = tb->lbytes - tb->pos_in_item;\n\n\t\t \n\t\ttb->insert_size[0] -= l_n;\n\n\t\tRFALSE(tb->insert_size[0] <= 0,\n\t\t       \"PAP-12105: there is nothing to paste into \"\n\t\t       \"L[0]. insert_size=%d\", tb->insert_size[0]);\n\n\t\tret = leaf_shift_left(tb, tb->lnum[0],\n\t\t\t\t      ih_item_len(tbS0_pos_ih));\n\n\t\ttbL0_ih = item_head(tb->L[0], n + tb->item_pos - ret);\n\n\t\t \n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, n + tb->item_pos - ret,\n\t\t\t\t     ih_item_len(tbL0_ih), l_n, body,\n\t\t\t\t     min_t(int, l_n, tb->zeroes_num));\n\n\t\t \n\t\ttemp_l = l_n;\n\n\t\tRFALSE(ih_item_len(tbS0_0_ih),\n\t\t       \"PAP-12106: item length must be 0\");\n\t\tRFALSE(comp_short_le_keys(&tbS0_0_ih->ih_key,\n\t\t       leaf_key(tb->L[0], n + tb->item_pos - ret)),\n\t\t       \"PAP-12107: items must be of the same file\");\n\n\t\tif (is_indirect_le_ih(tbL0_ih)) {\n\t\t\tint shift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\t\ttemp_l = l_n << shift;\n\t\t}\n\t\t \n\t\tversion = ih_version(tbS0_0_ih);\n\t\tadd_le_key_k_offset(version, &tbS0_0_ih->ih_key, temp_l);\n\n\t\t \n\t\tleft_delim_key = internal_key(tb->CFL[0], tb->lkey[0]);\n\t\tadd_le_key_k_offset(version, left_delim_key, temp_l);\n\n\t\t \n\t\tif (l_n > tb->zeroes_num) {\n\t\t\tbody_shift_bytes = l_n - tb->zeroes_num;\n\t\t\ttb->zeroes_num = 0;\n\t\t} else\n\t\t\ttb->zeroes_num -= l_n;\n\t\ttb->pos_in_item = 0;\n\n\t\tRFALSE(comp_short_le_keys(&tbS0_0_ih->ih_key,\n\t\t\t\t\t  leaf_key(tb->L[0],\n\t\t\t\t\t\t B_NR_ITEMS(tb->L[0]) - 1)) ||\n\t\t       !op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size) ||\n\t\t       !op_is_left_mergeable(left_delim_key, tbS0->b_size),\n\t\t       \"PAP-12120: item must be merge-able with left \"\n\t\t       \"neighboring item\");\n\t} else {\n\t\t \n\n\t\t \n\t\ttb->pos_in_item -= tb->lbytes;\n\n\t\tRFALSE(tb->pos_in_item <= 0,\n\t\t       \"PAP-12125: no place for paste. pos_in_item=%d\",\n\t\t       tb->pos_in_item);\n\n\t\t \n\t\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\t}\n\treturn body_shift_bytes;\n}\n\n\n \nstatic void balance_leaf_paste_left_whole(struct tree_balance *tb,\n\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t  const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tstruct buffer_info bi;\n\tstruct item_head *pasted;\n\tint ret;\n\n\t \n\tif (!tb->item_pos &&\n\t    op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size)) {\n\t\t \n\t\tpasted = item_head(tb->L[0], n - 1);\n\t\tif (is_direntry_le_ih(pasted))\n\t\t\ttb->pos_in_item += ih_entry_count(pasted);\n\t\telse\n\t\t\ttb->pos_in_item += ih_item_len(pasted);\n\t}\n\n\t \n\tret = leaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\n\t \n\tbuffer_info_init_left(tb, &bi);\n\tleaf_paste_in_buffer(&bi, n + tb->item_pos - ret, tb->pos_in_item,\n\t\t\t     tb->insert_size[0], body, tb->zeroes_num);\n\n\t \n\tpasted = item_head(tb->L[0], n + tb->item_pos - ret);\n\tif (is_direntry_le_ih(pasted))\n\t\tleaf_paste_entries(&bi, n + tb->item_pos - ret,\n\t\t\t\t   tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t \n\tif (is_indirect_le_ih(pasted))\n\t\tset_ih_free_space(pasted, 0);\n\n\ttb->insert_size[0] = 0;\n\ttb->zeroes_num = 0;\n}\n\nstatic unsigned int balance_leaf_paste_left(struct tree_balance *tb,\n\t\t\t\t\t    struct item_head * const ih,\n\t\t\t\t\t    const char * const body)\n{\n\t \n\tif (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1)\n\t\treturn balance_leaf_paste_left_shift(tb, ih, body);\n\telse\n\t\tbalance_leaf_paste_left_whole(tb, ih, body);\n\treturn 0;\n}\n\n \nstatic unsigned int balance_leaf_left(struct tree_balance *tb,\n\t\t\t\t      struct item_head * const ih,\n\t\t\t\t      const char * const body, int flag)\n{\n\tif (tb->lnum[0] <= 0)\n\t\treturn 0;\n\n\t \n\tif (tb->item_pos < tb->lnum[0]) {\n\t\tBUG_ON(flag != M_INSERT && flag != M_PASTE);\n\n\t\tif (flag == M_INSERT)\n\t\t\treturn balance_leaf_insert_left(tb, ih, body);\n\t\telse  \n\t\t\treturn balance_leaf_paste_left(tb, ih, body);\n\t} else\n\t\t \n\t\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\treturn 0;\n}\n\n\nstatic void balance_leaf_insert_right(struct tree_balance *tb,\n\t\t\t\t      struct item_head * const ih,\n\t\t\t\t      const char * const body)\n{\n\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tstruct buffer_info bi;\n\n\t \n\tif (n - tb->rnum[0] >= tb->item_pos) {\n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\t\treturn;\n\t}\n\n\t \n\n\t \n\tif (tb->item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1) {\n\t\tloff_t old_key_comp, old_len, r_zeroes_number;\n\t\tconst char *r_body;\n\t\tint shift;\n\t\tloff_t offset;\n\n\t\tleaf_shift_right(tb, tb->rnum[0] - 1, -1);\n\n\t\t \n\t\told_key_comp = le_ih_k_offset(ih);\n\t\told_len = ih_item_len(ih);\n\n\t\t \n\t\tshift = 0;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\toffset = le_ih_k_offset(ih) + ((old_len - tb->rbytes) << shift);\n\t\tset_le_ih_k_offset(ih, offset);\n\t\tput_ih_item_len(ih, tb->rbytes);\n\n\t\t \n\t\tbuffer_info_init_right(tb, &bi);\n\t\tif ((old_len - tb->rbytes) > tb->zeroes_num) {\n\t\t\tr_zeroes_number = 0;\n\t\t\tr_body = body + (old_len - tb->rbytes) - tb->zeroes_num;\n\t\t} else {\n\t\t\tr_body = body;\n\t\t\tr_zeroes_number = tb->zeroes_num -\n\t\t\t\t\t  (old_len - tb->rbytes);\n\t\t\ttb->zeroes_num -= r_zeroes_number;\n\t\t}\n\n\t\tleaf_insert_into_buf(&bi, 0, ih, r_body, r_zeroes_number);\n\n\t\t \n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\t \n\t\tset_le_ih_k_offset(ih, old_key_comp);\n\t\tput_ih_item_len(ih, old_len - tb->rbytes);\n\n\t\ttb->insert_size[0] -= tb->rbytes;\n\n\t} else {\n\t\t \n\n\t\t \n\t\tleaf_shift_right(tb, tb->rnum[0] - 1, tb->rbytes);\n\n\t\t \n\t\tbuffer_info_init_right(tb, &bi);\n\t\tleaf_insert_into_buf(&bi, tb->item_pos - n + tb->rnum[0] - 1,\n\t\t\t\t     ih, body, tb->zeroes_num);\n\n\t\tif (tb->item_pos - n + tb->rnum[0] - 1 == 0)\n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\ttb->zeroes_num = tb->insert_size[0] = 0;\n\t}\n}\n\n\nstatic void balance_leaf_paste_right_shift_dirent(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct buffer_info bi;\n\tint entry_count;\n\n\tRFALSE(tb->zeroes_num,\n\t       \"PAP-12145: invalid parameter in case of a directory\");\n\tentry_count = ih_entry_count(item_head(tbS0, tb->item_pos));\n\n\t \n\tif (entry_count - tb->rbytes < tb->pos_in_item) {\n\t\tint paste_entry_position;\n\n\t\tRFALSE(tb->rbytes - 1 >= entry_count || !tb->insert_size[0],\n\t\t       \"PAP-12150: no enough of entries to shift to R[0]: \"\n\t\t       \"rbytes=%d, entry_count=%d\", tb->rbytes, entry_count);\n\n\t\t \n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes - 1);\n\n\t\t \n\t\tpaste_entry_position = tb->pos_in_item - entry_count +\n\t\t\t\t       tb->rbytes - 1;\n\t\tbuffer_info_init_right(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, 0, paste_entry_position,\n\t\t\t\t     tb->insert_size[0], body, tb->zeroes_num);\n\n\t\t \n\t\tleaf_paste_entries(&bi, 0, paste_entry_position, 1,\n\t\t\t\t   (struct reiserfs_de_head *) body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\t \n\t\tif (paste_entry_position == 0)\n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\ttb->insert_size[0] = 0;\n\t\ttb->pos_in_item++;\n\t} else {\n\t\t \n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\t}\n}\n\nstatic void balance_leaf_paste_right_shift(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n_shift, n_rem, r_zeroes_number, version;\n\tunsigned long temp_rem;\n\tconst char *r_body;\n\tstruct buffer_info bi;\n\n\t \n\tif (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {\n\t\tbalance_leaf_paste_right_shift_dirent(tb, ih, body);\n\t\treturn;\n\t}\n\n\t \n\n\t \n\tn_shift = tb->rbytes - tb->insert_size[0];\n\tif (n_shift < 0)\n\t\tn_shift = 0;\n\n\tRFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)),\n\t       \"PAP-12155: invalid position to paste. ih_item_len=%d, \"\n\t       \"pos_in_item=%d\", tb->pos_in_item,\n\t       ih_item_len(item_head(tbS0, tb->item_pos)));\n\n\tleaf_shift_right(tb, tb->rnum[0], n_shift);\n\n\t \n\tn_rem = tb->insert_size[0] - tb->rbytes;\n\tif (n_rem < 0)\n\t\tn_rem = 0;\n\n\ttemp_rem = n_rem;\n\n\tversion = ih_version(item_head(tb->R[0], 0));\n\n\tif (is_indirect_le_key(version, leaf_key(tb->R[0], 0))) {\n\t\tint shift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\ttemp_rem = n_rem << shift;\n\t}\n\n\tadd_le_key_k_offset(version, leaf_key(tb->R[0], 0), temp_rem);\n\tadd_le_key_k_offset(version, internal_key(tb->CFR[0], tb->rkey[0]),\n\t\t\t    temp_rem);\n\n\tdo_balance_mark_internal_dirty(tb, tb->CFR[0], 0);\n\n\t \n\tbuffer_info_init_right(tb, &bi);\n\tif (n_rem > tb->zeroes_num) {\n\t\tr_zeroes_number = 0;\n\t\tr_body = body + n_rem - tb->zeroes_num;\n\t} else {\n\t\tr_body = body;\n\t\tr_zeroes_number = tb->zeroes_num - n_rem;\n\t\ttb->zeroes_num -= r_zeroes_number;\n\t}\n\n\tleaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0] - n_rem,\n\t\t\t     r_body, r_zeroes_number);\n\n\tif (is_indirect_le_ih(item_head(tb->R[0], 0)))\n\t\tset_ih_free_space(item_head(tb->R[0], 0), 0);\n\n\ttb->insert_size[0] = n_rem;\n\tif (!n_rem)\n\t\ttb->pos_in_item++;\n}\n\nstatic void balance_leaf_paste_right_whole(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tstruct item_head *pasted;\n\tstruct buffer_info bi;\n\n\tbuffer_info_init_right(tb, &bi);\n\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\n\t \n\tif (tb->pos_in_item >= 0) {\n\t\tbuffer_info_init_right(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, tb->item_pos - n + tb->rnum[0],\n\t\t\t\t     tb->pos_in_item, tb->insert_size[0], body,\n\t\t\t\t     tb->zeroes_num);\n\t}\n\n\t \n\tpasted = item_head(tb->R[0], tb->item_pos - n + tb->rnum[0]);\n\tif (is_direntry_le_ih(pasted) && tb->pos_in_item >= 0) {\n\t\tleaf_paste_entries(&bi, tb->item_pos - n + tb->rnum[0],\n\t\t\t\t   tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\tif (!tb->pos_in_item) {\n\n\t\t\tRFALSE(tb->item_pos - n + tb->rnum[0],\n\t\t\t       \"PAP-12165: directory item must be first \"\n\t\t\t       \"item of node when pasting is in 0th position\");\n\n\t\t\t \n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\t\t}\n\t}\n\n\tif (is_indirect_le_ih(pasted))\n\t\tset_ih_free_space(pasted, 0);\n\ttb->zeroes_num = tb->insert_size[0] = 0;\n}\n\nstatic void balance_leaf_paste_right(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\n\t \n\tif (n - tb->rnum[0] > tb->item_pos) {\n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\t\treturn;\n\t}\n\n\t \n\n\tif (tb->item_pos == n - tb->rnum[0] && tb->rbytes != -1)\n\t\t \n\t\tbalance_leaf_paste_right_shift(tb, ih, body);\n\telse\n\t\t \n\t\tbalance_leaf_paste_right_whole(tb, ih, body);\n}\n\n \nstatic void balance_leaf_right(struct tree_balance *tb,\n\t\t\t       struct item_head * const ih,\n\t\t\t       const char * const body, int flag)\n{\n\tif (tb->rnum[0] <= 0)\n\t\treturn;\n\n\tBUG_ON(flag != M_INSERT && flag != M_PASTE);\n\n\tif (flag == M_INSERT)\n\t\tbalance_leaf_insert_right(tb, ih, body);\n\telse  \n\t\tbalance_leaf_paste_right(tb, ih, body);\n}\n\nstatic void balance_leaf_new_nodes_insert(struct tree_balance *tb,\n\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t  const char * const body,\n\t\t\t\t\t  struct item_head *insert_key,\n\t\t\t\t\t  struct buffer_head **insert_ptr,\n\t\t\t\t\t  int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tstruct buffer_info bi;\n\tint shift;\n\n\t \n\tif (n - tb->snum[i] >= tb->item_pos) {\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\n\t\t\t\ttb->snum[i], tb->sbytes[i], tb->S_new[i]);\n\t\treturn;\n\t}\n\n\t \n\n\t \n\tif (tb->item_pos == n - tb->snum[i] + 1 && tb->sbytes[i] != -1) {\n\t\tint old_key_comp, old_len, r_zeroes_number;\n\t\tconst char *r_body;\n\n\t\t \n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i] - 1, -1,\n\t\t\t\ttb->S_new[i]);\n\n\t\t \n\t\told_key_comp = le_ih_k_offset(ih);\n\t\told_len = ih_item_len(ih);\n\n\t\t \n\t\tshift = 0;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\tset_le_ih_k_offset(ih,\n\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t   ((old_len - tb->sbytes[i]) << shift));\n\n\t\tput_ih_item_len(ih, tb->sbytes[i]);\n\n\t\t \n\t\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\n\t\tif ((old_len - tb->sbytes[i]) > tb->zeroes_num) {\n\t\t\tr_zeroes_number = 0;\n\t\t\tr_body = body + (old_len - tb->sbytes[i]) -\n\t\t\t\t\t tb->zeroes_num;\n\t\t} else {\n\t\t\tr_body = body;\n\t\t\tr_zeroes_number = tb->zeroes_num - (old_len -\n\t\t\t\t\t  tb->sbytes[i]);\n\t\t\ttb->zeroes_num -= r_zeroes_number;\n\t\t}\n\n\t\tleaf_insert_into_buf(&bi, 0, ih, r_body, r_zeroes_number);\n\n\t\t \n\t\tset_le_ih_k_offset(ih, old_key_comp);\n\t\tput_ih_item_len(ih, old_len - tb->sbytes[i]);\n\t\ttb->insert_size[0] -= tb->sbytes[i];\n\t} else {\n\t\t \n\n\t\t \n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\n\t\t\t\ttb->snum[i] - 1, tb->sbytes[i], tb->S_new[i]);\n\n\t\t \n\t\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\t\tleaf_insert_into_buf(&bi, tb->item_pos - n + tb->snum[i] - 1,\n\t\t\t\t     ih, body, tb->zeroes_num);\n\n\t\ttb->zeroes_num = tb->insert_size[0] = 0;\n\t}\n}\n\n \nstatic void balance_leaf_new_nodes_paste_dirent(struct tree_balance *tb,\n\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t const char * const body,\n\t\t\t\t\t struct item_head *insert_key,\n\t\t\t\t\t struct buffer_head **insert_ptr,\n\t\t\t\t\t int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct item_head *aux_ih = item_head(tbS0, tb->item_pos);\n\tint entry_count = ih_entry_count(aux_ih);\n\tstruct buffer_info bi;\n\n\tif (entry_count - tb->sbytes[i] < tb->pos_in_item &&\n\t    tb->pos_in_item <= entry_count) {\n\t\t \n\n\t\tRFALSE(!tb->insert_size[0],\n\t\t       \"PAP-12215: insert_size is already 0\");\n\t\tRFALSE(tb->sbytes[i] - 1 >= entry_count,\n\t\t       \"PAP-12220: there are no so much entries (%d), only %d\",\n\t\t       tb->sbytes[i] - 1, entry_count);\n\n\t\t \n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],\n\t\t\t\ttb->sbytes[i] - 1, tb->S_new[i]);\n\n\t\t \n\t\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\t\tleaf_paste_in_buffer(&bi, 0, tb->pos_in_item - entry_count +\n\t\t\t\t     tb->sbytes[i] - 1, tb->insert_size[0],\n\t\t\t\t     body, tb->zeroes_num);\n\n\t\t \n\t\tleaf_paste_entries(&bi, 0, tb->pos_in_item - entry_count +\n\t\t\t\t   tb->sbytes[i] - 1, 1,\n\t\t\t\t   (struct reiserfs_de_head *) body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\ttb->insert_size[0] = 0;\n\t\ttb->pos_in_item++;\n\t} else {\n\t\t \n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],\n\t\t\t\ttb->sbytes[i], tb->S_new[i]);\n\t}\n\n}\n\nstatic void balance_leaf_new_nodes_paste_shift(struct tree_balance *tb,\n\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t const char * const body,\n\t\t\t\t\t struct item_head *insert_key,\n\t\t\t\t\t struct buffer_head **insert_ptr,\n\t\t\t\t\t int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct item_head *aux_ih = item_head(tbS0, tb->item_pos);\n\tint n_shift, n_rem, r_zeroes_number, shift;\n\tconst char *r_body;\n\tstruct item_head *tmp;\n\tstruct buffer_info bi;\n\n\tRFALSE(ih, \"PAP-12210: ih must be 0\");\n\n\tif (is_direntry_le_ih(aux_ih)) {\n\t\tbalance_leaf_new_nodes_paste_dirent(tb, ih, body, insert_key,\n\t\t\t\t\t\t    insert_ptr, i);\n\t\treturn;\n\t}\n\n\t \n\n\n\tRFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)) ||\n\t       tb->insert_size[0] <= 0,\n\t       \"PAP-12225: item too short or insert_size <= 0\");\n\n\t \n\tn_shift = tb->sbytes[i] - tb->insert_size[0];\n\tif (n_shift < 0)\n\t\tn_shift = 0;\n\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], n_shift,\n\t\t\ttb->S_new[i]);\n\n\t \n\tn_rem = tb->insert_size[0] - tb->sbytes[i];\n\tif (n_rem < 0)\n\t\tn_rem = 0;\n\n\t \n\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\tif (n_rem > tb->zeroes_num) {\n\t\tr_zeroes_number = 0;\n\t\tr_body = body + n_rem - tb->zeroes_num;\n\t} else {\n\t\tr_body = body;\n\t\tr_zeroes_number = tb->zeroes_num - n_rem;\n\t\ttb->zeroes_num -= r_zeroes_number;\n\t}\n\n\tleaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0] - n_rem,\n\t\t\t     r_body, r_zeroes_number);\n\n\ttmp = item_head(tb->S_new[i], 0);\n\tshift = 0;\n\tif (is_indirect_le_ih(tmp)) {\n\t\tset_ih_free_space(tmp, 0);\n\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t}\n\tadd_le_ih_k_offset(tmp, n_rem << shift);\n\n\ttb->insert_size[0] = n_rem;\n\tif (!n_rem)\n\t\ttb->pos_in_item++;\n}\n\nstatic void balance_leaf_new_nodes_paste_whole(struct tree_balance *tb,\n\t\t\t\t\t       struct item_head * const ih,\n\t\t\t\t\t       const char * const body,\n\t\t\t\t\t       struct item_head *insert_key,\n\t\t\t\t\t       struct buffer_head **insert_ptr,\n\t\t\t\t\t       int i)\n\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tint leaf_mi;\n\tstruct item_head *pasted;\n\tstruct buffer_info bi;\n\n#ifdef CONFIG_REISERFS_CHECK\n\tstruct item_head *ih_check = item_head(tbS0, tb->item_pos);\n\n\tif (!is_direntry_le_ih(ih_check) &&\n\t    (tb->pos_in_item != ih_item_len(ih_check) ||\n\t    tb->insert_size[0] <= 0))\n\t\treiserfs_panic(tb->tb_sb,\n\t\t\t     \"PAP-12235\",\n\t\t\t     \"pos_in_item must be equal to ih_item_len\");\n#endif\n\n\tleaf_mi = leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],\n\t\t\t\t  tb->sbytes[i], tb->S_new[i]);\n\n\tRFALSE(leaf_mi,\n\t       \"PAP-12240: unexpected value returned by leaf_move_items (%d)\",\n\t       leaf_mi);\n\n\t \n\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\tleaf_paste_in_buffer(&bi, tb->item_pos - n + tb->snum[i],\n\t\t\t     tb->pos_in_item, tb->insert_size[0],\n\t\t\t     body, tb->zeroes_num);\n\n\tpasted = item_head(tb->S_new[i], tb->item_pos - n +\n\t\t\t   tb->snum[i]);\n\tif (is_direntry_le_ih(pasted))\n\t\tleaf_paste_entries(&bi, tb->item_pos - n + tb->snum[i],\n\t\t\t\t   tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t \n\tif (is_indirect_le_ih(pasted))\n\t\tset_ih_free_space(pasted, 0);\n\n\ttb->zeroes_num = tb->insert_size[0] = 0;\n\n}\nstatic void balance_leaf_new_nodes_paste(struct tree_balance *tb,\n\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t const char * const body,\n\t\t\t\t\t struct item_head *insert_key,\n\t\t\t\t\t struct buffer_head **insert_ptr,\n\t\t\t\t\t int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\n\t \n\tif (n - tb->snum[i] > tb->item_pos) {\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\n\t\t\t\ttb->snum[i], tb->sbytes[i], tb->S_new[i]);\n\t\treturn;\n\t}\n\n\t \n\n\tif (tb->item_pos == n - tb->snum[i] && tb->sbytes[i] != -1)\n\t\t \n\t\tbalance_leaf_new_nodes_paste_shift(tb, ih, body, insert_key,\n\t\t\t\t\t\t   insert_ptr, i);\n\telse\n\t\t \n\t\tbalance_leaf_new_nodes_paste_whole(tb, ih, body, insert_key,\n\t\t\t\t\t\t   insert_ptr, i);\n}\n\n \nstatic void balance_leaf_new_nodes(struct tree_balance *tb,\n\t\t\t\t   struct item_head * const ih,\n\t\t\t\t   const char * const body,\n\t\t\t\t   struct item_head *insert_key,\n\t\t\t\t   struct buffer_head **insert_ptr,\n\t\t\t\t   int flag)\n{\n\tint i;\n\tfor (i = tb->blknum[0] - 2; i >= 0; i--) {\n\t\tBUG_ON(flag != M_INSERT && flag != M_PASTE);\n\n\t\tRFALSE(!tb->snum[i],\n\t\t       \"PAP-12200: snum[%d] == %d. Must be > 0\", i,\n\t\t       tb->snum[i]);\n\n\t\t \n\n\t\ttb->S_new[i] = get_FEB(tb);\n\n\t\t \n\t\tset_blkh_level(B_BLK_HEAD(tb->S_new[i]), DISK_LEAF_NODE_LEVEL);\n\n\t\tif (flag == M_INSERT)\n\t\t\tbalance_leaf_new_nodes_insert(tb, ih, body, insert_key,\n\t\t\t\t\t\t      insert_ptr, i);\n\t\telse  \n\t\t\tbalance_leaf_new_nodes_paste(tb, ih, body, insert_key,\n\t\t\t\t\t\t     insert_ptr, i);\n\n\t\tmemcpy(insert_key + i, leaf_key(tb->S_new[i], 0), KEY_SIZE);\n\t\tinsert_ptr[i] = tb->S_new[i];\n\n\t\tRFALSE(!buffer_journaled(tb->S_new[i])\n\t\t       || buffer_journal_dirty(tb->S_new[i])\n\t\t       || buffer_dirty(tb->S_new[i]),\n\t\t       \"PAP-12247: S_new[%d] : (%b)\",\n\t\t       i, tb->S_new[i]);\n\t}\n}\n\nstatic void balance_leaf_finish_node_insert(struct tree_balance *tb,\n\t\t\t\t\t    struct item_head * const ih,\n\t\t\t\t\t    const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct buffer_info bi;\n\tbuffer_info_init_tbS0(tb, &bi);\n\tleaf_insert_into_buf(&bi, tb->item_pos, ih, body, tb->zeroes_num);\n\n\t \n\tif (tb->item_pos == 0) {\n\t\tif (tb->CFL[0])\t \n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);\n\n\t}\n}\n\nstatic void balance_leaf_finish_node_paste_dirent(struct tree_balance *tb,\n\t\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t\t  const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct item_head *pasted = item_head(tbS0, tb->item_pos);\n\tstruct buffer_info bi;\n\n\tif (tb->pos_in_item >= 0 && tb->pos_in_item <= ih_entry_count(pasted)) {\n\t\tRFALSE(!tb->insert_size[0],\n\t\t       \"PAP-12260: insert_size is 0 already\");\n\n\t\t \n\t\tbuffer_info_init_tbS0(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, tb->item_pos, tb->pos_in_item,\n\t\t\t\t     tb->insert_size[0], body, tb->zeroes_num);\n\n\t\t \n\t\tleaf_paste_entries(&bi, tb->item_pos, tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\tif (!tb->item_pos && !tb->pos_in_item) {\n\t\t\tRFALSE(!tb->CFL[0] || !tb->L[0],\n\t\t\t       \"PAP-12270: CFL[0]/L[0] must  be specified\");\n\t\t\tif (tb->CFL[0])\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    tbS0, 0);\n\t\t}\n\n\t\ttb->insert_size[0] = 0;\n\t}\n}\n\nstatic void balance_leaf_finish_node_paste(struct tree_balance *tb,\n\t\t\t\t\t   struct item_head * const ih,\n\t\t\t\t\t   const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct buffer_info bi;\n\tstruct item_head *pasted = item_head(tbS0, tb->item_pos);\n\n\t \n\tif (is_direntry_le_ih(pasted)) {\n\t\tbalance_leaf_finish_node_paste_dirent(tb, ih, body);\n\t\treturn;\n\t}\n\n\t \n\n\tif (tb->pos_in_item == ih_item_len(pasted)) {\n\t\tRFALSE(tb->insert_size[0] <= 0,\n\t\t       \"PAP-12275: insert size must not be %d\",\n\t\t       tb->insert_size[0]);\n\t\tbuffer_info_init_tbS0(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, tb->item_pos,\n\t\t\t\t     tb->pos_in_item, tb->insert_size[0], body,\n\t\t\t\t     tb->zeroes_num);\n\n\t\tif (is_indirect_le_ih(pasted))\n\t\t\tset_ih_free_space(pasted, 0);\n\n\t\ttb->insert_size[0] = 0;\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\telse if (tb->insert_size[0]) {\n\t\tprint_cur_tb(\"12285\");\n\t\treiserfs_panic(tb->tb_sb, \"PAP-12285\",\n\t\t    \"insert_size must be 0 (%d)\", tb->insert_size[0]);\n\t}\n#endif\n}\n\n \nstatic void balance_leaf_finish_node(struct tree_balance *tb,\n\t\t\t\t      struct item_head * const ih,\n\t\t\t\t      const char * const body, int flag)\n{\n\t \n\tif (0 <= tb->item_pos && tb->item_pos < tb->s0num) {\n\t\tif (flag == M_INSERT)\n\t\t\tbalance_leaf_finish_node_insert(tb, ih, body);\n\t\telse  \n\t\t\tbalance_leaf_finish_node_paste(tb, ih, body);\n\t}\n}\n\n \nstatic int balance_leaf(struct tree_balance *tb, struct item_head *ih,\n\t\t\tconst char *body, int flag,\n\t\t\tstruct item_head *insert_key,\n\t\t\tstruct buffer_head **insert_ptr)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\n\tPROC_INFO_INC(tb->tb_sb, balance_at[0]);\n\n\t \n\tif (tb->insert_size[0] < 0)\n\t\treturn balance_leaf_when_delete(tb, flag);\n\n\ttb->item_pos = PATH_LAST_POSITION(tb->tb_path),\n\ttb->pos_in_item = tb->tb_path->pos_in_item,\n\ttb->zeroes_num = 0;\n\tif (flag == M_INSERT && !body)\n\t\ttb->zeroes_num = ih_item_len(ih);\n\n\t \n\tif (flag != M_INSERT\n\t    && is_indirect_le_ih(item_head(tbS0, tb->item_pos)))\n\t\ttb->pos_in_item *= UNFM_P_SIZE;\n\n\tbody += balance_leaf_left(tb, ih, body, flag);\n\n\t \n\t \n\ttb->item_pos -= (tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0));\n\n\tbalance_leaf_right(tb, ih, body, flag);\n\n\t \n\tRFALSE(tb->blknum[0] > 3,\n\t       \"PAP-12180: blknum can not be %d. It must be <= 3\", tb->blknum[0]);\n\tRFALSE(tb->blknum[0] < 0,\n\t       \"PAP-12185: blknum can not be %d. It must be >= 0\", tb->blknum[0]);\n\n\t \n\tif (tb->blknum[0] == 0) {\t \n\n\t\tRFALSE(!tb->lnum[0] || !tb->rnum[0],\n\t\t       \"PAP-12190: lnum and rnum must not be zero\");\n\t\t \n\t\tif (tb->CFL[0]) {\n\t\t\tif (!tb->CFR[0])\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-12195\",\n\t\t\t\t\t       \"CFR not initialized\");\n\t\t\tcopy_key(internal_key(tb->CFL[0], tb->lkey[0]),\n\t\t\t\t internal_key(tb->CFR[0], tb->rkey[0]));\n\t\t\tdo_balance_mark_internal_dirty(tb, tb->CFL[0], 0);\n\t\t}\n\n\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\treturn 0;\n\t}\n\n\tbalance_leaf_new_nodes(tb, ih, body, insert_key, insert_ptr, flag);\n\n\tbalance_leaf_finish_node(tb, ih, body, flag);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (flag == M_PASTE && tb->insert_size[0]) {\n\t\tprint_cur_tb(\"12290\");\n\t\treiserfs_panic(tb->tb_sb,\n\t\t\t       \"PAP-12290\", \"insert_size is still not 0 (%d)\",\n\t\t\t       tb->insert_size[0]);\n\t}\n#endif\n\n\t \n\treturn 0;\n}\n\n \nvoid make_empty_node(struct buffer_info *bi)\n{\n\tstruct block_head *blkh;\n\n\tRFALSE(bi->bi_bh == NULL, \"PAP-12295: pointer to the buffer is NULL\");\n\n\tblkh = B_BLK_HEAD(bi->bi_bh);\n\tset_blkh_nr_item(blkh, 0);\n\tset_blkh_free_space(blkh, MAX_CHILD_SIZE(bi->bi_bh));\n\n\tif (bi->bi_parent)\n\t\tB_N_CHILD(bi->bi_parent, bi->bi_position)->dc_size = 0;\t \n}\n\n \nstruct buffer_head *get_FEB(struct tree_balance *tb)\n{\n\tint i;\n\tstruct buffer_info bi;\n\n\tfor (i = 0; i < MAX_FEB_SIZE; i++)\n\t\tif (tb->FEB[i] != NULL)\n\t\t\tbreak;\n\n\tif (i == MAX_FEB_SIZE)\n\t\treiserfs_panic(tb->tb_sb, \"vs-12300\", \"FEB list is empty\");\n\n\tbuffer_info_init_bh(tb, &bi, tb->FEB[i]);\n\tmake_empty_node(&bi);\n\tset_buffer_uptodate(tb->FEB[i]);\n\ttb->used[i] = tb->FEB[i];\n\ttb->FEB[i] = NULL;\n\n\treturn tb->used[i];\n}\n\n \nstatic void store_thrown(struct tree_balance *tb, struct buffer_head *bh)\n{\n\tint i;\n\n\tif (buffer_dirty(bh))\n\t\treiserfs_warning(tb->tb_sb, \"reiserfs-12320\",\n\t\t\t\t \"called with dirty buffer\");\n\tfor (i = 0; i < ARRAY_SIZE(tb->thrown); i++)\n\t\tif (!tb->thrown[i]) {\n\t\t\ttb->thrown[i] = bh;\n\t\t\tget_bh(bh);\t \n\t\t\treturn;\n\t\t}\n\treiserfs_warning(tb->tb_sb, \"reiserfs-12321\",\n\t\t\t \"too many thrown buffers\");\n}\n\nstatic void free_thrown(struct tree_balance *tb)\n{\n\tint i;\n\tb_blocknr_t blocknr;\n\tfor (i = 0; i < ARRAY_SIZE(tb->thrown); i++) {\n\t\tif (tb->thrown[i]) {\n\t\t\tblocknr = tb->thrown[i]->b_blocknr;\n\t\t\tif (buffer_dirty(tb->thrown[i]))\n\t\t\t\treiserfs_warning(tb->tb_sb, \"reiserfs-12322\",\n\t\t\t\t\t\t \"called with dirty buffer %d\",\n\t\t\t\t\t\t blocknr);\n\t\t\tbrelse(tb->thrown[i]);\t \n\t\t\treiserfs_free_block(tb->transaction_handle, NULL,\n\t\t\t\t\t    blocknr, 0);\n\t\t}\n\t}\n}\n\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tblkh = B_BLK_HEAD(bh);\n\tset_blkh_level(blkh, FREE_LEVEL);\n\tset_blkh_nr_item(blkh, 0);\n\n\tclear_buffer_dirty(bh);\n\tstore_thrown(tb, bh);\n}\n\n \nvoid replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t \n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}\n\nint get_left_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FL[h] == NULL,\n\t       \"vs-12325: FL[%d](%p) or F[%d](%p) does not exist\",\n\t       h, tb->FL[h], h, PATH_H_PPARENT(tb->tb_path, h));\n\n\tif (Sh_position == 0)\n\t\treturn B_NR_ITEMS(tb->FL[h]);\n\telse\n\t\treturn Sh_position - 1;\n}\n\nint get_right_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FR[h] == NULL,\n\t       \"vs-12330: F[%d](%p) or FR[%d](%p) does not exist\",\n\t       h, PATH_H_PPARENT(tb->tb_path, h), h, tb->FR[h]);\n\n\tif (Sh_position == B_NR_ITEMS(PATH_H_PPARENT(tb->tb_path, h)))\n\t\treturn 0;\n\telse\n\t\treturn Sh_position + 1;\n}\n\n#ifdef CONFIG_REISERFS_CHECK\n\nint is_reusable(struct super_block *s, b_blocknr_t block, int bit_value);\nstatic void check_internal_node(struct super_block *s, struct buffer_head *bh,\n\t\t\t\tchar *mes)\n{\n\tstruct disk_child *dc;\n\tint i;\n\n\tRFALSE(!bh, \"PAP-12336: bh == 0\");\n\n\tif (!bh || !B_IS_IN_TREE(bh))\n\t\treturn;\n\n\tRFALSE(!buffer_dirty(bh) &&\n\t       !(buffer_journaled(bh) || buffer_journal_dirty(bh)),\n\t       \"PAP-12337: buffer (%b) must be dirty\", bh);\n\tdc = B_N_CHILD(bh, 0);\n\n\tfor (i = 0; i <= B_NR_ITEMS(bh); i++, dc++) {\n\t\tif (!is_reusable(s, dc_block_number(dc), 1)) {\n\t\t\tprint_cur_tb(mes);\n\t\t\treiserfs_panic(s, \"PAP-12338\",\n\t\t\t\t       \"invalid child pointer %y in %b\",\n\t\t\t\t       dc, bh);\n\t\t}\n\t}\n}\n\nstatic int locked_or_not_in_tree(struct tree_balance *tb,\n\t\t\t\t  struct buffer_head *bh, char *which)\n{\n\tif ((!buffer_journal_prepared(bh) && buffer_locked(bh)) ||\n\t    !B_IS_IN_TREE(bh)) {\n\t\treiserfs_warning(tb->tb_sb, \"vs-12339\", \"%s (%b)\", which, bh);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int check_before_balancing(struct tree_balance *tb)\n{\n\tint retval = 0;\n\n\tif (REISERFS_SB(tb->tb_sb)->cur_tb) {\n\t\treiserfs_panic(tb->tb_sb, \"vs-12335\", \"suspect that schedule \"\n\t\t\t       \"occurred based on cur_tb not being null at \"\n\t\t\t       \"this point in code. do_balance cannot properly \"\n\t\t\t       \"handle concurrent tree accesses on a same \"\n\t\t\t       \"mount point.\");\n\t}\n\n\t \n\tif (tb->lnum[0]) {\n\t\tretval |= locked_or_not_in_tree(tb, tb->L[0], \"L[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->FL[0], \"FL[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->CFL[0], \"CFL[0]\");\n\t\tcheck_leaf(tb->L[0]);\n\t}\n\tif (tb->rnum[0]) {\n\t\tretval |= locked_or_not_in_tree(tb, tb->R[0], \"R[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->FR[0], \"FR[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->CFR[0], \"CFR[0]\");\n\t\tcheck_leaf(tb->R[0]);\n\t}\n\tretval |= locked_or_not_in_tree(tb, PATH_PLAST_BUFFER(tb->tb_path),\n\t\t\t\t\t\"S[0]\");\n\tcheck_leaf(PATH_PLAST_BUFFER(tb->tb_path));\n\n\treturn retval;\n}\n\nstatic void check_after_balance_leaf(struct tree_balance *tb)\n{\n\tif (tb->lnum[0]) {\n\t\tif (B_FREE_SPACE(tb->L[0]) !=\n\t\t    MAX_CHILD_SIZE(tb->L[0]) -\n\t\t    dc_size(B_N_CHILD\n\t\t\t    (tb->FL[0], get_left_neighbor_position(tb, 0)))) {\n\t\t\tprint_cur_tb(\"12221\");\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-12355\",\n\t\t\t\t       \"shift to left was incorrect\");\n\t\t}\n\t}\n\tif (tb->rnum[0]) {\n\t\tif (B_FREE_SPACE(tb->R[0]) !=\n\t\t    MAX_CHILD_SIZE(tb->R[0]) -\n\t\t    dc_size(B_N_CHILD\n\t\t\t    (tb->FR[0], get_right_neighbor_position(tb, 0)))) {\n\t\t\tprint_cur_tb(\"12222\");\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-12360\",\n\t\t\t\t       \"shift to right was incorrect\");\n\t\t}\n\t}\n\tif (PATH_H_PBUFFER(tb->tb_path, 1) &&\n\t    (B_FREE_SPACE(PATH_H_PBUFFER(tb->tb_path, 0)) !=\n\t     (MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)) -\n\t      dc_size(B_N_CHILD(PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\tPATH_H_POSITION(tb->tb_path, 1)))))) {\n\t\tint left = B_FREE_SPACE(PATH_H_PBUFFER(tb->tb_path, 0));\n\t\tint right = (MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)) -\n\t\t\t     dc_size(B_N_CHILD(PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\t\t       PATH_H_POSITION(tb->tb_path,\n\t\t\t\t\t\t\t       1))));\n\t\tprint_cur_tb(\"12223\");\n\t\treiserfs_warning(tb->tb_sb, \"reiserfs-12363\",\n\t\t\t\t \"B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0)) = %d; \"\n\t\t\t\t \"MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d\",\n\t\t\t\t left,\n\t\t\t\t MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)),\n\t\t\t\t PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\t PATH_H_POSITION(tb->tb_path, 1),\n\t\t\t\t dc_size(B_N_CHILD\n\t\t\t\t\t (PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\t\t  PATH_H_POSITION(tb->tb_path, 1))),\n\t\t\t\t right);\n\t\treiserfs_panic(tb->tb_sb, \"PAP-12365\", \"S is incorrect\");\n\t}\n}\n\nstatic void check_leaf_level(struct tree_balance *tb)\n{\n\tcheck_leaf(tb->L[0]);\n\tcheck_leaf(tb->R[0]);\n\tcheck_leaf(PATH_PLAST_BUFFER(tb->tb_path));\n}\n\nstatic void check_internal_levels(struct tree_balance *tb)\n{\n\tint h;\n\n\t \n\tfor (h = 1; tb->insert_size[h]; h++) {\n\t\tcheck_internal_node(tb->tb_sb, PATH_H_PBUFFER(tb->tb_path, h),\n\t\t\t\t    \"BAD BUFFER ON PATH\");\n\t\tif (tb->lnum[h])\n\t\t\tcheck_internal_node(tb->tb_sb, tb->L[h], \"BAD L\");\n\t\tif (tb->rnum[h])\n\t\t\tcheck_internal_node(tb->tb_sb, tb->R[h], \"BAD R\");\n\t}\n\n}\n\n#endif\n\n \n\n \n\nstatic inline void do_balance_starts(struct tree_balance *tb)\n{\n\t \n\n\t \n\n\t \n\t \n\tRFALSE(check_before_balancing(tb), \"PAP-12340: locked buffers in TB\");\n#ifdef CONFIG_REISERFS_CHECK\n\tREISERFS_SB(tb->tb_sb)->cur_tb = tb;\n#endif\n}\n\nstatic inline void do_balance_completed(struct tree_balance *tb)\n{\n\n#ifdef CONFIG_REISERFS_CHECK\n\tcheck_leaf_level(tb);\n\tcheck_internal_levels(tb);\n\tREISERFS_SB(tb->tb_sb)->cur_tb = NULL;\n#endif\n\n\t \n\n\tREISERFS_SB(tb->tb_sb)->s_do_balance++;\n\n\t \n\tunfix_nodes(tb);\n\n\tfree_thrown(tb);\n}\n\n \nvoid do_balance(struct tree_balance *tb, struct item_head *ih,\n\t\tconst char *body, int flag)\n{\n\tint child_pos;\t\t \n\tint h;\t\t\t \n\n\t \n\tstruct item_head insert_key[2];\n\n\t \n\tstruct buffer_head *insert_ptr[2];\n\n\ttb->tb_mode = flag;\n\ttb->need_balance_dirty = 0;\n\n\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\treiserfs_panic(tb->tb_sb, \"clm-6000\", \"fs generation has \"\n\t\t\t       \"changed\");\n\t}\n\t \n\tif (!tb->insert_size[0]) {\n\t\treiserfs_warning(tb->tb_sb, \"PAP-12350\",\n\t\t\t\t \"insert_size == 0, mode == %c\", flag);\n\t\tunfix_nodes(tb);\n\t\treturn;\n\t}\n\n\tatomic_inc(&fs_generation(tb->tb_sb));\n\tdo_balance_starts(tb);\n\n\t \n\tchild_pos = PATH_H_B_ITEM_ORDER(tb->tb_path, 0) +\n\t    balance_leaf(tb, ih, body, flag, insert_key, insert_ptr);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tcheck_after_balance_leaf(tb);\n#endif\n\n\t \n\tfor (h = 1; h < MAX_HEIGHT && tb->insert_size[h]; h++)\n\t\tchild_pos = balance_internal(tb, h, child_pos, insert_key,\n\t\t\t\t\t     insert_ptr);\n\n\tdo_balance_completed(tb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}