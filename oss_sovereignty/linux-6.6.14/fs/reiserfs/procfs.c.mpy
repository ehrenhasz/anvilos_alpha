{
  "module_name": "procfs.c",
  "hash_id": "af1d90753aa3228c381b985334b3bc99c08244ea599c822de72bedda71fc60d1",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/procfs.c",
  "human_readable_source": " \n\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include \"reiserfs.h\"\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/blkdev.h>\n\n \n\nstatic int show_version(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tchar *format;\n\n\tif (REISERFS_SB(sb)->s_properties & (1 << REISERFS_3_6)) {\n\t\tformat = \"3.6\";\n\t} else if (REISERFS_SB(sb)->s_properties & (1 << REISERFS_3_5)) {\n\t\tformat = \"3.5\";\n\t} else {\n\t\tformat = \"unknown\";\n\t}\n\n\tseq_printf(m, \"%s format\\twith checks %s\\n\", format,\n#if defined( CONFIG_REISERFS_CHECK )\n\t\t   \"on\"\n#else\n\t\t   \"off\"\n#endif\n\t    );\n\treturn 0;\n}\n\n#define SF( x ) ( r -> x )\n#define SFP( x ) SF( s_proc_info_data.x )\n#define SFPL( x ) SFP( x[ level ] )\n#define SFPF( x ) SFP( scan_bitmap.x )\n#define SFPJ( x ) SFP( journal.x )\n\n#define D2C( x ) le16_to_cpu( x )\n#define D4C( x ) le32_to_cpu( x )\n#define DF( x ) D2C( rs -> s_v1.x )\n#define DFL( x ) D4C( rs -> s_v1.x )\n\n#define objectid_map( s, rs ) (old_format_only (s) ?\t\t\t\t\\\n                         (__le32 *)((struct reiserfs_super_block_v1 *)rs + 1) :\t\\\n\t\t\t (__le32 *)(rs + 1))\n#define MAP( i ) D4C( objectid_map( sb, rs )[ i ] )\n\n#define DJF( x ) le32_to_cpu( rs -> x )\n#define DJP( x ) le32_to_cpu( jp -> x )\n#define JF( x ) ( r -> s_journal -> x )\n\nstatic int show_super(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tstruct reiserfs_sb_info *r = REISERFS_SB(sb);\n\n\tseq_printf(m, \"state: \\t%s\\n\"\n\t\t   \"mount options: \\t%s%s%s%s%s%s%s%s%s%s%s\\n\"\n\t\t   \"gen. counter: \\t%i\\n\"\n\t\t   \"s_disk_reads: \\t%i\\n\"\n\t\t   \"s_disk_writes: \\t%i\\n\"\n\t\t   \"s_fix_nodes: \\t%i\\n\"\n\t\t   \"s_do_balance: \\t%i\\n\"\n\t\t   \"s_unneeded_left_neighbor: \\t%i\\n\"\n\t\t   \"s_good_search_by_key_reada: \\t%i\\n\"\n\t\t   \"s_bmaps: \\t%i\\n\"\n\t\t   \"s_bmaps_without_search: \\t%i\\n\"\n\t\t   \"s_direct2indirect: \\t%i\\n\"\n\t\t   \"s_indirect2direct: \\t%i\\n\"\n\t\t   \"\\n\"\n\t\t   \"max_hash_collisions: \\t%i\\n\"\n\t\t   \"breads: \\t%lu\\n\"\n\t\t   \"bread_misses: \\t%lu\\n\"\n\t\t   \"search_by_key: \\t%lu\\n\"\n\t\t   \"search_by_key_fs_changed: \\t%lu\\n\"\n\t\t   \"search_by_key_restarted: \\t%lu\\n\"\n\t\t   \"insert_item_restarted: \\t%lu\\n\"\n\t\t   \"paste_into_item_restarted: \\t%lu\\n\"\n\t\t   \"cut_from_item_restarted: \\t%lu\\n\"\n\t\t   \"delete_solid_item_restarted: \\t%lu\\n\"\n\t\t   \"delete_item_restarted: \\t%lu\\n\"\n\t\t   \"leaked_oid: \\t%lu\\n\"\n\t\t   \"leaves_removable: \\t%lu\\n\",\n\t\t   SF(s_mount_state) == REISERFS_VALID_FS ?\n\t\t   \"REISERFS_VALID_FS\" : \"REISERFS_ERROR_FS\",\n\t\t   reiserfs_r5_hash(sb) ? \"FORCE_R5 \" : \"\",\n\t\t   reiserfs_rupasov_hash(sb) ? \"FORCE_RUPASOV \" : \"\",\n\t\t   reiserfs_tea_hash(sb) ? \"FORCE_TEA \" : \"\",\n\t\t   reiserfs_hash_detect(sb) ? \"DETECT_HASH \" : \"\",\n\t\t   reiserfs_no_border(sb) ? \"NO_BORDER \" : \"BORDER \",\n\t\t   reiserfs_no_unhashed_relocation(sb) ?\n\t\t   \"NO_UNHASHED_RELOCATION \" : \"\",\n\t\t   reiserfs_hashed_relocation(sb) ? \"UNHASHED_RELOCATION \" : \"\",\n\t\t   reiserfs_test4(sb) ? \"TEST4 \" : \"\",\n\t\t   have_large_tails(sb) ? \"TAILS \" : have_small_tails(sb) ?\n\t\t   \"SMALL_TAILS \" : \"NO_TAILS \",\n\t\t   replay_only(sb) ? \"REPLAY_ONLY \" : \"\",\n\t\t   convert_reiserfs(sb) ? \"CONV \" : \"\",\n\t\t   atomic_read(&r->s_generation_counter),\n\t\t   SF(s_disk_reads), SF(s_disk_writes), SF(s_fix_nodes),\n\t\t   SF(s_do_balance), SF(s_unneeded_left_neighbor),\n\t\t   SF(s_good_search_by_key_reada), SF(s_bmaps),\n\t\t   SF(s_bmaps_without_search), SF(s_direct2indirect),\n\t\t   SF(s_indirect2direct), SFP(max_hash_collisions), SFP(breads),\n\t\t   SFP(bread_miss), SFP(search_by_key),\n\t\t   SFP(search_by_key_fs_changed), SFP(search_by_key_restarted),\n\t\t   SFP(insert_item_restarted), SFP(paste_into_item_restarted),\n\t\t   SFP(cut_from_item_restarted),\n\t\t   SFP(delete_solid_item_restarted), SFP(delete_item_restarted),\n\t\t   SFP(leaked_oid), SFP(leaves_removable));\n\n\treturn 0;\n}\n\nstatic int show_per_level(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tstruct reiserfs_sb_info *r = REISERFS_SB(sb);\n\tint level;\n\n\tseq_printf(m, \"level\\t\"\n\t\t   \"     balances\"\n\t\t   \" [sbk:  reads\"\n\t\t   \"   fs_changed\"\n\t\t   \"   restarted]\"\n\t\t   \"   free space\"\n\t\t   \"        items\"\n\t\t   \"   can_remove\"\n\t\t   \"         lnum\"\n\t\t   \"         rnum\"\n\t\t   \"       lbytes\"\n\t\t   \"       rbytes\"\n\t\t   \"     get_neig\"\n\t\t   \" get_neig_res\" \"  need_l_neig\" \"  need_r_neig\" \"\\n\");\n\n\tfor (level = 0; level < MAX_HEIGHT; ++level) {\n\t\tseq_printf(m, \"%i\\t\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12li\"\n\t\t\t   \" %12li\"\n\t\t\t   \" %12li\"\n\t\t\t   \" %12li\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \"\\n\",\n\t\t\t   level,\n\t\t\t   SFPL(balance_at),\n\t\t\t   SFPL(sbk_read_at),\n\t\t\t   SFPL(sbk_fs_changed),\n\t\t\t   SFPL(sbk_restarted),\n\t\t\t   SFPL(free_at),\n\t\t\t   SFPL(items_at),\n\t\t\t   SFPL(can_node_be_removed),\n\t\t\t   SFPL(lnum),\n\t\t\t   SFPL(rnum),\n\t\t\t   SFPL(lbytes),\n\t\t\t   SFPL(rbytes),\n\t\t\t   SFPL(get_neighbors),\n\t\t\t   SFPL(get_neighbors_restart),\n\t\t\t   SFPL(need_l_neighbor), SFPL(need_r_neighbor)\n\t\t    );\n\t}\n\treturn 0;\n}\n\nstatic int show_bitmap(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tstruct reiserfs_sb_info *r = REISERFS_SB(sb);\n\n\tseq_printf(m, \"free_block: %lu\\n\"\n\t\t   \"  scan_bitmap:\"\n\t\t   \"          wait\"\n\t\t   \"          bmap\"\n\t\t   \"         retry\"\n\t\t   \"        stolen\"\n\t\t   \"  journal_hint\"\n\t\t   \"journal_nohint\"\n\t\t   \"\\n\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \"\\n\",\n\t\t   SFP(free_block),\n\t\t   SFPF(call),\n\t\t   SFPF(wait),\n\t\t   SFPF(bmap),\n\t\t   SFPF(retry),\n\t\t   SFPF(stolen),\n\t\t   SFPF(in_journal_hint), SFPF(in_journal_nohint));\n\n\treturn 0;\n}\n\nstatic int show_on_disk_super(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tstruct reiserfs_sb_info *sb_info = REISERFS_SB(sb);\n\tstruct reiserfs_super_block *rs = sb_info->s_rs;\n\tint hash_code = DFL(s_hash_function_code);\n\t__u32 flags = DJF(s_flags);\n\n\tseq_printf(m, \"block_count: \\t%i\\n\"\n\t\t   \"free_blocks: \\t%i\\n\"\n\t\t   \"root_block: \\t%i\\n\"\n\t\t   \"blocksize: \\t%i\\n\"\n\t\t   \"oid_maxsize: \\t%i\\n\"\n\t\t   \"oid_cursize: \\t%i\\n\"\n\t\t   \"umount_state: \\t%i\\n\"\n\t\t   \"magic: \\t%10.10s\\n\"\n\t\t   \"fs_state: \\t%i\\n\"\n\t\t   \"hash: \\t%s\\n\"\n\t\t   \"tree_height: \\t%i\\n\"\n\t\t   \"bmap_nr: \\t%i\\n\"\n\t\t   \"version: \\t%i\\n\"\n\t\t   \"flags: \\t%x[%s]\\n\"\n\t\t   \"reserved_for_journal: \\t%i\\n\",\n\t\t   DFL(s_block_count),\n\t\t   DFL(s_free_blocks),\n\t\t   DFL(s_root_block),\n\t\t   DF(s_blocksize),\n\t\t   DF(s_oid_maxsize),\n\t\t   DF(s_oid_cursize),\n\t\t   DF(s_umount_state),\n\t\t   rs->s_v1.s_magic,\n\t\t   DF(s_fs_state),\n\t\t   hash_code == TEA_HASH ? \"tea\" :\n\t\t   (hash_code == YURA_HASH) ? \"rupasov\" :\n\t\t   (hash_code == R5_HASH) ? \"r5\" :\n\t\t   (hash_code == UNSET_HASH) ? \"unset\" : \"unknown\",\n\t\t   DF(s_tree_height),\n\t\t   DF(s_bmap_nr),\n\t\t   DF(s_version), flags, (flags & reiserfs_attrs_cleared)\n\t\t   ? \"attrs_cleared\" : \"\", DF(s_reserved_for_journal));\n\n\treturn 0;\n}\n\nstatic int show_oidmap(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tstruct reiserfs_sb_info *sb_info = REISERFS_SB(sb);\n\tstruct reiserfs_super_block *rs = sb_info->s_rs;\n\tunsigned int mapsize = le16_to_cpu(rs->s_v1.s_oid_cursize);\n\tunsigned long total_used = 0;\n\tint i;\n\n\tfor (i = 0; i < mapsize; ++i) {\n\t\t__u32 right;\n\n\t\tright = (i == mapsize - 1) ? MAX_KEY_OBJECTID : MAP(i + 1);\n\t\tseq_printf(m, \"%s: [ %x .. %x )\\n\",\n\t\t\t   (i & 1) ? \"free\" : \"used\", MAP(i), right);\n\t\tif (!(i & 1)) {\n\t\t\ttotal_used += right - MAP(i);\n\t\t}\n\t}\n#if defined( REISERFS_USE_OIDMAPF )\n\tif (sb_info->oidmap.use_file && (sb_info->oidmap.mapf != NULL)) {\n\t\tloff_t size = file_inode(sb_info->oidmap.mapf)->i_size;\n\t\ttotal_used += size / sizeof(reiserfs_oidinterval_d_t);\n\t}\n#endif\n\tseq_printf(m, \"total: \\t%i [%i/%i] used: %lu [exact]\\n\",\n\t\t   mapsize,\n\t\t   mapsize, le16_to_cpu(rs->s_v1.s_oid_maxsize), total_used);\n\treturn 0;\n}\n\nstatic time64_t ktime_mono_to_real_seconds(time64_t mono)\n{\n\tktime_t kt = ktime_set(mono, NSEC_PER_SEC/2);\n\n\treturn ktime_divns(ktime_mono_to_real(kt), NSEC_PER_SEC);\n}\n\nstatic int show_journal(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tstruct reiserfs_sb_info *r = REISERFS_SB(sb);\n\tstruct reiserfs_super_block *rs = r->s_rs;\n\tstruct journal_params *jp = &rs->s_v1.s_journal;\n\n\tseq_printf(m,\t\t \n\t\t   \"jp_journal_1st_block: \\t%i\\n\"\n\t\t   \"jp_journal_dev: \\t%pg[%x]\\n\"\n\t\t   \"jp_journal_size: \\t%i\\n\"\n\t\t   \"jp_journal_trans_max: \\t%i\\n\"\n\t\t   \"jp_journal_magic: \\t%i\\n\"\n\t\t   \"jp_journal_max_batch: \\t%i\\n\"\n\t\t   \"jp_journal_max_commit_age: \\t%i\\n\"\n\t\t   \"jp_journal_max_trans_age: \\t%i\\n\"\n\t\t    \n\t\t   \"j_1st_reserved_block: \\t%i\\n\"\n\t\t   \"j_state: \\t%li\\n\"\n\t\t   \"j_trans_id: \\t%u\\n\"\n\t\t   \"j_mount_id: \\t%lu\\n\"\n\t\t   \"j_start: \\t%lu\\n\"\n\t\t   \"j_len: \\t%lu\\n\"\n\t\t   \"j_len_alloc: \\t%lu\\n\"\n\t\t   \"j_wcount: \\t%i\\n\"\n\t\t   \"j_bcount: \\t%lu\\n\"\n\t\t   \"j_first_unflushed_offset: \\t%lu\\n\"\n\t\t   \"j_last_flush_trans_id: \\t%u\\n\"\n\t\t   \"j_trans_start_time: \\t%lli\\n\"\n\t\t   \"j_list_bitmap_index: \\t%i\\n\"\n\t\t   \"j_must_wait: \\t%i\\n\"\n\t\t   \"j_next_full_flush: \\t%i\\n\"\n\t\t   \"j_next_async_flush: \\t%i\\n\"\n\t\t   \"j_cnode_used: \\t%i\\n\" \"j_cnode_free: \\t%i\\n\" \"\\n\"\n\t\t    \n\t\t   \"in_journal: \\t%12lu\\n\"\n\t\t   \"in_journal_bitmap: \\t%12lu\\n\"\n\t\t   \"in_journal_reusable: \\t%12lu\\n\"\n\t\t   \"lock_journal: \\t%12lu\\n\"\n\t\t   \"lock_journal_wait: \\t%12lu\\n\"\n\t\t   \"journal_begin: \\t%12lu\\n\"\n\t\t   \"journal_relock_writers: \\t%12lu\\n\"\n\t\t   \"journal_relock_wcount: \\t%12lu\\n\"\n\t\t   \"mark_dirty: \\t%12lu\\n\"\n\t\t   \"mark_dirty_already: \\t%12lu\\n\"\n\t\t   \"mark_dirty_notjournal: \\t%12lu\\n\"\n\t\t   \"restore_prepared: \\t%12lu\\n\"\n\t\t   \"prepare: \\t%12lu\\n\"\n\t\t   \"prepare_retry: \\t%12lu\\n\",\n\t\t   DJP(jp_journal_1st_block),\n\t\t   SB_JOURNAL(sb)->j_dev_bd,\n\t\t   DJP(jp_journal_dev),\n\t\t   DJP(jp_journal_size),\n\t\t   DJP(jp_journal_trans_max),\n\t\t   DJP(jp_journal_magic),\n\t\t   DJP(jp_journal_max_batch),\n\t\t   SB_JOURNAL(sb)->j_max_commit_age,\n\t\t   DJP(jp_journal_max_trans_age),\n\t\t   JF(j_1st_reserved_block),\n\t\t   JF(j_state),\n\t\t   JF(j_trans_id),\n\t\t   JF(j_mount_id),\n\t\t   JF(j_start),\n\t\t   JF(j_len),\n\t\t   JF(j_len_alloc),\n\t\t   atomic_read(&r->s_journal->j_wcount),\n\t\t   JF(j_bcount),\n\t\t   JF(j_first_unflushed_offset),\n\t\t   JF(j_last_flush_trans_id),\n\t\t   ktime_mono_to_real_seconds(JF(j_trans_start_time)),\n\t\t   JF(j_list_bitmap_index),\n\t\t   JF(j_must_wait),\n\t\t   JF(j_next_full_flush),\n\t\t   JF(j_next_async_flush),\n\t\t   JF(j_cnode_used),\n\t\t   JF(j_cnode_free),\n\t\t   SFPJ(in_journal),\n\t\t   SFPJ(in_journal_bitmap),\n\t\t   SFPJ(in_journal_reusable),\n\t\t   SFPJ(lock_journal),\n\t\t   SFPJ(lock_journal_wait),\n\t\t   SFPJ(journal_being),\n\t\t   SFPJ(journal_relock_writers),\n\t\t   SFPJ(journal_relock_wcount),\n\t\t   SFPJ(mark_dirty),\n\t\t   SFPJ(mark_dirty_already),\n\t\t   SFPJ(mark_dirty_notjournal),\n\t\t   SFPJ(restore_prepared), SFPJ(prepare), SFPJ(prepare_retry)\n\t    );\n\treturn 0;\n}\n\nstatic struct proc_dir_entry *proc_info_root = NULL;\nstatic const char proc_info_root_name[] = \"fs/reiserfs\";\n\nstatic void add_file(struct super_block *sb, char *name,\n\t\t     int (*func) (struct seq_file *, void *))\n{\n\tproc_create_single_data(name, 0, REISERFS_SB(sb)->procdir, func, sb);\n}\n\nint reiserfs_proc_info_init(struct super_block *sb)\n{\n\tchar b[BDEVNAME_SIZE];\n\tchar *s;\n\n\t \n\tstrscpy(b, sb->s_id, BDEVNAME_SIZE);\n\ts = strchr(b, '/');\n\tif (s)\n\t\t*s = '!';\n\n\tspin_lock_init(&__PINFO(sb).lock);\n\tREISERFS_SB(sb)->procdir = proc_mkdir_data(b, 0, proc_info_root, sb);\n\tif (REISERFS_SB(sb)->procdir) {\n\t\tadd_file(sb, \"version\", show_version);\n\t\tadd_file(sb, \"super\", show_super);\n\t\tadd_file(sb, \"per-level\", show_per_level);\n\t\tadd_file(sb, \"bitmap\", show_bitmap);\n\t\tadd_file(sb, \"on-disk-super\", show_on_disk_super);\n\t\tadd_file(sb, \"oidmap\", show_oidmap);\n\t\tadd_file(sb, \"journal\", show_journal);\n\t\treturn 0;\n\t}\n\treiserfs_warning(sb, \"cannot create /proc/%s/%s\",\n\t\t\t proc_info_root_name, b);\n\treturn 1;\n}\n\nint reiserfs_proc_info_done(struct super_block *sb)\n{\n\tstruct proc_dir_entry *de = REISERFS_SB(sb)->procdir;\n\tif (de) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\tchar *s;\n\n\t\t \n\t\tstrscpy(b, sb->s_id, BDEVNAME_SIZE);\n\t\ts = strchr(b, '/');\n\t\tif (s)\n\t\t\t*s = '!';\n\n\t\tremove_proc_subtree(b, proc_info_root);\n\t\tREISERFS_SB(sb)->procdir = NULL;\n\t}\n\treturn 0;\n}\n\nint reiserfs_proc_info_global_init(void)\n{\n\tif (proc_info_root == NULL) {\n\t\tproc_info_root = proc_mkdir(proc_info_root_name, NULL);\n\t\tif (!proc_info_root) {\n\t\t\treiserfs_warning(NULL, \"cannot create /proc/%s\",\n\t\t\t\t\t proc_info_root_name);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint reiserfs_proc_info_global_done(void)\n{\n\tif (proc_info_root != NULL) {\n\t\tproc_info_root = NULL;\n\t\tremove_proc_entry(proc_info_root_name, NULL);\n\t}\n\treturn 0;\n}\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}