{
  "module_name": "bitmap.c",
  "hash_id": "b4a0a303df241887da02e5f4257f84ab54a00337d731ec1a14fb586f8bd46f22",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/bitmap.c",
  "human_readable_source": " \n \n\n#include <linux/time.h>\n#include \"reiserfs.h\"\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n\n#define PREALLOCATION_SIZE 9\n\n \n\n#define SB_ALLOC_OPTS(s) (REISERFS_SB(s)->s_alloc_options.bits)\n\n#define  _ALLOC_concentrating_formatted_nodes 0\n#define  _ALLOC_displacing_large_files 1\n#define  _ALLOC_displacing_new_packing_localities 2\n#define  _ALLOC_old_hashed_relocation 3\n#define  _ALLOC_new_hashed_relocation 4\n#define  _ALLOC_skip_busy 5\n#define  _ALLOC_displace_based_on_dirid 6\n#define  _ALLOC_hashed_formatted_nodes 7\n#define  _ALLOC_old_way 8\n#define  _ALLOC_hundredth_slices 9\n#define  _ALLOC_dirid_groups 10\n#define  _ALLOC_oid_groups 11\n#define  _ALLOC_packing_groups 12\n\n#define  concentrating_formatted_nodes(s)\ttest_bit(_ALLOC_concentrating_formatted_nodes, &SB_ALLOC_OPTS(s))\n#define  displacing_large_files(s)\t\ttest_bit(_ALLOC_displacing_large_files, &SB_ALLOC_OPTS(s))\n#define  displacing_new_packing_localities(s)\ttest_bit(_ALLOC_displacing_new_packing_localities, &SB_ALLOC_OPTS(s))\n\n#define SET_OPTION(optname) \\\n   do { \\\n\treiserfs_info(s, \"block allocator option \\\"%s\\\" is set\", #optname); \\\n\tset_bit(_ALLOC_ ## optname , &SB_ALLOC_OPTS(s)); \\\n    } while(0)\n#define TEST_OPTION(optname, s) \\\n    test_bit(_ALLOC_ ## optname , &SB_ALLOC_OPTS(s))\n\nstatic inline void get_bit_address(struct super_block *s,\n\t\t\t\t   b_blocknr_t block,\n\t\t\t\t   unsigned int *bmap_nr,\n\t\t\t\t   unsigned int *offset)\n{\n\t \n\t*bmap_nr = block >> (s->s_blocksize_bits + 3);\n\t \n\t*offset = block & ((s->s_blocksize << 3) - 1);\n}\n\nint is_reusable(struct super_block *s, b_blocknr_t block, int bit_value)\n{\n\tunsigned int bmap, offset;\n\tunsigned int bmap_count = reiserfs_bmap_count(s);\n\n\tif (block == 0 || block >= SB_BLOCK_COUNT(s)) {\n\t\treiserfs_error(s, \"vs-4010\",\n\t\t\t       \"block number is out of range %lu (%u)\",\n\t\t\t       block, SB_BLOCK_COUNT(s));\n\t\treturn 0;\n\t}\n\n\tget_bit_address(s, block, &bmap, &offset);\n\n\t \n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(s)->s_properties))) {\n\t\tb_blocknr_t bmap1 = REISERFS_SB(s)->s_sbh->b_blocknr + 1;\n\t\tif (block >= bmap1 &&\n\t\t    block <= bmap1 + bmap_count) {\n\t\t\treiserfs_error(s, \"vs-4019\", \"bitmap block %lu(%u) \"\n\t\t\t\t       \"can't be freed or reused\",\n\t\t\t\t       block, bmap_count);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (offset == 0) {\n\t\t\treiserfs_error(s, \"vs-4020\", \"bitmap block %lu(%u) \"\n\t\t\t\t       \"can't be freed or reused\",\n\t\t\t\t       block, bmap_count);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (bmap >= bmap_count) {\n\t\treiserfs_error(s, \"vs-4030\", \"bitmap for requested block \"\n\t\t\t       \"is out of range: block=%lu, bitmap_nr=%u\",\n\t\t\t       block, bmap);\n\t\treturn 0;\n\t}\n\n\tif (bit_value == 0 && block == SB_ROOT_BLOCK(s)) {\n\t\treiserfs_error(s, \"vs-4050\", \"this is root block (%u), \"\n\t\t\t       \"it must be busy\", SB_ROOT_BLOCK(s));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic inline int is_block_in_journal(struct super_block *s, unsigned int bmap,\n\t\t\t\t      int off, int *next)\n{\n\tb_blocknr_t tmp;\n\n\tif (reiserfs_in_journal(s, bmap, off, 1, &tmp)) {\n\t\tif (tmp) {\t \n\t\t\t*next = tmp;\n\t\t\tPROC_INFO_INC(s, scan_bitmap.in_journal_hint);\n\t\t} else {\n\t\t\t(*next) = off + 1;   \n\t\t\tPROC_INFO_INC(s, scan_bitmap.in_journal_nohint);\n\t\t}\n\t\tPROC_INFO_INC(s, scan_bitmap.retry);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int scan_bitmap_block(struct reiserfs_transaction_handle *th,\n\t\t\t     unsigned int bmap_n, int *beg, int boundary,\n\t\t\t     int min, int max, int unfm)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_bitmap_info *bi = &SB_AP_BITMAP(s)[bmap_n];\n\tstruct buffer_head *bh;\n\tint end, next;\n\tint org = *beg;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(bmap_n >= reiserfs_bmap_count(s), \"Bitmap %u is out of \"\n\t       \"range (0..%u)\", bmap_n, reiserfs_bmap_count(s) - 1);\n\tPROC_INFO_INC(s, scan_bitmap.bmap);\n\n\tif (!bi) {\n\t\treiserfs_error(s, \"jdm-4055\", \"NULL bitmap info pointer \"\n\t\t\t       \"for bitmap %d\", bmap_n);\n\t\treturn 0;\n\t}\n\n\tbh = reiserfs_read_bitmap_block(s, bmap_n);\n\tif (bh == NULL)\n\t\treturn 0;\n\n\twhile (1) {\ncont:\n\t\tif (bi->free_count < min) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\t \n\t\t}\n\n\t\t \n\t\t*beg = reiserfs_find_next_zero_le_bit\n\t\t    ((unsigned long *)(bh->b_data), boundary, *beg);\n\n\t\t \n\t\tif (*beg + min > boundary) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (unfm && is_block_in_journal(s, bmap_n, *beg, beg))\n\t\t\tcontinue;\n\t\t \n\t\tfor (end = *beg + 1;; end++) {\n\t\t\tif (end >= *beg + max || end >= boundary\n\t\t\t    || reiserfs_test_le_bit(end, bh->b_data)) {\n\t\t\t\tnext = end;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (unfm && is_block_in_journal(s, bmap_n, end, &next))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif (end - *beg >= min) {\n\t\t\tint i;\n\t\t\treiserfs_prepare_for_journal(s, bh, 1);\n\t\t\t \n\t\t\tfor (i = *beg; i < end; i++) {\n\t\t\t\t \n\t\t\t\tif (reiserfs_test_and_set_le_bit\n\t\t\t\t    (i, bh->b_data)) {\n\t\t\t\t\t \n\t\t\t\t\tPROC_INFO_INC(s, scan_bitmap.stolen);\n\n\t\t\t\t\t \n\t\t\t\t\tif (i >= *beg + min) {\n\t\t\t\t\t\tend = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\twhile (--i >= *beg)\n\t\t\t\t\t\treiserfs_clear_le_bit\n\t\t\t\t\t\t    (i, bh->b_data);\n\t\t\t\t\treiserfs_restore_prepared_buffer(s, bh);\n\t\t\t\t\t*beg = org;\n\n\t\t\t\t\t \n\t\t\t\t\tgoto cont;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbi->free_count -= (end - *beg);\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\tbrelse(bh);\n\n\t\t\t \n\t\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s),\n\t\t\t\t\t\t     1);\n\t\t\tPUT_SB_FREE_BLOCKS(s, SB_FREE_BLOCKS(s) - (end - *beg));\n\t\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\n\n\t\t\treturn end - (*beg);\n\t\t} else {\n\t\t\t*beg = next;\n\t\t}\n\t}\n}\n\nstatic int bmap_hash_id(struct super_block *s, u32 id)\n{\n\tchar *hash_in = NULL;\n\tunsigned long hash;\n\tunsigned bm;\n\n\tif (id <= 2) {\n\t\tbm = 1;\n\t} else {\n\t\thash_in = (char *)(&id);\n\t\thash = keyed_hash(hash_in, 4);\n\t\tbm = hash % reiserfs_bmap_count(s);\n\t\tif (!bm)\n\t\t\tbm = 1;\n\t}\n\t \n\tif (bm >= reiserfs_bmap_count(s))\n\t\tbm = 0;\n\treturn bm;\n}\n\n \nstatic inline int block_group_used(struct super_block *s, u32 id)\n{\n\tint bm = bmap_hash_id(s, id);\n\tstruct reiserfs_bitmap_info *info = &SB_AP_BITMAP(s)[bm];\n\n\t \n\tif (info->free_count == UINT_MAX) {\n\t\tstruct buffer_head *bh = reiserfs_read_bitmap_block(s, bm);\n\t\tbrelse(bh);\n\t}\n\n\tif (info->free_count > ((s->s_blocksize << 3) * 60 / 100)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \n__le32 reiserfs_choose_packing(struct inode * dir)\n{\n\t__le32 packing;\n\tif (TEST_OPTION(packing_groups, dir->i_sb)) {\n\t\tu32 parent_dir = le32_to_cpu(INODE_PKEY(dir)->k_dir_id);\n\t\t \n\t\tif (parent_dir == 1 || block_group_used(dir->i_sb, parent_dir))\n\t\t\tpacking = INODE_PKEY(dir)->k_objectid;\n\t\telse\n\t\t\tpacking = INODE_PKEY(dir)->k_dir_id;\n\t} else\n\t\tpacking = INODE_PKEY(dir)->k_objectid;\n\treturn packing;\n}\n\n \nstatic int scan_bitmap(struct reiserfs_transaction_handle *th,\n\t\t       b_blocknr_t * start, b_blocknr_t finish,\n\t\t       int min, int max, int unfm, sector_t file_block)\n{\n\tint nr_allocated = 0;\n\tstruct super_block *s = th->t_super;\n\tunsigned int bm, off;\n\tunsigned int end_bm, end_off;\n\tunsigned int off_max = s->s_blocksize << 3;\n\n\tBUG_ON(!th->t_trans_id);\n\tPROC_INFO_INC(s, scan_bitmap.call);\n\n\t \n\tif (SB_FREE_BLOCKS(s) <= 0)\n\t\treturn 0;\n\n\tget_bit_address(s, *start, &bm, &off);\n\tget_bit_address(s, finish, &end_bm, &end_off);\n\tif (bm > reiserfs_bmap_count(s))\n\t\treturn 0;\n\tif (end_bm > reiserfs_bmap_count(s))\n\t\tend_bm = reiserfs_bmap_count(s);\n\n\t \n\tif (TEST_OPTION(skip_busy, s)\n\t    && SB_FREE_BLOCKS(s) > SB_BLOCK_COUNT(s) / 20) {\n\t\tfor (; bm < end_bm; bm++, off = 0) {\n\t\t\tif ((off && (!unfm || (file_block != 0)))\n\t\t\t    || SB_AP_BITMAP(s)[bm].free_count >\n\t\t\t    (s->s_blocksize << 3) / 10)\n\t\t\t\tnr_allocated =\n\t\t\t\t    scan_bitmap_block(th, bm, &off, off_max,\n\t\t\t\t\t\t      min, max, unfm);\n\t\t\tif (nr_allocated)\n\t\t\t\tgoto ret;\n\t\t}\n\t\t \n\t\tget_bit_address(s, *start, &bm, &off);\n\t}\n\n\tfor (; bm < end_bm; bm++, off = 0) {\n\t\tnr_allocated =\n\t\t    scan_bitmap_block(th, bm, &off, off_max, min, max, unfm);\n\t\tif (nr_allocated)\n\t\t\tgoto ret;\n\t}\n\n\tnr_allocated =\n\t    scan_bitmap_block(th, bm, &off, end_off + 1, min, max, unfm);\n\nret:\n\t*start = bm * off_max + off;\n\treturn nr_allocated;\n\n}\n\nstatic void _reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs;\n\tstruct buffer_head *sbh, *bmbh;\n\tstruct reiserfs_bitmap_info *apbi;\n\tunsigned int nr, offset;\n\n\tBUG_ON(!th->t_trans_id);\n\tPROC_INFO_INC(s, free_block);\n\trs = SB_DISK_SUPER_BLOCK(s);\n\tsbh = SB_BUFFER_WITH_SB(s);\n\tapbi = SB_AP_BITMAP(s);\n\n\tget_bit_address(s, block, &nr, &offset);\n\n\tif (nr >= reiserfs_bmap_count(s)) {\n\t\treiserfs_error(s, \"vs-4075\", \"block %lu is out of range\",\n\t\t\t       block);\n\t\treturn;\n\t}\n\n\tbmbh = reiserfs_read_bitmap_block(s, nr);\n\tif (!bmbh)\n\t\treturn;\n\n\treiserfs_prepare_for_journal(s, bmbh, 1);\n\n\t \n\tif (!reiserfs_test_and_clear_le_bit(offset, bmbh->b_data)) {\n\t\treiserfs_error(s, \"vs-4080\",\n\t\t\t       \"block %lu: bit already cleared\", block);\n\t}\n\tapbi[nr].free_count++;\n\tjournal_mark_dirty(th, bmbh);\n\tbrelse(bmbh);\n\n\treiserfs_prepare_for_journal(s, sbh, 1);\n\t \n\tset_sb_free_blocks(rs, sb_free_blocks(rs) + 1);\n\n\tjournal_mark_dirty(th, sbh);\n\tif (for_unformatted) {\n\t\tint depth = reiserfs_write_unlock_nested(s);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n}\n\nvoid reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!s, \"vs-4061: trying to free block on nonexistent device\");\n\tif (!is_reusable(s, block, 1))\n\t\treturn;\n\n\tif (block > sb_block_count(REISERFS_SB(s)->s_rs)) {\n\t\treiserfs_error(th->t_super, \"bitmap-4072\",\n\t\t\t       \"Trying to free block outside file system \"\n\t\t\t       \"boundaries (%lu > %lu)\",\n\t\t\t       block, sb_block_count(REISERFS_SB(s)->s_rs));\n\t\treturn;\n\t}\n\t \n\tjournal_mark_freed(th, s, block);\n\t_reiserfs_free_block(th, inode, block, for_unformatted);\n}\n\n \nstatic void reiserfs_free_prealloc_block(struct reiserfs_transaction_handle *th,\n\t\t\t\t\t struct inode *inode, b_blocknr_t block)\n{\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!th->t_super,\n\t       \"vs-4060: trying to free block on nonexistent device\");\n\tif (!is_reusable(th->t_super, block, 1))\n\t\treturn;\n\t_reiserfs_free_block(th, inode, block, 1);\n}\n\nstatic void __discard_prealloc(struct reiserfs_transaction_handle *th,\n\t\t\t       struct reiserfs_inode_info *ei)\n{\n\tunsigned long save = ei->i_prealloc_block;\n\tint dirty = 0;\n\tstruct inode *inode = &ei->vfs_inode;\n\n\tBUG_ON(!th->t_trans_id);\n#ifdef CONFIG_REISERFS_CHECK\n\tif (ei->i_prealloc_count < 0)\n\t\treiserfs_error(th->t_super, \"zam-4001\",\n\t\t\t       \"inode has negative prealloc blocks count.\");\n#endif\n\twhile (ei->i_prealloc_count > 0) {\n\t\tb_blocknr_t block_to_free;\n\n\t\t \n\t\tblock_to_free = ei->i_prealloc_block++;\n\t\tei->i_prealloc_count--;\n\t\treiserfs_free_prealloc_block(th, inode, block_to_free);\n\t\tdirty = 1;\n\t}\n\tif (dirty)\n\t\treiserfs_update_sd(th, inode);\n\tei->i_prealloc_block = save;\n\tlist_del_init(&ei->i_prealloc_list);\n}\n\n \nvoid reiserfs_discard_prealloc(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode)\n{\n\tstruct reiserfs_inode_info *ei = REISERFS_I(inode);\n\n\tBUG_ON(!th->t_trans_id);\n\tif (ei->i_prealloc_count)\n\t\t__discard_prealloc(th, ei);\n}\n\nvoid reiserfs_discard_all_prealloc(struct reiserfs_transaction_handle *th)\n{\n\tstruct list_head *plist = &SB_JOURNAL(th->t_super)->j_prealloc_list;\n\n\tBUG_ON(!th->t_trans_id);\n\twhile (!list_empty(plist)) {\n\t\tstruct reiserfs_inode_info *ei;\n\t\tei = list_entry(plist->next, struct reiserfs_inode_info,\n\t\t\t\ti_prealloc_list);\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (!ei->i_prealloc_count) {\n\t\t\treiserfs_error(th->t_super, \"zam-4001\",\n\t\t\t\t       \"inode is in prealloc list but has \"\n\t\t\t\t       \"no preallocated blocks.\");\n\t\t}\n#endif\n\t\t__discard_prealloc(th, ei);\n\t}\n}\n\nvoid reiserfs_init_alloc_options(struct super_block *s)\n{\n\tset_bit(_ALLOC_skip_busy, &SB_ALLOC_OPTS(s));\n\tset_bit(_ALLOC_dirid_groups, &SB_ALLOC_OPTS(s));\n\tset_bit(_ALLOC_packing_groups, &SB_ALLOC_OPTS(s));\n}\n\n \nint reiserfs_parse_alloc_options(struct super_block *s, char *options)\n{\n\tchar *this_char, *value;\n\n\t \n\tREISERFS_SB(s)->s_alloc_options.bits = 0;\n\n\twhile ((this_char = strsep(&options, \":\")) != NULL) {\n\t\tif ((value = strchr(this_char, '=')) != NULL)\n\t\t\t*value++ = 0;\n\n\t\tif (!strcmp(this_char, \"concentrating_formatted_nodes\")) {\n\t\t\tint temp;\n\t\t\tSET_OPTION(concentrating_formatted_nodes);\n\t\t\ttemp = (value\n\t\t\t\t&& *value) ? simple_strtoul(value, &value,\n\t\t\t\t\t\t\t    0) : 10;\n\t\t\tif (temp <= 0 || temp > 100) {\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.border = 10;\n\t\t\t} else {\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.border =\n\t\t\t\t    100 / temp;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"displacing_large_files\")) {\n\t\t\tSET_OPTION(displacing_large_files);\n\t\t\tREISERFS_SB(s)->s_alloc_options.large_file_size =\n\t\t\t    (value\n\t\t\t     && *value) ? simple_strtoul(value, &value, 0) : 16;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"displacing_new_packing_localities\")) {\n\t\t\tSET_OPTION(displacing_new_packing_localities);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"old_hashed_relocation\")) {\n\t\t\tSET_OPTION(old_hashed_relocation);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"new_hashed_relocation\")) {\n\t\t\tSET_OPTION(new_hashed_relocation);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"dirid_groups\")) {\n\t\t\tSET_OPTION(dirid_groups);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"oid_groups\")) {\n\t\t\tSET_OPTION(oid_groups);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"packing_groups\")) {\n\t\t\tSET_OPTION(packing_groups);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"hashed_formatted_nodes\")) {\n\t\t\tSET_OPTION(hashed_formatted_nodes);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"skip_busy\")) {\n\t\t\tSET_OPTION(skip_busy);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"hundredth_slices\")) {\n\t\t\tSET_OPTION(hundredth_slices);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"old_way\")) {\n\t\t\tSET_OPTION(old_way);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"displace_based_on_dirid\")) {\n\t\t\tSET_OPTION(displace_based_on_dirid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"preallocmin\")) {\n\t\t\tREISERFS_SB(s)->s_alloc_options.preallocmin =\n\t\t\t    (value\n\t\t\t     && *value) ? simple_strtoul(value, &value, 0) : 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"preallocsize\")) {\n\t\t\tREISERFS_SB(s)->s_alloc_options.preallocsize =\n\t\t\t    (value\n\t\t\t     && *value) ? simple_strtoul(value, &value,\n\t\t\t\t\t\t\t 0) :\n\t\t\t    PREALLOCATION_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\treiserfs_warning(s, \"zam-4001\", \"unknown option - %s\",\n\t\t\t\t this_char);\n\t\treturn 1;\n\t}\n\n\treiserfs_info(s, \"allocator options = [%08x]\\n\", SB_ALLOC_OPTS(s));\n\treturn 0;\n}\n\nstatic void print_sep(struct seq_file *seq, int *first)\n{\n\tif (!*first)\n\t\tseq_puts(seq, \":\");\n\telse\n\t\t*first = 0;\n}\n\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s)\n{\n\tint first = 1;\n\n\tif (SB_ALLOC_OPTS(s) == ((1 << _ALLOC_skip_busy) |\n\t\t(1 << _ALLOC_dirid_groups) | (1 << _ALLOC_packing_groups)))\n\t\treturn;\n\n\tseq_puts(seq, \",alloc=\");\n\n\tif (TEST_OPTION(concentrating_formatted_nodes, s)) {\n\t\tprint_sep(seq, &first);\n\t\tif (REISERFS_SB(s)->s_alloc_options.border != 10) {\n\t\t\tseq_printf(seq, \"concentrating_formatted_nodes=%d\",\n\t\t\t\t100 / REISERFS_SB(s)->s_alloc_options.border);\n\t\t} else\n\t\t\tseq_puts(seq, \"concentrating_formatted_nodes\");\n\t}\n\tif (TEST_OPTION(displacing_large_files, s)) {\n\t\tprint_sep(seq, &first);\n\t\tif (REISERFS_SB(s)->s_alloc_options.large_file_size != 16) {\n\t\t\tseq_printf(seq, \"displacing_large_files=%lu\",\n\t\t\t    REISERFS_SB(s)->s_alloc_options.large_file_size);\n\t\t} else\n\t\t\tseq_puts(seq, \"displacing_large_files\");\n\t}\n\tif (TEST_OPTION(displacing_new_packing_localities, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"displacing_new_packing_localities\");\n\t}\n\tif (TEST_OPTION(old_hashed_relocation, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"old_hashed_relocation\");\n\t}\n\tif (TEST_OPTION(new_hashed_relocation, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"new_hashed_relocation\");\n\t}\n\tif (TEST_OPTION(dirid_groups, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"dirid_groups\");\n\t}\n\tif (TEST_OPTION(oid_groups, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"oid_groups\");\n\t}\n\tif (TEST_OPTION(packing_groups, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"packing_groups\");\n\t}\n\tif (TEST_OPTION(hashed_formatted_nodes, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"hashed_formatted_nodes\");\n\t}\n\tif (TEST_OPTION(skip_busy, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"skip_busy\");\n\t}\n\tif (TEST_OPTION(hundredth_slices, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"hundredth_slices\");\n\t}\n\tif (TEST_OPTION(old_way, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"old_way\");\n\t}\n\tif (TEST_OPTION(displace_based_on_dirid, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"displace_based_on_dirid\");\n\t}\n\tif (REISERFS_SB(s)->s_alloc_options.preallocmin != 0) {\n\t\tprint_sep(seq, &first);\n\t\tseq_printf(seq, \"preallocmin=%d\",\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.preallocmin);\n\t}\n\tif (REISERFS_SB(s)->s_alloc_options.preallocsize != 17) {\n\t\tprint_sep(seq, &first);\n\t\tseq_printf(seq, \"preallocsize=%d\",\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.preallocsize);\n\t}\n}\n\nstatic inline void new_hashed_relocation(reiserfs_blocknr_hint_t * hint)\n{\n\tchar *hash_in;\n\n\tif (hint->formatted_node) {\n\t\thash_in = (char *)&hint->key.k_dir_id;\n\t} else {\n\t\tif (!hint->inode) {\n\t\t\t \n\t\t\thash_in = (char *)&hint->key.k_dir_id;\n\t\t} else\n\t\t    if (TEST_OPTION(displace_based_on_dirid, hint->th->t_super))\n\t\t\thash_in = (char *)(&INODE_PKEY(hint->inode)->k_dir_id);\n\t\telse\n\t\t\thash_in =\n\t\t\t    (char *)(&INODE_PKEY(hint->inode)->k_objectid);\n\t}\n\n\thint->search_start =\n\t    hint->beg + keyed_hash(hash_in, 4) % (hint->end - hint->beg);\n}\n\n \nstatic void dirid_groups(reiserfs_blocknr_hint_t * hint)\n{\n\tunsigned long hash;\n\t__u32 dirid = 0;\n\tint bm = 0;\n\tstruct super_block *sb = hint->th->t_super;\n\n\tif (hint->inode)\n\t\tdirid = le32_to_cpu(INODE_PKEY(hint->inode)->k_dir_id);\n\telse if (hint->formatted_node)\n\t\tdirid = hint->key.k_dir_id;\n\n\tif (dirid) {\n\t\tbm = bmap_hash_id(sb, dirid);\n\t\thash = bm * (sb->s_blocksize << 3);\n\t\t \n\t\tif (hint->inode)\n\t\t\thash += sb->s_blocksize / 2;\n\t\thint->search_start = hash;\n\t}\n}\n\n \nstatic void oid_groups(reiserfs_blocknr_hint_t * hint)\n{\n\tif (hint->inode) {\n\t\tunsigned long hash;\n\t\t__u32 oid;\n\t\t__u32 dirid;\n\t\tint bm;\n\n\t\tdirid = le32_to_cpu(INODE_PKEY(hint->inode)->k_dir_id);\n\n\t\t \n\t\tif (dirid <= 2)\n\t\t\thash = (hint->inode->i_sb->s_blocksize << 3);\n\t\telse {\n\t\t\toid = le32_to_cpu(INODE_PKEY(hint->inode)->k_objectid);\n\t\t\tbm = bmap_hash_id(hint->inode->i_sb, oid);\n\t\t\thash = bm * (hint->inode->i_sb->s_blocksize << 3);\n\t\t}\n\t\thint->search_start = hash;\n\t}\n}\n\n \nstatic int get_left_neighbor(reiserfs_blocknr_hint_t * hint)\n{\n\tstruct treepath *path;\n\tstruct buffer_head *bh;\n\tstruct item_head *ih;\n\tint pos_in_item;\n\t__le32 *item;\n\tint ret = 0;\n\n\t \n\tif (!hint->path)\n\t\treturn 0;\n\n\tpath = hint->path;\n\tbh = get_last_bh(path);\n\tRFALSE(!bh, \"green-4002: Illegal path specified to get_left_neighbor\");\n\tih = tp_item_head(path);\n\tpos_in_item = path->pos_in_item;\n\titem = tp_item_body(path);\n\n\thint->search_start = bh->b_blocknr;\n\n\t \n\tif (!hint->formatted_node && is_indirect_le_ih(ih)) {\n\t\tif (pos_in_item == I_UNFM_NUM(ih))\n\t\t\tpos_in_item--;\n\t\twhile (pos_in_item >= 0) {\n\t\t\tint t = get_block_num(item, pos_in_item);\n\t\t\tif (t) {\n\t\t\t\thint->search_start = t;\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos_in_item--;\n\t\t}\n\t}\n\n\t \n\treturn ret;\n}\n\n \nstatic inline void set_border_in_hint(struct super_block *s,\n\t\t\t\t      reiserfs_blocknr_hint_t * hint)\n{\n\tb_blocknr_t border =\n\t    SB_BLOCK_COUNT(s) / REISERFS_SB(s)->s_alloc_options.border;\n\n\tif (hint->formatted_node)\n\t\thint->end = border - 1;\n\telse\n\t\thint->beg = border;\n}\n\nstatic inline void displace_large_file(reiserfs_blocknr_hint_t * hint)\n{\n\tif (TEST_OPTION(displace_based_on_dirid, hint->th->t_super))\n\t\thint->search_start =\n\t\t    hint->beg +\n\t\t    keyed_hash((char *)(&INODE_PKEY(hint->inode)->k_dir_id),\n\t\t\t       4) % (hint->end - hint->beg);\n\telse\n\t\thint->search_start =\n\t\t    hint->beg +\n\t\t    keyed_hash((char *)(&INODE_PKEY(hint->inode)->k_objectid),\n\t\t\t       4) % (hint->end - hint->beg);\n}\n\nstatic inline void hash_formatted_node(reiserfs_blocknr_hint_t * hint)\n{\n\tchar *hash_in;\n\n\tif (!hint->inode)\n\t\thash_in = (char *)&hint->key.k_dir_id;\n\telse if (TEST_OPTION(displace_based_on_dirid, hint->th->t_super))\n\t\thash_in = (char *)(&INODE_PKEY(hint->inode)->k_dir_id);\n\telse\n\t\thash_in = (char *)(&INODE_PKEY(hint->inode)->k_objectid);\n\n\thint->search_start =\n\t    hint->beg + keyed_hash(hash_in, 4) % (hint->end - hint->beg);\n}\n\nstatic inline int\nthis_blocknr_allocation_would_make_it_a_large_file(reiserfs_blocknr_hint_t *\n\t\t\t\t\t\t   hint)\n{\n\treturn hint->block ==\n\t    REISERFS_SB(hint->th->t_super)->s_alloc_options.large_file_size;\n}\n\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\nstatic inline void displace_new_packing_locality(reiserfs_blocknr_hint_t * hint)\n{\n\tstruct in_core_key *key = &hint->key;\n\n\thint->th->displace_new_blocks = 0;\n\thint->search_start =\n\t    hint->beg + keyed_hash((char *)(&key->k_objectid),\n\t\t\t\t   4) % (hint->end - hint->beg);\n}\n#endif\n\nstatic inline int old_hashed_relocation(reiserfs_blocknr_hint_t * hint)\n{\n\tb_blocknr_t border;\n\tu32 hash_in;\n\n\tif (hint->formatted_node || hint->inode == NULL) {\n\t\treturn 0;\n\t}\n\n\thash_in = le32_to_cpu((INODE_PKEY(hint->inode))->k_dir_id);\n\tborder =\n\t    hint->beg + (u32) keyed_hash(((char *)(&hash_in)),\n\t\t\t\t\t 4) % (hint->end - hint->beg - 1);\n\tif (border > hint->search_start)\n\t\thint->search_start = border;\n\n\treturn 1;\n}\n\nstatic inline int old_way(reiserfs_blocknr_hint_t * hint)\n{\n\tb_blocknr_t border;\n\n\tif (hint->formatted_node || hint->inode == NULL) {\n\t\treturn 0;\n\t}\n\n\tborder =\n\t    hint->beg +\n\t    le32_to_cpu(INODE_PKEY(hint->inode)->k_dir_id) % (hint->end -\n\t\t\t\t\t\t\t      hint->beg);\n\tif (border > hint->search_start)\n\t\thint->search_start = border;\n\n\treturn 1;\n}\n\nstatic inline void hundredth_slices(reiserfs_blocknr_hint_t * hint)\n{\n\tstruct in_core_key *key = &hint->key;\n\tb_blocknr_t slice_start;\n\n\tslice_start =\n\t    (keyed_hash((char *)(&key->k_dir_id), 4) % 100) * (hint->end / 100);\n\tif (slice_start > hint->search_start\n\t    || slice_start + (hint->end / 100) <= hint->search_start) {\n\t\thint->search_start = slice_start;\n\t}\n}\n\nstatic void determine_search_start(reiserfs_blocknr_hint_t * hint,\n\t\t\t\t   int amount_needed)\n{\n\tstruct super_block *s = hint->th->t_super;\n\tint unfm_hint;\n\n\thint->beg = 0;\n\thint->end = SB_BLOCK_COUNT(s) - 1;\n\n\t \n\tif (concentrating_formatted_nodes(s))\n\t\tset_border_in_hint(s, hint);\n\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\t \n\tif (displacing_new_packing_localities(s)\n\t    && hint->th->displace_new_blocks) {\n\t\tdisplace_new_packing_locality(hint);\n\n\t\t \n\t\treturn;\n\t}\n#endif\n\n\t \n\n\tif (displacing_large_files(s) && !hint->formatted_node\n\t    && this_blocknr_allocation_would_make_it_a_large_file(hint)) {\n\t\tdisplace_large_file(hint);\n\t\treturn;\n\t}\n\n\t \n\tif (hint->formatted_node && TEST_OPTION(hashed_formatted_nodes, s)) {\n\t\thash_formatted_node(hint);\n\t\treturn;\n\t}\n\n\tunfm_hint = get_left_neighbor(hint);\n\n\t \n\tif (TEST_OPTION(old_way, s)) {\n\t\tif (!hint->formatted_node) {\n\t\t\tif (!reiserfs_hashed_relocation(s))\n\t\t\t\told_way(hint);\n\t\t\telse if (!reiserfs_no_unhashed_relocation(s))\n\t\t\t\told_hashed_relocation(hint);\n\n\t\t\tif (hint->inode\n\t\t\t    && hint->search_start <\n\t\t\t    REISERFS_I(hint->inode)->i_prealloc_block)\n\t\t\t\thint->search_start =\n\t\t\t\t    REISERFS_I(hint->inode)->i_prealloc_block;\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (TEST_OPTION(hundredth_slices, s)\n\t    && !(displacing_large_files(s) && !hint->formatted_node)) {\n\t\thundredth_slices(hint);\n\t\treturn;\n\t}\n\n\t \n\tif (!unfm_hint && !hint->formatted_node &&\n\t    TEST_OPTION(old_hashed_relocation, s)) {\n\t\told_hashed_relocation(hint);\n\t}\n\n\t \n\tif ((!unfm_hint || hint->formatted_node) &&\n\t    TEST_OPTION(new_hashed_relocation, s)) {\n\t\tnew_hashed_relocation(hint);\n\t}\n\n\t \n\tif (!unfm_hint && !hint->formatted_node && TEST_OPTION(dirid_groups, s)) {\n\t\tdirid_groups(hint);\n\t}\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (hint->formatted_node && TEST_OPTION(dirid_groups, s)) {\n\t\tdirid_groups(hint);\n\t}\n#endif\n\n\t \n\tif (!unfm_hint && !hint->formatted_node && TEST_OPTION(oid_groups, s)) {\n\t\toid_groups(hint);\n\t}\n\treturn;\n}\n\nstatic int determine_prealloc_size(reiserfs_blocknr_hint_t * hint)\n{\n\t \n\t \n\t \n\n\thint->prealloc_size = 0;\n\n\tif (!hint->formatted_node && hint->preallocate) {\n\t\tif (S_ISREG(hint->inode->i_mode) && !IS_PRIVATE(hint->inode)\n\t\t    && hint->inode->i_size >=\n\t\t    REISERFS_SB(hint->th->t_super)->s_alloc_options.\n\t\t    preallocmin * hint->inode->i_sb->s_blocksize)\n\t\t\thint->prealloc_size =\n\t\t\t    REISERFS_SB(hint->th->t_super)->s_alloc_options.\n\t\t\t    preallocsize - 1;\n\t}\n\treturn CARRY_ON;\n}\n\nstatic inline int allocate_without_wrapping_disk(reiserfs_blocknr_hint_t * hint,\n\t\t\t\t\t\t b_blocknr_t * new_blocknrs,\n\t\t\t\t\t\t b_blocknr_t start,\n\t\t\t\t\t\t b_blocknr_t finish, int min,\n\t\t\t\t\t\t int amount_needed,\n\t\t\t\t\t\t int prealloc_size)\n{\n\tint rest = amount_needed;\n\tint nr_allocated;\n\n\twhile (rest > 0 && start <= finish) {\n\t\tnr_allocated = scan_bitmap(hint->th, &start, finish, min,\n\t\t\t\t\t   rest + prealloc_size,\n\t\t\t\t\t   !hint->formatted_node, hint->block);\n\n\t\tif (nr_allocated == 0)\t \n\t\t\tbreak;\n\n\t\t \n\t\twhile (rest > 0 && nr_allocated > 0) {\n\t\t\t*new_blocknrs++ = start++;\n\t\t\trest--;\n\t\t\tnr_allocated--;\n\t\t}\n\n\t\t \n\t\tif (nr_allocated > 0) {\n\t\t\t \n\t\t\tlist_add(&REISERFS_I(hint->inode)->i_prealloc_list,\n\t\t\t\t &SB_JOURNAL(hint->th->t_super)->\n\t\t\t\t j_prealloc_list);\n\t\t\tREISERFS_I(hint->inode)->i_prealloc_block = start;\n\t\t\tREISERFS_I(hint->inode)->i_prealloc_count =\n\t\t\t    nr_allocated;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (amount_needed - rest);\n}\n\nstatic inline int blocknrs_and_prealloc_arrays_from_search_start\n    (reiserfs_blocknr_hint_t * hint, b_blocknr_t * new_blocknrs,\n     int amount_needed) {\n\tstruct super_block *s = hint->th->t_super;\n\tb_blocknr_t start = hint->search_start;\n\tb_blocknr_t finish = SB_BLOCK_COUNT(s) - 1;\n\tint passno = 0;\n\tint nr_allocated = 0;\n\tint depth;\n\n\tdetermine_prealloc_size(hint);\n\tif (!hint->formatted_node) {\n\t\tint quota_ret;\n#ifdef REISERQUOTA_DEBUG\n\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t       \"reiserquota: allocating %d blocks id=%u\",\n\t\t\t       amount_needed, hint->inode->i_uid);\n#endif\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tquota_ret =\n\t\t    dquot_alloc_block_nodirty(hint->inode, amount_needed);\n\t\tif (quota_ret) {\t \n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\treturn QUOTA_EXCEEDED;\n\t\t}\n\t\tif (hint->preallocate && hint->prealloc_size) {\n#ifdef REISERQUOTA_DEBUG\n\t\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"reiserquota: allocating (prealloc) %d blocks id=%u\",\n\t\t\t\t       hint->prealloc_size, hint->inode->i_uid);\n#endif\n\t\t\tquota_ret = dquot_prealloc_block_nodirty(hint->inode,\n\t\t\t\t\t\t\t hint->prealloc_size);\n\t\t\tif (quota_ret)\n\t\t\t\thint->preallocate = hint->prealloc_size = 0;\n\t\t}\n\t\t \n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\tdo {\n\t\tswitch (passno++) {\n\t\tcase 0:\t \n\t\t\tstart = hint->search_start;\n\t\t\tfinish = SB_BLOCK_COUNT(s) - 1;\n\t\t\tbreak;\n\t\tcase 1:\t \n\t\t\tstart = hint->beg;\n\t\t\tfinish = hint->search_start;\n\t\t\tbreak;\n\t\tcase 2:\t \n\t\t\tstart = 0;\n\t\t\tfinish = hint->beg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\t \n\t\t\tif (!hint->formatted_node) {\n#ifdef REISERQUOTA_DEBUG\n\t\t\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"reiserquota: freeing (nospace) %d blocks id=%u\",\n\t\t\t\t\t       amount_needed +\n\t\t\t\t\t       hint->prealloc_size -\n\t\t\t\t\t       nr_allocated,\n\t\t\t\t\t       hint->inode->i_uid);\n#endif\n\t\t\t\t \n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\t\tdquot_free_block_nodirty(hint->inode,\n\t\t\t\t\tamount_needed + hint->prealloc_size -\n\t\t\t\t\tnr_allocated);\n\t\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\twhile (nr_allocated--)\n\t\t\t\treiserfs_free_block(hint->th, hint->inode,\n\t\t\t\t\t\t    new_blocknrs[nr_allocated],\n\t\t\t\t\t\t    !hint->formatted_node);\n\n\t\t\treturn NO_DISK_SPACE;\n\t\t}\n\t} while ((nr_allocated += allocate_without_wrapping_disk(hint,\n\t\t\t\t\t\t\t\t new_blocknrs +\n\t\t\t\t\t\t\t\t nr_allocated,\n\t\t\t\t\t\t\t\t start, finish,\n\t\t\t\t\t\t\t\t 1,\n\t\t\t\t\t\t\t\t amount_needed -\n\t\t\t\t\t\t\t\t nr_allocated,\n\t\t\t\t\t\t\t\t hint->\n\t\t\t\t\t\t\t\t prealloc_size))\n\t\t < amount_needed);\n\tif (!hint->formatted_node &&\n\t    amount_needed + hint->prealloc_size >\n\t    nr_allocated + REISERFS_I(hint->inode)->i_prealloc_count) {\n\t\t \n#ifdef REISERQUOTA_DEBUG\n\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t       \"reiserquota: freeing (failed prealloc) %d blocks id=%u\",\n\t\t\t       amount_needed + hint->prealloc_size -\n\t\t\t       nr_allocated -\n\t\t\t       REISERFS_I(hint->inode)->i_prealloc_count,\n\t\t\t       hint->inode->i_uid);\n#endif\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tdquot_free_block_nodirty(hint->inode, amount_needed +\n\t\t\t\t\t hint->prealloc_size - nr_allocated -\n\t\t\t\t\t REISERFS_I(hint->inode)->\n\t\t\t\t\t i_prealloc_count);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\treturn CARRY_ON;\n}\n\n \n \nstatic int use_preallocated_list_if_available(reiserfs_blocknr_hint_t * hint,\n\t\t\t\t\t      b_blocknr_t * new_blocknrs,\n\t\t\t\t\t      int amount_needed)\n{\n\tstruct inode *inode = hint->inode;\n\n\tif (REISERFS_I(inode)->i_prealloc_count > 0) {\n\t\twhile (amount_needed) {\n\n\t\t\t*new_blocknrs++ = REISERFS_I(inode)->i_prealloc_block++;\n\t\t\tREISERFS_I(inode)->i_prealloc_count--;\n\n\t\t\tamount_needed--;\n\n\t\t\tif (REISERFS_I(inode)->i_prealloc_count <= 0) {\n\t\t\t\tlist_del(&REISERFS_I(inode)->i_prealloc_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t \n\treturn amount_needed;\n}\n\nint reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *hint,\n\t\t\t       b_blocknr_t *new_blocknrs,\n\t\t\t       int amount_needed,\n\t\t\t        \n\t\t\t       int reserved_by_us)\n{\n\tint initial_amount_needed = amount_needed;\n\tint ret;\n\tstruct super_block *s = hint->th->t_super;\n\n\t \n\tif (SB_FREE_BLOCKS(s) - REISERFS_SB(s)->reserved_blocks <\n\t    amount_needed - reserved_by_us)\n\t\treturn NO_DISK_SPACE;\n\t \n\t \n\t \n\n\tif (!hint->formatted_node && hint->preallocate) {\n\t\tamount_needed = use_preallocated_list_if_available\n\t\t    (hint, new_blocknrs, amount_needed);\n\n\t\t \n\t\tif (amount_needed == 0)\n\t\t\treturn CARRY_ON;\n\t\tnew_blocknrs += (initial_amount_needed - amount_needed);\n\t}\n\n\t \n\tdetermine_search_start(hint, amount_needed);\n\tif (hint->search_start >= SB_BLOCK_COUNT(s))\n\t\thint->search_start = SB_BLOCK_COUNT(s) - 1;\n\n\t \n\tret = blocknrs_and_prealloc_arrays_from_search_start\n\t    (hint, new_blocknrs, amount_needed);\n\n\t \n\tif (ret != CARRY_ON) {\n\t\twhile (amount_needed++ < initial_amount_needed) {\n\t\t\treiserfs_free_block(hint->th, hint->inode,\n\t\t\t\t\t    *(--new_blocknrs), 1);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid reiserfs_cache_bitmap_metadata(struct super_block *sb,\n                                    struct buffer_head *bh,\n                                    struct reiserfs_bitmap_info *info)\n{\n\tunsigned long *cur = (unsigned long *)(bh->b_data + bh->b_size);\n\n\t \n\tif (!reiserfs_test_le_bit(0, (unsigned long *)bh->b_data))\n\t\treiserfs_error(sb, \"reiserfs-2025\", \"bitmap block %lu is \"\n\t\t\t       \"corrupted: first bit must be 1\", bh->b_blocknr);\n\n\tinfo->free_count = 0;\n\n\twhile (--cur >= (unsigned long *)bh->b_data) {\n\t\t \n\t\tif (*cur == 0)\n\t\t\tinfo->free_count += BITS_PER_LONG;\n\t\telse if (*cur != ~0L)\t \n\t\t\tinfo->free_count += BITS_PER_LONG - hweight_long(*cur);\n\t}\n}\n\nstruct buffer_head *reiserfs_read_bitmap_block(struct super_block *sb,\n                                               unsigned int bitmap)\n{\n\tb_blocknr_t block = (sb->s_blocksize << 3) * bitmap;\n\tstruct reiserfs_bitmap_info *info = SB_AP_BITMAP(sb) + bitmap;\n\tstruct buffer_head *bh;\n\n\t \n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(sb)->s_properties)))\n\t\tblock = REISERFS_SB(sb)->s_sbh->b_blocknr + 1 + bitmap;\n\telse if (bitmap == 0)\n\t\tblock = (REISERFS_DISK_OFFSET_IN_BYTES >> sb->s_blocksize_bits) + 1;\n\n\tbh = sb_bread(sb, block);\n\tif (bh == NULL)\n\t\treiserfs_warning(sb, \"sh-2029: %s: bitmap block (#%u) \"\n\t\t                 \"reading failed\", __func__, block);\n\telse {\n\t\tif (buffer_locked(bh)) {\n\t\t\tint depth;\n\t\t\tPROC_INFO_INC(sb, scan_bitmap.wait);\n\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t__wait_on_buffer(bh);\n\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(atomic_read(&bh->b_count) == 0);\n\n\t\tif (info->free_count == UINT_MAX)\n\t\t\treiserfs_cache_bitmap_metadata(sb, bh, info);\n\t}\n\n\treturn bh;\n}\n\nint reiserfs_init_bitmap_cache(struct super_block *sb)\n{\n\tstruct reiserfs_bitmap_info *bitmap;\n\tunsigned int bmap_nr = reiserfs_bmap_count(sb);\n\n\tbitmap = vmalloc(array_size(bmap_nr, sizeof(*bitmap)));\n\tif (bitmap == NULL)\n\t\treturn -ENOMEM;\n\n\tmemset(bitmap, 0xff, sizeof(*bitmap) * bmap_nr);\n\n\tSB_AP_BITMAP(sb) = bitmap;\n\n\treturn 0;\n}\n\nvoid reiserfs_free_bitmap_cache(struct super_block *sb)\n{\n\tif (SB_AP_BITMAP(sb)) {\n\t\tvfree(SB_AP_BITMAP(sb));\n\t\tSB_AP_BITMAP(sb) = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}