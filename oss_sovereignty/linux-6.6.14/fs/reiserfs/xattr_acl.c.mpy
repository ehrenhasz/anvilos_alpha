{
  "module_name": "xattr_acl.c",
  "hash_id": "20dde2799aaf6ddad1b4650b412f2c221d66ad3c1ef73bc4f4dbdbf6759c08c8",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/xattr_acl.c",
  "human_readable_source": "\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/posix_acl.h>\n#include \"reiserfs.h\"\n#include <linux/errno.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include <linux/uaccess.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\n\nint\nreiserfs_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t struct posix_acl *acl, int type)\n{\n\tint error, error2;\n\tstruct reiserfs_transaction_handle th;\n\tsize_t jcreate_blocks;\n\tint size = acl ? posix_acl_xattr_size(acl->a_count) : 0;\n\tint update_mode = 0;\n\tstruct inode *inode = d_inode(dentry);\n\tumode_t mode = inode->i_mode;\n\n\t \n\n\tjcreate_blocks = reiserfs_xattr_jcreate_nblocks(inode) +\n\t\t\t reiserfs_xattr_nblocks(inode, size) * 2;\n\n\treiserfs_write_lock(inode->i_sb);\n\terror = journal_begin(&th, inode->i_sb, jcreate_blocks);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error == 0) {\n\t\tif (type == ACL_TYPE_ACCESS && acl) {\n\t\t\terror = posix_acl_update_mode(&nop_mnt_idmap, inode,\n\t\t\t\t\t\t      &mode, &acl);\n\t\t\tif (error)\n\t\t\t\tgoto unlock;\n\t\t\tupdate_mode = 1;\n\t\t}\n\t\terror = __reiserfs_set_acl(&th, inode, type, acl);\n\t\tif (!error && update_mode)\n\t\t\tinode->i_mode = mode;\nunlock:\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terror2 = journal_end(&th);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error2)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}\n\n \nstatic struct posix_acl *reiserfs_posix_acl_from_disk(const void *value, size_t size)\n{\n\tconst char *end = (char *)value + size;\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(reiserfs_acl_header))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (((reiserfs_acl_header *) value)->a_version !=\n\t    cpu_to_le32(REISERFS_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\tvalue = (char *)value + sizeof(reiserfs_acl_header);\n\tcount = reiserfs_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\treiserfs_acl_entry *entry = (reiserfs_acl_entry *) value;\n\t\tif ((char *)value + sizeof(reiserfs_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[n].e_tag = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tvalue = (char *)value +\n\t\t\t    sizeof(reiserfs_acl_entry_short);\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tvalue = (char *)value + sizeof(reiserfs_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_uid = \n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tvalue = (char *)value + sizeof(reiserfs_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\n \nstatic void *reiserfs_posix_acl_to_disk(const struct posix_acl *acl, size_t * size)\n{\n\treiserfs_acl_header *ext_acl;\n\tchar *e;\n\tint n;\n\n\t*size = reiserfs_acl_size(acl->a_count);\n\text_acl = kmalloc(sizeof(reiserfs_acl_header) +\n\t\t\t\t\t\t  acl->a_count *\n\t\t\t\t\t\t  sizeof(reiserfs_acl_entry),\n\t\t\t\t\t\t  GFP_NOFS);\n\tif (!ext_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\text_acl->a_version = cpu_to_le32(REISERFS_ACL_VERSION);\n\te = (char *)ext_acl + sizeof(reiserfs_acl_header);\n\tfor (n = 0; n < acl->a_count; n++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\treiserfs_acl_entry *entry = (reiserfs_acl_entry *) e;\n\t\tentry->e_tag = cpu_to_le16(acl->a_entries[n].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\te += sizeof(reiserfs_acl_entry);\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\te += sizeof(reiserfs_acl_entry);\n\t\t\tbreak;\n\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\te += sizeof(reiserfs_acl_entry_short);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn (char *)ext_acl;\n\nfail:\n\tkfree(ext_acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\n \nstruct posix_acl *reiserfs_get_acl(struct inode *inode, int type, bool rcu)\n{\n\tchar *name, *value;\n\tstruct posix_acl *acl;\n\tint size;\n\tint retval;\n\n\tif (rcu)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsize = reiserfs_xattr_get(inode, name, NULL, 0);\n\tif (size < 0) {\n\t\tif (size == -ENODATA || size == -ENOSYS)\n\t\t\treturn NULL;\n\t\treturn ERR_PTR(size);\n\t}\n\n\tvalue = kmalloc(size, GFP_NOFS);\n\tif (!value)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tretval = reiserfs_xattr_get(inode, name, value, size);\n\tif (retval == -ENODATA || retval == -ENOSYS) {\n\t\t \n\t\tacl = NULL;\n\t} else if (retval < 0) {\n\t\tacl = ERR_PTR(retval);\n\t} else {\n\t\tacl = reiserfs_posix_acl_from_disk(value, retval);\n\t}\n\n\tkfree(value);\n\treturn acl;\n}\n\n \nstatic int\n__reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t int type, struct posix_acl *acl)\n{\n\tchar *name;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = reiserfs_posix_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);\n\n\t \n\tif (error == -ENODATA) {\n\t\terror = 0;\n\t\tif (type == ACL_TYPE_ACCESS) {\n\t\t\tinode_set_ctime_current(inode);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\n\tkfree(value);\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}\n\n \nint\nreiserfs_inherit_default_acl(struct reiserfs_transaction_handle *th,\n\t\t\t     struct inode *dir, struct dentry *dentry,\n\t\t\t     struct inode *inode)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint err = 0;\n\n\t \n\tif (S_ISLNK(inode->i_mode))\n\t\treturn 0;\n\n\t \n\tif (get_inode_sd_version(dir) == STAT_DATA_V1)\n\t\tgoto apply_umask;\n\n\t \n\tif (IS_PRIVATE(inode))\n\t\tgoto apply_umask;\n\n\terr = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (default_acl) {\n\t\terr = __reiserfs_set_acl(th, inode, ACL_TYPE_DEFAULT,\n\t\t\t\t\t default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!err)\n\t\t\terr = __reiserfs_set_acl(th, inode, ACL_TYPE_ACCESS,\n\t\t\t\t\t\t acl);\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn err;\n\napply_umask:\n\t \n\tinode->i_mode &= ~current_umask();\n\treturn err;\n}\n\n \nint reiserfs_cache_default_acl(struct inode *inode)\n{\n\tstruct posix_acl *acl;\n\tint nblocks = 0;\n\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\n\tacl = get_inode_acl(inode, ACL_TYPE_DEFAULT);\n\n\tif (acl && !IS_ERR(acl)) {\n\t\tint size = reiserfs_acl_size(acl->a_count);\n\n\t\t \n\t\tnblocks = reiserfs_xattr_jcreate_nblocks(inode);\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\n\t\t \n\t\tnblocks += reiserfs_xattr_nblocks(inode, size) * 4;\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn nblocks;\n}\n\n \nint reiserfs_acl_chmod(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1 ||\n\t    !reiserfs_posixacl(inode->i_sb))\n\t\treturn 0;\n\n\treturn posix_acl_chmod(&nop_mnt_idmap, dentry, inode->i_mode);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}