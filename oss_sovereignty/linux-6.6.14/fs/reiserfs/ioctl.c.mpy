{
  "module_name": "ioctl.c",
  "hash_id": "452ce2469982e633579a94a7b3d75e625453dd3e7a86ab85999f4a8b724a6f44",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/ioctl.c",
  "human_readable_source": " \n\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/compat.h>\n#include <linux/fileattr.h>\n\nint reiserfs_fileattr_get(struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (!reiserfs_attrs(inode->i_sb))\n\t\treturn -ENOTTY;\n\n\tfileattr_fill_flags(fa, REISERFS_I(inode)->i_attrs);\n\n\treturn 0;\n}\n\nint reiserfs_fileattr_set(struct mnt_idmap *idmap,\n\t\t\t  struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tunsigned int flags = fa->flags;\n\tint err;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\terr = -ENOTTY;\n\tif (!reiserfs_attrs(inode->i_sb))\n\t\tgoto unlock;\n\n\terr = -EOPNOTSUPP;\n\tif (fileattr_has_fsx(fa))\n\t\tgoto unlock;\n\n\t \n\terr = -EPERM;\n\tif (IS_NOQUOTA(inode))\n\t\tgoto unlock;\n\n\tif ((flags & REISERFS_NOTAIL_FL) && S_ISREG(inode->i_mode)) {\n\t\terr = reiserfs_unpack(inode);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\tsd_attrs_to_i_attrs(flags, inode);\n\tREISERFS_I(inode)->i_attrs = flags;\n\tinode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n\terr = 0;\nunlock:\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn err;\n}\n\n \nlong reiserfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint err = 0;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\tswitch (cmd) {\n\tcase REISERFS_IOC_UNPACK:\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tif (arg)\n\t\t\t\terr = reiserfs_unpack(inode);\n\t\t} else\n\t\t\terr = -ENOTTY;\n\t\tbreak;\n\t\t \n\tcase REISERFS_IOC_GETVERSION:\n\t\terr = put_user(inode->i_generation, (int __user *)arg);\n\t\tbreak;\n\tcase REISERFS_IOC_SETVERSION:\n\t\tif (!inode_owner_or_capable(&nop_mnt_idmap, inode)) {\n\t\t\terr = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (get_user(inode->i_generation, (int __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\t\tinode_set_ctime_current(inode);\n\t\tmark_inode_dirty(inode);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOTTY;\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn err;\n}\n\n#ifdef CONFIG_COMPAT\nlong reiserfs_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\t \n\tswitch (cmd) {\n\tcase REISERFS_IOC32_UNPACK:\n\t\tcmd = REISERFS_IOC_UNPACK;\n\t\tbreak;\n\tcase REISERFS_IOC32_GETVERSION:\n\t\tcmd = REISERFS_IOC_GETVERSION;\n\t\tbreak;\n\tcase REISERFS_IOC32_SETVERSION:\n\t\tcmd = REISERFS_IOC_SETVERSION;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn reiserfs_ioctl(file, cmd, (unsigned long) compat_ptr(arg));\n}\n#endif\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n \nint reiserfs_unpack(struct inode *inode)\n{\n\tint retval = 0;\n\tint index;\n\tstruct page *page;\n\tstruct address_space *mapping;\n\tunsigned long write_from;\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\n\tif (inode->i_size == 0) {\n\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\treturn 0;\n\t}\n\t \n\tif (REISERFS_I(inode)->i_flags & i_nopack_mask) {\n\t\treturn 0;\n\t}\n\n\t \n\t{\n\t\tint depth = reiserfs_write_unlock_nested(inode->i_sb);\n\n\t\tinode_lock(inode);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t}\n\n\treiserfs_write_lock(inode->i_sb);\n\n\twrite_from = inode->i_size & (blocksize - 1);\n\t \n\tif (write_from == 0) {\n\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\tgoto out;\n\t}\n\n\t \n\tindex = inode->i_size >> PAGE_SHIFT;\n\tmapping = inode->i_mapping;\n\tpage = grab_cache_page(mapping, index);\n\tretval = -ENOMEM;\n\tif (!page) {\n\t\tgoto out;\n\t}\n\tretval = __reiserfs_write_begin(page, write_from, 0);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\t \n\tflush_dcache_page(page);\n\tretval = reiserfs_commit_write(NULL, page, write_from, write_from);\n\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\nout_unlock:\n\tunlock_page(page);\n\tput_page(page);\n\nout:\n\tinode_unlock(inode);\n\treiserfs_write_unlock(inode->i_sb);\n\treturn retval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}