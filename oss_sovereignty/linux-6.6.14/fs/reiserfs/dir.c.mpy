{
  "module_name": "dir.c",
  "hash_id": "d357bb644572ec6231cca445f0694d8a51d741ebfc16d4b95b1929be4a18a24b",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/dir.c",
  "human_readable_source": " \n\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include \"reiserfs.h\"\n#include <linux/stat.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nextern const struct reiserfs_key MIN_KEY;\n\nstatic int reiserfs_readdir(struct file *, struct dir_context *);\nstatic int reiserfs_dir_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\t      int datasync);\n\nconst struct file_operations reiserfs_dir_operations = {\n\t.llseek = generic_file_llseek,\n\t.read = generic_read_dir,\n\t.iterate_shared = reiserfs_readdir,\n\t.fsync = reiserfs_dir_fsync,\n\t.unlocked_ioctl = reiserfs_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = reiserfs_compat_ioctl,\n#endif\n};\n\nstatic int reiserfs_dir_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\t      int datasync)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint err;\n\n\terr = file_write_and_wait_range(filp, start, end);\n\tif (err)\n\t\treturn err;\n\n\tinode_lock(inode);\n\treiserfs_write_lock(inode->i_sb);\n\terr = reiserfs_commit_for_inode(inode);\n\treiserfs_write_unlock(inode->i_sb);\n\tinode_unlock(inode);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\n#define store_ih(where,what) copy_item_head (where, what)\n\nstatic inline bool is_privroot_deh(struct inode *dir, struct reiserfs_de_head *deh)\n{\n\tstruct dentry *privroot = REISERFS_SB(dir->i_sb)->priv_root;\n\treturn (d_really_is_positive(privroot) &&\n\t        deh->deh_objectid == INODE_PKEY(d_inode(privroot))->k_objectid);\n}\n\nint reiserfs_readdir_inode(struct inode *inode, struct dir_context *ctx)\n{\n\n\t \n\tstruct cpu_key pos_key;\n\n\tINITIALIZE_PATH(path_to_entry);\n\tstruct buffer_head *bh;\n\tint item_num, entry_num;\n\tconst struct reiserfs_key *rkey;\n\tstruct item_head *ih, tmp_ih;\n\tint search_res;\n\tchar *local_buf;\n\tloff_t next_pos;\n\tchar small_buf[32];\t \n\tstruct reiserfs_dir_entry de;\n\tint ret = 0;\n\tint depth;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\treiserfs_check_lock_depth(inode->i_sb, \"readdir\");\n\n\t \n\tmake_cpu_key(&pos_key, inode, ctx->pos ?: DOT_OFFSET, TYPE_DIRENTRY, 3);\n\tnext_pos = cpu_key_k_offset(&pos_key);\n\n\tpath_to_entry.reada = PATH_READA;\n\twhile (1) {\nresearch:\n\t\t \n\t\tsearch_res =\n\t\t    search_by_entry_key(inode->i_sb, &pos_key, &path_to_entry,\n\t\t\t\t\t&de);\n\t\tif (search_res == IO_ERROR) {\n\t\t\t \n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tentry_num = de.de_entry_num;\n\t\tbh = de.de_bh;\n\t\titem_num = de.de_item_num;\n\t\tih = de.de_ih;\n\t\tstore_ih(&tmp_ih, ih);\n\n\t\t \n\t\tRFALSE(COMP_SHORT_KEYS(&ih->ih_key, &pos_key),\n\t\t       \"vs-9000: found item %h does not match to dir we readdir %K\",\n\t\t       ih, &pos_key);\n\t\tRFALSE(item_num > B_NR_ITEMS(bh) - 1,\n\t\t       \"vs-9005 item_num == %d, item amount == %d\",\n\t\t       item_num, B_NR_ITEMS(bh));\n\n\t\t \n\t\tRFALSE(ih_entry_count(ih) < entry_num,\n\t\t       \"vs-9010: entry number is too big %d (%d)\",\n\t\t       entry_num, ih_entry_count(ih));\n\n\t\t \n\t\tif (search_res == POSITION_FOUND\n\t\t    || entry_num < ih_entry_count(ih)) {\n\t\t\tstruct reiserfs_de_head *deh =\n\t\t\t    B_I_DEH(bh, ih) + entry_num;\n\n\t\t\tfor (; entry_num < ih_entry_count(ih);\n\t\t\t     entry_num++, deh++) {\n\t\t\t\tint d_reclen;\n\t\t\t\tchar *d_name;\n\t\t\t\tino_t d_ino;\n\t\t\t\tloff_t cur_pos = deh_offset(deh);\n\n\t\t\t\t \n\t\t\t\tif (!de_visible(deh))\n\t\t\t\t\tcontinue;\n\t\t\t\td_reclen = entry_length(bh, ih, entry_num);\n\t\t\t\td_name = B_I_DEH_ENTRY_FILE_NAME(bh, ih, deh);\n\n\t\t\t\tif (d_reclen <= 0 ||\n\t\t\t\t    d_name + d_reclen > bh->b_data + bh->b_size) {\n\t\t\t\t\t \n\t\t\t\t\tpathrelse(&path_to_entry);\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (!d_name[d_reclen - 1])\n\t\t\t\t\td_reclen = strlen(d_name);\n\n\t\t\t\t \n\t\t\t\tif (d_reclen >\n\t\t\t\t    REISERFS_MAX_NAME(inode->i_sb->\n\t\t\t\t\t\t      s_blocksize)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (is_privroot_deh(inode, deh))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tctx->pos = deh_offset(deh);\n\t\t\t\td_ino = deh_objectid(deh);\n\t\t\t\tif (d_reclen <= 32) {\n\t\t\t\t\tlocal_buf = small_buf;\n\t\t\t\t} else {\n\t\t\t\t\tlocal_buf = kmalloc(d_reclen,\n\t\t\t\t\t\t\t    GFP_NOFS);\n\t\t\t\t\tif (!local_buf) {\n\t\t\t\t\t\tpathrelse(&path_to_entry);\n\t\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tif (item_moved(&tmp_ih, &path_to_entry)) {\n\t\t\t\t\t\tkfree(local_buf);\n\t\t\t\t\t\tgoto research;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tmemcpy(local_buf, d_name, d_reclen);\n\n\t\t\t\t \n\t\t\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\t\t\tif (!dir_emit\n\t\t\t\t    (ctx, local_buf, d_reclen, d_ino,\n\t\t\t\t     DT_UNKNOWN)) {\n\t\t\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t\t\t\tif (local_buf != small_buf) {\n\t\t\t\t\t\tkfree(local_buf);\n\t\t\t\t\t}\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t\t\tif (local_buf != small_buf) {\n\t\t\t\t\tkfree(local_buf);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tnext_pos = cur_pos + 1;\n\n\t\t\t\tif (item_moved(&tmp_ih, &path_to_entry)) {\n\t\t\t\t\tset_cpu_key_k_offset(&pos_key,\n\t\t\t\t\t\t\t     next_pos);\n\t\t\t\t\tgoto research;\n\t\t\t\t}\n\t\t\t}\t \n\t\t}\n\n\t\t \n\t\tif (item_num != B_NR_ITEMS(bh) - 1)\n\t\t\tgoto end;\n\n\t\t \n\t\trkey = get_rkey(&path_to_entry, inode->i_sb);\n\t\tif (!comp_le_keys(rkey, &MIN_KEY)) {\n\t\t\t \n\t\t\tset_cpu_key_k_offset(&pos_key, next_pos);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (COMP_SHORT_KEYS(rkey, &pos_key)) {\n\t\t\tgoto end;\n\t\t}\n\n\t\t \n\t\tset_cpu_key_k_offset(&pos_key,\n\t\t\t\t     le_key_k_offset(KEY_FORMAT_3_5, rkey));\n\n\t}\t\t\t \n\nend:\n\tctx->pos = next_pos;\n\tpathrelse(&path_to_entry);\n\treiserfs_check_path(&path_to_entry);\nout:\n\treiserfs_write_unlock(inode->i_sb);\n\treturn ret;\n}\n\nstatic int reiserfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn reiserfs_readdir_inode(file_inode(file), ctx);\n}\n\n \nvoid make_empty_dir_item_v1(char *body, __le32 dirid, __le32 objid,\n\t\t\t    __le32 par_dirid, __le32 par_objid)\n{\n\tstruct reiserfs_de_head *dot, *dotdot;\n\n\tmemset(body, 0, EMPTY_DIR_SIZE_V1);\n\tdot = (struct reiserfs_de_head *)body;\n\tdotdot = dot + 1;\n\n\t \n\tput_deh_offset(dot, DOT_OFFSET);\n\t \n\tdot->deh_dir_id = dirid;\n\tdot->deh_objectid = objid;\n\tdot->deh_state = 0;\t \n\tput_deh_location(dot, EMPTY_DIR_SIZE_V1 - strlen(\".\"));\n\tmark_de_visible(dot);\n\n\t \n\tput_deh_offset(dotdot, DOT_DOT_OFFSET);\n\t \n\t \n\tdotdot->deh_dir_id = par_dirid;\n\tdotdot->deh_objectid = par_objid;\n\tdotdot->deh_state = 0;\t \n\tput_deh_location(dotdot, deh_location(dot) - strlen(\"..\"));\n\tmark_de_visible(dotdot);\n\n\t \n\tmemcpy(body + deh_location(dot), \".\", 1);\n\tmemcpy(body + deh_location(dotdot), \"..\", 2);\n}\n\n \nvoid make_empty_dir_item(char *body, __le32 dirid, __le32 objid,\n\t\t\t __le32 par_dirid, __le32 par_objid)\n{\n\tstruct reiserfs_de_head *dot, *dotdot;\n\n\tmemset(body, 0, EMPTY_DIR_SIZE);\n\tdot = (struct reiserfs_de_head *)body;\n\tdotdot = dot + 1;\n\n\t \n\tput_deh_offset(dot, DOT_OFFSET);\n\t \n\tdot->deh_dir_id = dirid;\n\tdot->deh_objectid = objid;\n\tdot->deh_state = 0;\t \n\tput_deh_location(dot, EMPTY_DIR_SIZE - ROUND_UP(strlen(\".\")));\n\tmark_de_visible(dot);\n\n\t \n\tput_deh_offset(dotdot, DOT_DOT_OFFSET);\n\t \n\t \n\tdotdot->deh_dir_id = par_dirid;\n\tdotdot->deh_objectid = par_objid;\n\tdotdot->deh_state = 0;\t \n\tput_deh_location(dotdot, deh_location(dot) - ROUND_UP(strlen(\"..\")));\n\tmark_de_visible(dotdot);\n\n\t \n\tmemcpy(body + deh_location(dot), \".\", 1);\n\tmemcpy(body + deh_location(dotdot), \"..\", 2);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}