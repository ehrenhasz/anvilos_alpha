{
  "module_name": "file.c",
  "hash_id": "71aab9099267e7b389626d134a6fed383c667477eaf20954ed788e95ce74f92a",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/file.c",
  "human_readable_source": " \n\n#include <linux/time.h>\n#include \"reiserfs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n\n \nstatic int reiserfs_file_release(struct inode *inode, struct file *filp)\n{\n\n\tstruct reiserfs_transaction_handle th;\n\tint err;\n\tint jbegin_failure = 0;\n\n\tBUG_ON(!S_ISREG(inode->i_mode));\n\n\tif (!atomic_dec_and_mutex_lock(&REISERFS_I(inode)->openers,\n\t\t\t\t       &REISERFS_I(inode)->tailpack))\n\t\treturn 0;\n\n\t \n\tif ((!(REISERFS_I(inode)->i_flags & i_pack_on_close_mask) ||\n\t     !tail_has_to_be_packed(inode)) &&\n\t    REISERFS_I(inode)->i_prealloc_count <= 0) {\n\t\tmutex_unlock(&REISERFS_I(inode)->tailpack);\n\t\treturn 0;\n\t}\n\n\treiserfs_write_lock(inode->i_sb);\n\t \n\terr = journal_begin(&th, inode->i_sb, 1);\n\tif (err) {\n\t\t \n\t\tjbegin_failure = err;\n\t\terr = journal_join_abort(&th, inode->i_sb);\n\n\t\tif (err) {\n\t\t\t \n\t\t\tigrab(inode);\n\t\t\treiserfs_warning(inode->i_sb, \"clm-9001\",\n\t\t\t\t\t \"pinning inode %lu because the \"\n\t\t\t\t\t \"preallocation can't be freed\",\n\t\t\t\t\t inode->i_ino);\n\t\t\tgoto out;\n\t\t}\n\t}\n\treiserfs_update_inode_transaction(inode);\n\n#ifdef REISERFS_PREALLOCATE\n\treiserfs_discard_prealloc(&th, inode);\n#endif\n\terr = journal_end(&th);\n\n\t \n\tif (!err)\n\t\terr = jbegin_failure;\n\n\tif (!err &&\n\t    (REISERFS_I(inode)->i_flags & i_pack_on_close_mask) &&\n\t    tail_has_to_be_packed(inode)) {\n\n\t\t \n\t\terr = reiserfs_truncate_file(inode, 0);\n\t}\nout:\n\treiserfs_write_unlock(inode->i_sb);\n\tmutex_unlock(&REISERFS_I(inode)->tailpack);\n\treturn err;\n}\n\nstatic int reiserfs_file_open(struct inode *inode, struct file *file)\n{\n\tint err = dquot_file_open(inode, file);\n\n\t \n        if (!atomic_inc_not_zero(&REISERFS_I(inode)->openers)) {\n\t\tmutex_lock(&REISERFS_I(inode)->tailpack);\n\t\tatomic_inc(&REISERFS_I(inode)->openers);\n\t\tmutex_unlock(&REISERFS_I(inode)->tailpack);\n\t}\n\treturn err;\n}\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode)\n{\n\tmutex_lock(&REISERFS_I(inode)->tailpack);\n\treiserfs_truncate_file(inode, 1);\n\tmutex_unlock(&REISERFS_I(inode)->tailpack);\n}\n\n \n\n \n\nstatic int reiserfs_sync_file(struct file *filp, loff_t start, loff_t end,\n\t\t\t      int datasync)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint err;\n\tint barrier_done;\n\n\terr = file_write_and_wait_range(filp, start, end);\n\tif (err)\n\t\treturn err;\n\n\tinode_lock(inode);\n\tBUG_ON(!S_ISREG(inode->i_mode));\n\terr = sync_mapping_buffers(inode->i_mapping);\n\treiserfs_write_lock(inode->i_sb);\n\tbarrier_done = reiserfs_commit_for_inode(inode);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (barrier_done != 1 && reiserfs_barrier_flush(inode->i_sb))\n\t\tblkdev_issue_flush(inode->i_sb->s_bdev);\n\tinode_unlock(inode);\n\tif (barrier_done < 0)\n\t\treturn barrier_done;\n\treturn (err < 0) ? -EIO : 0;\n}\n\n \nint reiserfs_commit_page(struct inode *inode, struct page *page,\n\t\t\t unsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tint partial = 0;\n\tunsigned blocksize;\n\tstruct buffer_head *bh, *head;\n\tunsigned long i_size_index = inode->i_size >> PAGE_SHIFT;\n\tint new;\n\tint logit = reiserfs_file_data_log(inode);\n\tstruct super_block *s = inode->i_sb;\n\tint bh_per_page = PAGE_SIZE / s->s_blocksize;\n\tstruct reiserfs_transaction_handle th;\n\tint ret = 0;\n\n\tth.t_trans_id = 0;\n\tblocksize = i_blocksize(inode);\n\n\tif (logit) {\n\t\treiserfs_write_lock(s);\n\t\tret = journal_begin(&th, s, bh_per_page + 1);\n\t\tif (ret)\n\t\t\tgoto drop_write_lock;\n\t\treiserfs_update_inode_transaction(inode);\n\t}\n\tfor (bh = head = page_buffers(page), block_start = 0;\n\t     bh != head || !block_start;\n\t     block_start = block_end, bh = bh->b_this_page) {\n\n\t\tnew = buffer_new(bh);\n\t\tclear_buffer_new(bh);\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t} else {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tif (logit) {\n\t\t\t\treiserfs_prepare_for_journal(s, bh, 1);\n\t\t\t\tjournal_mark_dirty(&th, bh);\n\t\t\t} else if (!buffer_dirty(bh)) {\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t \n\t\t\t\tif (reiserfs_data_ordered(inode->i_sb) &&\n\t\t\t\t    (new || page->index >= i_size_index)) {\n\t\t\t\t\treiserfs_add_ordered_list(inode, bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (logit) {\n\t\tret = journal_end(&th);\ndrop_write_lock:\n\t\treiserfs_write_unlock(s);\n\t}\n\t \n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn ret;\n}\n\nconst struct file_operations reiserfs_file_operations = {\n\t.unlocked_ioctl = reiserfs_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = reiserfs_compat_ioctl,\n#endif\n\t.mmap = generic_file_mmap,\n\t.open = reiserfs_file_open,\n\t.release = reiserfs_file_release,\n\t.fsync = reiserfs_sync_file,\n\t.read_iter = generic_file_read_iter,\n\t.write_iter = generic_file_write_iter,\n\t.splice_read = filemap_splice_read,\n\t.splice_write = iter_file_splice_write,\n\t.llseek = generic_file_llseek,\n};\n\nconst struct inode_operations reiserfs_file_inode_operations = {\n\t.setattr = reiserfs_setattr,\n\t.listxattr = reiserfs_listxattr,\n\t.permission = reiserfs_permission,\n\t.get_inode_acl = reiserfs_get_acl,\n\t.set_acl = reiserfs_set_acl,\n\t.fileattr_get = reiserfs_fileattr_get,\n\t.fileattr_set = reiserfs_fileattr_set,\n};\n\nconst struct inode_operations reiserfs_priv_file_inode_operations = {\n\t.setattr = reiserfs_setattr,\n\t.permission = reiserfs_permission,\n\t.fileattr_get = reiserfs_fileattr_get,\n\t.fileattr_set = reiserfs_fileattr_set,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}