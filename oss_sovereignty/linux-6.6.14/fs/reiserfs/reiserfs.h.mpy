{
  "module_name": "reiserfs.h",
  "hash_id": "2da8e1ed5f6a11d1ea8cc21ced7cda79637ba207070bcf1cf39b789c87ef4aae",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/reiserfs.h",
  "human_readable_source": " \n \n\n#include <linux/reiserfs_fs.h>\n\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/bug.h>\n#include <linux/workqueue.h>\n#include <asm/unaligned.h>\n#include <linux/bitops.h>\n#include <linux/proc_fs.h>\n#include <linux/buffer_head.h>\n\n \n#define REISERFS_IOC32_UNPACK\t\t_IOW(0xCD, 1, int)\n#define REISERFS_IOC32_GETVERSION\tFS_IOC32_GETVERSION\n#define REISERFS_IOC32_SETVERSION\tFS_IOC32_SETVERSION\n\nstruct reiserfs_journal_list;\n\n \ntypedef enum {\n\t \n\ti_item_key_version_mask = 0x0001,\n\n\t \n\ti_stat_data_version_mask = 0x0002,\n\n\t \n\ti_pack_on_close_mask = 0x0004,\n\n\t \n\ti_nopack_mask = 0x0008,\n\n\t \n\ti_link_saved_unlink_mask = 0x0010,\n\ti_link_saved_truncate_mask = 0x0020,\n\n\ti_has_xattr_dir = 0x0040,\n\ti_data_log = 0x0080,\n} reiserfs_inode_flags;\n\nstruct reiserfs_inode_info {\n\t__u32 i_key[4];\t\t \n\n\t \n\t__u32 i_flags;\n\n\t \n\t__u32 i_first_direct_byte;\n\n\t \n\t__u32 i_attrs;\n\n\t \n\tint i_prealloc_block;\n\tint i_prealloc_count;\t \n\n\t \n\tstruct list_head i_prealloc_list;\n\n\t \n\tunsigned new_packing_locality:1;\n\n\t \n\tunsigned int i_trans_id;\n\n\tstruct reiserfs_journal_list *i_jl;\n\tatomic_t openers;\n\tstruct mutex tailpack;\n#ifdef CONFIG_REISERFS_FS_XATTR\n\tstruct rw_semaphore i_xattr_sem;\n#endif\n#ifdef CONFIG_QUOTA\n\tstruct dquot *i_dquot[MAXQUOTAS];\n#endif\n\n\tstruct inode vfs_inode;\n};\n\ntypedef enum {\n\treiserfs_attrs_cleared = 0x00000001,\n} reiserfs_super_block_flags;\n\n \n#define sb_block_count(sbp)         (le32_to_cpu((sbp)->s_v1.s_block_count))\n#define set_sb_block_count(sbp,v)   ((sbp)->s_v1.s_block_count = cpu_to_le32(v))\n#define sb_free_blocks(sbp)         (le32_to_cpu((sbp)->s_v1.s_free_blocks))\n#define set_sb_free_blocks(sbp,v)   ((sbp)->s_v1.s_free_blocks = cpu_to_le32(v))\n#define sb_root_block(sbp)          (le32_to_cpu((sbp)->s_v1.s_root_block))\n#define set_sb_root_block(sbp,v)    ((sbp)->s_v1.s_root_block = cpu_to_le32(v))\n\n#define sb_jp_journal_1st_block(sbp)  \\\n              (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_1st_block))\n#define set_sb_jp_journal_1st_block(sbp,v) \\\n              ((sbp)->s_v1.s_journal.jp_journal_1st_block = cpu_to_le32(v))\n#define sb_jp_journal_dev(sbp) \\\n              (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_dev))\n#define set_sb_jp_journal_dev(sbp,v) \\\n              ((sbp)->s_v1.s_journal.jp_journal_dev = cpu_to_le32(v))\n#define sb_jp_journal_size(sbp) \\\n              (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_size))\n#define set_sb_jp_journal_size(sbp,v) \\\n              ((sbp)->s_v1.s_journal.jp_journal_size = cpu_to_le32(v))\n#define sb_jp_journal_trans_max(sbp) \\\n              (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_trans_max))\n#define set_sb_jp_journal_trans_max(sbp,v) \\\n              ((sbp)->s_v1.s_journal.jp_journal_trans_max = cpu_to_le32(v))\n#define sb_jp_journal_magic(sbp) \\\n              (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_magic))\n#define set_sb_jp_journal_magic(sbp,v) \\\n              ((sbp)->s_v1.s_journal.jp_journal_magic = cpu_to_le32(v))\n#define sb_jp_journal_max_batch(sbp) \\\n              (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_max_batch))\n#define set_sb_jp_journal_max_batch(sbp,v) \\\n              ((sbp)->s_v1.s_journal.jp_journal_max_batch = cpu_to_le32(v))\n#define sb_jp_jourmal_max_commit_age(sbp) \\\n              (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_max_commit_age))\n#define set_sb_jp_journal_max_commit_age(sbp,v) \\\n              ((sbp)->s_v1.s_journal.jp_journal_max_commit_age = cpu_to_le32(v))\n\n#define sb_blocksize(sbp)          (le16_to_cpu((sbp)->s_v1.s_blocksize))\n#define set_sb_blocksize(sbp,v)    ((sbp)->s_v1.s_blocksize = cpu_to_le16(v))\n#define sb_oid_maxsize(sbp)        (le16_to_cpu((sbp)->s_v1.s_oid_maxsize))\n#define set_sb_oid_maxsize(sbp,v)  ((sbp)->s_v1.s_oid_maxsize = cpu_to_le16(v))\n#define sb_oid_cursize(sbp)        (le16_to_cpu((sbp)->s_v1.s_oid_cursize))\n#define set_sb_oid_cursize(sbp,v)  ((sbp)->s_v1.s_oid_cursize = cpu_to_le16(v))\n#define sb_umount_state(sbp)       (le16_to_cpu((sbp)->s_v1.s_umount_state))\n#define set_sb_umount_state(sbp,v) ((sbp)->s_v1.s_umount_state = cpu_to_le16(v))\n#define sb_fs_state(sbp)           (le16_to_cpu((sbp)->s_v1.s_fs_state))\n#define set_sb_fs_state(sbp,v)     ((sbp)->s_v1.s_fs_state = cpu_to_le16(v))\n#define sb_hash_function_code(sbp) \\\n              (le32_to_cpu((sbp)->s_v1.s_hash_function_code))\n#define set_sb_hash_function_code(sbp,v) \\\n              ((sbp)->s_v1.s_hash_function_code = cpu_to_le32(v))\n#define sb_tree_height(sbp)        (le16_to_cpu((sbp)->s_v1.s_tree_height))\n#define set_sb_tree_height(sbp,v)  ((sbp)->s_v1.s_tree_height = cpu_to_le16(v))\n#define sb_bmap_nr(sbp)            (le16_to_cpu((sbp)->s_v1.s_bmap_nr))\n#define set_sb_bmap_nr(sbp,v)      ((sbp)->s_v1.s_bmap_nr = cpu_to_le16(v))\n#define sb_version(sbp)            (le16_to_cpu((sbp)->s_v1.s_version))\n#define set_sb_version(sbp,v)      ((sbp)->s_v1.s_version = cpu_to_le16(v))\n\n#define sb_mnt_count(sbp)\t   (le16_to_cpu((sbp)->s_mnt_count))\n#define set_sb_mnt_count(sbp, v)   ((sbp)->s_mnt_count = cpu_to_le16(v))\n\n#define sb_reserved_for_journal(sbp) \\\n              (le16_to_cpu((sbp)->s_v1.s_reserved_for_journal))\n#define set_sb_reserved_for_journal(sbp,v) \\\n              ((sbp)->s_v1.s_reserved_for_journal = cpu_to_le16(v))\n\n \n\n \n\n \n \n#define JOURNAL_BLOCK_SIZE  4096\t \n#define JOURNAL_MAX_CNODE   1500\t \n#define JOURNAL_HASH_SIZE 8192\n\n \n#define JOURNAL_NUM_BITMAPS 5\n\n \nstruct reiserfs_journal_cnode {\n\tstruct buffer_head *bh;\t \n\tstruct super_block *sb;\t \n\n\t \n\t__u32 blocknr;\n\n\tunsigned long state;\n\n\t \n\tstruct reiserfs_journal_list *jlist;\n\n\tstruct reiserfs_journal_cnode *next;\t \n\tstruct reiserfs_journal_cnode *prev;\t \n\tstruct reiserfs_journal_cnode *hprev;\t \n\tstruct reiserfs_journal_cnode *hnext;\t \n};\n\nstruct reiserfs_bitmap_node {\n\tint id;\n\tchar *data;\n\tstruct list_head list;\n};\n\nstruct reiserfs_list_bitmap {\n\tstruct reiserfs_journal_list *journal_list;\n\tstruct reiserfs_bitmap_node **bitmaps;\n};\n\n \nstruct reiserfs_journal_list {\n\tunsigned long j_start;\n\tunsigned long j_state;\n\tunsigned long j_len;\n\tatomic_t j_nonzerolen;\n\tatomic_t j_commit_left;\n\n\t \n\tatomic_t j_older_commits_done;\n\n\tstruct mutex j_commit_mutex;\n\tunsigned int j_trans_id;\n\ttime64_t j_timestamp;  \n\tstruct reiserfs_list_bitmap *j_list_bitmap;\n\tstruct buffer_head *j_commit_bh;\t \n\tstruct reiserfs_journal_cnode *j_realblock;\n\tstruct reiserfs_journal_cnode *j_freedlist;\t \n\t \n\tstruct list_head j_list;\n\n\t \n\tstruct list_head j_working_list;\n\n\t \n\tstruct list_head j_tail_bh_list;\n\n\t \n\tstruct list_head j_bh_list;\n\tint j_refcount;\n};\n\nstruct reiserfs_journal {\n\tstruct buffer_head **j_ap_blocks;\t \n\t \n\tstruct reiserfs_journal_cnode *j_last;\n\n\t \n\tstruct reiserfs_journal_cnode *j_first;\n\n\tstruct block_device *j_dev_bd;\n\n\t \n\tint j_1st_reserved_block;\n\n\tunsigned long j_state;\n\tunsigned int j_trans_id;\n\tunsigned long j_mount_id;\n\n\t \n\tunsigned long j_start;\n\tunsigned long j_len;\t \n\n\t \n\tunsigned long j_len_alloc;\n\n\tatomic_t j_wcount;\t \n\n\t \n\tunsigned long j_bcount;\n\n\t \n\tunsigned long j_first_unflushed_offset;\n\n\t \n\tunsigned j_last_flush_trans_id;\n\n\tstruct buffer_head *j_header_bh;\n\n\ttime64_t j_trans_start_time;\t \n\tstruct mutex j_mutex;\n\tstruct mutex j_flush_mutex;\n\n\t \n\twait_queue_head_t j_join_wait;\n\n\tatomic_t j_jlock;\t\t \n\tint j_list_bitmap_index;\t \n\n\t \n\tint j_must_wait;\n\n\t \n\tint j_next_full_flush;\n\n\t \n\tint j_next_async_flush;\n\n\tint j_cnode_used;\t \n\tint j_cnode_free;\t \n\n\t \n\tunsigned int j_trans_max;\n\n\t \n\tunsigned int j_max_batch;\n\n\t \n\tunsigned int j_max_commit_age;\n\n\t \n\tunsigned int j_max_trans_age;\n\n\t \n\tunsigned int j_default_max_commit_age;\n\n\tstruct reiserfs_journal_cnode *j_cnode_free_list;\n\n\t \n\tstruct reiserfs_journal_cnode *j_cnode_free_orig;\n\n\tstruct reiserfs_journal_list *j_current_jl;\n\tint j_free_bitmap_nodes;\n\tint j_used_bitmap_nodes;\n\n\tint j_num_lists;\t \n\tint j_num_work_lists;\t \n\n\t \n\tunsigned int j_last_flush_id;\n\n\t \n\tunsigned int j_last_commit_id;\n\n\tstruct list_head j_bitmap_nodes;\n\tstruct list_head j_dirty_buffers;\n\tspinlock_t j_dirty_buffers_lock;\t \n\n\t \n\tstruct list_head j_journal_list;\n\n\t \n\tstruct list_head j_working_list;\n\n\t \n\tstruct reiserfs_journal_cnode *j_hash_table[JOURNAL_HASH_SIZE];\n\n\t \n\tstruct reiserfs_journal_cnode *j_list_hash_table[JOURNAL_HASH_SIZE];\n\n\t \n\tstruct reiserfs_list_bitmap j_list_bitmap[JOURNAL_NUM_BITMAPS];\n\n\t \n\tstruct list_head j_prealloc_list;\n\tint j_persistent_trans;\n\tunsigned long j_max_trans_size;\n\tunsigned long j_max_batch_size;\n\n\tint j_errno;\n\n\t \n\tstruct delayed_work j_work;\n\tstruct super_block *j_work_sb;\n\tatomic_t j_async_throttle;\n};\n\nenum journal_state_bits {\n\tJ_WRITERS_BLOCKED = 1,\t \n\tJ_WRITERS_QUEUED,     \n\tJ_ABORTED,            \n};\n\n \n#define JOURNAL_DESC_MAGIC \"ReIsErLB\"\n\ntypedef __u32(*hashf_t) (const signed char *, int);\n\nstruct reiserfs_bitmap_info {\n\t__u32 free_count;\n};\n\nstruct proc_dir_entry;\n\n#if defined( CONFIG_PROC_FS ) && defined( CONFIG_REISERFS_PROC_INFO )\ntypedef unsigned long int stat_cnt_t;\ntypedef struct reiserfs_proc_info_data {\n\tspinlock_t lock;\n\tint exiting;\n\tint max_hash_collisions;\n\n\tstat_cnt_t breads;\n\tstat_cnt_t bread_miss;\n\tstat_cnt_t search_by_key;\n\tstat_cnt_t search_by_key_fs_changed;\n\tstat_cnt_t search_by_key_restarted;\n\n\tstat_cnt_t insert_item_restarted;\n\tstat_cnt_t paste_into_item_restarted;\n\tstat_cnt_t cut_from_item_restarted;\n\tstat_cnt_t delete_solid_item_restarted;\n\tstat_cnt_t delete_item_restarted;\n\n\tstat_cnt_t leaked_oid;\n\tstat_cnt_t leaves_removable;\n\n\t \n\tstat_cnt_t balance_at[5];\t \n\t \n\tstat_cnt_t sbk_read_at[5];\t \n\tstat_cnt_t sbk_fs_changed[5];\n\tstat_cnt_t sbk_restarted[5];\n\tstat_cnt_t items_at[5];\t \n\tstat_cnt_t free_at[5];\t \n\tstat_cnt_t can_node_be_removed[5];\t \n\tlong int lnum[5];\t \n\tlong int rnum[5];\t \n\tlong int lbytes[5];\t \n\tlong int rbytes[5];\t \n\tstat_cnt_t get_neighbors[5];\n\tstat_cnt_t get_neighbors_restart[5];\n\tstat_cnt_t need_l_neighbor[5];\n\tstat_cnt_t need_r_neighbor[5];\n\n\tstat_cnt_t free_block;\n\tstruct __scan_bitmap_stats {\n\t\tstat_cnt_t call;\n\t\tstat_cnt_t wait;\n\t\tstat_cnt_t bmap;\n\t\tstat_cnt_t retry;\n\t\tstat_cnt_t in_journal_hint;\n\t\tstat_cnt_t in_journal_nohint;\n\t\tstat_cnt_t stolen;\n\t} scan_bitmap;\n\tstruct __journal_stats {\n\t\tstat_cnt_t in_journal;\n\t\tstat_cnt_t in_journal_bitmap;\n\t\tstat_cnt_t in_journal_reusable;\n\t\tstat_cnt_t lock_journal;\n\t\tstat_cnt_t lock_journal_wait;\n\t\tstat_cnt_t journal_being;\n\t\tstat_cnt_t journal_relock_writers;\n\t\tstat_cnt_t journal_relock_wcount;\n\t\tstat_cnt_t mark_dirty;\n\t\tstat_cnt_t mark_dirty_already;\n\t\tstat_cnt_t mark_dirty_notjournal;\n\t\tstat_cnt_t restore_prepared;\n\t\tstat_cnt_t prepare;\n\t\tstat_cnt_t prepare_retry;\n\t} journal;\n} reiserfs_proc_info_data_t;\n#else\ntypedef struct reiserfs_proc_info_data {\n} reiserfs_proc_info_data_t;\n#endif\n\n \n#define REISERFS_MAXQUOTAS 2\n\n \nstruct reiserfs_sb_info {\n\t \n\tstruct buffer_head *s_sbh;\n\n\t \n\tstruct reiserfs_super_block *s_rs;\n\tstruct reiserfs_bitmap_info *s_ap_bitmap;\n\n\t \n\tstruct reiserfs_journal *s_journal;\n\n\tunsigned short s_mount_state;\t \n\n\t \n\tstruct mutex lock;\n\n\t \n\tstruct task_struct *lock_owner;\n\n\t \n\tint lock_depth;\n\n\tstruct workqueue_struct *commit_wq;\n\n\t \n\tvoid (*end_io_handler) (struct buffer_head *, int);\n\n\t \n\thashf_t s_hash_function;\n\n\t \n\tunsigned long s_mount_opt;\n\n\t \n\tstruct {\n\t\t \n\t\tunsigned long bits;\n\n\t\t \n\t\tunsigned long large_file_size;\n\n\t\tint border;\t \n\n\t\t \n\t\tint preallocmin;\n\n\t\t \n\t\tint preallocsize;\n\t} s_alloc_options;\n\n\t \n\twait_queue_head_t s_wait;\n\t \n\tatomic_t s_generation_counter;\n\n\t \n\tunsigned long s_properties;\n\n\t \n\tint s_disk_reads;\n\tint s_disk_writes;\n\tint s_fix_nodes;\n\tint s_do_balance;\n\tint s_unneeded_left_neighbor;\n\tint s_good_search_by_key_reada;\n\tint s_bmaps;\n\tint s_bmaps_without_search;\n\tint s_direct2indirect;\n\tint s_indirect2direct;\n\n\t \n\tint s_is_unlinked_ok;\n\n\treiserfs_proc_info_data_t s_proc_info_data;\n\tstruct proc_dir_entry *procdir;\n\n\t \n\tint reserved_blocks;\n\n\n\t \n\tspinlock_t bitmap_lock;\n\tstruct dentry *priv_root;\t \n\tstruct dentry *xattr_root;\t \n\tint j_errno;\n\n\tint work_queued;               \n\tstruct delayed_work old_work;  \n\tspinlock_t old_work_lock;      \n\n#ifdef CONFIG_QUOTA\n\tchar *s_qf_names[REISERFS_MAXQUOTAS];\n\tint s_jquota_fmt;\n#endif\n\tchar *s_jdev;\t\t \n#ifdef CONFIG_REISERFS_CHECK\n\n\t \n\tstruct tree_balance *cur_tb;\n#endif\n};\n\n \n#define REISERFS_3_5 0\n#define REISERFS_3_6 1\n#define REISERFS_OLD_FORMAT 2\n\n \nenum reiserfs_mount_options {\n\t \n\tREISERFS_LARGETAIL,\n\t \n\tREISERFS_SMALLTAIL,\n\n\t \n\tREPLAYONLY,\n\n\t \n\tREISERFS_CONVERT,\n\n\t \n\tFORCE_TEA_HASH,\t\t \n\tFORCE_RUPASOV_HASH,\t \n\tFORCE_R5_HASH,\t\t \n\tFORCE_HASH_DETECT,\t \n\n\tREISERFS_DATA_LOG,\n\tREISERFS_DATA_ORDERED,\n\tREISERFS_DATA_WRITEBACK,\n\n\t \n\n\tREISERFS_NO_BORDER,\n\tREISERFS_NO_UNHASHED_RELOCATION,\n\tREISERFS_HASHED_RELOCATION,\n\tREISERFS_ATTRS,\n\tREISERFS_XATTRS_USER,\n\tREISERFS_POSIXACL,\n\tREISERFS_EXPOSE_PRIVROOT,\n\tREISERFS_BARRIER_NONE,\n\tREISERFS_BARRIER_FLUSH,\n\n\t \n\tREISERFS_ERROR_PANIC,\n\tREISERFS_ERROR_RO,\n\tREISERFS_ERROR_CONTINUE,\n\n\tREISERFS_USRQUOTA,\t \n\tREISERFS_GRPQUOTA,\t \n\n\tREISERFS_TEST1,\n\tREISERFS_TEST2,\n\tREISERFS_TEST3,\n\tREISERFS_TEST4,\n\tREISERFS_UNSUPPORTED_OPT,\n};\n\n#define reiserfs_r5_hash(s) (REISERFS_SB(s)->s_mount_opt & (1 << FORCE_R5_HASH))\n#define reiserfs_rupasov_hash(s) (REISERFS_SB(s)->s_mount_opt & (1 << FORCE_RUPASOV_HASH))\n#define reiserfs_tea_hash(s) (REISERFS_SB(s)->s_mount_opt & (1 << FORCE_TEA_HASH))\n#define reiserfs_hash_detect(s) (REISERFS_SB(s)->s_mount_opt & (1 << FORCE_HASH_DETECT))\n#define reiserfs_no_border(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_NO_BORDER))\n#define reiserfs_no_unhashed_relocation(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_NO_UNHASHED_RELOCATION))\n#define reiserfs_hashed_relocation(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_HASHED_RELOCATION))\n#define reiserfs_test4(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_TEST4))\n\n#define have_large_tails(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_LARGETAIL))\n#define have_small_tails(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_SMALLTAIL))\n#define replay_only(s) (REISERFS_SB(s)->s_mount_opt & (1 << REPLAYONLY))\n#define reiserfs_attrs(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_ATTRS))\n#define old_format_only(s) (REISERFS_SB(s)->s_properties & (1 << REISERFS_3_5))\n#define convert_reiserfs(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_CONVERT))\n#define reiserfs_data_log(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_DATA_LOG))\n#define reiserfs_data_ordered(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_DATA_ORDERED))\n#define reiserfs_data_writeback(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_DATA_WRITEBACK))\n#define reiserfs_xattrs_user(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_XATTRS_USER))\n#define reiserfs_posixacl(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_POSIXACL))\n#define reiserfs_expose_privroot(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_EXPOSE_PRIVROOT))\n#define reiserfs_xattrs_optional(s) (reiserfs_xattrs_user(s) || reiserfs_posixacl(s))\n#define reiserfs_barrier_none(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_BARRIER_NONE))\n#define reiserfs_barrier_flush(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_BARRIER_FLUSH))\n\n#define reiserfs_error_panic(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_ERROR_PANIC))\n#define reiserfs_error_ro(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_ERROR_RO))\n\nvoid reiserfs_file_buffer(struct buffer_head *bh, int list);\nextern struct file_system_type reiserfs_fs_type;\nint reiserfs_resize(struct super_block *, unsigned long);\n\n#define CARRY_ON                0\n#define SCHEDULE_OCCURRED       1\n\n#define SB_BUFFER_WITH_SB(s) (REISERFS_SB(s)->s_sbh)\n#define SB_JOURNAL(s) (REISERFS_SB(s)->s_journal)\n#define SB_JOURNAL_1st_RESERVED_BLOCK(s) (SB_JOURNAL(s)->j_1st_reserved_block)\n#define SB_JOURNAL_LEN_FREE(s) (SB_JOURNAL(s)->j_journal_len_free)\n#define SB_AP_BITMAP(s) (REISERFS_SB(s)->s_ap_bitmap)\n\n#define SB_DISK_JOURNAL_HEAD(s) (SB_JOURNAL(s)->j_header_bh->)\n\n#define reiserfs_is_journal_aborted(journal) (unlikely (__reiserfs_is_journal_aborted (journal)))\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}\n\n \nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth);\n\n#ifdef CONFIG_REISERFS_CHECK\nvoid reiserfs_lock_check_recursive(struct super_block *s);\n#else\nstatic inline void reiserfs_lock_check_recursive(struct super_block *s) { }\n#endif\n\n \nstatic inline void reiserfs_mutex_lock_safe(struct mutex *m,\n\t\t\t\t\t    struct super_block *s)\n{\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(s);\n\tmutex_lock(m);\n\treiserfs_write_lock_nested(s, depth);\n}\n\nstatic inline void\nreiserfs_mutex_lock_nested_safe(struct mutex *m, unsigned int subclass,\n\t\t\t\tstruct super_block *s)\n{\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(s);\n\tmutex_lock_nested(m, subclass);\n\treiserfs_write_lock_nested(s, depth);\n}\n\nstatic inline void\nreiserfs_down_read_safe(struct rw_semaphore *sem, struct super_block *s)\n{\n       int depth;\n       depth = reiserfs_write_unlock_nested(s);\n       down_read(sem);\n       reiserfs_write_lock_nested(s, depth);\n}\n\n \nstatic inline void reiserfs_cond_resched(struct super_block *s)\n{\n\tif (need_resched()) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tschedule();\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n}\n\nstruct fid;\n\n \n\n#define USE_INODE_GENERATION_COUNTER\n\n#define REISERFS_PREALLOCATE\n#define DISPLACE_NEW_PACKING_LOCALITIES\n#define PREALLOCATION_SIZE 9\n\n \n#define _ROUND_UP(x,n) (((x)+(n)-1u) & ~((n)-1u))\n\n \n#define ROUND_UP(x) _ROUND_UP(x,8LL)\n\n \n#define REISERFS_DEBUG_CODE 5\t \n\nvoid __reiserfs_warning(struct super_block *s, const char *id,\n\t\t\t const char *func, const char *fmt, ...);\n#define reiserfs_warning(s, id, fmt, args...) \\\n\t __reiserfs_warning(s, id, __func__, fmt, ##args)\n \n\n \n#define __RASSERT(cond, scond, format, args...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (!(cond))\t\t\t\t\t\t\t\\\n\t\treiserfs_panic(NULL, \"assertion failure\", \"(\" #cond \") at \" \\\n\t\t\t       __FILE__ \":%i:%s: \" format \"\\n\",\t\t\\\n\t\t\t       __LINE__, __func__ , ##args);\t\t\\\n} while (0)\n\n#define RASSERT(cond, format, args...) __RASSERT(cond, #cond, format, ##args)\n\n#if defined( CONFIG_REISERFS_CHECK )\n#define RFALSE(cond, format, args...) __RASSERT(!(cond), \"!(\" #cond \")\", format, ##args)\n#else\n#define RFALSE( cond, format, args... ) do {;} while( 0 )\n#endif\n\n#define CONSTF __attribute_const__\n \n\n \n\n \n#define UNSET_HASH 0\t \n#define TEA_HASH  1\n#define YURA_HASH 2\n#define R5_HASH   3\n#define DEFAULT_HASH R5_HASH\n\nstruct journal_params {\n\t \n\t__le32 jp_journal_1st_block;\n\n\t \n\t__le32 jp_journal_dev;\n\n\t \n\t__le32 jp_journal_size;\n\n\t \n\t__le32 jp_journal_trans_max;\n\n\t \n\t__le32 jp_journal_magic;\n\n\t \n\t__le32 jp_journal_max_batch;\n\n\t \n\t__le32 jp_journal_max_commit_age;\n\n\t \n\t__le32 jp_journal_max_trans_age;\n};\n\n \nstruct reiserfs_super_block_v1 {\n\t__le32 s_block_count;\t \n\t__le32 s_free_blocks;\t \n\t__le32 s_root_block;\t \n\tstruct journal_params s_journal;\n\t__le16 s_blocksize;\t \n\n\t \n\t__le16 s_oid_maxsize;\n\t__le16 s_oid_cursize;\t \n\n\t \n\t__le16 s_umount_state;\n\n\t \n\tchar s_magic[10];\n\n\t \n\t__le16 s_fs_state;\n\t \n\t__le32 s_hash_function_code;\n\t__le16 s_tree_height;\t \n\n\t \n\t__le16 s_bmap_nr;\n\n\t \n\t__le16 s_version;\n\n\t \n\t__le16 s_reserved_for_journal;\n} __attribute__ ((__packed__));\n\n#define SB_SIZE_V1 (sizeof(struct reiserfs_super_block_v1))\n\n \nstruct reiserfs_super_block {\n\tstruct reiserfs_super_block_v1 s_v1;\n\t__le32 s_inode_generation;\n\n\t \n\t__le32 s_flags;\n\n\tunsigned char s_uuid[16];\t \n\tunsigned char s_label[16];\t \n\t__le16 s_mnt_count;\t\t \n\t__le16 s_max_mnt_count;\t\t \n\t__le32 s_lastcheck;\t\t \n\t__le32 s_check_interval;\t \n\n\t \n\tchar s_unused[76];\n} __attribute__ ((__packed__));\n\n#define SB_SIZE (sizeof(struct reiserfs_super_block))\n\n#define REISERFS_VERSION_1 0\n#define REISERFS_VERSION_2 2\n\n \n#define SB_DISK_SUPER_BLOCK(s) (REISERFS_SB(s)->s_rs)\n#define SB_V1_DISK_SUPER_BLOCK(s) (&(SB_DISK_SUPER_BLOCK(s)->s_v1))\n#define SB_BLOCKSIZE(s) \\\n        le32_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)->s_blocksize))\n#define SB_BLOCK_COUNT(s) \\\n        le32_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)->s_block_count))\n#define SB_FREE_BLOCKS(s) \\\n        le32_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)->s_free_blocks))\n#define SB_REISERFS_MAGIC(s) \\\n        (SB_V1_DISK_SUPER_BLOCK(s)->s_magic)\n#define SB_ROOT_BLOCK(s) \\\n        le32_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)->s_root_block))\n#define SB_TREE_HEIGHT(s) \\\n        le16_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)->s_tree_height))\n#define SB_REISERFS_STATE(s) \\\n        le16_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)->s_umount_state))\n#define SB_VERSION(s) le16_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)->s_version))\n#define SB_BMAP_NR(s) le16_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)->s_bmap_nr))\n\n#define PUT_SB_BLOCK_COUNT(s, val) \\\n   do { SB_V1_DISK_SUPER_BLOCK(s)->s_block_count = cpu_to_le32(val); } while (0)\n#define PUT_SB_FREE_BLOCKS(s, val) \\\n   do { SB_V1_DISK_SUPER_BLOCK(s)->s_free_blocks = cpu_to_le32(val); } while (0)\n#define PUT_SB_ROOT_BLOCK(s, val) \\\n   do { SB_V1_DISK_SUPER_BLOCK(s)->s_root_block = cpu_to_le32(val); } while (0)\n#define PUT_SB_TREE_HEIGHT(s, val) \\\n   do { SB_V1_DISK_SUPER_BLOCK(s)->s_tree_height = cpu_to_le16(val); } while (0)\n#define PUT_SB_REISERFS_STATE(s, val) \\\n   do { SB_V1_DISK_SUPER_BLOCK(s)->s_umount_state = cpu_to_le16(val); } while (0)\n#define PUT_SB_VERSION(s, val) \\\n   do { SB_V1_DISK_SUPER_BLOCK(s)->s_version = cpu_to_le16(val); } while (0)\n#define PUT_SB_BMAP_NR(s, val) \\\n   do { SB_V1_DISK_SUPER_BLOCK(s)->s_bmap_nr = cpu_to_le16 (val); } while (0)\n\n#define SB_ONDISK_JP(s) (&SB_V1_DISK_SUPER_BLOCK(s)->s_journal)\n#define SB_ONDISK_JOURNAL_SIZE(s) \\\n         le32_to_cpu ((SB_ONDISK_JP(s)->jp_journal_size))\n#define SB_ONDISK_JOURNAL_1st_BLOCK(s) \\\n         le32_to_cpu ((SB_ONDISK_JP(s)->jp_journal_1st_block))\n#define SB_ONDISK_JOURNAL_DEVICE(s) \\\n         le32_to_cpu ((SB_ONDISK_JP(s)->jp_journal_dev))\n#define SB_ONDISK_RESERVED_FOR_JOURNAL(s) \\\n         le16_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)->s_reserved_for_journal))\n\n#define is_block_in_log_or_reserved_area(s, block) \\\n         block >= SB_JOURNAL_1st_RESERVED_BLOCK(s) \\\n         && block < SB_JOURNAL_1st_RESERVED_BLOCK(s) +  \\\n         ((!is_reiserfs_jr(SB_DISK_SUPER_BLOCK(s)) ? \\\n         SB_ONDISK_JOURNAL_SIZE(s) + 1 : SB_ONDISK_RESERVED_FOR_JOURNAL(s)))\n\nint is_reiserfs_3_5(struct reiserfs_super_block *rs);\nint is_reiserfs_3_6(struct reiserfs_super_block *rs);\nint is_reiserfs_jr(struct reiserfs_super_block *rs);\n\n \n#define REISERFS_DISK_OFFSET_IN_BYTES (64 * 1024)\n#define REISERFS_FIRST_BLOCK unused_define\n#define REISERFS_JOURNAL_OFFSET_IN_BYTES REISERFS_DISK_OFFSET_IN_BYTES\n\n \n#define REISERFS_OLD_DISK_OFFSET_IN_BYTES (8 * 1024)\n\n \n#define CARRY_ON      0\n#define REPEAT_SEARCH -1\n#define IO_ERROR      -2\n#define NO_DISK_SPACE -3\n#define NO_BALANCING_NEEDED  (-4)\n#define NO_MORE_UNUSED_CONTIGUOUS_BLOCKS (-5)\n#define QUOTA_EXCEEDED -6\n\ntypedef __u32 b_blocknr_t;\ntypedef __le32 unp_t;\n\nstruct unfm_nodeinfo {\n\tunp_t unfm_nodenum;\n\tunsigned short unfm_freespace;\n};\n\n \n#define KEY_FORMAT_3_5 0\n#define KEY_FORMAT_3_6 1\n\n \n#define STAT_DATA_V1 0\n#define STAT_DATA_V2 1\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\n \nstatic inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}\n\nstatic inline int bmap_would_wrap(unsigned bmap_nr)\n{\n\treturn bmap_nr > ((1LL << 16) - 1);\n}\n\nextern const struct xattr_handler *reiserfs_xattr_handlers[];\n\n \n#define get_inode_item_key_version( inode )                                    \\\n    ((REISERFS_I(inode)->i_flags & i_item_key_version_mask) ? KEY_FORMAT_3_6 : KEY_FORMAT_3_5)\n\n#define set_inode_item_key_version( inode, version )                           \\\n         ({ if((version)==KEY_FORMAT_3_6)                                      \\\n                REISERFS_I(inode)->i_flags |= i_item_key_version_mask;      \\\n            else                                                               \\\n                REISERFS_I(inode)->i_flags &= ~i_item_key_version_mask; })\n\n#define get_inode_sd_version(inode)                                            \\\n    ((REISERFS_I(inode)->i_flags & i_stat_data_version_mask) ? STAT_DATA_V2 : STAT_DATA_V1)\n\n#define set_inode_sd_version(inode, version)                                   \\\n         ({ if((version)==STAT_DATA_V2)                                        \\\n                REISERFS_I(inode)->i_flags |= i_stat_data_version_mask;     \\\n            else                                                               \\\n                REISERFS_I(inode)->i_flags &= ~i_stat_data_version_mask; })\n\n \n#define STORE_TAIL_IN_UNFM_S1(n_file_size,n_tail_size,n_block_size) \\\n(\\\n  (!(n_tail_size)) || \\\n  (((n_tail_size) > MAX_DIRECT_ITEM_LEN(n_block_size)) || \\\n   ( (n_file_size) >= (n_block_size) * 4 ) || \\\n   ( ( (n_file_size) >= (n_block_size) * 3 ) && \\\n     ( (n_tail_size) >=   (MAX_DIRECT_ITEM_LEN(n_block_size))/4) ) || \\\n   ( ( (n_file_size) >= (n_block_size) * 2 ) && \\\n     ( (n_tail_size) >=   (MAX_DIRECT_ITEM_LEN(n_block_size))/2) ) || \\\n   ( ( (n_file_size) >= (n_block_size) ) && \\\n     ( (n_tail_size) >=   (MAX_DIRECT_ITEM_LEN(n_block_size) * 3)/4) ) ) \\\n)\n\n \n#define STORE_TAIL_IN_UNFM_S2(n_file_size,n_tail_size,n_block_size) \\\n(\\\n  (!(n_tail_size)) || \\\n  (((n_file_size) > MAX_DIRECT_ITEM_LEN(n_block_size)) ) \\\n)\n\n \n#define REISERFS_VALID_FS    1\n#define REISERFS_ERROR_FS    2\n\n \n#define TYPE_STAT_DATA 0\n#define TYPE_INDIRECT 1\n#define TYPE_DIRECT 2\n#define TYPE_DIRENTRY 3\n#define TYPE_MAXTYPE 3\n#define TYPE_ANY 15\t\t \n\n \n\n \nstruct offset_v1 {\n\t__le32 k_offset;\n\t__le32 k_uniqueness;\n} __attribute__ ((__packed__));\n\nstruct offset_v2 {\n\t__le64 v;\n} __attribute__ ((__packed__));\n\nstatic inline __u16 offset_v2_k_type(const struct offset_v2 *v2)\n{\n\t__u8 type = le64_to_cpu(v2->v) >> 60;\n\treturn (type <= TYPE_MAXTYPE) ? type : TYPE_ANY;\n}\n\nstatic inline void set_offset_v2_k_type(struct offset_v2 *v2, int type)\n{\n\tv2->v =\n\t    (v2->v & cpu_to_le64(~0ULL >> 4)) | cpu_to_le64((__u64) type << 60);\n}\n\nstatic inline loff_t offset_v2_k_offset(const struct offset_v2 *v2)\n{\n\treturn le64_to_cpu(v2->v) & (~0ULL >> 4);\n}\n\nstatic inline void set_offset_v2_k_offset(struct offset_v2 *v2, loff_t offset)\n{\n\toffset &= (~0ULL >> 4);\n\tv2->v = (v2->v & cpu_to_le64(15ULL << 60)) | cpu_to_le64(offset);\n}\n\n \nstruct reiserfs_key {\n\t \n\t__le32 k_dir_id;\n\n\t__le32 k_objectid;\t \n\tunion {\n\t\tstruct offset_v1 k_offset_v1;\n\t\tstruct offset_v2 k_offset_v2;\n\t} __attribute__ ((__packed__)) u;\n} __attribute__ ((__packed__));\n\nstruct in_core_key {\n\t \n\t__u32 k_dir_id;\n\t__u32 k_objectid;\t \n\t__u64 k_offset;\n\t__u8 k_type;\n};\n\nstruct cpu_key {\n\tstruct in_core_key on_disk_key;\n\tint version;\n\t \n\tint key_length;\n};\n\n \n#define REISERFS_FULL_KEY_LEN     4\n#define REISERFS_SHORT_KEY_LEN    2\n\n \n#define FIRST_GREATER 1\n#define SECOND_GREATER -1\n#define KEYS_IDENTICAL 0\n#define KEY_FOUND 1\n#define KEY_NOT_FOUND 0\n\n#define KEY_SIZE (sizeof(struct reiserfs_key))\n\n \n#define ITEM_FOUND 1\n#define ITEM_NOT_FOUND 0\n#define ENTRY_FOUND 1\n#define ENTRY_NOT_FOUND 0\n#define DIRECTORY_NOT_FOUND -1\n#define REGULAR_FILE_FOUND -2\n#define DIRECTORY_FOUND -3\n#define BYTE_FOUND 1\n#define BYTE_NOT_FOUND 0\n#define FILE_NOT_FOUND -1\n\n#define POSITION_FOUND 1\n#define POSITION_NOT_FOUND 0\n\n \n#define NAME_FOUND 1\n#define NAME_NOT_FOUND 0\n#define GOTO_PREVIOUS_ITEM 2\n#define NAME_FOUND_INVISIBLE 3\n\n \n\nstruct item_head {\n\t \n\tstruct reiserfs_key ih_key;\n\tunion {\n\t\t \n\t\t__le16 ih_free_space_reserved;\n\n\t\t \n\t\t__le16 ih_entry_count;\n\t} __attribute__ ((__packed__)) u;\n\t__le16 ih_item_len;\t \n\n\t \n\t__le16 ih_item_location;\n\n\t \n\t__le16 ih_version;\n} __attribute__ ((__packed__));\n \n#define IH_SIZE (sizeof(struct item_head))\n\n#define ih_free_space(ih)            le16_to_cpu((ih)->u.ih_free_space_reserved)\n#define ih_version(ih)               le16_to_cpu((ih)->ih_version)\n#define ih_entry_count(ih)           le16_to_cpu((ih)->u.ih_entry_count)\n#define ih_location(ih)              le16_to_cpu((ih)->ih_item_location)\n#define ih_item_len(ih)              le16_to_cpu((ih)->ih_item_len)\n\n#define put_ih_free_space(ih, val)   do { (ih)->u.ih_free_space_reserved = cpu_to_le16(val); } while(0)\n#define put_ih_version(ih, val)      do { (ih)->ih_version = cpu_to_le16(val); } while (0)\n#define put_ih_entry_count(ih, val)  do { (ih)->u.ih_entry_count = cpu_to_le16(val); } while (0)\n#define put_ih_location(ih, val)     do { (ih)->ih_item_location = cpu_to_le16(val); } while (0)\n#define put_ih_item_len(ih, val)     do { (ih)->ih_item_len = cpu_to_le16(val); } while (0)\n\n#define unreachable_item(ih) (ih_version(ih) & (1 << 15))\n\n#define get_ih_free_space(ih) (ih_version (ih) == KEY_FORMAT_3_6 ? 0 : ih_free_space (ih))\n#define set_ih_free_space(ih,val) put_ih_free_space((ih), ((ih_version(ih) == KEY_FORMAT_3_6) ? 0 : (val)))\n\n \n#define get_block_num(p, i) get_unaligned_le32((p) + (i))\n#define put_block_num(p, i, v) put_unaligned_le32((v), (p) + (i))\n\n \n#define V1_SD_UNIQUENESS 0\n#define V1_INDIRECT_UNIQUENESS 0xfffffffe\n#define V1_DIRECT_UNIQUENESS 0xffffffff\n#define V1_DIRENTRY_UNIQUENESS 500\n#define V1_ANY_UNIQUENESS 555\t \n\n \nstatic inline int uniqueness2type(__u32 uniqueness) CONSTF;\nstatic inline int uniqueness2type(__u32 uniqueness)\n{\n\tswitch ((int)uniqueness) {\n\tcase V1_SD_UNIQUENESS:\n\t\treturn TYPE_STAT_DATA;\n\tcase V1_INDIRECT_UNIQUENESS:\n\t\treturn TYPE_INDIRECT;\n\tcase V1_DIRECT_UNIQUENESS:\n\t\treturn TYPE_DIRECT;\n\tcase V1_DIRENTRY_UNIQUENESS:\n\t\treturn TYPE_DIRENTRY;\n\tcase V1_ANY_UNIQUENESS:\n\tdefault:\n\t\treturn TYPE_ANY;\n\t}\n}\n\nstatic inline __u32 type2uniqueness(int type) CONSTF;\nstatic inline __u32 type2uniqueness(int type)\n{\n\tswitch (type) {\n\tcase TYPE_STAT_DATA:\n\t\treturn V1_SD_UNIQUENESS;\n\tcase TYPE_INDIRECT:\n\t\treturn V1_INDIRECT_UNIQUENESS;\n\tcase TYPE_DIRECT:\n\t\treturn V1_DIRECT_UNIQUENESS;\n\tcase TYPE_DIRENTRY:\n\t\treturn V1_DIRENTRY_UNIQUENESS;\n\tcase TYPE_ANY:\n\tdefault:\n\t\treturn V1_ANY_UNIQUENESS;\n\t}\n}\n\n \nstatic inline loff_t le_key_k_offset(int version,\n\t\t\t\t     const struct reiserfs_key *key)\n{\n\treturn (version == KEY_FORMAT_3_5) ?\n\t    le32_to_cpu(key->u.k_offset_v1.k_offset) :\n\t    offset_v2_k_offset(&(key->u.k_offset_v2));\n}\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}\n\nstatic inline loff_t le_key_k_type(int version, const struct reiserfs_key *key)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\tloff_t val = le32_to_cpu(key->u.k_offset_v1.k_uniqueness);\n\t\treturn uniqueness2type(val);\n\t} else\n\t\treturn offset_v2_k_type(&(key->u.k_offset_v2));\n}\n\nstatic inline loff_t le_ih_k_type(const struct item_head *ih)\n{\n\treturn le_key_k_type(ih_version(ih), &(ih->ih_key));\n}\n\nstatic inline void set_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tif (version == KEY_FORMAT_3_5)\n\t\tkey->u.k_offset_v1.k_offset = cpu_to_le32(offset);\n\telse\n\t\tset_offset_v2_k_offset(&key->u.k_offset_v2, offset);\n}\n\nstatic inline void add_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tset_le_key_k_offset(version, key,\n\t\t\t    le_key_k_offset(version, key) + offset);\n}\n\nstatic inline void add_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tadd_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}\n\nstatic inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}\n\nstatic inline void set_le_key_k_type(int version, struct reiserfs_key *key,\n\t\t\t\t     int type)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\ttype = type2uniqueness(type);\n\t\tkey->u.k_offset_v1.k_uniqueness = cpu_to_le32(type);\n\t} else\n\t       set_offset_v2_k_type(&key->u.k_offset_v2, type);\n}\n\nstatic inline void set_le_ih_k_type(struct item_head *ih, int type)\n{\n\tset_le_key_k_type(ih_version(ih), &(ih->ih_key), type);\n}\n\nstatic inline int is_direntry_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_DIRENTRY;\n}\n\nstatic inline int is_direct_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_DIRECT;\n}\n\nstatic inline int is_indirect_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_INDIRECT;\n}\n\nstatic inline int is_statdata_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_STAT_DATA;\n}\n\n \nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}\n\nstatic inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}\n\nstatic inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}\n\n \nstatic inline loff_t cpu_key_k_offset(const struct cpu_key *key)\n{\n\treturn key->on_disk_key.k_offset;\n}\n\nstatic inline loff_t cpu_key_k_type(const struct cpu_key *key)\n{\n\treturn key->on_disk_key.k_type;\n}\n\nstatic inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}\n\nstatic inline void set_cpu_key_k_type(struct cpu_key *key, int type)\n{\n\tkey->on_disk_key.k_type = type;\n}\n\nstatic inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}\n\n#define is_direntry_cpu_key(key) (cpu_key_k_type (key) == TYPE_DIRENTRY)\n#define is_direct_cpu_key(key) (cpu_key_k_type (key) == TYPE_DIRECT)\n#define is_indirect_cpu_key(key) (cpu_key_k_type (key) == TYPE_INDIRECT)\n#define is_statdata_cpu_key(key) (cpu_key_k_type (key) == TYPE_STAT_DATA)\n\n \n#define is_direntry_cpu_ih(ih) (is_direntry_cpu_key (&((ih)->ih_key)))\n#define is_direct_cpu_ih(ih) (is_direct_cpu_key (&((ih)->ih_key)))\n#define is_indirect_cpu_ih(ih) (is_indirect_cpu_key (&((ih)->ih_key)))\n#define is_statdata_cpu_ih(ih) (is_statdata_cpu_key (&((ih)->ih_key)))\n\n#define I_K_KEY_IN_ITEM(ih, key, n_blocksize) \\\n    (!COMP_SHORT_KEYS(ih, key) && \\\n\t  I_OFF_BYTE_IN_ITEM(ih, k_offset(key), n_blocksize))\n\n \n#define MAX_ITEM_LEN(block_size) (block_size - BLKH_SIZE - IH_SIZE)\n#define MIN_ITEM_LEN 1\n\n \n#define REISERFS_ROOT_OBJECTID 2\n#define REISERFS_ROOT_PARENT_OBJECTID 1\n\nextern struct reiserfs_key root_key;\n\n \n\n \nstruct block_head {\n\t__le16 blk_level;\t \n\t__le16 blk_nr_item;\t \n\t__le16 blk_free_space;\t \n\t__le16 blk_reserved;\n\t \n\n\t \n\tstruct reiserfs_key blk_right_delim_key;\n};\n\n#define BLKH_SIZE                     (sizeof(struct block_head))\n#define blkh_level(p_blkh)            (le16_to_cpu((p_blkh)->blk_level))\n#define blkh_nr_item(p_blkh)          (le16_to_cpu((p_blkh)->blk_nr_item))\n#define blkh_free_space(p_blkh)       (le16_to_cpu((p_blkh)->blk_free_space))\n#define blkh_reserved(p_blkh)         (le16_to_cpu((p_blkh)->blk_reserved))\n#define set_blkh_level(p_blkh,val)    ((p_blkh)->blk_level = cpu_to_le16(val))\n#define set_blkh_nr_item(p_blkh,val)  ((p_blkh)->blk_nr_item = cpu_to_le16(val))\n#define set_blkh_free_space(p_blkh,val) ((p_blkh)->blk_free_space = cpu_to_le16(val))\n#define set_blkh_reserved(p_blkh,val) ((p_blkh)->blk_reserved = cpu_to_le16(val))\n#define blkh_right_delim_key(p_blkh)  ((p_blkh)->blk_right_delim_key)\n#define set_blkh_right_delim_key(p_blkh,val)  ((p_blkh)->blk_right_delim_key = val)\n\n \n\n \n#define FREE_LEVEL 0\n\n#define DISK_LEAF_NODE_LEVEL  1\t \n\n \n#define B_BLK_HEAD(bh)\t\t\t((struct block_head *)((bh)->b_data))\n \n#define B_NR_ITEMS(bh)\t\t\t(blkh_nr_item(B_BLK_HEAD(bh)))\n#define B_LEVEL(bh)\t\t\t(blkh_level(B_BLK_HEAD(bh)))\n#define B_FREE_SPACE(bh)\t\t(blkh_free_space(B_BLK_HEAD(bh)))\n\n#define PUT_B_NR_ITEMS(bh, val)\t\tdo { set_blkh_nr_item(B_BLK_HEAD(bh), val); } while (0)\n#define PUT_B_LEVEL(bh, val)\t\tdo { set_blkh_level(B_BLK_HEAD(bh), val); } while (0)\n#define PUT_B_FREE_SPACE(bh, val)\tdo { set_blkh_free_space(B_BLK_HEAD(bh), val); } while (0)\n\n \n#define B_PRIGHT_DELIM_KEY(bh)\t\t(&(blk_right_delim_key(B_BLK_HEAD(bh))))\n\n \n#define B_IS_ITEMS_LEVEL(bh)\t\t(B_LEVEL(bh) == DISK_LEAF_NODE_LEVEL)\n\n \n#define B_IS_KEYS_LEVEL(bh)      (B_LEVEL(bh) > DISK_LEAF_NODE_LEVEL \\\n\t\t\t\t\t    && B_LEVEL(bh) <= MAX_HEIGHT)\n\n \n\n \nstruct stat_data_v1 {\n\t__le16 sd_mode;\t\t \n\t__le16 sd_nlink;\t \n\t__le16 sd_uid;\t\t \n\t__le16 sd_gid;\t\t \n\t__le32 sd_size;\t\t \n\t__le32 sd_atime;\t \n\t__le32 sd_mtime;\t \n\n\t \n\t__le32 sd_ctime;\n\tunion {\n\t\t__le32 sd_rdev;\n\t\t__le32 sd_blocks;\t \n\t} __attribute__ ((__packed__)) u;\n\n\t \n\t__le32 sd_first_direct_byte;\n} __attribute__ ((__packed__));\n\n#define SD_V1_SIZE              (sizeof(struct stat_data_v1))\n#define stat_data_v1(ih)        (ih_version (ih) == KEY_FORMAT_3_5)\n#define sd_v1_mode(sdp)         (le16_to_cpu((sdp)->sd_mode))\n#define set_sd_v1_mode(sdp,v)   ((sdp)->sd_mode = cpu_to_le16(v))\n#define sd_v1_nlink(sdp)        (le16_to_cpu((sdp)->sd_nlink))\n#define set_sd_v1_nlink(sdp,v)  ((sdp)->sd_nlink = cpu_to_le16(v))\n#define sd_v1_uid(sdp)          (le16_to_cpu((sdp)->sd_uid))\n#define set_sd_v1_uid(sdp,v)    ((sdp)->sd_uid = cpu_to_le16(v))\n#define sd_v1_gid(sdp)          (le16_to_cpu((sdp)->sd_gid))\n#define set_sd_v1_gid(sdp,v)    ((sdp)->sd_gid = cpu_to_le16(v))\n#define sd_v1_size(sdp)         (le32_to_cpu((sdp)->sd_size))\n#define set_sd_v1_size(sdp,v)   ((sdp)->sd_size = cpu_to_le32(v))\n#define sd_v1_atime(sdp)        (le32_to_cpu((sdp)->sd_atime))\n#define set_sd_v1_atime(sdp,v)  ((sdp)->sd_atime = cpu_to_le32(v))\n#define sd_v1_mtime(sdp)        (le32_to_cpu((sdp)->sd_mtime))\n#define set_sd_v1_mtime(sdp,v)  ((sdp)->sd_mtime = cpu_to_le32(v))\n#define sd_v1_ctime(sdp)        (le32_to_cpu((sdp)->sd_ctime))\n#define set_sd_v1_ctime(sdp,v)  ((sdp)->sd_ctime = cpu_to_le32(v))\n#define sd_v1_rdev(sdp)         (le32_to_cpu((sdp)->u.sd_rdev))\n#define set_sd_v1_rdev(sdp,v)   ((sdp)->u.sd_rdev = cpu_to_le32(v))\n#define sd_v1_blocks(sdp)       (le32_to_cpu((sdp)->u.sd_blocks))\n#define set_sd_v1_blocks(sdp,v) ((sdp)->u.sd_blocks = cpu_to_le32(v))\n#define sd_v1_first_direct_byte(sdp) \\\n                                (le32_to_cpu((sdp)->sd_first_direct_byte))\n#define set_sd_v1_first_direct_byte(sdp,v) \\\n                                ((sdp)->sd_first_direct_byte = cpu_to_le32(v))\n\n \n\n \n#define REISERFS_IMMUTABLE_FL FS_IMMUTABLE_FL\n#define REISERFS_APPEND_FL    FS_APPEND_FL\n#define REISERFS_SYNC_FL      FS_SYNC_FL\n#define REISERFS_NOATIME_FL   FS_NOATIME_FL\n#define REISERFS_NODUMP_FL    FS_NODUMP_FL\n#define REISERFS_SECRM_FL     FS_SECRM_FL\n#define REISERFS_UNRM_FL      FS_UNRM_FL\n#define REISERFS_COMPR_FL     FS_COMPR_FL\n#define REISERFS_NOTAIL_FL    FS_NOTAIL_FL\n\n \n#define REISERFS_INHERIT_MASK ( REISERFS_IMMUTABLE_FL |\t\\\n\t\t\t\tREISERFS_SYNC_FL |\t\\\n\t\t\t\tREISERFS_NOATIME_FL |\t\\\n\t\t\t\tREISERFS_NODUMP_FL |\t\\\n\t\t\t\tREISERFS_SECRM_FL |\t\\\n\t\t\t\tREISERFS_COMPR_FL |\t\\\n\t\t\t\tREISERFS_NOTAIL_FL )\n\n \nstruct stat_data {\n\t__le16 sd_mode;\t\t \n\t__le16 sd_attrs;\t \n\t__le32 sd_nlink;\t \n\t__le64 sd_size;\t\t \n\t__le32 sd_uid;\t\t \n\t__le32 sd_gid;\t\t \n\t__le32 sd_atime;\t \n\t__le32 sd_mtime;\t \n\n\t \n\t__le32 sd_ctime;\n\t__le32 sd_blocks;\n\tunion {\n\t\t__le32 sd_rdev;\n\t\t__le32 sd_generation;\n\t} __attribute__ ((__packed__)) u;\n} __attribute__ ((__packed__));\n\n \n#define SD_SIZE (sizeof(struct stat_data))\n#define SD_V2_SIZE              SD_SIZE\n#define stat_data_v2(ih)        (ih_version (ih) == KEY_FORMAT_3_6)\n#define sd_v2_mode(sdp)         (le16_to_cpu((sdp)->sd_mode))\n#define set_sd_v2_mode(sdp,v)   ((sdp)->sd_mode = cpu_to_le16(v))\n \n \n#define sd_v2_nlink(sdp)        (le32_to_cpu((sdp)->sd_nlink))\n#define set_sd_v2_nlink(sdp,v)  ((sdp)->sd_nlink = cpu_to_le32(v))\n#define sd_v2_size(sdp)         (le64_to_cpu((sdp)->sd_size))\n#define set_sd_v2_size(sdp,v)   ((sdp)->sd_size = cpu_to_le64(v))\n#define sd_v2_uid(sdp)          (le32_to_cpu((sdp)->sd_uid))\n#define set_sd_v2_uid(sdp,v)    ((sdp)->sd_uid = cpu_to_le32(v))\n#define sd_v2_gid(sdp)          (le32_to_cpu((sdp)->sd_gid))\n#define set_sd_v2_gid(sdp,v)    ((sdp)->sd_gid = cpu_to_le32(v))\n#define sd_v2_atime(sdp)        (le32_to_cpu((sdp)->sd_atime))\n#define set_sd_v2_atime(sdp,v)  ((sdp)->sd_atime = cpu_to_le32(v))\n#define sd_v2_mtime(sdp)        (le32_to_cpu((sdp)->sd_mtime))\n#define set_sd_v2_mtime(sdp,v)  ((sdp)->sd_mtime = cpu_to_le32(v))\n#define sd_v2_ctime(sdp)        (le32_to_cpu((sdp)->sd_ctime))\n#define set_sd_v2_ctime(sdp,v)  ((sdp)->sd_ctime = cpu_to_le32(v))\n#define sd_v2_blocks(sdp)       (le32_to_cpu((sdp)->sd_blocks))\n#define set_sd_v2_blocks(sdp,v) ((sdp)->sd_blocks = cpu_to_le32(v))\n#define sd_v2_rdev(sdp)         (le32_to_cpu((sdp)->u.sd_rdev))\n#define set_sd_v2_rdev(sdp,v)   ((sdp)->u.sd_rdev = cpu_to_le32(v))\n#define sd_v2_generation(sdp)   (le32_to_cpu((sdp)->u.sd_generation))\n#define set_sd_v2_generation(sdp,v) ((sdp)->u.sd_generation = cpu_to_le32(v))\n#define sd_v2_attrs(sdp)         (le16_to_cpu((sdp)->sd_attrs))\n#define set_sd_v2_attrs(sdp,v)   ((sdp)->sd_attrs = cpu_to_le16(v))\n\n \n \n#define SD_OFFSET  0\n#define SD_UNIQUENESS 0\n#define DOT_OFFSET 1\n#define DOT_DOT_OFFSET 2\n#define DIRENTRY_UNIQUENESS 500\n\n#define FIRST_ITEM_OFFSET 1\n\n \n\n \n\nstruct reiserfs_de_head {\n\t__le32 deh_offset;\t \n\n\t \n\t__le32 deh_dir_id;\n\n\t \n\t__le32 deh_objectid;\n\t__le16 deh_location;\t \n\n\t \n\t__le16 deh_state;\n} __attribute__ ((__packed__));\n#define DEH_SIZE                  sizeof(struct reiserfs_de_head)\n#define deh_offset(p_deh)         (le32_to_cpu((p_deh)->deh_offset))\n#define deh_dir_id(p_deh)         (le32_to_cpu((p_deh)->deh_dir_id))\n#define deh_objectid(p_deh)       (le32_to_cpu((p_deh)->deh_objectid))\n#define deh_location(p_deh)       (le16_to_cpu((p_deh)->deh_location))\n#define deh_state(p_deh)          (le16_to_cpu((p_deh)->deh_state))\n\n#define put_deh_offset(p_deh,v)   ((p_deh)->deh_offset = cpu_to_le32((v)))\n#define put_deh_dir_id(p_deh,v)   ((p_deh)->deh_dir_id = cpu_to_le32((v)))\n#define put_deh_objectid(p_deh,v) ((p_deh)->deh_objectid = cpu_to_le32((v)))\n#define put_deh_location(p_deh,v) ((p_deh)->deh_location = cpu_to_le16((v)))\n#define put_deh_state(p_deh,v)    ((p_deh)->deh_state = cpu_to_le16((v)))\n\n \n#define EMPTY_DIR_SIZE \\\n(DEH_SIZE * 2 + ROUND_UP (sizeof(\".\") - 1) + ROUND_UP (sizeof(\"..\") - 1))\n\n \n#define EMPTY_DIR_SIZE_V1 (DEH_SIZE * 2 + 3)\n\n#define DEH_Statdata 0\t\t \n#define DEH_Visible 2\n\n \n#if BITS_PER_LONG == 64 || defined(__s390__) || defined(__hppa__)\n#   define ADDR_UNALIGNED_BITS  (3)\n#endif\n\n \n#ifdef ADDR_UNALIGNED_BITS\n\n#   define aligned_address(addr)           ((void *)((long)(addr) & ~((1UL << ADDR_UNALIGNED_BITS) - 1)))\n#   define unaligned_offset(addr)          (((int)((long)(addr) & ((1 << ADDR_UNALIGNED_BITS) - 1))) << 3)\n\n#   define set_bit_unaligned(nr, addr)\t\\\n\t__test_and_set_bit_le((nr) + unaligned_offset(addr), aligned_address(addr))\n#   define clear_bit_unaligned(nr, addr)\t\\\n\t__test_and_clear_bit_le((nr) + unaligned_offset(addr), aligned_address(addr))\n#   define test_bit_unaligned(nr, addr)\t\\\n\ttest_bit_le((nr) + unaligned_offset(addr), aligned_address(addr))\n\n#else\n\n#   define set_bit_unaligned(nr, addr)\t__test_and_set_bit_le(nr, addr)\n#   define clear_bit_unaligned(nr, addr)\t__test_and_clear_bit_le(nr, addr)\n#   define test_bit_unaligned(nr, addr)\ttest_bit_le(nr, addr)\n\n#endif\n\n#define mark_de_with_sd(deh)        set_bit_unaligned (DEH_Statdata, &((deh)->deh_state))\n#define mark_de_without_sd(deh)     clear_bit_unaligned (DEH_Statdata, &((deh)->deh_state))\n#define mark_de_visible(deh)\t    set_bit_unaligned (DEH_Visible, &((deh)->deh_state))\n#define mark_de_hidden(deh)\t    clear_bit_unaligned (DEH_Visible, &((deh)->deh_state))\n\n#define de_with_sd(deh)\t\t    test_bit_unaligned (DEH_Statdata, &((deh)->deh_state))\n#define de_visible(deh)\t    \t    test_bit_unaligned (DEH_Visible, &((deh)->deh_state))\n#define de_hidden(deh)\t    \t    !test_bit_unaligned (DEH_Visible, &((deh)->deh_state))\n\nextern void make_empty_dir_item_v1(char *body, __le32 dirid, __le32 objid,\n\t\t\t\t   __le32 par_dirid, __le32 par_objid);\nextern void make_empty_dir_item(char *body, __le32 dirid, __le32 objid,\n\t\t\t\t__le32 par_dirid, __le32 par_objid);\n\n \n#define REISERFS_MAX_NAME(block_size) 255\n\n \nstruct reiserfs_dir_entry {\n\tstruct buffer_head *de_bh;\n\tint de_item_num;\n\tstruct item_head *de_ih;\n\tint de_entry_num;\n\tstruct reiserfs_de_head *de_deh;\n\tint de_entrylen;\n\tint de_namelen;\n\tchar *de_name;\n\tunsigned long *de_gen_number_bit_string;\n\n\t__u32 de_dir_id;\n\t__u32 de_objectid;\n\n\tstruct cpu_key de_entry_key;\n};\n\n \n\n \n#define B_I_DEH_ENTRY_FILE_NAME(bh, ih, deh) \\\n\t\t\t\t(ih_item_body(bh, ih) + deh_location(deh))\n\n \n#define I_DEH_N_ENTRY_FILE_NAME_LENGTH(ih,deh,entry_num) \\\n(I_DEH_N_ENTRY_LENGTH (ih, deh, entry_num) - (de_with_sd (deh) ? SD_SIZE : 0))\n\n \n#define GET_HASH_VALUE(offset) ((offset) & 0x7fffff80LL)\n \n#define GET_GENERATION_NUMBER(offset) ((offset) & 0x7fLL)\n#define MAX_GENERATION_NUMBER  127\n\n#define SET_GENERATION_NUMBER(offset,gen_number) (GET_HASH_VALUE(offset)|(gen_number))\n\n \n\n \n \nstruct disk_child {\n\t__le32 dc_block_number;\t \n\t__le16 dc_size;\t\t \n\t__le16 dc_reserved;\n};\n\n#define DC_SIZE (sizeof(struct disk_child))\n#define dc_block_number(dc_p)\t(le32_to_cpu((dc_p)->dc_block_number))\n#define dc_size(dc_p)\t\t(le16_to_cpu((dc_p)->dc_size))\n#define put_dc_block_number(dc_p, val)   do { (dc_p)->dc_block_number = cpu_to_le32(val); } while(0)\n#define put_dc_size(dc_p, val)   do { (dc_p)->dc_size = cpu_to_le16(val); } while(0)\n\n \n#define B_N_CHILD(bh, n_pos)  ((struct disk_child *)\\\n((bh)->b_data + BLKH_SIZE + B_NR_ITEMS(bh) * KEY_SIZE + DC_SIZE * (n_pos)))\n\n \n#define B_N_CHILD_NUM(bh, n_pos) (dc_block_number(B_N_CHILD(bh, n_pos)))\n#define PUT_B_N_CHILD_NUM(bh, n_pos, val) \\\n\t\t\t\t(put_dc_block_number(B_N_CHILD(bh, n_pos), val))\n\n  \n  \n#define MAX_CHILD_SIZE(bh) ((int)( (bh)->b_size - BLKH_SIZE ))\n\n \n#define B_CHILD_SIZE(cur) (MAX_CHILD_SIZE(cur)-(B_FREE_SPACE(cur)))\n\n \n#define MAX_NR_KEY(bh) ( (MAX_CHILD_SIZE(bh)-DC_SIZE)/(KEY_SIZE+DC_SIZE) )\n#define MIN_NR_KEY(bh)    (MAX_NR_KEY(bh)/2)\n\n \n\n \n\nstruct path_element {\n\t \n\tstruct buffer_head *pe_buffer;\n\t \n\tint pe_position;\n};\n\n \n#define MAX_HEIGHT 5\n\n \n#define EXTENDED_MAX_HEIGHT         7\n\n \n#define FIRST_PATH_ELEMENT_OFFSET   2\n\n \n#define ILLEGAL_PATH_ELEMENT_OFFSET 1\n\n \n#define MAX_FEB_SIZE 6\n\n \n\n#define PATH_READA\t0x1\t \n#define PATH_READA_BACK 0x2\t \n\nstruct treepath {\n\tint path_length;\t \n\tint reada;\n\t \n\tstruct path_element path_elements[EXTENDED_MAX_HEIGHT];\n\tint pos_in_item;\n};\n\n#define pos_in_item(path) ((path)->pos_in_item)\n\n#define INITIALIZE_PATH(var) \\\nstruct treepath var = {.path_length = ILLEGAL_PATH_ELEMENT_OFFSET, .reada = 0,}\n\n \n#define PATH_OFFSET_PELEMENT(path, n_offset)  ((path)->path_elements + (n_offset))\n\n \n#define PATH_OFFSET_PBUFFER(path, n_offset)   (PATH_OFFSET_PELEMENT(path, n_offset)->pe_buffer)\n\n \n#define PATH_OFFSET_POSITION(path, n_offset) (PATH_OFFSET_PELEMENT(path, n_offset)->pe_position)\n\n#define PATH_PLAST_BUFFER(path) (PATH_OFFSET_PBUFFER((path), (path)->path_length))\n\n \n#define PATH_LAST_POSITION(path) (PATH_OFFSET_POSITION((path), (path)->path_length))\n\n \n\n \n#define PATH_H_PBUFFER(path, h) \\\n\t\t\tPATH_OFFSET_PBUFFER(path, path->path_length - (h))\n\n \n#define PATH_H_PPARENT(path, h) PATH_H_PBUFFER(path, (h) + 1)\n\n#define PATH_H_POSITION(path, h) \\\n\t\t\tPATH_OFFSET_POSITION(path, path->path_length - (h))\n\n \n#define PATH_H_B_ITEM_ORDER(path, h) PATH_H_POSITION(path, h + 1)\n\n#define PATH_H_PATH_OFFSET(path, n_h) ((path)->path_length - (n_h))\n\nstatic inline void *reiserfs_node_data(const struct buffer_head *bh)\n{\n\treturn bh->b_data + sizeof(struct block_head);\n}\n\n \nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}\n\n \nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}\n\n \nstatic inline struct reiserfs_key *leaf_key(const struct buffer_head *bh,\n\t\t\t\t\t    int item_num)\n{\n\treturn &item_head(bh, item_num)->ih_key;\n}\n\nstatic inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}\n\n \nstatic inline void *item_body(const struct buffer_head *bh, int item_num)\n{\n\treturn ih_item_body(bh, item_head(bh, item_num));\n}\n\nstatic inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}\n\nstatic inline void *tp_item_body(const struct treepath *path)\n{\n\treturn item_body(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}\n\n#define get_last_bh(path) PATH_PLAST_BUFFER(path)\n#define get_item_pos(path) PATH_LAST_POSITION(path)\n#define item_moved(ih,path) comp_items(ih, path)\n#define path_changed(ih,path) comp_items (ih, path)\n\n \n  \n#define B_I_DEH(bh, ih) ((struct reiserfs_de_head *)(ih_item_body(bh, ih)))\n\n \nstatic inline int entry_length(const struct buffer_head *bh,\n\t\t\t       const struct item_head *ih, int pos_in_item)\n{\n\tstruct reiserfs_de_head *deh;\n\n\tdeh = B_I_DEH(bh, ih) + pos_in_item;\n\tif (pos_in_item)\n\t\treturn deh_location(deh - 1) - deh_location(deh);\n\n\treturn ih_item_len(ih) - deh_location(deh);\n}\n\n \n\n \n#define UNFM_P_SIZE (sizeof(unp_t))\n#define UNFM_P_SHIFT 2\n\n \n#define INODE_PKEY(inode) ((struct reiserfs_key *)(REISERFS_I(inode)->i_key))\n\n#define MAX_UL_INT 0xffffffff\n#define MAX_INT    0x7ffffff\n#define MAX_US_INT 0xffff\n\n\nstatic inline loff_t max_reiserfs_offset(struct inode *inode)\n{\n\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5)\n\t\treturn (loff_t) U32_MAX;\n\n\treturn (loff_t) ((~(__u64) 0) >> 4);\n}\n\n#define MAX_KEY_OBJECTID\tMAX_UL_INT\n\n#define MAX_B_NUM  MAX_UL_INT\n#define MAX_FC_NUM MAX_US_INT\n\n \n#define REISERFS_LINK_MAX (MAX_US_INT - 1000)\n\n \n#define REISERFS_KERNEL_MEM\t\t0\t \n#define REISERFS_USER_MEM\t\t1\t \n\n#define fs_generation(s) (REISERFS_SB(s)->s_generation_counter)\n#define get_generation(s) atomic_read (&fs_generation(s))\n#define FILESYSTEM_CHANGED_TB(tb)  (get_generation((tb)->tb_sb) != (tb)->fs_gen)\n#define __fs_changed(gen,s) (gen != get_generation (s))\n#define fs_changed(gen,s)\t\t\\\n({\t\t\t\t\t\\\n\treiserfs_cond_resched(s);\t\\\n\t__fs_changed(gen, s);\t\t\\\n})\n\n \n\n#define VI_TYPE_LEFT_MERGEABLE 1\n#define VI_TYPE_RIGHT_MERGEABLE 2\n\n \nstruct virtual_item {\n\tint vi_index;\t\t \n\tunsigned short vi_type;\t \n\n\t \n\tunsigned short vi_item_len;\n\n\tstruct item_head *vi_ih;\n\tconst char *vi_item;\t \n\tconst void *vi_new_data;\t \n\tvoid *vi_uarea;\t\t \n};\n\nstruct virtual_node {\n\t \n\tchar *vn_free_ptr;\n\n\tunsigned short vn_nr_item;\t \n\n\t \n\tshort vn_size;\n\n\t \n\tshort vn_mode;\n\n\tshort vn_affected_item_num;\n\tshort vn_pos_in_item;\n\n\t \n\tstruct item_head *vn_ins_ih;\n\tconst void *vn_data;\n\n\t \n\tstruct virtual_item *vn_vi;\n};\n\n \nstruct direntry_uarea {\n\tint flags;\n\t__u16 entry_count;\n\t__u16 entry_sizes[];\n} __attribute__ ((__packed__));\n\n \n\n \n\n \n#define MAX_FREE_BLOCK 7\n\n \n#define MAX_AMOUNT_NEEDED 2\n\n \nstruct tree_balance {\n\tint tb_mode;\n\tint need_balance_dirty;\n\tstruct super_block *tb_sb;\n\tstruct reiserfs_transaction_handle *transaction_handle;\n\tstruct treepath *tb_path;\n\n\t \n\tstruct buffer_head *L[MAX_HEIGHT];\n\n\t \n\tstruct buffer_head *R[MAX_HEIGHT];\n\n\t \n\tstruct buffer_head *FL[MAX_HEIGHT];\n\n\t \n\tstruct buffer_head *FR[MAX_HEIGHT];\n\t \n\tstruct buffer_head *CFL[MAX_HEIGHT];\n\n\t \n\tstruct buffer_head *CFR[MAX_HEIGHT];\n\n\t \n\tstruct buffer_head *FEB[MAX_FEB_SIZE];\n\tstruct buffer_head *used[MAX_FEB_SIZE];\n\tstruct buffer_head *thrown[MAX_FEB_SIZE];\n\n\t \n\tint lnum[MAX_HEIGHT];\n\n\t \n\tint rnum[MAX_HEIGHT];\n\n\t \n\tint lkey[MAX_HEIGHT];\n\n\t \n\tint rkey[MAX_HEIGHT];\n\n\t \n\tint insert_size[MAX_HEIGHT];\n\n\t \n\tint blknum[MAX_HEIGHT];\n\n\t \n\n\t \n\tint cur_blknum;\n\n\t \n\tint s0num;\n\n\t \n\tint lbytes;\n\n\t \n\tint rbytes;\n\n\n\t \n\tint item_pos;\n\n\t \n\tstruct buffer_head *S_new[2];\n\n\t \n\tint snum[2];\n\n\t \n\tint sbytes[2];\n\n\tint pos_in_item;\n\tint zeroes_num;\n\n\t \n\tstruct buffer_head *buf_to_free[MAX_FREE_BLOCK];\n\n\t \n\tchar *vn_buf;\n\n\tint vn_buf_size;\t \n\n\t \n\tstruct virtual_node *tb_vn;\n\n\t \n\tint fs_gen;\n\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\t \n\tstruct in_core_key key;\n#endif\n};\n\n \n\n \n#define M_INSERT\t'i'\n \n#define M_PASTE\t\t'p'\n \n#define M_DELETE\t'd'\n \n#define M_CUT\t\t'c'\n\n \n#define M_INTERNAL\t'n'\n\n \n#define M_SKIP_BALANCING\t\t's'\n#define M_CONVERT\t'v'\n\n \n#define LEAF_FROM_S_TO_L 0\n#define LEAF_FROM_S_TO_R 1\n#define LEAF_FROM_R_TO_L 2\n#define LEAF_FROM_L_TO_R 3\n#define LEAF_FROM_S_TO_SNEW 4\n\n#define FIRST_TO_LAST 0\n#define LAST_TO_FIRST 1\n\n \nstruct buffer_info {\n\tstruct tree_balance *tb;\n\tstruct buffer_head *bi_bh;\n\tstruct buffer_head *bi_parent;\n\tint bi_position;\n};\n\nstatic inline struct super_block *sb_from_tb(struct tree_balance *tb)\n{\n\treturn tb ? tb->tb_sb : NULL;\n}\n\nstatic inline struct super_block *sb_from_bi(struct buffer_info *bi)\n{\n\treturn bi ? sb_from_tb(bi->tb) : NULL;\n}\n\n \n\nstruct item_operations {\n\tint (*bytes_number) (struct item_head * ih, int block_size);\n\tvoid (*decrement_key) (struct cpu_key *);\n\tint (*is_left_mergeable) (struct reiserfs_key * ih,\n\t\t\t\t  unsigned long bsize);\n\tvoid (*print_item) (struct item_head *, char *item);\n\tvoid (*check_item) (struct item_head *, char *item);\n\n\tint (*create_vi) (struct virtual_node * vn, struct virtual_item * vi,\n\t\t\t  int is_affected, int insert_size);\n\tint (*check_left) (struct virtual_item * vi, int free,\n\t\t\t   int start_skip, int end_skip);\n\tint (*check_right) (struct virtual_item * vi, int free);\n\tint (*part_size) (struct virtual_item * vi, int from, int to);\n\tint (*unit_num) (struct virtual_item * vi);\n\tvoid (*print_vi) (struct virtual_item * vi);\n};\n\nextern struct item_operations *item_ops[TYPE_ANY + 1];\n\n#define op_bytes_number(ih,bsize)                    item_ops[le_ih_k_type (ih)]->bytes_number (ih, bsize)\n#define op_is_left_mergeable(key,bsize)              item_ops[le_key_k_type (le_key_version (key), key)]->is_left_mergeable (key, bsize)\n#define op_print_item(ih,item)                       item_ops[le_ih_k_type (ih)]->print_item (ih, item)\n#define op_check_item(ih,item)                       item_ops[le_ih_k_type (ih)]->check_item (ih, item)\n#define op_create_vi(vn,vi,is_affected,insert_size)  item_ops[le_ih_k_type ((vi)->vi_ih)]->create_vi (vn,vi,is_affected,insert_size)\n#define op_check_left(vi,free,start_skip,end_skip) item_ops[(vi)->vi_index]->check_left (vi, free, start_skip, end_skip)\n#define op_check_right(vi,free)                      item_ops[(vi)->vi_index]->check_right (vi, free)\n#define op_part_size(vi,from,to)                     item_ops[(vi)->vi_index]->part_size (vi, from, to)\n#define op_unit_num(vi)\t\t\t\t     item_ops[(vi)->vi_index]->unit_num (vi)\n#define op_print_vi(vi)                              item_ops[(vi)->vi_index]->print_vi (vi)\n\n#define COMP_SHORT_KEYS comp_short_keys\n\n \n#define I_UNFM_NUM(ih)\t(ih_item_len(ih) / UNFM_P_SIZE)\n\n \n#define I_POS_UNFM_SIZE(ih,pos,size) (((pos) == I_UNFM_NUM(ih) - 1 ) ? (size) - ih_free_space(ih) : (size))\n\n \n\n \n\n \n#define B_I_STAT_DATA(bh, ih) ( (struct stat_data * )((bh)->b_data + ih_location(ih)) )\n\n \n#define MAX_DIRECT_ITEM_LEN(size) ((size) - BLKH_SIZE - 2*IH_SIZE - SD_SIZE - UNFM_P_SIZE)\n\n \n#define B_I_POS_UNFM_POINTER(bh, ih, pos)\t\t\t\t\\\n\tle32_to_cpu(*(((unp_t *)ih_item_body(bh, ih)) + (pos)))\n#define PUT_B_I_POS_UNFM_POINTER(bh, ih, pos, val)\t\t\t\\\n\t(*(((unp_t *)ih_item_body(bh, ih)) + (pos)) = cpu_to_le32(val))\n\nstruct reiserfs_iget_args {\n\t__u32 objectid;\n\t__u32 dirid;\n};\n\n \n\n#define get_journal_desc_magic(bh) (bh->b_data + bh->b_size - 12)\n\n#define journal_trans_half(blocksize) \\\n\t((blocksize - sizeof(struct reiserfs_journal_desc) - 12) / sizeof(__u32))\n\n \n\n \nstruct reiserfs_journal_desc {\n\t__le32 j_trans_id;\t \n\n\t \n\t__le32 j_len;\n\n\t__le32 j_mount_id;\t \n\t__le32 j_realblock[];\t \n};\n\n#define get_desc_trans_id(d)   le32_to_cpu((d)->j_trans_id)\n#define get_desc_trans_len(d)  le32_to_cpu((d)->j_len)\n#define get_desc_mount_id(d)   le32_to_cpu((d)->j_mount_id)\n\n#define set_desc_trans_id(d,val)       do { (d)->j_trans_id = cpu_to_le32 (val); } while (0)\n#define set_desc_trans_len(d,val)      do { (d)->j_len = cpu_to_le32 (val); } while (0)\n#define set_desc_mount_id(d,val)       do { (d)->j_mount_id = cpu_to_le32 (val); } while (0)\n\n \nstruct reiserfs_journal_commit {\n\t__le32 j_trans_id;\t \n\t__le32 j_len;\t\t \n\t__le32 j_realblock[];\t \n};\n\n#define get_commit_trans_id(c) le32_to_cpu((c)->j_trans_id)\n#define get_commit_trans_len(c)        le32_to_cpu((c)->j_len)\n#define get_commit_mount_id(c) le32_to_cpu((c)->j_mount_id)\n\n#define set_commit_trans_id(c,val)     do { (c)->j_trans_id = cpu_to_le32 (val); } while (0)\n#define set_commit_trans_len(c,val)    do { (c)->j_len = cpu_to_le32 (val); } while (0)\n\n \nstruct reiserfs_journal_header {\n\t \n\t__le32 j_last_flush_trans_id;\n\n\t \n\t__le32 j_first_unflushed_offset;\n\n\t__le32 j_mount_id;\n\t  struct journal_params jh_journal;\n};\n\n \n#define JOURNAL_BLOCK_COUNT 8192\t \n\n \n#define JOURNAL_TRANS_MAX_DEFAULT 1024\n#define JOURNAL_TRANS_MIN_DEFAULT 256\n\n \n#define JOURNAL_MAX_BATCH_DEFAULT   900\n#define JOURNAL_MIN_RATIO 2\n#define JOURNAL_MAX_COMMIT_AGE 30\n#define JOURNAL_MAX_TRANS_AGE 30\n#define JOURNAL_PER_BALANCE_CNT (3 * (MAX_HEIGHT-2) + 9)\n#define JOURNAL_BLOCKS_PER_OBJECT(sb)  (JOURNAL_PER_BALANCE_CNT * 3 + \\\n\t\t\t\t\t 2 * (REISERFS_QUOTA_INIT_BLOCKS(sb) + \\\n\t\t\t\t\t      REISERFS_QUOTA_TRANS_BLOCKS(sb)))\n\n#ifdef CONFIG_QUOTA\n#define REISERFS_QUOTA_OPTS ((1 << REISERFS_USRQUOTA) | (1 << REISERFS_GRPQUOTA))\n \n#define REISERFS_QUOTA_TRANS_BLOCKS(s) (REISERFS_SB(s)->s_mount_opt & REISERFS_QUOTA_OPTS ? 2 : 0)\n \n#define REISERFS_QUOTA_INIT_BLOCKS(s) (REISERFS_SB(s)->s_mount_opt & REISERFS_QUOTA_OPTS ? \\\n(DQUOT_INIT_ALLOC*(JOURNAL_PER_BALANCE_CNT+2)+DQUOT_INIT_REWRITE+1) : 0)\n \n#define REISERFS_QUOTA_DEL_BLOCKS(s) (REISERFS_SB(s)->s_mount_opt & REISERFS_QUOTA_OPTS ? \\\n(DQUOT_DEL_ALLOC*(JOURNAL_PER_BALANCE_CNT+2)+DQUOT_DEL_REWRITE+1) : 0)\n#else\n#define REISERFS_QUOTA_TRANS_BLOCKS(s) 0\n#define REISERFS_QUOTA_INIT_BLOCKS(s) 0\n#define REISERFS_QUOTA_DEL_BLOCKS(s) 0\n#endif\n\n \n#define REISERFS_MIN_BITMAP_NODES 10\n#define REISERFS_MAX_BITMAP_NODES 100\n\n \n#define JBH_HASH_SHIFT 13\n#define JBH_HASH_MASK 8191\n\n#define _jhashfn(sb,block)\t\\\n\t(((unsigned long)sb>>L1_CACHE_SHIFT) ^ \\\n\t (((block)<<(JBH_HASH_SHIFT - 6)) ^ ((block) >> 13) ^ ((block) << (JBH_HASH_SHIFT - 12))))\n#define journal_hash(t,sb,block) ((t)[_jhashfn((sb),(block)) & JBH_HASH_MASK])\n\n \n#define journal_find_get_block(s, block) __find_get_block(SB_JOURNAL(s)->j_dev_bd, block, s->s_blocksize)\n#define journal_getblk(s, block) __getblk(SB_JOURNAL(s)->j_dev_bd, block, s->s_blocksize)\n#define journal_bread(s, block) __bread(SB_JOURNAL(s)->j_dev_bd, block, s->s_blocksize)\n\nenum reiserfs_bh_state_bits {\n\tBH_JDirty = BH_PrivateStart,\t \n\tBH_JDirty_wait,\n\t \n\tBH_JNew,\n\tBH_JPrepared,\n\tBH_JRestore_dirty,\n\tBH_JTest,\t\t \n};\n\nBUFFER_FNS(JDirty, journaled);\nTAS_BUFFER_FNS(JDirty, journaled);\nBUFFER_FNS(JDirty_wait, journal_dirty);\nTAS_BUFFER_FNS(JDirty_wait, journal_dirty);\nBUFFER_FNS(JNew, journal_new);\nTAS_BUFFER_FNS(JNew, journal_new);\nBUFFER_FNS(JPrepared, journal_prepared);\nTAS_BUFFER_FNS(JPrepared, journal_prepared);\nBUFFER_FNS(JRestore_dirty, journal_restore_dirty);\nTAS_BUFFER_FNS(JRestore_dirty, journal_restore_dirty);\nBUFFER_FNS(JTest, journal_test);\nTAS_BUFFER_FNS(JTest, journal_test);\n\n \nstruct reiserfs_transaction_handle {\n\t \n\tstruct super_block *t_super;\n\n\tint t_refcount;\n\tint t_blocks_logged;\t \n\tint t_blocks_allocated;\t \n\n\t \n\tunsigned int t_trans_id;\n\n\tvoid *t_handle_save;\t \n\n\t \n\tunsigned displace_new_blocks:1;\n\n\tstruct list_head t_list;\n};\n\n \nstruct reiserfs_jh {\n\tstruct reiserfs_journal_list *jl;\n\tstruct buffer_head *bh;\n\tstruct list_head list;\n};\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\n\nstatic inline int reiserfs_file_data_log(struct inode *inode)\n{\n\tif (reiserfs_data_log(inode->i_sb) ||\n\t    (REISERFS_I(inode)->i_flags & i_data_log))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int reiserfs_transaction_running(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\tif (th && th->t_super == s)\n\t\treturn 1;\n\tif (th && th->t_super == NULL)\n\t\tBUG();\n\treturn 0;\n}\n\nstatic inline int reiserfs_transaction_free_space(struct reiserfs_transaction_handle *th)\n{\n\treturn th->t_blocks_allocated - th->t_blocks_logged;\n}\n\nstruct reiserfs_transaction_handle *reiserfs_persistent_transaction(struct\n\t\t\t\t\t\t\t\t    super_block\n\t\t\t\t\t\t\t\t    *,\n\t\t\t\t\t\t\t\t    int count);\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_page(struct inode *inode, struct page *page,\n\t\t\t unsigned from, unsigned to);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nvoid reiserfs_allow_writes(struct super_block *s);\nvoid reiserfs_check_lock_depth(struct super_block *s, char *caller);\nint reiserfs_prepare_for_journal(struct super_block *, struct buffer_head *bh,\n\t\t\t\t int wait);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint journal_init(struct super_block *, const char *j_dev_name, int old_format,\n\t\t unsigned int);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_mark_freed(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *, b_blocknr_t blocknr);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\nint reiserfs_in_journal(struct super_block *sb, unsigned int bmap_nr,\n\t\t\t int bit_nr, int searchall, b_blocknr_t *next);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nvoid reiserfs_abort_journal(struct super_block *sb, int errno);\nvoid reiserfs_abort(struct super_block *sb, int errno, const char *fmt, ...);\nint reiserfs_allocate_list_bitmaps(struct super_block *s,\n\t\t\t\t   struct reiserfs_list_bitmap *, unsigned int);\n\nvoid reiserfs_schedule_old_flush(struct super_block *s);\nvoid reiserfs_cancel_old_flush(struct super_block *s);\nvoid add_save_link(struct reiserfs_transaction_handle *th,\n\t\t   struct inode *inode, int truncate);\nint remove_save_link(struct inode *inode, int truncate);\n\n \n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nvoid reiserfs_release_objectid(struct reiserfs_transaction_handle *th,\n\t\t\t       __u32 objectid_to_release);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\n\n \nint B_IS_IN_TREE(const struct buffer_head *);\nextern void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from);\n\n \nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nextern void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from);\n\n \nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\n\n \nstatic inline int le_key_version(const struct reiserfs_key *key)\n{\n\tint type;\n\n\ttype = offset_v2_k_type(&(key->u.k_offset_v2));\n\tif (type != TYPE_DIRECT && type != TYPE_INDIRECT\n\t    && type != TYPE_DIRENTRY)\n\t\treturn KEY_FORMAT_3_5;\n\n\treturn KEY_FORMAT_3_6;\n\n}\n\nstatic inline void copy_key(struct reiserfs_key *to,\n\t\t\t    const struct reiserfs_key *from)\n{\n\tmemcpy(to, from, KEY_SIZE);\n}\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n#define search_item(s,key,path) search_by_key (s, key, path, DISK_LEAF_NODE_LEVEL)\nint search_for_position_by_key(struct super_block *sb,\n\t\t\t       const struct cpu_key *cpu_key,\n\t\t\t       struct treepath *search_path);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid decrement_counters_in_path(struct treepath *search_path);\nvoid pathrelse(struct treepath *search_path);\nint reiserfs_check_path(struct treepath *p);\nvoid pathrelse_and_restore(struct super_block *s, struct treepath *search_path);\n\nint reiserfs_insert_item(struct reiserfs_transaction_handle *th,\n\t\t\t struct treepath *path,\n\t\t\t const struct cpu_key *key,\n\t\t\t struct item_head *ih,\n\t\t\t struct inode *inode, const char *body);\n\nint reiserfs_paste_into_item(struct reiserfs_transaction_handle *th,\n\t\t\t     struct treepath *path,\n\t\t\t     const struct cpu_key *key,\n\t\t\t     struct inode *inode,\n\t\t\t     const char *body, int paste_size);\n\nint reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,\n\t\t\t   struct treepath *path,\n\t\t\t   struct cpu_key *key,\n\t\t\t   struct inode *inode,\n\t\t\t   struct page *page, loff_t new_file_size);\n\nint reiserfs_delete_item(struct reiserfs_transaction_handle *th,\n\t\t\t struct treepath *path,\n\t\t\t const struct cpu_key *key,\n\t\t\t struct inode *inode, struct buffer_head *un_bh);\n\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nint reiserfs_do_truncate(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode, struct page *,\n\t\t\t int update_timestamps);\n\n#define i_block_size(inode) ((inode)->i_sb->s_blocksize)\n#define file_size(inode) ((inode)->i_size)\n#define tail_size(inode) (file_size (inode) & (i_block_size (inode) - 1))\n\n#define tail_has_to_be_packed(inode) (have_large_tails ((inode)->i_sb)?\\\n!STORE_TAIL_IN_UNFM_S1(file_size (inode), tail_size(inode), inode->i_sb->s_blocksize):have_small_tails ((inode)->i_sb)?!STORE_TAIL_IN_UNFM_S2(file_size (inode), tail_size(inode), inode->i_sb->s_blocksize):0 )\n\nvoid padd_item(char *item, int total_length, int length);\n\n \n \n#define GET_BLOCK_NO_CREATE 0\t  \n#define GET_BLOCK_CREATE 1\t  \n#define GET_BLOCK_NO_HOLE 2\t  \n#define GET_BLOCK_READ_DIRECT 4\t  \n#define GET_BLOCK_NO_IMUX     8\t  \n#define GET_BLOCK_NO_DANGLE   16  \n\nvoid reiserfs_read_locked_inode(struct inode *inode,\n\t\t\t\tstruct reiserfs_iget_args *args);\nint reiserfs_find_actor(struct inode *inode, void *p);\nint reiserfs_init_locked_inode(struct inode *inode, void *p);\nvoid reiserfs_evict_inode(struct inode *inode);\nint reiserfs_write_inode(struct inode *inode, struct writeback_control *wbc);\nint reiserfs_get_block(struct inode *inode, sector_t block,\n\t\t       struct buffer_head *bh_result, int create);\nstruct dentry *reiserfs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t\t\t     int fh_len, int fh_type);\nstruct dentry *reiserfs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\t\t\t     int fh_len, int fh_type);\nint reiserfs_encode_fh(struct inode *inode, __u32 * data, int *lenp,\n\t\t       struct inode *parent);\n\nint reiserfs_truncate_file(struct inode *, int update_timestamps);\nvoid make_cpu_key(struct cpu_key *cpu_key, struct inode *inode, loff_t offset,\n\t\t  int type, int key_length);\nvoid make_le_item_head(struct item_head *ih, const struct cpu_key *key,\n\t\t       int version,\n\t\t       loff_t offset, int type, int length, int entry_count);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstruct reiserfs_security_handle;\nint reiserfs_new_inode(struct reiserfs_transaction_handle *th,\n\t\t       struct inode *dir, umode_t mode,\n\t\t       const char *symname, loff_t i_size,\n\t\t       struct dentry *dentry, struct inode *inode,\n\t\t       struct reiserfs_security_handle *security);\n\nvoid reiserfs_update_sd_size(struct reiserfs_transaction_handle *th,\n\t\t\t     struct inode *inode, loff_t size);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}\n\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\nint reiserfs_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t     struct iattr *attr);\n\nint __reiserfs_write_begin(struct page *page, unsigned from, unsigned len);\n\n \nvoid reiserfs_init_priv_inode(struct inode *inode);\nvoid set_de_name_and_namelen(struct reiserfs_dir_entry *de);\nint search_by_entry_key(struct super_block *sb, const struct cpu_key *key,\n\t\t\tstruct treepath *path, struct reiserfs_dir_entry *de);\nstruct dentry *reiserfs_get_parent(struct dentry *);\n\n#ifdef CONFIG_REISERFS_PROC_INFO\nint reiserfs_proc_info_init(struct super_block *sb);\nint reiserfs_proc_info_done(struct super_block *sb);\nint reiserfs_proc_info_global_init(void);\nint reiserfs_proc_info_global_done(void);\n\n#define PROC_EXP( e )   e\n\n#define __PINFO( sb ) REISERFS_SB(sb) -> s_proc_info_data\n#define PROC_INFO_MAX( sb, field, value )\t\t\t\t\t\t\t\t\\\n    __PINFO( sb ).field =\t\t\t\t\t\t\t\t\t\t\t\t\\\n        max( REISERFS_SB( sb ) -> s_proc_info_data.field, value )\n#define PROC_INFO_INC( sb, field ) ( ++ ( __PINFO( sb ).field ) )\n#define PROC_INFO_ADD( sb, field, val ) ( __PINFO( sb ).field += ( val ) )\n#define PROC_INFO_BH_STAT( sb, bh, level )\t\t\t\t\t\t\t\\\n    PROC_INFO_INC( sb, sbk_read_at[ ( level ) ] );\t\t\t\t\t\t\\\n    PROC_INFO_ADD( sb, free_at[ ( level ) ], B_FREE_SPACE( bh ) );\t\\\n    PROC_INFO_ADD( sb, items_at[ ( level ) ], B_NR_ITEMS( bh ) )\n#else\nstatic inline int reiserfs_proc_info_init(struct super_block *sb)\n{\n\treturn 0;\n}\n\nstatic inline int reiserfs_proc_info_done(struct super_block *sb)\n{\n\treturn 0;\n}\n\nstatic inline int reiserfs_proc_info_global_init(void)\n{\n\treturn 0;\n}\n\nstatic inline int reiserfs_proc_info_global_done(void)\n{\n\treturn 0;\n}\n\n#define PROC_EXP( e )\n#define VOID_V ( ( void ) 0 )\n#define PROC_INFO_MAX( sb, field, value ) VOID_V\n#define PROC_INFO_INC( sb, field ) VOID_V\n#define PROC_INFO_ADD( sb, field, val ) VOID_V\n#define PROC_INFO_BH_STAT(sb, bh, n_node_level) VOID_V\n#endif\n\n \nextern const struct inode_operations reiserfs_dir_inode_operations;\nextern const struct inode_operations reiserfs_symlink_inode_operations;\nextern const struct inode_operations reiserfs_special_inode_operations;\nextern const struct file_operations reiserfs_dir_operations;\nint reiserfs_readdir_inode(struct inode *, struct dir_context *);\n\n \nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\n\n \nextern const struct inode_operations reiserfs_file_inode_operations;\nextern const struct inode_operations reiserfs_priv_file_inode_operations;\nextern const struct file_operations reiserfs_file_operations;\nextern const struct address_space_operations reiserfs_address_space_operations;\n\n \n\nint fix_nodes(int n_op_mode, struct tree_balance *tb,\n\t      struct item_head *ins_ih, const void *);\nvoid unfix_nodes(struct tree_balance *);\n\n \nvoid __reiserfs_panic(struct super_block *s, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n    __attribute__ ((noreturn));\n#define reiserfs_panic(s, id, fmt, args...) \\\n\t__reiserfs_panic(s, id, __func__, fmt, ##args)\nvoid __reiserfs_error(struct super_block *s, const char *id,\n\t\t      const char *function, const char *fmt, ...);\n#define reiserfs_error(s, id, fmt, args...) \\\n\t __reiserfs_error(s, id, __func__, fmt, ##args)\nvoid reiserfs_info(struct super_block *s, const char *fmt, ...);\nvoid reiserfs_debug(struct super_block *s, int level, const char *fmt, ...);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid store_print_tb(struct tree_balance *tb);\nvoid print_cur_tb(char *mes);\nvoid print_de(struct reiserfs_dir_entry *de);\nvoid print_bi(struct buffer_info *bi, char *mes);\n#define PRINT_LEAF_ITEMS 1\t \n#define PRINT_DIRECTORY_ITEMS 2\t \n#define PRINT_DIRECT_ITEMS 4\t \nvoid print_block(struct buffer_head *bh, ...);\nvoid print_bmap(struct super_block *s, int silent);\nvoid print_bmap_block(int i, char *data, int size, int silent);\n \nvoid print_objectid_map(struct super_block *s);\nvoid print_block_head(struct buffer_head *bh, char *mes);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nvoid print_statistics(struct super_block *s);\nchar *reiserfs_hashname(int code);\n\n \nint leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew);\nint leaf_shift_left(struct tree_balance *tb, int shift_num, int shift_bytes);\nint leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes);\nvoid leaf_delete_items(struct buffer_info *cur_bi, int last_first, int first,\n\t\t       int del_num, int del_bytes);\nvoid leaf_insert_into_buf(struct buffer_info *bi, int before,\n\t\t\t  struct item_head * const inserted_item_ih,\n\t\t\t  const char * const inserted_item_body,\n\t\t\t  int zeros_number);\nvoid leaf_paste_in_buffer(struct buffer_info *bi, int pasted_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char * const body, int zeros_number);\nvoid leaf_cut_from_buffer(struct buffer_info *bi, int cut_item_num,\n\t\t\t  int pos_in_item, int cut_size);\nvoid leaf_paste_entries(struct buffer_info *bi, int item_num, int before,\n\t\t\tint new_entry_count, struct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size);\n \nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\n\n \nvoid do_balance_mark_leaf_dirty(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh, int flag);\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n#define do_balance_mark_sb_dirty do_balance_mark_leaf_dirty\n\nvoid do_balance(struct tree_balance *tb, struct item_head *ih,\n\t\tconst char *body, int flag);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\n\nint get_left_neighbor_position(struct tree_balance *tb, int h);\nint get_right_neighbor_position(struct tree_balance *tb, int h);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\nvoid make_empty_node(struct buffer_info *);\nstruct buffer_head *get_FEB(struct tree_balance *);\n\n \n\n \nstruct __reiserfs_blocknr_hint {\n\t \n\tstruct inode *inode;\n\n\tsector_t block;\t\t \n\tstruct in_core_key key;\n\n\t \n\tstruct treepath *path;\n\n\t \n\tstruct reiserfs_transaction_handle *th;\n\n\tb_blocknr_t beg, end;\n\n\t \n\tb_blocknr_t search_start;\n\n\t \n\tint prealloc_size;\n\n\t \n\tunsigned formatted_node:1;\n\tunsigned preallocate:1;\n};\n\ntypedef struct __reiserfs_blocknr_hint reiserfs_blocknr_hint_t;\n\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\n\n \n__le32 reiserfs_choose_packing(struct inode *dir);\n\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\nvoid reiserfs_cache_bitmap_metadata(struct super_block *sb, struct buffer_head *bh, struct reiserfs_bitmap_info *info);\nstruct buffer_head *reiserfs_read_bitmap_block(struct super_block *sb, unsigned int bitmap);\nint is_reusable(struct super_block *s, b_blocknr_t block, int bit_value);\nvoid reiserfs_free_block(struct reiserfs_transaction_handle *th, struct inode *,\n\t\t\t b_blocknr_t, int for_unformatted);\nint reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *, b_blocknr_t *, int,\n\t\t\t       int);\nstatic inline int reiserfs_new_form_blocknrs(struct tree_balance *tb,\n\t\t\t\t\t     b_blocknr_t * new_blocknrs,\n\t\t\t\t\t     int amount_needed)\n{\n\treiserfs_blocknr_hint_t hint = {\n\t\t.th = tb->transaction_handle,\n\t\t.path = tb->tb_path,\n\t\t.inode = NULL,\n\t\t.key = tb->key,\n\t\t.block = 0,\n\t\t.formatted_node = 1\n\t};\n\treturn reiserfs_allocate_blocknrs(&hint, new_blocknrs, amount_needed,\n\t\t\t\t\t  0);\n}\n\nstatic inline int reiserfs_new_unf_blocknrs(struct reiserfs_transaction_handle\n\t\t\t\t\t    *th, struct inode *inode,\n\t\t\t\t\t    b_blocknr_t * new_blocknrs,\n\t\t\t\t\t    struct treepath *path,\n\t\t\t\t\t    sector_t block)\n{\n\treiserfs_blocknr_hint_t hint = {\n\t\t.th = th,\n\t\t.path = path,\n\t\t.inode = inode,\n\t\t.block = block,\n\t\t.formatted_node = 0,\n\t\t.preallocate = 0\n\t};\n\treturn reiserfs_allocate_blocknrs(&hint, new_blocknrs, 1, 0);\n}\n\n#ifdef REISERFS_PREALLOCATE\nstatic inline int reiserfs_new_unf_blocknrs2(struct reiserfs_transaction_handle\n\t\t\t\t\t     *th, struct inode *inode,\n\t\t\t\t\t     b_blocknr_t * new_blocknrs,\n\t\t\t\t\t     struct treepath *path,\n\t\t\t\t\t     sector_t block)\n{\n\treiserfs_blocknr_hint_t hint = {\n\t\t.th = th,\n\t\t.path = path,\n\t\t.inode = inode,\n\t\t.block = block,\n\t\t.formatted_node = 0,\n\t\t.preallocate = 1\n\t};\n\treturn reiserfs_allocate_blocknrs(&hint, new_blocknrs, 1, 0);\n}\n\nvoid reiserfs_discard_prealloc(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode);\nvoid reiserfs_discard_all_prealloc(struct reiserfs_transaction_handle *th);\n#endif\n\n \n__u32 keyed_hash(const signed char *msg, int len);\n__u32 yura_hash(const signed char *msg, int len);\n__u32 r5_hash(const signed char *msg, int len);\n\n#define reiserfs_set_le_bit\t\t__set_bit_le\n#define reiserfs_test_and_set_le_bit\t__test_and_set_bit_le\n#define reiserfs_clear_le_bit\t\t__clear_bit_le\n#define reiserfs_test_and_clear_le_bit\t__test_and_clear_bit_le\n#define reiserfs_test_le_bit\t\ttest_bit_le\n#define reiserfs_find_next_zero_le_bit\tfind_next_zero_bit_le\n\n \n#define SPARE_SPACE 500\n\n \nint reiserfs_fileattr_get(struct dentry *dentry, struct fileattr *fa);\nint reiserfs_fileattr_set(struct mnt_idmap *idmap,\n\t\t\t  struct dentry *dentry, struct fileattr *fa);\nlong reiserfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);\nlong reiserfs_compat_ioctl(struct file *filp,\n\t\t   unsigned int cmd, unsigned long arg);\nint reiserfs_unpack(struct inode *inode);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}