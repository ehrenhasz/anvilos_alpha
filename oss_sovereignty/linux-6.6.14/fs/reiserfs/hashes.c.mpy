{
  "module_name": "hashes.c",
  "hash_id": "cfbd29c21ca65ffd7c815f07eed657a83d04ba95bd98b8f826e81f6739692a2b",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/hashes.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <asm/types.h>\n\n#define DELTA 0x9E3779B9\n#define FULLROUNDS 10\t\t \n#define PARTROUNDS 6\t\t \n\n \n#define TEACORE(rounds)\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tu32 sum = 0;\t\t\t\t\t\t\\\n\t\tint n = rounds;\t\t\t\t\t\t\\\n\t\tu32 b0, b1;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tb0 = h0;\t\t\t\t\t\t\\\n\t\tb1 = h1;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tdo\t\t\t\t\t\t\t\\\n\t\t{\t\t\t\t\t\t\t\\\n\t\t\tsum += DELTA;\t\t\t\t\t\\\n\t\t\tb0 += ((b1 << 4)+a) ^ (b1+sum) ^ ((b1 >> 5)+b);\t\\\n\t\t\tb1 += ((b0 << 4)+c) ^ (b0+sum) ^ ((b0 >> 5)+d);\t\\\n\t\t} while(--n);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\th0 += b0;\t\t\t\t\t\t\\\n\t\th1 += b1;\t\t\t\t\t\t\\\n\t} while(0)\n\nu32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t \n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n \n\treturn h0 ^ h1;\n}\n\n \nu32 yura_hash(const signed char *msg, int len)\n{\n\tint j, pow;\n\tu32 a, c;\n\tint i;\n\n\tfor (pow = 1, i = 1; i < len; i++)\n\t\tpow = pow * 10;\n\n\tif (len == 1)\n\t\ta = msg[0] - 48;\n\telse\n\t\ta = (msg[0] - 48) * pow;\n\n\tfor (i = 1; i < len; i++) {\n\t\tc = msg[i] - 48;\n\t\tfor (pow = 1, j = i; j < len - 1; j++)\n\t\t\tpow = pow * 10;\n\t\ta = a + c * pow;\n\t}\n\n\tfor (; i < 40; i++) {\n\t\tc = '0' - 48;\n\t\tfor (pow = 1, j = i; j < len - 1; j++)\n\t\t\tpow = pow * 10;\n\t\ta = a + c * pow;\n\t}\n\n\tfor (; i < 256; i++) {\n\t\tc = i;\n\t\tfor (pow = 1, j = i; j < len - 1; j++)\n\t\t\tpow = pow * 10;\n\t\ta = a + c * pow;\n\t}\n\n\ta = a << 7;\n\treturn a;\n}\n\nu32 r5_hash(const signed char *msg, int len)\n{\n\tu32 a = 0;\n\twhile (*msg) {\n\t\ta += *msg << 4;\n\t\ta += *msg >> 4;\n\t\ta *= 11;\n\t\tmsg++;\n\t}\n\treturn a;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}