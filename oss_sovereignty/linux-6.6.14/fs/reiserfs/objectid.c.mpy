{
  "module_name": "objectid.c",
  "hash_id": "493e2b4dc068da26684895772272734194e012c9f063e3b13664898b3e4a3426",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/objectid.c",
  "human_readable_source": " \n\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/uuid.h>\n#include \"reiserfs.h\"\n\n \n#define objectid_map(s,rs) (old_format_only (s) ? \\\n                         (__le32 *)((struct reiserfs_super_block_v1 *)(rs) + 1) :\\\n\t\t\t (__le32 *)((rs) + 1))\n\n#ifdef CONFIG_REISERFS_CHECK\n\nstatic void check_objectid_map(struct super_block *s, __le32 * map)\n{\n\tif (le32_to_cpu(map[0]) != 1)\n\t\treiserfs_panic(s, \"vs-15010\", \"map corrupted: %lx\",\n\t\t\t       (long unsigned int)le32_to_cpu(map[0]));\n\n\t \n}\n\n#else\nstatic void check_objectid_map(struct super_block *s, __le32 * map)\n{;\n}\n#endif\n\n \n\n \n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\t__le32 *map = objectid_map(s, rs);\n\t__u32 unused_objectid;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tcheck_objectid_map(s, map);\n\n\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\t \n\tunused_objectid = le32_to_cpu(map[1]);\n\tif (unused_objectid == U32_MAX) {\n\t\treiserfs_warning(s, \"reiserfs-15100\", \"no more object ids\");\n\t\treiserfs_restore_prepared_buffer(s, SB_BUFFER_WITH_SB(s));\n\t\treturn 0;\n\t}\n\n\t \n\tmap[1] = cpu_to_le32(unused_objectid + 1);\n\n\t \n\tif (sb_oid_cursize(rs) > 2 && map[1] == map[2]) {\n\t\tmemmove(map + 1, map + 3,\n\t\t\t(sb_oid_cursize(rs) - 3) * sizeof(__u32));\n\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) - 2);\n\t}\n\n\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\n\treturn unused_objectid;\n}\n\n \nvoid reiserfs_release_objectid(struct reiserfs_transaction_handle *th,\n\t\t\t       __u32 objectid_to_release)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\t__le32 *map = objectid_map(s, rs);\n\tint i = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\t \n\tcheck_objectid_map(s, map);\n\n\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\n\n\t \n\twhile (i < sb_oid_cursize(rs)) {\n\t\tif (objectid_to_release == le32_to_cpu(map[i])) {\n\t\t\t \n\t\t\tle32_add_cpu(&map[i], 1);\n\n\t\t\t \n\t\t\tif (map[i] == map[i + 1]) {\n\t\t\t\t \n\t\t\t\tmemmove(map + i, map + i + 2,\n\t\t\t\t\t(sb_oid_cursize(rs) - i -\n\t\t\t\t\t 2) * sizeof(__u32));\n\t\t\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) - 2);\n\n\t\t\t\tRFALSE(sb_oid_cursize(rs) < 2 ||\n\t\t\t\t       sb_oid_cursize(rs) > sb_oid_maxsize(rs),\n\t\t\t\t       \"vs-15005: objectid map corrupted cur_size == %d (max == %d)\",\n\t\t\t\t       sb_oid_cursize(rs), sb_oid_maxsize(rs));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (objectid_to_release > le32_to_cpu(map[i]) &&\n\t\t    objectid_to_release < le32_to_cpu(map[i + 1])) {\n\t\t\t \n\t\t\tif (objectid_to_release + 1 == le32_to_cpu(map[i + 1])) {\n\t\t\t\tle32_add_cpu(&map[i + 1], -1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t\t \n\t\t\tif (sb_oid_cursize(rs) == sb_oid_maxsize(rs)) {\n\t\t\t\tPROC_INFO_INC(s, leaked_oid);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t\tmemmove(map + i + 3, map + i + 1,\n\t\t\t\t(sb_oid_cursize(rs) - i - 1) * sizeof(__u32));\n\t\t\tmap[i + 1] = cpu_to_le32(objectid_to_release);\n\t\t\tmap[i + 2] = cpu_to_le32(objectid_to_release + 1);\n\t\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) + 2);\n\t\t\treturn;\n\t\t}\n\t\ti += 2;\n\t}\n\n\treiserfs_error(s, \"vs-15011\", \"tried to free free object id (%lu)\",\n\t\t       (long unsigned)objectid_to_release);\n}\n\nint reiserfs_convert_objectid_map_v1(struct super_block *s)\n{\n\tstruct reiserfs_super_block *disk_sb = SB_DISK_SUPER_BLOCK(s);\n\tint cur_size = sb_oid_cursize(disk_sb);\n\tint new_size = (s->s_blocksize - SB_SIZE) / sizeof(__u32) / 2 * 2;\n\tint old_max = sb_oid_maxsize(disk_sb);\n\tstruct reiserfs_super_block_v1 *disk_sb_v1;\n\t__le32 *objectid_map;\n\tint i;\n\n\tdisk_sb_v1 =\n\t    (struct reiserfs_super_block_v1 *)(SB_BUFFER_WITH_SB(s)->b_data);\n\tobjectid_map = (__le32 *) (disk_sb_v1 + 1);\n\n\tif (cur_size > new_size) {\n\t\t \n\t\tobjectid_map[new_size - 1] = objectid_map[cur_size - 1];\n\t\tset_sb_oid_cursize(disk_sb, new_size);\n\t}\n\t \n\tfor (i = new_size - 1; i >= 0; i--) {\n\t\tobjectid_map[i + (old_max - new_size)] = objectid_map[i];\n\t}\n\n\t \n\tset_sb_oid_maxsize(disk_sb, new_size);\n\n\t \n\tmemset(disk_sb->s_label, 0, sizeof(disk_sb->s_label));\n\tgenerate_random_uuid(disk_sb->s_uuid);\n\n\t \n\tmemset(disk_sb->s_unused, 0, sizeof(disk_sb->s_unused));\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}