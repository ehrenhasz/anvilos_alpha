{
  "module_name": "resize.c",
  "hash_id": "88bdae6074b1f4b6fa87466a57717a36c01bbfba7ec2ecf2a7662b8bcc749efb",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/resize.c",
  "human_readable_source": " \n\n \n\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/buffer_head.h>\n\nint reiserfs_resize(struct super_block *s, unsigned long block_count_new)\n{\n\tint err = 0;\n\tstruct reiserfs_super_block *sb;\n\tstruct reiserfs_bitmap_info *bitmap;\n\tstruct reiserfs_bitmap_info *info;\n\tstruct reiserfs_bitmap_info *old_bitmap = SB_AP_BITMAP(s);\n\tstruct buffer_head *bh;\n\tstruct reiserfs_transaction_handle th;\n\tunsigned int bmap_nr_new, bmap_nr;\n\tunsigned int block_r_new, block_r;\n\n\tstruct reiserfs_list_bitmap *jb;\n\tstruct reiserfs_list_bitmap jbitmap[JOURNAL_NUM_BITMAPS];\n\n\tunsigned long int block_count, free_blocks;\n\tint i;\n\tint copy_size;\n\tint depth;\n\n\tsb = SB_DISK_SUPER_BLOCK(s);\n\n\tif (SB_BLOCK_COUNT(s) >= block_count_new) {\n\t\tprintk(\"can\\'t shrink filesystem on-line\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdepth = reiserfs_write_unlock_nested(s);\n\tbh = sb_bread(s, block_count_new - 1);\n\treiserfs_write_lock_nested(s, depth);\n\tif (!bh) {\n\t\tprintk(\"reiserfs_resize: can\\'t read last block\\n\");\n\t\treturn -EINVAL;\n\t}\n\tbforget(bh);\n\n\t \n\tif (SB_BUFFER_WITH_SB(s)->b_blocknr * SB_BUFFER_WITH_SB(s)->b_size\n\t    != REISERFS_DISK_OFFSET_IN_BYTES) {\n\t\tprintk\n\t\t    (\"reiserfs_resize: unable to resize a reiserfs without distributed bitmap (fs version < 3.5.12)\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\t \n\tblock_r = SB_BLOCK_COUNT(s) -\n\t\t\t(reiserfs_bmap_count(s) - 1) * s->s_blocksize * 8;\n\n\t \n\tbmap_nr_new = block_count_new / (s->s_blocksize * 8);\n\tblock_r_new = block_count_new - bmap_nr_new * s->s_blocksize * 8;\n\tif (block_r_new)\n\t\tbmap_nr_new++;\n\telse\n\t\tblock_r_new = s->s_blocksize * 8;\n\n\t \n\tblock_count = SB_BLOCK_COUNT(s);\n\tbmap_nr = reiserfs_bmap_count(s);\n\n\t \n\tif (bmap_nr_new > bmap_nr) {\n\t\t \n\t\tif (reiserfs_allocate_list_bitmaps(s, jbitmap, bmap_nr_new) < 0) {\n\t\t\tprintk\n\t\t\t    (\"reiserfs_resize: unable to allocate memory for journal bitmaps\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t \n\t\tcopy_size = min(bmap_nr_new, bmap_nr);\n\t\tcopy_size =\n\t\t    copy_size * sizeof(struct reiserfs_list_bitmap_node *);\n\t\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\t\tstruct reiserfs_bitmap_node **node_tmp;\n\t\t\tjb = SB_JOURNAL(s)->j_list_bitmap + i;\n\t\t\tmemcpy(jbitmap[i].bitmaps, jb->bitmaps, copy_size);\n\n\t\t\t \n\t\t\tnode_tmp = jb->bitmaps;\n\t\t\tjb->bitmaps = jbitmap[i].bitmaps;\n\t\t\tvfree(node_tmp);\n\t\t}\n\n\t\t \n\t\tbitmap =\n\t\t    vzalloc(array_size(bmap_nr_new,\n\t\t\t\t       sizeof(struct reiserfs_bitmap_info)));\n\t\tif (!bitmap) {\n\t\t\t \n\t\t\tprintk(\"reiserfs_resize: unable to allocate memory.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tfor (i = 0; i < bmap_nr; i++)\n\t\t\tbitmap[i] = old_bitmap[i];\n\n\t\t \n\t\tfor (i = bmap_nr; i < bmap_nr_new; i++) {\n\t\t\tint depth;\n\t\t\t \n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tbh = sb_bread(s, i * s->s_blocksize * 8);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\tif (!bh) {\n\t\t\t\tvfree(bitmap);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tmemset(bh->b_data, 0, sb_blocksize(sb));\n\t\t\treiserfs_set_le_bit(0, bh->b_data);\n\t\t\treiserfs_cache_bitmap_metadata(s, bh, bitmap + i);\n\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(bh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\t \n\t\t\tbitmap[i].free_count = sb_blocksize(sb) * 8 - 1;\n\t\t\tbrelse(bh);\n\t\t}\n\t\t \n\t\tSB_AP_BITMAP(s) = bitmap;\n\t\tvfree(old_bitmap);\n\t}\n\n\t \n\terr = journal_begin(&th, s, 10);\n\tif (err)\n\t\treturn err;\n\n\t \n\tinfo = SB_AP_BITMAP(s) + bmap_nr - 1;\n\tbh = reiserfs_read_bitmap_block(s, bmap_nr - 1);\n\tif (!bh) {\n\t\tint jerr = journal_end(&th);\n\t\tif (jerr)\n\t\t\treturn jerr;\n\t\treturn -EIO;\n\t}\n\n\treiserfs_prepare_for_journal(s, bh, 1);\n\tfor (i = block_r; i < s->s_blocksize * 8; i++)\n\t\treiserfs_clear_le_bit(i, bh->b_data);\n\tinfo->free_count += s->s_blocksize * 8 - block_r;\n\n\tjournal_mark_dirty(&th, bh);\n\tbrelse(bh);\n\n\t \n\tinfo = SB_AP_BITMAP(s) + bmap_nr_new - 1;\n\tbh = reiserfs_read_bitmap_block(s, bmap_nr_new - 1);\n\tif (!bh) {\n\t\tint jerr = journal_end(&th);\n\t\tif (jerr)\n\t\t\treturn jerr;\n\t\treturn -EIO;\n\t}\n\n\treiserfs_prepare_for_journal(s, bh, 1);\n\tfor (i = block_r_new; i < s->s_blocksize * 8; i++)\n\t\treiserfs_set_le_bit(i, bh->b_data);\n\tjournal_mark_dirty(&th, bh);\n\tbrelse(bh);\n\n\tinfo->free_count -= s->s_blocksize * 8 - block_r_new;\n\t \n\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\tfree_blocks = SB_FREE_BLOCKS(s);\n\tPUT_SB_FREE_BLOCKS(s,\n\t\t\t   free_blocks + (block_count_new - block_count -\n\t\t\t\t\t  (bmap_nr_new - bmap_nr)));\n\tPUT_SB_BLOCK_COUNT(s, block_count_new);\n\tPUT_SB_BMAP_NR(s, bmap_would_wrap(bmap_nr_new) ? : bmap_nr_new);\n\n\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\n\tSB_JOURNAL(s)->j_must_wait = 1;\n\treturn journal_end(&th);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}