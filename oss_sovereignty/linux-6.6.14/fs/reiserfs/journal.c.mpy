{
  "module_name": "journal.c",
  "hash_id": "d2b50f4b398eab1dc61632b6ed66eb509231b8ba13f043fc4267b8c58f68e9ec",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/journal.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/semaphore.h>\n#include <linux/vmalloc.h>\n#include \"reiserfs.h\"\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n\n \n#define JOURNAL_LIST_ENTRY(h) (list_entry((h), struct reiserfs_journal_list, \\\n                               j_list))\n\n \n#define JOURNAL_TRANS_HALF 1018\n#define BUFNR 64\t\t \n\n \n\n \n#define BLOCK_FREED 2\n \n#define BLOCK_FREED_HOLDER 3\n\n \n#define BLOCK_NEEDS_FLUSH 4\n#define BLOCK_DIRTIED 5\n\n \n#define LIST_TOUCHED 1\n#define LIST_DIRTY   2\n#define LIST_COMMIT_PENDING  4\t \n\n \n#define FLUSH_ALL   1\t\t \n#define COMMIT_NOW  2\t\t \n#define WAIT        4\t\t \n\nstatic int do_journal_end(struct reiserfs_transaction_handle *, int flags);\nstatic int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void flush_async_commits(struct work_struct *work);\nstatic void queue_log_writer(struct super_block *s);\n\n \nenum {\n\tJBEGIN_REG = 0,\t\t \n\t \n\tJBEGIN_JOIN = 1,\n\t \n\tJBEGIN_ABORT = 2,\n};\n\nstatic int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);\n\nstatic void init_journal_hash(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tmemset(journal->j_hash_table, 0,\n\t       JOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *));\n}\n\n \nstatic int reiserfs_clean_and_file_buffer(struct buffer_head *bh)\n{\n\tif (bh) {\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_journal_test(bh);\n\t}\n\treturn 0;\n}\n\nstatic struct reiserfs_bitmap_node *allocate_bitmap_node(struct super_block\n\t\t\t\t\t\t\t *sb)\n{\n\tstruct reiserfs_bitmap_node *bn;\n\tstatic int id;\n\n\tbn = kmalloc(sizeof(struct reiserfs_bitmap_node), GFP_NOFS);\n\tif (!bn) {\n\t\treturn NULL;\n\t}\n\tbn->data = kzalloc(sb->s_blocksize, GFP_NOFS);\n\tif (!bn->data) {\n\t\tkfree(bn);\n\t\treturn NULL;\n\t}\n\tbn->id = id++;\n\tINIT_LIST_HEAD(&bn->list);\n\treturn bn;\n}\n\nstatic struct reiserfs_bitmap_node *get_bitmap_node(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_bitmap_node *bn = NULL;\n\tstruct list_head *entry = journal->j_bitmap_nodes.next;\n\n\tjournal->j_used_bitmap_nodes++;\nrepeat:\n\n\tif (entry != &journal->j_bitmap_nodes) {\n\t\tbn = list_entry(entry, struct reiserfs_bitmap_node, list);\n\t\tlist_del(entry);\n\t\tmemset(bn->data, 0, sb->s_blocksize);\n\t\tjournal->j_free_bitmap_nodes--;\n\t\treturn bn;\n\t}\n\tbn = allocate_bitmap_node(sb);\n\tif (!bn) {\n\t\tyield();\n\t\tgoto repeat;\n\t}\n\treturn bn;\n}\nstatic inline void free_bitmap_node(struct super_block *sb,\n\t\t\t\t    struct reiserfs_bitmap_node *bn)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tjournal->j_used_bitmap_nodes--;\n\tif (journal->j_free_bitmap_nodes > REISERFS_MAX_BITMAP_NODES) {\n\t\tkfree(bn->data);\n\t\tkfree(bn);\n\t} else {\n\t\tlist_add(&bn->list, &journal->j_bitmap_nodes);\n\t\tjournal->j_free_bitmap_nodes++;\n\t}\n}\n\nstatic void allocate_bitmap_nodes(struct super_block *sb)\n{\n\tint i;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_bitmap_node *bn = NULL;\n\tfor (i = 0; i < REISERFS_MIN_BITMAP_NODES; i++) {\n\t\tbn = allocate_bitmap_node(sb);\n\t\tif (bn) {\n\t\t\tlist_add(&bn->list, &journal->j_bitmap_nodes);\n\t\t\tjournal->j_free_bitmap_nodes++;\n\t\t} else {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int set_bit_in_list_bitmap(struct super_block *sb,\n\t\t\t\t  b_blocknr_t block,\n\t\t\t\t  struct reiserfs_list_bitmap *jb)\n{\n\tunsigned int bmap_nr = block / (sb->s_blocksize << 3);\n\tunsigned int bit_nr = block % (sb->s_blocksize << 3);\n\n\tif (!jb->bitmaps[bmap_nr]) {\n\t\tjb->bitmaps[bmap_nr] = get_bitmap_node(sb);\n\t}\n\tset_bit(bit_nr, (unsigned long *)jb->bitmaps[bmap_nr]->data);\n\treturn 0;\n}\n\nstatic void cleanup_bitmap_list(struct super_block *sb,\n\t\t\t\tstruct reiserfs_list_bitmap *jb)\n{\n\tint i;\n\tif (jb->bitmaps == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < reiserfs_bmap_count(sb); i++) {\n\t\tif (jb->bitmaps[i]) {\n\t\t\tfree_bitmap_node(sb, jb->bitmaps[i]);\n\t\t\tjb->bitmaps[i] = NULL;\n\t\t}\n\t}\n}\n\n \nstatic int free_list_bitmaps(struct super_block *sb,\n\t\t\t     struct reiserfs_list_bitmap *jb_array)\n{\n\tint i;\n\tstruct reiserfs_list_bitmap *jb;\n\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\tjb = jb_array + i;\n\t\tjb->journal_list = NULL;\n\t\tcleanup_bitmap_list(sb, jb);\n\t\tvfree(jb->bitmaps);\n\t\tjb->bitmaps = NULL;\n\t}\n\treturn 0;\n}\n\nstatic int free_bitmap_nodes(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct list_head *next = journal->j_bitmap_nodes.next;\n\tstruct reiserfs_bitmap_node *bn;\n\n\twhile (next != &journal->j_bitmap_nodes) {\n\t\tbn = list_entry(next, struct reiserfs_bitmap_node, list);\n\t\tlist_del(next);\n\t\tkfree(bn->data);\n\t\tkfree(bn);\n\t\tnext = journal->j_bitmap_nodes.next;\n\t\tjournal->j_free_bitmap_nodes--;\n\t}\n\n\treturn 0;\n}\n\n \nint reiserfs_allocate_list_bitmaps(struct super_block *sb,\n\t\t\t\t   struct reiserfs_list_bitmap *jb_array,\n\t\t\t\t   unsigned int bmap_nr)\n{\n\tint i;\n\tint failed = 0;\n\tstruct reiserfs_list_bitmap *jb;\n\tint mem = bmap_nr * sizeof(struct reiserfs_bitmap_node *);\n\n\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\tjb = jb_array + i;\n\t\tjb->journal_list = NULL;\n\t\tjb->bitmaps = vzalloc(mem);\n\t\tif (!jb->bitmaps) {\n\t\t\treiserfs_warning(sb, \"clm-2000\", \"unable to \"\n\t\t\t\t\t \"allocate bitmaps for journal lists\");\n\t\t\tfailed = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (failed) {\n\t\tfree_list_bitmaps(sb, jb_array);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nstatic struct reiserfs_list_bitmap *get_list_bitmap(struct super_block *sb,\n\t\t\t\t\t\t    struct reiserfs_journal_list\n\t\t\t\t\t\t    *jl)\n{\n\tint i, j;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_list_bitmap *jb = NULL;\n\n\tfor (j = 0; j < (JOURNAL_NUM_BITMAPS * 3); j++) {\n\t\ti = journal->j_list_bitmap_index;\n\t\tjournal->j_list_bitmap_index = (i + 1) % JOURNAL_NUM_BITMAPS;\n\t\tjb = journal->j_list_bitmap + i;\n\t\tif (journal->j_list_bitmap[i].journal_list) {\n\t\t\tflush_commit_list(sb,\n\t\t\t\t\t  journal->j_list_bitmap[i].\n\t\t\t\t\t  journal_list, 1);\n\t\t\tif (!journal->j_list_bitmap[i].journal_list) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (jb->journal_list)\n\t\treturn NULL;\n\tjb->journal_list = jl;\n\treturn jb;\n}\n\n \nstatic struct reiserfs_journal_cnode *allocate_cnodes(int num_cnodes)\n{\n\tstruct reiserfs_journal_cnode *head;\n\tint i;\n\tif (num_cnodes <= 0) {\n\t\treturn NULL;\n\t}\n\thead = vzalloc(array_size(num_cnodes,\n\t\t\t\t  sizeof(struct reiserfs_journal_cnode)));\n\tif (!head) {\n\t\treturn NULL;\n\t}\n\thead[0].prev = NULL;\n\thead[0].next = head + 1;\n\tfor (i = 1; i < num_cnodes; i++) {\n\t\thead[i].prev = head + (i - 1);\n\t\thead[i].next = head + (i + 1);\t \n\t}\n\thead[num_cnodes - 1].next = NULL;\n\treturn head;\n}\n\n \nstatic struct reiserfs_journal_cnode *get_cnode(struct super_block *sb)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\treiserfs_check_lock_depth(sb, \"get_cnode\");\n\n\tif (journal->j_cnode_free <= 0) {\n\t\treturn NULL;\n\t}\n\tjournal->j_cnode_used++;\n\tjournal->j_cnode_free--;\n\tcn = journal->j_cnode_free_list;\n\tif (!cn) {\n\t\treturn cn;\n\t}\n\tif (cn->next) {\n\t\tcn->next->prev = NULL;\n\t}\n\tjournal->j_cnode_free_list = cn->next;\n\tmemset(cn, 0, sizeof(struct reiserfs_journal_cnode));\n\treturn cn;\n}\n\n \nstatic void free_cnode(struct super_block *sb,\n\t\t       struct reiserfs_journal_cnode *cn)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\treiserfs_check_lock_depth(sb, \"free_cnode\");\n\n\tjournal->j_cnode_used--;\n\tjournal->j_cnode_free++;\n\t \n\tcn->next = journal->j_cnode_free_list;\n\tif (journal->j_cnode_free_list) {\n\t\tjournal->j_cnode_free_list->prev = cn;\n\t}\n\tcn->prev = NULL;\t \n\tjournal->j_cnode_free_list = cn;\n}\n\nstatic void clear_prepared_bits(struct buffer_head *bh)\n{\n\tclear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n}\n\n \nstatic inline struct reiserfs_journal_cnode *get_journal_hash_dev(struct\n\t\t\t\t\t\t\t\t  super_block\n\t\t\t\t\t\t\t\t  *sb,\n\t\t\t\t\t\t\t\t  struct\n\t\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t\t  **table,\n\t\t\t\t\t\t\t\t  long bl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tcn = journal_hash(table, sb, bl);\n\twhile (cn) {\n\t\tif (cn->blocknr == bl && cn->sb == sb)\n\t\t\treturn cn;\n\t\tcn = cn->hnext;\n\t}\n\treturn (struct reiserfs_journal_cnode *)0;\n}\n\n \nint reiserfs_in_journal(struct super_block *sb,\n\t\t\tunsigned int bmap_nr, int bit_nr, int search_all,\n\t\t\tb_blocknr_t * next_zero_bit)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_list_bitmap *jb;\n\tint i;\n\tunsigned long bl;\n\n\t*next_zero_bit = 0;\t \n\n\tPROC_INFO_INC(sb, journal.in_journal);\n\t \n\tif (search_all) {\n\t\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\t\tPROC_INFO_INC(sb, journal.in_journal_bitmap);\n\t\t\tjb = journal->j_list_bitmap + i;\n\t\t\tif (jb->journal_list && jb->bitmaps[bmap_nr] &&\n\t\t\t    test_bit(bit_nr,\n\t\t\t\t     (unsigned long *)jb->bitmaps[bmap_nr]->\n\t\t\t\t     data)) {\n\t\t\t\t*next_zero_bit =\n\t\t\t\t    find_next_zero_bit((unsigned long *)\n\t\t\t\t\t\t       (jb->bitmaps[bmap_nr]->\n\t\t\t\t\t\t\tdata),\n\t\t\t\t\t\t       sb->s_blocksize << 3,\n\t\t\t\t\t\t       bit_nr + 1);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tbl = bmap_nr * (sb->s_blocksize << 3) + bit_nr;\n\t \n\tif (search_all\n\t    && (get_journal_hash_dev(sb, journal->j_list_hash_table, bl))) {\n\t\treturn 1;\n\t}\n\n\t \n\tif ((get_journal_hash_dev(sb, journal->j_hash_table, bl))) {\n\t\tBUG();\n\t\treturn 1;\n\t}\n\n\tPROC_INFO_INC(sb, journal.in_journal_reusable);\n\t \n\treturn 0;\n}\n\n \nstatic inline void insert_journal_hash(struct reiserfs_journal_cnode **table,\n\t\t\t\t       struct reiserfs_journal_cnode *cn)\n{\n\tstruct reiserfs_journal_cnode *cn_orig;\n\n\tcn_orig = journal_hash(table, cn->sb, cn->blocknr);\n\tcn->hnext = cn_orig;\n\tcn->hprev = NULL;\n\tif (cn_orig) {\n\t\tcn_orig->hprev = cn;\n\t}\n\tjournal_hash(table, cn->sb, cn->blocknr) = cn;\n}\n\n \nstatic inline void lock_journal(struct super_block *sb)\n{\n\tPROC_INFO_INC(sb, journal.lock_journal);\n\n\treiserfs_mutex_lock_safe(&SB_JOURNAL(sb)->j_mutex, sb);\n}\n\n \nstatic inline void unlock_journal(struct super_block *sb)\n{\n\tmutex_unlock(&SB_JOURNAL(sb)->j_mutex);\n}\n\nstatic inline void get_journal_list(struct reiserfs_journal_list *jl)\n{\n\tjl->j_refcount++;\n}\n\nstatic inline void put_journal_list(struct super_block *s,\n\t\t\t\t    struct reiserfs_journal_list *jl)\n{\n\tif (jl->j_refcount < 1) {\n\t\treiserfs_panic(s, \"journal-2\", \"trans id %u, refcount at %d\",\n\t\t\t       jl->j_trans_id, jl->j_refcount);\n\t}\n\tif (--jl->j_refcount == 0)\n\t\tkfree(jl);\n}\n\n \nstatic void cleanup_freed_for_journal_list(struct super_block *sb,\n\t\t\t\t\t   struct reiserfs_journal_list *jl)\n{\n\n\tstruct reiserfs_list_bitmap *jb = jl->j_list_bitmap;\n\tif (jb) {\n\t\tcleanup_bitmap_list(sb, jb);\n\t}\n\tjl->j_list_bitmap->journal_list = NULL;\n\tjl->j_list_bitmap = NULL;\n}\n\nstatic int journal_list_still_alive(struct super_block *s,\n\t\t\t\t    unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct list_head *entry = &journal->j_journal_list;\n\tstruct reiserfs_journal_list *jl;\n\n\tif (!list_empty(entry)) {\n\t\tjl = JOURNAL_LIST_ENTRY(entry->next);\n\t\tif (jl->j_trans_id <= trans_id) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct folio *folio = bh->b_folio;\n\tif (!folio->mapping && folio_trylock(folio)) {\n\t\tfolio_get(folio);\n\t\tput_bh(bh);\n\t\tif (!folio->mapping)\n\t\t\ttry_to_free_buffers(folio);\n\t\tfolio_unlock(folio);\n\t\tfolio_put(folio);\n\t} else {\n\t\tput_bh(bh);\n\t}\n}\n\nstatic void reiserfs_end_buffer_io_sync(struct buffer_head *bh, int uptodate)\n{\n\tif (buffer_journaled(bh)) {\n\t\treiserfs_warning(NULL, \"clm-2084\",\n\t\t\t\t \"pinned buffer %lu:%pg sent to disk\",\n\t\t\t\t bh->b_blocknr, bh->b_bdev);\n\t}\n\tif (uptodate)\n\t\tset_buffer_uptodate(bh);\n\telse\n\t\tclear_buffer_uptodate(bh);\n\n\tunlock_buffer(bh);\n\trelease_buffer_page(bh);\n}\n\nstatic void reiserfs_end_ordered_io(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate)\n\t\tset_buffer_uptodate(bh);\n\telse\n\t\tclear_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tput_bh(bh);\n}\n\nstatic void submit_logged_buffer(struct buffer_head *bh)\n{\n\tget_bh(bh);\n\tbh->b_end_io = reiserfs_end_buffer_io_sync;\n\tclear_buffer_journal_new(bh);\n\tclear_buffer_dirty(bh);\n\tif (!test_clear_buffer_journal_test(bh))\n\t\tBUG();\n\tif (!buffer_uptodate(bh))\n\t\tBUG();\n\tsubmit_bh(REQ_OP_WRITE, bh);\n}\n\nstatic void submit_ordered_buffer(struct buffer_head *bh)\n{\n\tget_bh(bh);\n\tbh->b_end_io = reiserfs_end_ordered_io;\n\tclear_buffer_dirty(bh);\n\tif (!buffer_uptodate(bh))\n\t\tBUG();\n\tsubmit_bh(REQ_OP_WRITE, bh);\n}\n\n#define CHUNK_SIZE 32\nstruct buffer_chunk {\n\tstruct buffer_head *bh[CHUNK_SIZE];\n\tint nr;\n};\n\nstatic void write_chunk(struct buffer_chunk *chunk)\n{\n\tint i;\n\tfor (i = 0; i < chunk->nr; i++) {\n\t\tsubmit_logged_buffer(chunk->bh[i]);\n\t}\n\tchunk->nr = 0;\n}\n\nstatic void write_ordered_chunk(struct buffer_chunk *chunk)\n{\n\tint i;\n\tfor (i = 0; i < chunk->nr; i++) {\n\t\tsubmit_ordered_buffer(chunk->bh[i]);\n\t}\n\tchunk->nr = 0;\n}\n\nstatic int add_to_chunk(struct buffer_chunk *chunk, struct buffer_head *bh,\n\t\t\tspinlock_t * lock, void (fn) (struct buffer_chunk *))\n{\n\tint ret = 0;\n\tBUG_ON(chunk->nr >= CHUNK_SIZE);\n\tchunk->bh[chunk->nr++] = bh;\n\tif (chunk->nr >= CHUNK_SIZE) {\n\t\tret = 1;\n\t\tif (lock) {\n\t\t\tspin_unlock(lock);\n\t\t\tfn(chunk);\n\t\t\tspin_lock(lock);\n\t\t} else {\n\t\t\tfn(chunk);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic atomic_t nr_reiserfs_jh = ATOMIC_INIT(0);\nstatic struct reiserfs_jh *alloc_jh(void)\n{\n\tstruct reiserfs_jh *jh;\n\twhile (1) {\n\t\tjh = kmalloc(sizeof(*jh), GFP_NOFS);\n\t\tif (jh) {\n\t\t\tatomic_inc(&nr_reiserfs_jh);\n\t\t\treturn jh;\n\t\t}\n\t\tyield();\n\t}\n}\n\n \nvoid reiserfs_free_jh(struct buffer_head *bh)\n{\n\tstruct reiserfs_jh *jh;\n\n\tjh = bh->b_private;\n\tif (jh) {\n\t\tbh->b_private = NULL;\n\t\tjh->bh = NULL;\n\t\tlist_del_init(&jh->list);\n\t\tkfree(jh);\n\t\tif (atomic_read(&nr_reiserfs_jh) <= 0)\n\t\t\tBUG();\n\t\tatomic_dec(&nr_reiserfs_jh);\n\t\tput_bh(bh);\n\t}\n}\n\nstatic inline int __add_jh(struct reiserfs_journal *j, struct buffer_head *bh,\n\t\t\t   int tail)\n{\n\tstruct reiserfs_jh *jh;\n\n\tif (bh->b_private) {\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\tif (!bh->b_private) {\n\t\t\tspin_unlock(&j->j_dirty_buffers_lock);\n\t\t\tgoto no_jh;\n\t\t}\n\t\tjh = bh->b_private;\n\t\tlist_del_init(&jh->list);\n\t} else {\nno_jh:\n\t\tget_bh(bh);\n\t\tjh = alloc_jh();\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\t \n\t\tBUG_ON(bh->b_private);\n\t\tjh->bh = bh;\n\t\tbh->b_private = jh;\n\t}\n\tjh->jl = j->j_current_jl;\n\tif (tail)\n\t\tlist_add_tail(&jh->list, &jh->jl->j_tail_bh_list);\n\telse {\n\t\tlist_add_tail(&jh->list, &jh->jl->j_bh_list);\n\t}\n\tspin_unlock(&j->j_dirty_buffers_lock);\n\treturn 0;\n}\n\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh)\n{\n\treturn __add_jh(SB_JOURNAL(inode->i_sb), bh, 1);\n}\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh)\n{\n\treturn __add_jh(SB_JOURNAL(inode->i_sb), bh, 0);\n}\n\n#define JH_ENTRY(l) list_entry((l), struct reiserfs_jh, list)\nstatic int write_ordered_buffers(spinlock_t * lock,\n\t\t\t\t struct reiserfs_journal *j,\n\t\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t\t struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct reiserfs_jh *jh;\n\tint ret = j->j_errno;\n\tstruct buffer_chunk chunk;\n\tstruct list_head tmp;\n\tINIT_LIST_HEAD(&tmp);\n\n\tchunk.nr = 0;\n\tspin_lock(lock);\n\twhile (!list_empty(list)) {\n\t\tjh = JH_ENTRY(list->next);\n\t\tbh = jh->bh;\n\t\tget_bh(bh);\n\t\tif (!trylock_buffer(bh)) {\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\tlist_move(&jh->list, &tmp);\n\t\t\t\tgoto loop_next;\n\t\t\t}\n\t\t\tspin_unlock(lock);\n\t\t\tif (chunk.nr)\n\t\t\t\twrite_ordered_chunk(&chunk);\n\t\t\twait_on_buffer(bh);\n\t\t\tcond_resched();\n\t\t\tspin_lock(lock);\n\t\t\tgoto loop_next;\n\t\t}\n\t\t \n\t\tif (!buffer_uptodate(bh) && buffer_dirty(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tret = -EIO;\n\t\t}\n\t\tif (buffer_dirty(bh)) {\n\t\t\tlist_move(&jh->list, &tmp);\n\t\t\tadd_to_chunk(&chunk, bh, lock, write_ordered_chunk);\n\t\t} else {\n\t\t\treiserfs_free_jh(bh);\n\t\t\tunlock_buffer(bh);\n\t\t}\nloop_next:\n\t\tput_bh(bh);\n\t\tcond_resched_lock(lock);\n\t}\n\tif (chunk.nr) {\n\t\tspin_unlock(lock);\n\t\twrite_ordered_chunk(&chunk);\n\t\tspin_lock(lock);\n\t}\n\twhile (!list_empty(&tmp)) {\n\t\tjh = JH_ENTRY(tmp.prev);\n\t\tbh = jh->bh;\n\t\tget_bh(bh);\n\t\treiserfs_free_jh(bh);\n\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tspin_lock(lock);\n\t\t}\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tret = -EIO;\n\t\t}\n\t\t \n\t\tif (buffer_dirty(bh) && unlikely(bh->b_folio->mapping == NULL)) {\n\t\t\tspin_unlock(lock);\n\t\t\twrite_dirty_buffer(bh, 0);\n\t\t\tspin_lock(lock);\n\t\t}\n\t\tput_bh(bh);\n\t\tcond_resched_lock(lock);\n\t}\n\tspin_unlock(lock);\n\treturn ret;\n}\n\nstatic int flush_older_commits(struct super_block *s,\n\t\t\t       struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct reiserfs_journal_list *other_jl;\n\tstruct reiserfs_journal_list *first_jl;\n\tstruct list_head *entry;\n\tunsigned int trans_id = jl->j_trans_id;\n\tunsigned int other_trans_id;\n\nfind_first:\n\t \n\tfirst_jl = jl;\n\tentry = jl->j_list.prev;\n\twhile (1) {\n\t\tother_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tif (entry == &journal->j_journal_list ||\n\t\t    atomic_read(&other_jl->j_older_commits_done))\n\t\t\tbreak;\n\n\t\tfirst_jl = other_jl;\n\t\tentry = other_jl->j_list.prev;\n\t}\n\n\t \n\tif (first_jl == jl) {\n\t\treturn 0;\n\t}\n\n\tentry = &first_jl->j_list;\n\twhile (1) {\n\t\tother_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tother_trans_id = other_jl->j_trans_id;\n\n\t\tif (other_trans_id < trans_id) {\n\t\t\tif (atomic_read(&other_jl->j_commit_left) != 0) {\n\t\t\t\tflush_commit_list(s, other_jl, 0);\n\n\t\t\t\t \n\t\t\t\tif (!journal_list_still_alive(s, trans_id))\n\t\t\t\t\treturn 1;\n\n\t\t\t\t \n\t\t\t\tif (!journal_list_still_alive\n\t\t\t\t    (s, other_trans_id)) {\n\t\t\t\t\tgoto find_first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry = entry->next;\n\t\t\tif (entry == &journal->j_journal_list)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int reiserfs_async_progress_wait(struct super_block *s)\n{\n\tstruct reiserfs_journal *j = SB_JOURNAL(s);\n\n\tif (atomic_read(&j->j_async_throttle)) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\twait_var_event_timeout(&j->j_async_throttle,\n\t\t\t\t       atomic_read(&j->j_async_throttle) == 0,\n\t\t\t\t       HZ / 10);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall)\n{\n\tint i;\n\tb_blocknr_t bn;\n\tstruct buffer_head *tbh = NULL;\n\tunsigned int trans_id = jl->j_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint retval = 0;\n\tint write_len;\n\tint depth;\n\n\treiserfs_check_lock_depth(s, \"flush_commit_list\");\n\n\tif (atomic_read(&jl->j_older_commits_done)) {\n\t\treturn 0;\n\t}\n\n\t \n\tBUG_ON(jl->j_len <= 0);\n\tBUG_ON(trans_id == journal->j_trans_id);\n\n\tget_journal_list(jl);\n\tif (flushall) {\n\t\tif (flush_older_commits(s, jl) == 1) {\n\t\t\t \n\t\t\tgoto put_jl;\n\t\t}\n\t}\n\n\t \n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, s);\n\n\tif (!journal_list_still_alive(s, trans_id)) {\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\tBUG_ON(jl->j_trans_id == 0);\n\n\t \n\tif (atomic_read(&jl->j_commit_left) <= 0) {\n\t\tif (flushall) {\n\t\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t\t}\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\n\tif (!list_empty(&jl->j_bh_list)) {\n\t\tint ret;\n\n\t\t \n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tret = write_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t\t    journal, jl, &jl->j_bh_list);\n\t\tif (ret < 0 && retval == 0)\n\t\t\tretval = ret;\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_bh_list));\n\t \n\tatomic_inc(&journal->j_async_throttle);\n\twrite_len = jl->j_len + 1;\n\tif (write_len < 256)\n\t\twrite_len = 256;\n\tfor (i = 0 ; i < write_len ; i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + (jl->j_start + i) %\n\t\t    SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\t\tif (tbh) {\n\t\t\tif (buffer_dirty(tbh)) {\n\t\t            depth = reiserfs_write_unlock_nested(s);\n\t\t\t    write_dirty_buffer(tbh, 0);\n\t\t\t    reiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\tput_bh(tbh) ;\n\t\t}\n\t}\n\tif (atomic_dec_and_test(&journal->j_async_throttle))\n\t\twake_up_var(&journal->j_async_throttle);\n\n\tfor (i = 0; i < (jl->j_len + 1); i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) +\n\t\t    (jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t__wait_on_buffer(tbh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t\t \n\t\t \n\t\tif (buffer_dirty(tbh)) {\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(tbh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\treiserfs_warning(s, \"journal-601\",\n\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\tretval = -EIO;\n\t\t}\n\t\t \n\t\tput_bh(tbh);\n\t\t \n\t\tput_bh(tbh);\n\t\tatomic_dec(&jl->j_commit_left);\n\t}\n\n\tBUG_ON(atomic_read(&jl->j_commit_left) != 1);\n\n\t \n\tif (likely(!retval && !reiserfs_is_journal_aborted (journal))) {\n\t\tif (buffer_dirty(jl->j_commit_bh))\n\t\t\tBUG();\n\t\tmark_buffer_dirty(jl->j_commit_bh) ;\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tif (reiserfs_barrier_flush(s))\n\t\t\t__sync_dirty_buffer(jl->j_commit_bh,\n\t\t\t\t\tREQ_SYNC | REQ_PREFLUSH | REQ_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(jl->j_commit_bh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\t \n\tif (unlikely(!buffer_uptodate(jl->j_commit_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\treiserfs_warning(s, \"journal-615\", \"buffer write failed\");\n#endif\n\t\tretval = -EIO;\n\t}\n\tbforget(jl->j_commit_bh);\n\tif (journal->j_last_commit_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_commit_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2200\", \"last commit %lu, current %lu\",\n\t\t\t\t journal->j_last_commit_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_commit_id = jl->j_trans_id;\n\n\t \n\tcleanup_freed_for_journal_list(s, jl);\n\n\tretval = retval ? retval : journal->j_errno;\n\n\t \n\tif (!retval)\n\t\tdirty_one_transaction(s, jl);\n\tatomic_dec(&jl->j_commit_left);\n\n\tif (flushall) {\n\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t}\n\tmutex_unlock(&jl->j_commit_mutex);\nput_jl:\n\tput_journal_list(s, jl);\n\n\tif (retval)\n\t\treiserfs_abort(s, retval, \"Journal write error in %s\",\n\t\t\t       __func__);\n\treturn retval;\n}\n\n \nstatic struct reiserfs_journal_list *find_newer_jl_for_cn(struct\n\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t  *cn)\n{\n\tstruct super_block *sb = cn->sb;\n\tb_blocknr_t blocknr = cn->blocknr;\n\n\tcn = cn->hprev;\n\twhile (cn) {\n\t\tif (cn->sb == sb && cn->blocknr == blocknr && cn->jlist) {\n\t\t\treturn cn->jlist;\n\t\t}\n\t\tcn = cn->hprev;\n\t}\n\treturn NULL;\n}\n\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\n \nstatic void remove_all_from_journal_list(struct super_block *sb,\n\t\t\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t\t\t int debug)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn, *last;\n\tcn = jl->j_realblock;\n\n\t \n\twhile (cn) {\n\t\tif (cn->blocknr != 0) {\n\t\t\tif (debug) {\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2201\",\n\t\t\t\t\t\t \"block %u, bh is %d, state %ld\",\n\t\t\t\t\t\t cn->blocknr, cn->bh ? 1 : 0,\n\t\t\t\t\t\t cn->state);\n\t\t\t}\n\t\t\tcn->state = 0;\n\t\t\tremove_journal_hash(sb, journal->j_list_hash_table,\n\t\t\t\t\t    jl, cn->blocknr, 1);\n\t\t}\n\t\tlast = cn;\n\t\tcn = cn->next;\n\t\tfree_cnode(sb, last);\n\t}\n\tjl->j_realblock = NULL;\n}\n\n \nstatic int _update_journal_header_block(struct super_block *sb,\n\t\t\t\t\tunsigned long offset,\n\t\t\t\t\tunsigned int trans_id)\n{\n\tstruct reiserfs_journal_header *jh;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tint depth;\n\n\tif (reiserfs_is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tif (trans_id >= journal->j_last_flush_trans_id) {\n\t\tif (buffer_locked((journal->j_header_bh))) {\n\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t__wait_on_buffer(journal->j_header_bh);\n\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t\tif (unlikely(!buffer_uptodate(journal->j_header_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\treiserfs_warning(sb, \"journal-699\",\n\t\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\tjournal->j_last_flush_trans_id = trans_id;\n\t\tjournal->j_first_unflushed_offset = offset;\n\t\tjh = (struct reiserfs_journal_header *)(journal->j_header_bh->\n\t\t\t\t\t\t\tb_data);\n\t\tjh->j_last_flush_trans_id = cpu_to_le32(trans_id);\n\t\tjh->j_first_unflushed_offset = cpu_to_le32(offset);\n\t\tjh->j_mount_id = cpu_to_le32(journal->j_mount_id);\n\n\t\tset_buffer_dirty(journal->j_header_bh);\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\n\t\tif (reiserfs_barrier_flush(sb))\n\t\t\t__sync_dirty_buffer(journal->j_header_bh,\n\t\t\t\t\tREQ_SYNC | REQ_PREFLUSH | REQ_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(journal->j_header_bh);\n\n\t\treiserfs_write_lock_nested(sb, depth);\n\t\tif (!buffer_uptodate(journal->j_header_bh)) {\n\t\t\treiserfs_warning(sb, \"journal-837\",\n\t\t\t\t\t \"IO error during journal replay\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int update_journal_header_block(struct super_block *sb,\n\t\t\t\t       unsigned long offset,\n\t\t\t\t       unsigned int trans_id)\n{\n\treturn _update_journal_header_block(sb, offset, trans_id);\n}\n\n \nstatic int flush_older_journal_lists(struct super_block *sb,\n\t\t\t\t     struct reiserfs_journal_list *jl)\n{\n\tstruct list_head *entry;\n\tstruct reiserfs_journal_list *other_jl;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tunsigned int trans_id = jl->j_trans_id;\n\n\t \nrestart:\n\tentry = journal->j_journal_list.next;\n\t \n\tif (entry == &journal->j_journal_list)\n\t\treturn 0;\n\tother_jl = JOURNAL_LIST_ENTRY(entry);\n\tif (other_jl->j_trans_id < trans_id) {\n\t\tBUG_ON(other_jl->j_refcount <= 0);\n\t\t \n\t\tflush_journal_list(sb, other_jl, 0);\n\n\t\t \n\t\tgoto restart;\n\t}\n\treturn 0;\n}\n\nstatic void del_from_work_list(struct super_block *s,\n\t\t\t       struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tif (!list_empty(&jl->j_working_list)) {\n\t\tlist_del_init(&jl->j_working_list);\n\t\tjournal->j_num_work_lists--;\n\t}\n}\n\n \nstatic int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall)\n{\n\tstruct reiserfs_journal_list *pjl;\n\tstruct reiserfs_journal_cnode *cn;\n\tint count;\n\tint was_jwait = 0;\n\tint was_dirty = 0;\n\tstruct buffer_head *saved_bh;\n\tunsigned long j_len_saved = jl->j_len;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint err = 0;\n\tint depth;\n\n\tBUG_ON(j_len_saved <= 0);\n\n\tif (atomic_read(&journal->j_wcount) != 0) {\n\t\treiserfs_warning(s, \"clm-2048\", \"called with wcount %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t}\n\n\t \n\tif (flushall) {\n\t\treiserfs_mutex_lock_safe(&journal->j_flush_mutex, s);\n\t} else if (mutex_trylock(&journal->j_flush_mutex)) {\n\t\tBUG();\n\t}\n\n\tcount = 0;\n\tif (j_len_saved > journal->j_trans_max) {\n\t\treiserfs_panic(s, \"journal-715\", \"length is %lu, trans id %lu\",\n\t\t\t       j_len_saved, jl->j_trans_id);\n\t\treturn 0;\n\t}\n\n\t \n\tif (atomic_read(&jl->j_nonzerolen) <= 0 &&\n\t    atomic_read(&jl->j_commit_left) <= 0) {\n\t\tgoto flush_older_and_return;\n\t}\n\n\t \n\tflush_commit_list(s, jl, 1);\n\n\tif (!(jl->j_state & LIST_DIRTY)\n\t    && !reiserfs_is_journal_aborted(journal))\n\t\tBUG();\n\n\t \n\tif (atomic_read(&jl->j_nonzerolen) <= 0 &&\n\t    atomic_read(&jl->j_commit_left) <= 0) {\n\t\tgoto flush_older_and_return;\n\t}\n\n\t \n\tif (atomic_read(&journal->j_wcount) != 0) {\n\t\treiserfs_panic(s, \"journal-844\", \"journal list is flushing, \"\n\t\t\t       \"wcount is not 0\");\n\t}\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\twas_jwait = 0;\n\t\twas_dirty = 0;\n\t\tsaved_bh = NULL;\n\t\t \n\t\tif (cn->blocknr == 0) {\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t \n\t\tif (!(jl->j_state & LIST_DIRTY))\n\t\t\tgoto free_cnode;\n\n\t\tpjl = find_newer_jl_for_cn(cn);\n\t\t \n\t\tif (!pjl && cn->bh) {\n\t\t\tsaved_bh = cn->bh;\n\n\t\t\t \n\t\t\tget_bh(saved_bh);\n\n\t\t\tif (buffer_journal_dirty(saved_bh)) {\n\t\t\t\tBUG_ON(!can_dirty(cn));\n\t\t\t\twas_jwait = 1;\n\t\t\t\twas_dirty = 1;\n\t\t\t} else if (can_dirty(cn)) {\n\t\t\t\t \n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (pjl) {\n\t\t\tif (atomic_read(&pjl->j_commit_left))\n\t\t\t\tflush_commit_list(s, pjl, 1);\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t \n\t\tif (saved_bh == NULL) {\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t \n\t\tif ((!was_jwait) && !buffer_locked(saved_bh)) {\n\t\t\treiserfs_warning(s, \"journal-813\",\n\t\t\t\t\t \"BAD! buffer %llu %cdirty %cjwait, \"\n\t\t\t\t\t \"not in a newer transaction\",\n\t\t\t\t\t (unsigned long long)saved_bh->\n\t\t\t\t\t b_blocknr, was_dirty ? ' ' : '!',\n\t\t\t\t\t was_jwait ? ' ' : '!');\n\t\t}\n\t\tif (was_dirty) {\n\t\t\t \n\t\t\tget_bh(saved_bh);\n\t\t\tset_bit(BLOCK_NEEDS_FLUSH, &cn->state);\n\t\t\tlock_buffer(saved_bh);\n\t\t\tBUG_ON(cn->blocknr != saved_bh->b_blocknr);\n\t\t\tif (buffer_dirty(saved_bh))\n\t\t\t\tsubmit_logged_buffer(saved_bh);\n\t\t\telse\n\t\t\t\tunlock_buffer(saved_bh);\n\t\t\tcount++;\n\t\t} else {\n\t\t\treiserfs_warning(s, \"clm-2082\",\n\t\t\t\t\t \"Unable to flush buffer %llu in %s\",\n\t\t\t\t\t (unsigned long long)saved_bh->\n\t\t\t\t\t b_blocknr, __func__);\n\t\t}\nfree_cnode:\n\t\tcn = cn->next;\n\t\tif (saved_bh) {\n\t\t\t \n\t\t\tput_bh(saved_bh);\n\t\t\tif (atomic_read(&saved_bh->b_count) < 0) {\n\t\t\t\treiserfs_warning(s, \"journal-945\",\n\t\t\t\t\t\t \"saved_bh->b_count < 0\");\n\t\t\t}\n\t\t}\n\t}\n\tif (count > 0) {\n\t\tcn = jl->j_realblock;\n\t\twhile (cn) {\n\t\t\tif (test_bit(BLOCK_NEEDS_FLUSH, &cn->state)) {\n\t\t\t\tif (!cn->bh) {\n\t\t\t\t\treiserfs_panic(s, \"journal-1011\",\n\t\t\t\t\t\t       \"cn->bh is NULL\");\n\t\t\t\t}\n\n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\t\t__wait_on_buffer(cn->bh);\n\t\t\t\treiserfs_write_lock_nested(s, depth);\n\n\t\t\t\tif (!cn->bh) {\n\t\t\t\t\treiserfs_panic(s, \"journal-1012\",\n\t\t\t\t\t\t       \"cn->bh is NULL\");\n\t\t\t\t}\n\t\t\t\tif (unlikely(!buffer_uptodate(cn->bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\t\treiserfs_warning(s, \"journal-949\",\n\t\t\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\t\t\terr = -EIO;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tBUG_ON(!test_clear_buffer_journal_dirty\n\t\t\t\t       (cn->bh));\n\n\t\t\t\t \n\t\t\t\tput_bh(cn->bh);\n\t\t\t\t \n\t\t\t\trelease_buffer_page(cn->bh);\n\t\t\t}\n\t\t\tcn = cn->next;\n\t\t}\n\t}\n\n\tif (err)\n\t\treiserfs_abort(s, -EIO,\n\t\t\t       \"Write error while pushing transaction to disk in %s\",\n\t\t\t       __func__);\nflush_older_and_return:\n\n\t \n\tif (flushall) {\n\t\tflush_older_journal_lists(s, jl);\n\t}\n\n\terr = journal->j_errno;\n\t \n\tif (!err && flushall) {\n\t\terr =\n\t\t    update_journal_header_block(s,\n\t\t\t\t\t\t(jl->j_start + jl->j_len +\n\t\t\t\t\t\t 2) % SB_ONDISK_JOURNAL_SIZE(s),\n\t\t\t\t\t\tjl->j_trans_id);\n\t\tif (err)\n\t\t\treiserfs_abort(s, -EIO,\n\t\t\t\t       \"Write error while updating journal header in %s\",\n\t\t\t\t       __func__);\n\t}\n\tremove_all_from_journal_list(s, jl, 0);\n\tlist_del_init(&jl->j_list);\n\tjournal->j_num_lists--;\n\tdel_from_work_list(s, jl);\n\n\tif (journal->j_last_flush_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_flush_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2201\", \"last flush %lu, current %lu\",\n\t\t\t\t journal->j_last_flush_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_flush_id = jl->j_trans_id;\n\n\t \n\tjl->j_len = 0;\n\tatomic_set(&jl->j_nonzerolen, 0);\n\tjl->j_start = 0;\n\tjl->j_realblock = NULL;\n\tjl->j_commit_bh = NULL;\n\tjl->j_trans_id = 0;\n\tjl->j_state = 0;\n\tput_journal_list(s, jl);\n\tif (flushall)\n\t\tmutex_unlock(&journal->j_flush_mutex);\n\treturn err;\n}\n\nstatic int write_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t\t struct buffer_chunk *chunk)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tint ret = 0;\n\n\tjl->j_state |= LIST_TOUCHED;\n\tdel_from_work_list(s, jl);\n\tif (jl->j_len == 0 || atomic_read(&jl->j_nonzerolen) == 0) {\n\t\treturn 0;\n\t}\n\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\t \n\t\tif (cn->blocknr == 0) {\n\t\t\tgoto next;\n\t\t}\n\t\tif (cn->bh && can_dirty(cn) && buffer_dirty(cn->bh)) {\n\t\t\tstruct buffer_head *tmp_bh;\n\t\t\t \n\t\t\ttmp_bh = cn->bh;\n\t\t\tget_bh(tmp_bh);\n\t\t\tlock_buffer(tmp_bh);\n\t\t\tif (cn->bh && can_dirty(cn) && buffer_dirty(tmp_bh)) {\n\t\t\t\tif (!buffer_journal_dirty(tmp_bh) ||\n\t\t\t\t    buffer_journal_prepared(tmp_bh))\n\t\t\t\t\tBUG();\n\t\t\t\tadd_to_chunk(chunk, tmp_bh, NULL, write_chunk);\n\t\t\t\tret++;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tunlock_buffer(tmp_bh);\n\t\t\t}\n\t\t\tput_bh(tmp_bh);\n\t\t}\nnext:\n\t\tcn = cn->next;\n\t\tcond_resched();\n\t}\n\treturn ret;\n}\n\n \nstatic void dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_journal_list *pjl;\n\n\tjl->j_state |= LIST_DIRTY;\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\t \n\t\tpjl = find_newer_jl_for_cn(cn);\n\t\tif (!pjl && cn->blocknr && cn->bh\n\t\t    && buffer_journal_dirty(cn->bh)) {\n\t\t\tBUG_ON(!can_dirty(cn));\n\t\t\t \n\t\t\tclear_buffer_journal_new(cn->bh);\n\t\t\tif (buffer_journal_prepared(cn->bh)) {\n\t\t\t\tset_buffer_journal_restore_dirty(cn->bh);\n\t\t\t} else {\n\t\t\t\tset_buffer_journal_test(cn->bh);\n\t\t\t\tmark_buffer_dirty(cn->bh);\n\t\t\t}\n\t\t}\n\t\tcn = cn->next;\n\t}\n}\n\nstatic int kupdate_transactions(struct super_block *s,\n\t\t\t\tstruct reiserfs_journal_list *jl,\n\t\t\t\tstruct reiserfs_journal_list **next_jl,\n\t\t\t\tunsigned int *next_trans_id,\n\t\t\t\tint num_blocks, int num_trans)\n{\n\tint ret = 0;\n\tint written = 0;\n\tint transactions_flushed = 0;\n\tunsigned int orig_trans_id = jl->j_trans_id;\n\tstruct buffer_chunk chunk;\n\tstruct list_head *entry;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tchunk.nr = 0;\n\n\treiserfs_mutex_lock_safe(&journal->j_flush_mutex, s);\n\tif (!journal_list_still_alive(s, orig_trans_id)) {\n\t\tgoto done;\n\t}\n\n\t \n\twhile ((num_trans && transactions_flushed < num_trans) ||\n\t       (!num_trans && written < num_blocks)) {\n\n\t\tif (jl->j_len == 0 || (jl->j_state & LIST_TOUCHED) ||\n\t\t    atomic_read(&jl->j_commit_left)\n\t\t    || !(jl->j_state & LIST_DIRTY)) {\n\t\t\tdel_from_work_list(s, jl);\n\t\t\tbreak;\n\t\t}\n\t\tret = write_one_transaction(s, jl, &chunk);\n\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\ttransactions_flushed++;\n\t\twritten += ret;\n\t\tentry = jl->j_list.next;\n\n\t\t \n\t\tif (entry == &journal->j_journal_list) {\n\t\t\tbreak;\n\t\t}\n\t\tjl = JOURNAL_LIST_ENTRY(entry);\n\n\t\t \n\t\tif (jl->j_trans_id <= orig_trans_id)\n\t\t\tbreak;\n\t}\n\tif (chunk.nr) {\n\t\twrite_chunk(&chunk);\n\t}\n\ndone:\n\tmutex_unlock(&journal->j_flush_mutex);\n\treturn ret;\n}\n\n \nstatic int flush_used_journal_lists(struct super_block *s,\n\t\t\t\t    struct reiserfs_journal_list *jl)\n{\n\tunsigned long len = 0;\n\tunsigned long cur_len;\n\tint i;\n\tint limit = 256;\n\tstruct reiserfs_journal_list *tjl;\n\tstruct reiserfs_journal_list *flush_jl;\n\tunsigned int trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\n\tflush_jl = tjl = jl;\n\n\t \n\tif (reiserfs_data_log(s))\n\t\tlimit = 1024;\n\t \n\tfor (i = 0; i < 256 && len < limit; i++) {\n\t\tif (atomic_read(&tjl->j_commit_left) ||\n\t\t    tjl->j_trans_id < jl->j_trans_id) {\n\t\t\tbreak;\n\t\t}\n\t\tcur_len = atomic_read(&tjl->j_nonzerolen);\n\t\tif (cur_len > 0) {\n\t\t\ttjl->j_state &= ~LIST_TOUCHED;\n\t\t}\n\t\tlen += cur_len;\n\t\tflush_jl = tjl;\n\t\tif (tjl->j_list.next == &journal->j_journal_list)\n\t\t\tbreak;\n\t\ttjl = JOURNAL_LIST_ENTRY(tjl->j_list.next);\n\t}\n\tget_journal_list(jl);\n\tget_journal_list(flush_jl);\n\n\t \n\tif (flush_jl != jl)\n\t\tkupdate_transactions(s, jl, &tjl, &trans_id, len, i);\n\n\tflush_journal_list(s, flush_jl, 1);\n\tput_journal_list(s, flush_jl);\n\tput_journal_list(s, jl);\n\treturn 0;\n}\n\n \nstatic void remove_journal_hash(struct super_block *sb,\n\t\t\t struct reiserfs_journal_cnode **table,\n\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t unsigned long block, int remove_freed)\n{\n\tstruct reiserfs_journal_cnode *cur;\n\tstruct reiserfs_journal_cnode **head;\n\n\thead = &(journal_hash(table, sb, block));\n\tif (!head) {\n\t\treturn;\n\t}\n\tcur = *head;\n\twhile (cur) {\n\t\tif (cur->blocknr == block && cur->sb == sb\n\t\t    && (jl == NULL || jl == cur->jlist)\n\t\t    && (!test_bit(BLOCK_FREED, &cur->state) || remove_freed)) {\n\t\t\tif (cur->hnext) {\n\t\t\t\tcur->hnext->hprev = cur->hprev;\n\t\t\t}\n\t\t\tif (cur->hprev) {\n\t\t\t\tcur->hprev->hnext = cur->hnext;\n\t\t\t} else {\n\t\t\t\t*head = cur->hnext;\n\t\t\t}\n\t\t\tcur->blocknr = 0;\n\t\t\tcur->sb = NULL;\n\t\t\tcur->state = 0;\n\t\t\t \n\t\t\tif (cur->bh && cur->jlist)\n\t\t\t\tatomic_dec(&cur->jlist->j_nonzerolen);\n\t\t\tcur->bh = NULL;\n\t\t\tcur->jlist = NULL;\n\t\t}\n\t\tcur = cur->hnext;\n\t}\n}\n\nstatic void free_journal_ram(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tkfree(journal->j_current_jl);\n\tjournal->j_num_lists--;\n\n\tvfree(journal->j_cnode_free_orig);\n\tfree_list_bitmaps(sb, journal->j_list_bitmap);\n\tfree_bitmap_nodes(sb);\t \n\tif (journal->j_header_bh) {\n\t\tbrelse(journal->j_header_bh);\n\t}\n\t \n\trelease_journal_dev(sb, journal);\n\tvfree(journal);\n}\n\n \nstatic int do_journal_release(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb, int error)\n{\n\tstruct reiserfs_transaction_handle myth;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\t \n\tif (!error && !sb_rdonly(sb)) {\n\t\t \n\t\tBUG_ON(!th->t_trans_id);\n\t\tdo_journal_end(th, FLUSH_ALL);\n\n\t\t \n\t\tif (!journal_join(&myth, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&myth, SB_BUFFER_WITH_SB(sb));\n\t\t\tdo_journal_end(&myth, FLUSH_ALL);\n\t\t}\n\t}\n\n\t \n\tif (!error && reiserfs_is_journal_aborted(journal)) {\n\t\tmemset(&myth, 0, sizeof(myth));\n\t\tif (!journal_join_abort(&myth, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&myth, SB_BUFFER_WITH_SB(sb));\n\t\t\tdo_journal_end(&myth, FLUSH_ALL);\n\t\t}\n\t}\n\n\n\t \n\treiserfs_write_unlock(sb);\n\n\t \n\treiserfs_cancel_old_flush(sb);\n\t \n\tcancel_delayed_work_sync(&SB_JOURNAL(sb)->j_work);\n\n\tfree_journal_ram(sb);\n\n\treiserfs_write_lock(sb);\n\n\treturn 0;\n}\n\n \nint journal_release(struct reiserfs_transaction_handle *th,\n\t\t    struct super_block *sb)\n{\n\treturn do_journal_release(th, sb, 0);\n}\n\n \nint journal_release_error(struct reiserfs_transaction_handle *th,\n\t\t\t  struct super_block *sb)\n{\n\treturn do_journal_release(th, sb, 1);\n}\n\n \nstatic int journal_compare_desc_commit(struct super_block *sb,\n\t\t\t\t       struct reiserfs_journal_desc *desc,\n\t\t\t\t       struct reiserfs_journal_commit *commit)\n{\n\tif (get_commit_trans_id(commit) != get_desc_trans_id(desc) ||\n\t    get_commit_trans_len(commit) != get_desc_trans_len(desc) ||\n\t    get_commit_trans_len(commit) > SB_JOURNAL(sb)->j_trans_max ||\n\t    get_commit_trans_len(commit) <= 0) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int journal_transaction_is_valid(struct super_block *sb,\n\t\t\t\t\tstruct buffer_head *d_bh,\n\t\t\t\t\tunsigned int *oldest_invalid_trans_id,\n\t\t\t\t\tunsigned long *newest_mount_id)\n{\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tstruct buffer_head *c_bh;\n\tunsigned long offset;\n\n\tif (!d_bh)\n\t\treturn 0;\n\n\tdesc = (struct reiserfs_journal_desc *)d_bh->b_data;\n\tif (get_desc_trans_len(desc) > 0\n\t    && !memcmp(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8)) {\n\t\tif (oldest_invalid_trans_id && *oldest_invalid_trans_id\n\t\t    && get_desc_trans_id(desc) > *oldest_invalid_trans_id) {\n\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"journal-986: transaction \"\n\t\t\t\t       \"is valid returning because trans_id %d is greater than \"\n\t\t\t\t       \"oldest_invalid %lu\",\n\t\t\t\t       get_desc_trans_id(desc),\n\t\t\t\t       *oldest_invalid_trans_id);\n\t\t\treturn 0;\n\t\t}\n\t\tif (newest_mount_id\n\t\t    && *newest_mount_id > get_desc_mount_id(desc)) {\n\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"journal-1087: transaction \"\n\t\t\t\t       \"is valid returning because mount_id %d is less than \"\n\t\t\t\t       \"newest_mount_id %lu\",\n\t\t\t\t       get_desc_mount_id(desc),\n\t\t\t\t       *newest_mount_id);\n\t\t\treturn -1;\n\t\t}\n\t\tif (get_desc_trans_len(desc) > SB_JOURNAL(sb)->j_trans_max) {\n\t\t\treiserfs_warning(sb, \"journal-2018\",\n\t\t\t\t\t \"Bad transaction length %d \"\n\t\t\t\t\t \"encountered, ignoring transaction\",\n\t\t\t\t\t get_desc_trans_len(desc));\n\t\t\treturn -1;\n\t\t}\n\t\toffset = d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\n\t\t \n\t\tc_bh =\n\t\t    journal_bread(sb,\n\t\t\t\t  SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t  ((offset + get_desc_trans_len(desc) +\n\t\t\t\t    1) % SB_ONDISK_JOURNAL_SIZE(sb)));\n\t\tif (!c_bh)\n\t\t\treturn 0;\n\t\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\t\tif (journal_compare_desc_commit(sb, desc, commit)) {\n\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"journal_transaction_is_valid, commit offset %ld had bad \"\n\t\t\t\t       \"time %d or length %d\",\n\t\t\t\t       c_bh->b_blocknr -\n\t\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t\t       get_commit_trans_id(commit),\n\t\t\t\t       get_commit_trans_len(commit));\n\t\t\tbrelse(c_bh);\n\t\t\tif (oldest_invalid_trans_id) {\n\t\t\t\t*oldest_invalid_trans_id =\n\t\t\t\t    get_desc_trans_id(desc);\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1004: \"\n\t\t\t\t\t       \"transaction_is_valid setting oldest invalid trans_id \"\n\t\t\t\t\t       \"to %d\",\n\t\t\t\t\t       get_desc_trans_id(desc));\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tbrelse(c_bh);\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1006: found valid \"\n\t\t\t       \"transaction start offset %llu, len %d id %d\",\n\t\t\t       d_bh->b_blocknr -\n\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t       get_desc_trans_len(desc),\n\t\t\t       get_desc_trans_id(desc));\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic void brelse_array(struct buffer_head **heads, int num)\n{\n\tint i;\n\tfor (i = 0; i < num; i++) {\n\t\tbrelse(heads[i]);\n\t}\n}\n\n \nstatic int journal_read_transaction(struct super_block *sb,\n\t\t\t\t    unsigned long cur_dblock,\n\t\t\t\t    unsigned long oldest_start,\n\t\t\t\t    unsigned int oldest_trans_id,\n\t\t\t\t    unsigned long newest_mount_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tunsigned int trans_id = 0;\n\tstruct buffer_head *c_bh;\n\tstruct buffer_head *d_bh;\n\tstruct buffer_head **log_blocks = NULL;\n\tstruct buffer_head **real_blocks = NULL;\n\tunsigned int trans_offset;\n\tint i;\n\tint trans_half;\n\n\td_bh = journal_bread(sb, cur_dblock);\n\tif (!d_bh)\n\t\treturn 1;\n\tdesc = (struct reiserfs_journal_desc *)d_bh->b_data;\n\ttrans_offset = d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1037: \"\n\t\t       \"journal_read_transaction, offset %llu, len %d mount_id %d\",\n\t\t       d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t       get_desc_trans_len(desc), get_desc_mount_id(desc));\n\tif (get_desc_trans_id(desc) < oldest_trans_id) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1039: \"\n\t\t\t       \"journal_read_trans skipping because %lu is too old\",\n\t\t\t       cur_dblock -\n\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb));\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\tif (get_desc_mount_id(desc) != newest_mount_id) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1146: \"\n\t\t\t       \"journal_read_trans skipping because %d is != \"\n\t\t\t       \"newest_mount_id %lu\", get_desc_mount_id(desc),\n\t\t\t       newest_mount_id);\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\tc_bh = journal_bread(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t     ((trans_offset + get_desc_trans_len(desc) + 1) %\n\t\t\t      SB_ONDISK_JOURNAL_SIZE(sb)));\n\tif (!c_bh) {\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\tif (journal_compare_desc_commit(sb, desc, commit)) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal_read_transaction, \"\n\t\t\t       \"commit offset %llu had bad time %d or length %d\",\n\t\t\t       c_bh->b_blocknr -\n\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t       get_commit_trans_id(commit),\n\t\t\t       get_commit_trans_len(commit));\n\t\tbrelse(c_bh);\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\treiserfs_warning(sb, \"clm-2076\",\n\t\t\t\t \"device is readonly, unable to replay log\");\n\t\tbrelse(c_bh);\n\t\tbrelse(d_bh);\n\t\treturn -EROFS;\n\t}\n\n\ttrans_id = get_desc_trans_id(desc);\n\t \n\tlog_blocks = kmalloc_array(get_desc_trans_len(desc),\n\t\t\t\t   sizeof(struct buffer_head *),\n\t\t\t\t   GFP_NOFS);\n\treal_blocks = kmalloc_array(get_desc_trans_len(desc),\n\t\t\t\t    sizeof(struct buffer_head *),\n\t\t\t\t    GFP_NOFS);\n\tif (!log_blocks || !real_blocks) {\n\t\tbrelse(c_bh);\n\t\tbrelse(d_bh);\n\t\tkfree(log_blocks);\n\t\tkfree(real_blocks);\n\t\treiserfs_warning(sb, \"journal-1169\",\n\t\t\t\t \"kmalloc failed, unable to mount FS\");\n\t\treturn -1;\n\t}\n\t \n\ttrans_half = journal_trans_half(sb->s_blocksize);\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\t\tlog_blocks[i] =\n\t\t    journal_getblk(sb,\n\t\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t   (trans_offset + 1 +\n\t\t\t\t    i) % SB_ONDISK_JOURNAL_SIZE(sb));\n\t\tif (i < trans_half) {\n\t\t\treal_blocks[i] =\n\t\t\t    sb_getblk(sb,\n\t\t\t\t      le32_to_cpu(desc->j_realblock[i]));\n\t\t} else {\n\t\t\treal_blocks[i] =\n\t\t\t    sb_getblk(sb,\n\t\t\t\t      le32_to_cpu(commit->\n\t\t\t\t\t\t  j_realblock[i - trans_half]));\n\t\t}\n\t\tif (real_blocks[i]->b_blocknr > SB_BLOCK_COUNT(sb)) {\n\t\t\treiserfs_warning(sb, \"journal-1207\",\n\t\t\t\t\t \"REPLAY FAILURE fsck required! \"\n\t\t\t\t\t \"Block to replay is outside of \"\n\t\t\t\t\t \"filesystem\");\n\t\t\tgoto abort_replay;\n\t\t}\n\t\t \n\t\tif (is_block_in_log_or_reserved_area\n\t\t    (sb, real_blocks[i]->b_blocknr)) {\n\t\t\treiserfs_warning(sb, \"journal-1204\",\n\t\t\t\t\t \"REPLAY FAILURE fsck required! \"\n\t\t\t\t\t \"Trying to replay onto a log block\");\nabort_replay:\n\t\t\tbrelse_array(log_blocks, i);\n\t\t\tbrelse_array(real_blocks, i);\n\t\t\tbrelse(c_bh);\n\t\t\tbrelse(d_bh);\n\t\t\tkfree(log_blocks);\n\t\t\tkfree(real_blocks);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t \n\tbh_read_batch(get_desc_trans_len(desc), log_blocks);\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\n\t\twait_on_buffer(log_blocks[i]);\n\t\tif (!buffer_uptodate(log_blocks[i])) {\n\t\t\treiserfs_warning(sb, \"journal-1212\",\n\t\t\t\t\t \"REPLAY FAILURE fsck required! \"\n\t\t\t\t\t \"buffer write failed\");\n\t\t\tbrelse_array(log_blocks + i,\n\t\t\t\t     get_desc_trans_len(desc) - i);\n\t\t\tbrelse_array(real_blocks, get_desc_trans_len(desc));\n\t\t\tbrelse(c_bh);\n\t\t\tbrelse(d_bh);\n\t\t\tkfree(log_blocks);\n\t\t\tkfree(real_blocks);\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(real_blocks[i]->b_data, log_blocks[i]->b_data,\n\t\t       real_blocks[i]->b_size);\n\t\tset_buffer_uptodate(real_blocks[i]);\n\t\tbrelse(log_blocks[i]);\n\t}\n\t \n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\t\tset_buffer_dirty(real_blocks[i]);\n\t\twrite_dirty_buffer(real_blocks[i], 0);\n\t}\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\t\twait_on_buffer(real_blocks[i]);\n\t\tif (!buffer_uptodate(real_blocks[i])) {\n\t\t\treiserfs_warning(sb, \"journal-1226\",\n\t\t\t\t\t \"REPLAY FAILURE, fsck required! \"\n\t\t\t\t\t \"buffer write failed\");\n\t\t\tbrelse_array(real_blocks + i,\n\t\t\t\t     get_desc_trans_len(desc) - i);\n\t\t\tbrelse(c_bh);\n\t\t\tbrelse(d_bh);\n\t\t\tkfree(log_blocks);\n\t\t\tkfree(real_blocks);\n\t\t\treturn -1;\n\t\t}\n\t\tbrelse(real_blocks[i]);\n\t}\n\tcur_dblock =\n\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t    ((trans_offset + get_desc_trans_len(desc) +\n\t      2) % SB_ONDISK_JOURNAL_SIZE(sb));\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t       \"journal-1095: setting journal \" \"start to offset %ld\",\n\t\t       cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb));\n\n\t \n\tjournal->j_start = cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\tjournal->j_last_flush_trans_id = trans_id;\n\tjournal->j_trans_id = trans_id + 1;\n\t \n\tif (journal->j_trans_id == 0)\n\t\tjournal->j_trans_id = 10;\n\tbrelse(c_bh);\n\tbrelse(d_bh);\n\tkfree(log_blocks);\n\tkfree(real_blocks);\n\treturn 0;\n}\n\n \nstatic struct buffer_head *reiserfs_breada(struct block_device *dev,\n\t\t\t\t\t   b_blocknr_t block, int bufsize,\n\t\t\t\t\t   b_blocknr_t max_block)\n{\n\tstruct buffer_head *bhlist[BUFNR];\n\tunsigned int blocks = BUFNR;\n\tstruct buffer_head *bh;\n\tint i, j;\n\n\tbh = __getblk(dev, block, bufsize);\n\tif (!bh || buffer_uptodate(bh))\n\t\treturn (bh);\n\n\tif (block + BUFNR > max_block) {\n\t\tblocks = max_block - block;\n\t}\n\tbhlist[0] = bh;\n\tj = 1;\n\tfor (i = 1; i < blocks; i++) {\n\t\tbh = __getblk(dev, block + i, bufsize);\n\t\tif (!bh)\n\t\t\tbreak;\n\t\tif (buffer_uptodate(bh)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t} else\n\t\t\tbhlist[j++] = bh;\n\t}\n\tbh = bhlist[0];\n\tbh_read_nowait(bh, 0);\n\tbh_readahead_batch(j - 1, &bhlist[1], 0);\n\tfor (i = 1; i < j; i++)\n\t\tbrelse(bhlist[i]);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tbrelse(bh);\n\treturn NULL;\n}\n\n \nstatic int journal_read(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_desc *desc;\n\tunsigned int oldest_trans_id = 0;\n\tunsigned int oldest_invalid_trans_id = 0;\n\ttime64_t start;\n\tunsigned long oldest_start = 0;\n\tunsigned long cur_dblock = 0;\n\tunsigned long newest_mount_id = 9;\n\tstruct buffer_head *d_bh;\n\tstruct reiserfs_journal_header *jh;\n\tint valid_journal_header = 0;\n\tint replay_count = 0;\n\tint continue_replay = 1;\n\tint ret;\n\n\tcur_dblock = SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\treiserfs_info(sb, \"checking transaction log (%pg)\\n\",\n\t\t      journal->j_dev_bd);\n\tstart = ktime_get_seconds();\n\n\t \n\tjournal->j_header_bh = journal_bread(sb,\n\t\t\t\t\t     SB_ONDISK_JOURNAL_1st_BLOCK(sb)\n\t\t\t\t\t     + SB_ONDISK_JOURNAL_SIZE(sb));\n\tif (!journal->j_header_bh) {\n\t\treturn 1;\n\t}\n\tjh = (struct reiserfs_journal_header *)(journal->j_header_bh->b_data);\n\tif (le32_to_cpu(jh->j_first_unflushed_offset) <\n\t    SB_ONDISK_JOURNAL_SIZE(sb)\n\t    && le32_to_cpu(jh->j_last_flush_trans_id) > 0) {\n\t\toldest_start =\n\t\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t    le32_to_cpu(jh->j_first_unflushed_offset);\n\t\toldest_trans_id = le32_to_cpu(jh->j_last_flush_trans_id) + 1;\n\t\tnewest_mount_id = le32_to_cpu(jh->j_mount_id);\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1153: found in \"\n\t\t\t       \"header: first_unflushed_offset %d, last_flushed_trans_id \"\n\t\t\t       \"%lu\", le32_to_cpu(jh->j_first_unflushed_offset),\n\t\t\t       le32_to_cpu(jh->j_last_flush_trans_id));\n\t\tvalid_journal_header = 1;\n\n\t\t \n\t\td_bh =\n\t\t    journal_bread(sb,\n\t\t\t\t  SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t  le32_to_cpu(jh->j_first_unflushed_offset));\n\t\tret = journal_transaction_is_valid(sb, d_bh, NULL, NULL);\n\t\tif (!ret) {\n\t\t\tcontinue_replay = 0;\n\t\t}\n\t\tbrelse(d_bh);\n\t\tgoto start_log_replay;\n\t}\n\n\t \n\twhile (continue_replay\n\t       && cur_dblock <\n\t       (SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\tSB_ONDISK_JOURNAL_SIZE(sb))) {\n\t\t \n\t\td_bh =\n\t\t    reiserfs_breada(journal->j_dev_bd, cur_dblock,\n\t\t\t\t    sb->s_blocksize,\n\t\t\t\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb));\n\t\tret =\n\t\t    journal_transaction_is_valid(sb, d_bh,\n\t\t\t\t\t\t &oldest_invalid_trans_id,\n\t\t\t\t\t\t &newest_mount_id);\n\t\tif (ret == 1) {\n\t\t\tdesc = (struct reiserfs_journal_desc *)d_bh->b_data;\n\t\t\tif (oldest_start == 0) {\t \n\t\t\t\toldest_trans_id = get_desc_trans_id(desc);\n\t\t\t\toldest_start = d_bh->b_blocknr;\n\t\t\t\tnewest_mount_id = get_desc_mount_id(desc);\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1179: Setting \"\n\t\t\t\t\t       \"oldest_start to offset %llu, trans_id %lu\",\n\t\t\t\t\t       oldest_start -\n\t\t\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK\n\t\t\t\t\t       (sb), oldest_trans_id);\n\t\t\t} else if (oldest_trans_id > get_desc_trans_id(desc)) {\n\t\t\t\t \n\t\t\t\toldest_trans_id = get_desc_trans_id(desc);\n\t\t\t\toldest_start = d_bh->b_blocknr;\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1180: Resetting \"\n\t\t\t\t\t       \"oldest_start to offset %lu, trans_id %lu\",\n\t\t\t\t\t       oldest_start -\n\t\t\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK\n\t\t\t\t\t       (sb), oldest_trans_id);\n\t\t\t}\n\t\t\tif (newest_mount_id < get_desc_mount_id(desc)) {\n\t\t\t\tnewest_mount_id = get_desc_mount_id(desc);\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1299: Setting \"\n\t\t\t\t\t       \"newest_mount_id to %d\",\n\t\t\t\t\t       get_desc_mount_id(desc));\n\t\t\t}\n\t\t\tcur_dblock += get_desc_trans_len(desc) + 2;\n\t\t} else {\n\t\t\tcur_dblock++;\n\t\t}\n\t\tbrelse(d_bh);\n\t}\n\nstart_log_replay:\n\tcur_dblock = oldest_start;\n\tif (oldest_trans_id) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1206: Starting replay \"\n\t\t\t       \"from offset %llu, trans_id %lu\",\n\t\t\t       cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t       oldest_trans_id);\n\n\t}\n\treplay_count = 0;\n\twhile (continue_replay && oldest_trans_id > 0) {\n\t\tret =\n\t\t    journal_read_transaction(sb, cur_dblock, oldest_start,\n\t\t\t\t\t     oldest_trans_id, newest_mount_id);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t} else if (ret != 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcur_dblock =\n\t\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) + journal->j_start;\n\t\treplay_count++;\n\t\tif (cur_dblock == oldest_start)\n\t\t\tbreak;\n\t}\n\n\tif (oldest_trans_id == 0) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1225: No valid \" \"transactions found\");\n\t}\n\t \n\tif (valid_journal_header && replay_count == 0) {\n\t\tjournal->j_start = le32_to_cpu(jh->j_first_unflushed_offset);\n\t\tjournal->j_trans_id =\n\t\t    le32_to_cpu(jh->j_last_flush_trans_id) + 1;\n\t\t \n\t\tif (journal->j_trans_id == 0)\n\t\t\tjournal->j_trans_id = 10;\n\t\tjournal->j_last_flush_trans_id =\n\t\t    le32_to_cpu(jh->j_last_flush_trans_id);\n\t\tjournal->j_mount_id = le32_to_cpu(jh->j_mount_id) + 1;\n\t} else {\n\t\tjournal->j_mount_id = newest_mount_id + 1;\n\t}\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1299: Setting \"\n\t\t       \"newest_mount_id to %lu\", journal->j_mount_id);\n\tjournal->j_first_unflushed_offset = journal->j_start;\n\tif (replay_count > 0) {\n\t\treiserfs_info(sb,\n\t\t\t      \"replayed %d transactions in %lu seconds\\n\",\n\t\t\t      replay_count, ktime_get_seconds() - start);\n\t}\n\t \n\treiserfs_write_lock(sb);\n\tif (!bdev_read_only(sb->s_bdev) &&\n\t    _update_journal_header_block(sb, journal->j_start,\n\t\t\t\t\t journal->j_last_flush_trans_id)) {\n\t\treiserfs_write_unlock(sb);\n\t\t \n\t\treturn -1;\n\t}\n\treiserfs_write_unlock(sb);\n\treturn 0;\n}\n\nstatic struct reiserfs_journal_list *alloc_journal_list(struct super_block *s)\n{\n\tstruct reiserfs_journal_list *jl;\n\tjl = kzalloc(sizeof(struct reiserfs_journal_list),\n\t\t     GFP_NOFS | __GFP_NOFAIL);\n\tINIT_LIST_HEAD(&jl->j_list);\n\tINIT_LIST_HEAD(&jl->j_working_list);\n\tINIT_LIST_HEAD(&jl->j_tail_bh_list);\n\tINIT_LIST_HEAD(&jl->j_bh_list);\n\tmutex_init(&jl->j_commit_mutex);\n\tSB_JOURNAL(s)->j_num_lists++;\n\tget_journal_list(jl);\n\treturn jl;\n}\n\nstatic void journal_list_init(struct super_block *sb)\n{\n\tSB_JOURNAL(sb)->j_current_jl = alloc_journal_list(sb);\n}\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal)\n{\n\tif (journal->j_dev_bd != NULL) {\n\t\tvoid *holder = NULL;\n\n\t\tif (journal->j_dev_bd->bd_dev != super->s_dev)\n\t\t\tholder = journal;\n\n\t\tblkdev_put(journal->j_dev_bd, holder);\n\t\tjournal->j_dev_bd = NULL;\n\t}\n}\n\nstatic int journal_init_dev(struct super_block *super,\n\t\t\t    struct reiserfs_journal *journal,\n\t\t\t    const char *jdev_name)\n{\n\tblk_mode_t blkdev_mode = BLK_OPEN_READ;\n\tvoid *holder = journal;\n\tint result;\n\tdev_t jdev;\n\n\tresult = 0;\n\n\tjournal->j_dev_bd = NULL;\n\tjdev = SB_ONDISK_JOURNAL_DEVICE(super) ?\n\t    new_decode_dev(SB_ONDISK_JOURNAL_DEVICE(super)) : super->s_dev;\n\n\tif (!bdev_read_only(super->s_bdev))\n\t\tblkdev_mode |= BLK_OPEN_WRITE;\n\n\t \n\tif ((!jdev_name || !jdev_name[0])) {\n\t\tif (jdev == super->s_dev)\n\t\t\tholder = NULL;\n\t\tjournal->j_dev_bd = blkdev_get_by_dev(jdev, blkdev_mode, holder,\n\t\t\t\t\t\t      NULL);\n\t\tif (IS_ERR(journal->j_dev_bd)) {\n\t\t\tresult = PTR_ERR(journal->j_dev_bd);\n\t\t\tjournal->j_dev_bd = NULL;\n\t\t\treiserfs_warning(super, \"sh-458\",\n\t\t\t\t\t \"cannot init journal device unknown-block(%u,%u): %i\",\n\t\t\t\t\t MAJOR(jdev), MINOR(jdev), result);\n\t\t\treturn result;\n\t\t} else if (jdev != super->s_dev)\n\t\t\tset_blocksize(journal->j_dev_bd, super->s_blocksize);\n\n\t\treturn 0;\n\t}\n\n\tjournal->j_dev_bd = blkdev_get_by_path(jdev_name, blkdev_mode, holder,\n\t\t\t\t\t       NULL);\n\tif (IS_ERR(journal->j_dev_bd)) {\n\t\tresult = PTR_ERR(journal->j_dev_bd);\n\t\tjournal->j_dev_bd = NULL;\n\t\treiserfs_warning(super, \"sh-457\",\n\t\t\t\t \"journal_init_dev: Cannot open '%s': %i\",\n\t\t\t\t jdev_name, result);\n\t\treturn result;\n\t}\n\n\tset_blocksize(journal->j_dev_bd, super->s_blocksize);\n\treiserfs_info(super,\n\t\t      \"journal_init_dev: journal device: %pg\\n\",\n\t\t      journal->j_dev_bd);\n\treturn 0;\n}\n\n \n#define REISERFS_STANDARD_BLKSIZE (4096)\n\nstatic int check_advise_trans_params(struct super_block *sb,\n\t\t\t\t     struct reiserfs_journal *journal)\n{\n        if (journal->j_trans_max) {\n\t\t \n\t        int ratio = 1;\n\t\tif (sb->s_blocksize < REISERFS_STANDARD_BLKSIZE)\n\t\t        ratio = REISERFS_STANDARD_BLKSIZE / sb->s_blocksize;\n\n\t\tif (journal->j_trans_max > JOURNAL_TRANS_MAX_DEFAULT / ratio ||\n\t\t    journal->j_trans_max < JOURNAL_TRANS_MIN_DEFAULT / ratio ||\n\t\t    SB_ONDISK_JOURNAL_SIZE(sb) / journal->j_trans_max <\n\t\t    JOURNAL_MIN_RATIO) {\n\t\t\treiserfs_warning(sb, \"sh-462\",\n\t\t\t\t\t \"bad transaction max size (%u). \"\n\t\t\t\t\t \"FSCK?\", journal->j_trans_max);\n\t\t\treturn 1;\n\t\t}\n\t\tif (journal->j_max_batch != (journal->j_trans_max) *\n\t\t        JOURNAL_MAX_BATCH_DEFAULT/JOURNAL_TRANS_MAX_DEFAULT) {\n\t\t\treiserfs_warning(sb, \"sh-463\",\n\t\t\t\t\t \"bad transaction max batch (%u). \"\n\t\t\t\t\t \"FSCK?\", journal->j_max_batch);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\t \n\t\tif (sb->s_blocksize != REISERFS_STANDARD_BLKSIZE) {\n\t\t\treiserfs_warning(sb, \"sh-464\", \"bad blocksize (%u)\",\n\t\t\t\t\t sb->s_blocksize);\n\t\t\treturn 1;\n\t\t}\n\t\tjournal->j_trans_max = JOURNAL_TRANS_MAX_DEFAULT;\n\t\tjournal->j_max_batch = JOURNAL_MAX_BATCH_DEFAULT;\n\t\tjournal->j_max_commit_age = JOURNAL_MAX_COMMIT_AGE;\n\t}\n\treturn 0;\n}\n\n \nint journal_init(struct super_block *sb, const char *j_dev_name,\n\t\t int old_format, unsigned int commit_max_age)\n{\n\tint num_cnodes = SB_ONDISK_JOURNAL_SIZE(sb) * 2;\n\tstruct buffer_head *bhjh;\n\tstruct reiserfs_super_block *rs;\n\tstruct reiserfs_journal_header *jh;\n\tstruct reiserfs_journal *journal;\n\tstruct reiserfs_journal_list *jl;\n\tint ret;\n\n\tjournal = SB_JOURNAL(sb) = vzalloc(sizeof(struct reiserfs_journal));\n\tif (!journal) {\n\t\treiserfs_warning(sb, \"journal-1256\",\n\t\t\t\t \"unable to get memory for journal structure\");\n\t\treturn 1;\n\t}\n\tINIT_LIST_HEAD(&journal->j_bitmap_nodes);\n\tINIT_LIST_HEAD(&journal->j_prealloc_list);\n\tINIT_LIST_HEAD(&journal->j_working_list);\n\tINIT_LIST_HEAD(&journal->j_journal_list);\n\tjournal->j_persistent_trans = 0;\n\tif (reiserfs_allocate_list_bitmaps(sb, journal->j_list_bitmap,\n\t\t\t\t\t   reiserfs_bmap_count(sb)))\n\t\tgoto free_and_return;\n\n\tallocate_bitmap_nodes(sb);\n\n\t \n\tSB_JOURNAL_1st_RESERVED_BLOCK(sb) = (old_format ?\n\t\t\t\t\t\t REISERFS_OLD_DISK_OFFSET_IN_BYTES\n\t\t\t\t\t\t / sb->s_blocksize +\n\t\t\t\t\t\t reiserfs_bmap_count(sb) +\n\t\t\t\t\t\t 1 :\n\t\t\t\t\t\t REISERFS_DISK_OFFSET_IN_BYTES /\n\t\t\t\t\t\t sb->s_blocksize + 2);\n\n\t \n\tif (!SB_ONDISK_JOURNAL_DEVICE(sb) &&\n\t    (SB_JOURNAL_1st_RESERVED_BLOCK(sb) +\n\t     SB_ONDISK_JOURNAL_SIZE(sb) > sb->s_blocksize * 8)) {\n\t\treiserfs_warning(sb, \"journal-1393\",\n\t\t\t\t \"journal does not fit for area addressed \"\n\t\t\t\t \"by first of bitmap blocks. It starts at \"\n\t\t\t\t \"%u and its size is %u. Block size %ld\",\n\t\t\t\t SB_JOURNAL_1st_RESERVED_BLOCK(sb),\n\t\t\t\t SB_ONDISK_JOURNAL_SIZE(sb),\n\t\t\t\t sb->s_blocksize);\n\t\tgoto free_and_return;\n\t}\n\n\t \n\tif (!SB_ONDISK_JOURNAL_DEVICE(sb) &&\n\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) < SB_JOURNAL_1st_RESERVED_BLOCK(sb)) {\n\t\treiserfs_warning(sb, \"journal-1393\",\n\t\t\t\t \"journal 1st super block is invalid: 1st reserved block %d, but actual 1st block is %d\",\n\t\t\t\t SB_JOURNAL_1st_RESERVED_BLOCK(sb),\n\t\t\t\t SB_ONDISK_JOURNAL_1st_BLOCK(sb));\n\t\tgoto free_and_return;\n\t}\n\n\tif (journal_init_dev(sb, journal, j_dev_name) != 0) {\n\t\treiserfs_warning(sb, \"sh-462\",\n\t\t\t\t \"unable to initialize journal device\");\n\t\tgoto free_and_return;\n\t}\n\n\trs = SB_DISK_SUPER_BLOCK(sb);\n\n\t \n\tbhjh = journal_bread(sb,\n\t\t\t     SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb));\n\tif (!bhjh) {\n\t\treiserfs_warning(sb, \"sh-459\",\n\t\t\t\t \"unable to read journal header\");\n\t\tgoto free_and_return;\n\t}\n\tjh = (struct reiserfs_journal_header *)(bhjh->b_data);\n\n\t \n\tif (is_reiserfs_jr(rs)\n\t    && (le32_to_cpu(jh->jh_journal.jp_journal_magic) !=\n\t\tsb_jp_journal_magic(rs))) {\n\t\treiserfs_warning(sb, \"sh-460\",\n\t\t\t\t \"journal header magic %x (device %pg) does \"\n\t\t\t\t \"not match to magic found in super block %x\",\n\t\t\t\t jh->jh_journal.jp_journal_magic,\n\t\t\t\t journal->j_dev_bd,\n\t\t\t\t sb_jp_journal_magic(rs));\n\t\tbrelse(bhjh);\n\t\tgoto free_and_return;\n\t}\n\n\tjournal->j_trans_max = le32_to_cpu(jh->jh_journal.jp_journal_trans_max);\n\tjournal->j_max_batch = le32_to_cpu(jh->jh_journal.jp_journal_max_batch);\n\tjournal->j_max_commit_age =\n\t    le32_to_cpu(jh->jh_journal.jp_journal_max_commit_age);\n\tjournal->j_max_trans_age = JOURNAL_MAX_TRANS_AGE;\n\n\tif (check_advise_trans_params(sb, journal) != 0)\n\t        goto free_and_return;\n\tjournal->j_default_max_commit_age = journal->j_max_commit_age;\n\n\tif (commit_max_age != 0) {\n\t\tjournal->j_max_commit_age = commit_max_age;\n\t\tjournal->j_max_trans_age = commit_max_age;\n\t}\n\n\treiserfs_info(sb, \"journal params: device %pg, size %u, \"\n\t\t      \"journal first block %u, max trans len %u, max batch %u, \"\n\t\t      \"max commit age %u, max trans age %u\\n\",\n\t\t      journal->j_dev_bd,\n\t\t      SB_ONDISK_JOURNAL_SIZE(sb),\n\t\t      SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t      journal->j_trans_max,\n\t\t      journal->j_max_batch,\n\t\t      journal->j_max_commit_age, journal->j_max_trans_age);\n\n\tbrelse(bhjh);\n\n\tjournal->j_list_bitmap_index = 0;\n\tjournal_list_init(sb);\n\n\tmemset(journal->j_list_hash_table, 0,\n\t       JOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *));\n\n\tINIT_LIST_HEAD(&journal->j_dirty_buffers);\n\tspin_lock_init(&journal->j_dirty_buffers_lock);\n\n\tjournal->j_start = 0;\n\tjournal->j_len = 0;\n\tjournal->j_len_alloc = 0;\n\tatomic_set(&journal->j_wcount, 0);\n\tatomic_set(&journal->j_async_throttle, 0);\n\tjournal->j_bcount = 0;\n\tjournal->j_trans_start_time = 0;\n\tjournal->j_last = NULL;\n\tjournal->j_first = NULL;\n\tinit_waitqueue_head(&journal->j_join_wait);\n\tmutex_init(&journal->j_mutex);\n\tmutex_init(&journal->j_flush_mutex);\n\n\tjournal->j_trans_id = 10;\n\tjournal->j_mount_id = 10;\n\tjournal->j_state = 0;\n\tatomic_set(&journal->j_jlock, 0);\n\tjournal->j_cnode_free_list = allocate_cnodes(num_cnodes);\n\tjournal->j_cnode_free_orig = journal->j_cnode_free_list;\n\tjournal->j_cnode_free = journal->j_cnode_free_list ? num_cnodes : 0;\n\tjournal->j_cnode_used = 0;\n\tjournal->j_must_wait = 0;\n\n\tif (journal->j_cnode_free == 0) {\n\t\treiserfs_warning(sb, \"journal-2004\", \"Journal cnode memory \"\n\t\t                 \"allocation failed (%ld bytes). Journal is \"\n\t\t                 \"too large for available memory. Usually \"\n\t\t                 \"this is due to a journal that is too large.\",\n\t\t                 sizeof (struct reiserfs_journal_cnode) * num_cnodes);\n        \tgoto free_and_return;\n\t}\n\n\tinit_journal_hash(sb);\n\tjl = journal->j_current_jl;\n\n\t \n\treiserfs_write_lock(sb);\n\tjl->j_list_bitmap = get_list_bitmap(sb, jl);\n\treiserfs_write_unlock(sb);\n\tif (!jl->j_list_bitmap) {\n\t\treiserfs_warning(sb, \"journal-2005\",\n\t\t\t\t \"get_list_bitmap failed for journal list 0\");\n\t\tgoto free_and_return;\n\t}\n\n\tret = journal_read(sb);\n\tif (ret < 0) {\n\t\treiserfs_warning(sb, \"reiserfs-2006\",\n\t\t\t\t \"Replay Failure, unable to mount\");\n\t\tgoto free_and_return;\n\t}\n\n\tINIT_DELAYED_WORK(&journal->j_work, flush_async_commits);\n\tjournal->j_work_sb = sb;\n\treturn 0;\nfree_and_return:\n\tfree_journal_ram(sb);\n\treturn 1;\n}\n\n \nint journal_transaction_should_end(struct reiserfs_transaction_handle *th,\n\t\t\t\t   int new_alloc)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(th->t_super);\n\ttime64_t now = ktime_get_seconds();\n\t \n\tBUG_ON(!th->t_trans_id);\n\tif (th->t_refcount > 1)\n\t\treturn 0;\n\tif (journal->j_must_wait > 0 ||\n\t    (journal->j_len_alloc + new_alloc) >= journal->j_max_batch ||\n\t    atomic_read(&journal->j_jlock) ||\n\t    (now - journal->j_trans_start_time) > journal->j_max_trans_age ||\n\t    journal->j_cnode_free < (journal->j_trans_max * 3)) {\n\t\treturn 1;\n\t}\n\n\tjournal->j_len_alloc += new_alloc;\n\tth->t_blocks_allocated += new_alloc ;\n\treturn 0;\n}\n\n \nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(th->t_super);\n\tBUG_ON(!th->t_trans_id);\n\tjournal->j_must_wait = 1;\n\tset_bit(J_WRITERS_BLOCKED, &journal->j_state);\n\treturn;\n}\n\n \nvoid reiserfs_allow_writes(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tclear_bit(J_WRITERS_BLOCKED, &journal->j_state);\n\twake_up(&journal->j_join_wait);\n}\n\n \nvoid reiserfs_wait_on_write_block(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\twait_event(journal->j_join_wait,\n\t\t   !test_bit(J_WRITERS_BLOCKED, &journal->j_state));\n}\n\nstatic void queue_log_writer(struct super_block *s)\n{\n\twait_queue_entry_t wait;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tset_bit(J_WRITERS_QUEUED, &journal->j_state);\n\n\t \n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&journal->j_join_wait, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (test_bit(J_WRITERS_QUEUED, &journal->j_state)) {\n\t\tint depth = reiserfs_write_unlock_nested(s);\n\t\tschedule();\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&journal->j_join_wait, &wait);\n}\n\nstatic void wake_queued_writers(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tif (test_and_clear_bit(J_WRITERS_QUEUED, &journal->j_state))\n\t\twake_up(&journal->j_join_wait);\n}\n\nstatic void let_transaction_grow(struct super_block *sb, unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tunsigned long bcount = journal->j_bcount;\n\twhile (1) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\tschedule_timeout_uninterruptible(1);\n\t\treiserfs_write_lock_nested(sb, depth);\n\n\t\tjournal->j_current_jl->j_state |= LIST_COMMIT_PENDING;\n\t\twhile ((atomic_read(&journal->j_wcount) > 0 ||\n\t\t\tatomic_read(&journal->j_jlock)) &&\n\t\t       journal->j_trans_id == trans_id) {\n\t\t\tqueue_log_writer(sb);\n\t\t}\n\t\tif (journal->j_trans_id != trans_id)\n\t\t\tbreak;\n\t\tif (bcount == journal->j_bcount)\n\t\t\tbreak;\n\t\tbcount = journal->j_bcount;\n\t}\n}\n\n \nstatic int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb, unsigned long nblocks,\n\t\t\t      int join)\n{\n\ttime64_t now = ktime_get_seconds();\n\tunsigned int old_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_transaction_handle myth;\n\tint retval;\n\tint depth;\n\n\treiserfs_check_lock_depth(sb, \"journal_begin\");\n\tBUG_ON(nblocks > journal->j_trans_max);\n\n\tPROC_INFO_INC(sb, journal.journal_being);\n\t \n\tth->t_refcount = 1;\n\tth->t_super = sb;\n\nrelock:\n\tlock_journal(sb);\n\tif (join != JBEGIN_ABORT && reiserfs_is_journal_aborted(journal)) {\n\t\tunlock_journal(sb);\n\t\tretval = journal->j_errno;\n\t\tgoto out_fail;\n\t}\n\tjournal->j_bcount++;\n\n\tif (test_bit(J_WRITERS_BLOCKED, &journal->j_state)) {\n\t\tunlock_journal(sb);\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\treiserfs_wait_on_write_block(sb);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t\tPROC_INFO_INC(sb, journal.journal_relock_writers);\n\t\tgoto relock;\n\t}\n\tnow = ktime_get_seconds();\n\n\t \n\n\tif ((!join && journal->j_must_wait > 0) ||\n\t    (!join\n\t     && (journal->j_len_alloc + nblocks + 2) >= journal->j_max_batch)\n\t    || (!join && atomic_read(&journal->j_wcount) > 0\n\t\t&& journal->j_trans_start_time > 0\n\t\t&& (now - journal->j_trans_start_time) >\n\t\tjournal->j_max_trans_age) || (!join\n\t\t\t\t\t      && atomic_read(&journal->j_jlock))\n\t    || (!join && journal->j_cnode_free < (journal->j_trans_max * 3))) {\n\n\t\told_trans_id = journal->j_trans_id;\n\t\t \n\t\tunlock_journal(sb);\n\n\t\tif (!join && (journal->j_len_alloc + nblocks + 2) >=\n\t\t    journal->j_max_batch &&\n\t\t    ((journal->j_len + nblocks + 2) * 100) <\n\t\t    (journal->j_len_alloc * 75)) {\n\t\t\tif (atomic_read(&journal->j_wcount) > 10) {\n\t\t\t\tqueue_log_writer(sb);\n\t\t\t\tgoto relock;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (atomic_read(&journal->j_jlock)) {\n\t\t\twhile (journal->j_trans_id == old_trans_id &&\n\t\t\t       atomic_read(&journal->j_jlock)) {\n\t\t\t\tqueue_log_writer(sb);\n\t\t\t}\n\t\t\tgoto relock;\n\t\t}\n\t\tretval = journal_join(&myth, sb);\n\t\tif (retval)\n\t\t\tgoto out_fail;\n\n\t\t \n\t\tif (old_trans_id != journal->j_trans_id) {\n\t\t\tretval = do_journal_end(&myth, 0);\n\t\t} else {\n\t\t\tretval = do_journal_end(&myth, COMMIT_NOW);\n\t\t}\n\n\t\tif (retval)\n\t\t\tgoto out_fail;\n\n\t\tPROC_INFO_INC(sb, journal.journal_relock_wcount);\n\t\tgoto relock;\n\t}\n\t \n\tif (journal->j_trans_start_time == 0) {\n\t\tjournal->j_trans_start_time = ktime_get_seconds();\n\t}\n\tatomic_inc(&journal->j_wcount);\n\tjournal->j_len_alloc += nblocks;\n\tth->t_blocks_logged = 0;\n\tth->t_blocks_allocated = nblocks;\n\tth->t_trans_id = journal->j_trans_id;\n\tunlock_journal(sb);\n\tINIT_LIST_HEAD(&th->t_list);\n\treturn 0;\n\nout_fail:\n\tmemset(th, 0, sizeof(*th));\n\t \n\tth->t_super = sb;\n\treturn retval;\n}\n\nstruct reiserfs_transaction_handle *reiserfs_persistent_transaction(struct\n\t\t\t\t\t\t\t\t    super_block\n\t\t\t\t\t\t\t\t    *s,\n\t\t\t\t\t\t\t\t    int nblocks)\n{\n\tint ret;\n\tstruct reiserfs_transaction_handle *th;\n\n\t \n\tif (reiserfs_transaction_running(s)) {\n\t\tth = current->journal_info;\n\t\tth->t_refcount++;\n\t\tBUG_ON(th->t_refcount < 2);\n\n\t\treturn th;\n\t}\n\tth = kmalloc(sizeof(struct reiserfs_transaction_handle), GFP_NOFS);\n\tif (!th)\n\t\treturn NULL;\n\tret = journal_begin(th, s, nblocks);\n\tif (ret) {\n\t\tkfree(th);\n\t\treturn NULL;\n\t}\n\n\tSB_JOURNAL(s)->j_persistent_trans++;\n\treturn th;\n}\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *s = th->t_super;\n\tint ret = 0;\n\tif (th->t_trans_id)\n\t\tret = journal_end(th);\n\telse\n\t\tret = -EIO;\n\tif (th->t_refcount == 0) {\n\t\tSB_JOURNAL(s)->j_persistent_trans--;\n\t\tkfree(th);\n\t}\n\treturn ret;\n}\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\n\t \n\tth->t_handle_save = cur_th;\n\tBUG_ON(cur_th && cur_th->t_refcount > 1);\n\treturn do_journal_begin_r(th, sb, 1, JBEGIN_JOIN);\n}\n\nint journal_join_abort(struct reiserfs_transaction_handle *th,\n\t\t       struct super_block *sb)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\n\t \n\tth->t_handle_save = cur_th;\n\tBUG_ON(cur_th && cur_th->t_refcount > 1);\n\treturn do_journal_begin_r(th, sb, 1, JBEGIN_ABORT);\n}\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t \n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t \n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t \n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}\n\n \nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t \n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t \n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t \n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}\n\nint journal_end(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tif (!current->journal_info && th->t_refcount > 1)\n\t\treiserfs_warning(sb, \"REISER-NESTING\",\n\t\t\t\t \"th NULL, refcount %d\", th->t_refcount);\n\n\tif (!th->t_trans_id) {\n\t\tWARN_ON(1);\n\t\treturn -EIO;\n\t}\n\n\tth->t_refcount--;\n\tif (th->t_refcount > 0) {\n\t\tstruct reiserfs_transaction_handle *cur_th =\n\t\t    current->journal_info;\n\n\t\t \n\t\tBUG_ON(cur_th->t_super != th->t_super);\n\n\t\tif (th != cur_th) {\n\t\t\tmemcpy(current->journal_info, th, sizeof(*th));\n\t\t\tth->t_trans_id = 0;\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\treturn do_journal_end(th, 0);\n\t}\n}\n\n \nstatic int remove_from_transaction(struct super_block *sb,\n\t\t\t\t   b_blocknr_t blocknr, int already_cleaned)\n{\n\tstruct buffer_head *bh;\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tint ret = 0;\n\n\tcn = get_journal_hash_dev(sb, journal->j_hash_table, blocknr);\n\tif (!cn || !cn->bh) {\n\t\treturn ret;\n\t}\n\tbh = cn->bh;\n\tif (cn->prev) {\n\t\tcn->prev->next = cn->next;\n\t}\n\tif (cn->next) {\n\t\tcn->next->prev = cn->prev;\n\t}\n\tif (cn == journal->j_first) {\n\t\tjournal->j_first = cn->next;\n\t}\n\tif (cn == journal->j_last) {\n\t\tjournal->j_last = cn->prev;\n\t}\n\tremove_journal_hash(sb, journal->j_hash_table, NULL,\n\t\t\t    bh->b_blocknr, 0);\n\tclear_buffer_journaled(bh);\t \n\n\tif (!already_cleaned) {\n\t\tclear_buffer_journal_dirty(bh);\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_journal_test(bh);\n\t\tput_bh(bh);\n\t\tif (atomic_read(&bh->b_count) < 0) {\n\t\t\treiserfs_warning(sb, \"journal-1752\",\n\t\t\t\t\t \"b_count < 0\");\n\t\t}\n\t\tret = 1;\n\t}\n\tjournal->j_len--;\n\tjournal->j_len_alloc--;\n\tfree_cnode(sb, cn);\n\treturn ret;\n}\n\n \nstatic int can_dirty(struct reiserfs_journal_cnode *cn)\n{\n\tstruct super_block *sb = cn->sb;\n\tb_blocknr_t blocknr = cn->blocknr;\n\tstruct reiserfs_journal_cnode *cur = cn->hprev;\n\tint can_dirty = 1;\n\n\t \n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->bh && cur->blocknr && cur->sb == sb &&\n\t\t    cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hprev;\n\t}\n\t \n\tcur = cn->hnext;\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->jlist->j_len > 0 &&\n\t\t    atomic_read(&cur->jlist->j_commit_left) > 0 && cur->bh &&\n\t\t    cur->blocknr && cur->sb == sb && cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hnext;\n\t}\n\treturn can_dirty;\n}\n\n \nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t \n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}\n\n \nstatic void flush_async_commits(struct work_struct *work)\n{\n\tstruct reiserfs_journal *journal =\n\t\tcontainer_of(work, struct reiserfs_journal, j_work.work);\n\tstruct super_block *sb = journal->j_work_sb;\n\tstruct reiserfs_journal_list *jl;\n\tstruct list_head *entry;\n\n\treiserfs_write_lock(sb);\n\tif (!list_empty(&journal->j_journal_list)) {\n\t\t \n\t\tentry = journal->j_journal_list.prev;\n\t\tjl = JOURNAL_LIST_ENTRY(entry);\n\t\tflush_commit_list(sb, jl, 1);\n\t}\n\treiserfs_write_unlock(sb);\n}\n\n \nvoid reiserfs_flush_old_commits(struct super_block *sb)\n{\n\ttime64_t now;\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tnow = ktime_get_seconds();\n\t \n\tif (list_empty(&journal->j_journal_list))\n\t\treturn;\n\n\t \n\tif (atomic_read(&journal->j_wcount) <= 0 &&\n\t    journal->j_trans_start_time > 0 &&\n\t    journal->j_len > 0 &&\n\t    (now - journal->j_trans_start_time) > journal->j_max_trans_age) {\n\t\tif (!journal_join(&th, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(sb));\n\n\t\t\t \n\t\t\tdo_journal_end(&th, COMMIT_NOW | WAIT);\n\t\t}\n\t}\n}\n\n \nstatic int check_journal_end(struct reiserfs_transaction_handle *th, int flags)\n{\n\n\ttime64_t now;\n\tint flush = flags & FLUSH_ALL;\n\tint commit_now = flags & COMMIT_NOW;\n\tint wait_on_commit = flags & WAIT;\n\tstruct reiserfs_journal_list *jl;\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tjournal->j_len_alloc -= (th->t_blocks_allocated - th->t_blocks_logged);\n\t \n\tif (atomic_read(&journal->j_wcount) > 0)\n\t\tatomic_dec(&journal->j_wcount);\n\n\t \n\tBUG_ON(journal->j_len == 0);\n\n\t \n\tif (atomic_read(&journal->j_wcount) > 0) {\n\t\tif (flush || commit_now) {\n\t\t\tunsigned trans_id;\n\n\t\t\tjl = journal->j_current_jl;\n\t\t\ttrans_id = jl->j_trans_id;\n\t\t\tif (wait_on_commit)\n\t\t\t\tjl->j_state |= LIST_COMMIT_PENDING;\n\t\t\tatomic_set(&journal->j_jlock, 1);\n\t\t\tif (flush) {\n\t\t\t\tjournal->j_next_full_flush = 1;\n\t\t\t}\n\t\t\tunlock_journal(sb);\n\n\t\t\t \n\t\t\twhile (journal->j_trans_id == trans_id) {\n\t\t\t\tif (atomic_read(&journal->j_jlock)) {\n\t\t\t\t\tqueue_log_writer(sb);\n\t\t\t\t} else {\n\t\t\t\t\tlock_journal(sb);\n\t\t\t\t\tif (journal->j_trans_id == trans_id) {\n\t\t\t\t\t\tatomic_set(&journal->j_jlock,\n\t\t\t\t\t\t\t   1);\n\t\t\t\t\t}\n\t\t\t\t\tunlock_journal(sb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tBUG_ON(journal->j_trans_id == trans_id);\n\n\t\t\tif (commit_now\n\t\t\t    && journal_list_still_alive(sb, trans_id)\n\t\t\t    && wait_on_commit) {\n\t\t\t\tflush_commit_list(sb, jl, 1);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tunlock_journal(sb);\n\t\treturn 0;\n\t}\n\n\t \n\tnow = ktime_get_seconds();\n\tif ((now - journal->j_trans_start_time) > journal->j_max_trans_age) {\n\t\tcommit_now = 1;\n\t\tjournal->j_next_async_flush = 1;\n\t}\n\t \n\t \n\tif (!(journal->j_must_wait > 0) && !(atomic_read(&journal->j_jlock))\n\t    && !flush && !commit_now && (journal->j_len < journal->j_max_batch)\n\t    && journal->j_len_alloc < journal->j_max_batch\n\t    && journal->j_cnode_free > (journal->j_trans_max * 3)) {\n\t\tjournal->j_bcount++;\n\t\tunlock_journal(sb);\n\t\treturn 0;\n\t}\n\n\tif (journal->j_start > SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\treiserfs_panic(sb, \"journal-003\",\n\t\t\t       \"j_start (%ld) is too high\",\n\t\t\t       journal->j_start);\n\t}\n\treturn 1;\n}\n\n \nint journal_mark_freed(struct reiserfs_transaction_handle *th,\n\t\t       struct super_block *sb, b_blocknr_t blocknr)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tstruct buffer_head *bh = NULL;\n\tstruct reiserfs_list_bitmap *jb = NULL;\n\tint cleaned = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tcn = get_journal_hash_dev(sb, journal->j_hash_table, blocknr);\n\tif (cn && cn->bh) {\n\t\tbh = cn->bh;\n\t\tget_bh(bh);\n\t}\n\t \n\tif (bh && buffer_journal_new(bh)) {\n\t\tclear_buffer_journal_new(bh);\n\t\tclear_prepared_bits(bh);\n\t\treiserfs_clean_and_file_buffer(bh);\n\t\tcleaned = remove_from_transaction(sb, blocknr, cleaned);\n\t} else {\n\t\t \n\t\tjb = journal->j_current_jl->j_list_bitmap;\n\t\tif (!jb) {\n\t\t\treiserfs_panic(sb, \"journal-1702\",\n\t\t\t\t       \"journal_list_bitmap is NULL\");\n\t\t}\n\t\tset_bit_in_list_bitmap(sb, blocknr, jb);\n\n\t\t \n\n\t\tif (bh) {\n\t\t\tclear_prepared_bits(bh);\n\t\t\treiserfs_clean_and_file_buffer(bh);\n\t\t}\n\t\tcleaned = remove_from_transaction(sb, blocknr, cleaned);\n\n\t\t \n\t\tcn = get_journal_hash_dev(sb, journal->j_list_hash_table,\n\t\t\t\t\t  blocknr);\n\t\twhile (cn) {\n\t\t\tif (sb == cn->sb && blocknr == cn->blocknr) {\n\t\t\t\tset_bit(BLOCK_FREED, &cn->state);\n\t\t\t\tif (cn->bh) {\n\t\t\t\t\t \n\t\t\t\t\tif (!cleaned) {\n\t\t\t\t\t\tclear_buffer_journal_dirty(cn->\n\t\t\t\t\t\t\t\t\t   bh);\n\t\t\t\t\t\tclear_buffer_dirty(cn->bh);\n\t\t\t\t\t\tclear_buffer_journal_test(cn->\n\t\t\t\t\t\t\t\t\t  bh);\n\t\t\t\t\t\tcleaned = 1;\n\t\t\t\t\t\tput_bh(cn->bh);\n\t\t\t\t\t\tif (atomic_read\n\t\t\t\t\t\t    (&cn->bh->b_count) < 0) {\n\t\t\t\t\t\t\treiserfs_warning(sb,\n\t\t\t\t\t\t\t\t \"journal-2138\",\n\t\t\t\t\t\t\t\t \"cn->bh->b_count < 0\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t \n\t\t\t\t\tif (cn->jlist) {\n\t\t\t\t\t\tatomic_dec(&cn->jlist->\n\t\t\t\t\t\t\t   j_nonzerolen);\n\t\t\t\t\t}\n\t\t\t\t\tcn->bh = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcn = cn->hnext;\n\t\t}\n\t}\n\n\tif (bh)\n\t\trelease_buffer_page(bh);  \n\treturn 0;\n}\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}\n\n \nstatic int __commit_trans_jl(struct inode *inode, unsigned long id,\n\t\t\t     struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_transaction_handle th;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tint ret = 0;\n\n\t \n\tif (id == journal->j_trans_id) {\n\t\tjl = journal->j_current_jl;\n\t\t \n\t\tlet_transaction_grow(sb, id);\n\t\tif (journal->j_trans_id != id) {\n\t\t\tgoto flush_commit_only;\n\t\t}\n\n\t\tret = journal_begin(&th, sb, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (journal->j_trans_id != id) {\n\t\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(sb));\n\t\t\tret = journal_end(&th);\n\t\t\tgoto flush_commit_only;\n\t\t}\n\n\t\tret = journal_end_sync(&th);\n\t\tif (!ret)\n\t\t\tret = 1;\n\n\t} else {\n\t\t \nflush_commit_only:\n\t\tif (journal_list_still_alive(inode->i_sb, id)) {\n\t\t\t \n\t\t\tif (atomic_read(&jl->j_commit_left) > 1)\n\t\t\t\tret = 1;\n\t\t\tflush_commit_list(sb, jl, 1);\n\t\t\tif (journal->j_errno)\n\t\t\t\tret = journal->j_errno;\n\t\t}\n\t}\n\t \n\treturn ret;\n}\n\nint reiserfs_commit_for_inode(struct inode *inode)\n{\n\tunsigned int id = REISERFS_I(inode)->i_trans_id;\n\tstruct reiserfs_journal_list *jl = REISERFS_I(inode)->i_jl;\n\n\t \n\tif (!id || !jl) {\n\t\treiserfs_update_inode_transaction(inode);\n\t\tid = REISERFS_I(inode)->i_trans_id;\n\t\t \n\t}\n\n\treturn __commit_trans_jl(inode, id, jl);\n}\n\nvoid reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}\n\nextern struct tree_balance *cur_tb;\n \nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}\n\n \nstatic int do_journal_end(struct reiserfs_transaction_handle *th, int flags)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn, *next, *jl_cn;\n\tstruct reiserfs_journal_cnode *last_cn = NULL;\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tstruct buffer_head *c_bh;\t \n\tstruct buffer_head *d_bh;\t \n\tint cur_write_start = 0;\t \n\tint i;\n\tint flush;\n\tint wait_on_commit;\n\tstruct reiserfs_journal_list *jl, *temp_jl;\n\tstruct list_head *entry, *safe;\n\tunsigned long jindex;\n\tunsigned int commit_trans_id;\n\tint trans_half;\n\tint depth;\n\n\tBUG_ON(th->t_refcount > 1);\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(!th->t_super);\n\n\t \n\tif (th->t_trans_id == ~0U)\n\t\tflags |= FLUSH_ALL | COMMIT_NOW | WAIT;\n\tflush = flags & FLUSH_ALL;\n\twait_on_commit = flags & WAIT;\n\n\tcurrent->journal_info = th->t_handle_save;\n\treiserfs_check_lock_depth(sb, \"journal end\");\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\n\tlock_journal(sb);\n\tif (journal->j_next_full_flush) {\n\t\tflags |= FLUSH_ALL;\n\t\tflush = 1;\n\t}\n\tif (journal->j_next_async_flush) {\n\t\tflags |= COMMIT_NOW | WAIT;\n\t\twait_on_commit = 1;\n\t}\n\n\t \n\tif (!check_journal_end(th, flags)) {\n\t\treiserfs_schedule_old_flush(sb);\n\t\twake_queued_writers(sb);\n\t\treiserfs_async_progress_wait(sb);\n\t\tgoto out;\n\t}\n\n\t \n\tif (journal->j_next_full_flush) {\n\t\tflush = 1;\n\t}\n\n\t \n\tif (journal->j_must_wait > 0) {\n\t\tflush = 1;\n\t}\n#ifdef REISERFS_PREALLOCATE\n\t \n\tcurrent->journal_info = th;\n\tth->t_refcount++;\n\n\t \n\treiserfs_discard_all_prealloc(th);\n\n\tth->t_refcount--;\n\tcurrent->journal_info = th->t_handle_save;\n#endif\n\n\t \n\td_bh =\n\t    journal_getblk(sb,\n\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t   journal->j_start);\n\tset_buffer_uptodate(d_bh);\n\tdesc = (struct reiserfs_journal_desc *)(d_bh)->b_data;\n\tmemset(d_bh->b_data, 0, d_bh->b_size);\n\tmemcpy(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\n\t \n\tc_bh = journal_getblk(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t      ((journal->j_start + journal->j_len +\n\t\t\t\t1) % SB_ONDISK_JOURNAL_SIZE(sb)));\n\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\tmemset(c_bh->b_data, 0, c_bh->b_size);\n\tset_commit_trans_id(commit, journal->j_trans_id);\n\tset_buffer_uptodate(c_bh);\n\n\t \n\tjl = journal->j_current_jl;\n\n\t \n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, sb);\n\n\t \n\tcommit_trans_id = jl->j_trans_id;\n\n\tatomic_set(&jl->j_older_commits_done, 0);\n\tjl->j_trans_id = journal->j_trans_id;\n\tjl->j_timestamp = journal->j_trans_start_time;\n\tjl->j_commit_bh = c_bh;\n\tjl->j_start = journal->j_start;\n\tjl->j_len = journal->j_len;\n\tatomic_set(&jl->j_nonzerolen, journal->j_len);\n\tatomic_set(&jl->j_commit_left, journal->j_len + 2);\n\tjl->j_realblock = NULL;\n\n\t \n\ttrans_half = journal_trans_half(sb->s_blocksize);\n\tfor (i = 0, cn = journal->j_first; cn; cn = cn->next, i++) {\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tjl_cn = get_cnode(sb);\n\t\t\tif (!jl_cn) {\n\t\t\t\treiserfs_panic(sb, \"journal-1676\",\n\t\t\t\t\t       \"get_cnode returned NULL\");\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\tjl->j_realblock = jl_cn;\n\t\t\t}\n\t\t\tjl_cn->prev = last_cn;\n\t\t\tjl_cn->next = NULL;\n\t\t\tif (last_cn) {\n\t\t\t\tlast_cn->next = jl_cn;\n\t\t\t}\n\t\t\tlast_cn = jl_cn;\n\t\t\t \n\t\t\tif (is_block_in_log_or_reserved_area\n\t\t\t    (sb, cn->bh->b_blocknr)) {\n\t\t\t\treiserfs_panic(sb, \"journal-2332\",\n\t\t\t\t\t       \"Trying to log block %lu, \"\n\t\t\t\t\t       \"which is a log block\",\n\t\t\t\t\t       cn->bh->b_blocknr);\n\t\t\t}\n\t\t\tjl_cn->blocknr = cn->bh->b_blocknr;\n\t\t\tjl_cn->state = 0;\n\t\t\tjl_cn->sb = sb;\n\t\t\tjl_cn->bh = cn->bh;\n\t\t\tjl_cn->jlist = jl;\n\t\t\tinsert_journal_hash(journal->j_list_hash_table, jl_cn);\n\t\t\tif (i < trans_half) {\n\t\t\t\tdesc->j_realblock[i] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t} else {\n\t\t\t\tcommit->j_realblock[i - trans_half] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t}\n\tset_desc_trans_len(desc, journal->j_len);\n\tset_desc_mount_id(desc, journal->j_mount_id);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\tset_commit_trans_len(commit, journal->j_len);\n\n\t \n\tBUG_ON(journal->j_len == 0);\n\n\t \n\tmark_buffer_dirty(d_bh);\n\n\t \n\tcur_write_start = journal->j_start;\n\tcn = journal->j_first;\n\tjindex = 1;\t \n\twhile (cn) {\n\t\tclear_buffer_journal_new(cn->bh);\n\t\t \n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tstruct buffer_head *tmp_bh;\n\t\t\tchar *addr;\n\t\t\tstruct page *page;\n\t\t\ttmp_bh =\n\t\t\t    journal_getblk(sb,\n\t\t\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t\t   ((cur_write_start +\n\t\t\t\t\t     jindex) %\n\t\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb)));\n\t\t\tset_buffer_uptodate(tmp_bh);\n\t\t\tpage = cn->bh->b_page;\n\t\t\taddr = kmap(page);\n\t\t\tmemcpy(tmp_bh->b_data,\n\t\t\t       addr + offset_in_page(cn->bh->b_data),\n\t\t\t       cn->bh->b_size);\n\t\t\tkunmap(page);\n\t\t\tmark_buffer_dirty(tmp_bh);\n\t\t\tjindex++;\n\t\t\tset_buffer_journal_dirty(cn->bh);\n\t\t\tclear_buffer_journaled(cn->bh);\n\t\t} else {\n\t\t\t \n\t\t\treiserfs_warning(sb, \"journal-2048\",\n\t\t\t\t\t \"BAD, buffer in journal hash, \"\n\t\t\t\t\t \"but not JDirty!\");\n\t\t\tbrelse(cn->bh);\n\t\t}\n\t\tnext = cn->next;\n\t\tfree_cnode(sb, cn);\n\t\tcn = next;\n\t\treiserfs_cond_resched(sb);\n\t}\n\n\t \n\n\tjournal->j_current_jl = alloc_journal_list(sb);\n\n\t \n\tlist_add_tail(&jl->j_list, &journal->j_journal_list);\n\tlist_add_tail(&jl->j_working_list, &journal->j_working_list);\n\tjournal->j_num_work_lists++;\n\n\t \n\tjournal->j_start =\n\t    (journal->j_start + journal->j_len +\n\t     2) % SB_ONDISK_JOURNAL_SIZE(sb);\n\tatomic_set(&journal->j_wcount, 0);\n\tjournal->j_bcount = 0;\n\tjournal->j_last = NULL;\n\tjournal->j_first = NULL;\n\tjournal->j_len = 0;\n\tjournal->j_trans_start_time = 0;\n\t \n\tif (++journal->j_trans_id == 0)\n\t\tjournal->j_trans_id = 10;\n\tjournal->j_current_jl->j_trans_id = journal->j_trans_id;\n\tjournal->j_must_wait = 0;\n\tjournal->j_len_alloc = 0;\n\tjournal->j_next_full_flush = 0;\n\tjournal->j_next_async_flush = 0;\n\tinit_journal_hash(sb);\n\n\t \n\tsmp_mb();\n\n\t \n\tif (!list_empty(&jl->j_tail_bh_list)) {\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\twrite_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t      journal, jl, &jl->j_tail_bh_list);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_tail_bh_list));\n\tmutex_unlock(&jl->j_commit_mutex);\n\n\t \n\tif (flush) {\n\t\tflush_commit_list(sb, jl, 1);\n\t\tflush_journal_list(sb, jl, 1);\n\t} else if (!(jl->j_state & LIST_COMMIT_PENDING)) {\n\t\t \n\t\tif (sb->s_flags & SB_ACTIVE)\n\t\t\tqueue_delayed_work(REISERFS_SB(sb)->commit_wq,\n\t\t\t\t\t   &journal->j_work, HZ / 10);\n\t}\n\n\t \nfirst_jl:\n\tlist_for_each_safe(entry, safe, &journal->j_journal_list) {\n\t\ttemp_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tif (journal->j_start <= temp_jl->j_start) {\n\t\t\tif ((journal->j_start + journal->j_trans_max + 1) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else if ((journal->j_start +\n\t\t\t\t    journal->j_trans_max + 1) <\n\t\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((journal->j_start +\n\t\t\t    journal->j_trans_max + 1) >\n\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\tif (((journal->j_start + journal->j_trans_max + 1) %\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb)) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tjournal->j_current_jl->j_list_bitmap =\n\t    get_list_bitmap(sb, journal->j_current_jl);\n\n\tif (!(journal->j_current_jl->j_list_bitmap)) {\n\t\treiserfs_panic(sb, \"journal-1996\",\n\t\t\t       \"could not get a list bitmap\");\n\t}\n\n\tatomic_set(&journal->j_jlock, 0);\n\tunlock_journal(sb);\n\t \n\tclear_bit(J_WRITERS_QUEUED, &journal->j_state);\n\twake_up(&journal->j_join_wait);\n\n\tif (!flush && wait_on_commit &&\n\t    journal_list_still_alive(sb, commit_trans_id)) {\n\t\tflush_commit_list(sb, jl, 1);\n\t}\nout:\n\treiserfs_check_lock_depth(sb, \"journal end2\");\n\n\tmemset(th, 0, sizeof(*th));\n\t \n\tth->t_super = sb;\n\n\treturn journal->j_errno;\n}\n\n \nvoid reiserfs_abort_journal(struct super_block *sb, int errno)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tif (test_bit(J_ABORTED, &journal->j_state))\n\t\treturn;\n\n\tif (!journal->j_errno)\n\t\tjournal->j_errno = errno;\n\n\tsb->s_flags |= SB_RDONLY;\n\tset_bit(J_ABORTED, &journal->j_state);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}