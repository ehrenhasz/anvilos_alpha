{
  "module_name": "xattr.c",
  "hash_id": "564fdd02fefe86192f36d5b298e967249b38f430037ccd0b930dc0fad5046ef6",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/xattr.c",
  "human_readable_source": "\n \n\n \n\n#include \"reiserfs.h\"\n#include <linux/capability.h>\n#include <linux/dcache.h>\n#include <linux/namei.h>\n#include <linux/errno.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include <linux/uaccess.h>\n#include <net/checksum.h>\n#include <linux/stat.h>\n#include <linux/quotaops.h>\n#include <linux/security.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n\n#define PRIVROOT_NAME \".reiserfs_priv\"\n#define XAROOT_NAME   \"xattrs\"\n\n\n \n#ifdef CONFIG_REISERFS_FS_XATTR\nstatic int xattr_create(struct inode *dir, struct dentry *dentry, int mode)\n{\n\tBUG_ON(!inode_is_locked(dir));\n\treturn dir->i_op->create(&nop_mnt_idmap, dir, dentry, mode, true);\n}\n#endif\n\nstatic int xattr_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tBUG_ON(!inode_is_locked(dir));\n\treturn dir->i_op->mkdir(&nop_mnt_idmap, dir, dentry, mode);\n}\n\n \nstatic int xattr_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error;\n\n\tBUG_ON(!inode_is_locked(dir));\n\n\tinode_lock_nested(d_inode(dentry), I_MUTEX_CHILD);\n\terror = dir->i_op->unlink(dir, dentry);\n\tinode_unlock(d_inode(dentry));\n\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}\n\nstatic int xattr_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error;\n\n\tBUG_ON(!inode_is_locked(dir));\n\n\tinode_lock_nested(d_inode(dentry), I_MUTEX_CHILD);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (!error)\n\t\td_inode(dentry)->i_flags |= S_DEAD;\n\tinode_unlock(d_inode(dentry));\n\tif (!error)\n\t\td_delete(dentry);\n\n\treturn error;\n}\n\n#define xattr_may_create(flags)\t(!flags || flags & XATTR_CREATE)\n\nstatic struct dentry *open_xa_root(struct super_block *sb, int flags)\n{\n\tstruct dentry *privroot = REISERFS_SB(sb)->priv_root;\n\tstruct dentry *xaroot;\n\n\tif (d_really_is_negative(privroot))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tinode_lock_nested(d_inode(privroot), I_MUTEX_XATTR);\n\n\txaroot = dget(REISERFS_SB(sb)->xattr_root);\n\tif (!xaroot)\n\t\txaroot = ERR_PTR(-EOPNOTSUPP);\n\telse if (d_really_is_negative(xaroot)) {\n\t\tint err = -ENODATA;\n\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_mkdir(d_inode(privroot), xaroot, 0700);\n\t\tif (err) {\n\t\t\tdput(xaroot);\n\t\t\txaroot = ERR_PTR(err);\n\t\t}\n\t}\n\n\tinode_unlock(d_inode(privroot));\n\treturn xaroot;\n}\n\nstatic struct dentry *open_xa_dir(const struct inode *inode, int flags)\n{\n\tstruct dentry *xaroot, *xadir;\n\tchar namebuf[17];\n\n\txaroot = open_xa_root(inode->i_sb, flags);\n\tif (IS_ERR(xaroot))\n\t\treturn xaroot;\n\n\tsnprintf(namebuf, sizeof(namebuf), \"%X.%X\",\n\t\t le32_to_cpu(INODE_PKEY(inode)->k_objectid),\n\t\t inode->i_generation);\n\n\tinode_lock_nested(d_inode(xaroot), I_MUTEX_XATTR);\n\n\txadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));\n\tif (!IS_ERR(xadir) && d_really_is_negative(xadir)) {\n\t\tint err = -ENODATA;\n\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_mkdir(d_inode(xaroot), xadir, 0700);\n\t\tif (err) {\n\t\t\tdput(xadir);\n\t\t\txadir = ERR_PTR(err);\n\t\t}\n\t}\n\n\tinode_unlock(d_inode(xaroot));\n\tdput(xaroot);\n\treturn xadir;\n}\n\n \nstruct reiserfs_dentry_buf {\n\tstruct dir_context ctx;\n\tstruct dentry *xadir;\n\tint count;\n\tint err;\n\tstruct dentry *dentries[8];\n};\n\nstatic bool\nfill_with_dentries(struct dir_context *ctx, const char *name, int namelen,\n\t\t   loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct reiserfs_dentry_buf *dbuf =\n\t\tcontainer_of(ctx, struct reiserfs_dentry_buf, ctx);\n\tstruct dentry *dentry;\n\n\tWARN_ON_ONCE(!inode_is_locked(d_inode(dbuf->xadir)));\n\n\tif (dbuf->count == ARRAY_SIZE(dbuf->dentries))\n\t\treturn false;\n\n\tif (name[0] == '.' && (namelen < 2 ||\n\t\t\t       (namelen == 2 && name[1] == '.')))\n\t\treturn true;\n\n\tdentry = lookup_one_len(name, dbuf->xadir, namelen);\n\tif (IS_ERR(dentry)) {\n\t\tdbuf->err = PTR_ERR(dentry);\n\t\treturn false;\n\t} else if (d_really_is_negative(dentry)) {\n\t\t \n\t\treiserfs_error(dentry->d_sb, \"xattr-20003\",\n\t\t\t       \"Corrupted directory: xattr %pd listed but \"\n\t\t\t       \"not found for file %pd.\\n\",\n\t\t\t       dentry, dbuf->xadir);\n\t\tdput(dentry);\n\t\tdbuf->err = -EIO;\n\t\treturn false;\n\t}\n\n\tdbuf->dentries[dbuf->count++] = dentry;\n\treturn true;\n}\n\nstatic void\ncleanup_dentry_buf(struct reiserfs_dentry_buf *buf)\n{\n\tint i;\n\n\tfor (i = 0; i < buf->count; i++)\n\t\tif (buf->dentries[i])\n\t\t\tdput(buf->dentries[i]);\n}\n\nstatic int reiserfs_for_each_xattr(struct inode *inode,\n\t\t\t\t   int (*action)(struct dentry *, void *),\n\t\t\t\t   void *data)\n{\n\tstruct dentry *dir;\n\tint i, err = 0;\n\tstruct reiserfs_dentry_buf buf = {\n\t\t.ctx.actor = fill_with_dentries,\n\t};\n\n\t \n\tif (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn 0;\n\n\tdir = open_xa_dir(inode, XATTR_REPLACE);\n\tif (IS_ERR(dir)) {\n\t\terr = PTR_ERR(dir);\n\t\tgoto out;\n\t} else if (d_really_is_negative(dir)) {\n\t\terr = 0;\n\t\tgoto out_dir;\n\t}\n\n\tinode_lock_nested(d_inode(dir), I_MUTEX_XATTR);\n\n\tbuf.xadir = dir;\n\twhile (1) {\n\t\terr = reiserfs_readdir_inode(d_inode(dir), &buf.ctx);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (buf.err) {\n\t\t\terr = buf.err;\n\t\t\tbreak;\n\t\t}\n\t\tif (!buf.count)\n\t\t\tbreak;\n\t\tfor (i = 0; !err && i < buf.count && buf.dentries[i]; i++) {\n\t\t\tstruct dentry *dentry = buf.dentries[i];\n\n\t\t\tif (!d_is_dir(dentry))\n\t\t\t\terr = action(dentry, data);\n\n\t\t\tdput(dentry);\n\t\t\tbuf.dentries[i] = NULL;\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t\tbuf.count = 0;\n\t}\n\tinode_unlock(d_inode(dir));\n\n\tcleanup_dentry_buf(&buf);\n\n\tif (!err) {\n\t\t \n\t\tint blocks = JOURNAL_PER_BALANCE_CNT * 2 + 2 +\n\t\t\t     4 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\t\tstruct reiserfs_transaction_handle th;\n\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terr = journal_begin(&th, inode->i_sb, blocks);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (!err) {\n\t\t\tint jerror;\n\n\t\t\tinode_lock_nested(d_inode(dir->d_parent),\n\t\t\t\t\t  I_MUTEX_XATTR);\n\t\t\terr = action(dir, data);\n\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\tjerror = journal_end(&th);\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\tinode_unlock(d_inode(dir->d_parent));\n\t\t\terr = jerror ?: err;\n\t\t}\n\t}\nout_dir:\n\tdput(dir);\nout:\n\t \n\tif (err == -ENODATA || err == -EOPNOTSUPP)\n\t\terr = 0;\n\treturn err;\n}\n\nstatic int delete_one_xattr(struct dentry *dentry, void *data)\n{\n\tstruct inode *dir = d_inode(dentry->d_parent);\n\n\t \n\tif (d_is_dir(dentry))\n\t\treturn xattr_rmdir(dir, dentry);\n\n\treturn xattr_unlink(dir, dentry);\n}\n\nstatic int chown_one_xattr(struct dentry *dentry, void *data)\n{\n\tstruct iattr *attrs = data;\n\tint ia_valid = attrs->ia_valid;\n\tint err;\n\n\t \n\tattrs->ia_valid &= (ATTR_UID|ATTR_GID);\n\terr = reiserfs_setattr(&nop_mnt_idmap, dentry, attrs);\n\tattrs->ia_valid = ia_valid;\n\n\treturn err;\n}\n\n \nint reiserfs_delete_xattrs(struct inode *inode)\n{\n\tint err = reiserfs_for_each_xattr(inode, delete_one_xattr, NULL);\n\n\tif (err)\n\t\treiserfs_warning(inode->i_sb, \"jdm-20004\",\n\t\t\t\t \"Couldn't delete all xattrs (%d)\\n\", err);\n\treturn err;\n}\n\n \nint reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)\n{\n\tint err = reiserfs_for_each_xattr(inode, chown_one_xattr, attrs);\n\n\tif (err)\n\t\treiserfs_warning(inode->i_sb, \"jdm-20007\",\n\t\t\t\t \"Couldn't chown all xattrs (%d)\\n\", err);\n\treturn err;\n}\n\n#ifdef CONFIG_REISERFS_FS_XATTR\n \nstatic struct dentry *xattr_lookup(struct inode *inode, const char *name,\n\t\t\t\t    int flags)\n{\n\tstruct dentry *xadir, *xafile;\n\tint err = 0;\n\n\txadir = open_xa_dir(inode, flags);\n\tif (IS_ERR(xadir))\n\t\treturn ERR_CAST(xadir);\n\n\tinode_lock_nested(d_inode(xadir), I_MUTEX_XATTR);\n\txafile = lookup_one_len(name, xadir, strlen(name));\n\tif (IS_ERR(xafile)) {\n\t\terr = PTR_ERR(xafile);\n\t\tgoto out;\n\t}\n\n\tif (d_really_is_positive(xafile) && (flags & XATTR_CREATE))\n\t\terr = -EEXIST;\n\n\tif (d_really_is_negative(xafile)) {\n\t\terr = -ENODATA;\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_create(d_inode(xadir), xafile,\n\t\t\t\t\t      0700|S_IFREG);\n\t}\n\n\tif (err)\n\t\tdput(xafile);\nout:\n\tinode_unlock(d_inode(xadir));\n\tdput(xadir);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn xafile;\n}\n\n \nstatic inline void reiserfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}\n\nstatic struct page *reiserfs_get_page(struct inode *dir, size_t n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page;\n\t \n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tpage = read_mapping_page(mapping, n >> PAGE_SHIFT, NULL);\n\tif (!IS_ERR(page))\n\t\tkmap(page);\n\treturn page;\n}\n\nstatic inline __u32 xattr_hash(const char *msg, int len)\n{\n\t \n\treturn csum_partial(msg, len, 0);\n}\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic void update_ctime(struct inode *inode)\n{\n\tstruct timespec64 now = current_time(inode);\n\tstruct timespec64 ctime = inode_get_ctime(inode);\n\n\tif (inode_unhashed(inode) || !inode->i_nlink ||\n\t    timespec64_equal(&ctime, &now))\n\t\treturn;\n\n\tinode_set_ctime_to_ts(inode, now);\n\tmark_inode_dirty(inode);\n}\n\nstatic int lookup_and_delete_xattr(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct dentry *dentry, *xadir;\n\n\txadir = open_xa_dir(inode, XATTR_REPLACE);\n\tif (IS_ERR(xadir))\n\t\treturn PTR_ERR(xadir);\n\n\tinode_lock_nested(d_inode(xadir), I_MUTEX_XATTR);\n\tdentry = lookup_one_len(name, xadir, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out_dput;\n\t}\n\n\tif (d_really_is_positive(dentry)) {\n\t\terr = xattr_unlink(d_inode(xadir), dentry);\n\t\tupdate_ctime(inode);\n\t}\n\n\tdput(dentry);\nout_dput:\n\tinode_unlock(d_inode(xadir));\n\tdput(xadir);\n\treturn err;\n}\n\n\n \n\n \nint\nreiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,\n\t\t\t  struct inode *inode, const char *name,\n\t\t\t  const void *buffer, size_t buffer_size, int flags)\n{\n\tint err = 0;\n\tstruct dentry *dentry;\n\tstruct page *page;\n\tchar *data;\n\tsize_t file_pos = 0;\n\tsize_t buffer_pos = 0;\n\tsize_t new_size;\n\t__u32 xahash = 0;\n\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!buffer) {\n\t\terr = lookup_and_delete_xattr(inode, name);\n\t\treturn err;\n\t}\n\n\tdentry = xattr_lookup(inode, name, flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tdown_write(&REISERFS_I(inode)->i_xattr_sem);\n\n\txahash = xattr_hash(buffer, buffer_size);\n\twhile (buffer_pos < buffer_size || buffer_pos == 0) {\n\t\tsize_t chunk;\n\t\tsize_t skip = 0;\n\t\tsize_t page_offset = (file_pos & (PAGE_SIZE - 1));\n\n\t\tif (buffer_size - buffer_pos > PAGE_SIZE)\n\t\t\tchunk = PAGE_SIZE;\n\t\telse\n\t\t\tchunk = buffer_size - buffer_pos;\n\n\t\tpage = reiserfs_get_page(d_inode(dentry), file_pos);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tlock_page(page);\n\t\tdata = page_address(page);\n\n\t\tif (file_pos == 0) {\n\t\t\tstruct reiserfs_xattr_header *rxh;\n\n\t\t\tskip = file_pos = sizeof(struct reiserfs_xattr_header);\n\t\t\tif (chunk + skip > PAGE_SIZE)\n\t\t\t\tchunk = PAGE_SIZE - skip;\n\t\t\trxh = (struct reiserfs_xattr_header *)data;\n\t\t\trxh->h_magic = cpu_to_le32(REISERFS_XATTR_MAGIC);\n\t\t\trxh->h_hash = cpu_to_le32(xahash);\n\t\t}\n\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terr = __reiserfs_write_begin(page, page_offset, chunk + skip);\n\t\tif (!err) {\n\t\t\tif (buffer)\n\t\t\t\tmemcpy(data + skip, buffer + buffer_pos, chunk);\n\t\t\terr = reiserfs_commit_write(NULL, page, page_offset,\n\t\t\t\t\t\t    page_offset + chunk +\n\t\t\t\t\t\t    skip);\n\t\t}\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tunlock_page(page);\n\t\treiserfs_put_page(page);\n\t\tbuffer_pos += chunk;\n\t\tfile_pos += chunk;\n\t\tskip = 0;\n\t\tif (err || buffer_size == 0 || !buffer)\n\t\t\tbreak;\n\t}\n\n\tnew_size = buffer_size + sizeof(struct reiserfs_xattr_header);\n\tif (!err && new_size < i_size_read(d_inode(dentry))) {\n\t\tstruct iattr newattrs = {\n\t\t\t.ia_ctime = current_time(inode),\n\t\t\t.ia_size = new_size,\n\t\t\t.ia_valid = ATTR_SIZE | ATTR_CTIME,\n\t\t};\n\n\t\tinode_lock_nested(d_inode(dentry), I_MUTEX_XATTR);\n\t\tinode_dio_wait(d_inode(dentry));\n\n\t\terr = reiserfs_setattr(&nop_mnt_idmap, dentry, &newattrs);\n\t\tinode_unlock(d_inode(dentry));\n\t} else\n\t\tupdate_ctime(inode);\nout_unlock:\n\tup_write(&REISERFS_I(inode)->i_xattr_sem);\n\tdput(dentry);\n\treturn err;\n}\n\n \nint reiserfs_xattr_set(struct inode *inode, const char *name,\n\t\t       const void *buffer, size_t buffer_size, int flags)\n{\n\n\tstruct reiserfs_transaction_handle th;\n\tint error, error2;\n\tsize_t jbegin_count = reiserfs_xattr_nblocks(inode, buffer_size);\n\n\t \n\tif (!d_really_is_positive(REISERFS_SB(inode->i_sb)->priv_root))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(flags & XATTR_REPLACE))\n\t\tjbegin_count += reiserfs_xattr_jcreate_nblocks(inode);\n\n\treiserfs_write_lock(inode->i_sb);\n\terror = journal_begin(&th, inode->i_sb, jbegin_count);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error) {\n\t\treturn error;\n\t}\n\n\terror = reiserfs_xattr_set_handle(&th, inode, name,\n\t\t\t\t\t  buffer, buffer_size, flags);\n\n\treiserfs_write_lock(inode->i_sb);\n\terror2 = journal_end(&th);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error == 0)\n\t\terror = error2;\n\n\treturn error;\n}\n\n \nint\nreiserfs_xattr_get(struct inode *inode, const char *name, void *buffer,\n\t\t   size_t buffer_size)\n{\n\tssize_t err = 0;\n\tstruct dentry *dentry;\n\tsize_t isize;\n\tsize_t file_pos = 0;\n\tsize_t buffer_pos = 0;\n\tstruct page *page;\n\t__u32 hash = 0;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\t \n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!REISERFS_SB(inode->i_sb)->priv_root)\n\t\treturn 0;\n\n\tdentry = xattr_lookup(inode, name, XATTR_REPLACE);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out;\n\t}\n\n\tdown_read(&REISERFS_I(inode)->i_xattr_sem);\n\n\tisize = i_size_read(d_inode(dentry));\n\n\t \n\tif (buffer == NULL) {\n\t\terr = isize - sizeof(struct reiserfs_xattr_header);\n\t\tgoto out_unlock;\n\t}\n\n\tif (buffer_size < isize - sizeof(struct reiserfs_xattr_header)) {\n\t\terr = -ERANGE;\n\t\tgoto out_unlock;\n\t}\n\n\twhile (file_pos < isize) {\n\t\tsize_t chunk;\n\t\tchar *data;\n\t\tsize_t skip = 0;\n\n\t\tif (isize - file_pos > PAGE_SIZE)\n\t\t\tchunk = PAGE_SIZE;\n\t\telse\n\t\t\tchunk = isize - file_pos;\n\n\t\tpage = reiserfs_get_page(d_inode(dentry), file_pos);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tlock_page(page);\n\t\tdata = page_address(page);\n\t\tif (file_pos == 0) {\n\t\t\tstruct reiserfs_xattr_header *rxh =\n\t\t\t    (struct reiserfs_xattr_header *)data;\n\t\t\tskip = file_pos = sizeof(struct reiserfs_xattr_header);\n\t\t\tchunk -= skip;\n\t\t\t \n\t\t\tif (rxh->h_magic != cpu_to_le32(REISERFS_XATTR_MAGIC)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\treiserfs_put_page(page);\n\t\t\t\treiserfs_warning(inode->i_sb, \"jdm-20001\",\n\t\t\t\t\t\t \"Invalid magic for xattr (%s) \"\n\t\t\t\t\t\t \"associated with %k\", name,\n\t\t\t\t\t\t INODE_PKEY(inode));\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\thash = le32_to_cpu(rxh->h_hash);\n\t\t}\n\t\tmemcpy(buffer + buffer_pos, data + skip, chunk);\n\t\tunlock_page(page);\n\t\treiserfs_put_page(page);\n\t\tfile_pos += chunk;\n\t\tbuffer_pos += chunk;\n\t\tskip = 0;\n\t}\n\terr = isize - sizeof(struct reiserfs_xattr_header);\n\n\tif (xattr_hash(buffer, isize - sizeof(struct reiserfs_xattr_header)) !=\n\t    hash) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-20002\",\n\t\t\t\t \"Invalid hash for xattr (%s) associated \"\n\t\t\t\t \"with %k\", name, INODE_PKEY(inode));\n\t\terr = -EIO;\n\t}\n\nout_unlock:\n\tup_read(&REISERFS_I(inode)->i_xattr_sem);\n\tdput(dentry);\n\nout:\n\treturn err;\n}\n\n \n#define for_each_xattr_handler(handlers, handler)\t\t\\\n\t\tfor ((handler) = *(handlers)++;\t\t\t\\\n\t\t\t(handler) != NULL;\t\t\t\\\n\t\t\t(handler) = *(handlers)++)\n\nstatic inline bool reiserfs_posix_acl_list(const char *name,\n\t\t\t\t\t   struct dentry *dentry)\n{\n\treturn (posix_acl_type(name) >= 0) &&\n\t       IS_POSIXACL(d_backing_inode(dentry));\n}\n\n \nstatic inline bool reiserfs_xattr_list(const struct xattr_handler **handlers,\n\t\t\t\t       const char *name, struct dentry *dentry)\n{\n\tif (handlers) {\n\t\tconst struct xattr_handler *xah = NULL;\n\n\t\tfor_each_xattr_handler(handlers, xah) {\n\t\t\tconst char *prefix = xattr_prefix(xah);\n\n\t\t\tif (strncmp(prefix, name, strlen(prefix)))\n\t\t\t\tcontinue;\n\n\t\t\tif (!xattr_handler_can_list(xah, dentry))\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn reiserfs_posix_acl_list(name, dentry);\n}\n\nstruct listxattr_buf {\n\tstruct dir_context ctx;\n\tsize_t size;\n\tsize_t pos;\n\tchar *buf;\n\tstruct dentry *dentry;\n};\n\nstatic bool listxattr_filler(struct dir_context *ctx, const char *name,\n\t\t\t    int namelen, loff_t offset, u64 ino,\n\t\t\t    unsigned int d_type)\n{\n\tstruct listxattr_buf *b =\n\t\tcontainer_of(ctx, struct listxattr_buf, ctx);\n\tsize_t size;\n\n\tif (name[0] != '.' ||\n\t    (namelen != 1 && (name[1] != '.' || namelen != 2))) {\n\t\tif (!reiserfs_xattr_list(b->dentry->d_sb->s_xattr, name,\n\t\t\t\t\t b->dentry))\n\t\t\treturn true;\n\t\tsize = namelen + 1;\n\t\tif (b->buf) {\n\t\t\tif (b->pos + size > b->size) {\n\t\t\t\tb->pos = -ERANGE;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmemcpy(b->buf + b->pos, name, namelen);\n\t\t\tb->buf[b->pos + namelen] = 0;\n\t\t}\n\t\tb->pos += size;\n\t}\n\treturn true;\n}\n\n \nssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)\n{\n\tstruct dentry *dir;\n\tint err = 0;\n\tstruct listxattr_buf buf = {\n\t\t.ctx.actor = listxattr_filler,\n\t\t.dentry = dentry,\n\t\t.buf = buffer,\n\t\t.size = buffer ? size : 0,\n\t};\n\n\tif (d_really_is_negative(dentry))\n\t\treturn -EINVAL;\n\n\tif (get_inode_sd_version(d_inode(dentry)) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tdir = open_xa_dir(d_inode(dentry), XATTR_REPLACE);\n\tif (IS_ERR(dir)) {\n\t\terr = PTR_ERR(dir);\n\t\tif (err == -ENODATA)\n\t\t\terr = 0;   \n\t\tgoto out;\n\t}\n\n\tinode_lock_nested(d_inode(dir), I_MUTEX_XATTR);\n\terr = reiserfs_readdir_inode(d_inode(dir), &buf.ctx);\n\tinode_unlock(d_inode(dir));\n\n\tif (!err)\n\t\terr = buf.pos;\n\n\tdput(dir);\nout:\n\treturn err;\n}\n\nstatic int create_privroot(struct dentry *dentry)\n{\n\tint err;\n\tstruct inode *inode = d_inode(dentry->d_parent);\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\n\terr = xattr_mkdir(inode, dentry, 0700);\n\tif (err || d_really_is_negative(dentry)) {\n\t\treiserfs_warning(dentry->d_sb, \"jdm-20006\",\n\t\t\t\t \"xattrs/ACLs enabled and couldn't \"\n\t\t\t\t \"find/create .reiserfs_priv. \"\n\t\t\t\t \"Failing mount.\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treiserfs_init_priv_inode(d_inode(dentry));\n\treiserfs_info(dentry->d_sb, \"Created %s - reserved for xattr \"\n\t\t      \"storage.\\n\", PRIVROOT_NAME);\n\n\treturn 0;\n}\n\n#else\nint __init reiserfs_xattr_register_handlers(void) { return 0; }\nvoid reiserfs_xattr_unregister_handlers(void) {}\nstatic int create_privroot(struct dentry *dentry) { return 0; }\n#endif\n\n \nconst struct xattr_handler *reiserfs_xattr_handlers[] = {\n#ifdef CONFIG_REISERFS_FS_XATTR\n\t&reiserfs_xattr_user_handler,\n\t&reiserfs_xattr_trusted_handler,\n#endif\n#ifdef CONFIG_REISERFS_FS_SECURITY\n\t&reiserfs_xattr_security_handler,\n#endif\n\tNULL\n};\n\nstatic int xattr_mount_check(struct super_block *s)\n{\n\t \n\tif (old_format_only(s)) {\n\t\tif (reiserfs_xattrs_optional(s)) {\n\t\t\t \n\t\t\treiserfs_warning(s, \"jdm-2005\",\n\t\t\t\t\t \"xattrs/ACLs not supported \"\n\t\t\t\t\t \"on pre-v3.6 format filesystems. \"\n\t\t\t\t\t \"Failing mount.\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint reiserfs_permission(struct mnt_idmap *idmap, struct inode *inode,\n\t\t\tint mask)\n{\n\t \n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\n\treturn generic_permission(&nop_mnt_idmap, inode, mask);\n}\n\nstatic int xattr_hide_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\treturn -EPERM;\n}\n\nstatic const struct dentry_operations xattr_lookup_poison_ops = {\n\t.d_revalidate = xattr_hide_revalidate,\n};\n\nint reiserfs_lookup_privroot(struct super_block *s)\n{\n\tstruct dentry *dentry;\n\tint err = 0;\n\n\t \n\tinode_lock(d_inode(s->s_root));\n\tdentry = lookup_one_len(PRIVROOT_NAME, s->s_root,\n\t\t\t\tstrlen(PRIVROOT_NAME));\n\tif (!IS_ERR(dentry)) {\n\t\tREISERFS_SB(s)->priv_root = dentry;\n\t\td_set_d_op(dentry, &xattr_lookup_poison_ops);\n\t\tif (d_really_is_positive(dentry))\n\t\t\treiserfs_init_priv_inode(d_inode(dentry));\n\t} else\n\t\terr = PTR_ERR(dentry);\n\tinode_unlock(d_inode(s->s_root));\n\n\treturn err;\n}\n\n \nint reiserfs_xattr_init(struct super_block *s, int mount_flags)\n{\n\tint err = 0;\n\tstruct dentry *privroot = REISERFS_SB(s)->priv_root;\n\n\terr = xattr_mount_check(s);\n\tif (err)\n\t\tgoto error;\n\n\tif (d_really_is_negative(privroot) && !(mount_flags & SB_RDONLY)) {\n\t\tinode_lock(d_inode(s->s_root));\n\t\terr = create_privroot(REISERFS_SB(s)->priv_root);\n\t\tinode_unlock(d_inode(s->s_root));\n\t}\n\n\tif (d_really_is_positive(privroot)) {\n\t\tinode_lock(d_inode(privroot));\n\t\tif (!REISERFS_SB(s)->xattr_root) {\n\t\t\tstruct dentry *dentry;\n\n\t\t\tdentry = lookup_one_len(XAROOT_NAME, privroot,\n\t\t\t\t\t\tstrlen(XAROOT_NAME));\n\t\t\tif (!IS_ERR(dentry))\n\t\t\t\tREISERFS_SB(s)->xattr_root = dentry;\n\t\t\telse\n\t\t\t\terr = PTR_ERR(dentry);\n\t\t}\n\t\tinode_unlock(d_inode(privroot));\n\t}\n\nerror:\n\tif (err) {\n\t\tclear_bit(REISERFS_XATTRS_USER, &REISERFS_SB(s)->s_mount_opt);\n\t\tclear_bit(REISERFS_POSIXACL, &REISERFS_SB(s)->s_mount_opt);\n\t}\n\n\t \n\tif (reiserfs_posixacl(s))\n\t\ts->s_flags |= SB_POSIXACL;\n\telse\n\t\ts->s_flags &= ~SB_POSIXACL;\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}