{
  "module_name": "item_ops.c",
  "hash_id": "6ed62f9ec4abaa81400ed22ce4607b9d803489fe51313a24f8b91c8cf3f856c1",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/item_ops.c",
  "human_readable_source": " \n\n#include <linux/time.h>\n#include \"reiserfs.h\"\n\n \n\n \n\n \nstatic int sd_bytes_number(struct item_head *ih, int block_size)\n{\n\treturn 0;\n}\n\nstatic void sd_decrement_key(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_objectid--;\n\tset_cpu_key_k_type(key, TYPE_ANY);\n\tset_cpu_key_k_offset(key, (loff_t)(~0ULL >> 1));\n}\n\nstatic int sd_is_left_mergeable(struct reiserfs_key *key, unsigned long bsize)\n{\n\treturn 0;\n}\n\nstatic void sd_print_item(struct item_head *ih, char *item)\n{\n\tprintk(\"\\tmode | size | nlinks | first direct | mtime\\n\");\n\tif (stat_data_v1(ih)) {\n\t\tstruct stat_data_v1 *sd = (struct stat_data_v1 *)item;\n\n\t\tprintk(\"\\t0%-6o | %6u | %2u | %d | %u\\n\", sd_v1_mode(sd),\n\t\t       sd_v1_size(sd), sd_v1_nlink(sd),\n\t\t       sd_v1_first_direct_byte(sd),\n\t\t       sd_v1_mtime(sd));\n\t} else {\n\t\tstruct stat_data *sd = (struct stat_data *)item;\n\n\t\tprintk(\"\\t0%-6o | %6llu | %2u | %d | %u\\n\", sd_v2_mode(sd),\n\t\t       (unsigned long long)sd_v2_size(sd), sd_v2_nlink(sd),\n\t\t       sd_v2_rdev(sd), sd_v2_mtime(sd));\n\t}\n}\n\nstatic void sd_check_item(struct item_head *ih, char *item)\n{\n\t \n}\n\nstatic int sd_create_vi(struct virtual_node *vn,\n\t\t\tstruct virtual_item *vi,\n\t\t\tint is_affected, int insert_size)\n{\n\tvi->vi_index = TYPE_STAT_DATA;\n\treturn 0;\n}\n\nstatic int sd_check_left(struct virtual_item *vi, int free,\n\t\t\t int start_skip, int end_skip)\n{\n\tBUG_ON(start_skip || end_skip);\n\treturn -1;\n}\n\nstatic int sd_check_right(struct virtual_item *vi, int free)\n{\n\treturn -1;\n}\n\nstatic int sd_part_size(struct virtual_item *vi, int first, int count)\n{\n\tBUG_ON(count);\n\treturn 0;\n}\n\nstatic int sd_unit_num(struct virtual_item *vi)\n{\n\treturn vi->vi_item_len - IH_SIZE;\n}\n\nstatic void sd_print_vi(struct virtual_item *vi)\n{\n\treiserfs_warning(NULL, \"reiserfs-16100\",\n\t\t\t \"STATDATA, index %d, type 0x%x, %h\",\n\t\t\t vi->vi_index, vi->vi_type, vi->vi_ih);\n}\n\nstatic struct item_operations stat_data_ops = {\n\t.bytes_number = sd_bytes_number,\n\t.decrement_key = sd_decrement_key,\n\t.is_left_mergeable = sd_is_left_mergeable,\n\t.print_item = sd_print_item,\n\t.check_item = sd_check_item,\n\n\t.create_vi = sd_create_vi,\n\t.check_left = sd_check_left,\n\t.check_right = sd_check_right,\n\t.part_size = sd_part_size,\n\t.unit_num = sd_unit_num,\n\t.print_vi = sd_print_vi\n};\n\n \nstatic int direct_bytes_number(struct item_head *ih, int block_size)\n{\n\treturn ih_item_len(ih);\n}\n\n \nstatic void direct_decrement_key(struct cpu_key *key)\n{\n\tcpu_key_k_offset_dec(key);\n\tif (cpu_key_k_offset(key) == 0)\n\t\tset_cpu_key_k_type(key, TYPE_STAT_DATA);\n}\n\nstatic int direct_is_left_mergeable(struct reiserfs_key *key,\n\t\t\t\t    unsigned long bsize)\n{\n\tint version = le_key_version(key);\n\treturn ((le_key_k_offset(version, key) & (bsize - 1)) != 1);\n}\n\nstatic void direct_print_item(struct item_head *ih, char *item)\n{\n\tint j = 0;\n\n \n\tprintk(\"\\\"\");\n\twhile (j < ih_item_len(ih))\n\t\tprintk(\"%c\", item[j++]);\n\tprintk(\"\\\"\\n\");\n}\n\nstatic void direct_check_item(struct item_head *ih, char *item)\n{\n\t \n}\n\nstatic int direct_create_vi(struct virtual_node *vn,\n\t\t\t    struct virtual_item *vi,\n\t\t\t    int is_affected, int insert_size)\n{\n\tvi->vi_index = TYPE_DIRECT;\n\treturn 0;\n}\n\nstatic int direct_check_left(struct virtual_item *vi, int free,\n\t\t\t     int start_skip, int end_skip)\n{\n\tint bytes;\n\n\tbytes = free - free % 8;\n\treturn bytes ? : -1;\n}\n\nstatic int direct_check_right(struct virtual_item *vi, int free)\n{\n\treturn direct_check_left(vi, free, 0, 0);\n}\n\nstatic int direct_part_size(struct virtual_item *vi, int first, int count)\n{\n\treturn count;\n}\n\nstatic int direct_unit_num(struct virtual_item *vi)\n{\n\treturn vi->vi_item_len - IH_SIZE;\n}\n\nstatic void direct_print_vi(struct virtual_item *vi)\n{\n\treiserfs_warning(NULL, \"reiserfs-16101\",\n\t\t\t \"DIRECT, index %d, type 0x%x, %h\",\n\t\t\t vi->vi_index, vi->vi_type, vi->vi_ih);\n}\n\nstatic struct item_operations direct_ops = {\n\t.bytes_number = direct_bytes_number,\n\t.decrement_key = direct_decrement_key,\n\t.is_left_mergeable = direct_is_left_mergeable,\n\t.print_item = direct_print_item,\n\t.check_item = direct_check_item,\n\n\t.create_vi = direct_create_vi,\n\t.check_left = direct_check_left,\n\t.check_right = direct_check_right,\n\t.part_size = direct_part_size,\n\t.unit_num = direct_unit_num,\n\t.print_vi = direct_print_vi\n};\n\n \nstatic int indirect_bytes_number(struct item_head *ih, int block_size)\n{\n\treturn ih_item_len(ih) / UNFM_P_SIZE * block_size;\n}\n\n \nstatic void indirect_decrement_key(struct cpu_key *key)\n{\n\tcpu_key_k_offset_dec(key);\n\tif (cpu_key_k_offset(key) == 0)\n\t\tset_cpu_key_k_type(key, TYPE_STAT_DATA);\n}\n\n \nstatic int indirect_is_left_mergeable(struct reiserfs_key *key,\n\t\t\t\t      unsigned long bsize)\n{\n\tint version = le_key_version(key);\n\treturn (le_key_k_offset(version, key) != 1);\n}\n\n \nstatic void start_new_sequence(__u32 * start, int *len, __u32 new)\n{\n\t*start = new;\n\t*len = 1;\n}\n\nstatic int sequence_finished(__u32 start, int *len, __u32 new)\n{\n\tif (start == INT_MAX)\n\t\treturn 1;\n\n\tif (start == 0 && new == 0) {\n\t\t(*len)++;\n\t\treturn 0;\n\t}\n\tif (start != 0 && (start + *len) == new) {\n\t\t(*len)++;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void print_sequence(__u32 start, int len)\n{\n\tif (start == INT_MAX)\n\t\treturn;\n\n\tif (len == 1)\n\t\tprintk(\" %d\", start);\n\telse\n\t\tprintk(\" %d(%d)\", start, len);\n}\n\nstatic void indirect_print_item(struct item_head *ih, char *item)\n{\n\tint j;\n\t__le32 *unp;\n\t__u32 prev = INT_MAX;\n\tint num = 0;\n\n\tunp = (__le32 *) item;\n\n\tif (ih_item_len(ih) % UNFM_P_SIZE)\n\t\treiserfs_warning(NULL, \"reiserfs-16102\", \"invalid item len\");\n\n\tprintk(\"%d pointers\\n[ \", (int)I_UNFM_NUM(ih));\n\tfor (j = 0; j < I_UNFM_NUM(ih); j++) {\n\t\tif (sequence_finished(prev, &num, get_block_num(unp, j))) {\n\t\t\tprint_sequence(prev, num);\n\t\t\tstart_new_sequence(&prev, &num, get_block_num(unp, j));\n\t\t}\n\t}\n\tprint_sequence(prev, num);\n\tprintk(\"]\\n\");\n}\n\nstatic void indirect_check_item(struct item_head *ih, char *item)\n{\n\t \n}\n\nstatic int indirect_create_vi(struct virtual_node *vn,\n\t\t\t      struct virtual_item *vi,\n\t\t\t      int is_affected, int insert_size)\n{\n\tvi->vi_index = TYPE_INDIRECT;\n\treturn 0;\n}\n\nstatic int indirect_check_left(struct virtual_item *vi, int free,\n\t\t\t       int start_skip, int end_skip)\n{\n\tint bytes;\n\n\tbytes = free - free % UNFM_P_SIZE;\n\treturn bytes ? : -1;\n}\n\nstatic int indirect_check_right(struct virtual_item *vi, int free)\n{\n\treturn indirect_check_left(vi, free, 0, 0);\n}\n\n \nstatic int indirect_part_size(struct virtual_item *vi, int first, int units)\n{\n\t \n\treturn units;\n}\n\nstatic int indirect_unit_num(struct virtual_item *vi)\n{\n\t \n\treturn vi->vi_item_len - IH_SIZE;\n}\n\nstatic void indirect_print_vi(struct virtual_item *vi)\n{\n\treiserfs_warning(NULL, \"reiserfs-16103\",\n\t\t\t \"INDIRECT, index %d, type 0x%x, %h\",\n\t\t\t vi->vi_index, vi->vi_type, vi->vi_ih);\n}\n\nstatic struct item_operations indirect_ops = {\n\t.bytes_number = indirect_bytes_number,\n\t.decrement_key = indirect_decrement_key,\n\t.is_left_mergeable = indirect_is_left_mergeable,\n\t.print_item = indirect_print_item,\n\t.check_item = indirect_check_item,\n\n\t.create_vi = indirect_create_vi,\n\t.check_left = indirect_check_left,\n\t.check_right = indirect_check_right,\n\t.part_size = indirect_part_size,\n\t.unit_num = indirect_unit_num,\n\t.print_vi = indirect_print_vi\n};\n\n \nstatic int direntry_bytes_number(struct item_head *ih, int block_size)\n{\n\treiserfs_warning(NULL, \"vs-16090\",\n\t\t\t \"bytes number is asked for direntry\");\n\treturn 0;\n}\n\nstatic void direntry_decrement_key(struct cpu_key *key)\n{\n\tcpu_key_k_offset_dec(key);\n\tif (cpu_key_k_offset(key) == 0)\n\t\tset_cpu_key_k_type(key, TYPE_STAT_DATA);\n}\n\nstatic int direntry_is_left_mergeable(struct reiserfs_key *key,\n\t\t\t\t      unsigned long bsize)\n{\n\tif (le32_to_cpu(key->u.k_offset_v1.k_offset) == DOT_OFFSET)\n\t\treturn 0;\n\treturn 1;\n\n}\n\nstatic void direntry_print_item(struct item_head *ih, char *item)\n{\n\tint i;\n\tint namelen;\n\tstruct reiserfs_de_head *deh;\n\tchar *name;\n\tstatic char namebuf[80];\n\n\tprintk(\"\\n # %-15s%-30s%-15s%-15s%-15s\\n\", \"Name\",\n\t       \"Key of pointed object\", \"Hash\", \"Gen number\", \"Status\");\n\n\tdeh = (struct reiserfs_de_head *)item;\n\n\tfor (i = 0; i < ih_entry_count(ih); i++, deh++) {\n\t\tnamelen =\n\t\t    (i ? (deh_location(deh - 1)) : ih_item_len(ih)) -\n\t\t    deh_location(deh);\n\t\tname = item + deh_location(deh);\n\t\tif (name[namelen - 1] == 0)\n\t\t\tnamelen = strlen(name);\n\t\tnamebuf[0] = '\"';\n\t\tif (namelen > sizeof(namebuf) - 3) {\n\t\t\tstrncpy(namebuf + 1, name, sizeof(namebuf) - 3);\n\t\t\tnamebuf[sizeof(namebuf) - 2] = '\"';\n\t\t\tnamebuf[sizeof(namebuf) - 1] = 0;\n\t\t} else {\n\t\t\tmemcpy(namebuf + 1, name, namelen);\n\t\t\tnamebuf[namelen + 1] = '\"';\n\t\t\tnamebuf[namelen + 2] = 0;\n\t\t}\n\n\t\tprintk(\"%d:  %-15s%-15d%-15d%-15lld%-15lld(%s)\\n\",\n\t\t       i, namebuf,\n\t\t       deh_dir_id(deh), deh_objectid(deh),\n\t\t       GET_HASH_VALUE(deh_offset(deh)),\n\t\t       GET_GENERATION_NUMBER((deh_offset(deh))),\n\t\t       (de_hidden(deh)) ? \"HIDDEN\" : \"VISIBLE\");\n\t}\n}\n\nstatic void direntry_check_item(struct item_head *ih, char *item)\n{\n\tint i;\n\tstruct reiserfs_de_head *deh;\n\n\t \n\tdeh = (struct reiserfs_de_head *)item;\n\tfor (i = 0; i < ih_entry_count(ih); i++, deh++) {\n\t\t;\n\t}\n}\n\n#define DIRENTRY_VI_FIRST_DIRENTRY_ITEM 1\n\n \nstatic inline int old_entry_num(int is_affected, int virtual_entry_num,\n\t\t\t\tint pos_in_item, int mode)\n{\n\tif (mode == M_INSERT || mode == M_DELETE)\n\t\treturn virtual_entry_num;\n\n\tif (!is_affected)\n\t\t \n\t\treturn virtual_entry_num;\n\n\tif (virtual_entry_num < pos_in_item)\n\t\treturn virtual_entry_num;\n\n\tif (mode == M_CUT)\n\t\treturn virtual_entry_num + 1;\n\n\tRFALSE(mode != M_PASTE || virtual_entry_num == 0,\n\t       \"vs-8015: old_entry_num: mode must be M_PASTE (mode = \\'%c\\'\",\n\t       mode);\n\n\treturn virtual_entry_num - 1;\n}\n\n \nstatic int direntry_create_vi(struct virtual_node *vn,\n\t\t\t      struct virtual_item *vi,\n\t\t\t      int is_affected, int insert_size)\n{\n\tstruct direntry_uarea *dir_u = vi->vi_uarea;\n\tint i, j;\n\tint size = sizeof(struct direntry_uarea);\n\tstruct reiserfs_de_head *deh;\n\n\tvi->vi_index = TYPE_DIRENTRY;\n\n\tBUG_ON(!(vi->vi_ih) || !vi->vi_item);\n\n\tdir_u->flags = 0;\n\tif (le_ih_k_offset(vi->vi_ih) == DOT_OFFSET)\n\t\tdir_u->flags |= DIRENTRY_VI_FIRST_DIRENTRY_ITEM;\n\n\tdeh = (struct reiserfs_de_head *)(vi->vi_item);\n\n\t \n\tdir_u->entry_count = ih_entry_count(vi->vi_ih) +\n\t    ((is_affected) ? ((vn->vn_mode == M_CUT) ? -1 :\n\t\t\t      (vn->vn_mode == M_PASTE ? 1 : 0)) : 0);\n\n\tfor (i = 0; i < dir_u->entry_count; i++) {\n\t\tj = old_entry_num(is_affected, i, vn->vn_pos_in_item,\n\t\t\t\t  vn->vn_mode);\n\t\tdir_u->entry_sizes[i] =\n\t\t    (j ? deh_location(&deh[j - 1]) : ih_item_len(vi->vi_ih)) -\n\t\t    deh_location(&deh[j]) + DEH_SIZE;\n\t}\n\n\tsize += (dir_u->entry_count * sizeof(short));\n\n\t \n\tif (is_affected && vn->vn_mode == M_PASTE)\n\t\tdir_u->entry_sizes[vn->vn_pos_in_item] = insert_size;\n\n#ifdef CONFIG_REISERFS_CHECK\n\t \n\t{\n\t\tint k, l;\n\n\t\tl = 0;\n\t\tfor (k = 0; k < dir_u->entry_count; k++)\n\t\t\tl += dir_u->entry_sizes[k];\n\n\t\tif (l + IH_SIZE != vi->vi_item_len +\n\t\t    ((is_affected\n\t\t      && (vn->vn_mode == M_PASTE\n\t\t\t  || vn->vn_mode == M_CUT)) ? insert_size : 0)) {\n\t\t\treiserfs_panic(NULL, \"vs-8025\", \"(mode==%c, \"\n\t\t\t\t       \"insert_size==%d), invalid length of \"\n\t\t\t\t       \"directory item\",\n\t\t\t\t       vn->vn_mode, insert_size);\n\t\t}\n\t}\n#endif\n\n\treturn size;\n\n}\n\n \nstatic int direntry_check_left(struct virtual_item *vi, int free,\n\t\t\t       int start_skip, int end_skip)\n{\n\tint i;\n\tint entries = 0;\n\tstruct direntry_uarea *dir_u = vi->vi_uarea;\n\n\tfor (i = start_skip; i < dir_u->entry_count - end_skip; i++) {\n\t\t \n\t\tif (dir_u->entry_sizes[i] > free)\n\t\t\tbreak;\n\n\t\tfree -= dir_u->entry_sizes[i];\n\t\tentries++;\n\t}\n\n\tif (entries == dir_u->entry_count) {\n\t\treiserfs_panic(NULL, \"item_ops-1\",\n\t\t\t       \"free space %d, entry_count %d\", free,\n\t\t\t       dir_u->entry_count);\n\t}\n\n\t \n\tif (start_skip == 0 && (dir_u->flags & DIRENTRY_VI_FIRST_DIRENTRY_ITEM)\n\t    && entries < 2)\n\t\tentries = 0;\n\n\treturn entries ? : -1;\n}\n\nstatic int direntry_check_right(struct virtual_item *vi, int free)\n{\n\tint i;\n\tint entries = 0;\n\tstruct direntry_uarea *dir_u = vi->vi_uarea;\n\n\tfor (i = dir_u->entry_count - 1; i >= 0; i--) {\n\t\t \n\t\tif (dir_u->entry_sizes[i] > free)\n\t\t\tbreak;\n\n\t\tfree -= dir_u->entry_sizes[i];\n\t\tentries++;\n\t}\n\tBUG_ON(entries == dir_u->entry_count);\n\n\t \n\tif ((dir_u->flags & DIRENTRY_VI_FIRST_DIRENTRY_ITEM)\n\t    && entries > dir_u->entry_count - 2)\n\t\tentries = dir_u->entry_count - 2;\n\n\treturn entries ? : -1;\n}\n\n \nstatic int direntry_part_size(struct virtual_item *vi, int first, int count)\n{\n\tint i, retval;\n\tint from, to;\n\tstruct direntry_uarea *dir_u = vi->vi_uarea;\n\n\tretval = 0;\n\tif (first == 0)\n\t\tfrom = 0;\n\telse\n\t\tfrom = dir_u->entry_count - count;\n\tto = from + count - 1;\n\n\tfor (i = from; i <= to; i++)\n\t\tretval += dir_u->entry_sizes[i];\n\n\treturn retval;\n}\n\nstatic int direntry_unit_num(struct virtual_item *vi)\n{\n\tstruct direntry_uarea *dir_u = vi->vi_uarea;\n\n\treturn dir_u->entry_count;\n}\n\nstatic void direntry_print_vi(struct virtual_item *vi)\n{\n\tint i;\n\tstruct direntry_uarea *dir_u = vi->vi_uarea;\n\n\treiserfs_warning(NULL, \"reiserfs-16104\",\n\t\t\t \"DIRENTRY, index %d, type 0x%x, %h, flags 0x%x\",\n\t\t\t vi->vi_index, vi->vi_type, vi->vi_ih, dir_u->flags);\n\tprintk(\"%d entries: \", dir_u->entry_count);\n\tfor (i = 0; i < dir_u->entry_count; i++)\n\t\tprintk(\"%d \", dir_u->entry_sizes[i]);\n\tprintk(\"\\n\");\n}\n\nstatic struct item_operations direntry_ops = {\n\t.bytes_number = direntry_bytes_number,\n\t.decrement_key = direntry_decrement_key,\n\t.is_left_mergeable = direntry_is_left_mergeable,\n\t.print_item = direntry_print_item,\n\t.check_item = direntry_check_item,\n\n\t.create_vi = direntry_create_vi,\n\t.check_left = direntry_check_left,\n\t.check_right = direntry_check_right,\n\t.part_size = direntry_part_size,\n\t.unit_num = direntry_unit_num,\n\t.print_vi = direntry_print_vi\n};\n\n \nstatic int errcatch_bytes_number(struct item_head *ih, int block_size)\n{\n\treiserfs_warning(NULL, \"green-16001\",\n\t\t\t \"Invalid item type observed, run fsck ASAP\");\n\treturn 0;\n}\n\nstatic void errcatch_decrement_key(struct cpu_key *key)\n{\n\treiserfs_warning(NULL, \"green-16002\",\n\t\t\t \"Invalid item type observed, run fsck ASAP\");\n}\n\nstatic int errcatch_is_left_mergeable(struct reiserfs_key *key,\n\t\t\t\t      unsigned long bsize)\n{\n\treiserfs_warning(NULL, \"green-16003\",\n\t\t\t \"Invalid item type observed, run fsck ASAP\");\n\treturn 0;\n}\n\nstatic void errcatch_print_item(struct item_head *ih, char *item)\n{\n\treiserfs_warning(NULL, \"green-16004\",\n\t\t\t \"Invalid item type observed, run fsck ASAP\");\n}\n\nstatic void errcatch_check_item(struct item_head *ih, char *item)\n{\n\treiserfs_warning(NULL, \"green-16005\",\n\t\t\t \"Invalid item type observed, run fsck ASAP\");\n}\n\nstatic int errcatch_create_vi(struct virtual_node *vn,\n\t\t\t      struct virtual_item *vi,\n\t\t\t      int is_affected, int insert_size)\n{\n\treiserfs_warning(NULL, \"green-16006\",\n\t\t\t \"Invalid item type observed, run fsck ASAP\");\n\t \n\treturn 0;\n}\n\nstatic int errcatch_check_left(struct virtual_item *vi, int free,\n\t\t\t       int start_skip, int end_skip)\n{\n\treiserfs_warning(NULL, \"green-16007\",\n\t\t\t \"Invalid item type observed, run fsck ASAP\");\n\treturn -1;\n}\n\nstatic int errcatch_check_right(struct virtual_item *vi, int free)\n{\n\treiserfs_warning(NULL, \"green-16008\",\n\t\t\t \"Invalid item type observed, run fsck ASAP\");\n\treturn -1;\n}\n\nstatic int errcatch_part_size(struct virtual_item *vi, int first, int count)\n{\n\treiserfs_warning(NULL, \"green-16009\",\n\t\t\t \"Invalid item type observed, run fsck ASAP\");\n\treturn 0;\n}\n\nstatic int errcatch_unit_num(struct virtual_item *vi)\n{\n\treiserfs_warning(NULL, \"green-16010\",\n\t\t\t \"Invalid item type observed, run fsck ASAP\");\n\treturn 0;\n}\n\nstatic void errcatch_print_vi(struct virtual_item *vi)\n{\n\treiserfs_warning(NULL, \"green-16011\",\n\t\t\t \"Invalid item type observed, run fsck ASAP\");\n}\n\nstatic struct item_operations errcatch_ops = {\n\t.bytes_number = errcatch_bytes_number,\n\t.decrement_key = errcatch_decrement_key,\n\t.is_left_mergeable = errcatch_is_left_mergeable,\n\t.print_item = errcatch_print_item,\n\t.check_item = errcatch_check_item,\n\n\t.create_vi = errcatch_create_vi,\n\t.check_left = errcatch_check_left,\n\t.check_right = errcatch_check_right,\n\t.part_size = errcatch_part_size,\n\t.unit_num = errcatch_unit_num,\n\t.print_vi = errcatch_print_vi\n};\n\n#if ! (TYPE_STAT_DATA == 0 && TYPE_INDIRECT == 1 && TYPE_DIRECT == 2 && TYPE_DIRENTRY == 3)\n#error Item types must use disk-format assigned values.\n#endif\n\nstruct item_operations *item_ops[TYPE_ANY + 1] = {\n\t&stat_data_ops,\n\t&indirect_ops,\n\t&direct_ops,\n\t&direntry_ops,\n\tNULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n\t&errcatch_ops\t\t \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}