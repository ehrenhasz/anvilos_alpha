{
  "module_name": "lbalance.c",
  "hash_id": "89781d2dbb66e22ac633602d00ce51c9825f5775b260a1c36f4d1d1ee87007ad",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/lbalance.c",
  "human_readable_source": " \n\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include \"reiserfs.h\"\n#include <linux/buffer_head.h>\n\n \nstatic void leaf_copy_dir_entries(struct buffer_info *dest_bi,\n\t\t\t\t  struct buffer_head *source, int last_first,\n\t\t\t\t  int item_num, int from, int copy_count)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\t \n\tint item_num_in_dest;\n\n\tstruct item_head *ih;\n\tstruct reiserfs_de_head *deh;\n\tint copy_records_len;\t \n\tchar *records;\n\n\tih = item_head(source, item_num);\n\n\tRFALSE(!is_direntry_le_ih(ih), \"vs-10000: item must be directory item\");\n\n\t \n\tdeh = B_I_DEH(source, ih);\n\tif (copy_count) {\n\t\tcopy_records_len = (from ? deh_location(&deh[from - 1]) :\n\t\t\t\t    ih_item_len(ih)) -\n\t\t    deh_location(&deh[from + copy_count - 1]);\n\t\trecords =\n\t\t    source->b_data + ih_location(ih) +\n\t\t    deh_location(&deh[from + copy_count - 1]);\n\t} else {\n\t\tcopy_records_len = 0;\n\t\trecords = NULL;\n\t}\n\n\t \n\titem_num_in_dest =\n\t    (last_first ==\n\t     LAST_TO_FIRST) ? ((B_NR_ITEMS(dest)) ? 0 : -1) : (B_NR_ITEMS(dest)\n\t\t\t\t\t\t\t       - 1);\n\n\t \n\tif ((item_num_in_dest == -1) ||\n\t    (last_first == FIRST_TO_LAST && le_ih_k_offset(ih) == DOT_OFFSET) ||\n\t    (last_first == LAST_TO_FIRST\n\t     && comp_short_le_keys   (&ih->ih_key,\n\t\t\t\t\t\t\t leaf_key(dest,\n\t\t\t\t\t\t\t\t  item_num_in_dest))))\n\t{\n\t\t \n\t\tstruct item_head new_ih;\n\n\t\t \n\t\tmemcpy(&new_ih.ih_key, &ih->ih_key, KEY_SIZE);\n\t\tput_ih_version(&new_ih, KEY_FORMAT_3_5);\n\t\t \n\t\tput_ih_item_len(&new_ih,\n\t\t\t\tDEH_SIZE * copy_count + copy_records_len);\n\t\tput_ih_entry_count(&new_ih, 0);\n\n\t\tif (last_first == LAST_TO_FIRST) {\n\t\t\t \n\t\t\tif (from < ih_entry_count(ih)) {\n\t\t\t\tset_le_ih_k_offset(&new_ih,\n\t\t\t\t\t\t   deh_offset(&deh[from]));\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tset_le_ih_k_offset(&new_ih, U32_MAX);\n\t\t\t\t \n\t\t\t}\n\t\t\tset_le_key_k_type(KEY_FORMAT_3_5, &new_ih.ih_key,\n\t\t\t\t\t  TYPE_DIRENTRY);\n\t\t}\n\n\t\t \n\t\tleaf_insert_into_buf(dest_bi,\n\t\t\t\t     (last_first ==\n\t\t\t\t      LAST_TO_FIRST) ? 0 : B_NR_ITEMS(dest),\n\t\t\t\t     &new_ih, NULL, 0);\n\t} else {\n\t\t \n\t\tleaf_paste_in_buffer(dest_bi,\n\t\t\t\t     (last_first ==\n\t\t\t\t      FIRST_TO_LAST) ? (B_NR_ITEMS(dest) -\n\t\t\t\t\t\t\t1) : 0, MAX_US_INT,\n\t\t\t\t     DEH_SIZE * copy_count + copy_records_len,\n\t\t\t\t     records, 0);\n\t}\n\n\titem_num_in_dest =\n\t    (last_first == FIRST_TO_LAST) ? (B_NR_ITEMS(dest) - 1) : 0;\n\n\tleaf_paste_entries(dest_bi, item_num_in_dest,\n\t\t\t   (last_first ==\n\t\t\t    FIRST_TO_LAST) ? ih_entry_count(item_head(dest,\n\t\t\t\t\t\t\t\t\t  item_num_in_dest))\n\t\t\t   : 0, copy_count, deh + from, records,\n\t\t\t   DEH_SIZE * copy_count + copy_records_len);\n}\n\n \n \nstatic int leaf_copy_boundary_item(struct buffer_info *dest_bi,\n\t\t\t\t   struct buffer_head *src, int last_first,\n\t\t\t\t   int bytes_or_entries)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\t \n\tint dest_nr_item, src_nr_item;\n\tstruct item_head *ih;\n\tstruct item_head *dih;\n\n\tdest_nr_item = B_NR_ITEMS(dest);\n\n\t \n\tif (last_first == FIRST_TO_LAST) {\n\t\tih = item_head(src, 0);\n\t\tdih = item_head(dest, dest_nr_item - 1);\n\n\t\t \n\t\tif (!dest_nr_item\n\t\t    || (!op_is_left_mergeable(&ih->ih_key, src->b_size)))\n\t\t\treturn 0;\n\n\t\tRFALSE(!ih_item_len(ih),\n\t\t       \"vs-10010: item can not have empty length\");\n\n\t\tif (is_direntry_le_ih(ih)) {\n\t\t\tif (bytes_or_entries == -1)\n\t\t\t\t \n\t\t\t\tbytes_or_entries = ih_entry_count(ih);\n\t\t\tleaf_copy_dir_entries(dest_bi, src, FIRST_TO_LAST, 0, 0,\n\t\t\t\t\t      bytes_or_entries);\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tif (bytes_or_entries == -1)\n\t\t\tbytes_or_entries = ih_item_len(ih);\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\telse {\n\t\t\tif (bytes_or_entries == ih_item_len(ih)\n\t\t\t    && is_indirect_le_ih(ih))\n\t\t\t\tif (get_ih_free_space(ih))\n\t\t\t\t\treiserfs_panic(sb_from_bi(dest_bi),\n\t\t\t\t\t\t       \"vs-10020\",\n\t\t\t\t\t\t       \"last unformatted node \"\n\t\t\t\t\t\t       \"must be filled \"\n\t\t\t\t\t\t       \"entirely (%h)\", ih);\n\t\t}\n#endif\n\n\t\t \n\t\tleaf_paste_in_buffer(dest_bi,\n\t\t\t\t     dest_nr_item - 1, ih_item_len(dih),\n\t\t\t\t     bytes_or_entries, ih_item_body(src, ih), 0);\n\n\t\tif (is_indirect_le_ih(dih)) {\n\t\t\tRFALSE(get_ih_free_space(dih),\n\t\t\t       \"vs-10030: merge to left: last unformatted node of non-last indirect item %h must have zerto free space\",\n\t\t\t       ih);\n\t\t\tif (bytes_or_entries == ih_item_len(ih))\n\t\t\t\tset_ih_free_space(dih, get_ih_free_space(ih));\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\t \n\n\t \n\tsrc_nr_item = B_NR_ITEMS(src);\n\tih = item_head(src, src_nr_item - 1);\n\tdih = item_head(dest, 0);\n\n\tif (!dest_nr_item || !op_is_left_mergeable(&dih->ih_key, src->b_size))\n\t\treturn 0;\n\n\tif (is_direntry_le_ih(ih)) {\n\t\t \n\t\tif (bytes_or_entries == -1)\n\t\t\tbytes_or_entries = ih_entry_count(ih);\n\n\t\tleaf_copy_dir_entries(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t      src_nr_item - 1,\n\t\t\t\t      ih_entry_count(ih) - bytes_or_entries,\n\t\t\t\t      bytes_or_entries);\n\t\treturn 1;\n\t}\n\n\t \n\n\tRFALSE(is_indirect_le_ih(ih) && get_ih_free_space(ih),\n\t       \"vs-10040: merge to right: last unformatted node of non-last indirect item must be filled entirely (%h)\",\n\t       ih);\n\n\tif (bytes_or_entries == -1) {\n\t\t \n\t\tbytes_or_entries = ih_item_len(ih);\n\n\t\tRFALSE(le_ih_k_offset(dih) !=\n\t\t       le_ih_k_offset(ih) + op_bytes_number(ih, src->b_size),\n\t\t       \"vs-10050: items %h and %h do not match\", ih, dih);\n\n\t\t \n\t\tset_le_ih_k_offset(dih, le_ih_k_offset(ih));\n\n\t\t \n\t\t \n\t\tset_le_ih_k_type(dih, le_ih_k_type(ih));\n\t} else {\n\t\t \n\t\tRFALSE(ih_item_len(ih) <= bytes_or_entries,\n\t\t       \"vs-10060: no so much bytes %lu (needed %lu)\",\n\t\t       (unsigned long)ih_item_len(ih),\n\t\t       (unsigned long)bytes_or_entries);\n\n\t\t \n\t\tif (is_direct_le_ih(dih)) {\n\t\t\tRFALSE(le_ih_k_offset(dih) <=\n\t\t\t       (unsigned long)bytes_or_entries,\n\t\t\t       \"vs-10070: dih %h, bytes_or_entries(%d)\", dih,\n\t\t\t       bytes_or_entries);\n\t\t\tset_le_ih_k_offset(dih,\n\t\t\t\t\t   le_ih_k_offset(dih) -\n\t\t\t\t\t   bytes_or_entries);\n\t\t} else {\n\t\t\tRFALSE(le_ih_k_offset(dih) <=\n\t\t\t       (bytes_or_entries / UNFM_P_SIZE) * dest->b_size,\n\t\t\t       \"vs-10080: dih %h, bytes_or_entries(%d)\",\n\t\t\t       dih,\n\t\t\t       (bytes_or_entries / UNFM_P_SIZE) * dest->b_size);\n\t\t\tset_le_ih_k_offset(dih,\n\t\t\t\t\t   le_ih_k_offset(dih) -\n\t\t\t\t\t   ((bytes_or_entries / UNFM_P_SIZE) *\n\t\t\t\t\t    dest->b_size));\n\t\t}\n\t}\n\n\tleaf_paste_in_buffer(dest_bi, 0, 0, bytes_or_entries,\n\t\t\t     ih_item_body(src,\n\t\t\t\t       ih) + ih_item_len(ih) - bytes_or_entries,\n\t\t\t     0);\n\treturn 1;\n}\n\n \nstatic void leaf_copy_items_entirely(struct buffer_info *dest_bi,\n\t\t\t\t     struct buffer_head *src, int last_first,\n\t\t\t\t     int first, int cpy_num)\n{\n\tstruct buffer_head *dest;\n\tint nr, free_space;\n\tint dest_before;\n\tint last_loc, last_inserted_loc, location;\n\tint i, j;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\n\tRFALSE(last_first != LAST_TO_FIRST && last_first != FIRST_TO_LAST,\n\t       \"vs-10090: bad last_first parameter %d\", last_first);\n\tRFALSE(B_NR_ITEMS(src) - first < cpy_num,\n\t       \"vs-10100: too few items in source %d, required %d from %d\",\n\t       B_NR_ITEMS(src), cpy_num, first);\n\tRFALSE(cpy_num < 0, \"vs-10110: can not copy negative amount of items\");\n\tRFALSE(!dest_bi, \"vs-10120: can not copy negative amount of items\");\n\n\tdest = dest_bi->bi_bh;\n\n\tRFALSE(!dest, \"vs-10130: can not copy negative amount of items\");\n\n\tif (cpy_num == 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(dest);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t \n\tdest_before = (last_first == LAST_TO_FIRST) ? 0 : nr;\n\n\t \n\tih = item_head(dest, dest_before);\n\n\tRFALSE(blkh_free_space(blkh) < cpy_num * IH_SIZE,\n\t       \"vs-10140: not enough free space for headers %d (needed %d)\",\n\t       B_FREE_SPACE(dest), cpy_num * IH_SIZE);\n\n\t \n\tmemmove(ih + cpy_num, ih, (nr - dest_before) * IH_SIZE);\n\n\t \n\tmemcpy(ih, item_head(src, first), cpy_num * IH_SIZE);\n\n\tfree_space -= (IH_SIZE * cpy_num);\n\tset_blkh_free_space(blkh, free_space);\n\n\t \n\tj = location = (dest_before == 0) ? dest->b_size : ih_location(ih - 1);\n\tfor (i = dest_before; i < nr + cpy_num; i++) {\n\t\tlocation -= ih_item_len(ih + i - dest_before);\n\t\tput_ih_location(ih + i - dest_before, location);\n\t}\n\n\t \n\tlast_loc = ih_location(&ih[nr + cpy_num - 1 - dest_before]);\n\tlast_inserted_loc = ih_location(&ih[cpy_num - 1]);\n\n\t \n\tRFALSE(free_space < j - last_inserted_loc,\n\t       \"vs-10150: not enough free space for items %d (needed %d)\",\n\t       free_space, j - last_inserted_loc);\n\n\tmemmove(dest->b_data + last_loc,\n\t\tdest->b_data + last_loc + j - last_inserted_loc,\n\t\tlast_inserted_loc - last_loc);\n\n\t \n\tmemcpy(dest->b_data + last_inserted_loc,\n\t       item_body(src, (first + cpy_num - 1)),\n\t       j - last_inserted_loc);\n\n\t \n\tset_blkh_nr_item(blkh, nr + cpy_num);\n\tset_blkh_free_space(blkh, free_space - (j - last_inserted_loc));\n\n\tdo_balance_mark_leaf_dirty(dest_bi->tb, dest, 0);\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tRFALSE(dc_block_number(t_dc) != dest->b_blocknr,\n\t\t       \"vs-10160: block number in bh does not match to field in disk_child structure %lu and %lu\",\n\t\t       (long unsigned)dest->b_blocknr,\n\t\t       (long unsigned)dc_block_number(t_dc));\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (j - last_inserted_loc +\n\t\t\t\t\t     IH_SIZE * cpy_num));\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t}\n}\n\n \nstatic void leaf_item_bottle(struct buffer_info *dest_bi,\n\t\t\t     struct buffer_head *src, int last_first,\n\t\t\t     int item_num, int cpy_bytes)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tstruct item_head *ih;\n\n\tRFALSE(cpy_bytes == -1,\n\t       \"vs-10170: bytes == - 1 means: do not split item\");\n\n\tif (last_first == FIRST_TO_LAST) {\n\t\t \n\t\tih = item_head(src, item_num);\n\t\tif (is_direntry_le_ih(ih))\n\t\t\tleaf_copy_dir_entries(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t      item_num, 0, cpy_bytes);\n\t\telse {\n\t\t\tstruct item_head n_ih;\n\n\t\t\t \n\t\t\tmemcpy(&n_ih, ih, IH_SIZE);\n\t\t\tput_ih_item_len(&n_ih, cpy_bytes);\n\t\t\tif (is_indirect_le_ih(ih)) {\n\t\t\t\tRFALSE(cpy_bytes == ih_item_len(ih)\n\t\t\t\t       && get_ih_free_space(ih),\n\t\t\t\t       \"vs-10180: when whole indirect item is bottle to left neighbor, it must have free_space==0 (not %lu)\",\n\t\t\t\t       (long unsigned)get_ih_free_space(ih));\n\t\t\t\tset_ih_free_space(&n_ih, 0);\n\t\t\t}\n\n\t\t\tRFALSE(op_is_left_mergeable(&ih->ih_key, src->b_size),\n\t\t\t       \"vs-10190: bad mergeability of item %h\", ih);\n\t\t\tn_ih.ih_version = ih->ih_version;\t \n\t\t\tleaf_insert_into_buf(dest_bi, B_NR_ITEMS(dest), &n_ih,\n\t\t\t\t\t     item_body(src, item_num), 0);\n\t\t}\n\t} else {\n\t\t \n\t\tih = item_head(src, item_num);\n\t\tif (is_direntry_le_ih(ih))\n\t\t\tleaf_copy_dir_entries(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t\t      item_num,\n\t\t\t\t\t      ih_entry_count(ih) - cpy_bytes,\n\t\t\t\t\t      cpy_bytes);\n\t\telse {\n\t\t\tstruct item_head n_ih;\n\n\t\t\t \n\t\t\tmemcpy(&n_ih.ih_key, &ih->ih_key, KEY_SIZE);\n\n\t\t\t \n\t\t\tn_ih.ih_version = ih->ih_version;\n\n\t\t\tif (is_direct_le_ih(ih)) {\n\t\t\t\tset_le_ih_k_offset(&n_ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   ih_item_len(ih) - cpy_bytes);\n\t\t\t\tset_le_ih_k_type(&n_ih, TYPE_DIRECT);\n\t\t\t\tset_ih_free_space(&n_ih, MAX_US_INT);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tRFALSE(!cpy_bytes && get_ih_free_space(ih),\n\t\t\t\t       \"vs-10200: ih->ih_free_space must be 0 when indirect item will be appended\");\n\t\t\t\tset_le_ih_k_offset(&n_ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   (ih_item_len(ih) -\n\t\t\t\t\t\t    cpy_bytes) / UNFM_P_SIZE *\n\t\t\t\t\t\t   dest->b_size);\n\t\t\t\tset_le_ih_k_type(&n_ih, TYPE_INDIRECT);\n\t\t\t\tset_ih_free_space(&n_ih, get_ih_free_space(ih));\n\t\t\t}\n\n\t\t\t \n\t\t\tput_ih_item_len(&n_ih, cpy_bytes);\n\n\t\t\t \n\t\t\tn_ih.ih_version = ih->ih_version;\n\n\t\t\tleaf_insert_into_buf(dest_bi, 0, &n_ih,\n\t\t\t\t\t     item_body(src, item_num) +\n\t\t\t\t\t\tih_item_len(ih) - cpy_bytes, 0);\n\t\t}\n\t}\n}\n\n \nstatic int leaf_copy_items(struct buffer_info *dest_bi, struct buffer_head *src,\n\t\t\t   int last_first, int cpy_num, int cpy_bytes)\n{\n\tstruct buffer_head *dest;\n\tint pos, i, src_nr_item, bytes;\n\n\tdest = dest_bi->bi_bh;\n\tRFALSE(!dest || !src, \"vs-10210: !dest || !src\");\n\tRFALSE(last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST,\n\t       \"vs-10220:last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST\");\n\tRFALSE(B_NR_ITEMS(src) < cpy_num,\n\t       \"vs-10230: No enough items: %d, req. %d\", B_NR_ITEMS(src),\n\t       cpy_num);\n\tRFALSE(cpy_num < 0, \"vs-10240: cpy_num < 0 (%d)\", cpy_num);\n\n\tif (cpy_num == 0)\n\t\treturn 0;\n\n\tif (last_first == FIRST_TO_LAST) {\n\t\t \n\t\tpos = 0;\n\t\tif (cpy_num == 1)\n\t\t\tbytes = cpy_bytes;\n\t\telse\n\t\t\tbytes = -1;\n\n\t\t \n\t\ti = leaf_copy_boundary_item(dest_bi, src, FIRST_TO_LAST, bytes);\n\t\tcpy_num -= i;\n\t\tif (cpy_num == 0)\n\t\t\treturn i;\n\t\tpos += i;\n\t\tif (cpy_bytes == -1)\n\t\t\t \n\t\t\tleaf_copy_items_entirely(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t\t pos, cpy_num);\n\t\telse {\n\t\t\t \n\t\t\tleaf_copy_items_entirely(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t\t pos, cpy_num - 1);\n\n\t\t\t \n\t\t\tleaf_item_bottle(dest_bi, src, FIRST_TO_LAST,\n\t\t\t\t\t cpy_num + pos - 1, cpy_bytes);\n\t\t}\n\t} else {\n\t\t \n\t\tsrc_nr_item = B_NR_ITEMS(src);\n\t\tif (cpy_num == 1)\n\t\t\tbytes = cpy_bytes;\n\t\telse\n\t\t\tbytes = -1;\n\n\t\t \n\t\ti = leaf_copy_boundary_item(dest_bi, src, LAST_TO_FIRST, bytes);\n\n\t\tcpy_num -= i;\n\t\tif (cpy_num == 0)\n\t\t\treturn i;\n\n\t\tpos = src_nr_item - cpy_num - i;\n\t\tif (cpy_bytes == -1) {\n\t\t\t \n\t\t\tleaf_copy_items_entirely(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t\t\t pos, cpy_num);\n\t\t} else {\n\t\t\t \n\t\t\tleaf_copy_items_entirely(dest_bi, src, LAST_TO_FIRST,\n\t\t\t\t\t\t pos + 1, cpy_num - 1);\n\n\t\t\t \n\t\t\tleaf_item_bottle(dest_bi, src, LAST_TO_FIRST, pos,\n\t\t\t\t\t cpy_bytes);\n\t\t}\n\t}\n\treturn i;\n}\n\n \nstatic void leaf_define_dest_src_infos(int shift_mode, struct tree_balance *tb,\n\t\t\t\t       struct buffer_info *dest_bi,\n\t\t\t\t       struct buffer_info *src_bi,\n\t\t\t\t       int *first_last,\n\t\t\t\t       struct buffer_head *Snew)\n{\n\tmemset(dest_bi, 0, sizeof(struct buffer_info));\n\tmemset(src_bi, 0, sizeof(struct buffer_info));\n\n\t \n\tswitch (shift_mode) {\n\tcase LEAF_FROM_S_TO_L:\t \n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\n\n\t\t \n\t\tsrc_bi->bi_position = PATH_H_B_ITEM_ORDER(tb->tb_path, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[0];\n\t\tdest_bi->bi_parent = tb->FL[0];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, 0);\n\t\t*first_last = FIRST_TO_LAST;\n\t\tbreak;\n\n\tcase LEAF_FROM_S_TO_R:\t \n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\n\t\tsrc_bi->bi_position = PATH_H_B_ITEM_ORDER(tb->tb_path, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[0];\n\t\tdest_bi->bi_parent = tb->FR[0];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, 0);\n\t\t*first_last = LAST_TO_FIRST;\n\t\tbreak;\n\n\tcase LEAF_FROM_R_TO_L:\t \n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->R[0];\n\t\tsrc_bi->bi_parent = tb->FR[0];\n\t\tsrc_bi->bi_position = get_right_neighbor_position(tb, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[0];\n\t\tdest_bi->bi_parent = tb->FL[0];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, 0);\n\t\t*first_last = FIRST_TO_LAST;\n\t\tbreak;\n\n\tcase LEAF_FROM_L_TO_R:\t \n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->L[0];\n\t\tsrc_bi->bi_parent = tb->FL[0];\n\t\tsrc_bi->bi_position = get_left_neighbor_position(tb, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[0];\n\t\tdest_bi->bi_parent = tb->FR[0];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, 0);\n\t\t*first_last = LAST_TO_FIRST;\n\t\tbreak;\n\n\tcase LEAF_FROM_S_TO_SNEW:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\n\t\tsrc_bi->bi_position = PATH_H_B_ITEM_ORDER(tb->tb_path, 0);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = Snew;\n\t\tdest_bi->bi_parent = NULL;\n\t\tdest_bi->bi_position = 0;\n\t\t*first_last = LAST_TO_FIRST;\n\t\tbreak;\n\n\tdefault:\n\t\treiserfs_panic(sb_from_bi(src_bi), \"vs-10250\",\n\t\t\t       \"shift type is unknown (%d)\", shift_mode);\n\t}\n\tRFALSE(!src_bi->bi_bh || !dest_bi->bi_bh,\n\t       \"vs-10260: mode==%d, source (%p) or dest (%p) buffer is initialized incorrectly\",\n\t       shift_mode, src_bi->bi_bh, dest_bi->bi_bh);\n}\n\n \nint leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}\n\n \nint leaf_shift_left(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tstruct buffer_head *S0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint i;\n\n\t \n\ti = leaf_move_items(LEAF_FROM_S_TO_L, tb, shift_num, shift_bytes, NULL);\n\n\tif (shift_num) {\n\t\t \n\t\tif (B_NR_ITEMS(S0) == 0) {\n\n\t\t\tRFALSE(shift_bytes != -1,\n\t\t\t       \"vs-10270: S0 is empty now, but shift_bytes != -1 (%d)\",\n\t\t\t       shift_bytes);\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\tif (tb->tb_mode == M_PASTE || tb->tb_mode == M_INSERT) {\n\t\t\t\tprint_cur_tb(\"vs-10275\");\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-10275\",\n\t\t\t\t\t       \"balance condition corrupted \"\n\t\t\t\t\t       \"(%c)\", tb->tb_mode);\n\t\t\t}\n#endif\n\n\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0)\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\n\t\t} else {\n\t\t\t \n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], S0, 0);\n\n\t\t\tRFALSE((shift_bytes != -1 &&\n\t\t\t\t!(is_direntry_le_ih(item_head(S0, 0))\n\t\t\t\t  && !ih_entry_count(item_head(S0, 0)))) &&\n\t\t\t       (!op_is_left_mergeable\n\t\t\t\t(leaf_key(S0, 0), S0->b_size)),\n\t\t\t       \"vs-10280: item must be mergeable\");\n\t\t}\n\t}\n\n\treturn i;\n}\n\n \n\n \nint leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tint ret_value;\n\n\t \n\tret_value =\n\t    leaf_move_items(LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, NULL);\n\n\t \n\tif (shift_num) {\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t}\n\n\treturn ret_value;\n}\n\nstatic void leaf_delete_items_entirely(struct buffer_info *bi,\n\t\t\t\t       int first, int del_num);\n \nvoid leaf_delete_items(struct buffer_info *cur_bi, int last_first,\n\t\t       int first, int del_num, int del_bytes)\n{\n\tstruct buffer_head *bh;\n\tint item_amount = B_NR_ITEMS(bh = cur_bi->bi_bh);\n\n\tRFALSE(!bh, \"10155: bh is not defined\");\n\tRFALSE(del_num < 0, \"10160: del_num can not be < 0. del_num==%d\",\n\t       del_num);\n\tRFALSE(first < 0\n\t       || first + del_num > item_amount,\n\t       \"10165: invalid number of first item to be deleted (%d) or \"\n\t       \"no so much items (%d) to delete (only %d)\", first,\n\t       first + del_num, item_amount);\n\n\tif (del_num == 0)\n\t\treturn;\n\n\tif (first == 0 && del_num == item_amount && del_bytes == -1) {\n\t\tmake_empty_node(cur_bi);\n\t\tdo_balance_mark_leaf_dirty(cur_bi->tb, bh, 0);\n\t\treturn;\n\t}\n\n\tif (del_bytes == -1)\n\t\t \n\t\tleaf_delete_items_entirely(cur_bi, first, del_num);\n\telse {\n\t\tif (last_first == FIRST_TO_LAST) {\n\t\t\t \n\t\t\tleaf_delete_items_entirely(cur_bi, first, del_num - 1);\n\n\t\t\t \n\t\t\tleaf_cut_from_buffer(cur_bi, 0, 0, del_bytes);\n\t\t} else {\n\t\t\tstruct item_head *ih;\n\t\t\tint len;\n\n\t\t\t \n\t\t\tleaf_delete_items_entirely(cur_bi, first + 1,\n\t\t\t\t\t\t   del_num - 1);\n\n\t\t\tih = item_head(bh, B_NR_ITEMS(bh) - 1);\n\t\t\tif (is_direntry_le_ih(ih))\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tlen = ih_entry_count(ih);\n\t\t\telse\n\t\t\t\t \n\t\t\t\tlen = ih_item_len(ih);\n\n\t\t\t \n\t\t\tleaf_cut_from_buffer(cur_bi, B_NR_ITEMS(bh) - 1,\n\t\t\t\t\t     len - del_bytes, del_bytes);\n\t\t}\n\t}\n}\n\n \nvoid leaf_insert_into_buf(struct buffer_info *bi, int before,\n\t\t\t  struct item_head * const inserted_item_ih,\n\t\t\t  const char * const inserted_item_body,\n\t\t\t  int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\tchar *to;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t \n\tRFALSE(free_space < ih_item_len(inserted_item_ih) + IH_SIZE,\n\t       \"vs-10170: not enough free space in block %z, new item %h\",\n\t       bh, inserted_item_ih);\n\tRFALSE(zeros_number > ih_item_len(inserted_item_ih),\n\t       \"vs-10172: zero number == %d, item length == %d\",\n\t       zeros_number, ih_item_len(inserted_item_ih));\n\n\t \n\tih = item_head(bh, before);\n\n\t \n\tlast_loc = nr ? ih_location(&ih[nr - before - 1]) : bh->b_size;\n\tunmoved_loc = before ? ih_location(ih - 1) : bh->b_size;\n\n\tmemmove(bh->b_data + last_loc - ih_item_len(inserted_item_ih),\n\t\tbh->b_data + last_loc, unmoved_loc - last_loc);\n\n\tto = bh->b_data + unmoved_loc - ih_item_len(inserted_item_ih);\n\tmemset(to, 0, zeros_number);\n\tto += zeros_number;\n\n\t \n\tif (inserted_item_body)\n\t\tmemmove(to, inserted_item_body,\n\t\t\tih_item_len(inserted_item_ih) - zeros_number);\n\telse\n\t\tmemset(to, '\\0', ih_item_len(inserted_item_ih) - zeros_number);\n\n\t \n\tmemmove(ih + 1, ih, IH_SIZE * (nr - before));\n\tmemmove(ih, inserted_item_ih, IH_SIZE);\n\n\t \n\tfor (i = before; i < nr + 1; i++) {\n\t\tunmoved_loc -= ih_item_len(&ih[i - before]);\n\t\tput_ih_location(&ih[i - before], unmoved_loc);\n\t}\n\n\t \n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh,\n\t\t\t    free_space - (IH_SIZE +\n\t\t\t\t\t  ih_item_len(inserted_item_ih)));\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 1);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (IH_SIZE +\n\t\t\t\t\t     ih_item_len(inserted_item_ih)));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}\n\n \nvoid leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t \n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t \n\n\t \n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t \n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t \n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t \n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t \n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t \n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}\n\n \nstatic int leaf_cut_entries(struct buffer_head *bh,\n\t\t\t    struct item_head *ih, int from, int del_count)\n{\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tint prev_record_offset;\t \n\tchar *prev_record;\t \n\tint cut_records_len;\t \n\tint i;\n\n\t \n\tRFALSE(!is_direntry_le_ih(ih), \"10180: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < from + del_count,\n\t       \"10185: item contains not enough entries: entry_count = %d, from = %d, to delete = %d\",\n\t       ih_entry_count(ih), from, del_count);\n\n\tif (del_count == 0)\n\t\treturn 0;\n\n\t \n\titem = bh->b_data + ih_location(ih);\n\n\t \n\tdeh = B_I_DEH(bh, ih);\n\n\t \n\tprev_record_offset =\n\t    (from ? deh_location(&deh[from - 1]) : ih_item_len(ih));\n\tcut_records_len = prev_record_offset    -\n\t    deh_location(&deh[from + del_count - 1]);\n\tprev_record = item + prev_record_offset;\n\n\t \n\tfor (i = ih_entry_count(ih) - 1; i > from + del_count - 1; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) -\n\t\t\t\t (DEH_SIZE * del_count));\n\n\tfor (i = 0; i < from; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) - (DEH_SIZE * del_count +\n\t\t\t\t\t\t\t  cut_records_len));\n\n\tput_ih_entry_count(ih, ih_entry_count(ih) - del_count);\n\n\t \n\tmemmove((char *)(deh + from),\n\t\tdeh + from + del_count,\n\t\tprev_record - cut_records_len - (char *)(deh + from +\n\t\t\t\t\t\t\t del_count));\n\n\t \n\tmemmove(prev_record - cut_records_len - DEH_SIZE * del_count,\n\t\tprev_record, item + ih_item_len(ih) - prev_record);\n\n\treturn DEH_SIZE * del_count + cut_records_len;\n}\n\n \nvoid leaf_cut_from_buffer(struct buffer_info *bi, int cut_item_num,\n\t\t\t  int pos_in_item, int cut_size)\n{\n\tint nr;\n\tstruct buffer_head *bh = bi->bi_bh;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint last_loc, unmoved_loc;\n\tint i;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\n\t \n\tih = item_head(bh, cut_item_num);\n\n\tif (is_direntry_le_ih(ih)) {\n\t\t \n\t\tcut_size = leaf_cut_entries(bh, ih, pos_in_item, cut_size);\n\t\tif (pos_in_item == 0) {\n\t\t\t \n\t\t\tRFALSE(cut_item_num,\n\t\t\t       \"when 0-th enrty of item is cut, that item must be first in the node, not %d-th\",\n\t\t\t       cut_item_num);\n\t\t\t \n\t\t\tset_le_ih_k_offset(ih, deh_offset(B_I_DEH(bh, ih)));\n\t\t}\n\t} else {\n\t\t \n\t\tRFALSE(is_statdata_le_ih(ih), \"10195: item is stat data\");\n\t\tRFALSE(pos_in_item && pos_in_item + cut_size != ih_item_len(ih),\n\t\t       \"10200: invalid offset (%lu) or trunc_size (%lu) or ih_item_len (%lu)\",\n\t\t       (long unsigned)pos_in_item, (long unsigned)cut_size,\n\t\t       (long unsigned)ih_item_len(ih));\n\n\t\t \n\t\tif (pos_in_item == 0) {\n\t\t\tmemmove(bh->b_data + ih_location(ih),\n\t\t\t\tbh->b_data + ih_location(ih) + cut_size,\n\t\t\t\tih_item_len(ih) - cut_size);\n\n\t\t\t \n\t\t\tif (is_direct_le_ih(ih))\n\t\t\t\tset_le_ih_k_offset(ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   cut_size);\n\t\t\telse {\n\t\t\t\tset_le_ih_k_offset(ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   (cut_size / UNFM_P_SIZE) *\n\t\t\t\t\t\t   bh->b_size);\n\t\t\t\tRFALSE(ih_item_len(ih) == cut_size\n\t\t\t\t       && get_ih_free_space(ih),\n\t\t\t\t       \"10205: invalid ih_free_space (%h)\", ih);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tlast_loc = ih_location(&ih[nr - cut_item_num - 1]);\n\n\t \n\tunmoved_loc = cut_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t \n\tmemmove(bh->b_data + last_loc + cut_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc - cut_size);\n\n\t \n\tput_ih_item_len(ih, ih_item_len(ih) - cut_size);\n\n\tif (is_indirect_le_ih(ih)) {\n\t\tif (pos_in_item)\n\t\t\tset_ih_free_space(ih, 0);\n\t}\n\n\t \n\tfor (i = cut_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - cut_item_num],\n\t\t\t\tih_location(&ih[i - cut_item_num]) + cut_size);\n\n\t \n\tset_blkh_free_space(blkh, blkh_free_space(blkh) + cut_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) - cut_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}\n\n \nstatic void leaf_delete_items_entirely(struct buffer_info *bi,\n\t\t\t\t       int first, int del_num)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr;\n\tint i, j;\n\tint last_loc, last_removed_loc;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\n\tRFALSE(bh == NULL, \"10210: buffer is 0\");\n\tRFALSE(del_num < 0, \"10215: del_num less than 0 (%d)\", del_num);\n\n\tif (del_num == 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\n\tRFALSE(first < 0 || first + del_num > nr,\n\t       \"10220: first=%d, number=%d, there is %d items\", first, del_num,\n\t       nr);\n\n\tif (first == 0 && del_num == nr) {\n\t\t \n\t\tmake_empty_node(bi);\n\n\t\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\t\treturn;\n\t}\n\n\tih = item_head(bh, first);\n\n\t \n\tj = (first == 0) ? bh->b_size : ih_location(ih - 1);\n\n\t \n\tlast_loc = ih_location(&ih[nr - 1 - first]);\n\tlast_removed_loc = ih_location(&ih[del_num - 1]);\n\n\tmemmove(bh->b_data + last_loc + j - last_removed_loc,\n\t\tbh->b_data + last_loc, last_removed_loc - last_loc);\n\n\t \n\tmemmove(ih, ih + del_num, (nr - first - del_num) * IH_SIZE);\n\n\t \n\tfor (i = first; i < nr - del_num; i++)\n\t\tput_ih_location(&ih[i - first],\n\t\t\t\tih_location(&ih[i - first]) + (j -\n\t\t\t\t\t\t\t\t last_removed_loc));\n\n\t \n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) - del_num);\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) + (j - last_removed_loc +\n\t\t\t\t\t\t     IH_SIZE * del_num));\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) - (j - last_removed_loc +\n\t\t\t\t\t     IH_SIZE * del_num));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}\n\n \nvoid leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t \n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t \n\titem = bh->b_data + ih_location(ih);\n\n\t \n\tdeh = B_I_DEH(bh, ih);\n\n\t \n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t \n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t \n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t \n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t \n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t \n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t \n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t \n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t \n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t \n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}