{
  "module_name": "namei.c",
  "hash_id": "e1098dc8b1db66136a0ab49aa238d04154060a39f28250faee517078da474d38",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/namei.c",
  "human_readable_source": " \n\n#include <linux/time.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include \"reiserfs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n\n#define INC_DIR_INODE_NLINK(i) if (i->i_nlink != 1) { inc_nlink(i); if (i->i_nlink >= REISERFS_LINK_MAX) set_nlink(i, 1); }\n#define DEC_DIR_INODE_NLINK(i) if (i->i_nlink != 1) drop_nlink(i);\n\n \nstatic int bin_search_in_dir_item(struct reiserfs_dir_entry *de, loff_t off)\n{\n\tstruct item_head *ih = de->de_ih;\n\tstruct reiserfs_de_head *deh = de->de_deh;\n\tint rbound, lbound, j;\n\n\tlbound = 0;\n\trbound = ih_entry_count(ih) - 1;\n\n\tfor (j = (rbound + lbound) / 2; lbound <= rbound;\n\t     j = (rbound + lbound) / 2) {\n\t\tif (off < deh_offset(deh + j)) {\n\t\t\trbound = j - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (off > deh_offset(deh + j)) {\n\t\t\tlbound = j + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tde->de_entry_num = j;\n\t\treturn NAME_FOUND;\n\t}\n\n\tde->de_entry_num = lbound;\n\treturn NAME_NOT_FOUND;\n}\n\n \nstatic inline void set_de_item_location(struct reiserfs_dir_entry *de,\n\t\t\t\t\tstruct treepath *path)\n{\n\tde->de_bh = get_last_bh(path);\n\tde->de_ih = tp_item_head(path);\n\tde->de_deh = B_I_DEH(de->de_bh, de->de_ih);\n\tde->de_item_num = PATH_LAST_POSITION(path);\n}\n\n \ninline void set_de_name_and_namelen(struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh + de->de_entry_num;\n\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\n\tde->de_entrylen = entry_length(de->de_bh, de->de_ih, de->de_entry_num);\n\tde->de_namelen = de->de_entrylen - (de_with_sd(deh) ? SD_SIZE : 0);\n\tde->de_name = ih_item_body(de->de_bh, de->de_ih) + deh_location(deh);\n\tif (de->de_name[de->de_namelen - 1] == 0)\n\t\tde->de_namelen = strlen(de->de_name);\n}\n\n \nstatic inline void set_de_object_key(struct reiserfs_dir_entry *de)\n{\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\tde->de_dir_id = deh_dir_id(&de->de_deh[de->de_entry_num]);\n\tde->de_objectid = deh_objectid(&de->de_deh[de->de_entry_num]);\n}\n\nstatic inline void store_de_entry_key(struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh + de->de_entry_num;\n\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\n\t \n\tde->de_entry_key.version = KEY_FORMAT_3_5;\n\tde->de_entry_key.on_disk_key.k_dir_id =\n\t    le32_to_cpu(de->de_ih->ih_key.k_dir_id);\n\tde->de_entry_key.on_disk_key.k_objectid =\n\t    le32_to_cpu(de->de_ih->ih_key.k_objectid);\n\tset_cpu_key_k_offset(&de->de_entry_key, deh_offset(deh));\n\tset_cpu_key_k_type(&de->de_entry_key, TYPE_DIRENTRY);\n}\n\n \n \nint search_by_entry_key(struct super_block *sb, const struct cpu_key *key,\n\t\t\tstruct treepath *path, struct reiserfs_dir_entry *de)\n{\n\tint retval;\n\n\tretval = search_item(sb, key, path);\n\tswitch (retval) {\n\tcase ITEM_NOT_FOUND:\n\t\tif (!PATH_LAST_POSITION(path)) {\n\t\t\treiserfs_error(sb, \"vs-7000\", \"search_by_key \"\n\t\t\t\t       \"returned item position == 0\");\n\t\t\tpathrelse(path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\tPATH_LAST_POSITION(path)--;\n\t\tbreak;\n\n\tcase ITEM_FOUND:\n\t\tbreak;\n\n\tcase IO_ERROR:\n\t\treturn retval;\n\n\tdefault:\n\t\tpathrelse(path);\n\t\treiserfs_error(sb, \"vs-7002\", \"no path to here\");\n\t\treturn IO_ERROR;\n\t}\n\n\tset_de_item_location(de, path);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (!is_direntry_le_ih(de->de_ih) ||\n\t    COMP_SHORT_KEYS(&de->de_ih->ih_key, key)) {\n\t\tprint_block(de->de_bh, 0, -1, -1);\n\t\treiserfs_panic(sb, \"vs-7005\", \"found item %h is not directory \"\n\t\t\t       \"item or does not belong to the same directory \"\n\t\t\t       \"as key %K\", de->de_ih, key);\n\t}\n#endif\t\t\t\t \n\n\t \n\tretval = bin_search_in_dir_item(de, cpu_key_k_offset(key));\n\tpath->pos_in_item = de->de_entry_num;\n\tif (retval != NAME_NOT_FOUND) {\n\t\t \n\t\tset_de_name_and_namelen(de);\n\t\tset_de_object_key(de);\n\t}\n\treturn retval;\n}\n\n \n\n \nstatic __u32 get_third_component(struct super_block *s,\n\t\t\t\t const char *name, int len)\n{\n\t__u32 res;\n\n\tif (!len || (len == 1 && name[0] == '.'))\n\t\treturn DOT_OFFSET;\n\tif (len == 2 && name[0] == '.' && name[1] == '.')\n\t\treturn DOT_DOT_OFFSET;\n\n\tres = REISERFS_SB(s)->s_hash_function(name, len);\n\n\t \n\tres = GET_HASH_VALUE(res);\n\tif (res == 0)\n\t\t \n\t\tres = 128;\n\treturn res + MAX_GENERATION_NUMBER;\n}\n\nstatic int reiserfs_match(struct reiserfs_dir_entry *de,\n\t\t\t  const char *name, int namelen)\n{\n\tint retval = NAME_NOT_FOUND;\n\n\tif ((namelen == de->de_namelen) &&\n\t    !memcmp(de->de_name, name, de->de_namelen))\n\t\tretval =\n\t\t    (de_visible(de->de_deh + de->de_entry_num) ? NAME_FOUND :\n\t\t     NAME_FOUND_INVISIBLE);\n\n\treturn retval;\n}\n\n \n\n \n\nstatic int linear_search_in_dir_item(struct cpu_key *key,\n\t\t\t\t     struct reiserfs_dir_entry *de,\n\t\t\t\t     const char *name, int namelen)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh;\n\tint retval;\n\tint i;\n\n\ti = de->de_entry_num;\n\n\tif (i == ih_entry_count(de->de_ih) ||\n\t    GET_HASH_VALUE(deh_offset(deh + i)) !=\n\t    GET_HASH_VALUE(cpu_key_k_offset(key))) {\n\t\ti--;\n\t}\n\n\tRFALSE(de->de_deh != B_I_DEH(de->de_bh, de->de_ih),\n\t       \"vs-7010: array of entry headers not found\");\n\n\tdeh += i;\n\n\tfor (; i >= 0; i--, deh--) {\n\t\t \n\t\tif (GET_HASH_VALUE(deh_offset(deh)) !=\n\t\t    GET_HASH_VALUE(cpu_key_k_offset(key))) {\n\t\t\treturn NAME_NOT_FOUND;\n\t\t}\n\n\t\t \n\t\tif (de->de_gen_number_bit_string)\n\t\t\tset_bit(GET_GENERATION_NUMBER(deh_offset(deh)),\n\t\t\t\tde->de_gen_number_bit_string);\n\n\t\t \n\t\tde->de_entry_num = i;\n\t\tset_de_name_and_namelen(de);\n\n\t\t \n\t\tif ((retval =\n\t\t     reiserfs_match(de, name, namelen)) != NAME_NOT_FOUND) {\n\n\t\t\t \n\t\t\tset_de_object_key(de);\n\n\t\t\tstore_de_entry_key(de);\n\n\t\t\t \n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (GET_GENERATION_NUMBER(le_ih_k_offset(de->de_ih)) == 0)\n\t\t \n\t\t \n\t\treturn NAME_NOT_FOUND;\n\n\tRFALSE(de->de_item_num,\n\t       \"vs-7015: two diritems of the same directory in one node?\");\n\n\treturn GOTO_PREVIOUS_ITEM;\n}\n\n \nstatic int reiserfs_find_entry(struct inode *dir, const char *name, int namelen,\n\t\t\t       struct treepath *path_to_entry,\n\t\t\t       struct reiserfs_dir_entry *de)\n{\n\tstruct cpu_key key_to_search;\n\tint retval;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn NAME_NOT_FOUND;\n\n\t \n\tmake_cpu_key(&key_to_search, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\twhile (1) {\n\t\tretval =\n\t\t    search_by_entry_key(dir->i_sb, &key_to_search,\n\t\t\t\t\tpath_to_entry, de);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7001\", \"io error\");\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t \n\t\tretval =\n\t\t    linear_search_in_dir_item(&key_to_search, de, name,\n\t\t\t\t\t      namelen);\n\t\t \n\t\tif (retval != GOTO_PREVIOUS_ITEM) {\n\t\t\tpath_to_entry->pos_in_item = de->de_entry_num;\n\t\t\treturn retval;\n\t\t}\n\n\t\t \n\t\tset_cpu_key_k_offset(&key_to_search,\n\t\t\t\t     le_ih_k_offset(de->de_ih) - 1);\n\t\tpathrelse(path_to_entry);\n\n\t}\t\t\t \n}\n\nstatic struct dentry *reiserfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t      unsigned int flags)\n{\n\tint retval;\n\tstruct inode *inode = NULL;\n\tstruct reiserfs_dir_entry de;\n\tINITIALIZE_PATH(path_to_entry);\n\n\tif (REISERFS_MAX_NAME(dir->i_sb->s_blocksize) < dentry->d_name.len)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\treiserfs_write_lock(dir->i_sb);\n\n\tde.de_gen_number_bit_string = NULL;\n\tretval =\n\t    reiserfs_find_entry(dir, dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t&path_to_entry, &de);\n\tpathrelse(&path_to_entry);\n\tif (retval == NAME_FOUND) {\n\t\tinode = reiserfs_iget(dir->i_sb,\n\t\t\t\t      (struct cpu_key *)&de.de_dir_id);\n\t\tif (!inode || IS_ERR(inode)) {\n\t\t\treiserfs_write_unlock(dir->i_sb);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\t \n\t\tif (IS_PRIVATE(dir))\n\t\t\treiserfs_init_priv_inode(inode);\n\t}\n\treiserfs_write_unlock(dir->i_sb);\n\tif (retval == IO_ERROR) {\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn d_splice_alias(inode, dentry);\n}\n\n \nstruct dentry *reiserfs_get_parent(struct dentry *child)\n{\n\tint retval;\n\tstruct inode *inode = NULL;\n\tstruct reiserfs_dir_entry de;\n\tINITIALIZE_PATH(path_to_entry);\n\tstruct inode *dir = d_inode(child);\n\n\tif (dir->i_nlink == 0) {\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tde.de_gen_number_bit_string = NULL;\n\n\treiserfs_write_lock(dir->i_sb);\n\tretval = reiserfs_find_entry(dir, \"..\", 2, &path_to_entry, &de);\n\tpathrelse(&path_to_entry);\n\tif (retval != NAME_FOUND) {\n\t\treiserfs_write_unlock(dir->i_sb);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tinode = reiserfs_iget(dir->i_sb, (struct cpu_key *)&de.de_dir_id);\n\treiserfs_write_unlock(dir->i_sb);\n\n\treturn d_obtain_alias(inode);\n}\n\n \n\nstatic int reiserfs_add_entry(struct reiserfs_transaction_handle *th,\n\t\t\t      struct inode *dir, const char *name, int namelen,\n\t\t\t      struct inode *inode, int visible)\n{\n\tstruct cpu_key entry_key;\n\tstruct reiserfs_de_head *deh;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tDECLARE_BITMAP(bit_string, MAX_GENERATION_NUMBER + 1);\n\tint gen_number;\n\n\t \n\tchar small_buf[32 + DEH_SIZE];\n\n\tchar *buffer;\n\tint buflen, paste_size;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t \n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn -ENAMETOOLONG;\n\n\t \n\tmake_cpu_key(&entry_key, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\t \n\tbuflen = DEH_SIZE + ROUND_UP(namelen);\n\tif (buflen > sizeof(small_buf)) {\n\t\tbuffer = kmalloc(buflen, GFP_NOFS);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuffer = small_buf;\n\n\tpaste_size =\n\t    (get_inode_sd_version(dir) ==\n\t     STAT_DATA_V1) ? (DEH_SIZE + namelen) : buflen;\n\n\t \n\tdeh = (struct reiserfs_de_head *)buffer;\n\tdeh->deh_location = 0;\t \n\tput_deh_offset(deh, cpu_key_k_offset(&entry_key));\n\tdeh->deh_state = 0;\t \n\t \n\n\t \n\tdeh->deh_dir_id = INODE_PKEY(inode)->k_dir_id;\n\t \n\tdeh->deh_objectid = INODE_PKEY(inode)->k_objectid;\n\n\t \n\tmemcpy((char *)(deh + 1), name, namelen);\n\t \n\tpadd_item((char *)(deh + 1), ROUND_UP(namelen), namelen);\n\n\t \n\tmark_de_without_sd(deh);\n\tvisible ? mark_de_visible(deh) : mark_de_hidden(deh);\n\n\t \n\tmemset(bit_string, 0, sizeof(bit_string));\n\tde.de_gen_number_bit_string = bit_string;\n\tretval = reiserfs_find_entry(dir, name, namelen, &path, &de);\n\tif (retval != NAME_NOT_FOUND) {\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\n\t\tif (retval == IO_ERROR) {\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (retval != NAME_FOUND) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7002\",\n\t\t\t\t       \"reiserfs_find_entry() returned \"\n\t\t\t\t       \"unexpected value (%d)\", retval);\n\t\t}\n\n\t\treturn -EEXIST;\n\t}\n\n\tgen_number =\n\t    find_first_zero_bit(bit_string,\n\t\t\t\tMAX_GENERATION_NUMBER + 1);\n\tif (gen_number > MAX_GENERATION_NUMBER) {\n\t\t \n\t\treiserfs_warning(dir->i_sb, \"reiserfs-7010\",\n\t\t\t\t \"Congratulations! we have got hash function \"\n\t\t\t\t \"screwed up\");\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\t\treturn -EBUSY;\n\t}\n\t \n\tput_deh_offset(deh, SET_GENERATION_NUMBER(deh_offset(deh), gen_number));\n\tset_cpu_key_k_offset(&entry_key, deh_offset(deh));\n\n\t \n\tPROC_INFO_MAX(th->t_super, max_hash_collisions, gen_number);\n\n\t \n\tif (gen_number != 0) {\n\t\tif (search_by_entry_key(dir->i_sb, &entry_key, &path, &de) !=\n\t\t    NAME_NOT_FOUND) {\n\t\t\treiserfs_warning(dir->i_sb, \"vs-7032\",\n\t\t\t\t\t \"entry with this key (%K) already \"\n\t\t\t\t\t \"exists\", &entry_key);\n\n\t\t\tif (buffer != small_buf)\n\t\t\t\tkfree(buffer);\n\t\t\tpathrelse(&path);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t \n\tretval =\n\t    reiserfs_paste_into_item(th, &path, &entry_key, dir, buffer,\n\t\t\t\t     paste_size);\n\tif (buffer != small_buf)\n\t\tkfree(buffer);\n\tif (retval) {\n\t\treiserfs_check_path(&path);\n\t\treturn retval;\n\t}\n\n\tdir->i_size += paste_size;\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tif (!S_ISDIR(inode->i_mode) && visible)\n\t\t \n\t\treiserfs_update_sd(th, dir);\n\n\treiserfs_check_path(&path);\n\treturn 0;\n}\n\n \nstatic int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}\n\n \nstatic int new_inode_init(struct inode *inode, struct inode *dir, umode_t mode)\n{\n\t \n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t \n\tinode_init_owner(&nop_mnt_idmap, inode, dir, mode);\n\treturn dquot_initialize(inode);\n}\n\nstatic int reiserfs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t   struct dentry *dentry, umode_t mode, bool excl)\n{\n\tint retval;\n\tstruct inode *inode;\n\t \n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 2 +\n\t    2 * (REISERFS_QUOTA_INIT_BLOCKS(dir->i_sb) +\n\t\t REISERFS_QUOTA_TRANS_BLOCKS(dir->i_sb));\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_security_handle security;\n\n\tretval = dquot_initialize(dir);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!(inode = new_inode(dir->i_sb))) {\n\t\treturn -ENOMEM;\n\t}\n\tretval = new_inode_init(inode, dir, mode);\n\tif (retval) {\n\t\tdrop_new_inode(inode);\n\t\treturn retval;\n\t}\n\n\tjbegin_count += reiserfs_cache_default_acl(dir);\n\tretval = reiserfs_security_init(dir, inode, &dentry->d_name, &security);\n\tif (retval < 0) {\n\t\tdrop_new_inode(inode);\n\t\treturn retval;\n\t}\n\tjbegin_count += retval;\n\treiserfs_write_lock(dir->i_sb);\n\n\tretval = journal_begin(&th, dir->i_sb, jbegin_count);\n\tif (retval) {\n\t\tdrop_new_inode(inode);\n\t\tgoto out_failed;\n\t}\n\n\tretval =\n\t    reiserfs_new_inode(&th, dir, mode, NULL, 0   , dentry,\n\t\t\t       inode, &security);\n\tif (retval)\n\t\tgoto out_failed;\n\n\tinode->i_op = &reiserfs_file_inode_operations;\n\tinode->i_fop = &reiserfs_file_operations;\n\tinode->i_mapping->a_ops = &reiserfs_address_space_operations;\n\n\tretval =\n\t    reiserfs_add_entry(&th, dir, dentry->d_name.name,\n\t\t\t       dentry->d_name.len, inode, 1   );\n\tif (retval) {\n\t\tint err;\n\t\tdrop_nlink(inode);\n\t\treiserfs_update_sd(&th, inode);\n\t\terr = journal_end(&th);\n\t\tif (err)\n\t\t\tretval = err;\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\tgoto out_failed;\n\t}\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(dir);\n\n\td_instantiate_new(dentry, inode);\n\tretval = journal_end(&th);\n\nout_failed:\n\treiserfs_write_unlock(dir->i_sb);\n\treiserfs_security_free(&security);\n\treturn retval;\n}\n\nstatic int reiserfs_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t  struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_security_handle security;\n\t \n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 +\n\t    2 * (REISERFS_QUOTA_INIT_BLOCKS(dir->i_sb) +\n\t\t REISERFS_QUOTA_TRANS_BLOCKS(dir->i_sb));\n\n\tretval = dquot_initialize(dir);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!(inode = new_inode(dir->i_sb))) {\n\t\treturn -ENOMEM;\n\t}\n\tretval = new_inode_init(inode, dir, mode);\n\tif (retval) {\n\t\tdrop_new_inode(inode);\n\t\treturn retval;\n\t}\n\n\tjbegin_count += reiserfs_cache_default_acl(dir);\n\tretval = reiserfs_security_init(dir, inode, &dentry->d_name, &security);\n\tif (retval < 0) {\n\t\tdrop_new_inode(inode);\n\t\treturn retval;\n\t}\n\tjbegin_count += retval;\n\treiserfs_write_lock(dir->i_sb);\n\n\tretval = journal_begin(&th, dir->i_sb, jbegin_count);\n\tif (retval) {\n\t\tdrop_new_inode(inode);\n\t\tgoto out_failed;\n\t}\n\n\tretval =\n\t    reiserfs_new_inode(&th, dir, mode, NULL, 0   , dentry,\n\t\t\t       inode, &security);\n\tif (retval) {\n\t\tgoto out_failed;\n\t}\n\n\tinode->i_op = &reiserfs_special_inode_operations;\n\tinit_special_inode(inode, inode->i_mode, rdev);\n\n\t \n\treiserfs_update_sd(&th, inode);\n\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(dir);\n\n\tretval =\n\t    reiserfs_add_entry(&th, dir, dentry->d_name.name,\n\t\t\t       dentry->d_name.len, inode, 1   );\n\tif (retval) {\n\t\tint err;\n\t\tdrop_nlink(inode);\n\t\treiserfs_update_sd(&th, inode);\n\t\terr = journal_end(&th);\n\t\tif (err)\n\t\t\tretval = err;\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\tgoto out_failed;\n\t}\n\n\td_instantiate_new(dentry, inode);\n\tretval = journal_end(&th);\n\nout_failed:\n\treiserfs_write_unlock(dir->i_sb);\n\treiserfs_security_free(&security);\n\treturn retval;\n}\n\nstatic int reiserfs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t  struct dentry *dentry, umode_t mode)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_security_handle security;\n\t \n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 +\n\t    2 * (REISERFS_QUOTA_INIT_BLOCKS(dir->i_sb) +\n\t\t REISERFS_QUOTA_TRANS_BLOCKS(dir->i_sb));\n\n\tretval = dquot_initialize(dir);\n\tif (retval)\n\t\treturn retval;\n\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\t \n\tREISERFS_I(dir)->new_packing_locality = 1;\n#endif\n\tmode = S_IFDIR | mode;\n\tif (!(inode = new_inode(dir->i_sb))) {\n\t\treturn -ENOMEM;\n\t}\n\tretval = new_inode_init(inode, dir, mode);\n\tif (retval) {\n\t\tdrop_new_inode(inode);\n\t\treturn retval;\n\t}\n\n\tjbegin_count += reiserfs_cache_default_acl(dir);\n\tretval = reiserfs_security_init(dir, inode, &dentry->d_name, &security);\n\tif (retval < 0) {\n\t\tdrop_new_inode(inode);\n\t\treturn retval;\n\t}\n\tjbegin_count += retval;\n\treiserfs_write_lock(dir->i_sb);\n\n\tretval = journal_begin(&th, dir->i_sb, jbegin_count);\n\tif (retval) {\n\t\tdrop_new_inode(inode);\n\t\tgoto out_failed;\n\t}\n\n\t \n\tINC_DIR_INODE_NLINK(dir)\n\n\tretval = reiserfs_new_inode(&th, dir, mode, NULL  ,\n\t\t\t\t    old_format_only(dir->i_sb) ?\n\t\t\t\t    EMPTY_DIR_SIZE_V1 : EMPTY_DIR_SIZE,\n\t\t\t\t    dentry, inode, &security);\n\tif (retval) {\n\t\tDEC_DIR_INODE_NLINK(dir)\n\t\tgoto out_failed;\n\t}\n\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(dir);\n\n\tinode->i_op = &reiserfs_dir_inode_operations;\n\tinode->i_fop = &reiserfs_dir_operations;\n\n\t \n\tretval =\n\t    reiserfs_add_entry(&th, dir, dentry->d_name.name,\n\t\t\t       dentry->d_name.len, inode, 1   );\n\tif (retval) {\n\t\tint err;\n\t\tclear_nlink(inode);\n\t\tDEC_DIR_INODE_NLINK(dir);\n\t\treiserfs_update_sd(&th, inode);\n\t\terr = journal_end(&th);\n\t\tif (err)\n\t\t\tretval = err;\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\tgoto out_failed;\n\t}\n\t \n\treiserfs_update_sd(&th, dir);\n\n\td_instantiate_new(dentry, inode);\n\tretval = journal_end(&th);\nout_failed:\n\treiserfs_write_unlock(dir->i_sb);\n\treiserfs_security_free(&security);\n\treturn retval;\n}\n\nstatic inline int reiserfs_empty_dir(struct inode *inode)\n{\n\t \n\tif (inode->i_size != EMPTY_DIR_SIZE &&\n\t    inode->i_size != EMPTY_DIR_SIZE_V1) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int reiserfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint retval, err;\n\tstruct inode *inode;\n\tstruct reiserfs_transaction_handle th;\n\tint jbegin_count;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\n\t \n\tjbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 2 + 2 +\n\t    4 * REISERFS_QUOTA_TRANS_BLOCKS(dir->i_sb);\n\n\tretval = dquot_initialize(dir);\n\tif (retval)\n\t\treturn retval;\n\n\treiserfs_write_lock(dir->i_sb);\n\tretval = journal_begin(&th, dir->i_sb, jbegin_count);\n\tif (retval)\n\t\tgoto out_rmdir;\n\n\tde.de_gen_number_bit_string = NULL;\n\tif ((retval =\n\t     reiserfs_find_entry(dir, dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t &path, &de)) == NAME_NOT_FOUND) {\n\t\tretval = -ENOENT;\n\t\tgoto end_rmdir;\n\t} else if (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto end_rmdir;\n\t}\n\n\tinode = d_inode(dentry);\n\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(dir);\n\n\tif (de.de_objectid != inode->i_ino) {\n\t\t \n\t\tretval = -EIO;\n\t\tgoto end_rmdir;\n\t}\n\tif (!reiserfs_empty_dir(inode)) {\n\t\tretval = -ENOTEMPTY;\n\t\tgoto end_rmdir;\n\t}\n\n\t \n\tretval = reiserfs_cut_from_item(&th, &path, &de.de_entry_key,\n\t\t\t\t\tdir, NULL,\t \n\t\t\t\t\t0   );\n\tif (retval < 0)\n\t\tgoto end_rmdir;\n\n\tif (inode->i_nlink != 2 && inode->i_nlink != 1)\n\t\treiserfs_error(inode->i_sb, \"reiserfs-7040\",\n\t\t\t       \"empty directory has nlink != 2 (%d)\",\n\t\t\t       inode->i_nlink);\n\n\tclear_nlink(inode);\n\tdir->i_mtime = inode_set_ctime_to_ts(dir,\n\t\t\t\t\t     inode_set_ctime_current(inode));\n\treiserfs_update_sd(&th, inode);\n\n\tDEC_DIR_INODE_NLINK(dir)\n\tdir->i_size -= (DEH_SIZE + de.de_entrylen);\n\treiserfs_update_sd(&th, dir);\n\n\t \n\tadd_save_link(&th, inode, 0   );\n\n\tretval = journal_end(&th);\n\treiserfs_check_path(&path);\nout_rmdir:\n\treiserfs_write_unlock(dir->i_sb);\n\treturn retval;\n\nend_rmdir:\n\t \n\tpathrelse(&path);\n\terr = journal_end(&th);\n\treiserfs_write_unlock(dir->i_sb);\n\treturn err ? err : retval;\n}\n\nstatic int reiserfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint retval, err;\n\tstruct inode *inode;\n\tstruct reiserfs_dir_entry de;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_transaction_handle th;\n\tint jbegin_count;\n\tunsigned long savelink;\n\n\tretval = dquot_initialize(dir);\n\tif (retval)\n\t\treturn retval;\n\n\tinode = d_inode(dentry);\n\n\t \n\tjbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 2 + 2 +\n\t    4 * REISERFS_QUOTA_TRANS_BLOCKS(dir->i_sb);\n\n\treiserfs_write_lock(dir->i_sb);\n\tretval = journal_begin(&th, dir->i_sb, jbegin_count);\n\tif (retval)\n\t\tgoto out_unlink;\n\n\tde.de_gen_number_bit_string = NULL;\n\tif ((retval =\n\t     reiserfs_find_entry(dir, dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t &path, &de)) == NAME_NOT_FOUND) {\n\t\tretval = -ENOENT;\n\t\tgoto end_unlink;\n\t} else if (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto end_unlink;\n\t}\n\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(dir);\n\n\tif (de.de_objectid != inode->i_ino) {\n\t\t \n\t\tretval = -EIO;\n\t\tgoto end_unlink;\n\t}\n\n\tif (!inode->i_nlink) {\n\t\treiserfs_warning(inode->i_sb, \"reiserfs-7042\",\n\t\t\t\t \"deleting nonexistent file (%lu), %d\",\n\t\t\t\t inode->i_ino, inode->i_nlink);\n\t\tset_nlink(inode, 1);\n\t}\n\n\tdrop_nlink(inode);\n\n\t \n\tsavelink = inode->i_nlink;\n\n\tretval =\n\t    reiserfs_cut_from_item(&th, &path, &de.de_entry_key, dir, NULL,\n\t\t\t\t   0);\n\tif (retval < 0) {\n\t\tinc_nlink(inode);\n\t\tgoto end_unlink;\n\t}\n\tinode_set_ctime_current(inode);\n\treiserfs_update_sd(&th, inode);\n\n\tdir->i_size -= (de.de_entrylen + DEH_SIZE);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\treiserfs_update_sd(&th, dir);\n\n\tif (!savelink)\n\t\t \n\t\tadd_save_link(&th, inode, 0   );\n\n\tretval = journal_end(&th);\n\treiserfs_check_path(&path);\n\treiserfs_write_unlock(dir->i_sb);\n\treturn retval;\n\nend_unlink:\n\tpathrelse(&path);\n\terr = journal_end(&th);\n\treiserfs_check_path(&path);\n\tif (err)\n\t\tretval = err;\nout_unlink:\n\treiserfs_write_unlock(dir->i_sb);\n\treturn retval;\n}\n\nstatic int reiserfs_symlink(struct mnt_idmap *idmap,\n\t\t\t    struct inode *parent_dir, struct dentry *dentry,\n\t\t\t    const char *symname)\n{\n\tint retval;\n\tstruct inode *inode;\n\tchar *name;\n\tint item_len;\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_security_handle security;\n\tint mode = S_IFLNK | S_IRWXUGO;\n\t \n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 +\n\t    2 * (REISERFS_QUOTA_INIT_BLOCKS(parent_dir->i_sb) +\n\t\t REISERFS_QUOTA_TRANS_BLOCKS(parent_dir->i_sb));\n\n\tretval = dquot_initialize(parent_dir);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!(inode = new_inode(parent_dir->i_sb))) {\n\t\treturn -ENOMEM;\n\t}\n\tretval = new_inode_init(inode, parent_dir, mode);\n\tif (retval) {\n\t\tdrop_new_inode(inode);\n\t\treturn retval;\n\t}\n\n\tretval = reiserfs_security_init(parent_dir, inode, &dentry->d_name,\n\t\t\t\t\t&security);\n\tif (retval < 0) {\n\t\tdrop_new_inode(inode);\n\t\treturn retval;\n\t}\n\tjbegin_count += retval;\n\n\treiserfs_write_lock(parent_dir->i_sb);\n\titem_len = ROUND_UP(strlen(symname));\n\tif (item_len > MAX_DIRECT_ITEM_LEN(parent_dir->i_sb->s_blocksize)) {\n\t\tretval = -ENAMETOOLONG;\n\t\tdrop_new_inode(inode);\n\t\tgoto out_failed;\n\t}\n\n\tname = kmalloc(item_len, GFP_NOFS);\n\tif (!name) {\n\t\tdrop_new_inode(inode);\n\t\tretval = -ENOMEM;\n\t\tgoto out_failed;\n\t}\n\tmemcpy(name, symname, strlen(symname));\n\tpadd_item(name, item_len, strlen(symname));\n\n\tretval = journal_begin(&th, parent_dir->i_sb, jbegin_count);\n\tif (retval) {\n\t\tdrop_new_inode(inode);\n\t\tkfree(name);\n\t\tgoto out_failed;\n\t}\n\n\tretval =\n\t    reiserfs_new_inode(&th, parent_dir, mode, name, strlen(symname),\n\t\t\t       dentry, inode, &security);\n\tkfree(name);\n\tif (retval) {\t\t \n\t\tgoto out_failed;\n\t}\n\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(parent_dir);\n\n\tinode->i_op = &reiserfs_symlink_inode_operations;\n\tinode_nohighmem(inode);\n\tinode->i_mapping->a_ops = &reiserfs_address_space_operations;\n\n\tretval = reiserfs_add_entry(&th, parent_dir, dentry->d_name.name,\n\t\t\t\t    dentry->d_name.len, inode, 1   );\n\tif (retval) {\n\t\tint err;\n\t\tdrop_nlink(inode);\n\t\treiserfs_update_sd(&th, inode);\n\t\terr = journal_end(&th);\n\t\tif (err)\n\t\t\tretval = err;\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\tgoto out_failed;\n\t}\n\n\td_instantiate_new(dentry, inode);\n\tretval = journal_end(&th);\nout_failed:\n\treiserfs_write_unlock(parent_dir->i_sb);\n\treiserfs_security_free(&security);\n\treturn retval;\n}\n\nstatic int reiserfs_link(struct dentry *old_dentry, struct inode *dir,\n\t\t\t struct dentry *dentry)\n{\n\tint retval;\n\tstruct inode *inode = d_inode(old_dentry);\n\tstruct reiserfs_transaction_handle th;\n\t \n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 +\n\t    2 * REISERFS_QUOTA_TRANS_BLOCKS(dir->i_sb);\n\n\tretval = dquot_initialize(dir);\n\tif (retval)\n\t\treturn retval;\n\n\treiserfs_write_lock(dir->i_sb);\n\tif (inode->i_nlink >= REISERFS_LINK_MAX) {\n\t\t \n\t\treiserfs_write_unlock(dir->i_sb);\n\t\treturn -EMLINK;\n\t}\n\n\t \n\tinc_nlink(inode);\n\n\tretval = journal_begin(&th, dir->i_sb, jbegin_count);\n\tif (retval) {\n\t\tdrop_nlink(inode);\n\t\treiserfs_write_unlock(dir->i_sb);\n\t\treturn retval;\n\t}\n\n\t \n\tretval =\n\t    reiserfs_add_entry(&th, dir, dentry->d_name.name,\n\t\t\t       dentry->d_name.len, inode, 1   );\n\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(dir);\n\n\tif (retval) {\n\t\tint err;\n\t\tdrop_nlink(inode);\n\t\terr = journal_end(&th);\n\t\treiserfs_write_unlock(dir->i_sb);\n\t\treturn err ? err : retval;\n\t}\n\n\tinode_set_ctime_current(inode);\n\treiserfs_update_sd(&th, inode);\n\n\tihold(inode);\n\td_instantiate(dentry, inode);\n\tretval = journal_end(&th);\n\treiserfs_write_unlock(dir->i_sb);\n\treturn retval;\n}\n\n \nstatic int de_still_valid(const char *name, int len,\n\t\t\t  struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_dir_entry tmp = *de;\n\n\t \n\tset_de_name_and_namelen(&tmp);\n\t \n\tif (tmp.de_namelen != len || memcmp(name, de->de_name, len))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int entry_points_to_object(const char *name, int len,\n\t\t\t\t  struct reiserfs_dir_entry *de,\n\t\t\t\t  struct inode *inode)\n{\n\tif (!de_still_valid(name, len, de))\n\t\treturn 0;\n\n\tif (inode) {\n\t\tif (!de_visible(de->de_deh + de->de_entry_num))\n\t\t\treiserfs_panic(inode->i_sb, \"vs-7042\",\n\t\t\t\t       \"entry must be visible\");\n\t\treturn (de->de_objectid == inode->i_ino) ? 1 : 0;\n\t}\n\n\t \n\tif (de_visible(de->de_deh + de->de_entry_num))\n\t\treiserfs_panic(NULL, \"vs-7043\", \"entry must be visible\");\n\n\treturn 1;\n}\n\n \nstatic void set_ino_in_dir_entry(struct reiserfs_dir_entry *de,\n\t\t\t\t struct reiserfs_key *key)\n{\n\t \n\tde->de_deh[de->de_entry_num].deh_dir_id = key->k_dir_id;\n\tde->de_deh[de->de_entry_num].deh_objectid = key->k_objectid;\n}\n\n \nstatic int reiserfs_rename(struct mnt_idmap *idmap,\n\t\t\t   struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t   struct inode *new_dir, struct dentry *new_dentry,\n\t\t\t   unsigned int flags)\n{\n\tint retval;\n\tINITIALIZE_PATH(old_entry_path);\n\tINITIALIZE_PATH(new_entry_path);\n\tINITIALIZE_PATH(dot_dot_entry_path);\n\tstruct item_head new_entry_ih, old_entry_ih, dot_dot_ih;\n\tstruct reiserfs_dir_entry old_de, new_de, dot_dot_de;\n\tstruct inode *old_inode, *new_dentry_inode;\n\tstruct reiserfs_transaction_handle th;\n\tint jbegin_count;\n\tumode_t old_inode_mode;\n\tunsigned long savelink = 1;\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\t \n\tjbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 + 5 +\n\t    4 * REISERFS_QUOTA_TRANS_BLOCKS(old_dir->i_sb);\n\n\tretval = dquot_initialize(old_dir);\n\tif (retval)\n\t\treturn retval;\n\tretval = dquot_initialize(new_dir);\n\tif (retval)\n\t\treturn retval;\n\n\told_inode = d_inode(old_dentry);\n\tnew_dentry_inode = d_inode(new_dentry);\n\n\t \n\told_de.de_gen_number_bit_string = NULL;\n\treiserfs_write_lock(old_dir->i_sb);\n\tretval =\n\t    reiserfs_find_entry(old_dir, old_dentry->d_name.name,\n\t\t\t\told_dentry->d_name.len, &old_entry_path,\n\t\t\t\t&old_de);\n\tpathrelse(&old_entry_path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\treturn -EIO;\n\t}\n\n\tif (retval != NAME_FOUND || old_de.de_objectid != old_inode->i_ino) {\n\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\treturn -ENOENT;\n\t}\n\n\told_inode_mode = old_inode->i_mode;\n\tif (S_ISDIR(old_inode_mode)) {\n\t\t \n\t\tif (new_dentry_inode) {\n\t\t\tif (!reiserfs_empty_dir(new_dentry_inode)) {\n\t\t\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\t\t\treturn -ENOTEMPTY;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tdot_dot_de.de_gen_number_bit_string = NULL;\n\t\tretval =\n\t\t    reiserfs_find_entry(old_inode, \"..\", 2, &dot_dot_entry_path,\n\t\t\t\t\t&dot_dot_de);\n\t\tpathrelse(&dot_dot_entry_path);\n\t\tif (retval != NAME_FOUND) {\n\t\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tif (dot_dot_de.de_objectid != old_dir->i_ino) {\n\t\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tretval = journal_begin(&th, old_dir->i_sb, jbegin_count);\n\tif (retval) {\n\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\treturn retval;\n\t}\n\n\t \n\tretval =\n\t    reiserfs_add_entry(&th, new_dir, new_dentry->d_name.name,\n\t\t\t       new_dentry->d_name.len, old_inode, 0);\n\tif (retval == -EEXIST) {\n\t\tif (!new_dentry_inode) {\n\t\t\treiserfs_panic(old_dir->i_sb, \"vs-7050\",\n\t\t\t\t       \"new entry is found, new inode == 0\");\n\t\t}\n\t} else if (retval) {\n\t\tint err = journal_end(&th);\n\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\treturn err ? err : retval;\n\t}\n\n\treiserfs_update_inode_transaction(old_dir);\n\treiserfs_update_inode_transaction(new_dir);\n\n\t \n\treiserfs_update_inode_transaction(old_inode);\n\n\tif (new_dentry_inode)\n\t\treiserfs_update_inode_transaction(new_dentry_inode);\n\n\twhile (1) {\n\t\t \n\t\tif ((retval =\n\t\t     search_by_entry_key(new_dir->i_sb, &old_de.de_entry_key,\n\t\t\t\t\t &old_entry_path,\n\t\t\t\t\t &old_de)) != NAME_FOUND) {\n\t\t\tpathrelse(&old_entry_path);\n\t\t\tjournal_end(&th);\n\t\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tcopy_item_head(&old_entry_ih, tp_item_head(&old_entry_path));\n\n\t\treiserfs_prepare_for_journal(old_inode->i_sb, old_de.de_bh, 1);\n\n\t\t \n\t\tnew_de.de_gen_number_bit_string = NULL;\n\t\tretval =\n\t\t    reiserfs_find_entry(new_dir, new_dentry->d_name.name,\n\t\t\t\t\tnew_dentry->d_name.len, &new_entry_path,\n\t\t\t\t\t&new_de);\n\t\t \n\t\tif (retval != NAME_FOUND_INVISIBLE && retval != NAME_FOUND) {\n\t\t\tpathrelse(&new_entry_path);\n\t\t\tpathrelse(&old_entry_path);\n\t\t\tjournal_end(&th);\n\t\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tcopy_item_head(&new_entry_ih, tp_item_head(&new_entry_path));\n\n\t\treiserfs_prepare_for_journal(old_inode->i_sb, new_de.de_bh, 1);\n\n\t\tif (S_ISDIR(old_inode->i_mode)) {\n\t\t\tif ((retval =\n\t\t\t     search_by_entry_key(new_dir->i_sb,\n\t\t\t\t\t\t &dot_dot_de.de_entry_key,\n\t\t\t\t\t\t &dot_dot_entry_path,\n\t\t\t\t\t\t &dot_dot_de)) != NAME_FOUND) {\n\t\t\t\tpathrelse(&dot_dot_entry_path);\n\t\t\t\tpathrelse(&new_entry_path);\n\t\t\t\tpathrelse(&old_entry_path);\n\t\t\t\tjournal_end(&th);\n\t\t\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tcopy_item_head(&dot_dot_ih,\n\t\t\t\t       tp_item_head(&dot_dot_entry_path));\n\t\t\t \n\t\t\treiserfs_prepare_for_journal(old_inode->i_sb,\n\t\t\t\t\t\t     dot_dot_de.de_bh, 1);\n\t\t}\n\t\t \n\t\t \n\t\t \n\t\tif (item_moved(&new_entry_ih, &new_entry_path) ||\n\t\t    !entry_points_to_object(new_dentry->d_name.name,\n\t\t\t\t\t    new_dentry->d_name.len,\n\t\t\t\t\t    &new_de, new_dentry_inode) ||\n\t\t    item_moved(&old_entry_ih, &old_entry_path) ||\n\t\t    !entry_points_to_object(old_dentry->d_name.name,\n\t\t\t\t\t    old_dentry->d_name.len,\n\t\t\t\t\t    &old_de, old_inode)) {\n\t\t\treiserfs_restore_prepared_buffer(old_inode->i_sb,\n\t\t\t\t\t\t\t new_de.de_bh);\n\t\t\treiserfs_restore_prepared_buffer(old_inode->i_sb,\n\t\t\t\t\t\t\t old_de.de_bh);\n\t\t\tif (S_ISDIR(old_inode_mode))\n\t\t\t\treiserfs_restore_prepared_buffer(old_inode->\n\t\t\t\t\t\t\t\t i_sb,\n\t\t\t\t\t\t\t\t dot_dot_de.\n\t\t\t\t\t\t\t\t de_bh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(old_inode_mode)) {\n\t\t\tif (item_moved(&dot_dot_ih, &dot_dot_entry_path) ||\n\t\t\t    !entry_points_to_object(\"..\", 2, &dot_dot_de,\n\t\t\t\t\t\t    old_dir)) {\n\t\t\t\treiserfs_restore_prepared_buffer(old_inode->\n\t\t\t\t\t\t\t\t i_sb,\n\t\t\t\t\t\t\t\t old_de.de_bh);\n\t\t\t\treiserfs_restore_prepared_buffer(old_inode->\n\t\t\t\t\t\t\t\t i_sb,\n\t\t\t\t\t\t\t\t new_de.de_bh);\n\t\t\t\treiserfs_restore_prepared_buffer(old_inode->\n\t\t\t\t\t\t\t\t i_sb,\n\t\t\t\t\t\t\t\t dot_dot_de.\n\t\t\t\t\t\t\t\t de_bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tRFALSE(S_ISDIR(old_inode_mode) &&\n\t\t       !buffer_journal_prepared(dot_dot_de.de_bh), \"\");\n\n\t\tbreak;\n\t}\n\n\t \n\n\tmark_de_visible(new_de.de_deh + new_de.de_entry_num);\n\tset_ino_in_dir_entry(&new_de, INODE_PKEY(old_inode));\n\tjournal_mark_dirty(&th, new_de.de_bh);\n\n\tmark_de_hidden(old_de.de_deh + old_de.de_entry_num);\n\tjournal_mark_dirty(&th, old_de.de_bh);\n\t \n\tsimple_rename_timestamp(old_dir, old_dentry, new_dir, new_dentry);\n\n\tif (new_dentry_inode) {\n\t\t \n\t\tif (S_ISDIR(new_dentry_inode->i_mode)) {\n\t\t\tclear_nlink(new_dentry_inode);\n\t\t} else {\n\t\t\tdrop_nlink(new_dentry_inode);\n\t\t}\n\t\tsavelink = new_dentry_inode->i_nlink;\n\t}\n\n\tif (S_ISDIR(old_inode_mode)) {\n\t\t \n\t\tset_ino_in_dir_entry(&dot_dot_de, INODE_PKEY(new_dir));\n\t\tjournal_mark_dirty(&th, dot_dot_de.de_bh);\n\n\t\t \n\t\tif (!new_dentry_inode)\n\t\t\tINC_DIR_INODE_NLINK(new_dir);\n\n\t\t \n\t\tDEC_DIR_INODE_NLINK(old_dir);\n\t}\n\t \n\tpathrelse(&new_entry_path);\n\tpathrelse(&dot_dot_entry_path);\n\n\t \n\tif (reiserfs_cut_from_item\n\t    (&th, &old_entry_path, &old_de.de_entry_key, old_dir, NULL,\n\t     0) < 0)\n\t\treiserfs_error(old_dir->i_sb, \"vs-7060\",\n\t\t\t       \"couldn't not cut old name. Fsck later?\");\n\n\told_dir->i_size -= DEH_SIZE + old_de.de_entrylen;\n\n\treiserfs_update_sd(&th, old_dir);\n\treiserfs_update_sd(&th, new_dir);\n\treiserfs_update_sd(&th, old_inode);\n\n\tif (new_dentry_inode) {\n\t\tif (savelink == 0)\n\t\t\tadd_save_link(&th, new_dentry_inode,\n\t\t\t\t      0   );\n\t\treiserfs_update_sd(&th, new_dentry_inode);\n\t}\n\n\tretval = journal_end(&th);\n\treiserfs_write_unlock(old_dir->i_sb);\n\treturn retval;\n}\n\nstatic const struct inode_operations reiserfs_priv_dir_inode_operations = {\n\t.create = reiserfs_create,\n\t.lookup = reiserfs_lookup,\n\t.link = reiserfs_link,\n\t.unlink = reiserfs_unlink,\n\t.symlink = reiserfs_symlink,\n\t.mkdir = reiserfs_mkdir,\n\t.rmdir = reiserfs_rmdir,\n\t.mknod = reiserfs_mknod,\n\t.rename = reiserfs_rename,\n\t.setattr = reiserfs_setattr,\n\t.permission = reiserfs_permission,\n\t.fileattr_get = reiserfs_fileattr_get,\n\t.fileattr_set = reiserfs_fileattr_set,\n};\n\nstatic const struct inode_operations reiserfs_priv_symlink_inode_operations = {\n\t.get_link\t= page_get_link,\n\t.setattr = reiserfs_setattr,\n\t.permission = reiserfs_permission,\n};\n\nstatic const struct inode_operations reiserfs_priv_special_inode_operations = {\n\t.setattr = reiserfs_setattr,\n\t.permission = reiserfs_permission,\n};\n\nvoid reiserfs_init_priv_inode(struct inode *inode)\n{\n\tinode->i_flags |= S_PRIVATE;\n\tinode->i_opflags &= ~IOP_XATTR;\n\n\tif (S_ISREG(inode->i_mode))\n\t\tinode->i_op = &reiserfs_priv_file_inode_operations;\n\telse if (S_ISDIR(inode->i_mode))\n\t\tinode->i_op = &reiserfs_priv_dir_inode_operations;\n\telse if (S_ISLNK(inode->i_mode))\n\t\tinode->i_op = &reiserfs_priv_symlink_inode_operations;\n\telse\n\t\tinode->i_op = &reiserfs_priv_special_inode_operations;\n}\n\n \nconst struct inode_operations reiserfs_dir_inode_operations = {\n\t.create = reiserfs_create,\n\t.lookup = reiserfs_lookup,\n\t.link = reiserfs_link,\n\t.unlink = reiserfs_unlink,\n\t.symlink = reiserfs_symlink,\n\t.mkdir = reiserfs_mkdir,\n\t.rmdir = reiserfs_rmdir,\n\t.mknod = reiserfs_mknod,\n\t.rename = reiserfs_rename,\n\t.setattr = reiserfs_setattr,\n\t.listxattr = reiserfs_listxattr,\n\t.permission = reiserfs_permission,\n\t.get_inode_acl = reiserfs_get_acl,\n\t.set_acl = reiserfs_set_acl,\n\t.fileattr_get = reiserfs_fileattr_get,\n\t.fileattr_set = reiserfs_fileattr_set,\n};\n\n \nconst struct inode_operations reiserfs_symlink_inode_operations = {\n\t.get_link\t= page_get_link,\n\t.setattr = reiserfs_setattr,\n\t.listxattr = reiserfs_listxattr,\n\t.permission = reiserfs_permission,\n};\n\n \nconst struct inode_operations reiserfs_special_inode_operations = {\n\t.setattr = reiserfs_setattr,\n\t.listxattr = reiserfs_listxattr,\n\t.permission = reiserfs_permission,\n\t.get_inode_acl = reiserfs_get_acl,\n\t.set_acl = reiserfs_set_acl,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}