{
  "module_name": "fix_node.c",
  "hash_id": "2f913c606b97637d570df2a13bc2389e3d0d2479cd53e58211b7fd958866d911",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/fix_node.c",
  "human_readable_source": " \n\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/buffer_head.h>\n\n \n\n \nstatic inline int old_item_num(int new_num, int affected_item_num, int mode)\n{\n\tif (mode == M_PASTE || mode == M_CUT || new_num < affected_item_num)\n\t\treturn new_num;\n\n\tif (mode == M_INSERT) {\n\n\t\tRFALSE(new_num == 0,\n\t\t       \"vs-8005: for INSERT mode and item number of inserted item\");\n\n\t\treturn new_num - 1;\n\t}\n\n\tRFALSE(mode != M_DELETE,\n\t       \"vs-8010: old_item_num: mode must be M_DELETE (mode = \\'%c\\'\",\n\t       mode);\n\t \n\treturn new_num + 1;\n}\n\nstatic void create_virtual_node(struct tree_balance *tb, int h)\n{\n\tstruct item_head *ih;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint new_num;\n\tstruct buffer_head *Sh;\t \n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\n\t \n\tvn->vn_size =\n\t    MAX_CHILD_SIZE(Sh) - B_FREE_SPACE(Sh) + tb->insert_size[h];\n\n\t \n\tif (h) {\n\t\tvn->vn_nr_item = (vn->vn_size - DC_SIZE) / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t \n\tvn->vn_nr_item =\n\t    B_NR_ITEMS(Sh) + ((vn->vn_mode == M_INSERT) ? 1 : 0) -\n\t    ((vn->vn_mode == M_DELETE) ? 1 : 0);\n\n\t \n\tvn->vn_vi = (struct virtual_item *)(tb->tb_vn + 1);\n\tmemset(vn->vn_vi, 0, vn->vn_nr_item * sizeof(struct virtual_item));\n\tvn->vn_free_ptr += vn->vn_nr_item * sizeof(struct virtual_item);\n\n\t \n\tih = item_head(Sh, 0);\n\n\t \n\tif (op_is_left_mergeable(&ih->ih_key, Sh->b_size)\n\t    && (vn->vn_mode != M_DELETE || vn->vn_affected_item_num))\n\t\tvn->vn_vi[0].vi_type |= VI_TYPE_LEFT_MERGEABLE;\n\n\t \n\tfor (new_num = 0; new_num < vn->vn_nr_item; new_num++) {\n\t\tint j;\n\t\tstruct virtual_item *vi = vn->vn_vi + new_num;\n\t\tint is_affected =\n\t\t    ((new_num != vn->vn_affected_item_num) ? 0 : 1);\n\n\t\tif (is_affected && vn->vn_mode == M_INSERT)\n\t\t\tcontinue;\n\n\t\t \n\t\tj = old_item_num(new_num, vn->vn_affected_item_num,\n\t\t\t\t vn->vn_mode);\n\n\t\tvi->vi_item_len += ih_item_len(ih + j) + IH_SIZE;\n\t\tvi->vi_ih = ih + j;\n\t\tvi->vi_item = ih_item_body(Sh, ih + j);\n\t\tvi->vi_uarea = vn->vn_free_ptr;\n\n\t\t \n\t\tvn->vn_free_ptr +=\n\t\t    op_create_vi(vn, vi, is_affected, tb->insert_size[0]);\n\t\tif (tb->vn_buf + tb->vn_buf_size < vn->vn_free_ptr)\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8030\",\n\t\t\t\t       \"virtual node space consumed\");\n\n\t\tif (!is_affected)\n\t\t\t \n\t\t\tcontinue;\n\n\t\tif (vn->vn_mode == M_PASTE || vn->vn_mode == M_CUT) {\n\t\t\tvn->vn_vi[new_num].vi_item_len += tb->insert_size[0];\n\t\t\t \n\t\t\tvi->vi_new_data = vn->vn_data;\n\t\t}\n\t}\n\n\t \n\tif (vn->vn_mode == M_INSERT) {\n\t\tstruct virtual_item *vi = vn->vn_vi + vn->vn_affected_item_num;\n\n\t\tRFALSE(vn->vn_ins_ih == NULL,\n\t\t       \"vs-8040: item header of inserted item is not specified\");\n\t\tvi->vi_item_len = tb->insert_size[0];\n\t\tvi->vi_ih = vn->vn_ins_ih;\n\t\tvi->vi_item = vn->vn_data;\n\t\tvi->vi_uarea = vn->vn_free_ptr;\n\n\t\top_create_vi(vn, vi, 0   ,\n\t\t\t     tb->insert_size[0]);\n\t}\n\n\t \n\tif (tb->CFR[0]) {\n\t\tstruct reiserfs_key *key;\n\n\t\tkey = internal_key(tb->CFR[0], tb->rkey[0]);\n\t\tif (op_is_left_mergeable(key, Sh->b_size)\n\t\t    && (vn->vn_mode != M_DELETE\n\t\t\t|| vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1))\n\t\t\tvn->vn_vi[vn->vn_nr_item - 1].vi_type |=\n\t\t\t    VI_TYPE_RIGHT_MERGEABLE;\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (op_is_left_mergeable(key, Sh->b_size) &&\n\t\t    !(vn->vn_mode != M_DELETE\n\t\t      || vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1)) {\n\t\t\t \n\t\t\tif (!\n\t\t\t    (B_NR_ITEMS(Sh) == 1\n\t\t\t     && is_direntry_le_ih(item_head(Sh, 0))\n\t\t\t     && ih_entry_count(item_head(Sh, 0)) == 1)) {\n\t\t\t\t \n\t\t\t\tprint_block(Sh, 0, -1, -1);\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-8045\",\n\t\t\t\t\t       \"rdkey %k, affected item==%d \"\n\t\t\t\t\t       \"(mode==%c) Must be %c\",\n\t\t\t\t\t       key, vn->vn_affected_item_num,\n\t\t\t\t\t       vn->vn_mode, M_DELETE);\n\t\t\t}\n\t\t}\n#endif\n\n\t}\n}\n\n \nstatic void check_left(struct tree_balance *tb, int h, int cur_free)\n{\n\tint i;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tstruct virtual_item *vi;\n\tint d_size, ih_size;\n\n\tRFALSE(cur_free < 0, \"vs-8050: cur_free (%d) < 0\", cur_free);\n\n\t \n\tif (h > 0) {\n\t\ttb->lnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t \n\n\tif (!cur_free || !vn->vn_nr_item) {\n\t\t \n\t\ttb->lnum[h] = 0;\n\t\ttb->lbytes = -1;\n\t\treturn;\n\t}\n\n\tRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"vs-8055: parent does not exist or invalid\");\n\n\tvi = vn->vn_vi;\n\tif ((unsigned int)cur_free >=\n\t    (vn->vn_size -\n\t     ((vi->vi_type & VI_TYPE_LEFT_MERGEABLE) ? IH_SIZE : 0))) {\n\t\t \n\n\t\tRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\n\t\t       \"vs-8055: invalid mode or balance condition failed\");\n\n\t\ttb->lnum[0] = vn->vn_nr_item;\n\t\ttb->lbytes = -1;\n\t\treturn;\n\t}\n\n\td_size = 0, ih_size = IH_SIZE;\n\n\t \n\tif (vi->vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\td_size = -((int)IH_SIZE), ih_size = 0;\n\n\ttb->lnum[0] = 0;\n\tfor (i = 0; i < vn->vn_nr_item;\n\t     i++, ih_size = IH_SIZE, d_size = 0, vi++) {\n\t\td_size += vi->vi_item_len;\n\t\tif (cur_free >= d_size) {\n\t\t\t \n\t\t\tcur_free -= d_size;\n\t\t\ttb->lnum[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\t \n\n\t\t \n\t\tif (cur_free <= ih_size) {\n\t\t\ttb->lbytes = -1;\n\t\t\treturn;\n\t\t}\n\t\tcur_free -= ih_size;\n\n\t\ttb->lbytes = op_check_left(vi, cur_free, 0, 0);\n\t\tif (tb->lbytes != -1)\n\t\t\t \n\t\t\ttb->lnum[0]++;\n\n\t\tbreak;\n\t}\n\n\treturn;\n}\n\n \nstatic void check_right(struct tree_balance *tb, int h, int cur_free)\n{\n\tint i;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tstruct virtual_item *vi;\n\tint d_size, ih_size;\n\n\tRFALSE(cur_free < 0, \"vs-8070: cur_free < 0\");\n\n\t \n\tif (h > 0) {\n\t\ttb->rnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t \n\n\tif (!cur_free || !vn->vn_nr_item) {\n\t\t \n\t\ttb->rnum[h] = 0;\n\t\ttb->rbytes = -1;\n\t\treturn;\n\t}\n\n\tRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"vs-8075: parent does not exist or invalid\");\n\n\tvi = vn->vn_vi + vn->vn_nr_item - 1;\n\tif ((unsigned int)cur_free >=\n\t    (vn->vn_size -\n\t     ((vi->vi_type & VI_TYPE_RIGHT_MERGEABLE) ? IH_SIZE : 0))) {\n\t\t \n\n\t\tRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\n\t\t       \"vs-8080: invalid mode or balance condition failed\");\n\n\t\ttb->rnum[h] = vn->vn_nr_item;\n\t\ttb->rbytes = -1;\n\t\treturn;\n\t}\n\n\td_size = 0, ih_size = IH_SIZE;\n\n\t \n\tif (vi->vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\td_size = -(int)IH_SIZE, ih_size = 0;\n\n\ttb->rnum[0] = 0;\n\tfor (i = vn->vn_nr_item - 1; i >= 0;\n\t     i--, d_size = 0, ih_size = IH_SIZE, vi--) {\n\t\td_size += vi->vi_item_len;\n\t\tif (cur_free >= d_size) {\n\t\t\t \n\t\t\tcur_free -= d_size;\n\t\t\ttb->rnum[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif (cur_free <= ih_size) {\n\t\t\ttb->rbytes = -1;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tcur_free -= ih_size;\t \n\n\t\ttb->rbytes = op_check_right(vi, cur_free);\n\t\tif (tb->rbytes != -1)\n\t\t\t \n\t\t\ttb->rnum[0]++;\n\n\t\tbreak;\n\t}\n\n\treturn;\n}\n\n \nstatic int get_num_ver(int mode, struct tree_balance *tb, int h,\n\t\t       int from, int from_bytes,\n\t\t       int to, int to_bytes, short *snum012, int flow)\n{\n\tint i;\n\tint units;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint total_node_size, max_node_size, current_item_size;\n\tint needed_nodes;\n\n\t \n\tint start_item;\n\n\t \n\tint end_item;\n\n\t \n\tint start_bytes;\n\n\t \n\tint end_bytes;\n\n\t \n\tint split_item_positions[2];\n\n\tsplit_item_positions[0] = -1;\n\tsplit_item_positions[1] = -1;\n\n\t \n\tRFALSE(tb->insert_size[h] < 0 || (mode != M_INSERT && mode != M_PASTE),\n\t       \"vs-8100: insert_size < 0 in overflow\");\n\n\tmax_node_size = MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, h));\n\n\t \n\tsnum012[3] = -1;\t \n\tsnum012[4] = -1;\t \n\n\t \n\tif (h > 0) {\n\t\ti = ((to - from) * (KEY_SIZE + DC_SIZE) + DC_SIZE);\n\t\tif (i == max_node_size)\n\t\t\treturn 1;\n\t\treturn (i / max_node_size + 1);\n\t}\n\n\t \n\tneeded_nodes = 1;\n\ttotal_node_size = 0;\n\n\t \n\tstart_item = from;\n\t \n\tstart_bytes = ((from_bytes != -1) ? from_bytes : 0);\n\n\t \n\tend_item = vn->vn_nr_item - to - 1;\n\t \n\tend_bytes = (to_bytes != -1) ? to_bytes : 0;\n\n\t \n\tfor (i = start_item; i <= end_item; i++) {\n\t\tstruct virtual_item *vi = vn->vn_vi + i;\n\t\tint skip_from_end = ((i == end_item) ? end_bytes : 0);\n\n\t\tRFALSE(needed_nodes > 3, \"vs-8105: too many nodes are needed\");\n\n\t\t \n\t\tcurrent_item_size = vi->vi_item_len;\n\n\t\t \n\t\tcurrent_item_size -=\n\t\t    op_part_size(vi, 0   , start_bytes);\n\n\t\t \n\t\tcurrent_item_size -=\n\t\t    op_part_size(vi, 1   , skip_from_end);\n\n\t\t \n\t\tif (total_node_size + current_item_size <= max_node_size) {\n\t\t\tsnum012[needed_nodes - 1]++;\n\t\t\ttotal_node_size += current_item_size;\n\t\t\tstart_bytes = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (current_item_size > max_node_size) {\n\t\t\tRFALSE(is_direct_le_ih(vi->vi_ih),\n\t\t\t       \"vs-8110: \"\n\t\t\t       \"direct item length is %d. It can not be longer than %d\",\n\t\t\t       current_item_size, max_node_size);\n\t\t\t \n\t\t\tflow = 1;\n\t\t}\n\n\t\t \n\t\tif (!flow) {\n\t\t\tneeded_nodes++;\n\t\t\ti--;\n\t\t\ttotal_node_size = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\t{\n\t\t\tint free_space;\n\n\t\t\tfree_space = max_node_size - total_node_size - IH_SIZE;\n\t\t\tunits =\n\t\t\t    op_check_left(vi, free_space, start_bytes,\n\t\t\t\t\t  skip_from_end);\n\t\t\t \n\t\t\tif (units == -1) {\n\t\t\t\tneeded_nodes++, i--, total_node_size = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tstart_bytes += units;\n\t\tsnum012[needed_nodes - 1 + 3] = units;\n\n\t\tif (needed_nodes > 2)\n\t\t\treiserfs_warning(tb->tb_sb, \"vs-8111\",\n\t\t\t\t\t \"split_item_position is out of range\");\n\t\tsnum012[needed_nodes - 1]++;\n\t\tsplit_item_positions[needed_nodes - 1] = i;\n\t\tneeded_nodes++;\n\t\t \n\t\tstart_item = i;\n\t\ti--;\n\t\ttotal_node_size = 0;\n\t}\n\n\t \n\tif (snum012[4] > 0) {\n\t\tint split_item_num;\n\t\tint bytes_to_r, bytes_to_l;\n\t\tint bytes_to_S1new;\n\n\t\tsplit_item_num = split_item_positions[1];\n\t\tbytes_to_l =\n\t\t    ((from == split_item_num\n\t\t      && from_bytes != -1) ? from_bytes : 0);\n\t\tbytes_to_r =\n\t\t    ((end_item == split_item_num\n\t\t      && end_bytes != -1) ? end_bytes : 0);\n\t\tbytes_to_S1new =\n\t\t    ((split_item_positions[0] ==\n\t\t      split_item_positions[1]) ? snum012[3] : 0);\n\n\t\t \n\t\tsnum012[4] =\n\t\t    op_unit_num(&vn->vn_vi[split_item_num]) - snum012[4] -\n\t\t    bytes_to_r - bytes_to_l - bytes_to_S1new;\n\n\t\tif (vn->vn_vi[split_item_num].vi_index != TYPE_DIRENTRY &&\n\t\t    vn->vn_vi[split_item_num].vi_index != TYPE_INDIRECT)\n\t\t\treiserfs_warning(tb->tb_sb, \"vs-8115\",\n\t\t\t\t\t \"not directory or indirect item\");\n\t}\n\n\t \n\tif (snum012[3] > 0) {\n\t\tint split_item_num;\n\t\tint bytes_to_r, bytes_to_l;\n\t\tint bytes_to_S2new;\n\n\t\tsplit_item_num = split_item_positions[0];\n\t\tbytes_to_l =\n\t\t    ((from == split_item_num\n\t\t      && from_bytes != -1) ? from_bytes : 0);\n\t\tbytes_to_r =\n\t\t    ((end_item == split_item_num\n\t\t      && end_bytes != -1) ? end_bytes : 0);\n\t\tbytes_to_S2new =\n\t\t    ((split_item_positions[0] == split_item_positions[1]\n\t\t      && snum012[4] != -1) ? snum012[4] : 0);\n\n\t\t \n\t\tsnum012[3] =\n\t\t    op_unit_num(&vn->vn_vi[split_item_num]) - snum012[3] -\n\t\t    bytes_to_r - bytes_to_l - bytes_to_S2new;\n\t}\n\n\treturn needed_nodes;\n}\n\n\n \n\nstatic void set_parameters(struct tree_balance *tb, int h, int lnum,\n\t\t\t   int rnum, int blk_num, short *s012, int lb, int rb)\n{\n\n\ttb->lnum[h] = lnum;\n\ttb->rnum[h] = rnum;\n\ttb->blknum[h] = blk_num;\n\n\t \n\tif (h == 0) {\n\t\tif (s012 != NULL) {\n\t\t\ttb->s0num = *s012++;\n\t\t\ttb->snum[0] = *s012++;\n\t\t\ttb->snum[1] = *s012++;\n\t\t\ttb->sbytes[0] = *s012++;\n\t\t\ttb->sbytes[1] = *s012;\n\t\t}\n\t\ttb->lbytes = lb;\n\t\ttb->rbytes = rb;\n\t}\n\tPROC_INFO_ADD(tb->tb_sb, lnum[h], lnum);\n\tPROC_INFO_ADD(tb->tb_sb, rnum[h], rnum);\n\n\tPROC_INFO_ADD(tb->tb_sb, lbytes[h], lb);\n\tPROC_INFO_ADD(tb->tb_sb, rbytes[h], rb);\n}\n\n \nstatic int is_leaf_removable(struct tree_balance *tb)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint to_left, to_right;\n\tint size;\n\tint remain_items;\n\n\t \n\tto_left = tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0);\n\tto_right = tb->rnum[0] - ((tb->rbytes != -1) ? 1 : 0);\n\tremain_items = vn->vn_nr_item;\n\n\t \n\tremain_items -= (to_left + to_right);\n\n\t \n\tif (remain_items < 1) {\n\t\tset_parameters(tb, 0, to_left, vn->vn_nr_item - to_left, 0,\n\t\t\t       NULL, -1, -1);\n\t\treturn 1;\n\t}\n\n\t \n\tif (remain_items > 1 || tb->lbytes == -1 || tb->rbytes == -1)\n\t\treturn 0;\n\n\t \n\n\t \n\tsize = op_unit_num(&vn->vn_vi[to_left]);\n\n\tif (tb->lbytes + tb->rbytes >= size) {\n\t\tset_parameters(tb, 0, to_left + 1, to_right + 1, 0, NULL,\n\t\t\t       tb->lbytes, -1);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t \n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t \n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t \n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}\n\n \n#define SET_PAR_SHIFT_LEFT \\\nif (h)\\\n{\\\n   int to_l;\\\n   \\\n   to_l = (MAX_NR_KEY(Sh)+1 - lpar + vn->vn_nr_item + 1) / 2 -\\\n\t      (MAX_NR_KEY(Sh) + 1 - lpar);\\\n\t      \\\n\t      set_parameters (tb, h, to_l, 0, lnver, NULL, -1, -1);\\\n}\\\nelse \\\n{\\\n   if (lset==LEFT_SHIFT_FLOW)\\\n     set_parameters (tb, h, lpar, 0, lnver, snum012+lset,\\\n\t\t     tb->lbytes, -1);\\\n   else\\\n     set_parameters (tb, h, lpar - (tb->lbytes!=-1), 0, lnver, snum012+lset,\\\n\t\t     -1, -1);\\\n}\n\n#define SET_PAR_SHIFT_RIGHT \\\nif (h)\\\n{\\\n   int to_r;\\\n   \\\n   to_r = (MAX_NR_KEY(Sh)+1 - rpar + vn->vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 - rpar);\\\n   \\\n   set_parameters (tb, h, 0, to_r, rnver, NULL, -1, -1);\\\n}\\\nelse \\\n{\\\n   if (rset==RIGHT_SHIFT_FLOW)\\\n     set_parameters (tb, h, 0, rpar, rnver, snum012+rset,\\\n\t\t  -1, tb->rbytes);\\\n   else\\\n     set_parameters (tb, h, 0, rpar - (tb->rbytes!=-1), rnver, snum012+rset,\\\n\t\t  -1, -1);\\\n}\n\nstatic void free_buffers_in_tb(struct tree_balance *tb)\n{\n\tint i;\n\n\tpathrelse(tb->tb_path);\n\n\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\tbrelse(tb->L[i]);\n\t\tbrelse(tb->R[i]);\n\t\tbrelse(tb->FL[i]);\n\t\tbrelse(tb->FR[i]);\n\t\tbrelse(tb->CFL[i]);\n\t\tbrelse(tb->CFR[i]);\n\n\t\ttb->L[i] = NULL;\n\t\ttb->R[i] = NULL;\n\t\ttb->FL[i] = NULL;\n\t\ttb->FR[i] = NULL;\n\t\ttb->CFL[i] = NULL;\n\t\ttb->CFR[i] = NULL;\n\t}\n}\n\n \n \nstatic int get_empty_nodes(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *new_bh, *Sh = PATH_H_PBUFFER(tb->tb_path, h);\n\tb_blocknr_t *blocknr, blocknrs[MAX_AMOUNT_NEEDED] = { 0, };\n\tint counter, number_of_freeblk;\n\tint  amount_needed;\t \n\tint  retval = CARRY_ON;\n\tstruct super_block *sb = tb->tb_sb;\n\n\t \n\n\t \n\t \n\tfor (counter = 0, number_of_freeblk = tb->cur_blknum;\n\t     counter < h; counter++)\n\t\tnumber_of_freeblk -=\n\t\t    (tb->blknum[counter]) ? (tb->blknum[counter] -\n\t\t\t\t\t\t   1) : 0;\n\n\t \n\t \n\tamount_needed = (Sh) ? (tb->blknum[h] - 1) : 1;\n\t \n\tif (amount_needed > number_of_freeblk)\n\t\tamount_needed -= number_of_freeblk;\n\telse\t \n\t\treturn CARRY_ON;\n\n\t \n\tif (reiserfs_new_form_blocknrs(tb, blocknrs,\n\t\t\t\t       amount_needed) == NO_DISK_SPACE)\n\t\treturn NO_DISK_SPACE;\n\n\t \n\tfor (blocknr = blocknrs, counter = 0;\n\t     counter < amount_needed; blocknr++, counter++) {\n\n\t\tRFALSE(!*blocknr,\n\t\t       \"PAP-8135: reiserfs_new_blocknrs failed when got new blocks\");\n\n\t\tnew_bh = sb_getblk(sb, *blocknr);\n\t\tRFALSE(buffer_dirty(new_bh) ||\n\t\t       buffer_journaled(new_bh) ||\n\t\t       buffer_journal_dirty(new_bh),\n\t\t       \"PAP-8140: journaled or dirty buffer %b for the new block\",\n\t\t       new_bh);\n\n\t\t \n\t\tRFALSE(tb->FEB[tb->cur_blknum],\n\t\t       \"PAP-8141: busy slot for new buffer\");\n\n\t\tset_buffer_journal_new(new_bh);\n\t\ttb->FEB[tb->cur_blknum++] = new_bh;\n\t}\n\n\tif (retval == CARRY_ON && FILESYSTEM_CHANGED_TB(tb))\n\t\tretval = REPEAT_SEARCH;\n\n\treturn retval;\n}\n\n \nstatic int get_lfree(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *l, *f;\n\tint order;\n\n\tif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\n\t    (l = tb->FL[h]) == NULL)\n\t\treturn 0;\n\n\tif (f == l)\n\t\torder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) - 1;\n\telse {\n\t\torder = B_NR_ITEMS(l);\n\t\tf = l;\n\t}\n\n\treturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\n}\n\n \nstatic int get_rfree(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *r, *f;\n\tint order;\n\n\tif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\n\t    (r = tb->FR[h]) == NULL)\n\t\treturn 0;\n\n\tif (f == r)\n\t\torder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) + 1;\n\telse {\n\t\torder = 0;\n\t\tf = r;\n\t}\n\n\treturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\n\n}\n\n \nstatic int is_left_neighbor_in_cache(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *father, *left;\n\tstruct super_block *sb = tb->tb_sb;\n\tb_blocknr_t left_neighbor_blocknr;\n\tint left_neighbor_position;\n\n\t \n\tif (!tb->FL[h])\n\t\treturn 0;\n\n\t \n\tfather = PATH_H_PBUFFER(tb->tb_path, h + 1);\n\n\tRFALSE(!father ||\n\t       !B_IS_IN_TREE(father) ||\n\t       !B_IS_IN_TREE(tb->FL[h]) ||\n\t       !buffer_uptodate(father) ||\n\t       !buffer_uptodate(tb->FL[h]),\n\t       \"vs-8165: F[h] (%b) or FL[h] (%b) is invalid\",\n\t       father, tb->FL[h]);\n\n\t \n\tleft_neighbor_position = (father == tb->FL[h]) ?\n\t    tb->lkey[h] : B_NR_ITEMS(tb->FL[h]);\n\t \n\tleft_neighbor_blocknr =\n\t    B_N_CHILD_NUM(tb->FL[h], left_neighbor_position);\n\t \n\tif ((left = sb_find_get_block(sb, left_neighbor_blocknr))) {\n\n\t\tRFALSE(buffer_uptodate(left) && !B_IS_IN_TREE(left),\n\t\t       \"vs-8170: left neighbor (%b %z) is not in the tree\",\n\t\t       left, left);\n\t\tput_bh(left);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n#define LEFT_PARENTS  'l'\n#define RIGHT_PARENTS 'r'\n\nstatic void decrement_key(struct cpu_key *key)\n{\n\t \n\titem_ops[cpu_key_k_type(key)]->decrement_key(key);\n}\n\n \nstatic int get_far_parent(struct tree_balance *tb,\n\t\t\t  int h,\n\t\t\t  struct buffer_head **pfather,\n\t\t\t  struct buffer_head **pcom_father, char c_lr_par)\n{\n\tstruct buffer_head *parent;\n\tINITIALIZE_PATH(s_path_to_neighbor_father);\n\tstruct treepath *path = tb->tb_path;\n\tstruct cpu_key s_lr_father_key;\n\tint counter,\n\t    position = INT_MAX,\n\t    first_last_position = 0,\n\t    path_offset = PATH_H_PATH_OFFSET(path, h);\n\n\t \n\n\tcounter = path_offset;\n\n\tRFALSE(counter < FIRST_PATH_ELEMENT_OFFSET,\n\t       \"PAP-8180: invalid path length\");\n\n\tfor (; counter > FIRST_PATH_ELEMENT_OFFSET; counter--) {\n\t\t \n\t\tif (!B_IS_IN_TREE\n\t\t    (parent = PATH_OFFSET_PBUFFER(path, counter - 1)))\n\t\t\treturn REPEAT_SEARCH;\n\n\t\t \n\t\tif ((position =\n\t\t     PATH_OFFSET_POSITION(path,\n\t\t\t\t\t  counter - 1)) >\n\t\t    B_NR_ITEMS(parent))\n\t\t\treturn REPEAT_SEARCH;\n\n\t\t \n\t\tif (B_N_CHILD_NUM(parent, position) !=\n\t\t    PATH_OFFSET_PBUFFER(path, counter)->b_blocknr)\n\t\t\treturn REPEAT_SEARCH;\n\n\t\t \n\t\tif (c_lr_par == RIGHT_PARENTS)\n\t\t\tfirst_last_position = B_NR_ITEMS(parent);\n\t\tif (position != first_last_position) {\n\t\t\t*pcom_father = parent;\n\t\t\tget_bh(*pcom_father);\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (counter == FIRST_PATH_ELEMENT_OFFSET) {\n\t\t \n\t\tif (PATH_OFFSET_PBUFFER\n\t\t    (tb->tb_path,\n\t\t     FIRST_PATH_ELEMENT_OFFSET)->b_blocknr ==\n\t\t    SB_ROOT_BLOCK(tb->tb_sb)) {\n\t\t\t*pfather = *pcom_father = NULL;\n\t\t\treturn CARRY_ON;\n\t\t}\n\t\treturn REPEAT_SEARCH;\n\t}\n\n\tRFALSE(B_LEVEL(*pcom_father) <= DISK_LEAF_NODE_LEVEL,\n\t       \"PAP-8185: (%b %z) level too small\",\n\t       *pcom_father, *pcom_father);\n\n\t \n\n\tif (buffer_locked(*pcom_father)) {\n\n\t\t \n\t\tint depth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t__wait_on_buffer(*pcom_father);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\tbrelse(*pcom_father);\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\t}\n\n\t \n\n\t \n\tle_key2cpu_key(&s_lr_father_key,\n\t\t       internal_key(*pcom_father,\n\t\t\t\t      (c_lr_par ==\n\t\t\t\t       LEFT_PARENTS) ? (tb->lkey[h - 1] =\n\t\t\t\t\t\t\tposition -\n\t\t\t\t\t\t\t1) : (tb->rkey[h -\n\t\t\t\t\t\t\t\t\t   1] =\n\t\t\t\t\t\t\t      position)));\n\n\tif (c_lr_par == LEFT_PARENTS)\n\t\tdecrement_key(&s_lr_father_key);\n\n\tif (search_by_key\n\t    (tb->tb_sb, &s_lr_father_key, &s_path_to_neighbor_father,\n\t     h + 1) == IO_ERROR)\n\t\t \n\t\treturn IO_ERROR;\n\n\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\tpathrelse(&s_path_to_neighbor_father);\n\t\tbrelse(*pcom_father);\n\t\treturn REPEAT_SEARCH;\n\t}\n\n\t*pfather = PATH_PLAST_BUFFER(&s_path_to_neighbor_father);\n\n\tRFALSE(B_LEVEL(*pfather) != h + 1,\n\t       \"PAP-8190: (%b %z) level too small\", *pfather, *pfather);\n\tRFALSE(s_path_to_neighbor_father.path_length <\n\t       FIRST_PATH_ELEMENT_OFFSET, \"PAP-8192: path length is too small\");\n\n\ts_path_to_neighbor_father.path_length--;\n\tpathrelse(&s_path_to_neighbor_father);\n\treturn CARRY_ON;\n}\n\n \nstatic int get_parents(struct tree_balance *tb, int h)\n{\n\tstruct treepath *path = tb->tb_path;\n\tint position,\n\t    ret,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h);\n\tstruct buffer_head *curf, *curcf;\n\n\t \n\tif (path_offset <= FIRST_PATH_ELEMENT_OFFSET) {\n\t\t \n\t\tbrelse(tb->FL[h]);\n\t\tbrelse(tb->CFL[h]);\n\t\tbrelse(tb->FR[h]);\n\t\tbrelse(tb->CFR[h]);\n\t\ttb->FL[h]  = NULL;\n\t\ttb->CFL[h] = NULL;\n\t\ttb->FR[h]  = NULL;\n\t\ttb->CFR[h] = NULL;\n\t\treturn CARRY_ON;\n\t}\n\n\t \n\tposition = PATH_OFFSET_POSITION(path, path_offset - 1);\n\tif (position) {\n\t\t \n\t\tcurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tcurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tget_bh(curf);\n\t\tget_bh(curf);\n\t\ttb->lkey[h] = position - 1;\n\t} else {\n\t\t \n\t\tif ((ret = get_far_parent(tb, h + 1, &curf,\n\t\t\t\t\t\t  &curcf,\n\t\t\t\t\t\t  LEFT_PARENTS)) != CARRY_ON)\n\t\t\treturn ret;\n\t}\n\n\tbrelse(tb->FL[h]);\n\ttb->FL[h] = curf;\t \n\tbrelse(tb->CFL[h]);\n\ttb->CFL[h] = curcf;\t \n\n\tRFALSE((curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf)),\n\t       \"PAP-8195: FL (%b) or CFL (%b) is invalid\", curf, curcf);\n\n\t \n\n\t \n\tif (position == B_NR_ITEMS(PATH_H_PBUFFER(path, h + 1))) {\n\t\t \n\t\tif ((ret =\n\t\t     get_far_parent(tb, h + 1, &curf, &curcf,\n\t\t\t\t    RIGHT_PARENTS)) != CARRY_ON)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tcurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tcurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tget_bh(curf);\n\t\tget_bh(curf);\n\t\ttb->rkey[h] = position;\n\t}\n\n\tbrelse(tb->FR[h]);\n\t \n\ttb->FR[h] = curf;\n\n\tbrelse(tb->CFR[h]);\n\t \n\ttb->CFR[h] = curcf;\n\n\tRFALSE((curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf)),\n\t       \"PAP-8205: FR (%b) or CFR (%b) is invalid\", curf, curcf);\n\n\treturn CARRY_ON;\n}\n\n \nstatic inline int can_node_be_removed(int mode, int lfree, int sfree, int rfree,\n\t\t\t\t      struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *Sh = PATH_H_PBUFFER(tb->tb_path, h);\n\tint levbytes = tb->insert_size[h];\n\tstruct item_head *ih;\n\tstruct reiserfs_key *r_key = NULL;\n\n\tih = item_head(Sh, 0);\n\tif (tb->CFR[h])\n\t\tr_key = internal_key(tb->CFR[h], tb->rkey[h]);\n\n\tif (lfree + rfree + sfree < MAX_CHILD_SIZE(Sh) + levbytes\n\t     \n\t    -\n\t    ((!h\n\t      && op_is_left_mergeable(&ih->ih_key, Sh->b_size)) ? IH_SIZE : 0)\n\t    -\n\t    ((!h && r_key\n\t      && op_is_left_mergeable(r_key, Sh->b_size)) ? IH_SIZE : 0)\n\t    + ((h) ? KEY_SIZE : 0)) {\n\t\t \n\t\tif (sfree >= levbytes) {\n\t\t\t \n\t\t\tif (!h)\n\t\t\t\ttb->s0num =\n\t\t\t\t    B_NR_ITEMS(Sh) +\n\t\t\t\t    ((mode == M_INSERT) ? 1 : 0);\n\t\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\t\treturn NO_BALANCING_NEEDED;\n\t\t}\n\t}\n\tPROC_INFO_INC(tb->tb_sb, can_node_be_removed[h]);\n\treturn !NO_BALANCING_NEEDED;\n}\n\n \n \nstatic int ip_check_balance(struct tree_balance *tb, int h)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\t \n\tint levbytes;\n\tint ret;\n\n\tint lfree, sfree, rfree   ;\n\n\t \n\tint nver, lnver, rnver, lrnver;\n\n\t \n\n\t \n\tshort snum012[40] = { 0, };\n\n\t \n\tstruct buffer_head *Sh;\n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tlevbytes = tb->insert_size[h];\n\n\t \n\tif (!Sh) {\n\t\tif (!h)\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8210\",\n\t\t\t\t       \"S[0] can not be 0\");\n\t\tswitch (ret = get_empty_nodes(tb, h)) {\n\t\t \n\t\tcase CARRY_ON:\n\t\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\t\treturn NO_BALANCING_NEEDED;\n\n\t\tcase NO_DISK_SPACE:\n\t\tcase REPEAT_SEARCH:\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8215\", \"incorrect \"\n\t\t\t\t       \"return value of get_empty_nodes\");\n\t\t}\n\t}\n\n\t \n\tret = get_parents(tb, h);\n\tif (ret != CARRY_ON)\n\t\treturn ret;\n\n\tsfree = B_FREE_SPACE(Sh);\n\n\t \n\trfree = get_rfree(tb, h);\n\tlfree = get_lfree(tb, h);\n\n\t \n\tif (can_node_be_removed(vn->vn_mode, lfree, sfree, rfree, tb, h) ==\n\t    NO_BALANCING_NEEDED)\n\t\treturn NO_BALANCING_NEEDED;\n\n\tcreate_virtual_node(tb, h);\n\n\t \n\tcheck_left(tb, h, lfree);\n\n\t \n\tcheck_right(tb, h, rfree);\n\n\t \n\tif (h && (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1)) {\n\t\tint to_r;\n\n\t\t \n\t\tto_r =\n\t\t    ((MAX_NR_KEY(Sh) << 1) + 2 - tb->lnum[h] - tb->rnum[h] +\n\t\t     vn->vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 -\n\t\t\t\t\t\ttb->rnum[h]);\n\t\tset_parameters(tb, h, vn->vn_nr_item + 1 - to_r, to_r, 0, NULL,\n\t\t\t       -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t \n\tRFALSE(h &&\n\t       (tb->lnum[h] >= vn->vn_nr_item + 1 ||\n\t\ttb->rnum[h] >= vn->vn_nr_item + 1),\n\t       \"vs-8220: tree is not balanced on internal level\");\n\tRFALSE(!h && ((tb->lnum[h] >= vn->vn_nr_item && (tb->lbytes == -1)) ||\n\t\t      (tb->rnum[h] >= vn->vn_nr_item && (tb->rbytes == -1))),\n\t       \"vs-8225: tree is not balanced on leaf level\");\n\n\t \n\tif (!h && is_leaf_removable(tb))\n\t\treturn CARRY_ON;\n\n\t \n\n\t  \n\tif (sfree >= levbytes) {\n\t\tif (!h)\n\t\t\ttb->s0num = vn->vn_nr_item;\n\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\treturn NO_BALANCING_NEEDED;\n\t}\n\n\t{\n\t\tint lpar, rpar, nset, lset, rset, lrset;\n\t\t \n\n\t\t \n#define FLOW 1\n#define NO_FLOW 0\t\t \n\n\t\t \n#define NOTHING_SHIFT_NO_FLOW\t0\n#define NOTHING_SHIFT_FLOW\t5\n#define LEFT_SHIFT_NO_FLOW\t10\n#define LEFT_SHIFT_FLOW\t\t15\n#define RIGHT_SHIFT_NO_FLOW\t20\n#define RIGHT_SHIFT_FLOW\t25\n#define LR_SHIFT_NO_FLOW\t30\n#define LR_SHIFT_FLOW\t\t35\n\n\t\tlpar = tb->lnum[h];\n\t\trpar = tb->rnum[h];\n\n\t\t \n\t\tnset = NOTHING_SHIFT_NO_FLOW;\n\t\tnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t   0, -1, h ? vn->vn_nr_item : 0, -1,\n\t\t\t\t   snum012, NO_FLOW);\n\n\t\tif (!h) {\n\t\t\tint nver1;\n\n\t\t\t \n\t\t\tnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t    0, -1, 0, -1,\n\t\t\t\t\t    snum012 + NOTHING_SHIFT_FLOW, FLOW);\n\t\t\tif (nver > nver1)\n\t\t\t\tnset = NOTHING_SHIFT_FLOW, nver = nver1;\n\t\t}\n\n\t\t \n\t\tlset = LEFT_SHIFT_NO_FLOW;\n\t\tlnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t    lpar - ((h || tb->lbytes == -1) ? 0 : 1),\n\t\t\t\t    -1, h ? vn->vn_nr_item : 0, -1,\n\t\t\t\t    snum012 + LEFT_SHIFT_NO_FLOW, NO_FLOW);\n\t\tif (!h) {\n\t\t\tint lnver1;\n\n\t\t\tlnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t     lpar -\n\t\t\t\t\t     ((tb->lbytes != -1) ? 1 : 0),\n\t\t\t\t\t     tb->lbytes, 0, -1,\n\t\t\t\t\t     snum012 + LEFT_SHIFT_FLOW, FLOW);\n\t\t\tif (lnver > lnver1)\n\t\t\t\tlset = LEFT_SHIFT_FLOW, lnver = lnver1;\n\t\t}\n\n\t\t \n\t\trset = RIGHT_SHIFT_NO_FLOW;\n\t\trnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t    0, -1,\n\t\t\t\t    h ? (vn->vn_nr_item - rpar) : (rpar -\n\t\t\t\t\t\t\t\t   ((tb->\n\t\t\t\t\t\t\t\t     rbytes !=\n\t\t\t\t\t\t\t\t     -1) ? 1 :\n\t\t\t\t\t\t\t\t    0)), -1,\n\t\t\t\t    snum012 + RIGHT_SHIFT_NO_FLOW, NO_FLOW);\n\t\tif (!h) {\n\t\t\tint rnver1;\n\n\t\t\trnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t     0, -1,\n\t\t\t\t\t     (rpar -\n\t\t\t\t\t      ((tb->rbytes != -1) ? 1 : 0)),\n\t\t\t\t\t     tb->rbytes,\n\t\t\t\t\t     snum012 + RIGHT_SHIFT_FLOW, FLOW);\n\n\t\t\tif (rnver > rnver1)\n\t\t\t\trset = RIGHT_SHIFT_FLOW, rnver = rnver1;\n\t\t}\n\n\t\t \n\t\tlrset = LR_SHIFT_NO_FLOW;\n\t\tlrnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t     lpar - ((h || tb->lbytes == -1) ? 0 : 1),\n\t\t\t\t     -1,\n\t\t\t\t     h ? (vn->vn_nr_item - rpar) : (rpar -\n\t\t\t\t\t\t\t\t    ((tb->\n\t\t\t\t\t\t\t\t      rbytes !=\n\t\t\t\t\t\t\t\t      -1) ? 1 :\n\t\t\t\t\t\t\t\t     0)), -1,\n\t\t\t\t     snum012 + LR_SHIFT_NO_FLOW, NO_FLOW);\n\t\tif (!h) {\n\t\t\tint lrnver1;\n\n\t\t\tlrnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t      lpar -\n\t\t\t\t\t      ((tb->lbytes != -1) ? 1 : 0),\n\t\t\t\t\t      tb->lbytes,\n\t\t\t\t\t      (rpar -\n\t\t\t\t\t       ((tb->rbytes != -1) ? 1 : 0)),\n\t\t\t\t\t      tb->rbytes,\n\t\t\t\t\t      snum012 + LR_SHIFT_FLOW, FLOW);\n\t\t\tif (lrnver > lrnver1)\n\t\t\t\tlrset = LR_SHIFT_FLOW, lrnver = lrnver1;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif (lrnver < lnver && lrnver < rnver) {\n\t\t\tRFALSE(h &&\n\t\t\t       (tb->lnum[h] != 1 ||\n\t\t\t\ttb->rnum[h] != 1 ||\n\t\t\t\tlrnver != 1 || rnver != 2 || lnver != 2\n\t\t\t\t|| h != 1), \"vs-8230: bad h\");\n\t\t\tif (lrset == LR_SHIFT_FLOW)\n\t\t\t\tset_parameters(tb, h, tb->lnum[h], tb->rnum[h],\n\t\t\t\t\t       lrnver, snum012 + lrset,\n\t\t\t\t\t       tb->lbytes, tb->rbytes);\n\t\t\telse\n\t\t\t\tset_parameters(tb, h,\n\t\t\t\t\t       tb->lnum[h] -\n\t\t\t\t\t       ((tb->lbytes == -1) ? 0 : 1),\n\t\t\t\t\t       tb->rnum[h] -\n\t\t\t\t\t       ((tb->rbytes == -1) ? 0 : 1),\n\t\t\t\t\t       lrnver, snum012 + lrset, -1, -1);\n\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t \n\t\tif (nver == lrnver) {\n\t\t\tset_parameters(tb, h, 0, 0, nver, snum012 + nset, -1,\n\t\t\t\t       -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif (lnver < rnver) {\n\t\t\tSET_PAR_SHIFT_LEFT;\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t \n\t\tif (lnver > rnver) {\n\t\t\tSET_PAR_SHIFT_RIGHT;\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t \n\t\tif (is_left_neighbor_in_cache(tb, h)) {\n\t\t\tSET_PAR_SHIFT_LEFT;\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t \n\t\tSET_PAR_SHIFT_RIGHT;\n\t\treturn CARRY_ON;\n\t}\n}\n\n \nstatic int dc_check_balance_internal(struct tree_balance *tb, int h)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\n\t \n\tstruct buffer_head *Sh, *Fh;\n\tint ret;\n\tint lfree, rfree   ;\n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tFh = PATH_H_PPARENT(tb->tb_path, h);\n\n\t \n\tcreate_virtual_node(tb, h);\n\n\tif (!Fh) {\t\t \n\t\t \n\t\tif (vn->vn_nr_item > 0) {\n\t\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\t\treturn NO_BALANCING_NEEDED;\n\t\t}\n\t\t \n\t\tset_parameters(tb, h, 0, 0, 0, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\tif ((ret = get_parents(tb, h)) != CARRY_ON)\n\t\treturn ret;\n\n\t \n\trfree = get_rfree(tb, h);\n\tlfree = get_lfree(tb, h);\n\n\t \n\tcheck_left(tb, h, lfree);\n\tcheck_right(tb, h, rfree);\n\n\t \n\tif (vn->vn_nr_item >= MIN_NR_KEY(Sh)) {\n\t\t \n\t\tif (vn->vn_nr_item == MIN_NR_KEY(Sh)) {\n\t\t\t \n\t\t\tif (tb->lnum[h] >= vn->vn_nr_item + 1) {\n\t\t\t\tint n;\n\t\t\t\tint order_L;\n\n\t\t\t\torder_L =\n\t\t\t\t    ((n =\n\t\t\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t\t\t  h)) ==\n\t\t\t\t     0) ? B_NR_ITEMS(tb->FL[h]) : n - 1;\n\t\t\t\tn = dc_size(B_N_CHILD(tb->FL[h], order_L)) /\n\t\t\t\t    (DC_SIZE + KEY_SIZE);\n\t\t\t\tset_parameters(tb, h, -n - 1, 0, 0, NULL, -1,\n\t\t\t\t\t       -1);\n\t\t\t\treturn CARRY_ON;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (tb->rnum[h] >= vn->vn_nr_item + 1) {\n\t\t\t\tint n;\n\t\t\t\tint order_R;\n\n\t\t\t\torder_R =\n\t\t\t\t    ((n =\n\t\t\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t\t\t  h)) ==\n\t\t\t\t     B_NR_ITEMS(Fh)) ? 0 : n + 1;\n\t\t\t\tn = dc_size(B_N_CHILD(tb->FR[h], order_R)) /\n\t\t\t\t    (DC_SIZE + KEY_SIZE);\n\t\t\t\tset_parameters(tb, h, 0, -n - 1, 0, NULL, -1,\n\t\t\t\t\t       -1);\n\t\t\t\treturn CARRY_ON;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1) {\n\t\t\tint to_r;\n\n\t\t\tto_r =\n\t\t\t    ((MAX_NR_KEY(Sh) << 1) + 2 - tb->lnum[h] -\n\t\t\t     tb->rnum[h] + vn->vn_nr_item + 1) / 2 -\n\t\t\t    (MAX_NR_KEY(Sh) + 1 - tb->rnum[h]);\n\t\t\tset_parameters(tb, h, vn->vn_nr_item + 1 - to_r, to_r,\n\t\t\t\t       0, NULL, -1, -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t \n\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\treturn NO_BALANCING_NEEDED;\n\t}\n\n\t \n\t \n\tif (tb->lnum[h] >= vn->vn_nr_item + 1)\n\t\tif (is_left_neighbor_in_cache(tb, h)\n\t\t    || tb->rnum[h] < vn->vn_nr_item + 1 || !tb->FR[h]) {\n\t\t\tint n;\n\t\t\tint order_L;\n\n\t\t\torder_L =\n\t\t\t    ((n =\n\t\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t\t  h)) ==\n\t\t\t     0) ? B_NR_ITEMS(tb->FL[h]) : n - 1;\n\t\t\tn = dc_size(B_N_CHILD(tb->FL[h], order_L)) / (DC_SIZE +\n\t\t\t\t\t\t\t\t      KEY_SIZE);\n\t\t\tset_parameters(tb, h, -n - 1, 0, 0, NULL, -1, -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t \n\tif (tb->rnum[h] >= vn->vn_nr_item + 1) {\n\t\tint n;\n\t\tint order_R;\n\n\t\torder_R =\n\t\t    ((n =\n\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t  h)) == B_NR_ITEMS(Fh)) ? 0 : (n + 1);\n\t\tn = dc_size(B_N_CHILD(tb->FR[h], order_R)) / (DC_SIZE +\n\t\t\t\t\t\t\t      KEY_SIZE);\n\t\tset_parameters(tb, h, 0, -n - 1, 0, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t \n\tif (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1) {\n\t\tint to_r;\n\n\t\tto_r =\n\t\t    ((MAX_NR_KEY(Sh) << 1) + 2 - tb->lnum[h] - tb->rnum[h] +\n\t\t     vn->vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 -\n\t\t\t\t\t\ttb->rnum[h]);\n\t\tset_parameters(tb, h, vn->vn_nr_item + 1 - to_r, to_r, 0, NULL,\n\t\t\t       -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t \n\tRFALSE(!tb->FL[h] && !tb->FR[h], \"vs-8235: trying to borrow for root\");\n\n\t \n\tif (is_left_neighbor_in_cache(tb, h) || !tb->FR[h]) {\n\t\tint from_l;\n\n\t\tfrom_l =\n\t\t    (MAX_NR_KEY(Sh) + 1 - tb->lnum[h] + vn->vn_nr_item +\n\t\t     1) / 2 - (vn->vn_nr_item + 1);\n\t\tset_parameters(tb, h, -from_l, 0, 1, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\tset_parameters(tb, h, 0,\n\t\t       -((MAX_NR_KEY(Sh) + 1 - tb->rnum[h] + vn->vn_nr_item +\n\t\t\t  1) / 2 - (vn->vn_nr_item + 1)), 1, NULL, -1, -1);\n\treturn CARRY_ON;\n}\n\n \nstatic int dc_check_balance_leaf(struct tree_balance *tb, int h)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\n\t \n\tint levbytes;\n\n\t \n\tint maxsize, ret;\n\n\t \n\tstruct buffer_head *S0, *F0;\n\tint lfree, rfree   ;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\tF0 = PATH_H_PPARENT(tb->tb_path, 0);\n\n\tlevbytes = tb->insert_size[h];\n\n\tmaxsize = MAX_CHILD_SIZE(S0);\t \n\n\tif (!F0) {\t\t \n\n\t\tRFALSE(-levbytes >= maxsize - B_FREE_SPACE(S0),\n\t\t       \"vs-8240: attempt to create empty buffer tree\");\n\n\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\treturn NO_BALANCING_NEEDED;\n\t}\n\n\tif ((ret = get_parents(tb, h)) != CARRY_ON)\n\t\treturn ret;\n\n\t \n\trfree = get_rfree(tb, h);\n\tlfree = get_lfree(tb, h);\n\n\tcreate_virtual_node(tb, h);\n\n\t \n\tif (are_leaves_removable(tb, lfree, rfree))\n\t\treturn CARRY_ON;\n\n\t \n\tcheck_left(tb, h, lfree);\n\tcheck_right(tb, h, rfree);\n\n\t \n\tif (tb->lnum[0] >= vn->vn_nr_item && tb->lbytes == -1)\n\t\tif (is_left_neighbor_in_cache(tb, h) || ((tb->rnum[0] - ((tb->rbytes == -1) ? 0 : 1)) < vn->vn_nr_item) ||\t \n\t\t    !tb->FR[h]) {\n\n\t\t\tRFALSE(!tb->FL[h],\n\t\t\t       \"vs-8245: dc_check_balance_leaf: FL[h] must exist\");\n\n\t\t\t \n\t\t\tset_parameters(tb, h, -1, 0, 0, NULL, -1, -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t \n\tif (tb->rnum[0] >= vn->vn_nr_item && tb->rbytes == -1) {\n\t\tset_parameters(tb, h, 0, -1, 0, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t \n\tif (is_leaf_removable(tb))\n\t\treturn CARRY_ON;\n\n\t \n\ttb->s0num = vn->vn_nr_item;\n\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\treturn NO_BALANCING_NEEDED;\n}\n\n \nstatic int dc_check_balance(struct tree_balance *tb, int h)\n{\n\tRFALSE(!(PATH_H_PBUFFER(tb->tb_path, h)),\n\t       \"vs-8250: S is not initialized\");\n\n\tif (h)\n\t\treturn dc_check_balance_internal(tb, h);\n\telse\n\t\treturn dc_check_balance_leaf(tb, h);\n}\n\n \nstatic int check_balance(int mode,\n\t\t\t struct tree_balance *tb,\n\t\t\t int h,\n\t\t\t int inum,\n\t\t\t int pos_in_item,\n\t\t\t struct item_head *ins_ih, const void *data)\n{\n\tstruct virtual_node *vn;\n\n\tvn = tb->tb_vn = (struct virtual_node *)(tb->vn_buf);\n\tvn->vn_free_ptr = (char *)(tb->tb_vn + 1);\n\tvn->vn_mode = mode;\n\tvn->vn_affected_item_num = inum;\n\tvn->vn_pos_in_item = pos_in_item;\n\tvn->vn_ins_ih = ins_ih;\n\tvn->vn_data = data;\n\n\tRFALSE(mode == M_INSERT && !vn->vn_ins_ih,\n\t       \"vs-8255: ins_ih can not be 0 in insert mode\");\n\n\t \n\tif (tb->insert_size[h] > 0)\n\t\treturn ip_check_balance(tb, h);\n\n\t \n\treturn dc_check_balance(tb, h);\n}\n\n \nstatic int get_direct_parent(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *bh;\n\tstruct treepath *path = tb->tb_path;\n\tint position,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h);\n\n\t \n\tif (path_offset <= FIRST_PATH_ELEMENT_OFFSET) {\n\n\t\tRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET - 1,\n\t\t       \"PAP-8260: invalid offset in the path\");\n\n\t\tif (PATH_OFFSET_PBUFFER(path, FIRST_PATH_ELEMENT_OFFSET)->\n\t\t    b_blocknr == SB_ROOT_BLOCK(tb->tb_sb)) {\n\t\t\t \n\t\t\tPATH_OFFSET_PBUFFER(path, path_offset - 1) = NULL;\n\t\t\tPATH_OFFSET_POSITION(path, path_offset - 1) = 0;\n\t\t\treturn CARRY_ON;\n\t\t}\n\t\t \n\t\treturn REPEAT_SEARCH;\n\t}\n\n\t \n\tif (!B_IS_IN_TREE\n\t    (bh = PATH_OFFSET_PBUFFER(path, path_offset - 1)))\n\t\treturn REPEAT_SEARCH;\n\n\tif ((position =\n\t     PATH_OFFSET_POSITION(path,\n\t\t\t\t  path_offset - 1)) > B_NR_ITEMS(bh))\n\t\treturn REPEAT_SEARCH;\n\n\t \n\tif (B_N_CHILD_NUM(bh, position) !=\n\t    PATH_OFFSET_PBUFFER(path, path_offset)->b_blocknr)\n\t\treturn REPEAT_SEARCH;\n\n\tif (buffer_locked(bh)) {\n\t\tint depth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t__wait_on_buffer(bh);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\t\treturn REPEAT_SEARCH;\n\t}\n\n\t \n\treturn CARRY_ON;\n}\n\n \nstatic int get_neighbors(struct tree_balance *tb, int h)\n{\n\tint child_position,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h + 1);\n\tunsigned long son_number;\n\tstruct super_block *sb = tb->tb_sb;\n\tstruct buffer_head *bh;\n\tint depth;\n\n\tPROC_INFO_INC(sb, get_neighbors[h]);\n\n\tif (tb->lnum[h]) {\n\t\t \n\t\tPROC_INFO_INC(sb, need_l_neighbor[h]);\n\t\tbh = PATH_OFFSET_PBUFFER(tb->tb_path, path_offset);\n\n\t\tRFALSE(bh == tb->FL[h] &&\n\t\t       !PATH_OFFSET_POSITION(tb->tb_path, path_offset),\n\t\t       \"PAP-8270: invalid position in the parent\");\n\n\t\tchild_position =\n\t\t    (bh ==\n\t\t     tb->FL[h]) ? tb->lkey[h] : B_NR_ITEMS(tb->\n\t\t\t\t\t\t\t\t       FL[h]);\n\t\tson_number = B_N_CHILD_NUM(tb->FL[h], child_position);\n\t\tdepth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\tbh = sb_bread(sb, son_number);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (!bh)\n\t\t\treturn IO_ERROR;\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\tbrelse(bh);\n\t\t\tPROC_INFO_INC(sb, get_neighbors_restart[h]);\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\n\t\tRFALSE(!B_IS_IN_TREE(tb->FL[h]) ||\n\t\t       child_position > B_NR_ITEMS(tb->FL[h]) ||\n\t\t       B_N_CHILD_NUM(tb->FL[h], child_position) !=\n\t\t       bh->b_blocknr, \"PAP-8275: invalid parent\");\n\t\tRFALSE(!B_IS_IN_TREE(bh), \"PAP-8280: invalid child\");\n\t\tRFALSE(!h &&\n\t\t       B_FREE_SPACE(bh) !=\n\t\t       MAX_CHILD_SIZE(bh) -\n\t\t       dc_size(B_N_CHILD(tb->FL[0], child_position)),\n\t\t       \"PAP-8290: invalid child size of left neighbor\");\n\n\t\tbrelse(tb->L[h]);\n\t\ttb->L[h] = bh;\n\t}\n\n\t \n\tif (tb->rnum[h]) {\n\t\tPROC_INFO_INC(sb, need_r_neighbor[h]);\n\t\tbh = PATH_OFFSET_PBUFFER(tb->tb_path, path_offset);\n\n\t\tRFALSE(bh == tb->FR[h] &&\n\t\t       PATH_OFFSET_POSITION(tb->tb_path,\n\t\t\t\t\t    path_offset) >=\n\t\t       B_NR_ITEMS(bh),\n\t\t       \"PAP-8295: invalid position in the parent\");\n\n\t\tchild_position =\n\t\t    (bh == tb->FR[h]) ? tb->rkey[h] + 1 : 0;\n\t\tson_number = B_N_CHILD_NUM(tb->FR[h], child_position);\n\t\tdepth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\tbh = sb_bread(sb, son_number);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (!bh)\n\t\t\treturn IO_ERROR;\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\tbrelse(bh);\n\t\t\tPROC_INFO_INC(sb, get_neighbors_restart[h]);\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\t\tbrelse(tb->R[h]);\n\t\ttb->R[h] = bh;\n\n\t\tRFALSE(!h\n\t\t       && B_FREE_SPACE(bh) !=\n\t\t       MAX_CHILD_SIZE(bh) -\n\t\t       dc_size(B_N_CHILD(tb->FR[0], child_position)),\n\t\t       \"PAP-8300: invalid child size of right neighbor (%d != %d - %d)\",\n\t\t       B_FREE_SPACE(bh), MAX_CHILD_SIZE(bh),\n\t\t       dc_size(B_N_CHILD(tb->FR[0], child_position)));\n\n\t}\n\treturn CARRY_ON;\n}\n\nstatic int get_virtual_node_size(struct super_block *sb, struct buffer_head *bh)\n{\n\tint max_num_of_items;\n\tint max_num_of_entries;\n\tunsigned long blocksize = sb->s_blocksize;\n\n#define MIN_NAME_LEN 1\n\n\tmax_num_of_items = (blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN);\n\tmax_num_of_entries = (blocksize - BLKH_SIZE - IH_SIZE) /\n\t    (DEH_SIZE + MIN_NAME_LEN);\n\n\treturn sizeof(struct virtual_node) +\n\t    max(max_num_of_items * sizeof(struct virtual_item),\n\t\tsizeof(struct virtual_item) +\n\t\tstruct_size_t(struct direntry_uarea, entry_sizes,\n\t\t\t      max_num_of_entries));\n}\n\n \nstatic int get_mem_for_virtual_node(struct tree_balance *tb)\n{\n\tint check_fs = 0;\n\tint size;\n\tchar *buf;\n\n\tsize = get_virtual_node_size(tb->tb_sb, PATH_PLAST_BUFFER(tb->tb_path));\n\n\t \n\tif (size > tb->vn_buf_size) {\n\t\tif (tb->vn_buf) {\n\t\t\t \n\t\t\tkfree(tb->vn_buf);\n\t\t\t \n\t\t\tcheck_fs = 1;\n\t\t}\n\n\t\t \n\t\ttb->vn_buf_size = size;\n\n\t\t \n\t\tbuf = kmalloc(size, GFP_ATOMIC | __GFP_NOWARN);\n\t\tif (!buf) {\n\t\t\t \n\t\t\tfree_buffers_in_tb(tb);\n\t\t\tbuf = kmalloc(size, GFP_NOFS);\n\t\t\tif (!buf) {\n\t\t\t\ttb->vn_buf_size = 0;\n\t\t\t}\n\t\t\ttb->vn_buf = buf;\n\t\t\tschedule();\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\n\t\ttb->vn_buf = buf;\n\t}\n\n\tif (check_fs && FILESYSTEM_CHANGED_TB(tb))\n\t\treturn REPEAT_SEARCH;\n\n\treturn CARRY_ON;\n}\n\n#ifdef CONFIG_REISERFS_CHECK\nstatic void tb_buffer_sanity_check(struct super_block *sb,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   const char *descr, int level)\n{\n\tif (bh) {\n\t\tif (atomic_read(&(bh->b_count)) <= 0)\n\n\t\t\treiserfs_panic(sb, \"jmacd-1\", \"negative or zero \"\n\t\t\t\t       \"reference counter for buffer %s[%d] \"\n\t\t\t\t       \"(%b)\", descr, level, bh);\n\n\t\tif (!buffer_uptodate(bh))\n\t\t\treiserfs_panic(sb, \"jmacd-2\", \"buffer is not up \"\n\t\t\t\t       \"to date %s[%d] (%b)\",\n\t\t\t\t       descr, level, bh);\n\n\t\tif (!B_IS_IN_TREE(bh))\n\t\t\treiserfs_panic(sb, \"jmacd-3\", \"buffer is not \"\n\t\t\t\t       \"in tree %s[%d] (%b)\",\n\t\t\t\t       descr, level, bh);\n\n\t\tif (bh->b_bdev != sb->s_bdev)\n\t\t\treiserfs_panic(sb, \"jmacd-4\", \"buffer has wrong \"\n\t\t\t\t       \"device %s[%d] (%b)\",\n\t\t\t\t       descr, level, bh);\n\n\t\tif (bh->b_size != sb->s_blocksize)\n\t\t\treiserfs_panic(sb, \"jmacd-5\", \"buffer has wrong \"\n\t\t\t\t       \"blocksize %s[%d] (%b)\",\n\t\t\t\t       descr, level, bh);\n\n\t\tif (bh->b_blocknr > SB_BLOCK_COUNT(sb))\n\t\t\treiserfs_panic(sb, \"jmacd-6\", \"buffer block \"\n\t\t\t\t       \"number too high %s[%d] (%b)\",\n\t\t\t\t       descr, level, bh);\n\t}\n}\n#else\nstatic void tb_buffer_sanity_check(struct super_block *sb,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   const char *descr, int level)\n{;\n}\n#endif\n\nstatic int clear_all_dirty_bits(struct super_block *s, struct buffer_head *bh)\n{\n\treturn reiserfs_prepare_for_journal(s, bh, 0);\n}\n\nstatic int wait_tb_buffers_until_unlocked(struct tree_balance *tb)\n{\n\tstruct buffer_head *locked;\n#ifdef CONFIG_REISERFS_CHECK\n\tint repeat_counter = 0;\n#endif\n\tint i;\n\n\tdo {\n\n\t\tlocked = NULL;\n\n\t\tfor (i = tb->tb_path->path_length;\n\t\t     !locked && i > ILLEGAL_PATH_ELEMENT_OFFSET; i--) {\n\t\t\tif (PATH_OFFSET_PBUFFER(tb->tb_path, i)) {\n\t\t\t\t \n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\tif (PATH_PLAST_BUFFER(tb->tb_path) ==\n\t\t\t\t    PATH_OFFSET_PBUFFER(tb->tb_path, i))\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       PATH_OFFSET_PBUFFER\n\t\t\t\t\t\t\t       (tb->tb_path,\n\t\t\t\t\t\t\t\ti), \"S\",\n\t\t\t\t\t\t\t       tb->tb_path->\n\t\t\t\t\t\t\t       path_length - i);\n#endif\n\t\t\t\tif (!clear_all_dirty_bits(tb->tb_sb,\n\t\t\t\t\t\t\t  PATH_OFFSET_PBUFFER\n\t\t\t\t\t\t\t  (tb->tb_path,\n\t\t\t\t\t\t\t   i))) {\n\t\t\t\t\tlocked =\n\t\t\t\t\t    PATH_OFFSET_PBUFFER(tb->tb_path,\n\t\t\t\t\t\t\t\ti);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; !locked && i < MAX_HEIGHT && tb->insert_size[i];\n\t\t     i++) {\n\n\t\t\tif (tb->lnum[i]) {\n\n\t\t\t\tif (tb->L[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->L[i],\n\t\t\t\t\t\t\t       \"L\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->L[i]))\n\t\t\t\t\t\tlocked = tb->L[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->FL[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->FL[i],\n\t\t\t\t\t\t\t       \"FL\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->FL[i]))\n\t\t\t\t\t\tlocked = tb->FL[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->CFL[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->CFL[i],\n\t\t\t\t\t\t\t       \"CFL\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->CFL[i]))\n\t\t\t\t\t\tlocked = tb->CFL[i];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (!locked && (tb->rnum[i])) {\n\n\t\t\t\tif (tb->R[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->R[i],\n\t\t\t\t\t\t\t       \"R\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->R[i]))\n\t\t\t\t\t\tlocked = tb->R[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->FR[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->FR[i],\n\t\t\t\t\t\t\t       \"FR\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->FR[i]))\n\t\t\t\t\t\tlocked = tb->FR[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->CFR[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->CFR[i],\n\t\t\t\t\t\t\t       \"CFR\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->CFR[i]))\n\t\t\t\t\t\tlocked = tb->CFR[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (i = 0; !locked && i < MAX_FEB_SIZE; i++) {\n\t\t\tif (tb->FEB[i]) {\n\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t    (tb->tb_sb, tb->FEB[i]))\n\t\t\t\t\tlocked = tb->FEB[i];\n\t\t\t}\n\t\t}\n\n\t\tif (locked) {\n\t\t\tint depth;\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\trepeat_counter++;\n\t\t\tif ((repeat_counter % 10000) == 0) {\n\t\t\t\treiserfs_warning(tb->tb_sb, \"reiserfs-8200\",\n\t\t\t\t\t\t \"too many iterations waiting \"\n\t\t\t\t\t\t \"for buffer to unlock \"\n\t\t\t\t\t\t \"(%b)\", locked);\n\n\t\t\t\t \n\n\t\t\t\treturn (FILESYSTEM_CHANGED_TB(tb)) ?\n\t\t\t\t    REPEAT_SEARCH : CARRY_ON;\n\t\t\t}\n#endif\n\t\t\tdepth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t\t__wait_on_buffer(locked);\n\t\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\t\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\n\t} while (locked);\n\n\treturn CARRY_ON;\n}\n\n \n\nint fix_nodes(int op_mode, struct tree_balance *tb,\n\t      struct item_head *ins_ih, const void *data)\n{\n\tint ret, h, item_num = PATH_LAST_POSITION(tb->tb_path);\n\tint pos_in_item;\n\n\t \n\tint wait_tb_buffers_run = 0;\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\n\t++REISERFS_SB(tb->tb_sb)->s_fix_nodes;\n\n\tpos_in_item = tb->tb_path->pos_in_item;\n\n\ttb->fs_gen = get_generation(tb->tb_sb);\n\n\t \n\treiserfs_prepare_for_journal(tb->tb_sb,\n\t\t\t\t     SB_BUFFER_WITH_SB(tb->tb_sb), 1);\n\tjournal_mark_dirty(tb->transaction_handle,\n\t\t\t   SB_BUFFER_WITH_SB(tb->tb_sb));\n\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\treturn REPEAT_SEARCH;\n\n\t \n\tif (buffer_locked(tbS0)) {\n\t\tint depth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t__wait_on_buffer(tbS0);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\t\treturn REPEAT_SEARCH;\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\tif (REISERFS_SB(tb->tb_sb)->cur_tb) {\n\t\tprint_cur_tb(\"fix_nodes\");\n\t\treiserfs_panic(tb->tb_sb, \"PAP-8305\",\n\t\t\t       \"there is pending do_balance\");\n\t}\n\n\tif (!buffer_uptodate(tbS0) || !B_IS_IN_TREE(tbS0))\n\t\treiserfs_panic(tb->tb_sb, \"PAP-8320\", \"S[0] (%b %z) is \"\n\t\t\t       \"not uptodate at the beginning of fix_nodes \"\n\t\t\t       \"or not in tree (mode %c)\",\n\t\t\t       tbS0, tbS0, op_mode);\n\n\t \n\tswitch (op_mode) {\n\tcase M_INSERT:\n\t\tif (item_num <= 0 || item_num > B_NR_ITEMS(tbS0))\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-8330\", \"Incorrect \"\n\t\t\t\t       \"item number %d (in S0 - %d) in case \"\n\t\t\t\t       \"of insert\", item_num,\n\t\t\t\t       B_NR_ITEMS(tbS0));\n\t\tbreak;\n\tcase M_PASTE:\n\tcase M_DELETE:\n\tcase M_CUT:\n\t\tif (item_num < 0 || item_num >= B_NR_ITEMS(tbS0)) {\n\t\t\tprint_block(tbS0, 0, -1, -1);\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-8335\", \"Incorrect \"\n\t\t\t\t       \"item number(%d); mode = %c \"\n\t\t\t\t       \"insert_size = %d\",\n\t\t\t\t       item_num, op_mode,\n\t\t\t\t       tb->insert_size[0]);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treiserfs_panic(tb->tb_sb, \"PAP-8340\", \"Incorrect mode \"\n\t\t\t       \"of operation\");\n\t}\n#endif\n\n\tif (get_mem_for_virtual_node(tb) == REPEAT_SEARCH)\n\t\t \n\t\treturn REPEAT_SEARCH;\n\n\t \n\tfor (h = 0; h < MAX_HEIGHT && tb->insert_size[h]; h++) {\n\t\tret = get_direct_parent(tb, h);\n\t\tif (ret != CARRY_ON)\n\t\t\tgoto repeat;\n\n\t\tret = check_balance(op_mode, tb, h, item_num,\n\t\t\t\t    pos_in_item, ins_ih, data);\n\t\tif (ret != CARRY_ON) {\n\t\t\tif (ret == NO_BALANCING_NEEDED) {\n\t\t\t\t \n\t\t\t\tret = get_neighbors(tb, h);\n\t\t\t\tif (ret != CARRY_ON)\n\t\t\t\t\tgoto repeat;\n\t\t\t\tif (h != MAX_HEIGHT - 1)\n\t\t\t\t\ttb->insert_size[h + 1] = 0;\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tret = get_neighbors(tb, h);\n\t\tif (ret != CARRY_ON)\n\t\t\tgoto repeat;\n\n\t\t \n\t\tret = get_empty_nodes(tb, h);\n\t\tif (ret != CARRY_ON)\n\t\t\tgoto repeat;\n\n\t\t \n\t\tif (!PATH_H_PBUFFER(tb->tb_path, h)) {\n\n\t\t\tRFALSE(tb->blknum[h] != 1,\n\t\t\t       \"PAP-8350: creating new empty root\");\n\n\t\t\tif (h < MAX_HEIGHT - 1)\n\t\t\t\ttb->insert_size[h + 1] = 0;\n\t\t} else if (!PATH_H_PBUFFER(tb->tb_path, h + 1)) {\n\t\t\t \n\t\t\tif (tb->blknum[h] > 1) {\n\n\t\t\t\tRFALSE(h == MAX_HEIGHT - 1,\n\t\t\t\t       \"PAP-8355: attempt to create too high of a tree\");\n\n\t\t\t\ttb->insert_size[h + 1] =\n\t\t\t\t    (DC_SIZE +\n\t\t\t\t     KEY_SIZE) * (tb->blknum[h] - 1) +\n\t\t\t\t    DC_SIZE;\n\t\t\t} else if (h < MAX_HEIGHT - 1)\n\t\t\t\ttb->insert_size[h + 1] = 0;\n\t\t} else\n\t\t\ttb->insert_size[h + 1] =\n\t\t\t    (DC_SIZE + KEY_SIZE) * (tb->blknum[h] - 1);\n\t}\n\n\tret = wait_tb_buffers_until_unlocked(tb);\n\tif (ret == CARRY_ON) {\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\twait_tb_buffers_run = 1;\n\t\t\tret = REPEAT_SEARCH;\n\t\t\tgoto repeat;\n\t\t} else {\n\t\t\treturn CARRY_ON;\n\t\t}\n\t} else {\n\t\twait_tb_buffers_run = 1;\n\t\tgoto repeat;\n\t}\n\nrepeat:\n\t \n\t{\n\t\tint i;\n\n\t\t \n\t\tif (wait_tb_buffers_run) {\n\t\t\tpathrelse_and_restore(tb->tb_sb, tb->tb_path);\n\t\t} else {\n\t\t\tpathrelse(tb->tb_path);\n\t\t}\n\t\t \n\t\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\t\tif (wait_tb_buffers_run) {\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->L[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->R[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->FL[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->FR[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->\n\t\t\t\t\t\t\t\t CFL[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->\n\t\t\t\t\t\t\t\t CFR[i]);\n\t\t\t}\n\n\t\t\tbrelse(tb->L[i]);\n\t\t\tbrelse(tb->R[i]);\n\t\t\tbrelse(tb->FL[i]);\n\t\t\tbrelse(tb->FR[i]);\n\t\t\tbrelse(tb->CFL[i]);\n\t\t\tbrelse(tb->CFR[i]);\n\n\t\t\ttb->L[i] = NULL;\n\t\t\ttb->R[i] = NULL;\n\t\t\ttb->FL[i] = NULL;\n\t\t\ttb->FR[i] = NULL;\n\t\t\ttb->CFL[i] = NULL;\n\t\t\ttb->CFR[i] = NULL;\n\t\t}\n\n\t\tif (wait_tb_buffers_run) {\n\t\t\tfor (i = 0; i < MAX_FEB_SIZE; i++) {\n\t\t\t\tif (tb->FEB[i])\n\t\t\t\t\treiserfs_restore_prepared_buffer\n\t\t\t\t\t    (tb->tb_sb, tb->FEB[i]);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n}\n\nvoid unfix_nodes(struct tree_balance *tb)\n{\n\tint i;\n\n\t \n\tpathrelse_and_restore(tb->tb_sb, tb->tb_path);\n\n\t \n\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->L[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->R[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->FL[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->FR[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFL[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFR[i]);\n\n\t\tbrelse(tb->L[i]);\n\t\tbrelse(tb->R[i]);\n\t\tbrelse(tb->FL[i]);\n\t\tbrelse(tb->FR[i]);\n\t\tbrelse(tb->CFL[i]);\n\t\tbrelse(tb->CFR[i]);\n\t}\n\n\t \n\tfor (i = 0; i < MAX_FEB_SIZE; i++) {\n\t\tif (tb->FEB[i]) {\n\t\t\tb_blocknr_t blocknr = tb->FEB[i]->b_blocknr;\n\t\t\t \n\t\t\tbrelse(tb->FEB[i]);\n\t\t\treiserfs_free_block(tb->transaction_handle, NULL,\n\t\t\t\t\t    blocknr, 0);\n\t\t}\n\t\tif (tb->used[i]) {\n\t\t\t \n\t\t\tbrelse(tb->used[i]);\n\t\t}\n\t}\n\n\tkfree(tb->vn_buf);\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}