{
  "module_name": "super.c",
  "hash_id": "fef13f3a6e40a1e7fa799b6db05d015776a544c0ecd22562e16c511782998e40",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/super.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/uaccess.h>\n#include \"reiserfs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/crc32.h>\n#include <linux/seq_file.h>\n\nstruct file_system_type reiserfs_fs_type;\n\nstatic const char reiserfs_3_5_magic_string[] = REISERFS_SUPER_MAGIC_STRING;\nstatic const char reiserfs_3_6_magic_string[] = REISER2FS_SUPER_MAGIC_STRING;\nstatic const char reiserfs_jr_magic_string[] = REISER2FS_JR_SUPER_MAGIC_STRING;\n\nint is_reiserfs_3_5(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_3_5_magic_string,\n\t\t\tstrlen(reiserfs_3_5_magic_string));\n}\n\nint is_reiserfs_3_6(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_3_6_magic_string,\n\t\t\tstrlen(reiserfs_3_6_magic_string));\n}\n\nint is_reiserfs_jr(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_jr_magic_string,\n\t\t\tstrlen(reiserfs_jr_magic_string));\n}\n\nstatic int is_any_reiserfs_magic_string(struct reiserfs_super_block *rs)\n{\n\treturn (is_reiserfs_3_5(rs) || is_reiserfs_3_6(rs) ||\n\t\tis_reiserfs_jr(rs));\n}\n\nstatic int reiserfs_remount(struct super_block *s, int *flags, char *data);\nstatic int reiserfs_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic int reiserfs_sync_fs(struct super_block *s, int wait)\n{\n\tstruct reiserfs_transaction_handle th;\n\n\t \n\tdquot_writeback_dquots(s, -1);\n\treiserfs_write_lock(s);\n\tif (!journal_begin(&th, s, 1))\n\t\tif (!journal_end_sync(&th))\n\t\t\treiserfs_flush_old_commits(s);\n\treiserfs_write_unlock(s);\n\treturn 0;\n}\n\nstatic void flush_old_commits(struct work_struct *work)\n{\n\tstruct reiserfs_sb_info *sbi;\n\tstruct super_block *s;\n\n\tsbi = container_of(work, struct reiserfs_sb_info, old_work.work);\n\ts = sbi->s_journal->j_work_sb;\n\n\t \n\tif (!down_read_trylock(&s->s_umount)) {\n\t\t \n\t\tspin_lock(&sbi->old_work_lock);\n\t\tif (sbi->work_queued == 1)\n\t\t\tqueue_delayed_work(system_long_wq, &sbi->old_work, HZ);\n\t\tspin_unlock(&sbi->old_work_lock);\n\t\treturn;\n\t}\n\tspin_lock(&sbi->old_work_lock);\n\t \n\tif (sbi->work_queued == 1)\n\t\tsbi->work_queued = 0;\n\tspin_unlock(&sbi->old_work_lock);\n\n\treiserfs_sync_fs(s, 1);\n\tup_read(&s->s_umount);\n}\n\nvoid reiserfs_schedule_old_flush(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sbi = REISERFS_SB(s);\n\tunsigned long delay;\n\n\t \n\tif (sb_rdonly(s) || !(s->s_flags & SB_ACTIVE))\n\t\treturn;\n\n\tspin_lock(&sbi->old_work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->old_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->old_work_lock);\n}\n\nvoid reiserfs_cancel_old_flush(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sbi = REISERFS_SB(s);\n\n\tspin_lock(&sbi->old_work_lock);\n\t \n\tsbi->work_queued = 2;\n\tspin_unlock(&sbi->old_work_lock);\n\tcancel_delayed_work_sync(&REISERFS_SB(s)->old_work);\n}\n\nstatic int reiserfs_freeze(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle th;\n\n\treiserfs_cancel_old_flush(s);\n\n\treiserfs_write_lock(s);\n\tif (!sb_rdonly(s)) {\n\t\tint err = journal_begin(&th, s, 1);\n\t\tif (err) {\n\t\t\treiserfs_block_writes(&th);\n\t\t} else {\n\t\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\t\t\treiserfs_block_writes(&th);\n\t\t\tjournal_end_sync(&th);\n\t\t}\n\t}\n\treiserfs_write_unlock(s);\n\treturn 0;\n}\n\nstatic int reiserfs_unfreeze(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sbi = REISERFS_SB(s);\n\n\treiserfs_allow_writes(s);\n\tspin_lock(&sbi->old_work_lock);\n\t \n\tsbi->work_queued = 0;\n\tspin_unlock(&sbi->old_work_lock);\n\treturn 0;\n}\n\nextern const struct in_core_key MAX_IN_CORE_KEY;\n\n \nstatic int remove_save_link_only(struct super_block *s,\n\t\t\t\t struct reiserfs_key *key, int oid_free)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint err;\n\n\t \n\terr = journal_begin(&th, s, JOURNAL_PER_BALANCE_CNT);\n\tif (err)\n\t\treturn err;\n\n\treiserfs_delete_solid_item(&th, NULL, key);\n\tif (oid_free)\n\t\t \n\t\treiserfs_release_objectid(&th, le32_to_cpu(key->k_objectid));\n\n\treturn journal_end(&th);\n}\n\n#ifdef CONFIG_QUOTA\nstatic int reiserfs_quota_on_mount(struct super_block *, int);\n#endif\n\n \nstatic int finish_unfinished(struct super_block *s)\n{\n\tINITIALIZE_PATH(path);\n\tstruct cpu_key max_cpu_key, obj_key;\n\tstruct reiserfs_key save_link_key, last_inode_key;\n\tint retval = 0;\n\tstruct item_head *ih;\n\tstruct buffer_head *bh;\n\tint item_pos;\n\tchar *item;\n\tint done;\n\tstruct inode *inode;\n\tint truncate;\n#ifdef CONFIG_QUOTA\n\tint i;\n\tint ms_active_set;\n\tint quota_enabled[REISERFS_MAXQUOTAS];\n#endif\n\n\t \n\tmax_cpu_key.version = KEY_FORMAT_3_5;\n\tmax_cpu_key.on_disk_key.k_dir_id = ~0U;\n\tmax_cpu_key.on_disk_key.k_objectid = ~0U;\n\tset_cpu_key_k_offset(&max_cpu_key, ~0U);\n\tmax_cpu_key.key_length = 3;\n\n\tmemset(&last_inode_key, 0, sizeof(last_inode_key));\n\n#ifdef CONFIG_QUOTA\n\t \n\tif (s->s_flags & SB_ACTIVE) {\n\t\tms_active_set = 0;\n\t} else {\n\t\tms_active_set = 1;\n\t\ts->s_flags |= SB_ACTIVE;\n\t}\n\t \n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tquota_enabled[i] = 1;\n\t\tif (REISERFS_SB(s)->s_qf_names[i]) {\n\t\t\tint ret;\n\n\t\t\tif (sb_has_quota_active(s, i)) {\n\t\t\t\tquota_enabled[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treiserfs_write_unlock(s);\n\t\t\tret = reiserfs_quota_on_mount(s, i);\n\t\t\treiserfs_write_lock(s);\n\t\t\tif (ret < 0)\n\t\t\t\treiserfs_warning(s, \"reiserfs-2500\",\n\t\t\t\t\t\t \"cannot turn on journaled \"\n\t\t\t\t\t\t \"quota: error %d\", ret);\n\t\t}\n\t}\n#endif\n\n\tdone = 0;\n\tREISERFS_SB(s)->s_is_unlinked_ok = 1;\n\twhile (!retval) {\n\t\tint depth;\n\t\tretval = search_item(s, &max_cpu_key, &path);\n\t\tif (retval != ITEM_NOT_FOUND) {\n\t\t\treiserfs_error(s, \"vs-2140\",\n\t\t\t\t       \"search_by_key returned %d\", retval);\n\t\t\tbreak;\n\t\t}\n\n\t\tbh = get_last_bh(&path);\n\t\titem_pos = get_item_pos(&path);\n\t\tif (item_pos != B_NR_ITEMS(bh)) {\n\t\t\treiserfs_warning(s, \"vs-2060\",\n\t\t\t\t\t \"wrong position found\");\n\t\t\tbreak;\n\t\t}\n\t\titem_pos--;\n\t\tih = item_head(bh, item_pos);\n\n\t\tif (le32_to_cpu(ih->ih_key.k_dir_id) != MAX_KEY_OBJECTID)\n\t\t\t \n\t\t\tbreak;\n\n\t\tsave_link_key = ih->ih_key;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\ttruncate = 1;\n\t\telse\n\t\t\ttruncate = 0;\n\n\t\t \n\t\titem = ih_item_body(bh, ih);\n\t\tobj_key.on_disk_key.k_dir_id = le32_to_cpu(*(__le32 *) item);\n\t\tobj_key.on_disk_key.k_objectid =\n\t\t    le32_to_cpu(ih->ih_key.k_objectid);\n\t\tobj_key.on_disk_key.k_offset = 0;\n\t\tobj_key.on_disk_key.k_type = 0;\n\n\t\tpathrelse(&path);\n\n\t\tinode = reiserfs_iget(s, &obj_key);\n\t\tif (IS_ERR_OR_NULL(inode)) {\n\t\t\t \n\t\t\treiserfs_warning(s, \"vs-2180\", \"iget failed for %K\",\n\t\t\t\t\t &obj_key);\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!truncate && inode->i_nlink) {\n\t\t\t \n\t\t\treiserfs_warning(s, \"vs-2185\",\n\t\t\t\t\t \"file %K is not unlinked\",\n\t\t\t\t\t &obj_key);\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 0);\n\t\t\tcontinue;\n\t\t}\n\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tdquot_initialize(inode);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\t\tif (truncate && S_ISDIR(inode->i_mode)) {\n\t\t\t \n\t\t\treiserfs_warning(s, \"green-2101\",\n\t\t\t\t\t \"impossible truncate on a \"\n\t\t\t\t\t \"directory %k. Please report\",\n\t\t\t\t\t INODE_PKEY(inode));\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 0);\n\t\t\ttruncate = 0;\n\t\t\tiput(inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (truncate) {\n\t\t\tREISERFS_I(inode)->i_flags |=\n\t\t\t    i_link_saved_truncate_mask;\n\t\t\t \n\t\t\treiserfs_info(s, \"Truncating %k to %lld ..\",\n\t\t\t\t      INODE_PKEY(inode), inode->i_size);\n\n\t\t\t \n\t\t\treiserfs_truncate_file(inode, 0);\n\n\t\t\tretval = remove_save_link(inode, truncate);\n\t\t} else {\n\t\t\tREISERFS_I(inode)->i_flags |= i_link_saved_unlink_mask;\n\t\t\t \n\t\t\treiserfs_info(s, \"Removing %k..\", INODE_PKEY(inode));\n\t\t\tif (memcmp(&last_inode_key, INODE_PKEY(inode),\n\t\t\t\t\tsizeof(last_inode_key))){\n\t\t\t\tlast_inode_key = *INODE_PKEY(inode);\n\t\t\t\t \n\t\t\t\tretval = 0;\n\t\t\t} else {\n\t\t\t\treiserfs_warning(s, \"super-2189\", \"Dead loop \"\n\t\t\t\t\t\t \"in finish_unfinished \"\n\t\t\t\t\t\t \"detected, just remove \"\n\t\t\t\t\t\t \"save link\\n\");\n\t\t\t\tretval = remove_save_link_only(s,\n\t\t\t\t\t\t\t&save_link_key, 0);\n\t\t\t}\n\t\t}\n\n\t\tiput(inode);\n\t\tprintk(\"done\\n\");\n\t\tdone++;\n\t}\n\tREISERFS_SB(s)->s_is_unlinked_ok = 0;\n\n#ifdef CONFIG_QUOTA\n\t \n\treiserfs_write_unlock(s);\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tif (sb_dqopt(s)->files[i] && quota_enabled[i])\n\t\t\tdquot_quota_off(s, i);\n\t}\n\treiserfs_write_lock(s);\n\tif (ms_active_set)\n\t\t \n\t\ts->s_flags &= ~SB_ACTIVE;\n#endif\n\tpathrelse(&path);\n\tif (done)\n\t\treiserfs_info(s, \"There were %d uncompleted unlinks/truncates. \"\n\t\t\t      \"Completed\\n\", done);\n\treturn retval;\n}\n\n \nvoid add_save_link(struct reiserfs_transaction_handle *th,\n\t\t   struct inode *inode, int truncate)\n{\n\tINITIALIZE_PATH(path);\n\tint retval;\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\t__le32 link;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t \n\tRFALSE(truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask),\n\t       \"saved link already exists for truncated inode %lx\",\n\t       (long)inode->i_ino);\n\tRFALSE(!truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask),\n\t       \"saved link already exists for unlinked inode %lx\",\n\t       (long)inode->i_ino);\n\n\t \n\tkey.version = KEY_FORMAT_3_5;\n\tkey.on_disk_key.k_dir_id = MAX_KEY_OBJECTID;\n\tkey.on_disk_key.k_objectid = inode->i_ino;\n\tif (!truncate) {\n\t\t \n\t\tset_cpu_key_k_offset(&key, 1 + inode->i_sb->s_blocksize);\n\t\tset_cpu_key_k_type(&key, TYPE_DIRECT);\n\n\t\t \n\t\tmake_le_item_head(&ih, &key, key.version,\n\t\t\t\t  1 + inode->i_sb->s_blocksize, TYPE_DIRECT,\n\t\t\t\t  4   , 0xffff   );\n\t} else {\n\t\t \n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treiserfs_warning(inode->i_sb, \"green-2102\",\n\t\t\t\t\t \"Adding a truncate savelink for \"\n\t\t\t\t\t \"a directory %k! Please report\",\n\t\t\t\t\t INODE_PKEY(inode));\n\t\tset_cpu_key_k_offset(&key, 1);\n\t\tset_cpu_key_k_type(&key, TYPE_INDIRECT);\n\n\t\t \n\t\tmake_le_item_head(&ih, &key, key.version, 1, TYPE_INDIRECT,\n\t\t\t\t  4   , 0   );\n\t}\n\tkey.key_length = 3;\n\n\t \n\tretval = search_item(inode->i_sb, &key, &path);\n\tif (retval != ITEM_NOT_FOUND) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2100\",\n\t\t\t\t       \"search_by_key (%K) returned %d\", &key,\n\t\t\t\t       retval);\n\t\tpathrelse(&path);\n\t\treturn;\n\t}\n\n\t \n\tlink = INODE_PKEY(inode)->k_dir_id;\n\n\t \n\tretval =\n\t    reiserfs_insert_item(th, &path, &key, &ih, NULL, (char *)&link);\n\tif (retval) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2120\",\n\t\t\t\t       \"insert_item returned %d\", retval);\n\t} else {\n\t\tif (truncate)\n\t\t\tREISERFS_I(inode)->i_flags |=\n\t\t\t    i_link_saved_truncate_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags |= i_link_saved_unlink_mask;\n\t}\n}\n\n \nint remove_save_link(struct inode *inode, int truncate)\n{\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_key key;\n\tint err;\n\n\t \n\terr = journal_begin(&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT);\n\tif (err)\n\t\treturn err;\n\n\t \n\tkey.k_dir_id = cpu_to_le32(MAX_KEY_OBJECTID);\n\tkey.k_objectid = INODE_PKEY(inode)->k_objectid;\n\tif (!truncate) {\n\t\t \n\t\tset_le_key_k_offset(KEY_FORMAT_3_5, &key,\n\t\t\t\t    1 + inode->i_sb->s_blocksize);\n\t\tset_le_key_k_type(KEY_FORMAT_3_5, &key, TYPE_DIRECT);\n\t} else {\n\t\t \n\t\tset_le_key_k_offset(KEY_FORMAT_3_5, &key, 1);\n\t\tset_le_key_k_type(KEY_FORMAT_3_5, &key, TYPE_INDIRECT);\n\t}\n\n\tif ((truncate &&\n\t     (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask)) ||\n\t    (!truncate &&\n\t     (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask)))\n\t\t \n\t\treiserfs_delete_solid_item(&th, NULL, &key);\n\tif (!truncate) {\n\t\treiserfs_release_objectid(&th, inode->i_ino);\n\t\tREISERFS_I(inode)->i_flags &= ~i_link_saved_unlink_mask;\n\t} else\n\t\tREISERFS_I(inode)->i_flags &= ~i_link_saved_truncate_mask;\n\n\treturn journal_end(&th);\n}\n\nstatic void reiserfs_kill_sb(struct super_block *s)\n{\n\tif (REISERFS_SB(s)) {\n\t\treiserfs_proc_info_done(s);\n\t\t \n\t\tshrink_dcache_sb(s);\n\n\t\tdput(REISERFS_SB(s)->xattr_root);\n\t\tREISERFS_SB(s)->xattr_root = NULL;\n\t\tdput(REISERFS_SB(s)->priv_root);\n\t\tREISERFS_SB(s)->priv_root = NULL;\n\t}\n\n\tkill_block_super(s);\n}\n\n#ifdef CONFIG_QUOTA\nstatic int reiserfs_quota_off(struct super_block *sb, int type);\n\nstatic void reiserfs_quota_off_umount(struct super_block *s)\n{\n\tint type;\n\n\tfor (type = 0; type < REISERFS_MAXQUOTAS; type++)\n\t\treiserfs_quota_off(s, type);\n}\n#else\nstatic inline void reiserfs_quota_off_umount(struct super_block *s)\n{\n}\n#endif\n\nstatic void reiserfs_put_super(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle th;\n\tth.t_trans_id = 0;\n\n\treiserfs_quota_off_umount(s);\n\n\treiserfs_write_lock(s);\n\n\t \n\tif (!sb_rdonly(s)) {\n\t\tif (!journal_begin(&th, s, 10)) {\n\t\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s),\n\t\t\t\t\t\t     1);\n\t\t\tset_sb_umount_state(SB_DISK_SUPER_BLOCK(s),\n\t\t\t\t\t    REISERFS_SB(s)->s_mount_state);\n\t\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\t\t}\n\t}\n\n\t \n\tjournal_release(&th, s);\n\n\treiserfs_free_bitmap_cache(s);\n\n\tbrelse(SB_BUFFER_WITH_SB(s));\n\n\tprint_statistics(s);\n\n\tif (REISERFS_SB(s)->reserved_blocks != 0) {\n\t\treiserfs_warning(s, \"green-2005\", \"reserved blocks left %d\",\n\t\t\t\t REISERFS_SB(s)->reserved_blocks);\n\t}\n\n\treiserfs_write_unlock(s);\n\tmutex_destroy(&REISERFS_SB(s)->lock);\n\tdestroy_workqueue(REISERFS_SB(s)->commit_wq);\n\tkfree(REISERFS_SB(s)->s_jdev);\n\tkfree(s->s_fs_info);\n\ts->s_fs_info = NULL;\n}\n\nstatic struct kmem_cache *reiserfs_inode_cachep;\n\nstatic struct inode *reiserfs_alloc_inode(struct super_block *sb)\n{\n\tstruct reiserfs_inode_info *ei;\n\tei = alloc_inode_sb(sb, reiserfs_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\tatomic_set(&ei->openers, 0);\n\tmutex_init(&ei->tailpack);\n#ifdef CONFIG_QUOTA\n\tmemset(&ei->i_dquot, 0, sizeof(ei->i_dquot));\n#endif\n\n\treturn &ei->vfs_inode;\n}\n\nstatic void reiserfs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(reiserfs_inode_cachep, REISERFS_I(inode));\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct reiserfs_inode_info *ei = (struct reiserfs_inode_info *)foo;\n\n\tINIT_LIST_HEAD(&ei->i_prealloc_list);\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int __init init_inodecache(void)\n{\n\treiserfs_inode_cachep = kmem_cache_create(\"reiser_inode_cache\",\n\t\t\t\t\t\t  sizeof(struct\n\t\t\t\t\t\t\t reiserfs_inode_info),\n\t\t\t\t\t\t  0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\t      SLAB_MEM_SPREAD|\n\t\t\t\t\t\t      SLAB_ACCOUNT),\n\t\t\t\t\t\t  init_once);\n\tif (reiserfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(reiserfs_inode_cachep);\n}\n\n \nstatic void reiserfs_dirty_inode(struct inode *inode, int flags)\n{\n\tstruct reiserfs_transaction_handle th;\n\n\tint err = 0;\n\n\tif (sb_rdonly(inode->i_sb)) {\n\t\treiserfs_warning(inode->i_sb, \"clm-6006\",\n\t\t\t\t \"writing inode %lu on readonly FS\",\n\t\t\t\t inode->i_ino);\n\t\treturn;\n\t}\n\treiserfs_write_lock(inode->i_sb);\n\n\t \n\terr = journal_begin(&th, inode->i_sb, 1);\n\tif (err)\n\t\tgoto out;\n\n\treiserfs_update_sd(&th, inode);\n\tjournal_end(&th);\n\nout:\n\treiserfs_write_unlock(inode->i_sb);\n}\n\nstatic int reiserfs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *s = root->d_sb;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tlong opts = REISERFS_SB(s)->s_mount_opt;\n\n\tif (opts & (1 << REISERFS_LARGETAIL))\n\t\tseq_puts(seq, \",tails=on\");\n\telse if (!(opts & (1 << REISERFS_SMALLTAIL)))\n\t\tseq_puts(seq, \",notail\");\n\t \n\n\tif (!(opts & (1 << REISERFS_BARRIER_FLUSH)))\n\t\tseq_puts(seq, \",barrier=none\");\n\t \n\n\tif (opts & (1 << REISERFS_ERROR_CONTINUE))\n\t\tseq_puts(seq, \",errors=continue\");\n\telse if (opts & (1 << REISERFS_ERROR_PANIC))\n\t\tseq_puts(seq, \",errors=panic\");\n\t \n\n\tif (opts & (1 << REISERFS_DATA_LOG))\n\t\tseq_puts(seq, \",data=journal\");\n\telse if (opts & (1 << REISERFS_DATA_WRITEBACK))\n\t\tseq_puts(seq, \",data=writeback\");\n\t \n\n\tif (opts & (1 << REISERFS_ATTRS))\n\t\tseq_puts(seq, \",attrs\");\n\n\tif (opts & (1 << REISERFS_XATTRS_USER))\n\t\tseq_puts(seq, \",user_xattr\");\n\n\tif (opts & (1 << REISERFS_EXPOSE_PRIVROOT))\n\t\tseq_puts(seq, \",expose_privroot\");\n\n\tif (opts & (1 << REISERFS_POSIXACL))\n\t\tseq_puts(seq, \",acl\");\n\n\tif (REISERFS_SB(s)->s_jdev)\n\t\tseq_show_option(seq, \"jdev\", REISERFS_SB(s)->s_jdev);\n\n\tif (journal->j_max_commit_age != journal->j_default_max_commit_age)\n\t\tseq_printf(seq, \",commit=%d\", journal->j_max_commit_age);\n\n#ifdef CONFIG_QUOTA\n\tif (REISERFS_SB(s)->s_qf_names[USRQUOTA])\n\t\tseq_show_option(seq, \"usrjquota\",\n\t\t\t\tREISERFS_SB(s)->s_qf_names[USRQUOTA]);\n\telse if (opts & (1 << REISERFS_USRQUOTA))\n\t\tseq_puts(seq, \",usrquota\");\n\tif (REISERFS_SB(s)->s_qf_names[GRPQUOTA])\n\t\tseq_show_option(seq, \"grpjquota\",\n\t\t\t\tREISERFS_SB(s)->s_qf_names[GRPQUOTA]);\n\telse if (opts & (1 << REISERFS_GRPQUOTA))\n\t\tseq_puts(seq, \",grpquota\");\n\tif (REISERFS_SB(s)->s_jquota_fmt) {\n\t\tif (REISERFS_SB(s)->s_jquota_fmt == QFMT_VFS_OLD)\n\t\t\tseq_puts(seq, \",jqfmt=vfsold\");\n\t\telse if (REISERFS_SB(s)->s_jquota_fmt == QFMT_VFS_V0)\n\t\t\tseq_puts(seq, \",jqfmt=vfsv0\");\n\t}\n#endif\n\n\t \n\tif (opts & (1 << REISERFS_NO_BORDER))\n\t\tseq_puts(seq, \",block-allocator=noborder\");\n\tif (opts & (1 << REISERFS_NO_UNHASHED_RELOCATION))\n\t\tseq_puts(seq, \",block-allocator=no_unhashed_relocation\");\n\tif (opts & (1 << REISERFS_HASHED_RELOCATION))\n\t\tseq_puts(seq, \",block-allocator=hashed_relocation\");\n\tif (opts & (1 << REISERFS_TEST4))\n\t\tseq_puts(seq, \",block-allocator=test4\");\n\tshow_alloc_options(seq, s);\n\treturn 0;\n}\n\n#ifdef CONFIG_QUOTA\nstatic ssize_t reiserfs_quota_write(struct super_block *, int, const char *,\n\t\t\t\t    size_t, loff_t);\nstatic ssize_t reiserfs_quota_read(struct super_block *, int, char *, size_t,\n\t\t\t\t   loff_t);\n\nstatic struct dquot **reiserfs_get_dquots(struct inode *inode)\n{\n\treturn REISERFS_I(inode)->i_dquot;\n}\n#endif\n\nstatic const struct super_operations reiserfs_sops = {\n\t.alloc_inode = reiserfs_alloc_inode,\n\t.free_inode = reiserfs_free_inode,\n\t.write_inode = reiserfs_write_inode,\n\t.dirty_inode = reiserfs_dirty_inode,\n\t.evict_inode = reiserfs_evict_inode,\n\t.put_super = reiserfs_put_super,\n\t.sync_fs = reiserfs_sync_fs,\n\t.freeze_fs = reiserfs_freeze,\n\t.unfreeze_fs = reiserfs_unfreeze,\n\t.statfs = reiserfs_statfs,\n\t.remount_fs = reiserfs_remount,\n\t.show_options = reiserfs_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read = reiserfs_quota_read,\n\t.quota_write = reiserfs_quota_write,\n\t.get_dquots = reiserfs_get_dquots,\n#endif\n};\n\n#ifdef CONFIG_QUOTA\n#define QTYPE2NAME(t) ((t)==USRQUOTA?\"user\":\"group\")\n\nstatic int reiserfs_write_dquot(struct dquot *);\nstatic int reiserfs_acquire_dquot(struct dquot *);\nstatic int reiserfs_release_dquot(struct dquot *);\nstatic int reiserfs_mark_dquot_dirty(struct dquot *);\nstatic int reiserfs_write_info(struct super_block *, int);\nstatic int reiserfs_quota_on(struct super_block *, int, int, const struct path *);\n\nstatic const struct dquot_operations reiserfs_quota_operations = {\n\t.write_dquot = reiserfs_write_dquot,\n\t.acquire_dquot = reiserfs_acquire_dquot,\n\t.release_dquot = reiserfs_release_dquot,\n\t.mark_dirty = reiserfs_mark_dquot_dirty,\n\t.write_info = reiserfs_write_info,\n\t.alloc_dquot\t= dquot_alloc,\n\t.destroy_dquot\t= dquot_destroy,\n\t.get_next_id\t= dquot_get_next_id,\n};\n\nstatic const struct quotactl_ops reiserfs_qctl_operations = {\n\t.quota_on = reiserfs_quota_on,\n\t.quota_off = reiserfs_quota_off,\n\t.quota_sync = dquot_quota_sync,\n\t.get_state = dquot_get_state,\n\t.set_info = dquot_set_dqinfo,\n\t.get_dqblk = dquot_get_dqblk,\n\t.set_dqblk = dquot_set_dqblk,\n};\n#endif\n\nstatic const struct export_operations reiserfs_export_ops = {\n\t.encode_fh = reiserfs_encode_fh,\n\t.fh_to_dentry = reiserfs_fh_to_dentry,\n\t.fh_to_parent = reiserfs_fh_to_parent,\n\t.get_parent = reiserfs_get_parent,\n};\n\n \ntypedef struct {\n\tchar *value;\n\t \n\tint setmask;\n\t \n\tint clrmask;\n} arg_desc_t;\n\n \n#define REISERFS_OPT_ALLOWEMPTY 31\n\n \ntypedef struct {\n\tchar *option_name;\n\n\t \n\tint arg_required;\n\n\t \n\tconst arg_desc_t *values;\n\n\t \n\tint setmask;\n\n\t \n\tint clrmask;\n} opt_desc_t;\n\n \nstatic const arg_desc_t logging_mode[] = {\n\t{\"ordered\", 1 << REISERFS_DATA_ORDERED,\n\t (1 << REISERFS_DATA_LOG | 1 << REISERFS_DATA_WRITEBACK)},\n\t{\"journal\", 1 << REISERFS_DATA_LOG,\n\t (1 << REISERFS_DATA_ORDERED | 1 << REISERFS_DATA_WRITEBACK)},\n\t{\"writeback\", 1 << REISERFS_DATA_WRITEBACK,\n\t (1 << REISERFS_DATA_ORDERED | 1 << REISERFS_DATA_LOG)},\n\t{.value = NULL}\n};\n\n \nstatic const arg_desc_t barrier_mode[] = {\n\t{\"none\", 1 << REISERFS_BARRIER_NONE, 1 << REISERFS_BARRIER_FLUSH},\n\t{\"flush\", 1 << REISERFS_BARRIER_FLUSH, 1 << REISERFS_BARRIER_NONE},\n\t{.value = NULL}\n};\n\n \nstatic const arg_desc_t balloc[] = {\n\t{\"noborder\", 1 << REISERFS_NO_BORDER, 0},\n\t{\"border\", 0, 1 << REISERFS_NO_BORDER},\n\t{\"no_unhashed_relocation\", 1 << REISERFS_NO_UNHASHED_RELOCATION, 0},\n\t{\"hashed_relocation\", 1 << REISERFS_HASHED_RELOCATION, 0},\n\t{\"test4\", 1 << REISERFS_TEST4, 0},\n\t{\"notest4\", 0, 1 << REISERFS_TEST4},\n\t{NULL, 0, 0}\n};\n\nstatic const arg_desc_t tails[] = {\n\t{\"on\", 1 << REISERFS_LARGETAIL, 1 << REISERFS_SMALLTAIL},\n\t{\"off\", 0, (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t{\"small\", 1 << REISERFS_SMALLTAIL, 1 << REISERFS_LARGETAIL},\n\t{NULL, 0, 0}\n};\n\nstatic const arg_desc_t error_actions[] = {\n\t{\"panic\", 1 << REISERFS_ERROR_PANIC,\n\t (1 << REISERFS_ERROR_RO | 1 << REISERFS_ERROR_CONTINUE)},\n\t{\"ro-remount\", 1 << REISERFS_ERROR_RO,\n\t (1 << REISERFS_ERROR_PANIC | 1 << REISERFS_ERROR_CONTINUE)},\n#ifdef REISERFS_JOURNAL_ERROR_ALLOWS_NO_LOG\n\t{\"continue\", 1 << REISERFS_ERROR_CONTINUE,\n\t (1 << REISERFS_ERROR_PANIC | 1 << REISERFS_ERROR_RO)},\n#endif\n\t{NULL, 0, 0},\n};\n\n \nstatic int reiserfs_getopt(struct super_block *s, char **cur, opt_desc_t * opts,\n\t\t\t   char **opt_arg, unsigned long *bit_flags)\n{\n\tchar *p;\n\t \n\tconst opt_desc_t *opt;\n\tconst arg_desc_t *arg;\n\n\tp = *cur;\n\n\t \n\t*cur = strchr(p, ',');\n\tif (*cur) {\n\t\t*(*cur) = '\\0';\n\t\t(*cur)++;\n\t}\n\n\tif (!strncmp(p, \"alloc=\", 6)) {\n\t\t \n\t\tif (reiserfs_parse_alloc_options(s, p + 6)) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tfor (opt = opts; opt->option_name; opt++) {\n\t\tif (!strncmp(p, opt->option_name, strlen(opt->option_name))) {\n\t\t\tif (bit_flags) {\n\t\t\t\tif (opt->clrmask ==\n\t\t\t\t    (1 << REISERFS_UNSUPPORTED_OPT))\n\t\t\t\t\treiserfs_warning(s, \"super-6500\",\n\t\t\t\t\t\t\t \"%s not supported.\\n\",\n\t\t\t\t\t\t\t p);\n\t\t\t\telse\n\t\t\t\t\t*bit_flags &= ~opt->clrmask;\n\t\t\t\tif (opt->setmask ==\n\t\t\t\t    (1 << REISERFS_UNSUPPORTED_OPT))\n\t\t\t\t\treiserfs_warning(s, \"super-6501\",\n\t\t\t\t\t\t\t \"%s not supported.\\n\",\n\t\t\t\t\t\t\t p);\n\t\t\t\telse\n\t\t\t\t\t*bit_flags |= opt->setmask;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!opt->option_name) {\n\t\treiserfs_warning(s, \"super-6502\",\n\t\t\t\t \"unknown mount option \\\"%s\\\"\", p);\n\t\treturn -1;\n\t}\n\n\tp += strlen(opt->option_name);\n\tswitch (*p) {\n\tcase '=':\n\t\tif (!opt->arg_required) {\n\t\t\treiserfs_warning(s, \"super-6503\",\n\t\t\t\t\t \"the option \\\"%s\\\" does not \"\n\t\t\t\t\t \"require an argument\\n\",\n\t\t\t\t\t opt->option_name);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\tif (opt->arg_required) {\n\t\t\treiserfs_warning(s, \"super-6504\",\n\t\t\t\t\t \"the option \\\"%s\\\" requires an \"\n\t\t\t\t\t \"argument\\n\", opt->option_name);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treiserfs_warning(s, \"super-6505\",\n\t\t\t\t \"head of option \\\"%s\\\" is only correct\\n\",\n\t\t\t\t opt->option_name);\n\t\treturn -1;\n\t}\n\n\t \n\tp++;\n\n\tif (opt->arg_required\n\t    && !(opt->arg_required & (1 << REISERFS_OPT_ALLOWEMPTY))\n\t    && !strlen(p)) {\n\t\t \n\t\treiserfs_warning(s, \"super-6506\",\n\t\t\t\t \"empty argument for \\\"%s\\\"\\n\",\n\t\t\t\t opt->option_name);\n\t\treturn -1;\n\t}\n\n\tif (!opt->values) {\n\t\t \n\t\t*opt_arg = p;\n\t\treturn opt->arg_required & ~(1 << REISERFS_OPT_ALLOWEMPTY);\n\t}\n\n\t \n\tfor (arg = opt->values; arg->value; arg++) {\n\t\tif (!strcmp(p, arg->value)) {\n\t\t\tif (bit_flags) {\n\t\t\t\t*bit_flags &= ~arg->clrmask;\n\t\t\t\t*bit_flags |= arg->setmask;\n\t\t\t}\n\t\t\treturn opt->arg_required;\n\t\t}\n\t}\n\n\treiserfs_warning(s, \"super-6506\",\n\t\t\t \"bad value \\\"%s\\\" for option \\\"%s\\\"\\n\", p,\n\t\t\t opt->option_name);\n\treturn -1;\n}\n\n \nstatic int reiserfs_parse_options(struct super_block *s,\n\n\t\t\t\t   \n\t\t\t\t  char *options,\n\n\t\t\t\t   \n\t\t\t\t  unsigned long *mount_options,\n\n\t\t\t\t   \n\t\t\t\t  unsigned long *blocks,\n\t\t\t\t  char **jdev_name,\n\t\t\t\t  unsigned int *commit_max_age,\n\t\t\t\t  char **qf_names,\n\t\t\t\t  unsigned int *qfmt)\n{\n\tint c;\n\tchar *arg = NULL;\n\tchar *pos;\n\topt_desc_t opts[] = {\n\t\t \n\t\t{\"tails\",.arg_required = 't',.values = tails},\n\t\t{\"notail\",.clrmask =\n\t\t (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t\t{\"conv\",.setmask = 1 << REISERFS_CONVERT},\n\t\t{\"attrs\",.setmask = 1 << REISERFS_ATTRS},\n\t\t{\"noattrs\",.clrmask = 1 << REISERFS_ATTRS},\n\t\t{\"expose_privroot\", .setmask = 1 << REISERFS_EXPOSE_PRIVROOT},\n#ifdef CONFIG_REISERFS_FS_XATTR\n\t\t{\"user_xattr\",.setmask = 1 << REISERFS_XATTRS_USER},\n\t\t{\"nouser_xattr\",.clrmask = 1 << REISERFS_XATTRS_USER},\n#else\n\t\t{\"user_xattr\",.setmask = 1 << REISERFS_UNSUPPORTED_OPT},\n\t\t{\"nouser_xattr\",.clrmask = 1 << REISERFS_UNSUPPORTED_OPT},\n#endif\n#ifdef CONFIG_REISERFS_FS_POSIX_ACL\n\t\t{\"acl\",.setmask = 1 << REISERFS_POSIXACL},\n\t\t{\"noacl\",.clrmask = 1 << REISERFS_POSIXACL},\n#else\n\t\t{\"acl\",.setmask = 1 << REISERFS_UNSUPPORTED_OPT},\n\t\t{\"noacl\",.clrmask = 1 << REISERFS_UNSUPPORTED_OPT},\n#endif\n\t\t{.option_name = \"nolog\"},\n\t\t{\"replayonly\",.setmask = 1 << REPLAYONLY},\n\t\t{\"block-allocator\",.arg_required = 'a',.values = balloc},\n\t\t{\"data\",.arg_required = 'd',.values = logging_mode},\n\t\t{\"barrier\",.arg_required = 'b',.values = barrier_mode},\n\t\t{\"resize\",.arg_required = 'r',.values = NULL},\n\t\t{\"jdev\",.arg_required = 'j',.values = NULL},\n\t\t{\"nolargeio\",.arg_required = 'w',.values = NULL},\n\t\t{\"commit\",.arg_required = 'c',.values = NULL},\n\t\t{\"usrquota\",.setmask = 1 << REISERFS_USRQUOTA},\n\t\t{\"grpquota\",.setmask = 1 << REISERFS_GRPQUOTA},\n\t\t{\"noquota\",.clrmask = 1 << REISERFS_USRQUOTA | 1 << REISERFS_GRPQUOTA},\n\t\t{\"errors\",.arg_required = 'e',.values = error_actions},\n\t\t{\"usrjquota\",.arg_required =\n\t\t 'u' | (1 << REISERFS_OPT_ALLOWEMPTY),.values = NULL},\n\t\t{\"grpjquota\",.arg_required =\n\t\t 'g' | (1 << REISERFS_OPT_ALLOWEMPTY),.values = NULL},\n\t\t{\"jqfmt\",.arg_required = 'f',.values = NULL},\n\t\t{.option_name = NULL}\n\t};\n\n\t*blocks = 0;\n\tif (!options || !*options)\n\t\t \n\t\treturn 1;\n\n\tfor (pos = options; pos;) {\n\t\tc = reiserfs_getopt(s, &pos, opts, &arg, mount_options);\n\t\tif (c == -1)\n\t\t\t \n\t\t\treturn 0;\n\n\t\tif (c == 'r') {\n\t\t\tchar *p;\n\n\t\t\tp = NULL;\n\t\t\t \n\n\t\t\tif (!strcmp(arg, \"auto\")) {\n\t\t\t\t \n\t\t\t\t*blocks = sb_bdev_nr_blocks(s);\n\t\t\t} else {\n\t\t\t\t*blocks = simple_strtoul(arg, &p, 0);\n\t\t\t\tif (*p != '\\0') {\n\t\t\t\t\t \n\t\t\t\t\treiserfs_warning(s, \"super-6507\",\n\t\t\t\t\t\t\t \"bad value %s for \"\n\t\t\t\t\t\t\t \"-oresize\\n\", arg);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (c == 'c') {\n\t\t\tchar *p = NULL;\n\t\t\tunsigned long val = simple_strtoul(arg, &p, 0);\n\t\t\t \n\t\t\tif (*p != '\\0' || val >= (unsigned int)-1) {\n\t\t\t\treiserfs_warning(s, \"super-6508\",\n\t\t\t\t\t\t \"bad value %s for -ocommit\\n\",\n\t\t\t\t\t\t arg);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*commit_max_age = (unsigned int)val;\n\t\t}\n\n\t\tif (c == 'w') {\n\t\t\treiserfs_warning(s, \"super-6509\", \"nolargeio option \"\n\t\t\t\t\t \"is no longer supported\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (c == 'j') {\n\t\t\tif (arg && *arg && jdev_name) {\n\t\t\t\t \n\t\t\t\tif (*jdev_name) {\n\t\t\t\t\treiserfs_warning(s, \"super-6510\",\n\t\t\t\t\t\t\t \"journal device was \"\n\t\t\t\t\t\t\t \"already specified to \"\n\t\t\t\t\t\t\t \"be %s\", *jdev_name);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*jdev_name = arg;\n\t\t\t}\n\t\t}\n#ifdef CONFIG_QUOTA\n\t\tif (c == 'u' || c == 'g') {\n\t\t\tint qtype = c == 'u' ? USRQUOTA : GRPQUOTA;\n\n\t\t\tif (sb_any_quota_loaded(s) &&\n\t\t\t    (!*arg != !REISERFS_SB(s)->s_qf_names[qtype])) {\n\t\t\t\treiserfs_warning(s, \"super-6511\",\n\t\t\t\t\t\t \"cannot change journaled \"\n\t\t\t\t\t\t \"quota options when quota \"\n\t\t\t\t\t\t \"turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (qf_names[qtype] !=\n\t\t\t    REISERFS_SB(s)->s_qf_names[qtype])\n\t\t\t\tkfree(qf_names[qtype]);\n\t\t\tqf_names[qtype] = NULL;\n\t\t\tif (*arg) {\t \n\t\t\t\tif (REISERFS_SB(s)->s_qf_names[qtype]\n\t\t\t\t    && strcmp(REISERFS_SB(s)->s_qf_names[qtype],\n\t\t\t\t\t      arg)) {\n\t\t\t\t\treiserfs_warning(s, \"super-6512\",\n\t\t\t\t\t\t\t \"%s quota file \"\n\t\t\t\t\t\t\t \"already specified.\",\n\t\t\t\t\t\t\t QTYPE2NAME(qtype));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (strchr(arg, '/')) {\n\t\t\t\t\treiserfs_warning(s, \"super-6513\",\n\t\t\t\t\t\t\t \"quotafile must be \"\n\t\t\t\t\t\t\t \"on filesystem root.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tqf_names[qtype] = kstrdup(arg, GFP_KERNEL);\n\t\t\t\tif (!qf_names[qtype]) {\n\t\t\t\t\treiserfs_warning(s, \"reiserfs-2502\",\n\t\t\t\t\t\t\t \"not enough memory \"\n\t\t\t\t\t\t\t \"for storing \"\n\t\t\t\t\t\t\t \"quotafile name.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (qtype == USRQUOTA)\n\t\t\t\t\t*mount_options |= 1 << REISERFS_USRQUOTA;\n\t\t\t\telse\n\t\t\t\t\t*mount_options |= 1 << REISERFS_GRPQUOTA;\n\t\t\t} else {\n\t\t\t\tif (qtype == USRQUOTA)\n\t\t\t\t\t*mount_options &= ~(1 << REISERFS_USRQUOTA);\n\t\t\t\telse\n\t\t\t\t\t*mount_options &= ~(1 << REISERFS_GRPQUOTA);\n\t\t\t}\n\t\t}\n\t\tif (c == 'f') {\n\t\t\tif (!strcmp(arg, \"vfsold\"))\n\t\t\t\t*qfmt = QFMT_VFS_OLD;\n\t\t\telse if (!strcmp(arg, \"vfsv0\"))\n\t\t\t\t*qfmt = QFMT_VFS_V0;\n\t\t\telse {\n\t\t\t\treiserfs_warning(s, \"super-6514\",\n\t\t\t\t\t\t \"unknown quota format \"\n\t\t\t\t\t\t \"specified.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sb_any_quota_loaded(s) &&\n\t\t\t    *qfmt != REISERFS_SB(s)->s_jquota_fmt) {\n\t\t\t\treiserfs_warning(s, \"super-6515\",\n\t\t\t\t\t\t \"cannot change journaled \"\n\t\t\t\t\t\t \"quota options when quota \"\n\t\t\t\t\t\t \"turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n#else\n\t\tif (c == 'u' || c == 'g' || c == 'f') {\n\t\t\treiserfs_warning(s, \"reiserfs-2503\", \"journaled \"\n\t\t\t\t\t \"quota options not supported.\");\n\t\t\treturn 0;\n\t\t}\n#endif\n\t}\n\n#ifdef CONFIG_QUOTA\n\tif (!REISERFS_SB(s)->s_jquota_fmt && !*qfmt\n\t    && (qf_names[USRQUOTA] || qf_names[GRPQUOTA])) {\n\t\treiserfs_warning(s, \"super-6515\",\n\t\t\t\t \"journaled quota format not specified.\");\n\t\treturn 0;\n\t}\n\tif ((!(*mount_options & (1 << REISERFS_USRQUOTA)) &&\n\t       sb_has_quota_loaded(s, USRQUOTA)) ||\n\t    (!(*mount_options & (1 << REISERFS_GRPQUOTA)) &&\n\t       sb_has_quota_loaded(s, GRPQUOTA))) {\n\t\treiserfs_warning(s, \"super-6516\", \"quota options must \"\n\t\t\t\t \"be present when quota is turned on.\");\n\t\treturn 0;\n\t}\n#endif\n\n\treturn 1;\n}\n\nstatic void switch_data_mode(struct super_block *s, unsigned long mode)\n{\n\tREISERFS_SB(s)->s_mount_opt &= ~((1 << REISERFS_DATA_LOG) |\n\t\t\t\t\t (1 << REISERFS_DATA_ORDERED) |\n\t\t\t\t\t (1 << REISERFS_DATA_WRITEBACK));\n\tREISERFS_SB(s)->s_mount_opt |= (1 << mode);\n}\n\nstatic void handle_data_mode(struct super_block *s, unsigned long mount_options)\n{\n\tif (mount_options & (1 << REISERFS_DATA_LOG)) {\n\t\tif (!reiserfs_data_log(s)) {\n\t\t\tswitch_data_mode(s, REISERFS_DATA_LOG);\n\t\t\treiserfs_info(s, \"switching to journaled data mode\\n\");\n\t\t}\n\t} else if (mount_options & (1 << REISERFS_DATA_ORDERED)) {\n\t\tif (!reiserfs_data_ordered(s)) {\n\t\t\tswitch_data_mode(s, REISERFS_DATA_ORDERED);\n\t\t\treiserfs_info(s, \"switching to ordered data mode\\n\");\n\t\t}\n\t} else if (mount_options & (1 << REISERFS_DATA_WRITEBACK)) {\n\t\tif (!reiserfs_data_writeback(s)) {\n\t\t\tswitch_data_mode(s, REISERFS_DATA_WRITEBACK);\n\t\t\treiserfs_info(s, \"switching to writeback data mode\\n\");\n\t\t}\n\t}\n}\n\nstatic void handle_barrier_mode(struct super_block *s, unsigned long bits)\n{\n\tint flush = (1 << REISERFS_BARRIER_FLUSH);\n\tint none = (1 << REISERFS_BARRIER_NONE);\n\tint all_barrier = flush | none;\n\n\tif (bits & all_barrier) {\n\t\tREISERFS_SB(s)->s_mount_opt &= ~all_barrier;\n\t\tif (bits & flush) {\n\t\t\tREISERFS_SB(s)->s_mount_opt |= flush;\n\t\t\tprintk(\"reiserfs: enabling write barrier flush mode\\n\");\n\t\t} else if (bits & none) {\n\t\t\tREISERFS_SB(s)->s_mount_opt |= none;\n\t\t\tprintk(\"reiserfs: write barriers turned off\\n\");\n\t\t}\n\t}\n}\n\nstatic void handle_attrs(struct super_block *s)\n{\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\n\tif (reiserfs_attrs(s)) {\n\t\tif (old_format_only(s)) {\n\t\t\treiserfs_warning(s, \"super-6517\", \"cannot support \"\n\t\t\t\t\t \"attributes on 3.5.x disk format\");\n\t\t\tREISERFS_SB(s)->s_mount_opt &= ~(1 << REISERFS_ATTRS);\n\t\t\treturn;\n\t\t}\n\t\tif (!(le32_to_cpu(rs->s_flags) & reiserfs_attrs_cleared)) {\n\t\t\treiserfs_warning(s, \"super-6518\", \"cannot support \"\n\t\t\t\t\t \"attributes until flag is set in \"\n\t\t\t\t\t \"super-block\");\n\t\t\tREISERFS_SB(s)->s_mount_opt &= ~(1 << REISERFS_ATTRS);\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_QUOTA\nstatic void handle_quota_files(struct super_block *s, char **qf_names,\n\t\t\t       unsigned int *qfmt)\n{\n\tint i;\n\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tif (qf_names[i] != REISERFS_SB(s)->s_qf_names[i])\n\t\t\tkfree(REISERFS_SB(s)->s_qf_names[i]);\n\t\tREISERFS_SB(s)->s_qf_names[i] = qf_names[i];\n\t}\n\tif (*qfmt)\n\t\tREISERFS_SB(s)->s_jquota_fmt = *qfmt;\n}\n#endif\n\nstatic int reiserfs_remount(struct super_block *s, int *mount_flags, char *arg)\n{\n\tstruct reiserfs_super_block *rs;\n\tstruct reiserfs_transaction_handle th;\n\tunsigned long blocks;\n\tunsigned long mount_options = REISERFS_SB(s)->s_mount_opt;\n\tunsigned long safe_mask = 0;\n\tunsigned int commit_max_age = (unsigned int)-1;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint err;\n\tchar *qf_names[REISERFS_MAXQUOTAS];\n\tunsigned int qfmt = 0;\n#ifdef CONFIG_QUOTA\n\tint i;\n#endif\n\n\tsync_filesystem(s);\n\treiserfs_write_lock(s);\n\n#ifdef CONFIG_QUOTA\n\tmemcpy(qf_names, REISERFS_SB(s)->s_qf_names, sizeof(qf_names));\n#endif\n\n\trs = SB_DISK_SUPER_BLOCK(s);\n\n\tif (!reiserfs_parse_options\n\t    (s, arg, &mount_options, &blocks, NULL, &commit_max_age,\n\t    qf_names, &qfmt)) {\n#ifdef CONFIG_QUOTA\n\t\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++)\n\t\t\tif (qf_names[i] != REISERFS_SB(s)->s_qf_names[i])\n\t\t\t\tkfree(qf_names[i]);\n#endif\n\t\terr = -EINVAL;\n\t\tgoto out_err_unlock;\n\t}\n#ifdef CONFIG_QUOTA\n\thandle_quota_files(s, qf_names, &qfmt);\n#endif\n\n\thandle_attrs(s);\n\n\t \n\tsafe_mask |= 1 << REISERFS_SMALLTAIL;\n\tsafe_mask |= 1 << REISERFS_LARGETAIL;\n\tsafe_mask |= 1 << REISERFS_NO_BORDER;\n\tsafe_mask |= 1 << REISERFS_NO_UNHASHED_RELOCATION;\n\tsafe_mask |= 1 << REISERFS_HASHED_RELOCATION;\n\tsafe_mask |= 1 << REISERFS_TEST4;\n\tsafe_mask |= 1 << REISERFS_ATTRS;\n\tsafe_mask |= 1 << REISERFS_XATTRS_USER;\n\tsafe_mask |= 1 << REISERFS_POSIXACL;\n\tsafe_mask |= 1 << REISERFS_BARRIER_FLUSH;\n\tsafe_mask |= 1 << REISERFS_BARRIER_NONE;\n\tsafe_mask |= 1 << REISERFS_ERROR_RO;\n\tsafe_mask |= 1 << REISERFS_ERROR_CONTINUE;\n\tsafe_mask |= 1 << REISERFS_ERROR_PANIC;\n\tsafe_mask |= 1 << REISERFS_USRQUOTA;\n\tsafe_mask |= 1 << REISERFS_GRPQUOTA;\n\n\t \n\tREISERFS_SB(s)->s_mount_opt =\n\t    (REISERFS_SB(s)->\n\t     s_mount_opt & ~safe_mask) | (mount_options & safe_mask);\n\n\tif (commit_max_age != 0 && commit_max_age != (unsigned int)-1) {\n\t\tjournal->j_max_commit_age = commit_max_age;\n\t\tjournal->j_max_trans_age = commit_max_age;\n\t} else if (commit_max_age == 0) {\n\t\t \n\t\tjournal->j_max_commit_age = journal->j_default_max_commit_age;\n\t\tjournal->j_max_trans_age = JOURNAL_MAX_TRANS_AGE;\n\t}\n\n\tif (blocks) {\n\t\terr = reiserfs_resize(s, blocks);\n\t\tif (err != 0)\n\t\t\tgoto out_err_unlock;\n\t}\n\n\tif (*mount_flags & SB_RDONLY) {\n\t\treiserfs_write_unlock(s);\n\t\treiserfs_xattr_init(s, *mount_flags);\n\t\t \n\t\tif (sb_rdonly(s))\n\t\t\t \n\t\t\tgoto out_ok_unlocked;\n\n\t\terr = dquot_suspend(s, -1);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\n\t\t \n\t\tif (sb_umount_state(rs) == REISERFS_VALID_FS\n\t\t    || REISERFS_SB(s)->s_mount_state != REISERFS_VALID_FS) {\n\t\t\tgoto out_ok_unlocked;\n\t\t}\n\n\t\treiserfs_write_lock(s);\n\n\t\terr = journal_begin(&th, s, 10);\n\t\tif (err)\n\t\t\tgoto out_err_unlock;\n\n\t\t \n\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\t\tset_sb_umount_state(rs, REISERFS_SB(s)->s_mount_state);\n\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\t} else {\n\t\t \n\t\tif (!sb_rdonly(s)) {\n\t\t\treiserfs_write_unlock(s);\n\t\t\treiserfs_xattr_init(s, *mount_flags);\n\t\t\tgoto out_ok_unlocked;\t \n\t\t}\n\n\t\tif (reiserfs_is_journal_aborted(journal)) {\n\t\t\terr = journal->j_errno;\n\t\t\tgoto out_err_unlock;\n\t\t}\n\n\t\thandle_data_mode(s, mount_options);\n\t\thandle_barrier_mode(s, mount_options);\n\t\tREISERFS_SB(s)->s_mount_state = sb_umount_state(rs);\n\n\t\t \n\t\ts->s_flags &= ~SB_RDONLY;\n\t\terr = journal_begin(&th, s, 10);\n\t\tif (err)\n\t\t\tgoto out_err_unlock;\n\n\t\t \n\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\t\tREISERFS_SB(s)->s_mount_state = sb_umount_state(rs);\n\t\ts->s_flags &= ~SB_RDONLY;\n\t\tset_sb_umount_state(rs, REISERFS_ERROR_FS);\n\t\tif (!old_format_only(s))\n\t\t\tset_sb_mnt_count(rs, sb_mnt_count(rs) + 1);\n\t\t \n\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\t\tREISERFS_SB(s)->s_mount_state = REISERFS_VALID_FS;\n\t}\n\t \n\tSB_JOURNAL(s)->j_must_wait = 1;\n\terr = journal_end(&th);\n\tif (err)\n\t\tgoto out_err_unlock;\n\n\treiserfs_write_unlock(s);\n\tif (!(*mount_flags & SB_RDONLY)) {\n\t\tdquot_resume(s, -1);\n\t\treiserfs_write_lock(s);\n\t\tfinish_unfinished(s);\n\t\treiserfs_write_unlock(s);\n\t\treiserfs_xattr_init(s, *mount_flags);\n\t}\n\nout_ok_unlocked:\n\treturn 0;\n\nout_err_unlock:\n\treiserfs_write_unlock(s);\nout_err:\n\treturn err;\n}\n\nstatic int read_super_block(struct super_block *s, int offset)\n{\n\tstruct buffer_head *bh;\n\tstruct reiserfs_super_block *rs;\n\tint fs_blocksize;\n\n\tbh = sb_bread(s, offset / s->s_blocksize);\n\tif (!bh) {\n\t\treiserfs_warning(s, \"sh-2006\",\n\t\t\t\t \"bread failed (dev %s, block %lu, size %lu)\",\n\t\t\t\t s->s_id, offset / s->s_blocksize,\n\t\t\t\t s->s_blocksize);\n\t\treturn 1;\n\t}\n\n\trs = (struct reiserfs_super_block *)bh->b_data;\n\tif (!is_any_reiserfs_magic_string(rs)) {\n\t\tbrelse(bh);\n\t\treturn 1;\n\t}\n\t \n\tfs_blocksize = sb_blocksize(rs);\n\tbrelse(bh);\n\tsb_set_blocksize(s, fs_blocksize);\n\n\tbh = sb_bread(s, offset / s->s_blocksize);\n\tif (!bh) {\n\t\treiserfs_warning(s, \"sh-2007\",\n\t\t\t\t \"bread failed (dev %s, block %lu, size %lu)\",\n\t\t\t\t s->s_id, offset / s->s_blocksize,\n\t\t\t\t s->s_blocksize);\n\t\treturn 1;\n\t}\n\n\trs = (struct reiserfs_super_block *)bh->b_data;\n\tif (sb_blocksize(rs) != s->s_blocksize) {\n\t\treiserfs_warning(s, \"sh-2011\", \"can't find a reiserfs \"\n\t\t\t\t \"filesystem on (dev %s, block %llu, size %lu)\",\n\t\t\t\t s->s_id,\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t s->s_blocksize);\n\t\tbrelse(bh);\n\t\treturn 1;\n\t}\n\n\tif (rs->s_v1.s_root_block == cpu_to_le32(-1)) {\n\t\tbrelse(bh);\n\t\treiserfs_warning(s, \"super-6519\", \"Unfinished reiserfsck \"\n\t\t\t\t \"--rebuild-tree run detected. Please run\\n\"\n\t\t\t\t \"reiserfsck --rebuild-tree and wait for a \"\n\t\t\t\t \"completion. If that fails\\n\"\n\t\t\t\t \"get newer reiserfsprogs package\");\n\t\treturn 1;\n\t}\n\n\treiserfs_warning(NULL, \"\", \"reiserfs filesystem is deprecated and \"\n\t\t\"scheduled to be removed from the kernel in 2025\");\n\tSB_BUFFER_WITH_SB(s) = bh;\n\tSB_DISK_SUPER_BLOCK(s) = rs;\n\n\t \n\tif (is_reiserfs_jr(rs)) {\n\t\tif (sb_version(rs) == REISERFS_VERSION_2)\n\t\t\treiserfs_info(s, \"found reiserfs format \\\"3.6\\\"\"\n\t\t\t\t      \" with non-standard journal\\n\");\n\t\telse if (sb_version(rs) == REISERFS_VERSION_1)\n\t\t\treiserfs_info(s, \"found reiserfs format \\\"3.5\\\"\"\n\t\t\t\t      \" with non-standard journal\\n\");\n\t\telse {\n\t\t\treiserfs_warning(s, \"sh-2012\", \"found unknown \"\n\t\t\t\t\t \"format \\\"%u\\\" of reiserfs with \"\n\t\t\t\t\t \"non-standard magic\", sb_version(rs));\n\t\t\treturn 1;\n\t\t}\n\t} else\n\t\t \n\t\treiserfs_info(s,\n\t\t\t      \"found reiserfs format \\\"%s\\\" with standard journal\\n\",\n\t\t\t      is_reiserfs_3_5(rs) ? \"3.5\" : \"3.6\");\n\n\ts->s_op = &reiserfs_sops;\n\ts->s_export_op = &reiserfs_export_ops;\n#ifdef CONFIG_QUOTA\n\ts->s_qcop = &reiserfs_qctl_operations;\n\ts->dq_op = &reiserfs_quota_operations;\n\ts->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n#endif\n\n\t \n\ts->s_maxbytes = (512LL << 32) - s->s_blocksize;\n\treturn 0;\n}\n\n \nstatic int reread_meta_blocks(struct super_block *s)\n{\n\tif (bh_read(SB_BUFFER_WITH_SB(s), 0) < 0) {\n\t\treiserfs_warning(s, \"reiserfs-2504\", \"error reading the super\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic __u32 find_hash_out(struct super_block *s)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct cpu_key key;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tstruct reiserfs_de_head *deh;\n\t__u32 hash = DEFAULT_HASH;\n\t__u32 deh_hashval, teahash, r5hash, yurahash;\n\n\tinode = d_inode(s->s_root);\n\n\tmake_cpu_key(&key, inode, ~0, TYPE_DIRENTRY, 3);\n\tretval = search_by_entry_key(s, &key, &path, &de);\n\tif (retval == IO_ERROR) {\n\t\tpathrelse(&path);\n\t\treturn UNSET_HASH;\n\t}\n\tif (retval == NAME_NOT_FOUND)\n\t\tde.de_entry_num--;\n\n\tset_de_name_and_namelen(&de);\n\tdeh = de.de_deh + de.de_entry_num;\n\n\tif (deh_offset(deh) == DOT_DOT_OFFSET) {\n\t\t \n\t\tif (reiserfs_rupasov_hash(s))\n\t\t\thash = YURA_HASH;\n\t\treiserfs_info(s, \"FS seems to be empty, autodetect is using the default hash\\n\");\n\t\tgoto out;\n\t}\n\n\tdeh_hashval = GET_HASH_VALUE(deh_offset(deh));\n\tr5hash = GET_HASH_VALUE(r5_hash(de.de_name, de.de_namelen));\n\tteahash = GET_HASH_VALUE(keyed_hash(de.de_name, de.de_namelen));\n\tyurahash = GET_HASH_VALUE(yura_hash(de.de_name, de.de_namelen));\n\n\tif ((teahash == r5hash && deh_hashval == r5hash) ||\n\t    (teahash == yurahash && deh_hashval == yurahash) ||\n\t    (r5hash == yurahash && deh_hashval == yurahash)) {\n\t\treiserfs_warning(s, \"reiserfs-2506\",\n\t\t\t\t \"Unable to automatically detect hash \"\n\t\t\t\t \"function. Please mount with -o \"\n\t\t\t\t \"hash={tea,rupasov,r5}\");\n\t\thash = UNSET_HASH;\n\t\tgoto out;\n\t}\n\n\tif (deh_hashval == yurahash)\n\t\thash = YURA_HASH;\n\telse if (deh_hashval == teahash)\n\t\thash = TEA_HASH;\n\telse if (deh_hashval == r5hash)\n\t\thash = R5_HASH;\n\telse {\n\t\treiserfs_warning(s, \"reiserfs-2506\",\n\t\t\t\t \"Unrecognised hash function\");\n\t\thash = UNSET_HASH;\n\t}\nout:\n\tpathrelse(&path);\n\treturn hash;\n}\n\n \nstatic int what_hash(struct super_block *s)\n{\n\t__u32 code;\n\n\tcode = sb_hash_function_code(SB_DISK_SUPER_BLOCK(s));\n\n\t \n\tif (code == UNSET_HASH || reiserfs_hash_detect(s))\n\t\tcode = find_hash_out(s);\n\n\tif (code != UNSET_HASH && reiserfs_hash_detect(s)) {\n\t\t \n\t\tif (reiserfs_rupasov_hash(s) && code != YURA_HASH) {\n\t\t\treiserfs_warning(s, \"reiserfs-2507\",\n\t\t\t\t\t \"Error, %s hash detected, \"\n\t\t\t\t\t \"unable to force rupasov hash\",\n\t\t\t\t\t reiserfs_hashname(code));\n\t\t\tcode = UNSET_HASH;\n\t\t} else if (reiserfs_tea_hash(s) && code != TEA_HASH) {\n\t\t\treiserfs_warning(s, \"reiserfs-2508\",\n\t\t\t\t\t \"Error, %s hash detected, \"\n\t\t\t\t\t \"unable to force tea hash\",\n\t\t\t\t\t reiserfs_hashname(code));\n\t\t\tcode = UNSET_HASH;\n\t\t} else if (reiserfs_r5_hash(s) && code != R5_HASH) {\n\t\t\treiserfs_warning(s, \"reiserfs-2509\",\n\t\t\t\t\t \"Error, %s hash detected, \"\n\t\t\t\t\t \"unable to force r5 hash\",\n\t\t\t\t\t reiserfs_hashname(code));\n\t\t\tcode = UNSET_HASH;\n\t\t}\n\t} else {\n\t\t \n\t\tif (reiserfs_rupasov_hash(s)) {\n\t\t\tcode = YURA_HASH;\n\t\t} else if (reiserfs_tea_hash(s)) {\n\t\t\tcode = TEA_HASH;\n\t\t} else if (reiserfs_r5_hash(s)) {\n\t\t\tcode = R5_HASH;\n\t\t}\n\t}\n\n\t \n\tif (code != UNSET_HASH &&\n\t    !sb_rdonly(s) &&\n\t    code != sb_hash_function_code(SB_DISK_SUPER_BLOCK(s))) {\n\t\tset_sb_hash_function_code(SB_DISK_SUPER_BLOCK(s), code);\n\t}\n\treturn code;\n}\n\n \nstatic hashf_t hash_function(struct super_block *s)\n{\n\tswitch (what_hash(s)) {\n\tcase TEA_HASH:\n\t\treiserfs_info(s, \"Using tea hash to sort names\\n\");\n\t\treturn keyed_hash;\n\tcase YURA_HASH:\n\t\treiserfs_info(s, \"Using rupasov hash to sort names\\n\");\n\t\treturn yura_hash;\n\tcase R5_HASH:\n\t\treiserfs_info(s, \"Using r5 hash to sort names\\n\");\n\t\treturn r5_hash;\n\t}\n\treturn NULL;\n}\n\n \nstatic int function2code(hashf_t func)\n{\n\tif (func == keyed_hash)\n\t\treturn TEA_HASH;\n\tif (func == yura_hash)\n\t\treturn YURA_HASH;\n\tif (func == r5_hash)\n\t\treturn R5_HASH;\n\n\tBUG();\t\t\t \n\n\treturn 0;\n}\n\n#define SWARN(silent, s, id, ...)\t\t\t\\\n\tif (!(silent))\t\t\t\t\\\n\t\treiserfs_warning(s, id, __VA_ARGS__)\n\nstatic int reiserfs_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct inode *root_inode;\n\tstruct reiserfs_transaction_handle th;\n\tint old_format = 0;\n\tunsigned long blocks;\n\tunsigned int commit_max_age = 0;\n\tint jinit_done = 0;\n\tstruct reiserfs_iget_args args;\n\tstruct reiserfs_super_block *rs;\n\tchar *jdev_name;\n\tstruct reiserfs_sb_info *sbi;\n\tint errval = -EINVAL;\n\tchar *qf_names[REISERFS_MAXQUOTAS] = {};\n\tunsigned int qfmt = 0;\n\n\tsbi = kzalloc(sizeof(struct reiserfs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = sbi;\n\t \n\tsbi->s_mount_opt |= (1 << REISERFS_SMALLTAIL);\n\tsbi->s_mount_opt |= (1 << REISERFS_ERROR_RO);\n\tsbi->s_mount_opt |= (1 << REISERFS_BARRIER_FLUSH);\n\t \n\tsbi->s_alloc_options.preallocmin = 0;\n\t \n\tsbi->s_alloc_options.preallocsize = 17;\n\t \n\treiserfs_init_alloc_options(s);\n\n\tspin_lock_init(&sbi->old_work_lock);\n\tINIT_DELAYED_WORK(&sbi->old_work, flush_old_commits);\n\tmutex_init(&sbi->lock);\n\tsbi->lock_depth = -1;\n\n\tsbi->commit_wq = alloc_workqueue(\"reiserfs/%s\", WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t s->s_id);\n\tif (!sbi->commit_wq) {\n\t\tSWARN(silent, s, \"\", \"Cannot allocate commit workqueue\");\n\t\terrval = -ENOMEM;\n\t\tgoto error_unlocked;\n\t}\n\n\tjdev_name = NULL;\n\tif (reiserfs_parse_options\n\t    (s, (char *)data, &sbi->s_mount_opt, &blocks, &jdev_name,\n\t     &commit_max_age, qf_names, &qfmt) == 0) {\n\t\tgoto error_unlocked;\n\t}\n\tif (jdev_name && jdev_name[0]) {\n\t\tsbi->s_jdev = kstrdup(jdev_name, GFP_KERNEL);\n\t\tif (!sbi->s_jdev) {\n\t\t\tSWARN(silent, s, \"\", \"Cannot allocate memory for \"\n\t\t\t\t\"journal device name\");\n\t\t\tgoto error_unlocked;\n\t\t}\n\t}\n#ifdef CONFIG_QUOTA\n\thandle_quota_files(s, qf_names, &qfmt);\n#endif\n\n\tif (blocks) {\n\t\tSWARN(silent, s, \"jmacd-7\", \"resize option for remount only\");\n\t\tgoto error_unlocked;\n\t}\n\n\t \n\tif (!read_super_block(s, REISERFS_OLD_DISK_OFFSET_IN_BYTES))\n\t\told_format = 1;\n\n\t \n\telse if (read_super_block(s, REISERFS_DISK_OFFSET_IN_BYTES)) {\n\t\tSWARN(silent, s, \"sh-2021\", \"can not find reiserfs on %s\",\n\t\t      s->s_id);\n\t\tgoto error_unlocked;\n\t}\n\n\ts->s_time_min = 0;\n\ts->s_time_max = U32_MAX;\n\n\trs = SB_DISK_SUPER_BLOCK(s);\n\t \n\tif (bdev_nr_bytes(s->s_bdev) < sb_block_count(rs) * sb_blocksize(rs)) {\n\t\tSWARN(silent, s, \"\", \"Filesystem cannot be \"\n\t\t      \"mounted because it is bigger than the device\");\n\t\tSWARN(silent, s, \"\", \"You may need to run fsck \"\n\t\t      \"or increase size of your LVM partition\");\n\t\tSWARN(silent, s, \"\", \"Or may be you forgot to \"\n\t\t      \"reboot after fdisk when it told you to\");\n\t\tgoto error_unlocked;\n\t}\n\n\tsbi->s_mount_state = SB_REISERFS_STATE(s);\n\tsbi->s_mount_state = REISERFS_VALID_FS;\n\n\tif ((errval = reiserfs_init_bitmap_cache(s))) {\n\t\tSWARN(silent, s, \"jmacd-8\", \"unable to read bitmap\");\n\t\tgoto error_unlocked;\n\t}\n\n\terrval = -EINVAL;\n#ifdef CONFIG_REISERFS_CHECK\n\tSWARN(silent, s, \"\", \"CONFIG_REISERFS_CHECK is set ON\");\n\tSWARN(silent, s, \"\", \"- it is slow mode for debugging.\");\n#endif\n\n\t \n\tif (!reiserfs_data_log(s) && !reiserfs_data_ordered(s) &&\n\t    !reiserfs_data_writeback(s)) {\n\t\tsbi->s_mount_opt |= (1 << REISERFS_DATA_ORDERED);\n\t}\n\n\tif (reiserfs_data_log(s)) {\n\t\treiserfs_info(s, \"using journaled data mode\\n\");\n\t} else if (reiserfs_data_ordered(s)) {\n\t\treiserfs_info(s, \"using ordered data mode\\n\");\n\t} else {\n\t\treiserfs_info(s, \"using writeback data mode\\n\");\n\t}\n\tif (reiserfs_barrier_flush(s)) {\n\t\tprintk(\"reiserfs: using flush barriers\\n\");\n\t}\n\n\tif (journal_init(s, jdev_name, old_format, commit_max_age)) {\n\t\tSWARN(silent, s, \"sh-2022\",\n\t\t      \"unable to initialize journal space\");\n\t\tgoto error_unlocked;\n\t} else {\n\t\t \n\t\tjinit_done = 1;\n\t}\n\n\tif (reread_meta_blocks(s)) {\n\t\tSWARN(silent, s, \"jmacd-9\",\n\t\t      \"unable to reread meta blocks after journal init\");\n\t\tgoto error_unlocked;\n\t}\n\n\tif (replay_only(s))\n\t\tgoto error_unlocked;\n\n\ts->s_xattr = reiserfs_xattr_handlers;\n\n\tif (bdev_read_only(s->s_bdev) && !sb_rdonly(s)) {\n\t\tSWARN(silent, s, \"clm-7000\",\n\t\t      \"Detected readonly device, marking FS readonly\");\n\t\ts->s_flags |= SB_RDONLY;\n\t}\n\targs.objectid = REISERFS_ROOT_OBJECTID;\n\targs.dirid = REISERFS_ROOT_PARENT_OBJECTID;\n\troot_inode =\n\t    iget5_locked(s, REISERFS_ROOT_OBJECTID, reiserfs_find_actor,\n\t\t\t reiserfs_init_locked_inode, (void *)&args);\n\tif (!root_inode) {\n\t\tSWARN(silent, s, \"jmacd-10\", \"get root inode failed\");\n\t\tgoto error_unlocked;\n\t}\n\n\t \n\treiserfs_write_lock(s);\n\n\tif (root_inode->i_state & I_NEW) {\n\t\treiserfs_read_locked_inode(root_inode, &args);\n\t\tunlock_new_inode(root_inode);\n\t}\n\n\tif (!S_ISDIR(root_inode->i_mode) || !inode_get_bytes(root_inode) ||\n\t    !root_inode->i_size) {\n\t\tSWARN(silent, s, \"\", \"corrupt root inode, run fsck\");\n\t\tiput(root_inode);\n\t\terrval = -EUCLEAN;\n\t\tgoto error;\n\t}\n\n\ts->s_root = d_make_root(root_inode);\n\tif (!s->s_root)\n\t\tgoto error;\n\t \n\tsbi->s_hash_function = hash_function(s);\n\tif (sbi->s_hash_function == NULL) {\n\t\tdput(s->s_root);\n\t\ts->s_root = NULL;\n\t\tgoto error;\n\t}\n\n\tif (is_reiserfs_3_5(rs)\n\t    || (is_reiserfs_jr(rs) && SB_VERSION(s) == REISERFS_VERSION_1))\n\t\tset_bit(REISERFS_3_5, &sbi->s_properties);\n\telse if (old_format)\n\t\tset_bit(REISERFS_OLD_FORMAT, &sbi->s_properties);\n\telse\n\t\tset_bit(REISERFS_3_6, &sbi->s_properties);\n\n\tif (!sb_rdonly(s)) {\n\n\t\terrval = journal_begin(&th, s, 1);\n\t\tif (errval) {\n\t\t\tdput(s->s_root);\n\t\t\ts->s_root = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\n\t\tset_sb_umount_state(rs, REISERFS_ERROR_FS);\n\t\tset_sb_fs_state(rs, 0);\n\n\t\t \n\t\tif (bmap_would_wrap(reiserfs_bmap_count(s)) &&\n\t\t    sb_bmap_nr(rs) != 0) {\n\t\t\treiserfs_warning(s, \"super-2030\", \"This file system \"\n\t\t\t\t\t\"claims to use %u bitmap blocks in \"\n\t\t\t\t\t\"its super block, but requires %u. \"\n\t\t\t\t\t\"Clearing to zero.\", sb_bmap_nr(rs),\n\t\t\t\t\treiserfs_bmap_count(s));\n\n\t\t\tset_sb_bmap_nr(rs, 0);\n\t\t}\n\n\t\tif (old_format_only(s)) {\n\t\t\t \n\t\t\tif (convert_reiserfs(s)) {\n\t\t\t\t \n\t\t\t\tif (!silent)\n\t\t\t\t\treiserfs_info(s,\n\t\t\t\t\t\t      \"converting 3.5 filesystem to the 3.6 format\");\n\n\t\t\t\tif (is_reiserfs_3_5(rs))\n\t\t\t\t\t \n\t\t\t\t\tmemcpy(rs->s_v1.s_magic,\n\t\t\t\t\t       reiserfs_3_6_magic_string,\n\t\t\t\t\t       sizeof\n\t\t\t\t\t       (reiserfs_3_6_magic_string));\n\n\t\t\t\tset_sb_version(rs, REISERFS_VERSION_2);\n\t\t\t\treiserfs_convert_objectid_map_v1(s);\n\t\t\t\tset_bit(REISERFS_3_6, &sbi->s_properties);\n\t\t\t\tclear_bit(REISERFS_3_5, &sbi->s_properties);\n\t\t\t} else if (!silent) {\n\t\t\t\treiserfs_info(s, \"using 3.5.x disk format\\n\");\n\t\t\t}\n\t\t} else\n\t\t\tset_sb_mnt_count(rs, sb_mnt_count(rs) + 1);\n\n\n\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\t\terrval = journal_end(&th);\n\t\tif (errval) {\n\t\t\tdput(s->s_root);\n\t\t\ts->s_root = NULL;\n\t\t\tgoto error;\n\t\t}\n\n\t\treiserfs_write_unlock(s);\n\t\tif ((errval = reiserfs_lookup_privroot(s)) ||\n\t\t    (errval = reiserfs_xattr_init(s, s->s_flags))) {\n\t\t\tdput(s->s_root);\n\t\t\ts->s_root = NULL;\n\t\t\tgoto error_unlocked;\n\t\t}\n\t\treiserfs_write_lock(s);\n\n\t\t \n\t\tfinish_unfinished(s);\n\t} else {\n\t\tif (old_format_only(s) && !silent) {\n\t\t\treiserfs_info(s, \"using 3.5.x disk format\\n\");\n\t\t}\n\n\t\treiserfs_write_unlock(s);\n\t\tif ((errval = reiserfs_lookup_privroot(s)) ||\n\t\t    (errval = reiserfs_xattr_init(s, s->s_flags))) {\n\t\t\tdput(s->s_root);\n\t\t\ts->s_root = NULL;\n\t\t\tgoto error_unlocked;\n\t\t}\n\t\treiserfs_write_lock(s);\n\t}\n\t \n\tset_sb_hash_function_code(rs, function2code(sbi->s_hash_function));\n\n\thandle_attrs(s);\n\n\treiserfs_proc_info_init(s);\n\n\tinit_waitqueue_head(&(sbi->s_wait));\n\tspin_lock_init(&sbi->bitmap_lock);\n\n\treiserfs_write_unlock(s);\n\n\treturn (0);\n\nerror:\n\treiserfs_write_unlock(s);\n\nerror_unlocked:\n\t \n\tif (jinit_done) {\n\t\treiserfs_write_lock(s);\n\t\tjournal_release_error(NULL, s);\n\t\treiserfs_write_unlock(s);\n\t}\n\n\tif (sbi->commit_wq)\n\t\tdestroy_workqueue(sbi->commit_wq);\n\n\treiserfs_cancel_old_flush(s);\n\n\treiserfs_free_bitmap_cache(s);\n\tif (SB_BUFFER_WITH_SB(s))\n\t\tbrelse(SB_BUFFER_WITH_SB(s));\n#ifdef CONFIG_QUOTA\n\t{\n\t\tint j;\n\t\tfor (j = 0; j < REISERFS_MAXQUOTAS; j++)\n\t\t\tkfree(qf_names[j]);\n\t}\n#endif\n\tkfree(sbi->s_jdev);\n\tkfree(sbi);\n\n\ts->s_fs_info = NULL;\n\treturn errval;\n}\n\nstatic int reiserfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(dentry->d_sb);\n\n\tbuf->f_namelen = (REISERFS_MAX_NAME(s->s_blocksize));\n\tbuf->f_bfree = sb_free_blocks(rs);\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_blocks = sb_block_count(rs) - sb_bmap_nr(rs) - 1;\n\tbuf->f_bsize = dentry->d_sb->s_blocksize;\n\t \n\tbuf->f_type = REISERFS_SUPER_MAGIC;\n\tbuf->f_fsid.val[0] = (u32)crc32_le(0, rs->s_uuid, sizeof(rs->s_uuid)/2);\n\tbuf->f_fsid.val[1] = (u32)crc32_le(0, rs->s_uuid + sizeof(rs->s_uuid)/2,\n\t\t\t\tsizeof(rs->s_uuid)/2);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_QUOTA\nstatic int reiserfs_write_dquot(struct dquot *dquot)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint ret, err;\n\tint depth;\n\n\treiserfs_write_lock(dquot->dq_sb);\n\tret =\n\t    journal_begin(&th, dquot->dq_sb,\n\t\t\t  REISERFS_QUOTA_TRANS_BLOCKS(dquot->dq_sb));\n\tif (ret)\n\t\tgoto out;\n\tdepth = reiserfs_write_unlock_nested(dquot->dq_sb);\n\tret = dquot_commit(dquot);\n\treiserfs_write_lock_nested(dquot->dq_sb, depth);\n\terr = journal_end(&th);\n\tif (!ret && err)\n\t\tret = err;\nout:\n\treiserfs_write_unlock(dquot->dq_sb);\n\treturn ret;\n}\n\nstatic int reiserfs_acquire_dquot(struct dquot *dquot)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint ret, err;\n\tint depth;\n\n\treiserfs_write_lock(dquot->dq_sb);\n\tret =\n\t    journal_begin(&th, dquot->dq_sb,\n\t\t\t  REISERFS_QUOTA_INIT_BLOCKS(dquot->dq_sb));\n\tif (ret)\n\t\tgoto out;\n\tdepth = reiserfs_write_unlock_nested(dquot->dq_sb);\n\tret = dquot_acquire(dquot);\n\treiserfs_write_lock_nested(dquot->dq_sb, depth);\n\terr = journal_end(&th);\n\tif (!ret && err)\n\t\tret = err;\nout:\n\treiserfs_write_unlock(dquot->dq_sb);\n\treturn ret;\n}\n\nstatic int reiserfs_release_dquot(struct dquot *dquot)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint ret, err;\n\n\treiserfs_write_lock(dquot->dq_sb);\n\tret =\n\t    journal_begin(&th, dquot->dq_sb,\n\t\t\t  REISERFS_QUOTA_DEL_BLOCKS(dquot->dq_sb));\n\treiserfs_write_unlock(dquot->dq_sb);\n\tif (ret) {\n\t\t \n\t\tdquot_release(dquot);\n\t\tgoto out;\n\t}\n\tret = dquot_release(dquot);\n\treiserfs_write_lock(dquot->dq_sb);\n\terr = journal_end(&th);\n\tif (!ret && err)\n\t\tret = err;\n\treiserfs_write_unlock(dquot->dq_sb);\nout:\n\treturn ret;\n}\n\nstatic int reiserfs_mark_dquot_dirty(struct dquot *dquot)\n{\n\t \n\tif (REISERFS_SB(dquot->dq_sb)->s_qf_names[USRQUOTA] ||\n\t    REISERFS_SB(dquot->dq_sb)->s_qf_names[GRPQUOTA]) {\n\t\tdquot_mark_dquot_dirty(dquot);\n\t\treturn reiserfs_write_dquot(dquot);\n\t} else\n\t\treturn dquot_mark_dquot_dirty(dquot);\n}\n\nstatic int reiserfs_write_info(struct super_block *sb, int type)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint ret, err;\n\tint depth;\n\n\t \n\treiserfs_write_lock(sb);\n\tret = journal_begin(&th, sb, 2);\n\tif (ret)\n\t\tgoto out;\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tret = dquot_commit_info(sb, type);\n\treiserfs_write_lock_nested(sb, depth);\n\terr = journal_end(&th);\n\tif (!ret && err)\n\t\tret = err;\nout:\n\treiserfs_write_unlock(sb);\n\treturn ret;\n}\n\n \nstatic int reiserfs_quota_on_mount(struct super_block *sb, int type)\n{\n\treturn dquot_quota_on_mount(sb, REISERFS_SB(sb)->s_qf_names[type],\n\t\t\t\t\tREISERFS_SB(sb)->s_jquota_fmt, type);\n}\n\n \nstatic int reiserfs_quota_on(struct super_block *sb, int type, int format_id,\n\t\t\t     const struct path *path)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct reiserfs_transaction_handle th;\n\tint opt = type == USRQUOTA ? REISERFS_USRQUOTA : REISERFS_GRPQUOTA;\n\n\treiserfs_write_lock(sb);\n\tif (!(REISERFS_SB(sb)->s_mount_opt & (1 << opt))) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (path->dentry->d_sb != sb) {\n\t\terr = -EXDEV;\n\t\tgoto out;\n\t}\n\tinode = d_inode(path->dentry);\n\t \n\tif (!(REISERFS_I(inode)->i_flags & i_nopack_mask)) {\n\t\terr = reiserfs_unpack(inode);\n\t\tif (err) {\n\t\t\treiserfs_warning(sb, \"super-6520\",\n\t\t\t\t\"Unpacking tail of quota file failed\"\n\t\t\t\t\" (%d). Cannot turn on quotas.\", err);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmark_inode_dirty(inode);\n\t}\n\t \n\tif (REISERFS_SB(sb)->s_qf_names[type]) {\n\t\t \n\t\tif (path->dentry->d_parent != sb->s_root)\n\t\t\treiserfs_warning(sb, \"super-6521\",\n\t\t\t\t \"Quota file not on filesystem root. \"\n\t\t\t\t \"Journalled quota will not work.\");\n\t}\n\n\t \n\tif (reiserfs_file_data_log(inode)) {\n\t\t \n\t\terr = journal_begin(&th, sb, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = journal_end_sync(&th);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\treiserfs_write_unlock(sb);\n\terr = dquot_quota_on(sb, type, format_id, path);\n\tif (!err) {\n\t\tinode_lock(inode);\n\t\tREISERFS_I(inode)->i_attrs |= REISERFS_IMMUTABLE_FL |\n\t\t\t\t\t      REISERFS_NOATIME_FL;\n\t\tinode_set_flags(inode, S_IMMUTABLE | S_NOATIME,\n\t\t\t\tS_IMMUTABLE | S_NOATIME);\n\t\tinode_unlock(inode);\n\t\tmark_inode_dirty(inode);\n\t}\n\treturn err;\nout:\n\treiserfs_write_unlock(sb);\n\treturn err;\n}\n\nstatic int reiserfs_quota_off(struct super_block *sb, int type)\n{\n\tint err;\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\n\tif (!inode || !igrab(inode))\n\t\tgoto out;\n\n\terr = dquot_quota_off(sb, type);\n\tif (err)\n\t\tgoto out_put;\n\n\tinode_lock(inode);\n\tREISERFS_I(inode)->i_attrs &= ~(REISERFS_IMMUTABLE_FL |\n\t\t\t\t\tREISERFS_NOATIME_FL);\n\tinode_set_flags(inode, 0, S_IMMUTABLE | S_NOATIME);\n\tinode_unlock(inode);\n\tmark_inode_dirty(inode);\nout_put:\n\tiput(inode);\n\treturn err;\nout:\n\treturn dquot_quota_off(sb, type);\n}\n\n \nstatic ssize_t reiserfs_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t\t   size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tunsigned long blk = off >> sb->s_blocksize_bits;\n\tint err = 0, offset = off & (sb->s_blocksize - 1), tocopy;\n\tsize_t toread;\n\tstruct buffer_head tmp_bh, *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off + len > i_size)\n\t\tlen = i_size - off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = min_t(unsigned long, sb->s_blocksize - offset, toread);\n\t\ttmp_bh.b_state = 0;\n\t\t \n\t\treiserfs_write_lock(sb);\n\t\terr = reiserfs_get_block(inode, blk, &tmp_bh, 0);\n\t\treiserfs_write_unlock(sb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!buffer_mapped(&tmp_bh))\t \n\t\t\tmemset(data, 0, tocopy);\n\t\telse {\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(data, bh->b_data + offset, tocopy);\n\t\t\tbrelse(bh);\n\t\t}\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}\n\n \nstatic ssize_t reiserfs_quota_write(struct super_block *sb, int type,\n\t\t\t\t    const char *data, size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tunsigned long blk = off >> sb->s_blocksize_bits;\n\tint err = 0, offset = off & (sb->s_blocksize - 1), tocopy;\n\tint journal_quota = REISERFS_SB(sb)->s_qf_names[type] != NULL;\n\tsize_t towrite = len;\n\tstruct buffer_head tmp_bh, *bh;\n\n\tif (!current->journal_info) {\n\t\tprintk(KERN_WARNING \"reiserfs: Quota write (off=%llu, len=%llu) cancelled because transaction is not started.\\n\",\n\t\t\t(unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\twhile (towrite > 0) {\n\t\ttocopy = min_t(unsigned long, sb->s_blocksize - offset, towrite);\n\t\ttmp_bh.b_state = 0;\n\t\treiserfs_write_lock(sb);\n\t\terr = reiserfs_get_block(inode, blk, &tmp_bh, GET_BLOCK_CREATE);\n\t\treiserfs_write_unlock(sb);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (offset || tocopy != sb->s_blocksize)\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\telse\n\t\t\tbh = sb_getblk(sb, tmp_bh.b_blocknr);\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data + offset, data, tocopy);\n\t\tflush_dcache_page(bh->b_page);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\treiserfs_write_lock(sb);\n\t\treiserfs_prepare_for_journal(sb, bh, 1);\n\t\tjournal_mark_dirty(current->journal_info, bh);\n\t\tif (!journal_quota)\n\t\t\treiserfs_add_ordered_list(inode, bh);\n\t\treiserfs_write_unlock(sb);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttowrite -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\nout:\n\tif (len == towrite)\n\t\treturn err;\n\tif (inode->i_size < off + len - towrite)\n\t\ti_size_write(inode, off + len - towrite);\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n\treturn len - towrite;\n}\n\n#endif\n\nstatic struct dentry *get_super_block(struct file_system_type *fs_type,\n\t\t\t   int flags, const char *dev_name,\n\t\t\t   void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, reiserfs_fill_super);\n}\n\nstatic int __init init_reiserfs_fs(void)\n{\n\tint ret;\n\n\tret = init_inodecache();\n\tif (ret)\n\t\treturn ret;\n\n\treiserfs_proc_info_global_init();\n\n\tret = register_filesystem(&reiserfs_fs_type);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\treiserfs_proc_info_global_done();\n\tdestroy_inodecache();\n\n\treturn ret;\n}\n\nstatic void __exit exit_reiserfs_fs(void)\n{\n\treiserfs_proc_info_global_done();\n\tunregister_filesystem(&reiserfs_fs_type);\n\tdestroy_inodecache();\n}\n\nstruct file_system_type reiserfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"reiserfs\",\n\t.mount = get_super_block,\n\t.kill_sb = reiserfs_kill_sb,\n\t.fs_flags = FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"reiserfs\");\n\nMODULE_DESCRIPTION(\"ReiserFS journaled filesystem\");\nMODULE_AUTHOR(\"Hans Reiser <reiser@namesys.com>\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(init_reiserfs_fs);\nmodule_exit(exit_reiserfs_fs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}