{
  "module_name": "inode.c",
  "hash_id": "a66ab201d729bfaa8d68d3b8be9fcdd236f3e8787ab9f501ac8fe9f740fa15e5",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/inode.c",
  "human_readable_source": " \n\n#include <linux/time.h>\n#include <linux/fs.h>\n#include \"reiserfs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/exportfs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <asm/unaligned.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/uio.h>\n#include <linux/bio.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nvoid reiserfs_evict_inode(struct inode *inode)\n{\n\t \n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 2 +\n\t    2 * REISERFS_QUOTA_INIT_BLOCKS(inode->i_sb);\n\tstruct reiserfs_transaction_handle th;\n\tint err;\n\n\tif (!inode->i_nlink && !is_bad_inode(inode))\n\t\tdquot_initialize(inode);\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (inode->i_nlink)\n\t\tgoto no_delete;\n\n\t \n\tif (!(inode->i_state & I_NEW) && INODE_PKEY(inode)->k_objectid != 0) {\n\n\t\treiserfs_delete_xattrs(inode);\n\n\t\treiserfs_write_lock(inode->i_sb);\n\n\t\tif (journal_begin(&th, inode->i_sb, jbegin_count))\n\t\t\tgoto out;\n\t\treiserfs_update_inode_transaction(inode);\n\n\t\treiserfs_discard_prealloc(&th, inode);\n\n\t\terr = reiserfs_delete_object(&th, inode);\n\n\t\t \n\t\tif (!err) {\n\t\t\tint depth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\t\tdquot_free_inode(inode);\n\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t}\n\n\t\tif (journal_end(&th))\n\t\t\tgoto out;\n\n\t\t \n\t\tif (err)\n\t\t    goto out;\n\n\t\t \n\t\tremove_save_link(inode, 0  );\nout:\n\t\treiserfs_write_unlock(inode->i_sb);\n\t} else {\n\t\t \n\t\t;\n\t}\n\n\t \n\tclear_inode(inode);\n\n\tdquot_drop(inode);\n\tinode->i_blocks = 0;\n\treturn;\n\nno_delete:\n\tclear_inode(inode);\n\tdquot_drop(inode);\n}\n\nstatic void _make_cpu_key(struct cpu_key *key, int version, __u32 dirid,\n\t\t\t  __u32 objectid, loff_t offset, int type, int length)\n{\n\tkey->version = version;\n\n\tkey->on_disk_key.k_dir_id = dirid;\n\tkey->on_disk_key.k_objectid = objectid;\n\tset_cpu_key_k_offset(key, offset);\n\tset_cpu_key_k_type(key, type);\n\tkey->key_length = length;\n}\n\n \nvoid make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}\n\n \ninline void make_le_item_head(struct item_head *ih, const struct cpu_key *key,\n\t\t\t      int version,\n\t\t\t      loff_t offset, int type, int length,\n\t\t\t      int entry_count   )\n{\n\tif (key) {\n\t\tih->ih_key.k_dir_id = cpu_to_le32(key->on_disk_key.k_dir_id);\n\t\tih->ih_key.k_objectid =\n\t\t    cpu_to_le32(key->on_disk_key.k_objectid);\n\t}\n\tput_ih_version(ih, version);\n\tset_le_ih_k_offset(ih, offset);\n\tset_le_ih_k_type(ih, type);\n\tput_ih_item_len(ih, length);\n\t \n\t \n\tput_ih_entry_count(ih, entry_count);\n}\n\n \n\n \n\n \nstatic inline void fix_tail_page_for_writing(struct page *page)\n{\n\tstruct buffer_head *head, *next, *bh;\n\n\tif (page && page_has_buffers(page)) {\n\t\thead = page_buffers(page);\n\t\tbh = head;\n\t\tdo {\n\t\t\tnext = bh->b_this_page;\n\t\t\tif (buffer_mapped(bh) && bh->b_blocknr == 0) {\n\t\t\t\treiserfs_unmap_buffer(bh);\n\t\t\t}\n\t\t\tbh = next;\n\t\t} while (bh != head);\n\t}\n}\n\n \nstatic inline int allocation_needed(int retval, b_blocknr_t allocated,\n\t\t\t\t    struct item_head *ih,\n\t\t\t\t    __le32 * item, int pos_in_item)\n{\n\tif (allocated)\n\t\treturn 0;\n\tif (retval == POSITION_FOUND && is_indirect_le_ih(ih) &&\n\t    get_block_num(item, pos_in_item))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic inline int indirect_item_found(int retval, struct item_head *ih)\n{\n\treturn (retval == POSITION_FOUND) && is_indirect_le_ih(ih);\n}\n\nstatic inline void set_block_dev_mapped(struct buffer_head *bh,\n\t\t\t\t\tb_blocknr_t block, struct inode *inode)\n{\n\tmap_bh(bh, inode->i_sb, block);\n}\n\n \nstatic int file_capable(struct inode *inode, sector_t block)\n{\n\t \n\tif (get_inode_item_key_version(inode) != KEY_FORMAT_3_5 ||\n\t     \n\t    block < (1 << (31 - inode->i_sb->s_blocksize_bits)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int restart_transaction(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode, struct treepath *path)\n{\n\tstruct super_block *s = th->t_super;\n\tint err;\n\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(!th->t_refcount);\n\n\tpathrelse(path);\n\n\t \n\tif (th->t_refcount > 1) {\n\t\treturn 0;\n\t}\n\treiserfs_update_sd(th, inode);\n\terr = journal_end(th);\n\tif (!err) {\n\t\terr = journal_begin(th, s, JOURNAL_PER_BALANCE_CNT * 6);\n\t\tif (!err)\n\t\t\treiserfs_update_inode_transaction(inode);\n\t}\n\treturn err;\n}\n\n \nstatic int _get_block_create_0(struct inode *inode, sector_t block,\n\t\t\t       struct buffer_head *bh_result, int args)\n{\n\tINITIALIZE_PATH(path);\n\tstruct cpu_key key;\n\tstruct buffer_head *bh;\n\tstruct item_head *ih, tmp_ih;\n\tb_blocknr_t blocknr;\n\tchar *p;\n\tint chars;\n\tint ret;\n\tint result;\n\tint done = 0;\n\tunsigned long offset;\n\n\t \n\tmake_cpu_key(&key, inode,\n\t\t     (loff_t) block * inode->i_sb->s_blocksize + 1, TYPE_ANY,\n\t\t     3);\n\n\tresult = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (result != POSITION_FOUND) {\n\t\tpathrelse(&path);\n\t\tif (result == IO_ERROR)\n\t\t\treturn -EIO;\n\t\t \n\t\tif ((args & GET_BLOCK_NO_HOLE)\n\t\t    && !PageUptodate(bh_result->b_page)) {\n\t\t\treturn -ENOENT;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\tif (is_indirect_le_ih(ih)) {\n\t\t__le32 *ind_item = (__le32 *) ih_item_body(bh, ih);\n\n\t\t \n\t\tblocknr = get_block_num(ind_item, path.pos_in_item);\n\t\tret = 0;\n\t\tif (blocknr) {\n\t\t\tmap_bh(bh_result, inode->i_sb, blocknr);\n\t\t\tif (path.pos_in_item ==\n\t\t\t    ((ih_item_len(ih) / UNFM_P_SIZE) - 1)) {\n\t\t\t\tset_buffer_boundary(bh_result);\n\t\t\t}\n\t\t} else\n\t\t\t \n\t\tif ((args & GET_BLOCK_NO_HOLE)\n\t\t\t    && !PageUptodate(bh_result->b_page)) {\n\t\t\tret = -ENOENT;\n\t\t}\n\n\t\tpathrelse(&path);\n\t\treturn ret;\n\t}\n\t \n\tif (!(args & GET_BLOCK_READ_DIRECT)) {\n\t\t \n\t\tpathrelse(&path);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tif (buffer_uptodate(bh_result)) {\n\t\tgoto finished;\n\t} else\n\t\t \n\tif (!bh_result->b_page || PageUptodate(bh_result->b_page)) {\n\t\tset_buffer_uptodate(bh_result);\n\t\tgoto finished;\n\t}\n\t \n\toffset = (cpu_key_k_offset(&key) - 1) & (PAGE_SIZE - 1);\n\tcopy_item_head(&tmp_ih, ih);\n\n\t \n\tp = (char *)kmap(bh_result->b_page);\n\tp += offset;\n\tmemset(p, 0, inode->i_sb->s_blocksize);\n\tdo {\n\t\tif (!is_direct_le_ih(ih)) {\n\t\t\tBUG();\n\t\t}\n\t\t \n\t\tif ((le_ih_k_offset(ih) + path.pos_in_item) > inode->i_size)\n\t\t\tbreak;\n\t\tif ((le_ih_k_offset(ih) - 1 + ih_item_len(ih)) > inode->i_size) {\n\t\t\tchars =\n\t\t\t    inode->i_size - (le_ih_k_offset(ih) - 1) -\n\t\t\t    path.pos_in_item;\n\t\t\tdone = 1;\n\t\t} else {\n\t\t\tchars = ih_item_len(ih) - path.pos_in_item;\n\t\t}\n\t\tmemcpy(p, ih_item_body(bh, ih) + path.pos_in_item, chars);\n\n\t\tif (done)\n\t\t\tbreak;\n\n\t\tp += chars;\n\n\t\t \n\t\tif (PATH_LAST_POSITION(&path) != (B_NR_ITEMS(bh) - 1))\n\t\t\tbreak;\n\n\t\t \n\t\tset_cpu_key_k_offset(&key, cpu_key_k_offset(&key) + chars);\n\t\tresult = search_for_position_by_key(inode->i_sb, &key, &path);\n\t\tif (result != POSITION_FOUND)\n\t\t\t \n\t\t\tbreak;\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t} while (1);\n\n\tflush_dcache_page(bh_result->b_page);\n\tkunmap(bh_result->b_page);\n\nfinished:\n\tpathrelse(&path);\n\n\tif (result == IO_ERROR)\n\t\treturn -EIO;\n\n\t \n\tmap_bh(bh_result, inode->i_sb, 0);\n\tset_buffer_uptodate(bh_result);\n\treturn 0;\n}\n\n \nstatic int reiserfs_bmap(struct inode *inode, sector_t block,\n\t\t\t struct buffer_head *bh_result, int create)\n{\n\tif (!file_capable(inode, block))\n\t\treturn -EFBIG;\n\n\treiserfs_write_lock(inode->i_sb);\n\t \n\t_get_block_create_0(inode, block, bh_result, 0);\n\treiserfs_write_unlock(inode->i_sb);\n\treturn 0;\n}\n\n \nstatic int reiserfs_get_block_create_0(struct inode *inode, sector_t block,\n\t\t\t\t       struct buffer_head *bh_result,\n\t\t\t\t       int create)\n{\n\treturn reiserfs_get_block(inode, block, bh_result, GET_BLOCK_NO_HOLE);\n}\n\n \nstatic int reiserfs_get_blocks_direct_io(struct inode *inode,\n\t\t\t\t\t sector_t iblock,\n\t\t\t\t\t struct buffer_head *bh_result,\n\t\t\t\t\t int create)\n{\n\tint ret;\n\n\tbh_result->b_page = NULL;\n\n\t \n\tbh_result->b_size = i_blocksize(inode);\n\n\tret = reiserfs_get_block(inode, iblock, bh_result,\n\t\t\t\t create | GET_BLOCK_NO_DANGLE);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (buffer_mapped(bh_result) && bh_result->b_blocknr == 0) {\n\t\t \n\t\tclear_buffer_mapped(bh_result);\n\t\tret = -EINVAL;\n\t}\n\n\t \n\tif (REISERFS_I(inode)->i_flags & i_pack_on_close_mask) {\n\t\tint err;\n\n\t\treiserfs_write_lock(inode->i_sb);\n\n\t\terr = reiserfs_commit_for_inode(inode);\n\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\n\t\treiserfs_write_unlock(inode->i_sb);\n\n\t\tif (err < 0)\n\t\t\tret = err;\n\t}\nout:\n\treturn ret;\n}\n\n \nstatic int convert_tail_for_hole(struct inode *inode,\n\t\t\t\t struct buffer_head *bh_result,\n\t\t\t\t loff_t tail_offset)\n{\n\tunsigned long index;\n\tunsigned long tail_end;\n\tunsigned long tail_start;\n\tstruct page *tail_page;\n\tstruct page *hole_page = bh_result->b_page;\n\tint retval = 0;\n\n\tif ((tail_offset & (bh_result->b_size - 1)) != 1)\n\t\treturn -EIO;\n\n\t \n\ttail_start = tail_offset & (PAGE_SIZE - 1);\n\ttail_end = (tail_start | (bh_result->b_size - 1)) + 1;\n\n\tindex = tail_offset >> PAGE_SHIFT;\n\t \n\tif (!hole_page || index != hole_page->index) {\n\t\ttail_page = grab_cache_page(inode->i_mapping, index);\n\t\tretval = -ENOMEM;\n\t\tif (!tail_page) {\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\ttail_page = hole_page;\n\t}\n\n\t \n\tfix_tail_page_for_writing(tail_page);\n\tretval = __reiserfs_write_begin(tail_page, tail_start,\n\t\t\t\t      tail_end - tail_start);\n\tif (retval)\n\t\tgoto unlock;\n\n\t \n\tflush_dcache_page(tail_page);\n\n\tretval = reiserfs_commit_write(NULL, tail_page, tail_start, tail_end);\n\nunlock:\n\tif (tail_page != hole_page) {\n\t\tunlock_page(tail_page);\n\t\tput_page(tail_page);\n\t}\nout:\n\treturn retval;\n}\n\nstatic inline int _allocate_block(struct reiserfs_transaction_handle *th,\n\t\t\t\t  sector_t block,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  b_blocknr_t * allocated_block_nr,\n\t\t\t\t  struct treepath *path, int flags)\n{\n\tBUG_ON(!th->t_trans_id);\n\n#ifdef REISERFS_PREALLOCATE\n\tif (!(flags & GET_BLOCK_NO_IMUX)) {\n\t\treturn reiserfs_new_unf_blocknrs2(th, inode, allocated_block_nr,\n\t\t\t\t\t\t  path, block);\n\t}\n#endif\n\treturn reiserfs_new_unf_blocknrs(th, inode, allocated_block_nr, path,\n\t\t\t\t\t block);\n}\n\nint reiserfs_get_block(struct inode *inode, sector_t block,\n\t\t       struct buffer_head *bh_result, int create)\n{\n\tint repeat, retval = 0;\n\t \n\tb_blocknr_t allocated_block_nr = 0;\n\tINITIALIZE_PATH(path);\n\tint pos_in_item;\n\tstruct cpu_key key;\n\tstruct buffer_head *bh, *unbh = NULL;\n\tstruct item_head *ih, tmp_ih;\n\t__le32 *item;\n\tint done;\n\tint fs_gen;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\t \n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 + 1 +\n\t    2 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\tint version;\n\tint dangle = 1;\n\tloff_t new_offset =\n\t    (((loff_t) block) << inode->i_sb->s_blocksize_bits) + 1;\n\n\treiserfs_write_lock(inode->i_sb);\n\tversion = get_inode_item_key_version(inode);\n\n\tif (!file_capable(inode, block)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn -EFBIG;\n\t}\n\n\t \n\tif (!(create & GET_BLOCK_CREATE)) {\n\t\tint ret;\n\t\t \n\t\tret = _get_block_create_0(inode, block, bh_result,\n\t\t\t\t\t  create | GET_BLOCK_READ_DIRECT);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn ret;\n\t}\n\n\t \n\tif ((create & GET_BLOCK_NO_DANGLE) ||\n\t    reiserfs_transaction_running(inode->i_sb))\n\t\tdangle = 0;\n\n\t \n\tif ((have_large_tails(inode->i_sb)\n\t     && inode->i_size < i_block_size(inode) * 4)\n\t    || (have_small_tails(inode->i_sb)\n\t\t&& inode->i_size < i_block_size(inode)))\n\t\tREISERFS_I(inode)->i_flags |= i_pack_on_close_mask;\n\n\t \n\tmake_cpu_key(&key, inode, new_offset, TYPE_ANY, 3   );\n\tif ((new_offset + inode->i_sb->s_blocksize - 1) > inode->i_size) {\nstart_trans:\n\t\tth = reiserfs_persistent_transaction(inode->i_sb, jbegin_count);\n\t\tif (!th) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\t\treiserfs_update_inode_transaction(inode);\n\t}\nresearch:\n\n\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto failure;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\titem = tp_item_body(&path);\n\tpos_in_item = path.pos_in_item;\n\n\tfs_gen = get_generation(inode->i_sb);\n\tcopy_item_head(&tmp_ih, ih);\n\n\tif (allocation_needed\n\t    (retval, allocated_block_nr, ih, item, pos_in_item)) {\n\t\t \n\t\tif (!th) {\n\t\t\tpathrelse(&path);\n\t\t\tgoto start_trans;\n\t\t}\n\n\t\trepeat =\n\t\t    _allocate_block(th, block, inode, &allocated_block_nr,\n\t\t\t\t    &path, create);\n\n\t\t \n\t\tif (repeat == NO_DISK_SPACE || repeat == QUOTA_EXCEEDED) {\n\t\t\tSB_JOURNAL(inode->i_sb)->j_next_async_flush = 1;\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t\trepeat =\n\t\t\t    _allocate_block(th, block, inode,\n\t\t\t\t\t    &allocated_block_nr, NULL, create);\n\n\t\t\tif (repeat != NO_DISK_SPACE && repeat != QUOTA_EXCEEDED) {\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tif (repeat == QUOTA_EXCEEDED)\n\t\t\t\tretval = -EDQUOT;\n\t\t\telse\n\t\t\t\tretval = -ENOSPC;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\tgoto research;\n\t\t}\n\t}\n\n\tif (indirect_item_found(retval, ih)) {\n\t\tb_blocknr_t unfm_ptr;\n\t\t \n\t\tunfm_ptr = get_block_num(item, pos_in_item);\n\t\tif (unfm_ptr == 0) {\n\t\t\t \n\t\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\t\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\t\treiserfs_restore_prepared_buffer(inode->i_sb,\n\t\t\t\t\t\t\t\t bh);\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tset_buffer_new(bh_result);\n\t\t\tif (buffer_dirty(bh_result)\n\t\t\t    && reiserfs_data_ordered(inode->i_sb))\n\t\t\t\treiserfs_add_ordered_list(inode, bh_result);\n\t\t\tput_block_num(item, pos_in_item, allocated_block_nr);\n\t\t\tunfm_ptr = allocated_block_nr;\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\treiserfs_update_sd(th, inode);\n\t\t}\n\t\tset_block_dev_mapped(bh_result, unfm_ptr, inode);\n\t\tpathrelse(&path);\n\t\tretval = 0;\n\t\tif (!dangle && th)\n\t\t\tretval = reiserfs_end_persistent_transaction(th);\n\n\t\treiserfs_write_unlock(inode->i_sb);\n\n\t\t \n\t\treturn retval;\n\t}\n\n\tif (!th) {\n\t\tpathrelse(&path);\n\t\tgoto start_trans;\n\t}\n\n\t \n\tdone = 0;\n\tdo {\n\t\tif (is_statdata_le_ih(ih)) {\n\t\t\t__le32 unp = 0;\n\t\t\tstruct cpu_key tmp_key;\n\n\t\t\t \n\t\t\tmake_le_item_head(&tmp_ih, &key, version, 1,\n\t\t\t\t\t  TYPE_INDIRECT, UNFM_P_SIZE,\n\t\t\t\t\t  0   );\n\n\t\t\t \n\t\t\tif (cpu_key_k_offset(&key) == 1) {\n\t\t\t\tunp = cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\ttmp_key = key;\t \n\t\t\tset_cpu_key_k_offset(&tmp_key, 1);\n\t\t\tPATH_LAST_POSITION(&path)++;\n\n\t\t\tretval =\n\t\t\t    reiserfs_insert_item(th, &path, &tmp_key, &tmp_ih,\n\t\t\t\t\t\t inode, (char *)&unp);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\t \n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t} else if (is_direct_le_ih(ih)) {\n\t\t\t \n\t\t\tloff_t tail_offset;\n\n\t\t\ttail_offset =\n\t\t\t    ((le_ih_k_offset(ih) -\n\t\t\t      1) & ~(inode->i_sb->s_blocksize - 1)) + 1;\n\n\t\t\t \n\t\t\tif (tail_offset == cpu_key_k_offset(&key)) {\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tunbh = bh_result;\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t \n\n\t\t\t\tpathrelse(&path);\n\t\t\t\t \n\t\t\t\tBUG_ON(!th->t_refcount);\n\t\t\t\tif (th->t_refcount == 1) {\n\t\t\t\t\tretval =\n\t\t\t\t\t    reiserfs_end_persistent_transaction\n\t\t\t\t\t    (th);\n\t\t\t\t\tth = NULL;\n\t\t\t\t\tif (retval)\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\n\t\t\t\tretval =\n\t\t\t\t    convert_tail_for_hole(inode, bh_result,\n\t\t\t\t\t\t\t  tail_offset);\n\t\t\t\tif (retval) {\n\t\t\t\t\tif (retval != -ENOSPC)\n\t\t\t\t\t\treiserfs_error(inode->i_sb,\n\t\t\t\t\t\t\t\"clm-6004\",\n\t\t\t\t\t\t\t\"convert tail failed \"\n\t\t\t\t\t\t\t\"inode %lu, error %d\",\n\t\t\t\t\t\t\tinode->i_ino,\n\t\t\t\t\t\t\tretval);\n\t\t\t\t\tif (allocated_block_nr) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (!th)\n\t\t\t\t\t\t\tth = reiserfs_persistent_transaction(inode->i_sb, 3);\n\t\t\t\t\t\tif (th)\n\t\t\t\t\t\t\treiserfs_free_block(th,\n\t\t\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t\t\t    allocated_block_nr,\n\t\t\t\t\t\t\t\t\t    1);\n\t\t\t\t\t}\n\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    direct2indirect(th, inode, &path, unbh,\n\t\t\t\t\t    tail_offset);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_unmap_buffer(unbh);\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t \n\t\t\tset_buffer_uptodate(unbh);\n\n\t\t\t \n\t\t\tif (unbh->b_page) {\n\t\t\t\t \n\t\t\t\treiserfs_add_tail_list(inode, unbh);\n\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tmark_buffer_dirty(unbh);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tstruct cpu_key tmp_key;\n\t\t\t \n\t\t\tunp_t unf_single = 0;\n\t\t\tunp_t *un;\n\t\t\t__u64 max_to_insert =\n\t\t\t    MAX_ITEM_LEN(inode->i_sb->s_blocksize) /\n\t\t\t    UNFM_P_SIZE;\n\t\t\t__u64 blocks_needed;\n\n\t\t\tRFALSE(pos_in_item != ih_item_len(ih) / UNFM_P_SIZE,\n\t\t\t       \"vs-804: invalid position for append\");\n\t\t\t \n\t\t\tmake_cpu_key(&tmp_key, inode,\n\t\t\t\t     le_key_k_offset(version,\n\t\t\t\t\t\t     &ih->ih_key) +\n\t\t\t\t     op_bytes_number(ih,\n\t\t\t\t\t\t     inode->i_sb->s_blocksize),\n\t\t\t\t     TYPE_INDIRECT, 3);\n\n\t\t\tRFALSE(cpu_key_k_offset(&tmp_key) > cpu_key_k_offset(&key),\n\t\t\t       \"green-805: invalid offset\");\n\t\t\tblocks_needed =\n\t\t\t    1 +\n\t\t\t    ((cpu_key_k_offset(&key) -\n\t\t\t      cpu_key_k_offset(&tmp_key)) >> inode->i_sb->\n\t\t\t     s_blocksize_bits);\n\n\t\t\tif (blocks_needed == 1) {\n\t\t\t\tun = &unf_single;\n\t\t\t} else {\n\t\t\t\tun = kcalloc(min(blocks_needed, max_to_insert),\n\t\t\t\t\t     UNFM_P_SIZE, GFP_NOFS);\n\t\t\t\tif (!un) {\n\t\t\t\t\tun = &unf_single;\n\t\t\t\t\tblocks_needed = 1;\n\t\t\t\t\tmax_to_insert = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (blocks_needed <= max_to_insert) {\n\t\t\t\t \n\t\t\t\tun[blocks_needed - 1] =\n\t\t\t\t    cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tblocks_needed =\n\t\t\t\t    max_to_insert ? max_to_insert : 1;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    reiserfs_paste_into_item(th, &path, &tmp_key, inode,\n\t\t\t\t\t\t     (char *)un,\n\t\t\t\t\t\t     UNFM_P_SIZE *\n\t\t\t\t\t\t     blocks_needed);\n\n\t\t\tif (blocks_needed != 1)\n\t\t\t\tkfree(un);\n\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tif (!done) {\n\t\t\t\t \n\t\t\t\tinode->i_size +=\n\t\t\t\t    inode->i_sb->s_blocksize * blocks_needed;\n\t\t\t}\n\t\t}\n\n\t\tif (done == 1)\n\t\t\tbreak;\n\n\t\t \n\t\tif (journal_transaction_should_end(th, th->t_blocks_allocated)) {\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t}\n\t\t \n\t\treiserfs_cond_resched(inode->i_sb);\n\n\t\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto failure;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-825\",\n\t\t\t\t\t \"%K should not be found\", &key);\n\t\t\tretval = -EEXIST;\n\t\t\tif (allocated_block_nr)\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\tpathrelse(&path);\n\t\t\tgoto failure;\n\t\t}\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t\titem = tp_item_body(&path);\n\t\tpos_in_item = path.pos_in_item;\n\t} while (1);\n\n\tretval = 0;\n\nfailure:\n\tif (th && (!dangle || (retval && !th->t_trans_id))) {\n\t\tint err;\n\t\tif (th->t_trans_id)\n\t\t\treiserfs_update_sd(th, inode);\n\t\terr = reiserfs_end_persistent_transaction(th);\n\t\tif (err)\n\t\t\tretval = err;\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\treiserfs_check_path(&path);\n\treturn retval;\n}\n\nstatic void reiserfs_readahead(struct readahead_control *rac)\n{\n\tmpage_readahead(rac, reiserfs_get_block);\n}\n\n \nstatic int real_space_diff(struct inode *inode, int sd_size)\n{\n\tint bytes;\n\tloff_t blocksize = inode->i_sb->s_blocksize;\n\n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode))\n\t\treturn sd_size;\n\n\t \n\tbytes =\n\t    ((inode->i_size +\n\t      (blocksize - 1)) >> inode->i_sb->s_blocksize_bits) * UNFM_P_SIZE +\n\t    sd_size;\n\treturn bytes;\n}\n\nstatic inline loff_t to_real_used_space(struct inode *inode, ulong blocks,\n\t\t\t\t\tint sd_size)\n{\n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode)) {\n\t\treturn inode->i_size +\n\t\t    (loff_t) (real_space_diff(inode, sd_size));\n\t}\n\treturn ((loff_t) real_space_diff(inode, sd_size)) +\n\t    (((loff_t) blocks) << 9);\n}\n\n \nstatic inline ulong to_fake_used_blocks(struct inode *inode, int sd_size)\n{\n\tloff_t bytes = inode_get_bytes(inode);\n\tloff_t real_space = real_space_diff(inode, sd_size);\n\n\t \n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode)) {\n\t\tbytes += (loff_t) 511;\n\t}\n\n\t \n\tif (bytes < real_space)\n\t\treturn 0;\n\treturn (bytes - real_space) >> 9;\n}\n\n \n\n \nstatic void init_inode(struct inode *inode, struct treepath *path)\n{\n\tstruct buffer_head *bh;\n\tstruct item_head *ih;\n\t__u32 rdev;\n\n\tbh = PATH_PLAST_BUFFER(path);\n\tih = tp_item_head(path);\n\n\tcopy_key(INODE_PKEY(inode), &ih->ih_key);\n\n\tINIT_LIST_HEAD(&REISERFS_I(inode)->i_prealloc_list);\n\tREISERFS_I(inode)->i_flags = 0;\n\tREISERFS_I(inode)->i_prealloc_block = 0;\n\tREISERFS_I(inode)->i_prealloc_count = 0;\n\tREISERFS_I(inode)->i_trans_id = 0;\n\tREISERFS_I(inode)->i_jl = NULL;\n\treiserfs_init_xattr_rwsem(inode);\n\n\tif (stat_data_v1(ih)) {\n\t\tstruct stat_data_v1 *sd =\n\t\t    (struct stat_data_v1 *)ih_item_body(bh, ih);\n\t\tunsigned long blocks;\n\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\t\tset_inode_sd_version(inode, STAT_DATA_V1);\n\t\tinode->i_mode = sd_v1_mode(sd);\n\t\tset_nlink(inode, sd_v1_nlink(sd));\n\t\ti_uid_write(inode, sd_v1_uid(sd));\n\t\ti_gid_write(inode, sd_v1_gid(sd));\n\t\tinode->i_size = sd_v1_size(sd);\n\t\tinode->i_atime.tv_sec = sd_v1_atime(sd);\n\t\tinode->i_mtime.tv_sec = sd_v1_mtime(sd);\n\t\tinode_set_ctime(inode, sd_v1_ctime(sd), 0);\n\t\tinode->i_atime.tv_nsec = 0;\n\t\tinode->i_mtime.tv_nsec = 0;\n\n\t\tinode->i_blocks = sd_v1_blocks(sd);\n\t\tinode->i_generation = le32_to_cpu(INODE_PKEY(inode)->k_dir_id);\n\t\tblocks = (inode->i_size + 511) >> 9;\n\t\tblocks = _ROUND_UP(blocks, inode->i_sb->s_blocksize >> 9);\n\n\t\t \n\t\tif (inode->i_blocks > blocks) {\n\t\t\tinode->i_blocks = blocks;\n\t\t}\n\n\t\trdev = sd_v1_rdev(sd);\n\t\tREISERFS_I(inode)->i_first_direct_byte =\n\t\t    sd_v1_first_direct_byte(sd);\n\n\t\t \n\t\tif (inode->i_blocks & 1) {\n\t\t\tinode->i_blocks++;\n\t\t}\n\t\tinode_set_bytes(inode,\n\t\t\t\tto_real_used_space(inode, inode->i_blocks,\n\t\t\t\t\t\t   SD_V1_SIZE));\n\t\t \n\t\tREISERFS_I(inode)->i_flags &= ~i_nopack_mask;\n\t} else {\n\t\t \n\t\tstruct stat_data *sd = (struct stat_data *)ih_item_body(bh, ih);\n\n\t\tinode->i_mode = sd_v2_mode(sd);\n\t\tset_nlink(inode, sd_v2_nlink(sd));\n\t\ti_uid_write(inode, sd_v2_uid(sd));\n\t\tinode->i_size = sd_v2_size(sd);\n\t\ti_gid_write(inode, sd_v2_gid(sd));\n\t\tinode->i_mtime.tv_sec = sd_v2_mtime(sd);\n\t\tinode->i_atime.tv_sec = sd_v2_atime(sd);\n\t\tinode_set_ctime(inode, sd_v2_ctime(sd), 0);\n\t\tinode->i_mtime.tv_nsec = 0;\n\t\tinode->i_atime.tv_nsec = 0;\n\t\tinode->i_blocks = sd_v2_blocks(sd);\n\t\trdev = sd_v2_rdev(sd);\n\t\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\t\tinode->i_generation =\n\t\t\t    le32_to_cpu(INODE_PKEY(inode)->k_dir_id);\n\t\telse\n\t\t\tinode->i_generation = sd_v2_generation(sd);\n\n\t\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\n\t\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\t\telse\n\t\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_6);\n\t\tREISERFS_I(inode)->i_first_direct_byte = 0;\n\t\tset_inode_sd_version(inode, STAT_DATA_V2);\n\t\tinode_set_bytes(inode,\n\t\t\t\tto_real_used_space(inode, inode->i_blocks,\n\t\t\t\t\t\t   SD_V2_SIZE));\n\t\t \n\t\tREISERFS_I(inode)->i_attrs = sd_v2_attrs(sd);\n\t\tsd_attrs_to_i_attrs(sd_v2_attrs(sd), inode);\n\t}\n\n\tpathrelse(path);\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &reiserfs_file_inode_operations;\n\t\tinode->i_fop = &reiserfs_file_operations;\n\t\tinode->i_mapping->a_ops = &reiserfs_address_space_operations;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &reiserfs_dir_inode_operations;\n\t\tinode->i_fop = &reiserfs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &reiserfs_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &reiserfs_address_space_operations;\n\t} else {\n\t\tinode->i_blocks = 0;\n\t\tinode->i_op = &reiserfs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, new_decode_dev(rdev));\n\t}\n}\n\n \nstatic void inode2sd(void *sd, struct inode *inode, loff_t size)\n{\n\tstruct stat_data *sd_v2 = (struct stat_data *)sd;\n\n\tset_sd_v2_mode(sd_v2, inode->i_mode);\n\tset_sd_v2_nlink(sd_v2, inode->i_nlink);\n\tset_sd_v2_uid(sd_v2, i_uid_read(inode));\n\tset_sd_v2_size(sd_v2, size);\n\tset_sd_v2_gid(sd_v2, i_gid_read(inode));\n\tset_sd_v2_mtime(sd_v2, inode->i_mtime.tv_sec);\n\tset_sd_v2_atime(sd_v2, inode->i_atime.tv_sec);\n\tset_sd_v2_ctime(sd_v2, inode_get_ctime(inode).tv_sec);\n\tset_sd_v2_blocks(sd_v2, to_fake_used_blocks(inode, SD_V2_SIZE));\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tset_sd_v2_rdev(sd_v2, new_encode_dev(inode->i_rdev));\n\telse\n\t\tset_sd_v2_generation(sd_v2, inode->i_generation);\n\tset_sd_v2_attrs(sd_v2, REISERFS_I(inode)->i_attrs);\n}\n\n \nstatic void inode2sd_v1(void *sd, struct inode *inode, loff_t size)\n{\n\tstruct stat_data_v1 *sd_v1 = (struct stat_data_v1 *)sd;\n\n\tset_sd_v1_mode(sd_v1, inode->i_mode);\n\tset_sd_v1_uid(sd_v1, i_uid_read(inode));\n\tset_sd_v1_gid(sd_v1, i_gid_read(inode));\n\tset_sd_v1_nlink(sd_v1, inode->i_nlink);\n\tset_sd_v1_size(sd_v1, size);\n\tset_sd_v1_atime(sd_v1, inode->i_atime.tv_sec);\n\tset_sd_v1_ctime(sd_v1, inode_get_ctime(inode).tv_sec);\n\tset_sd_v1_mtime(sd_v1, inode->i_mtime.tv_sec);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tset_sd_v1_rdev(sd_v1, new_encode_dev(inode->i_rdev));\n\telse\n\t\tset_sd_v1_blocks(sd_v1, to_fake_used_blocks(inode, SD_V1_SIZE));\n\n\t \n\tset_sd_v1_first_direct_byte(sd_v1,\n\t\t\t\t    REISERFS_I(inode)->i_first_direct_byte);\n}\n\n \nstatic void update_stat_data(struct treepath *path, struct inode *inode,\n\t\t\t     loff_t size)\n{\n\tstruct buffer_head *bh;\n\tstruct item_head *ih;\n\n\tbh = PATH_PLAST_BUFFER(path);\n\tih = tp_item_head(path);\n\n\tif (!is_statdata_le_ih(ih))\n\t\treiserfs_panic(inode->i_sb, \"vs-13065\", \"key %k, found item %h\",\n\t\t\t       INODE_PKEY(inode), ih);\n\n\t \n\tif (stat_data_v1(ih)) {\n\t\tinode2sd_v1(ih_item_body(bh, ih), inode, size);\n\t} else {\n\t\tinode2sd(ih_item_body(bh, ih), inode, size);\n\t}\n\n\treturn;\n}\n\nvoid reiserfs_update_sd_size(struct reiserfs_transaction_handle *th,\n\t\t\t     struct inode *inode, loff_t size)\n{\n\tstruct cpu_key key;\n\tINITIALIZE_PATH(path);\n\tstruct buffer_head *bh;\n\tint fs_gen;\n\tstruct item_head *ih, tmp_ih;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t \n\tmake_cpu_key(&key, inode, SD_OFFSET, TYPE_STAT_DATA, 3);\n\n\tfor (;;) {\n\t\tint pos;\n\t\t \n\t\tretval = search_item(inode->i_sb, &key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(inode->i_sb, \"vs-13050\",\n\t\t\t\t       \"i/o failure occurred trying to \"\n\t\t\t\t       \"update %K stat data\", &key);\n\t\t\treturn;\n\t\t}\n\t\tif (retval == ITEM_NOT_FOUND) {\n\t\t\tpos = PATH_LAST_POSITION(&path);\n\t\t\tpathrelse(&path);\n\t\t\tif (inode->i_nlink == 0) {\n\t\t\t\t \n\t\t\t\treturn;\n\t\t\t}\n\t\t\treiserfs_warning(inode->i_sb, \"vs-13060\",\n\t\t\t\t\t \"stat data of object %k (nlink == %d) \"\n\t\t\t\t\t \"not found (pos %d)\",\n\t\t\t\t\t INODE_PKEY(inode), inode->i_nlink,\n\t\t\t\t\t pos);\n\t\t\treiserfs_check_path(&path);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t\tcopy_item_head(&tmp_ih, ih);\n\t\tfs_gen = get_generation(inode->i_sb);\n\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\n\t\t \n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\treiserfs_restore_prepared_buffer(inode->i_sb, bh);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tupdate_stat_data(&path, inode, size);\n\tjournal_mark_dirty(th, bh);\n\tpathrelse(&path);\n\treturn;\n}\n\n \nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}\n\n \nint reiserfs_init_locked_inode(struct inode *inode, void *p)\n{\n\tstruct reiserfs_iget_args *args = (struct reiserfs_iget_args *)p;\n\tinode->i_ino = args->objectid;\n\tINODE_PKEY(inode)->k_dir_id = cpu_to_le32(args->dirid);\n\treturn 0;\n}\n\n \nvoid reiserfs_read_locked_inode(struct inode *inode,\n\t\t\t\tstruct reiserfs_iget_args *args)\n{\n\tINITIALIZE_PATH(path_to_sd);\n\tstruct cpu_key key;\n\tunsigned long dirino;\n\tint retval;\n\n\tdirino = args->dirid;\n\n\t \n\t_make_cpu_key(&key, KEY_FORMAT_3_5, dirino, inode->i_ino, 0, 0, 3);\n\n\t \n\tretval = search_item(inode->i_sb, &key, &path_to_sd);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(inode->i_sb, \"vs-13070\",\n\t\t\t       \"i/o failure occurred trying to find \"\n\t\t\t       \"stat data of %K\", &key);\n\t\treiserfs_make_bad_inode(inode);\n\t\treturn;\n\t}\n\n\t \n\tif (retval != ITEM_FOUND) {\n\t\tpathrelse(&path_to_sd);\n\t\treiserfs_make_bad_inode(inode);\n\t\tclear_nlink(inode);\n\t\treturn;\n\t}\n\n\tinit_inode(inode, &path_to_sd);\n\n\t \n\n\t \n\tif ((inode->i_nlink == 0) &&\n\t    !REISERFS_SB(inode->i_sb)->s_is_unlinked_ok) {\n\t\treiserfs_warning(inode->i_sb, \"vs-13075\",\n\t\t\t\t \"dead inode read from disk %K. \"\n\t\t\t\t \"This is likely to be race with knfsd. Ignore\",\n\t\t\t\t &key);\n\t\treiserfs_make_bad_inode(inode);\n\t}\n\n\t \n\treiserfs_check_path(&path_to_sd);\n\n\t \n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\tcache_no_acl(inode);\n}\n\n \nint reiserfs_find_actor(struct inode *inode, void *opaque)\n{\n\tstruct reiserfs_iget_args *args;\n\n\targs = opaque;\n\t \n\treturn (inode->i_ino == args->objectid) &&\n\t    (le32_to_cpu(INODE_PKEY(inode)->k_dir_id) == args->dirid);\n}\n\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key)\n{\n\tstruct inode *inode;\n\tstruct reiserfs_iget_args args;\n\tint depth;\n\n\targs.objectid = key->on_disk_key.k_objectid;\n\targs.dirid = key->on_disk_key.k_dir_id;\n\tdepth = reiserfs_write_unlock_nested(s);\n\tinode = iget5_locked(s, key->on_disk_key.k_objectid,\n\t\t\t     reiserfs_find_actor, reiserfs_init_locked_inode,\n\t\t\t     (void *)(&args));\n\treiserfs_write_lock_nested(s, depth);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\treiserfs_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tif (comp_short_keys(INODE_PKEY(inode), key) || is_bad_inode(inode)) {\n\t\t \n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}\n\nstatic struct dentry *reiserfs_get_dentry(struct super_block *sb,\n\tu32 objectid, u32 dir_id, u32 generation)\n\n{\n\tstruct cpu_key key;\n\tstruct inode *inode;\n\n\tkey.on_disk_key.k_objectid = objectid;\n\tkey.on_disk_key.k_dir_id = dir_id;\n\treiserfs_write_lock(sb);\n\tinode = reiserfs_iget(sb, &key);\n\tif (inode && !IS_ERR(inode) && generation != 0 &&\n\t    generation != inode->i_generation) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treiserfs_write_unlock(sb);\n\n\treturn d_obtain_alias(inode);\n}\n\nstruct dentry *reiserfs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\t \n\tif (fh_type > fh_len) {\n\t\tif (fh_type != 6 || fh_len != 5)\n\t\t\treiserfs_warning(sb, \"reiserfs-13077\",\n\t\t\t\t\"nfsd/reiserfs, fhtype=%d, len=%d - odd\",\n\t\t\t\tfh_type, fh_len);\n\t\tfh_type = fh_len;\n\t}\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\treturn reiserfs_get_dentry(sb, fid->raw[0], fid->raw[1],\n\t\t(fh_type == 3 || fh_type >= 5) ? fid->raw[2] : 0);\n}\n\nstruct dentry *reiserfs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\tif (fh_type > fh_len)\n\t\tfh_type = fh_len;\n\tif (fh_type < 4)\n\t\treturn NULL;\n\n\treturn reiserfs_get_dentry(sb,\n\t\t(fh_type >= 5) ? fid->raw[3] : fid->raw[2],\n\t\t(fh_type >= 5) ? fid->raw[4] : fid->raw[3],\n\t\t(fh_type == 6) ? fid->raw[5] : 0);\n}\n\nint reiserfs_encode_fh(struct inode *inode, __u32 * data, int *lenp,\n\t\t       struct inode *parent)\n{\n\tint maxlen = *lenp;\n\n\tif (parent && (maxlen < 5)) {\n\t\t*lenp = 5;\n\t\treturn FILEID_INVALID;\n\t} else if (maxlen < 3) {\n\t\t*lenp = 3;\n\t\treturn FILEID_INVALID;\n\t}\n\n\tdata[0] = inode->i_ino;\n\tdata[1] = le32_to_cpu(INODE_PKEY(inode)->k_dir_id);\n\tdata[2] = inode->i_generation;\n\t*lenp = 3;\n\tif (parent) {\n\t\tdata[3] = parent->i_ino;\n\t\tdata[4] = le32_to_cpu(INODE_PKEY(parent)->k_dir_id);\n\t\t*lenp = 5;\n\t\tif (maxlen >= 6) {\n\t\t\tdata[5] = parent->i_generation;\n\t\t\t*lenp = 6;\n\t\t}\n\t}\n\treturn *lenp;\n}\n\n \n \nint reiserfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint jbegin_count = 1;\n\n\tif (sb_rdonly(inode->i_sb))\n\t\treturn -EROFS;\n\t \n\tif (wbc->sync_mode == WB_SYNC_ALL && !(current->flags & PF_MEMALLOC)) {\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (!journal_begin(&th, inode->i_sb, jbegin_count)) {\n\t\t\treiserfs_update_sd(&th, inode);\n\t\t\tjournal_end_sync(&th);\n\t\t}\n\t\treiserfs_write_unlock(inode->i_sb);\n\t}\n\treturn 0;\n}\n\n \nstatic int reiserfs_new_directory(struct reiserfs_transaction_handle *th,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct item_head *ih, struct treepath *path,\n\t\t\t\t  struct inode *dir)\n{\n\tstruct super_block *sb = th->t_super;\n\tchar empty_dir[EMPTY_DIR_SIZE];\n\tchar *body = empty_dir;\n\tstruct cpu_key key;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t_make_cpu_key(&key, KEY_FORMAT_3_5, le32_to_cpu(ih->ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih->ih_key.k_objectid), DOT_OFFSET,\n\t\t      TYPE_DIRENTRY, 3   );\n\n\t \n\tif (old_format_only(sb)) {\n\t\tmake_le_item_head(ih, NULL, KEY_FORMAT_3_5, DOT_OFFSET,\n\t\t\t\t  TYPE_DIRENTRY, EMPTY_DIR_SIZE_V1, 2);\n\n\t\tmake_empty_dir_item_v1(body, ih->ih_key.k_dir_id,\n\t\t\t\t       ih->ih_key.k_objectid,\n\t\t\t\t       INODE_PKEY(dir)->k_dir_id,\n\t\t\t\t       INODE_PKEY(dir)->k_objectid);\n\t} else {\n\t\tmake_le_item_head(ih, NULL, KEY_FORMAT_3_5, DOT_OFFSET,\n\t\t\t\t  TYPE_DIRENTRY, EMPTY_DIR_SIZE, 2);\n\n\t\tmake_empty_dir_item(body, ih->ih_key.k_dir_id,\n\t\t\t\t    ih->ih_key.k_objectid,\n\t\t\t\t    INODE_PKEY(dir)->k_dir_id,\n\t\t\t\t    INODE_PKEY(dir)->k_objectid);\n\t}\n\n\t \n\tretval = search_item(sb, &key, path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(sb, \"vs-13080\",\n\t\t\t       \"i/o failure occurred creating new directory\");\n\t\treturn -EIO;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(path);\n\t\treiserfs_warning(sb, \"vs-13070\",\n\t\t\t\t \"object with this key exists (%k)\",\n\t\t\t\t &(ih->ih_key));\n\t\treturn -EEXIST;\n\t}\n\n\t \n\treturn reiserfs_insert_item(th, path, &key, ih, inode, body);\n}\n\n \nstatic int reiserfs_new_symlink(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct item_head *ih,\n\t\t\t\tstruct treepath *path, const char *symname,\n\t\t\t\tint item_len)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct cpu_key key;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t_make_cpu_key(&key, KEY_FORMAT_3_5,\n\t\t      le32_to_cpu(ih->ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih->ih_key.k_objectid),\n\t\t      1, TYPE_DIRECT, 3   );\n\n\tmake_le_item_head(ih, NULL, KEY_FORMAT_3_5, 1, TYPE_DIRECT, item_len,\n\t\t\t  0   );\n\n\t \n\tretval = search_item(sb, &key, path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(sb, \"vs-13080\",\n\t\t\t       \"i/o failure occurred creating new symlink\");\n\t\treturn -EIO;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(path);\n\t\treiserfs_warning(sb, \"vs-13080\",\n\t\t\t\t \"object with this key exists (%k)\",\n\t\t\t\t &(ih->ih_key));\n\t\treturn -EEXIST;\n\t}\n\n\t \n\treturn reiserfs_insert_item(th, path, &key, ih, inode, symname);\n}\n\n \nint reiserfs_new_inode(struct reiserfs_transaction_handle *th,\n\t\t       struct inode *dir, umode_t mode, const char *symname,\n\t\t        \n\t\t       loff_t i_size, struct dentry *dentry,\n\t\t       struct inode *inode,\n\t\t       struct reiserfs_security_handle *security)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct reiserfs_iget_args args;\n\tINITIALIZE_PATH(path_to_key);\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\tstruct stat_data sd;\n\tint retval;\n\tint err;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tdepth = reiserfs_write_unlock_nested(sb);\n\terr = dquot_alloc_inode(inode);\n\treiserfs_write_lock_nested(sb, depth);\n\tif (err)\n\t\tgoto out_end_trans;\n\tif (!dir->i_nlink) {\n\t\terr = -EPERM;\n\t\tgoto out_bad_inode;\n\t}\n\n\t \n\tih.ih_key.k_dir_id = reiserfs_choose_packing(dir);\n\tih.ih_key.k_objectid = cpu_to_le32(reiserfs_get_unused_objectid(th));\n\tif (!ih.ih_key.k_objectid) {\n\t\terr = -ENOMEM;\n\t\tgoto out_bad_inode;\n\t}\n\targs.objectid = inode->i_ino = le32_to_cpu(ih.ih_key.k_objectid);\n\tif (old_format_only(sb))\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_5, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_V1_SIZE, MAX_US_INT);\n\telse\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_6, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_SIZE, MAX_US_INT);\n\tmemcpy(INODE_PKEY(inode), &ih.ih_key, KEY_SIZE);\n\targs.dirid = le32_to_cpu(ih.ih_key.k_dir_id);\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\terr = insert_inode_locked4(inode, args.objectid,\n\t\t\t     reiserfs_find_actor, &args);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tgoto out_bad_inode;\n\t}\n\n\tif (old_format_only(sb))\n\t\t \n\t\tinode->i_generation = le32_to_cpu(INODE_PKEY(dir)->k_objectid);\n\telse\n#if defined( USE_INODE_GENERATION_COUNTER )\n\t\tinode->i_generation =\n\t\t    le32_to_cpu(REISERFS_SB(sb)->s_rs->s_inode_generation);\n#else\n\t\tinode->i_generation = ++event;\n#endif\n\n\t \n\tset_nlink(inode, (S_ISDIR(mode) ? 2 : 1));\n\n\t \n\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tinode->i_size = i_size;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tREISERFS_I(inode)->i_first_direct_byte = S_ISLNK(mode) ? 1 :\n\t    U32_MAX   ;\n\n\tINIT_LIST_HEAD(&REISERFS_I(inode)->i_prealloc_list);\n\tREISERFS_I(inode)->i_flags = 0;\n\tREISERFS_I(inode)->i_prealloc_block = 0;\n\tREISERFS_I(inode)->i_prealloc_count = 0;\n\tREISERFS_I(inode)->i_trans_id = 0;\n\tREISERFS_I(inode)->i_jl = NULL;\n\tREISERFS_I(inode)->i_attrs =\n\t    REISERFS_I(dir)->i_attrs & REISERFS_INHERIT_MASK;\n\tsd_attrs_to_i_attrs(REISERFS_I(inode)->i_attrs, inode);\n\treiserfs_init_xattr_rwsem(inode);\n\n\t \n\t_make_cpu_key(&key, KEY_FORMAT_3_6, le32_to_cpu(ih.ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih.ih_key.k_objectid), SD_OFFSET,\n\t\t      TYPE_STAT_DATA, 3   );\n\n\t \n\tretval = search_item(sb, &key, &path_to_key);\n\tif (retval == IO_ERROR) {\n\t\terr = -EIO;\n\t\tgoto out_bad_inode;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(&path_to_key);\n\t\terr = -EEXIST;\n\t\tgoto out_bad_inode;\n\t}\n\tif (old_format_only(sb)) {\n\t\t \n\t\tif (i_uid_read(inode) & ~0xffff || i_gid_read(inode) & ~0xffff) {\n\t\t\tpathrelse(&path_to_key);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_bad_inode;\n\t\t}\n\t\tinode2sd_v1(&sd, inode, inode->i_size);\n\t} else {\n\t\tinode2sd(&sd, inode, inode->i_size);\n\t}\n\t \n\tif (old_format_only(sb) || S_ISDIR(mode) || S_ISLNK(mode))\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\telse\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_6);\n\tif (old_format_only(sb))\n\t\tset_inode_sd_version(inode, STAT_DATA_V1);\n\telse\n\t\tset_inode_sd_version(inode, STAT_DATA_V2);\n\n\t \n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (REISERFS_I(dir)->new_packing_locality)\n\t\tth->displace_new_blocks = 1;\n#endif\n\tretval =\n\t    reiserfs_insert_item(th, &path_to_key, &key, &ih, inode,\n\t\t\t\t (char *)(&sd));\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tgoto out_bad_inode;\n\t}\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (!th->displace_new_blocks)\n\t\tREISERFS_I(dir)->new_packing_locality = 0;\n#endif\n\tif (S_ISDIR(mode)) {\n\t\t \n\t\tretval =\n\t\t    reiserfs_new_directory(th, inode, &ih, &path_to_key, dir);\n\t}\n\n\tif (S_ISLNK(mode)) {\n\t\t \n\t\tif (!old_format_only(sb))\n\t\t\ti_size = ROUND_UP(i_size);\n\t\tretval =\n\t\t    reiserfs_new_symlink(th, inode, &ih, &path_to_key, symname,\n\t\t\t\t\t i_size);\n\t}\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tjournal_end(th);\n\t\tgoto out_inserted_sd;\n\t}\n\n\t \n\tif (IS_PRIVATE(dir) || dentry == REISERFS_SB(sb)->priv_root)\n\t\treiserfs_init_priv_inode(inode);\n\n\tif (reiserfs_posixacl(inode->i_sb)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_inherit_default_acl(th, dir, dentry, inode);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tjournal_end(th);\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t} else if (inode->i_sb->s_flags & SB_POSIXACL) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-13090\",\n\t\t\t\t \"ACLs aren't enabled in the fs, \"\n\t\t\t\t \"but vfs thinks they are!\");\n\t}\n\n\tif (security->name) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_security_write(th, inode, security);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tretval = journal_end(th);\n\t\t\tif (retval)\n\t\t\t\terr = retval;\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t}\n\n\treiserfs_update_sd(th, inode);\n\treiserfs_check_path(&path_to_key);\n\n\treturn 0;\n\nout_bad_inode:\n\t \n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t \n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_free_inode(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\nout_end_trans:\n\tjournal_end(th);\n\t \n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_drop(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tinode->i_flags |= S_NOQUOTA;\n\tmake_bad_inode(inode);\n\nout_inserted_sd:\n\tclear_nlink(inode);\n\tth->t_trans_id = 0;\t \n\tif (inode->i_state & I_NEW)\n\t\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}\n\n \nstatic int grab_tail_page(struct inode *inode,\n\t\t\t  struct page **page_result,\n\t\t\t  struct buffer_head **bh_result)\n{\n\n\t \n\tunsigned long index = (inode->i_size - 1) >> PAGE_SHIFT;\n\tunsigned long pos = 0;\n\tunsigned long start = 0;\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\tunsigned long offset = (inode->i_size) & (PAGE_SIZE - 1);\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct page *page;\n\tint error;\n\n\t \n\tif ((offset & (blocksize - 1)) == 0) {\n\t\treturn -ENOENT;\n\t}\n\tpage = grab_cache_page(inode->i_mapping, index);\n\terror = -ENOMEM;\n\tif (!page) {\n\t\tgoto out;\n\t}\n\t \n\tstart = (offset / blocksize) * blocksize;\n\n\terror = __block_write_begin(page, start, offset - start,\n\t\t\t\t    reiserfs_get_block_create_0);\n\tif (error)\n\t\tgoto unlock;\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (pos >= start) {\n\t\t\tbreak;\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tpos += blocksize;\n\t} while (bh != head);\n\n\tif (!buffer_uptodate(bh)) {\n\t\t \n\t\treiserfs_error(inode->i_sb, \"clm-6000\",\n\t\t\t       \"error reading block %lu\", bh->b_blocknr);\n\t\terror = -EIO;\n\t\tgoto unlock;\n\t}\n\t*bh_result = bh;\n\t*page_result = page;\n\nout:\n\treturn error;\n\nunlock:\n\tunlock_page(page);\n\tput_page(page);\n\treturn error;\n}\n\n \nint reiserfs_truncate_file(struct inode *inode, int update_timestamps)\n{\n\tstruct reiserfs_transaction_handle th;\n\t \n\tunsigned long offset = inode->i_size & (PAGE_SIZE - 1);\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned length;\n\tstruct page *page = NULL;\n\tint error;\n\tstruct buffer_head *bh = NULL;\n\tint err2;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\tif (inode->i_size > 0) {\n\t\terror = grab_tail_page(inode, &page, &bh);\n\t\tif (error) {\n\t\t\t \n\t\t\tif (error != -ENOENT)\n\t\t\t\treiserfs_error(inode->i_sb, \"clm-6001\",\n\t\t\t\t\t       \"grab_tail_page failed %d\",\n\t\t\t\t\t       error);\n\t\t\tpage = NULL;\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\n\t \n\terror = journal_begin(&th, inode->i_sb,\n\t\t\t      JOURNAL_PER_BALANCE_CNT * 2 + 1);\n\tif (error)\n\t\tgoto out;\n\treiserfs_update_inode_transaction(inode);\n\tif (update_timestamps)\n\t\t \n\t\tadd_save_link(&th, inode, 1);\n\terr2 = reiserfs_do_truncate(&th, inode, page, update_timestamps);\n\terror = journal_end(&th);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tif (err2) {\n\t\terror = err2;\n  \t\tgoto out;\n\t}\n\t\n\tif (update_timestamps) {\n\t\terror = remove_save_link(inode, 1  );\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (page) {\n\t\tlength = offset & (blocksize - 1);\n\t\t \n\t\tif (length) {\n\t\t\tlength = blocksize - length;\n\t\t\tzero_user(page, offset, length);\n\t\t\tif (buffer_mapped(bh) && bh->b_blocknr != 0) {\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn 0;\nout:\n\tif (page) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn error;\n}\n\nstatic int map_block_for_writepage(struct inode *inode,\n\t\t\t\t   struct buffer_head *bh_result,\n\t\t\t\t   unsigned long block)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint fs_gen;\n\tstruct item_head tmp_ih;\n\tstruct item_head *ih;\n\tstruct buffer_head *bh;\n\t__le32 *item;\n\tstruct cpu_key key;\n\tINITIALIZE_PATH(path);\n\tint pos_in_item;\n\tint jbegin_count = JOURNAL_PER_BALANCE_CNT;\n\tloff_t byte_offset = ((loff_t)block << inode->i_sb->s_blocksize_bits)+1;\n\tint retval;\n\tint use_get_block = 0;\n\tint bytes_copied = 0;\n\tint copy_size;\n\tint trans_running = 0;\n\n\t \n\tth.t_trans_id = 0;\n\n\tif (!buffer_uptodate(bh_result)) {\n\t\treturn -EIO;\n\t}\n\n\tkmap(bh_result->b_page);\nstart_over:\n\treiserfs_write_lock(inode->i_sb);\n\tmake_cpu_key(&key, inode, byte_offset, TYPE_ANY, 3);\n\nresearch:\n\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (retval != POSITION_FOUND) {\n\t\tuse_get_block = 1;\n\t\tgoto out;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\titem = tp_item_body(&path);\n\tpos_in_item = path.pos_in_item;\n\n\t \n\tif (indirect_item_found(retval, ih)) {\n\t\tif (bytes_copied > 0) {\n\t\t\treiserfs_warning(inode->i_sb, \"clm-6002\",\n\t\t\t\t\t \"bytes_copied %d\", bytes_copied);\n\t\t}\n\t\tif (!get_block_num(item, pos_in_item)) {\n\t\t\t \n\t\t\tuse_get_block = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t     get_block_num(item, pos_in_item), inode);\n\t} else if (is_direct_le_ih(ih)) {\n\t\tchar *p;\n\t\tp = page_address(bh_result->b_page);\n\t\tp += (byte_offset - 1) & (PAGE_SIZE - 1);\n\t\tcopy_size = ih_item_len(ih) - pos_in_item;\n\n\t\tfs_gen = get_generation(inode->i_sb);\n\t\tcopy_item_head(&tmp_ih, ih);\n\n\t\tif (!trans_running) {\n\t\t\t \n\t\t\tretval = journal_begin(&th, inode->i_sb, jbegin_count);\n\t\t\tif (retval)\n\t\t\t\tgoto out;\n\t\t\treiserfs_update_inode_transaction(inode);\n\t\t\ttrans_running = 1;\n\t\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\t\treiserfs_restore_prepared_buffer(inode->i_sb,\n\t\t\t\t\t\t\t\t bh);\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t}\n\n\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\treiserfs_restore_prepared_buffer(inode->i_sb, bh);\n\t\t\tgoto research;\n\t\t}\n\n\t\tmemcpy(ih_item_body(bh, ih) + pos_in_item, p + bytes_copied,\n\t\t       copy_size);\n\n\t\tjournal_mark_dirty(&th, bh);\n\t\tbytes_copied += copy_size;\n\t\tset_block_dev_mapped(bh_result, 0, inode);\n\n\t\t \n\t\tif (bytes_copied < bh_result->b_size &&\n\t\t    (byte_offset + bytes_copied) < inode->i_size) {\n\t\t\tset_cpu_key_k_offset(&key,\n\t\t\t\t\t     cpu_key_k_offset(&key) +\n\t\t\t\t\t     copy_size);\n\t\t\tgoto research;\n\t\t}\n\t} else {\n\t\treiserfs_warning(inode->i_sb, \"clm-6003\",\n\t\t\t\t \"bad item inode %lu\", inode->i_ino);\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\tretval = 0;\n\nout:\n\tpathrelse(&path);\n\tif (trans_running) {\n\t\tint err = journal_end(&th);\n\t\tif (err)\n\t\t\tretval = err;\n\t\ttrans_running = 0;\n\t}\n\treiserfs_write_unlock(inode->i_sb);\n\n\t \n\tif (use_get_block) {\n\t\tretval = reiserfs_get_block(inode, block, bh_result,\n\t\t\t\t\t    GET_BLOCK_CREATE | GET_BLOCK_NO_IMUX\n\t\t\t\t\t    | GET_BLOCK_NO_DANGLE);\n\t\tif (!retval) {\n\t\t\tif (!buffer_mapped(bh_result)\n\t\t\t    || bh_result->b_blocknr == 0) {\n\t\t\t\t \n\t\t\t\tuse_get_block = 0;\n\t\t\t\tgoto start_over;\n\t\t\t}\n\t\t}\n\t}\n\tkunmap(bh_result->b_page);\n\n\tif (!retval && buffer_mapped(bh_result) && bh_result->b_blocknr == 0) {\n\t\t \n\t\tlock_buffer(bh_result);\n\t\tclear_buffer_dirty(bh_result);\n\t\tunlock_buffer(bh_result);\n\t}\n\treturn retval;\n}\n\n \nstatic int reiserfs_write_full_page(struct page *page,\n\t\t\t\t    struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tunsigned long end_index = inode->i_size >> PAGE_SHIFT;\n\tint error = 0;\n\tunsigned long block;\n\tsector_t last_block;\n\tstruct buffer_head *head, *bh;\n\tint partial = 0;\n\tint nr = 0;\n\tint checked = PageChecked(page);\n\tstruct reiserfs_transaction_handle th;\n\tstruct super_block *s = inode->i_sb;\n\tint bh_per_page = PAGE_SIZE / s->s_blocksize;\n\tth.t_trans_id = 0;\n\n\t \n\tif (checked && (current->flags & PF_MEMALLOC)) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!page_has_buffers(page)) {\n\t\tcreate_empty_buffers(page, s->s_blocksize,\n\t\t\t\t     (1 << BH_Dirty) | (1 << BH_Uptodate));\n\t}\n\thead = page_buffers(page);\n\n\t \n\tif (page->index >= end_index) {\n\t\tunsigned last_offset;\n\n\t\tlast_offset = inode->i_size & (PAGE_SIZE - 1);\n\t\t \n\t\tif (page->index >= end_index + 1 || !last_offset) {\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t\tzero_user_segment(page, last_offset, PAGE_SIZE);\n\t}\n\tbh = head;\n\tblock = page->index << (PAGE_SHIFT - s->s_blocksize_bits);\n\tlast_block = (i_size_read(inode) - 1) >> inode->i_blkbits;\n\t \n\tdo {\n\t\tif (block > last_block) {\n\t\t\t \n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t} else if ((checked || buffer_dirty(bh)) &&\n\t\t\t   (!buffer_mapped(bh) || bh->b_blocknr == 0)) {\n\t\t\t \n\t\t\tif ((error = map_block_for_writepage(inode, bh, block))) {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tblock++;\n\t} while (bh != head);\n\n\t \n\tif (checked) {\n\t\tClearPageChecked(page);\n\t\treiserfs_write_lock(s);\n\t\terror = journal_begin(&th, s, bh_per_page + 1);\n\t\tif (error) {\n\t\t\treiserfs_write_unlock(s);\n\t\t\tgoto fail;\n\t\t}\n\t\treiserfs_update_inode_transaction(inode);\n\t}\n\t \n\tdo {\n\t\tget_bh(bh);\n\t\tif (!buffer_mapped(bh))\n\t\t\tcontinue;\n\t\tif (buffer_mapped(bh) && bh->b_blocknr == 0)\n\t\t\tcontinue;\n\n\t\tif (checked) {\n\t\t\treiserfs_prepare_for_journal(s, bh, 1);\n\t\t\tjournal_mark_dirty(&th, bh);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\tlock_buffer(bh);\n\t\t} else {\n\t\t\tif (!trylock_buffer(bh)) {\n\t\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\tmark_buffer_async_write(bh);\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\tif (checked) {\n\t\terror = journal_end(&th);\n\t\treiserfs_write_unlock(s);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\n\t \n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh(REQ_OP_WRITE, bh);\n\t\t\tnr++;\n\t\t}\n\t\tput_bh(bh);\n\t\tbh = next;\n\t} while (bh != head);\n\n\terror = 0;\ndone:\n\tif (nr == 0) {\n\t\t \n\t\tbh = head;\n\t\tdo {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tpartial = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t\tif (!partial)\n\t\t\tSetPageUptodate(page);\n\t\tend_page_writeback(page);\n\t}\n\treturn error;\n\nfail:\n\t \n\tClearPageUptodate(page);\n\tbh = head;\n\tdo {\n\t\tget_bh(bh);\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh) && bh->b_blocknr) {\n\t\t\tlock_buffer(bh);\n\t\t\tmark_buffer_async_write(bh);\n\t\t} else {\n\t\t\t \n\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tSetPageError(page);\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tsubmit_bh(REQ_OP_WRITE, bh);\n\t\t\tnr++;\n\t\t}\n\t\tput_bh(bh);\n\t\tbh = next;\n\t} while (bh != head);\n\tgoto done;\n}\n\nstatic int reiserfs_read_folio(struct file *f, struct folio *folio)\n{\n\treturn block_read_full_folio(folio, reiserfs_get_block);\n}\n\nstatic int reiserfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treturn reiserfs_write_full_page(page, wbc);\n}\n\nstatic void reiserfs_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\treiserfs_truncate_file(inode, 0);\n}\n\nstatic int reiserfs_write_begin(struct file *file,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len,\n\t\t\t\tstruct page **pagep, void **fsdata)\n{\n\tstruct inode *inode;\n\tstruct page *page;\n\tpgoff_t index;\n\tint ret;\n\tint old_ref = 0;\n\n \tinode = mapping->host;\n\tindex = pos >> PAGE_SHIFT;\n\tpage = grab_cache_page_write_begin(mapping, index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\n\treiserfs_wait_on_write_block(inode->i_sb);\n\tfix_tail_page_for_writing(page);\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th;\n\t\tth = (struct reiserfs_transaction_handle *)current->\n\t\t    journal_info;\n\t\tBUG_ON(!th->t_refcount);\n\t\tBUG_ON(!th->t_trans_id);\n\t\told_ref = th->t_refcount;\n\t\tth->t_refcount++;\n\t}\n\tret = __block_write_begin(page, pos, len, reiserfs_get_block);\n\tif (ret && reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\t\t \n\t\tif (th->t_refcount > old_ref) {\n\t\t\tif (old_ref)\n\t\t\t\tth->t_refcount--;\n\t\t\telse {\n\t\t\t\tint err;\n\t\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\t\terr = reiserfs_end_persistent_transaction(th);\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tif (err)\n\t\t\t\t\tret = err;\n\t\t\t}\n\t\t}\n\t}\n\tif (ret) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\t \n\t\treiserfs_truncate_failed_write(inode);\n\t}\n\treturn ret;\n}\n\nint __reiserfs_write_begin(struct page *page, unsigned from, unsigned len)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret;\n\tint old_ref = 0;\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\tfix_tail_page_for_writing(page);\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th;\n\t\tth = (struct reiserfs_transaction_handle *)current->\n\t\t    journal_info;\n\t\tBUG_ON(!th->t_refcount);\n\t\tBUG_ON(!th->t_trans_id);\n\t\told_ref = th->t_refcount;\n\t\tth->t_refcount++;\n\t}\n\n\tret = __block_write_begin(page, from, len, reiserfs_get_block);\n\tif (ret && reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\t\t \n\t\tif (th->t_refcount > old_ref) {\n\t\t\tif (old_ref)\n\t\t\t\tth->t_refcount--;\n\t\t\telse {\n\t\t\t\tint err;\n\t\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\t\terr = reiserfs_end_persistent_transaction(th);\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tif (err)\n\t\t\t\t\tret = err;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n\n}\n\nstatic sector_t reiserfs_aop_bmap(struct address_space *as, sector_t block)\n{\n\treturn generic_block_bmap(as, block, reiserfs_bmap);\n}\n\nstatic int reiserfs_write_end(struct file *file, struct address_space *mapping,\n\t\t\t      loff_t pos, unsigned len, unsigned copied,\n\t\t\t      struct page *page, void *fsdata)\n{\n\tstruct folio *folio = page_folio(page);\n\tstruct inode *inode = page->mapping->host;\n\tint ret = 0;\n\tint update_sd = 0;\n\tstruct reiserfs_transaction_handle *th;\n\tunsigned start;\n\tbool locked = false;\n\n\treiserfs_wait_on_write_block(inode->i_sb);\n\tif (reiserfs_transaction_running(inode->i_sb))\n\t\tth = current->journal_info;\n\telse\n\t\tth = NULL;\n\n\tstart = pos & (PAGE_SIZE - 1);\n\tif (unlikely(copied < len)) {\n\t\tif (!folio_test_uptodate(folio))\n\t\t\tcopied = 0;\n\n\t\tfolio_zero_new_buffers(folio, start + copied, start + len);\n\t}\n\tflush_dcache_folio(folio);\n\n\treiserfs_commit_page(inode, page, start, start + copied);\n\n\t \n\tif (pos + copied > inode->i_size) {\n\t\tstruct reiserfs_transaction_handle myth;\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tlocked = true;\n\t\t \n\t\tif ((have_large_tails(inode->i_sb)\n\t\t     && inode->i_size > i_block_size(inode) * 4)\n\t\t    || (have_small_tails(inode->i_sb)\n\t\t\t&& inode->i_size > i_block_size(inode)))\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\n\t\tret = journal_begin(&myth, inode->i_sb, 1);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\n\t\treiserfs_update_inode_transaction(inode);\n\t\tinode->i_size = pos + copied;\n\t\t \n\t\tmark_inode_dirty(inode);\n\t\treiserfs_update_sd(&myth, inode);\n\t\tupdate_sd = 1;\n\t\tret = journal_end(&myth);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\t}\n\tif (th) {\n\t\tif (!locked) {\n\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\tlocked = true;\n\t\t}\n\t\tif (!update_sd)\n\t\t\tmark_inode_dirty(inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (locked)\n\t\treiserfs_write_unlock(inode->i_sb);\n\tunlock_page(page);\n\tput_page(page);\n\n\tif (pos + len > inode->i_size)\n\t\treiserfs_truncate_failed_write(inode);\n\n\treturn ret == 0 ? copied : ret;\n\njournal_error:\n\treiserfs_write_unlock(inode->i_sb);\n\tlocked = false;\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\treiserfs_update_sd(th, inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t}\n\tgoto out;\n}\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tloff_t pos = ((loff_t) page->index << PAGE_SHIFT) + to;\n\tint ret = 0;\n\tint update_sd = 0;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tth = current->journal_info;\n\t}\n\treiserfs_commit_page(inode, page, from, to);\n\n\t \n\tif (pos > inode->i_size) {\n\t\tstruct reiserfs_transaction_handle myth;\n\t\t \n\t\tif ((have_large_tails(inode->i_sb)\n\t\t     && inode->i_size > i_block_size(inode) * 4)\n\t\t    || (have_small_tails(inode->i_sb)\n\t\t\t&& inode->i_size > i_block_size(inode)))\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\n\t\tret = journal_begin(&myth, inode->i_sb, 1);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\n\t\treiserfs_update_inode_transaction(inode);\n\t\tinode->i_size = pos;\n\t\t \n\t\tmark_inode_dirty(inode);\n\t\treiserfs_update_sd(&myth, inode);\n\t\tupdate_sd = 1;\n\t\tret = journal_end(&myth);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\t}\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\tmark_inode_dirty(inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n\njournal_error:\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\treiserfs_update_sd(th, inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t}\n\n\treturn ret;\n}\n\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode)\n{\n\tif (reiserfs_attrs(inode->i_sb)) {\n\t\tif (sd_attrs & REISERFS_SYNC_FL)\n\t\t\tinode->i_flags |= S_SYNC;\n\t\telse\n\t\t\tinode->i_flags &= ~S_SYNC;\n\t\tif (sd_attrs & REISERFS_IMMUTABLE_FL)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t\telse\n\t\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t\tif (sd_attrs & REISERFS_APPEND_FL)\n\t\t\tinode->i_flags |= S_APPEND;\n\t\telse\n\t\t\tinode->i_flags &= ~S_APPEND;\n\t\tif (sd_attrs & REISERFS_NOATIME_FL)\n\t\t\tinode->i_flags |= S_NOATIME;\n\t\telse\n\t\t\tinode->i_flags &= ~S_NOATIME;\n\t\tif (sd_attrs & REISERFS_NOTAIL_FL)\n\t\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_nopack_mask;\n\t}\n}\n\n \nstatic int invalidate_folio_can_drop(struct inode *inode, struct buffer_head *bh)\n{\n\tint ret = 1;\n\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\n\tlock_buffer(bh);\n\tspin_lock(&j->j_dirty_buffers_lock);\n\tif (!buffer_mapped(bh)) {\n\t\tgoto free_jh;\n\t}\n\t \n\tif (reiserfs_file_data_log(inode)) {\n\t\t \n\t\tif (buffer_journaled(bh) || buffer_journal_dirty(bh)) {\n\t\t\tret = 0;\n\t\t}\n\t} else  if (buffer_dirty(bh)) {\n\t\tstruct reiserfs_journal_list *jl;\n\t\tstruct reiserfs_jh *jh = bh->b_private;\n\n\t\t \n\t\tif (jh && (jl = jh->jl)\n\t\t    && jl != SB_JOURNAL(inode->i_sb)->j_current_jl)\n\t\t\tret = 0;\n\t}\nfree_jh:\n\tif (ret && bh->b_private) {\n\t\treiserfs_free_jh(bh);\n\t}\n\tspin_unlock(&j->j_dirty_buffers_lock);\n\tunlock_buffer(bh);\n\treturn ret;\n}\n\n \nstatic void reiserfs_invalidate_folio(struct folio *folio, size_t offset,\n\t\t\t\t    size_t length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tstruct inode *inode = folio->mapping->host;\n\tunsigned int curr_off = 0;\n\tunsigned int stop = offset + length;\n\tint partial_page = (offset || length < folio_size(folio));\n\tint ret = 1;\n\n\tBUG_ON(!folio_test_locked(folio));\n\n\tif (!partial_page)\n\t\tfolio_clear_checked(folio);\n\n\thead = folio_buffers(folio);\n\tif (!head)\n\t\tgoto out;\n\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\tif (next_off > stop)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (offset <= curr_off) {\n\t\t\tif (invalidate_folio_can_drop(inode, bh))\n\t\t\t\treiserfs_unmap_buffer(bh);\n\t\t\telse\n\t\t\t\tret = 0;\n\t\t}\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\t} while (bh != head);\n\n\t \n\tif (!partial_page && ret) {\n\t\tret = filemap_release_folio(folio, 0);\n\t\t \n\t}\nout:\n\treturn;\n}\n\nstatic bool reiserfs_dirty_folio(struct address_space *mapping,\n\t\tstruct folio *folio)\n{\n\tif (reiserfs_file_data_log(mapping->host)) {\n\t\tfolio_set_checked(folio);\n\t\treturn filemap_dirty_folio(mapping, folio);\n\t}\n\treturn block_dirty_folio(mapping, folio);\n}\n\n \nstatic bool reiserfs_release_folio(struct folio *folio, gfp_t unused_gfp_flags)\n{\n\tstruct inode *inode = folio->mapping->host;\n\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\tstruct buffer_head *head;\n\tstruct buffer_head *bh;\n\tbool ret = true;\n\n\tWARN_ON(folio_test_checked(folio));\n\tspin_lock(&j->j_dirty_buffers_lock);\n\thead = folio_buffers(folio);\n\tbh = head;\n\tdo {\n\t\tif (bh->b_private) {\n\t\t\tif (!buffer_dirty(bh) && !buffer_locked(bh)) {\n\t\t\t\treiserfs_free_jh(bh);\n\t\t\t} else {\n\t\t\t\tret = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tif (ret)\n\t\tret = try_to_free_buffers(folio);\n\tspin_unlock(&j->j_dirty_buffers_lock);\n\treturn ret;\n}\n\n \nstatic ssize_t reiserfs_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tret = blockdev_direct_IO(iocb, inode, iter,\n\t\t\t\t reiserfs_get_blocks_direct_io);\n\n\t \n\tif (unlikely(iov_iter_rw(iter) == WRITE && ret < 0)) {\n\t\tloff_t isize = i_size_read(inode);\n\t\tloff_t end = iocb->ki_pos + count;\n\n\t\tif ((end > isize) && inode_newsize_ok(inode, isize) == 0) {\n\t\t\ttruncate_setsize(inode, isize);\n\t\t\treiserfs_vfs_truncate_file(inode);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint reiserfs_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t     struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tunsigned int ia_valid;\n\tint error;\n\n\terror = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\tif (error)\n\t\treturn error;\n\n\t \n\tia_valid = attr->ia_valid &= ~(ATTR_KILL_SUID|ATTR_KILL_SGID);\n\n\tif (is_quota_modification(&nop_mnt_idmap, inode, attr)) {\n\t\terror = dquot_initialize(inode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treiserfs_write_lock(inode->i_sb);\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t \n\t\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5 &&\n\t\t    attr->ia_size > MAX_NON_LFS) {\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\terror = -EFBIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode_dio_wait(inode);\n\n\t\t \n\t\tif (attr->ia_size > inode->i_size) {\n\t\t\tloff_t pos = attr->ia_size;\n\n\t\t\tif ((pos & (inode->i_sb->s_blocksize - 1)) == 0)\n\t\t\t\tpos++;\n\t\t\terror = generic_cont_expand_simple(inode, pos);\n\t\t\tif (REISERFS_I(inode)->i_prealloc_count > 0) {\n\t\t\t\tint err;\n\t\t\t\tstruct reiserfs_transaction_handle th;\n\t\t\t\t \n\t\t\t\terr = journal_begin(&th, inode->i_sb, 4);\n\t\t\t\tif (!err) {\n\t\t\t\t\treiserfs_discard_prealloc(&th, inode);\n\t\t\t\t\terr = journal_end(&th);\n\t\t\t\t}\n\t\t\t\tif (err)\n\t\t\t\t\terror = err;\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\tattr->ia_valid |= (ATTR_MTIME | ATTR_CTIME);\n\t\t}\n\t}\n\treiserfs_write_unlock(inode->i_sb);\n\n\tif ((((attr->ia_valid & ATTR_UID) && (from_kuid(&init_user_ns, attr->ia_uid) & ~0xffff)) ||\n\t     ((attr->ia_valid & ATTR_GID) && (from_kgid(&init_user_ns, attr->ia_gid) & ~0xffff))) &&\n\t    (get_inode_sd_version(inode) == STAT_DATA_V1)) {\n\t\t \n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||\n\t    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {\n\t\tstruct reiserfs_transaction_handle th;\n\t\tint jbegin_count =\n\t\t    2 *\n\t\t    (REISERFS_QUOTA_INIT_BLOCKS(inode->i_sb) +\n\t\t     REISERFS_QUOTA_DEL_BLOCKS(inode->i_sb)) +\n\t\t    2;\n\n\t\terror = reiserfs_chown_xattrs(inode, attr);\n\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\treiserfs_write_lock(inode->i_sb);\n\t\terror = journal_begin(&th, inode->i_sb, jbegin_count);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = dquot_transfer(&nop_mnt_idmap, inode, attr);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (error) {\n\t\t\tjournal_end(&th);\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (attr->ia_valid & ATTR_UID)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif (attr->ia_valid & ATTR_GID)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\tmark_inode_dirty(inode);\n\t\terror = journal_end(&th);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (!error) {\n\t\t\t \n\t\t\tmutex_lock(&REISERFS_I(inode)->tailpack);\n\t\t\ttruncate_setsize(inode, attr->ia_size);\n\t\t\treiserfs_truncate_file(inode, 1);\n\t\t\tmutex_unlock(&REISERFS_I(inode)->tailpack);\n\t\t}\n\t}\n\n\tif (!error) {\n\t\tsetattr_copy(&nop_mnt_idmap, inode, attr);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (!error && reiserfs_posixacl(inode->i_sb)) {\n\t\tif (attr->ia_valid & ATTR_MODE)\n\t\t\terror = reiserfs_acl_chmod(dentry);\n\t}\n\nout:\n\treturn error;\n}\n\nconst struct address_space_operations reiserfs_address_space_operations = {\n\t.writepage = reiserfs_writepage,\n\t.read_folio = reiserfs_read_folio,\n\t.readahead = reiserfs_readahead,\n\t.release_folio = reiserfs_release_folio,\n\t.invalidate_folio = reiserfs_invalidate_folio,\n\t.write_begin = reiserfs_write_begin,\n\t.write_end = reiserfs_write_end,\n\t.bmap = reiserfs_aop_bmap,\n\t.direct_IO = reiserfs_direct_IO,\n\t.dirty_folio = reiserfs_dirty_folio,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}