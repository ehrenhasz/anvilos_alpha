{
  "module_name": "prints.c",
  "hash_id": "ca86a54df1718858cba83f210cd36bc3d8bad54518abbec7c66a6d7a47ec7b46",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/prints.c",
  "human_readable_source": " \n\n#include <linux/time.h>\n#include <linux/fs.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\n#include <linux/stdarg.h>\n\nstatic char error_buf[1024];\nstatic char fmt_buf[1024];\nstatic char off_buf[80];\n\nstatic char *reiserfs_cpu_offset(struct cpu_key *key)\n{\n\tif (cpu_key_k_type(key) == TYPE_DIRENTRY)\n\t\tsprintf(off_buf, \"%llu(%llu)\",\n\t\t\t(unsigned long long)\n\t\t\tGET_HASH_VALUE(cpu_key_k_offset(key)),\n\t\t\t(unsigned long long)\n\t\t\tGET_GENERATION_NUMBER(cpu_key_k_offset(key)));\n\telse\n\t\tsprintf(off_buf, \"0x%Lx\",\n\t\t\t(unsigned long long)cpu_key_k_offset(key));\n\treturn off_buf;\n}\n\nstatic char *le_offset(struct reiserfs_key *key)\n{\n\tint version;\n\n\tversion = le_key_version(key);\n\tif (le_key_k_type(version, key) == TYPE_DIRENTRY)\n\t\tsprintf(off_buf, \"%llu(%llu)\",\n\t\t\t(unsigned long long)\n\t\t\tGET_HASH_VALUE(le_key_k_offset(version, key)),\n\t\t\t(unsigned long long)\n\t\t\tGET_GENERATION_NUMBER(le_key_k_offset(version, key)));\n\telse\n\t\tsprintf(off_buf, \"0x%Lx\",\n\t\t\t(unsigned long long)le_key_k_offset(version, key));\n\treturn off_buf;\n}\n\nstatic char *cpu_type(struct cpu_key *key)\n{\n\tif (cpu_key_k_type(key) == TYPE_STAT_DATA)\n\t\treturn \"SD\";\n\tif (cpu_key_k_type(key) == TYPE_DIRENTRY)\n\t\treturn \"DIR\";\n\tif (cpu_key_k_type(key) == TYPE_DIRECT)\n\t\treturn \"DIRECT\";\n\tif (cpu_key_k_type(key) == TYPE_INDIRECT)\n\t\treturn \"IND\";\n\treturn \"UNKNOWN\";\n}\n\nstatic char *le_type(struct reiserfs_key *key)\n{\n\tint version;\n\n\tversion = le_key_version(key);\n\n\tif (le_key_k_type(version, key) == TYPE_STAT_DATA)\n\t\treturn \"SD\";\n\tif (le_key_k_type(version, key) == TYPE_DIRENTRY)\n\t\treturn \"DIR\";\n\tif (le_key_k_type(version, key) == TYPE_DIRECT)\n\t\treturn \"DIRECT\";\n\tif (le_key_k_type(version, key) == TYPE_INDIRECT)\n\t\treturn \"IND\";\n\treturn \"UNKNOWN\";\n}\n\n \nstatic int scnprintf_le_key(char *buf, size_t size, struct reiserfs_key *key)\n{\n\tif (key)\n\t\treturn scnprintf(buf, size, \"[%d %d %s %s]\",\n\t\t\t\t le32_to_cpu(key->k_dir_id),\n\t\t\t\t le32_to_cpu(key->k_objectid), le_offset(key),\n\t\t\t\t le_type(key));\n\telse\n\t\treturn scnprintf(buf, size, \"[NULL]\");\n}\n\n \nstatic int scnprintf_cpu_key(char *buf, size_t size, struct cpu_key *key)\n{\n\tif (key)\n\t\treturn scnprintf(buf, size, \"[%d %d %s %s]\",\n\t\t\t\t key->on_disk_key.k_dir_id,\n\t\t\t\t key->on_disk_key.k_objectid,\n\t\t\t\t reiserfs_cpu_offset(key), cpu_type(key));\n\telse\n\t\treturn scnprintf(buf, size, \"[NULL]\");\n}\n\nstatic int scnprintf_de_head(char *buf, size_t size,\n\t\t\t     struct reiserfs_de_head *deh)\n{\n\tif (deh)\n\t\treturn scnprintf(buf, size,\n\t\t\t\t \"[offset=%d dir_id=%d objectid=%d location=%d state=%04x]\",\n\t\t\t\t deh_offset(deh), deh_dir_id(deh),\n\t\t\t\t deh_objectid(deh), deh_location(deh),\n\t\t\t\t deh_state(deh));\n\telse\n\t\treturn scnprintf(buf, size, \"[NULL]\");\n\n}\n\nstatic int scnprintf_item_head(char *buf, size_t size, struct item_head *ih)\n{\n\tif (ih) {\n\t\tchar *p = buf;\n\t\tchar * const end = buf + size;\n\n\t\tp += scnprintf(p, end - p, \"%s\",\n\t\t\t       (ih_version(ih) == KEY_FORMAT_3_6) ?\n\t\t\t       \"*3.6* \" : \"*3.5*\");\n\n\t\tp += scnprintf_le_key(p, end - p, &ih->ih_key);\n\n\t\tp += scnprintf(p, end - p,\n\t\t\t       \", item_len %d, item_location %d, free_space(entry_count) %d\",\n\t\t\t       ih_item_len(ih), ih_location(ih),\n\t\t\t       ih_free_space(ih));\n\t\treturn p - buf;\n\t} else\n\t\treturn scnprintf(buf, size, \"[NULL]\");\n}\n\nstatic int scnprintf_direntry(char *buf, size_t size,\n\t\t\t      struct reiserfs_dir_entry *de)\n{\n\tchar name[20];\n\n\tmemcpy(name, de->de_name, de->de_namelen > 19 ? 19 : de->de_namelen);\n\tname[de->de_namelen > 19 ? 19 : de->de_namelen] = 0;\n\treturn scnprintf(buf, size, \"\\\"%s\\\"==>[%d %d]\",\n\t\t\t name, de->de_dir_id, de->de_objectid);\n}\n\nstatic int scnprintf_block_head(char *buf, size_t size, struct buffer_head *bh)\n{\n\treturn scnprintf(buf, size,\n\t\t\t \"level=%d, nr_items=%d, free_space=%d rdkey \",\n\t\t\t B_LEVEL(bh), B_NR_ITEMS(bh), B_FREE_SPACE(bh));\n}\n\nstatic int scnprintf_buffer_head(char *buf, size_t size, struct buffer_head *bh)\n{\n\treturn scnprintf(buf, size,\n\t\t\t \"dev %pg, size %zd, blocknr %llu, count %d, state 0x%lx, page %p, (%s, %s, %s)\",\n\t\t\t bh->b_bdev, bh->b_size,\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t atomic_read(&(bh->b_count)),\n\t\t\t bh->b_state, bh->b_page,\n\t\t\t buffer_uptodate(bh) ? \"UPTODATE\" : \"!UPTODATE\",\n\t\t\t buffer_dirty(bh) ? \"DIRTY\" : \"CLEAN\",\n\t\t\t buffer_locked(bh) ? \"LOCKED\" : \"UNLOCKED\");\n}\n\nstatic int scnprintf_disk_child(char *buf, size_t size, struct disk_child *dc)\n{\n\treturn scnprintf(buf, size, \"[dc_number=%d, dc_size=%u]\",\n\t\t\t dc_block_number(dc), dc_size(dc));\n}\n\nstatic char *is_there_reiserfs_struct(char *fmt, int *what)\n{\n\tchar *k = fmt;\n\n\twhile ((k = strchr(k, '%')) != NULL) {\n\t\tif (k[1] == 'k' || k[1] == 'K' || k[1] == 'h' || k[1] == 't' ||\n\t\t    k[1] == 'z' || k[1] == 'b' || k[1] == 'y' || k[1] == 'a') {\n\t\t\t*what = k[1];\n\t\t\tbreak;\n\t\t}\n\t\tk++;\n\t}\n\treturn k;\n}\n\n \nstatic DEFINE_SPINLOCK(error_lock);\nstatic void prepare_error_buf(const char *fmt, va_list args)\n{\n\tchar *fmt1 = fmt_buf;\n\tchar *k;\n\tchar *p = error_buf;\n\tchar * const end = &error_buf[sizeof(error_buf)];\n\tint what;\n\n\tspin_lock(&error_lock);\n\n\tif (WARN_ON(strscpy(fmt_buf, fmt, sizeof(fmt_buf)) < 0)) {\n\t\tstrscpy(error_buf, \"format string too long\", end - error_buf);\n\t\tgoto out_unlock;\n\t}\n\n\twhile ((k = is_there_reiserfs_struct(fmt1, &what)) != NULL) {\n\t\t*k = 0;\n\n\t\tp += vscnprintf(p, end - p, fmt1, args);\n\n\t\tswitch (what) {\n\t\tcase 'k':\n\t\t\tp += scnprintf_le_key(p, end - p,\n\t\t\t\t\t      va_arg(args, struct reiserfs_key *));\n\t\t\tbreak;\n\t\tcase 'K':\n\t\t\tp += scnprintf_cpu_key(p, end - p,\n\t\t\t\t\t       va_arg(args, struct cpu_key *));\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tp += scnprintf_item_head(p, end - p,\n\t\t\t\t\t\t va_arg(args, struct item_head *));\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tp += scnprintf_direntry(p, end - p,\n\t\t\t\t\t\tva_arg(args, struct reiserfs_dir_entry *));\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tp += scnprintf_disk_child(p, end - p,\n\t\t\t\t\t\t  va_arg(args, struct disk_child *));\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tp += scnprintf_block_head(p, end - p,\n\t\t\t\t\t\t  va_arg(args, struct buffer_head *));\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tp += scnprintf_buffer_head(p, end - p,\n\t\t\t\t\t\t   va_arg(args, struct buffer_head *));\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tp += scnprintf_de_head(p, end - p,\n\t\t\t\t\t       va_arg(args, struct reiserfs_de_head *));\n\t\t\tbreak;\n\t\t}\n\n\t\tfmt1 = k + 2;\n\t}\n\tp += vscnprintf(p, end - p, fmt1, args);\nout_unlock:\n\tspin_unlock(&error_lock);\n\n}\n\n \n\n#define do_reiserfs_warning(fmt)\\\n{\\\n    va_list args;\\\n    va_start( args, fmt );\\\n    prepare_error_buf( fmt, args );\\\n    va_end( args );\\\n}\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}\n\n \nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}\n\n \nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}\n\nvoid reiserfs_debug(struct super_block *s, int level, const char *fmt, ...)\n{\n#ifdef CONFIG_REISERFS_CHECK\n\tdo_reiserfs_warning(fmt);\n\tif (s)\n\t\tprintk(KERN_DEBUG \"REISERFS debug (device %s): %s\\n\",\n\t\t       s->s_id, error_buf);\n\telse\n\t\tprintk(KERN_DEBUG \"REISERFS debug: %s\\n\", error_buf);\n#endif\n}\n\n \n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb_rdonly(sb))\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= SB_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}\n\nvoid reiserfs_abort(struct super_block *sb, int errno, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tif (reiserfs_error_panic(sb)) {\n\t\tpanic(KERN_CRIT \"REISERFS panic (device %s): %s\\n\", sb->s_id,\n\t\t      error_buf);\n\t}\n\n\tif (reiserfs_is_journal_aborted(SB_JOURNAL(sb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"REISERFS abort (device %s): %s\\n\", sb->s_id,\n\t       error_buf);\n\n\tsb->s_flags |= SB_RDONLY;\n\treiserfs_abort_journal(sb, errno);\n}\n\n \nstatic int print_internal(struct buffer_head *bh, int first, int last)\n{\n\tstruct reiserfs_key *key;\n\tstruct disk_child *dc;\n\tint i;\n\tint from, to;\n\n\tif (!B_IS_KEYS_LEVEL(bh))\n\t\treturn 1;\n\n\tcheck_internal(bh);\n\n\tif (first == -1) {\n\t\tfrom = 0;\n\t\tto = B_NR_ITEMS(bh);\n\t} else {\n\t\tfrom = first;\n\t\tto = min_t(int, last, B_NR_ITEMS(bh));\n\t}\n\n\treiserfs_printk(\"INTERNAL NODE (%ld) contains %z\\n\", bh->b_blocknr, bh);\n\n\tdc = B_N_CHILD(bh, from);\n\treiserfs_printk(\"PTR %d: %y \", from, dc);\n\n\tfor (i = from, key = internal_key(bh, from), dc++; i < to;\n\t     i++, key++, dc++) {\n\t\treiserfs_printk(\"KEY %d: %k PTR %d: %y \", i, key, i + 1, dc);\n\t\tif (i && i % 4 == 0)\n\t\t\tprintk(\"\\n\");\n\t}\n\tprintk(\"\\n\");\n\treturn 0;\n}\n\nstatic int print_leaf(struct buffer_head *bh, int print_mode, int first,\n\t\t      int last)\n{\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i, nr;\n\tint from, to;\n\n\tif (!B_IS_ITEMS_LEVEL(bh))\n\t\treturn 1;\n\n\tcheck_leaf(bh);\n\n\tblkh = B_BLK_HEAD(bh);\n\tih = item_head(bh, 0);\n\tnr = blkh_nr_item(blkh);\n\n\tprintk\n\t    (\"\\n===================================================================\\n\");\n\treiserfs_printk(\"LEAF NODE (%ld) contains %z\\n\", bh->b_blocknr, bh);\n\n\tif (!(print_mode & PRINT_LEAF_ITEMS)) {\n\t\treiserfs_printk(\"FIRST ITEM_KEY: %k, LAST ITEM KEY: %k\\n\",\n\t\t\t\t&(ih->ih_key), &((ih + nr - 1)->ih_key));\n\t\treturn 0;\n\t}\n\n\tif (first < 0 || first > nr - 1)\n\t\tfrom = 0;\n\telse\n\t\tfrom = first;\n\n\tif (last < 0 || last > nr)\n\t\tto = nr;\n\telse\n\t\tto = last;\n\n\tih += from;\n\tprintk\n\t    (\"-------------------------------------------------------------------------------\\n\");\n\tprintk\n\t    (\"|##|   type    |           key           | ilen | free_space | version | loc  |\\n\");\n\tfor (i = from; i < to; i++, ih++) {\n\t\tprintk\n\t\t    (\"-------------------------------------------------------------------------------\\n\");\n\t\treiserfs_printk(\"|%2d| %h |\\n\", i, ih);\n\t\tif (print_mode & PRINT_LEAF_ITEMS)\n\t\t\top_print_item(ih, ih_item_body(bh, ih));\n\t}\n\n\tprintk\n\t    (\"===================================================================\\n\");\n\n\treturn 0;\n}\n\nchar *reiserfs_hashname(int code)\n{\n\tif (code == YURA_HASH)\n\t\treturn \"rupasov\";\n\tif (code == TEA_HASH)\n\t\treturn \"tea\";\n\tif (code == R5_HASH)\n\t\treturn \"r5\";\n\n\treturn \"unknown\";\n}\n\n \nstatic int print_super_block(struct buffer_head *bh)\n{\n\tstruct reiserfs_super_block *rs =\n\t    (struct reiserfs_super_block *)(bh->b_data);\n\tint skipped, data_blocks;\n\tchar *version;\n\n\tif (is_reiserfs_3_5(rs)) {\n\t\tversion = \"3.5\";\n\t} else if (is_reiserfs_3_6(rs)) {\n\t\tversion = \"3.6\";\n\t} else if (is_reiserfs_jr(rs)) {\n\t\tversion = ((sb_version(rs) == REISERFS_VERSION_2) ?\n\t\t\t   \"3.6\" : \"3.5\");\n\t} else {\n\t\treturn 1;\n\t}\n\n\tprintk(\"%pg\\'s super block is in block %llu\\n\", bh->b_bdev,\n\t       (unsigned long long)bh->b_blocknr);\n\tprintk(\"Reiserfs version %s\\n\", version);\n\tprintk(\"Block count %u\\n\", sb_block_count(rs));\n\tprintk(\"Blocksize %d\\n\", sb_blocksize(rs));\n\tprintk(\"Free blocks %u\\n\", sb_free_blocks(rs));\n\t \n\tskipped = bh->b_blocknr;\n\tdata_blocks = sb_block_count(rs) - skipped - 1 - sb_bmap_nr(rs) -\n\t    (!is_reiserfs_jr(rs) ? sb_jp_journal_size(rs) +\n\t     1 : sb_reserved_for_journal(rs)) - sb_free_blocks(rs);\n\tprintk\n\t    (\"Busy blocks (skipped %d, bitmaps - %d, journal (or reserved) blocks - %d\\n\"\n\t     \"1 super block, %d data blocks\\n\", skipped, sb_bmap_nr(rs),\n\t     (!is_reiserfs_jr(rs) ? (sb_jp_journal_size(rs) + 1) :\n\t      sb_reserved_for_journal(rs)), data_blocks);\n\tprintk(\"Root block %u\\n\", sb_root_block(rs));\n\tprintk(\"Journal block (first) %d\\n\", sb_jp_journal_1st_block(rs));\n\tprintk(\"Journal dev %d\\n\", sb_jp_journal_dev(rs));\n\tprintk(\"Journal orig size %d\\n\", sb_jp_journal_size(rs));\n\tprintk(\"FS state %d\\n\", sb_fs_state(rs));\n\tprintk(\"Hash function \\\"%s\\\"\\n\",\n\t       reiserfs_hashname(sb_hash_function_code(rs)));\n\n\tprintk(\"Tree height %d\\n\", sb_tree_height(rs));\n\treturn 0;\n}\n\nstatic int print_desc_block(struct buffer_head *bh)\n{\n\tstruct reiserfs_journal_desc *desc;\n\n\tif (memcmp(get_journal_desc_magic(bh), JOURNAL_DESC_MAGIC, 8))\n\t\treturn 1;\n\n\tdesc = (struct reiserfs_journal_desc *)(bh->b_data);\n\tprintk(\"Desc block %llu (j_trans_id %d, j_mount_id %d, j_len %d)\",\n\t       (unsigned long long)bh->b_blocknr, get_desc_trans_id(desc),\n\t       get_desc_mount_id(desc), get_desc_trans_len(desc));\n\n\treturn 0;\n}\n \nvoid print_block(struct buffer_head *bh, ...)\n{\n\tva_list args;\n\tint mode, first, last;\n\n\tif (!bh) {\n\t\tprintk(\"print_block: buffer is NULL\\n\");\n\t\treturn;\n\t}\n\n\tva_start(args, bh);\n\n\tmode = va_arg(args, int);\n\tfirst = va_arg(args, int);\n\tlast = va_arg(args, int);\n\tif (print_leaf(bh, mode, first, last))\n\t\tif (print_internal(bh, first, last))\n\t\t\tif (print_super_block(bh))\n\t\t\t\tif (print_desc_block(bh))\n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"Block %llu contains unformatted data\\n\",\n\t\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\n\tva_end(args);\n}\n\nstatic char print_tb_buf[2048];\n\n \nvoid store_print_tb(struct tree_balance *tb)\n{\n\tint h = 0;\n\tint i;\n\tstruct buffer_head *tbSh, *tbFh;\n\n\tif (!tb)\n\t\treturn;\n\n\tsprintf(print_tb_buf, \"\\n\"\n\t\t\"BALANCING %d\\n\"\n\t\t\"MODE=%c, ITEM_POS=%d POS_IN_ITEM=%d\\n\"\n\t\t\"=====================================================================\\n\"\n\t\t\"* h *    S    *    L    *    R    *   F   *   FL  *   FR  *  CFL  *  CFR  *\\n\",\n\t\tREISERFS_SB(tb->tb_sb)->s_do_balance,\n\t\ttb->tb_mode, PATH_LAST_POSITION(tb->tb_path),\n\t\ttb->tb_path->pos_in_item);\n\n\tfor (h = 0; h < ARRAY_SIZE(tb->insert_size); h++) {\n\t\tif (PATH_H_PATH_OFFSET(tb->tb_path, h) <=\n\t\t    tb->tb_path->path_length\n\t\t    && PATH_H_PATH_OFFSET(tb->tb_path,\n\t\t\t\t\t  h) > ILLEGAL_PATH_ELEMENT_OFFSET) {\n\t\t\ttbSh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\t\ttbFh = PATH_H_PPARENT(tb->tb_path, h);\n\t\t} else {\n\t\t\ttbSh = NULL;\n\t\t\ttbFh = NULL;\n\t\t}\n\t\tsprintf(print_tb_buf + strlen(print_tb_buf),\n\t\t\t\"* %d * %3lld(%2d) * %3lld(%2d) * %3lld(%2d) * %5lld * %5lld * %5lld * %5lld * %5lld *\\n\",\n\t\t\th,\n\t\t\t(tbSh) ? (long long)(tbSh->b_blocknr) : (-1LL),\n\t\t\t(tbSh) ? atomic_read(&tbSh->b_count) : -1,\n\t\t\t(tb->L[h]) ? (long long)(tb->L[h]->b_blocknr) : (-1LL),\n\t\t\t(tb->L[h]) ? atomic_read(&tb->L[h]->b_count) : -1,\n\t\t\t(tb->R[h]) ? (long long)(tb->R[h]->b_blocknr) : (-1LL),\n\t\t\t(tb->R[h]) ? atomic_read(&tb->R[h]->b_count) : -1,\n\t\t\t(tbFh) ? (long long)(tbFh->b_blocknr) : (-1LL),\n\t\t\t(tb->FL[h]) ? (long long)(tb->FL[h]->\n\t\t\t\t\t\t  b_blocknr) : (-1LL),\n\t\t\t(tb->FR[h]) ? (long long)(tb->FR[h]->\n\t\t\t\t\t\t  b_blocknr) : (-1LL),\n\t\t\t(tb->CFL[h]) ? (long long)(tb->CFL[h]->\n\t\t\t\t\t\t   b_blocknr) : (-1LL),\n\t\t\t(tb->CFR[h]) ? (long long)(tb->CFR[h]->\n\t\t\t\t\t\t   b_blocknr) : (-1LL));\n\t}\n\n\tsprintf(print_tb_buf + strlen(print_tb_buf),\n\t\t\"=====================================================================\\n\"\n\t\t\"* h * size * ln * lb * rn * rb * blkn * s0 * s1 * s1b * s2 * s2b * curb * lk * rk *\\n\"\n\t\t\"* 0 * %4d * %2d * %2d * %2d * %2d * %4d * %2d * %2d * %3d * %2d * %3d * %4d * %2d * %2d *\\n\",\n\t\ttb->insert_size[0], tb->lnum[0], tb->lbytes, tb->rnum[0],\n\t\ttb->rbytes, tb->blknum[0], tb->s0num, tb->snum[0],\n\t\ttb->sbytes[0], tb->snum[1], tb->sbytes[1],\n\t\ttb->cur_blknum, tb->lkey[0], tb->rkey[0]);\n\n\t \n\th = 0;\n\tdo {\n\t\th++;\n\t\tsprintf(print_tb_buf + strlen(print_tb_buf),\n\t\t\t\"* %d * %4d * %2d *    * %2d *    * %2d *\\n\",\n\t\t\th, tb->insert_size[h], tb->lnum[h], tb->rnum[h],\n\t\t\ttb->blknum[h]);\n\t} while (tb->insert_size[h]);\n\n\tsprintf(print_tb_buf + strlen(print_tb_buf),\n\t\t\"=====================================================================\\n\"\n\t\t\"FEB list: \");\n\n\t \n\th = 0;\n\tfor (i = 0; i < ARRAY_SIZE(tb->FEB); i++)\n\t\tsprintf(print_tb_buf + strlen(print_tb_buf),\n\t\t\t\"%p (%llu %d)%s\", tb->FEB[i],\n\t\t\ttb->FEB[i] ? (unsigned long long)tb->FEB[i]->\n\t\t\tb_blocknr : 0ULL,\n\t\t\ttb->FEB[i] ? atomic_read(&tb->FEB[i]->b_count) : 0,\n\t\t\t(i == ARRAY_SIZE(tb->FEB) - 1) ? \"\\n\" : \", \");\n\n\tsprintf(print_tb_buf + strlen(print_tb_buf),\n\t\t\"======================== the end ====================================\\n\");\n}\n\nvoid print_cur_tb(char *mes)\n{\n\tprintk(\"%s\\n%s\", mes, print_tb_buf);\n}\n\nstatic void check_leaf_block_head(struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tint nr;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tif (nr > (bh->b_size - BLKH_SIZE) / IH_SIZE)\n\t\treiserfs_panic(NULL, \"vs-6010\", \"invalid item number %z\",\n\t\t\t       bh);\n\tif (blkh_free_space(blkh) > bh->b_size - BLKH_SIZE - IH_SIZE * nr)\n\t\treiserfs_panic(NULL, \"vs-6020\", \"invalid free space %z\",\n\t\t\t       bh);\n\n}\n\nstatic void check_internal_block_head(struct buffer_head *bh)\n{\n\tif (!(B_LEVEL(bh) > DISK_LEAF_NODE_LEVEL && B_LEVEL(bh) <= MAX_HEIGHT))\n\t\treiserfs_panic(NULL, \"vs-6025\", \"invalid level %z\", bh);\n\n\tif (B_NR_ITEMS(bh) > (bh->b_size - BLKH_SIZE) / IH_SIZE)\n\t\treiserfs_panic(NULL, \"vs-6030\", \"invalid item number %z\", bh);\n\n\tif (B_FREE_SPACE(bh) !=\n\t    bh->b_size - BLKH_SIZE - KEY_SIZE * B_NR_ITEMS(bh) -\n\t    DC_SIZE * (B_NR_ITEMS(bh) + 1))\n\t\treiserfs_panic(NULL, \"vs-6040\", \"invalid free space %z\", bh);\n\n}\n\nvoid check_leaf(struct buffer_head *bh)\n{\n\tint i;\n\tstruct item_head *ih;\n\n\tif (!bh)\n\t\treturn;\n\tcheck_leaf_block_head(bh);\n\tfor (i = 0, ih = item_head(bh, 0); i < B_NR_ITEMS(bh); i++, ih++)\n\t\top_check_item(ih, ih_item_body(bh, ih));\n}\n\nvoid check_internal(struct buffer_head *bh)\n{\n\tif (!bh)\n\t\treturn;\n\tcheck_internal_block_head(bh);\n}\n\nvoid print_statistics(struct super_block *s)\n{\n\n\t \n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}