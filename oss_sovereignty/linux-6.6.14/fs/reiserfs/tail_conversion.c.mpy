{
  "module_name": "tail_conversion.c",
  "hash_id": "e214ee631f716da4fccc12e1b6ec0dfcc4f2a41cccaa643d4e891ec2bd7fda0d",
  "original_prompt": "Ingested from linux-6.6.14/fs/reiserfs/tail_conversion.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n\n \n\n \n \nint direct2indirect(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t    struct treepath *path, struct buffer_head *unbh,\n\t\t    loff_t tail_offset)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *up_to_date_bh;\n\tstruct item_head *p_le_ih = tp_item_head(path);\n\tunsigned long total_tail = 0;\n\n\t \n\tstruct cpu_key end_key;\n\n\t \n\tstruct item_head ind_ih;\n\tint blk_size;\n\t \n\tint  retval;\n\t \n\tunp_t unfm_ptr;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tREISERFS_SB(sb)->s_direct2indirect++;\n\n\tblk_size = sb->s_blocksize;\n\n\t \n\tcopy_item_head(&ind_ih, p_le_ih);\n\tset_le_ih_k_offset(&ind_ih, tail_offset);\n\tset_le_ih_k_type(&ind_ih, TYPE_INDIRECT);\n\n\t \n\tmake_cpu_key(&end_key, inode, tail_offset, TYPE_INDIRECT, 4);\n\n\t \n\tif (search_for_position_by_key(sb, &end_key, path) == POSITION_FOUND) {\n\t\treiserfs_error(sb, \"PAP-14030\",\n\t\t\t       \"pasted or inserted byte exists in \"\n\t\t\t       \"the tree %K. Use fsck to repair.\", &end_key);\n\t\tpathrelse(path);\n\t\treturn -EIO;\n\t}\n\n\tp_le_ih = tp_item_head(path);\n\n\tunfm_ptr = cpu_to_le32(unbh->b_blocknr);\n\n\tif (is_statdata_le_ih(p_le_ih)) {\n\t\t \n\t\tset_ih_free_space(&ind_ih, 0);\t \n\t\tput_ih_item_len(&ind_ih, UNFM_P_SIZE);\n\t\tPATH_LAST_POSITION(path)++;\n\t\tretval =\n\t\t    reiserfs_insert_item(th, path, &end_key, &ind_ih, inode,\n\t\t\t\t\t (char *)&unfm_ptr);\n\t} else {\n\t\t \n\t\tretval = reiserfs_paste_into_item(th, path, &end_key, inode,\n\t\t\t\t\t\t    (char *)&unfm_ptr,\n\t\t\t\t\t\t    UNFM_P_SIZE);\n\t}\n\tif (retval) {\n\t\treturn retval;\n\t}\n\t \n\n\t \n\tmake_cpu_key(&end_key, inode, max_reiserfs_offset(inode), TYPE_DIRECT,\n\t\t     4);\n\n\t \n\twhile (1) {\n\t\tint tail_size;\n\n\t\t \n\t\tif (search_for_position_by_key(sb, &end_key, path) ==\n\t\t    POSITION_FOUND)\n\t\t\treiserfs_panic(sb, \"PAP-14050\",\n\t\t\t\t       \"direct item (%K) not found\", &end_key);\n\t\tp_le_ih = tp_item_head(path);\n\t\tRFALSE(!is_direct_le_ih(p_le_ih),\n\t\t       \"vs-14055: direct item expected(%K), found %h\",\n\t\t       &end_key, p_le_ih);\n\t\ttail_size = (le_ih_k_offset(p_le_ih) & (blk_size - 1))\n\t\t    + ih_item_len(p_le_ih) - 1;\n\n\t\t \n\t\tif (!unbh->b_page || buffer_uptodate(unbh)\n\t\t    || PageUptodate(unbh->b_page)) {\n\t\t\tup_to_date_bh = NULL;\n\t\t} else {\n\t\t\tup_to_date_bh = unbh;\n\t\t}\n\t\tretval = reiserfs_delete_item(th, path, &end_key, inode,\n\t\t\t\t\t\tup_to_date_bh);\n\n\t\ttotal_tail += retval;\n\n\t\t \n\t\tif (tail_size == retval)\n\t\t\tbreak;\n\n\t}\n\t \n\tif (up_to_date_bh) {\n\t\tunsigned pgoff =\n\t\t    (tail_offset + total_tail - 1) & (PAGE_SIZE - 1);\n\t\tchar *kaddr = kmap_atomic(up_to_date_bh->b_page);\n\t\tmemset(kaddr + pgoff, 0, blk_size - total_tail);\n\t\tkunmap_atomic(kaddr);\n\t}\n\n\tREISERFS_I(inode)->i_first_direct_byte = U32_MAX;\n\n\treturn 0;\n}\n\n \nvoid reiserfs_unmap_buffer(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_journaled(bh) || buffer_journal_dirty(bh)) {\n\t\tBUG();\n\t}\n\tclear_buffer_dirty(bh);\n\t \n\tif ((!list_empty(&bh->b_assoc_buffers) || bh->b_private) && bh->b_page) {\n\t\tstruct inode *inode = bh->b_folio->mapping->host;\n\t\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\treiserfs_free_jh(bh);\n\t\tspin_unlock(&j->j_dirty_buffers_lock);\n\t}\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tbh->b_bdev = NULL;\n\tunlock_buffer(bh);\n}\n\n \nint indirect2direct(struct reiserfs_transaction_handle *th,\n\t\t    struct inode *inode, struct page *page,\n\t\t    struct treepath *path,\t \n\t\t    const struct cpu_key *item_key,\t \n\t\t    loff_t n_new_file_size,\t \n\t\t    char *mode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct item_head s_ih;\n\tunsigned long block_size = sb->s_blocksize;\n\tchar *tail;\n\tint tail_len, round_tail_len;\n\tloff_t pos, pos1;\t \n\tstruct cpu_key key;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tREISERFS_SB(sb)->s_indirect2direct++;\n\n\t*mode = M_SKIP_BALANCING;\n\n\t \n\tcopy_item_head(&s_ih, tp_item_head(path));\n\n\ttail_len = (n_new_file_size & (block_size - 1));\n\tif (get_inode_sd_version(inode) == STAT_DATA_V2)\n\t\tround_tail_len = ROUND_UP(tail_len);\n\telse\n\t\tround_tail_len = tail_len;\n\n\tpos =\n\t    le_ih_k_offset(&s_ih) - 1 + (ih_item_len(&s_ih) / UNFM_P_SIZE -\n\t\t\t\t\t 1) * sb->s_blocksize;\n\tpos1 = pos;\n\n\t \n\n\ttail = (char *)kmap(page);\t \n\n\tif (path_changed(&s_ih, path)) {\n\t\t \n\t\tif (search_for_position_by_key(sb, item_key, path)\n\t\t    == POSITION_NOT_FOUND)\n\t\t\treiserfs_panic(sb, \"PAP-5520\",\n\t\t\t\t       \"item to be converted %K does not exist\",\n\t\t\t\t       item_key);\n\t\tcopy_item_head(&s_ih, tp_item_head(path));\n#ifdef CONFIG_REISERFS_CHECK\n\t\tpos = le_ih_k_offset(&s_ih) - 1 +\n\t\t    (ih_item_len(&s_ih) / UNFM_P_SIZE -\n\t\t     1) * sb->s_blocksize;\n\t\tif (pos != pos1)\n\t\t\treiserfs_panic(sb, \"vs-5530\", \"tail position \"\n\t\t\t\t       \"changed while we were reading it\");\n#endif\n\t}\n\n\t \n\tmake_le_item_head(&s_ih, NULL, get_inode_item_key_version(inode),\n\t\t\t  pos1 + 1, TYPE_DIRECT, round_tail_len,\n\t\t\t  0xffff   );\n\n\t \n\ttail = tail + (pos & (PAGE_SIZE - 1));\n\n\tPATH_LAST_POSITION(path)++;\n\n\tkey = *item_key;\n\tset_cpu_key_k_type(&key, TYPE_DIRECT);\n\tkey.key_length = 4;\n\t \n\tif (reiserfs_insert_item(th, path, &key, &s_ih, inode,\n\t\t\t\t tail ? tail : NULL) < 0) {\n\t\t \n\t\tkunmap(page);\n\t\treturn block_size - round_tail_len;\n\t}\n\tkunmap(page);\n\n\t \n\treiserfs_update_sd(th, inode);\n\n\t \n\n\t \n\t*mode = M_CUT;\n\n\t \n\t \n\tREISERFS_I(inode)->i_first_direct_byte = pos1 + 1;\n\n\treturn block_size - round_tail_len;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}