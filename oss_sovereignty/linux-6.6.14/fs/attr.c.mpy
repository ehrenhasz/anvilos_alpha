{
  "module_name": "attr.c",
  "hash_id": "41fdb97375f61c9e922634c1e4b0491517b25f64302f498432c9918aa27bb918",
  "original_prompt": "Ingested from linux-6.6.14/fs/attr.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/sched/signal.h>\n#include <linux/capability.h>\n#include <linux/fsnotify.h>\n#include <linux/fcntl.h>\n#include <linux/filelock.h>\n#include <linux/security.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n\n#include \"internal.h\"\n\n \nint setattr_should_drop_sgid(struct mnt_idmap *idmap,\n\t\t\t     const struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\n\tif (!(mode & S_ISGID))\n\t\treturn 0;\n\tif (mode & S_IXGRP)\n\t\treturn ATTR_KILL_SGID;\n\tif (!in_group_or_capable(idmap, inode, i_gid_into_vfsgid(idmap, inode)))\n\t\treturn ATTR_KILL_SGID;\n\treturn 0;\n}\nEXPORT_SYMBOL(setattr_should_drop_sgid);\n\n \nint setattr_should_drop_suidgid(struct mnt_idmap *idmap,\n\t\t\t\tstruct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tint kill = 0;\n\n\t \n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\tkill |= setattr_should_drop_sgid(idmap, inode);\n\n\tif (unlikely(kill && !capable(CAP_FSETID) && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(setattr_should_drop_suidgid);\n\n \nstatic bool chown_ok(struct mnt_idmap *idmap,\n\t\t     const struct inode *inode, vfsuid_t ia_vfsuid)\n{\n\tvfsuid_t vfsuid = i_uid_into_vfsuid(idmap, inode);\n\tif (vfsuid_eq_kuid(vfsuid, current_fsuid()) &&\n\t    vfsuid_eq(ia_vfsuid, vfsuid))\n\t\treturn true;\n\tif (capable_wrt_inode_uidgid(idmap, inode, CAP_CHOWN))\n\t\treturn true;\n\tif (!vfsuid_valid(vfsuid) &&\n\t    ns_capable(inode->i_sb->s_user_ns, CAP_CHOWN))\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic bool chgrp_ok(struct mnt_idmap *idmap,\n\t\t     const struct inode *inode, vfsgid_t ia_vfsgid)\n{\n\tvfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode);\n\tvfsuid_t vfsuid = i_uid_into_vfsuid(idmap, inode);\n\tif (vfsuid_eq_kuid(vfsuid, current_fsuid())) {\n\t\tif (vfsgid_eq(ia_vfsgid, vfsgid))\n\t\t\treturn true;\n\t\tif (vfsgid_in_group_p(ia_vfsgid))\n\t\t\treturn true;\n\t}\n\tif (capable_wrt_inode_uidgid(idmap, inode, CAP_CHOWN))\n\t\treturn true;\n\tif (!vfsgid_valid(vfsgid) &&\n\t    ns_capable(inode->i_sb->s_user_ns, CAP_CHOWN))\n\t\treturn true;\n\treturn false;\n}\n\n \nint setattr_prepare(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t    struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t \n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\tif (ia_valid & ATTR_FORCE)\n\t\tgoto kill_priv;\n\n\t \n\tif ((ia_valid & ATTR_UID) &&\n\t    !chown_ok(idmap, inode, attr->ia_vfsuid))\n\t\treturn -EPERM;\n\n\t \n\tif ((ia_valid & ATTR_GID) &&\n\t    !chgrp_ok(idmap, inode, attr->ia_vfsgid))\n\t\treturn -EPERM;\n\n\t \n\tif (ia_valid & ATTR_MODE) {\n\t\tvfsgid_t vfsgid;\n\n\t\tif (!inode_owner_or_capable(idmap, inode))\n\t\t\treturn -EPERM;\n\n\t\tif (ia_valid & ATTR_GID)\n\t\t\tvfsgid = attr->ia_vfsgid;\n\t\telse\n\t\t\tvfsgid = i_gid_into_vfsgid(idmap, inode);\n\n\t\t \n\t\tif (!in_group_or_capable(idmap, inode, vfsgid))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t \n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(idmap, inode))\n\t\t\treturn -EPERM;\n\t}\n\nkill_priv:\n\t \n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tint error;\n\n\t\terror = security_inode_killpriv(idmap, dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(setattr_prepare);\n\n \nint inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (offset < 0)\n\t\treturn -EINVAL;\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t \n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}\nEXPORT_SYMBOL(inode_newsize_ok);\n\n \nvoid setattr_copy(struct mnt_idmap *idmap, struct inode *inode,\n\t\t  const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\ti_uid_update(idmap, attr, inode);\n\ti_gid_update(idmap, attr, inode);\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = attr->ia_atime;\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = attr->ia_mtime;\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode_set_ctime_to_ts(inode, attr->ia_ctime);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\t\tif (!in_group_or_capable(idmap, inode,\n\t\t\t\t\t i_gid_into_vfsgid(idmap, inode)))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}\nEXPORT_SYMBOL(setattr_copy);\n\nint may_setattr(struct mnt_idmap *idmap, struct inode *inode,\n\t\tunsigned int ia_valid)\n{\n\tint error;\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t \n\tif (ia_valid & ATTR_TOUCH) {\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\tif (!inode_owner_or_capable(idmap, inode)) {\n\t\t\terror = inode_permission(idmap, inode, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(may_setattr);\n\n \nint notify_change(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t  struct iattr *attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec64 now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\n\terror = may_setattr(idmap, inode, ia_valid);\n\tif (error)\n\t\treturn error;\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\t \n\t\tif (S_ISLNK(inode->i_mode))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (is_sxid(attr->ia_mode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_time(inode);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\telse\n\t\tattr->ia_atime = timestamp_truncate(attr->ia_atime, inode);\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\telse\n\t\tattr->ia_mtime = timestamp_truncate(attr->ia_mtime, inode);\n\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 0)\n\t\t\tia_valid = attr->ia_valid &= ~ATTR_KILL_PRIV;\n\t}\n\n\t \n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif (mode & S_ISGID) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\t \n\tif (ia_valid & ATTR_UID &&\n\t    !vfsuid_has_fsmapping(idmap, inode->i_sb->s_user_ns,\n\t\t\t\t  attr->ia_vfsuid))\n\t\treturn -EOVERFLOW;\n\tif (ia_valid & ATTR_GID &&\n\t    !vfsgid_has_fsmapping(idmap, inode->i_sb->s_user_ns,\n\t\t\t\t  attr->ia_vfsgid))\n\t\treturn -EOVERFLOW;\n\n\t \n\tif (!(ia_valid & ATTR_UID) &&\n\t    !vfsuid_valid(i_uid_into_vfsuid(idmap, inode)))\n\t\treturn -EOVERFLOW;\n\tif (!(ia_valid & ATTR_GID) &&\n\t    !vfsgid_valid(i_gid_into_vfsgid(idmap, inode)))\n\t\treturn -EOVERFLOW;\n\n\terror = security_inode_setattr(idmap, dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(idmap, dentry, attr);\n\telse\n\t\terror = simple_setattr(idmap, dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(idmap, dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}\nEXPORT_SYMBOL(notify_change);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}