{
  "module_name": "inode.c",
  "hash_id": "f2fe2f2bbe3f3f25c7377948678d13eb0febc9d42e04a6aa90aefd031b5d2279",
  "original_prompt": "Ingested from linux-6.6.14/fs/coda/inode.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/unistd.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/file.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/pid_namespace.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n\n#include <linux/coda.h>\n#include \"coda_psdev.h\"\n#include \"coda_linux.h\"\n#include \"coda_cache.h\"\n\n#include \"coda_int.h\"\n\n \nstatic void coda_evict_inode(struct inode *);\nstatic void coda_put_super(struct super_block *);\nstatic int coda_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic struct kmem_cache * coda_inode_cachep;\n\nstatic struct inode *coda_alloc_inode(struct super_block *sb)\n{\n\tstruct coda_inode_info *ei;\n\tei = alloc_inode_sb(sb, coda_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\tmemset(&ei->c_fid, 0, sizeof(struct CodaFid));\n\tei->c_flags = 0;\n\tei->c_uid = GLOBAL_ROOT_UID;\n\tei->c_cached_perm = 0;\n\tspin_lock_init(&ei->c_lock);\n\treturn &ei->vfs_inode;\n}\n\nstatic void coda_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(coda_inode_cachep, ITOC(inode));\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct coda_inode_info *ei = (struct coda_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nint __init coda_init_inodecache(void)\n{\n\tcoda_inode_cachep = kmem_cache_create(\"coda_inode_cache\",\n\t\t\t\tsizeof(struct coda_inode_info), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD|\n\t\t\t\tSLAB_ACCOUNT, init_once);\n\tif (coda_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid coda_destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(coda_inode_cachep);\n}\n\nstatic int coda_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= SB_NOATIME;\n\treturn 0;\n}\n\n \nstatic const struct super_operations coda_super_operations =\n{\n\t.alloc_inode\t= coda_alloc_inode,\n\t.free_inode\t= coda_free_inode,\n\t.evict_inode\t= coda_evict_inode,\n\t.put_super\t= coda_put_super,\n\t.statfs\t\t= coda_statfs,\n\t.remount_fs\t= coda_remount,\n};\n\nstatic int get_device_index(struct coda_mount_data *data)\n{\n\tstruct fd f;\n\tstruct inode *inode;\n\tint idx;\n\n\tif (data == NULL) {\n\t\tpr_warn(\"%s: Bad mount data\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tif (data->version != CODA_MOUNT_VERSION) {\n\t\tpr_warn(\"%s: Bad mount version\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tf = fdget(data->fd);\n\tif (!f.file)\n\t\tgoto Ebadf;\n\tinode = file_inode(f.file);\n\tif (!S_ISCHR(inode->i_mode) || imajor(inode) != CODA_PSDEV_MAJOR) {\n\t\tfdput(f);\n\t\tgoto Ebadf;\n\t}\n\n\tidx = iminor(inode);\n\tfdput(f);\n\n\tif (idx < 0 || idx >= MAX_CODADEVS) {\n\t\tpr_warn(\"%s: Bad minor number\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\treturn idx;\nEbadf:\n\tpr_warn(\"%s: Bad file\\n\", __func__);\n\treturn -1;\n}\n\nstatic int coda_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct inode *root = NULL;\n\tstruct venus_comm *vc;\n\tstruct CodaFid fid;\n\tint error;\n\tint idx;\n\n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\tidx = get_device_index((struct coda_mount_data *) data);\n\n\t \n\tif(idx == -1)\n\t\tidx = 0;\n\t\n\tpr_info(\"%s: device index: %i\\n\", __func__,  idx);\n\n\tvc = &coda_comms[idx];\n\tmutex_lock(&vc->vc_mutex);\n\n\tif (!vc->vc_inuse) {\n\t\tpr_warn(\"%s: No pseudo device\\n\", __func__);\n\t\terror = -EINVAL;\n\t\tgoto unlock_out;\n\t}\n\n\tif (vc->vc_sb) {\n\t\tpr_warn(\"%s: Device already mounted\\n\", __func__);\n\t\terror = -EBUSY;\n\t\tgoto unlock_out;\n\t}\n\n\tvc->vc_sb = sb;\n\tmutex_unlock(&vc->vc_mutex);\n\n\tsb->s_fs_info = vc;\n\tsb->s_flags |= SB_NOATIME;\n\tsb->s_blocksize = 4096;\t \n\tsb->s_blocksize_bits = 12;\n\tsb->s_magic = CODA_SUPER_MAGIC;\n\tsb->s_op = &coda_super_operations;\n\tsb->s_d_op = &coda_dentry_operations;\n\tsb->s_time_gran = 1;\n\tsb->s_time_min = S64_MIN;\n\tsb->s_time_max = S64_MAX;\n\n\terror = super_setup_bdi(sb);\n\tif (error)\n\t\tgoto error;\n\n\t \n\terror = venus_rootfid(sb, &fid);\n\tif ( error ) {\n\t\tpr_warn(\"%s: coda_get_rootfid failed with %d\\n\",\n\t\t\t__func__, error);\n\t\tgoto error;\n\t}\n\tpr_info(\"%s: rootfid is %s\\n\", __func__, coda_f2s(&fid));\n\t\n\t \n        root = coda_cnode_make(&fid, sb);\n        if (IS_ERR(root)) {\n\t\terror = PTR_ERR(root);\n\t\tpr_warn(\"Failure of coda_cnode_make for root: error %d\\n\",\n\t\t\terror);\n\t\tgoto error;\n\t} \n\n\tpr_info(\"%s: rootinode is %ld dev %s\\n\",\n\t\t__func__, root->i_ino, root->i_sb->s_id);\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\terror = -EINVAL;\n\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\tmutex_lock(&vc->vc_mutex);\n\tvc->vc_sb = NULL;\n\tsb->s_fs_info = NULL;\nunlock_out:\n\tmutex_unlock(&vc->vc_mutex);\n\treturn error;\n}\n\nstatic void coda_put_super(struct super_block *sb)\n{\n\tstruct venus_comm *vcp = coda_vcp(sb);\n\tmutex_lock(&vcp->vc_mutex);\n\tvcp->vc_sb = NULL;\n\tsb->s_fs_info = NULL;\n\tmutex_unlock(&vcp->vc_mutex);\n\tmutex_destroy(&vcp->vc_mutex);\n\n\tpr_info(\"Bye bye.\\n\");\n}\n\nstatic void coda_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tcoda_cache_clear_inode(inode);\n}\n\nint coda_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t struct kstat *stat, u32 request_mask, unsigned int flags)\n{\n\tint err = coda_revalidate_inode(d_inode(path->dentry));\n\tif (!err)\n\t\tgeneric_fillattr(&nop_mnt_idmap, request_mask,\n\t\t\t\t d_inode(path->dentry), stat);\n\treturn err;\n}\n\nint coda_setattr(struct mnt_idmap *idmap, struct dentry *de,\n\t\t struct iattr *iattr)\n{\n\tstruct inode *inode = d_inode(de);\n\tstruct coda_vattr vattr;\n\tint error;\n\n\tmemset(&vattr, 0, sizeof(vattr)); \n\n\tinode_set_ctime_current(inode);\n\tcoda_iattr_to_vattr(iattr, &vattr);\n\tvattr.va_type = C_VNON;  \n\n\t \n\terror = venus_setattr(inode->i_sb, coda_i2f(inode), &vattr);\n\n\tif (!error) {\n\t        coda_vattr_to_iattr(inode, &vattr); \n\t\tcoda_cache_clear_inode(inode);\n\t}\n\treturn error;\n}\n\nconst struct inode_operations coda_file_inode_operations = {\n\t.permission\t= coda_permission,\n\t.getattr\t= coda_getattr,\n\t.setattr\t= coda_setattr,\n};\n\nstatic int coda_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tint error;\n\t\n\terror = venus_statfs(dentry, buf);\n\n\tif (error) {\n\t\t \n\t\tbuf->f_blocks = 9000000;\n\t\tbuf->f_bfree  = 9000000;\n\t\tbuf->f_bavail = 9000000;\n\t\tbuf->f_files  = 9000000;\n\t\tbuf->f_ffree  = 9000000;\n\t}\n\n\t \n\tbuf->f_type = CODA_SUPER_MAGIC;\n\tbuf->f_bsize = 4096;\n\tbuf->f_namelen = CODA_MAXNAMLEN;\n\n\treturn 0; \n}\n\n \n\nstatic struct dentry *coda_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_nodev(fs_type, flags, data, coda_fill_super);\n}\n\nstruct file_system_type coda_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"coda\",\n\t.mount\t\t= coda_mount,\n\t.kill_sb\t= kill_anon_super,\n\t.fs_flags\t= FS_BINARY_MOUNTDATA,\n};\nMODULE_ALIAS_FS(\"coda\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}