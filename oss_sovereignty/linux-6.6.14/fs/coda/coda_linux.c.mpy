{
  "module_name": "coda_linux.c",
  "hash_id": "ff361c1f6906d2876552e7289c2932a1b12cfc4a36a835ce1b1e8e38d4c5cef0",
  "original_prompt": "Ingested from linux-6.6.14/fs/coda/coda_linux.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n\n#include <linux/coda.h>\n#include \"coda_psdev.h\"\n#include \"coda_linux.h\"\n\n \nint coda_fake_statfs;\n\n \nchar * coda_f2s(struct CodaFid *f)\n{\n\tstatic char s[60];\n\n \tsprintf(s, \"(%08x.%08x.%08x.%08x)\", f->opaque[0], f->opaque[1], f->opaque[2], f->opaque[3]);\n\n\treturn s;\n}\n\n \nint coda_iscontrol(const char *name, size_t length)\n{\n\treturn ((CODA_CONTROLLEN == length) && \n                (strncmp(name, CODA_CONTROL, CODA_CONTROLLEN) == 0));\n}\n\nunsigned short coda_flags_to_cflags(unsigned short flags)\n{\n\tunsigned short coda_flags = 0;\n\t\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\tcoda_flags |= C_O_READ;\n\n\tif ((flags & O_ACCMODE) == O_RDWR)\n\t\tcoda_flags |= C_O_READ | C_O_WRITE;\n\n\tif ((flags & O_ACCMODE) == O_WRONLY)\n\t\tcoda_flags |= C_O_WRITE;\n\n\tif (flags & O_TRUNC)\n\t\tcoda_flags |= C_O_TRUNC;\n\n\tif (flags & O_CREAT)\n\t\tcoda_flags |= C_O_CREAT;\n\n\tif (flags & O_EXCL)\n\t\tcoda_flags |= C_O_EXCL;\n\n\treturn coda_flags;\n}\n\nstatic struct timespec64 coda_to_timespec64(struct coda_timespec ts)\n{\n\tstruct timespec64 ts64 = {\n\t\t.tv_sec = ts.tv_sec,\n\t\t.tv_nsec = ts.tv_nsec,\n\t};\n\n\treturn ts64;\n}\n\nstatic struct coda_timespec timespec64_to_coda(struct timespec64 ts64)\n{\n\tstruct coda_timespec ts = {\n\t\t.tv_sec = ts64.tv_sec,\n\t\t.tv_nsec = ts64.tv_nsec,\n\t};\n\n\treturn ts;\n}\n\n \numode_t coda_inode_type(struct coda_vattr *attr)\n{\n\tswitch (attr->va_type) {\n\tcase C_VREG:\n\t\treturn S_IFREG;\n\tcase C_VDIR:\n\t\treturn S_IFDIR;\n\tcase C_VLNK:\n\t\treturn S_IFLNK;\n\tcase C_VNON:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nvoid coda_vattr_to_iattr(struct inode *inode, struct coda_vattr *attr)\n{\n\t \n\tumode_t inode_type = coda_inode_type(attr);\n\tinode->i_mode |= inode_type;\n\n\tif (attr->va_mode != (u_short) -1)\n\t        inode->i_mode = attr->va_mode | inode_type;\n        if (attr->va_uid != -1) \n\t        inode->i_uid = make_kuid(&init_user_ns, (uid_t) attr->va_uid);\n        if (attr->va_gid != -1)\n\t        inode->i_gid = make_kgid(&init_user_ns, (gid_t) attr->va_gid);\n\tif (attr->va_nlink != -1)\n\t\tset_nlink(inode, attr->va_nlink);\n\tif (attr->va_size != -1)\n\t        inode->i_size = attr->va_size;\n\tif (attr->va_size != -1)\n\t\tinode->i_blocks = (attr->va_size + 511) >> 9;\n\tif (attr->va_atime.tv_sec != -1) \n\t\tinode->i_atime = coda_to_timespec64(attr->va_atime);\n\tif (attr->va_mtime.tv_sec != -1)\n\t\tinode->i_mtime = coda_to_timespec64(attr->va_mtime);\n        if (attr->va_ctime.tv_sec != -1)\n\t\tinode_set_ctime_to_ts(inode,\n\t\t\t\t      coda_to_timespec64(attr->va_ctime));\n}\n\n\n \n\nvoid coda_iattr_to_vattr(struct iattr *iattr, struct coda_vattr *vattr)\n{\n        unsigned int valid;\n\n                 \n\tvattr->va_mode = -1;\n        vattr->va_uid = (vuid_t) -1; \n        vattr->va_gid = (vgid_t) -1;\n        vattr->va_size = (off_t) -1;\n\tvattr->va_atime.tv_sec = (int64_t) -1;\n\tvattr->va_atime.tv_nsec = (long) -1;\n\tvattr->va_mtime.tv_sec = (int64_t) -1;\n\tvattr->va_mtime.tv_nsec = (long) -1;\n\tvattr->va_ctime.tv_sec = (int64_t) -1;\n\tvattr->va_ctime.tv_nsec = (long) -1;\n        vattr->va_type = C_VNON;\n\tvattr->va_fileid = -1;\n\tvattr->va_gen = -1;\n\tvattr->va_bytes = -1;\n\tvattr->va_nlink = -1;\n\tvattr->va_blocksize = -1;\n\tvattr->va_rdev = -1;\n        vattr->va_flags = 0;\n\n         \n#if 0\n        mode = iattr->ia_mode;\n                if ( S_ISDIR(mode) ) {\n                vattr->va_type = C_VDIR; \n        } else if ( S_ISREG(mode) ) {\n                vattr->va_type = C_VREG;\n        } else if ( S_ISLNK(mode) ) {\n                vattr->va_type = C_VLNK;\n        } else {\n                 \n                vattr->va_type = C_VNON;\n        }\n#endif \n\n         \n        valid = iattr->ia_valid;\n        if ( valid & ATTR_MODE ) {\n                vattr->va_mode = iattr->ia_mode;\n\t}\n        if ( valid & ATTR_UID ) {\n                vattr->va_uid = (vuid_t) from_kuid(&init_user_ns, iattr->ia_uid);\n\t}\n        if ( valid & ATTR_GID ) {\n                vattr->va_gid = (vgid_t) from_kgid(&init_user_ns, iattr->ia_gid);\n\t}\n        if ( valid & ATTR_SIZE ) {\n                vattr->va_size = iattr->ia_size;\n\t}\n        if ( valid & ATTR_ATIME ) {\n\t\tvattr->va_atime = timespec64_to_coda(iattr->ia_atime);\n\t}\n        if ( valid & ATTR_MTIME ) {\n\t\tvattr->va_mtime = timespec64_to_coda(iattr->ia_mtime);\n\t}\n        if ( valid & ATTR_CTIME ) {\n\t\tvattr->va_ctime = timespec64_to_coda(iattr->ia_ctime);\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}