{
  "module_name": "upcall.c",
  "hash_id": "d278bb9b337c0309eb7a7e5110611939e578586f4a4c88cee13ff76277eae76a",
  "original_prompt": "Ingested from linux-6.6.14/fs/coda/upcall.c",
  "human_readable_source": "\n \n\n#include <linux/signal.h>\n#include <linux/sched/signal.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n\n#include <linux/coda.h>\n#include \"coda_psdev.h\"\n#include \"coda_linux.h\"\n#include \"coda_cache.h\"\n\n#include \"coda_int.h\"\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic void *alloc_upcall(int opcode, int size)\n{\n\tunion inputArgs *inp;\n\n\tinp = kvzalloc(size, GFP_KERNEL);\n        if (!inp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n        inp->ih.opcode = opcode;\n\tinp->ih.pid = task_pid_nr_ns(current, &init_pid_ns);\n\tinp->ih.pgid = task_pgrp_nr_ns(current, &init_pid_ns);\n\tinp->ih.uid = from_kuid(&init_user_ns, current_fsuid());\n\n\treturn (void*)inp;\n}\n\n#define UPARG(op)\\\ndo {\\\n\tinp = (union inputArgs *)alloc_upcall(op, insize); \\\n        if (IS_ERR(inp)) { return PTR_ERR(inp); }\\\n        outp = (union outputArgs *)(inp); \\\n        outsize = insize; \\\n} while (0)\n\n#define INSIZE(tag) sizeof(struct coda_ ## tag ## _in)\n#define OUTSIZE(tag) sizeof(struct coda_ ## tag ## _out)\n#define SIZE(tag)  max_t(unsigned int, INSIZE(tag), OUTSIZE(tag))\n\n\n \nint venus_rootfid(struct super_block *sb, struct CodaFid *fidp)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n\n        insize = SIZE(root);\n        UPARG(CODA_ROOT);\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error)\n\t\t*fidp = outp->coda_root.VFid;\n\n\tkvfree(inp);\n\treturn error;\n}\n\nint venus_getattr(struct super_block *sb, struct CodaFid *fid, \n\t\t     struct coda_vattr *attr) \n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n\n        insize = SIZE(getattr); \n\tUPARG(CODA_GETATTR);\n        inp->coda_getattr.VFid = *fid;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error)\n\t\t*attr = outp->coda_getattr.attr;\n\n\tkvfree(inp);\n        return error;\n}\n\nint venus_setattr(struct super_block *sb, struct CodaFid *fid, \n\t\t  struct coda_vattr *vattr)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n\t\n\tinsize = SIZE(setattr);\n\tUPARG(CODA_SETATTR);\n\n        inp->coda_setattr.VFid = *fid;\n\tinp->coda_setattr.attr = *vattr;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tkvfree(inp);\n        return error;\n}\n\nint venus_lookup(struct super_block *sb, struct CodaFid *fid, \n\t\t    const char *name, int length, int * type, \n\t\t    struct CodaFid *resfid)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n\tint offset;\n\n\toffset = INSIZE(lookup);\n        insize = max_t(unsigned int, offset + length +1, OUTSIZE(lookup));\n\tUPARG(CODA_LOOKUP);\n\n        inp->coda_lookup.VFid = *fid;\n\tinp->coda_lookup.name = offset;\n\tinp->coda_lookup.flags = CLU_CASE_SENSITIVE;\n         \n        memcpy((char *)(inp) + offset, name, length);\n        *((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\t*resfid = outp->coda_lookup.VFid;\n\t\t*type = outp->coda_lookup.vtype;\n\t}\n\n\tkvfree(inp);\n\treturn error;\n}\n\nint venus_close(struct super_block *sb, struct CodaFid *fid, int flags,\n\t\tkuid_t uid)\n{\n\tunion inputArgs *inp;\n\tunion outputArgs *outp;\n\tint insize, outsize, error;\n\t\n\tinsize = SIZE(release);\n\tUPARG(CODA_CLOSE);\n\t\n\tinp->ih.uid = from_kuid(&init_user_ns, uid);\n        inp->coda_close.VFid = *fid;\n        inp->coda_close.flags = flags;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tkvfree(inp);\n        return error;\n}\n\nint venus_open(struct super_block *sb, struct CodaFid *fid,\n\t\t  int flags, struct file **fh)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n       \n\tinsize = SIZE(open_by_fd);\n\tUPARG(CODA_OPEN_BY_FD);\n\n\tinp->coda_open_by_fd.VFid = *fid;\n\tinp->coda_open_by_fd.flags = flags;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error)\n\t\t*fh = outp->coda_open_by_fd.fh;\n\n\tkvfree(inp);\n\treturn error;\n}\t\n\nint venus_mkdir(struct super_block *sb, struct CodaFid *dirfid, \n\t\t   const char *name, int length, \n\t\t   struct CodaFid *newfid, struct coda_vattr *attrs)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n\toffset = INSIZE(mkdir);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(mkdir));\n\tUPARG(CODA_MKDIR);\n\n        inp->coda_mkdir.VFid = *dirfid;\n        inp->coda_mkdir.attr = *attrs;\n\tinp->coda_mkdir.name = offset;\n         \n        memcpy((char *)(inp) + offset, name, length);\n        *((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\t*attrs = outp->coda_mkdir.attr;\n\t\t*newfid = outp->coda_mkdir.VFid;\n\t}\n\n\tkvfree(inp);\n\treturn error;        \n}\n\n\nint venus_rename(struct super_block *sb, struct CodaFid *old_fid, \n\t\t struct CodaFid *new_fid, size_t old_length, \n\t\t size_t new_length, const char *old_name, \n\t\t const char *new_name)\n{\n\tunion inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error; \n\tint offset, s;\n\t\n\toffset = INSIZE(rename);\n\tinsize = max_t(unsigned int, offset + new_length + old_length + 8,\n\t\t     OUTSIZE(rename)); \n \tUPARG(CODA_RENAME);\n\n        inp->coda_rename.sourceFid = *old_fid;\n        inp->coda_rename.destFid =  *new_fid;\n        inp->coda_rename.srcname = offset;\n\n         \n        s = ( old_length & ~0x3) +4;  \n        memcpy((char *)(inp) + offset, old_name, old_length);\n        *((char *)inp + offset + old_length) = '\\0';\n\n         \n        offset += s;\n        inp->coda_rename.destname = offset;\n        s = ( new_length & ~0x3) +4;  \n        memcpy((char *)(inp) + offset, new_name, new_length);\n        *((char *)inp + offset + new_length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tkvfree(inp);\n\treturn error;\n}\n\nint venus_create(struct super_block *sb, struct CodaFid *dirfid, \n\t\t const char *name, int length, int excl, int mode,\n\t\t struct CodaFid *newfid, struct coda_vattr *attrs) \n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n        offset = INSIZE(create);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(create));\n\tUPARG(CODA_CREATE);\n\n        inp->coda_create.VFid = *dirfid;\n        inp->coda_create.attr.va_mode = mode;\n\tinp->coda_create.excl = excl;\n        inp->coda_create.mode = mode;\n        inp->coda_create.name = offset;\n\n         \n        memcpy((char *)(inp) + offset, name, length);\n        *((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\t*attrs = outp->coda_create.attr;\n\t\t*newfid = outp->coda_create.VFid;\n\t}\n\n\tkvfree(inp);\n\treturn error;        \n}\n\nint venus_rmdir(struct super_block *sb, struct CodaFid *dirfid, \n\t\t    const char *name, int length)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n        offset = INSIZE(rmdir);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(rmdir));\n\tUPARG(CODA_RMDIR);\n\n        inp->coda_rmdir.VFid = *dirfid;\n        inp->coda_rmdir.name = offset;\n        memcpy((char *)(inp) + offset, name, length);\n\t*((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tkvfree(inp);\n\treturn error;\n}\n\nint venus_remove(struct super_block *sb, struct CodaFid *dirfid, \n\t\t    const char *name, int length)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int error=0, insize, outsize, offset;\n\n        offset = INSIZE(remove);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(remove));\n\tUPARG(CODA_REMOVE);\n\n        inp->coda_remove.VFid = *dirfid;\n        inp->coda_remove.name = offset;\n        memcpy((char *)(inp) + offset, name, length);\n\t*((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tkvfree(inp);\n\treturn error;\n}\n\nint venus_readlink(struct super_block *sb, struct CodaFid *fid, \n\t\t      char *buffer, int *length)\n{ \n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int retlen;\n        char *result;\n        \n\tinsize = max_t(unsigned int,\n\t\t     INSIZE(readlink), OUTSIZE(readlink)+ *length);\n\tUPARG(CODA_READLINK);\n\n        inp->coda_readlink.VFid = *fid;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\tretlen = outp->coda_readlink.count;\n\t\tif (retlen >= *length)\n\t\t\tretlen = *length - 1;\n\t\t*length = retlen;\n\t\tresult =  (char *)outp + (long)outp->coda_readlink.data;\n\t\tmemcpy(buffer, result, retlen);\n\t\t*(buffer + retlen) = '\\0';\n\t}\n\n\tkvfree(inp);\n        return error;\n}\n\n\n\nint venus_link(struct super_block *sb, struct CodaFid *fid, \n\t\t  struct CodaFid *dirfid, const char *name, int len )\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n\toffset = INSIZE(link);\n\tinsize = max_t(unsigned int, offset  + len + 1, OUTSIZE(link));\n        UPARG(CODA_LINK);\n\n        inp->coda_link.sourceFid = *fid;\n        inp->coda_link.destFid = *dirfid;\n        inp->coda_link.tname = offset;\n\n         \n        memcpy((char *)(inp) + offset, name, len);\n        *((char *)inp + offset + len) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tkvfree(inp);\n        return error;\n}\n\nint venus_symlink(struct super_block *sb, struct CodaFid *fid,\n\t\t     const char *name, int len,\n\t\t     const char *symname, int symlen)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset, s;\n\n        offset = INSIZE(symlink);\n\tinsize = max_t(unsigned int, offset + len + symlen + 8, OUTSIZE(symlink));\n\tUPARG(CODA_SYMLINK);\n        \n          \n        inp->coda_symlink.VFid = *fid;\n\n\t \n        inp->coda_symlink.srcname = offset;\n        s = ( symlen  & ~0x3 ) + 4; \n        memcpy((char *)(inp) + offset, symname, symlen);\n        *((char *)inp + offset + symlen) = '\\0';\n        \n\t \n        offset += s;\n        inp->coda_symlink.tname = offset;\n        s = (len & ~0x3) + 4;\n        memcpy((char *)(inp) + offset, name, len);\n        *((char *)inp + offset + len) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tkvfree(inp);\n        return error;\n}\n\nint venus_fsync(struct super_block *sb, struct CodaFid *fid)\n{\n        union inputArgs *inp;\n        union outputArgs *outp; \n\tint insize, outsize, error;\n\t\n\tinsize=SIZE(fsync);\n\tUPARG(CODA_FSYNC);\n\n\tinp->coda_fsync.VFid = *fid;\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tkvfree(inp);\n\treturn error;\n}\n\nint venus_access(struct super_block *sb, struct CodaFid *fid, int mask)\n{\n        union inputArgs *inp;\n        union outputArgs *outp; \n\tint insize, outsize, error;\n\n\tinsize = SIZE(access);\n\tUPARG(CODA_ACCESS);\n\n        inp->coda_access.VFid = *fid;\n        inp->coda_access.flags = mask;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tkvfree(inp);\n\treturn error;\n}\n\n\nint venus_pioctl(struct super_block *sb, struct CodaFid *fid,\n\t\t unsigned int cmd, struct PioctlData *data)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;  \n\tint insize, outsize, error;\n\tint iocsize;\n\n\tinsize = VC_MAXMSGSIZE;\n\tUPARG(CODA_IOCTL);\n\n         \n        if (data->vi.in_size > VC_MAXDATASIZE) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n        }\n\n        if (data->vi.out_size > VC_MAXDATASIZE) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n\t}\n\n        inp->coda_ioctl.VFid = *fid;\n    \n         \n        inp->coda_ioctl.cmd = (cmd & ~(PIOCPARM_MASK << 16));\t\n        iocsize = ((cmd >> 16) & PIOCPARM_MASK) - sizeof(char *) - sizeof(int);\n        inp->coda_ioctl.cmd |= (iocsize & PIOCPARM_MASK) <<\t16;\t\n    \n         \n        inp->coda_ioctl.len = data->vi.in_size;\n        inp->coda_ioctl.data = (char *)(INSIZE(ioctl));\n     \n         \n\tif (copy_from_user((char *)inp + (long)inp->coda_ioctl.data,\n\t\t\t   data->vi.in, data->vi.in_size)) {\n\t\terror = -EINVAL;\n\t        goto exit;\n\t}\n\n\terror = coda_upcall(coda_vcp(sb), SIZE(ioctl) + data->vi.in_size,\n\t\t\t    &outsize, inp);\n\n        if (error) {\n\t\tpr_warn(\"%s: Venus returns: %d for %s\\n\",\n\t\t\t__func__, error, coda_f2s(fid));\n\t\tgoto exit; \n\t}\n\n\tif (outsize < (long)outp->coda_ioctl.data + outp->coda_ioctl.len) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n\t}\n        \n\t \n        if (outp->coda_ioctl.len > data->vi.out_size) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n        }\n\n\t \n\tif (copy_to_user(data->vi.out,\n\t\t\t (char *)outp + (long)outp->coda_ioctl.data,\n\t\t\t outp->coda_ioctl.len)) {\n\t\terror = -EFAULT;\n\t\tgoto exit;\n\t}\n\n exit:\n\tkvfree(inp);\n\treturn error;\n}\n\nint venus_statfs(struct dentry *dentry, struct kstatfs *sfs)\n{ \n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        \n\tinsize = SIZE(statfs);\n\tUPARG(CODA_STATFS);\n\n\terror = coda_upcall(coda_vcp(dentry->d_sb), insize, &outsize, inp);\n\tif (!error) {\n\t\tsfs->f_blocks = outp->coda_statfs.stat.f_blocks;\n\t\tsfs->f_bfree  = outp->coda_statfs.stat.f_bfree;\n\t\tsfs->f_bavail = outp->coda_statfs.stat.f_bavail;\n\t\tsfs->f_files  = outp->coda_statfs.stat.f_files;\n\t\tsfs->f_ffree  = outp->coda_statfs.stat.f_ffree;\n\t}\n\n\tkvfree(inp);\n        return error;\n}\n\nint venus_access_intent(struct super_block *sb, struct CodaFid *fid,\n\t\t\tbool *access_intent_supported,\n\t\t\tsize_t count, loff_t ppos, int type)\n{\n\tunion inputArgs *inp;\n\tunion outputArgs *outp;\n\tint insize, outsize, error;\n\tbool finalizer =\n\t\ttype == CODA_ACCESS_TYPE_READ_FINISH ||\n\t\ttype == CODA_ACCESS_TYPE_WRITE_FINISH;\n\n\tif (!*access_intent_supported && !finalizer)\n\t\treturn 0;\n\n\tinsize = SIZE(access_intent);\n\tUPARG(CODA_ACCESS_INTENT);\n\n\tinp->coda_access_intent.VFid = *fid;\n\tinp->coda_access_intent.count = count;\n\tinp->coda_access_intent.pos = ppos;\n\tinp->coda_access_intent.type = type;\n\n\terror = coda_upcall(coda_vcp(sb), insize,\n\t\t\t    finalizer ? NULL : &outsize, inp);\n\n\t \n\tif (!finalizer || error)\n\t\tkvfree(inp);\n\n\t \n\tif (error == -EOPNOTSUPP) {\n\t\t*access_intent_supported = false;\n\t\terror = 0;\n\t}\n\treturn error;\n}\n\n \nstatic void coda_block_signals(sigset_t *old)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\t*old = current->blocked;\n\n\tsigfillset(&current->blocked);\n\tsigdelset(&current->blocked, SIGKILL);\n\tsigdelset(&current->blocked, SIGSTOP);\n\tsigdelset(&current->blocked, SIGINT);\n\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n}\n\nstatic void coda_unblock_signals(sigset_t *old)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->blocked = *old;\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n}\n\n \n#define CODA_INTERRUPTIBLE(r) (!coda_hard && \\\n\t\t\t       (((r)->uc_opcode != CODA_CLOSE && \\\n\t\t\t\t (r)->uc_opcode != CODA_STORE && \\\n\t\t\t\t (r)->uc_opcode != CODA_ACCESS_INTENT && \\\n\t\t\t\t (r)->uc_opcode != CODA_RELEASE) || \\\n\t\t\t\t(r)->uc_flags & CODA_REQ_READ))\n\nstatic inline void coda_waitfor_upcall(struct venus_comm *vcp,\n\t\t\t\t       struct upc_req *req)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tunsigned long timeout = jiffies + coda_timeout * HZ;\n\tsigset_t old;\n\tint blocked;\n\n\tcoda_block_signals(&old);\n\tblocked = 1;\n\n\tadd_wait_queue(&req->uc_sleep, &wait);\n\tfor (;;) {\n\t\tif (CODA_INTERRUPTIBLE(req))\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\telse\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t \n\t\tif (req->uc_flags & (CODA_REQ_WRITE | CODA_REQ_ABORT))\n\t\t\tbreak;\n\n\t\tif (blocked && time_after(jiffies, timeout) &&\n\t\t    CODA_INTERRUPTIBLE(req))\n\t\t{\n\t\t\tcoda_unblock_signals(&old);\n\t\t\tblocked = 0;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tlist_del(&req->uc_chain);\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_unlock(&vcp->vc_mutex);\n\t\tif (blocked)\n\t\t\tschedule_timeout(HZ);\n\t\telse\n\t\t\tschedule();\n\t\tmutex_lock(&vcp->vc_mutex);\n\t}\n\tif (blocked)\n\t\tcoda_unblock_signals(&old);\n\n\tremove_wait_queue(&req->uc_sleep, &wait);\n\tset_current_state(TASK_RUNNING);\n}\n\n\n \nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t \n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tbuffer->ih.unique = ++vcp->vc_seq;\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = outSize ? 0 : CODA_REQ_ASYNC;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = (outSize && *outSize) ? *outSize : inSize;\n\treq->uc_opcode = buffer->ih.opcode;\n\treq->uc_unique = buffer->ih.unique;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t \n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\n\t \n\tif (outSize == NULL) {\n\t\tmutex_unlock(&vcp->vc_mutex);\n\t\treturn 0;\n\t}\n\n\t \n\n\t \n\tcoda_waitfor_upcall(vcp, req);\n\n\t \n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t \n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t \n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tsig_inputArgs = kvzalloc(sizeof(*sig_inputArgs), GFP_KERNEL);\n\tif (!sig_inputArgs) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_data = (void *)sig_inputArgs;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t \n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}\n\n \n\n\n \n\nint coda_downcall(struct venus_comm *vcp, int opcode, union outputArgs *out,\n\t\t  size_t nbytes)\n{\n\tstruct inode *inode = NULL;\n\tstruct CodaFid *fid = NULL, *newfid;\n\tstruct super_block *sb;\n\n\t \n\tswitch (opcode) {\n\tcase CODA_PURGEUSER:\n\t\tif (nbytes < sizeof(struct coda_purgeuser_out))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase CODA_ZAPDIR:\n\t\tif (nbytes < sizeof(struct coda_zapdir_out))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase CODA_ZAPFILE:\n\t\tif (nbytes < sizeof(struct coda_zapfile_out))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase CODA_PURGEFID:\n\t\tif (nbytes < sizeof(struct coda_purgefid_out))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase CODA_REPLACE:\n\t\tif (nbytes < sizeof(struct coda_replace_out))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\t \n\tmutex_lock(&vcp->vc_mutex);\n\tsb = vcp->vc_sb;\n\tif (!sb || !sb->s_root)\n\t\tgoto unlock_out;\n\n\tswitch (opcode) {\n\tcase CODA_FLUSH:\n\t\tcoda_cache_clear_all(sb);\n\t\tshrink_dcache_sb(sb);\n\t\tif (d_really_is_positive(sb->s_root))\n\t\t\tcoda_flag_inode(d_inode(sb->s_root), C_FLUSH);\n\t\tbreak;\n\n\tcase CODA_PURGEUSER:\n\t\tcoda_cache_clear_all(sb);\n\t\tbreak;\n\n\tcase CODA_ZAPDIR:\n\t\tfid = &out->coda_zapdir.CodaFid;\n\t\tbreak;\n\n\tcase CODA_ZAPFILE:\n\t\tfid = &out->coda_zapfile.CodaFid;\n\t\tbreak;\n\n\tcase CODA_PURGEFID:\n\t\tfid = &out->coda_purgefid.CodaFid;\n\t\tbreak;\n\n\tcase CODA_REPLACE:\n\t\tfid = &out->coda_replace.OldFid;\n\t\tbreak;\n\t}\n\tif (fid)\n\t\tinode = coda_fid_to_inode(fid, sb);\n\nunlock_out:\n\tmutex_unlock(&vcp->vc_mutex);\n\n\tif (!inode)\n\t\treturn 0;\n\n\tswitch (opcode) {\n\tcase CODA_ZAPDIR:\n\t\tcoda_flag_inode_children(inode, C_PURGE);\n\t\tcoda_flag_inode(inode, C_VATTR);\n\t\tbreak;\n\n\tcase CODA_ZAPFILE:\n\t\tcoda_flag_inode(inode, C_VATTR);\n\t\tbreak;\n\n\tcase CODA_PURGEFID:\n\t\tcoda_flag_inode_children(inode, C_PURGE);\n\n\t\t \n\t\tcoda_flag_inode(inode, C_PURGE);\n\t\td_prune_aliases(inode);\n\t\tbreak;\n\n\tcase CODA_REPLACE:\n\t\tnewfid = &out->coda_replace.NewFid;\n\t\tcoda_replace_fid(inode, fid, newfid);\n\t\tbreak;\n\t}\n\tiput(inode);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}