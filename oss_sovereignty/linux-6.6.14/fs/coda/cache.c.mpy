{
  "module_name": "cache.c",
  "hash_id": "82bbb106eb1915a8cbda96e7cfde729d6271e1177bc2b378fa47bd7172ab175a",
  "original_prompt": "Ingested from linux-6.6.14/fs/coda/cache.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#include <linux/coda.h>\n#include \"coda_psdev.h\"\n#include \"coda_linux.h\"\n#include \"coda_cache.h\"\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\n \nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}\n\n \nvoid coda_cache_clear_inode(struct inode *inode)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch) - 1;\n\tspin_unlock(&cii->c_lock);\n}\n\n \nvoid coda_cache_clear_all(struct super_block *sb)\n{\n\tatomic_inc(&permission_epoch);\n}\n\n\n \nint coda_cache_check(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\tint hit;\n\t\n\tspin_lock(&cii->c_lock);\n\thit = (mask & cii->c_cached_perm) == mask &&\n\t    uid_eq(cii->c_uid, current_fsuid()) &&\n\t    cii->c_cached_epoch == atomic_read(&permission_epoch);\n\tspin_unlock(&cii->c_lock);\n\n\treturn hit;\n}\n\n\n \n \n\n \nstatic void coda_flag_children(struct dentry *parent, int flag)\n{\n\tstruct dentry *de;\n\n\tspin_lock(&parent->d_lock);\n\tlist_for_each_entry(de, &parent->d_subdirs, d_child) {\n\t\t \n\t\tif (d_inode(de) ) \n\t\t\tcoda_flag_inode(d_inode(de), flag);\n\t}\n\tspin_unlock(&parent->d_lock);\n\treturn; \n}\n\nvoid coda_flag_inode_children(struct inode *inode, int flag)\n{\n\tstruct dentry *alias_de;\n\n\tif ( !inode || !S_ISDIR(inode->i_mode)) \n\t\treturn; \n\n\talias_de = d_find_alias(inode);\n\tif (!alias_de)\n\t\treturn;\n\tcoda_flag_children(alias_de, flag);\n\tshrink_dcache_parent(alias_de);\n\tdput(alias_de);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}