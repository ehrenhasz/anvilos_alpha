{
  "module_name": "file.c",
  "hash_id": "7c41d9c614724e7558d6a365fc960d4258e74a388cd1ded78a7e666e6fd54fb1",
  "original_prompt": "Ingested from linux-6.6.14/fs/coda/file.c",
  "human_readable_source": "\n \n\n#include <linux/refcount.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/stat.h>\n#include <linux/cred.h>\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/splice.h>\n\n#include <linux/coda.h>\n#include \"coda_psdev.h\"\n#include \"coda_linux.h\"\n#include \"coda_int.h\"\n\nstruct coda_vm_ops {\n\trefcount_t refcnt;\n\tstruct file *coda_file;\n\tconst struct vm_operations_struct *host_vm_ops;\n\tstruct vm_operations_struct vm_ops;\n};\n\nstatic ssize_t\ncoda_file_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *coda_file = iocb->ki_filp;\n\tstruct inode *coda_inode = file_inode(coda_file);\n\tstruct coda_file_info *cfi = coda_ftoc(coda_file);\n\tloff_t ki_pos = iocb->ki_pos;\n\tsize_t count = iov_iter_count(to);\n\tssize_t ret;\n\n\tret = venus_access_intent(coda_inode->i_sb, coda_i2f(coda_inode),\n\t\t\t\t  &cfi->cfi_access_intent,\n\t\t\t\t  count, ki_pos, CODA_ACCESS_TYPE_READ);\n\tif (ret)\n\t\tgoto finish_read;\n\n\tret = vfs_iter_read(cfi->cfi_container, to, &iocb->ki_pos, 0);\n\nfinish_read:\n\tvenus_access_intent(coda_inode->i_sb, coda_i2f(coda_inode),\n\t\t\t    &cfi->cfi_access_intent,\n\t\t\t    count, ki_pos, CODA_ACCESS_TYPE_READ_FINISH);\n\treturn ret;\n}\n\nstatic ssize_t\ncoda_file_write_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *coda_file = iocb->ki_filp;\n\tstruct inode *coda_inode = file_inode(coda_file);\n\tstruct coda_file_info *cfi = coda_ftoc(coda_file);\n\tstruct file *host_file = cfi->cfi_container;\n\tloff_t ki_pos = iocb->ki_pos;\n\tsize_t count = iov_iter_count(to);\n\tssize_t ret;\n\n\tret = venus_access_intent(coda_inode->i_sb, coda_i2f(coda_inode),\n\t\t\t\t  &cfi->cfi_access_intent,\n\t\t\t\t  count, ki_pos, CODA_ACCESS_TYPE_WRITE);\n\tif (ret)\n\t\tgoto finish_write;\n\n\tfile_start_write(host_file);\n\tinode_lock(coda_inode);\n\tret = vfs_iter_write(cfi->cfi_container, to, &iocb->ki_pos, 0);\n\tcoda_inode->i_size = file_inode(host_file)->i_size;\n\tcoda_inode->i_blocks = (coda_inode->i_size + 511) >> 9;\n\tcoda_inode->i_mtime = inode_set_ctime_current(coda_inode);\n\tinode_unlock(coda_inode);\n\tfile_end_write(host_file);\n\nfinish_write:\n\tvenus_access_intent(coda_inode->i_sb, coda_i2f(coda_inode),\n\t\t\t    &cfi->cfi_access_intent,\n\t\t\t    count, ki_pos, CODA_ACCESS_TYPE_WRITE_FINISH);\n\treturn ret;\n}\n\nstatic ssize_t\ncoda_file_splice_read(struct file *coda_file, loff_t *ppos,\n\t\t      struct pipe_inode_info *pipe,\n\t\t      size_t len, unsigned int flags)\n{\n\tstruct inode *coda_inode = file_inode(coda_file);\n\tstruct coda_file_info *cfi = coda_ftoc(coda_file);\n\tstruct file *in = cfi->cfi_container;\n\tloff_t ki_pos = *ppos;\n\tssize_t ret;\n\n\tret = venus_access_intent(coda_inode->i_sb, coda_i2f(coda_inode),\n\t\t\t\t  &cfi->cfi_access_intent,\n\t\t\t\t  len, ki_pos, CODA_ACCESS_TYPE_READ);\n\tif (ret)\n\t\tgoto finish_read;\n\n\tret = vfs_splice_read(in, ppos, pipe, len, flags);\n\nfinish_read:\n\tvenus_access_intent(coda_inode->i_sb, coda_i2f(coda_inode),\n\t\t\t    &cfi->cfi_access_intent,\n\t\t\t    len, ki_pos, CODA_ACCESS_TYPE_READ_FINISH);\n\treturn ret;\n}\n\nstatic void\ncoda_vm_open(struct vm_area_struct *vma)\n{\n\tstruct coda_vm_ops *cvm_ops =\n\t\tcontainer_of(vma->vm_ops, struct coda_vm_ops, vm_ops);\n\n\trefcount_inc(&cvm_ops->refcnt);\n\n\tif (cvm_ops->host_vm_ops && cvm_ops->host_vm_ops->open)\n\t\tcvm_ops->host_vm_ops->open(vma);\n}\n\nstatic void\ncoda_vm_close(struct vm_area_struct *vma)\n{\n\tstruct coda_vm_ops *cvm_ops =\n\t\tcontainer_of(vma->vm_ops, struct coda_vm_ops, vm_ops);\n\n\tif (cvm_ops->host_vm_ops && cvm_ops->host_vm_ops->close)\n\t\tcvm_ops->host_vm_ops->close(vma);\n\n\tif (refcount_dec_and_test(&cvm_ops->refcnt)) {\n\t\tvma->vm_ops = cvm_ops->host_vm_ops;\n\t\tfput(cvm_ops->coda_file);\n\t\tkfree(cvm_ops);\n\t}\n}\n\nstatic int\ncoda_file_mmap(struct file *coda_file, struct vm_area_struct *vma)\n{\n\tstruct inode *coda_inode = file_inode(coda_file);\n\tstruct coda_file_info *cfi = coda_ftoc(coda_file);\n\tstruct file *host_file = cfi->cfi_container;\n\tstruct inode *host_inode = file_inode(host_file);\n\tstruct coda_inode_info *cii;\n\tstruct coda_vm_ops *cvm_ops;\n\tloff_t ppos;\n\tsize_t count;\n\tint ret;\n\n\tif (!host_file->f_op->mmap)\n\t\treturn -ENODEV;\n\n\tif (WARN_ON(coda_file != vma->vm_file))\n\t\treturn -EIO;\n\n\tcount = vma->vm_end - vma->vm_start;\n\tppos = vma->vm_pgoff * PAGE_SIZE;\n\n\tret = venus_access_intent(coda_inode->i_sb, coda_i2f(coda_inode),\n\t\t\t\t  &cfi->cfi_access_intent,\n\t\t\t\t  count, ppos, CODA_ACCESS_TYPE_MMAP);\n\tif (ret)\n\t\treturn ret;\n\n\tcvm_ops = kmalloc(sizeof(struct coda_vm_ops), GFP_KERNEL);\n\tif (!cvm_ops)\n\t\treturn -ENOMEM;\n\n\tcii = ITOC(coda_inode);\n\tspin_lock(&cii->c_lock);\n\tcoda_file->f_mapping = host_file->f_mapping;\n\tif (coda_inode->i_mapping == &coda_inode->i_data)\n\t\tcoda_inode->i_mapping = host_inode->i_mapping;\n\n\t \n\telse if (coda_inode->i_mapping != host_inode->i_mapping) {\n\t\tspin_unlock(&cii->c_lock);\n\t\tkfree(cvm_ops);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tcii->c_mapcount++;\n\tcfi->cfi_mapcount++;\n\tspin_unlock(&cii->c_lock);\n\n\tvma->vm_file = get_file(host_file);\n\tret = call_mmap(vma->vm_file, vma);\n\n\tif (ret) {\n\t\t \n\t\tfput(coda_file);\n\t\tkfree(cvm_ops);\n\t} else {\n\t\t \n\t\tcvm_ops->host_vm_ops = vma->vm_ops;\n\t\tif (vma->vm_ops)\n\t\t\tcvm_ops->vm_ops = *vma->vm_ops;\n\n\t\tcvm_ops->vm_ops.open = coda_vm_open;\n\t\tcvm_ops->vm_ops.close = coda_vm_close;\n\t\tcvm_ops->coda_file = coda_file;\n\t\trefcount_set(&cvm_ops->refcnt, 1);\n\n\t\tvma->vm_ops = &cvm_ops->vm_ops;\n\t}\n\treturn ret;\n}\n\nint coda_open(struct inode *coda_inode, struct file *coda_file)\n{\n\tstruct file *host_file = NULL;\n\tint error;\n\tunsigned short flags = coda_file->f_flags & (~O_EXCL);\n\tunsigned short coda_flags = coda_flags_to_cflags(flags);\n\tstruct coda_file_info *cfi;\n\n\tcfi = kmalloc(sizeof(struct coda_file_info), GFP_KERNEL);\n\tif (!cfi)\n\t\treturn -ENOMEM;\n\n\terror = venus_open(coda_inode->i_sb, coda_i2f(coda_inode), coda_flags,\n\t\t\t   &host_file);\n\tif (!host_file)\n\t\terror = -EIO;\n\n\tif (error) {\n\t\tkfree(cfi);\n\t\treturn error;\n\t}\n\n\thost_file->f_flags |= coda_file->f_flags & (O_APPEND | O_SYNC);\n\n\tcfi->cfi_magic = CODA_MAGIC;\n\tcfi->cfi_mapcount = 0;\n\tcfi->cfi_container = host_file;\n\t \n\tcfi->cfi_access_intent = true;\n\n\tBUG_ON(coda_file->private_data != NULL);\n\tcoda_file->private_data = cfi;\n\treturn 0;\n}\n\nint coda_release(struct inode *coda_inode, struct file *coda_file)\n{\n\tunsigned short flags = (coda_file->f_flags) & (~O_EXCL);\n\tunsigned short coda_flags = coda_flags_to_cflags(flags);\n\tstruct coda_file_info *cfi;\n\tstruct coda_inode_info *cii;\n\tstruct inode *host_inode;\n\n\tcfi = coda_ftoc(coda_file);\n\n\tvenus_close(coda_inode->i_sb, coda_i2f(coda_inode),\n\t\t\t  coda_flags, coda_file->f_cred->fsuid);\n\n\thost_inode = file_inode(cfi->cfi_container);\n\tcii = ITOC(coda_inode);\n\n\t \n\tspin_lock(&cii->c_lock);\n\tif (coda_inode->i_mapping == &host_inode->i_data) {\n\t\tcii->c_mapcount -= cfi->cfi_mapcount;\n\t\tif (!cii->c_mapcount)\n\t\t\tcoda_inode->i_mapping = &coda_inode->i_data;\n\t}\n\tspin_unlock(&cii->c_lock);\n\n\tfput(cfi->cfi_container);\n\tkfree(coda_file->private_data);\n\tcoda_file->private_data = NULL;\n\n\t \n\treturn 0;\n}\n\nint coda_fsync(struct file *coda_file, loff_t start, loff_t end, int datasync)\n{\n\tstruct file *host_file;\n\tstruct inode *coda_inode = file_inode(coda_file);\n\tstruct coda_file_info *cfi;\n\tint err;\n\n\tif (!(S_ISREG(coda_inode->i_mode) || S_ISDIR(coda_inode->i_mode) ||\n\t      S_ISLNK(coda_inode->i_mode)))\n\t\treturn -EINVAL;\n\n\terr = filemap_write_and_wait_range(coda_inode->i_mapping, start, end);\n\tif (err)\n\t\treturn err;\n\tinode_lock(coda_inode);\n\n\tcfi = coda_ftoc(coda_file);\n\thost_file = cfi->cfi_container;\n\n\terr = vfs_fsync(host_file, datasync);\n\tif (!err && !datasync)\n\t\terr = venus_fsync(coda_inode->i_sb, coda_i2f(coda_inode));\n\tinode_unlock(coda_inode);\n\n\treturn err;\n}\n\nconst struct file_operations coda_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read_iter\t= coda_file_read_iter,\n\t.write_iter\t= coda_file_write_iter,\n\t.mmap\t\t= coda_file_mmap,\n\t.open\t\t= coda_open,\n\t.release\t= coda_release,\n\t.fsync\t\t= coda_fsync,\n\t.splice_read\t= coda_file_splice_read,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}