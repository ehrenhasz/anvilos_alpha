{
  "module_name": "psdev.c",
  "hash_id": "8966b5dbc42984675493200f45b739c57b596b4225eba433827353a709353f4d",
  "original_prompt": "Ingested from linux-6.6.14/fs/coda/psdev.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/major.h>\n#include <linux/time.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/fcntl.h>\n#include <linux/delay.h>\n#include <linux/skbuff.h>\n#include <linux/proc_fs.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/pid_namespace.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#include <linux/coda.h>\n#include \"coda_psdev.h\"\n#include \"coda_linux.h\"\n\n#include \"coda_int.h\"\n\n \nint           coda_hard;          \nunsigned long coda_timeout = 30;  \n\n\nstruct venus_comm coda_comms[MAX_CODADEVS];\nstatic struct class *coda_psdev_class;\n\n \n\nstatic __poll_t coda_psdev_poll(struct file *file, poll_table * wait)\n{\n        struct venus_comm *vcp = (struct venus_comm *) file->private_data;\n\t__poll_t mask = EPOLLOUT | EPOLLWRNORM;\n\n\tpoll_wait(file, &vcp->vc_waitq, wait);\n\tmutex_lock(&vcp->vc_mutex);\n\tif (!list_empty(&vcp->vc_pending))\n                mask |= EPOLLIN | EPOLLRDNORM;\n\tmutex_unlock(&vcp->vc_mutex);\n\n\treturn mask;\n}\n\nstatic long coda_psdev_ioctl(struct file * filp, unsigned int cmd, unsigned long arg)\n{\n\tunsigned int data;\n\n\tswitch(cmd) {\n\tcase CIOC_KERNEL_VERSION:\n\t\tdata = CODA_KERNEL_VERSION;\n\t\treturn put_user(data, (int __user *) arg);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\treturn 0;\n}\n\n \n \nstatic ssize_t coda_psdev_write(struct file *file, const char __user *buf, \n\t\t\t\tsize_t nbytes, loff_t *off)\n{\n        struct venus_comm *vcp = (struct venus_comm *) file->private_data;\n        struct upc_req *req = NULL;\n        struct upc_req *tmp;\n\tstruct list_head *lh;\n\tstruct coda_in_hdr hdr;\n\tssize_t retval = 0, count = 0;\n\tint error;\n\n\t \n\tif (nbytes < (2 * sizeof(u_int32_t)))\n\t\treturn -EINVAL;\n\n         \n\tif (copy_from_user(&hdr, buf, 2 * sizeof(u_int32_t)))\n\t        return -EFAULT;\n\n        if (DOWNCALL(hdr.opcode)) {\n\t\tunion outputArgs *dcbuf;\n\t\tint size = sizeof(*dcbuf);\n\n\t\tif  ( nbytes < sizeof(struct coda_out_hdr) ) {\n\t\t\tpr_warn(\"coda_downcall opc %d uniq %d, not enough!\\n\",\n\t\t\t\thdr.opcode, hdr.unique);\n\t\t\tcount = nbytes;\n\t\t\tgoto out;\n\t\t}\n\t\tif ( nbytes > size ) {\n\t\t\tpr_warn(\"downcall opc %d, uniq %d, too much!\",\n\t\t\t\thdr.opcode, hdr.unique);\n\t\t        nbytes = size;\n\t\t}\n\n\t\tdcbuf = vmemdup_user(buf, nbytes);\n\t\tif (IS_ERR(dcbuf)) {\n\t\t\tretval = PTR_ERR(dcbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\terror = coda_downcall(vcp, hdr.opcode, dcbuf, nbytes);\n\n\t\tkvfree(dcbuf);\n\t\tif (error) {\n\t\t\tpr_warn(\"%s: coda_downcall error: %d\\n\",\n\t\t\t\t__func__, error);\n\t\t\tretval = error;\n\t\t\tgoto out;\n\t\t}\n\t\tcount = nbytes;\n\t\tgoto out;\n\t}\n        \n\t \n\tmutex_lock(&vcp->vc_mutex);\n\tlist_for_each(lh, &vcp->vc_processing) {\n\t\ttmp = list_entry(lh, struct upc_req , uc_chain);\n\t\tif (tmp->uc_unique == hdr.unique) {\n\t\t\treq = tmp;\n\t\t\tlist_del(&req->uc_chain);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vcp->vc_mutex);\n\n\tif (!req) {\n\t\tpr_warn(\"%s: msg (%d, %d) not found\\n\",\n\t\t\t__func__, hdr.opcode, hdr.unique);\n\t\tretval = -ESRCH;\n\t\tgoto out;\n\t}\n\n         \n\tif (req->uc_outSize < nbytes) {\n\t\tpr_warn(\"%s: too much cnt: %d, cnt: %ld, opc: %d, uniq: %d.\\n\",\n\t\t\t__func__, req->uc_outSize, (long)nbytes,\n\t\t\thdr.opcode, hdr.unique);\n\t\tnbytes = req->uc_outSize;  \n\t}\n        if (copy_from_user(req->uc_data, buf, nbytes)) {\n\t\treq->uc_flags |= CODA_REQ_ABORT;\n\t\twake_up(&req->uc_sleep);\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t \n\treq->uc_outSize = nbytes;\n\treq->uc_flags |= CODA_REQ_WRITE;\n\tcount = nbytes;\n\n\t \n\tif (req->uc_opcode == CODA_OPEN_BY_FD) {\n\t\tstruct coda_open_by_fd_out *outp =\n\t\t\t(struct coda_open_by_fd_out *)req->uc_data;\n\t\tif (!outp->oh.result) {\n\t\t\toutp->fh = fget(outp->fd);\n\t\t\tif (!outp->fh)\n\t\t\t\treturn -EBADF;\n\t\t}\n\t}\n\n        wake_up(&req->uc_sleep);\nout:\n        return(count ? count : retval);  \n}\n\n \n\nstatic ssize_t coda_psdev_read(struct file * file, char __user * buf, \n\t\t\t       size_t nbytes, loff_t *off)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n        struct venus_comm *vcp = (struct venus_comm *) file->private_data;\n        struct upc_req *req;\n\tssize_t retval = 0, count = 0;\n\n\tif (nbytes == 0)\n\t\treturn 0;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tadd_wait_queue(&vcp->vc_waitq, &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\twhile (list_empty(&vcp->vc_pending)) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&vcp->vc_mutex);\n\t\tschedule();\n\t\tmutex_lock(&vcp->vc_mutex);\n\t}\n\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&vcp->vc_waitq, &wait);\n\n\tif (retval)\n\t\tgoto out;\n\n\treq = list_entry(vcp->vc_pending.next, struct upc_req,uc_chain);\n\tlist_del(&req->uc_chain);\n\n\t \n\tcount = req->uc_inSize;\n\tif (nbytes < req->uc_inSize) {\n\t\tpr_warn(\"%s: Venus read %ld bytes of %d in message\\n\",\n\t\t\t__func__, (long)nbytes, req->uc_inSize);\n\t\tcount = nbytes;\n        }\n\n\tif (copy_to_user(buf, req->uc_data, count))\n\t        retval = -EFAULT;\n        \n\t \n\tif (!(req->uc_flags & CODA_REQ_ASYNC)) {\n\t\treq->uc_flags |= CODA_REQ_READ;\n\t\tlist_add_tail(&(req->uc_chain), &vcp->vc_processing);\n\t\tgoto out;\n\t}\n\n\tkvfree(req->uc_data);\n\tkfree(req);\nout:\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn (count ? count : retval);\n}\n\nstatic int coda_psdev_open(struct inode * inode, struct file * file)\n{\n\tstruct venus_comm *vcp;\n\tint idx, err;\n\n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -EINVAL;\n\n\tidx = iminor(inode);\n\tif (idx < 0 || idx >= MAX_CODADEVS)\n\t\treturn -ENODEV;\n\n\terr = -EBUSY;\n\tvcp = &coda_comms[idx];\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tvcp->vc_inuse++;\n\n\t\tINIT_LIST_HEAD(&vcp->vc_pending);\n\t\tINIT_LIST_HEAD(&vcp->vc_processing);\n\t\tinit_waitqueue_head(&vcp->vc_waitq);\n\t\tvcp->vc_sb = NULL;\n\t\tvcp->vc_seq = 0;\n\n\t\tfile->private_data = vcp;\n\t\terr = 0;\n\t}\n\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn err;\n}\n\n\nstatic int coda_psdev_release(struct inode * inode, struct file * file)\n{\n\tstruct venus_comm *vcp = (struct venus_comm *) file->private_data;\n\tstruct upc_req *req, *tmp;\n\n\tif (!vcp || !vcp->vc_inuse ) {\n\t\tpr_warn(\"%s: Not open.\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\t \n\tlist_for_each_entry_safe(req, tmp, &vcp->vc_pending, uc_chain) {\n\t\tlist_del(&req->uc_chain);\n\n\t\t \n\t\tif (req->uc_flags & CODA_REQ_ASYNC) {\n\t\t\tkvfree(req->uc_data);\n\t\t\tkfree(req);\n\t\t\tcontinue;\n\t\t}\n\t\treq->uc_flags |= CODA_REQ_ABORT;\n\t\twake_up(&req->uc_sleep);\n\t}\n\n\tlist_for_each_entry_safe(req, tmp, &vcp->vc_processing, uc_chain) {\n\t\tlist_del(&req->uc_chain);\n\n\t\treq->uc_flags |= CODA_REQ_ABORT;\n\t\twake_up(&req->uc_sleep);\n\t}\n\n\tfile->private_data = NULL;\n\tvcp->vc_inuse--;\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn 0;\n}\n\n\nstatic const struct file_operations coda_psdev_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= coda_psdev_read,\n\t.write\t\t= coda_psdev_write,\n\t.poll\t\t= coda_psdev_poll,\n\t.unlocked_ioctl\t= coda_psdev_ioctl,\n\t.open\t\t= coda_psdev_open,\n\t.release\t= coda_psdev_release,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int __init init_coda_psdev(void)\n{\n\tint i, err = 0;\n\tif (register_chrdev(CODA_PSDEV_MAJOR, \"coda\", &coda_psdev_fops)) {\n\t\tpr_err(\"%s: unable to get major %d\\n\",\n\t\t       __func__, CODA_PSDEV_MAJOR);\n\t\treturn -EIO;\n\t}\n\tcoda_psdev_class = class_create(\"coda\");\n\tif (IS_ERR(coda_psdev_class)) {\n\t\terr = PTR_ERR(coda_psdev_class);\n\t\tgoto out_chrdev;\n\t}\t\t\n\tfor (i = 0; i < MAX_CODADEVS; i++) {\n\t\tmutex_init(&(&coda_comms[i])->vc_mutex);\n\t\tdevice_create(coda_psdev_class, NULL,\n\t\t\t      MKDEV(CODA_PSDEV_MAJOR, i), NULL, \"cfs%d\", i);\n\t}\n\tcoda_sysctl_init();\n\tgoto out;\n\nout_chrdev:\n\tunregister_chrdev(CODA_PSDEV_MAJOR, \"coda\");\nout:\n\treturn err;\n}\n\nMODULE_AUTHOR(\"Jan Harkes, Peter J. Braam\");\nMODULE_DESCRIPTION(\"Coda Distributed File System VFS interface\");\nMODULE_ALIAS_CHARDEV_MAJOR(CODA_PSDEV_MAJOR);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"7.2\");\n\nstatic int __init init_coda(void)\n{\n\tint status;\n\tint i;\n\n\tstatus = coda_init_inodecache();\n\tif (status)\n\t\tgoto out2;\n\tstatus = init_coda_psdev();\n\tif ( status ) {\n\t\tpr_warn(\"Problem (%d) in init_coda_psdev\\n\", status);\n\t\tgoto out1;\n\t}\n\t\n\tstatus = register_filesystem(&coda_fs_type);\n\tif (status) {\n\t\tpr_warn(\"failed to register filesystem!\\n\");\n\t\tgoto out;\n\t}\n\treturn 0;\nout:\n\tfor (i = 0; i < MAX_CODADEVS; i++)\n\t\tdevice_destroy(coda_psdev_class, MKDEV(CODA_PSDEV_MAJOR, i));\n\tclass_destroy(coda_psdev_class);\n\tunregister_chrdev(CODA_PSDEV_MAJOR, \"coda\");\n\tcoda_sysctl_clean();\nout1:\n\tcoda_destroy_inodecache();\nout2:\n\treturn status;\n}\n\nstatic void __exit exit_coda(void)\n{\n        int err, i;\n\n\terr = unregister_filesystem(&coda_fs_type);\n\tif (err != 0)\n\t\tpr_warn(\"failed to unregister filesystem\\n\");\n\tfor (i = 0; i < MAX_CODADEVS; i++)\n\t\tdevice_destroy(coda_psdev_class, MKDEV(CODA_PSDEV_MAJOR, i));\n\tclass_destroy(coda_psdev_class);\n\tunregister_chrdev(CODA_PSDEV_MAJOR, \"coda\");\n\tcoda_sysctl_clean();\n\tcoda_destroy_inodecache();\n}\n\nmodule_init(init_coda);\nmodule_exit(exit_coda);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}