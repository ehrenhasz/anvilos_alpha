{
  "module_name": "cnode.c",
  "hash_id": "992c3ee4793ff7d13aecadcad6a5e3edd24c271ff8711c00234212997cd8b42b",
  "original_prompt": "Ingested from linux-6.6.14/fs/coda/cnode.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\n#include <linux/coda.h>\n#include <linux/pagemap.h>\n#include \"coda_psdev.h\"\n#include \"coda_linux.h\"\n\nstatic inline int coda_fideq(struct CodaFid *fid1, struct CodaFid *fid2)\n{\n\treturn memcmp(fid1, fid2, sizeof(*fid1)) == 0;\n}\n\nstatic const struct inode_operations coda_symlink_inode_operations = {\n\t.get_link\t= page_get_link,\n\t.setattr\t= coda_setattr,\n};\n\n \nstatic void coda_fill_inode(struct inode *inode, struct coda_vattr *attr)\n{\n        coda_vattr_to_iattr(inode, attr);\n\n        if (S_ISREG(inode->i_mode)) {\n                inode->i_op = &coda_file_inode_operations;\n                inode->i_fop = &coda_file_operations;\n        } else if (S_ISDIR(inode->i_mode)) {\n                inode->i_op = &coda_dir_inode_operations;\n                inode->i_fop = &coda_dir_operations;\n        } else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &coda_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_data.a_ops = &coda_symlink_aops;\n\t\tinode->i_mapping = &inode->i_data;\n\t} else\n                init_special_inode(inode, inode->i_mode, huge_decode_dev(attr->va_rdev));\n}\n\nstatic int coda_test_inode(struct inode *inode, void *data)\n{\n\tstruct CodaFid *fid = (struct CodaFid *)data;\n\tstruct coda_inode_info *cii = ITOC(inode);\n\treturn coda_fideq(&cii->c_fid, fid);\n}\n\nstatic int coda_set_inode(struct inode *inode, void *data)\n{\n\tstruct CodaFid *fid = (struct CodaFid *)data;\n\tstruct coda_inode_info *cii = ITOC(inode);\n\tcii->c_fid = *fid;\n\treturn 0;\n}\n\nstruct inode * coda_iget(struct super_block * sb, struct CodaFid * fid,\n\t\t\t struct coda_vattr * attr)\n{\n\tstruct inode *inode;\n\tstruct coda_inode_info *cii;\n\tunsigned long hash = coda_f2i(fid);\n\tumode_t inode_type = coda_inode_type(attr);\n\nretry:\n\tinode = iget5_locked(sb, hash, coda_test_inode, coda_set_inode, fid);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tcii = ITOC(inode);\n\t\t \n\t\tinode->i_ino = hash;\n\t\t \n\t\tcii->c_mapcount = 0;\n\t\tcoda_fill_inode(inode, attr);\n\t\tunlock_new_inode(inode);\n\t} else if ((inode->i_mode & S_IFMT) != inode_type) {\n\t\t \n\t\tremove_inode_hash(inode);\n\t\tcoda_flag_inode(inode, C_PURGE);\n\t\tiput(inode);\n\t\tgoto retry;\n\t}\n\treturn inode;\n}\n\n \nstruct inode *coda_cnode_make(struct CodaFid *fid, struct super_block *sb)\n{\n        struct coda_vattr attr;\n\tstruct inode *inode;\n        int error;\n        \n\t \n\terror = venus_getattr(sb, fid, &attr);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tinode = coda_iget(sb, fid, &attr);\n\tif (IS_ERR(inode))\n\t\tpr_warn(\"%s: coda_iget failed\\n\", __func__);\n\treturn inode;\n}\n\n\n \nvoid coda_replace_fid(struct inode *inode, struct CodaFid *oldfid, \n\t\t      struct CodaFid *newfid)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\tunsigned long hash = coda_f2i(newfid);\n\t\n\tBUG_ON(!coda_fideq(&cii->c_fid, oldfid));\n\n\t \n\t \n\tremove_inode_hash(inode);\n\tcii->c_fid = *newfid;\n\tinode->i_ino = hash;\n\t__insert_inode_hash(inode, hash);\n}\n\n \nstruct inode *coda_fid_to_inode(struct CodaFid *fid, struct super_block *sb) \n{\n\tstruct inode *inode;\n\tunsigned long hash = coda_f2i(fid);\n\n\tinode = ilookup5(sb, hash, coda_test_inode, fid);\n\tif ( !inode )\n\t\treturn NULL;\n\n\t \n\tBUG_ON(inode->i_state & I_NEW);\n\n\treturn inode;\n}\n\nstruct coda_file_info *coda_ftoc(struct file *file)\n{\n\tstruct coda_file_info *cfi = file->private_data;\n\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\n\treturn cfi;\n\n}\n\n \nstruct inode *coda_cnode_makectl(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = CTL_INO;\n\t\tinode->i_op = &coda_ioctl_inode_operations;\n\t\tinode->i_fop = &coda_ioctl_operations;\n\t\tinode->i_mode = 0444;\n\t\treturn inode;\n\t}\n\treturn ERR_PTR(-ENOMEM);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}