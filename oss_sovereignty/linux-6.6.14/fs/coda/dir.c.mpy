{
  "module_name": "dir.c",
  "hash_id": "d9ad68070bcb7b203a1f7697db5a1f22cb190e1c4f4ff53bad5241fa9e98f2f6",
  "original_prompt": "Ingested from linux-6.6.14/fs/coda/dir.c",
  "human_readable_source": "\n\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/namei.h>\n#include <linux/uaccess.h>\n\n#include <linux/coda.h>\n#include \"coda_psdev.h\"\n#include \"coda_linux.h\"\n#include \"coda_cache.h\"\n\n#include \"coda_int.h\"\n\n \nstatic int coda_return_EIO(void)\n{\n\treturn -EIO;\n}\n#define CODA_EIO_ERROR ((void *) (coda_return_EIO))\n\n \n \nstatic struct dentry *coda_lookup(struct inode *dir, struct dentry *entry, unsigned int flags)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tconst char *name = entry->d_name.name;\n\tsize_t length = entry->d_name.len;\n\tstruct inode *inode;\n\tint type = 0;\n\n\tif (length > CODA_MAXNAMLEN) {\n\t\tpr_err(\"name too long: lookup, %s %zu\\n\",\n\t\t       coda_i2s(dir), length);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\n\t \n\tif (is_root_inode(dir) && coda_iscontrol(name, length)) {\n\t\tinode = coda_cnode_makectl(sb);\n\t\ttype = CODA_NOCACHE;\n\t} else {\n\t\tstruct CodaFid fid = { { 0, } };\n\t\tint error = venus_lookup(sb, coda_i2f(dir), name, length,\n\t\t\t\t     &type, &fid);\n\t\tinode = !error ? coda_cnode_make(&fid, sb) : ERR_PTR(error);\n\t}\n\n\tif (!IS_ERR(inode) && (type & CODA_NOCACHE))\n\t\tcoda_flag_inode(inode, C_VATTR | C_PURGE);\n\n\tif (inode == ERR_PTR(-ENOENT))\n\t\tinode = NULL;\n\n\treturn d_splice_alias(inode, entry);\n}\n\n\nint coda_permission(struct mnt_idmap *idmap, struct inode *inode,\n\t\t    int mask)\n{\n\tint error;\n\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n \n\tif (!mask)\n\t\treturn 0;\n\n\tif ((mask & MAY_EXEC) && !execute_ok(inode))\n\t\treturn -EACCES;\n\n\tif (coda_cache_check(inode, mask))\n\t\treturn 0;\n\n\terror = venus_access(inode->i_sb, coda_i2f(inode), mask);\n    \n\tif (!error)\n\t\tcoda_cache_enter(inode, mask);\n\n\treturn error;\n}\n\n\nstatic inline void coda_dir_update_mtime(struct inode *dir)\n{\n#ifdef REQUERY_VENUS_FOR_MTIME\n\t \n\tcoda_flag_inode(dir, C_VATTR);\n#else\n\t \n\tdir->i_mtime = inode_set_ctime_current(dir);\n#endif\n}\n\n \nstatic inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}\n\nstatic inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}\n\n \nstatic int coda_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *de, umode_t mode, bool excl)\n{\n\tint error;\n\tconst char *name=de->d_name.name;\n\tint length=de->d_name.len;\n\tstruct inode *inode;\n\tstruct CodaFid newfid;\n\tstruct coda_vattr attrs;\n\n\tif (is_root_inode(dir) && coda_iscontrol(name, length))\n\t\treturn -EPERM;\n\n\terror = venus_create(dir->i_sb, coda_i2f(dir), name, length, \n\t\t\t\t0, mode, &newfid, &attrs);\n\tif (error)\n\t\tgoto err_out;\n\n\tinode = coda_iget(dir->i_sb, &newfid, &attrs);\n\tif (IS_ERR(inode)) {\n\t\terror = PTR_ERR(inode);\n\t\tgoto err_out;\n\t}\n\n\t \n\tcoda_dir_update_mtime(dir);\n\td_instantiate(de, inode);\n\treturn 0;\nerr_out:\n\td_drop(de);\n\treturn error;\n}\n\nstatic int coda_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *de, umode_t mode)\n{\n\tstruct inode *inode;\n\tstruct coda_vattr attrs;\n\tconst char *name = de->d_name.name;\n\tint len = de->d_name.len;\n\tint error;\n\tstruct CodaFid newfid;\n\n\tif (is_root_inode(dir) && coda_iscontrol(name, len))\n\t\treturn -EPERM;\n\n\tattrs.va_mode = mode;\n\terror = venus_mkdir(dir->i_sb, coda_i2f(dir), \n\t\t\t       name, len, &newfid, &attrs);\n\tif (error)\n\t\tgoto err_out;\n         \n\tinode = coda_iget(dir->i_sb, &newfid, &attrs);\n\tif (IS_ERR(inode)) {\n\t\terror = PTR_ERR(inode);\n\t\tgoto err_out;\n\t}\n\n\t \n\tcoda_dir_inc_nlink(dir);\n\tcoda_dir_update_mtime(dir);\n\td_instantiate(de, inode);\n\treturn 0;\nerr_out:\n\td_drop(de);\n\treturn error;\n}\n\n  \nstatic int coda_link(struct dentry *source_de, struct inode *dir_inode, \n\t  struct dentry *de)\n{\n\tstruct inode *inode = d_inode(source_de);\n        const char * name = de->d_name.name;\n\tint len = de->d_name.len;\n\tint error;\n\n\tif (is_root_inode(dir_inode) && coda_iscontrol(name, len))\n\t\treturn -EPERM;\n\n\terror = venus_link(dir_inode->i_sb, coda_i2f(inode),\n\t\t\t   coda_i2f(dir_inode), (const char *)name, len);\n\tif (error) {\n\t\td_drop(de);\n\t\treturn error;\n\t}\n\n\tcoda_dir_update_mtime(dir_inode);\n\tihold(inode);\n\td_instantiate(de, inode);\n\tinc_nlink(inode);\n\treturn 0;\n}\n\n\nstatic int coda_symlink(struct mnt_idmap *idmap,\n\t\t\tstruct inode *dir_inode, struct dentry *de,\n\t\t\tconst char *symname)\n{\n\tconst char *name = de->d_name.name;\n\tint len = de->d_name.len;\n\tint symlen;\n\tint error;\n\n\tif (is_root_inode(dir_inode) && coda_iscontrol(name, len))\n\t\treturn -EPERM;\n\n\tsymlen = strlen(symname);\n\tif (symlen > CODA_MAXPATHLEN)\n\t\treturn -ENAMETOOLONG;\n\n\t \n\td_drop(de);\n\terror = venus_symlink(dir_inode->i_sb, coda_i2f(dir_inode), name, len,\n\t\t\t      symname, symlen);\n\n\t \n\tif (!error)\n\t\tcoda_dir_update_mtime(dir_inode);\n\n\treturn error;\n}\n\n \nstatic int coda_unlink(struct inode *dir, struct dentry *de)\n{\n        int error;\n\tconst char *name = de->d_name.name;\n\tint len = de->d_name.len;\n\n\terror = venus_remove(dir->i_sb, coda_i2f(dir), name, len);\n\tif (error)\n\t\treturn error;\n\n\tcoda_dir_update_mtime(dir);\n\tdrop_nlink(d_inode(de));\n\treturn 0;\n}\n\nstatic int coda_rmdir(struct inode *dir, struct dentry *de)\n{\n\tconst char *name = de->d_name.name;\n\tint len = de->d_name.len;\n\tint error;\n\n\terror = venus_rmdir(dir->i_sb, coda_i2f(dir), name, len);\n\tif (!error) {\n\t\t \n\t\tif (d_really_is_positive(de))\n\t\t\tclear_nlink(d_inode(de));\n\n\t\t \n\t\tcoda_dir_drop_nlink(dir);\n\t\tcoda_dir_update_mtime(dir);\n\t}\n\treturn error;\n}\n\n \nstatic int coda_rename(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\t       struct dentry *old_dentry, struct inode *new_dir,\n\t\t       struct dentry *new_dentry, unsigned int flags)\n{\n\tconst char *old_name = old_dentry->d_name.name;\n\tconst char *new_name = new_dentry->d_name.name;\n\tint old_length = old_dentry->d_name.len;\n\tint new_length = new_dentry->d_name.len;\n\tint error;\n\n\tif (flags)\n\t\treturn -EINVAL;\n\n\terror = venus_rename(old_dir->i_sb, coda_i2f(old_dir),\n\t\t\t     coda_i2f(new_dir), old_length, new_length,\n\t\t\t     (const char *) old_name, (const char *)new_name);\n\tif (!error) {\n\t\tif (d_really_is_positive(new_dentry)) {\n\t\t\tif (d_is_dir(new_dentry)) {\n\t\t\t\tcoda_dir_drop_nlink(old_dir);\n\t\t\t\tcoda_dir_inc_nlink(new_dir);\n\t\t\t}\n\t\t\tcoda_flag_inode(d_inode(new_dentry), C_VATTR);\n\t\t}\n\t\tcoda_dir_update_mtime(old_dir);\n\t\tcoda_dir_update_mtime(new_dir);\n\t}\n\treturn error;\n}\n\nstatic inline unsigned int CDT2DT(unsigned char cdt)\n{\n\tunsigned int dt;\n\n\tswitch(cdt) {\n\tcase CDT_UNKNOWN: dt = DT_UNKNOWN; break;\n\tcase CDT_FIFO:\t  dt = DT_FIFO;    break;\n\tcase CDT_CHR:\t  dt = DT_CHR;     break;\n\tcase CDT_DIR:\t  dt = DT_DIR;     break;\n\tcase CDT_BLK:\t  dt = DT_BLK;     break;\n\tcase CDT_REG:\t  dt = DT_REG;     break;\n\tcase CDT_LNK:\t  dt = DT_LNK;     break;\n\tcase CDT_SOCK:\t  dt = DT_SOCK;    break;\n\tcase CDT_WHT:\t  dt = DT_WHT;     break;\n\tdefault:\t  dt = DT_UNKNOWN; break;\n\t}\n\treturn dt;\n}\n\n \nstatic int coda_venus_readdir(struct file *coda_file, struct dir_context *ctx)\n{\n\tstruct coda_file_info *cfi;\n\tstruct coda_inode_info *cii;\n\tstruct file *host_file;\n\tstruct venus_dirent *vdir;\n\tunsigned long vdir_size = offsetof(struct venus_dirent, d_name);\n\tunsigned int type;\n\tstruct qstr name;\n\tino_t ino;\n\tint ret;\n\n\tcfi = coda_ftoc(coda_file);\n\thost_file = cfi->cfi_container;\n\n\tcii = ITOC(file_inode(coda_file));\n\n\tvdir = kmalloc(sizeof(*vdir), GFP_KERNEL);\n\tif (!vdir) return -ENOMEM;\n\n\tif (!dir_emit_dots(coda_file, ctx))\n\t\tgoto out;\n\n\twhile (1) {\n\t\tloff_t pos = ctx->pos - 2;\n\n\t\t \n\t\tret = kernel_read(host_file, vdir, sizeof(*vdir), &pos);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"%s: read dir %s failed %d\\n\",\n\t\t\t       __func__, coda_f2s(&cii->c_fid), ret);\n\t\t\tbreak;\n\t\t}\n\t\tif (ret == 0) break;  \n\n\t\t \n\t\tif (ret < vdir_size || ret < vdir_size + vdir->d_namlen) {\n\t\t\tpr_err(\"%s: short read on %s\\n\",\n\t\t\t       __func__, coda_f2s(&cii->c_fid));\n\t\t\tret = -EBADF;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (vdir->d_reclen < vdir_size + vdir->d_namlen) {\n\t\t\tpr_err(\"%s: invalid dir %s\\n\",\n\t\t\t       __func__, coda_f2s(&cii->c_fid));\n\t\t\tret = -EBADF;\n\t\t\tbreak;\n\t\t}\n\n\t\tname.len = vdir->d_namlen;\n\t\tname.name = vdir->d_name;\n\n\t\t \n\t\tif (name.name[0] == '.' && (name.len == 1 ||\n\t\t    (name.name[1] == '.' && name.len == 2)))\n\t\t\tvdir->d_fileno = name.len = 0;\n\n\t\t \n\t\tif (vdir->d_fileno && name.len) {\n\t\t\tino = vdir->d_fileno;\n\t\t\ttype = CDT2DT(vdir->d_type);\n\t\t\tif (!dir_emit(ctx, name.name, name.len, ino, type))\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tctx->pos += vdir->d_reclen;\n\t}\nout:\n\tkfree(vdir);\n\treturn 0;\n}\n\n \nstatic int coda_readdir(struct file *coda_file, struct dir_context *ctx)\n{\n\tstruct coda_file_info *cfi;\n\tstruct file *host_file;\n\tint ret;\n\n\tcfi = coda_ftoc(coda_file);\n\thost_file = cfi->cfi_container;\n\n\tif (host_file->f_op->iterate_shared) {\n\t\tstruct inode *host_inode = file_inode(host_file);\n\t\tret = -ENOENT;\n\t\tif (!IS_DEADDIR(host_inode)) {\n\t\t\tinode_lock_shared(host_inode);\n\t\t\tret = host_file->f_op->iterate_shared(host_file, ctx);\n\t\t\tfile_accessed(host_file);\n\t\t\tinode_unlock_shared(host_inode);\n\t\t}\n\t\treturn ret;\n\t}\n\t \n\treturn coda_venus_readdir(coda_file, ctx);\n}\n\n \nstatic int coda_dentry_revalidate(struct dentry *de, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct coda_inode_info *cii;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = d_inode(de);\n\tif (!inode || is_root_inode(inode))\n\t\tgoto out;\n\tif (is_bad_inode(inode))\n\t\tgoto bad;\n\n\tcii = ITOC(d_inode(de));\n\tif (!(cii->c_flags & (C_PURGE | C_FLUSH)))\n\t\tgoto out;\n\n\tshrink_dcache_parent(de);\n\n\t \n\tif (cii->c_flags & C_FLUSH) \n\t\tcoda_flag_inode_children(inode, C_FLUSH);\n\n\tif (d_count(de) > 1)\n\t\t \n\t\tgoto out;\n\n\t \n\tspin_lock(&cii->c_lock);\n\tcii->c_flags &= ~(C_VATTR | C_PURGE | C_FLUSH);\n\tspin_unlock(&cii->c_lock);\nbad:\n\treturn 0;\nout:\n\treturn 1;\n}\n\n \nstatic int coda_dentry_delete(const struct dentry * dentry)\n{\n\tstruct inode *inode;\n\tstruct coda_inode_info *cii;\n\n\tif (d_really_is_negative(dentry)) \n\t\treturn 0;\n\n\tinode = d_inode(dentry);\n\tif (!inode || is_bad_inode(inode))\n\t\treturn 1;\n\n\tcii = ITOC(inode);\n\tif (cii->c_flags & C_PURGE)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n\n\n \nint coda_revalidate_inode(struct inode *inode)\n{\n\tstruct coda_vattr attr;\n\tint error;\n\tint old_mode;\n\tino_t old_ino;\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tif (!cii->c_flags)\n\t\treturn 0;\n\n\tif (cii->c_flags & (C_VATTR | C_PURGE | C_FLUSH)) {\n\t\terror = venus_getattr(inode->i_sb, &(cii->c_fid), &attr);\n\t\tif (error)\n\t\t\treturn -EIO;\n\n\t\t \n\t\told_mode = inode->i_mode;\n\t\told_ino = inode->i_ino;\n\t\tcoda_vattr_to_iattr(inode, &attr);\n\n\t\tif ((old_mode & S_IFMT) != (inode->i_mode & S_IFMT)) {\n\t\t\tpr_warn(\"inode %ld, fid %s changed type!\\n\",\n\t\t\t\tinode->i_ino, coda_f2s(&(cii->c_fid)));\n\t\t}\n\n\t\t \n\t\tif (inode->i_ino != old_ino)\n\t\t\treturn -EIO;\n\t\t\n\t\tcoda_flag_inode_children(inode, C_FLUSH);\n\n\t\tspin_lock(&cii->c_lock);\n\t\tcii->c_flags &= ~(C_VATTR | C_PURGE | C_FLUSH);\n\t\tspin_unlock(&cii->c_lock);\n\t}\n\treturn 0;\n}\n\nconst struct dentry_operations coda_dentry_operations = {\n\t.d_revalidate\t= coda_dentry_revalidate,\n\t.d_delete\t= coda_dentry_delete,\n};\n\nconst struct inode_operations coda_dir_inode_operations = {\n\t.create\t\t= coda_create,\n\t.lookup\t\t= coda_lookup,\n\t.link\t\t= coda_link,\n\t.unlink\t\t= coda_unlink,\n\t.symlink\t= coda_symlink,\n\t.mkdir\t\t= coda_mkdir,\n\t.rmdir\t\t= coda_rmdir,\n\t.mknod\t\t= CODA_EIO_ERROR,\n\t.rename\t\t= coda_rename,\n\t.permission\t= coda_permission,\n\t.getattr\t= coda_getattr,\n\t.setattr\t= coda_setattr,\n};\n\nWRAP_DIR_ITER(coda_readdir) \nconst struct file_operations coda_dir_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= shared_coda_readdir,\n\t.open\t\t= coda_open,\n\t.release\t= coda_release,\n\t.fsync\t\t= coda_fsync,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}