{
  "module_name": "inode.c",
  "hash_id": "42a323fd1751453f0d2ac858d98a0c1e88f8633682083edd18c00380e151a57c",
  "original_prompt": "Ingested from linux-6.6.14/fs/qnx6/inode.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/highuid.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/crc32.h>\n#include <linux/mpage.h>\n#include \"qnx6.h\"\n\nstatic const struct super_operations qnx6_sops;\n\nstatic void qnx6_put_super(struct super_block *sb);\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb);\nstatic void qnx6_free_inode(struct inode *inode);\nstatic int qnx6_remount(struct super_block *sb, int *flags, char *data);\nstatic int qnx6_statfs(struct dentry *dentry, struct kstatfs *buf);\nstatic int qnx6_show_options(struct seq_file *seq, struct dentry *root);\n\nstatic const struct super_operations qnx6_sops = {\n\t.alloc_inode\t= qnx6_alloc_inode,\n\t.free_inode\t= qnx6_free_inode,\n\t.put_super\t= qnx6_put_super,\n\t.statfs\t\t= qnx6_statfs,\n\t.remount_fs\t= qnx6_remount,\n\t.show_options\t= qnx6_show_options,\n};\n\nstatic int qnx6_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\n\tif (sbi->s_mount_opt & QNX6_MOUNT_MMI_FS)\n\t\tseq_puts(seq, \",mmi_fs\");\n\treturn 0;\n}\n\nstatic int qnx6_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= SB_RDONLY;\n\treturn 0;\n}\n\nstatic unsigned qnx6_get_devblock(struct super_block *sb, __fs32 block)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\treturn fs32_to_cpu(sbi, block) + sbi->s_blks_off;\n}\n\nstatic unsigned qnx6_block_map(struct inode *inode, unsigned iblock);\n\nstatic int qnx6_get_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create)\n{\n\tunsigned phys;\n\n\tpr_debug(\"qnx6_get_block inode=[%ld] iblock=[%ld]\\n\",\n\t\t inode->i_ino, (unsigned long)iblock);\n\n\tphys = qnx6_block_map(inode, iblock);\n\tif (phys) {\n\t\t \n\t\tmap_bh(bh, inode->i_sb, phys);\n\t}\n\treturn 0;\n}\n\nstatic int qnx6_check_blockptr(__fs32 ptr)\n{\n\tif (ptr == ~(__fs32)0) {\n\t\tpr_err(\"hit unused blockpointer.\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int qnx6_read_folio(struct file *file, struct folio *folio)\n{\n\treturn mpage_read_folio(folio, qnx6_get_block);\n}\n\nstatic void qnx6_readahead(struct readahead_control *rac)\n{\n\tmpage_readahead(rac, qnx6_get_block);\n}\n\n \nstatic unsigned qnx6_block_map(struct inode *inode, unsigned no)\n{\n\tstruct super_block *s = inode->i_sb;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\tstruct qnx6_inode_info *ei = QNX6_I(inode);\n\tunsigned block = 0;\n\tstruct buffer_head *bh;\n\t__fs32 ptr;\n\tint levelptr;\n\tint ptrbits = sbi->s_ptrbits;\n\tint bitdelta;\n\tu32 mask = (1 << ptrbits) - 1;\n\tint depth = ei->di_filelevels;\n\tint i;\n\n\tbitdelta = ptrbits * depth;\n\tlevelptr = no >> bitdelta;\n\n\tif (levelptr > QNX6_NO_DIRECT_POINTERS - 1) {\n\t\tpr_err(\"Requested file block number (%u) too big.\", no);\n\t\treturn 0;\n\t}\n\n\tblock = qnx6_get_devblock(s, ei->di_block_ptr[levelptr]);\n\n\tfor (i = 0; i < depth; i++) {\n\t\tbh = sb_bread(s, block);\n\t\tif (!bh) {\n\t\t\tpr_err(\"Error reading block (%u)\\n\", block);\n\t\t\treturn 0;\n\t\t}\n\t\tbitdelta -= ptrbits;\n\t\tlevelptr = (no >> bitdelta) & mask;\n\t\tptr = ((__fs32 *)bh->b_data)[levelptr];\n\n\t\tif (!qnx6_check_blockptr(ptr))\n\t\t\treturn 0;\n\n\t\tblock = qnx6_get_devblock(s, ptr);\n\t\tbrelse(bh);\n\t}\n\treturn block;\n}\n\nstatic int qnx6_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type    = sb->s_magic;\n\tbuf->f_bsize   = sb->s_blocksize;\n\tbuf->f_blocks  = fs32_to_cpu(sbi, sbi->sb->sb_num_blocks);\n\tbuf->f_bfree   = fs32_to_cpu(sbi, sbi->sb->sb_free_blocks);\n\tbuf->f_files   = fs32_to_cpu(sbi, sbi->sb->sb_num_inodes);\n\tbuf->f_ffree   = fs32_to_cpu(sbi, sbi->sb->sb_free_inodes);\n\tbuf->f_bavail  = buf->f_bfree;\n\tbuf->f_namelen = QNX6_LONG_NAME_MAX;\n\tbuf->f_fsid    = u64_to_fsid(id);\n\n\treturn 0;\n}\n\n \nstatic const char *qnx6_checkroot(struct super_block *s)\n{\n\tstatic char match_root[2][3] = {\".\\0\\0\", \"..\\0\"};\n\tint i, error = 0;\n\tstruct qnx6_dir_entry *dir_entry;\n\tstruct inode *root = d_inode(s->s_root);\n\tstruct address_space *mapping = root->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\treturn \"error reading root directory\";\n\tkmap(page);\n\tdir_entry = page_address(page);\n\tfor (i = 0; i < 2; i++) {\n\t\t \n\t\tif (strncmp(dir_entry[i].de_fname, match_root[i], 3))\n\t\t\terror = 1;\n\t}\n\tqnx6_put_page(page);\n\tif (error)\n\t\treturn \"error reading root directory.\";\n\treturn NULL;\n}\n\n#ifdef CONFIG_QNX6FS_DEBUG\nvoid qnx6_superblock_debug(struct qnx6_super_block *sb, struct super_block *s)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\n\tpr_debug(\"magic: %08x\\n\", fs32_to_cpu(sbi, sb->sb_magic));\n\tpr_debug(\"checksum: %08x\\n\", fs32_to_cpu(sbi, sb->sb_checksum));\n\tpr_debug(\"serial: %llx\\n\", fs64_to_cpu(sbi, sb->sb_serial));\n\tpr_debug(\"flags: %08x\\n\", fs32_to_cpu(sbi, sb->sb_flags));\n\tpr_debug(\"blocksize: %08x\\n\", fs32_to_cpu(sbi, sb->sb_blocksize));\n\tpr_debug(\"num_inodes: %08x\\n\", fs32_to_cpu(sbi, sb->sb_num_inodes));\n\tpr_debug(\"free_inodes: %08x\\n\", fs32_to_cpu(sbi, sb->sb_free_inodes));\n\tpr_debug(\"num_blocks: %08x\\n\", fs32_to_cpu(sbi, sb->sb_num_blocks));\n\tpr_debug(\"free_blocks: %08x\\n\", fs32_to_cpu(sbi, sb->sb_free_blocks));\n\tpr_debug(\"inode_levels: %02x\\n\", sb->Inode.levels);\n}\n#endif\n\nenum {\n\tOpt_mmifs,\n\tOpt_err\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_mmifs, \"mmi_fs\"},\n\t{Opt_err, NULL}\n};\n\nstatic int qnx6_parse_options(char *options, struct super_block *sb)\n{\n\tchar *p;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_mmifs:\n\t\t\tset_opt(sbi->s_mount_opt, MMI_FS);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic struct buffer_head *qnx6_check_first_superblock(struct super_block *s,\n\t\t\t\tint offset, int silent)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\tstruct buffer_head *bh;\n\tstruct qnx6_super_block *sb;\n\n\t \n\tbh = sb_bread(s, offset);\n\tif (!bh) {\n\t\tpr_err(\"unable to read the first superblock\\n\");\n\t\treturn NULL;\n\t}\n\tsb = (struct qnx6_super_block *)bh->b_data;\n\tif (fs32_to_cpu(sbi, sb->sb_magic) != QNX6_SUPER_MAGIC) {\n\t\tsbi->s_bytesex = BYTESEX_BE;\n\t\tif (fs32_to_cpu(sbi, sb->sb_magic) == QNX6_SUPER_MAGIC) {\n\t\t\t \n\t\t\tpr_debug(\"fs got different endianness.\\n\");\n\t\t\treturn bh;\n\t\t} else\n\t\t\tsbi->s_bytesex = BYTESEX_LE;\n\t\tif (!silent) {\n\t\t\tif (offset == 0) {\n\t\t\t\tpr_err(\"wrong signature (magic) in superblock #1.\\n\");\n\t\t\t} else {\n\t\t\t\tpr_info(\"wrong signature (magic) at position (0x%lx) - will try alternative position (0x0000).\\n\",\n\t\t\t\t\toffset * s->s_blocksize);\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}\n\nstatic struct inode *qnx6_private_inode(struct super_block *s,\n\t\t\t\t\tstruct qnx6_root_node *p);\n\nstatic int qnx6_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct buffer_head *bh1 = NULL, *bh2 = NULL;\n\tstruct qnx6_super_block *sb1 = NULL, *sb2 = NULL;\n\tstruct qnx6_sb_info *sbi;\n\tstruct inode *root;\n\tconst char *errmsg;\n\tstruct qnx6_sb_info *qs;\n\tint ret = -EINVAL;\n\tu64 offset;\n\tint bootblock_offset = QNX6_BOOTBLOCK_SIZE;\n\n\tqs = kzalloc(sizeof(struct qnx6_sb_info), GFP_KERNEL);\n\tif (!qs)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = qs;\n\n\t \n\tif (!sb_set_blocksize(s, QNX6_SUPERBLOCK_SIZE)) {\n\t\tpr_err(\"unable to set blocksize\\n\");\n\t\tgoto outnobh;\n\t}\n\n\t \n\tif (!qnx6_parse_options((char *) data, s)) {\n\t\tpr_err(\"invalid mount options.\\n\");\n\t\tgoto outnobh;\n\t}\n\tif (test_opt(s, MMI_FS)) {\n\t\tsb1 = qnx6_mmi_fill_super(s, silent);\n\t\tif (sb1)\n\t\t\tgoto mmi_success;\n\t\telse\n\t\t\tgoto outnobh;\n\t}\n\tsbi = QNX6_SB(s);\n\tsbi->s_bytesex = BYTESEX_LE;\n\t \n\tbh1 = qnx6_check_first_superblock(s,\n\t\tbootblock_offset / QNX6_SUPERBLOCK_SIZE, silent);\n\tif (!bh1) {\n\t\t \n\t\tbh1 = qnx6_check_first_superblock(s, 0, silent);\n\t\tif (!bh1) {\n\t\t\tpr_err(\"unable to read the first superblock\\n\");\n\t\t\tgoto outnobh;\n\t\t}\n\t\t \n\t\tbootblock_offset = 0;\n\t}\n\tsb1 = (struct qnx6_super_block *)bh1->b_data;\n\n#ifdef CONFIG_QNX6FS_DEBUG\n\tqnx6_superblock_debug(sb1, s);\n#endif\n\n\t \n\tif (fs32_to_cpu(sbi, sb1->sb_checksum) !=\n\t\t\tcrc32_be(0, (char *)(bh1->b_data + 8), 504)) {\n\t\tpr_err(\"superblock #1 checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (!sb_set_blocksize(s, fs32_to_cpu(sbi, sb1->sb_blocksize))) {\n\t\tpr_err(\"unable to set blocksize\\n\");\n\t\tgoto out;\n\t}\n\t \n\tbrelse(bh1);\n\tbh1 = sb_bread(s, bootblock_offset >> s->s_blocksize_bits);\n\tif (!bh1)\n\t\tgoto outnobh;\n\tsb1 = (struct qnx6_super_block *)bh1->b_data;\n\n\t \n\toffset = fs32_to_cpu(sbi, sb1->sb_num_blocks) +\n\t\t(bootblock_offset >> s->s_blocksize_bits) +\n\t\t(QNX6_SUPERBLOCK_AREA >> s->s_blocksize_bits);\n\n\t \n\tsbi->s_blks_off = (bootblock_offset >> s->s_blocksize_bits) +\n\t\t\t  (QNX6_SUPERBLOCK_AREA >> s->s_blocksize_bits);\n\n\t \n\tbh2 = sb_bread(s, offset);\n\tif (!bh2) {\n\t\tpr_err(\"unable to read the second superblock\\n\");\n\t\tgoto out;\n\t}\n\tsb2 = (struct qnx6_super_block *)bh2->b_data;\n\tif (fs32_to_cpu(sbi, sb2->sb_magic) != QNX6_SUPER_MAGIC) {\n\t\tif (!silent)\n\t\t\tpr_err(\"wrong signature (magic) in superblock #2.\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (fs32_to_cpu(sbi, sb2->sb_checksum) !=\n\t\t\t\tcrc32_be(0, (char *)(bh2->b_data + 8), 504)) {\n\t\tpr_err(\"superblock #2 checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\tif (fs64_to_cpu(sbi, sb1->sb_serial) >=\n\t\t\t\t\tfs64_to_cpu(sbi, sb2->sb_serial)) {\n\t\t \n\t\tsbi->sb_buf = bh1;\n\t\tsbi->sb = (struct qnx6_super_block *)bh1->b_data;\n\t\tbrelse(bh2);\n\t\tpr_info(\"superblock #1 active\\n\");\n\t} else {\n\t\t \n\t\tsbi->sb_buf = bh2;\n\t\tsbi->sb = (struct qnx6_super_block *)bh2->b_data;\n\t\tbrelse(bh1);\n\t\tpr_info(\"superblock #2 active\\n\");\n\t}\nmmi_success:\n\t \n\tif (sb1->Inode.levels > QNX6_PTR_MAX_LEVELS) {\n\t\tpr_err(\"too many inode levels (max %i, sb %i)\\n\",\n\t\t       QNX6_PTR_MAX_LEVELS, sb1->Inode.levels);\n\t\tgoto out;\n\t}\n\tif (sb1->Longfile.levels > QNX6_PTR_MAX_LEVELS) {\n\t\tpr_err(\"too many longfilename levels (max %i, sb %i)\\n\",\n\t\t       QNX6_PTR_MAX_LEVELS, sb1->Longfile.levels);\n\t\tgoto out;\n\t}\n\ts->s_op = &qnx6_sops;\n\ts->s_magic = QNX6_SUPER_MAGIC;\n\ts->s_flags |= SB_RDONLY;         \n\ts->s_time_min = 0;\n\ts->s_time_max = U32_MAX;\n\n\t \n\tsbi = QNX6_SB(s);\n\tsbi->s_ptrbits = ilog2(s->s_blocksize / 4);\n\tsbi->inodes = qnx6_private_inode(s, &sb1->Inode);\n\tif (!sbi->inodes)\n\t\tgoto out;\n\tsbi->longfile = qnx6_private_inode(s, &sb1->Longfile);\n\tif (!sbi->longfile)\n\t\tgoto out1;\n\n\t \n\troot = qnx6_iget(s, QNX6_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\tpr_err(\"get inode failed\\n\");\n\t\tret = PTR_ERR(root);\n\t\tgoto out2;\n\t}\n\n\tret = -ENOMEM;\n\ts->s_root = d_make_root(root);\n\tif (!s->s_root)\n\t\tgoto out2;\n\n\tret = -EINVAL;\n\terrmsg = qnx6_checkroot(s);\n\tif (errmsg != NULL) {\n\t\tif (!silent)\n\t\t\tpr_err(\"%s\\n\", errmsg);\n\t\tgoto out3;\n\t}\n\treturn 0;\n\nout3:\n\tdput(s->s_root);\n\ts->s_root = NULL;\nout2:\n\tiput(sbi->longfile);\nout1:\n\tiput(sbi->inodes);\nout:\n\tbrelse(bh1);\n\tbrelse(bh2);\noutnobh:\n\tkfree(qs);\n\ts->s_fs_info = NULL;\n\treturn ret;\n}\n\nstatic void qnx6_put_super(struct super_block *sb)\n{\n\tstruct qnx6_sb_info *qs = QNX6_SB(sb);\n\tbrelse(qs->sb_buf);\n\tiput(qs->longfile);\n\tiput(qs->inodes);\n\tkfree(qs);\n\tsb->s_fs_info = NULL;\n\treturn;\n}\n\nstatic sector_t qnx6_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, qnx6_get_block);\n}\nstatic const struct address_space_operations qnx6_aops = {\n\t.read_folio\t= qnx6_read_folio,\n\t.readahead\t= qnx6_readahead,\n\t.bmap\t\t= qnx6_bmap\n};\n\nstatic struct inode *qnx6_private_inode(struct super_block *s,\n\t\t\t\t\tstruct qnx6_root_node *p)\n{\n\tstruct inode *inode = new_inode(s);\n\tif (inode) {\n\t\tstruct qnx6_inode_info *ei = QNX6_I(inode);\n\t\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\t\tinode->i_size = fs64_to_cpu(sbi, p->size);\n\t\tmemcpy(ei->di_block_ptr, p->ptr, sizeof(p->ptr));\n\t\tei->di_filelevels = p->levels;\n\t\tinode->i_mode = S_IFREG | S_IRUSR;  \n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t}\n\treturn inode;\n}\n\nstruct inode *qnx6_iget(struct super_block *sb, unsigned ino)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\tstruct qnx6_inode_entry *raw_inode;\n\tstruct inode *inode;\n\tstruct qnx6_inode_info\t*ei;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tu32 n, offs;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = QNX6_I(inode);\n\n\tinode->i_mode = 0;\n\n\tif (ino == 0) {\n\t\tpr_err(\"bad inode number on dev %s: %u is out of range\\n\",\n\t\t       sb->s_id, ino);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tn = (ino - 1) >> (PAGE_SHIFT - QNX6_INODE_SIZE_BITS);\n\toffs = (ino - 1) & (~PAGE_MASK >> QNX6_INODE_SIZE_BITS);\n\tmapping = sbi->inodes->i_mapping;\n\tpage = read_mapping_page(mapping, n, NULL);\n\tif (IS_ERR(page)) {\n\t\tpr_err(\"major problem: unable to read inode from dev %s\\n\",\n\t\t       sb->s_id);\n\t\tiget_failed(inode);\n\t\treturn ERR_CAST(page);\n\t}\n\tkmap(page);\n\traw_inode = ((struct qnx6_inode_entry *)page_address(page)) + offs;\n\n\tinode->i_mode    = fs16_to_cpu(sbi, raw_inode->di_mode);\n\ti_uid_write(inode, (uid_t)fs32_to_cpu(sbi, raw_inode->di_uid));\n\ti_gid_write(inode, (gid_t)fs32_to_cpu(sbi, raw_inode->di_gid));\n\tinode->i_size    = fs64_to_cpu(sbi, raw_inode->di_size);\n\tinode->i_mtime.tv_sec   = fs32_to_cpu(sbi, raw_inode->di_mtime);\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_sec   = fs32_to_cpu(sbi, raw_inode->di_atime);\n\tinode->i_atime.tv_nsec = 0;\n\tinode_set_ctime(inode, fs32_to_cpu(sbi, raw_inode->di_ctime), 0);\n\n\t \n\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\n\tmemcpy(&ei->di_block_ptr, &raw_inode->di_block_ptr,\n\t\t\t\tsizeof(raw_inode->di_block_ptr));\n\tei->di_filelevels = raw_inode->di_filelevels;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &qnx6_dir_inode_operations;\n\t\tinode->i_fop = &qnx6_dir_operations;\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &qnx6_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\tqnx6_put_page(page);\n\tunlock_new_inode(inode);\n\treturn inode;\n}\n\nstatic struct kmem_cache *qnx6_inode_cachep;\n\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb)\n{\n\tstruct qnx6_inode_info *ei;\n\tei = alloc_inode_sb(sb, qnx6_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}\n\nstatic void qnx6_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(qnx6_inode_cachep, QNX6_I(inode));\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct qnx6_inode_info *ei = (struct qnx6_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int init_inodecache(void)\n{\n\tqnx6_inode_cachep = kmem_cache_create(\"qnx6_inode_cache\",\n\t\t\t\t\t     sizeof(struct qnx6_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t     init_once);\n\tif (!qnx6_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(qnx6_inode_cachep);\n}\n\nstatic struct dentry *qnx6_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, qnx6_fill_super);\n}\n\nstatic struct file_system_type qnx6_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"qnx6\",\n\t.mount\t\t= qnx6_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"qnx6\");\n\nstatic int __init init_qnx6_fs(void)\n{\n\tint err;\n\n\terr = init_inodecache();\n\tif (err)\n\t\treturn err;\n\n\terr = register_filesystem(&qnx6_fs_type);\n\tif (err) {\n\t\tdestroy_inodecache();\n\t\treturn err;\n\t}\n\n\tpr_info(\"QNX6 filesystem 1.0.0 registered.\\n\");\n\treturn 0;\n}\n\nstatic void __exit exit_qnx6_fs(void)\n{\n\tunregister_filesystem(&qnx6_fs_type);\n\tdestroy_inodecache();\n}\n\nmodule_init(init_qnx6_fs)\nmodule_exit(exit_qnx6_fs)\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}