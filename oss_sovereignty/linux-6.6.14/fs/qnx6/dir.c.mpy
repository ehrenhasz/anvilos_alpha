{
  "module_name": "dir.c",
  "hash_id": "b711f37ba3e245f94d0653a6b79269d2184d5b4b6d19cae8c6f148608f5eb8d5",
  "original_prompt": "Ingested from linux-6.6.14/fs/qnx6/dir.c",
  "human_readable_source": "\n \n\n#include \"qnx6.h\"\n\nstatic unsigned qnx6_lfile_checksum(char *name, unsigned size)\n{\n\tunsigned crc = 0;\n\tchar *end = name + size;\n\twhile (name < end) {\n\t\tcrc = ((crc >> 1) + *(name++)) ^\n\t\t\t((crc & 0x00000001) ? 0x80000000 : 0);\n\t}\n\treturn crc;\n}\n\nstatic struct page *qnx6_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page))\n\t\tkmap(page);\n\treturn page;\n}\n\nstatic unsigned last_entry(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned long last_byte = inode->i_size;\n\tlast_byte -= page_nr << PAGE_SHIFT;\n\tif (last_byte > PAGE_SIZE)\n\t\tlast_byte = PAGE_SIZE;\n\treturn last_byte / QNX6_DIR_ENTRY_SIZE;\n}\n\nstatic struct qnx6_long_filename *qnx6_longname(struct super_block *sb,\n\t\t\t\t\t struct qnx6_long_dir_entry *de,\n\t\t\t\t\t struct page **p)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(sb);\n\tu32 s = fs32_to_cpu(sbi, de->de_long_inode);  \n\tu32 n = s >> (PAGE_SHIFT - sb->s_blocksize_bits);  \n\t \n\tu32 offs = (s << sb->s_blocksize_bits) & ~PAGE_MASK;\n\tstruct address_space *mapping = sbi->longfile->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (IS_ERR(page))\n\t\treturn ERR_CAST(page);\n\tkmap(*p = page);\n\treturn (struct qnx6_long_filename *)(page_address(page) + offs);\n}\n\nstatic int qnx6_dir_longfilename(struct inode *inode,\n\t\t\tstruct qnx6_long_dir_entry *de,\n\t\t\tstruct dir_context *ctx,\n\t\t\tunsigned de_inode)\n{\n\tstruct qnx6_long_filename *lf;\n\tstruct super_block *s = inode->i_sb;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\tstruct page *page;\n\tint lf_size;\n\n\tif (de->de_size != 0xff) {\n\t\t \n\t\tpr_err(\"invalid direntry size (%i).\\n\", de->de_size);\n\t\treturn 0;\n\t}\n\tlf = qnx6_longname(s, de, &page);\n\tif (IS_ERR(lf)) {\n\t\tpr_err(\"Error reading longname\\n\");\n\t\treturn 0;\n\t}\n\n\tlf_size = fs16_to_cpu(sbi, lf->lf_size);\n\n\tif (lf_size > QNX6_LONG_NAME_MAX) {\n\t\tpr_debug(\"file %s\\n\", lf->lf_fname);\n\t\tpr_err(\"Filename too long (%i)\\n\", lf_size);\n\t\tqnx6_put_page(page);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!test_opt(s, MMI_FS) && fs32_to_cpu(sbi, de->de_checksum) !=\n\t\t\tqnx6_lfile_checksum(lf->lf_fname, lf_size))\n\t\tpr_info(\"long filename checksum error.\\n\");\n\n\tpr_debug(\"qnx6_readdir:%.*s inode:%u\\n\",\n\t\t lf_size, lf->lf_fname, de_inode);\n\tif (!dir_emit(ctx, lf->lf_fname, lf_size, de_inode, DT_UNKNOWN)) {\n\t\tqnx6_put_page(page);\n\t\treturn 0;\n\t}\n\n\tqnx6_put_page(page);\n\t \n\treturn 1;\n}\n\nstatic int qnx6_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *s = inode->i_sb;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\tloff_t pos = ctx->pos & ~(QNX6_DIR_ENTRY_SIZE - 1);\n\tunsigned long npages = dir_pages(inode);\n\tunsigned long n = pos >> PAGE_SHIFT;\n\tunsigned start = (pos & ~PAGE_MASK) / QNX6_DIR_ENTRY_SIZE;\n\tbool done = false;\n\n\tctx->pos = pos;\n\tif (ctx->pos >= inode->i_size)\n\t\treturn 0;\n\n\tfor ( ; !done && n < npages; n++, start = 0) {\n\t\tstruct page *page = qnx6_get_page(inode, n);\n\t\tint limit = last_entry(inode, n);\n\t\tstruct qnx6_dir_entry *de;\n\t\tint i = start;\n\n\t\tif (IS_ERR(page)) {\n\t\t\tpr_err(\"%s(): read failed\\n\", __func__);\n\t\t\tctx->pos = (n + 1) << PAGE_SHIFT;\n\t\t\treturn PTR_ERR(page);\n\t\t}\n\t\tde = ((struct qnx6_dir_entry *)page_address(page)) + start;\n\t\tfor (; i < limit; i++, de++, ctx->pos += QNX6_DIR_ENTRY_SIZE) {\n\t\t\tint size = de->de_size;\n\t\t\tu32 no_inode = fs32_to_cpu(sbi, de->de_inode);\n\n\t\t\tif (!no_inode || !size)\n\t\t\t\tcontinue;\n\n\t\t\tif (size > QNX6_SHORT_NAME_MAX) {\n\t\t\t\t \n\t\t\t\tif (!qnx6_dir_longfilename(inode,\n\t\t\t\t\t(struct qnx6_long_dir_entry *)de,\n\t\t\t\t\tctx, no_inode)) {\n\t\t\t\t\tdone = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpr_debug(\"%s():%.*s inode:%u\\n\",\n\t\t\t\t\t __func__, size, de->de_fname,\n\t\t\t\t\t no_inode);\n\t\t\t\tif (!dir_emit(ctx, de->de_fname, size,\n\t\t\t\t      no_inode, DT_UNKNOWN)) {\n\t\t\t\t\tdone = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqnx6_put_page(page);\n\t}\n\treturn 0;\n}\n\n \nstatic unsigned qnx6_long_match(int len, const char *name,\n\t\t\tstruct qnx6_long_dir_entry *de, struct inode *dir)\n{\n\tstruct super_block *s = dir->i_sb;\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\tstruct page *page;\n\tint thislen;\n\tstruct qnx6_long_filename *lf = qnx6_longname(s, de, &page);\n\n\tif (IS_ERR(lf))\n\t\treturn 0;\n\n\tthislen = fs16_to_cpu(sbi, lf->lf_size);\n\tif (len != thislen) {\n\t\tqnx6_put_page(page);\n\t\treturn 0;\n\t}\n\tif (memcmp(name, lf->lf_fname, len) == 0) {\n\t\tqnx6_put_page(page);\n\t\treturn fs32_to_cpu(sbi, de->de_inode);\n\t}\n\tqnx6_put_page(page);\n\treturn 0;\n}\n\n \nstatic unsigned qnx6_match(struct super_block *s, int len, const char *name,\n\t\t\tstruct qnx6_dir_entry *de)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\tif (memcmp(name, de->de_fname, len) == 0)\n\t\treturn fs32_to_cpu(sbi, de->de_inode);\n\treturn 0;\n}\n\n\nunsigned qnx6_find_entry(int len, struct inode *dir, const char *name,\n\t\t\t struct page **res_page)\n{\n\tstruct super_block *s = dir->i_sb;\n\tstruct qnx6_inode_info *ei = QNX6_I(dir);\n\tstruct page *page = NULL;\n\tunsigned long start, n;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned ino;\n\tstruct qnx6_dir_entry *de;\n\tstruct qnx6_long_dir_entry *lde;\n\n\t*res_page = NULL;\n\n\tif (npages == 0)\n\t\treturn 0;\n\tstart = ei->i_dir_start_lookup;\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\n\tdo {\n\t\tpage = qnx6_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tint limit = last_entry(dir, n);\n\t\t\tint i;\n\n\t\t\tde = (struct qnx6_dir_entry *)page_address(page);\n\t\t\tfor (i = 0; i < limit; i++, de++) {\n\t\t\t\tif (len <= QNX6_SHORT_NAME_MAX) {\n\t\t\t\t\t \n\t\t\t\t\tif (len != de->de_size)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tino = qnx6_match(s, len, name, de);\n\t\t\t\t\tif (ino)\n\t\t\t\t\t\tgoto found;\n\t\t\t\t} else if (de->de_size == 0xff) {\n\t\t\t\t\t \n\t\t\t\t\tlde = (struct qnx6_long_dir_entry *)de;\n\t\t\t\t\tino = qnx6_long_match(len,\n\t\t\t\t\t\t\t\tname, lde, dir);\n\t\t\t\t\tif (ino)\n\t\t\t\t\t\tgoto found;\n\t\t\t\t} else\n\t\t\t\t\tpr_err(\"undefined filename size in inode.\\n\");\n\t\t\t}\n\t\t\tqnx6_put_page(page);\n\t\t}\n\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\n\treturn 0;\n\nfound:\n\t*res_page = page;\n\tei->i_dir_start_lookup = n;\n\treturn ino;\n}\n\nconst struct file_operations qnx6_dir_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= qnx6_readdir,\n\t.fsync\t\t= generic_file_fsync,\n};\n\nconst struct inode_operations qnx6_dir_inode_operations = {\n\t.lookup\t\t= qnx6_lookup,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}