{
  "module_name": "super_mmi.c",
  "hash_id": "278a412b122824ea9177c5b18b8257b737bf482dbd87fc6843bf443e247eaaf3",
  "original_prompt": "Ingested from linux-6.6.14/fs/qnx6/super_mmi.c",
  "human_readable_source": "\n \n\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include \"qnx6.h\"\n\nstatic void qnx6_mmi_copy_sb(struct qnx6_super_block *qsb,\n\t\tstruct qnx6_mmi_super_block *sb)\n{\n\tqsb->sb_magic = sb->sb_magic;\n\tqsb->sb_checksum = sb->sb_checksum;\n\tqsb->sb_serial = sb->sb_serial;\n\tqsb->sb_blocksize = sb->sb_blocksize;\n\tqsb->sb_num_inodes = sb->sb_num_inodes;\n\tqsb->sb_free_inodes = sb->sb_free_inodes;\n\tqsb->sb_num_blocks = sb->sb_num_blocks;\n\tqsb->sb_free_blocks = sb->sb_free_blocks;\n\n\t \n\tmemcpy(&qsb->Inode, &sb->Inode, sizeof(sb->Inode));\n\tmemcpy(&qsb->Bitmap, &sb->Bitmap, sizeof(sb->Bitmap));\n\tmemcpy(&qsb->Longfile, &sb->Longfile, sizeof(sb->Longfile));\n}\n\nstruct qnx6_super_block *qnx6_mmi_fill_super(struct super_block *s, int silent)\n{\n\tstruct buffer_head *bh1, *bh2 = NULL;\n\tstruct qnx6_mmi_super_block *sb1, *sb2;\n\tstruct qnx6_super_block *qsb = NULL;\n\tstruct qnx6_sb_info *sbi;\n\t__u64 offset;\n\n\t \n\tbh1 = sb_bread(s, 0);\n\tif (!bh1) {\n\t\tpr_err(\"Unable to read first mmi superblock\\n\");\n\t\treturn NULL;\n\t}\n\tsb1 = (struct qnx6_mmi_super_block *)bh1->b_data;\n\tsbi = QNX6_SB(s);\n\tif (fs32_to_cpu(sbi, sb1->sb_magic) != QNX6_SUPER_MAGIC) {\n\t\tif (!silent) {\n\t\t\tpr_err(\"wrong signature (magic) in superblock #1.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (fs32_to_cpu(sbi, sb1->sb_checksum) !=\n\t\t\t\tcrc32_be(0, (char *)(bh1->b_data + 8), 504)) {\n\t\tpr_err(\"superblock #1 checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\toffset = fs32_to_cpu(sbi, sb1->sb_num_blocks) + QNX6_SUPERBLOCK_AREA /\n\t\t\t\t\tfs32_to_cpu(sbi, sb1->sb_blocksize);\n\n\t \n\tif (!sb_set_blocksize(s, fs32_to_cpu(sbi, sb1->sb_blocksize))) {\n\t\tpr_err(\"unable to set blocksize\\n\");\n\t\tgoto out;\n\t}\n\t \n\tbrelse(bh1);\n\tbh1 = sb_bread(s, 0);\n\tif (!bh1)\n\t\tgoto out;\n\tsb1 = (struct qnx6_mmi_super_block *)bh1->b_data;\n\n\t \n\tbh2 = sb_bread(s, offset);\n\tif (!bh2) {\n\t\tpr_err(\"unable to read the second superblock\\n\");\n\t\tgoto out;\n\t}\n\tsb2 = (struct qnx6_mmi_super_block *)bh2->b_data;\n\tif (fs32_to_cpu(sbi, sb2->sb_magic) != QNX6_SUPER_MAGIC) {\n\t\tif (!silent)\n\t\t\tpr_err(\"wrong signature (magic) in superblock #2.\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (fs32_to_cpu(sbi, sb2->sb_checksum)\n\t\t\t!= crc32_be(0, (char *)(bh2->b_data + 8), 504)) {\n\t\tpr_err(\"superblock #1 checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\tqsb = kmalloc(sizeof(*qsb), GFP_KERNEL);\n\tif (!qsb) {\n\t\tpr_err(\"unable to allocate memory.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (fs64_to_cpu(sbi, sb1->sb_serial) >\n\t\t\t\t\tfs64_to_cpu(sbi, sb2->sb_serial)) {\n\t\t \n\t\tqnx6_mmi_copy_sb(qsb, sb1);\n#ifdef CONFIG_QNX6FS_DEBUG\n\t\tqnx6_superblock_debug(qsb, s);\n#endif\n\t\tmemcpy(bh1->b_data, qsb, sizeof(struct qnx6_super_block));\n\n\t\tsbi->sb_buf = bh1;\n\t\tsbi->sb = (struct qnx6_super_block *)bh1->b_data;\n\t\tbrelse(bh2);\n\t\tpr_info(\"superblock #1 active\\n\");\n\t} else {\n\t\t \n\t\tqnx6_mmi_copy_sb(qsb, sb2);\n#ifdef CONFIG_QNX6FS_DEBUG\n\t\tqnx6_superblock_debug(qsb, s);\n#endif\n\t\tmemcpy(bh2->b_data, qsb, sizeof(struct qnx6_super_block));\n\n\t\tsbi->sb_buf = bh2;\n\t\tsbi->sb = (struct qnx6_super_block *)bh2->b_data;\n\t\tbrelse(bh1);\n\t\tpr_info(\"superblock #2 active\\n\");\n\t}\n\tkfree(qsb);\n\n\t \n\tsbi->s_blks_off = QNX6_SUPERBLOCK_AREA / s->s_blocksize;\n\n\t \n\treturn sbi->sb;\n\nout:\n\tif (bh1 != NULL)\n\t\tbrelse(bh1);\n\tif (bh2 != NULL)\n\t\tbrelse(bh2);\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}