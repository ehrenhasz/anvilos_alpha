{
  "module_name": "ialloc.c",
  "hash_id": "db22ea465ab05f13459ec58be776075cd79783b30406b5851acd10567af309c1",
  "original_prompt": "Ingested from linux-6.6.14/fs/ufs/ialloc.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/bitops.h>\n#include <asm/byteorder.h>\n\n#include \"ufs_fs.h\"\n#include \"ufs.h\"\n#include \"swab.h\"\n#include \"util.h\"\n\n \nvoid ufs_free_inode (struct inode * inode)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tint is_directory;\n\tunsigned ino, cg, bit;\n\t\n\tUFSD(\"ENTER, ino %lu\\n\", inode->i_ino);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tino = inode->i_ino;\n\n\tmutex_lock(&UFS_SB(sb)->s_lock);\n\n\tif (!((ino > 1) && (ino < (uspi->s_ncg * uspi->s_ipg )))) {\n\t\tufs_warning(sb, \"ufs_free_inode\", \"reserved inode or nonexistent inode %u\\n\", ino);\n\t\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\t\treturn;\n\t}\n\t\n\tcg = ufs_inotocg (ino);\n\tbit = ufs_inotocgoff (ino);\n\tucpi = ufs_load_cylinder (sb, cg);\n\tif (!ucpi) {\n\t\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\t\treturn;\n\t}\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg))\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"internal error, bad cg magic number\");\n\n\tucg->cg_time = ufs_get_seconds(sb);\n\n\tis_directory = S_ISDIR(inode->i_mode);\n\n\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit))\n\t\tufs_error(sb, \"ufs_free_inode\", \"bit already cleared for inode %u\", ino);\n\telse {\n\t\tubh_clrbit (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit);\n\t\tif (ino < ucpi->c_irotor)\n\t\t\tucpi->c_irotor = ino;\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nifree, 1);\n\t\tuspi->cs_total.cs_nifree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cg).cs_nifree, 1);\n\n\t\tif (is_directory) {\n\t\t\tfs32_sub(sb, &ucg->cg_cs.cs_ndir, 1);\n\t\t\tuspi->cs_total.cs_ndir--;\n\t\t\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cg).cs_ndir, 1);\n\t\t}\n\t}\n\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & SB_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\t\n\tufs_mark_sb_dirty(sb);\n\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\tUFSD(\"EXIT\\n\");\n}\n\n \nstatic void ufs2_init_inodes_chunk(struct super_block *sb,\n\t\t\t\t   struct ufs_cg_private_info *ucpi,\n\t\t\t\t   struct ufs_cylinder_group *ucg)\n{\n\tstruct buffer_head *bh;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tsector_t beg = uspi->s_sbbase +\n\t\tufs_inotofsba(ucpi->c_cgx * uspi->s_ipg +\n\t\t\t      fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_initediblk));\n\tsector_t end = beg + uspi->s_fpb;\n\n\tUFSD(\"ENTER cgno %d\\n\", ucpi->c_cgx);\n\n\tfor (; beg < end; ++beg) {\n\t\tbh = sb_getblk(sb, beg);\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (sb->s_flags & SB_SYNCHRONOUS)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\n\tfs32_add(sb, &ucg->cg_u.cg_u2.cg_initediblk, uspi->s_inopb);\n\tubh_mark_buffer_dirty(UCPI_UBH(ucpi));\n\tif (sb->s_flags & SB_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\n\tUFSD(\"EXIT\\n\");\n}\n\n \nstruct inode *ufs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_info * sbi;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tstruct inode * inode;\n\tstruct timespec64 ts;\n\tunsigned cg, bit, i, j, start;\n\tstruct ufs_inode_info *ufsi;\n\tint err = -ENOSPC;\n\n\tUFSD(\"ENTER\\n\");\n\t\n\t \n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tufsi = UFS_I(inode);\n\tsbi = UFS_SB(sb);\n\tuspi = sbi->s_uspi;\n\n\tmutex_lock(&sbi->s_lock);\n\n\t \n\ti = ufs_inotocg(dir->i_ino);\n\tif (sbi->fs_cs(i).cs_nifree) {\n\t\tcg = i;\n\t\tgoto cg_found;\n\t}\n\n\t \n\tfor ( j = 1; j < uspi->s_ncg; j <<= 1 ) {\n\t\ti += j;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti -= uspi->s_ncg;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\t \n\ti = ufs_inotocg(dir->i_ino) + 1;\n\tfor (j = 2; j < uspi->s_ncg; j++) {\n\t\ti++;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti = 0;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\tgoto failed;\n\ncg_found:\n\tucpi = ufs_load_cylinder (sb, cg);\n\tif (!ucpi) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) \n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error, bad cg magic number\");\n\n\tstart = ucpi->c_irotor;\n\tbit = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, uspi->s_ipg, start);\n\tif (!(bit < uspi->s_ipg)) {\n\t\tbit = ubh_find_first_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, start);\n\t\tif (!(bit < start)) {\n\t\t\tufs_error (sb, \"ufs_new_inode\",\n\t\t\t    \"cylinder group %u corrupted - error in inode bitmap\\n\", cg);\n\t\t\terr = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\t}\n\tUFSD(\"start = %u, bit = %u, ipg = %u\\n\", start, bit, uspi->s_ipg);\n\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit))\n\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit);\n\telse {\n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error\");\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tu32 initediblk = fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_initediblk);\n\n\t\tif (bit + uspi->s_inopb > initediblk &&\n\t\t    initediblk < fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_niblk))\n\t\t\tufs2_init_inodes_chunk(sb, ucpi, ucg);\n\t}\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nifree, 1);\n\tuspi->cs_total.cs_nifree--;\n\tfs32_sub(sb, &sbi->fs_cs(cg).cs_nifree, 1);\n\t\n\tif (S_ISDIR(mode)) {\n\t\tfs32_add(sb, &ucg->cg_cs.cs_ndir, 1);\n\t\tuspi->cs_total.cs_ndir++;\n\t\tfs32_add(sb, &sbi->fs_cs(cg).cs_ndir, 1);\n\t}\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & SB_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tinode->i_ino = cg * uspi->s_ipg + bit;\n\tinode_init_owner(&nop_mnt_idmap, inode, dir, mode);\n\tinode->i_blocks = 0;\n\tinode->i_generation = 0;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tufsi->i_flags = UFS_I(dir)->i_flags;\n\tufsi->i_lastfrag = 0;\n\tufsi->i_shadow = 0;\n\tufsi->i_osync = 0;\n\tufsi->i_oeftflag = 0;\n\tufsi->i_dir_start_lookup = 0;\n\tmemset(&ufsi->i_u1, 0, sizeof(ufsi->i_u1));\n\tif (insert_inode_locked(inode) < 0) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tmark_inode_dirty(inode);\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct buffer_head *bh;\n\t\tstruct ufs2_inode *ufs2_inode;\n\n\t\t \n\t\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\t\tif (!bh) {\n\t\t\tufs_warning(sb, \"ufs_read_inode\",\n\t\t\t\t    \"unable to read inode %lu\\n\",\n\t\t\t\t    inode->i_ino);\n\t\t\terr = -EIO;\n\t\t\tgoto fail_remove_inode;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tufs2_inode = (struct ufs2_inode *)bh->b_data;\n\t\tufs2_inode += ufs_inotofsbo(inode->i_ino);\n\t\tktime_get_real_ts64(&ts);\n\t\tufs2_inode->ui_birthtime = cpu_to_fs64(sb, ts.tv_sec);\n\t\tufs2_inode->ui_birthnsec = cpu_to_fs32(sb, ts.tv_nsec);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (sb->s_flags & SB_SYNCHRONOUS)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\tmutex_unlock(&sbi->s_lock);\n\n\tUFSD(\"allocating inode %lu\\n\", inode->i_ino);\n\tUFSD(\"EXIT\\n\");\n\treturn inode;\n\nfail_remove_inode:\n\tmutex_unlock(&sbi->s_lock);\n\tclear_nlink(inode);\n\tdiscard_new_inode(inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\nfailed:\n\tmutex_unlock(&sbi->s_lock);\n\tmake_bad_inode(inode);\n\tiput (inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}