{
  "module_name": "inode.c",
  "hash_id": "10040e98c3b2d3a658a3da9016a0abbd9fd5bcdc82a656a3a5825cc1d9968db9",
  "original_prompt": "Ingested from linux-6.6.14/fs/ufs/inode.c",
  "human_readable_source": "\n \n\n#include <linux/uaccess.h>\n\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/iversion.h>\n\n#include \"ufs_fs.h\"\n#include \"ufs.h\"\n#include \"swab.h\"\n#include \"util.h\"\n\nstatic int ufs_block_to_path(struct inode *inode, sector_t i_block, unsigned offsets[4])\n{\n\tstruct ufs_sb_private_info *uspi = UFS_SB(inode->i_sb)->s_uspi;\n\tint ptrs = uspi->s_apb;\n\tint ptrs_bits = uspi->s_apbshift;\n\tconst long direct_blocks = UFS_NDADDR,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\n\n\tUFSD(\"ptrs=uspi->s_apb = %d,double_blocks=%ld \\n\",ptrs,double_blocks);\n\tif (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t} else if ((i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = UFS_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = UFS_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = UFS_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t} else {\n\t\tufs_warning(inode->i_sb, \"ufs_block_to_path\", \"block > big\");\n\t}\n\treturn n;\n}\n\ntypedef struct {\n\tvoid\t*p;\n\tunion {\n\t\t__fs32\tkey32;\n\t\t__fs64\tkey64;\n\t};\n\tstruct buffer_head *bh;\n} Indirect;\n\nstatic inline int grow_chain32(struct ufs_inode_info *ufsi,\n\t\t\t       struct buffer_head *bh, __fs32 *v,\n\t\t\t       Indirect *from, Indirect *to)\n{\n\tIndirect *p;\n\tunsigned seq;\n\tto->bh = bh;\n\tdo {\n\t\tseq = read_seqbegin(&ufsi->meta_lock);\n\t\tto->key32 = *(__fs32 *)(to->p = v);\n\t\tfor (p = from; p <= to && p->key32 == *(__fs32 *)p->p; p++)\n\t\t\t;\n\t} while (read_seqretry(&ufsi->meta_lock, seq));\n\treturn (p > to);\n}\n\nstatic inline int grow_chain64(struct ufs_inode_info *ufsi,\n\t\t\t       struct buffer_head *bh, __fs64 *v,\n\t\t\t       Indirect *from, Indirect *to)\n{\n\tIndirect *p;\n\tunsigned seq;\n\tto->bh = bh;\n\tdo {\n\t\tseq = read_seqbegin(&ufsi->meta_lock);\n\t\tto->key64 = *(__fs64 *)(to->p = v);\n\t\tfor (p = from; p <= to && p->key64 == *(__fs64 *)p->p; p++)\n\t\t\t;\n\t} while (read_seqretry(&ufsi->meta_lock, seq));\n\treturn (p > to);\n}\n\n \n\nstatic u64 ufs_frag_map(struct inode *inode, unsigned offsets[4], int depth)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tu64 mask = (u64) uspi->s_apbmask>>uspi->s_fpbshift;\n\tint shift = uspi->s_apbshift-uspi->s_fpbshift;\n\tIndirect chain[4], *q = chain;\n\tunsigned *p;\n\tunsigned flags = UFS_SB(sb)->s_flags;\n\tu64 res = 0;\n\n\tUFSD(\": uspi->s_fpbshift = %d ,uspi->s_apbmask = %x, mask=%llx\\n\",\n\t\tuspi->s_fpbshift, uspi->s_apbmask,\n\t\t(unsigned long long)mask);\n\n\tif (depth == 0)\n\t\tgoto no_block;\n\nagain:\n\tp = offsets;\n\n\tif ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)\n\t\tgoto ufs2;\n\n\tif (!grow_chain32(ufsi, NULL, &ufsi->i_u1.i_data[*p++], chain, q))\n\t\tgoto changed;\n\tif (!q->key32)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\t__fs32 *ptr;\n\t\tstruct buffer_head *bh;\n\t\tunsigned n = *p++;\n\n\t\tbh = sb_bread(sb, uspi->s_sbbase +\n\t\t\t\t  fs32_to_cpu(sb, q->key32) + (n>>shift));\n\t\tif (!bh)\n\t\t\tgoto no_block;\n\t\tptr = (__fs32 *)bh->b_data + (n & mask);\n\t\tif (!grow_chain32(ufsi, bh, ptr, chain, ++q))\n\t\t\tgoto changed;\n\t\tif (!q->key32)\n\t\t\tgoto no_block;\n\t}\n\tres = fs32_to_cpu(sb, q->key32);\n\tgoto found;\n\nufs2:\n\tif (!grow_chain64(ufsi, NULL, &ufsi->i_u1.u2_i_data[*p++], chain, q))\n\t\tgoto changed;\n\tif (!q->key64)\n\t\tgoto no_block;\n\n\twhile (--depth) {\n\t\t__fs64 *ptr;\n\t\tstruct buffer_head *bh;\n\t\tunsigned n = *p++;\n\n\t\tbh = sb_bread(sb, uspi->s_sbbase +\n\t\t\t\t  fs64_to_cpu(sb, q->key64) + (n>>shift));\n\t\tif (!bh)\n\t\t\tgoto no_block;\n\t\tptr = (__fs64 *)bh->b_data + (n & mask);\n\t\tif (!grow_chain64(ufsi, bh, ptr, chain, ++q))\n\t\t\tgoto changed;\n\t\tif (!q->key64)\n\t\t\tgoto no_block;\n\t}\n\tres = fs64_to_cpu(sb, q->key64);\nfound:\n\tres += uspi->s_sbbase;\nno_block:\n\twhile (q > chain) {\n\t\tbrelse(q->bh);\n\t\tq--;\n\t}\n\treturn res;\n\nchanged:\n\twhile (q > chain) {\n\t\tbrelse(q->bh);\n\t\tq--;\n\t}\n\tgoto again;\n}\n\n \nstatic bool\nufs_extend_tail(struct inode *inode, u64 writes_to,\n\t\t  int *err, struct page *locked_page)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tunsigned lastfrag = ufsi->i_lastfrag;\t \n\tunsigned block = ufs_fragstoblks(lastfrag);\n\tunsigned new_size;\n\tvoid *p;\n\tu64 tmp;\n\n\tif (writes_to < (lastfrag | uspi->s_fpbmask))\n\t\tnew_size = (writes_to & uspi->s_fpbmask) + 1;\n\telse\n\t\tnew_size = uspi->s_fpb;\n\n\tp = ufs_get_direct_data_ptr(uspi, ufsi, block);\n\ttmp = ufs_new_fragments(inode, p, lastfrag, ufs_data_ptr_to_cpu(sb, p),\n\t\t\t\tnew_size - (lastfrag & uspi->s_fpbmask), err,\n\t\t\t\tlocked_page);\n\treturn tmp != 0;\n}\n\n \nstatic u64\nufs_inode_getfrag(struct inode *inode, unsigned index,\n\t\t  sector_t new_fragment, int *err,\n\t\t  int *new, struct page *locked_page)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tu64 tmp, goal, lastfrag;\n\tunsigned nfrags = uspi->s_fpb;\n\tvoid *p;\n\n         \n\n\tp = ufs_get_direct_data_ptr(uspi, ufsi, index);\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (tmp)\n\t\tgoto out;\n\n\tlastfrag = ufsi->i_lastfrag;\n\n\t \n\tif (new_fragment < UFS_NDIR_FRAGMENT && new_fragment >= lastfrag)\n\t\tnfrags = (new_fragment & uspi->s_fpbmask) + 1;\n\n\tgoal = 0;\n\tif (index) {\n\t\tgoal = ufs_data_ptr_to_cpu(sb,\n\t\t\t\t ufs_get_direct_data_ptr(uspi, ufsi, index - 1));\n\t\tif (goal)\n\t\t\tgoal += uspi->s_fpb;\n\t}\n\ttmp = ufs_new_fragments(inode, p, ufs_blknum(new_fragment),\n\t\t\t\tgoal, nfrags, err, locked_page);\n\n\tif (!tmp) {\n\t\t*err = -ENOSPC;\n\t\treturn 0;\n\t}\n\n\tif (new)\n\t\t*new = 1;\n\tinode_set_ctime_current(inode);\n\tif (IS_SYNC(inode))\n\t\tufs_sync_inode (inode);\n\tmark_inode_dirty(inode);\nout:\n\treturn tmp + uspi->s_sbbase;\n\n      \n}\n\n \nstatic u64\nufs_inode_getblock(struct inode *inode, u64 ind_block,\n\t\t  unsigned index, sector_t new_fragment, int *err,\n\t\t  int *new, struct page *locked_page)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tint shift = uspi->s_apbshift - uspi->s_fpbshift;\n\tu64 tmp = 0, goal;\n\tstruct buffer_head *bh;\n\tvoid *p;\n\n\tif (!ind_block)\n\t\treturn 0;\n\n\tbh = sb_bread(sb, ind_block + (index >> shift));\n\tif (unlikely(!bh)) {\n\t\t*err = -EIO;\n\t\treturn 0;\n\t}\n\n\tindex &= uspi->s_apbmask >> uspi->s_fpbshift;\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\tp = (__fs64 *)bh->b_data + index;\n\telse\n\t\tp = (__fs32 *)bh->b_data + index;\n\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (tmp)\n\t\tgoto out;\n\n\tif (index && (uspi->fs_magic == UFS2_MAGIC ?\n\t\t      (tmp = fs64_to_cpu(sb, ((__fs64 *)bh->b_data)[index-1])) :\n\t\t      (tmp = fs32_to_cpu(sb, ((__fs32 *)bh->b_data)[index-1]))))\n\t\tgoal = tmp + uspi->s_fpb;\n\telse\n\t\tgoal = bh->b_blocknr + uspi->s_fpb;\n\ttmp = ufs_new_fragments(inode, p, ufs_blknum(new_fragment), goal,\n\t\t\t\tuspi->s_fpb, err, locked_page);\n\tif (!tmp)\n\t\tgoto out;\n\n\tif (new)\n\t\t*new = 1;\n\n\tmark_buffer_dirty(bh);\n\tif (IS_SYNC(inode))\n\t\tsync_dirty_buffer(bh);\n\tinode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\nout:\n\tbrelse (bh);\n\tUFSD(\"EXIT\\n\");\n\tif (tmp)\n\t\ttmp += uspi->s_sbbase;\n\treturn tmp;\n}\n\n \n\nstatic int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head *bh_result, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tint err = 0, new = 0;\n\tunsigned offsets[4];\n\tint depth = ufs_block_to_path(inode, fragment >> uspi->s_fpbshift, offsets);\n\tu64 phys64 = 0;\n\tunsigned frag = fragment & uspi->s_fpbmask;\n\n\tphys64 = ufs_frag_map(inode, offsets, depth);\n\tif (!create)\n\t\tgoto done;\n\n\tif (phys64) {\n\t\tif (fragment >= UFS_NDIR_FRAGMENT)\n\t\t\tgoto done;\n\t\tread_seqlock_excl(&UFS_I(inode)->meta_lock);\n\t\tif (fragment < UFS_I(inode)->i_lastfrag) {\n\t\t\tread_sequnlock_excl(&UFS_I(inode)->meta_lock);\n\t\t\tgoto done;\n\t\t}\n\t\tread_sequnlock_excl(&UFS_I(inode)->meta_lock);\n\t}\n         \n\n\tmutex_lock(&UFS_I(inode)->truncate_mutex);\n\n\tUFSD(\"ENTER, ino %lu, fragment %llu\\n\", inode->i_ino, (unsigned long long)fragment);\n\tif (unlikely(!depth)) {\n\t\tufs_warning(sb, \"ufs_get_block\", \"block > big\");\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (UFS_I(inode)->i_lastfrag < UFS_NDIR_FRAGMENT) {\n\t\tunsigned lastfrag = UFS_I(inode)->i_lastfrag;\n\t\tunsigned tailfrags = lastfrag & uspi->s_fpbmask;\n\t\tif (tailfrags && fragment >= lastfrag) {\n\t\t\tif (!ufs_extend_tail(inode, fragment,\n\t\t\t\t\t     &err, bh_result->b_page))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (depth == 1) {\n\t\tphys64 = ufs_inode_getfrag(inode, offsets[0], fragment,\n\t\t\t\t\t   &err, &new, bh_result->b_page);\n\t} else {\n\t\tint i;\n\t\tphys64 = ufs_inode_getfrag(inode, offsets[0], fragment,\n\t\t\t\t\t   &err, NULL, NULL);\n\t\tfor (i = 1; i < depth - 1; i++)\n\t\t\tphys64 = ufs_inode_getblock(inode, phys64, offsets[i],\n\t\t\t\t\t\tfragment, &err, NULL, NULL);\n\t\tphys64 = ufs_inode_getblock(inode, phys64, offsets[depth - 1],\n\t\t\t\t\tfragment, &err, &new, bh_result->b_page);\n\t}\nout:\n\tif (phys64) {\n\t\tphys64 += frag;\n\t\tmap_bh(bh_result, sb, phys64);\n\t\tif (new)\n\t\t\tset_buffer_new(bh_result);\n\t}\n\tmutex_unlock(&UFS_I(inode)->truncate_mutex);\n\treturn err;\n\ndone:\n\tif (phys64)\n\t\tmap_bh(bh_result, sb, phys64 + frag);\n\treturn 0;\n}\n\nstatic int ufs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page,ufs_getfrag_block,wbc);\n}\n\nstatic int ufs_read_folio(struct file *file, struct folio *folio)\n{\n\treturn block_read_full_folio(folio, ufs_getfrag_block);\n}\n\nint ufs_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, ufs_getfrag_block);\n}\n\nstatic void ufs_truncate_blocks(struct inode *);\n\nstatic void ufs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tufs_truncate_blocks(inode);\n\t}\n}\n\nstatic int ufs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, pagep, ufs_getfrag_block);\n\tif (unlikely(ret))\n\t\tufs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}\n\nstatic int ufs_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tint ret;\n\n\tret = generic_write_end(file, mapping, pos, len, copied, page, fsdata);\n\tif (ret < len)\n\t\tufs_write_failed(mapping, pos + len);\n\treturn ret;\n}\n\nstatic sector_t ufs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,ufs_getfrag_block);\n}\n\nconst struct address_space_operations ufs_aops = {\n\t.dirty_folio = block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.read_folio = ufs_read_folio,\n\t.writepage = ufs_writepage,\n\t.write_begin = ufs_write_begin,\n\t.write_end = ufs_write_end,\n\t.bmap = ufs_bmap\n};\n\nstatic void ufs_set_inode_ops(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ufs_file_inode_operations;\n\t\tinode->i_fop = &ufs_file_operations;\n\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ufs_dir_inode_operations;\n\t\tinode->i_fop = &ufs_dir_operations;\n\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (!inode->i_blocks) {\n\t\t\tinode->i_link = (char *)UFS_I(inode)->i_u1.i_symlink;\n\t\t\tinode->i_op = &simple_symlink_inode_operations;\n\t\t} else {\n\t\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode_nohighmem(inode);\n\t\t}\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t   ufs_get_inode_dev(inode->i_sb, UFS_I(inode)));\n}\n\nstatic int ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tumode_t mode;\n\n\t \n\tinode->i_mode = mode = fs16_to_cpu(sb, ufs_inode->ui_mode);\n\tset_nlink(inode, fs16_to_cpu(sb, ufs_inode->ui_nlink));\n\tif (inode->i_nlink == 0)\n\t\treturn -ESTALE;\n\n\t \n\ti_uid_write(inode, ufs_get_inode_uid(sb, ufs_inode));\n\ti_gid_write(inode, ufs_get_inode_gid(sb, ufs_inode));\n\n\tinode->i_size = fs64_to_cpu(sb, ufs_inode->ui_size);\n\tinode->i_atime.tv_sec = (signed)fs32_to_cpu(sb, ufs_inode->ui_atime.tv_sec);\n\tinode_set_ctime(inode,\n\t\t\t(signed)fs32_to_cpu(sb, ufs_inode->ui_ctime.tv_sec),\n\t\t\t0);\n\tinode->i_mtime.tv_sec = (signed)fs32_to_cpu(sb, ufs_inode->ui_mtime.tv_sec);\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_blocks = fs32_to_cpu(sb, ufs_inode->ui_blocks);\n\tinode->i_generation = fs32_to_cpu(sb, ufs_inode->ui_gen);\n\tufsi->i_flags = fs32_to_cpu(sb, ufs_inode->ui_flags);\n\tufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);\n\tufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);\n\n\n\tif (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {\n\t\tmemcpy(ufsi->i_u1.i_data, &ufs_inode->ui_u2.ui_addr,\n\t\t       sizeof(ufs_inode->ui_u2.ui_addr));\n\t} else {\n\t\tmemcpy(ufsi->i_u1.i_symlink, ufs_inode->ui_u2.ui_symlink,\n\t\t       sizeof(ufs_inode->ui_u2.ui_symlink) - 1);\n\t\tufsi->i_u1.i_symlink[sizeof(ufs_inode->ui_u2.ui_symlink) - 1] = 0;\n\t}\n\treturn 0;\n}\n\nstatic int ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tumode_t mode;\n\n\tUFSD(\"Reading ufs2 inode, ino %lu\\n\", inode->i_ino);\n\t \n\tinode->i_mode = mode = fs16_to_cpu(sb, ufs2_inode->ui_mode);\n\tset_nlink(inode, fs16_to_cpu(sb, ufs2_inode->ui_nlink));\n\tif (inode->i_nlink == 0)\n\t\treturn -ESTALE;\n\n         \n\ti_uid_write(inode, fs32_to_cpu(sb, ufs2_inode->ui_uid));\n\ti_gid_write(inode, fs32_to_cpu(sb, ufs2_inode->ui_gid));\n\n\tinode->i_size = fs64_to_cpu(sb, ufs2_inode->ui_size);\n\tinode->i_atime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_atime);\n\tinode_set_ctime(inode, fs64_to_cpu(sb, ufs2_inode->ui_ctime),\n\t\t\tfs32_to_cpu(sb, ufs2_inode->ui_ctimensec));\n\tinode->i_mtime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_mtime);\n\tinode->i_atime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_atimensec);\n\tinode->i_mtime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_mtimensec);\n\tinode->i_blocks = fs64_to_cpu(sb, ufs2_inode->ui_blocks);\n\tinode->i_generation = fs32_to_cpu(sb, ufs2_inode->ui_gen);\n\tufsi->i_flags = fs32_to_cpu(sb, ufs2_inode->ui_flags);\n\t \n\n\tif (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {\n\t\tmemcpy(ufsi->i_u1.u2_i_data, &ufs2_inode->ui_u2.ui_addr,\n\t\t       sizeof(ufs2_inode->ui_u2.ui_addr));\n\t} else {\n\t\tmemcpy(ufsi->i_u1.i_symlink, ufs2_inode->ui_u2.ui_symlink,\n\t\t       sizeof(ufs2_inode->ui_u2.ui_symlink) - 1);\n\t\tufsi->i_u1.i_symlink[sizeof(ufs2_inode->ui_u2.ui_symlink) - 1] = 0;\n\t}\n\treturn 0;\n}\n\nstruct inode *ufs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ufs_inode_info *ufsi;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\tstruct inode *inode;\n\tint err = -EIO;\n\n\tUFSD(\"ENTER, ino %lu\\n\", ino);\n\n\tif (ino < UFS_ROOTINO || ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\",\n\t\t\t    ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tufsi = UFS_I(inode);\n\n\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\",\n\t\t\t    inode->i_ino);\n\t\tgoto bad_inode;\n\t}\n\tif ((UFS_SB(sb)->s_flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\terr = ufs2_read_inode(inode,\n\t\t\t\t      ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *)bh->b_data;\n\n\t\terr = ufs1_read_inode(inode,\n\t\t\t\t      ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\tbrelse(bh);\n\tif (err)\n\t\tgoto bad_inode;\n\n\tinode_inc_iversion(inode);\n\tufsi->i_lastfrag =\n\t\t(inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tufsi->i_dir_start_lookup = 0;\n\tufsi->i_osync = 0;\n\n\tufs_set_inode_ops(inode);\n\n\tUFSD(\"EXIT\\n\");\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}\n\nstatic void ufs1_update_inode(struct inode *inode, struct ufs_inode *ufs_inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n \tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\n\tufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);\n\tufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);\n\n\tufs_set_inode_uid(sb, ufs_inode, i_uid_read(inode));\n\tufs_set_inode_gid(sb, ufs_inode, i_gid_read(inode));\n\n\tufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);\n\tufs_inode->ui_atime.tv_sec = cpu_to_fs32(sb, inode->i_atime.tv_sec);\n\tufs_inode->ui_atime.tv_usec = 0;\n\tufs_inode->ui_ctime.tv_sec = cpu_to_fs32(sb,\n\t\t\t\t\t\t inode_get_ctime(inode).tv_sec);\n\tufs_inode->ui_ctime.tv_usec = 0;\n\tufs_inode->ui_mtime.tv_sec = cpu_to_fs32(sb, inode->i_mtime.tv_sec);\n\tufs_inode->ui_mtime.tv_usec = 0;\n\tufs_inode->ui_blocks = cpu_to_fs32(sb, inode->i_blocks);\n\tufs_inode->ui_flags = cpu_to_fs32(sb, ufsi->i_flags);\n\tufs_inode->ui_gen = cpu_to_fs32(sb, inode->i_generation);\n\n\tif ((UFS_SB(sb)->s_flags & UFS_UID_MASK) == UFS_UID_EFT) {\n\t\tufs_inode->ui_u3.ui_sun.ui_shadow = cpu_to_fs32(sb, ufsi->i_shadow);\n\t\tufs_inode->ui_u3.ui_sun.ui_oeftflag = cpu_to_fs32(sb, ufsi->i_oeftflag);\n\t}\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\t \n\t\tufs_inode->ui_u2.ui_addr.ui_db[0] = ufsi->i_u1.i_data[0];\n\t} else if (inode->i_blocks) {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_addr, ufsi->i_u1.i_data,\n\t\t       sizeof(ufs_inode->ui_u2.ui_addr));\n\t}\n\telse {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_symlink, ufsi->i_u1.i_symlink,\n\t\t       sizeof(ufs_inode->ui_u2.ui_symlink));\n\t}\n\n\tif (!inode->i_nlink)\n\t\tmemset (ufs_inode, 0, sizeof(struct ufs_inode));\n}\n\nstatic void ufs2_update_inode(struct inode *inode, struct ufs2_inode *ufs_inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n \tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\n\tUFSD(\"ENTER\\n\");\n\tufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);\n\tufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);\n\n\tufs_inode->ui_uid = cpu_to_fs32(sb, i_uid_read(inode));\n\tufs_inode->ui_gid = cpu_to_fs32(sb, i_gid_read(inode));\n\n\tufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);\n\tufs_inode->ui_atime = cpu_to_fs64(sb, inode->i_atime.tv_sec);\n\tufs_inode->ui_atimensec = cpu_to_fs32(sb, inode->i_atime.tv_nsec);\n\tufs_inode->ui_ctime = cpu_to_fs64(sb, inode_get_ctime(inode).tv_sec);\n\tufs_inode->ui_ctimensec = cpu_to_fs32(sb,\n\t\t\t\t\t      inode_get_ctime(inode).tv_nsec);\n\tufs_inode->ui_mtime = cpu_to_fs64(sb, inode->i_mtime.tv_sec);\n\tufs_inode->ui_mtimensec = cpu_to_fs32(sb, inode->i_mtime.tv_nsec);\n\n\tufs_inode->ui_blocks = cpu_to_fs64(sb, inode->i_blocks);\n\tufs_inode->ui_flags = cpu_to_fs32(sb, ufsi->i_flags);\n\tufs_inode->ui_gen = cpu_to_fs32(sb, inode->i_generation);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\t \n\t\tufs_inode->ui_u2.ui_addr.ui_db[0] = ufsi->i_u1.u2_i_data[0];\n\t} else if (inode->i_blocks) {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_addr, ufsi->i_u1.u2_i_data,\n\t\t       sizeof(ufs_inode->ui_u2.ui_addr));\n\t} else {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_symlink, ufsi->i_u1.i_symlink,\n\t\t       sizeof(ufs_inode->ui_u2.ui_symlink));\n \t}\n\n\tif (!inode->i_nlink)\n\t\tmemset (ufs_inode, 0, sizeof(struct ufs2_inode));\n\tUFSD(\"EXIT\\n\");\n}\n\nstatic int ufs_update_inode(struct inode * inode, int do_sync)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\n\tUFSD(\"ENTER, ino %lu\\n\", inode->i_ino);\n\n\tif (inode->i_ino < UFS_ROOTINO ||\n\t    inode->i_ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning (sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\n\tbh = sb_bread(sb, ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning (sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\tufs2_update_inode(inode,\n\t\t\t\t  ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *) bh->b_data;\n\n\t\tufs1_update_inode(inode, ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\n\tmark_buffer_dirty(bh);\n\tif (do_sync)\n\t\tsync_dirty_buffer(bh);\n\tbrelse (bh);\n\n\tUFSD(\"EXIT\\n\");\n\treturn 0;\n}\n\nint ufs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\treturn ufs_update_inode(inode, wbc->sync_mode == WB_SYNC_ALL);\n}\n\nint ufs_sync_inode (struct inode *inode)\n{\n\treturn ufs_update_inode (inode, 1);\n}\n\nvoid ufs_evict_inode(struct inode * inode)\n{\n\tint want_delete = 0;\n\n\tif (!inode->i_nlink && !is_bad_inode(inode))\n\t\twant_delete = 1;\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (want_delete) {\n\t\tinode->i_size = 0;\n\t\tif (inode->i_blocks &&\n\t\t    (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t     S_ISLNK(inode->i_mode)))\n\t\t\tufs_truncate_blocks(inode);\n\t\tufs_update_inode(inode, inode_needs_sync(inode));\n\t}\n\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\n\tif (want_delete)\n\t\tufs_free_inode(inode);\n}\n\nstruct to_free {\n\tstruct inode *inode;\n\tu64 to;\n\tunsigned count;\n};\n\nstatic inline void free_data(struct to_free *ctx, u64 from, unsigned count)\n{\n\tif (ctx->count && ctx->to != from) {\n\t\tufs_free_blocks(ctx->inode, ctx->to - ctx->count, ctx->count);\n\t\tctx->count = 0;\n\t}\n\tctx->count += count;\n\tctx->to = from + count;\n}\n\n#define DIRECT_FRAGMENT ((inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift)\n\nstatic void ufs_trunc_direct(struct inode *inode)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tvoid *p;\n\tu64 frag1, frag2, frag3, frag4, block1, block2;\n\tstruct to_free ctx = {.inode = inode};\n\tunsigned i, tmp;\n\n\tUFSD(\"ENTER: ino %lu\\n\", inode->i_ino);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tfrag1 = DIRECT_FRAGMENT;\n\tfrag4 = min_t(u64, UFS_NDIR_FRAGMENT, ufsi->i_lastfrag);\n\tfrag2 = ((frag1 & uspi->s_fpbmask) ? ((frag1 | uspi->s_fpbmask) + 1) : frag1);\n\tfrag3 = frag4 & ~uspi->s_fpbmask;\n\tblock1 = block2 = 0;\n\tif (frag2 > frag3) {\n\t\tfrag2 = frag4;\n\t\tfrag3 = frag4 = 0;\n\t} else if (frag2 < frag3) {\n\t\tblock1 = ufs_fragstoblks (frag2);\n\t\tblock2 = ufs_fragstoblks (frag3);\n\t}\n\n\tUFSD(\"ino %lu, frag1 %llu, frag2 %llu, block1 %llu, block2 %llu,\"\n\t     \" frag3 %llu, frag4 %llu\\n\", inode->i_ino,\n\t     (unsigned long long)frag1, (unsigned long long)frag2,\n\t     (unsigned long long)block1, (unsigned long long)block2,\n\t     (unsigned long long)frag3, (unsigned long long)frag4);\n\n\tif (frag1 >= frag2)\n\t\tgoto next1;\n\n\t \n\tp = ufs_get_direct_data_ptr(uspi, ufsi, ufs_fragstoblks(frag1));\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp )\n\t\tufs_panic (sb, \"ufs_trunc_direct\", \"internal error\");\n\tfrag2 -= frag1;\n\tfrag1 = ufs_fragnum (frag1);\n\n\tufs_free_fragments(inode, tmp + frag1, frag2);\n\nnext1:\n\t \n\tfor (i = block1 ; i < block2; i++) {\n\t\tp = ufs_get_direct_data_ptr(uspi, ufsi, i);\n\t\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\t\twrite_seqlock(&ufsi->meta_lock);\n\t\tufs_data_ptr_clear(uspi, p);\n\t\twrite_sequnlock(&ufsi->meta_lock);\n\n\t\tfree_data(&ctx, tmp, uspi->s_fpb);\n\t}\n\n\tfree_data(&ctx, 0, 0);\n\n\tif (frag3 >= frag4)\n\t\tgoto next3;\n\n\t \n\tp = ufs_get_direct_data_ptr(uspi, ufsi, ufs_fragstoblks(frag3));\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (!tmp )\n\t\tufs_panic(sb, \"ufs_truncate_direct\", \"internal error\");\n\tfrag4 = ufs_fragnum (frag4);\n\twrite_seqlock(&ufsi->meta_lock);\n\tufs_data_ptr_clear(uspi, p);\n\twrite_sequnlock(&ufsi->meta_lock);\n\n\tufs_free_fragments (inode, tmp, frag4);\n next3:\n\n\tUFSD(\"EXIT: ino %lu\\n\", inode->i_ino);\n}\n\nstatic void free_full_branch(struct inode *inode, u64 ind_block, int depth)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct ufs_buffer_head *ubh = ubh_bread(sb, ind_block, uspi->s_bsize);\n\tunsigned i;\n\n\tif (!ubh)\n\t\treturn;\n\n\tif (--depth) {\n\t\tfor (i = 0; i < uspi->s_apb; i++) {\n\t\t\tvoid *p = ubh_get_data_ptr(uspi, ubh, i);\n\t\t\tu64 block = ufs_data_ptr_to_cpu(sb, p);\n\t\t\tif (block)\n\t\t\t\tfree_full_branch(inode, block, depth);\n\t\t}\n\t} else {\n\t\tstruct to_free ctx = {.inode = inode};\n\n\t\tfor (i = 0; i < uspi->s_apb; i++) {\n\t\t\tvoid *p = ubh_get_data_ptr(uspi, ubh, i);\n\t\t\tu64 block = ufs_data_ptr_to_cpu(sb, p);\n\t\t\tif (block)\n\t\t\t\tfree_data(&ctx, block, uspi->s_fpb);\n\t\t}\n\t\tfree_data(&ctx, 0, 0);\n\t}\n\n\tubh_bforget(ubh);\n\tufs_free_blocks(inode, ind_block, uspi->s_fpb);\n}\n\nstatic void free_branch_tail(struct inode *inode, unsigned from, struct ufs_buffer_head *ubh, int depth)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tunsigned i;\n\n\tif (--depth) {\n\t\tfor (i = from; i < uspi->s_apb ; i++) {\n\t\t\tvoid *p = ubh_get_data_ptr(uspi, ubh, i);\n\t\t\tu64 block = ufs_data_ptr_to_cpu(sb, p);\n\t\t\tif (block) {\n\t\t\t\twrite_seqlock(&UFS_I(inode)->meta_lock);\n\t\t\t\tufs_data_ptr_clear(uspi, p);\n\t\t\t\twrite_sequnlock(&UFS_I(inode)->meta_lock);\n\t\t\t\tubh_mark_buffer_dirty(ubh);\n\t\t\t\tfree_full_branch(inode, block, depth);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstruct to_free ctx = {.inode = inode};\n\n\t\tfor (i = from; i < uspi->s_apb; i++) {\n\t\t\tvoid *p = ubh_get_data_ptr(uspi, ubh, i);\n\t\t\tu64 block = ufs_data_ptr_to_cpu(sb, p);\n\t\t\tif (block) {\n\t\t\t\twrite_seqlock(&UFS_I(inode)->meta_lock);\n\t\t\t\tufs_data_ptr_clear(uspi, p);\n\t\t\t\twrite_sequnlock(&UFS_I(inode)->meta_lock);\n\t\t\t\tubh_mark_buffer_dirty(ubh);\n\t\t\t\tfree_data(&ctx, block, uspi->s_fpb);\n\t\t\t}\n\t\t}\n\t\tfree_data(&ctx, 0, 0);\n\t}\n\tif (IS_SYNC(inode) && ubh_buffer_dirty(ubh))\n\t\tubh_sync_block(ubh);\n\tubh_brelse(ubh);\n}\n\nstatic int ufs_alloc_lastblock(struct inode *inode, loff_t size)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tunsigned i, end;\n\tsector_t lastfrag;\n\tstruct page *lastpage;\n\tstruct buffer_head *bh;\n\tu64 phys64;\n\n\tlastfrag = (size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\n\tif (!lastfrag)\n\t\tgoto out;\n\n\tlastfrag--;\n\n\tlastpage = ufs_get_locked_page(mapping, lastfrag >>\n\t\t\t\t       (PAGE_SHIFT - inode->i_blkbits));\n       if (IS_ERR(lastpage)) {\n               err = -EIO;\n               goto out;\n       }\n\n       end = lastfrag & ((1 << (PAGE_SHIFT - inode->i_blkbits)) - 1);\n       bh = page_buffers(lastpage);\n       for (i = 0; i < end; ++i)\n               bh = bh->b_this_page;\n\n\n       err = ufs_getfrag_block(inode, lastfrag, bh, 1);\n\n       if (unlikely(err))\n\t       goto out_unlock;\n\n       if (buffer_new(bh)) {\n\t       clear_buffer_new(bh);\n\t       clean_bdev_bh_alias(bh);\n\t        \n\t       set_buffer_uptodate(bh);\n\t       mark_buffer_dirty(bh);\n\t       set_page_dirty(lastpage);\n       }\n\n       if (lastfrag >= UFS_IND_FRAGMENT) {\n\t       end = uspi->s_fpb - ufs_fragnum(lastfrag) - 1;\n\t       phys64 = bh->b_blocknr + 1;\n\t       for (i = 0; i < end; ++i) {\n\t\t       bh = sb_getblk(sb, i + phys64);\n\t\t       lock_buffer(bh);\n\t\t       memset(bh->b_data, 0, sb->s_blocksize);\n\t\t       set_buffer_uptodate(bh);\n\t\t       mark_buffer_dirty(bh);\n\t\t       unlock_buffer(bh);\n\t\t       sync_dirty_buffer(bh);\n\t\t       brelse(bh);\n\t       }\n       }\nout_unlock:\n       ufs_put_locked_page(lastpage);\nout:\n       return err;\n}\n\nstatic void ufs_truncate_blocks(struct inode *inode)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tunsigned offsets[4];\n\tint depth;\n\tint depth2;\n\tunsigned i;\n\tstruct ufs_buffer_head *ubh[3];\n\tvoid *p;\n\tu64 block;\n\n\tif (inode->i_size) {\n\t\tsector_t last = (inode->i_size - 1) >> uspi->s_bshift;\n\t\tdepth = ufs_block_to_path(inode, last, offsets);\n\t\tif (!depth)\n\t\t\treturn;\n\t} else {\n\t\tdepth = 1;\n\t}\n\n\tfor (depth2 = depth - 1; depth2; depth2--)\n\t\tif (offsets[depth2] != uspi->s_apb - 1)\n\t\t\tbreak;\n\n\tmutex_lock(&ufsi->truncate_mutex);\n\tif (depth == 1) {\n\t\tufs_trunc_direct(inode);\n\t\toffsets[0] = UFS_IND_BLOCK;\n\t} else {\n\t\t \n\t\tp = ufs_get_direct_data_ptr(uspi, ufsi, offsets[0]++);\n\t\tfor (i = 0; i < depth2; i++) {\n\t\t\tblock = ufs_data_ptr_to_cpu(sb, p);\n\t\t\tif (!block)\n\t\t\t\tbreak;\n\t\t\tubh[i] = ubh_bread(sb, block, uspi->s_bsize);\n\t\t\tif (!ubh[i]) {\n\t\t\t\twrite_seqlock(&ufsi->meta_lock);\n\t\t\t\tufs_data_ptr_clear(uspi, p);\n\t\t\t\twrite_sequnlock(&ufsi->meta_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = ubh_get_data_ptr(uspi, ubh[i], offsets[i + 1]++);\n\t\t}\n\t\twhile (i--)\n\t\t\tfree_branch_tail(inode, offsets[i + 1], ubh[i], depth - i - 1);\n\t}\n\tfor (i = offsets[0]; i <= UFS_TIND_BLOCK; i++) {\n\t\tp = ufs_get_direct_data_ptr(uspi, ufsi, i);\n\t\tblock = ufs_data_ptr_to_cpu(sb, p);\n\t\tif (block) {\n\t\t\twrite_seqlock(&ufsi->meta_lock);\n\t\t\tufs_data_ptr_clear(uspi, p);\n\t\t\twrite_sequnlock(&ufsi->meta_lock);\n\t\t\tfree_full_branch(inode, block, i - UFS_IND_BLOCK + 1);\n\t\t}\n\t}\n\tread_seqlock_excl(&ufsi->meta_lock);\n\tufsi->i_lastfrag = DIRECT_FRAGMENT;\n\tread_sequnlock_excl(&ufsi->meta_lock);\n\tmark_inode_dirty(inode);\n\tmutex_unlock(&ufsi->truncate_mutex);\n}\n\nstatic int ufs_truncate(struct inode *inode, loff_t size)\n{\n\tint err = 0;\n\n\tUFSD(\"ENTER: ino %lu, i_size: %llu, old_i_size: %llu\\n\",\n\t     inode->i_ino, (unsigned long long)size,\n\t     (unsigned long long)i_size_read(inode));\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t      S_ISLNK(inode->i_mode)))\n\t\treturn -EINVAL;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\terr = ufs_alloc_lastblock(inode, size);\n\n\tif (err)\n\t\tgoto out;\n\n\tblock_truncate_page(inode->i_mapping, size, ufs_getfrag_block);\n\n\ttruncate_setsize(inode, size);\n\n\tufs_truncate_blocks(inode);\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\nout:\n\tUFSD(\"EXIT: err %d\\n\", err);\n\treturn err;\n}\n\nint ufs_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\tstruct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tunsigned int ia_valid = attr->ia_valid;\n\tint error;\n\n\terror = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\tif (error)\n\t\treturn error;\n\n\tif (ia_valid & ATTR_SIZE && attr->ia_size != inode->i_size) {\n\t\terror = ufs_truncate(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tsetattr_copy(&nop_mnt_idmap, inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}\n\nconst struct inode_operations ufs_file_inode_operations = {\n\t.setattr = ufs_setattr,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}