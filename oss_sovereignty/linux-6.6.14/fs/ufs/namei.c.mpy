{
  "module_name": "namei.c",
  "hash_id": "e5d5b172bede9393ca930790803eeb5f2b806c4cbec94f6fbdaa7d923c6e5b3c",
  "original_prompt": "Ingested from linux-6.6.14/fs/ufs/namei.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/fs.h>\n\n#include \"ufs_fs.h\"\n#include \"ufs.h\"\n#include \"util.h\"\n\nstatic inline int ufs_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ufs_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate_new(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tdiscard_new_inode(inode);\n\treturn err;\n}\n\nstatic struct dentry *ufs_lookup(struct inode * dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode * inode = NULL;\n\tino_t ino;\n\t\n\tif (dentry->d_name.len > UFS_MAXNAMLEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tino = ufs_inode_by_name(dir, &dentry->d_name);\n\tif (ino)\n\t\tinode = ufs_iget(dir->i_sb, ino);\n\treturn d_splice_alias(inode, dentry);\n}\n\n \nstatic int ufs_create (struct mnt_idmap * idmap,\n\t\tstruct inode * dir, struct dentry * dentry, umode_t mode,\n\t\tbool excl)\n{\n\tstruct inode *inode;\n\n\tinode = ufs_new_inode(dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &ufs_file_inode_operations;\n\tinode->i_fop = &ufs_file_operations;\n\tinode->i_mapping->a_ops = &ufs_aops;\n\tmark_inode_dirty(inode);\n\treturn ufs_add_nondir(dentry, inode);\n}\n\nstatic int ufs_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t\t     struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tif (!old_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tinode = ufs_new_inode(dir, mode);\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinit_special_inode(inode, mode, rdev);\n\t\tufs_set_inode_dev(inode->i_sb, UFS_I(inode), rdev);\n\t\tmark_inode_dirty(inode);\n\t\terr = ufs_add_nondir(dentry, inode);\n\t}\n\treturn err;\n}\n\nstatic int ufs_symlink (struct mnt_idmap * idmap, struct inode * dir,\n\tstruct dentry * dentry, const char * symname)\n{\n\tstruct super_block * sb = dir->i_sb;\n\tint err;\n\tunsigned l = strlen(symname)+1;\n\tstruct inode * inode;\n\n\tif (l > sb->s_blocksize)\n\t\treturn -ENAMETOOLONG;\n\n\tinode = ufs_new_inode(dir, S_IFLNK | S_IRWXUGO);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\treturn err;\n\n\tif (l > UFS_SB(sb)->s_uspi->s_maxsymlinklen) {\n\t\t \n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t\terr = page_symlink(inode, symname, l);\n\t\tif (err)\n\t\t\tgoto out_fail;\n\t} else {\n\t\t \n\t\tinode->i_op = &simple_symlink_inode_operations;\n\t\tinode->i_link = (char *)UFS_I(inode)->i_u1.i_symlink;\n\t\tmemcpy(inode->i_link, symname, l);\n\t\tinode->i_size = l-1;\n\t}\n\tmark_inode_dirty(inode);\n\n\treturn ufs_add_nondir(dentry, inode);\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tdiscard_new_inode(inode);\n\treturn err;\n}\n\nstatic int ufs_link (struct dentry * old_dentry, struct inode * dir,\n\tstruct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(old_dentry);\n\tint error;\n\n\tinode_set_ctime_current(inode);\n\tinode_inc_link_count(inode);\n\tihold(inode);\n\n\terror = ufs_add_link(dentry, inode);\n\tif (error) {\n\t\tinode_dec_link_count(inode);\n\t\tiput(inode);\n\t} else\n\t\td_instantiate(dentry, inode);\n\treturn error;\n}\n\nstatic int ufs_mkdir(struct mnt_idmap * idmap, struct inode * dir,\n\tstruct dentry * dentry, umode_t mode)\n{\n\tstruct inode * inode;\n\tint err;\n\n\tinode_inc_link_count(dir);\n\n\tinode = ufs_new_inode(dir, S_IFDIR|mode);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_dir;\n\n\tinode->i_op = &ufs_dir_inode_operations;\n\tinode->i_fop = &ufs_dir_operations;\n\tinode->i_mapping->a_ops = &ufs_aops;\n\n\tinode_inc_link_count(inode);\n\n\terr = ufs_make_empty(inode, dir);\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = ufs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_fail;\n\n\td_instantiate_new(dentry, inode);\n\treturn 0;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tinode_dec_link_count(inode);\n\tdiscard_new_inode(inode);\nout_dir:\n\tinode_dec_link_count(dir);\n\treturn err;\n}\n\nstatic int ufs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode * inode = d_inode(dentry);\n\tstruct ufs_dir_entry *de;\n\tstruct page *page;\n\tint err = -ENOENT;\n\n\tde = ufs_find_entry(dir, &dentry->d_name, &page);\n\tif (!de)\n\t\tgoto out;\n\n\terr = ufs_delete_entry(dir, de, page);\n\tif (err)\n\t\tgoto out;\n\n\tinode_set_ctime_to_ts(inode, inode_get_ctime(dir));\n\tinode_dec_link_count(inode);\n\terr = 0;\nout:\n\treturn err;\n}\n\nstatic int ufs_rmdir (struct inode * dir, struct dentry *dentry)\n{\n\tstruct inode * inode = d_inode(dentry);\n\tint err= -ENOTEMPTY;\n\n\tif (ufs_empty_dir (inode)) {\n\t\terr = ufs_unlink(dir, dentry);\n\t\tif (!err) {\n\t\t\tinode->i_size = 0;\n\t\t\tinode_dec_link_count(inode);\n\t\t\tinode_dec_link_count(dir);\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int ufs_rename(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\t      struct dentry *old_dentry, struct inode *new_dir,\n\t\t      struct dentry *new_dentry, unsigned int flags)\n{\n\tstruct inode *old_inode = d_inode(old_dentry);\n\tstruct inode *new_inode = d_inode(new_dentry);\n\tstruct page *dir_page = NULL;\n\tstruct ufs_dir_entry * dir_de = NULL;\n\tstruct page *old_page;\n\tstruct ufs_dir_entry *old_de;\n\tint err = -ENOENT;\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\told_de = ufs_find_entry(old_dir, &old_dentry->d_name, &old_page);\n\tif (!old_de)\n\t\tgoto out;\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\terr = -EIO;\n\t\tdir_de = ufs_dotdot(old_inode, &dir_page);\n\t\tif (!dir_de)\n\t\t\tgoto out_old;\n\t}\n\n\tif (new_inode) {\n\t\tstruct page *new_page;\n\t\tstruct ufs_dir_entry *new_de;\n\n\t\terr = -ENOTEMPTY;\n\t\tif (dir_de && !ufs_empty_dir(new_inode))\n\t\t\tgoto out_dir;\n\n\t\terr = -ENOENT;\n\t\tnew_de = ufs_find_entry(new_dir, &new_dentry->d_name, &new_page);\n\t\tif (!new_de)\n\t\t\tgoto out_dir;\n\t\tufs_set_link(new_dir, new_de, new_page, old_inode, 1);\n\t\tinode_set_ctime_current(new_inode);\n\t\tif (dir_de)\n\t\t\tdrop_nlink(new_inode);\n\t\tinode_dec_link_count(new_inode);\n\t} else {\n\t\terr = ufs_add_link(new_dentry, old_inode);\n\t\tif (err)\n\t\t\tgoto out_dir;\n\t\tif (dir_de)\n\t\t\tinode_inc_link_count(new_dir);\n\t}\n\n\t \n\tinode_set_ctime_current(old_inode);\n\n\tufs_delete_entry(old_dir, old_de, old_page);\n\tmark_inode_dirty(old_inode);\n\n\tif (dir_de) {\n\t\tif (old_dir != new_dir)\n\t\t\tufs_set_link(old_inode, dir_de, dir_page, new_dir, 0);\n\t\telse {\n\t\t\tkunmap(dir_page);\n\t\t\tput_page(dir_page);\n\t\t}\n\t\tinode_dec_link_count(old_dir);\n\t}\n\treturn 0;\n\n\nout_dir:\n\tif (dir_de) {\n\t\tkunmap(dir_page);\n\t\tput_page(dir_page);\n\t}\nout_old:\n\tkunmap(old_page);\n\tput_page(old_page);\nout:\n\treturn err;\n}\n\nconst struct inode_operations ufs_dir_inode_operations = {\n\t.create\t\t= ufs_create,\n\t.lookup\t\t= ufs_lookup,\n\t.link\t\t= ufs_link,\n\t.unlink\t\t= ufs_unlink,\n\t.symlink\t= ufs_symlink,\n\t.mkdir\t\t= ufs_mkdir,\n\t.rmdir\t\t= ufs_rmdir,\n\t.mknod\t\t= ufs_mknod,\n\t.rename\t\t= ufs_rename,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}