{
  "module_name": "util.c",
  "hash_id": "5dbb10f73abd2eb53f0f0c8c54660b0a2340551178c8dbf839231f460ad1ecfe",
  "original_prompt": "Ingested from linux-6.6.14/fs/ufs/util.c",
  "human_readable_source": "\n \n \n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\n#include \"ufs_fs.h\"\n#include \"ufs.h\"\n#include \"swab.h\"\n#include \"util.h\"\n\nstruct ufs_buffer_head * _ubh_bread_ (struct ufs_sb_private_info * uspi,\n\tstruct super_block *sb, u64 fragment, u64 size)\n{\n\tstruct ufs_buffer_head * ubh;\n\tunsigned i, j ;\n\tu64  count = 0;\n\tif (size & ~uspi->s_fmask)\n\t\treturn NULL;\n\tcount = size >> uspi->s_fshift;\n\tif (count > UFS_MAXFRAG)\n\t\treturn NULL;\n\tubh = kmalloc (sizeof (struct ufs_buffer_head), GFP_NOFS);\n\tif (!ubh)\n\t\treturn NULL;\n\tubh->fragment = fragment;\n\tubh->count = count;\n\tfor (i = 0; i < count; i++)\n\t\tif (!(ubh->bh[i] = sb_bread(sb, fragment + i)))\n\t\t\tgoto failed;\n\tfor (; i < UFS_MAXFRAG; i++)\n\t\tubh->bh[i] = NULL;\n\treturn ubh;\nfailed:\n\tfor (j = 0; j < i; j++)\n\t\tbrelse (ubh->bh[j]);\n\tkfree(ubh);\n\treturn NULL;\n}\n\nstruct ufs_buffer_head * ubh_bread_uspi (struct ufs_sb_private_info * uspi,\n\tstruct super_block *sb, u64 fragment, u64 size)\n{\n\tunsigned i, j;\n\tu64 count = 0;\n\tif (size & ~uspi->s_fmask)\n\t\treturn NULL;\n\tcount = size >> uspi->s_fshift;\n\tif (count <= 0 || count > UFS_MAXFRAG)\n\t\treturn NULL;\n\tUSPI_UBH(uspi)->fragment = fragment;\n\tUSPI_UBH(uspi)->count = count;\n\tfor (i = 0; i < count; i++)\n\t\tif (!(USPI_UBH(uspi)->bh[i] = sb_bread(sb, fragment + i)))\n\t\t\tgoto failed;\n\tfor (; i < UFS_MAXFRAG; i++)\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\treturn USPI_UBH(uspi);\nfailed:\n\tfor (j = 0; j < i; j++)\n\t\tbrelse (USPI_UBH(uspi)->bh[j]);\n\treturn NULL;\n}\n\nvoid ubh_brelse (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor (i = 0; i < ubh->count; i++)\n\t\tbrelse (ubh->bh[i]);\n\tkfree (ubh);\n}\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}\n\nvoid ubh_mark_buffer_uptodate (struct ufs_buffer_head * ubh, int flag)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tif (flag) {\n\t\tfor ( i = 0; i < ubh->count; i++ )\n\t\t\tset_buffer_uptodate (ubh->bh[i]);\n\t} else {\n\t\tfor ( i = 0; i < ubh->count; i++ )\n\t\t\tclear_buffer_uptodate (ubh->bh[i]);\n\t}\n}\n\nvoid ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], 0);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}\n\nvoid ubh_bforget (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh) \n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ ) if ( ubh->bh[i] ) \n\t\tbforget (ubh->bh[i]);\n}\n \nint ubh_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tunsigned result = 0;\n\tif (!ubh)\n\t\treturn 0;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tresult |= buffer_dirty(ubh->bh[i]);\n\treturn result;\n}\n\nvoid _ubh_ubhcpymem_(struct ufs_sb_private_info * uspi, \n\tunsigned char * mem, struct ufs_buffer_head * ubh, unsigned size)\n{\n\tunsigned len, bhno;\n\tif (size > (ubh->count << uspi->s_fshift))\n\t\tsize = ubh->count << uspi->s_fshift;\n\tbhno = 0;\n\twhile (size) {\n\t\tlen = min_t(unsigned int, size, uspi->s_fsize);\n\t\tmemcpy (mem, ubh->bh[bhno]->b_data, len);\n\t\tmem += uspi->s_fsize;\n\t\tsize -= len;\n\t\tbhno++;\n\t}\n}\n\nvoid _ubh_memcpyubh_(struct ufs_sb_private_info * uspi, \n\tstruct ufs_buffer_head * ubh, unsigned char * mem, unsigned size)\n{\n\tunsigned len, bhno;\n\tif (size > (ubh->count << uspi->s_fshift))\n\t\tsize = ubh->count << uspi->s_fshift;\n\tbhno = 0;\n\twhile (size) {\n\t\tlen = min_t(unsigned int, size, uspi->s_fsize);\n\t\tmemcpy (ubh->bh[bhno]->b_data, mem, len);\n\t\tmem += uspi->s_fsize;\n\t\tsize -= len;\n\t\tbhno++;\n\t}\n}\n\ndev_t\nufs_get_inode_dev(struct super_block *sb, struct ufs_inode_info *ufsi)\n{\n\t__u32 fs32;\n\tdev_t dev;\n\n\tif ((UFS_SB(sb)->s_flags & UFS_ST_MASK) == UFS_ST_SUNx86)\n\t\tfs32 = fs32_to_cpu(sb, ufsi->i_u1.i_data[1]);\n\telse\n\t\tfs32 = fs32_to_cpu(sb, ufsi->i_u1.i_data[0]);\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNx86:\n\tcase UFS_ST_SUN:\n\t\tif ((fs32 & 0xffff0000) == 0 ||\n\t\t    (fs32 & 0xffff0000) == 0xffff0000)\n\t\t\tdev = old_decode_dev(fs32 & 0x7fff);\n\t\telse\n\t\t\tdev = MKDEV(sysv_major(fs32), sysv_minor(fs32));\n\t\tbreak;\n\n\tdefault:\n\t\tdev = old_decode_dev(fs32);\n\t\tbreak;\n\t}\n\treturn dev;\n}\n\nvoid\nufs_set_inode_dev(struct super_block *sb, struct ufs_inode_info *ufsi, dev_t dev)\n{\n\t__u32 fs32;\n\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNx86:\n\tcase UFS_ST_SUN:\n\t\tfs32 = sysv_encode_dev(dev);\n\t\tif ((fs32 & 0xffff8000) == 0) {\n\t\t\tfs32 = old_encode_dev(dev);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tfs32 = old_encode_dev(dev);\n\t\tbreak;\n\t}\n\tif ((UFS_SB(sb)->s_flags & UFS_ST_MASK) == UFS_ST_SUNx86)\n\t\tufsi->i_u1.i_data[1] = cpu_to_fs32(sb, fs32);\n\telse\n\t\tufsi->i_u1.i_data[0] = cpu_to_fs32(sb, fs32);\n}\n\n \n\nstruct page *ufs_get_locked_page(struct address_space *mapping,\n\t\t\t\t pgoff_t index)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct page *page = find_lock_page(mapping, index);\n\tif (!page) {\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tprintk(KERN_ERR \"ufs_change_blocknr: \"\n\t\t\t       \"read_mapping_page error: ino %lu, index: %lu\\n\",\n\t\t\t       mapping->host->i_ino, index);\n\t\t\treturn page;\n\t\t}\n\n\t\tlock_page(page);\n\n\t\tif (unlikely(page->mapping == NULL)) {\n\t\t\t \n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << inode->i_blkbits, 0);\n\treturn page;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}