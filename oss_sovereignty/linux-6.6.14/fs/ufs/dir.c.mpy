{
  "module_name": "dir.c",
  "hash_id": "d601b8604f391aa5688fd4b598777b7b7fb71ee584f29f9539ceabad8c8c9023",
  "original_prompt": "Ingested from linux-6.6.14/fs/ufs/dir.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/swap.h>\n#include <linux/iversion.h>\n\n#include \"ufs_fs.h\"\n#include \"ufs.h\"\n#include \"swab.h\"\n#include \"util.h\"\n\n \nstatic inline int ufs_match(struct super_block *sb, int len,\n\t\tconst unsigned char *name, struct ufs_dir_entry *de)\n{\n\tif (len != ufs_get_de_namlen(sb, de))\n\t\treturn 0;\n\tif (!de->d_ino)\n\t\treturn 0;\n\treturn !memcmp(name, de->d_name, len);\n}\n\nstatic void ufs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\n\tinode_inc_iversion(dir);\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tunlock_page(page);\n}\n\nstatic int ufs_handle_dirsync(struct inode *dir)\n{\n\tint err;\n\n\terr = filemap_write_and_wait(dir->i_mapping);\n\tif (!err)\n\t\terr = sync_inode_metadata(dir, 1);\n\treturn err;\n}\n\nstatic inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}\n\nino_t ufs_inode_by_name(struct inode *dir, const struct qstr *qstr)\n{\n\tino_t res = 0;\n\tstruct ufs_dir_entry *de;\n\tstruct page *page;\n\t\n\tde = ufs_find_entry(dir, qstr, &page);\n\tif (de) {\n\t\tres = fs32_to_cpu(dir->i_sb, de->d_ino);\n\t\tufs_put_page(page);\n\t}\n\treturn res;\n}\n\n\n \nvoid ufs_set_link(struct inode *dir, struct ufs_dir_entry *de,\n\t\t  struct page *page, struct inode *inode,\n\t\t  bool update_times)\n{\n\tloff_t pos = page_offset(page) +\n\t\t\t(char *) de - (char *) page_address(page);\n\tunsigned len = fs16_to_cpu(dir->i_sb, de->d_reclen);\n\tint err;\n\n\tlock_page(page);\n\terr = ufs_prepare_chunk(page, pos, len);\n\tBUG_ON(err);\n\n\tde->d_ino = cpu_to_fs32(dir->i_sb, inode->i_ino);\n\tufs_set_de_type(dir->i_sb, de, inode->i_mode);\n\n\tufs_commit_chunk(page, pos, len);\n\tufs_put_page(page);\n\tif (update_times)\n\t\tdir->i_mtime = inode_set_ctime_current(dir);\n\tmark_inode_dirty(dir);\n\tufs_handle_dirsync(dir);\n}\n\n\nstatic bool ufs_check_page(struct page *page)\n{\n\tstruct inode *dir = page->mapping->host;\n\tstruct super_block *sb = dir->i_sb;\n\tchar *kaddr = page_address(page);\n\tunsigned offs, rec_len;\n\tunsigned limit = PAGE_SIZE;\n\tconst unsigned chunk_mask = UFS_SB(sb)->s_uspi->s_dirblksize - 1;\n\tstruct ufs_dir_entry *p;\n\tchar *error;\n\n\tif ((dir->i_size >> PAGE_SHIFT) == page->index) {\n\t\tlimit = dir->i_size & ~PAGE_MASK;\n\t\tif (limit & chunk_mask)\n\t\t\tgoto Ebadsize;\n\t\tif (!limit)\n\t\t\tgoto out;\n\t}\n\tfor (offs = 0; offs <= limit - UFS_DIR_REC_LEN(1); offs += rec_len) {\n\t\tp = (struct ufs_dir_entry *)(kaddr + offs);\n\t\trec_len = fs16_to_cpu(sb, p->d_reclen);\n\n\t\tif (rec_len < UFS_DIR_REC_LEN(1))\n\t\t\tgoto Eshort;\n\t\tif (rec_len & 3)\n\t\t\tgoto Ealign;\n\t\tif (rec_len < UFS_DIR_REC_LEN(ufs_get_de_namlen(sb, p)))\n\t\t\tgoto Enamelen;\n\t\tif (((offs + rec_len - 1) ^ offs) & ~chunk_mask)\n\t\t\tgoto Espan;\n\t\tif (fs32_to_cpu(sb, p->d_ino) > (UFS_SB(sb)->s_uspi->s_ipg *\n\t\t\t\t\t\t  UFS_SB(sb)->s_uspi->s_ncg))\n\t\t\tgoto Einumber;\n\t}\n\tif (offs != limit)\n\t\tgoto Eend;\nout:\n\tSetPageChecked(page);\n\treturn true;\n\n\t \n\nEbadsize:\n\tufs_error(sb, \"ufs_check_page\",\n\t\t  \"size of directory #%lu is not a multiple of chunk size\",\n\t\t  dir->i_ino\n\t);\n\tgoto fail;\nEshort:\n\terror = \"rec_len is smaller than minimal\";\n\tgoto bad_entry;\nEalign:\n\terror = \"unaligned directory entry\";\n\tgoto bad_entry;\nEnamelen:\n\terror = \"rec_len is too small for name_len\";\n\tgoto bad_entry;\nEspan:\n\terror = \"directory entry across blocks\";\n\tgoto bad_entry;\nEinumber:\n\terror = \"inode out of bounds\";\nbad_entry:\n\tufs_error (sb, \"ufs_check_page\", \"bad entry in directory #%lu: %s - \"\n\t\t   \"offset=%lu, rec_len=%d, name_len=%d\",\n\t\t   dir->i_ino, error, (page->index<<PAGE_SHIFT)+offs,\n\t\t   rec_len, ufs_get_de_namlen(sb, p));\n\tgoto fail;\nEend:\n\tp = (struct ufs_dir_entry *)(kaddr + offs);\n\tufs_error(sb, __func__,\n\t\t   \"entry in directory #%lu spans the page boundary\"\n\t\t   \"offset=%lu\",\n\t\t   dir->i_ino, (page->index<<PAGE_SHIFT)+offs);\nfail:\n\tSetPageError(page);\n\treturn false;\n}\n\nstatic struct page *ufs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (unlikely(!PageChecked(page))) {\n\t\t\tif (!ufs_check_page(page))\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn page;\n\nfail:\n\tufs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}\n\n \nstatic unsigned\nufs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_SHIFT;\n\tif (last_byte > PAGE_SIZE)\n\t\tlast_byte = PAGE_SIZE;\n\treturn last_byte;\n}\n\nstatic inline struct ufs_dir_entry *\nufs_next_entry(struct super_block *sb, struct ufs_dir_entry *p)\n{\n\treturn (struct ufs_dir_entry *)((char *)p +\n\t\t\t\t\tfs16_to_cpu(sb, p->d_reclen));\n}\n\nstruct ufs_dir_entry *ufs_dotdot(struct inode *dir, struct page **p)\n{\n\tstruct page *page = ufs_get_page(dir, 0);\n\tstruct ufs_dir_entry *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = ufs_next_entry(dir->i_sb,\n\t\t\t\t    (struct ufs_dir_entry *)page_address(page));\n\t\t*p = page;\n\t}\n\treturn de;\n}\n\n \nstruct ufs_dir_entry *ufs_find_entry(struct inode *dir, const struct qstr *qstr,\n\t\t\t\t     struct page **res_page)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tconst unsigned char *name = qstr->name;\n\tint namelen = qstr->len;\n\tunsigned reclen = UFS_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct ufs_inode_info *ui = UFS_I(dir);\n\tstruct ufs_dir_entry *de;\n\n\tUFSD(\"ENTER, dir_ino %lu, name %s, namlen %u\\n\", dir->i_ino, name, namelen);\n\n\tif (npages == 0 || namelen > UFS_MAXNAMLEN)\n\t\tgoto out;\n\n\t \n\t*res_page = NULL;\n\n\tstart = ui->i_dir_start_lookup;\n\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = ufs_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = page_address(page);\n\t\t\tde = (struct ufs_dir_entry *) kaddr;\n\t\t\tkaddr += ufs_last_byte(dir, n) - reclen;\n\t\t\twhile ((char *) de <= kaddr) {\n\t\t\t\tif (ufs_match(sb, namelen, name, de))\n\t\t\t\t\tgoto found;\n\t\t\t\tde = ufs_next_entry(sb, de);\n\t\t\t}\n\t\t\tufs_put_page(page);\n\t\t}\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\nout:\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\tui->i_dir_start_lookup = n;\n\treturn de;\n}\n\n \nint ufs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = d_inode(dentry->d_parent);\n\tconst unsigned char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct super_block *sb = dir->i_sb;\n\tunsigned reclen = UFS_DIR_REC_LEN(namelen);\n\tconst unsigned int chunk_size = UFS_SB(sb)->s_uspi->s_dirblksize;\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\tstruct ufs_dir_entry *de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\tUFSD(\"ENTER, name %s, namelen %u\\n\", name, namelen);\n\n\t \n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = ufs_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + ufs_last_byte(dir, n);\n\t\tde = (struct ufs_dir_entry *)kaddr;\n\t\tkaddr += PAGE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t \n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->d_reclen = cpu_to_fs16(sb, chunk_size);\n\t\t\t\tde->d_ino = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->d_reclen == 0) {\n\t\t\t\tufs_error(dir->i_sb, __func__,\n\t\t\t\t\t  \"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (ufs_match(sb, namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = UFS_DIR_REC_LEN(ufs_get_de_namlen(sb, de));\n\t\t\trec_len = fs16_to_cpu(sb, de->d_reclen);\n\t\t\tif (!de->d_ino && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (struct ufs_dir_entry *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\tufs_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t\t(char*)de - (char*)page_address(page);\n\terr = ufs_prepare_chunk(page, pos, rec_len);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->d_ino) {\n\t\tstruct ufs_dir_entry *de1 =\n\t\t\t(struct ufs_dir_entry *) ((char *) de + name_len);\n\t\tde1->d_reclen = cpu_to_fs16(sb, rec_len - name_len);\n\t\tde->d_reclen = cpu_to_fs16(sb, name_len);\n\n\t\tde = de1;\n\t}\n\n\tufs_set_de_namlen(sb, de, namelen);\n\tmemcpy(de->d_name, name, namelen + 1);\n\tde->d_ino = cpu_to_fs32(sb, inode->i_ino);\n\tufs_set_de_type(sb, de, inode->i_mode);\n\n\tufs_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\n\tmark_inode_dirty(dir);\n\terr = ufs_handle_dirsync(dir);\n\t \nout_put:\n\tufs_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}\n\nstatic inline unsigned\nufs_validate_entry(struct super_block *sb, char *base,\n\t\t   unsigned offset, unsigned mask)\n{\n\tstruct ufs_dir_entry *de = (struct ufs_dir_entry*)(base + offset);\n\tstruct ufs_dir_entry *p = (struct ufs_dir_entry*)(base + (offset&mask));\n\twhile ((char*)p < (char*)de)\n\t\tp = ufs_next_entry(sb, p);\n\treturn (char *)p - base;\n}\n\n\n \nstatic int\nufs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tloff_t pos = ctx->pos;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned int offset = pos & ~PAGE_MASK;\n\tunsigned long n = pos >> PAGE_SHIFT;\n\tunsigned long npages = dir_pages(inode);\n\tunsigned chunk_mask = ~(UFS_SB(sb)->s_uspi->s_dirblksize - 1);\n\tbool need_revalidate = !inode_eq_iversion(inode, file->f_version);\n\tunsigned flags = UFS_SB(sb)->s_flags;\n\n\tUFSD(\"BEGIN\\n\");\n\n\tif (pos > inode->i_size - UFS_DIR_REC_LEN(1))\n\t\treturn 0;\n\n\tfor ( ; n < npages; n++, offset = 0) {\n\t\tchar *kaddr, *limit;\n\t\tstruct ufs_dir_entry *de;\n\n\t\tstruct page *page = ufs_get_page(inode, n);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tufs_error(sb, __func__,\n\t\t\t\t  \"bad page in #%lu\",\n\t\t\t\t  inode->i_ino);\n\t\t\tctx->pos += PAGE_SIZE - offset;\n\t\t\treturn -EIO;\n\t\t}\n\t\tkaddr = page_address(page);\n\t\tif (unlikely(need_revalidate)) {\n\t\t\tif (offset) {\n\t\t\t\toffset = ufs_validate_entry(sb, kaddr, offset, chunk_mask);\n\t\t\t\tctx->pos = (n<<PAGE_SHIFT) + offset;\n\t\t\t}\n\t\t\tfile->f_version = inode_query_iversion(inode);\n\t\t\tneed_revalidate = false;\n\t\t}\n\t\tde = (struct ufs_dir_entry *)(kaddr+offset);\n\t\tlimit = kaddr + ufs_last_byte(inode, n) - UFS_DIR_REC_LEN(1);\n\t\tfor ( ;(char*)de <= limit; de = ufs_next_entry(sb, de)) {\n\t\t\tif (de->d_ino) {\n\t\t\t\tunsigned char d_type = DT_UNKNOWN;\n\n\t\t\t\tUFSD(\"filldir(%s,%u)\\n\", de->d_name,\n\t\t\t\t      fs32_to_cpu(sb, de->d_ino));\n\t\t\t\tUFSD(\"namlen %u\\n\", ufs_get_de_namlen(sb, de));\n\n\t\t\t\tif ((flags & UFS_DE_MASK) == UFS_DE_44BSD)\n\t\t\t\t\td_type = de->d_u.d_44.d_type;\n\n\t\t\t\tif (!dir_emit(ctx, de->d_name,\n\t\t\t\t\t       ufs_get_de_namlen(sb, de),\n\t\t\t\t\t       fs32_to_cpu(sb, de->d_ino),\n\t\t\t\t\t       d_type)) {\n\t\t\t\t\tufs_put_page(page);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->pos += fs16_to_cpu(sb, de->d_reclen);\n\t\t}\n\t\tufs_put_page(page);\n\t}\n\treturn 0;\n}\n\n\n \nint ufs_delete_entry(struct inode *inode, struct ufs_dir_entry *dir,\n\t\t     struct page * page)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tchar *kaddr = page_address(page);\n\tunsigned from = ((char*)dir - kaddr) & ~(UFS_SB(sb)->s_uspi->s_dirblksize - 1);\n\tunsigned to = ((char*)dir - kaddr) + fs16_to_cpu(sb, dir->d_reclen);\n\tloff_t pos;\n\tstruct ufs_dir_entry *pde = NULL;\n\tstruct ufs_dir_entry *de = (struct ufs_dir_entry *) (kaddr + from);\n\tint err;\n\n\tUFSD(\"ENTER\\n\");\n\n\tUFSD(\"ino %u, reclen %u, namlen %u, name %s\\n\",\n\t      fs32_to_cpu(sb, de->d_ino),\n\t      fs16_to_cpu(sb, de->d_reclen),\n\t      ufs_get_de_namlen(sb, de), de->d_name);\n\n\twhile ((char*)de < (char*)dir) {\n\t\tif (de->d_reclen == 0) {\n\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t  \"zero-length directory entry\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpde = de;\n\t\tde = ufs_next_entry(sb, de);\n\t}\n\tif (pde)\n\t\tfrom = (char*)pde - (char*)page_address(page);\n\n\tpos = page_offset(page) + from;\n\tlock_page(page);\n\terr = ufs_prepare_chunk(page, pos, to - from);\n\tBUG_ON(err);\n\tif (pde)\n\t\tpde->d_reclen = cpu_to_fs16(sb, to - from);\n\tdir->d_ino = 0;\n\tufs_commit_chunk(page, pos, to - from);\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n\terr = ufs_handle_dirsync(inode);\nout:\n\tufs_put_page(page);\n\tUFSD(\"EXIT\\n\");\n\treturn err;\n}\n\nint ufs_make_empty(struct inode * inode, struct inode *dir)\n{\n\tstruct super_block * sb = dir->i_sb;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page = grab_cache_page(mapping, 0);\n\tconst unsigned int chunk_size = UFS_SB(sb)->s_uspi->s_dirblksize;\n\tstruct ufs_dir_entry * de;\n\tchar *base;\n\tint err;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = ufs_prepare_chunk(page, 0, chunk_size);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\n\tkmap(page);\n\tbase = (char*)page_address(page);\n\tmemset(base, 0, PAGE_SIZE);\n\n\tde = (struct ufs_dir_entry *) base;\n\n\tde->d_ino = cpu_to_fs32(sb, inode->i_ino);\n\tufs_set_de_type(sb, de, inode->i_mode);\n\tufs_set_de_namlen(sb, de, 1);\n\tde->d_reclen = cpu_to_fs16(sb, UFS_DIR_REC_LEN(1));\n\tstrcpy (de->d_name, \".\");\n\tde = (struct ufs_dir_entry *)\n\t\t((char *)de + fs16_to_cpu(sb, de->d_reclen));\n\tde->d_ino = cpu_to_fs32(sb, dir->i_ino);\n\tufs_set_de_type(sb, de, dir->i_mode);\n\tde->d_reclen = cpu_to_fs16(sb, chunk_size - UFS_DIR_REC_LEN(1));\n\tufs_set_de_namlen(sb, de, 2);\n\tstrcpy (de->d_name, \"..\");\n\tkunmap(page);\n\n\tufs_commit_chunk(page, 0, chunk_size);\n\terr = ufs_handle_dirsync(inode);\nfail:\n\tput_page(page);\n\treturn err;\n}\n\n \nint ufs_empty_dir(struct inode * inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *kaddr;\n\t\tstruct ufs_dir_entry *de;\n\t\tpage = ufs_get_page(inode, i);\n\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = page_address(page);\n\t\tde = (struct ufs_dir_entry *)kaddr;\n\t\tkaddr += ufs_last_byte(inode, i) - UFS_DIR_REC_LEN(1);\n\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (de->d_reclen == 0) {\n\t\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry: \"\n\t\t\t\t\t\"kaddr=%p, de=%p\\n\", kaddr, de);\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->d_ino) {\n\t\t\t\tu16 namelen=ufs_get_de_namlen(sb, de);\n\t\t\t\t \n\t\t\t\tif (de->d_name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (namelen > 2)\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (namelen < 2) {\n\t\t\t\t\tif (inode->i_ino !=\n\t\t\t\t\t    fs32_to_cpu(sb, de->d_ino))\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (de->d_name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tde = ufs_next_entry(sb, de);\n\t\t}\n\t\tufs_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tufs_put_page(page);\n\treturn 0;\n}\n\nconst struct file_operations ufs_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= ufs_readdir,\n\t.fsync\t\t= generic_file_fsync,\n\t.llseek\t\t= generic_file_llseek,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}