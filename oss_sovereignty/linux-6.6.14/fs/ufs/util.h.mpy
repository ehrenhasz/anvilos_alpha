{
  "module_name": "util.h",
  "hash_id": "fa626ef8ff777734e4571987b322023d463f3147ad1d674afd65568860829409",
  "original_prompt": "Ingested from linux-6.6.14/fs/ufs/util.h",
  "human_readable_source": " \n \n\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include \"swab.h\"\n\n \nstatic inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}\nstatic inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}\n\n\n\n \nstatic inline s32\nufs_get_fs_state(struct super_block *sb, struct ufs_super_block_first *usb1,\n\t\t struct ufs_super_block_third *usb3)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNOS:\n\t\tif (fs32_to_cpu(sb, usb3->fs_postblformat) == UFS_42POSTBLFMT)\n\t\t\treturn fs32_to_cpu(sb, usb1->fs_u0.fs_sun.fs_state);\n\t\tfallthrough;\t \n\tcase UFS_ST_SUN:\n\t\treturn fs32_to_cpu(sb, usb3->fs_un2.fs_sun.fs_state);\n\tcase UFS_ST_SUNx86:\n\t\treturn fs32_to_cpu(sb, usb1->fs_u1.fs_sunx86.fs_state);\n\tcase UFS_ST_44BSD:\n\tdefault:\n\t\treturn fs32_to_cpu(sb, usb3->fs_un2.fs_44.fs_state);\n\t}\n}\n\nstatic inline void\nufs_set_fs_state(struct super_block *sb, struct ufs_super_block_first *usb1,\n\t\t struct ufs_super_block_third *usb3, s32 value)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNOS:\n\t\tif (fs32_to_cpu(sb, usb3->fs_postblformat) == UFS_42POSTBLFMT) {\n\t\t\tusb1->fs_u0.fs_sun.fs_state = cpu_to_fs32(sb, value);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\t \n\tcase UFS_ST_SUN:\n\t\tusb3->fs_un2.fs_sun.fs_state = cpu_to_fs32(sb, value);\n\t\tbreak;\n\tcase UFS_ST_SUNx86:\n\t\tusb1->fs_u1.fs_sunx86.fs_state = cpu_to_fs32(sb, value);\n\t\tbreak;\n\tcase UFS_ST_44BSD:\n\t\tusb3->fs_un2.fs_44.fs_state = cpu_to_fs32(sb, value);\n\t\tbreak;\n\t}\n}\n\nstatic inline u32\nufs_get_fs_npsect(struct super_block *sb, struct ufs_super_block_first *usb1,\n\t\t  struct ufs_super_block_third *usb3)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_ST_MASK) == UFS_ST_SUNx86)\n\t\treturn fs32_to_cpu(sb, usb3->fs_un2.fs_sunx86.fs_npsect);\n\telse\n\t\treturn fs32_to_cpu(sb, usb1->fs_u1.fs_sun.fs_npsect);\n}\n\nstatic inline u64\nufs_get_fs_qbmask(struct super_block *sb, struct ufs_super_block_third *usb3)\n{\n\t__fs64 tmp;\n\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNOS:\n\tcase UFS_ST_SUN:\n\t\t((__fs32 *)&tmp)[0] = usb3->fs_un2.fs_sun.fs_qbmask[0];\n\t\t((__fs32 *)&tmp)[1] = usb3->fs_un2.fs_sun.fs_qbmask[1];\n\t\tbreak;\n\tcase UFS_ST_SUNx86:\n\t\t((__fs32 *)&tmp)[0] = usb3->fs_un2.fs_sunx86.fs_qbmask[0];\n\t\t((__fs32 *)&tmp)[1] = usb3->fs_un2.fs_sunx86.fs_qbmask[1];\n\t\tbreak;\n\tcase UFS_ST_44BSD:\n\t\t((__fs32 *)&tmp)[0] = usb3->fs_un2.fs_44.fs_qbmask[0];\n\t\t((__fs32 *)&tmp)[1] = usb3->fs_un2.fs_44.fs_qbmask[1];\n\t\tbreak;\n\t}\n\n\treturn fs64_to_cpu(sb, tmp);\n}\n\nstatic inline u64\nufs_get_fs_qfmask(struct super_block *sb, struct ufs_super_block_third *usb3)\n{\n\t__fs64 tmp;\n\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNOS:\n\tcase UFS_ST_SUN:\n\t\t((__fs32 *)&tmp)[0] = usb3->fs_un2.fs_sun.fs_qfmask[0];\n\t\t((__fs32 *)&tmp)[1] = usb3->fs_un2.fs_sun.fs_qfmask[1];\n\t\tbreak;\n\tcase UFS_ST_SUNx86:\n\t\t((__fs32 *)&tmp)[0] = usb3->fs_un2.fs_sunx86.fs_qfmask[0];\n\t\t((__fs32 *)&tmp)[1] = usb3->fs_un2.fs_sunx86.fs_qfmask[1];\n\t\tbreak;\n\tcase UFS_ST_44BSD:\n\t\t((__fs32 *)&tmp)[0] = usb3->fs_un2.fs_44.fs_qfmask[0];\n\t\t((__fs32 *)&tmp)[1] = usb3->fs_un2.fs_44.fs_qfmask[1];\n\t\tbreak;\n\t}\n\n\treturn fs64_to_cpu(sb, tmp);\n}\n\nstatic inline u16\nufs_get_de_namlen(struct super_block *sb, struct ufs_dir_entry *de)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) == UFS_DE_OLD)\n\t\treturn fs16_to_cpu(sb, de->d_u.d_namlen);\n\telse\n\t\treturn de->d_u.d_44.d_namlen;  \n}\n\nstatic inline void\nufs_set_de_namlen(struct super_block *sb, struct ufs_dir_entry *de, u16 value)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) == UFS_DE_OLD)\n\t\tde->d_u.d_namlen = cpu_to_fs16(sb, value);\n\telse\n\t\tde->d_u.d_44.d_namlen = value;  \n}\n\nstatic inline void\nufs_set_de_type(struct super_block *sb, struct ufs_dir_entry *de, int mode)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) != UFS_DE_44BSD)\n\t\treturn;\n\n\t \n\tswitch (mode & S_IFMT) {\n\tcase S_IFSOCK:\n\t\tde->d_u.d_44.d_type = DT_SOCK;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tde->d_u.d_44.d_type = DT_LNK;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tde->d_u.d_44.d_type = DT_REG;\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tde->d_u.d_44.d_type = DT_BLK;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tde->d_u.d_44.d_type = DT_DIR;\n\t\tbreak;\n\tcase S_IFCHR:\n\t\tde->d_u.d_44.d_type = DT_CHR;\n\t\tbreak;\n\tcase S_IFIFO:\n\t\tde->d_u.d_44.d_type = DT_FIFO;\n\t\tbreak;\n\tdefault:\n\t\tde->d_u.d_44.d_type = DT_UNKNOWN;\n\t}\n}\n\nstatic inline u32\nufs_get_inode_uid(struct super_block *sb, struct ufs_inode *inode)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_UID_MASK) {\n\tcase UFS_UID_44BSD:\n\t\treturn fs32_to_cpu(sb, inode->ui_u3.ui_44.ui_uid);\n\tcase UFS_UID_EFT:\n\t\tif (inode->ui_u1.oldids.ui_suid == 0xFFFF)\n\t\t\treturn fs32_to_cpu(sb, inode->ui_u3.ui_sun.ui_uid);\n\t\tfallthrough;\n\tdefault:\n\t\treturn fs16_to_cpu(sb, inode->ui_u1.oldids.ui_suid);\n\t}\n}\n\nstatic inline void\nufs_set_inode_uid(struct super_block *sb, struct ufs_inode *inode, u32 value)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_UID_MASK) {\n\tcase UFS_UID_44BSD:\n\t\tinode->ui_u3.ui_44.ui_uid = cpu_to_fs32(sb, value);\n\t\tinode->ui_u1.oldids.ui_suid = cpu_to_fs16(sb, value);\n\t\tbreak;\n\tcase UFS_UID_EFT:\n\t\tinode->ui_u3.ui_sun.ui_uid = cpu_to_fs32(sb, value);\n\t\tif (value > 0xFFFF)\n\t\t\tvalue = 0xFFFF;\n\t\tfallthrough;\n\tdefault:\n\t\tinode->ui_u1.oldids.ui_suid = cpu_to_fs16(sb, value);\n\t\tbreak;\n\t}\n}\n\nstatic inline u32\nufs_get_inode_gid(struct super_block *sb, struct ufs_inode *inode)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_UID_MASK) {\n\tcase UFS_UID_44BSD:\n\t\treturn fs32_to_cpu(sb, inode->ui_u3.ui_44.ui_gid);\n\tcase UFS_UID_EFT:\n\t\tif (inode->ui_u1.oldids.ui_sgid == 0xFFFF)\n\t\t\treturn fs32_to_cpu(sb, inode->ui_u3.ui_sun.ui_gid);\n\t\tfallthrough;\n\tdefault:\n\t\treturn fs16_to_cpu(sb, inode->ui_u1.oldids.ui_sgid);\n\t}\n}\n\nstatic inline void\nufs_set_inode_gid(struct super_block *sb, struct ufs_inode *inode, u32 value)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_UID_MASK) {\n\tcase UFS_UID_44BSD:\n\t\tinode->ui_u3.ui_44.ui_gid = cpu_to_fs32(sb, value);\n\t\tinode->ui_u1.oldids.ui_sgid =  cpu_to_fs16(sb, value);\n\t\tbreak;\n\tcase UFS_UID_EFT:\n\t\tinode->ui_u3.ui_sun.ui_gid = cpu_to_fs32(sb, value);\n\t\tif (value > 0xFFFF)\n\t\t\tvalue = 0xFFFF;\n\t\tfallthrough;\n\tdefault:\n\t\tinode->ui_u1.oldids.ui_sgid =  cpu_to_fs16(sb, value);\n\t\tbreak;\n\t}\n}\n\nextern dev_t ufs_get_inode_dev(struct super_block *, struct ufs_inode_info *);\nextern void ufs_set_inode_dev(struct super_block *, struct ufs_inode_info *, dev_t);\nextern int ufs_prepare_chunk(struct page *page, loff_t pos, unsigned len);\n\n \n#define ubh_bread(sb,fragment,size) _ubh_bread_(uspi,sb,fragment,size)  \nextern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);\nextern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\n#define ubh_ubhcpymem(mem,ubh,size) _ubh_ubhcpymem_(uspi,mem,ubh,size)\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\n#define ubh_memcpyubh(ubh,mem,size) _ubh_memcpyubh_(uspi,ubh,mem,size)\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\n \nextern struct page *ufs_get_locked_page(struct address_space *mapping,\n\t\t\t\t\tpgoff_t index);\nstatic inline void ufs_put_locked_page(struct page *page)\n{\n       unlock_page(page);\n       put_page(page);\n}\n\n\n \n\nstatic inline void *get_usb_offset(struct ufs_sb_private_info *uspi,\n\t\t\t\t   unsigned int offset)\n{\n\tunsigned int index;\n\t\n\tindex = offset >> uspi->s_fshift;\n\toffset &= ~uspi->s_fmask;\n\treturn uspi->s_ubh.bh[index]->b_data + offset;\n}\n\n#define ubh_get_usb_first(uspi) \\\n\t((struct ufs_super_block_first *)get_usb_offset((uspi), 0))\n\n#define ubh_get_usb_second(uspi) \\\n\t((struct ufs_super_block_second *)get_usb_offset((uspi), UFS_SECTOR_SIZE))\n\n#define ubh_get_usb_third(uspi)\t\\\n\t((struct ufs_super_block_third *)get_usb_offset((uspi), 2*UFS_SECTOR_SIZE))\n\n\n#define ubh_get_ucg(ubh) \\\n\t((struct ufs_cylinder_group *)((ubh)->bh[0]->b_data))\n\n\n \n#define ubh_get_addr8(ubh,begin) \\\n\t((u8*)(ubh)->bh[(begin) >> uspi->s_fshift]->b_data + \\\n\t((begin) & ~uspi->s_fmask))\n\n#define ubh_get_addr16(ubh,begin) \\\n\t(((__fs16*)((ubh)->bh[(begin) >> (uspi->s_fshift-1)]->b_data)) + \\\n\t((begin) & ((uspi->fsize>>1) - 1)))\n\n#define ubh_get_addr32(ubh,begin) \\\n\t(((__fs32*)((ubh)->bh[(begin) >> (uspi->s_fshift-2)]->b_data)) + \\\n\t((begin) & ((uspi->s_fsize>>2) - 1)))\n\n#define ubh_get_addr64(ubh,begin) \\\n\t(((__fs64*)((ubh)->bh[(begin) >> (uspi->s_fshift-3)]->b_data)) + \\\n\t((begin) & ((uspi->s_fsize>>3) - 1)))\n\n#define ubh_get_addr ubh_get_addr8\n\nstatic inline void *ubh_get_data_ptr(struct ufs_sb_private_info *uspi,\n\t\t\t\t     struct ufs_buffer_head *ubh,\n\t\t\t\t     u64 blk)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\treturn ubh_get_addr64(ubh, blk);\n\telse\n\t\treturn ubh_get_addr32(ubh, blk);\n}\n\n#define ubh_blkmap(ubh,begin,bit) \\\n\t((*ubh_get_addr(ubh, (begin) + ((bit) >> 3)) >> ((bit) & 7)) & (0xff >> (UFS_MAXFRAG - uspi->s_fpb)))\n\nstatic inline u64\nufs_freefrags(struct ufs_sb_private_info *uspi)\n{\n\treturn ufs_blkstofrags(uspi->cs_total.cs_nbfree) +\n\t\tuspi->cs_total.cs_nffree;\n}\n\n \n#define ubh_cg_blktot(ucpi,cylno) \\\n\t(*((__fs32*)ubh_get_addr(UCPI_UBH(ucpi), (ucpi)->c_btotoff + ((cylno) << 2))))\n\n#define ubh_cg_blks(ucpi,cylno,rpos) \\\n\t(*((__fs16*)ubh_get_addr(UCPI_UBH(ucpi), \\\n\t(ucpi)->c_boff + (((cylno) * uspi->s_nrpos + (rpos)) << 1 ))))\n\n \n#define ubh_setbit(ubh,begin,bit) \\\n\t(*ubh_get_addr(ubh, (begin) + ((bit) >> 3)) |= (1 << ((bit) & 7)))\n\n#define ubh_clrbit(ubh,begin,bit) \\\n\t(*ubh_get_addr (ubh, (begin) + ((bit) >> 3)) &= ~(1 << ((bit) & 7)))\n\n#define ubh_isset(ubh,begin,bit) \\\n\t(*ubh_get_addr (ubh, (begin) + ((bit) >> 3)) & (1 << ((bit) & 7)))\n\n#define ubh_isclr(ubh,begin,bit) (!ubh_isset(ubh,begin,bit))\n\n#define ubh_find_first_zero_bit(ubh,begin,size) _ubh_find_next_zero_bit_(uspi,ubh,begin,size,0)\n\n#define ubh_find_next_zero_bit(ubh,begin,size,offset) _ubh_find_next_zero_bit_(uspi,ubh,begin,size,offset)\nstatic inline unsigned _ubh_find_next_zero_bit_(\n\tstruct ufs_sb_private_info * uspi, struct ufs_buffer_head * ubh,\n\tunsigned begin, unsigned size, unsigned offset)\n{\n\tunsigned base, count, pos;\n\n\tsize -= offset;\n\tbegin <<= 3;\n\toffset += begin;\n\tbase = offset >> uspi->s_bpfshift;\n\toffset &= uspi->s_bpfmask;\n\tfor (;;) {\n\t\tcount = min_t(unsigned int, size + offset, uspi->s_bpf);\n\t\tsize -= count - offset;\n\t\tpos = find_next_zero_bit_le(ubh->bh[base]->b_data, count, offset);\n\t\tif (pos < count || !size)\n\t\t\tbreak;\n\t\tbase++;\n\t\toffset = 0;\n\t}\n\treturn (base << uspi->s_bpfshift) + pos - begin;\n} \t\n\nstatic inline unsigned find_last_zero_bit (unsigned char * bitmap,\n\tunsigned size, unsigned offset)\n{\n\tunsigned bit, i;\n\tunsigned char * mapp;\n\tunsigned char map;\n\n\tmapp = bitmap + (size >> 3);\n\tmap = *mapp--;\n\tbit = 1 << (size & 7);\n\tfor (i = size; i > offset; i--) {\n\t\tif ((map & bit) == 0)\n\t\t\tbreak;\n\t\tif ((i & 7) != 0) {\n\t\t\tbit >>= 1;\n\t\t} else {\n\t\t\tmap = *mapp--;\n\t\t\tbit = 1 << 7;\n\t\t}\n\t}\n\treturn i;\n}\n\n#define ubh_find_last_zero_bit(ubh,begin,size,offset) _ubh_find_last_zero_bit_(uspi,ubh,begin,size,offset)\nstatic inline unsigned _ubh_find_last_zero_bit_(\n\tstruct ufs_sb_private_info * uspi, struct ufs_buffer_head * ubh,\n\tunsigned begin, unsigned start, unsigned end)\n{\n\tunsigned base, count, pos, size;\n\n\tsize = start - end;\n\tbegin <<= 3;\n\tstart += begin;\n\tbase = start >> uspi->s_bpfshift;\n\tstart &= uspi->s_bpfmask;\n\tfor (;;) {\n\t\tcount = min_t(unsigned int,\n\t\t\t    size + (uspi->s_bpf - start), uspi->s_bpf)\n\t\t\t- (uspi->s_bpf - start);\n\t\tsize -= count;\n\t\tpos = find_last_zero_bit (ubh->bh[base]->b_data,\n\t\t\tstart, start - count);\n\t\tif (pos > start - count || !size)\n\t\t\tbreak;\n\t\tbase--;\n\t\tstart = uspi->s_bpf;\n\t}\n\treturn (base << uspi->s_bpfshift) + pos - begin;\n} \t\n\n#define ubh_isblockclear(ubh,begin,block) (!_ubh_isblockset_(uspi,ubh,begin,block))\n\n#define ubh_isblockset(ubh,begin,block) _ubh_isblockset_(uspi,ubh,begin,block)\nstatic inline int _ubh_isblockset_(struct ufs_sb_private_info * uspi,\n\tstruct ufs_buffer_head * ubh, unsigned begin, unsigned block)\n{\n\tu8 mask;\n\tswitch (uspi->s_fpb) {\n\tcase 8:\n\t    \treturn (*ubh_get_addr (ubh, begin + block) == 0xff);\n\tcase 4:\n\t\tmask = 0x0f << ((block & 0x01) << 2);\n\t\treturn (*ubh_get_addr (ubh, begin + (block >> 1)) & mask) == mask;\n\tcase 2:\n\t\tmask = 0x03 << ((block & 0x03) << 1);\n\t\treturn (*ubh_get_addr (ubh, begin + (block >> 2)) & mask) == mask;\n\tcase 1:\n\t\tmask = 0x01 << (block & 0x07);\n\t\treturn (*ubh_get_addr (ubh, begin + (block >> 3)) & mask) == mask;\n\t}\n\treturn 0;\t\n}\n\n#define ubh_clrblock(ubh,begin,block) _ubh_clrblock_(uspi,ubh,begin,block)\nstatic inline void _ubh_clrblock_(struct ufs_sb_private_info * uspi,\n\tstruct ufs_buffer_head * ubh, unsigned begin, unsigned block)\n{\n\tswitch (uspi->s_fpb) {\n\tcase 8:\n\t    \t*ubh_get_addr (ubh, begin + block) = 0x00;\n\t    \treturn; \n\tcase 4:\n\t\t*ubh_get_addr (ubh, begin + (block >> 1)) &= ~(0x0f << ((block & 0x01) << 2));\n\t\treturn;\n\tcase 2:\n\t\t*ubh_get_addr (ubh, begin + (block >> 2)) &= ~(0x03 << ((block & 0x03) << 1));\n\t\treturn;\n\tcase 1:\n\t\t*ubh_get_addr (ubh, begin + (block >> 3)) &= ~(0x01 << ((block & 0x07)));\n\t\treturn;\n\t}\n}\n\n#define ubh_setblock(ubh,begin,block) _ubh_setblock_(uspi,ubh,begin,block)\nstatic inline void _ubh_setblock_(struct ufs_sb_private_info * uspi,\n\tstruct ufs_buffer_head * ubh, unsigned begin, unsigned block)\n{\n\tswitch (uspi->s_fpb) {\n\tcase 8:\n\t    \t*ubh_get_addr(ubh, begin + block) = 0xff;\n\t    \treturn;\n\tcase 4:\n\t\t*ubh_get_addr(ubh, begin + (block >> 1)) |= (0x0f << ((block & 0x01) << 2));\n\t\treturn;\n\tcase 2:\n\t\t*ubh_get_addr(ubh, begin + (block >> 2)) |= (0x03 << ((block & 0x03) << 1));\n\t\treturn;\n\tcase 1:\n\t\t*ubh_get_addr(ubh, begin + (block >> 3)) |= (0x01 << ((block & 0x07)));\n\t\treturn;\n\t}\n}\n\nstatic inline void ufs_fragacct (struct super_block * sb, unsigned blockmap,\n\t__fs32 * fraglist, int cnt)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tunsigned fragsize, pos;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tfragsize = 0;\n\tfor (pos = 0; pos < uspi->s_fpb; pos++) {\n\t\tif (blockmap & (1 << pos)) {\n\t\t\tfragsize++;\n\t\t}\n\t\telse if (fragsize > 0) {\n\t\t\tfs32_add(sb, &fraglist[fragsize], cnt);\n\t\t\tfragsize = 0;\n\t\t}\n\t}\n\tif (fragsize > 0 && fragsize < uspi->s_fpb)\n\t\tfs32_add(sb, &fraglist[fragsize], cnt);\n}\n\nstatic inline void *ufs_get_direct_data_ptr(struct ufs_sb_private_info *uspi,\n\t\t\t\t\t    struct ufs_inode_info *ufsi,\n\t\t\t\t\t    unsigned blk)\n{\n\tBUG_ON(blk > UFS_TIND_BLOCK);\n\treturn uspi->fs_magic == UFS2_MAGIC ?\n\t\t(void *)&ufsi->i_u1.u2_i_data[blk] :\n\t\t(void *)&ufsi->i_u1.i_data[blk];\n}\n\nstatic inline u64 ufs_data_ptr_to_cpu(struct super_block *sb, void *p)\n{\n\treturn UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC ?\n\t\tfs64_to_cpu(sb, *(__fs64 *)p) :\n\t\tfs32_to_cpu(sb, *(__fs32 *)p);\n}\n\nstatic inline void ufs_cpu_to_data_ptr(struct super_block *sb, void *p, u64 val)\n{\n\tif (UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC)\n\t\t*(__fs64 *)p = cpu_to_fs64(sb, val);\n\telse\n\t\t*(__fs32 *)p = cpu_to_fs32(sb, val);\n}\n\nstatic inline void ufs_data_ptr_clear(struct ufs_sb_private_info *uspi,\n\t\t\t\t      void *p)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\t*(__fs64 *)p = 0;\n\telse\n\t\t*(__fs32 *)p = 0;\n}\n\nstatic inline int ufs_is_data_ptr_zero(struct ufs_sb_private_info *uspi,\n\t\t\t\t       void *p)\n{\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\treturn *(__fs64 *)p == 0;\n\telse\n\t\treturn *(__fs32 *)p == 0;\n}\n\nstatic inline __fs32 ufs_get_seconds(struct super_block *sbp)\n{\n\ttime64_t now = ktime_get_real_seconds();\n\n\t \n\treturn cpu_to_fs32(sbp, lower_32_bits(now));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}