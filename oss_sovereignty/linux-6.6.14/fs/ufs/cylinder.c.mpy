{
  "module_name": "cylinder.c",
  "hash_id": "9c1e112acdf2b7fa609a71dc7bbdac0b342b8be8ed3391d3ca1e179f009d8dcb",
  "original_prompt": "Ingested from linux-6.6.14/fs/ufs/cylinder.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/bitops.h>\n\n#include <asm/byteorder.h>\n\n#include \"ufs_fs.h\"\n#include \"ufs.h\"\n#include \"swab.h\"\n#include \"util.h\"\n\n \nstatic void ufs_read_cylinder (struct super_block * sb,\n\tunsigned cgno, unsigned bitmap_nr)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned i, j;\n\n\tUFSD(\"ENTER, cgno %u, bitmap_nr %u\\n\", cgno, bitmap_nr);\n\tuspi = sbi->s_uspi;\n\tucpi = sbi->s_ucpi[bitmap_nr];\n\tucg = (struct ufs_cylinder_group *)sbi->s_ucg[cgno]->b_data;\n\n\tUCPI_UBH(ucpi)->fragment = ufs_cgcmin(cgno);\n\tUCPI_UBH(ucpi)->count = uspi->s_cgsize >> sb->s_blocksize_bits;\n\t \n\tUCPI_UBH(ucpi)->bh[0] = sbi->s_ucg[cgno];\n\tfor (i = 1; i < UCPI_UBH(ucpi)->count; i++)\n\t\tif (!(UCPI_UBH(ucpi)->bh[i] = sb_bread(sb, UCPI_UBH(ucpi)->fragment + i)))\n\t\t\tgoto failed;\n\tsbi->s_cgno[bitmap_nr] = cgno;\n\t\t\t\n\tucpi->c_cgx\t= fs32_to_cpu(sb, ucg->cg_cgx);\n\tucpi->c_ncyl\t= fs16_to_cpu(sb, ucg->cg_ncyl);\n\tucpi->c_niblk\t= fs16_to_cpu(sb, ucg->cg_niblk);\n\tucpi->c_ndblk\t= fs32_to_cpu(sb, ucg->cg_ndblk);\n\tucpi->c_rotor\t= fs32_to_cpu(sb, ucg->cg_rotor);\n\tucpi->c_frotor\t= fs32_to_cpu(sb, ucg->cg_frotor);\n\tucpi->c_irotor\t= fs32_to_cpu(sb, ucg->cg_irotor);\n\tucpi->c_btotoff\t= fs32_to_cpu(sb, ucg->cg_btotoff);\n\tucpi->c_boff\t= fs32_to_cpu(sb, ucg->cg_boff);\n\tucpi->c_iusedoff = fs32_to_cpu(sb, ucg->cg_iusedoff);\n\tucpi->c_freeoff\t= fs32_to_cpu(sb, ucg->cg_freeoff);\n\tucpi->c_nextfreeoff = fs32_to_cpu(sb, ucg->cg_nextfreeoff);\n\tucpi->c_clustersumoff = fs32_to_cpu(sb, ucg->cg_u.cg_44.cg_clustersumoff);\n\tucpi->c_clusteroff = fs32_to_cpu(sb, ucg->cg_u.cg_44.cg_clusteroff);\n\tucpi->c_nclusterblks = fs32_to_cpu(sb, ucg->cg_u.cg_44.cg_nclusterblks);\n\tUFSD(\"EXIT\\n\");\n\treturn;\t\n\t\nfailed:\n\tfor (j = 1; j < i; j++)\n\t\tbrelse (sbi->s_ucg[j]);\n\tsbi->s_cgno[bitmap_nr] = UFS_CGNO_EMPTY;\n\tufs_error (sb, \"ufs_read_cylinder\", \"can't read cylinder group block %u\", cgno);\n}\n\n \nvoid ufs_put_cylinder (struct super_block * sb, unsigned bitmap_nr)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi; \n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned i;\n\n\tUFSD(\"ENTER, bitmap_nr %u\\n\", bitmap_nr);\n\n\tuspi = sbi->s_uspi;\n\tif (sbi->s_cgno[bitmap_nr] == UFS_CGNO_EMPTY) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn;\n\t}\n\tucpi = sbi->s_ucpi[bitmap_nr];\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\n\tif (uspi->s_ncg > UFS_MAX_GROUP_LOADED && bitmap_nr >= sbi->s_cg_loaded) {\n\t\tufs_panic (sb, \"ufs_put_cylinder\", \"internal error\");\n\t\treturn;\n\t}\n\t \n\tucg->cg_rotor = cpu_to_fs32(sb, ucpi->c_rotor);\n\tucg->cg_frotor = cpu_to_fs32(sb, ucpi->c_frotor);\n\tucg->cg_irotor = cpu_to_fs32(sb, ucpi->c_irotor);\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tfor (i = 1; i < UCPI_UBH(ucpi)->count; i++) {\n\t\tbrelse (UCPI_UBH(ucpi)->bh[i]);\n\t}\n\n\tsbi->s_cgno[bitmap_nr] = UFS_CGNO_EMPTY;\n\tUFSD(\"EXIT\\n\");\n}\n\n \nstruct ufs_cg_private_info * ufs_load_cylinder (\n\tstruct super_block * sb, unsigned cgno)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tunsigned cg, i, j;\n\n\tUFSD(\"ENTER, cgno %u\\n\", cgno);\n\n\tuspi = sbi->s_uspi;\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, high number of cg\");\n\t\treturn NULL;\n\t}\n\t \n\tif (sbi->s_cgno[0] == cgno) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn sbi->s_ucpi[0];\n\t}\n\t \n\tif (uspi->s_ncg <= UFS_MAX_GROUP_LOADED) {\n\t\tif (sbi->s_cgno[cgno] != UFS_CGNO_EMPTY) {\n\t\t\tif (sbi->s_cgno[cgno] != cgno) {\n\t\t\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, wrong number of cg in cache\");\n\t\t\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUFSD(\"EXIT\\n\");\n\t\t\t\treturn sbi->s_ucpi[cgno];\n\t\t\t}\n\t\t} else {\n\t\t\tufs_read_cylinder (sb, cgno, cgno);\n\t\t\tUFSD(\"EXIT\\n\");\n\t\t\treturn sbi->s_ucpi[cgno];\n\t\t}\n\t}\n\t \n\tfor (i = 0; i < sbi->s_cg_loaded && sbi->s_cgno[i] != cgno; i++);\n\tif (i < sbi->s_cg_loaded && sbi->s_cgno[i] == cgno) {\n\t\tcg = sbi->s_cgno[i];\n\t\tucpi = sbi->s_ucpi[i];\n\t\tfor (j = i; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_cgno[0] = cg;\n\t\tsbi->s_ucpi[0] = ucpi;\n\t \n\t} else {\n\t\tif (sbi->s_cg_loaded < UFS_MAX_GROUP_LOADED)\n\t\t\tsbi->s_cg_loaded++;\n\t\telse\n\t\t\tufs_put_cylinder (sb, UFS_MAX_GROUP_LOADED-1);\n\t\tucpi = sbi->s_ucpi[sbi->s_cg_loaded - 1];\n\t\tfor (j = sbi->s_cg_loaded - 1; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_ucpi[0] = ucpi;\n\t\tufs_read_cylinder (sb, cgno, 0);\n\t}\n\tUFSD(\"EXIT\\n\");\n\treturn sbi->s_ucpi[0];\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}