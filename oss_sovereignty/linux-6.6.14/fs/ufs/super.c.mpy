{
  "module_name": "super.c",
  "hash_id": "269ba404ee8b31143294c9e45f9aa97b52fe6c46383618148100862ca0a14666",
  "original_prompt": "Ingested from linux-6.6.14/fs/ufs/super.c",
  "human_readable_source": "\n \n\n \n \n \n\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/bitops.h>\n\n#include <linux/stdarg.h>\n\n#include <linux/uaccess.h>\n\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/vfs.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/iversion.h>\n\n#include \"ufs_fs.h\"\n#include \"ufs.h\"\n#include \"swab.h\"\n#include \"util.h\"\n\nstatic struct inode *ufs_nfs_get_inode(struct super_block *sb, u64 ino, u32 generation)\n{\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct inode *inode;\n\n\tif (ino < UFS_ROOTINO || ino > (u64)uspi->s_ncg * uspi->s_ipg)\n\t\treturn ERR_PTR(-ESTALE);\n\n\tinode = ufs_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn inode;\n}\n\nstatic struct dentry *ufs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t\t\t       int fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type, ufs_nfs_get_inode);\n}\n\nstatic struct dentry *ufs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\t\t\t       int fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type, ufs_nfs_get_inode);\n}\n\nstatic struct dentry *ufs_get_parent(struct dentry *child)\n{\n\tino_t ino;\n\n\tino = ufs_inode_by_name(d_inode(child), &dotdot_name);\n\tif (!ino)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn d_obtain_alias(ufs_iget(child->d_sb, ino));\n}\n\nstatic const struct export_operations ufs_export_ops = {\n\t.fh_to_dentry\t= ufs_fh_to_dentry,\n\t.fh_to_parent\t= ufs_fh_to_parent,\n\t.get_parent\t= ufs_get_parent,\n};\n\n#ifdef CONFIG_UFS_DEBUG\n \nstatic void ufs_print_super_stuff(struct super_block *sb,\n\t\t\t\t  struct ufs_super_block_first *usb1,\n\t\t\t\t  struct ufs_super_block_second *usb2,\n\t\t\t\t  struct ufs_super_block_third *usb3)\n{\n\tu32 magic = fs32_to_cpu(sb, usb3->fs_magic);\n\n\tpr_debug(\"ufs_print_super_stuff\\n\");\n\tpr_debug(\"  magic:     0x%x\\n\", magic);\n\tif (fs32_to_cpu(sb, usb3->fs_magic) == UFS2_MAGIC) {\n\t\tpr_debug(\"  fs_size:   %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_size));\n\t\tpr_debug(\"  fs_dsize:  %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_dsize));\n\t\tpr_debug(\"  bsize:         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_bsize));\n\t\tpr_debug(\"  fsize:         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fsize));\n\t\tpr_debug(\"  fs_volname:  %s\\n\", usb2->fs_un.fs_u2.fs_volname);\n\t\tpr_debug(\"  fs_sblockloc: %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.fs_sblockloc));\n\t\tpr_debug(\"  cs_ndir(No of dirs):  %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_ndir));\n\t\tpr_debug(\"  cs_nbfree(No of free blocks):  %llu\\n\",\n\t\t\t (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_nbfree));\n\t\tpr_info(\"  cs_nifree(Num of free inodes): %llu\\n\",\n\t\t\t(unsigned long long)\n\t\t\tfs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nifree));\n\t\tpr_info(\"  cs_nffree(Num of free frags): %llu\\n\",\n\t\t\t(unsigned long long)\n\t\t\tfs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nffree));\n\t\tpr_info(\"  fs_maxsymlinklen: %u\\n\",\n\t\t\tfs32_to_cpu(sb, usb3->fs_un2.fs_44.fs_maxsymlinklen));\n\t} else {\n\t\tpr_debug(\" sblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_sblkno));\n\t\tpr_debug(\" cblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cblkno));\n\t\tpr_debug(\" iblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_iblkno));\n\t\tpr_debug(\" dblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_dblkno));\n\t\tpr_debug(\" cgoffset:    %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cgoffset));\n\t\tpr_debug(\" ~cgmask:     0x%x\\n\",\n\t\t\t ~fs32_to_cpu(sb, usb1->fs_cgmask));\n\t\tpr_debug(\" size:        %u\\n\", fs32_to_cpu(sb, usb1->fs_size));\n\t\tpr_debug(\" dsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_dsize));\n\t\tpr_debug(\" ncg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_ncg));\n\t\tpr_debug(\" bsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_bsize));\n\t\tpr_debug(\" fsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_fsize));\n\t\tpr_debug(\" frag:        %u\\n\", fs32_to_cpu(sb, usb1->fs_frag));\n\t\tpr_debug(\" fragshift:   %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fragshift));\n\t\tpr_debug(\" ~fmask:      %u\\n\", ~fs32_to_cpu(sb, usb1->fs_fmask));\n\t\tpr_debug(\" fshift:      %u\\n\", fs32_to_cpu(sb, usb1->fs_fshift));\n\t\tpr_debug(\" sbsize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_sbsize));\n\t\tpr_debug(\" spc:         %u\\n\", fs32_to_cpu(sb, usb1->fs_spc));\n\t\tpr_debug(\" cpg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_cpg));\n\t\tpr_debug(\" ipg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_ipg));\n\t\tpr_debug(\" fpg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_fpg));\n\t\tpr_debug(\" csaddr:      %u\\n\", fs32_to_cpu(sb, usb1->fs_csaddr));\n\t\tpr_debug(\" cssize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cssize));\n\t\tpr_debug(\" cgsize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cgsize));\n\t\tpr_debug(\" fstodb:      %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fsbtodb));\n\t\tpr_debug(\" nrpos:       %u\\n\", fs32_to_cpu(sb, usb3->fs_nrpos));\n\t\tpr_debug(\" ndir         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_ndir));\n\t\tpr_debug(\" nifree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nifree));\n\t\tpr_debug(\" nbfree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nbfree));\n\t\tpr_debug(\" nffree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nffree));\n\t}\n\tpr_debug(\"\\n\");\n}\n\n \nstatic void ufs_print_cylinder_stuff(struct super_block *sb,\n\t\t\t\t     struct ufs_cylinder_group *cg)\n{\n\tpr_debug(\"\\nufs_print_cylinder_stuff\\n\");\n\tpr_debug(\"size of ucg: %zu\\n\", sizeof(struct ufs_cylinder_group));\n\tpr_debug(\"  magic:        %x\\n\", fs32_to_cpu(sb, cg->cg_magic));\n\tpr_debug(\"  time:         %u\\n\", fs32_to_cpu(sb, cg->cg_time));\n\tpr_debug(\"  cgx:          %u\\n\", fs32_to_cpu(sb, cg->cg_cgx));\n\tpr_debug(\"  ncyl:         %u\\n\", fs16_to_cpu(sb, cg->cg_ncyl));\n\tpr_debug(\"  niblk:        %u\\n\", fs16_to_cpu(sb, cg->cg_niblk));\n\tpr_debug(\"  ndblk:        %u\\n\", fs32_to_cpu(sb, cg->cg_ndblk));\n\tpr_debug(\"  cs_ndir:      %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_ndir));\n\tpr_debug(\"  cs_nbfree:    %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_nbfree));\n\tpr_debug(\"  cs_nifree:    %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_nifree));\n\tpr_debug(\"  cs_nffree:    %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_nffree));\n\tpr_debug(\"  rotor:        %u\\n\", fs32_to_cpu(sb, cg->cg_rotor));\n\tpr_debug(\"  frotor:       %u\\n\", fs32_to_cpu(sb, cg->cg_frotor));\n\tpr_debug(\"  irotor:       %u\\n\", fs32_to_cpu(sb, cg->cg_irotor));\n\tpr_debug(\"  frsum:        %u, %u, %u, %u, %u, %u, %u, %u\\n\",\n\t    fs32_to_cpu(sb, cg->cg_frsum[0]), fs32_to_cpu(sb, cg->cg_frsum[1]),\n\t    fs32_to_cpu(sb, cg->cg_frsum[2]), fs32_to_cpu(sb, cg->cg_frsum[3]),\n\t    fs32_to_cpu(sb, cg->cg_frsum[4]), fs32_to_cpu(sb, cg->cg_frsum[5]),\n\t    fs32_to_cpu(sb, cg->cg_frsum[6]), fs32_to_cpu(sb, cg->cg_frsum[7]));\n\tpr_debug(\"  btotoff:      %u\\n\", fs32_to_cpu(sb, cg->cg_btotoff));\n\tpr_debug(\"  boff:         %u\\n\", fs32_to_cpu(sb, cg->cg_boff));\n\tpr_debug(\"  iuseoff:      %u\\n\", fs32_to_cpu(sb, cg->cg_iusedoff));\n\tpr_debug(\"  freeoff:      %u\\n\", fs32_to_cpu(sb, cg->cg_freeoff));\n\tpr_debug(\"  nextfreeoff:  %u\\n\", fs32_to_cpu(sb, cg->cg_nextfreeoff));\n\tpr_debug(\"  clustersumoff %u\\n\",\n\t\t fs32_to_cpu(sb, cg->cg_u.cg_44.cg_clustersumoff));\n\tpr_debug(\"  clusteroff    %u\\n\",\n\t\t fs32_to_cpu(sb, cg->cg_u.cg_44.cg_clusteroff));\n\tpr_debug(\"  nclusterblks  %u\\n\",\n\t\t fs32_to_cpu(sb, cg->cg_u.cg_44.cg_nclusterblks));\n\tpr_debug(\"\\n\");\n}\n#else\n#  define ufs_print_super_stuff(sb, usb1, usb2, usb3)  \n#  define ufs_print_cylinder_stuff(sb, cg)  \n#endif  \n\nstatic const struct super_operations ufs_super_ops;\n\nvoid ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!sb_rdonly(sb)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= SB_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}\n\nvoid ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!sb_rdonly(sb)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= SB_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}\n\nvoid ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}\n\nenum {\n       Opt_type_old = UFS_MOUNT_UFSTYPE_OLD,\n       Opt_type_sunx86 = UFS_MOUNT_UFSTYPE_SUNx86,\n       Opt_type_sun = UFS_MOUNT_UFSTYPE_SUN,\n       Opt_type_sunos = UFS_MOUNT_UFSTYPE_SUNOS,\n       Opt_type_44bsd = UFS_MOUNT_UFSTYPE_44BSD,\n       Opt_type_ufs2 = UFS_MOUNT_UFSTYPE_UFS2,\n       Opt_type_hp = UFS_MOUNT_UFSTYPE_HP,\n       Opt_type_nextstepcd = UFS_MOUNT_UFSTYPE_NEXTSTEP_CD,\n       Opt_type_nextstep = UFS_MOUNT_UFSTYPE_NEXTSTEP,\n       Opt_type_openstep = UFS_MOUNT_UFSTYPE_OPENSTEP,\n       Opt_onerror_panic = UFS_MOUNT_ONERROR_PANIC,\n       Opt_onerror_lock = UFS_MOUNT_ONERROR_LOCK,\n       Opt_onerror_umount = UFS_MOUNT_ONERROR_UMOUNT,\n       Opt_onerror_repair = UFS_MOUNT_ONERROR_REPAIR,\n       Opt_err\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_type_old, \"ufstype=old\"},\n\t{Opt_type_sunx86, \"ufstype=sunx86\"},\n\t{Opt_type_sun, \"ufstype=sun\"},\n\t{Opt_type_sunos, \"ufstype=sunos\"},\n\t{Opt_type_44bsd, \"ufstype=44bsd\"},\n\t{Opt_type_ufs2, \"ufstype=ufs2\"},\n\t{Opt_type_ufs2, \"ufstype=5xbsd\"},\n\t{Opt_type_hp, \"ufstype=hp\"},\n\t{Opt_type_nextstepcd, \"ufstype=nextstep-cd\"},\n\t{Opt_type_nextstep, \"ufstype=nextstep\"},\n\t{Opt_type_openstep, \"ufstype=openstep\"},\n \n\t{Opt_onerror_panic, \"onerror=panic\"},\n\t{Opt_onerror_lock, \"onerror=lock\"},\n\t{Opt_onerror_umount, \"onerror=umount\"},\n\t{Opt_onerror_repair, \"onerror=repair\"},\n\t{Opt_err, NULL}\n};\n\nstatic int ufs_parse_options (char * options, unsigned * mount_options)\n{\n\tchar * p;\n\t\n\tUFSD(\"ENTER\\n\");\n\t\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_type_old:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_OLD);\n\t\t\tbreak;\n\t\tcase Opt_type_sunx86:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_SUNx86);\n\t\t\tbreak;\n\t\tcase Opt_type_sun:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_SUN);\n\t\t\tbreak;\n\t\tcase Opt_type_sunos:\n\t\t\tufs_clear_opt(*mount_options, UFSTYPE);\n\t\t\tufs_set_opt(*mount_options, UFSTYPE_SUNOS);\n\t\t\tbreak;\n\t\tcase Opt_type_44bsd:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_44BSD);\n\t\t\tbreak;\n\t\tcase Opt_type_ufs2:\n\t\t\tufs_clear_opt(*mount_options, UFSTYPE);\n\t\t\tufs_set_opt(*mount_options, UFSTYPE_UFS2);\n\t\t\tbreak;\n\t\tcase Opt_type_hp:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_HP);\n\t\t\tbreak;\n\t\tcase Opt_type_nextstepcd:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_NEXTSTEP_CD);\n\t\t\tbreak;\n\t\tcase Opt_type_nextstep:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_NEXTSTEP);\n\t\t\tbreak;\n\t\tcase Opt_type_openstep:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_OPENSTEP);\n\t\t\tbreak;\n\t\tcase Opt_onerror_panic:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_onerror_lock:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_LOCK);\n\t\t\tbreak;\n\t\tcase Opt_onerror_umount:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_UMOUNT);\n\t\t\tbreak;\n\t\tcase Opt_onerror_repair:\n\t\t\tpr_err(\"Unable to do repair on error, will lock lock instead\\n\");\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_REPAIR);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid option: \\\"%s\\\" or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n \nstatic void ufs_setup_cstotal(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_super_block_first *usb1;\n\tstruct ufs_super_block_second *usb2;\n\tstruct ufs_super_block_third *usb3;\n\tunsigned mtype = sbi->s_mount_opt & UFS_MOUNT_UFSTYPE;\n\n\tUFSD(\"ENTER, mtype=%u\\n\", mtype);\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb2 = ubh_get_usb_second(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\tif ((mtype == UFS_MOUNT_UFSTYPE_44BSD &&\n\t     (usb2->fs_un.fs_u2.fs_maxbsize == usb1->fs_bsize)) ||\n\t    mtype == UFS_MOUNT_UFSTYPE_UFS2) {\n\t\t \n\t\tuspi->cs_total.cs_ndir = fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_ndir);\n\t\tuspi->cs_total.cs_nbfree = fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_nbfree);\n\t\tuspi->cs_total.cs_nifree = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nifree);\n\t\tuspi->cs_total.cs_nffree = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nffree);\n\t} else {\n\t\tuspi->cs_total.cs_ndir = fs32_to_cpu(sb, usb1->fs_cstotal.cs_ndir);\n\t\tuspi->cs_total.cs_nbfree = fs32_to_cpu(sb, usb1->fs_cstotal.cs_nbfree);\n\t\tuspi->cs_total.cs_nifree = fs32_to_cpu(sb, usb1->fs_cstotal.cs_nifree);\n\t\tuspi->cs_total.cs_nffree = fs32_to_cpu(sb, usb1->fs_cstotal.cs_nffree);\n\t}\n\tUFSD(\"EXIT\\n\");\n}\n\n \nstatic int ufs_read_cylinder_structures(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_buffer_head * ubh;\n\tunsigned char * base, * space;\n\tunsigned size, blks, i;\n\n\tUFSD(\"ENTER\\n\");\n\n\t \n\tsize = uspi->s_cssize;\n\tblks = (size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tbase = space = kmalloc(size, GFP_NOFS);\n\tif (!base)\n\t\tgoto failed; \n\tsbi->s_csp = (struct ufs_csum *)space;\n\tfor (i = 0; i < blks; i += uspi->s_fpb) {\n\t\tsize = uspi->s_bsize;\n\t\tif (i + uspi->s_fpb > blks)\n\t\t\tsize = (blks - i) * uspi->s_fsize;\n\n\t\tubh = ubh_bread(sb, uspi->s_csaddr + i, size);\n\t\t\n\t\tif (!ubh)\n\t\t\tgoto failed;\n\n\t\tubh_ubhcpymem (space, ubh, size);\n\n\t\tspace += size;\n\t\tubh_brelse (ubh);\n\t\tubh = NULL;\n\t}\n\n\t \n\tsbi->s_ucg = kmalloc_array(uspi->s_ncg, sizeof(struct buffer_head *),\n\t\t\t\t   GFP_NOFS);\n\tif (!sbi->s_ucg)\n\t\tgoto failed;\n\tfor (i = 0; i < uspi->s_ncg; i++) \n\t\tsbi->s_ucg[i] = NULL;\n\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++) {\n\t\tsbi->s_ucpi[i] = NULL;\n\t\tsbi->s_cgno[i] = UFS_CGNO_EMPTY;\n\t}\n\tfor (i = 0; i < uspi->s_ncg; i++) {\n\t\tUFSD(\"read cg %u\\n\", i);\n\t\tif (!(sbi->s_ucg[i] = sb_bread(sb, ufs_cgcmin(i))))\n\t\t\tgoto failed;\n\t\tif (!ufs_cg_chkmagic (sb, (struct ufs_cylinder_group *) sbi->s_ucg[i]->b_data))\n\t\t\tgoto failed;\n\n\t\tufs_print_cylinder_stuff(sb, (struct ufs_cylinder_group *) sbi->s_ucg[i]->b_data);\n\t}\n\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++) {\n\t\tif (!(sbi->s_ucpi[i] = kmalloc (sizeof(struct ufs_cg_private_info), GFP_NOFS)))\n\t\t\tgoto failed;\n\t\tsbi->s_cgno[i] = UFS_CGNO_EMPTY;\n\t}\n\tsbi->s_cg_loaded = 0;\n\tUFSD(\"EXIT\\n\");\n\treturn 1;\n\nfailed:\n\tkfree (base);\n\tif (sbi->s_ucg) {\n\t\tfor (i = 0; i < uspi->s_ncg; i++)\n\t\t\tif (sbi->s_ucg[i])\n\t\t\t\tbrelse (sbi->s_ucg[i]);\n\t\tkfree (sbi->s_ucg);\n\t\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++)\n\t\t\tkfree (sbi->s_ucpi[i]);\n\t}\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n}\n\n \nstatic void ufs_put_cstotal(struct super_block *sb)\n{\n\tunsigned mtype = UFS_SB(sb)->s_mount_opt & UFS_MOUNT_UFSTYPE;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct ufs_super_block_first *usb1;\n\tstruct ufs_super_block_second *usb2;\n\tstruct ufs_super_block_third *usb3;\n\n\tUFSD(\"ENTER\\n\");\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb2 = ubh_get_usb_second(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\tif (mtype == UFS_MOUNT_UFSTYPE_UFS2) {\n\t\t \n\t\tusb2->fs_un.fs_u2.cs_ndir =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_ndir);\n\t\tusb2->fs_un.fs_u2.cs_nbfree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nbfree);\n\t\tusb3->fs_un1.fs_u2.cs_nifree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nifree);\n\t\tusb3->fs_un1.fs_u2.cs_nffree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nffree);\n\t\tgoto out;\n\t}\n\n\tif (mtype == UFS_MOUNT_UFSTYPE_44BSD &&\n\t     (usb2->fs_un.fs_u2.fs_maxbsize == usb1->fs_bsize)) {\n\t\t \n\t\tusb2->fs_un.fs_u2.cs_ndir =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_ndir);\n\t\tusb2->fs_un.fs_u2.cs_nbfree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nbfree);\n\t\tusb3->fs_un1.fs_u2.cs_nifree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nifree);\n\t\tusb3->fs_un1.fs_u2.cs_nffree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nffree);\n\t}\n\tusb1->fs_cstotal.cs_ndir = cpu_to_fs32(sb, uspi->cs_total.cs_ndir);\n\tusb1->fs_cstotal.cs_nbfree = cpu_to_fs32(sb, uspi->cs_total.cs_nbfree);\n\tusb1->fs_cstotal.cs_nifree = cpu_to_fs32(sb, uspi->cs_total.cs_nifree);\n\tusb1->fs_cstotal.cs_nffree = cpu_to_fs32(sb, uspi->cs_total.cs_nffree);\nout:\n\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\tufs_print_super_stuff(sb, usb1, usb2, usb3);\n\tUFSD(\"EXIT\\n\");\n}\n\n \nstatic void ufs_put_super_internal(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_buffer_head * ubh;\n\tunsigned char * base, * space;\n\tunsigned blks, size, i;\n\n\t\n\tUFSD(\"ENTER\\n\");\n\n\tufs_put_cstotal(sb);\n\tsize = uspi->s_cssize;\n\tblks = (size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tbase = space = (char*) sbi->s_csp;\n\tfor (i = 0; i < blks; i += uspi->s_fpb) {\n\t\tsize = uspi->s_bsize;\n\t\tif (i + uspi->s_fpb > blks)\n\t\t\tsize = (blks - i) * uspi->s_fsize;\n\n\t\tubh = ubh_bread(sb, uspi->s_csaddr + i, size);\n\n\t\tubh_memcpyubh (ubh, space, size);\n\t\tspace += size;\n\t\tubh_mark_buffer_uptodate (ubh, 1);\n\t\tubh_mark_buffer_dirty (ubh);\n\t\tubh_brelse (ubh);\n\t}\n\tfor (i = 0; i < sbi->s_cg_loaded; i++) {\n\t\tufs_put_cylinder (sb, i);\n\t\tkfree (sbi->s_ucpi[i]);\n\t}\n\tfor (; i < UFS_MAX_GROUP_LOADED; i++) \n\t\tkfree (sbi->s_ucpi[i]);\n\tfor (i = 0; i < uspi->s_ncg; i++) \n\t\tbrelse (sbi->s_ucg[i]);\n\tkfree (sbi->s_ucg);\n\tkfree (base);\n\n\tUFSD(\"EXIT\\n\");\n}\n\nstatic int ufs_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct ufs_super_block_third * usb3;\n\tunsigned flags;\n\n\tmutex_lock(&UFS_SB(sb)->s_lock);\n\n\tUFSD(\"ENTER\\n\");\n\n\tflags = UFS_SB(sb)->s_flags;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\tusb1->fs_time = ufs_get_seconds(sb);\n\tif ((flags & UFS_ST_MASK) == UFS_ST_SUN  ||\n\t    (flags & UFS_ST_MASK) == UFS_ST_SUNOS ||\n\t    (flags & UFS_ST_MASK) == UFS_ST_SUNx86)\n\t\tufs_set_fs_state(sb, usb1, usb3,\n\t\t\t\tUFS_FSOK - fs32_to_cpu(sb, usb1->fs_time));\n\tufs_put_cstotal(sb);\n\n\tUFSD(\"EXIT\\n\");\n\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\n\treturn 0;\n}\n\nstatic void delayed_sync_fs(struct work_struct *work)\n{\n\tstruct ufs_sb_info *sbi;\n\n\tsbi = container_of(work, struct ufs_sb_info, sync_work.work);\n\n\tspin_lock(&sbi->work_lock);\n\tsbi->work_queued = 0;\n\tspin_unlock(&sbi->work_lock);\n\n\tufs_sync_fs(sbi->sb, 1);\n}\n\nvoid ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}\n\nstatic void ufs_put_super(struct super_block *sb)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\n\tUFSD(\"ENTER\\n\");\n\n\tif (!sb_rdonly(sb))\n\t\tufs_put_super_internal(sb);\n\tcancel_delayed_work_sync(&sbi->sync_work);\n\n\tubh_brelse_uspi (sbi->s_uspi);\n\tkfree (sbi->s_uspi);\n\tkfree (sbi);\n\tsb->s_fs_info = NULL;\n\tUFSD(\"EXIT\\n\");\n\treturn;\n}\n\nstatic u64 ufs_max_bytes(struct super_block *sb)\n{\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tint bits = uspi->s_apbshift;\n\tu64 res;\n\n\tif (bits > 21)\n\t\tres = ~0ULL;\n\telse\n\t\tres = UFS_NDADDR + (1LL << bits) + (1LL << (2*bits)) +\n\t\t\t(1LL << (3*bits));\n\n\tif (res >= (MAX_LFS_FILESIZE >> uspi->s_bshift))\n\t\treturn MAX_LFS_FILESIZE;\n\treturn res << uspi->s_bshift;\n}\n\nstatic int ufs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct ufs_sb_info * sbi;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct ufs_super_block_second * usb2;\n\tstruct ufs_super_block_third * usb3;\n\tstruct ufs_buffer_head * ubh;\t\n\tstruct inode *inode;\n\tunsigned block_size, super_block_size;\n\tunsigned flags;\n\tunsigned super_block_offset;\n\tunsigned maxsymlen;\n\tint ret = -EINVAL;\n\n\tuspi = NULL;\n\tubh = NULL;\n\tflags = 0;\n\t\n\tUFSD(\"ENTER\\n\");\n\n#ifndef CONFIG_UFS_FS_WRITE\n\tif (!sb_rdonly(sb)) {\n\t\tpr_err(\"ufs was compiled with read-only support, can't be mounted as read-write\\n\");\n\t\treturn -EROFS;\n\t}\n#endif\n\t\t\n\tsbi = kzalloc(sizeof(struct ufs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto failed_nomem;\n\tsb->s_fs_info = sbi;\n\tsbi->sb = sb;\n\n\tUFSD(\"flag %u\\n\", (int)(sb_rdonly(sb)));\n\t\n\tmutex_init(&sbi->s_lock);\n\tspin_lock_init(&sbi->work_lock);\n\tINIT_DELAYED_WORK(&sbi->sync_work, delayed_sync_fs);\n\t \n\tsbi->s_mount_opt = 0;\n\tufs_set_opt (sbi->s_mount_opt, ONERROR_LOCK);\n\tif (!ufs_parse_options ((char *) data, &sbi->s_mount_opt)) {\n\t\tpr_err(\"wrong mount options\\n\");\n\t\tgoto failed;\n\t}\n\tif (!(sbi->s_mount_opt & UFS_MOUNT_UFSTYPE)) {\n\t\tif (!silent)\n\t\t\tpr_err(\"You didn't specify the type of your ufs filesystem\\n\\n\"\n\t\t\t\"mount -t ufs -o ufstype=\"\n\t\t\t\"sun|sunx86|44bsd|ufs2|5xbsd|old|hp|nextstep|nextstep-cd|openstep ...\\n\\n\"\n\t\t\t\">>>WARNING<<< Wrong ufstype may corrupt your filesystem, \"\n\t\t\t\"default is ufstype=old\\n\");\n\t\tufs_set_opt (sbi->s_mount_opt, UFSTYPE_OLD);\n\t}\n\n\tuspi = kzalloc(sizeof(struct ufs_sb_private_info), GFP_KERNEL);\n\tsbi->s_uspi = uspi;\n\tif (!uspi)\n\t\tgoto failed;\n\tuspi->s_dirblksize = UFS_SECTOR_SIZE;\n\tsuper_block_offset=UFS_SBLOCK;\n\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\n\tsb->s_time_gran = NSEC_PER_SEC;\n\tsb->s_time_min = S32_MIN;\n\tsb->s_time_max = S32_MAX;\n\n\tswitch (sbi->s_mount_opt & UFS_MOUNT_UFSTYPE) {\n\tcase UFS_MOUNT_UFSTYPE_44BSD:\n\t\tUFSD(\"ufstype=44bsd\\n\");\n\t\tuspi->s_fsize = block_size = 512;\n\t\tuspi->s_fmask = ~(512 - 1);\n\t\tuspi->s_fshift = 9;\n\t\tuspi->s_sbsize = super_block_size = 1536;\n\t\tuspi->s_sbbase = 0;\n\t\tflags |= UFS_DE_44BSD | UFS_UID_44BSD | UFS_ST_44BSD | UFS_CG_44BSD;\n\t\tbreak;\n\tcase UFS_MOUNT_UFSTYPE_UFS2:\n\t\tUFSD(\"ufstype=ufs2\\n\");\n\t\tsuper_block_offset=SBLOCK_UFS2;\n\t\tuspi->s_fsize = block_size = 512;\n\t\tuspi->s_fmask = ~(512 - 1);\n\t\tuspi->s_fshift = 9;\n\t\tuspi->s_sbsize = super_block_size = 1536;\n\t\tuspi->s_sbbase =  0;\n\t\tsb->s_time_gran = 1;\n\t\tsb->s_time_min = S64_MIN;\n\t\tsb->s_time_max = S64_MAX;\n\t\tflags |= UFS_TYPE_UFS2 | UFS_DE_44BSD | UFS_UID_44BSD | UFS_ST_44BSD | UFS_CG_44BSD;\n\t\tbreak;\n\t\t\n\tcase UFS_MOUNT_UFSTYPE_SUN:\n\t\tUFSD(\"ufstype=sun\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tuspi->s_maxsymlinklen = 0;  \n\t\tflags |= UFS_DE_OLD | UFS_UID_EFT | UFS_ST_SUN | UFS_CG_SUN;\n\t\tbreak;\n\n\tcase UFS_MOUNT_UFSTYPE_SUNOS:\n\t\tUFSD(\"ufstype=sunos\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = 2048;\n\t\tsuper_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tuspi->s_maxsymlinklen = 0;  \n\t\tflags |= UFS_DE_OLD | UFS_UID_OLD | UFS_ST_SUNOS | UFS_CG_SUN;\n\t\tbreak;\n\n\tcase UFS_MOUNT_UFSTYPE_SUNx86:\n\t\tUFSD(\"ufstype=sunx86\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tuspi->s_maxsymlinklen = 0;  \n\t\tflags |= UFS_DE_OLD | UFS_UID_EFT | UFS_ST_SUNx86 | UFS_CG_SUN;\n\t\tbreak;\n\n\tcase UFS_MOUNT_UFSTYPE_OLD:\n\t\tUFSD(\"ufstype=old\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tflags |= UFS_DE_OLD | UFS_UID_OLD | UFS_ST_OLD | UFS_CG_OLD;\n\t\tif (!sb_rdonly(sb)) {\n\t\t\tif (!silent)\n\t\t\t\tpr_info(\"ufstype=old is supported read-only\\n\");\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t}\n\t\tbreak;\n\t\n\tcase UFS_MOUNT_UFSTYPE_NEXTSTEP:\n\t\tUFSD(\"ufstype=nextstep\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tuspi->s_dirblksize = 1024;\n\t\tflags |= UFS_DE_OLD | UFS_UID_OLD | UFS_ST_OLD | UFS_CG_OLD;\n\t\tif (!sb_rdonly(sb)) {\n\t\t\tif (!silent)\n\t\t\t\tpr_info(\"ufstype=nextstep is supported read-only\\n\");\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t}\n\t\tbreak;\n\t\n\tcase UFS_MOUNT_UFSTYPE_NEXTSTEP_CD:\n\t\tUFSD(\"ufstype=nextstep-cd\\n\");\n\t\tuspi->s_fsize = block_size = 2048;\n\t\tuspi->s_fmask = ~(2048 - 1);\n\t\tuspi->s_fshift = 11;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tuspi->s_dirblksize = 1024;\n\t\tflags |= UFS_DE_OLD | UFS_UID_OLD | UFS_ST_OLD | UFS_CG_OLD;\n\t\tif (!sb_rdonly(sb)) {\n\t\t\tif (!silent)\n\t\t\t\tpr_info(\"ufstype=nextstep-cd is supported read-only\\n\");\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t}\n\t\tbreak;\n\t\n\tcase UFS_MOUNT_UFSTYPE_OPENSTEP:\n\t\tUFSD(\"ufstype=openstep\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tuspi->s_dirblksize = 1024;\n\t\tflags |= UFS_DE_44BSD | UFS_UID_44BSD | UFS_ST_44BSD | UFS_CG_44BSD;\n\t\tif (!sb_rdonly(sb)) {\n\t\t\tif (!silent)\n\t\t\t\tpr_info(\"ufstype=openstep is supported read-only\\n\");\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t}\n\t\tbreak;\n\t\n\tcase UFS_MOUNT_UFSTYPE_HP:\n\t\tUFSD(\"ufstype=hp\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tflags |= UFS_DE_OLD | UFS_UID_OLD | UFS_ST_OLD | UFS_CG_OLD;\n\t\tif (!sb_rdonly(sb)) {\n\t\t\tif (!silent)\n\t\t\t\tpr_info(\"ufstype=hp is supported read-only\\n\");\n\t\t\tsb->s_flags |= SB_RDONLY;\n \t\t}\n \t\tbreak;\n\tdefault:\n\t\tif (!silent)\n\t\t\tpr_err(\"unknown ufstype\\n\");\n\t\tgoto failed;\n\t}\n\t\nagain:\t\n\tif (!sb_set_blocksize(sb, block_size)) {\n\t\tpr_err(\"failed to set blocksize\\n\");\n\t\tgoto failed;\n\t}\n\n\t \n\n\tubh = ubh_bread_uspi(uspi, sb, uspi->s_sbbase + super_block_offset/block_size, super_block_size);\n\t\n\tif (!ubh) \n            goto failed;\n\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb2 = ubh_get_usb_second(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\t \n\tuspi->s_postblformat = fs32_to_cpu(sb, usb3->fs_postblformat);\n\tif (((flags & UFS_ST_MASK) == UFS_ST_SUNOS) &&\n\t    (uspi->s_postblformat != UFS_42POSTBLFMT)) {\n\t\tflags &= ~UFS_ST_MASK;\n\t\tflags |=  UFS_ST_SUN;\n\t}\n\n\tif ((flags & UFS_ST_MASK) == UFS_ST_44BSD &&\n\t    uspi->s_postblformat == UFS_42POSTBLFMT) {\n\t\tif (!silent)\n\t\t\tpr_err(\"this is not a 44bsd filesystem\");\n\t\tgoto failed;\n\t}\n\n\t \n\tsbi->s_bytesex = BYTESEX_LE;\n\tswitch ((uspi->fs_magic = fs32_to_cpu(sb, usb3->fs_magic))) {\n\t\tcase UFS_MAGIC:\n\t\tcase UFS_MAGIC_BW:\n\t\tcase UFS2_MAGIC:\n\t\tcase UFS_MAGIC_LFN:\n\t        case UFS_MAGIC_FEA:\n\t        case UFS_MAGIC_4GB:\n\t\t\tgoto magic_found;\n\t}\n\tsbi->s_bytesex = BYTESEX_BE;\n\tswitch ((uspi->fs_magic = fs32_to_cpu(sb, usb3->fs_magic))) {\n\t\tcase UFS_MAGIC:\n\t\tcase UFS_MAGIC_BW:\n\t\tcase UFS2_MAGIC:\n\t\tcase UFS_MAGIC_LFN:\n\t        case UFS_MAGIC_FEA:\n\t        case UFS_MAGIC_4GB:\n\t\t\tgoto magic_found;\n\t}\n\n\tif ((((sbi->s_mount_opt & UFS_MOUNT_UFSTYPE) == UFS_MOUNT_UFSTYPE_NEXTSTEP) \n\t  || ((sbi->s_mount_opt & UFS_MOUNT_UFSTYPE) == UFS_MOUNT_UFSTYPE_NEXTSTEP_CD) \n\t  || ((sbi->s_mount_opt & UFS_MOUNT_UFSTYPE) == UFS_MOUNT_UFSTYPE_OPENSTEP)) \n\t  && uspi->s_sbbase < 256) {\n\t\tubh_brelse_uspi(uspi);\n\t\tubh = NULL;\n\t\tuspi->s_sbbase += 8;\n\t\tgoto again;\n\t}\n\tif (!silent)\n\t\tpr_err(\"%s(): bad magic number\\n\", __func__);\n\tgoto failed;\n\nmagic_found:\n\t \n\tuspi->s_bsize = fs32_to_cpu(sb, usb1->fs_bsize);\n\tuspi->s_fsize = fs32_to_cpu(sb, usb1->fs_fsize);\n\tuspi->s_sbsize = fs32_to_cpu(sb, usb1->fs_sbsize);\n\tuspi->s_fmask = fs32_to_cpu(sb, usb1->fs_fmask);\n\tuspi->s_fshift = fs32_to_cpu(sb, usb1->fs_fshift);\n\n\tif (!is_power_of_2(uspi->s_fsize)) {\n\t\tpr_err(\"%s(): fragment size %u is not a power of 2\\n\",\n\t\t       __func__, uspi->s_fsize);\n\t\tgoto failed;\n\t}\n\tif (uspi->s_fsize < 512) {\n\t\tpr_err(\"%s(): fragment size %u is too small\\n\",\n\t\t       __func__, uspi->s_fsize);\n\t\tgoto failed;\n\t}\n\tif (uspi->s_fsize > 4096) {\n\t\tpr_err(\"%s(): fragment size %u is too large\\n\",\n\t\t       __func__, uspi->s_fsize);\n\t\tgoto failed;\n\t}\n\tif (!is_power_of_2(uspi->s_bsize)) {\n\t\tpr_err(\"%s(): block size %u is not a power of 2\\n\",\n\t\t       __func__, uspi->s_bsize);\n\t\tgoto failed;\n\t}\n\tif (uspi->s_bsize < 4096) {\n\t\tpr_err(\"%s(): block size %u is too small\\n\",\n\t\t       __func__, uspi->s_bsize);\n\t\tgoto failed;\n\t}\n\tif (uspi->s_bsize / uspi->s_fsize > 8) {\n\t\tpr_err(\"%s(): too many fragments per block (%u)\\n\",\n\t\t       __func__, uspi->s_bsize / uspi->s_fsize);\n\t\tgoto failed;\n\t}\n\tif (uspi->s_fsize != block_size || uspi->s_sbsize != super_block_size) {\n\t\tubh_brelse_uspi(uspi);\n\t\tubh = NULL;\n\t\tblock_size = uspi->s_fsize;\n\t\tsuper_block_size = uspi->s_sbsize;\n\t\tUFSD(\"another value of block_size or super_block_size %u, %u\\n\", block_size, super_block_size);\n\t\tgoto again;\n\t}\n\n\tsbi->s_flags = flags; \n\tufs_print_super_stuff(sb, usb1, usb2, usb3);\n\n\t \n\tif (((flags & UFS_ST_MASK) == UFS_ST_44BSD) ||\n\t  ((flags & UFS_ST_MASK) == UFS_ST_OLD) ||\n\t  (((flags & UFS_ST_MASK) == UFS_ST_SUN ||\n\t    (flags & UFS_ST_MASK) == UFS_ST_SUNOS ||\n\t  (flags & UFS_ST_MASK) == UFS_ST_SUNx86) &&\n\t  (ufs_get_fs_state(sb, usb1, usb3) == (UFS_FSOK - fs32_to_cpu(sb, usb1->fs_time))))) {\n\t\tswitch(usb1->fs_clean) {\n\t\tcase UFS_FSCLEAN:\n\t\t\tUFSD(\"fs is clean\\n\");\n\t\t\tbreak;\n\t\tcase UFS_FSSTABLE:\n\t\t\tUFSD(\"fs is stable\\n\");\n\t\t\tbreak;\n\t\tcase UFS_FSLOG:\n\t\t\tUFSD(\"fs is logging fs\\n\");\n\t\t\tbreak;\n\t\tcase UFS_FSOSF1:\n\t\t\tUFSD(\"fs is DEC OSF/1\\n\");\n\t\t\tbreak;\n\t\tcase UFS_FSACTIVE:\n\t\t\tpr_err(\"%s(): fs is active\\n\", __func__);\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t\tbreak;\n\t\tcase UFS_FSBAD:\n\t\t\tpr_err(\"%s(): fs is bad\\n\", __func__);\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"%s(): can't grok fs_clean 0x%x\\n\",\n\t\t\t       __func__, usb1->fs_clean);\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tpr_err(\"%s(): fs needs fsck\\n\", __func__);\n\t\tsb->s_flags |= SB_RDONLY;\n\t}\n\n\t \n\tsb->s_op = &ufs_super_ops;\n\tsb->s_export_op = &ufs_export_ops;\n\n\tsb->s_magic = fs32_to_cpu(sb, usb3->fs_magic);\n\n\tuspi->s_sblkno = fs32_to_cpu(sb, usb1->fs_sblkno);\n\tuspi->s_cblkno = fs32_to_cpu(sb, usb1->fs_cblkno);\n\tuspi->s_iblkno = fs32_to_cpu(sb, usb1->fs_iblkno);\n\tuspi->s_dblkno = fs32_to_cpu(sb, usb1->fs_dblkno);\n\tuspi->s_cgoffset = fs32_to_cpu(sb, usb1->fs_cgoffset);\n\tuspi->s_cgmask = fs32_to_cpu(sb, usb1->fs_cgmask);\n\n\tif ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2) {\n\t\tuspi->s_size  = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_size);\n\t\tuspi->s_dsize = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_dsize);\n\t} else {\n\t\tuspi->s_size  =  fs32_to_cpu(sb, usb1->fs_size);\n\t\tuspi->s_dsize =  fs32_to_cpu(sb, usb1->fs_dsize);\n\t}\n\n\tuspi->s_ncg = fs32_to_cpu(sb, usb1->fs_ncg);\n\t \n\t \n\tuspi->s_fpb = fs32_to_cpu(sb, usb1->fs_frag);\n\tuspi->s_minfree = fs32_to_cpu(sb, usb1->fs_minfree);\n\tuspi->s_bmask = fs32_to_cpu(sb, usb1->fs_bmask);\n\tuspi->s_fmask = fs32_to_cpu(sb, usb1->fs_fmask);\n\tuspi->s_bshift = fs32_to_cpu(sb, usb1->fs_bshift);\n\tuspi->s_fshift = fs32_to_cpu(sb, usb1->fs_fshift);\n\tUFSD(\"uspi->s_bshift = %d,uspi->s_fshift = %d\", uspi->s_bshift,\n\t\tuspi->s_fshift);\n\tuspi->s_fpbshift = fs32_to_cpu(sb, usb1->fs_fragshift);\n\tuspi->s_fsbtodb = fs32_to_cpu(sb, usb1->fs_fsbtodb);\n\t \n\tuspi->s_csmask = fs32_to_cpu(sb, usb1->fs_csmask);\n\tuspi->s_csshift = fs32_to_cpu(sb, usb1->fs_csshift);\n\tuspi->s_nindir = fs32_to_cpu(sb, usb1->fs_nindir);\n\tuspi->s_inopb = fs32_to_cpu(sb, usb1->fs_inopb);\n\tuspi->s_nspf = fs32_to_cpu(sb, usb1->fs_nspf);\n\tuspi->s_npsect = ufs_get_fs_npsect(sb, usb1, usb3);\n\tuspi->s_interleave = fs32_to_cpu(sb, usb1->fs_interleave);\n\tuspi->s_trackskew = fs32_to_cpu(sb, usb1->fs_trackskew);\n\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\tuspi->s_csaddr = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_csaddr);\n\telse\n\t\tuspi->s_csaddr = fs32_to_cpu(sb, usb1->fs_csaddr);\n\n\tuspi->s_cssize = fs32_to_cpu(sb, usb1->fs_cssize);\n\tuspi->s_cgsize = fs32_to_cpu(sb, usb1->fs_cgsize);\n\tuspi->s_ntrak = fs32_to_cpu(sb, usb1->fs_ntrak);\n\tuspi->s_nsect = fs32_to_cpu(sb, usb1->fs_nsect);\n\tuspi->s_spc = fs32_to_cpu(sb, usb1->fs_spc);\n\tuspi->s_ipg = fs32_to_cpu(sb, usb1->fs_ipg);\n\tuspi->s_fpg = fs32_to_cpu(sb, usb1->fs_fpg);\n\tuspi->s_cpc = fs32_to_cpu(sb, usb2->fs_un.fs_u1.fs_cpc);\n\tuspi->s_contigsumsize = fs32_to_cpu(sb, usb3->fs_un2.fs_44.fs_contigsumsize);\n\tuspi->s_qbmask = ufs_get_fs_qbmask(sb, usb3);\n\tuspi->s_qfmask = ufs_get_fs_qfmask(sb, usb3);\n\tuspi->s_nrpos = fs32_to_cpu(sb, usb3->fs_nrpos);\n\tuspi->s_postbloff = fs32_to_cpu(sb, usb3->fs_postbloff);\n\tuspi->s_rotbloff = fs32_to_cpu(sb, usb3->fs_rotbloff);\n\n\tuspi->s_root_blocks = mul_u64_u32_div(uspi->s_dsize,\n\t\t\t\t\t      uspi->s_minfree, 100);\n\tif (uspi->s_minfree <= 5) {\n\t\tuspi->s_time_to_space = ~0ULL;\n\t\tuspi->s_space_to_time = 0;\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTSPACE);\n\t} else {\n\t\tuspi->s_time_to_space = (uspi->s_root_blocks / 2) + 1;\n\t\tuspi->s_space_to_time = mul_u64_u32_div(uspi->s_dsize,\n\t\t\t\t\t      uspi->s_minfree - 2, 100) - 1;\n\t}\n\n\t \n\tuspi->s_fpbmask = uspi->s_fpb - 1;\n\tif ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)\n\t\tuspi->s_apbshift = uspi->s_bshift - 3;\n\telse\n\t\tuspi->s_apbshift = uspi->s_bshift - 2;\n\n\tuspi->s_2apbshift = uspi->s_apbshift * 2;\n\tuspi->s_3apbshift = uspi->s_apbshift * 3;\n\tuspi->s_apb = 1 << uspi->s_apbshift;\n\tuspi->s_2apb = 1 << uspi->s_2apbshift;\n\tuspi->s_3apb = 1 << uspi->s_3apbshift;\n\tuspi->s_apbmask = uspi->s_apb - 1;\n\tuspi->s_nspfshift = uspi->s_fshift - UFS_SECTOR_BITS;\n\tuspi->s_nspb = uspi->s_nspf << uspi->s_fpbshift;\n\tuspi->s_inopf = uspi->s_inopb >> uspi->s_fpbshift;\n\tuspi->s_bpf = uspi->s_fsize << 3;\n\tuspi->s_bpfshift = uspi->s_fshift + 3;\n\tuspi->s_bpfmask = uspi->s_bpf - 1;\n\tif ((sbi->s_mount_opt & UFS_MOUNT_UFSTYPE) == UFS_MOUNT_UFSTYPE_44BSD ||\n\t    (sbi->s_mount_opt & UFS_MOUNT_UFSTYPE) == UFS_MOUNT_UFSTYPE_UFS2)\n\t\tuspi->s_maxsymlinklen =\n\t\t    fs32_to_cpu(sb, usb3->fs_un2.fs_44.fs_maxsymlinklen);\n\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\tmaxsymlen = 2 * 4 * (UFS_NDADDR + UFS_NINDIR);\n\telse\n\t\tmaxsymlen = 4 * (UFS_NDADDR + UFS_NINDIR);\n\tif (uspi->s_maxsymlinklen > maxsymlen) {\n\t\tufs_warning(sb, __func__, \"ufs_read_super: excessive maximum \"\n\t\t\t    \"fast symlink size (%u)\\n\", uspi->s_maxsymlinklen);\n\t\tuspi->s_maxsymlinklen = maxsymlen;\n\t}\n\tsb->s_maxbytes = ufs_max_bytes(sb);\n\tsb->s_max_links = UFS_LINK_MAX;\n\n\tinode = ufs_iget(sb, UFS_ROOTINO);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto failed;\n\t}\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root) {\n\t\tret = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tufs_setup_cstotal(sb);\n\t \n\tif (!sb_rdonly(sb))\n\t\tif (!ufs_read_cylinder_structures(sb))\n\t\t\tgoto failed;\n\n\tUFSD(\"EXIT\\n\");\n\treturn 0;\n\nfailed:\n\tif (ubh)\n\t\tubh_brelse_uspi (uspi);\n\tkfree (uspi);\n\tkfree(sbi);\n\tsb->s_fs_info = NULL;\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn ret;\n\nfailed_nomem:\n\tUFSD(\"EXIT (NOMEM)\\n\");\n\treturn -ENOMEM;\n}\n\nstatic int ufs_remount (struct super_block *sb, int *mount_flags, char *data)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct ufs_super_block_third * usb3;\n\tunsigned new_mount_opt, ufstype;\n\tunsigned flags;\n\n\tsync_filesystem(sb);\n\tmutex_lock(&UFS_SB(sb)->s_lock);\n\tuspi = UFS_SB(sb)->s_uspi;\n\tflags = UFS_SB(sb)->s_flags;\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\t\n\t \n\tufstype = UFS_SB(sb)->s_mount_opt & UFS_MOUNT_UFSTYPE;\n\tnew_mount_opt = 0;\n\tufs_set_opt (new_mount_opt, ONERROR_LOCK);\n\tif (!ufs_parse_options (data, &new_mount_opt)) {\n\t\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!(new_mount_opt & UFS_MOUNT_UFSTYPE)) {\n\t\tnew_mount_opt |= ufstype;\n\t} else if ((new_mount_opt & UFS_MOUNT_UFSTYPE) != ufstype) {\n\t\tpr_err(\"ufstype can't be changed during remount\\n\");\n\t\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((bool)(*mount_flags & SB_RDONLY) == sb_rdonly(sb)) {\n\t\tUFS_SB(sb)->s_mount_opt = new_mount_opt;\n\t\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\t\treturn 0;\n\t}\n\t\n\t \n\tif (*mount_flags & SB_RDONLY) {\n\t\tufs_put_super_internal(sb);\n\t\tusb1->fs_time = ufs_get_seconds(sb);\n\t\tif ((flags & UFS_ST_MASK) == UFS_ST_SUN\n\t\t  || (flags & UFS_ST_MASK) == UFS_ST_SUNOS\n\t\t  || (flags & UFS_ST_MASK) == UFS_ST_SUNx86) \n\t\t\tufs_set_fs_state(sb, usb1, usb3,\n\t\t\t\tUFS_FSOK - fs32_to_cpu(sb, usb1->fs_time));\n\t\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\t\tsb->s_flags |= SB_RDONLY;\n\t} else {\n\t \n#ifndef CONFIG_UFS_FS_WRITE\n\t\tpr_err(\"ufs was compiled with read-only support, can't be mounted as read-write\\n\");\n\t\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\t\treturn -EINVAL;\n#else\n\t\tif (ufstype != UFS_MOUNT_UFSTYPE_SUN && \n\t\t    ufstype != UFS_MOUNT_UFSTYPE_SUNOS &&\n\t\t    ufstype != UFS_MOUNT_UFSTYPE_44BSD &&\n\t\t    ufstype != UFS_MOUNT_UFSTYPE_SUNx86 &&\n\t\t    ufstype != UFS_MOUNT_UFSTYPE_UFS2) {\n\t\t\tpr_err(\"this ufstype is read-only supported\\n\");\n\t\t\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!ufs_read_cylinder_structures(sb)) {\n\t\t\tpr_err(\"failed during remounting\\n\");\n\t\t\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tsb->s_flags &= ~SB_RDONLY;\n#endif\n\t}\n\tUFS_SB(sb)->s_mount_opt = new_mount_opt;\n\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\treturn 0;\n}\n\nstatic int ufs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(root->d_sb);\n\tunsigned mval = sbi->s_mount_opt & UFS_MOUNT_UFSTYPE;\n\tconst struct match_token *tp = tokens;\n\n\twhile (tp->token != Opt_onerror_panic && tp->token != mval)\n\t\t++tp;\n\tBUG_ON(tp->token == Opt_onerror_panic);\n\tseq_printf(seq, \",%s\", tp->pattern);\n\n\tmval = sbi->s_mount_opt & UFS_MOUNT_ONERROR;\n\twhile (tp->token != Opt_err && tp->token != mval)\n\t\t++tp;\n\tBUG_ON(tp->token == Opt_err);\n\tseq_printf(seq, \",%s\", tp->pattern);\n\n\treturn 0;\n}\n\nstatic int ufs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ufs_sb_private_info *uspi= UFS_SB(sb)->s_uspi;\n\tunsigned  flags = UFS_SB(sb)->s_flags;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tmutex_lock(&UFS_SB(sb)->s_lock);\n\t\n\tif ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)\n\t\tbuf->f_type = UFS2_MAGIC;\n\telse\n\t\tbuf->f_type = UFS_MAGIC;\n\n\tbuf->f_blocks = uspi->s_dsize;\n\tbuf->f_bfree = ufs_freefrags(uspi);\n\tbuf->f_ffree = uspi->cs_total.cs_nifree;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_bavail = (buf->f_bfree > uspi->s_root_blocks)\n\t\t? (buf->f_bfree - uspi->s_root_blocks) : 0;\n\tbuf->f_files = uspi->s_ncg * uspi->s_ipg;\n\tbuf->f_namelen = UFS_MAXNAMLEN;\n\tbuf->f_fsid = u64_to_fsid(id);\n\n\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\n\treturn 0;\n}\n\nstatic struct kmem_cache * ufs_inode_cachep;\n\nstatic struct inode *ufs_alloc_inode(struct super_block *sb)\n{\n\tstruct ufs_inode_info *ei;\n\n\tei = alloc_inode_sb(sb, ufs_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\n\tinode_set_iversion(&ei->vfs_inode, 1);\n\tseqlock_init(&ei->meta_lock);\n\tmutex_init(&ei->truncate_mutex);\n\treturn &ei->vfs_inode;\n}\n\nstatic void ufs_free_in_core_inode(struct inode *inode)\n{\n\tkmem_cache_free(ufs_inode_cachep, UFS_I(inode));\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct ufs_inode_info *ei = (struct ufs_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int __init init_inodecache(void)\n{\n\tufs_inode_cachep = kmem_cache_create_usercopy(\"ufs_inode_cache\",\n\t\t\t\tsizeof(struct ufs_inode_info), 0,\n\t\t\t\t(SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD|\n\t\t\t\t\tSLAB_ACCOUNT),\n\t\t\t\toffsetof(struct ufs_inode_info, i_u1.i_symlink),\n\t\t\t\tsizeof_field(struct ufs_inode_info,\n\t\t\t\t\ti_u1.i_symlink),\n\t\t\t\tinit_once);\n\tif (ufs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(ufs_inode_cachep);\n}\n\nstatic const struct super_operations ufs_super_ops = {\n\t.alloc_inode\t= ufs_alloc_inode,\n\t.free_inode\t= ufs_free_in_core_inode,\n\t.write_inode\t= ufs_write_inode,\n\t.evict_inode\t= ufs_evict_inode,\n\t.put_super\t= ufs_put_super,\n\t.sync_fs\t= ufs_sync_fs,\n\t.statfs\t\t= ufs_statfs,\n\t.remount_fs\t= ufs_remount,\n\t.show_options   = ufs_show_options,\n};\n\nstatic struct dentry *ufs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ufs_fill_super);\n}\n\nstatic struct file_system_type ufs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ufs\",\n\t.mount\t\t= ufs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"ufs\");\n\nstatic int __init init_ufs_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&ufs_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}\n\nstatic void __exit exit_ufs_fs(void)\n{\n\tunregister_filesystem(&ufs_fs_type);\n\tdestroy_inodecache();\n}\n\nmodule_init(init_ufs_fs)\nmodule_exit(exit_ufs_fs)\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}