{
  "module_name": "balloc.c",
  "hash_id": "277ff4e921469084699c49261c8e2db81869c467916d88cce321f28420be9667",
  "original_prompt": "Ingested from linux-6.6.14/fs/ufs/balloc.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n#include <linux/capability.h>\n#include <linux/bitops.h>\n#include <linux/bio.h>\n#include <asm/byteorder.h>\n\n#include \"ufs_fs.h\"\n#include \"ufs.h\"\n#include \"swab.h\"\n#include \"util.h\"\n\n#define INVBLOCK ((u64)-1L)\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\nstatic unsigned char ufs_fragtable_8fpb[], ufs_fragtable_other[];\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\n \nvoid ufs_free_fragments(struct inode *inode, u64 fragment, unsigned count)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned cgno, bit, end_bit, bbase, blkmap, i;\n\tu64 blkno;\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tUFSD(\"ENTER, fragment %llu, count %u\\n\",\n\t     (unsigned long long)fragment, count);\n\t\n\tif (ufs_fragnum(fragment) + count > uspi->s_fpg)\n\t\tufs_error (sb, \"ufs_free_fragments\", \"internal error\");\n\n\tmutex_lock(&UFS_SB(sb)->s_lock);\n\t\n\tcgno = ufs_dtog(uspi, fragment);\n\tbit = ufs_dtogd(uspi, fragment);\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"freeing blocks are outside device\");\n\t\tgoto failed;\n\t}\n\t\t\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi) \n\t\tgoto failed;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"internal error, bad magic number on cg %u\", cgno);\n\t\tgoto failed;\n\t}\n\n\tend_bit = bit + count;\n\tbbase = ufs_blknum (bit);\n\tblkmap = ubh_blkmap (UCPI_UBH(ucpi), ucpi->c_freeoff, bbase);\n\tufs_fragacct (sb, blkmap, ucg->cg_frsum, -1);\n\tfor (i = bit; i < end_bit; i++) {\n\t\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_freeoff, i))\n\t\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_freeoff, i);\n\t\telse \n\t\t\tufs_error (sb, \"ufs_free_fragments\",\n\t\t\t\t   \"bit already cleared for fragment %u\", i);\n\t}\n\n\tinode_sub_bytes(inode, count << uspi->s_fshift);\n\tfs32_add(sb, &ucg->cg_cs.cs_nffree, count);\n\tuspi->cs_total.cs_nffree += count;\n\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, count);\n\tblkmap = ubh_blkmap (UCPI_UBH(ucpi), ucpi->c_freeoff, bbase);\n\tufs_fragacct(sb, blkmap, ucg->cg_frsum, 1);\n\n\t \n\tblkno = ufs_fragstoblks (bbase);\n\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno)) {\n\t\tfs32_sub(sb, &ucg->cg_cs.cs_nffree, uspi->s_fpb);\n\t\tuspi->cs_total.cs_nffree -= uspi->s_fpb;\n\t\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, uspi->s_fpb);\n\t\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\t\tufs_clusteracct (sb, ucpi, blkno, 1);\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nbfree, 1);\n\t\tuspi->cs_total.cs_nbfree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nbfree, 1);\n\t\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\t\tunsigned cylno = ufs_cbtocylno (bbase);\n\n\t\t\tfs16_add(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(bbase)), 1);\n\t\t\tfs32_add(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t\t}\n\t}\n\t\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & SB_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\tUFSD(\"EXIT\\n\");\n\treturn;\n\nfailed:\n\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn;\n}\n\n \nvoid ufs_free_blocks(struct inode *inode, u64 fragment, unsigned count)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned overflow, cgno, bit, end_bit, i;\n\tu64 blkno;\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tUFSD(\"ENTER, fragment %llu, count %u\\n\",\n\t     (unsigned long long)fragment, count);\n\t\n\tif ((fragment & uspi->s_fpbmask) || (count & uspi->s_fpbmask)) {\n\t\tufs_error (sb, \"ufs_free_blocks\", \"internal error, \"\n\t\t\t   \"fragment %llu, count %u\\n\",\n\t\t\t   (unsigned long long)fragment, count);\n\t\tgoto failed;\n\t}\n\n\tmutex_lock(&UFS_SB(sb)->s_lock);\n\t\ndo_more:\n\toverflow = 0;\n\tcgno = ufs_dtog(uspi, fragment);\n\tbit = ufs_dtogd(uspi, fragment);\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"freeing blocks are outside device\");\n\t\tgoto failed_unlock;\n\t}\n\tend_bit = bit + count;\n\tif (end_bit > uspi->s_fpg) {\n\t\toverflow = bit + count - uspi->s_fpg;\n\t\tcount -= overflow;\n\t\tend_bit -= overflow;\n\t}\n\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi) \n\t\tgoto failed_unlock;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"internal error, bad magic number on cg %u\", cgno);\n\t\tgoto failed_unlock;\n\t}\n\n\tfor (i = bit; i < end_bit; i += uspi->s_fpb) {\n\t\tblkno = ufs_fragstoblks(i);\n\t\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno)) {\n\t\t\tufs_error(sb, \"ufs_free_blocks\", \"freeing free fragment\");\n\t\t}\n\t\tubh_setblock(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno);\n\t\tinode_sub_bytes(inode, uspi->s_fpb << uspi->s_fshift);\n\t\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\t\tufs_clusteracct (sb, ucpi, blkno, 1);\n\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nbfree, 1);\n\t\tuspi->cs_total.cs_nbfree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nbfree, 1);\n\n\t\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\t\tunsigned cylno = ufs_cbtocylno(i);\n\n\t\t\tfs16_add(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(i)), 1);\n\t\t\tfs32_add(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t\t}\n\t}\n\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & SB_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\n\tif (overflow) {\n\t\tfragment += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\n\n\tufs_mark_sb_dirty(sb);\n\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\tUFSD(\"EXIT\\n\");\n\treturn;\n\nfailed_unlock:\n\tmutex_unlock(&UFS_SB(sb)->s_lock);\nfailed:\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn;\n}\n\n \nstatic void ufs_change_blocknr(struct inode *inode, sector_t beg,\n\t\t\t       unsigned int count, sector_t oldb,\n\t\t\t       sector_t newb, struct page *locked_page)\n{\n\tconst unsigned blks_per_page =\n\t\t1 << (PAGE_SHIFT - inode->i_blkbits);\n\tconst unsigned mask = blks_per_page - 1;\n\tstruct address_space * const mapping = inode->i_mapping;\n\tpgoff_t index, cur_index, last_index;\n\tunsigned pos, j, lblock;\n\tsector_t end, i;\n\tstruct page *page;\n\tstruct buffer_head *head, *bh;\n\n\tUFSD(\"ENTER, ino %lu, count %u, oldb %llu, newb %llu\\n\",\n\t      inode->i_ino, count,\n\t     (unsigned long long)oldb, (unsigned long long)newb);\n\n\tBUG_ON(!locked_page);\n\tBUG_ON(!PageLocked(locked_page));\n\n\tcur_index = locked_page->index;\n\tend = count + beg;\n\tlast_index = end >> (PAGE_SHIFT - inode->i_blkbits);\n\tfor (i = beg; i < end; i = (i | mask) + 1) {\n\t\tindex = i >> (PAGE_SHIFT - inode->i_blkbits);\n\n\t\tif (likely(cur_index != index)) {\n\t\t\tpage = ufs_get_locked_page(mapping, index);\n\t\t\tif (!page) \n\t\t\t\tcontinue;\n\t\t\tif (IS_ERR(page)) { \n\t\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t\t  \"read of page %llu failed\\n\",\n\t\t\t\t\t  (unsigned long long)index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else\n\t\t\tpage = locked_page;\n\n\t\thead = page_buffers(page);\n\t\tbh = head;\n\t\tpos = i & mask;\n\t\tfor (j = 0; j < pos; ++j)\n\t\t\tbh = bh->b_this_page;\n\n\n\t\tif (unlikely(index == last_index))\n\t\t\tlblock = end & mask;\n\t\telse\n\t\t\tlblock = blks_per_page;\n\n\t\tdo {\n\t\t\tif (j >= lblock)\n\t\t\t\tbreak;\n\t\t\tpos = (i - beg) + j;\n\n\t\t\tif (!buffer_mapped(bh))\n\t\t\t\t\tmap_bh(bh, inode->i_sb, oldb + pos);\n\t\t\tif (bh_read(bh, 0) < 0) {\n\t\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t\t  \"read of block failed\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tUFSD(\" change from %llu to %llu, pos %u\\n\",\n\t\t\t     (unsigned long long)(pos + oldb),\n\t\t\t     (unsigned long long)(pos + newb), pos);\n\n\t\t\tbh->b_blocknr = newb + pos;\n\t\t\tclean_bdev_bh_alias(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\t++j;\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\n\t\tif (likely(cur_index != index))\n\t\t\tufs_put_locked_page(page);\n \t}\n\tUFSD(\"EXIT\\n\");\n}\n\nstatic void ufs_clear_frags(struct inode *inode, sector_t beg, unsigned int n,\n\t\t\t    int sync)\n{\n\tstruct buffer_head *bh;\n\tsector_t end = beg + n;\n\n\tfor (; beg < end; ++beg) {\n\t\tbh = sb_getblk(inode->i_sb, beg);\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (IS_SYNC(inode) || sync)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n}\n\nu64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,\n\t\t\t   u64 goal, unsigned count, int *err,\n\t\t\t   struct page *locked_page)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tunsigned cgno, oldcount, newcount;\n\tu64 tmp, request, result;\n\t\n\tUFSD(\"ENTER, ino %lu, fragment %llu, goal %llu, count %u\\n\",\n\t     inode->i_ino, (unsigned long long)fragment,\n\t     (unsigned long long)goal, count);\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t*err = -ENOSPC;\n\n\tmutex_lock(&UFS_SB(sb)->s_lock);\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\n\tif (count + ufs_fragnum(fragment) > uspi->s_fpb) {\n\t\tufs_warning(sb, \"ufs_new_fragments\", \"internal warning\"\n\t\t\t    \" fragment %llu, count %u\",\n\t\t\t    (unsigned long long)fragment, count);\n\t\tcount = uspi->s_fpb - ufs_fragnum(fragment); \n\t}\n\toldcount = ufs_fragnum (fragment);\n\tnewcount = oldcount + count;\n\n\t \n\tif (oldcount) {\n\t\tif (!tmp) {\n\t\t\tufs_error(sb, \"ufs_new_fragments\", \"internal error, \"\n\t\t\t\t  \"fragment %llu, tmp %llu\\n\",\n\t\t\t\t  (unsigned long long)fragment,\n\t\t\t\t  (unsigned long long)tmp);\n\t\t\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\t\t\treturn INVBLOCK;\n\t\t}\n\t\tif (fragment < UFS_I(inode)->i_lastfrag) {\n\t\t\tUFSD(\"EXIT (ALREADY ALLOCATED)\\n\");\n\t\t\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tif (tmp) {\n\t\t\tUFSD(\"EXIT (ALREADY ALLOCATED)\\n\");\n\t\t\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (unlikely(ufs_freefrags(uspi) <= uspi->s_root_blocks)) {\n\t\tif (!capable(CAP_SYS_RESOURCE)) {\n\t\t\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\t\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (goal >= uspi->s_size) \n\t\tgoal = 0;\n\tif (goal == 0) \n\t\tcgno = ufs_inotocg (inode->i_ino);\n\telse\n\t\tcgno = ufs_dtog(uspi, goal);\n\t \n\t \n\tif (oldcount == 0) {\n\t\tresult = ufs_alloc_fragments (inode, cgno, goal, count, err);\n\t\tif (result) {\n\t\t\tufs_clear_frags(inode, result + oldcount,\n\t\t\t\t\tnewcount - oldcount, locked_page != NULL);\n\t\t\t*err = 0;\n\t\t\twrite_seqlock(&UFS_I(inode)->meta_lock);\n\t\t\tufs_cpu_to_data_ptr(sb, p, result);\n\t\t\tUFS_I(inode)->i_lastfrag =\n\t\t\t\tmax(UFS_I(inode)->i_lastfrag, fragment + count);\n\t\t\twrite_sequnlock(&UFS_I(inode)->meta_lock);\n\t\t}\n\t\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\t \n\tresult = ufs_add_fragments(inode, tmp, oldcount, newcount);\n\tif (result) {\n\t\t*err = 0;\n\t\tread_seqlock_excl(&UFS_I(inode)->meta_lock);\n\t\tUFS_I(inode)->i_lastfrag = max(UFS_I(inode)->i_lastfrag,\n\t\t\t\t\t\tfragment + count);\n\t\tread_sequnlock_excl(&UFS_I(inode)->meta_lock);\n\t\tufs_clear_frags(inode, result + oldcount, newcount - oldcount,\n\t\t\t\tlocked_page != NULL);\n\t\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\t \n\tif (fs32_to_cpu(sb, usb1->fs_optim) == UFS_OPTSPACE) {\n\t\trequest = newcount;\n\t\tif (uspi->cs_total.cs_nffree < uspi->s_space_to_time)\n\t\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t} else {\n\t\trequest = uspi->s_fpb;\n\t\tif (uspi->cs_total.cs_nffree > uspi->s_time_to_space)\n\t\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTSPACE);\n\t}\n\tresult = ufs_alloc_fragments (inode, cgno, goal, request, err);\n\tif (result) {\n\t\tufs_clear_frags(inode, result + oldcount, newcount - oldcount,\n\t\t\t\tlocked_page != NULL);\n\t\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\t\tufs_change_blocknr(inode, fragment - oldcount, oldcount,\n\t\t\t\t   uspi->s_sbbase + tmp,\n\t\t\t\t   uspi->s_sbbase + result, locked_page);\n\t\t*err = 0;\n\t\twrite_seqlock(&UFS_I(inode)->meta_lock);\n\t\tufs_cpu_to_data_ptr(sb, p, result);\n\t\tUFS_I(inode)->i_lastfrag = max(UFS_I(inode)->i_lastfrag,\n\t\t\t\t\t\tfragment + count);\n\t\twrite_sequnlock(&UFS_I(inode)->meta_lock);\n\t\tif (newcount < request)\n\t\t\tufs_free_fragments (inode, result + newcount, request - newcount);\n\t\tufs_free_fragments (inode, tmp, oldcount);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\tmutex_unlock(&UFS_SB(sb)->s_lock);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n}\t\t\n\nstatic bool try_add_frags(struct inode *inode, unsigned frags)\n{\n\tunsigned size = frags * i_blocksize(inode);\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, size);\n\tif (unlikely((u32)inode->i_blocks != inode->i_blocks)) {\n\t\t__inode_sub_bytes(inode, size);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn false;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn true;\n}\n\nstatic u64 ufs_add_fragments(struct inode *inode, u64 fragment,\n\t\t\t     unsigned oldcount, unsigned newcount)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned cgno, fragno, fragoff, count, fragsize, i;\n\t\n\tUFSD(\"ENTER, fragment %llu, oldcount %u, newcount %u\\n\",\n\t     (unsigned long long)fragment, oldcount, newcount);\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tcount = newcount - oldcount;\n\t\n\tcgno = ufs_dtog(uspi, fragment);\n\tif (fs32_to_cpu(sb, UFS_SB(sb)->fs_cs(cgno).cs_nffree) < count)\n\t\treturn 0;\n\tif ((ufs_fragnum (fragment) + newcount) > uspi->s_fpb)\n\t\treturn 0;\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi)\n\t\treturn 0;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_add_fragments\",\n\t\t\t\"internal error, bad magic number on cg %u\", cgno);\n\t\treturn 0;\n\t}\n\n\tfragno = ufs_dtogd(uspi, fragment);\n\tfragoff = ufs_fragnum (fragno);\n\tfor (i = oldcount; i < newcount; i++)\n\t\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_freeoff, fragno + i))\n\t\t\treturn 0;\n\n\tif (!try_add_frags(inode, count))\n\t\treturn 0;\n\t \n\tucg->cg_time = ufs_get_seconds(sb);\n\tfor (i = newcount; i < (uspi->s_fpb - fragoff); i++)\n\t\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_freeoff, fragno + i))\n\t\t\tbreak;\n\tfragsize = i - oldcount;\n\tif (!fs32_to_cpu(sb, ucg->cg_frsum[fragsize]))\n\t\tufs_panic (sb, \"ufs_add_fragments\",\n\t\t\t\"internal error or corrupted bitmap on cg %u\", cgno);\n\tfs32_sub(sb, &ucg->cg_frsum[fragsize], 1);\n\tif (fragsize != count)\n\t\tfs32_add(sb, &ucg->cg_frsum[fragsize - count], 1);\n\tfor (i = oldcount; i < newcount; i++)\n\t\tubh_clrbit (UCPI_UBH(ucpi), ucpi->c_freeoff, fragno + i);\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nffree, count);\n\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, count);\n\tuspi->cs_total.cs_nffree -= count;\n\t\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & SB_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tUFSD(\"EXIT, fragment %llu\\n\", (unsigned long long)fragment);\n\t\n\treturn fragment;\n}\n\n#define UFS_TEST_FREE_SPACE_CG \\\n\tucg = (struct ufs_cylinder_group *) UFS_SB(sb)->s_ucg[cgno]->b_data; \\\n\tif (fs32_to_cpu(sb, ucg->cg_cs.cs_nbfree)) \\\n\t\tgoto cg_found; \\\n\tfor (k = count; k < uspi->s_fpb; k++) \\\n\t\tif (fs32_to_cpu(sb, ucg->cg_frsum[k])) \\\n\t\t\tgoto cg_found; \n\nstatic u64 ufs_alloc_fragments(struct inode *inode, unsigned cgno,\n\t\t\t       u64 goal, unsigned count, int *err)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned oldcg, i, j, k, allocsize;\n\tu64 result;\n\t\n\tUFSD(\"ENTER, ino %lu, cgno %u, goal %llu, count %u\\n\",\n\t     inode->i_ino, cgno, (unsigned long long)goal, count);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\toldcg = cgno;\n\t\n\t \n\tUFS_TEST_FREE_SPACE_CG\n\n\t \n\tfor (j = 1; j < uspi->s_ncg; j *= 2) {\n\t\tcgno += j;\n\t\tif (cgno >= uspi->s_ncg) \n\t\t\tcgno -= uspi->s_ncg;\n\t\tUFS_TEST_FREE_SPACE_CG\n\t}\n\n\t \n\tcgno = (oldcg + 1) % uspi->s_ncg;\n\tfor (j = 2; j < uspi->s_ncg; j++) {\n\t\tcgno++;\n\t\tif (cgno >= uspi->s_ncg)\n\t\t\tcgno = 0;\n\t\tUFS_TEST_FREE_SPACE_CG\n\t}\n\t\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n\ncg_found:\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi)\n\t\treturn 0;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) \n\t\tufs_panic (sb, \"ufs_alloc_fragments\",\n\t\t\t\"internal error, bad magic number on cg %u\", cgno);\n\tucg->cg_time = ufs_get_seconds(sb);\n\n\tif (count == uspi->s_fpb) {\n\t\tresult = ufs_alloccg_block (inode, ucpi, goal, err);\n\t\tif (result == INVBLOCK)\n\t\t\treturn 0;\n\t\tgoto succed;\n\t}\n\n\tfor (allocsize = count; allocsize < uspi->s_fpb; allocsize++)\n\t\tif (fs32_to_cpu(sb, ucg->cg_frsum[allocsize]) != 0)\n\t\t\tbreak;\n\t\n\tif (allocsize == uspi->s_fpb) {\n\t\tresult = ufs_alloccg_block (inode, ucpi, goal, err);\n\t\tif (result == INVBLOCK)\n\t\t\treturn 0;\n\t\tgoal = ufs_dtogd(uspi, result);\n\t\tfor (i = count; i < uspi->s_fpb; i++)\n\t\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_freeoff, goal + i);\n\t\ti = uspi->s_fpb - count;\n\n\t\tinode_sub_bytes(inode, i << uspi->s_fshift);\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nffree, i);\n\t\tuspi->cs_total.cs_nffree += i;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, i);\n\t\tfs32_add(sb, &ucg->cg_frsum[i], 1);\n\t\tgoto succed;\n\t}\n\n\tresult = ufs_bitmap_search (sb, ucpi, goal, allocsize);\n\tif (result == INVBLOCK)\n\t\treturn 0;\n\tif (!try_add_frags(inode, count))\n\t\treturn 0;\n\tfor (i = 0; i < count; i++)\n\t\tubh_clrbit (UCPI_UBH(ucpi), ucpi->c_freeoff, result + i);\n\t\n\tfs32_sub(sb, &ucg->cg_cs.cs_nffree, count);\n\tuspi->cs_total.cs_nffree -= count;\n\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, count);\n\tfs32_sub(sb, &ucg->cg_frsum[allocsize], 1);\n\n\tif (count != allocsize)\n\t\tfs32_add(sb, &ucg->cg_frsum[allocsize - count], 1);\n\nsucced:\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & SB_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tresult += cgno * uspi->s_fpg;\n\tUFSD(\"EXIT3, result %llu\\n\", (unsigned long long)result);\n\treturn result;\n}\n\nstatic u64 ufs_alloccg_block(struct inode *inode,\n\t\t\t     struct ufs_cg_private_info *ucpi,\n\t\t\t     u64 goal, int *err)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cylinder_group * ucg;\n\tu64 result, blkno;\n\n\tUFSD(\"ENTER, goal %llu\\n\", (unsigned long long)goal);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\n\tif (goal == 0) {\n\t\tgoal = ucpi->c_rotor;\n\t\tgoto norot;\n\t}\n\tgoal = ufs_blknum (goal);\n\tgoal = ufs_dtogd(uspi, goal);\n\t\n\t \n\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, ufs_fragstoblks(goal))) {\n\t\tresult = goal;\n\t\tgoto gotit;\n\t}\n\t\nnorot:\t\n\tresult = ufs_bitmap_search (sb, ucpi, goal, uspi->s_fpb);\n\tif (result == INVBLOCK)\n\t\treturn INVBLOCK;\n\tucpi->c_rotor = result;\ngotit:\n\tif (!try_add_frags(inode, uspi->s_fpb))\n\t\treturn 0;\n\tblkno = ufs_fragstoblks(result);\n\tubh_clrblock (UCPI_UBH(ucpi), ucpi->c_freeoff, blkno);\n\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\tufs_clusteracct (sb, ucpi, blkno, -1);\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nbfree, 1);\n\tuspi->cs_total.cs_nbfree--;\n\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(ucpi->c_cgx).cs_nbfree, 1);\n\n\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\tunsigned cylno = ufs_cbtocylno((unsigned)result);\n\n\t\tfs16_sub(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t  ufs_cbtorpos((unsigned)result)), 1);\n\t\tfs32_sub(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t}\n\t\n\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\n\treturn result;\n}\n\nstatic unsigned ubh_scanc(struct ufs_sb_private_info *uspi,\n\t\t\t  struct ufs_buffer_head *ubh,\n\t\t\t  unsigned begin, unsigned size,\n\t\t\t  unsigned char *table, unsigned char mask)\n{\n\tunsigned rest, offset;\n\tunsigned char *cp;\n\t\n\n\toffset = begin & ~uspi->s_fmask;\n\tbegin >>= uspi->s_fshift;\n\tfor (;;) {\n\t\tif ((offset + size) < uspi->s_fsize)\n\t\t\trest = size;\n\t\telse\n\t\t\trest = uspi->s_fsize - offset;\n\t\tsize -= rest;\n\t\tcp = ubh->bh[begin]->b_data + offset;\n\t\twhile ((table[*cp++] & mask) == 0 && --rest)\n\t\t\t;\n\t\tif (rest || !size)\n\t\t\tbreak;\n\t\tbegin++;\n\t\toffset = 0;\n\t}\n\treturn (size + rest);\n}\n\n \nstatic u64 ufs_bitmap_search(struct super_block *sb,\n\t\t\t     struct ufs_cg_private_info *ucpi,\n\t\t\t     u64 goal, unsigned count)\n{\n\t \n\tstatic const int mask_arr[9] = {\n\t\t0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff, 0x1ff, 0x3ff\n\t};\n\tstatic const int want_arr[9] = {\n\t\t0x0, 0x2, 0x6, 0xe, 0x1e, 0x3e, 0x7e, 0xfe, 0x1fe\n\t};\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tunsigned start, length, loc;\n\tunsigned pos, want, blockmap, mask, end;\n\tu64 result;\n\n\tUFSD(\"ENTER, cg %u, goal %llu, count %u\\n\", ucpi->c_cgx,\n\t     (unsigned long long)goal, count);\n\n\tif (goal)\n\t\tstart = ufs_dtogd(uspi, goal) >> 3;\n\telse\n\t\tstart = ucpi->c_frotor >> 3;\n\t\t\n\tlength = ((uspi->s_fpg + 7) >> 3) - start;\n\tloc = ubh_scanc(uspi, UCPI_UBH(ucpi), ucpi->c_freeoff + start, length,\n\t\t(uspi->s_fpb == 8) ? ufs_fragtable_8fpb : ufs_fragtable_other,\n\t\t1 << (count - 1 + (uspi->s_fpb & 7))); \n\tif (loc == 0) {\n\t\tlength = start + 1;\n\t\tloc = ubh_scanc(uspi, UCPI_UBH(ucpi), ucpi->c_freeoff, length,\n\t\t\t\t(uspi->s_fpb == 8) ? ufs_fragtable_8fpb :\n\t\t\t\tufs_fragtable_other,\n\t\t\t\t1 << (count - 1 + (uspi->s_fpb & 7)));\n\t\tif (loc == 0) {\n\t\t\tufs_error(sb, \"ufs_bitmap_search\",\n\t\t\t\t  \"bitmap corrupted on cg %u, start %u,\"\n\t\t\t\t  \" length %u, count %u, freeoff %u\\n\",\n\t\t\t\t  ucpi->c_cgx, start, length, count,\n\t\t\t\t  ucpi->c_freeoff);\n\t\t\treturn INVBLOCK;\n\t\t}\n\t\tstart = 0;\n\t}\n\tresult = (start + length - loc) << 3;\n\tucpi->c_frotor = result;\n\n\t \n\n\tfor (end = result + 8; result < end; result += uspi->s_fpb) {\n\t\tblockmap = ubh_blkmap(UCPI_UBH(ucpi), ucpi->c_freeoff, result);\n\t\tblockmap <<= 1;\n\t\tmask = mask_arr[count];\n\t\twant = want_arr[count];\n\t\tfor (pos = 0; pos <= uspi->s_fpb - count; pos++) {\n\t\t\tif ((blockmap & mask) == want) {\n\t\t\t\tUFSD(\"EXIT, result %llu\\n\",\n\t\t\t\t     (unsigned long long)result);\n\t\t\t\treturn result + pos;\n \t\t\t}\n\t\t\tmask <<= 1;\n\t\t\twant <<= 1;\n \t\t}\n \t}\n\n\tufs_error(sb, \"ufs_bitmap_search\", \"block not in map on cg %u\\n\",\n\t\t  ucpi->c_cgx);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn INVBLOCK;\n}\n\nstatic void ufs_clusteracct(struct super_block * sb,\n\tstruct ufs_cg_private_info * ucpi, unsigned blkno, int cnt)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tint i, start, end, forw, back;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tif (uspi->s_contigsumsize <= 0)\n\t\treturn;\n\n\tif (cnt > 0)\n\t\tubh_setbit(UCPI_UBH(ucpi), ucpi->c_clusteroff, blkno);\n\telse\n\t\tubh_clrbit(UCPI_UBH(ucpi), ucpi->c_clusteroff, blkno);\n\n\t \n\tstart = blkno + 1;\n\tend = start + uspi->s_contigsumsize;\n\tif ( end >= ucpi->c_nclusterblks)\n\t\tend = ucpi->c_nclusterblks;\n\ti = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_clusteroff, end, start);\n\tif (i > end)\n\t\ti = end;\n\tforw = i - start;\n\t\n\t \n\tstart = blkno - 1;\n\tend = start - uspi->s_contigsumsize;\n\tif (end < 0 ) \n\t\tend = -1;\n\ti = ubh_find_last_zero_bit (UCPI_UBH(ucpi), ucpi->c_clusteroff, start, end);\n\tif ( i < end) \n\t\ti = end;\n\tback = start - i;\n\t\n\t \n\ti = back + forw + 1;\n\tif (i > uspi->s_contigsumsize)\n\t\ti = uspi->s_contigsumsize;\n\tfs32_add(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (i << 2)), cnt);\n\tif (back > 0)\n\t\tfs32_sub(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (back << 2)), cnt);\n\tif (forw > 0)\n\t\tfs32_sub(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (forw << 2)), cnt);\n}\n\n\nstatic unsigned char ufs_fragtable_8fpb[] = {\n\t0x00, 0x01, 0x01, 0x02, 0x01, 0x01, 0x02, 0x04, 0x01, 0x01, 0x01, 0x03, 0x02, 0x03, 0x04, 0x08,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x02, 0x03, 0x03, 0x02, 0x04, 0x05, 0x08, 0x10,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x04, 0x05, 0x05, 0x06, 0x08, 0x09, 0x10, 0x20,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\t\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x03, 0x03, 0x03, 0x03, 0x05, 0x05, 0x09, 0x11,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x03, 0x03, 0x03, 0x03, 0x02, 0x03, 0x06, 0x0A,\n\t0x04, 0x05, 0x05, 0x06, 0x05, 0x05, 0x06, 0x04, 0x08, 0x09, 0x09, 0x0A, 0x10, 0x11, 0x20, 0x40,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x03, 0x03, 0x03, 0x03, 0x05, 0x05, 0x09, 0x11,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x05, 0x05, 0x05, 0x07, 0x09, 0x09, 0x11, 0x21,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x03, 0x03, 0x03, 0x03, 0x02, 0x03, 0x06, 0x0A,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x02, 0x03, 0x03, 0x02, 0x06, 0x07, 0x0A, 0x12,\n\t0x04, 0x05, 0x05, 0x06, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x05, 0x07, 0x06, 0x07, 0x04, 0x0C,\n\t0x08, 0x09, 0x09, 0x0A, 0x09, 0x09, 0x0A, 0x0C, 0x10, 0x11, 0x11, 0x12, 0x20, 0x21, 0x40, 0x80,\n};\n\nstatic unsigned char ufs_fragtable_other[] = {\n\t0x00, 0x16, 0x16, 0x2A, 0x16, 0x16, 0x26, 0x4E, 0x16, 0x16, 0x16, 0x3E, 0x2A, 0x3E, 0x4E, 0x8A,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x2A, 0x3E, 0x3E, 0x2A, 0x3E, 0x3E, 0x2E, 0x6E, 0x3E, 0x3E, 0x3E, 0x3E, 0x2A, 0x3E, 0x6E, 0xAA,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x26, 0x36, 0x36, 0x2E, 0x36, 0x36, 0x26, 0x6E, 0x36, 0x36, 0x36, 0x3E, 0x2E, 0x3E, 0x6E, 0xAE,\n\t0x4E, 0x5E, 0x5E, 0x6E, 0x5E, 0x5E, 0x6E, 0x4E, 0x5E, 0x5E, 0x5E, 0x7E, 0x6E, 0x7E, 0x4E, 0xCE,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0xBE,\n\t0x2A, 0x3E, 0x3E, 0x2A, 0x3E, 0x3E, 0x2E, 0x6E, 0x3E, 0x3E, 0x3E, 0x3E, 0x2A, 0x3E, 0x6E, 0xAA,\n\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E,\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0xBE,\n\t0x4E, 0x5E, 0x5E, 0x6E, 0x5E, 0x5E, 0x6E, 0x4E, 0x5E, 0x5E, 0x5E, 0x7E, 0x6E, 0x7E, 0x4E, 0xCE,\n\t0x8A, 0x9E, 0x9E, 0xAA, 0x9E, 0x9E, 0xAE, 0xCE, 0x9E, 0x9E, 0x9E, 0xBE, 0xAA, 0xBE, 0xCE, 0x8A,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}