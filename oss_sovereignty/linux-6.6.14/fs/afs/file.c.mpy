{
  "module_name": "file.c",
  "hash_id": "ce68cca73ee80461cc65456d940bd88027634c1c2bba9c3303df33163f09999f",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/file.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/gfp.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/mm.h>\n#include <linux/swap.h>\n#include <linux/netfs.h>\n#include \"internal.h\"\n\nstatic int afs_file_mmap(struct file *file, struct vm_area_struct *vma);\nstatic int afs_symlink_read_folio(struct file *file, struct folio *folio);\nstatic void afs_invalidate_folio(struct folio *folio, size_t offset,\n\t\t\t       size_t length);\nstatic bool afs_release_folio(struct folio *folio, gfp_t gfp_flags);\n\nstatic ssize_t afs_file_read_iter(struct kiocb *iocb, struct iov_iter *iter);\nstatic ssize_t afs_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t    struct pipe_inode_info *pipe,\n\t\t\t\t    size_t len, unsigned int flags);\nstatic void afs_vm_open(struct vm_area_struct *area);\nstatic void afs_vm_close(struct vm_area_struct *area);\nstatic vm_fault_t afs_vm_map_pages(struct vm_fault *vmf, pgoff_t start_pgoff, pgoff_t end_pgoff);\n\nconst struct file_operations afs_file_operations = {\n\t.open\t\t= afs_open,\n\t.release\t= afs_release,\n\t.llseek\t\t= generic_file_llseek,\n\t.read_iter\t= afs_file_read_iter,\n\t.write_iter\t= afs_file_write,\n\t.mmap\t\t= afs_file_mmap,\n\t.splice_read\t= afs_file_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n\t.fsync\t\t= afs_fsync,\n\t.lock\t\t= afs_lock,\n\t.flock\t\t= afs_flock,\n};\n\nconst struct inode_operations afs_file_inode_operations = {\n\t.getattr\t= afs_getattr,\n\t.setattr\t= afs_setattr,\n\t.permission\t= afs_permission,\n};\n\nconst struct address_space_operations afs_file_aops = {\n\t.read_folio\t= netfs_read_folio,\n\t.readahead\t= netfs_readahead,\n\t.dirty_folio\t= afs_dirty_folio,\n\t.launder_folio\t= afs_launder_folio,\n\t.release_folio\t= afs_release_folio,\n\t.invalidate_folio = afs_invalidate_folio,\n\t.write_begin\t= afs_write_begin,\n\t.write_end\t= afs_write_end,\n\t.writepages\t= afs_writepages,\n\t.migrate_folio\t= filemap_migrate_folio,\n};\n\nconst struct address_space_operations afs_symlink_aops = {\n\t.read_folio\t= afs_symlink_read_folio,\n\t.release_folio\t= afs_release_folio,\n\t.invalidate_folio = afs_invalidate_folio,\n\t.migrate_folio\t= filemap_migrate_folio,\n};\n\nstatic const struct vm_operations_struct afs_vm_ops = {\n\t.open\t\t= afs_vm_open,\n\t.close\t\t= afs_vm_close,\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= afs_vm_map_pages,\n\t.page_mkwrite\t= afs_page_mkwrite,\n};\n\n \nvoid afs_put_wb_key(struct afs_wb_key *wbk)\n{\n\tif (wbk && refcount_dec_and_test(&wbk->usage)) {\n\t\tkey_put(wbk->key);\n\t\tkfree(wbk);\n\t}\n}\n\n \nint afs_cache_wb_key(struct afs_vnode *vnode, struct afs_file *af)\n{\n\tstruct afs_wb_key *wbk, *p;\n\n\twbk = kzalloc(sizeof(struct afs_wb_key), GFP_KERNEL);\n\tif (!wbk)\n\t\treturn -ENOMEM;\n\trefcount_set(&wbk->usage, 2);\n\twbk->key = af->key;\n\n\tspin_lock(&vnode->wb_lock);\n\tlist_for_each_entry(p, &vnode->wb_keys, vnode_link) {\n\t\tif (p->key == wbk->key)\n\t\t\tgoto found;\n\t}\n\n\tkey_get(wbk->key);\n\tlist_add_tail(&wbk->vnode_link, &vnode->wb_keys);\n\tspin_unlock(&vnode->wb_lock);\n\taf->wb = wbk;\n\treturn 0;\n\nfound:\n\trefcount_inc(&p->usage);\n\tspin_unlock(&vnode->wb_lock);\n\taf->wb = p;\n\tkfree(wbk);\n\treturn 0;\n}\n\n \nint afs_open(struct inode *inode, struct file *file)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct afs_file *af;\n\tstruct key *key;\n\tint ret;\n\n\t_enter(\"{%llx:%llu},\", vnode->fid.vid, vnode->fid.vnode);\n\n\tkey = afs_request_key(vnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error;\n\t}\n\n\taf = kzalloc(sizeof(*af), GFP_KERNEL);\n\tif (!af) {\n\t\tret = -ENOMEM;\n\t\tgoto error_key;\n\t}\n\taf->key = key;\n\n\tret = afs_validate(vnode, key);\n\tif (ret < 0)\n\t\tgoto error_af;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tret = afs_cache_wb_key(vnode, af);\n\t\tif (ret < 0)\n\t\t\tgoto error_af;\n\t}\n\n\tif (file->f_flags & O_TRUNC)\n\t\tset_bit(AFS_VNODE_NEW_CONTENT, &vnode->flags);\n\n\tfscache_use_cookie(afs_vnode_cache(vnode), file->f_mode & FMODE_WRITE);\n\n\tfile->private_data = af;\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_af:\n\tkfree(af);\nerror_key:\n\tkey_put(key);\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nint afs_release(struct inode *inode, struct file *file)\n{\n\tstruct afs_vnode_cache_aux aux;\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct afs_file *af = file->private_data;\n\tloff_t i_size;\n\tint ret = 0;\n\n\t_enter(\"{%llx:%llu},\", vnode->fid.vid, vnode->fid.vnode);\n\n\tif ((file->f_mode & FMODE_WRITE))\n\t\tret = vfs_fsync(file, 0);\n\n\tfile->private_data = NULL;\n\tif (af->wb)\n\t\tafs_put_wb_key(af->wb);\n\n\tif ((file->f_mode & FMODE_WRITE)) {\n\t\ti_size = i_size_read(&vnode->netfs.inode);\n\t\tafs_set_cache_aux(vnode, &aux);\n\t\tfscache_unuse_cookie(afs_vnode_cache(vnode), &aux, &i_size);\n\t} else {\n\t\tfscache_unuse_cookie(afs_vnode_cache(vnode), NULL, NULL);\n\t}\n\n\tkey_put(af->key);\n\tkfree(af);\n\tafs_prune_wb_keys(vnode);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nstruct afs_read *afs_alloc_read(gfp_t gfp)\n{\n\tstruct afs_read *req;\n\n\treq = kzalloc(sizeof(struct afs_read), gfp);\n\tif (req)\n\t\trefcount_set(&req->usage, 1);\n\n\treturn req;\n}\n\n \nvoid afs_put_read(struct afs_read *req)\n{\n\tif (refcount_dec_and_test(&req->usage)) {\n\t\tif (req->cleanup)\n\t\t\treq->cleanup(req);\n\t\tkey_put(req->key);\n\t\tkfree(req);\n\t}\n}\n\nstatic void afs_fetch_data_notify(struct afs_operation *op)\n{\n\tstruct afs_read *req = op->fetch.req;\n\tstruct netfs_io_subrequest *subreq = req->subreq;\n\tint error = op->error;\n\n\tif (error == -ECONNABORTED)\n\t\terror = afs_abort_to_error(op->ac.abort_code);\n\treq->error = error;\n\n\tif (subreq) {\n\t\t__set_bit(NETFS_SREQ_CLEAR_TAIL, &subreq->flags);\n\t\tnetfs_subreq_terminated(subreq, error ?: req->actual_len, false);\n\t\treq->subreq = NULL;\n\t} else if (req->done) {\n\t\treq->done(req);\n\t}\n}\n\nstatic void afs_fetch_data_success(struct afs_operation *op)\n{\n\tstruct afs_vnode *vnode = op->file[0].vnode;\n\n\t_enter(\"op=%08x\", op->debug_id);\n\tafs_vnode_commit_status(op, &op->file[0]);\n\tafs_stat_v(vnode, n_fetches);\n\tatomic_long_add(op->fetch.req->actual_len, &op->net->n_fetch_bytes);\n\tafs_fetch_data_notify(op);\n}\n\nstatic void afs_fetch_data_put(struct afs_operation *op)\n{\n\top->fetch.req->error = op->error;\n\tafs_put_read(op->fetch.req);\n}\n\nstatic const struct afs_operation_ops afs_fetch_data_operation = {\n\t.issue_afs_rpc\t= afs_fs_fetch_data,\n\t.issue_yfs_rpc\t= yfs_fs_fetch_data,\n\t.success\t= afs_fetch_data_success,\n\t.aborted\t= afs_check_for_remote_deletion,\n\t.failed\t\t= afs_fetch_data_notify,\n\t.put\t\t= afs_fetch_data_put,\n};\n\n \nint afs_fetch_data(struct afs_vnode *vnode, struct afs_read *req)\n{\n\tstruct afs_operation *op;\n\n\t_enter(\"%s{%llx:%llu.%u},%x,,,\",\n\t       vnode->volume->name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(req->key));\n\n\top = afs_alloc_operation(req->key, vnode->volume);\n\tif (IS_ERR(op)) {\n\t\tif (req->subreq)\n\t\t\tnetfs_subreq_terminated(req->subreq, PTR_ERR(op), false);\n\t\treturn PTR_ERR(op);\n\t}\n\n\tafs_op_set_vnode(op, 0, vnode);\n\n\top->fetch.req\t= afs_get_read(req);\n\top->ops\t\t= &afs_fetch_data_operation;\n\treturn afs_do_sync_operation(op);\n}\n\nstatic void afs_issue_read(struct netfs_io_subrequest *subreq)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(subreq->rreq->inode);\n\tstruct afs_read *fsreq;\n\n\tfsreq = afs_alloc_read(GFP_NOFS);\n\tif (!fsreq)\n\t\treturn netfs_subreq_terminated(subreq, -ENOMEM, false);\n\n\tfsreq->subreq\t= subreq;\n\tfsreq->pos\t= subreq->start + subreq->transferred;\n\tfsreq->len\t= subreq->len   - subreq->transferred;\n\tfsreq->key\t= key_get(subreq->rreq->netfs_priv);\n\tfsreq->vnode\t= vnode;\n\tfsreq->iter\t= &fsreq->def_iter;\n\n\tiov_iter_xarray(&fsreq->def_iter, ITER_DEST,\n\t\t\t&fsreq->vnode->netfs.inode.i_mapping->i_pages,\n\t\t\tfsreq->pos, fsreq->len);\n\n\tafs_fetch_data(fsreq->vnode, fsreq);\n\tafs_put_read(fsreq);\n}\n\nstatic int afs_symlink_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(folio->mapping->host);\n\tstruct afs_read *fsreq;\n\tint ret;\n\n\tfsreq = afs_alloc_read(GFP_NOFS);\n\tif (!fsreq)\n\t\treturn -ENOMEM;\n\n\tfsreq->pos\t= folio_pos(folio);\n\tfsreq->len\t= folio_size(folio);\n\tfsreq->vnode\t= vnode;\n\tfsreq->iter\t= &fsreq->def_iter;\n\tiov_iter_xarray(&fsreq->def_iter, ITER_DEST, &folio->mapping->i_pages,\n\t\t\tfsreq->pos, fsreq->len);\n\n\tret = afs_fetch_data(fsreq->vnode, fsreq);\n\tif (ret == 0)\n\t\tfolio_mark_uptodate(folio);\n\tfolio_unlock(folio);\n\treturn ret;\n}\n\nstatic int afs_init_request(struct netfs_io_request *rreq, struct file *file)\n{\n\trreq->netfs_priv = key_get(afs_file_key(file));\n\treturn 0;\n}\n\nstatic int afs_begin_cache_operation(struct netfs_io_request *rreq)\n{\n#ifdef CONFIG_AFS_FSCACHE\n\tstruct afs_vnode *vnode = AFS_FS_I(rreq->inode);\n\n\treturn fscache_begin_read_operation(&rreq->cache_resources,\n\t\t\t\t\t    afs_vnode_cache(vnode));\n#else\n\treturn -ENOBUFS;\n#endif\n}\n\nstatic int afs_check_write_begin(struct file *file, loff_t pos, unsigned len,\n\t\t\t\t struct folio **foliop, void **_fsdata)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(file));\n\n\treturn test_bit(AFS_VNODE_DELETED, &vnode->flags) ? -ESTALE : 0;\n}\n\nstatic void afs_free_request(struct netfs_io_request *rreq)\n{\n\tkey_put(rreq->netfs_priv);\n}\n\nconst struct netfs_request_ops afs_req_ops = {\n\t.init_request\t\t= afs_init_request,\n\t.free_request\t\t= afs_free_request,\n\t.begin_cache_operation\t= afs_begin_cache_operation,\n\t.check_write_begin\t= afs_check_write_begin,\n\t.issue_read\t\t= afs_issue_read,\n};\n\nint afs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tfscache_unpin_writeback(wbc, afs_vnode_cache(AFS_FS_I(inode)));\n\treturn 0;\n}\n\n \nstatic void afs_invalidate_dirty(struct folio *folio, size_t offset,\n\t\t\t\t size_t length)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(folio_inode(folio));\n\tunsigned long priv;\n\tunsigned int f, t, end = offset + length;\n\n\tpriv = (unsigned long)folio_get_private(folio);\n\n\t \n\tif (offset == 0 && length == folio_size(folio))\n\t\tgoto full_invalidate;\n\n\t  \n\tif (afs_is_folio_dirty_mmapped(priv))\n\t\treturn;\n\n\t \n\tf = afs_folio_dirty_from(folio, priv);\n\tt = afs_folio_dirty_to(folio, priv);\n\n\tif (t <= offset || f >= end)\n\t\treturn;  \n\n\tif (f < offset && t > end)\n\t\treturn;  \n\n\tif (f >= offset && t <= end)\n\t\tgoto undirty;\n\n\tif (f < offset)\n\t\tt = offset;\n\telse\n\t\tf = end;\n\tif (f == t)\n\t\tgoto undirty;\n\n\tpriv = afs_folio_dirty(folio, f, t);\n\tfolio_change_private(folio, (void *)priv);\n\ttrace_afs_folio_dirty(vnode, tracepoint_string(\"trunc\"), folio);\n\treturn;\n\nundirty:\n\ttrace_afs_folio_dirty(vnode, tracepoint_string(\"undirty\"), folio);\n\tfolio_clear_dirty_for_io(folio);\nfull_invalidate:\n\ttrace_afs_folio_dirty(vnode, tracepoint_string(\"inval\"), folio);\n\tfolio_detach_private(folio);\n}\n\n \nstatic void afs_invalidate_folio(struct folio *folio, size_t offset,\n\t\t\t       size_t length)\n{\n\t_enter(\"{%lu},%zu,%zu\", folio->index, offset, length);\n\n\tBUG_ON(!folio_test_locked(folio));\n\n\tif (folio_get_private(folio))\n\t\tafs_invalidate_dirty(folio, offset, length);\n\n\tfolio_wait_fscache(folio);\n\t_leave(\"\");\n}\n\n \nstatic bool afs_release_folio(struct folio *folio, gfp_t gfp)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(folio_inode(folio));\n\n\t_enter(\"{{%llx:%llu}[%lu],%lx},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, folio_index(folio), folio->flags,\n\t       gfp);\n\n\t \n#ifdef CONFIG_AFS_FSCACHE\n\tif (folio_test_fscache(folio)) {\n\t\tif (current_is_kswapd() || !(gfp & __GFP_FS))\n\t\t\treturn false;\n\t\tfolio_wait_fscache(folio);\n\t}\n\tfscache_note_page_release(afs_vnode_cache(vnode));\n#endif\n\n\tif (folio_test_private(folio)) {\n\t\ttrace_afs_folio_dirty(vnode, tracepoint_string(\"rel\"), folio);\n\t\tfolio_detach_private(folio);\n\t}\n\n\t \n\t_leave(\" = T\");\n\treturn true;\n}\n\nstatic void afs_add_open_mmap(struct afs_vnode *vnode)\n{\n\tif (atomic_inc_return(&vnode->cb_nr_mmap) == 1) {\n\t\tdown_write(&vnode->volume->cell->fs_open_mmaps_lock);\n\n\t\tif (list_empty(&vnode->cb_mmap_link))\n\t\t\tlist_add_tail(&vnode->cb_mmap_link,\n\t\t\t\t      &vnode->volume->cell->fs_open_mmaps);\n\n\t\tup_write(&vnode->volume->cell->fs_open_mmaps_lock);\n\t}\n}\n\nstatic void afs_drop_open_mmap(struct afs_vnode *vnode)\n{\n\tif (!atomic_dec_and_test(&vnode->cb_nr_mmap))\n\t\treturn;\n\n\tdown_write(&vnode->volume->cell->fs_open_mmaps_lock);\n\n\tif (atomic_read(&vnode->cb_nr_mmap) == 0)\n\t\tlist_del_init(&vnode->cb_mmap_link);\n\n\tup_write(&vnode->volume->cell->fs_open_mmaps_lock);\n\tflush_work(&vnode->cb_work);\n}\n\n \nstatic int afs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(file));\n\tint ret;\n\n\tafs_add_open_mmap(vnode);\n\n\tret = generic_file_mmap(file, vma);\n\tif (ret == 0)\n\t\tvma->vm_ops = &afs_vm_ops;\n\telse\n\t\tafs_drop_open_mmap(vnode);\n\treturn ret;\n}\n\nstatic void afs_vm_open(struct vm_area_struct *vma)\n{\n\tafs_add_open_mmap(AFS_FS_I(file_inode(vma->vm_file)));\n}\n\nstatic void afs_vm_close(struct vm_area_struct *vma)\n{\n\tafs_drop_open_mmap(AFS_FS_I(file_inode(vma->vm_file)));\n}\n\nstatic vm_fault_t afs_vm_map_pages(struct vm_fault *vmf, pgoff_t start_pgoff, pgoff_t end_pgoff)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(vmf->vma->vm_file));\n\n\tif (afs_pagecache_valid(vnode))\n\t\treturn filemap_map_pages(vmf, start_pgoff, end_pgoff);\n\treturn 0;\n}\n\nstatic ssize_t afs_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(iocb->ki_filp));\n\tstruct afs_file *af = iocb->ki_filp->private_data;\n\tint ret;\n\n\tret = afs_validate(vnode, af->key);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn generic_file_read_iter(iocb, iter);\n}\n\nstatic ssize_t afs_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t    struct pipe_inode_info *pipe,\n\t\t\t\t    size_t len, unsigned int flags)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(in));\n\tstruct afs_file *af = in->private_data;\n\tint ret;\n\n\tret = afs_validate(vnode, af->key);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn filemap_splice_read(in, ppos, pipe, len, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}