{
  "module_name": "rotate.c",
  "hash_id": "a84331ce64b628d3e3d10b5097ef6ad4f23fdacca24d15a9bd62f55becc1856a",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/rotate.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/sched/signal.h>\n#include \"internal.h\"\n#include \"afs_fs.h\"\n\n \nstatic bool afs_start_fs_iteration(struct afs_operation *op,\n\t\t\t\t   struct afs_vnode *vnode)\n{\n\tstruct afs_server *server;\n\tvoid *cb_server;\n\tint i;\n\n\tread_lock(&op->volume->servers_lock);\n\top->server_list = afs_get_serverlist(\n\t\trcu_dereference_protected(op->volume->servers,\n\t\t\t\t\t  lockdep_is_held(&op->volume->servers_lock)));\n\tread_unlock(&op->volume->servers_lock);\n\n\top->untried = (1UL << op->server_list->nr_servers) - 1;\n\top->index = READ_ONCE(op->server_list->preferred);\n\n\tcb_server = vnode->cb_server;\n\tif (cb_server) {\n\t\t \n\t\tfor (i = 0; i < op->server_list->nr_servers; i++) {\n\t\t\tserver = op->server_list->servers[i].server;\n\t\t\tif (server == cb_server) {\n\t\t\t\top->index = i;\n\t\t\t\tgoto found_interest;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (op->flags & AFS_OPERATION_CUR_ONLY) {\n\t\t\top->error = -ESTALE;\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\twrite_seqlock(&vnode->cb_lock);\n\t\tASSERTCMP(cb_server, ==, vnode->cb_server);\n\t\tvnode->cb_server = NULL;\n\t\tif (test_and_clear_bit(AFS_VNODE_CB_PROMISED, &vnode->flags))\n\t\t\tvnode->cb_break++;\n\t\twrite_sequnlock(&vnode->cb_lock);\n\t}\n\nfound_interest:\n\treturn true;\n}\n\n \nstatic void afs_busy(struct afs_volume *volume, u32 abort_code)\n{\n\tconst char *m;\n\n\tswitch (abort_code) {\n\tcase VOFFLINE:\t\tm = \"offline\";\t\tbreak;\n\tcase VRESTARTING:\tm = \"restarting\";\tbreak;\n\tcase VSALVAGING:\tm = \"being salvaged\";\tbreak;\n\tdefault:\t\tm = \"busy\";\t\tbreak;\n\t}\n\n\tpr_notice(\"kAFS: Volume %llu '%s' is %s\\n\", volume->vid, volume->name, m);\n}\n\n \nstatic bool afs_sleep_and_retry(struct afs_operation *op)\n{\n\tif (!(op->flags & AFS_OPERATION_UNINTR)) {\n\t\tmsleep_interruptible(1000);\n\t\tif (signal_pending(current)) {\n\t\t\top->error = -ERESTARTSYS;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tmsleep(1000);\n\t}\n\n\treturn true;\n}\n\n \nbool afs_select_fileserver(struct afs_operation *op)\n{\n\tstruct afs_addr_list *alist;\n\tstruct afs_server *server;\n\tstruct afs_vnode *vnode = op->file[0].vnode;\n\tstruct afs_error e;\n\tu32 rtt;\n\tint error = op->ac.error, i;\n\n\t_enter(\"%lx[%d],%lx[%d],%d,%d\",\n\t       op->untried, op->index,\n\t       op->ac.tried, op->ac.index,\n\t       error, op->ac.abort_code);\n\n\tif (op->flags & AFS_OPERATION_STOP) {\n\t\t_leave(\" = f [stopped]\");\n\t\treturn false;\n\t}\n\n\top->nr_iterations++;\n\n\t \n\tswitch (error) {\n\tcase SHRT_MAX:\n\t\tgoto start;\n\n\tcase 0:\n\tdefault:\n\t\t \n\t\top->error = error;\n\t\top->flags |= AFS_OPERATION_STOP;\n\t\t_leave(\" = f [okay/local %d]\", error);\n\t\treturn false;\n\n\tcase -ECONNABORTED:\n\t\t \n\t\tswitch (op->ac.abort_code) {\n\t\tcase VNOVOL:\n\t\t\t \n\t\t\tif (op->flags & AFS_OPERATION_VNOVOL) {\n\t\t\t\top->error = -EREMOTEIO;\n\t\t\t\tgoto next_server;\n\t\t\t}\n\n\t\t\twrite_lock(&op->volume->servers_lock);\n\t\t\top->server_list->vnovol_mask |= 1 << op->index;\n\t\t\twrite_unlock(&op->volume->servers_lock);\n\n\t\t\tset_bit(AFS_VOLUME_NEEDS_UPDATE, &op->volume->flags);\n\t\t\terror = afs_check_volume_status(op->volume, op);\n\t\t\tif (error < 0)\n\t\t\t\tgoto failed_set_error;\n\n\t\t\tif (test_bit(AFS_VOLUME_DELETED, &op->volume->flags)) {\n\t\t\t\top->error = -ENOMEDIUM;\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (rcu_access_pointer(op->volume->servers) == op->server_list) {\n\t\t\t\top->error = -EREMOTEIO;\n\t\t\t\tgoto next_server;\n\t\t\t}\n\n\t\t\t \n\t\t\top->flags |= AFS_OPERATION_VNOVOL;\n\t\t\t_leave(\" = t [vnovol]\");\n\t\t\treturn true;\n\n\t\tcase VSALVAGE:  \n\t\tcase VVOLEXISTS:\n\t\tcase VNOSERVICE:\n\t\tcase VONLINE:\n\t\tcase VDISKFULL:\n\t\tcase VOVERQUOTA:\n\t\t\top->error = afs_abort_to_error(op->ac.abort_code);\n\t\t\tgoto next_server;\n\n\t\tcase VOFFLINE:\n\t\t\tif (!test_and_set_bit(AFS_VOLUME_OFFLINE, &op->volume->flags)) {\n\t\t\t\tafs_busy(op->volume, op->ac.abort_code);\n\t\t\t\tclear_bit(AFS_VOLUME_BUSY, &op->volume->flags);\n\t\t\t}\n\t\t\tif (op->flags & AFS_OPERATION_NO_VSLEEP) {\n\t\t\t\top->error = -EADV;\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tif (op->flags & AFS_OPERATION_CUR_ONLY) {\n\t\t\t\top->error = -ESTALE;\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tgoto busy;\n\n\t\tcase VSALVAGING:\n\t\tcase VRESTARTING:\n\t\tcase VBUSY:\n\t\t\t \n\t\t\tif (op->flags & AFS_OPERATION_NO_VSLEEP) {\n\t\t\t\top->error = -EBUSY;\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tif (!test_and_set_bit(AFS_VOLUME_BUSY, &op->volume->flags)) {\n\t\t\t\tafs_busy(op->volume, op->ac.abort_code);\n\t\t\t\tclear_bit(AFS_VOLUME_OFFLINE, &op->volume->flags);\n\t\t\t}\n\t\tbusy:\n\t\t\tif (op->flags & AFS_OPERATION_CUR_ONLY) {\n\t\t\t\tif (!afs_sleep_and_retry(op))\n\t\t\t\t\tgoto failed;\n\n\t\t\t\t  \n\t\t\t\t_leave(\" = t [vbusy]\");\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\top->flags |= AFS_OPERATION_VBUSY;\n\t\t\tgoto next_server;\n\n\t\tcase VMOVED:\n\t\t\t \n\t\t\tif (op->flags & AFS_OPERATION_VMOVED) {\n\t\t\t\top->error = -EREMOTEIO;\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\top->flags |= AFS_OPERATION_VMOVED;\n\n\t\t\tset_bit(AFS_VOLUME_WAIT, &op->volume->flags);\n\t\t\tset_bit(AFS_VOLUME_NEEDS_UPDATE, &op->volume->flags);\n\t\t\terror = afs_check_volume_status(op->volume, op);\n\t\t\tif (error < 0)\n\t\t\t\tgoto failed_set_error;\n\n\t\t\t \n\t\t\tif (rcu_access_pointer(op->volume->servers) == op->server_list) {\n\t\t\t\top->error = -ENOMEDIUM;\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tgoto restart_from_beginning;\n\n\t\tdefault:\n\t\t\tclear_bit(AFS_VOLUME_OFFLINE, &op->volume->flags);\n\t\t\tclear_bit(AFS_VOLUME_BUSY, &op->volume->flags);\n\t\t\top->error = afs_abort_to_error(op->ac.abort_code);\n\t\t\tgoto failed;\n\t\t}\n\n\tcase -ETIMEDOUT:\n\tcase -ETIME:\n\t\tif (op->error != -EDESTADDRREQ)\n\t\t\tgoto iterate_address;\n\t\tfallthrough;\n\tcase -ERFKILL:\n\tcase -EADDRNOTAVAIL:\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -EHOSTDOWN:\n\tcase -ECONNREFUSED:\n\t\t_debug(\"no conn\");\n\t\top->error = error;\n\t\tgoto iterate_address;\n\n\tcase -ENETRESET:\n\t\tpr_warn(\"kAFS: Peer reset %s (op=%x)\\n\",\n\t\t\top->type ? op->type->name : \"???\", op->debug_id);\n\t\tfallthrough;\n\tcase -ECONNRESET:\n\t\t_debug(\"call reset\");\n\t\top->error = error;\n\t\tgoto failed;\n\t}\n\nrestart_from_beginning:\n\t_debug(\"restart\");\n\tafs_end_cursor(&op->ac);\n\top->server = NULL;\n\tafs_put_serverlist(op->net, op->server_list);\n\top->server_list = NULL;\nstart:\n\t_debug(\"start\");\n\t \n\terror = afs_check_volume_status(op->volume, op);\n\tif (error < 0)\n\t\tgoto failed_set_error;\n\n\tif (!afs_start_fs_iteration(op, vnode))\n\t\tgoto failed;\n\n\t_debug(\"__ VOL %llx __\", op->volume->vid);\n\npick_server:\n\t_debug(\"pick [%lx]\", op->untried);\n\n\terror = afs_wait_for_fs_probes(op->server_list, op->untried);\n\tif (error < 0)\n\t\tgoto failed_set_error;\n\n\t \n\tif (op->server) {\n\t\t_debug(\"server %u\", op->index);\n\t\tif (test_bit(op->index, &op->untried))\n\t\t\tgoto selected_server;\n\t\top->server = NULL;\n\t\t_debug(\"no server\");\n\t}\n\n\top->index = -1;\n\trtt = U32_MAX;\n\tfor (i = 0; i < op->server_list->nr_servers; i++) {\n\t\tstruct afs_server *s = op->server_list->servers[i].server;\n\n\t\tif (!test_bit(i, &op->untried) ||\n\t\t    !test_bit(AFS_SERVER_FL_RESPONDING, &s->flags))\n\t\t\tcontinue;\n\t\tif (s->probe.rtt < rtt) {\n\t\t\top->index = i;\n\t\t\trtt = s->probe.rtt;\n\t\t}\n\t}\n\n\tif (op->index == -1)\n\t\tgoto no_more_servers;\n\nselected_server:\n\t_debug(\"use %d\", op->index);\n\t__clear_bit(op->index, &op->untried);\n\n\t \n\tASSERTCMP(op->ac.alist, ==, NULL);\n\tserver = op->server_list->servers[op->index].server;\n\n\tif (!afs_check_server_record(op, server))\n\t\tgoto failed;\n\n\t_debug(\"USING SERVER: %pU\", &server->uuid);\n\n\top->flags |= AFS_OPERATION_RETRY_SERVER;\n\top->server = server;\n\tif (vnode->cb_server != server) {\n\t\tvnode->cb_server = server;\n\t\tvnode->cb_s_break = server->cb_s_break;\n\t\tvnode->cb_fs_s_break = atomic_read(&server->cell->fs_s_break);\n\t\tvnode->cb_v_break = vnode->volume->cb_v_break;\n\t\tclear_bit(AFS_VNODE_CB_PROMISED, &vnode->flags);\n\t}\n\n\tread_lock(&server->fs_lock);\n\talist = rcu_dereference_protected(server->addresses,\n\t\t\t\t\t  lockdep_is_held(&server->fs_lock));\n\tafs_get_addrlist(alist);\n\tread_unlock(&server->fs_lock);\n\nretry_server:\n\tmemset(&op->ac, 0, sizeof(op->ac));\n\n\tif (!op->ac.alist)\n\t\top->ac.alist = alist;\n\telse\n\t\tafs_put_addrlist(alist);\n\n\top->ac.index = -1;\n\niterate_address:\n\tASSERT(op->ac.alist);\n\t \n\tif (!afs_iterate_addresses(&op->ac))\n\t\tgoto out_of_addresses;\n\n\t_debug(\"address [%u] %u/%u %pISp\",\n\t       op->index, op->ac.index, op->ac.alist->nr_addrs,\n\t       &op->ac.alist->addrs[op->ac.index].transport);\n\n\t_leave(\" = t\");\n\treturn true;\n\nout_of_addresses:\n\t \n\tafs_probe_fileserver(op->net, op->server);\n\tif (op->flags & AFS_OPERATION_RETRY_SERVER) {\n\t\talist = op->ac.alist;\n\t\terror = afs_wait_for_one_fs_probe(\n\t\t\top->server, !(op->flags & AFS_OPERATION_UNINTR));\n\t\tswitch (error) {\n\t\tcase 0:\n\t\t\top->flags &= ~AFS_OPERATION_RETRY_SERVER;\n\t\t\tgoto retry_server;\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto failed_set_error;\n\t\tcase -ETIME:\n\t\tcase -EDESTADDRREQ:\n\t\t\tgoto next_server;\n\t\t}\n\t}\n\nnext_server:\n\t_debug(\"next\");\n\tafs_end_cursor(&op->ac);\n\tgoto pick_server;\n\nno_more_servers:\n\t \n\tif (op->flags & AFS_OPERATION_VBUSY)\n\t\tgoto restart_from_beginning;\n\n\te.error = -EDESTADDRREQ;\n\te.responded = false;\n\tfor (i = 0; i < op->server_list->nr_servers; i++) {\n\t\tstruct afs_server *s = op->server_list->servers[i].server;\n\n\t\tafs_prioritise_error(&e, READ_ONCE(s->probe.error),\n\t\t\t\t     s->probe.abort_code);\n\t}\n\n\terror = e.error;\n\nfailed_set_error:\n\top->error = error;\nfailed:\n\top->flags |= AFS_OPERATION_STOP;\n\tafs_end_cursor(&op->ac);\n\t_leave(\" = f [failed %d]\", op->error);\n\treturn false;\n}\n\n \nvoid afs_dump_edestaddrreq(const struct afs_operation *op)\n{\n\tstatic int count;\n\tint i;\n\n\tif (!IS_ENABLED(CONFIG_AFS_DEBUG_CURSOR) || count > 3)\n\t\treturn;\n\tcount++;\n\n\trcu_read_lock();\n\n\tpr_notice(\"EDESTADDR occurred\\n\");\n\tpr_notice(\"FC: cbb=%x cbb2=%x fl=%x err=%hd\\n\",\n\t\t  op->file[0].cb_break_before,\n\t\t  op->file[1].cb_break_before, op->flags, op->error);\n\tpr_notice(\"FC: ut=%lx ix=%d ni=%u\\n\",\n\t\t  op->untried, op->index, op->nr_iterations);\n\n\tif (op->server_list) {\n\t\tconst struct afs_server_list *sl = op->server_list;\n\t\tpr_notice(\"FC: SL nr=%u pr=%u vnov=%hx\\n\",\n\t\t\t  sl->nr_servers, sl->preferred, sl->vnovol_mask);\n\t\tfor (i = 0; i < sl->nr_servers; i++) {\n\t\t\tconst struct afs_server *s = sl->servers[i].server;\n\t\t\tpr_notice(\"FC: server fl=%lx av=%u %pU\\n\",\n\t\t\t\t  s->flags, s->addr_version, &s->uuid);\n\t\t\tif (s->addresses) {\n\t\t\t\tconst struct afs_addr_list *a =\n\t\t\t\t\trcu_dereference(s->addresses);\n\t\t\t\tpr_notice(\"FC:  - av=%u nr=%u/%u/%u pr=%u\\n\",\n\t\t\t\t\t  a->version,\n\t\t\t\t\t  a->nr_ipv4, a->nr_addrs, a->max_addrs,\n\t\t\t\t\t  a->preferred);\n\t\t\t\tpr_notice(\"FC:  - R=%lx F=%lx\\n\",\n\t\t\t\t\t  a->responded, a->failed);\n\t\t\t\tif (a == op->ac.alist)\n\t\t\t\t\tpr_notice(\"FC:  - current\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpr_notice(\"AC: t=%lx ax=%u ac=%d er=%d r=%u ni=%u\\n\",\n\t\t  op->ac.tried, op->ac.index, op->ac.abort_code, op->ac.error,\n\t\t  op->ac.responded, op->ac.nr_iterations);\n\trcu_read_unlock();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}