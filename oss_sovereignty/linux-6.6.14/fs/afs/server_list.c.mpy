{
  "module_name": "server_list.c",
  "hash_id": "26bc9f45c69c1385fbd3da26e9fc08d679f5814e51555a0783ee2a15b3204948",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/server_list.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include \"internal.h\"\n\nvoid afs_put_serverlist(struct afs_net *net, struct afs_server_list *slist)\n{\n\tint i;\n\n\tif (slist && refcount_dec_and_test(&slist->usage)) {\n\t\tfor (i = 0; i < slist->nr_servers; i++)\n\t\t\tafs_unuse_server(net, slist->servers[i].server,\n\t\t\t\t\t afs_server_trace_put_slist);\n\t\tkfree_rcu(slist, rcu);\n\t}\n}\n\n \nstruct afs_server_list *afs_alloc_server_list(struct afs_cell *cell,\n\t\t\t\t\t      struct key *key,\n\t\t\t\t\t      struct afs_vldb_entry *vldb,\n\t\t\t\t\t      u8 type_mask)\n{\n\tstruct afs_server_list *slist;\n\tstruct afs_server *server;\n\tint ret = -ENOMEM, nr_servers = 0, i, j;\n\n\tfor (i = 0; i < vldb->nr_servers; i++)\n\t\tif (vldb->fs_mask[i] & type_mask)\n\t\t\tnr_servers++;\n\n\tslist = kzalloc(struct_size(slist, servers, nr_servers), GFP_KERNEL);\n\tif (!slist)\n\t\tgoto error;\n\n\trefcount_set(&slist->usage, 1);\n\trwlock_init(&slist->lock);\n\n\tfor (i = 0; i < AFS_MAXTYPES; i++)\n\t\tslist->vids[i] = vldb->vid[i];\n\n\t \n\tfor (i = 0; i < vldb->nr_servers; i++) {\n\t\tif (!(vldb->fs_mask[i] & type_mask))\n\t\t\tcontinue;\n\n\t\tserver = afs_lookup_server(cell, key, &vldb->fs_server[i],\n\t\t\t\t\t   vldb->addr_version[i]);\n\t\tif (IS_ERR(server)) {\n\t\t\tret = PTR_ERR(server);\n\t\t\tif (ret == -ENOENT ||\n\t\t\t    ret == -ENOMEDIUM)\n\t\t\t\tcontinue;\n\t\t\tgoto error_2;\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < slist->nr_servers; j++)\n\t\t\tif (memcmp(&slist->servers[j].server->uuid,\n\t\t\t\t   &server->uuid,\n\t\t\t\t   sizeof(server->uuid)) >= 0)\n\t\t\t\tbreak;\n\t\tif (j < slist->nr_servers) {\n\t\t\tif (slist->servers[j].server == server) {\n\t\t\t\tafs_put_server(cell->net, server,\n\t\t\t\t\t       afs_server_trace_put_slist_isort);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmemmove(slist->servers + j + 1,\n\t\t\t\tslist->servers + j,\n\t\t\t\t(slist->nr_servers - j) * sizeof(struct afs_server_entry));\n\t\t}\n\n\t\tslist->servers[j].server = server;\n\t\tslist->nr_servers++;\n\t}\n\n\tif (slist->nr_servers == 0) {\n\t\tret = -EDESTADDRREQ;\n\t\tgoto error_2;\n\t}\n\n\treturn slist;\n\nerror_2:\n\tafs_put_serverlist(cell->net, slist);\nerror:\n\treturn ERR_PTR(ret);\n}\n\n \nbool afs_annotate_server_list(struct afs_server_list *new,\n\t\t\t      struct afs_server_list *old)\n{\n\tstruct afs_server *cur;\n\tint i, j;\n\n\tif (old->nr_servers != new->nr_servers)\n\t\tgoto changed;\n\n\tfor (i = 0; i < old->nr_servers; i++)\n\t\tif (old->servers[i].server != new->servers[i].server)\n\t\t\tgoto changed;\n\n\treturn false;\n\nchanged:\n\t \n\tcur = old->servers[old->preferred].server;\n\tfor (j = 0; j < new->nr_servers; j++) {\n\t\tif (new->servers[j].server == cur) {\n\t\t\tnew->preferred = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}