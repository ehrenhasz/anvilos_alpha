{
  "module_name": "security.c",
  "hash_id": "0f2b6793989bf17870c6a77a30628e70bc965c984e2fcc76d7b273052468ec12",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/security.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/hashtable.h>\n#include <keys/rxrpc-type.h>\n#include \"internal.h\"\n\nstatic DEFINE_HASHTABLE(afs_permits_cache, 10);\nstatic DEFINE_SPINLOCK(afs_permits_lock);\n\n \nstruct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key_net(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t      cell->net->net, NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t \n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t \n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}\n\n \nstruct key *afs_request_key_rcu(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key_net_rcu(&key_type_rxrpc,\n\t\t\t\t  cell->anonymous_key->description,\n\t\t\t\t  cell->net->net);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t \n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t \n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}\n\n \nstatic void afs_permits_rcu(struct rcu_head *rcu)\n{\n\tstruct afs_permits *permits =\n\t\tcontainer_of(rcu, struct afs_permits, rcu);\n\tint i;\n\n\tfor (i = 0; i < permits->nr_permits; i++)\n\t\tkey_put(permits->permits[i].key);\n\tkfree(permits);\n}\n\n \nvoid afs_put_permits(struct afs_permits *permits)\n{\n\tif (permits && refcount_dec_and_test(&permits->usage)) {\n\t\tspin_lock(&afs_permits_lock);\n\t\thash_del_rcu(&permits->hash_node);\n\t\tspin_unlock(&afs_permits_lock);\n\t\tcall_rcu(&permits->rcu, afs_permits_rcu);\n\t}\n}\n\n \nvoid afs_clear_permits(struct afs_vnode *vnode)\n{\n\tstruct afs_permits *permits;\n\n\tspin_lock(&vnode->lock);\n\tpermits = rcu_dereference_protected(vnode->permit_cache,\n\t\t\t\t\t    lockdep_is_held(&vnode->lock));\n\tRCU_INIT_POINTER(vnode->permit_cache, NULL);\n\tspin_unlock(&vnode->lock);\n\n\tafs_put_permits(permits);\n}\n\n \nstatic void afs_hash_permits(struct afs_permits *permits)\n{\n\tunsigned long h = permits->nr_permits;\n\tint i;\n\n\tfor (i = 0; i < permits->nr_permits; i++) {\n\t\th += (unsigned long)permits->permits[i].key / sizeof(void *);\n\t\th += permits->permits[i].access;\n\t}\n\n\tpermits->h = h;\n}\n\n \nvoid afs_cache_permit(struct afs_vnode *vnode, struct key *key,\n\t\t      unsigned int cb_break, struct afs_status_cb *scb)\n{\n\tstruct afs_permits *permits, *xpermits, *replacement, *zap, *new = NULL;\n\tafs_access_t caller_access = scb->status.caller_access;\n\tsize_t size = 0;\n\tbool changed = false;\n\tint i, j;\n\n\t_enter(\"{%llx:%llu},%x,%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, key_serial(key), caller_access);\n\n\trcu_read_lock();\n\n\t \n\tpermits = rcu_dereference(vnode->permit_cache);\n\tif (permits) {\n\t\tif (!permits->invalidated) {\n\t\t\tfor (i = 0; i < permits->nr_permits; i++) {\n\t\t\t\tif (permits->permits[i].key < key)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (permits->permits[i].key > key)\n\t\t\t\t\tbreak;\n\t\t\t\tif (permits->permits[i].access != caller_access) {\n\t\t\t\t\tchanged = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (afs_cb_is_broken(cb_break, vnode)) {\n\t\t\t\t\tchanged = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tchanged |= permits->invalidated;\n\t\tsize = permits->nr_permits;\n\n\t\t \n\t\tif (changed) {\n\t\t\tspin_lock(&vnode->lock);\n\t\t\tif (permits != rcu_access_pointer(vnode->permit_cache))\n\t\t\t\tgoto someone_else_changed_it_unlock;\n\t\t\tRCU_INIT_POINTER(vnode->permit_cache, NULL);\n\t\t\tspin_unlock(&vnode->lock);\n\n\t\t\tafs_put_permits(permits);\n\t\t\tpermits = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tif (afs_cb_is_broken(cb_break, vnode))\n\t\tgoto someone_else_changed_it;\n\n\t \n\tif (permits && !refcount_inc_not_zero(&permits->usage))\n\t\tgoto someone_else_changed_it;\n\n\trcu_read_unlock();\n\n\t \n\tsize++;\n\tnew = kzalloc(struct_size(new, permits, size), GFP_NOFS);\n\tif (!new)\n\t\tgoto out_put;\n\n\trefcount_set(&new->usage, 1);\n\tnew->nr_permits = size;\n\ti = j = 0;\n\tif (permits) {\n\t\tfor (i = 0; i < permits->nr_permits; i++) {\n\t\t\tif (j == i && permits->permits[i].key > key) {\n\t\t\t\tnew->permits[j].key = key;\n\t\t\t\tnew->permits[j].access = caller_access;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tnew->permits[j].key = permits->permits[i].key;\n\t\t\tnew->permits[j].access = permits->permits[i].access;\n\t\t\tj++;\n\t\t}\n\t}\n\n\tif (j == i) {\n\t\tnew->permits[j].key = key;\n\t\tnew->permits[j].access = caller_access;\n\t}\n\n\tafs_hash_permits(new);\n\n\t \n\tspin_lock(&afs_permits_lock);\n\n\thash_for_each_possible(afs_permits_cache, xpermits, hash_node, new->h) {\n\t\tif (xpermits->h != new->h ||\n\t\t    xpermits->invalidated ||\n\t\t    xpermits->nr_permits != new->nr_permits ||\n\t\t    memcmp(xpermits->permits, new->permits,\n\t\t\t   new->nr_permits * sizeof(struct afs_permit)) != 0)\n\t\t\tcontinue;\n\n\t\tif (refcount_inc_not_zero(&xpermits->usage)) {\n\t\t\treplacement = xpermits;\n\t\t\tgoto found;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < new->nr_permits; i++)\n\t\tkey_get(new->permits[i].key);\n\thash_add_rcu(afs_permits_cache, &new->hash_node, new->h);\n\treplacement = new;\n\tnew = NULL;\n\nfound:\n\tspin_unlock(&afs_permits_lock);\n\n\tkfree(new);\n\n\trcu_read_lock();\n\tspin_lock(&vnode->lock);\n\tzap = rcu_access_pointer(vnode->permit_cache);\n\tif (!afs_cb_is_broken(cb_break, vnode) && zap == permits)\n\t\trcu_assign_pointer(vnode->permit_cache, replacement);\n\telse\n\t\tzap = replacement;\n\tspin_unlock(&vnode->lock);\n\trcu_read_unlock();\n\tafs_put_permits(zap);\nout_put:\n\tafs_put_permits(permits);\n\treturn;\n\nsomeone_else_changed_it_unlock:\n\tspin_unlock(&vnode->lock);\nsomeone_else_changed_it:\n\t \n\trcu_read_unlock();\n\treturn;\n}\n\nstatic bool afs_check_permit_rcu(struct afs_vnode *vnode, struct key *key,\n\t\t\t\t afs_access_t *_access)\n{\n\tconst struct afs_permits *permits;\n\tint i;\n\n\t_enter(\"{%llx:%llu},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, key_serial(key));\n\n\t \n\tif (key == vnode->volume->cell->anonymous_key) {\n\t\t*_access = vnode->status.anon_access;\n\t\t_leave(\" = t [anon %x]\", *_access);\n\t\treturn true;\n\t}\n\n\tpermits = rcu_dereference(vnode->permit_cache);\n\tif (permits) {\n\t\tfor (i = 0; i < permits->nr_permits; i++) {\n\t\t\tif (permits->permits[i].key < key)\n\t\t\t\tcontinue;\n\t\t\tif (permits->permits[i].key > key)\n\t\t\t\tbreak;\n\n\t\t\t*_access = permits->permits[i].access;\n\t\t\t_leave(\" = %u [perm %x]\", !permits->invalidated, *_access);\n\t\t\treturn !permits->invalidated;\n\t\t}\n\t}\n\n\t_leave(\" = f\");\n\treturn false;\n}\n\n \nint afs_check_permit(struct afs_vnode *vnode, struct key *key,\n\t\t     afs_access_t *_access)\n{\n\tstruct afs_permits *permits;\n\tbool valid = false;\n\tint i, ret;\n\n\t_enter(\"{%llx:%llu},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, key_serial(key));\n\n\t \n\tif (key == vnode->volume->cell->anonymous_key) {\n\t\t_debug(\"anon\");\n\t\t*_access = vnode->status.anon_access;\n\t\tvalid = true;\n\t} else {\n\t\trcu_read_lock();\n\t\tpermits = rcu_dereference(vnode->permit_cache);\n\t\tif (permits) {\n\t\t\tfor (i = 0; i < permits->nr_permits; i++) {\n\t\t\t\tif (permits->permits[i].key < key)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (permits->permits[i].key > key)\n\t\t\t\t\tbreak;\n\n\t\t\t\t*_access = permits->permits[i].access;\n\t\t\t\tvalid = !permits->invalidated;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (!valid) {\n\t\t \n\t\t_debug(\"no valid permit\");\n\n\t\tret = afs_fetch_status(vnode, key, false, _access);\n\t\tif (ret < 0) {\n\t\t\t*_access = 0;\n\t\t\t_leave(\" = %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t_leave(\" = 0 [access %x]\", *_access);\n\treturn 0;\n}\n\n \nint afs_permission(struct mnt_idmap *idmap, struct inode *inode,\n\t\t   int mask)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tafs_access_t access;\n\tstruct key *key;\n\tint ret = 0;\n\n\t_enter(\"{{%llx:%llu},%lx},%x,\",\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->flags, mask);\n\n\tif (mask & MAY_NOT_BLOCK) {\n\t\tkey = afs_request_key_rcu(vnode->volume->cell);\n\t\tif (IS_ERR(key))\n\t\t\treturn -ECHILD;\n\n\t\tret = -ECHILD;\n\t\tif (!afs_check_validity(vnode) ||\n\t\t    !afs_check_permit_rcu(vnode, key, &access))\n\t\t\tgoto error;\n\t} else {\n\t\tkey = afs_request_key(vnode->volume->cell);\n\t\tif (IS_ERR(key)) {\n\t\t\t_leave(\" = %ld [key]\", PTR_ERR(key));\n\t\t\treturn PTR_ERR(key);\n\t\t}\n\n\t\tret = afs_validate(vnode, key);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tret = afs_check_permit(vnode, key, &access);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\t \n\t_debug(\"REQ %x ACC %x on %s\",\n\t       mask, access, S_ISDIR(inode->i_mode) ? \"dir\" : \"file\");\n\n\tret = 0;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (mask & (MAY_EXEC | MAY_READ | MAY_CHDIR)) {\n\t\t\tif (!(access & AFS_ACE_LOOKUP))\n\t\t\t\tgoto permission_denied;\n\t\t}\n\t\tif (mask & MAY_WRITE) {\n\t\t\tif (!(access & (AFS_ACE_DELETE |  \n\t\t\t\t\tAFS_ACE_INSERT)))  \n\t\t\t\tgoto permission_denied;\n\t\t}\n\t} else {\n\t\tif (!(access & AFS_ACE_LOOKUP))\n\t\t\tgoto permission_denied;\n\t\tif ((mask & MAY_EXEC) && !(inode->i_mode & S_IXUSR))\n\t\t\tgoto permission_denied;\n\t\tif (mask & (MAY_EXEC | MAY_READ)) {\n\t\t\tif (!(access & AFS_ACE_READ))\n\t\t\t\tgoto permission_denied;\n\t\t\tif (!(inode->i_mode & S_IRUSR))\n\t\t\t\tgoto permission_denied;\n\t\t} else if (mask & MAY_WRITE) {\n\t\t\tif (!(access & AFS_ACE_WRITE))\n\t\t\t\tgoto permission_denied;\n\t\t\tif (!(inode->i_mode & S_IWUSR))\n\t\t\t\tgoto permission_denied;\n\t\t}\n\t}\n\n\tkey_put(key);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\npermission_denied:\n\tret = -EACCES;\nerror:\n\tkey_put(key);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\nvoid __exit afs_clean_up_permit_cache(void)\n{\n\tint i;\n\n\tfor (i = 0; i < HASH_SIZE(afs_permits_cache); i++)\n\t\tWARN_ON_ONCE(!hlist_empty(&afs_permits_cache[i]));\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}