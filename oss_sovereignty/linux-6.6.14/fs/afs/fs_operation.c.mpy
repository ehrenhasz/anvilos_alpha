{
  "module_name": "fs_operation.c",
  "hash_id": "64920db46440ccb2047b1066aeab102cceff75d4dd58d9f3cc3f838e2776a77d",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/fs_operation.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include \"internal.h\"\n\nstatic atomic_t afs_operation_debug_counter;\n\n \nstruct afs_operation *afs_alloc_operation(struct key *key, struct afs_volume *volume)\n{\n\tstruct afs_operation *op;\n\n\t_enter(\"\");\n\n\top = kzalloc(sizeof(*op), GFP_KERNEL);\n\tif (!op)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!key) {\n\t\tkey = afs_request_key(volume->cell);\n\t\tif (IS_ERR(key)) {\n\t\t\tkfree(op);\n\t\t\treturn ERR_CAST(key);\n\t\t}\n\t} else {\n\t\tkey_get(key);\n\t}\n\n\top->key\t\t= key;\n\top->volume\t= afs_get_volume(volume, afs_volume_trace_get_new_op);\n\top->net\t\t= volume->cell->net;\n\top->cb_v_break\t= volume->cb_v_break;\n\top->debug_id\t= atomic_inc_return(&afs_operation_debug_counter);\n\top->error\t= -EDESTADDRREQ;\n\top->ac.error\t= SHRT_MAX;\n\n\t_leave(\" = [op=%08x]\", op->debug_id);\n\treturn op;\n}\n\n \nstatic bool afs_get_io_locks(struct afs_operation *op)\n{\n\tstruct afs_vnode *vnode = op->file[0].vnode;\n\tstruct afs_vnode *vnode2 = op->file[1].vnode;\n\n\t_enter(\"\");\n\n\tif (op->flags & AFS_OPERATION_UNINTR) {\n\t\tmutex_lock(&vnode->io_lock);\n\t\top->flags |= AFS_OPERATION_LOCK_0;\n\t\t_leave(\" = t [1]\");\n\t\treturn true;\n\t}\n\n\tif (!vnode2 || !op->file[1].need_io_lock || vnode == vnode2)\n\t\tvnode2 = NULL;\n\n\tif (vnode2 > vnode)\n\t\tswap(vnode, vnode2);\n\n\tif (mutex_lock_interruptible(&vnode->io_lock) < 0) {\n\t\top->error = -ERESTARTSYS;\n\t\top->flags |= AFS_OPERATION_STOP;\n\t\t_leave(\" = f [I 0]\");\n\t\treturn false;\n\t}\n\top->flags |= AFS_OPERATION_LOCK_0;\n\n\tif (vnode2) {\n\t\tif (mutex_lock_interruptible_nested(&vnode2->io_lock, 1) < 0) {\n\t\t\top->error = -ERESTARTSYS;\n\t\t\top->flags |= AFS_OPERATION_STOP;\n\t\t\tmutex_unlock(&vnode->io_lock);\n\t\t\top->flags &= ~AFS_OPERATION_LOCK_0;\n\t\t\t_leave(\" = f [I 1]\");\n\t\t\treturn false;\n\t\t}\n\t\top->flags |= AFS_OPERATION_LOCK_1;\n\t}\n\n\t_leave(\" = t [2]\");\n\treturn true;\n}\n\nstatic void afs_drop_io_locks(struct afs_operation *op)\n{\n\tstruct afs_vnode *vnode = op->file[0].vnode;\n\tstruct afs_vnode *vnode2 = op->file[1].vnode;\n\n\t_enter(\"\");\n\n\tif (op->flags & AFS_OPERATION_LOCK_1)\n\t\tmutex_unlock(&vnode2->io_lock);\n\tif (op->flags & AFS_OPERATION_LOCK_0)\n\t\tmutex_unlock(&vnode->io_lock);\n}\n\nstatic void afs_prepare_vnode(struct afs_operation *op, struct afs_vnode_param *vp,\n\t\t\t      unsigned int index)\n{\n\tstruct afs_vnode *vnode = vp->vnode;\n\n\tif (vnode) {\n\t\tvp->fid\t\t\t= vnode->fid;\n\t\tvp->dv_before\t\t= vnode->status.data_version;\n\t\tvp->cb_break_before\t= afs_calc_vnode_cb_break(vnode);\n\t\tif (vnode->lock_state != AFS_VNODE_LOCK_NONE)\n\t\t\top->flags\t|= AFS_OPERATION_CUR_ONLY;\n\t\tif (vp->modification)\n\t\t\tset_bit(AFS_VNODE_MODIFYING, &vnode->flags);\n\t}\n\n\tif (vp->fid.vnode)\n\t\t_debug(\"PREP[%u] {%llx:%llu.%u}\",\n\t\t       index, vp->fid.vid, vp->fid.vnode, vp->fid.unique);\n}\n\n \nbool afs_begin_vnode_operation(struct afs_operation *op)\n{\n\tstruct afs_vnode *vnode = op->file[0].vnode;\n\n\tASSERT(vnode);\n\n\t_enter(\"\");\n\n\tif (op->file[0].need_io_lock)\n\t\tif (!afs_get_io_locks(op))\n\t\t\treturn false;\n\n\tafs_prepare_vnode(op, &op->file[0], 0);\n\tafs_prepare_vnode(op, &op->file[1], 1);\n\top->cb_v_break = op->volume->cb_v_break;\n\t_leave(\" = true\");\n\treturn true;\n}\n\n \nstatic void afs_end_vnode_operation(struct afs_operation *op)\n{\n\t_enter(\"\");\n\n\tif (op->error == -EDESTADDRREQ ||\n\t    op->error == -EADDRNOTAVAIL ||\n\t    op->error == -ENETUNREACH ||\n\t    op->error == -EHOSTUNREACH)\n\t\tafs_dump_edestaddrreq(op);\n\n\tafs_drop_io_locks(op);\n\n\tif (op->error == -ECONNABORTED)\n\t\top->error = afs_abort_to_error(op->ac.abort_code);\n}\n\n \nvoid afs_wait_for_operation(struct afs_operation *op)\n{\n\t_enter(\"\");\n\n\twhile (afs_select_fileserver(op)) {\n\t\top->cb_s_break = op->server->cb_s_break;\n\t\tif (test_bit(AFS_SERVER_FL_IS_YFS, &op->server->flags) &&\n\t\t    op->ops->issue_yfs_rpc)\n\t\t\top->ops->issue_yfs_rpc(op);\n\t\telse if (op->ops->issue_afs_rpc)\n\t\t\top->ops->issue_afs_rpc(op);\n\t\telse\n\t\t\top->ac.error = -ENOTSUPP;\n\n\t\tif (op->call)\n\t\t\top->error = afs_wait_for_call_to_complete(op->call, &op->ac);\n\t}\n\n\tswitch (op->error) {\n\tcase 0:\n\t\t_debug(\"success\");\n\t\top->ops->success(op);\n\t\tbreak;\n\tcase -ECONNABORTED:\n\t\tif (op->ops->aborted)\n\t\t\top->ops->aborted(op);\n\t\tfallthrough;\n\tdefault:\n\t\tif (op->ops->failed)\n\t\t\top->ops->failed(op);\n\t\tbreak;\n\t}\n\n\tafs_end_vnode_operation(op);\n\n\tif (op->error == 0 && op->ops->edit_dir) {\n\t\t_debug(\"edit_dir\");\n\t\top->ops->edit_dir(op);\n\t}\n\t_leave(\"\");\n}\n\n \nint afs_put_operation(struct afs_operation *op)\n{\n\tint i, ret = op->error;\n\n\t_enter(\"op=%08x,%d\", op->debug_id, ret);\n\n\tif (op->ops && op->ops->put)\n\t\top->ops->put(op);\n\tif (op->file[0].modification)\n\t\tclear_bit(AFS_VNODE_MODIFYING, &op->file[0].vnode->flags);\n\tif (op->file[1].modification && op->file[1].vnode != op->file[0].vnode)\n\t\tclear_bit(AFS_VNODE_MODIFYING, &op->file[1].vnode->flags);\n\tif (op->file[0].put_vnode)\n\t\tiput(&op->file[0].vnode->netfs.inode);\n\tif (op->file[1].put_vnode)\n\t\tiput(&op->file[1].vnode->netfs.inode);\n\n\tif (op->more_files) {\n\t\tfor (i = 0; i < op->nr_files - 2; i++)\n\t\t\tif (op->more_files[i].put_vnode)\n\t\t\t\tiput(&op->more_files[i].vnode->netfs.inode);\n\t\tkfree(op->more_files);\n\t}\n\n\tafs_end_cursor(&op->ac);\n\tafs_put_serverlist(op->net, op->server_list);\n\tafs_put_volume(op->net, op->volume, afs_volume_trace_put_put_op);\n\tkey_put(op->key);\n\tkfree(op);\n\treturn ret;\n}\n\nint afs_do_sync_operation(struct afs_operation *op)\n{\n\tafs_begin_vnode_operation(op);\n\tafs_wait_for_operation(op);\n\treturn afs_put_operation(op);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}