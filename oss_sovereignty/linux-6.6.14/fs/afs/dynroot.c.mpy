{
  "module_name": "dynroot.c",
  "hash_id": "a70bbeb7412788bc67704a1d5ea82169715993aa01eb0c3c1003e3531840061f",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/dynroot.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/dns_resolver.h>\n#include \"internal.h\"\n\nstatic atomic_t afs_autocell_ino;\n\n \nstatic int afs_iget5_pseudo_test(struct inode *inode, void *opaque)\n{\n\treturn 0;\n}\n\n \nstatic int afs_iget5_pseudo_set(struct inode *inode, void *opaque)\n{\n\tstruct afs_super_info *as = AFS_FS_S(inode->i_sb);\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct afs_fid *fid = opaque;\n\n\tvnode->volume\t\t= as->volume;\n\tvnode->fid\t\t= *fid;\n\tinode->i_ino\t\t= fid->vnode;\n\tinode->i_generation\t= fid->unique;\n\treturn 0;\n}\n\n \nstruct inode *afs_iget_pseudo_dir(struct super_block *sb, bool root)\n{\n\tstruct afs_super_info *as = AFS_FS_S(sb);\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\tstruct afs_fid fid = {};\n\n\t_enter(\"\");\n\n\tif (as->volume)\n\t\tfid.vid = as->volume->vid;\n\tif (root) {\n\t\tfid.vnode = 1;\n\t\tfid.unique = 1;\n\t} else {\n\t\tfid.vnode = atomic_inc_return(&afs_autocell_ino);\n\t\tfid.unique = 0;\n\t}\n\n\tinode = iget5_locked(sb, fid.vnode,\n\t\t\t     afs_iget5_pseudo_test, afs_iget5_pseudo_set, &fid);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { ino=%lu, vl=%llx, vn=%llx, u=%x }\",\n\t       inode, inode->i_ino, fid.vid, fid.vnode, fid.unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t \n\tBUG_ON(!(inode->i_state & I_NEW));\n\n\tnetfs_inode_init(&vnode->netfs, NULL);\n\tinode->i_size\t\t= 0;\n\tinode->i_mode\t\t= S_IFDIR | S_IRUGO | S_IXUGO;\n\tif (root) {\n\t\tinode->i_op\t= &afs_dynroot_inode_operations;\n\t\tinode->i_fop\t= &simple_dir_operations;\n\t} else {\n\t\tinode->i_op\t= &afs_autocell_inode_operations;\n\t}\n\tset_nlink(inode, 2);\n\tinode->i_uid\t\t= GLOBAL_ROOT_UID;\n\tinode->i_gid\t\t= GLOBAL_ROOT_GID;\n\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\tinode->i_blocks\t\t= 0;\n\tinode->i_generation\t= 0;\n\n\tset_bit(AFS_VNODE_PSEUDODIR, &vnode->flags);\n\tif (!root) {\n\t\tset_bit(AFS_VNODE_MOUNTPOINT, &vnode->flags);\n\t\tinode->i_flags |= S_AUTOMOUNT;\n\t}\n\n\tinode->i_flags |= S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p\", inode);\n\treturn inode;\n}\n\n \nstatic int afs_probe_cell_name(struct dentry *dentry)\n{\n\tstruct afs_cell *cell;\n\tstruct afs_net *net = afs_d2net(dentry);\n\tconst char *name = dentry->d_name.name;\n\tsize_t len = dentry->d_name.len;\n\tchar *result = NULL;\n\tint ret;\n\n\t \n\tif (name[0] == '.') {\n\t\tif (len == 1)\n\t\t\treturn -EINVAL;\n\t\tname++;\n\t\tlen--;\n\t}\n\n\tcell = afs_find_cell(net, name, len, afs_cell_trace_use_probe);\n\tif (!IS_ERR(cell)) {\n\t\tafs_unuse_cell(net, cell, afs_cell_trace_unuse_probe);\n\t\treturn 0;\n\t}\n\n\tret = dns_query(net->net, \"afsdb\", name, len, \"srv=1\",\n\t\t\t&result, NULL, false);\n\tif (ret == -ENODATA || ret == -ENOKEY || ret == 0)\n\t\tret = -ENOENT;\n\tif (ret > 0 && ret >= sizeof(struct dns_server_list_v1_header)) {\n\t\tstruct dns_server_list_v1_header *v1 = (void *)result;\n\n\t\tif (v1->hdr.zero == 0 &&\n\t\t    v1->hdr.content == DNS_PAYLOAD_IS_SERVER_LIST &&\n\t\t    v1->hdr.version == 1 &&\n\t\t    (v1->status != DNS_LOOKUP_GOOD &&\n\t\t     v1->status != DNS_LOOKUP_GOOD_WITH_BAD))\n\t\t\treturn -ENOENT;\n\n\t}\n\n\tkfree(result);\n\treturn ret;\n}\n\n \nstruct inode *afs_try_auto_mntpt(struct dentry *dentry, struct inode *dir)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(dir);\n\tstruct inode *inode;\n\tint ret = -ENOENT;\n\n\t_enter(\"%p{%pd}, {%llx:%llu}\",\n\t       dentry, dentry, vnode->fid.vid, vnode->fid.vnode);\n\n\tif (!test_bit(AFS_VNODE_AUTOCELL, &vnode->flags))\n\t\tgoto out;\n\n\tret = afs_probe_cell_name(dentry);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tinode = afs_iget_pseudo_dir(dir->i_sb, false);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\n\t_leave(\"= %p\", inode);\n\treturn inode;\n\nout:\n\t_leave(\"= %d\", ret);\n\treturn ret == -ENOENT ? NULL : ERR_PTR(ret);\n}\n\n \nstatic struct dentry *afs_lookup_atcell(struct dentry *dentry)\n{\n\tstruct afs_cell *cell;\n\tstruct afs_net *net = afs_d2net(dentry);\n\tstruct dentry *ret;\n\tchar *name;\n\tint len;\n\n\tif (!net->ws_cell)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tret = ERR_PTR(-ENOMEM);\n\tname = kmalloc(AFS_MAXCELLNAME + 1, GFP_KERNEL);\n\tif (!name)\n\t\tgoto out_p;\n\n\tdown_read(&net->cells_lock);\n\tcell = net->ws_cell;\n\tif (cell) {\n\t\tlen = cell->name_len;\n\t\tmemcpy(name, cell->name, len + 1);\n\t}\n\tup_read(&net->cells_lock);\n\n\tret = ERR_PTR(-ENOENT);\n\tif (!cell)\n\t\tgoto out_n;\n\n\tret = lookup_one_len(name, dentry->d_parent, len);\n\n\t \n\nout_n:\n\tkfree(name);\nout_p:\n\treturn ret;\n}\n\n \nstatic struct dentry *afs_dynroot_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t\t unsigned int flags)\n{\n\t_enter(\"%pd\", dentry);\n\n\tASSERTCMP(d_inode(dentry), ==, NULL);\n\n\tif (flags & LOOKUP_CREATE)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (dentry->d_name.len >= AFSNAMEMAX) {\n\t\t_leave(\" = -ENAMETOOLONG\");\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\n\tif (dentry->d_name.len == 5 &&\n\t    memcmp(dentry->d_name.name, \"@cell\", 5) == 0)\n\t\treturn afs_lookup_atcell(dentry);\n\n\treturn d_splice_alias(afs_try_auto_mntpt(dentry, dir), dentry);\n}\n\nconst struct inode_operations afs_dynroot_inode_operations = {\n\t.lookup\t\t= afs_dynroot_lookup,\n};\n\n \nstatic int afs_dynroot_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\treturn 1;\n}\n\nconst struct dentry_operations afs_dynroot_dentry_operations = {\n\t.d_revalidate\t= afs_dynroot_d_revalidate,\n\t.d_delete\t= always_delete_dentry,\n\t.d_release\t= afs_d_release,\n\t.d_automount\t= afs_d_automount,\n};\n\n \nint afs_dynroot_mkdir(struct afs_net *net, struct afs_cell *cell)\n{\n\tstruct super_block *sb = net->dynroot_sb;\n\tstruct dentry *root, *subdir;\n\tint ret;\n\n\tif (!sb || atomic_read(&sb->s_active) == 0)\n\t\treturn 0;\n\n\t \n\troot = sb->s_root;\n\tinode_lock(root->d_inode);\n\tsubdir = lookup_one_len(cell->name, root, cell->name_len);\n\tif (IS_ERR(subdir)) {\n\t\tret = PTR_ERR(subdir);\n\t\tgoto unlock;\n\t}\n\n\t \n\tsubdir->d_fsdata = (void *)1UL;\n\tret = 0;\nunlock:\n\tinode_unlock(root->d_inode);\n\treturn ret;\n}\n\n \nvoid afs_dynroot_rmdir(struct afs_net *net, struct afs_cell *cell)\n{\n\tstruct super_block *sb = net->dynroot_sb;\n\tstruct dentry *root, *subdir;\n\n\tif (!sb || atomic_read(&sb->s_active) == 0)\n\t\treturn;\n\n\troot = sb->s_root;\n\tinode_lock(root->d_inode);\n\n\t \n\tsubdir = try_lookup_one_len(cell->name, root, cell->name_len);\n\tif (IS_ERR_OR_NULL(subdir)) {\n\t\t_debug(\"lookup %ld\", PTR_ERR(subdir));\n\t\tgoto no_dentry;\n\t}\n\n\t_debug(\"rmdir %pd %u\", subdir, d_count(subdir));\n\n\tif (subdir->d_fsdata) {\n\t\t_debug(\"unpin %u\", d_count(subdir));\n\t\tsubdir->d_fsdata = NULL;\n\t\tdput(subdir);\n\t}\n\tdput(subdir);\nno_dentry:\n\tinode_unlock(root->d_inode);\n\t_leave(\"\");\n}\n\n \nint afs_dynroot_populate(struct super_block *sb)\n{\n\tstruct afs_cell *cell;\n\tstruct afs_net *net = afs_sb2net(sb);\n\tint ret;\n\n\tmutex_lock(&net->proc_cells_lock);\n\n\tnet->dynroot_sb = sb;\n\thlist_for_each_entry(cell, &net->proc_cells, proc_link) {\n\t\tret = afs_dynroot_mkdir(net, cell);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tret = 0;\nout:\n\tmutex_unlock(&net->proc_cells_lock);\n\treturn ret;\n\nerror:\n\tnet->dynroot_sb = NULL;\n\tgoto out;\n}\n\n \nvoid afs_dynroot_depopulate(struct super_block *sb)\n{\n\tstruct afs_net *net = afs_sb2net(sb);\n\tstruct dentry *root = sb->s_root, *subdir, *tmp;\n\n\t \n\tmutex_lock(&net->proc_cells_lock);\n\tif (net->dynroot_sb == sb)\n\t\tnet->dynroot_sb = NULL;\n\tmutex_unlock(&net->proc_cells_lock);\n\n\tif (root) {\n\t\tinode_lock(root->d_inode);\n\n\t\t \n\t\tlist_for_each_entry_safe(subdir, tmp, &root->d_subdirs, d_child) {\n\t\t\tif (subdir->d_fsdata) {\n\t\t\t\tsubdir->d_fsdata = NULL;\n\t\t\t\tdput(subdir);\n\t\t\t}\n\t\t}\n\n\t\tinode_unlock(root->d_inode);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}