{
  "module_name": "vl_list.c",
  "hash_id": "254e0f8cdd45ce7894a8f42f70447ac597a66c2d7179f3b298ed533ef384b19b",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/vl_list.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include \"internal.h\"\n\nstruct afs_vlserver *afs_alloc_vlserver(const char *name, size_t name_len,\n\t\t\t\t\tunsigned short port)\n{\n\tstruct afs_vlserver *vlserver;\n\n\tvlserver = kzalloc(struct_size(vlserver, name, name_len + 1),\n\t\t\t   GFP_KERNEL);\n\tif (vlserver) {\n\t\trefcount_set(&vlserver->ref, 1);\n\t\trwlock_init(&vlserver->lock);\n\t\tinit_waitqueue_head(&vlserver->probe_wq);\n\t\tspin_lock_init(&vlserver->probe_lock);\n\t\tvlserver->rtt = UINT_MAX;\n\t\tvlserver->name_len = name_len;\n\t\tvlserver->port = port;\n\t\tmemcpy(vlserver->name, name, name_len);\n\t}\n\treturn vlserver;\n}\n\nstatic void afs_vlserver_rcu(struct rcu_head *rcu)\n{\n\tstruct afs_vlserver *vlserver = container_of(rcu, struct afs_vlserver, rcu);\n\n\tafs_put_addrlist(rcu_access_pointer(vlserver->addresses));\n\tkfree_rcu(vlserver, rcu);\n}\n\nvoid afs_put_vlserver(struct afs_net *net, struct afs_vlserver *vlserver)\n{\n\tif (vlserver &&\n\t    refcount_dec_and_test(&vlserver->ref))\n\t\tcall_rcu(&vlserver->rcu, afs_vlserver_rcu);\n}\n\nstruct afs_vlserver_list *afs_alloc_vlserver_list(unsigned int nr_servers)\n{\n\tstruct afs_vlserver_list *vllist;\n\n\tvllist = kzalloc(struct_size(vllist, servers, nr_servers), GFP_KERNEL);\n\tif (vllist) {\n\t\trefcount_set(&vllist->ref, 1);\n\t\trwlock_init(&vllist->lock);\n\t}\n\n\treturn vllist;\n}\n\nvoid afs_put_vlserverlist(struct afs_net *net, struct afs_vlserver_list *vllist)\n{\n\tif (vllist) {\n\t\tif (refcount_dec_and_test(&vllist->ref)) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < vllist->nr_servers; i++) {\n\t\t\t\tafs_put_vlserver(net, vllist->servers[i].server);\n\t\t\t}\n\t\t\tkfree_rcu(vllist, rcu);\n\t\t}\n\t}\n}\n\nstatic u16 afs_extract_le16(const u8 **_b)\n{\n\tu16 val;\n\n\tval  = (u16)*(*_b)++ << 0;\n\tval |= (u16)*(*_b)++ << 8;\n\treturn val;\n}\n\n \nstatic struct afs_addr_list *afs_extract_vl_addrs(const u8 **_b, const u8 *end,\n\t\t\t\t\t\t  u8 nr_addrs, u16 port)\n{\n\tstruct afs_addr_list *alist;\n\tconst u8 *b = *_b;\n\tint ret = -EINVAL;\n\n\talist = afs_alloc_addrlist(nr_addrs, VL_SERVICE, port);\n\tif (!alist)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (nr_addrs == 0)\n\t\treturn alist;\n\n\tfor (; nr_addrs > 0 && end - b >= nr_addrs; nr_addrs--) {\n\t\tstruct dns_server_list_v1_address hdr;\n\t\t__be32 x[4];\n\n\t\thdr.address_type = *b++;\n\n\t\tswitch (hdr.address_type) {\n\t\tcase DNS_ADDRESS_IS_IPV4:\n\t\t\tif (end - b < 4) {\n\t\t\t\t_leave(\" = -EINVAL [short inet]\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemcpy(x, b, 4);\n\t\t\tafs_merge_fs_addr4(alist, x[0], port);\n\t\t\tb += 4;\n\t\t\tbreak;\n\n\t\tcase DNS_ADDRESS_IS_IPV6:\n\t\t\tif (end - b < 16) {\n\t\t\t\t_leave(\" = -EINVAL [short inet6]\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemcpy(x, b, 16);\n\t\t\tafs_merge_fs_addr6(alist, x, port);\n\t\t\tb += 16;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t_leave(\" = -EADDRNOTAVAIL [unknown af %u]\",\n\t\t\t       hdr.address_type);\n\t\t\tret = -EADDRNOTAVAIL;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\tif (alist->nr_ipv4 < alist->nr_addrs)\n\t\talist->preferred = alist->nr_ipv4;\n\n\t*_b = b;\n\treturn alist;\n\nerror:\n\t*_b = b;\n\tafs_put_addrlist(alist);\n\treturn ERR_PTR(ret);\n}\n\n \nstruct afs_vlserver_list *afs_extract_vlserver_list(struct afs_cell *cell,\n\t\t\t\t\t\t    const void *buffer,\n\t\t\t\t\t\t    size_t buffer_size)\n{\n\tconst struct dns_server_list_v1_header *hdr = buffer;\n\tstruct dns_server_list_v1_server bs;\n\tstruct afs_vlserver_list *vllist, *previous;\n\tstruct afs_addr_list *addrs;\n\tstruct afs_vlserver *server;\n\tconst u8 *b = buffer, *end = buffer + buffer_size;\n\tint ret = -ENOMEM, nr_servers, i, j;\n\n\t_enter(\"\");\n\n\t \n\tif (end - b < sizeof(*hdr) ||\n\t    hdr->hdr.content != DNS_PAYLOAD_IS_SERVER_LIST ||\n\t    hdr->hdr.version != 1) {\n\t\tpr_notice(\"kAFS: Got DNS record [%u,%u] len %zu\\n\",\n\t\t\t  hdr->hdr.content, hdr->hdr.version, end - b);\n\t\tret = -EDESTADDRREQ;\n\t\tgoto dump;\n\t}\n\n\tnr_servers = hdr->nr_servers;\n\n\tvllist = afs_alloc_vlserver_list(nr_servers);\n\tif (!vllist)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvllist->source = (hdr->source < NR__dns_record_source) ?\n\t\thdr->source : NR__dns_record_source;\n\tvllist->status = (hdr->status < NR__dns_lookup_status) ?\n\t\thdr->status : NR__dns_lookup_status;\n\n\tread_lock(&cell->vl_servers_lock);\n\tprevious = afs_get_vlserverlist(\n\t\trcu_dereference_protected(cell->vl_servers,\n\t\t\t\t\t  lockdep_is_held(&cell->vl_servers_lock)));\n\tread_unlock(&cell->vl_servers_lock);\n\n\tb += sizeof(*hdr);\n\twhile (end - b >= sizeof(bs)) {\n\t\tbs.name_len\t= afs_extract_le16(&b);\n\t\tbs.priority\t= afs_extract_le16(&b);\n\t\tbs.weight\t= afs_extract_le16(&b);\n\t\tbs.port\t\t= afs_extract_le16(&b);\n\t\tbs.source\t= *b++;\n\t\tbs.status\t= *b++;\n\t\tbs.protocol\t= *b++;\n\t\tbs.nr_addrs\t= *b++;\n\n\t\t_debug(\"extract %u %u %u %u %u %u %*.*s\",\n\t\t       bs.name_len, bs.priority, bs.weight,\n\t\t       bs.port, bs.protocol, bs.nr_addrs,\n\t\t       bs.name_len, bs.name_len, b);\n\n\t\tif (end - b < bs.name_len)\n\t\t\tbreak;\n\n\t\tret = -EPROTONOSUPPORT;\n\t\tif (bs.protocol == DNS_SERVER_PROTOCOL_UNSPECIFIED) {\n\t\t\tbs.protocol = DNS_SERVER_PROTOCOL_UDP;\n\t\t} else if (bs.protocol != DNS_SERVER_PROTOCOL_UDP) {\n\t\t\t_leave(\" = [proto %u]\", bs.protocol);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (bs.port == 0)\n\t\t\tbs.port = AFS_VL_PORT;\n\t\tif (bs.source > NR__dns_record_source)\n\t\t\tbs.source = NR__dns_record_source;\n\t\tif (bs.status > NR__dns_lookup_status)\n\t\t\tbs.status = NR__dns_lookup_status;\n\n\t\t \n\t\tserver = NULL;\n\t\tfor (i = 0; i < previous->nr_servers; i++) {\n\t\t\tstruct afs_vlserver *p = previous->servers[i].server;\n\n\t\t\tif (p->name_len == bs.name_len &&\n\t\t\t    p->port == bs.port &&\n\t\t\t    strncasecmp(b, p->name, bs.name_len) == 0) {\n\t\t\t\tserver = afs_get_vlserver(p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!server) {\n\t\t\tret = -ENOMEM;\n\t\t\tserver = afs_alloc_vlserver(b, bs.name_len, bs.port);\n\t\t\tif (!server)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tb += bs.name_len;\n\n\t\t \n\t\taddrs = afs_extract_vl_addrs(&b, end, bs.nr_addrs, bs.port);\n\t\tif (IS_ERR(addrs)) {\n\t\t\tret = PTR_ERR(addrs);\n\t\t\tgoto error_2;\n\t\t}\n\n\t\tif (vllist->nr_servers >= nr_servers) {\n\t\t\t_debug(\"skip %u >= %u\", vllist->nr_servers, nr_servers);\n\t\t\tafs_put_addrlist(addrs);\n\t\t\tafs_put_vlserver(cell->net, server);\n\t\t\tcontinue;\n\t\t}\n\n\t\taddrs->source = bs.source;\n\t\taddrs->status = bs.status;\n\n\t\tif (addrs->nr_addrs == 0) {\n\t\t\tafs_put_addrlist(addrs);\n\t\t\tif (!rcu_access_pointer(server->addresses)) {\n\t\t\t\tafs_put_vlserver(cell->net, server);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct afs_addr_list *old = addrs;\n\n\t\t\twrite_lock(&server->lock);\n\t\t\told = rcu_replace_pointer(server->addresses, old,\n\t\t\t\t\t\t  lockdep_is_held(&server->lock));\n\t\t\twrite_unlock(&server->lock);\n\t\t\tafs_put_addrlist(old);\n\t\t}\n\n\n\t\t \n\n\t\t \n\t\tfor (j = 0; j < vllist->nr_servers; j++) {\n\t\t\tif (bs.priority < vllist->servers[j].priority)\n\t\t\t\tbreak;  \n\t\t\tif (bs.priority == vllist->servers[j].priority &&\n\t\t\t    bs.weight > vllist->servers[j].weight)\n\t\t\t\tbreak;  \n\t\t}\n\n\t\tif (j < vllist->nr_servers) {\n\t\t\tmemmove(vllist->servers + j + 1,\n\t\t\t\tvllist->servers + j,\n\t\t\t\t(vllist->nr_servers - j) * sizeof(struct afs_vlserver_entry));\n\t\t}\n\n\t\tclear_bit(AFS_VLSERVER_FL_PROBED, &server->flags);\n\n\t\tvllist->servers[j].priority = bs.priority;\n\t\tvllist->servers[j].weight = bs.weight;\n\t\tvllist->servers[j].server = server;\n\t\tvllist->nr_servers++;\n\t}\n\n\tif (b != end) {\n\t\t_debug(\"parse error %zd\", b - end);\n\t\tgoto error;\n\t}\n\n\tafs_put_vlserverlist(cell->net, previous);\n\t_leave(\" = ok [%u]\", vllist->nr_servers);\n\treturn vllist;\n\nerror_2:\n\tafs_put_vlserver(cell->net, server);\nerror:\n\tafs_put_vlserverlist(cell->net, vllist);\n\tafs_put_vlserverlist(cell->net, previous);\ndump:\n\tif (ret != -ENOMEM) {\n\t\tprintk(KERN_DEBUG \"DNS: at %zu\\n\", (const void *)b - buffer);\n\t\tprint_hex_dump_bytes(\"DNS: \", DUMP_PREFIX_NONE, buffer, buffer_size);\n\t}\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}