{
  "module_name": "fs_probe.c",
  "hash_id": "d72af047ddf5fc4a3ad4416145f0f864cf29ff69556cff92d505f60b0ac2f570",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/fs_probe.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include \"protocol_afs.h\"\n#include \"protocol_yfs.h\"\n\nstatic unsigned int afs_fs_probe_fast_poll_interval = 30 * HZ;\nstatic unsigned int afs_fs_probe_slow_poll_interval = 5 * 60 * HZ;\n\n \nstatic void afs_schedule_fs_probe(struct afs_net *net,\n\t\t\t\t  struct afs_server *server, bool fast)\n{\n\tunsigned long atj;\n\n\tif (!net->live)\n\t\treturn;\n\n\tatj = server->probed_at;\n\tatj += fast ? afs_fs_probe_fast_poll_interval : afs_fs_probe_slow_poll_interval;\n\n\tafs_inc_servers_outstanding(net);\n\tif (timer_reduce(&net->fs_probe_timer, atj))\n\t\tafs_dec_servers_outstanding(net);\n}\n\n \nstatic void afs_finished_fs_probe(struct afs_net *net, struct afs_server *server)\n{\n\tbool responded = server->probe.responded;\n\n\twrite_seqlock(&net->fs_lock);\n\tif (responded) {\n\t\tlist_add_tail(&server->probe_link, &net->fs_probe_slow);\n\t} else {\n\t\tserver->rtt = UINT_MAX;\n\t\tclear_bit(AFS_SERVER_FL_RESPONDING, &server->flags);\n\t\tlist_add_tail(&server->probe_link, &net->fs_probe_fast);\n\t}\n\twrite_sequnlock(&net->fs_lock);\n\n\tafs_schedule_fs_probe(net, server, !responded);\n}\n\n \nstatic void afs_done_one_fs_probe(struct afs_net *net, struct afs_server *server)\n{\n\t_enter(\"\");\n\n\tif (atomic_dec_and_test(&server->probe_outstanding))\n\t\tafs_finished_fs_probe(net, server);\n\n\twake_up_all(&server->probe_wq);\n}\n\n \nstatic void afs_fs_probe_not_done(struct afs_net *net,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  struct afs_addr_cursor *ac)\n{\n\tstruct afs_addr_list *alist = ac->alist;\n\tunsigned int index = ac->index;\n\n\t_enter(\"\");\n\n\ttrace_afs_io_error(0, -ENOMEM, afs_io_error_fs_probe_fail);\n\tspin_lock(&server->probe_lock);\n\n\tserver->probe.local_failure = true;\n\tif (server->probe.error == 0)\n\t\tserver->probe.error = -ENOMEM;\n\n\tset_bit(index, &alist->failed);\n\n\tspin_unlock(&server->probe_lock);\n\treturn afs_done_one_fs_probe(net, server);\n}\n\n \nvoid afs_fileserver_probe_result(struct afs_call *call)\n{\n\tstruct afs_addr_list *alist = call->alist;\n\tstruct afs_server *server = call->server;\n\tunsigned int index = call->addr_ix;\n\tunsigned int rtt_us = 0, cap0;\n\tint ret = call->error;\n\n\t_enter(\"%pU,%u\", &server->uuid, index);\n\n\tspin_lock(&server->probe_lock);\n\n\tswitch (ret) {\n\tcase 0:\n\t\tserver->probe.error = 0;\n\t\tgoto responded;\n\tcase -ECONNABORTED:\n\t\tif (!server->probe.responded) {\n\t\t\tserver->probe.abort_code = call->abort_code;\n\t\t\tserver->probe.error = ret;\n\t\t}\n\t\tgoto responded;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\tclear_bit(index, &alist->responded);\n\t\tserver->probe.local_failure = true;\n\t\ttrace_afs_io_error(call->debug_id, ret, afs_io_error_fs_probe_fail);\n\t\tgoto out;\n\tcase -ECONNRESET:  \n\tcase -ERFKILL:\n\tcase -EADDRNOTAVAIL:\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -EHOSTDOWN:\n\tcase -ECONNREFUSED:\n\tcase -ETIMEDOUT:\n\tcase -ETIME:\n\tdefault:\n\t\tclear_bit(index, &alist->responded);\n\t\tset_bit(index, &alist->failed);\n\t\tif (!server->probe.responded &&\n\t\t    (server->probe.error == 0 ||\n\t\t     server->probe.error == -ETIMEDOUT ||\n\t\t     server->probe.error == -ETIME))\n\t\t\tserver->probe.error = ret;\n\t\ttrace_afs_io_error(call->debug_id, ret, afs_io_error_fs_probe_fail);\n\t\tgoto out;\n\t}\n\nresponded:\n\tclear_bit(index, &alist->failed);\n\n\tif (call->service_id == YFS_FS_SERVICE) {\n\t\tserver->probe.is_yfs = true;\n\t\tset_bit(AFS_SERVER_FL_IS_YFS, &server->flags);\n\t\talist->addrs[index].srx_service = call->service_id;\n\t} else {\n\t\tserver->probe.not_yfs = true;\n\t\tif (!server->probe.is_yfs) {\n\t\t\tclear_bit(AFS_SERVER_FL_IS_YFS, &server->flags);\n\t\t\talist->addrs[index].srx_service = call->service_id;\n\t\t}\n\t\tcap0 = ntohl(call->tmp);\n\t\tif (cap0 & AFS3_VICED_CAPABILITY_64BITFILES)\n\t\t\tset_bit(AFS_SERVER_FL_HAS_FS64, &server->flags);\n\t\telse\n\t\t\tclear_bit(AFS_SERVER_FL_HAS_FS64, &server->flags);\n\t}\n\n\trxrpc_kernel_get_srtt(call->net->socket, call->rxcall, &rtt_us);\n\tif (rtt_us < server->probe.rtt) {\n\t\tserver->probe.rtt = rtt_us;\n\t\tserver->rtt = rtt_us;\n\t\talist->preferred = index;\n\t}\n\n\tsmp_wmb();  \n\tserver->probe.responded = true;\n\tset_bit(index, &alist->responded);\n\tset_bit(AFS_SERVER_FL_RESPONDING, &server->flags);\nout:\n\tspin_unlock(&server->probe_lock);\n\n\t_debug(\"probe %pU [%u] %pISpc rtt=%u ret=%d\",\n\t       &server->uuid, index, &alist->addrs[index].transport,\n\t       rtt_us, ret);\n\n\treturn afs_done_one_fs_probe(call->net, server);\n}\n\n \nvoid afs_fs_probe_fileserver(struct afs_net *net, struct afs_server *server,\n\t\t\t     struct key *key, bool all)\n{\n\tstruct afs_addr_cursor ac = {\n\t\t.index = 0,\n\t};\n\n\t_enter(\"%pU\", &server->uuid);\n\n\tread_lock(&server->fs_lock);\n\tac.alist = rcu_dereference_protected(server->addresses,\n\t\t\t\t\t     lockdep_is_held(&server->fs_lock));\n\tafs_get_addrlist(ac.alist);\n\tread_unlock(&server->fs_lock);\n\n\tserver->probed_at = jiffies;\n\tatomic_set(&server->probe_outstanding, all ? ac.alist->nr_addrs : 1);\n\tmemset(&server->probe, 0, sizeof(server->probe));\n\tserver->probe.rtt = UINT_MAX;\n\n\tac.index = ac.alist->preferred;\n\tif (ac.index < 0 || ac.index >= ac.alist->nr_addrs)\n\t\tall = true;\n\n\tif (all) {\n\t\tfor (ac.index = 0; ac.index < ac.alist->nr_addrs; ac.index++)\n\t\t\tif (!afs_fs_get_capabilities(net, server, &ac, key))\n\t\t\t\tafs_fs_probe_not_done(net, server, &ac);\n\t} else {\n\t\tif (!afs_fs_get_capabilities(net, server, &ac, key))\n\t\t\tafs_fs_probe_not_done(net, server, &ac);\n\t}\n\n\tafs_put_addrlist(ac.alist);\n}\n\n \nint afs_wait_for_fs_probes(struct afs_server_list *slist, unsigned long untried)\n{\n\tstruct wait_queue_entry *waits;\n\tstruct afs_server *server;\n\tunsigned int rtt = UINT_MAX, rtt_s;\n\tbool have_responders = false;\n\tint pref = -1, i;\n\n\t_enter(\"%u,%lx\", slist->nr_servers, untried);\n\n\t \n\tfor (i = 0; i < slist->nr_servers; i++) {\n\t\tif (test_bit(i, &untried)) {\n\t\t\tserver = slist->servers[i].server;\n\t\t\tif (!atomic_read(&server->probe_outstanding))\n\t\t\t\t__clear_bit(i, &untried);\n\t\t\tif (server->probe.responded)\n\t\t\t\thave_responders = true;\n\t\t}\n\t}\n\tif (have_responders || !untried)\n\t\treturn 0;\n\n\twaits = kmalloc(array_size(slist->nr_servers, sizeof(*waits)), GFP_KERNEL);\n\tif (!waits)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < slist->nr_servers; i++) {\n\t\tif (test_bit(i, &untried)) {\n\t\t\tserver = slist->servers[i].server;\n\t\t\tinit_waitqueue_entry(&waits[i], current);\n\t\t\tadd_wait_queue(&server->probe_wq, &waits[i]);\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\tbool still_probing = false;\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tfor (i = 0; i < slist->nr_servers; i++) {\n\t\t\tif (test_bit(i, &untried)) {\n\t\t\t\tserver = slist->servers[i].server;\n\t\t\t\tif (server->probe.responded)\n\t\t\t\t\tgoto stop;\n\t\t\t\tif (atomic_read(&server->probe_outstanding))\n\t\t\t\t\tstill_probing = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!still_probing || signal_pending(current))\n\t\t\tgoto stop;\n\t\tschedule();\n\t}\n\nstop:\n\tset_current_state(TASK_RUNNING);\n\n\tfor (i = 0; i < slist->nr_servers; i++) {\n\t\tif (test_bit(i, &untried)) {\n\t\t\tserver = slist->servers[i].server;\n\t\t\trtt_s = READ_ONCE(server->rtt);\n\t\t\tif (test_bit(AFS_SERVER_FL_RESPONDING, &server->flags) &&\n\t\t\t    rtt_s < rtt) {\n\t\t\t\tpref = i;\n\t\t\t\trtt = rtt_s;\n\t\t\t}\n\n\t\t\tremove_wait_queue(&server->probe_wq, &waits[i]);\n\t\t}\n\t}\n\n\tkfree(waits);\n\n\tif (pref == -1 && signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\tif (pref >= 0)\n\t\tslist->preferred = pref;\n\treturn 0;\n}\n\n \nvoid afs_fs_probe_timer(struct timer_list *timer)\n{\n\tstruct afs_net *net = container_of(timer, struct afs_net, fs_probe_timer);\n\n\tif (!net->live || !queue_work(afs_wq, &net->fs_prober))\n\t\tafs_dec_servers_outstanding(net);\n}\n\n \nstatic void afs_dispatch_fs_probe(struct afs_net *net, struct afs_server *server, bool all)\n\t__releases(&net->fs_lock)\n{\n\tstruct key *key = NULL;\n\n\t \n\tlist_del_init(&server->probe_link);\n\n\tafs_get_server(server, afs_server_trace_get_probe);\n\twrite_sequnlock(&net->fs_lock);\n\n\tafs_fs_probe_fileserver(net, server, key, all);\n\tafs_put_server(net, server, afs_server_trace_put_probe);\n}\n\n \nvoid afs_probe_fileserver(struct afs_net *net, struct afs_server *server)\n{\n\twrite_seqlock(&net->fs_lock);\n\tif (!list_empty(&server->probe_link))\n\t\treturn afs_dispatch_fs_probe(net, server, true);\n\twrite_sequnlock(&net->fs_lock);\n}\n\n \nvoid afs_fs_probe_dispatcher(struct work_struct *work)\n{\n\tstruct afs_net *net = container_of(work, struct afs_net, fs_prober);\n\tstruct afs_server *fast, *slow, *server;\n\tunsigned long nowj, timer_at, poll_at;\n\tbool first_pass = true, set_timer = false;\n\n\tif (!net->live) {\n\t\tafs_dec_servers_outstanding(net);\n\t\treturn;\n\t}\n\n\t_enter(\"\");\n\n\tif (list_empty(&net->fs_probe_fast) && list_empty(&net->fs_probe_slow)) {\n\t\tafs_dec_servers_outstanding(net);\n\t\t_leave(\" [none]\");\n\t\treturn;\n\t}\n\nagain:\n\twrite_seqlock(&net->fs_lock);\n\n\tfast = slow = server = NULL;\n\tnowj = jiffies;\n\ttimer_at = nowj + MAX_JIFFY_OFFSET;\n\n\tif (!list_empty(&net->fs_probe_fast)) {\n\t\tfast = list_first_entry(&net->fs_probe_fast, struct afs_server, probe_link);\n\t\tpoll_at = fast->probed_at + afs_fs_probe_fast_poll_interval;\n\t\tif (time_before(nowj, poll_at)) {\n\t\t\ttimer_at = poll_at;\n\t\t\tset_timer = true;\n\t\t\tfast = NULL;\n\t\t}\n\t}\n\n\tif (!list_empty(&net->fs_probe_slow)) {\n\t\tslow = list_first_entry(&net->fs_probe_slow, struct afs_server, probe_link);\n\t\tpoll_at = slow->probed_at + afs_fs_probe_slow_poll_interval;\n\t\tif (time_before(nowj, poll_at)) {\n\t\t\tif (time_before(poll_at, timer_at))\n\t\t\t    timer_at = poll_at;\n\t\t\tset_timer = true;\n\t\t\tslow = NULL;\n\t\t}\n\t}\n\n\tserver = fast ?: slow;\n\tif (server)\n\t\t_debug(\"probe %pU\", &server->uuid);\n\n\tif (server && (first_pass || !need_resched())) {\n\t\tafs_dispatch_fs_probe(net, server, server == fast);\n\t\tfirst_pass = false;\n\t\tgoto again;\n\t}\n\n\twrite_sequnlock(&net->fs_lock);\n\n\tif (server) {\n\t\tif (!queue_work(afs_wq, &net->fs_prober))\n\t\t\tafs_dec_servers_outstanding(net);\n\t\t_leave(\" [requeue]\");\n\t} else if (set_timer) {\n\t\tif (timer_reduce(&net->fs_probe_timer, timer_at))\n\t\t\tafs_dec_servers_outstanding(net);\n\t\t_leave(\" [timer]\");\n\t} else {\n\t\tafs_dec_servers_outstanding(net);\n\t\t_leave(\" [quiesce]\");\n\t}\n}\n\n \nint afs_wait_for_one_fs_probe(struct afs_server *server, bool is_intr)\n{\n\tstruct wait_queue_entry wait;\n\tunsigned long timo = 2 * HZ;\n\n\tif (atomic_read(&server->probe_outstanding) == 0)\n\t\tgoto dont_wait;\n\n\tinit_wait_entry(&wait, 0);\n\tfor (;;) {\n\t\tprepare_to_wait_event(&server->probe_wq, &wait,\n\t\t\t\t      is_intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\t\tif (timo == 0 ||\n\t\t    server->probe.responded ||\n\t\t    atomic_read(&server->probe_outstanding) == 0 ||\n\t\t    (is_intr && signal_pending(current)))\n\t\t\tbreak;\n\t\ttimo = schedule_timeout(timo);\n\t}\n\n\tfinish_wait(&server->probe_wq, &wait);\n\ndont_wait:\n\tif (server->probe.responded)\n\t\treturn 0;\n\tif (is_intr && signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\tif (timo == 0)\n\t\treturn -ETIME;\n\treturn -EDESTADDRREQ;\n}\n\n \nvoid afs_fs_probe_cleanup(struct afs_net *net)\n{\n\tif (del_timer_sync(&net->fs_probe_timer))\n\t\tafs_dec_servers_outstanding(net);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}