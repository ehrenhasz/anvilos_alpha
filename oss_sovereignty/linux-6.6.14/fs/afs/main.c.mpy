{
  "module_name": "main.c",
  "hash_id": "5726cee0fc97808a00aff08041c7d389d067a3dbef1396b602aad6bdcd9fa046",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#define CREATE_TRACE_POINTS\n#include \"internal.h\"\n\nMODULE_DESCRIPTION(\"AFS Client File System\");\nMODULE_AUTHOR(\"Red Hat, Inc.\");\nMODULE_LICENSE(\"GPL\");\n\nunsigned afs_debug;\nmodule_param_named(debug, afs_debug, uint, S_IWUSR | S_IRUGO);\nMODULE_PARM_DESC(debug, \"AFS debugging mask\");\n\nstatic char *rootcell;\n\nmodule_param(rootcell, charp, 0);\nMODULE_PARM_DESC(rootcell, \"root AFS cell name and VL server IP addr list\");\n\nstruct workqueue_struct *afs_wq;\nstatic struct proc_dir_entry *afs_proc_symlink;\n\n#if defined(CONFIG_ALPHA)\nconst char afs_init_sysname[] = \"alpha_linux26\";\n#elif defined(CONFIG_X86_64)\nconst char afs_init_sysname[] = \"amd64_linux26\";\n#elif defined(CONFIG_ARM)\nconst char afs_init_sysname[] = \"arm_linux26\";\n#elif defined(CONFIG_ARM64)\nconst char afs_init_sysname[] = \"aarch64_linux26\";\n#elif defined(CONFIG_X86_32)\nconst char afs_init_sysname[] = \"i386_linux26\";\n#elif defined(CONFIG_IA64)\nconst char afs_init_sysname[] = \"ia64_linux26\";\n#elif defined(CONFIG_PPC64)\nconst char afs_init_sysname[] = \"ppc64_linux26\";\n#elif defined(CONFIG_PPC32)\nconst char afs_init_sysname[] = \"ppc_linux26\";\n#elif defined(CONFIG_S390)\n#ifdef CONFIG_64BIT\nconst char afs_init_sysname[] = \"s390x_linux26\";\n#else\nconst char afs_init_sysname[] = \"s390_linux26\";\n#endif\n#elif defined(CONFIG_SPARC64)\nconst char afs_init_sysname[] = \"sparc64_linux26\";\n#elif defined(CONFIG_SPARC32)\nconst char afs_init_sysname[] = \"sparc_linux26\";\n#else\nconst char afs_init_sysname[] = \"unknown_linux26\";\n#endif\n\n \nstatic int __net_init afs_net_init(struct net *net_ns)\n{\n\tstruct afs_sysnames *sysnames;\n\tstruct afs_net *net = afs_net(net_ns);\n\tint ret;\n\n\tnet->net = net_ns;\n\tnet->live = true;\n\tgenerate_random_uuid((unsigned char *)&net->uuid);\n\n\tINIT_WORK(&net->charge_preallocation_work, afs_charge_preallocation);\n\tmutex_init(&net->socket_mutex);\n\n\tnet->cells = RB_ROOT;\n\tinit_rwsem(&net->cells_lock);\n\tINIT_WORK(&net->cells_manager, afs_manage_cells);\n\ttimer_setup(&net->cells_timer, afs_cells_timer, 0);\n\n\tmutex_init(&net->cells_alias_lock);\n\tmutex_init(&net->proc_cells_lock);\n\tINIT_HLIST_HEAD(&net->proc_cells);\n\n\tseqlock_init(&net->fs_lock);\n\tnet->fs_servers = RB_ROOT;\n\tINIT_LIST_HEAD(&net->fs_probe_fast);\n\tINIT_LIST_HEAD(&net->fs_probe_slow);\n\tINIT_HLIST_HEAD(&net->fs_proc);\n\n\tINIT_HLIST_HEAD(&net->fs_addresses4);\n\tINIT_HLIST_HEAD(&net->fs_addresses6);\n\tseqlock_init(&net->fs_addr_lock);\n\n\tINIT_WORK(&net->fs_manager, afs_manage_servers);\n\ttimer_setup(&net->fs_timer, afs_servers_timer, 0);\n\tINIT_WORK(&net->fs_prober, afs_fs_probe_dispatcher);\n\ttimer_setup(&net->fs_probe_timer, afs_fs_probe_timer, 0);\n\tatomic_set(&net->servers_outstanding, 1);\n\n\tret = -ENOMEM;\n\tsysnames = kzalloc(sizeof(*sysnames), GFP_KERNEL);\n\tif (!sysnames)\n\t\tgoto error_sysnames;\n\tsysnames->subs[0] = (char *)&afs_init_sysname;\n\tsysnames->nr = 1;\n\trefcount_set(&sysnames->usage, 1);\n\tnet->sysnames = sysnames;\n\trwlock_init(&net->sysnames_lock);\n\n\t \n\tret = afs_proc_init(net);\n\tif (ret < 0)\n\t\tgoto error_proc;\n\n\t \n\tret = afs_cell_init(net, rootcell);\n\tif (ret < 0)\n\t\tgoto error_cell_init;\n\n\t \n\tret = afs_open_socket(net);\n\tif (ret < 0)\n\t\tgoto error_open_socket;\n\n\treturn 0;\n\nerror_open_socket:\n\tnet->live = false;\n\tafs_fs_probe_cleanup(net);\n\tafs_cell_purge(net);\n\tafs_purge_servers(net);\nerror_cell_init:\n\tnet->live = false;\n\tafs_proc_cleanup(net);\nerror_proc:\n\tafs_put_sysnames(net->sysnames);\nerror_sysnames:\n\tnet->live = false;\n\treturn ret;\n}\n\n \nstatic void __net_exit afs_net_exit(struct net *net_ns)\n{\n\tstruct afs_net *net = afs_net(net_ns);\n\n\tnet->live = false;\n\tafs_fs_probe_cleanup(net);\n\tafs_cell_purge(net);\n\tafs_purge_servers(net);\n\tafs_close_socket(net);\n\tafs_proc_cleanup(net);\n\tafs_put_sysnames(net->sysnames);\n}\n\nstatic struct pernet_operations afs_net_ops = {\n\t.init\t= afs_net_init,\n\t.exit\t= afs_net_exit,\n\t.id\t= &afs_net_id,\n\t.size\t= sizeof(struct afs_net),\n};\n\n \nstatic int __init afs_init(void)\n{\n\tint ret = -ENOMEM;\n\n\tprintk(KERN_INFO \"kAFS: Red Hat AFS client v0.1 registering.\\n\");\n\n\tafs_wq = alloc_workqueue(\"afs\", 0, 0);\n\tif (!afs_wq)\n\t\tgoto error_afs_wq;\n\tafs_async_calls = alloc_workqueue(\"kafsd\", WQ_MEM_RECLAIM, 0);\n\tif (!afs_async_calls)\n\t\tgoto error_async;\n\tafs_lock_manager = alloc_workqueue(\"kafs_lockd\", WQ_MEM_RECLAIM, 0);\n\tif (!afs_lock_manager)\n\t\tgoto error_lockmgr;\n\n\tret = register_pernet_device(&afs_net_ops);\n\tif (ret < 0)\n\t\tgoto error_net;\n\n\t \n\tret = afs_fs_init();\n\tif (ret < 0)\n\t\tgoto error_fs;\n\n\tafs_proc_symlink = proc_symlink(\"fs/afs\", NULL, \"../self/net/afs\");\n\tif (!afs_proc_symlink) {\n\t\tret = -ENOMEM;\n\t\tgoto error_proc;\n\t}\n\n\treturn ret;\n\nerror_proc:\n\tafs_fs_exit();\nerror_fs:\n\tunregister_pernet_device(&afs_net_ops);\nerror_net:\n\tdestroy_workqueue(afs_lock_manager);\nerror_lockmgr:\n\tdestroy_workqueue(afs_async_calls);\nerror_async:\n\tdestroy_workqueue(afs_wq);\nerror_afs_wq:\n\trcu_barrier();\n\tprintk(KERN_ERR \"kAFS: failed to register: %d\\n\", ret);\n\treturn ret;\n}\n\n \nlate_initcall(afs_init);\t \n\n \nstatic void __exit afs_exit(void)\n{\n\tprintk(KERN_INFO \"kAFS: Red Hat AFS client v0.1 unregistering.\\n\");\n\n\tproc_remove(afs_proc_symlink);\n\tafs_fs_exit();\n\tunregister_pernet_device(&afs_net_ops);\n\tdestroy_workqueue(afs_lock_manager);\n\tdestroy_workqueue(afs_async_calls);\n\tdestroy_workqueue(afs_wq);\n\tafs_clean_up_permit_cache();\n\trcu_barrier();\n}\n\nmodule_exit(afs_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}