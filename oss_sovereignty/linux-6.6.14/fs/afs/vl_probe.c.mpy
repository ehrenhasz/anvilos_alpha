{
  "module_name": "vl_probe.c",
  "hash_id": "dbe780713885dcd4b59ffe2c41fd58ee59470aacf2acfc78939de6f965c85cda",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/vl_probe.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include \"protocol_yfs.h\"\n\n\n \nstatic void afs_finished_vl_probe(struct afs_vlserver *server)\n{\n\tif (!(server->probe.flags & AFS_VLSERVER_PROBE_RESPONDED)) {\n\t\tserver->rtt = UINT_MAX;\n\t\tclear_bit(AFS_VLSERVER_FL_RESPONDING, &server->flags);\n\t}\n\n\tclear_bit_unlock(AFS_VLSERVER_FL_PROBING, &server->flags);\n\twake_up_bit(&server->flags, AFS_VLSERVER_FL_PROBING);\n}\n\n \nstatic void afs_done_one_vl_probe(struct afs_vlserver *server, bool wake_up)\n{\n\tif (atomic_dec_and_test(&server->probe_outstanding)) {\n\t\tafs_finished_vl_probe(server);\n\t\twake_up = true;\n\t}\n\n\tif (wake_up)\n\t\twake_up_all(&server->probe_wq);\n}\n\n \nvoid afs_vlserver_probe_result(struct afs_call *call)\n{\n\tstruct afs_addr_list *alist = call->alist;\n\tstruct afs_vlserver *server = call->vlserver;\n\tunsigned int server_index = call->server_index;\n\tunsigned int rtt_us = 0;\n\tunsigned int index = call->addr_ix;\n\tbool have_result = false;\n\tint ret = call->error;\n\n\t_enter(\"%s,%u,%u,%d,%d\", server->name, server_index, index, ret, call->abort_code);\n\n\tspin_lock(&server->probe_lock);\n\n\tswitch (ret) {\n\tcase 0:\n\t\tserver->probe.error = 0;\n\t\tgoto responded;\n\tcase -ECONNABORTED:\n\t\tif (!(server->probe.flags & AFS_VLSERVER_PROBE_RESPONDED)) {\n\t\t\tserver->probe.abort_code = call->abort_code;\n\t\t\tserver->probe.error = ret;\n\t\t}\n\t\tgoto responded;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\tcase -EKEYEXPIRED:\n\tcase -EKEYREVOKED:\n\tcase -EKEYREJECTED:\n\t\tserver->probe.flags |= AFS_VLSERVER_PROBE_LOCAL_FAILURE;\n\t\tif (server->probe.error == 0)\n\t\t\tserver->probe.error = ret;\n\t\ttrace_afs_io_error(call->debug_id, ret, afs_io_error_vl_probe_fail);\n\t\tgoto out;\n\tcase -ECONNRESET:  \n\tcase -ERFKILL:\n\tcase -EADDRNOTAVAIL:\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -EHOSTDOWN:\n\tcase -ECONNREFUSED:\n\tcase -ETIMEDOUT:\n\tcase -ETIME:\n\tdefault:\n\t\tclear_bit(index, &alist->responded);\n\t\tset_bit(index, &alist->failed);\n\t\tif (!(server->probe.flags & AFS_VLSERVER_PROBE_RESPONDED) &&\n\t\t    (server->probe.error == 0 ||\n\t\t     server->probe.error == -ETIMEDOUT ||\n\t\t     server->probe.error == -ETIME))\n\t\t\tserver->probe.error = ret;\n\t\ttrace_afs_io_error(call->debug_id, ret, afs_io_error_vl_probe_fail);\n\t\tgoto out;\n\t}\n\nresponded:\n\tset_bit(index, &alist->responded);\n\tclear_bit(index, &alist->failed);\n\n\tif (call->service_id == YFS_VL_SERVICE) {\n\t\tserver->probe.flags |= AFS_VLSERVER_PROBE_IS_YFS;\n\t\tset_bit(AFS_VLSERVER_FL_IS_YFS, &server->flags);\n\t\talist->addrs[index].srx_service = call->service_id;\n\t} else {\n\t\tserver->probe.flags |= AFS_VLSERVER_PROBE_NOT_YFS;\n\t\tif (!(server->probe.flags & AFS_VLSERVER_PROBE_IS_YFS)) {\n\t\t\tclear_bit(AFS_VLSERVER_FL_IS_YFS, &server->flags);\n\t\t\talist->addrs[index].srx_service = call->service_id;\n\t\t}\n\t}\n\n\trxrpc_kernel_get_srtt(call->net->socket, call->rxcall, &rtt_us);\n\tif (rtt_us < server->probe.rtt) {\n\t\tserver->probe.rtt = rtt_us;\n\t\tserver->rtt = rtt_us;\n\t\talist->preferred = index;\n\t}\n\n\tsmp_wmb();  \n\tserver->probe.flags |= AFS_VLSERVER_PROBE_RESPONDED;\n\tset_bit(AFS_VLSERVER_FL_PROBED, &server->flags);\n\tset_bit(AFS_VLSERVER_FL_RESPONDING, &server->flags);\n\thave_result = true;\nout:\n\tspin_unlock(&server->probe_lock);\n\n\t_debug(\"probe [%u][%u] %pISpc rtt=%u ret=%d\",\n\t       server_index, index, &alist->addrs[index].transport, rtt_us, ret);\n\n\tafs_done_one_vl_probe(server, have_result);\n}\n\n \nstatic bool afs_do_probe_vlserver(struct afs_net *net,\n\t\t\t\t  struct afs_vlserver *server,\n\t\t\t\t  struct key *key,\n\t\t\t\t  unsigned int server_index,\n\t\t\t\t  struct afs_error *_e)\n{\n\tstruct afs_addr_cursor ac = {\n\t\t.index = 0,\n\t};\n\tstruct afs_call *call;\n\tbool in_progress = false;\n\n\t_enter(\"%s\", server->name);\n\n\tread_lock(&server->lock);\n\tac.alist = rcu_dereference_protected(server->addresses,\n\t\t\t\t\t     lockdep_is_held(&server->lock));\n\tread_unlock(&server->lock);\n\n\tatomic_set(&server->probe_outstanding, ac.alist->nr_addrs);\n\tmemset(&server->probe, 0, sizeof(server->probe));\n\tserver->probe.rtt = UINT_MAX;\n\n\tfor (ac.index = 0; ac.index < ac.alist->nr_addrs; ac.index++) {\n\t\tcall = afs_vl_get_capabilities(net, &ac, key, server,\n\t\t\t\t\t       server_index);\n\t\tif (!IS_ERR(call)) {\n\t\t\tafs_put_call(call);\n\t\t\tin_progress = true;\n\t\t} else {\n\t\t\tafs_prioritise_error(_e, PTR_ERR(call), ac.abort_code);\n\t\t\tafs_done_one_vl_probe(server, false);\n\t\t}\n\t}\n\n\treturn in_progress;\n}\n\n \nint afs_send_vl_probes(struct afs_net *net, struct key *key,\n\t\t       struct afs_vlserver_list *vllist)\n{\n\tstruct afs_vlserver *server;\n\tstruct afs_error e;\n\tbool in_progress = false;\n\tint i;\n\n\te.error = 0;\n\te.responded = false;\n\tfor (i = 0; i < vllist->nr_servers; i++) {\n\t\tserver = vllist->servers[i].server;\n\t\tif (test_bit(AFS_VLSERVER_FL_PROBED, &server->flags))\n\t\t\tcontinue;\n\n\t\tif (!test_and_set_bit_lock(AFS_VLSERVER_FL_PROBING, &server->flags) &&\n\t\t    afs_do_probe_vlserver(net, server, key, i, &e))\n\t\t\tin_progress = true;\n\t}\n\n\treturn in_progress ? 0 : e.error;\n}\n\n \nint afs_wait_for_vl_probes(struct afs_vlserver_list *vllist,\n\t\t\t   unsigned long untried)\n{\n\tstruct wait_queue_entry *waits;\n\tstruct afs_vlserver *server;\n\tunsigned int rtt = UINT_MAX, rtt_s;\n\tbool have_responders = false;\n\tint pref = -1, i;\n\n\t_enter(\"%u,%lx\", vllist->nr_servers, untried);\n\n\t \n\tfor (i = 0; i < vllist->nr_servers; i++) {\n\t\tif (test_bit(i, &untried)) {\n\t\t\tserver = vllist->servers[i].server;\n\t\t\tif (!test_bit(AFS_VLSERVER_FL_PROBING, &server->flags))\n\t\t\t\t__clear_bit(i, &untried);\n\t\t\tif (server->probe.flags & AFS_VLSERVER_PROBE_RESPONDED)\n\t\t\t\thave_responders = true;\n\t\t}\n\t}\n\tif (have_responders || !untried)\n\t\treturn 0;\n\n\twaits = kmalloc(array_size(vllist->nr_servers, sizeof(*waits)), GFP_KERNEL);\n\tif (!waits)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < vllist->nr_servers; i++) {\n\t\tif (test_bit(i, &untried)) {\n\t\t\tserver = vllist->servers[i].server;\n\t\t\tinit_waitqueue_entry(&waits[i], current);\n\t\t\tadd_wait_queue(&server->probe_wq, &waits[i]);\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\tbool still_probing = false;\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tfor (i = 0; i < vllist->nr_servers; i++) {\n\t\t\tif (test_bit(i, &untried)) {\n\t\t\t\tserver = vllist->servers[i].server;\n\t\t\t\tif (server->probe.flags & AFS_VLSERVER_PROBE_RESPONDED)\n\t\t\t\t\tgoto stop;\n\t\t\t\tif (test_bit(AFS_VLSERVER_FL_PROBING, &server->flags))\n\t\t\t\t\tstill_probing = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!still_probing || signal_pending(current))\n\t\t\tgoto stop;\n\t\tschedule();\n\t}\n\nstop:\n\tset_current_state(TASK_RUNNING);\n\n\tfor (i = 0; i < vllist->nr_servers; i++) {\n\t\tif (test_bit(i, &untried)) {\n\t\t\tserver = vllist->servers[i].server;\n\t\t\trtt_s = READ_ONCE(server->rtt);\n\t\t\tif (test_bit(AFS_VLSERVER_FL_RESPONDING, &server->flags) &&\n\t\t\t    rtt_s < rtt) {\n\t\t\t\tpref = i;\n\t\t\t\trtt = rtt_s;\n\t\t\t}\n\n\t\t\tremove_wait_queue(&server->probe_wq, &waits[i]);\n\t\t}\n\t}\n\n\tkfree(waits);\n\n\tif (pref == -1 && signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\tif (pref >= 0)\n\t\tvllist->preferred = pref;\n\n\t_leave(\" = 0 [%u]\", pref);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}