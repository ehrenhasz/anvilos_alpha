{
  "module_name": "internal.h",
  "hash_id": "54279070d36e0ee921b4aadfa62a8169a788b333446f2a797a9168184beb3432",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/internal.h",
  "human_readable_source": " \n \n\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/fs.h>\n#include <linux/filelock.h>\n#include <linux/pagemap.h>\n#include <linux/rxrpc.h>\n#include <linux/key.h>\n#include <linux/workqueue.h>\n#include <linux/sched.h>\n#include <linux/fscache.h>\n#include <linux/backing-dev.h>\n#include <linux/uuid.h>\n#include <linux/mm_types.h>\n#include <linux/dns_resolver.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n\n#include \"afs.h\"\n#include \"afs_vl.h\"\n\n#define AFS_CELL_MAX_ADDRS 15\n\nstruct pagevec;\nstruct afs_call;\nstruct afs_vnode;\n\n \nenum afs_flock_mode {\n\tafs_flock_mode_unset,\n\tafs_flock_mode_local,\t \n\tafs_flock_mode_openafs,\t \n\tafs_flock_mode_strict,\t \n\tafs_flock_mode_write,\t \n};\n\nstruct afs_fs_context {\n\tbool\t\t\tforce;\t\t \n\tbool\t\t\tautocell;\t \n\tbool\t\t\tdyn_root;\t \n\tbool\t\t\tno_cell;\t \n\tenum afs_flock_mode\tflock_mode;\t \n\tafs_voltype_t\t\ttype;\t\t \n\tunsigned int\t\tvolnamesz;\t \n\tconst char\t\t*volname;\t \n\tstruct afs_net\t\t*net;\t\t \n\tstruct afs_cell\t\t*cell;\t\t \n\tstruct afs_volume\t*volume;\t \n\tstruct key\t\t*key;\t\t \n};\n\nenum afs_call_state {\n\tAFS_CALL_CL_REQUESTING,\t\t \n\tAFS_CALL_CL_AWAIT_REPLY,\t \n\tAFS_CALL_CL_PROC_REPLY,\t\t \n\tAFS_CALL_SV_AWAIT_OP_ID,\t \n\tAFS_CALL_SV_AWAIT_REQUEST,\t \n\tAFS_CALL_SV_REPLYING,\t\t \n\tAFS_CALL_SV_AWAIT_ACK,\t\t \n\tAFS_CALL_COMPLETE,\t\t \n};\n\n \nstruct afs_addr_list {\n\tstruct rcu_head\t\trcu;\n\trefcount_t\t\tusage;\n\tu32\t\t\tversion;\t \n\tunsigned char\t\tmax_addrs;\n\tunsigned char\t\tnr_addrs;\n\tunsigned char\t\tpreferred;\t \n\tunsigned char\t\tnr_ipv4;\t \n\tenum dns_record_source\tsource:8;\n\tenum dns_lookup_status\tstatus:8;\n\tunsigned long\t\tfailed;\t\t \n\tunsigned long\t\tresponded;\t \n\tstruct sockaddr_rxrpc\taddrs[];\n#define AFS_MAX_ADDRESSES ((unsigned int)(sizeof(unsigned long) * 8))\n};\n\n \nstruct afs_call {\n\tconst struct afs_call_type *type;\t \n\tstruct afs_addr_list\t*alist;\t\t \n\twait_queue_head_t\twaitq;\t\t \n\tstruct work_struct\tasync_work;\t \n\tstruct work_struct\twork;\t\t \n\tstruct rxrpc_call\t*rxcall;\t \n\tstruct key\t\t*key;\t\t \n\tstruct afs_net\t\t*net;\t\t \n\tstruct afs_server\t*server;\t \n\tstruct afs_vlserver\t*vlserver;\t \n\tvoid\t\t\t*request;\t \n\tsize_t\t\t\tiov_len;\t \n\tstruct iov_iter\t\tdef_iter;\t \n\tstruct iov_iter\t\t*write_iter;\t \n\tstruct iov_iter\t\t*iter;\t\t \n\tunion {\t \n\t\tstruct kvec\tkvec[1];\n\t\tstruct bio_vec\tbvec[1];\n\t};\n\tvoid\t\t\t*buffer;\t \n\tunion {\n\t\tlong\t\t\tret0;\t \n\t\tstruct afs_addr_list\t*ret_alist;\n\t\tstruct afs_vldb_entry\t*ret_vldb;\n\t\tchar\t\t\t*ret_str;\n\t};\n\tstruct afs_operation\t*op;\n\tunsigned int\t\tserver_index;\n\trefcount_t\t\tref;\n\tenum afs_call_state\tstate;\n\tspinlock_t\t\tstate_lock;\n\tint\t\t\terror;\t\t \n\tu32\t\t\tabort_code;\t \n\tunsigned int\t\tmax_lifespan;\t \n\tunsigned\t\trequest_size;\t \n\tunsigned\t\treply_max;\t \n\tunsigned\t\tcount2;\t\t \n\tunsigned char\t\tunmarshall;\t \n\tunsigned char\t\taddr_ix;\t \n\tbool\t\t\tdrop_ref;\t \n\tbool\t\t\tneed_attention;\t \n\tbool\t\t\tasync;\t\t \n\tbool\t\t\tupgrade;\t \n\tbool\t\t\tintr;\t\t \n\tbool\t\t\tunmarshalling_error;  \n\tu16\t\t\tservice_id;\t \n\tunsigned int\t\tdebug_id;\t \n\tu32\t\t\toperation_ID;\t \n\tu32\t\t\tcount;\t\t \n\tunion {\t\t\t\t\t \n\t\tstruct {\n\t\t\t__be32\ttmp_u;\n\t\t\t__be32\ttmp;\n\t\t} __attribute__((packed));\n\t\t__be64\t\ttmp64;\n\t};\n\tktime_t\t\t\tissue_time;\t \n};\n\nstruct afs_call_type {\n\tconst char *name;\n\tunsigned int op;  \n\n\t \n\tint (*deliver)(struct afs_call *call);\n\n\t \n\tvoid (*destructor)(struct afs_call *call);\n\n\t \n\tvoid (*work)(struct work_struct *work);\n\n\t \n\tvoid (*done)(struct afs_call *call);\n};\n\n \nstruct afs_wb_key {\n\trefcount_t\t\tusage;\n\tstruct key\t\t*key;\n\tstruct list_head\tvnode_link;\t \n};\n\n \nstruct afs_file {\n\tstruct key\t\t*key;\t\t \n\tstruct afs_wb_key\t*wb;\t\t \n};\n\nstatic inline struct key *afs_file_key(struct file *file)\n{\n\tstruct afs_file *af = file->private_data;\n\n\treturn af->key;\n}\n\n \nstruct afs_read {\n\tloff_t\t\t\tpos;\t\t \n\tloff_t\t\t\tlen;\t\t \n\tloff_t\t\t\tactual_len;\t \n\tloff_t\t\t\tfile_size;\t \n\tstruct key\t\t*key;\t\t \n\tstruct afs_vnode\t*vnode;\t\t \n\tstruct netfs_io_subrequest *subreq;\t \n\tafs_dataversion_t\tdata_version;\t \n\trefcount_t\t\tusage;\n\tunsigned int\t\tcall_debug_id;\n\tunsigned int\t\tnr_pages;\n\tint\t\t\terror;\n\tvoid (*done)(struct afs_read *);\n\tvoid (*cleanup)(struct afs_read *);\n\tstruct iov_iter\t\t*iter;\t\t \n\tstruct iov_iter\t\tdef_iter;\t \n};\n\n \nstruct afs_super_info {\n\tstruct net\t\t*net_ns;\t \n\tstruct afs_cell\t\t*cell;\t\t \n\tstruct afs_volume\t*volume;\t \n\tenum afs_flock_mode\tflock_mode:8;\t \n\tbool\t\t\tdyn_root;\t \n};\n\nstatic inline struct afs_super_info *AFS_FS_S(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\nextern struct file_system_type afs_fs_type;\n\n \nstruct afs_sysnames {\n#define AFS_NR_SYSNAME 16\n\tchar\t\t\t*subs[AFS_NR_SYSNAME];\n\trefcount_t\t\tusage;\n\tunsigned short\t\tnr;\n\tchar\t\t\tblank[1];\n};\n\n \nstruct afs_net {\n\tstruct net\t\t*net;\t\t \n\tstruct afs_uuid\t\tuuid;\n\tbool\t\t\tlive;\t\t \n\n\t \n\tstruct socket\t\t*socket;\n\tstruct afs_call\t\t*spare_incoming_call;\n\tstruct work_struct\tcharge_preallocation_work;\n\tstruct mutex\t\tsocket_mutex;\n\tatomic_t\t\tnr_outstanding_calls;\n\tatomic_t\t\tnr_superblocks;\n\n\t \n\tstruct rb_root\t\tcells;\n\tstruct afs_cell\t\t*ws_cell;\n\tstruct work_struct\tcells_manager;\n\tstruct timer_list\tcells_timer;\n\tatomic_t\t\tcells_outstanding;\n\tstruct rw_semaphore\tcells_lock;\n\tstruct mutex\t\tcells_alias_lock;\n\n\tstruct mutex\t\tproc_cells_lock;\n\tstruct hlist_head\tproc_cells;\n\n\t \n\tseqlock_t\t\tfs_lock;\t \n\tstruct rb_root\t\tfs_servers;\t \n\tstruct list_head\tfs_probe_fast;\t \n\tstruct list_head\tfs_probe_slow;\t \n\tstruct hlist_head\tfs_proc;\t \n\n\tstruct hlist_head\tfs_addresses4;\t \n\tstruct hlist_head\tfs_addresses6;\t \n\tseqlock_t\t\tfs_addr_lock;\t \n\n\tstruct work_struct\tfs_manager;\n\tstruct timer_list\tfs_timer;\n\n\tstruct work_struct\tfs_prober;\n\tstruct timer_list\tfs_probe_timer;\n\tatomic_t\t\tservers_outstanding;\n\n\t \n\tstruct mutex\t\tlock_manager_mutex;\n\n\t \n\tstruct super_block\t*dynroot_sb;\t \n\tstruct proc_dir_entry\t*proc_afs;\t \n\tstruct afs_sysnames\t*sysnames;\n\trwlock_t\t\tsysnames_lock;\n\n\t \n\tatomic_t\t\tn_lookup;\t \n\tatomic_t\t\tn_reval;\t \n\tatomic_t\t\tn_inval;\t \n\tatomic_t\t\tn_relpg;\t \n\tatomic_t\t\tn_read_dir;\t \n\tatomic_t\t\tn_dir_cr;\t \n\tatomic_t\t\tn_dir_rm;\t \n\tatomic_t\t\tn_stores;\t \n\tatomic_long_t\t\tn_store_bytes;\t \n\tatomic_long_t\t\tn_fetch_bytes;\t \n\tatomic_t\t\tn_fetches;\t \n};\n\nextern const char afs_init_sysname[];\n\nenum afs_cell_state {\n\tAFS_CELL_UNSET,\n\tAFS_CELL_ACTIVATING,\n\tAFS_CELL_ACTIVE,\n\tAFS_CELL_DEACTIVATING,\n\tAFS_CELL_INACTIVE,\n\tAFS_CELL_FAILED,\n\tAFS_CELL_REMOVED,\n};\n\n \nstruct afs_cell {\n\tunion {\n\t\tstruct rcu_head\trcu;\n\t\tstruct rb_node\tnet_node;\t \n\t};\n\tstruct afs_net\t\t*net;\n\tstruct afs_cell\t\t*alias_of;\t \n\tstruct afs_volume\t*root_volume;\t \n\tstruct key\t\t*anonymous_key;\t \n\tstruct work_struct\tmanager;\t \n\tstruct hlist_node\tproc_link;\t \n\ttime64_t\t\tdns_expiry;\t \n\ttime64_t\t\tlast_inactive;\t \n\trefcount_t\t\tref;\t\t \n\tatomic_t\t\tactive;\t\t \n\tunsigned long\t\tflags;\n#define AFS_CELL_FL_NO_GC\t0\t\t \n#define AFS_CELL_FL_DO_LOOKUP\t1\t\t \n#define AFS_CELL_FL_CHECK_ALIAS\t2\t\t \n\tenum afs_cell_state\tstate;\n\tshort\t\t\terror;\n\tenum dns_record_source\tdns_source:8;\t \n\tenum dns_lookup_status\tdns_status:8;\t \n\tunsigned int\t\tdns_lookup_count;  \n\tunsigned int\t\tdebug_id;\n\n\t \n\tstruct rb_root\t\tvolumes;\t \n\tstruct hlist_head\tproc_volumes;\t \n\tseqlock_t\t\tvolume_lock;\t \n\n\t \n\tstruct rb_root\t\tfs_servers;\t \n\tseqlock_t\t\tfs_lock;\t \n\tstruct rw_semaphore\tfs_open_mmaps_lock;\n\tstruct list_head\tfs_open_mmaps;\t \n\tatomic_t\t\tfs_s_break;\t \n\n\t \n\trwlock_t\t\tvl_servers_lock;  \n\tstruct afs_vlserver_list __rcu *vl_servers;\n\n\tu8\t\t\tname_len;\t \n\tchar\t\t\t*name;\t\t \n};\n\n \nstruct afs_vlserver {\n\tstruct rcu_head\t\trcu;\n\tstruct afs_addr_list\t__rcu *addresses;  \n\tunsigned long\t\tflags;\n#define AFS_VLSERVER_FL_PROBED\t0\t\t \n#define AFS_VLSERVER_FL_PROBING\t1\t\t \n#define AFS_VLSERVER_FL_IS_YFS\t2\t\t \n#define AFS_VLSERVER_FL_RESPONDING 3\t\t \n\trwlock_t\t\tlock;\t\t \n\trefcount_t\t\tref;\n\tunsigned int\t\trtt;\t\t \n\n\t \n\twait_queue_head_t\tprobe_wq;\n\tatomic_t\t\tprobe_outstanding;\n\tspinlock_t\t\tprobe_lock;\n\tstruct {\n\t\tunsigned int\trtt;\t\t \n\t\tu32\t\tabort_code;\n\t\tshort\t\terror;\n\t\tunsigned short\tflags;\n#define AFS_VLSERVER_PROBE_RESPONDED\t\t0x01  \n#define AFS_VLSERVER_PROBE_IS_YFS\t\t0x02  \n#define AFS_VLSERVER_PROBE_NOT_YFS\t\t0x04  \n#define AFS_VLSERVER_PROBE_LOCAL_FAILURE\t0x08  \n\t} probe;\n\n\tu16\t\t\tport;\n\tu16\t\t\tname_len;\t \n\tchar\t\t\tname[];\t\t \n};\n\n \nstruct afs_vlserver_entry {\n\tu16\t\t\tpriority;\t \n\tu16\t\t\tweight;\t\t \n\tenum dns_record_source\tsource:8;\n\tenum dns_lookup_status\tstatus:8;\n\tstruct afs_vlserver\t*server;\n};\n\nstruct afs_vlserver_list {\n\tstruct rcu_head\t\trcu;\n\trefcount_t\t\tref;\n\tu8\t\t\tnr_servers;\n\tu8\t\t\tindex;\t\t \n\tu8\t\t\tpreferred;\t \n\tenum dns_record_source\tsource:8;\n\tenum dns_lookup_status\tstatus:8;\n\trwlock_t\t\tlock;\n\tstruct afs_vlserver_entry servers[];\n};\n\n \nstruct afs_vldb_entry {\n\tafs_volid_t\t\tvid[3];\t\t \n\n\tunsigned long\t\tflags;\n#define AFS_VLDB_HAS_RW\t\t0\t\t \n#define AFS_VLDB_HAS_RO\t\t1\t\t \n#define AFS_VLDB_HAS_BAK\t2\t\t \n#define AFS_VLDB_QUERY_VALID\t3\t\t \n#define AFS_VLDB_QUERY_ERROR\t4\t\t \n\n\tuuid_t\t\t\tfs_server[AFS_NMAXNSERVERS];\n\tu32\t\t\taddr_version[AFS_NMAXNSERVERS];  \n\tu8\t\t\tfs_mask[AFS_NMAXNSERVERS];\n#define AFS_VOL_VTM_RW\t0x01  \n#define AFS_VOL_VTM_RO\t0x02  \n#define AFS_VOL_VTM_BAK\t0x04  \n\tshort\t\t\terror;\n\tu8\t\t\tnr_servers;\t \n\tu8\t\t\tname_len;\n\tu8\t\t\tname[AFS_MAXVOLNAME + 1];  \n};\n\n \nstruct afs_server {\n\tstruct rcu_head\t\trcu;\n\tunion {\n\t\tuuid_t\t\tuuid;\t\t \n\t\tstruct afs_uuid\t_uuid;\n\t};\n\n\tstruct afs_addr_list\t__rcu *addresses;\n\tstruct afs_cell\t\t*cell;\t\t \n\tstruct rb_node\t\tuuid_rb;\t \n\tstruct afs_server __rcu\t*uuid_next;\t \n\tstruct afs_server\t*uuid_prev;\t \n\tstruct list_head\tprobe_link;\t \n\tstruct hlist_node\taddr4_link;\t \n\tstruct hlist_node\taddr6_link;\t \n\tstruct hlist_node\tproc_link;\t \n\tstruct work_struct\tinitcb_work;\t \n\tstruct afs_server\t*gc_next;\t \n\ttime64_t\t\tunuse_time;\t \n\tunsigned long\t\tflags;\n#define AFS_SERVER_FL_RESPONDING 0\t\t \n#define AFS_SERVER_FL_UPDATING\t1\n#define AFS_SERVER_FL_NEEDS_UPDATE 2\t\t \n#define AFS_SERVER_FL_NOT_READY\t4\t\t \n#define AFS_SERVER_FL_NOT_FOUND\t5\t\t \n#define AFS_SERVER_FL_VL_FAIL\t6\t\t \n#define AFS_SERVER_FL_MAY_HAVE_CB 8\t\t \n#define AFS_SERVER_FL_IS_YFS\t16\t\t \n#define AFS_SERVER_FL_NO_IBULK\t17\t\t \n#define AFS_SERVER_FL_NO_RM2\t18\t\t \n#define AFS_SERVER_FL_HAS_FS64\t19\t\t \n\trefcount_t\t\tref;\t\t \n\tatomic_t\t\tactive;\t\t \n\tu32\t\t\taddr_version;\t \n\tunsigned int\t\trtt;\t\t \n\tunsigned int\t\tdebug_id;\t \n\n\t \n\trwlock_t\t\tfs_lock;\t \n\n\t \n\tunsigned\t\tcb_s_break;\t \n\n\t \n\tunsigned long\t\tprobed_at;\t \n\twait_queue_head_t\tprobe_wq;\n\tatomic_t\t\tprobe_outstanding;\n\tspinlock_t\t\tprobe_lock;\n\tstruct {\n\t\tunsigned int\trtt;\t\t \n\t\tu32\t\tabort_code;\n\t\tshort\t\terror;\n\t\tbool\t\tresponded:1;\n\t\tbool\t\tis_yfs:1;\n\t\tbool\t\tnot_yfs:1;\n\t\tbool\t\tlocal_failure:1;\n\t} probe;\n};\n\n \nstruct afs_server_entry {\n\tstruct afs_server\t*server;\n};\n\nstruct afs_server_list {\n\tstruct rcu_head\t\trcu;\n\tafs_volid_t\t\tvids[AFS_MAXTYPES];  \n\trefcount_t\t\tusage;\n\tunsigned char\t\tnr_servers;\n\tunsigned char\t\tpreferred;\t \n\tunsigned short\t\tvnovol_mask;\t \n\tunsigned int\t\tseq;\t\t \n\trwlock_t\t\tlock;\n\tstruct afs_server_entry\tservers[];\n};\n\n \nstruct afs_volume {\n\tunion {\n\t\tstruct rcu_head\trcu;\n\t\tafs_volid_t\tvid;\t\t \n\t};\n\trefcount_t\t\tref;\n\ttime64_t\t\tupdate_at;\t \n\tstruct afs_cell\t\t*cell;\t\t \n\tstruct rb_node\t\tcell_node;\t \n\tstruct hlist_node\tproc_link;\t \n\tstruct super_block __rcu *sb;\t\t \n\tunsigned long\t\tflags;\n#define AFS_VOLUME_NEEDS_UPDATE\t0\t \n#define AFS_VOLUME_UPDATING\t1\t \n#define AFS_VOLUME_WAIT\t\t2\t \n#define AFS_VOLUME_DELETED\t3\t \n#define AFS_VOLUME_OFFLINE\t4\t \n#define AFS_VOLUME_BUSY\t\t5\t \n#define AFS_VOLUME_MAYBE_NO_IBULK 6\t \n#define AFS_VOLUME_RM_TREE\t7\t \n#ifdef CONFIG_AFS_FSCACHE\n\tstruct fscache_volume\t*cache;\t\t \n#endif\n\tstruct afs_server_list __rcu *servers;\t \n\trwlock_t\t\tservers_lock;\t \n\tunsigned int\t\tservers_seq;\t \n\n\tunsigned\t\tcb_v_break;\t \n\trwlock_t\t\tcb_v_break_lock;\n\n\tafs_voltype_t\t\ttype;\t\t \n\tchar\t\t\ttype_force;\t \n\tu8\t\t\tname_len;\n\tu8\t\t\tname[AFS_MAXVOLNAME + 1];  \n};\n\nenum afs_lock_state {\n\tAFS_VNODE_LOCK_NONE,\t\t \n\tAFS_VNODE_LOCK_WAITING_FOR_CB,\t \n\tAFS_VNODE_LOCK_SETTING,\t\t \n\tAFS_VNODE_LOCK_GRANTED,\t\t \n\tAFS_VNODE_LOCK_EXTENDING,\t \n\tAFS_VNODE_LOCK_NEED_UNLOCK,\t \n\tAFS_VNODE_LOCK_UNLOCKING,\t \n\tAFS_VNODE_LOCK_DELETED,\t\t \n};\n\n \nstruct afs_vnode {\n\tstruct netfs_inode\tnetfs;\t\t \n\tstruct afs_volume\t*volume;\t \n\tstruct afs_fid\t\tfid;\t\t \n\tstruct afs_file_status\tstatus;\t\t \n\tafs_dataversion_t\tinvalid_before;\t \n\tstruct afs_permits __rcu *permit_cache;\t \n\tstruct mutex\t\tio_lock;\t \n\tstruct rw_semaphore\tvalidate_lock;\t \n\tstruct rw_semaphore\trmdir_lock;\t \n\tstruct key\t\t*silly_key;\t \n\tspinlock_t\t\twb_lock;\t \n\tspinlock_t\t\tlock;\t\t \n\tunsigned long\t\tflags;\n#define AFS_VNODE_CB_PROMISED\t0\t\t \n#define AFS_VNODE_UNSET\t\t1\t\t \n#define AFS_VNODE_DIR_VALID\t2\t\t \n#define AFS_VNODE_ZAP_DATA\t3\t\t \n#define AFS_VNODE_DELETED\t4\t\t \n#define AFS_VNODE_MOUNTPOINT\t5\t\t \n#define AFS_VNODE_AUTOCELL\t6\t\t \n#define AFS_VNODE_PSEUDODIR\t7 \t\t \n#define AFS_VNODE_NEW_CONTENT\t8\t\t \n#define AFS_VNODE_SILLY_DELETED\t9\t\t \n#define AFS_VNODE_MODIFYING\t10\t\t \n\n\tstruct list_head\twb_keys;\t \n\tstruct list_head\tpending_locks;\t \n\tstruct list_head\tgranted_locks;\t \n\tstruct delayed_work\tlock_work;\t \n\tstruct key\t\t*lock_key;\t \n\tktime_t\t\t\tlocked_at;\t \n\tenum afs_lock_state\tlock_state : 8;\n\tafs_lock_type_t\t\tlock_type : 8;\n\n\t \n\tstruct work_struct\tcb_work;\t \n\tstruct list_head\tcb_mmap_link;\t \n\tvoid\t\t\t*cb_server;\t \n\tatomic_t\t\tcb_nr_mmap;\t \n\tunsigned int\t\tcb_fs_s_break;\t \n\tunsigned int\t\tcb_s_break;\t \n\tunsigned int\t\tcb_v_break;\t \n\tunsigned int\t\tcb_break;\t \n\tseqlock_t\t\tcb_lock;\t \n\n\ttime64_t\t\tcb_expires_at;\t \n};\n\nstatic inline struct fscache_cookie *afs_vnode_cache(struct afs_vnode *vnode)\n{\n#ifdef CONFIG_AFS_FSCACHE\n\treturn netfs_i_cookie(&vnode->netfs);\n#else\n\treturn NULL;\n#endif\n}\n\nstatic inline void afs_vnode_set_cache(struct afs_vnode *vnode,\n\t\t\t\t       struct fscache_cookie *cookie)\n{\n#ifdef CONFIG_AFS_FSCACHE\n\tvnode->netfs.cache = cookie;\n\tif (cookie)\n\t\tmapping_set_release_always(vnode->netfs.inode.i_mapping);\n#endif\n}\n\n \nstruct afs_permit {\n\tstruct key\t\t*key;\t\t \n\tafs_access_t\t\taccess;\t\t \n};\n\n \nstruct afs_permits {\n\tstruct rcu_head\t\trcu;\n\tstruct hlist_node\thash_node;\t \n\tunsigned long\t\th;\t\t \n\trefcount_t\t\tusage;\n\tunsigned short\t\tnr_permits;\t \n\tbool\t\t\tinvalidated;\t \n\tstruct afs_permit\tpermits[];\t \n};\n\n \nstruct afs_error {\n\tshort\terror;\t\t\t \n\tbool\tresponded;\t\t \n};\n\n \nstruct afs_addr_cursor {\n\tstruct afs_addr_list\t*alist;\t\t \n\tunsigned long\t\ttried;\t\t \n\tsigned char\t\tindex;\t\t \n\tbool\t\t\tresponded;\t \n\tunsigned short\t\tnr_iterations;\t \n\tshort\t\t\terror;\n\tu32\t\t\tabort_code;\n};\n\n \nstruct afs_vl_cursor {\n\tstruct afs_addr_cursor\tac;\n\tstruct afs_cell\t\t*cell;\t\t \n\tstruct afs_vlserver_list *server_list;\t \n\tstruct afs_vlserver\t*server;\t \n\tstruct key\t\t*key;\t\t \n\tunsigned long\t\tuntried;\t \n\tshort\t\t\tindex;\t\t \n\tshort\t\t\terror;\n\tunsigned short\t\tflags;\n#define AFS_VL_CURSOR_STOP\t0x0001\t\t \n#define AFS_VL_CURSOR_RETRY\t0x0002\t\t \n#define AFS_VL_CURSOR_RETRIED\t0x0004\t\t \n\tunsigned short\t\tnr_iterations;\t \n};\n\n \nstruct afs_operation_ops {\n\tvoid (*issue_afs_rpc)(struct afs_operation *op);\n\tvoid (*issue_yfs_rpc)(struct afs_operation *op);\n\tvoid (*success)(struct afs_operation *op);\n\tvoid (*aborted)(struct afs_operation *op);\n\tvoid (*failed)(struct afs_operation *op);\n\tvoid (*edit_dir)(struct afs_operation *op);\n\tvoid (*put)(struct afs_operation *op);\n};\n\nstruct afs_vnode_param {\n\tstruct afs_vnode\t*vnode;\n\tstruct afs_fid\t\tfid;\t\t \n\tstruct afs_status_cb\tscb;\t\t \n\tafs_dataversion_t\tdv_before;\t \n\tunsigned int\t\tcb_break_before;  \n\tu8\t\t\tdv_delta;\t \n\tbool\t\t\tput_vnode:1;\t \n\tbool\t\t\tneed_io_lock:1;\t \n\tbool\t\t\tupdate_ctime:1;\t \n\tbool\t\t\tset_size:1;\t \n\tbool\t\t\top_unlinked:1;\t \n\tbool\t\t\tspeculative:1;\t \n\tbool\t\t\tmodification:1;\t \n};\n\n \nstruct afs_operation {\n\tstruct afs_net\t\t*net;\t\t \n\tstruct key\t\t*key;\t\t \n\tconst struct afs_call_type *type;\t \n\tconst struct afs_operation_ops *ops;\n\n\t \n\tstruct afs_volume\t*volume;\t \n\tstruct afs_vnode_param\tfile[2];\n\tstruct afs_vnode_param\t*more_files;\n\tstruct afs_volsync\tvolsync;\n\tstruct dentry\t\t*dentry;\t \n\tstruct dentry\t\t*dentry_2;\t \n\tstruct timespec64\tmtime;\t\t \n\tstruct timespec64\tctime;\t\t \n\tshort\t\t\tnr_files;\t \n\tshort\t\t\terror;\n\tunsigned int\t\tdebug_id;\n\n\tunsigned int\t\tcb_v_break;\t \n\tunsigned int\t\tcb_s_break;\t \n\n\tunion {\n\t\tstruct {\n\t\t\tint\twhich;\t\t \n\t\t} fetch_status;\n\t\tstruct {\n\t\t\tint\treason;\t\t \n\t\t\tmode_t\tmode;\n\t\t\tconst char *symlink;\n\t\t} create;\n\t\tstruct {\n\t\t\tbool\tneed_rehash;\n\t\t} unlink;\n\t\tstruct {\n\t\t\tstruct dentry *rehash;\n\t\t\tstruct dentry *tmp;\n\t\t\tbool\tnew_negative;\n\t\t} rename;\n\t\tstruct {\n\t\t\tstruct afs_read *req;\n\t\t} fetch;\n\t\tstruct {\n\t\t\tafs_lock_type_t type;\n\t\t} lock;\n\t\tstruct {\n\t\t\tstruct iov_iter\t*write_iter;\n\t\t\tloff_t\tpos;\n\t\t\tloff_t\tsize;\n\t\t\tloff_t\ti_size;\n\t\t\tbool\tlaundering;\t \n\t\t} store;\n\t\tstruct {\n\t\t\tstruct iattr\t*attr;\n\t\t\tloff_t\t\told_i_size;\n\t\t} setattr;\n\t\tstruct afs_acl\t*acl;\n\t\tstruct yfs_acl\t*yacl;\n\t\tstruct {\n\t\t\tstruct afs_volume_status vs;\n\t\t\tstruct kstatfs\t\t*buf;\n\t\t} volstatus;\n\t};\n\n\t \n\tstruct afs_addr_cursor\tac;\n\tstruct afs_server_list\t*server_list;\t \n\tstruct afs_server\t*server;\t \n\tstruct afs_call\t\t*call;\n\tunsigned long\t\tuntried;\t \n\tshort\t\t\tindex;\t\t \n\tunsigned short\t\tnr_iterations;\t \n\n\tunsigned int\t\tflags;\n#define AFS_OPERATION_STOP\t\t0x0001\t \n#define AFS_OPERATION_VBUSY\t\t0x0002\t \n#define AFS_OPERATION_VMOVED\t\t0x0004\t \n#define AFS_OPERATION_VNOVOL\t\t0x0008\t \n#define AFS_OPERATION_CUR_ONLY\t\t0x0010\t \n#define AFS_OPERATION_NO_VSLEEP\t\t0x0020\t \n#define AFS_OPERATION_UNINTR\t\t0x0040\t \n#define AFS_OPERATION_DOWNGRADE\t\t0x0080\t \n#define AFS_OPERATION_LOCK_0\t\t0x0100\t \n#define AFS_OPERATION_LOCK_1\t\t0x0200\t \n#define AFS_OPERATION_TRIED_ALL\t\t0x0400\t \n#define AFS_OPERATION_RETRY_SERVER\t0x0800\t \n#define AFS_OPERATION_DIR_CONFLICT\t0x1000\t \n};\n\n \nstruct afs_vnode_cache_aux {\n\t__be64\t\t\tdata_version;\n} __packed;\n\nstatic inline void afs_set_cache_aux(struct afs_vnode *vnode,\n\t\t\t\t     struct afs_vnode_cache_aux *aux)\n{\n\taux->data_version = cpu_to_be64(vnode->status.data_version);\n}\n\nstatic inline void afs_invalidate_cache(struct afs_vnode *vnode, unsigned int flags)\n{\n\tstruct afs_vnode_cache_aux aux;\n\n\tafs_set_cache_aux(vnode, &aux);\n\tfscache_invalidate(afs_vnode_cache(vnode), &aux,\n\t\t\t   i_size_read(&vnode->netfs.inode), flags);\n}\n\n \n#ifdef CONFIG_64BIT\n#define __AFS_FOLIO_PRIV_MASK\t\t0x7fffffffUL\n#define __AFS_FOLIO_PRIV_SHIFT\t\t32\n#define __AFS_FOLIO_PRIV_MMAPPED\t0x80000000UL\n#else\n#define __AFS_FOLIO_PRIV_MASK\t\t0x7fffUL\n#define __AFS_FOLIO_PRIV_SHIFT\t\t16\n#define __AFS_FOLIO_PRIV_MMAPPED\t0x8000UL\n#endif\n\nstatic inline unsigned int afs_folio_dirty_resolution(struct folio *folio)\n{\n\tint shift = folio_shift(folio) - (__AFS_FOLIO_PRIV_SHIFT - 1);\n\treturn (shift > 0) ? shift : 0;\n}\n\nstatic inline size_t afs_folio_dirty_from(struct folio *folio, unsigned long priv)\n{\n\tunsigned long x = priv & __AFS_FOLIO_PRIV_MASK;\n\n\t \n\treturn x << afs_folio_dirty_resolution(folio);\n}\n\nstatic inline size_t afs_folio_dirty_to(struct folio *folio, unsigned long priv)\n{\n\tunsigned long x = (priv >> __AFS_FOLIO_PRIV_SHIFT) & __AFS_FOLIO_PRIV_MASK;\n\n\t \n\treturn (x + 1) << afs_folio_dirty_resolution(folio);\n}\n\nstatic inline unsigned long afs_folio_dirty(struct folio *folio, size_t from, size_t to)\n{\n\tunsigned int res = afs_folio_dirty_resolution(folio);\n\tfrom >>= res;\n\tto = (to - 1) >> res;\n\treturn (to << __AFS_FOLIO_PRIV_SHIFT) | from;\n}\n\nstatic inline unsigned long afs_folio_dirty_mmapped(unsigned long priv)\n{\n\treturn priv | __AFS_FOLIO_PRIV_MMAPPED;\n}\n\nstatic inline bool afs_is_folio_dirty_mmapped(unsigned long priv)\n{\n\treturn priv & __AFS_FOLIO_PRIV_MMAPPED;\n}\n\n#include <trace/events/afs.h>\n\n \n \nstatic inline struct afs_addr_list *afs_get_addrlist(struct afs_addr_list *alist)\n{\n\tif (alist)\n\t\trefcount_inc(&alist->usage);\n\treturn alist;\n}\nextern struct afs_addr_list *afs_alloc_addrlist(unsigned int,\n\t\t\t\t\t\tunsigned short,\n\t\t\t\t\t\tunsigned short);\nextern void afs_put_addrlist(struct afs_addr_list *);\nextern struct afs_vlserver_list *afs_parse_text_addrs(struct afs_net *,\n\t\t\t\t\t\t      const char *, size_t, char,\n\t\t\t\t\t\t      unsigned short, unsigned short);\nextern struct afs_vlserver_list *afs_dns_query(struct afs_cell *, time64_t *);\nextern bool afs_iterate_addresses(struct afs_addr_cursor *);\nextern int afs_end_cursor(struct afs_addr_cursor *);\n\nextern void afs_merge_fs_addr4(struct afs_addr_list *, __be32, u16);\nextern void afs_merge_fs_addr6(struct afs_addr_list *, __be32 *, u16);\n\n \nextern void afs_invalidate_mmap_work(struct work_struct *);\nextern void afs_server_init_callback_work(struct work_struct *work);\nextern void afs_init_callback_state(struct afs_server *);\nextern void __afs_break_callback(struct afs_vnode *, enum afs_cb_break_reason);\nextern void afs_break_callback(struct afs_vnode *, enum afs_cb_break_reason);\nextern void afs_break_callbacks(struct afs_server *, size_t, struct afs_callback_break *);\n\nstatic inline unsigned int afs_calc_vnode_cb_break(struct afs_vnode *vnode)\n{\n\treturn vnode->cb_break + vnode->cb_v_break;\n}\n\nstatic inline bool afs_cb_is_broken(unsigned int cb_break,\n\t\t\t\t    const struct afs_vnode *vnode)\n{\n\treturn cb_break != (vnode->cb_break + vnode->volume->cb_v_break);\n}\n\n \nextern int afs_cell_init(struct afs_net *, const char *);\nextern struct afs_cell *afs_find_cell(struct afs_net *, const char *, unsigned,\n\t\t\t\t      enum afs_cell_trace);\nextern struct afs_cell *afs_lookup_cell(struct afs_net *, const char *, unsigned,\n\t\t\t\t\tconst char *, bool);\nextern struct afs_cell *afs_use_cell(struct afs_cell *, enum afs_cell_trace);\nextern void afs_unuse_cell(struct afs_net *, struct afs_cell *, enum afs_cell_trace);\nextern struct afs_cell *afs_get_cell(struct afs_cell *, enum afs_cell_trace);\nextern void afs_see_cell(struct afs_cell *, enum afs_cell_trace);\nextern void afs_put_cell(struct afs_cell *, enum afs_cell_trace);\nextern void afs_queue_cell(struct afs_cell *, enum afs_cell_trace);\nextern void afs_manage_cells(struct work_struct *);\nextern void afs_cells_timer(struct timer_list *);\nextern void __net_exit afs_cell_purge(struct afs_net *);\n\n \nextern bool afs_cm_incoming_call(struct afs_call *);\n\n \nextern const struct file_operations afs_dir_file_operations;\nextern const struct inode_operations afs_dir_inode_operations;\nextern const struct address_space_operations afs_dir_aops;\nextern const struct dentry_operations afs_fs_dentry_operations;\n\nextern void afs_d_release(struct dentry *);\nextern void afs_check_for_remote_deletion(struct afs_operation *);\n\n \nextern void afs_edit_dir_add(struct afs_vnode *, struct qstr *, struct afs_fid *,\n\t\t\t     enum afs_edit_dir_reason);\nextern void afs_edit_dir_remove(struct afs_vnode *, struct qstr *, enum afs_edit_dir_reason);\n\n \nextern int afs_sillyrename(struct afs_vnode *, struct afs_vnode *,\n\t\t\t   struct dentry *, struct key *);\nextern int afs_silly_iput(struct dentry *, struct inode *);\n\n \nextern const struct inode_operations afs_dynroot_inode_operations;\nextern const struct dentry_operations afs_dynroot_dentry_operations;\n\nextern struct inode *afs_try_auto_mntpt(struct dentry *, struct inode *);\nextern int afs_dynroot_mkdir(struct afs_net *, struct afs_cell *);\nextern void afs_dynroot_rmdir(struct afs_net *, struct afs_cell *);\nextern int afs_dynroot_populate(struct super_block *);\nextern void afs_dynroot_depopulate(struct super_block *);\n\n \nextern const struct address_space_operations afs_file_aops;\nextern const struct address_space_operations afs_symlink_aops;\nextern const struct inode_operations afs_file_inode_operations;\nextern const struct file_operations afs_file_operations;\nextern const struct netfs_request_ops afs_req_ops;\n\nextern int afs_cache_wb_key(struct afs_vnode *, struct afs_file *);\nextern void afs_put_wb_key(struct afs_wb_key *);\nextern int afs_open(struct inode *, struct file *);\nextern int afs_release(struct inode *, struct file *);\nextern int afs_fetch_data(struct afs_vnode *, struct afs_read *);\nextern struct afs_read *afs_alloc_read(gfp_t);\nextern void afs_put_read(struct afs_read *);\nextern int afs_write_inode(struct inode *, struct writeback_control *);\n\nstatic inline struct afs_read *afs_get_read(struct afs_read *req)\n{\n\trefcount_inc(&req->usage);\n\treturn req;\n}\n\n \nextern struct workqueue_struct *afs_lock_manager;\n\nextern void afs_lock_op_done(struct afs_call *);\nextern void afs_lock_work(struct work_struct *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern int afs_lock(struct file *, int, struct file_lock *);\nextern int afs_flock(struct file *, int, struct file_lock *);\n\n \nextern void afs_fs_fetch_status(struct afs_operation *);\nextern void afs_fs_fetch_data(struct afs_operation *);\nextern void afs_fs_create_file(struct afs_operation *);\nextern void afs_fs_make_dir(struct afs_operation *);\nextern void afs_fs_remove_file(struct afs_operation *);\nextern void afs_fs_remove_dir(struct afs_operation *);\nextern void afs_fs_link(struct afs_operation *);\nextern void afs_fs_symlink(struct afs_operation *);\nextern void afs_fs_rename(struct afs_operation *);\nextern void afs_fs_store_data(struct afs_operation *);\nextern void afs_fs_setattr(struct afs_operation *);\nextern void afs_fs_get_volume_status(struct afs_operation *);\nextern void afs_fs_set_lock(struct afs_operation *);\nextern void afs_fs_extend_lock(struct afs_operation *);\nextern void afs_fs_release_lock(struct afs_operation *);\nextern int afs_fs_give_up_all_callbacks(struct afs_net *, struct afs_server *,\n\t\t\t\t\tstruct afs_addr_cursor *, struct key *);\nextern bool afs_fs_get_capabilities(struct afs_net *, struct afs_server *,\n\t\t\t\t    struct afs_addr_cursor *, struct key *);\nextern void afs_fs_inline_bulk_status(struct afs_operation *);\n\nstruct afs_acl {\n\tu32\tsize;\n\tu8\tdata[];\n};\n\nextern void afs_fs_fetch_acl(struct afs_operation *);\nextern void afs_fs_store_acl(struct afs_operation *);\n\n \nextern struct afs_operation *afs_alloc_operation(struct key *, struct afs_volume *);\nextern int afs_put_operation(struct afs_operation *);\nextern bool afs_begin_vnode_operation(struct afs_operation *);\nextern void afs_wait_for_operation(struct afs_operation *);\nextern int afs_do_sync_operation(struct afs_operation *);\n\nstatic inline void afs_op_nomem(struct afs_operation *op)\n{\n\top->error = -ENOMEM;\n}\n\nstatic inline void afs_op_set_vnode(struct afs_operation *op, unsigned int n,\n\t\t\t\t    struct afs_vnode *vnode)\n{\n\top->file[n].vnode = vnode;\n\top->file[n].need_io_lock = true;\n}\n\nstatic inline void afs_op_set_fid(struct afs_operation *op, unsigned int n,\n\t\t\t\t  const struct afs_fid *fid)\n{\n\top->file[n].fid = *fid;\n}\n\n \nextern void afs_fileserver_probe_result(struct afs_call *);\nextern void afs_fs_probe_fileserver(struct afs_net *, struct afs_server *, struct key *, bool);\nextern int afs_wait_for_fs_probes(struct afs_server_list *, unsigned long);\nextern void afs_probe_fileserver(struct afs_net *, struct afs_server *);\nextern void afs_fs_probe_dispatcher(struct work_struct *);\nextern int afs_wait_for_one_fs_probe(struct afs_server *, bool);\nextern void afs_fs_probe_cleanup(struct afs_net *);\n\n \nextern const struct afs_operation_ops afs_fetch_status_operation;\n\nextern void afs_vnode_commit_status(struct afs_operation *, struct afs_vnode_param *);\nextern int afs_fetch_status(struct afs_vnode *, struct key *, bool, afs_access_t *);\nextern int afs_ilookup5_test_by_fid(struct inode *, void *);\nextern struct inode *afs_iget_pseudo_dir(struct super_block *, bool);\nextern struct inode *afs_iget(struct afs_operation *, struct afs_vnode_param *);\nextern struct inode *afs_root_iget(struct super_block *, struct key *);\nextern bool afs_check_validity(struct afs_vnode *);\nextern int afs_validate(struct afs_vnode *, struct key *);\nbool afs_pagecache_valid(struct afs_vnode *);\nextern int afs_getattr(struct mnt_idmap *idmap, const struct path *,\n\t\t       struct kstat *, u32, unsigned int);\nextern int afs_setattr(struct mnt_idmap *idmap, struct dentry *, struct iattr *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\n\n \nextern struct workqueue_struct *afs_wq;\nextern int afs_net_id;\n\nstatic inline struct afs_net *afs_net(struct net *net)\n{\n\treturn net_generic(net, afs_net_id);\n}\n\nstatic inline struct afs_net *afs_sb2net(struct super_block *sb)\n{\n\treturn afs_net(AFS_FS_S(sb)->net_ns);\n}\n\nstatic inline struct afs_net *afs_d2net(struct dentry *dentry)\n{\n\treturn afs_sb2net(dentry->d_sb);\n}\n\nstatic inline struct afs_net *afs_i2net(struct inode *inode)\n{\n\treturn afs_sb2net(inode->i_sb);\n}\n\nstatic inline struct afs_net *afs_v2net(struct afs_vnode *vnode)\n{\n\treturn afs_i2net(&vnode->netfs.inode);\n}\n\nstatic inline struct afs_net *afs_sock2net(struct sock *sk)\n{\n\treturn net_generic(sock_net(sk), afs_net_id);\n}\n\nstatic inline void __afs_stat(atomic_t *s)\n{\n\tatomic_inc(s);\n}\n\n#define afs_stat_v(vnode, n) __afs_stat(&afs_v2net(vnode)->n)\n\n \nextern int afs_abort_to_error(u32);\nextern void afs_prioritise_error(struct afs_error *, int, u32);\n\n \nextern const struct inode_operations afs_mntpt_inode_operations;\nextern const struct inode_operations afs_autocell_inode_operations;\nextern const struct file_operations afs_mntpt_file_operations;\n\nextern struct vfsmount *afs_d_automount(struct path *);\nextern void afs_mntpt_kill_timer(void);\n\n \n#ifdef CONFIG_PROC_FS\nextern int __net_init afs_proc_init(struct afs_net *);\nextern void __net_exit afs_proc_cleanup(struct afs_net *);\nextern int afs_proc_cell_setup(struct afs_cell *);\nextern void afs_proc_cell_remove(struct afs_cell *);\nextern void afs_put_sysnames(struct afs_sysnames *);\n#else\nstatic inline int afs_proc_init(struct afs_net *net) { return 0; }\nstatic inline void afs_proc_cleanup(struct afs_net *net) {}\nstatic inline int afs_proc_cell_setup(struct afs_cell *cell) { return 0; }\nstatic inline void afs_proc_cell_remove(struct afs_cell *cell) {}\nstatic inline void afs_put_sysnames(struct afs_sysnames *sysnames) {}\n#endif\n\n \nextern bool afs_select_fileserver(struct afs_operation *);\nextern void afs_dump_edestaddrreq(const struct afs_operation *);\n\n \nextern struct workqueue_struct *afs_async_calls;\n\nextern int __net_init afs_open_socket(struct afs_net *);\nextern void __net_exit afs_close_socket(struct afs_net *);\nextern void afs_charge_preallocation(struct work_struct *);\nextern void afs_put_call(struct afs_call *);\nextern void afs_make_call(struct afs_addr_cursor *, struct afs_call *, gfp_t);\nextern long afs_wait_for_call_to_complete(struct afs_call *, struct afs_addr_cursor *);\nextern struct afs_call *afs_alloc_flat_call(struct afs_net *,\n\t\t\t\t\t    const struct afs_call_type *,\n\t\t\t\t\t    size_t, size_t);\nextern void afs_flat_call_destructor(struct afs_call *);\nextern void afs_send_empty_reply(struct afs_call *);\nextern void afs_send_simple_reply(struct afs_call *, const void *, size_t);\nextern int afs_extract_data(struct afs_call *, bool);\nextern int afs_protocol_error(struct afs_call *, enum afs_eproto_cause);\n\nstatic inline void afs_make_op_call(struct afs_operation *op, struct afs_call *call,\n\t\t\t\t    gfp_t gfp)\n{\n\top->call = call;\n\top->type = call->type;\n\tcall->op = op;\n\tcall->key = op->key;\n\tcall->intr = !(op->flags & AFS_OPERATION_UNINTR);\n\tafs_make_call(&op->ac, call, gfp);\n}\n\nstatic inline void afs_extract_begin(struct afs_call *call, void *buf, size_t size)\n{\n\tcall->iov_len = size;\n\tcall->kvec[0].iov_base = buf;\n\tcall->kvec[0].iov_len = size;\n\tiov_iter_kvec(&call->def_iter, ITER_DEST, call->kvec, 1, size);\n}\n\nstatic inline void afs_extract_to_tmp(struct afs_call *call)\n{\n\tcall->iov_len = sizeof(call->tmp);\n\tafs_extract_begin(call, &call->tmp, sizeof(call->tmp));\n}\n\nstatic inline void afs_extract_to_tmp64(struct afs_call *call)\n{\n\tcall->iov_len = sizeof(call->tmp64);\n\tafs_extract_begin(call, &call->tmp64, sizeof(call->tmp64));\n}\n\nstatic inline void afs_extract_discard(struct afs_call *call, size_t size)\n{\n\tcall->iov_len = size;\n\tiov_iter_discard(&call->def_iter, ITER_DEST, size);\n}\n\nstatic inline void afs_extract_to_buf(struct afs_call *call, size_t size)\n{\n\tcall->iov_len = size;\n\tafs_extract_begin(call, call->buffer, size);\n}\n\nstatic inline int afs_transfer_reply(struct afs_call *call)\n{\n\treturn afs_extract_data(call, false);\n}\n\nstatic inline bool afs_check_call_state(struct afs_call *call,\n\t\t\t\t\tenum afs_call_state state)\n{\n\treturn READ_ONCE(call->state) == state;\n}\n\nstatic inline bool afs_set_call_state(struct afs_call *call,\n\t\t\t\t      enum afs_call_state from,\n\t\t\t\t      enum afs_call_state to)\n{\n\tbool ok = false;\n\n\tspin_lock_bh(&call->state_lock);\n\tif (call->state == from) {\n\t\tcall->state = to;\n\t\ttrace_afs_call_state(call, from, to, 0, 0);\n\t\tok = true;\n\t}\n\tspin_unlock_bh(&call->state_lock);\n\treturn ok;\n}\n\nstatic inline void afs_set_call_complete(struct afs_call *call,\n\t\t\t\t\t int error, u32 remote_abort)\n{\n\tenum afs_call_state state;\n\tbool ok = false;\n\n\tspin_lock_bh(&call->state_lock);\n\tstate = call->state;\n\tif (state != AFS_CALL_COMPLETE) {\n\t\tcall->abort_code = remote_abort;\n\t\tcall->error = error;\n\t\tcall->state = AFS_CALL_COMPLETE;\n\t\ttrace_afs_call_state(call, state, AFS_CALL_COMPLETE,\n\t\t\t\t     error, remote_abort);\n\t\tok = true;\n\t}\n\tspin_unlock_bh(&call->state_lock);\n\tif (ok) {\n\t\ttrace_afs_call_done(call);\n\n\t\t \n\t\tif (call->drop_ref)\n\t\t\tafs_put_call(call);\n\t}\n}\n\n \nextern void afs_put_permits(struct afs_permits *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern void afs_cache_permit(struct afs_vnode *, struct key *, unsigned int,\n\t\t\t     struct afs_status_cb *);\nextern struct key *afs_request_key(struct afs_cell *);\nextern struct key *afs_request_key_rcu(struct afs_cell *);\nextern int afs_check_permit(struct afs_vnode *, struct key *, afs_access_t *);\nextern int afs_permission(struct mnt_idmap *, struct inode *, int);\nextern void __exit afs_clean_up_permit_cache(void);\n\n \nextern spinlock_t afs_server_peer_lock;\n\nextern struct afs_server *afs_find_server(struct afs_net *,\n\t\t\t\t\t  const struct sockaddr_rxrpc *);\nextern struct afs_server *afs_find_server_by_uuid(struct afs_net *, const uuid_t *);\nextern struct afs_server *afs_lookup_server(struct afs_cell *, struct key *, const uuid_t *, u32);\nextern struct afs_server *afs_get_server(struct afs_server *, enum afs_server_trace);\nextern struct afs_server *afs_use_server(struct afs_server *, enum afs_server_trace);\nextern void afs_unuse_server(struct afs_net *, struct afs_server *, enum afs_server_trace);\nextern void afs_unuse_server_notime(struct afs_net *, struct afs_server *, enum afs_server_trace);\nextern void afs_put_server(struct afs_net *, struct afs_server *, enum afs_server_trace);\nextern void afs_manage_servers(struct work_struct *);\nextern void afs_servers_timer(struct timer_list *);\nextern void afs_fs_probe_timer(struct timer_list *);\nextern void __net_exit afs_purge_servers(struct afs_net *);\nextern bool afs_check_server_record(struct afs_operation *, struct afs_server *);\n\nstatic inline void afs_inc_servers_outstanding(struct afs_net *net)\n{\n\tatomic_inc(&net->servers_outstanding);\n}\n\nstatic inline void afs_dec_servers_outstanding(struct afs_net *net)\n{\n\tif (atomic_dec_and_test(&net->servers_outstanding))\n\t\twake_up_var(&net->servers_outstanding);\n}\n\nstatic inline bool afs_is_probing_server(struct afs_server *server)\n{\n\treturn list_empty(&server->probe_link);\n}\n\n \nstatic inline struct afs_server_list *afs_get_serverlist(struct afs_server_list *slist)\n{\n\trefcount_inc(&slist->usage);\n\treturn slist;\n}\n\nextern void afs_put_serverlist(struct afs_net *, struct afs_server_list *);\nextern struct afs_server_list *afs_alloc_server_list(struct afs_cell *, struct key *,\n\t\t\t\t\t\t     struct afs_vldb_entry *,\n\t\t\t\t\t\t     u8);\nextern bool afs_annotate_server_list(struct afs_server_list *, struct afs_server_list *);\n\n \nextern int __init afs_fs_init(void);\nextern void afs_fs_exit(void);\n\n \nextern struct afs_vldb_entry *afs_vl_get_entry_by_name_u(struct afs_vl_cursor *,\n\t\t\t\t\t\t\t const char *, int);\nextern struct afs_addr_list *afs_vl_get_addrs_u(struct afs_vl_cursor *, const uuid_t *);\nextern struct afs_call *afs_vl_get_capabilities(struct afs_net *, struct afs_addr_cursor *,\n\t\t\t\t\t\tstruct key *, struct afs_vlserver *, unsigned int);\nextern struct afs_addr_list *afs_yfsvl_get_endpoints(struct afs_vl_cursor *, const uuid_t *);\nextern char *afs_yfsvl_get_cell_name(struct afs_vl_cursor *);\n\n \nextern int afs_cell_detect_alias(struct afs_cell *, struct key *);\n\n \nextern void afs_vlserver_probe_result(struct afs_call *);\nextern int afs_send_vl_probes(struct afs_net *, struct key *, struct afs_vlserver_list *);\nextern int afs_wait_for_vl_probes(struct afs_vlserver_list *, unsigned long);\n\n \nextern bool afs_begin_vlserver_operation(struct afs_vl_cursor *,\n\t\t\t\t\t struct afs_cell *, struct key *);\nextern bool afs_select_vlserver(struct afs_vl_cursor *);\nextern bool afs_select_current_vlserver(struct afs_vl_cursor *);\nextern int afs_end_vlserver_operation(struct afs_vl_cursor *);\n\n \nstatic inline struct afs_vlserver *afs_get_vlserver(struct afs_vlserver *vlserver)\n{\n\trefcount_inc(&vlserver->ref);\n\treturn vlserver;\n}\n\nstatic inline struct afs_vlserver_list *afs_get_vlserverlist(struct afs_vlserver_list *vllist)\n{\n\tif (vllist)\n\t\trefcount_inc(&vllist->ref);\n\treturn vllist;\n}\n\nextern struct afs_vlserver *afs_alloc_vlserver(const char *, size_t, unsigned short);\nextern void afs_put_vlserver(struct afs_net *, struct afs_vlserver *);\nextern struct afs_vlserver_list *afs_alloc_vlserver_list(unsigned int);\nextern void afs_put_vlserverlist(struct afs_net *, struct afs_vlserver_list *);\nextern struct afs_vlserver_list *afs_extract_vlserver_list(struct afs_cell *,\n\t\t\t\t\t\t\t   const void *, size_t);\n\n \nextern struct afs_volume *afs_create_volume(struct afs_fs_context *);\nextern int afs_activate_volume(struct afs_volume *);\nextern void afs_deactivate_volume(struct afs_volume *);\nbool afs_try_get_volume(struct afs_volume *volume, enum afs_volume_trace reason);\nextern struct afs_volume *afs_get_volume(struct afs_volume *, enum afs_volume_trace);\nextern void afs_put_volume(struct afs_net *, struct afs_volume *, enum afs_volume_trace);\nextern int afs_check_volume_status(struct afs_volume *, struct afs_operation *);\n\n \n#ifdef CONFIG_AFS_FSCACHE\nbool afs_dirty_folio(struct address_space *, struct folio *);\n#else\n#define afs_dirty_folio filemap_dirty_folio\n#endif\nextern int afs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len,\n\t\t\tstruct page **pagep, void **fsdata);\nextern int afs_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata);\nextern int afs_writepage(struct page *, struct writeback_control *);\nextern int afs_writepages(struct address_space *, struct writeback_control *);\nextern ssize_t afs_file_write(struct kiocb *, struct iov_iter *);\nextern int afs_fsync(struct file *, loff_t, loff_t, int);\nextern vm_fault_t afs_page_mkwrite(struct vm_fault *vmf);\nextern void afs_prune_wb_keys(struct afs_vnode *);\nint afs_launder_folio(struct folio *);\n\n \nextern const struct xattr_handler *afs_xattr_handlers[];\n\n \nextern void yfs_fs_fetch_data(struct afs_operation *);\nextern void yfs_fs_create_file(struct afs_operation *);\nextern void yfs_fs_make_dir(struct afs_operation *);\nextern void yfs_fs_remove_file2(struct afs_operation *);\nextern void yfs_fs_remove_file(struct afs_operation *);\nextern void yfs_fs_remove_dir(struct afs_operation *);\nextern void yfs_fs_link(struct afs_operation *);\nextern void yfs_fs_symlink(struct afs_operation *);\nextern void yfs_fs_rename(struct afs_operation *);\nextern void yfs_fs_store_data(struct afs_operation *);\nextern void yfs_fs_setattr(struct afs_operation *);\nextern void yfs_fs_get_volume_status(struct afs_operation *);\nextern void yfs_fs_set_lock(struct afs_operation *);\nextern void yfs_fs_extend_lock(struct afs_operation *);\nextern void yfs_fs_release_lock(struct afs_operation *);\nextern void yfs_fs_fetch_status(struct afs_operation *);\nextern void yfs_fs_inline_bulk_status(struct afs_operation *);\n\nstruct yfs_acl {\n\tstruct afs_acl\t*acl;\t\t \n\tstruct afs_acl\t*vol_acl;\t \n\tu32\t\tinherit_flag;\t \n\tu32\t\tnum_cleaned;\t \n\tunsigned int\tflags;\n#define YFS_ACL_WANT_ACL\t0x01\t \n#define YFS_ACL_WANT_VOL_ACL\t0x02\t \n};\n\nextern void yfs_free_opaque_acl(struct yfs_acl *);\nextern void yfs_fs_fetch_opaque_acl(struct afs_operation *);\nextern void yfs_fs_store_opaque_acl2(struct afs_operation *);\n\n \nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, netfs.inode);\n}\n\nstatic inline struct inode *AFS_VNODE_TO_I(struct afs_vnode *vnode)\n{\n\treturn &vnode->netfs.inode;\n}\n\n \nstatic inline void afs_update_dentry_version(struct afs_operation *op,\n\t\t\t\t\t     struct afs_vnode_param *dir_vp,\n\t\t\t\t\t     struct dentry *dentry)\n{\n\tif (!op->error)\n\t\tdentry->d_fsdata =\n\t\t\t(void *)(unsigned long)dir_vp->scb.status.data_version;\n}\n\n \nstatic inline void afs_set_i_size(struct afs_vnode *vnode, u64 size)\n{\n\ti_size_write(&vnode->netfs.inode, size);\n\tvnode->netfs.inode.i_blocks = ((size + 1023) >> 10) << 1;\n}\n\n \nstatic inline void afs_check_dir_conflict(struct afs_operation *op,\n\t\t\t\t\t  struct afs_vnode_param *dvp)\n{\n\tif (dvp->dv_before + dvp->dv_delta != dvp->scb.status.data_version)\n\t\top->flags |= AFS_OPERATION_DIR_CONFLICT;\n}\n\nstatic inline int afs_io_error(struct afs_call *call, enum afs_io_error where)\n{\n\ttrace_afs_io_error(call->debug_id, -EIO, where);\n\treturn -EIO;\n}\n\nstatic inline int afs_bad(struct afs_vnode *vnode, enum afs_file_error where)\n{\n\ttrace_afs_file_error(vnode, -EIO, where);\n\treturn -EIO;\n}\n\n \n \nextern unsigned afs_debug;\n\n#define dbgprintk(FMT,...) \\\n\tprintk(\"[%-6.6s] \"FMT\"\\n\", current->comm ,##__VA_ARGS__)\n\n#define kenter(FMT,...)\tdbgprintk(\"==> %s(\"FMT\")\",__func__ ,##__VA_ARGS__)\n#define kleave(FMT,...)\tdbgprintk(\"<== %s()\"FMT\"\",__func__ ,##__VA_ARGS__)\n#define kdebug(FMT,...)\tdbgprintk(\"    \"FMT ,##__VA_ARGS__)\n\n\n#if defined(__KDEBUG)\n#define _enter(FMT,...)\tkenter(FMT,##__VA_ARGS__)\n#define _leave(FMT,...)\tkleave(FMT,##__VA_ARGS__)\n#define _debug(FMT,...)\tkdebug(FMT,##__VA_ARGS__)\n\n#elif defined(CONFIG_AFS_DEBUG)\n#define AFS_DEBUG_KENTER\t0x01\n#define AFS_DEBUG_KLEAVE\t0x02\n#define AFS_DEBUG_KDEBUG\t0x04\n\n#define _enter(FMT,...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (unlikely(afs_debug & AFS_DEBUG_KENTER))\t\\\n\t\tkenter(FMT,##__VA_ARGS__);\t\t\\\n} while (0)\n\n#define _leave(FMT,...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (unlikely(afs_debug & AFS_DEBUG_KLEAVE))\t\\\n\t\tkleave(FMT,##__VA_ARGS__);\t\t\\\n} while (0)\n\n#define _debug(FMT,...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (unlikely(afs_debug & AFS_DEBUG_KDEBUG))\t\\\n\t\tkdebug(FMT,##__VA_ARGS__);\t\t\\\n} while (0)\n\n#else\n#define _enter(FMT,...)\tno_printk(\"==> %s(\"FMT\")\",__func__ ,##__VA_ARGS__)\n#define _leave(FMT,...)\tno_printk(\"<== %s()\"FMT\"\",__func__ ,##__VA_ARGS__)\n#define _debug(FMT,...)\tno_printk(\"    \"FMT ,##__VA_ARGS__)\n#endif\n\n \n#if 1 \n\n#define ASSERT(X)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (unlikely(!(X))) {\t\t\t\t\t\\\n\t\tprintk(KERN_ERR \"\\n\");\t\t\t\t\\\n\t\tprintk(KERN_ERR \"AFS: Assertion failed\\n\");\t\\\n\t\tBUG();\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n} while(0)\n\n#define ASSERTCMP(X, OP, Y)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely(!((X) OP (Y)))) {\t\t\t\t\t\\\n\t\tprintk(KERN_ERR \"\\n\");\t\t\t\t\t\\\n\t\tprintk(KERN_ERR \"AFS: Assertion failed\\n\");\t\t\\\n\t\tprintk(KERN_ERR \"%lu \" #OP \" %lu is false\\n\",\t\t\\\n\t\t       (unsigned long)(X), (unsigned long)(Y));\t\t\\\n\t\tprintk(KERN_ERR \"0x%lx \" #OP \" 0x%lx is false\\n\",\t\\\n\t\t       (unsigned long)(X), (unsigned long)(Y));\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while(0)\n\n#define ASSERTRANGE(L, OP1, N, OP2, H)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely(!((L) OP1 (N)) || !((N) OP2 (H)))) {\t\t\\\n\t\tprintk(KERN_ERR \"\\n\");\t\t\t\t\t\\\n\t\tprintk(KERN_ERR \"AFS: Assertion failed\\n\");\t\t\\\n\t\tprintk(KERN_ERR \"%lu \"#OP1\" %lu \"#OP2\" %lu is false\\n\",\t\\\n\t\t       (unsigned long)(L), (unsigned long)(N),\t\t\\\n\t\t       (unsigned long)(H));\t\t\t\t\\\n\t\tprintk(KERN_ERR \"0x%lx \"#OP1\" 0x%lx \"#OP2\" 0x%lx is false\\n\", \\\n\t\t       (unsigned long)(L), (unsigned long)(N),\t\t\\\n\t\t       (unsigned long)(H));\t\t\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while(0)\n\n#define ASSERTIF(C, X)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (unlikely((C) && !(X))) {\t\t\t\t\\\n\t\tprintk(KERN_ERR \"\\n\");\t\t\t\t\\\n\t\tprintk(KERN_ERR \"AFS: Assertion failed\\n\");\t\\\n\t\tBUG();\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n} while(0)\n\n#define ASSERTIFCMP(C, X, OP, Y)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely((C) && !((X) OP (Y)))) {\t\t\t\t\\\n\t\tprintk(KERN_ERR \"\\n\");\t\t\t\t\t\\\n\t\tprintk(KERN_ERR \"AFS: Assertion failed\\n\");\t\t\\\n\t\tprintk(KERN_ERR \"%lu \" #OP \" %lu is false\\n\",\t\t\\\n\t\t       (unsigned long)(X), (unsigned long)(Y));\t\t\\\n\t\tprintk(KERN_ERR \"0x%lx \" #OP \" 0x%lx is false\\n\",\t\\\n\t\t       (unsigned long)(X), (unsigned long)(Y));\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while(0)\n\n#else\n\n#define ASSERT(X)\t\t\t\t\\\ndo {\t\t\t\t\t\t\\\n} while(0)\n\n#define ASSERTCMP(X, OP, Y)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n} while(0)\n\n#define ASSERTRANGE(L, OP1, N, OP2, H)\t\t\\\ndo {\t\t\t\t\t\t\\\n} while(0)\n\n#define ASSERTIF(C, X)\t\t\t\t\\\ndo {\t\t\t\t\t\t\\\n} while(0)\n\n#define ASSERTIFCMP(C, X, OP, Y)\t\t\\\ndo {\t\t\t\t\t\t\\\n} while(0)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}