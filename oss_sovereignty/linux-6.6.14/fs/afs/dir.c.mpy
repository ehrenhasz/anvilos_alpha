{
  "module_name": "dir.c",
  "hash_id": "52851285d98ddc8cb554d03df2686fbfbda6dd5b3fc89196c122e4b55f559057",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/dir.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/task_io_accounting_ops.h>\n#include \"internal.h\"\n#include \"afs_fs.h\"\n#include \"xdr_fs.h\"\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_dir_open(struct inode *inode, struct file *file);\nstatic int afs_readdir(struct file *file, struct dir_context *ctx);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_iput(struct dentry *dentry, struct inode *inode);\nstatic bool afs_lookup_one_filldir(struct dir_context *ctx, const char *name, int nlen,\n\t\t\t\t  loff_t fpos, u64 ino, unsigned dtype);\nstatic bool afs_lookup_filldir(struct dir_context *ctx, const char *name, int nlen,\n\t\t\t      loff_t fpos, u64 ino, unsigned dtype);\nstatic int afs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode, bool excl);\nstatic int afs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t     struct dentry *dentry, umode_t mode);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\nstatic int afs_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, const char *content);\nstatic int afs_rename(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\t      struct dentry *old_dentry, struct inode *new_dir,\n\t\t      struct dentry *new_dentry, unsigned int flags);\nstatic bool afs_dir_release_folio(struct folio *folio, gfp_t gfp_flags);\nstatic void afs_dir_invalidate_folio(struct folio *folio, size_t offset,\n\t\t\t\t   size_t length);\n\nstatic bool afs_dir_dirty_folio(struct address_space *mapping,\n\t\tstruct folio *folio)\n{\n\tBUG();  \n}\n\nconst struct file_operations afs_dir_file_operations = {\n\t.open\t\t= afs_dir_open,\n\t.release\t= afs_release,\n\t.iterate_shared\t= afs_readdir,\n\t.lock\t\t= afs_lock,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nconst struct inode_operations afs_dir_inode_operations = {\n\t.create\t\t= afs_create,\n\t.lookup\t\t= afs_lookup,\n\t.link\t\t= afs_link,\n\t.unlink\t\t= afs_unlink,\n\t.symlink\t= afs_symlink,\n\t.mkdir\t\t= afs_mkdir,\n\t.rmdir\t\t= afs_rmdir,\n\t.rename\t\t= afs_rename,\n\t.permission\t= afs_permission,\n\t.getattr\t= afs_getattr,\n\t.setattr\t= afs_setattr,\n};\n\nconst struct address_space_operations afs_dir_aops = {\n\t.dirty_folio\t= afs_dir_dirty_folio,\n\t.release_folio\t= afs_dir_release_folio,\n\t.invalidate_folio = afs_dir_invalidate_folio,\n\t.migrate_folio\t= filemap_migrate_folio,\n};\n\nconst struct dentry_operations afs_fs_dentry_operations = {\n\t.d_revalidate\t= afs_d_revalidate,\n\t.d_delete\t= afs_d_delete,\n\t.d_release\t= afs_d_release,\n\t.d_automount\t= afs_d_automount,\n\t.d_iput\t\t= afs_d_iput,\n};\n\nstruct afs_lookup_one_cookie {\n\tstruct dir_context\tctx;\n\tstruct qstr\t\tname;\n\tbool\t\t\tfound;\n\tstruct afs_fid\t\tfid;\n};\n\nstruct afs_lookup_cookie {\n\tstruct dir_context\tctx;\n\tstruct qstr\t\tname;\n\tbool\t\t\tfound;\n\tbool\t\t\tone_only;\n\tunsigned short\t\tnr_fids;\n\tstruct afs_fid\t\tfids[50];\n};\n\n \nstatic void afs_dir_read_cleanup(struct afs_read *req)\n{\n\tstruct address_space *mapping = req->vnode->netfs.inode.i_mapping;\n\tstruct folio *folio;\n\tpgoff_t last = req->nr_pages - 1;\n\n\tXA_STATE(xas, &mapping->i_pages, 0);\n\n\tif (unlikely(!req->nr_pages))\n\t\treturn;\n\n\trcu_read_lock();\n\txas_for_each(&xas, folio, last) {\n\t\tif (xas_retry(&xas, folio))\n\t\t\tcontinue;\n\t\tBUG_ON(xa_is_value(folio));\n\t\tASSERTCMP(folio_file_mapping(folio), ==, mapping);\n\n\t\tfolio_put(folio);\n\t}\n\n\trcu_read_unlock();\n}\n\n \nstatic bool afs_dir_check_folio(struct afs_vnode *dvnode, struct folio *folio,\n\t\t\t\tloff_t i_size)\n{\n\tunion afs_xdr_dir_block *block;\n\tsize_t offset, size;\n\tloff_t pos;\n\n\t \n\tpos = folio_pos(folio);\n\tif (i_size <= pos)\n\t\tgoto checked;\n\n\tsize = min_t(loff_t, folio_size(folio), i_size - pos);\n\tfor (offset = 0; offset < size; offset += sizeof(*block)) {\n\t\tblock = kmap_local_folio(folio, offset);\n\t\tif (block->hdr.magic != AFS_DIR_MAGIC) {\n\t\t\tprintk(\"kAFS: %s(%lx): [%llx] bad magic %zx/%zx is %04hx\\n\",\n\t\t\t       __func__, dvnode->netfs.inode.i_ino,\n\t\t\t       pos, offset, size, ntohs(block->hdr.magic));\n\t\t\ttrace_afs_dir_check_failed(dvnode, pos + offset, i_size);\n\t\t\tkunmap_local(block);\n\t\t\ttrace_afs_file_error(dvnode, -EIO, afs_file_error_dir_bad_magic);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\t((u8 *)block)[AFS_DIR_BLOCK_SIZE - 1] = 0;\n\n\t\tkunmap_local(block);\n\t}\nchecked:\n\tafs_stat_v(dvnode, n_read_dir);\n\treturn true;\n\nerror:\n\treturn false;\n}\n\n \nstatic void afs_dir_dump(struct afs_vnode *dvnode, struct afs_read *req)\n{\n\tunion afs_xdr_dir_block *block;\n\tstruct address_space *mapping = dvnode->netfs.inode.i_mapping;\n\tstruct folio *folio;\n\tpgoff_t last = req->nr_pages - 1;\n\tsize_t offset, size;\n\n\tXA_STATE(xas, &mapping->i_pages, 0);\n\n\tpr_warn(\"DIR %llx:%llx f=%llx l=%llx al=%llx\\n\",\n\t\tdvnode->fid.vid, dvnode->fid.vnode,\n\t\treq->file_size, req->len, req->actual_len);\n\tpr_warn(\"DIR %llx %x %zx %zx\\n\",\n\t\treq->pos, req->nr_pages,\n\t\treq->iter->iov_offset,  iov_iter_count(req->iter));\n\n\txas_for_each(&xas, folio, last) {\n\t\tif (xas_retry(&xas, folio))\n\t\t\tcontinue;\n\n\t\tBUG_ON(folio_file_mapping(folio) != mapping);\n\n\t\tsize = min_t(loff_t, folio_size(folio), req->actual_len - folio_pos(folio));\n\t\tfor (offset = 0; offset < size; offset += sizeof(*block)) {\n\t\t\tblock = kmap_local_folio(folio, offset);\n\t\t\tpr_warn(\"[%02lx] %32phN\\n\", folio_index(folio) + offset, block);\n\t\t\tkunmap_local(block);\n\t\t}\n\t}\n}\n\n \nstatic int afs_dir_check(struct afs_vnode *dvnode, struct afs_read *req)\n{\n\tstruct address_space *mapping = dvnode->netfs.inode.i_mapping;\n\tstruct folio *folio;\n\tpgoff_t last = req->nr_pages - 1;\n\tint ret = 0;\n\n\tXA_STATE(xas, &mapping->i_pages, 0);\n\n\tif (unlikely(!req->nr_pages))\n\t\treturn 0;\n\n\trcu_read_lock();\n\txas_for_each(&xas, folio, last) {\n\t\tif (xas_retry(&xas, folio))\n\t\t\tcontinue;\n\n\t\tBUG_ON(folio_file_mapping(folio) != mapping);\n\n\t\tif (!afs_dir_check_folio(dvnode, folio, req->actual_len)) {\n\t\t\tafs_dir_dump(dvnode, req);\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nstatic int afs_dir_open(struct inode *inode, struct file *file)\n{\n\t_enter(\"{%lu}\", inode->i_ino);\n\n\tBUILD_BUG_ON(sizeof(union afs_xdr_dir_block) != 2048);\n\tBUILD_BUG_ON(sizeof(union afs_xdr_dirent) != 32);\n\n\tif (test_bit(AFS_VNODE_DELETED, &AFS_FS_I(inode)->flags))\n\t\treturn -ENOENT;\n\n\treturn afs_open(inode, file);\n}\n\n \nstatic struct afs_read *afs_read_dir(struct afs_vnode *dvnode, struct key *key)\n\t__acquires(&dvnode->validate_lock)\n{\n\tstruct address_space *mapping = dvnode->netfs.inode.i_mapping;\n\tstruct afs_read *req;\n\tloff_t i_size;\n\tint nr_pages, i;\n\tint ret;\n\tloff_t remote_size = 0;\n\n\t_enter(\"\");\n\n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trefcount_set(&req->usage, 1);\n\treq->vnode = dvnode;\n\treq->key = key_get(key);\n\treq->cleanup = afs_dir_read_cleanup;\n\nexpand:\n\ti_size = i_size_read(&dvnode->netfs.inode);\n\tif (i_size < remote_size)\n\t    i_size = remote_size;\n\tif (i_size < 2048) {\n\t\tret = afs_bad(dvnode, afs_file_error_dir_small);\n\t\tgoto error;\n\t}\n\tif (i_size > 2048 * 1024) {\n\t\ttrace_afs_file_error(dvnode, -EFBIG, afs_file_error_dir_big);\n\t\tret = -EFBIG;\n\t\tgoto error;\n\t}\n\n\t_enter(\"%llu\", i_size);\n\n\tnr_pages = (i_size + PAGE_SIZE - 1) / PAGE_SIZE;\n\n\treq->actual_len = i_size;  \n\treq->len = nr_pages * PAGE_SIZE;  \n\treq->data_version = dvnode->status.data_version;  \n\tiov_iter_xarray(&req->def_iter, ITER_DEST, &dvnode->netfs.inode.i_mapping->i_pages,\n\t\t\t0, i_size);\n\treq->iter = &req->def_iter;\n\n\t \n\ti = req->nr_pages;\n\twhile (i < nr_pages) {\n\t\tstruct folio *folio;\n\n\t\tfolio = filemap_get_folio(mapping, i);\n\t\tif (IS_ERR(folio)) {\n\t\t\tif (test_and_clear_bit(AFS_VNODE_DIR_VALID, &dvnode->flags))\n\t\t\t\tafs_stat_v(dvnode, n_inval);\n\t\t\tfolio = __filemap_get_folio(mapping,\n\t\t\t\t\t\t    i, FGP_LOCK | FGP_CREAT,\n\t\t\t\t\t\t    mapping->gfp_mask);\n\t\t\tif (IS_ERR(folio)) {\n\t\t\t\tret = PTR_ERR(folio);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tfolio_attach_private(folio, (void *)1);\n\t\t\tfolio_unlock(folio);\n\t\t}\n\n\t\treq->nr_pages += folio_nr_pages(folio);\n\t\ti += folio_nr_pages(folio);\n\t}\n\n\t \n\tret = -ERESTARTSYS;\n\tif (down_read_killable(&dvnode->validate_lock) < 0)\n\t\tgoto error;\n\n\tif (test_bit(AFS_VNODE_DIR_VALID, &dvnode->flags))\n\t\tgoto success;\n\n\tup_read(&dvnode->validate_lock);\n\tif (down_write_killable(&dvnode->validate_lock) < 0)\n\t\tgoto error;\n\n\tif (!test_bit(AFS_VNODE_DIR_VALID, &dvnode->flags)) {\n\t\ttrace_afs_reload_dir(dvnode);\n\t\tret = afs_fetch_data(dvnode, req);\n\t\tif (ret < 0)\n\t\t\tgoto error_unlock;\n\n\t\ttask_io_account_read(PAGE_SIZE * req->nr_pages);\n\n\t\tif (req->len < req->file_size) {\n\t\t\t \n\t\t\tup_write(&dvnode->validate_lock);\n\t\t\tremote_size = req->file_size;\n\t\t\tgoto expand;\n\t\t}\n\n\t\t \n\t\tret = afs_dir_check(dvnode, req);\n\t\tif (ret < 0)\n\t\t\tgoto error_unlock;\n\n\t\t\n\n\t\tset_bit(AFS_VNODE_DIR_VALID, &dvnode->flags);\n\t}\n\n\tdowngrade_write(&dvnode->validate_lock);\nsuccess:\n\treturn req;\n\nerror_unlock:\n\tup_write(&dvnode->validate_lock);\nerror:\n\tafs_put_read(req);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}\n\n \nstatic int afs_dir_iterate_block(struct afs_vnode *dvnode,\n\t\t\t\t struct dir_context *ctx,\n\t\t\t\t union afs_xdr_dir_block *block,\n\t\t\t\t unsigned blkoff)\n{\n\tunion afs_xdr_dirent *dire;\n\tunsigned offset, next, curr, nr_slots;\n\tsize_t nlen;\n\tint tmp;\n\n\t_enter(\"%llx,%x\", ctx->pos, blkoff);\n\n\tcurr = (ctx->pos - blkoff) / sizeof(union afs_xdr_dirent);\n\n\t \n\tfor (offset = (blkoff == 0 ? AFS_DIR_RESV_BLOCKS0 : AFS_DIR_RESV_BLOCKS);\n\t     offset < AFS_DIR_SLOTS_PER_BLOCK;\n\t     offset = next\n\t     ) {\n\t\t \n\t\tif (!(block->hdr.bitmap[offset / 8] &\n\t\t      (1 << (offset % 8)))) {\n\t\t\t_debug(\"ENT[%zu.%u]: unused\",\n\t\t\t       blkoff / sizeof(union afs_xdr_dir_block), offset);\n\t\t\tnext = offset + 1;\n\t\t\tif (offset >= curr)\n\t\t\t\tctx->pos = blkoff +\n\t\t\t\t\tnext * sizeof(union afs_xdr_dirent);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tdire = &block->dirents[offset];\n\t\tnlen = strnlen(dire->u.name,\n\t\t\t       sizeof(*block) -\n\t\t\t       offset * sizeof(union afs_xdr_dirent));\n\t\tif (nlen > AFSNAMEMAX - 1) {\n\t\t\t_debug(\"ENT[%zu]: name too long (len %u/%zu)\",\n\t\t\t       blkoff / sizeof(union afs_xdr_dir_block),\n\t\t\t       offset, nlen);\n\t\t\treturn afs_bad(dvnode, afs_file_error_dir_name_too_long);\n\t\t}\n\n\t\t_debug(\"ENT[%zu.%u]: %s %zu \\\"%s\\\"\",\n\t\t       blkoff / sizeof(union afs_xdr_dir_block), offset,\n\t\t       (offset < curr ? \"skip\" : \"fill\"),\n\t\t       nlen, dire->u.name);\n\n\t\tnr_slots = afs_dir_calc_slots(nlen);\n\t\tnext = offset + nr_slots;\n\t\tif (next > AFS_DIR_SLOTS_PER_BLOCK) {\n\t\t\t_debug(\"ENT[%zu.%u]:\"\n\t\t\t       \" %u extends beyond end dir block\"\n\t\t\t       \" (len %zu)\",\n\t\t\t       blkoff / sizeof(union afs_xdr_dir_block),\n\t\t\t       offset, next, nlen);\n\t\t\treturn afs_bad(dvnode, afs_file_error_dir_over_end);\n\t\t}\n\n\t\t \n\t\tfor (tmp = 1; tmp < nr_slots; tmp++) {\n\t\t\tunsigned int ix = offset + tmp;\n\t\t\tif (!(block->hdr.bitmap[ix / 8] & (1 << (ix % 8)))) {\n\t\t\t\t_debug(\"ENT[%zu.u]:\"\n\t\t\t\t       \" %u unmarked extension (%u/%u)\",\n\t\t\t\t       blkoff / sizeof(union afs_xdr_dir_block),\n\t\t\t\t       offset, tmp, nr_slots);\n\t\t\t\treturn afs_bad(dvnode, afs_file_error_dir_unmarked_ext);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (offset < curr) {\n\t\t\tif (next > curr)\n\t\t\t\tctx->pos = blkoff + next * sizeof(union afs_xdr_dirent);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!dir_emit(ctx, dire->u.name, nlen,\n\t\t\t      ntohl(dire->u.vnode),\n\t\t\t      (ctx->actor == afs_lookup_filldir ||\n\t\t\t       ctx->actor == afs_lookup_one_filldir)?\n\t\t\t      ntohl(dire->u.unique) : DT_UNKNOWN)) {\n\t\t\t_leave(\" = 0 [full]\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tctx->pos = blkoff + next * sizeof(union afs_xdr_dirent);\n\t}\n\n\t_leave(\" = 1 [more]\");\n\treturn 1;\n}\n\n \nstatic int afs_dir_iterate(struct inode *dir, struct dir_context *ctx,\n\t\t\t   struct key *key, afs_dataversion_t *_dir_version)\n{\n\tstruct afs_vnode *dvnode = AFS_FS_I(dir);\n\tunion afs_xdr_dir_block *dblock;\n\tstruct afs_read *req;\n\tstruct folio *folio;\n\tunsigned offset, size;\n\tint ret;\n\n\t_enter(\"{%lu},%u,,\", dir->i_ino, (unsigned)ctx->pos);\n\n\tif (test_bit(AFS_VNODE_DELETED, &AFS_FS_I(dir)->flags)) {\n\t\t_leave(\" = -ESTALE\");\n\t\treturn -ESTALE;\n\t}\n\n\treq = afs_read_dir(dvnode, key);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\t*_dir_version = req->data_version;\n\n\t \n\tctx->pos += sizeof(union afs_xdr_dirent) - 1;\n\tctx->pos &= ~(sizeof(union afs_xdr_dirent) - 1);\n\n\t \n\tret = 0;\n\twhile (ctx->pos < req->actual_len) {\n\t\t \n\t\tfolio = __filemap_get_folio(dir->i_mapping, ctx->pos / PAGE_SIZE,\n\t\t\t\t\t    FGP_ACCESSED, 0);\n\t\tif (IS_ERR(folio)) {\n\t\t\tret = afs_bad(dvnode, afs_file_error_dir_missing_page);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset = round_down(ctx->pos, sizeof(*dblock)) - folio_file_pos(folio);\n\t\tsize = min_t(loff_t, folio_size(folio),\n\t\t\t     req->actual_len - folio_file_pos(folio));\n\n\t\tdo {\n\t\t\tdblock = kmap_local_folio(folio, offset);\n\t\t\tret = afs_dir_iterate_block(dvnode, ctx, dblock,\n\t\t\t\t\t\t    folio_file_pos(folio) + offset);\n\t\t\tkunmap_local(dblock);\n\t\t\tif (ret != 1)\n\t\t\t\tgoto out;\n\n\t\t} while (offset += sizeof(*dblock), offset < size);\n\n\t\tret = 0;\n\t}\n\nout:\n\tup_read(&dvnode->validate_lock);\n\tafs_put_read(req);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nstatic int afs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tafs_dataversion_t dir_version;\n\n\treturn afs_dir_iterate(file_inode(file), ctx, afs_file_key(file),\n\t\t\t       &dir_version);\n}\n\n \nstatic bool afs_lookup_one_filldir(struct dir_context *ctx, const char *name,\n\t\t\t\t  int nlen, loff_t fpos, u64 ino, unsigned dtype)\n{\n\tstruct afs_lookup_one_cookie *cookie =\n\t\tcontainer_of(ctx, struct afs_lookup_one_cookie, ctx);\n\n\t_enter(\"{%s,%u},%s,%u,,%llu,%u\",\n\t       cookie->name.name, cookie->name.len, name, nlen,\n\t       (unsigned long long) ino, dtype);\n\n\t \n\tBUILD_BUG_ON(sizeof(union afs_xdr_dir_block) != 2048);\n\tBUILD_BUG_ON(sizeof(union afs_xdr_dirent) != 32);\n\n\tif (cookie->name.len != nlen ||\n\t    memcmp(cookie->name.name, name, nlen) != 0) {\n\t\t_leave(\" = true [keep looking]\");\n\t\treturn true;\n\t}\n\n\tcookie->fid.vnode = ino;\n\tcookie->fid.unique = dtype;\n\tcookie->found = 1;\n\n\t_leave(\" = false [found]\");\n\treturn false;\n}\n\n \nstatic int afs_do_lookup_one(struct inode *dir, struct dentry *dentry,\n\t\t\t     struct afs_fid *fid, struct key *key,\n\t\t\t     afs_dataversion_t *_dir_version)\n{\n\tstruct afs_super_info *as = dir->i_sb->s_fs_info;\n\tstruct afs_lookup_one_cookie cookie = {\n\t\t.ctx.actor = afs_lookup_one_filldir,\n\t\t.name = dentry->d_name,\n\t\t.fid.vid = as->volume->vid\n\t};\n\tint ret;\n\n\t_enter(\"{%lu},%p{%pd},\", dir->i_ino, dentry, dentry);\n\n\t \n\tret = afs_dir_iterate(dir, &cookie.ctx, key, _dir_version);\n\tif (ret < 0) {\n\t\t_leave(\" = %d [iter]\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!cookie.found) {\n\t\t_leave(\" = -ENOENT [not found]\");\n\t\treturn -ENOENT;\n\t}\n\n\t*fid = cookie.fid;\n\t_leave(\" = 0 { vn=%llu u=%u }\", fid->vnode, fid->unique);\n\treturn 0;\n}\n\n \nstatic bool afs_lookup_filldir(struct dir_context *ctx, const char *name,\n\t\t\t      int nlen, loff_t fpos, u64 ino, unsigned dtype)\n{\n\tstruct afs_lookup_cookie *cookie =\n\t\tcontainer_of(ctx, struct afs_lookup_cookie, ctx);\n\n\t_enter(\"{%s,%u},%s,%u,,%llu,%u\",\n\t       cookie->name.name, cookie->name.len, name, nlen,\n\t       (unsigned long long) ino, dtype);\n\n\t \n\tBUILD_BUG_ON(sizeof(union afs_xdr_dir_block) != 2048);\n\tBUILD_BUG_ON(sizeof(union afs_xdr_dirent) != 32);\n\n\tif (cookie->found) {\n\t\tif (cookie->nr_fids < 50) {\n\t\t\tcookie->fids[cookie->nr_fids].vnode\t= ino;\n\t\t\tcookie->fids[cookie->nr_fids].unique\t= dtype;\n\t\t\tcookie->nr_fids++;\n\t\t}\n\t} else if (cookie->name.len == nlen &&\n\t\t   memcmp(cookie->name.name, name, nlen) == 0) {\n\t\tcookie->fids[1].vnode\t= ino;\n\t\tcookie->fids[1].unique\t= dtype;\n\t\tcookie->found = 1;\n\t\tif (cookie->one_only)\n\t\t\treturn false;\n\t}\n\n\treturn cookie->nr_fids < 50;\n}\n\n \nstatic void afs_do_lookup_success(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp;\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\tu32 abort_code;\n\tint i;\n\n\t_enter(\"\");\n\n\tfor (i = 0; i < op->nr_files; i++) {\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tvp = &op->file[0];\n\t\t\tabort_code = vp->scb.status.abort_code;\n\t\t\tif (abort_code != 0) {\n\t\t\t\top->ac.abort_code = abort_code;\n\t\t\t\top->error = afs_abort_to_error(abort_code);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tvp = &op->file[1];\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tvp = &op->more_files[i - 2];\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!vp->scb.have_status && !vp->scb.have_error)\n\t\t\tcontinue;\n\n\t\t_debug(\"do [%u]\", i);\n\t\tif (vp->vnode) {\n\t\t\tif (!test_bit(AFS_VNODE_UNSET, &vp->vnode->flags))\n\t\t\t\tafs_vnode_commit_status(op, vp);\n\t\t} else if (vp->scb.status.abort_code == 0) {\n\t\t\tinode = afs_iget(op, vp);\n\t\t\tif (!IS_ERR(inode)) {\n\t\t\t\tvnode = AFS_FS_I(inode);\n\t\t\t\tafs_cache_permit(vnode, op->key,\n\t\t\t\t\t\t 0   +\n\t\t\t\t\t\t op->cb_v_break,\n\t\t\t\t\t\t &vp->scb);\n\t\t\t\tvp->vnode = vnode;\n\t\t\t\tvp->put_vnode = true;\n\t\t\t}\n\t\t} else {\n\t\t\t_debug(\"- abort %d %llx:%llx.%x\",\n\t\t\t       vp->scb.status.abort_code,\n\t\t\t       vp->fid.vid, vp->fid.vnode, vp->fid.unique);\n\t\t}\n\t}\n\n\t_leave(\"\");\n}\n\nstatic const struct afs_operation_ops afs_inline_bulk_status_operation = {\n\t.issue_afs_rpc\t= afs_fs_inline_bulk_status,\n\t.issue_yfs_rpc\t= yfs_fs_inline_bulk_status,\n\t.success\t= afs_do_lookup_success,\n};\n\nstatic const struct afs_operation_ops afs_lookup_fetch_status_operation = {\n\t.issue_afs_rpc\t= afs_fs_fetch_status,\n\t.issue_yfs_rpc\t= yfs_fs_fetch_status,\n\t.success\t= afs_do_lookup_success,\n\t.aborted\t= afs_check_for_remote_deletion,\n};\n\n \nstatic bool afs_server_supports_ibulk(struct afs_vnode *dvnode)\n{\n\tstruct afs_server_list *slist;\n\tstruct afs_volume *volume = dvnode->volume;\n\tstruct afs_server *server;\n\tbool ret = true;\n\tint i;\n\n\tif (!test_bit(AFS_VOLUME_MAYBE_NO_IBULK, &volume->flags))\n\t\treturn true;\n\n\trcu_read_lock();\n\tslist = rcu_dereference(volume->servers);\n\n\tfor (i = 0; i < slist->nr_servers; i++) {\n\t\tserver = slist->servers[i].server;\n\t\tif (server == dvnode->cb_server) {\n\t\t\tif (test_bit(AFS_SERVER_FL_NO_IBULK, &server->flags))\n\t\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nstatic struct inode *afs_do_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t   struct key *key)\n{\n\tstruct afs_lookup_cookie *cookie;\n\tstruct afs_vnode_param *vp;\n\tstruct afs_operation *op;\n\tstruct afs_vnode *dvnode = AFS_FS_I(dir), *vnode;\n\tstruct inode *inode = NULL, *ti;\n\tafs_dataversion_t data_version = READ_ONCE(dvnode->status.data_version);\n\tlong ret;\n\tint i;\n\n\t_enter(\"{%lu},%p{%pd},\", dir->i_ino, dentry, dentry);\n\n\tcookie = kzalloc(sizeof(struct afs_lookup_cookie), GFP_KERNEL);\n\tif (!cookie)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < ARRAY_SIZE(cookie->fids); i++)\n\t\tcookie->fids[i].vid = dvnode->fid.vid;\n\tcookie->ctx.actor = afs_lookup_filldir;\n\tcookie->name = dentry->d_name;\n\tcookie->nr_fids = 2;  \n\n\tif (!afs_server_supports_ibulk(dvnode))\n\t\tcookie->one_only = true;\n\n\t \n\tret = afs_dir_iterate(dir, &cookie->ctx, key, &data_version);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdentry->d_fsdata = (void *)(unsigned long)data_version;\n\n\tret = -ENOENT;\n\tif (!cookie->found)\n\t\tgoto out;\n\n\t \n\tinode = ilookup5(dir->i_sb, cookie->fids[1].vnode,\n\t\t\t afs_ilookup5_test_by_fid, &cookie->fids[1]);\n\tif (inode)\n\t\tgoto out;  \n\n\t \n\top = afs_alloc_operation(NULL, dvnode->volume);\n\tif (IS_ERR(op)) {\n\t\tret = PTR_ERR(op);\n\t\tgoto out;\n\t}\n\n\tafs_op_set_vnode(op, 0, dvnode);\n\tafs_op_set_fid(op, 1, &cookie->fids[1]);\n\n\top->nr_files = cookie->nr_fids;\n\t_debug(\"nr_files %u\", op->nr_files);\n\n\t \n\top->error = -ENOMEM;\n\tif (op->nr_files > 2) {\n\t\top->more_files = kvcalloc(op->nr_files - 2,\n\t\t\t\t\t  sizeof(struct afs_vnode_param),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!op->more_files)\n\t\t\tgoto out_op;\n\n\t\tfor (i = 2; i < op->nr_files; i++) {\n\t\t\tvp = &op->more_files[i - 2];\n\t\t\tvp->fid = cookie->fids[i];\n\n\t\t\t \n\t\t\tti = ilookup5_nowait(dir->i_sb, vp->fid.vnode,\n\t\t\t\t\t     afs_ilookup5_test_by_fid, &vp->fid);\n\t\t\tif (!IS_ERR_OR_NULL(ti)) {\n\t\t\t\tvnode = AFS_FS_I(ti);\n\t\t\t\tvp->dv_before = vnode->status.data_version;\n\t\t\t\tvp->cb_break_before = afs_calc_vnode_cb_break(vnode);\n\t\t\t\tvp->vnode = vnode;\n\t\t\t\tvp->put_vnode = true;\n\t\t\t\tvp->speculative = true;  \n\t\t\t}\n\t\t}\n\t}\n\n\t \n\top->error = -ENOTSUPP;\n\tif (!cookie->one_only) {\n\t\top->ops = &afs_inline_bulk_status_operation;\n\t\tafs_begin_vnode_operation(op);\n\t\tafs_wait_for_operation(op);\n\t}\n\n\tif (op->error == -ENOTSUPP) {\n\t\t \n\t\top->fetch_status.which = 1;\n\t\top->ops = &afs_lookup_fetch_status_operation;\n\t\tafs_begin_vnode_operation(op);\n\t\tafs_wait_for_operation(op);\n\t}\n\tinode = ERR_PTR(op->error);\n\nout_op:\n\tif (op->error == 0) {\n\t\tinode = &op->file[1].vnode->netfs.inode;\n\t\top->file[1].vnode = NULL;\n\t}\n\n\tif (op->file[0].scb.have_status)\n\t\tdentry->d_fsdata = (void *)(unsigned long)op->file[0].scb.status.data_version;\n\telse\n\t\tdentry->d_fsdata = (void *)(unsigned long)op->file[0].dv_before;\n\tret = afs_put_operation(op);\nout:\n\tkfree(cookie);\n\t_leave(\"\");\n\treturn inode ?: ERR_PTR(ret);\n}\n\n \nstatic struct dentry *afs_lookup_atsys(struct inode *dir, struct dentry *dentry,\n\t\t\t\t       struct key *key)\n{\n\tstruct afs_sysnames *subs;\n\tstruct afs_net *net = afs_i2net(dir);\n\tstruct dentry *ret;\n\tchar *buf, *p, *name;\n\tint len, i;\n\n\t_enter(\"\");\n\n\tret = ERR_PTR(-ENOMEM);\n\tp = buf = kmalloc(AFSNAMEMAX, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto out_p;\n\tif (dentry->d_name.len > 4) {\n\t\tmemcpy(p, dentry->d_name.name, dentry->d_name.len - 4);\n\t\tp += dentry->d_name.len - 4;\n\t}\n\n\t \n\tread_lock(&net->sysnames_lock);\n\tsubs = net->sysnames;\n\trefcount_inc(&subs->usage);\n\tread_unlock(&net->sysnames_lock);\n\n\tfor (i = 0; i < subs->nr; i++) {\n\t\tname = subs->subs[i];\n\t\tlen = dentry->d_name.len - 4 + strlen(name);\n\t\tif (len >= AFSNAMEMAX) {\n\t\t\tret = ERR_PTR(-ENAMETOOLONG);\n\t\t\tgoto out_s;\n\t\t}\n\n\t\tstrcpy(p, name);\n\t\tret = lookup_one_len(buf, dentry->d_parent, len);\n\t\tif (IS_ERR(ret) || d_is_positive(ret))\n\t\t\tgoto out_s;\n\t\tdput(ret);\n\t}\n\n\t \n\tret = NULL;\nout_s:\n\tafs_put_sysnames(subs);\n\tkfree(buf);\nout_p:\n\tkey_put(key);\n\treturn ret;\n}\n\n \nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags)\n{\n\tstruct afs_vnode *dvnode = AFS_FS_I(dir);\n\tstruct afs_fid fid = {};\n\tstruct inode *inode;\n\tstruct dentry *d;\n\tstruct key *key;\n\tint ret;\n\n\t_enter(\"{%llx:%llu},%p{%pd},\",\n\t       dvnode->fid.vid, dvnode->fid.vnode, dentry, dentry);\n\n\tASSERTCMP(d_inode(dentry), ==, NULL);\n\n\tif (dentry->d_name.len >= AFSNAMEMAX) {\n\t\t_leave(\" = -ENAMETOOLONG\");\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &dvnode->flags)) {\n\t\t_leave(\" = -ESTALE\");\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\tkey = afs_request_key(dvnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\t_leave(\" = %ld [key]\", PTR_ERR(key));\n\t\treturn ERR_CAST(key);\n\t}\n\n\tret = afs_validate(dvnode, key);\n\tif (ret < 0) {\n\t\tkey_put(key);\n\t\t_leave(\" = %d [val]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (dentry->d_name.len >= 4 &&\n\t    dentry->d_name.name[dentry->d_name.len - 4] == '@' &&\n\t    dentry->d_name.name[dentry->d_name.len - 3] == 's' &&\n\t    dentry->d_name.name[dentry->d_name.len - 2] == 'y' &&\n\t    dentry->d_name.name[dentry->d_name.len - 1] == 's')\n\t\treturn afs_lookup_atsys(dir, dentry, key);\n\n\tafs_stat_v(dvnode, n_lookup);\n\tinode = afs_do_lookup(dir, dentry, key);\n\tkey_put(key);\n\tif (inode == ERR_PTR(-ENOENT))\n\t\tinode = afs_try_auto_mntpt(dentry, dir);\n\n\tif (!IS_ERR_OR_NULL(inode))\n\t\tfid = AFS_FS_I(inode)->fid;\n\n\t_debug(\"splice %p\", dentry->d_inode);\n\td = d_splice_alias(inode, dentry);\n\tif (!IS_ERR_OR_NULL(d)) {\n\t\td->d_fsdata = dentry->d_fsdata;\n\t\ttrace_afs_lookup(dvnode, &d->d_name, &fid);\n\t} else {\n\t\ttrace_afs_lookup(dvnode, &dentry->d_name, &fid);\n\t}\n\t_leave(\"\");\n\treturn d;\n}\n\n \nstatic int afs_d_revalidate_rcu(struct dentry *dentry)\n{\n\tstruct afs_vnode *dvnode;\n\tstruct dentry *parent;\n\tstruct inode *dir;\n\tlong dir_version, de_version;\n\n\t_enter(\"%p\", dentry);\n\n\t \n\tparent = READ_ONCE(dentry->d_parent);\n\tdir = d_inode_rcu(parent);\n\tif (!dir)\n\t\treturn -ECHILD;\n\tdvnode = AFS_FS_I(dir);\n\tif (test_bit(AFS_VNODE_DELETED, &dvnode->flags))\n\t\treturn -ECHILD;\n\n\tif (!afs_check_validity(dvnode))\n\t\treturn -ECHILD;\n\n\t \n\tdir_version = (long)READ_ONCE(dvnode->status.data_version);\n\tde_version = (long)READ_ONCE(dentry->d_fsdata);\n\tif (de_version != dir_version) {\n\t\tdir_version = (long)READ_ONCE(dvnode->invalid_before);\n\t\tif (de_version - dir_version < 0)\n\t\t\treturn -ECHILD;\n\t}\n\n\treturn 1;  \n}\n\n \nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct afs_vnode *vnode, *dir;\n\tstruct afs_fid fid;\n\tstruct dentry *parent;\n\tstruct inode *inode;\n\tstruct key *key;\n\tafs_dataversion_t dir_version, invalid_before;\n\tlong de_version;\n\tint ret;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn afs_d_revalidate_rcu(dentry);\n\n\tif (d_really_is_positive(dentry)) {\n\t\tvnode = AFS_FS_I(d_inode(dentry));\n\t\t_enter(\"{v={%llx:%llu} n=%pd fl=%lx},\",\n\t\t       vnode->fid.vid, vnode->fid.vnode, dentry,\n\t\t       vnode->flags);\n\t} else {\n\t\t_enter(\"{neg n=%pd}\", dentry);\n\t}\n\n\tkey = afs_request_key(AFS_FS_S(dentry->d_sb)->volume->cell);\n\tif (IS_ERR(key))\n\t\tkey = NULL;\n\n\t \n\tparent = dget_parent(dentry);\n\tdir = AFS_FS_I(d_inode(parent));\n\n\t \n\tafs_validate(dir, key);\n\n\tif (test_bit(AFS_VNODE_DELETED, &dir->flags)) {\n\t\t_debug(\"%pd: parent dir deleted\", dentry);\n\t\tgoto not_found;\n\t}\n\n\t \n\tdir_version = dir->status.data_version;\n\tde_version = (long)dentry->d_fsdata;\n\tif (de_version == (long)dir_version)\n\t\tgoto out_valid_noupdate;\n\n\tinvalid_before = dir->invalid_before;\n\tif (de_version - (long)invalid_before >= 0)\n\t\tgoto out_valid;\n\n\t_debug(\"dir modified\");\n\tafs_stat_v(dir, n_reval);\n\n\t \n\tret = afs_do_lookup_one(&dir->netfs.inode, dentry, &fid, key, &dir_version);\n\tswitch (ret) {\n\tcase 0:\n\t\t \n\t\tif (d_really_is_negative(dentry))\n\t\t\tgoto not_found;\n\t\tinode = d_inode(dentry);\n\t\tif (is_bad_inode(inode)) {\n\t\t\tprintk(\"kAFS: afs_d_revalidate: %pd2 has bad inode\\n\",\n\t\t\t       dentry);\n\t\t\tgoto not_found;\n\t\t}\n\n\t\tvnode = AFS_FS_I(inode);\n\n\t\t \n\t\tif (fid.vnode != vnode->fid.vnode) {\n\t\t\t_debug(\"%pd: dirent changed [%llu != %llu]\",\n\t\t\t       dentry, fid.vnode,\n\t\t\t       vnode->fid.vnode);\n\t\t\tgoto not_found;\n\t\t}\n\n\t\t \n\t\tif (fid.unique != vnode->fid.unique) {\n\t\t\t_debug(\"%pd: file deleted (uq %u -> %u I:%u)\",\n\t\t\t       dentry, fid.unique,\n\t\t\t       vnode->fid.unique,\n\t\t\t       vnode->netfs.inode.i_generation);\n\t\t\tgoto not_found;\n\t\t}\n\t\tgoto out_valid;\n\n\tcase -ENOENT:\n\t\t \n\t\t_debug(\"%pd: dirent not found\", dentry);\n\t\tif (d_really_is_positive(dentry))\n\t\t\tgoto not_found;\n\t\tgoto out_valid;\n\n\tdefault:\n\t\t_debug(\"failed to iterate dir %pd: %d\",\n\t\t       parent, ret);\n\t\tgoto not_found;\n\t}\n\nout_valid:\n\tdentry->d_fsdata = (void *)(unsigned long)dir_version;\nout_valid_noupdate:\n\tdput(parent);\n\tkey_put(key);\n\t_leave(\" = 1 [valid]\");\n\treturn 1;\n\nnot_found:\n\t_debug(\"dropping dentry %pd2\", dentry);\n\tdput(parent);\n\tkey_put(key);\n\n\t_leave(\" = 0 [bad]\");\n\treturn 0;\n}\n\n \nstatic int afs_d_delete(const struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto zap;\n\n\tif (d_really_is_positive(dentry) &&\n\t    (test_bit(AFS_VNODE_DELETED,   &AFS_FS_I(d_inode(dentry))->flags) ||\n\t     test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(d_inode(dentry))->flags)))\n\t\tgoto zap;\n\n\t_leave(\" = 0 [keep]\");\n\treturn 0;\n\nzap:\n\t_leave(\" = 1 [zap]\");\n\treturn 1;\n}\n\n \nstatic void afs_d_iput(struct dentry *dentry, struct inode *inode)\n{\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tafs_silly_iput(dentry, inode);\n\tiput(inode);\n}\n\n \nvoid afs_d_release(struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n}\n\nvoid afs_check_for_remote_deletion(struct afs_operation *op)\n{\n\tstruct afs_vnode *vnode = op->file[0].vnode;\n\n\tswitch (op->ac.abort_code) {\n\tcase VNOVNODE:\n\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\tafs_break_callback(vnode, afs_cb_break_for_deleted);\n\t}\n}\n\n \nstatic void afs_vnode_new_inode(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[1];\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\n\t_enter(\"\");\n\n\tASSERTCMP(op->error, ==, 0);\n\n\tinode = afs_iget(op, vp);\n\tif (IS_ERR(inode)) {\n\t\t \n\t\top->error = PTR_ERR(inode);\n\t\treturn;\n\t}\n\n\tvnode = AFS_FS_I(inode);\n\tset_bit(AFS_VNODE_NEW_CONTENT, &vnode->flags);\n\tif (!op->error)\n\t\tafs_cache_permit(vnode, op->key, vnode->cb_break, &vp->scb);\n\td_instantiate(op->dentry, inode);\n}\n\nstatic void afs_create_success(struct afs_operation *op)\n{\n\t_enter(\"op=%08x\", op->debug_id);\n\top->ctime = op->file[0].scb.status.mtime_client;\n\tafs_vnode_commit_status(op, &op->file[0]);\n\tafs_update_dentry_version(op, &op->file[0], op->dentry);\n\tafs_vnode_new_inode(op);\n}\n\nstatic void afs_create_edit_dir(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_vnode_param *vp = &op->file[1];\n\tstruct afs_vnode *dvnode = dvp->vnode;\n\n\t_enter(\"op=%08x\", op->debug_id);\n\n\tdown_write(&dvnode->validate_lock);\n\tif (test_bit(AFS_VNODE_DIR_VALID, &dvnode->flags) &&\n\t    dvnode->status.data_version == dvp->dv_before + dvp->dv_delta)\n\t\tafs_edit_dir_add(dvnode, &op->dentry->d_name, &vp->fid,\n\t\t\t\t op->create.reason);\n\tup_write(&dvnode->validate_lock);\n}\n\nstatic void afs_create_put(struct afs_operation *op)\n{\n\t_enter(\"op=%08x\", op->debug_id);\n\n\tif (op->error)\n\t\td_drop(op->dentry);\n}\n\nstatic const struct afs_operation_ops afs_mkdir_operation = {\n\t.issue_afs_rpc\t= afs_fs_make_dir,\n\t.issue_yfs_rpc\t= yfs_fs_make_dir,\n\t.success\t= afs_create_success,\n\t.aborted\t= afs_check_for_remote_deletion,\n\t.edit_dir\t= afs_create_edit_dir,\n\t.put\t\t= afs_create_put,\n};\n\n \nstatic int afs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t     struct dentry *dentry, umode_t mode)\n{\n\tstruct afs_operation *op;\n\tstruct afs_vnode *dvnode = AFS_FS_I(dir);\n\n\t_enter(\"{%llx:%llu},{%pd},%ho\",\n\t       dvnode->fid.vid, dvnode->fid.vnode, dentry, mode);\n\n\top = afs_alloc_operation(NULL, dvnode->volume);\n\tif (IS_ERR(op)) {\n\t\td_drop(dentry);\n\t\treturn PTR_ERR(op);\n\t}\n\n\tafs_op_set_vnode(op, 0, dvnode);\n\top->file[0].dv_delta = 1;\n\top->file[0].modification = true;\n\top->file[0].update_ctime = true;\n\top->dentry\t= dentry;\n\top->create.mode\t= S_IFDIR | mode;\n\top->create.reason = afs_edit_dir_for_mkdir;\n\top->mtime\t= current_time(dir);\n\top->ops\t\t= &afs_mkdir_operation;\n\treturn afs_do_sync_operation(op);\n}\n\n \nstatic void afs_dir_remove_subdir(struct dentry *dentry)\n{\n\tif (d_really_is_positive(dentry)) {\n\t\tstruct afs_vnode *vnode = AFS_FS_I(d_inode(dentry));\n\n\t\tclear_nlink(&vnode->netfs.inode);\n\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\tclear_bit(AFS_VNODE_CB_PROMISED, &vnode->flags);\n\t\tclear_bit(AFS_VNODE_DIR_VALID, &vnode->flags);\n\t}\n}\n\nstatic void afs_rmdir_success(struct afs_operation *op)\n{\n\t_enter(\"op=%08x\", op->debug_id);\n\top->ctime = op->file[0].scb.status.mtime_client;\n\tafs_vnode_commit_status(op, &op->file[0]);\n\tafs_update_dentry_version(op, &op->file[0], op->dentry);\n}\n\nstatic void afs_rmdir_edit_dir(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_vnode *dvnode = dvp->vnode;\n\n\t_enter(\"op=%08x\", op->debug_id);\n\tafs_dir_remove_subdir(op->dentry);\n\n\tdown_write(&dvnode->validate_lock);\n\tif (test_bit(AFS_VNODE_DIR_VALID, &dvnode->flags) &&\n\t    dvnode->status.data_version == dvp->dv_before + dvp->dv_delta)\n\t\tafs_edit_dir_remove(dvnode, &op->dentry->d_name,\n\t\t\t\t    afs_edit_dir_for_rmdir);\n\tup_write(&dvnode->validate_lock);\n}\n\nstatic void afs_rmdir_put(struct afs_operation *op)\n{\n\t_enter(\"op=%08x\", op->debug_id);\n\tif (op->file[1].vnode)\n\t\tup_write(&op->file[1].vnode->rmdir_lock);\n}\n\nstatic const struct afs_operation_ops afs_rmdir_operation = {\n\t.issue_afs_rpc\t= afs_fs_remove_dir,\n\t.issue_yfs_rpc\t= yfs_fs_remove_dir,\n\t.success\t= afs_rmdir_success,\n\t.aborted\t= afs_check_for_remote_deletion,\n\t.edit_dir\t= afs_rmdir_edit_dir,\n\t.put\t\t= afs_rmdir_put,\n};\n\n \nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct afs_operation *op;\n\tstruct afs_vnode *dvnode = AFS_FS_I(dir), *vnode = NULL;\n\tint ret;\n\n\t_enter(\"{%llx:%llu},{%pd}\",\n\t       dvnode->fid.vid, dvnode->fid.vnode, dentry);\n\n\top = afs_alloc_operation(NULL, dvnode->volume);\n\tif (IS_ERR(op))\n\t\treturn PTR_ERR(op);\n\n\tafs_op_set_vnode(op, 0, dvnode);\n\top->file[0].dv_delta = 1;\n\top->file[0].modification = true;\n\top->file[0].update_ctime = true;\n\n\top->dentry\t= dentry;\n\top->ops\t\t= &afs_rmdir_operation;\n\n\t \n\tif (d_really_is_positive(dentry)) {\n\t\tvnode = AFS_FS_I(d_inode(dentry));\n\t\tret = afs_validate(vnode, op->key);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (vnode) {\n\t\tret = down_write_killable(&vnode->rmdir_lock);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\top->file[1].vnode = vnode;\n\t}\n\n\treturn afs_do_sync_operation(op);\n\nerror:\n\treturn afs_put_operation(op);\n}\n\n \nstatic void afs_dir_remove_link(struct afs_operation *op)\n{\n\tstruct afs_vnode *dvnode = op->file[0].vnode;\n\tstruct afs_vnode *vnode = op->file[1].vnode;\n\tstruct dentry *dentry = op->dentry;\n\tint ret;\n\n\tif (op->error != 0 ||\n\t    (op->file[1].scb.have_status && op->file[1].scb.have_error))\n\t\treturn;\n\tif (d_really_is_positive(dentry))\n\t\treturn;\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t \n\t} else if (test_bit(AFS_VNODE_DIR_VALID, &dvnode->flags)) {\n\t\twrite_seqlock(&vnode->cb_lock);\n\t\tdrop_nlink(&vnode->netfs.inode);\n\t\tif (vnode->netfs.inode.i_nlink == 0) {\n\t\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\t\t__afs_break_callback(vnode, afs_cb_break_for_unlink);\n\t\t}\n\t\twrite_sequnlock(&vnode->cb_lock);\n\t} else {\n\t\tafs_break_callback(vnode, afs_cb_break_for_unlink);\n\n\t\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\t\t_debug(\"AFS_VNODE_DELETED\");\n\n\t\tret = afs_validate(vnode, op->key);\n\t\tif (ret != -ESTALE)\n\t\t\top->error = ret;\n\t}\n\n\t_debug(\"nlink %d [val %d]\", vnode->netfs.inode.i_nlink, op->error);\n}\n\nstatic void afs_unlink_success(struct afs_operation *op)\n{\n\t_enter(\"op=%08x\", op->debug_id);\n\top->ctime = op->file[0].scb.status.mtime_client;\n\tafs_check_dir_conflict(op, &op->file[0]);\n\tafs_vnode_commit_status(op, &op->file[0]);\n\tafs_vnode_commit_status(op, &op->file[1]);\n\tafs_update_dentry_version(op, &op->file[0], op->dentry);\n\tafs_dir_remove_link(op);\n}\n\nstatic void afs_unlink_edit_dir(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_vnode *dvnode = dvp->vnode;\n\n\t_enter(\"op=%08x\", op->debug_id);\n\tdown_write(&dvnode->validate_lock);\n\tif (test_bit(AFS_VNODE_DIR_VALID, &dvnode->flags) &&\n\t    dvnode->status.data_version == dvp->dv_before + dvp->dv_delta)\n\t\tafs_edit_dir_remove(dvnode, &op->dentry->d_name,\n\t\t\t\t    afs_edit_dir_for_unlink);\n\tup_write(&dvnode->validate_lock);\n}\n\nstatic void afs_unlink_put(struct afs_operation *op)\n{\n\t_enter(\"op=%08x\", op->debug_id);\n\tif (op->unlink.need_rehash && op->error < 0 && op->error != -ENOENT)\n\t\td_rehash(op->dentry);\n}\n\nstatic const struct afs_operation_ops afs_unlink_operation = {\n\t.issue_afs_rpc\t= afs_fs_remove_file,\n\t.issue_yfs_rpc\t= yfs_fs_remove_file,\n\t.success\t= afs_unlink_success,\n\t.aborted\t= afs_check_for_remote_deletion,\n\t.edit_dir\t= afs_unlink_edit_dir,\n\t.put\t\t= afs_unlink_put,\n};\n\n \nstatic int afs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct afs_operation *op;\n\tstruct afs_vnode *dvnode = AFS_FS_I(dir);\n\tstruct afs_vnode *vnode = AFS_FS_I(d_inode(dentry));\n\tint ret;\n\n\t_enter(\"{%llx:%llu},{%pd}\",\n\t       dvnode->fid.vid, dvnode->fid.vnode, dentry);\n\n\tif (dentry->d_name.len >= AFSNAMEMAX)\n\t\treturn -ENAMETOOLONG;\n\n\top = afs_alloc_operation(NULL, dvnode->volume);\n\tif (IS_ERR(op))\n\t\treturn PTR_ERR(op);\n\n\tafs_op_set_vnode(op, 0, dvnode);\n\top->file[0].dv_delta = 1;\n\top->file[0].modification = true;\n\top->file[0].update_ctime = true;\n\n\t \n\tret = afs_validate(vnode, op->key);\n\tif (ret < 0) {\n\t\top->error = ret;\n\t\tgoto error;\n\t}\n\n\tspin_lock(&dentry->d_lock);\n\tif (d_count(dentry) > 1) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\t \n\t\twrite_inode_now(d_inode(dentry), 0);\n\t\top->error = afs_sillyrename(dvnode, vnode, dentry, op->key);\n\t\tgoto error;\n\t}\n\tif (!d_unhashed(dentry)) {\n\t\t \n\t\t__d_drop(dentry);\n\t\top->unlink.need_rehash = true;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\top->file[1].vnode = vnode;\n\top->file[1].update_ctime = true;\n\top->file[1].op_unlinked = true;\n\top->dentry\t= dentry;\n\top->ops\t\t= &afs_unlink_operation;\n\tafs_begin_vnode_operation(op);\n\tafs_wait_for_operation(op);\n\n\t \n\tif (op->error == 0 && (op->flags & AFS_OPERATION_DIR_CONFLICT)) {\n\t\top->file[1].update_ctime = false;\n\t\top->fetch_status.which = 1;\n\t\top->ops = &afs_fetch_status_operation;\n\t\tafs_begin_vnode_operation(op);\n\t\tafs_wait_for_operation(op);\n\t}\n\n\treturn afs_put_operation(op);\n\nerror:\n\treturn afs_put_operation(op);\n}\n\nstatic const struct afs_operation_ops afs_create_operation = {\n\t.issue_afs_rpc\t= afs_fs_create_file,\n\t.issue_yfs_rpc\t= yfs_fs_create_file,\n\t.success\t= afs_create_success,\n\t.aborted\t= afs_check_for_remote_deletion,\n\t.edit_dir\t= afs_create_edit_dir,\n\t.put\t\t= afs_create_put,\n};\n\n \nstatic int afs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct afs_operation *op;\n\tstruct afs_vnode *dvnode = AFS_FS_I(dir);\n\tint ret = -ENAMETOOLONG;\n\n\t_enter(\"{%llx:%llu},{%pd},%ho\",\n\t       dvnode->fid.vid, dvnode->fid.vnode, dentry, mode);\n\n\tif (dentry->d_name.len >= AFSNAMEMAX)\n\t\tgoto error;\n\n\top = afs_alloc_operation(NULL, dvnode->volume);\n\tif (IS_ERR(op)) {\n\t\tret = PTR_ERR(op);\n\t\tgoto error;\n\t}\n\n\tafs_op_set_vnode(op, 0, dvnode);\n\top->file[0].dv_delta = 1;\n\top->file[0].modification = true;\n\top->file[0].update_ctime = true;\n\n\top->dentry\t= dentry;\n\top->create.mode\t= S_IFREG | mode;\n\top->create.reason = afs_edit_dir_for_create;\n\top->mtime\t= current_time(dir);\n\top->ops\t\t= &afs_create_operation;\n\treturn afs_do_sync_operation(op);\n\nerror:\n\td_drop(dentry);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\nstatic void afs_link_success(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_vnode_param *vp = &op->file[1];\n\n\t_enter(\"op=%08x\", op->debug_id);\n\top->ctime = dvp->scb.status.mtime_client;\n\tafs_vnode_commit_status(op, dvp);\n\tafs_vnode_commit_status(op, vp);\n\tafs_update_dentry_version(op, dvp, op->dentry);\n\tif (op->dentry_2->d_parent == op->dentry->d_parent)\n\t\tafs_update_dentry_version(op, dvp, op->dentry_2);\n\tihold(&vp->vnode->netfs.inode);\n\td_instantiate(op->dentry, &vp->vnode->netfs.inode);\n}\n\nstatic void afs_link_put(struct afs_operation *op)\n{\n\t_enter(\"op=%08x\", op->debug_id);\n\tif (op->error)\n\t\td_drop(op->dentry);\n}\n\nstatic const struct afs_operation_ops afs_link_operation = {\n\t.issue_afs_rpc\t= afs_fs_link,\n\t.issue_yfs_rpc\t= yfs_fs_link,\n\t.success\t= afs_link_success,\n\t.aborted\t= afs_check_for_remote_deletion,\n\t.edit_dir\t= afs_create_edit_dir,\n\t.put\t\t= afs_link_put,\n};\n\n \nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry)\n{\n\tstruct afs_operation *op;\n\tstruct afs_vnode *dvnode = AFS_FS_I(dir);\n\tstruct afs_vnode *vnode = AFS_FS_I(d_inode(from));\n\tint ret = -ENAMETOOLONG;\n\n\t_enter(\"{%llx:%llu},{%llx:%llu},{%pd}\",\n\t       vnode->fid.vid, vnode->fid.vnode,\n\t       dvnode->fid.vid, dvnode->fid.vnode,\n\t       dentry);\n\n\tif (dentry->d_name.len >= AFSNAMEMAX)\n\t\tgoto error;\n\n\top = afs_alloc_operation(NULL, dvnode->volume);\n\tif (IS_ERR(op)) {\n\t\tret = PTR_ERR(op);\n\t\tgoto error;\n\t}\n\n\tret = afs_validate(vnode, op->key);\n\tif (ret < 0)\n\t\tgoto error_op;\n\n\tafs_op_set_vnode(op, 0, dvnode);\n\tafs_op_set_vnode(op, 1, vnode);\n\top->file[0].dv_delta = 1;\n\top->file[0].modification = true;\n\top->file[0].update_ctime = true;\n\top->file[1].update_ctime = true;\n\n\top->dentry\t\t= dentry;\n\top->dentry_2\t\t= from;\n\top->ops\t\t\t= &afs_link_operation;\n\top->create.reason\t= afs_edit_dir_for_link;\n\treturn afs_do_sync_operation(op);\n\nerror_op:\n\tafs_put_operation(op);\nerror:\n\td_drop(dentry);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\nstatic const struct afs_operation_ops afs_symlink_operation = {\n\t.issue_afs_rpc\t= afs_fs_symlink,\n\t.issue_yfs_rpc\t= yfs_fs_symlink,\n\t.success\t= afs_create_success,\n\t.aborted\t= afs_check_for_remote_deletion,\n\t.edit_dir\t= afs_create_edit_dir,\n\t.put\t\t= afs_create_put,\n};\n\n \nstatic int afs_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, const char *content)\n{\n\tstruct afs_operation *op;\n\tstruct afs_vnode *dvnode = AFS_FS_I(dir);\n\tint ret;\n\n\t_enter(\"{%llx:%llu},{%pd},%s\",\n\t       dvnode->fid.vid, dvnode->fid.vnode, dentry,\n\t       content);\n\n\tret = -ENAMETOOLONG;\n\tif (dentry->d_name.len >= AFSNAMEMAX)\n\t\tgoto error;\n\n\tret = -EINVAL;\n\tif (strlen(content) >= AFSPATHMAX)\n\t\tgoto error;\n\n\top = afs_alloc_operation(NULL, dvnode->volume);\n\tif (IS_ERR(op)) {\n\t\tret = PTR_ERR(op);\n\t\tgoto error;\n\t}\n\n\tafs_op_set_vnode(op, 0, dvnode);\n\top->file[0].dv_delta = 1;\n\n\top->dentry\t\t= dentry;\n\top->ops\t\t\t= &afs_symlink_operation;\n\top->create.reason\t= afs_edit_dir_for_symlink;\n\top->create.symlink\t= content;\n\top->mtime\t\t= current_time(dir);\n\treturn afs_do_sync_operation(op);\n\nerror:\n\td_drop(dentry);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\nstatic void afs_rename_success(struct afs_operation *op)\n{\n\t_enter(\"op=%08x\", op->debug_id);\n\n\top->ctime = op->file[0].scb.status.mtime_client;\n\tafs_check_dir_conflict(op, &op->file[1]);\n\tafs_vnode_commit_status(op, &op->file[0]);\n\tif (op->file[1].vnode != op->file[0].vnode) {\n\t\top->ctime = op->file[1].scb.status.mtime_client;\n\t\tafs_vnode_commit_status(op, &op->file[1]);\n\t}\n}\n\nstatic void afs_rename_edit_dir(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *orig_dvp = &op->file[0];\n\tstruct afs_vnode_param *new_dvp = &op->file[1];\n\tstruct afs_vnode *orig_dvnode = orig_dvp->vnode;\n\tstruct afs_vnode *new_dvnode = new_dvp->vnode;\n\tstruct afs_vnode *vnode = AFS_FS_I(d_inode(op->dentry));\n\tstruct dentry *old_dentry = op->dentry;\n\tstruct dentry *new_dentry = op->dentry_2;\n\tstruct inode *new_inode;\n\n\t_enter(\"op=%08x\", op->debug_id);\n\n\tif (op->rename.rehash) {\n\t\td_rehash(op->rename.rehash);\n\t\top->rename.rehash = NULL;\n\t}\n\n\tdown_write(&orig_dvnode->validate_lock);\n\tif (test_bit(AFS_VNODE_DIR_VALID, &orig_dvnode->flags) &&\n\t    orig_dvnode->status.data_version == orig_dvp->dv_before + orig_dvp->dv_delta)\n\t\tafs_edit_dir_remove(orig_dvnode, &old_dentry->d_name,\n\t\t\t\t    afs_edit_dir_for_rename_0);\n\n\tif (new_dvnode != orig_dvnode) {\n\t\tup_write(&orig_dvnode->validate_lock);\n\t\tdown_write(&new_dvnode->validate_lock);\n\t}\n\n\tif (test_bit(AFS_VNODE_DIR_VALID, &new_dvnode->flags) &&\n\t    new_dvnode->status.data_version == new_dvp->dv_before + new_dvp->dv_delta) {\n\t\tif (!op->rename.new_negative)\n\t\t\tafs_edit_dir_remove(new_dvnode, &new_dentry->d_name,\n\t\t\t\t\t    afs_edit_dir_for_rename_1);\n\n\t\tafs_edit_dir_add(new_dvnode, &new_dentry->d_name,\n\t\t\t\t &vnode->fid, afs_edit_dir_for_rename_2);\n\t}\n\n\tnew_inode = d_inode(new_dentry);\n\tif (new_inode) {\n\t\tspin_lock(&new_inode->i_lock);\n\t\tif (S_ISDIR(new_inode->i_mode))\n\t\t\tclear_nlink(new_inode);\n\t\telse if (new_inode->i_nlink > 0)\n\t\t\tdrop_nlink(new_inode);\n\t\tspin_unlock(&new_inode->i_lock);\n\t}\n\n\t \n\tafs_update_dentry_version(op, new_dvp, op->dentry);\n\tafs_update_dentry_version(op, new_dvp, op->dentry_2);\n\n\td_move(old_dentry, new_dentry);\n\n\tup_write(&new_dvnode->validate_lock);\n}\n\nstatic void afs_rename_put(struct afs_operation *op)\n{\n\t_enter(\"op=%08x\", op->debug_id);\n\tif (op->rename.rehash)\n\t\td_rehash(op->rename.rehash);\n\tdput(op->rename.tmp);\n\tif (op->error)\n\t\td_rehash(op->dentry);\n}\n\nstatic const struct afs_operation_ops afs_rename_operation = {\n\t.issue_afs_rpc\t= afs_fs_rename,\n\t.issue_yfs_rpc\t= yfs_fs_rename,\n\t.success\t= afs_rename_success,\n\t.edit_dir\t= afs_rename_edit_dir,\n\t.put\t\t= afs_rename_put,\n};\n\n \nstatic int afs_rename(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\t      struct dentry *old_dentry, struct inode *new_dir,\n\t\t      struct dentry *new_dentry, unsigned int flags)\n{\n\tstruct afs_operation *op;\n\tstruct afs_vnode *orig_dvnode, *new_dvnode, *vnode;\n\tint ret;\n\n\tif (flags)\n\t\treturn -EINVAL;\n\n\t \n\tif (old_dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EINVAL;\n\n\tvnode = AFS_FS_I(d_inode(old_dentry));\n\torig_dvnode = AFS_FS_I(old_dir);\n\tnew_dvnode = AFS_FS_I(new_dir);\n\n\t_enter(\"{%llx:%llu},{%llx:%llu},{%llx:%llu},{%pd}\",\n\t       orig_dvnode->fid.vid, orig_dvnode->fid.vnode,\n\t       vnode->fid.vid, vnode->fid.vnode,\n\t       new_dvnode->fid.vid, new_dvnode->fid.vnode,\n\t       new_dentry);\n\n\top = afs_alloc_operation(NULL, orig_dvnode->volume);\n\tif (IS_ERR(op))\n\t\treturn PTR_ERR(op);\n\n\tret = afs_validate(vnode, op->key);\n\top->error = ret;\n\tif (ret < 0)\n\t\tgoto error;\n\n\tafs_op_set_vnode(op, 0, orig_dvnode);\n\tafs_op_set_vnode(op, 1, new_dvnode);  \n\top->file[0].dv_delta = 1;\n\top->file[1].dv_delta = 1;\n\top->file[0].modification = true;\n\top->file[1].modification = true;\n\top->file[0].update_ctime = true;\n\top->file[1].update_ctime = true;\n\n\top->dentry\t\t= old_dentry;\n\top->dentry_2\t\t= new_dentry;\n\top->rename.new_negative\t= d_is_negative(new_dentry);\n\top->ops\t\t\t= &afs_rename_operation;\n\n\t \n\tif (d_is_positive(new_dentry) && !d_is_dir(new_dentry)) {\n\t\t \n\t\tif (!d_unhashed(new_dentry)) {\n\t\t\td_drop(new_dentry);\n\t\t\top->rename.rehash = new_dentry;\n\t\t}\n\n\t\tif (d_count(new_dentry) > 2) {\n\t\t\t \n\t\t\top->rename.tmp = d_alloc(new_dentry->d_parent,\n\t\t\t\t\t\t &new_dentry->d_name);\n\t\t\tif (!op->rename.tmp) {\n\t\t\t\top->error = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tret = afs_sillyrename(new_dvnode,\n\t\t\t\t\t      AFS_FS_I(d_inode(new_dentry)),\n\t\t\t\t\t      new_dentry, op->key);\n\t\t\tif (ret) {\n\t\t\t\top->error = ret;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\top->dentry_2 = op->rename.tmp;\n\t\t\top->rename.rehash = NULL;\n\t\t\top->rename.new_negative = true;\n\t\t}\n\t}\n\n\t \n\td_drop(old_dentry);\n\n\treturn afs_do_sync_operation(op);\n\nerror:\n\treturn afs_put_operation(op);\n}\n\n \nstatic bool afs_dir_release_folio(struct folio *folio, gfp_t gfp_flags)\n{\n\tstruct afs_vnode *dvnode = AFS_FS_I(folio_inode(folio));\n\n\t_enter(\"{{%llx:%llu}[%lu]}\", dvnode->fid.vid, dvnode->fid.vnode, folio_index(folio));\n\n\tfolio_detach_private(folio);\n\n\t \n\tif (test_and_clear_bit(AFS_VNODE_DIR_VALID, &dvnode->flags))\n\t\tafs_stat_v(dvnode, n_relpg);\n\treturn true;\n}\n\n \nstatic void afs_dir_invalidate_folio(struct folio *folio, size_t offset,\n\t\t\t\t   size_t length)\n{\n\tstruct afs_vnode *dvnode = AFS_FS_I(folio_inode(folio));\n\n\t_enter(\"{%lu},%zu,%zu\", folio->index, offset, length);\n\n\tBUG_ON(!folio_test_locked(folio));\n\n\t \n\tif (test_and_clear_bit(AFS_VNODE_DIR_VALID, &dvnode->flags))\n\t\tafs_stat_v(dvnode, n_inval);\n\n\t \n\tif (offset == 0 && length == folio_size(folio))\n\t\tfolio_detach_private(folio);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}