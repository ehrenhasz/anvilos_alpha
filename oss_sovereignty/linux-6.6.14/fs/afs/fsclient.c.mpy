{
  "module_name": "fsclient.c",
  "hash_id": "a1a19061f4208b100ca500dea5b94cc9c4b5cc9333a8844d71ca070144629393",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/fsclient.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/circ_buf.h>\n#include <linux/iversion.h>\n#include <linux/netfs.h>\n#include \"internal.h\"\n#include \"afs_fs.h\"\n#include \"xdr_fs.h\"\n\n \nstatic void xdr_decode_AFSFid(const __be32 **_bp, struct afs_fid *fid)\n{\n\tconst __be32 *bp = *_bp;\n\n\tfid->vid\t\t= ntohl(*bp++);\n\tfid->vnode\t\t= ntohl(*bp++);\n\tfid->unique\t\t= ntohl(*bp++);\n\t*_bp = bp;\n}\n\n \nstatic void xdr_dump_bad(const __be32 *bp)\n{\n\t__be32 x[4];\n\tint i;\n\n\tpr_notice(\"AFS XDR: Bad status record\\n\");\n\tfor (i = 0; i < 5 * 4 * 4; i += 16) {\n\t\tmemcpy(x, bp, 16);\n\t\tbp += 4;\n\t\tpr_notice(\"%03x: %08x %08x %08x %08x\\n\",\n\t\t\t  i, ntohl(x[0]), ntohl(x[1]), ntohl(x[2]), ntohl(x[3]));\n\t}\n\n\tmemcpy(x, bp, 4);\n\tpr_notice(\"0x50: %08x\\n\", ntohl(x[0]));\n}\n\n \nstatic void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_call *call,\n\t\t\t\t      struct afs_status_cb *scb)\n{\n\tconst struct afs_xdr_AFSFetchStatus *xdr = (const void *)*_bp;\n\tstruct afs_file_status *status = &scb->status;\n\tbool inline_error = (call->operation_ID == afs_FS_InlineBulkStatus);\n\tu64 data_version, size;\n\tu32 type, abort_code;\n\n\tabort_code = ntohl(xdr->abort_code);\n\n\tif (xdr->if_version != htonl(AFS_FSTATUS_VERSION)) {\n\t\tif (xdr->if_version == htonl(0) &&\n\t\t    abort_code != 0 &&\n\t\t    inline_error) {\n\t\t\t \n\t\t\tstatus->abort_code = abort_code;\n\t\t\tscb->have_error = true;\n\t\t\tgoto advance;\n\t\t}\n\n\t\tpr_warn(\"Unknown AFSFetchStatus version %u\\n\", ntohl(xdr->if_version));\n\t\tgoto bad;\n\t}\n\n\tif (abort_code != 0 && inline_error) {\n\t\tstatus->abort_code = abort_code;\n\t\tscb->have_error = true;\n\t\tgoto advance;\n\t}\n\n\ttype = ntohl(xdr->type);\n\tswitch (type) {\n\tcase AFS_FTYPE_FILE:\n\tcase AFS_FTYPE_DIR:\n\tcase AFS_FTYPE_SYMLINK:\n\t\tstatus->type = type;\n\t\tbreak;\n\tdefault:\n\t\tgoto bad;\n\t}\n\n\tstatus->nlink\t\t= ntohl(xdr->nlink);\n\tstatus->author\t\t= ntohl(xdr->author);\n\tstatus->owner\t\t= ntohl(xdr->owner);\n\tstatus->caller_access\t= ntohl(xdr->caller_access);  \n\tstatus->anon_access\t= ntohl(xdr->anon_access);\n\tstatus->mode\t\t= ntohl(xdr->mode) & S_IALLUGO;\n\tstatus->group\t\t= ntohl(xdr->group);\n\tstatus->lock_count\t= ntohl(xdr->lock_count);\n\n\tstatus->mtime_client.tv_sec = ntohl(xdr->mtime_client);\n\tstatus->mtime_client.tv_nsec = 0;\n\tstatus->mtime_server.tv_sec = ntohl(xdr->mtime_server);\n\tstatus->mtime_server.tv_nsec = 0;\n\n\tsize  = (u64)ntohl(xdr->size_lo);\n\tsize |= (u64)ntohl(xdr->size_hi) << 32;\n\tstatus->size = size;\n\n\tdata_version  = (u64)ntohl(xdr->data_version_lo);\n\tdata_version |= (u64)ntohl(xdr->data_version_hi) << 32;\n\tstatus->data_version = data_version;\n\tscb->have_status = true;\nadvance:\n\t*_bp = (const void *)*_bp + sizeof(*xdr);\n\treturn;\n\nbad:\n\txdr_dump_bad(*_bp);\n\tafs_protocol_error(call, afs_eproto_bad_status);\n\tgoto advance;\n}\n\nstatic time64_t xdr_decode_expiry(struct afs_call *call, u32 expiry)\n{\n\treturn ktime_divns(call->issue_time, NSEC_PER_SEC) + expiry;\n}\n\nstatic void xdr_decode_AFSCallBack(const __be32 **_bp,\n\t\t\t\t   struct afs_call *call,\n\t\t\t\t   struct afs_status_cb *scb)\n{\n\tstruct afs_callback *cb = &scb->callback;\n\tconst __be32 *bp = *_bp;\n\n\tbp++;  \n\tcb->expires_at\t= xdr_decode_expiry(call, ntohl(*bp++));\n\tbp++;  \n\tscb->have_cb\t= true;\n\t*_bp = bp;\n}\n\n \nstatic void xdr_decode_AFSVolSync(const __be32 **_bp,\n\t\t\t\t  struct afs_volsync *volsync)\n{\n\tconst __be32 *bp = *_bp;\n\tu32 creation;\n\n\tcreation = ntohl(*bp++);\n\tbp++;  \n\tbp++;  \n\tbp++;  \n\tbp++;  \n\tbp++;  \n\t*_bp = bp;\n\n\tif (volsync)\n\t\tvolsync->creation = creation;\n}\n\n \nstatic void xdr_encode_AFS_StoreStatus(__be32 **_bp, struct iattr *attr)\n{\n\t__be32 *bp = *_bp;\n\tu32 mask = 0, mtime = 0, owner = 0, group = 0, mode = 0;\n\n\tmask = 0;\n\tif (attr->ia_valid & ATTR_MTIME) {\n\t\tmask |= AFS_SET_MTIME;\n\t\tmtime = attr->ia_mtime.tv_sec;\n\t}\n\n\tif (attr->ia_valid & ATTR_UID) {\n\t\tmask |= AFS_SET_OWNER;\n\t\towner = from_kuid(&init_user_ns, attr->ia_uid);\n\t}\n\n\tif (attr->ia_valid & ATTR_GID) {\n\t\tmask |= AFS_SET_GROUP;\n\t\tgroup = from_kgid(&init_user_ns, attr->ia_gid);\n\t}\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tmask |= AFS_SET_MODE;\n\t\tmode = attr->ia_mode & S_IALLUGO;\n\t}\n\n\t*bp++ = htonl(mask);\n\t*bp++ = htonl(mtime);\n\t*bp++ = htonl(owner);\n\t*bp++ = htonl(group);\n\t*bp++ = htonl(mode);\n\t*bp++ = 0;\t\t \n\t*_bp = bp;\n}\n\n \nstatic void xdr_decode_AFSFetchVolumeStatus(const __be32 **_bp,\n\t\t\t\t\t    struct afs_volume_status *vs)\n{\n\tconst __be32 *bp = *_bp;\n\n\tvs->vid\t\t\t= ntohl(*bp++);\n\tvs->parent_id\t\t= ntohl(*bp++);\n\tvs->online\t\t= ntohl(*bp++);\n\tvs->in_service\t\t= ntohl(*bp++);\n\tvs->blessed\t\t= ntohl(*bp++);\n\tvs->needs_salvage\t= ntohl(*bp++);\n\tvs->type\t\t= ntohl(*bp++);\n\tvs->min_quota\t\t= ntohl(*bp++);\n\tvs->max_quota\t\t= ntohl(*bp++);\n\tvs->blocks_in_use\t= ntohl(*bp++);\n\tvs->part_blocks_avail\t= ntohl(*bp++);\n\tvs->part_max_blocks\t= ntohl(*bp++);\n\tvs->vol_copy_date\t= 0;\n\tvs->vol_backup_date\t= 0;\n\t*_bp = bp;\n}\n\n \nstatic int afs_deliver_fs_fetch_status(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode_param *vp = &op->file[op->fetch_status.which];\n\tconst __be32 *bp;\n\tint ret;\n\n\tret = afs_transfer_reply(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbp = call->buffer;\n\txdr_decode_AFSFetchStatus(&bp, call, &vp->scb);\n\txdr_decode_AFSCallBack(&bp, call, &vp->scb);\n\txdr_decode_AFSVolSync(&bp, &op->volsync);\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type afs_RXFSFetchStatus = {\n\t.name\t\t= \"FS.FetchStatus\",\n\t.op\t\t= afs_FS_FetchStatus,\n\t.deliver\t= afs_deliver_fs_fetch_status,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid afs_fs_fetch_status(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[op->fetch_status.which];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%llx:%llu},,\",\n\t       key_serial(op->key), vp->fid.vid, vp->fid.vnode);\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSFetchStatus,\n\t\t\t\t   16, (21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp[0] = htonl(FSFETCHSTATUS);\n\tbp[1] = htonl(vp->fid.vid);\n\tbp[2] = htonl(vp->fid.vnode);\n\tbp[3] = htonl(vp->fid.unique);\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int afs_deliver_fs_fetch_data(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_read *req = op->fetch.req;\n\tconst __be32 *bp;\n\tint ret;\n\n\t_enter(\"{%u,%zu,%zu/%llu}\",\n\t       call->unmarshall, call->iov_len, iov_iter_count(call->iter),\n\t       req->actual_len);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\treq->actual_len = 0;\n\t\tcall->unmarshall++;\n\t\tif (call->operation_ID == FSFETCHDATA64) {\n\t\t\tafs_extract_to_tmp64(call);\n\t\t} else {\n\t\t\tcall->tmp_u = htonl(0);\n\t\t\tafs_extract_to_tmp(call);\n\t\t}\n\t\tfallthrough;\n\n\t\t \n\tcase 1:\n\t\t_debug(\"extract data length\");\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treq->actual_len = be64_to_cpu(call->tmp64);\n\t\t_debug(\"DATA length: %llu\", req->actual_len);\n\n\t\tif (req->actual_len == 0)\n\t\t\tgoto no_more_data;\n\n\t\tcall->iter = req->iter;\n\t\tcall->iov_len = min(req->actual_len, req->len);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 2:\n\t\t_debug(\"extract data %zu/%llu\",\n\t\t       iov_iter_count(call->iter), req->actual_len);\n\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcall->iter = &call->def_iter;\n\t\tif (req->actual_len <= req->len)\n\t\t\tgoto no_more_data;\n\n\t\t \n\t\tafs_extract_discard(call, req->actual_len - req->len);\n\t\tcall->unmarshall = 3;\n\t\tfallthrough;\n\n\tcase 3:\n\t\t_debug(\"extract discard %zu/%llu\",\n\t\t       iov_iter_count(call->iter), req->actual_len - req->len);\n\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\tno_more_data:\n\t\tcall->unmarshall = 4;\n\t\tafs_extract_to_buf(call, (21 + 3 + 6) * 4);\n\t\tfallthrough;\n\n\t\t \n\tcase 4:\n\t\tret = afs_extract_data(call, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbp = call->buffer;\n\t\txdr_decode_AFSFetchStatus(&bp, call, &vp->scb);\n\t\txdr_decode_AFSCallBack(&bp, call, &vp->scb);\n\t\txdr_decode_AFSVolSync(&bp, &op->volsync);\n\n\t\treq->data_version = vp->scb.status.data_version;\n\t\treq->file_size = vp->scb.status.size;\n\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\tcase 5:\n\t\tbreak;\n\t}\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type afs_RXFSFetchData = {\n\t.name\t\t= \"FS.FetchData\",\n\t.op\t\t= afs_FS_FetchData,\n\t.deliver\t= afs_deliver_fs_fetch_data,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nstatic const struct afs_call_type afs_RXFSFetchData64 = {\n\t.name\t\t= \"FS.FetchData64\",\n\t.op\t\t= afs_FS_FetchData64,\n\t.deliver\t= afs_deliver_fs_fetch_data,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nstatic void afs_fs_fetch_data64(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_read *req = op->fetch.req;\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSFetchData64, 32, (21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp[0] = htonl(FSFETCHDATA64);\n\tbp[1] = htonl(vp->fid.vid);\n\tbp[2] = htonl(vp->fid.vnode);\n\tbp[3] = htonl(vp->fid.unique);\n\tbp[4] = htonl(upper_32_bits(req->pos));\n\tbp[5] = htonl(lower_32_bits(req->pos));\n\tbp[6] = 0;\n\tbp[7] = htonl(lower_32_bits(req->len));\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nvoid afs_fs_fetch_data(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\tstruct afs_read *req = op->fetch.req;\n\t__be32 *bp;\n\n\tif (test_bit(AFS_SERVER_FL_HAS_FS64, &op->server->flags))\n\t\treturn afs_fs_fetch_data64(op);\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSFetchData, 24, (21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\treq->call_debug_id = call->debug_id;\n\n\t \n\tbp = call->request;\n\tbp[0] = htonl(FSFETCHDATA);\n\tbp[1] = htonl(vp->fid.vid);\n\tbp[2] = htonl(vp->fid.vnode);\n\tbp[3] = htonl(vp->fid.unique);\n\tbp[4] = htonl(lower_32_bits(req->pos));\n\tbp[5] = htonl(lower_32_bits(req->len));\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int afs_deliver_fs_create_vnode(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_vnode_param *vp = &op->file[1];\n\tconst __be32 *bp;\n\tint ret;\n\n\tret = afs_transfer_reply(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbp = call->buffer;\n\txdr_decode_AFSFid(&bp, &op->file[1].fid);\n\txdr_decode_AFSFetchStatus(&bp, call, &vp->scb);\n\txdr_decode_AFSFetchStatus(&bp, call, &dvp->scb);\n\txdr_decode_AFSCallBack(&bp, call, &vp->scb);\n\txdr_decode_AFSVolSync(&bp, &op->volsync);\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type afs_RXFSCreateFile = {\n\t.name\t\t= \"FS.CreateFile\",\n\t.op\t\t= afs_FS_CreateFile,\n\t.deliver\t= afs_deliver_fs_create_vnode,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid afs_fs_create_file(struct afs_operation *op)\n{\n\tconst struct qstr *name = &op->dentry->d_name;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = name->len;\n\tpadsz = (4 - (namesz & 3)) & 3;\n\treqsz = (5 * 4) + namesz + padsz + (6 * 4);\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSCreateFile,\n\t\t\t\t   reqsz, (3 + 21 + 21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(FSCREATEFILE);\n\t*bp++ = htonl(dvp->fid.vid);\n\t*bp++ = htonl(dvp->fid.vnode);\n\t*bp++ = htonl(dvp->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name->name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\t*bp++ = htonl(AFS_SET_MODE | AFS_SET_MTIME);\n\t*bp++ = htonl(op->mtime.tv_sec);  \n\t*bp++ = 0;  \n\t*bp++ = 0;  \n\t*bp++ = htonl(op->create.mode & S_IALLUGO);  \n\t*bp++ = 0;  \n\n\ttrace_afs_make_fs_call1(call, &dvp->fid, name);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\nstatic const struct afs_call_type afs_RXFSMakeDir = {\n\t.name\t\t= \"FS.MakeDir\",\n\t.op\t\t= afs_FS_MakeDir,\n\t.deliver\t= afs_deliver_fs_create_vnode,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid afs_fs_make_dir(struct afs_operation *op)\n{\n\tconst struct qstr *name = &op->dentry->d_name;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = name->len;\n\tpadsz = (4 - (namesz & 3)) & 3;\n\treqsz = (5 * 4) + namesz + padsz + (6 * 4);\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSMakeDir,\n\t\t\t\t   reqsz, (3 + 21 + 21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(FSMAKEDIR);\n\t*bp++ = htonl(dvp->fid.vid);\n\t*bp++ = htonl(dvp->fid.vnode);\n\t*bp++ = htonl(dvp->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name->name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\t*bp++ = htonl(AFS_SET_MODE | AFS_SET_MTIME);\n\t*bp++ = htonl(op->mtime.tv_sec);  \n\t*bp++ = 0;  \n\t*bp++ = 0;  \n\t*bp++ = htonl(op->create.mode & S_IALLUGO);  \n\t*bp++ = 0;  \n\n\ttrace_afs_make_fs_call1(call, &dvp->fid, name);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int afs_deliver_fs_file_status_and_vol(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tconst __be32 *bp;\n\tint ret;\n\n\tret = afs_transfer_reply(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbp = call->buffer;\n\txdr_decode_AFSFetchStatus(&bp, call, &vp->scb);\n\txdr_decode_AFSVolSync(&bp, &op->volsync);\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type afs_RXFSRemoveFile = {\n\t.name\t\t= \"FS.RemoveFile\",\n\t.op\t\t= afs_FS_RemoveFile,\n\t.deliver\t= afs_deliver_fs_file_status_and_vol,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid afs_fs_remove_file(struct afs_operation *op)\n{\n\tconst struct qstr *name = &op->dentry->d_name;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = name->len;\n\tpadsz = (4 - (namesz & 3)) & 3;\n\treqsz = (5 * 4) + namesz + padsz;\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSRemoveFile,\n\t\t\t\t   reqsz, (21 + 6) * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(FSREMOVEFILE);\n\t*bp++ = htonl(dvp->fid.vid);\n\t*bp++ = htonl(dvp->fid.vnode);\n\t*bp++ = htonl(dvp->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name->name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\n\ttrace_afs_make_fs_call1(call, &dvp->fid, name);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\nstatic const struct afs_call_type afs_RXFSRemoveDir = {\n\t.name\t\t= \"FS.RemoveDir\",\n\t.op\t\t= afs_FS_RemoveDir,\n\t.deliver\t= afs_deliver_fs_file_status_and_vol,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid afs_fs_remove_dir(struct afs_operation *op)\n{\n\tconst struct qstr *name = &op->dentry->d_name;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = name->len;\n\tpadsz = (4 - (namesz & 3)) & 3;\n\treqsz = (5 * 4) + namesz + padsz;\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSRemoveDir,\n\t\t\t\t   reqsz, (21 + 6) * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(FSREMOVEDIR);\n\t*bp++ = htonl(dvp->fid.vid);\n\t*bp++ = htonl(dvp->fid.vnode);\n\t*bp++ = htonl(dvp->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name->name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\n\ttrace_afs_make_fs_call1(call, &dvp->fid, name);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int afs_deliver_fs_link(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_vnode_param *vp = &op->file[1];\n\tconst __be32 *bp;\n\tint ret;\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tret = afs_transfer_reply(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbp = call->buffer;\n\txdr_decode_AFSFetchStatus(&bp, call, &vp->scb);\n\txdr_decode_AFSFetchStatus(&bp, call, &dvp->scb);\n\txdr_decode_AFSVolSync(&bp, &op->volsync);\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type afs_RXFSLink = {\n\t.name\t\t= \"FS.Link\",\n\t.op\t\t= afs_FS_Link,\n\t.deliver\t= afs_deliver_fs_link,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid afs_fs_link(struct afs_operation *op)\n{\n\tconst struct qstr *name = &op->dentry->d_name;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_vnode_param *vp = &op->file[1];\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = name->len;\n\tpadsz = (4 - (namesz & 3)) & 3;\n\treqsz = (5 * 4) + namesz + padsz + (3 * 4);\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSLink, reqsz, (21 + 21 + 6) * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(FSLINK);\n\t*bp++ = htonl(dvp->fid.vid);\n\t*bp++ = htonl(dvp->fid.vnode);\n\t*bp++ = htonl(dvp->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name->name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\t*bp++ = htonl(vp->fid.vid);\n\t*bp++ = htonl(vp->fid.vnode);\n\t*bp++ = htonl(vp->fid.unique);\n\n\ttrace_afs_make_fs_call1(call, &vp->fid, name);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int afs_deliver_fs_symlink(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_vnode_param *vp = &op->file[1];\n\tconst __be32 *bp;\n\tint ret;\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tret = afs_transfer_reply(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbp = call->buffer;\n\txdr_decode_AFSFid(&bp, &vp->fid);\n\txdr_decode_AFSFetchStatus(&bp, call, &vp->scb);\n\txdr_decode_AFSFetchStatus(&bp, call, &dvp->scb);\n\txdr_decode_AFSVolSync(&bp, &op->volsync);\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type afs_RXFSSymlink = {\n\t.name\t\t= \"FS.Symlink\",\n\t.op\t\t= afs_FS_Symlink,\n\t.deliver\t= afs_deliver_fs_symlink,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid afs_fs_symlink(struct afs_operation *op)\n{\n\tconst struct qstr *name = &op->dentry->d_name;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz, c_namesz, c_padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = name->len;\n\tpadsz = (4 - (namesz & 3)) & 3;\n\n\tc_namesz = strlen(op->create.symlink);\n\tc_padsz = (4 - (c_namesz & 3)) & 3;\n\n\treqsz = (6 * 4) + namesz + padsz + c_namesz + c_padsz + (6 * 4);\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSSymlink, reqsz,\n\t\t\t\t   (3 + 21 + 21 + 6) * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(FSSYMLINK);\n\t*bp++ = htonl(dvp->fid.vid);\n\t*bp++ = htonl(dvp->fid.vnode);\n\t*bp++ = htonl(dvp->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name->name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\t*bp++ = htonl(c_namesz);\n\tmemcpy(bp, op->create.symlink, c_namesz);\n\tbp = (void *) bp + c_namesz;\n\tif (c_padsz > 0) {\n\t\tmemset(bp, 0, c_padsz);\n\t\tbp = (void *) bp + c_padsz;\n\t}\n\t*bp++ = htonl(AFS_SET_MODE | AFS_SET_MTIME);\n\t*bp++ = htonl(op->mtime.tv_sec);  \n\t*bp++ = 0;  \n\t*bp++ = 0;  \n\t*bp++ = htonl(S_IRWXUGO);  \n\t*bp++ = 0;  \n\n\ttrace_afs_make_fs_call1(call, &dvp->fid, name);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int afs_deliver_fs_rename(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode_param *orig_dvp = &op->file[0];\n\tstruct afs_vnode_param *new_dvp = &op->file[1];\n\tconst __be32 *bp;\n\tint ret;\n\n\tret = afs_transfer_reply(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbp = call->buffer;\n\t \n\txdr_decode_AFSFetchStatus(&bp, call, &orig_dvp->scb);\n\txdr_decode_AFSFetchStatus(&bp, call, &new_dvp->scb);\n\txdr_decode_AFSVolSync(&bp, &op->volsync);\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type afs_RXFSRename = {\n\t.name\t\t= \"FS.Rename\",\n\t.op\t\t= afs_FS_Rename,\n\t.deliver\t= afs_deliver_fs_rename,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid afs_fs_rename(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *orig_dvp = &op->file[0];\n\tstruct afs_vnode_param *new_dvp = &op->file[1];\n\tconst struct qstr *orig_name = &op->dentry->d_name;\n\tconst struct qstr *new_name = &op->dentry_2->d_name;\n\tstruct afs_call *call;\n\tsize_t reqsz, o_namesz, o_padsz, n_namesz, n_padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\to_namesz = orig_name->len;\n\to_padsz = (4 - (o_namesz & 3)) & 3;\n\n\tn_namesz = new_name->len;\n\tn_padsz = (4 - (n_namesz & 3)) & 3;\n\n\treqsz = (4 * 4) +\n\t\t4 + o_namesz + o_padsz +\n\t\t(3 * 4) +\n\t\t4 + n_namesz + n_padsz;\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSRename, reqsz, (21 + 21 + 6) * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(FSRENAME);\n\t*bp++ = htonl(orig_dvp->fid.vid);\n\t*bp++ = htonl(orig_dvp->fid.vnode);\n\t*bp++ = htonl(orig_dvp->fid.unique);\n\t*bp++ = htonl(o_namesz);\n\tmemcpy(bp, orig_name->name, o_namesz);\n\tbp = (void *) bp + o_namesz;\n\tif (o_padsz > 0) {\n\t\tmemset(bp, 0, o_padsz);\n\t\tbp = (void *) bp + o_padsz;\n\t}\n\n\t*bp++ = htonl(new_dvp->fid.vid);\n\t*bp++ = htonl(new_dvp->fid.vnode);\n\t*bp++ = htonl(new_dvp->fid.unique);\n\t*bp++ = htonl(n_namesz);\n\tmemcpy(bp, new_name->name, n_namesz);\n\tbp = (void *) bp + n_namesz;\n\tif (n_padsz > 0) {\n\t\tmemset(bp, 0, n_padsz);\n\t\tbp = (void *) bp + n_padsz;\n\t}\n\n\ttrace_afs_make_fs_call2(call, &orig_dvp->fid, orig_name, new_name);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int afs_deliver_fs_store_data(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tconst __be32 *bp;\n\tint ret;\n\n\t_enter(\"\");\n\n\tret = afs_transfer_reply(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbp = call->buffer;\n\txdr_decode_AFSFetchStatus(&bp, call, &vp->scb);\n\txdr_decode_AFSVolSync(&bp, &op->volsync);\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type afs_RXFSStoreData = {\n\t.name\t\t= \"FS.StoreData\",\n\t.op\t\t= afs_FS_StoreData,\n\t.deliver\t= afs_deliver_fs_store_data,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nstatic const struct afs_call_type afs_RXFSStoreData64 = {\n\t.name\t\t= \"FS.StoreData64\",\n\t.op\t\t= afs_FS_StoreData64,\n\t.deliver\t= afs_deliver_fs_store_data,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nstatic void afs_fs_store_data64(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%llx:%llu},,\",\n\t       key_serial(op->key), vp->fid.vid, vp->fid.vnode);\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSStoreData64,\n\t\t\t\t   (4 + 6 + 3 * 2) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\tcall->write_iter = op->store.write_iter;\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA64);\n\t*bp++ = htonl(vp->fid.vid);\n\t*bp++ = htonl(vp->fid.vnode);\n\t*bp++ = htonl(vp->fid.unique);\n\n\t*bp++ = htonl(AFS_SET_MTIME);  \n\t*bp++ = htonl(op->mtime.tv_sec);  \n\t*bp++ = 0;  \n\t*bp++ = 0;  \n\t*bp++ = 0;  \n\t*bp++ = 0;  \n\n\t*bp++ = htonl(upper_32_bits(op->store.pos));\n\t*bp++ = htonl(lower_32_bits(op->store.pos));\n\t*bp++ = htonl(upper_32_bits(op->store.size));\n\t*bp++ = htonl(lower_32_bits(op->store.size));\n\t*bp++ = htonl(upper_32_bits(op->store.i_size));\n\t*bp++ = htonl(lower_32_bits(op->store.i_size));\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nvoid afs_fs_store_data(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%llx:%llu},,\",\n\t       key_serial(op->key), vp->fid.vid, vp->fid.vnode);\n\n\t_debug(\"size %llx, at %llx, i_size %llx\",\n\t       (unsigned long long)op->store.size,\n\t       (unsigned long long)op->store.pos,\n\t       (unsigned long long)op->store.i_size);\n\n\tif (test_bit(AFS_SERVER_FL_HAS_FS64, &op->server->flags))\n\t\treturn afs_fs_store_data64(op);\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSStoreData,\n\t\t\t\t   (4 + 6 + 3) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\tcall->write_iter = op->store.write_iter;\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA);\n\t*bp++ = htonl(vp->fid.vid);\n\t*bp++ = htonl(vp->fid.vnode);\n\t*bp++ = htonl(vp->fid.unique);\n\n\t*bp++ = htonl(AFS_SET_MTIME);  \n\t*bp++ = htonl(op->mtime.tv_sec);  \n\t*bp++ = 0;  \n\t*bp++ = 0;  \n\t*bp++ = 0;  \n\t*bp++ = 0;  \n\n\t*bp++ = htonl(lower_32_bits(op->store.pos));\n\t*bp++ = htonl(lower_32_bits(op->store.size));\n\t*bp++ = htonl(lower_32_bits(op->store.i_size));\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic const struct afs_call_type afs_RXFSStoreStatus = {\n\t.name\t\t= \"FS.StoreStatus\",\n\t.op\t\t= afs_FS_StoreStatus,\n\t.deliver\t= afs_deliver_fs_store_data,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nstatic const struct afs_call_type afs_RXFSStoreData_as_Status = {\n\t.name\t\t= \"FS.StoreData\",\n\t.op\t\t= afs_FS_StoreData,\n\t.deliver\t= afs_deliver_fs_store_data,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nstatic const struct afs_call_type afs_RXFSStoreData64_as_Status = {\n\t.name\t\t= \"FS.StoreData64\",\n\t.op\t\t= afs_FS_StoreData64,\n\t.deliver\t= afs_deliver_fs_store_data,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nstatic void afs_fs_setattr_size64(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\tstruct iattr *attr = op->setattr.attr;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%llx:%llu},,\",\n\t       key_serial(op->key), vp->fid.vid, vp->fid.vnode);\n\n\tASSERT(attr->ia_valid & ATTR_SIZE);\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSStoreData64_as_Status,\n\t\t\t\t   (4 + 6 + 3 * 2) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA64);\n\t*bp++ = htonl(vp->fid.vid);\n\t*bp++ = htonl(vp->fid.vnode);\n\t*bp++ = htonl(vp->fid.unique);\n\n\txdr_encode_AFS_StoreStatus(&bp, attr);\n\n\t*bp++ = htonl(upper_32_bits(attr->ia_size));\t \n\t*bp++ = htonl(lower_32_bits(attr->ia_size));\n\t*bp++ = 0;\t\t\t\t\t \n\t*bp++ = 0;\n\t*bp++ = htonl(upper_32_bits(attr->ia_size));\t \n\t*bp++ = htonl(lower_32_bits(attr->ia_size));\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic void afs_fs_setattr_size(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\tstruct iattr *attr = op->setattr.attr;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%llx:%llu},,\",\n\t       key_serial(op->key), vp->fid.vid, vp->fid.vnode);\n\n\tASSERT(attr->ia_valid & ATTR_SIZE);\n\tif (test_bit(AFS_SERVER_FL_HAS_FS64, &op->server->flags))\n\t\treturn afs_fs_setattr_size64(op);\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSStoreData_as_Status,\n\t\t\t\t   (4 + 6 + 3) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA);\n\t*bp++ = htonl(vp->fid.vid);\n\t*bp++ = htonl(vp->fid.vnode);\n\t*bp++ = htonl(vp->fid.unique);\n\n\txdr_encode_AFS_StoreStatus(&bp, attr);\n\n\t*bp++ = htonl(attr->ia_size);\t\t \n\t*bp++ = 0;\t\t\t\t \n\t*bp++ = htonl(attr->ia_size);\t\t \n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nvoid afs_fs_setattr(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\tstruct iattr *attr = op->setattr.attr;\n\t__be32 *bp;\n\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\treturn afs_fs_setattr_size(op);\n\n\t_enter(\",%x,{%llx:%llu},,\",\n\t       key_serial(op->key), vp->fid.vid, vp->fid.vnode);\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSStoreStatus,\n\t\t\t\t   (4 + 6) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(FSSTORESTATUS);\n\t*bp++ = htonl(vp->fid.vid);\n\t*bp++ = htonl(vp->fid.vnode);\n\t*bp++ = htonl(vp->fid.unique);\n\n\txdr_encode_AFS_StoreStatus(&bp, op->setattr.attr);\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int afs_deliver_fs_get_volume_status(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tconst __be32 *bp;\n\tchar *p;\n\tu32 size;\n\tint ret;\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tcall->unmarshall++;\n\t\tafs_extract_to_buf(call, 12 * 4);\n\t\tfallthrough;\n\n\t\t \n\tcase 1:\n\t\t_debug(\"extract status\");\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbp = call->buffer;\n\t\txdr_decode_AFSFetchVolumeStatus(&bp, &op->volstatus.vs);\n\t\tcall->unmarshall++;\n\t\tafs_extract_to_tmp(call);\n\t\tfallthrough;\n\n\t\t \n\tcase 2:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"volname length: %u\", call->count);\n\t\tif (call->count >= AFSNAMEMAX)\n\t\t\treturn afs_protocol_error(call, afs_eproto_volname_len);\n\t\tsize = (call->count + 3) & ~3;  \n\t\tafs_extract_to_buf(call, size);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 3:\n\t\t_debug(\"extract volname\");\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tp = call->buffer;\n\t\tp[call->count] = 0;\n\t\t_debug(\"volname '%s'\", p);\n\t\tafs_extract_to_tmp(call);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 4:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"offline msg length: %u\", call->count);\n\t\tif (call->count >= AFSNAMEMAX)\n\t\t\treturn afs_protocol_error(call, afs_eproto_offline_msg_len);\n\t\tsize = (call->count + 3) & ~3;  \n\t\tafs_extract_to_buf(call, size);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 5:\n\t\t_debug(\"extract offline\");\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tp = call->buffer;\n\t\tp[call->count] = 0;\n\t\t_debug(\"offline '%s'\", p);\n\n\t\tafs_extract_to_tmp(call);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 6:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"motd length: %u\", call->count);\n\t\tif (call->count >= AFSNAMEMAX)\n\t\t\treturn afs_protocol_error(call, afs_eproto_motd_len);\n\t\tsize = (call->count + 3) & ~3;  \n\t\tafs_extract_to_buf(call, size);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 7:\n\t\t_debug(\"extract motd\");\n\t\tret = afs_extract_data(call, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tp = call->buffer;\n\t\tp[call->count] = 0;\n\t\t_debug(\"motd '%s'\", p);\n\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\tcase 8:\n\t\tbreak;\n\t}\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type afs_RXFSGetVolumeStatus = {\n\t.name\t\t= \"FS.GetVolumeStatus\",\n\t.op\t\t= afs_FS_GetVolumeStatus,\n\t.deliver\t= afs_deliver_fs_get_volume_status,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid afs_fs_get_volume_status(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSGetVolumeStatus, 2 * 4,\n\t\t\t\t   max(12 * 4, AFSOPAQUEMAX + 1));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp[0] = htonl(FSGETVOLUMESTATUS);\n\tbp[1] = htonl(vp->fid.vid);\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int afs_deliver_fs_xxxx_lock(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tconst __be32 *bp;\n\tint ret;\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tret = afs_transfer_reply(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbp = call->buffer;\n\txdr_decode_AFSVolSync(&bp, &op->volsync);\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type afs_RXFSSetLock = {\n\t.name\t\t= \"FS.SetLock\",\n\t.op\t\t= afs_FS_SetLock,\n\t.deliver\t= afs_deliver_fs_xxxx_lock,\n\t.done\t\t= afs_lock_op_done,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nstatic const struct afs_call_type afs_RXFSExtendLock = {\n\t.name\t\t= \"FS.ExtendLock\",\n\t.op\t\t= afs_FS_ExtendLock,\n\t.deliver\t= afs_deliver_fs_xxxx_lock,\n\t.done\t\t= afs_lock_op_done,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nstatic const struct afs_call_type afs_RXFSReleaseLock = {\n\t.name\t\t= \"FS.ReleaseLock\",\n\t.op\t\t= afs_FS_ReleaseLock,\n\t.deliver\t= afs_deliver_fs_xxxx_lock,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid afs_fs_set_lock(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSSetLock, 5 * 4, 6 * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(FSSETLOCK);\n\t*bp++ = htonl(vp->fid.vid);\n\t*bp++ = htonl(vp->fid.vnode);\n\t*bp++ = htonl(vp->fid.unique);\n\t*bp++ = htonl(op->lock.type);\n\n\ttrace_afs_make_fs_calli(call, &vp->fid, op->lock.type);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nvoid afs_fs_extend_lock(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSExtendLock, 4 * 4, 6 * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(FSEXTENDLOCK);\n\t*bp++ = htonl(vp->fid.vid);\n\t*bp++ = htonl(vp->fid.vnode);\n\t*bp++ = htonl(vp->fid.unique);\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nvoid afs_fs_release_lock(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSReleaseLock, 4 * 4, 6 * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(FSRELEASELOCK);\n\t*bp++ = htonl(vp->fid.vid);\n\t*bp++ = htonl(vp->fid.vnode);\n\t*bp++ = htonl(vp->fid.unique);\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int afs_deliver_fs_give_up_all_callbacks(struct afs_call *call)\n{\n\treturn afs_transfer_reply(call);\n}\n\n \nstatic const struct afs_call_type afs_RXFSGiveUpAllCallBacks = {\n\t.name\t\t= \"FS.GiveUpAllCallBacks\",\n\t.op\t\t= afs_FS_GiveUpAllCallBacks,\n\t.deliver\t= afs_deliver_fs_give_up_all_callbacks,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nint afs_fs_give_up_all_callbacks(struct afs_net *net,\n\t\t\t\t struct afs_server *server,\n\t\t\t\t struct afs_addr_cursor *ac,\n\t\t\t\t struct key *key)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(net, &afs_RXFSGiveUpAllCallBacks, 1 * 4, 0);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(FSGIVEUPALLCALLBACKS);\n\n\tcall->server = afs_use_server(server, afs_server_trace_give_up_cb);\n\tafs_make_call(ac, call, GFP_NOFS);\n\treturn afs_wait_for_call_to_complete(call, ac);\n}\n\n \nstatic int afs_deliver_fs_get_capabilities(struct afs_call *call)\n{\n\tu32 count;\n\tint ret;\n\n\t_enter(\"{%u,%zu}\", call->unmarshall, iov_iter_count(call->iter));\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tafs_extract_to_tmp(call);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 1:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcount = ntohl(call->tmp);\n\t\tcall->count = count;\n\t\tcall->count2 = count;\n\t\tif (count == 0) {\n\t\t\tcall->unmarshall = 4;\n\t\t\tcall->tmp = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tafs_extract_to_tmp(call);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\tcase 2:\n\t\tret = afs_extract_data(call, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tafs_extract_discard(call, (count - 1) * sizeof(__be32));\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 3:\n\t\tret = afs_extract_data(call, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcall->unmarshall++;\n\t\tbreak;\n\t}\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type afs_RXFSGetCapabilities = {\n\t.name\t\t= \"FS.GetCapabilities\",\n\t.op\t\t= afs_FS_GetCapabilities,\n\t.deliver\t= afs_deliver_fs_get_capabilities,\n\t.done\t\t= afs_fileserver_probe_result,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nbool afs_fs_get_capabilities(struct afs_net *net, struct afs_server *server,\n\t\t\t     struct afs_addr_cursor *ac, struct key *key)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(net, &afs_RXFSGetCapabilities, 1 * 4, 16 * 4);\n\tif (!call)\n\t\treturn false;\n\n\tcall->key = key;\n\tcall->server = afs_use_server(server, afs_server_trace_get_caps);\n\tcall->upgrade = true;\n\tcall->async = true;\n\tcall->max_lifespan = AFS_PROBE_MAX_LIFESPAN;\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(FSGETCAPABILITIES);\n\n\ttrace_afs_make_fs_call(call, NULL);\n\tafs_make_call(ac, call, GFP_NOFS);\n\tafs_put_call(call);\n\treturn true;\n}\n\n \nstatic int afs_deliver_fs_inline_bulk_status(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_status_cb *scb;\n\tconst __be32 *bp;\n\tu32 tmp;\n\tint ret;\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tafs_extract_to_tmp(call);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 1:\n\t\t_debug(\"extract status count\");\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttmp = ntohl(call->tmp);\n\t\t_debug(\"status count: %u/%u\", tmp, op->nr_files);\n\t\tif (tmp != op->nr_files)\n\t\t\treturn afs_protocol_error(call, afs_eproto_ibulkst_count);\n\n\t\tcall->count = 0;\n\t\tcall->unmarshall++;\n\tmore_counts:\n\t\tafs_extract_to_buf(call, 21 * sizeof(__be32));\n\t\tfallthrough;\n\n\tcase 2:\n\t\t_debug(\"extract status array %u\", call->count);\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tswitch (call->count) {\n\t\tcase 0:\n\t\t\tscb = &op->file[0].scb;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscb = &op->file[1].scb;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tscb = &op->more_files[call->count - 2].scb;\n\t\t\tbreak;\n\t\t}\n\n\t\tbp = call->buffer;\n\t\txdr_decode_AFSFetchStatus(&bp, call, scb);\n\n\t\tcall->count++;\n\t\tif (call->count < op->nr_files)\n\t\t\tgoto more_counts;\n\n\t\tcall->count = 0;\n\t\tcall->unmarshall++;\n\t\tafs_extract_to_tmp(call);\n\t\tfallthrough;\n\n\t\t \n\tcase 3:\n\t\t_debug(\"extract CB count\");\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttmp = ntohl(call->tmp);\n\t\t_debug(\"CB count: %u\", tmp);\n\t\tif (tmp != op->nr_files)\n\t\t\treturn afs_protocol_error(call, afs_eproto_ibulkst_cb_count);\n\t\tcall->count = 0;\n\t\tcall->unmarshall++;\n\tmore_cbs:\n\t\tafs_extract_to_buf(call, 3 * sizeof(__be32));\n\t\tfallthrough;\n\n\tcase 4:\n\t\t_debug(\"extract CB array\");\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t_debug(\"unmarshall CB array\");\n\t\tswitch (call->count) {\n\t\tcase 0:\n\t\t\tscb = &op->file[0].scb;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscb = &op->file[1].scb;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tscb = &op->more_files[call->count - 2].scb;\n\t\t\tbreak;\n\t\t}\n\n\t\tbp = call->buffer;\n\t\txdr_decode_AFSCallBack(&bp, call, scb);\n\t\tcall->count++;\n\t\tif (call->count < op->nr_files)\n\t\t\tgoto more_cbs;\n\n\t\tafs_extract_to_buf(call, 6 * sizeof(__be32));\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\tcase 5:\n\t\tret = afs_extract_data(call, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbp = call->buffer;\n\t\txdr_decode_AFSVolSync(&bp, &op->volsync);\n\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\tcase 6:\n\t\tbreak;\n\t}\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\nstatic void afs_done_fs_inline_bulk_status(struct afs_call *call)\n{\n\tif (call->error == -ECONNABORTED &&\n\t    call->abort_code == RX_INVALID_OPERATION) {\n\t\tset_bit(AFS_SERVER_FL_NO_IBULK, &call->server->flags);\n\t\tif (call->op)\n\t\t\tset_bit(AFS_VOLUME_MAYBE_NO_IBULK, &call->op->volume->flags);\n\t}\n}\n\n \nstatic const struct afs_call_type afs_RXFSInlineBulkStatus = {\n\t.name\t\t= \"FS.InlineBulkStatus\",\n\t.op\t\t= afs_FS_InlineBulkStatus,\n\t.deliver\t= afs_deliver_fs_inline_bulk_status,\n\t.done\t\t= afs_done_fs_inline_bulk_status,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid afs_fs_inline_bulk_status(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_vnode_param *vp = &op->file[1];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\tint i;\n\n\tif (test_bit(AFS_SERVER_FL_NO_IBULK, &op->server->flags)) {\n\t\top->error = -ENOTSUPP;\n\t\treturn;\n\t}\n\n\t_enter(\",%x,{%llx:%llu},%u\",\n\t       key_serial(op->key), vp->fid.vid, vp->fid.vnode, op->nr_files);\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSInlineBulkStatus,\n\t\t\t\t   (2 + op->nr_files * 3) * 4,\n\t\t\t\t   21 * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(FSINLINEBULKSTATUS);\n\t*bp++ = htonl(op->nr_files);\n\t*bp++ = htonl(dvp->fid.vid);\n\t*bp++ = htonl(dvp->fid.vnode);\n\t*bp++ = htonl(dvp->fid.unique);\n\t*bp++ = htonl(vp->fid.vid);\n\t*bp++ = htonl(vp->fid.vnode);\n\t*bp++ = htonl(vp->fid.unique);\n\tfor (i = 0; i < op->nr_files - 2; i++) {\n\t\t*bp++ = htonl(op->more_files[i].fid.vid);\n\t\t*bp++ = htonl(op->more_files[i].fid.vnode);\n\t\t*bp++ = htonl(op->more_files[i].fid.unique);\n\t}\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int afs_deliver_fs_fetch_acl(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_acl *acl;\n\tconst __be32 *bp;\n\tunsigned int size;\n\tint ret;\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tafs_extract_to_tmp(call);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 1:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tsize = call->count2 = ntohl(call->tmp);\n\t\tsize = round_up(size, 4);\n\n\t\tacl = kmalloc(struct_size(acl, data, size), GFP_KERNEL);\n\t\tif (!acl)\n\t\t\treturn -ENOMEM;\n\t\top->acl = acl;\n\t\tacl->size = call->count2;\n\t\tafs_extract_begin(call, acl->data, size);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 2:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tafs_extract_to_buf(call, (21 + 6) * 4);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 3:\n\t\tret = afs_extract_data(call, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbp = call->buffer;\n\t\txdr_decode_AFSFetchStatus(&bp, call, &vp->scb);\n\t\txdr_decode_AFSVolSync(&bp, &op->volsync);\n\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\tcase 4:\n\t\tbreak;\n\t}\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type afs_RXFSFetchACL = {\n\t.name\t\t= \"FS.FetchACL\",\n\t.op\t\t= afs_FS_FetchACL,\n\t.deliver\t= afs_deliver_fs_fetch_acl,\n};\n\n \nvoid afs_fs_fetch_acl(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%llx:%llu},,\",\n\t       key_serial(op->key), vp->fid.vid, vp->fid.vnode);\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSFetchACL, 16, (21 + 6) * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp[0] = htonl(FSFETCHACL);\n\tbp[1] = htonl(vp->fid.vid);\n\tbp[2] = htonl(vp->fid.vnode);\n\tbp[3] = htonl(vp->fid.unique);\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_KERNEL);\n}\n\n \nstatic const struct afs_call_type afs_RXFSStoreACL = {\n\t.name\t\t= \"FS.StoreACL\",\n\t.op\t\t= afs_FS_StoreACL,\n\t.deliver\t= afs_deliver_fs_file_status_and_vol,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid afs_fs_store_acl(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\tconst struct afs_acl *acl = op->acl;\n\tsize_t size;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%llx:%llu},,\",\n\t       key_serial(op->key), vp->fid.vid, vp->fid.vnode);\n\n\tsize = round_up(acl->size, 4);\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSStoreACL,\n\t\t\t\t   5 * 4 + size, (21 + 6) * 4);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp[0] = htonl(FSSTOREACL);\n\tbp[1] = htonl(vp->fid.vid);\n\tbp[2] = htonl(vp->fid.vnode);\n\tbp[3] = htonl(vp->fid.unique);\n\tbp[4] = htonl(acl->size);\n\tmemcpy(&bp[5], acl->data, acl->size);\n\tif (acl->size != size)\n\t\tmemset((void *)&bp[5] + acl->size, 0, size - acl->size);\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_KERNEL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}