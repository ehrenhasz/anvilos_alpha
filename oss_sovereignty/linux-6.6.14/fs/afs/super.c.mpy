{
  "module_name": "super.c",
  "hash_id": "55a311a2058c30225278b2af998ee792a9f80aa7a6dd59dc8301bde2e1c4abf4",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/super.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs_parser.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/nsproxy.h>\n#include <linux/magic.h>\n#include <net/net_namespace.h>\n#include \"internal.h\"\n\nstatic void afs_i_init_once(void *foo);\nstatic void afs_kill_super(struct super_block *sb);\nstatic struct inode *afs_alloc_inode(struct super_block *sb);\nstatic void afs_destroy_inode(struct inode *inode);\nstatic void afs_free_inode(struct inode *inode);\nstatic int afs_statfs(struct dentry *dentry, struct kstatfs *buf);\nstatic int afs_show_devname(struct seq_file *m, struct dentry *root);\nstatic int afs_show_options(struct seq_file *m, struct dentry *root);\nstatic int afs_init_fs_context(struct fs_context *fc);\nstatic const struct fs_parameter_spec afs_fs_parameters[];\n\nstruct file_system_type afs_fs_type = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"afs\",\n\t.init_fs_context\t= afs_init_fs_context,\n\t.parameters\t\t= afs_fs_parameters,\n\t.kill_sb\t\t= afs_kill_super,\n\t.fs_flags\t\t= FS_RENAME_DOES_D_MOVE,\n};\nMODULE_ALIAS_FS(\"afs\");\n\nint afs_net_id;\n\nstatic const struct super_operations afs_super_ops = {\n\t.statfs\t\t= afs_statfs,\n\t.alloc_inode\t= afs_alloc_inode,\n\t.write_inode\t= afs_write_inode,\n\t.drop_inode\t= afs_drop_inode,\n\t.destroy_inode\t= afs_destroy_inode,\n\t.free_inode\t= afs_free_inode,\n\t.evict_inode\t= afs_evict_inode,\n\t.show_devname\t= afs_show_devname,\n\t.show_options\t= afs_show_options,\n};\n\nstatic struct kmem_cache *afs_inode_cachep;\nstatic atomic_t afs_count_active_inodes;\n\nenum afs_param {\n\tOpt_autocell,\n\tOpt_dyn,\n\tOpt_flock,\n\tOpt_source,\n};\n\nstatic const struct constant_table afs_param_flock[] = {\n\t{\"local\",\tafs_flock_mode_local },\n\t{\"openafs\",\tafs_flock_mode_openafs },\n\t{\"strict\",\tafs_flock_mode_strict },\n\t{\"write\",\tafs_flock_mode_write },\n\t{}\n};\n\nstatic const struct fs_parameter_spec afs_fs_parameters[] = {\n\tfsparam_flag  (\"autocell\",\tOpt_autocell),\n\tfsparam_flag  (\"dyn\",\t\tOpt_dyn),\n\tfsparam_enum  (\"flock\",\t\tOpt_flock, afs_param_flock),\n\tfsparam_string(\"source\",\tOpt_source),\n\t{}\n};\n\n \nint __init afs_fs_init(void)\n{\n\tint ret;\n\n\t_enter(\"\");\n\n\t \n\tatomic_set(&afs_count_active_inodes, 0);\n\n\tret = -ENOMEM;\n\tafs_inode_cachep = kmem_cache_create(\"afs_inode_cache\",\n\t\t\t\t\t     sizeof(struct afs_vnode),\n\t\t\t\t\t     0,\n\t\t\t\t\t     SLAB_HWCACHE_ALIGN|SLAB_ACCOUNT,\n\t\t\t\t\t     afs_i_init_once);\n\tif (!afs_inode_cachep) {\n\t\tprintk(KERN_NOTICE \"kAFS: Failed to allocate inode cache\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = register_filesystem(&afs_fs_type);\n\tif (ret < 0) {\n\t\tkmem_cache_destroy(afs_inode_cachep);\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n}\n\n \nvoid afs_fs_exit(void)\n{\n\t_enter(\"\");\n\n\tafs_mntpt_kill_timer();\n\tunregister_filesystem(&afs_fs_type);\n\n\tif (atomic_read(&afs_count_active_inodes) != 0) {\n\t\tprintk(\"kAFS: %d active inode objects still present\\n\",\n\t\t       atomic_read(&afs_count_active_inodes));\n\t\tBUG();\n\t}\n\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(afs_inode_cachep);\n\t_leave(\"\");\n}\n\n \nstatic int afs_show_devname(struct seq_file *m, struct dentry *root)\n{\n\tstruct afs_super_info *as = AFS_FS_S(root->d_sb);\n\tstruct afs_volume *volume = as->volume;\n\tstruct afs_cell *cell = as->cell;\n\tconst char *suf = \"\";\n\tchar pref = '%';\n\n\tif (as->dyn_root) {\n\t\tseq_puts(m, \"none\");\n\t\treturn 0;\n\t}\n\n\tswitch (volume->type) {\n\tcase AFSVL_RWVOL:\n\t\tbreak;\n\tcase AFSVL_ROVOL:\n\t\tpref = '#';\n\t\tif (volume->type_force)\n\t\t\tsuf = \".readonly\";\n\t\tbreak;\n\tcase AFSVL_BACKVOL:\n\t\tpref = '#';\n\t\tsuf = \".backup\";\n\t\tbreak;\n\t}\n\n\tseq_printf(m, \"%c%s:%s%s\", pref, cell->name, volume->name, suf);\n\treturn 0;\n}\n\n \nstatic int afs_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct afs_super_info *as = AFS_FS_S(root->d_sb);\n\tconst char *p = NULL;\n\n\tif (as->dyn_root)\n\t\tseq_puts(m, \",dyn\");\n\tif (test_bit(AFS_VNODE_AUTOCELL, &AFS_FS_I(d_inode(root))->flags))\n\t\tseq_puts(m, \",autocell\");\n\tswitch (as->flock_mode) {\n\tcase afs_flock_mode_unset:\tbreak;\n\tcase afs_flock_mode_local:\tp = \"local\";\tbreak;\n\tcase afs_flock_mode_openafs:\tp = \"openafs\";\tbreak;\n\tcase afs_flock_mode_strict:\tp = \"strict\";\tbreak;\n\tcase afs_flock_mode_write:\tp = \"write\";\tbreak;\n\t}\n\tif (p)\n\t\tseq_printf(m, \",flock=%s\", p);\n\n\treturn 0;\n}\n\n \nstatic int afs_parse_source(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct afs_fs_context *ctx = fc->fs_private;\n\tstruct afs_cell *cell;\n\tconst char *cellname, *suffix, *name = param->string;\n\tint cellnamesz;\n\n\t_enter(\",%s\", name);\n\n\tif (fc->source)\n\t\treturn invalf(fc, \"kAFS: Multiple sources not supported\");\n\n\tif (!name) {\n\t\tprintk(KERN_ERR \"kAFS: no volume name specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((name[0] != '%' && name[0] != '#') || !name[1]) {\n\t\t \n\t\tif (strcmp(name, \"none\") == 0) {\n\t\t\tctx->no_cell = true;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(KERN_ERR \"kAFS: unparsable volume name\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (name[0] == '%') {\n\t\tctx->type = AFSVL_RWVOL;\n\t\tctx->force = true;\n\t}\n\tname++;\n\n\t \n\tctx->volname = strchr(name, ':');\n\tif (ctx->volname) {\n\t\tcellname = name;\n\t\tcellnamesz = ctx->volname - name;\n\t\tctx->volname++;\n\t} else {\n\t\tctx->volname = name;\n\t\tcellname = NULL;\n\t\tcellnamesz = 0;\n\t}\n\n\t \n\tsuffix = strrchr(ctx->volname, '.');\n\tif (suffix) {\n\t\tif (strcmp(suffix, \".readonly\") == 0) {\n\t\t\tctx->type = AFSVL_ROVOL;\n\t\t\tctx->force = true;\n\t\t} else if (strcmp(suffix, \".backup\") == 0) {\n\t\t\tctx->type = AFSVL_BACKVOL;\n\t\t\tctx->force = true;\n\t\t} else if (suffix[1] == 0) {\n\t\t} else {\n\t\t\tsuffix = NULL;\n\t\t}\n\t}\n\n\tctx->volnamesz = suffix ?\n\t\tsuffix - ctx->volname : strlen(ctx->volname);\n\n\t_debug(\"cell %*.*s [%p]\",\n\t       cellnamesz, cellnamesz, cellname ?: \"\", ctx->cell);\n\n\t \n\tif (cellname) {\n\t\tcell = afs_lookup_cell(ctx->net, cellname, cellnamesz,\n\t\t\t\t       NULL, false);\n\t\tif (IS_ERR(cell)) {\n\t\t\tpr_err(\"kAFS: unable to lookup cell '%*.*s'\\n\",\n\t\t\t       cellnamesz, cellnamesz, cellname ?: \"\");\n\t\t\treturn PTR_ERR(cell);\n\t\t}\n\t\tafs_unuse_cell(ctx->net, ctx->cell, afs_cell_trace_unuse_parse);\n\t\tafs_see_cell(cell, afs_cell_trace_see_source);\n\t\tctx->cell = cell;\n\t}\n\n\t_debug(\"CELL:%s [%p] VOLUME:%*.*s SUFFIX:%s TYPE:%d%s\",\n\t       ctx->cell->name, ctx->cell,\n\t       ctx->volnamesz, ctx->volnamesz, ctx->volname,\n\t       suffix ?: \"-\", ctx->type, ctx->force ? \" FORCE\" : \"\");\n\n\tfc->source = param->string;\n\tparam->string = NULL;\n\treturn 0;\n}\n\n \nstatic int afs_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct fs_parse_result result;\n\tstruct afs_fs_context *ctx = fc->fs_private;\n\tint opt;\n\n\topt = fs_parse(fc, afs_fs_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_source:\n\t\treturn afs_parse_source(fc, param);\n\n\tcase Opt_autocell:\n\t\tctx->autocell = true;\n\t\tbreak;\n\n\tcase Opt_dyn:\n\t\tctx->dyn_root = true;\n\t\tbreak;\n\n\tcase Opt_flock:\n\t\tctx->flock_mode = result.uint_32;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n}\n\n \nstatic int afs_validate_fc(struct fs_context *fc)\n{\n\tstruct afs_fs_context *ctx = fc->fs_private;\n\tstruct afs_volume *volume;\n\tstruct afs_cell *cell;\n\tstruct key *key;\n\tint ret;\n\n\tif (!ctx->dyn_root) {\n\t\tif (ctx->no_cell) {\n\t\t\tpr_warn(\"kAFS: Can only specify source 'none' with -o dyn\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!ctx->cell) {\n\t\t\tpr_warn(\"kAFS: No cell specified\\n\");\n\t\t\treturn -EDESTADDRREQ;\n\t\t}\n\n\treget_key:\n\t\t \n\t\tkey = afs_request_key(ctx->cell);\n\t\tif (IS_ERR(key))\n\t\t\treturn PTR_ERR(key);\n\n\t\tctx->key = key;\n\n\t\tif (ctx->volume) {\n\t\t\tafs_put_volume(ctx->net, ctx->volume,\n\t\t\t\t       afs_volume_trace_put_validate_fc);\n\t\t\tctx->volume = NULL;\n\t\t}\n\n\t\tif (test_bit(AFS_CELL_FL_CHECK_ALIAS, &ctx->cell->flags)) {\n\t\t\tret = afs_cell_detect_alias(ctx->cell, key);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 1) {\n\t\t\t\t_debug(\"switch to alias\");\n\t\t\t\tkey_put(ctx->key);\n\t\t\t\tctx->key = NULL;\n\t\t\t\tcell = afs_use_cell(ctx->cell->alias_of,\n\t\t\t\t\t\t    afs_cell_trace_use_fc_alias);\n\t\t\t\tafs_unuse_cell(ctx->net, ctx->cell, afs_cell_trace_unuse_fc);\n\t\t\t\tctx->cell = cell;\n\t\t\t\tgoto reget_key;\n\t\t\t}\n\t\t}\n\n\t\tvolume = afs_create_volume(ctx);\n\t\tif (IS_ERR(volume))\n\t\t\treturn PTR_ERR(volume);\n\n\t\tctx->volume = volume;\n\t\tif (volume->type != AFSVL_RWVOL)\n\t\t\tctx->flock_mode = afs_flock_mode_local;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int afs_test_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct afs_fs_context *ctx = fc->fs_private;\n\tstruct afs_super_info *as = AFS_FS_S(sb);\n\n\treturn (as->net_ns == fc->net_ns &&\n\t\tas->volume &&\n\t\tas->volume->vid == ctx->volume->vid &&\n\t\tas->cell == ctx->cell &&\n\t\t!as->dyn_root);\n}\n\nstatic int afs_dynroot_test_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct afs_super_info *as = AFS_FS_S(sb);\n\n\treturn (as->net_ns == fc->net_ns &&\n\t\tas->dyn_root);\n}\n\nstatic int afs_set_super(struct super_block *sb, struct fs_context *fc)\n{\n\treturn set_anon_super(sb, NULL);\n}\n\n \nstatic int afs_fill_super(struct super_block *sb, struct afs_fs_context *ctx)\n{\n\tstruct afs_super_info *as = AFS_FS_S(sb);\n\tstruct inode *inode = NULL;\n\tint ret;\n\n\t_enter(\"\");\n\n\t \n\tsb->s_blocksize\t\t= PAGE_SIZE;\n\tsb->s_blocksize_bits\t= PAGE_SHIFT;\n\tsb->s_maxbytes\t\t= MAX_LFS_FILESIZE;\n\tsb->s_magic\t\t= AFS_FS_MAGIC;\n\tsb->s_op\t\t= &afs_super_ops;\n\tif (!as->dyn_root)\n\t\tsb->s_xattr\t= afs_xattr_handlers;\n\tret = super_setup_bdi(sb);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (as->dyn_root) {\n\t\tinode = afs_iget_pseudo_dir(sb, true);\n\t} else {\n\t\tsprintf(sb->s_id, \"%llu\", as->volume->vid);\n\t\tafs_activate_volume(as->volume);\n\t\tinode = afs_root_iget(sb, ctx->key);\n\t}\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (ctx->autocell || as->dyn_root)\n\t\tset_bit(AFS_VNODE_AUTOCELL, &AFS_FS_I(inode)->flags);\n\n\tret = -ENOMEM;\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\tgoto error;\n\n\tif (as->dyn_root) {\n\t\tsb->s_d_op = &afs_dynroot_dentry_operations;\n\t\tret = afs_dynroot_populate(sb);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t} else {\n\t\tsb->s_d_op = &afs_fs_dentry_operations;\n\t\trcu_assign_pointer(as->volume->sb, sb);\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\nstatic struct afs_super_info *afs_alloc_sbi(struct fs_context *fc)\n{\n\tstruct afs_fs_context *ctx = fc->fs_private;\n\tstruct afs_super_info *as;\n\n\tas = kzalloc(sizeof(struct afs_super_info), GFP_KERNEL);\n\tif (as) {\n\t\tas->net_ns = get_net(fc->net_ns);\n\t\tas->flock_mode = ctx->flock_mode;\n\t\tif (ctx->dyn_root) {\n\t\t\tas->dyn_root = true;\n\t\t} else {\n\t\t\tas->cell = afs_use_cell(ctx->cell, afs_cell_trace_use_sbi);\n\t\t\tas->volume = afs_get_volume(ctx->volume,\n\t\t\t\t\t\t    afs_volume_trace_get_alloc_sbi);\n\t\t}\n\t}\n\treturn as;\n}\n\nstatic void afs_destroy_sbi(struct afs_super_info *as)\n{\n\tif (as) {\n\t\tstruct afs_net *net = afs_net(as->net_ns);\n\t\tafs_put_volume(net, as->volume, afs_volume_trace_put_destroy_sbi);\n\t\tafs_unuse_cell(net, as->cell, afs_cell_trace_unuse_sbi);\n\t\tput_net(as->net_ns);\n\t\tkfree(as);\n\t}\n}\n\nstatic void afs_kill_super(struct super_block *sb)\n{\n\tstruct afs_super_info *as = AFS_FS_S(sb);\n\n\tif (as->dyn_root)\n\t\tafs_dynroot_depopulate(sb);\n\n\t \n\tif (as->volume)\n\t\trcu_assign_pointer(as->volume->sb, NULL);\n\tkill_anon_super(sb);\n\tif (as->volume)\n\t\tafs_deactivate_volume(as->volume);\n\tafs_destroy_sbi(as);\n}\n\n \nstatic int afs_get_tree(struct fs_context *fc)\n{\n\tstruct afs_fs_context *ctx = fc->fs_private;\n\tstruct super_block *sb;\n\tstruct afs_super_info *as;\n\tint ret;\n\n\tret = afs_validate_fc(fc);\n\tif (ret)\n\t\tgoto error;\n\n\t_enter(\"\");\n\n\t \n\tret = -ENOMEM;\n\tas = afs_alloc_sbi(fc);\n\tif (!as)\n\t\tgoto error;\n\tfc->s_fs_info = as;\n\n\t \n\tsb = sget_fc(fc,\n\t\t     as->dyn_root ? afs_dynroot_test_super : afs_test_super,\n\t\t     afs_set_super);\n\tif (IS_ERR(sb)) {\n\t\tret = PTR_ERR(sb);\n\t\tgoto error;\n\t}\n\n\tif (!sb->s_root) {\n\t\t \n\t\t_debug(\"create\");\n\t\tret = afs_fill_super(sb, ctx);\n\t\tif (ret < 0)\n\t\t\tgoto error_sb;\n\t\tsb->s_flags |= SB_ACTIVE;\n\t} else {\n\t\t_debug(\"reuse\");\n\t\tASSERTCMP(sb->s_flags, &, SB_ACTIVE);\n\t}\n\n\tfc->root = dget(sb->s_root);\n\ttrace_afs_get_tree(as->cell, as->volume);\n\t_leave(\" = 0 [%p]\", sb);\n\treturn 0;\n\nerror_sb:\n\tdeactivate_locked_super(sb);\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\nstatic void afs_free_fc(struct fs_context *fc)\n{\n\tstruct afs_fs_context *ctx = fc->fs_private;\n\n\tafs_destroy_sbi(fc->s_fs_info);\n\tafs_put_volume(ctx->net, ctx->volume, afs_volume_trace_put_free_fc);\n\tafs_unuse_cell(ctx->net, ctx->cell, afs_cell_trace_unuse_fc);\n\tkey_put(ctx->key);\n\tkfree(ctx);\n}\n\nstatic const struct fs_context_operations afs_context_ops = {\n\t.free\t\t= afs_free_fc,\n\t.parse_param\t= afs_parse_param,\n\t.get_tree\t= afs_get_tree,\n};\n\n \nstatic int afs_init_fs_context(struct fs_context *fc)\n{\n\tstruct afs_fs_context *ctx;\n\tstruct afs_cell *cell;\n\n\tctx = kzalloc(sizeof(struct afs_fs_context), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->type = AFSVL_ROVOL;\n\tctx->net = afs_net(fc->net_ns);\n\n\t \n\tcell = afs_find_cell(ctx->net, NULL, 0, afs_cell_trace_use_fc);\n\tif (IS_ERR(cell))\n\t\tcell = NULL;\n\tctx->cell = cell;\n\n\tfc->fs_private = ctx;\n\tfc->ops = &afs_context_ops;\n\treturn 0;\n}\n\n \nstatic void afs_i_init_once(void *_vnode)\n{\n\tstruct afs_vnode *vnode = _vnode;\n\n\tmemset(vnode, 0, sizeof(*vnode));\n\tinode_init_once(&vnode->netfs.inode);\n\tmutex_init(&vnode->io_lock);\n\tinit_rwsem(&vnode->validate_lock);\n\tspin_lock_init(&vnode->wb_lock);\n\tspin_lock_init(&vnode->lock);\n\tINIT_LIST_HEAD(&vnode->wb_keys);\n\tINIT_LIST_HEAD(&vnode->pending_locks);\n\tINIT_LIST_HEAD(&vnode->granted_locks);\n\tINIT_DELAYED_WORK(&vnode->lock_work, afs_lock_work);\n\tINIT_LIST_HEAD(&vnode->cb_mmap_link);\n\tseqlock_init(&vnode->cb_lock);\n}\n\n \nstatic struct inode *afs_alloc_inode(struct super_block *sb)\n{\n\tstruct afs_vnode *vnode;\n\n\tvnode = alloc_inode_sb(sb, afs_inode_cachep, GFP_KERNEL);\n\tif (!vnode)\n\t\treturn NULL;\n\n\tatomic_inc(&afs_count_active_inodes);\n\n\t \n\tmemset(&vnode->fid, 0, sizeof(vnode->fid));\n\tmemset(&vnode->status, 0, sizeof(vnode->status));\n\tafs_vnode_set_cache(vnode, NULL);\n\n\tvnode->volume\t\t= NULL;\n\tvnode->lock_key\t\t= NULL;\n\tvnode->permit_cache\t= NULL;\n\n\tvnode->flags\t\t= 1 << AFS_VNODE_UNSET;\n\tvnode->lock_state\t= AFS_VNODE_LOCK_NONE;\n\n\tinit_rwsem(&vnode->rmdir_lock);\n\tINIT_WORK(&vnode->cb_work, afs_invalidate_mmap_work);\n\n\t_leave(\" = %p\", &vnode->netfs.inode);\n\treturn &vnode->netfs.inode;\n}\n\nstatic void afs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(afs_inode_cachep, AFS_FS_I(inode));\n}\n\n \nstatic void afs_destroy_inode(struct inode *inode)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\n\t_enter(\"%p{%llx:%llu}\", inode, vnode->fid.vid, vnode->fid.vnode);\n\n\t_debug(\"DESTROY INODE %p\", inode);\n\n\tatomic_dec(&afs_count_active_inodes);\n}\n\nstatic void afs_get_volume_status_success(struct afs_operation *op)\n{\n\tstruct afs_volume_status *vs = &op->volstatus.vs;\n\tstruct kstatfs *buf = op->volstatus.buf;\n\n\tif (vs->max_quota == 0)\n\t\tbuf->f_blocks = vs->part_max_blocks;\n\telse\n\t\tbuf->f_blocks = vs->max_quota;\n\n\tif (buf->f_blocks > vs->blocks_in_use)\n\t\tbuf->f_bavail = buf->f_bfree =\n\t\t\tbuf->f_blocks - vs->blocks_in_use;\n}\n\nstatic const struct afs_operation_ops afs_get_volume_status_operation = {\n\t.issue_afs_rpc\t= afs_fs_get_volume_status,\n\t.issue_yfs_rpc\t= yfs_fs_get_volume_status,\n\t.success\t= afs_get_volume_status_success,\n};\n\n \nstatic int afs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct afs_super_info *as = AFS_FS_S(dentry->d_sb);\n\tstruct afs_operation *op;\n\tstruct afs_vnode *vnode = AFS_FS_I(d_inode(dentry));\n\n\tbuf->f_type\t= dentry->d_sb->s_magic;\n\tbuf->f_bsize\t= AFS_BLOCK_SIZE;\n\tbuf->f_namelen\t= AFSNAMEMAX - 1;\n\n\tif (as->dyn_root) {\n\t\tbuf->f_blocks\t= 1;\n\t\tbuf->f_bavail\t= 0;\n\t\tbuf->f_bfree\t= 0;\n\t\treturn 0;\n\t}\n\n\top = afs_alloc_operation(NULL, as->volume);\n\tif (IS_ERR(op))\n\t\treturn PTR_ERR(op);\n\n\tafs_op_set_vnode(op, 0, vnode);\n\top->nr_files\t\t= 1;\n\top->volstatus.buf\t= buf;\n\top->ops\t\t\t= &afs_get_volume_status_operation;\n\treturn afs_do_sync_operation(op);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}