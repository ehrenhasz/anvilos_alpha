{
  "module_name": "rxrpc.c",
  "hash_id": "62a5be644dd572fd7096ce6524f643154d5aa67f66698e857289482af66a2446",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/rxrpc.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n#include \"internal.h\"\n#include \"afs_cm.h\"\n#include \"protocol_yfs.h\"\n#define RXRPC_TRACE_ONLY_DEFINE_ENUMS\n#include <trace/events/rxrpc.h>\n\nstruct workqueue_struct *afs_async_calls;\n\nstatic void afs_wake_up_call_waiter(struct sock *, struct rxrpc_call *, unsigned long);\nstatic void afs_wake_up_async_call(struct sock *, struct rxrpc_call *, unsigned long);\nstatic void afs_process_async_call(struct work_struct *);\nstatic void afs_rx_new_call(struct sock *, struct rxrpc_call *, unsigned long);\nstatic void afs_rx_discard_new_call(struct rxrpc_call *, unsigned long);\nstatic int afs_deliver_cm_op_id(struct afs_call *);\n\n \nstatic const struct afs_call_type afs_RXCMxxxx = {\n\t.name\t\t= \"CB.xxxx\",\n\t.deliver\t= afs_deliver_cm_op_id,\n};\n\n \nint afs_open_socket(struct afs_net *net)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct socket *socket;\n\tint ret;\n\n\t_enter(\"\");\n\n\tret = sock_create_kern(net->net, AF_RXRPC, SOCK_DGRAM, PF_INET6, &socket);\n\tif (ret < 0)\n\t\tgoto error_1;\n\n\tsocket->sk->sk_allocation = GFP_NOFS;\n\n\t \n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family\t\t\t= AF_RXRPC;\n\tsrx.srx_service\t\t\t= CM_SERVICE;\n\tsrx.transport_type\t\t= SOCK_DGRAM;\n\tsrx.transport_len\t\t= sizeof(srx.transport.sin6);\n\tsrx.transport.sin6.sin6_family\t= AF_INET6;\n\tsrx.transport.sin6.sin6_port\t= htons(AFS_CM_PORT);\n\n\tret = rxrpc_sock_set_min_security_level(socket->sk,\n\t\t\t\t\t\tRXRPC_SECURITY_ENCRYPT);\n\tif (ret < 0)\n\t\tgoto error_2;\n\n\tret = kernel_bind(socket, (struct sockaddr *) &srx, sizeof(srx));\n\tif (ret == -EADDRINUSE) {\n\t\tsrx.transport.sin6.sin6_port = 0;\n\t\tret = kernel_bind(socket, (struct sockaddr *) &srx, sizeof(srx));\n\t}\n\tif (ret < 0)\n\t\tgoto error_2;\n\n\tsrx.srx_service = YFS_CM_SERVICE;\n\tret = kernel_bind(socket, (struct sockaddr *) &srx, sizeof(srx));\n\tif (ret < 0)\n\t\tgoto error_2;\n\n\t \n\n\trxrpc_kernel_new_call_notification(socket, afs_rx_new_call,\n\t\t\t\t\t   afs_rx_discard_new_call);\n\n\tret = kernel_listen(socket, INT_MAX);\n\tif (ret < 0)\n\t\tgoto error_2;\n\n\tnet->socket = socket;\n\tafs_charge_preallocation(&net->charge_preallocation_work);\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_2:\n\tsock_release(socket);\nerror_1:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nvoid afs_close_socket(struct afs_net *net)\n{\n\t_enter(\"\");\n\n\tkernel_listen(net->socket, 0);\n\tflush_workqueue(afs_async_calls);\n\n\tif (net->spare_incoming_call) {\n\t\tafs_put_call(net->spare_incoming_call);\n\t\tnet->spare_incoming_call = NULL;\n\t}\n\n\t_debug(\"outstanding %u\", atomic_read(&net->nr_outstanding_calls));\n\twait_var_event(&net->nr_outstanding_calls,\n\t\t       !atomic_read(&net->nr_outstanding_calls));\n\t_debug(\"no outstanding calls\");\n\n\tkernel_sock_shutdown(net->socket, SHUT_RDWR);\n\tflush_workqueue(afs_async_calls);\n\tsock_release(net->socket);\n\n\t_debug(\"dework\");\n\t_leave(\"\");\n}\n\n \nstatic struct afs_call *afs_alloc_call(struct afs_net *net,\n\t\t\t\t       const struct afs_call_type *type,\n\t\t\t\t       gfp_t gfp)\n{\n\tstruct afs_call *call;\n\tint o;\n\n\tcall = kzalloc(sizeof(*call), gfp);\n\tif (!call)\n\t\treturn NULL;\n\n\tcall->type = type;\n\tcall->net = net;\n\tcall->debug_id = atomic_inc_return(&rxrpc_debug_id);\n\trefcount_set(&call->ref, 1);\n\tINIT_WORK(&call->async_work, afs_process_async_call);\n\tinit_waitqueue_head(&call->waitq);\n\tspin_lock_init(&call->state_lock);\n\tcall->iter = &call->def_iter;\n\n\to = atomic_inc_return(&net->nr_outstanding_calls);\n\ttrace_afs_call(call->debug_id, afs_call_trace_alloc, 1, o,\n\t\t       __builtin_return_address(0));\n\treturn call;\n}\n\n \nvoid afs_put_call(struct afs_call *call)\n{\n\tstruct afs_net *net = call->net;\n\tunsigned int debug_id = call->debug_id;\n\tbool zero;\n\tint r, o;\n\n\tzero = __refcount_dec_and_test(&call->ref, &r);\n\to = atomic_read(&net->nr_outstanding_calls);\n\ttrace_afs_call(debug_id, afs_call_trace_put, r - 1, o,\n\t\t       __builtin_return_address(0));\n\n\tif (zero) {\n\t\tASSERT(!work_pending(&call->async_work));\n\t\tASSERT(call->type->name != NULL);\n\n\t\tif (call->rxcall) {\n\t\t\trxrpc_kernel_shutdown_call(net->socket, call->rxcall);\n\t\t\trxrpc_kernel_put_call(net->socket, call->rxcall);\n\t\t\tcall->rxcall = NULL;\n\t\t}\n\t\tif (call->type->destructor)\n\t\t\tcall->type->destructor(call);\n\n\t\tafs_unuse_server_notime(call->net, call->server, afs_server_trace_put_call);\n\t\tafs_put_addrlist(call->alist);\n\t\tkfree(call->request);\n\n\t\ttrace_afs_call(call->debug_id, afs_call_trace_free, 0, o,\n\t\t\t       __builtin_return_address(0));\n\t\tkfree(call);\n\n\t\to = atomic_dec_return(&net->nr_outstanding_calls);\n\t\tif (o == 0)\n\t\t\twake_up_var(&net->nr_outstanding_calls);\n\t}\n}\n\nstatic struct afs_call *afs_get_call(struct afs_call *call,\n\t\t\t\t     enum afs_call_trace why)\n{\n\tint r;\n\n\t__refcount_inc(&call->ref, &r);\n\n\ttrace_afs_call(call->debug_id, why, r + 1,\n\t\t       atomic_read(&call->net->nr_outstanding_calls),\n\t\t       __builtin_return_address(0));\n\treturn call;\n}\n\n \nstatic void afs_queue_call_work(struct afs_call *call)\n{\n\tif (call->type->work) {\n\t\tINIT_WORK(&call->work, call->type->work);\n\n\t\tafs_get_call(call, afs_call_trace_work);\n\t\tif (!queue_work(afs_wq, &call->work))\n\t\t\tafs_put_call(call);\n\t}\n}\n\n \nstruct afs_call *afs_alloc_flat_call(struct afs_net *net,\n\t\t\t\t     const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_max)\n{\n\tstruct afs_call *call;\n\n\tcall = afs_alloc_call(net, type, GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\tif (request_size) {\n\t\tcall->request_size = request_size;\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_max) {\n\t\tcall->reply_max = reply_max;\n\t\tcall->buffer = kmalloc(reply_max, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tafs_extract_to_buf(call, call->reply_max);\n\tcall->operation_ID = type->op;\n\tinit_waitqueue_head(&call->waitq);\n\treturn call;\n\nnomem_free:\n\tafs_put_call(call);\nnomem_call:\n\treturn NULL;\n}\n\n \nvoid afs_flat_call_destructor(struct afs_call *call)\n{\n\t_enter(\"\");\n\n\tkfree(call->request);\n\tcall->request = NULL;\n\tkfree(call->buffer);\n\tcall->buffer = NULL;\n}\n\n \nstatic void afs_notify_end_request_tx(struct sock *sock,\n\t\t\t\t      struct rxrpc_call *rxcall,\n\t\t\t\t      unsigned long call_user_ID)\n{\n\tstruct afs_call *call = (struct afs_call *)call_user_ID;\n\n\tafs_set_call_state(call, AFS_CALL_CL_REQUESTING, AFS_CALL_CL_AWAIT_REPLY);\n}\n\n \nvoid afs_make_call(struct afs_addr_cursor *ac, struct afs_call *call, gfp_t gfp)\n{\n\tstruct sockaddr_rxrpc *srx = &ac->alist->addrs[ac->index];\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tsize_t len;\n\ts64 tx_total_len;\n\tint ret;\n\n\t_enter(\",{%pISp},\", &srx->transport);\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&call->net->nr_outstanding_calls));\n\n\tcall->addr_ix = ac->index;\n\tcall->alist = afs_get_addrlist(ac->alist);\n\n\t \n\ttx_total_len = call->request_size;\n\tif (call->write_iter)\n\t\ttx_total_len += iov_iter_count(call->write_iter);\n\n\t \n\tif (call->async) {\n\t\tafs_get_call(call, afs_call_trace_get);\n\t\tcall->drop_ref = true;\n\t}\n\n\t \n\trxcall = rxrpc_kernel_begin_call(call->net->socket, srx, call->key,\n\t\t\t\t\t (unsigned long)call,\n\t\t\t\t\t tx_total_len,\n\t\t\t\t\t call->max_lifespan,\n\t\t\t\t\t gfp,\n\t\t\t\t\t (call->async ?\n\t\t\t\t\t  afs_wake_up_async_call :\n\t\t\t\t\t  afs_wake_up_call_waiter),\n\t\t\t\t\t call->upgrade,\n\t\t\t\t\t (call->intr ? RXRPC_PREINTERRUPTIBLE :\n\t\t\t\t\t  RXRPC_UNINTERRUPTIBLE),\n\t\t\t\t\t call->debug_id);\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tcall->error = ret;\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\tcall->issue_time = ktime_get_real();\n\n\t \n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, ITER_SOURCE, iov, 1, call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= MSG_WAITALL | (call->write_iter ? MSG_MORE : 0);\n\n\tret = rxrpc_kernel_send_data(call->net->socket, rxcall,\n\t\t\t\t     &msg, call->request_size,\n\t\t\t\t     afs_notify_end_request_tx);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->write_iter) {\n\t\tmsg.msg_iter = *call->write_iter;\n\t\tmsg.msg_flags &= ~MSG_MORE;\n\t\ttrace_afs_send_data(call, &msg);\n\n\t\tret = rxrpc_kernel_send_data(call->net->socket,\n\t\t\t\t\t     call->rxcall, &msg,\n\t\t\t\t\t     iov_iter_count(&msg.msg_iter),\n\t\t\t\t\t     afs_notify_end_request_tx);\n\t\t*call->write_iter = msg.msg_iter;\n\n\t\ttrace_afs_sent_data(call, &msg, ret);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t \n\treturn;\n\nerror_do_abort:\n\tif (ret != -ECONNABORTED) {\n\t\trxrpc_kernel_abort_call(call->net->socket, rxcall,\n\t\t\t\t\tRX_USER_ABORT, ret,\n\t\t\t\t\tafs_abort_send_data_error);\n\t} else {\n\t\tlen = 0;\n\t\tiov_iter_kvec(&msg.msg_iter, ITER_DEST, NULL, 0, 0);\n\t\trxrpc_kernel_recv_data(call->net->socket, rxcall,\n\t\t\t\t       &msg.msg_iter, &len, false,\n\t\t\t\t       &call->abort_code, &call->service_id);\n\t\tac->abort_code = call->abort_code;\n\t\tac->responded = true;\n\t}\n\tcall->error = ret;\n\ttrace_afs_call_done(call);\nerror_kill_call:\n\tif (call->type->done)\n\t\tcall->type->done(call);\n\n\t \n\tif (call->rxcall)\n\t\trxrpc_kernel_shutdown_call(call->net->socket, call->rxcall);\n\tif (call->async) {\n\t\tif (cancel_work_sync(&call->async_work))\n\t\t\tafs_put_call(call);\n\t\tafs_set_call_complete(call, ret, 0);\n\t}\n\n\tac->error = ret;\n\tcall->state = AFS_CALL_COMPLETE;\n\t_leave(\" = %d\", ret);\n}\n\n \nstatic void afs_log_error(struct afs_call *call, s32 remote_abort)\n{\n\tstatic int max = 0;\n\tconst char *msg;\n\tint m;\n\n\tswitch (remote_abort) {\n\tcase RX_EOF:\t\t msg = \"unexpected EOF\";\tbreak;\n\tcase RXGEN_CC_MARSHAL:\t msg = \"client marshalling\";\tbreak;\n\tcase RXGEN_CC_UNMARSHAL: msg = \"client unmarshalling\";\tbreak;\n\tcase RXGEN_SS_MARSHAL:\t msg = \"server marshalling\";\tbreak;\n\tcase RXGEN_SS_UNMARSHAL: msg = \"server unmarshalling\";\tbreak;\n\tcase RXGEN_DECODE:\t msg = \"opcode decode\";\t\tbreak;\n\tcase RXGEN_SS_XDRFREE:\t msg = \"server XDR cleanup\";\tbreak;\n\tcase RXGEN_CC_XDRFREE:\t msg = \"client XDR cleanup\";\tbreak;\n\tcase -32:\t\t msg = \"insufficient data\";\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tm = max;\n\tif (m < 3) {\n\t\tmax = m + 1;\n\t\tpr_notice(\"kAFS: Peer reported %s failure on %s [%pISp]\\n\",\n\t\t\t  msg, call->type->name,\n\t\t\t  &call->alist->addrs[call->addr_ix].transport);\n\t}\n}\n\n \nstatic void afs_deliver_to_call(struct afs_call *call)\n{\n\tenum afs_call_state state;\n\tsize_t len;\n\tu32 abort_code, remote_abort = 0;\n\tint ret;\n\n\t_enter(\"%s\", call->type->name);\n\n\twhile (state = READ_ONCE(call->state),\n\t       state == AFS_CALL_CL_AWAIT_REPLY ||\n\t       state == AFS_CALL_SV_AWAIT_OP_ID ||\n\t       state == AFS_CALL_SV_AWAIT_REQUEST ||\n\t       state == AFS_CALL_SV_AWAIT_ACK\n\t       ) {\n\t\tif (state == AFS_CALL_SV_AWAIT_ACK) {\n\t\t\tlen = 0;\n\t\t\tiov_iter_kvec(&call->def_iter, ITER_DEST, NULL, 0, 0);\n\t\t\tret = rxrpc_kernel_recv_data(call->net->socket,\n\t\t\t\t\t\t     call->rxcall, &call->def_iter,\n\t\t\t\t\t\t     &len, false, &remote_abort,\n\t\t\t\t\t\t     &call->service_id);\n\t\t\ttrace_afs_receive_data(call, &call->def_iter, false, ret);\n\n\t\t\tif (ret == -EINPROGRESS || ret == -EAGAIN)\n\t\t\t\treturn;\n\t\t\tif (ret < 0 || ret == 1) {\n\t\t\t\tif (ret == 1)\n\t\t\t\t\tret = 0;\n\t\t\t\tgoto call_complete;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tret = call->type->deliver(call);\n\t\tstate = READ_ONCE(call->state);\n\t\tif (ret == 0 && call->unmarshalling_error)\n\t\t\tret = -EBADMSG;\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tafs_queue_call_work(call);\n\t\t\tif (state == AFS_CALL_CL_PROC_REPLY) {\n\t\t\t\tif (call->op)\n\t\t\t\t\tset_bit(AFS_SERVER_FL_MAY_HAVE_CB,\n\t\t\t\t\t\t&call->op->server->flags);\n\t\t\t\tgoto call_complete;\n\t\t\t}\n\t\t\tASSERTCMP(state, >, AFS_CALL_CL_PROC_REPLY);\n\t\t\tgoto done;\n\t\tcase -EINPROGRESS:\n\t\tcase -EAGAIN:\n\t\t\tgoto out;\n\t\tcase -ECONNABORTED:\n\t\t\tASSERTCMP(state, ==, AFS_CALL_COMPLETE);\n\t\t\tafs_log_error(call, call->abort_code);\n\t\t\tgoto done;\n\t\tcase -ENOTSUPP:\n\t\t\tabort_code = RXGEN_OPCODE;\n\t\t\trxrpc_kernel_abort_call(call->net->socket, call->rxcall,\n\t\t\t\t\t\tabort_code, ret,\n\t\t\t\t\t\tafs_abort_op_not_supported);\n\t\t\tgoto local_abort;\n\t\tcase -EIO:\n\t\t\tpr_err(\"kAFS: Call %u in bad state %u\\n\",\n\t\t\t       call->debug_id, state);\n\t\t\tfallthrough;\n\t\tcase -ENODATA:\n\t\tcase -EBADMSG:\n\t\tcase -EMSGSIZE:\n\t\tcase -ENOMEM:\n\t\tcase -EFAULT:\n\t\t\tabort_code = RXGEN_CC_UNMARSHAL;\n\t\t\tif (state != AFS_CALL_CL_AWAIT_REPLY)\n\t\t\t\tabort_code = RXGEN_SS_UNMARSHAL;\n\t\t\trxrpc_kernel_abort_call(call->net->socket, call->rxcall,\n\t\t\t\t\t\tabort_code, ret,\n\t\t\t\t\t\tafs_abort_unmarshal_error);\n\t\t\tgoto local_abort;\n\t\tdefault:\n\t\t\tabort_code = RX_CALL_DEAD;\n\t\t\trxrpc_kernel_abort_call(call->net->socket, call->rxcall,\n\t\t\t\t\t\tabort_code, ret,\n\t\t\t\t\t\tafs_abort_general_error);\n\t\t\tgoto local_abort;\n\t\t}\n\t}\n\ndone:\n\tif (call->type->done)\n\t\tcall->type->done(call);\nout:\n\t_leave(\"\");\n\treturn;\n\nlocal_abort:\n\tabort_code = 0;\ncall_complete:\n\tafs_set_call_complete(call, ret, remote_abort);\n\tstate = AFS_CALL_COMPLETE;\n\tgoto done;\n}\n\n \nlong afs_wait_for_call_to_complete(struct afs_call *call,\n\t\t\t\t   struct afs_addr_cursor *ac)\n{\n\tlong ret;\n\tbool rxrpc_complete = false;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"\");\n\n\tret = call->error;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tadd_wait_queue(&call->waitq, &myself);\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t \n\t\tif (!afs_check_call_state(call, AFS_CALL_COMPLETE) &&\n\t\t    call->need_attention) {\n\t\t\tcall->need_attention = false;\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tafs_deliver_to_call(call);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (afs_check_call_state(call, AFS_CALL_COMPLETE))\n\t\t\tbreak;\n\n\t\tif (!rxrpc_kernel_check_life(call->net->socket, call->rxcall)) {\n\t\t\t \n\t\t\trxrpc_complete = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tschedule();\n\t}\n\n\tremove_wait_queue(&call->waitq, &myself);\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!afs_check_call_state(call, AFS_CALL_COMPLETE)) {\n\t\tif (rxrpc_complete) {\n\t\t\tafs_set_call_complete(call, call->error, call->abort_code);\n\t\t} else {\n\t\t\t \n\t\t\t_debug(\"call interrupted\");\n\t\t\tif (rxrpc_kernel_abort_call(call->net->socket, call->rxcall,\n\t\t\t\t\t\t    RX_USER_ABORT, -EINTR,\n\t\t\t\t\t\t    afs_abort_interrupted))\n\t\t\t\tafs_set_call_complete(call, -EINTR, 0);\n\t\t}\n\t}\n\n\tspin_lock_bh(&call->state_lock);\n\tac->abort_code = call->abort_code;\n\tac->error = call->error;\n\tspin_unlock_bh(&call->state_lock);\n\n\tret = ac->error;\n\tswitch (ret) {\n\tcase 0:\n\t\tret = call->ret0;\n\t\tcall->ret0 = 0;\n\n\t\tfallthrough;\n\tcase -ECONNABORTED:\n\t\tac->responded = true;\n\t\tbreak;\n\t}\n\nout:\n\t_debug(\"call complete\");\n\tafs_put_call(call);\n\t_leave(\" = %p\", (void *)ret);\n\treturn ret;\n}\n\n \nstatic void afs_wake_up_call_waiter(struct sock *sk, struct rxrpc_call *rxcall,\n\t\t\t\t    unsigned long call_user_ID)\n{\n\tstruct afs_call *call = (struct afs_call *)call_user_ID;\n\n\tcall->need_attention = true;\n\twake_up(&call->waitq);\n}\n\n \nstatic void afs_wake_up_async_call(struct sock *sk, struct rxrpc_call *rxcall,\n\t\t\t\t   unsigned long call_user_ID)\n{\n\tstruct afs_call *call = (struct afs_call *)call_user_ID;\n\tint r;\n\n\ttrace_afs_notify_call(rxcall, call);\n\tcall->need_attention = true;\n\n\tif (__refcount_inc_not_zero(&call->ref, &r)) {\n\t\ttrace_afs_call(call->debug_id, afs_call_trace_wake, r + 1,\n\t\t\t       atomic_read(&call->net->nr_outstanding_calls),\n\t\t\t       __builtin_return_address(0));\n\n\t\tif (!queue_work(afs_async_calls, &call->async_work))\n\t\t\tafs_put_call(call);\n\t}\n}\n\n \nstatic void afs_process_async_call(struct work_struct *work)\n{\n\tstruct afs_call *call = container_of(work, struct afs_call, async_work);\n\n\t_enter(\"\");\n\n\tif (call->state < AFS_CALL_COMPLETE && call->need_attention) {\n\t\tcall->need_attention = false;\n\t\tafs_deliver_to_call(call);\n\t}\n\n\tafs_put_call(call);\n\t_leave(\"\");\n}\n\nstatic void afs_rx_attach(struct rxrpc_call *rxcall, unsigned long user_call_ID)\n{\n\tstruct afs_call *call = (struct afs_call *)user_call_ID;\n\n\tcall->rxcall = rxcall;\n}\n\n \nvoid afs_charge_preallocation(struct work_struct *work)\n{\n\tstruct afs_net *net =\n\t\tcontainer_of(work, struct afs_net, charge_preallocation_work);\n\tstruct afs_call *call = net->spare_incoming_call;\n\n\tfor (;;) {\n\t\tif (!call) {\n\t\t\tcall = afs_alloc_call(net, &afs_RXCMxxxx, GFP_KERNEL);\n\t\t\tif (!call)\n\t\t\t\tbreak;\n\n\t\t\tcall->drop_ref = true;\n\t\t\tcall->async = true;\n\t\t\tcall->state = AFS_CALL_SV_AWAIT_OP_ID;\n\t\t\tinit_waitqueue_head(&call->waitq);\n\t\t\tafs_extract_to_tmp(call);\n\t\t}\n\n\t\tif (rxrpc_kernel_charge_accept(net->socket,\n\t\t\t\t\t       afs_wake_up_async_call,\n\t\t\t\t\t       afs_rx_attach,\n\t\t\t\t\t       (unsigned long)call,\n\t\t\t\t\t       GFP_KERNEL,\n\t\t\t\t\t       call->debug_id) < 0)\n\t\t\tbreak;\n\t\tcall = NULL;\n\t}\n\tnet->spare_incoming_call = call;\n}\n\n \nstatic void afs_rx_discard_new_call(struct rxrpc_call *rxcall,\n\t\t\t\t    unsigned long user_call_ID)\n{\n\tstruct afs_call *call = (struct afs_call *)user_call_ID;\n\n\tcall->rxcall = NULL;\n\tafs_put_call(call);\n}\n\n \nstatic void afs_rx_new_call(struct sock *sk, struct rxrpc_call *rxcall,\n\t\t\t    unsigned long user_call_ID)\n{\n\tstruct afs_net *net = afs_sock2net(sk);\n\n\tqueue_work(afs_wq, &net->charge_preallocation_work);\n}\n\n \nstatic int afs_deliver_cm_op_id(struct afs_call *call)\n{\n\tint ret;\n\n\t_enter(\"{%zu}\", iov_iter_count(call->iter));\n\n\t \n\tret = afs_extract_data(call, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcall->operation_ID = ntohl(call->tmp);\n\tafs_set_call_state(call, AFS_CALL_SV_AWAIT_OP_ID, AFS_CALL_SV_AWAIT_REQUEST);\n\n\t \n\tif (!afs_cm_incoming_call(call))\n\t\treturn -ENOTSUPP;\n\n\ttrace_afs_cb_call(call);\n\n\t \n\treturn call->type->deliver(call);\n}\n\n \nstatic void afs_notify_end_reply_tx(struct sock *sock,\n\t\t\t\t    struct rxrpc_call *rxcall,\n\t\t\t\t    unsigned long call_user_ID)\n{\n\tstruct afs_call *call = (struct afs_call *)call_user_ID;\n\n\tafs_set_call_state(call, AFS_CALL_SV_REPLYING, AFS_CALL_SV_AWAIT_ACK);\n}\n\n \nvoid afs_send_empty_reply(struct afs_call *call)\n{\n\tstruct afs_net *net = call->net;\n\tstruct msghdr msg;\n\n\t_enter(\"\");\n\n\trxrpc_kernel_set_tx_length(net->socket, call->rxcall, 0);\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, ITER_SOURCE, NULL, 0, 0);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= 0;\n\n\tswitch (rxrpc_kernel_send_data(net->socket, call->rxcall, &msg, 0,\n\t\t\t\t       afs_notify_end_reply_tx)) {\n\tcase 0:\n\t\t_leave(\" [replied]\");\n\t\treturn;\n\n\tcase -ENOMEM:\n\t\t_debug(\"oom\");\n\t\trxrpc_kernel_abort_call(net->socket, call->rxcall,\n\t\t\t\t\tRXGEN_SS_MARSHAL, -ENOMEM,\n\t\t\t\t\tafs_abort_oom);\n\t\tfallthrough;\n\tdefault:\n\t\t_leave(\" [error]\");\n\t\treturn;\n\t}\n}\n\n \nvoid afs_send_simple_reply(struct afs_call *call, const void *buf, size_t len)\n{\n\tstruct afs_net *net = call->net;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint n;\n\n\t_enter(\"\");\n\n\trxrpc_kernel_set_tx_length(net->socket, call->rxcall, len);\n\n\tiov[0].iov_base\t\t= (void *) buf;\n\tiov[0].iov_len\t\t= len;\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, ITER_SOURCE, iov, 1, len);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= 0;\n\n\tn = rxrpc_kernel_send_data(net->socket, call->rxcall, &msg, len,\n\t\t\t\t   afs_notify_end_reply_tx);\n\tif (n >= 0) {\n\t\t \n\t\t_leave(\" [replied]\");\n\t\treturn;\n\t}\n\n\tif (n == -ENOMEM) {\n\t\t_debug(\"oom\");\n\t\trxrpc_kernel_abort_call(net->socket, call->rxcall,\n\t\t\t\t\tRXGEN_SS_MARSHAL, -ENOMEM,\n\t\t\t\t\tafs_abort_oom);\n\t}\n\t_leave(\" [error]\");\n}\n\n \nint afs_extract_data(struct afs_call *call, bool want_more)\n{\n\tstruct afs_net *net = call->net;\n\tstruct iov_iter *iter = call->iter;\n\tenum afs_call_state state;\n\tu32 remote_abort = 0;\n\tint ret;\n\n\t_enter(\"{%s,%zu,%zu},%d\",\n\t       call->type->name, call->iov_len, iov_iter_count(iter), want_more);\n\n\tret = rxrpc_kernel_recv_data(net->socket, call->rxcall, iter,\n\t\t\t\t     &call->iov_len, want_more, &remote_abort,\n\t\t\t\t     &call->service_id);\n\ttrace_afs_receive_data(call, call->iter, want_more, ret);\n\tif (ret == 0 || ret == -EAGAIN)\n\t\treturn ret;\n\n\tstate = READ_ONCE(call->state);\n\tif (ret == 1) {\n\t\tswitch (state) {\n\t\tcase AFS_CALL_CL_AWAIT_REPLY:\n\t\t\tafs_set_call_state(call, state, AFS_CALL_CL_PROC_REPLY);\n\t\t\tbreak;\n\t\tcase AFS_CALL_SV_AWAIT_REQUEST:\n\t\t\tafs_set_call_state(call, state, AFS_CALL_SV_REPLYING);\n\t\t\tbreak;\n\t\tcase AFS_CALL_COMPLETE:\n\t\t\tkdebug(\"prem complete %d\", call->error);\n\t\t\treturn afs_io_error(call, afs_io_error_extract);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tafs_set_call_complete(call, ret, remote_abort);\n\treturn ret;\n}\n\n \nnoinline int afs_protocol_error(struct afs_call *call,\n\t\t\t\tenum afs_eproto_cause cause)\n{\n\ttrace_afs_protocol_error(call, cause);\n\tif (call)\n\t\tcall->unmarshalling_error = true;\n\treturn -EBADMSG;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}