{
  "module_name": "vl_alias.c",
  "hash_id": "c7628b41bfa664d53b246b4bc0eedb44be5a58e2ba4faeccd9f30f819b9847c7",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/vl_alias.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <keys/rxrpc-type.h>\n#include \"internal.h\"\n\n \nstatic struct afs_volume *afs_sample_volume(struct afs_cell *cell, struct key *key,\n\t\t\t\t\t    const char *name, unsigned int namelen)\n{\n\tstruct afs_volume *volume;\n\tstruct afs_fs_context fc = {\n\t\t.type\t\t= 0,  \n\t\t.volnamesz\t= namelen,\n\t\t.volname\t= name,\n\t\t.net\t\t= cell->net,\n\t\t.cell\t\t= cell,\n\t\t.key\t\t= key,  \n\t};\n\n\tvolume = afs_create_volume(&fc);\n\t_leave(\" = %p\", volume);\n\treturn volume;\n}\n\n \nstatic int afs_compare_addrs(const struct sockaddr_rxrpc *srx_a,\n\t\t\t     const struct sockaddr_rxrpc *srx_b)\n{\n\tshort port_a, port_b;\n\tint addr_a, addr_b, diff;\n\n\tdiff = (short)srx_a->transport_type - (short)srx_b->transport_type;\n\tif (diff)\n\t\tgoto out;\n\n\tswitch (srx_a->transport_type) {\n\tcase AF_INET: {\n\t\tconst struct sockaddr_in *a = &srx_a->transport.sin;\n\t\tconst struct sockaddr_in *b = &srx_b->transport.sin;\n\t\taddr_a = ntohl(a->sin_addr.s_addr);\n\t\taddr_b = ntohl(b->sin_addr.s_addr);\n\t\tdiff = addr_a - addr_b;\n\t\tif (diff == 0) {\n\t\t\tport_a = ntohs(a->sin_port);\n\t\t\tport_b = ntohs(b->sin_port);\n\t\t\tdiff = port_a - port_b;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase AF_INET6: {\n\t\tconst struct sockaddr_in6 *a = &srx_a->transport.sin6;\n\t\tconst struct sockaddr_in6 *b = &srx_b->transport.sin6;\n\t\tdiff = memcmp(&a->sin6_addr, &b->sin6_addr, 16);\n\t\tif (diff == 0) {\n\t\t\tport_a = ntohs(a->sin6_port);\n\t\t\tport_b = ntohs(b->sin6_port);\n\t\t\tdiff = port_a - port_b;\n\t\t}\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tWARN_ON(1);\n\t\tdiff = 1;\n\t}\n\nout:\n\treturn diff;\n}\n\n \nstatic int afs_compare_fs_alists(const struct afs_server *server_a,\n\t\t\t\t const struct afs_server *server_b)\n{\n\tconst struct afs_addr_list *la, *lb;\n\tint a = 0, b = 0, addr_matches = 0;\n\n\tla = rcu_dereference(server_a->addresses);\n\tlb = rcu_dereference(server_b->addresses);\n\n\twhile (a < la->nr_addrs && b < lb->nr_addrs) {\n\t\tconst struct sockaddr_rxrpc *srx_a = &la->addrs[a];\n\t\tconst struct sockaddr_rxrpc *srx_b = &lb->addrs[b];\n\t\tint diff = afs_compare_addrs(srx_a, srx_b);\n\n\t\tif (diff < 0) {\n\t\t\ta++;\n\t\t} else if (diff > 0) {\n\t\t\tb++;\n\t\t} else {\n\t\t\taddr_matches++;\n\t\t\ta++;\n\t\t\tb++;\n\t\t}\n\t}\n\n\treturn addr_matches;\n}\n\n \nstatic int afs_compare_volume_slists(const struct afs_volume *vol_a,\n\t\t\t\t     const struct afs_volume *vol_b)\n{\n\tconst struct afs_server_list *la, *lb;\n\tint i, a = 0, b = 0, uuid_matches = 0, addr_matches = 0;\n\n\tla = rcu_dereference(vol_a->servers);\n\tlb = rcu_dereference(vol_b->servers);\n\n\tfor (i = 0; i < AFS_MAXTYPES; i++)\n\t\tif (la->vids[i] != lb->vids[i])\n\t\t\treturn 0;\n\n\twhile (a < la->nr_servers && b < lb->nr_servers) {\n\t\tconst struct afs_server *server_a = la->servers[a].server;\n\t\tconst struct afs_server *server_b = lb->servers[b].server;\n\t\tint diff = memcmp(&server_a->uuid, &server_b->uuid, sizeof(uuid_t));\n\n\t\tif (diff < 0) {\n\t\t\ta++;\n\t\t} else if (diff > 0) {\n\t\t\tb++;\n\t\t} else {\n\t\t\tuuid_matches++;\n\t\t\taddr_matches += afs_compare_fs_alists(server_a, server_b);\n\t\t\ta++;\n\t\t\tb++;\n\t\t}\n\t}\n\n\t_leave(\" = %d [um %d]\", addr_matches, uuid_matches);\n\treturn addr_matches;\n}\n\n \nstatic int afs_compare_cell_roots(struct afs_cell *cell)\n{\n\tstruct afs_cell *p;\n\n\t_enter(\"\");\n\n\trcu_read_lock();\n\n\thlist_for_each_entry_rcu(p, &cell->net->proc_cells, proc_link) {\n\t\tif (p == cell || p->alias_of)\n\t\t\tcontinue;\n\t\tif (!p->root_volume)\n\t\t\tcontinue;  \n\n\t\tif (afs_compare_volume_slists(cell->root_volume, p->root_volume) != 0)\n\t\t\tgoto is_alias;\n\t}\n\n\trcu_read_unlock();\n\t_leave(\" = 0\");\n\treturn 0;\n\nis_alias:\n\trcu_read_unlock();\n\tcell->alias_of = afs_use_cell(p, afs_cell_trace_use_alias);\n\treturn 1;\n}\n\n \nstatic int afs_query_for_alias_one(struct afs_cell *cell, struct key *key,\n\t\t\t\t   struct afs_cell *p)\n{\n\tstruct afs_volume *volume, *pvol = NULL;\n\tint ret;\n\n\t \n\tread_seqlock_excl(&p->volume_lock);\n\tif (!RB_EMPTY_ROOT(&p->volumes))\n\t\tpvol = afs_get_volume(rb_entry(p->volumes.rb_node,\n\t\t\t\t\t       struct afs_volume, cell_node),\n\t\t\t\t      afs_volume_trace_get_query_alias);\n\tread_sequnlock_excl(&p->volume_lock);\n\tif (!pvol)\n\t\treturn 0;\n\n\t_enter(\"%s:%s\", cell->name, pvol->name);\n\n\t \n\tvolume = afs_sample_volume(cell, key, pvol->name, pvol->name_len);\n\tif (IS_ERR(volume)) {\n\t\tafs_put_volume(cell->net, pvol, afs_volume_trace_put_query_alias);\n\t\tif (PTR_ERR(volume) != -ENOMEDIUM)\n\t\t\treturn PTR_ERR(volume);\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tret = 0;\n\tif (pvol->vid == volume->vid) {\n\t\trcu_read_lock();\n\t\tif (afs_compare_volume_slists(volume, pvol))\n\t\t\tret = 1;\n\t\trcu_read_unlock();\n\t}\n\n\tafs_put_volume(cell->net, volume, afs_volume_trace_put_query_alias);\n\tafs_put_volume(cell->net, pvol, afs_volume_trace_put_query_alias);\n\treturn ret;\n}\n\n \nstatic int afs_query_for_alias(struct afs_cell *cell, struct key *key)\n{\n\tstruct afs_cell *p;\n\n\t_enter(\"%s\", cell->name);\n\n\tif (mutex_lock_interruptible(&cell->net->proc_cells_lock) < 0)\n\t\treturn -ERESTARTSYS;\n\n\thlist_for_each_entry(p, &cell->net->proc_cells, proc_link) {\n\t\tif (p == cell || p->alias_of)\n\t\t\tcontinue;\n\t\tif (RB_EMPTY_ROOT(&p->volumes))\n\t\t\tcontinue;\n\t\tif (p->root_volume)\n\t\t\tcontinue;  \n\t\tafs_use_cell(p, afs_cell_trace_use_check_alias);\n\t\tmutex_unlock(&cell->net->proc_cells_lock);\n\n\t\tif (afs_query_for_alias_one(cell, key, p) != 0)\n\t\t\tgoto is_alias;\n\n\t\tif (mutex_lock_interruptible(&cell->net->proc_cells_lock) < 0) {\n\t\t\tafs_unuse_cell(cell->net, p, afs_cell_trace_unuse_check_alias);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\n\t\tafs_unuse_cell(cell->net, p, afs_cell_trace_unuse_check_alias);\n\t}\n\n\tmutex_unlock(&cell->net->proc_cells_lock);\n\t_leave(\" = 0\");\n\treturn 0;\n\nis_alias:\n\tcell->alias_of = p;  \n\treturn 1;\n}\n\n \nstatic char *afs_vl_get_cell_name(struct afs_cell *cell, struct key *key)\n{\n\tstruct afs_vl_cursor vc;\n\tchar *cell_name = ERR_PTR(-EDESTADDRREQ);\n\tbool skipped = false, not_skipped = false;\n\tint ret;\n\n\tif (!afs_begin_vlserver_operation(&vc, cell, key))\n\t\treturn ERR_PTR(-ERESTARTSYS);\n\n\twhile (afs_select_vlserver(&vc)) {\n\t\tif (!test_bit(AFS_VLSERVER_FL_IS_YFS, &vc.server->flags)) {\n\t\t\tvc.ac.error = -EOPNOTSUPP;\n\t\t\tskipped = true;\n\t\t\tcontinue;\n\t\t}\n\t\tnot_skipped = true;\n\t\tcell_name = afs_yfsvl_get_cell_name(&vc);\n\t}\n\n\tret = afs_end_vlserver_operation(&vc);\n\tif (skipped && !not_skipped)\n\t\tret = -EOPNOTSUPP;\n\treturn ret < 0 ? ERR_PTR(ret) : cell_name;\n}\n\nstatic int yfs_check_canonical_cell_name(struct afs_cell *cell, struct key *key)\n{\n\tstruct afs_cell *master;\n\tchar *cell_name;\n\n\tcell_name = afs_vl_get_cell_name(cell, key);\n\tif (IS_ERR(cell_name))\n\t\treturn PTR_ERR(cell_name);\n\n\tif (strcmp(cell_name, cell->name) == 0) {\n\t\tkfree(cell_name);\n\t\treturn 0;\n\t}\n\n\tmaster = afs_lookup_cell(cell->net, cell_name, strlen(cell_name),\n\t\t\t\t NULL, false);\n\tkfree(cell_name);\n\tif (IS_ERR(master))\n\t\treturn PTR_ERR(master);\n\n\tcell->alias_of = master;  \n\treturn 1;\n}\n\nstatic int afs_do_cell_detect_alias(struct afs_cell *cell, struct key *key)\n{\n\tstruct afs_volume *root_volume;\n\tint ret;\n\n\t_enter(\"%s\", cell->name);\n\n\tret = yfs_check_canonical_cell_name(cell, key);\n\tif (ret != -EOPNOTSUPP)\n\t\treturn ret;\n\n\t \n\troot_volume = afs_sample_volume(cell, key, \"root.cell\", 9);\n\tif (!IS_ERR(root_volume)) {\n\t\tcell->root_volume = root_volume;\n\t\treturn afs_compare_cell_roots(cell);\n\t}\n\n\tif (PTR_ERR(root_volume) != -ENOMEDIUM)\n\t\treturn PTR_ERR(root_volume);\n\n\t \n\treturn afs_query_for_alias(cell, key);\n}\n\n \nint afs_cell_detect_alias(struct afs_cell *cell, struct key *key)\n{\n\tstruct afs_net *net = cell->net;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&net->cells_alias_lock) < 0)\n\t\treturn -ERESTARTSYS;\n\n\tif (test_bit(AFS_CELL_FL_CHECK_ALIAS, &cell->flags)) {\n\t\tret = afs_do_cell_detect_alias(cell, key);\n\t\tif (ret >= 0)\n\t\t\tclear_bit_unlock(AFS_CELL_FL_CHECK_ALIAS, &cell->flags);\n\t} else {\n\t\tret = cell->alias_of ? 1 : 0;\n\t}\n\n\tmutex_unlock(&net->cells_alias_lock);\n\n\tif (ret == 1)\n\t\tpr_notice(\"kAFS: Cell %s is an alias of %s\\n\",\n\t\t\t  cell->name, cell->alias_of->name);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}