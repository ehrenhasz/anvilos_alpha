{
  "module_name": "xattr.c",
  "hash_id": "5cd5054f4def48535a050ebf0076e6007a7e8594adc174c8dd3d041ff88facff",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/xattr.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/xattr.h>\n#include \"internal.h\"\n\n \nstatic void afs_acl_success(struct afs_operation *op)\n{\n\tafs_vnode_commit_status(op, &op->file[0]);\n}\n\nstatic void afs_acl_put(struct afs_operation *op)\n{\n\tkfree(op->acl);\n}\n\nstatic const struct afs_operation_ops afs_fetch_acl_operation = {\n\t.issue_afs_rpc\t= afs_fs_fetch_acl,\n\t.success\t= afs_acl_success,\n\t.put\t\t= afs_acl_put,\n};\n\n \nstatic int afs_xattr_get_acl(const struct xattr_handler *handler,\n\t\t\t     struct dentry *dentry,\n\t\t\t     struct inode *inode, const char *name,\n\t\t\t     void *buffer, size_t size)\n{\n\tstruct afs_operation *op;\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct afs_acl *acl = NULL;\n\tint ret;\n\n\top = afs_alloc_operation(NULL, vnode->volume);\n\tif (IS_ERR(op))\n\t\treturn -ENOMEM;\n\n\tafs_op_set_vnode(op, 0, vnode);\n\top->ops = &afs_fetch_acl_operation;\n\n\tafs_begin_vnode_operation(op);\n\tafs_wait_for_operation(op);\n\tacl = op->acl;\n\top->acl = NULL;\n\tret = afs_put_operation(op);\n\n\tif (ret == 0) {\n\t\tret = acl->size;\n\t\tif (size > 0) {\n\t\t\tif (acl->size <= size)\n\t\t\t\tmemcpy(buffer, acl->data, acl->size);\n\t\t\telse\n\t\t\t\tret = -ERANGE;\n\t\t}\n\t}\n\n\tkfree(acl);\n\treturn ret;\n}\n\nstatic bool afs_make_acl(struct afs_operation *op,\n\t\t\t const void *buffer, size_t size)\n{\n\tstruct afs_acl *acl;\n\n\tacl = kmalloc(sizeof(*acl) + size, GFP_KERNEL);\n\tif (!acl) {\n\t\tafs_op_nomem(op);\n\t\treturn false;\n\t}\n\n\tacl->size = size;\n\tmemcpy(acl->data, buffer, size);\n\top->acl = acl;\n\treturn true;\n}\n\nstatic const struct afs_operation_ops afs_store_acl_operation = {\n\t.issue_afs_rpc\t= afs_fs_store_acl,\n\t.success\t= afs_acl_success,\n\t.put\t\t= afs_acl_put,\n};\n\n \nstatic int afs_xattr_set_acl(const struct xattr_handler *handler,\n\t\t\t     struct mnt_idmap *idmap,\n                             struct dentry *dentry,\n                             struct inode *inode, const char *name,\n                             const void *buffer, size_t size, int flags)\n{\n\tstruct afs_operation *op;\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\n\tif (flags == XATTR_CREATE)\n\t\treturn -EINVAL;\n\n\top = afs_alloc_operation(NULL, vnode->volume);\n\tif (IS_ERR(op))\n\t\treturn -ENOMEM;\n\n\tafs_op_set_vnode(op, 0, vnode);\n\tif (!afs_make_acl(op, buffer, size))\n\t\treturn afs_put_operation(op);\n\n\top->ops = &afs_store_acl_operation;\n\treturn afs_do_sync_operation(op);\n}\n\nstatic const struct xattr_handler afs_xattr_afs_acl_handler = {\n\t.name   = \"afs.acl\",\n\t.get    = afs_xattr_get_acl,\n\t.set    = afs_xattr_set_acl,\n};\n\nstatic const struct afs_operation_ops yfs_fetch_opaque_acl_operation = {\n\t.issue_yfs_rpc\t= yfs_fs_fetch_opaque_acl,\n\t.success\t= afs_acl_success,\n\t \n};\n\n \nstatic int afs_xattr_get_yfs(const struct xattr_handler *handler,\n\t\t\t     struct dentry *dentry,\n\t\t\t     struct inode *inode, const char *name,\n\t\t\t     void *buffer, size_t size)\n{\n\tstruct afs_operation *op;\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct yfs_acl *yacl = NULL;\n\tchar buf[16], *data;\n\tint which = 0, dsize, ret = -ENOMEM;\n\n\tif (strcmp(name, \"acl\") == 0)\n\t\twhich = 0;\n\telse if (strcmp(name, \"acl_inherited\") == 0)\n\t\twhich = 1;\n\telse if (strcmp(name, \"acl_num_cleaned\") == 0)\n\t\twhich = 2;\n\telse if (strcmp(name, \"vol_acl\") == 0)\n\t\twhich = 3;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\tyacl = kzalloc(sizeof(struct yfs_acl), GFP_KERNEL);\n\tif (!yacl)\n\t\tgoto error;\n\n\tif (which == 0)\n\t\tyacl->flags |= YFS_ACL_WANT_ACL;\n\telse if (which == 3)\n\t\tyacl->flags |= YFS_ACL_WANT_VOL_ACL;\n\n\top = afs_alloc_operation(NULL, vnode->volume);\n\tif (IS_ERR(op))\n\t\tgoto error_yacl;\n\n\tafs_op_set_vnode(op, 0, vnode);\n\top->yacl = yacl;\n\top->ops = &yfs_fetch_opaque_acl_operation;\n\n\tafs_begin_vnode_operation(op);\n\tafs_wait_for_operation(op);\n\tret = afs_put_operation(op);\n\n\tif (ret == 0) {\n\t\tswitch (which) {\n\t\tcase 0:\n\t\t\tdata = yacl->acl->data;\n\t\t\tdsize = yacl->acl->size;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdata = buf;\n\t\t\tdsize = scnprintf(buf, sizeof(buf), \"%u\", yacl->inherit_flag);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata = buf;\n\t\t\tdsize = scnprintf(buf, sizeof(buf), \"%u\", yacl->num_cleaned);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdata = yacl->vol_acl->data;\n\t\t\tdsize = yacl->vol_acl->size;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto error_yacl;\n\t\t}\n\n\t\tret = dsize;\n\t\tif (size > 0) {\n\t\t\tif (dsize <= size)\n\t\t\t\tmemcpy(buffer, data, dsize);\n\t\t\telse\n\t\t\t\tret = -ERANGE;\n\t\t}\n\t} else if (ret == -ENOTSUPP) {\n\t\tret = -ENODATA;\n\t}\n\nerror_yacl:\n\tyfs_free_opaque_acl(yacl);\nerror:\n\treturn ret;\n}\n\nstatic const struct afs_operation_ops yfs_store_opaque_acl2_operation = {\n\t.issue_yfs_rpc\t= yfs_fs_store_opaque_acl2,\n\t.success\t= afs_acl_success,\n\t.put\t\t= afs_acl_put,\n};\n\n \nstatic int afs_xattr_set_yfs(const struct xattr_handler *handler,\n\t\t\t     struct mnt_idmap *idmap,\n                             struct dentry *dentry,\n                             struct inode *inode, const char *name,\n                             const void *buffer, size_t size, int flags)\n{\n\tstruct afs_operation *op;\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tint ret;\n\n\tif (flags == XATTR_CREATE ||\n\t    strcmp(name, \"acl\") != 0)\n\t\treturn -EINVAL;\n\n\top = afs_alloc_operation(NULL, vnode->volume);\n\tif (IS_ERR(op))\n\t\treturn -ENOMEM;\n\n\tafs_op_set_vnode(op, 0, vnode);\n\tif (!afs_make_acl(op, buffer, size))\n\t\treturn afs_put_operation(op);\n\n\top->ops = &yfs_store_opaque_acl2_operation;\n\tret = afs_do_sync_operation(op);\n\tif (ret == -ENOTSUPP)\n\t\tret = -ENODATA;\n\treturn ret;\n}\n\nstatic const struct xattr_handler afs_xattr_yfs_handler = {\n\t.prefix\t= \"afs.yfs.\",\n\t.get\t= afs_xattr_get_yfs,\n\t.set\t= afs_xattr_set_yfs,\n};\n\n \nstatic int afs_xattr_get_cell(const struct xattr_handler *handler,\n\t\t\t      struct dentry *dentry,\n\t\t\t      struct inode *inode, const char *name,\n\t\t\t      void *buffer, size_t size)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct afs_cell *cell = vnode->volume->cell;\n\tsize_t namelen;\n\n\tnamelen = cell->name_len;\n\tif (size == 0)\n\t\treturn namelen;\n\tif (namelen > size)\n\t\treturn -ERANGE;\n\tmemcpy(buffer, cell->name, namelen);\n\treturn namelen;\n}\n\nstatic const struct xattr_handler afs_xattr_afs_cell_handler = {\n\t.name\t= \"afs.cell\",\n\t.get\t= afs_xattr_get_cell,\n};\n\n \nstatic int afs_xattr_get_fid(const struct xattr_handler *handler,\n\t\t\t     struct dentry *dentry,\n\t\t\t     struct inode *inode, const char *name,\n\t\t\t     void *buffer, size_t size)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tchar text[16 + 1 + 24 + 1 + 8 + 1];\n\tsize_t len;\n\n\t \n\tlen = scnprintf(text, sizeof(text), \"%llx:\", vnode->fid.vid);\n\tif (vnode->fid.vnode_hi)\n\t\tlen += scnprintf(text + len, sizeof(text) - len, \"%x%016llx\",\n\t\t\t\tvnode->fid.vnode_hi, vnode->fid.vnode);\n\telse\n\t\tlen += scnprintf(text + len, sizeof(text) - len, \"%llx\",\n\t\t\t\t vnode->fid.vnode);\n\tlen += scnprintf(text + len, sizeof(text) - len, \":%x\",\n\t\t\t vnode->fid.unique);\n\n\tif (size == 0)\n\t\treturn len;\n\tif (len > size)\n\t\treturn -ERANGE;\n\tmemcpy(buffer, text, len);\n\treturn len;\n}\n\nstatic const struct xattr_handler afs_xattr_afs_fid_handler = {\n\t.name\t= \"afs.fid\",\n\t.get\t= afs_xattr_get_fid,\n};\n\n \nstatic int afs_xattr_get_volume(const struct xattr_handler *handler,\n\t\t\t      struct dentry *dentry,\n\t\t\t      struct inode *inode, const char *name,\n\t\t\t      void *buffer, size_t size)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tconst char *volname = vnode->volume->name;\n\tsize_t namelen;\n\n\tnamelen = strlen(volname);\n\tif (size == 0)\n\t\treturn namelen;\n\tif (namelen > size)\n\t\treturn -ERANGE;\n\tmemcpy(buffer, volname, namelen);\n\treturn namelen;\n}\n\nstatic const struct xattr_handler afs_xattr_afs_volume_handler = {\n\t.name\t= \"afs.volume\",\n\t.get\t= afs_xattr_get_volume,\n};\n\nconst struct xattr_handler *afs_xattr_handlers[] = {\n\t&afs_xattr_afs_acl_handler,\n\t&afs_xattr_afs_cell_handler,\n\t&afs_xattr_afs_fid_handler,\n\t&afs_xattr_afs_volume_handler,\n\t&afs_xattr_yfs_handler,\t\t \n\tNULL\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}