{
  "module_name": "cell.c",
  "hash_id": "52623431c714ce3aaf8bf54042aad7c551d63dabaa5404c6b99bff5430d927d9",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/cell.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/key.h>\n#include <linux/ctype.h>\n#include <linux/dns_resolver.h>\n#include <linux/sched.h>\n#include <linux/inet.h>\n#include <linux/namei.h>\n#include <keys/rxrpc-type.h>\n#include \"internal.h\"\n\nstatic unsigned __read_mostly afs_cell_gc_delay = 10;\nstatic unsigned __read_mostly afs_cell_min_ttl = 10 * 60;\nstatic unsigned __read_mostly afs_cell_max_ttl = 24 * 60 * 60;\nstatic atomic_t cell_debug_id;\n\nstatic void afs_queue_cell_manager(struct afs_net *);\nstatic void afs_manage_cell_work(struct work_struct *);\n\nstatic void afs_dec_cells_outstanding(struct afs_net *net)\n{\n\tif (atomic_dec_and_test(&net->cells_outstanding))\n\t\twake_up_var(&net->cells_outstanding);\n}\n\n \nstatic void afs_set_cell_timer(struct afs_net *net, time64_t delay)\n{\n\tif (net->live) {\n\t\tatomic_inc(&net->cells_outstanding);\n\t\tif (timer_reduce(&net->cells_timer, jiffies + delay * HZ))\n\t\t\tafs_dec_cells_outstanding(net);\n\t} else {\n\t\tafs_queue_cell_manager(net);\n\t}\n}\n\n \nstatic struct afs_cell *afs_find_cell_locked(struct afs_net *net,\n\t\t\t\t\t     const char *name, unsigned int namesz,\n\t\t\t\t\t     enum afs_cell_trace reason)\n{\n\tstruct afs_cell *cell = NULL;\n\tstruct rb_node *p;\n\tint n;\n\n\t_enter(\"%*.*s\", namesz, namesz, name);\n\n\tif (name && namesz == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (namesz > AFS_MAXCELLNAME)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tif (!name) {\n\t\tcell = net->ws_cell;\n\t\tif (!cell)\n\t\t\treturn ERR_PTR(-EDESTADDRREQ);\n\t\tgoto found;\n\t}\n\n\tp = net->cells.rb_node;\n\twhile (p) {\n\t\tcell = rb_entry(p, struct afs_cell, net_node);\n\n\t\tn = strncasecmp(cell->name, name,\n\t\t\t\tmin_t(size_t, cell->name_len, namesz));\n\t\tif (n == 0)\n\t\t\tn = cell->name_len - namesz;\n\t\tif (n < 0)\n\t\t\tp = p->rb_left;\n\t\telse if (n > 0)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n\nfound:\n\treturn afs_use_cell(cell, reason);\n}\n\n \nstruct afs_cell *afs_find_cell(struct afs_net *net,\n\t\t\t       const char *name, unsigned int namesz,\n\t\t\t       enum afs_cell_trace reason)\n{\n\tstruct afs_cell *cell;\n\n\tdown_read(&net->cells_lock);\n\tcell = afs_find_cell_locked(net, name, namesz, reason);\n\tup_read(&net->cells_lock);\n\treturn cell;\n}\n\n \nstatic struct afs_cell *afs_alloc_cell(struct afs_net *net,\n\t\t\t\t       const char *name, unsigned int namelen,\n\t\t\t\t       const char *addresses)\n{\n\tstruct afs_vlserver_list *vllist;\n\tstruct afs_cell *cell;\n\tint i, ret;\n\n\tASSERT(name);\n\tif (namelen == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (namelen > AFS_MAXCELLNAME) {\n\t\t_leave(\" = -ENAMETOOLONG\");\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\n\t \n\tif (name[0] == '.')\n\t\treturn ERR_PTR(-EINVAL);\n\tfor (i = 0; i < namelen; i++) {\n\t\tchar ch = name[i];\n\t\tif (!isprint(ch) || ch == '/' || ch == '@')\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t_enter(\"%*.*s,%s\", namelen, namelen, name, addresses);\n\n\tcell = kzalloc(sizeof(struct afs_cell), GFP_KERNEL);\n\tif (!cell) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tcell->name = kmalloc(namelen + 1, GFP_KERNEL);\n\tif (!cell->name) {\n\t\tkfree(cell);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tcell->net = net;\n\tcell->name_len = namelen;\n\tfor (i = 0; i < namelen; i++)\n\t\tcell->name[i] = tolower(name[i]);\n\tcell->name[i] = 0;\n\n\trefcount_set(&cell->ref, 1);\n\tatomic_set(&cell->active, 0);\n\tINIT_WORK(&cell->manager, afs_manage_cell_work);\n\tcell->volumes = RB_ROOT;\n\tINIT_HLIST_HEAD(&cell->proc_volumes);\n\tseqlock_init(&cell->volume_lock);\n\tcell->fs_servers = RB_ROOT;\n\tseqlock_init(&cell->fs_lock);\n\tINIT_LIST_HEAD(&cell->fs_open_mmaps);\n\tinit_rwsem(&cell->fs_open_mmaps_lock);\n\trwlock_init(&cell->vl_servers_lock);\n\tcell->flags = (1 << AFS_CELL_FL_CHECK_ALIAS);\n\n\t \n\tif (addresses) {\n\t\tvllist = afs_parse_text_addrs(net,\n\t\t\t\t\t      addresses, strlen(addresses), ':',\n\t\t\t\t\t      VL_SERVICE, AFS_VL_PORT);\n\t\tif (IS_ERR(vllist)) {\n\t\t\tret = PTR_ERR(vllist);\n\t\t\tgoto parse_failed;\n\t\t}\n\n\t\tvllist->source = DNS_RECORD_FROM_CONFIG;\n\t\tvllist->status = DNS_LOOKUP_NOT_DONE;\n\t\tcell->dns_expiry = TIME64_MAX;\n\t} else {\n\t\tret = -ENOMEM;\n\t\tvllist = afs_alloc_vlserver_list(0);\n\t\tif (!vllist)\n\t\t\tgoto error;\n\t\tvllist->source = DNS_RECORD_UNAVAILABLE;\n\t\tvllist->status = DNS_LOOKUP_NOT_DONE;\n\t\tcell->dns_expiry = ktime_get_real_seconds();\n\t}\n\n\trcu_assign_pointer(cell->vl_servers, vllist);\n\n\tcell->dns_source = vllist->source;\n\tcell->dns_status = vllist->status;\n\tsmp_store_release(&cell->dns_lookup_count, 1);  \n\tatomic_inc(&net->cells_outstanding);\n\tcell->debug_id = atomic_inc_return(&cell_debug_id);\n\ttrace_afs_cell(cell->debug_id, 1, 0, afs_cell_trace_alloc);\n\n\t_leave(\" = %p\", cell);\n\treturn cell;\n\nparse_failed:\n\tif (ret == -EINVAL)\n\t\tprintk(KERN_ERR \"kAFS: bad VL server IP address\\n\");\nerror:\n\tkfree(cell->name);\n\tkfree(cell);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}\n\n \nstruct afs_cell *afs_lookup_cell(struct afs_net *net,\n\t\t\t\t const char *name, unsigned int namesz,\n\t\t\t\t const char *vllist, bool excl)\n{\n\tstruct afs_cell *cell, *candidate, *cursor;\n\tstruct rb_node *parent, **pp;\n\tenum afs_cell_state state;\n\tint ret, n;\n\n\t_enter(\"%s,%s\", name, vllist);\n\n\tif (!excl) {\n\t\tcell = afs_find_cell(net, name, namesz, afs_cell_trace_use_lookup);\n\t\tif (!IS_ERR(cell))\n\t\t\tgoto wait_for_cell;\n\t}\n\n\t \n\tcandidate = afs_alloc_cell(net, name, namesz, vllist);\n\tif (IS_ERR(candidate)) {\n\t\t_leave(\" = %ld\", PTR_ERR(candidate));\n\t\treturn candidate;\n\t}\n\n\t \n\tdown_write(&net->cells_lock);\n\n\tpp = &net->cells.rb_node;\n\tparent = NULL;\n\twhile (*pp) {\n\t\tparent = *pp;\n\t\tcursor = rb_entry(parent, struct afs_cell, net_node);\n\n\t\tn = strncasecmp(cursor->name, name,\n\t\t\t\tmin_t(size_t, cursor->name_len, namesz));\n\t\tif (n == 0)\n\t\t\tn = cursor->name_len - namesz;\n\t\tif (n < 0)\n\t\t\tpp = &(*pp)->rb_left;\n\t\telse if (n > 0)\n\t\t\tpp = &(*pp)->rb_right;\n\t\telse\n\t\t\tgoto cell_already_exists;\n\t}\n\n\tcell = candidate;\n\tcandidate = NULL;\n\tatomic_set(&cell->active, 2);\n\ttrace_afs_cell(cell->debug_id, refcount_read(&cell->ref), 2, afs_cell_trace_insert);\n\trb_link_node_rcu(&cell->net_node, parent, pp);\n\trb_insert_color(&cell->net_node, &net->cells);\n\tup_write(&net->cells_lock);\n\n\tafs_queue_cell(cell, afs_cell_trace_get_queue_new);\n\nwait_for_cell:\n\ttrace_afs_cell(cell->debug_id, refcount_read(&cell->ref), atomic_read(&cell->active),\n\t\t       afs_cell_trace_wait);\n\t_debug(\"wait_for_cell\");\n\twait_var_event(&cell->state,\n\t\t       ({\n\t\t\t       state = smp_load_acquire(&cell->state);  \n\t\t\t       state == AFS_CELL_ACTIVE || state == AFS_CELL_REMOVED;\n\t\t       }));\n\n\t \n\tif (state == AFS_CELL_REMOVED) {\n\t\tret = cell->error;\n\t\tgoto error;\n\t}\n\n\t_leave(\" = %p [cell]\", cell);\n\treturn cell;\n\ncell_already_exists:\n\t_debug(\"cell exists\");\n\tcell = cursor;\n\tif (excl) {\n\t\tret = -EEXIST;\n\t} else {\n\t\tafs_use_cell(cursor, afs_cell_trace_use_lookup);\n\t\tret = 0;\n\t}\n\tup_write(&net->cells_lock);\n\tif (candidate)\n\t\tafs_put_cell(candidate, afs_cell_trace_put_candidate);\n\tif (ret == 0)\n\t\tgoto wait_for_cell;\n\tgoto error_noput;\nerror:\n\tafs_unuse_cell(net, cell, afs_cell_trace_unuse_lookup);\nerror_noput:\n\t_leave(\" = %d [error]\", ret);\n\treturn ERR_PTR(ret);\n}\n\n \nint afs_cell_init(struct afs_net *net, const char *rootcell)\n{\n\tstruct afs_cell *old_root, *new_root;\n\tconst char *cp, *vllist;\n\tsize_t len;\n\n\t_enter(\"\");\n\n\tif (!rootcell) {\n\t\t \n\t\t_leave(\" = 0 [no root]\");\n\t\treturn 0;\n\t}\n\n\tcp = strchr(rootcell, ':');\n\tif (!cp) {\n\t\t_debug(\"kAFS: no VL server IP addresses specified\");\n\t\tvllist = NULL;\n\t\tlen = strlen(rootcell);\n\t} else {\n\t\tvllist = cp + 1;\n\t\tlen = cp - rootcell;\n\t}\n\n\t \n\tnew_root = afs_lookup_cell(net, rootcell, len, vllist, false);\n\tif (IS_ERR(new_root)) {\n\t\t_leave(\" = %ld\", PTR_ERR(new_root));\n\t\treturn PTR_ERR(new_root);\n\t}\n\n\tif (!test_and_set_bit(AFS_CELL_FL_NO_GC, &new_root->flags))\n\t\tafs_use_cell(new_root, afs_cell_trace_use_pin);\n\n\t \n\tdown_write(&net->cells_lock);\n\tafs_see_cell(new_root, afs_cell_trace_see_ws);\n\told_root = net->ws_cell;\n\tnet->ws_cell = new_root;\n\tup_write(&net->cells_lock);\n\n\tafs_unuse_cell(net, old_root, afs_cell_trace_unuse_ws);\n\t_leave(\" = 0\");\n\treturn 0;\n}\n\n \nstatic int afs_update_cell(struct afs_cell *cell)\n{\n\tstruct afs_vlserver_list *vllist, *old = NULL, *p;\n\tunsigned int min_ttl = READ_ONCE(afs_cell_min_ttl);\n\tunsigned int max_ttl = READ_ONCE(afs_cell_max_ttl);\n\ttime64_t now, expiry = 0;\n\tint ret = 0;\n\n\t_enter(\"%s\", cell->name);\n\n\tvllist = afs_dns_query(cell, &expiry);\n\tif (IS_ERR(vllist)) {\n\t\tret = PTR_ERR(vllist);\n\n\t\t_debug(\"%s: fail %d\", cell->name, ret);\n\t\tif (ret == -ENOMEM)\n\t\t\tgoto out_wake;\n\n\t\tvllist = afs_alloc_vlserver_list(0);\n\t\tif (!vllist) {\n\t\t\tif (ret >= 0)\n\t\t\t\tret = -ENOMEM;\n\t\t\tgoto out_wake;\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase -ENODATA:\n\t\tcase -EDESTADDRREQ:\n\t\t\tvllist->status = DNS_LOOKUP_GOT_NOT_FOUND;\n\t\t\tbreak;\n\t\tcase -EAGAIN:\n\t\tcase -ECONNREFUSED:\n\t\t\tvllist->status = DNS_LOOKUP_GOT_TEMP_FAILURE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvllist->status = DNS_LOOKUP_GOT_LOCAL_FAILURE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t_debug(\"%s: got list %d %d\", cell->name, vllist->source, vllist->status);\n\tcell->dns_status = vllist->status;\n\n\tnow = ktime_get_real_seconds();\n\tif (min_ttl > max_ttl)\n\t\tmax_ttl = min_ttl;\n\tif (expiry < now + min_ttl)\n\t\texpiry = now + min_ttl;\n\telse if (expiry > now + max_ttl)\n\t\texpiry = now + max_ttl;\n\n\t_debug(\"%s: status %d\", cell->name, vllist->status);\n\tif (vllist->source == DNS_RECORD_UNAVAILABLE) {\n\t\tswitch (vllist->status) {\n\t\tcase DNS_LOOKUP_GOT_NOT_FOUND:\n\t\t\t \n\t\t\tcell->dns_expiry = expiry;\n\t\t\tbreak;\n\n\t\tcase DNS_LOOKUP_BAD:\n\t\tcase DNS_LOOKUP_GOT_LOCAL_FAILURE:\n\t\tcase DNS_LOOKUP_GOT_TEMP_FAILURE:\n\t\tcase DNS_LOOKUP_GOT_NS_FAILURE:\n\t\tdefault:\n\t\t\tcell->dns_expiry = now + 10;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tcell->dns_expiry = expiry;\n\t}\n\n\t \n\twrite_lock(&cell->vl_servers_lock);\n\tp = rcu_dereference_protected(cell->vl_servers, true);\n\tif (vllist->nr_servers > 0 || p->nr_servers == 0) {\n\t\trcu_assign_pointer(cell->vl_servers, vllist);\n\t\tcell->dns_source = vllist->source;\n\t\told = p;\n\t}\n\twrite_unlock(&cell->vl_servers_lock);\n\tafs_put_vlserverlist(cell->net, old);\n\nout_wake:\n\tsmp_store_release(&cell->dns_lookup_count,\n\t\t\t  cell->dns_lookup_count + 1);  \n\twake_up_var(&cell->dns_lookup_count);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nstatic void afs_cell_destroy(struct rcu_head *rcu)\n{\n\tstruct afs_cell *cell = container_of(rcu, struct afs_cell, rcu);\n\tstruct afs_net *net = cell->net;\n\tint r;\n\n\t_enter(\"%p{%s}\", cell, cell->name);\n\n\tr = refcount_read(&cell->ref);\n\tASSERTCMP(r, ==, 0);\n\ttrace_afs_cell(cell->debug_id, r, atomic_read(&cell->active), afs_cell_trace_free);\n\n\tafs_put_vlserverlist(net, rcu_access_pointer(cell->vl_servers));\n\tafs_unuse_cell(net, cell->alias_of, afs_cell_trace_unuse_alias);\n\tkey_put(cell->anonymous_key);\n\tkfree(cell->name);\n\tkfree(cell);\n\n\tafs_dec_cells_outstanding(net);\n\t_leave(\" [destroyed]\");\n}\n\n \nstatic void afs_queue_cell_manager(struct afs_net *net)\n{\n\tint outstanding = atomic_inc_return(&net->cells_outstanding);\n\n\t_enter(\"%d\", outstanding);\n\n\tif (!queue_work(afs_wq, &net->cells_manager))\n\t\tafs_dec_cells_outstanding(net);\n}\n\n \nvoid afs_cells_timer(struct timer_list *timer)\n{\n\tstruct afs_net *net = container_of(timer, struct afs_net, cells_timer);\n\n\t_enter(\"\");\n\tif (!queue_work(afs_wq, &net->cells_manager))\n\t\tafs_dec_cells_outstanding(net);\n}\n\n \nstruct afs_cell *afs_get_cell(struct afs_cell *cell, enum afs_cell_trace reason)\n{\n\tint r;\n\n\t__refcount_inc(&cell->ref, &r);\n\ttrace_afs_cell(cell->debug_id, r + 1, atomic_read(&cell->active), reason);\n\treturn cell;\n}\n\n \nvoid afs_put_cell(struct afs_cell *cell, enum afs_cell_trace reason)\n{\n\tif (cell) {\n\t\tunsigned int debug_id = cell->debug_id;\n\t\tunsigned int a;\n\t\tbool zero;\n\t\tint r;\n\n\t\ta = atomic_read(&cell->active);\n\t\tzero = __refcount_dec_and_test(&cell->ref, &r);\n\t\ttrace_afs_cell(debug_id, r - 1, a, reason);\n\t\tif (zero) {\n\t\t\ta = atomic_read(&cell->active);\n\t\t\tWARN(a != 0, \"Cell active count %u > 0\\n\", a);\n\t\t\tcall_rcu(&cell->rcu, afs_cell_destroy);\n\t\t}\n\t}\n}\n\n \nstruct afs_cell *afs_use_cell(struct afs_cell *cell, enum afs_cell_trace reason)\n{\n\tint r, a;\n\n\tr = refcount_read(&cell->ref);\n\tWARN_ON(r == 0);\n\ta = atomic_inc_return(&cell->active);\n\ttrace_afs_cell(cell->debug_id, r, a, reason);\n\treturn cell;\n}\n\n \nvoid afs_unuse_cell(struct afs_net *net, struct afs_cell *cell, enum afs_cell_trace reason)\n{\n\tunsigned int debug_id;\n\ttime64_t now, expire_delay;\n\tint r, a;\n\n\tif (!cell)\n\t\treturn;\n\n\t_enter(\"%s\", cell->name);\n\n\tnow = ktime_get_real_seconds();\n\tcell->last_inactive = now;\n\texpire_delay = 0;\n\tif (cell->vl_servers->nr_servers)\n\t\texpire_delay = afs_cell_gc_delay;\n\n\tdebug_id = cell->debug_id;\n\tr = refcount_read(&cell->ref);\n\ta = atomic_dec_return(&cell->active);\n\ttrace_afs_cell(debug_id, r, a, reason);\n\tWARN_ON(a == 0);\n\tif (a == 1)\n\t\t \n\t\tafs_set_cell_timer(net, expire_delay);\n}\n\n \nvoid afs_see_cell(struct afs_cell *cell, enum afs_cell_trace reason)\n{\n\tint r, a;\n\n\tr = refcount_read(&cell->ref);\n\ta = atomic_read(&cell->active);\n\ttrace_afs_cell(cell->debug_id, r, a, reason);\n}\n\n \nvoid afs_queue_cell(struct afs_cell *cell, enum afs_cell_trace reason)\n{\n\tafs_get_cell(cell, reason);\n\tif (!queue_work(afs_wq, &cell->manager))\n\t\tafs_put_cell(cell, afs_cell_trace_put_queue_fail);\n}\n\n \nstatic int afs_alloc_anon_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\tchar keyname[4 + AFS_MAXCELLNAME + 1], *cp, *dp;\n\n\t \n\tmemcpy(keyname, \"afs@\", 4);\n\tdp = keyname + 4;\n\tcp = cell->name;\n\tdo {\n\t\t*dp++ = tolower(*cp);\n\t} while (*cp++);\n\n\tkey = rxrpc_get_null_key(keyname);\n\tif (IS_ERR(key))\n\t\treturn PTR_ERR(key);\n\n\tcell->anonymous_key = key;\n\n\t_debug(\"anon key %p{%x}\",\n\t       cell->anonymous_key, key_serial(cell->anonymous_key));\n\treturn 0;\n}\n\n \nstatic int afs_activate_cell(struct afs_net *net, struct afs_cell *cell)\n{\n\tstruct hlist_node **p;\n\tstruct afs_cell *pcell;\n\tint ret;\n\n\tif (!cell->anonymous_key) {\n\t\tret = afs_alloc_anon_key(cell);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = afs_proc_cell_setup(cell);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&net->proc_cells_lock);\n\tfor (p = &net->proc_cells.first; *p; p = &(*p)->next) {\n\t\tpcell = hlist_entry(*p, struct afs_cell, proc_link);\n\t\tif (strcmp(cell->name, pcell->name) < 0)\n\t\t\tbreak;\n\t}\n\n\tcell->proc_link.pprev = p;\n\tcell->proc_link.next = *p;\n\trcu_assign_pointer(*p, &cell->proc_link.next);\n\tif (cell->proc_link.next)\n\t\tcell->proc_link.next->pprev = &cell->proc_link.next;\n\n\tafs_dynroot_mkdir(net, cell);\n\tmutex_unlock(&net->proc_cells_lock);\n\treturn 0;\n}\n\n \nstatic void afs_deactivate_cell(struct afs_net *net, struct afs_cell *cell)\n{\n\t_enter(\"%s\", cell->name);\n\n\tafs_proc_cell_remove(cell);\n\n\tmutex_lock(&net->proc_cells_lock);\n\thlist_del_rcu(&cell->proc_link);\n\tafs_dynroot_rmdir(net, cell);\n\tmutex_unlock(&net->proc_cells_lock);\n\n\t_leave(\"\");\n}\n\n \nstatic void afs_manage_cell(struct afs_cell *cell)\n{\n\tstruct afs_net *net = cell->net;\n\tint ret, active;\n\n\t_enter(\"%s\", cell->name);\n\nagain:\n\t_debug(\"state %u\", cell->state);\n\tswitch (cell->state) {\n\tcase AFS_CELL_INACTIVE:\n\tcase AFS_CELL_FAILED:\n\t\tdown_write(&net->cells_lock);\n\t\tactive = 1;\n\t\tif (atomic_try_cmpxchg_relaxed(&cell->active, &active, 0)) {\n\t\t\trb_erase(&cell->net_node, &net->cells);\n\t\t\ttrace_afs_cell(cell->debug_id, refcount_read(&cell->ref), 0,\n\t\t\t\t       afs_cell_trace_unuse_delete);\n\t\t\tsmp_store_release(&cell->state, AFS_CELL_REMOVED);\n\t\t}\n\t\tup_write(&net->cells_lock);\n\t\tif (cell->state == AFS_CELL_REMOVED) {\n\t\t\twake_up_var(&cell->state);\n\t\t\tgoto final_destruction;\n\t\t}\n\t\tif (cell->state == AFS_CELL_FAILED)\n\t\t\tgoto done;\n\t\tsmp_store_release(&cell->state, AFS_CELL_UNSET);\n\t\twake_up_var(&cell->state);\n\t\tgoto again;\n\n\tcase AFS_CELL_UNSET:\n\t\tsmp_store_release(&cell->state, AFS_CELL_ACTIVATING);\n\t\twake_up_var(&cell->state);\n\t\tgoto again;\n\n\tcase AFS_CELL_ACTIVATING:\n\t\tret = afs_activate_cell(net, cell);\n\t\tif (ret < 0)\n\t\t\tgoto activation_failed;\n\n\t\tsmp_store_release(&cell->state, AFS_CELL_ACTIVE);\n\t\twake_up_var(&cell->state);\n\t\tgoto again;\n\n\tcase AFS_CELL_ACTIVE:\n\t\tif (atomic_read(&cell->active) > 1) {\n\t\t\tif (test_and_clear_bit(AFS_CELL_FL_DO_LOOKUP, &cell->flags)) {\n\t\t\t\tret = afs_update_cell(cell);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tcell->error = ret;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\t\tsmp_store_release(&cell->state, AFS_CELL_DEACTIVATING);\n\t\twake_up_var(&cell->state);\n\t\tgoto again;\n\n\tcase AFS_CELL_DEACTIVATING:\n\t\tif (atomic_read(&cell->active) > 1)\n\t\t\tgoto reverse_deactivation;\n\t\tafs_deactivate_cell(net, cell);\n\t\tsmp_store_release(&cell->state, AFS_CELL_INACTIVE);\n\t\twake_up_var(&cell->state);\n\t\tgoto again;\n\n\tcase AFS_CELL_REMOVED:\n\t\tgoto done;\n\n\tdefault:\n\t\tbreak;\n\t}\n\t_debug(\"bad state %u\", cell->state);\n\tBUG();  \n\nactivation_failed:\n\tcell->error = ret;\n\tafs_deactivate_cell(net, cell);\n\n\tsmp_store_release(&cell->state, AFS_CELL_FAILED);  \n\twake_up_var(&cell->state);\n\tgoto again;\n\nreverse_deactivation:\n\tsmp_store_release(&cell->state, AFS_CELL_ACTIVE);\n\twake_up_var(&cell->state);\n\t_leave(\" [deact->act]\");\n\treturn;\n\ndone:\n\t_leave(\" [done %u]\", cell->state);\n\treturn;\n\nfinal_destruction:\n\t \n\tafs_put_volume(cell->net, cell->root_volume, afs_volume_trace_put_cell_root);\n\tcell->root_volume = NULL;\n\tafs_put_cell(cell, afs_cell_trace_put_destroy);\n}\n\nstatic void afs_manage_cell_work(struct work_struct *work)\n{\n\tstruct afs_cell *cell = container_of(work, struct afs_cell, manager);\n\n\tafs_manage_cell(cell);\n\tafs_put_cell(cell, afs_cell_trace_put_queue_work);\n}\n\n \nvoid afs_manage_cells(struct work_struct *work)\n{\n\tstruct afs_net *net = container_of(work, struct afs_net, cells_manager);\n\tstruct rb_node *cursor;\n\ttime64_t now = ktime_get_real_seconds(), next_manage = TIME64_MAX;\n\tbool purging = !net->live;\n\n\t_enter(\"\");\n\n\t \n\tdown_read(&net->cells_lock);\n\n\tfor (cursor = rb_first(&net->cells); cursor; cursor = rb_next(cursor)) {\n\t\tstruct afs_cell *cell =\n\t\t\trb_entry(cursor, struct afs_cell, net_node);\n\t\tunsigned active;\n\t\tbool sched_cell = false;\n\n\t\tactive = atomic_read(&cell->active);\n\t\ttrace_afs_cell(cell->debug_id, refcount_read(&cell->ref),\n\t\t\t       active, afs_cell_trace_manage);\n\n\t\tASSERTCMP(active, >=, 1);\n\n\t\tif (purging) {\n\t\t\tif (test_and_clear_bit(AFS_CELL_FL_NO_GC, &cell->flags)) {\n\t\t\t\tactive = atomic_dec_return(&cell->active);\n\t\t\t\ttrace_afs_cell(cell->debug_id, refcount_read(&cell->ref),\n\t\t\t\t\t       active, afs_cell_trace_unuse_pin);\n\t\t\t}\n\t\t}\n\n\t\tif (active == 1) {\n\t\t\tstruct afs_vlserver_list *vllist;\n\t\t\ttime64_t expire_at = cell->last_inactive;\n\n\t\t\tread_lock(&cell->vl_servers_lock);\n\t\t\tvllist = rcu_dereference_protected(\n\t\t\t\tcell->vl_servers,\n\t\t\t\tlockdep_is_held(&cell->vl_servers_lock));\n\t\t\tif (vllist->nr_servers > 0)\n\t\t\t\texpire_at += afs_cell_gc_delay;\n\t\t\tread_unlock(&cell->vl_servers_lock);\n\t\t\tif (purging || expire_at <= now)\n\t\t\t\tsched_cell = true;\n\t\t\telse if (expire_at < next_manage)\n\t\t\t\tnext_manage = expire_at;\n\t\t}\n\n\t\tif (!purging) {\n\t\t\tif (test_bit(AFS_CELL_FL_DO_LOOKUP, &cell->flags))\n\t\t\t\tsched_cell = true;\n\t\t}\n\n\t\tif (sched_cell)\n\t\t\tafs_queue_cell(cell, afs_cell_trace_get_queue_manage);\n\t}\n\n\tup_read(&net->cells_lock);\n\n\t \n\tif (!purging && next_manage < TIME64_MAX) {\n\t\tnow = ktime_get_real_seconds();\n\n\t\tif (next_manage - now <= 0) {\n\t\t\tif (queue_work(afs_wq, &net->cells_manager))\n\t\t\t\tatomic_inc(&net->cells_outstanding);\n\t\t} else {\n\t\t\tafs_set_cell_timer(net, next_manage - now);\n\t\t}\n\t}\n\n\tafs_dec_cells_outstanding(net);\n\t_leave(\" [%d]\", atomic_read(&net->cells_outstanding));\n}\n\n \nvoid afs_cell_purge(struct afs_net *net)\n{\n\tstruct afs_cell *ws;\n\n\t_enter(\"\");\n\n\tdown_write(&net->cells_lock);\n\tws = net->ws_cell;\n\tnet->ws_cell = NULL;\n\tup_write(&net->cells_lock);\n\tafs_unuse_cell(net, ws, afs_cell_trace_unuse_ws);\n\n\t_debug(\"del timer\");\n\tif (del_timer_sync(&net->cells_timer))\n\t\tatomic_dec(&net->cells_outstanding);\n\n\t_debug(\"kick mgr\");\n\tafs_queue_cell_manager(net);\n\n\t_debug(\"wait\");\n\twait_var_event(&net->cells_outstanding,\n\t\t       !atomic_read(&net->cells_outstanding));\n\t_leave(\"\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}