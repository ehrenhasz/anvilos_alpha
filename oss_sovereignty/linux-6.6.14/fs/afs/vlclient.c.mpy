{
  "module_name": "vlclient.c",
  "hash_id": "a70ec6600cfa5aab2fbbc43dd43d528b55554ac0d553bb4a89cdcd04918b2c8d",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/vlclient.c",
  "human_readable_source": "\n \n\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include \"afs_fs.h\"\n#include \"internal.h\"\n\n \nstatic int afs_deliver_vl_get_entry_by_name_u(struct afs_call *call)\n{\n\tstruct afs_uvldbentry__xdr *uvldb;\n\tstruct afs_vldb_entry *entry;\n\tbool new_only = false;\n\tu32 tmp, nr_servers, vlflags;\n\tint i, ret;\n\n\t_enter(\"\");\n\n\tret = afs_transfer_reply(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tuvldb = call->buffer;\n\tentry = call->ret_vldb;\n\n\tnr_servers = ntohl(uvldb->nServers);\n\tif (nr_servers > AFS_NMAXNSERVERS)\n\t\tnr_servers = AFS_NMAXNSERVERS;\n\n\tfor (i = 0; i < ARRAY_SIZE(uvldb->name) - 1; i++)\n\t\tentry->name[i] = (u8)ntohl(uvldb->name[i]);\n\tentry->name[i] = 0;\n\tentry->name_len = strlen(entry->name);\n\n\t \n\tfor (i = 0; i < nr_servers; i++) {\n\t\ttmp = ntohl(uvldb->serverFlags[i]);\n\t\tif (!(tmp & AFS_VLSF_DONTUSE) &&\n\t\t    (tmp & AFS_VLSF_NEWREPSITE))\n\t\t\tnew_only = true;\n\t}\n\n\tvlflags = ntohl(uvldb->flags);\n\tfor (i = 0; i < nr_servers; i++) {\n\t\tstruct afs_uuid__xdr *xdr;\n\t\tstruct afs_uuid *uuid;\n\t\tint j;\n\t\tint n = entry->nr_servers;\n\n\t\ttmp = ntohl(uvldb->serverFlags[i]);\n\t\tif (tmp & AFS_VLSF_DONTUSE ||\n\t\t    (new_only && !(tmp & AFS_VLSF_NEWREPSITE)))\n\t\t\tcontinue;\n\t\tif (tmp & AFS_VLSF_RWVOL) {\n\t\t\tentry->fs_mask[n] |= AFS_VOL_VTM_RW;\n\t\t\tif (vlflags & AFS_VLF_BACKEXISTS)\n\t\t\t\tentry->fs_mask[n] |= AFS_VOL_VTM_BAK;\n\t\t}\n\t\tif (tmp & AFS_VLSF_ROVOL)\n\t\t\tentry->fs_mask[n] |= AFS_VOL_VTM_RO;\n\t\tif (!entry->fs_mask[n])\n\t\t\tcontinue;\n\n\t\txdr = &uvldb->serverNumber[i];\n\t\tuuid = (struct afs_uuid *)&entry->fs_server[n];\n\t\tuuid->time_low\t\t\t= xdr->time_low;\n\t\tuuid->time_mid\t\t\t= htons(ntohl(xdr->time_mid));\n\t\tuuid->time_hi_and_version\t= htons(ntohl(xdr->time_hi_and_version));\n\t\tuuid->clock_seq_hi_and_reserved\t= (u8)ntohl(xdr->clock_seq_hi_and_reserved);\n\t\tuuid->clock_seq_low\t\t= (u8)ntohl(xdr->clock_seq_low);\n\t\tfor (j = 0; j < 6; j++)\n\t\t\tuuid->node[j] = (u8)ntohl(xdr->node[j]);\n\n\t\tentry->addr_version[n] = ntohl(uvldb->serverUnique[i]);\n\t\tentry->nr_servers++;\n\t}\n\n\tfor (i = 0; i < AFS_MAXTYPES; i++)\n\t\tentry->vid[i] = ntohl(uvldb->volumeId[i]);\n\n\tif (vlflags & AFS_VLF_RWEXISTS)\n\t\t__set_bit(AFS_VLDB_HAS_RW, &entry->flags);\n\tif (vlflags & AFS_VLF_ROEXISTS)\n\t\t__set_bit(AFS_VLDB_HAS_RO, &entry->flags);\n\tif (vlflags & AFS_VLF_BACKEXISTS)\n\t\t__set_bit(AFS_VLDB_HAS_BAK, &entry->flags);\n\n\tif (!(vlflags & (AFS_VLF_RWEXISTS | AFS_VLF_ROEXISTS | AFS_VLF_BACKEXISTS))) {\n\t\tentry->error = -ENOMEDIUM;\n\t\t__set_bit(AFS_VLDB_QUERY_ERROR, &entry->flags);\n\t}\n\n\t__set_bit(AFS_VLDB_QUERY_VALID, &entry->flags);\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\nstatic void afs_destroy_vl_get_entry_by_name_u(struct afs_call *call)\n{\n\tkfree(call->ret_vldb);\n\tafs_flat_call_destructor(call);\n}\n\n \nstatic const struct afs_call_type afs_RXVLGetEntryByNameU = {\n\t.name\t\t= \"VL.GetEntryByNameU\",\n\t.op\t\t= afs_VL_GetEntryByNameU,\n\t.deliver\t= afs_deliver_vl_get_entry_by_name_u,\n\t.destructor\t= afs_destroy_vl_get_entry_by_name_u,\n};\n\n \nstruct afs_vldb_entry *afs_vl_get_entry_by_name_u(struct afs_vl_cursor *vc,\n\t\t\t\t\t\t  const char *volname,\n\t\t\t\t\t\t  int volnamesz)\n{\n\tstruct afs_vldb_entry *entry;\n\tstruct afs_call *call;\n\tstruct afs_net *net = vc->cell->net;\n\tsize_t reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tpadsz = (4 - (volnamesz & 3)) & 3;\n\treqsz = 8 + volnamesz + padsz;\n\n\tentry = kzalloc(sizeof(struct afs_vldb_entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcall = afs_alloc_flat_call(net, &afs_RXVLGetEntryByNameU, reqsz,\n\t\t\t\t   sizeof(struct afs_uvldbentry__xdr));\n\tif (!call) {\n\t\tkfree(entry);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tcall->key = vc->key;\n\tcall->ret_vldb = entry;\n\tcall->max_lifespan = AFS_VL_MAX_LIFESPAN;\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(VLGETENTRYBYNAMEU);\n\t*bp++ = htonl(volnamesz);\n\tmemcpy(bp, volname, volnamesz);\n\tif (padsz > 0)\n\t\tmemset((void *)bp + volnamesz, 0, padsz);\n\n\ttrace_afs_make_vl_call(call);\n\tafs_make_call(&vc->ac, call, GFP_KERNEL);\n\treturn (struct afs_vldb_entry *)afs_wait_for_call_to_complete(call, &vc->ac);\n}\n\n \nstatic int afs_deliver_vl_get_addrs_u(struct afs_call *call)\n{\n\tstruct afs_addr_list *alist;\n\t__be32 *bp;\n\tu32 uniquifier, nentries, count;\n\tint i, ret;\n\n\t_enter(\"{%u,%zu/%u}\",\n\t       call->unmarshall, iov_iter_count(call->iter), call->count);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tafs_extract_to_buf(call,\n\t\t\t\t   sizeof(struct afs_uuid__xdr) + 3 * sizeof(__be32));\n\t\tcall->unmarshall++;\n\n\t\t \n\t\tfallthrough;\n\tcase 1:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbp = call->buffer + sizeof(struct afs_uuid__xdr);\n\t\tuniquifier\t= ntohl(*bp++);\n\t\tnentries\t= ntohl(*bp++);\n\t\tcount\t\t= ntohl(*bp);\n\n\t\tnentries = min(nentries, count);\n\t\talist = afs_alloc_addrlist(nentries, FS_SERVICE, AFS_FS_PORT);\n\t\tif (!alist)\n\t\t\treturn -ENOMEM;\n\t\talist->version = uniquifier;\n\t\tcall->ret_alist = alist;\n\t\tcall->count = count;\n\t\tcall->count2 = nentries;\n\t\tcall->unmarshall++;\n\n\tmore_entries:\n\t\tcount = min(call->count, 4U);\n\t\tafs_extract_to_buf(call, count * sizeof(__be32));\n\n\t\tfallthrough;\t \n\tcase 2:\n\t\tret = afs_extract_data(call, call->count > 4);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\talist = call->ret_alist;\n\t\tbp = call->buffer;\n\t\tcount = min(call->count, 4U);\n\t\tfor (i = 0; i < count; i++)\n\t\t\tif (alist->nr_addrs < call->count2)\n\t\t\t\tafs_merge_fs_addr4(alist, *bp++, AFS_FS_PORT);\n\n\t\tcall->count -= count;\n\t\tif (call->count > 0)\n\t\t\tgoto more_entries;\n\t\tcall->unmarshall++;\n\t\tbreak;\n\t}\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\nstatic void afs_vl_get_addrs_u_destructor(struct afs_call *call)\n{\n\tafs_put_addrlist(call->ret_alist);\n\treturn afs_flat_call_destructor(call);\n}\n\n \nstatic const struct afs_call_type afs_RXVLGetAddrsU = {\n\t.name\t\t= \"VL.GetAddrsU\",\n\t.op\t\t= afs_VL_GetAddrsU,\n\t.deliver\t= afs_deliver_vl_get_addrs_u,\n\t.destructor\t= afs_vl_get_addrs_u_destructor,\n};\n\n \nstruct afs_addr_list *afs_vl_get_addrs_u(struct afs_vl_cursor *vc,\n\t\t\t\t\t const uuid_t *uuid)\n{\n\tstruct afs_ListAddrByAttributes__xdr *r;\n\tconst struct afs_uuid *u = (const struct afs_uuid *)uuid;\n\tstruct afs_call *call;\n\tstruct afs_net *net = vc->cell->net;\n\t__be32 *bp;\n\tint i;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(net, &afs_RXVLGetAddrsU,\n\t\t\t\t   sizeof(__be32) + sizeof(struct afs_ListAddrByAttributes__xdr),\n\t\t\t\t   sizeof(struct afs_uuid__xdr) + 3 * sizeof(__be32));\n\tif (!call)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcall->key = vc->key;\n\tcall->ret_alist = NULL;\n\tcall->max_lifespan = AFS_VL_MAX_LIFESPAN;\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(VLGETADDRSU);\n\tr = (struct afs_ListAddrByAttributes__xdr *)bp;\n\tr->Mask\t\t= htonl(AFS_VLADDR_UUID);\n\tr->ipaddr\t= 0;\n\tr->index\t= 0;\n\tr->spare\t= 0;\n\tr->uuid.time_low\t\t\t= u->time_low;\n\tr->uuid.time_mid\t\t\t= htonl(ntohs(u->time_mid));\n\tr->uuid.time_hi_and_version\t\t= htonl(ntohs(u->time_hi_and_version));\n\tr->uuid.clock_seq_hi_and_reserved \t= htonl(u->clock_seq_hi_and_reserved);\n\tr->uuid.clock_seq_low\t\t\t= htonl(u->clock_seq_low);\n\tfor (i = 0; i < 6; i++)\n\t\tr->uuid.node[i] = htonl(u->node[i]);\n\n\ttrace_afs_make_vl_call(call);\n\tafs_make_call(&vc->ac, call, GFP_KERNEL);\n\treturn (struct afs_addr_list *)afs_wait_for_call_to_complete(call, &vc->ac);\n}\n\n \nstatic int afs_deliver_vl_get_capabilities(struct afs_call *call)\n{\n\tu32 count;\n\tint ret;\n\n\t_enter(\"{%u,%zu/%u}\",\n\t       call->unmarshall, iov_iter_count(call->iter), call->count);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tafs_extract_to_tmp(call);\n\t\tcall->unmarshall++;\n\n\t\tfallthrough;\t \n\tcase 1:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcount = ntohl(call->tmp);\n\t\tcall->count = count;\n\t\tcall->count2 = count;\n\n\t\tcall->unmarshall++;\n\t\tafs_extract_discard(call, count * sizeof(__be32));\n\n\t\tfallthrough;\t \n\tcase 2:\n\t\tret = afs_extract_data(call, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\n\t\tcall->unmarshall++;\n\t\tbreak;\n\t}\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\nstatic void afs_destroy_vl_get_capabilities(struct afs_call *call)\n{\n\tafs_put_vlserver(call->net, call->vlserver);\n\tafs_flat_call_destructor(call);\n}\n\n \nstatic const struct afs_call_type afs_RXVLGetCapabilities = {\n\t.name\t\t= \"VL.GetCapabilities\",\n\t.op\t\t= afs_VL_GetCapabilities,\n\t.deliver\t= afs_deliver_vl_get_capabilities,\n\t.done\t\t= afs_vlserver_probe_result,\n\t.destructor\t= afs_destroy_vl_get_capabilities,\n};\n\n \nstruct afs_call *afs_vl_get_capabilities(struct afs_net *net,\n\t\t\t\t\t struct afs_addr_cursor *ac,\n\t\t\t\t\t struct key *key,\n\t\t\t\t\t struct afs_vlserver *server,\n\t\t\t\t\t unsigned int server_index)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(net, &afs_RXVLGetCapabilities, 1 * 4, 16 * 4);\n\tif (!call)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcall->key = key;\n\tcall->vlserver = afs_get_vlserver(server);\n\tcall->server_index = server_index;\n\tcall->upgrade = true;\n\tcall->async = true;\n\tcall->max_lifespan = AFS_PROBE_MAX_LIFESPAN;\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(VLGETCAPABILITIES);\n\n\t \n\ttrace_afs_make_vl_call(call);\n\tafs_make_call(ac, call, GFP_KERNEL);\n\treturn call;\n}\n\n \nstatic int afs_deliver_yfsvl_get_endpoints(struct afs_call *call)\n{\n\tstruct afs_addr_list *alist;\n\t__be32 *bp;\n\tu32 uniquifier, size;\n\tint ret;\n\n\t_enter(\"{%u,%zu,%u}\",\n\t       call->unmarshall, iov_iter_count(call->iter), call->count2);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tafs_extract_to_buf(call, sizeof(uuid_t) + 3 * sizeof(__be32));\n\t\tcall->unmarshall = 1;\n\n\t\t \n\t\tfallthrough;\n\tcase 1:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbp = call->buffer + sizeof(uuid_t);\n\t\tuniquifier\t= ntohl(*bp++);\n\t\tcall->count\t= ntohl(*bp++);\n\t\tcall->count2\t= ntohl(*bp);  \n\n\t\tif (call->count > YFS_MAXENDPOINTS)\n\t\t\treturn afs_protocol_error(call, afs_eproto_yvl_fsendpt_num);\n\n\t\talist = afs_alloc_addrlist(call->count, FS_SERVICE, AFS_FS_PORT);\n\t\tif (!alist)\n\t\t\treturn -ENOMEM;\n\t\talist->version = uniquifier;\n\t\tcall->ret_alist = alist;\n\n\t\tif (call->count == 0)\n\t\t\tgoto extract_volendpoints;\n\n\tnext_fsendpoint:\n\t\tswitch (call->count2) {\n\t\tcase YFS_ENDPOINT_IPV4:\n\t\t\tsize = sizeof(__be32) * (1 + 1 + 1);\n\t\t\tbreak;\n\t\tcase YFS_ENDPOINT_IPV6:\n\t\t\tsize = sizeof(__be32) * (1 + 4 + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn afs_protocol_error(call, afs_eproto_yvl_fsendpt_type);\n\t\t}\n\n\t\tsize += sizeof(__be32);\n\t\tafs_extract_to_buf(call, size);\n\t\tcall->unmarshall = 2;\n\n\t\tfallthrough;\t \n\tcase 2:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\talist = call->ret_alist;\n\t\tbp = call->buffer;\n\t\tswitch (call->count2) {\n\t\tcase YFS_ENDPOINT_IPV4:\n\t\t\tif (ntohl(bp[0]) != sizeof(__be32) * 2)\n\t\t\t\treturn afs_protocol_error(\n\t\t\t\t\tcall, afs_eproto_yvl_fsendpt4_len);\n\t\t\tafs_merge_fs_addr4(alist, bp[1], ntohl(bp[2]));\n\t\t\tbp += 3;\n\t\t\tbreak;\n\t\tcase YFS_ENDPOINT_IPV6:\n\t\t\tif (ntohl(bp[0]) != sizeof(__be32) * 5)\n\t\t\t\treturn afs_protocol_error(\n\t\t\t\t\tcall, afs_eproto_yvl_fsendpt6_len);\n\t\t\tafs_merge_fs_addr6(alist, bp + 1, ntohl(bp[5]));\n\t\t\tbp += 6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn afs_protocol_error(call, afs_eproto_yvl_fsendpt_type);\n\t\t}\n\n\t\t \n\t\tcall->count2 = ntohl(*bp++);\n\n\t\tcall->count--;\n\t\tif (call->count > 0)\n\t\t\tgoto next_fsendpoint;\n\n\textract_volendpoints:\n\t\t \n\t\tcall->count = call->count2;\n\t\tif (!call->count)\n\t\t\tgoto end;\n\t\tif (call->count > YFS_MAXENDPOINTS)\n\t\t\treturn afs_protocol_error(call, afs_eproto_yvl_vlendpt_type);\n\n\t\tafs_extract_to_buf(call, 1 * sizeof(__be32));\n\t\tcall->unmarshall = 3;\n\n\t\t \n\t\tfallthrough;\n\tcase 3:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbp = call->buffer;\n\n\tnext_volendpoint:\n\t\tcall->count2 = ntohl(*bp++);\n\t\tswitch (call->count2) {\n\t\tcase YFS_ENDPOINT_IPV4:\n\t\t\tsize = sizeof(__be32) * (1 + 1 + 1);\n\t\t\tbreak;\n\t\tcase YFS_ENDPOINT_IPV6:\n\t\t\tsize = sizeof(__be32) * (1 + 4 + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn afs_protocol_error(call, afs_eproto_yvl_vlendpt_type);\n\t\t}\n\n\t\tif (call->count > 1)\n\t\t\tsize += sizeof(__be32);  \n\t\tafs_extract_to_buf(call, size);\n\t\tcall->unmarshall = 4;\n\n\t\tfallthrough;\t \n\tcase 4:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbp = call->buffer;\n\t\tswitch (call->count2) {\n\t\tcase YFS_ENDPOINT_IPV4:\n\t\t\tif (ntohl(bp[0]) != sizeof(__be32) * 2)\n\t\t\t\treturn afs_protocol_error(\n\t\t\t\t\tcall, afs_eproto_yvl_vlendpt4_len);\n\t\t\tbp += 3;\n\t\t\tbreak;\n\t\tcase YFS_ENDPOINT_IPV6:\n\t\t\tif (ntohl(bp[0]) != sizeof(__be32) * 5)\n\t\t\t\treturn afs_protocol_error(\n\t\t\t\t\tcall, afs_eproto_yvl_vlendpt6_len);\n\t\t\tbp += 6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn afs_protocol_error(call, afs_eproto_yvl_vlendpt_type);\n\t\t}\n\n\t\t \n\t\tcall->count--;\n\t\tif (call->count > 0)\n\t\t\tgoto next_volendpoint;\n\n\tend:\n\t\tafs_extract_discard(call, 0);\n\t\tcall->unmarshall = 5;\n\n\t\tfallthrough;\t \n\tcase 5:\n\t\tret = afs_extract_data(call, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tcall->unmarshall = 6;\n\t\tfallthrough;\n\n\tcase 6:\n\t\tbreak;\n\t}\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type afs_YFSVLGetEndpoints = {\n\t.name\t\t= \"YFSVL.GetEndpoints\",\n\t.op\t\t= afs_YFSVL_GetEndpoints,\n\t.deliver\t= afs_deliver_yfsvl_get_endpoints,\n\t.destructor\t= afs_vl_get_addrs_u_destructor,\n};\n\n \nstruct afs_addr_list *afs_yfsvl_get_endpoints(struct afs_vl_cursor *vc,\n\t\t\t\t\t      const uuid_t *uuid)\n{\n\tstruct afs_call *call;\n\tstruct afs_net *net = vc->cell->net;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(net, &afs_YFSVLGetEndpoints,\n\t\t\t\t   sizeof(__be32) * 2 + sizeof(*uuid),\n\t\t\t\t   sizeof(struct in6_addr) + sizeof(__be32) * 3);\n\tif (!call)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcall->key = vc->key;\n\tcall->ret_alist = NULL;\n\tcall->max_lifespan = AFS_VL_MAX_LIFESPAN;\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(YVLGETENDPOINTS);\n\t*bp++ = htonl(YFS_SERVER_UUID);\n\tmemcpy(bp, uuid, sizeof(*uuid));  \n\n\ttrace_afs_make_vl_call(call);\n\tafs_make_call(&vc->ac, call, GFP_KERNEL);\n\treturn (struct afs_addr_list *)afs_wait_for_call_to_complete(call, &vc->ac);\n}\n\n \nstatic int afs_deliver_yfsvl_get_cell_name(struct afs_call *call)\n{\n\tchar *cell_name;\n\tu32 namesz, paddedsz;\n\tint ret;\n\n\t_enter(\"{%u,%zu/%u}\",\n\t       call->unmarshall, iov_iter_count(call->iter), call->count);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tafs_extract_to_tmp(call);\n\t\tcall->unmarshall++;\n\n\t\tfallthrough;\t \n\tcase 1:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tnamesz = ntohl(call->tmp);\n\t\tif (namesz > AFS_MAXCELLNAME)\n\t\t\treturn afs_protocol_error(call, afs_eproto_cellname_len);\n\t\tpaddedsz = (namesz + 3) & ~3;\n\t\tcall->count = namesz;\n\t\tcall->count2 = paddedsz - namesz;\n\n\t\tcell_name = kmalloc(namesz + 1, GFP_KERNEL);\n\t\tif (!cell_name)\n\t\t\treturn -ENOMEM;\n\t\tcell_name[namesz] = 0;\n\t\tcall->ret_str = cell_name;\n\n\t\tafs_extract_begin(call, cell_name, namesz);\n\t\tcall->unmarshall++;\n\n\t\tfallthrough;\t \n\tcase 2:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tafs_extract_discard(call, call->count2);\n\t\tcall->unmarshall++;\n\n\t\tfallthrough;\t \n\tcase 3:\n\t\tret = afs_extract_data(call, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcall->unmarshall++;\n\t\tbreak;\n\t}\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\nstatic void afs_destroy_yfsvl_get_cell_name(struct afs_call *call)\n{\n\tkfree(call->ret_str);\n\tafs_flat_call_destructor(call);\n}\n\n \nstatic const struct afs_call_type afs_YFSVLGetCellName = {\n\t.name\t\t= \"YFSVL.GetCellName\",\n\t.op\t\t= afs_YFSVL_GetCellName,\n\t.deliver\t= afs_deliver_yfsvl_get_cell_name,\n\t.destructor\t= afs_destroy_yfsvl_get_cell_name,\n};\n\n \nchar *afs_yfsvl_get_cell_name(struct afs_vl_cursor *vc)\n{\n\tstruct afs_call *call;\n\tstruct afs_net *net = vc->cell->net;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(net, &afs_YFSVLGetCellName, 1 * 4, 0);\n\tif (!call)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcall->key = vc->key;\n\tcall->ret_str = NULL;\n\tcall->max_lifespan = AFS_VL_MAX_LIFESPAN;\n\n\t \n\tbp = call->request;\n\t*bp++ = htonl(YVLGETCELLNAME);\n\n\t \n\ttrace_afs_make_vl_call(call);\n\tafs_make_call(&vc->ac, call, GFP_KERNEL);\n\treturn (char *)afs_wait_for_call_to_complete(call, &vc->ac);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}