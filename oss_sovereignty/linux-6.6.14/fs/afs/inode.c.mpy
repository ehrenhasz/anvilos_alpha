{
  "module_name": "inode.c",
  "hash_id": "61d14d666c72278d84c78602a593eff3e4db1131f291a116b9ee4e69e8227a06",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/inode.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/iversion.h>\n#include \"internal.h\"\n#include \"afs_fs.h\"\n\nstatic const struct inode_operations afs_symlink_inode_operations = {\n\t.get_link\t= page_get_link,\n};\n\nstatic noinline void dump_vnode(struct afs_vnode *vnode, struct afs_vnode *parent_vnode)\n{\n\tstatic unsigned long once_only;\n\n\tpr_warn(\"kAFS: AFS vnode with undefined type %u\\n\", vnode->status.type);\n\tpr_warn(\"kAFS: A=%d m=%o s=%llx v=%llx\\n\",\n\t\tvnode->status.abort_code,\n\t\tvnode->status.mode,\n\t\tvnode->status.size,\n\t\tvnode->status.data_version);\n\tpr_warn(\"kAFS: vnode %llx:%llx:%x\\n\",\n\t\tvnode->fid.vid,\n\t\tvnode->fid.vnode,\n\t\tvnode->fid.unique);\n\tif (parent_vnode)\n\t\tpr_warn(\"kAFS: dir %llx:%llx:%x\\n\",\n\t\t\tparent_vnode->fid.vid,\n\t\t\tparent_vnode->fid.vnode,\n\t\t\tparent_vnode->fid.unique);\n\n\tif (!test_and_set_bit(0, &once_only))\n\t\tdump_stack();\n}\n\n \nstatic void afs_set_netfs_context(struct afs_vnode *vnode)\n{\n\tnetfs_inode_init(&vnode->netfs, &afs_req_ops);\n}\n\n \nstatic int afs_inode_init_from_status(struct afs_operation *op,\n\t\t\t\t      struct afs_vnode_param *vp,\n\t\t\t\t      struct afs_vnode *vnode)\n{\n\tstruct afs_file_status *status = &vp->scb.status;\n\tstruct inode *inode = AFS_VNODE_TO_I(vnode);\n\tstruct timespec64 t;\n\n\t_enter(\"{%llx:%llu.%u} %s\",\n\t       vp->fid.vid, vp->fid.vnode, vp->fid.unique,\n\t       op->type ? op->type->name : \"???\");\n\n\t_debug(\"FS: ft=%d lk=%d sz=%llu ver=%Lu mod=%hu\",\n\t       status->type,\n\t       status->nlink,\n\t       (unsigned long long) status->size,\n\t       status->data_version,\n\t       status->mode);\n\n\twrite_seqlock(&vnode->cb_lock);\n\n\tvnode->cb_v_break = op->cb_v_break;\n\tvnode->cb_s_break = op->cb_s_break;\n\tvnode->status = *status;\n\n\tt = status->mtime_client;\n\tinode_set_ctime_to_ts(inode, t);\n\tinode->i_mtime = t;\n\tinode->i_atime = t;\n\tinode->i_flags |= S_NOATIME;\n\tinode->i_uid = make_kuid(&init_user_ns, status->owner);\n\tinode->i_gid = make_kgid(&init_user_ns, status->group);\n\tset_nlink(&vnode->netfs.inode, status->nlink);\n\n\tswitch (status->type) {\n\tcase AFS_FTYPE_FILE:\n\t\tinode->i_mode\t= S_IFREG | (status->mode & S_IALLUGO);\n\t\tinode->i_op\t= &afs_file_inode_operations;\n\t\tinode->i_fop\t= &afs_file_operations;\n\t\tinode->i_mapping->a_ops\t= &afs_file_aops;\n\t\tmapping_set_large_folios(inode->i_mapping);\n\t\tbreak;\n\tcase AFS_FTYPE_DIR:\n\t\tinode->i_mode\t= S_IFDIR |  (status->mode & S_IALLUGO);\n\t\tinode->i_op\t= &afs_dir_inode_operations;\n\t\tinode->i_fop\t= &afs_dir_file_operations;\n\t\tinode->i_mapping->a_ops\t= &afs_dir_aops;\n\t\tmapping_set_large_folios(inode->i_mapping);\n\t\tbreak;\n\tcase AFS_FTYPE_SYMLINK:\n\t\t \n\t\tif ((status->mode & 0777) == 0644) {\n\t\t\tinode->i_flags |= S_AUTOMOUNT;\n\n\t\t\tset_bit(AFS_VNODE_MOUNTPOINT, &vnode->flags);\n\n\t\t\tinode->i_mode\t= S_IFDIR | 0555;\n\t\t\tinode->i_op\t= &afs_mntpt_inode_operations;\n\t\t\tinode->i_fop\t= &afs_mntpt_file_operations;\n\t\t\tinode->i_mapping->a_ops\t= &afs_symlink_aops;\n\t\t} else {\n\t\t\tinode->i_mode\t= S_IFLNK | status->mode;\n\t\t\tinode->i_op\t= &afs_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops\t= &afs_symlink_aops;\n\t\t}\n\t\tinode_nohighmem(inode);\n\t\tbreak;\n\tdefault:\n\t\tdump_vnode(vnode, op->file[0].vnode != vnode ? op->file[0].vnode : NULL);\n\t\twrite_sequnlock(&vnode->cb_lock);\n\t\treturn afs_protocol_error(NULL, afs_eproto_file_type);\n\t}\n\n\tafs_set_i_size(vnode, status->size);\n\tafs_set_netfs_context(vnode);\n\n\tvnode->invalid_before\t= status->data_version;\n\tinode_set_iversion_raw(&vnode->netfs.inode, status->data_version);\n\n\tif (!vp->scb.have_cb) {\n\t\t \n\t\tvnode->cb_expires_at = ktime_get_real_seconds();\n\t} else {\n\t\tvnode->cb_expires_at = vp->scb.callback.expires_at;\n\t\tvnode->cb_server = op->server;\n\t\tset_bit(AFS_VNODE_CB_PROMISED, &vnode->flags);\n\t}\n\n\twrite_sequnlock(&vnode->cb_lock);\n\treturn 0;\n}\n\n \nstatic void afs_apply_status(struct afs_operation *op,\n\t\t\t     struct afs_vnode_param *vp)\n{\n\tstruct afs_file_status *status = &vp->scb.status;\n\tstruct afs_vnode *vnode = vp->vnode;\n\tstruct inode *inode = &vnode->netfs.inode;\n\tstruct timespec64 t;\n\tumode_t mode;\n\tbool data_changed = false;\n\tbool change_size = vp->set_size;\n\n\t_enter(\"{%llx:%llu.%u} %s\",\n\t       vp->fid.vid, vp->fid.vnode, vp->fid.unique,\n\t       op->type ? op->type->name : \"???\");\n\n\tBUG_ON(test_bit(AFS_VNODE_UNSET, &vnode->flags));\n\n\tif (status->type != vnode->status.type) {\n\t\tpr_warn(\"Vnode %llx:%llx:%x changed type %u to %u\\n\",\n\t\t\tvnode->fid.vid,\n\t\t\tvnode->fid.vnode,\n\t\t\tvnode->fid.unique,\n\t\t\tstatus->type, vnode->status.type);\n\t\tafs_protocol_error(NULL, afs_eproto_bad_status);\n\t\treturn;\n\t}\n\n\tif (status->nlink != vnode->status.nlink)\n\t\tset_nlink(inode, status->nlink);\n\n\tif (status->owner != vnode->status.owner)\n\t\tinode->i_uid = make_kuid(&init_user_ns, status->owner);\n\n\tif (status->group != vnode->status.group)\n\t\tinode->i_gid = make_kgid(&init_user_ns, status->group);\n\n\tif (status->mode != vnode->status.mode) {\n\t\tmode = inode->i_mode;\n\t\tmode &= ~S_IALLUGO;\n\t\tmode |= status->mode & S_IALLUGO;\n\t\tWRITE_ONCE(inode->i_mode, mode);\n\t}\n\n\tt = status->mtime_client;\n\tinode->i_mtime = t;\n\tif (vp->update_ctime)\n\t\tinode_set_ctime_to_ts(inode, op->ctime);\n\n\tif (vnode->status.data_version != status->data_version)\n\t\tdata_changed = true;\n\n\tvnode->status = *status;\n\n\tif (vp->dv_before + vp->dv_delta != status->data_version) {\n\t\tif (test_bit(AFS_VNODE_CB_PROMISED, &vnode->flags))\n\t\t\tpr_warn(\"kAFS: vnode modified {%llx:%llu} %llx->%llx %s (op=%x)\\n\",\n\t\t\t\tvnode->fid.vid, vnode->fid.vnode,\n\t\t\t\t(unsigned long long)vp->dv_before + vp->dv_delta,\n\t\t\t\t(unsigned long long)status->data_version,\n\t\t\t\top->type ? op->type->name : \"???\",\n\t\t\t\top->debug_id);\n\n\t\tvnode->invalid_before = status->data_version;\n\t\tif (vnode->status.type == AFS_FTYPE_DIR) {\n\t\t\tif (test_and_clear_bit(AFS_VNODE_DIR_VALID, &vnode->flags))\n\t\t\t\tafs_stat_v(vnode, n_inval);\n\t\t} else {\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t\tchange_size = true;\n\t\tdata_changed = true;\n\t} else if (vnode->status.type == AFS_FTYPE_DIR) {\n\t\t \n\t\tif (test_bit(AFS_VNODE_DIR_VALID, &vnode->flags))\n\t\t\tdata_changed = false;\n\t\tchange_size = true;\n\t}\n\n\tif (data_changed) {\n\t\tinode_set_iversion_raw(inode, status->data_version);\n\n\t\t \n\t\tvnode->netfs.remote_i_size = status->size;\n\t\tif (change_size) {\n\t\t\tafs_set_i_size(vnode, status->size);\n\t\t\tinode_set_ctime_to_ts(inode, t);\n\t\t\tinode->i_atime = t;\n\t\t}\n\t}\n}\n\n \nstatic void afs_apply_callback(struct afs_operation *op,\n\t\t\t       struct afs_vnode_param *vp)\n{\n\tstruct afs_callback *cb = &vp->scb.callback;\n\tstruct afs_vnode *vnode = vp->vnode;\n\n\tif (!afs_cb_is_broken(vp->cb_break_before, vnode)) {\n\t\tvnode->cb_expires_at\t= cb->expires_at;\n\t\tvnode->cb_server\t= op->server;\n\t\tset_bit(AFS_VNODE_CB_PROMISED, &vnode->flags);\n\t}\n}\n\n \nvoid afs_vnode_commit_status(struct afs_operation *op, struct afs_vnode_param *vp)\n{\n\tstruct afs_vnode *vnode = vp->vnode;\n\n\t_enter(\"\");\n\n\twrite_seqlock(&vnode->cb_lock);\n\n\tif (vp->scb.have_error) {\n\t\t \n\t\tif (vp->scb.status.abort_code == VNOVNODE) {\n\t\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\t\tclear_nlink(&vnode->netfs.inode);\n\t\t\t__afs_break_callback(vnode, afs_cb_break_for_deleted);\n\t\t\top->flags &= ~AFS_OPERATION_DIR_CONFLICT;\n\t\t}\n\t} else if (vp->scb.have_status) {\n\t\tif (vp->speculative &&\n\t\t    (test_bit(AFS_VNODE_MODIFYING, &vnode->flags) ||\n\t\t     vp->dv_before != vnode->status.data_version))\n\t\t\t \n\t\t\tgoto out;\n\t\tafs_apply_status(op, vp);\n\t\tif (vp->scb.have_cb)\n\t\t\tafs_apply_callback(op, vp);\n\t} else if (vp->op_unlinked && !(op->flags & AFS_OPERATION_DIR_CONFLICT)) {\n\t\tdrop_nlink(&vnode->netfs.inode);\n\t\tif (vnode->netfs.inode.i_nlink == 0) {\n\t\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\t\t__afs_break_callback(vnode, afs_cb_break_for_deleted);\n\t\t}\n\t}\n\nout:\n\twrite_sequnlock(&vnode->cb_lock);\n\n\tif (vp->scb.have_status)\n\t\tafs_cache_permit(vnode, op->key, vp->cb_break_before, &vp->scb);\n}\n\nstatic void afs_fetch_status_success(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[op->fetch_status.which];\n\tstruct afs_vnode *vnode = vp->vnode;\n\tint ret;\n\n\tif (vnode->netfs.inode.i_state & I_NEW) {\n\t\tret = afs_inode_init_from_status(op, vp, vnode);\n\t\top->error = ret;\n\t\tif (ret == 0)\n\t\t\tafs_cache_permit(vnode, op->key, vp->cb_break_before, &vp->scb);\n\t} else {\n\t\tafs_vnode_commit_status(op, vp);\n\t}\n}\n\nconst struct afs_operation_ops afs_fetch_status_operation = {\n\t.issue_afs_rpc\t= afs_fs_fetch_status,\n\t.issue_yfs_rpc\t= yfs_fs_fetch_status,\n\t.success\t= afs_fetch_status_success,\n\t.aborted\t= afs_check_for_remote_deletion,\n};\n\n \nint afs_fetch_status(struct afs_vnode *vnode, struct key *key, bool is_new,\n\t\t     afs_access_t *_caller_access)\n{\n\tstruct afs_operation *op;\n\n\t_enter(\"%s,{%llx:%llu.%u,S=%lx}\",\n\t       vnode->volume->name,\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique,\n\t       vnode->flags);\n\n\top = afs_alloc_operation(key, vnode->volume);\n\tif (IS_ERR(op))\n\t\treturn PTR_ERR(op);\n\n\tafs_op_set_vnode(op, 0, vnode);\n\n\top->nr_files\t= 1;\n\top->ops\t\t= &afs_fetch_status_operation;\n\tafs_begin_vnode_operation(op);\n\tafs_wait_for_operation(op);\n\n\tif (_caller_access)\n\t\t*_caller_access = op->file[0].scb.status.caller_access;\n\treturn afs_put_operation(op);\n}\n\n \nint afs_ilookup5_test_by_fid(struct inode *inode, void *opaque)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct afs_fid *fid = opaque;\n\n\treturn (fid->vnode == vnode->fid.vnode &&\n\t\tfid->vnode_hi == vnode->fid.vnode_hi &&\n\t\tfid->unique == vnode->fid.unique);\n}\n\n \nstatic int afs_iget5_test(struct inode *inode, void *opaque)\n{\n\tstruct afs_vnode_param *vp = opaque;\n\t\n\n\treturn afs_ilookup5_test_by_fid(inode, &vp->fid);\n}\n\n \nstatic int afs_iget5_set(struct inode *inode, void *opaque)\n{\n\tstruct afs_vnode_param *vp = opaque;\n\tstruct afs_super_info *as = AFS_FS_S(inode->i_sb);\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\n\tvnode->volume\t\t= as->volume;\n\tvnode->fid\t\t= vp->fid;\n\n\t \n\tinode->i_ino\t\t= vnode->fid.vnode;\n\tinode->i_generation\t= vnode->fid.unique;\n\treturn 0;\n}\n\n \nstatic void afs_get_inode_cache(struct afs_vnode *vnode)\n{\n#ifdef CONFIG_AFS_FSCACHE\n\tstruct {\n\t\t__be32 vnode_id;\n\t\t__be32 unique;\n\t\t__be32 vnode_id_ext[2];\t \n\t} __packed key;\n\tstruct afs_vnode_cache_aux aux;\n\n\tif (vnode->status.type != AFS_FTYPE_FILE) {\n\t\tvnode->netfs.cache = NULL;\n\t\treturn;\n\t}\n\n\tkey.vnode_id\t\t= htonl(vnode->fid.vnode);\n\tkey.unique\t\t= htonl(vnode->fid.unique);\n\tkey.vnode_id_ext[0]\t= htonl(vnode->fid.vnode >> 32);\n\tkey.vnode_id_ext[1]\t= htonl(vnode->fid.vnode_hi);\n\tafs_set_cache_aux(vnode, &aux);\n\n\tafs_vnode_set_cache(vnode,\n\t\t\t    fscache_acquire_cookie(\n\t\t\t\t    vnode->volume->cache,\n\t\t\t\t    vnode->status.type == AFS_FTYPE_FILE ?\n\t\t\t\t    0 : FSCACHE_ADV_SINGLE_CHUNK,\n\t\t\t\t    &key, sizeof(key),\n\t\t\t\t    &aux, sizeof(aux),\n\t\t\t\t    i_size_read(&vnode->netfs.inode)));\n#endif\n}\n\n \nstruct inode *afs_iget(struct afs_operation *op, struct afs_vnode_param *vp)\n{\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct super_block *sb = dvp->vnode->netfs.inode.i_sb;\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\tint ret;\n\n\t_enter(\",{%llx:%llu.%u},,\", vp->fid.vid, vp->fid.vnode, vp->fid.unique);\n\n\tinode = iget5_locked(sb, vp->fid.vnode, afs_iget5_test, afs_iget5_set, vp);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tvnode = AFS_FS_I(inode);\n\n\t_debug(\"GOT INODE %p { vl=%llx vn=%llx, u=%x }\",\n\t       inode, vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\n\t \n\tif (!(inode->i_state & I_NEW)) {\n\t\t_leave(\" = %p\", inode);\n\t\treturn inode;\n\t}\n\n\tret = afs_inode_init_from_status(op, vp, vnode);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\n\tafs_get_inode_cache(vnode);\n\n\t \n\tclear_bit(AFS_VNODE_UNSET, &vnode->flags);\n\tunlock_new_inode(inode);\n\t_leave(\" = %p\", inode);\n\treturn inode;\n\n\t \nbad_inode:\n\tiget_failed(inode);\n\t_leave(\" = %d [bad]\", ret);\n\treturn ERR_PTR(ret);\n}\n\nstatic int afs_iget5_set_root(struct inode *inode, void *opaque)\n{\n\tstruct afs_super_info *as = AFS_FS_S(inode->i_sb);\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\n\tvnode->volume\t\t= as->volume;\n\tvnode->fid.vid\t\t= as->volume->vid,\n\tvnode->fid.vnode\t= 1;\n\tvnode->fid.unique\t= 1;\n\tinode->i_ino\t\t= 1;\n\tinode->i_generation\t= 1;\n\treturn 0;\n}\n\n \nstruct inode *afs_root_iget(struct super_block *sb, struct key *key)\n{\n\tstruct afs_super_info *as = AFS_FS_S(sb);\n\tstruct afs_operation *op;\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\tint ret;\n\n\t_enter(\",{%llx},,\", as->volume->vid);\n\n\tinode = iget5_locked(sb, 1, NULL, afs_iget5_set_root, NULL);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT ROOT INODE %p { vl=%llx }\", inode, as->volume->vid);\n\n\tBUG_ON(!(inode->i_state & I_NEW));\n\n\tvnode = AFS_FS_I(inode);\n\tvnode->cb_v_break = as->volume->cb_v_break,\n\tafs_set_netfs_context(vnode);\n\n\top = afs_alloc_operation(key, as->volume);\n\tif (IS_ERR(op)) {\n\t\tret = PTR_ERR(op);\n\t\tgoto error;\n\t}\n\n\tafs_op_set_vnode(op, 0, vnode);\n\n\top->nr_files\t= 1;\n\top->ops\t\t= &afs_fetch_status_operation;\n\tret = afs_do_sync_operation(op);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tafs_get_inode_cache(vnode);\n\n\tclear_bit(AFS_VNODE_UNSET, &vnode->flags);\n\tunlock_new_inode(inode);\n\t_leave(\" = %p\", inode);\n\treturn inode;\n\nerror:\n\tiget_failed(inode);\n\t_leave(\" = %d [bad]\", ret);\n\treturn ERR_PTR(ret);\n}\n\n \nstatic void afs_zap_data(struct afs_vnode *vnode)\n{\n\t_enter(\"{%llx:%llu}\", vnode->fid.vid, vnode->fid.vnode);\n\n\tafs_invalidate_cache(vnode, 0);\n\n\t \n\tif (S_ISREG(vnode->netfs.inode.i_mode))\n\t\tinvalidate_remote_inode(&vnode->netfs.inode);\n\telse\n\t\tinvalidate_inode_pages2(vnode->netfs.inode.i_mapping);\n}\n\n \nstatic bool afs_check_server_good(struct afs_vnode *vnode)\n{\n\tstruct afs_server_list *slist;\n\tstruct afs_server *server;\n\tbool good;\n\tint i;\n\n\tif (vnode->cb_fs_s_break == atomic_read(&vnode->volume->cell->fs_s_break))\n\t\treturn true;\n\n\trcu_read_lock();\n\n\tslist = rcu_dereference(vnode->volume->servers);\n\tfor (i = 0; i < slist->nr_servers; i++) {\n\t\tserver = slist->servers[i].server;\n\t\tif (server == vnode->cb_server) {\n\t\t\tgood = (vnode->cb_s_break == server->cb_s_break);\n\t\t\trcu_read_unlock();\n\t\t\treturn good;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn false;\n}\n\n \nbool afs_check_validity(struct afs_vnode *vnode)\n{\n\tenum afs_cb_break_reason need_clear = afs_cb_break_no_break;\n\ttime64_t now = ktime_get_real_seconds();\n\tunsigned int cb_break;\n\tint seq = 0;\n\n\tdo {\n\t\tread_seqbegin_or_lock(&vnode->cb_lock, &seq);\n\t\tcb_break = vnode->cb_break;\n\n\t\tif (test_bit(AFS_VNODE_CB_PROMISED, &vnode->flags)) {\n\t\t\tif (vnode->cb_v_break != vnode->volume->cb_v_break)\n\t\t\t\tneed_clear = afs_cb_break_for_v_break;\n\t\t\telse if (!afs_check_server_good(vnode))\n\t\t\t\tneed_clear = afs_cb_break_for_s_reinit;\n\t\t\telse if (test_bit(AFS_VNODE_ZAP_DATA, &vnode->flags))\n\t\t\t\tneed_clear = afs_cb_break_for_zap;\n\t\t\telse if (vnode->cb_expires_at - 10 <= now)\n\t\t\t\tneed_clear = afs_cb_break_for_lapsed;\n\t\t} else if (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t\t;\n\t\t} else {\n\t\t\tneed_clear = afs_cb_break_no_promise;\n\t\t}\n\n\t} while (need_seqretry(&vnode->cb_lock, seq));\n\n\tdone_seqretry(&vnode->cb_lock, seq);\n\n\tif (need_clear == afs_cb_break_no_break)\n\t\treturn true;\n\n\twrite_seqlock(&vnode->cb_lock);\n\tif (need_clear == afs_cb_break_no_promise)\n\t\tvnode->cb_v_break = vnode->volume->cb_v_break;\n\telse if (cb_break == vnode->cb_break)\n\t\t__afs_break_callback(vnode, need_clear);\n\telse\n\t\ttrace_afs_cb_miss(&vnode->fid, need_clear);\n\twrite_sequnlock(&vnode->cb_lock);\n\treturn false;\n}\n\n \nbool afs_pagecache_valid(struct afs_vnode *vnode)\n{\n\tif (unlikely(test_bit(AFS_VNODE_DELETED, &vnode->flags))) {\n\t\tif (vnode->netfs.inode.i_nlink)\n\t\t\tclear_nlink(&vnode->netfs.inode);\n\t\treturn true;\n\t}\n\n\tif (test_bit(AFS_VNODE_CB_PROMISED, &vnode->flags) &&\n\t    afs_check_validity(vnode))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nint afs_validate(struct afs_vnode *vnode, struct key *key)\n{\n\tint ret;\n\n\t_enter(\"{v={%llx:%llu} fl=%lx},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->flags,\n\t       key_serial(key));\n\n\tif (afs_pagecache_valid(vnode))\n\t\tgoto valid;\n\n\tdown_write(&vnode->validate_lock);\n\n\t \n\tif (!test_bit(AFS_VNODE_CB_PROMISED, &vnode->flags)) {\n\t\t_debug(\"not promised\");\n\t\tret = afs_fetch_status(vnode, key, false, NULL);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -ENOENT) {\n\t\t\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\t\t\tret = -ESTALE;\n\t\t\t}\n\t\t\tgoto error_unlock;\n\t\t}\n\t\t_debug(\"new promise [fl=%lx]\", vnode->flags);\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_debug(\"file already deleted\");\n\t\tret = -ESTALE;\n\t\tgoto error_unlock;\n\t}\n\n\t \n\tif (test_and_clear_bit(AFS_VNODE_ZAP_DATA, &vnode->flags))\n\t\tafs_zap_data(vnode);\n\tup_write(&vnode->validate_lock);\nvalid:\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_unlock:\n\tup_write(&vnode->validate_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nint afs_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\tstruct kstat *stat, u32 request_mask, unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct key *key;\n\tint ret, seq = 0;\n\n\t_enter(\"{ ino=%lu v=%u }\", inode->i_ino, inode->i_generation);\n\n\tif (vnode->volume &&\n\t    !(query_flags & AT_STATX_DONT_SYNC) &&\n\t    !test_bit(AFS_VNODE_CB_PROMISED, &vnode->flags)) {\n\t\tkey = afs_request_key(vnode->volume->cell);\n\t\tif (IS_ERR(key))\n\t\t\treturn PTR_ERR(key);\n\t\tret = afs_validate(vnode, key);\n\t\tkey_put(key);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tdo {\n\t\tread_seqbegin_or_lock(&vnode->cb_lock, &seq);\n\t\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\t\tif (test_bit(AFS_VNODE_SILLY_DELETED, &vnode->flags) &&\n\t\t    stat->nlink > 0)\n\t\t\tstat->nlink -= 1;\n\n\t\t \n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tstat->size = vnode->netfs.remote_i_size;\n\t} while (need_seqretry(&vnode->cb_lock, seq));\n\n\tdone_seqretry(&vnode->cb_lock, seq);\n\treturn 0;\n}\n\n \nint afs_drop_inode(struct inode *inode)\n{\n\t_enter(\"\");\n\n\tif (test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(inode)->flags))\n\t\treturn generic_delete_inode(inode);\n\telse\n\t\treturn generic_drop_inode(inode);\n}\n\n \nvoid afs_evict_inode(struct inode *inode)\n{\n\tstruct afs_vnode_cache_aux aux;\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\n\t_enter(\"{%llx:%llu.%d}\",\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique);\n\n\t_debug(\"CLEAR INODE %p\", inode);\n\n\tASSERTCMP(inode->i_ino, ==, vnode->fid.vnode);\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\tafs_set_cache_aux(vnode, &aux);\n\tfscache_clear_inode_writeback(afs_vnode_cache(vnode), inode, &aux);\n\tclear_inode(inode);\n\n\twhile (!list_empty(&vnode->wb_keys)) {\n\t\tstruct afs_wb_key *wbk = list_entry(vnode->wb_keys.next,\n\t\t\t\t\t\t    struct afs_wb_key, vnode_link);\n\t\tlist_del(&wbk->vnode_link);\n\t\tafs_put_wb_key(wbk);\n\t}\n\n\tfscache_relinquish_cookie(afs_vnode_cache(vnode),\n\t\t\t\t  test_bit(AFS_VNODE_DELETED, &vnode->flags));\n\n\tafs_prune_wb_keys(vnode);\n\tafs_put_permits(rcu_access_pointer(vnode->permit_cache));\n\tkey_put(vnode->silly_key);\n\tvnode->silly_key = NULL;\n\tkey_put(vnode->lock_key);\n\tvnode->lock_key = NULL;\n\t_leave(\"\");\n}\n\nstatic void afs_setattr_success(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct inode *inode = &vp->vnode->netfs.inode;\n\tloff_t old_i_size = i_size_read(inode);\n\n\top->setattr.old_i_size = old_i_size;\n\tafs_vnode_commit_status(op, vp);\n\t \n\n\tif (op->setattr.attr->ia_valid & ATTR_SIZE) {\n\t\tloff_t size = op->setattr.attr->ia_size;\n\t\tif (size > old_i_size)\n\t\t\tpagecache_isize_extended(inode, old_i_size, size);\n\t}\n}\n\nstatic void afs_setattr_edit_file(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct inode *inode = &vp->vnode->netfs.inode;\n\n\tif (op->setattr.attr->ia_valid & ATTR_SIZE) {\n\t\tloff_t size = op->setattr.attr->ia_size;\n\t\tloff_t i_size = op->setattr.old_i_size;\n\n\t\tif (size < i_size)\n\t\t\ttruncate_pagecache(inode, size);\n\t\tif (size != i_size)\n\t\t\tfscache_resize_cookie(afs_vnode_cache(vp->vnode),\n\t\t\t\t\t      vp->scb.status.size);\n\t}\n}\n\nstatic const struct afs_operation_ops afs_setattr_operation = {\n\t.issue_afs_rpc\t= afs_fs_setattr,\n\t.issue_yfs_rpc\t= yfs_fs_setattr,\n\t.success\t= afs_setattr_success,\n\t.edit_dir\t= afs_setattr_edit_file,\n};\n\n \nint afs_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\tstruct iattr *attr)\n{\n\tconst unsigned int supported =\n\t\tATTR_SIZE | ATTR_MODE | ATTR_UID | ATTR_GID |\n\t\tATTR_MTIME | ATTR_MTIME_SET | ATTR_TIMES_SET | ATTR_TOUCH;\n\tstruct afs_operation *op;\n\tstruct afs_vnode *vnode = AFS_FS_I(d_inode(dentry));\n\tstruct inode *inode = &vnode->netfs.inode;\n\tloff_t i_size;\n\tint ret;\n\n\t_enter(\"{%llx:%llu},{n=%pd},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, dentry,\n\t       attr->ia_valid);\n\n\tif (!(attr->ia_valid & supported)) {\n\t\t_leave(\" = 0 [unsupported]\");\n\t\treturn 0;\n\t}\n\n\ti_size = i_size_read(inode);\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tif (!S_ISREG(inode->i_mode))\n\t\t\treturn -EISDIR;\n\n\t\tret = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (attr->ia_size == i_size)\n\t\t\tattr->ia_valid &= ~ATTR_SIZE;\n\t}\n\n\tfscache_use_cookie(afs_vnode_cache(vnode), true);\n\n\t \n\tdown_write(&vnode->validate_lock);\n\n\tif ((attr->ia_valid & ATTR_SIZE) && S_ISREG(inode->i_mode)) {\n\t\tloff_t size = attr->ia_size;\n\n\t\t \n\t\tloff_t from = min(size, i_size);\n\t\tloff_t to = max(size, i_size);\n\t\tret = filemap_fdatawait_range(inode->i_mapping, from, to);\n\t\tif (ret < 0)\n\t\t\tgoto out_unlock;\n\n\t\t \n\t\tif (!(attr->ia_valid & (supported & ~ATTR_SIZE & ~ATTR_MTIME)) &&\n\t\t    attr->ia_size < i_size &&\n\t\t    attr->ia_size > vnode->status.size) {\n\t\t\ttruncate_pagecache(inode, attr->ia_size);\n\t\t\tfscache_resize_cookie(afs_vnode_cache(vnode),\n\t\t\t\t\t      attr->ia_size);\n\t\t\ti_size_write(inode, attr->ia_size);\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\top = afs_alloc_operation(((attr->ia_valid & ATTR_FILE) ?\n\t\t\t\t  afs_file_key(attr->ia_file) : NULL),\n\t\t\t\t vnode->volume);\n\tif (IS_ERR(op)) {\n\t\tret = PTR_ERR(op);\n\t\tgoto out_unlock;\n\t}\n\n\tafs_op_set_vnode(op, 0, vnode);\n\top->setattr.attr = attr;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\top->file[0].dv_delta = 1;\n\t\top->file[0].set_size = true;\n\t}\n\top->ctime = attr->ia_ctime;\n\top->file[0].update_ctime = 1;\n\top->file[0].modification = true;\n\n\top->ops = &afs_setattr_operation;\n\tret = afs_do_sync_operation(op);\n\nout_unlock:\n\tup_write(&vnode->validate_lock);\n\tfscache_unuse_cookie(afs_vnode_cache(vnode), NULL, NULL);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}