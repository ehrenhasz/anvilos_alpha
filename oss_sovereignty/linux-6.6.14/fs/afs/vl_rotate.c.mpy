{
  "module_name": "vl_rotate.c",
  "hash_id": "776fba660e76a962f156feb73a33bcf81fd4f0bf21d8b97b4fa899387a0c7c65",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/vl_rotate.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/signal.h>\n#include \"internal.h\"\n#include \"afs_vl.h\"\n\n \nbool afs_begin_vlserver_operation(struct afs_vl_cursor *vc, struct afs_cell *cell,\n\t\t\t\t  struct key *key)\n{\n\tmemset(vc, 0, sizeof(*vc));\n\tvc->cell = cell;\n\tvc->key = key;\n\tvc->error = -EDESTADDRREQ;\n\tvc->ac.error = SHRT_MAX;\n\n\tif (signal_pending(current)) {\n\t\tvc->error = -EINTR;\n\t\tvc->flags |= AFS_VL_CURSOR_STOP;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool afs_start_vl_iteration(struct afs_vl_cursor *vc)\n{\n\tstruct afs_cell *cell = vc->cell;\n\tunsigned int dns_lookup_count;\n\n\tif (cell->dns_source == DNS_RECORD_UNAVAILABLE ||\n\t    cell->dns_expiry <= ktime_get_real_seconds()) {\n\t\tdns_lookup_count = smp_load_acquire(&cell->dns_lookup_count);\n\t\tset_bit(AFS_CELL_FL_DO_LOOKUP, &cell->flags);\n\t\tafs_queue_cell(cell, afs_cell_trace_get_queue_dns);\n\n\t\tif (cell->dns_source == DNS_RECORD_UNAVAILABLE) {\n\t\t\tif (wait_var_event_interruptible(\n\t\t\t\t    &cell->dns_lookup_count,\n\t\t\t\t    smp_load_acquire(&cell->dns_lookup_count)\n\t\t\t\t    != dns_lookup_count) < 0) {\n\t\t\t\tvc->error = -ERESTARTSYS;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (cell->dns_status == DNS_LOOKUP_GOT_NOT_FOUND) {\n\t\t\tpr_warn(\"No record of cell %s\\n\", cell->name);\n\t\t\tvc->error = -ENOENT;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (cell->dns_source == DNS_RECORD_UNAVAILABLE) {\n\t\t\tvc->error = -EDESTADDRREQ;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tread_lock(&cell->vl_servers_lock);\n\tvc->server_list = afs_get_vlserverlist(\n\t\trcu_dereference_protected(cell->vl_servers,\n\t\t\t\t\t  lockdep_is_held(&cell->vl_servers_lock)));\n\tread_unlock(&cell->vl_servers_lock);\n\tif (!vc->server_list->nr_servers)\n\t\treturn false;\n\n\tvc->untried = (1UL << vc->server_list->nr_servers) - 1;\n\tvc->index = -1;\n\treturn true;\n}\n\n \nbool afs_select_vlserver(struct afs_vl_cursor *vc)\n{\n\tstruct afs_addr_list *alist;\n\tstruct afs_vlserver *vlserver;\n\tstruct afs_error e;\n\tu32 rtt;\n\tint error = vc->ac.error, i;\n\n\t_enter(\"%lx[%d],%lx[%d],%d,%d\",\n\t       vc->untried, vc->index,\n\t       vc->ac.tried, vc->ac.index,\n\t       error, vc->ac.abort_code);\n\n\tif (vc->flags & AFS_VL_CURSOR_STOP) {\n\t\t_leave(\" = f [stopped]\");\n\t\treturn false;\n\t}\n\n\tvc->nr_iterations++;\n\n\t \n\tswitch (error) {\n\tcase SHRT_MAX:\n\t\tgoto start;\n\n\tdefault:\n\tcase 0:\n\t\t \n\t\tvc->error = error;\n\t\tvc->flags |= AFS_VL_CURSOR_STOP;\n\t\t_leave(\" = f [okay/local %d]\", vc->ac.error);\n\t\treturn false;\n\n\tcase -ECONNABORTED:\n\t\t \n\t\tswitch (vc->ac.abort_code) {\n\t\tcase AFSVL_IO:\n\t\tcase AFSVL_BADVOLOPER:\n\t\tcase AFSVL_NOMEM:\n\t\t\t \n\t\t\tvc->error = -EREMOTEIO;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tgoto next_server;\n\n\t\tdefault:\n\t\t\tvc->error = afs_abort_to_error(vc->ac.abort_code);\n\t\t\tgoto failed;\n\t\t}\n\n\tcase -ERFKILL:\n\tcase -EADDRNOTAVAIL:\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -EHOSTDOWN:\n\tcase -ECONNREFUSED:\n\tcase -ETIMEDOUT:\n\tcase -ETIME:\n\t\t_debug(\"no conn %d\", error);\n\t\tvc->error = error;\n\t\tgoto iterate_address;\n\n\tcase -ECONNRESET:\n\t\t_debug(\"call reset\");\n\t\tvc->error = error;\n\t\tvc->flags |= AFS_VL_CURSOR_RETRY;\n\t\tgoto next_server;\n\n\tcase -EOPNOTSUPP:\n\t\t_debug(\"notsupp\");\n\t\tgoto next_server;\n\t}\n\nrestart_from_beginning:\n\t_debug(\"restart\");\n\tafs_end_cursor(&vc->ac);\n\tafs_put_vlserverlist(vc->cell->net, vc->server_list);\n\tvc->server_list = NULL;\n\tif (vc->flags & AFS_VL_CURSOR_RETRIED)\n\t\tgoto failed;\n\tvc->flags |= AFS_VL_CURSOR_RETRIED;\nstart:\n\t_debug(\"start\");\n\n\tif (!afs_start_vl_iteration(vc))\n\t\tgoto failed;\n\n\terror = afs_send_vl_probes(vc->cell->net, vc->key, vc->server_list);\n\tif (error < 0)\n\t\tgoto failed_set_error;\n\npick_server:\n\t_debug(\"pick [%lx]\", vc->untried);\n\n\terror = afs_wait_for_vl_probes(vc->server_list, vc->untried);\n\tif (error < 0)\n\t\tgoto failed_set_error;\n\n\t \n\tvc->index = vc->server_list->preferred;\n\tif (test_bit(vc->index, &vc->untried))\n\t\tgoto selected_server;\n\n\tvc->index = -1;\n\trtt = U32_MAX;\n\tfor (i = 0; i < vc->server_list->nr_servers; i++) {\n\t\tstruct afs_vlserver *s = vc->server_list->servers[i].server;\n\n\t\tif (!test_bit(i, &vc->untried) ||\n\t\t    !test_bit(AFS_VLSERVER_FL_RESPONDING, &s->flags))\n\t\t\tcontinue;\n\t\tif (s->probe.rtt < rtt) {\n\t\t\tvc->index = i;\n\t\t\trtt = s->probe.rtt;\n\t\t}\n\t}\n\n\tif (vc->index == -1)\n\t\tgoto no_more_servers;\n\nselected_server:\n\t_debug(\"use %d\", vc->index);\n\t__clear_bit(vc->index, &vc->untried);\n\n\t \n\tASSERTCMP(vc->ac.alist, ==, NULL);\n\tvlserver = vc->server_list->servers[vc->index].server;\n\tvc->server = vlserver;\n\n\t_debug(\"USING VLSERVER: %s\", vlserver->name);\n\n\tread_lock(&vlserver->lock);\n\talist = rcu_dereference_protected(vlserver->addresses,\n\t\t\t\t\t  lockdep_is_held(&vlserver->lock));\n\tafs_get_addrlist(alist);\n\tread_unlock(&vlserver->lock);\n\n\tmemset(&vc->ac, 0, sizeof(vc->ac));\n\n\tif (!vc->ac.alist)\n\t\tvc->ac.alist = alist;\n\telse\n\t\tafs_put_addrlist(alist);\n\n\tvc->ac.index = -1;\n\niterate_address:\n\tASSERT(vc->ac.alist);\n\t \n\tif (!afs_iterate_addresses(&vc->ac))\n\t\tgoto next_server;\n\n\t_debug(\"VL address %d/%d\", vc->ac.index, vc->ac.alist->nr_addrs);\n\n\t_leave(\" = t %pISpc\", &vc->ac.alist->addrs[vc->ac.index].transport);\n\treturn true;\n\nnext_server:\n\t_debug(\"next\");\n\tafs_end_cursor(&vc->ac);\n\tgoto pick_server;\n\nno_more_servers:\n\t \n\tif (vc->flags & AFS_VL_CURSOR_RETRY)\n\t\tgoto restart_from_beginning;\n\n\te.error = -EDESTADDRREQ;\n\te.responded = false;\n\tfor (i = 0; i < vc->server_list->nr_servers; i++) {\n\t\tstruct afs_vlserver *s = vc->server_list->servers[i].server;\n\n\t\tif (test_bit(AFS_VLSERVER_FL_RESPONDING, &s->flags))\n\t\t\te.responded = true;\n\t\tafs_prioritise_error(&e, READ_ONCE(s->probe.error),\n\t\t\t\t     s->probe.abort_code);\n\t}\n\n\terror = e.error;\n\nfailed_set_error:\n\tvc->error = error;\nfailed:\n\tvc->flags |= AFS_VL_CURSOR_STOP;\n\tafs_end_cursor(&vc->ac);\n\t_leave(\" = f [failed %d]\", vc->error);\n\treturn false;\n}\n\n \nstatic void afs_vl_dump_edestaddrreq(const struct afs_vl_cursor *vc)\n{\n\tstruct afs_cell *cell = vc->cell;\n\tstatic int count;\n\tint i;\n\n\tif (!IS_ENABLED(CONFIG_AFS_DEBUG_CURSOR) || count > 3)\n\t\treturn;\n\tcount++;\n\n\trcu_read_lock();\n\tpr_notice(\"EDESTADDR occurred\\n\");\n\tpr_notice(\"CELL: %s err=%d\\n\", cell->name, cell->error);\n\tpr_notice(\"DNS: src=%u st=%u lc=%x\\n\",\n\t\t  cell->dns_source, cell->dns_status, cell->dns_lookup_count);\n\tpr_notice(\"VC: ut=%lx ix=%u ni=%hu fl=%hx err=%hd\\n\",\n\t\t  vc->untried, vc->index, vc->nr_iterations, vc->flags, vc->error);\n\n\tif (vc->server_list) {\n\t\tconst struct afs_vlserver_list *sl = vc->server_list;\n\t\tpr_notice(\"VC: SL nr=%u ix=%u\\n\",\n\t\t\t  sl->nr_servers, sl->index);\n\t\tfor (i = 0; i < sl->nr_servers; i++) {\n\t\t\tconst struct afs_vlserver *s = sl->servers[i].server;\n\t\t\tpr_notice(\"VC: server %s+%hu fl=%lx E=%hd\\n\",\n\t\t\t\t  s->name, s->port, s->flags, s->probe.error);\n\t\t\tif (s->addresses) {\n\t\t\t\tconst struct afs_addr_list *a =\n\t\t\t\t\trcu_dereference(s->addresses);\n\t\t\t\tpr_notice(\"VC:  - nr=%u/%u/%u pf=%u\\n\",\n\t\t\t\t\t  a->nr_ipv4, a->nr_addrs, a->max_addrs,\n\t\t\t\t\t  a->preferred);\n\t\t\t\tpr_notice(\"VC:  - R=%lx F=%lx\\n\",\n\t\t\t\t\t  a->responded, a->failed);\n\t\t\t\tif (a == vc->ac.alist)\n\t\t\t\t\tpr_notice(\"VC:  - current\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpr_notice(\"AC: t=%lx ax=%u ac=%d er=%d r=%u ni=%u\\n\",\n\t\t  vc->ac.tried, vc->ac.index, vc->ac.abort_code, vc->ac.error,\n\t\t  vc->ac.responded, vc->ac.nr_iterations);\n\trcu_read_unlock();\n}\n\n \nint afs_end_vlserver_operation(struct afs_vl_cursor *vc)\n{\n\tstruct afs_net *net = vc->cell->net;\n\n\tif (vc->error == -EDESTADDRREQ ||\n\t    vc->error == -EADDRNOTAVAIL ||\n\t    vc->error == -ENETUNREACH ||\n\t    vc->error == -EHOSTUNREACH)\n\t\tafs_vl_dump_edestaddrreq(vc);\n\n\tafs_end_cursor(&vc->ac);\n\tafs_put_vlserverlist(net, vc->server_list);\n\n\tif (vc->error == -ECONNABORTED)\n\t\tvc->error = afs_abort_to_error(vc->ac.abort_code);\n\n\treturn vc->error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}