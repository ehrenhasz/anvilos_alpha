{
  "module_name": "dir_silly.c",
  "hash_id": "567c32c0a4bad64e12619c62aacd925afd918f6214bc8baf1990544d737b9b79",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/dir_silly.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/fsnotify.h>\n#include \"internal.h\"\n\nstatic void afs_silly_rename_success(struct afs_operation *op)\n{\n\t_enter(\"op=%08x\", op->debug_id);\n\n\tafs_check_dir_conflict(op, &op->file[0]);\n\tafs_vnode_commit_status(op, &op->file[0]);\n}\n\nstatic void afs_silly_rename_edit_dir(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_vnode *dvnode = dvp->vnode;\n\tstruct afs_vnode *vnode = AFS_FS_I(d_inode(op->dentry));\n\tstruct dentry *old = op->dentry;\n\tstruct dentry *new = op->dentry_2;\n\n\tspin_lock(&old->d_lock);\n\told->d_flags |= DCACHE_NFSFS_RENAMED;\n\tspin_unlock(&old->d_lock);\n\tif (dvnode->silly_key != op->key) {\n\t\tkey_put(dvnode->silly_key);\n\t\tdvnode->silly_key = key_get(op->key);\n\t}\n\n\tdown_write(&dvnode->validate_lock);\n\tif (test_bit(AFS_VNODE_DIR_VALID, &dvnode->flags) &&\n\t    dvnode->status.data_version == dvp->dv_before + dvp->dv_delta) {\n\t\tafs_edit_dir_remove(dvnode, &old->d_name,\n\t\t\t\t    afs_edit_dir_for_silly_0);\n\t\tafs_edit_dir_add(dvnode, &new->d_name,\n\t\t\t\t &vnode->fid, afs_edit_dir_for_silly_1);\n\t}\n\tup_write(&dvnode->validate_lock);\n}\n\nstatic const struct afs_operation_ops afs_silly_rename_operation = {\n\t.issue_afs_rpc\t= afs_fs_rename,\n\t.issue_yfs_rpc\t= yfs_fs_rename,\n\t.success\t= afs_silly_rename_success,\n\t.edit_dir\t= afs_silly_rename_edit_dir,\n};\n\n \nstatic int afs_do_silly_rename(struct afs_vnode *dvnode, struct afs_vnode *vnode,\n\t\t\t       struct dentry *old, struct dentry *new,\n\t\t\t       struct key *key)\n{\n\tstruct afs_operation *op;\n\n\t_enter(\"%pd,%pd\", old, new);\n\n\top = afs_alloc_operation(key, dvnode->volume);\n\tif (IS_ERR(op))\n\t\treturn PTR_ERR(op);\n\n\tafs_op_set_vnode(op, 0, dvnode);\n\tafs_op_set_vnode(op, 1, dvnode);\n\top->file[0].dv_delta = 1;\n\top->file[1].dv_delta = 1;\n\top->file[0].modification = true;\n\top->file[1].modification = true;\n\top->file[0].update_ctime = true;\n\top->file[1].update_ctime = true;\n\n\top->dentry\t\t= old;\n\top->dentry_2\t\t= new;\n\top->ops\t\t\t= &afs_silly_rename_operation;\n\n\ttrace_afs_silly_rename(vnode, false);\n\treturn afs_do_sync_operation(op);\n}\n\n \nint afs_sillyrename(struct afs_vnode *dvnode, struct afs_vnode *vnode,\n\t\t    struct dentry *dentry, struct key *key)\n{\n\tstatic unsigned int sillycounter;\n\tstruct dentry *sdentry = NULL;\n\tunsigned char silly[16];\n\tint ret = -EBUSY;\n\n\t_enter(\"\");\n\n\t \n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\n\tsdentry = NULL;\n\tdo {\n\t\tint slen;\n\n\t\tdput(sdentry);\n\t\tsillycounter++;\n\n\t\t \n\t\tslen = scnprintf(silly, sizeof(silly), \".__afs%04X\", sillycounter);\n\t\tsdentry = lookup_one_len(silly, dentry->d_parent, slen);\n\n\t\t \n\t\tif (IS_ERR(sdentry))\n\t\t\tgoto out;\n\t} while (!d_is_negative(sdentry));\n\n\tihold(&vnode->netfs.inode);\n\n\tret = afs_do_silly_rename(dvnode, vnode, dentry, sdentry, key);\n\tswitch (ret) {\n\tcase 0:\n\t\t \n\t\tset_bit(AFS_VNODE_SILLY_DELETED, &vnode->flags);\n\t\td_move(dentry, sdentry);\n\t\tbreak;\n\tcase -ERESTARTSYS:\n\t\t \n\t\td_drop(dentry);\n\t\td_drop(sdentry);\n\t}\n\n\tiput(&vnode->netfs.inode);\n\tdput(sdentry);\nout:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\nstatic void afs_silly_unlink_success(struct afs_operation *op)\n{\n\t_enter(\"op=%08x\", op->debug_id);\n\tafs_check_dir_conflict(op, &op->file[0]);\n\tafs_vnode_commit_status(op, &op->file[0]);\n\tafs_vnode_commit_status(op, &op->file[1]);\n\tafs_update_dentry_version(op, &op->file[0], op->dentry);\n}\n\nstatic void afs_silly_unlink_edit_dir(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_vnode *dvnode = dvp->vnode;\n\n\t_enter(\"op=%08x\", op->debug_id);\n\tdown_write(&dvnode->validate_lock);\n\tif (test_bit(AFS_VNODE_DIR_VALID, &dvnode->flags) &&\n\t    dvnode->status.data_version == dvp->dv_before + dvp->dv_delta)\n\t\tafs_edit_dir_remove(dvnode, &op->dentry->d_name,\n\t\t\t\t    afs_edit_dir_for_unlink);\n\tup_write(&dvnode->validate_lock);\n}\n\nstatic const struct afs_operation_ops afs_silly_unlink_operation = {\n\t.issue_afs_rpc\t= afs_fs_remove_file,\n\t.issue_yfs_rpc\t= yfs_fs_remove_file,\n\t.success\t= afs_silly_unlink_success,\n\t.aborted\t= afs_check_for_remote_deletion,\n\t.edit_dir\t= afs_silly_unlink_edit_dir,\n};\n\n \nstatic int afs_do_silly_unlink(struct afs_vnode *dvnode, struct afs_vnode *vnode,\n\t\t\t       struct dentry *dentry, struct key *key)\n{\n\tstruct afs_operation *op;\n\n\t_enter(\"\");\n\n\top = afs_alloc_operation(NULL, dvnode->volume);\n\tif (IS_ERR(op))\n\t\treturn PTR_ERR(op);\n\n\tafs_op_set_vnode(op, 0, dvnode);\n\tafs_op_set_vnode(op, 1, vnode);\n\top->file[0].dv_delta = 1;\n\top->file[0].modification = true;\n\top->file[0].update_ctime = true;\n\top->file[1].op_unlinked = true;\n\top->file[1].update_ctime = true;\n\n\top->dentry\t= dentry;\n\top->ops\t\t= &afs_silly_unlink_operation;\n\n\ttrace_afs_silly_rename(vnode, true);\n\tafs_begin_vnode_operation(op);\n\tafs_wait_for_operation(op);\n\n\t \n\tif (op->error == 0 && (op->flags & AFS_OPERATION_DIR_CONFLICT)) {\n\t\top->file[1].update_ctime = false;\n\t\top->fetch_status.which = 1;\n\t\top->ops = &afs_fetch_status_operation;\n\t\tafs_begin_vnode_operation(op);\n\t\tafs_wait_for_operation(op);\n\t}\n\n\treturn afs_put_operation(op);\n}\n\n \nint afs_silly_iput(struct dentry *dentry, struct inode *inode)\n{\n\tstruct afs_vnode *dvnode = AFS_FS_I(d_inode(dentry->d_parent));\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct dentry *alias;\n\tint ret;\n\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\n\t_enter(\"%p{%pd},%llx\", dentry, dentry, vnode->fid.vnode);\n\n\tdown_read(&dvnode->rmdir_lock);\n\n\talias = d_alloc_parallel(dentry->d_parent, &dentry->d_name, &wq);\n\tif (IS_ERR(alias)) {\n\t\tup_read(&dvnode->rmdir_lock);\n\t\treturn 0;\n\t}\n\n\tif (!d_in_lookup(alias)) {\n\t\t \n\t\tret = 0;\n\t\tspin_lock(&alias->d_lock);\n\t\tif (d_really_is_positive(alias) &&\n\t\t    !(alias->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\t\talias->d_flags |= DCACHE_NFSFS_RENAMED;\n\t\t\tret = 1;\n\t\t}\n\t\tspin_unlock(&alias->d_lock);\n\t\tup_read(&dvnode->rmdir_lock);\n\t\tdput(alias);\n\t\treturn ret;\n\t}\n\n\t \n\tspin_lock(&vnode->lock);\n\tvnode->lock_state = AFS_VNODE_LOCK_DELETED;\n\ttrace_afs_flock_ev(vnode, NULL, afs_flock_silly_delete, 0);\n\tspin_unlock(&vnode->lock);\n\n\tafs_do_silly_unlink(dvnode, vnode, dentry, dvnode->silly_key);\n\tup_read(&dvnode->rmdir_lock);\n\td_lookup_done(alias);\n\tdput(alias);\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}