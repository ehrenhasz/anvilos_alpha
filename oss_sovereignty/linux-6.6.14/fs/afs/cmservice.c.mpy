{
  "module_name": "cmservice.c",
  "hash_id": "85272e2e5fadeb3652360bf655cb4a4f3377a4861d432113f723f3ca46d5b950",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/cmservice.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/ip.h>\n#include \"internal.h\"\n#include \"afs_cm.h\"\n#include \"protocol_yfs.h\"\n#define RXRPC_TRACE_ONLY_DEFINE_ENUMS\n#include <trace/events/rxrpc.h>\n\nstatic int afs_deliver_cb_init_call_back_state(struct afs_call *);\nstatic int afs_deliver_cb_init_call_back_state3(struct afs_call *);\nstatic int afs_deliver_cb_probe(struct afs_call *);\nstatic int afs_deliver_cb_callback(struct afs_call *);\nstatic int afs_deliver_cb_probe_uuid(struct afs_call *);\nstatic int afs_deliver_cb_tell_me_about_yourself(struct afs_call *);\nstatic void afs_cm_destructor(struct afs_call *);\nstatic void SRXAFSCB_CallBack(struct work_struct *);\nstatic void SRXAFSCB_InitCallBackState(struct work_struct *);\nstatic void SRXAFSCB_Probe(struct work_struct *);\nstatic void SRXAFSCB_ProbeUuid(struct work_struct *);\nstatic void SRXAFSCB_TellMeAboutYourself(struct work_struct *);\n\nstatic int afs_deliver_yfs_cb_callback(struct afs_call *);\n\n \nstatic const struct afs_call_type afs_SRXCBCallBack = {\n\t.name\t\t= \"CB.CallBack\",\n\t.deliver\t= afs_deliver_cb_callback,\n\t.destructor\t= afs_cm_destructor,\n\t.work\t\t= SRXAFSCB_CallBack,\n};\n\n \nstatic const struct afs_call_type afs_SRXCBInitCallBackState = {\n\t.name\t\t= \"CB.InitCallBackState\",\n\t.deliver\t= afs_deliver_cb_init_call_back_state,\n\t.destructor\t= afs_cm_destructor,\n\t.work\t\t= SRXAFSCB_InitCallBackState,\n};\n\n \nstatic const struct afs_call_type afs_SRXCBInitCallBackState3 = {\n\t.name\t\t= \"CB.InitCallBackState3\",\n\t.deliver\t= afs_deliver_cb_init_call_back_state3,\n\t.destructor\t= afs_cm_destructor,\n\t.work\t\t= SRXAFSCB_InitCallBackState,\n};\n\n \nstatic const struct afs_call_type afs_SRXCBProbe = {\n\t.name\t\t= \"CB.Probe\",\n\t.deliver\t= afs_deliver_cb_probe,\n\t.destructor\t= afs_cm_destructor,\n\t.work\t\t= SRXAFSCB_Probe,\n};\n\n \nstatic const struct afs_call_type afs_SRXCBProbeUuid = {\n\t.name\t\t= \"CB.ProbeUuid\",\n\t.deliver\t= afs_deliver_cb_probe_uuid,\n\t.destructor\t= afs_cm_destructor,\n\t.work\t\t= SRXAFSCB_ProbeUuid,\n};\n\n \nstatic const struct afs_call_type afs_SRXCBTellMeAboutYourself = {\n\t.name\t\t= \"CB.TellMeAboutYourself\",\n\t.deliver\t= afs_deliver_cb_tell_me_about_yourself,\n\t.destructor\t= afs_cm_destructor,\n\t.work\t\t= SRXAFSCB_TellMeAboutYourself,\n};\n\n \nstatic const struct afs_call_type afs_SRXYFSCB_CallBack = {\n\t.name\t\t= \"YFSCB.CallBack\",\n\t.deliver\t= afs_deliver_yfs_cb_callback,\n\t.destructor\t= afs_cm_destructor,\n\t.work\t\t= SRXAFSCB_CallBack,\n};\n\n \nbool afs_cm_incoming_call(struct afs_call *call)\n{\n\t_enter(\"{%u, CB.OP %u}\", call->service_id, call->operation_ID);\n\n\tswitch (call->operation_ID) {\n\tcase CBCallBack:\n\t\tcall->type = &afs_SRXCBCallBack;\n\t\treturn true;\n\tcase CBInitCallBackState:\n\t\tcall->type = &afs_SRXCBInitCallBackState;\n\t\treturn true;\n\tcase CBInitCallBackState3:\n\t\tcall->type = &afs_SRXCBInitCallBackState3;\n\t\treturn true;\n\tcase CBProbe:\n\t\tcall->type = &afs_SRXCBProbe;\n\t\treturn true;\n\tcase CBProbeUuid:\n\t\tcall->type = &afs_SRXCBProbeUuid;\n\t\treturn true;\n\tcase CBTellMeAboutYourself:\n\t\tcall->type = &afs_SRXCBTellMeAboutYourself;\n\t\treturn true;\n\tcase YFSCBCallBack:\n\t\tif (call->service_id != YFS_CM_SERVICE)\n\t\t\treturn false;\n\t\tcall->type = &afs_SRXYFSCB_CallBack;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic int afs_find_cm_server_by_peer(struct afs_call *call)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct afs_server *server;\n\n\trxrpc_kernel_get_peer(call->net->socket, call->rxcall, &srx);\n\n\tserver = afs_find_server(call->net, &srx);\n\tif (!server) {\n\t\ttrace_afs_cm_no_server(call, &srx);\n\t\treturn 0;\n\t}\n\n\tcall->server = server;\n\treturn 0;\n}\n\n \nstatic int afs_find_cm_server_by_uuid(struct afs_call *call,\n\t\t\t\t      struct afs_uuid *uuid)\n{\n\tstruct afs_server *server;\n\n\trcu_read_lock();\n\tserver = afs_find_server_by_uuid(call->net, call->request);\n\trcu_read_unlock();\n\tif (!server) {\n\t\ttrace_afs_cm_no_server_u(call, call->request);\n\t\treturn 0;\n\t}\n\n\tcall->server = server;\n\treturn 0;\n}\n\n \nstatic void afs_cm_destructor(struct afs_call *call)\n{\n\tkfree(call->buffer);\n\tcall->buffer = NULL;\n}\n\n \nstatic void afs_abort_service_call(struct afs_call *call, u32 abort_code, int error,\n\t\t\t\t   enum rxrpc_abort_reason why)\n{\n\trxrpc_kernel_abort_call(call->net->socket, call->rxcall,\n\t\t\t\tabort_code, error, why);\n\tafs_set_call_complete(call, error, 0);\n}\n\n \nstatic void SRXAFSCB_CallBack(struct work_struct *work)\n{\n\tstruct afs_call *call = container_of(work, struct afs_call, work);\n\n\t_enter(\"\");\n\n\t \n\tif (call->server) {\n\t\ttrace_afs_server(call->server->debug_id,\n\t\t\t\t refcount_read(&call->server->ref),\n\t\t\t\t atomic_read(&call->server->active),\n\t\t\t\t afs_server_trace_callback);\n\t\tafs_break_callbacks(call->server, call->count, call->request);\n\t}\n\n\tafs_send_empty_reply(call);\n\tafs_put_call(call);\n\t_leave(\"\");\n}\n\n \nstatic int afs_deliver_cb_callback(struct afs_call *call)\n{\n\tstruct afs_callback_break *cb;\n\t__be32 *bp;\n\tint ret, loop;\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tafs_extract_to_tmp(call);\n\t\tcall->unmarshall++;\n\n\t\t \n\t\tfallthrough;\n\tcase 1:\n\t\t_debug(\"extract FID count\");\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"FID count: %u\", call->count);\n\t\tif (call->count > AFSCBMAX)\n\t\t\treturn afs_protocol_error(call, afs_eproto_cb_fid_count);\n\n\t\tcall->buffer = kmalloc(array3_size(call->count, 3, 4),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!call->buffer)\n\t\t\treturn -ENOMEM;\n\t\tafs_extract_to_buf(call, call->count * 3 * 4);\n\t\tcall->unmarshall++;\n\n\t\tfallthrough;\n\tcase 2:\n\t\t_debug(\"extract FID array\");\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t_debug(\"unmarshall FID array\");\n\t\tcall->request = kcalloc(call->count,\n\t\t\t\t\tsizeof(struct afs_callback_break),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!call->request)\n\t\t\treturn -ENOMEM;\n\n\t\tcb = call->request;\n\t\tbp = call->buffer;\n\t\tfor (loop = call->count; loop > 0; loop--, cb++) {\n\t\t\tcb->fid.vid\t= ntohl(*bp++);\n\t\t\tcb->fid.vnode\t= ntohl(*bp++);\n\t\t\tcb->fid.unique\t= ntohl(*bp++);\n\t\t}\n\n\t\tafs_extract_to_tmp(call);\n\t\tcall->unmarshall++;\n\n\t\t \n\t\tfallthrough;\n\tcase 3:\n\t\t_debug(\"extract CB count\");\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcall->count2 = ntohl(call->tmp);\n\t\t_debug(\"CB count: %u\", call->count2);\n\t\tif (call->count2 != call->count && call->count2 != 0)\n\t\t\treturn afs_protocol_error(call, afs_eproto_cb_count);\n\t\tcall->iter = &call->def_iter;\n\t\tiov_iter_discard(&call->def_iter, ITER_DEST, call->count2 * 3 * 4);\n\t\tcall->unmarshall++;\n\n\t\tfallthrough;\n\tcase 4:\n\t\t_debug(\"extract discard %zu/%u\",\n\t\t       iov_iter_count(call->iter), call->count2 * 3 * 4);\n\n\t\tret = afs_extract_data(call, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\tcase 5:\n\t\tbreak;\n\t}\n\n\tif (!afs_check_call_state(call, AFS_CALL_SV_REPLYING))\n\t\treturn afs_io_error(call, afs_io_error_cm_reply);\n\n\t \n\treturn afs_find_cm_server_by_peer(call);\n}\n\n \nstatic void SRXAFSCB_InitCallBackState(struct work_struct *work)\n{\n\tstruct afs_call *call = container_of(work, struct afs_call, work);\n\n\t_enter(\"{%p}\", call->server);\n\n\tif (call->server)\n\t\tafs_init_callback_state(call->server);\n\tafs_send_empty_reply(call);\n\tafs_put_call(call);\n\t_leave(\"\");\n}\n\n \nstatic int afs_deliver_cb_init_call_back_state(struct afs_call *call)\n{\n\tint ret;\n\n\t_enter(\"\");\n\n\tafs_extract_discard(call, 0);\n\tret = afs_extract_data(call, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn afs_find_cm_server_by_peer(call);\n}\n\n \nstatic int afs_deliver_cb_init_call_back_state3(struct afs_call *call)\n{\n\tstruct afs_uuid *r;\n\tunsigned loop;\n\t__be32 *b;\n\tint ret;\n\n\t_enter(\"\");\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tcall->buffer = kmalloc_array(11, sizeof(__be32), GFP_KERNEL);\n\t\tif (!call->buffer)\n\t\t\treturn -ENOMEM;\n\t\tafs_extract_to_buf(call, 11 * sizeof(__be32));\n\t\tcall->unmarshall++;\n\n\t\tfallthrough;\n\tcase 1:\n\t\t_debug(\"extract UUID\");\n\t\tret = afs_extract_data(call, false);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\t_debug(\"unmarshall UUID\");\n\t\tcall->request = kmalloc(sizeof(struct afs_uuid), GFP_KERNEL);\n\t\tif (!call->request)\n\t\t\treturn -ENOMEM;\n\n\t\tb = call->buffer;\n\t\tr = call->request;\n\t\tr->time_low\t\t\t= b[0];\n\t\tr->time_mid\t\t\t= htons(ntohl(b[1]));\n\t\tr->time_hi_and_version\t\t= htons(ntohl(b[2]));\n\t\tr->clock_seq_hi_and_reserved \t= ntohl(b[3]);\n\t\tr->clock_seq_low\t\t= ntohl(b[4]);\n\n\t\tfor (loop = 0; loop < 6; loop++)\n\t\t\tr->node[loop] = ntohl(b[loop + 5]);\n\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\tcase 2:\n\t\tbreak;\n\t}\n\n\tif (!afs_check_call_state(call, AFS_CALL_SV_REPLYING))\n\t\treturn afs_io_error(call, afs_io_error_cm_reply);\n\n\t \n\treturn afs_find_cm_server_by_uuid(call, call->request);\n}\n\n \nstatic void SRXAFSCB_Probe(struct work_struct *work)\n{\n\tstruct afs_call *call = container_of(work, struct afs_call, work);\n\n\t_enter(\"\");\n\tafs_send_empty_reply(call);\n\tafs_put_call(call);\n\t_leave(\"\");\n}\n\n \nstatic int afs_deliver_cb_probe(struct afs_call *call)\n{\n\tint ret;\n\n\t_enter(\"\");\n\n\tafs_extract_discard(call, 0);\n\tret = afs_extract_data(call, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!afs_check_call_state(call, AFS_CALL_SV_REPLYING))\n\t\treturn afs_io_error(call, afs_io_error_cm_reply);\n\treturn afs_find_cm_server_by_peer(call);\n}\n\n \nstatic void SRXAFSCB_ProbeUuid(struct work_struct *work)\n{\n\tstruct afs_call *call = container_of(work, struct afs_call, work);\n\tstruct afs_uuid *r = call->request;\n\n\t_enter(\"\");\n\n\tif (memcmp(r, &call->net->uuid, sizeof(call->net->uuid)) == 0)\n\t\tafs_send_empty_reply(call);\n\telse\n\t\tafs_abort_service_call(call, 1, 1, afs_abort_probeuuid_negative);\n\n\tafs_put_call(call);\n\t_leave(\"\");\n}\n\n \nstatic int afs_deliver_cb_probe_uuid(struct afs_call *call)\n{\n\tstruct afs_uuid *r;\n\tunsigned loop;\n\t__be32 *b;\n\tint ret;\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tcall->buffer = kmalloc_array(11, sizeof(__be32), GFP_KERNEL);\n\t\tif (!call->buffer)\n\t\t\treturn -ENOMEM;\n\t\tafs_extract_to_buf(call, 11 * sizeof(__be32));\n\t\tcall->unmarshall++;\n\n\t\tfallthrough;\n\tcase 1:\n\t\t_debug(\"extract UUID\");\n\t\tret = afs_extract_data(call, false);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\t_debug(\"unmarshall UUID\");\n\t\tcall->request = kmalloc(sizeof(struct afs_uuid), GFP_KERNEL);\n\t\tif (!call->request)\n\t\t\treturn -ENOMEM;\n\n\t\tb = call->buffer;\n\t\tr = call->request;\n\t\tr->time_low\t\t\t= b[0];\n\t\tr->time_mid\t\t\t= htons(ntohl(b[1]));\n\t\tr->time_hi_and_version\t\t= htons(ntohl(b[2]));\n\t\tr->clock_seq_hi_and_reserved \t= ntohl(b[3]);\n\t\tr->clock_seq_low\t\t= ntohl(b[4]);\n\n\t\tfor (loop = 0; loop < 6; loop++)\n\t\t\tr->node[loop] = ntohl(b[loop + 5]);\n\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\tcase 2:\n\t\tbreak;\n\t}\n\n\tif (!afs_check_call_state(call, AFS_CALL_SV_REPLYING))\n\t\treturn afs_io_error(call, afs_io_error_cm_reply);\n\treturn afs_find_cm_server_by_peer(call);\n}\n\n \nstatic void SRXAFSCB_TellMeAboutYourself(struct work_struct *work)\n{\n\tstruct afs_call *call = container_of(work, struct afs_call, work);\n\tint loop;\n\n\tstruct {\n\t\tstruct   {\n\t\t\t__be32 nifs;\n\t\t\t__be32 uuid[11];\n\t\t\t__be32 ifaddr[32];\n\t\t\t__be32 netmask[32];\n\t\t\t__be32 mtu[32];\n\t\t} ia;\n\t\tstruct   {\n\t\t\t__be32 capcount;\n\t\t\t__be32 caps[1];\n\t\t} cap;\n\t} reply;\n\n\t_enter(\"\");\n\n\tmemset(&reply, 0, sizeof(reply));\n\n\treply.ia.uuid[0] = call->net->uuid.time_low;\n\treply.ia.uuid[1] = htonl(ntohs(call->net->uuid.time_mid));\n\treply.ia.uuid[2] = htonl(ntohs(call->net->uuid.time_hi_and_version));\n\treply.ia.uuid[3] = htonl((s8) call->net->uuid.clock_seq_hi_and_reserved);\n\treply.ia.uuid[4] = htonl((s8) call->net->uuid.clock_seq_low);\n\tfor (loop = 0; loop < 6; loop++)\n\t\treply.ia.uuid[loop + 5] = htonl((s8) call->net->uuid.node[loop]);\n\n\treply.cap.capcount = htonl(1);\n\treply.cap.caps[0] = htonl(AFS_CAP_ERROR_TRANSLATION);\n\tafs_send_simple_reply(call, &reply, sizeof(reply));\n\tafs_put_call(call);\n\t_leave(\"\");\n}\n\n \nstatic int afs_deliver_cb_tell_me_about_yourself(struct afs_call *call)\n{\n\tint ret;\n\n\t_enter(\"\");\n\n\tafs_extract_discard(call, 0);\n\tret = afs_extract_data(call, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!afs_check_call_state(call, AFS_CALL_SV_REPLYING))\n\t\treturn afs_io_error(call, afs_io_error_cm_reply);\n\treturn afs_find_cm_server_by_peer(call);\n}\n\n \nstatic int afs_deliver_yfs_cb_callback(struct afs_call *call)\n{\n\tstruct afs_callback_break *cb;\n\tstruct yfs_xdr_YFSFid *bp;\n\tsize_t size;\n\tint ret, loop;\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tafs_extract_to_tmp(call);\n\t\tcall->unmarshall++;\n\n\t\t \n\t\tfallthrough;\n\tcase 1:\n\t\t_debug(\"extract FID count\");\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"FID count: %u\", call->count);\n\t\tif (call->count > YFSCBMAX)\n\t\t\treturn afs_protocol_error(call, afs_eproto_cb_fid_count);\n\n\t\tsize = array_size(call->count, sizeof(struct yfs_xdr_YFSFid));\n\t\tcall->buffer = kmalloc(size, GFP_KERNEL);\n\t\tif (!call->buffer)\n\t\t\treturn -ENOMEM;\n\t\tafs_extract_to_buf(call, size);\n\t\tcall->unmarshall++;\n\n\t\tfallthrough;\n\tcase 2:\n\t\t_debug(\"extract FID array\");\n\t\tret = afs_extract_data(call, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t_debug(\"unmarshall FID array\");\n\t\tcall->request = kcalloc(call->count,\n\t\t\t\t\tsizeof(struct afs_callback_break),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!call->request)\n\t\t\treturn -ENOMEM;\n\n\t\tcb = call->request;\n\t\tbp = call->buffer;\n\t\tfor (loop = call->count; loop > 0; loop--, cb++) {\n\t\t\tcb->fid.vid\t= xdr_to_u64(bp->volume);\n\t\t\tcb->fid.vnode\t= xdr_to_u64(bp->vnode.lo);\n\t\t\tcb->fid.vnode_hi = ntohl(bp->vnode.hi);\n\t\t\tcb->fid.unique\t= ntohl(bp->vnode.unique);\n\t\t\tbp++;\n\t\t}\n\n\t\tafs_extract_to_tmp(call);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\tcase 3:\n\t\tbreak;\n\t}\n\n\tif (!afs_check_call_state(call, AFS_CALL_SV_REPLYING))\n\t\treturn afs_io_error(call, afs_io_error_cm_reply);\n\n\t \n\treturn afs_find_cm_server_by_peer(call);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}