{
  "module_name": "addr_list.c",
  "hash_id": "61fcfde1c2e654b59eb1f1bc8bf72d4a860ffe6d1834cd70fcc0fae142233371",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/addr_list.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/dns_resolver.h>\n#include <linux/inet.h>\n#include <keys/rxrpc-type.h>\n#include \"internal.h\"\n#include \"afs_fs.h\"\n\n \nvoid afs_put_addrlist(struct afs_addr_list *alist)\n{\n\tif (alist && refcount_dec_and_test(&alist->usage))\n\t\tkfree_rcu(alist, rcu);\n}\n\n \nstruct afs_addr_list *afs_alloc_addrlist(unsigned int nr,\n\t\t\t\t\t unsigned short service,\n\t\t\t\t\t unsigned short port)\n{\n\tstruct afs_addr_list *alist;\n\tunsigned int i;\n\n\t_enter(\"%u,%u,%u\", nr, service, port);\n\n\tif (nr > AFS_MAX_ADDRESSES)\n\t\tnr = AFS_MAX_ADDRESSES;\n\n\talist = kzalloc(struct_size(alist, addrs, nr), GFP_KERNEL);\n\tif (!alist)\n\t\treturn NULL;\n\n\trefcount_set(&alist->usage, 1);\n\talist->max_addrs = nr;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct sockaddr_rxrpc *srx = &alist->addrs[i];\n\t\tsrx->srx_family\t\t\t= AF_RXRPC;\n\t\tsrx->srx_service\t\t= service;\n\t\tsrx->transport_type\t\t= SOCK_DGRAM;\n\t\tsrx->transport_len\t\t= sizeof(srx->transport.sin6);\n\t\tsrx->transport.sin6.sin6_family\t= AF_INET6;\n\t\tsrx->transport.sin6.sin6_port\t= htons(port);\n\t}\n\n\treturn alist;\n}\n\n \nstruct afs_vlserver_list *afs_parse_text_addrs(struct afs_net *net,\n\t\t\t\t\t       const char *text, size_t len,\n\t\t\t\t\t       char delim,\n\t\t\t\t\t       unsigned short service,\n\t\t\t\t\t       unsigned short port)\n{\n\tstruct afs_vlserver_list *vllist;\n\tstruct afs_addr_list *alist;\n\tconst char *p, *end = text + len;\n\tconst char *problem;\n\tunsigned int nr = 0;\n\tint ret = -ENOMEM;\n\n\t_enter(\"%*.*s,%c\", (int)len, (int)len, text, delim);\n\n\tif (!len) {\n\t\t_leave(\" = -EDESTADDRREQ [empty]\");\n\t\treturn ERR_PTR(-EDESTADDRREQ);\n\t}\n\n\tif (delim == ':' && (memchr(text, ',', len) || !memchr(text, '.', len)))\n\t\tdelim = ',';\n\n\t \n\tp = text;\n\tdo {\n\t\tif (!*p) {\n\t\t\tproblem = \"nul\";\n\t\t\tgoto inval;\n\t\t}\n\t\tif (*p == delim)\n\t\t\tcontinue;\n\t\tnr++;\n\t\tif (*p == '[') {\n\t\t\tp++;\n\t\t\tif (p == end) {\n\t\t\t\tproblem = \"brace1\";\n\t\t\t\tgoto inval;\n\t\t\t}\n\t\t\tp = memchr(p, ']', end - p);\n\t\t\tif (!p) {\n\t\t\t\tproblem = \"brace2\";\n\t\t\t\tgoto inval;\n\t\t\t}\n\t\t\tp++;\n\t\t\tif (p >= end)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tp = memchr(p, delim, end - p);\n\t\tif (!p)\n\t\t\tbreak;\n\t\tp++;\n\t} while (p < end);\n\n\t_debug(\"%u/%u addresses\", nr, AFS_MAX_ADDRESSES);\n\n\tvllist = afs_alloc_vlserver_list(1);\n\tif (!vllist)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvllist->nr_servers = 1;\n\tvllist->servers[0].server = afs_alloc_vlserver(\"<dummy>\", 7, AFS_VL_PORT);\n\tif (!vllist->servers[0].server)\n\t\tgoto error_vl;\n\n\talist = afs_alloc_addrlist(nr, service, AFS_VL_PORT);\n\tif (!alist)\n\t\tgoto error;\n\n\t \n\tp = text;\n\tdo {\n\t\tconst char *q, *stop;\n\t\tunsigned int xport = port;\n\t\t__be32 x[4];\n\t\tint family;\n\n\t\tif (*p == delim) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (*p == '[') {\n\t\t\tp++;\n\t\t\tq = memchr(p, ']', end - p);\n\t\t} else {\n\t\t\tfor (q = p; q < end; q++)\n\t\t\t\tif (*q == '+' || *q == delim)\n\t\t\t\t\tbreak;\n\t\t}\n\n\t\tif (in4_pton(p, q - p, (u8 *)&x[0], -1, &stop)) {\n\t\t\tfamily = AF_INET;\n\t\t} else if (in6_pton(p, q - p, (u8 *)x, -1, &stop)) {\n\t\t\tfamily = AF_INET6;\n\t\t} else {\n\t\t\tproblem = \"family\";\n\t\t\tgoto bad_address;\n\t\t}\n\n\t\tp = q;\n\t\tif (stop != p) {\n\t\t\tproblem = \"nostop\";\n\t\t\tgoto bad_address;\n\t\t}\n\n\t\tif (q < end && *q == ']')\n\t\t\tp++;\n\n\t\tif (p < end) {\n\t\t\tif (*p == '+') {\n\t\t\t\t \n\t\t\t\txport = 0;\n\t\t\t\tp++;\n\t\t\t\tif (p >= end || !isdigit(*p)) {\n\t\t\t\t\tproblem = \"port\";\n\t\t\t\t\tgoto bad_address;\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\txport *= 10;\n\t\t\t\t\txport += *p - '0';\n\t\t\t\t\tif (xport > 65535) {\n\t\t\t\t\t\tproblem = \"pval\";\n\t\t\t\t\t\tgoto bad_address;\n\t\t\t\t\t}\n\t\t\t\t\tp++;\n\t\t\t\t} while (p < end && isdigit(*p));\n\t\t\t} else if (*p == delim) {\n\t\t\t\tp++;\n\t\t\t} else {\n\t\t\t\tproblem = \"weird\";\n\t\t\t\tgoto bad_address;\n\t\t\t}\n\t\t}\n\n\t\tif (family == AF_INET)\n\t\t\tafs_merge_fs_addr4(alist, x[0], xport);\n\t\telse\n\t\t\tafs_merge_fs_addr6(alist, x, xport);\n\n\t} while (p < end);\n\n\trcu_assign_pointer(vllist->servers[0].server->addresses, alist);\n\t_leave(\" = [nr %u]\", alist->nr_addrs);\n\treturn vllist;\n\ninval:\n\t_leave(\" = -EINVAL [%s %zu %*.*s]\",\n\t       problem, p - text, (int)len, (int)len, text);\n\treturn ERR_PTR(-EINVAL);\nbad_address:\n\t_leave(\" = -EINVAL [%s %zu %*.*s]\",\n\t       problem, p - text, (int)len, (int)len, text);\n\tret = -EINVAL;\nerror:\n\tafs_put_addrlist(alist);\nerror_vl:\n\tafs_put_vlserverlist(net, vllist);\n\treturn ERR_PTR(ret);\n}\n\n \n#if 0\nstatic int afs_cmp_addr_list(const struct afs_addr_list *a1,\n\t\t\t     const struct afs_addr_list *a2)\n{\n}\n#endif\n\n \nstruct afs_vlserver_list *afs_dns_query(struct afs_cell *cell, time64_t *_expiry)\n{\n\tstruct afs_vlserver_list *vllist;\n\tchar *result = NULL;\n\tint ret;\n\n\t_enter(\"%s\", cell->name);\n\n\tret = dns_query(cell->net->net, \"afsdb\", cell->name, cell->name_len,\n\t\t\t\"srv=1\", &result, _expiry, true);\n\tif (ret < 0) {\n\t\t_leave(\" = %d [dns]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (*_expiry == 0)\n\t\t*_expiry = ktime_get_real_seconds() + 60;\n\n\tif (ret > 1 && result[0] == 0)\n\t\tvllist = afs_extract_vlserver_list(cell, result, ret);\n\telse\n\t\tvllist = afs_parse_text_addrs(cell->net, result, ret, ',',\n\t\t\t\t\t      VL_SERVICE, AFS_VL_PORT);\n\tkfree(result);\n\tif (IS_ERR(vllist) && vllist != ERR_PTR(-ENOMEM))\n\t\tpr_err(\"Failed to parse DNS data %ld\\n\", PTR_ERR(vllist));\n\n\treturn vllist;\n}\n\n \nvoid afs_merge_fs_addr4(struct afs_addr_list *alist, __be32 xdr, u16 port)\n{\n\tstruct sockaddr_rxrpc *srx;\n\tu32 addr = ntohl(xdr);\n\tint i;\n\n\tif (alist->nr_addrs >= alist->max_addrs)\n\t\treturn;\n\n\tfor (i = 0; i < alist->nr_ipv4; i++) {\n\t\tstruct sockaddr_in *a = &alist->addrs[i].transport.sin;\n\t\tu32 a_addr = ntohl(a->sin_addr.s_addr);\n\t\tu16 a_port = ntohs(a->sin_port);\n\n\t\tif (addr == a_addr && port == a_port)\n\t\t\treturn;\n\t\tif (addr == a_addr && port < a_port)\n\t\t\tbreak;\n\t\tif (addr < a_addr)\n\t\t\tbreak;\n\t}\n\n\tif (i < alist->nr_addrs)\n\t\tmemmove(alist->addrs + i + 1,\n\t\t\talist->addrs + i,\n\t\t\tsizeof(alist->addrs[0]) * (alist->nr_addrs - i));\n\n\tsrx = &alist->addrs[i];\n\tsrx->srx_family = AF_RXRPC;\n\tsrx->transport_type = SOCK_DGRAM;\n\tsrx->transport_len = sizeof(srx->transport.sin);\n\tsrx->transport.sin.sin_family = AF_INET;\n\tsrx->transport.sin.sin_port = htons(port);\n\tsrx->transport.sin.sin_addr.s_addr = xdr;\n\talist->nr_ipv4++;\n\talist->nr_addrs++;\n}\n\n \nvoid afs_merge_fs_addr6(struct afs_addr_list *alist, __be32 *xdr, u16 port)\n{\n\tstruct sockaddr_rxrpc *srx;\n\tint i, diff;\n\n\tif (alist->nr_addrs >= alist->max_addrs)\n\t\treturn;\n\n\tfor (i = alist->nr_ipv4; i < alist->nr_addrs; i++) {\n\t\tstruct sockaddr_in6 *a = &alist->addrs[i].transport.sin6;\n\t\tu16 a_port = ntohs(a->sin6_port);\n\n\t\tdiff = memcmp(xdr, &a->sin6_addr, 16);\n\t\tif (diff == 0 && port == a_port)\n\t\t\treturn;\n\t\tif (diff == 0 && port < a_port)\n\t\t\tbreak;\n\t\tif (diff < 0)\n\t\t\tbreak;\n\t}\n\n\tif (i < alist->nr_addrs)\n\t\tmemmove(alist->addrs + i + 1,\n\t\t\talist->addrs + i,\n\t\t\tsizeof(alist->addrs[0]) * (alist->nr_addrs - i));\n\n\tsrx = &alist->addrs[i];\n\tsrx->srx_family = AF_RXRPC;\n\tsrx->transport_type = SOCK_DGRAM;\n\tsrx->transport_len = sizeof(srx->transport.sin6);\n\tsrx->transport.sin6.sin6_family = AF_INET6;\n\tsrx->transport.sin6.sin6_port = htons(port);\n\tmemcpy(&srx->transport.sin6.sin6_addr, xdr, 16);\n\talist->nr_addrs++;\n}\n\n \nbool afs_iterate_addresses(struct afs_addr_cursor *ac)\n{\n\tunsigned long set, failed;\n\tint index;\n\n\tif (!ac->alist)\n\t\treturn false;\n\n\tset = ac->alist->responded;\n\tfailed = ac->alist->failed;\n\t_enter(\"%lx-%lx-%lx,%d\", set, failed, ac->tried, ac->index);\n\n\tac->nr_iterations++;\n\n\tset &= ~(failed | ac->tried);\n\n\tif (!set)\n\t\treturn false;\n\n\tindex = READ_ONCE(ac->alist->preferred);\n\tif (test_bit(index, &set))\n\t\tgoto selected;\n\n\tindex = __ffs(set);\n\nselected:\n\tac->index = index;\n\tset_bit(index, &ac->tried);\n\tac->responded = false;\n\treturn true;\n}\n\n \nint afs_end_cursor(struct afs_addr_cursor *ac)\n{\n\tstruct afs_addr_list *alist;\n\n\talist = ac->alist;\n\tif (alist) {\n\t\tif (ac->responded &&\n\t\t    ac->index != alist->preferred &&\n\t\t    test_bit(ac->alist->preferred, &ac->tried))\n\t\t\tWRITE_ONCE(alist->preferred, ac->index);\n\t\tafs_put_addrlist(alist);\n\t\tac->alist = NULL;\n\t}\n\n\treturn ac->error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}