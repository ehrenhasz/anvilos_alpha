{
  "module_name": "flock.c",
  "hash_id": "65c994e335f8bf49c727aa83cd6be7e6a2178dc84c78587dcea3ebaf90bb87d4",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/flock.c",
  "human_readable_source": "\n \n\n#include \"internal.h\"\n\n#define AFS_LOCK_GRANTED\t0\n#define AFS_LOCK_PENDING\t1\n#define AFS_LOCK_YOUR_TRY\t2\n\nstruct workqueue_struct *afs_lock_manager;\n\nstatic void afs_next_locker(struct afs_vnode *vnode, int error);\nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);\nstatic void afs_fl_release_private(struct file_lock *fl);\n\nstatic const struct file_lock_operations afs_lock_ops = {\n\t.fl_copy_lock\t\t= afs_fl_copy_lock,\n\t.fl_release_private\t= afs_fl_release_private,\n};\n\nstatic inline void afs_set_lock_state(struct afs_vnode *vnode, enum afs_lock_state state)\n{\n\t_debug(\"STATE %u -> %u\", vnode->lock_state, state);\n\tvnode->lock_state = state;\n}\n\nstatic atomic_t afs_file_lock_debug_id;\n\n \nvoid afs_lock_may_be_available(struct afs_vnode *vnode)\n{\n\t_enter(\"{%llx:%llu}\", vnode->fid.vid, vnode->fid.vnode);\n\n\tspin_lock(&vnode->lock);\n\tif (vnode->lock_state == AFS_VNODE_LOCK_WAITING_FOR_CB)\n\t\tafs_next_locker(vnode, 0);\n\ttrace_afs_flock_ev(vnode, NULL, afs_flock_callback_break, 0);\n\tspin_unlock(&vnode->lock);\n}\n\n \nstatic void afs_schedule_lock_extension(struct afs_vnode *vnode)\n{\n\tktime_t expires_at, now, duration;\n\tu64 duration_j;\n\n\texpires_at = ktime_add_ms(vnode->locked_at, AFS_LOCKWAIT * 1000 / 2);\n\tnow = ktime_get_real();\n\tduration = ktime_sub(expires_at, now);\n\tif (duration <= 0)\n\t\tduration_j = 0;\n\telse\n\t\tduration_j = nsecs_to_jiffies(ktime_to_ns(duration));\n\n\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work, duration_j);\n}\n\n \nvoid afs_lock_op_done(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode *vnode = op->file[0].vnode;\n\n\tif (call->error == 0) {\n\t\tspin_lock(&vnode->lock);\n\t\ttrace_afs_flock_ev(vnode, NULL, afs_flock_timestamp, 0);\n\t\tvnode->locked_at = call->issue_time;\n\t\tafs_schedule_lock_extension(vnode);\n\t\tspin_unlock(&vnode->lock);\n\t}\n}\n\n \nstatic void afs_grant_locks(struct afs_vnode *vnode)\n{\n\tstruct file_lock *p, *_p;\n\tbool exclusive = (vnode->lock_type == AFS_LOCK_WRITE);\n\n\tlist_for_each_entry_safe(p, _p, &vnode->pending_locks, fl_u.afs.link) {\n\t\tif (!exclusive && p->fl_type == F_WRLCK)\n\t\t\tcontinue;\n\n\t\tlist_move_tail(&p->fl_u.afs.link, &vnode->granted_locks);\n\t\tp->fl_u.afs.state = AFS_LOCK_GRANTED;\n\t\ttrace_afs_flock_op(vnode, p, afs_flock_op_grant);\n\t\twake_up(&p->fl_wait);\n\t}\n}\n\n \nstatic void afs_next_locker(struct afs_vnode *vnode, int error)\n{\n\tstruct file_lock *p, *_p, *next = NULL;\n\tstruct key *key = vnode->lock_key;\n\tunsigned int fl_type = F_RDLCK;\n\n\t_enter(\"\");\n\n\tif (vnode->lock_type == AFS_LOCK_WRITE)\n\t\tfl_type = F_WRLCK;\n\n\tlist_for_each_entry_safe(p, _p, &vnode->pending_locks, fl_u.afs.link) {\n\t\tif (error &&\n\t\t    p->fl_type == fl_type &&\n\t\t    afs_file_key(p->fl_file) == key) {\n\t\t\tlist_del_init(&p->fl_u.afs.link);\n\t\t\tp->fl_u.afs.state = error;\n\t\t\twake_up(&p->fl_wait);\n\t\t}\n\n\t\t \n\t\tif (next &&\n\t\t    (next->fl_type == F_WRLCK || p->fl_type == F_RDLCK))\n\t\t\tcontinue;\n\t\tnext = p;\n\t}\n\n\tvnode->lock_key = NULL;\n\tkey_put(key);\n\n\tif (next) {\n\t\tafs_set_lock_state(vnode, AFS_VNODE_LOCK_SETTING);\n\t\tnext->fl_u.afs.state = AFS_LOCK_YOUR_TRY;\n\t\ttrace_afs_flock_op(vnode, next, afs_flock_op_wake);\n\t\twake_up(&next->fl_wait);\n\t} else {\n\t\tafs_set_lock_state(vnode, AFS_VNODE_LOCK_NONE);\n\t\ttrace_afs_flock_ev(vnode, NULL, afs_flock_no_lockers, 0);\n\t}\n\n\t_leave(\"\");\n}\n\n \nstatic void afs_kill_lockers_enoent(struct afs_vnode *vnode)\n{\n\tstruct file_lock *p;\n\n\tafs_set_lock_state(vnode, AFS_VNODE_LOCK_DELETED);\n\n\twhile (!list_empty(&vnode->pending_locks)) {\n\t\tp = list_entry(vnode->pending_locks.next,\n\t\t\t       struct file_lock, fl_u.afs.link);\n\t\tlist_del_init(&p->fl_u.afs.link);\n\t\tp->fl_u.afs.state = -ENOENT;\n\t\twake_up(&p->fl_wait);\n\t}\n\n\tkey_put(vnode->lock_key);\n\tvnode->lock_key = NULL;\n}\n\nstatic void afs_lock_success(struct afs_operation *op)\n{\n\t_enter(\"op=%08x\", op->debug_id);\n\tafs_vnode_commit_status(op, &op->file[0]);\n}\n\nstatic const struct afs_operation_ops afs_set_lock_operation = {\n\t.issue_afs_rpc\t= afs_fs_set_lock,\n\t.issue_yfs_rpc\t= yfs_fs_set_lock,\n\t.success\t= afs_lock_success,\n\t.aborted\t= afs_check_for_remote_deletion,\n};\n\n \nstatic int afs_set_lock(struct afs_vnode *vnode, struct key *key,\n\t\t\tafs_lock_type_t type)\n{\n\tstruct afs_operation *op;\n\n\t_enter(\"%s{%llx:%llu.%u},%x,%u\",\n\t       vnode->volume->name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key), type);\n\n\top = afs_alloc_operation(key, vnode->volume);\n\tif (IS_ERR(op))\n\t\treturn PTR_ERR(op);\n\n\tafs_op_set_vnode(op, 0, vnode);\n\n\top->lock.type\t= type;\n\top->ops\t\t= &afs_set_lock_operation;\n\treturn afs_do_sync_operation(op);\n}\n\nstatic const struct afs_operation_ops afs_extend_lock_operation = {\n\t.issue_afs_rpc\t= afs_fs_extend_lock,\n\t.issue_yfs_rpc\t= yfs_fs_extend_lock,\n\t.success\t= afs_lock_success,\n};\n\n \nstatic int afs_extend_lock(struct afs_vnode *vnode, struct key *key)\n{\n\tstruct afs_operation *op;\n\n\t_enter(\"%s{%llx:%llu.%u},%x\",\n\t       vnode->volume->name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\top = afs_alloc_operation(key, vnode->volume);\n\tif (IS_ERR(op))\n\t\treturn PTR_ERR(op);\n\n\tafs_op_set_vnode(op, 0, vnode);\n\n\top->flags\t|= AFS_OPERATION_UNINTR;\n\top->ops\t\t= &afs_extend_lock_operation;\n\treturn afs_do_sync_operation(op);\n}\n\nstatic const struct afs_operation_ops afs_release_lock_operation = {\n\t.issue_afs_rpc\t= afs_fs_release_lock,\n\t.issue_yfs_rpc\t= yfs_fs_release_lock,\n\t.success\t= afs_lock_success,\n};\n\n \nstatic int afs_release_lock(struct afs_vnode *vnode, struct key *key)\n{\n\tstruct afs_operation *op;\n\n\t_enter(\"%s{%llx:%llu.%u},%x\",\n\t       vnode->volume->name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\top = afs_alloc_operation(key, vnode->volume);\n\tif (IS_ERR(op))\n\t\treturn PTR_ERR(op);\n\n\tafs_op_set_vnode(op, 0, vnode);\n\n\top->flags\t|= AFS_OPERATION_UNINTR;\n\top->ops\t\t= &afs_release_lock_operation;\n\treturn afs_do_sync_operation(op);\n}\n\n \nvoid afs_lock_work(struct work_struct *work)\n{\n\tstruct afs_vnode *vnode =\n\t\tcontainer_of(work, struct afs_vnode, lock_work.work);\n\tstruct key *key;\n\tint ret;\n\n\t_enter(\"{%llx:%llu}\", vnode->fid.vid, vnode->fid.vnode);\n\n\tspin_lock(&vnode->lock);\n\nagain:\n\t_debug(\"wstate %u for %p\", vnode->lock_state, vnode);\n\tswitch (vnode->lock_state) {\n\tcase AFS_VNODE_LOCK_NEED_UNLOCK:\n\t\tafs_set_lock_state(vnode, AFS_VNODE_LOCK_UNLOCKING);\n\t\ttrace_afs_flock_ev(vnode, NULL, afs_flock_work_unlocking, 0);\n\t\tspin_unlock(&vnode->lock);\n\n\t\t \n\t\tret = afs_release_lock(vnode, vnode->lock_key);\n\t\tif (ret < 0 && vnode->lock_state != AFS_VNODE_LOCK_DELETED) {\n\t\t\ttrace_afs_flock_ev(vnode, NULL, afs_flock_release_fail,\n\t\t\t\t\t   ret);\n\t\t\tprintk(KERN_WARNING \"AFS:\"\n\t\t\t       \" Failed to release lock on {%llx:%llx} error %d\\n\",\n\t\t\t       vnode->fid.vid, vnode->fid.vnode, ret);\n\t\t}\n\n\t\tspin_lock(&vnode->lock);\n\t\tif (ret == -ENOENT)\n\t\t\tafs_kill_lockers_enoent(vnode);\n\t\telse\n\t\t\tafs_next_locker(vnode, 0);\n\t\tspin_unlock(&vnode->lock);\n\t\treturn;\n\n\t \n\tcase AFS_VNODE_LOCK_GRANTED:\n\t\t_debug(\"extend\");\n\n\t\tASSERT(!list_empty(&vnode->granted_locks));\n\n\t\tkey = key_get(vnode->lock_key);\n\t\tafs_set_lock_state(vnode, AFS_VNODE_LOCK_EXTENDING);\n\t\ttrace_afs_flock_ev(vnode, NULL, afs_flock_work_extending, 0);\n\t\tspin_unlock(&vnode->lock);\n\n\t\tret = afs_extend_lock(vnode, key);  \n\t\tkey_put(key);\n\n\t\tif (ret < 0) {\n\t\t\ttrace_afs_flock_ev(vnode, NULL, afs_flock_extend_fail,\n\t\t\t\t\t   ret);\n\t\t\tpr_warn(\"AFS: Failed to extend lock on {%llx:%llx} error %d\\n\",\n\t\t\t\tvnode->fid.vid, vnode->fid.vnode, ret);\n\t\t}\n\n\t\tspin_lock(&vnode->lock);\n\n\t\tif (ret == -ENOENT) {\n\t\t\tafs_kill_lockers_enoent(vnode);\n\t\t\tspin_unlock(&vnode->lock);\n\t\t\treturn;\n\t\t}\n\n\t\tif (vnode->lock_state != AFS_VNODE_LOCK_EXTENDING)\n\t\t\tgoto again;\n\t\tafs_set_lock_state(vnode, AFS_VNODE_LOCK_GRANTED);\n\n\t\tif (ret != 0)\n\t\t\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work,\n\t\t\t\t\t   HZ * 10);\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" [ext]\");\n\t\treturn;\n\n\t \n\tcase AFS_VNODE_LOCK_WAITING_FOR_CB:\n\t\t_debug(\"retry\");\n\t\tafs_next_locker(vnode, 0);\n\t\tspin_unlock(&vnode->lock);\n\t\treturn;\n\n\tcase AFS_VNODE_LOCK_DELETED:\n\t\tafs_kill_lockers_enoent(vnode);\n\t\tspin_unlock(&vnode->lock);\n\t\treturn;\n\n\tdefault:\n\t\t \n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" [no]\");\n\t\treturn;\n\t}\n}\n\n \nstatic void afs_defer_unlock(struct afs_vnode *vnode)\n{\n\t_enter(\"%u\", vnode->lock_state);\n\n\tif (list_empty(&vnode->granted_locks) &&\n\t    (vnode->lock_state == AFS_VNODE_LOCK_GRANTED ||\n\t     vnode->lock_state == AFS_VNODE_LOCK_EXTENDING)) {\n\t\tcancel_delayed_work(&vnode->lock_work);\n\n\t\tafs_set_lock_state(vnode, AFS_VNODE_LOCK_NEED_UNLOCK);\n\t\ttrace_afs_flock_ev(vnode, NULL, afs_flock_defer_unlock, 0);\n\t\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work, 0);\n\t}\n}\n\n \nstatic int afs_do_setlk_check(struct afs_vnode *vnode, struct key *key,\n\t\t\t      enum afs_flock_mode mode, afs_lock_type_t type)\n{\n\tafs_access_t access;\n\tint ret;\n\n\t \n\tret = afs_validate(vnode, key);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = afs_check_permit(vnode, key, &access);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (type == AFS_LOCK_READ) {\n\t\tif (!(access & (AFS_ACE_INSERT | AFS_ACE_WRITE | AFS_ACE_LOCK)))\n\t\t\treturn -EACCES;\n\t} else {\n\t\tif (!(access & (AFS_ACE_INSERT | AFS_ACE_WRITE)))\n\t\t\treturn -EACCES;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int afs_do_setlk(struct file *file, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tenum afs_flock_mode mode = AFS_FS_S(inode->i_sb)->flock_mode;\n\tafs_lock_type_t type;\n\tstruct key *key = afs_file_key(file);\n\tbool partial, no_server_lock = false;\n\tint ret;\n\n\tif (mode == afs_flock_mode_unset)\n\t\tmode = afs_flock_mode_openafs;\n\n\t_enter(\"{%llx:%llu},%llu-%llu,%u,%u\",\n\t       vnode->fid.vid, vnode->fid.vnode,\n\t       fl->fl_start, fl->fl_end, fl->fl_type, mode);\n\n\tfl->fl_ops = &afs_lock_ops;\n\tINIT_LIST_HEAD(&fl->fl_u.afs.link);\n\tfl->fl_u.afs.state = AFS_LOCK_PENDING;\n\n\tpartial = (fl->fl_start != 0 || fl->fl_end != OFFSET_MAX);\n\ttype = (fl->fl_type == F_RDLCK) ? AFS_LOCK_READ : AFS_LOCK_WRITE;\n\tif (mode == afs_flock_mode_write && partial)\n\t\ttype = AFS_LOCK_WRITE;\n\n\tret = afs_do_setlk_check(vnode, key, mode, type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttrace_afs_flock_op(vnode, fl, afs_flock_op_set_lock);\n\n\t \n\tif (mode == afs_flock_mode_local ||\n\t    (partial && mode == afs_flock_mode_openafs)) {\n\t\tno_server_lock = true;\n\t\tgoto skip_server_lock;\n\t}\n\n\tspin_lock(&vnode->lock);\n\tlist_add_tail(&fl->fl_u.afs.link, &vnode->pending_locks);\n\n\tret = -ENOENT;\n\tif (vnode->lock_state == AFS_VNODE_LOCK_DELETED)\n\t\tgoto error_unlock;\n\n\t \n\t_debug(\"try %u\", vnode->lock_state);\n\tif (vnode->lock_state == AFS_VNODE_LOCK_GRANTED) {\n\t\tif (type == AFS_LOCK_READ) {\n\t\t\t_debug(\"instant readlock\");\n\t\t\tlist_move_tail(&fl->fl_u.afs.link, &vnode->granted_locks);\n\t\t\tfl->fl_u.afs.state = AFS_LOCK_GRANTED;\n\t\t\tgoto vnode_is_locked_u;\n\t\t}\n\n\t\tif (vnode->lock_type == AFS_LOCK_WRITE) {\n\t\t\t_debug(\"instant writelock\");\n\t\t\tlist_move_tail(&fl->fl_u.afs.link, &vnode->granted_locks);\n\t\t\tfl->fl_u.afs.state = AFS_LOCK_GRANTED;\n\t\t\tgoto vnode_is_locked_u;\n\t\t}\n\t}\n\n\tif (vnode->lock_state == AFS_VNODE_LOCK_NONE &&\n\t    !(fl->fl_flags & FL_SLEEP)) {\n\t\tret = -EAGAIN;\n\t\tif (type == AFS_LOCK_READ) {\n\t\t\tif (vnode->status.lock_count == -1)\n\t\t\t\tgoto lock_is_contended;  \n\t\t} else {\n\t\t\tif (vnode->status.lock_count != 0)\n\t\t\t\tgoto lock_is_contended;  \n\t\t}\n\t}\n\n\tif (vnode->lock_state != AFS_VNODE_LOCK_NONE)\n\t\tgoto need_to_wait;\n\ntry_to_lock:\n\t \n\ttrace_afs_flock_ev(vnode, fl, afs_flock_try_to_lock, 0);\n\tvnode->lock_key = key_get(key);\n\tvnode->lock_type = type;\n\tafs_set_lock_state(vnode, AFS_VNODE_LOCK_SETTING);\n\tspin_unlock(&vnode->lock);\n\n\tret = afs_set_lock(vnode, key, type);  \n\n\tspin_lock(&vnode->lock);\n\tswitch (ret) {\n\tcase -EKEYREJECTED:\n\tcase -EKEYEXPIRED:\n\tcase -EKEYREVOKED:\n\tcase -EPERM:\n\tcase -EACCES:\n\t\tfl->fl_u.afs.state = ret;\n\t\ttrace_afs_flock_ev(vnode, fl, afs_flock_fail_perm, ret);\n\t\tlist_del_init(&fl->fl_u.afs.link);\n\t\tafs_next_locker(vnode, ret);\n\t\tgoto error_unlock;\n\n\tcase -ENOENT:\n\t\tfl->fl_u.afs.state = ret;\n\t\ttrace_afs_flock_ev(vnode, fl, afs_flock_fail_other, ret);\n\t\tlist_del_init(&fl->fl_u.afs.link);\n\t\tafs_kill_lockers_enoent(vnode);\n\t\tgoto error_unlock;\n\n\tdefault:\n\t\tfl->fl_u.afs.state = ret;\n\t\ttrace_afs_flock_ev(vnode, fl, afs_flock_fail_other, ret);\n\t\tlist_del_init(&fl->fl_u.afs.link);\n\t\tafs_next_locker(vnode, 0);\n\t\tgoto error_unlock;\n\n\tcase -EWOULDBLOCK:\n\t\t \n\t\tASSERT(list_empty(&vnode->granted_locks));\n\t\tASSERTCMP(vnode->pending_locks.next, ==, &fl->fl_u.afs.link);\n\t\tgoto lock_is_contended;\n\n\tcase 0:\n\t\tafs_set_lock_state(vnode, AFS_VNODE_LOCK_GRANTED);\n\t\ttrace_afs_flock_ev(vnode, fl, afs_flock_acquired, type);\n\t\tafs_grant_locks(vnode);\n\t\tgoto vnode_is_locked_u;\n\t}\n\nvnode_is_locked_u:\n\tspin_unlock(&vnode->lock);\nvnode_is_locked:\n\t \n\tASSERTCMP(fl->fl_u.afs.state, ==, AFS_LOCK_GRANTED);\n\nskip_server_lock:\n\t \n\ttrace_afs_flock_ev(vnode, fl, afs_flock_vfs_locking, 0);\n\tret = locks_lock_file_wait(file, fl);\n\ttrace_afs_flock_ev(vnode, fl, afs_flock_vfs_lock, ret);\n\tif (ret < 0)\n\t\tgoto vfs_rejected_lock;\n\n\t \n\tafs_validate(vnode, key);\n\t_leave(\" = 0\");\n\treturn 0;\n\nlock_is_contended:\n\tif (!(fl->fl_flags & FL_SLEEP)) {\n\t\tlist_del_init(&fl->fl_u.afs.link);\n\t\tafs_next_locker(vnode, 0);\n\t\tret = -EAGAIN;\n\t\tgoto error_unlock;\n\t}\n\n\tafs_set_lock_state(vnode, AFS_VNODE_LOCK_WAITING_FOR_CB);\n\ttrace_afs_flock_ev(vnode, fl, afs_flock_would_block, ret);\n\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work, HZ * 5);\n\nneed_to_wait:\n\t \n\tspin_unlock(&vnode->lock);\n\n\ttrace_afs_flock_ev(vnode, fl, afs_flock_waiting, 0);\n\tret = wait_event_interruptible(fl->fl_wait,\n\t\t\t\t       fl->fl_u.afs.state != AFS_LOCK_PENDING);\n\ttrace_afs_flock_ev(vnode, fl, afs_flock_waited, ret);\n\n\tif (fl->fl_u.afs.state >= 0 && fl->fl_u.afs.state != AFS_LOCK_GRANTED) {\n\t\tspin_lock(&vnode->lock);\n\n\t\tswitch (fl->fl_u.afs.state) {\n\t\tcase AFS_LOCK_YOUR_TRY:\n\t\t\tfl->fl_u.afs.state = AFS_LOCK_PENDING;\n\t\t\tgoto try_to_lock;\n\t\tcase AFS_LOCK_PENDING:\n\t\t\tif (ret > 0) {\n\t\t\t\t \n\t\t\t\tASSERTCMP(vnode->lock_state, ==, AFS_VNODE_LOCK_WAITING_FOR_CB);\n\t\t\t\tafs_set_lock_state(vnode, AFS_VNODE_LOCK_SETTING);\n\t\t\t\tfl->fl_u.afs.state = AFS_LOCK_PENDING;\n\t\t\t\tgoto try_to_lock;\n\t\t\t}\n\t\t\tgoto error_unlock;\n\t\tcase AFS_LOCK_GRANTED:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&vnode->lock);\n\t}\n\n\tif (fl->fl_u.afs.state == AFS_LOCK_GRANTED)\n\t\tgoto vnode_is_locked;\n\tret = fl->fl_u.afs.state;\n\tgoto error;\n\nvfs_rejected_lock:\n\t \n\t_debug(\"vfs refused %d\", ret);\n\tif (no_server_lock)\n\t\tgoto error;\n\tspin_lock(&vnode->lock);\n\tlist_del_init(&fl->fl_u.afs.link);\n\tafs_defer_unlock(vnode);\n\nerror_unlock:\n\tspin_unlock(&vnode->lock);\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nstatic int afs_do_unlk(struct file *file, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(file));\n\tint ret;\n\n\t_enter(\"{%llx:%llu},%u\", vnode->fid.vid, vnode->fid.vnode, fl->fl_type);\n\n\ttrace_afs_flock_op(vnode, fl, afs_flock_op_unlock);\n\n\t \n\tvfs_fsync(file, 0);\n\n\tret = locks_lock_file_wait(file, fl);\n\t_leave(\" = %d [%u]\", ret, vnode->lock_state);\n\treturn ret;\n}\n\n \nstatic int afs_do_getlk(struct file *file, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(file));\n\tstruct key *key = afs_file_key(file);\n\tint ret, lock_count;\n\n\t_enter(\"\");\n\n\tif (vnode->lock_state == AFS_VNODE_LOCK_DELETED)\n\t\treturn -ENOENT;\n\n\tfl->fl_type = F_UNLCK;\n\n\t \n\tposix_test_lock(file, fl);\n\tif (fl->fl_type == F_UNLCK) {\n\t\t \n\t\tret = afs_fetch_status(vnode, key, false, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tlock_count = READ_ONCE(vnode->status.lock_count);\n\t\tif (lock_count != 0) {\n\t\t\tif (lock_count > 0)\n\t\t\t\tfl->fl_type = F_RDLCK;\n\t\t\telse\n\t\t\t\tfl->fl_type = F_WRLCK;\n\t\t\tfl->fl_start = 0;\n\t\t\tfl->fl_end = OFFSET_MAX;\n\t\t\tfl->fl_pid = 0;\n\t\t}\n\t}\n\n\tret = 0;\nerror:\n\t_leave(\" = %d [%hd]\", ret, fl->fl_type);\n\treturn ret;\n}\n\n \nint afs_lock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(file));\n\tenum afs_flock_operation op;\n\tint ret;\n\n\t_enter(\"{%llx:%llu},%d,{t=%x,fl=%x,r=%Ld:%Ld}\",\n\t       vnode->fid.vid, vnode->fid.vnode, cmd,\n\t       fl->fl_type, fl->fl_flags,\n\t       (long long) fl->fl_start, (long long) fl->fl_end);\n\n\tif (IS_GETLK(cmd))\n\t\treturn afs_do_getlk(file, fl);\n\n\tfl->fl_u.afs.debug_id = atomic_inc_return(&afs_file_lock_debug_id);\n\ttrace_afs_flock_op(vnode, fl, afs_flock_op_lock);\n\n\tif (fl->fl_type == F_UNLCK)\n\t\tret = afs_do_unlk(file, fl);\n\telse\n\t\tret = afs_do_setlk(file, fl);\n\n\tswitch (ret) {\n\tcase 0:\t\top = afs_flock_op_return_ok; break;\n\tcase -EAGAIN:\top = afs_flock_op_return_eagain; break;\n\tcase -EDEADLK:\top = afs_flock_op_return_edeadlk; break;\n\tdefault:\top = afs_flock_op_return_error; break;\n\t}\n\ttrace_afs_flock_op(vnode, fl, op);\n\treturn ret;\n}\n\n \nint afs_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(file));\n\tenum afs_flock_operation op;\n\tint ret;\n\n\t_enter(\"{%llx:%llu},%d,{t=%x,fl=%x}\",\n\t       vnode->fid.vid, vnode->fid.vnode, cmd,\n\t       fl->fl_type, fl->fl_flags);\n\n\t \n\tif (!(fl->fl_flags & FL_FLOCK))\n\t\treturn -ENOLCK;\n\n\tfl->fl_u.afs.debug_id = atomic_inc_return(&afs_file_lock_debug_id);\n\ttrace_afs_flock_op(vnode, fl, afs_flock_op_flock);\n\n\t \n\tif (fl->fl_type == F_UNLCK)\n\t\tret = afs_do_unlk(file, fl);\n\telse\n\t\tret = afs_do_setlk(file, fl);\n\n\tswitch (ret) {\n\tcase 0:\t\top = afs_flock_op_return_ok; break;\n\tcase -EAGAIN:\top = afs_flock_op_return_eagain; break;\n\tcase -EDEADLK:\top = afs_flock_op_return_edeadlk; break;\n\tdefault:\top = afs_flock_op_return_error; break;\n\t}\n\ttrace_afs_flock_op(vnode, fl, op);\n\treturn ret;\n}\n\n \nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(fl->fl_file));\n\n\t_enter(\"\");\n\n\tnew->fl_u.afs.debug_id = atomic_inc_return(&afs_file_lock_debug_id);\n\n\tspin_lock(&vnode->lock);\n\ttrace_afs_flock_op(vnode, new, afs_flock_op_copy_lock);\n\tlist_add(&new->fl_u.afs.link, &fl->fl_u.afs.link);\n\tspin_unlock(&vnode->lock);\n}\n\n \nstatic void afs_fl_release_private(struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(fl->fl_file));\n\n\t_enter(\"\");\n\n\tspin_lock(&vnode->lock);\n\n\ttrace_afs_flock_op(vnode, fl, afs_flock_op_release_lock);\n\tlist_del_init(&fl->fl_u.afs.link);\n\tif (list_empty(&vnode->granted_locks))\n\t\tafs_defer_unlock(vnode);\n\n\t_debug(\"state %u for %p\", vnode->lock_state, vnode);\n\tspin_unlock(&vnode->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}