{
  "module_name": "callback.c",
  "hash_id": "672eba8ff2fa0842b57351e831674f7b1442ef85363b42960316b1088a4dc5d8",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/callback.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include \"internal.h\"\n\n \nvoid afs_invalidate_mmap_work(struct work_struct *work)\n{\n\tstruct afs_vnode *vnode = container_of(work, struct afs_vnode, cb_work);\n\n\tunmap_mapping_pages(vnode->netfs.inode.i_mapping, 0, 0, false);\n}\n\nvoid afs_server_init_callback_work(struct work_struct *work)\n{\n\tstruct afs_server *server = container_of(work, struct afs_server, initcb_work);\n\tstruct afs_vnode *vnode;\n\tstruct afs_cell *cell = server->cell;\n\n\tdown_read(&cell->fs_open_mmaps_lock);\n\n\tlist_for_each_entry(vnode, &cell->fs_open_mmaps, cb_mmap_link) {\n\t\tif (vnode->cb_server == server) {\n\t\t\tclear_bit(AFS_VNODE_CB_PROMISED, &vnode->flags);\n\t\t\tqueue_work(system_unbound_wq, &vnode->cb_work);\n\t\t}\n\t}\n\n\tup_read(&cell->fs_open_mmaps_lock);\n}\n\n \nvoid afs_init_callback_state(struct afs_server *server)\n{\n\trcu_read_lock();\n\tdo {\n\t\tserver->cb_s_break++;\n\t\tatomic_inc(&server->cell->fs_s_break);\n\t\tif (!list_empty(&server->cell->fs_open_mmaps))\n\t\t\tqueue_work(system_unbound_wq, &server->initcb_work);\n\n\t} while ((server = rcu_dereference(server->uuid_next)));\n\trcu_read_unlock();\n}\n\n \nvoid __afs_break_callback(struct afs_vnode *vnode, enum afs_cb_break_reason reason)\n{\n\t_enter(\"\");\n\n\tclear_bit(AFS_VNODE_NEW_CONTENT, &vnode->flags);\n\tif (test_and_clear_bit(AFS_VNODE_CB_PROMISED, &vnode->flags)) {\n\t\tvnode->cb_break++;\n\t\tvnode->cb_v_break = vnode->volume->cb_v_break;\n\t\tafs_clear_permits(vnode);\n\n\t\tif (vnode->lock_state == AFS_VNODE_LOCK_WAITING_FOR_CB)\n\t\t\tafs_lock_may_be_available(vnode);\n\n\t\tif (reason != afs_cb_break_for_deleted &&\n\t\t    vnode->status.type == AFS_FTYPE_FILE &&\n\t\t    atomic_read(&vnode->cb_nr_mmap))\n\t\t\tqueue_work(system_unbound_wq, &vnode->cb_work);\n\n\t\ttrace_afs_cb_break(&vnode->fid, vnode->cb_break, reason, true);\n\t} else {\n\t\ttrace_afs_cb_break(&vnode->fid, vnode->cb_break, reason, false);\n\t}\n}\n\nvoid afs_break_callback(struct afs_vnode *vnode, enum afs_cb_break_reason reason)\n{\n\twrite_seqlock(&vnode->cb_lock);\n\t__afs_break_callback(vnode, reason);\n\twrite_sequnlock(&vnode->cb_lock);\n}\n\n \nstatic struct afs_volume *afs_lookup_volume_rcu(struct afs_cell *cell,\n\t\t\t\t\t\tafs_volid_t vid)\n{\n\tstruct afs_volume *volume = NULL;\n\tstruct rb_node *p;\n\tint seq = 0;\n\n\tdo {\n\t\t \n\t\tread_seqbegin_or_lock(&cell->volume_lock, &seq);\n\n\t\tp = rcu_dereference_raw(cell->volumes.rb_node);\n\t\twhile (p) {\n\t\t\tvolume = rb_entry(p, struct afs_volume, cell_node);\n\n\t\t\tif (volume->vid < vid)\n\t\t\t\tp = rcu_dereference_raw(p->rb_left);\n\t\t\telse if (volume->vid > vid)\n\t\t\t\tp = rcu_dereference_raw(p->rb_right);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\tvolume = NULL;\n\t\t}\n\n\t} while (need_seqretry(&cell->volume_lock, seq));\n\n\tdone_seqretry(&cell->volume_lock, seq);\n\treturn volume;\n}\n\n \nstatic void afs_break_one_callback(struct afs_volume *volume,\n\t\t\t\t   struct afs_fid *fid)\n{\n\tstruct super_block *sb;\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\n\tif (fid->vnode == 0 && fid->unique == 0) {\n\t\t \n\t\twrite_lock(&volume->cb_v_break_lock);\n\t\tvolume->cb_v_break++;\n\t\ttrace_afs_cb_break(fid, volume->cb_v_break,\n\t\t\t\t   afs_cb_break_for_volume_callback, false);\n\t\twrite_unlock(&volume->cb_v_break_lock);\n\t\treturn;\n\t}\n\n\t \n\tsb = rcu_dereference(volume->sb);\n\tif (!sb)\n\t\treturn;\n\n\tinode = find_inode_rcu(sb, fid->vnode, afs_ilookup5_test_by_fid, fid);\n\tif (inode) {\n\t\tvnode = AFS_FS_I(inode);\n\t\tafs_break_callback(vnode, afs_cb_break_for_callback);\n\t} else {\n\t\ttrace_afs_cb_miss(fid, afs_cb_break_for_callback);\n\t}\n}\n\nstatic void afs_break_some_callbacks(struct afs_server *server,\n\t\t\t\t     struct afs_callback_break *cbb,\n\t\t\t\t     size_t *_count)\n{\n\tstruct afs_callback_break *residue = cbb;\n\tstruct afs_volume *volume;\n\tafs_volid_t vid = cbb->fid.vid;\n\tsize_t i;\n\n\tvolume = afs_lookup_volume_rcu(server->cell, vid);\n\n\t \n\n\tfor (i = *_count; i > 0; cbb++, i--) {\n\t\tif (cbb->fid.vid == vid) {\n\t\t\t_debug(\"- Fid { vl=%08llx n=%llu u=%u }\",\n\t\t\t       cbb->fid.vid,\n\t\t\t       cbb->fid.vnode,\n\t\t\t       cbb->fid.unique);\n\t\t\t--*_count;\n\t\t\tif (volume)\n\t\t\t\tafs_break_one_callback(volume, &cbb->fid);\n\t\t} else {\n\t\t\t*residue++ = *cbb;\n\t\t}\n\t}\n}\n\n \nvoid afs_break_callbacks(struct afs_server *server, size_t count,\n\t\t\t struct afs_callback_break *callbacks)\n{\n\t_enter(\"%p,%zu,\", server, count);\n\n\tASSERT(server != NULL);\n\n\trcu_read_lock();\n\n\twhile (count > 0)\n\t\tafs_break_some_callbacks(server, callbacks, &count);\n\n\trcu_read_unlock();\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}