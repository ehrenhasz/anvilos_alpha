{
  "module_name": "proc.c",
  "hash_id": "dfa59392103ff4bd761532d3de178c218abf3db72a585f0487a3e4c98b28e37c",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/proc.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\nstruct afs_vl_seq_net_private {\n\tstruct seq_net_private\t\tseq;\t \n\tstruct afs_vlserver_list\t*vllist;\n};\n\nstatic inline struct afs_net *afs_seq2net(struct seq_file *m)\n{\n\treturn afs_net(seq_file_net(m));\n}\n\nstatic inline struct afs_net *afs_seq2net_single(struct seq_file *m)\n{\n\treturn afs_net(seq_file_single_net(m));\n}\n\n \nstatic int afs_proc_cells_show(struct seq_file *m, void *v)\n{\n\tstruct afs_vlserver_list *vllist;\n\tstruct afs_cell *cell;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\t \n\t\tseq_puts(m, \"USE ACT    TTL SV ST NAME\\n\");\n\t\treturn 0;\n\t}\n\n\tcell = list_entry(v, struct afs_cell, proc_link);\n\tvllist = rcu_dereference(cell->vl_servers);\n\n\t \n\tseq_printf(m, \"%3u %3u %6lld %2u %2u %s\\n\",\n\t\t   refcount_read(&cell->ref),\n\t\t   atomic_read(&cell->active),\n\t\t   cell->dns_expiry - ktime_get_real_seconds(),\n\t\t   vllist ? vllist->nr_servers : 0,\n\t\t   cell->state,\n\t\t   cell->name);\n\treturn 0;\n}\n\nstatic void *afs_proc_cells_start(struct seq_file *m, loff_t *_pos)\n\t__acquires(rcu)\n{\n\trcu_read_lock();\n\treturn seq_hlist_start_head_rcu(&afs_seq2net(m)->proc_cells, *_pos);\n}\n\nstatic void *afs_proc_cells_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_hlist_next_rcu(v, &afs_seq2net(m)->proc_cells, pos);\n}\n\nstatic void afs_proc_cells_stop(struct seq_file *m, void *v)\n\t__releases(rcu)\n{\n\trcu_read_unlock();\n}\n\nstatic const struct seq_operations afs_proc_cells_ops = {\n\t.start\t= afs_proc_cells_start,\n\t.next\t= afs_proc_cells_next,\n\t.stop\t= afs_proc_cells_stop,\n\t.show\t= afs_proc_cells_show,\n};\n\n \nstatic int afs_proc_cells_write(struct file *file, char *buf, size_t size)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct afs_net *net = afs_seq2net(m);\n\tchar *name, *args;\n\tint ret;\n\n\t \n\tname = memchr(buf, '\\n', size);\n\tif (name)\n\t\t*name = 0;\n\n\t \n\tname = strchr(buf, ' ');\n\tif (!name)\n\t\tgoto inval;\n\tdo {\n\t\t*name++ = 0;\n\t} while(*name == ' ');\n\tif (!*name)\n\t\tgoto inval;\n\n\targs = strchr(name, ' ');\n\tif (args) {\n\t\tdo {\n\t\t\t*args++ = 0;\n\t\t} while(*args == ' ');\n\t\tif (!*args)\n\t\t\tgoto inval;\n\t}\n\n\t \n\t_debug(\"cmd=%s name=%s args=%s\", buf, name, args);\n\n\tif (strcmp(buf, \"add\") == 0) {\n\t\tstruct afs_cell *cell;\n\n\t\tcell = afs_lookup_cell(net, name, strlen(name), args, true);\n\t\tif (IS_ERR(cell)) {\n\t\t\tret = PTR_ERR(cell);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (test_and_set_bit(AFS_CELL_FL_NO_GC, &cell->flags))\n\t\t\tafs_unuse_cell(net, cell, afs_cell_trace_unuse_no_pin);\n\t} else {\n\t\tgoto inval;\n\t}\n\n\tret = 0;\n\ndone:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\ninval:\n\tret = -EINVAL;\n\tprintk(\"kAFS: Invalid Command on /proc/fs/afs/cells file\\n\");\n\tgoto done;\n}\n\n \nstatic int afs_proc_rootcell_show(struct seq_file *m, void *v)\n{\n\tstruct afs_cell *cell;\n\tstruct afs_net *net;\n\n\tnet = afs_seq2net_single(m);\n\tdown_read(&net->cells_lock);\n\tcell = net->ws_cell;\n\tif (cell)\n\t\tseq_printf(m, \"%s\\n\", cell->name);\n\tup_read(&net->cells_lock);\n\treturn 0;\n}\n\n \nstatic int afs_proc_rootcell_write(struct file *file, char *buf, size_t size)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct afs_net *net = afs_seq2net_single(m);\n\tchar *s;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (buf[0] == '.')\n\t\tgoto out;\n\tif (memchr(buf, '/', size))\n\t\tgoto out;\n\n\t \n\ts = memchr(buf, '\\n', size);\n\tif (s)\n\t\t*s = 0;\n\n\t \n\t_debug(\"rootcell=%s\", buf);\n\n\tret = afs_cell_init(net, buf);\n\nout:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\nstatic const char afs_vol_types[3][3] = {\n\t[AFSVL_RWVOL]\t= \"RW\",\n\t[AFSVL_ROVOL]\t= \"RO\",\n\t[AFSVL_BACKVOL]\t= \"BK\",\n};\n\n \nstatic int afs_proc_cell_volumes_show(struct seq_file *m, void *v)\n{\n\tstruct afs_volume *vol = hlist_entry(v, struct afs_volume, proc_link);\n\n\t \n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(m, \"USE VID      TY NAME\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"%3d %08llx %s %s\\n\",\n\t\t   refcount_read(&vol->ref), vol->vid,\n\t\t   afs_vol_types[vol->type],\n\t\t   vol->name);\n\n\treturn 0;\n}\n\nstatic void *afs_proc_cell_volumes_start(struct seq_file *m, loff_t *_pos)\n\t__acquires(cell->proc_lock)\n{\n\tstruct afs_cell *cell = pde_data(file_inode(m->file));\n\n\trcu_read_lock();\n\treturn seq_hlist_start_head_rcu(&cell->proc_volumes, *_pos);\n}\n\nstatic void *afs_proc_cell_volumes_next(struct seq_file *m, void *v,\n\t\t\t\t\tloff_t *_pos)\n{\n\tstruct afs_cell *cell = pde_data(file_inode(m->file));\n\n\treturn seq_hlist_next_rcu(v, &cell->proc_volumes, _pos);\n}\n\nstatic void afs_proc_cell_volumes_stop(struct seq_file *m, void *v)\n\t__releases(cell->proc_lock)\n{\n\trcu_read_unlock();\n}\n\nstatic const struct seq_operations afs_proc_cell_volumes_ops = {\n\t.start\t= afs_proc_cell_volumes_start,\n\t.next\t= afs_proc_cell_volumes_next,\n\t.stop\t= afs_proc_cell_volumes_stop,\n\t.show\t= afs_proc_cell_volumes_show,\n};\n\nstatic const char *const dns_record_sources[NR__dns_record_source + 1] = {\n\t[DNS_RECORD_UNAVAILABLE]\t= \"unav\",\n\t[DNS_RECORD_FROM_CONFIG]\t= \"cfg\",\n\t[DNS_RECORD_FROM_DNS_A]\t\t= \"A\",\n\t[DNS_RECORD_FROM_DNS_AFSDB]\t= \"AFSDB\",\n\t[DNS_RECORD_FROM_DNS_SRV]\t= \"SRV\",\n\t[DNS_RECORD_FROM_NSS]\t\t= \"nss\",\n\t[NR__dns_record_source]\t\t= \"[weird]\"\n};\n\nstatic const char *const dns_lookup_statuses[NR__dns_lookup_status + 1] = {\n\t[DNS_LOOKUP_NOT_DONE]\t\t= \"no-lookup\",\n\t[DNS_LOOKUP_GOOD]\t\t= \"good\",\n\t[DNS_LOOKUP_GOOD_WITH_BAD]\t= \"good/bad\",\n\t[DNS_LOOKUP_BAD]\t\t= \"bad\",\n\t[DNS_LOOKUP_GOT_NOT_FOUND]\t= \"not-found\",\n\t[DNS_LOOKUP_GOT_LOCAL_FAILURE]\t= \"local-failure\",\n\t[DNS_LOOKUP_GOT_TEMP_FAILURE]\t= \"temp-failure\",\n\t[DNS_LOOKUP_GOT_NS_FAILURE]\t= \"ns-failure\",\n\t[NR__dns_lookup_status]\t\t= \"[weird]\"\n};\n\n \nstatic int afs_proc_cell_vlservers_show(struct seq_file *m, void *v)\n{\n\tconst struct afs_vl_seq_net_private *priv = m->private;\n\tconst struct afs_vlserver_list *vllist = priv->vllist;\n\tconst struct afs_vlserver_entry *entry;\n\tconst struct afs_vlserver *vlserver;\n\tconst struct afs_addr_list *alist;\n\tint i;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(m, \"# source %s, status %s\\n\",\n\t\t\t   dns_record_sources[vllist ? vllist->source : 0],\n\t\t\t   dns_lookup_statuses[vllist ? vllist->status : 0]);\n\t\treturn 0;\n\t}\n\n\tentry = v;\n\tvlserver = entry->server;\n\talist = rcu_dereference(vlserver->addresses);\n\n\tseq_printf(m, \"%s [p=%hu w=%hu s=%s,%s]:\\n\",\n\t\t   vlserver->name, entry->priority, entry->weight,\n\t\t   dns_record_sources[alist ? alist->source : entry->source],\n\t\t   dns_lookup_statuses[alist ? alist->status : entry->status]);\n\tif (alist) {\n\t\tfor (i = 0; i < alist->nr_addrs; i++)\n\t\t\tseq_printf(m, \" %c %pISpc\\n\",\n\t\t\t\t   alist->preferred == i ? '>' : '-',\n\t\t\t\t   &alist->addrs[i].transport);\n\t}\n\tseq_printf(m, \" info: fl=%lx rtt=%d\\n\", vlserver->flags, vlserver->rtt);\n\tseq_printf(m, \" probe: fl=%x e=%d ac=%d out=%d\\n\",\n\t\t   vlserver->probe.flags, vlserver->probe.error,\n\t\t   vlserver->probe.abort_code,\n\t\t   atomic_read(&vlserver->probe_outstanding));\n\treturn 0;\n}\n\nstatic void *afs_proc_cell_vlservers_start(struct seq_file *m, loff_t *_pos)\n\t__acquires(rcu)\n{\n\tstruct afs_vl_seq_net_private *priv = m->private;\n\tstruct afs_vlserver_list *vllist;\n\tstruct afs_cell *cell = pde_data(file_inode(m->file));\n\tloff_t pos = *_pos;\n\n\trcu_read_lock();\n\n\tvllist = rcu_dereference(cell->vl_servers);\n\tpriv->vllist = vllist;\n\n\tif (pos < 0)\n\t\t*_pos = pos = 0;\n\tif (pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tif (pos - 1 >= vllist->nr_servers)\n\t\treturn NULL;\n\n\treturn &vllist->servers[pos - 1];\n}\n\nstatic void *afs_proc_cell_vlservers_next(struct seq_file *m, void *v,\n\t\t\t\t\t  loff_t *_pos)\n{\n\tstruct afs_vl_seq_net_private *priv = m->private;\n\tstruct afs_vlserver_list *vllist = priv->vllist;\n\tloff_t pos;\n\n\tpos = *_pos;\n\tpos++;\n\t*_pos = pos;\n\tif (!vllist || pos - 1 >= vllist->nr_servers)\n\t\treturn NULL;\n\n\treturn &vllist->servers[pos - 1];\n}\n\nstatic void afs_proc_cell_vlservers_stop(struct seq_file *m, void *v)\n\t__releases(rcu)\n{\n\trcu_read_unlock();\n}\n\nstatic const struct seq_operations afs_proc_cell_vlservers_ops = {\n\t.start\t= afs_proc_cell_vlservers_start,\n\t.next\t= afs_proc_cell_vlservers_next,\n\t.stop\t= afs_proc_cell_vlservers_stop,\n\t.show\t= afs_proc_cell_vlservers_show,\n};\n\n \nstatic int afs_proc_servers_show(struct seq_file *m, void *v)\n{\n\tstruct afs_server *server;\n\tstruct afs_addr_list *alist;\n\tint i;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(m, \"UUID                                 REF ACT\\n\");\n\t\treturn 0;\n\t}\n\n\tserver = list_entry(v, struct afs_server, proc_link);\n\talist = rcu_dereference(server->addresses);\n\tseq_printf(m, \"%pU %3d %3d\\n\",\n\t\t   &server->uuid,\n\t\t   refcount_read(&server->ref),\n\t\t   atomic_read(&server->active));\n\tseq_printf(m, \"  - info: fl=%lx rtt=%u brk=%x\\n\",\n\t\t   server->flags, server->rtt, server->cb_s_break);\n\tseq_printf(m, \"  - probe: last=%d out=%d\\n\",\n\t\t   (int)(jiffies - server->probed_at) / HZ,\n\t\t   atomic_read(&server->probe_outstanding));\n\tseq_printf(m, \"  - ALIST v=%u rsp=%lx f=%lx\\n\",\n\t\t   alist->version, alist->responded, alist->failed);\n\tfor (i = 0; i < alist->nr_addrs; i++)\n\t\tseq_printf(m, \"    [%x] %pISpc%s\\n\",\n\t\t\t   i, &alist->addrs[i].transport,\n\t\t\t   alist->preferred == i ? \"*\" : \"\");\n\treturn 0;\n}\n\nstatic void *afs_proc_servers_start(struct seq_file *m, loff_t *_pos)\n\t__acquires(rcu)\n{\n\trcu_read_lock();\n\treturn seq_hlist_start_head_rcu(&afs_seq2net(m)->fs_proc, *_pos);\n}\n\nstatic void *afs_proc_servers_next(struct seq_file *m, void *v, loff_t *_pos)\n{\n\treturn seq_hlist_next_rcu(v, &afs_seq2net(m)->fs_proc, _pos);\n}\n\nstatic void afs_proc_servers_stop(struct seq_file *m, void *v)\n\t__releases(rcu)\n{\n\trcu_read_unlock();\n}\n\nstatic const struct seq_operations afs_proc_servers_ops = {\n\t.start\t= afs_proc_servers_start,\n\t.next\t= afs_proc_servers_next,\n\t.stop\t= afs_proc_servers_stop,\n\t.show\t= afs_proc_servers_show,\n};\n\n \nstatic int afs_proc_sysname_show(struct seq_file *m, void *v)\n{\n\tstruct afs_net *net = afs_seq2net(m);\n\tstruct afs_sysnames *sysnames = net->sysnames;\n\tunsigned int i = (unsigned long)v - 1;\n\n\tif (i < sysnames->nr)\n\t\tseq_printf(m, \"%s\\n\", sysnames->subs[i]);\n\treturn 0;\n}\n\nstatic void *afs_proc_sysname_start(struct seq_file *m, loff_t *pos)\n\t__acquires(&net->sysnames_lock)\n{\n\tstruct afs_net *net = afs_seq2net(m);\n\tstruct afs_sysnames *names;\n\n\tread_lock(&net->sysnames_lock);\n\n\tnames = net->sysnames;\n\tif (*pos >= names->nr)\n\t\treturn NULL;\n\treturn (void *)(unsigned long)(*pos + 1);\n}\n\nstatic void *afs_proc_sysname_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct afs_net *net = afs_seq2net(m);\n\tstruct afs_sysnames *names = net->sysnames;\n\n\t*pos += 1;\n\tif (*pos >= names->nr)\n\t\treturn NULL;\n\treturn (void *)(unsigned long)(*pos + 1);\n}\n\nstatic void afs_proc_sysname_stop(struct seq_file *m, void *v)\n\t__releases(&net->sysnames_lock)\n{\n\tstruct afs_net *net = afs_seq2net(m);\n\n\tread_unlock(&net->sysnames_lock);\n}\n\nstatic const struct seq_operations afs_proc_sysname_ops = {\n\t.start\t= afs_proc_sysname_start,\n\t.next\t= afs_proc_sysname_next,\n\t.stop\t= afs_proc_sysname_stop,\n\t.show\t= afs_proc_sysname_show,\n};\n\n \nstatic int afs_proc_sysname_write(struct file *file, char *buf, size_t size)\n{\n\tstruct afs_sysnames *sysnames, *kill;\n\tstruct seq_file *m = file->private_data;\n\tstruct afs_net *net = afs_seq2net(m);\n\tchar *s, *p, *sub;\n\tint ret, len;\n\n\tsysnames = kzalloc(sizeof(*sysnames), GFP_KERNEL);\n\tif (!sysnames)\n\t\treturn -ENOMEM;\n\trefcount_set(&sysnames->usage, 1);\n\tkill = sysnames;\n\n\tp = buf;\n\twhile ((s = strsep(&p, \" \\t\\n\"))) {\n\t\tlen = strlen(s);\n\t\tif (len == 0)\n\t\t\tcontinue;\n\t\tret = -ENAMETOOLONG;\n\t\tif (len >= AFSNAMEMAX)\n\t\t\tgoto error;\n\n\t\tif (len >= 4 &&\n\t\t    s[len - 4] == '@' &&\n\t\t    s[len - 3] == 's' &&\n\t\t    s[len - 2] == 'y' &&\n\t\t    s[len - 1] == 's')\n\t\t\t \n\t\t\tgoto invalid;\n\n\t\tif (s[0] == '.' &&\n\t\t    (len < 2 || (len == 2 && s[1] == '.')))\n\t\t\tgoto invalid;\n\n\t\tif (memchr(s, '/', len))\n\t\t\tgoto invalid;\n\n\t\tret = -EFBIG;\n\t\tif (sysnames->nr >= AFS_NR_SYSNAME)\n\t\t\tgoto out;\n\n\t\tif (strcmp(s, afs_init_sysname) == 0) {\n\t\t\tsub = (char *)afs_init_sysname;\n\t\t} else {\n\t\t\tret = -ENOMEM;\n\t\t\tsub = kmemdup(s, len + 1, GFP_KERNEL);\n\t\t\tif (!sub)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tsysnames->subs[sysnames->nr] = sub;\n\t\tsysnames->nr++;\n\t}\n\n\tif (sysnames->nr == 0) {\n\t\tsysnames->subs[0] = sysnames->blank;\n\t\tsysnames->nr++;\n\t}\n\n\twrite_lock(&net->sysnames_lock);\n\tkill = net->sysnames;\n\tnet->sysnames = sysnames;\n\twrite_unlock(&net->sysnames_lock);\n\tret = 0;\nout:\n\tafs_put_sysnames(kill);\n\treturn ret;\n\ninvalid:\n\tret = -EINVAL;\nerror:\n\tgoto out;\n}\n\nvoid afs_put_sysnames(struct afs_sysnames *sysnames)\n{\n\tint i;\n\n\tif (sysnames && refcount_dec_and_test(&sysnames->usage)) {\n\t\tfor (i = 0; i < sysnames->nr; i++)\n\t\t\tif (sysnames->subs[i] != afs_init_sysname &&\n\t\t\t    sysnames->subs[i] != sysnames->blank)\n\t\t\t\tkfree(sysnames->subs[i]);\n\t\tkfree(sysnames);\n\t}\n}\n\n \nstatic int afs_proc_stats_show(struct seq_file *m, void *v)\n{\n\tstruct afs_net *net = afs_seq2net_single(m);\n\n\tseq_puts(m, \"kAFS statistics\\n\");\n\n\tseq_printf(m, \"dir-mgmt: look=%u reval=%u inval=%u relpg=%u\\n\",\n\t\t   atomic_read(&net->n_lookup),\n\t\t   atomic_read(&net->n_reval),\n\t\t   atomic_read(&net->n_inval),\n\t\t   atomic_read(&net->n_relpg));\n\n\tseq_printf(m, \"dir-data: rdpg=%u\\n\",\n\t\t   atomic_read(&net->n_read_dir));\n\n\tseq_printf(m, \"dir-edit: cr=%u rm=%u\\n\",\n\t\t   atomic_read(&net->n_dir_cr),\n\t\t   atomic_read(&net->n_dir_rm));\n\n\tseq_printf(m, \"file-rd : n=%u nb=%lu\\n\",\n\t\t   atomic_read(&net->n_fetches),\n\t\t   atomic_long_read(&net->n_fetch_bytes));\n\tseq_printf(m, \"file-wr : n=%u nb=%lu\\n\",\n\t\t   atomic_read(&net->n_stores),\n\t\t   atomic_long_read(&net->n_store_bytes));\n\treturn 0;\n}\n\n \nint afs_proc_cell_setup(struct afs_cell *cell)\n{\n\tstruct proc_dir_entry *dir;\n\tstruct afs_net *net = cell->net;\n\n\t_enter(\"%p{%s},%p\", cell, cell->name, net->proc_afs);\n\n\tdir = proc_net_mkdir(net->net, cell->name, net->proc_afs);\n\tif (!dir)\n\t\tgoto error_dir;\n\n\tif (!proc_create_net_data(\"vlservers\", 0444, dir,\n\t\t\t\t  &afs_proc_cell_vlservers_ops,\n\t\t\t\t  sizeof(struct afs_vl_seq_net_private),\n\t\t\t\t  cell) ||\n\t    !proc_create_net_data(\"volumes\", 0444, dir,\n\t\t\t\t  &afs_proc_cell_volumes_ops,\n\t\t\t\t  sizeof(struct seq_net_private),\n\t\t\t\t  cell))\n\t\tgoto error_tree;\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_tree:\n\tremove_proc_subtree(cell->name, net->proc_afs);\nerror_dir:\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}\n\n \nvoid afs_proc_cell_remove(struct afs_cell *cell)\n{\n\tstruct afs_net *net = cell->net;\n\n\t_enter(\"\");\n\tremove_proc_subtree(cell->name, net->proc_afs);\n\t_leave(\"\");\n}\n\n \nint afs_proc_init(struct afs_net *net)\n{\n\tstruct proc_dir_entry *p;\n\n\t_enter(\"\");\n\n\tp = proc_net_mkdir(net->net, \"afs\", net->net->proc_net);\n\tif (!p)\n\t\tgoto error_dir;\n\n\tif (!proc_create_net_data_write(\"cells\", 0644, p,\n\t\t\t\t\t&afs_proc_cells_ops,\n\t\t\t\t\tafs_proc_cells_write,\n\t\t\t\t\tsizeof(struct seq_net_private),\n\t\t\t\t\tNULL) ||\n\t    !proc_create_net_single_write(\"rootcell\", 0644, p,\n\t\t\t\t\t  afs_proc_rootcell_show,\n\t\t\t\t\t  afs_proc_rootcell_write,\n\t\t\t\t\t  NULL) ||\n\t    !proc_create_net(\"servers\", 0444, p, &afs_proc_servers_ops,\n\t\t\t     sizeof(struct seq_net_private)) ||\n\t    !proc_create_net_single(\"stats\", 0444, p, afs_proc_stats_show, NULL) ||\n\t    !proc_create_net_data_write(\"sysname\", 0644, p,\n\t\t\t\t\t&afs_proc_sysname_ops,\n\t\t\t\t\tafs_proc_sysname_write,\n\t\t\t\t\tsizeof(struct seq_net_private),\n\t\t\t\t\tNULL))\n\t\tgoto error_tree;\n\n\tnet->proc_afs = p;\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_tree:\n\tproc_remove(p);\nerror_dir:\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}\n\n \nvoid afs_proc_cleanup(struct afs_net *net)\n{\n\tproc_remove(net->proc_afs);\n\tnet->proc_afs = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}