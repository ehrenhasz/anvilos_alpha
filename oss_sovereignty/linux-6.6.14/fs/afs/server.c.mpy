{
  "module_name": "server.c",
  "hash_id": "1bde57606aaff4892d8dac26d673394bb2a4866e41d978d26f0ce6b2962ca0a9",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/server.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include \"protocol_yfs.h\"\n\nstatic unsigned afs_server_gc_delay = 10;\t \nstatic atomic_t afs_server_debug_id;\n\nstatic struct afs_server *afs_maybe_use_server(struct afs_server *,\n\t\t\t\t\t       enum afs_server_trace);\nstatic void __afs_put_server(struct afs_net *, struct afs_server *);\n\n \nstruct afs_server *afs_find_server(struct afs_net *net,\n\t\t\t\t   const struct sockaddr_rxrpc *srx)\n{\n\tconst struct afs_addr_list *alist;\n\tstruct afs_server *server = NULL;\n\tunsigned int i;\n\tint seq = 0, diff;\n\n\trcu_read_lock();\n\n\tdo {\n\t\tif (server)\n\t\t\tafs_unuse_server_notime(net, server, afs_server_trace_put_find_rsq);\n\t\tserver = NULL;\n\t\tread_seqbegin_or_lock(&net->fs_addr_lock, &seq);\n\n\t\tif (srx->transport.family == AF_INET6) {\n\t\t\tconst struct sockaddr_in6 *a = &srx->transport.sin6, *b;\n\t\t\thlist_for_each_entry_rcu(server, &net->fs_addresses6, addr6_link) {\n\t\t\t\talist = rcu_dereference(server->addresses);\n\t\t\t\tfor (i = alist->nr_ipv4; i < alist->nr_addrs; i++) {\n\t\t\t\t\tb = &alist->addrs[i].transport.sin6;\n\t\t\t\t\tdiff = ((u16 __force)a->sin6_port -\n\t\t\t\t\t\t(u16 __force)b->sin6_port);\n\t\t\t\t\tif (diff == 0)\n\t\t\t\t\t\tdiff = memcmp(&a->sin6_addr,\n\t\t\t\t\t\t\t      &b->sin6_addr,\n\t\t\t\t\t\t\t      sizeof(struct in6_addr));\n\t\t\t\t\tif (diff == 0)\n\t\t\t\t\t\tgoto found;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst struct sockaddr_in *a = &srx->transport.sin, *b;\n\t\t\thlist_for_each_entry_rcu(server, &net->fs_addresses4, addr4_link) {\n\t\t\t\talist = rcu_dereference(server->addresses);\n\t\t\t\tfor (i = 0; i < alist->nr_ipv4; i++) {\n\t\t\t\t\tb = &alist->addrs[i].transport.sin;\n\t\t\t\t\tdiff = ((u16 __force)a->sin_port -\n\t\t\t\t\t\t(u16 __force)b->sin_port);\n\t\t\t\t\tif (diff == 0)\n\t\t\t\t\t\tdiff = ((u32 __force)a->sin_addr.s_addr -\n\t\t\t\t\t\t\t(u32 __force)b->sin_addr.s_addr);\n\t\t\t\t\tif (diff == 0)\n\t\t\t\t\t\tgoto found;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tserver = NULL;\n\t\tcontinue;\n\tfound:\n\t\tserver = afs_maybe_use_server(server, afs_server_trace_get_by_addr);\n\n\t} while (need_seqretry(&net->fs_addr_lock, seq));\n\n\tdone_seqretry(&net->fs_addr_lock, seq);\n\n\trcu_read_unlock();\n\treturn server;\n}\n\n \nstruct afs_server *afs_find_server_by_uuid(struct afs_net *net, const uuid_t *uuid)\n{\n\tstruct afs_server *server = NULL;\n\tstruct rb_node *p;\n\tint diff, seq = 0;\n\n\t_enter(\"%pU\", uuid);\n\n\tdo {\n\t\t \n\t\tif (server)\n\t\t\tafs_unuse_server(net, server, afs_server_trace_put_uuid_rsq);\n\t\tserver = NULL;\n\n\t\tread_seqbegin_or_lock(&net->fs_lock, &seq);\n\n\t\tp = net->fs_servers.rb_node;\n\t\twhile (p) {\n\t\t\tserver = rb_entry(p, struct afs_server, uuid_rb);\n\n\t\t\tdiff = memcmp(uuid, &server->uuid, sizeof(*uuid));\n\t\t\tif (diff < 0) {\n\t\t\t\tp = p->rb_left;\n\t\t\t} else if (diff > 0) {\n\t\t\t\tp = p->rb_right;\n\t\t\t} else {\n\t\t\t\tafs_use_server(server, afs_server_trace_get_by_uuid);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tserver = NULL;\n\t\t}\n\t} while (need_seqretry(&net->fs_lock, seq));\n\n\tdone_seqretry(&net->fs_lock, seq);\n\n\t_leave(\" = %p\", server);\n\treturn server;\n}\n\n \nstatic struct afs_server *afs_install_server(struct afs_cell *cell,\n\t\t\t\t\t     struct afs_server *candidate)\n{\n\tconst struct afs_addr_list *alist;\n\tstruct afs_server *server, *next;\n\tstruct afs_net *net = cell->net;\n\tstruct rb_node **pp, *p;\n\tint diff;\n\n\t_enter(\"%p\", candidate);\n\n\twrite_seqlock(&net->fs_lock);\n\n\t \n\tpp = &net->fs_servers.rb_node;\n\tp = NULL;\n\twhile (*pp) {\n\t\tp = *pp;\n\t\t_debug(\"- consider %p\", p);\n\t\tserver = rb_entry(p, struct afs_server, uuid_rb);\n\t\tdiff = memcmp(&candidate->uuid, &server->uuid, sizeof(uuid_t));\n\t\tif (diff < 0) {\n\t\t\tpp = &(*pp)->rb_left;\n\t\t} else if (diff > 0) {\n\t\t\tpp = &(*pp)->rb_right;\n\t\t} else {\n\t\t\tif (server->cell == cell)\n\t\t\t\tgoto exists;\n\n\t\t\t \n\t\t\tfor (;;) {\n\t\t\t\tnext = rcu_dereference_protected(\n\t\t\t\t\tserver->uuid_next,\n\t\t\t\t\tlockdep_is_held(&net->fs_lock.lock));\n\t\t\t\tif (!next)\n\t\t\t\t\tbreak;\n\t\t\t\tserver = next;\n\t\t\t}\n\t\t\trcu_assign_pointer(server->uuid_next, candidate);\n\t\t\tcandidate->uuid_prev = server;\n\t\t\tserver = candidate;\n\t\t\tgoto added_dup;\n\t\t}\n\t}\n\n\tserver = candidate;\n\trb_link_node(&server->uuid_rb, p, pp);\n\trb_insert_color(&server->uuid_rb, &net->fs_servers);\n\thlist_add_head_rcu(&server->proc_link, &net->fs_proc);\n\nadded_dup:\n\twrite_seqlock(&net->fs_addr_lock);\n\talist = rcu_dereference_protected(server->addresses,\n\t\t\t\t\t  lockdep_is_held(&net->fs_addr_lock.lock));\n\n\t \n\tif (alist->nr_ipv4 > 0)\n\t\thlist_add_head_rcu(&server->addr4_link, &net->fs_addresses4);\n\tif (alist->nr_addrs > alist->nr_ipv4)\n\t\thlist_add_head_rcu(&server->addr6_link, &net->fs_addresses6);\n\n\twrite_sequnlock(&net->fs_addr_lock);\n\nexists:\n\tafs_get_server(server, afs_server_trace_get_install);\n\twrite_sequnlock(&net->fs_lock);\n\treturn server;\n}\n\n \nstatic struct afs_server *afs_alloc_server(struct afs_cell *cell,\n\t\t\t\t\t   const uuid_t *uuid,\n\t\t\t\t\t   struct afs_addr_list *alist)\n{\n\tstruct afs_server *server;\n\tstruct afs_net *net = cell->net;\n\n\t_enter(\"\");\n\n\tserver = kzalloc(sizeof(struct afs_server), GFP_KERNEL);\n\tif (!server)\n\t\tgoto enomem;\n\n\trefcount_set(&server->ref, 1);\n\tatomic_set(&server->active, 1);\n\tserver->debug_id = atomic_inc_return(&afs_server_debug_id);\n\tRCU_INIT_POINTER(server->addresses, alist);\n\tserver->addr_version = alist->version;\n\tserver->uuid = *uuid;\n\trwlock_init(&server->fs_lock);\n\tINIT_WORK(&server->initcb_work, afs_server_init_callback_work);\n\tinit_waitqueue_head(&server->probe_wq);\n\tINIT_LIST_HEAD(&server->probe_link);\n\tspin_lock_init(&server->probe_lock);\n\tserver->cell = cell;\n\tserver->rtt = UINT_MAX;\n\n\tafs_inc_servers_outstanding(net);\n\ttrace_afs_server(server->debug_id, 1, 1, afs_server_trace_alloc);\n\t_leave(\" = %p\", server);\n\treturn server;\n\nenomem:\n\t_leave(\" = NULL [nomem]\");\n\treturn NULL;\n}\n\n \nstatic struct afs_addr_list *afs_vl_lookup_addrs(struct afs_cell *cell,\n\t\t\t\t\t\t struct key *key, const uuid_t *uuid)\n{\n\tstruct afs_vl_cursor vc;\n\tstruct afs_addr_list *alist = NULL;\n\tint ret;\n\n\tret = -ERESTARTSYS;\n\tif (afs_begin_vlserver_operation(&vc, cell, key)) {\n\t\twhile (afs_select_vlserver(&vc)) {\n\t\t\tif (test_bit(AFS_VLSERVER_FL_IS_YFS, &vc.server->flags))\n\t\t\t\talist = afs_yfsvl_get_endpoints(&vc, uuid);\n\t\t\telse\n\t\t\t\talist = afs_vl_get_addrs_u(&vc, uuid);\n\t\t}\n\n\t\tret = afs_end_vlserver_operation(&vc);\n\t}\n\n\treturn ret < 0 ? ERR_PTR(ret) : alist;\n}\n\n \nstruct afs_server *afs_lookup_server(struct afs_cell *cell, struct key *key,\n\t\t\t\t     const uuid_t *uuid, u32 addr_version)\n{\n\tstruct afs_addr_list *alist;\n\tstruct afs_server *server, *candidate;\n\n\t_enter(\"%p,%pU\", cell->net, uuid);\n\n\tserver = afs_find_server_by_uuid(cell->net, uuid);\n\tif (server) {\n\t\tif (server->addr_version != addr_version)\n\t\t\tset_bit(AFS_SERVER_FL_NEEDS_UPDATE, &server->flags);\n\t\treturn server;\n\t}\n\n\talist = afs_vl_lookup_addrs(cell, key, uuid);\n\tif (IS_ERR(alist))\n\t\treturn ERR_CAST(alist);\n\n\tcandidate = afs_alloc_server(cell, uuid, alist);\n\tif (!candidate) {\n\t\tafs_put_addrlist(alist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tserver = afs_install_server(cell, candidate);\n\tif (server != candidate) {\n\t\tafs_put_addrlist(alist);\n\t\tkfree(candidate);\n\t} else {\n\t\t \n\t\tafs_fs_probe_fileserver(cell->net, server, key, true);\n\t}\n\n\treturn server;\n}\n\n \nstatic void afs_set_server_timer(struct afs_net *net, time64_t delay)\n{\n\tif (net->live) {\n\t\tafs_inc_servers_outstanding(net);\n\t\tif (timer_reduce(&net->fs_timer, jiffies + delay * HZ))\n\t\t\tafs_dec_servers_outstanding(net);\n\t}\n}\n\n \nvoid afs_servers_timer(struct timer_list *timer)\n{\n\tstruct afs_net *net = container_of(timer, struct afs_net, fs_timer);\n\n\t_enter(\"\");\n\tif (!queue_work(afs_wq, &net->fs_manager))\n\t\tafs_dec_servers_outstanding(net);\n}\n\n \nstruct afs_server *afs_get_server(struct afs_server *server,\n\t\t\t\t  enum afs_server_trace reason)\n{\n\tunsigned int a;\n\tint r;\n\n\t__refcount_inc(&server->ref, &r);\n\ta = atomic_read(&server->active);\n\ttrace_afs_server(server->debug_id, r + 1, a, reason);\n\treturn server;\n}\n\n \nstatic struct afs_server *afs_maybe_use_server(struct afs_server *server,\n\t\t\t\t\t       enum afs_server_trace reason)\n{\n\tunsigned int a;\n\tint r;\n\n\tif (!__refcount_inc_not_zero(&server->ref, &r))\n\t\treturn NULL;\n\n\ta = atomic_inc_return(&server->active);\n\ttrace_afs_server(server->debug_id, r + 1, a, reason);\n\treturn server;\n}\n\n \nstruct afs_server *afs_use_server(struct afs_server *server, enum afs_server_trace reason)\n{\n\tunsigned int a;\n\tint r;\n\n\t__refcount_inc(&server->ref, &r);\n\ta = atomic_inc_return(&server->active);\n\n\ttrace_afs_server(server->debug_id, r + 1, a, reason);\n\treturn server;\n}\n\n \nvoid afs_put_server(struct afs_net *net, struct afs_server *server,\n\t\t    enum afs_server_trace reason)\n{\n\tunsigned int a, debug_id = server->debug_id;\n\tbool zero;\n\tint r;\n\n\tif (!server)\n\t\treturn;\n\n\ta = atomic_read(&server->active);\n\tzero = __refcount_dec_and_test(&server->ref, &r);\n\ttrace_afs_server(debug_id, r - 1, a, reason);\n\tif (unlikely(zero))\n\t\t__afs_put_server(net, server);\n}\n\n \nvoid afs_unuse_server_notime(struct afs_net *net, struct afs_server *server,\n\t\t\t     enum afs_server_trace reason)\n{\n\tif (server) {\n\t\tunsigned int active = atomic_dec_return(&server->active);\n\n\t\tif (active == 0)\n\t\t\tafs_set_server_timer(net, afs_server_gc_delay);\n\t\tafs_put_server(net, server, reason);\n\t}\n}\n\n \nvoid afs_unuse_server(struct afs_net *net, struct afs_server *server,\n\t\t      enum afs_server_trace reason)\n{\n\tif (server) {\n\t\tserver->unuse_time = ktime_get_real_seconds();\n\t\tafs_unuse_server_notime(net, server, reason);\n\t}\n}\n\nstatic void afs_server_rcu(struct rcu_head *rcu)\n{\n\tstruct afs_server *server = container_of(rcu, struct afs_server, rcu);\n\n\ttrace_afs_server(server->debug_id, refcount_read(&server->ref),\n\t\t\t atomic_read(&server->active), afs_server_trace_free);\n\tafs_put_addrlist(rcu_access_pointer(server->addresses));\n\tkfree(server);\n}\n\nstatic void __afs_put_server(struct afs_net *net, struct afs_server *server)\n{\n\tcall_rcu(&server->rcu, afs_server_rcu);\n\tafs_dec_servers_outstanding(net);\n}\n\nstatic void afs_give_up_callbacks(struct afs_net *net, struct afs_server *server)\n{\n\tstruct afs_addr_list *alist = rcu_access_pointer(server->addresses);\n\tstruct afs_addr_cursor ac = {\n\t\t.alist\t= alist,\n\t\t.index\t= alist->preferred,\n\t\t.error\t= 0,\n\t};\n\n\tafs_fs_give_up_all_callbacks(net, server, &ac, NULL);\n}\n\n \nstatic void afs_destroy_server(struct afs_net *net, struct afs_server *server)\n{\n\tif (test_bit(AFS_SERVER_FL_MAY_HAVE_CB, &server->flags))\n\t\tafs_give_up_callbacks(net, server);\n\n\tflush_work(&server->initcb_work);\n\tafs_put_server(net, server, afs_server_trace_destroy);\n}\n\n \nstatic void afs_gc_servers(struct afs_net *net, struct afs_server *gc_list)\n{\n\tstruct afs_server *server, *next, *prev;\n\tint active;\n\n\twhile ((server = gc_list)) {\n\t\tgc_list = server->gc_next;\n\n\t\twrite_seqlock(&net->fs_lock);\n\n\t\tactive = atomic_read(&server->active);\n\t\tif (active == 0) {\n\t\t\ttrace_afs_server(server->debug_id, refcount_read(&server->ref),\n\t\t\t\t\t active, afs_server_trace_gc);\n\t\t\tnext = rcu_dereference_protected(\n\t\t\t\tserver->uuid_next, lockdep_is_held(&net->fs_lock.lock));\n\t\t\tprev = server->uuid_prev;\n\t\t\tif (!prev) {\n\t\t\t\t \n\t\t\t\tif (!next) {\n\t\t\t\t\trb_erase(&server->uuid_rb, &net->fs_servers);\n\t\t\t\t} else {\n\t\t\t\t\trb_replace_node_rcu(&server->uuid_rb,\n\t\t\t\t\t\t\t    &next->uuid_rb,\n\t\t\t\t\t\t\t    &net->fs_servers);\n\t\t\t\t\tnext->uuid_prev = NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trcu_assign_pointer(prev->uuid_next, next);\n\t\t\t\tif (next)\n\t\t\t\t\tnext->uuid_prev = prev;\n\t\t\t}\n\n\t\t\tlist_del(&server->probe_link);\n\t\t\thlist_del_rcu(&server->proc_link);\n\t\t\tif (!hlist_unhashed(&server->addr4_link))\n\t\t\t\thlist_del_rcu(&server->addr4_link);\n\t\t\tif (!hlist_unhashed(&server->addr6_link))\n\t\t\t\thlist_del_rcu(&server->addr6_link);\n\t\t}\n\t\twrite_sequnlock(&net->fs_lock);\n\n\t\tif (active == 0)\n\t\t\tafs_destroy_server(net, server);\n\t}\n}\n\n \nvoid afs_manage_servers(struct work_struct *work)\n{\n\tstruct afs_net *net = container_of(work, struct afs_net, fs_manager);\n\tstruct afs_server *gc_list = NULL;\n\tstruct rb_node *cursor;\n\ttime64_t now = ktime_get_real_seconds(), next_manage = TIME64_MAX;\n\tbool purging = !net->live;\n\n\t_enter(\"\");\n\n\t \n\tread_seqlock_excl(&net->fs_lock);\n\n\tfor (cursor = rb_first(&net->fs_servers); cursor; cursor = rb_next(cursor)) {\n\t\tstruct afs_server *server =\n\t\t\trb_entry(cursor, struct afs_server, uuid_rb);\n\t\tint active = atomic_read(&server->active);\n\n\t\t_debug(\"manage %pU %u\", &server->uuid, active);\n\n\t\tif (purging) {\n\t\t\ttrace_afs_server(server->debug_id, refcount_read(&server->ref),\n\t\t\t\t\t active, afs_server_trace_purging);\n\t\t\tif (active != 0)\n\t\t\t\tpr_notice(\"Can't purge s=%08x\\n\", server->debug_id);\n\t\t}\n\n\t\tif (active == 0) {\n\t\t\ttime64_t expire_at = server->unuse_time;\n\n\t\t\tif (!test_bit(AFS_SERVER_FL_VL_FAIL, &server->flags) &&\n\t\t\t    !test_bit(AFS_SERVER_FL_NOT_FOUND, &server->flags))\n\t\t\t\texpire_at += afs_server_gc_delay;\n\t\t\tif (purging || expire_at <= now) {\n\t\t\t\tserver->gc_next = gc_list;\n\t\t\t\tgc_list = server;\n\t\t\t} else if (expire_at < next_manage) {\n\t\t\t\tnext_manage = expire_at;\n\t\t\t}\n\t\t}\n\t}\n\n\tread_sequnlock_excl(&net->fs_lock);\n\n\t \n\tif (!purging && next_manage < TIME64_MAX) {\n\t\tnow = ktime_get_real_seconds();\n\n\t\tif (next_manage - now <= 0) {\n\t\t\tif (queue_work(afs_wq, &net->fs_manager))\n\t\t\t\tafs_inc_servers_outstanding(net);\n\t\t} else {\n\t\t\tafs_set_server_timer(net, next_manage - now);\n\t\t}\n\t}\n\n\tafs_gc_servers(net, gc_list);\n\n\tafs_dec_servers_outstanding(net);\n\t_leave(\" [%d]\", atomic_read(&net->servers_outstanding));\n}\n\nstatic void afs_queue_server_manager(struct afs_net *net)\n{\n\tafs_inc_servers_outstanding(net);\n\tif (!queue_work(afs_wq, &net->fs_manager))\n\t\tafs_dec_servers_outstanding(net);\n}\n\n \nvoid afs_purge_servers(struct afs_net *net)\n{\n\t_enter(\"\");\n\n\tif (del_timer_sync(&net->fs_timer))\n\t\tafs_dec_servers_outstanding(net);\n\n\tafs_queue_server_manager(net);\n\n\t_debug(\"wait\");\n\tatomic_dec(&net->servers_outstanding);\n\twait_var_event(&net->servers_outstanding,\n\t\t       !atomic_read(&net->servers_outstanding));\n\t_leave(\"\");\n}\n\n \nstatic noinline bool afs_update_server_record(struct afs_operation *op,\n\t\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_addr_list *alist, *discard;\n\n\t_enter(\"\");\n\n\ttrace_afs_server(server->debug_id, refcount_read(&server->ref),\n\t\t\t atomic_read(&server->active),\n\t\t\t afs_server_trace_update);\n\n\talist = afs_vl_lookup_addrs(op->volume->cell, op->key, &server->uuid);\n\tif (IS_ERR(alist)) {\n\t\tif ((PTR_ERR(alist) == -ERESTARTSYS ||\n\t\t     PTR_ERR(alist) == -EINTR) &&\n\t\t    (op->flags & AFS_OPERATION_UNINTR) &&\n\t\t    server->addresses) {\n\t\t\t_leave(\" = t [intr]\");\n\t\t\treturn true;\n\t\t}\n\t\top->error = PTR_ERR(alist);\n\t\t_leave(\" = f [%d]\", op->error);\n\t\treturn false;\n\t}\n\n\tdiscard = alist;\n\tif (server->addr_version != alist->version) {\n\t\twrite_lock(&server->fs_lock);\n\t\tdiscard = rcu_dereference_protected(server->addresses,\n\t\t\t\t\t\t    lockdep_is_held(&server->fs_lock));\n\t\trcu_assign_pointer(server->addresses, alist);\n\t\tserver->addr_version = alist->version;\n\t\twrite_unlock(&server->fs_lock);\n\t}\n\n\tafs_put_addrlist(discard);\n\t_leave(\" = t\");\n\treturn true;\n}\n\n \nbool afs_check_server_record(struct afs_operation *op, struct afs_server *server)\n{\n\tbool success;\n\tint ret, retries = 0;\n\n\t_enter(\"\");\n\n\tASSERT(server);\n\nretry:\n\tif (test_bit(AFS_SERVER_FL_UPDATING, &server->flags))\n\t\tgoto wait;\n\tif (test_bit(AFS_SERVER_FL_NEEDS_UPDATE, &server->flags))\n\t\tgoto update;\n\t_leave(\" = t [good]\");\n\treturn true;\n\nupdate:\n\tif (!test_and_set_bit_lock(AFS_SERVER_FL_UPDATING, &server->flags)) {\n\t\tclear_bit(AFS_SERVER_FL_NEEDS_UPDATE, &server->flags);\n\t\tsuccess = afs_update_server_record(op, server);\n\t\tclear_bit_unlock(AFS_SERVER_FL_UPDATING, &server->flags);\n\t\twake_up_bit(&server->flags, AFS_SERVER_FL_UPDATING);\n\t\t_leave(\" = %d\", success);\n\t\treturn success;\n\t}\n\nwait:\n\tret = wait_on_bit(&server->flags, AFS_SERVER_FL_UPDATING,\n\t\t\t  (op->flags & AFS_OPERATION_UNINTR) ?\n\t\t\t  TASK_UNINTERRUPTIBLE : TASK_INTERRUPTIBLE);\n\tif (ret == -ERESTARTSYS) {\n\t\top->error = ret;\n\t\t_leave(\" = f [intr]\");\n\t\treturn false;\n\t}\n\n\tretries++;\n\tif (retries == 4) {\n\t\t_leave(\" = f [stale]\");\n\t\tret = -ESTALE;\n\t\treturn false;\n\t}\n\tgoto retry;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}