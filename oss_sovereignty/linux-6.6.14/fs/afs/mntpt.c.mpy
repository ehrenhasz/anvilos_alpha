{
  "module_name": "mntpt.c",
  "hash_id": "ceb9727a9825cef2d3b85c3255ba76a2d5474be157bbc32ce0705a3b7a81ebb2",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/mntpt.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/gfp.h>\n#include <linux/fs_context.h>\n#include \"internal.h\"\n\n\nstatic struct dentry *afs_mntpt_lookup(struct inode *dir,\n\t\t\t\t       struct dentry *dentry,\n\t\t\t\t       unsigned int flags);\nstatic int afs_mntpt_open(struct inode *inode, struct file *file);\nstatic void afs_mntpt_expiry_timed_out(struct work_struct *work);\n\nconst struct file_operations afs_mntpt_file_operations = {\n\t.open\t\t= afs_mntpt_open,\n\t.llseek\t\t= noop_llseek,\n};\n\nconst struct inode_operations afs_mntpt_inode_operations = {\n\t.lookup\t\t= afs_mntpt_lookup,\n\t.readlink\t= page_readlink,\n\t.getattr\t= afs_getattr,\n};\n\nconst struct inode_operations afs_autocell_inode_operations = {\n\t.getattr\t= afs_getattr,\n};\n\nstatic LIST_HEAD(afs_vfsmounts);\nstatic DECLARE_DELAYED_WORK(afs_mntpt_expiry_timer, afs_mntpt_expiry_timed_out);\n\nstatic unsigned long afs_mntpt_expiry_timeout = 10 * 60;\n\nstatic const char afs_root_volume[] = \"root.cell\";\n\n \nstatic struct dentry *afs_mntpt_lookup(struct inode *dir,\n\t\t\t\t       struct dentry *dentry,\n\t\t\t\t       unsigned int flags)\n{\n\t_enter(\"%p,%p{%pd2}\", dir, dentry, dentry);\n\treturn ERR_PTR(-EREMOTE);\n}\n\n \nstatic int afs_mntpt_open(struct inode *inode, struct file *file)\n{\n\t_enter(\"%p,%p{%pD2}\", inode, file, file);\n\treturn -EREMOTE;\n}\n\n \nstatic int afs_mntpt_set_params(struct fs_context *fc, struct dentry *mntpt)\n{\n\tstruct afs_fs_context *ctx = fc->fs_private;\n\tstruct afs_super_info *src_as = AFS_FS_S(mntpt->d_sb);\n\tstruct afs_vnode *vnode = AFS_FS_I(d_inode(mntpt));\n\tstruct afs_cell *cell;\n\tconst char *p;\n\tint ret;\n\n\tif (fc->net_ns != src_as->net_ns) {\n\t\tput_net(fc->net_ns);\n\t\tfc->net_ns = get_net(src_as->net_ns);\n\t}\n\n\tif (src_as->volume && src_as->volume->type == AFSVL_RWVOL) {\n\t\tctx->type = AFSVL_RWVOL;\n\t\tctx->force = true;\n\t}\n\tif (ctx->cell) {\n\t\tafs_unuse_cell(ctx->net, ctx->cell, afs_cell_trace_unuse_mntpt);\n\t\tctx->cell = NULL;\n\t}\n\tif (test_bit(AFS_VNODE_PSEUDODIR, &vnode->flags)) {\n\t\t \n\t\tunsigned size = mntpt->d_name.len;\n\n\t\tif (size < 2)\n\t\t\treturn -ENOENT;\n\n\t\tp = mntpt->d_name.name;\n\t\tif (mntpt->d_name.name[0] == '.') {\n\t\t\tsize--;\n\t\t\tp++;\n\t\t\tctx->type = AFSVL_RWVOL;\n\t\t\tctx->force = true;\n\t\t}\n\t\tif (size > AFS_MAXCELLNAME)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\tcell = afs_lookup_cell(ctx->net, p, size, NULL, false);\n\t\tif (IS_ERR(cell)) {\n\t\t\tpr_err(\"kAFS: unable to lookup cell '%pd'\\n\", mntpt);\n\t\t\treturn PTR_ERR(cell);\n\t\t}\n\t\tctx->cell = cell;\n\n\t\tctx->volname = afs_root_volume;\n\t\tctx->volnamesz = sizeof(afs_root_volume) - 1;\n\t} else {\n\t\t \n\t\tstruct page *page;\n\t\tloff_t size = i_size_read(d_inode(mntpt));\n\t\tchar *buf;\n\n\t\tif (src_as->cell)\n\t\t\tctx->cell = afs_use_cell(src_as->cell, afs_cell_trace_use_mntpt);\n\n\t\tif (size < 2 || size > PAGE_SIZE - 1)\n\t\t\treturn -EINVAL;\n\n\t\tpage = read_mapping_page(d_inode(mntpt)->i_mapping, 0, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\n\t\tbuf = kmap(page);\n\t\tret = -EINVAL;\n\t\tif (buf[size - 1] == '.')\n\t\t\tret = vfs_parse_fs_string(fc, \"source\", buf, size - 1);\n\t\tkunmap(page);\n\t\tput_page(page);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct vfsmount *afs_mntpt_do_automount(struct dentry *mntpt)\n{\n\tstruct fs_context *fc;\n\tstruct vfsmount *mnt;\n\tint ret;\n\n\tBUG_ON(!d_inode(mntpt));\n\n\tfc = fs_context_for_submount(&afs_fs_type, mntpt);\n\tif (IS_ERR(fc))\n\t\treturn ERR_CAST(fc);\n\n\tret = afs_mntpt_set_params(fc, mntpt);\n\tif (!ret)\n\t\tmnt = fc_mount(fc);\n\telse\n\t\tmnt = ERR_PTR(ret);\n\n\tput_fs_context(fc);\n\treturn mnt;\n}\n\n \nstruct vfsmount *afs_d_automount(struct path *path)\n{\n\tstruct vfsmount *newmnt;\n\n\t_enter(\"{%pd}\", path->dentry);\n\n\tnewmnt = afs_mntpt_do_automount(path->dentry);\n\tif (IS_ERR(newmnt))\n\t\treturn newmnt;\n\n\tmntget(newmnt);  \n\tmnt_set_expiry(newmnt, &afs_vfsmounts);\n\tqueue_delayed_work(afs_wq, &afs_mntpt_expiry_timer,\n\t\t\t   afs_mntpt_expiry_timeout * HZ);\n\t_leave(\" = %p\", newmnt);\n\treturn newmnt;\n}\n\n \nstatic void afs_mntpt_expiry_timed_out(struct work_struct *work)\n{\n\t_enter(\"\");\n\n\tif (!list_empty(&afs_vfsmounts)) {\n\t\tmark_mounts_for_expiry(&afs_vfsmounts);\n\t\tqueue_delayed_work(afs_wq, &afs_mntpt_expiry_timer,\n\t\t\t\t   afs_mntpt_expiry_timeout * HZ);\n\t}\n\n\t_leave(\"\");\n}\n\n \nvoid afs_mntpt_kill_timer(void)\n{\n\t_enter(\"\");\n\n\tASSERT(list_empty(&afs_vfsmounts));\n\tcancel_delayed_work_sync(&afs_mntpt_expiry_timer);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}