{
  "module_name": "volume.c",
  "hash_id": "3634457a4093573ff60f4a060655896d3494914b5b20aa5e2c69e1af903237ca",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/volume.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include \"internal.h\"\n\nstatic unsigned __read_mostly afs_volume_record_life = 60 * 60;\n\n \nstatic struct afs_volume *afs_insert_volume_into_cell(struct afs_cell *cell,\n\t\t\t\t\t\t      struct afs_volume *volume)\n{\n\tstruct afs_volume *p;\n\tstruct rb_node *parent = NULL, **pp;\n\n\twrite_seqlock(&cell->volume_lock);\n\n\tpp = &cell->volumes.rb_node;\n\twhile (*pp) {\n\t\tparent = *pp;\n\t\tp = rb_entry(parent, struct afs_volume, cell_node);\n\t\tif (p->vid < volume->vid) {\n\t\t\tpp = &(*pp)->rb_left;\n\t\t} else if (p->vid > volume->vid) {\n\t\t\tpp = &(*pp)->rb_right;\n\t\t} else {\n\t\t\tif (afs_try_get_volume(p, afs_volume_trace_get_cell_insert)) {\n\t\t\t\tvolume = p;\n\t\t\t\tgoto found;\n\t\t\t}\n\n\t\t\tset_bit(AFS_VOLUME_RM_TREE, &volume->flags);\n\t\t\trb_replace_node_rcu(&p->cell_node, &volume->cell_node, &cell->volumes);\n\t\t}\n\t}\n\n\trb_link_node_rcu(&volume->cell_node, parent, pp);\n\trb_insert_color(&volume->cell_node, &cell->volumes);\n\thlist_add_head_rcu(&volume->proc_link, &cell->proc_volumes);\n\nfound:\n\twrite_sequnlock(&cell->volume_lock);\n\treturn volume;\n\n}\n\nstatic void afs_remove_volume_from_cell(struct afs_volume *volume)\n{\n\tstruct afs_cell *cell = volume->cell;\n\n\tif (!hlist_unhashed(&volume->proc_link)) {\n\t\ttrace_afs_volume(volume->vid, refcount_read(&cell->ref),\n\t\t\t\t afs_volume_trace_remove);\n\t\twrite_seqlock(&cell->volume_lock);\n\t\thlist_del_rcu(&volume->proc_link);\n\t\tif (!test_and_set_bit(AFS_VOLUME_RM_TREE, &volume->flags))\n\t\t\trb_erase(&volume->cell_node, &cell->volumes);\n\t\twrite_sequnlock(&cell->volume_lock);\n\t}\n}\n\n \nstatic struct afs_volume *afs_alloc_volume(struct afs_fs_context *params,\n\t\t\t\t\t   struct afs_vldb_entry *vldb,\n\t\t\t\t\t   unsigned long type_mask)\n{\n\tstruct afs_server_list *slist;\n\tstruct afs_volume *volume;\n\tint ret = -ENOMEM;\n\n\tvolume = kzalloc(sizeof(struct afs_volume), GFP_KERNEL);\n\tif (!volume)\n\t\tgoto error_0;\n\n\tvolume->vid\t\t= vldb->vid[params->type];\n\tvolume->update_at\t= ktime_get_real_seconds() + afs_volume_record_life;\n\tvolume->cell\t\t= afs_get_cell(params->cell, afs_cell_trace_get_vol);\n\tvolume->type\t\t= params->type;\n\tvolume->type_force\t= params->force;\n\tvolume->name_len\t= vldb->name_len;\n\n\trefcount_set(&volume->ref, 1);\n\tINIT_HLIST_NODE(&volume->proc_link);\n\trwlock_init(&volume->servers_lock);\n\trwlock_init(&volume->cb_v_break_lock);\n\tmemcpy(volume->name, vldb->name, vldb->name_len + 1);\n\n\tslist = afs_alloc_server_list(params->cell, params->key, vldb, type_mask);\n\tif (IS_ERR(slist)) {\n\t\tret = PTR_ERR(slist);\n\t\tgoto error_1;\n\t}\n\n\trefcount_set(&slist->usage, 1);\n\trcu_assign_pointer(volume->servers, slist);\n\ttrace_afs_volume(volume->vid, 1, afs_volume_trace_alloc);\n\treturn volume;\n\nerror_1:\n\tafs_put_cell(volume->cell, afs_cell_trace_put_vol);\n\tkfree(volume);\nerror_0:\n\treturn ERR_PTR(ret);\n}\n\n \nstatic struct afs_volume *afs_lookup_volume(struct afs_fs_context *params,\n\t\t\t\t\t    struct afs_vldb_entry *vldb,\n\t\t\t\t\t    unsigned long type_mask)\n{\n\tstruct afs_volume *candidate, *volume;\n\n\tcandidate = afs_alloc_volume(params, vldb, type_mask);\n\tif (IS_ERR(candidate))\n\t\treturn candidate;\n\n\tvolume = afs_insert_volume_into_cell(params->cell, candidate);\n\tif (volume != candidate)\n\t\tafs_put_volume(params->net, candidate, afs_volume_trace_put_cell_dup);\n\treturn volume;\n}\n\n \nstatic struct afs_vldb_entry *afs_vl_lookup_vldb(struct afs_cell *cell,\n\t\t\t\t\t\t struct key *key,\n\t\t\t\t\t\t const char *volname,\n\t\t\t\t\t\t size_t volnamesz)\n{\n\tstruct afs_vldb_entry *vldb = ERR_PTR(-EDESTADDRREQ);\n\tstruct afs_vl_cursor vc;\n\tint ret;\n\n\tif (!afs_begin_vlserver_operation(&vc, cell, key))\n\t\treturn ERR_PTR(-ERESTARTSYS);\n\n\twhile (afs_select_vlserver(&vc)) {\n\t\tvldb = afs_vl_get_entry_by_name_u(&vc, volname, volnamesz);\n\t}\n\n\tret = afs_end_vlserver_operation(&vc);\n\treturn ret < 0 ? ERR_PTR(ret) : vldb;\n}\n\n \nstruct afs_volume *afs_create_volume(struct afs_fs_context *params)\n{\n\tstruct afs_vldb_entry *vldb;\n\tstruct afs_volume *volume;\n\tunsigned long type_mask = 1UL << params->type;\n\n\tvldb = afs_vl_lookup_vldb(params->cell, params->key,\n\t\t\t\t  params->volname, params->volnamesz);\n\tif (IS_ERR(vldb))\n\t\treturn ERR_CAST(vldb);\n\n\tif (test_bit(AFS_VLDB_QUERY_ERROR, &vldb->flags)) {\n\t\tvolume = ERR_PTR(vldb->error);\n\t\tgoto error;\n\t}\n\n\t \n\tvolume = ERR_PTR(-ENOMEDIUM);\n\tif (params->force) {\n\t\tif (!(vldb->flags & type_mask))\n\t\t\tgoto error;\n\t} else if (test_bit(AFS_VLDB_HAS_RO, &vldb->flags)) {\n\t\tparams->type = AFSVL_ROVOL;\n\t} else if (test_bit(AFS_VLDB_HAS_RW, &vldb->flags)) {\n\t\tparams->type = AFSVL_RWVOL;\n\t} else {\n\t\tgoto error;\n\t}\n\n\ttype_mask = 1UL << params->type;\n\tvolume = afs_lookup_volume(params, vldb, type_mask);\n\nerror:\n\tkfree(vldb);\n\treturn volume;\n}\n\n \nstatic void afs_destroy_volume(struct afs_net *net, struct afs_volume *volume)\n{\n\t_enter(\"%p\", volume);\n\n#ifdef CONFIG_AFS_FSCACHE\n\tASSERTCMP(volume->cache, ==, NULL);\n#endif\n\n\tafs_remove_volume_from_cell(volume);\n\tafs_put_serverlist(net, rcu_access_pointer(volume->servers));\n\tafs_put_cell(volume->cell, afs_cell_trace_put_vol);\n\ttrace_afs_volume(volume->vid, refcount_read(&volume->ref),\n\t\t\t afs_volume_trace_free);\n\tkfree_rcu(volume, rcu);\n\n\t_leave(\" [destroyed]\");\n}\n\n \nbool afs_try_get_volume(struct afs_volume *volume, enum afs_volume_trace reason)\n{\n\tint r;\n\n\tif (__refcount_inc_not_zero(&volume->ref, &r)) {\n\t\ttrace_afs_volume(volume->vid, r + 1, reason);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstruct afs_volume *afs_get_volume(struct afs_volume *volume,\n\t\t\t\t  enum afs_volume_trace reason)\n{\n\tif (volume) {\n\t\tint r;\n\n\t\t__refcount_inc(&volume->ref, &r);\n\t\ttrace_afs_volume(volume->vid, r + 1, reason);\n\t}\n\treturn volume;\n}\n\n\n \nvoid afs_put_volume(struct afs_net *net, struct afs_volume *volume,\n\t\t    enum afs_volume_trace reason)\n{\n\tif (volume) {\n\t\tafs_volid_t vid = volume->vid;\n\t\tbool zero;\n\t\tint r;\n\n\t\tzero = __refcount_dec_and_test(&volume->ref, &r);\n\t\ttrace_afs_volume(vid, r - 1, reason);\n\t\tif (zero)\n\t\t\tafs_destroy_volume(net, volume);\n\t}\n}\n\n \nint afs_activate_volume(struct afs_volume *volume)\n{\n#ifdef CONFIG_AFS_FSCACHE\n\tstruct fscache_volume *vcookie;\n\tchar *name;\n\n\tname = kasprintf(GFP_KERNEL, \"afs,%s,%llx\",\n\t\t\t volume->cell->name, volume->vid);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tvcookie = fscache_acquire_volume(name, NULL, NULL, 0);\n\tif (IS_ERR(vcookie)) {\n\t\tif (vcookie != ERR_PTR(-EBUSY)) {\n\t\t\tkfree(name);\n\t\t\treturn PTR_ERR(vcookie);\n\t\t}\n\t\tpr_err(\"AFS: Cache volume key already in use (%s)\\n\", name);\n\t\tvcookie = NULL;\n\t}\n\tvolume->cache = vcookie;\n\tkfree(name);\n#endif\n\treturn 0;\n}\n\n \nvoid afs_deactivate_volume(struct afs_volume *volume)\n{\n\t_enter(\"%s\", volume->name);\n\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_volume(volume->cache, NULL,\n\t\t\t\t  test_bit(AFS_VOLUME_DELETED, &volume->flags));\n\tvolume->cache = NULL;\n#endif\n\n\t_leave(\"\");\n}\n\n \nstatic int afs_update_volume_status(struct afs_volume *volume, struct key *key)\n{\n\tstruct afs_server_list *new, *old, *discard;\n\tstruct afs_vldb_entry *vldb;\n\tchar idbuf[16];\n\tint ret, idsz;\n\n\t_enter(\"\");\n\n\t \n\tidsz = sprintf(idbuf, \"%llu\", volume->vid);\n\n\tvldb = afs_vl_lookup_vldb(volume->cell, key, idbuf, idsz);\n\tif (IS_ERR(vldb)) {\n\t\tret = PTR_ERR(vldb);\n\t\tgoto error;\n\t}\n\n\t \n\tif (vldb->name_len != volume->name_len ||\n\t    memcmp(vldb->name, volume->name, vldb->name_len) != 0) {\n\t\t \n\t\tmemcpy(volume->name, vldb->name, AFS_MAXVOLNAME);\n\t\tvolume->name_len = vldb->name_len;\n\t}\n\n\t \n\tnew = afs_alloc_server_list(volume->cell, key,\n\t\t\t\t    vldb, (1 << volume->type));\n\tif (IS_ERR(new)) {\n\t\tret = PTR_ERR(new);\n\t\tgoto error_vldb;\n\t}\n\n\twrite_lock(&volume->servers_lock);\n\n\tdiscard = new;\n\told = rcu_dereference_protected(volume->servers,\n\t\t\t\t\tlockdep_is_held(&volume->servers_lock));\n\tif (afs_annotate_server_list(new, old)) {\n\t\tnew->seq = volume->servers_seq + 1;\n\t\trcu_assign_pointer(volume->servers, new);\n\t\tsmp_wmb();\n\t\tvolume->servers_seq++;\n\t\tdiscard = old;\n\t}\n\n\tvolume->update_at = ktime_get_real_seconds() + afs_volume_record_life;\n\twrite_unlock(&volume->servers_lock);\n\tret = 0;\n\n\tafs_put_serverlist(volume->cell->net, discard);\nerror_vldb:\n\tkfree(vldb);\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nint afs_check_volume_status(struct afs_volume *volume, struct afs_operation *op)\n{\n\tint ret, retries = 0;\n\n\t_enter(\"\");\n\nretry:\n\tif (test_bit(AFS_VOLUME_WAIT, &volume->flags))\n\t\tgoto wait;\n\tif (volume->update_at <= ktime_get_real_seconds() ||\n\t    test_bit(AFS_VOLUME_NEEDS_UPDATE, &volume->flags))\n\t\tgoto update;\n\t_leave(\" = 0\");\n\treturn 0;\n\nupdate:\n\tif (!test_and_set_bit_lock(AFS_VOLUME_UPDATING, &volume->flags)) {\n\t\tclear_bit(AFS_VOLUME_NEEDS_UPDATE, &volume->flags);\n\t\tret = afs_update_volume_status(volume, op->key);\n\t\tif (ret < 0)\n\t\t\tset_bit(AFS_VOLUME_NEEDS_UPDATE, &volume->flags);\n\t\tclear_bit_unlock(AFS_VOLUME_WAIT, &volume->flags);\n\t\tclear_bit_unlock(AFS_VOLUME_UPDATING, &volume->flags);\n\t\twake_up_bit(&volume->flags, AFS_VOLUME_WAIT);\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\nwait:\n\tif (!test_bit(AFS_VOLUME_WAIT, &volume->flags)) {\n\t\t_leave(\" = 0 [no wait]\");\n\t\treturn 0;\n\t}\n\n\tret = wait_on_bit(&volume->flags, AFS_VOLUME_WAIT,\n\t\t\t  (op->flags & AFS_OPERATION_UNINTR) ?\n\t\t\t  TASK_UNINTERRUPTIBLE : TASK_INTERRUPTIBLE);\n\tif (ret == -ERESTARTSYS) {\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tretries++;\n\tif (retries == 4) {\n\t\t_leave(\" = -ESTALE\");\n\t\treturn -ESTALE;\n\t}\n\tgoto retry;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}