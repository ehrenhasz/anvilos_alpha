{
  "module_name": "dir_edit.c",
  "hash_id": "a28934e440b4cbc417d6777d49e448ade2885e9b3bcb847cda00c51febe9fcec",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/dir_edit.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/iversion.h>\n#include \"internal.h\"\n#include \"xdr_fs.h\"\n\n \nstatic int afs_find_contig_bits(union afs_xdr_dir_block *block, unsigned int nr_slots)\n{\n\tu64 bitmap;\n\tu32 mask;\n\tint bit, n;\n\n\tbitmap  = (u64)block->hdr.bitmap[0] << 0 * 8;\n\tbitmap |= (u64)block->hdr.bitmap[1] << 1 * 8;\n\tbitmap |= (u64)block->hdr.bitmap[2] << 2 * 8;\n\tbitmap |= (u64)block->hdr.bitmap[3] << 3 * 8;\n\tbitmap |= (u64)block->hdr.bitmap[4] << 4 * 8;\n\tbitmap |= (u64)block->hdr.bitmap[5] << 5 * 8;\n\tbitmap |= (u64)block->hdr.bitmap[6] << 6 * 8;\n\tbitmap |= (u64)block->hdr.bitmap[7] << 7 * 8;\n\tbitmap >>= 1;  \n\tbit = 1;\n\tmask = (1 << nr_slots) - 1;\n\n\tdo {\n\t\tif (sizeof(unsigned long) == 8)\n\t\t\tn = ffz(bitmap);\n\t\telse\n\t\t\tn = ((u32)bitmap) != 0 ?\n\t\t\t\tffz((u32)bitmap) :\n\t\t\t\tffz((u32)(bitmap >> 32)) + 32;\n\t\tbitmap >>= n;\n\t\tbit += n;\n\n\t\tif ((bitmap & mask) == 0) {\n\t\t\tif (bit > 64 - nr_slots)\n\t\t\t\treturn -1;\n\t\t\treturn bit;\n\t\t}\n\n\t\tn = __ffs(bitmap);\n\t\tbitmap >>= n;\n\t\tbit += n;\n\t} while (bitmap);\n\n\treturn -1;\n}\n\n \nstatic void afs_set_contig_bits(union afs_xdr_dir_block *block,\n\t\t\t\tint bit, unsigned int nr_slots)\n{\n\tu64 mask;\n\n\tmask = (1 << nr_slots) - 1;\n\tmask <<= bit;\n\n\tblock->hdr.bitmap[0] |= (u8)(mask >> 0 * 8);\n\tblock->hdr.bitmap[1] |= (u8)(mask >> 1 * 8);\n\tblock->hdr.bitmap[2] |= (u8)(mask >> 2 * 8);\n\tblock->hdr.bitmap[3] |= (u8)(mask >> 3 * 8);\n\tblock->hdr.bitmap[4] |= (u8)(mask >> 4 * 8);\n\tblock->hdr.bitmap[5] |= (u8)(mask >> 5 * 8);\n\tblock->hdr.bitmap[6] |= (u8)(mask >> 6 * 8);\n\tblock->hdr.bitmap[7] |= (u8)(mask >> 7 * 8);\n}\n\n \nstatic void afs_clear_contig_bits(union afs_xdr_dir_block *block,\n\t\t\t\t  int bit, unsigned int nr_slots)\n{\n\tu64 mask;\n\n\tmask = (1 << nr_slots) - 1;\n\tmask <<= bit;\n\n\tblock->hdr.bitmap[0] &= ~(u8)(mask >> 0 * 8);\n\tblock->hdr.bitmap[1] &= ~(u8)(mask >> 1 * 8);\n\tblock->hdr.bitmap[2] &= ~(u8)(mask >> 2 * 8);\n\tblock->hdr.bitmap[3] &= ~(u8)(mask >> 3 * 8);\n\tblock->hdr.bitmap[4] &= ~(u8)(mask >> 4 * 8);\n\tblock->hdr.bitmap[5] &= ~(u8)(mask >> 5 * 8);\n\tblock->hdr.bitmap[6] &= ~(u8)(mask >> 6 * 8);\n\tblock->hdr.bitmap[7] &= ~(u8)(mask >> 7 * 8);\n}\n\n \nstatic struct folio *afs_dir_get_folio(struct afs_vnode *vnode, pgoff_t index)\n{\n\tstruct address_space *mapping = vnode->netfs.inode.i_mapping;\n\tstruct folio *folio;\n\n\tfolio = __filemap_get_folio(mapping, index,\n\t\t\t\t    FGP_LOCK | FGP_ACCESSED | FGP_CREAT,\n\t\t\t\t    mapping->gfp_mask);\n\tif (IS_ERR(folio)) {\n\t\tclear_bit(AFS_VNODE_DIR_VALID, &vnode->flags);\n\t\treturn NULL;\n\t}\n\tif (!folio_test_private(folio))\n\t\tfolio_attach_private(folio, (void *)1);\n\treturn folio;\n}\n\n \nstatic int afs_dir_scan_block(union afs_xdr_dir_block *block, struct qstr *name,\n\t\t\t      unsigned int blocknum)\n{\n\tunion afs_xdr_dirent *de;\n\tu64 bitmap;\n\tint d, len, n;\n\n\t_enter(\"\");\n\n\tbitmap  = (u64)block->hdr.bitmap[0] << 0 * 8;\n\tbitmap |= (u64)block->hdr.bitmap[1] << 1 * 8;\n\tbitmap |= (u64)block->hdr.bitmap[2] << 2 * 8;\n\tbitmap |= (u64)block->hdr.bitmap[3] << 3 * 8;\n\tbitmap |= (u64)block->hdr.bitmap[4] << 4 * 8;\n\tbitmap |= (u64)block->hdr.bitmap[5] << 5 * 8;\n\tbitmap |= (u64)block->hdr.bitmap[6] << 6 * 8;\n\tbitmap |= (u64)block->hdr.bitmap[7] << 7 * 8;\n\n\tfor (d = (blocknum == 0 ? AFS_DIR_RESV_BLOCKS0 : AFS_DIR_RESV_BLOCKS);\n\t     d < AFS_DIR_SLOTS_PER_BLOCK;\n\t     d++) {\n\t\tif (!((bitmap >> d) & 1))\n\t\t\tcontinue;\n\t\tde = &block->dirents[d];\n\t\tif (de->u.valid != 1)\n\t\t\tcontinue;\n\n\t\t \n\t\tlen = strlen(de->u.name);\n\t\tif (len == name->len &&\n\t\t    memcmp(de->u.name, name->name, name->len) == 0)\n\t\t\treturn d;\n\n\t\tn = round_up(12 + len + 1 + 4, AFS_DIR_DIRENT_SIZE);\n\t\tn /= AFS_DIR_DIRENT_SIZE;\n\t\td += n - 1;\n\t}\n\n\treturn -1;\n}\n\n \nstatic void afs_edit_init_block(union afs_xdr_dir_block *meta,\n\t\t\t\tunion afs_xdr_dir_block *block, int block_num)\n{\n\tmemset(block, 0, sizeof(*block));\n\tblock->hdr.npages = htons(1);\n\tblock->hdr.magic = AFS_DIR_MAGIC;\n\tblock->hdr.bitmap[0] = 1;\n\n\tif (block_num == 0) {\n\t\tblock->hdr.bitmap[0] = 0xff;\n\t\tblock->hdr.bitmap[1] = 0x1f;\n\t\tmemset(block->meta.alloc_ctrs,\n\t\t       AFS_DIR_SLOTS_PER_BLOCK,\n\t\t       sizeof(block->meta.alloc_ctrs));\n\t\tmeta->meta.alloc_ctrs[0] =\n\t\t\tAFS_DIR_SLOTS_PER_BLOCK - AFS_DIR_RESV_BLOCKS0;\n\t}\n\n\tif (block_num < AFS_DIR_BLOCKS_WITH_CTR)\n\t\tmeta->meta.alloc_ctrs[block_num] =\n\t\t\tAFS_DIR_SLOTS_PER_BLOCK - AFS_DIR_RESV_BLOCKS;\n}\n\n \nvoid afs_edit_dir_add(struct afs_vnode *vnode,\n\t\t      struct qstr *name, struct afs_fid *new_fid,\n\t\t      enum afs_edit_dir_reason why)\n{\n\tunion afs_xdr_dir_block *meta, *block;\n\tunion afs_xdr_dirent *de;\n\tstruct folio *folio0, *folio;\n\tunsigned int need_slots, nr_blocks, b;\n\tpgoff_t index;\n\tloff_t i_size;\n\tint slot;\n\n\t_enter(\",,{%d,%s},\", name->len, name->name);\n\n\ti_size = i_size_read(&vnode->netfs.inode);\n\tif (i_size > AFS_DIR_BLOCK_SIZE * AFS_DIR_MAX_BLOCKS ||\n\t    (i_size & (AFS_DIR_BLOCK_SIZE - 1))) {\n\t\tclear_bit(AFS_VNODE_DIR_VALID, &vnode->flags);\n\t\treturn;\n\t}\n\n\tfolio0 = afs_dir_get_folio(vnode, 0);\n\tif (!folio0) {\n\t\t_leave(\" [fgp]\");\n\t\treturn;\n\t}\n\n\t \n\tneed_slots = afs_dir_calc_slots(name->len);\n\n\tmeta = kmap_local_folio(folio0, 0);\n\tif (i_size == 0)\n\t\tgoto new_directory;\n\tnr_blocks = i_size / AFS_DIR_BLOCK_SIZE;\n\n\t \n\tfor (b = 0; b < nr_blocks + 1; b++) {\n\t\t \n\t\tindex = b / AFS_DIR_BLOCKS_PER_PAGE;\n\t\tif (nr_blocks >= AFS_DIR_MAX_BLOCKS)\n\t\t\tgoto error;\n\t\tif (index >= folio_nr_pages(folio0)) {\n\t\t\tfolio = afs_dir_get_folio(vnode, index);\n\t\t\tif (!folio)\n\t\t\t\tgoto error;\n\t\t} else {\n\t\t\tfolio = folio0;\n\t\t}\n\n\t\tblock = kmap_local_folio(folio, b * AFS_DIR_BLOCK_SIZE - folio_file_pos(folio));\n\n\t\t \n\t\tif (!test_bit(AFS_VNODE_DIR_VALID, &vnode->flags))\n\t\t\tgoto invalidated;\n\n\t\t_debug(\"block %u: %2u %3u %u\",\n\t\t       b,\n\t\t       (b < AFS_DIR_BLOCKS_WITH_CTR) ? meta->meta.alloc_ctrs[b] : 99,\n\t\t       ntohs(block->hdr.npages),\n\t\t       ntohs(block->hdr.magic));\n\n\t\t \n\t\tif (b == nr_blocks) {\n\t\t\t_debug(\"init %u\", b);\n\t\t\tafs_edit_init_block(meta, block, b);\n\t\t\tafs_set_i_size(vnode, (b + 1) * AFS_DIR_BLOCK_SIZE);\n\t\t}\n\n\t\t \n\t\tif (b >= AFS_DIR_BLOCKS_WITH_CTR ||\n\t\t    meta->meta.alloc_ctrs[b] >= need_slots) {\n\t\t\t \n\t\t\tslot = afs_find_contig_bits(block, need_slots);\n\t\t\tif (slot >= 0) {\n\t\t\t\t_debug(\"slot %u\", slot);\n\t\t\t\tgoto found_space;\n\t\t\t}\n\t\t}\n\n\t\tkunmap_local(block);\n\t\tif (folio != folio0) {\n\t\t\tfolio_unlock(folio);\n\t\t\tfolio_put(folio);\n\t\t}\n\t}\n\n\t \n\ttrace_afs_edit_dir(vnode, why, afs_edit_dir_create_nospc, 0, 0, 0, 0, name->name);\n\tclear_bit(AFS_VNODE_DIR_VALID, &vnode->flags);\n\tgoto out_unmap;\n\nnew_directory:\n\tafs_edit_init_block(meta, meta, 0);\n\ti_size = AFS_DIR_BLOCK_SIZE;\n\tafs_set_i_size(vnode, i_size);\n\tslot = AFS_DIR_RESV_BLOCKS0;\n\tfolio = folio0;\n\tblock = kmap_local_folio(folio, 0);\n\tnr_blocks = 1;\n\tb = 0;\n\nfound_space:\n\t \n\ttrace_afs_edit_dir(vnode, why, afs_edit_dir_create, b, slot,\n\t\t\t   new_fid->vnode, new_fid->unique, name->name);\n\tde = &block->dirents[slot];\n\tde->u.valid\t= 1;\n\tde->u.unused[0]\t= 0;\n\tde->u.hash_next\t= 0;  \n\tde->u.vnode\t= htonl(new_fid->vnode);\n\tde->u.unique\t= htonl(new_fid->unique);\n\tmemcpy(de->u.name, name->name, name->len + 1);\n\tde->u.name[name->len] = 0;\n\n\t \n\tafs_set_contig_bits(block, slot, need_slots);\n\tkunmap_local(block);\n\tif (folio != folio0) {\n\t\tfolio_unlock(folio);\n\t\tfolio_put(folio);\n\t}\n\n\t \n\tif (b < AFS_DIR_BLOCKS_WITH_CTR)\n\t\tmeta->meta.alloc_ctrs[b] -= need_slots;\n\n\tinode_inc_iversion_raw(&vnode->netfs.inode);\n\tafs_stat_v(vnode, n_dir_cr);\n\t_debug(\"Insert %s in %u[%u]\", name->name, b, slot);\n\nout_unmap:\n\tkunmap_local(meta);\n\tfolio_unlock(folio0);\n\tfolio_put(folio0);\n\t_leave(\"\");\n\treturn;\n\ninvalidated:\n\ttrace_afs_edit_dir(vnode, why, afs_edit_dir_create_inval, 0, 0, 0, 0, name->name);\n\tclear_bit(AFS_VNODE_DIR_VALID, &vnode->flags);\n\tkunmap_local(block);\n\tif (folio != folio0) {\n\t\tfolio_unlock(folio);\n\t\tfolio_put(folio);\n\t}\n\tgoto out_unmap;\n\nerror:\n\ttrace_afs_edit_dir(vnode, why, afs_edit_dir_create_error, 0, 0, 0, 0, name->name);\n\tclear_bit(AFS_VNODE_DIR_VALID, &vnode->flags);\n\tgoto out_unmap;\n}\n\n \nvoid afs_edit_dir_remove(struct afs_vnode *vnode,\n\t\t\t struct qstr *name, enum afs_edit_dir_reason why)\n{\n\tunion afs_xdr_dir_block *meta, *block;\n\tunion afs_xdr_dirent *de;\n\tstruct folio *folio0, *folio;\n\tunsigned int need_slots, nr_blocks, b;\n\tpgoff_t index;\n\tloff_t i_size;\n\tint slot;\n\n\t_enter(\",,{%d,%s},\", name->len, name->name);\n\n\ti_size = i_size_read(&vnode->netfs.inode);\n\tif (i_size < AFS_DIR_BLOCK_SIZE ||\n\t    i_size > AFS_DIR_BLOCK_SIZE * AFS_DIR_MAX_BLOCKS ||\n\t    (i_size & (AFS_DIR_BLOCK_SIZE - 1))) {\n\t\tclear_bit(AFS_VNODE_DIR_VALID, &vnode->flags);\n\t\treturn;\n\t}\n\tnr_blocks = i_size / AFS_DIR_BLOCK_SIZE;\n\n\tfolio0 = afs_dir_get_folio(vnode, 0);\n\tif (!folio0) {\n\t\t_leave(\" [fgp]\");\n\t\treturn;\n\t}\n\n\t \n\tneed_slots = afs_dir_calc_slots(name->len);\n\n\tmeta = kmap_local_folio(folio0, 0);\n\n\t \n\tfor (b = 0; b < nr_blocks; b++) {\n\t\tindex = b / AFS_DIR_BLOCKS_PER_PAGE;\n\t\tif (index >= folio_nr_pages(folio0)) {\n\t\t\tfolio = afs_dir_get_folio(vnode, index);\n\t\t\tif (!folio)\n\t\t\t\tgoto error;\n\t\t} else {\n\t\t\tfolio = folio0;\n\t\t}\n\n\t\tblock = kmap_local_folio(folio, b * AFS_DIR_BLOCK_SIZE - folio_file_pos(folio));\n\n\t\t \n\t\tif (!test_bit(AFS_VNODE_DIR_VALID, &vnode->flags))\n\t\t\tgoto invalidated;\n\n\t\tif (b > AFS_DIR_BLOCKS_WITH_CTR ||\n\t\t    meta->meta.alloc_ctrs[b] <= AFS_DIR_SLOTS_PER_BLOCK - 1 - need_slots) {\n\t\t\tslot = afs_dir_scan_block(block, name, b);\n\t\t\tif (slot >= 0)\n\t\t\t\tgoto found_dirent;\n\t\t}\n\n\t\tkunmap_local(block);\n\t\tif (folio != folio0) {\n\t\t\tfolio_unlock(folio);\n\t\t\tfolio_put(folio);\n\t\t}\n\t}\n\n\t \n\ttrace_afs_edit_dir(vnode, why, afs_edit_dir_delete_noent,\n\t\t\t   0, 0, 0, 0, name->name);\n\tclear_bit(AFS_VNODE_DIR_VALID, &vnode->flags);\n\tgoto out_unmap;\n\nfound_dirent:\n\tde = &block->dirents[slot];\n\n\ttrace_afs_edit_dir(vnode, why, afs_edit_dir_delete, b, slot,\n\t\t\t   ntohl(de->u.vnode), ntohl(de->u.unique),\n\t\t\t   name->name);\n\n\tmemset(de, 0, sizeof(*de) * need_slots);\n\n\t \n\tafs_clear_contig_bits(block, slot, need_slots);\n\tkunmap_local(block);\n\tif (folio != folio0) {\n\t\tfolio_unlock(folio);\n\t\tfolio_put(folio);\n\t}\n\n\t \n\tif (b < AFS_DIR_BLOCKS_WITH_CTR)\n\t\tmeta->meta.alloc_ctrs[b] += need_slots;\n\n\tinode_set_iversion_raw(&vnode->netfs.inode, vnode->status.data_version);\n\tafs_stat_v(vnode, n_dir_rm);\n\t_debug(\"Remove %s from %u[%u]\", name->name, b, slot);\n\nout_unmap:\n\tkunmap_local(meta);\n\tfolio_unlock(folio0);\n\tfolio_put(folio0);\n\t_leave(\"\");\n\treturn;\n\ninvalidated:\n\ttrace_afs_edit_dir(vnode, why, afs_edit_dir_delete_inval,\n\t\t\t   0, 0, 0, 0, name->name);\n\tclear_bit(AFS_VNODE_DIR_VALID, &vnode->flags);\n\tkunmap_local(block);\n\tif (folio != folio0) {\n\t\tfolio_unlock(folio);\n\t\tfolio_put(folio);\n\t}\n\tgoto out_unmap;\n\nerror:\n\ttrace_afs_edit_dir(vnode, why, afs_edit_dir_delete_error,\n\t\t\t   0, 0, 0, 0, name->name);\n\tclear_bit(AFS_VNODE_DIR_VALID, &vnode->flags);\n\tgoto out_unmap;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}