{
  "module_name": "yfsclient.c",
  "hash_id": "d532e8d5ab9f144c0a7a710d63cfb1b72adb74559eb6658d07c8ff38fd334ba4",
  "original_prompt": "Ingested from linux-6.6.14/fs/afs/yfsclient.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/circ_buf.h>\n#include <linux/iversion.h>\n#include \"internal.h\"\n#include \"afs_fs.h\"\n#include \"xdr_fs.h\"\n#include \"protocol_yfs.h\"\n\n#define xdr_size(x) (sizeof(*x) / sizeof(__be32))\n\nstatic void xdr_decode_YFSFid(const __be32 **_bp, struct afs_fid *fid)\n{\n\tconst struct yfs_xdr_YFSFid *x = (const void *)*_bp;\n\n\tfid->vid\t= xdr_to_u64(x->volume);\n\tfid->vnode\t= xdr_to_u64(x->vnode.lo);\n\tfid->vnode_hi\t= ntohl(x->vnode.hi);\n\tfid->unique\t= ntohl(x->vnode.unique);\n\t*_bp += xdr_size(x);\n}\n\nstatic __be32 *xdr_encode_u32(__be32 *bp, u32 n)\n{\n\t*bp++ = htonl(n);\n\treturn bp;\n}\n\nstatic __be32 *xdr_encode_u64(__be32 *bp, u64 n)\n{\n\tstruct yfs_xdr_u64 *x = (void *)bp;\n\n\t*x = u64_to_xdr(n);\n\treturn bp + xdr_size(x);\n}\n\nstatic __be32 *xdr_encode_YFSFid(__be32 *bp, struct afs_fid *fid)\n{\n\tstruct yfs_xdr_YFSFid *x = (void *)bp;\n\n\tx->volume\t= u64_to_xdr(fid->vid);\n\tx->vnode.lo\t= u64_to_xdr(fid->vnode);\n\tx->vnode.hi\t= htonl(fid->vnode_hi);\n\tx->vnode.unique\t= htonl(fid->unique);\n\treturn bp + xdr_size(x);\n}\n\nstatic size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}\n\nstatic __be32 *xdr_encode_string(__be32 *bp, const char *p, unsigned int len)\n{\n\tbp = xdr_encode_u32(bp, len);\n\tbp = memcpy(bp, p, len);\n\tif (len & 3) {\n\t\tunsigned int pad = 4 - (len & 3);\n\n\t\tmemset((u8 *)bp + len, 0, pad);\n\t\tlen += pad;\n\t}\n\n\treturn bp + len / sizeof(__be32);\n}\n\nstatic __be32 *xdr_encode_name(__be32 *bp, const struct qstr *p)\n{\n\treturn xdr_encode_string(bp, p->name, p->len);\n}\n\nstatic s64 linux_to_yfs_time(const struct timespec64 *t)\n{\n\t \n\treturn (u64)t->tv_sec * 10000000 + t->tv_nsec/100;\n}\n\nstatic __be32 *xdr_encode_YFSStoreStatus(__be32 *bp, mode_t *mode,\n\t\t\t\t\t const struct timespec64 *t)\n{\n\tstruct yfs_xdr_YFSStoreStatus *x = (void *)bp;\n\tmode_t masked_mode = mode ? *mode & S_IALLUGO : 0;\n\ts64 mtime = linux_to_yfs_time(t);\n\tu32 mask = AFS_SET_MTIME;\n\n\tmask |= mode ? AFS_SET_MODE : 0;\n\n\tx->mask\t\t= htonl(mask);\n\tx->mode\t\t= htonl(masked_mode);\n\tx->mtime_client\t= u64_to_xdr(mtime);\n\tx->owner\t= u64_to_xdr(0);\n\tx->group\t= u64_to_xdr(0);\n\treturn bp + xdr_size(x);\n}\n\n \nstatic struct timespec64 yfs_time_to_linux(s64 t)\n{\n\tstruct timespec64 ts;\n\tu64 abs_t;\n\n\t \n\tif (t < 0) {\n\t\tabs_t = -t;\n\t\tts.tv_nsec = (time64_t)(do_div(abs_t, 10000000) * 100);\n\t\tts.tv_nsec = -ts.tv_nsec;\n\t\tts.tv_sec = -abs_t;\n\t} else {\n\t\tabs_t = t;\n\t\tts.tv_nsec = (time64_t)do_div(abs_t, 10000000) * 100;\n\t\tts.tv_sec = abs_t;\n\t}\n\n\treturn ts;\n}\n\nstatic struct timespec64 xdr_to_time(const struct yfs_xdr_u64 xdr)\n{\n\ts64 t = xdr_to_u64(xdr);\n\n\treturn yfs_time_to_linux(t);\n}\n\nstatic void yfs_check_req(struct afs_call *call, __be32 *bp)\n{\n\tsize_t len = (void *)bp - call->request;\n\n\tif (len > call->request_size)\n\t\tpr_err(\"kAFS: %s: Request buffer overflow (%zu>%u)\\n\",\n\t\t       call->type->name, len, call->request_size);\n\telse if (len < call->request_size)\n\t\tpr_warn(\"kAFS: %s: Request buffer underflow (%zu<%u)\\n\",\n\t\t\tcall->type->name, len, call->request_size);\n}\n\n \nstatic void xdr_dump_bad(const __be32 *bp)\n{\n\t__be32 x[4];\n\tint i;\n\n\tpr_notice(\"YFS XDR: Bad status record\\n\");\n\tfor (i = 0; i < 6 * 4 * 4; i += 16) {\n\t\tmemcpy(x, bp, 16);\n\t\tbp += 4;\n\t\tpr_notice(\"%03x: %08x %08x %08x %08x\\n\",\n\t\t\t  i, ntohl(x[0]), ntohl(x[1]), ntohl(x[2]), ntohl(x[3]));\n\t}\n\n\tmemcpy(x, bp, 8);\n\tpr_notice(\"0x60: %08x %08x\\n\", ntohl(x[0]), ntohl(x[1]));\n}\n\n \nstatic void xdr_decode_YFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_call *call,\n\t\t\t\t      struct afs_status_cb *scb)\n{\n\tconst struct yfs_xdr_YFSFetchStatus *xdr = (const void *)*_bp;\n\tstruct afs_file_status *status = &scb->status;\n\tu32 type;\n\n\tstatus->abort_code = ntohl(xdr->abort_code);\n\tif (status->abort_code != 0) {\n\t\tif (status->abort_code == VNOVNODE)\n\t\t\tstatus->nlink = 0;\n\t\tscb->have_error = true;\n\t\tgoto advance;\n\t}\n\n\ttype = ntohl(xdr->type);\n\tswitch (type) {\n\tcase AFS_FTYPE_FILE:\n\tcase AFS_FTYPE_DIR:\n\tcase AFS_FTYPE_SYMLINK:\n\t\tstatus->type = type;\n\t\tbreak;\n\tdefault:\n\t\tgoto bad;\n\t}\n\n\tstatus->nlink\t\t= ntohl(xdr->nlink);\n\tstatus->author\t\t= xdr_to_u64(xdr->author);\n\tstatus->owner\t\t= xdr_to_u64(xdr->owner);\n\tstatus->caller_access\t= ntohl(xdr->caller_access);  \n\tstatus->anon_access\t= ntohl(xdr->anon_access);\n\tstatus->mode\t\t= ntohl(xdr->mode) & S_IALLUGO;\n\tstatus->group\t\t= xdr_to_u64(xdr->group);\n\tstatus->lock_count\t= ntohl(xdr->lock_count);\n\n\tstatus->mtime_client\t= xdr_to_time(xdr->mtime_client);\n\tstatus->mtime_server\t= xdr_to_time(xdr->mtime_server);\n\tstatus->size\t\t= xdr_to_u64(xdr->size);\n\tstatus->data_version\t= xdr_to_u64(xdr->data_version);\n\tscb->have_status\t= true;\nadvance:\n\t*_bp += xdr_size(xdr);\n\treturn;\n\nbad:\n\txdr_dump_bad(*_bp);\n\tafs_protocol_error(call, afs_eproto_bad_status);\n\tgoto advance;\n}\n\n \nstatic void xdr_decode_YFSCallBack(const __be32 **_bp,\n\t\t\t\t   struct afs_call *call,\n\t\t\t\t   struct afs_status_cb *scb)\n{\n\tstruct yfs_xdr_YFSCallBack *x = (void *)*_bp;\n\tstruct afs_callback *cb = &scb->callback;\n\tktime_t cb_expiry;\n\n\tcb_expiry = ktime_add(call->issue_time, xdr_to_u64(x->expiration_time) * 100);\n\tcb->expires_at\t= ktime_divns(cb_expiry, NSEC_PER_SEC);\n\tscb->have_cb\t= true;\n\t*_bp += xdr_size(x);\n}\n\n \nstatic void xdr_decode_YFSVolSync(const __be32 **_bp,\n\t\t\t\t  struct afs_volsync *volsync)\n{\n\tstruct yfs_xdr_YFSVolSync *x = (void *)*_bp;\n\tu64 creation;\n\n\tif (volsync) {\n\t\tcreation = xdr_to_u64(x->vol_creation_date);\n\t\tdo_div(creation, 10 * 1000 * 1000);\n\t\tvolsync->creation = creation;\n\t}\n\n\t*_bp += xdr_size(x);\n}\n\n \nstatic __be32 *xdr_encode_YFS_StoreStatus(__be32 *bp, struct iattr *attr)\n{\n\tstruct yfs_xdr_YFSStoreStatus *x = (void *)bp;\n\ts64 mtime = 0, owner = 0, group = 0;\n\tu32 mask = 0, mode = 0;\n\n\tmask = 0;\n\tif (attr->ia_valid & ATTR_MTIME) {\n\t\tmask |= AFS_SET_MTIME;\n\t\tmtime = linux_to_yfs_time(&attr->ia_mtime);\n\t}\n\n\tif (attr->ia_valid & ATTR_UID) {\n\t\tmask |= AFS_SET_OWNER;\n\t\towner = from_kuid(&init_user_ns, attr->ia_uid);\n\t}\n\n\tif (attr->ia_valid & ATTR_GID) {\n\t\tmask |= AFS_SET_GROUP;\n\t\tgroup = from_kgid(&init_user_ns, attr->ia_gid);\n\t}\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tmask |= AFS_SET_MODE;\n\t\tmode = attr->ia_mode & S_IALLUGO;\n\t}\n\n\tx->mask\t\t= htonl(mask);\n\tx->mode\t\t= htonl(mode);\n\tx->mtime_client\t= u64_to_xdr(mtime);\n\tx->owner\t= u64_to_xdr(owner);\n\tx->group\t= u64_to_xdr(group);\n\treturn bp + xdr_size(x);\n}\n\n \nstatic void xdr_decode_YFSFetchVolumeStatus(const __be32 **_bp,\n\t\t\t\t\t    struct afs_volume_status *vs)\n{\n\tconst struct yfs_xdr_YFSFetchVolumeStatus *x = (const void *)*_bp;\n\tu32 flags;\n\n\tvs->vid\t\t\t= xdr_to_u64(x->vid);\n\tvs->parent_id\t\t= xdr_to_u64(x->parent_id);\n\tflags\t\t\t= ntohl(x->flags);\n\tvs->online\t\t= flags & yfs_FVSOnline;\n\tvs->in_service\t\t= flags & yfs_FVSInservice;\n\tvs->blessed\t\t= flags & yfs_FVSBlessed;\n\tvs->needs_salvage\t= flags & yfs_FVSNeedsSalvage;\n\tvs->type\t\t= ntohl(x->type);\n\tvs->min_quota\t\t= 0;\n\tvs->max_quota\t\t= xdr_to_u64(x->max_quota);\n\tvs->blocks_in_use\t= xdr_to_u64(x->blocks_in_use);\n\tvs->part_blocks_avail\t= xdr_to_u64(x->part_blocks_avail);\n\tvs->part_max_blocks\t= xdr_to_u64(x->part_max_blocks);\n\tvs->vol_copy_date\t= xdr_to_u64(x->vol_copy_date);\n\tvs->vol_backup_date\t= xdr_to_u64(x->vol_backup_date);\n\t*_bp += sizeof(*x) / sizeof(__be32);\n}\n\n \nstatic int yfs_deliver_status_and_volsync(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tconst __be32 *bp;\n\tint ret;\n\n\tret = afs_transfer_reply(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbp = call->buffer;\n\txdr_decode_YFSFetchStatus(&bp, call, &op->file[0].scb);\n\txdr_decode_YFSVolSync(&bp, &op->volsync);\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic int yfs_deliver_fs_fetch_data64(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_read *req = op->fetch.req;\n\tconst __be32 *bp;\n\tint ret;\n\n\t_enter(\"{%u,%zu, %zu/%llu}\",\n\t       call->unmarshall, call->iov_len, iov_iter_count(call->iter),\n\t       req->actual_len);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\treq->actual_len = 0;\n\t\tafs_extract_to_tmp64(call);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 1:\n\t\t_debug(\"extract data length\");\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treq->actual_len = be64_to_cpu(call->tmp64);\n\t\t_debug(\"DATA length: %llu\", req->actual_len);\n\n\t\tif (req->actual_len == 0)\n\t\t\tgoto no_more_data;\n\n\t\tcall->iter = req->iter;\n\t\tcall->iov_len = min(req->actual_len, req->len);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 2:\n\t\t_debug(\"extract data %zu/%llu\",\n\t\t       iov_iter_count(call->iter), req->actual_len);\n\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcall->iter = &call->def_iter;\n\t\tif (req->actual_len <= req->len)\n\t\t\tgoto no_more_data;\n\n\t\t \n\t\tafs_extract_discard(call, req->actual_len - req->len);\n\t\tcall->unmarshall = 3;\n\t\tfallthrough;\n\n\tcase 3:\n\t\t_debug(\"extract discard %zu/%llu\",\n\t\t       iov_iter_count(call->iter), req->actual_len - req->len);\n\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\tno_more_data:\n\t\tcall->unmarshall = 4;\n\t\tafs_extract_to_buf(call,\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSCallBack) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSVolSync));\n\t\tfallthrough;\n\n\t\t \n\tcase 4:\n\t\tret = afs_extract_data(call, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbp = call->buffer;\n\t\txdr_decode_YFSFetchStatus(&bp, call, &vp->scb);\n\t\txdr_decode_YFSCallBack(&bp, call, &vp->scb);\n\t\txdr_decode_YFSVolSync(&bp, &op->volsync);\n\n\t\treq->data_version = vp->scb.status.data_version;\n\t\treq->file_size = vp->scb.status.size;\n\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\tcase 5:\n\t\tbreak;\n\t}\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type yfs_RXYFSFetchData64 = {\n\t.name\t\t= \"YFS.FetchData64\",\n\t.op\t\t= yfs_FS_FetchData64,\n\t.deliver\t= yfs_deliver_fs_fetch_data64,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid yfs_fs_fetch_data(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_read *req = op->fetch.req;\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%llx:%llu},%llx,%llx\",\n\t       key_serial(op->key), vp->fid.vid, vp->fid.vnode,\n\t       req->pos, req->len);\n\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXYFSFetchData64,\n\t\t\t\t   sizeof(__be32) * 2 +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid) +\n\t\t\t\t   sizeof(struct yfs_xdr_u64) * 2,\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSCallBack) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSVolSync));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\treq->call_debug_id = call->debug_id;\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSFETCHDATA64);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_YFSFid(bp, &vp->fid);\n\tbp = xdr_encode_u64(bp, req->pos);\n\tbp = xdr_encode_u64(bp, req->len);\n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int yfs_deliver_fs_create_vnode(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_vnode_param *vp = &op->file[1];\n\tconst __be32 *bp;\n\tint ret;\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tret = afs_transfer_reply(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbp = call->buffer;\n\txdr_decode_YFSFid(&bp, &op->file[1].fid);\n\txdr_decode_YFSFetchStatus(&bp, call, &vp->scb);\n\txdr_decode_YFSFetchStatus(&bp, call, &dvp->scb);\n\txdr_decode_YFSCallBack(&bp, call, &vp->scb);\n\txdr_decode_YFSVolSync(&bp, &op->volsync);\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type afs_RXFSCreateFile = {\n\t.name\t\t= \"YFS.CreateFile\",\n\t.op\t\t= yfs_FS_CreateFile,\n\t.deliver\t= yfs_deliver_fs_create_vnode,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid yfs_fs_create_file(struct afs_operation *op)\n{\n\tconst struct qstr *name = &op->dentry->d_name;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_call *call;\n\tsize_t reqsz, rplsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\treqsz = (sizeof(__be32) +\n\t\t sizeof(__be32) +\n\t\t sizeof(struct yfs_xdr_YFSFid) +\n\t\t xdr_strlen(name->len) +\n\t\t sizeof(struct yfs_xdr_YFSStoreStatus) +\n\t\t sizeof(__be32));\n\trplsz = (sizeof(struct yfs_xdr_YFSFid) +\n\t\t sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t sizeof(struct yfs_xdr_YFSCallBack) +\n\t\t sizeof(struct yfs_xdr_YFSVolSync));\n\n\tcall = afs_alloc_flat_call(op->net, &afs_RXFSCreateFile, reqsz, rplsz);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSCREATEFILE);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_YFSFid(bp, &dvp->fid);\n\tbp = xdr_encode_name(bp, name);\n\tbp = xdr_encode_YFSStoreStatus(bp, &op->create.mode, &op->mtime);\n\tbp = xdr_encode_u32(bp, yfs_LockNone);  \n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call1(call, &dvp->fid, name);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\nstatic const struct afs_call_type yfs_RXFSMakeDir = {\n\t.name\t\t= \"YFS.MakeDir\",\n\t.op\t\t= yfs_FS_MakeDir,\n\t.deliver\t= yfs_deliver_fs_create_vnode,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid yfs_fs_make_dir(struct afs_operation *op)\n{\n\tconst struct qstr *name = &op->dentry->d_name;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_call *call;\n\tsize_t reqsz, rplsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\treqsz = (sizeof(__be32) +\n\t\t sizeof(struct yfs_xdr_RPCFlags) +\n\t\t sizeof(struct yfs_xdr_YFSFid) +\n\t\t xdr_strlen(name->len) +\n\t\t sizeof(struct yfs_xdr_YFSStoreStatus));\n\trplsz = (sizeof(struct yfs_xdr_YFSFid) +\n\t\t sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t sizeof(struct yfs_xdr_YFSCallBack) +\n\t\t sizeof(struct yfs_xdr_YFSVolSync));\n\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXFSMakeDir, reqsz, rplsz);\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSMAKEDIR);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_YFSFid(bp, &dvp->fid);\n\tbp = xdr_encode_name(bp, name);\n\tbp = xdr_encode_YFSStoreStatus(bp, &op->create.mode, &op->mtime);\n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call1(call, &dvp->fid, name);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int yfs_deliver_fs_remove_file2(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_vnode_param *vp = &op->file[1];\n\tstruct afs_fid fid;\n\tconst __be32 *bp;\n\tint ret;\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tret = afs_transfer_reply(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbp = call->buffer;\n\txdr_decode_YFSFetchStatus(&bp, call, &dvp->scb);\n\txdr_decode_YFSFid(&bp, &fid);\n\txdr_decode_YFSFetchStatus(&bp, call, &vp->scb);\n\t \n\n\txdr_decode_YFSVolSync(&bp, &op->volsync);\n\treturn 0;\n}\n\nstatic void yfs_done_fs_remove_file2(struct afs_call *call)\n{\n\tif (call->error == -ECONNABORTED &&\n\t    call->abort_code == RX_INVALID_OPERATION) {\n\t\tset_bit(AFS_SERVER_FL_NO_RM2, &call->server->flags);\n\t\tcall->op->flags |= AFS_OPERATION_DOWNGRADE;\n\t}\n}\n\n \nstatic const struct afs_call_type yfs_RXYFSRemoveFile2 = {\n\t.name\t\t= \"YFS.RemoveFile2\",\n\t.op\t\t= yfs_FS_RemoveFile2,\n\t.deliver\t= yfs_deliver_fs_remove_file2,\n\t.done\t\t= yfs_done_fs_remove_file2,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid yfs_fs_remove_file2(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tconst struct qstr *name = &op->dentry->d_name;\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXYFSRemoveFile2,\n\t\t\t\t   sizeof(__be32) +\n\t\t\t\t   sizeof(struct yfs_xdr_RPCFlags) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid) +\n\t\t\t\t   xdr_strlen(name->len),\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSVolSync));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSREMOVEFILE2);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_YFSFid(bp, &dvp->fid);\n\tbp = xdr_encode_name(bp, name);\n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call1(call, &dvp->fid, name);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int yfs_deliver_fs_remove(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tconst __be32 *bp;\n\tint ret;\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tret = afs_transfer_reply(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbp = call->buffer;\n\txdr_decode_YFSFetchStatus(&bp, call, &dvp->scb);\n\txdr_decode_YFSVolSync(&bp, &op->volsync);\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type yfs_RXYFSRemoveFile = {\n\t.name\t\t= \"YFS.RemoveFile\",\n\t.op\t\t= yfs_FS_RemoveFile,\n\t.deliver\t= yfs_deliver_fs_remove,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid yfs_fs_remove_file(struct afs_operation *op)\n{\n\tconst struct qstr *name = &op->dentry->d_name;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tif (!test_bit(AFS_SERVER_FL_NO_RM2, &op->server->flags))\n\t\treturn yfs_fs_remove_file2(op);\n\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXYFSRemoveFile,\n\t\t\t\t   sizeof(__be32) +\n\t\t\t\t   sizeof(struct yfs_xdr_RPCFlags) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid) +\n\t\t\t\t   xdr_strlen(name->len),\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSVolSync));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSREMOVEFILE);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_YFSFid(bp, &dvp->fid);\n\tbp = xdr_encode_name(bp, name);\n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call1(call, &dvp->fid, name);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\nstatic const struct afs_call_type yfs_RXYFSRemoveDir = {\n\t.name\t\t= \"YFS.RemoveDir\",\n\t.op\t\t= yfs_FS_RemoveDir,\n\t.deliver\t= yfs_deliver_fs_remove,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid yfs_fs_remove_dir(struct afs_operation *op)\n{\n\tconst struct qstr *name = &op->dentry->d_name;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXYFSRemoveDir,\n\t\t\t\t   sizeof(__be32) +\n\t\t\t\t   sizeof(struct yfs_xdr_RPCFlags) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid) +\n\t\t\t\t   xdr_strlen(name->len),\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSVolSync));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSREMOVEDIR);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_YFSFid(bp, &dvp->fid);\n\tbp = xdr_encode_name(bp, name);\n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call1(call, &dvp->fid, name);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int yfs_deliver_fs_link(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_vnode_param *vp = &op->file[1];\n\tconst __be32 *bp;\n\tint ret;\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tret = afs_transfer_reply(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbp = call->buffer;\n\txdr_decode_YFSFetchStatus(&bp, call, &vp->scb);\n\txdr_decode_YFSFetchStatus(&bp, call, &dvp->scb);\n\txdr_decode_YFSVolSync(&bp, &op->volsync);\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type yfs_RXYFSLink = {\n\t.name\t\t= \"YFS.Link\",\n\t.op\t\t= yfs_FS_Link,\n\t.deliver\t= yfs_deliver_fs_link,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid yfs_fs_link(struct afs_operation *op)\n{\n\tconst struct qstr *name = &op->dentry->d_name;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_vnode_param *vp = &op->file[1];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXYFSLink,\n\t\t\t\t   sizeof(__be32) +\n\t\t\t\t   sizeof(struct yfs_xdr_RPCFlags) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid) +\n\t\t\t\t   xdr_strlen(name->len) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid),\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSVolSync));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSLINK);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_YFSFid(bp, &dvp->fid);\n\tbp = xdr_encode_name(bp, name);\n\tbp = xdr_encode_YFSFid(bp, &vp->fid);\n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call1(call, &vp->fid, name);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int yfs_deliver_fs_symlink(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_vnode_param *vp = &op->file[1];\n\tconst __be32 *bp;\n\tint ret;\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tret = afs_transfer_reply(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbp = call->buffer;\n\txdr_decode_YFSFid(&bp, &vp->fid);\n\txdr_decode_YFSFetchStatus(&bp, call, &vp->scb);\n\txdr_decode_YFSFetchStatus(&bp, call, &dvp->scb);\n\txdr_decode_YFSVolSync(&bp, &op->volsync);\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type yfs_RXYFSSymlink = {\n\t.name\t\t= \"YFS.Symlink\",\n\t.op\t\t= yfs_FS_Symlink,\n\t.deliver\t= yfs_deliver_fs_symlink,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid yfs_fs_symlink(struct afs_operation *op)\n{\n\tconst struct qstr *name = &op->dentry->d_name;\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_call *call;\n\tsize_t contents_sz;\n\tmode_t mode = 0777;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcontents_sz = strlen(op->create.symlink);\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXYFSSymlink,\n\t\t\t\t   sizeof(__be32) +\n\t\t\t\t   sizeof(struct yfs_xdr_RPCFlags) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid) +\n\t\t\t\t   xdr_strlen(name->len) +\n\t\t\t\t   xdr_strlen(contents_sz) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSStoreStatus),\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSVolSync));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSSYMLINK);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_YFSFid(bp, &dvp->fid);\n\tbp = xdr_encode_name(bp, name);\n\tbp = xdr_encode_string(bp, op->create.symlink, contents_sz);\n\tbp = xdr_encode_YFSStoreStatus(bp, &mode, &op->mtime);\n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call1(call, &dvp->fid, name);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int yfs_deliver_fs_rename(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode_param *orig_dvp = &op->file[0];\n\tstruct afs_vnode_param *new_dvp = &op->file[1];\n\tconst __be32 *bp;\n\tint ret;\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tret = afs_transfer_reply(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbp = call->buffer;\n\t \n\txdr_decode_YFSFetchStatus(&bp, call, &orig_dvp->scb);\n\txdr_decode_YFSFetchStatus(&bp, call, &new_dvp->scb);\n\txdr_decode_YFSVolSync(&bp, &op->volsync);\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type yfs_RXYFSRename = {\n\t.name\t\t= \"FS.Rename\",\n\t.op\t\t= yfs_FS_Rename,\n\t.deliver\t= yfs_deliver_fs_rename,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid yfs_fs_rename(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *orig_dvp = &op->file[0];\n\tstruct afs_vnode_param *new_dvp = &op->file[1];\n\tconst struct qstr *orig_name = &op->dentry->d_name;\n\tconst struct qstr *new_name = &op->dentry_2->d_name;\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXYFSRename,\n\t\t\t\t   sizeof(__be32) +\n\t\t\t\t   sizeof(struct yfs_xdr_RPCFlags) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid) +\n\t\t\t\t   xdr_strlen(orig_name->len) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid) +\n\t\t\t\t   xdr_strlen(new_name->len),\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSVolSync));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSRENAME);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_YFSFid(bp, &orig_dvp->fid);\n\tbp = xdr_encode_name(bp, orig_name);\n\tbp = xdr_encode_YFSFid(bp, &new_dvp->fid);\n\tbp = xdr_encode_name(bp, new_name);\n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call2(call, &orig_dvp->fid, orig_name, new_name);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic const struct afs_call_type yfs_RXYFSStoreData64 = {\n\t.name\t\t= \"YFS.StoreData64\",\n\t.op\t\t= yfs_FS_StoreData64,\n\t.deliver\t= yfs_deliver_status_and_volsync,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid yfs_fs_store_data(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%llx:%llu},,\",\n\t       key_serial(op->key), vp->fid.vid, vp->fid.vnode);\n\n\t_debug(\"size %llx, at %llx, i_size %llx\",\n\t       (unsigned long long)op->store.size,\n\t       (unsigned long long)op->store.pos,\n\t       (unsigned long long)op->store.i_size);\n\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXYFSStoreData64,\n\t\t\t\t   sizeof(__be32) +\n\t\t\t\t   sizeof(__be32) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSStoreStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_u64) * 3,\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSVolSync));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\tcall->write_iter = op->store.write_iter;\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSSTOREDATA64);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_YFSFid(bp, &vp->fid);\n\tbp = xdr_encode_YFSStoreStatus(bp, NULL, &op->mtime);\n\tbp = xdr_encode_u64(bp, op->store.pos);\n\tbp = xdr_encode_u64(bp, op->store.size);\n\tbp = xdr_encode_u64(bp, op->store.i_size);\n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic const struct afs_call_type yfs_RXYFSStoreStatus = {\n\t.name\t\t= \"YFS.StoreStatus\",\n\t.op\t\t= yfs_FS_StoreStatus,\n\t.deliver\t= yfs_deliver_status_and_volsync,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nstatic const struct afs_call_type yfs_RXYFSStoreData64_as_Status = {\n\t.name\t\t= \"YFS.StoreData64\",\n\t.op\t\t= yfs_FS_StoreData64,\n\t.deliver\t= yfs_deliver_status_and_volsync,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nstatic void yfs_fs_setattr_size(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\tstruct iattr *attr = op->setattr.attr;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%llx:%llu},,\",\n\t       key_serial(op->key), vp->fid.vid, vp->fid.vnode);\n\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXYFSStoreData64_as_Status,\n\t\t\t\t   sizeof(__be32) * 2 +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSStoreStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_u64) * 3,\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSVolSync));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSSTOREDATA64);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_YFSFid(bp, &vp->fid);\n\tbp = xdr_encode_YFS_StoreStatus(bp, attr);\n\tbp = xdr_encode_u64(bp, attr->ia_size);\t \n\tbp = xdr_encode_u64(bp, 0);\t\t \n\tbp = xdr_encode_u64(bp, attr->ia_size);\t \n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nvoid yfs_fs_setattr(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\tstruct iattr *attr = op->setattr.attr;\n\t__be32 *bp;\n\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\treturn yfs_fs_setattr_size(op);\n\n\t_enter(\",%x,{%llx:%llu},,\",\n\t       key_serial(op->key), vp->fid.vid, vp->fid.vnode);\n\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXYFSStoreStatus,\n\t\t\t\t   sizeof(__be32) * 2 +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSStoreStatus),\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSVolSync));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSSTORESTATUS);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_YFSFid(bp, &vp->fid);\n\tbp = xdr_encode_YFS_StoreStatus(bp, attr);\n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int yfs_deliver_fs_get_volume_status(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tconst __be32 *bp;\n\tchar *p;\n\tu32 size;\n\tint ret;\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tcall->unmarshall++;\n\t\tafs_extract_to_buf(call, sizeof(struct yfs_xdr_YFSFetchVolumeStatus));\n\t\tfallthrough;\n\n\t\t \n\tcase 1:\n\t\t_debug(\"extract status\");\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbp = call->buffer;\n\t\txdr_decode_YFSFetchVolumeStatus(&bp, &op->volstatus.vs);\n\t\tcall->unmarshall++;\n\t\tafs_extract_to_tmp(call);\n\t\tfallthrough;\n\n\t\t \n\tcase 2:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"volname length: %u\", call->count);\n\t\tif (call->count >= AFSNAMEMAX)\n\t\t\treturn afs_protocol_error(call, afs_eproto_volname_len);\n\t\tsize = (call->count + 3) & ~3;  \n\t\tafs_extract_to_buf(call, size);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 3:\n\t\t_debug(\"extract volname\");\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tp = call->buffer;\n\t\tp[call->count] = 0;\n\t\t_debug(\"volname '%s'\", p);\n\t\tafs_extract_to_tmp(call);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 4:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"offline msg length: %u\", call->count);\n\t\tif (call->count >= AFSNAMEMAX)\n\t\t\treturn afs_protocol_error(call, afs_eproto_offline_msg_len);\n\t\tsize = (call->count + 3) & ~3;  \n\t\tafs_extract_to_buf(call, size);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 5:\n\t\t_debug(\"extract offline\");\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tp = call->buffer;\n\t\tp[call->count] = 0;\n\t\t_debug(\"offline '%s'\", p);\n\n\t\tafs_extract_to_tmp(call);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 6:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"motd length: %u\", call->count);\n\t\tif (call->count >= AFSNAMEMAX)\n\t\t\treturn afs_protocol_error(call, afs_eproto_motd_len);\n\t\tsize = (call->count + 3) & ~3;  \n\t\tafs_extract_to_buf(call, size);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 7:\n\t\t_debug(\"extract motd\");\n\t\tret = afs_extract_data(call, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tp = call->buffer;\n\t\tp[call->count] = 0;\n\t\t_debug(\"motd '%s'\", p);\n\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\tcase 8:\n\t\tbreak;\n\t}\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type yfs_RXYFSGetVolumeStatus = {\n\t.name\t\t= \"YFS.GetVolumeStatus\",\n\t.op\t\t= yfs_FS_GetVolumeStatus,\n\t.deliver\t= yfs_deliver_fs_get_volume_status,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid yfs_fs_get_volume_status(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXYFSGetVolumeStatus,\n\t\t\t\t   sizeof(__be32) * 2 +\n\t\t\t\t   sizeof(struct yfs_xdr_u64),\n\t\t\t\t   max_t(size_t,\n\t\t\t\t\t sizeof(struct yfs_xdr_YFSFetchVolumeStatus) +\n\t\t\t\t\t sizeof(__be32),\n\t\t\t\t\t AFSOPAQUEMAX + 1));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSGETVOLUMESTATUS);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_u64(bp, vp->fid.vid);\n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic const struct afs_call_type yfs_RXYFSSetLock = {\n\t.name\t\t= \"YFS.SetLock\",\n\t.op\t\t= yfs_FS_SetLock,\n\t.deliver\t= yfs_deliver_status_and_volsync,\n\t.done\t\t= afs_lock_op_done,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nstatic const struct afs_call_type yfs_RXYFSExtendLock = {\n\t.name\t\t= \"YFS.ExtendLock\",\n\t.op\t\t= yfs_FS_ExtendLock,\n\t.deliver\t= yfs_deliver_status_and_volsync,\n\t.done\t\t= afs_lock_op_done,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nstatic const struct afs_call_type yfs_RXYFSReleaseLock = {\n\t.name\t\t= \"YFS.ReleaseLock\",\n\t.op\t\t= yfs_FS_ReleaseLock,\n\t.deliver\t= yfs_deliver_status_and_volsync,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid yfs_fs_set_lock(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXYFSSetLock,\n\t\t\t\t   sizeof(__be32) * 2 +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid) +\n\t\t\t\t   sizeof(__be32),\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSVolSync));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSSETLOCK);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_YFSFid(bp, &vp->fid);\n\tbp = xdr_encode_u32(bp, op->lock.type);\n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_calli(call, &vp->fid, op->lock.type);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nvoid yfs_fs_extend_lock(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXYFSExtendLock,\n\t\t\t\t   sizeof(__be32) * 2 +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid),\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSVolSync));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSEXTENDLOCK);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_YFSFid(bp, &vp->fid);\n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nvoid yfs_fs_release_lock(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXYFSReleaseLock,\n\t\t\t\t   sizeof(__be32) * 2 +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid),\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSVolSync));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSRELEASELOCK);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_YFSFid(bp, &vp->fid);\n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int yfs_deliver_fs_fetch_status(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode_param *vp = &op->file[op->fetch_status.which];\n\tconst __be32 *bp;\n\tint ret;\n\n\tret = afs_transfer_reply(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbp = call->buffer;\n\txdr_decode_YFSFetchStatus(&bp, call, &vp->scb);\n\txdr_decode_YFSCallBack(&bp, call, &vp->scb);\n\txdr_decode_YFSVolSync(&bp, &op->volsync);\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type yfs_RXYFSFetchStatus = {\n\t.name\t\t= \"YFS.FetchStatus\",\n\t.op\t\t= yfs_FS_FetchStatus,\n\t.deliver\t= yfs_deliver_fs_fetch_status,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid yfs_fs_fetch_status(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[op->fetch_status.which];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%llx:%llu},,\",\n\t       key_serial(op->key), vp->fid.vid, vp->fid.vnode);\n\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXYFSFetchStatus,\n\t\t\t\t   sizeof(__be32) * 2 +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid),\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSCallBack) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSVolSync));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSFETCHSTATUS);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_YFSFid(bp, &vp->fid);\n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int yfs_deliver_fs_inline_bulk_status(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_status_cb *scb;\n\tconst __be32 *bp;\n\tu32 tmp;\n\tint ret;\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tafs_extract_to_tmp(call);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 1:\n\t\t_debug(\"extract status count\");\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttmp = ntohl(call->tmp);\n\t\t_debug(\"status count: %u/%u\", tmp, op->nr_files);\n\t\tif (tmp != op->nr_files)\n\t\t\treturn afs_protocol_error(call, afs_eproto_ibulkst_count);\n\n\t\tcall->count = 0;\n\t\tcall->unmarshall++;\n\tmore_counts:\n\t\tafs_extract_to_buf(call, sizeof(struct yfs_xdr_YFSFetchStatus));\n\t\tfallthrough;\n\n\tcase 2:\n\t\t_debug(\"extract status array %u\", call->count);\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tswitch (call->count) {\n\t\tcase 0:\n\t\t\tscb = &op->file[0].scb;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscb = &op->file[1].scb;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tscb = &op->more_files[call->count - 2].scb;\n\t\t\tbreak;\n\t\t}\n\n\t\tbp = call->buffer;\n\t\txdr_decode_YFSFetchStatus(&bp, call, scb);\n\n\t\tcall->count++;\n\t\tif (call->count < op->nr_files)\n\t\t\tgoto more_counts;\n\n\t\tcall->count = 0;\n\t\tcall->unmarshall++;\n\t\tafs_extract_to_tmp(call);\n\t\tfallthrough;\n\n\t\t \n\tcase 3:\n\t\t_debug(\"extract CB count\");\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttmp = ntohl(call->tmp);\n\t\t_debug(\"CB count: %u\", tmp);\n\t\tif (tmp != op->nr_files)\n\t\t\treturn afs_protocol_error(call, afs_eproto_ibulkst_cb_count);\n\t\tcall->count = 0;\n\t\tcall->unmarshall++;\n\tmore_cbs:\n\t\tafs_extract_to_buf(call, sizeof(struct yfs_xdr_YFSCallBack));\n\t\tfallthrough;\n\n\tcase 4:\n\t\t_debug(\"extract CB array\");\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t_debug(\"unmarshall CB array\");\n\t\tswitch (call->count) {\n\t\tcase 0:\n\t\t\tscb = &op->file[0].scb;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscb = &op->file[1].scb;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tscb = &op->more_files[call->count - 2].scb;\n\t\t\tbreak;\n\t\t}\n\n\t\tbp = call->buffer;\n\t\txdr_decode_YFSCallBack(&bp, call, scb);\n\t\tcall->count++;\n\t\tif (call->count < op->nr_files)\n\t\t\tgoto more_cbs;\n\n\t\tafs_extract_to_buf(call, sizeof(struct yfs_xdr_YFSVolSync));\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\tcase 5:\n\t\tret = afs_extract_data(call, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbp = call->buffer;\n\t\txdr_decode_YFSVolSync(&bp, &op->volsync);\n\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\tcase 6:\n\t\tbreak;\n\t}\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\n \nstatic const struct afs_call_type yfs_RXYFSInlineBulkStatus = {\n\t.name\t\t= \"YFS.InlineBulkStatus\",\n\t.op\t\t= yfs_FS_InlineBulkStatus,\n\t.deliver\t= yfs_deliver_fs_inline_bulk_status,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid yfs_fs_inline_bulk_status(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *dvp = &op->file[0];\n\tstruct afs_vnode_param *vp = &op->file[1];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\tint i;\n\n\t_enter(\",%x,{%llx:%llu},%u\",\n\t       key_serial(op->key), vp->fid.vid, vp->fid.vnode, op->nr_files);\n\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXYFSInlineBulkStatus,\n\t\t\t\t   sizeof(__be32) +\n\t\t\t\t   sizeof(__be32) +\n\t\t\t\t   sizeof(__be32) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid) * op->nr_files,\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSINLINEBULKSTATUS);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_u32(bp, op->nr_files);\n\tbp = xdr_encode_YFSFid(bp, &dvp->fid);\n\tbp = xdr_encode_YFSFid(bp, &vp->fid);\n\tfor (i = 0; i < op->nr_files - 2; i++)\n\t\tbp = xdr_encode_YFSFid(bp, &op->more_files[i].fid);\n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_NOFS);\n}\n\n \nstatic int yfs_deliver_fs_fetch_opaque_acl(struct afs_call *call)\n{\n\tstruct afs_operation *op = call->op;\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct yfs_acl *yacl = op->yacl;\n\tstruct afs_acl *acl;\n\tconst __be32 *bp;\n\tunsigned int size;\n\tint ret;\n\n\t_enter(\"{%u}\", call->unmarshall);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tafs_extract_to_tmp(call);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 1:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tsize = call->count2 = ntohl(call->tmp);\n\t\tsize = round_up(size, 4);\n\n\t\tif (yacl->flags & YFS_ACL_WANT_ACL) {\n\t\t\tacl = kmalloc(struct_size(acl, data, size), GFP_KERNEL);\n\t\t\tif (!acl)\n\t\t\t\treturn -ENOMEM;\n\t\t\tyacl->acl = acl;\n\t\t\tacl->size = call->count2;\n\t\t\tafs_extract_begin(call, acl->data, size);\n\t\t} else {\n\t\t\tafs_extract_discard(call, size);\n\t\t}\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 2:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tafs_extract_to_tmp(call);\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 3:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tsize = call->count2 = ntohl(call->tmp);\n\t\tsize = round_up(size, 4);\n\n\t\tif (yacl->flags & YFS_ACL_WANT_VOL_ACL) {\n\t\t\tacl = kmalloc(struct_size(acl, data, size), GFP_KERNEL);\n\t\t\tif (!acl)\n\t\t\t\treturn -ENOMEM;\n\t\t\tyacl->vol_acl = acl;\n\t\t\tacl->size = call->count2;\n\t\t\tafs_extract_begin(call, acl->data, size);\n\t\t} else {\n\t\t\tafs_extract_discard(call, size);\n\t\t}\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 4:\n\t\tret = afs_extract_data(call, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tafs_extract_to_buf(call,\n\t\t\t\t   sizeof(__be32) * 2 +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSVolSync));\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\t\t \n\tcase 5:\n\t\tret = afs_extract_data(call, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbp = call->buffer;\n\t\tyacl->inherit_flag = ntohl(*bp++);\n\t\tyacl->num_cleaned = ntohl(*bp++);\n\t\txdr_decode_YFSFetchStatus(&bp, call, &vp->scb);\n\t\txdr_decode_YFSVolSync(&bp, &op->volsync);\n\n\t\tcall->unmarshall++;\n\t\tfallthrough;\n\n\tcase 6:\n\t\tbreak;\n\t}\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}\n\nvoid yfs_free_opaque_acl(struct yfs_acl *yacl)\n{\n\tif (yacl) {\n\t\tkfree(yacl->acl);\n\t\tkfree(yacl->vol_acl);\n\t\tkfree(yacl);\n\t}\n}\n\n \nstatic const struct afs_call_type yfs_RXYFSFetchOpaqueACL = {\n\t.name\t\t= \"YFS.FetchOpaqueACL\",\n\t.op\t\t= yfs_FS_FetchOpaqueACL,\n\t.deliver\t= yfs_deliver_fs_fetch_opaque_acl,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid yfs_fs_fetch_opaque_acl(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%llx:%llu},,\",\n\t       key_serial(op->key), vp->fid.vid, vp->fid.vnode);\n\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXYFSFetchOpaqueACL,\n\t\t\t\t   sizeof(__be32) * 2 +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid),\n\t\t\t\t   sizeof(__be32) * 2 +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSVolSync));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSFETCHOPAQUEACL);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_YFSFid(bp, &vp->fid);\n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_KERNEL);\n}\n\n \nstatic const struct afs_call_type yfs_RXYFSStoreOpaqueACL2 = {\n\t.name\t\t= \"YFS.StoreOpaqueACL2\",\n\t.op\t\t= yfs_FS_StoreOpaqueACL2,\n\t.deliver\t= yfs_deliver_status_and_volsync,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\n \nvoid yfs_fs_store_opaque_acl2(struct afs_operation *op)\n{\n\tstruct afs_vnode_param *vp = &op->file[0];\n\tstruct afs_call *call;\n\tstruct afs_acl *acl = op->acl;\n\tsize_t size;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%llx:%llu},,\",\n\t       key_serial(op->key), vp->fid.vid, vp->fid.vnode);\n\n\tsize = round_up(acl->size, 4);\n\tcall = afs_alloc_flat_call(op->net, &yfs_RXYFSStoreOpaqueACL2,\n\t\t\t\t   sizeof(__be32) * 2 +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFid) +\n\t\t\t\t   sizeof(__be32) + size,\n\t\t\t\t   sizeof(struct yfs_xdr_YFSFetchStatus) +\n\t\t\t\t   sizeof(struct yfs_xdr_YFSVolSync));\n\tif (!call)\n\t\treturn afs_op_nomem(op);\n\n\t \n\tbp = call->request;\n\tbp = xdr_encode_u32(bp, YFSSTOREOPAQUEACL2);\n\tbp = xdr_encode_u32(bp, 0);  \n\tbp = xdr_encode_YFSFid(bp, &vp->fid);\n\tbp = xdr_encode_u32(bp, acl->size);\n\tmemcpy(bp, acl->data, acl->size);\n\tif (acl->size != size)\n\t\tmemset((void *)bp + acl->size, 0, size - acl->size);\n\tbp += size / sizeof(__be32);\n\tyfs_check_req(call, bp);\n\n\ttrace_afs_make_fs_call(call, &vp->fid);\n\tafs_make_op_call(op, call, GFP_KERNEL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}