{
  "module_name": "olpc.c",
  "hash_id": "7573b523d374d42d4185f1d42740fa26f7acbf8ad7b3637b227c919593556c6d",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/olpc/olpc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/string.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/syscore_ops.h>\n#include <linux/mutex.h>\n#include <linux/olpc-ec.h>\n\n#include <asm/geode.h>\n#include <asm/setup.h>\n#include <asm/olpc.h>\n#include <asm/olpc_ofw.h>\n\nstruct olpc_platform_t olpc_platform_info;\nEXPORT_SYMBOL_GPL(olpc_platform_info);\n\n \n#define EC_BASE_TIMEOUT 20\n\n \nstatic int ec_timeout = EC_BASE_TIMEOUT;\n\nstatic int __init olpc_ec_timeout_set(char *str)\n{\n\tif (get_option(&str, &ec_timeout) != 1) {\n\t\tec_timeout = EC_BASE_TIMEOUT;\n\t\tprintk(KERN_ERR \"olpc-ec:  invalid argument to \"\n\t\t\t\t\"'olpc_ec_timeout=', ignoring!\\n\");\n\t}\n\tprintk(KERN_DEBUG \"olpc-ec:  using %d ms delay for EC commands.\\n\",\n\t\t\tec_timeout);\n\treturn 1;\n}\n__setup(\"olpc_ec_timeout=\", olpc_ec_timeout_set);\n\n \n\nstatic inline unsigned int ibf_status(unsigned int port)\n{\n\treturn !!(inb(port) & 0x02);\n}\n\nstatic inline unsigned int obf_status(unsigned int port)\n{\n\treturn inb(port) & 0x01;\n}\n\n#define wait_on_ibf(p, d) __wait_on_ibf(__LINE__, (p), (d))\nstatic int __wait_on_ibf(unsigned int line, unsigned int port, int desired)\n{\n\tunsigned int timeo;\n\tint state = ibf_status(port);\n\n\tfor (timeo = ec_timeout; state != desired && timeo; timeo--) {\n\t\tmdelay(1);\n\t\tstate = ibf_status(port);\n\t}\n\n\tif ((state == desired) && (ec_timeout > EC_BASE_TIMEOUT) &&\n\t\t\ttimeo < (ec_timeout - EC_BASE_TIMEOUT)) {\n\t\tprintk(KERN_WARNING \"olpc-ec:  %d: waited %u ms for IBF!\\n\",\n\t\t\t\tline, ec_timeout - timeo);\n\t}\n\n\treturn !(state == desired);\n}\n\n#define wait_on_obf(p, d) __wait_on_obf(__LINE__, (p), (d))\nstatic int __wait_on_obf(unsigned int line, unsigned int port, int desired)\n{\n\tunsigned int timeo;\n\tint state = obf_status(port);\n\n\tfor (timeo = ec_timeout; state != desired && timeo; timeo--) {\n\t\tmdelay(1);\n\t\tstate = obf_status(port);\n\t}\n\n\tif ((state == desired) && (ec_timeout > EC_BASE_TIMEOUT) &&\n\t\t\ttimeo < (ec_timeout - EC_BASE_TIMEOUT)) {\n\t\tprintk(KERN_WARNING \"olpc-ec:  %d: waited %u ms for OBF!\\n\",\n\t\t\t\tline, ec_timeout - timeo);\n\t}\n\n\treturn !(state == desired);\n}\n\n \nstatic int olpc_xo1_ec_cmd(u8 cmd, u8 *inbuf, size_t inlen, u8 *outbuf,\n\t\tsize_t outlen, void *arg)\n{\n\tint ret = -EIO;\n\tint i;\n\tint restarts = 0;\n\n\t \n\tfor (i = 0; i < 10 && (obf_status(0x6c) == 1); i++)\n\t\tinb(0x68);\n\tif (i == 10) {\n\t\tprintk(KERN_ERR \"olpc-ec:  timeout while attempting to \"\n\t\t\t\t\"clear OBF flag!\\n\");\n\t\tgoto err;\n\t}\n\n\tif (wait_on_ibf(0x6c, 0)) {\n\t\tprintk(KERN_ERR \"olpc-ec:  timeout waiting for EC to \"\n\t\t\t\t\"quiesce!\\n\");\n\t\tgoto err;\n\t}\n\nrestart:\n\t \n\tpr_devel(\"olpc-ec:  running cmd 0x%x\\n\", cmd);\n\toutb(cmd, 0x6c);\n\n\tif (wait_on_ibf(0x6c, 0)) {\n\t\tprintk(KERN_ERR \"olpc-ec:  timeout waiting for EC to read \"\n\t\t\t\t\"command!\\n\");\n\t\tgoto err;\n\t}\n\n\tif (inbuf && inlen) {\n\t\t \n\t\tfor (i = 0; i < inlen; i++) {\n\t\t\tpr_devel(\"olpc-ec:  sending cmd arg 0x%x\\n\", inbuf[i]);\n\t\t\toutb(inbuf[i], 0x68);\n\t\t\tif (wait_on_ibf(0x6c, 0)) {\n\t\t\t\tprintk(KERN_ERR \"olpc-ec:  timeout waiting for\"\n\t\t\t\t\t\t\" EC accept data!\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\tif (outbuf && outlen) {\n\t\t \n\t\tfor (i = 0; i < outlen; i++) {\n\t\t\tif (wait_on_obf(0x6c, 1)) {\n\t\t\t\tprintk(KERN_ERR \"olpc-ec:  timeout waiting for\"\n\t\t\t\t\t\t\" EC to provide data!\\n\");\n\t\t\t\tif (restarts++ < 10)\n\t\t\t\t\tgoto restart;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\toutbuf[i] = inb(0x68);\n\t\t\tpr_devel(\"olpc-ec:  received 0x%x\\n\", outbuf[i]);\n\t\t}\n\t}\n\n\tret = 0;\nerr:\n\treturn ret;\n}\n\nstatic bool __init check_ofw_architecture(struct device_node *root)\n{\n\tconst char *olpc_arch;\n\tint propsize;\n\n\tolpc_arch = of_get_property(root, \"architecture\", &propsize);\n\treturn propsize == 5 && strncmp(\"OLPC\", olpc_arch, 5) == 0;\n}\n\nstatic u32 __init get_board_revision(struct device_node *root)\n{\n\tint propsize;\n\tconst __be32 *rev;\n\n\trev = of_get_property(root, \"board-revision-int\", &propsize);\n\tif (propsize != 4)\n\t\treturn 0;\n\n\treturn be32_to_cpu(*rev);\n}\n\nstatic bool __init platform_detect(void)\n{\n\tstruct device_node *root = of_find_node_by_path(\"/\");\n\tbool success;\n\n\tif (!root)\n\t\treturn false;\n\n\tsuccess = check_ofw_architecture(root);\n\tif (success) {\n\t\tolpc_platform_info.boardrev = get_board_revision(root);\n\t\tolpc_platform_info.flags |= OLPC_F_PRESENT;\n\n\t\tpr_info(\"OLPC board revision %s%X\\n\",\n\t\t\t((olpc_platform_info.boardrev & 0xf) < 8) ? \"pre\" : \"\",\n\t\t\tolpc_platform_info.boardrev >> 4);\n\t}\n\n\tof_node_put(root);\n\treturn success;\n}\n\nstatic int __init add_xo1_platform_devices(void)\n{\n\tstruct platform_device *pdev;\n\n\tpdev = platform_device_register_simple(\"xo1-rfkill\", -1, NULL, 0);\n\tif (IS_ERR(pdev))\n\t\treturn PTR_ERR(pdev);\n\n\tpdev = platform_device_register_simple(\"olpc-xo1\", -1, NULL, 0);\n\n\treturn PTR_ERR_OR_ZERO(pdev);\n}\n\nstatic int olpc_xo1_ec_suspend(struct platform_device *pdev)\n{\n\t \n\treturn olpc_ec_cmd(EC_SET_SCI_INHIBIT, NULL, 0, NULL, 0);\n}\n\nstatic int olpc_xo1_ec_resume(struct platform_device *pdev)\n{\n\t \n\tolpc_ec_cmd(EC_SET_SCI_INHIBIT_RELEASE, NULL, 0, NULL, 0);\n\n\t \n\tolpc_ec_cmd(EC_WAKE_UP_WLAN, NULL, 0, NULL, 0);\n\tolpc_ec_cmd(EC_WAKE_UP_WLAN, NULL, 0, NULL, 0);\n\n\treturn 0;\n}\n\nstatic struct olpc_ec_driver ec_xo1_driver = {\n\t.suspend = olpc_xo1_ec_suspend,\n\t.resume = olpc_xo1_ec_resume,\n\t.ec_cmd = olpc_xo1_ec_cmd,\n#ifdef CONFIG_OLPC_XO1_SCI\n\t \n\t.wakeup_available = true,\n#endif\n};\n\nstatic struct olpc_ec_driver ec_xo1_5_driver = {\n\t.ec_cmd = olpc_xo1_ec_cmd,\n#ifdef CONFIG_OLPC_XO15_SCI\n\t \n\t.wakeup_available = true,\n#endif\n};\n\nstatic int __init olpc_init(void)\n{\n\tint r = 0;\n\n\tif (!olpc_ofw_present() || !platform_detect())\n\t\treturn 0;\n\n\t \n\tif (olpc_platform_info.boardrev < olpc_board_pre(0xd0))\t \n\t\tolpc_ec_driver_register(&ec_xo1_driver, NULL);\n\telse\n\t\tolpc_ec_driver_register(&ec_xo1_5_driver, NULL);\n\tplatform_device_register_simple(\"olpc-ec\", -1, NULL, 0);\n\n\t \n\tif (olpc_board_at_least(olpc_board(0xb1)))\n\t\tolpc_platform_info.flags |= OLPC_F_DCON;\n\n#ifdef CONFIG_PCI_OLPC\n\t \n\tif (olpc_platform_info.boardrev < olpc_board_pre(0xd0) &&\n\t\t\t!cs5535_has_vsa2())\n\t\tx86_init.pci.arch_init = pci_olpc_init;\n#endif\n\n\tif (olpc_platform_info.boardrev < olpc_board_pre(0xd0)) {  \n\t\tr = add_xo1_platform_devices();\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\npostcore_initcall(olpc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}