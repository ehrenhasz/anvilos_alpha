{
  "module_name": "olpc_ofw.c",
  "hash_id": "d42846a043c3a82441f0be1b388b4e21e68cde4ee9c559e255bc623aba4acc9a",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/olpc/olpc_ofw.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/spinlock_types.h>\n#include <linux/init.h>\n#include <linux/pgtable.h>\n#include <asm/page.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/cpufeature.h>\n#include <asm/special_insns.h>\n#include <asm/olpc_ofw.h>\n\n \nstatic int (*olpc_ofw_cif)(int *);\n\n \nu32 olpc_ofw_pgd __initdata;\n\nstatic DEFINE_SPINLOCK(ofw_lock);\n\n#define MAXARGS 10\n\nvoid __init setup_olpc_ofw_pgd(void)\n{\n\tpgd_t *base, *ofw_pde;\n\n\tif (!olpc_ofw_cif)\n\t\treturn;\n\n\t \n\tbase = early_ioremap(olpc_ofw_pgd, sizeof(olpc_ofw_pgd) * PTRS_PER_PGD);\n\tif (!base) {\n\t\tprintk(KERN_ERR \"failed to remap OFW's pgd - disabling OFW!\\n\");\n\t\tolpc_ofw_cif = NULL;\n\t\treturn;\n\t}\n\tofw_pde = &base[OLPC_OFW_PDE_NR];\n\n\t \n\tset_pgd(&swapper_pg_dir[OLPC_OFW_PDE_NR], *ofw_pde);\n\t \n\n\tearly_iounmap(base, sizeof(olpc_ofw_pgd) * PTRS_PER_PGD);\n}\n\nint __olpc_ofw(const char *name, int nr_args, const void **args, int nr_res,\n\t\tvoid **res)\n{\n\tint ofw_args[MAXARGS + 3];\n\tunsigned long flags;\n\tint ret, i, *p;\n\n\tBUG_ON(nr_args + nr_res > MAXARGS);\n\n\tif (!olpc_ofw_cif)\n\t\treturn -EIO;\n\n\tofw_args[0] = (int)name;\n\tofw_args[1] = nr_args;\n\tofw_args[2] = nr_res;\n\n\tp = &ofw_args[3];\n\tfor (i = 0; i < nr_args; i++, p++)\n\t\t*p = (int)args[i];\n\n\t \n\tspin_lock_irqsave(&ofw_lock, flags);\n\tret = olpc_ofw_cif(ofw_args);\n\tspin_unlock_irqrestore(&ofw_lock, flags);\n\n\tif (!ret) {\n\t\tfor (i = 0; i < nr_res; i++, p++)\n\t\t\t*((int *)res[i]) = *p;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__olpc_ofw);\n\nbool olpc_ofw_present(void)\n{\n\treturn olpc_ofw_cif != NULL;\n}\nEXPORT_SYMBOL_GPL(olpc_ofw_present);\n\n \n#define OFW_MIN 0xff000000\n\n \n#define OFW_BOUND (1<<20)\n\nvoid __init olpc_ofw_detect(void)\n{\n\tstruct olpc_ofw_header *hdr = &boot_params.olpc_ofw_header;\n\tunsigned long start;\n\n\t \n\tif (hdr->ofw_magic != OLPC_OFW_SIG)\n\t\treturn;\n\n\tolpc_ofw_cif = (int (*)(int *))hdr->cif_handler;\n\n\tif ((unsigned long)olpc_ofw_cif < OFW_MIN) {\n\t\tprintk(KERN_ERR \"OFW detected, but cif has invalid address 0x%lx - disabling.\\n\",\n\t\t\t\t(unsigned long)olpc_ofw_cif);\n\t\tolpc_ofw_cif = NULL;\n\t\treturn;\n\t}\n\n\t \n\tstart = round_down((unsigned long)olpc_ofw_cif, OFW_BOUND);\n\tprintk(KERN_INFO \"OFW detected in memory, cif @ 0x%lx (reserving top %ldMB)\\n\",\n\t\t\t(unsigned long)olpc_ofw_cif, (-start) >> 20);\n\treserve_top_address(-start);\n}\n\nbool __init olpc_ofw_is_installed(void)\n{\n\treturn olpc_ofw_cif != NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}