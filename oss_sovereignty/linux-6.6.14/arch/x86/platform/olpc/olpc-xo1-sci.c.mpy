{
  "module_name": "olpc-xo1-sci.c",
  "hash_id": "b4063a4bf63b325b4207a6d9bfe771561a4ed71ae5a398af6d327ead3a287ac7",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/olpc/olpc-xo1-sci.c",
  "human_readable_source": "\n \n\n#include <linux/cs5535.h>\n#include <linux/device.h>\n#include <linux/gpio.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_wakeup.h>\n#include <linux/power_supply.h>\n#include <linux/suspend.h>\n#include <linux/workqueue.h>\n#include <linux/olpc-ec.h>\n\n#include <asm/io.h>\n#include <asm/msr.h>\n#include <asm/olpc.h>\n\n#define DRV_NAME\t\"olpc-xo1-sci\"\n#define PFX\t\tDRV_NAME \": \"\n\nstatic unsigned long acpi_base;\nstatic struct input_dev *power_button_idev;\nstatic struct input_dev *ebook_switch_idev;\nstatic struct input_dev *lid_switch_idev;\n\nstatic int sci_irq;\n\nstatic bool lid_open;\nstatic bool lid_inverted;\nstatic int lid_wake_mode;\n\nenum lid_wake_modes {\n\tLID_WAKE_ALWAYS,\n\tLID_WAKE_OPEN,\n\tLID_WAKE_CLOSE,\n};\n\nstatic const char * const lid_wake_mode_names[] = {\n\t[LID_WAKE_ALWAYS] = \"always\",\n\t[LID_WAKE_OPEN] = \"open\",\n\t[LID_WAKE_CLOSE] = \"close\",\n};\n\nstatic void battery_status_changed(void)\n{\n\tstruct power_supply *psy = power_supply_get_by_name(\"olpc_battery\");\n\n\tif (psy) {\n\t\tpower_supply_changed(psy);\n\t\tpower_supply_put(psy);\n\t}\n}\n\nstatic void ac_status_changed(void)\n{\n\tstruct power_supply *psy = power_supply_get_by_name(\"olpc_ac\");\n\n\tif (psy) {\n\t\tpower_supply_changed(psy);\n\t\tpower_supply_put(psy);\n\t}\n}\n\n \nstatic void send_ebook_state(void)\n{\n\tunsigned char state;\n\n\tif (olpc_ec_cmd(EC_READ_EB_MODE, NULL, 0, &state, 1)) {\n\t\tpr_err(PFX \"failed to get ebook state\\n\");\n\t\treturn;\n\t}\n\n\tif (test_bit(SW_TABLET_MODE, ebook_switch_idev->sw) == !!state)\n\t\treturn;  \n\n\tinput_report_switch(ebook_switch_idev, SW_TABLET_MODE, state);\n\tinput_sync(ebook_switch_idev);\n\tpm_wakeup_event(&ebook_switch_idev->dev, 0);\n}\n\nstatic void flip_lid_inverter(void)\n{\n\t \n\tif (lid_inverted)\n\t\tcs5535_gpio_clear(OLPC_GPIO_LID, GPIO_INPUT_INVERT);\n\telse\n\t\tcs5535_gpio_set(OLPC_GPIO_LID, GPIO_INPUT_INVERT);\n\tlid_inverted = !lid_inverted;\n}\n\nstatic void detect_lid_state(void)\n{\n\t \n\n\tint state;\n\n\tstate = cs5535_gpio_isset(OLPC_GPIO_LID, GPIO_READ_BACK);\n\tlid_open = !state ^ !lid_inverted;  \n\tif (!state)\n\t\treturn;\n\n\tflip_lid_inverter();\n}\n\n \nstatic void send_lid_state(void)\n{\n\tif (!!test_bit(SW_LID, lid_switch_idev->sw) == !lid_open)\n\t\treturn;  \n\n\tinput_report_switch(lid_switch_idev, SW_LID, !lid_open);\n\tinput_sync(lid_switch_idev);\n\tpm_wakeup_event(&lid_switch_idev->dev, 0);\n}\n\nstatic ssize_t lid_wake_mode_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tconst char *mode = lid_wake_mode_names[lid_wake_mode];\n\treturn sprintf(buf, \"%s\\n\", mode);\n}\nstatic ssize_t lid_wake_mode_set(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(lid_wake_mode_names); i++) {\n\t\tconst char *mode = lid_wake_mode_names[i];\n\t\tif (strlen(mode) != count || strncasecmp(mode, buf, count))\n\t\t\tcontinue;\n\n\t\tlid_wake_mode = i;\n\t\treturn count;\n\t}\n\treturn -EINVAL;\n}\nstatic DEVICE_ATTR(lid_wake_mode, S_IWUSR | S_IRUGO, lid_wake_mode_show,\n\t\t   lid_wake_mode_set);\n\nstatic struct attribute *lid_attrs[] = {\n\t&dev_attr_lid_wake_mode.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(lid);\n\n \nstatic void process_sci_queue(bool propagate_events)\n{\n\tint r;\n\tu16 data;\n\n\tdo {\n\t\tr = olpc_ec_sci_query(&data);\n\t\tif (r || !data)\n\t\t\tbreak;\n\n\t\tpr_debug(PFX \"SCI 0x%x received\\n\", data);\n\n\t\tswitch (data) {\n\t\tcase EC_SCI_SRC_BATERR:\n\t\tcase EC_SCI_SRC_BATSOC:\n\t\tcase EC_SCI_SRC_BATTERY:\n\t\tcase EC_SCI_SRC_BATCRIT:\n\t\t\tbattery_status_changed();\n\t\t\tbreak;\n\t\tcase EC_SCI_SRC_ACPWR:\n\t\t\tac_status_changed();\n\t\t\tbreak;\n\t\t}\n\n\t\tif (data == EC_SCI_SRC_EBOOK && propagate_events)\n\t\t\tsend_ebook_state();\n\t} while (data);\n\n\tif (r)\n\t\tpr_err(PFX \"Failed to clear SCI queue\");\n}\n\nstatic void process_sci_queue_work(struct work_struct *work)\n{\n\tprocess_sci_queue(true);\n}\n\nstatic DECLARE_WORK(sci_work, process_sci_queue_work);\n\nstatic irqreturn_t xo1_sci_intr(int irq, void *dev_id)\n{\n\tstruct platform_device *pdev = dev_id;\n\tu32 sts;\n\tu32 gpe;\n\n\tsts = inl(acpi_base + CS5536_PM1_STS);\n\toutl(sts | 0xffff, acpi_base + CS5536_PM1_STS);\n\n\tgpe = inl(acpi_base + CS5536_PM_GPE0_STS);\n\toutl(0xffffffff, acpi_base + CS5536_PM_GPE0_STS);\n\n\tdev_dbg(&pdev->dev, \"sts %x gpe %x\\n\", sts, gpe);\n\n\tif (sts & CS5536_PWRBTN_FLAG) {\n\t\tif (!(sts & CS5536_WAK_FLAG)) {\n\t\t\t \n\t\t\tinput_report_key(power_button_idev, KEY_POWER, 1);\n\t\t\tinput_sync(power_button_idev);\n\t\t\tinput_report_key(power_button_idev, KEY_POWER, 0);\n\t\t\tinput_sync(power_button_idev);\n\t\t}\n\t\t \n\t\tpm_wakeup_event(&power_button_idev->dev, 0);\n\t}\n\n\tif ((sts & (CS5536_RTC_FLAG | CS5536_WAK_FLAG)) ==\n\t\t\t(CS5536_RTC_FLAG | CS5536_WAK_FLAG)) {\n\t\t \n\t\tstruct device *rtc = bus_find_device_by_name(\n\t\t\t&platform_bus_type, NULL, \"rtc_cmos\");\n\t\tif (rtc) {\n\t\t\tpm_wakeup_event(rtc, 0);\n\t\t\tput_device(rtc);\n\t\t}\n\t}\n\n\tif (gpe & CS5536_GPIOM7_PME_FLAG) {  \n\t\tcs5535_gpio_set(OLPC_GPIO_ECSCI, GPIO_NEGATIVE_EDGE_STS);\n\t\tschedule_work(&sci_work);\n\t}\n\n\tcs5535_gpio_set(OLPC_GPIO_LID, GPIO_NEGATIVE_EDGE_STS);\n\tcs5535_gpio_set(OLPC_GPIO_LID, GPIO_POSITIVE_EDGE_STS);\n\tdetect_lid_state();\n\tsend_lid_state();\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int xo1_sci_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tif (device_may_wakeup(&power_button_idev->dev))\n\t\tolpc_xo1_pm_wakeup_set(CS5536_PM_PWRBTN);\n\telse\n\t\tolpc_xo1_pm_wakeup_clear(CS5536_PM_PWRBTN);\n\n\tif (device_may_wakeup(&ebook_switch_idev->dev))\n\t\tolpc_ec_wakeup_set(EC_SCI_SRC_EBOOK);\n\telse\n\t\tolpc_ec_wakeup_clear(EC_SCI_SRC_EBOOK);\n\n\tif (!device_may_wakeup(&lid_switch_idev->dev)) {\n\t\tcs5535_gpio_clear(OLPC_GPIO_LID, GPIO_EVENTS_ENABLE);\n\t} else if ((lid_open && lid_wake_mode == LID_WAKE_OPEN) ||\n\t\t   (!lid_open && lid_wake_mode == LID_WAKE_CLOSE)) {\n\t\tflip_lid_inverter();\n\n\t\t \n\t\tcs5535_gpio_set(OLPC_GPIO_LID, GPIO_NEGATIVE_EDGE_STS);\n\t\tcs5535_gpio_set(OLPC_GPIO_LID, GPIO_POSITIVE_EDGE_STS);\n\n\t\tcs5535_gpio_set(OLPC_GPIO_LID, GPIO_EVENTS_ENABLE);\n\t}\n\n\treturn 0;\n}\n\nstatic int xo1_sci_resume(struct platform_device *pdev)\n{\n\t \n\tdetect_lid_state();\n\tsend_lid_state();\n\tcs5535_gpio_set(OLPC_GPIO_LID, GPIO_EVENTS_ENABLE);\n\n\t \n\tolpc_ec_mask_write(EC_SCI_SRC_ALL);\n\n\t \n\tbattery_status_changed();\n\tac_status_changed();\n\treturn 0;\n}\n\nstatic int setup_sci_interrupt(struct platform_device *pdev)\n{\n\tu32 lo, hi;\n\tu32 sts;\n\tint r;\n\n\trdmsr(0x51400020, lo, hi);\n\tsci_irq = (lo >> 20) & 15;\n\n\tif (sci_irq) {\n\t\tdev_info(&pdev->dev, \"SCI is mapped to IRQ %d\\n\", sci_irq);\n\t} else {\n\t\t \n\t\tdev_info(&pdev->dev, \"SCI unmapped. Mapping to IRQ 3\\n\");\n\t\tsci_irq = 3;\n\t\tlo |= 0x00300000;\n\t\twrmsrl(0x51400020, lo);\n\t}\n\n\t \n\tif (sci_irq < 8) {\n\t\tlo = inb(CS5536_PIC_INT_SEL1);\n\t\tlo |= 1 << sci_irq;\n\t\toutb(lo, CS5536_PIC_INT_SEL1);\n\t} else {\n\t\tlo = inb(CS5536_PIC_INT_SEL2);\n\t\tlo |= 1 << (sci_irq - 8);\n\t\toutb(lo, CS5536_PIC_INT_SEL2);\n\t}\n\n\t \n\tsts = inl(acpi_base + CS5536_PM1_STS);\n\toutl(((CS5536_PM_PWRBTN | CS5536_PM_RTC) << 16) | 0xffff,\n\t     acpi_base + CS5536_PM1_STS);\n\n\tr = request_irq(sci_irq, xo1_sci_intr, 0, DRV_NAME, pdev);\n\tif (r)\n\t\tdev_err(&pdev->dev, \"can't request interrupt\\n\");\n\n\treturn r;\n}\n\nstatic int setup_ec_sci(void)\n{\n\tint r;\n\n\tr = gpio_request(OLPC_GPIO_ECSCI, \"OLPC-ECSCI\");\n\tif (r)\n\t\treturn r;\n\n\tgpio_direction_input(OLPC_GPIO_ECSCI);\n\n\t \n\tcs5535_gpio_set(OLPC_GPIO_ECSCI, GPIO_NEGATIVE_EDGE_STS);\n\tcs5535_gpio_set(OLPC_GPIO_ECSCI, GPIO_POSITIVE_EDGE_STS);\n\n\t \n\tcs5535_gpio_set(OLPC_GPIO_ECSCI, GPIO_EVENTS_ENABLE);\n\n\t \n\tcs5535_gpio_setup_event(OLPC_GPIO_ECSCI, 7, 1);\n\n\t \n\tcs5535_pic_unreqz_select_high(7, sci_irq);\n\n\treturn 0;\n}\n\nstatic void free_ec_sci(void)\n{\n\tgpio_free(OLPC_GPIO_ECSCI);\n}\n\nstatic int setup_lid_events(void)\n{\n\tint r;\n\n\tr = gpio_request(OLPC_GPIO_LID, \"OLPC-LID\");\n\tif (r)\n\t\treturn r;\n\n\tgpio_direction_input(OLPC_GPIO_LID);\n\n\tcs5535_gpio_clear(OLPC_GPIO_LID, GPIO_INPUT_INVERT);\n\tlid_inverted = 0;\n\n\t \n\tcs5535_gpio_clear(OLPC_GPIO_LID, GPIO_EVENTS_ENABLE);\n\tcs5535_gpio_clear(OLPC_GPIO_LID, GPIO_NEGATIVE_EDGE_EN);\n\tcs5535_gpio_clear(OLPC_GPIO_LID, GPIO_POSITIVE_EDGE_EN);\n\tcs5535_gpio_set(OLPC_GPIO_LID, GPIO_NEGATIVE_EDGE_STS);\n\tcs5535_gpio_set(OLPC_GPIO_LID, GPIO_POSITIVE_EDGE_STS);\n\n\t \n\tcs5535_gpio_setup_event(OLPC_GPIO_LID, 6, 1);\n\n\t \n\tcs5535_gpio_set_irq(6, sci_irq);\n\n\t \n\tcs5535_gpio_set(OLPC_GPIO_LID, GPIO_EVENTS_ENABLE);\n\n\treturn 0;\n}\n\nstatic void free_lid_events(void)\n{\n\tgpio_free(OLPC_GPIO_LID);\n}\n\nstatic int setup_power_button(struct platform_device *pdev)\n{\n\tint r;\n\n\tpower_button_idev = input_allocate_device();\n\tif (!power_button_idev)\n\t\treturn -ENOMEM;\n\n\tpower_button_idev->name = \"Power Button\";\n\tpower_button_idev->phys = DRV_NAME \"/input0\";\n\tset_bit(EV_KEY, power_button_idev->evbit);\n\tset_bit(KEY_POWER, power_button_idev->keybit);\n\n\tpower_button_idev->dev.parent = &pdev->dev;\n\tdevice_init_wakeup(&power_button_idev->dev, 1);\n\n\tr = input_register_device(power_button_idev);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"failed to register power button: %d\\n\", r);\n\t\tinput_free_device(power_button_idev);\n\t}\n\n\treturn r;\n}\n\nstatic void free_power_button(void)\n{\n\tinput_unregister_device(power_button_idev);\n}\n\nstatic int setup_ebook_switch(struct platform_device *pdev)\n{\n\tint r;\n\n\tebook_switch_idev = input_allocate_device();\n\tif (!ebook_switch_idev)\n\t\treturn -ENOMEM;\n\n\tebook_switch_idev->name = \"EBook Switch\";\n\tebook_switch_idev->phys = DRV_NAME \"/input1\";\n\tset_bit(EV_SW, ebook_switch_idev->evbit);\n\tset_bit(SW_TABLET_MODE, ebook_switch_idev->swbit);\n\n\tebook_switch_idev->dev.parent = &pdev->dev;\n\tdevice_set_wakeup_capable(&ebook_switch_idev->dev, true);\n\n\tr = input_register_device(ebook_switch_idev);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"failed to register ebook switch: %d\\n\", r);\n\t\tinput_free_device(ebook_switch_idev);\n\t}\n\n\treturn r;\n}\n\nstatic void free_ebook_switch(void)\n{\n\tinput_unregister_device(ebook_switch_idev);\n}\n\nstatic int setup_lid_switch(struct platform_device *pdev)\n{\n\tint r;\n\n\tlid_switch_idev = input_allocate_device();\n\tif (!lid_switch_idev)\n\t\treturn -ENOMEM;\n\n\tlid_switch_idev->name = \"Lid Switch\";\n\tlid_switch_idev->phys = DRV_NAME \"/input2\";\n\tset_bit(EV_SW, lid_switch_idev->evbit);\n\tset_bit(SW_LID, lid_switch_idev->swbit);\n\n\tlid_switch_idev->dev.parent = &pdev->dev;\n\tdevice_set_wakeup_capable(&lid_switch_idev->dev, true);\n\n\tr = input_register_device(lid_switch_idev);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"failed to register lid switch: %d\\n\", r);\n\t\tgoto err_register;\n\t}\n\n\treturn 0;\n\nerr_register:\n\tinput_free_device(lid_switch_idev);\n\treturn r;\n}\n\nstatic void free_lid_switch(void)\n{\n\tinput_unregister_device(lid_switch_idev);\n}\n\nstatic int xo1_sci_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tint r;\n\n\t \n\tif (!machine_is_olpc())\n\t\treturn -ENODEV;\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"can't fetch device resource info\\n\");\n\t\treturn -EIO;\n\t}\n\tacpi_base = res->start;\n\n\tr = setup_power_button(pdev);\n\tif (r)\n\t\treturn r;\n\n\tr = setup_ebook_switch(pdev);\n\tif (r)\n\t\tgoto err_ebook;\n\n\tr = setup_lid_switch(pdev);\n\tif (r)\n\t\tgoto err_lid;\n\n\tr = setup_lid_events();\n\tif (r)\n\t\tgoto err_lidevt;\n\n\tr = setup_ec_sci();\n\tif (r)\n\t\tgoto err_ecsci;\n\n\t \n\toutl(CS5536_GPIOM6_PME_EN | CS5536_GPIOM7_PME_EN,\n\t\tacpi_base + CS5536_PM_GPE0_EN);\n\n\t \n\toutl(0xffffffff, acpi_base + CS5536_PM_GPE0_STS);\n\tprocess_sci_queue(false);\n\n\t \n\tsend_ebook_state();\n\tdetect_lid_state();\n\tsend_lid_state();\n\n\tr = setup_sci_interrupt(pdev);\n\tif (r)\n\t\tgoto err_sci;\n\n\t \n\tolpc_ec_mask_write(EC_SCI_SRC_ALL);\n\n\treturn r;\n\nerr_sci:\n\tfree_ec_sci();\nerr_ecsci:\n\tfree_lid_events();\nerr_lidevt:\n\tfree_lid_switch();\nerr_lid:\n\tfree_ebook_switch();\nerr_ebook:\n\tfree_power_button();\n\treturn r;\n}\n\nstatic int xo1_sci_remove(struct platform_device *pdev)\n{\n\tfree_irq(sci_irq, pdev);\n\tcancel_work_sync(&sci_work);\n\tfree_ec_sci();\n\tfree_lid_events();\n\tfree_lid_switch();\n\tfree_ebook_switch();\n\tfree_power_button();\n\tacpi_base = 0;\n\treturn 0;\n}\n\nstatic struct platform_driver xo1_sci_driver = {\n\t.driver = {\n\t\t.name = \"olpc-xo1-sci-acpi\",\n\t\t.dev_groups = lid_groups,\n\t},\n\t.probe = xo1_sci_probe,\n\t.remove = xo1_sci_remove,\n\t.suspend = xo1_sci_suspend,\n\t.resume = xo1_sci_resume,\n};\n\nstatic int __init xo1_sci_init(void)\n{\n\treturn platform_driver_register(&xo1_sci_driver);\n}\narch_initcall(xo1_sci_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}