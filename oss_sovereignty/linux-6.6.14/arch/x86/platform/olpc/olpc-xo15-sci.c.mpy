{
  "module_name": "olpc-xo15-sci.c",
  "hash_id": "4f3175b440e0cca1328900c66ce28fe52546a1cb23aa1a6b58370852c3412f84",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/olpc/olpc-xo15-sci.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/power_supply.h>\n#include <linux/olpc-ec.h>\n\n#include <linux/acpi.h>\n#include <asm/olpc.h>\n\n#define DRV_NAME\t\t\t\"olpc-xo15-sci\"\n#define PFX\t\t\t\tDRV_NAME \": \"\n#define XO15_SCI_CLASS\t\t\tDRV_NAME\n#define XO15_SCI_DEVICE_NAME\t\t\"OLPC XO-1.5 SCI\"\n\nstatic unsigned long\t\t\txo15_sci_gpe;\nstatic bool\t\t\t\tlid_wake_on_close;\n\n \nstatic int set_lid_wake_behavior(bool wake_on_close)\n{\n\tacpi_status status;\n\n\tstatus = acpi_execute_simple_method(NULL, \"\\\\_SB.PCI0.LID.LIDW\", wake_on_close);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_warn(PFX \"failed to set lid behavior\\n\");\n\t\treturn 1;\n\t}\n\n\tlid_wake_on_close = wake_on_close;\n\n\treturn 0;\n}\n\nstatic ssize_t\nlid_wake_on_close_show(struct kobject *s, struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", lid_wake_on_close);\n}\n\nstatic ssize_t lid_wake_on_close_store(struct kobject *s,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       const char *buf, size_t n)\n{\n\tunsigned int val;\n\n\tif (sscanf(buf, \"%u\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tset_lid_wake_behavior(!!val);\n\n\treturn n;\n}\n\nstatic struct kobj_attribute lid_wake_on_close_attr =\n\t__ATTR(lid_wake_on_close, 0644,\n\t       lid_wake_on_close_show,\n\t       lid_wake_on_close_store);\n\nstatic void battery_status_changed(void)\n{\n\tstruct power_supply *psy = power_supply_get_by_name(\"olpc_battery\");\n\n\tif (psy) {\n\t\tpower_supply_changed(psy);\n\t\tpower_supply_put(psy);\n\t}\n}\n\nstatic void ac_status_changed(void)\n{\n\tstruct power_supply *psy = power_supply_get_by_name(\"olpc_ac\");\n\n\tif (psy) {\n\t\tpower_supply_changed(psy);\n\t\tpower_supply_put(psy);\n\t}\n}\n\nstatic void process_sci_queue(void)\n{\n\tu16 data;\n\tint r;\n\n\tdo {\n\t\tr = olpc_ec_sci_query(&data);\n\t\tif (r || !data)\n\t\t\tbreak;\n\n\t\tpr_debug(PFX \"SCI 0x%x received\\n\", data);\n\n\t\tswitch (data) {\n\t\tcase EC_SCI_SRC_BATERR:\n\t\tcase EC_SCI_SRC_BATSOC:\n\t\tcase EC_SCI_SRC_BATTERY:\n\t\tcase EC_SCI_SRC_BATCRIT:\n\t\t\tbattery_status_changed();\n\t\t\tbreak;\n\t\tcase EC_SCI_SRC_ACPWR:\n\t\t\tac_status_changed();\n\t\t\tbreak;\n\t\t}\n\t} while (data);\n\n\tif (r)\n\t\tpr_err(PFX \"Failed to clear SCI queue\");\n}\n\nstatic void process_sci_queue_work(struct work_struct *work)\n{\n\tprocess_sci_queue();\n}\n\nstatic DECLARE_WORK(sci_work, process_sci_queue_work);\n\nstatic u32 xo15_sci_gpe_handler(acpi_handle gpe_device, u32 gpe, void *context)\n{\n\tschedule_work(&sci_work);\n\treturn ACPI_INTERRUPT_HANDLED | ACPI_REENABLE_GPE;\n}\n\nstatic int xo15_sci_add(struct acpi_device *device)\n{\n\tunsigned long long tmp;\n\tacpi_status status;\n\tint r;\n\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tstrcpy(acpi_device_name(device), XO15_SCI_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), XO15_SCI_CLASS);\n\n\t \n\tstatus = acpi_evaluate_integer(device->handle, \"_GPE\", NULL, &tmp);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EINVAL;\n\n\txo15_sci_gpe = tmp;\n\tstatus = acpi_install_gpe_handler(NULL, xo15_sci_gpe,\n\t\t\t\t\t  ACPI_GPE_EDGE_TRIGGERED,\n\t\t\t\t\t  xo15_sci_gpe_handler, device);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tdev_info(&device->dev, \"Initialized, GPE = 0x%lx\\n\", xo15_sci_gpe);\n\n\tr = sysfs_create_file(&device->dev.kobj, &lid_wake_on_close_attr.attr);\n\tif (r)\n\t\tgoto err_sysfs;\n\n\t \n\tprocess_sci_queue();\n\tolpc_ec_mask_write(EC_SCI_SRC_ALL);\n\n\tacpi_enable_gpe(NULL, xo15_sci_gpe);\n\n\t \n\tif (device->wakeup.flags.valid)\n\t\tdevice_init_wakeup(&device->dev, true);\n\n\treturn 0;\n\nerr_sysfs:\n\tacpi_remove_gpe_handler(NULL, xo15_sci_gpe, xo15_sci_gpe_handler);\n\tcancel_work_sync(&sci_work);\n\treturn r;\n}\n\nstatic void xo15_sci_remove(struct acpi_device *device)\n{\n\tacpi_disable_gpe(NULL, xo15_sci_gpe);\n\tacpi_remove_gpe_handler(NULL, xo15_sci_gpe, xo15_sci_gpe_handler);\n\tcancel_work_sync(&sci_work);\n\tsysfs_remove_file(&device->dev.kobj, &lid_wake_on_close_attr.attr);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int xo15_sci_resume(struct device *dev)\n{\n\t \n\tolpc_ec_mask_write(EC_SCI_SRC_ALL);\n\n\t \n\tbattery_status_changed();\n\tac_status_changed();\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(xo15_sci_pm, NULL, xo15_sci_resume);\n\nstatic const struct acpi_device_id xo15_sci_device_ids[] = {\n\t{\"XO15EC\", 0},\n\t{\"\", 0},\n};\n\nstatic struct acpi_driver xo15_sci_drv = {\n\t.name = DRV_NAME,\n\t.class = XO15_SCI_CLASS,\n\t.ids = xo15_sci_device_ids,\n\t.ops = {\n\t\t.add = xo15_sci_add,\n\t\t.remove = xo15_sci_remove,\n\t},\n\t.drv.pm = &xo15_sci_pm,\n};\n\nstatic int __init xo15_sci_init(void)\n{\n\treturn acpi_bus_register_driver(&xo15_sci_drv);\n}\ndevice_initcall(xo15_sci_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}