{
  "module_name": "net5501.c",
  "hash_id": "f107233345fdb9ad5dca8373be0166a6c54665ba7f2f10788ec6fd7d0f05f9c8",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/geode/net5501.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/string.h>\n#include <linux/leds.h>\n#include <linux/platform_device.h>\n#include <linux/input.h>\n#include <linux/gpio_keys.h>\n#include <linux/gpio/machine.h>\n\n#include <asm/geode.h>\n\n#define BIOS_REGION_BASE\t\t0xffff0000\n#define BIOS_REGION_SIZE\t\t0x00010000\n\nstatic struct gpio_keys_button net5501_gpio_buttons[] = {\n\t{\n\t\t.code = KEY_RESTART,\n\t\t.gpio = 24,\n\t\t.active_low = 1,\n\t\t.desc = \"Reset button\",\n\t\t.type = EV_KEY,\n\t\t.wakeup = 0,\n\t\t.debounce_interval = 100,\n\t\t.can_disable = 0,\n\t}\n};\nstatic struct gpio_keys_platform_data net5501_buttons_data = {\n\t.buttons = net5501_gpio_buttons,\n\t.nbuttons = ARRAY_SIZE(net5501_gpio_buttons),\n\t.poll_interval = 20,\n};\n\nstatic struct platform_device net5501_buttons_dev = {\n\t.name = \"gpio-keys-polled\",\n\t.id = 1,\n\t.dev = {\n\t\t.platform_data = &net5501_buttons_data,\n\t}\n};\n\nstatic struct gpio_led net5501_leds[] = {\n\t{\n\t\t.name = \"net5501:1\",\n\t\t.default_trigger = \"default-on\",\n\t},\n};\n\nstatic struct gpio_led_platform_data net5501_leds_data = {\n\t.num_leds = ARRAY_SIZE(net5501_leds),\n\t.leds = net5501_leds,\n};\n\nstatic struct gpiod_lookup_table net5501_leds_gpio_table = {\n\t.dev_id = \"leds-gpio\",\n\t.table = {\n\t\t \n\t\tGPIO_LOOKUP_IDX(\"cs5535-gpio\", 6, NULL, 0, GPIO_ACTIVE_HIGH),\n\t\t{ }\n\t},\n};\n\nstatic struct platform_device net5501_leds_dev = {\n\t.name = \"leds-gpio\",\n\t.id = -1,\n\t.dev.platform_data = &net5501_leds_data,\n};\n\nstatic struct platform_device *net5501_devs[] __initdata = {\n\t&net5501_buttons_dev,\n\t&net5501_leds_dev,\n};\n\nstatic void __init register_net5501(void)\n{\n\t \n\tgpiod_add_lookup_table(&net5501_leds_gpio_table);\n\tplatform_add_devices(net5501_devs, ARRAY_SIZE(net5501_devs));\n}\n\nstruct net5501_board {\n\tu16\toffset;\n\tu16\tlen;\n\tchar\t*sig;\n};\n\nstatic struct net5501_board __initdata boards[] = {\n\t{ 0xb7b, 7, \"net5501\" },\t \n\t{ 0xb1f, 7, \"net5501\" },\t \n};\n\nstatic bool __init net5501_present(void)\n{\n\tint i;\n\tunsigned char *rombase, *bios;\n\tbool found = false;\n\n\trombase = ioremap(BIOS_REGION_BASE, BIOS_REGION_SIZE - 1);\n\tif (!rombase) {\n\t\tprintk(KERN_ERR \"%s: failed to get rombase\\n\", KBUILD_MODNAME);\n\t\treturn found;\n\t}\n\n\tbios = rombase + 0x20;\t \n\n\tif (memcmp(bios, \"comBIOS\", 7))\n\t\tgoto unmap;\n\n\tfor (i = 0; i < ARRAY_SIZE(boards); i++) {\n\t\tunsigned char *model = rombase + boards[i].offset;\n\n\t\tif (!memcmp(model, boards[i].sig, boards[i].len)) {\n\t\t\tprintk(KERN_INFO \"%s: system is recognized as \\\"%s\\\"\\n\",\n\t\t\t       KBUILD_MODNAME, model);\n\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\nunmap:\n\tiounmap(rombase);\n\treturn found;\n}\n\nstatic int __init net5501_init(void)\n{\n\tif (!is_geode())\n\t\treturn 0;\n\n\tif (!net5501_present())\n\t\treturn 0;\n\n\tregister_net5501();\n\n\treturn 0;\n}\ndevice_initcall(net5501_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}