{
  "module_name": "scx200_32.c",
  "hash_id": "257ed78445bab38d9f7ebcd545b8be96bef096282f6b80c3568193b827d07293",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/scx200/scx200_32.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n\n#include <linux/scx200.h>\n#include <linux/scx200_gpio.h>\n\n \n#define scx200_cb_probe(base) (inw((base) + SCx200_CBA) == (base))\n\nMODULE_AUTHOR(\"Christer Weinigel <wingel@nano-system.com>\");\nMODULE_DESCRIPTION(\"NatSemi SCx200 Driver\");\nMODULE_LICENSE(\"GPL\");\n\nunsigned scx200_gpio_base = 0;\nunsigned long scx200_gpio_shadow[2];\n\nunsigned scx200_cb_base = 0;\n\nstatic struct pci_device_id scx200_tbl[] = {\n\t{ PCI_VDEVICE(NS, PCI_DEVICE_ID_NS_SCx200_BRIDGE) },\n\t{ PCI_VDEVICE(NS, PCI_DEVICE_ID_NS_SC1100_BRIDGE) },\n\t{ PCI_VDEVICE(NS, PCI_DEVICE_ID_NS_SCx200_XBUS)   },\n\t{ PCI_VDEVICE(NS, PCI_DEVICE_ID_NS_SC1100_XBUS)   },\n\t{ },\n};\nMODULE_DEVICE_TABLE(pci,scx200_tbl);\n\nstatic int scx200_probe(struct pci_dev *, const struct pci_device_id *);\n\nstatic struct pci_driver scx200_pci_driver = {\n\t.name = \"scx200\",\n\t.id_table = scx200_tbl,\n\t.probe = scx200_probe,\n};\n\nstatic DEFINE_MUTEX(scx200_gpio_config_lock);\n\nstatic void scx200_init_shadow(void)\n{\n\tint bank;\n\n\t \n\tfor (bank = 0; bank < 2; ++bank)\n\t\tscx200_gpio_shadow[bank] = inl(scx200_gpio_base + 0x10 * bank);\n}\n\nstatic int scx200_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tunsigned base;\n\n\tif (pdev->device == PCI_DEVICE_ID_NS_SCx200_BRIDGE ||\n\t    pdev->device == PCI_DEVICE_ID_NS_SC1100_BRIDGE) {\n\t\tbase = pci_resource_start(pdev, 0);\n\t\tpr_info(\"GPIO base 0x%x\\n\", base);\n\n\t\tif (!request_region(base, SCx200_GPIO_SIZE,\n\t\t\t\t    \"NatSemi SCx200 GPIO\")) {\n\t\t\tpr_err(\"can't allocate I/O for GPIOs\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tscx200_gpio_base = base;\n\t\tscx200_init_shadow();\n\n\t} else {\n\t\t \n\t\tif (scx200_cb_probe(SCx200_CB_BASE_FIXED)) {\n\t\t\tscx200_cb_base = SCx200_CB_BASE_FIXED;\n\t\t} else {\n\t\t\tpci_read_config_dword(pdev, SCx200_CBA_SCRATCH, &base);\n\t\t\tif (scx200_cb_probe(base)) {\n\t\t\t\tscx200_cb_base = base;\n\t\t\t} else {\n\t\t\t\tpr_warn(\"Configuration Block not found\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\t\tpr_info(\"Configuration Block base 0x%x\\n\", scx200_cb_base);\n\t}\n\n\treturn 0;\n}\n\nu32 scx200_gpio_configure(unsigned index, u32 mask, u32 bits)\n{\n\tu32 config, new_config;\n\n\tmutex_lock(&scx200_gpio_config_lock);\n\n\toutl(index, scx200_gpio_base + 0x20);\n\tconfig = inl(scx200_gpio_base + 0x24);\n\n\tnew_config = (config & mask) | bits;\n\toutl(new_config, scx200_gpio_base + 0x24);\n\n\tmutex_unlock(&scx200_gpio_config_lock);\n\n\treturn config;\n}\n\nstatic int __init scx200_init(void)\n{\n\tpr_info(\"NatSemi SCx200 Driver\\n\");\n\treturn pci_register_driver(&scx200_pci_driver);\n}\n\nstatic void __exit scx200_cleanup(void)\n{\n\tpci_unregister_driver(&scx200_pci_driver);\n\trelease_region(scx200_gpio_base, SCx200_GPIO_SIZE);\n}\n\nmodule_init(scx200_init);\nmodule_exit(scx200_cleanup);\n\nEXPORT_SYMBOL(scx200_gpio_base);\nEXPORT_SYMBOL(scx200_gpio_shadow);\nEXPORT_SYMBOL(scx200_gpio_configure);\nEXPORT_SYMBOL(scx200_cb_base);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}