{
  "module_name": "runtime-map.c",
  "hash_id": "07d936a438588c225718644e4fd28327be8539bdc5aa6baae63fbca2e4eb484b",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/efi/runtime-map.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/efi.h>\n#include <linux/slab.h>\n\n#include <asm/efi.h>\n#include <asm/setup.h>\n\nstruct efi_runtime_map_entry {\n\tefi_memory_desc_t md;\n\tstruct kobject kobj;    \n};\n\nstatic struct efi_runtime_map_entry **map_entries;\n\nstruct map_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct efi_runtime_map_entry *entry, char *buf);\n};\n\nstatic inline struct map_attribute *to_map_attr(struct attribute *attr)\n{\n\treturn container_of(attr, struct map_attribute, attr);\n}\n\nstatic ssize_t type_show(struct efi_runtime_map_entry *entry, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"0x%x\\n\", entry->md.type);\n}\n\n#define EFI_RUNTIME_FIELD(var) entry->md.var\n\n#define EFI_RUNTIME_U64_ATTR_SHOW(name) \\\nstatic ssize_t name##_show(struct efi_runtime_map_entry *entry, char *buf) \\\n{ \\\n\treturn snprintf(buf, PAGE_SIZE, \"0x%llx\\n\", EFI_RUNTIME_FIELD(name)); \\\n}\n\nEFI_RUNTIME_U64_ATTR_SHOW(phys_addr);\nEFI_RUNTIME_U64_ATTR_SHOW(virt_addr);\nEFI_RUNTIME_U64_ATTR_SHOW(num_pages);\nEFI_RUNTIME_U64_ATTR_SHOW(attribute);\n\nstatic inline struct efi_runtime_map_entry *to_map_entry(struct kobject *kobj)\n{\n\treturn container_of(kobj, struct efi_runtime_map_entry, kobj);\n}\n\nstatic ssize_t map_attr_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct efi_runtime_map_entry *entry = to_map_entry(kobj);\n\tstruct map_attribute *map_attr = to_map_attr(attr);\n\n\treturn map_attr->show(entry, buf);\n}\n\nstatic struct map_attribute map_type_attr = __ATTR_RO_MODE(type, 0400);\nstatic struct map_attribute map_phys_addr_attr = __ATTR_RO_MODE(phys_addr, 0400);\nstatic struct map_attribute map_virt_addr_attr = __ATTR_RO_MODE(virt_addr, 0400);\nstatic struct map_attribute map_num_pages_attr = __ATTR_RO_MODE(num_pages, 0400);\nstatic struct map_attribute map_attribute_attr = __ATTR_RO_MODE(attribute, 0400);\n\n \nstatic struct attribute *def_attrs[] = {\n\t&map_type_attr.attr,\n\t&map_phys_addr_attr.attr,\n\t&map_virt_addr_attr.attr,\n\t&map_num_pages_attr.attr,\n\t&map_attribute_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(def);\n\nstatic const struct sysfs_ops map_attr_ops = {\n\t.show = map_attr_show,\n};\n\nstatic void map_release(struct kobject *kobj)\n{\n\tstruct efi_runtime_map_entry *entry;\n\n\tentry = to_map_entry(kobj);\n\tkfree(entry);\n}\n\nstatic const struct kobj_type __refconst map_ktype = {\n\t.sysfs_ops\t= &map_attr_ops,\n\t.default_groups\t= def_groups,\n\t.release\t= map_release,\n};\n\nstatic struct kset *map_kset;\n\nstatic struct efi_runtime_map_entry *\nadd_sysfs_runtime_map_entry(struct kobject *kobj, int nr,\n\t\t\t    efi_memory_desc_t *md)\n{\n\tint ret;\n\tstruct efi_runtime_map_entry *entry;\n\n\tif (!map_kset) {\n\t\tmap_kset = kset_create_and_add(\"runtime-map\", NULL, kobj);\n\t\tif (!map_kset)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\tkset_unregister(map_kset);\n\t\tmap_kset = NULL;\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tmemcpy(&entry->md, md, sizeof(efi_memory_desc_t));\n\n\tkobject_init(&entry->kobj, &map_ktype);\n\tentry->kobj.kset = map_kset;\n\tret = kobject_add(&entry->kobj, NULL, \"%d\", nr);\n\tif (ret) {\n\t\tkobject_put(&entry->kobj);\n\t\tkset_unregister(map_kset);\n\t\tmap_kset = NULL;\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn entry;\n}\n\nint efi_get_runtime_map_size(void)\n{\n\treturn efi.memmap.nr_map * efi.memmap.desc_size;\n}\n\nint efi_get_runtime_map_desc_size(void)\n{\n\treturn efi.memmap.desc_size;\n}\n\nint efi_runtime_map_copy(void *buf, size_t bufsz)\n{\n\tsize_t sz = efi_get_runtime_map_size();\n\n\tif (sz > bufsz)\n\t\tsz = bufsz;\n\n\tmemcpy(buf, efi.memmap.map, sz);\n\treturn 0;\n}\n\nstatic int __init efi_runtime_map_init(void)\n{\n\tint i, j, ret = 0;\n\tstruct efi_runtime_map_entry *entry;\n\tefi_memory_desc_t *md;\n\n\tif (!efi_enabled(EFI_MEMMAP) || !efi_kobj)\n\t\treturn 0;\n\n\tmap_entries = kcalloc(efi.memmap.nr_map, sizeof(entry), GFP_KERNEL);\n\tif (!map_entries) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ti = 0;\n\tfor_each_efi_memory_desc(md) {\n\t\tentry = add_sysfs_runtime_map_entry(efi_kobj, i, md);\n\t\tif (IS_ERR(entry)) {\n\t\t\tret = PTR_ERR(entry);\n\t\t\tgoto out_add_entry;\n\t\t}\n\t\t*(map_entries + i++) = entry;\n\t}\n\n\treturn 0;\nout_add_entry:\n\tfor (j = i - 1; j >= 0; j--) {\n\t\tentry = *(map_entries + j);\n\t\tkobject_put(&entry->kobj);\n\t}\nout:\n\treturn ret;\n}\nsubsys_initcall_sync(efi_runtime_map_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}