{
  "module_name": "efi.c",
  "hash_id": "f893504dabe09211250492411b72c75d9b21eb0b380ffa6bdf8aae9d616ad31c",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/efi/efi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/efi.h>\n#include <linux/efi-bgrt.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/io.h>\n#include <linux/reboot.h>\n#include <linux/bcd.h>\n\n#include <asm/setup.h>\n#include <asm/efi.h>\n#include <asm/e820/api.h>\n#include <asm/time.h>\n#include <asm/tlbflush.h>\n#include <asm/x86_init.h>\n#include <asm/uv/uv.h>\n\nstatic unsigned long efi_systab_phys __initdata;\nstatic unsigned long prop_phys = EFI_INVALID_TABLE_ADDR;\nstatic unsigned long uga_phys = EFI_INVALID_TABLE_ADDR;\nstatic unsigned long efi_runtime, efi_nr_tables;\n\nunsigned long efi_fw_vendor, efi_config_table;\n\nstatic const efi_config_table_type_t arch_tables[] __initconst = {\n\t{EFI_PROPERTIES_TABLE_GUID,\t&prop_phys,\t\t\"PROP\"\t\t},\n\t{UGA_IO_PROTOCOL_GUID,\t\t&uga_phys,\t\t\"UGA\"\t\t},\n#ifdef CONFIG_X86_UV\n\t{UV_SYSTEM_TABLE_GUID,\t\t&uv_systab_phys,\t\"UVsystab\"\t},\n#endif\n\t{},\n};\n\nstatic const unsigned long * const efi_tables[] = {\n\t&efi.acpi,\n\t&efi.acpi20,\n\t&efi.smbios,\n\t&efi.smbios3,\n\t&uga_phys,\n#ifdef CONFIG_X86_UV\n\t&uv_systab_phys,\n#endif\n\t&efi_fw_vendor,\n\t&efi_runtime,\n\t&efi_config_table,\n\t&efi.esrt,\n\t&prop_phys,\n\t&efi_mem_attr_table,\n#ifdef CONFIG_EFI_RCI2_TABLE\n\t&rci2_table_phys,\n#endif\n\t&efi.tpm_log,\n\t&efi.tpm_final_log,\n\t&efi_rng_seed,\n#ifdef CONFIG_LOAD_UEFI_KEYS\n\t&efi.mokvar_table,\n#endif\n#ifdef CONFIG_EFI_COCO_SECRET\n\t&efi.coco_secret,\n#endif\n#ifdef CONFIG_UNACCEPTED_MEMORY\n\t&efi.unaccepted,\n#endif\n};\n\nu64 efi_setup;\t\t \n\nstatic int add_efi_memmap __initdata;\nstatic int __init setup_add_efi_memmap(char *arg)\n{\n\tadd_efi_memmap = 1;\n\treturn 0;\n}\nearly_param(\"add_efi_memmap\", setup_add_efi_memmap);\n\n \n\nstatic void __init do_add_efi_memmap(void)\n{\n\tefi_memory_desc_t *md;\n\n\tif (!efi_enabled(EFI_MEMMAP))\n\t\treturn;\n\n\tfor_each_efi_memory_desc(md) {\n\t\tunsigned long long start = md->phys_addr;\n\t\tunsigned long long size = md->num_pages << EFI_PAGE_SHIFT;\n\t\tint e820_type;\n\n\t\tswitch (md->type) {\n\t\tcase EFI_LOADER_CODE:\n\t\tcase EFI_LOADER_DATA:\n\t\tcase EFI_BOOT_SERVICES_CODE:\n\t\tcase EFI_BOOT_SERVICES_DATA:\n\t\tcase EFI_CONVENTIONAL_MEMORY:\n\t\t\tif (efi_soft_reserve_enabled()\n\t\t\t    && (md->attribute & EFI_MEMORY_SP))\n\t\t\t\te820_type = E820_TYPE_SOFT_RESERVED;\n\t\t\telse if (md->attribute & EFI_MEMORY_WB)\n\t\t\t\te820_type = E820_TYPE_RAM;\n\t\t\telse\n\t\t\t\te820_type = E820_TYPE_RESERVED;\n\t\t\tbreak;\n\t\tcase EFI_ACPI_RECLAIM_MEMORY:\n\t\t\te820_type = E820_TYPE_ACPI;\n\t\t\tbreak;\n\t\tcase EFI_ACPI_MEMORY_NVS:\n\t\t\te820_type = E820_TYPE_NVS;\n\t\t\tbreak;\n\t\tcase EFI_UNUSABLE_MEMORY:\n\t\t\te820_type = E820_TYPE_UNUSABLE;\n\t\t\tbreak;\n\t\tcase EFI_PERSISTENT_MEMORY:\n\t\t\te820_type = E820_TYPE_PMEM;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\te820_type = E820_TYPE_RESERVED;\n\t\t\tbreak;\n\t\t}\n\n\t\te820__range_add(start, size, e820_type);\n\t}\n\te820__update_table(e820_table);\n}\n\n \nstatic bool do_efi_soft_reserve(void)\n{\n\tefi_memory_desc_t *md;\n\n\tif (!efi_enabled(EFI_MEMMAP))\n\t\treturn false;\n\n\tif (!efi_soft_reserve_enabled())\n\t\treturn false;\n\n\tfor_each_efi_memory_desc(md)\n\t\tif (md->type == EFI_CONVENTIONAL_MEMORY &&\n\t\t    (md->attribute & EFI_MEMORY_SP))\n\t\t\treturn true;\n\treturn false;\n}\n\nint __init efi_memblock_x86_reserve_range(void)\n{\n\tstruct efi_info *e = &boot_params.efi_info;\n\tstruct efi_memory_map_data data;\n\tphys_addr_t pmap;\n\tint rv;\n\n\tif (efi_enabled(EFI_PARAVIRT))\n\t\treturn 0;\n\n\t \n\tif (IS_ENABLED(CONFIG_X86_32) && e->efi_memmap_hi > 0) {\n\t\tpr_err(\"Memory map is above 4GB, disabling EFI.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpmap = (phys_addr_t)(e->efi_memmap | ((u64)e->efi_memmap_hi << 32));\n\n\tdata.phys_map\t\t= pmap;\n\tdata.size \t\t= e->efi_memmap_size;\n\tdata.desc_size\t\t= e->efi_memdesc_size;\n\tdata.desc_version\t= e->efi_memdesc_version;\n\n\tif (!efi_enabled(EFI_PARAVIRT)) {\n\t\trv = efi_memmap_init_early(&data);\n\t\tif (rv)\n\t\t\treturn rv;\n\t}\n\n\tif (add_efi_memmap || do_efi_soft_reserve())\n\t\tdo_add_efi_memmap();\n\n\tefi_fake_memmap_early();\n\n\tWARN(efi.memmap.desc_version != 1,\n\t     \"Unexpected EFI_MEMORY_DESCRIPTOR version %ld\",\n\t     efi.memmap.desc_version);\n\n\tmemblock_reserve(pmap, efi.memmap.nr_map * efi.memmap.desc_size);\n\tset_bit(EFI_PRESERVE_BS_REGIONS, &efi.flags);\n\n\treturn 0;\n}\n\n#define OVERFLOW_ADDR_SHIFT\t(64 - EFI_PAGE_SHIFT)\n#define OVERFLOW_ADDR_MASK\t(U64_MAX << OVERFLOW_ADDR_SHIFT)\n#define U64_HIGH_BIT\t\t(~(U64_MAX >> 1))\n\nstatic bool __init efi_memmap_entry_valid(const efi_memory_desc_t *md, int i)\n{\n\tu64 end = (md->num_pages << EFI_PAGE_SHIFT) + md->phys_addr - 1;\n\tu64 end_hi = 0;\n\tchar buf[64];\n\n\tif (md->num_pages == 0) {\n\t\tend = 0;\n\t} else if (md->num_pages > EFI_PAGES_MAX ||\n\t\t   EFI_PAGES_MAX - md->num_pages <\n\t\t   (md->phys_addr >> EFI_PAGE_SHIFT)) {\n\t\tend_hi = (md->num_pages & OVERFLOW_ADDR_MASK)\n\t\t\t>> OVERFLOW_ADDR_SHIFT;\n\n\t\tif ((md->phys_addr & U64_HIGH_BIT) && !(end & U64_HIGH_BIT))\n\t\t\tend_hi += 1;\n\t} else {\n\t\treturn true;\n\t}\n\n\tpr_warn_once(FW_BUG \"Invalid EFI memory map entries:\\n\");\n\n\tif (end_hi) {\n\t\tpr_warn(\"mem%02u: %s range=[0x%016llx-0x%llx%016llx] (invalid)\\n\",\n\t\t\ti, efi_md_typeattr_format(buf, sizeof(buf), md),\n\t\t\tmd->phys_addr, end_hi, end);\n\t} else {\n\t\tpr_warn(\"mem%02u: %s range=[0x%016llx-0x%016llx] (invalid)\\n\",\n\t\t\ti, efi_md_typeattr_format(buf, sizeof(buf), md),\n\t\t\tmd->phys_addr, end);\n\t}\n\treturn false;\n}\n\nstatic void __init efi_clean_memmap(void)\n{\n\tefi_memory_desc_t *out = efi.memmap.map;\n\tconst efi_memory_desc_t *in = out;\n\tconst efi_memory_desc_t *end = efi.memmap.map_end;\n\tint i, n_removal;\n\n\tfor (i = n_removal = 0; in < end; i++) {\n\t\tif (efi_memmap_entry_valid(in, i)) {\n\t\t\tif (out != in)\n\t\t\t\tmemcpy(out, in, efi.memmap.desc_size);\n\t\t\tout = (void *)out + efi.memmap.desc_size;\n\t\t} else {\n\t\t\tn_removal++;\n\t\t}\n\t\tin = (void *)in + efi.memmap.desc_size;\n\t}\n\n\tif (n_removal > 0) {\n\t\tstruct efi_memory_map_data data = {\n\t\t\t.phys_map\t= efi.memmap.phys_map,\n\t\t\t.desc_version\t= efi.memmap.desc_version,\n\t\t\t.desc_size\t= efi.memmap.desc_size,\n\t\t\t.size\t\t= efi.memmap.desc_size * (efi.memmap.nr_map - n_removal),\n\t\t\t.flags\t\t= 0,\n\t\t};\n\n\t\tpr_warn(\"Removing %d invalid memory map entries.\\n\", n_removal);\n\t\tefi_memmap_install(&data);\n\t}\n}\n\n \nstatic void __init efi_remove_e820_mmio(void)\n{\n\tefi_memory_desc_t *md;\n\tu64 size, start, end;\n\tint i = 0;\n\n\tfor_each_efi_memory_desc(md) {\n\t\tif (md->type == EFI_MEMORY_MAPPED_IO) {\n\t\t\tsize = md->num_pages << EFI_PAGE_SHIFT;\n\t\t\tstart = md->phys_addr;\n\t\t\tend = start + size - 1;\n\t\t\tif (size >= 256*1024) {\n\t\t\t\tpr_info(\"Remove mem%02u: MMIO range=[0x%08llx-0x%08llx] (%lluMB) from e820 map\\n\",\n\t\t\t\t\ti, start, end, size >> 20);\n\t\t\t\te820__range_remove(start, size,\n\t\t\t\t\t\t   E820_TYPE_RESERVED, 1);\n\t\t\t} else {\n\t\t\t\tpr_info(\"Not removing mem%02u: MMIO range=[0x%08llx-0x%08llx] (%lluKB) from e820 map\\n\",\n\t\t\t\t\ti, start, end, size >> 10);\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n}\n\nvoid __init efi_print_memmap(void)\n{\n\tefi_memory_desc_t *md;\n\tint i = 0;\n\n\tfor_each_efi_memory_desc(md) {\n\t\tchar buf[64];\n\n\t\tpr_info(\"mem%02u: %s range=[0x%016llx-0x%016llx] (%lluMB)\\n\",\n\t\t\ti++, efi_md_typeattr_format(buf, sizeof(buf), md),\n\t\t\tmd->phys_addr,\n\t\t\tmd->phys_addr + (md->num_pages << EFI_PAGE_SHIFT) - 1,\n\t\t\t(md->num_pages >> (20 - EFI_PAGE_SHIFT)));\n\t}\n}\n\nstatic int __init efi_systab_init(unsigned long phys)\n{\n\tint size = efi_enabled(EFI_64BIT) ? sizeof(efi_system_table_64_t)\n\t\t\t\t\t  : sizeof(efi_system_table_32_t);\n\tconst efi_table_hdr_t *hdr;\n\tbool over4g = false;\n\tvoid *p;\n\tint ret;\n\n\thdr = p = early_memremap_ro(phys, size);\n\tif (p == NULL) {\n\t\tpr_err(\"Couldn't map the system table!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = efi_systab_check_header(hdr);\n\tif (ret) {\n\t\tearly_memunmap(p, size);\n\t\treturn ret;\n\t}\n\n\tif (efi_enabled(EFI_64BIT)) {\n\t\tconst efi_system_table_64_t *systab64 = p;\n\n\t\tefi_runtime\t= systab64->runtime;\n\t\tover4g\t\t= systab64->runtime > U32_MAX;\n\n\t\tif (efi_setup) {\n\t\t\tstruct efi_setup_data *data;\n\n\t\t\tdata = early_memremap_ro(efi_setup, sizeof(*data));\n\t\t\tif (!data) {\n\t\t\t\tearly_memunmap(p, size);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tefi_fw_vendor\t\t= (unsigned long)data->fw_vendor;\n\t\t\tefi_config_table\t= (unsigned long)data->tables;\n\n\t\t\tover4g |= data->fw_vendor\t> U32_MAX ||\n\t\t\t\t  data->tables\t\t> U32_MAX;\n\n\t\t\tearly_memunmap(data, sizeof(*data));\n\t\t} else {\n\t\t\tefi_fw_vendor\t\t= systab64->fw_vendor;\n\t\t\tefi_config_table\t= systab64->tables;\n\n\t\t\tover4g |= systab64->fw_vendor\t> U32_MAX ||\n\t\t\t\t  systab64->tables\t> U32_MAX;\n\t\t}\n\t\tefi_nr_tables = systab64->nr_tables;\n\t} else {\n\t\tconst efi_system_table_32_t *systab32 = p;\n\n\t\tefi_fw_vendor\t\t= systab32->fw_vendor;\n\t\tefi_runtime\t\t= systab32->runtime;\n\t\tefi_config_table\t= systab32->tables;\n\t\tefi_nr_tables\t\t= systab32->nr_tables;\n\t}\n\n\tefi.runtime_version = hdr->revision;\n\n\tefi_systab_report_header(hdr, efi_fw_vendor);\n\tearly_memunmap(p, size);\n\n\tif (IS_ENABLED(CONFIG_X86_32) && over4g) {\n\t\tpr_err(\"EFI data located above 4GB, disabling EFI.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init efi_config_init(const efi_config_table_type_t *arch_tables)\n{\n\tvoid *config_tables;\n\tint sz, ret;\n\n\tif (efi_nr_tables == 0)\n\t\treturn 0;\n\n\tif (efi_enabled(EFI_64BIT))\n\t\tsz = sizeof(efi_config_table_64_t);\n\telse\n\t\tsz = sizeof(efi_config_table_32_t);\n\n\t \n\tconfig_tables = early_memremap(efi_config_table, efi_nr_tables * sz);\n\tif (config_tables == NULL) {\n\t\tpr_err(\"Could not map Configuration table!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = efi_config_parse_tables(config_tables, efi_nr_tables,\n\t\t\t\t      arch_tables);\n\n\tearly_memunmap(config_tables, efi_nr_tables * sz);\n\treturn ret;\n}\n\nvoid __init efi_init(void)\n{\n\tif (IS_ENABLED(CONFIG_X86_32) &&\n\t    (boot_params.efi_info.efi_systab_hi ||\n\t     boot_params.efi_info.efi_memmap_hi)) {\n\t\tpr_info(\"Table located above 4GB, disabling EFI.\\n\");\n\t\treturn;\n\t}\n\n\tefi_systab_phys = boot_params.efi_info.efi_systab |\n\t\t\t  ((__u64)boot_params.efi_info.efi_systab_hi << 32);\n\n\tif (efi_systab_init(efi_systab_phys))\n\t\treturn;\n\n\tif (efi_reuse_config(efi_config_table, efi_nr_tables))\n\t\treturn;\n\n\tif (efi_config_init(arch_tables))\n\t\treturn;\n\n\t \n\n\tif (!efi_runtime_supported())\n\t\tpr_err(\"No EFI runtime due to 32/64-bit mismatch with kernel\\n\");\n\n\tif (!efi_runtime_supported() || efi_runtime_disabled()) {\n\t\tefi_memmap_unmap();\n\t\treturn;\n\t}\n\n\t \n\tif (prop_phys != EFI_INVALID_TABLE_ADDR) {\n\t\tefi_properties_table_t *tbl;\n\n\t\ttbl = early_memremap_ro(prop_phys, sizeof(*tbl));\n\t\tif (tbl == NULL) {\n\t\t\tpr_err(\"Could not map Properties table!\\n\");\n\t\t} else {\n\t\t\tif (tbl->memory_protection_attribute &\n\t\t\t    EFI_PROPERTIES_RUNTIME_MEMORY_PROTECTION_NON_EXECUTABLE_PE_DATA)\n\t\t\t\tset_bit(EFI_NX_PE_DATA, &efi.flags);\n\n\t\t\tearly_memunmap(tbl, sizeof(*tbl));\n\t\t}\n\t}\n\n\tset_bit(EFI_RUNTIME_SERVICES, &efi.flags);\n\tefi_clean_memmap();\n\n\tefi_remove_e820_mmio();\n\n\tif (efi_enabled(EFI_DBG))\n\t\tefi_print_memmap();\n}\n\n \nstatic void __init efi_merge_regions(void)\n{\n\tefi_memory_desc_t *md, *prev_md = NULL;\n\n\tfor_each_efi_memory_desc(md) {\n\t\tu64 prev_size;\n\n\t\tif (!prev_md) {\n\t\t\tprev_md = md;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (prev_md->type != md->type ||\n\t\t    prev_md->attribute != md->attribute) {\n\t\t\tprev_md = md;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprev_size = prev_md->num_pages << EFI_PAGE_SHIFT;\n\n\t\tif (md->phys_addr == (prev_md->phys_addr + prev_size)) {\n\t\t\tprev_md->num_pages += md->num_pages;\n\t\t\tmd->type = EFI_RESERVED_TYPE;\n\t\t\tmd->attribute = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tprev_md = md;\n\t}\n}\n\nstatic void *realloc_pages(void *old_memmap, int old_shift)\n{\n\tvoid *ret;\n\n\tret = (void *)__get_free_pages(GFP_KERNEL, old_shift + 1);\n\tif (!ret)\n\t\tgoto out;\n\n\t \n\tif (!old_memmap)\n\t\treturn ret;\n\n\tmemcpy(ret, old_memmap, PAGE_SIZE << old_shift);\n\nout:\n\tfree_pages((unsigned long)old_memmap, old_shift);\n\treturn ret;\n}\n\n \nstatic inline void *efi_map_next_entry_reverse(void *entry)\n{\n\t \n\tif (!entry)\n\t\treturn efi.memmap.map_end - efi.memmap.desc_size;\n\n\tentry -= efi.memmap.desc_size;\n\tif (entry < efi.memmap.map)\n\t\treturn NULL;\n\n\treturn entry;\n}\n\n \nstatic void *efi_map_next_entry(void *entry)\n{\n\tif (efi_enabled(EFI_64BIT)) {\n\t\t \n\t\treturn efi_map_next_entry_reverse(entry);\n\t}\n\n\t \n\tif (!entry)\n\t\treturn efi.memmap.map;\n\n\tentry += efi.memmap.desc_size;\n\tif (entry >= efi.memmap.map_end)\n\t\treturn NULL;\n\n\treturn entry;\n}\n\nstatic bool should_map_region(efi_memory_desc_t *md)\n{\n\t \n\tif (md->attribute & EFI_MEMORY_RUNTIME)\n\t\treturn true;\n\n\t \n\tif (IS_ENABLED(CONFIG_X86_32))\n\t\treturn false;\n\n\t \n\tif (md->type == EFI_CONVENTIONAL_MEMORY &&\n\t    efi_soft_reserve_enabled() &&\n\t    (md->attribute & EFI_MEMORY_SP))\n\t\treturn false;\n\n\t \n\tif (efi_is_mixed()) {\n\t\tif (md->type == EFI_CONVENTIONAL_MEMORY ||\n\t\t    md->type == EFI_LOADER_DATA ||\n\t\t    md->type == EFI_LOADER_CODE)\n\t\t\treturn true;\n\t}\n\n\t \n\tif (md->type == EFI_BOOT_SERVICES_CODE ||\n\t    md->type == EFI_BOOT_SERVICES_DATA)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void * __init efi_map_regions(int *count, int *pg_shift)\n{\n\tvoid *p, *new_memmap = NULL;\n\tunsigned long left = 0;\n\tunsigned long desc_size;\n\tefi_memory_desc_t *md;\n\n\tdesc_size = efi.memmap.desc_size;\n\n\tp = NULL;\n\twhile ((p = efi_map_next_entry(p))) {\n\t\tmd = p;\n\n\t\tif (!should_map_region(md))\n\t\t\tcontinue;\n\n\t\tefi_map_region(md);\n\n\t\tif (left < desc_size) {\n\t\t\tnew_memmap = realloc_pages(new_memmap, *pg_shift);\n\t\t\tif (!new_memmap)\n\t\t\t\treturn NULL;\n\n\t\t\tleft += PAGE_SIZE << *pg_shift;\n\t\t\t(*pg_shift)++;\n\t\t}\n\n\t\tmemcpy(new_memmap + (*count * desc_size), md, desc_size);\n\n\t\tleft -= desc_size;\n\t\t(*count)++;\n\t}\n\n\treturn new_memmap;\n}\n\nstatic void __init kexec_enter_virtual_mode(void)\n{\n#ifdef CONFIG_KEXEC_CORE\n\tefi_memory_desc_t *md;\n\tunsigned int num_pages;\n\n\t \n\tif (efi_is_mixed()) {\n\t\tefi_memmap_unmap();\n\t\tclear_bit(EFI_RUNTIME_SERVICES, &efi.flags);\n\t\treturn;\n\t}\n\n\tif (efi_alloc_page_tables()) {\n\t\tpr_err(\"Failed to allocate EFI page tables\\n\");\n\t\tclear_bit(EFI_RUNTIME_SERVICES, &efi.flags);\n\t\treturn;\n\t}\n\n\t \n\tfor_each_efi_memory_desc(md)\n\t\tefi_map_region_fixed(md);  \n\n\t \n\tefi_memmap_unmap();\n\n\tif (efi_memmap_init_late(efi.memmap.phys_map,\n\t\t\t\t efi.memmap.desc_size * efi.memmap.nr_map)) {\n\t\tpr_err(\"Failed to remap late EFI memory map\\n\");\n\t\tclear_bit(EFI_RUNTIME_SERVICES, &efi.flags);\n\t\treturn;\n\t}\n\n\tnum_pages = ALIGN(efi.memmap.nr_map * efi.memmap.desc_size, PAGE_SIZE);\n\tnum_pages >>= PAGE_SHIFT;\n\n\tif (efi_setup_page_tables(efi.memmap.phys_map, num_pages)) {\n\t\tclear_bit(EFI_RUNTIME_SERVICES, &efi.flags);\n\t\treturn;\n\t}\n\n\tefi_sync_low_kernel_mappings();\n\tefi_native_runtime_setup();\n#endif\n}\n\n \nstatic void __init __efi_enter_virtual_mode(void)\n{\n\tint count = 0, pg_shift = 0;\n\tvoid *new_memmap = NULL;\n\tefi_status_t status;\n\tunsigned long pa;\n\n\tif (efi_alloc_page_tables()) {\n\t\tpr_err(\"Failed to allocate EFI page tables\\n\");\n\t\tgoto err;\n\t}\n\n\tefi_merge_regions();\n\tnew_memmap = efi_map_regions(&count, &pg_shift);\n\tif (!new_memmap) {\n\t\tpr_err(\"Error reallocating memory, EFI runtime non-functional!\\n\");\n\t\tgoto err;\n\t}\n\n\tpa = __pa(new_memmap);\n\n\t \n\tefi_memmap_unmap();\n\n\tif (efi_memmap_init_late(pa, efi.memmap.desc_size * count)) {\n\t\tpr_err(\"Failed to remap late EFI memory map\\n\");\n\t\tgoto err;\n\t}\n\n\tif (efi_enabled(EFI_DBG)) {\n\t\tpr_info(\"EFI runtime memory map:\\n\");\n\t\tefi_print_memmap();\n\t}\n\n\tif (efi_setup_page_tables(pa, 1 << pg_shift))\n\t\tgoto err;\n\n\tefi_sync_low_kernel_mappings();\n\n\tstatus = efi_set_virtual_address_map(efi.memmap.desc_size * count,\n\t\t\t\t\t     efi.memmap.desc_size,\n\t\t\t\t\t     efi.memmap.desc_version,\n\t\t\t\t\t     (efi_memory_desc_t *)pa,\n\t\t\t\t\t     efi_systab_phys);\n\tif (status != EFI_SUCCESS) {\n\t\tpr_err(\"Unable to switch EFI into virtual mode (status=%lx)!\\n\",\n\t\t       status);\n\t\tgoto err;\n\t}\n\n\tefi_check_for_embedded_firmwares();\n\tefi_free_boot_services();\n\n\tif (!efi_is_mixed())\n\t\tefi_native_runtime_setup();\n\telse\n\t\tefi_thunk_runtime_setup();\n\n\t \n\tefi_runtime_update_mappings();\n\n\t \n\tefi_delete_dummy_variable();\n\treturn;\n\nerr:\n\tclear_bit(EFI_RUNTIME_SERVICES, &efi.flags);\n}\n\nvoid __init efi_enter_virtual_mode(void)\n{\n\tif (efi_enabled(EFI_PARAVIRT))\n\t\treturn;\n\n\tefi.runtime = (efi_runtime_services_t *)efi_runtime;\n\n\tif (efi_setup)\n\t\tkexec_enter_virtual_mode();\n\telse\n\t\t__efi_enter_virtual_mode();\n\n\tefi_dump_pagetable();\n}\n\nbool efi_is_table_address(unsigned long phys_addr)\n{\n\tunsigned int i;\n\n\tif (phys_addr == EFI_INVALID_TABLE_ADDR)\n\t\treturn false;\n\n\tfor (i = 0; i < ARRAY_SIZE(efi_tables); i++)\n\t\tif (*(efi_tables[i]) == phys_addr)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nchar *efi_systab_show_arch(char *str)\n{\n\tif (uga_phys != EFI_INVALID_TABLE_ADDR)\n\t\tstr += sprintf(str, \"UGA=0x%lx\\n\", uga_phys);\n\treturn str;\n}\n\n#define EFI_FIELD(var) efi_ ## var\n\n#define EFI_ATTR_SHOW(name) \\\nstatic ssize_t name##_show(struct kobject *kobj, \\\n\t\t\t\tstruct kobj_attribute *attr, char *buf) \\\n{ \\\n\treturn sprintf(buf, \"0x%lx\\n\", EFI_FIELD(name)); \\\n}\n\nEFI_ATTR_SHOW(fw_vendor);\nEFI_ATTR_SHOW(runtime);\nEFI_ATTR_SHOW(config_table);\n\nstruct kobj_attribute efi_attr_fw_vendor = __ATTR_RO(fw_vendor);\nstruct kobj_attribute efi_attr_runtime = __ATTR_RO(runtime);\nstruct kobj_attribute efi_attr_config_table = __ATTR_RO(config_table);\n\numode_t efi_attr_is_visible(struct kobject *kobj, struct attribute *attr, int n)\n{\n\tif (attr == &efi_attr_fw_vendor.attr) {\n\t\tif (efi_enabled(EFI_PARAVIRT) ||\n\t\t\t\tefi_fw_vendor == EFI_INVALID_TABLE_ADDR)\n\t\t\treturn 0;\n\t} else if (attr == &efi_attr_runtime.attr) {\n\t\tif (efi_runtime == EFI_INVALID_TABLE_ADDR)\n\t\t\treturn 0;\n\t} else if (attr == &efi_attr_config_table.attr) {\n\t\tif (efi_config_table == EFI_INVALID_TABLE_ADDR)\n\t\t\treturn 0;\n\t}\n\treturn attr->mode;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}