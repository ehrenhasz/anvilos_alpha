{
  "module_name": "quirks.c",
  "hash_id": "1f4ee49b84846113f22f25e3d8e64916bf35f89fde0d7bc3fc105c1e664cdf1e",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/efi/quirks.c",
  "human_readable_source": "\n#define pr_fmt(fmt) \"efi: \" fmt\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/types.h>\n#include <linux/efi.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n\n#include <asm/e820/api.h>\n#include <asm/efi.h>\n#include <asm/uv/uv.h>\n#include <asm/cpu_device_id.h>\n#include <asm/realmode.h>\n#include <asm/reboot.h>\n\n#define EFI_MIN_RESERVE 5120\n\n#define EFI_DUMMY_GUID \\\n\tEFI_GUID(0x4424ac57, 0xbe4b, 0x47dd, 0x9e, 0x97, 0xed, 0x50, 0xf0, 0x9f, 0x92, 0xa9)\n\n#define QUARK_CSH_SIGNATURE\t\t0x5f435348\t \n#define QUARK_SECURITY_HEADER_SIZE\t0x400\n\n \nstruct quark_security_header {\n\tu32 csh_signature;\n\tu32 version;\n\tu32 modulesize;\n\tu32 security_version_number_index;\n\tu32 security_version_number;\n\tu32 rsvd_module_id;\n\tu32 rsvd_module_vendor;\n\tu32 rsvd_date;\n\tu32 headersize;\n\tu32 hash_algo;\n\tu32 cryp_algo;\n\tu32 keysize;\n\tu32 signaturesize;\n\tu32 rsvd_next_header;\n\tu32 rsvd[2];\n};\n\nstatic const efi_char16_t efi_dummy_name[] = L\"DUMMY\";\n\nstatic bool efi_no_storage_paranoia;\n\n \nstatic int __init setup_storage_paranoia(char *arg)\n{\n\tefi_no_storage_paranoia = true;\n\treturn 0;\n}\nearly_param(\"efi_no_storage_paranoia\", setup_storage_paranoia);\n\n \nvoid efi_delete_dummy_variable(void)\n{\n\tefi.set_variable_nonblocking((efi_char16_t *)efi_dummy_name,\n\t\t\t\t     &EFI_DUMMY_GUID,\n\t\t\t\t     EFI_VARIABLE_NON_VOLATILE |\n\t\t\t\t     EFI_VARIABLE_BOOTSERVICE_ACCESS |\n\t\t\t\t     EFI_VARIABLE_RUNTIME_ACCESS, 0, NULL);\n}\n\nu64 efivar_reserved_space(void)\n{\n\tif (efi_no_storage_paranoia)\n\t\treturn 0;\n\treturn EFI_MIN_RESERVE;\n}\nEXPORT_SYMBOL_GPL(efivar_reserved_space);\n\n \nstatic efi_status_t\nquery_variable_store_nonblocking(u32 attributes, unsigned long size)\n{\n\tefi_status_t status;\n\tu64 storage_size, remaining_size, max_size;\n\n\tstatus = efi.query_variable_info_nonblocking(attributes, &storage_size,\n\t\t\t\t\t\t     &remaining_size,\n\t\t\t\t\t\t     &max_size);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\n\tif (remaining_size - size < EFI_MIN_RESERVE)\n\t\treturn EFI_OUT_OF_RESOURCES;\n\n\treturn EFI_SUCCESS;\n}\n\n \nefi_status_t efi_query_variable_store(u32 attributes, unsigned long size,\n\t\t\t\t      bool nonblocking)\n{\n\tefi_status_t status;\n\tu64 storage_size, remaining_size, max_size;\n\n\tif (!(attributes & EFI_VARIABLE_NON_VOLATILE))\n\t\treturn 0;\n\n\tif (nonblocking)\n\t\treturn query_variable_store_nonblocking(attributes, size);\n\n\tstatus = efi.query_variable_info(attributes, &storage_size,\n\t\t\t\t\t &remaining_size, &max_size);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\n\t \n\tif ((remaining_size - size < EFI_MIN_RESERVE) &&\n\t\t!efi_no_storage_paranoia) {\n\n\t\t \n\t\tunsigned long dummy_size = remaining_size + 1024;\n\t\tvoid *dummy = kzalloc(dummy_size, GFP_KERNEL);\n\n\t\tif (!dummy)\n\t\t\treturn EFI_OUT_OF_RESOURCES;\n\n\t\tstatus = efi.set_variable((efi_char16_t *)efi_dummy_name,\n\t\t\t\t\t  &EFI_DUMMY_GUID,\n\t\t\t\t\t  EFI_VARIABLE_NON_VOLATILE |\n\t\t\t\t\t  EFI_VARIABLE_BOOTSERVICE_ACCESS |\n\t\t\t\t\t  EFI_VARIABLE_RUNTIME_ACCESS,\n\t\t\t\t\t  dummy_size, dummy);\n\n\t\tif (status == EFI_SUCCESS) {\n\t\t\t \n\t\t\tefi_delete_dummy_variable();\n\t\t}\n\n\t\tkfree(dummy);\n\n\t\t \n\t\tstatus = efi.query_variable_info(attributes, &storage_size,\n\t\t\t\t\t\t &remaining_size, &max_size);\n\n\t\tif (status != EFI_SUCCESS)\n\t\t\treturn status;\n\n\t\t \n\t\tif (remaining_size - size < EFI_MIN_RESERVE)\n\t\t\treturn EFI_OUT_OF_RESOURCES;\n\t}\n\n\treturn EFI_SUCCESS;\n}\nEXPORT_SYMBOL_GPL(efi_query_variable_store);\n\n \nvoid __init efi_arch_mem_reserve(phys_addr_t addr, u64 size)\n{\n\tstruct efi_memory_map_data data = { 0 };\n\tstruct efi_mem_range mr;\n\tefi_memory_desc_t md;\n\tint num_entries;\n\tvoid *new;\n\n\tif (efi_mem_desc_lookup(addr, &md) ||\n\t    md.type != EFI_BOOT_SERVICES_DATA) {\n\t\tpr_err(\"Failed to lookup EFI memory descriptor for %pa\\n\", &addr);\n\t\treturn;\n\t}\n\n\tif (addr + size > md.phys_addr + (md.num_pages << EFI_PAGE_SHIFT)) {\n\t\tpr_err(\"Region spans EFI memory descriptors, %pa\\n\", &addr);\n\t\treturn;\n\t}\n\n\tsize += addr % EFI_PAGE_SIZE;\n\tsize = round_up(size, EFI_PAGE_SIZE);\n\taddr = round_down(addr, EFI_PAGE_SIZE);\n\n\tmr.range.start = addr;\n\tmr.range.end = addr + size - 1;\n\tmr.attribute = md.attribute | EFI_MEMORY_RUNTIME;\n\n\tnum_entries = efi_memmap_split_count(&md, &mr.range);\n\tnum_entries += efi.memmap.nr_map;\n\n\tif (efi_memmap_alloc(num_entries, &data) != 0) {\n\t\tpr_err(\"Could not allocate boot services memmap\\n\");\n\t\treturn;\n\t}\n\n\tnew = early_memremap_prot(data.phys_map, data.size,\n\t\t\t\t  pgprot_val(pgprot_encrypted(FIXMAP_PAGE_NORMAL)));\n\tif (!new) {\n\t\tpr_err(\"Failed to map new boot services memmap\\n\");\n\t\treturn;\n\t}\n\n\tefi_memmap_insert(&efi.memmap, new, &mr);\n\tearly_memunmap(new, data.size);\n\n\tefi_memmap_install(&data);\n\te820__range_update(addr, size, E820_TYPE_RAM, E820_TYPE_RESERVED);\n\te820__update_table(e820_table);\n}\n\n \nstatic __init bool can_free_region(u64 start, u64 size)\n{\n\tif (start + size > __pa_symbol(_text) && start <= __pa_symbol(_end))\n\t\treturn false;\n\n\tif (!e820__mapped_all(start, start+size, E820_TYPE_RAM))\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid __init efi_reserve_boot_services(void)\n{\n\tefi_memory_desc_t *md;\n\n\tif (!efi_enabled(EFI_MEMMAP))\n\t\treturn;\n\n\tfor_each_efi_memory_desc(md) {\n\t\tu64 start = md->phys_addr;\n\t\tu64 size = md->num_pages << EFI_PAGE_SHIFT;\n\t\tbool already_reserved;\n\n\t\tif (md->type != EFI_BOOT_SERVICES_CODE &&\n\t\t    md->type != EFI_BOOT_SERVICES_DATA)\n\t\t\tcontinue;\n\n\t\talready_reserved = memblock_is_region_reserved(start, size);\n\n\t\t \n\t\tif (!already_reserved) {\n\t\t\tmemblock_reserve(start, size);\n\n\t\t\t \n\t\t\tif (can_free_region(start, size))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmd->attribute |= EFI_MEMORY_RUNTIME;\n\t}\n}\n\n \nstatic void __init efi_unmap_pages(efi_memory_desc_t *md)\n{\n\tpgd_t *pgd = efi_mm.pgd;\n\tu64 pa = md->phys_addr;\n\tu64 va = md->virt_addr;\n\n\t \n\tif (efi_is_mixed())\n\t\treturn;\n\n\tif (kernel_unmap_pages_in_pgd(pgd, pa, md->num_pages))\n\t\tpr_err(\"Failed to unmap 1:1 mapping for 0x%llx\\n\", pa);\n\n\tif (kernel_unmap_pages_in_pgd(pgd, va, md->num_pages))\n\t\tpr_err(\"Failed to unmap VA mapping for 0x%llx\\n\", va);\n}\n\nvoid __init efi_free_boot_services(void)\n{\n\tstruct efi_memory_map_data data = { 0 };\n\tefi_memory_desc_t *md;\n\tint num_entries = 0;\n\tvoid *new, *new_md;\n\n\t \n\tif (efi_enabled(EFI_DBG))\n\t\treturn;\n\n\tfor_each_efi_memory_desc(md) {\n\t\tunsigned long long start = md->phys_addr;\n\t\tunsigned long long size = md->num_pages << EFI_PAGE_SHIFT;\n\t\tsize_t rm_size;\n\n\t\tif (md->type != EFI_BOOT_SERVICES_CODE &&\n\t\t    md->type != EFI_BOOT_SERVICES_DATA) {\n\t\t\tnum_entries++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (md->attribute & EFI_MEMORY_RUNTIME) {\n\t\t\tnum_entries++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tefi_unmap_pages(md);\n\n\t\t \n\t\trm_size = real_mode_size_needed();\n\t\tif (rm_size && (start + rm_size) < (1<<20) && size >= rm_size) {\n\t\t\tset_real_mode_mem(start);\n\t\t\tstart += rm_size;\n\t\t\tsize -= rm_size;\n\t\t}\n\n\t\t \n\t\tif (start + size < SZ_1M)\n\t\t\tcontinue;\n\t\tif (start < SZ_1M) {\n\t\t\tsize -= (SZ_1M - start);\n\t\t\tstart = SZ_1M;\n\t\t}\n\n\t\tmemblock_free_late(start, size);\n\t}\n\n\tif (!num_entries)\n\t\treturn;\n\n\tif (efi_memmap_alloc(num_entries, &data) != 0) {\n\t\tpr_err(\"Failed to allocate new EFI memmap\\n\");\n\t\treturn;\n\t}\n\n\tnew = memremap(data.phys_map, data.size, MEMREMAP_WB);\n\tif (!new) {\n\t\tpr_err(\"Failed to map new EFI memmap\\n\");\n\t\treturn;\n\t}\n\n\t \n\tnew_md = new;\n\tfor_each_efi_memory_desc(md) {\n\t\tif (!(md->attribute & EFI_MEMORY_RUNTIME) &&\n\t\t    (md->type == EFI_BOOT_SERVICES_CODE ||\n\t\t     md->type == EFI_BOOT_SERVICES_DATA))\n\t\t\tcontinue;\n\n\t\tmemcpy(new_md, md, efi.memmap.desc_size);\n\t\tnew_md += efi.memmap.desc_size;\n\t}\n\n\tmemunmap(new);\n\n\tif (efi_memmap_install(&data) != 0) {\n\t\tpr_err(\"Could not install new EFI memmap\\n\");\n\t\treturn;\n\t}\n}\n\n \nint __init efi_reuse_config(u64 tables, int nr_tables)\n{\n\tint i, sz, ret = 0;\n\tvoid *p, *tablep;\n\tstruct efi_setup_data *data;\n\n\tif (nr_tables == 0)\n\t\treturn 0;\n\n\tif (!efi_setup)\n\t\treturn 0;\n\n\tif (!efi_enabled(EFI_64BIT))\n\t\treturn 0;\n\n\tdata = early_memremap(efi_setup, sizeof(*data));\n\tif (!data) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (!data->smbios)\n\t\tgoto out_memremap;\n\n\tsz = sizeof(efi_config_table_64_t);\n\n\tp = tablep = early_memremap(tables, nr_tables * sz);\n\tif (!p) {\n\t\tpr_err(\"Could not map Configuration table!\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_memremap;\n\t}\n\n\tfor (i = 0; i < nr_tables; i++) {\n\t\tefi_guid_t guid;\n\n\t\tguid = ((efi_config_table_64_t *)p)->guid;\n\n\t\tif (!efi_guidcmp(guid, SMBIOS_TABLE_GUID))\n\t\t\t((efi_config_table_64_t *)p)->table = data->smbios;\n\t\tp += sz;\n\t}\n\tearly_memunmap(tablep, nr_tables * sz);\n\nout_memremap:\n\tearly_memunmap(data, sizeof(*data));\nout:\n\treturn ret;\n}\n\nvoid __init efi_apply_memmap_quirks(void)\n{\n\t \n\tif (!efi_runtime_supported()) {\n\t\tpr_info(\"Setup done, disabling due to 32/64-bit mismatch\\n\");\n\t\tefi_memmap_unmap();\n\t}\n}\n\n \nbool efi_reboot_required(void)\n{\n\tif (!acpi_gbl_reduced_hardware)\n\t\treturn false;\n\n\tefi_reboot_quirk_mode = EFI_RESET_WARM;\n\treturn true;\n}\n\nbool efi_poweroff_required(void)\n{\n\treturn acpi_gbl_reduced_hardware || acpi_no_s5;\n}\n\n#ifdef CONFIG_EFI_CAPSULE_QUIRK_QUARK_CSH\n\nstatic int qrk_capsule_setup_info(struct capsule_info *cap_info, void **pkbuff,\n\t\t\t\t  size_t hdr_bytes)\n{\n\tstruct quark_security_header *csh = *pkbuff;\n\n\t \n\tif (hdr_bytes < sizeof(struct quark_security_header))\n\t\treturn 0;\n\n\tif (csh->csh_signature != QUARK_CSH_SIGNATURE ||\n\t    csh->headersize != QUARK_SECURITY_HEADER_SIZE)\n\t\treturn 1;\n\n\t \n\tif (hdr_bytes < QUARK_SECURITY_HEADER_SIZE +\n\t\t\tsizeof(efi_capsule_header_t))\n\t\treturn 0;\n\n\tpr_debug(\"Quark security header detected\\n\");\n\n\tif (csh->rsvd_next_header != 0) {\n\t\tpr_err(\"multiple Quark security headers not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*pkbuff += csh->headersize;\n\tcap_info->total_size = csh->headersize;\n\n\t \n\tcap_info->phys[0] += csh->headersize;\n\n\t \n\tcap_info->capsule = &cap_info->header;\n\n\treturn 1;\n}\n\nstatic const struct x86_cpu_id efi_capsule_quirk_ids[] = {\n\tX86_MATCH_VENDOR_FAM_MODEL(INTEL, 5, INTEL_FAM5_QUARK_X1000,\n\t\t\t\t   &qrk_capsule_setup_info),\n\t{ }\n};\n\nint efi_capsule_setup_info(struct capsule_info *cap_info, void *kbuff,\n\t\t\t   size_t hdr_bytes)\n{\n\tint (*quirk_handler)(struct capsule_info *, void **, size_t);\n\tconst struct x86_cpu_id *id;\n\tint ret;\n\n\tif (hdr_bytes < sizeof(efi_capsule_header_t))\n\t\treturn 0;\n\n\tcap_info->total_size = 0;\n\n\tid = x86_match_cpu(efi_capsule_quirk_ids);\n\tif (id) {\n\t\t \n\t\tquirk_handler = (typeof(quirk_handler))id->driver_data;\n\t\tret = quirk_handler(cap_info, &kbuff, hdr_bytes);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\t}\n\n\tmemcpy(&cap_info->header, kbuff, sizeof(cap_info->header));\n\n\tcap_info->total_size += cap_info->header.imagesize;\n\n\treturn __efi_capsule_setup_info(cap_info);\n}\n\n#endif\n\n \nvoid efi_crash_gracefully_on_page_fault(unsigned long phys_addr)\n{\n\tif (!IS_ENABLED(CONFIG_X86_64))\n\t\treturn;\n\n\t \n\tif (in_interrupt())\n\t\treturn;\n\n\t \n\tif (READ_ONCE(efi_rts_work.efi_rts_id) == EFI_NONE ||\n\t    current_work() != &efi_rts_work.work)\n\t\treturn;\n\n\t \n\tif (phys_addr <= 0x0fff)\n\t\treturn;\n\n\t \n\tWARN(1, FW_BUG \"Page fault caused by firmware at PA: 0x%lx\\n\",\n\t     phys_addr);\n\n\t \n\tif (efi_rts_work.efi_rts_id == EFI_RESET_SYSTEM) {\n\t\tpr_info(\"efi_reset_system() buggy! Reboot through BIOS\\n\");\n\t\tmachine_real_restart(MRR_BIOS);\n\t\treturn;\n\t}\n\n\t \n\tarch_efi_call_virt_teardown();\n\n\t \n\tefi_rts_work.status = EFI_ABORTED;\n\tcomplete(&efi_rts_work.efi_rts_comp);\n\n\tclear_bit(EFI_RUNTIME_SERVICES, &efi.flags);\n\tpr_info(\"Froze efi_rts_wq and disabled EFI Runtime Services\\n\");\n\n\t \n\tfor (;;) {\n\t\tset_current_state(TASK_IDLE);\n\t\tschedule();\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}