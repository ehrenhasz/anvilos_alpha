{
  "module_name": "efi_64.c",
  "hash_id": "081278dbe1c4f2448e5893f6bb04d43275d388367725233de1054e180fa65ccc",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/efi/efi_64.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"efi: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/memblock.h>\n#include <linux/ioport.h>\n#include <linux/mc146818rtc.h>\n#include <linux/efi.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/ucs2_string.h>\n#include <linux/cc_platform.h>\n#include <linux/sched/task.h>\n\n#include <asm/setup.h>\n#include <asm/page.h>\n#include <asm/e820/api.h>\n#include <asm/tlbflush.h>\n#include <asm/proto.h>\n#include <asm/efi.h>\n#include <asm/cacheflush.h>\n#include <asm/fixmap.h>\n#include <asm/realmode.h>\n#include <asm/time.h>\n#include <asm/pgalloc.h>\n#include <asm/sev.h>\n\n \nstatic u64 efi_va = EFI_VA_START;\nstatic struct mm_struct *efi_prev_mm;\n\n \nint __init efi_alloc_page_tables(void)\n{\n\tpgd_t *pgd, *efi_pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tgfp_t gfp_mask;\n\n\tgfp_mask = GFP_KERNEL | __GFP_ZERO;\n\tefi_pgd = (pgd_t *)__get_free_pages(gfp_mask, PGD_ALLOCATION_ORDER);\n\tif (!efi_pgd)\n\t\tgoto fail;\n\n\tpgd = efi_pgd + pgd_index(EFI_VA_END);\n\tp4d = p4d_alloc(&init_mm, pgd, EFI_VA_END);\n\tif (!p4d)\n\t\tgoto free_pgd;\n\n\tpud = pud_alloc(&init_mm, p4d, EFI_VA_END);\n\tif (!pud)\n\t\tgoto free_p4d;\n\n\tefi_mm.pgd = efi_pgd;\n\tmm_init_cpumask(&efi_mm);\n\tinit_new_context(NULL, &efi_mm);\n\n\treturn 0;\n\nfree_p4d:\n\tif (pgtable_l5_enabled())\n\t\tfree_page((unsigned long)pgd_page_vaddr(*pgd));\nfree_pgd:\n\tfree_pages((unsigned long)efi_pgd, PGD_ALLOCATION_ORDER);\nfail:\n\treturn -ENOMEM;\n}\n\n \nvoid efi_sync_low_kernel_mappings(void)\n{\n\tunsigned num_entries;\n\tpgd_t *pgd_k, *pgd_efi;\n\tp4d_t *p4d_k, *p4d_efi;\n\tpud_t *pud_k, *pud_efi;\n\tpgd_t *efi_pgd = efi_mm.pgd;\n\n\tpgd_efi = efi_pgd + pgd_index(PAGE_OFFSET);\n\tpgd_k = pgd_offset_k(PAGE_OFFSET);\n\n\tnum_entries = pgd_index(EFI_VA_END) - pgd_index(PAGE_OFFSET);\n\tmemcpy(pgd_efi, pgd_k, sizeof(pgd_t) * num_entries);\n\n\tpgd_efi = efi_pgd + pgd_index(EFI_VA_END);\n\tpgd_k = pgd_offset_k(EFI_VA_END);\n\tp4d_efi = p4d_offset(pgd_efi, 0);\n\tp4d_k = p4d_offset(pgd_k, 0);\n\n\tnum_entries = p4d_index(EFI_VA_END);\n\tmemcpy(p4d_efi, p4d_k, sizeof(p4d_t) * num_entries);\n\n\t \n\tBUILD_BUG_ON((EFI_VA_START & ~PUD_MASK) != 0);\n\tBUILD_BUG_ON((EFI_VA_END & ~PUD_MASK) != 0);\n\n\tp4d_efi = p4d_offset(pgd_efi, EFI_VA_END);\n\tp4d_k = p4d_offset(pgd_k, EFI_VA_END);\n\tpud_efi = pud_offset(p4d_efi, 0);\n\tpud_k = pud_offset(p4d_k, 0);\n\n\tnum_entries = pud_index(EFI_VA_END);\n\tmemcpy(pud_efi, pud_k, sizeof(pud_t) * num_entries);\n\n\tpud_efi = pud_offset(p4d_efi, EFI_VA_START);\n\tpud_k = pud_offset(p4d_k, EFI_VA_START);\n\n\tnum_entries = PTRS_PER_PUD - pud_index(EFI_VA_START);\n\tmemcpy(pud_efi, pud_k, sizeof(pud_t) * num_entries);\n}\n\n \nstatic inline phys_addr_t\nvirt_to_phys_or_null_size(void *va, unsigned long size)\n{\n\tphys_addr_t pa;\n\n\tif (!va)\n\t\treturn 0;\n\n\tif (virt_addr_valid(va))\n\t\treturn virt_to_phys(va);\n\n\tpa = slow_virt_to_phys(va);\n\n\t \n\tif (WARN_ON((pa ^ (pa + size - 1)) & PAGE_MASK))\n\t\treturn 0;\n\n\treturn pa;\n}\n\n#define virt_to_phys_or_null(addr)\t\t\t\t\\\n\tvirt_to_phys_or_null_size((addr), sizeof(*(addr)))\n\nint __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)\n{\n\textern const u8 __efi64_thunk_ret_tramp[];\n\tunsigned long pfn, text, pf, rodata, tramp;\n\tstruct page *page;\n\tunsigned npages;\n\tpgd_t *pgd = efi_mm.pgd;\n\n\t \n\tpfn = pa_memmap >> PAGE_SHIFT;\n\tpf = _PAGE_NX | _PAGE_RW | _PAGE_ENC;\n\tif (kernel_map_pages_in_pgd(pgd, pfn, pa_memmap, num_pages, pf)) {\n\t\tpr_err(\"Error ident-mapping new memmap (0x%lx)!\\n\", pa_memmap);\n\t\treturn 1;\n\t}\n\n\t \n\tif (kernel_map_pages_in_pgd(pgd, 0x0, 0x0, 1, pf)) {\n\t\tpr_err(\"Failed to create 1:1 mapping for the first page!\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tif (sev_es_efi_map_ghcbs(pgd)) {\n\t\tpr_err(\"Failed to create 1:1 mapping for the GHCBs!\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tif (!efi_is_mixed())\n\t\treturn 0;\n\n\tpage = alloc_page(GFP_KERNEL|__GFP_DMA32);\n\tif (!page) {\n\t\tpr_err(\"Unable to allocate EFI runtime stack < 4GB\\n\");\n\t\treturn 1;\n\t}\n\n\tefi_mixed_mode_stack_pa = page_to_phys(page + 1);  \n\n\tnpages = (_etext - _text) >> PAGE_SHIFT;\n\ttext = __pa(_text);\n\n\tif (kernel_unmap_pages_in_pgd(pgd, text, npages)) {\n\t\tpr_err(\"Failed to unmap kernel text 1:1 mapping\\n\");\n\t\treturn 1;\n\t}\n\n\tnpages = (__end_rodata - __start_rodata) >> PAGE_SHIFT;\n\trodata = __pa(__start_rodata);\n\tpfn = rodata >> PAGE_SHIFT;\n\n\tpf = _PAGE_NX | _PAGE_ENC;\n\tif (kernel_map_pages_in_pgd(pgd, pfn, rodata, npages, pf)) {\n\t\tpr_err(\"Failed to map kernel rodata 1:1\\n\");\n\t\treturn 1;\n\t}\n\n\ttramp = __pa(__efi64_thunk_ret_tramp);\n\tpfn = tramp >> PAGE_SHIFT;\n\n\tpf = _PAGE_ENC;\n\tif (kernel_map_pages_in_pgd(pgd, pfn, tramp, 1, pf)) {\n\t\tpr_err(\"Failed to map mixed mode return trampoline\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void __init __map_region(efi_memory_desc_t *md, u64 va)\n{\n\tunsigned long flags = _PAGE_RW;\n\tunsigned long pfn;\n\tpgd_t *pgd = efi_mm.pgd;\n\n\t \n\tif (md->type != EFI_BOOT_SERVICES_CODE &&\n\t    md->type != EFI_RUNTIME_SERVICES_CODE)\n\t\tflags |= _PAGE_NX;\n\n\tif (!(md->attribute & EFI_MEMORY_WB))\n\t\tflags |= _PAGE_PCD;\n\n\tif (cc_platform_has(CC_ATTR_GUEST_MEM_ENCRYPT) &&\n\t    md->type != EFI_MEMORY_MAPPED_IO)\n\t\tflags |= _PAGE_ENC;\n\n\tpfn = md->phys_addr >> PAGE_SHIFT;\n\tif (kernel_map_pages_in_pgd(pgd, pfn, va, md->num_pages, flags))\n\t\tpr_warn(\"Error mapping PA 0x%llx -> VA 0x%llx!\\n\",\n\t\t\t   md->phys_addr, va);\n}\n\nvoid __init efi_map_region(efi_memory_desc_t *md)\n{\n\tunsigned long size = md->num_pages << PAGE_SHIFT;\n\tu64 pa = md->phys_addr;\n\n\t \n\t__map_region(md, md->phys_addr);\n\n\t \n\tif (efi_is_mixed()) {\n\t\tmd->virt_addr = md->phys_addr;\n\t\treturn;\n\t}\n\n\tefi_va -= size;\n\n\t \n\tif (!(pa & (PMD_SIZE - 1))) {\n\t\tefi_va &= PMD_MASK;\n\t} else {\n\t\tu64 pa_offset = pa & (PMD_SIZE - 1);\n\t\tu64 prev_va = efi_va;\n\n\t\t \n\t\tefi_va = (efi_va & PMD_MASK) + pa_offset;\n\n\t\tif (efi_va > prev_va)\n\t\t\tefi_va -= PMD_SIZE;\n\t}\n\n\tif (efi_va < EFI_VA_END) {\n\t\tpr_warn(FW_WARN \"VA address range overflow!\\n\");\n\t\treturn;\n\t}\n\n\t \n\t__map_region(md, efi_va);\n\tmd->virt_addr = efi_va;\n}\n\n \nvoid __init efi_map_region_fixed(efi_memory_desc_t *md)\n{\n\t__map_region(md, md->phys_addr);\n\t__map_region(md, md->virt_addr);\n}\n\nvoid __init parse_efi_setup(u64 phys_addr, u32 data_len)\n{\n\tefi_setup = phys_addr + sizeof(struct setup_data);\n}\n\nstatic int __init efi_update_mappings(efi_memory_desc_t *md, unsigned long pf)\n{\n\tunsigned long pfn;\n\tpgd_t *pgd = efi_mm.pgd;\n\tint err1, err2;\n\n\t \n\tpfn = md->phys_addr >> PAGE_SHIFT;\n\terr1 = kernel_map_pages_in_pgd(pgd, pfn, md->phys_addr, md->num_pages, pf);\n\tif (err1) {\n\t\tpr_err(\"Error while updating 1:1 mapping PA 0x%llx -> VA 0x%llx!\\n\",\n\t\t\t   md->phys_addr, md->virt_addr);\n\t}\n\n\terr2 = kernel_map_pages_in_pgd(pgd, pfn, md->virt_addr, md->num_pages, pf);\n\tif (err2) {\n\t\tpr_err(\"Error while updating VA mapping PA 0x%llx -> VA 0x%llx!\\n\",\n\t\t\t   md->phys_addr, md->virt_addr);\n\t}\n\n\treturn err1 || err2;\n}\n\nbool efi_disable_ibt_for_runtime __ro_after_init = true;\n\nstatic int __init efi_update_mem_attr(struct mm_struct *mm, efi_memory_desc_t *md,\n\t\t\t\t      bool has_ibt)\n{\n\tunsigned long pf = 0;\n\n\tefi_disable_ibt_for_runtime |= !has_ibt;\n\n\tif (md->attribute & EFI_MEMORY_XP)\n\t\tpf |= _PAGE_NX;\n\n\tif (!(md->attribute & EFI_MEMORY_RO))\n\t\tpf |= _PAGE_RW;\n\n\tif (cc_platform_has(CC_ATTR_GUEST_MEM_ENCRYPT))\n\t\tpf |= _PAGE_ENC;\n\n\treturn efi_update_mappings(md, pf);\n}\n\nvoid __init efi_runtime_update_mappings(void)\n{\n\tefi_memory_desc_t *md;\n\n\t \n\tif (efi_enabled(EFI_MEM_ATTR)) {\n\t\tefi_disable_ibt_for_runtime = false;\n\t\tefi_memattr_apply_permissions(NULL, efi_update_mem_attr);\n\t\treturn;\n\t}\n\n\t \n\n\tif (!efi_enabled(EFI_NX_PE_DATA))\n\t\treturn;\n\n\tfor_each_efi_memory_desc(md) {\n\t\tunsigned long pf = 0;\n\n\t\tif (!(md->attribute & EFI_MEMORY_RUNTIME))\n\t\t\tcontinue;\n\n\t\tif (!(md->attribute & EFI_MEMORY_WB))\n\t\t\tpf |= _PAGE_PCD;\n\n\t\tif ((md->attribute & EFI_MEMORY_XP) ||\n\t\t\t(md->type == EFI_RUNTIME_SERVICES_DATA))\n\t\t\tpf |= _PAGE_NX;\n\n\t\tif (!(md->attribute & EFI_MEMORY_RO) &&\n\t\t\t(md->type != EFI_RUNTIME_SERVICES_CODE))\n\t\t\tpf |= _PAGE_RW;\n\n\t\tif (cc_platform_has(CC_ATTR_GUEST_MEM_ENCRYPT))\n\t\t\tpf |= _PAGE_ENC;\n\n\t\tefi_update_mappings(md, pf);\n\t}\n}\n\nvoid __init efi_dump_pagetable(void)\n{\n#ifdef CONFIG_EFI_PGT_DUMP\n\tptdump_walk_pgd_level(NULL, &efi_mm);\n#endif\n}\n\n \nstatic void efi_enter_mm(void)\n{\n\tefi_prev_mm = current->active_mm;\n\tcurrent->active_mm = &efi_mm;\n\tswitch_mm(efi_prev_mm, &efi_mm, NULL);\n}\n\nstatic void efi_leave_mm(void)\n{\n\tcurrent->active_mm = efi_prev_mm;\n\tswitch_mm(&efi_mm, efi_prev_mm, NULL);\n}\n\nvoid arch_efi_call_virt_setup(void)\n{\n\tefi_sync_low_kernel_mappings();\n\tefi_fpu_begin();\n\tfirmware_restrict_branch_speculation_start();\n\tefi_enter_mm();\n}\n\nvoid arch_efi_call_virt_teardown(void)\n{\n\tefi_leave_mm();\n\tfirmware_restrict_branch_speculation_end();\n\tefi_fpu_end();\n}\n\nstatic DEFINE_SPINLOCK(efi_runtime_lock);\n\n \n#define __efi_thunk(func, ...)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tunsigned short __ds, __es;\t\t\t\t\t\\\n\tefi_status_t ____s;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tsavesegment(ds, __ds);\t\t\t\t\t\t\\\n\tsavesegment(es, __es);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tloadsegment(ss, __KERNEL_DS);\t\t\t\t\t\\\n\tloadsegment(ds, __KERNEL_DS);\t\t\t\t\t\\\n\tloadsegment(es, __KERNEL_DS);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t____s = efi64_thunk(efi.runtime->mixed_mode.func, __VA_ARGS__);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tloadsegment(ds, __ds);\t\t\t\t\t\t\\\n\tloadsegment(es, __es);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t____s ^= (____s & BIT(31)) | (____s & BIT_ULL(31)) << 32;\t\\\n\t____s;\t\t\t\t\t\t\t\t\\\n})\n\n \n#define efi_thunk(func...)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tefi_status_t __s;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tarch_efi_call_virt_setup();\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__s = __efi_thunk(func);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tarch_efi_call_virt_teardown();\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__s;\t\t\t\t\t\t\t\t\\\n})\n\nstatic efi_status_t __init __no_sanitize_address\nefi_thunk_set_virtual_address_map(unsigned long memory_map_size,\n\t\t\t\t  unsigned long descriptor_size,\n\t\t\t\t  u32 descriptor_version,\n\t\t\t\t  efi_memory_desc_t *virtual_map)\n{\n\tefi_status_t status;\n\tunsigned long flags;\n\n\tefi_sync_low_kernel_mappings();\n\tlocal_irq_save(flags);\n\n\tefi_enter_mm();\n\n\tstatus = __efi_thunk(set_virtual_address_map, memory_map_size,\n\t\t\t     descriptor_size, descriptor_version, virtual_map);\n\n\tefi_leave_mm();\n\tlocal_irq_restore(flags);\n\n\treturn status;\n}\n\nstatic efi_status_t efi_thunk_get_time(efi_time_t *tm, efi_time_cap_t *tc)\n{\n\treturn EFI_UNSUPPORTED;\n}\n\nstatic efi_status_t efi_thunk_set_time(efi_time_t *tm)\n{\n\treturn EFI_UNSUPPORTED;\n}\n\nstatic efi_status_t\nefi_thunk_get_wakeup_time(efi_bool_t *enabled, efi_bool_t *pending,\n\t\t\t  efi_time_t *tm)\n{\n\treturn EFI_UNSUPPORTED;\n}\n\nstatic efi_status_t\nefi_thunk_set_wakeup_time(efi_bool_t enabled, efi_time_t *tm)\n{\n\treturn EFI_UNSUPPORTED;\n}\n\nstatic unsigned long efi_name_size(efi_char16_t *name)\n{\n\treturn ucs2_strsize(name, EFI_VAR_NAME_LEN) + 1;\n}\n\nstatic efi_status_t\nefi_thunk_get_variable(efi_char16_t *name, efi_guid_t *vendor,\n\t\t       u32 *attr, unsigned long *data_size, void *data)\n{\n\tu8 buf[24] __aligned(8);\n\tefi_guid_t *vnd = PTR_ALIGN((efi_guid_t *)buf, sizeof(*vnd));\n\tefi_status_t status;\n\tu32 phys_name, phys_vendor, phys_attr;\n\tu32 phys_data_size, phys_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&efi_runtime_lock, flags);\n\n\t*vnd = *vendor;\n\n\tphys_data_size = virt_to_phys_or_null(data_size);\n\tphys_vendor = virt_to_phys_or_null(vnd);\n\tphys_name = virt_to_phys_or_null_size(name, efi_name_size(name));\n\tphys_attr = virt_to_phys_or_null(attr);\n\tphys_data = virt_to_phys_or_null_size(data, *data_size);\n\n\tif (!phys_name || (data && !phys_data))\n\t\tstatus = EFI_INVALID_PARAMETER;\n\telse\n\t\tstatus = efi_thunk(get_variable, phys_name, phys_vendor,\n\t\t\t\t   phys_attr, phys_data_size, phys_data);\n\n\tspin_unlock_irqrestore(&efi_runtime_lock, flags);\n\n\treturn status;\n}\n\nstatic efi_status_t\nefi_thunk_set_variable(efi_char16_t *name, efi_guid_t *vendor,\n\t\t       u32 attr, unsigned long data_size, void *data)\n{\n\tu8 buf[24] __aligned(8);\n\tefi_guid_t *vnd = PTR_ALIGN((efi_guid_t *)buf, sizeof(*vnd));\n\tu32 phys_name, phys_vendor, phys_data;\n\tefi_status_t status;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&efi_runtime_lock, flags);\n\n\t*vnd = *vendor;\n\n\tphys_name = virt_to_phys_or_null_size(name, efi_name_size(name));\n\tphys_vendor = virt_to_phys_or_null(vnd);\n\tphys_data = virt_to_phys_or_null_size(data, data_size);\n\n\tif (!phys_name || (data && !phys_data))\n\t\tstatus = EFI_INVALID_PARAMETER;\n\telse\n\t\tstatus = efi_thunk(set_variable, phys_name, phys_vendor,\n\t\t\t\t   attr, data_size, phys_data);\n\n\tspin_unlock_irqrestore(&efi_runtime_lock, flags);\n\n\treturn status;\n}\n\nstatic efi_status_t\nefi_thunk_set_variable_nonblocking(efi_char16_t *name, efi_guid_t *vendor,\n\t\t\t\t   u32 attr, unsigned long data_size,\n\t\t\t\t   void *data)\n{\n\tu8 buf[24] __aligned(8);\n\tefi_guid_t *vnd = PTR_ALIGN((efi_guid_t *)buf, sizeof(*vnd));\n\tu32 phys_name, phys_vendor, phys_data;\n\tefi_status_t status;\n\tunsigned long flags;\n\n\tif (!spin_trylock_irqsave(&efi_runtime_lock, flags))\n\t\treturn EFI_NOT_READY;\n\n\t*vnd = *vendor;\n\n\tphys_name = virt_to_phys_or_null_size(name, efi_name_size(name));\n\tphys_vendor = virt_to_phys_or_null(vnd);\n\tphys_data = virt_to_phys_or_null_size(data, data_size);\n\n\tif (!phys_name || (data && !phys_data))\n\t\tstatus = EFI_INVALID_PARAMETER;\n\telse\n\t\tstatus = efi_thunk(set_variable, phys_name, phys_vendor,\n\t\t\t\t   attr, data_size, phys_data);\n\n\tspin_unlock_irqrestore(&efi_runtime_lock, flags);\n\n\treturn status;\n}\n\nstatic efi_status_t\nefi_thunk_get_next_variable(unsigned long *name_size,\n\t\t\t    efi_char16_t *name,\n\t\t\t    efi_guid_t *vendor)\n{\n\tu8 buf[24] __aligned(8);\n\tefi_guid_t *vnd = PTR_ALIGN((efi_guid_t *)buf, sizeof(*vnd));\n\tefi_status_t status;\n\tu32 phys_name_size, phys_name, phys_vendor;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&efi_runtime_lock, flags);\n\n\t*vnd = *vendor;\n\n\tphys_name_size = virt_to_phys_or_null(name_size);\n\tphys_vendor = virt_to_phys_or_null(vnd);\n\tphys_name = virt_to_phys_or_null_size(name, *name_size);\n\n\tif (!phys_name)\n\t\tstatus = EFI_INVALID_PARAMETER;\n\telse\n\t\tstatus = efi_thunk(get_next_variable, phys_name_size,\n\t\t\t\t   phys_name, phys_vendor);\n\n\tspin_unlock_irqrestore(&efi_runtime_lock, flags);\n\n\t*vendor = *vnd;\n\treturn status;\n}\n\nstatic efi_status_t\nefi_thunk_get_next_high_mono_count(u32 *count)\n{\n\treturn EFI_UNSUPPORTED;\n}\n\nstatic void\nefi_thunk_reset_system(int reset_type, efi_status_t status,\n\t\t       unsigned long data_size, efi_char16_t *data)\n{\n\tu32 phys_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&efi_runtime_lock, flags);\n\n\tphys_data = virt_to_phys_or_null_size(data, data_size);\n\n\tefi_thunk(reset_system, reset_type, status, data_size, phys_data);\n\n\tspin_unlock_irqrestore(&efi_runtime_lock, flags);\n}\n\nstatic efi_status_t\nefi_thunk_update_capsule(efi_capsule_header_t **capsules,\n\t\t\t unsigned long count, unsigned long sg_list)\n{\n\t \n\treturn EFI_UNSUPPORTED;\n}\n\nstatic efi_status_t\nefi_thunk_query_variable_info(u32 attr, u64 *storage_space,\n\t\t\t      u64 *remaining_space,\n\t\t\t      u64 *max_variable_size)\n{\n\tefi_status_t status;\n\tu32 phys_storage, phys_remaining, phys_max;\n\tunsigned long flags;\n\n\tif (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)\n\t\treturn EFI_UNSUPPORTED;\n\n\tspin_lock_irqsave(&efi_runtime_lock, flags);\n\n\tphys_storage = virt_to_phys_or_null(storage_space);\n\tphys_remaining = virt_to_phys_or_null(remaining_space);\n\tphys_max = virt_to_phys_or_null(max_variable_size);\n\n\tstatus = efi_thunk(query_variable_info, attr, phys_storage,\n\t\t\t   phys_remaining, phys_max);\n\n\tspin_unlock_irqrestore(&efi_runtime_lock, flags);\n\n\treturn status;\n}\n\nstatic efi_status_t\nefi_thunk_query_variable_info_nonblocking(u32 attr, u64 *storage_space,\n\t\t\t\t\t  u64 *remaining_space,\n\t\t\t\t\t  u64 *max_variable_size)\n{\n\tefi_status_t status;\n\tu32 phys_storage, phys_remaining, phys_max;\n\tunsigned long flags;\n\n\tif (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)\n\t\treturn EFI_UNSUPPORTED;\n\n\tif (!spin_trylock_irqsave(&efi_runtime_lock, flags))\n\t\treturn EFI_NOT_READY;\n\n\tphys_storage = virt_to_phys_or_null(storage_space);\n\tphys_remaining = virt_to_phys_or_null(remaining_space);\n\tphys_max = virt_to_phys_or_null(max_variable_size);\n\n\tstatus = efi_thunk(query_variable_info, attr, phys_storage,\n\t\t\t   phys_remaining, phys_max);\n\n\tspin_unlock_irqrestore(&efi_runtime_lock, flags);\n\n\treturn status;\n}\n\nstatic efi_status_t\nefi_thunk_query_capsule_caps(efi_capsule_header_t **capsules,\n\t\t\t     unsigned long count, u64 *max_size,\n\t\t\t     int *reset_type)\n{\n\t \n\treturn EFI_UNSUPPORTED;\n}\n\nvoid __init efi_thunk_runtime_setup(void)\n{\n\tif (!IS_ENABLED(CONFIG_EFI_MIXED))\n\t\treturn;\n\n\tefi.get_time = efi_thunk_get_time;\n\tefi.set_time = efi_thunk_set_time;\n\tefi.get_wakeup_time = efi_thunk_get_wakeup_time;\n\tefi.set_wakeup_time = efi_thunk_set_wakeup_time;\n\tefi.get_variable = efi_thunk_get_variable;\n\tefi.get_next_variable = efi_thunk_get_next_variable;\n\tefi.set_variable = efi_thunk_set_variable;\n\tefi.set_variable_nonblocking = efi_thunk_set_variable_nonblocking;\n\tefi.get_next_high_mono_count = efi_thunk_get_next_high_mono_count;\n\tefi.reset_system = efi_thunk_reset_system;\n\tefi.query_variable_info = efi_thunk_query_variable_info;\n\tefi.query_variable_info_nonblocking = efi_thunk_query_variable_info_nonblocking;\n\tefi.update_capsule = efi_thunk_update_capsule;\n\tefi.query_capsule_caps = efi_thunk_query_capsule_caps;\n}\n\nefi_status_t __init __no_sanitize_address\nefi_set_virtual_address_map(unsigned long memory_map_size,\n\t\t\t    unsigned long descriptor_size,\n\t\t\t    u32 descriptor_version,\n\t\t\t    efi_memory_desc_t *virtual_map,\n\t\t\t    unsigned long systab_phys)\n{\n\tconst efi_system_table_t *systab = (efi_system_table_t *)systab_phys;\n\tefi_status_t status;\n\tunsigned long flags;\n\n\tif (efi_is_mixed())\n\t\treturn efi_thunk_set_virtual_address_map(memory_map_size,\n\t\t\t\t\t\t\t descriptor_size,\n\t\t\t\t\t\t\t descriptor_version,\n\t\t\t\t\t\t\t virtual_map);\n\tefi_enter_mm();\n\n\tefi_fpu_begin();\n\n\t \n\tlocal_irq_save(flags);\n\tstatus = arch_efi_call_virt(efi.runtime, set_virtual_address_map,\n\t\t\t\t    memory_map_size, descriptor_size,\n\t\t\t\t    descriptor_version, virtual_map);\n\tlocal_irq_restore(flags);\n\n\tefi_fpu_end();\n\n\t \n\tefi.runtime = READ_ONCE(systab->runtime);\n\n\tefi_leave_mm();\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}