{
  "module_name": "memmap.c",
  "hash_id": "de99fcd01bf4f50d75b4633f4420fcdae0de3a152eac329acdc7b21ba8674305",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/efi/memmap.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"efi: \" fmt\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/efi.h>\n#include <linux/io.h>\n#include <asm/early_ioremap.h>\n#include <asm/efi.h>\n#include <linux/memblock.h>\n#include <linux/slab.h>\n\nstatic phys_addr_t __init __efi_memmap_alloc_early(unsigned long size)\n{\n\treturn memblock_phys_alloc(size, SMP_CACHE_BYTES);\n}\n\nstatic phys_addr_t __init __efi_memmap_alloc_late(unsigned long size)\n{\n\tunsigned int order = get_order(size);\n\tstruct page *p = alloc_pages(GFP_KERNEL, order);\n\n\tif (!p)\n\t\treturn 0;\n\n\treturn PFN_PHYS(page_to_pfn(p));\n}\n\nvoid __init __efi_memmap_free(u64 phys, unsigned long size, unsigned long flags)\n{\n\tif (flags & EFI_MEMMAP_MEMBLOCK) {\n\t\tif (slab_is_available())\n\t\t\tmemblock_free_late(phys, size);\n\t\telse\n\t\t\tmemblock_phys_free(phys, size);\n\t} else if (flags & EFI_MEMMAP_SLAB) {\n\t\tstruct page *p = pfn_to_page(PHYS_PFN(phys));\n\t\tunsigned int order = get_order(size);\n\n\t\tfree_pages((unsigned long) page_address(p), order);\n\t}\n}\n\n \nint __init efi_memmap_alloc(unsigned int num_entries,\n\t\tstruct efi_memory_map_data *data)\n{\n\t \n\tWARN_ON(data->phys_map || data->size);\n\n\tdata->size = num_entries * efi.memmap.desc_size;\n\tdata->desc_version = efi.memmap.desc_version;\n\tdata->desc_size = efi.memmap.desc_size;\n\tdata->flags &= ~(EFI_MEMMAP_SLAB | EFI_MEMMAP_MEMBLOCK);\n\tdata->flags |= efi.memmap.flags & EFI_MEMMAP_LATE;\n\n\tif (slab_is_available()) {\n\t\tdata->flags |= EFI_MEMMAP_SLAB;\n\t\tdata->phys_map = __efi_memmap_alloc_late(data->size);\n\t} else {\n\t\tdata->flags |= EFI_MEMMAP_MEMBLOCK;\n\t\tdata->phys_map = __efi_memmap_alloc_early(data->size);\n\t}\n\n\tif (!data->phys_map)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \nint __init efi_memmap_install(struct efi_memory_map_data *data)\n{\n\tefi_memmap_unmap();\n\n\tif (efi_enabled(EFI_PARAVIRT))\n\t\treturn 0;\n\n\treturn __efi_memmap_init(data);\n}\n\n \nint __init efi_memmap_split_count(efi_memory_desc_t *md, struct range *range)\n{\n\tu64 m_start, m_end;\n\tu64 start, end;\n\tint count = 0;\n\n\tstart = md->phys_addr;\n\tend = start + (md->num_pages << EFI_PAGE_SHIFT) - 1;\n\n\t \n\tm_start = range->start;\n\tm_end = range->end;\n\n\tif (m_start <= start) {\n\t\t \n\t\tif (start < m_end && m_end < end)\n\t\t\tcount++;\n\t}\n\n\tif (start < m_start && m_start < end) {\n\t\t \n\t\tif (m_end < end)\n\t\t\tcount += 2;\n\t\t \n\t\tif (end <= m_end)\n\t\t\tcount++;\n\t}\n\n\treturn count;\n}\n\n \nvoid __init efi_memmap_insert(struct efi_memory_map *old_memmap, void *buf,\n\t\t\t      struct efi_mem_range *mem)\n{\n\tu64 m_start, m_end, m_attr;\n\tefi_memory_desc_t *md;\n\tu64 start, end;\n\tvoid *old, *new;\n\n\t \n\tm_start = mem->range.start;\n\tm_end = mem->range.end;\n\tm_attr = mem->attribute;\n\n\t \n\tif (!IS_ALIGNED(m_start, EFI_PAGE_SIZE) ||\n\t    !IS_ALIGNED(m_end + 1, EFI_PAGE_SIZE)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tfor (old = old_memmap->map, new = buf;\n\t     old < old_memmap->map_end;\n\t     old += old_memmap->desc_size, new += old_memmap->desc_size) {\n\n\t\t \n\t\tmemcpy(new, old, old_memmap->desc_size);\n\t\tmd = new;\n\t\tstart = md->phys_addr;\n\t\tend = md->phys_addr + (md->num_pages << EFI_PAGE_SHIFT) - 1;\n\n\t\tif (m_start <= start && end <= m_end)\n\t\t\tmd->attribute |= m_attr;\n\n\t\tif (m_start <= start &&\n\t\t    (start < m_end && m_end < end)) {\n\t\t\t \n\t\t\tmd->attribute |= m_attr;\n\t\t\tmd->num_pages = (m_end - md->phys_addr + 1) >>\n\t\t\t\tEFI_PAGE_SHIFT;\n\t\t\t \n\t\t\tnew += old_memmap->desc_size;\n\t\t\tmemcpy(new, old, old_memmap->desc_size);\n\t\t\tmd = new;\n\t\t\tmd->phys_addr = m_end + 1;\n\t\t\tmd->num_pages = (end - md->phys_addr + 1) >>\n\t\t\t\tEFI_PAGE_SHIFT;\n\t\t}\n\n\t\tif ((start < m_start && m_start < end) && m_end < end) {\n\t\t\t \n\t\t\tmd->num_pages = (m_start - md->phys_addr) >>\n\t\t\t\tEFI_PAGE_SHIFT;\n\t\t\t \n\t\t\tnew += old_memmap->desc_size;\n\t\t\tmemcpy(new, old, old_memmap->desc_size);\n\t\t\tmd = new;\n\t\t\tmd->attribute |= m_attr;\n\t\t\tmd->phys_addr = m_start;\n\t\t\tmd->num_pages = (m_end - m_start + 1) >>\n\t\t\t\tEFI_PAGE_SHIFT;\n\t\t\t \n\t\t\tnew += old_memmap->desc_size;\n\t\t\tmemcpy(new, old, old_memmap->desc_size);\n\t\t\tmd = new;\n\t\t\tmd->phys_addr = m_end + 1;\n\t\t\tmd->num_pages = (end - m_end) >>\n\t\t\t\tEFI_PAGE_SHIFT;\n\t\t}\n\n\t\tif ((start < m_start && m_start < end) &&\n\t\t    (end <= m_end)) {\n\t\t\t \n\t\t\tmd->num_pages = (m_start - md->phys_addr) >>\n\t\t\t\tEFI_PAGE_SHIFT;\n\t\t\t \n\t\t\tnew += old_memmap->desc_size;\n\t\t\tmemcpy(new, old, old_memmap->desc_size);\n\t\t\tmd = new;\n\t\t\tmd->phys_addr = m_start;\n\t\t\tmd->num_pages = (end - md->phys_addr + 1) >>\n\t\t\t\tEFI_PAGE_SHIFT;\n\t\t\tmd->attribute |= m_attr;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}