{
  "module_name": "efi_32.c",
  "hash_id": "9a23c6d4521b5b437c9ff440215c558c025a7b49cc82425fc851ac0147be3035",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/efi/efi_32.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/ioport.h>\n#include <linux/efi.h>\n#include <linux/pgtable.h>\n\n#include <asm/io.h>\n#include <asm/desc.h>\n#include <asm/page.h>\n#include <asm/set_memory.h>\n#include <asm/tlbflush.h>\n#include <asm/efi.h>\n\nvoid __init efi_map_region(efi_memory_desc_t *md)\n{\n\tu64 start_pfn, end_pfn, end;\n\tunsigned long size;\n\tvoid *va;\n\n\tstart_pfn\t= PFN_DOWN(md->phys_addr);\n\tsize\t\t= md->num_pages << PAGE_SHIFT;\n\tend\t\t= md->phys_addr + size;\n\tend_pfn \t= PFN_UP(end);\n\n\tif (pfn_range_is_mapped(start_pfn, end_pfn)) {\n\t\tva = __va(md->phys_addr);\n\n\t\tif (!(md->attribute & EFI_MEMORY_WB))\n\t\t\tset_memory_uc((unsigned long)va, md->num_pages);\n\t} else {\n\t\tva = ioremap_cache(md->phys_addr, size);\n\t}\n\n\tmd->virt_addr = (unsigned long)va;\n\tif (!va)\n\t\tpr_err(\"ioremap of 0x%llX failed!\\n\", md->phys_addr);\n}\n\n \n\nint __init efi_alloc_page_tables(void)\n{\n\treturn 0;\n}\n\nvoid efi_sync_low_kernel_mappings(void) {}\n\nvoid __init efi_dump_pagetable(void)\n{\n#ifdef CONFIG_EFI_PGT_DUMP\n\tptdump_walk_pgd_level(NULL, &init_mm);\n#endif\n}\n\nint __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)\n{\n\treturn 0;\n}\n\nvoid __init efi_map_region_fixed(efi_memory_desc_t *md) {}\nvoid __init parse_efi_setup(u64 phys_addr, u32 data_len) {}\n\nefi_status_t efi_call_svam(efi_runtime_services_t * const *,\n\t\t\t   u32, u32, u32, void *, u32);\n\nefi_status_t __init efi_set_virtual_address_map(unsigned long memory_map_size,\n\t\t\t\t\t\tunsigned long descriptor_size,\n\t\t\t\t\t\tu32 descriptor_version,\n\t\t\t\t\t\tefi_memory_desc_t *virtual_map,\n\t\t\t\t\t\tunsigned long systab_phys)\n{\n\tconst efi_system_table_t *systab = (efi_system_table_t *)systab_phys;\n\tstruct desc_ptr gdt_descr;\n\tefi_status_t status;\n\tunsigned long flags;\n\tpgd_t *save_pgd;\n\n\t \n\tsave_pgd = swapper_pg_dir;\n\tload_cr3(initial_page_table);\n\t__flush_tlb_all();\n\n\tgdt_descr.address = get_cpu_gdt_paddr(0);\n\tgdt_descr.size = GDT_SIZE - 1;\n\tload_gdt(&gdt_descr);\n\n\t \n\tlocal_irq_save(flags);\n\tstatus = efi_call_svam(&systab->runtime,\n\t\t\t       memory_map_size, descriptor_size,\n\t\t\t       descriptor_version, virtual_map,\n\t\t\t       __pa(&efi.runtime));\n\tlocal_irq_restore(flags);\n\n\tload_fixmap_gdt(0);\n\tload_cr3(save_pgd);\n\t__flush_tlb_all();\n\n\treturn status;\n}\n\nvoid __init efi_runtime_update_mappings(void)\n{\n\tif (__supported_pte_mask & _PAGE_NX) {\n\t\tefi_memory_desc_t *md;\n\n\t\t \n\t\tfor_each_efi_memory_desc(md) {\n\t\t\tif (md->type != EFI_RUNTIME_SERVICES_CODE)\n\t\t\t\tcontinue;\n\n\t\t\tset_memory_x(md->virt_addr, md->num_pages);\n\t\t}\n\t}\n}\n\nvoid arch_efi_call_virt_setup(void)\n{\n\tefi_fpu_begin();\n\tfirmware_restrict_branch_speculation_start();\n}\n\nvoid arch_efi_call_virt_teardown(void)\n{\n\tfirmware_restrict_branch_speculation_end();\n\tefi_fpu_end();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}