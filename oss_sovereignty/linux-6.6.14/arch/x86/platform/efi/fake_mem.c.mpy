{
  "module_name": "fake_mem.c",
  "hash_id": "795064cdce26fc4c2b6569fe7510507cc2a3a7ccc1f85534ba812c7bc1f5eace",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/efi/fake_mem.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/efi.h>\n#include <linux/init.h>\n#include <linux/memblock.h>\n#include <linux/types.h>\n#include <linux/sort.h>\n#include <asm/e820/api.h>\n#include <asm/efi.h>\n\n#define EFI_MAX_FAKEMEM CONFIG_EFI_MAX_FAKE_MEM\n\nstatic struct efi_mem_range efi_fake_mems[EFI_MAX_FAKEMEM];\nstatic int nr_fake_mem;\n\nstatic int __init cmp_fake_mem(const void *x1, const void *x2)\n{\n\tconst struct efi_mem_range *m1 = x1;\n\tconst struct efi_mem_range *m2 = x2;\n\n\tif (m1->range.start < m2->range.start)\n\t\treturn -1;\n\tif (m1->range.start > m2->range.start)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void __init efi_fake_range(struct efi_mem_range *efi_range)\n{\n\tstruct efi_memory_map_data data = { 0 };\n\tint new_nr_map = efi.memmap.nr_map;\n\tefi_memory_desc_t *md;\n\tvoid *new_memmap;\n\n\t \n\tfor_each_efi_memory_desc(md)\n\t\tnew_nr_map += efi_memmap_split_count(md, &efi_range->range);\n\n\t \n\tif (efi_memmap_alloc(new_nr_map, &data) != 0)\n\t\treturn;\n\n\t \n\tnew_memmap = early_memremap(data.phys_map, data.size);\n\tif (!new_memmap) {\n\t\t__efi_memmap_free(data.phys_map, data.size, data.flags);\n\t\treturn;\n\t}\n\n\tefi_memmap_insert(&efi.memmap, new_memmap, efi_range);\n\n\t \n\tearly_memunmap(new_memmap, data.size);\n\n\tefi_memmap_install(&data);\n}\n\nvoid __init efi_fake_memmap(void)\n{\n\tint i;\n\n\tif (!efi_enabled(EFI_MEMMAP) || !nr_fake_mem)\n\t\treturn;\n\n\tfor (i = 0; i < nr_fake_mem; i++)\n\t\tefi_fake_range(&efi_fake_mems[i]);\n\n\t \n\tefi_print_memmap();\n}\n\nstatic int __init setup_fake_mem(char *p)\n{\n\tu64 start = 0, mem_size = 0, attribute = 0;\n\tint i;\n\n\tif (!p)\n\t\treturn -EINVAL;\n\n\twhile (*p != '\\0') {\n\t\tmem_size = memparse(p, &p);\n\t\tif (*p == '@')\n\t\t\tstart = memparse(p+1, &p);\n\t\telse\n\t\t\tbreak;\n\n\t\tif (*p == ':')\n\t\t\tattribute = simple_strtoull(p+1, &p, 0);\n\t\telse\n\t\t\tbreak;\n\n\t\tif (nr_fake_mem >= EFI_MAX_FAKEMEM)\n\t\t\tbreak;\n\n\t\tefi_fake_mems[nr_fake_mem].range.start = start;\n\t\tefi_fake_mems[nr_fake_mem].range.end = start + mem_size - 1;\n\t\tefi_fake_mems[nr_fake_mem].attribute = attribute;\n\t\tnr_fake_mem++;\n\n\t\tif (*p == ',')\n\t\t\tp++;\n\t}\n\n\tsort(efi_fake_mems, nr_fake_mem, sizeof(struct efi_mem_range),\n\t     cmp_fake_mem, NULL);\n\n\tfor (i = 0; i < nr_fake_mem; i++)\n\t\tpr_info(\"efi_fake_mem: add attr=0x%016llx to [mem 0x%016llx-0x%016llx]\",\n\t\t\tefi_fake_mems[i].attribute, efi_fake_mems[i].range.start,\n\t\t\tefi_fake_mems[i].range.end);\n\n\treturn *p == '\\0' ? 0 : -EINVAL;\n}\n\nearly_param(\"efi_fake_mem\", setup_fake_mem);\n\nvoid __init efi_fake_memmap_early(void)\n{\n\tint i;\n\n\t \n\tif (!efi_soft_reserve_enabled())\n\t\treturn;\n\n\tif (!efi_enabled(EFI_MEMMAP) || !nr_fake_mem)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < nr_fake_mem; i++) {\n\t\tstruct efi_mem_range *mem = &efi_fake_mems[i];\n\t\tefi_memory_desc_t *md;\n\t\tu64 m_start, m_end;\n\n\t\tif ((mem->attribute & EFI_MEMORY_SP) == 0)\n\t\t\tcontinue;\n\n\t\tm_start = mem->range.start;\n\t\tm_end = mem->range.end;\n\t\tfor_each_efi_memory_desc(md) {\n\t\t\tu64 start, end, size;\n\n\t\t\tif (md->type != EFI_CONVENTIONAL_MEMORY)\n\t\t\t\tcontinue;\n\n\t\t\tstart = md->phys_addr;\n\t\t\tend = md->phys_addr + (md->num_pages << EFI_PAGE_SHIFT) - 1;\n\n\t\t\tif (m_start <= end && m_end >= start)\n\t\t\t\t ;\n\t\t\telse\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tstart = max(start, m_start);\n\t\t\tend = min(end, m_end);\n\t\t\tsize = end - start + 1;\n\n\t\t\tif (end <= start)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\te820__range_remove(start, size, E820_TYPE_RAM, 1);\n\t\t\te820__range_add(start, size, E820_TYPE_SOFT_RESERVED);\n\t\t\te820__update_table(e820_table);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}