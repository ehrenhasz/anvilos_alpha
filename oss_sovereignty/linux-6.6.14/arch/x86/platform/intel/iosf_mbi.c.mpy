{
  "module_name": "iosf_mbi.c",
  "hash_id": "b46cbc42e5e5766ebc518f6e9082a38a72a3a70517207f41badc48480c672e5c",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/intel/iosf_mbi.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/pci.h>\n#include <linux/debugfs.h>\n#include <linux/capability.h>\n#include <linux/pm_qos.h>\n#include <linux/wait.h>\n\n#include <asm/iosf_mbi.h>\n\n#define PCI_DEVICE_ID_INTEL_BAYTRAIL\t\t0x0F00\n#define PCI_DEVICE_ID_INTEL_BRASWELL\t\t0x2280\n#define PCI_DEVICE_ID_INTEL_QUARK_X1000\t\t0x0958\n#define PCI_DEVICE_ID_INTEL_TANGIER\t\t0x1170\n\nstatic struct pci_dev *mbi_pdev;\nstatic DEFINE_SPINLOCK(iosf_mbi_lock);\n\n \n\nstatic inline u32 iosf_mbi_form_mcr(u8 op, u8 port, u8 offset)\n{\n\treturn (op << 24) | (port << 16) | (offset << 8) | MBI_ENABLE;\n}\n\nstatic int iosf_mbi_pci_read_mdr(u32 mcrx, u32 mcr, u32 *mdr)\n{\n\tint result;\n\n\tif (!mbi_pdev)\n\t\treturn -ENODEV;\n\n\tif (mcrx) {\n\t\tresult = pci_write_config_dword(mbi_pdev, MBI_MCRX_OFFSET,\n\t\t\t\t\t\tmcrx);\n\t\tif (result < 0)\n\t\t\tgoto fail_read;\n\t}\n\n\tresult = pci_write_config_dword(mbi_pdev, MBI_MCR_OFFSET, mcr);\n\tif (result < 0)\n\t\tgoto fail_read;\n\n\tresult = pci_read_config_dword(mbi_pdev, MBI_MDR_OFFSET, mdr);\n\tif (result < 0)\n\t\tgoto fail_read;\n\n\treturn 0;\n\nfail_read:\n\tdev_err(&mbi_pdev->dev, \"PCI config access failed with %d\\n\", result);\n\treturn result;\n}\n\nstatic int iosf_mbi_pci_write_mdr(u32 mcrx, u32 mcr, u32 mdr)\n{\n\tint result;\n\n\tif (!mbi_pdev)\n\t\treturn -ENODEV;\n\n\tresult = pci_write_config_dword(mbi_pdev, MBI_MDR_OFFSET, mdr);\n\tif (result < 0)\n\t\tgoto fail_write;\n\n\tif (mcrx) {\n\t\tresult = pci_write_config_dword(mbi_pdev, MBI_MCRX_OFFSET,\n\t\t\t\t\t\tmcrx);\n\t\tif (result < 0)\n\t\t\tgoto fail_write;\n\t}\n\n\tresult = pci_write_config_dword(mbi_pdev, MBI_MCR_OFFSET, mcr);\n\tif (result < 0)\n\t\tgoto fail_write;\n\n\treturn 0;\n\nfail_write:\n\tdev_err(&mbi_pdev->dev, \"PCI config access failed with %d\\n\", result);\n\treturn result;\n}\n\nint iosf_mbi_read(u8 port, u8 opcode, u32 offset, u32 *mdr)\n{\n\tu32 mcr, mcrx;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tif (port == BT_MBI_UNIT_GFX) {\n\t\tWARN_ON(1);\n\t\treturn -EPERM;\n\t}\n\n\tmcr = iosf_mbi_form_mcr(opcode, port, offset & MBI_MASK_LO);\n\tmcrx = offset & MBI_MASK_HI;\n\n\tspin_lock_irqsave(&iosf_mbi_lock, flags);\n\tret = iosf_mbi_pci_read_mdr(mcrx, mcr, mdr);\n\tspin_unlock_irqrestore(&iosf_mbi_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(iosf_mbi_read);\n\nint iosf_mbi_write(u8 port, u8 opcode, u32 offset, u32 mdr)\n{\n\tu32 mcr, mcrx;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tif (port == BT_MBI_UNIT_GFX) {\n\t\tWARN_ON(1);\n\t\treturn -EPERM;\n\t}\n\n\tmcr = iosf_mbi_form_mcr(opcode, port, offset & MBI_MASK_LO);\n\tmcrx = offset & MBI_MASK_HI;\n\n\tspin_lock_irqsave(&iosf_mbi_lock, flags);\n\tret = iosf_mbi_pci_write_mdr(mcrx, mcr, mdr);\n\tspin_unlock_irqrestore(&iosf_mbi_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(iosf_mbi_write);\n\nint iosf_mbi_modify(u8 port, u8 opcode, u32 offset, u32 mdr, u32 mask)\n{\n\tu32 mcr, mcrx;\n\tu32 value;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tif (port == BT_MBI_UNIT_GFX) {\n\t\tWARN_ON(1);\n\t\treturn -EPERM;\n\t}\n\n\tmcr = iosf_mbi_form_mcr(opcode, port, offset & MBI_MASK_LO);\n\tmcrx = offset & MBI_MASK_HI;\n\n\tspin_lock_irqsave(&iosf_mbi_lock, flags);\n\n\t \n\tret = iosf_mbi_pci_read_mdr(mcrx, mcr & MBI_RD_MASK, &value);\n\tif (ret < 0) {\n\t\tspin_unlock_irqrestore(&iosf_mbi_lock, flags);\n\t\treturn ret;\n\t}\n\n\t \n\tvalue &= ~mask;\n\tmdr &= mask;\n\tvalue |= mdr;\n\n\t \n\tret = iosf_mbi_pci_write_mdr(mcrx, mcr | MBI_WR_MASK, value);\n\n\tspin_unlock_irqrestore(&iosf_mbi_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(iosf_mbi_modify);\n\nbool iosf_mbi_available(void)\n{\n\t \n\treturn mbi_pdev;\n}\nEXPORT_SYMBOL(iosf_mbi_available);\n\n \n\n#define SEMAPHORE_TIMEOUT\t\t500\n#define PUNIT_SEMAPHORE_BYT\t\t0x7\n#define PUNIT_SEMAPHORE_CHT\t\t0x10e\n#define PUNIT_SEMAPHORE_BIT\t\tBIT(0)\n#define PUNIT_SEMAPHORE_ACQUIRE\t\tBIT(1)\n\nstatic DEFINE_MUTEX(iosf_mbi_pmic_access_mutex);\nstatic BLOCKING_NOTIFIER_HEAD(iosf_mbi_pmic_bus_access_notifier);\nstatic DECLARE_WAIT_QUEUE_HEAD(iosf_mbi_pmic_access_waitq);\nstatic u32 iosf_mbi_pmic_punit_access_count;\nstatic u32 iosf_mbi_pmic_i2c_access_count;\nstatic u32 iosf_mbi_sem_address;\nstatic unsigned long iosf_mbi_sem_acquired;\nstatic struct pm_qos_request iosf_mbi_pm_qos;\n\nvoid iosf_mbi_punit_acquire(void)\n{\n\t \n\tmutex_lock(&iosf_mbi_pmic_access_mutex);\n\twhile (iosf_mbi_pmic_i2c_access_count != 0) {\n\t\tmutex_unlock(&iosf_mbi_pmic_access_mutex);\n\t\twait_event(iosf_mbi_pmic_access_waitq,\n\t\t\t   iosf_mbi_pmic_i2c_access_count == 0);\n\t\tmutex_lock(&iosf_mbi_pmic_access_mutex);\n\t}\n\t \n\tiosf_mbi_pmic_punit_access_count++;\n\tmutex_unlock(&iosf_mbi_pmic_access_mutex);\n}\nEXPORT_SYMBOL(iosf_mbi_punit_acquire);\n\nvoid iosf_mbi_punit_release(void)\n{\n\tbool do_wakeup;\n\n\tmutex_lock(&iosf_mbi_pmic_access_mutex);\n\tiosf_mbi_pmic_punit_access_count--;\n\tdo_wakeup = iosf_mbi_pmic_punit_access_count == 0;\n\tmutex_unlock(&iosf_mbi_pmic_access_mutex);\n\n\tif (do_wakeup)\n\t\twake_up(&iosf_mbi_pmic_access_waitq);\n}\nEXPORT_SYMBOL(iosf_mbi_punit_release);\n\nstatic int iosf_mbi_get_sem(u32 *sem)\n{\n\tint ret;\n\n\tret = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\n\t\t\t    iosf_mbi_sem_address, sem);\n\tif (ret) {\n\t\tdev_err(&mbi_pdev->dev, \"Error P-Unit semaphore read failed\\n\");\n\t\treturn ret;\n\t}\n\n\t*sem &= PUNIT_SEMAPHORE_BIT;\n\treturn 0;\n}\n\nstatic void iosf_mbi_reset_semaphore(void)\n{\n\tif (iosf_mbi_modify(BT_MBI_UNIT_PMC, MBI_REG_READ,\n\t\t\t    iosf_mbi_sem_address, 0, PUNIT_SEMAPHORE_BIT))\n\t\tdev_err(&mbi_pdev->dev, \"Error P-Unit semaphore reset failed\\n\");\n\n\tcpu_latency_qos_update_request(&iosf_mbi_pm_qos, PM_QOS_DEFAULT_VALUE);\n\n\tblocking_notifier_call_chain(&iosf_mbi_pmic_bus_access_notifier,\n\t\t\t\t     MBI_PMIC_BUS_ACCESS_END, NULL);\n}\n\n \nint iosf_mbi_block_punit_i2c_access(void)\n{\n\tunsigned long start, end;\n\tint ret = 0;\n\tu32 sem;\n\n\tif (WARN_ON(!mbi_pdev || !iosf_mbi_sem_address))\n\t\treturn -ENXIO;\n\n\tmutex_lock(&iosf_mbi_pmic_access_mutex);\n\n\twhile (iosf_mbi_pmic_punit_access_count != 0) {\n\t\tmutex_unlock(&iosf_mbi_pmic_access_mutex);\n\t\twait_event(iosf_mbi_pmic_access_waitq,\n\t\t\t   iosf_mbi_pmic_punit_access_count == 0);\n\t\tmutex_lock(&iosf_mbi_pmic_access_mutex);\n\t}\n\n\tif (iosf_mbi_pmic_i2c_access_count > 0)\n\t\tgoto success;\n\n\tblocking_notifier_call_chain(&iosf_mbi_pmic_bus_access_notifier,\n\t\t\t\t     MBI_PMIC_BUS_ACCESS_BEGIN, NULL);\n\n\t \n\tcpu_latency_qos_update_request(&iosf_mbi_pm_qos, 0);\n\n\t \n\tret = iosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\n\t\t\t     iosf_mbi_sem_address, PUNIT_SEMAPHORE_ACQUIRE);\n\tif (ret) {\n\t\tdev_err(&mbi_pdev->dev, \"Error P-Unit semaphore request failed\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tstart = jiffies;\n\tend = start + msecs_to_jiffies(SEMAPHORE_TIMEOUT);\n\tdo {\n\t\tret = iosf_mbi_get_sem(&sem);\n\t\tif (!ret && sem) {\n\t\t\tiosf_mbi_sem_acquired = jiffies;\n\t\t\tdev_dbg(&mbi_pdev->dev, \"P-Unit semaphore acquired after %ums\\n\",\n\t\t\t\tjiffies_to_msecs(jiffies - start));\n\t\t\tgoto success;\n\t\t}\n\n\t\tusleep_range(1000, 2000);\n\t} while (time_before(jiffies, end));\n\n\tret = -ETIMEDOUT;\n\tdev_err(&mbi_pdev->dev, \"Error P-Unit semaphore timed out, resetting\\n\");\nerror:\n\tiosf_mbi_reset_semaphore();\n\tif (!iosf_mbi_get_sem(&sem))\n\t\tdev_err(&mbi_pdev->dev, \"P-Unit semaphore: %d\\n\", sem);\nsuccess:\n\tif (!WARN_ON(ret))\n\t\tiosf_mbi_pmic_i2c_access_count++;\n\n\tmutex_unlock(&iosf_mbi_pmic_access_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(iosf_mbi_block_punit_i2c_access);\n\nvoid iosf_mbi_unblock_punit_i2c_access(void)\n{\n\tbool do_wakeup = false;\n\n\tmutex_lock(&iosf_mbi_pmic_access_mutex);\n\tiosf_mbi_pmic_i2c_access_count--;\n\tif (iosf_mbi_pmic_i2c_access_count == 0) {\n\t\tiosf_mbi_reset_semaphore();\n\t\tdev_dbg(&mbi_pdev->dev, \"punit semaphore held for %ums\\n\",\n\t\t\tjiffies_to_msecs(jiffies - iosf_mbi_sem_acquired));\n\t\tdo_wakeup = true;\n\t}\n\tmutex_unlock(&iosf_mbi_pmic_access_mutex);\n\n\tif (do_wakeup)\n\t\twake_up(&iosf_mbi_pmic_access_waitq);\n}\nEXPORT_SYMBOL(iosf_mbi_unblock_punit_i2c_access);\n\nint iosf_mbi_register_pmic_bus_access_notifier(struct notifier_block *nb)\n{\n\tint ret;\n\n\t \n\tiosf_mbi_punit_acquire();\n\tret = blocking_notifier_chain_register(\n\t\t\t\t&iosf_mbi_pmic_bus_access_notifier, nb);\n\tiosf_mbi_punit_release();\n\n\treturn ret;\n}\nEXPORT_SYMBOL(iosf_mbi_register_pmic_bus_access_notifier);\n\nint iosf_mbi_unregister_pmic_bus_access_notifier_unlocked(\n\tstruct notifier_block *nb)\n{\n\tiosf_mbi_assert_punit_acquired();\n\n\treturn blocking_notifier_chain_unregister(\n\t\t\t\t&iosf_mbi_pmic_bus_access_notifier, nb);\n}\nEXPORT_SYMBOL(iosf_mbi_unregister_pmic_bus_access_notifier_unlocked);\n\nint iosf_mbi_unregister_pmic_bus_access_notifier(struct notifier_block *nb)\n{\n\tint ret;\n\n\t \n\tiosf_mbi_punit_acquire();\n\tret = iosf_mbi_unregister_pmic_bus_access_notifier_unlocked(nb);\n\tiosf_mbi_punit_release();\n\n\treturn ret;\n}\nEXPORT_SYMBOL(iosf_mbi_unregister_pmic_bus_access_notifier);\n\nvoid iosf_mbi_assert_punit_acquired(void)\n{\n\tWARN_ON(iosf_mbi_pmic_punit_access_count == 0);\n}\nEXPORT_SYMBOL(iosf_mbi_assert_punit_acquired);\n\n \n\n#ifdef CONFIG_IOSF_MBI_DEBUG\nstatic u32\tdbg_mdr;\nstatic u32\tdbg_mcr;\nstatic u32\tdbg_mcrx;\n\nstatic int mcr_get(void *data, u64 *val)\n{\n\t*val = *(u32 *)data;\n\treturn 0;\n}\n\nstatic int mcr_set(void *data, u64 val)\n{\n\tu8 command = ((u32)val & 0xFF000000) >> 24,\n\t   port\t   = ((u32)val & 0x00FF0000) >> 16,\n\t   offset  = ((u32)val & 0x0000FF00) >> 8;\n\tint err;\n\n\t*(u32 *)data = val;\n\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EACCES;\n\n\tif (command & 1u)\n\t\terr = iosf_mbi_write(port,\n\t\t\t       command,\n\t\t\t       dbg_mcrx | offset,\n\t\t\t       dbg_mdr);\n\telse\n\t\terr = iosf_mbi_read(port,\n\t\t\t      command,\n\t\t\t      dbg_mcrx | offset,\n\t\t\t      &dbg_mdr);\n\n\treturn err;\n}\nDEFINE_SIMPLE_ATTRIBUTE(iosf_mcr_fops, mcr_get, mcr_set , \"%llx\\n\");\n\nstatic struct dentry *iosf_dbg;\n\nstatic void iosf_sideband_debug_init(void)\n{\n\tiosf_dbg = debugfs_create_dir(\"iosf_sb\", NULL);\n\n\t \n\tdebugfs_create_x32(\"mdr\", 0660, iosf_dbg, &dbg_mdr);\n\n\t \n\tdebugfs_create_x32(\"mcrx\", 0660, iosf_dbg, &dbg_mcrx);\n\n\t \n\tdebugfs_create_file(\"mcr\", 0660, iosf_dbg, &dbg_mcr, &iosf_mcr_fops);\n}\n\nstatic void iosf_debugfs_init(void)\n{\n\tiosf_sideband_debug_init();\n}\n\nstatic void iosf_debugfs_remove(void)\n{\n\tdebugfs_remove_recursive(iosf_dbg);\n}\n#else\nstatic inline void iosf_debugfs_init(void) { }\nstatic inline void iosf_debugfs_remove(void) { }\n#endif  \n\nstatic int iosf_mbi_probe(struct pci_dev *pdev,\n\t\t\t  const struct pci_device_id *dev_id)\n{\n\tint ret;\n\n\tret = pci_enable_device(pdev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"error: could not enable device\\n\");\n\t\treturn ret;\n\t}\n\n\tmbi_pdev = pci_dev_get(pdev);\n\tiosf_mbi_sem_address = dev_id->driver_data;\n\n\treturn 0;\n}\n\nstatic const struct pci_device_id iosf_mbi_pci_ids[] = {\n\t{ PCI_DEVICE_DATA(INTEL, BAYTRAIL, PUNIT_SEMAPHORE_BYT) },\n\t{ PCI_DEVICE_DATA(INTEL, BRASWELL, PUNIT_SEMAPHORE_CHT) },\n\t{ PCI_DEVICE_DATA(INTEL, QUARK_X1000, 0) },\n\t{ PCI_DEVICE_DATA(INTEL, TANGIER, 0) },\n\t{ 0, },\n};\nMODULE_DEVICE_TABLE(pci, iosf_mbi_pci_ids);\n\nstatic struct pci_driver iosf_mbi_pci_driver = {\n\t.name\t\t= \"iosf_mbi_pci\",\n\t.probe\t\t= iosf_mbi_probe,\n\t.id_table\t= iosf_mbi_pci_ids,\n};\n\nstatic int __init iosf_mbi_init(void)\n{\n\tiosf_debugfs_init();\n\n\tcpu_latency_qos_add_request(&iosf_mbi_pm_qos, PM_QOS_DEFAULT_VALUE);\n\n\treturn pci_register_driver(&iosf_mbi_pci_driver);\n}\n\nstatic void __exit iosf_mbi_exit(void)\n{\n\tiosf_debugfs_remove();\n\n\tpci_unregister_driver(&iosf_mbi_pci_driver);\n\tpci_dev_put(mbi_pdev);\n\tmbi_pdev = NULL;\n\n\tcpu_latency_qos_remove_request(&iosf_mbi_pm_qos);\n}\n\nmodule_init(iosf_mbi_init);\nmodule_exit(iosf_mbi_exit);\n\nMODULE_AUTHOR(\"David E. Box <david.e.box@linux.intel.com>\");\nMODULE_DESCRIPTION(\"IOSF Mailbox Interface accessor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}