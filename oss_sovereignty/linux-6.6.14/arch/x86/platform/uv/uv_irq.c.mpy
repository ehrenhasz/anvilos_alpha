{
  "module_name": "uv_irq.c",
  "hash_id": "df9ed207b4e44aad05168ebdd911cddd2134918021111c9452c2982845704d4b",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/uv/uv_irq.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\n#include <asm/irqdomain.h>\n#include <asm/apic.h>\n#include <asm/uv/uv_irq.h>\n#include <asm/uv/uv_hub.h>\n\n \nstruct uv_irq_2_mmr_pnode {\n\tunsigned long\t\toffset;\n\tint\t\t\tpnode;\n};\n\nstatic void uv_program_mmr(struct irq_cfg *cfg, struct uv_irq_2_mmr_pnode *info)\n{\n\tunsigned long mmr_value;\n\tstruct uv_IO_APIC_route_entry *entry;\n\n\tBUILD_BUG_ON(sizeof(struct uv_IO_APIC_route_entry) !=\n\t\t     sizeof(unsigned long));\n\n\tmmr_value = 0;\n\tentry = (struct uv_IO_APIC_route_entry *)&mmr_value;\n\tentry->vector\t\t= cfg->vector;\n\tentry->delivery_mode\t= apic->delivery_mode;\n\tentry->dest_mode\t= apic->dest_mode_logical;\n\tentry->polarity\t\t= 0;\n\tentry->trigger\t\t= 0;\n\tentry->mask\t\t= 0;\n\tentry->dest\t\t= cfg->dest_apicid;\n\n\tuv_write_global_mmr64(info->pnode, info->offset, mmr_value);\n}\n\nstatic void uv_noop(struct irq_data *data) { }\n\nstatic int\nuv_set_irq_affinity(struct irq_data *data, const struct cpumask *mask,\n\t\t    bool force)\n{\n\tstruct irq_data *parent = data->parent_data;\n\tstruct irq_cfg *cfg = irqd_cfg(data);\n\tint ret;\n\n\tret = parent->chip->irq_set_affinity(parent, mask, force);\n\tif (ret >= 0) {\n\t\tuv_program_mmr(cfg, data->chip_data);\n\t\tvector_schedule_cleanup(cfg);\n\t}\n\n\treturn ret;\n}\n\nstatic struct irq_chip uv_irq_chip = {\n\t.name\t\t\t= \"UV-CORE\",\n\t.irq_mask\t\t= uv_noop,\n\t.irq_unmask\t\t= uv_noop,\n\t.irq_eoi\t\t= apic_ack_irq,\n\t.irq_set_affinity\t= uv_set_irq_affinity,\n};\n\nstatic int uv_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t   unsigned int nr_irqs, void *arg)\n{\n\tstruct uv_irq_2_mmr_pnode *chip_data;\n\tstruct irq_alloc_info *info = arg;\n\tstruct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);\n\tint ret;\n\n\tif (nr_irqs > 1 || !info || info->type != X86_IRQ_ALLOC_TYPE_UV)\n\t\treturn -EINVAL;\n\n\tchip_data = kmalloc_node(sizeof(*chip_data), GFP_KERNEL,\n\t\t\t\t irq_data_get_node(irq_data));\n\tif (!chip_data)\n\t\treturn -ENOMEM;\n\n\tret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, arg);\n\tif (ret >= 0) {\n\t\tif (info->uv.limit == UV_AFFINITY_CPU)\n\t\t\tirq_set_status_flags(virq, IRQ_NO_BALANCING);\n\t\telse\n\t\t\tirq_set_status_flags(virq, IRQ_MOVE_PCNTXT);\n\n\t\tchip_data->pnode = uv_blade_to_pnode(info->uv.blade);\n\t\tchip_data->offset = info->uv.offset;\n\t\tirq_domain_set_info(domain, virq, virq, &uv_irq_chip, chip_data,\n\t\t\t\t    handle_percpu_irq, NULL, info->uv.name);\n\t} else {\n\t\tkfree(chip_data);\n\t}\n\n\treturn ret;\n}\n\nstatic void uv_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t   unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);\n\n\tBUG_ON(nr_irqs != 1);\n\tkfree(irq_data->chip_data);\n\tirq_clear_status_flags(virq, IRQ_MOVE_PCNTXT);\n\tirq_clear_status_flags(virq, IRQ_NO_BALANCING);\n\tirq_domain_free_irqs_top(domain, virq, nr_irqs);\n}\n\n \nstatic int uv_domain_activate(struct irq_domain *domain,\n\t\t\t      struct irq_data *irq_data, bool reserve)\n{\n\tuv_program_mmr(irqd_cfg(irq_data), irq_data->chip_data);\n\treturn 0;\n}\n\n \nstatic void uv_domain_deactivate(struct irq_domain *domain,\n\t\t\t\t struct irq_data *irq_data)\n{\n\tunsigned long mmr_value;\n\tstruct uv_IO_APIC_route_entry *entry;\n\n\tmmr_value = 0;\n\tentry = (struct uv_IO_APIC_route_entry *)&mmr_value;\n\tentry->mask = 1;\n\tuv_program_mmr(irqd_cfg(irq_data), irq_data->chip_data);\n}\n\nstatic const struct irq_domain_ops uv_domain_ops = {\n\t.alloc\t\t= uv_domain_alloc,\n\t.free\t\t= uv_domain_free,\n\t.activate\t= uv_domain_activate,\n\t.deactivate\t= uv_domain_deactivate,\n};\n\nstatic struct irq_domain *uv_get_irq_domain(void)\n{\n\tstatic struct irq_domain *uv_domain;\n\tstatic DEFINE_MUTEX(uv_lock);\n\tstruct fwnode_handle *fn;\n\n\tmutex_lock(&uv_lock);\n\tif (uv_domain)\n\t\tgoto out;\n\n\tfn = irq_domain_alloc_named_fwnode(\"UV-CORE\");\n\tif (!fn)\n\t\tgoto out;\n\n\tuv_domain = irq_domain_create_hierarchy(x86_vector_domain, 0, 0, fn,\n\t\t\t\t\t\t&uv_domain_ops, NULL);\n\tif (!uv_domain)\n\t\tirq_domain_free_fwnode(fn);\nout:\n\tmutex_unlock(&uv_lock);\n\n\treturn uv_domain;\n}\n\n \nint uv_setup_irq(char *irq_name, int cpu, int mmr_blade,\n\t\t unsigned long mmr_offset, int limit)\n{\n\tstruct irq_alloc_info info;\n\tstruct irq_domain *domain = uv_get_irq_domain();\n\n\tif (!domain)\n\t\treturn -ENOMEM;\n\n\tinit_irq_alloc_info(&info, cpumask_of(cpu));\n\tinfo.type = X86_IRQ_ALLOC_TYPE_UV;\n\tinfo.uv.limit = limit;\n\tinfo.uv.blade = mmr_blade;\n\tinfo.uv.offset = mmr_offset;\n\tinfo.uv.name = irq_name;\n\n\treturn irq_domain_alloc_irqs(domain, 1,\n\t\t\t\t     uv_blade_to_memory_nid(mmr_blade), &info);\n}\nEXPORT_SYMBOL_GPL(uv_setup_irq);\n\n \nvoid uv_teardown_irq(unsigned int irq)\n{\n\tirq_domain_free_irqs(irq, 1);\n}\nEXPORT_SYMBOL_GPL(uv_teardown_irq);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}