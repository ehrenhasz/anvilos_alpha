{
  "module_name": "bios_uv.c",
  "hash_id": "b399b87b1aa6776df174920f35430dd9c42384e609400e25b3d1f7581ddcdf1a",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/uv/bios_uv.c",
  "human_readable_source": "\n \n\n#include <linux/efi.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <asm/efi.h>\n#include <linux/io.h>\n#include <asm/pgalloc.h>\n#include <asm/uv/bios.h>\n#include <asm/uv/uv_hub.h>\n\nunsigned long uv_systab_phys __ro_after_init = EFI_INVALID_TABLE_ADDR;\n\nstruct uv_systab *uv_systab;\n\nstatic s64 __uv_bios_call(enum uv_bios_cmd which, u64 a1, u64 a2, u64 a3,\n\t\t\tu64 a4, u64 a5)\n{\n\tstruct uv_systab *tab = uv_systab;\n\ts64 ret;\n\n\tif (!tab || !tab->function)\n\t\t \n\t\treturn BIOS_STATUS_UNIMPLEMENTED;\n\n\tret = efi_call_virt_pointer(tab, function, (u64)which, a1, a2, a3, a4, a5);\n\n\treturn ret;\n}\n\nstatic s64 uv_bios_call(enum uv_bios_cmd which, u64 a1, u64 a2, u64 a3, u64 a4,\n\t\tu64 a5)\n{\n\ts64 ret;\n\n\tif (down_interruptible(&__efi_uv_runtime_lock))\n\t\treturn BIOS_STATUS_ABORT;\n\n\tret = __uv_bios_call(which, a1, a2, a3, a4, a5);\n\tup(&__efi_uv_runtime_lock);\n\n\treturn ret;\n}\n\nstatic s64 uv_bios_call_irqsave(enum uv_bios_cmd which, u64 a1, u64 a2, u64 a3,\n\t\tu64 a4, u64 a5)\n{\n\tunsigned long bios_flags;\n\ts64 ret;\n\n\tif (down_interruptible(&__efi_uv_runtime_lock))\n\t\treturn BIOS_STATUS_ABORT;\n\n\tlocal_irq_save(bios_flags);\n\tret = __uv_bios_call(which, a1, a2, a3, a4, a5);\n\tlocal_irq_restore(bios_flags);\n\n\tup(&__efi_uv_runtime_lock);\n\n\treturn ret;\n}\n\nlong sn_partition_id;\nEXPORT_SYMBOL_GPL(sn_partition_id);\nlong sn_coherency_id;\nEXPORT_SYMBOL_GPL(sn_coherency_id);\nlong sn_region_size;\nEXPORT_SYMBOL_GPL(sn_region_size);\nlong system_serial_number;\nint uv_type;\n\ns64 uv_bios_get_sn_info(int fc, int *uvtype, long *partid, long *coher,\n\t\tlong *region, long *ssn)\n{\n\ts64 ret;\n\tu64 v0, v1;\n\tunion partition_info_u part;\n\n\tret = uv_bios_call_irqsave(UV_BIOS_GET_SN_INFO, fc,\n\t\t\t\t(u64)(&v0), (u64)(&v1), 0, 0);\n\tif (ret != BIOS_STATUS_SUCCESS)\n\t\treturn ret;\n\n\tpart.val = v0;\n\tif (uvtype)\n\t\t*uvtype = part.hub_version;\n\tif (partid)\n\t\t*partid = part.partition_id;\n\tif (coher)\n\t\t*coher = part.coherence_id;\n\tif (region)\n\t\t*region = part.region_size;\n\tif (ssn)\n\t\t*ssn = v1;\n\treturn ret;\n}\n\nint\nuv_bios_mq_watchlist_alloc(unsigned long addr, unsigned int mq_size,\n\t\t\t   unsigned long *intr_mmr_offset)\n{\n\tu64 watchlist;\n\ts64 ret;\n\n\t \n\tret = (int)uv_bios_call_irqsave(UV_BIOS_WATCHLIST_ALLOC, addr,\n\t\t\tmq_size, (u64)intr_mmr_offset,\n\t\t\t(u64)&watchlist, 0);\n\tif (ret < BIOS_STATUS_SUCCESS)\n\t\treturn ret;\n\n\treturn watchlist;\n}\nEXPORT_SYMBOL_GPL(uv_bios_mq_watchlist_alloc);\n\nint\nuv_bios_mq_watchlist_free(int blade, int watchlist_num)\n{\n\treturn (int)uv_bios_call_irqsave(UV_BIOS_WATCHLIST_FREE,\n\t\t\t\tblade, watchlist_num, 0, 0, 0);\n}\nEXPORT_SYMBOL_GPL(uv_bios_mq_watchlist_free);\n\ns64\nuv_bios_change_memprotect(u64 paddr, u64 len, enum uv_memprotect perms)\n{\n\treturn uv_bios_call_irqsave(UV_BIOS_MEMPROTECT, paddr, len,\n\t\t\t\t\tperms, 0, 0);\n}\nEXPORT_SYMBOL_GPL(uv_bios_change_memprotect);\n\ns64\nuv_bios_reserved_page_pa(u64 buf, u64 *cookie, u64 *addr, u64 *len)\n{\n\treturn uv_bios_call_irqsave(UV_BIOS_GET_PARTITION_ADDR, (u64)cookie,\n\t\t\t\t    (u64)addr, buf, (u64)len, 0);\n}\nEXPORT_SYMBOL_GPL(uv_bios_reserved_page_pa);\n\ns64 uv_bios_freq_base(u64 clock_type, u64 *ticks_per_second)\n{\n\treturn uv_bios_call(UV_BIOS_FREQ_BASE, clock_type,\n\t\t\t   (u64)ticks_per_second, 0, 0, 0);\n}\n\n \nint uv_bios_set_legacy_vga_target(bool decode, int domain, int bus)\n{\n\treturn uv_bios_call(UV_BIOS_SET_LEGACY_VGA_TARGET,\n\t\t\t\t(u64)decode, (u64)domain, (u64)bus, 0, 0);\n}\n\nextern s64 uv_bios_get_master_nasid(u64 size, u64 *master_nasid)\n{\n\treturn uv_bios_call(UV_BIOS_EXTRA, 0, UV_BIOS_EXTRA_MASTER_NASID, 0,\n\t\t\t\tsize, (u64)master_nasid);\n}\nEXPORT_SYMBOL_GPL(uv_bios_get_master_nasid);\n\nextern s64 uv_bios_get_heapsize(u64 nasid, u64 size, u64 *heap_size)\n{\n\treturn uv_bios_call(UV_BIOS_EXTRA, nasid, UV_BIOS_EXTRA_GET_HEAPSIZE,\n\t\t\t\t0, size, (u64)heap_size);\n}\nEXPORT_SYMBOL_GPL(uv_bios_get_heapsize);\n\nextern s64 uv_bios_install_heap(u64 nasid, u64 heap_size, u64 *bios_heap)\n{\n\treturn uv_bios_call(UV_BIOS_EXTRA, nasid, UV_BIOS_EXTRA_INSTALL_HEAP,\n\t\t\t\t0, heap_size, (u64)bios_heap);\n}\nEXPORT_SYMBOL_GPL(uv_bios_install_heap);\n\nextern s64 uv_bios_obj_count(u64 nasid, u64 size, u64 *objcnt)\n{\n\treturn uv_bios_call(UV_BIOS_EXTRA, nasid, UV_BIOS_EXTRA_OBJECT_COUNT,\n\t\t\t\t0, size, (u64)objcnt);\n}\nEXPORT_SYMBOL_GPL(uv_bios_obj_count);\n\nextern s64 uv_bios_enum_objs(u64 nasid, u64 size, u64 *objbuf)\n{\n\treturn uv_bios_call(UV_BIOS_EXTRA, nasid, UV_BIOS_EXTRA_ENUM_OBJECTS,\n\t\t\t\t0, size, (u64)objbuf);\n}\nEXPORT_SYMBOL_GPL(uv_bios_enum_objs);\n\nextern s64 uv_bios_enum_ports(u64 nasid, u64 obj_id, u64 size, u64 *portbuf)\n{\n\treturn uv_bios_call(UV_BIOS_EXTRA, nasid, UV_BIOS_EXTRA_ENUM_PORTS,\n\t\t\t\tobj_id, size, (u64)portbuf);\n}\nEXPORT_SYMBOL_GPL(uv_bios_enum_ports);\n\nextern s64 uv_bios_get_geoinfo(u64 nasid, u64 size, u64 *buf)\n{\n\treturn uv_bios_call(UV_BIOS_GET_GEOINFO, nasid, (u64)buf, size, 0, 0);\n}\nEXPORT_SYMBOL_GPL(uv_bios_get_geoinfo);\n\nextern s64 uv_bios_get_pci_topology(u64 size, u64 *buf)\n{\n\treturn uv_bios_call(UV_BIOS_GET_PCI_TOPOLOGY, (u64)buf, size, 0, 0, 0);\n}\nEXPORT_SYMBOL_GPL(uv_bios_get_pci_topology);\n\nunsigned long get_uv_systab_phys(bool msg)\n{\n\tif ((uv_systab_phys == EFI_INVALID_TABLE_ADDR) ||\n\t    !uv_systab_phys || efi_runtime_disabled()) {\n\t\tif (msg)\n\t\t\tpr_crit(\"UV: UVsystab: missing\\n\");\n\t\treturn 0;\n\t}\n\treturn uv_systab_phys;\n}\n\nint uv_bios_init(void)\n{\n\tunsigned long uv_systab_phys_addr;\n\n\tuv_systab = NULL;\n\tuv_systab_phys_addr = get_uv_systab_phys(1);\n\tif (!uv_systab_phys_addr)\n\t\treturn -EEXIST;\n\n\tuv_systab = ioremap(uv_systab_phys_addr, sizeof(struct uv_systab));\n\tif (!uv_systab || strncmp(uv_systab->signature, UV_SYSTAB_SIG, 4)) {\n\t\tpr_err(\"UV: UVsystab: bad signature!\\n\");\n\t\tiounmap(uv_systab);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (uv_systab->revision >= UV_SYSTAB_VERSION_UV4) {\n\t\tint size = uv_systab->size;\n\n\t\tiounmap(uv_systab);\n\t\tuv_systab = ioremap(uv_systab_phys_addr, size);\n\t\tif (!uv_systab) {\n\t\t\tpr_err(\"UV: UVsystab: ioremap(%d) failed!\\n\", size);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tpr_info(\"UV: UVsystab: Revision:%x\\n\", uv_systab->revision);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}