{
  "module_name": "ce4100.c",
  "hash_id": "31565758712b990b129fbabcfe8194240d5738ff9ee73a2a32dae96c6f1c07dc",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/ce4100/ce4100.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/irq.h>\n#include <linux/reboot.h>\n#include <linux/serial_reg.h>\n#include <linux/serial_8250.h>\n\n#include <asm/ce4100.h>\n#include <asm/prom.h>\n#include <asm/setup.h>\n#include <asm/i8259.h>\n#include <asm/io.h>\n#include <asm/io_apic.h>\n#include <asm/emergency-restart.h>\n\n \nstatic void ce4100_power_off(void)\n{\n\toutb(0x4, 0xcf9);\n}\n\n#ifdef CONFIG_SERIAL_8250\n\nstatic unsigned int mem_serial_in(struct uart_port *p, int offset)\n{\n\toffset = offset << p->regshift;\n\treturn readl(p->membase + offset);\n}\n\n \n\nstatic unsigned int ce4100_mem_serial_in(struct uart_port *p, int offset)\n{\n\tunsigned int ret, ier, lsr;\n\n\tif (offset == UART_IIR) {\n\t\toffset = offset << p->regshift;\n\t\tret = readl(p->membase + offset);\n\t\tif (ret & UART_IIR_NO_INT) {\n\t\t\t \n\t\t\tier = mem_serial_in(p, UART_IER);\n\t\t\t \n\t\t\tif (ier & UART_IER_THRI) {\n\t\t\t\tlsr = mem_serial_in(p, UART_LSR);\n\t\t\t\t \n\t\t\t\tif (lsr & (UART_LSR_THRE | UART_LSR_TEMT))\n\t\t\t\t\tret &= ~UART_IIR_NO_INT;\n\t\t\t}\n\t\t}\n\t} else\n\t\tret =  mem_serial_in(p, offset);\n\treturn ret;\n}\n\nstatic void ce4100_mem_serial_out(struct uart_port *p, int offset, int value)\n{\n\toffset = offset << p->regshift;\n\twritel(value, p->membase + offset);\n}\n\nstatic void ce4100_serial_fixup(int port, struct uart_port *up,\n\tu32 *capabilities)\n{\n#ifdef CONFIG_EARLY_PRINTK\n\t \n\tif (up->iotype !=  UPIO_MEM32) {\n\t\tup->uartclk  = 14745600;\n\t\tup->mapbase = 0xdffe0200;\n\t\tset_fixmap_nocache(FIX_EARLYCON_MEM_BASE,\n\t\t\t\tup->mapbase & PAGE_MASK);\n\t\tup->membase =\n\t\t\t(void __iomem *)__fix_to_virt(FIX_EARLYCON_MEM_BASE);\n\t\tup->membase += up->mapbase & ~PAGE_MASK;\n\t\tup->mapbase += port * 0x100;\n\t\tup->membase += port * 0x100;\n\t\tup->iotype   = UPIO_MEM32;\n\t\tup->regshift = 2;\n\t\tup->irq = 4;\n\t}\n#endif\n\tup->iobase = 0;\n\tup->serial_in = ce4100_mem_serial_in;\n\tup->serial_out = ce4100_mem_serial_out;\n\n\t*capabilities |= (1 << 12);\n}\n\nstatic __init void sdv_serial_fixup(void)\n{\n\tserial8250_set_isa_configurator(ce4100_serial_fixup);\n}\n\n#else\nstatic inline void sdv_serial_fixup(void) {};\n#endif\n\nstatic void __init sdv_arch_setup(void)\n{\n\tsdv_serial_fixup();\n}\n\nstatic void sdv_pci_init(void)\n{\n\tx86_of_pci_init();\n}\n\n \nvoid __init x86_ce4100_early_setup(void)\n{\n\tx86_init.oem.arch_setup = sdv_arch_setup;\n\tx86_init.resources.probe_roms = x86_init_noop;\n\tx86_init.mpparse.get_smp_config = x86_init_uint_noop;\n\tx86_init.mpparse.find_smp_config = x86_init_noop;\n\tx86_init.mpparse.setup_ioapic_ids = setup_ioapic_ids_from_mpc_nocheck;\n\tx86_init.pci.init = ce4100_pci_init;\n\tx86_init.pci.init_irq = sdv_pci_init;\n\n\t \n\treboot_type = BOOT_KBD;\n\n\tpm_power_off = ce4100_power_off;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}