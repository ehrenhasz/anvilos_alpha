{
  "module_name": "imr_selftest.c",
  "hash_id": "fb43d499db84248158bfecdf6f34ae10d2db1f87adbae0bd4cb65bab83e82ac6",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/intel-quark/imr_selftest.c",
  "human_readable_source": "\n \n\n#include <asm-generic/sections.h>\n#include <asm/cpu_device_id.h>\n#include <asm/imr.h>\n#include <asm/io.h>\n\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/types.h>\n\n#define SELFTEST KBUILD_MODNAME \": \"\n \nstatic __printf(2, 3)\nvoid __init imr_self_test_result(int res, const char *fmt, ...)\n{\n\tva_list vlist;\n\n\t \n\tif (res)\n\t\tpr_info(SELFTEST \"pass \");\n\telse\n\t\tpr_info(SELFTEST \"fail \");\n\n\t \n\tva_start(vlist, fmt);\n\tvprintk(fmt, vlist);\n\tva_end(vlist);\n\n\t \n\tWARN(res == 0, \"test failed\");\n}\n#undef SELFTEST\n\n \nstatic void __init imr_self_test(void)\n{\n\tphys_addr_t base  = virt_to_phys(&_text);\n\tsize_t size = virt_to_phys(&__end_rodata) - base;\n\tconst char *fmt_over = \"overlapped IMR @ (0x%08lx - 0x%08lx)\\n\";\n\tint ret;\n\n\t \n\tret = imr_add_range(0, 0, 0, 0);\n\timr_self_test_result(ret < 0, \"zero sized IMR\\n\");\n\n\t \n\tret = imr_add_range(base, size, IMR_CPU, IMR_CPU);\n\timr_self_test_result(ret < 0, fmt_over, __va(base), __va(base + size));\n\n\t \n\tbase += size - IMR_ALIGN;\n\tret = imr_add_range(base, size, IMR_CPU, IMR_CPU);\n\timr_self_test_result(ret < 0, fmt_over, __va(base), __va(base + size));\n\n\t \n\tbase -= size + IMR_ALIGN * 2;\n\tret = imr_add_range(base, size, IMR_CPU, IMR_CPU);\n\timr_self_test_result(ret < 0, fmt_over, __va(base), __va(base + size));\n\n\t \n\tret = imr_add_range(0, IMR_ALIGN, IMR_READ_ACCESS_ALL,\n\t\t\t    IMR_WRITE_ACCESS_ALL);\n\timr_self_test_result(ret < 0, \"1KiB IMR @ 0x00000000 - access-all\\n\");\n\n\t \n\tret = imr_add_range(0, IMR_ALIGN, IMR_CPU, IMR_CPU);\n\timr_self_test_result(ret >= 0, \"1KiB IMR @ 0x00000000 - cpu-access\\n\");\n\tif (ret >= 0) {\n\t\tret = imr_remove_range(0, IMR_ALIGN);\n\t\timr_self_test_result(ret == 0, \"teardown - cpu-access\\n\");\n\t}\n\n\t \n\tsize = IMR_ALIGN * 2;\n\tret = imr_add_range(0, size, IMR_READ_ACCESS_ALL, IMR_WRITE_ACCESS_ALL);\n\timr_self_test_result(ret >= 0, \"2KiB IMR @ 0x00000000\\n\");\n\tif (ret >= 0) {\n\t\tret = imr_remove_range(0, size);\n\t\timr_self_test_result(ret == 0, \"teardown 2KiB\\n\");\n\t}\n}\n\nstatic const struct x86_cpu_id imr_ids[] __initconst = {\n\tX86_MATCH_VENDOR_FAM_MODEL(INTEL, 5, INTEL_FAM5_QUARK_X1000, NULL),\n\t{}\n};\n\n \nstatic int __init imr_self_test_init(void)\n{\n\tif (x86_match_cpu(imr_ids))\n\t\timr_self_test();\n\treturn 0;\n}\n\n \ndevice_initcall(imr_self_test_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}