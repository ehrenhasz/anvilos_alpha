{
  "module_name": "imr.c",
  "hash_id": "b540865ba24485336ab15cf3c6d2e48c20aeb4c70e7152d4fd534e1158419d52",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/intel-quark/imr.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <asm-generic/sections.h>\n#include <asm/cpu_device_id.h>\n#include <asm/imr.h>\n#include <asm/iosf_mbi.h>\n#include <asm/io.h>\n\n#include <linux/debugfs.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/types.h>\n\nstruct imr_device {\n\tbool\t\tinit;\n\tstruct mutex\tlock;\n\tint\t\tmax_imr;\n\tint\t\treg_base;\n};\n\nstatic struct imr_device imr_dev;\n\n \n#define IMR_LOCK\tBIT(31)\n\nstruct imr_regs {\n\tu32 addr_lo;\n\tu32 addr_hi;\n\tu32 rmask;\n\tu32 wmask;\n};\n\n#define IMR_NUM_REGS\t(sizeof(struct imr_regs)/sizeof(u32))\n#define IMR_SHIFT\t8\n#define imr_to_phys(x)\t((x) << IMR_SHIFT)\n#define phys_to_imr(x)\t((x) >> IMR_SHIFT)\n\n \nstatic inline int imr_is_enabled(struct imr_regs *imr)\n{\n\treturn !(imr->rmask == IMR_READ_ACCESS_ALL &&\n\t\t imr->wmask == IMR_WRITE_ACCESS_ALL &&\n\t\t imr_to_phys(imr->addr_lo) == 0 &&\n\t\t imr_to_phys(imr->addr_hi) == 0);\n}\n\n \nstatic int imr_read(struct imr_device *idev, u32 imr_id, struct imr_regs *imr)\n{\n\tu32 reg = imr_id * IMR_NUM_REGS + idev->reg_base;\n\tint ret;\n\n\tret = iosf_mbi_read(QRK_MBI_UNIT_MM, MBI_REG_READ, reg++, &imr->addr_lo);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iosf_mbi_read(QRK_MBI_UNIT_MM, MBI_REG_READ, reg++, &imr->addr_hi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iosf_mbi_read(QRK_MBI_UNIT_MM, MBI_REG_READ, reg++, &imr->rmask);\n\tif (ret)\n\t\treturn ret;\n\n\treturn iosf_mbi_read(QRK_MBI_UNIT_MM, MBI_REG_READ, reg++, &imr->wmask);\n}\n\n \nstatic int imr_write(struct imr_device *idev, u32 imr_id, struct imr_regs *imr)\n{\n\tunsigned long flags;\n\tu32 reg = imr_id * IMR_NUM_REGS + idev->reg_base;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\n\tret = iosf_mbi_write(QRK_MBI_UNIT_MM, MBI_REG_WRITE, reg++, imr->addr_lo);\n\tif (ret)\n\t\tgoto failed;\n\n\tret = iosf_mbi_write(QRK_MBI_UNIT_MM, MBI_REG_WRITE, reg++, imr->addr_hi);\n\tif (ret)\n\t\tgoto failed;\n\n\tret = iosf_mbi_write(QRK_MBI_UNIT_MM, MBI_REG_WRITE, reg++, imr->rmask);\n\tif (ret)\n\t\tgoto failed;\n\n\tret = iosf_mbi_write(QRK_MBI_UNIT_MM, MBI_REG_WRITE, reg++, imr->wmask);\n\tif (ret)\n\t\tgoto failed;\n\n\tlocal_irq_restore(flags);\n\treturn 0;\nfailed:\n\t \n\tlocal_irq_restore(flags);\n\tWARN(ret, \"IOSF-MBI write fail range 0x%08x-0x%08x unreliable\\n\",\n\t     imr_to_phys(imr->addr_lo), imr_to_phys(imr->addr_hi) + IMR_MASK);\n\n\treturn ret;\n}\n\n \nstatic int imr_dbgfs_state_show(struct seq_file *s, void *unused)\n{\n\tphys_addr_t base;\n\tphys_addr_t end;\n\tint i;\n\tstruct imr_device *idev = s->private;\n\tstruct imr_regs imr;\n\tsize_t size;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&idev->lock);\n\n\tfor (i = 0; i < idev->max_imr; i++) {\n\n\t\tret = imr_read(idev, i, &imr);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tif (imr_is_enabled(&imr)) {\n\t\t\tbase = imr_to_phys(imr.addr_lo);\n\t\t\tend = imr_to_phys(imr.addr_hi) + IMR_MASK;\n\t\t\tsize = end - base + 1;\n\t\t} else {\n\t\t\tbase = 0;\n\t\t\tend = 0;\n\t\t\tsize = 0;\n\t\t}\n\t\tseq_printf(s, \"imr%02i: base=%pa, end=%pa, size=0x%08zx \"\n\t\t\t   \"rmask=0x%08x, wmask=0x%08x, %s, %s\\n\", i,\n\t\t\t   &base, &end, size, imr.rmask, imr.wmask,\n\t\t\t   imr_is_enabled(&imr) ? \"enabled \" : \"disabled\",\n\t\t\t   imr.addr_lo & IMR_LOCK ? \"locked\" : \"unlocked\");\n\t}\n\n\tmutex_unlock(&idev->lock);\n\treturn ret;\n}\nDEFINE_SHOW_ATTRIBUTE(imr_dbgfs_state);\n\n \nstatic void imr_debugfs_register(struct imr_device *idev)\n{\n\tdebugfs_create_file(\"imr_state\", 0444, NULL, idev,\n\t\t\t    &imr_dbgfs_state_fops);\n}\n\n \nstatic int imr_check_params(phys_addr_t base, size_t size)\n{\n\tif ((base & IMR_MASK) || (size & IMR_MASK)) {\n\t\tpr_err(\"base %pa size 0x%08zx must align to 1KiB\\n\",\n\t\t\t&base, size);\n\t\treturn -EINVAL;\n\t}\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic inline size_t imr_raw_size(size_t size)\n{\n\treturn size - IMR_ALIGN;\n}\n\n \nstatic inline int imr_address_overlap(phys_addr_t addr, struct imr_regs *imr)\n{\n\treturn addr >= imr_to_phys(imr->addr_lo) && addr <= imr_to_phys(imr->addr_hi);\n}\n\n \nint imr_add_range(phys_addr_t base, size_t size,\n\t\t  unsigned int rmask, unsigned int wmask)\n{\n\tphys_addr_t end;\n\tunsigned int i;\n\tstruct imr_device *idev = &imr_dev;\n\tstruct imr_regs imr;\n\tsize_t raw_size;\n\tint reg;\n\tint ret;\n\n\tif (WARN_ONCE(idev->init == false, \"driver not initialized\"))\n\t\treturn -ENODEV;\n\n\tret = imr_check_params(base, size);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\traw_size = imr_raw_size(size);\n\tend = base + raw_size;\n\n\t \n\timr.addr_lo = phys_to_imr(base);\n\timr.addr_hi = phys_to_imr(end);\n\timr.rmask = rmask;\n\timr.wmask = wmask;\n\tif (!imr_is_enabled(&imr))\n\t\treturn -ENOTSUPP;\n\n\tmutex_lock(&idev->lock);\n\n\t \n\treg = -1;\n\tfor (i = 0; i < idev->max_imr; i++) {\n\t\tret = imr_read(idev, i, &imr);\n\t\tif (ret)\n\t\t\tgoto failed;\n\n\t\t \n\t\tret = -EINVAL;\n\t\tif (imr_is_enabled(&imr)) {\n\t\t\tif (imr_address_overlap(base, &imr))\n\t\t\t\tgoto failed;\n\t\t\tif (imr_address_overlap(end, &imr))\n\t\t\t\tgoto failed;\n\t\t} else {\n\t\t\treg = i;\n\t\t}\n\t}\n\n\t \n\tif (reg == -1) {\n\t\tret = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tpr_debug(\"add %d phys %pa-%pa size %zx mask 0x%08x wmask 0x%08x\\n\",\n\t\t reg, &base, &end, raw_size, rmask, wmask);\n\n\t \n\timr.addr_lo = phys_to_imr(base);\n\timr.addr_hi = phys_to_imr(end);\n\timr.rmask = rmask;\n\timr.wmask = wmask;\n\n\tret = imr_write(idev, reg, &imr);\n\tif (ret < 0) {\n\t\t \n\t\timr.addr_lo = 0;\n\t\timr.addr_hi = 0;\n\t\timr.rmask = IMR_READ_ACCESS_ALL;\n\t\timr.wmask = IMR_WRITE_ACCESS_ALL;\n\t\timr_write(idev, reg, &imr);\n\t}\nfailed:\n\tmutex_unlock(&idev->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(imr_add_range);\n\n \nstatic int __imr_remove_range(int reg, phys_addr_t base, size_t size)\n{\n\tphys_addr_t end;\n\tbool found = false;\n\tunsigned int i;\n\tstruct imr_device *idev = &imr_dev;\n\tstruct imr_regs imr;\n\tsize_t raw_size;\n\tint ret = 0;\n\n\tif (WARN_ONCE(idev->init == false, \"driver not initialized\"))\n\t\treturn -ENODEV;\n\n\t \n\tif (reg == -1) {\n\t\tret = imr_check_params(base, size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\traw_size = imr_raw_size(size);\n\tend = base + raw_size;\n\n\tmutex_lock(&idev->lock);\n\n\tif (reg >= 0) {\n\t\t \n\t\tret = imr_read(idev, reg, &imr);\n\t\tif (ret)\n\t\t\tgoto failed;\n\n\t\tif (!imr_is_enabled(&imr) || imr.addr_lo & IMR_LOCK) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto failed;\n\t\t}\n\t\tfound = true;\n\t} else {\n\t\t \n\t\tfor (i = 0; i < idev->max_imr; i++) {\n\t\t\tret = imr_read(idev, i, &imr);\n\t\t\tif (ret)\n\t\t\t\tgoto failed;\n\n\t\t\tif (!imr_is_enabled(&imr) || imr.addr_lo & IMR_LOCK)\n\t\t\t\tcontinue;\n\n\t\t\tif ((imr_to_phys(imr.addr_lo) == base) &&\n\t\t\t    (imr_to_phys(imr.addr_hi) == end)) {\n\t\t\t\tfound = true;\n\t\t\t\treg = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tret = -ENODEV;\n\t\tgoto failed;\n\t}\n\n\tpr_debug(\"remove %d phys %pa-%pa size %zx\\n\", reg, &base, &end, raw_size);\n\n\t \n\timr.addr_lo = 0;\n\timr.addr_hi = 0;\n\timr.rmask = IMR_READ_ACCESS_ALL;\n\timr.wmask = IMR_WRITE_ACCESS_ALL;\n\n\tret = imr_write(idev, reg, &imr);\n\nfailed:\n\tmutex_unlock(&idev->lock);\n\treturn ret;\n}\n\n \nint imr_remove_range(phys_addr_t base, size_t size)\n{\n\treturn __imr_remove_range(-1, base, size);\n}\nEXPORT_SYMBOL_GPL(imr_remove_range);\n\n \nstatic inline int imr_clear(int reg)\n{\n\treturn __imr_remove_range(reg, 0, 0);\n}\n\n \nstatic void __init imr_fixup_memmap(struct imr_device *idev)\n{\n\tphys_addr_t base = virt_to_phys(&_text);\n\tsize_t size = virt_to_phys(&__end_rodata) - base;\n\tunsigned long start, end;\n\tint i;\n\tint ret;\n\n\t \n\tfor (i = 0; i < idev->max_imr; i++)\n\t\timr_clear(i);\n\n\tstart = (unsigned long)_text;\n\tend = (unsigned long)__end_rodata - 1;\n\n\t \n\tret = imr_add_range(base, size, IMR_CPU, IMR_CPU);\n\tif (ret < 0) {\n\t\tpr_err(\"unable to setup IMR for kernel: %zu KiB (%lx - %lx)\\n\",\n\t\t\tsize / 1024, start, end);\n\t} else {\n\t\tpr_info(\"protecting kernel .text - .rodata: %zu KiB (%lx - %lx)\\n\",\n\t\t\tsize / 1024, start, end);\n\t}\n\n}\n\nstatic const struct x86_cpu_id imr_ids[] __initconst = {\n\tX86_MATCH_VENDOR_FAM_MODEL(INTEL, 5, INTEL_FAM5_QUARK_X1000, NULL),\n\t{}\n};\n\n \nstatic int __init imr_init(void)\n{\n\tstruct imr_device *idev = &imr_dev;\n\n\tif (!x86_match_cpu(imr_ids) || !iosf_mbi_available())\n\t\treturn -ENODEV;\n\n\tidev->max_imr = QUARK_X1000_IMR_MAX;\n\tidev->reg_base = QUARK_X1000_IMR_REGBASE;\n\tidev->init = true;\n\n\tmutex_init(&idev->lock);\n\timr_debugfs_register(idev);\n\timr_fixup_memmap(idev);\n\treturn 0;\n}\ndevice_initcall(imr_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}