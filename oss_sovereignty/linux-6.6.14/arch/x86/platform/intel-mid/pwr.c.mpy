{
  "module_name": "pwr.c",
  "hash_id": "01011d3f4273d738aeeec1bae531b824ec0871724626cdd911d6719210558e1a",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/platform/intel-mid/pwr.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n\n#include <asm/intel-mid.h>\n\n \n#define PM_STS\t\t\t0x00\n#define PM_CMD\t\t\t0x04\n#define PM_ICS\t\t\t0x08\n#define PM_WKC(x)\t\t(0x10 + (x) * 4)\n#define PM_WKS(x)\t\t(0x18 + (x) * 4)\n#define PM_SSC(x)\t\t(0x20 + (x) * 4)\n#define PM_SSS(x)\t\t(0x30 + (x) * 4)\n\n \n#define PM_STS_BUSY\t\t(1 << 8)\n\n \n#define PM_CMD_CMD(x)\t\t((x) << 0)\n#define PM_CMD_IOC\t\t(1 << 8)\n#define PM_CMD_CM_NOP\t\t(0 << 9)\n#define PM_CMD_CM_IMMEDIATE\t(1 << 9)\n#define PM_CMD_CM_DELAY\t\t(2 << 9)\n#define PM_CMD_CM_TRIGGER\t(3 << 9)\n\n \n#define PM_CMD_SYS_STATE_S5\t(5 << 16)\n\n \n#define PM_CMD_CFG_TRIGGER_NC\t(3 << 19)\n\n \n#define TRIGGER_NC_MSG_2\t(2 << 22)\n\n \n#define CMD_SET_CFG\t\t0x01\n\n \n#define PM_ICS_INT_STATUS(x)\t((x) & 0xff)\n#define PM_ICS_IE\t\t(1 << 8)\n#define PM_ICS_IP\t\t(1 << 9)\n#define PM_ICS_SW_INT_STS\t(1 << 10)\n\n \n#define INT_INVALID\t\t0\n#define INT_CMD_COMPLETE\t1\n#define INT_CMD_ERR\t\t2\n#define INT_WAKE_EVENT\t\t3\n#define INT_LSS_POWER_ERR\t4\n#define INT_S0iX_MSG_ERR\t5\n#define INT_NO_C6\t\t6\n#define INT_TRIGGER_ERR\t\t7\n#define INT_INACTIVITY\t\t8\n\n \n#define LSS_MAX_SHARED_DEVS\t4\n#define LSS_MAX_DEVS\t\t64\n\n#define LSS_WS_BITS\t\t1\t \n#define LSS_PWS_BITS\t\t2\t \n\n \n#define PCI_DEVICE_ID_PENWELL\t0x0828\n#define PCI_DEVICE_ID_TANGIER\t0x11a1\n\nstruct mid_pwr_dev {\n\tstruct pci_dev *pdev;\n\tpci_power_t state;\n};\n\nstruct mid_pwr {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tint irq;\n\tbool available;\n\n\tstruct mutex lock;\n\tstruct mid_pwr_dev lss[LSS_MAX_DEVS][LSS_MAX_SHARED_DEVS];\n};\n\nstatic struct mid_pwr *midpwr;\n\nstatic u32 mid_pwr_get_state(struct mid_pwr *pwr, int reg)\n{\n\treturn readl(pwr->regs + PM_SSS(reg));\n}\n\nstatic void mid_pwr_set_state(struct mid_pwr *pwr, int reg, u32 value)\n{\n\twritel(value, pwr->regs + PM_SSC(reg));\n}\n\nstatic void mid_pwr_set_wake(struct mid_pwr *pwr, int reg, u32 value)\n{\n\twritel(value, pwr->regs + PM_WKC(reg));\n}\n\nstatic void mid_pwr_interrupt_disable(struct mid_pwr *pwr)\n{\n\twritel(~PM_ICS_IE, pwr->regs + PM_ICS);\n}\n\nstatic bool mid_pwr_is_busy(struct mid_pwr *pwr)\n{\n\treturn !!(readl(pwr->regs + PM_STS) & PM_STS_BUSY);\n}\n\n \nstatic int mid_pwr_wait(struct mid_pwr *pwr)\n{\n\tunsigned int count = 500000;\n\tbool busy;\n\n\tdo {\n\t\tbusy = mid_pwr_is_busy(pwr);\n\t\tif (!busy)\n\t\t\treturn 0;\n\t\tudelay(1);\n\t} while (--count);\n\n\treturn -EBUSY;\n}\n\nstatic int mid_pwr_wait_for_cmd(struct mid_pwr *pwr, u8 cmd)\n{\n\twritel(PM_CMD_CMD(cmd) | PM_CMD_CM_IMMEDIATE, pwr->regs + PM_CMD);\n\treturn mid_pwr_wait(pwr);\n}\n\nstatic int __update_power_state(struct mid_pwr *pwr, int reg, int bit, int new)\n{\n\tint curstate;\n\tu32 power;\n\tint ret;\n\n\t \n\tpower = mid_pwr_get_state(pwr, reg);\n\tcurstate = (power >> bit) & 3;\n\tif (curstate == new)\n\t\treturn 0;\n\n\t \n\tmid_pwr_set_state(pwr, reg, (power & ~(3 << bit)) | (new << bit));\n\n\t \n\tret = mid_pwr_wait_for_cmd(pwr, CMD_SET_CFG);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpower = mid_pwr_get_state(pwr, reg);\n\tcurstate = (power >> bit) & 3;\n\tif (curstate != new)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic pci_power_t __find_weakest_power_state(struct mid_pwr_dev *lss,\n\t\t\t\t\t      struct pci_dev *pdev,\n\t\t\t\t\t      pci_power_t state)\n{\n\tpci_power_t weakest = PCI_D3hot;\n\tunsigned int j;\n\n\t \n\tfor (j = 0; j < LSS_MAX_SHARED_DEVS; j++) {\n\t\tif (lss[j].pdev == pdev || !lss[j].pdev)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (j < LSS_MAX_SHARED_DEVS) {\n\t\tlss[j].pdev = pdev;\n\t\tlss[j].state = state;\n\t} else {\n\t\tdev_WARN(&pdev->dev, \"No room for device in PWRMU LSS cache\\n\");\n\t\tweakest = state;\n\t}\n\n\t \n\tfor (j = 0; j < LSS_MAX_SHARED_DEVS; j++) {\n\t\tif (lss[j].state < weakest)\n\t\t\tweakest = lss[j].state;\n\t}\n\n\treturn weakest;\n}\n\nstatic int __set_power_state(struct mid_pwr *pwr, struct pci_dev *pdev,\n\t\t\t     pci_power_t state, int id, int reg, int bit)\n{\n\tconst char *name;\n\tint ret;\n\n\tstate = __find_weakest_power_state(pwr->lss[id], pdev, state);\n\tname = pci_power_name(state);\n\n\tret = __update_power_state(pwr, reg, bit, (__force int)state);\n\tif (ret) {\n\t\tdev_warn(&pdev->dev, \"Can't set power state %s: %d\\n\", name, ret);\n\t\treturn ret;\n\t}\n\n\tdev_vdbg(&pdev->dev, \"Set power state %s\\n\", name);\n\treturn 0;\n}\n\nstatic int mid_pwr_set_power_state(struct mid_pwr *pwr, struct pci_dev *pdev,\n\t\t\t\t   pci_power_t state)\n{\n\tint id, reg, bit;\n\tint ret;\n\n\tid = intel_mid_pwr_get_lss_id(pdev);\n\tif (id < 0)\n\t\treturn id;\n\n\treg = (id * LSS_PWS_BITS) / 32;\n\tbit = (id * LSS_PWS_BITS) % 32;\n\n\t \n\tif (state < PCI_D0)\n\t\tstate = PCI_D0;\n\tif (state > PCI_D3hot)\n\t\tstate = PCI_D3hot;\n\n\tmutex_lock(&pwr->lock);\n\tret = __set_power_state(pwr, pdev, state, id, reg, bit);\n\tmutex_unlock(&pwr->lock);\n\treturn ret;\n}\n\nint intel_mid_pci_set_power_state(struct pci_dev *pdev, pci_power_t state)\n{\n\tstruct mid_pwr *pwr = midpwr;\n\tint ret = 0;\n\n\tmight_sleep();\n\n\tif (pwr && pwr->available)\n\t\tret = mid_pwr_set_power_state(pwr, pdev, state);\n\tdev_vdbg(&pdev->dev, \"set_power_state() returns %d\\n\", ret);\n\n\treturn 0;\n}\n\npci_power_t intel_mid_pci_get_power_state(struct pci_dev *pdev)\n{\n\tstruct mid_pwr *pwr = midpwr;\n\tint id, reg, bit;\n\tu32 power;\n\n\tif (!pwr || !pwr->available)\n\t\treturn PCI_UNKNOWN;\n\n\tid = intel_mid_pwr_get_lss_id(pdev);\n\tif (id < 0)\n\t\treturn PCI_UNKNOWN;\n\n\treg = (id * LSS_PWS_BITS) / 32;\n\tbit = (id * LSS_PWS_BITS) % 32;\n\tpower = mid_pwr_get_state(pwr, reg);\n\treturn (__force pci_power_t)((power >> bit) & 3);\n}\n\nvoid intel_mid_pwr_power_off(void)\n{\n\tstruct mid_pwr *pwr = midpwr;\n\tu32 cmd = PM_CMD_SYS_STATE_S5 |\n\t\t  PM_CMD_CMD(CMD_SET_CFG) |\n\t\t  PM_CMD_CM_TRIGGER |\n\t\t  PM_CMD_CFG_TRIGGER_NC |\n\t\t  TRIGGER_NC_MSG_2;\n\n\t \n\twritel(cmd, pwr->regs + PM_CMD);\n\tmid_pwr_wait(pwr);\n}\n\nint intel_mid_pwr_get_lss_id(struct pci_dev *pdev)\n{\n\tint vndr;\n\tu8 id;\n\n\t \n\tvndr = pci_find_capability(pdev, PCI_CAP_ID_VNDR);\n\tif (!vndr)\n\t\treturn -EINVAL;\n\n\t \n\tpci_read_config_byte(pdev, vndr + INTEL_MID_PWR_LSS_OFFSET, &id);\n\tif (!(id & INTEL_MID_PWR_LSS_TYPE))\n\t\treturn -ENODEV;\n\n\tid &= ~INTEL_MID_PWR_LSS_TYPE;\n\tif (id >= LSS_MAX_DEVS)\n\t\treturn -ERANGE;\n\n\treturn id;\n}\n\nstatic irqreturn_t mid_pwr_irq_handler(int irq, void *dev_id)\n{\n\tstruct mid_pwr *pwr = dev_id;\n\tu32 ics;\n\n\tics = readl(pwr->regs + PM_ICS);\n\tif (!(ics & PM_ICS_IP))\n\t\treturn IRQ_NONE;\n\n\twritel(ics | PM_ICS_IP, pwr->regs + PM_ICS);\n\n\tdev_warn(pwr->dev, \"Unexpected IRQ: %#x\\n\", PM_ICS_INT_STATUS(ics));\n\treturn IRQ_HANDLED;\n}\n\nstruct mid_pwr_device_info {\n\tint (*set_initial_state)(struct mid_pwr *pwr);\n};\n\nstatic int mid_pwr_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct mid_pwr_device_info *info = (void *)id->driver_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct mid_pwr *pwr;\n\tint ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"error: could not enable device\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pcim_iomap_regions(pdev, 1 << 0, pci_name(pdev));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"I/O memory remapping failed\\n\");\n\t\treturn ret;\n\t}\n\n\tpwr = devm_kzalloc(dev, sizeof(*pwr), GFP_KERNEL);\n\tif (!pwr)\n\t\treturn -ENOMEM;\n\n\tpwr->dev = dev;\n\tpwr->regs = pcim_iomap_table(pdev)[0];\n\tpwr->irq = pdev->irq;\n\n\tmutex_init(&pwr->lock);\n\n\t \n\tmid_pwr_interrupt_disable(pwr);\n\n\tif (info && info->set_initial_state) {\n\t\tret = info->set_initial_state(pwr);\n\t\tif (ret)\n\t\t\tdev_warn(dev, \"Can't set initial state: %d\\n\", ret);\n\t}\n\n\tret = devm_request_irq(dev, pdev->irq, mid_pwr_irq_handler,\n\t\t\t       IRQF_NO_SUSPEND, pci_name(pdev), pwr);\n\tif (ret)\n\t\treturn ret;\n\n\tpwr->available = true;\n\tmidpwr = pwr;\n\n\tpci_set_drvdata(pdev, pwr);\n\treturn 0;\n}\n\nstatic int mid_set_initial_state(struct mid_pwr *pwr, const u32 *states)\n{\n\tunsigned int i, j;\n\tint ret;\n\n\t \n\tmid_pwr_set_wake(pwr, 0, 0xffffffff);\n\tmid_pwr_set_wake(pwr, 1, 0xffffffff);\n\n\t \n\tmid_pwr_set_state(pwr, 0, states[0]);\n\tmid_pwr_set_state(pwr, 1, states[1]);\n\tmid_pwr_set_state(pwr, 2, states[2]);\n\tmid_pwr_set_state(pwr, 3, states[3]);\n\n\t \n\tret = mid_pwr_wait_for_cmd(pwr, CMD_SET_CFG);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < LSS_MAX_DEVS; i++) {\n\t\tfor (j = 0; j < LSS_MAX_SHARED_DEVS; j++)\n\t\t\tpwr->lss[i][j].state = PCI_D3hot;\n\t}\n\n\treturn 0;\n}\n\nstatic int pnw_set_initial_state(struct mid_pwr *pwr)\n{\n\t \n\tstatic const u32 states[] = {\n\t\t0xf00fffff,\t\t \n\t\t0xffffffff,\t\t \n\t\t0xffffffff,\t\t \n\t\t0xffffffff,\t\t \n\t};\n\treturn mid_set_initial_state(pwr, states);\n}\n\nstatic int tng_set_initial_state(struct mid_pwr *pwr)\n{\n\tstatic const u32 states[] = {\n\t\t0xffffffff,\t\t \n\t\t0xffffffff,\t\t \n\t\t0xffffffff,\t\t \n\t\t0xffffffff,\t\t \n\t};\n\treturn mid_set_initial_state(pwr, states);\n}\n\nstatic const struct mid_pwr_device_info pnw_info = {\n\t.set_initial_state = pnw_set_initial_state,\n};\n\nstatic const struct mid_pwr_device_info tng_info = {\n\t.set_initial_state = tng_set_initial_state,\n};\n\n \nstatic const struct pci_device_id mid_pwr_pci_ids[] = {\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_PENWELL), (kernel_ulong_t)&pnw_info },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_TANGIER), (kernel_ulong_t)&tng_info },\n\t{}\n};\n\nstatic struct pci_driver mid_pwr_pci_driver = {\n\t.name\t\t= \"intel_mid_pwr\",\n\t.probe\t\t= mid_pwr_probe,\n\t.id_table\t= mid_pwr_pci_ids,\n};\n\nbuiltin_pci_driver(mid_pwr_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}