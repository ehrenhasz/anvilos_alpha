{
  "module_name": "hv_apic.c",
  "hash_id": "4f72e44a4d1b6761de4ec380ecdd7d714f512681f2a69dc27a5814b896a0094f",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/hyperv/hv_apic.c",
  "human_readable_source": "\n\n \n\n#include <linux/types.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/clockchips.h>\n#include <linux/hyperv.h>\n#include <linux/slab.h>\n#include <linux/cpuhotplug.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/apic.h>\n\n#include <asm/trace/hyperv.h>\n\nstatic struct apic orig_apic;\n\nstatic u64 hv_apic_icr_read(void)\n{\n\tu64 reg_val;\n\n\trdmsrl(HV_X64_MSR_ICR, reg_val);\n\treturn reg_val;\n}\n\nstatic void hv_apic_icr_write(u32 low, u32 id)\n{\n\tu64 reg_val;\n\n\treg_val = SET_XAPIC_DEST_FIELD(id);\n\treg_val = reg_val << 32;\n\treg_val |= low;\n\n\twrmsrl(HV_X64_MSR_ICR, reg_val);\n}\n\nstatic u32 hv_apic_read(u32 reg)\n{\n\tu32 reg_val, hi;\n\n\tswitch (reg) {\n\tcase APIC_EOI:\n\t\trdmsr(HV_X64_MSR_EOI, reg_val, hi);\n\t\t(void)hi;\n\t\treturn reg_val;\n\tcase APIC_TASKPRI:\n\t\trdmsr(HV_X64_MSR_TPR, reg_val, hi);\n\t\t(void)hi;\n\t\treturn reg_val;\n\n\tdefault:\n\t\treturn native_apic_mem_read(reg);\n\t}\n}\n\nstatic void hv_apic_write(u32 reg, u32 val)\n{\n\tswitch (reg) {\n\tcase APIC_EOI:\n\t\twrmsr(HV_X64_MSR_EOI, val, 0);\n\t\tbreak;\n\tcase APIC_TASKPRI:\n\t\twrmsr(HV_X64_MSR_TPR, val, 0);\n\t\tbreak;\n\tdefault:\n\t\tnative_apic_mem_write(reg, val);\n\t}\n}\n\nstatic void hv_apic_eoi_write(void)\n{\n\tstruct hv_vp_assist_page *hvp = hv_vp_assist_page[smp_processor_id()];\n\n\tif (hvp && (xchg(&hvp->apic_assist, 0) & 0x1))\n\t\treturn;\n\n\twrmsr(HV_X64_MSR_EOI, APIC_EOI_ACK, 0);\n}\n\nstatic bool cpu_is_self(int cpu)\n{\n\treturn cpu == smp_processor_id();\n}\n\n \nstatic bool __send_ipi_mask_ex(const struct cpumask *mask, int vector,\n\t\tbool exclude_self)\n{\n\tstruct hv_send_ipi_ex *ipi_arg;\n\tunsigned long flags;\n\tint nr_bank = 0;\n\tu64 status = HV_STATUS_INVALID_PARAMETER;\n\n\tif (!(ms_hyperv.hints & HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED))\n\t\treturn false;\n\n\tlocal_irq_save(flags);\n\tipi_arg = *this_cpu_ptr(hyperv_pcpu_input_arg);\n\n\tif (unlikely(!ipi_arg))\n\t\tgoto ipi_mask_ex_done;\n\n\tipi_arg->vector = vector;\n\tipi_arg->reserved = 0;\n\tipi_arg->vp_set.valid_bank_mask = 0;\n\n\t \n\tif (!cpumask_equal(mask, cpu_present_mask) || exclude_self) {\n\t\tipi_arg->vp_set.format = HV_GENERIC_SET_SPARSE_4K;\n\n\t\tnr_bank = cpumask_to_vpset_skip(&(ipi_arg->vp_set), mask,\n\t\t\t\texclude_self ? cpu_is_self : NULL);\n\n\t\t \n\t\tif (nr_bank <= 0)\n\t\t\tgoto ipi_mask_ex_done;\n\t} else {\n\t\tipi_arg->vp_set.format = HV_GENERIC_SET_ALL;\n\t}\n\n\tstatus = hv_do_rep_hypercall(HVCALL_SEND_IPI_EX, 0, nr_bank,\n\t\t\t      ipi_arg, NULL);\n\nipi_mask_ex_done:\n\tlocal_irq_restore(flags);\n\treturn hv_result_success(status);\n}\n\nstatic bool __send_ipi_mask(const struct cpumask *mask, int vector,\n\t\tbool exclude_self)\n{\n\tint cur_cpu, vcpu, this_cpu = smp_processor_id();\n\tstruct hv_send_ipi ipi_arg;\n\tu64 status;\n\tunsigned int weight;\n\n\ttrace_hyperv_send_ipi_mask(mask, vector);\n\n\tweight = cpumask_weight(mask);\n\n\t \n\tif (weight == 0 ||\n\t    (exclude_self && weight == 1 && cpumask_test_cpu(this_cpu, mask)))\n\t\treturn true;\n\n\t \n\tif (!hv_hypercall_pg) {\n\t\tif (ms_hyperv.paravisor_present || !hv_isolation_type_tdx())\n\t\t\treturn false;\n\t}\n\n\tif ((vector < HV_IPI_LOW_VECTOR) || (vector > HV_IPI_HIGH_VECTOR))\n\t\treturn false;\n\n\t \n\tif (hv_cpu_number_to_vp_number(cpumask_last(mask)) >= 64)\n\t\tgoto do_ex_hypercall;\n\n\tipi_arg.vector = vector;\n\tipi_arg.cpu_mask = 0;\n\n\tfor_each_cpu(cur_cpu, mask) {\n\t\tif (exclude_self && cur_cpu == this_cpu)\n\t\t\tcontinue;\n\t\tvcpu = hv_cpu_number_to_vp_number(cur_cpu);\n\t\tif (vcpu == VP_INVAL)\n\t\t\treturn false;\n\n\t\t \n\t\tif (vcpu >= 64)\n\t\t\tgoto do_ex_hypercall;\n\n\t\t__set_bit(vcpu, (unsigned long *)&ipi_arg.cpu_mask);\n\t}\n\n\tstatus = hv_do_fast_hypercall16(HVCALL_SEND_IPI, ipi_arg.vector,\n\t\t\t\t     ipi_arg.cpu_mask);\n\treturn hv_result_success(status);\n\ndo_ex_hypercall:\n\treturn __send_ipi_mask_ex(mask, vector, exclude_self);\n}\n\nstatic bool __send_ipi_one(int cpu, int vector)\n{\n\tint vp = hv_cpu_number_to_vp_number(cpu);\n\tu64 status;\n\n\ttrace_hyperv_send_ipi_one(cpu, vector);\n\n\tif (vp == VP_INVAL)\n\t\treturn false;\n\n\t \n\tif (!hv_hypercall_pg) {\n\t\tif (ms_hyperv.paravisor_present || !hv_isolation_type_tdx())\n\t\t\treturn false;\n\t}\n\n\tif ((vector < HV_IPI_LOW_VECTOR) || (vector > HV_IPI_HIGH_VECTOR))\n\t\treturn false;\n\n\tif (vp >= 64)\n\t\treturn __send_ipi_mask_ex(cpumask_of(cpu), vector, false);\n\n\tstatus = hv_do_fast_hypercall16(HVCALL_SEND_IPI, vector, BIT_ULL(vp));\n\treturn hv_result_success(status);\n}\n\nstatic void hv_send_ipi(int cpu, int vector)\n{\n\tif (!__send_ipi_one(cpu, vector))\n\t\torig_apic.send_IPI(cpu, vector);\n}\n\nstatic void hv_send_ipi_mask(const struct cpumask *mask, int vector)\n{\n\tif (!__send_ipi_mask(mask, vector, false))\n\t\torig_apic.send_IPI_mask(mask, vector);\n}\n\nstatic void hv_send_ipi_mask_allbutself(const struct cpumask *mask, int vector)\n{\n\tif (!__send_ipi_mask(mask, vector, true))\n\t\torig_apic.send_IPI_mask_allbutself(mask, vector);\n}\n\nstatic void hv_send_ipi_allbutself(int vector)\n{\n\thv_send_ipi_mask_allbutself(cpu_online_mask, vector);\n}\n\nstatic void hv_send_ipi_all(int vector)\n{\n\tif (!__send_ipi_mask(cpu_online_mask, vector, false))\n\t\torig_apic.send_IPI_all(vector);\n}\n\nstatic void hv_send_ipi_self(int vector)\n{\n\tif (!__send_ipi_one(smp_processor_id(), vector))\n\t\torig_apic.send_IPI_self(vector);\n}\n\nvoid __init hv_apic_init(void)\n{\n\tif (ms_hyperv.hints & HV_X64_CLUSTER_IPI_RECOMMENDED) {\n\t\tpr_info(\"Hyper-V: Using IPI hypercalls\\n\");\n\t\t \n\t\torig_apic = *apic;\n\n\t\tapic_update_callback(send_IPI, hv_send_ipi);\n\t\tapic_update_callback(send_IPI_mask, hv_send_ipi_mask);\n\t\tapic_update_callback(send_IPI_mask_allbutself, hv_send_ipi_mask_allbutself);\n\t\tapic_update_callback(send_IPI_allbutself, hv_send_ipi_allbutself);\n\t\tapic_update_callback(send_IPI_all, hv_send_ipi_all);\n\t\tapic_update_callback(send_IPI_self, hv_send_ipi_self);\n\t}\n\n\tif (ms_hyperv.hints & HV_X64_APIC_ACCESS_RECOMMENDED) {\n\t\tpr_info(\"Hyper-V: Using enlightened APIC (%s mode)\",\n\t\t\tx2apic_enabled() ? \"x2apic\" : \"xapic\");\n\t\t \n\t\tapic_update_callback(eoi, hv_apic_eoi_write);\n\t\tif (!x2apic_enabled()) {\n\t\t\tapic_update_callback(read, hv_apic_read);\n\t\t\tapic_update_callback(write, hv_apic_write);\n\t\t\tapic_update_callback(icr_write, hv_apic_icr_write);\n\t\t\tapic_update_callback(icr_read, hv_apic_icr_read);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}