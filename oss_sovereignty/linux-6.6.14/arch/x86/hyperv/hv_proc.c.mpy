{
  "module_name": "hv_proc.c",
  "hash_id": "74f732ae80f4dbddee5ae9fa6089fbeb4c39b9ac1b695769d7a538e0be97eafc",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/hyperv/hv_proc.c",
  "human_readable_source": "\n#include <linux/types.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/clockchips.h>\n#include <linux/acpi.h>\n#include <linux/hyperv.h>\n#include <linux/slab.h>\n#include <linux/cpuhotplug.h>\n#include <linux/minmax.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/apic.h>\n\n#include <asm/trace/hyperv.h>\n\n \n#define HV_DEPOSIT_MAX (HV_HYP_PAGE_SIZE / sizeof(u64) - 1)\n\n \nint hv_call_deposit_pages(int node, u64 partition_id, u32 num_pages)\n{\n\tstruct page **pages, *page;\n\tint *counts;\n\tint num_allocations;\n\tint i, j, page_count;\n\tint order;\n\tu64 status;\n\tint ret;\n\tu64 base_pfn;\n\tstruct hv_deposit_memory *input_page;\n\tunsigned long flags;\n\n\tif (num_pages > HV_DEPOSIT_MAX)\n\t\treturn -E2BIG;\n\tif (!num_pages)\n\t\treturn 0;\n\n\t \n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tpages = page_address(page);\n\n\tcounts = kcalloc(HV_DEPOSIT_MAX, sizeof(int), GFP_KERNEL);\n\tif (!counts) {\n\t\tfree_page((unsigned long)pages);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\ti = 0;\n\n\twhile (num_pages) {\n\t\t \n\t\torder = 31 - __builtin_clz(num_pages);\n\n\t\twhile (1) {\n\t\t\tpages[i] = alloc_pages_node(node, GFP_KERNEL, order);\n\t\t\tif (pages[i])\n\t\t\t\tbreak;\n\t\t\tif (!order) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tnum_allocations = i;\n\t\t\t\tgoto err_free_allocations;\n\t\t\t}\n\t\t\t--order;\n\t\t}\n\n\t\tsplit_page(pages[i], order);\n\t\tcounts[i] = 1 << order;\n\t\tnum_pages -= counts[i];\n\t\ti++;\n\t}\n\tnum_allocations = i;\n\n\tlocal_irq_save(flags);\n\n\tinput_page = *this_cpu_ptr(hyperv_pcpu_input_arg);\n\n\tinput_page->partition_id = partition_id;\n\n\t \n\tfor (i = 0, page_count = 0; i < num_allocations; ++i) {\n\t\tbase_pfn = page_to_pfn(pages[i]);\n\t\tfor (j = 0; j < counts[i]; ++j, ++page_count)\n\t\t\tinput_page->gpa_page_list[page_count] = base_pfn + j;\n\t}\n\tstatus = hv_do_rep_hypercall(HVCALL_DEPOSIT_MEMORY,\n\t\t\t\t     page_count, 0, input_page, NULL);\n\tlocal_irq_restore(flags);\n\tif (!hv_result_success(status)) {\n\t\tpr_err(\"Failed to deposit pages: %lld\\n\", status);\n\t\tret = hv_result(status);\n\t\tgoto err_free_allocations;\n\t}\n\n\tret = 0;\n\tgoto free_buf;\n\nerr_free_allocations:\n\tfor (i = 0; i < num_allocations; ++i) {\n\t\tbase_pfn = page_to_pfn(pages[i]);\n\t\tfor (j = 0; j < counts[i]; ++j)\n\t\t\t__free_page(pfn_to_page(base_pfn + j));\n\t}\n\nfree_buf:\n\tfree_page((unsigned long)pages);\n\tkfree(counts);\n\treturn ret;\n}\n\nint hv_call_add_logical_proc(int node, u32 lp_index, u32 apic_id)\n{\n\tstruct hv_add_logical_processor_in *input;\n\tstruct hv_add_logical_processor_out *output;\n\tu64 status;\n\tunsigned long flags;\n\tint ret = HV_STATUS_SUCCESS;\n\tint pxm = node_to_pxm(node);\n\n\t \n\tdo {\n\t\tlocal_irq_save(flags);\n\n\t\tinput = *this_cpu_ptr(hyperv_pcpu_input_arg);\n\t\t \n\t\toutput = *this_cpu_ptr(hyperv_pcpu_output_arg);\n\n\t\tinput->lp_index = lp_index;\n\t\tinput->apic_id = apic_id;\n\t\tinput->flags = 0;\n\t\tinput->proximity_domain_info.domain_id = pxm;\n\t\tinput->proximity_domain_info.flags.reserved = 0;\n\t\tinput->proximity_domain_info.flags.proximity_info_valid = 1;\n\t\tinput->proximity_domain_info.flags.proximity_preferred = 1;\n\t\tstatus = hv_do_hypercall(HVCALL_ADD_LOGICAL_PROCESSOR,\n\t\t\t\t\t input, output);\n\t\tlocal_irq_restore(flags);\n\n\t\tif (hv_result(status) != HV_STATUS_INSUFFICIENT_MEMORY) {\n\t\t\tif (!hv_result_success(status)) {\n\t\t\t\tpr_err(\"%s: cpu %u apic ID %u, %lld\\n\", __func__,\n\t\t\t\t       lp_index, apic_id, status);\n\t\t\t\tret = hv_result(status);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tret = hv_call_deposit_pages(node, hv_current_partition_id, 1);\n\t} while (!ret);\n\n\treturn ret;\n}\n\nint hv_call_create_vp(int node, u64 partition_id, u32 vp_index, u32 flags)\n{\n\tstruct hv_create_vp *input;\n\tu64 status;\n\tunsigned long irq_flags;\n\tint ret = HV_STATUS_SUCCESS;\n\tint pxm = node_to_pxm(node);\n\n\t \n\tif (partition_id != hv_current_partition_id) {\n\t\t \n\t\tret = hv_call_deposit_pages(node, partition_id, 90);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdo {\n\t\tlocal_irq_save(irq_flags);\n\n\t\tinput = *this_cpu_ptr(hyperv_pcpu_input_arg);\n\n\t\tinput->partition_id = partition_id;\n\t\tinput->vp_index = vp_index;\n\t\tinput->flags = flags;\n\t\tinput->subnode_type = HvSubnodeAny;\n\t\tif (node != NUMA_NO_NODE) {\n\t\t\tinput->proximity_domain_info.domain_id = pxm;\n\t\t\tinput->proximity_domain_info.flags.reserved = 0;\n\t\t\tinput->proximity_domain_info.flags.proximity_info_valid = 1;\n\t\t\tinput->proximity_domain_info.flags.proximity_preferred = 1;\n\t\t} else {\n\t\t\tinput->proximity_domain_info.as_uint64 = 0;\n\t\t}\n\t\tstatus = hv_do_hypercall(HVCALL_CREATE_VP, input, NULL);\n\t\tlocal_irq_restore(irq_flags);\n\n\t\tif (hv_result(status) != HV_STATUS_INSUFFICIENT_MEMORY) {\n\t\t\tif (!hv_result_success(status)) {\n\t\t\t\tpr_err(\"%s: vcpu %u, lp %u, %lld\\n\", __func__,\n\t\t\t\t       vp_index, flags, status);\n\t\t\t\tret = hv_result(status);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tret = hv_call_deposit_pages(node, partition_id, 1);\n\n\t} while (!ret);\n\n\treturn ret;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}