{
  "module_name": "hv_vtl.c",
  "hash_id": "c3915474df123a8ea60d65077e7182f690f6b38d7afa364e16e0c926bba7d14e",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/hyperv/hv_vtl.c",
  "human_readable_source": "\n \n\n#include <asm/apic.h>\n#include <asm/boot.h>\n#include <asm/desc.h>\n#include <asm/i8259.h>\n#include <asm/mshyperv.h>\n#include <asm/realmode.h>\n\nextern struct boot_params boot_params;\nstatic struct real_mode_header hv_vtl_real_mode_header;\n\nvoid __init hv_vtl_init_platform(void)\n{\n\tpr_info(\"Linux runs in Hyper-V Virtual Trust Level\\n\");\n\n\tx86_platform.realmode_reserve = x86_init_noop;\n\tx86_platform.realmode_init = x86_init_noop;\n\tx86_init.irqs.pre_vector_init = x86_init_noop;\n\tx86_init.timers.timer_init = x86_init_noop;\n\n\t \n\tx86_init.mpparse.find_smp_config = x86_init_noop;\n\tx86_init.mpparse.get_smp_config = x86_init_uint_noop;\n\n\tx86_platform.get_wallclock = get_rtc_noop;\n\tx86_platform.set_wallclock = set_rtc_noop;\n\tx86_platform.get_nmi_reason = hv_get_nmi_reason;\n\n\tx86_platform.legacy.i8042 = X86_LEGACY_I8042_PLATFORM_ABSENT;\n\tx86_platform.legacy.rtc = 0;\n\tx86_platform.legacy.warm_reset = 0;\n\tx86_platform.legacy.reserve_bios_regions = 0;\n\tx86_platform.legacy.devices.pnpbios = 0;\n}\n\nstatic inline u64 hv_vtl_system_desc_base(struct ldttss_desc *desc)\n{\n\treturn ((u64)desc->base3 << 32) | ((u64)desc->base2 << 24) |\n\t\t(desc->base1 << 16) | desc->base0;\n}\n\nstatic inline u32 hv_vtl_system_desc_limit(struct ldttss_desc *desc)\n{\n\treturn ((u32)desc->limit1 << 16) | (u32)desc->limit0;\n}\n\ntypedef void (*secondary_startup_64_fn)(void*, void*);\nstatic void hv_vtl_ap_entry(void)\n{\n\t((secondary_startup_64_fn)secondary_startup_64)(&boot_params, &boot_params);\n}\n\nstatic int hv_vtl_bringup_vcpu(u32 target_vp_index, u64 eip_ignored)\n{\n\tu64 status;\n\tint ret = 0;\n\tstruct hv_enable_vp_vtl *input;\n\tunsigned long irq_flags;\n\n\tstruct desc_ptr gdt_ptr;\n\tstruct desc_ptr idt_ptr;\n\n\tstruct ldttss_desc *tss;\n\tstruct ldttss_desc *ldt;\n\tstruct desc_struct *gdt;\n\n\tu64 rsp = current->thread.sp;\n\tu64 rip = (u64)&hv_vtl_ap_entry;\n\n\tnative_store_gdt(&gdt_ptr);\n\tstore_idt(&idt_ptr);\n\n\tgdt = (struct desc_struct *)((void *)(gdt_ptr.address));\n\ttss = (struct ldttss_desc *)(gdt + GDT_ENTRY_TSS);\n\tldt = (struct ldttss_desc *)(gdt + GDT_ENTRY_LDT);\n\n\tlocal_irq_save(irq_flags);\n\n\tinput = *this_cpu_ptr(hyperv_pcpu_input_arg);\n\tmemset(input, 0, sizeof(*input));\n\n\tinput->partition_id = HV_PARTITION_ID_SELF;\n\tinput->vp_index = target_vp_index;\n\tinput->target_vtl.target_vtl = HV_VTL_MGMT;\n\n\t \n\n\tinput->vp_context.rip = rip;\n\tinput->vp_context.rsp = rsp;\n\tinput->vp_context.rflags = 0x0000000000000002;\n\tinput->vp_context.efer = __rdmsr(MSR_EFER);\n\tinput->vp_context.cr0 = native_read_cr0();\n\tinput->vp_context.cr3 = __native_read_cr3();\n\tinput->vp_context.cr4 = native_read_cr4();\n\tinput->vp_context.msr_cr_pat = __rdmsr(MSR_IA32_CR_PAT);\n\tinput->vp_context.idtr.limit = idt_ptr.size;\n\tinput->vp_context.idtr.base = idt_ptr.address;\n\tinput->vp_context.gdtr.limit = gdt_ptr.size;\n\tinput->vp_context.gdtr.base = gdt_ptr.address;\n\n\t \n\tinput->vp_context.cs.selector = __KERNEL_CS;\n\tinput->vp_context.cs.base = 0;\n\tinput->vp_context.cs.limit = 0xffffffff;\n\tinput->vp_context.cs.attributes = 0xa09b;\n\t \n\tinput->vp_context.ss.selector = __KERNEL_DS;\n\tinput->vp_context.ss.base = 0;\n\tinput->vp_context.ss.limit = 0xffffffff;\n\tinput->vp_context.ss.attributes = 0xc093;\n\n\t \n\tinput->vp_context.ldtr.selector = GDT_ENTRY_LDT * 8;\n\tinput->vp_context.ldtr.base = hv_vtl_system_desc_base(ldt);\n\tinput->vp_context.ldtr.limit = hv_vtl_system_desc_limit(ldt);\n\tinput->vp_context.ldtr.attributes = 0x82;\n\n\t \n\tinput->vp_context.tr.selector = GDT_ENTRY_TSS * 8;\n\tinput->vp_context.tr.base = hv_vtl_system_desc_base(tss);\n\tinput->vp_context.tr.limit = hv_vtl_system_desc_limit(tss);\n\tinput->vp_context.tr.attributes = 0x8b;\n\n\tstatus = hv_do_hypercall(HVCALL_ENABLE_VP_VTL, input, NULL);\n\n\tif (!hv_result_success(status) &&\n\t    hv_result(status) != HV_STATUS_VTL_ALREADY_ENABLED) {\n\t\tpr_err(\"HVCALL_ENABLE_VP_VTL failed for VP : %d ! [Err: %#llx\\n]\",\n\t\t       target_vp_index, status);\n\t\tret = -EINVAL;\n\t\tgoto free_lock;\n\t}\n\n\tstatus = hv_do_hypercall(HVCALL_START_VP, input, NULL);\n\n\tif (!hv_result_success(status)) {\n\t\tpr_err(\"HVCALL_START_VP failed for VP : %d ! [Err: %#llx]\\n\",\n\t\t       target_vp_index, status);\n\t\tret = -EINVAL;\n\t}\n\nfree_lock:\n\tlocal_irq_restore(irq_flags);\n\n\treturn ret;\n}\n\nstatic int hv_vtl_apicid_to_vp_id(u32 apic_id)\n{\n\tu64 control;\n\tu64 status;\n\tunsigned long irq_flags;\n\tstruct hv_get_vp_from_apic_id_in *input;\n\tu32 *output, ret;\n\n\tlocal_irq_save(irq_flags);\n\n\tinput = *this_cpu_ptr(hyperv_pcpu_input_arg);\n\tmemset(input, 0, sizeof(*input));\n\tinput->partition_id = HV_PARTITION_ID_SELF;\n\tinput->apic_ids[0] = apic_id;\n\n\toutput = (u32 *)input;\n\n\tcontrol = HV_HYPERCALL_REP_COMP_1 | HVCALL_GET_VP_ID_FROM_APIC_ID;\n\tstatus = hv_do_hypercall(control, input, output);\n\tret = output[0];\n\n\tlocal_irq_restore(irq_flags);\n\n\tif (!hv_result_success(status)) {\n\t\tpr_err(\"failed to get vp id from apic id %d, status %#llx\\n\",\n\t\t       apic_id, status);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int hv_vtl_wakeup_secondary_cpu(int apicid, unsigned long start_eip)\n{\n\tint vp_id;\n\n\tpr_debug(\"Bringing up CPU with APIC ID %d in VTL2...\\n\", apicid);\n\tvp_id = hv_vtl_apicid_to_vp_id(apicid);\n\n\tif (vp_id < 0) {\n\t\tpr_err(\"Couldn't find CPU with APIC ID %d\\n\", apicid);\n\t\treturn -EINVAL;\n\t}\n\tif (vp_id > ms_hyperv.max_vp_index) {\n\t\tpr_err(\"Invalid CPU id %d for APIC ID %d\\n\", vp_id, apicid);\n\t\treturn -EINVAL;\n\t}\n\n\treturn hv_vtl_bringup_vcpu(vp_id, start_eip);\n}\n\nint __init hv_vtl_early_init(void)\n{\n\t \n\tif (cpu_feature_enabled(X86_FEATURE_XSAVE))\n\t\tpanic(\"XSAVE has to be disabled as it is not supported by this module.\\n\"\n\t\t\t  \"Please add 'noxsave' to the kernel command line.\\n\");\n\n\treal_mode_header = &hv_vtl_real_mode_header;\n\tapic_update_callback(wakeup_secondary_cpu_64, hv_vtl_wakeup_secondary_cpu);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}