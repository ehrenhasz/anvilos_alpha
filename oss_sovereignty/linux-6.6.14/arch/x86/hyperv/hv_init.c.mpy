{
  "module_name": "hv_init.c",
  "hash_id": "5d54d2a6204330919e3b2da989a95158e03a0bcc719e11a97013fba4b6e7c3d0",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/hyperv/hv_init.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)  \"Hyper-V: \" fmt\n\n#include <linux/efi.h>\n#include <linux/types.h>\n#include <linux/bitfield.h>\n#include <linux/io.h>\n#include <asm/apic.h>\n#include <asm/desc.h>\n#include <asm/e820/api.h>\n#include <asm/sev.h>\n#include <asm/ibt.h>\n#include <asm/hypervisor.h>\n#include <asm/hyperv-tlfs.h>\n#include <asm/mshyperv.h>\n#include <asm/idtentry.h>\n#include <asm/set_memory.h>\n#include <linux/kexec.h>\n#include <linux/version.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/hyperv.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/cpuhotplug.h>\n#include <linux/syscore_ops.h>\n#include <clocksource/hyperv_timer.h>\n#include <linux/highmem.h>\n\nint hyperv_init_cpuhp;\nu64 hv_current_partition_id = ~0ull;\nEXPORT_SYMBOL_GPL(hv_current_partition_id);\n\nvoid *hv_hypercall_pg;\nEXPORT_SYMBOL_GPL(hv_hypercall_pg);\n\nunion hv_ghcb * __percpu *hv_ghcb_pg;\n\n \nstatic void *hv_hypercall_pg_saved;\n\nstruct hv_vp_assist_page **hv_vp_assist_page;\nEXPORT_SYMBOL_GPL(hv_vp_assist_page);\n\nstatic int hyperv_init_ghcb(void)\n{\n\tu64 ghcb_gpa;\n\tvoid *ghcb_va;\n\tvoid **ghcb_base;\n\n\tif (!ms_hyperv.paravisor_present || !hv_isolation_type_snp())\n\t\treturn 0;\n\n\tif (!hv_ghcb_pg)\n\t\treturn -EINVAL;\n\n\t \n\trdmsrl(MSR_AMD64_SEV_ES_GHCB, ghcb_gpa);\n\n\t \n\tghcb_gpa &= ~ms_hyperv.shared_gpa_boundary;\n\tghcb_va = (void *)ioremap_cache(ghcb_gpa, HV_HYP_PAGE_SIZE);\n\tif (!ghcb_va)\n\t\treturn -ENOMEM;\n\n\tghcb_base = (void **)this_cpu_ptr(hv_ghcb_pg);\n\t*ghcb_base = ghcb_va;\n\n\treturn 0;\n}\n\nstatic int hv_cpu_init(unsigned int cpu)\n{\n\tunion hv_vp_assist_msr_contents msr = { 0 };\n\tstruct hv_vp_assist_page **hvp;\n\tint ret;\n\n\tret = hv_common_cpu_init(cpu);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!hv_vp_assist_page)\n\t\treturn 0;\n\n\thvp = &hv_vp_assist_page[cpu];\n\tif (hv_root_partition) {\n\t\t \n\t\trdmsrl(HV_X64_MSR_VP_ASSIST_PAGE, msr.as_uint64);\n\t\t*hvp = memremap(msr.pfn << HV_X64_MSR_VP_ASSIST_PAGE_ADDRESS_SHIFT,\n\t\t\t\tPAGE_SIZE, MEMREMAP_WB);\n\t} else {\n\t\t \n\t\tif (!*hvp) {\n\t\t\t*hvp = __vmalloc(PAGE_SIZE, GFP_KERNEL | __GFP_ZERO);\n\n\t\t\t \n\t\t\tif (*hvp && !ms_hyperv.paravisor_present && hv_isolation_type_snp()) {\n\t\t\t\tWARN_ON_ONCE(set_memory_decrypted((unsigned long)(*hvp), 1));\n\t\t\t\tmemset(*hvp, 0, PAGE_SIZE);\n\t\t\t}\n\t\t}\n\n\t\tif (*hvp)\n\t\t\tmsr.pfn = vmalloc_to_pfn(*hvp);\n\n\t}\n\tif (!WARN_ON(!(*hvp))) {\n\t\tmsr.enable = 1;\n\t\twrmsrl(HV_X64_MSR_VP_ASSIST_PAGE, msr.as_uint64);\n\t}\n\n\treturn hyperv_init_ghcb();\n}\n\nstatic void (*hv_reenlightenment_cb)(void);\n\nstatic void hv_reenlightenment_notify(struct work_struct *dummy)\n{\n\tstruct hv_tsc_emulation_status emu_status;\n\n\trdmsrl(HV_X64_MSR_TSC_EMULATION_STATUS, *(u64 *)&emu_status);\n\n\t \n\tif (hv_reenlightenment_cb && emu_status.inprogress)\n\t\thv_reenlightenment_cb();\n}\nstatic DECLARE_DELAYED_WORK(hv_reenlightenment_work, hv_reenlightenment_notify);\n\nvoid hyperv_stop_tsc_emulation(void)\n{\n\tu64 freq;\n\tstruct hv_tsc_emulation_status emu_status;\n\n\trdmsrl(HV_X64_MSR_TSC_EMULATION_STATUS, *(u64 *)&emu_status);\n\temu_status.inprogress = 0;\n\twrmsrl(HV_X64_MSR_TSC_EMULATION_STATUS, *(u64 *)&emu_status);\n\n\trdmsrl(HV_X64_MSR_TSC_FREQUENCY, freq);\n\ttsc_khz = div64_u64(freq, 1000);\n}\nEXPORT_SYMBOL_GPL(hyperv_stop_tsc_emulation);\n\nstatic inline bool hv_reenlightenment_available(void)\n{\n\t \n\treturn ms_hyperv.features & HV_ACCESS_FREQUENCY_MSRS &&\n\t\tms_hyperv.misc_features & HV_FEATURE_FREQUENCY_MSRS_AVAILABLE &&\n\t\tms_hyperv.features & HV_ACCESS_REENLIGHTENMENT;\n}\n\nDEFINE_IDTENTRY_SYSVEC(sysvec_hyperv_reenlightenment)\n{\n\tapic_eoi();\n\tinc_irq_stat(irq_hv_reenlightenment_count);\n\tschedule_delayed_work(&hv_reenlightenment_work, HZ/10);\n}\n\nvoid set_hv_tscchange_cb(void (*cb)(void))\n{\n\tstruct hv_reenlightenment_control re_ctrl = {\n\t\t.vector = HYPERV_REENLIGHTENMENT_VECTOR,\n\t\t.enabled = 1,\n\t};\n\tstruct hv_tsc_emulation_control emu_ctrl = {.enabled = 1};\n\n\tif (!hv_reenlightenment_available()) {\n\t\tpr_warn(\"reenlightenment support is unavailable\\n\");\n\t\treturn;\n\t}\n\n\tif (!hv_vp_index)\n\t\treturn;\n\n\thv_reenlightenment_cb = cb;\n\n\t \n\twmb();\n\n\tre_ctrl.target_vp = hv_vp_index[get_cpu()];\n\n\twrmsrl(HV_X64_MSR_REENLIGHTENMENT_CONTROL, *((u64 *)&re_ctrl));\n\twrmsrl(HV_X64_MSR_TSC_EMULATION_CONTROL, *((u64 *)&emu_ctrl));\n\n\tput_cpu();\n}\nEXPORT_SYMBOL_GPL(set_hv_tscchange_cb);\n\nvoid clear_hv_tscchange_cb(void)\n{\n\tstruct hv_reenlightenment_control re_ctrl;\n\n\tif (!hv_reenlightenment_available())\n\t\treturn;\n\n\trdmsrl(HV_X64_MSR_REENLIGHTENMENT_CONTROL, *(u64 *)&re_ctrl);\n\tre_ctrl.enabled = 0;\n\twrmsrl(HV_X64_MSR_REENLIGHTENMENT_CONTROL, *(u64 *)&re_ctrl);\n\n\thv_reenlightenment_cb = NULL;\n}\nEXPORT_SYMBOL_GPL(clear_hv_tscchange_cb);\n\nstatic int hv_cpu_die(unsigned int cpu)\n{\n\tstruct hv_reenlightenment_control re_ctrl;\n\tunsigned int new_cpu;\n\tvoid **ghcb_va;\n\n\tif (hv_ghcb_pg) {\n\t\tghcb_va = (void **)this_cpu_ptr(hv_ghcb_pg);\n\t\tif (*ghcb_va)\n\t\t\tiounmap(*ghcb_va);\n\t\t*ghcb_va = NULL;\n\t}\n\n\thv_common_cpu_die(cpu);\n\n\tif (hv_vp_assist_page && hv_vp_assist_page[cpu]) {\n\t\tunion hv_vp_assist_msr_contents msr = { 0 };\n\t\tif (hv_root_partition) {\n\t\t\t \n\t\t\tmemunmap(hv_vp_assist_page[cpu]);\n\t\t\thv_vp_assist_page[cpu] = NULL;\n\t\t\trdmsrl(HV_X64_MSR_VP_ASSIST_PAGE, msr.as_uint64);\n\t\t\tmsr.enable = 0;\n\t\t}\n\t\twrmsrl(HV_X64_MSR_VP_ASSIST_PAGE, msr.as_uint64);\n\t}\n\n\tif (hv_reenlightenment_cb == NULL)\n\t\treturn 0;\n\n\trdmsrl(HV_X64_MSR_REENLIGHTENMENT_CONTROL, *((u64 *)&re_ctrl));\n\tif (re_ctrl.target_vp == hv_vp_index[cpu]) {\n\t\t \n\t\tnew_cpu = cpumask_any_but(cpu_online_mask, cpu);\n\n\t\tif (new_cpu < nr_cpu_ids)\n\t\t\tre_ctrl.target_vp = hv_vp_index[new_cpu];\n\t\telse\n\t\t\tre_ctrl.enabled = 0;\n\n\t\twrmsrl(HV_X64_MSR_REENLIGHTENMENT_CONTROL, *((u64 *)&re_ctrl));\n\t}\n\n\treturn 0;\n}\n\nstatic int __init hv_pci_init(void)\n{\n\tbool gen2vm = efi_enabled(EFI_BOOT);\n\n\t \n\tif (gen2vm) {\n\t\te820__reserve_resources_late();\n\t\treturn 0;\n\t}\n\n\t \n\treturn 1;\n}\n\nstatic int hv_suspend(void)\n{\n\tunion hv_x64_msr_hypercall_contents hypercall_msr;\n\tint ret;\n\n\tif (hv_root_partition)\n\t\treturn -EPERM;\n\n\t \n\thv_hypercall_pg_saved = hv_hypercall_pg;\n\thv_hypercall_pg = NULL;\n\n\t \n\trdmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\n\thypercall_msr.enable = 0;\n\twrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\n\n\tret = hv_cpu_die(0);\n\treturn ret;\n}\n\nstatic void hv_resume(void)\n{\n\tunion hv_x64_msr_hypercall_contents hypercall_msr;\n\tint ret;\n\n\tret = hv_cpu_init(0);\n\tWARN_ON(ret);\n\n\t \n\trdmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\n\thypercall_msr.enable = 1;\n\thypercall_msr.guest_physical_address =\n\t\tvmalloc_to_pfn(hv_hypercall_pg_saved);\n\twrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\n\n\thv_hypercall_pg = hv_hypercall_pg_saved;\n\thv_hypercall_pg_saved = NULL;\n\n\t \n\tif (hv_reenlightenment_cb)\n\t\tset_hv_tscchange_cb(hv_reenlightenment_cb);\n}\n\n \nstatic struct syscore_ops hv_syscore_ops = {\n\t.suspend\t= hv_suspend,\n\t.resume\t\t= hv_resume,\n};\n\nstatic void (* __initdata old_setup_percpu_clockev)(void);\n\nstatic void __init hv_stimer_setup_percpu_clockev(void)\n{\n\t \n\t(void)hv_stimer_alloc(false);\n\n\t \n\tif (old_setup_percpu_clockev)\n\t\told_setup_percpu_clockev();\n}\n\nstatic void __init hv_get_partition_id(void)\n{\n\tstruct hv_get_partition_id *output_page;\n\tu64 status;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\toutput_page = *this_cpu_ptr(hyperv_pcpu_output_arg);\n\tstatus = hv_do_hypercall(HVCALL_GET_PARTITION_ID, NULL, output_page);\n\tif (!hv_result_success(status)) {\n\t\t \n\t\tpr_err(\"Failed to get partition ID: %lld\\n\", status);\n\t\tBUG();\n\t}\n\thv_current_partition_id = output_page->partition_id;\n\tlocal_irq_restore(flags);\n}\n\n#if IS_ENABLED(CONFIG_HYPERV_VTL_MODE)\nstatic u8 __init get_vtl(void)\n{\n\tu64 control = HV_HYPERCALL_REP_COMP_1 | HVCALL_GET_VP_REGISTERS;\n\tstruct hv_get_vp_registers_input *input;\n\tstruct hv_get_vp_registers_output *output;\n\tunsigned long flags;\n\tu64 ret;\n\n\tlocal_irq_save(flags);\n\tinput = *this_cpu_ptr(hyperv_pcpu_input_arg);\n\toutput = (struct hv_get_vp_registers_output *)input;\n\n\tmemset(input, 0, struct_size(input, element, 1));\n\tinput->header.partitionid = HV_PARTITION_ID_SELF;\n\tinput->header.vpindex = HV_VP_INDEX_SELF;\n\tinput->header.inputvtl = 0;\n\tinput->element[0].name0 = HV_X64_REGISTER_VSM_VP_STATUS;\n\n\tret = hv_do_hypercall(control, input, output);\n\tif (hv_result_success(ret)) {\n\t\tret = output->as64.low & HV_X64_VTL_MASK;\n\t} else {\n\t\tpr_err(\"Failed to get VTL(error: %lld) exiting...\\n\", ret);\n\t\tBUG();\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}\n#else\nstatic inline u8 get_vtl(void) { return 0; }\n#endif\n\n \nvoid __init hyperv_init(void)\n{\n\tu64 guest_id;\n\tunion hv_x64_msr_hypercall_contents hypercall_msr;\n\tint cpuhp;\n\n\tif (x86_hyper_type != X86_HYPER_MS_HYPERV)\n\t\treturn;\n\n\tif (hv_common_init())\n\t\treturn;\n\n\t \n\tif (hv_isolation_type_tdx())\n\t\thv_vp_assist_page = NULL;\n\telse\n\t\thv_vp_assist_page = kcalloc(num_possible_cpus(),\n\t\t\t\t\t    sizeof(*hv_vp_assist_page),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!hv_vp_assist_page) {\n\t\tms_hyperv.hints &= ~HV_X64_ENLIGHTENED_VMCS_RECOMMENDED;\n\n\t\tif (!hv_isolation_type_tdx())\n\t\t\tgoto common_free;\n\t}\n\n\tif (ms_hyperv.paravisor_present && hv_isolation_type_snp()) {\n\t\t \n\t\tif (!hv_ghcb_negotiate_protocol())\n\t\t\thv_ghcb_terminate(SEV_TERM_SET_GEN,\n\t\t\t\t\t  GHCB_SEV_ES_PROT_UNSUPPORTED);\n\n\t\thv_ghcb_pg = alloc_percpu(union hv_ghcb *);\n\t\tif (!hv_ghcb_pg)\n\t\t\tgoto free_vp_assist_page;\n\t}\n\n\tcpuhp = cpuhp_setup_state(CPUHP_AP_HYPERV_ONLINE, \"x86/hyperv_init:online\",\n\t\t\t\t  hv_cpu_init, hv_cpu_die);\n\tif (cpuhp < 0)\n\t\tgoto free_ghcb_page;\n\n\t \n\tguest_id = hv_generate_guest_id(LINUX_VERSION_CODE);\n\twrmsrl(HV_X64_MSR_GUEST_OS_ID, guest_id);\n\n\t \n\thv_ivm_msr_write(HV_X64_MSR_GUEST_OS_ID, guest_id);\n\n\t \n\tif (hv_isolation_type_tdx() && !ms_hyperv.paravisor_present)\n\t\tgoto skip_hypercall_pg_init;\n\n\thv_hypercall_pg = __vmalloc_node_range(PAGE_SIZE, 1, VMALLOC_START,\n\t\t\tVMALLOC_END, GFP_KERNEL, PAGE_KERNEL_ROX,\n\t\t\tVM_FLUSH_RESET_PERMS, NUMA_NO_NODE,\n\t\t\t__builtin_return_address(0));\n\tif (hv_hypercall_pg == NULL)\n\t\tgoto clean_guest_os_id;\n\n\trdmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\n\thypercall_msr.enable = 1;\n\n\tif (hv_root_partition) {\n\t\tstruct page *pg;\n\t\tvoid *src;\n\n\t\t \n\t\twrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\n\n\t\tpg = vmalloc_to_page(hv_hypercall_pg);\n\t\tsrc = memremap(hypercall_msr.guest_physical_address << PAGE_SHIFT, PAGE_SIZE,\n\t\t\t\tMEMREMAP_WB);\n\t\tBUG_ON(!src);\n\t\tmemcpy_to_page(pg, 0, src, HV_HYP_PAGE_SIZE);\n\t\tmemunmap(src);\n\n\t\thv_remap_tsc_clocksource();\n\t} else {\n\t\thypercall_msr.guest_physical_address = vmalloc_to_pfn(hv_hypercall_pg);\n\t\twrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\n\t}\n\nskip_hypercall_pg_init:\n\t \n#ifdef CONFIG_X86_KERNEL_IBT\n\tif (cpu_feature_enabled(X86_FEATURE_IBT) &&\n\t    *(u32 *)hv_hypercall_pg != gen_endbr()) {\n\t\tsetup_clear_cpu_cap(X86_FEATURE_IBT);\n\t\tpr_warn(\"Disabling IBT because of Hyper-V bug\\n\");\n\t}\n#endif\n\n\t \n\told_setup_percpu_clockev = x86_init.timers.setup_percpu_clockev;\n\tx86_init.timers.setup_percpu_clockev = hv_stimer_setup_percpu_clockev;\n\n\thv_apic_init();\n\n\tx86_init.pci.arch_init = hv_pci_init;\n\n\tregister_syscore_ops(&hv_syscore_ops);\n\n\thyperv_init_cpuhp = cpuhp;\n\n\tif (cpuid_ebx(HYPERV_CPUID_FEATURES) & HV_ACCESS_PARTITION_ID)\n\t\thv_get_partition_id();\n\n\tBUG_ON(hv_root_partition && hv_current_partition_id == ~0ull);\n\n#ifdef CONFIG_PCI_MSI\n\t \n\tif (hv_root_partition)\n\t\tx86_init.irqs.create_pci_msi_domain = hv_create_pci_msi_domain;\n#endif\n\n\t \n\thv_query_ext_cap(0);\n\n\t \n\tms_hyperv.vtl = get_vtl();\n\n\tif (ms_hyperv.vtl > 0)  \n\t\thv_vtl_early_init();\n\n\treturn;\n\nclean_guest_os_id:\n\twrmsrl(HV_X64_MSR_GUEST_OS_ID, 0);\n\thv_ivm_msr_write(HV_X64_MSR_GUEST_OS_ID, 0);\n\tcpuhp_remove_state(cpuhp);\nfree_ghcb_page:\n\tfree_percpu(hv_ghcb_pg);\nfree_vp_assist_page:\n\tkfree(hv_vp_assist_page);\n\thv_vp_assist_page = NULL;\ncommon_free:\n\thv_common_free();\n}\n\n \nvoid hyperv_cleanup(void)\n{\n\tunion hv_x64_msr_hypercall_contents hypercall_msr;\n\tunion hv_reference_tsc_msr tsc_msr;\n\n\t \n\twrmsrl(HV_X64_MSR_GUEST_OS_ID, 0);\n\thv_ivm_msr_write(HV_X64_MSR_GUEST_OS_ID, 0);\n\n\t \n\thv_hypercall_pg = NULL;\n\n\t \n\thypercall_msr.as_uint64 = hv_get_register(HV_X64_MSR_HYPERCALL);\n\thypercall_msr.enable = 0;\n\thv_set_register(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\n\n\t \n\ttsc_msr.as_uint64 = hv_get_register(HV_X64_MSR_REFERENCE_TSC);\n\ttsc_msr.enable = 0;\n\thv_set_register(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);\n}\n\nvoid hyperv_report_panic(struct pt_regs *regs, long err, bool in_die)\n{\n\tstatic bool panic_reported;\n\tu64 guest_id;\n\n\tif (in_die && !panic_on_oops)\n\t\treturn;\n\n\t \n\tif (panic_reported)\n\t\treturn;\n\tpanic_reported = true;\n\n\trdmsrl(HV_X64_MSR_GUEST_OS_ID, guest_id);\n\n\twrmsrl(HV_X64_MSR_CRASH_P0, err);\n\twrmsrl(HV_X64_MSR_CRASH_P1, guest_id);\n\twrmsrl(HV_X64_MSR_CRASH_P2, regs->ip);\n\twrmsrl(HV_X64_MSR_CRASH_P3, regs->ax);\n\twrmsrl(HV_X64_MSR_CRASH_P4, regs->sp);\n\n\t \n\twrmsrl(HV_X64_MSR_CRASH_CTL, HV_CRASH_CTL_CRASH_NOTIFY);\n}\nEXPORT_SYMBOL_GPL(hyperv_report_panic);\n\nbool hv_is_hyperv_initialized(void)\n{\n\tunion hv_x64_msr_hypercall_contents hypercall_msr;\n\n\t \n\tif (x86_hyper_type != X86_HYPER_MS_HYPERV)\n\t\treturn false;\n\n\t \n\tif (hv_isolation_type_tdx() && !ms_hyperv.paravisor_present)\n\t\treturn true;\n\t \n\thypercall_msr.as_uint64 = 0;\n\trdmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\n\n\treturn hypercall_msr.enable;\n}\nEXPORT_SYMBOL_GPL(hv_is_hyperv_initialized);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}