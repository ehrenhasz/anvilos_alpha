{
  "module_name": "irqdomain.c",
  "hash_id": "cab04c80e43f5b381c0f7542995efb78e0b94007f03263563ffd38de99655823",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/hyperv/irqdomain.c",
  "human_readable_source": "\n\n \n\n#include <linux/pci.h>\n#include <linux/irq.h>\n#include <asm/mshyperv.h>\n\nstatic int hv_map_interrupt(union hv_device_id device_id, bool level,\n\t\tint cpu, int vector, struct hv_interrupt_entry *entry)\n{\n\tstruct hv_input_map_device_interrupt *input;\n\tstruct hv_output_map_device_interrupt *output;\n\tstruct hv_device_interrupt_descriptor *intr_desc;\n\tunsigned long flags;\n\tu64 status;\n\tint nr_bank, var_size;\n\n\tlocal_irq_save(flags);\n\n\tinput = *this_cpu_ptr(hyperv_pcpu_input_arg);\n\toutput = *this_cpu_ptr(hyperv_pcpu_output_arg);\n\n\tintr_desc = &input->interrupt_descriptor;\n\tmemset(input, 0, sizeof(*input));\n\tinput->partition_id = hv_current_partition_id;\n\tinput->device_id = device_id.as_uint64;\n\tintr_desc->interrupt_type = HV_X64_INTERRUPT_TYPE_FIXED;\n\tintr_desc->vector_count = 1;\n\tintr_desc->target.vector = vector;\n\n\tif (level)\n\t\tintr_desc->trigger_mode = HV_INTERRUPT_TRIGGER_MODE_LEVEL;\n\telse\n\t\tintr_desc->trigger_mode = HV_INTERRUPT_TRIGGER_MODE_EDGE;\n\n\tintr_desc->target.vp_set.valid_bank_mask = 0;\n\tintr_desc->target.vp_set.format = HV_GENERIC_SET_SPARSE_4K;\n\tnr_bank = cpumask_to_vpset(&(intr_desc->target.vp_set), cpumask_of(cpu));\n\tif (nr_bank < 0) {\n\t\tlocal_irq_restore(flags);\n\t\tpr_err(\"%s: unable to generate VP set\\n\", __func__);\n\t\treturn EINVAL;\n\t}\n\tintr_desc->target.flags = HV_DEVICE_INTERRUPT_TARGET_PROCESSOR_SET;\n\n\t \n\tvar_size = nr_bank + 1;\n\n\tstatus = hv_do_rep_hypercall(HVCALL_MAP_DEVICE_INTERRUPT, 0, var_size,\n\t\t\tinput, output);\n\t*entry = output->interrupt_entry;\n\n\tlocal_irq_restore(flags);\n\n\tif (!hv_result_success(status))\n\t\tpr_err(\"%s: hypercall failed, status %lld\\n\", __func__, status);\n\n\treturn hv_result(status);\n}\n\nstatic int hv_unmap_interrupt(u64 id, struct hv_interrupt_entry *old_entry)\n{\n\tunsigned long flags;\n\tstruct hv_input_unmap_device_interrupt *input;\n\tstruct hv_interrupt_entry *intr_entry;\n\tu64 status;\n\n\tlocal_irq_save(flags);\n\tinput = *this_cpu_ptr(hyperv_pcpu_input_arg);\n\n\tmemset(input, 0, sizeof(*input));\n\tintr_entry = &input->interrupt_entry;\n\tinput->partition_id = hv_current_partition_id;\n\tinput->device_id = id;\n\t*intr_entry = *old_entry;\n\n\tstatus = hv_do_hypercall(HVCALL_UNMAP_DEVICE_INTERRUPT, input, NULL);\n\tlocal_irq_restore(flags);\n\n\treturn hv_result(status);\n}\n\n#ifdef CONFIG_PCI_MSI\nstruct rid_data {\n\tstruct pci_dev *bridge;\n\tu32 rid;\n};\n\nstatic int get_rid_cb(struct pci_dev *pdev, u16 alias, void *data)\n{\n\tstruct rid_data *rd = data;\n\tu8 bus = PCI_BUS_NUM(rd->rid);\n\n\tif (pdev->bus->number != bus || PCI_BUS_NUM(alias) != bus) {\n\t\trd->bridge = pdev;\n\t\trd->rid = alias;\n\t}\n\n\treturn 0;\n}\n\nstatic union hv_device_id hv_build_pci_dev_id(struct pci_dev *dev)\n{\n\tunion hv_device_id dev_id;\n\tstruct rid_data data = {\n\t\t.bridge = NULL,\n\t\t.rid = PCI_DEVID(dev->bus->number, dev->devfn)\n\t};\n\n\tpci_for_each_dma_alias(dev, get_rid_cb, &data);\n\n\tdev_id.as_uint64 = 0;\n\tdev_id.device_type = HV_DEVICE_TYPE_PCI;\n\tdev_id.pci.segment = pci_domain_nr(dev->bus);\n\n\tdev_id.pci.bdf.bus = PCI_BUS_NUM(data.rid);\n\tdev_id.pci.bdf.device = PCI_SLOT(data.rid);\n\tdev_id.pci.bdf.function = PCI_FUNC(data.rid);\n\tdev_id.pci.source_shadow = HV_SOURCE_SHADOW_NONE;\n\n\tif (data.bridge) {\n\t\tint pos;\n\n\t\t \n\n\t\tpos = pci_find_capability(data.bridge, PCI_CAP_ID_PCIX);\n\t\tif (pos) {\n\t\t\tu16 status;\n\n\t\t\tpci_read_config_word(data.bridge, pos +\n\t\t\t\t\tPCI_X_BRIDGE_SSTATUS, &status);\n\n\t\t\tif (status & PCI_X_SSTATUS_FREQ) {\n\t\t\t\t \n\t\t\t\tu8 sec_bus, sub_bus;\n\n\t\t\t\tdev_id.pci.source_shadow = HV_SOURCE_SHADOW_BRIDGE_BUS_RANGE;\n\n\t\t\t\tpci_read_config_byte(data.bridge, PCI_SECONDARY_BUS, &sec_bus);\n\t\t\t\tdev_id.pci.shadow_bus_range.secondary_bus = sec_bus;\n\t\t\t\tpci_read_config_byte(data.bridge, PCI_SUBORDINATE_BUS, &sub_bus);\n\t\t\t\tdev_id.pci.shadow_bus_range.subordinate_bus = sub_bus;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dev_id;\n}\n\nstatic int hv_map_msi_interrupt(struct pci_dev *dev, int cpu, int vector,\n\t\t\t\tstruct hv_interrupt_entry *entry)\n{\n\tunion hv_device_id device_id = hv_build_pci_dev_id(dev);\n\n\treturn hv_map_interrupt(device_id, false, cpu, vector, entry);\n}\n\nstatic inline void entry_to_msi_msg(struct hv_interrupt_entry *entry, struct msi_msg *msg)\n{\n\t \n\tmsg->address_hi = 0;\n\tmsg->address_lo = entry->msi_entry.address.as_uint32;\n\tmsg->data = entry->msi_entry.data.as_uint32;\n}\n\nstatic int hv_unmap_msi_interrupt(struct pci_dev *dev, struct hv_interrupt_entry *old_entry);\nstatic void hv_irq_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct msi_desc *msidesc;\n\tstruct pci_dev *dev;\n\tstruct hv_interrupt_entry out_entry, *stored_entry;\n\tstruct irq_cfg *cfg = irqd_cfg(data);\n\tconst cpumask_t *affinity;\n\tint cpu;\n\tu64 status;\n\n\tmsidesc = irq_data_get_msi_desc(data);\n\tdev = msi_desc_to_pci_dev(msidesc);\n\n\tif (!cfg) {\n\t\tpr_debug(\"%s: cfg is NULL\", __func__);\n\t\treturn;\n\t}\n\n\taffinity = irq_data_get_effective_affinity_mask(data);\n\tcpu = cpumask_first_and(affinity, cpu_online_mask);\n\n\tif (data->chip_data) {\n\t\t \n\t\tstored_entry = data->chip_data;\n\t\tdata->chip_data = NULL;\n\n\t\tstatus = hv_unmap_msi_interrupt(dev, stored_entry);\n\n\t\tkfree(stored_entry);\n\n\t\tif (status != HV_STATUS_SUCCESS) {\n\t\t\tpr_debug(\"%s: failed to unmap, status %lld\", __func__, status);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstored_entry = kzalloc(sizeof(*stored_entry), GFP_ATOMIC);\n\tif (!stored_entry) {\n\t\tpr_debug(\"%s: failed to allocate chip data\\n\", __func__);\n\t\treturn;\n\t}\n\n\tstatus = hv_map_msi_interrupt(dev, cpu, cfg->vector, &out_entry);\n\tif (status != HV_STATUS_SUCCESS) {\n\t\tkfree(stored_entry);\n\t\treturn;\n\t}\n\n\t*stored_entry = out_entry;\n\tdata->chip_data = stored_entry;\n\tentry_to_msi_msg(&out_entry, msg);\n\n\treturn;\n}\n\nstatic int hv_unmap_msi_interrupt(struct pci_dev *dev, struct hv_interrupt_entry *old_entry)\n{\n\treturn hv_unmap_interrupt(hv_build_pci_dev_id(dev).as_uint64, old_entry);\n}\n\nstatic void hv_teardown_msi_irq(struct pci_dev *dev, struct irq_data *irqd)\n{\n\tstruct hv_interrupt_entry old_entry;\n\tstruct msi_msg msg;\n\tu64 status;\n\n\tif (!irqd->chip_data) {\n\t\tpr_debug(\"%s: no chip data\\n!\", __func__);\n\t\treturn;\n\t}\n\n\told_entry = *(struct hv_interrupt_entry *)irqd->chip_data;\n\tentry_to_msi_msg(&old_entry, &msg);\n\n\tkfree(irqd->chip_data);\n\tirqd->chip_data = NULL;\n\n\tstatus = hv_unmap_msi_interrupt(dev, &old_entry);\n\n\tif (status != HV_STATUS_SUCCESS)\n\t\tpr_err(\"%s: hypercall failed, status %lld\\n\", __func__, status);\n}\n\nstatic void hv_msi_free_irq(struct irq_domain *domain,\n\t\t\t    struct msi_domain_info *info, unsigned int virq)\n{\n\tstruct irq_data *irqd = irq_get_irq_data(virq);\n\tstruct msi_desc *desc;\n\n\tif (!irqd)\n\t\treturn;\n\n\tdesc = irq_data_get_msi_desc(irqd);\n\tif (!desc || !desc->irq || WARN_ON_ONCE(!dev_is_pci(desc->dev)))\n\t\treturn;\n\n\thv_teardown_msi_irq(to_pci_dev(desc->dev), irqd);\n}\n\n \nstatic struct irq_chip hv_pci_msi_controller = {\n\t.name\t\t\t= \"HV-PCI-MSI\",\n\t.irq_unmask\t\t= pci_msi_unmask_irq,\n\t.irq_mask\t\t= pci_msi_mask_irq,\n\t.irq_ack\t\t= irq_chip_ack_parent,\n\t.irq_retrigger\t\t= irq_chip_retrigger_hierarchy,\n\t.irq_compose_msi_msg\t= hv_irq_compose_msi_msg,\n\t.irq_set_affinity\t= msi_domain_set_affinity,\n\t.flags\t\t\t= IRQCHIP_SKIP_SET_WAKE,\n};\n\nstatic struct msi_domain_ops pci_msi_domain_ops = {\n\t.msi_free\t\t= hv_msi_free_irq,\n\t.msi_prepare\t\t= pci_msi_prepare,\n};\n\nstatic struct msi_domain_info hv_pci_msi_domain_info = {\n\t.flags\t\t= MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t\t  MSI_FLAG_PCI_MSIX,\n\t.ops\t\t= &pci_msi_domain_ops,\n\t.chip\t\t= &hv_pci_msi_controller,\n\t.handler\t= handle_edge_irq,\n\t.handler_name\t= \"edge\",\n};\n\nstruct irq_domain * __init hv_create_pci_msi_domain(void)\n{\n\tstruct irq_domain *d = NULL;\n\tstruct fwnode_handle *fn;\n\n\tfn = irq_domain_alloc_named_fwnode(\"HV-PCI-MSI\");\n\tif (fn)\n\t\td = pci_msi_create_irq_domain(fn, &hv_pci_msi_domain_info, x86_vector_domain);\n\n\t \n\tBUG_ON(!d);\n\n\treturn d;\n}\n\n#endif  \n\nint hv_unmap_ioapic_interrupt(int ioapic_id, struct hv_interrupt_entry *entry)\n{\n\tunion hv_device_id device_id;\n\n\tdevice_id.as_uint64 = 0;\n\tdevice_id.device_type = HV_DEVICE_TYPE_IOAPIC;\n\tdevice_id.ioapic.ioapic_id = (u8)ioapic_id;\n\n\treturn hv_unmap_interrupt(device_id.as_uint64, entry);\n}\nEXPORT_SYMBOL_GPL(hv_unmap_ioapic_interrupt);\n\nint hv_map_ioapic_interrupt(int ioapic_id, bool level, int cpu, int vector,\n\t\tstruct hv_interrupt_entry *entry)\n{\n\tunion hv_device_id device_id;\n\n\tdevice_id.as_uint64 = 0;\n\tdevice_id.device_type = HV_DEVICE_TYPE_IOAPIC;\n\tdevice_id.ioapic.ioapic_id = (u8)ioapic_id;\n\n\treturn hv_map_interrupt(device_id, level, cpu, vector, entry);\n}\nEXPORT_SYMBOL_GPL(hv_map_ioapic_interrupt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}