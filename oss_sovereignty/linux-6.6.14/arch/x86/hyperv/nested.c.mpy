{
  "module_name": "nested.c",
  "hash_id": "dccc6ddfceac70065c34002d7ad1a3f94791b19850f8cfee2b8bc6b6fdb877a8",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/hyperv/nested.c",
  "human_readable_source": "\n\n \n#define pr_fmt(fmt)  \"Hyper-V: \" fmt\n\n\n#include <linux/types.h>\n#include <asm/hyperv-tlfs.h>\n#include <asm/mshyperv.h>\n#include <asm/tlbflush.h>\n\n#include <asm/trace/hyperv.h>\n\nint hyperv_flush_guest_mapping(u64 as)\n{\n\tstruct hv_guest_mapping_flush *flush;\n\tu64 status;\n\tunsigned long flags;\n\tint ret = -ENOTSUPP;\n\n\tif (!hv_hypercall_pg)\n\t\tgoto fault;\n\n\tlocal_irq_save(flags);\n\n\tflush = *this_cpu_ptr(hyperv_pcpu_input_arg);\n\n\tif (unlikely(!flush)) {\n\t\tlocal_irq_restore(flags);\n\t\tgoto fault;\n\t}\n\n\tflush->address_space = as;\n\tflush->flags = 0;\n\n\tstatus = hv_do_hypercall(HVCALL_FLUSH_GUEST_PHYSICAL_ADDRESS_SPACE,\n\t\t\t\t flush, NULL);\n\tlocal_irq_restore(flags);\n\n\tif (hv_result_success(status))\n\t\tret = 0;\n\nfault:\n\ttrace_hyperv_nested_flush_guest_mapping(as, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hyperv_flush_guest_mapping);\n\nint hyperv_fill_flush_guest_mapping_list(\n\t\tstruct hv_guest_mapping_flush_list *flush,\n\t\tu64 start_gfn, u64 pages)\n{\n\tu64 cur = start_gfn;\n\tu64 additional_pages;\n\tint gpa_n = 0;\n\n\tdo {\n\t\t \n\t\tif (gpa_n >= HV_MAX_FLUSH_REP_COUNT)\n\t\t\treturn -ENOSPC;\n\n\t\tadditional_pages = min_t(u64, pages, HV_MAX_FLUSH_PAGES) - 1;\n\n\t\tflush->gpa_list[gpa_n].page.additional_pages = additional_pages;\n\t\tflush->gpa_list[gpa_n].page.largepage = false;\n\t\tflush->gpa_list[gpa_n].page.basepfn = cur;\n\n\t\tpages -= additional_pages + 1;\n\t\tcur += additional_pages + 1;\n\t\tgpa_n++;\n\t} while (pages > 0);\n\n\treturn gpa_n;\n}\nEXPORT_SYMBOL_GPL(hyperv_fill_flush_guest_mapping_list);\n\nint hyperv_flush_guest_mapping_range(u64 as,\n\t\thyperv_fill_flush_list_func fill_flush_list_func, void *data)\n{\n\tstruct hv_guest_mapping_flush_list *flush;\n\tu64 status;\n\tunsigned long flags;\n\tint ret = -ENOTSUPP;\n\tint gpa_n = 0;\n\n\tif (!hv_hypercall_pg || !fill_flush_list_func)\n\t\tgoto fault;\n\n\tlocal_irq_save(flags);\n\n\tflush = *this_cpu_ptr(hyperv_pcpu_input_arg);\n\n\tif (unlikely(!flush)) {\n\t\tlocal_irq_restore(flags);\n\t\tgoto fault;\n\t}\n\n\tflush->address_space = as;\n\tflush->flags = 0;\n\n\tgpa_n = fill_flush_list_func(flush, data);\n\tif (gpa_n < 0) {\n\t\tlocal_irq_restore(flags);\n\t\tgoto fault;\n\t}\n\n\tstatus = hv_do_rep_hypercall(HVCALL_FLUSH_GUEST_PHYSICAL_ADDRESS_LIST,\n\t\t\t\t     gpa_n, 0, flush, NULL);\n\n\tlocal_irq_restore(flags);\n\n\tif (hv_result_success(status))\n\t\tret = 0;\n\telse\n\t\tret = hv_result(status);\nfault:\n\ttrace_hyperv_nested_flush_guest_mapping_range(as, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hyperv_flush_guest_mapping_range);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}