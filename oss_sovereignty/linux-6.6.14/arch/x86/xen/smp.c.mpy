{
  "module_name": "smp.c",
  "hash_id": "462dd7727199238e9b11d1d0f4ef5ae0a7bffc1de0e8584bb787caf194bda66f",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/xen/smp.c",
  "human_readable_source": "\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/cpumask.h>\n#include <linux/percpu.h>\n\n#include <xen/events.h>\n\n#include <xen/hvc-console.h>\n#include \"xen-ops.h\"\n#include \"smp.h\"\n\nstatic DEFINE_PER_CPU(struct xen_common_irq, xen_resched_irq) = { .irq = -1 };\nstatic DEFINE_PER_CPU(struct xen_common_irq, xen_callfunc_irq) = { .irq = -1 };\nstatic DEFINE_PER_CPU(struct xen_common_irq, xen_callfuncsingle_irq) = { .irq = -1 };\nstatic DEFINE_PER_CPU(struct xen_common_irq, xen_debug_irq) = { .irq = -1 };\n\nstatic irqreturn_t xen_call_function_interrupt(int irq, void *dev_id);\nstatic irqreturn_t xen_call_function_single_interrupt(int irq, void *dev_id);\n\n \nstatic irqreturn_t xen_reschedule_interrupt(int irq, void *dev_id)\n{\n\tinc_irq_stat(irq_resched_count);\n\tscheduler_ipi();\n\n\treturn IRQ_HANDLED;\n}\n\nvoid xen_smp_intr_free(unsigned int cpu)\n{\n\tkfree(per_cpu(xen_resched_irq, cpu).name);\n\tper_cpu(xen_resched_irq, cpu).name = NULL;\n\tif (per_cpu(xen_resched_irq, cpu).irq >= 0) {\n\t\tunbind_from_irqhandler(per_cpu(xen_resched_irq, cpu).irq, NULL);\n\t\tper_cpu(xen_resched_irq, cpu).irq = -1;\n\t}\n\tkfree(per_cpu(xen_callfunc_irq, cpu).name);\n\tper_cpu(xen_callfunc_irq, cpu).name = NULL;\n\tif (per_cpu(xen_callfunc_irq, cpu).irq >= 0) {\n\t\tunbind_from_irqhandler(per_cpu(xen_callfunc_irq, cpu).irq, NULL);\n\t\tper_cpu(xen_callfunc_irq, cpu).irq = -1;\n\t}\n\tkfree(per_cpu(xen_debug_irq, cpu).name);\n\tper_cpu(xen_debug_irq, cpu).name = NULL;\n\tif (per_cpu(xen_debug_irq, cpu).irq >= 0) {\n\t\tunbind_from_irqhandler(per_cpu(xen_debug_irq, cpu).irq, NULL);\n\t\tper_cpu(xen_debug_irq, cpu).irq = -1;\n\t}\n\tkfree(per_cpu(xen_callfuncsingle_irq, cpu).name);\n\tper_cpu(xen_callfuncsingle_irq, cpu).name = NULL;\n\tif (per_cpu(xen_callfuncsingle_irq, cpu).irq >= 0) {\n\t\tunbind_from_irqhandler(per_cpu(xen_callfuncsingle_irq, cpu).irq,\n\t\t\t\t       NULL);\n\t\tper_cpu(xen_callfuncsingle_irq, cpu).irq = -1;\n\t}\n}\n\nint xen_smp_intr_init(unsigned int cpu)\n{\n\tint rc;\n\tchar *resched_name, *callfunc_name, *debug_name;\n\n\tresched_name = kasprintf(GFP_KERNEL, \"resched%d\", cpu);\n\tper_cpu(xen_resched_irq, cpu).name = resched_name;\n\trc = bind_ipi_to_irqhandler(XEN_RESCHEDULE_VECTOR,\n\t\t\t\t    cpu,\n\t\t\t\t    xen_reschedule_interrupt,\n\t\t\t\t    IRQF_PERCPU|IRQF_NOBALANCING,\n\t\t\t\t    resched_name,\n\t\t\t\t    NULL);\n\tif (rc < 0)\n\t\tgoto fail;\n\tper_cpu(xen_resched_irq, cpu).irq = rc;\n\n\tcallfunc_name = kasprintf(GFP_KERNEL, \"callfunc%d\", cpu);\n\tper_cpu(xen_callfunc_irq, cpu).name = callfunc_name;\n\trc = bind_ipi_to_irqhandler(XEN_CALL_FUNCTION_VECTOR,\n\t\t\t\t    cpu,\n\t\t\t\t    xen_call_function_interrupt,\n\t\t\t\t    IRQF_PERCPU|IRQF_NOBALANCING,\n\t\t\t\t    callfunc_name,\n\t\t\t\t    NULL);\n\tif (rc < 0)\n\t\tgoto fail;\n\tper_cpu(xen_callfunc_irq, cpu).irq = rc;\n\n\tif (!xen_fifo_events) {\n\t\tdebug_name = kasprintf(GFP_KERNEL, \"debug%d\", cpu);\n\t\tper_cpu(xen_debug_irq, cpu).name = debug_name;\n\t\trc = bind_virq_to_irqhandler(VIRQ_DEBUG, cpu,\n\t\t\t\t\t     xen_debug_interrupt,\n\t\t\t\t\t     IRQF_PERCPU | IRQF_NOBALANCING,\n\t\t\t\t\t     debug_name, NULL);\n\t\tif (rc < 0)\n\t\t\tgoto fail;\n\t\tper_cpu(xen_debug_irq, cpu).irq = rc;\n\t}\n\n\tcallfunc_name = kasprintf(GFP_KERNEL, \"callfuncsingle%d\", cpu);\n\tper_cpu(xen_callfuncsingle_irq, cpu).name = callfunc_name;\n\trc = bind_ipi_to_irqhandler(XEN_CALL_FUNCTION_SINGLE_VECTOR,\n\t\t\t\t    cpu,\n\t\t\t\t    xen_call_function_single_interrupt,\n\t\t\t\t    IRQF_PERCPU|IRQF_NOBALANCING,\n\t\t\t\t    callfunc_name,\n\t\t\t\t    NULL);\n\tif (rc < 0)\n\t\tgoto fail;\n\tper_cpu(xen_callfuncsingle_irq, cpu).irq = rc;\n\n\treturn 0;\n\n fail:\n\txen_smp_intr_free(cpu);\n\treturn rc;\n}\n\nvoid __init xen_smp_cpus_done(unsigned int max_cpus)\n{\n\tif (xen_hvm_domain())\n\t\tnative_smp_cpus_done(max_cpus);\n\telse\n\t\tcalculate_max_logical_packages();\n}\n\nvoid xen_smp_send_reschedule(int cpu)\n{\n\txen_send_IPI_one(cpu, XEN_RESCHEDULE_VECTOR);\n}\n\nstatic void __xen_send_IPI_mask(const struct cpumask *mask,\n\t\t\t      int vector)\n{\n\tunsigned cpu;\n\n\tfor_each_cpu_and(cpu, mask, cpu_online_mask)\n\t\txen_send_IPI_one(cpu, vector);\n}\n\nvoid xen_smp_send_call_function_ipi(const struct cpumask *mask)\n{\n\tint cpu;\n\n\t__xen_send_IPI_mask(mask, XEN_CALL_FUNCTION_VECTOR);\n\n\t \n\tfor_each_cpu(cpu, mask) {\n\t\tif (xen_vcpu_stolen(cpu)) {\n\t\t\tHYPERVISOR_sched_op(SCHEDOP_yield, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid xen_smp_send_call_function_single_ipi(int cpu)\n{\n\t__xen_send_IPI_mask(cpumask_of(cpu),\n\t\t\t  XEN_CALL_FUNCTION_SINGLE_VECTOR);\n}\n\nstatic inline int xen_map_vector(int vector)\n{\n\tint xen_vector;\n\n\tswitch (vector) {\n\tcase RESCHEDULE_VECTOR:\n\t\txen_vector = XEN_RESCHEDULE_VECTOR;\n\t\tbreak;\n\tcase CALL_FUNCTION_VECTOR:\n\t\txen_vector = XEN_CALL_FUNCTION_VECTOR;\n\t\tbreak;\n\tcase CALL_FUNCTION_SINGLE_VECTOR:\n\t\txen_vector = XEN_CALL_FUNCTION_SINGLE_VECTOR;\n\t\tbreak;\n\tcase IRQ_WORK_VECTOR:\n\t\txen_vector = XEN_IRQ_WORK_VECTOR;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase NMI_VECTOR:\n\tcase APIC_DM_NMI:  \n\t\txen_vector = XEN_NMI_VECTOR;\n\t\tbreak;\n#endif\n\tdefault:\n\t\txen_vector = -1;\n\t\tprintk(KERN_ERR \"xen: vector 0x%x is not implemented\\n\",\n\t\t\tvector);\n\t}\n\n\treturn xen_vector;\n}\n\nvoid xen_send_IPI_mask(const struct cpumask *mask,\n\t\t\t      int vector)\n{\n\tint xen_vector = xen_map_vector(vector);\n\n\tif (xen_vector >= 0)\n\t\t__xen_send_IPI_mask(mask, xen_vector);\n}\n\nvoid xen_send_IPI_all(int vector)\n{\n\tint xen_vector = xen_map_vector(vector);\n\n\tif (xen_vector >= 0)\n\t\t__xen_send_IPI_mask(cpu_online_mask, xen_vector);\n}\n\nvoid xen_send_IPI_self(int vector)\n{\n\tint xen_vector = xen_map_vector(vector);\n\n\tif (xen_vector >= 0)\n\t\txen_send_IPI_one(smp_processor_id(), xen_vector);\n}\n\nvoid xen_send_IPI_mask_allbutself(const struct cpumask *mask,\n\t\t\t\tint vector)\n{\n\tunsigned cpu;\n\tunsigned int this_cpu = smp_processor_id();\n\tint xen_vector = xen_map_vector(vector);\n\n\tif (!(num_online_cpus() > 1) || (xen_vector < 0))\n\t\treturn;\n\n\tfor_each_cpu_and(cpu, mask, cpu_online_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\txen_send_IPI_one(cpu, xen_vector);\n\t}\n}\n\nvoid xen_send_IPI_allbutself(int vector)\n{\n\txen_send_IPI_mask_allbutself(cpu_online_mask, vector);\n}\n\nstatic irqreturn_t xen_call_function_interrupt(int irq, void *dev_id)\n{\n\tgeneric_smp_call_function_interrupt();\n\tinc_irq_stat(irq_call_count);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t xen_call_function_single_interrupt(int irq, void *dev_id)\n{\n\tgeneric_smp_call_function_single_interrupt();\n\tinc_irq_stat(irq_call_count);\n\n\treturn IRQ_HANDLED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}