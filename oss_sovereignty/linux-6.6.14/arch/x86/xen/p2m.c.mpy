{
  "module_name": "p2m.c",
  "hash_id": "c0e42115b967a1ecdbcc0fc1a75e35b4ebef9246442ed98f7f0cb615e80d3e98",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/xen/p2m.c",
  "human_readable_source": "\n\n \n\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/memblock.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\n#include <asm/cache.h>\n#include <asm/setup.h>\n#include <linux/uaccess.h>\n\n#include <asm/xen/page.h>\n#include <asm/xen/hypercall.h>\n#include <asm/xen/hypervisor.h>\n#include <xen/balloon.h>\n#include <xen/grant_table.h>\n\n#include \"multicalls.h\"\n#include \"xen-ops.h\"\n\n#define P2M_MID_PER_PAGE\t(PAGE_SIZE / sizeof(unsigned long *))\n#define P2M_TOP_PER_PAGE\t(PAGE_SIZE / sizeof(unsigned long **))\n\n#define MAX_P2M_PFN\t(P2M_TOP_PER_PAGE * P2M_MID_PER_PAGE * P2M_PER_PAGE)\n\n#define PMDS_PER_MID_PAGE\t(P2M_MID_PER_PAGE / PTRS_PER_PTE)\n\nunsigned long *xen_p2m_addr __read_mostly;\nEXPORT_SYMBOL_GPL(xen_p2m_addr);\nunsigned long xen_p2m_size __read_mostly;\nEXPORT_SYMBOL_GPL(xen_p2m_size);\nunsigned long xen_max_p2m_pfn __read_mostly;\nEXPORT_SYMBOL_GPL(xen_max_p2m_pfn);\n\n#ifdef CONFIG_XEN_MEMORY_HOTPLUG_LIMIT\n#define P2M_LIMIT CONFIG_XEN_MEMORY_HOTPLUG_LIMIT\n#else\n#define P2M_LIMIT 0\n#endif\n\nstatic DEFINE_SPINLOCK(p2m_update_lock);\n\nstatic unsigned long *p2m_mid_missing_mfn;\nstatic unsigned long *p2m_top_mfn;\nstatic unsigned long **p2m_top_mfn_p;\nstatic unsigned long *p2m_missing;\nstatic unsigned long *p2m_identity;\nstatic pte_t *p2m_missing_pte;\nstatic pte_t *p2m_identity_pte;\n\n \nstatic unsigned long xen_p2m_last_pfn;\n\nstatic inline unsigned p2m_top_index(unsigned long pfn)\n{\n\tBUG_ON(pfn >= MAX_P2M_PFN);\n\treturn pfn / (P2M_MID_PER_PAGE * P2M_PER_PAGE);\n}\n\nstatic inline unsigned p2m_mid_index(unsigned long pfn)\n{\n\treturn (pfn / P2M_PER_PAGE) % P2M_MID_PER_PAGE;\n}\n\nstatic void p2m_top_mfn_init(unsigned long *top)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < P2M_TOP_PER_PAGE; i++)\n\t\ttop[i] = virt_to_mfn(p2m_mid_missing_mfn);\n}\n\nstatic void p2m_top_mfn_p_init(unsigned long **top)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < P2M_TOP_PER_PAGE; i++)\n\t\ttop[i] = p2m_mid_missing_mfn;\n}\n\nstatic void p2m_mid_mfn_init(unsigned long *mid, unsigned long *leaf)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < P2M_MID_PER_PAGE; i++)\n\t\tmid[i] = virt_to_mfn(leaf);\n}\n\nstatic void p2m_init(unsigned long *p2m)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < P2M_PER_PAGE; i++)\n\t\tp2m[i] = INVALID_P2M_ENTRY;\n}\n\nstatic void p2m_init_identity(unsigned long *p2m, unsigned long pfn)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < P2M_PER_PAGE; i++)\n\t\tp2m[i] = IDENTITY_FRAME(pfn + i);\n}\n\nstatic void * __ref alloc_p2m_page(void)\n{\n\tif (unlikely(!slab_is_available())) {\n\t\tvoid *ptr = memblock_alloc(PAGE_SIZE, PAGE_SIZE);\n\n\t\tif (!ptr)\n\t\t\tpanic(\"%s: Failed to allocate %lu bytes align=0x%lx\\n\",\n\t\t\t      __func__, PAGE_SIZE, PAGE_SIZE);\n\n\t\treturn ptr;\n\t}\n\n\treturn (void *)__get_free_page(GFP_KERNEL);\n}\n\nstatic void __ref free_p2m_page(void *p)\n{\n\tif (unlikely(!slab_is_available())) {\n\t\tmemblock_free(p, PAGE_SIZE);\n\t\treturn;\n\t}\n\n\tfree_page((unsigned long)p);\n}\n\n \nvoid __ref xen_build_mfn_list_list(void)\n{\n\tunsigned long pfn, mfn;\n\tpte_t *ptep;\n\tunsigned int level, topidx, mididx;\n\tunsigned long *mid_mfn_p;\n\n\tif (xen_start_info->flags & SIF_VIRT_P2M_4TOOLS)\n\t\treturn;\n\n\t \n\tif (p2m_top_mfn == NULL) {\n\t\tp2m_mid_missing_mfn = alloc_p2m_page();\n\t\tp2m_mid_mfn_init(p2m_mid_missing_mfn, p2m_missing);\n\n\t\tp2m_top_mfn_p = alloc_p2m_page();\n\t\tp2m_top_mfn_p_init(p2m_top_mfn_p);\n\n\t\tp2m_top_mfn = alloc_p2m_page();\n\t\tp2m_top_mfn_init(p2m_top_mfn);\n\t} else {\n\t\t \n\t\tp2m_mid_mfn_init(p2m_mid_missing_mfn, p2m_missing);\n\t}\n\n\tfor (pfn = 0; pfn < xen_max_p2m_pfn && pfn < MAX_P2M_PFN;\n\t     pfn += P2M_PER_PAGE) {\n\t\ttopidx = p2m_top_index(pfn);\n\t\tmididx = p2m_mid_index(pfn);\n\n\t\tmid_mfn_p = p2m_top_mfn_p[topidx];\n\t\tptep = lookup_address((unsigned long)(xen_p2m_addr + pfn),\n\t\t\t\t      &level);\n\t\tBUG_ON(!ptep || level != PG_LEVEL_4K);\n\t\tmfn = pte_mfn(*ptep);\n\t\tptep = (pte_t *)((unsigned long)ptep & ~(PAGE_SIZE - 1));\n\n\t\t \n\t\tif (ptep == p2m_missing_pte || ptep == p2m_identity_pte) {\n\t\t\tBUG_ON(mididx);\n\t\t\tBUG_ON(mid_mfn_p != p2m_mid_missing_mfn);\n\t\t\tp2m_top_mfn[topidx] = virt_to_mfn(p2m_mid_missing_mfn);\n\t\t\tpfn += (P2M_MID_PER_PAGE - 1) * P2M_PER_PAGE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mid_mfn_p == p2m_mid_missing_mfn) {\n\t\t\tmid_mfn_p = alloc_p2m_page();\n\t\t\tp2m_mid_mfn_init(mid_mfn_p, p2m_missing);\n\n\t\t\tp2m_top_mfn_p[topidx] = mid_mfn_p;\n\t\t}\n\n\t\tp2m_top_mfn[topidx] = virt_to_mfn(mid_mfn_p);\n\t\tmid_mfn_p[mididx] = mfn;\n\t}\n}\n\nvoid xen_setup_mfn_list_list(void)\n{\n\tBUG_ON(HYPERVISOR_shared_info == &xen_dummy_shared_info);\n\n\tif (xen_start_info->flags & SIF_VIRT_P2M_4TOOLS)\n\t\tHYPERVISOR_shared_info->arch.pfn_to_mfn_frame_list_list = ~0UL;\n\telse\n\t\tHYPERVISOR_shared_info->arch.pfn_to_mfn_frame_list_list =\n\t\t\tvirt_to_mfn(p2m_top_mfn);\n\tHYPERVISOR_shared_info->arch.max_pfn = xen_p2m_last_pfn;\n\tHYPERVISOR_shared_info->arch.p2m_generation = 0;\n\tHYPERVISOR_shared_info->arch.p2m_vaddr = (unsigned long)xen_p2m_addr;\n\tHYPERVISOR_shared_info->arch.p2m_cr3 =\n\t\txen_pfn_to_cr3(virt_to_mfn(swapper_pg_dir));\n}\n\n \nvoid __init xen_build_dynamic_phys_to_machine(void)\n{\n\tunsigned long pfn;\n\n\txen_p2m_addr = (unsigned long *)xen_start_info->mfn_list;\n\txen_p2m_size = ALIGN(xen_start_info->nr_pages, P2M_PER_PAGE);\n\n\tfor (pfn = xen_start_info->nr_pages; pfn < xen_p2m_size; pfn++)\n\t\txen_p2m_addr[pfn] = INVALID_P2M_ENTRY;\n\n\txen_max_p2m_pfn = xen_p2m_size;\n}\n\n#define P2M_TYPE_IDENTITY\t0\n#define P2M_TYPE_MISSING\t1\n#define P2M_TYPE_PFN\t\t2\n#define P2M_TYPE_UNKNOWN\t3\n\nstatic int xen_p2m_elem_type(unsigned long pfn)\n{\n\tunsigned long mfn;\n\n\tif (pfn >= xen_p2m_size)\n\t\treturn P2M_TYPE_IDENTITY;\n\n\tmfn = xen_p2m_addr[pfn];\n\n\tif (mfn == INVALID_P2M_ENTRY)\n\t\treturn P2M_TYPE_MISSING;\n\n\tif (mfn & IDENTITY_FRAME_BIT)\n\t\treturn P2M_TYPE_IDENTITY;\n\n\treturn P2M_TYPE_PFN;\n}\n\nstatic void __init xen_rebuild_p2m_list(unsigned long *p2m)\n{\n\tunsigned int i, chunk;\n\tunsigned long pfn;\n\tunsigned long *mfns;\n\tpte_t *ptep;\n\tpmd_t *pmdp;\n\tint type;\n\n\tp2m_missing = alloc_p2m_page();\n\tp2m_init(p2m_missing);\n\tp2m_identity = alloc_p2m_page();\n\tp2m_init(p2m_identity);\n\n\tp2m_missing_pte = alloc_p2m_page();\n\tparavirt_alloc_pte(&init_mm, __pa(p2m_missing_pte) >> PAGE_SHIFT);\n\tp2m_identity_pte = alloc_p2m_page();\n\tparavirt_alloc_pte(&init_mm, __pa(p2m_identity_pte) >> PAGE_SHIFT);\n\tfor (i = 0; i < PTRS_PER_PTE; i++) {\n\t\tset_pte(p2m_missing_pte + i,\n\t\t\tpfn_pte(PFN_DOWN(__pa(p2m_missing)), PAGE_KERNEL_RO));\n\t\tset_pte(p2m_identity_pte + i,\n\t\t\tpfn_pte(PFN_DOWN(__pa(p2m_identity)), PAGE_KERNEL_RO));\n\t}\n\n\tfor (pfn = 0; pfn < xen_max_p2m_pfn; pfn += chunk) {\n\t\t \n\t\tchunk = (pfn & (P2M_PER_PAGE * P2M_MID_PER_PAGE - 1)) ?\n\t\t\tP2M_PER_PAGE : P2M_PER_PAGE * P2M_MID_PER_PAGE;\n\n\t\ttype = xen_p2m_elem_type(pfn);\n\t\ti = 0;\n\t\tif (type != P2M_TYPE_PFN)\n\t\t\tfor (i = 1; i < chunk; i++)\n\t\t\t\tif (xen_p2m_elem_type(pfn + i) != type)\n\t\t\t\t\tbreak;\n\t\tif (i < chunk)\n\t\t\t \n\t\t\tchunk = P2M_PER_PAGE;\n\n\t\tif (type == P2M_TYPE_PFN || i < chunk) {\n\t\t\t \n\t\t\tmfns = alloc_p2m_page();\n\t\t\tcopy_page(mfns, xen_p2m_addr + pfn);\n\t\t\tptep = populate_extra_pte((unsigned long)(p2m + pfn));\n\t\t\tset_pte(ptep,\n\t\t\t\tpfn_pte(PFN_DOWN(__pa(mfns)), PAGE_KERNEL));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (chunk == P2M_PER_PAGE) {\n\t\t\t \n\t\t\tmfns = (type == P2M_TYPE_MISSING) ?\n\t\t\t\tp2m_missing : p2m_identity;\n\t\t\tptep = populate_extra_pte((unsigned long)(p2m + pfn));\n\t\t\tset_pte(ptep,\n\t\t\t\tpfn_pte(PFN_DOWN(__pa(mfns)), PAGE_KERNEL_RO));\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tptep = (type == P2M_TYPE_MISSING) ?\n\t\t\tp2m_missing_pte : p2m_identity_pte;\n\t\tfor (i = 0; i < PMDS_PER_MID_PAGE; i++) {\n\t\t\tpmdp = populate_extra_pmd(\n\t\t\t\t(unsigned long)(p2m + pfn) + i * PMD_SIZE);\n\t\t\tset_pmd(pmdp, __pmd(__pa(ptep) | _KERNPG_TABLE));\n\t\t}\n\t}\n}\n\nvoid __init xen_vmalloc_p2m_tree(void)\n{\n\tstatic struct vm_struct vm;\n\tunsigned long p2m_limit;\n\n\txen_p2m_last_pfn = xen_max_p2m_pfn;\n\n\tp2m_limit = (phys_addr_t)P2M_LIMIT * 1024 * 1024 * 1024 / PAGE_SIZE;\n\tvm.flags = VM_ALLOC;\n\tvm.size = ALIGN(sizeof(unsigned long) * max(xen_max_p2m_pfn, p2m_limit),\n\t\t\tPMD_SIZE * PMDS_PER_MID_PAGE);\n\tvm_area_register_early(&vm, PMD_SIZE * PMDS_PER_MID_PAGE);\n\tpr_notice(\"p2m virtual area at %p, size is %lx\\n\", vm.addr, vm.size);\n\n\txen_max_p2m_pfn = vm.size / sizeof(unsigned long);\n\n\txen_rebuild_p2m_list(vm.addr);\n\n\txen_p2m_addr = vm.addr;\n\txen_p2m_size = xen_max_p2m_pfn;\n\n\txen_inv_extra_mem();\n}\n\nunsigned long get_phys_to_machine(unsigned long pfn)\n{\n\tpte_t *ptep;\n\tunsigned int level;\n\n\tif (unlikely(pfn >= xen_p2m_size)) {\n\t\tif (pfn < xen_max_p2m_pfn)\n\t\t\treturn xen_chk_extra_mem(pfn);\n\n\t\treturn IDENTITY_FRAME(pfn);\n\t}\n\n\tptep = lookup_address((unsigned long)(xen_p2m_addr + pfn), &level);\n\tBUG_ON(!ptep || level != PG_LEVEL_4K);\n\n\t \n\tif (pte_pfn(*ptep) == PFN_DOWN(__pa(p2m_identity)))\n\t\treturn IDENTITY_FRAME(pfn);\n\n\treturn xen_p2m_addr[pfn];\n}\nEXPORT_SYMBOL_GPL(get_phys_to_machine);\n\n \nstatic pte_t *alloc_p2m_pmd(unsigned long addr, pte_t *pte_pg)\n{\n\tpte_t *ptechk;\n\tpte_t *pte_newpg[PMDS_PER_MID_PAGE];\n\tpmd_t *pmdp;\n\tunsigned int level;\n\tunsigned long flags;\n\tunsigned long vaddr;\n\tint i;\n\n\t \n\tfor (i = 0; i < PMDS_PER_MID_PAGE; i++) {\n\t\tpte_newpg[i] = alloc_p2m_page();\n\t\tif (!pte_newpg[i]) {\n\t\t\tfor (i--; i >= 0; i--)\n\t\t\t\tfree_p2m_page(pte_newpg[i]);\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tvaddr = addr & ~(PMD_SIZE * PMDS_PER_MID_PAGE - 1);\n\n\tfor (i = 0; i < PMDS_PER_MID_PAGE; i++) {\n\t\tcopy_page(pte_newpg[i], pte_pg);\n\t\tparavirt_alloc_pte(&init_mm, __pa(pte_newpg[i]) >> PAGE_SHIFT);\n\n\t\tpmdp = lookup_pmd_address(vaddr);\n\t\tBUG_ON(!pmdp);\n\n\t\tspin_lock_irqsave(&p2m_update_lock, flags);\n\n\t\tptechk = lookup_address(vaddr, &level);\n\t\tif (ptechk == pte_pg) {\n\t\t\tHYPERVISOR_shared_info->arch.p2m_generation++;\n\t\t\twmb();  \n\t\t\tset_pmd(pmdp,\n\t\t\t\t__pmd(__pa(pte_newpg[i]) | _KERNPG_TABLE));\n\t\t\twmb();  \n\t\t\tHYPERVISOR_shared_info->arch.p2m_generation++;\n\t\t\tpte_newpg[i] = NULL;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&p2m_update_lock, flags);\n\n\t\tif (pte_newpg[i]) {\n\t\t\tparavirt_release_pte(__pa(pte_newpg[i]) >> PAGE_SHIFT);\n\t\t\tfree_p2m_page(pte_newpg[i]);\n\t\t}\n\n\t\tvaddr += PMD_SIZE;\n\t}\n\n\treturn lookup_address(addr, &level);\n}\n\n \nint xen_alloc_p2m_entry(unsigned long pfn)\n{\n\tunsigned topidx;\n\tunsigned long *top_mfn_p, *mid_mfn;\n\tpte_t *ptep, *pte_pg;\n\tunsigned int level;\n\tunsigned long flags;\n\tunsigned long addr = (unsigned long)(xen_p2m_addr + pfn);\n\tunsigned long p2m_pfn;\n\n\tptep = lookup_address(addr, &level);\n\tBUG_ON(!ptep || level != PG_LEVEL_4K);\n\tpte_pg = (pte_t *)((unsigned long)ptep & ~(PAGE_SIZE - 1));\n\n\tif (pte_pg == p2m_missing_pte || pte_pg == p2m_identity_pte) {\n\t\t \n\t\tptep = alloc_p2m_pmd(addr, pte_pg);\n\t\tif (!ptep)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (p2m_top_mfn && pfn < MAX_P2M_PFN) {\n\t\ttopidx = p2m_top_index(pfn);\n\t\ttop_mfn_p = &p2m_top_mfn[topidx];\n\t\tmid_mfn = READ_ONCE(p2m_top_mfn_p[topidx]);\n\n\t\tBUG_ON(virt_to_mfn(mid_mfn) != *top_mfn_p);\n\n\t\tif (mid_mfn == p2m_mid_missing_mfn) {\n\t\t\t \n\t\t\tunsigned long missing_mfn;\n\t\t\tunsigned long mid_mfn_mfn;\n\t\t\tunsigned long old_mfn;\n\n\t\t\tmid_mfn = alloc_p2m_page();\n\t\t\tif (!mid_mfn)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tp2m_mid_mfn_init(mid_mfn, p2m_missing);\n\n\t\t\tmissing_mfn = virt_to_mfn(p2m_mid_missing_mfn);\n\t\t\tmid_mfn_mfn = virt_to_mfn(mid_mfn);\n\t\t\told_mfn = cmpxchg(top_mfn_p, missing_mfn, mid_mfn_mfn);\n\t\t\tif (old_mfn != missing_mfn) {\n\t\t\t\tfree_p2m_page(mid_mfn);\n\t\t\t\tmid_mfn = mfn_to_virt(old_mfn);\n\t\t\t} else {\n\t\t\t\tp2m_top_mfn_p[topidx] = mid_mfn;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmid_mfn = NULL;\n\t}\n\n\tp2m_pfn = pte_pfn(READ_ONCE(*ptep));\n\tif (p2m_pfn == PFN_DOWN(__pa(p2m_identity)) ||\n\t    p2m_pfn == PFN_DOWN(__pa(p2m_missing))) {\n\t\t \n\t\tunsigned long *p2m;\n\n\t\tp2m = alloc_p2m_page();\n\t\tif (!p2m)\n\t\t\treturn -ENOMEM;\n\n\t\tif (p2m_pfn == PFN_DOWN(__pa(p2m_missing)))\n\t\t\tp2m_init(p2m);\n\t\telse\n\t\t\tp2m_init_identity(p2m, pfn & ~(P2M_PER_PAGE - 1));\n\n\t\tspin_lock_irqsave(&p2m_update_lock, flags);\n\n\t\tif (pte_pfn(*ptep) == p2m_pfn) {\n\t\t\tHYPERVISOR_shared_info->arch.p2m_generation++;\n\t\t\twmb();  \n\t\t\tset_pte(ptep,\n\t\t\t\tpfn_pte(PFN_DOWN(__pa(p2m)), PAGE_KERNEL));\n\t\t\twmb();  \n\t\t\tHYPERVISOR_shared_info->arch.p2m_generation++;\n\t\t\tif (mid_mfn)\n\t\t\t\tmid_mfn[p2m_mid_index(pfn)] = virt_to_mfn(p2m);\n\t\t\tp2m = NULL;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&p2m_update_lock, flags);\n\n\t\tif (p2m)\n\t\t\tfree_p2m_page(p2m);\n\t}\n\n\t \n\tif (pfn >= xen_p2m_last_pfn) {\n\t\txen_p2m_last_pfn = ALIGN(pfn + 1, P2M_PER_PAGE);\n\t\tHYPERVISOR_shared_info->arch.max_pfn = xen_p2m_last_pfn;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(xen_alloc_p2m_entry);\n\nunsigned long __init set_phys_range_identity(unsigned long pfn_s,\n\t\t\t\t      unsigned long pfn_e)\n{\n\tunsigned long pfn;\n\n\tif (unlikely(pfn_s >= xen_p2m_size))\n\t\treturn 0;\n\n\tif (pfn_s > pfn_e)\n\t\treturn 0;\n\n\tif (pfn_e > xen_p2m_size)\n\t\tpfn_e = xen_p2m_size;\n\n\tfor (pfn = pfn_s; pfn < pfn_e; pfn++)\n\t\txen_p2m_addr[pfn] = IDENTITY_FRAME(pfn);\n\n\treturn pfn - pfn_s;\n}\n\nbool __set_phys_to_machine(unsigned long pfn, unsigned long mfn)\n{\n\tpte_t *ptep;\n\tunsigned int level;\n\n\t \n\tif (unlikely(pfn >= xen_p2m_size))\n\t\treturn mfn == INVALID_P2M_ENTRY;\n\n\t \n\tif (likely(!xen_safe_write_ulong(xen_p2m_addr + pfn, mfn)))\n\t\treturn true;\n\n\tptep = lookup_address((unsigned long)(xen_p2m_addr + pfn), &level);\n\tBUG_ON(!ptep || level != PG_LEVEL_4K);\n\n\tif (pte_pfn(*ptep) == PFN_DOWN(__pa(p2m_missing)))\n\t\treturn mfn == INVALID_P2M_ENTRY;\n\n\tif (pte_pfn(*ptep) == PFN_DOWN(__pa(p2m_identity)))\n\t\treturn mfn == IDENTITY_FRAME(pfn);\n\n\treturn false;\n}\n\nbool set_phys_to_machine(unsigned long pfn, unsigned long mfn)\n{\n\tif (unlikely(!__set_phys_to_machine(pfn, mfn))) {\n\t\tint ret;\n\n\t\tret = xen_alloc_p2m_entry(pfn);\n\t\tif (ret < 0)\n\t\t\treturn false;\n\n\t\treturn __set_phys_to_machine(pfn, mfn);\n\t}\n\n\treturn true;\n}\n\nint set_foreign_p2m_mapping(struct gnttab_map_grant_ref *map_ops,\n\t\t\t    struct gnttab_map_grant_ref *kmap_ops,\n\t\t\t    struct page **pages, unsigned int count)\n{\n\tint i, ret = 0;\n\tpte_t *pte;\n\n\tif (xen_feature(XENFEAT_auto_translated_physmap))\n\t\treturn 0;\n\n\tif (kmap_ops) {\n\t\tret = HYPERVISOR_grant_table_op(GNTTABOP_map_grant_ref,\n\t\t\t\t\t\tkmap_ops, count);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tunsigned long mfn, pfn;\n\t\tstruct gnttab_unmap_grant_ref unmap[2];\n\t\tint rc;\n\n\t\t \n\t\tif (map_ops[i].status != GNTST_okay ||\n\t\t    (kmap_ops && kmap_ops[i].status != GNTST_okay))\n\t\t\tcontinue;\n\n\t\tif (map_ops[i].flags & GNTMAP_contains_pte) {\n\t\t\tpte = (pte_t *)(mfn_to_virt(PFN_DOWN(map_ops[i].host_addr)) +\n\t\t\t\t(map_ops[i].host_addr & ~PAGE_MASK));\n\t\t\tmfn = pte_mfn(*pte);\n\t\t} else {\n\t\t\tmfn = PFN_DOWN(map_ops[i].dev_bus_addr);\n\t\t}\n\t\tpfn = page_to_pfn(pages[i]);\n\n\t\tWARN(pfn_to_mfn(pfn) != INVALID_P2M_ENTRY, \"page must be ballooned\");\n\n\t\tif (likely(set_phys_to_machine(pfn, FOREIGN_FRAME(mfn))))\n\t\t\tcontinue;\n\n\t\t \n\t\tmap_ops[i].status = GNTST_general_error;\n\t\tunmap[0].host_addr = map_ops[i].host_addr,\n\t\tunmap[0].handle = map_ops[i].handle;\n\t\tmap_ops[i].handle = INVALID_GRANT_HANDLE;\n\t\tif (map_ops[i].flags & GNTMAP_device_map)\n\t\t\tunmap[0].dev_bus_addr = map_ops[i].dev_bus_addr;\n\t\telse\n\t\t\tunmap[0].dev_bus_addr = 0;\n\n\t\tif (kmap_ops) {\n\t\t\tkmap_ops[i].status = GNTST_general_error;\n\t\t\tunmap[1].host_addr = kmap_ops[i].host_addr,\n\t\t\tunmap[1].handle = kmap_ops[i].handle;\n\t\t\tkmap_ops[i].handle = INVALID_GRANT_HANDLE;\n\t\t\tif (kmap_ops[i].flags & GNTMAP_device_map)\n\t\t\t\tunmap[1].dev_bus_addr = kmap_ops[i].dev_bus_addr;\n\t\t\telse\n\t\t\t\tunmap[1].dev_bus_addr = 0;\n\t\t}\n\n\t\t \n\t\tunmap[0].status = 1;\n\t\tunmap[1].status = 1;\n\n\t\trc = HYPERVISOR_grant_table_op(GNTTABOP_unmap_grant_ref,\n\t\t\t\t\t       unmap, 1 + !!kmap_ops);\n\t\tif (rc || unmap[0].status != GNTST_okay ||\n\t\t    unmap[1].status != GNTST_okay)\n\t\t\tpr_err_once(\"gnttab unmap failed: rc=%d st0=%d st1=%d\\n\",\n\t\t\t\t    rc, unmap[0].status, unmap[1].status);\n\t}\n\nout:\n\treturn ret;\n}\n\nint clear_foreign_p2m_mapping(struct gnttab_unmap_grant_ref *unmap_ops,\n\t\t\t      struct gnttab_unmap_grant_ref *kunmap_ops,\n\t\t\t      struct page **pages, unsigned int count)\n{\n\tint i, ret = 0;\n\n\tif (xen_feature(XENFEAT_auto_translated_physmap))\n\t\treturn 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tunsigned long mfn = __pfn_to_mfn(page_to_pfn(pages[i]));\n\t\tunsigned long pfn = page_to_pfn(pages[i]);\n\n\t\tif (mfn != INVALID_P2M_ENTRY && (mfn & FOREIGN_FRAME_BIT))\n\t\t\tset_phys_to_machine(pfn, INVALID_P2M_ENTRY);\n\t\telse\n\t\t\tret = -EINVAL;\n\t}\n\tif (kunmap_ops)\n\t\tret = HYPERVISOR_grant_table_op(GNTTABOP_unmap_grant_ref,\n\t\t\t\t\t\tkunmap_ops, count) ?: ret;\n\n\treturn ret;\n}\n\n#ifdef CONFIG_XEN_DEBUG_FS\n#include <linux/debugfs.h>\n#include \"debugfs.h\"\nstatic int p2m_dump_show(struct seq_file *m, void *v)\n{\n\tstatic const char * const type_name[] = {\n\t\t\t\t[P2M_TYPE_IDENTITY] = \"identity\",\n\t\t\t\t[P2M_TYPE_MISSING] = \"missing\",\n\t\t\t\t[P2M_TYPE_PFN] = \"pfn\",\n\t\t\t\t[P2M_TYPE_UNKNOWN] = \"abnormal\"};\n\tunsigned long pfn, first_pfn;\n\tint type, prev_type;\n\n\tprev_type = xen_p2m_elem_type(0);\n\tfirst_pfn = 0;\n\n\tfor (pfn = 0; pfn < xen_p2m_size; pfn++) {\n\t\ttype = xen_p2m_elem_type(pfn);\n\t\tif (type != prev_type) {\n\t\t\tseq_printf(m, \" [0x%lx->0x%lx] %s\\n\", first_pfn, pfn,\n\t\t\t\t   type_name[prev_type]);\n\t\t\tprev_type = type;\n\t\t\tfirst_pfn = pfn;\n\t\t}\n\t}\n\tseq_printf(m, \" [0x%lx->0x%lx] %s\\n\", first_pfn, pfn,\n\t\t   type_name[prev_type]);\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(p2m_dump);\n\nstatic struct dentry *d_mmu_debug;\n\nstatic int __init xen_p2m_debugfs(void)\n{\n\tstruct dentry *d_xen = xen_init_debugfs();\n\n\td_mmu_debug = debugfs_create_dir(\"mmu\", d_xen);\n\n\tdebugfs_create_file(\"p2m\", 0600, d_mmu_debug, NULL, &p2m_dump_fops);\n\treturn 0;\n}\nfs_initcall(xen_p2m_debugfs);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}