{
  "module_name": "time.c",
  "hash_id": "188e76494eda06c7f2277f5b5d426cd4954a469265d056a6f1a79b51493feb5e",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/xen/time.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include <linux/clockchips.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n\n#include <asm/pvclock.h>\n#include <asm/xen/hypervisor.h>\n#include <asm/xen/hypercall.h>\n#include <asm/xen/cpuid.h>\n\n#include <xen/events.h>\n#include <xen/features.h>\n#include <xen/interface/xen.h>\n#include <xen/interface/vcpu.h>\n\n#include \"xen-ops.h\"\n\n \n#define TIMER_SLOP\t100000\n\nstatic u64 xen_sched_clock_offset __read_mostly;\n\n \nstatic unsigned long xen_tsc_khz(void)\n{\n\tstruct pvclock_vcpu_time_info *info =\n\t\t&HYPERVISOR_shared_info->vcpu_info[0].time;\n\n\tsetup_force_cpu_cap(X86_FEATURE_TSC_KNOWN_FREQ);\n\treturn pvclock_tsc_khz(info);\n}\n\nstatic u64 xen_clocksource_read(void)\n{\n        struct pvclock_vcpu_time_info *src;\n\tu64 ret;\n\n\tpreempt_disable_notrace();\n\tsrc = &__this_cpu_read(xen_vcpu)->time;\n\tret = pvclock_clocksource_read(src);\n\tpreempt_enable_notrace();\n\treturn ret;\n}\n\nstatic u64 xen_clocksource_get_cycles(struct clocksource *cs)\n{\n\treturn xen_clocksource_read();\n}\n\nstatic noinstr u64 xen_sched_clock(void)\n{\n        struct pvclock_vcpu_time_info *src;\n\tu64 ret;\n\n\tsrc = &__this_cpu_read(xen_vcpu)->time;\n\tret = pvclock_clocksource_read_nowd(src);\n\tret -= xen_sched_clock_offset;\n\n\treturn ret;\n}\n\nstatic void xen_read_wallclock(struct timespec64 *ts)\n{\n\tstruct shared_info *s = HYPERVISOR_shared_info;\n\tstruct pvclock_wall_clock *wall_clock = &(s->wc);\n        struct pvclock_vcpu_time_info *vcpu_time;\n\n\tvcpu_time = &get_cpu_var(xen_vcpu)->time;\n\tpvclock_read_wallclock(wall_clock, vcpu_time, ts);\n\tput_cpu_var(xen_vcpu);\n}\n\nstatic void xen_get_wallclock(struct timespec64 *now)\n{\n\txen_read_wallclock(now);\n}\n\nstatic int xen_set_wallclock(const struct timespec64 *now)\n{\n\treturn -ENODEV;\n}\n\nstatic int xen_pvclock_gtod_notify(struct notifier_block *nb,\n\t\t\t\t   unsigned long was_set, void *priv)\n{\n\t \n\tstatic struct timespec64 next_sync;\n\n\tstruct xen_platform_op op;\n\tstruct timespec64 now;\n\tstruct timekeeper *tk = priv;\n\tstatic bool settime64_supported = true;\n\tint ret;\n\n\tnow.tv_sec = tk->xtime_sec;\n\tnow.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\n\t \n\tif (!was_set && timespec64_compare(&now, &next_sync) < 0)\n\t\treturn NOTIFY_OK;\n\nagain:\n\tif (settime64_supported) {\n\t\top.cmd = XENPF_settime64;\n\t\top.u.settime64.mbz = 0;\n\t\top.u.settime64.secs = now.tv_sec;\n\t\top.u.settime64.nsecs = now.tv_nsec;\n\t\top.u.settime64.system_time = xen_clocksource_read();\n\t} else {\n\t\top.cmd = XENPF_settime32;\n\t\top.u.settime32.secs = now.tv_sec;\n\t\top.u.settime32.nsecs = now.tv_nsec;\n\t\top.u.settime32.system_time = xen_clocksource_read();\n\t}\n\n\tret = HYPERVISOR_platform_op(&op);\n\n\tif (ret == -ENOSYS && settime64_supported) {\n\t\tsettime64_supported = false;\n\t\tgoto again;\n\t}\n\tif (ret < 0)\n\t\treturn NOTIFY_BAD;\n\n\t \n\tnext_sync = now;\n\tnext_sync.tv_sec += 11 * 60;\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block xen_pvclock_gtod_notifier = {\n\t.notifier_call = xen_pvclock_gtod_notify,\n};\n\nstatic int xen_cs_enable(struct clocksource *cs)\n{\n\tvclocks_set_used(VDSO_CLOCKMODE_PVCLOCK);\n\treturn 0;\n}\n\nstatic struct clocksource xen_clocksource __read_mostly = {\n\t.name\t= \"xen\",\n\t.rating\t= 400,\n\t.read\t= xen_clocksource_get_cycles,\n\t.mask\t= CLOCKSOURCE_MASK(64),\n\t.flags\t= CLOCK_SOURCE_IS_CONTINUOUS,\n\t.enable = xen_cs_enable,\n};\n\n \n\n\n \nstatic s64 get_abs_timeout(unsigned long delta)\n{\n\treturn xen_clocksource_read() + delta;\n}\n\nstatic int xen_timerop_shutdown(struct clock_event_device *evt)\n{\n\t \n\tHYPERVISOR_set_timer_op(0);\n\n\treturn 0;\n}\n\nstatic int xen_timerop_set_next_event(unsigned long delta,\n\t\t\t\t      struct clock_event_device *evt)\n{\n\tWARN_ON(!clockevent_state_oneshot(evt));\n\n\tif (HYPERVISOR_set_timer_op(get_abs_timeout(delta)) < 0)\n\t\tBUG();\n\n\t \n\n\treturn 0;\n}\n\nstatic struct clock_event_device xen_timerop_clockevent __ro_after_init = {\n\t.name\t\t\t= \"xen\",\n\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT,\n\n\t.max_delta_ns\t\t= 0xffffffff,\n\t.max_delta_ticks\t= 0xffffffff,\n\t.min_delta_ns\t\t= TIMER_SLOP,\n\t.min_delta_ticks\t= TIMER_SLOP,\n\n\t.mult\t\t\t= 1,\n\t.shift\t\t\t= 0,\n\t.rating\t\t\t= 500,\n\n\t.set_state_shutdown\t= xen_timerop_shutdown,\n\t.set_next_event\t\t= xen_timerop_set_next_event,\n};\n\nstatic int xen_vcpuop_shutdown(struct clock_event_device *evt)\n{\n\tint cpu = smp_processor_id();\n\n\tif (HYPERVISOR_vcpu_op(VCPUOP_stop_singleshot_timer, xen_vcpu_nr(cpu),\n\t\t\t       NULL) ||\n\t    HYPERVISOR_vcpu_op(VCPUOP_stop_periodic_timer, xen_vcpu_nr(cpu),\n\t\t\t       NULL))\n\t\tBUG();\n\n\treturn 0;\n}\n\nstatic int xen_vcpuop_set_oneshot(struct clock_event_device *evt)\n{\n\tint cpu = smp_processor_id();\n\n\tif (HYPERVISOR_vcpu_op(VCPUOP_stop_periodic_timer, xen_vcpu_nr(cpu),\n\t\t\t       NULL))\n\t\tBUG();\n\n\treturn 0;\n}\n\nstatic int xen_vcpuop_set_next_event(unsigned long delta,\n\t\t\t\t     struct clock_event_device *evt)\n{\n\tint cpu = smp_processor_id();\n\tstruct vcpu_set_singleshot_timer single;\n\tint ret;\n\n\tWARN_ON(!clockevent_state_oneshot(evt));\n\n\tsingle.timeout_abs_ns = get_abs_timeout(delta);\n\t \n\tsingle.flags = 0;\n\n\tret = HYPERVISOR_vcpu_op(VCPUOP_set_singleshot_timer, xen_vcpu_nr(cpu),\n\t\t\t\t &single);\n\tBUG_ON(ret != 0);\n\n\treturn ret;\n}\n\nstatic struct clock_event_device xen_vcpuop_clockevent __ro_after_init = {\n\t.name = \"xen\",\n\t.features = CLOCK_EVT_FEAT_ONESHOT,\n\n\t.max_delta_ns = 0xffffffff,\n\t.max_delta_ticks = 0xffffffff,\n\t.min_delta_ns = TIMER_SLOP,\n\t.min_delta_ticks = TIMER_SLOP,\n\n\t.mult = 1,\n\t.shift = 0,\n\t.rating = 500,\n\n\t.set_state_shutdown = xen_vcpuop_shutdown,\n\t.set_state_oneshot = xen_vcpuop_set_oneshot,\n\t.set_next_event = xen_vcpuop_set_next_event,\n};\n\nstatic const struct clock_event_device *xen_clockevent =\n\t&xen_timerop_clockevent;\n\nstruct xen_clock_event_device {\n\tstruct clock_event_device evt;\n\tchar name[16];\n};\nstatic DEFINE_PER_CPU(struct xen_clock_event_device, xen_clock_events) = { .evt.irq = -1 };\n\nstatic irqreturn_t xen_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = this_cpu_ptr(&xen_clock_events.evt);\n\tirqreturn_t ret;\n\n\tret = IRQ_NONE;\n\tif (evt->event_handler) {\n\t\tevt->event_handler(evt);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nvoid xen_teardown_timer(int cpu)\n{\n\tstruct clock_event_device *evt;\n\tevt = &per_cpu(xen_clock_events, cpu).evt;\n\n\tif (evt->irq >= 0) {\n\t\tunbind_from_irqhandler(evt->irq, NULL);\n\t\tevt->irq = -1;\n\t}\n}\n\nvoid xen_setup_timer(int cpu)\n{\n\tstruct xen_clock_event_device *xevt = &per_cpu(xen_clock_events, cpu);\n\tstruct clock_event_device *evt = &xevt->evt;\n\tint irq;\n\n\tWARN(evt->irq >= 0, \"IRQ%d for CPU%d is already allocated\\n\", evt->irq, cpu);\n\tif (evt->irq >= 0)\n\t\txen_teardown_timer(cpu);\n\n\tprintk(KERN_INFO \"installing Xen timer for CPU %d\\n\", cpu);\n\n\tsnprintf(xevt->name, sizeof(xevt->name), \"timer%d\", cpu);\n\n\tirq = bind_virq_to_irqhandler(VIRQ_TIMER, cpu, xen_timer_interrupt,\n\t\t\t\t      IRQF_PERCPU|IRQF_NOBALANCING|IRQF_TIMER|\n\t\t\t\t      IRQF_FORCE_RESUME|IRQF_EARLY_RESUME,\n\t\t\t\t      xevt->name, NULL);\n\t(void)xen_set_irq_priority(irq, XEN_IRQ_PRIORITY_MAX);\n\n\tmemcpy(evt, xen_clockevent, sizeof(*evt));\n\n\tevt->cpumask = cpumask_of(cpu);\n\tevt->irq = irq;\n}\n\n\nvoid xen_setup_cpu_clockevents(void)\n{\n\tclockevents_register_device(this_cpu_ptr(&xen_clock_events.evt));\n}\n\nvoid xen_timer_resume(void)\n{\n\tint cpu;\n\n\tif (xen_clockevent != &xen_vcpuop_clockevent)\n\t\treturn;\n\n\tfor_each_online_cpu(cpu) {\n\t\tif (HYPERVISOR_vcpu_op(VCPUOP_stop_periodic_timer,\n\t\t\t\t       xen_vcpu_nr(cpu), NULL))\n\t\t\tBUG();\n\t}\n}\n\nstatic struct pvclock_vsyscall_time_info *xen_clock __read_mostly;\nstatic u64 xen_clock_value_saved;\n\nvoid xen_save_time_memory_area(void)\n{\n\tstruct vcpu_register_time_memory_area t;\n\tint ret;\n\n\txen_clock_value_saved = xen_clocksource_read() - xen_sched_clock_offset;\n\n\tif (!xen_clock)\n\t\treturn;\n\n\tt.addr.v = NULL;\n\n\tret = HYPERVISOR_vcpu_op(VCPUOP_register_vcpu_time_memory_area, 0, &t);\n\tif (ret != 0)\n\t\tpr_notice(\"Cannot save secondary vcpu_time_info (err %d)\",\n\t\t\t  ret);\n\telse\n\t\tclear_page(xen_clock);\n}\n\nvoid xen_restore_time_memory_area(void)\n{\n\tstruct vcpu_register_time_memory_area t;\n\tint ret;\n\n\tif (!xen_clock)\n\t\tgoto out;\n\n\tt.addr.v = &xen_clock->pvti;\n\n\tret = HYPERVISOR_vcpu_op(VCPUOP_register_vcpu_time_memory_area, 0, &t);\n\n\t \n\tif (ret != 0)\n\t\tpr_notice(\"Cannot restore secondary vcpu_time_info (err %d)\",\n\t\t\t  ret);\n\nout:\n\t \n\tpvclock_resume();\n\txen_sched_clock_offset = xen_clocksource_read() - xen_clock_value_saved;\n}\n\nstatic void xen_setup_vsyscall_time_info(void)\n{\n\tstruct vcpu_register_time_memory_area t;\n\tstruct pvclock_vsyscall_time_info *ti;\n\tint ret;\n\n\tti = (struct pvclock_vsyscall_time_info *)get_zeroed_page(GFP_KERNEL);\n\tif (!ti)\n\t\treturn;\n\n\tt.addr.v = &ti->pvti;\n\n\tret = HYPERVISOR_vcpu_op(VCPUOP_register_vcpu_time_memory_area, 0, &t);\n\tif (ret) {\n\t\tpr_notice(\"xen: VDSO_CLOCKMODE_PVCLOCK not supported (err %d)\\n\", ret);\n\t\tfree_page((unsigned long)ti);\n\t\treturn;\n\t}\n\n\t \n\tif (!(ti->pvti.flags & PVCLOCK_TSC_STABLE_BIT)) {\n\t\tt.addr.v = NULL;\n\t\tret = HYPERVISOR_vcpu_op(VCPUOP_register_vcpu_time_memory_area,\n\t\t\t\t\t 0, &t);\n\t\tif (!ret)\n\t\t\tfree_page((unsigned long)ti);\n\n\t\tpr_notice(\"xen: VDSO_CLOCKMODE_PVCLOCK not supported (tsc unstable)\\n\");\n\t\treturn;\n\t}\n\n\txen_clock = ti;\n\tpvclock_set_pvti_cpu0_va(xen_clock);\n\n\txen_clocksource.vdso_clock_mode = VDSO_CLOCKMODE_PVCLOCK;\n}\n\n \nstatic int __init xen_tsc_safe_clocksource(void)\n{\n\tu32 eax, ebx, ecx, edx;\n\n\tif (!(boot_cpu_has(X86_FEATURE_CONSTANT_TSC)))\n\t\treturn 0;\n\n\tif (!(boot_cpu_has(X86_FEATURE_NONSTOP_TSC)))\n\t\treturn 0;\n\n\tif (check_tsc_unstable())\n\t\treturn 0;\n\n\t \n\tcpuid_count(xen_cpuid_base() + 3, 0, &eax, &ebx, &ecx, &edx);\n\n\treturn ebx == XEN_CPUID_TSC_MODE_NEVER_EMULATE;\n}\n\nstatic void __init xen_time_init(void)\n{\n\tstruct pvclock_vcpu_time_info *pvti;\n\tint cpu = smp_processor_id();\n\tstruct timespec64 tp;\n\n\t \n\tif (xen_initial_domain())\n\t\txen_clocksource.rating = 275;\n\telse if (xen_tsc_safe_clocksource())\n\t\txen_clocksource.rating = 299;\n\n\tclocksource_register_hz(&xen_clocksource, NSEC_PER_SEC);\n\n\tif (HYPERVISOR_vcpu_op(VCPUOP_stop_periodic_timer, xen_vcpu_nr(cpu),\n\t\t\t       NULL) == 0) {\n\t\t \n\t\tprintk(KERN_DEBUG \"Xen: using vcpuop timer interface\\n\");\n\t\txen_clockevent = &xen_vcpuop_clockevent;\n\t}\n\n\t \n\txen_read_wallclock(&tp);\n\tdo_settimeofday64(&tp);\n\n\tsetup_force_cpu_cap(X86_FEATURE_TSC);\n\n\t \n\tpvti = &__this_cpu_read(xen_vcpu)->time;\n\tif (pvti->flags & PVCLOCK_TSC_STABLE_BIT) {\n\t\tpvclock_set_flags(PVCLOCK_TSC_STABLE_BIT);\n\t\txen_setup_vsyscall_time_info();\n\t}\n\n\txen_setup_runstate_info(cpu);\n\txen_setup_timer(cpu);\n\txen_setup_cpu_clockevents();\n\n\txen_time_setup_guest();\n\n\tif (xen_initial_domain())\n\t\tpvclock_gtod_register_notifier(&xen_pvclock_gtod_notifier);\n}\n\nstatic void __init xen_init_time_common(void)\n{\n\txen_sched_clock_offset = xen_clocksource_read();\n\tstatic_call_update(pv_steal_clock, xen_steal_clock);\n\tparavirt_set_sched_clock(xen_sched_clock);\n\n\tx86_platform.calibrate_tsc = xen_tsc_khz;\n\tx86_platform.get_wallclock = xen_get_wallclock;\n}\n\nvoid __init xen_init_time_ops(void)\n{\n\txen_init_time_common();\n\n\tx86_init.timers.timer_init = xen_time_init;\n\tx86_init.timers.setup_percpu_clockev = x86_init_noop;\n\tx86_cpuinit.setup_percpu_clockev = x86_init_noop;\n\n\t \n\tif (!xen_initial_domain())\n\t\tx86_platform.set_wallclock = xen_set_wallclock;\n}\n\n#ifdef CONFIG_XEN_PVHVM\nstatic void xen_hvm_setup_cpu_clockevents(void)\n{\n\tint cpu = smp_processor_id();\n\txen_setup_runstate_info(cpu);\n\t \n\txen_setup_cpu_clockevents();\n}\n\nvoid __init xen_hvm_init_time_ops(void)\n{\n\tstatic bool hvm_time_initialized;\n\n\tif (hvm_time_initialized)\n\t\treturn;\n\n\t \n\tif (!xen_have_vector_callback)\n\t\treturn;\n\n\tif (!xen_feature(XENFEAT_hvm_safe_pvclock)) {\n\t\tpr_info_once(\"Xen doesn't support pvclock on HVM, disable pv timer\");\n\t\treturn;\n\t}\n\n\t \n\tif (!__this_cpu_read(xen_vcpu)) {\n\t\tpr_info(\"Delay xen_init_time_common() as kernel is running on vcpu=%d\\n\",\n\t\t\txen_vcpu_nr(0));\n\t\treturn;\n\t}\n\n\txen_init_time_common();\n\n\tx86_init.timers.setup_percpu_clockev = xen_time_init;\n\tx86_cpuinit.setup_percpu_clockev = xen_hvm_setup_cpu_clockevents;\n\n\tx86_platform.set_wallclock = xen_set_wallclock;\n\n\thvm_time_initialized = true;\n}\n#endif\n\n \nstatic int __init parse_xen_timer_slop(char *ptr)\n{\n\tunsigned long slop = memparse(ptr, NULL);\n\n\txen_timerop_clockevent.min_delta_ns = slop;\n\txen_timerop_clockevent.min_delta_ticks = slop;\n\txen_vcpuop_clockevent.min_delta_ns = slop;\n\txen_vcpuop_clockevent.min_delta_ticks = slop;\n\n\treturn 0;\n}\nearly_param(\"xen_timer_slop\", parse_xen_timer_slop);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}