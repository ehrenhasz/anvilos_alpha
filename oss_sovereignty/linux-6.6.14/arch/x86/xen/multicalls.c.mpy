{
  "module_name": "multicalls.c",
  "hash_id": "964176208d94d9fe6c9bf458b240ff59ab83d009feb91dc7dcfc86cef19555bb",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/xen/multicalls.c",
  "human_readable_source": "\n \n#include <linux/percpu.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n\n#include <asm/xen/hypercall.h>\n\n#include \"multicalls.h\"\n#include \"debugfs.h\"\n\n#define MC_BATCH\t32\n\n#define MC_DEBUG\t0\n\n#define MC_ARGS\t\t(MC_BATCH * 16)\n\n\nstruct mc_buffer {\n\tunsigned mcidx, argidx, cbidx;\n\tstruct multicall_entry entries[MC_BATCH];\n#if MC_DEBUG\n\tstruct multicall_entry debug[MC_BATCH];\n\tvoid *caller[MC_BATCH];\n#endif\n\tunsigned char args[MC_ARGS];\n\tstruct callback {\n\t\tvoid (*fn)(void *);\n\t\tvoid *data;\n\t} callbacks[MC_BATCH];\n};\n\nstatic DEFINE_PER_CPU(struct mc_buffer, mc_buffer);\nDEFINE_PER_CPU(unsigned long, xen_mc_irq_flags);\n\nvoid xen_mc_flush(void)\n{\n\tstruct mc_buffer *b = this_cpu_ptr(&mc_buffer);\n\tstruct multicall_entry *mc;\n\tint ret = 0;\n\tunsigned long flags;\n\tint i;\n\n\tBUG_ON(preemptible());\n\n\t \n\tlocal_irq_save(flags);\n\n\ttrace_xen_mc_flush(b->mcidx, b->argidx, b->cbidx);\n\n#if MC_DEBUG\n\tmemcpy(b->debug, b->entries,\n\t       b->mcidx * sizeof(struct multicall_entry));\n#endif\n\n\tswitch (b->mcidx) {\n\tcase 0:\n\t\t \n\t\tBUG_ON(b->argidx != 0);\n\t\tbreak;\n\n\tcase 1:\n\t\t \n\t\tmc = &b->entries[0];\n\n\t\tmc->result = xen_single_call(mc->op, mc->args[0], mc->args[1],\n\t\t\t\t\t     mc->args[2], mc->args[3],\n\t\t\t\t\t     mc->args[4]);\n\t\tret = mc->result < 0;\n\t\tbreak;\n\n\tdefault:\n\t\tif (HYPERVISOR_multicall(b->entries, b->mcidx) != 0)\n\t\t\tBUG();\n\t\tfor (i = 0; i < b->mcidx; i++)\n\t\t\tif (b->entries[i].result < 0)\n\t\t\t\tret++;\n\t}\n\n\tif (WARN_ON(ret)) {\n\t\tpr_err(\"%d of %d multicall(s) failed: cpu %d\\n\",\n\t\t       ret, b->mcidx, smp_processor_id());\n\t\tfor (i = 0; i < b->mcidx; i++) {\n\t\t\tif (b->entries[i].result < 0) {\n#if MC_DEBUG\n\t\t\t\tpr_err(\"  call %2d: op=%lu arg=[%lx] result=%ld\\t%pS\\n\",\n\t\t\t\t       i + 1,\n\t\t\t\t       b->debug[i].op,\n\t\t\t\t       b->debug[i].args[0],\n\t\t\t\t       b->entries[i].result,\n\t\t\t\t       b->caller[i]);\n#else\n\t\t\t\tpr_err(\"  call %2d: op=%lu arg=[%lx] result=%ld\\n\",\n\t\t\t\t       i + 1,\n\t\t\t\t       b->entries[i].op,\n\t\t\t\t       b->entries[i].args[0],\n\t\t\t\t       b->entries[i].result);\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\tb->mcidx = 0;\n\tb->argidx = 0;\n\n\tfor (i = 0; i < b->cbidx; i++) {\n\t\tstruct callback *cb = &b->callbacks[i];\n\n\t\t(*cb->fn)(cb->data);\n\t}\n\tb->cbidx = 0;\n\n\tlocal_irq_restore(flags);\n}\n\nstruct multicall_space __xen_mc_entry(size_t args)\n{\n\tstruct mc_buffer *b = this_cpu_ptr(&mc_buffer);\n\tstruct multicall_space ret;\n\tunsigned argidx = roundup(b->argidx, sizeof(u64));\n\n\ttrace_xen_mc_entry_alloc(args);\n\n\tBUG_ON(preemptible());\n\tBUG_ON(b->argidx >= MC_ARGS);\n\n\tif (unlikely(b->mcidx == MC_BATCH ||\n\t\t     (argidx + args) >= MC_ARGS)) {\n\t\ttrace_xen_mc_flush_reason((b->mcidx == MC_BATCH) ?\n\t\t\t\t\t  XEN_MC_FL_BATCH : XEN_MC_FL_ARGS);\n\t\txen_mc_flush();\n\t\targidx = roundup(b->argidx, sizeof(u64));\n\t}\n\n\tret.mc = &b->entries[b->mcidx];\n#if MC_DEBUG\n\tb->caller[b->mcidx] = __builtin_return_address(0);\n#endif\n\tb->mcidx++;\n\tret.args = &b->args[argidx];\n\tb->argidx = argidx + args;\n\n\tBUG_ON(b->argidx >= MC_ARGS);\n\treturn ret;\n}\n\nstruct multicall_space xen_mc_extend_args(unsigned long op, size_t size)\n{\n\tstruct mc_buffer *b = this_cpu_ptr(&mc_buffer);\n\tstruct multicall_space ret = { NULL, NULL };\n\n\tBUG_ON(preemptible());\n\tBUG_ON(b->argidx >= MC_ARGS);\n\n\tif (unlikely(b->mcidx == 0 ||\n\t\t     b->entries[b->mcidx - 1].op != op)) {\n\t\ttrace_xen_mc_extend_args(op, size, XEN_MC_XE_BAD_OP);\n\t\tgoto out;\n\t}\n\n\tif (unlikely((b->argidx + size) >= MC_ARGS)) {\n\t\ttrace_xen_mc_extend_args(op, size, XEN_MC_XE_NO_SPACE);\n\t\tgoto out;\n\t}\n\n\tret.mc = &b->entries[b->mcidx - 1];\n\tret.args = &b->args[b->argidx];\n\tb->argidx += size;\n\n\tBUG_ON(b->argidx >= MC_ARGS);\n\n\ttrace_xen_mc_extend_args(op, size, XEN_MC_XE_OK);\nout:\n\treturn ret;\n}\n\nvoid xen_mc_callback(void (*fn)(void *), void *data)\n{\n\tstruct mc_buffer *b = this_cpu_ptr(&mc_buffer);\n\tstruct callback *cb;\n\n\tif (b->cbidx == MC_BATCH) {\n\t\ttrace_xen_mc_flush_reason(XEN_MC_FL_CALLBACK);\n\t\txen_mc_flush();\n\t}\n\n\ttrace_xen_mc_callback(fn, data);\n\n\tcb = &b->callbacks[b->cbidx++];\n\tcb->fn = fn;\n\tcb->data = data;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}