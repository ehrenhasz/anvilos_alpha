{
  "module_name": "apic.c",
  "hash_id": "e6947d298af1443e0ff5d819107c661cb1f880afb4c5a2474b5a1b4b3007fb19",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/xen/apic.c",
  "human_readable_source": "\n#include <linux/init.h>\n#include <linux/thread_info.h>\n\n#include <asm/x86_init.h>\n#include <asm/apic.h>\n#include <asm/io_apic.h>\n#include <asm/xen/hypercall.h>\n\n#include <xen/xen.h>\n#include <xen/interface/physdev.h>\n#include \"xen-ops.h\"\n#include \"pmu.h\"\n#include \"smp.h\"\n\nstatic unsigned int xen_io_apic_read(unsigned apic, unsigned reg)\n{\n\tstruct physdev_apic apic_op;\n\tint ret;\n\n\tapic_op.apic_physbase = mpc_ioapic_addr(apic);\n\tapic_op.reg = reg;\n\tret = HYPERVISOR_physdev_op(PHYSDEVOP_apic_read, &apic_op);\n\tif (!ret)\n\t\treturn apic_op.value;\n\n\t \n\tif (reg == 0x1)\n\t\treturn 0x00170020;\n\telse if (reg == 0x0)\n\t\treturn apic << 24;\n\n\treturn 0xfd;\n}\n\nstatic u32 xen_set_apic_id(unsigned int x)\n{\n\tWARN_ON(1);\n\treturn x;\n}\n\nstatic unsigned int xen_get_apic_id(unsigned long x)\n{\n\treturn ((x)>>24) & 0xFFu;\n}\n\nstatic u32 xen_apic_read(u32 reg)\n{\n\tstruct xen_platform_op op = {\n\t\t.cmd = XENPF_get_cpuinfo,\n\t\t.interface_version = XENPF_INTERFACE_VERSION,\n\t\t.u.pcpu_info.xen_cpuid = 0,\n\t};\n\tint ret;\n\n\t \n\tif (!xen_initial_domain() || smp_processor_id())\n\t\treturn 0;\n\n\tif (reg == APIC_LVR)\n\t\treturn 0x14;\n\tif (reg != APIC_ID)\n\t\treturn 0;\n\n\tret = HYPERVISOR_platform_op(&op);\n\tif (ret)\n\t\top.u.pcpu_info.apic_id = BAD_APICID;\n\n\treturn op.u.pcpu_info.apic_id << 24;\n}\n\nstatic void xen_apic_write(u32 reg, u32 val)\n{\n\tif (reg == APIC_LVTPC) {\n\t\t(void)pmu_apic_update(reg);\n\t\treturn;\n\t}\n\n\t \n\tWARN(1,\"register: %x, value: %x\\n\", reg, val);\n}\n\nstatic void xen_apic_eoi(void)\n{\n\tWARN_ON_ONCE(1);\n}\n\nstatic u64 xen_apic_icr_read(void)\n{\n\treturn 0;\n}\n\nstatic void xen_apic_icr_write(u32 low, u32 id)\n{\n\t \n\tWARN_ON(1);\n}\n\nstatic int xen_apic_probe_pv(void)\n{\n\tif (xen_pv_domain())\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int xen_madt_oem_check(char *oem_id, char *oem_table_id)\n{\n\treturn xen_pv_domain();\n}\n\nstatic int xen_phys_pkg_id(int initial_apic_id, int index_msb)\n{\n\treturn initial_apic_id >> index_msb;\n}\n\nstatic int xen_cpu_present_to_apicid(int cpu)\n{\n\tif (cpu_present(cpu))\n\t\treturn cpu_data(cpu).apicid;\n\telse\n\t\treturn BAD_APICID;\n}\n\nstatic struct apic xen_pv_apic __ro_after_init = {\n\t.name\t\t\t\t= \"Xen PV\",\n\t.probe\t\t\t\t= xen_apic_probe_pv,\n\t.acpi_madt_oem_check\t\t= xen_madt_oem_check,\n\n\t \n\n\t.disable_esr\t\t\t= 0,\n\n\t.cpu_present_to_apicid\t\t= xen_cpu_present_to_apicid,\n\t.phys_pkg_id\t\t\t= xen_phys_pkg_id,  \n\n\t.max_apic_id\t\t\t= UINT_MAX,\n\t.get_apic_id\t\t\t= xen_get_apic_id,\n\t.set_apic_id\t\t\t= xen_set_apic_id,\n\n\t.calc_dest_apicid\t\t= apic_flat_calc_apicid,\n\n#ifdef CONFIG_SMP\n\t.send_IPI_mask\t\t\t= xen_send_IPI_mask,\n\t.send_IPI_mask_allbutself\t= xen_send_IPI_mask_allbutself,\n\t.send_IPI_allbutself\t\t= xen_send_IPI_allbutself,\n\t.send_IPI_all\t\t\t= xen_send_IPI_all,\n\t.send_IPI_self\t\t\t= xen_send_IPI_self,\n#endif\n\t.read\t\t\t\t= xen_apic_read,\n\t.write\t\t\t\t= xen_apic_write,\n\t.eoi\t\t\t\t= xen_apic_eoi,\n\n\t.icr_read\t\t\t= xen_apic_icr_read,\n\t.icr_write\t\t\t= xen_apic_icr_write,\n};\napic_driver(xen_pv_apic);\n\nvoid __init xen_init_apic(void)\n{\n\tx86_apic_ops.io_apic_read = xen_io_apic_read;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}