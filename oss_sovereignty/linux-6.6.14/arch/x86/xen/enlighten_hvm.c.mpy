{
  "module_name": "enlighten_hvm.c",
  "hash_id": "1765b69c124adb6563e96c9d45aa4339bbf4d864afc3a2595265251ba4031e44",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/xen/enlighten_hvm.c",
  "human_readable_source": "\n\n#include <linux/acpi.h>\n#include <linux/cpu.h>\n#include <linux/kexec.h>\n#include <linux/memblock.h>\n#include <linux/virtio_anchor.h>\n\n#include <xen/features.h>\n#include <xen/events.h>\n#include <xen/hvm.h>\n#include <xen/interface/hvm/hvm_op.h>\n#include <xen/interface/memory.h>\n\n#include <asm/apic.h>\n#include <asm/cpu.h>\n#include <asm/smp.h>\n#include <asm/io_apic.h>\n#include <asm/reboot.h>\n#include <asm/setup.h>\n#include <asm/idtentry.h>\n#include <asm/hypervisor.h>\n#include <asm/e820/api.h>\n#include <asm/early_ioremap.h>\n\n#include <asm/xen/cpuid.h>\n#include <asm/xen/hypervisor.h>\n#include <asm/xen/page.h>\n\n#include \"xen-ops.h\"\n#include \"mmu.h\"\n#include \"smp.h\"\n\nstatic unsigned long shared_info_pfn;\n\n__ro_after_init bool xen_percpu_upcall;\nEXPORT_SYMBOL_GPL(xen_percpu_upcall);\n\nvoid xen_hvm_init_shared_info(void)\n{\n\tstruct xen_add_to_physmap xatp;\n\n\txatp.domid = DOMID_SELF;\n\txatp.idx = 0;\n\txatp.space = XENMAPSPACE_shared_info;\n\txatp.gpfn = shared_info_pfn;\n\tif (HYPERVISOR_memory_op(XENMEM_add_to_physmap, &xatp))\n\t\tBUG();\n}\n\nstatic void __init reserve_shared_info(void)\n{\n\tu64 pa;\n\n\t \n\tfor (pa = PAGE_SIZE;\n\t     !e820__mapped_all(pa, pa + PAGE_SIZE, E820_TYPE_RAM) ||\n\t     memblock_is_reserved(pa);\n\t     pa += PAGE_SIZE)\n\t\t;\n\n\tshared_info_pfn = PHYS_PFN(pa);\n\n\tmemblock_reserve(pa, PAGE_SIZE);\n\tHYPERVISOR_shared_info = early_memremap(pa, PAGE_SIZE);\n}\n\nstatic void __init xen_hvm_init_mem_mapping(void)\n{\n\tearly_memunmap(HYPERVISOR_shared_info, PAGE_SIZE);\n\tHYPERVISOR_shared_info = __va(PFN_PHYS(shared_info_pfn));\n\n\t \n\txen_vcpu_info_reset(0);\n}\n\nstatic void __init init_hvm_pv_info(void)\n{\n\tint major, minor;\n\tuint32_t eax, ebx, ecx, edx, base;\n\n\tbase = xen_cpuid_base();\n\teax = cpuid_eax(base + 1);\n\n\tmajor = eax >> 16;\n\tminor = eax & 0xffff;\n\tprintk(KERN_INFO \"Xen version %d.%d.\\n\", major, minor);\n\n\txen_domain_type = XEN_HVM_DOMAIN;\n\n\t \n\tif (xen_pvh_domain())\n\t\tpv_info.name = \"Xen PVH\";\n\telse {\n\t\tu64 pfn;\n\t\tuint32_t msr;\n\n\t\tpv_info.name = \"Xen HVM\";\n\t\tmsr = cpuid_ebx(base + 2);\n\t\tpfn = __pa(hypercall_page);\n\t\twrmsr_safe(msr, (u32)pfn, (u32)(pfn >> 32));\n\t}\n\n\txen_setup_features();\n\n\tcpuid(base + 4, &eax, &ebx, &ecx, &edx);\n\tif (eax & XEN_HVM_CPUID_VCPU_ID_PRESENT)\n\t\tthis_cpu_write(xen_vcpu_id, ebx);\n\telse\n\t\tthis_cpu_write(xen_vcpu_id, smp_processor_id());\n}\n\nDEFINE_IDTENTRY_SYSVEC(sysvec_xen_hvm_callback)\n{\n\tstruct pt_regs *old_regs = set_irq_regs(regs);\n\n\tif (xen_percpu_upcall)\n\t\tapic_eoi();\n\n\tinc_irq_stat(irq_hv_callback_count);\n\n\txen_evtchn_do_upcall();\n\n\tset_irq_regs(old_regs);\n}\n\n#ifdef CONFIG_KEXEC_CORE\nstatic void xen_hvm_shutdown(void)\n{\n\tnative_machine_shutdown();\n\tif (kexec_in_progress)\n\t\txen_reboot(SHUTDOWN_soft_reset);\n}\n\nstatic void xen_hvm_crash_shutdown(struct pt_regs *regs)\n{\n\tnative_machine_crash_shutdown(regs);\n\txen_reboot(SHUTDOWN_soft_reset);\n}\n#endif\n\nstatic int xen_cpu_up_prepare_hvm(unsigned int cpu)\n{\n\tint rc = 0;\n\n\t \n\txen_uninit_lock_cpu(cpu);\n\n\tif (cpu_acpi_id(cpu) != U32_MAX)\n\t\tper_cpu(xen_vcpu_id, cpu) = cpu_acpi_id(cpu);\n\telse\n\t\tper_cpu(xen_vcpu_id, cpu) = cpu;\n\txen_vcpu_setup(cpu);\n\tif (!xen_have_vector_callback)\n\t\treturn 0;\n\n\tif (xen_percpu_upcall) {\n\t\trc = xen_set_upcall_vector(cpu);\n\t\tif (rc) {\n\t\t\tWARN(1, \"HVMOP_set_evtchn_upcall_vector\"\n\t\t\t     \" for CPU %d failed: %d\\n\", cpu, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (xen_feature(XENFEAT_hvm_safe_pvclock))\n\t\txen_setup_timer(cpu);\n\n\trc = xen_smp_intr_init(cpu);\n\tif (rc) {\n\t\tWARN(1, \"xen_smp_intr_init() for CPU %d failed: %d\\n\",\n\t\t     cpu, rc);\n\t}\n\treturn rc;\n}\n\nstatic int xen_cpu_dead_hvm(unsigned int cpu)\n{\n\txen_smp_intr_free(cpu);\n\n\tif (xen_have_vector_callback && xen_feature(XENFEAT_hvm_safe_pvclock))\n\t\txen_teardown_timer(cpu);\n\treturn 0;\n}\n\nstatic void __init xen_hvm_guest_init(void)\n{\n\tif (xen_pv_domain())\n\t\treturn;\n\n\tif (IS_ENABLED(CONFIG_XEN_VIRTIO_FORCE_GRANT))\n\t\tvirtio_set_mem_acc_cb(xen_virtio_restricted_mem_acc);\n\n\tinit_hvm_pv_info();\n\n\treserve_shared_info();\n\txen_hvm_init_shared_info();\n\n\t \n\txen_vcpu_info_reset(0);\n\n\txen_panic_handler_init();\n\n\txen_hvm_smp_init();\n\tWARN_ON(xen_cpuhp_setup(xen_cpu_up_prepare_hvm, xen_cpu_dead_hvm));\n\txen_unplug_emulated_devices();\n\tx86_init.irqs.intr_init = xen_init_IRQ;\n\txen_hvm_init_time_ops();\n\txen_hvm_init_mmu_ops();\n\n#ifdef CONFIG_KEXEC_CORE\n\tmachine_ops.shutdown = xen_hvm_shutdown;\n\tmachine_ops.crash_shutdown = xen_hvm_crash_shutdown;\n#endif\n}\n\nstatic __init int xen_parse_nopv(char *arg)\n{\n\tpr_notice(\"\\\"xen_nopv\\\" is deprecated, please use \\\"nopv\\\" instead\\n\");\n\n\tif (xen_cpuid_base())\n\t\tnopv = true;\n\treturn 0;\n}\nearly_param(\"xen_nopv\", xen_parse_nopv);\n\nstatic __init int xen_parse_no_vector_callback(char *arg)\n{\n\txen_have_vector_callback = false;\n\treturn 0;\n}\nearly_param(\"xen_no_vector_callback\", xen_parse_no_vector_callback);\n\nstatic __init bool xen_x2apic_available(void)\n{\n\treturn x2apic_supported();\n}\n\nstatic bool __init msi_ext_dest_id(void)\n{\n       return cpuid_eax(xen_cpuid_base() + 4) & XEN_HVM_CPUID_EXT_DEST_ID;\n}\n\nstatic __init void xen_hvm_guest_late_init(void)\n{\n#ifdef CONFIG_XEN_PVH\n\t \n\tif (!xen_pvh &&\n\t    (x86_platform.legacy.rtc || !x86_platform.legacy.no_vga))\n\t\treturn;\n\n\t \n\txen_pvh = true;\n\n\tif (nopv)\n\t\tpanic(\"\\\"nopv\\\" and \\\"xen_nopv\\\" parameters are unsupported in PVH guest.\");\n\n\t \n\tif (!nr_ioapics && acpi_irq_model == ACPI_IRQ_MODEL_PIC)\n\t\tacpi_irq_model = ACPI_IRQ_MODEL_PLATFORM;\n\n\tmachine_ops.emergency_restart = xen_emergency_restart;\n\tpv_info.name = \"Xen PVH\";\n#endif\n}\n\nstatic uint32_t __init xen_platform_hvm(void)\n{\n\tuint32_t xen_domain = xen_cpuid_base();\n\tstruct x86_hyper_init *h = &x86_hyper_xen_hvm.init;\n\n\tif (xen_pv_domain())\n\t\treturn 0;\n\n\tif (xen_pvh_domain() && nopv) {\n\t\t \n\t\tpr_info(\"\\\"nopv\\\" parameter is ignored in PVH guest\\n\");\n\t\tnopv = false;\n\t} else if (nopv && xen_domain) {\n\t\t \n\t\th->init_platform = x86_init_noop;\n\t\th->x2apic_available = bool_x86_init_noop;\n\t\th->init_mem_mapping = x86_init_noop;\n\t\th->init_after_bootmem = x86_init_noop;\n\t\th->guest_late_init = xen_hvm_guest_late_init;\n\t\tx86_hyper_xen_hvm.runtime.pin_vcpu = x86_op_int_noop;\n\t}\n\treturn xen_domain;\n}\n\nstruct hypervisor_x86 x86_hyper_xen_hvm __initdata = {\n\t.name                   = \"Xen HVM\",\n\t.detect                 = xen_platform_hvm,\n\t.type\t\t\t= X86_HYPER_XEN_HVM,\n\t.init.init_platform     = xen_hvm_guest_init,\n\t.init.x2apic_available  = xen_x2apic_available,\n\t.init.init_mem_mapping\t= xen_hvm_init_mem_mapping,\n\t.init.guest_late_init\t= xen_hvm_guest_late_init,\n\t.init.msi_ext_dest_id   = msi_ext_dest_id,\n\t.runtime.pin_vcpu       = xen_pin_vcpu,\n\t.ignore_nopv            = true,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}