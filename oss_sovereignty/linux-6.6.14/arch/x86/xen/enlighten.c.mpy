{
  "module_name": "enlighten.c",
  "hash_id": "b4204e7a6c23a1685fee01e9758a42d47daaa5f88d811b39f02c18cacc9c9b87",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/xen/enlighten.c",
  "human_readable_source": "\n\n#ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG\n#include <linux/memblock.h>\n#endif\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/panic_notifier.h>\n\n#include <xen/xen.h>\n#include <xen/features.h>\n#include <xen/interface/sched.h>\n#include <xen/interface/version.h>\n#include <xen/page.h>\n\n#include <asm/xen/hypercall.h>\n#include <asm/xen/hypervisor.h>\n#include <asm/cpu.h>\n#include <asm/e820/api.h> \n#include <asm/setup.h>\n\n#include \"xen-ops.h\"\n#include \"smp.h\"\n#include \"pmu.h\"\n\nEXPORT_SYMBOL_GPL(hypercall_page);\n\n \nDEFINE_PER_CPU(struct vcpu_info *, xen_vcpu);\nDEFINE_PER_CPU_ALIGNED(struct vcpu_info, xen_vcpu_info);\n\n \nDEFINE_PER_CPU(uint32_t, xen_vcpu_id);\nEXPORT_PER_CPU_SYMBOL(xen_vcpu_id);\n\nunsigned long *machine_to_phys_mapping = (void *)MACH2PHYS_VIRT_START;\nEXPORT_SYMBOL(machine_to_phys_mapping);\nunsigned long  machine_to_phys_nr;\nEXPORT_SYMBOL(machine_to_phys_nr);\n\nstruct start_info *xen_start_info;\nEXPORT_SYMBOL_GPL(xen_start_info);\n\nstruct shared_info xen_dummy_shared_info;\n\n__read_mostly bool xen_have_vector_callback = true;\nEXPORT_SYMBOL_GPL(xen_have_vector_callback);\n\n \nenum xen_domain_type __ro_after_init xen_domain_type = XEN_NATIVE;\nEXPORT_SYMBOL_GPL(xen_domain_type);\nuint32_t __ro_after_init xen_start_flags;\nEXPORT_SYMBOL(xen_start_flags);\n\n \nstruct shared_info *HYPERVISOR_shared_info = &xen_dummy_shared_info;\n\nstatic int xen_cpu_up_online(unsigned int cpu)\n{\n\txen_init_lock_cpu(cpu);\n\treturn 0;\n}\n\nint xen_cpuhp_setup(int (*cpu_up_prepare_cb)(unsigned int),\n\t\t    int (*cpu_dead_cb)(unsigned int))\n{\n\tint rc;\n\n\trc = cpuhp_setup_state_nocalls(CPUHP_XEN_PREPARE,\n\t\t\t\t       \"x86/xen/guest:prepare\",\n\t\t\t\t       cpu_up_prepare_cb, cpu_dead_cb);\n\tif (rc >= 0) {\n\t\trc = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t       \"x86/xen/guest:online\",\n\t\t\t\t\t       xen_cpu_up_online, NULL);\n\t\tif (rc < 0)\n\t\t\tcpuhp_remove_state_nocalls(CPUHP_XEN_PREPARE);\n\t}\n\n\treturn rc >= 0 ? 0 : rc;\n}\n\nstatic void xen_vcpu_setup_restore(int cpu)\n{\n\t \n\txen_vcpu_info_reset(cpu);\n\n\t \n\tif (xen_pv_domain() ||\n\t    (xen_hvm_domain() && cpu_online(cpu)))\n\t\txen_vcpu_setup(cpu);\n}\n\n \nvoid xen_vcpu_restore(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tbool other_cpu = (cpu != smp_processor_id());\n\t\tbool is_up;\n\n\t\tif (xen_vcpu_nr(cpu) == XEN_VCPU_ID_INVALID)\n\t\t\tcontinue;\n\n\t\t \n\t\tis_up = HYPERVISOR_vcpu_op(VCPUOP_is_up,\n\t\t\t\t\t   xen_vcpu_nr(cpu), NULL) > 0;\n\n\t\tif (other_cpu && is_up &&\n\t\t    HYPERVISOR_vcpu_op(VCPUOP_down, xen_vcpu_nr(cpu), NULL))\n\t\t\tBUG();\n\n\t\tif (xen_pv_domain() || xen_feature(XENFEAT_hvm_safe_pvclock))\n\t\t\txen_setup_runstate_info(cpu);\n\n\t\txen_vcpu_setup_restore(cpu);\n\n\t\tif (other_cpu && is_up &&\n\t\t    HYPERVISOR_vcpu_op(VCPUOP_up, xen_vcpu_nr(cpu), NULL))\n\t\t\tBUG();\n\t}\n}\n\nvoid xen_vcpu_info_reset(int cpu)\n{\n\tif (xen_vcpu_nr(cpu) < MAX_VIRT_CPUS) {\n\t\tper_cpu(xen_vcpu, cpu) =\n\t\t\t&HYPERVISOR_shared_info->vcpu_info[xen_vcpu_nr(cpu)];\n\t} else {\n\t\t \n\t\tper_cpu(xen_vcpu, cpu) = NULL;\n\t}\n}\n\nvoid xen_vcpu_setup(int cpu)\n{\n\tstruct vcpu_register_vcpu_info info;\n\tint err;\n\tstruct vcpu_info *vcpup;\n\n\tBUILD_BUG_ON(sizeof(*vcpup) > SMP_CACHE_BYTES);\n\tBUG_ON(HYPERVISOR_shared_info == &xen_dummy_shared_info);\n\n\t \n\tif (xen_hvm_domain()) {\n\t\tif (per_cpu(xen_vcpu, cpu) == &per_cpu(xen_vcpu_info, cpu))\n\t\t\treturn;\n\t}\n\n\tvcpup = &per_cpu(xen_vcpu_info, cpu);\n\tinfo.mfn = arbitrary_virt_to_mfn(vcpup);\n\tinfo.offset = offset_in_page(vcpup);\n\n\t \n\terr = HYPERVISOR_vcpu_op(VCPUOP_register_vcpu_info, xen_vcpu_nr(cpu),\n\t\t\t\t &info);\n\tif (err)\n\t\tpanic(\"register_vcpu_info failed: cpu=%d err=%d\\n\", cpu, err);\n\n\tper_cpu(xen_vcpu, cpu) = vcpup;\n}\n\nvoid __init xen_banner(void)\n{\n\tunsigned version = HYPERVISOR_xen_version(XENVER_version, NULL);\n\tstruct xen_extraversion extra;\n\n\tHYPERVISOR_xen_version(XENVER_extraversion, &extra);\n\n\tpr_info(\"Booting kernel on %s\\n\", pv_info.name);\n\tpr_info(\"Xen version: %u.%u%s%s\\n\",\n\t\tversion >> 16, version & 0xffff, extra.extraversion,\n\t\txen_feature(XENFEAT_mmu_pt_update_preserve_ad)\n\t\t? \" (preserve-AD)\" : \"\");\n}\n\n \nbool xen_running_on_version_or_later(unsigned int major, unsigned int minor)\n{\n\tunsigned int version;\n\n\tif (!xen_domain())\n\t\treturn false;\n\n\tversion = HYPERVISOR_xen_version(XENVER_version, NULL);\n\tif ((((version >> 16) == major) && ((version & 0xffff) >= minor)) ||\n\t\t((version >> 16) > major))\n\t\treturn true;\n\treturn false;\n}\n\nvoid __init xen_add_preferred_consoles(void)\n{\n\tadd_preferred_console(\"xenboot\", 0, NULL);\n\tif (!boot_params.screen_info.orig_video_isVGA)\n\t\tadd_preferred_console(\"tty\", 0, NULL);\n\tadd_preferred_console(\"hvc\", 0, NULL);\n\tif (boot_params.screen_info.orig_video_isVGA)\n\t\tadd_preferred_console(\"tty\", 0, NULL);\n}\n\nvoid xen_reboot(int reason)\n{\n\tstruct sched_shutdown r = { .reason = reason };\n\tint cpu;\n\n\tfor_each_online_cpu(cpu)\n\t\txen_pmu_finish(cpu);\n\n\tif (HYPERVISOR_sched_op(SCHEDOP_shutdown, &r))\n\t\tBUG();\n}\n\nstatic int reboot_reason = SHUTDOWN_reboot;\nstatic bool xen_legacy_crash;\nvoid xen_emergency_restart(void)\n{\n\txen_reboot(reboot_reason);\n}\n\nstatic int\nxen_panic_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tif (!kexec_crash_loaded()) {\n\t\tif (xen_legacy_crash)\n\t\t\txen_reboot(SHUTDOWN_crash);\n\n\t\treboot_reason = SHUTDOWN_crash;\n\n\t\t \n\t\tif (panic_timeout == 0)\n\t\t\tpanic_timeout = -1;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic int __init parse_xen_legacy_crash(char *arg)\n{\n\txen_legacy_crash = true;\n\treturn 0;\n}\nearly_param(\"xen_legacy_crash\", parse_xen_legacy_crash);\n\nstatic struct notifier_block xen_panic_block = {\n\t.notifier_call = xen_panic_event,\n\t.priority = INT_MIN\n};\n\nint xen_panic_handler_init(void)\n{\n\tatomic_notifier_chain_register(&panic_notifier_list, &xen_panic_block);\n\treturn 0;\n}\n\nvoid xen_pin_vcpu(int cpu)\n{\n\tstatic bool disable_pinning;\n\tstruct sched_pin_override pin_override;\n\tint ret;\n\n\tif (disable_pinning)\n\t\treturn;\n\n\tpin_override.pcpu = cpu;\n\tret = HYPERVISOR_sched_op(SCHEDOP_pin_override, &pin_override);\n\n\t \n\tif (cpu < 0)\n\t\treturn;\n\n\tswitch (ret) {\n\tcase -ENOSYS:\n\t\tpr_warn(\"Unable to pin on physical cpu %d. In case of problems consider vcpu pinning.\\n\",\n\t\t\tcpu);\n\t\tdisable_pinning = true;\n\t\tbreak;\n\tcase -EPERM:\n\t\tWARN(1, \"Trying to pin vcpu without having privilege to do so\\n\");\n\t\tdisable_pinning = true;\n\t\tbreak;\n\tcase -EINVAL:\n\tcase -EBUSY:\n\t\tpr_warn(\"Physical cpu %d not available for pinning. Check Xen cpu configuration.\\n\",\n\t\t\tcpu);\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"rc %d while trying to pin vcpu\\n\", ret);\n\t\tdisable_pinning = true;\n\t}\n}\n\n#ifdef CONFIG_HOTPLUG_CPU\nvoid xen_arch_register_cpu(int num)\n{\n\tarch_register_cpu(num);\n}\nEXPORT_SYMBOL(xen_arch_register_cpu);\n\nvoid xen_arch_unregister_cpu(int num)\n{\n\tarch_unregister_cpu(num);\n}\nEXPORT_SYMBOL(xen_arch_unregister_cpu);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}