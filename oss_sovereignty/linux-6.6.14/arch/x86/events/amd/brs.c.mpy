{
  "module_name": "brs.c",
  "hash_id": "4b54aada3ed6f8374c0b6864b016e7c18bc039b7be7653ee329313473959cd41",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/events/amd/brs.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/jump_label.h>\n#include <asm/msr.h>\n#include <asm/cpufeature.h>\n\n#include \"../perf_event.h\"\n\n#define BRS_POISON\t0xFFFFFFFFFFFFFFFEULL  \n\n \nunion amd_debug_extn_cfg {\n\t__u64 val;\n\tstruct {\n\t\t__u64\trsvd0:2,   \n\t\t\tbrsmen:1,  \n\t\t\trsvd4_3:2, \n\t\t\tvb:1,      \n\t\t\trsvd2:10,  \n\t\t\tmsroff:4,  \n\t\t\trsvd3:4,   \n\t\t\tpmc:3,     \n\t\t\trsvd4:37;  \n\t};\n};\n\nstatic inline unsigned int brs_from(int idx)\n{\n\treturn MSR_AMD_SAMP_BR_FROM + 2 * idx;\n}\n\nstatic inline unsigned int brs_to(int idx)\n{\n\treturn MSR_AMD_SAMP_BR_FROM + 2 * idx + 1;\n}\n\nstatic __always_inline void set_debug_extn_cfg(u64 val)\n{\n\t \n\t__wrmsr(MSR_AMD_DBG_EXTN_CFG, val | 3ULL << 3, val >> 32);\n}\n\nstatic __always_inline u64 get_debug_extn_cfg(void)\n{\n\treturn __rdmsr(MSR_AMD_DBG_EXTN_CFG);\n}\n\nstatic bool __init amd_brs_detect(void)\n{\n\tif (!cpu_feature_enabled(X86_FEATURE_BRS))\n\t\treturn false;\n\n\tswitch (boot_cpu_data.x86) {\n\tcase 0x19:  \n\t\tx86_pmu.lbr_nr = 16;\n\n\t\t \n\t\tx86_pmu.lbr_sel_map = NULL;\n\t\tx86_pmu.lbr_sel_mask = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic int amd_brs_setup_filter(struct perf_event *event)\n{\n\tu64 type = event->attr.branch_sample_type;\n\n\t \n\tif (!x86_pmu.lbr_nr)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((type & ~PERF_SAMPLE_BRANCH_PLM_ALL) != PERF_SAMPLE_BRANCH_ANY)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic inline int amd_is_brs_event(struct perf_event *e)\n{\n\treturn (e->hw.config & AMD64_RAW_EVENT_MASK) == AMD_FAM19H_BRS_EVENT;\n}\n\nint amd_brs_hw_config(struct perf_event *event)\n{\n\tint ret = 0;\n\n\t \n\tif (!is_sampling_event(event))\n\t\treturn -EINVAL;\n\n\t \n\tif (!amd_is_brs_event(event))\n\t\treturn -EINVAL;\n\n\t \n\tif (event->attr.freq)\n\t\treturn -EINVAL;\n\t \n\tif (event->attr.sample_period <= x86_pmu.lbr_nr)\n\t\treturn -EINVAL;\n\n\t \n\tret = amd_brs_setup_filter(event);\n\n\t \n\tif (!ret)\n\t\tevent->hw.flags |= PERF_X86_EVENT_AMD_BRS;\n\n\treturn ret;\n}\n\n \nstatic inline int amd_brs_get_tos(union amd_debug_extn_cfg *cfg)\n{\n\t \n\treturn (cfg->msroff ? cfg->msroff : x86_pmu.lbr_nr) - 1;\n}\n\n \nvoid amd_brs_reset(void)\n{\n\tif (!cpu_feature_enabled(X86_FEATURE_BRS))\n\t\treturn;\n\n\t \n\tset_debug_extn_cfg(0);\n\n\t \n\twrmsrl(brs_to(0), BRS_POISON);\n}\n\nint __init amd_brs_init(void)\n{\n\tif (!amd_brs_detect())\n\t\treturn -EOPNOTSUPP;\n\n\tpr_cont(\"%d-deep BRS, \", x86_pmu.lbr_nr);\n\n\treturn 0;\n}\n\nvoid amd_brs_enable(void)\n{\n\tstruct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);\n\tunion amd_debug_extn_cfg cfg;\n\n\t \n\tif (++cpuc->brs_active > 1)\n\t\treturn;\n\n\tcfg.val    = 0;  \n\tcfg.brsmen = 1;  \n\n\t \n\tset_debug_extn_cfg(cfg.val);\n}\n\nvoid amd_brs_enable_all(void)\n{\n\tstruct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);\n\tif (cpuc->lbr_users)\n\t\tamd_brs_enable();\n}\n\nvoid amd_brs_disable(void)\n{\n\tstruct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);\n\tunion amd_debug_extn_cfg cfg;\n\n\t \n\tif (!cpuc->brs_active)\n\t\treturn;\n\n\t \n\tif (--cpuc->brs_active)\n\t\treturn;\n\n\t \n\tcfg.val = get_debug_extn_cfg();\n\n\t \n\tif (cfg.brsmen) {\n\t\tcfg.brsmen = 0;\n\t\tset_debug_extn_cfg(cfg.val);\n\t}\n}\n\nvoid amd_brs_disable_all(void)\n{\n\tstruct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);\n\tif (cpuc->lbr_users)\n\t\tamd_brs_disable();\n}\n\nstatic bool amd_brs_match_plm(struct perf_event *event, u64 to)\n{\n\tint type = event->attr.branch_sample_type;\n\tint plm_k = PERF_SAMPLE_BRANCH_KERNEL | PERF_SAMPLE_BRANCH_HV;\n\tint plm_u = PERF_SAMPLE_BRANCH_USER;\n\n\tif (!(type & plm_k) && kernel_ip(to))\n\t\treturn 0;\n\n\tif (!(type & plm_u) && !kernel_ip(to))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nvoid amd_brs_drain(void)\n{\n\tstruct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);\n\tstruct perf_event *event = cpuc->events[0];\n\tstruct perf_branch_entry *br = cpuc->lbr_entries;\n\tunion amd_debug_extn_cfg cfg;\n\tu32 i, nr = 0, num, tos, start;\n\tu32 shift = 64 - boot_cpu_data.x86_virt_bits;\n\n\t \n\tif (!event)\n\t\tgoto empty;\n\n\tcfg.val = get_debug_extn_cfg();\n\n\t \n\tif (WARN_ON_ONCE(cfg.msroff >= x86_pmu.lbr_nr))\n\t\tgoto empty;\n\n\t \n\tif (cfg.vb == 0)\n\t\tgoto empty;\n\n\t \n\tstart = 0;\n\ttos = amd_brs_get_tos(&cfg);\n\n\tnum = tos - start + 1;\n\n\t \n\tfor (i = 0; i < num; i++) {\n\t\tu32 brs_idx = tos - i;\n\t\tu64 from, to;\n\n\t\trdmsrl(brs_to(brs_idx), to);\n\n\t\t \n\t\tif (to == BRS_POISON)\n\t\t\tbreak;\n\n\t\t \n\t\tto = (u64)(((s64)to << shift) >> shift);\n\n\t\tif (!amd_brs_match_plm(event, to))\n\t\t\tcontinue;\n\n\t\trdmsrl(brs_from(brs_idx), from);\n\n\t\tperf_clear_branch_entry_bitfields(br+nr);\n\n\t\tbr[nr].from = from;\n\t\tbr[nr].to   = to;\n\n\t\tnr++;\n\t}\nempty:\n\t \n\tcpuc->lbr_stack.nr = nr;\n}\n\n \nstatic void amd_brs_poison_buffer(void)\n{\n\tunion amd_debug_extn_cfg cfg;\n\tunsigned int idx;\n\n\t \n\tcfg.val = get_debug_extn_cfg();\n\n\t \n\tidx = amd_brs_get_tos(&cfg);\n\n\t \n\twrmsrl(brs_to(idx), BRS_POISON);\n}\n\n \nvoid amd_pmu_brs_sched_task(struct perf_event_pmu_context *pmu_ctx, bool sched_in)\n{\n\tstruct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);\n\n\t \n\tif (!cpuc->lbr_users)\n\t\treturn;\n\n\t \n\tif (sched_in)\n\t\tamd_brs_poison_buffer();\n}\n\n \nvoid noinstr perf_amd_brs_lopwr_cb(bool lopwr_in)\n{\n\tstruct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);\n\tunion amd_debug_extn_cfg cfg;\n\n\t \n\tif (cpuc->brs_active) {\n\t\tcfg.val = get_debug_extn_cfg();\n\t\tcfg.brsmen = !lopwr_in;\n\t\tset_debug_extn_cfg(cfg.val);\n\t}\n}\n\nDEFINE_STATIC_CALL_NULL(perf_lopwr_cb, perf_amd_brs_lopwr_cb);\nEXPORT_STATIC_CALL_TRAMP_GPL(perf_lopwr_cb);\n\nvoid __init amd_brs_lopwr_init(void)\n{\n\tstatic_call_update(perf_lopwr_cb, perf_amd_brs_lopwr_cb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}