{
  "module_name": "power.c",
  "hash_id": "60b17441875152185caa24b0048a0b2816db366a9dca540610c8decb4a1a26c7",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/events/amd/power.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <asm/cpu_device_id.h>\n#include \"../perf_event.h\"\n\n \n#define AMD_POWER_EVENT_MASK\t\t0xFFULL\n\n \n#define AMD_POWER_EVENTSEL_PKG\t\t1\n\n \nstatic unsigned int cpu_pwr_sample_ratio;\n\n \nstatic u64 max_cu_acc_power;\n\nstatic struct pmu pmu_class;\n\n \nstatic cpumask_t cpu_mask;\n\nstatic void event_update(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 prev_pwr_acc, new_pwr_acc, prev_ptsc, new_ptsc;\n\tu64 delta, tdelta;\n\n\tprev_pwr_acc = hwc->pwr_acc;\n\tprev_ptsc = hwc->ptsc;\n\trdmsrl(MSR_F15H_CU_PWR_ACCUMULATOR, new_pwr_acc);\n\trdmsrl(MSR_F15H_PTSC, new_ptsc);\n\n\t \n\tif (new_pwr_acc < prev_pwr_acc) {\n\t\tdelta = max_cu_acc_power + new_pwr_acc;\n\t\tdelta -= prev_pwr_acc;\n\t} else\n\t\tdelta = new_pwr_acc - prev_pwr_acc;\n\n\tdelta *= cpu_pwr_sample_ratio * 1000;\n\ttdelta = new_ptsc - prev_ptsc;\n\n\tdo_div(delta, tdelta);\n\tlocal64_add(delta, &event->count);\n}\n\nstatic void __pmu_event_start(struct perf_event *event)\n{\n\tif (WARN_ON_ONCE(!(event->hw.state & PERF_HES_STOPPED)))\n\t\treturn;\n\n\tevent->hw.state = 0;\n\n\trdmsrl(MSR_F15H_PTSC, event->hw.ptsc);\n\trdmsrl(MSR_F15H_CU_PWR_ACCUMULATOR, event->hw.pwr_acc);\n}\n\nstatic void pmu_event_start(struct perf_event *event, int mode)\n{\n\t__pmu_event_start(event);\n}\n\nstatic void pmu_event_stop(struct perf_event *event, int mode)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\t \n\tif (!(hwc->state & PERF_HES_STOPPED))\n\t\thwc->state |= PERF_HES_STOPPED;\n\n\t \n\tif ((mode & PERF_EF_UPDATE) && !(hwc->state & PERF_HES_UPTODATE)) {\n\t\t \n\t\tevent_update(event);\n\t\thwc->state |= PERF_HES_UPTODATE;\n\t}\n}\n\nstatic int pmu_event_add(struct perf_event *event, int mode)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\thwc->state = PERF_HES_UPTODATE | PERF_HES_STOPPED;\n\n\tif (mode & PERF_EF_START)\n\t\t__pmu_event_start(event);\n\n\treturn 0;\n}\n\nstatic void pmu_event_del(struct perf_event *event, int flags)\n{\n\tpmu_event_stop(event, PERF_EF_UPDATE);\n}\n\nstatic int pmu_event_init(struct perf_event *event)\n{\n\tu64 cfg = event->attr.config & AMD_POWER_EVENT_MASK;\n\n\t \n\tif (event->attr.type != pmu_class.type)\n\t\treturn -ENOENT;\n\n\t \n\tif (event->attr.sample_period)\n\t\treturn -EINVAL;\n\n\tif (cfg != AMD_POWER_EVENTSEL_PKG)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void pmu_event_read(struct perf_event *event)\n{\n\tevent_update(event);\n}\n\nstatic ssize_t\nget_attr_cpumask(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn cpumap_print_to_pagebuf(true, buf, &cpu_mask);\n}\n\nstatic DEVICE_ATTR(cpumask, S_IRUGO, get_attr_cpumask, NULL);\n\nstatic struct attribute *pmu_attrs[] = {\n\t&dev_attr_cpumask.attr,\n\tNULL,\n};\n\nstatic struct attribute_group pmu_attr_group = {\n\t.attrs = pmu_attrs,\n};\n\n \nEVENT_ATTR_STR(power-pkg, power_pkg, \"event=0x01\");\n\nEVENT_ATTR_STR(power-pkg.unit, power_pkg_unit, \"mWatts\");\n\n \nEVENT_ATTR_STR(power-pkg.scale, power_pkg_scale, \"1.000000e-3\");\n\nstatic struct attribute *events_attr[] = {\n\tEVENT_PTR(power_pkg),\n\tEVENT_PTR(power_pkg_unit),\n\tEVENT_PTR(power_pkg_scale),\n\tNULL,\n};\n\nstatic struct attribute_group pmu_events_group = {\n\t.name\t= \"events\",\n\t.attrs\t= events_attr,\n};\n\nPMU_FORMAT_ATTR(event, \"config:0-7\");\n\nstatic struct attribute *formats_attr[] = {\n\t&format_attr_event.attr,\n\tNULL,\n};\n\nstatic struct attribute_group pmu_format_group = {\n\t.name\t= \"format\",\n\t.attrs\t= formats_attr,\n};\n\nstatic const struct attribute_group *attr_groups[] = {\n\t&pmu_attr_group,\n\t&pmu_format_group,\n\t&pmu_events_group,\n\tNULL,\n};\n\nstatic struct pmu pmu_class = {\n\t.attr_groups\t= attr_groups,\n\t \n\t.task_ctx_nr\t= perf_invalid_context,\n\t.event_init\t= pmu_event_init,\n\t.add\t\t= pmu_event_add,\n\t.del\t\t= pmu_event_del,\n\t.start\t\t= pmu_event_start,\n\t.stop\t\t= pmu_event_stop,\n\t.read\t\t= pmu_event_read,\n\t.capabilities\t= PERF_PMU_CAP_NO_EXCLUDE,\n\t.module\t\t= THIS_MODULE,\n};\n\nstatic int power_cpu_exit(unsigned int cpu)\n{\n\tint target;\n\n\tif (!cpumask_test_and_clear_cpu(cpu, &cpu_mask))\n\t\treturn 0;\n\n\t \n\ttarget = cpumask_any_but(topology_sibling_cpumask(cpu), cpu);\n\tif (target < nr_cpumask_bits) {\n\t\tcpumask_set_cpu(target, &cpu_mask);\n\t\tperf_pmu_migrate_context(&pmu_class, cpu, target);\n\t}\n\treturn 0;\n}\n\nstatic int power_cpu_init(unsigned int cpu)\n{\n\tint target;\n\n\t \n\ttarget = cpumask_any_but(topology_sibling_cpumask(cpu), cpu);\n\tif (target >= nr_cpumask_bits)\n\t\tcpumask_set_cpu(cpu, &cpu_mask);\n\treturn 0;\n}\n\nstatic const struct x86_cpu_id cpu_match[] = {\n\tX86_MATCH_VENDOR_FAM(AMD, 0x15, NULL),\n\t{},\n};\n\nstatic int __init amd_power_pmu_init(void)\n{\n\tint ret;\n\n\tif (!x86_match_cpu(cpu_match))\n\t\treturn -ENODEV;\n\n\tif (!boot_cpu_has(X86_FEATURE_ACC_POWER))\n\t\treturn -ENODEV;\n\n\tcpu_pwr_sample_ratio = cpuid_ecx(0x80000007);\n\n\tif (rdmsrl_safe(MSR_F15H_CU_MAX_PWR_ACCUMULATOR, &max_cu_acc_power)) {\n\t\tpr_err(\"Failed to read max compute unit power accumulator MSR\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\n\tcpuhp_setup_state(CPUHP_AP_PERF_X86_AMD_POWER_ONLINE,\n\t\t\t  \"perf/x86/amd/power:online\",\n\t\t\t  power_cpu_init, power_cpu_exit);\n\n\tret = perf_pmu_register(&pmu_class, \"power\", -1);\n\tif (WARN_ON(ret)) {\n\t\tpr_warn(\"AMD Power PMU registration failed\\n\");\n\t\treturn ret;\n\t}\n\n\tpr_info(\"AMD Power PMU detected\\n\");\n\treturn ret;\n}\nmodule_init(amd_power_pmu_init);\n\nstatic void __exit amd_power_pmu_exit(void)\n{\n\tcpuhp_remove_state_nocalls(CPUHP_AP_PERF_X86_AMD_POWER_ONLINE);\n\tperf_pmu_unregister(&pmu_class);\n}\nmodule_exit(amd_power_pmu_exit);\n\nMODULE_AUTHOR(\"Huang Rui <ray.huang@amd.com>\");\nMODULE_DESCRIPTION(\"AMD Processor Power Reporting Mechanism\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}