{
  "module_name": "p6.c",
  "hash_id": "ed6d4afab5dfab51c43876166bf2afff80dc992dd9ae5eef78e0840924fab5aa",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/events/intel/p6.c",
  "human_readable_source": "\n#include <linux/perf_event.h>\n#include <linux/types.h>\n\n#include \"../perf_event.h\"\n\n \nstatic const u64 p6_perfmon_event_map[] =\n{\n  [PERF_COUNT_HW_CPU_CYCLES]\t\t= 0x0079,\t \n  [PERF_COUNT_HW_INSTRUCTIONS]\t\t= 0x00c0,\t \n  [PERF_COUNT_HW_CACHE_REFERENCES]\t= 0x0f2e,\t \n  [PERF_COUNT_HW_CACHE_MISSES]\t\t= 0x012e,\t \n  [PERF_COUNT_HW_BRANCH_INSTRUCTIONS]\t= 0x00c4,\t \n  [PERF_COUNT_HW_BRANCH_MISSES]\t\t= 0x00c5,\t \n  [PERF_COUNT_HW_BUS_CYCLES]\t\t= 0x0062,\t \n  [PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] = 0x00a2,\t \n\n};\n\nstatic const u64 __initconst p6_hw_cache_event_ids\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX] =\n{\n [ C(L1D) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0043,\t \n                [ C(RESULT_MISS)   ] = 0x0045,\t \n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0x0f29,\t \n\t},\n        [ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n        },\n },\n [ C(L1I ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0080,\t \n\t\t[ C(RESULT_MISS)   ] = 0x0f28,\t \n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(LL  ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0x0025,\t \n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(DTLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0043,\t \n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n },\n [ C(ITLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0080,\t \n\t\t[ C(RESULT_MISS)   ] = 0x0085,\t \n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n [ C(BPU ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x00c4,\t \n\t\t[ C(RESULT_MISS)   ] = 0x00c5,\t \n        },\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n};\n\nstatic u64 p6_pmu_event_map(int hw_event)\n{\n\treturn p6_perfmon_event_map[hw_event];\n}\n\n \n#define P6_NOP_EVENT\t\t\t0x0000002EULL\n\nstatic struct event_constraint p6_event_constraints[] =\n{\n\tINTEL_EVENT_CONSTRAINT(0xc1, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0x10, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0x11, 0x2),\t \n\tINTEL_EVENT_CONSTRAINT(0x12, 0x2),\t \n\tINTEL_EVENT_CONSTRAINT(0x13, 0x2),\t \n\tINTEL_EVENT_CONSTRAINT(0x14, 0x1),\t \n\tEVENT_CONSTRAINT_END\n};\n\nstatic void p6_pmu_disable_all(void)\n{\n\tu64 val;\n\n\t \n\trdmsrl(MSR_P6_EVNTSEL0, val);\n\tval &= ~ARCH_PERFMON_EVENTSEL_ENABLE;\n\twrmsrl(MSR_P6_EVNTSEL0, val);\n}\n\nstatic void p6_pmu_enable_all(int added)\n{\n\tunsigned long val;\n\n\t \n\trdmsrl(MSR_P6_EVNTSEL0, val);\n\tval |= ARCH_PERFMON_EVENTSEL_ENABLE;\n\twrmsrl(MSR_P6_EVNTSEL0, val);\n}\n\nstatic inline void\np6_pmu_disable_event(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 val = P6_NOP_EVENT;\n\n\t(void)wrmsrl_safe(hwc->config_base, val);\n}\n\nstatic void p6_pmu_enable_event(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 val;\n\n\tval = hwc->config;\n\n\t \n\n\t(void)wrmsrl_safe(hwc->config_base, val);\n}\n\nPMU_FORMAT_ATTR(event,\t\"config:0-7\"\t);\nPMU_FORMAT_ATTR(umask,\t\"config:8-15\"\t);\nPMU_FORMAT_ATTR(edge,\t\"config:18\"\t);\nPMU_FORMAT_ATTR(pc,\t\"config:19\"\t);\nPMU_FORMAT_ATTR(inv,\t\"config:23\"\t);\nPMU_FORMAT_ATTR(cmask,\t\"config:24-31\"\t);\n\nstatic struct attribute *intel_p6_formats_attr[] = {\n\t&format_attr_event.attr,\n\t&format_attr_umask.attr,\n\t&format_attr_edge.attr,\n\t&format_attr_pc.attr,\n\t&format_attr_inv.attr,\n\t&format_attr_cmask.attr,\n\tNULL,\n};\n\nstatic __initconst const struct x86_pmu p6_pmu = {\n\t.name\t\t\t= \"p6\",\n\t.handle_irq\t\t= x86_pmu_handle_irq,\n\t.disable_all\t\t= p6_pmu_disable_all,\n\t.enable_all\t\t= p6_pmu_enable_all,\n\t.enable\t\t\t= p6_pmu_enable_event,\n\t.disable\t\t= p6_pmu_disable_event,\n\t.hw_config\t\t= x86_pmu_hw_config,\n\t.schedule_events\t= x86_schedule_events,\n\t.eventsel\t\t= MSR_P6_EVNTSEL0,\n\t.perfctr\t\t= MSR_P6_PERFCTR0,\n\t.event_map\t\t= p6_pmu_event_map,\n\t.max_events\t\t= ARRAY_SIZE(p6_perfmon_event_map),\n\t.apic\t\t\t= 1,\n\t.max_period\t\t= (1ULL << 31) - 1,\n\t.version\t\t= 0,\n\t.num_counters\t\t= 2,\n\t \n\t.cntval_bits\t\t= 32,\n\t.cntval_mask\t\t= (1ULL << 32) - 1,\n\t.get_event_constraints\t= x86_get_event_constraints,\n\t.event_constraints\t= p6_event_constraints,\n\n\t.format_attrs\t\t= intel_p6_formats_attr,\n\t.events_sysfs_show\t= intel_event_sysfs_show,\n\n};\n\nstatic __init void p6_pmu_rdpmc_quirk(void)\n{\n\tif (boot_cpu_data.x86_stepping < 9) {\n\t\t \n\t\tpr_warn(\"Userspace RDPMC support disabled due to a CPU erratum\\n\");\n\t\tx86_pmu.attr_rdpmc_broken = 1;\n\t\tx86_pmu.attr_rdpmc = 0;\n\t}\n}\n\n__init int p6_pmu_init(void)\n{\n\tx86_pmu = p6_pmu;\n\n\tswitch (boot_cpu_data.x86_model) {\n\tcase  1:  \n\t\tx86_add_quirk(p6_pmu_rdpmc_quirk);\n\t\tbreak;\n\n\tcase  3:  \n\tcase  5:  \n\tcase  6:  \n\t\tbreak;\n\n\tcase  7:  \n\tcase  8:  \n\tcase 10:  \n\tcase 11:  \n\t\tbreak;\n\n\tcase  9:  \n\tcase 13:  \n\t\tbreak;\n\n\tdefault:\n\t\tpr_cont(\"unsupported p6 CPU model %d \", boot_cpu_data.x86_model);\n\t\treturn -ENODEV;\n\t}\n\n\tmemcpy(hw_cache_event_ids, p6_hw_cache_event_ids,\n\t\tsizeof(hw_cache_event_ids));\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}