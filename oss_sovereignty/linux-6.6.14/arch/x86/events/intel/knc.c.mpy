{
  "module_name": "knc.c",
  "hash_id": "bde43c5493a24082530fab2b21131792b9b9f68a96d278f8efd81fcaf0b36cc0",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/events/intel/knc.c",
  "human_readable_source": "\n \n\n#include <linux/perf_event.h>\n#include <linux/types.h>\n\n#include <asm/hardirq.h>\n\n#include \"../perf_event.h\"\n\nstatic const u64 knc_perfmon_event_map[] =\n{\n  [PERF_COUNT_HW_CPU_CYCLES]\t\t= 0x002a,\n  [PERF_COUNT_HW_INSTRUCTIONS]\t\t= 0x0016,\n  [PERF_COUNT_HW_CACHE_REFERENCES]\t= 0x0028,\n  [PERF_COUNT_HW_CACHE_MISSES]\t\t= 0x0029,\n  [PERF_COUNT_HW_BRANCH_INSTRUCTIONS]\t= 0x0012,\n  [PERF_COUNT_HW_BRANCH_MISSES]\t\t= 0x002b,\n};\n\nstatic const u64 __initconst knc_hw_cache_event_ids\n\t\t\t\t[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX] =\n{\n [ C(L1D) ] = {\n\t[ C(OP_READ) ] = {\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t[ C(RESULT_ACCESS) ] = ARCH_PERFMON_EVENTSEL_INT,\n\t\t\t\t\t\t \n\t\t[ C(RESULT_MISS)   ] = 0x0003,\t \n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0001,\t \n\t\t[ C(RESULT_MISS)   ] = 0x0004,\t \n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0011,\t \n\t\t[ C(RESULT_MISS)   ] = 0x001c,\t \n\t},\n },\n [ C(L1I ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x000c,\t \n\t\t[ C(RESULT_MISS)   ] = 0x000e,\t \n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0x0,\n\t},\n },\n [ C(LL  ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0,\n\t\t[ C(RESULT_MISS)   ] = 0x10cb,\t \n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x10cc,\t \n\t\t[ C(RESULT_MISS)   ] = 0,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x10fc,\t \n\t\t[ C(RESULT_MISS)   ] = 0x10fe,\t \n\t},\n },\n [ C(DTLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = ARCH_PERFMON_EVENTSEL_INT,\n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\t\t[ C(RESULT_MISS)   ] = 0x0002,\t \n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0001,\t \n\t\t[ C(RESULT_MISS)   ] = 0x0002,\t \n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0,\n\t\t[ C(RESULT_MISS)   ] = 0x0,\n\t},\n },\n [ C(ITLB) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x000c,\t \n\t\t[ C(RESULT_MISS)   ] = 0x000d,\t \n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n [ C(BPU ) ] = {\n\t[ C(OP_READ) ] = {\n\t\t[ C(RESULT_ACCESS) ] = 0x0012,\t \n\t\t[ C(RESULT_MISS)   ] = 0x002b,\t \n\t},\n\t[ C(OP_WRITE) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n\t[ C(OP_PREFETCH) ] = {\n\t\t[ C(RESULT_ACCESS) ] = -1,\n\t\t[ C(RESULT_MISS)   ] = -1,\n\t},\n },\n};\n\n\nstatic u64 knc_pmu_event_map(int hw_event)\n{\n\treturn knc_perfmon_event_map[hw_event];\n}\n\nstatic struct event_constraint knc_event_constraints[] =\n{\n\tINTEL_EVENT_CONSTRAINT(0xc3, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xc4, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xc8, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xc9, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xca, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xcb, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xcc, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xce, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xcf, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xd7, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xe3, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xe6, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xe7, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xf1, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xf2, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xf6, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xf7, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xfc, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xfd, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xfe, 0x1),\t \n\tINTEL_EVENT_CONSTRAINT(0xff, 0x1),\t \n\tEVENT_CONSTRAINT_END\n};\n\n#define MSR_KNC_IA32_PERF_GLOBAL_STATUS\t\t0x0000002d\n#define MSR_KNC_IA32_PERF_GLOBAL_OVF_CONTROL\t0x0000002e\n#define MSR_KNC_IA32_PERF_GLOBAL_CTRL\t\t0x0000002f\n\n#define KNC_ENABLE_COUNTER0\t\t\t0x00000001\n#define KNC_ENABLE_COUNTER1\t\t\t0x00000002\n\nstatic void knc_pmu_disable_all(void)\n{\n\tu64 val;\n\n\trdmsrl(MSR_KNC_IA32_PERF_GLOBAL_CTRL, val);\n\tval &= ~(KNC_ENABLE_COUNTER0|KNC_ENABLE_COUNTER1);\n\twrmsrl(MSR_KNC_IA32_PERF_GLOBAL_CTRL, val);\n}\n\nstatic void knc_pmu_enable_all(int added)\n{\n\tu64 val;\n\n\trdmsrl(MSR_KNC_IA32_PERF_GLOBAL_CTRL, val);\n\tval |= (KNC_ENABLE_COUNTER0|KNC_ENABLE_COUNTER1);\n\twrmsrl(MSR_KNC_IA32_PERF_GLOBAL_CTRL, val);\n}\n\nstatic inline void\nknc_pmu_disable_event(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 val;\n\n\tval = hwc->config;\n\tval &= ~ARCH_PERFMON_EVENTSEL_ENABLE;\n\n\t(void)wrmsrl_safe(hwc->config_base + hwc->idx, val);\n}\n\nstatic void knc_pmu_enable_event(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 val;\n\n\tval = hwc->config;\n\tval |= ARCH_PERFMON_EVENTSEL_ENABLE;\n\n\t(void)wrmsrl_safe(hwc->config_base + hwc->idx, val);\n}\n\nstatic inline u64 knc_pmu_get_status(void)\n{\n\tu64 status;\n\n\trdmsrl(MSR_KNC_IA32_PERF_GLOBAL_STATUS, status);\n\n\treturn status;\n}\n\nstatic inline void knc_pmu_ack_status(u64 ack)\n{\n\twrmsrl(MSR_KNC_IA32_PERF_GLOBAL_OVF_CONTROL, ack);\n}\n\nstatic int knc_pmu_handle_irq(struct pt_regs *regs)\n{\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tint handled = 0;\n\tint bit, loops;\n\tu64 status;\n\n\tcpuc = this_cpu_ptr(&cpu_hw_events);\n\n\tknc_pmu_disable_all();\n\n\tstatus = knc_pmu_get_status();\n\tif (!status) {\n\t\tknc_pmu_enable_all(0);\n\t\treturn handled;\n\t}\n\n\tloops = 0;\nagain:\n\tknc_pmu_ack_status(status);\n\tif (++loops > 100) {\n\t\tWARN_ONCE(1, \"perf: irq loop stuck!\\n\");\n\t\tperf_event_print_debug();\n\t\tgoto done;\n\t}\n\n\tinc_irq_stat(apic_perf_irqs);\n\n\tfor_each_set_bit(bit, (unsigned long *)&status, X86_PMC_IDX_MAX) {\n\t\tstruct perf_event *event = cpuc->events[bit];\n\n\t\thandled++;\n\n\t\tif (!test_bit(bit, cpuc->active_mask))\n\t\t\tcontinue;\n\n\t\tif (!intel_pmu_save_and_restart(event))\n\t\t\tcontinue;\n\n\t\tperf_sample_data_init(&data, 0, event->hw.last_period);\n\n\t\tif (perf_event_overflow(event, &data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\t \n\tstatus = knc_pmu_get_status();\n\tif (status)\n\t\tgoto again;\n\ndone:\n\t \n\tif (cpuc->enabled)\n\t\tknc_pmu_enable_all(0);\n\n\treturn handled;\n}\n\n\nPMU_FORMAT_ATTR(event,\t\"config:0-7\"\t);\nPMU_FORMAT_ATTR(umask,\t\"config:8-15\"\t);\nPMU_FORMAT_ATTR(edge,\t\"config:18\"\t);\nPMU_FORMAT_ATTR(inv,\t\"config:23\"\t);\nPMU_FORMAT_ATTR(cmask,\t\"config:24-31\"\t);\n\nstatic struct attribute *intel_knc_formats_attr[] = {\n\t&format_attr_event.attr,\n\t&format_attr_umask.attr,\n\t&format_attr_edge.attr,\n\t&format_attr_inv.attr,\n\t&format_attr_cmask.attr,\n\tNULL,\n};\n\nstatic const struct x86_pmu knc_pmu __initconst = {\n\t.name\t\t\t= \"knc\",\n\t.handle_irq\t\t= knc_pmu_handle_irq,\n\t.disable_all\t\t= knc_pmu_disable_all,\n\t.enable_all\t\t= knc_pmu_enable_all,\n\t.enable\t\t\t= knc_pmu_enable_event,\n\t.disable\t\t= knc_pmu_disable_event,\n\t.hw_config\t\t= x86_pmu_hw_config,\n\t.schedule_events\t= x86_schedule_events,\n\t.eventsel\t\t= MSR_KNC_EVNTSEL0,\n\t.perfctr\t\t= MSR_KNC_PERFCTR0,\n\t.event_map\t\t= knc_pmu_event_map,\n\t.max_events             = ARRAY_SIZE(knc_perfmon_event_map),\n\t.apic\t\t\t= 1,\n\t.max_period\t\t= (1ULL << 39) - 1,\n\t.version\t\t= 0,\n\t.num_counters\t\t= 2,\n\t.cntval_bits\t\t= 40,\n\t.cntval_mask\t\t= (1ULL << 40) - 1,\n\t.get_event_constraints\t= x86_get_event_constraints,\n\t.event_constraints\t= knc_event_constraints,\n\t.format_attrs\t\t= intel_knc_formats_attr,\n};\n\n__init int knc_pmu_init(void)\n{\n\tx86_pmu = knc_pmu;\n\n\tmemcpy(hw_cache_event_ids, knc_hw_cache_event_ids, \n\t\tsizeof(hw_cache_event_ids));\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}