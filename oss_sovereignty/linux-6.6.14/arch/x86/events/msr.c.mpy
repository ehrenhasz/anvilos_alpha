{
  "module_name": "msr.c",
  "hash_id": "f3c01edc964d0f7bf0bafe0ec8bf669936f081611ea5e8a1e77145eee30c544f",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/events/msr.c",
  "human_readable_source": "\n#include <linux/perf_event.h>\n#include <linux/sysfs.h>\n#include <linux/nospec.h>\n#include <asm/intel-family.h>\n#include \"probe.h\"\n\nenum perf_msr_id {\n\tPERF_MSR_TSC\t\t\t= 0,\n\tPERF_MSR_APERF\t\t\t= 1,\n\tPERF_MSR_MPERF\t\t\t= 2,\n\tPERF_MSR_PPERF\t\t\t= 3,\n\tPERF_MSR_SMI\t\t\t= 4,\n\tPERF_MSR_PTSC\t\t\t= 5,\n\tPERF_MSR_IRPERF\t\t\t= 6,\n\tPERF_MSR_THERM\t\t\t= 7,\n\tPERF_MSR_EVENT_MAX,\n};\n\nstatic bool test_aperfmperf(int idx, void *data)\n{\n\treturn boot_cpu_has(X86_FEATURE_APERFMPERF);\n}\n\nstatic bool test_ptsc(int idx, void *data)\n{\n\treturn boot_cpu_has(X86_FEATURE_PTSC);\n}\n\nstatic bool test_irperf(int idx, void *data)\n{\n\treturn boot_cpu_has(X86_FEATURE_IRPERF);\n}\n\nstatic bool test_therm_status(int idx, void *data)\n{\n\treturn boot_cpu_has(X86_FEATURE_DTHERM);\n}\n\nstatic bool test_intel(int idx, void *data)\n{\n\tif (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL ||\n\t    boot_cpu_data.x86 != 6)\n\t\treturn false;\n\n\tswitch (boot_cpu_data.x86_model) {\n\tcase INTEL_FAM6_NEHALEM:\n\tcase INTEL_FAM6_NEHALEM_G:\n\tcase INTEL_FAM6_NEHALEM_EP:\n\tcase INTEL_FAM6_NEHALEM_EX:\n\n\tcase INTEL_FAM6_WESTMERE:\n\tcase INTEL_FAM6_WESTMERE_EP:\n\tcase INTEL_FAM6_WESTMERE_EX:\n\n\tcase INTEL_FAM6_SANDYBRIDGE:\n\tcase INTEL_FAM6_SANDYBRIDGE_X:\n\n\tcase INTEL_FAM6_IVYBRIDGE:\n\tcase INTEL_FAM6_IVYBRIDGE_X:\n\n\tcase INTEL_FAM6_HASWELL:\n\tcase INTEL_FAM6_HASWELL_X:\n\tcase INTEL_FAM6_HASWELL_L:\n\tcase INTEL_FAM6_HASWELL_G:\n\n\tcase INTEL_FAM6_BROADWELL:\n\tcase INTEL_FAM6_BROADWELL_D:\n\tcase INTEL_FAM6_BROADWELL_G:\n\tcase INTEL_FAM6_BROADWELL_X:\n\tcase INTEL_FAM6_SAPPHIRERAPIDS_X:\n\tcase INTEL_FAM6_EMERALDRAPIDS_X:\n\tcase INTEL_FAM6_GRANITERAPIDS_X:\n\tcase INTEL_FAM6_GRANITERAPIDS_D:\n\n\tcase INTEL_FAM6_ATOM_SILVERMONT:\n\tcase INTEL_FAM6_ATOM_SILVERMONT_D:\n\tcase INTEL_FAM6_ATOM_AIRMONT:\n\n\tcase INTEL_FAM6_ATOM_GOLDMONT:\n\tcase INTEL_FAM6_ATOM_GOLDMONT_D:\n\tcase INTEL_FAM6_ATOM_GOLDMONT_PLUS:\n\tcase INTEL_FAM6_ATOM_TREMONT_D:\n\tcase INTEL_FAM6_ATOM_TREMONT:\n\tcase INTEL_FAM6_ATOM_TREMONT_L:\n\n\tcase INTEL_FAM6_XEON_PHI_KNL:\n\tcase INTEL_FAM6_XEON_PHI_KNM:\n\t\tif (idx == PERF_MSR_SMI)\n\t\t\treturn true;\n\t\tbreak;\n\n\tcase INTEL_FAM6_SKYLAKE_L:\n\tcase INTEL_FAM6_SKYLAKE:\n\tcase INTEL_FAM6_SKYLAKE_X:\n\tcase INTEL_FAM6_KABYLAKE_L:\n\tcase INTEL_FAM6_KABYLAKE:\n\tcase INTEL_FAM6_COMETLAKE_L:\n\tcase INTEL_FAM6_COMETLAKE:\n\tcase INTEL_FAM6_ICELAKE_L:\n\tcase INTEL_FAM6_ICELAKE:\n\tcase INTEL_FAM6_ICELAKE_X:\n\tcase INTEL_FAM6_ICELAKE_D:\n\tcase INTEL_FAM6_TIGERLAKE_L:\n\tcase INTEL_FAM6_TIGERLAKE:\n\tcase INTEL_FAM6_ROCKETLAKE:\n\tcase INTEL_FAM6_ALDERLAKE:\n\tcase INTEL_FAM6_ALDERLAKE_L:\n\tcase INTEL_FAM6_ATOM_GRACEMONT:\n\tcase INTEL_FAM6_RAPTORLAKE:\n\tcase INTEL_FAM6_RAPTORLAKE_P:\n\tcase INTEL_FAM6_RAPTORLAKE_S:\n\tcase INTEL_FAM6_METEORLAKE:\n\tcase INTEL_FAM6_METEORLAKE_L:\n\t\tif (idx == PERF_MSR_SMI || idx == PERF_MSR_PPERF)\n\t\t\treturn true;\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nPMU_EVENT_ATTR_STRING(tsc,\t\t\t\tattr_tsc,\t\t\"event=0x00\"\t);\nPMU_EVENT_ATTR_STRING(aperf,\t\t\t\tattr_aperf,\t\t\"event=0x01\"\t);\nPMU_EVENT_ATTR_STRING(mperf,\t\t\t\tattr_mperf,\t\t\"event=0x02\"\t);\nPMU_EVENT_ATTR_STRING(pperf,\t\t\t\tattr_pperf,\t\t\"event=0x03\"\t);\nPMU_EVENT_ATTR_STRING(smi,\t\t\t\tattr_smi,\t\t\"event=0x04\"\t);\nPMU_EVENT_ATTR_STRING(ptsc,\t\t\t\tattr_ptsc,\t\t\"event=0x05\"\t);\nPMU_EVENT_ATTR_STRING(irperf,\t\t\t\tattr_irperf,\t\t\"event=0x06\"\t);\nPMU_EVENT_ATTR_STRING(cpu_thermal_margin,\t\tattr_therm,\t\t\"event=0x07\"\t);\nPMU_EVENT_ATTR_STRING(cpu_thermal_margin.snapshot,\tattr_therm_snap,\t\"1\"\t\t);\nPMU_EVENT_ATTR_STRING(cpu_thermal_margin.unit,\t\tattr_therm_unit,\t\"C\"\t\t);\n\nstatic unsigned long msr_mask;\n\nPMU_EVENT_GROUP(events, aperf);\nPMU_EVENT_GROUP(events, mperf);\nPMU_EVENT_GROUP(events, pperf);\nPMU_EVENT_GROUP(events, smi);\nPMU_EVENT_GROUP(events, ptsc);\nPMU_EVENT_GROUP(events, irperf);\n\nstatic struct attribute *attrs_therm[] = {\n\t&attr_therm.attr.attr,\n\t&attr_therm_snap.attr.attr,\n\t&attr_therm_unit.attr.attr,\n\tNULL,\n};\n\nstatic struct attribute_group group_therm = {\n\t.name  = \"events\",\n\t.attrs = attrs_therm,\n};\n\nstatic struct perf_msr msr[] = {\n\t[PERF_MSR_TSC]\t\t= { .no_check = true,\t\t\t\t\t\t\t\t},\n\t[PERF_MSR_APERF]\t= { MSR_IA32_APERF,\t\t&group_aperf,\t\ttest_aperfmperf,\t},\n\t[PERF_MSR_MPERF]\t= { MSR_IA32_MPERF,\t\t&group_mperf,\t\ttest_aperfmperf,\t},\n\t[PERF_MSR_PPERF]\t= { MSR_PPERF,\t\t\t&group_pperf,\t\ttest_intel,\t\t},\n\t[PERF_MSR_SMI]\t\t= { MSR_SMI_COUNT,\t\t&group_smi,\t\ttest_intel,\t\t},\n\t[PERF_MSR_PTSC]\t\t= { MSR_F15H_PTSC,\t\t&group_ptsc,\t\ttest_ptsc,\t\t},\n\t[PERF_MSR_IRPERF]\t= { MSR_F17H_IRPERF,\t\t&group_irperf,\t\ttest_irperf,\t\t},\n\t[PERF_MSR_THERM]\t= { MSR_IA32_THERM_STATUS,\t&group_therm,\t\ttest_therm_status,\t},\n};\n\nstatic struct attribute *events_attrs[] = {\n\t&attr_tsc.attr.attr,\n\tNULL,\n};\n\nstatic struct attribute_group events_attr_group = {\n\t.name = \"events\",\n\t.attrs = events_attrs,\n};\n\nPMU_FORMAT_ATTR(event, \"config:0-63\");\nstatic struct attribute *format_attrs[] = {\n\t&format_attr_event.attr,\n\tNULL,\n};\nstatic struct attribute_group format_attr_group = {\n\t.name = \"format\",\n\t.attrs = format_attrs,\n};\n\nstatic const struct attribute_group *attr_groups[] = {\n\t&events_attr_group,\n\t&format_attr_group,\n\tNULL,\n};\n\nstatic const struct attribute_group *attr_update[] = {\n\t&group_aperf,\n\t&group_mperf,\n\t&group_pperf,\n\t&group_smi,\n\t&group_ptsc,\n\t&group_irperf,\n\t&group_therm,\n\tNULL,\n};\n\nstatic int msr_event_init(struct perf_event *event)\n{\n\tu64 cfg = event->attr.config;\n\n\tif (event->attr.type != event->pmu->type)\n\t\treturn -ENOENT;\n\n\t \n\tif (event->attr.sample_period)  \n\t\treturn -EINVAL;\n\n\tif (cfg >= PERF_MSR_EVENT_MAX)\n\t\treturn -EINVAL;\n\n\tcfg = array_index_nospec((unsigned long)cfg, PERF_MSR_EVENT_MAX);\n\n\tif (!(msr_mask & (1 << cfg)))\n\t\treturn -EINVAL;\n\n\tevent->hw.idx\t\t= -1;\n\tevent->hw.event_base\t= msr[cfg].msr;\n\tevent->hw.config\t= cfg;\n\n\treturn 0;\n}\n\nstatic inline u64 msr_read_counter(struct perf_event *event)\n{\n\tu64 now;\n\n\tif (event->hw.event_base)\n\t\trdmsrl(event->hw.event_base, now);\n\telse\n\t\tnow = rdtsc_ordered();\n\n\treturn now;\n}\n\nstatic void msr_event_update(struct perf_event *event)\n{\n\tu64 prev, now;\n\ts64 delta;\n\n\t \n\tprev = local64_read(&event->hw.prev_count);\n\tdo {\n\t\tnow = msr_read_counter(event);\n\t} while (!local64_try_cmpxchg(&event->hw.prev_count, &prev, now));\n\n\tdelta = now - prev;\n\tif (unlikely(event->hw.event_base == MSR_SMI_COUNT)) {\n\t\tdelta = sign_extend64(delta, 31);\n\t\tlocal64_add(delta, &event->count);\n\t} else if (unlikely(event->hw.event_base == MSR_IA32_THERM_STATUS)) {\n\t\t \n\t\tnow = now & (1ULL << 31) ? (now >> 16) & 0x3f :  -1;\n\t\tlocal64_set(&event->count, now);\n\t} else {\n\t\tlocal64_add(delta, &event->count);\n\t}\n}\n\nstatic void msr_event_start(struct perf_event *event, int flags)\n{\n\tu64 now = msr_read_counter(event);\n\n\tlocal64_set(&event->hw.prev_count, now);\n}\n\nstatic void msr_event_stop(struct perf_event *event, int flags)\n{\n\tmsr_event_update(event);\n}\n\nstatic void msr_event_del(struct perf_event *event, int flags)\n{\n\tmsr_event_stop(event, PERF_EF_UPDATE);\n}\n\nstatic int msr_event_add(struct perf_event *event, int flags)\n{\n\tif (flags & PERF_EF_START)\n\t\tmsr_event_start(event, flags);\n\n\treturn 0;\n}\n\nstatic struct pmu pmu_msr = {\n\t.task_ctx_nr\t= perf_sw_context,\n\t.attr_groups\t= attr_groups,\n\t.event_init\t= msr_event_init,\n\t.add\t\t= msr_event_add,\n\t.del\t\t= msr_event_del,\n\t.start\t\t= msr_event_start,\n\t.stop\t\t= msr_event_stop,\n\t.read\t\t= msr_event_update,\n\t.capabilities\t= PERF_PMU_CAP_NO_INTERRUPT | PERF_PMU_CAP_NO_EXCLUDE,\n\t.attr_update\t= attr_update,\n};\n\nstatic int __init msr_init(void)\n{\n\tif (!boot_cpu_has(X86_FEATURE_TSC)) {\n\t\tpr_cont(\"no MSR PMU driver.\\n\");\n\t\treturn 0;\n\t}\n\n\tmsr_mask = perf_msr_probe(msr, PERF_MSR_EVENT_MAX, true, NULL);\n\n\tperf_pmu_register(&pmu_msr, \"msr\", -1);\n\n\treturn 0;\n}\ndevice_initcall(msr_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}