{
  "module_name": "rapl.c",
  "hash_id": "5136d70cac504ef5f30a51c22c17f7109524be70ce309af493bc7f6375e877b8",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/events/rapl.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"RAPL PMU: \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/nospec.h>\n#include <asm/cpu_device_id.h>\n#include <asm/intel-family.h>\n#include \"perf_event.h\"\n#include \"probe.h\"\n\nMODULE_LICENSE(\"GPL\");\n\n \nenum perf_rapl_events {\n\tPERF_RAPL_PP0 = 0,\t\t \n\tPERF_RAPL_PKG,\t\t\t \n\tPERF_RAPL_RAM,\t\t\t \n\tPERF_RAPL_PP1,\t\t\t \n\tPERF_RAPL_PSYS,\t\t\t \n\n\tPERF_RAPL_MAX,\n\tNR_RAPL_DOMAINS = PERF_RAPL_MAX,\n};\n\nstatic const char *const rapl_domain_names[NR_RAPL_DOMAINS] __initconst = {\n\t\"pp0-core\",\n\t\"package\",\n\t\"dram\",\n\t\"pp1-gpu\",\n\t\"psys\",\n};\n\n \n#define RAPL_EVENT_MASK\t0xFFULL\n#define RAPL_CNTR_WIDTH 32\n\n#define RAPL_EVENT_ATTR_STR(_name, v, str)\t\t\t\t\t\\\nstatic struct perf_pmu_events_attr event_attr_##v = {\t\t\t\t\\\n\t.attr\t\t= __ATTR(_name, 0444, perf_event_sysfs_show, NULL),\t\\\n\t.id\t\t= 0,\t\t\t\t\t\t\t\\\n\t.event_str\t= str,\t\t\t\t\t\t\t\\\n};\n\nstruct rapl_pmu {\n\traw_spinlock_t\t\tlock;\n\tint\t\t\tn_active;\n\tint\t\t\tcpu;\n\tstruct list_head\tactive_list;\n\tstruct pmu\t\t*pmu;\n\tktime_t\t\t\ttimer_interval;\n\tstruct hrtimer\t\thrtimer;\n};\n\nstruct rapl_pmus {\n\tstruct pmu\t\tpmu;\n\tunsigned int\t\tmaxdie;\n\tstruct rapl_pmu\t\t*pmus[];\n};\n\nenum rapl_unit_quirk {\n\tRAPL_UNIT_QUIRK_NONE,\n\tRAPL_UNIT_QUIRK_INTEL_HSW,\n\tRAPL_UNIT_QUIRK_INTEL_SPR,\n};\n\nstruct rapl_model {\n\tstruct perf_msr *rapl_msrs;\n\tunsigned long\tevents;\n\tunsigned int\tmsr_power_unit;\n\tenum rapl_unit_quirk\tunit_quirk;\n};\n\n  \nstatic int rapl_hw_unit[NR_RAPL_DOMAINS] __read_mostly;\nstatic struct rapl_pmus *rapl_pmus;\nstatic cpumask_t rapl_cpu_mask;\nstatic unsigned int rapl_cntr_mask;\nstatic u64 rapl_timer_ms;\nstatic struct perf_msr *rapl_msrs;\n\nstatic inline struct rapl_pmu *cpu_to_rapl_pmu(unsigned int cpu)\n{\n\tunsigned int dieid = topology_logical_die_id(cpu);\n\n\t \n\treturn dieid < rapl_pmus->maxdie ? rapl_pmus->pmus[dieid] : NULL;\n}\n\nstatic inline u64 rapl_read_counter(struct perf_event *event)\n{\n\tu64 raw;\n\trdmsrl(event->hw.event_base, raw);\n\treturn raw;\n}\n\nstatic inline u64 rapl_scale(u64 v, int cfg)\n{\n\tif (cfg > NR_RAPL_DOMAINS) {\n\t\tpr_warn(\"Invalid domain %d, failed to scale data\\n\", cfg);\n\t\treturn v;\n\t}\n\t \n\treturn v << (32 - rapl_hw_unit[cfg - 1]);\n}\n\nstatic u64 rapl_event_update(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 prev_raw_count, new_raw_count;\n\ts64 delta, sdelta;\n\tint shift = RAPL_CNTR_WIDTH;\n\nagain:\n\tprev_raw_count = local64_read(&hwc->prev_count);\n\trdmsrl(event->hw.event_base, new_raw_count);\n\n\tif (local64_cmpxchg(&hwc->prev_count, prev_raw_count,\n\t\t\t    new_raw_count) != prev_raw_count) {\n\t\tcpu_relax();\n\t\tgoto again;\n\t}\n\n\t \n\tdelta = (new_raw_count << shift) - (prev_raw_count << shift);\n\tdelta >>= shift;\n\n\tsdelta = rapl_scale(delta, event->hw.config);\n\n\tlocal64_add(sdelta, &event->count);\n\n\treturn new_raw_count;\n}\n\nstatic void rapl_start_hrtimer(struct rapl_pmu *pmu)\n{\n       hrtimer_start(&pmu->hrtimer, pmu->timer_interval,\n\t\t     HRTIMER_MODE_REL_PINNED);\n}\n\nstatic enum hrtimer_restart rapl_hrtimer_handle(struct hrtimer *hrtimer)\n{\n\tstruct rapl_pmu *pmu = container_of(hrtimer, struct rapl_pmu, hrtimer);\n\tstruct perf_event *event;\n\tunsigned long flags;\n\n\tif (!pmu->n_active)\n\t\treturn HRTIMER_NORESTART;\n\n\traw_spin_lock_irqsave(&pmu->lock, flags);\n\n\tlist_for_each_entry(event, &pmu->active_list, active_entry)\n\t\trapl_event_update(event);\n\n\traw_spin_unlock_irqrestore(&pmu->lock, flags);\n\n\thrtimer_forward_now(hrtimer, pmu->timer_interval);\n\n\treturn HRTIMER_RESTART;\n}\n\nstatic void rapl_hrtimer_init(struct rapl_pmu *pmu)\n{\n\tstruct hrtimer *hr = &pmu->hrtimer;\n\n\thrtimer_init(hr, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\thr->function = rapl_hrtimer_handle;\n}\n\nstatic void __rapl_pmu_event_start(struct rapl_pmu *pmu,\n\t\t\t\t   struct perf_event *event)\n{\n\tif (WARN_ON_ONCE(!(event->hw.state & PERF_HES_STOPPED)))\n\t\treturn;\n\n\tevent->hw.state = 0;\n\n\tlist_add_tail(&event->active_entry, &pmu->active_list);\n\n\tlocal64_set(&event->hw.prev_count, rapl_read_counter(event));\n\n\tpmu->n_active++;\n\tif (pmu->n_active == 1)\n\t\trapl_start_hrtimer(pmu);\n}\n\nstatic void rapl_pmu_event_start(struct perf_event *event, int mode)\n{\n\tstruct rapl_pmu *pmu = event->pmu_private;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&pmu->lock, flags);\n\t__rapl_pmu_event_start(pmu, event);\n\traw_spin_unlock_irqrestore(&pmu->lock, flags);\n}\n\nstatic void rapl_pmu_event_stop(struct perf_event *event, int mode)\n{\n\tstruct rapl_pmu *pmu = event->pmu_private;\n\tstruct hw_perf_event *hwc = &event->hw;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&pmu->lock, flags);\n\n\t \n\tif (!(hwc->state & PERF_HES_STOPPED)) {\n\t\tWARN_ON_ONCE(pmu->n_active <= 0);\n\t\tpmu->n_active--;\n\t\tif (pmu->n_active == 0)\n\t\t\thrtimer_cancel(&pmu->hrtimer);\n\n\t\tlist_del(&event->active_entry);\n\n\t\tWARN_ON_ONCE(hwc->state & PERF_HES_STOPPED);\n\t\thwc->state |= PERF_HES_STOPPED;\n\t}\n\n\t \n\tif ((mode & PERF_EF_UPDATE) && !(hwc->state & PERF_HES_UPTODATE)) {\n\t\t \n\t\trapl_event_update(event);\n\t\thwc->state |= PERF_HES_UPTODATE;\n\t}\n\n\traw_spin_unlock_irqrestore(&pmu->lock, flags);\n}\n\nstatic int rapl_pmu_event_add(struct perf_event *event, int mode)\n{\n\tstruct rapl_pmu *pmu = event->pmu_private;\n\tstruct hw_perf_event *hwc = &event->hw;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&pmu->lock, flags);\n\n\thwc->state = PERF_HES_UPTODATE | PERF_HES_STOPPED;\n\n\tif (mode & PERF_EF_START)\n\t\t__rapl_pmu_event_start(pmu, event);\n\n\traw_spin_unlock_irqrestore(&pmu->lock, flags);\n\n\treturn 0;\n}\n\nstatic void rapl_pmu_event_del(struct perf_event *event, int flags)\n{\n\trapl_pmu_event_stop(event, PERF_EF_UPDATE);\n}\n\nstatic int rapl_pmu_event_init(struct perf_event *event)\n{\n\tu64 cfg = event->attr.config & RAPL_EVENT_MASK;\n\tint bit, ret = 0;\n\tstruct rapl_pmu *pmu;\n\n\t \n\tif (event->attr.type != rapl_pmus->pmu.type)\n\t\treturn -ENOENT;\n\n\t \n\tif (event->attr.config & ~RAPL_EVENT_MASK)\n\t\treturn -EINVAL;\n\n\tif (event->cpu < 0)\n\t\treturn -EINVAL;\n\n\tevent->event_caps |= PERF_EV_CAP_READ_ACTIVE_PKG;\n\n\tif (!cfg || cfg >= NR_RAPL_DOMAINS + 1)\n\t\treturn -EINVAL;\n\n\tcfg = array_index_nospec((long)cfg, NR_RAPL_DOMAINS + 1);\n\tbit = cfg - 1;\n\n\t \n\tif (!(rapl_cntr_mask & (1 << bit)))\n\t\treturn -EINVAL;\n\n\t \n\tif (event->attr.sample_period)  \n\t\treturn -EINVAL;\n\n\t \n\tpmu = cpu_to_rapl_pmu(event->cpu);\n\tif (!pmu)\n\t\treturn -EINVAL;\n\tevent->cpu = pmu->cpu;\n\tevent->pmu_private = pmu;\n\tevent->hw.event_base = rapl_msrs[bit].msr;\n\tevent->hw.config = cfg;\n\tevent->hw.idx = bit;\n\n\treturn ret;\n}\n\nstatic void rapl_pmu_event_read(struct perf_event *event)\n{\n\trapl_event_update(event);\n}\n\nstatic ssize_t rapl_get_attr_cpumask(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn cpumap_print_to_pagebuf(true, buf, &rapl_cpu_mask);\n}\n\nstatic DEVICE_ATTR(cpumask, S_IRUGO, rapl_get_attr_cpumask, NULL);\n\nstatic struct attribute *rapl_pmu_attrs[] = {\n\t&dev_attr_cpumask.attr,\n\tNULL,\n};\n\nstatic struct attribute_group rapl_pmu_attr_group = {\n\t.attrs = rapl_pmu_attrs,\n};\n\nRAPL_EVENT_ATTR_STR(energy-cores, rapl_cores, \"event=0x01\");\nRAPL_EVENT_ATTR_STR(energy-pkg  ,   rapl_pkg, \"event=0x02\");\nRAPL_EVENT_ATTR_STR(energy-ram  ,   rapl_ram, \"event=0x03\");\nRAPL_EVENT_ATTR_STR(energy-gpu  ,   rapl_gpu, \"event=0x04\");\nRAPL_EVENT_ATTR_STR(energy-psys,   rapl_psys, \"event=0x05\");\n\nRAPL_EVENT_ATTR_STR(energy-cores.unit, rapl_cores_unit, \"Joules\");\nRAPL_EVENT_ATTR_STR(energy-pkg.unit  ,   rapl_pkg_unit, \"Joules\");\nRAPL_EVENT_ATTR_STR(energy-ram.unit  ,   rapl_ram_unit, \"Joules\");\nRAPL_EVENT_ATTR_STR(energy-gpu.unit  ,   rapl_gpu_unit, \"Joules\");\nRAPL_EVENT_ATTR_STR(energy-psys.unit,   rapl_psys_unit, \"Joules\");\n\n \nRAPL_EVENT_ATTR_STR(energy-cores.scale, rapl_cores_scale, \"2.3283064365386962890625e-10\");\nRAPL_EVENT_ATTR_STR(energy-pkg.scale,     rapl_pkg_scale, \"2.3283064365386962890625e-10\");\nRAPL_EVENT_ATTR_STR(energy-ram.scale,     rapl_ram_scale, \"2.3283064365386962890625e-10\");\nRAPL_EVENT_ATTR_STR(energy-gpu.scale,     rapl_gpu_scale, \"2.3283064365386962890625e-10\");\nRAPL_EVENT_ATTR_STR(energy-psys.scale,   rapl_psys_scale, \"2.3283064365386962890625e-10\");\n\n \nstatic struct attribute *attrs_empty[] = {\n\tNULL,\n};\n\nstatic struct attribute_group rapl_pmu_events_group = {\n\t.name = \"events\",\n\t.attrs = attrs_empty,\n};\n\nPMU_FORMAT_ATTR(event, \"config:0-7\");\nstatic struct attribute *rapl_formats_attr[] = {\n\t&format_attr_event.attr,\n\tNULL,\n};\n\nstatic struct attribute_group rapl_pmu_format_group = {\n\t.name = \"format\",\n\t.attrs = rapl_formats_attr,\n};\n\nstatic const struct attribute_group *rapl_attr_groups[] = {\n\t&rapl_pmu_attr_group,\n\t&rapl_pmu_format_group,\n\t&rapl_pmu_events_group,\n\tNULL,\n};\n\nstatic struct attribute *rapl_events_cores[] = {\n\tEVENT_PTR(rapl_cores),\n\tEVENT_PTR(rapl_cores_unit),\n\tEVENT_PTR(rapl_cores_scale),\n\tNULL,\n};\n\nstatic struct attribute_group rapl_events_cores_group = {\n\t.name  = \"events\",\n\t.attrs = rapl_events_cores,\n};\n\nstatic struct attribute *rapl_events_pkg[] = {\n\tEVENT_PTR(rapl_pkg),\n\tEVENT_PTR(rapl_pkg_unit),\n\tEVENT_PTR(rapl_pkg_scale),\n\tNULL,\n};\n\nstatic struct attribute_group rapl_events_pkg_group = {\n\t.name  = \"events\",\n\t.attrs = rapl_events_pkg,\n};\n\nstatic struct attribute *rapl_events_ram[] = {\n\tEVENT_PTR(rapl_ram),\n\tEVENT_PTR(rapl_ram_unit),\n\tEVENT_PTR(rapl_ram_scale),\n\tNULL,\n};\n\nstatic struct attribute_group rapl_events_ram_group = {\n\t.name  = \"events\",\n\t.attrs = rapl_events_ram,\n};\n\nstatic struct attribute *rapl_events_gpu[] = {\n\tEVENT_PTR(rapl_gpu),\n\tEVENT_PTR(rapl_gpu_unit),\n\tEVENT_PTR(rapl_gpu_scale),\n\tNULL,\n};\n\nstatic struct attribute_group rapl_events_gpu_group = {\n\t.name  = \"events\",\n\t.attrs = rapl_events_gpu,\n};\n\nstatic struct attribute *rapl_events_psys[] = {\n\tEVENT_PTR(rapl_psys),\n\tEVENT_PTR(rapl_psys_unit),\n\tEVENT_PTR(rapl_psys_scale),\n\tNULL,\n};\n\nstatic struct attribute_group rapl_events_psys_group = {\n\t.name  = \"events\",\n\t.attrs = rapl_events_psys,\n};\n\nstatic bool test_msr(int idx, void *data)\n{\n\treturn test_bit(idx, (unsigned long *) data);\n}\n\n \n#define RAPL_MSR_MASK 0xFFFFFFFF\n\nstatic struct perf_msr intel_rapl_msrs[] = {\n\t[PERF_RAPL_PP0]  = { MSR_PP0_ENERGY_STATUS,      &rapl_events_cores_group, test_msr, false, RAPL_MSR_MASK },\n\t[PERF_RAPL_PKG]  = { MSR_PKG_ENERGY_STATUS,      &rapl_events_pkg_group,   test_msr, false, RAPL_MSR_MASK },\n\t[PERF_RAPL_RAM]  = { MSR_DRAM_ENERGY_STATUS,     &rapl_events_ram_group,   test_msr, false, RAPL_MSR_MASK },\n\t[PERF_RAPL_PP1]  = { MSR_PP1_ENERGY_STATUS,      &rapl_events_gpu_group,   test_msr, false, RAPL_MSR_MASK },\n\t[PERF_RAPL_PSYS] = { MSR_PLATFORM_ENERGY_STATUS, &rapl_events_psys_group,  test_msr, false, RAPL_MSR_MASK },\n};\n\nstatic struct perf_msr intel_rapl_spr_msrs[] = {\n\t[PERF_RAPL_PP0]  = { MSR_PP0_ENERGY_STATUS,      &rapl_events_cores_group, test_msr, false, RAPL_MSR_MASK },\n\t[PERF_RAPL_PKG]  = { MSR_PKG_ENERGY_STATUS,      &rapl_events_pkg_group,   test_msr, false, RAPL_MSR_MASK },\n\t[PERF_RAPL_RAM]  = { MSR_DRAM_ENERGY_STATUS,     &rapl_events_ram_group,   test_msr, false, RAPL_MSR_MASK },\n\t[PERF_RAPL_PP1]  = { MSR_PP1_ENERGY_STATUS,      &rapl_events_gpu_group,   test_msr, false, RAPL_MSR_MASK },\n\t[PERF_RAPL_PSYS] = { MSR_PLATFORM_ENERGY_STATUS, &rapl_events_psys_group,  test_msr, true, RAPL_MSR_MASK },\n};\n\n \nstatic struct perf_msr amd_rapl_msrs[] = {\n\t[PERF_RAPL_PP0]  = { 0, &rapl_events_cores_group, 0, false, 0 },\n\t[PERF_RAPL_PKG]  = { MSR_AMD_PKG_ENERGY_STATUS,  &rapl_events_pkg_group,   test_msr, false, RAPL_MSR_MASK },\n\t[PERF_RAPL_RAM]  = { 0, &rapl_events_ram_group,   0, false, 0 },\n\t[PERF_RAPL_PP1]  = { 0, &rapl_events_gpu_group,   0, false, 0 },\n\t[PERF_RAPL_PSYS] = { 0, &rapl_events_psys_group,  0, false, 0 },\n};\n\nstatic int rapl_cpu_offline(unsigned int cpu)\n{\n\tstruct rapl_pmu *pmu = cpu_to_rapl_pmu(cpu);\n\tint target;\n\n\t \n\tif (!cpumask_test_and_clear_cpu(cpu, &rapl_cpu_mask))\n\t\treturn 0;\n\n\tpmu->cpu = -1;\n\t \n\ttarget = cpumask_any_but(topology_die_cpumask(cpu), cpu);\n\n\t \n\tif (target < nr_cpu_ids) {\n\t\tcpumask_set_cpu(target, &rapl_cpu_mask);\n\t\tpmu->cpu = target;\n\t\tperf_pmu_migrate_context(pmu->pmu, cpu, target);\n\t}\n\treturn 0;\n}\n\nstatic int rapl_cpu_online(unsigned int cpu)\n{\n\tstruct rapl_pmu *pmu = cpu_to_rapl_pmu(cpu);\n\tint target;\n\n\tif (!pmu) {\n\t\tpmu = kzalloc_node(sizeof(*pmu), GFP_KERNEL, cpu_to_node(cpu));\n\t\tif (!pmu)\n\t\t\treturn -ENOMEM;\n\n\t\traw_spin_lock_init(&pmu->lock);\n\t\tINIT_LIST_HEAD(&pmu->active_list);\n\t\tpmu->pmu = &rapl_pmus->pmu;\n\t\tpmu->timer_interval = ms_to_ktime(rapl_timer_ms);\n\t\trapl_hrtimer_init(pmu);\n\n\t\trapl_pmus->pmus[topology_logical_die_id(cpu)] = pmu;\n\t}\n\n\t \n\ttarget = cpumask_any_and(&rapl_cpu_mask, topology_die_cpumask(cpu));\n\tif (target < nr_cpu_ids)\n\t\treturn 0;\n\n\tcpumask_set_cpu(cpu, &rapl_cpu_mask);\n\tpmu->cpu = cpu;\n\treturn 0;\n}\n\nstatic int rapl_check_hw_unit(struct rapl_model *rm)\n{\n\tu64 msr_rapl_power_unit_bits;\n\tint i;\n\n\t \n\tif (rdmsrl_safe(rm->msr_power_unit, &msr_rapl_power_unit_bits))\n\t\treturn -1;\n\tfor (i = 0; i < NR_RAPL_DOMAINS; i++)\n\t\trapl_hw_unit[i] = (msr_rapl_power_unit_bits >> 8) & 0x1FULL;\n\n\tswitch (rm->unit_quirk) {\n\t \n\tcase RAPL_UNIT_QUIRK_INTEL_HSW:\n\t\trapl_hw_unit[PERF_RAPL_RAM] = 16;\n\t\tbreak;\n\t \n\tcase RAPL_UNIT_QUIRK_INTEL_SPR:\n\t\trapl_hw_unit[PERF_RAPL_PSYS] = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\n\t \n\trapl_timer_ms = 2;\n\tif (rapl_hw_unit[0] < 32) {\n\t\trapl_timer_ms = (1000 / (2 * 100));\n\t\trapl_timer_ms *= (1ULL << (32 - rapl_hw_unit[0] - 1));\n\t}\n\treturn 0;\n}\n\nstatic void __init rapl_advertise(void)\n{\n\tint i;\n\n\tpr_info(\"API unit is 2^-32 Joules, %d fixed counters, %llu ms ovfl timer\\n\",\n\t\thweight32(rapl_cntr_mask), rapl_timer_ms);\n\n\tfor (i = 0; i < NR_RAPL_DOMAINS; i++) {\n\t\tif (rapl_cntr_mask & (1 << i)) {\n\t\t\tpr_info(\"hw unit of domain %s 2^-%d Joules\\n\",\n\t\t\t\trapl_domain_names[i], rapl_hw_unit[i]);\n\t\t}\n\t}\n}\n\nstatic void cleanup_rapl_pmus(void)\n{\n\tint i;\n\n\tfor (i = 0; i < rapl_pmus->maxdie; i++)\n\t\tkfree(rapl_pmus->pmus[i]);\n\tkfree(rapl_pmus);\n}\n\nstatic const struct attribute_group *rapl_attr_update[] = {\n\t&rapl_events_cores_group,\n\t&rapl_events_pkg_group,\n\t&rapl_events_ram_group,\n\t&rapl_events_gpu_group,\n\t&rapl_events_psys_group,\n\tNULL,\n};\n\nstatic int __init init_rapl_pmus(void)\n{\n\tint maxdie = topology_max_packages() * topology_max_die_per_package();\n\tsize_t size;\n\n\tsize = sizeof(*rapl_pmus) + maxdie * sizeof(struct rapl_pmu *);\n\trapl_pmus = kzalloc(size, GFP_KERNEL);\n\tif (!rapl_pmus)\n\t\treturn -ENOMEM;\n\n\trapl_pmus->maxdie\t\t= maxdie;\n\trapl_pmus->pmu.attr_groups\t= rapl_attr_groups;\n\trapl_pmus->pmu.attr_update\t= rapl_attr_update;\n\trapl_pmus->pmu.task_ctx_nr\t= perf_invalid_context;\n\trapl_pmus->pmu.event_init\t= rapl_pmu_event_init;\n\trapl_pmus->pmu.add\t\t= rapl_pmu_event_add;\n\trapl_pmus->pmu.del\t\t= rapl_pmu_event_del;\n\trapl_pmus->pmu.start\t\t= rapl_pmu_event_start;\n\trapl_pmus->pmu.stop\t\t= rapl_pmu_event_stop;\n\trapl_pmus->pmu.read\t\t= rapl_pmu_event_read;\n\trapl_pmus->pmu.module\t\t= THIS_MODULE;\n\trapl_pmus->pmu.capabilities\t= PERF_PMU_CAP_NO_EXCLUDE;\n\treturn 0;\n}\n\nstatic struct rapl_model model_snb = {\n\t.events\t\t= BIT(PERF_RAPL_PP0) |\n\t\t\t  BIT(PERF_RAPL_PKG) |\n\t\t\t  BIT(PERF_RAPL_PP1),\n\t.msr_power_unit = MSR_RAPL_POWER_UNIT,\n\t.rapl_msrs      = intel_rapl_msrs,\n};\n\nstatic struct rapl_model model_snbep = {\n\t.events\t\t= BIT(PERF_RAPL_PP0) |\n\t\t\t  BIT(PERF_RAPL_PKG) |\n\t\t\t  BIT(PERF_RAPL_RAM),\n\t.msr_power_unit = MSR_RAPL_POWER_UNIT,\n\t.rapl_msrs      = intel_rapl_msrs,\n};\n\nstatic struct rapl_model model_hsw = {\n\t.events\t\t= BIT(PERF_RAPL_PP0) |\n\t\t\t  BIT(PERF_RAPL_PKG) |\n\t\t\t  BIT(PERF_RAPL_RAM) |\n\t\t\t  BIT(PERF_RAPL_PP1),\n\t.msr_power_unit = MSR_RAPL_POWER_UNIT,\n\t.rapl_msrs      = intel_rapl_msrs,\n};\n\nstatic struct rapl_model model_hsx = {\n\t.events\t\t= BIT(PERF_RAPL_PP0) |\n\t\t\t  BIT(PERF_RAPL_PKG) |\n\t\t\t  BIT(PERF_RAPL_RAM),\n\t.unit_quirk\t= RAPL_UNIT_QUIRK_INTEL_HSW,\n\t.msr_power_unit = MSR_RAPL_POWER_UNIT,\n\t.rapl_msrs      = intel_rapl_msrs,\n};\n\nstatic struct rapl_model model_knl = {\n\t.events\t\t= BIT(PERF_RAPL_PKG) |\n\t\t\t  BIT(PERF_RAPL_RAM),\n\t.unit_quirk\t= RAPL_UNIT_QUIRK_INTEL_HSW,\n\t.msr_power_unit = MSR_RAPL_POWER_UNIT,\n\t.rapl_msrs      = intel_rapl_msrs,\n};\n\nstatic struct rapl_model model_skl = {\n\t.events\t\t= BIT(PERF_RAPL_PP0) |\n\t\t\t  BIT(PERF_RAPL_PKG) |\n\t\t\t  BIT(PERF_RAPL_RAM) |\n\t\t\t  BIT(PERF_RAPL_PP1) |\n\t\t\t  BIT(PERF_RAPL_PSYS),\n\t.msr_power_unit = MSR_RAPL_POWER_UNIT,\n\t.rapl_msrs      = intel_rapl_msrs,\n};\n\nstatic struct rapl_model model_spr = {\n\t.events\t\t= BIT(PERF_RAPL_PP0) |\n\t\t\t  BIT(PERF_RAPL_PKG) |\n\t\t\t  BIT(PERF_RAPL_RAM) |\n\t\t\t  BIT(PERF_RAPL_PSYS),\n\t.unit_quirk\t= RAPL_UNIT_QUIRK_INTEL_SPR,\n\t.msr_power_unit = MSR_RAPL_POWER_UNIT,\n\t.rapl_msrs      = intel_rapl_spr_msrs,\n};\n\nstatic struct rapl_model model_amd_hygon = {\n\t.events\t\t= BIT(PERF_RAPL_PKG),\n\t.msr_power_unit = MSR_AMD_RAPL_POWER_UNIT,\n\t.rapl_msrs      = amd_rapl_msrs,\n};\n\nstatic const struct x86_cpu_id rapl_model_match[] __initconst = {\n\tX86_MATCH_FEATURE(X86_FEATURE_RAPL,\t\t&model_amd_hygon),\n\tX86_MATCH_INTEL_FAM6_MODEL(SANDYBRIDGE,\t\t&model_snb),\n\tX86_MATCH_INTEL_FAM6_MODEL(SANDYBRIDGE_X,\t&model_snbep),\n\tX86_MATCH_INTEL_FAM6_MODEL(IVYBRIDGE,\t\t&model_snb),\n\tX86_MATCH_INTEL_FAM6_MODEL(IVYBRIDGE_X,\t\t&model_snbep),\n\tX86_MATCH_INTEL_FAM6_MODEL(HASWELL,\t\t&model_hsw),\n\tX86_MATCH_INTEL_FAM6_MODEL(HASWELL_X,\t\t&model_hsx),\n\tX86_MATCH_INTEL_FAM6_MODEL(HASWELL_L,\t\t&model_hsw),\n\tX86_MATCH_INTEL_FAM6_MODEL(HASWELL_G,\t\t&model_hsw),\n\tX86_MATCH_INTEL_FAM6_MODEL(BROADWELL,\t\t&model_hsw),\n\tX86_MATCH_INTEL_FAM6_MODEL(BROADWELL_G,\t\t&model_hsw),\n\tX86_MATCH_INTEL_FAM6_MODEL(BROADWELL_X,\t\t&model_hsx),\n\tX86_MATCH_INTEL_FAM6_MODEL(BROADWELL_D,\t\t&model_hsx),\n\tX86_MATCH_INTEL_FAM6_MODEL(XEON_PHI_KNL,\t&model_knl),\n\tX86_MATCH_INTEL_FAM6_MODEL(XEON_PHI_KNM,\t&model_knl),\n\tX86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_L,\t\t&model_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(SKYLAKE,\t\t&model_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_X,\t\t&model_hsx),\n\tX86_MATCH_INTEL_FAM6_MODEL(KABYLAKE_L,\t\t&model_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(KABYLAKE,\t\t&model_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(CANNONLAKE_L,\t&model_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_GOLDMONT,\t&model_hsw),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_GOLDMONT_D,\t&model_hsw),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_GOLDMONT_PLUS,\t&model_hsw),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_L,\t\t&model_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE,\t\t&model_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_D,\t\t&model_hsx),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_X,\t\t&model_hsx),\n\tX86_MATCH_INTEL_FAM6_MODEL(COMETLAKE_L,\t\t&model_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(COMETLAKE,\t\t&model_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(TIGERLAKE_L,\t\t&model_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(TIGERLAKE,\t\t&model_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE,\t\t&model_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE_L,\t\t&model_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_GRACEMONT,\t&model_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(SAPPHIRERAPIDS_X,\t&model_spr),\n\tX86_MATCH_INTEL_FAM6_MODEL(EMERALDRAPIDS_X,\t&model_spr),\n\tX86_MATCH_INTEL_FAM6_MODEL(RAPTORLAKE,\t\t&model_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(RAPTORLAKE_P,\t&model_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(RAPTORLAKE_S,\t&model_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(METEORLAKE,\t\t&model_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(METEORLAKE_L,\t&model_skl),\n\t{},\n};\nMODULE_DEVICE_TABLE(x86cpu, rapl_model_match);\n\nstatic int __init rapl_pmu_init(void)\n{\n\tconst struct x86_cpu_id *id;\n\tstruct rapl_model *rm;\n\tint ret;\n\n\tid = x86_match_cpu(rapl_model_match);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\trm = (struct rapl_model *) id->driver_data;\n\n\trapl_msrs = rm->rapl_msrs;\n\n\trapl_cntr_mask = perf_msr_probe(rapl_msrs, PERF_RAPL_MAX,\n\t\t\t\t\tfalse, (void *) &rm->events);\n\n\tret = rapl_check_hw_unit(rm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = init_rapl_pmus();\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = cpuhp_setup_state(CPUHP_AP_PERF_X86_RAPL_ONLINE,\n\t\t\t\t\"perf/x86/rapl:online\",\n\t\t\t\trapl_cpu_online, rapl_cpu_offline);\n\tif (ret)\n\t\tgoto out;\n\n\tret = perf_pmu_register(&rapl_pmus->pmu, \"power\", -1);\n\tif (ret)\n\t\tgoto out1;\n\n\trapl_advertise();\n\treturn 0;\n\nout1:\n\tcpuhp_remove_state(CPUHP_AP_PERF_X86_RAPL_ONLINE);\nout:\n\tpr_warn(\"Initialization failed (%d), disabled\\n\", ret);\n\tcleanup_rapl_pmus();\n\treturn ret;\n}\nmodule_init(rapl_pmu_init);\n\nstatic void __exit intel_rapl_exit(void)\n{\n\tcpuhp_remove_state_nocalls(CPUHP_AP_PERF_X86_RAPL_ONLINE);\n\tperf_pmu_unregister(&rapl_pmus->pmu);\n\tcleanup_rapl_pmus();\n}\nmodule_exit(intel_rapl_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}