{
  "module_name": "tdx.c",
  "hash_id": "ed415ba45e4c554163fe32265d6c23495040bc713581e0d8c4f59cf550801aec",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/coco/tdx/tdx.c",
  "human_readable_source": "\n \n\n#undef pr_fmt\n#define pr_fmt(fmt)     \"tdx: \" fmt\n\n#include <linux/cpufeature.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <asm/coco.h>\n#include <asm/tdx.h>\n#include <asm/vmx.h>\n#include <asm/ia32.h>\n#include <asm/insn.h>\n#include <asm/insn-eval.h>\n#include <asm/pgtable.h>\n\n \n#define EPT_READ\t0\n#define EPT_WRITE\t1\n\n \n#define PORT_READ\t0\n#define PORT_WRITE\t1\n\n \n#define VE_IS_IO_IN(e)\t\t((e) & BIT(3))\n#define VE_GET_IO_SIZE(e)\t(((e) & GENMASK(2, 0)) + 1)\n#define VE_GET_PORT_NUM(e)\t((e) >> 16)\n#define VE_IS_IO_STRING(e)\t((e) & BIT(4))\n\n#define ATTR_DEBUG\t\tBIT(0)\n#define ATTR_SEPT_VE_DISABLE\tBIT(28)\n\n \n#define TDCALL_RETURN_CODE(a)\t((a) >> 32)\n#define TDCALL_INVALID_OPERAND\t0xc0000100\n\n#define TDREPORT_SUBTYPE_0\t0\n\n \nnoinstr void __tdx_hypercall_failed(void)\n{\n\tinstrumentation_begin();\n\tpanic(\"TDVMCALL failed. TDX module bug?\");\n}\n\n#ifdef CONFIG_KVM_GUEST\nlong tdx_kvm_hypercall(unsigned int nr, unsigned long p1, unsigned long p2,\n\t\t       unsigned long p3, unsigned long p4)\n{\n\tstruct tdx_hypercall_args args = {\n\t\t.r10 = nr,\n\t\t.r11 = p1,\n\t\t.r12 = p2,\n\t\t.r13 = p3,\n\t\t.r14 = p4,\n\t};\n\n\treturn __tdx_hypercall(&args);\n}\nEXPORT_SYMBOL_GPL(tdx_kvm_hypercall);\n#endif\n\n \nstatic inline void tdx_module_call(u64 fn, u64 rcx, u64 rdx, u64 r8, u64 r9,\n\t\t\t\t   struct tdx_module_output *out)\n{\n\tif (__tdx_module_call(fn, rcx, rdx, r8, r9, out))\n\t\tpanic(\"TDCALL %lld failed (Buggy TDX module!)\\n\", fn);\n}\n\n \nint tdx_mcall_get_report0(u8 *reportdata, u8 *tdreport)\n{\n\tu64 ret;\n\n\tret = __tdx_module_call(TDX_GET_REPORT, virt_to_phys(tdreport),\n\t\t\t\tvirt_to_phys(reportdata), TDREPORT_SUBTYPE_0,\n\t\t\t\t0, NULL);\n\tif (ret) {\n\t\tif (TDCALL_RETURN_CODE(ret) == TDCALL_INVALID_OPERAND)\n\t\t\treturn -EINVAL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tdx_mcall_get_report0);\n\nstatic void __noreturn tdx_panic(const char *msg)\n{\n\tstruct tdx_hypercall_args args = {\n\t\t.r10 = TDX_HYPERCALL_STANDARD,\n\t\t.r11 = TDVMCALL_REPORT_FATAL_ERROR,\n\t\t.r12 = 0,  \n\t};\n\tunion {\n\t\t \n\t\tstruct { u64 r14, r15, rbx, rdi, rsi, r8, r9, rdx; };\n\n\t\tchar str[64];\n\t} message;\n\n\t \n\tstrncpy(message.str, msg, 64);\n\n\targs.r8  = message.r8;\n\targs.r9  = message.r9;\n\targs.r14 = message.r14;\n\targs.r15 = message.r15;\n\targs.rdi = message.rdi;\n\targs.rsi = message.rsi;\n\targs.rbx = message.rbx;\n\targs.rdx = message.rdx;\n\n\t \n\twhile (1)\n\t\t__tdx_hypercall(&args);\n}\n\nstatic void tdx_parse_tdinfo(u64 *cc_mask)\n{\n\tstruct tdx_module_output out;\n\tunsigned int gpa_width;\n\tu64 td_attr;\n\n\t \n\ttdx_module_call(TDX_GET_INFO, 0, 0, 0, 0, &out);\n\n\t \n\tgpa_width = out.rcx & GENMASK(5, 0);\n\t*cc_mask = BIT_ULL(gpa_width - 1);\n\n\t \n\ttd_attr = out.rdx;\n\tif (!(td_attr & ATTR_SEPT_VE_DISABLE)) {\n\t\tconst char *msg = \"TD misconfiguration: SEPT_VE_DISABLE attribute must be set.\";\n\n\t\t \n\t\tif (td_attr & ATTR_DEBUG)\n\t\t\tpr_warn(\"%s\\n\", msg);\n\t\telse\n\t\t\ttdx_panic(msg);\n\t}\n}\n\n \nstatic int ve_instr_len(struct ve_info *ve)\n{\n\tswitch (ve->exit_reason) {\n\tcase EXIT_REASON_HLT:\n\tcase EXIT_REASON_MSR_READ:\n\tcase EXIT_REASON_MSR_WRITE:\n\tcase EXIT_REASON_CPUID:\n\tcase EXIT_REASON_IO_INSTRUCTION:\n\t\t \n\t\treturn ve->instr_len;\n\tcase EXIT_REASON_EPT_VIOLATION:\n\t\t \n\t\tWARN_ONCE(1, \"ve->instr_len is not defined for EPT violations\");\n\t\treturn 0;\n\tdefault:\n\t\tWARN_ONCE(1, \"Unexpected #VE-type: %lld\\n\", ve->exit_reason);\n\t\treturn ve->instr_len;\n\t}\n}\n\nstatic u64 __cpuidle __halt(const bool irq_disabled)\n{\n\tstruct tdx_hypercall_args args = {\n\t\t.r10 = TDX_HYPERCALL_STANDARD,\n\t\t.r11 = hcall_func(EXIT_REASON_HLT),\n\t\t.r12 = irq_disabled,\n\t};\n\n\t \n\treturn __tdx_hypercall(&args);\n}\n\nstatic int handle_halt(struct ve_info *ve)\n{\n\tconst bool irq_disabled = irqs_disabled();\n\n\tif (__halt(irq_disabled))\n\t\treturn -EIO;\n\n\treturn ve_instr_len(ve);\n}\n\nvoid __cpuidle tdx_safe_halt(void)\n{\n\tconst bool irq_disabled = false;\n\n\t \n\tif (__halt(irq_disabled))\n\t\tWARN_ONCE(1, \"HLT instruction emulation failed\\n\");\n}\n\nstatic int read_msr(struct pt_regs *regs, struct ve_info *ve)\n{\n\tstruct tdx_hypercall_args args = {\n\t\t.r10 = TDX_HYPERCALL_STANDARD,\n\t\t.r11 = hcall_func(EXIT_REASON_MSR_READ),\n\t\t.r12 = regs->cx,\n\t};\n\n\t \n\tif (__tdx_hypercall_ret(&args))\n\t\treturn -EIO;\n\n\tregs->ax = lower_32_bits(args.r11);\n\tregs->dx = upper_32_bits(args.r11);\n\treturn ve_instr_len(ve);\n}\n\nstatic int write_msr(struct pt_regs *regs, struct ve_info *ve)\n{\n\tstruct tdx_hypercall_args args = {\n\t\t.r10 = TDX_HYPERCALL_STANDARD,\n\t\t.r11 = hcall_func(EXIT_REASON_MSR_WRITE),\n\t\t.r12 = regs->cx,\n\t\t.r13 = (u64)regs->dx << 32 | regs->ax,\n\t};\n\n\t \n\tif (__tdx_hypercall(&args))\n\t\treturn -EIO;\n\n\treturn ve_instr_len(ve);\n}\n\nstatic int handle_cpuid(struct pt_regs *regs, struct ve_info *ve)\n{\n\tstruct tdx_hypercall_args args = {\n\t\t.r10 = TDX_HYPERCALL_STANDARD,\n\t\t.r11 = hcall_func(EXIT_REASON_CPUID),\n\t\t.r12 = regs->ax,\n\t\t.r13 = regs->cx,\n\t};\n\n\t \n\tif (regs->ax < 0x40000000 || regs->ax > 0x4FFFFFFF) {\n\t\tregs->ax = regs->bx = regs->cx = regs->dx = 0;\n\t\treturn ve_instr_len(ve);\n\t}\n\n\t \n\tif (__tdx_hypercall_ret(&args))\n\t\treturn -EIO;\n\n\t \n\tregs->ax = args.r12;\n\tregs->bx = args.r13;\n\tregs->cx = args.r14;\n\tregs->dx = args.r15;\n\n\treturn ve_instr_len(ve);\n}\n\nstatic bool mmio_read(int size, unsigned long addr, unsigned long *val)\n{\n\tstruct tdx_hypercall_args args = {\n\t\t.r10 = TDX_HYPERCALL_STANDARD,\n\t\t.r11 = hcall_func(EXIT_REASON_EPT_VIOLATION),\n\t\t.r12 = size,\n\t\t.r13 = EPT_READ,\n\t\t.r14 = addr,\n\t\t.r15 = *val,\n\t};\n\n\tif (__tdx_hypercall_ret(&args))\n\t\treturn false;\n\t*val = args.r11;\n\treturn true;\n}\n\nstatic bool mmio_write(int size, unsigned long addr, unsigned long val)\n{\n\treturn !_tdx_hypercall(hcall_func(EXIT_REASON_EPT_VIOLATION), size,\n\t\t\t       EPT_WRITE, addr, val);\n}\n\nstatic int handle_mmio(struct pt_regs *regs, struct ve_info *ve)\n{\n\tunsigned long *reg, val, vaddr;\n\tchar buffer[MAX_INSN_SIZE];\n\tenum insn_mmio_type mmio;\n\tstruct insn insn = {};\n\tint size, extend_size;\n\tu8 extend_val = 0;\n\n\t \n\tif (WARN_ON_ONCE(user_mode(regs)))\n\t\treturn -EFAULT;\n\n\tif (copy_from_kernel_nofault(buffer, (void *)regs->ip, MAX_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\tif (insn_decode(&insn, buffer, MAX_INSN_SIZE, INSN_MODE_64))\n\t\treturn -EINVAL;\n\n\tmmio = insn_decode_mmio(&insn, &size);\n\tif (WARN_ON_ONCE(mmio == INSN_MMIO_DECODE_FAILED))\n\t\treturn -EINVAL;\n\n\tif (mmio != INSN_MMIO_WRITE_IMM && mmio != INSN_MMIO_MOVS) {\n\t\treg = insn_get_modrm_reg_ptr(&insn, regs);\n\t\tif (!reg)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tvaddr = (unsigned long)insn_get_addr_ref(&insn, regs);\n\tif (vaddr / PAGE_SIZE != (vaddr + size - 1) / PAGE_SIZE)\n\t\treturn -EFAULT;\n\n\t \n\tswitch (mmio) {\n\tcase INSN_MMIO_WRITE:\n\t\tmemcpy(&val, reg, size);\n\t\tif (!mmio_write(size, ve->gpa, val))\n\t\t\treturn -EIO;\n\t\treturn insn.length;\n\tcase INSN_MMIO_WRITE_IMM:\n\t\tval = insn.immediate.value;\n\t\tif (!mmio_write(size, ve->gpa, val))\n\t\t\treturn -EIO;\n\t\treturn insn.length;\n\tcase INSN_MMIO_READ:\n\tcase INSN_MMIO_READ_ZERO_EXTEND:\n\tcase INSN_MMIO_READ_SIGN_EXTEND:\n\t\t \n\t\tbreak;\n\tcase INSN_MMIO_MOVS:\n\tcase INSN_MMIO_DECODE_FAILED:\n\t\t \n\t\treturn -EINVAL;\n\tdefault:\n\t\tWARN_ONCE(1, \"Unknown insn_decode_mmio() decode value?\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!mmio_read(size, ve->gpa, &val))\n\t\treturn -EIO;\n\n\tswitch (mmio) {\n\tcase INSN_MMIO_READ:\n\t\t \n\t\textend_size = size == 4 ? sizeof(*reg) : 0;\n\t\tbreak;\n\tcase INSN_MMIO_READ_ZERO_EXTEND:\n\t\t \n\t\textend_size = insn.opnd_bytes;\n\t\tbreak;\n\tcase INSN_MMIO_READ_SIGN_EXTEND:\n\t\t \n\t\textend_size = insn.opnd_bytes;\n\t\tif (size == 1 && val & BIT(7))\n\t\t\textend_val = 0xFF;\n\t\telse if (size > 1 && val & BIT(15))\n\t\t\textend_val = 0xFF;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (extend_size)\n\t\tmemset(reg, extend_val, extend_size);\n\tmemcpy(reg, &val, size);\n\treturn insn.length;\n}\n\nstatic bool handle_in(struct pt_regs *regs, int size, int port)\n{\n\tstruct tdx_hypercall_args args = {\n\t\t.r10 = TDX_HYPERCALL_STANDARD,\n\t\t.r11 = hcall_func(EXIT_REASON_IO_INSTRUCTION),\n\t\t.r12 = size,\n\t\t.r13 = PORT_READ,\n\t\t.r14 = port,\n\t};\n\tu64 mask = GENMASK(BITS_PER_BYTE * size, 0);\n\tbool success;\n\n\t \n\tsuccess = !__tdx_hypercall_ret(&args);\n\n\t \n\tregs->ax &= ~mask;\n\tif (success)\n\t\tregs->ax |= args.r11 & mask;\n\n\treturn success;\n}\n\nstatic bool handle_out(struct pt_regs *regs, int size, int port)\n{\n\tu64 mask = GENMASK(BITS_PER_BYTE * size, 0);\n\n\t \n\treturn !_tdx_hypercall(hcall_func(EXIT_REASON_IO_INSTRUCTION), size,\n\t\t\t       PORT_WRITE, port, regs->ax & mask);\n}\n\n \nstatic int handle_io(struct pt_regs *regs, struct ve_info *ve)\n{\n\tu32 exit_qual = ve->exit_qual;\n\tint size, port;\n\tbool in, ret;\n\n\tif (VE_IS_IO_STRING(exit_qual))\n\t\treturn -EIO;\n\n\tin   = VE_IS_IO_IN(exit_qual);\n\tsize = VE_GET_IO_SIZE(exit_qual);\n\tport = VE_GET_PORT_NUM(exit_qual);\n\n\n\tif (in)\n\t\tret = handle_in(regs, size, port);\n\telse\n\t\tret = handle_out(regs, size, port);\n\tif (!ret)\n\t\treturn -EIO;\n\n\treturn ve_instr_len(ve);\n}\n\n \n__init bool tdx_early_handle_ve(struct pt_regs *regs)\n{\n\tstruct ve_info ve;\n\tint insn_len;\n\n\ttdx_get_ve_info(&ve);\n\n\tif (ve.exit_reason != EXIT_REASON_IO_INSTRUCTION)\n\t\treturn false;\n\n\tinsn_len = handle_io(regs, &ve);\n\tif (insn_len < 0)\n\t\treturn false;\n\n\tregs->ip += insn_len;\n\treturn true;\n}\n\nvoid tdx_get_ve_info(struct ve_info *ve)\n{\n\tstruct tdx_module_output out;\n\n\t \n\ttdx_module_call(TDX_GET_VEINFO, 0, 0, 0, 0, &out);\n\n\t \n\tve->exit_reason = out.rcx;\n\tve->exit_qual   = out.rdx;\n\tve->gla         = out.r8;\n\tve->gpa         = out.r9;\n\tve->instr_len   = lower_32_bits(out.r10);\n\tve->instr_info  = upper_32_bits(out.r10);\n}\n\n \nstatic int virt_exception_user(struct pt_regs *regs, struct ve_info *ve)\n{\n\tswitch (ve->exit_reason) {\n\tcase EXIT_REASON_CPUID:\n\t\treturn handle_cpuid(regs, ve);\n\tdefault:\n\t\tpr_warn(\"Unexpected #VE: %lld\\n\", ve->exit_reason);\n\t\treturn -EIO;\n\t}\n}\n\nstatic inline bool is_private_gpa(u64 gpa)\n{\n\treturn gpa == cc_mkenc(gpa);\n}\n\n \nstatic int virt_exception_kernel(struct pt_regs *regs, struct ve_info *ve)\n{\n\tswitch (ve->exit_reason) {\n\tcase EXIT_REASON_HLT:\n\t\treturn handle_halt(ve);\n\tcase EXIT_REASON_MSR_READ:\n\t\treturn read_msr(regs, ve);\n\tcase EXIT_REASON_MSR_WRITE:\n\t\treturn write_msr(regs, ve);\n\tcase EXIT_REASON_CPUID:\n\t\treturn handle_cpuid(regs, ve);\n\tcase EXIT_REASON_EPT_VIOLATION:\n\t\tif (is_private_gpa(ve->gpa))\n\t\t\tpanic(\"Unexpected EPT-violation on private memory.\");\n\t\treturn handle_mmio(regs, ve);\n\tcase EXIT_REASON_IO_INSTRUCTION:\n\t\treturn handle_io(regs, ve);\n\tdefault:\n\t\tpr_warn(\"Unexpected #VE: %lld\\n\", ve->exit_reason);\n\t\treturn -EIO;\n\t}\n}\n\nbool tdx_handle_virt_exception(struct pt_regs *regs, struct ve_info *ve)\n{\n\tint insn_len;\n\n\tif (user_mode(regs))\n\t\tinsn_len = virt_exception_user(regs, ve);\n\telse\n\t\tinsn_len = virt_exception_kernel(regs, ve);\n\tif (insn_len < 0)\n\t\treturn false;\n\n\t \n\tregs->ip += insn_len;\n\n\treturn true;\n}\n\nstatic bool tdx_tlb_flush_required(bool private)\n{\n\t \n\treturn !private;\n}\n\nstatic bool tdx_cache_flush_required(void)\n{\n\t \n\treturn true;\n}\n\n \nstatic bool tdx_enc_status_changed(unsigned long vaddr, int numpages, bool enc)\n{\n\tphys_addr_t start = __pa(vaddr);\n\tphys_addr_t end   = __pa(vaddr + numpages * PAGE_SIZE);\n\n\tif (!enc) {\n\t\t \n\t\tstart |= cc_mkdec(0);\n\t\tend   |= cc_mkdec(0);\n\t}\n\n\t \n\tif (_tdx_hypercall(TDVMCALL_MAP_GPA, start, end - start, 0, 0))\n\t\treturn false;\n\n\t \n\tif (enc)\n\t\treturn tdx_accept_memory(start, end);\n\n\treturn true;\n}\n\nstatic bool tdx_enc_status_change_prepare(unsigned long vaddr, int numpages,\n\t\t\t\t\t  bool enc)\n{\n\t \n\tif (enc)\n\t\treturn tdx_enc_status_changed(vaddr, numpages, enc);\n\treturn true;\n}\n\nstatic bool tdx_enc_status_change_finish(unsigned long vaddr, int numpages,\n\t\t\t\t\t bool enc)\n{\n\t \n\tif (!enc)\n\t\treturn tdx_enc_status_changed(vaddr, numpages, enc);\n\treturn true;\n}\n\nvoid __init tdx_early_init(void)\n{\n\tu64 cc_mask;\n\tu32 eax, sig[3];\n\n\tcpuid_count(TDX_CPUID_LEAF_ID, 0, &eax, &sig[0], &sig[2],  &sig[1]);\n\n\tif (memcmp(TDX_IDENT, sig, sizeof(sig)))\n\t\treturn;\n\n\tsetup_force_cpu_cap(X86_FEATURE_TDX_GUEST);\n\n\tcc_vendor = CC_VENDOR_INTEL;\n\ttdx_parse_tdinfo(&cc_mask);\n\tcc_set_mask(cc_mask);\n\n\t \n\ttdx_module_call(TDX_WR, 0, TDCS_NOTIFY_ENABLES, 0, -1ULL, NULL);\n\n\t \n\tphysical_mask &= cc_mask - 1;\n\n\t \n\tx86_platform.guest.enc_status_change_prepare = tdx_enc_status_change_prepare;\n\tx86_platform.guest.enc_status_change_finish  = tdx_enc_status_change_finish;\n\n\tx86_platform.guest.enc_cache_flush_required  = tdx_cache_flush_required;\n\tx86_platform.guest.enc_tlb_flush_required    = tdx_tlb_flush_required;\n\n\t \n\tx86_cpuinit.parallel_bringup = false;\n\n\tpr_info(\"Guest detected\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}