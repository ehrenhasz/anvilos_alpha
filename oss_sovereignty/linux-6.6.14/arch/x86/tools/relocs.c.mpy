{
  "module_name": "relocs.c",
  "hash_id": "dd7b59f54bea417ed781e005b63a9f8bc9bd544c7c08dba5114f8cc210a88b1b",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/tools/relocs.c",
  "human_readable_source": "\n \n\n#define ElfW(type)\t\t_ElfW(ELF_BITS, type)\n#define _ElfW(bits, type)\t__ElfW(bits, type)\n#define __ElfW(bits, type)\tElf##bits##_##type\n\n#define Elf_Addr\t\tElfW(Addr)\n#define Elf_Ehdr\t\tElfW(Ehdr)\n#define Elf_Phdr\t\tElfW(Phdr)\n#define Elf_Shdr\t\tElfW(Shdr)\n#define Elf_Sym\t\t\tElfW(Sym)\n\nstatic Elf_Ehdr\t\tehdr;\nstatic unsigned long\tshnum;\nstatic unsigned int\tshstrndx;\nstatic unsigned int\tshsymtabndx;\nstatic unsigned int\tshxsymtabndx;\n\nstatic int sym_index(Elf_Sym *sym);\n\nstruct relocs {\n\tuint32_t\t*offset;\n\tunsigned long\tcount;\n\tunsigned long\tsize;\n};\n\nstatic struct relocs relocs16;\nstatic struct relocs relocs32;\n#if ELF_BITS == 64\nstatic struct relocs relocs32neg;\nstatic struct relocs relocs64;\n#define FMT PRIu64\n#else\n#define FMT PRIu32\n#endif\n\nstruct section {\n\tElf_Shdr       shdr;\n\tstruct section *link;\n\tElf_Sym        *symtab;\n\tElf32_Word     *xsymtab;\n\tElf_Rel        *reltab;\n\tchar           *strtab;\n};\nstatic struct section *secs;\n\nstatic const char * const sym_regex_kernel[S_NSYMTYPES] = {\n \n\t[S_ABS] =\n\t\"^(xen_irq_disable_direct_reloc$|\"\n\t\"xen_save_fl_direct_reloc$|\"\n\t\"VDSO|\"\n\t\"__kcfi_typeid_|\"\n\t\"__crc_)\",\n\n \n\t[S_REL] =\n\t\"^(__init_(begin|end)|\"\n\t\"__x86_cpu_dev_(start|end)|\"\n\t\"(__parainstructions|__alt_instructions)(_end)?|\"\n\t\"(__iommu_table|__apicdrivers|__smp_locks)(_end)?|\"\n\t\"__(start|end)_pci_.*|\"\n#if CONFIG_FW_LOADER\n\t\"__(start|end)_builtin_fw|\"\n#endif\n\t\"__(start|stop)___ksymtab(_gpl)?|\"\n\t\"__(start|stop)___kcrctab(_gpl)?|\"\n\t\"__(start|stop)___param|\"\n\t\"__(start|stop)___modver|\"\n\t\"__(start|stop)___bug_table|\"\n\t\"__tracedata_(start|end)|\"\n\t\"__(start|stop)_notes|\"\n\t\"__end_rodata|\"\n\t\"__end_rodata_aligned|\"\n\t\"__initramfs_start|\"\n\t\"(jiffies|jiffies_64)|\"\n#if ELF_BITS == 64\n\t\"__per_cpu_load|\"\n\t\"init_per_cpu__.*|\"\n\t\"__end_rodata_hpage_align|\"\n#endif\n\t\"__vvar_page|\"\n\t\"_end)$\"\n};\n\n\nstatic const char * const sym_regex_realmode[S_NSYMTYPES] = {\n \n\t[S_REL] =\n\t\"^pa_\",\n\n \n\t[S_SEG] =\n\t\"^real_mode_seg$\",\n\n \n\t[S_LIN] =\n\t\"^pa_\",\n};\n\nstatic const char * const *sym_regex;\n\nstatic regex_t sym_regex_c[S_NSYMTYPES];\nstatic int is_reloc(enum symtype type, const char *sym_name)\n{\n\treturn sym_regex[type] &&\n\t\t!regexec(&sym_regex_c[type], sym_name, 0, NULL, 0);\n}\n\nstatic void regex_init(int use_real_mode)\n{\n        char errbuf[128];\n        int err;\n\tint i;\n\n\tif (use_real_mode)\n\t\tsym_regex = sym_regex_realmode;\n\telse\n\t\tsym_regex = sym_regex_kernel;\n\n\tfor (i = 0; i < S_NSYMTYPES; i++) {\n\t\tif (!sym_regex[i])\n\t\t\tcontinue;\n\n\t\terr = regcomp(&sym_regex_c[i], sym_regex[i],\n\t\t\t      REG_EXTENDED|REG_NOSUB);\n\n\t\tif (err) {\n\t\t\tregerror(err, &sym_regex_c[i], errbuf, sizeof(errbuf));\n\t\t\tdie(\"%s\", errbuf);\n\t\t}\n        }\n}\n\nstatic const char *sym_type(unsigned type)\n{\n\tstatic const char *type_name[] = {\n#define SYM_TYPE(X) [X] = #X\n\t\tSYM_TYPE(STT_NOTYPE),\n\t\tSYM_TYPE(STT_OBJECT),\n\t\tSYM_TYPE(STT_FUNC),\n\t\tSYM_TYPE(STT_SECTION),\n\t\tSYM_TYPE(STT_FILE),\n\t\tSYM_TYPE(STT_COMMON),\n\t\tSYM_TYPE(STT_TLS),\n#undef SYM_TYPE\n\t};\n\tconst char *name = \"unknown sym type name\";\n\tif (type < ARRAY_SIZE(type_name)) {\n\t\tname = type_name[type];\n\t}\n\treturn name;\n}\n\nstatic const char *sym_bind(unsigned bind)\n{\n\tstatic const char *bind_name[] = {\n#define SYM_BIND(X) [X] = #X\n\t\tSYM_BIND(STB_LOCAL),\n\t\tSYM_BIND(STB_GLOBAL),\n\t\tSYM_BIND(STB_WEAK),\n#undef SYM_BIND\n\t};\n\tconst char *name = \"unknown sym bind name\";\n\tif (bind < ARRAY_SIZE(bind_name)) {\n\t\tname = bind_name[bind];\n\t}\n\treturn name;\n}\n\nstatic const char *sym_visibility(unsigned visibility)\n{\n\tstatic const char *visibility_name[] = {\n#define SYM_VISIBILITY(X) [X] = #X\n\t\tSYM_VISIBILITY(STV_DEFAULT),\n\t\tSYM_VISIBILITY(STV_INTERNAL),\n\t\tSYM_VISIBILITY(STV_HIDDEN),\n\t\tSYM_VISIBILITY(STV_PROTECTED),\n#undef SYM_VISIBILITY\n\t};\n\tconst char *name = \"unknown sym visibility name\";\n\tif (visibility < ARRAY_SIZE(visibility_name)) {\n\t\tname = visibility_name[visibility];\n\t}\n\treturn name;\n}\n\nstatic const char *rel_type(unsigned type)\n{\n\tstatic const char *type_name[] = {\n#define REL_TYPE(X) [X] = #X\n#if ELF_BITS == 64\n\t\tREL_TYPE(R_X86_64_NONE),\n\t\tREL_TYPE(R_X86_64_64),\n\t\tREL_TYPE(R_X86_64_PC64),\n\t\tREL_TYPE(R_X86_64_PC32),\n\t\tREL_TYPE(R_X86_64_GOT32),\n\t\tREL_TYPE(R_X86_64_PLT32),\n\t\tREL_TYPE(R_X86_64_COPY),\n\t\tREL_TYPE(R_X86_64_GLOB_DAT),\n\t\tREL_TYPE(R_X86_64_JUMP_SLOT),\n\t\tREL_TYPE(R_X86_64_RELATIVE),\n\t\tREL_TYPE(R_X86_64_GOTPCREL),\n\t\tREL_TYPE(R_X86_64_32),\n\t\tREL_TYPE(R_X86_64_32S),\n\t\tREL_TYPE(R_X86_64_16),\n\t\tREL_TYPE(R_X86_64_PC16),\n\t\tREL_TYPE(R_X86_64_8),\n\t\tREL_TYPE(R_X86_64_PC8),\n#else\n\t\tREL_TYPE(R_386_NONE),\n\t\tREL_TYPE(R_386_32),\n\t\tREL_TYPE(R_386_PC32),\n\t\tREL_TYPE(R_386_GOT32),\n\t\tREL_TYPE(R_386_PLT32),\n\t\tREL_TYPE(R_386_COPY),\n\t\tREL_TYPE(R_386_GLOB_DAT),\n\t\tREL_TYPE(R_386_JMP_SLOT),\n\t\tREL_TYPE(R_386_RELATIVE),\n\t\tREL_TYPE(R_386_GOTOFF),\n\t\tREL_TYPE(R_386_GOTPC),\n\t\tREL_TYPE(R_386_8),\n\t\tREL_TYPE(R_386_PC8),\n\t\tREL_TYPE(R_386_16),\n\t\tREL_TYPE(R_386_PC16),\n#endif\n#undef REL_TYPE\n\t};\n\tconst char *name = \"unknown type rel type name\";\n\tif (type < ARRAY_SIZE(type_name) && type_name[type]) {\n\t\tname = type_name[type];\n\t}\n\treturn name;\n}\n\nstatic const char *sec_name(unsigned shndx)\n{\n\tconst char *sec_strtab;\n\tconst char *name;\n\tsec_strtab = secs[shstrndx].strtab;\n\tname = \"<noname>\";\n\tif (shndx < shnum) {\n\t\tname = sec_strtab + secs[shndx].shdr.sh_name;\n\t}\n\telse if (shndx == SHN_ABS) {\n\t\tname = \"ABSOLUTE\";\n\t}\n\telse if (shndx == SHN_COMMON) {\n\t\tname = \"COMMON\";\n\t}\n\treturn name;\n}\n\nstatic const char *sym_name(const char *sym_strtab, Elf_Sym *sym)\n{\n\tconst char *name;\n\tname = \"<noname>\";\n\tif (sym->st_name) {\n\t\tname = sym_strtab + sym->st_name;\n\t}\n\telse {\n\t\tname = sec_name(sym_index(sym));\n\t}\n\treturn name;\n}\n\nstatic Elf_Sym *sym_lookup(const char *symname)\n{\n\tint i;\n\tfor (i = 0; i < shnum; i++) {\n\t\tstruct section *sec = &secs[i];\n\t\tlong nsyms;\n\t\tchar *strtab;\n\t\tElf_Sym *symtab;\n\t\tElf_Sym *sym;\n\n\t\tif (sec->shdr.sh_type != SHT_SYMTAB)\n\t\t\tcontinue;\n\n\t\tnsyms = sec->shdr.sh_size/sizeof(Elf_Sym);\n\t\tsymtab = sec->symtab;\n\t\tstrtab = sec->link->strtab;\n\n\t\tfor (sym = symtab; --nsyms >= 0; sym++) {\n\t\t\tif (!sym->st_name)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(symname, strtab + sym->st_name) == 0)\n\t\t\t\treturn sym;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#if BYTE_ORDER == LITTLE_ENDIAN\n#define le16_to_cpu(val) (val)\n#define le32_to_cpu(val) (val)\n#define le64_to_cpu(val) (val)\n#endif\n#if BYTE_ORDER == BIG_ENDIAN\n#define le16_to_cpu(val) bswap_16(val)\n#define le32_to_cpu(val) bswap_32(val)\n#define le64_to_cpu(val) bswap_64(val)\n#endif\n\nstatic uint16_t elf16_to_cpu(uint16_t val)\n{\n\treturn le16_to_cpu(val);\n}\n\nstatic uint32_t elf32_to_cpu(uint32_t val)\n{\n\treturn le32_to_cpu(val);\n}\n\n#define elf_half_to_cpu(x)\telf16_to_cpu(x)\n#define elf_word_to_cpu(x)\telf32_to_cpu(x)\n\n#if ELF_BITS == 64\nstatic uint64_t elf64_to_cpu(uint64_t val)\n{\n        return le64_to_cpu(val);\n}\n#define elf_addr_to_cpu(x)\telf64_to_cpu(x)\n#define elf_off_to_cpu(x)\telf64_to_cpu(x)\n#define elf_xword_to_cpu(x)\telf64_to_cpu(x)\n#else\n#define elf_addr_to_cpu(x)\telf32_to_cpu(x)\n#define elf_off_to_cpu(x)\telf32_to_cpu(x)\n#define elf_xword_to_cpu(x)\telf32_to_cpu(x)\n#endif\n\nstatic int sym_index(Elf_Sym *sym)\n{\n\tElf_Sym *symtab = secs[shsymtabndx].symtab;\n\tElf32_Word *xsymtab = secs[shxsymtabndx].xsymtab;\n\tunsigned long offset;\n\tint index;\n\n\tif (sym->st_shndx != SHN_XINDEX)\n\t\treturn sym->st_shndx;\n\n\t \n\toffset = (unsigned long)sym - (unsigned long)symtab;\n\tindex = offset / sizeof(*sym);\n\n\treturn elf32_to_cpu(xsymtab[index]);\n}\n\nstatic void read_ehdr(FILE *fp)\n{\n\tif (fread(&ehdr, sizeof(ehdr), 1, fp) != 1) {\n\t\tdie(\"Cannot read ELF header: %s\\n\",\n\t\t\tstrerror(errno));\n\t}\n\tif (memcmp(ehdr.e_ident, ELFMAG, SELFMAG) != 0) {\n\t\tdie(\"No ELF magic\\n\");\n\t}\n\tif (ehdr.e_ident[EI_CLASS] != ELF_CLASS) {\n\t\tdie(\"Not a %d bit executable\\n\", ELF_BITS);\n\t}\n\tif (ehdr.e_ident[EI_DATA] != ELFDATA2LSB) {\n\t\tdie(\"Not a LSB ELF executable\\n\");\n\t}\n\tif (ehdr.e_ident[EI_VERSION] != EV_CURRENT) {\n\t\tdie(\"Unknown ELF version\\n\");\n\t}\n\t \n\tehdr.e_type      = elf_half_to_cpu(ehdr.e_type);\n\tehdr.e_machine   = elf_half_to_cpu(ehdr.e_machine);\n\tehdr.e_version   = elf_word_to_cpu(ehdr.e_version);\n\tehdr.e_entry     = elf_addr_to_cpu(ehdr.e_entry);\n\tehdr.e_phoff     = elf_off_to_cpu(ehdr.e_phoff);\n\tehdr.e_shoff     = elf_off_to_cpu(ehdr.e_shoff);\n\tehdr.e_flags     = elf_word_to_cpu(ehdr.e_flags);\n\tehdr.e_ehsize    = elf_half_to_cpu(ehdr.e_ehsize);\n\tehdr.e_phentsize = elf_half_to_cpu(ehdr.e_phentsize);\n\tehdr.e_phnum     = elf_half_to_cpu(ehdr.e_phnum);\n\tehdr.e_shentsize = elf_half_to_cpu(ehdr.e_shentsize);\n\tehdr.e_shnum     = elf_half_to_cpu(ehdr.e_shnum);\n\tehdr.e_shstrndx  = elf_half_to_cpu(ehdr.e_shstrndx);\n\n\tshnum = ehdr.e_shnum;\n\tshstrndx = ehdr.e_shstrndx;\n\n\tif ((ehdr.e_type != ET_EXEC) && (ehdr.e_type != ET_DYN))\n\t\tdie(\"Unsupported ELF header type\\n\");\n\tif (ehdr.e_machine != ELF_MACHINE)\n\t\tdie(\"Not for %s\\n\", ELF_MACHINE_NAME);\n\tif (ehdr.e_version != EV_CURRENT)\n\t\tdie(\"Unknown ELF version\\n\");\n\tif (ehdr.e_ehsize != sizeof(Elf_Ehdr))\n\t\tdie(\"Bad ELF header size\\n\");\n\tif (ehdr.e_phentsize != sizeof(Elf_Phdr))\n\t\tdie(\"Bad program header entry\\n\");\n\tif (ehdr.e_shentsize != sizeof(Elf_Shdr))\n\t\tdie(\"Bad section header entry\\n\");\n\n\n\tif (shnum == SHN_UNDEF || shstrndx == SHN_XINDEX) {\n\t\tElf_Shdr shdr;\n\n\t\tif (fseek(fp, ehdr.e_shoff, SEEK_SET) < 0)\n\t\t\tdie(\"Seek to %\" FMT \" failed: %s\\n\", ehdr.e_shoff, strerror(errno));\n\n\t\tif (fread(&shdr, sizeof(shdr), 1, fp) != 1)\n\t\t\tdie(\"Cannot read initial ELF section header: %s\\n\", strerror(errno));\n\n\t\tif (shnum == SHN_UNDEF)\n\t\t\tshnum = elf_xword_to_cpu(shdr.sh_size);\n\n\t\tif (shstrndx == SHN_XINDEX)\n\t\t\tshstrndx = elf_word_to_cpu(shdr.sh_link);\n\t}\n\n\tif (shstrndx >= shnum)\n\t\tdie(\"String table index out of bounds\\n\");\n}\n\nstatic void read_shdrs(FILE *fp)\n{\n\tint i;\n\tElf_Shdr shdr;\n\n\tsecs = calloc(shnum, sizeof(struct section));\n\tif (!secs) {\n\t\tdie(\"Unable to allocate %ld section headers\\n\",\n\t\t    shnum);\n\t}\n\tif (fseek(fp, ehdr.e_shoff, SEEK_SET) < 0) {\n\t\tdie(\"Seek to %\" FMT \" failed: %s\\n\",\n\t\t    ehdr.e_shoff, strerror(errno));\n\t}\n\tfor (i = 0; i < shnum; i++) {\n\t\tstruct section *sec = &secs[i];\n\t\tif (fread(&shdr, sizeof(shdr), 1, fp) != 1)\n\t\t\tdie(\"Cannot read ELF section headers %d/%ld: %s\\n\",\n\t\t\t    i, shnum, strerror(errno));\n\t\tsec->shdr.sh_name      = elf_word_to_cpu(shdr.sh_name);\n\t\tsec->shdr.sh_type      = elf_word_to_cpu(shdr.sh_type);\n\t\tsec->shdr.sh_flags     = elf_xword_to_cpu(shdr.sh_flags);\n\t\tsec->shdr.sh_addr      = elf_addr_to_cpu(shdr.sh_addr);\n\t\tsec->shdr.sh_offset    = elf_off_to_cpu(shdr.sh_offset);\n\t\tsec->shdr.sh_size      = elf_xword_to_cpu(shdr.sh_size);\n\t\tsec->shdr.sh_link      = elf_word_to_cpu(shdr.sh_link);\n\t\tsec->shdr.sh_info      = elf_word_to_cpu(shdr.sh_info);\n\t\tsec->shdr.sh_addralign = elf_xword_to_cpu(shdr.sh_addralign);\n\t\tsec->shdr.sh_entsize   = elf_xword_to_cpu(shdr.sh_entsize);\n\t\tif (sec->shdr.sh_link < shnum)\n\t\t\tsec->link = &secs[sec->shdr.sh_link];\n\t}\n\n}\n\nstatic void read_strtabs(FILE *fp)\n{\n\tint i;\n\tfor (i = 0; i < shnum; i++) {\n\t\tstruct section *sec = &secs[i];\n\t\tif (sec->shdr.sh_type != SHT_STRTAB) {\n\t\t\tcontinue;\n\t\t}\n\t\tsec->strtab = malloc(sec->shdr.sh_size);\n\t\tif (!sec->strtab) {\n\t\t\tdie(\"malloc of %\" FMT \" bytes for strtab failed\\n\",\n\t\t\t    sec->shdr.sh_size);\n\t\t}\n\t\tif (fseek(fp, sec->shdr.sh_offset, SEEK_SET) < 0) {\n\t\t\tdie(\"Seek to %\" FMT \" failed: %s\\n\",\n\t\t\t    sec->shdr.sh_offset, strerror(errno));\n\t\t}\n\t\tif (fread(sec->strtab, 1, sec->shdr.sh_size, fp)\n\t\t    != sec->shdr.sh_size) {\n\t\t\tdie(\"Cannot read symbol table: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\t}\n\t}\n}\n\nstatic void read_symtabs(FILE *fp)\n{\n\tint i,j;\n\n\tfor (i = 0; i < shnum; i++) {\n\t\tstruct section *sec = &secs[i];\n\t\tint num_syms;\n\n\t\tswitch (sec->shdr.sh_type) {\n\t\tcase SHT_SYMTAB_SHNDX:\n\t\t\tsec->xsymtab = malloc(sec->shdr.sh_size);\n\t\t\tif (!sec->xsymtab) {\n\t\t\t\tdie(\"malloc of %\" FMT \" bytes for xsymtab failed\\n\",\n\t\t\t\t    sec->shdr.sh_size);\n\t\t\t}\n\t\t\tif (fseek(fp, sec->shdr.sh_offset, SEEK_SET) < 0) {\n\t\t\t\tdie(\"Seek to %\" FMT \" failed: %s\\n\",\n\t\t\t\t    sec->shdr.sh_offset, strerror(errno));\n\t\t\t}\n\t\t\tif (fread(sec->xsymtab, 1, sec->shdr.sh_size, fp)\n\t\t\t    != sec->shdr.sh_size) {\n\t\t\t\tdie(\"Cannot read extended symbol table: %s\\n\",\n\t\t\t\t    strerror(errno));\n\t\t\t}\n\t\t\tshxsymtabndx = i;\n\t\t\tcontinue;\n\n\t\tcase SHT_SYMTAB:\n\t\t\tnum_syms = sec->shdr.sh_size / sizeof(Elf_Sym);\n\n\t\t\tsec->symtab = malloc(sec->shdr.sh_size);\n\t\t\tif (!sec->symtab) {\n\t\t\t\tdie(\"malloc of %\" FMT \" bytes for symtab failed\\n\",\n\t\t\t\t    sec->shdr.sh_size);\n\t\t\t}\n\t\t\tif (fseek(fp, sec->shdr.sh_offset, SEEK_SET) < 0) {\n\t\t\t\tdie(\"Seek to %\" FMT \" failed: %s\\n\",\n\t\t\t\t    sec->shdr.sh_offset, strerror(errno));\n\t\t\t}\n\t\t\tif (fread(sec->symtab, 1, sec->shdr.sh_size, fp)\n\t\t\t    != sec->shdr.sh_size) {\n\t\t\t\tdie(\"Cannot read symbol table: %s\\n\",\n\t\t\t\t    strerror(errno));\n\t\t\t}\n\t\t\tfor (j = 0; j < num_syms; j++) {\n\t\t\t\tElf_Sym *sym = &sec->symtab[j];\n\n\t\t\t\tsym->st_name  = elf_word_to_cpu(sym->st_name);\n\t\t\t\tsym->st_value = elf_addr_to_cpu(sym->st_value);\n\t\t\t\tsym->st_size  = elf_xword_to_cpu(sym->st_size);\n\t\t\t\tsym->st_shndx = elf_half_to_cpu(sym->st_shndx);\n\t\t\t}\n\t\t\tshsymtabndx = i;\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\n\nstatic void read_relocs(FILE *fp)\n{\n\tint i,j;\n\tfor (i = 0; i < shnum; i++) {\n\t\tstruct section *sec = &secs[i];\n\t\tif (sec->shdr.sh_type != SHT_REL_TYPE) {\n\t\t\tcontinue;\n\t\t}\n\t\tsec->reltab = malloc(sec->shdr.sh_size);\n\t\tif (!sec->reltab) {\n\t\t\tdie(\"malloc of %\" FMT \" bytes for relocs failed\\n\",\n\t\t\t    sec->shdr.sh_size);\n\t\t}\n\t\tif (fseek(fp, sec->shdr.sh_offset, SEEK_SET) < 0) {\n\t\t\tdie(\"Seek to %\" FMT \" failed: %s\\n\",\n\t\t\t    sec->shdr.sh_offset, strerror(errno));\n\t\t}\n\t\tif (fread(sec->reltab, 1, sec->shdr.sh_size, fp)\n\t\t    != sec->shdr.sh_size) {\n\t\t\tdie(\"Cannot read symbol table: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\t}\n\t\tfor (j = 0; j < sec->shdr.sh_size/sizeof(Elf_Rel); j++) {\n\t\t\tElf_Rel *rel = &sec->reltab[j];\n\t\t\trel->r_offset = elf_addr_to_cpu(rel->r_offset);\n\t\t\trel->r_info   = elf_xword_to_cpu(rel->r_info);\n#if (SHT_REL_TYPE == SHT_RELA)\n\t\t\trel->r_addend = elf_xword_to_cpu(rel->r_addend);\n#endif\n\t\t}\n\t}\n}\n\n\nstatic void print_absolute_symbols(void)\n{\n\tint i;\n\tconst char *format;\n\n\tif (ELF_BITS == 64)\n\t\tformat = \"%5d %016\"PRIx64\" %5\"PRId64\" %10s %10s %12s %s\\n\";\n\telse\n\t\tformat = \"%5d %08\"PRIx32\"  %5\"PRId32\" %10s %10s %12s %s\\n\";\n\n\tprintf(\"Absolute symbols\\n\");\n\tprintf(\" Num:    Value Size  Type       Bind        Visibility  Name\\n\");\n\tfor (i = 0; i < shnum; i++) {\n\t\tstruct section *sec = &secs[i];\n\t\tchar *sym_strtab;\n\t\tint j;\n\n\t\tif (sec->shdr.sh_type != SHT_SYMTAB) {\n\t\t\tcontinue;\n\t\t}\n\t\tsym_strtab = sec->link->strtab;\n\t\tfor (j = 0; j < sec->shdr.sh_size/sizeof(Elf_Sym); j++) {\n\t\t\tElf_Sym *sym;\n\t\t\tconst char *name;\n\t\t\tsym = &sec->symtab[j];\n\t\t\tname = sym_name(sym_strtab, sym);\n\t\t\tif (sym->st_shndx != SHN_ABS) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprintf(format,\n\t\t\t\tj, sym->st_value, sym->st_size,\n\t\t\t\tsym_type(ELF_ST_TYPE(sym->st_info)),\n\t\t\t\tsym_bind(ELF_ST_BIND(sym->st_info)),\n\t\t\t\tsym_visibility(ELF_ST_VISIBILITY(sym->st_other)),\n\t\t\t\tname);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}\n\nstatic void print_absolute_relocs(void)\n{\n\tint i, printed = 0;\n\tconst char *format;\n\n\tif (ELF_BITS == 64)\n\t\tformat = \"%016\"PRIx64\" %016\"PRIx64\" %10s %016\"PRIx64\"  %s\\n\";\n\telse\n\t\tformat = \"%08\"PRIx32\" %08\"PRIx32\" %10s %08\"PRIx32\"  %s\\n\";\n\n\tfor (i = 0; i < shnum; i++) {\n\t\tstruct section *sec = &secs[i];\n\t\tstruct section *sec_applies, *sec_symtab;\n\t\tchar *sym_strtab;\n\t\tElf_Sym *sh_symtab;\n\t\tint j;\n\t\tif (sec->shdr.sh_type != SHT_REL_TYPE) {\n\t\t\tcontinue;\n\t\t}\n\t\tsec_symtab  = sec->link;\n\t\tsec_applies = &secs[sec->shdr.sh_info];\n\t\tif (!(sec_applies->shdr.sh_flags & SHF_ALLOC)) {\n\t\t\tcontinue;\n\t\t}\n\t\tsh_symtab  = sec_symtab->symtab;\n\t\tsym_strtab = sec_symtab->link->strtab;\n\t\tfor (j = 0; j < sec->shdr.sh_size/sizeof(Elf_Rel); j++) {\n\t\t\tElf_Rel *rel;\n\t\t\tElf_Sym *sym;\n\t\t\tconst char *name;\n\t\t\trel = &sec->reltab[j];\n\t\t\tsym = &sh_symtab[ELF_R_SYM(rel->r_info)];\n\t\t\tname = sym_name(sym_strtab, sym);\n\t\t\tif (sym->st_shndx != SHN_ABS) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (is_reloc(S_ABS, name) || is_reloc(S_REL, name))\n\t\t\t\tcontinue;\n\n\t\t\tif (!printed) {\n\t\t\t\tprintf(\"WARNING: Absolute relocations\"\n\t\t\t\t\t\" present\\n\");\n\t\t\t\tprintf(\"Offset     Info     Type     Sym.Value \"\n\t\t\t\t\t\"Sym.Name\\n\");\n\t\t\t\tprinted = 1;\n\t\t\t}\n\n\t\t\tprintf(format,\n\t\t\t\trel->r_offset,\n\t\t\t\trel->r_info,\n\t\t\t\trel_type(ELF_R_TYPE(rel->r_info)),\n\t\t\t\tsym->st_value,\n\t\t\t\tname);\n\t\t}\n\t}\n\n\tif (printed)\n\t\tprintf(\"\\n\");\n}\n\nstatic void add_reloc(struct relocs *r, uint32_t offset)\n{\n\tif (r->count == r->size) {\n\t\tunsigned long newsize = r->size + 50000;\n\t\tvoid *mem = realloc(r->offset, newsize * sizeof(r->offset[0]));\n\n\t\tif (!mem)\n\t\t\tdie(\"realloc of %ld entries for relocs failed\\n\",\n                                newsize);\n\t\tr->offset = mem;\n\t\tr->size = newsize;\n\t}\n\tr->offset[r->count++] = offset;\n}\n\nstatic void walk_relocs(int (*process)(struct section *sec, Elf_Rel *rel,\n\t\t\tElf_Sym *sym, const char *symname))\n{\n\tint i;\n\t \n\tfor (i = 0; i < shnum; i++) {\n\t\tchar *sym_strtab;\n\t\tElf_Sym *sh_symtab;\n\t\tstruct section *sec_applies, *sec_symtab;\n\t\tint j;\n\t\tstruct section *sec = &secs[i];\n\n\t\tif (sec->shdr.sh_type != SHT_REL_TYPE) {\n\t\t\tcontinue;\n\t\t}\n\t\tsec_symtab  = sec->link;\n\t\tsec_applies = &secs[sec->shdr.sh_info];\n\t\tif (!(sec_applies->shdr.sh_flags & SHF_ALLOC)) {\n\t\t\tcontinue;\n\t\t}\n\t\tsh_symtab = sec_symtab->symtab;\n\t\tsym_strtab = sec_symtab->link->strtab;\n\t\tfor (j = 0; j < sec->shdr.sh_size/sizeof(Elf_Rel); j++) {\n\t\t\tElf_Rel *rel = &sec->reltab[j];\n\t\t\tElf_Sym *sym = &sh_symtab[ELF_R_SYM(rel->r_info)];\n\t\t\tconst char *symname = sym_name(sym_strtab, sym);\n\n\t\t\tprocess(sec, rel, sym, symname);\n\t\t}\n\t}\n}\n\n \nstatic int per_cpu_shndx\t= -1;\nstatic Elf_Addr per_cpu_load_addr;\n\nstatic void percpu_init(void)\n{\n\tint i;\n\tfor (i = 0; i < shnum; i++) {\n\t\tElfW(Sym) *sym;\n\t\tif (strcmp(sec_name(i), \".data..percpu\"))\n\t\t\tcontinue;\n\n\t\tif (secs[i].shdr.sh_addr != 0)\t \n\t\t\treturn;\n\n\t\tsym = sym_lookup(\"__per_cpu_load\");\n\t\tif (!sym)\n\t\t\tdie(\"can't find __per_cpu_load\\n\");\n\n\t\tper_cpu_shndx = i;\n\t\tper_cpu_load_addr = sym->st_value;\n\t\treturn;\n\t}\n}\n\n#if ELF_BITS == 64\n\n \nstatic int is_percpu_sym(ElfW(Sym) *sym, const char *symname)\n{\n\tint shndx = sym_index(sym);\n\n\treturn (shndx == per_cpu_shndx) &&\n\t\tstrcmp(symname, \"__init_begin\") &&\n\t\tstrcmp(symname, \"__per_cpu_load\") &&\n\t\tstrncmp(symname, \"init_per_cpu_\", 13);\n}\n\n\nstatic int do_reloc64(struct section *sec, Elf_Rel *rel, ElfW(Sym) *sym,\n\t\t      const char *symname)\n{\n\tunsigned r_type = ELF64_R_TYPE(rel->r_info);\n\tElfW(Addr) offset = rel->r_offset;\n\tint shn_abs = (sym->st_shndx == SHN_ABS) && !is_reloc(S_REL, symname);\n\n\tif (sym->st_shndx == SHN_UNDEF)\n\t\treturn 0;\n\n\t \n\tif (sec->shdr.sh_info == per_cpu_shndx)\n\t\toffset += per_cpu_load_addr;\n\n\tswitch (r_type) {\n\tcase R_X86_64_NONE:\n\t\t \n\t\tbreak;\n\n\tcase R_X86_64_PC32:\n\tcase R_X86_64_PLT32:\n\t\t \n\t\tif (is_percpu_sym(sym, symname))\n\t\t\tadd_reloc(&relocs32neg, offset);\n\t\tbreak;\n\n\tcase R_X86_64_PC64:\n\t\t \n\t\tif (is_percpu_sym(sym, symname))\n\t\t\tdie(\"Invalid R_X86_64_PC64 relocation against per-CPU symbol %s\\n\",\n\t\t\t    symname);\n\t\tbreak;\n\n\tcase R_X86_64_32:\n\tcase R_X86_64_32S:\n\tcase R_X86_64_64:\n\t\t \n\t\tif (is_percpu_sym(sym, symname))\n\t\t\tbreak;\n\n\t\tif (shn_abs) {\n\t\t\t \n\t\t\tif (is_reloc(S_ABS, symname))\n\t\t\t\tbreak;\n\n\t\t\tdie(\"Invalid absolute %s relocation: %s\\n\",\n\t\t\t    rel_type(r_type), symname);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif ((int32_t)offset != (int64_t)offset)\n\t\t\tdie(\"Relocation offset doesn't fit in 32 bits\\n\");\n\n\t\tif (r_type == R_X86_64_64)\n\t\t\tadd_reloc(&relocs64, offset);\n\t\telse\n\t\t\tadd_reloc(&relocs32, offset);\n\t\tbreak;\n\n\tdefault:\n\t\tdie(\"Unsupported relocation type: %s (%d)\\n\",\n\t\t    rel_type(r_type), r_type);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#else\n\nstatic int do_reloc32(struct section *sec, Elf_Rel *rel, Elf_Sym *sym,\n\t\t      const char *symname)\n{\n\tunsigned r_type = ELF32_R_TYPE(rel->r_info);\n\tint shn_abs = (sym->st_shndx == SHN_ABS) && !is_reloc(S_REL, symname);\n\n\tswitch (r_type) {\n\tcase R_386_NONE:\n\tcase R_386_PC32:\n\tcase R_386_PC16:\n\tcase R_386_PC8:\n\tcase R_386_PLT32:\n\t\t \n\t\tbreak;\n\n\tcase R_386_32:\n\t\tif (shn_abs) {\n\t\t\t \n\t\t\tif (is_reloc(S_ABS, symname))\n\t\t\t\tbreak;\n\n\t\t\tdie(\"Invalid absolute %s relocation: %s\\n\",\n\t\t\t    rel_type(r_type), symname);\n\t\t\tbreak;\n\t\t}\n\n\t\tadd_reloc(&relocs32, rel->r_offset);\n\t\tbreak;\n\n\tdefault:\n\t\tdie(\"Unsupported relocation type: %s (%d)\\n\",\n\t\t    rel_type(r_type), r_type);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int do_reloc_real(struct section *sec, Elf_Rel *rel, Elf_Sym *sym,\n\t\t\t const char *symname)\n{\n\tunsigned r_type = ELF32_R_TYPE(rel->r_info);\n\tint shn_abs = (sym->st_shndx == SHN_ABS) && !is_reloc(S_REL, symname);\n\n\tswitch (r_type) {\n\tcase R_386_NONE:\n\tcase R_386_PC32:\n\tcase R_386_PC16:\n\tcase R_386_PC8:\n\tcase R_386_PLT32:\n\t\t \n\t\tbreak;\n\n\tcase R_386_16:\n\t\tif (shn_abs) {\n\t\t\t \n\t\t\tif (is_reloc(S_ABS, symname))\n\t\t\t\tbreak;\n\n\t\t\tif (is_reloc(S_SEG, symname)) {\n\t\t\t\tadd_reloc(&relocs16, rel->r_offset);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!is_reloc(S_LIN, symname))\n\t\t\t\tbreak;\n\t\t}\n\t\tdie(\"Invalid %s %s relocation: %s\\n\",\n\t\t    shn_abs ? \"absolute\" : \"relative\",\n\t\t    rel_type(r_type), symname);\n\t\tbreak;\n\n\tcase R_386_32:\n\t\tif (shn_abs) {\n\t\t\t \n\t\t\tif (is_reloc(S_ABS, symname))\n\t\t\t\tbreak;\n\n\t\t\tif (is_reloc(S_REL, symname)) {\n\t\t\t\tadd_reloc(&relocs32, rel->r_offset);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (is_reloc(S_LIN, symname))\n\t\t\t\tadd_reloc(&relocs32, rel->r_offset);\n\t\t\tbreak;\n\t\t}\n\t\tdie(\"Invalid %s %s relocation: %s\\n\",\n\t\t    shn_abs ? \"absolute\" : \"relative\",\n\t\t    rel_type(r_type), symname);\n\t\tbreak;\n\n\tdefault:\n\t\tdie(\"Unsupported relocation type: %s (%d)\\n\",\n\t\t    rel_type(r_type), r_type);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#endif\n\nstatic int cmp_relocs(const void *va, const void *vb)\n{\n\tconst uint32_t *a, *b;\n\ta = va; b = vb;\n\treturn (*a == *b)? 0 : (*a > *b)? 1 : -1;\n}\n\nstatic void sort_relocs(struct relocs *r)\n{\n\tqsort(r->offset, r->count, sizeof(r->offset[0]), cmp_relocs);\n}\n\nstatic int write32(uint32_t v, FILE *f)\n{\n\tunsigned char buf[4];\n\n\tput_unaligned_le32(v, buf);\n\treturn fwrite(buf, 1, 4, f) == 4 ? 0 : -1;\n}\n\nstatic int write32_as_text(uint32_t v, FILE *f)\n{\n\treturn fprintf(f, \"\\t.long 0x%08\"PRIx32\"\\n\", v) > 0 ? 0 : -1;\n}\n\nstatic void emit_relocs(int as_text, int use_real_mode)\n{\n\tint i;\n\tint (*write_reloc)(uint32_t, FILE *) = write32;\n\tint (*do_reloc)(struct section *sec, Elf_Rel *rel, Elf_Sym *sym,\n\t\t\tconst char *symname);\n\n#if ELF_BITS == 64\n\tif (!use_real_mode)\n\t\tdo_reloc = do_reloc64;\n\telse\n\t\tdie(\"--realmode not valid for a 64-bit ELF file\");\n#else\n\tif (!use_real_mode)\n\t\tdo_reloc = do_reloc32;\n\telse\n\t\tdo_reloc = do_reloc_real;\n#endif\n\n\t \n\twalk_relocs(do_reloc);\n\n\tif (relocs16.count && !use_real_mode)\n\t\tdie(\"Segment relocations found but --realmode not specified\\n\");\n\n\t \n\tsort_relocs(&relocs32);\n#if ELF_BITS == 64\n\tsort_relocs(&relocs32neg);\n\tsort_relocs(&relocs64);\n#else\n\tsort_relocs(&relocs16);\n#endif\n\n\t \n\tif (as_text) {\n\t\t \n\t\tprintf(\".section \\\".data.reloc\\\",\\\"a\\\"\\n\");\n\t\tprintf(\".balign 4\\n\");\n\t\twrite_reloc = write32_as_text;\n\t}\n\n\tif (use_real_mode) {\n\t\twrite_reloc(relocs16.count, stdout);\n\t\tfor (i = 0; i < relocs16.count; i++)\n\t\t\twrite_reloc(relocs16.offset[i], stdout);\n\n\t\twrite_reloc(relocs32.count, stdout);\n\t\tfor (i = 0; i < relocs32.count; i++)\n\t\t\twrite_reloc(relocs32.offset[i], stdout);\n\t} else {\n#if ELF_BITS == 64\n\t\t \n\t\twrite_reloc(0, stdout);\n\n\t\t \n\t\tfor (i = 0; i < relocs64.count; i++)\n\t\t\twrite_reloc(relocs64.offset[i], stdout);\n\n\t\t \n\t\twrite_reloc(0, stdout);\n\n\t\t \n\t\tfor (i = 0; i < relocs32neg.count; i++)\n\t\t\twrite_reloc(relocs32neg.offset[i], stdout);\n#endif\n\n\t\t \n\t\twrite_reloc(0, stdout);\n\n\t\t \n\t\tfor (i = 0; i < relocs32.count; i++)\n\t\t\twrite_reloc(relocs32.offset[i], stdout);\n\t}\n}\n\n \nstatic int do_reloc_info(struct section *sec, Elf_Rel *rel, ElfW(Sym) *sym,\n\t\t\t\tconst char *symname)\n{\n\tprintf(\"%s\\t%s\\t%s\\t%s\\n\",\n\t\tsec_name(sec->shdr.sh_info),\n\t\trel_type(ELF_R_TYPE(rel->r_info)),\n\t\tsymname,\n\t\tsec_name(sym_index(sym)));\n\treturn 0;\n}\n\nstatic void print_reloc_info(void)\n{\n\tprintf(\"reloc section\\treloc type\\tsymbol\\tsymbol section\\n\");\n\twalk_relocs(do_reloc_info);\n}\n\n#if ELF_BITS == 64\n# define process process_64\n#else\n# define process process_32\n#endif\n\nvoid process(FILE *fp, int use_real_mode, int as_text,\n\t     int show_absolute_syms, int show_absolute_relocs,\n\t     int show_reloc_info)\n{\n\tregex_init(use_real_mode);\n\tread_ehdr(fp);\n\tread_shdrs(fp);\n\tread_strtabs(fp);\n\tread_symtabs(fp);\n\tread_relocs(fp);\n\tif (ELF_BITS == 64)\n\t\tpercpu_init();\n\tif (show_absolute_syms) {\n\t\tprint_absolute_symbols();\n\t\treturn;\n\t}\n\tif (show_absolute_relocs) {\n\t\tprint_absolute_relocs();\n\t\treturn;\n\t}\n\tif (show_reloc_info) {\n\t\tprint_reloc_info();\n\t\treturn;\n\t}\n\temit_relocs(as_text, use_real_mode);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}