{
  "module_name": "insn_sanity.c",
  "hash_id": "16e33ac46fcf84b5c51c0be657cb5c17caadb835e1180b9291b7fe0c9be22dd3",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/tools/insn_sanity.c",
  "human_readable_source": "\n \n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <asm/insn.h>\n#include <inat.c>\n#include <insn.c>\n\n \n\n#define DEFAULT_MAX_ITER\t10000\n#define INSN_NOP 0x90\n\nstatic const char\t*prog;\t\t \nstatic int\t\tverbose;\t \nstatic int\t\tx86_64;\t\t \nstatic unsigned int\tseed;\t\t \nstatic unsigned long\titer_start;\t \nstatic unsigned long\titer_end = DEFAULT_MAX_ITER;\t \nstatic FILE\t\t*input_file;\t \n\nstatic void usage(const char *err)\n{\n\tif (err)\n\t\tfprintf(stderr, \"%s: Error: %s\\n\\n\", prog, err);\n\tfprintf(stderr, \"Usage: %s [-y|-n|-v] [-s seed[,no]] [-m max] [-i input]\\n\", prog);\n\tfprintf(stderr, \"\\t-y\t64bit mode\\n\");\n\tfprintf(stderr, \"\\t-n\t32bit mode\\n\");\n\tfprintf(stderr, \"\\t-v\tVerbosity(-vv dumps any decoded result)\\n\");\n\tfprintf(stderr, \"\\t-s\tGive a random seed (and iteration number)\\n\");\n\tfprintf(stderr, \"\\t-m\tGive a maximum iteration number\\n\");\n\tfprintf(stderr, \"\\t-i\tGive an input file with decoded binary\\n\");\n\texit(1);\n}\n\nstatic void dump_field(FILE *fp, const char *name, const char *indent,\n\t\t       struct insn_field *field)\n{\n\tfprintf(fp, \"%s.%s = {\\n\", indent, name);\n\tfprintf(fp, \"%s\\t.value = %d, bytes[] = {%x, %x, %x, %x},\\n\",\n\t\tindent, field->value, field->bytes[0], field->bytes[1],\n\t\tfield->bytes[2], field->bytes[3]);\n\tfprintf(fp, \"%s\\t.got = %d, .nbytes = %d},\\n\", indent,\n\t\tfield->got, field->nbytes);\n}\n\nstatic void dump_insn(FILE *fp, struct insn *insn)\n{\n\tfprintf(fp, \"Instruction = {\\n\");\n\tdump_field(fp, \"prefixes\", \"\\t\",\t&insn->prefixes);\n\tdump_field(fp, \"rex_prefix\", \"\\t\",\t&insn->rex_prefix);\n\tdump_field(fp, \"vex_prefix\", \"\\t\",\t&insn->vex_prefix);\n\tdump_field(fp, \"opcode\", \"\\t\",\t\t&insn->opcode);\n\tdump_field(fp, \"modrm\", \"\\t\",\t\t&insn->modrm);\n\tdump_field(fp, \"sib\", \"\\t\",\t\t&insn->sib);\n\tdump_field(fp, \"displacement\", \"\\t\",\t&insn->displacement);\n\tdump_field(fp, \"immediate1\", \"\\t\",\t&insn->immediate1);\n\tdump_field(fp, \"immediate2\", \"\\t\",\t&insn->immediate2);\n\tfprintf(fp, \"\\t.attr = %x, .opnd_bytes = %d, .addr_bytes = %d,\\n\",\n\t\tinsn->attr, insn->opnd_bytes, insn->addr_bytes);\n\tfprintf(fp, \"\\t.length = %d, .x86_64 = %d, .kaddr = %p}\\n\",\n\t\tinsn->length, insn->x86_64, insn->kaddr);\n}\n\nstatic void dump_stream(FILE *fp, const char *msg, unsigned long nr_iter,\n\t\t\tunsigned char *insn_buff, struct insn *insn)\n{\n\tint i;\n\n\tfprintf(fp, \"%s:\\n\", msg);\n\n\tdump_insn(fp, insn);\n\n\tfprintf(fp, \"You can reproduce this with below command(s);\\n\");\n\n\t \n\tfprintf(fp, \" $ echo \");\n\tfor (i = 0; i < MAX_INSN_SIZE; i++)\n\t\tfprintf(fp, \" %02x\", insn_buff[i]);\n\tfprintf(fp, \" | %s -i -\\n\", prog);\n\n\tif (!input_file) {\n\t\tfprintf(fp, \"Or \\n\");\n\t\t \n\t\tfprintf(fp, \" $ %s -s 0x%x,%lu\\n\", prog, seed, nr_iter);\n\t}\n}\n\nstatic void init_random_seed(void)\n{\n\tint fd;\n\n\tfd = open(\"/dev/urandom\", O_RDONLY);\n\tif (fd < 0)\n\t\tgoto fail;\n\n\tif (read(fd, &seed, sizeof(seed)) != sizeof(seed))\n\t\tgoto fail;\n\n\tclose(fd);\n\treturn;\nfail:\n\tusage(\"Failed to open /dev/urandom\");\n}\n\n \nstatic int read_next_insn(unsigned char *insn_buff)\n{\n\tchar buf[256]  = \"\", *tmp;\n\tint i;\n\n\ttmp = fgets(buf, ARRAY_SIZE(buf), input_file);\n\tif (tmp == NULL || feof(input_file))\n\t\treturn 0;\n\n\tfor (i = 0; i < MAX_INSN_SIZE; i++) {\n\t\tinsn_buff[i] = (unsigned char)strtoul(tmp, &tmp, 16);\n\t\tif (*tmp != ' ')\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic int generate_insn(unsigned char *insn_buff)\n{\n\tint i;\n\n\tif (input_file)\n\t\treturn read_next_insn(insn_buff);\n\n\t \n\tfor (i = 0; i < MAX_INSN_SIZE - 1; i += 2)\n\t\t*(unsigned short *)(&insn_buff[i]) = random() & 0xffff;\n\n\twhile (i < MAX_INSN_SIZE)\n\t\tinsn_buff[i++] = random() & 0xff;\n\n\treturn i;\n}\n\nstatic void parse_args(int argc, char **argv)\n{\n\tint c;\n\tchar *tmp = NULL;\n\tint set_seed = 0;\n\n\tprog = argv[0];\n\twhile ((c = getopt(argc, argv, \"ynvs:m:i:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'y':\n\t\t\tx86_64 = 1;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tx86_64 = 0;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tverbose++;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (strcmp(\"-\", optarg) == 0)\n\t\t\t\tinput_file = stdin;\n\t\t\telse\n\t\t\t\tinput_file = fopen(optarg, \"r\");\n\t\t\tif (!input_file)\n\t\t\t\tusage(\"Failed to open input file\");\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tseed = (unsigned int)strtoul(optarg, &tmp, 0);\n\t\t\tif (*tmp == ',') {\n\t\t\t\toptarg = tmp + 1;\n\t\t\t\titer_start = strtoul(optarg, &tmp, 0);\n\t\t\t}\n\t\t\tif (*tmp != '\\0' || tmp == optarg)\n\t\t\t\tusage(\"Failed to parse seed\");\n\t\t\tset_seed = 1;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\titer_end = strtoul(optarg, &tmp, 0);\n\t\t\tif (*tmp != '\\0' || tmp == optarg)\n\t\t\t\tusage(\"Failed to parse max_iter\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(NULL);\n\t\t}\n\t}\n\n\t \n\tif (iter_end < iter_start)\n\t\tusage(\"Max iteration number must be bigger than iter-num\");\n\n\tif (set_seed && input_file)\n\t\tusage(\"Don't use input file (-i) with random seed (-s)\");\n\n\t \n\tif (!input_file) {\n\t\tif (!set_seed)\t \n\t\t\tinit_random_seed();\n\t\tsrand(seed);\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tint insns = 0, ret;\n\tstruct insn insn;\n\tint errors = 0;\n\tunsigned long i;\n\tunsigned char insn_buff[MAX_INSN_SIZE * 2];\n\n\tparse_args(argc, argv);\n\n\t \n\tmemset(insn_buff + MAX_INSN_SIZE, INSN_NOP, MAX_INSN_SIZE);\n\n\tfor (i = 0; i < iter_end; i++) {\n\t\tif (generate_insn(insn_buff) <= 0)\n\t\t\tbreak;\n\n\t\tif (i < iter_start)\t \n\t\t\tcontinue;\n\n\t\t \n\t\tret = insn_decode(&insn, insn_buff, sizeof(insn_buff),\n\t\t\t\t  x86_64 ? INSN_MODE_64 : INSN_MODE_32);\n\n\t\tif (insn.next_byte <= insn.kaddr ||\n\t\t    insn.kaddr + MAX_INSN_SIZE < insn.next_byte) {\n\t\t\t \n\t\t\tdump_stream(stderr, \"Error: Found an access violation\", i, insn_buff, &insn);\n\t\t\terrors++;\n\t\t} else if (verbose && ret < 0)\n\t\t\tdump_stream(stdout, \"Info: Found an undecodable input\", i, insn_buff, &insn);\n\t\telse if (verbose >= 2)\n\t\t\tdump_insn(stdout, &insn);\n\t\tinsns++;\n\t}\n\n\tfprintf((errors) ? stderr : stdout,\n\t\t\"%s: %s: decoded and checked %d %s instructions with %d errors (seed:0x%x)\\n\",\n\t\tprog,\n\t\t(errors) ? \"Failure\" : \"Success\",\n\t\tinsns,\n\t\t(input_file) ? \"given\" : \"random\",\n\t\terrors,\n\t\tseed);\n\n\treturn errors ? 1 : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}