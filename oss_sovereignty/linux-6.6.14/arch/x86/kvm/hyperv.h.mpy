{
  "module_name": "hyperv.h",
  "hash_id": "f017002049f2e13c75beb7610b1208222627cb8c15ff15bbf42d5b47b6e812a1",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/hyperv.h",
  "human_readable_source": " \n \n\n#ifndef __ARCH_X86_KVM_HYPERV_H__\n#define __ARCH_X86_KVM_HYPERV_H__\n\n#include <linux/kvm_host.h>\n#include \"x86.h\"\n\n \n#define HYPERV_CPUID_SIGNATURE_EAX 0x31237648\n\n \n#define HYPERV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS\t0x40000080\n#define HYPERV_CPUID_SYNDBG_INTERFACE\t\t\t0x40000081\n#define HYPERV_CPUID_SYNDBG_PLATFORM_CAPABILITIES\t0x40000082\n\n \n#define HV_X64_SYNDBG_CAP_ALLOW_KERNEL_DEBUGGING\tBIT(1)\n\n \n#define HV_X64_MSR_SYNDBG_CONTROL\t\t0x400000F1\n#define HV_X64_MSR_SYNDBG_STATUS\t\t0x400000F2\n#define HV_X64_MSR_SYNDBG_SEND_BUFFER\t\t0x400000F3\n#define HV_X64_MSR_SYNDBG_RECV_BUFFER\t\t0x400000F4\n#define HV_X64_MSR_SYNDBG_PENDING_BUFFER\t0x400000F5\n#define HV_X64_MSR_SYNDBG_OPTIONS\t\t0x400000FF\n\n \n#define HV_X64_SYNDBG_OPTION_USE_HCALLS\t\tBIT(2)\n\nstatic inline struct kvm_hv *to_kvm_hv(struct kvm *kvm)\n{\n\treturn &kvm->arch.hyperv;\n}\n\nstatic inline struct kvm_vcpu_hv *to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hyperv;\n}\n\nstatic inline struct kvm_vcpu_hv_synic *to_hv_synic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\n\treturn &hv_vcpu->synic;\n}\n\nstatic inline struct kvm_vcpu *hv_synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = container_of(synic, struct kvm_vcpu_hv, synic);\n\n\treturn hv_vcpu->vcpu;\n}\n\nstatic inline struct kvm_hv_syndbg *to_hv_syndbg(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->kvm->arch.hyperv.hv_syndbg;\n}\n\nstatic inline u32 kvm_hv_get_vpindex(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\n\treturn hv_vcpu ? hv_vcpu->vp_index : vcpu->vcpu_idx;\n}\n\nint kvm_hv_set_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host);\nint kvm_hv_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata, bool host);\n\nstatic inline bool kvm_hv_hypercall_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hyperv_enabled && to_kvm_hv(vcpu->kvm)->hv_guest_os_id;\n}\n\nint kvm_hv_hypercall(struct kvm_vcpu *vcpu);\n\nvoid kvm_hv_irq_routing_update(struct kvm *kvm);\nint kvm_hv_synic_set_irq(struct kvm *kvm, u32 vcpu_id, u32 sint);\nvoid kvm_hv_synic_send_eoi(struct kvm_vcpu *vcpu, int vector);\nint kvm_hv_activate_synic(struct kvm_vcpu *vcpu, bool dont_zero_synic_pages);\n\nvoid kvm_hv_vcpu_uninit(struct kvm_vcpu *vcpu);\n\nbool kvm_hv_assist_page_enabled(struct kvm_vcpu *vcpu);\nint kvm_hv_get_assist_page(struct kvm_vcpu *vcpu);\n\nstatic inline struct kvm_vcpu_hv_stimer *to_hv_stimer(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t      int timer_index)\n{\n\treturn &to_hv_vcpu(vcpu)->stimer[timer_index];\n}\n\nstatic inline struct kvm_vcpu *hv_stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu->vcpu;\n}\n\nstatic inline bool kvm_hv_has_stimer_pending(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\n\tif (!hv_vcpu)\n\t\treturn false;\n\n\treturn !bitmap_empty(hv_vcpu->stimer_pending_bitmap,\n\t\t\t     HV_SYNIC_STIMER_COUNT);\n}\n\n \nstatic inline bool kvm_hv_invtsc_suppressed(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\n\t \n\tif (!hv_vcpu ||\n\t    !(hv_vcpu->cpuid_cache.features_eax & HV_ACCESS_TSC_INVARIANT))\n\t\treturn false;\n\n\t \n\treturn !(to_kvm_hv(vcpu->kvm)->hv_invtsc_control & HV_EXPOSE_INVARIANT_TSC);\n}\n\nvoid kvm_hv_process_stimers(struct kvm_vcpu *vcpu);\n\nvoid kvm_hv_setup_tsc_page(struct kvm *kvm,\n\t\t\t   struct pvclock_vcpu_time_info *hv_clock);\nvoid kvm_hv_request_tsc_page_update(struct kvm *kvm);\n\nvoid kvm_hv_init_vm(struct kvm *kvm);\nvoid kvm_hv_destroy_vm(struct kvm *kvm);\nint kvm_hv_vcpu_init(struct kvm_vcpu *vcpu);\nvoid kvm_hv_set_cpuid(struct kvm_vcpu *vcpu, bool hyperv_enabled);\nint kvm_hv_set_enforce_cpuid(struct kvm_vcpu *vcpu, bool enforce);\nint kvm_vm_ioctl_hv_eventfd(struct kvm *kvm, struct kvm_hyperv_eventfd *args);\nint kvm_get_hv_cpuid(struct kvm_vcpu *vcpu, struct kvm_cpuid2 *cpuid,\n\t\t     struct kvm_cpuid_entry2 __user *entries);\n\nstatic inline struct kvm_vcpu_hv_tlb_flush_fifo *kvm_hv_get_tlb_flush_fifo(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t\t\t\t   bool is_guest_mode)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tint i = is_guest_mode ? HV_L2_TLB_FLUSH_FIFO :\n\t\t\t\tHV_L1_TLB_FLUSH_FIFO;\n\n\treturn &hv_vcpu->tlb_flush_fifo[i];\n}\n\nstatic inline void kvm_hv_vcpu_purge_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv_tlb_flush_fifo *tlb_flush_fifo;\n\n\tif (!to_hv_vcpu(vcpu) || !kvm_check_request(KVM_REQ_HV_TLB_FLUSH, vcpu))\n\t\treturn;\n\n\ttlb_flush_fifo = kvm_hv_get_tlb_flush_fifo(vcpu, is_guest_mode(vcpu));\n\n\tkfifo_reset_out(&tlb_flush_fifo->entries);\n}\n\nstatic inline bool guest_hv_cpuid_has_l2_tlb_flush(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\n\treturn hv_vcpu &&\n\t\t(hv_vcpu->cpuid_cache.nested_eax & HV_X64_NESTED_DIRECT_FLUSH);\n}\n\nstatic inline bool kvm_hv_is_tlb_flush_hcall(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tu16 code;\n\n\tif (!hv_vcpu)\n\t\treturn false;\n\n\tcode = is_64_bit_hypercall(vcpu) ? kvm_rcx_read(vcpu) :\n\t\t\t\t\t   kvm_rax_read(vcpu);\n\n\treturn (code == HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE ||\n\t\tcode == HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST ||\n\t\tcode == HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX ||\n\t\tcode == HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX);\n}\n\nstatic inline int kvm_hv_verify_vp_assist(struct kvm_vcpu *vcpu)\n{\n\tif (!to_hv_vcpu(vcpu))\n\t\treturn 0;\n\n\tif (!kvm_hv_assist_page_enabled(vcpu))\n\t\treturn 0;\n\n\treturn kvm_hv_get_assist_page(vcpu);\n}\n\nint kvm_hv_vcpu_flush_tlb(struct kvm_vcpu *vcpu);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}