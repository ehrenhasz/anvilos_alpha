{
  "module_name": "pmu.c",
  "hash_id": "8eba8fd8964c8e4cfb985c37089ecc636111738503b2fc4ceed1b9112199db3a",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/pmu.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include <linux/perf_event.h>\n#include <linux/bsearch.h>\n#include <linux/sort.h>\n#include <asm/perf_event.h>\n#include <asm/cpu_device_id.h>\n#include \"x86.h\"\n#include \"cpuid.h\"\n#include \"lapic.h\"\n#include \"pmu.h\"\n\n \n#define KVM_PMU_EVENT_FILTER_MAX_EVENTS 300\n\nstruct x86_pmu_capability __read_mostly kvm_pmu_cap;\nEXPORT_SYMBOL_GPL(kvm_pmu_cap);\n\n \nstatic const struct x86_cpu_id vmx_pebs_pdir_cpu[] = {\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_D, NULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_X, NULL),\n\t \n\tX86_MATCH_INTEL_FAM6_MODEL(SAPPHIRERAPIDS_X, NULL),\n\t{}\n};\n\n \nstatic const struct x86_cpu_id vmx_pebs_pdist_cpu[] = {\n\tX86_MATCH_INTEL_FAM6_MODEL(SAPPHIRERAPIDS_X, NULL),\n\t{}\n};\n\n \n\nstatic struct kvm_pmu_ops kvm_pmu_ops __read_mostly;\n\n#define KVM_X86_PMU_OP(func)\t\t\t\t\t     \\\n\tDEFINE_STATIC_CALL_NULL(kvm_x86_pmu_##func,\t\t\t     \\\n\t\t\t\t*(((struct kvm_pmu_ops *)0)->func));\n#define KVM_X86_PMU_OP_OPTIONAL KVM_X86_PMU_OP\n#include <asm/kvm-x86-pmu-ops.h>\n\nvoid kvm_pmu_ops_update(const struct kvm_pmu_ops *pmu_ops)\n{\n\tmemcpy(&kvm_pmu_ops, pmu_ops, sizeof(kvm_pmu_ops));\n\n#define __KVM_X86_PMU_OP(func) \\\n\tstatic_call_update(kvm_x86_pmu_##func, kvm_pmu_ops.func);\n#define KVM_X86_PMU_OP(func) \\\n\tWARN_ON(!kvm_pmu_ops.func); __KVM_X86_PMU_OP(func)\n#define KVM_X86_PMU_OP_OPTIONAL __KVM_X86_PMU_OP\n#include <asm/kvm-x86-pmu-ops.h>\n#undef __KVM_X86_PMU_OP\n}\n\nstatic inline void __kvm_perf_overflow(struct kvm_pmc *pmc, bool in_pmi)\n{\n\tstruct kvm_pmu *pmu = pmc_to_pmu(pmc);\n\tbool skip_pmi = false;\n\n\tif (pmc->perf_event && pmc->perf_event->attr.precise_ip) {\n\t\tif (!in_pmi) {\n\t\t\t \n\t\t\tskip_pmi = true;\n\t\t} else {\n\t\t\t \n\t\t\tskip_pmi = __test_and_set_bit(GLOBAL_STATUS_BUFFER_OVF_BIT,\n\t\t\t\t\t\t      (unsigned long *)&pmu->global_status);\n\t\t}\n\t} else {\n\t\t__set_bit(pmc->idx, (unsigned long *)&pmu->global_status);\n\t}\n\n\tif (pmc->intr && !skip_pmi)\n\t\tkvm_make_request(KVM_REQ_PMI, pmc->vcpu);\n}\n\nstatic void kvm_perf_overflow(struct perf_event *perf_event,\n\t\t\t      struct perf_sample_data *data,\n\t\t\t      struct pt_regs *regs)\n{\n\tstruct kvm_pmc *pmc = perf_event->overflow_handler_context;\n\n\t \n\tif (test_and_set_bit(pmc->idx, pmc_to_pmu(pmc)->reprogram_pmi))\n\t\treturn;\n\n\t__kvm_perf_overflow(pmc, true);\n\n\tkvm_make_request(KVM_REQ_PMU, pmc->vcpu);\n}\n\nstatic u64 pmc_get_pebs_precise_level(struct kvm_pmc *pmc)\n{\n\t \n\tif ((pmc->idx == 0 && x86_match_cpu(vmx_pebs_pdist_cpu)) ||\n\t    (pmc->idx == 32 && x86_match_cpu(vmx_pebs_pdir_cpu)))\n\t\treturn 3;\n\n\t \n\treturn 1;\n}\n\nstatic int pmc_reprogram_counter(struct kvm_pmc *pmc, u32 type, u64 config,\n\t\t\t\t bool exclude_user, bool exclude_kernel,\n\t\t\t\t bool intr)\n{\n\tstruct kvm_pmu *pmu = pmc_to_pmu(pmc);\n\tstruct perf_event *event;\n\tstruct perf_event_attr attr = {\n\t\t.type = type,\n\t\t.size = sizeof(attr),\n\t\t.pinned = true,\n\t\t.exclude_idle = true,\n\t\t.exclude_host = 1,\n\t\t.exclude_user = exclude_user,\n\t\t.exclude_kernel = exclude_kernel,\n\t\t.config = config,\n\t};\n\tbool pebs = test_bit(pmc->idx, (unsigned long *)&pmu->pebs_enable);\n\n\tattr.sample_period = get_sample_period(pmc, pmc->counter);\n\n\tif ((attr.config & HSW_IN_TX_CHECKPOINTED) &&\n\t    guest_cpuid_is_intel(pmc->vcpu)) {\n\t\t \n\t\tattr.sample_period = 0;\n\t}\n\tif (pebs) {\n\t\t \n\t\tattr.precise_ip = pmc_get_pebs_precise_level(pmc);\n\t}\n\n\tevent = perf_event_create_kernel_counter(&attr, -1, current,\n\t\t\t\t\t\t kvm_perf_overflow, pmc);\n\tif (IS_ERR(event)) {\n\t\tpr_debug_ratelimited(\"kvm_pmu: event creation failed %ld for pmc->idx = %d\\n\",\n\t\t\t    PTR_ERR(event), pmc->idx);\n\t\treturn PTR_ERR(event);\n\t}\n\n\tpmc->perf_event = event;\n\tpmc_to_pmu(pmc)->event_count++;\n\tpmc->is_paused = false;\n\tpmc->intr = intr || pebs;\n\treturn 0;\n}\n\nstatic void pmc_pause_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter = pmc->counter;\n\n\tif (!pmc->perf_event || pmc->is_paused)\n\t\treturn;\n\n\t \n\tcounter += perf_event_pause(pmc->perf_event, true);\n\tpmc->counter = counter & pmc_bitmask(pmc);\n\tpmc->is_paused = true;\n}\n\nstatic bool pmc_resume_counter(struct kvm_pmc *pmc)\n{\n\tif (!pmc->perf_event)\n\t\treturn false;\n\n\t \n\tif (is_sampling_event(pmc->perf_event) &&\n\t    perf_event_period(pmc->perf_event,\n\t\t\t      get_sample_period(pmc, pmc->counter)))\n\t\treturn false;\n\n\tif (test_bit(pmc->idx, (unsigned long *)&pmc_to_pmu(pmc)->pebs_enable) !=\n\t    (!!pmc->perf_event->attr.precise_ip))\n\t\treturn false;\n\n\t \n\tperf_event_enable(pmc->perf_event);\n\tpmc->is_paused = false;\n\n\treturn true;\n}\n\nstatic void pmc_release_perf_event(struct kvm_pmc *pmc)\n{\n\tif (pmc->perf_event) {\n\t\tperf_event_release_kernel(pmc->perf_event);\n\t\tpmc->perf_event = NULL;\n\t\tpmc->current_config = 0;\n\t\tpmc_to_pmu(pmc)->event_count--;\n\t}\n}\n\nstatic void pmc_stop_counter(struct kvm_pmc *pmc)\n{\n\tif (pmc->perf_event) {\n\t\tpmc->counter = pmc_read_counter(pmc);\n\t\tpmc_release_perf_event(pmc);\n\t}\n}\n\nstatic int filter_cmp(const void *pa, const void *pb, u64 mask)\n{\n\tu64 a = *(u64 *)pa & mask;\n\tu64 b = *(u64 *)pb & mask;\n\n\treturn (a > b) - (a < b);\n}\n\n\nstatic int filter_sort_cmp(const void *pa, const void *pb)\n{\n\treturn filter_cmp(pa, pb, (KVM_PMU_MASKED_ENTRY_EVENT_SELECT |\n\t\t\t\t   KVM_PMU_MASKED_ENTRY_EXCLUDE));\n}\n\n \nstatic int filter_event_cmp(const void *pa, const void *pb)\n{\n\treturn filter_cmp(pa, pb, (KVM_PMU_MASKED_ENTRY_EVENT_SELECT));\n}\n\nstatic int find_filter_index(u64 *events, u64 nevents, u64 key)\n{\n\tu64 *fe = bsearch(&key, events, nevents, sizeof(events[0]),\n\t\t\t  filter_event_cmp);\n\n\tif (!fe)\n\t\treturn -1;\n\n\treturn fe - events;\n}\n\nstatic bool is_filter_entry_match(u64 filter_event, u64 umask)\n{\n\tu64 mask = filter_event >> (KVM_PMU_MASKED_ENTRY_UMASK_MASK_SHIFT - 8);\n\tu64 match = filter_event & KVM_PMU_MASKED_ENTRY_UMASK_MATCH;\n\n\tBUILD_BUG_ON((KVM_PMU_ENCODE_MASKED_ENTRY(0, 0xff, 0, false) >>\n\t\t     (KVM_PMU_MASKED_ENTRY_UMASK_MASK_SHIFT - 8)) !=\n\t\t     ARCH_PERFMON_EVENTSEL_UMASK);\n\n\treturn (umask & mask) == match;\n}\n\nstatic bool filter_contains_match(u64 *events, u64 nevents, u64 eventsel)\n{\n\tu64 event_select = eventsel & kvm_pmu_ops.EVENTSEL_EVENT;\n\tu64 umask = eventsel & ARCH_PERFMON_EVENTSEL_UMASK;\n\tint i, index;\n\n\tindex = find_filter_index(events, nevents, event_select);\n\tif (index < 0)\n\t\treturn false;\n\n\t \n\tfor (i = index; i < nevents; i++) {\n\t\tif (filter_event_cmp(&events[i], &event_select))\n\t\t\tbreak;\n\n\t\tif (is_filter_entry_match(events[i], umask))\n\t\t\treturn true;\n\t}\n\n\tfor (i = index - 1; i >= 0; i--) {\n\t\tif (filter_event_cmp(&events[i], &event_select))\n\t\t\tbreak;\n\n\t\tif (is_filter_entry_match(events[i], umask))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool is_gp_event_allowed(struct kvm_x86_pmu_event_filter *f,\n\t\t\t\tu64 eventsel)\n{\n\tif (filter_contains_match(f->includes, f->nr_includes, eventsel) &&\n\t    !filter_contains_match(f->excludes, f->nr_excludes, eventsel))\n\t\treturn f->action == KVM_PMU_EVENT_ALLOW;\n\n\treturn f->action == KVM_PMU_EVENT_DENY;\n}\n\nstatic bool is_fixed_event_allowed(struct kvm_x86_pmu_event_filter *filter,\n\t\t\t\t   int idx)\n{\n\tint fixed_idx = idx - INTEL_PMC_IDX_FIXED;\n\n\tif (filter->action == KVM_PMU_EVENT_DENY &&\n\t    test_bit(fixed_idx, (ulong *)&filter->fixed_counter_bitmap))\n\t\treturn false;\n\tif (filter->action == KVM_PMU_EVENT_ALLOW &&\n\t    !test_bit(fixed_idx, (ulong *)&filter->fixed_counter_bitmap))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool check_pmu_event_filter(struct kvm_pmc *pmc)\n{\n\tstruct kvm_x86_pmu_event_filter *filter;\n\tstruct kvm *kvm = pmc->vcpu->kvm;\n\n\tfilter = srcu_dereference(kvm->arch.pmu_event_filter, &kvm->srcu);\n\tif (!filter)\n\t\treturn true;\n\n\tif (pmc_is_gp(pmc))\n\t\treturn is_gp_event_allowed(filter, pmc->eventsel);\n\n\treturn is_fixed_event_allowed(filter, pmc->idx);\n}\n\nstatic bool pmc_event_is_allowed(struct kvm_pmc *pmc)\n{\n\treturn pmc_is_globally_enabled(pmc) && pmc_speculative_in_use(pmc) &&\n\t       static_call(kvm_x86_pmu_hw_event_available)(pmc) &&\n\t       check_pmu_event_filter(pmc);\n}\n\nstatic void reprogram_counter(struct kvm_pmc *pmc)\n{\n\tstruct kvm_pmu *pmu = pmc_to_pmu(pmc);\n\tu64 eventsel = pmc->eventsel;\n\tu64 new_config = eventsel;\n\tu8 fixed_ctr_ctrl;\n\n\tpmc_pause_counter(pmc);\n\n\tif (!pmc_event_is_allowed(pmc))\n\t\tgoto reprogram_complete;\n\n\tif (pmc->counter < pmc->prev_counter)\n\t\t__kvm_perf_overflow(pmc, false);\n\n\tif (eventsel & ARCH_PERFMON_EVENTSEL_PIN_CONTROL)\n\t\tprintk_once(\"kvm pmu: pin control bit is ignored\\n\");\n\n\tif (pmc_is_fixed(pmc)) {\n\t\tfixed_ctr_ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl,\n\t\t\t\t\t\t  pmc->idx - INTEL_PMC_IDX_FIXED);\n\t\tif (fixed_ctr_ctrl & 0x1)\n\t\t\teventsel |= ARCH_PERFMON_EVENTSEL_OS;\n\t\tif (fixed_ctr_ctrl & 0x2)\n\t\t\teventsel |= ARCH_PERFMON_EVENTSEL_USR;\n\t\tif (fixed_ctr_ctrl & 0x8)\n\t\t\teventsel |= ARCH_PERFMON_EVENTSEL_INT;\n\t\tnew_config = (u64)fixed_ctr_ctrl;\n\t}\n\n\tif (pmc->current_config == new_config && pmc_resume_counter(pmc))\n\t\tgoto reprogram_complete;\n\n\tpmc_release_perf_event(pmc);\n\n\tpmc->current_config = new_config;\n\n\t \n\tif (pmc_reprogram_counter(pmc, PERF_TYPE_RAW,\n\t\t\t\t  (eventsel & pmu->raw_event_mask),\n\t\t\t\t  !(eventsel & ARCH_PERFMON_EVENTSEL_USR),\n\t\t\t\t  !(eventsel & ARCH_PERFMON_EVENTSEL_OS),\n\t\t\t\t  eventsel & ARCH_PERFMON_EVENTSEL_INT))\n\t\treturn;\n\nreprogram_complete:\n\tclear_bit(pmc->idx, (unsigned long *)&pmc_to_pmu(pmc)->reprogram_pmi);\n\tpmc->prev_counter = 0;\n}\n\nvoid kvm_pmu_handle_event(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tint bit;\n\n\tfor_each_set_bit(bit, pmu->reprogram_pmi, X86_PMC_IDX_MAX) {\n\t\tstruct kvm_pmc *pmc = static_call(kvm_x86_pmu_pmc_idx_to_pmc)(pmu, bit);\n\n\t\tif (unlikely(!pmc)) {\n\t\t\tclear_bit(bit, pmu->reprogram_pmi);\n\t\t\tcontinue;\n\t\t}\n\n\t\treprogram_counter(pmc);\n\t}\n\n\t \n\tif (unlikely(pmu->need_cleanup))\n\t\tkvm_pmu_cleanup(vcpu);\n}\n\n \nbool kvm_pmu_is_valid_rdpmc_ecx(struct kvm_vcpu *vcpu, unsigned int idx)\n{\n\treturn static_call(kvm_x86_pmu_is_valid_rdpmc_ecx)(vcpu, idx);\n}\n\nbool is_vmware_backdoor_pmc(u32 pmc_idx)\n{\n\tswitch (pmc_idx) {\n\tcase VMWARE_BACKDOOR_PMC_HOST_TSC:\n\tcase VMWARE_BACKDOOR_PMC_REAL_TIME:\n\tcase VMWARE_BACKDOOR_PMC_APPARENT_TIME:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int kvm_pmu_rdpmc_vmware(struct kvm_vcpu *vcpu, unsigned idx, u64 *data)\n{\n\tu64 ctr_val;\n\n\tswitch (idx) {\n\tcase VMWARE_BACKDOOR_PMC_HOST_TSC:\n\t\tctr_val = rdtsc();\n\t\tbreak;\n\tcase VMWARE_BACKDOOR_PMC_REAL_TIME:\n\t\tctr_val = ktime_get_boottime_ns();\n\t\tbreak;\n\tcase VMWARE_BACKDOOR_PMC_APPARENT_TIME:\n\t\tctr_val = ktime_get_boottime_ns() +\n\t\t\tvcpu->kvm->arch.kvmclock_offset;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\t*data = ctr_val;\n\treturn 0;\n}\n\nint kvm_pmu_rdpmc(struct kvm_vcpu *vcpu, unsigned idx, u64 *data)\n{\n\tbool fast_mode = idx & (1u << 31);\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\tu64 mask = fast_mode ? ~0u : ~0ull;\n\n\tif (!pmu->version)\n\t\treturn 1;\n\n\tif (is_vmware_backdoor_pmc(idx))\n\t\treturn kvm_pmu_rdpmc_vmware(vcpu, idx, data);\n\n\tpmc = static_call(kvm_x86_pmu_rdpmc_ecx_to_pmc)(vcpu, idx, &mask);\n\tif (!pmc)\n\t\treturn 1;\n\n\tif (!kvm_is_cr4_bit_set(vcpu, X86_CR4_PCE) &&\n\t    (static_call(kvm_x86_get_cpl)(vcpu) != 0) &&\n\t    kvm_is_cr0_bit_set(vcpu, X86_CR0_PE))\n\t\treturn 1;\n\n\t*data = pmc_read_counter(pmc) & mask;\n\treturn 0;\n}\n\nvoid kvm_pmu_deliver_pmi(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu)) {\n\t\tstatic_call_cond(kvm_x86_pmu_deliver_pmi)(vcpu);\n\t\tkvm_apic_local_deliver(vcpu->arch.apic, APIC_LVTPC);\n\t}\n}\n\nbool kvm_pmu_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tswitch (msr) {\n\tcase MSR_CORE_PERF_GLOBAL_STATUS:\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\tcase MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\t\treturn kvm_pmu_has_perf_global_ctrl(vcpu_to_pmu(vcpu));\n\tdefault:\n\t\tbreak;\n\t}\n\treturn static_call(kvm_x86_pmu_msr_idx_to_pmc)(vcpu, msr) ||\n\t\tstatic_call(kvm_x86_pmu_is_valid_msr)(vcpu, msr);\n}\n\nstatic void kvm_pmu_mark_pmc_in_use(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc = static_call(kvm_x86_pmu_msr_idx_to_pmc)(vcpu, msr);\n\n\tif (pmc)\n\t\t__set_bit(pmc->idx, pmu->pmc_in_use);\n}\n\nint kvm_pmu_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tu32 msr = msr_info->index;\n\n\tswitch (msr) {\n\tcase MSR_CORE_PERF_GLOBAL_STATUS:\n\tcase MSR_AMD64_PERF_CNTR_GLOBAL_STATUS:\n\t\tmsr_info->data = pmu->global_status;\n\t\tbreak;\n\tcase MSR_AMD64_PERF_CNTR_GLOBAL_CTL:\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tmsr_info->data = pmu->global_ctrl;\n\t\tbreak;\n\tcase MSR_AMD64_PERF_CNTR_GLOBAL_STATUS_CLR:\n\tcase MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn static_call(kvm_x86_pmu_get_msr)(vcpu, msr_info);\n\t}\n\n\treturn 0;\n}\n\nint kvm_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\tu64 diff;\n\n\t \n\tswitch (msr) {\n\tcase MSR_CORE_PERF_GLOBAL_STATUS:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;  \n\t\tfallthrough;\n\tcase MSR_AMD64_PERF_CNTR_GLOBAL_STATUS:\n\t\t \n\t\tif (!msr_info->host_initiated)\n\t\t\tbreak;\n\n\t\tif (data & pmu->global_status_mask)\n\t\t\treturn 1;\n\n\t\tpmu->global_status = data;\n\t\tbreak;\n\tcase MSR_AMD64_PERF_CNTR_GLOBAL_CTL:\n\t\tdata &= ~pmu->global_ctrl_mask;\n\t\tfallthrough;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (!kvm_valid_perf_global_ctrl(pmu, data))\n\t\t\treturn 1;\n\n\t\tif (pmu->global_ctrl != data) {\n\t\t\tdiff = pmu->global_ctrl ^ data;\n\t\t\tpmu->global_ctrl = data;\n\t\t\treprogram_counters(pmu, diff);\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\t\t \n\t\tif (data & pmu->global_status_mask)\n\t\t\treturn 1;\n\t\tfallthrough;\n\tcase MSR_AMD64_PERF_CNTR_GLOBAL_STATUS_CLR:\n\t\tif (!msr_info->host_initiated)\n\t\t\tpmu->global_status &= ~data;\n\t\tbreak;\n\tdefault:\n\t\tkvm_pmu_mark_pmc_in_use(vcpu, msr_info->index);\n\t\treturn static_call(kvm_x86_pmu_set_msr)(vcpu, msr_info);\n\t}\n\n\treturn 0;\n}\n\nvoid kvm_pmu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\tint i;\n\n\tpmu->need_cleanup = false;\n\n\tbitmap_zero(pmu->reprogram_pmi, X86_PMC_IDX_MAX);\n\n\tfor_each_set_bit(i, pmu->all_valid_pmc_idx, X86_PMC_IDX_MAX) {\n\t\tpmc = static_call(kvm_x86_pmu_pmc_idx_to_pmc)(pmu, i);\n\t\tif (!pmc)\n\t\t\tcontinue;\n\n\t\tpmc_stop_counter(pmc);\n\t\tpmc->counter = 0;\n\n\t\tif (pmc_is_gp(pmc))\n\t\t\tpmc->eventsel = 0;\n\t}\n\n\tpmu->fixed_ctr_ctrl = pmu->global_ctrl = pmu->global_status = 0;\n\n\tstatic_call_cond(kvm_x86_pmu_reset)(vcpu);\n}\n\n\n \nvoid kvm_pmu_refresh(struct kvm_vcpu *vcpu)\n{\n\tif (KVM_BUG_ON(kvm_vcpu_has_run(vcpu), vcpu->kvm))\n\t\treturn;\n\n\t \n\tkvm_pmu_reset(vcpu);\n\n\tbitmap_zero(vcpu_to_pmu(vcpu)->all_valid_pmc_idx, X86_PMC_IDX_MAX);\n\tstatic_call(kvm_x86_pmu_refresh)(vcpu);\n}\n\nvoid kvm_pmu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tmemset(pmu, 0, sizeof(*pmu));\n\tstatic_call(kvm_x86_pmu_init)(vcpu);\n\tpmu->event_count = 0;\n\tpmu->need_cleanup = false;\n\tkvm_pmu_refresh(vcpu);\n}\n\n \nvoid kvm_pmu_cleanup(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc = NULL;\n\tDECLARE_BITMAP(bitmask, X86_PMC_IDX_MAX);\n\tint i;\n\n\tpmu->need_cleanup = false;\n\n\tbitmap_andnot(bitmask, pmu->all_valid_pmc_idx,\n\t\t      pmu->pmc_in_use, X86_PMC_IDX_MAX);\n\n\tfor_each_set_bit(i, bitmask, X86_PMC_IDX_MAX) {\n\t\tpmc = static_call(kvm_x86_pmu_pmc_idx_to_pmc)(pmu, i);\n\n\t\tif (pmc && pmc->perf_event && !pmc_speculative_in_use(pmc))\n\t\t\tpmc_stop_counter(pmc);\n\t}\n\n\tstatic_call_cond(kvm_x86_pmu_cleanup)(vcpu);\n\n\tbitmap_zero(pmu->pmc_in_use, X86_PMC_IDX_MAX);\n}\n\nvoid kvm_pmu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_pmu_reset(vcpu);\n}\n\nstatic void kvm_pmu_incr_counter(struct kvm_pmc *pmc)\n{\n\tpmc->prev_counter = pmc->counter;\n\tpmc->counter = (pmc->counter + 1) & pmc_bitmask(pmc);\n\tkvm_pmu_request_counter_reprogram(pmc);\n}\n\nstatic inline bool eventsel_match_perf_hw_id(struct kvm_pmc *pmc,\n\tunsigned int perf_hw_id)\n{\n\treturn !((pmc->eventsel ^ perf_get_hw_event_config(perf_hw_id)) &\n\t\tAMD64_RAW_EVENT_MASK_NB);\n}\n\nstatic inline bool cpl_is_matched(struct kvm_pmc *pmc)\n{\n\tbool select_os, select_user;\n\tu64 config;\n\n\tif (pmc_is_gp(pmc)) {\n\t\tconfig = pmc->eventsel;\n\t\tselect_os = config & ARCH_PERFMON_EVENTSEL_OS;\n\t\tselect_user = config & ARCH_PERFMON_EVENTSEL_USR;\n\t} else {\n\t\tconfig = fixed_ctrl_field(pmc_to_pmu(pmc)->fixed_ctr_ctrl,\n\t\t\t\t\t  pmc->idx - INTEL_PMC_IDX_FIXED);\n\t\tselect_os = config & 0x1;\n\t\tselect_user = config & 0x2;\n\t}\n\n\treturn (static_call(kvm_x86_get_cpl)(pmc->vcpu) == 0) ? select_os : select_user;\n}\n\nvoid kvm_pmu_trigger_event(struct kvm_vcpu *vcpu, u64 perf_hw_id)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\tint i;\n\n\tfor_each_set_bit(i, pmu->all_valid_pmc_idx, X86_PMC_IDX_MAX) {\n\t\tpmc = static_call(kvm_x86_pmu_pmc_idx_to_pmc)(pmu, i);\n\n\t\tif (!pmc || !pmc_event_is_allowed(pmc))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (eventsel_match_perf_hw_id(pmc, perf_hw_id) && cpl_is_matched(pmc))\n\t\t\tkvm_pmu_incr_counter(pmc);\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_pmu_trigger_event);\n\nstatic bool is_masked_filter_valid(const struct kvm_x86_pmu_event_filter *filter)\n{\n\tu64 mask = kvm_pmu_ops.EVENTSEL_EVENT |\n\t\t   KVM_PMU_MASKED_ENTRY_UMASK_MASK |\n\t\t   KVM_PMU_MASKED_ENTRY_UMASK_MATCH |\n\t\t   KVM_PMU_MASKED_ENTRY_EXCLUDE;\n\tint i;\n\n\tfor (i = 0; i < filter->nevents; i++) {\n\t\tif (filter->events[i] & ~mask)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void convert_to_masked_filter(struct kvm_x86_pmu_event_filter *filter)\n{\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < filter->nevents; i++) {\n\t\t \n\t\tif (filter->events[i] & ~(kvm_pmu_ops.EVENTSEL_EVENT |\n\t\t\t\t\t  ARCH_PERFMON_EVENTSEL_UMASK))\n\t\t\tcontinue;\n\t\t \n\t\tfilter->events[j++] = filter->events[i] |\n\t\t\t\t      (0xFFULL << KVM_PMU_MASKED_ENTRY_UMASK_MASK_SHIFT);\n\t}\n\n\tfilter->nevents = j;\n}\n\nstatic int prepare_filter_lists(struct kvm_x86_pmu_event_filter *filter)\n{\n\tint i;\n\n\tif (!(filter->flags & KVM_PMU_EVENT_FLAG_MASKED_EVENTS))\n\t\tconvert_to_masked_filter(filter);\n\telse if (!is_masked_filter_valid(filter))\n\t\treturn -EINVAL;\n\n\t \n\tsort(&filter->events, filter->nevents, sizeof(filter->events[0]),\n\t     filter_sort_cmp, NULL);\n\n\ti = filter->nevents;\n\t \n\tif (filter->flags & KVM_PMU_EVENT_FLAG_MASKED_EVENTS) {\n\t\tfor (i = 0; i < filter->nevents; i++) {\n\t\t\tif (filter->events[i] & KVM_PMU_MASKED_ENTRY_EXCLUDE)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfilter->nr_includes = i;\n\tfilter->nr_excludes = filter->nevents - filter->nr_includes;\n\tfilter->includes = filter->events;\n\tfilter->excludes = filter->events + filter->nr_includes;\n\n\treturn 0;\n}\n\nint kvm_vm_ioctl_set_pmu_event_filter(struct kvm *kvm, void __user *argp)\n{\n\tstruct kvm_pmu_event_filter __user *user_filter = argp;\n\tstruct kvm_x86_pmu_event_filter *filter;\n\tstruct kvm_pmu_event_filter tmp;\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long i;\n\tsize_t size;\n\tint r;\n\n\tif (copy_from_user(&tmp, user_filter, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tif (tmp.action != KVM_PMU_EVENT_ALLOW &&\n\t    tmp.action != KVM_PMU_EVENT_DENY)\n\t\treturn -EINVAL;\n\n\tif (tmp.flags & ~KVM_PMU_EVENT_FLAGS_VALID_MASK)\n\t\treturn -EINVAL;\n\n\tif (tmp.nevents > KVM_PMU_EVENT_FILTER_MAX_EVENTS)\n\t\treturn -E2BIG;\n\n\tsize = struct_size(filter, events, tmp.nevents);\n\tfilter = kzalloc(size, GFP_KERNEL_ACCOUNT);\n\tif (!filter)\n\t\treturn -ENOMEM;\n\n\tfilter->action = tmp.action;\n\tfilter->nevents = tmp.nevents;\n\tfilter->fixed_counter_bitmap = tmp.fixed_counter_bitmap;\n\tfilter->flags = tmp.flags;\n\n\tr = -EFAULT;\n\tif (copy_from_user(filter->events, user_filter->events,\n\t\t\t   sizeof(filter->events[0]) * filter->nevents))\n\t\tgoto cleanup;\n\n\tr = prepare_filter_lists(filter);\n\tif (r)\n\t\tgoto cleanup;\n\n\tmutex_lock(&kvm->lock);\n\tfilter = rcu_replace_pointer(kvm->arch.pmu_event_filter, filter,\n\t\t\t\t     mutex_is_locked(&kvm->lock));\n\tmutex_unlock(&kvm->lock);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\n\tBUILD_BUG_ON(sizeof(((struct kvm_pmu *)0)->reprogram_pmi) >\n\t\t     sizeof(((struct kvm_pmu *)0)->__reprogram_pmi));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tatomic64_set(&vcpu_to_pmu(vcpu)->__reprogram_pmi, -1ull);\n\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_PMU);\n\n\tr = 0;\ncleanup:\n\tkfree(filter);\n\treturn r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}