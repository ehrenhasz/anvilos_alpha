{
  "module_name": "debugfs.c",
  "hash_id": "9ff0787de08bf15e09bcfad8dc981e768aaadb189109467679a9b9fca712bfb3",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/debugfs.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kvm_host.h>\n#include <linux/debugfs.h>\n#include \"lapic.h\"\n#include \"mmu.h\"\n#include \"mmu/mmu_internal.h\"\n\nstatic int vcpu_get_timer_advance_ns(void *data, u64 *val)\n{\n\tstruct kvm_vcpu *vcpu = (struct kvm_vcpu *) data;\n\t*val = vcpu->arch.apic->lapic_timer.timer_advance_ns;\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(vcpu_timer_advance_ns_fops, vcpu_get_timer_advance_ns, NULL, \"%llu\\n\");\n\nstatic int vcpu_get_guest_mode(void *data, u64 *val)\n{\n\tstruct kvm_vcpu *vcpu = (struct kvm_vcpu *) data;\n\t*val = vcpu->stat.guest_mode;\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(vcpu_guest_mode_fops, vcpu_get_guest_mode, NULL, \"%lld\\n\");\n\nstatic int vcpu_get_tsc_offset(void *data, u64 *val)\n{\n\tstruct kvm_vcpu *vcpu = (struct kvm_vcpu *) data;\n\t*val = vcpu->arch.tsc_offset;\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(vcpu_tsc_offset_fops, vcpu_get_tsc_offset, NULL, \"%lld\\n\");\n\nstatic int vcpu_get_tsc_scaling_ratio(void *data, u64 *val)\n{\n\tstruct kvm_vcpu *vcpu = (struct kvm_vcpu *) data;\n\t*val = vcpu->arch.tsc_scaling_ratio;\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(vcpu_tsc_scaling_fops, vcpu_get_tsc_scaling_ratio, NULL, \"%llu\\n\");\n\nstatic int vcpu_get_tsc_scaling_frac_bits(void *data, u64 *val)\n{\n\t*val = kvm_caps.tsc_scaling_ratio_frac_bits;\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(vcpu_tsc_scaling_frac_fops, vcpu_get_tsc_scaling_frac_bits, NULL, \"%llu\\n\");\n\nvoid kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu, struct dentry *debugfs_dentry)\n{\n\tdebugfs_create_file(\"guest_mode\", 0444, debugfs_dentry, vcpu,\n\t\t\t    &vcpu_guest_mode_fops);\n\tdebugfs_create_file(\"tsc-offset\", 0444, debugfs_dentry, vcpu,\n\t\t\t    &vcpu_tsc_offset_fops);\n\n\tif (lapic_in_kernel(vcpu))\n\t\tdebugfs_create_file(\"lapic_timer_advance_ns\", 0444,\n\t\t\t\t    debugfs_dentry, vcpu,\n\t\t\t\t    &vcpu_timer_advance_ns_fops);\n\n\tif (kvm_caps.has_tsc_control) {\n\t\tdebugfs_create_file(\"tsc-scaling-ratio\", 0444,\n\t\t\t\t    debugfs_dentry, vcpu,\n\t\t\t\t    &vcpu_tsc_scaling_fops);\n\t\tdebugfs_create_file(\"tsc-scaling-ratio-frac-bits\", 0444,\n\t\t\t\t    debugfs_dentry, vcpu,\n\t\t\t\t    &vcpu_tsc_scaling_frac_fops);\n\t}\n}\n\n \n#define  RMAP_LOG_SIZE  11\n\nstatic const char *kvm_lpage_str[KVM_NR_PAGE_SIZES] = { \"4K\", \"2M\", \"1G\" };\n\nstatic int kvm_mmu_rmaps_stat_show(struct seq_file *m, void *v)\n{\n\tstruct kvm_rmap_head *rmap;\n\tstruct kvm *kvm = m->private;\n\tstruct kvm_memory_slot *slot;\n\tstruct kvm_memslots *slots;\n\tunsigned int lpage_size, index;\n\t \n\tunsigned int *log[KVM_NR_PAGE_SIZES], *cur;\n\tint i, j, k, l, ret;\n\n\tif (!kvm_memslots_have_rmaps(kvm))\n\t\treturn 0;\n\n\tret = -ENOMEM;\n\tmemset(log, 0, sizeof(log));\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; i++) {\n\t\tlog[i] = kcalloc(RMAP_LOG_SIZE, sizeof(unsigned int), GFP_KERNEL);\n\t\tif (!log[i])\n\t\t\tgoto out;\n\t}\n\n\tmutex_lock(&kvm->slots_lock);\n\twrite_lock(&kvm->mmu_lock);\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tint bkt;\n\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(slot, bkt, slots)\n\t\t\tfor (k = 0; k < KVM_NR_PAGE_SIZES; k++) {\n\t\t\t\trmap = slot->arch.rmap[k];\n\t\t\t\tlpage_size = kvm_mmu_slot_lpages(slot, k + 1);\n\t\t\t\tcur = log[k];\n\t\t\t\tfor (l = 0; l < lpage_size; l++) {\n\t\t\t\t\tindex = ffs(pte_list_count(&rmap[l]));\n\t\t\t\t\tif (WARN_ON_ONCE(index >= RMAP_LOG_SIZE))\n\t\t\t\t\t\tindex = RMAP_LOG_SIZE - 1;\n\t\t\t\t\tcur[index]++;\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\twrite_unlock(&kvm->mmu_lock);\n\tmutex_unlock(&kvm->slots_lock);\n\n\t \n\tseq_printf(m, \"Rmap_Count:\\t0\\t1\\t\");\n\tfor (i = 2; i < RMAP_LOG_SIZE; i++) {\n\t\tj = 1 << (i - 1);\n\t\tk = (1 << i) - 1;\n\t\tseq_printf(m, \"%d-%d\\t\", j, k);\n\t}\n\tseq_printf(m, \"\\n\");\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; i++) {\n\t\tseq_printf(m, \"Level=%s:\\t\", kvm_lpage_str[i]);\n\t\tcur = log[i];\n\t\tfor (j = 0; j < RMAP_LOG_SIZE; j++)\n\t\t\tseq_printf(m, \"%d\\t\", cur[j]);\n\t\tseq_printf(m, \"\\n\");\n\t}\n\n\tret = 0;\nout:\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; i++)\n\t\tkfree(log[i]);\n\n\treturn ret;\n}\n\nstatic int kvm_mmu_rmaps_stat_open(struct inode *inode, struct file *file)\n{\n\tstruct kvm *kvm = inode->i_private;\n\tint r;\n\n\tif (!kvm_get_kvm_safe(kvm))\n\t\treturn -ENOENT;\n\n\tr = single_open(file, kvm_mmu_rmaps_stat_show, kvm);\n\tif (r < 0)\n\t\tkvm_put_kvm(kvm);\n\n\treturn r;\n}\n\nstatic int kvm_mmu_rmaps_stat_release(struct inode *inode, struct file *file)\n{\n\tstruct kvm *kvm = inode->i_private;\n\n\tkvm_put_kvm(kvm);\n\n\treturn single_release(inode, file);\n}\n\nstatic const struct file_operations mmu_rmaps_stat_fops = {\n\t.open\t\t= kvm_mmu_rmaps_stat_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= kvm_mmu_rmaps_stat_release,\n};\n\nint kvm_arch_create_vm_debugfs(struct kvm *kvm)\n{\n\tdebugfs_create_file(\"mmu_rmaps_stat\", 0644, kvm->debugfs_dentry, kvm,\n\t\t\t    &mmu_rmaps_stat_fops);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}