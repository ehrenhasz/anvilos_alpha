{
  "module_name": "ioapic.h",
  "hash_id": "7feb792178b25b3c15e94fbccbec5e4004b3b67d96e75877248dea77bea49c36",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/ioapic.h",
  "human_readable_source": " \n#ifndef __KVM_IO_APIC_H\n#define __KVM_IO_APIC_H\n\n#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n#include \"irq.h\"\n\nstruct kvm;\nstruct kvm_vcpu;\n\n#define IOAPIC_NUM_PINS  KVM_IOAPIC_NUM_PINS\n#define MAX_NR_RESERVED_IOAPIC_PINS KVM_MAX_IRQ_ROUTES\n#define IOAPIC_VERSION_ID 0x11\t \n#define IOAPIC_EDGE_TRIG  0\n#define IOAPIC_LEVEL_TRIG 1\n\n#define IOAPIC_DEFAULT_BASE_ADDRESS  0xfec00000\n#define IOAPIC_MEM_LENGTH            0x100\n\n \n#define IOAPIC_REG_SELECT  0x00\n#define IOAPIC_REG_WINDOW  0x10\n\n \n#define IOAPIC_REG_APIC_ID 0x00\t \n#define IOAPIC_REG_VERSION 0x01\n#define IOAPIC_REG_ARB_ID  0x02\t \n\n \n#define\tIOAPIC_FIXED\t\t\t0x0\n#define\tIOAPIC_LOWEST_PRIORITY\t\t0x1\n#define\tIOAPIC_PMI\t\t\t0x2\n#define\tIOAPIC_NMI\t\t\t0x4\n#define\tIOAPIC_INIT\t\t\t0x5\n#define\tIOAPIC_EXTINT\t\t\t0x7\n\n#define RTC_GSI 8\n\nstruct dest_map {\n\t \n\tDECLARE_BITMAP(map, KVM_MAX_VCPU_IDS);\n\n\t \n\tu8 vectors[KVM_MAX_VCPU_IDS];\n};\n\n\nstruct rtc_status {\n\tint pending_eoi;\n\tstruct dest_map dest_map;\n};\n\nunion kvm_ioapic_redirect_entry {\n\tu64 bits;\n\tstruct {\n\t\tu8 vector;\n\t\tu8 delivery_mode:3;\n\t\tu8 dest_mode:1;\n\t\tu8 delivery_status:1;\n\t\tu8 polarity:1;\n\t\tu8 remote_irr:1;\n\t\tu8 trig_mode:1;\n\t\tu8 mask:1;\n\t\tu8 reserve:7;\n\t\tu8 reserved[4];\n\t\tu8 dest_id;\n\t} fields;\n};\n\nstruct kvm_ioapic {\n\tu64 base_address;\n\tu32 ioregsel;\n\tu32 id;\n\tu32 irr;\n\tu32 pad;\n\tunion kvm_ioapic_redirect_entry redirtbl[IOAPIC_NUM_PINS];\n\tunsigned long irq_states[IOAPIC_NUM_PINS];\n\tstruct kvm_io_device dev;\n\tstruct kvm *kvm;\n\tspinlock_t lock;\n\tstruct rtc_status rtc_status;\n\tstruct delayed_work eoi_inject;\n\tu32 irq_eoi[IOAPIC_NUM_PINS];\n\tu32 irr_delivered;\n};\n\n#ifdef DEBUG\n#define ASSERT(x)  \t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (!(x)) {\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_EMERG \"assertion failed %s: %d: %s\\n\",\t\\\n\t\t       __FILE__, __LINE__, #x);\t\t\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n#else\n#define ASSERT(x) do { } while (0)\n#endif\n\nstatic inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\treturn irqchip_kernel(kvm);\n}\n\nvoid kvm_rtc_eoi_tracking_restore_one(struct kvm_vcpu *vcpu);\nvoid kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu, int vector,\n\t\t\tint trigger_mode);\nint kvm_ioapic_init(struct kvm *kvm);\nvoid kvm_ioapic_destroy(struct kvm *kvm);\nint kvm_ioapic_set_irq(struct kvm_ioapic *ioapic, int irq, int irq_source_id,\n\t\t       int level, bool line_status);\nvoid kvm_ioapic_clear_all(struct kvm_ioapic *ioapic, int irq_source_id);\nvoid kvm_get_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state);\nvoid kvm_set_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state);\nvoid kvm_ioapic_scan_entry(struct kvm_vcpu *vcpu,\n\t\t\t   ulong *ioapic_handled_vectors);\nvoid kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu,\n\t\t\t    ulong *ioapic_handled_vectors);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}