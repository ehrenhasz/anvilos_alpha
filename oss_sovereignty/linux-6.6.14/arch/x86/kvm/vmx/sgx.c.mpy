{
  "module_name": "sgx.c",
  "hash_id": "5d3dd7834ec260f5e3dc5afc38e4652abeaadae635c0b7bd0e7e62510af7aead",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/vmx/sgx.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <asm/sgx.h>\n\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"nested.h\"\n#include \"sgx.h\"\n#include \"vmx.h\"\n#include \"x86.h\"\n\nbool __read_mostly enable_sgx = 1;\nmodule_param_named(sgx, enable_sgx, bool, 0444);\n\n \nstatic u64 sgx_pubkey_hash[4] __ro_after_init;\n\n \nstatic int sgx_get_encls_gva(struct kvm_vcpu *vcpu, unsigned long offset,\n\t\t\t     int size, int alignment, gva_t *gva)\n{\n\tstruct kvm_segment s;\n\tbool fault;\n\n\t \n\t*gva = offset;\n\tif (!is_64_bit_mode(vcpu)) {\n\t\tvmx_get_segment(vcpu, &s, VCPU_SREG_DS);\n\t\t*gva += s.base;\n\t}\n\n\tif (!IS_ALIGNED(*gva, alignment)) {\n\t\tfault = true;\n\t} else if (likely(is_64_bit_mode(vcpu))) {\n\t\tfault = is_noncanonical_address(*gva, vcpu);\n\t} else {\n\t\t*gva &= 0xffffffff;\n\t\tfault = (s.unusable) ||\n\t\t\t(s.type != 2 && s.type != 3) ||\n\t\t\t(*gva > s.limit) ||\n\t\t\t((s.base != 0 || s.limit != 0xffffffff) &&\n\t\t\t(((u64)*gva + size - 1) > s.limit + 1));\n\t}\n\tif (fault)\n\t\tkvm_inject_gp(vcpu, 0);\n\treturn fault ? -EINVAL : 0;\n}\n\nstatic void sgx_handle_emulation_failure(struct kvm_vcpu *vcpu, u64 addr,\n\t\t\t\t\t unsigned int size)\n{\n\tuint64_t data[2] = { addr, size };\n\n\t__kvm_prepare_emulation_failure_exit(vcpu, data, ARRAY_SIZE(data));\n}\n\nstatic int sgx_read_hva(struct kvm_vcpu *vcpu, unsigned long hva, void *data,\n\t\t\tunsigned int size)\n{\n\tif (__copy_from_user(data, (void __user *)hva, size)) {\n\t\tsgx_handle_emulation_failure(vcpu, hva, size);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int sgx_gva_to_gpa(struct kvm_vcpu *vcpu, gva_t gva, bool write,\n\t\t\t  gpa_t *gpa)\n{\n\tstruct x86_exception ex;\n\n\tif (write)\n\t\t*gpa = kvm_mmu_gva_to_gpa_write(vcpu, gva, &ex);\n\telse\n\t\t*gpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, &ex);\n\n\tif (*gpa == INVALID_GPA) {\n\t\tkvm_inject_emulated_page_fault(vcpu, &ex);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int sgx_gpa_to_hva(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned long *hva)\n{\n\t*hva = kvm_vcpu_gfn_to_hva(vcpu, PFN_DOWN(gpa));\n\tif (kvm_is_error_hva(*hva)) {\n\t\tsgx_handle_emulation_failure(vcpu, gpa, 1);\n\t\treturn -EFAULT;\n\t}\n\n\t*hva |= gpa & ~PAGE_MASK;\n\n\treturn 0;\n}\n\nstatic int sgx_inject_fault(struct kvm_vcpu *vcpu, gva_t gva, int trapnr)\n{\n\tstruct x86_exception ex;\n\n\t \n\tif (trapnr == PF_VECTOR && !boot_cpu_has(X86_FEATURE_SGX2)) {\n\t\tkvm_prepare_emulation_failure_exit(vcpu);\n\t\treturn 0;\n\t}\n\n\t \n\tif ((trapnr == PF_VECTOR || !boot_cpu_has(X86_FEATURE_SGX2)) &&\n\t    guest_cpuid_has(vcpu, X86_FEATURE_SGX2)) {\n\t\tmemset(&ex, 0, sizeof(ex));\n\t\tex.vector = PF_VECTOR;\n\t\tex.error_code = PFERR_PRESENT_MASK | PFERR_WRITE_MASK |\n\t\t\t\tPFERR_SGX_MASK;\n\t\tex.address = gva;\n\t\tex.error_code_valid = true;\n\t\tex.nested_page_fault = false;\n\t\tkvm_inject_emulated_page_fault(vcpu, &ex);\n\t} else {\n\t\tkvm_inject_gp(vcpu, 0);\n\t}\n\treturn 1;\n}\n\nstatic int __handle_encls_ecreate(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct sgx_pageinfo *pageinfo,\n\t\t\t\t  unsigned long secs_hva,\n\t\t\t\t  gva_t secs_gva)\n{\n\tstruct sgx_secs *contents = (struct sgx_secs *)pageinfo->contents;\n\tstruct kvm_cpuid_entry2 *sgx_12_0, *sgx_12_1;\n\tu64 attributes, xfrm, size;\n\tu32 miscselect;\n\tu8 max_size_log2;\n\tint trapnr, ret;\n\n\tsgx_12_0 = kvm_find_cpuid_entry_index(vcpu, 0x12, 0);\n\tsgx_12_1 = kvm_find_cpuid_entry_index(vcpu, 0x12, 1);\n\tif (!sgx_12_0 || !sgx_12_1) {\n\t\tkvm_prepare_emulation_failure_exit(vcpu);\n\t\treturn 0;\n\t}\n\n\tmiscselect = contents->miscselect;\n\tattributes = contents->attributes;\n\txfrm = contents->xfrm;\n\tsize = contents->size;\n\n\t \n\tif (!vcpu->kvm->arch.sgx_provisioning_allowed &&\n\t    (attributes & SGX_ATTR_PROVISIONKEY)) {\n\t\tif (sgx_12_1->eax & SGX_ATTR_PROVISIONKEY)\n\t\t\tpr_warn_once(\"SGX PROVISIONKEY advertised but not allowed\\n\");\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\t \n\tif ((u32)miscselect & ~sgx_12_0->ebx ||\n\t    (u32)attributes & ~sgx_12_1->eax ||\n\t    (u32)(attributes >> 32) & ~sgx_12_1->ebx ||\n\t    (u32)xfrm & ~sgx_12_1->ecx ||\n\t    (u32)(xfrm >> 32) & ~sgx_12_1->edx ||\n\t    xfrm & ~(vcpu->arch.guest_supported_xcr0 | XFEATURE_MASK_FPSSE) ||\n\t    (xfrm & XFEATURE_MASK_FPSSE) != XFEATURE_MASK_FPSSE) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\t \n\tmax_size_log2 = (attributes & SGX_ATTR_MODE64BIT) ? sgx_12_0->edx >> 8 :\n\t\t\t\t\t\t\t    sgx_12_0->edx;\n\tif (size >= BIT_ULL(max_size_log2)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\t \n\tret = sgx_virt_ecreate(pageinfo, (void __user *)secs_hva, &trapnr);\n\tif (!ret)\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tif (ret == -EFAULT)\n\t\treturn sgx_inject_fault(vcpu, secs_gva, trapnr);\n\n\treturn ret;\n}\n\nstatic int handle_encls_ecreate(struct kvm_vcpu *vcpu)\n{\n\tgva_t pageinfo_gva, secs_gva;\n\tgva_t metadata_gva, contents_gva;\n\tgpa_t metadata_gpa, contents_gpa, secs_gpa;\n\tunsigned long metadata_hva, contents_hva, secs_hva;\n\tstruct sgx_pageinfo pageinfo;\n\tstruct sgx_secs *contents;\n\tstruct x86_exception ex;\n\tint r;\n\n\tif (sgx_get_encls_gva(vcpu, kvm_rbx_read(vcpu), 32, 32, &pageinfo_gva) ||\n\t    sgx_get_encls_gva(vcpu, kvm_rcx_read(vcpu), 4096, 4096, &secs_gva))\n\t\treturn 1;\n\n\t \n\tr = kvm_read_guest_virt(vcpu, pageinfo_gva, &pageinfo,\n\t\t\t\tsizeof(pageinfo), &ex);\n\tif (r == X86EMUL_PROPAGATE_FAULT) {\n\t\tkvm_inject_emulated_page_fault(vcpu, &ex);\n\t\treturn 1;\n\t} else if (r != X86EMUL_CONTINUE) {\n\t\tsgx_handle_emulation_failure(vcpu, pageinfo_gva,\n\t\t\t\t\t     sizeof(pageinfo));\n\t\treturn 0;\n\t}\n\n\tif (sgx_get_encls_gva(vcpu, pageinfo.metadata, 64, 64, &metadata_gva) ||\n\t    sgx_get_encls_gva(vcpu, pageinfo.contents, 4096, 4096,\n\t\t\t      &contents_gva))\n\t\treturn 1;\n\n\t \n\tif (sgx_gva_to_gpa(vcpu, metadata_gva, false, &metadata_gpa) ||\n\t    sgx_gva_to_gpa(vcpu, contents_gva, false, &contents_gpa) ||\n\t    sgx_gva_to_gpa(vcpu, secs_gva, true, &secs_gpa))\n\t\treturn 1;\n\n\t \n\tif (sgx_gpa_to_hva(vcpu, metadata_gpa, &metadata_hva) ||\n\t    sgx_gpa_to_hva(vcpu, contents_gpa, &contents_hva) ||\n\t    sgx_gpa_to_hva(vcpu, secs_gpa, &secs_hva))\n\t\treturn 0;\n\n\t \n\tcontents = (struct sgx_secs *)__get_free_page(GFP_KERNEL_ACCOUNT);\n\tif (!contents)\n\t\treturn -ENOMEM;\n\n\t \n\tif (sgx_read_hva(vcpu, contents_hva, (void *)contents, PAGE_SIZE)) {\n\t\tfree_page((unsigned long)contents);\n\t\treturn 0;\n\t}\n\n\tpageinfo.metadata = metadata_hva;\n\tpageinfo.contents = (u64)contents;\n\n\tr = __handle_encls_ecreate(vcpu, &pageinfo, secs_hva, secs_gva);\n\n\tfree_page((unsigned long)contents);\n\n\treturn r;\n}\n\nstatic int handle_encls_einit(struct kvm_vcpu *vcpu)\n{\n\tunsigned long sig_hva, secs_hva, token_hva, rflags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tgva_t sig_gva, secs_gva, token_gva;\n\tgpa_t sig_gpa, secs_gpa, token_gpa;\n\tint ret, trapnr;\n\n\tif (sgx_get_encls_gva(vcpu, kvm_rbx_read(vcpu), 1808, 4096, &sig_gva) ||\n\t    sgx_get_encls_gva(vcpu, kvm_rcx_read(vcpu), 4096, 4096, &secs_gva) ||\n\t    sgx_get_encls_gva(vcpu, kvm_rdx_read(vcpu), 304, 512, &token_gva))\n\t\treturn 1;\n\n\t \n\tif (sgx_gva_to_gpa(vcpu, sig_gva, false, &sig_gpa) ||\n\t    sgx_gva_to_gpa(vcpu, secs_gva, true, &secs_gpa) ||\n\t    sgx_gva_to_gpa(vcpu, token_gva, false, &token_gpa))\n\t\treturn 1;\n\n\t \n\tif (sgx_gpa_to_hva(vcpu, sig_gpa, &sig_hva) ||\n\t    sgx_gpa_to_hva(vcpu, secs_gpa, &secs_hva) ||\n\t    sgx_gpa_to_hva(vcpu, token_gpa, &token_hva))\n\t\treturn 0;\n\n\tret = sgx_virt_einit((void __user *)sig_hva, (void __user *)token_hva,\n\t\t\t     (void __user *)secs_hva,\n\t\t\t     vmx->msr_ia32_sgxlepubkeyhash, &trapnr);\n\n\tif (ret == -EFAULT)\n\t\treturn sgx_inject_fault(vcpu, secs_gva, trapnr);\n\n\t \n\tif (ret < 0)\n\t\treturn ret;\n\n\trflags = vmx_get_rflags(vcpu) & ~(X86_EFLAGS_CF | X86_EFLAGS_PF |\n\t\t\t\t\t  X86_EFLAGS_AF | X86_EFLAGS_SF |\n\t\t\t\t\t  X86_EFLAGS_OF);\n\tif (ret)\n\t\trflags |= X86_EFLAGS_ZF;\n\telse\n\t\trflags &= ~X86_EFLAGS_ZF;\n\tvmx_set_rflags(vcpu, rflags);\n\n\tkvm_rax_write(vcpu, ret);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic inline bool encls_leaf_enabled_in_guest(struct kvm_vcpu *vcpu, u32 leaf)\n{\n\t \n\tif (leaf >= ECREATE && leaf <= ETRACK)\n\t\treturn true;\n\n\tif (leaf >= EAUG && leaf <= EMODT)\n\t\treturn guest_cpuid_has(vcpu, X86_FEATURE_SGX2);\n\n\treturn false;\n}\n\nstatic inline bool sgx_enabled_in_guest_bios(struct kvm_vcpu *vcpu)\n{\n\tconst u64 bits = FEAT_CTL_SGX_ENABLED | FEAT_CTL_LOCKED;\n\n\treturn (to_vmx(vcpu)->msr_ia32_feature_control & bits) == bits;\n}\n\nint handle_encls(struct kvm_vcpu *vcpu)\n{\n\tu32 leaf = (u32)kvm_rax_read(vcpu);\n\n\tif (!enable_sgx || !guest_cpuid_has(vcpu, X86_FEATURE_SGX) ||\n\t    !guest_cpuid_has(vcpu, X86_FEATURE_SGX1)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t} else if (!encls_leaf_enabled_in_guest(vcpu, leaf) ||\n\t\t   !sgx_enabled_in_guest_bios(vcpu) || !is_paging(vcpu)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t} else {\n\t\tif (leaf == ECREATE)\n\t\t\treturn handle_encls_ecreate(vcpu);\n\t\tif (leaf == EINIT)\n\t\t\treturn handle_encls_einit(vcpu);\n\t\tWARN_ONCE(1, \"unexpected exit on ENCLS[%u]\", leaf);\n\t\tvcpu->run->exit_reason = KVM_EXIT_UNKNOWN;\n\t\tvcpu->run->hw.hardware_exit_reason = EXIT_REASON_ENCLS;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nvoid setup_default_sgx_lepubkeyhash(void)\n{\n\t \n\tif (!enable_sgx || boot_cpu_has(X86_FEATURE_SGX_LC) ||\n\t    rdmsrl_safe(MSR_IA32_SGXLEPUBKEYHASH0, &sgx_pubkey_hash[0])) {\n\t\tsgx_pubkey_hash[0] = 0xa6053e051270b7acULL;\n\t\tsgx_pubkey_hash[1] = 0x6cfbe8ba8b3b413dULL;\n\t\tsgx_pubkey_hash[2] = 0xc4916d99f2b3735dULL;\n\t\tsgx_pubkey_hash[3] = 0xd4f8c05909f9bb3bULL;\n\t} else {\n\t\t \n\t\trdmsrl(MSR_IA32_SGXLEPUBKEYHASH1, sgx_pubkey_hash[1]);\n\t\trdmsrl(MSR_IA32_SGXLEPUBKEYHASH2, sgx_pubkey_hash[2]);\n\t\trdmsrl(MSR_IA32_SGXLEPUBKEYHASH3, sgx_pubkey_hash[3]);\n\t}\n}\n\nvoid vcpu_setup_sgx_lepubkeyhash(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tmemcpy(vmx->msr_ia32_sgxlepubkeyhash, sgx_pubkey_hash,\n\t       sizeof(sgx_pubkey_hash));\n}\n\n \nstatic bool sgx_intercept_encls_ecreate(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *guest_cpuid;\n\tu32 eax, ebx, ecx, edx;\n\n\tif (!vcpu->kvm->arch.sgx_provisioning_allowed)\n\t\treturn true;\n\n\tguest_cpuid = kvm_find_cpuid_entry_index(vcpu, 0x12, 0);\n\tif (!guest_cpuid)\n\t\treturn true;\n\n\tcpuid_count(0x12, 0, &eax, &ebx, &ecx, &edx);\n\tif (guest_cpuid->ebx != ebx || guest_cpuid->edx != edx)\n\t\treturn true;\n\n\tguest_cpuid = kvm_find_cpuid_entry_index(vcpu, 0x12, 1);\n\tif (!guest_cpuid)\n\t\treturn true;\n\n\tcpuid_count(0x12, 1, &eax, &ebx, &ecx, &edx);\n\tif (guest_cpuid->eax != eax || guest_cpuid->ebx != ebx ||\n\t    guest_cpuid->ecx != ecx || guest_cpuid->edx != edx)\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid vmx_write_encls_bitmap(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)\n{\n\t \n\tu64 bitmap = -1ull;\n\n\t \n\tif (!cpu_has_vmx_encls_vmexit())\n\t\treturn;\n\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_SGX) &&\n\t    sgx_enabled_in_guest_bios(vcpu)) {\n\t\tif (guest_cpuid_has(vcpu, X86_FEATURE_SGX1)) {\n\t\t\tbitmap &= ~GENMASK_ULL(ETRACK, ECREATE);\n\t\t\tif (sgx_intercept_encls_ecreate(vcpu))\n\t\t\t\tbitmap |= (1 << ECREATE);\n\t\t}\n\n\t\tif (guest_cpuid_has(vcpu, X86_FEATURE_SGX2))\n\t\t\tbitmap &= ~GENMASK_ULL(EMODT, EAUG);\n\n\t\t \n\t\tif (boot_cpu_has(X86_FEATURE_SGX_LC))\n\t\t\tbitmap |= (1 << EINIT);\n\n\t\tif (!vmcs12 && is_guest_mode(vcpu))\n\t\t\tvmcs12 = get_vmcs12(vcpu);\n\t\tif (vmcs12 && nested_cpu_has_encls_exit(vmcs12))\n\t\t\tbitmap |= vmcs12->encls_exiting_bitmap;\n\t}\n\tvmcs_write64(ENCLS_EXITING_BITMAP, bitmap);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}