{
  "module_name": "capabilities.h",
  "hash_id": "c90164b0d3905c915ae351315fcdb2ae2b128e2bf6917a56df52f638b2997189",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/vmx/capabilities.h",
  "human_readable_source": " \n#ifndef __KVM_X86_VMX_CAPS_H\n#define __KVM_X86_VMX_CAPS_H\n\n#include <asm/vmx.h>\n\n#include \"../lapic.h\"\n#include \"../x86.h\"\n#include \"../pmu.h\"\n#include \"../cpuid.h\"\n\nextern bool __read_mostly enable_vpid;\nextern bool __read_mostly flexpriority_enabled;\nextern bool __read_mostly enable_ept;\nextern bool __read_mostly enable_unrestricted_guest;\nextern bool __read_mostly enable_ept_ad_bits;\nextern bool __read_mostly enable_pml;\nextern bool __read_mostly enable_ipiv;\nextern int __read_mostly pt_mode;\n\n#define PT_MODE_SYSTEM\t\t0\n#define PT_MODE_HOST_GUEST\t1\n\n#define PMU_CAP_FW_WRITES\t(1ULL << 13)\n#define PMU_CAP_LBR_FMT\t\t0x3f\n\nstruct nested_vmx_msrs {\n\t \n\tu32 procbased_ctls_low;\n\tu32 procbased_ctls_high;\n\tu32 secondary_ctls_low;\n\tu32 secondary_ctls_high;\n\tu32 pinbased_ctls_low;\n\tu32 pinbased_ctls_high;\n\tu32 exit_ctls_low;\n\tu32 exit_ctls_high;\n\tu32 entry_ctls_low;\n\tu32 entry_ctls_high;\n\tu32 misc_low;\n\tu32 misc_high;\n\tu32 ept_caps;\n\tu32 vpid_caps;\n\tu64 basic;\n\tu64 cr0_fixed0;\n\tu64 cr0_fixed1;\n\tu64 cr4_fixed0;\n\tu64 cr4_fixed1;\n\tu64 vmcs_enum;\n\tu64 vmfunc_controls;\n};\n\nstruct vmcs_config {\n\tint size;\n\tu32 basic_cap;\n\tu32 revision_id;\n\tu32 pin_based_exec_ctrl;\n\tu32 cpu_based_exec_ctrl;\n\tu32 cpu_based_2nd_exec_ctrl;\n\tu64 cpu_based_3rd_exec_ctrl;\n\tu32 vmexit_ctrl;\n\tu32 vmentry_ctrl;\n\tu64 misc;\n\tstruct nested_vmx_msrs nested;\n};\nextern struct vmcs_config vmcs_config __ro_after_init;\n\nstruct vmx_capability {\n\tu32 ept;\n\tu32 vpid;\n};\nextern struct vmx_capability vmx_capability __ro_after_init;\n\nstatic inline bool cpu_has_vmx_basic_inout(void)\n{\n\treturn\t(((u64)vmcs_config.basic_cap << 32) & VMX_BASIC_INOUT);\n}\n\nstatic inline bool cpu_has_virtual_nmis(void)\n{\n\treturn vmcs_config.pin_based_exec_ctrl & PIN_BASED_VIRTUAL_NMIS &&\n\t       vmcs_config.cpu_based_exec_ctrl & CPU_BASED_NMI_WINDOW_EXITING;\n}\n\nstatic inline bool cpu_has_vmx_preemption_timer(void)\n{\n\treturn vmcs_config.pin_based_exec_ctrl &\n\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n}\n\nstatic inline bool cpu_has_vmx_posted_intr(void)\n{\n\treturn vmcs_config.pin_based_exec_ctrl & PIN_BASED_POSTED_INTR;\n}\n\nstatic inline bool cpu_has_load_ia32_efer(void)\n{\n\treturn vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_EFER;\n}\n\nstatic inline bool cpu_has_load_perf_global_ctrl(void)\n{\n\treturn vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL;\n}\n\nstatic inline bool cpu_has_vmx_mpx(void)\n{\n\treturn vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_BNDCFGS;\n}\n\nstatic inline bool cpu_has_vmx_tpr_shadow(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW;\n}\n\nstatic inline bool cpu_need_tpr_shadow(struct kvm_vcpu *vcpu)\n{\n\treturn cpu_has_vmx_tpr_shadow() && lapic_in_kernel(vcpu);\n}\n\nstatic inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}\n\nstatic inline bool cpu_has_secondary_exec_ctrls(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl &\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n}\n\nstatic inline bool cpu_has_tertiary_exec_ctrls(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl &\n\t\tCPU_BASED_ACTIVATE_TERTIARY_CONTROLS;\n}\n\nstatic inline bool cpu_has_vmx_virtualize_apic_accesses(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n}\n\nstatic inline bool cpu_has_vmx_ept(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_EPT;\n}\n\nstatic inline bool vmx_umip_emulated(void)\n{\n\treturn !boot_cpu_has(X86_FEATURE_UMIP) &&\n\t       (vmcs_config.cpu_based_2nd_exec_ctrl & SECONDARY_EXEC_DESC);\n}\n\nstatic inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_RDTSCP;\n}\n\nstatic inline bool cpu_has_vmx_virtualize_x2apic_mode(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n}\n\nstatic inline bool cpu_has_vmx_vpid(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_VPID;\n}\n\nstatic inline bool cpu_has_vmx_wbinvd_exit(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_WBINVD_EXITING;\n}\n\nstatic inline bool cpu_has_vmx_unrestricted_guest(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST;\n}\n\nstatic inline bool cpu_has_vmx_apic_register_virt(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT;\n}\n\nstatic inline bool cpu_has_vmx_virtual_intr_delivery(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY;\n}\n\nstatic inline bool cpu_has_vmx_ple(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING;\n}\n\nstatic inline bool cpu_has_vmx_rdrand(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDRAND_EXITING;\n}\n\nstatic inline bool cpu_has_vmx_invpcid(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_INVPCID;\n}\n\nstatic inline bool cpu_has_vmx_vmfunc(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_VMFUNC;\n}\n\nstatic inline bool cpu_has_vmx_shadow_vmcs(void)\n{\n\t \n\tif (!(vmcs_config.misc & MSR_IA32_VMX_MISC_VMWRITE_SHADOW_RO_FIELDS))\n\t\treturn false;\n\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_SHADOW_VMCS;\n}\n\nstatic inline bool cpu_has_vmx_encls_vmexit(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENCLS_EXITING;\n}\n\nstatic inline bool cpu_has_vmx_rdseed(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDSEED_EXITING;\n}\n\nstatic inline bool cpu_has_vmx_pml(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl & SECONDARY_EXEC_ENABLE_PML;\n}\n\nstatic inline bool cpu_has_vmx_xsaves(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_XSAVES;\n}\n\nstatic inline bool cpu_has_vmx_waitpkg(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n}\n\nstatic inline bool cpu_has_vmx_tsc_scaling(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_TSC_SCALING;\n}\n\nstatic inline bool cpu_has_vmx_bus_lock_detection(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t    SECONDARY_EXEC_BUS_LOCK_DETECTION;\n}\n\nstatic inline bool cpu_has_vmx_apicv(void)\n{\n\treturn cpu_has_vmx_apic_register_virt() &&\n\t\tcpu_has_vmx_virtual_intr_delivery() &&\n\t\tcpu_has_vmx_posted_intr();\n}\n\nstatic inline bool cpu_has_vmx_ipiv(void)\n{\n\treturn vmcs_config.cpu_based_3rd_exec_ctrl & TERTIARY_EXEC_IPI_VIRT;\n}\n\nstatic inline bool cpu_has_vmx_flexpriority(void)\n{\n\treturn cpu_has_vmx_tpr_shadow() &&\n\t\tcpu_has_vmx_virtualize_apic_accesses();\n}\n\nstatic inline bool cpu_has_vmx_ept_execute_only(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXECUTE_ONLY_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_4levels(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_PAGE_WALK_4_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_5levels(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_PAGE_WALK_5_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_mt_wb(void)\n{\n\treturn vmx_capability.ept & VMX_EPTP_WB_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_2m_page(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_2MB_PAGE_BIT;\n}\n\nstatic inline bool cpu_has_vmx_ept_1g_page(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_1GB_PAGE_BIT;\n}\n\nstatic inline int ept_caps_to_lpage_level(u32 ept_caps)\n{\n\tif (ept_caps & VMX_EPT_1GB_PAGE_BIT)\n\t\treturn PG_LEVEL_1G;\n\tif (ept_caps & VMX_EPT_2MB_PAGE_BIT)\n\t\treturn PG_LEVEL_2M;\n\treturn PG_LEVEL_4K;\n}\n\nstatic inline bool cpu_has_vmx_ept_ad_bits(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_AD_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invept_context(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_CONTEXT_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invept_global(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_GLOBAL_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invvpid(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_INVVPID_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invvpid_individual_addr(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_INDIVIDUAL_ADDR_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invvpid_single(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_SINGLE_CONTEXT_BIT;\n}\n\nstatic inline bool cpu_has_vmx_invvpid_global(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT;\n}\n\nstatic inline bool cpu_has_vmx_intel_pt(void)\n{\n\treturn (vmcs_config.misc & MSR_IA32_VMX_MISC_INTEL_PT) &&\n\t\t(vmcs_config.cpu_based_2nd_exec_ctrl & SECONDARY_EXEC_PT_USE_GPA) &&\n\t\t(vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_RTIT_CTL);\n}\n\n \nstatic inline bool vmx_pt_mode_is_system(void)\n{\n\treturn pt_mode == PT_MODE_SYSTEM;\n}\nstatic inline bool vmx_pt_mode_is_host_guest(void)\n{\n\treturn pt_mode == PT_MODE_HOST_GUEST;\n}\n\nstatic inline bool vmx_pebs_supported(void)\n{\n\treturn boot_cpu_has(X86_FEATURE_PEBS) && kvm_pmu_cap.pebs_ept;\n}\n\nstatic inline bool cpu_has_notify_vmexit(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_NOTIFY_VM_EXITING;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}