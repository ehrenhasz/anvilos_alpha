{
  "module_name": "vmx_ops.h",
  "hash_id": "a0324e7f75de04527beec901024632fe5a83838ba6b92e44da6f9708b2881270",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/vmx/vmx_ops.h",
  "human_readable_source": " \n#ifndef __KVM_X86_VMX_INSN_H\n#define __KVM_X86_VMX_INSN_H\n\n#include <linux/nospec.h>\n\n#include <asm/vmx.h>\n\n#include \"hyperv.h\"\n#include \"vmcs.h\"\n#include \"../x86.h\"\n\nvoid vmread_error(unsigned long field);\nvoid vmwrite_error(unsigned long field, unsigned long value);\nvoid vmclear_error(struct vmcs *vmcs, u64 phys_addr);\nvoid vmptrld_error(struct vmcs *vmcs, u64 phys_addr);\nvoid invvpid_error(unsigned long ext, u16 vpid, gva_t gva);\nvoid invept_error(unsigned long ext, u64 eptp, gpa_t gpa);\n\n#ifndef CONFIG_CC_HAS_ASM_GOTO_OUTPUT\n \nextern unsigned long vmread_error_trampoline;\n\n \nvoid vmread_error_trampoline2(unsigned long field, bool fault);\n\n#endif\n\nstatic __always_inline void vmcs_check16(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"16-bit accessor invalid for 64-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"16-bit accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"16-bit accessor invalid for 32-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"16-bit accessor invalid for natural width field\");\n}\n\nstatic __always_inline void vmcs_check32(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"32-bit accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"32-bit accessor invalid for 64-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"32-bit accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"32-bit accessor invalid for natural width field\");\n}\n\nstatic __always_inline void vmcs_check64(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"64-bit accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"64-bit accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"64-bit accessor invalid for 32-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"64-bit accessor invalid for natural width field\");\n}\n\nstatic __always_inline void vmcs_checkl(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"Natural width accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"Natural width accessor invalid for 64-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"Natural width accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"Natural width accessor invalid for 32-bit field\");\n}\n\nstatic __always_inline unsigned long __vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n#ifdef CONFIG_CC_HAS_ASM_GOTO_OUTPUT\n\n\tasm_volatile_goto(\"1: vmread %[field], %[output]\\n\\t\"\n\t\t\t  \"jna %l[do_fail]\\n\\t\"\n\n\t\t\t  _ASM_EXTABLE(1b, %l[do_exception])\n\n\t\t\t  : [output] \"=r\" (value)\n\t\t\t  : [field] \"r\" (field)\n\t\t\t  : \"cc\"\n\t\t\t  : do_fail, do_exception);\n\n\treturn value;\n\ndo_fail:\n\tinstrumentation_begin();\n\tvmread_error(field);\n\tinstrumentation_end();\n\treturn 0;\n\ndo_exception:\n\tkvm_spurious_fault();\n\treturn 0;\n\n#else  \n\n\tasm volatile(\"1: vmread %2, %1\\n\\t\"\n\t\t     \".byte 0x3e\\n\\t\"  \n\t\t     \"ja 3f\\n\\t\"\n\n\t\t      \n\t\t     \"xorl %k1, %k1\\n\\t\"\n\t\t     \"2:\\n\\t\"\n\t\t     \"push %1\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"call vmread_error_trampoline\\n\\t\"\n\n\t\t      \n\t\t     \"pop %2\\n\\t\"\n\t\t     \"pop %1\\n\\t\"\n\t\t     \"3:\\n\\t\"\n\n\t\t      \n\t\t     _ASM_EXTABLE_TYPE_REG(1b, 2b, EX_TYPE_ONE_REG, %1)\n\n\t\t     : ASM_CALL_CONSTRAINT, \"=&r\"(value) : \"r\"(field) : \"cc\");\n\treturn value;\n\n#endif  \n}\n\nstatic __always_inline u16 vmcs_read16(unsigned long field)\n{\n\tvmcs_check16(field);\n\tif (kvm_is_using_evmcs())\n\t\treturn evmcs_read16(field);\n\treturn __vmcs_readl(field);\n}\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (kvm_is_using_evmcs())\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}\n\nstatic __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n\tif (kvm_is_using_evmcs())\n\t\treturn evmcs_read64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (kvm_is_using_evmcs())\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}\n\n#define vmx_asm1(insn, op1, error_args...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tasm_volatile_goto(\"1: \" __stringify(insn) \" %0\\n\\t\"\t\t\\\n\t\t\t  \".byte 0x2e\\n\\t\"  \t\\\n\t\t\t  \"jna %l[error]\\n\\t\"\t\t\t\t\\\n\t\t\t  _ASM_EXTABLE(1b, %l[fault])\t\t\t\\\n\t\t\t  : : op1 : \"cc\" : error, fault);\t\t\\\n\treturn;\t\t\t\t\t\t\t\t\\\nerror:\t\t\t\t\t\t\t\t\t\\\n\tinstrumentation_begin();\t\t\t\t\t\\\n\tinsn##_error(error_args);\t\t\t\t\t\\\n\tinstrumentation_end();\t\t\t\t\t\t\\\n\treturn;\t\t\t\t\t\t\t\t\\\nfault:\t\t\t\t\t\t\t\t\t\\\n\tkvm_spurious_fault();\t\t\t\t\t\t\\\n} while (0)\n\n#define vmx_asm2(insn, op1, op2, error_args...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tasm_volatile_goto(\"1: \"  __stringify(insn) \" %1, %0\\n\\t\"\t\\\n\t\t\t  \".byte 0x2e\\n\\t\"  \t\\\n\t\t\t  \"jna %l[error]\\n\\t\"\t\t\t\t\\\n\t\t\t  _ASM_EXTABLE(1b, %l[fault])\t\t\t\\\n\t\t\t  : : op1, op2 : \"cc\" : error, fault);\t\t\\\n\treturn;\t\t\t\t\t\t\t\t\\\nerror:\t\t\t\t\t\t\t\t\t\\\n\tinstrumentation_begin();\t\t\t\t\t\\\n\tinsn##_error(error_args);\t\t\t\t\t\\\n\tinstrumentation_end();\t\t\t\t\t\t\\\n\treturn;\t\t\t\t\t\t\t\t\\\nfault:\t\t\t\t\t\t\t\t\t\\\n\tkvm_spurious_fault();\t\t\t\t\t\t\\\n} while (0)\n\nstatic __always_inline void __vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmx_asm2(vmwrite, \"r\"(field), \"rm\"(value), field, value);\n}\n\nstatic __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (kvm_is_using_evmcs())\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (kvm_is_using_evmcs())\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}\n\nstatic __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (kvm_is_using_evmcs())\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (kvm_is_using_evmcs())\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\tif (kvm_is_using_evmcs())\n\t\treturn evmcs_write32(field, evmcs_read32(field) & ~mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (kvm_is_using_evmcs())\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}\n\nstatic inline void vmcs_clear(struct vmcs *vmcs)\n{\n\tu64 phys_addr = __pa(vmcs);\n\n\tvmx_asm1(vmclear, \"m\"(phys_addr), vmcs, phys_addr);\n}\n\nstatic inline void vmcs_load(struct vmcs *vmcs)\n{\n\tu64 phys_addr = __pa(vmcs);\n\n\tif (kvm_is_using_evmcs())\n\t\treturn evmcs_load(phys_addr);\n\n\tvmx_asm1(vmptrld, \"m\"(phys_addr), vmcs, phys_addr);\n}\n\nstatic inline void __invvpid(unsigned long ext, u16 vpid, gva_t gva)\n{\n\tstruct {\n\t\tu64 vpid : 16;\n\t\tu64 rsvd : 48;\n\t\tu64 gva;\n\t} operand = { vpid, 0, gva };\n\n\tvmx_asm2(invvpid, \"r\"(ext), \"m\"(operand), ext, vpid, gva);\n}\n\nstatic inline void __invept(unsigned long ext, u64 eptp, gpa_t gpa)\n{\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand = {eptp, gpa};\n\n\tvmx_asm2(invept, \"r\"(ext), \"m\"(operand), ext, eptp, gpa);\n}\n\nstatic inline void vpid_sync_vcpu_single(int vpid)\n{\n\tif (vpid == 0)\n\t\treturn;\n\n\t__invvpid(VMX_VPID_EXTENT_SINGLE_CONTEXT, vpid, 0);\n}\n\nstatic inline void vpid_sync_vcpu_global(void)\n{\n\t__invvpid(VMX_VPID_EXTENT_ALL_CONTEXT, 0, 0);\n}\n\nstatic inline void vpid_sync_context(int vpid)\n{\n\tif (cpu_has_vmx_invvpid_single())\n\t\tvpid_sync_vcpu_single(vpid);\n\telse if (vpid != 0)\n\t\tvpid_sync_vcpu_global();\n}\n\nstatic inline void vpid_sync_vcpu_addr(int vpid, gva_t addr)\n{\n\tif (vpid == 0)\n\t\treturn;\n\n\tif (cpu_has_vmx_invvpid_individual_addr())\n\t\t__invvpid(VMX_VPID_EXTENT_INDIVIDUAL_ADDR, vpid, addr);\n\telse\n\t\tvpid_sync_context(vpid);\n}\n\nstatic inline void ept_sync_global(void)\n{\n\t__invept(VMX_EPT_EXTENT_GLOBAL, 0, 0);\n}\n\nstatic inline void ept_sync_context(u64 eptp)\n{\n\tif (cpu_has_vmx_invept_context())\n\t\t__invept(VMX_EPT_EXTENT_CONTEXT, eptp, 0);\n\telse\n\t\tept_sync_global();\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}