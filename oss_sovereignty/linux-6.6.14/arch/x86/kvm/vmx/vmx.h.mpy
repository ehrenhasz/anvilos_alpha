{
  "module_name": "vmx.h",
  "hash_id": "3780bc4e3ed57f2a70b8305a8d2c7c5ce04f8b923c2cb3071c3452e4779aa526",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/vmx/vmx.h",
  "human_readable_source": " \n#ifndef __KVM_X86_VMX_H\n#define __KVM_X86_VMX_H\n\n#include <linux/kvm_host.h>\n\n#include <asm/kvm.h>\n#include <asm/intel_pt.h>\n#include <asm/perf_event.h>\n\n#include \"capabilities.h\"\n#include \"../kvm_cache_regs.h\"\n#include \"posted_intr.h\"\n#include \"vmcs.h\"\n#include \"vmx_ops.h\"\n#include \"../cpuid.h\"\n#include \"run_flags.h\"\n\n#define MSR_TYPE_R\t1\n#define MSR_TYPE_W\t2\n#define MSR_TYPE_RW\t3\n\n#define X2APIC_MSR(r) (APIC_BASE_MSR + ((r) >> 4))\n\n#ifdef CONFIG_X86_64\n#define MAX_NR_USER_RETURN_MSRS\t7\n#else\n#define MAX_NR_USER_RETURN_MSRS\t4\n#endif\n\n#define MAX_NR_LOADSTORE_MSRS\t8\n\nstruct vmx_msrs {\n\tunsigned int\t\tnr;\n\tstruct vmx_msr_entry\tval[MAX_NR_LOADSTORE_MSRS];\n};\n\nstruct vmx_uret_msr {\n\tbool load_into_hardware;\n\tu64 data;\n\tu64 mask;\n};\n\nenum segment_cache_field {\n\tSEG_FIELD_SEL = 0,\n\tSEG_FIELD_BASE = 1,\n\tSEG_FIELD_LIMIT = 2,\n\tSEG_FIELD_AR = 3,\n\n\tSEG_FIELD_NR = 4\n};\n\n#define RTIT_ADDR_RANGE\t\t4\n\nstruct pt_ctx {\n\tu64 ctl;\n\tu64 status;\n\tu64 output_base;\n\tu64 output_mask;\n\tu64 cr3_match;\n\tu64 addr_a[RTIT_ADDR_RANGE];\n\tu64 addr_b[RTIT_ADDR_RANGE];\n};\n\nstruct pt_desc {\n\tu64 ctl_bitmask;\n\tu32 num_address_ranges;\n\tu32 caps[PT_CPUID_REGS_NUM * PT_CPUID_LEAVES];\n\tstruct pt_ctx host;\n\tstruct pt_ctx guest;\n};\n\nunion vmx_exit_reason {\n\tstruct {\n\t\tu32\tbasic\t\t\t: 16;\n\t\tu32\treserved16\t\t: 1;\n\t\tu32\treserved17\t\t: 1;\n\t\tu32\treserved18\t\t: 1;\n\t\tu32\treserved19\t\t: 1;\n\t\tu32\treserved20\t\t: 1;\n\t\tu32\treserved21\t\t: 1;\n\t\tu32\treserved22\t\t: 1;\n\t\tu32\treserved23\t\t: 1;\n\t\tu32\treserved24\t\t: 1;\n\t\tu32\treserved25\t\t: 1;\n\t\tu32\tbus_lock_detected\t: 1;\n\t\tu32\tenclave_mode\t\t: 1;\n\t\tu32\tsmi_pending_mtf\t\t: 1;\n\t\tu32\tsmi_from_vmx_root\t: 1;\n\t\tu32\treserved30\t\t: 1;\n\t\tu32\tfailed_vmentry\t\t: 1;\n\t};\n\tu32 full;\n};\n\nstruct lbr_desc {\n\t \n\tstruct x86_pmu_lbr records;\n\n\t \n\tstruct perf_event *event;\n\n\t \n\tbool msr_passthrough;\n};\n\n \nstruct nested_vmx {\n\t \n\tbool vmxon;\n\tgpa_t vmxon_ptr;\n\tbool pml_full;\n\n\t \n\tgpa_t current_vmptr;\n\t \n\tstruct vmcs12 *cached_vmcs12;\n\t \n\tstruct vmcs12 *cached_shadow_vmcs12;\n\n\t \n\tstruct gfn_to_hva_cache shadow_vmcs12_cache;\n\n\t \n\tstruct gfn_to_hva_cache vmcs12_cache;\n\n\t \n\tbool need_vmcs12_to_shadow_sync;\n\tbool dirty_vmcs12;\n\n\t \n\tbool force_msr_bitmap_recalc;\n\n\t \n\tbool need_sync_vmcs02_to_vmcs12_rare;\n\n\t \n\tbool vmcs02_initialized;\n\n\tbool change_vmcs01_virtual_apic_mode;\n\tbool reload_vmcs01_apic_access_page;\n\tbool update_vmcs01_cpu_dirty_logging;\n\tbool update_vmcs01_apicv_status;\n\n\t \n\tbool enlightened_vmcs_enabled;\n\n\t \n\tbool nested_run_pending;\n\n\t \n\tbool mtf_pending;\n\n\tstruct loaded_vmcs vmcs02;\n\n\t \n\tstruct kvm_host_map apic_access_page_map;\n\tstruct kvm_host_map virtual_apic_map;\n\tstruct kvm_host_map pi_desc_map;\n\n\tstruct kvm_host_map msr_bitmap_map;\n\n\tstruct pi_desc *pi_desc;\n\tbool pi_pending;\n\tu16 posted_intr_nv;\n\n\tstruct hrtimer preemption_timer;\n\tu64 preemption_timer_deadline;\n\tbool has_preemption_timer_deadline;\n\tbool preemption_timer_expired;\n\n\t \n\tu64 pre_vmenter_debugctl;\n\tu64 pre_vmenter_bndcfgs;\n\n\t \n\tint l1_tpr_threshold;\n\n\tu16 vpid02;\n\tu16 last_vpid;\n\n\tstruct nested_vmx_msrs msrs;\n\n\t \n\tstruct {\n\t\t \n\t\tbool vmxon;\n\t\t \n\t\tbool guest_mode;\n\t} smm;\n\n\tgpa_t hv_evmcs_vmptr;\n\tstruct kvm_host_map hv_evmcs_map;\n\tstruct hv_enlightened_vmcs *hv_evmcs;\n};\n\nstruct vcpu_vmx {\n\tstruct kvm_vcpu       vcpu;\n\tu8                    fail;\n\tu8\t\t      x2apic_msr_bitmap_mode;\n\n\t \n\tbool\t\t      guest_state_loaded;\n\n\tunsigned long         exit_qualification;\n\tu32                   exit_intr_info;\n\tu32                   idt_vectoring_info;\n\tulong                 rflags;\n\n\t \n\tstruct vmx_uret_msr   guest_uret_msrs[MAX_NR_USER_RETURN_MSRS];\n\tbool                  guest_uret_msrs_loaded;\n#ifdef CONFIG_X86_64\n\tu64\t\t      msr_host_kernel_gs_base;\n\tu64\t\t      msr_guest_kernel_gs_base;\n#endif\n\n\tu64\t\t      spec_ctrl;\n\tu32\t\t      msr_ia32_umwait_control;\n\n\t \n\tstruct loaded_vmcs    vmcs01;\n\tstruct loaded_vmcs   *loaded_vmcs;\n\n\tstruct msr_autoload {\n\t\tstruct vmx_msrs guest;\n\t\tstruct vmx_msrs host;\n\t} msr_autoload;\n\n\tstruct msr_autostore {\n\t\tstruct vmx_msrs guest;\n\t} msr_autostore;\n\n\tstruct {\n\t\tint vm86_active;\n\t\tulong save_rflags;\n\t\tstruct kvm_segment segs[8];\n\t} rmode;\n\tstruct {\n\t\tu32 bitmask;  \n\t\tstruct kvm_save_segment {\n\t\t\tu16 selector;\n\t\t\tunsigned long base;\n\t\t\tu32 limit;\n\t\t\tu32 ar;\n\t\t} seg[8];\n\t} segment_cache;\n\tint vpid;\n\tbool emulation_required;\n\n\tunion vmx_exit_reason exit_reason;\n\n\t \n\tstruct pi_desc pi_desc;\n\n\t \n\tstruct list_head pi_wakeup_list;\n\n\t \n\tstruct nested_vmx nested;\n\n\t \n\tunsigned int ple_window;\n\tbool ple_window_dirty;\n\n\tbool req_immediate_exit;\n\n\t \n#define PML_ENTITY_NUM\t\t512\n\tstruct page *pml_pg;\n\n\t \n\tu64 hv_deadline_tsc;\n\n\tunsigned long host_debugctlmsr;\n\n\t \n\tu64 msr_ia32_feature_control;\n\tu64 msr_ia32_feature_control_valid_bits;\n\t \n\tu64 msr_ia32_sgxlepubkeyhash[4];\n\tu64 msr_ia32_mcu_opt_ctrl;\n\tbool disable_fb_clear;\n\n\tstruct pt_desc pt_desc;\n\tstruct lbr_desc lbr_desc;\n\n\t \n#define MAX_POSSIBLE_PASSTHROUGH_MSRS\t16\n\tstruct {\n\t\tDECLARE_BITMAP(read, MAX_POSSIBLE_PASSTHROUGH_MSRS);\n\t\tDECLARE_BITMAP(write, MAX_POSSIBLE_PASSTHROUGH_MSRS);\n\t} shadow_msr_intercept;\n};\n\nstruct kvm_vmx {\n\tstruct kvm kvm;\n\n\tunsigned int tss_addr;\n\tbool ept_identity_pagetable_done;\n\tgpa_t ept_identity_map_addr;\n\t \n\tu64 *pid_table;\n};\n\nvoid vmx_vcpu_load_vmcs(struct kvm_vcpu *vcpu, int cpu,\n\t\t\tstruct loaded_vmcs *buddy);\nint allocate_vpid(void);\nvoid free_vpid(int vpid);\nvoid vmx_set_constant_host_state(struct vcpu_vmx *vmx);\nvoid vmx_prepare_switch_to_guest(struct kvm_vcpu *vcpu);\nvoid vmx_set_host_fs_gs(struct vmcs_host_state *host, u16 fs_sel, u16 gs_sel,\n\t\t\tunsigned long fs_base, unsigned long gs_base);\nint vmx_get_cpl(struct kvm_vcpu *vcpu);\nbool vmx_emulation_required(struct kvm_vcpu *vcpu);\nunsigned long vmx_get_rflags(struct kvm_vcpu *vcpu);\nvoid vmx_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nu32 vmx_get_interrupt_shadow(struct kvm_vcpu *vcpu);\nvoid vmx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask);\nint vmx_set_efer(struct kvm_vcpu *vcpu, u64 efer);\nvoid vmx_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nvoid vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4);\nvoid set_cr4_guest_host_mask(struct vcpu_vmx *vmx);\nvoid ept_save_pdptrs(struct kvm_vcpu *vcpu);\nvoid vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg);\nvoid __vmx_set_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg);\nu64 construct_eptp(struct kvm_vcpu *vcpu, hpa_t root_hpa, int root_level);\n\nbool vmx_guest_inject_ac(struct kvm_vcpu *vcpu);\nvoid vmx_update_exception_bitmap(struct kvm_vcpu *vcpu);\nbool vmx_nmi_blocked(struct kvm_vcpu *vcpu);\nbool vmx_interrupt_blocked(struct kvm_vcpu *vcpu);\nbool vmx_get_nmi_mask(struct kvm_vcpu *vcpu);\nvoid vmx_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked);\nvoid vmx_set_virtual_apic_mode(struct kvm_vcpu *vcpu);\nstruct vmx_uret_msr *vmx_find_uret_msr(struct vcpu_vmx *vmx, u32 msr);\nvoid pt_update_intercept_for_msr(struct kvm_vcpu *vcpu);\nvoid vmx_update_host_rsp(struct vcpu_vmx *vmx, unsigned long host_rsp);\nvoid vmx_spec_ctrl_restore_host(struct vcpu_vmx *vmx, unsigned int flags);\nunsigned int __vmx_vcpu_run_flags(struct vcpu_vmx *vmx);\nbool __vmx_vcpu_run(struct vcpu_vmx *vmx, unsigned long *regs,\n\t\t    unsigned int flags);\nint vmx_find_loadstore_msr_slot(struct vmx_msrs *m, u32 msr);\nvoid vmx_ept_load_pdptrs(struct kvm_vcpu *vcpu);\n\nvoid vmx_disable_intercept_for_msr(struct kvm_vcpu *vcpu, u32 msr, int type);\nvoid vmx_enable_intercept_for_msr(struct kvm_vcpu *vcpu, u32 msr, int type);\n\nu64 vmx_get_l2_tsc_offset(struct kvm_vcpu *vcpu);\nu64 vmx_get_l2_tsc_multiplier(struct kvm_vcpu *vcpu);\n\nstatic inline void vmx_set_intercept_for_msr(struct kvm_vcpu *vcpu, u32 msr,\n\t\t\t\t\t     int type, bool value)\n{\n\tif (value)\n\t\tvmx_enable_intercept_for_msr(vcpu, msr, type);\n\telse\n\t\tvmx_disable_intercept_for_msr(vcpu, msr, type);\n}\n\nvoid vmx_update_cpu_dirty_logging(struct kvm_vcpu *vcpu);\n\n \n#define __BUILD_VMX_MSR_BITMAP_HELPER(rtype, action, bitop, access, base)      \\\nstatic inline rtype vmx_##action##_msr_bitmap_##access(unsigned long *bitmap,  \\\n\t\t\t\t\t\t       u32 msr)\t\t       \\\n{\t\t\t\t\t\t\t\t\t       \\\n\tint f = sizeof(unsigned long);\t\t\t\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\tif (msr <= 0x1fff)\t\t\t\t\t\t       \\\n\t\treturn bitop##_bit(msr, bitmap + base / f);\t\t       \\\n\telse if ((msr >= 0xc0000000) && (msr <= 0xc0001fff))\t\t       \\\n\t\treturn bitop##_bit(msr & 0x1fff, bitmap + (base + 0x400) / f); \\\n\treturn (rtype)true;\t\t\t\t\t\t       \\\n}\n#define BUILD_VMX_MSR_BITMAP_HELPERS(ret_type, action, bitop)\t\t       \\\n\t__BUILD_VMX_MSR_BITMAP_HELPER(ret_type, action, bitop, read,  0x0)     \\\n\t__BUILD_VMX_MSR_BITMAP_HELPER(ret_type, action, bitop, write, 0x800)\n\nBUILD_VMX_MSR_BITMAP_HELPERS(bool, test, test)\nBUILD_VMX_MSR_BITMAP_HELPERS(void, clear, __clear)\nBUILD_VMX_MSR_BITMAP_HELPERS(void, set, __set)\n\nstatic inline u8 vmx_get_rvi(void)\n{\n\treturn vmcs_read16(GUEST_INTR_STATUS) & 0xff;\n}\n\n#define __KVM_REQUIRED_VMX_VM_ENTRY_CONTROLS\t\t\t\t\\\n\t(VM_ENTRY_LOAD_DEBUG_CONTROLS)\n#ifdef CONFIG_X86_64\n\t#define KVM_REQUIRED_VMX_VM_ENTRY_CONTROLS\t\t\t\\\n\t\t(__KVM_REQUIRED_VMX_VM_ENTRY_CONTROLS |\t\t\t\\\n\t\t VM_ENTRY_IA32E_MODE)\n#else\n\t#define KVM_REQUIRED_VMX_VM_ENTRY_CONTROLS\t\t\t\\\n\t\t__KVM_REQUIRED_VMX_VM_ENTRY_CONTROLS\n#endif\n#define KVM_OPTIONAL_VMX_VM_ENTRY_CONTROLS\t\t\t\t\\\n\t(VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL |\t\t\t\t\\\n\t VM_ENTRY_LOAD_IA32_PAT |\t\t\t\t\t\\\n\t VM_ENTRY_LOAD_IA32_EFER |\t\t\t\t\t\\\n\t VM_ENTRY_LOAD_BNDCFGS |\t\t\t\t\t\\\n\t VM_ENTRY_PT_CONCEAL_PIP |\t\t\t\t\t\\\n\t VM_ENTRY_LOAD_IA32_RTIT_CTL)\n\n#define __KVM_REQUIRED_VMX_VM_EXIT_CONTROLS\t\t\t\t\\\n\t(VM_EXIT_SAVE_DEBUG_CONTROLS |\t\t\t\t\t\\\n\t VM_EXIT_ACK_INTR_ON_EXIT)\n#ifdef CONFIG_X86_64\n\t#define KVM_REQUIRED_VMX_VM_EXIT_CONTROLS\t\t\t\\\n\t\t(__KVM_REQUIRED_VMX_VM_EXIT_CONTROLS |\t\t\t\\\n\t\t VM_EXIT_HOST_ADDR_SPACE_SIZE)\n#else\n\t#define KVM_REQUIRED_VMX_VM_EXIT_CONTROLS\t\t\t\\\n\t\t__KVM_REQUIRED_VMX_VM_EXIT_CONTROLS\n#endif\n#define KVM_OPTIONAL_VMX_VM_EXIT_CONTROLS\t\t\t\t\\\n\t      (VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL |\t\t\t\\\n\t       VM_EXIT_SAVE_IA32_PAT |\t\t\t\t\t\\\n\t       VM_EXIT_LOAD_IA32_PAT |\t\t\t\t\t\\\n\t       VM_EXIT_SAVE_IA32_EFER |\t\t\t\t\t\\\n\t       VM_EXIT_SAVE_VMX_PREEMPTION_TIMER |\t\t\t\\\n\t       VM_EXIT_LOAD_IA32_EFER |\t\t\t\t\t\\\n\t       VM_EXIT_CLEAR_BNDCFGS |\t\t\t\t\t\\\n\t       VM_EXIT_PT_CONCEAL_PIP |\t\t\t\t\t\\\n\t       VM_EXIT_CLEAR_IA32_RTIT_CTL)\n\n#define KVM_REQUIRED_VMX_PIN_BASED_VM_EXEC_CONTROL\t\t\t\\\n\t(PIN_BASED_EXT_INTR_MASK |\t\t\t\t\t\\\n\t PIN_BASED_NMI_EXITING)\n#define KVM_OPTIONAL_VMX_PIN_BASED_VM_EXEC_CONTROL\t\t\t\\\n\t(PIN_BASED_VIRTUAL_NMIS |\t\t\t\t\t\\\n\t PIN_BASED_POSTED_INTR |\t\t\t\t\t\\\n\t PIN_BASED_VMX_PREEMPTION_TIMER)\n\n#define __KVM_REQUIRED_VMX_CPU_BASED_VM_EXEC_CONTROL\t\t\t\\\n\t(CPU_BASED_HLT_EXITING |\t\t\t\t\t\\\n\t CPU_BASED_CR3_LOAD_EXITING |\t\t\t\t\t\\\n\t CPU_BASED_CR3_STORE_EXITING |\t\t\t\t\t\\\n\t CPU_BASED_UNCOND_IO_EXITING |\t\t\t\t\t\\\n\t CPU_BASED_MOV_DR_EXITING |\t\t\t\t\t\\\n\t CPU_BASED_USE_TSC_OFFSETTING |\t\t\t\t\t\\\n\t CPU_BASED_MWAIT_EXITING |\t\t\t\t\t\\\n\t CPU_BASED_MONITOR_EXITING |\t\t\t\t\t\\\n\t CPU_BASED_INVLPG_EXITING |\t\t\t\t\t\\\n\t CPU_BASED_RDPMC_EXITING |\t\t\t\t\t\\\n\t CPU_BASED_INTR_WINDOW_EXITING)\n\n#ifdef CONFIG_X86_64\n\t#define KVM_REQUIRED_VMX_CPU_BASED_VM_EXEC_CONTROL\t\t\\\n\t\t(__KVM_REQUIRED_VMX_CPU_BASED_VM_EXEC_CONTROL |\t\t\\\n\t\t CPU_BASED_CR8_LOAD_EXITING |\t\t\t\t\\\n\t\t CPU_BASED_CR8_STORE_EXITING)\n#else\n\t#define KVM_REQUIRED_VMX_CPU_BASED_VM_EXEC_CONTROL\t\t\\\n\t\t__KVM_REQUIRED_VMX_CPU_BASED_VM_EXEC_CONTROL\n#endif\n\n#define KVM_OPTIONAL_VMX_CPU_BASED_VM_EXEC_CONTROL\t\t\t\\\n\t(CPU_BASED_RDTSC_EXITING |\t\t\t\t\t\\\n\t CPU_BASED_TPR_SHADOW |\t\t\t\t\t\t\\\n\t CPU_BASED_USE_IO_BITMAPS |\t\t\t\t\t\\\n\t CPU_BASED_MONITOR_TRAP_FLAG |\t\t\t\t\t\\\n\t CPU_BASED_USE_MSR_BITMAPS |\t\t\t\t\t\\\n\t CPU_BASED_NMI_WINDOW_EXITING |\t\t\t\t\t\\\n\t CPU_BASED_PAUSE_EXITING |\t\t\t\t\t\\\n\t CPU_BASED_ACTIVATE_SECONDARY_CONTROLS |\t\t\t\\\n\t CPU_BASED_ACTIVATE_TERTIARY_CONTROLS)\n\n#define KVM_REQUIRED_VMX_SECONDARY_VM_EXEC_CONTROL 0\n#define KVM_OPTIONAL_VMX_SECONDARY_VM_EXEC_CONTROL\t\t\t\\\n\t(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\t\t\t\\\n\t SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\t\t\t\\\n\t SECONDARY_EXEC_WBINVD_EXITING |\t\t\t\t\\\n\t SECONDARY_EXEC_ENABLE_VPID |\t\t\t\t\t\\\n\t SECONDARY_EXEC_ENABLE_EPT |\t\t\t\t\t\\\n\t SECONDARY_EXEC_UNRESTRICTED_GUEST |\t\t\t\t\\\n\t SECONDARY_EXEC_PAUSE_LOOP_EXITING |\t\t\t\t\\\n\t SECONDARY_EXEC_DESC |\t\t\t\t\t\t\\\n\t SECONDARY_EXEC_ENABLE_RDTSCP |\t\t\t\t\t\\\n\t SECONDARY_EXEC_ENABLE_INVPCID |\t\t\t\t\\\n\t SECONDARY_EXEC_APIC_REGISTER_VIRT |\t\t\t\t\\\n\t SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |\t\t\t\t\\\n\t SECONDARY_EXEC_SHADOW_VMCS |\t\t\t\t\t\\\n\t SECONDARY_EXEC_ENABLE_XSAVES |\t\t\t\t\t\\\n\t SECONDARY_EXEC_RDSEED_EXITING |\t\t\t\t\\\n\t SECONDARY_EXEC_RDRAND_EXITING |\t\t\t\t\\\n\t SECONDARY_EXEC_ENABLE_PML |\t\t\t\t\t\\\n\t SECONDARY_EXEC_TSC_SCALING |\t\t\t\t\t\\\n\t SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE |\t\t\t\t\\\n\t SECONDARY_EXEC_PT_USE_GPA |\t\t\t\t\t\\\n\t SECONDARY_EXEC_PT_CONCEAL_VMX |\t\t\t\t\\\n\t SECONDARY_EXEC_ENABLE_VMFUNC |\t\t\t\t\t\\\n\t SECONDARY_EXEC_BUS_LOCK_DETECTION |\t\t\t\t\\\n\t SECONDARY_EXEC_NOTIFY_VM_EXITING |\t\t\t\t\\\n\t SECONDARY_EXEC_ENCLS_EXITING)\n\n#define KVM_REQUIRED_VMX_TERTIARY_VM_EXEC_CONTROL 0\n#define KVM_OPTIONAL_VMX_TERTIARY_VM_EXEC_CONTROL\t\t\t\\\n\t(TERTIARY_EXEC_IPI_VIRT)\n\n#define BUILD_CONTROLS_SHADOW(lname, uname, bits)\t\t\t\t\t\t\\\nstatic inline void lname##_controls_set(struct vcpu_vmx *vmx, u##bits val)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (vmx->loaded_vmcs->controls_shadow.lname != val) {\t\t\t\t\t\\\n\t\tvmcs_write##bits(uname, val);\t\t\t\t\t\t\t\\\n\t\tvmx->loaded_vmcs->controls_shadow.lname = val;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\t\t\\\nstatic inline u##bits __##lname##_controls_get(struct loaded_vmcs *vmcs)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\\\n\treturn vmcs->controls_shadow.lname;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\t\t\\\nstatic inline u##bits lname##_controls_get(struct vcpu_vmx *vmx)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\\\n\treturn __##lname##_controls_get(vmx->loaded_vmcs);\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\t\t\\\nstatic __always_inline void lname##_controls_setbit(struct vcpu_vmx *vmx, u##bits val)\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tBUILD_BUG_ON(!(val & (KVM_REQUIRED_VMX_##uname | KVM_OPTIONAL_VMX_##uname)));\t\t\\\n\tlname##_controls_set(vmx, lname##_controls_get(vmx) | val);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\t\t\\\nstatic __always_inline void lname##_controls_clearbit(struct vcpu_vmx *vmx, u##bits val)\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tBUILD_BUG_ON(!(val & (KVM_REQUIRED_VMX_##uname | KVM_OPTIONAL_VMX_##uname)));\t\t\\\n\tlname##_controls_set(vmx, lname##_controls_get(vmx) & ~val);\t\t\t\t\\\n}\nBUILD_CONTROLS_SHADOW(vm_entry, VM_ENTRY_CONTROLS, 32)\nBUILD_CONTROLS_SHADOW(vm_exit, VM_EXIT_CONTROLS, 32)\nBUILD_CONTROLS_SHADOW(pin, PIN_BASED_VM_EXEC_CONTROL, 32)\nBUILD_CONTROLS_SHADOW(exec, CPU_BASED_VM_EXEC_CONTROL, 32)\nBUILD_CONTROLS_SHADOW(secondary_exec, SECONDARY_VM_EXEC_CONTROL, 32)\nBUILD_CONTROLS_SHADOW(tertiary_exec, TERTIARY_VM_EXEC_CONTROL, 64)\n\n \n#define VMX_REGS_LAZY_LOAD_SET\t((1 << VCPU_REGS_RIP) |         \\\n\t\t\t\t(1 << VCPU_REGS_RSP) |          \\\n\t\t\t\t(1 << VCPU_EXREG_RFLAGS) |      \\\n\t\t\t\t(1 << VCPU_EXREG_PDPTR) |       \\\n\t\t\t\t(1 << VCPU_EXREG_SEGMENTS) |    \\\n\t\t\t\t(1 << VCPU_EXREG_CR0) |         \\\n\t\t\t\t(1 << VCPU_EXREG_CR3) |         \\\n\t\t\t\t(1 << VCPU_EXREG_CR4) |         \\\n\t\t\t\t(1 << VCPU_EXREG_EXIT_INFO_1) | \\\n\t\t\t\t(1 << VCPU_EXREG_EXIT_INFO_2))\n\nstatic inline unsigned long vmx_l1_guest_owned_cr0_bits(void)\n{\n\tunsigned long bits = KVM_POSSIBLE_CR0_GUEST_BITS;\n\n\t \n\tif (!enable_ept)\n\t\tbits &= ~X86_CR0_WP;\n\treturn bits;\n}\n\nstatic __always_inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}\n\nstatic __always_inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}\n\nstatic inline struct lbr_desc *vcpu_to_lbr_desc(struct kvm_vcpu *vcpu)\n{\n\treturn &to_vmx(vcpu)->lbr_desc;\n}\n\nstatic inline struct x86_pmu_lbr *vcpu_to_lbr_records(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu_to_lbr_desc(vcpu)->records;\n}\n\nstatic inline bool intel_pmu_lbr_is_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn !!vcpu_to_lbr_records(vcpu)->nr;\n}\n\nvoid intel_pmu_cross_mapped_check(struct kvm_pmu *pmu);\nint intel_pmu_create_guest_lbr_event(struct kvm_vcpu *vcpu);\nvoid vmx_passthrough_lbr_msrs(struct kvm_vcpu *vcpu);\n\nstatic __always_inline unsigned long vmx_get_exit_qual(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!kvm_register_test_and_mark_available(vcpu, VCPU_EXREG_EXIT_INFO_1))\n\t\tvmx->exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\treturn vmx->exit_qualification;\n}\n\nstatic __always_inline u32 vmx_get_intr_info(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!kvm_register_test_and_mark_available(vcpu, VCPU_EXREG_EXIT_INFO_2))\n\t\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\n\treturn vmx->exit_intr_info;\n}\n\nstruct vmcs *alloc_vmcs_cpu(bool shadow, int cpu, gfp_t flags);\nvoid free_vmcs(struct vmcs *vmcs);\nint alloc_loaded_vmcs(struct loaded_vmcs *loaded_vmcs);\nvoid free_loaded_vmcs(struct loaded_vmcs *loaded_vmcs);\nvoid loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs);\n\nstatic inline struct vmcs *alloc_vmcs(bool shadow)\n{\n\treturn alloc_vmcs_cpu(shadow, raw_smp_processor_id(),\n\t\t\t      GFP_KERNEL_ACCOUNT);\n}\n\nstatic inline bool vmx_has_waitpkg(struct vcpu_vmx *vmx)\n{\n\treturn secondary_exec_controls_get(vmx) &\n\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n}\n\nstatic inline bool vmx_need_pf_intercept(struct kvm_vcpu *vcpu)\n{\n\tif (!enable_ept)\n\t\treturn true;\n\n\treturn allow_smaller_maxphyaddr && cpuid_maxphyaddr(vcpu) < boot_cpu_data.x86_phys_bits;\n}\n\nstatic inline bool is_unrestricted_guest(struct kvm_vcpu *vcpu)\n{\n\treturn enable_unrestricted_guest && (!is_guest_mode(vcpu) ||\n\t    (secondary_exec_controls_get(to_vmx(vcpu)) &\n\t    SECONDARY_EXEC_UNRESTRICTED_GUEST));\n}\n\nbool __vmx_guest_state_valid(struct kvm_vcpu *vcpu);\nstatic inline bool vmx_guest_state_valid(struct kvm_vcpu *vcpu)\n{\n\treturn is_unrestricted_guest(vcpu) || __vmx_guest_state_valid(vcpu);\n}\n\nvoid dump_vmcs(struct kvm_vcpu *vcpu);\n\nstatic inline int vmx_get_instr_info_reg2(u32 vmx_instr_info)\n{\n\treturn (vmx_instr_info >> 28) & 0xf;\n}\n\nstatic inline bool vmx_can_use_ipiv(struct kvm_vcpu *vcpu)\n{\n\treturn  lapic_in_kernel(vcpu) && enable_ipiv;\n}\n\nstatic inline bool guest_cpuid_has_evmcs(struct kvm_vcpu *vcpu)\n{\n\t \n\treturn vcpu->arch.hyperv_enabled &&\n\t       to_vmx(vcpu)->nested.enlightened_vmcs_enabled;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}