{
  "module_name": "nested.h",
  "hash_id": "d3ab85608f823e8ebc07d271f87031529d5ba8adef288f041205ff4b461e7932",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/vmx/nested.h",
  "human_readable_source": " \n#ifndef __KVM_X86_VMX_NESTED_H\n#define __KVM_X86_VMX_NESTED_H\n\n#include \"kvm_cache_regs.h\"\n#include \"vmcs12.h\"\n#include \"vmx.h\"\n\n \nenum nvmx_vmentry_status {\n\tNVMX_VMENTRY_SUCCESS,\t\t \n\tNVMX_VMENTRY_VMFAIL,\t\t \n\tNVMX_VMENTRY_VMEXIT,\t\t \n\tNVMX_VMENTRY_KVM_INTERNAL_ERROR, \n};\n\nvoid vmx_leave_nested(struct kvm_vcpu *vcpu);\nvoid nested_vmx_setup_ctls_msrs(struct vmcs_config *vmcs_conf, u32 ept_caps);\nvoid nested_vmx_hardware_unsetup(void);\n__init int nested_vmx_hardware_setup(int (*exit_handlers[])(struct kvm_vcpu *));\nvoid nested_vmx_set_vmcs_shadowing_bitmap(void);\nvoid nested_vmx_free_vcpu(struct kvm_vcpu *vcpu);\nenum nvmx_vmentry_status nested_vmx_enter_non_root_mode(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t     bool from_vmentry);\nbool nested_vmx_reflect_vmexit(struct kvm_vcpu *vcpu);\nvoid nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 vm_exit_reason,\n\t\t       u32 exit_intr_info, unsigned long exit_qualification);\nvoid nested_sync_vmcs12_to_shadow(struct kvm_vcpu *vcpu);\nint vmx_set_vmx_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 data);\nint vmx_get_vmx_msr(struct nested_vmx_msrs *msrs, u32 msr_index, u64 *pdata);\nint get_vmx_mem_address(struct kvm_vcpu *vcpu, unsigned long exit_qualification,\n\t\t\tu32 vmx_instruction_info, bool wr, int len, gva_t *ret);\nvoid nested_mark_vmcs12_pages_dirty(struct kvm_vcpu *vcpu);\nbool nested_vmx_check_io_bitmaps(struct kvm_vcpu *vcpu, unsigned int port,\n\t\t\t\t int size);\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}\n\nstatic inline struct vmcs12 *get_shadow_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_shadow_vmcs12;\n}\n\n \nstatic inline int vmx_has_valid_vmcs12(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t \n\treturn vmx->nested.current_vmptr != -1ull ||\n\t\tvmx->nested.hv_evmcs_vmptr != EVMPTR_INVALID;\n}\n\nstatic inline u16 nested_get_vpid02(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\treturn vmx->nested.vpid02 ? vmx->nested.vpid02 : vmx->vpid;\n}\n\nstatic inline unsigned long nested_ept_get_eptp(struct kvm_vcpu *vcpu)\n{\n\t \n\treturn get_vmcs12(vcpu)->ept_pointer;\n}\n\nstatic inline bool nested_ept_ad_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn nested_ept_get_eptp(vcpu) & VMX_EPTP_AD_ENABLE_BIT;\n}\n\n \nstatic inline unsigned long nested_read_cr0(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr0 & ~fields->cr0_guest_host_mask) |\n\t\t(fields->cr0_read_shadow & fields->cr0_guest_host_mask);\n}\nstatic inline unsigned long nested_read_cr4(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr4 & ~fields->cr4_guest_host_mask) |\n\t\t(fields->cr4_read_shadow & fields->cr4_guest_host_mask);\n}\n\nstatic inline unsigned nested_cpu_vmx_misc_cr3_count(struct kvm_vcpu *vcpu)\n{\n\treturn vmx_misc_cr3_count(to_vmx(vcpu)->nested.msrs.misc_low);\n}\n\n \nstatic inline bool nested_cpu_has_vmwrite_any_field(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.msrs.misc_low &\n\t\tMSR_IA32_VMX_MISC_VMWRITE_SHADOW_RO_FIELDS;\n}\n\nstatic inline bool nested_cpu_has_zero_length_injection(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.msrs.misc_low & VMX_MISC_ZERO_LEN_INS;\n}\n\nstatic inline bool nested_cpu_supports_monitor_trap_flag(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.msrs.procbased_ctls_high &\n\t\t\tCPU_BASED_MONITOR_TRAP_FLAG;\n}\n\nstatic inline bool nested_cpu_has_vmx_shadow_vmcs(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.msrs.secondary_ctls_high &\n\t\tSECONDARY_EXEC_SHADOW_VMCS;\n}\n\nstatic inline bool nested_cpu_has(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn vmcs12->cpu_based_vm_exec_control & bit;\n}\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}\n\nstatic inline bool nested_cpu_has_preemption_timer(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control &\n\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n}\n\nstatic inline bool nested_cpu_has_nmi_exiting(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_NMI_EXITING;\n}\n\nstatic inline bool nested_cpu_has_virtual_nmis(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_VIRTUAL_NMIS;\n}\n\nstatic inline int nested_cpu_has_mtf(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_TRAP_FLAG);\n}\n\nstatic inline int nested_cpu_has_ept(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_EPT);\n}\n\nstatic inline bool nested_cpu_has_xsaves(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_XSAVES);\n}\n\nstatic inline bool nested_cpu_has_pml(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_PML);\n}\n\nstatic inline bool nested_cpu_has_virt_x2apic_mode(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE);\n}\n\nstatic inline bool nested_cpu_has_vpid(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_VPID);\n}\n\nstatic inline bool nested_cpu_has_apic_reg_virt(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_APIC_REGISTER_VIRT);\n}\n\nstatic inline bool nested_cpu_has_vid(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n}\n\nstatic inline bool nested_cpu_has_posted_intr(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_POSTED_INTR;\n}\n\nstatic inline bool nested_cpu_has_vmfunc(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_VMFUNC);\n}\n\nstatic inline bool nested_cpu_has_eptp_switching(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has_vmfunc(vmcs12) &&\n\t\t(vmcs12->vm_function_control &\n\t\t VMX_VMFUNC_EPTP_SWITCHING);\n}\n\nstatic inline bool nested_cpu_has_shadow_vmcs(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_SHADOW_VMCS);\n}\n\nstatic inline bool nested_cpu_has_save_preemption_timer(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->vm_exit_controls &\n\t    VM_EXIT_SAVE_VMX_PREEMPTION_TIMER;\n}\n\nstatic inline bool nested_exit_on_nmi(struct kvm_vcpu *vcpu)\n{\n\treturn nested_cpu_has_nmi_exiting(get_vmcs12(vcpu));\n}\n\n \nstatic inline bool nested_exit_on_intr(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->pin_based_vm_exec_control &\n\t\tPIN_BASED_EXT_INTR_MASK;\n}\n\nstatic inline bool nested_cpu_has_encls_exit(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENCLS_EXITING);\n}\n\n \nstatic inline bool fixed_bits_valid(u64 val, u64 fixed0, u64 fixed1)\n{\n\treturn ((val & fixed1) | fixed0) == val;\n}\n\nstatic inline bool nested_guest_cr0_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.msrs.cr0_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.msrs.cr0_fixed1;\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (to_vmx(vcpu)->nested.msrs.secondary_ctls_high &\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST &&\n\t    nested_cpu_has2(vmcs12, SECONDARY_EXEC_UNRESTRICTED_GUEST))\n\t\tfixed0 &= ~(X86_CR0_PE | X86_CR0_PG);\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}\n\nstatic inline bool nested_host_cr0_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.msrs.cr0_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.msrs.cr0_fixed1;\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}\n\nstatic inline bool nested_cr4_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.msrs.cr4_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.msrs.cr4_fixed1;\n\n\treturn fixed_bits_valid(val, fixed0, fixed1) &&\n\t       __kvm_is_valid_cr4(vcpu, val);\n}\n\n \n#define nested_guest_cr4_valid\tnested_cr4_valid\n#define nested_host_cr4_valid\tnested_cr4_valid\n\nextern struct kvm_x86_nested_ops vmx_nested_ops;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}