{
  "module_name": "vmcs.h",
  "hash_id": "a501b17ee441a939313977e390e52fb651dc5f4d254cb43a3e70c34da99d4170",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/vmx/vmcs.h",
  "human_readable_source": " \n#ifndef __KVM_X86_VMX_VMCS_H\n#define __KVM_X86_VMX_VMCS_H\n\n#include <linux/ktime.h>\n#include <linux/list.h>\n#include <linux/nospec.h>\n\n#include <asm/kvm.h>\n#include <asm/vmx.h>\n\n#include \"capabilities.h\"\n\n#define ROL16(val, n) ((u16)(((u16)(val) << (n)) | ((u16)(val) >> (16 - (n)))))\n\nstruct vmcs_hdr {\n\tu32 revision_id:31;\n\tu32 shadow_vmcs:1;\n};\n\nstruct vmcs {\n\tstruct vmcs_hdr hdr;\n\tu32 abort;\n\tchar data[];\n};\n\nDECLARE_PER_CPU(struct vmcs *, current_vmcs);\n\n \nstruct vmcs_host_state {\n\tunsigned long cr3;\t \n\tunsigned long cr4;\t \n\tunsigned long gs_base;\n\tunsigned long fs_base;\n\tunsigned long rsp;\n\n\tu16           fs_sel, gs_sel, ldt_sel;\n#ifdef CONFIG_X86_64\n\tu16           ds_sel, es_sel;\n#endif\n};\n\nstruct vmcs_controls_shadow {\n\tu32 vm_entry;\n\tu32 vm_exit;\n\tu32 pin;\n\tu32 exec;\n\tu32 secondary_exec;\n\tu64 tertiary_exec;\n};\n\n \nstruct loaded_vmcs {\n\tstruct vmcs *vmcs;\n\tstruct vmcs *shadow_vmcs;\n\tint cpu;\n\tbool launched;\n\tbool nmi_known_unmasked;\n\tbool hv_timer_soft_disabled;\n\t \n\tint soft_vnmi_blocked;\n\tktime_t entry_time;\n\ts64 vnmi_blocked_time;\n\tunsigned long *msr_bitmap;\n\tstruct list_head loaded_vmcss_on_cpu_link;\n\tstruct vmcs_host_state host_state;\n\tstruct vmcs_controls_shadow controls_shadow;\n};\n\nstatic __always_inline bool is_intr_type(u32 intr_info, u32 type)\n{\n\tconst u32 mask = INTR_INFO_VALID_MASK | INTR_INFO_INTR_TYPE_MASK;\n\n\treturn (intr_info & mask) == (INTR_INFO_VALID_MASK | type);\n}\n\nstatic inline bool is_intr_type_n(u32 intr_info, u32 type, u8 vector)\n{\n\tconst u32 mask = INTR_INFO_VALID_MASK | INTR_INFO_INTR_TYPE_MASK |\n\t\t\t INTR_INFO_VECTOR_MASK;\n\n\treturn (intr_info & mask) == (INTR_INFO_VALID_MASK | type | vector);\n}\n\nstatic inline bool is_exception_n(u32 intr_info, u8 vector)\n{\n\treturn is_intr_type_n(intr_info, INTR_TYPE_HARD_EXCEPTION, vector);\n}\n\nstatic inline bool is_debug(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, DB_VECTOR);\n}\n\nstatic inline bool is_breakpoint(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, BP_VECTOR);\n}\n\nstatic inline bool is_double_fault(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, DF_VECTOR);\n}\n\nstatic inline bool is_page_fault(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, PF_VECTOR);\n}\n\nstatic inline bool is_invalid_opcode(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, UD_VECTOR);\n}\n\nstatic inline bool is_gp_fault(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, GP_VECTOR);\n}\n\nstatic inline bool is_alignment_check(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, AC_VECTOR);\n}\n\nstatic inline bool is_machine_check(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, MC_VECTOR);\n}\n\nstatic inline bool is_nm_fault(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, NM_VECTOR);\n}\n\n \nstatic inline bool is_icebp(u32 intr_info)\n{\n\treturn is_intr_type(intr_info, INTR_TYPE_PRIV_SW_EXCEPTION);\n}\n\nstatic __always_inline bool is_nmi(u32 intr_info)\n{\n\treturn is_intr_type(intr_info, INTR_TYPE_NMI_INTR);\n}\n\nstatic inline bool is_external_intr(u32 intr_info)\n{\n\treturn is_intr_type(intr_info, INTR_TYPE_EXT_INTR);\n}\n\nstatic inline bool is_exception_with_error_code(u32 intr_info)\n{\n\tconst u32 mask = INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK;\n\n\treturn (intr_info & mask) == mask;\n}\n\nenum vmcs_field_width {\n\tVMCS_FIELD_WIDTH_U16 = 0,\n\tVMCS_FIELD_WIDTH_U64 = 1,\n\tVMCS_FIELD_WIDTH_U32 = 2,\n\tVMCS_FIELD_WIDTH_NATURAL_WIDTH = 3\n};\n\nstatic inline int vmcs_field_width(unsigned long field)\n{\n\tif (0x1 & field)\t \n\t\treturn VMCS_FIELD_WIDTH_U32;\n\treturn (field >> 13) & 0x3;\n}\n\nstatic inline int vmcs_field_readonly(unsigned long field)\n{\n\treturn (((field >> 10) & 0x3) == 1);\n}\n\n#define VMCS_FIELD_INDEX_SHIFT\t\t(1)\n#define VMCS_FIELD_INDEX_MASK\t\tGENMASK(9, 1)\n\nstatic inline unsigned int vmcs_field_index(unsigned long field)\n{\n\treturn (field & VMCS_FIELD_INDEX_MASK) >> VMCS_FIELD_INDEX_SHIFT;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}