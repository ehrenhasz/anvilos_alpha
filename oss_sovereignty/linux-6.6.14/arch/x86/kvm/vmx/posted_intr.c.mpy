{
  "module_name": "posted_intr.c",
  "hash_id": "c555c5adc0700ad7c0bc1aed92a1d9c1b61053ab4a23c073787d212f5bc63b86",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/vmx/posted_intr.c",
  "human_readable_source": "\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kvm_host.h>\n\n#include <asm/irq_remapping.h>\n#include <asm/cpu.h>\n\n#include \"lapic.h\"\n#include \"irq.h\"\n#include \"posted_intr.h\"\n#include \"trace.h\"\n#include \"vmx.h\"\n\n \nstatic DEFINE_PER_CPU(struct list_head, wakeup_vcpus_on_cpu);\n \nstatic DEFINE_PER_CPU(raw_spinlock_t, wakeup_vcpus_on_cpu_lock);\n\nstatic inline struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)\n{\n\treturn &(to_vmx(vcpu)->pi_desc);\n}\n\nstatic int pi_try_set_control(struct pi_desc *pi_desc, u64 *pold, u64 new)\n{\n\t \n\tif (!try_cmpxchg64(&pi_desc->control, pold, new))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nvoid vmx_vcpu_pi_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct pi_desc old, new;\n\tunsigned long flags;\n\tunsigned int dest;\n\n\t \n\tif (!enable_apicv || !lapic_in_kernel(vcpu))\n\t\treturn;\n\n\t \n\tif (pi_desc->nv != POSTED_INTR_WAKEUP_VECTOR && vcpu->cpu == cpu) {\n\t\t \n\t\tif (pi_test_and_clear_sn(pi_desc))\n\t\t\tgoto after_clear_sn;\n\t\treturn;\n\t}\n\n\tlocal_irq_save(flags);\n\n\t \n\tif (pi_desc->nv == POSTED_INTR_WAKEUP_VECTOR) {\n\t\traw_spin_lock(&per_cpu(wakeup_vcpus_on_cpu_lock, vcpu->cpu));\n\t\tlist_del(&vmx->pi_wakeup_list);\n\t\traw_spin_unlock(&per_cpu(wakeup_vcpus_on_cpu_lock, vcpu->cpu));\n\t}\n\n\tdest = cpu_physical_id(cpu);\n\tif (!x2apic_mode)\n\t\tdest = (dest << 8) & 0xFF00;\n\n\told.control = READ_ONCE(pi_desc->control);\n\tdo {\n\t\tnew.control = old.control;\n\n\t\t \n\t\tnew.ndst = dest;\n\t\tnew.sn = 0;\n\n\t\t \n\t\tnew.nv = POSTED_INTR_VECTOR;\n\t} while (pi_try_set_control(pi_desc, &old.control, new.control));\n\n\tlocal_irq_restore(flags);\n\nafter_clear_sn:\n\n\t \n\tsmp_mb__after_atomic();\n\n\tif (!pi_is_pir_empty(pi_desc))\n\t\tpi_set_on(pi_desc);\n}\n\nstatic bool vmx_can_use_vtd_pi(struct kvm *kvm)\n{\n\treturn irqchip_in_kernel(kvm) && enable_apicv &&\n\t\tkvm_arch_has_assigned_device(kvm) &&\n\t\tirq_remapping_cap(IRQ_POSTING_CAP);\n}\n\n \nstatic void pi_enable_wakeup_handler(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct pi_desc old, new;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\traw_spin_lock(&per_cpu(wakeup_vcpus_on_cpu_lock, vcpu->cpu));\n\tlist_add_tail(&vmx->pi_wakeup_list,\n\t\t      &per_cpu(wakeup_vcpus_on_cpu, vcpu->cpu));\n\traw_spin_unlock(&per_cpu(wakeup_vcpus_on_cpu_lock, vcpu->cpu));\n\n\tWARN(pi_desc->sn, \"PI descriptor SN field set before blocking\");\n\n\told.control = READ_ONCE(pi_desc->control);\n\tdo {\n\t\t \n\t\tnew.control = old.control;\n\t\tnew.nv = POSTED_INTR_WAKEUP_VECTOR;\n\t} while (pi_try_set_control(pi_desc, &old.control, new.control));\n\n\t \n\tif (pi_test_on(&new))\n\t\t__apic_send_IPI_self(POSTED_INTR_WAKEUP_VECTOR);\n\n\tlocal_irq_restore(flags);\n}\n\nstatic bool vmx_needs_pi_wakeup(struct kvm_vcpu *vcpu)\n{\n\t \n\treturn vmx_can_use_ipiv(vcpu) || vmx_can_use_vtd_pi(vcpu->kvm);\n}\n\nvoid vmx_vcpu_pi_put(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\tif (!vmx_needs_pi_wakeup(vcpu))\n\t\treturn;\n\n\tif (kvm_vcpu_is_blocking(vcpu) && !vmx_interrupt_blocked(vcpu))\n\t\tpi_enable_wakeup_handler(vcpu);\n\n\t \n\tif (vcpu->preempted)\n\t\tpi_set_sn(pi_desc);\n}\n\n \nvoid pi_wakeup_handler(void)\n{\n\tint cpu = smp_processor_id();\n\tstruct list_head *wakeup_list = &per_cpu(wakeup_vcpus_on_cpu, cpu);\n\traw_spinlock_t *spinlock = &per_cpu(wakeup_vcpus_on_cpu_lock, cpu);\n\tstruct vcpu_vmx *vmx;\n\n\traw_spin_lock(spinlock);\n\tlist_for_each_entry(vmx, wakeup_list, pi_wakeup_list) {\n\n\t\tif (pi_test_on(&vmx->pi_desc))\n\t\t\tkvm_vcpu_wake_up(&vmx->vcpu);\n\t}\n\traw_spin_unlock(spinlock);\n}\n\nvoid __init pi_init_cpu(int cpu)\n{\n\tINIT_LIST_HEAD(&per_cpu(wakeup_vcpus_on_cpu, cpu));\n\traw_spin_lock_init(&per_cpu(wakeup_vcpus_on_cpu_lock, cpu));\n}\n\nbool pi_has_pending_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\treturn pi_test_on(pi_desc) ||\n\t\t(pi_test_sn(pi_desc) && !pi_is_pir_empty(pi_desc));\n}\n\n\n \nvoid vmx_pi_start_assignment(struct kvm *kvm)\n{\n\tif (!irq_remapping_cap(IRQ_POSTING_CAP))\n\t\treturn;\n\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_UNBLOCK);\n}\n\n \nint vmx_pi_update_irte(struct kvm *kvm, unsigned int host_irq,\n\t\t       uint32_t guest_irq, bool set)\n{\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tstruct kvm_irq_routing_table *irq_rt;\n\tstruct kvm_lapic_irq irq;\n\tstruct kvm_vcpu *vcpu;\n\tstruct vcpu_data vcpu_info;\n\tint idx, ret = 0;\n\n\tif (!vmx_can_use_vtd_pi(kvm))\n\t\treturn 0;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tirq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);\n\tif (guest_irq >= irq_rt->nr_rt_entries ||\n\t    hlist_empty(&irq_rt->map[guest_irq])) {\n\t\tpr_warn_once(\"no route for guest_irq %u/%u (broken user space?)\\n\",\n\t\t\t     guest_irq, irq_rt->nr_rt_entries);\n\t\tgoto out;\n\t}\n\n\thlist_for_each_entry(e, &irq_rt->map[guest_irq], link) {\n\t\tif (e->type != KVM_IRQ_ROUTING_MSI)\n\t\t\tcontinue;\n\t\t \n\n\t\tkvm_set_msi_irq(kvm, e, &irq);\n\t\tif (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu) ||\n\t\t    !kvm_irq_is_postable(&irq)) {\n\t\t\t \n\t\t\tret = irq_set_vcpu_affinity(host_irq, NULL);\n\t\t\tif (ret < 0) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t   \"failed to back to remapped mode, irq: %u\\n\",\n\t\t\t\t   host_irq);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tvcpu_info.pi_desc_addr = __pa(vcpu_to_pi_desc(vcpu));\n\t\tvcpu_info.vector = irq.vector;\n\n\t\ttrace_kvm_pi_irte_update(host_irq, vcpu->vcpu_id, e->gsi,\n\t\t\t\tvcpu_info.vector, vcpu_info.pi_desc_addr, set);\n\n\t\tif (set)\n\t\t\tret = irq_set_vcpu_affinity(host_irq, &vcpu_info);\n\t\telse\n\t\t\tret = irq_set_vcpu_affinity(host_irq, NULL);\n\n\t\tif (ret < 0) {\n\t\t\tprintk(KERN_INFO \"%s: failed to update PI IRTE\\n\",\n\t\t\t\t\t__func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}