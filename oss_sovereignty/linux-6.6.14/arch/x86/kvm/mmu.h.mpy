{
  "module_name": "mmu.h",
  "hash_id": "62d3449993591924e02cb50b127c49050e2b5febc4f37e482c873604f08aeea4",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/mmu.h",
  "human_readable_source": " \n#ifndef __KVM_X86_MMU_H\n#define __KVM_X86_MMU_H\n\n#include <linux/kvm_host.h>\n#include \"kvm_cache_regs.h\"\n#include \"cpuid.h\"\n\nextern bool __read_mostly enable_mmio_caching;\n\n#define PT_WRITABLE_SHIFT 1\n#define PT_USER_SHIFT 2\n\n#define PT_PRESENT_MASK (1ULL << 0)\n#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)\n#define PT_USER_MASK (1ULL << PT_USER_SHIFT)\n#define PT_PWT_MASK (1ULL << 3)\n#define PT_PCD_MASK (1ULL << 4)\n#define PT_ACCESSED_SHIFT 5\n#define PT_ACCESSED_MASK (1ULL << PT_ACCESSED_SHIFT)\n#define PT_DIRTY_SHIFT 6\n#define PT_DIRTY_MASK (1ULL << PT_DIRTY_SHIFT)\n#define PT_PAGE_SIZE_SHIFT 7\n#define PT_PAGE_SIZE_MASK (1ULL << PT_PAGE_SIZE_SHIFT)\n#define PT_PAT_MASK (1ULL << 7)\n#define PT_GLOBAL_MASK (1ULL << 8)\n#define PT64_NX_SHIFT 63\n#define PT64_NX_MASK (1ULL << PT64_NX_SHIFT)\n\n#define PT_PAT_SHIFT 7\n#define PT_DIR_PAT_SHIFT 12\n#define PT_DIR_PAT_MASK (1ULL << PT_DIR_PAT_SHIFT)\n\n#define PT64_ROOT_5LEVEL 5\n#define PT64_ROOT_4LEVEL 4\n#define PT32_ROOT_LEVEL 2\n#define PT32E_ROOT_LEVEL 3\n\n#define KVM_MMU_CR4_ROLE_BITS (X86_CR4_PSE | X86_CR4_PAE | X86_CR4_LA57 | \\\n\t\t\t       X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE)\n\n#define KVM_MMU_CR0_ROLE_BITS (X86_CR0_PG | X86_CR0_WP)\n#define KVM_MMU_EFER_ROLE_BITS (EFER_LME | EFER_NX)\n\nstatic __always_inline u64 rsvd_bits(int s, int e)\n{\n\tBUILD_BUG_ON(__builtin_constant_p(e) && __builtin_constant_p(s) && e < s);\n\n\tif (__builtin_constant_p(e))\n\t\tBUILD_BUG_ON(e > 63);\n\telse\n\t\te &= 63;\n\n\tif (e < s)\n\t\treturn 0;\n\n\treturn ((2ULL << (e - s)) - 1) << s;\n}\n\n \nextern u8 __read_mostly shadow_phys_bits;\n\nstatic inline gfn_t kvm_mmu_max_gfn(void)\n{\n\t \n\tint max_gpa_bits = likely(tdp_enabled) ? shadow_phys_bits : 52;\n\n\treturn (1ULL << (max_gpa_bits - PAGE_SHIFT)) - 1;\n}\n\nstatic inline u8 kvm_get_shadow_phys_bits(void)\n{\n\t \n\tif (likely(boot_cpu_data.extended_cpuid_level >= 0x80000008))\n\t\treturn cpuid_eax(0x80000008) & 0xff;\n\n\t \n\treturn boot_cpu_data.x86_phys_bits;\n}\n\nvoid kvm_mmu_set_mmio_spte_mask(u64 mmio_value, u64 mmio_mask, u64 access_mask);\nvoid kvm_mmu_set_me_spte_mask(u64 me_value, u64 me_mask);\nvoid kvm_mmu_set_ept_masks(bool has_ad_bits, bool has_exec_only);\n\nvoid kvm_init_mmu(struct kvm_vcpu *vcpu);\nvoid kvm_init_shadow_npt_mmu(struct kvm_vcpu *vcpu, unsigned long cr0,\n\t\t\t     unsigned long cr4, u64 efer, gpa_t nested_cr3);\nvoid kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, bool execonly,\n\t\t\t     int huge_page_level, bool accessed_dirty,\n\t\t\t     gpa_t new_eptp);\nbool kvm_can_do_async_pf(struct kvm_vcpu *vcpu);\nint kvm_handle_page_fault(struct kvm_vcpu *vcpu, u64 error_code,\n\t\t\t\tu64 fault_address, char *insn, int insn_len);\nvoid __kvm_mmu_refresh_passthrough_bits(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_mmu *mmu);\n\nint kvm_mmu_load(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_unload(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_free_obsolete_roots(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_sync_roots(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_sync_prev_roots(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new,\n\t\t\t int bytes);\n\nstatic inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)\n{\n\tif (likely(vcpu->arch.mmu->root.hpa != INVALID_PAGE))\n\t\treturn 0;\n\n\treturn kvm_mmu_load(vcpu);\n}\n\nstatic inline unsigned long kvm_get_pcid(struct kvm_vcpu *vcpu, gpa_t cr3)\n{\n\tBUILD_BUG_ON((X86_CR3_PCID_MASK & PAGE_MASK) != 0);\n\n\treturn kvm_is_cr4_bit_set(vcpu, X86_CR4_PCIDE)\n\t       ? cr3 & X86_CR3_PCID_MASK\n\t       : 0;\n}\n\nstatic inline unsigned long kvm_get_active_pcid(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_get_pcid(vcpu, kvm_read_cr3(vcpu));\n}\n\nstatic inline void kvm_mmu_load_pgd(struct kvm_vcpu *vcpu)\n{\n\tu64 root_hpa = vcpu->arch.mmu->root.hpa;\n\n\tif (!VALID_PAGE(root_hpa))\n\t\treturn;\n\n\tstatic_call(kvm_x86_load_mmu_pgd)(vcpu, root_hpa,\n\t\t\t\t\t  vcpu->arch.mmu->root_role.level);\n}\n\nstatic inline void kvm_mmu_refresh_passthrough_bits(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t    struct kvm_mmu *mmu)\n{\n\t \n\tif (!tdp_enabled || mmu == &vcpu->arch.guest_mmu)\n\t\treturn;\n\n\t__kvm_mmu_refresh_passthrough_bits(vcpu, mmu);\n}\n\n \nstatic inline u8 permission_fault(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\t  unsigned pte_access, unsigned pte_pkey,\n\t\t\t\t  u64 access)\n{\n\t \n\tunsigned int pfec = access;\n\tunsigned long rflags = static_call(kvm_x86_get_rflags)(vcpu);\n\n\t \n\tu64 implicit_access = access & PFERR_IMPLICIT_ACCESS;\n\tbool not_smap = ((rflags & X86_EFLAGS_AC) | implicit_access) == X86_EFLAGS_AC;\n\tint index = (pfec + (not_smap << PFERR_RSVD_BIT)) >> 1;\n\tu32 errcode = PFERR_PRESENT_MASK;\n\tbool fault;\n\n\tkvm_mmu_refresh_passthrough_bits(vcpu, mmu);\n\n\tfault = (mmu->permissions[index] >> pte_access) & 1;\n\n\tWARN_ON(pfec & (PFERR_PK_MASK | PFERR_RSVD_MASK));\n\tif (unlikely(mmu->pkru_mask)) {\n\t\tu32 pkru_bits, offset;\n\n\t\t \n\t\tpkru_bits = (vcpu->arch.pkru >> (pte_pkey * 2)) & 3;\n\n\t\t \n\t\toffset = (pfec & ~1) +\n\t\t\t((pte_access & PT_USER_MASK) << (PFERR_RSVD_BIT - PT_USER_SHIFT));\n\n\t\tpkru_bits &= mmu->pkru_mask >> offset;\n\t\terrcode |= -pkru_bits & PFERR_PK_MASK;\n\t\tfault |= (pkru_bits != 0);\n\t}\n\n\treturn -(u32)fault & errcode;\n}\n\nvoid kvm_zap_gfn_range(struct kvm *kvm, gfn_t gfn_start, gfn_t gfn_end);\n\nint kvm_arch_write_log_dirty(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_post_init_vm(struct kvm *kvm);\nvoid kvm_mmu_pre_destroy_vm(struct kvm *kvm);\n\nstatic inline bool kvm_shadow_root_allocated(struct kvm *kvm)\n{\n\t \n\treturn smp_load_acquire(&kvm->arch.shadow_root_allocated);\n}\n\n#ifdef CONFIG_X86_64\nextern bool tdp_mmu_enabled;\n#else\n#define tdp_mmu_enabled false\n#endif\n\nstatic inline bool kvm_memslots_have_rmaps(struct kvm *kvm)\n{\n\treturn !tdp_mmu_enabled || kvm_shadow_root_allocated(kvm);\n}\n\nstatic inline gfn_t gfn_to_index(gfn_t gfn, gfn_t base_gfn, int level)\n{\n\t \n\treturn (gfn >> KVM_HPAGE_GFN_SHIFT(level)) -\n\t\t(base_gfn >> KVM_HPAGE_GFN_SHIFT(level));\n}\n\nstatic inline unsigned long\n__kvm_mmu_slot_lpages(struct kvm_memory_slot *slot, unsigned long npages,\n\t\t      int level)\n{\n\treturn gfn_to_index(slot->base_gfn + npages - 1,\n\t\t\t    slot->base_gfn, level) + 1;\n}\n\nstatic inline unsigned long\nkvm_mmu_slot_lpages(struct kvm_memory_slot *slot, int level)\n{\n\treturn __kvm_mmu_slot_lpages(slot, slot->npages, level);\n}\n\nstatic inline void kvm_update_page_stats(struct kvm *kvm, int level, int count)\n{\n\tatomic64_add(count, &kvm->stat.pages[level - 1]);\n}\n\ngpa_t translate_nested_gpa(struct kvm_vcpu *vcpu, gpa_t gpa, u64 access,\n\t\t\t   struct x86_exception *exception);\n\nstatic inline gpa_t kvm_translate_gpa(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu,\n\t\t\t\t      gpa_t gpa, u64 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tif (mmu != &vcpu->arch.nested_mmu)\n\t\treturn gpa;\n\treturn translate_nested_gpa(vcpu, gpa, access, exception);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}