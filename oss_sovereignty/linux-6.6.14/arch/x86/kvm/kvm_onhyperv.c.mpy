{
  "module_name": "kvm_onhyperv.c",
  "hash_id": "e7c8c569ff7818b06c72aab8df81ccb09361e42a7e9b798ee081ed9432c1ce49",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/kvm_onhyperv.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kvm_host.h>\n#include <asm/mshyperv.h>\n\n#include \"hyperv.h\"\n#include \"kvm_onhyperv.h\"\n\nstruct kvm_hv_tlb_range {\n\tu64 start_gfn;\n\tu64 pages;\n};\n\nstatic int kvm_fill_hv_flush_list_func(struct hv_guest_mapping_flush_list *flush,\n\t\tvoid *data)\n{\n\tstruct kvm_hv_tlb_range *range = data;\n\n\treturn hyperv_fill_flush_guest_mapping_list(flush, range->start_gfn,\n\t\t\trange->pages);\n}\n\nstatic inline int hv_remote_flush_root_tdp(hpa_t root_tdp,\n\t\t\t\t\t   struct kvm_hv_tlb_range *range)\n{\n\tif (range)\n\t\treturn hyperv_flush_guest_mapping_range(root_tdp,\n\t\t\t\tkvm_fill_hv_flush_list_func, (void *)range);\n\telse\n\t\treturn hyperv_flush_guest_mapping(root_tdp);\n}\n\nstatic int __hv_flush_remote_tlbs_range(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_hv_tlb_range *range)\n{\n\tstruct kvm_arch *kvm_arch = &kvm->arch;\n\tstruct kvm_vcpu *vcpu;\n\tint ret = 0, nr_unique_valid_roots;\n\tunsigned long i;\n\thpa_t root;\n\n\tspin_lock(&kvm_arch->hv_root_tdp_lock);\n\n\tif (!VALID_PAGE(kvm_arch->hv_root_tdp)) {\n\t\tnr_unique_valid_roots = 0;\n\n\t\t \n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\troot = vcpu->arch.hv_root_tdp;\n\t\t\tif (!VALID_PAGE(root) || root == kvm_arch->hv_root_tdp)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (++nr_unique_valid_roots == 1)\n\t\t\t\tkvm_arch->hv_root_tdp = root;\n\n\t\t\tif (!ret)\n\t\t\t\tret = hv_remote_flush_root_tdp(root, range);\n\n\t\t\t \n\t\t\tif (ret && nr_unique_valid_roots > 1)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (nr_unique_valid_roots > 1)\n\t\t\tkvm_arch->hv_root_tdp = INVALID_PAGE;\n\t} else {\n\t\tret = hv_remote_flush_root_tdp(kvm_arch->hv_root_tdp, range);\n\t}\n\n\tspin_unlock(&kvm_arch->hv_root_tdp_lock);\n\treturn ret;\n}\n\nint hv_flush_remote_tlbs_range(struct kvm *kvm, gfn_t start_gfn, gfn_t nr_pages)\n{\n\tstruct kvm_hv_tlb_range range = {\n\t\t.start_gfn = start_gfn,\n\t\t.pages = nr_pages,\n\t};\n\n\treturn __hv_flush_remote_tlbs_range(kvm, &range);\n}\nEXPORT_SYMBOL_GPL(hv_flush_remote_tlbs_range);\n\nint hv_flush_remote_tlbs(struct kvm *kvm)\n{\n\treturn __hv_flush_remote_tlbs_range(kvm, NULL);\n}\nEXPORT_SYMBOL_GPL(hv_flush_remote_tlbs);\n\nvoid hv_track_root_tdp(struct kvm_vcpu *vcpu, hpa_t root_tdp)\n{\n\tstruct kvm_arch *kvm_arch = &vcpu->kvm->arch;\n\n\tif (kvm_x86_ops.flush_remote_tlbs == hv_flush_remote_tlbs) {\n\t\tspin_lock(&kvm_arch->hv_root_tdp_lock);\n\t\tvcpu->arch.hv_root_tdp = root_tdp;\n\t\tif (root_tdp != kvm_arch->hv_root_tdp)\n\t\t\tkvm_arch->hv_root_tdp = INVALID_PAGE;\n\t\tspin_unlock(&kvm_arch->hv_root_tdp_lock);\n\t}\n}\nEXPORT_SYMBOL_GPL(hv_track_root_tdp);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}