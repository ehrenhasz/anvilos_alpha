{
  "module_name": "kvm_emulate.h",
  "hash_id": "72cde6b612dc7669c07c166d26318298edff139c4b90a69c843a0c1f8590b9b5",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/kvm_emulate.h",
  "human_readable_source": " \n \n\n#ifndef _ASM_X86_KVM_X86_EMULATE_H\n#define _ASM_X86_KVM_X86_EMULATE_H\n\n#include <asm/desc_defs.h>\n#include \"fpu.h\"\n\nstruct x86_emulate_ctxt;\nenum x86_intercept;\nenum x86_intercept_stage;\n\nstruct x86_exception {\n\tu8 vector;\n\tbool error_code_valid;\n\tu16 error_code;\n\tbool nested_page_fault;\n\tu64 address;  \n\tu8 async_page_fault;\n};\n\n \nstruct x86_instruction_info {\n\tu8  intercept;           \n\tu8  rep_prefix;          \n\tu8  modrm_mod;\t\t \n\tu8  modrm_reg;           \n\tu8  modrm_rm;\t\t \n\tu64 src_val;             \n\tu64 dst_val;             \n\tu8  src_bytes;           \n\tu8  dst_bytes;           \n\tu8  ad_bytes;            \n\tu64 next_rip;            \n};\n\n \n \n#define X86EMUL_CONTINUE        0\n \n#define X86EMUL_UNHANDLEABLE    1\n \n#define X86EMUL_PROPAGATE_FAULT 2  \n#define X86EMUL_RETRY_INSTR     3  \n#define X86EMUL_CMPXCHG_FAILED  4  \n#define X86EMUL_IO_NEEDED       5  \n#define X86EMUL_INTERCEPTED     6  \n\nstruct x86_emulate_ops {\n\tvoid (*vm_bugged)(struct x86_emulate_ctxt *ctxt);\n\t \n\tulong (*read_gpr)(struct x86_emulate_ctxt *ctxt, unsigned reg);\n\t \n\tvoid (*write_gpr)(struct x86_emulate_ctxt *ctxt, unsigned reg, ulong val);\n\t \n\tint (*read_std)(struct x86_emulate_ctxt *ctxt,\n\t\t\tunsigned long addr, void *val,\n\t\t\tunsigned int bytes,\n\t\t\tstruct x86_exception *fault, bool system);\n\n\t \n\tint (*write_std)(struct x86_emulate_ctxt *ctxt,\n\t\t\t unsigned long addr, void *val, unsigned int bytes,\n\t\t\t struct x86_exception *fault, bool system);\n\t \n\tint (*fetch)(struct x86_emulate_ctxt *ctxt,\n\t\t     unsigned long addr, void *val, unsigned int bytes,\n\t\t     struct x86_exception *fault);\n\n\t \n\tint (*read_emulated)(struct x86_emulate_ctxt *ctxt,\n\t\t\t     unsigned long addr, void *val, unsigned int bytes,\n\t\t\t     struct x86_exception *fault);\n\n\t \n\tint (*write_emulated)(struct x86_emulate_ctxt *ctxt,\n\t\t\t      unsigned long addr, const void *val,\n\t\t\t      unsigned int bytes,\n\t\t\t      struct x86_exception *fault);\n\n\t \n\tint (*cmpxchg_emulated)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tunsigned long addr,\n\t\t\t\tconst void *old,\n\t\t\t\tconst void *new,\n\t\t\t\tunsigned int bytes,\n\t\t\t\tstruct x86_exception *fault);\n\tvoid (*invlpg)(struct x86_emulate_ctxt *ctxt, ulong addr);\n\n\tint (*pio_in_emulated)(struct x86_emulate_ctxt *ctxt,\n\t\t\t       int size, unsigned short port, void *val,\n\t\t\t       unsigned int count);\n\n\tint (*pio_out_emulated)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tint size, unsigned short port, const void *val,\n\t\t\t\tunsigned int count);\n\n\tbool (*get_segment)(struct x86_emulate_ctxt *ctxt, u16 *selector,\n\t\t\t    struct desc_struct *desc, u32 *base3, int seg);\n\tvoid (*set_segment)(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t    struct desc_struct *desc, u32 base3, int seg);\n\tunsigned long (*get_cached_segment_base)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t\t int seg);\n\tvoid (*get_gdt)(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt);\n\tvoid (*get_idt)(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt);\n\tvoid (*set_gdt)(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt);\n\tvoid (*set_idt)(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt);\n\tulong (*get_cr)(struct x86_emulate_ctxt *ctxt, int cr);\n\tint (*set_cr)(struct x86_emulate_ctxt *ctxt, int cr, ulong val);\n\tint (*cpl)(struct x86_emulate_ctxt *ctxt);\n\tvoid (*get_dr)(struct x86_emulate_ctxt *ctxt, int dr, ulong *dest);\n\tint (*set_dr)(struct x86_emulate_ctxt *ctxt, int dr, ulong value);\n\tint (*set_msr_with_filter)(struct x86_emulate_ctxt *ctxt, u32 msr_index, u64 data);\n\tint (*get_msr_with_filter)(struct x86_emulate_ctxt *ctxt, u32 msr_index, u64 *pdata);\n\tint (*get_msr)(struct x86_emulate_ctxt *ctxt, u32 msr_index, u64 *pdata);\n\tint (*check_pmc)(struct x86_emulate_ctxt *ctxt, u32 pmc);\n\tint (*read_pmc)(struct x86_emulate_ctxt *ctxt, u32 pmc, u64 *pdata);\n\tvoid (*halt)(struct x86_emulate_ctxt *ctxt);\n\tvoid (*wbinvd)(struct x86_emulate_ctxt *ctxt);\n\tint (*fix_hypercall)(struct x86_emulate_ctxt *ctxt);\n\tint (*intercept)(struct x86_emulate_ctxt *ctxt,\n\t\t\t struct x86_instruction_info *info,\n\t\t\t enum x86_intercept_stage stage);\n\n\tbool (*get_cpuid)(struct x86_emulate_ctxt *ctxt, u32 *eax, u32 *ebx,\n\t\t\t  u32 *ecx, u32 *edx, bool exact_only);\n\tbool (*guest_has_movbe)(struct x86_emulate_ctxt *ctxt);\n\tbool (*guest_has_fxsr)(struct x86_emulate_ctxt *ctxt);\n\tbool (*guest_has_rdpid)(struct x86_emulate_ctxt *ctxt);\n\n\tvoid (*set_nmi_mask)(struct x86_emulate_ctxt *ctxt, bool masked);\n\n\tbool (*is_smm)(struct x86_emulate_ctxt *ctxt);\n\tbool (*is_guest_mode)(struct x86_emulate_ctxt *ctxt);\n\tint (*leave_smm)(struct x86_emulate_ctxt *ctxt);\n\tvoid (*triple_fault)(struct x86_emulate_ctxt *ctxt);\n\tint (*set_xcr)(struct x86_emulate_ctxt *ctxt, u32 index, u64 xcr);\n};\n\n \nstruct operand {\n\tenum { OP_REG, OP_MEM, OP_MEM_STR, OP_IMM, OP_XMM, OP_MM, OP_NONE } type;\n\tunsigned int bytes;\n\tunsigned int count;\n\tunion {\n\t\tunsigned long orig_val;\n\t\tu64 orig_val64;\n\t};\n\tunion {\n\t\tunsigned long *reg;\n\t\tstruct segmented_address {\n\t\t\tulong ea;\n\t\t\tunsigned seg;\n\t\t} mem;\n\t\tunsigned xmm;\n\t\tunsigned mm;\n\t} addr;\n\tunion {\n\t\tunsigned long val;\n\t\tu64 val64;\n\t\tchar valptr[sizeof(sse128_t)];\n\t\tsse128_t vec_val;\n\t\tu64 mm_val;\n\t\tvoid *data;\n\t};\n};\n\nstruct fetch_cache {\n\tu8 data[15];\n\tu8 *ptr;\n\tu8 *end;\n};\n\nstruct read_cache {\n\tu8 data[1024];\n\tunsigned long pos;\n\tunsigned long end;\n};\n\n \nenum x86emul_mode {\n\tX86EMUL_MODE_REAL,\t \n\tX86EMUL_MODE_VM86,\t \n\tX86EMUL_MODE_PROT16,\t \n\tX86EMUL_MODE_PROT32,\t \n\tX86EMUL_MODE_PROT64,\t \n};\n\n \nstruct fastop;\n\ntypedef void (*fastop_t)(struct fastop *);\n\n \n#ifdef CONFIG_X86_64\n#define NR_EMULATOR_GPRS\t16\n#else\n#define NR_EMULATOR_GPRS\t8\n#endif\n\nstruct x86_emulate_ctxt {\n\tvoid *vcpu;\n\tconst struct x86_emulate_ops *ops;\n\n\t \n\tunsigned long eflags;\n\tunsigned long eip;  \n\t \n\tenum x86emul_mode mode;\n\n\t \n\tint interruptibility;\n\n\tbool perm_ok;  \n\tbool tf;\t \n\n\tbool have_exception;\n\tstruct x86_exception exception;\n\n\t \n\tbool gpa_available;\n\tgpa_t gpa_val;\n\n\t \n\n\t \n\tu8 opcode_len;\n\tu8 b;\n\tu8 intercept;\n\tu8 op_bytes;\n\tu8 ad_bytes;\n\tunion {\n\t\tint (*execute)(struct x86_emulate_ctxt *ctxt);\n\t\tfastop_t fop;\n\t};\n\tint (*check_perm)(struct x86_emulate_ctxt *ctxt);\n\n\tbool rip_relative;\n\tu8 rex_prefix;\n\tu8 lock_prefix;\n\tu8 rep_prefix;\n\t \n\tu16 regs_valid;\n\t \n\tu16 regs_dirty;\n\t \n\tu8 modrm;\n\tu8 modrm_mod;\n\tu8 modrm_reg;\n\tu8 modrm_rm;\n\tu8 modrm_seg;\n\tu8 seg_override;\n\tu64 d;\n\tunsigned long _eip;\n\n\t \n\tstruct operand src;\n\tstruct operand src2;\n\tstruct operand dst;\n\tstruct operand memop;\n\tunsigned long _regs[NR_EMULATOR_GPRS];\n\tstruct operand *memopp;\n\tstruct fetch_cache fetch;\n\tstruct read_cache io_read;\n\tstruct read_cache mem_read;\n\tbool is_branch;\n};\n\n#define KVM_EMULATOR_BUG_ON(cond, ctxt)\t\t\\\n({\t\t\t\t\t\t\\\n\tint __ret = (cond);\t\t\t\\\n\t\t\t\t\t\t\\\n\tif (WARN_ON_ONCE(__ret))\t\t\\\n\t\tctxt->ops->vm_bugged(ctxt);\t\\\n\tunlikely(__ret);\t\t\t\\\n})\n\n \n#define REPE_PREFIX\t0xf3\n#define REPNE_PREFIX\t0xf2\n\n \n#define X86EMUL_CPUID_VENDOR_AuthenticAMD_ebx 0x68747541\n#define X86EMUL_CPUID_VENDOR_AuthenticAMD_ecx 0x444d4163\n#define X86EMUL_CPUID_VENDOR_AuthenticAMD_edx 0x69746e65\n\n#define X86EMUL_CPUID_VENDOR_AMDisbetterI_ebx 0x69444d41\n#define X86EMUL_CPUID_VENDOR_AMDisbetterI_ecx 0x21726574\n#define X86EMUL_CPUID_VENDOR_AMDisbetterI_edx 0x74656273\n\n#define X86EMUL_CPUID_VENDOR_HygonGenuine_ebx 0x6f677948\n#define X86EMUL_CPUID_VENDOR_HygonGenuine_ecx 0x656e6975\n#define X86EMUL_CPUID_VENDOR_HygonGenuine_edx 0x6e65476e\n\n#define X86EMUL_CPUID_VENDOR_GenuineIntel_ebx 0x756e6547\n#define X86EMUL_CPUID_VENDOR_GenuineIntel_ecx 0x6c65746e\n#define X86EMUL_CPUID_VENDOR_GenuineIntel_edx 0x49656e69\n\n#define X86EMUL_CPUID_VENDOR_CentaurHauls_ebx 0x746e6543\n#define X86EMUL_CPUID_VENDOR_CentaurHauls_ecx 0x736c7561\n#define X86EMUL_CPUID_VENDOR_CentaurHauls_edx 0x48727561\n\nstatic inline bool is_guest_vendor_intel(u32 ebx, u32 ecx, u32 edx)\n{\n\treturn ebx == X86EMUL_CPUID_VENDOR_GenuineIntel_ebx &&\n\t       ecx == X86EMUL_CPUID_VENDOR_GenuineIntel_ecx &&\n\t       edx == X86EMUL_CPUID_VENDOR_GenuineIntel_edx;\n}\n\nstatic inline bool is_guest_vendor_amd(u32 ebx, u32 ecx, u32 edx)\n{\n\treturn (ebx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ebx &&\n\t\tecx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ecx &&\n\t\tedx == X86EMUL_CPUID_VENDOR_AuthenticAMD_edx) ||\n\t       (ebx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ebx &&\n\t\tecx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ecx &&\n\t\tedx == X86EMUL_CPUID_VENDOR_AMDisbetterI_edx);\n}\n\nstatic inline bool is_guest_vendor_hygon(u32 ebx, u32 ecx, u32 edx)\n{\n\treturn ebx == X86EMUL_CPUID_VENDOR_HygonGenuine_ebx &&\n\t       ecx == X86EMUL_CPUID_VENDOR_HygonGenuine_ecx &&\n\t       edx == X86EMUL_CPUID_VENDOR_HygonGenuine_edx;\n}\n\nenum x86_intercept_stage {\n\tX86_ICTP_NONE = 0,    \n\tX86_ICPT_PRE_EXCEPT,\n\tX86_ICPT_POST_EXCEPT,\n\tX86_ICPT_POST_MEMACCESS,\n};\n\nenum x86_intercept {\n\tx86_intercept_none,\n\tx86_intercept_cr_read,\n\tx86_intercept_cr_write,\n\tx86_intercept_clts,\n\tx86_intercept_lmsw,\n\tx86_intercept_smsw,\n\tx86_intercept_dr_read,\n\tx86_intercept_dr_write,\n\tx86_intercept_lidt,\n\tx86_intercept_sidt,\n\tx86_intercept_lgdt,\n\tx86_intercept_sgdt,\n\tx86_intercept_lldt,\n\tx86_intercept_sldt,\n\tx86_intercept_ltr,\n\tx86_intercept_str,\n\tx86_intercept_rdtsc,\n\tx86_intercept_rdpmc,\n\tx86_intercept_pushf,\n\tx86_intercept_popf,\n\tx86_intercept_cpuid,\n\tx86_intercept_rsm,\n\tx86_intercept_iret,\n\tx86_intercept_intn,\n\tx86_intercept_invd,\n\tx86_intercept_pause,\n\tx86_intercept_hlt,\n\tx86_intercept_invlpg,\n\tx86_intercept_invlpga,\n\tx86_intercept_vmrun,\n\tx86_intercept_vmload,\n\tx86_intercept_vmsave,\n\tx86_intercept_vmmcall,\n\tx86_intercept_stgi,\n\tx86_intercept_clgi,\n\tx86_intercept_skinit,\n\tx86_intercept_rdtscp,\n\tx86_intercept_rdpid,\n\tx86_intercept_icebp,\n\tx86_intercept_wbinvd,\n\tx86_intercept_monitor,\n\tx86_intercept_mwait,\n\tx86_intercept_rdmsr,\n\tx86_intercept_wrmsr,\n\tx86_intercept_in,\n\tx86_intercept_ins,\n\tx86_intercept_out,\n\tx86_intercept_outs,\n\tx86_intercept_xsetbv,\n\n\tnr_x86_intercepts\n};\n\n \n#if defined(CONFIG_X86_32)\n#define X86EMUL_MODE_HOST X86EMUL_MODE_PROT32\n#elif defined(CONFIG_X86_64)\n#define X86EMUL_MODE_HOST X86EMUL_MODE_PROT64\n#endif\n\nint x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len, int emulation_type);\nbool x86_page_table_writing_insn(struct x86_emulate_ctxt *ctxt);\n#define EMULATION_FAILED -1\n#define EMULATION_OK 0\n#define EMULATION_RESTART 1\n#define EMULATION_INTERCEPTED 2\nvoid init_decode_cache(struct x86_emulate_ctxt *ctxt);\nint x86_emulate_insn(struct x86_emulate_ctxt *ctxt);\nint emulator_task_switch(struct x86_emulate_ctxt *ctxt,\n\t\t\t u16 tss_selector, int idt_index, int reason,\n\t\t\t bool has_error_code, u32 error_code);\nint emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq);\nvoid emulator_invalidate_register_cache(struct x86_emulate_ctxt *ctxt);\nvoid emulator_writeback_register_cache(struct x86_emulate_ctxt *ctxt);\nbool emulator_can_use_gpa(struct x86_emulate_ctxt *ctxt);\n\nstatic inline ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (KVM_EMULATOR_BUG_ON(nr >= NR_EMULATOR_GPRS, ctxt))\n\t\tnr &= NR_EMULATOR_GPRS - 1;\n\n\tif (!(ctxt->regs_valid & (1 << nr))) {\n\t\tctxt->regs_valid |= 1 << nr;\n\t\tctxt->_regs[nr] = ctxt->ops->read_gpr(ctxt, nr);\n\t}\n\treturn ctxt->_regs[nr];\n}\n\nstatic inline ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tif (KVM_EMULATOR_BUG_ON(nr >= NR_EMULATOR_GPRS, ctxt))\n\t\tnr &= NR_EMULATOR_GPRS - 1;\n\n\tBUILD_BUG_ON(sizeof(ctxt->regs_dirty) * BITS_PER_BYTE < NR_EMULATOR_GPRS);\n\tBUILD_BUG_ON(sizeof(ctxt->regs_valid) * BITS_PER_BYTE < NR_EMULATOR_GPRS);\n\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}\n\nstatic inline ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\treg_read(ctxt, nr);\n\treturn reg_write(ctxt, nr);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}