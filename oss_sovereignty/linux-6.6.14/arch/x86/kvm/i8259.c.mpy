{
  "module_name": "i8259.c",
  "hash_id": "891cfb2c38eed56c3abc3f6b70b12938c6e186a936eb63a61525472e24b194e3",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/i8259.c",
  "human_readable_source": " \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include \"irq.h\"\n\n#include <linux/kvm_host.h>\n#include \"trace.h\"\n\n#define pr_pic_unimpl(fmt, ...)\t\\\n\tpr_err_ratelimited(\"pic: \" fmt, ## __VA_ARGS__)\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}\n\nstatic void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\t\tkvm_vcpu_kick(vcpu);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t \n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}\n\n \nstatic inline int pic_set_irq1(struct kvm_kpic_state *s, int irq, int level)\n{\n\tint mask, ret = 1;\n\tmask = 1 << irq;\n\tif (s->elcr & mask)\t \n\t\tif (level) {\n\t\t\tret = !(s->irr & mask);\n\t\t\ts->irr |= mask;\n\t\t\ts->last_irr |= mask;\n\t\t} else {\n\t\t\ts->irr &= ~mask;\n\t\t\ts->last_irr &= ~mask;\n\t\t}\n\telse\t \n\t\tif (level) {\n\t\t\tif ((s->last_irr & mask) == 0) {\n\t\t\t\tret = !(s->irr & mask);\n\t\t\t\ts->irr |= mask;\n\t\t\t}\n\t\t\ts->last_irr |= mask;\n\t\t} else\n\t\t\ts->last_irr &= ~mask;\n\n\treturn (s->imr & mask) ? -1 : ret;\n}\n\n \nstatic inline int get_priority(struct kvm_kpic_state *s, int mask)\n{\n\tint priority;\n\tif (mask == 0)\n\t\treturn 8;\n\tpriority = 0;\n\twhile ((mask & (1 << ((priority + s->priority_add) & 7))) == 0)\n\t\tpriority++;\n\treturn priority;\n}\n\n \nstatic int pic_get_irq(struct kvm_kpic_state *s)\n{\n\tint mask, cur_priority, priority;\n\n\tmask = s->irr & ~s->imr;\n\tpriority = get_priority(s, mask);\n\tif (priority == 8)\n\t\treturn -1;\n\t \n\tmask = s->isr;\n\tif (s->special_fully_nested_mode && s == &s->pics_state->pics[0])\n\t\tmask &= ~(1 << 2);\n\tcur_priority = get_priority(s, mask);\n\tif (priority < cur_priority)\n\t\t \n\t\treturn (priority + s->priority_add) & 7;\n\telse\n\t\treturn -1;\n}\n\n \nstatic void pic_update_irq(struct kvm_pic *s)\n{\n\tint irq2, irq;\n\n\tirq2 = pic_get_irq(&s->pics[1]);\n\tif (irq2 >= 0) {\n\t\t \n\t\tpic_set_irq1(&s->pics[0], 2, 1);\n\t\tpic_set_irq1(&s->pics[0], 2, 0);\n\t}\n\tirq = pic_get_irq(&s->pics[0]);\n\tpic_irq_request(s->kvm, irq >= 0);\n}\n\nvoid kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}\n\nint kvm_pic_set_irq(struct kvm_pic *s, int irq, int irq_source_id, int level)\n{\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= PIC_NUM_PINS);\n\n\tpic_lock(s);\n\tirq_level = __kvm_irq_line_state(&s->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tret = pic_set_irq1(&s->pics[irq >> 3], irq & 7, irq_level);\n\tpic_update_irq(s);\n\ttrace_kvm_pic_set_irq(irq >> 3, irq & 7, s->pics[irq >> 3].elcr,\n\t\t\t      s->pics[irq >> 3].imr, ret == 0);\n\tpic_unlock(s);\n\n\treturn ret;\n}\n\nvoid kvm_pic_clear_all(struct kvm_pic *s, int irq_source_id)\n{\n\tint i;\n\n\tpic_lock(s);\n\tfor (i = 0; i < PIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &s->irq_states[i]);\n\tpic_unlock(s);\n}\n\n \nstatic inline void pic_intack(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr |= 1 << irq;\n\t \n\tif (!(s->elcr & (1 << irq)))\n\t\ts->irr &= ~(1 << irq);\n\n\tif (s->auto_eoi) {\n\t\tif (s->rotate_on_auto_eoi)\n\t\t\ts->priority_add = (irq + 1) & 7;\n\t\tpic_clear_isr(s, irq);\n\t}\n\n}\n\nint kvm_pic_read_irq(struct kvm *kvm)\n{\n\tint irq, irq2, intno;\n\tstruct kvm_pic *s = kvm->arch.vpic;\n\n\ts->output = 0;\n\n\tpic_lock(s);\n\tirq = pic_get_irq(&s->pics[0]);\n\tif (irq >= 0) {\n\t\tpic_intack(&s->pics[0], irq);\n\t\tif (irq == 2) {\n\t\t\tirq2 = pic_get_irq(&s->pics[1]);\n\t\t\tif (irq2 >= 0)\n\t\t\t\tpic_intack(&s->pics[1], irq2);\n\t\t\telse\n\t\t\t\t \n\t\t\t\tirq2 = 7;\n\t\t\tintno = s->pics[1].irq_base + irq2;\n\t\t} else\n\t\t\tintno = s->pics[0].irq_base + irq;\n\t} else {\n\t\t \n\t\tirq = 7;\n\t\tintno = s->pics[0].irq_base + irq;\n\t}\n\tpic_update_irq(s);\n\tpic_unlock(s);\n\n\treturn intno;\n}\n\nstatic void kvm_pic_reset(struct kvm_kpic_state *s)\n{\n\tint irq;\n\tunsigned long i;\n\tstruct kvm_vcpu *vcpu;\n\tu8 edge_irr = s->irr & ~s->elcr;\n\tbool found = false;\n\n\ts->last_irr = 0;\n\ts->irr &= s->elcr;\n\ts->imr = 0;\n\ts->priority_add = 0;\n\ts->special_mask = 0;\n\ts->read_reg_select = 0;\n\tif (!s->init4) {\n\t\ts->special_fully_nested_mode = 0;\n\t\ts->auto_eoi = 0;\n\t}\n\ts->init_state = 1;\n\n\tkvm_for_each_vcpu(i, vcpu, s->pics_state->kvm)\n\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\n\tif (!found)\n\t\treturn;\n\n\tfor (irq = 0; irq < PIC_NUM_PINS/2; irq++)\n\t\tif (edge_irr & (1 << irq))\n\t\t\tpic_clear_isr(s, irq);\n}\n\nstatic void pic_ioport_write(void *opaque, u32 addr, u32 val)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\tint priority, cmd, irq;\n\n\taddr &= 1;\n\tif (addr == 0) {\n\t\tif (val & 0x10) {\n\t\t\ts->init4 = val & 1;\n\t\t\tif (val & 0x02)\n\t\t\t\tpr_pic_unimpl(\"single mode not supported\");\n\t\t\tif (val & 0x08)\n\t\t\t\tpr_pic_unimpl(\n\t\t\t\t\t\t\"level sensitive irq not supported\");\n\t\t\tkvm_pic_reset(s);\n\t\t} else if (val & 0x08) {\n\t\t\tif (val & 0x04)\n\t\t\t\ts->poll = 1;\n\t\t\tif (val & 0x02)\n\t\t\t\ts->read_reg_select = val & 1;\n\t\t\tif (val & 0x40)\n\t\t\t\ts->special_mask = (val >> 5) & 1;\n\t\t} else {\n\t\t\tcmd = val >> 5;\n\t\t\tswitch (cmd) {\n\t\t\tcase 0:\n\t\t\tcase 4:\n\t\t\t\ts->rotate_on_auto_eoi = cmd >> 2;\n\t\t\t\tbreak;\n\t\t\tcase 1:\t \n\t\t\tcase 5:\n\t\t\t\tpriority = get_priority(s, s->isr);\n\t\t\t\tif (priority != 8) {\n\t\t\t\t\tirq = (priority + s->priority_add) & 7;\n\t\t\t\t\tif (cmd == 5)\n\t\t\t\t\t\ts->priority_add = (irq + 1) & 7;\n\t\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tirq = val & 7;\n\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\ts->priority_add = (val + 1) & 7;\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tirq = val & 7;\n\t\t\t\ts->priority_add = (irq + 1) & 7;\n\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\t \n\t\t\t}\n\t\t}\n\t} else\n\t\tswitch (s->init_state) {\n\t\tcase 0: {  \n\t\t\tu8 imr_diff = s->imr ^ val,\n\t\t\t\toff = (s == &s->pics_state->pics[0]) ? 0 : 8;\n\t\t\ts->imr = val;\n\t\t\tfor (irq = 0; irq < PIC_NUM_PINS/2; irq++)\n\t\t\t\tif (imr_diff & (1 << irq))\n\t\t\t\t\tkvm_fire_mask_notifiers(\n\t\t\t\t\t\ts->pics_state->kvm,\n\t\t\t\t\t\tSELECT_PIC(irq + off),\n\t\t\t\t\t\tirq + off,\n\t\t\t\t\t\t!!(s->imr & (1 << irq)));\n\t\t\tpic_update_irq(s->pics_state);\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t\ts->irq_base = val & 0xf8;\n\t\t\ts->init_state = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (s->init4)\n\t\t\t\ts->init_state = 3;\n\t\t\telse\n\t\t\t\ts->init_state = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ts->special_fully_nested_mode = (val >> 4) & 1;\n\t\t\ts->auto_eoi = (val >> 1) & 1;\n\t\t\ts->init_state = 0;\n\t\t\tbreak;\n\t\t}\n}\n\nstatic u32 pic_poll_read(struct kvm_kpic_state *s, u32 addr1)\n{\n\tint ret;\n\n\tret = pic_get_irq(s);\n\tif (ret >= 0) {\n\t\tif (addr1 >> 7) {\n\t\t\ts->pics_state->pics[0].isr &= ~(1 << 2);\n\t\t\ts->pics_state->pics[0].irr &= ~(1 << 2);\n\t\t}\n\t\ts->irr &= ~(1 << ret);\n\t\tpic_clear_isr(s, ret);\n\t\tif (addr1 >> 7 || ret != 2)\n\t\t\tpic_update_irq(s->pics_state);\n\t\t \n\t\tret |= 0x80;\n\t} else {\n\t\t \n\t\tret = 0x07;\n\t\tpic_update_irq(s->pics_state);\n\t}\n\n\treturn ret;\n}\n\nstatic u32 pic_ioport_read(void *opaque, u32 addr)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\tint ret;\n\n\tif (s->poll) {\n\t\tret = pic_poll_read(s, addr);\n\t\ts->poll = 0;\n\t} else\n\t\tif ((addr & 1) == 0)\n\t\t\tif (s->read_reg_select)\n\t\t\t\tret = s->isr;\n\t\t\telse\n\t\t\t\tret = s->irr;\n\t\telse\n\t\t\tret = s->imr;\n\treturn ret;\n}\n\nstatic void elcr_ioport_write(void *opaque, u32 val)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\ts->elcr = val & s->elcr_mask;\n}\n\nstatic u32 elcr_ioport_read(void *opaque)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\treturn s->elcr;\n}\n\nstatic int picdev_write(struct kvm_pic *s,\n\t\t\t gpa_t addr, int len, const void *val)\n{\n\tunsigned char data = *(unsigned char *)val;\n\n\tif (len != 1) {\n\t\tpr_pic_unimpl(\"non byte write\\n\");\n\t\treturn 0;\n\t}\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\t\tpic_lock(s);\n\t\tpic_ioport_write(&s->pics[0], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_lock(s);\n\t\tpic_ioport_write(&s->pics[1], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tpic_lock(s);\n\t\telcr_ioport_write(&s->pics[addr & 1], data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int picdev_read(struct kvm_pic *s,\n\t\t       gpa_t addr, int len, void *val)\n{\n\tunsigned char *data = (unsigned char *)val;\n\n\tif (len != 1) {\n\t\tmemset(val, 0, len);\n\t\tpr_pic_unimpl(\"non byte read\\n\");\n\t\treturn 0;\n\t}\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_lock(s);\n\t\t*data = pic_ioport_read(&s->pics[addr >> 7], addr);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tpic_lock(s);\n\t\t*data = elcr_ioport_read(&s->pics[addr & 1]);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int picdev_master_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t       gpa_t addr, int len, const void *val)\n{\n\treturn picdev_write(container_of(dev, struct kvm_pic, dev_master),\n\t\t\t    addr, len, val);\n}\n\nstatic int picdev_master_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t      gpa_t addr, int len, void *val)\n{\n\treturn picdev_read(container_of(dev, struct kvm_pic, dev_master),\n\t\t\t    addr, len, val);\n}\n\nstatic int picdev_slave_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t      gpa_t addr, int len, const void *val)\n{\n\treturn picdev_write(container_of(dev, struct kvm_pic, dev_slave),\n\t\t\t    addr, len, val);\n}\n\nstatic int picdev_slave_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t     gpa_t addr, int len, void *val)\n{\n\treturn picdev_read(container_of(dev, struct kvm_pic, dev_slave),\n\t\t\t    addr, len, val);\n}\n\nstatic int picdev_elcr_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t     gpa_t addr, int len, const void *val)\n{\n\treturn picdev_write(container_of(dev, struct kvm_pic, dev_elcr),\n\t\t\t    addr, len, val);\n}\n\nstatic int picdev_elcr_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t    gpa_t addr, int len, void *val)\n{\n\treturn picdev_read(container_of(dev, struct kvm_pic, dev_elcr),\n\t\t\t    addr, len, val);\n}\n\n \nstatic void pic_irq_request(struct kvm *kvm, int level)\n{\n\tstruct kvm_pic *s = kvm->arch.vpic;\n\n\tif (!s->output)\n\t\ts->wakeup_needed = true;\n\ts->output = level;\n}\n\nstatic const struct kvm_io_device_ops picdev_master_ops = {\n\t.read     = picdev_master_read,\n\t.write    = picdev_master_write,\n};\n\nstatic const struct kvm_io_device_ops picdev_slave_ops = {\n\t.read     = picdev_slave_read,\n\t.write    = picdev_slave_write,\n};\n\nstatic const struct kvm_io_device_ops picdev_elcr_ops = {\n\t.read     = picdev_elcr_read,\n\t.write    = picdev_elcr_write,\n};\n\nint kvm_pic_init(struct kvm *kvm)\n{\n\tstruct kvm_pic *s;\n\tint ret;\n\n\ts = kzalloc(sizeof(struct kvm_pic), GFP_KERNEL_ACCOUNT);\n\tif (!s)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&s->lock);\n\ts->kvm = kvm;\n\ts->pics[0].elcr_mask = 0xf8;\n\ts->pics[1].elcr_mask = 0xde;\n\ts->pics[0].pics_state = s;\n\ts->pics[1].pics_state = s;\n\n\t \n\tkvm_iodevice_init(&s->dev_master, &picdev_master_ops);\n\tkvm_iodevice_init(&s->dev_slave, &picdev_slave_ops);\n\tkvm_iodevice_init(&s->dev_elcr, &picdev_elcr_ops);\n\tmutex_lock(&kvm->slots_lock);\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x20, 2,\n\t\t\t\t      &s->dev_master);\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0xa0, 2, &s->dev_slave);\n\tif (ret < 0)\n\t\tgoto fail_unreg_2;\n\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x4d0, 2, &s->dev_elcr);\n\tif (ret < 0)\n\t\tgoto fail_unreg_1;\n\n\tmutex_unlock(&kvm->slots_lock);\n\n\tkvm->arch.vpic = s;\n\n\treturn 0;\n\nfail_unreg_1:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_slave);\n\nfail_unreg_2:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_master);\n\nfail_unlock:\n\tmutex_unlock(&kvm->slots_lock);\n\n\tkfree(s);\n\n\treturn ret;\n}\n\nvoid kvm_pic_destroy(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = kvm->arch.vpic;\n\n\tif (!vpic)\n\t\treturn;\n\n\tmutex_lock(&kvm->slots_lock);\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_master);\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_slave);\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_elcr);\n\tmutex_unlock(&kvm->slots_lock);\n\n\tkvm->arch.vpic = NULL;\n\tkfree(vpic);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}