{
  "module_name": "svm_onhyperv.h",
  "hash_id": "5a5e2aaf86a4b2d350df23cfb53c08f64d642c1042fd1a3fc664edfa940282e9",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/svm/svm_onhyperv.h",
  "human_readable_source": " \n \n\n#ifndef __ARCH_X86_KVM_SVM_ONHYPERV_H__\n#define __ARCH_X86_KVM_SVM_ONHYPERV_H__\n\n#include <asm/mshyperv.h>\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\n#include \"kvm_onhyperv.h\"\n#include \"svm/hyperv.h\"\n\nstatic struct kvm_x86_ops svm_x86_ops;\n\nint svm_hv_enable_l2_tlb_flush(struct kvm_vcpu *vcpu);\n\nstatic inline bool svm_hv_is_enlightened_tlb_enabled(struct kvm_vcpu *vcpu)\n{\n\tstruct hv_vmcb_enlightenments *hve = &to_svm(vcpu)->vmcb->control.hv_enlightenments;\n\n\treturn ms_hyperv.nested_features & HV_X64_NESTED_ENLIGHTENED_TLB &&\n\t       !!hve->hv_enlightenments_control.enlightened_npt_tlb;\n}\n\nstatic inline void svm_hv_init_vmcb(struct vmcb *vmcb)\n{\n\tstruct hv_vmcb_enlightenments *hve = &vmcb->control.hv_enlightenments;\n\n\tBUILD_BUG_ON(sizeof(vmcb->control.hv_enlightenments) !=\n\t\t     sizeof(vmcb->control.reserved_sw));\n\n\tif (npt_enabled &&\n\t    ms_hyperv.nested_features & HV_X64_NESTED_ENLIGHTENED_TLB)\n\t\thve->hv_enlightenments_control.enlightened_npt_tlb = 1;\n\n\tif (ms_hyperv.nested_features & HV_X64_NESTED_MSR_BITMAP)\n\t\thve->hv_enlightenments_control.msr_bitmap = 1;\n}\n\nstatic inline __init void svm_hv_hardware_setup(void)\n{\n\tif (npt_enabled &&\n\t    ms_hyperv.nested_features & HV_X64_NESTED_ENLIGHTENED_TLB) {\n\t\tpr_info(KBUILD_MODNAME \": Hyper-V enlightened NPT TLB flush enabled\\n\");\n\t\tsvm_x86_ops.flush_remote_tlbs = hv_flush_remote_tlbs;\n\t\tsvm_x86_ops.flush_remote_tlbs_range = hv_flush_remote_tlbs_range;\n\t}\n\n\tif (ms_hyperv.nested_features & HV_X64_NESTED_DIRECT_FLUSH) {\n\t\tint cpu;\n\n\t\tpr_info(KBUILD_MODNAME \": Hyper-V Direct TLB Flush enabled\\n\");\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tstruct hv_vp_assist_page *vp_ap =\n\t\t\t\thv_get_vp_assist_page(cpu);\n\n\t\t\tif (!vp_ap)\n\t\t\t\tcontinue;\n\n\t\t\tvp_ap->nested_control.features.directhypercall = 1;\n\t\t}\n\t\tsvm_x86_ops.enable_l2_tlb_flush =\n\t\t\t\tsvm_hv_enable_l2_tlb_flush;\n\t}\n}\n\nstatic inline void svm_hv_vmcb_dirty_nested_enlightenments(\n\t\tstruct kvm_vcpu *vcpu)\n{\n\tstruct vmcb *vmcb = to_svm(vcpu)->vmcb;\n\tstruct hv_vmcb_enlightenments *hve = &vmcb->control.hv_enlightenments;\n\n\tif (hve->hv_enlightenments_control.msr_bitmap)\n\t\tvmcb_mark_dirty(vmcb, HV_VMCB_NESTED_ENLIGHTENMENTS);\n}\n\nstatic inline void svm_hv_update_vp_id(struct vmcb *vmcb, struct kvm_vcpu *vcpu)\n{\n\tstruct hv_vmcb_enlightenments *hve = &vmcb->control.hv_enlightenments;\n\tu32 vp_index = kvm_hv_get_vpindex(vcpu);\n\n\tif (hve->hv_vp_id != vp_index) {\n\t\thve->hv_vp_id = vp_index;\n\t\tvmcb_mark_dirty(vmcb, HV_VMCB_NESTED_ENLIGHTENMENTS);\n\t}\n}\n#else\n\nstatic inline bool svm_hv_is_enlightened_tlb_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn false;\n}\n\nstatic inline void svm_hv_init_vmcb(struct vmcb *vmcb)\n{\n}\n\nstatic inline __init void svm_hv_hardware_setup(void)\n{\n}\n\nstatic inline void svm_hv_vmcb_dirty_nested_enlightenments(\n\t\tstruct kvm_vcpu *vcpu)\n{\n}\n\nstatic inline void svm_hv_update_vp_id(struct vmcb *vmcb,\n\t\tstruct kvm_vcpu *vcpu)\n{\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}