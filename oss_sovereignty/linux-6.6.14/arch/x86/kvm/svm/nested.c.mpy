{
  "module_name": "nested.c",
  "hash_id": "2b801cb87435f316a46382c829161c45c5a9a8e7ddee7cd3e01d91f41aeb86f8",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/svm/nested.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kvm_types.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n\n#include <asm/msr-index.h>\n#include <asm/debugreg.h>\n\n#include \"kvm_emulate.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"x86.h\"\n#include \"smm.h\"\n#include \"cpuid.h\"\n#include \"lapic.h\"\n#include \"svm.h\"\n#include \"hyperv.h\"\n\n#define CC KVM_NESTED_VMENTER_CONSISTENCY_CHECK\n\nstatic void nested_svm_inject_npf_exit(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct x86_exception *fault)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tif (vmcb->control.exit_code != SVM_EXIT_NPF) {\n\t\t \n\t\tvmcb->control.exit_code = SVM_EXIT_NPF;\n\t\tvmcb->control.exit_code_hi = 0;\n\t\tvmcb->control.exit_info_1 = (1ULL << 32);\n\t\tvmcb->control.exit_info_2 = fault->address;\n\t}\n\n\tvmcb->control.exit_info_1 &= ~0xffffffffULL;\n\tvmcb->control.exit_info_1 |= fault->error_code;\n\n\tnested_svm_vmexit(svm);\n}\n\nstatic u64 nested_svm_get_tdp_pdptr(struct kvm_vcpu *vcpu, int index)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 cr3 = svm->nested.ctl.nested_cr3;\n\tu64 pdpte;\n\tint ret;\n\n\tret = kvm_vcpu_read_guest_page(vcpu, gpa_to_gfn(cr3), &pdpte,\n\t\t\t\t       offset_in_page(cr3) + index * 8, 8);\n\tif (ret)\n\t\treturn 0;\n\treturn pdpte;\n}\n\nstatic unsigned long nested_svm_get_tdp_cr3(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn svm->nested.ctl.nested_cr3;\n}\n\nstatic void nested_svm_init_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tWARN_ON(mmu_is_nested(vcpu));\n\n\tvcpu->arch.mmu = &vcpu->arch.guest_mmu;\n\n\t \n\tkvm_init_shadow_npt_mmu(vcpu, X86_CR0_PG, svm->vmcb01.ptr->save.cr4,\n\t\t\t\tsvm->vmcb01.ptr->save.efer,\n\t\t\t\tsvm->nested.ctl.nested_cr3);\n\tvcpu->arch.mmu->get_guest_pgd     = nested_svm_get_tdp_cr3;\n\tvcpu->arch.mmu->get_pdptr         = nested_svm_get_tdp_pdptr;\n\tvcpu->arch.mmu->inject_page_fault = nested_svm_inject_npf_exit;\n\tvcpu->arch.walk_mmu              = &vcpu->arch.nested_mmu;\n}\n\nstatic void nested_svm_uninit_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.mmu = &vcpu->arch.root_mmu;\n\tvcpu->arch.walk_mmu = &vcpu->arch.root_mmu;\n}\n\nstatic bool nested_vmcb_needs_vls_intercept(struct vcpu_svm *svm)\n{\n\tif (!guest_can_use(&svm->vcpu, X86_FEATURE_V_VMSAVE_VMLOAD))\n\t\treturn true;\n\n\tif (!nested_npt_enabled(svm))\n\t\treturn true;\n\n\tif (!(svm->nested.ctl.virt_ext & VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK))\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct vmcb_ctrl_area_cached *g;\n\tunsigned int i;\n\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->vmcb01.ptr->control;\n\tg = &svm->nested.ctl;\n\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] = h->intercepts[i];\n\n\tif (g->int_ctl & V_INTR_MASKING_MASK) {\n\t\t \n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n\t\tif (!(svm->vmcb01.ptr->save.rflags & X86_EFLAGS_IF))\n\t\t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n\t}\n\n\t \n\tif (!nested_svm_l2_tlb_flush_enabled(&svm->vcpu))\n\t\tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] |= g->intercepts[i];\n\n\t \n\tif (!intercept_smi)\n\t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n\n\tif (nested_vmcb_needs_vls_intercept(svm)) {\n\t\t \n\t\tvmcb_set_intercept(c, INTERCEPT_VMLOAD);\n\t\tvmcb_set_intercept(c, INTERCEPT_VMSAVE);\n\t} else {\n\t\tWARN_ON(!(c->virt_ext & VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK));\n\t}\n}\n\n \nstatic bool nested_svm_vmrun_msrpm(struct vcpu_svm *svm)\n{\n\tstruct hv_vmcb_enlightenments *hve = &svm->nested.ctl.hv_enlightenments;\n\tint i;\n\n\t \n\tif (!svm->nested.force_msr_bitmap_recalc &&\n\t    kvm_hv_hypercall_enabled(&svm->vcpu) &&\n\t    hve->hv_enlightenments_control.msr_bitmap &&\n\t    (svm->nested.ctl.clean & BIT(HV_VMCB_NESTED_ENLIGHTENMENTS)))\n\t\tgoto set_msrpm_base_pa;\n\n\tif (!(vmcb12_is_intercept(&svm->nested.ctl, INTERCEPT_MSR_PROT)))\n\t\treturn true;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; i++) {\n\t\tu32 value, p;\n\t\tu64 offset;\n\n\t\tif (msrpm_offsets[i] == 0xffffffff)\n\t\t\tbreak;\n\n\t\tp      = msrpm_offsets[i];\n\n\t\t \n\t\tif (is_x2apic_msrpm_offset(p))\n\t\t\tcontinue;\n\n\t\toffset = svm->nested.ctl.msrpm_base_pa + (p * 4);\n\n\t\tif (kvm_vcpu_read_guest(&svm->vcpu, offset, &value, 4))\n\t\t\treturn false;\n\n\t\tsvm->nested.msrpm[p] = svm->msrpm[p] | value;\n\t}\n\n\tsvm->nested.force_msr_bitmap_recalc = false;\n\nset_msrpm_base_pa:\n\tsvm->vmcb->control.msrpm_base_pa = __sme_set(__pa(svm->nested.msrpm));\n\n\treturn true;\n}\n\n \nstatic bool nested_svm_check_bitmap_pa(struct kvm_vcpu *vcpu, u64 pa, u32 size)\n{\n\tu64 addr = PAGE_ALIGN(pa);\n\n\treturn kvm_vcpu_is_legal_gpa(vcpu, addr) &&\n\t    kvm_vcpu_is_legal_gpa(vcpu, addr + size - 1);\n}\n\nstatic bool __nested_vmcb_check_controls(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct vmcb_ctrl_area_cached *control)\n{\n\tif (CC(!vmcb12_is_intercept(control, INTERCEPT_VMRUN)))\n\t\treturn false;\n\n\tif (CC(control->asid == 0))\n\t\treturn false;\n\n\tif (CC((control->nested_ctl & SVM_NESTED_CTL_NP_ENABLE) && !npt_enabled))\n\t\treturn false;\n\n\tif (CC(!nested_svm_check_bitmap_pa(vcpu, control->msrpm_base_pa,\n\t\t\t\t\t   MSRPM_SIZE)))\n\t\treturn false;\n\tif (CC(!nested_svm_check_bitmap_pa(vcpu, control->iopm_base_pa,\n\t\t\t\t\t   IOPM_SIZE)))\n\t\treturn false;\n\n\tif (CC((control->int_ctl & V_NMI_ENABLE_MASK) &&\n\t       !vmcb12_is_intercept(control, INTERCEPT_NMI))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool __nested_vmcb_check_save(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct vmcb_save_area_cached *save)\n{\n\tif (CC(!(save->efer & EFER_SVME)))\n\t\treturn false;\n\n\tif (CC((save->cr0 & X86_CR0_CD) == 0 && (save->cr0 & X86_CR0_NW)) ||\n\t    CC(save->cr0 & ~0xffffffffULL))\n\t\treturn false;\n\n\tif (CC(!kvm_dr6_valid(save->dr6)) || CC(!kvm_dr7_valid(save->dr7)))\n\t\treturn false;\n\n\t \n\tif ((save->efer & EFER_LME) && (save->cr0 & X86_CR0_PG)) {\n\t\tif (CC(!(save->cr4 & X86_CR4_PAE)) ||\n\t\t    CC(!(save->cr0 & X86_CR0_PE)) ||\n\t\t    CC(kvm_vcpu_is_illegal_gpa(vcpu, save->cr3)))\n\t\t\treturn false;\n\t}\n\n\t \n\tif (CC(!__kvm_is_valid_cr4(vcpu, save->cr4)))\n\t\treturn false;\n\n\tif (CC(!kvm_valid_efer(vcpu, save->efer)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool nested_vmcb_check_save(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_save_area_cached *save = &svm->nested.save;\n\n\treturn __nested_vmcb_check_save(vcpu, save);\n}\n\nstatic bool nested_vmcb_check_controls(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_ctrl_area_cached *ctl = &svm->nested.ctl;\n\n\treturn __nested_vmcb_check_controls(vcpu, ctl);\n}\n\nstatic\nvoid __nested_copy_vmcb_control_to_cache(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct vmcb_ctrl_area_cached *to,\n\t\t\t\t\t struct vmcb_control_area *from)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tto->intercepts[i] = from->intercepts[i];\n\n\tto->iopm_base_pa        = from->iopm_base_pa;\n\tto->msrpm_base_pa       = from->msrpm_base_pa;\n\tto->tsc_offset          = from->tsc_offset;\n\tto->tlb_ctl             = from->tlb_ctl;\n\tto->int_ctl             = from->int_ctl;\n\tto->int_vector          = from->int_vector;\n\tto->int_state           = from->int_state;\n\tto->exit_code           = from->exit_code;\n\tto->exit_code_hi        = from->exit_code_hi;\n\tto->exit_info_1         = from->exit_info_1;\n\tto->exit_info_2         = from->exit_info_2;\n\tto->exit_int_info       = from->exit_int_info;\n\tto->exit_int_info_err   = from->exit_int_info_err;\n\tto->nested_ctl          = from->nested_ctl;\n\tto->event_inj           = from->event_inj;\n\tto->event_inj_err       = from->event_inj_err;\n\tto->next_rip            = from->next_rip;\n\tto->nested_cr3          = from->nested_cr3;\n\tto->virt_ext            = from->virt_ext;\n\tto->pause_filter_count  = from->pause_filter_count;\n\tto->pause_filter_thresh = from->pause_filter_thresh;\n\n\t \n\tto->asid           = from->asid;\n\tto->msrpm_base_pa &= ~0x0fffULL;\n\tto->iopm_base_pa  &= ~0x0fffULL;\n\n\t \n\tif (kvm_hv_hypercall_enabled(vcpu)) {\n\t\tto->clean = from->clean;\n\t\tmemcpy(&to->hv_enlightenments, &from->hv_enlightenments,\n\t\t       sizeof(to->hv_enlightenments));\n\t}\n}\n\nvoid nested_copy_vmcb_control_to_cache(struct vcpu_svm *svm,\n\t\t\t\t       struct vmcb_control_area *control)\n{\n\t__nested_copy_vmcb_control_to_cache(&svm->vcpu, &svm->nested.ctl, control);\n}\n\nstatic void __nested_copy_vmcb_save_to_cache(struct vmcb_save_area_cached *to,\n\t\t\t\t\t     struct vmcb_save_area *from)\n{\n\t \n\tto->efer = from->efer;\n\tto->cr0 = from->cr0;\n\tto->cr3 = from->cr3;\n\tto->cr4 = from->cr4;\n\n\tto->dr6 = from->dr6;\n\tto->dr7 = from->dr7;\n}\n\nvoid nested_copy_vmcb_save_to_cache(struct vcpu_svm *svm,\n\t\t\t\t    struct vmcb_save_area *save)\n{\n\t__nested_copy_vmcb_save_to_cache(&svm->nested.save, save);\n}\n\n \nvoid nested_sync_control_from_vmcb02(struct vcpu_svm *svm)\n{\n\tu32 mask;\n\tsvm->nested.ctl.event_inj      = svm->vmcb->control.event_inj;\n\tsvm->nested.ctl.event_inj_err  = svm->vmcb->control.event_inj_err;\n\n\t \n\tmask = V_IRQ_MASK | V_TPR_MASK;\n\t \n\tif (svm_is_intercept(svm, INTERCEPT_VINTR) &&\n\t    !test_bit(INTERCEPT_VINTR, (unsigned long *)svm->nested.ctl.intercepts))\n\t\tmask &= ~V_IRQ_MASK;\n\n\tif (nested_vgif_enabled(svm))\n\t\tmask |= V_GIF_MASK;\n\n\tif (nested_vnmi_enabled(svm))\n\t\tmask |= V_NMI_BLOCKING_MASK | V_NMI_PENDING_MASK;\n\n\tsvm->nested.ctl.int_ctl        &= ~mask;\n\tsvm->nested.ctl.int_ctl        |= svm->vmcb->control.int_ctl & mask;\n}\n\n \nstatic void nested_save_pending_event_to_vmcb12(struct vcpu_svm *svm,\n\t\t\t\t\t\tstruct vmcb *vmcb12)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tu32 exit_int_info = 0;\n\tunsigned int nr;\n\n\tif (vcpu->arch.exception.injected) {\n\t\tnr = vcpu->arch.exception.vector;\n\t\texit_int_info = nr | SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_EXEPT;\n\n\t\tif (vcpu->arch.exception.has_error_code) {\n\t\t\texit_int_info |= SVM_EVTINJ_VALID_ERR;\n\t\t\tvmcb12->control.exit_int_info_err =\n\t\t\t\tvcpu->arch.exception.error_code;\n\t\t}\n\n\t} else if (vcpu->arch.nmi_injected) {\n\t\texit_int_info = SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_NMI;\n\n\t} else if (vcpu->arch.interrupt.injected) {\n\t\tnr = vcpu->arch.interrupt.nr;\n\t\texit_int_info = nr | SVM_EVTINJ_VALID;\n\n\t\tif (vcpu->arch.interrupt.soft)\n\t\t\texit_int_info |= SVM_EVTINJ_TYPE_SOFT;\n\t\telse\n\t\t\texit_int_info |= SVM_EVTINJ_TYPE_INTR;\n\t}\n\n\tvmcb12->control.exit_int_info = exit_int_info;\n}\n\nstatic void nested_svm_transition_tlb_flush(struct kvm_vcpu *vcpu)\n{\n\t \n\tif (to_hv_vcpu(vcpu) && npt_enabled)\n\t\tkvm_make_request(KVM_REQ_HV_TLB_FLUSH, vcpu);\n\n\t \n\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\tkvm_make_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);\n}\n\n \nstatic int nested_svm_load_cr3(struct kvm_vcpu *vcpu, unsigned long cr3,\n\t\t\t       bool nested_npt, bool reload_pdptrs)\n{\n\tif (CC(kvm_vcpu_is_illegal_gpa(vcpu, cr3)))\n\t\treturn -EINVAL;\n\n\tif (reload_pdptrs && !nested_npt && is_pae_paging(vcpu) &&\n\t    CC(!load_pdptrs(vcpu, cr3)))\n\t\treturn -EINVAL;\n\n\tvcpu->arch.cr3 = cr3;\n\n\t \n\tkvm_init_mmu(vcpu);\n\n\tif (!nested_npt)\n\t\tkvm_mmu_new_pgd(vcpu, cr3);\n\n\treturn 0;\n}\n\nvoid nested_vmcb02_compute_g_pat(struct vcpu_svm *svm)\n{\n\tif (!svm->nested.vmcb02.ptr)\n\t\treturn;\n\n\t \n\tsvm->nested.vmcb02.ptr->save.g_pat = svm->vmcb01.ptr->save.g_pat;\n}\n\nstatic void nested_vmcb02_prepare_save(struct vcpu_svm *svm, struct vmcb *vmcb12)\n{\n\tbool new_vmcb12 = false;\n\tstruct vmcb *vmcb01 = svm->vmcb01.ptr;\n\tstruct vmcb *vmcb02 = svm->nested.vmcb02.ptr;\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\n\tnested_vmcb02_compute_g_pat(svm);\n\n\t \n\tif (svm->nested.vmcb12_gpa != svm->nested.last_vmcb12_gpa) {\n\t\tnew_vmcb12 = true;\n\t\tsvm->nested.last_vmcb12_gpa = svm->nested.vmcb12_gpa;\n\t\tsvm->nested.force_msr_bitmap_recalc = true;\n\t}\n\n\tif (unlikely(new_vmcb12 || vmcb_is_dirty(vmcb12, VMCB_SEG))) {\n\t\tvmcb02->save.es = vmcb12->save.es;\n\t\tvmcb02->save.cs = vmcb12->save.cs;\n\t\tvmcb02->save.ss = vmcb12->save.ss;\n\t\tvmcb02->save.ds = vmcb12->save.ds;\n\t\tvmcb02->save.cpl = vmcb12->save.cpl;\n\t\tvmcb_mark_dirty(vmcb02, VMCB_SEG);\n\t}\n\n\tif (unlikely(new_vmcb12 || vmcb_is_dirty(vmcb12, VMCB_DT))) {\n\t\tvmcb02->save.gdtr = vmcb12->save.gdtr;\n\t\tvmcb02->save.idtr = vmcb12->save.idtr;\n\t\tvmcb_mark_dirty(vmcb02, VMCB_DT);\n\t}\n\n\tkvm_set_rflags(vcpu, vmcb12->save.rflags | X86_EFLAGS_FIXED);\n\n\tsvm_set_efer(vcpu, svm->nested.save.efer);\n\n\tsvm_set_cr0(vcpu, svm->nested.save.cr0);\n\tsvm_set_cr4(vcpu, svm->nested.save.cr4);\n\n\tsvm->vcpu.arch.cr2 = vmcb12->save.cr2;\n\n\tkvm_rax_write(vcpu, vmcb12->save.rax);\n\tkvm_rsp_write(vcpu, vmcb12->save.rsp);\n\tkvm_rip_write(vcpu, vmcb12->save.rip);\n\n\t \n\tvmcb02->save.rax = vmcb12->save.rax;\n\tvmcb02->save.rsp = vmcb12->save.rsp;\n\tvmcb02->save.rip = vmcb12->save.rip;\n\n\t \n\tif (unlikely(new_vmcb12 || vmcb_is_dirty(vmcb12, VMCB_DR))) {\n\t\tvmcb02->save.dr7 = svm->nested.save.dr7 | DR7_FIXED_1;\n\t\tsvm->vcpu.arch.dr6  = svm->nested.save.dr6 | DR6_ACTIVE_LOW;\n\t\tvmcb_mark_dirty(vmcb02, VMCB_DR);\n\t}\n\n\tif (unlikely(guest_can_use(vcpu, X86_FEATURE_LBRV) &&\n\t\t     (svm->nested.ctl.virt_ext & LBR_CTL_ENABLE_MASK))) {\n\t\t \n\t\tsvm_copy_lbrs(vmcb02, vmcb12);\n\t\tvmcb02->save.dbgctl &= ~DEBUGCTL_RESERVED_BITS;\n\t\tsvm_update_lbrv(&svm->vcpu);\n\n\t} else if (unlikely(vmcb01->control.virt_ext & LBR_CTL_ENABLE_MASK)) {\n\t\tsvm_copy_lbrs(vmcb02, vmcb01);\n\t}\n}\n\nstatic inline bool is_evtinj_soft(u32 evtinj)\n{\n\tu32 type = evtinj & SVM_EVTINJ_TYPE_MASK;\n\tu8 vector = evtinj & SVM_EVTINJ_VEC_MASK;\n\n\tif (!(evtinj & SVM_EVTINJ_VALID))\n\t\treturn false;\n\n\tif (type == SVM_EVTINJ_TYPE_SOFT)\n\t\treturn true;\n\n\treturn type == SVM_EVTINJ_TYPE_EXEPT && kvm_exception_is_soft(vector);\n}\n\nstatic bool is_evtinj_nmi(u32 evtinj)\n{\n\tu32 type = evtinj & SVM_EVTINJ_TYPE_MASK;\n\n\tif (!(evtinj & SVM_EVTINJ_VALID))\n\t\treturn false;\n\n\treturn type == SVM_EVTINJ_TYPE_NMI;\n}\n\nstatic void nested_vmcb02_prepare_control(struct vcpu_svm *svm,\n\t\t\t\t\t  unsigned long vmcb12_rip,\n\t\t\t\t\t  unsigned long vmcb12_csbase)\n{\n\tu32 int_ctl_vmcb01_bits = V_INTR_MASKING_MASK;\n\tu32 int_ctl_vmcb12_bits = V_TPR_MASK | V_IRQ_INJECTION_BITS_MASK;\n\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tstruct vmcb *vmcb01 = svm->vmcb01.ptr;\n\tstruct vmcb *vmcb02 = svm->nested.vmcb02.ptr;\n\tu32 pause_count12;\n\tu32 pause_thresh12;\n\n\t \n\n\tif (guest_can_use(vcpu, X86_FEATURE_VGIF) &&\n\t    (svm->nested.ctl.int_ctl & V_GIF_ENABLE_MASK))\n\t\tint_ctl_vmcb12_bits |= (V_GIF_MASK | V_GIF_ENABLE_MASK);\n\telse\n\t\tint_ctl_vmcb01_bits |= (V_GIF_MASK | V_GIF_ENABLE_MASK);\n\n\tif (vnmi) {\n\t\tif (vmcb01->control.int_ctl & V_NMI_PENDING_MASK) {\n\t\t\tsvm->vcpu.arch.nmi_pending++;\n\t\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\t\t}\n\t\tif (nested_vnmi_enabled(svm))\n\t\t\tint_ctl_vmcb12_bits |= (V_NMI_PENDING_MASK |\n\t\t\t\t\t\tV_NMI_ENABLE_MASK |\n\t\t\t\t\t\tV_NMI_BLOCKING_MASK);\n\t}\n\n\t \n\tvmcb02->control.nested_ctl = vmcb01->control.nested_ctl;\n\tvmcb02->control.iopm_base_pa = vmcb01->control.iopm_base_pa;\n\tvmcb02->control.msrpm_base_pa = vmcb01->control.msrpm_base_pa;\n\n\t \n\n\t \n\tvmcb02->control.tlb_ctl = TLB_CONTROL_DO_NOTHING;\n\n\t \n\tif (nested_npt_enabled(svm))\n\t\tnested_svm_init_mmu_context(vcpu);\n\n\tvcpu->arch.tsc_offset = kvm_calc_nested_tsc_offset(\n\t\t\tvcpu->arch.l1_tsc_offset,\n\t\t\tsvm->nested.ctl.tsc_offset,\n\t\t\tsvm->tsc_ratio_msr);\n\n\tvmcb02->control.tsc_offset = vcpu->arch.tsc_offset;\n\n\tif (guest_can_use(vcpu, X86_FEATURE_TSCRATEMSR) &&\n\t    svm->tsc_ratio_msr != kvm_caps.default_tsc_scaling_ratio)\n\t\tnested_svm_update_tsc_ratio_msr(vcpu);\n\n\tvmcb02->control.int_ctl             =\n\t\t(svm->nested.ctl.int_ctl & int_ctl_vmcb12_bits) |\n\t\t(vmcb01->control.int_ctl & int_ctl_vmcb01_bits);\n\n\tvmcb02->control.int_vector          = svm->nested.ctl.int_vector;\n\tvmcb02->control.int_state           = svm->nested.ctl.int_state;\n\tvmcb02->control.event_inj           = svm->nested.ctl.event_inj;\n\tvmcb02->control.event_inj_err       = svm->nested.ctl.event_inj_err;\n\n\t \n\tif (guest_can_use(vcpu, X86_FEATURE_NRIPS))\n\t\tvmcb02->control.next_rip    = svm->nested.ctl.next_rip;\n\telse if (boot_cpu_has(X86_FEATURE_NRIPS))\n\t\tvmcb02->control.next_rip    = vmcb12_rip;\n\n\tsvm->nmi_l1_to_l2 = is_evtinj_nmi(vmcb02->control.event_inj);\n\tif (is_evtinj_soft(vmcb02->control.event_inj)) {\n\t\tsvm->soft_int_injected = true;\n\t\tsvm->soft_int_csbase = vmcb12_csbase;\n\t\tsvm->soft_int_old_rip = vmcb12_rip;\n\t\tif (guest_can_use(vcpu, X86_FEATURE_NRIPS))\n\t\t\tsvm->soft_int_next_rip = svm->nested.ctl.next_rip;\n\t\telse\n\t\t\tsvm->soft_int_next_rip = vmcb12_rip;\n\t}\n\n\tvmcb02->control.virt_ext            = vmcb01->control.virt_ext &\n\t\t\t\t\t      LBR_CTL_ENABLE_MASK;\n\tif (guest_can_use(vcpu, X86_FEATURE_LBRV))\n\t\tvmcb02->control.virt_ext  |=\n\t\t\t(svm->nested.ctl.virt_ext & LBR_CTL_ENABLE_MASK);\n\n\tif (!nested_vmcb_needs_vls_intercept(svm))\n\t\tvmcb02->control.virt_ext |= VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK;\n\n\tif (guest_can_use(vcpu, X86_FEATURE_PAUSEFILTER))\n\t\tpause_count12 = svm->nested.ctl.pause_filter_count;\n\telse\n\t\tpause_count12 = 0;\n\tif (guest_can_use(vcpu, X86_FEATURE_PFTHRESHOLD))\n\t\tpause_thresh12 = svm->nested.ctl.pause_filter_thresh;\n\telse\n\t\tpause_thresh12 = 0;\n\tif (kvm_pause_in_guest(svm->vcpu.kvm)) {\n\t\t \n\t\tvmcb02->control.pause_filter_count = pause_count12;\n\t\tvmcb02->control.pause_filter_thresh = pause_thresh12;\n\n\t} else {\n\t\t \n\t\tvmcb02->control.pause_filter_count = vmcb01->control.pause_filter_count;\n\t\tvmcb02->control.pause_filter_thresh = vmcb01->control.pause_filter_thresh;\n\n\t\t \n\t\tif (vmcb12_is_intercept(&svm->nested.ctl, INTERCEPT_PAUSE)) {\n\t\t\tif (!pause_count12)\n\t\t\t\tvmcb02->control.pause_filter_count = 0;\n\t\t\tif (!pause_thresh12)\n\t\t\t\tvmcb02->control.pause_filter_thresh = 0;\n\t\t}\n\t}\n\n\tnested_svm_transition_tlb_flush(vcpu);\n\n\t \n\tenter_guest_mode(vcpu);\n\n\t \n\trecalc_intercepts(svm);\n}\n\nstatic void nested_svm_copy_common_state(struct vmcb *from_vmcb, struct vmcb *to_vmcb)\n{\n\t \n\tto_vmcb->save.spec_ctrl = from_vmcb->save.spec_ctrl;\n}\n\nint enter_svm_guest_mode(struct kvm_vcpu *vcpu, u64 vmcb12_gpa,\n\t\t\t struct vmcb *vmcb12, bool from_vmrun)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint ret;\n\n\ttrace_kvm_nested_vmenter(svm->vmcb->save.rip,\n\t\t\t\t vmcb12_gpa,\n\t\t\t\t vmcb12->save.rip,\n\t\t\t\t vmcb12->control.int_ctl,\n\t\t\t\t vmcb12->control.event_inj,\n\t\t\t\t vmcb12->control.nested_ctl,\n\t\t\t\t vmcb12->control.nested_cr3,\n\t\t\t\t vmcb12->save.cr3,\n\t\t\t\t KVM_ISA_SVM);\n\n\ttrace_kvm_nested_intercepts(vmcb12->control.intercepts[INTERCEPT_CR] & 0xffff,\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_CR] >> 16,\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_EXCEPTION],\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_WORD3],\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_WORD4],\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_WORD5]);\n\n\n\tsvm->nested.vmcb12_gpa = vmcb12_gpa;\n\n\tWARN_ON(svm->vmcb == svm->nested.vmcb02.ptr);\n\n\tnested_svm_copy_common_state(svm->vmcb01.ptr, svm->nested.vmcb02.ptr);\n\n\tsvm_switch_vmcb(svm, &svm->nested.vmcb02);\n\tnested_vmcb02_prepare_control(svm, vmcb12->save.rip, vmcb12->save.cs.base);\n\tnested_vmcb02_prepare_save(svm, vmcb12);\n\n\tret = nested_svm_load_cr3(&svm->vcpu, svm->nested.save.cr3,\n\t\t\t\t  nested_npt_enabled(svm), from_vmrun);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!from_vmrun)\n\t\tkvm_make_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu);\n\n\tsvm_set_gif(svm, true);\n\n\tif (kvm_vcpu_apicv_active(vcpu))\n\t\tkvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);\n\n\tnested_svm_hv_update_vm_vp_ids(vcpu);\n\n\treturn 0;\n}\n\nint nested_svm_vmrun(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint ret;\n\tstruct vmcb *vmcb12;\n\tstruct kvm_host_map map;\n\tu64 vmcb12_gpa;\n\tstruct vmcb *vmcb01 = svm->vmcb01.ptr;\n\n\tif (!svm->nested.hsave_msr) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tif (is_smm(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\t \n\tret = kvm_hv_verify_vp_assist(vcpu);\n\tif (ret) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn ret;\n\t}\n\n\tvmcb12_gpa = svm->vmcb->save.rax;\n\tret = kvm_vcpu_map(vcpu, gpa_to_gfn(vmcb12_gpa), &map);\n\tif (ret == -EINVAL) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t} else if (ret) {\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\tret = kvm_skip_emulated_instruction(vcpu);\n\n\tvmcb12 = map.hva;\n\n\tif (WARN_ON_ONCE(!svm->nested.initialized))\n\t\treturn -EINVAL;\n\n\tnested_copy_vmcb_control_to_cache(svm, &vmcb12->control);\n\tnested_copy_vmcb_save_to_cache(svm, &vmcb12->save);\n\n\tif (!nested_vmcb_check_save(vcpu) ||\n\t    !nested_vmcb_check_controls(vcpu)) {\n\t\tvmcb12->control.exit_code    = SVM_EXIT_ERR;\n\t\tvmcb12->control.exit_code_hi = 0;\n\t\tvmcb12->control.exit_info_1  = 0;\n\t\tvmcb12->control.exit_info_2  = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tvmcb01->save.efer   = vcpu->arch.efer;\n\tvmcb01->save.cr0    = kvm_read_cr0(vcpu);\n\tvmcb01->save.cr4    = vcpu->arch.cr4;\n\tvmcb01->save.rflags = kvm_get_rflags(vcpu);\n\tvmcb01->save.rip    = kvm_rip_read(vcpu);\n\n\tif (!npt_enabled)\n\t\tvmcb01->save.cr3 = kvm_read_cr3(vcpu);\n\n\tsvm->nested.nested_run_pending = 1;\n\n\tif (enter_svm_guest_mode(vcpu, vmcb12_gpa, vmcb12, true))\n\t\tgoto out_exit_err;\n\n\tif (nested_svm_vmrun_msrpm(svm))\n\t\tgoto out;\n\nout_exit_err:\n\tsvm->nested.nested_run_pending = 0;\n\tsvm->nmi_l1_to_l2 = false;\n\tsvm->soft_int_injected = false;\n\n\tsvm->vmcb->control.exit_code    = SVM_EXIT_ERR;\n\tsvm->vmcb->control.exit_code_hi = 0;\n\tsvm->vmcb->control.exit_info_1  = 0;\n\tsvm->vmcb->control.exit_info_2  = 0;\n\n\tnested_svm_vmexit(svm);\n\nout:\n\tkvm_vcpu_unmap(vcpu, &map, true);\n\n\treturn ret;\n}\n\n \nvoid svm_copy_vmrun_state(struct vmcb_save_area *to_save,\n\t\t\t  struct vmcb_save_area *from_save)\n{\n\tto_save->es = from_save->es;\n\tto_save->cs = from_save->cs;\n\tto_save->ss = from_save->ss;\n\tto_save->ds = from_save->ds;\n\tto_save->gdtr = from_save->gdtr;\n\tto_save->idtr = from_save->idtr;\n\tto_save->rflags = from_save->rflags | X86_EFLAGS_FIXED;\n\tto_save->efer = from_save->efer;\n\tto_save->cr0 = from_save->cr0;\n\tto_save->cr3 = from_save->cr3;\n\tto_save->cr4 = from_save->cr4;\n\tto_save->rax = from_save->rax;\n\tto_save->rsp = from_save->rsp;\n\tto_save->rip = from_save->rip;\n\tto_save->cpl = 0;\n}\n\nvoid svm_copy_vmloadsave_state(struct vmcb *to_vmcb, struct vmcb *from_vmcb)\n{\n\tto_vmcb->save.fs = from_vmcb->save.fs;\n\tto_vmcb->save.gs = from_vmcb->save.gs;\n\tto_vmcb->save.tr = from_vmcb->save.tr;\n\tto_vmcb->save.ldtr = from_vmcb->save.ldtr;\n\tto_vmcb->save.kernel_gs_base = from_vmcb->save.kernel_gs_base;\n\tto_vmcb->save.star = from_vmcb->save.star;\n\tto_vmcb->save.lstar = from_vmcb->save.lstar;\n\tto_vmcb->save.cstar = from_vmcb->save.cstar;\n\tto_vmcb->save.sfmask = from_vmcb->save.sfmask;\n\tto_vmcb->save.sysenter_cs = from_vmcb->save.sysenter_cs;\n\tto_vmcb->save.sysenter_esp = from_vmcb->save.sysenter_esp;\n\tto_vmcb->save.sysenter_eip = from_vmcb->save.sysenter_eip;\n}\n\nint nested_svm_vmexit(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tstruct vmcb *vmcb01 = svm->vmcb01.ptr;\n\tstruct vmcb *vmcb02 = svm->nested.vmcb02.ptr;\n\tstruct vmcb *vmcb12;\n\tstruct kvm_host_map map;\n\tint rc;\n\n\trc = kvm_vcpu_map(vcpu, gpa_to_gfn(svm->nested.vmcb12_gpa), &map);\n\tif (rc) {\n\t\tif (rc == -EINVAL)\n\t\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tvmcb12 = map.hva;\n\n\t \n\tleave_guest_mode(vcpu);\n\tsvm->nested.vmcb12_gpa = 0;\n\tWARN_ON_ONCE(svm->nested.nested_run_pending);\n\n\tkvm_clear_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu);\n\n\t \n\tsvm->vcpu.arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\t \n\n\tvmcb12->save.es     = vmcb02->save.es;\n\tvmcb12->save.cs     = vmcb02->save.cs;\n\tvmcb12->save.ss     = vmcb02->save.ss;\n\tvmcb12->save.ds     = vmcb02->save.ds;\n\tvmcb12->save.gdtr   = vmcb02->save.gdtr;\n\tvmcb12->save.idtr   = vmcb02->save.idtr;\n\tvmcb12->save.efer   = svm->vcpu.arch.efer;\n\tvmcb12->save.cr0    = kvm_read_cr0(vcpu);\n\tvmcb12->save.cr3    = kvm_read_cr3(vcpu);\n\tvmcb12->save.cr2    = vmcb02->save.cr2;\n\tvmcb12->save.cr4    = svm->vcpu.arch.cr4;\n\tvmcb12->save.rflags = kvm_get_rflags(vcpu);\n\tvmcb12->save.rip    = kvm_rip_read(vcpu);\n\tvmcb12->save.rsp    = kvm_rsp_read(vcpu);\n\tvmcb12->save.rax    = kvm_rax_read(vcpu);\n\tvmcb12->save.dr7    = vmcb02->save.dr7;\n\tvmcb12->save.dr6    = svm->vcpu.arch.dr6;\n\tvmcb12->save.cpl    = vmcb02->save.cpl;\n\n\tvmcb12->control.int_state         = vmcb02->control.int_state;\n\tvmcb12->control.exit_code         = vmcb02->control.exit_code;\n\tvmcb12->control.exit_code_hi      = vmcb02->control.exit_code_hi;\n\tvmcb12->control.exit_info_1       = vmcb02->control.exit_info_1;\n\tvmcb12->control.exit_info_2       = vmcb02->control.exit_info_2;\n\n\tif (vmcb12->control.exit_code != SVM_EXIT_ERR)\n\t\tnested_save_pending_event_to_vmcb12(svm, vmcb12);\n\n\tif (guest_can_use(vcpu, X86_FEATURE_NRIPS))\n\t\tvmcb12->control.next_rip  = vmcb02->control.next_rip;\n\n\tvmcb12->control.int_ctl           = svm->nested.ctl.int_ctl;\n\tvmcb12->control.event_inj         = svm->nested.ctl.event_inj;\n\tvmcb12->control.event_inj_err     = svm->nested.ctl.event_inj_err;\n\n\tif (!kvm_pause_in_guest(vcpu->kvm)) {\n\t\tvmcb01->control.pause_filter_count = vmcb02->control.pause_filter_count;\n\t\tvmcb_mark_dirty(vmcb01, VMCB_INTERCEPTS);\n\n\t}\n\n\tnested_svm_copy_common_state(svm->nested.vmcb02.ptr, svm->vmcb01.ptr);\n\n\tsvm_switch_vmcb(svm, &svm->vmcb01);\n\n\t \n\tif (!nested_exit_on_intr(svm))\n\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tif (unlikely(guest_can_use(vcpu, X86_FEATURE_LBRV) &&\n\t\t     (svm->nested.ctl.virt_ext & LBR_CTL_ENABLE_MASK))) {\n\t\tsvm_copy_lbrs(vmcb12, vmcb02);\n\t\tsvm_update_lbrv(vcpu);\n\t} else if (unlikely(vmcb01->control.virt_ext & LBR_CTL_ENABLE_MASK)) {\n\t\tsvm_copy_lbrs(vmcb01, vmcb02);\n\t\tsvm_update_lbrv(vcpu);\n\t}\n\n\tif (vnmi) {\n\t\tif (vmcb02->control.int_ctl & V_NMI_BLOCKING_MASK)\n\t\t\tvmcb01->control.int_ctl |= V_NMI_BLOCKING_MASK;\n\t\telse\n\t\t\tvmcb01->control.int_ctl &= ~V_NMI_BLOCKING_MASK;\n\n\t\tif (vcpu->arch.nmi_pending) {\n\t\t\tvcpu->arch.nmi_pending--;\n\t\t\tvmcb01->control.int_ctl |= V_NMI_PENDING_MASK;\n\t\t} else {\n\t\t\tvmcb01->control.int_ctl &= ~V_NMI_PENDING_MASK;\n\t\t}\n\t}\n\n\t \n\tsvm_set_gif(svm, false);\n\tvmcb01->control.exit_int_info = 0;\n\n\tsvm->vcpu.arch.tsc_offset = svm->vcpu.arch.l1_tsc_offset;\n\tif (vmcb01->control.tsc_offset != svm->vcpu.arch.tsc_offset) {\n\t\tvmcb01->control.tsc_offset = svm->vcpu.arch.tsc_offset;\n\t\tvmcb_mark_dirty(vmcb01, VMCB_INTERCEPTS);\n\t}\n\n\tif (kvm_caps.has_tsc_control &&\n\t    vcpu->arch.tsc_scaling_ratio != vcpu->arch.l1_tsc_scaling_ratio) {\n\t\tvcpu->arch.tsc_scaling_ratio = vcpu->arch.l1_tsc_scaling_ratio;\n\t\tsvm_write_tsc_multiplier(vcpu);\n\t}\n\n\tsvm->nested.ctl.nested_cr3 = 0;\n\n\t \n\tkvm_set_rflags(vcpu, vmcb01->save.rflags);\n\tsvm_set_efer(vcpu, vmcb01->save.efer);\n\tsvm_set_cr0(vcpu, vmcb01->save.cr0 | X86_CR0_PE);\n\tsvm_set_cr4(vcpu, vmcb01->save.cr4);\n\tkvm_rax_write(vcpu, vmcb01->save.rax);\n\tkvm_rsp_write(vcpu, vmcb01->save.rsp);\n\tkvm_rip_write(vcpu, vmcb01->save.rip);\n\n\tsvm->vcpu.arch.dr7 = DR7_FIXED_1;\n\tkvm_update_dr7(&svm->vcpu);\n\n\ttrace_kvm_nested_vmexit_inject(vmcb12->control.exit_code,\n\t\t\t\t       vmcb12->control.exit_info_1,\n\t\t\t\t       vmcb12->control.exit_info_2,\n\t\t\t\t       vmcb12->control.exit_int_info,\n\t\t\t\t       vmcb12->control.exit_int_info_err,\n\t\t\t\t       KVM_ISA_SVM);\n\n\tkvm_vcpu_unmap(vcpu, &map, true);\n\n\tnested_svm_transition_tlb_flush(vcpu);\n\n\tnested_svm_uninit_mmu_context(vcpu);\n\n\trc = nested_svm_load_cr3(vcpu, vmcb01->save.cr3, false, true);\n\tif (rc)\n\t\treturn 1;\n\n\t \n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n\n\t \n\tif (unlikely(vmcb01->save.rflags & X86_EFLAGS_TF))\n\t\tkvm_queue_exception(&(svm->vcpu), DB_VECTOR);\n\n\t \n\tif (kvm_apicv_activated(vcpu->kvm))\n\t\t__kvm_vcpu_update_apicv(vcpu);\n\n\treturn 0;\n}\n\nstatic void nested_svm_triple_fault(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!vmcb12_is_intercept(&svm->nested.ctl, INTERCEPT_SHUTDOWN))\n\t\treturn;\n\n\tkvm_clear_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\tnested_svm_simple_vmexit(to_svm(vcpu), SVM_EXIT_SHUTDOWN);\n}\n\nint svm_allocate_nested(struct vcpu_svm *svm)\n{\n\tstruct page *vmcb02_page;\n\n\tif (svm->nested.initialized)\n\t\treturn 0;\n\n\tvmcb02_page = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\tif (!vmcb02_page)\n\t\treturn -ENOMEM;\n\tsvm->nested.vmcb02.ptr = page_address(vmcb02_page);\n\tsvm->nested.vmcb02.pa = __sme_set(page_to_pfn(vmcb02_page) << PAGE_SHIFT);\n\n\tsvm->nested.msrpm = svm_vcpu_alloc_msrpm();\n\tif (!svm->nested.msrpm)\n\t\tgoto err_free_vmcb02;\n\tsvm_vcpu_init_msrpm(&svm->vcpu, svm->nested.msrpm);\n\n\tsvm->nested.initialized = true;\n\treturn 0;\n\nerr_free_vmcb02:\n\t__free_page(vmcb02_page);\n\treturn -ENOMEM;\n}\n\nvoid svm_free_nested(struct vcpu_svm *svm)\n{\n\tif (!svm->nested.initialized)\n\t\treturn;\n\n\tif (WARN_ON_ONCE(svm->vmcb != svm->vmcb01.ptr))\n\t\tsvm_switch_vmcb(svm, &svm->vmcb01);\n\n\tsvm_vcpu_free_msrpm(svm->nested.msrpm);\n\tsvm->nested.msrpm = NULL;\n\n\t__free_page(virt_to_page(svm->nested.vmcb02.ptr));\n\tsvm->nested.vmcb02.ptr = NULL;\n\n\t \n\tsvm->nested.last_vmcb12_gpa = INVALID_GPA;\n\n\tsvm->nested.initialized = false;\n}\n\nvoid svm_leave_nested(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (is_guest_mode(vcpu)) {\n\t\tsvm->nested.nested_run_pending = 0;\n\t\tsvm->nested.vmcb12_gpa = INVALID_GPA;\n\n\t\tleave_guest_mode(vcpu);\n\n\t\tsvm_switch_vmcb(svm, &svm->vmcb01);\n\n\t\tnested_svm_uninit_mmu_context(vcpu);\n\t\tvmcb_mark_all_dirty(svm->vmcb);\n\n\t\tif (kvm_apicv_activated(vcpu->kvm))\n\t\t\tkvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);\n\t}\n\n\tkvm_clear_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu);\n}\n\nstatic int nested_svm_exit_handled_msr(struct vcpu_svm *svm)\n{\n\tu32 offset, msr, value;\n\tint write, mask;\n\n\tif (!(vmcb12_is_intercept(&svm->nested.ctl, INTERCEPT_MSR_PROT)))\n\t\treturn NESTED_EXIT_HOST;\n\n\tmsr    = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\toffset = svm_msrpm_offset(msr);\n\twrite  = svm->vmcb->control.exit_info_1 & 1;\n\tmask   = 1 << ((2 * (msr & 0xf)) + write);\n\n\tif (offset == MSR_INVALID)\n\t\treturn NESTED_EXIT_DONE;\n\n\t \n\toffset *= 4;\n\n\tif (kvm_vcpu_read_guest(&svm->vcpu, svm->nested.ctl.msrpm_base_pa + offset, &value, 4))\n\t\treturn NESTED_EXIT_DONE;\n\n\treturn (value & mask) ? NESTED_EXIT_DONE : NESTED_EXIT_HOST;\n}\n\nstatic int nested_svm_intercept_ioio(struct vcpu_svm *svm)\n{\n\tunsigned port, size, iopm_len;\n\tu16 val, mask;\n\tu8 start_bit;\n\tu64 gpa;\n\n\tif (!(vmcb12_is_intercept(&svm->nested.ctl, INTERCEPT_IOIO_PROT)))\n\t\treturn NESTED_EXIT_HOST;\n\n\tport = svm->vmcb->control.exit_info_1 >> 16;\n\tsize = (svm->vmcb->control.exit_info_1 & SVM_IOIO_SIZE_MASK) >>\n\t\tSVM_IOIO_SIZE_SHIFT;\n\tgpa  = svm->nested.ctl.iopm_base_pa + (port / 8);\n\tstart_bit = port % 8;\n\tiopm_len = (start_bit + size > 8) ? 2 : 1;\n\tmask = (0xf >> (4 - size)) << start_bit;\n\tval = 0;\n\n\tif (kvm_vcpu_read_guest(&svm->vcpu, gpa, &val, iopm_len))\n\t\treturn NESTED_EXIT_DONE;\n\n\treturn (val & mask) ? NESTED_EXIT_DONE : NESTED_EXIT_HOST;\n}\n\nstatic int nested_svm_intercept(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\tint vmexit = NESTED_EXIT_HOST;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_MSR:\n\t\tvmexit = nested_svm_exit_handled_msr(svm);\n\t\tbreak;\n\tcase SVM_EXIT_IOIO:\n\t\tvmexit = nested_svm_intercept_ioio(svm);\n\t\tbreak;\n\tcase SVM_EXIT_READ_CR0 ... SVM_EXIT_WRITE_CR8: {\n\t\tif (vmcb12_is_intercept(&svm->nested.ctl, exit_code))\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0 ... SVM_EXIT_WRITE_DR7: {\n\t\tif (vmcb12_is_intercept(&svm->nested.ctl, exit_code))\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 0x1f: {\n\t\t \n\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_ERR: {\n\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tdefault: {\n\t\tif (vmcb12_is_intercept(&svm->nested.ctl, exit_code))\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t}\n\t}\n\n\treturn vmexit;\n}\n\nint nested_svm_exit_handled(struct vcpu_svm *svm)\n{\n\tint vmexit;\n\n\tvmexit = nested_svm_intercept(svm);\n\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tnested_svm_vmexit(svm);\n\n\treturn vmexit;\n}\n\nint nested_svm_check_permissions(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.efer & EFER_SVME) || !is_paging(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (to_svm(vcpu)->vmcb->save.cpl) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic bool nested_svm_is_exception_vmexit(struct kvm_vcpu *vcpu, u8 vector,\n\t\t\t\t\t   u32 error_code)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn (svm->nested.ctl.intercepts[INTERCEPT_EXCEPTION] & BIT(vector));\n}\n\nstatic void nested_svm_inject_exception_vmexit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_queued_exception *ex = &vcpu->arch.exception_vmexit;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tvmcb->control.exit_code = SVM_EXIT_EXCP_BASE + ex->vector;\n\tvmcb->control.exit_code_hi = 0;\n\n\tif (ex->has_error_code)\n\t\tvmcb->control.exit_info_1 = ex->error_code;\n\n\t \n\tif (ex->vector == PF_VECTOR) {\n\t\tif (ex->has_payload)\n\t\t\tvmcb->control.exit_info_2 = ex->payload;\n\t\telse\n\t\t\tvmcb->control.exit_info_2 = vcpu->arch.cr2;\n\t} else if (ex->vector == DB_VECTOR) {\n\t\t \n\t\tkvm_deliver_exception_payload(vcpu, ex);\n\n\t\tif (vcpu->arch.dr7 & DR7_GD) {\n\t\t\tvcpu->arch.dr7 &= ~DR7_GD;\n\t\t\tkvm_update_dr7(vcpu);\n\t\t}\n\t} else {\n\t\tWARN_ON(ex->has_payload);\n\t}\n\n\tnested_svm_vmexit(svm);\n}\n\nstatic inline bool nested_exit_on_init(struct vcpu_svm *svm)\n{\n\treturn vmcb12_is_intercept(&svm->nested.ctl, INTERCEPT_INIT);\n}\n\nstatic int svm_check_nested_events(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\t \n\tbool block_nested_exceptions = svm->nested.nested_run_pending;\n\t \n\tbool block_nested_events = block_nested_exceptions ||\n\t\t\t\t   kvm_event_needs_reinjection(vcpu);\n\n\tif (lapic_in_kernel(vcpu) &&\n\t    test_bit(KVM_APIC_INIT, &apic->pending_events)) {\n\t\tif (block_nested_events)\n\t\t\treturn -EBUSY;\n\t\tif (!nested_exit_on_init(svm))\n\t\t\treturn 0;\n\t\tnested_svm_simple_vmexit(svm, SVM_EXIT_INIT);\n\t\treturn 0;\n\t}\n\n\tif (vcpu->arch.exception_vmexit.pending) {\n\t\tif (block_nested_exceptions)\n                        return -EBUSY;\n\t\tnested_svm_inject_exception_vmexit(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (vcpu->arch.exception.pending) {\n\t\tif (block_nested_exceptions)\n\t\t\treturn -EBUSY;\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_KVM_SMM\n\tif (vcpu->arch.smi_pending && !svm_smi_blocked(vcpu)) {\n\t\tif (block_nested_events)\n\t\t\treturn -EBUSY;\n\t\tif (!nested_exit_on_smi(svm))\n\t\t\treturn 0;\n\t\tnested_svm_simple_vmexit(svm, SVM_EXIT_SMI);\n\t\treturn 0;\n\t}\n#endif\n\n\tif (vcpu->arch.nmi_pending && !svm_nmi_blocked(vcpu)) {\n\t\tif (block_nested_events)\n\t\t\treturn -EBUSY;\n\t\tif (!nested_exit_on_nmi(svm))\n\t\t\treturn 0;\n\t\tnested_svm_simple_vmexit(svm, SVM_EXIT_NMI);\n\t\treturn 0;\n\t}\n\n\tif (kvm_cpu_has_interrupt(vcpu) && !svm_interrupt_blocked(vcpu)) {\n\t\tif (block_nested_events)\n\t\t\treturn -EBUSY;\n\t\tif (!nested_exit_on_intr(svm))\n\t\t\treturn 0;\n\t\ttrace_kvm_nested_intr_vmexit(svm->vmcb->save.rip);\n\t\tnested_svm_simple_vmexit(svm, SVM_EXIT_INTR);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nint nested_svm_exit_special(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_INTR:\n\tcase SVM_EXIT_NMI:\n\tcase SVM_EXIT_NPF:\n\t\treturn NESTED_EXIT_HOST;\n\tcase SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 0x1f: {\n\t\tu32 excp_bits = 1 << (exit_code - SVM_EXIT_EXCP_BASE);\n\n\t\tif (svm->vmcb01.ptr->control.intercepts[INTERCEPT_EXCEPTION] &\n\t\t    excp_bits)\n\t\t\treturn NESTED_EXIT_HOST;\n\t\telse if (exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR &&\n\t\t\t svm->vcpu.arch.apf.host_apf_flags)\n\t\t\t \n\t\t\treturn NESTED_EXIT_HOST;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_VMMCALL:\n\t\t \n\t\tif (guest_hv_cpuid_has_l2_tlb_flush(vcpu) &&\n\t\t    nested_svm_l2_tlb_flush_enabled(vcpu) &&\n\t\t    kvm_hv_is_tlb_flush_hcall(vcpu))\n\t\t\treturn NESTED_EXIT_HOST;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NESTED_EXIT_CONTINUE;\n}\n\nvoid nested_svm_update_tsc_ratio_msr(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tvcpu->arch.tsc_scaling_ratio =\n\t\tkvm_calc_nested_tsc_multiplier(vcpu->arch.l1_tsc_scaling_ratio,\n\t\t\t\t\t       svm->tsc_ratio_msr);\n\tsvm_write_tsc_multiplier(vcpu);\n}\n\n \nstatic void nested_copy_vmcb_cache_to_control(struct vmcb_control_area *dst,\n\t\t\t\t\t      struct vmcb_ctrl_area_cached *from)\n{\n\tunsigned int i;\n\n\tmemset(dst, 0, sizeof(struct vmcb_control_area));\n\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tdst->intercepts[i] = from->intercepts[i];\n\n\tdst->iopm_base_pa         = from->iopm_base_pa;\n\tdst->msrpm_base_pa        = from->msrpm_base_pa;\n\tdst->tsc_offset           = from->tsc_offset;\n\tdst->asid                 = from->asid;\n\tdst->tlb_ctl              = from->tlb_ctl;\n\tdst->int_ctl              = from->int_ctl;\n\tdst->int_vector           = from->int_vector;\n\tdst->int_state            = from->int_state;\n\tdst->exit_code            = from->exit_code;\n\tdst->exit_code_hi         = from->exit_code_hi;\n\tdst->exit_info_1          = from->exit_info_1;\n\tdst->exit_info_2          = from->exit_info_2;\n\tdst->exit_int_info        = from->exit_int_info;\n\tdst->exit_int_info_err    = from->exit_int_info_err;\n\tdst->nested_ctl           = from->nested_ctl;\n\tdst->event_inj            = from->event_inj;\n\tdst->event_inj_err        = from->event_inj_err;\n\tdst->next_rip             = from->next_rip;\n\tdst->nested_cr3           = from->nested_cr3;\n\tdst->virt_ext              = from->virt_ext;\n\tdst->pause_filter_count   = from->pause_filter_count;\n\tdst->pause_filter_thresh  = from->pause_filter_thresh;\n\t \n}\n\nstatic int svm_get_nested_state(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_nested_state __user *user_kvm_nested_state,\n\t\t\t\tu32 user_data_size)\n{\n\tstruct vcpu_svm *svm;\n\tstruct vmcb_control_area *ctl;\n\tunsigned long r;\n\tstruct kvm_nested_state kvm_state = {\n\t\t.flags = 0,\n\t\t.format = KVM_STATE_NESTED_FORMAT_SVM,\n\t\t.size = sizeof(kvm_state),\n\t};\n\tstruct vmcb __user *user_vmcb = (struct vmcb __user *)\n\t\t&user_kvm_nested_state->data.svm[0];\n\n\tif (!vcpu)\n\t\treturn kvm_state.size + KVM_STATE_NESTED_SVM_VMCB_SIZE;\n\n\tsvm = to_svm(vcpu);\n\n\tif (user_data_size < kvm_state.size)\n\t\tgoto out;\n\n\t \n\tif (is_guest_mode(vcpu)) {\n\t\tkvm_state.hdr.svm.vmcb_pa = svm->nested.vmcb12_gpa;\n\t\tkvm_state.size += KVM_STATE_NESTED_SVM_VMCB_SIZE;\n\t\tkvm_state.flags |= KVM_STATE_NESTED_GUEST_MODE;\n\n\t\tif (svm->nested.nested_run_pending)\n\t\t\tkvm_state.flags |= KVM_STATE_NESTED_RUN_PENDING;\n\t}\n\n\tif (gif_set(svm))\n\t\tkvm_state.flags |= KVM_STATE_NESTED_GIF_SET;\n\n\tif (copy_to_user(user_kvm_nested_state, &kvm_state, sizeof(kvm_state)))\n\t\treturn -EFAULT;\n\n\tif (!is_guest_mode(vcpu))\n\t\tgoto out;\n\n\t \n\tif (clear_user(user_vmcb, KVM_STATE_NESTED_SVM_VMCB_SIZE))\n\t\treturn -EFAULT;\n\n\tctl = kzalloc(sizeof(*ctl), GFP_KERNEL);\n\tif (!ctl)\n\t\treturn -ENOMEM;\n\n\tnested_copy_vmcb_cache_to_control(ctl, &svm->nested.ctl);\n\tr = copy_to_user(&user_vmcb->control, ctl,\n\t\t\t sizeof(user_vmcb->control));\n\tkfree(ctl);\n\tif (r)\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(&user_vmcb->save, &svm->vmcb01.ptr->save,\n\t\t\t sizeof(user_vmcb->save)))\n\t\treturn -EFAULT;\nout:\n\treturn kvm_state.size;\n}\n\nstatic int svm_set_nested_state(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_nested_state __user *user_kvm_nested_state,\n\t\t\t\tstruct kvm_nested_state *kvm_state)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb __user *user_vmcb = (struct vmcb __user *)\n\t\t&user_kvm_nested_state->data.svm[0];\n\tstruct vmcb_control_area *ctl;\n\tstruct vmcb_save_area *save;\n\tstruct vmcb_save_area_cached save_cached;\n\tstruct vmcb_ctrl_area_cached ctl_cached;\n\tunsigned long cr0;\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(struct vmcb_control_area) + sizeof(struct vmcb_save_area) >\n\t\t     KVM_STATE_NESTED_SVM_VMCB_SIZE);\n\n\tif (kvm_state->format != KVM_STATE_NESTED_FORMAT_SVM)\n\t\treturn -EINVAL;\n\n\tif (kvm_state->flags & ~(KVM_STATE_NESTED_GUEST_MODE |\n\t\t\t\t KVM_STATE_NESTED_RUN_PENDING |\n\t\t\t\t KVM_STATE_NESTED_GIF_SET))\n\t\treturn -EINVAL;\n\n\t \n\tif (!(vcpu->arch.efer & EFER_SVME)) {\n\t\t \n\t\tif (kvm_state->flags != KVM_STATE_NESTED_GIF_SET)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (is_smm(vcpu) && (kvm_state->flags & KVM_STATE_NESTED_GUEST_MODE))\n\t\treturn -EINVAL;\n\n\tif (!(kvm_state->flags & KVM_STATE_NESTED_GUEST_MODE)) {\n\t\tsvm_leave_nested(vcpu);\n\t\tsvm_set_gif(svm, !!(kvm_state->flags & KVM_STATE_NESTED_GIF_SET));\n\t\treturn 0;\n\t}\n\n\tif (!page_address_valid(vcpu, kvm_state->hdr.svm.vmcb_pa))\n\t\treturn -EINVAL;\n\tif (kvm_state->size < sizeof(*kvm_state) + KVM_STATE_NESTED_SVM_VMCB_SIZE)\n\t\treturn -EINVAL;\n\n\tret  = -ENOMEM;\n\tctl  = kzalloc(sizeof(*ctl),  GFP_KERNEL_ACCOUNT);\n\tsave = kzalloc(sizeof(*save), GFP_KERNEL_ACCOUNT);\n\tif (!ctl || !save)\n\t\tgoto out_free;\n\n\tret = -EFAULT;\n\tif (copy_from_user(ctl, &user_vmcb->control, sizeof(*ctl)))\n\t\tgoto out_free;\n\tif (copy_from_user(save, &user_vmcb->save, sizeof(*save)))\n\t\tgoto out_free;\n\n\tret = -EINVAL;\n\t__nested_copy_vmcb_control_to_cache(vcpu, &ctl_cached, ctl);\n\tif (!__nested_vmcb_check_controls(vcpu, &ctl_cached))\n\t\tgoto out_free;\n\n\t \n\tcr0 = kvm_read_cr0(vcpu);\n        if (((cr0 & X86_CR0_CD) == 0) && (cr0 & X86_CR0_NW))\n\t\tgoto out_free;\n\n\t \n\t__nested_copy_vmcb_save_to_cache(&save_cached, save);\n\tif (!(save->cr0 & X86_CR0_PG) ||\n\t    !(save->cr0 & X86_CR0_PE) ||\n\t    (save->rflags & X86_EFLAGS_VM) ||\n\t    !__nested_vmcb_check_save(vcpu, &save_cached))\n\t\tgoto out_free;\n\n\n\t \n\n\tif (is_guest_mode(vcpu))\n\t\tsvm_leave_nested(vcpu);\n\telse\n\t\tsvm->nested.vmcb02.ptr->save = svm->vmcb01.ptr->save;\n\n\tsvm_set_gif(svm, !!(kvm_state->flags & KVM_STATE_NESTED_GIF_SET));\n\n\tsvm->nested.nested_run_pending =\n\t\t!!(kvm_state->flags & KVM_STATE_NESTED_RUN_PENDING);\n\n\tsvm->nested.vmcb12_gpa = kvm_state->hdr.svm.vmcb_pa;\n\n\tsvm_copy_vmrun_state(&svm->vmcb01.ptr->save, save);\n\tnested_copy_vmcb_control_to_cache(svm, ctl);\n\n\tsvm_switch_vmcb(svm, &svm->nested.vmcb02);\n\tnested_vmcb02_prepare_control(svm, svm->vmcb->save.rip, svm->vmcb->save.cs.base);\n\n\t \n\n\tret = nested_svm_load_cr3(&svm->vcpu, vcpu->arch.cr3,\n\t\t\t\t  nested_npt_enabled(svm), false);\n\tif (WARN_ON_ONCE(ret))\n\t\tgoto out_free;\n\n\tsvm->nested.force_msr_bitmap_recalc = true;\n\n\tkvm_make_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu);\n\tret = 0;\nout_free:\n\tkfree(save);\n\tkfree(ctl);\n\n\treturn ret;\n}\n\nstatic bool svm_get_nested_state_pages(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (WARN_ON(!is_guest_mode(vcpu)))\n\t\treturn true;\n\n\tif (!vcpu->arch.pdptrs_from_userspace &&\n\t    !nested_npt_enabled(svm) && is_pae_paging(vcpu))\n\t\t \n\t\tif (CC(!load_pdptrs(vcpu, vcpu->arch.cr3)))\n\t\t\treturn false;\n\n\tif (!nested_svm_vmrun_msrpm(svm)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror =\n\t\t\tKVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\treturn false;\n\t}\n\n\tif (kvm_hv_verify_vp_assist(vcpu))\n\t\treturn false;\n\n\treturn true;\n}\n\nstruct kvm_x86_nested_ops svm_nested_ops = {\n\t.leave_nested = svm_leave_nested,\n\t.is_exception_vmexit = nested_svm_is_exception_vmexit,\n\t.check_events = svm_check_nested_events,\n\t.triple_fault = nested_svm_triple_fault,\n\t.get_nested_state_pages = svm_get_nested_state_pages,\n\t.get_state = svm_get_nested_state,\n\t.set_state = svm_set_nested_state,\n\t.hv_inject_synthetic_vmexit_post_tlb_flush = svm_hv_inject_synthetic_vmexit_post_tlb_flush,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}