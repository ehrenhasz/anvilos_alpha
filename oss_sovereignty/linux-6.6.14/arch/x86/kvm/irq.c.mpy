{
  "module_name": "irq.c",
  "hash_id": "8ee117d5bb11168f70b0829c3b6b83cacd9c77908f7b9df1b3fcacf06570d236",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/irq.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/export.h>\n#include <linux/kvm_host.h>\n\n#include \"irq.h\"\n#include \"i8254.h\"\n#include \"x86.h\"\n#include \"xen.h\"\n\n \nint kvm_cpu_has_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tint r = 0;\n\n\tif (lapic_in_kernel(vcpu))\n\t\tr = apic_has_pending_timer(vcpu);\n\tif (kvm_xen_timer_enabled(vcpu))\n\t\tr += kvm_xen_has_pending_timer(vcpu);\n\n\treturn r;\n}\n\n \nstatic int pending_userspace_extint(struct kvm_vcpu *v)\n{\n\treturn v->arch.pending_external_vector != -1;\n}\n\n \nint kvm_cpu_has_extint(struct kvm_vcpu *v)\n{\n\t \n\tif (!lapic_in_kernel(v))\n\t\treturn v->arch.interrupt.injected;\n\n\tif (kvm_xen_has_interrupt(v))\n\t\treturn 1;\n\n\tif (!kvm_apic_accept_pic_intr(v))\n\t\treturn 0;\n\n\tif (irqchip_split(v->kvm))\n\t\treturn pending_userspace_extint(v);\n\telse\n\t\treturn v->kvm->arch.vpic->output;\n}\n\n \nint kvm_cpu_has_injectable_intr(struct kvm_vcpu *v)\n{\n\tif (kvm_cpu_has_extint(v))\n\t\treturn 1;\n\n\tif (!is_guest_mode(v) && kvm_vcpu_apicv_active(v))\n\t\treturn 0;\n\n\treturn kvm_apic_has_interrupt(v) != -1;  \n}\nEXPORT_SYMBOL_GPL(kvm_cpu_has_injectable_intr);\n\n \nint kvm_cpu_has_interrupt(struct kvm_vcpu *v)\n{\n\tif (kvm_cpu_has_extint(v))\n\t\treturn 1;\n\n\treturn kvm_apic_has_interrupt(v) != -1;\t \n}\nEXPORT_SYMBOL_GPL(kvm_cpu_has_interrupt);\n\n \nstatic int kvm_cpu_get_extint(struct kvm_vcpu *v)\n{\n\tif (!kvm_cpu_has_extint(v)) {\n\t\tWARN_ON(!lapic_in_kernel(v));\n\t\treturn -1;\n\t}\n\n\tif (!lapic_in_kernel(v))\n\t\treturn v->arch.interrupt.nr;\n\n\tif (kvm_xen_has_interrupt(v))\n\t\treturn v->kvm->arch.xen.upcall_vector;\n\n\tif (irqchip_split(v->kvm)) {\n\t\tint vector = v->arch.pending_external_vector;\n\n\t\tv->arch.pending_external_vector = -1;\n\t\treturn vector;\n\t} else\n\t\treturn kvm_pic_read_irq(v->kvm);  \n}\n\n \nint kvm_cpu_get_interrupt(struct kvm_vcpu *v)\n{\n\tint vector = kvm_cpu_get_extint(v);\n\tif (vector != -1)\n\t\treturn vector;\t\t\t \n\n\treturn kvm_get_apic_interrupt(v);\t \n}\nEXPORT_SYMBOL_GPL(kvm_cpu_get_interrupt);\n\nvoid kvm_inject_pending_timer_irqs(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_inject_apic_timer_irqs(vcpu);\n\tif (kvm_xen_timer_enabled(vcpu))\n\t\tkvm_xen_inject_timer_irqs(vcpu);\n}\n\nvoid __kvm_migrate_timers(struct kvm_vcpu *vcpu)\n{\n\t__kvm_migrate_apic_timer(vcpu);\n\t__kvm_migrate_pit_timer(vcpu);\n\tstatic_call_cond(kvm_x86_migrate_timers)(vcpu);\n}\n\nbool kvm_arch_irqfd_allowed(struct kvm *kvm, struct kvm_irqfd *args)\n{\n\tbool resample = args->flags & KVM_IRQFD_FLAG_RESAMPLE;\n\n\treturn resample ? irqchip_kernel(kvm) : irqchip_in_kernel(kvm);\n}\n\nbool kvm_arch_irqchip_in_kernel(struct kvm *kvm)\n{\n\treturn irqchip_in_kernel(kvm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}