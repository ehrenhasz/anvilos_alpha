{
  "module_name": "ioapic.c",
  "hash_id": "ecf1abd8c826d2d12b2f40e906d7950cb358d558ac58505b5653b921af9c6672",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/ioapic.c",
  "human_readable_source": " \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kvm_host.h>\n#include <linux/kvm.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/smp.h>\n#include <linux/hrtimer.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/nospec.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/current.h>\n#include <trace/events/kvm.h>\n\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"irq.h\"\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\n\nstatic void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_ioapic *ioapic,\n\t\t\t\t      int trigger_mode,\n\t\t\t\t      int pin);\n\nstatic unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic)\n{\n\tunsigned long result = 0;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content = ~0ULL;\n\n\t\t\tif (redir_index < IOAPIC_NUM_PINS) {\n\t\t\t\tu32 index = array_index_nospec(\n\t\t\t\t\tredir_index, IOAPIC_NUM_PINS);\n\n\t\t\t\tredir_content = ioapic->redirtbl[index].bits;\n\t\t\t}\n\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPU_IDS);\n}\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_status_pending_eoi_check_valid(struct kvm_ioapic *ioapic)\n{\n\tif (WARN_ON(ioapic->rtc_status.pending_eoi < 0))\n\t\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}\n\nstatic void __rtc_irq_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tbool new_val, old_val;\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\te = &ioapic->redirtbl[RTC_GSI];\n\tif (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t e->fields.dest_id,\n\t\t\t\t kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))\n\t\treturn;\n\n\tnew_val = kvm_apic_pending_eoi(vcpu, e->fields.vector);\n\told_val = test_bit(vcpu->vcpu_id, dest_map->map);\n\n\tif (new_val == old_val)\n\t\treturn;\n\n\tif (new_val) {\n\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\tdest_map->vectors[vcpu->vcpu_id] = e->fields.vector;\n\t\tioapic->rtc_status.pending_eoi++;\n\t} else {\n\t\t__clear_bit(vcpu->vcpu_id, dest_map->map);\n\t\tioapic->rtc_status.pending_eoi--;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}\n\nvoid kvm_rtc_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\t__rtc_irq_eoi_tracking_restore_one(vcpu);\n\tspin_unlock(&ioapic->lock);\n}\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long i;\n\n\tif (RTC_GSI >= IOAPIC_NUM_PINS)\n\t\treturn;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm)\n\t    __rtc_irq_eoi_tracking_restore_one(vcpu);\n}\n\nstatic void rtc_irq_eoi(struct kvm_ioapic *ioapic, struct kvm_vcpu *vcpu,\n\t\t\tint vector)\n{\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\n\t \n\tif (test_bit(vcpu->vcpu_id, dest_map->map) &&\n\t    (vector == dest_map->vectors[vcpu->vcpu_id]) &&\n\t    (test_and_clear_bit(vcpu->vcpu_id,\n\t\t\t\tioapic->rtc_status.dest_map.map))) {\n\t\t--ioapic->rtc_status.pending_eoi;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}\n\nstatic bool rtc_irq_check_coalesced(struct kvm_ioapic *ioapic)\n{\n\tif (ioapic->rtc_status.pending_eoi > 0)\n\t\treturn true;  \n\n\treturn false;\n}\n\nstatic void ioapic_lazy_update_eoi(struct kvm_ioapic *ioapic, int irq)\n{\n\tunsigned long i;\n\tstruct kvm_vcpu *vcpu;\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm) {\n\t\tif (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t\t entry->fields.dest_id,\n\t\t\t\t\t entry->fields.dest_mode) ||\n\t\t    kvm_apic_pending_eoi(vcpu, entry->fields.vector))\n\t\t\tcontinue;\n\n\t\t \n\t\trtc_irq_eoi(ioapic, vcpu, entry->fields.vector);\n\t\tbreak;\n\t}\n}\n\nstatic int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,\n\t\tint irq_level, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry entry;\n\tu32 mask = 1 << irq;\n\tu32 old_irr;\n\tint edge, ret;\n\n\tentry = ioapic->redirtbl[irq];\n\tedge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);\n\n\tif (!irq_level) {\n\t\tioapic->irr &= ~mask;\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (edge && kvm_apicv_activated(ioapic->kvm))\n\t\tioapic_lazy_update_eoi(ioapic, irq);\n\n\t \n\tif (irq == RTC_GSI && line_status &&\n\t\trtc_irq_check_coalesced(ioapic)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\told_irr = ioapic->irr;\n\tioapic->irr |= mask;\n\tif (edge) {\n\t\tioapic->irr_delivered &= ~mask;\n\t\tif (old_irr == ioapic->irr) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ioapic_service(ioapic, irq, line_status);\n\nout:\n\ttrace_kvm_ioapic_set_irq(entry.bits, irq, ret == 0);\n\treturn ret;\n}\n\nstatic void kvm_ioapic_inject_all(struct kvm_ioapic *ioapic, unsigned long irr)\n{\n\tu32 idx;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tfor_each_set_bit(idx, &irr, IOAPIC_NUM_PINS)\n\t\tioapic_set_irq(ioapic, idx, 1, true);\n\n\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}\n\n\nvoid kvm_ioapic_scan_entry(struct kvm_vcpu *vcpu, ulong *ioapic_handled_vectors)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\tunion kvm_ioapic_redirect_entry *e;\n\tint index;\n\n\tspin_lock(&ioapic->lock);\n\n\t \n\tif (test_bit(vcpu->vcpu_id, dest_map->map))\n\t\t__set_bit(dest_map->vectors[vcpu->vcpu_id],\n\t\t\t  ioapic_handled_vectors);\n\n\tfor (index = 0; index < IOAPIC_NUM_PINS; index++) {\n\t\te = &ioapic->redirtbl[index];\n\t\tif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG ||\n\t\t    kvm_irq_has_notifier(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index) ||\n\t\t    index == RTC_GSI) {\n\t\t\tu16 dm = kvm_lapic_irq_dest_mode(!!e->fields.dest_mode);\n\n\t\t\tif (kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t\t\te->fields.dest_id, dm) ||\n\t\t\t    kvm_apic_pending_eoi(vcpu, e->fields.vector))\n\t\t\t\t__set_bit(e->fields.vector,\n\t\t\t\t\t  ioapic_handled_vectors);\n\t\t}\n\t}\n\tspin_unlock(&ioapic->lock);\n}\n\nvoid kvm_arch_post_irq_ack_notifier_list_update(struct kvm *kvm)\n{\n\tif (!ioapic_in_kernel(kvm))\n\t\treturn;\n\tkvm_make_scan_ioapic_request(kvm);\n}\n\nstatic void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)\n{\n\tunsigned index;\n\tbool mask_before, mask_after;\n\tunion kvm_ioapic_redirect_entry *e;\n\tint old_remote_irr, old_delivery_status, old_dest_id, old_dest_mode;\n\tDECLARE_BITMAP(vcpu_bitmap, KVM_MAX_VCPUS);\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\t \n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\t\tioapic->id = (val >> 24) & 0xf;\n\t\tbreak;\n\n\tcase IOAPIC_REG_ARB_ID:\n\t\tbreak;\n\n\tdefault:\n\t\tindex = (ioapic->ioregsel - 0x10) >> 1;\n\n\t\tif (index >= IOAPIC_NUM_PINS)\n\t\t\treturn;\n\t\tindex = array_index_nospec(index, IOAPIC_NUM_PINS);\n\t\te = &ioapic->redirtbl[index];\n\t\tmask_before = e->fields.mask;\n\t\t \n\t\told_remote_irr = e->fields.remote_irr;\n\t\told_delivery_status = e->fields.delivery_status;\n\t\told_dest_id = e->fields.dest_id;\n\t\told_dest_mode = e->fields.dest_mode;\n\t\tif (ioapic->ioregsel & 1) {\n\t\t\te->bits &= 0xffffffff;\n\t\t\te->bits |= (u64) val << 32;\n\t\t} else {\n\t\t\te->bits &= ~0xffffffffULL;\n\t\t\te->bits |= (u32) val;\n\t\t}\n\t\te->fields.remote_irr = old_remote_irr;\n\t\te->fields.delivery_status = old_delivery_status;\n\n\t\t \n\t\tif (e->fields.trig_mode == IOAPIC_EDGE_TRIG)\n\t\t\te->fields.remote_irr = 0;\n\n\t\tmask_after = e->fields.mask;\n\t\tif (mask_before != mask_after)\n\t\t\tkvm_fire_mask_notifiers(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index, mask_after);\n\t\tif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG &&\n\t\t    ioapic->irr & (1 << index) && !e->fields.mask && !e->fields.remote_irr) {\n\t\t\t \n\t\t\tif (kvm_notify_irqfd_resampler(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index))\n\t\t\t\tioapic->irr &= ~(1 << index);\n\t\t\telse\n\t\t\t\tioapic_service(ioapic, index, false);\n\t\t}\n\t\tif (e->fields.delivery_mode == APIC_DM_FIXED) {\n\t\t\tstruct kvm_lapic_irq irq;\n\n\t\t\tirq.vector = e->fields.vector;\n\t\t\tirq.delivery_mode = e->fields.delivery_mode << 8;\n\t\t\tirq.dest_mode =\n\t\t\t    kvm_lapic_irq_dest_mode(!!e->fields.dest_mode);\n\t\t\tirq.level = false;\n\t\t\tirq.trig_mode = e->fields.trig_mode;\n\t\t\tirq.shorthand = APIC_DEST_NOSHORT;\n\t\t\tirq.dest_id = e->fields.dest_id;\n\t\t\tirq.msi_redir_hint = false;\n\t\t\tbitmap_zero(vcpu_bitmap, KVM_MAX_VCPUS);\n\t\t\tkvm_bitmap_or_dest_vcpus(ioapic->kvm, &irq,\n\t\t\t\t\t\t vcpu_bitmap);\n\t\t\tif (old_dest_mode != e->fields.dest_mode ||\n\t\t\t    old_dest_id != e->fields.dest_id) {\n\t\t\t\t \n\t\t\t\tirq.dest_id = old_dest_id;\n\t\t\t\tirq.dest_mode =\n\t\t\t\t    kvm_lapic_irq_dest_mode(\n\t\t\t\t\t!!e->fields.dest_mode);\n\t\t\t\tkvm_bitmap_or_dest_vcpus(ioapic->kvm, &irq,\n\t\t\t\t\t\t\t vcpu_bitmap);\n\t\t\t}\n\t\t\tkvm_make_scan_ioapic_request_mask(ioapic->kvm,\n\t\t\t\t\t\t\t  vcpu_bitmap);\n\t\t} else {\n\t\t\tkvm_make_scan_ioapic_request(ioapic->kvm);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask ||\n\t    (entry->fields.trig_mode == IOAPIC_LEVEL_TRIG &&\n\t    entry->fields.remote_irr))\n\t\treturn -1;\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = kvm_lapic_irq_dest_mode(!!entry->fields.dest_mode);\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = APIC_DEST_NOSHORT;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t \n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}\n\nint kvm_ioapic_set_irq(struct kvm_ioapic *ioapic, int irq, int irq_source_id,\n\t\t       int level, bool line_status)\n{\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= IOAPIC_NUM_PINS);\n\n\tspin_lock(&ioapic->lock);\n\tirq_level = __kvm_irq_line_state(&ioapic->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tret = ioapic_set_irq(ioapic, irq, irq_level, line_status);\n\n\tspin_unlock(&ioapic->lock);\n\n\treturn ret;\n}\n\nvoid kvm_ioapic_clear_all(struct kvm_ioapic *ioapic, int irq_source_id)\n{\n\tint i;\n\n\tspin_lock(&ioapic->lock);\n\tfor (i = 0; i < KVM_IOAPIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &ioapic->irq_states[i]);\n\tspin_unlock(&ioapic->lock);\n}\n\nstatic void kvm_ioapic_eoi_inject_work(struct work_struct *work)\n{\n\tint i;\n\tstruct kvm_ioapic *ioapic = container_of(work, struct kvm_ioapic,\n\t\t\t\t\t\t eoi_inject.work);\n\tspin_lock(&ioapic->lock);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++) {\n\t\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];\n\n\t\tif (ent->fields.trig_mode != IOAPIC_LEVEL_TRIG)\n\t\t\tcontinue;\n\n\t\tif (ioapic->irr & (1 << i) && !ent->fields.remote_irr)\n\t\t\tioapic_service(ioapic, i, false);\n\t}\n\tspin_unlock(&ioapic->lock);\n}\n\n#define IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT 10000\nstatic void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_ioapic *ioapic,\n\t\t\t\t      int trigger_mode,\n\t\t\t\t      int pin)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];\n\n\t \n\tspin_unlock(&ioapic->lock);\n\tkvm_notify_acked_irq(ioapic->kvm, KVM_IRQCHIP_IOAPIC, pin);\n\tspin_lock(&ioapic->lock);\n\n\tif (trigger_mode != IOAPIC_LEVEL_TRIG ||\n\t    kvm_lapic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI)\n\t\treturn;\n\n\tASSERT(ent->fields.trig_mode == IOAPIC_LEVEL_TRIG);\n\tent->fields.remote_irr = 0;\n\tif (!ent->fields.mask && (ioapic->irr & (1 << pin))) {\n\t\t++ioapic->irq_eoi[pin];\n\t\tif (ioapic->irq_eoi[pin] == IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT) {\n\t\t\t \n\t\t\tschedule_delayed_work(&ioapic->eoi_inject, HZ / 100);\n\t\t\tioapic->irq_eoi[pin] = 0;\n\t\t\ttrace_kvm_ioapic_delayed_eoi_inj(ent->bits);\n\t\t} else {\n\t\t\tioapic_service(ioapic, pin, false);\n\t\t}\n\t} else {\n\t\tioapic->irq_eoi[pin] = 0;\n\t}\n}\n\nvoid kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu, int vector, int trigger_mode)\n{\n\tint i;\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\trtc_irq_eoi(ioapic, vcpu, vector);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++) {\n\t\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];\n\n\t\tif (ent->fields.vector != vector)\n\t\t\tcontinue;\n\t\tkvm_ioapic_update_eoi_one(vcpu, ioapic, trigger_mode, i);\n\t}\n\tspin_unlock(&ioapic->lock);\n}\n\nstatic inline struct kvm_ioapic *to_ioapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_ioapic, dev);\n}\n\nstatic inline int ioapic_in_range(struct kvm_ioapic *ioapic, gpa_t addr)\n{\n\treturn ((addr >= ioapic->base_address &&\n\t\t (addr < ioapic->base_address + IOAPIC_MEM_LENGTH)));\n}\n\nstatic int ioapic_mmio_read(struct kvm_vcpu *vcpu, struct kvm_io_device *this,\n\t\t\t\tgpa_t addr, int len, void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 result;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\n\tASSERT(!(addr & 0xf));\t \n\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tresult = ioapic->ioregsel;\n\t\tbreak;\n\n\tcase IOAPIC_REG_WINDOW:\n\t\tresult = ioapic_read_indirect(ioapic);\n\t\tbreak;\n\n\tdefault:\n\t\tresult = 0;\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\n\tswitch (len) {\n\tcase 8:\n\t\t*(u64 *) val = result;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(val, (char *)&result, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: wrong length %d\\n\", len);\n\t}\n\treturn 0;\n}\n\nstatic int ioapic_mmio_write(struct kvm_vcpu *vcpu, struct kvm_io_device *this,\n\t\t\t\t gpa_t addr, int len, const void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 data;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\n\tASSERT(!(addr & 0xf));\t \n\n\tswitch (len) {\n\tcase 8:\n\tcase 4:\n\t\tdata = *(u32 *) val;\n\t\tbreak;\n\tcase 2:\n\t\tdata = *(u16 *) val;\n\t\tbreak;\n\tcase 1:\n\t\tdata = *(u8  *) val;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: Unsupported size %d\\n\", len);\n\t\treturn 0;\n\t}\n\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tioapic->ioregsel = data & 0xFF;  \n\t\tbreak;\n\n\tcase IOAPIC_REG_WINDOW:\n\t\tioapic_write_indirect(ioapic, data);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}\n\nstatic void kvm_ioapic_reset(struct kvm_ioapic *ioapic)\n{\n\tint i;\n\n\tcancel_delayed_work_sync(&ioapic->eoi_inject);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++)\n\t\tioapic->redirtbl[i].fields.mask = 1;\n\tioapic->base_address = IOAPIC_DEFAULT_BASE_ADDRESS;\n\tioapic->ioregsel = 0;\n\tioapic->irr = 0;\n\tioapic->irr_delivered = 0;\n\tioapic->id = 0;\n\tmemset(ioapic->irq_eoi, 0x00, sizeof(ioapic->irq_eoi));\n\trtc_irq_eoi_tracking_reset(ioapic);\n}\n\nstatic const struct kvm_io_device_ops ioapic_mmio_ops = {\n\t.read     = ioapic_mmio_read,\n\t.write    = ioapic_mmio_write,\n};\n\nint kvm_ioapic_init(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic;\n\tint ret;\n\n\tioapic = kzalloc(sizeof(struct kvm_ioapic), GFP_KERNEL_ACCOUNT);\n\tif (!ioapic)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&ioapic->lock);\n\tINIT_DELAYED_WORK(&ioapic->eoi_inject, kvm_ioapic_eoi_inject_work);\n\tkvm->arch.vioapic = ioapic;\n\tkvm_ioapic_reset(ioapic);\n\tkvm_iodevice_init(&ioapic->dev, &ioapic_mmio_ops);\n\tioapic->kvm = kvm;\n\tmutex_lock(&kvm->slots_lock);\n\tret = kvm_io_bus_register_dev(kvm, KVM_MMIO_BUS, ioapic->base_address,\n\t\t\t\t      IOAPIC_MEM_LENGTH, &ioapic->dev);\n\tmutex_unlock(&kvm->slots_lock);\n\tif (ret < 0) {\n\t\tkvm->arch.vioapic = NULL;\n\t\tkfree(ioapic);\n\t}\n\n\treturn ret;\n}\n\nvoid kvm_ioapic_destroy(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tif (!ioapic)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&ioapic->eoi_inject);\n\tmutex_lock(&kvm->slots_lock);\n\tkvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);\n\tmutex_unlock(&kvm->slots_lock);\n\tkvm->arch.vioapic = NULL;\n\tkfree(ioapic);\n}\n\nvoid kvm_get_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(state, ioapic, sizeof(struct kvm_ioapic_state));\n\tstate->irr &= ~ioapic->irr_delivered;\n\tspin_unlock(&ioapic->lock);\n}\n\nvoid kvm_set_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(ioapic, state, sizeof(struct kvm_ioapic_state));\n\tioapic->irr = 0;\n\tioapic->irr_delivered = 0;\n\tkvm_make_scan_ioapic_request(kvm);\n\tkvm_ioapic_inject_all(ioapic, state->irr);\n\tspin_unlock(&ioapic->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}