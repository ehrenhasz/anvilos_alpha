{
  "module_name": "cpuid.h",
  "hash_id": "710dd490ba694249acb1f11ab9c3935d37efcf6a9e616782561c66a54e012f2a",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/cpuid.h",
  "human_readable_source": " \n#ifndef ARCH_X86_KVM_CPUID_H\n#define ARCH_X86_KVM_CPUID_H\n\n#include \"x86.h\"\n#include \"reverse_cpuid.h\"\n#include <asm/cpu.h>\n#include <asm/processor.h>\n#include <uapi/asm/kvm_para.h>\n\nextern u32 kvm_cpu_caps[NR_KVM_CPU_CAPS] __read_mostly;\nvoid kvm_set_cpu_caps(void);\n\nvoid kvm_update_cpuid_runtime(struct kvm_vcpu *vcpu);\nvoid kvm_update_pv_runtime(struct kvm_vcpu *vcpu);\nstruct kvm_cpuid_entry2 *kvm_find_cpuid_entry_index(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t    u32 function, u32 index);\nstruct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function);\nint kvm_dev_ioctl_get_cpuid(struct kvm_cpuid2 *cpuid,\n\t\t\t    struct kvm_cpuid_entry2 __user *entries,\n\t\t\t    unsigned int type);\nint kvm_vcpu_ioctl_set_cpuid(struct kvm_vcpu *vcpu,\n\t\t\t     struct kvm_cpuid *cpuid,\n\t\t\t     struct kvm_cpuid_entry __user *entries);\nint kvm_vcpu_ioctl_set_cpuid2(struct kvm_vcpu *vcpu,\n\t\t\t      struct kvm_cpuid2 *cpuid,\n\t\t\t      struct kvm_cpuid_entry2 __user *entries);\nint kvm_vcpu_ioctl_get_cpuid2(struct kvm_vcpu *vcpu,\n\t\t\t      struct kvm_cpuid2 *cpuid,\n\t\t\t      struct kvm_cpuid_entry2 __user *entries);\nbool kvm_cpuid(struct kvm_vcpu *vcpu, u32 *eax, u32 *ebx,\n\t       u32 *ecx, u32 *edx, bool exact_only);\n\nu32 xstate_required_size(u64 xstate_bv, bool compacted);\n\nint cpuid_query_maxphyaddr(struct kvm_vcpu *vcpu);\nu64 kvm_vcpu_reserved_gpa_bits_raw(struct kvm_vcpu *vcpu);\n\nstatic inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}\n\nstatic inline bool kvm_vcpu_is_legal_gpa(struct kvm_vcpu *vcpu, gpa_t gpa)\n{\n\treturn !(gpa & vcpu->arch.reserved_gpa_bits);\n}\n\nstatic inline bool kvm_vcpu_is_illegal_gpa(struct kvm_vcpu *vcpu, gpa_t gpa)\n{\n\treturn !kvm_vcpu_is_legal_gpa(vcpu, gpa);\n}\n\nstatic inline bool kvm_vcpu_is_legal_aligned_gpa(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t gpa_t gpa, gpa_t alignment)\n{\n\treturn IS_ALIGNED(gpa, alignment) && kvm_vcpu_is_legal_gpa(vcpu, gpa);\n}\n\nstatic inline bool page_address_valid(struct kvm_vcpu *vcpu, gpa_t gpa)\n{\n\treturn kvm_vcpu_is_legal_aligned_gpa(vcpu, gpa, PAGE_SIZE);\n}\n\nstatic __always_inline void cpuid_entry_override(struct kvm_cpuid_entry2 *entry,\n\t\t\t\t\t\t unsigned int leaf)\n{\n\tu32 *reg = cpuid_entry_get_reg(entry, leaf * 32);\n\n\tBUILD_BUG_ON(leaf >= ARRAY_SIZE(kvm_cpu_caps));\n\t*reg = kvm_cpu_caps[leaf];\n}\n\nstatic __always_inline u32 *guest_cpuid_get_register(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t     unsigned int x86_feature)\n{\n\tconst struct cpuid_reg cpuid = x86_feature_cpuid(x86_feature);\n\tstruct kvm_cpuid_entry2 *entry;\n\n\tentry = kvm_find_cpuid_entry_index(vcpu, cpuid.function, cpuid.index);\n\tif (!entry)\n\t\treturn NULL;\n\n\treturn __cpuid_entry_get_reg(entry, cpuid.reg);\n}\n\nstatic __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}\n\nstatic __always_inline void guest_cpuid_clear(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (reg)\n\t\t*reg &= ~__feature_bit(x86_feature);\n}\n\nstatic inline bool guest_cpuid_is_amd_or_hygon(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0);\n\treturn best &&\n\t       (is_guest_vendor_amd(best->ebx, best->ecx, best->edx) ||\n\t\tis_guest_vendor_hygon(best->ebx, best->ecx, best->edx));\n}\n\nstatic inline bool guest_cpuid_is_intel(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0);\n\treturn best && is_guest_vendor_intel(best->ebx, best->ecx, best->edx);\n}\n\nstatic inline int guest_cpuid_family(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x1);\n\tif (!best)\n\t\treturn -1;\n\n\treturn x86_family(best->eax);\n}\n\nstatic inline int guest_cpuid_model(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x1);\n\tif (!best)\n\t\treturn -1;\n\n\treturn x86_model(best->eax);\n}\n\nstatic inline bool cpuid_model_is_consistent(struct kvm_vcpu *vcpu)\n{\n\treturn boot_cpu_data.x86_model == guest_cpuid_model(vcpu);\n}\n\nstatic inline int guest_cpuid_stepping(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x1);\n\tif (!best)\n\t\treturn -1;\n\n\treturn x86_stepping(best->eax);\n}\n\nstatic inline bool guest_has_spec_ctrl_msr(struct kvm_vcpu *vcpu)\n{\n\treturn (guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL) ||\n\t\tguest_cpuid_has(vcpu, X86_FEATURE_AMD_STIBP) ||\n\t\tguest_cpuid_has(vcpu, X86_FEATURE_AMD_IBRS) ||\n\t\tguest_cpuid_has(vcpu, X86_FEATURE_AMD_SSBD));\n}\n\nstatic inline bool guest_has_pred_cmd_msr(struct kvm_vcpu *vcpu)\n{\n\treturn (guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL) ||\n\t\tguest_cpuid_has(vcpu, X86_FEATURE_AMD_IBPB));\n}\n\nstatic inline bool supports_cpuid_fault(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.msr_platform_info & MSR_PLATFORM_INFO_CPUID_FAULT;\n}\n\nstatic inline bool cpuid_fault_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.msr_misc_features_enables &\n\t\t  MSR_MISC_FEATURES_ENABLES_CPUID_FAULT;\n}\n\nstatic __always_inline void kvm_cpu_cap_clear(unsigned int x86_feature)\n{\n\tunsigned int x86_leaf = __feature_leaf(x86_feature);\n\n\treverse_cpuid_check(x86_leaf);\n\tkvm_cpu_caps[x86_leaf] &= ~__feature_bit(x86_feature);\n}\n\nstatic __always_inline void kvm_cpu_cap_set(unsigned int x86_feature)\n{\n\tunsigned int x86_leaf = __feature_leaf(x86_feature);\n\n\treverse_cpuid_check(x86_leaf);\n\tkvm_cpu_caps[x86_leaf] |= __feature_bit(x86_feature);\n}\n\nstatic __always_inline u32 kvm_cpu_cap_get(unsigned int x86_feature)\n{\n\tunsigned int x86_leaf = __feature_leaf(x86_feature);\n\n\treverse_cpuid_check(x86_leaf);\n\treturn kvm_cpu_caps[x86_leaf] & __feature_bit(x86_feature);\n}\n\nstatic __always_inline bool kvm_cpu_cap_has(unsigned int x86_feature)\n{\n\treturn !!kvm_cpu_cap_get(x86_feature);\n}\n\nstatic __always_inline void kvm_cpu_cap_check_and_set(unsigned int x86_feature)\n{\n\tif (boot_cpu_has(x86_feature))\n\t\tkvm_cpu_cap_set(x86_feature);\n}\n\nstatic __always_inline bool guest_pv_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t unsigned int kvm_feature)\n{\n\tif (!vcpu->arch.pv_cpuid.enforce)\n\t\treturn true;\n\n\treturn vcpu->arch.pv_cpuid.features & (1u << kvm_feature);\n}\n\nenum kvm_governed_features {\n#define KVM_GOVERNED_FEATURE(x) KVM_GOVERNED_##x,\n#include \"governed_features.h\"\n\tKVM_NR_GOVERNED_FEATURES\n};\n\nstatic __always_inline int kvm_governed_feature_index(unsigned int x86_feature)\n{\n\tswitch (x86_feature) {\n#define KVM_GOVERNED_FEATURE(x) case x: return KVM_GOVERNED_##x;\n#include \"governed_features.h\"\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic __always_inline bool kvm_is_governed_feature(unsigned int x86_feature)\n{\n\treturn kvm_governed_feature_index(x86_feature) >= 0;\n}\n\nstatic __always_inline void kvm_governed_feature_set(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t     unsigned int x86_feature)\n{\n\tBUILD_BUG_ON(!kvm_is_governed_feature(x86_feature));\n\n\t__set_bit(kvm_governed_feature_index(x86_feature),\n\t\t  vcpu->arch.governed_features.enabled);\n}\n\nstatic __always_inline void kvm_governed_feature_check_and_set(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t\t       unsigned int x86_feature)\n{\n\tif (kvm_cpu_cap_has(x86_feature) && guest_cpuid_has(vcpu, x86_feature))\n\t\tkvm_governed_feature_set(vcpu, x86_feature);\n}\n\nstatic __always_inline bool guest_can_use(struct kvm_vcpu *vcpu,\n\t\t\t\t\t  unsigned int x86_feature)\n{\n\tBUILD_BUG_ON(!kvm_is_governed_feature(x86_feature));\n\n\treturn test_bit(kvm_governed_feature_index(x86_feature),\n\t\t\tvcpu->arch.governed_features.enabled);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}