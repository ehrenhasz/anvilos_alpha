{
  "module_name": "tdp_iter.c",
  "hash_id": "b15c9579eaae5120a93a59aca48a124795c28c1b320450bfc108a1f5da3e49bd",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/mmu/tdp_iter.c",
  "human_readable_source": "\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"mmu_internal.h\"\n#include \"tdp_iter.h\"\n#include \"spte.h\"\n\n \nstatic void tdp_iter_refresh_sptep(struct tdp_iter *iter)\n{\n\titer->sptep = iter->pt_path[iter->level - 1] +\n\t\tSPTE_INDEX(iter->gfn << PAGE_SHIFT, iter->level);\n\titer->old_spte = kvm_tdp_mmu_read_spte(iter->sptep);\n}\n\n \nvoid tdp_iter_restart(struct tdp_iter *iter)\n{\n\titer->yielded = false;\n\titer->yielded_gfn = iter->next_last_level_gfn;\n\titer->level = iter->root_level;\n\n\titer->gfn = gfn_round_for_level(iter->next_last_level_gfn, iter->level);\n\ttdp_iter_refresh_sptep(iter);\n\n\titer->valid = true;\n}\n\n \nvoid tdp_iter_start(struct tdp_iter *iter, struct kvm_mmu_page *root,\n\t\t    int min_level, gfn_t next_last_level_gfn)\n{\n\tif (WARN_ON_ONCE(!root || (root->role.level < 1) ||\n\t\t\t (root->role.level > PT64_ROOT_MAX_LEVEL))) {\n\t\titer->valid = false;\n\t\treturn;\n\t}\n\n\titer->next_last_level_gfn = next_last_level_gfn;\n\titer->root_level = root->role.level;\n\titer->min_level = min_level;\n\titer->pt_path[iter->root_level - 1] = (tdp_ptep_t)root->spt;\n\titer->as_id = kvm_mmu_page_as_id(root);\n\n\ttdp_iter_restart(iter);\n}\n\n \ntdp_ptep_t spte_to_child_pt(u64 spte, int level)\n{\n\t \n\tif (!is_shadow_present_pte(spte) || is_last_spte(spte, level))\n\t\treturn NULL;\n\n\treturn (tdp_ptep_t)__va(spte_to_pfn(spte) << PAGE_SHIFT);\n}\n\n \nstatic bool try_step_down(struct tdp_iter *iter)\n{\n\ttdp_ptep_t child_pt;\n\n\tif (iter->level == iter->min_level)\n\t\treturn false;\n\n\t \n\titer->old_spte = kvm_tdp_mmu_read_spte(iter->sptep);\n\n\tchild_pt = spte_to_child_pt(iter->old_spte, iter->level);\n\tif (!child_pt)\n\t\treturn false;\n\n\titer->level--;\n\titer->pt_path[iter->level - 1] = child_pt;\n\titer->gfn = gfn_round_for_level(iter->next_last_level_gfn, iter->level);\n\ttdp_iter_refresh_sptep(iter);\n\n\treturn true;\n}\n\n \nstatic bool try_step_side(struct tdp_iter *iter)\n{\n\t \n\tif (SPTE_INDEX(iter->gfn << PAGE_SHIFT, iter->level) ==\n\t    (SPTE_ENT_PER_PAGE - 1))\n\t\treturn false;\n\n\titer->gfn += KVM_PAGES_PER_HPAGE(iter->level);\n\titer->next_last_level_gfn = iter->gfn;\n\titer->sptep++;\n\titer->old_spte = kvm_tdp_mmu_read_spte(iter->sptep);\n\n\treturn true;\n}\n\n \nstatic bool try_step_up(struct tdp_iter *iter)\n{\n\tif (iter->level == iter->root_level)\n\t\treturn false;\n\n\titer->level++;\n\titer->gfn = gfn_round_for_level(iter->gfn, iter->level);\n\ttdp_iter_refresh_sptep(iter);\n\n\treturn true;\n}\n\n \nvoid tdp_iter_next(struct tdp_iter *iter)\n{\n\tif (iter->yielded) {\n\t\ttdp_iter_restart(iter);\n\t\treturn;\n\t}\n\n\tif (try_step_down(iter))\n\t\treturn;\n\n\tdo {\n\t\tif (try_step_side(iter))\n\t\t\treturn;\n\t} while (try_step_up(iter));\n\titer->valid = false;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}