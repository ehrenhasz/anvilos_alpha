{
  "module_name": "paging_tmpl.h",
  "hash_id": "b00de71bb6085a9be886a48bbbe876cff7cdb147e8cdf5c7f6f98bd0580890ab",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/mmu/paging_tmpl.h",
  "human_readable_source": " \n \n\n \n\n#if PTTYPE == 64\n\t#define pt_element_t u64\n\t#define guest_walker guest_walker64\n\t#define FNAME(name) paging##64_##name\n\t#define PT_LEVEL_BITS 9\n\t#define PT_GUEST_DIRTY_SHIFT PT_DIRTY_SHIFT\n\t#define PT_GUEST_ACCESSED_SHIFT PT_ACCESSED_SHIFT\n\t#define PT_HAVE_ACCESSED_DIRTY(mmu) true\n\t#ifdef CONFIG_X86_64\n\t#define PT_MAX_FULL_LEVELS PT64_ROOT_MAX_LEVEL\n\t#else\n\t#define PT_MAX_FULL_LEVELS 2\n\t#endif\n#elif PTTYPE == 32\n\t#define pt_element_t u32\n\t#define guest_walker guest_walker32\n\t#define FNAME(name) paging##32_##name\n\t#define PT_LEVEL_BITS 10\n\t#define PT_MAX_FULL_LEVELS 2\n\t#define PT_GUEST_DIRTY_SHIFT PT_DIRTY_SHIFT\n\t#define PT_GUEST_ACCESSED_SHIFT PT_ACCESSED_SHIFT\n\t#define PT_HAVE_ACCESSED_DIRTY(mmu) true\n\n\t#define PT32_DIR_PSE36_SIZE 4\n\t#define PT32_DIR_PSE36_SHIFT 13\n\t#define PT32_DIR_PSE36_MASK \\\n\t\t(((1ULL << PT32_DIR_PSE36_SIZE) - 1) << PT32_DIR_PSE36_SHIFT)\n#elif PTTYPE == PTTYPE_EPT\n\t#define pt_element_t u64\n\t#define guest_walker guest_walkerEPT\n\t#define FNAME(name) ept_##name\n\t#define PT_LEVEL_BITS 9\n\t#define PT_GUEST_DIRTY_SHIFT 9\n\t#define PT_GUEST_ACCESSED_SHIFT 8\n\t#define PT_HAVE_ACCESSED_DIRTY(mmu) (!(mmu)->cpu_role.base.ad_disabled)\n\t#define PT_MAX_FULL_LEVELS PT64_ROOT_MAX_LEVEL\n#else\n\t#error Invalid PTTYPE value\n#endif\n\n \n#define PT_BASE_ADDR_MASK\t((pt_element_t)(((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1)))\n#define PT_LVL_ADDR_MASK(lvl)\t__PT_LVL_ADDR_MASK(PT_BASE_ADDR_MASK, lvl, PT_LEVEL_BITS)\n#define PT_LVL_OFFSET_MASK(lvl)\t__PT_LVL_OFFSET_MASK(PT_BASE_ADDR_MASK, lvl, PT_LEVEL_BITS)\n#define PT_INDEX(addr, lvl)\t__PT_INDEX(addr, lvl, PT_LEVEL_BITS)\n\n#define PT_GUEST_DIRTY_MASK    (1 << PT_GUEST_DIRTY_SHIFT)\n#define PT_GUEST_ACCESSED_MASK (1 << PT_GUEST_ACCESSED_SHIFT)\n\n#define gpte_to_gfn_lvl FNAME(gpte_to_gfn_lvl)\n#define gpte_to_gfn(pte) gpte_to_gfn_lvl((pte), PG_LEVEL_4K)\n\n \nstruct guest_walker {\n\tint level;\n\tunsigned max_level;\n\tgfn_t table_gfn[PT_MAX_FULL_LEVELS];\n\tpt_element_t ptes[PT_MAX_FULL_LEVELS];\n\tpt_element_t prefetch_ptes[PTE_PREFETCH_NUM];\n\tgpa_t pte_gpa[PT_MAX_FULL_LEVELS];\n\tpt_element_t __user *ptep_user[PT_MAX_FULL_LEVELS];\n\tbool pte_writable[PT_MAX_FULL_LEVELS];\n\tunsigned int pt_access[PT_MAX_FULL_LEVELS];\n\tunsigned int pte_access;\n\tgfn_t gfn;\n\tstruct x86_exception fault;\n};\n\n#if PTTYPE == 32\nstatic inline gfn_t pse36_gfn_delta(u32 gpte)\n{\n\tint shift = 32 - PT32_DIR_PSE36_SHIFT - PAGE_SHIFT;\n\n\treturn (gpte & PT32_DIR_PSE36_MASK) << shift;\n}\n#endif\n\nstatic gfn_t gpte_to_gfn_lvl(pt_element_t gpte, int lvl)\n{\n\treturn (gpte & PT_LVL_ADDR_MASK(lvl)) >> PAGE_SHIFT;\n}\n\nstatic inline void FNAME(protect_clean_gpte)(struct kvm_mmu *mmu, unsigned *access,\n\t\t\t\t\t     unsigned gpte)\n{\n\tunsigned mask;\n\n\t \n\tif (!PT_HAVE_ACCESSED_DIRTY(mmu))\n\t\treturn;\n\n\tBUILD_BUG_ON(PT_WRITABLE_MASK != ACC_WRITE_MASK);\n\n\tmask = (unsigned)~ACC_WRITE_MASK;\n\t \n\tmask |= (gpte >> (PT_GUEST_DIRTY_SHIFT - PT_WRITABLE_SHIFT)) &\n\t\tPT_WRITABLE_MASK;\n\t*access &= mask;\n}\n\nstatic inline int FNAME(is_present_gpte)(unsigned long pte)\n{\n#if PTTYPE != PTTYPE_EPT\n\treturn pte & PT_PRESENT_MASK;\n#else\n\treturn pte & 7;\n#endif\n}\n\nstatic bool FNAME(is_bad_mt_xwr)(struct rsvd_bits_validate *rsvd_check, u64 gpte)\n{\n#if PTTYPE != PTTYPE_EPT\n\treturn false;\n#else\n\treturn __is_bad_mt_xwr(rsvd_check, gpte);\n#endif\n}\n\nstatic bool FNAME(is_rsvd_bits_set)(struct kvm_mmu *mmu, u64 gpte, int level)\n{\n\treturn __is_rsvd_bits_set(&mmu->guest_rsvd_check, gpte, level) ||\n\t       FNAME(is_bad_mt_xwr)(&mmu->guest_rsvd_check, gpte);\n}\n\nstatic bool FNAME(prefetch_invalid_gpte)(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t  u64 gpte)\n{\n\tif (!FNAME(is_present_gpte)(gpte))\n\t\tgoto no_present;\n\n\t \n\tif (PT_HAVE_ACCESSED_DIRTY(vcpu->arch.mmu) &&\n\t    !(gpte & PT_GUEST_ACCESSED_MASK))\n\t\tgoto no_present;\n\n\tif (FNAME(is_rsvd_bits_set)(vcpu->arch.mmu, gpte, PG_LEVEL_4K))\n\t\tgoto no_present;\n\n\treturn false;\n\nno_present:\n\tdrop_spte(vcpu->kvm, spte);\n\treturn true;\n}\n\n \nstatic inline unsigned FNAME(gpte_access)(u64 gpte)\n{\n\tunsigned access;\n#if PTTYPE == PTTYPE_EPT\n\taccess = ((gpte & VMX_EPT_WRITABLE_MASK) ? ACC_WRITE_MASK : 0) |\n\t\t((gpte & VMX_EPT_EXECUTABLE_MASK) ? ACC_EXEC_MASK : 0) |\n\t\t((gpte & VMX_EPT_READABLE_MASK) ? ACC_USER_MASK : 0);\n#else\n\tBUILD_BUG_ON(ACC_EXEC_MASK != PT_PRESENT_MASK);\n\tBUILD_BUG_ON(ACC_EXEC_MASK != 1);\n\taccess = gpte & (PT_WRITABLE_MASK | PT_USER_MASK | PT_PRESENT_MASK);\n\t \n\taccess ^= (gpte >> PT64_NX_SHIFT);\n#endif\n\n\treturn access;\n}\n\nstatic int FNAME(update_accessed_dirty_bits)(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_mmu *mmu,\n\t\t\t\t\t     struct guest_walker *walker,\n\t\t\t\t\t     gpa_t addr, int write_fault)\n{\n\tunsigned level, index;\n\tpt_element_t pte, orig_pte;\n\tpt_element_t __user *ptep_user;\n\tgfn_t table_gfn;\n\tint ret;\n\n\t \n\tif (!PT_HAVE_ACCESSED_DIRTY(mmu))\n\t\treturn 0;\n\n\tfor (level = walker->max_level; level >= walker->level; --level) {\n\t\tpte = orig_pte = walker->ptes[level - 1];\n\t\ttable_gfn = walker->table_gfn[level - 1];\n\t\tptep_user = walker->ptep_user[level - 1];\n\t\tindex = offset_in_page(ptep_user) / sizeof(pt_element_t);\n\t\tif (!(pte & PT_GUEST_ACCESSED_MASK)) {\n\t\t\ttrace_kvm_mmu_set_accessed_bit(table_gfn, index, sizeof(pte));\n\t\t\tpte |= PT_GUEST_ACCESSED_MASK;\n\t\t}\n\t\tif (level == walker->level && write_fault &&\n\t\t\t\t!(pte & PT_GUEST_DIRTY_MASK)) {\n\t\t\ttrace_kvm_mmu_set_dirty_bit(table_gfn, index, sizeof(pte));\n#if PTTYPE == PTTYPE_EPT\n\t\t\tif (kvm_x86_ops.nested_ops->write_log_dirty(vcpu, addr))\n\t\t\t\treturn -EINVAL;\n#endif\n\t\t\tpte |= PT_GUEST_DIRTY_MASK;\n\t\t}\n\t\tif (pte == orig_pte)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (unlikely(!walker->pte_writable[level - 1]))\n\t\t\tcontinue;\n\n\t\tret = __try_cmpxchg_user(ptep_user, &orig_pte, pte, fault);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tkvm_vcpu_mark_page_dirty(vcpu, table_gfn);\n\t\twalker->ptes[level - 1] = pte;\n\t}\n\treturn 0;\n}\n\nstatic inline unsigned FNAME(gpte_pkeys)(struct kvm_vcpu *vcpu, u64 gpte)\n{\n\tunsigned pkeys = 0;\n#if PTTYPE == 64\n\tpte_t pte = {.pte = gpte};\n\n\tpkeys = pte_flags_pkey(pte_flags(pte));\n#endif\n\treturn pkeys;\n}\n\nstatic inline bool FNAME(is_last_gpte)(struct kvm_mmu *mmu,\n\t\t\t\t       unsigned int level, unsigned int gpte)\n{\n\t \n#if PTTYPE == 32\n\t \n\tgpte &= level - (PT32_ROOT_LEVEL + mmu->cpu_role.ext.cr4_pse);\n#endif\n\t \n\tgpte |= level - PG_LEVEL_4K - 1;\n\n\treturn gpte & PT_PAGE_SIZE_MASK;\n}\n \nstatic int FNAME(walk_addr_generic)(struct guest_walker *walker,\n\t\t\t\t    struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\t    gpa_t addr, u64 access)\n{\n\tint ret;\n\tpt_element_t pte;\n\tpt_element_t __user *ptep_user;\n\tgfn_t table_gfn;\n\tu64 pt_access, pte_access;\n\tunsigned index, accessed_dirty, pte_pkey;\n\tu64 nested_access;\n\tgpa_t pte_gpa;\n\tbool have_ad;\n\tint offset;\n\tu64 walk_nx_mask = 0;\n\tconst int write_fault = access & PFERR_WRITE_MASK;\n\tconst int user_fault  = access & PFERR_USER_MASK;\n\tconst int fetch_fault = access & PFERR_FETCH_MASK;\n\tu16 errcode = 0;\n\tgpa_t real_gpa;\n\tgfn_t gfn;\n\n\ttrace_kvm_mmu_pagetable_walk(addr, access);\nretry_walk:\n\twalker->level = mmu->cpu_role.base.level;\n\tpte           = kvm_mmu_get_guest_pgd(vcpu, mmu);\n\thave_ad       = PT_HAVE_ACCESSED_DIRTY(mmu);\n\n#if PTTYPE == 64\n\twalk_nx_mask = 1ULL << PT64_NX_SHIFT;\n\tif (walker->level == PT32E_ROOT_LEVEL) {\n\t\tpte = mmu->get_pdptr(vcpu, (addr >> 30) & 3);\n\t\ttrace_kvm_mmu_paging_element(pte, walker->level);\n\t\tif (!FNAME(is_present_gpte)(pte))\n\t\t\tgoto error;\n\t\t--walker->level;\n\t}\n#endif\n\twalker->max_level = walker->level;\n\n\t \n\tnested_access = (have_ad ? PFERR_WRITE_MASK : 0) | PFERR_USER_MASK;\n\n\tpte_access = ~0;\n\n\t \n\tif (KVM_BUG_ON(is_long_mode(vcpu) && !is_pae(vcpu), vcpu->kvm))\n\t\tgoto error;\n\n\t++walker->level;\n\n\tdo {\n\t\tstruct kvm_memory_slot *slot;\n\t\tunsigned long host_addr;\n\n\t\tpt_access = pte_access;\n\t\t--walker->level;\n\n\t\tindex = PT_INDEX(addr, walker->level);\n\t\ttable_gfn = gpte_to_gfn(pte);\n\t\toffset    = index * sizeof(pt_element_t);\n\t\tpte_gpa   = gfn_to_gpa(table_gfn) + offset;\n\n\t\tBUG_ON(walker->level < 1);\n\t\twalker->table_gfn[walker->level - 1] = table_gfn;\n\t\twalker->pte_gpa[walker->level - 1] = pte_gpa;\n\n\t\treal_gpa = kvm_translate_gpa(vcpu, mmu, gfn_to_gpa(table_gfn),\n\t\t\t\t\t     nested_access, &walker->fault);\n\n\t\t \n\t\tif (unlikely(real_gpa == INVALID_GPA))\n\t\t\treturn 0;\n\n\t\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gpa_to_gfn(real_gpa));\n\t\tif (!kvm_is_visible_memslot(slot))\n\t\t\tgoto error;\n\n\t\thost_addr = gfn_to_hva_memslot_prot(slot, gpa_to_gfn(real_gpa),\n\t\t\t\t\t    &walker->pte_writable[walker->level - 1]);\n\t\tif (unlikely(kvm_is_error_hva(host_addr)))\n\t\t\tgoto error;\n\n\t\tptep_user = (pt_element_t __user *)((void *)host_addr + offset);\n\t\tif (unlikely(__get_user(pte, ptep_user)))\n\t\t\tgoto error;\n\t\twalker->ptep_user[walker->level - 1] = ptep_user;\n\n\t\ttrace_kvm_mmu_paging_element(pte, walker->level);\n\n\t\t \n\t\tpte_access = pt_access & (pte ^ walk_nx_mask);\n\n\t\tif (unlikely(!FNAME(is_present_gpte)(pte)))\n\t\t\tgoto error;\n\n\t\tif (unlikely(FNAME(is_rsvd_bits_set)(mmu, pte, walker->level))) {\n\t\t\terrcode = PFERR_RSVD_MASK | PFERR_PRESENT_MASK;\n\t\t\tgoto error;\n\t\t}\n\n\t\twalker->ptes[walker->level - 1] = pte;\n\n\t\t \n\t\twalker->pt_access[walker->level - 1] = FNAME(gpte_access)(pt_access ^ walk_nx_mask);\n\t} while (!FNAME(is_last_gpte)(mmu, walker->level, pte));\n\n\tpte_pkey = FNAME(gpte_pkeys)(vcpu, pte);\n\taccessed_dirty = have_ad ? pte_access & PT_GUEST_ACCESSED_MASK : 0;\n\n\t \n\twalker->pte_access = FNAME(gpte_access)(pte_access ^ walk_nx_mask);\n\terrcode = permission_fault(vcpu, mmu, walker->pte_access, pte_pkey, access);\n\tif (unlikely(errcode))\n\t\tgoto error;\n\n\tgfn = gpte_to_gfn_lvl(pte, walker->level);\n\tgfn += (addr & PT_LVL_OFFSET_MASK(walker->level)) >> PAGE_SHIFT;\n\n#if PTTYPE == 32\n\tif (walker->level > PG_LEVEL_4K && is_cpuid_PSE36())\n\t\tgfn += pse36_gfn_delta(pte);\n#endif\n\n\treal_gpa = kvm_translate_gpa(vcpu, mmu, gfn_to_gpa(gfn), access, &walker->fault);\n\tif (real_gpa == INVALID_GPA)\n\t\treturn 0;\n\n\twalker->gfn = real_gpa >> PAGE_SHIFT;\n\n\tif (!write_fault)\n\t\tFNAME(protect_clean_gpte)(mmu, &walker->pte_access, pte);\n\telse\n\t\t \n\t\taccessed_dirty &= pte >>\n\t\t\t(PT_GUEST_DIRTY_SHIFT - PT_GUEST_ACCESSED_SHIFT);\n\n\tif (unlikely(!accessed_dirty)) {\n\t\tret = FNAME(update_accessed_dirty_bits)(vcpu, mmu, walker,\n\t\t\t\t\t\t\taddr, write_fault);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto error;\n\t\telse if (ret)\n\t\t\tgoto retry_walk;\n\t}\n\n\treturn 1;\n\nerror:\n\terrcode |= write_fault | user_fault;\n\tif (fetch_fault && (is_efer_nx(mmu) || is_cr4_smep(mmu)))\n\t\terrcode |= PFERR_FETCH_MASK;\n\n\twalker->fault.vector = PF_VECTOR;\n\twalker->fault.error_code_valid = true;\n\twalker->fault.error_code = errcode;\n\n#if PTTYPE == PTTYPE_EPT\n\t \n\tif (!(errcode & PFERR_RSVD_MASK)) {\n\t\tvcpu->arch.exit_qualification &= (EPT_VIOLATION_GVA_IS_VALID |\n\t\t\t\t\t\t  EPT_VIOLATION_GVA_TRANSLATED);\n\t\tif (write_fault)\n\t\t\tvcpu->arch.exit_qualification |= EPT_VIOLATION_ACC_WRITE;\n\t\tif (user_fault)\n\t\t\tvcpu->arch.exit_qualification |= EPT_VIOLATION_ACC_READ;\n\t\tif (fetch_fault)\n\t\t\tvcpu->arch.exit_qualification |= EPT_VIOLATION_ACC_INSTR;\n\n\t\t \n\t\tvcpu->arch.exit_qualification |= (pte_access & VMX_EPT_RWX_MASK) <<\n\t\t\t\t\t\t EPT_VIOLATION_RWX_SHIFT;\n\t}\n#endif\n\twalker->fault.address = addr;\n\twalker->fault.nested_page_fault = mmu != vcpu->arch.walk_mmu;\n\twalker->fault.async_page_fault = false;\n\n\ttrace_kvm_mmu_walker_error(walker->fault.error_code);\n\treturn 0;\n}\n\nstatic int FNAME(walk_addr)(struct guest_walker *walker,\n\t\t\t    struct kvm_vcpu *vcpu, gpa_t addr, u64 access)\n{\n\treturn FNAME(walk_addr_generic)(walker, vcpu, vcpu->arch.mmu, addr,\n\t\t\t\t\taccess);\n}\n\nstatic bool\nFNAME(prefetch_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t     u64 *spte, pt_element_t gpte)\n{\n\tstruct kvm_memory_slot *slot;\n\tunsigned pte_access;\n\tgfn_t gfn;\n\tkvm_pfn_t pfn;\n\n\tif (FNAME(prefetch_invalid_gpte)(vcpu, sp, spte, gpte))\n\t\treturn false;\n\n\tgfn = gpte_to_gfn(gpte);\n\tpte_access = sp->role.access & FNAME(gpte_access)(gpte);\n\tFNAME(protect_clean_gpte)(vcpu->arch.mmu, &pte_access, gpte);\n\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn, pte_access & ACC_WRITE_MASK);\n\tif (!slot)\n\t\treturn false;\n\n\tpfn = gfn_to_pfn_memslot_atomic(slot, gfn);\n\tif (is_error_pfn(pfn))\n\t\treturn false;\n\n\tmmu_set_spte(vcpu, slot, spte, pte_access, gfn, pfn, NULL);\n\tkvm_release_pfn_clean(pfn);\n\treturn true;\n}\n\nstatic bool FNAME(gpte_changed)(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct guest_walker *gw, int level)\n{\n\tpt_element_t curr_pte;\n\tgpa_t base_gpa, pte_gpa = gw->pte_gpa[level - 1];\n\tu64 mask;\n\tint r, index;\n\n\tif (level == PG_LEVEL_4K) {\n\t\tmask = PTE_PREFETCH_NUM * sizeof(pt_element_t) - 1;\n\t\tbase_gpa = pte_gpa & ~mask;\n\t\tindex = (pte_gpa - base_gpa) / sizeof(pt_element_t);\n\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, base_gpa,\n\t\t\t\tgw->prefetch_ptes, sizeof(gw->prefetch_ptes));\n\t\tcurr_pte = gw->prefetch_ptes[index];\n\t} else\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, pte_gpa,\n\t\t\t\t  &curr_pte, sizeof(curr_pte));\n\n\treturn r || curr_pte != gw->ptes[level - 1];\n}\n\nstatic void FNAME(pte_prefetch)(struct kvm_vcpu *vcpu, struct guest_walker *gw,\n\t\t\t\tu64 *sptep)\n{\n\tstruct kvm_mmu_page *sp;\n\tpt_element_t *gptep = gw->prefetch_ptes;\n\tu64 *spte;\n\tint i;\n\n\tsp = sptep_to_sp(sptep);\n\n\tif (sp->role.level > PG_LEVEL_4K)\n\t\treturn;\n\n\t \n\tif (unlikely(vcpu->kvm->mmu_invalidate_in_progress))\n\t\treturn;\n\n\tif (sp->role.direct)\n\t\treturn __direct_pte_prefetch(vcpu, sp, sptep);\n\n\ti = spte_index(sptep) & ~(PTE_PREFETCH_NUM - 1);\n\tspte = sp->spt + i;\n\n\tfor (i = 0; i < PTE_PREFETCH_NUM; i++, spte++) {\n\t\tif (spte == sptep)\n\t\t\tcontinue;\n\n\t\tif (is_shadow_present_pte(*spte))\n\t\t\tcontinue;\n\n\t\tif (!FNAME(prefetch_gpte)(vcpu, sp, spte, gptep[i]))\n\t\t\tbreak;\n\t}\n}\n\n \nstatic int FNAME(fetch)(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault,\n\t\t\t struct guest_walker *gw)\n{\n\tstruct kvm_mmu_page *sp = NULL;\n\tstruct kvm_shadow_walk_iterator it;\n\tunsigned int direct_access, access;\n\tint top_level, ret;\n\tgfn_t base_gfn = fault->gfn;\n\n\tWARN_ON_ONCE(gw->gfn != base_gfn);\n\tdirect_access = gw->pte_access;\n\n\ttop_level = vcpu->arch.mmu->cpu_role.base.level;\n\tif (top_level == PT32E_ROOT_LEVEL)\n\t\ttop_level = PT32_ROOT_LEVEL;\n\t \n\tif (FNAME(gpte_changed)(vcpu, gw, top_level))\n\t\tgoto out_gpte_changed;\n\n\tif (WARN_ON_ONCE(!VALID_PAGE(vcpu->arch.mmu->root.hpa)))\n\t\tgoto out_gpte_changed;\n\n\t \n\tif (unlikely(kvm_mmu_is_dummy_root(vcpu->arch.mmu->root.hpa))) {\n\t\tkvm_make_request(KVM_REQ_MMU_FREE_OBSOLETE_ROOTS, vcpu);\n\t\tgoto out_gpte_changed;\n\t}\n\n\tfor_each_shadow_entry(vcpu, fault->addr, it) {\n\t\tgfn_t table_gfn;\n\n\t\tclear_sp_write_flooding_count(it.sptep);\n\t\tif (it.level == gw->level)\n\t\t\tbreak;\n\n\t\ttable_gfn = gw->table_gfn[it.level - 2];\n\t\taccess = gw->pt_access[it.level - 2];\n\t\tsp = kvm_mmu_get_child_sp(vcpu, it.sptep, table_gfn,\n\t\t\t\t\t  false, access);\n\n\t\tif (sp != ERR_PTR(-EEXIST)) {\n\t\t\t \n\t\t\tif (sp->unsync_children &&\n\t\t\t    mmu_sync_children(vcpu, sp, false))\n\t\t\t\treturn RET_PF_RETRY;\n\t\t}\n\n\t\t \n\t\tif (FNAME(gpte_changed)(vcpu, gw, it.level - 1))\n\t\t\tgoto out_gpte_changed;\n\n\t\tif (sp != ERR_PTR(-EEXIST))\n\t\t\tlink_shadow_page(vcpu, it.sptep, sp);\n\n\t\tif (fault->write && table_gfn == fault->gfn)\n\t\t\tfault->write_fault_to_shadow_pgtable = true;\n\t}\n\n\t \n\tkvm_mmu_hugepage_adjust(vcpu, fault);\n\n\ttrace_kvm_mmu_spte_requested(fault);\n\n\tfor (; shadow_walk_okay(&it); shadow_walk_next(&it)) {\n\t\t \n\t\tif (fault->nx_huge_page_workaround_enabled)\n\t\t\tdisallowed_hugepage_adjust(fault, *it.sptep, it.level);\n\n\t\tbase_gfn = gfn_round_for_level(fault->gfn, it.level);\n\t\tif (it.level == fault->goal_level)\n\t\t\tbreak;\n\n\t\tvalidate_direct_spte(vcpu, it.sptep, direct_access);\n\n\t\tsp = kvm_mmu_get_child_sp(vcpu, it.sptep, base_gfn,\n\t\t\t\t\t  true, direct_access);\n\t\tif (sp == ERR_PTR(-EEXIST))\n\t\t\tcontinue;\n\n\t\tlink_shadow_page(vcpu, it.sptep, sp);\n\t\tif (fault->huge_page_disallowed)\n\t\t\taccount_nx_huge_page(vcpu->kvm, sp,\n\t\t\t\t\t     fault->req_level >= it.level);\n\t}\n\n\tif (WARN_ON_ONCE(it.level != fault->goal_level))\n\t\treturn -EFAULT;\n\n\tret = mmu_set_spte(vcpu, fault->slot, it.sptep, gw->pte_access,\n\t\t\t   base_gfn, fault->pfn, fault);\n\tif (ret == RET_PF_SPURIOUS)\n\t\treturn ret;\n\n\tFNAME(pte_prefetch)(vcpu, gw, it.sptep);\n\treturn ret;\n\nout_gpte_changed:\n\treturn RET_PF_RETRY;\n}\n\n \nstatic int FNAME(page_fault)(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault)\n{\n\tstruct guest_walker walker;\n\tint r;\n\n\tWARN_ON_ONCE(fault->is_tdp);\n\n\t \n\tr = FNAME(walk_addr)(&walker, vcpu, fault->addr,\n\t\t\t     fault->error_code & ~PFERR_RSVD_MASK);\n\n\t \n\tif (!r) {\n\t\tif (!fault->prefetch)\n\t\t\tkvm_inject_emulated_page_fault(vcpu, &walker.fault);\n\n\t\treturn RET_PF_RETRY;\n\t}\n\n\tfault->gfn = walker.gfn;\n\tfault->max_level = walker.level;\n\tfault->slot = kvm_vcpu_gfn_to_memslot(vcpu, fault->gfn);\n\n\tif (page_fault_handle_page_track(vcpu, fault)) {\n\t\tshadow_page_table_clear_flood(vcpu, fault->addr);\n\t\treturn RET_PF_EMULATE;\n\t}\n\n\tr = mmu_topup_memory_caches(vcpu, true);\n\tif (r)\n\t\treturn r;\n\n\tr = kvm_faultin_pfn(vcpu, fault, walker.pte_access);\n\tif (r != RET_PF_CONTINUE)\n\t\treturn r;\n\n\t \n\tif (fault->write && !(walker.pte_access & ACC_WRITE_MASK) &&\n\t    !is_cr0_wp(vcpu->arch.mmu) && !fault->user && fault->slot) {\n\t\twalker.pte_access |= ACC_WRITE_MASK;\n\t\twalker.pte_access &= ~ACC_USER_MASK;\n\n\t\t \n\t\tif (is_cr4_smep(vcpu->arch.mmu))\n\t\t\twalker.pte_access &= ~ACC_EXEC_MASK;\n\t}\n\n\tr = RET_PF_RETRY;\n\twrite_lock(&vcpu->kvm->mmu_lock);\n\n\tif (is_page_fault_stale(vcpu, fault))\n\t\tgoto out_unlock;\n\n\tr = make_mmu_pages_available(vcpu);\n\tif (r)\n\t\tgoto out_unlock;\n\tr = FNAME(fetch)(vcpu, fault, &walker);\n\nout_unlock:\n\twrite_unlock(&vcpu->kvm->mmu_lock);\n\tkvm_release_pfn_clean(fault->pfn);\n\treturn r;\n}\n\nstatic gpa_t FNAME(get_level1_sp_gpa)(struct kvm_mmu_page *sp)\n{\n\tint offset = 0;\n\n\tWARN_ON_ONCE(sp->role.level != PG_LEVEL_4K);\n\n\tif (PTTYPE == 32)\n\t\toffset = sp->role.quadrant << SPTE_LEVEL_BITS;\n\n\treturn gfn_to_gpa(sp->gfn) + offset * sizeof(pt_element_t);\n}\n\n \nstatic gpa_t FNAME(gva_to_gpa)(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t       gpa_t addr, u64 access,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct guest_walker walker;\n\tgpa_t gpa = INVALID_GPA;\n\tint r;\n\n#ifndef CONFIG_X86_64\n\t \n\tWARN_ON_ONCE((addr >> 32) && mmu == vcpu->arch.walk_mmu);\n#endif\n\n\tr = FNAME(walk_addr_generic)(&walker, vcpu, mmu, addr, access);\n\n\tif (r) {\n\t\tgpa = gfn_to_gpa(walker.gfn);\n\t\tgpa |= addr & ~PAGE_MASK;\n\t} else if (exception)\n\t\t*exception = walker.fault;\n\n\treturn gpa;\n}\n\n \nstatic int FNAME(sync_spte)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp, int i)\n{\n\tbool host_writable;\n\tgpa_t first_pte_gpa;\n\tu64 *sptep, spte;\n\tstruct kvm_memory_slot *slot;\n\tunsigned pte_access;\n\tpt_element_t gpte;\n\tgpa_t pte_gpa;\n\tgfn_t gfn;\n\n\tif (WARN_ON_ONCE(!sp->spt[i]))\n\t\treturn 0;\n\n\tfirst_pte_gpa = FNAME(get_level1_sp_gpa)(sp);\n\tpte_gpa = first_pte_gpa + i * sizeof(pt_element_t);\n\n\tif (kvm_vcpu_read_guest_atomic(vcpu, pte_gpa, &gpte,\n\t\t\t\t       sizeof(pt_element_t)))\n\t\treturn -1;\n\n\tif (FNAME(prefetch_invalid_gpte)(vcpu, sp, &sp->spt[i], gpte))\n\t\treturn 1;\n\n\tgfn = gpte_to_gfn(gpte);\n\tpte_access = sp->role.access;\n\tpte_access &= FNAME(gpte_access)(gpte);\n\tFNAME(protect_clean_gpte)(vcpu->arch.mmu, &pte_access, gpte);\n\n\tif (sync_mmio_spte(vcpu, &sp->spt[i], gfn, pte_access))\n\t\treturn 0;\n\n\t \n\tif ((!pte_access && !shadow_present_mask) ||\n\t    gfn != kvm_mmu_page_get_gfn(sp, i)) {\n\t\tdrop_spte(vcpu->kvm, &sp->spt[i]);\n\t\treturn 1;\n\t}\n\t \n\tif (kvm_mmu_page_get_access(sp, i) == pte_access)\n\t\treturn 0;\n\n\t \n\tkvm_mmu_page_set_access(sp, i, pte_access);\n\n\tsptep = &sp->spt[i];\n\tspte = *sptep;\n\thost_writable = spte & shadow_host_writable_mask;\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tmake_spte(vcpu, sp, slot, pte_access, gfn,\n\t\t  spte_to_pfn(spte), spte, true, false,\n\t\t  host_writable, &spte);\n\n\treturn mmu_spte_update(sptep, spte);\n}\n\n#undef pt_element_t\n#undef guest_walker\n#undef FNAME\n#undef PT_BASE_ADDR_MASK\n#undef PT_INDEX\n#undef PT_LVL_ADDR_MASK\n#undef PT_LVL_OFFSET_MASK\n#undef PT_LEVEL_BITS\n#undef PT_MAX_FULL_LEVELS\n#undef gpte_to_gfn\n#undef gpte_to_gfn_lvl\n#undef PT_GUEST_ACCESSED_MASK\n#undef PT_GUEST_DIRTY_MASK\n#undef PT_GUEST_DIRTY_SHIFT\n#undef PT_GUEST_ACCESSED_SHIFT\n#undef PT_HAVE_ACCESSED_DIRTY\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}