{
  "module_name": "page_track.c",
  "hash_id": "0b28ee9a3253d23fb2a9c419f31892d1123866cac1ec8be76a988097e47f6685",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/mmu/page_track.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/lockdep.h>\n#include <linux/kvm_host.h>\n#include <linux/rculist.h>\n\n#include \"mmu.h\"\n#include \"mmu_internal.h\"\n#include \"page_track.h\"\n\nbool kvm_page_track_write_tracking_enabled(struct kvm *kvm)\n{\n\treturn IS_ENABLED(CONFIG_KVM_EXTERNAL_WRITE_TRACKING) ||\n\t       !tdp_enabled || kvm_shadow_root_allocated(kvm);\n}\n\nvoid kvm_page_track_free_memslot(struct kvm_memory_slot *slot)\n{\n\tkvfree(slot->arch.gfn_write_track);\n\tslot->arch.gfn_write_track = NULL;\n}\n\nstatic int __kvm_page_track_write_tracking_alloc(struct kvm_memory_slot *slot,\n\t\t\t\t\t\t unsigned long npages)\n{\n\tconst size_t size = sizeof(*slot->arch.gfn_write_track);\n\n\tif (!slot->arch.gfn_write_track)\n\t\tslot->arch.gfn_write_track = __vcalloc(npages, size,\n\t\t\t\t\t\t       GFP_KERNEL_ACCOUNT);\n\n\treturn slot->arch.gfn_write_track ? 0 : -ENOMEM;\n}\n\nint kvm_page_track_create_memslot(struct kvm *kvm,\n\t\t\t\t  struct kvm_memory_slot *slot,\n\t\t\t\t  unsigned long npages)\n{\n\tif (!kvm_page_track_write_tracking_enabled(kvm))\n\t\treturn 0;\n\n\treturn __kvm_page_track_write_tracking_alloc(slot, npages);\n}\n\nint kvm_page_track_write_tracking_alloc(struct kvm_memory_slot *slot)\n{\n\treturn __kvm_page_track_write_tracking_alloc(slot, slot->npages);\n}\n\nstatic void update_gfn_write_track(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t\t   short count)\n{\n\tint index, val;\n\n\tindex = gfn_to_index(gfn, slot->base_gfn, PG_LEVEL_4K);\n\n\tval = slot->arch.gfn_write_track[index];\n\n\tif (WARN_ON_ONCE(val + count < 0 || val + count > USHRT_MAX))\n\t\treturn;\n\n\tslot->arch.gfn_write_track[index] += count;\n}\n\nvoid __kvm_write_track_add_gfn(struct kvm *kvm, struct kvm_memory_slot *slot,\n\t\t\t       gfn_t gfn)\n{\n\tlockdep_assert_held_write(&kvm->mmu_lock);\n\n\tlockdep_assert_once(lockdep_is_held(&kvm->slots_lock) ||\n\t\t\t    srcu_read_lock_held(&kvm->srcu));\n\n\tif (KVM_BUG_ON(!kvm_page_track_write_tracking_enabled(kvm), kvm))\n\t\treturn;\n\n\tupdate_gfn_write_track(slot, gfn, 1);\n\n\t \n\tkvm_mmu_gfn_disallow_lpage(slot, gfn);\n\n\tif (kvm_mmu_slot_gfn_write_protect(kvm, slot, gfn, PG_LEVEL_4K))\n\t\tkvm_flush_remote_tlbs(kvm);\n}\n\nvoid __kvm_write_track_remove_gfn(struct kvm *kvm,\n\t\t\t\t  struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tlockdep_assert_held_write(&kvm->mmu_lock);\n\n\tlockdep_assert_once(lockdep_is_held(&kvm->slots_lock) ||\n\t\t\t    srcu_read_lock_held(&kvm->srcu));\n\n\tif (KVM_BUG_ON(!kvm_page_track_write_tracking_enabled(kvm), kvm))\n\t\treturn;\n\n\tupdate_gfn_write_track(slot, gfn, -1);\n\n\t \n\tkvm_mmu_gfn_allow_lpage(slot, gfn);\n}\n\n \nbool kvm_gfn_is_write_tracked(struct kvm *kvm,\n\t\t\t      const struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tint index;\n\n\tif (!slot)\n\t\treturn false;\n\n\tif (!kvm_page_track_write_tracking_enabled(kvm))\n\t\treturn false;\n\n\tindex = gfn_to_index(gfn, slot->base_gfn, PG_LEVEL_4K);\n\treturn !!READ_ONCE(slot->arch.gfn_write_track[index]);\n}\n\n#ifdef CONFIG_KVM_EXTERNAL_WRITE_TRACKING\nvoid kvm_page_track_cleanup(struct kvm *kvm)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\n\thead = &kvm->arch.track_notifier_head;\n\tcleanup_srcu_struct(&head->track_srcu);\n}\n\nint kvm_page_track_init(struct kvm *kvm)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\n\thead = &kvm->arch.track_notifier_head;\n\tINIT_HLIST_HEAD(&head->track_notifier_list);\n\treturn init_srcu_struct(&head->track_srcu);\n}\n\n \nint kvm_page_track_register_notifier(struct kvm *kvm,\n\t\t\t\t     struct kvm_page_track_notifier_node *n)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\n\tif (!kvm || kvm->mm != current->mm)\n\t\treturn -ESRCH;\n\n\tkvm_get_kvm(kvm);\n\n\thead = &kvm->arch.track_notifier_head;\n\n\twrite_lock(&kvm->mmu_lock);\n\thlist_add_head_rcu(&n->node, &head->track_notifier_list);\n\twrite_unlock(&kvm->mmu_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_page_track_register_notifier);\n\n \nvoid kvm_page_track_unregister_notifier(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_page_track_notifier_node *n)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\n\thead = &kvm->arch.track_notifier_head;\n\n\twrite_lock(&kvm->mmu_lock);\n\thlist_del_rcu(&n->node);\n\twrite_unlock(&kvm->mmu_lock);\n\tsynchronize_srcu(&head->track_srcu);\n\n\tkvm_put_kvm(kvm);\n}\nEXPORT_SYMBOL_GPL(kvm_page_track_unregister_notifier);\n\n \nvoid __kvm_page_track_write(struct kvm *kvm, gpa_t gpa, const u8 *new, int bytes)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\tstruct kvm_page_track_notifier_node *n;\n\tint idx;\n\n\thead = &kvm->arch.track_notifier_head;\n\n\tif (hlist_empty(&head->track_notifier_list))\n\t\treturn;\n\n\tidx = srcu_read_lock(&head->track_srcu);\n\thlist_for_each_entry_srcu(n, &head->track_notifier_list, node,\n\t\t\t\t  srcu_read_lock_held(&head->track_srcu))\n\t\tif (n->track_write)\n\t\t\tn->track_write(gpa, new, bytes, n);\n\tsrcu_read_unlock(&head->track_srcu, idx);\n}\n\n \nvoid kvm_page_track_delete_slot(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\tstruct kvm_page_track_notifier_node *n;\n\tint idx;\n\n\thead = &kvm->arch.track_notifier_head;\n\n\tif (hlist_empty(&head->track_notifier_list))\n\t\treturn;\n\n\tidx = srcu_read_lock(&head->track_srcu);\n\thlist_for_each_entry_srcu(n, &head->track_notifier_list, node,\n\t\t\t\t  srcu_read_lock_held(&head->track_srcu))\n\t\tif (n->track_remove_region)\n\t\t\tn->track_remove_region(slot->base_gfn, slot->npages, n);\n\tsrcu_read_unlock(&head->track_srcu, idx);\n}\n\n \nint kvm_write_track_add_gfn(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct kvm_memory_slot *slot;\n\tint idx;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\n\tslot = gfn_to_memslot(kvm, gfn);\n\tif (!slot) {\n\t\tsrcu_read_unlock(&kvm->srcu, idx);\n\t\treturn -EINVAL;\n\t}\n\n\twrite_lock(&kvm->mmu_lock);\n\t__kvm_write_track_add_gfn(kvm, slot, gfn);\n\twrite_unlock(&kvm->mmu_lock);\n\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_write_track_add_gfn);\n\n \nint kvm_write_track_remove_gfn(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct kvm_memory_slot *slot;\n\tint idx;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\n\tslot = gfn_to_memslot(kvm, gfn);\n\tif (!slot) {\n\t\tsrcu_read_unlock(&kvm->srcu, idx);\n\t\treturn -EINVAL;\n\t}\n\n\twrite_lock(&kvm->mmu_lock);\n\t__kvm_write_track_remove_gfn(kvm, slot, gfn);\n\twrite_unlock(&kvm->mmu_lock);\n\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_write_track_remove_gfn);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}