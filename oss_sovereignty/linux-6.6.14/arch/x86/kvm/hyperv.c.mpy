{
  "module_name": "hyperv.c",
  "hash_id": "e499af89af598e9e286aca00aa7cde0b8a15d71e26b0bc71f291f629ea9dd7a5",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/hyperv.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"x86.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"cpuid.h\"\n#include \"hyperv.h\"\n#include \"mmu.h\"\n#include \"xen.h\"\n\n#include <linux/cpu.h>\n#include <linux/kvm_host.h>\n#include <linux/highmem.h>\n#include <linux/sched/cputime.h>\n#include <linux/spinlock.h>\n#include <linux/eventfd.h>\n\n#include <asm/apicdef.h>\n#include <asm/mshyperv.h>\n#include <trace/events/kvm.h>\n\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"fpu.h\"\n\n#define KVM_HV_MAX_SPARSE_VCPU_SET_BITS DIV_ROUND_UP(KVM_MAX_VCPUS, HV_VCPUS_PER_SPARSE_BANK)\n\n \n#define HV_EXT_CALL_MAX (HV_EXT_CALL_QUERY_CAPABILITIES + 64)\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick);\n\nstatic inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}\n\nstatic inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}\n\nstatic bool synic_has_vector_connected(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t      int vector)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool synic_has_vector_auto_eoi(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t     int vector)\n{\n\tint i;\n\tu64 sint_value;\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tsint_value = synic_read_sint(synic, i);\n\t\tif (synic_get_sint_vector(sint_value) == vector &&\n\t\t    sint_value & HV_SYNIC_SINT_AUTO_EOI)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void synic_update_vector(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\tint vector)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tstruct kvm_hv *hv = to_kvm_hv(vcpu->kvm);\n\tbool auto_eoi_old, auto_eoi_new;\n\n\tif (vector < HV_SYNIC_FIRST_VALID_VECTOR)\n\t\treturn;\n\n\tif (synic_has_vector_connected(synic, vector))\n\t\t__set_bit(vector, synic->vec_bitmap);\n\telse\n\t\t__clear_bit(vector, synic->vec_bitmap);\n\n\tauto_eoi_old = !bitmap_empty(synic->auto_eoi_bitmap, 256);\n\n\tif (synic_has_vector_auto_eoi(synic, vector))\n\t\t__set_bit(vector, synic->auto_eoi_bitmap);\n\telse\n\t\t__clear_bit(vector, synic->auto_eoi_bitmap);\n\n\tauto_eoi_new = !bitmap_empty(synic->auto_eoi_bitmap, 256);\n\n\tif (auto_eoi_old == auto_eoi_new)\n\t\treturn;\n\n\tif (!enable_apicv)\n\t\treturn;\n\n\tdown_write(&vcpu->kvm->arch.apicv_update_lock);\n\n\tif (auto_eoi_new)\n\t\thv->synic_auto_eoi_used++;\n\telse\n\t\thv->synic_auto_eoi_used--;\n\n\t \n\t__kvm_set_or_clear_apicv_inhibit(vcpu->kvm,\n\t\t\t\t\t APICV_INHIBIT_REASON_HYPERV,\n\t\t\t\t\t !!hv->synic_auto_eoi_used);\n\n\tup_write(&vcpu->kvm->arch.apicv_update_lock);\n}\n\nstatic int synic_set_sint(struct kvm_vcpu_hv_synic *synic, int sint,\n\t\t\t  u64 data, bool host)\n{\n\tint vector, old_vector;\n\tbool masked;\n\n\tvector = data & HV_SYNIC_SINT_VECTOR_MASK;\n\tmasked = data & HV_SYNIC_SINT_MASKED;\n\n\t \n\tif (vector < HV_SYNIC_FIRST_VALID_VECTOR && !host && !masked)\n\t\treturn 1;\n\t \n\told_vector = synic_read_sint(synic, sint) & HV_SYNIC_SINT_VECTOR_MASK;\n\n\tatomic64_set(&synic->sint[sint], data);\n\n\tsynic_update_vector(synic, old_vector);\n\n\tsynic_update_vector(synic, vector);\n\n\t \n\tkvm_make_request(KVM_REQ_SCAN_IOAPIC, hv_synic_to_vcpu(synic));\n\treturn 0;\n}\n\nstatic struct kvm_vcpu *get_vcpu_by_vpidx(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu = NULL;\n\tunsigned long i;\n\n\tif (vpidx >= KVM_MAX_VCPUS)\n\t\treturn NULL;\n\n\tvcpu = kvm_get_vcpu(kvm, vpidx);\n\tif (vcpu && kvm_hv_get_vpindex(vcpu) == vpidx)\n\t\treturn vcpu;\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tif (kvm_hv_get_vpindex(vcpu) == vpidx)\n\t\t\treturn vcpu;\n\treturn NULL;\n}\n\nstatic struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tvcpu = get_vcpu_by_vpidx(kvm, vpidx);\n\tif (!vcpu || !to_hv_vcpu(vcpu))\n\t\treturn NULL;\n\tsynic = to_hv_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}\n\nstatic void kvm_hv_notify_acked_sint(struct kvm_vcpu *vcpu, u32 sint)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tint gsi, idx;\n\n\ttrace_kvm_hv_notify_acked_sint(vcpu->vcpu_id, sint);\n\n\t \n\tfor (idx = 0; idx < ARRAY_SIZE(hv_vcpu->stimer); idx++) {\n\t\tstimer = &hv_vcpu->stimer[idx];\n\t\tif (stimer->msg_pending && stimer->config.enable &&\n\t\t    !stimer->config.direct_mode &&\n\t\t    stimer->config.sintx == sint)\n\t\t\tstimer_mark_pending(stimer, false);\n\t}\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = atomic_read(&synic->sint_to_gsi[sint]);\n\tif (gsi != -1)\n\t\tkvm_notify_acked_gsi(kvm, gsi);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}\n\nstatic void synic_exit(struct kvm_vcpu_hv_synic *synic, u32 msr)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\n\thv_vcpu->exit.type = KVM_EXIT_HYPERV_SYNIC;\n\thv_vcpu->exit.u.synic.msr = msr;\n\thv_vcpu->exit.u.synic.control = synic->control;\n\thv_vcpu->exit.u.synic.evt_page = synic->evt_page;\n\thv_vcpu->exit.u.synic.msg_page = synic->msg_page;\n\n\tkvm_make_request(KVM_REQ_HV_EXIT, vcpu);\n}\n\nstatic int synic_set_msr(struct kvm_vcpu_hv_synic *synic,\n\t\t\t u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tint ret;\n\n\tif (!synic->active && (!host || data))\n\t\treturn 1;\n\n\ttrace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\tsynic->control = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\tif (!host) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tsynic->version = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\tif ((data & HV_SYNIC_SIEFP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->evt_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\tif ((data & HV_SYNIC_SIMP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->msg_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_EOM: {\n\t\tint i;\n\n\t\tif (!synic->active)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\tret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic bool kvm_hv_is_syndbg_enabled(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\n\treturn hv_vcpu->cpuid_cache.syndbg_cap_eax &\n\t\tHV_X64_SYNDBG_CAP_ALLOW_KERNEL_DEBUGGING;\n}\n\nstatic int kvm_hv_syndbg_complete_userspace(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_hv *hv = to_kvm_hv(vcpu->kvm);\n\n\tif (vcpu->run->hyperv.u.syndbg.msr == HV_X64_MSR_SYNDBG_CONTROL)\n\t\thv->hv_syndbg.control.status =\n\t\t\tvcpu->run->hyperv.u.syndbg.status;\n\treturn 1;\n}\n\nstatic void syndbg_exit(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tstruct kvm_hv_syndbg *syndbg = to_hv_syndbg(vcpu);\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\n\thv_vcpu->exit.type = KVM_EXIT_HYPERV_SYNDBG;\n\thv_vcpu->exit.u.syndbg.msr = msr;\n\thv_vcpu->exit.u.syndbg.control = syndbg->control.control;\n\thv_vcpu->exit.u.syndbg.send_page = syndbg->control.send_page;\n\thv_vcpu->exit.u.syndbg.recv_page = syndbg->control.recv_page;\n\thv_vcpu->exit.u.syndbg.pending_page = syndbg->control.pending_page;\n\tvcpu->arch.complete_userspace_io =\n\t\t\tkvm_hv_syndbg_complete_userspace;\n\n\tkvm_make_request(KVM_REQ_HV_EXIT, vcpu);\n}\n\nstatic int syndbg_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)\n{\n\tstruct kvm_hv_syndbg *syndbg = to_hv_syndbg(vcpu);\n\n\tif (!kvm_hv_is_syndbg_enabled(vcpu) && !host)\n\t\treturn 1;\n\n\ttrace_kvm_hv_syndbg_set_msr(vcpu->vcpu_id,\n\t\t\t\t    to_hv_vcpu(vcpu)->vp_index, msr, data);\n\tswitch (msr) {\n\tcase HV_X64_MSR_SYNDBG_CONTROL:\n\t\tsyndbg->control.control = data;\n\t\tif (!host)\n\t\t\tsyndbg_exit(vcpu, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SYNDBG_STATUS:\n\t\tsyndbg->control.status = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SYNDBG_SEND_BUFFER:\n\t\tsyndbg->control.send_page = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SYNDBG_RECV_BUFFER:\n\t\tsyndbg->control.recv_page = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SYNDBG_PENDING_BUFFER:\n\t\tsyndbg->control.pending_page = data;\n\t\tif (!host)\n\t\t\tsyndbg_exit(vcpu, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SYNDBG_OPTIONS:\n\t\tsyndbg->options = data;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int syndbg_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata, bool host)\n{\n\tstruct kvm_hv_syndbg *syndbg = to_hv_syndbg(vcpu);\n\n\tif (!kvm_hv_is_syndbg_enabled(vcpu) && !host)\n\t\treturn 1;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_SYNDBG_CONTROL:\n\t\t*pdata = syndbg->control.control;\n\t\tbreak;\n\tcase HV_X64_MSR_SYNDBG_STATUS:\n\t\t*pdata = syndbg->control.status;\n\t\tbreak;\n\tcase HV_X64_MSR_SYNDBG_SEND_BUFFER:\n\t\t*pdata = syndbg->control.send_page;\n\t\tbreak;\n\tcase HV_X64_MSR_SYNDBG_RECV_BUFFER:\n\t\t*pdata = syndbg->control.recv_page;\n\t\tbreak;\n\tcase HV_X64_MSR_SYNDBG_PENDING_BUFFER:\n\t\t*pdata = syndbg->control.pending_page;\n\t\tbreak;\n\tcase HV_X64_MSR_SYNDBG_OPTIONS:\n\t\t*pdata = syndbg->options;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttrace_kvm_hv_syndbg_get_msr(vcpu->vcpu_id, kvm_hv_get_vpindex(vcpu), msr, *pdata);\n\n\treturn 0;\n}\n\nstatic int synic_get_msr(struct kvm_vcpu_hv_synic *synic, u32 msr, u64 *pdata,\n\t\t\t bool host)\n{\n\tint ret;\n\n\tif (!synic->active && !host)\n\t\treturn 1;\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\t*pdata = synic->control;\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\t*pdata = synic->version;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\t*pdata = synic->evt_page;\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\t*pdata = synic->msg_page;\n\t\tbreak;\n\tcase HV_X64_MSR_EOM:\n\t\t*pdata = 0;\n\t\tbreak;\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\t*pdata = atomic64_read(&synic->sint[msr - HV_X64_MSR_SINT0]);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\n\tif (KVM_BUG_ON(!lapic_in_kernel(vcpu), vcpu->kvm))\n\t\treturn -EINVAL;\n\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.shorthand = APIC_DEST_SELF;\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}\n\nint kvm_hv_synic_set_irq(struct kvm *kvm, u32 vpidx, u32 sint)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tsynic = synic_get(kvm, vpidx);\n\tif (!synic)\n\t\treturn -EINVAL;\n\n\treturn synic_set_irq(synic, sint);\n}\n\nvoid kvm_hv_synic_send_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\tint i;\n\n\ttrace_kvm_hv_synic_send_eoi(vcpu->vcpu_id, vector);\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\tif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n}\n\nstatic int kvm_hv_set_sint_gsi(struct kvm *kvm, u32 vpidx, u32 sint, int gsi)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tsynic = synic_get(kvm, vpidx);\n\tif (!synic)\n\t\treturn -EINVAL;\n\n\tif (sint >= ARRAY_SIZE(synic->sint_to_gsi))\n\t\treturn -EINVAL;\n\n\tatomic_set(&synic->sint_to_gsi[sint], gsi);\n\treturn 0;\n}\n\nvoid kvm_hv_irq_routing_update(struct kvm *kvm)\n{\n\tstruct kvm_irq_routing_table *irq_rt;\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tu32 gsi;\n\n\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\t\t\t\t\tlockdep_is_held(&kvm->irq_lock));\n\n\tfor (gsi = 0; gsi < irq_rt->nr_rt_entries; gsi++) {\n\t\thlist_for_each_entry(e, &irq_rt->map[gsi], link) {\n\t\t\tif (e->type == KVM_IRQ_ROUTING_HV_SINT)\n\t\t\t\tkvm_hv_set_sint_gsi(kvm, e->hv_sint.vcpu,\n\t\t\t\t\t\t    e->hv_sint.sint, gsi);\n\t\t}\n\t}\n}\n\nstatic void synic_init(struct kvm_vcpu_hv_synic *synic)\n{\n\tint i;\n\n\tmemset(synic, 0, sizeof(*synic));\n\tsynic->version = HV_SYNIC_VERSION_1;\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tatomic64_set(&synic->sint[i], HV_SYNIC_SINT_MASKED);\n\t\tatomic_set(&synic->sint_to_gsi[i], -1);\n\t}\n}\n\nstatic u64 get_time_ref_counter(struct kvm *kvm)\n{\n\tstruct kvm_hv *hv = to_kvm_hv(kvm);\n\tstruct kvm_vcpu *vcpu;\n\tu64 tsc;\n\n\t \n\tif (hv->hv_tsc_page_status != HV_TSC_PAGE_SET)\n\t\treturn div_u64(get_kvmclock_ns(kvm), 100);\n\n\tvcpu = kvm_get_vcpu(kvm, 0);\n\ttsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\treturn mul_u64_u64_shr(tsc, hv->tsc_ref.tsc_scale, 64)\n\t\t+ hv->tsc_ref.tsc_offset;\n}\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tto_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}\n\nstatic void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}\n\nstatic enum hrtimer_restart stimer_timer_callback(struct hrtimer *timer)\n{\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\n\tstimer = container_of(timer, struct kvm_vcpu_hv_stimer, timer);\n\ttrace_kvm_hv_stimer_callback(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t     stimer->index);\n\tstimer_mark_pending(stimer, true);\n\n\treturn HRTIMER_NORESTART;\n}\n\n \nstatic int stimer_start(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tu64 time_now;\n\tktime_t ktime_now;\n\n\ttime_now = get_time_ref_counter(hv_stimer_to_vcpu(stimer)->kvm);\n\tktime_now = ktime_get();\n\n\tif (stimer->config.periodic) {\n\t\tif (stimer->exp_time) {\n\t\t\tif (time_now >= stimer->exp_time) {\n\t\t\t\tu64 remainder;\n\n\t\t\t\tdiv64_u64_rem(time_now - stimer->exp_time,\n\t\t\t\t\t      stimer->count, &remainder);\n\t\t\t\tstimer->exp_time =\n\t\t\t\t\ttime_now + (stimer->count - remainder);\n\t\t\t}\n\t\t} else\n\t\t\tstimer->exp_time = time_now + stimer->count;\n\n\t\ttrace_kvm_hv_stimer_start_periodic(\n\t\t\t\t\thv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t\tstimer->index,\n\t\t\t\t\ttime_now, stimer->exp_time);\n\n\t\thrtimer_start(&stimer->timer,\n\t\t\t      ktime_add_ns(ktime_now,\n\t\t\t\t\t   100 * (stimer->exp_time - time_now)),\n\t\t\t      HRTIMER_MODE_ABS);\n\t\treturn 0;\n\t}\n\tstimer->exp_time = stimer->count;\n\tif (time_now >= stimer->count) {\n\t\t \n\t\tstimer_mark_pending(stimer, false);\n\t\treturn 0;\n\t}\n\n\ttrace_kvm_hv_stimer_start_one_shot(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t\t   stimer->index,\n\t\t\t\t\t   time_now, stimer->count);\n\n\thrtimer_start(&stimer->timer,\n\t\t      ktime_add_ns(ktime_now, 100 * (stimer->count - time_now)),\n\t\t      HRTIMER_MODE_ABS);\n\treturn 0;\n}\n\nstatic int stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,\n\t\t\t     bool host)\n{\n\tunion hv_stimer_config new_config = {.as_uint64 = config},\n\t\told_config = {.as_uint64 = stimer->config.as_uint64};\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\n\tif (!synic->active && (!host || config))\n\t\treturn 1;\n\n\tif (unlikely(!host && hv_vcpu->enforce_cpuid && new_config.direct_mode &&\n\t\t     !(hv_vcpu->cpuid_cache.features_edx &\n\t\t       HV_STIMER_DIRECT_MODE_AVAILABLE)))\n\t\treturn 1;\n\n\ttrace_kvm_hv_stimer_set_config(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, config, host);\n\n\tstimer_cleanup(stimer);\n\tif (old_config.enable &&\n\t    !new_config.direct_mode && new_config.sintx == 0)\n\t\tnew_config.enable = 0;\n\tstimer->config.as_uint64 = new_config.as_uint64;\n\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\n\treturn 0;\n}\n\nstatic int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\n\tif (!synic->active && (!host || count))\n\t\treturn 1;\n\n\ttrace_kvm_hv_stimer_set_count(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (!host) {\n\t\tif (stimer->count == 0)\n\t\t\tstimer->config.enable = 0;\n\t\telse if (stimer->config.auto_enable)\n\t\t\tstimer->config.enable = 1;\n\t}\n\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\n\treturn 0;\n}\n\nstatic int stimer_get_config(struct kvm_vcpu_hv_stimer *stimer, u64 *pconfig)\n{\n\t*pconfig = stimer->config.as_uint64;\n\treturn 0;\n}\n\nstatic int stimer_get_count(struct kvm_vcpu_hv_stimer *stimer, u64 *pcount)\n{\n\t*pcount = stimer->count;\n\treturn 0;\n}\n\nstatic int synic_deliver_msg(struct kvm_vcpu_hv_synic *synic, u32 sint,\n\t\t\t     struct hv_message *src_msg, bool no_retry)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tint msg_off = offsetof(struct hv_message_page, sint_message[sint]);\n\tgfn_t msg_page_gfn;\n\tstruct hv_message_header hv_hdr;\n\tint r;\n\n\tif (!(synic->msg_page & HV_SYNIC_SIMP_ENABLE))\n\t\treturn -ENOENT;\n\n\tmsg_page_gfn = synic->msg_page >> PAGE_SHIFT;\n\n\t \n\tr = kvm_vcpu_read_guest_page(vcpu, msg_page_gfn, &hv_hdr.message_type,\n\t\t\t\t     msg_off + offsetof(struct hv_message,\n\t\t\t\t\t\t\theader.message_type),\n\t\t\t\t     sizeof(hv_hdr.message_type));\n\tif (r < 0)\n\t\treturn r;\n\n\tif (hv_hdr.message_type != HVMSG_NONE) {\n\t\tif (no_retry)\n\t\t\treturn 0;\n\n\t\thv_hdr.message_flags.msg_pending = 1;\n\t\tr = kvm_vcpu_write_guest_page(vcpu, msg_page_gfn,\n\t\t\t\t\t      &hv_hdr.message_flags,\n\t\t\t\t\t      msg_off +\n\t\t\t\t\t      offsetof(struct hv_message,\n\t\t\t\t\t\t       header.message_flags),\n\t\t\t\t\t      sizeof(hv_hdr.message_flags));\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\treturn -EAGAIN;\n\t}\n\n\tr = kvm_vcpu_write_guest_page(vcpu, msg_page_gfn, src_msg, msg_off,\n\t\t\t\t      sizeof(src_msg->header) +\n\t\t\t\t      src_msg->header.payload_size);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = synic_set_irq(synic, sint);\n\tif (r < 0)\n\t\treturn r;\n\tif (r == 0)\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int stimer_send_msg(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct hv_message *msg = &stimer->msg;\n\tstruct hv_timer_message_payload *payload =\n\t\t\t(struct hv_timer_message_payload *)&msg->u.payload;\n\n\t \n\tbool no_retry = stimer->config.periodic;\n\n\tpayload->expiration_time = stimer->exp_time;\n\tpayload->delivery_time = get_time_ref_counter(vcpu->kvm);\n\treturn synic_deliver_msg(to_hv_synic(vcpu),\n\t\t\t\t stimer->config.sintx, msg,\n\t\t\t\t no_retry);\n}\n\nstatic int stimer_notify_direct(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_lapic_irq irq = {\n\t\t.delivery_mode = APIC_DM_FIXED,\n\t\t.vector = stimer->config.apic_vector\n\t};\n\n\tif (lapic_in_kernel(vcpu))\n\t\treturn !kvm_apic_set_irq(vcpu, &irq, NULL);\n\treturn 0;\n}\n\nstatic void stimer_expiration(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tint r, direct = stimer->config.direct_mode;\n\n\tstimer->msg_pending = true;\n\tif (!direct)\n\t\tr = stimer_send_msg(stimer);\n\telse\n\t\tr = stimer_notify_direct(stimer);\n\ttrace_kvm_hv_stimer_expiration(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, direct, r);\n\tif (!r) {\n\t\tstimer->msg_pending = false;\n\t\tif (!(stimer->config.periodic))\n\t\t\tstimer->config.enable = 0;\n\t}\n}\n\nvoid kvm_hv_process_stimers(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tu64 time_now, exp_time;\n\tint i;\n\n\tif (!hv_vcpu)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tif (test_and_clear_bit(i, hv_vcpu->stimer_pending_bitmap)) {\n\t\t\tstimer = &hv_vcpu->stimer[i];\n\t\t\tif (stimer->config.enable) {\n\t\t\t\texp_time = stimer->exp_time;\n\n\t\t\t\tif (exp_time) {\n\t\t\t\t\ttime_now =\n\t\t\t\t\t\tget_time_ref_counter(vcpu->kvm);\n\t\t\t\t\tif (time_now >= exp_time)\n\t\t\t\t\t\tstimer_expiration(stimer);\n\t\t\t\t}\n\n\t\t\t\tif ((stimer->config.enable) &&\n\t\t\t\t    stimer->count) {\n\t\t\t\t\tif (!stimer->msg_pending)\n\t\t\t\t\t\tstimer_start(stimer);\n\t\t\t\t} else\n\t\t\t\t\tstimer_cleanup(stimer);\n\t\t\t}\n\t\t}\n}\n\nvoid kvm_hv_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tint i;\n\n\tif (!hv_vcpu)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tstimer_cleanup(&hv_vcpu->stimer[i]);\n\n\tkfree(hv_vcpu);\n\tvcpu->arch.hyperv = NULL;\n}\n\nbool kvm_hv_assist_page_enabled(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\n\tif (!hv_vcpu)\n\t\treturn false;\n\n\tif (!(hv_vcpu->hv_vapic & HV_X64_MSR_VP_ASSIST_PAGE_ENABLE))\n\t\treturn false;\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}\nEXPORT_SYMBOL_GPL(kvm_hv_assist_page_enabled);\n\nint kvm_hv_get_assist_page(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\n\tif (!hv_vcpu || !kvm_hv_assist_page_enabled(vcpu))\n\t\treturn -EFAULT;\n\n\treturn kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data,\n\t\t\t\t     &hv_vcpu->vp_assist_page, sizeof(struct hv_vp_assist_page));\n}\nEXPORT_SYMBOL_GPL(kvm_hv_get_assist_page);\n\nstatic void stimer_prepare_msg(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct hv_message *msg = &stimer->msg;\n\tstruct hv_timer_message_payload *payload =\n\t\t\t(struct hv_timer_message_payload *)&msg->u.payload;\n\n\tmemset(&msg->header, 0, sizeof(msg->header));\n\tmsg->header.message_type = HVMSG_TIMER_EXPIRED;\n\tmsg->header.payload_size = sizeof(*payload);\n\n\tpayload->timer_index = stimer->index;\n\tpayload->expiration_time = 0;\n\tpayload->delivery_time = 0;\n}\n\nstatic void stimer_init(struct kvm_vcpu_hv_stimer *stimer, int timer_index)\n{\n\tmemset(stimer, 0, sizeof(*stimer));\n\tstimer->index = timer_index;\n\thrtimer_init(&stimer->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tstimer->timer.function = stimer_timer_callback;\n\tstimer_prepare_msg(stimer);\n}\n\nint kvm_hv_vcpu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tint i;\n\n\tif (hv_vcpu)\n\t\treturn 0;\n\n\thv_vcpu = kzalloc(sizeof(struct kvm_vcpu_hv), GFP_KERNEL_ACCOUNT);\n\tif (!hv_vcpu)\n\t\treturn -ENOMEM;\n\n\tvcpu->arch.hyperv = hv_vcpu;\n\thv_vcpu->vcpu = vcpu;\n\n\tsynic_init(&hv_vcpu->synic);\n\n\tbitmap_zero(hv_vcpu->stimer_pending_bitmap, HV_SYNIC_STIMER_COUNT);\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tstimer_init(&hv_vcpu->stimer[i], i);\n\n\thv_vcpu->vp_index = vcpu->vcpu_idx;\n\n\tfor (i = 0; i < HV_NR_TLB_FLUSH_FIFOS; i++) {\n\t\tINIT_KFIFO(hv_vcpu->tlb_flush_fifo[i].entries);\n\t\tspin_lock_init(&hv_vcpu->tlb_flush_fifo[i].write_lock);\n\t}\n\n\treturn 0;\n}\n\nint kvm_hv_activate_synic(struct kvm_vcpu *vcpu, bool dont_zero_synic_pages)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\tint r;\n\n\tr = kvm_hv_vcpu_init(vcpu);\n\tif (r)\n\t\treturn r;\n\n\tsynic = to_hv_synic(vcpu);\n\n\tsynic->active = true;\n\tsynic->dont_zero_synic_pages = dont_zero_synic_pages;\n\tsynic->control = HV_SYNIC_CONTROL_ENABLE;\n\treturn 0;\n}\n\nstatic bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_RESET:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\tcase HV_X64_MSR_TSC_INVARIANT_CONTROL:\n\tcase HV_X64_MSR_SYNDBG_OPTIONS:\n\tcase HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nstatic int kvm_hv_msr_get_crash_data(struct kvm *kvm, u32 index, u64 *pdata)\n{\n\tstruct kvm_hv *hv = to_kvm_hv(kvm);\n\tsize_t size = ARRAY_SIZE(hv->hv_crash_param);\n\n\tif (WARN_ON_ONCE(index >= size))\n\t\treturn -EINVAL;\n\n\t*pdata = hv->hv_crash_param[array_index_nospec(index, size)];\n\treturn 0;\n}\n\nstatic int kvm_hv_msr_get_crash_ctl(struct kvm *kvm, u64 *pdata)\n{\n\tstruct kvm_hv *hv = to_kvm_hv(kvm);\n\n\t*pdata = hv->hv_crash_ctl;\n\treturn 0;\n}\n\nstatic int kvm_hv_msr_set_crash_ctl(struct kvm *kvm, u64 data)\n{\n\tstruct kvm_hv *hv = to_kvm_hv(kvm);\n\n\thv->hv_crash_ctl = data & HV_CRASH_CTL_CRASH_NOTIFY;\n\n\treturn 0;\n}\n\nstatic int kvm_hv_msr_set_crash_data(struct kvm *kvm, u32 index, u64 data)\n{\n\tstruct kvm_hv *hv = to_kvm_hv(kvm);\n\tsize_t size = ARRAY_SIZE(hv->hv_crash_param);\n\n\tif (WARN_ON_ONCE(index >= size))\n\t\treturn -EINVAL;\n\n\thv->hv_crash_param[array_index_nospec(index, size)] = data;\n\treturn 0;\n}\n\n \nstatic bool compute_tsc_page_parameters(struct pvclock_vcpu_time_info *hv_clock,\n\t\t\t\t\tstruct ms_hyperv_tsc_page *tsc_ref)\n{\n\tu64 max_mul;\n\n\tif (!(hv_clock->flags & PVCLOCK_TSC_STABLE_BIT))\n\t\treturn false;\n\n\t \n\tmax_mul = 100ull << (32 - hv_clock->tsc_shift);\n\tif (hv_clock->tsc_to_system_mul >= max_mul)\n\t\treturn false;\n\n\t \n\ttsc_ref->tsc_scale =\n\t\tmul_u64_u32_div(1ULL << (32 + hv_clock->tsc_shift),\n\t\t\t\thv_clock->tsc_to_system_mul,\n\t\t\t\t100);\n\n\ttsc_ref->tsc_offset = hv_clock->system_time;\n\tdo_div(tsc_ref->tsc_offset, 100);\n\ttsc_ref->tsc_offset -=\n\t\tmul_u64_u64_shr(hv_clock->tsc_timestamp, tsc_ref->tsc_scale, 64);\n\treturn true;\n}\n\n \nstatic inline bool tsc_page_update_unsafe(struct kvm_hv *hv)\n{\n\treturn (hv->hv_tsc_page_status != HV_TSC_PAGE_GUEST_CHANGED) &&\n\t\thv->hv_tsc_emulation_control;\n}\n\nvoid kvm_hv_setup_tsc_page(struct kvm *kvm,\n\t\t\t   struct pvclock_vcpu_time_info *hv_clock)\n{\n\tstruct kvm_hv *hv = to_kvm_hv(kvm);\n\tu32 tsc_seq;\n\tu64 gfn;\n\n\tBUILD_BUG_ON(sizeof(tsc_seq) != sizeof(hv->tsc_ref.tsc_sequence));\n\tBUILD_BUG_ON(offsetof(struct ms_hyperv_tsc_page, tsc_sequence) != 0);\n\n\tmutex_lock(&hv->hv_lock);\n\n\tif (hv->hv_tsc_page_status == HV_TSC_PAGE_BROKEN ||\n\t    hv->hv_tsc_page_status == HV_TSC_PAGE_SET ||\n\t    hv->hv_tsc_page_status == HV_TSC_PAGE_UNSET)\n\t\tgoto out_unlock;\n\n\tif (!(hv->hv_tsc_page & HV_X64_MSR_TSC_REFERENCE_ENABLE))\n\t\tgoto out_unlock;\n\n\tgfn = hv->hv_tsc_page >> HV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFT;\n\t \n\tif (unlikely(kvm_read_guest(kvm, gfn_to_gpa(gfn),\n\t\t\t\t    &tsc_seq, sizeof(tsc_seq))))\n\t\tgoto out_err;\n\n\tif (tsc_seq && tsc_page_update_unsafe(hv)) {\n\t\tif (kvm_read_guest(kvm, gfn_to_gpa(gfn), &hv->tsc_ref, sizeof(hv->tsc_ref)))\n\t\t\tgoto out_err;\n\n\t\thv->hv_tsc_page_status = HV_TSC_PAGE_SET;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\thv->tsc_ref.tsc_sequence = 0;\n\tif (kvm_write_guest(kvm, gfn_to_gpa(gfn),\n\t\t\t    &hv->tsc_ref, sizeof(hv->tsc_ref.tsc_sequence)))\n\t\tgoto out_err;\n\n\tif (!compute_tsc_page_parameters(hv_clock, &hv->tsc_ref))\n\t\tgoto out_err;\n\n\t \n\tsmp_wmb();\n\tif (kvm_write_guest(kvm, gfn_to_gpa(gfn), &hv->tsc_ref, sizeof(hv->tsc_ref)))\n\t\tgoto out_err;\n\n\t \n\ttsc_seq++;\n\tif (tsc_seq == 0xFFFFFFFF || tsc_seq == 0)\n\t\ttsc_seq = 1;\n\n\t \n\tsmp_wmb();\n\n\thv->tsc_ref.tsc_sequence = tsc_seq;\n\tif (kvm_write_guest(kvm, gfn_to_gpa(gfn),\n\t\t\t    &hv->tsc_ref, sizeof(hv->tsc_ref.tsc_sequence)))\n\t\tgoto out_err;\n\n\thv->hv_tsc_page_status = HV_TSC_PAGE_SET;\n\tgoto out_unlock;\n\nout_err:\n\thv->hv_tsc_page_status = HV_TSC_PAGE_BROKEN;\nout_unlock:\n\tmutex_unlock(&hv->hv_lock);\n}\n\nvoid kvm_hv_request_tsc_page_update(struct kvm *kvm)\n{\n\tstruct kvm_hv *hv = to_kvm_hv(kvm);\n\n\tmutex_lock(&hv->hv_lock);\n\n\tif (hv->hv_tsc_page_status == HV_TSC_PAGE_SET &&\n\t    !tsc_page_update_unsafe(hv))\n\t\thv->hv_tsc_page_status = HV_TSC_PAGE_HOST_CHANGED;\n\n\tmutex_unlock(&hv->hv_lock);\n}\n\nstatic bool hv_check_msr_access(struct kvm_vcpu_hv *hv_vcpu, u32 msr)\n{\n\tif (!hv_vcpu->enforce_cpuid)\n\t\treturn true;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\t\treturn hv_vcpu->cpuid_cache.features_eax &\n\t\t\tHV_MSR_HYPERCALL_AVAILABLE;\n\tcase HV_X64_MSR_VP_RUNTIME:\n\t\treturn hv_vcpu->cpuid_cache.features_eax &\n\t\t\tHV_MSR_VP_RUNTIME_AVAILABLE;\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\t\treturn hv_vcpu->cpuid_cache.features_eax &\n\t\t\tHV_MSR_TIME_REF_COUNT_AVAILABLE;\n\tcase HV_X64_MSR_VP_INDEX:\n\t\treturn hv_vcpu->cpuid_cache.features_eax &\n\t\t\tHV_MSR_VP_INDEX_AVAILABLE;\n\tcase HV_X64_MSR_RESET:\n\t\treturn hv_vcpu->cpuid_cache.features_eax &\n\t\t\tHV_MSR_RESET_AVAILABLE;\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\t\treturn hv_vcpu->cpuid_cache.features_eax &\n\t\t\tHV_MSR_REFERENCE_TSC_AVAILABLE;\n\tcase HV_X64_MSR_SCONTROL:\n\tcase HV_X64_MSR_SVERSION:\n\tcase HV_X64_MSR_SIEFP:\n\tcase HV_X64_MSR_SIMP:\n\tcase HV_X64_MSR_EOM:\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\treturn hv_vcpu->cpuid_cache.features_eax &\n\t\t\tHV_MSR_SYNIC_AVAILABLE;\n\tcase HV_X64_MSR_STIMER0_CONFIG:\n\tcase HV_X64_MSR_STIMER1_CONFIG:\n\tcase HV_X64_MSR_STIMER2_CONFIG:\n\tcase HV_X64_MSR_STIMER3_CONFIG:\n\tcase HV_X64_MSR_STIMER0_COUNT:\n\tcase HV_X64_MSR_STIMER1_COUNT:\n\tcase HV_X64_MSR_STIMER2_COUNT:\n\tcase HV_X64_MSR_STIMER3_COUNT:\n\t\treturn hv_vcpu->cpuid_cache.features_eax &\n\t\t\tHV_MSR_SYNTIMER_AVAILABLE;\n\tcase HV_X64_MSR_EOI:\n\tcase HV_X64_MSR_ICR:\n\tcase HV_X64_MSR_TPR:\n\tcase HV_X64_MSR_VP_ASSIST_PAGE:\n\t\treturn hv_vcpu->cpuid_cache.features_eax &\n\t\t\tHV_MSR_APIC_ACCESS_AVAILABLE;\n\tcase HV_X64_MSR_TSC_FREQUENCY:\n\tcase HV_X64_MSR_APIC_FREQUENCY:\n\t\treturn hv_vcpu->cpuid_cache.features_eax &\n\t\t\tHV_ACCESS_FREQUENCY_MSRS;\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\treturn hv_vcpu->cpuid_cache.features_eax &\n\t\t\tHV_ACCESS_REENLIGHTENMENT;\n\tcase HV_X64_MSR_TSC_INVARIANT_CONTROL:\n\t\treturn hv_vcpu->cpuid_cache.features_eax &\n\t\t\tHV_ACCESS_TSC_INVARIANT;\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\treturn hv_vcpu->cpuid_cache.features_edx &\n\t\t\tHV_FEATURE_GUEST_CRASH_MSR_AVAILABLE;\n\tcase HV_X64_MSR_SYNDBG_OPTIONS:\n\tcase HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER:\n\t\treturn hv_vcpu->cpuid_cache.features_edx &\n\t\t\tHV_FEATURE_DEBUG_MSRS_AVAILABLE;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic int kvm_hv_set_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 data,\n\t\t\t     bool host)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_hv *hv = to_kvm_hv(kvm);\n\n\tif (unlikely(!host && !hv_check_msr_access(to_hv_vcpu(vcpu), msr)))\n\t\treturn 1;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\thv->hv_guest_os_id = data;\n\t\t \n\t\tif (!hv->hv_guest_os_id)\n\t\t\thv->hv_hypercall &= ~HV_X64_MSR_HYPERCALL_ENABLE;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL: {\n\t\tu8 instructions[9];\n\t\tint i = 0;\n\t\tu64 addr;\n\n\t\t \n\t\tif (!hv->hv_guest_os_id)\n\t\t\tbreak;\n\t\tif (!(data & HV_X64_MSR_HYPERCALL_ENABLE)) {\n\t\t\thv->hv_hypercall = data;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (kvm_xen_hypercall_enabled(kvm)) {\n\t\t\t \n\t\t\tinstructions[i++] = 0x0d;\n\t\t\tinstructions[i++] = 0x00;\n\t\t\tinstructions[i++] = 0x00;\n\t\t\tinstructions[i++] = 0x00;\n\t\t\tinstructions[i++] = 0x80;\n\t\t}\n\n\t\t \n\t\tstatic_call(kvm_x86_patch_hypercall)(vcpu, instructions + i);\n\t\ti += 3;\n\n\t\t \n\t\t((unsigned char *)instructions)[i++] = 0xc3;\n\n\t\taddr = data & HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_MASK;\n\t\tif (kvm_vcpu_write_guest(vcpu, addr, instructions, i))\n\t\t\treturn 1;\n\t\thv->hv_hypercall = data;\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\t\thv->hv_tsc_page = data;\n\t\tif (hv->hv_tsc_page & HV_X64_MSR_TSC_REFERENCE_ENABLE) {\n\t\t\tif (!host)\n\t\t\t\thv->hv_tsc_page_status = HV_TSC_PAGE_GUEST_CHANGED;\n\t\t\telse\n\t\t\t\thv->hv_tsc_page_status = HV_TSC_PAGE_HOST_CHANGED;\n\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\t\t} else {\n\t\t\thv->hv_tsc_page_status = HV_TSC_PAGE_UNSET;\n\t\t}\n\t\tbreak;\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\t\treturn kvm_hv_msr_set_crash_data(kvm,\n\t\t\t\t\t\t msr - HV_X64_MSR_CRASH_P0,\n\t\t\t\t\t\t data);\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\tif (host)\n\t\t\treturn kvm_hv_msr_set_crash_ctl(kvm, data);\n\n\t\tif (data & HV_CRASH_CTL_CRASH_NOTIFY) {\n\t\t\tvcpu_debug(vcpu, \"hv crash (0x%llx 0x%llx 0x%llx 0x%llx 0x%llx)\\n\",\n\t\t\t\t   hv->hv_crash_param[0],\n\t\t\t\t   hv->hv_crash_param[1],\n\t\t\t\t   hv->hv_crash_param[2],\n\t\t\t\t   hv->hv_crash_param[3],\n\t\t\t\t   hv->hv_crash_param[4]);\n\n\t\t\t \n\t\t\tkvm_make_request(KVM_REQ_HV_CRASH, vcpu);\n\t\t}\n\t\tbreak;\n\tcase HV_X64_MSR_RESET:\n\t\tif (data == 1) {\n\t\t\tvcpu_debug(vcpu, \"hyper-v reset requested\\n\");\n\t\t\tkvm_make_request(KVM_REQ_HV_RESET, vcpu);\n\t\t}\n\t\tbreak;\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\t\thv->hv_reenlightenment_control = data;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\t\thv->hv_tsc_emulation_control = data;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\tif (data && !host)\n\t\t\treturn 1;\n\n\t\thv->hv_tsc_emulation_status = data;\n\t\tbreak;\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\t\t \n\t\tif (!host)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_INVARIANT_CONTROL:\n\t\t \n\t\tif (data & ~HV_EXPOSE_INVARIANT_TSC)\n\t\t\treturn 1;\n\n\t\t \n\t\tif (!host && hv->hv_invtsc_control && !data)\n\t\t\treturn 1;\n\n\t\thv->hv_invtsc_control = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SYNDBG_OPTIONS:\n\tcase HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER:\n\t\treturn syndbg_set_msr(vcpu, msr, data, host);\n\tdefault:\n\t\tkvm_pr_unimpl_wrmsr(vcpu, msr, data);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic u64 current_task_runtime_100ns(void)\n{\n\tu64 utime, stime;\n\n\ttask_cputime_adjusted(current, &utime, &stime);\n\n\treturn div_u64(utime + stime, 100);\n}\n\nstatic int kvm_hv_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\n\tif (unlikely(!host && !hv_check_msr_access(hv_vcpu, msr)))\n\t\treturn 1;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_VP_INDEX: {\n\t\tstruct kvm_hv *hv = to_kvm_hv(vcpu->kvm);\n\t\tu32 new_vp_index = (u32)data;\n\n\t\tif (!host || new_vp_index >= KVM_MAX_VCPUS)\n\t\t\treturn 1;\n\n\t\tif (new_vp_index == hv_vcpu->vp_index)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (hv_vcpu->vp_index == vcpu->vcpu_idx)\n\t\t\tatomic_inc(&hv->num_mismatched_vp_indexes);\n\t\telse if (new_vp_index == vcpu->vcpu_idx)\n\t\t\tatomic_dec(&hv->num_mismatched_vp_indexes);\n\n\t\thv_vcpu->vp_index = new_vp_index;\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_VP_ASSIST_PAGE: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\n\t\tif (!(data & HV_X64_MSR_VP_ASSIST_PAGE_ENABLE)) {\n\t\t\thv_vcpu->hv_vapic = data;\n\t\t\tif (kvm_lapic_set_pv_eoi(vcpu, 0, 0))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_VP_ASSIST_PAGE_ADDRESS_SHIFT;\n\t\taddr = kvm_vcpu_gfn_to_hva(vcpu, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\n\t\t \n\t\tif (__put_user(0, (u32 __user *)addr))\n\t\t\treturn 1;\n\t\thv_vcpu->hv_vapic = data;\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t\tif (kvm_lapic_set_pv_eoi(vcpu,\n\t\t\t\t\t    gfn_to_gpa(gfn) | KVM_MSR_ENABLED,\n\t\t\t\t\t    sizeof(struct hv_vp_assist_page)))\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_EOI, data);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_ICR, data);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_TASKPRI, data);\n\tcase HV_X64_MSR_VP_RUNTIME:\n\t\tif (!host)\n\t\t\treturn 1;\n\t\thv_vcpu->runtime_offset = data - current_task_runtime_100ns();\n\t\tbreak;\n\tcase HV_X64_MSR_SCONTROL:\n\tcase HV_X64_MSR_SVERSION:\n\tcase HV_X64_MSR_SIEFP:\n\tcase HV_X64_MSR_SIMP:\n\tcase HV_X64_MSR_EOM:\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\treturn synic_set_msr(to_hv_synic(vcpu), msr, data, host);\n\tcase HV_X64_MSR_STIMER0_CONFIG:\n\tcase HV_X64_MSR_STIMER1_CONFIG:\n\tcase HV_X64_MSR_STIMER2_CONFIG:\n\tcase HV_X64_MSR_STIMER3_CONFIG: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_CONFIG)/2;\n\n\t\treturn stimer_set_config(to_hv_stimer(vcpu, timer_index),\n\t\t\t\t\t data, host);\n\t}\n\tcase HV_X64_MSR_STIMER0_COUNT:\n\tcase HV_X64_MSR_STIMER1_COUNT:\n\tcase HV_X64_MSR_STIMER2_COUNT:\n\tcase HV_X64_MSR_STIMER3_COUNT: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_COUNT)/2;\n\n\t\treturn stimer_set_count(to_hv_stimer(vcpu, timer_index),\n\t\t\t\t\tdata, host);\n\t}\n\tcase HV_X64_MSR_TSC_FREQUENCY:\n\tcase HV_X64_MSR_APIC_FREQUENCY:\n\t\t \n\t\tif (!host)\n\t\t\treturn 1;\n\t\tbreak;\n\tdefault:\n\t\tkvm_pr_unimpl_wrmsr(vcpu, msr, data);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int kvm_hv_get_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata,\n\t\t\t     bool host)\n{\n\tu64 data = 0;\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_hv *hv = to_kvm_hv(kvm);\n\n\tif (unlikely(!host && !hv_check_msr_access(to_hv_vcpu(vcpu), msr)))\n\t\treturn 1;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tdata = hv->hv_guest_os_id;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL:\n\t\tdata = hv->hv_hypercall;\n\t\tbreak;\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\t\tdata = get_time_ref_counter(kvm);\n\t\tbreak;\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\t\tdata = hv->hv_tsc_page;\n\t\tbreak;\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\t\treturn kvm_hv_msr_get_crash_data(kvm,\n\t\t\t\t\t\t msr - HV_X64_MSR_CRASH_P0,\n\t\t\t\t\t\t pdata);\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\treturn kvm_hv_msr_get_crash_ctl(kvm, pdata);\n\tcase HV_X64_MSR_RESET:\n\t\tdata = 0;\n\t\tbreak;\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\t\tdata = hv->hv_reenlightenment_control;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\t\tdata = hv->hv_tsc_emulation_control;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\tdata = hv->hv_tsc_emulation_status;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_INVARIANT_CONTROL:\n\t\tdata = hv->hv_invtsc_control;\n\t\tbreak;\n\tcase HV_X64_MSR_SYNDBG_OPTIONS:\n\tcase HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER:\n\t\treturn syndbg_get_msr(vcpu, msr, pdata, host);\n\tdefault:\n\t\tkvm_pr_unimpl_rdmsr(vcpu, msr);\n\t\treturn 1;\n\t}\n\n\t*pdata = data;\n\treturn 0;\n}\n\nstatic int kvm_hv_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata,\n\t\t\t  bool host)\n{\n\tu64 data = 0;\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\n\tif (unlikely(!host && !hv_check_msr_access(hv_vcpu, msr)))\n\t\treturn 1;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_VP_INDEX:\n\t\tdata = hv_vcpu->vp_index;\n\t\tbreak;\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_EOI, pdata);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_ICR, pdata);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_TASKPRI, pdata);\n\tcase HV_X64_MSR_VP_ASSIST_PAGE:\n\t\tdata = hv_vcpu->hv_vapic;\n\t\tbreak;\n\tcase HV_X64_MSR_VP_RUNTIME:\n\t\tdata = current_task_runtime_100ns() + hv_vcpu->runtime_offset;\n\t\tbreak;\n\tcase HV_X64_MSR_SCONTROL:\n\tcase HV_X64_MSR_SVERSION:\n\tcase HV_X64_MSR_SIEFP:\n\tcase HV_X64_MSR_SIMP:\n\tcase HV_X64_MSR_EOM:\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\treturn synic_get_msr(to_hv_synic(vcpu), msr, pdata, host);\n\tcase HV_X64_MSR_STIMER0_CONFIG:\n\tcase HV_X64_MSR_STIMER1_CONFIG:\n\tcase HV_X64_MSR_STIMER2_CONFIG:\n\tcase HV_X64_MSR_STIMER3_CONFIG: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_CONFIG)/2;\n\n\t\treturn stimer_get_config(to_hv_stimer(vcpu, timer_index),\n\t\t\t\t\t pdata);\n\t}\n\tcase HV_X64_MSR_STIMER0_COUNT:\n\tcase HV_X64_MSR_STIMER1_COUNT:\n\tcase HV_X64_MSR_STIMER2_COUNT:\n\tcase HV_X64_MSR_STIMER3_COUNT: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_COUNT)/2;\n\n\t\treturn stimer_get_count(to_hv_stimer(vcpu, timer_index),\n\t\t\t\t\tpdata);\n\t}\n\tcase HV_X64_MSR_TSC_FREQUENCY:\n\t\tdata = (u64)vcpu->arch.virtual_tsc_khz * 1000;\n\t\tbreak;\n\tcase HV_X64_MSR_APIC_FREQUENCY:\n\t\tdata = APIC_BUS_FREQUENCY;\n\t\tbreak;\n\tdefault:\n\t\tkvm_pr_unimpl_rdmsr(vcpu, msr);\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}\n\nint kvm_hv_set_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)\n{\n\tstruct kvm_hv *hv = to_kvm_hv(vcpu->kvm);\n\n\tif (!host && !vcpu->arch.hyperv_enabled)\n\t\treturn 1;\n\n\tif (kvm_hv_vcpu_init(vcpu))\n\t\treturn 1;\n\n\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\tint r;\n\n\t\tmutex_lock(&hv->hv_lock);\n\t\tr = kvm_hv_set_msr_pw(vcpu, msr, data, host);\n\t\tmutex_unlock(&hv->hv_lock);\n\t\treturn r;\n\t} else\n\t\treturn kvm_hv_set_msr(vcpu, msr, data, host);\n}\n\nint kvm_hv_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata, bool host)\n{\n\tstruct kvm_hv *hv = to_kvm_hv(vcpu->kvm);\n\n\tif (!host && !vcpu->arch.hyperv_enabled)\n\t\treturn 1;\n\n\tif (kvm_hv_vcpu_init(vcpu))\n\t\treturn 1;\n\n\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\tint r;\n\n\t\tmutex_lock(&hv->hv_lock);\n\t\tr = kvm_hv_get_msr_pw(vcpu, msr, pdata, host);\n\t\tmutex_unlock(&hv->hv_lock);\n\t\treturn r;\n\t} else\n\t\treturn kvm_hv_get_msr(vcpu, msr, pdata, host);\n}\n\nstatic void sparse_set_to_vcpu_mask(struct kvm *kvm, u64 *sparse_banks,\n\t\t\t\t    u64 valid_bank_mask, unsigned long *vcpu_mask)\n{\n\tstruct kvm_hv *hv = to_kvm_hv(kvm);\n\tbool has_mismatch = atomic_read(&hv->num_mismatched_vp_indexes);\n\tu64 vp_bitmap[KVM_HV_MAX_SPARSE_VCPU_SET_BITS];\n\tstruct kvm_vcpu *vcpu;\n\tint bank, sbank = 0;\n\tunsigned long i;\n\tu64 *bitmap;\n\n\tBUILD_BUG_ON(sizeof(vp_bitmap) >\n\t\t     sizeof(*vcpu_mask) * BITS_TO_LONGS(KVM_MAX_VCPUS));\n\n\t \n\tif (likely(!has_mismatch))\n\t\tbitmap = (u64 *)vcpu_mask;\n\telse\n\t\tbitmap = vp_bitmap;\n\n\t \n\tmemset(bitmap, 0, sizeof(vp_bitmap));\n\tfor_each_set_bit(bank, (unsigned long *)&valid_bank_mask,\n\t\t\t KVM_HV_MAX_SPARSE_VCPU_SET_BITS)\n\t\tbitmap[bank] = sparse_banks[sbank++];\n\n\tif (likely(!has_mismatch))\n\t\treturn;\n\n\tbitmap_zero(vcpu_mask, KVM_MAX_VCPUS);\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (test_bit(kvm_hv_get_vpindex(vcpu), (unsigned long *)vp_bitmap))\n\t\t\t__set_bit(i, vcpu_mask);\n\t}\n}\n\nstatic bool hv_is_vp_in_sparse_set(u32 vp_id, u64 valid_bank_mask, u64 sparse_banks[])\n{\n\tint valid_bit_nr = vp_id / HV_VCPUS_PER_SPARSE_BANK;\n\tunsigned long sbank;\n\n\tif (!test_bit(valid_bit_nr, (unsigned long *)&valid_bank_mask))\n\t\treturn false;\n\n\t \n\tif (valid_bit_nr)\n\t\tsbank = hweight64(valid_bank_mask & GENMASK_ULL(valid_bit_nr - 1, 0));\n\telse\n\t\tsbank = 0;\n\n\treturn test_bit(vp_id % HV_VCPUS_PER_SPARSE_BANK,\n\t\t\t(unsigned long *)&sparse_banks[sbank]);\n}\n\nstruct kvm_hv_hcall {\n\t \n\tu64 param;\n\tu64 ingpa;\n\tu64 outgpa;\n\tu16 code;\n\tu16 var_cnt;\n\tu16 rep_cnt;\n\tu16 rep_idx;\n\tbool fast;\n\tbool rep;\n\tsse128_t xmm[HV_HYPERCALL_MAX_XMM_REGISTERS];\n\n\t \n\tunion {\n\t\tgpa_t data_offset;\n\t\tint consumed_xmm_halves;\n\t};\n};\n\n\nstatic int kvm_hv_get_hc_data(struct kvm *kvm, struct kvm_hv_hcall *hc,\n\t\t\t      u16 orig_cnt, u16 cnt_cap, u64 *data)\n{\n\t \n\tu16 cnt = min(orig_cnt, cnt_cap);\n\tint i, j;\n\n\tif (hc->fast) {\n\t\t \n\t\tif (orig_cnt > 2 * HV_HYPERCALL_MAX_XMM_REGISTERS - hc->consumed_xmm_halves)\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tj = i + hc->consumed_xmm_halves;\n\t\t\tif (j % 2)\n\t\t\t\tdata[i] = sse128_hi(hc->xmm[j / 2]);\n\t\t\telse\n\t\t\t\tdata[i] = sse128_lo(hc->xmm[j / 2]);\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn kvm_read_guest(kvm, hc->ingpa + hc->data_offset, data,\n\t\t\t      cnt * sizeof(*data));\n}\n\nstatic u64 kvm_get_sparse_vp_set(struct kvm *kvm, struct kvm_hv_hcall *hc,\n\t\t\t\t u64 *sparse_banks)\n{\n\tif (hc->var_cnt > HV_MAX_SPARSE_VCPU_BANKS)\n\t\treturn -EINVAL;\n\n\t \n\treturn kvm_hv_get_hc_data(kvm, hc, hc->var_cnt, KVM_HV_MAX_SPARSE_VCPU_SET_BITS,\n\t\t\t\t  sparse_banks);\n}\n\nstatic int kvm_hv_get_tlb_flush_entries(struct kvm *kvm, struct kvm_hv_hcall *hc, u64 entries[])\n{\n\treturn kvm_hv_get_hc_data(kvm, hc, hc->rep_cnt, hc->rep_cnt, entries);\n}\n\nstatic void hv_tlb_flush_enqueue(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_vcpu_hv_tlb_flush_fifo *tlb_flush_fifo,\n\t\t\t\t u64 *entries, int count)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tu64 flush_all_entry = KVM_HV_TLB_FLUSHALL_ENTRY;\n\n\tif (!hv_vcpu)\n\t\treturn;\n\n\tspin_lock(&tlb_flush_fifo->write_lock);\n\n\t \n\tif (count && entries && count < kfifo_avail(&tlb_flush_fifo->entries)) {\n\t\tWARN_ON(kfifo_in(&tlb_flush_fifo->entries, entries, count) != count);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tkfifo_in(&tlb_flush_fifo->entries, &flush_all_entry, 1);\n\nout_unlock:\n\tspin_unlock(&tlb_flush_fifo->write_lock);\n}\n\nint kvm_hv_vcpu_flush_tlb(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv_tlb_flush_fifo *tlb_flush_fifo;\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tu64 entries[KVM_HV_TLB_FLUSH_FIFO_SIZE];\n\tint i, j, count;\n\tgva_t gva;\n\n\tif (!tdp_enabled || !hv_vcpu)\n\t\treturn -EINVAL;\n\n\ttlb_flush_fifo = kvm_hv_get_tlb_flush_fifo(vcpu, is_guest_mode(vcpu));\n\n\tcount = kfifo_out(&tlb_flush_fifo->entries, entries, KVM_HV_TLB_FLUSH_FIFO_SIZE);\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (entries[i] == KVM_HV_TLB_FLUSHALL_ENTRY)\n\t\t\tgoto out_flush_all;\n\n\t\t \n\t\tgva = entries[i] & PAGE_MASK;\n\t\tfor (j = 0; j < (entries[i] & ~PAGE_MASK) + 1; j++)\n\t\t\tstatic_call(kvm_x86_flush_tlb_gva)(vcpu, gva + j * PAGE_SIZE);\n\n\t\t++vcpu->stat.tlb_flush;\n\t}\n\treturn 0;\n\nout_flush_all:\n\tkfifo_reset_out(&tlb_flush_fifo->entries);\n\n\t \n\treturn -ENOSPC;\n}\n\nstatic u64 kvm_hv_flush_tlb(struct kvm_vcpu *vcpu, struct kvm_hv_hcall *hc)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tu64 *sparse_banks = hv_vcpu->sparse_banks;\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct hv_tlb_flush_ex flush_ex;\n\tstruct hv_tlb_flush flush;\n\tDECLARE_BITMAP(vcpu_mask, KVM_MAX_VCPUS);\n\tstruct kvm_vcpu_hv_tlb_flush_fifo *tlb_flush_fifo;\n\t \n\tu64 __tlb_flush_entries[KVM_HV_TLB_FLUSH_FIFO_SIZE - 1];\n\tu64 *tlb_flush_entries;\n\tu64 valid_bank_mask;\n\tstruct kvm_vcpu *v;\n\tunsigned long i;\n\tbool all_cpus;\n\n\t \n\tBUILD_BUG_ON(KVM_HV_MAX_SPARSE_VCPU_SET_BITS > HV_MAX_SPARSE_VCPU_BANKS);\n\n\t \n\tif (!hc->fast && is_guest_mode(vcpu)) {\n\t\thc->ingpa = translate_nested_gpa(vcpu, hc->ingpa, 0, NULL);\n\t\tif (unlikely(hc->ingpa == INVALID_GPA))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t}\n\n\tif (hc->code == HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST ||\n\t    hc->code == HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE) {\n\t\tif (hc->fast) {\n\t\t\tflush.address_space = hc->ingpa;\n\t\t\tflush.flags = hc->outgpa;\n\t\t\tflush.processor_mask = sse128_lo(hc->xmm[0]);\n\t\t\thc->consumed_xmm_halves = 1;\n\t\t} else {\n\t\t\tif (unlikely(kvm_read_guest(kvm, hc->ingpa,\n\t\t\t\t\t\t    &flush, sizeof(flush))))\n\t\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\thc->data_offset = sizeof(flush);\n\t\t}\n\n\t\ttrace_kvm_hv_flush_tlb(flush.processor_mask,\n\t\t\t\t       flush.address_space, flush.flags,\n\t\t\t\t       is_guest_mode(vcpu));\n\n\t\tvalid_bank_mask = BIT_ULL(0);\n\t\tsparse_banks[0] = flush.processor_mask;\n\n\t\t \n\t\tall_cpus = (flush.flags & HV_FLUSH_ALL_PROCESSORS) ||\n\t\t\tflush.processor_mask == 0;\n\t} else {\n\t\tif (hc->fast) {\n\t\t\tflush_ex.address_space = hc->ingpa;\n\t\t\tflush_ex.flags = hc->outgpa;\n\t\t\tmemcpy(&flush_ex.hv_vp_set,\n\t\t\t       &hc->xmm[0], sizeof(hc->xmm[0]));\n\t\t\thc->consumed_xmm_halves = 2;\n\t\t} else {\n\t\t\tif (unlikely(kvm_read_guest(kvm, hc->ingpa, &flush_ex,\n\t\t\t\t\t\t    sizeof(flush_ex))))\n\t\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\thc->data_offset = sizeof(flush_ex);\n\t\t}\n\n\t\ttrace_kvm_hv_flush_tlb_ex(flush_ex.hv_vp_set.valid_bank_mask,\n\t\t\t\t\t  flush_ex.hv_vp_set.format,\n\t\t\t\t\t  flush_ex.address_space,\n\t\t\t\t\t  flush_ex.flags, is_guest_mode(vcpu));\n\n\t\tvalid_bank_mask = flush_ex.hv_vp_set.valid_bank_mask;\n\t\tall_cpus = flush_ex.hv_vp_set.format !=\n\t\t\tHV_GENERIC_SET_SPARSE_4K;\n\n\t\tif (hc->var_cnt != hweight64(valid_bank_mask))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t\tif (!all_cpus) {\n\t\t\tif (!hc->var_cnt)\n\t\t\t\tgoto ret_success;\n\n\t\t\tif (kvm_get_sparse_vp_set(kvm, hc, sparse_banks))\n\t\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t}\n\n\t\t \n\t\tif (hc->fast)\n\t\t\thc->consumed_xmm_halves += hc->var_cnt;\n\t\telse\n\t\t\thc->data_offset += hc->var_cnt * sizeof(sparse_banks[0]);\n\t}\n\n\tif (hc->code == HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE ||\n\t    hc->code == HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX ||\n\t    hc->rep_cnt > ARRAY_SIZE(__tlb_flush_entries)) {\n\t\ttlb_flush_entries = NULL;\n\t} else {\n\t\tif (kvm_hv_get_tlb_flush_entries(kvm, hc, __tlb_flush_entries))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\ttlb_flush_entries = __tlb_flush_entries;\n\t}\n\n\t \n\tif (all_cpus && !is_guest_mode(vcpu)) {\n\t\tkvm_for_each_vcpu(i, v, kvm) {\n\t\t\ttlb_flush_fifo = kvm_hv_get_tlb_flush_fifo(v, false);\n\t\t\thv_tlb_flush_enqueue(v, tlb_flush_fifo,\n\t\t\t\t\t     tlb_flush_entries, hc->rep_cnt);\n\t\t}\n\n\t\tkvm_make_all_cpus_request(kvm, KVM_REQ_HV_TLB_FLUSH);\n\t} else if (!is_guest_mode(vcpu)) {\n\t\tsparse_set_to_vcpu_mask(kvm, sparse_banks, valid_bank_mask, vcpu_mask);\n\n\t\tfor_each_set_bit(i, vcpu_mask, KVM_MAX_VCPUS) {\n\t\t\tv = kvm_get_vcpu(kvm, i);\n\t\t\tif (!v)\n\t\t\t\tcontinue;\n\t\t\ttlb_flush_fifo = kvm_hv_get_tlb_flush_fifo(v, false);\n\t\t\thv_tlb_flush_enqueue(v, tlb_flush_fifo,\n\t\t\t\t\t     tlb_flush_entries, hc->rep_cnt);\n\t\t}\n\n\t\tkvm_make_vcpus_request_mask(kvm, KVM_REQ_HV_TLB_FLUSH, vcpu_mask);\n\t} else {\n\t\tstruct kvm_vcpu_hv *hv_v;\n\n\t\tbitmap_zero(vcpu_mask, KVM_MAX_VCPUS);\n\n\t\tkvm_for_each_vcpu(i, v, kvm) {\n\t\t\thv_v = to_hv_vcpu(v);\n\n\t\t\t \n\t\t\tif (!hv_v || hv_v->nested.vm_id != hv_vcpu->nested.vm_id)\n\t\t\t\tcontinue;\n\n\t\t\tif (!all_cpus &&\n\t\t\t    !hv_is_vp_in_sparse_set(hv_v->nested.vp_id, valid_bank_mask,\n\t\t\t\t\t\t    sparse_banks))\n\t\t\t\tcontinue;\n\n\t\t\t__set_bit(i, vcpu_mask);\n\t\t\ttlb_flush_fifo = kvm_hv_get_tlb_flush_fifo(v, true);\n\t\t\thv_tlb_flush_enqueue(v, tlb_flush_fifo,\n\t\t\t\t\t     tlb_flush_entries, hc->rep_cnt);\n\t\t}\n\n\t\tkvm_make_vcpus_request_mask(kvm, KVM_REQ_HV_TLB_FLUSH, vcpu_mask);\n\t}\n\nret_success:\n\t \n\treturn (u64)HV_STATUS_SUCCESS |\n\t\t((u64)hc->rep_cnt << HV_HYPERCALL_REP_COMP_OFFSET);\n}\n\nstatic void kvm_hv_send_ipi_to_many(struct kvm *kvm, u32 vector,\n\t\t\t\t    u64 *sparse_banks, u64 valid_bank_mask)\n{\n\tstruct kvm_lapic_irq irq = {\n\t\t.delivery_mode = APIC_DM_FIXED,\n\t\t.vector = vector\n\t};\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (sparse_banks &&\n\t\t    !hv_is_vp_in_sparse_set(kvm_hv_get_vpindex(vcpu),\n\t\t\t\t\t    valid_bank_mask, sparse_banks))\n\t\t\tcontinue;\n\n\t\t \n\t\tkvm_apic_set_irq(vcpu, &irq, NULL);\n\t}\n}\n\nstatic u64 kvm_hv_send_ipi(struct kvm_vcpu *vcpu, struct kvm_hv_hcall *hc)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tu64 *sparse_banks = hv_vcpu->sparse_banks;\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct hv_send_ipi_ex send_ipi_ex;\n\tstruct hv_send_ipi send_ipi;\n\tu64 valid_bank_mask;\n\tu32 vector;\n\tbool all_cpus;\n\n\tif (hc->code == HVCALL_SEND_IPI) {\n\t\tif (!hc->fast) {\n\t\t\tif (unlikely(kvm_read_guest(kvm, hc->ingpa, &send_ipi,\n\t\t\t\t\t\t    sizeof(send_ipi))))\n\t\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tsparse_banks[0] = send_ipi.cpu_mask;\n\t\t\tvector = send_ipi.vector;\n\t\t} else {\n\t\t\t \n\t\t\tif (unlikely(hc->ingpa >> 32 != 0))\n\t\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tsparse_banks[0] = hc->outgpa;\n\t\t\tvector = (u32)hc->ingpa;\n\t\t}\n\t\tall_cpus = false;\n\t\tvalid_bank_mask = BIT_ULL(0);\n\n\t\ttrace_kvm_hv_send_ipi(vector, sparse_banks[0]);\n\t} else {\n\t\tif (!hc->fast) {\n\t\t\tif (unlikely(kvm_read_guest(kvm, hc->ingpa, &send_ipi_ex,\n\t\t\t\t\t\t    sizeof(send_ipi_ex))))\n\t\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t} else {\n\t\t\tsend_ipi_ex.vector = (u32)hc->ingpa;\n\t\t\tsend_ipi_ex.vp_set.format = hc->outgpa;\n\t\t\tsend_ipi_ex.vp_set.valid_bank_mask = sse128_lo(hc->xmm[0]);\n\t\t}\n\n\t\ttrace_kvm_hv_send_ipi_ex(send_ipi_ex.vector,\n\t\t\t\t\t send_ipi_ex.vp_set.format,\n\t\t\t\t\t send_ipi_ex.vp_set.valid_bank_mask);\n\n\t\tvector = send_ipi_ex.vector;\n\t\tvalid_bank_mask = send_ipi_ex.vp_set.valid_bank_mask;\n\t\tall_cpus = send_ipi_ex.vp_set.format == HV_GENERIC_SET_ALL;\n\n\t\tif (hc->var_cnt != hweight64(valid_bank_mask))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t\tif (all_cpus)\n\t\t\tgoto check_and_send_ipi;\n\n\t\tif (!hc->var_cnt)\n\t\t\tgoto ret_success;\n\n\t\tif (!hc->fast)\n\t\t\thc->data_offset = offsetof(struct hv_send_ipi_ex,\n\t\t\t\t\t\t   vp_set.bank_contents);\n\t\telse\n\t\t\thc->consumed_xmm_halves = 1;\n\n\t\tif (kvm_get_sparse_vp_set(kvm, hc, sparse_banks))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t}\n\ncheck_and_send_ipi:\n\tif ((vector < HV_IPI_LOW_VECTOR) || (vector > HV_IPI_HIGH_VECTOR))\n\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\tif (all_cpus)\n\t\tkvm_hv_send_ipi_to_many(kvm, vector, NULL, 0);\n\telse\n\t\tkvm_hv_send_ipi_to_many(kvm, vector, sparse_banks, valid_bank_mask);\n\nret_success:\n\treturn HV_STATUS_SUCCESS;\n}\n\nvoid kvm_hv_set_cpuid(struct kvm_vcpu *vcpu, bool hyperv_enabled)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tstruct kvm_cpuid_entry2 *entry;\n\n\tvcpu->arch.hyperv_enabled = hyperv_enabled;\n\n\tif (!hv_vcpu) {\n\t\t \n\t\tWARN_ON_ONCE(vcpu->arch.hyperv_enabled);\n\t\treturn;\n\t}\n\n\tmemset(&hv_vcpu->cpuid_cache, 0, sizeof(hv_vcpu->cpuid_cache));\n\n\tif (!vcpu->arch.hyperv_enabled)\n\t\treturn;\n\n\tentry = kvm_find_cpuid_entry(vcpu, HYPERV_CPUID_FEATURES);\n\tif (entry) {\n\t\thv_vcpu->cpuid_cache.features_eax = entry->eax;\n\t\thv_vcpu->cpuid_cache.features_ebx = entry->ebx;\n\t\thv_vcpu->cpuid_cache.features_edx = entry->edx;\n\t}\n\n\tentry = kvm_find_cpuid_entry(vcpu, HYPERV_CPUID_ENLIGHTMENT_INFO);\n\tif (entry) {\n\t\thv_vcpu->cpuid_cache.enlightenments_eax = entry->eax;\n\t\thv_vcpu->cpuid_cache.enlightenments_ebx = entry->ebx;\n\t}\n\n\tentry = kvm_find_cpuid_entry(vcpu, HYPERV_CPUID_SYNDBG_PLATFORM_CAPABILITIES);\n\tif (entry)\n\t\thv_vcpu->cpuid_cache.syndbg_cap_eax = entry->eax;\n\n\tentry = kvm_find_cpuid_entry(vcpu, HYPERV_CPUID_NESTED_FEATURES);\n\tif (entry) {\n\t\thv_vcpu->cpuid_cache.nested_eax = entry->eax;\n\t\thv_vcpu->cpuid_cache.nested_ebx = entry->ebx;\n\t}\n}\n\nint kvm_hv_set_enforce_cpuid(struct kvm_vcpu *vcpu, bool enforce)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\tint ret = 0;\n\n\tif (!to_hv_vcpu(vcpu)) {\n\t\tif (enforce) {\n\t\t\tret = kvm_hv_vcpu_init(vcpu);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\thv_vcpu = to_hv_vcpu(vcpu);\n\thv_vcpu->enforce_cpuid = enforce;\n\n\treturn ret;\n}\n\nstatic void kvm_hv_hypercall_set_result(struct kvm_vcpu *vcpu, u64 result)\n{\n\tbool longmode;\n\n\tlongmode = is_64_bit_hypercall(vcpu);\n\tif (longmode)\n\t\tkvm_rax_write(vcpu, result);\n\telse {\n\t\tkvm_rdx_write(vcpu, result >> 32);\n\t\tkvm_rax_write(vcpu, result & 0xffffffff);\n\t}\n}\n\nstatic int kvm_hv_hypercall_complete(struct kvm_vcpu *vcpu, u64 result)\n{\n\tu32 tlb_lock_count = 0;\n\tint ret;\n\n\tif (hv_result_success(result) && is_guest_mode(vcpu) &&\n\t    kvm_hv_is_tlb_flush_hcall(vcpu) &&\n\t    kvm_read_guest(vcpu->kvm, to_hv_vcpu(vcpu)->nested.pa_page_gpa,\n\t\t\t   &tlb_lock_count, sizeof(tlb_lock_count)))\n\t\tresult = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\ttrace_kvm_hv_hypercall_done(result);\n\tkvm_hv_hypercall_set_result(vcpu, result);\n\t++vcpu->stat.hypercalls;\n\n\tret = kvm_skip_emulated_instruction(vcpu);\n\n\tif (tlb_lock_count)\n\t\tkvm_x86_ops.nested_ops->hv_inject_synthetic_vmexit_post_tlb_flush(vcpu);\n\n\treturn ret;\n}\n\nstatic int kvm_hv_hypercall_complete_userspace(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_hv_hypercall_complete(vcpu, vcpu->run->hyperv.u.hcall.result);\n}\n\nstatic u16 kvm_hvcall_signal_event(struct kvm_vcpu *vcpu, struct kvm_hv_hcall *hc)\n{\n\tstruct kvm_hv *hv = to_kvm_hv(vcpu->kvm);\n\tstruct eventfd_ctx *eventfd;\n\n\tif (unlikely(!hc->fast)) {\n\t\tint ret;\n\t\tgpa_t gpa = hc->ingpa;\n\n\t\tif ((gpa & (__alignof__(hc->ingpa) - 1)) ||\n\t\t    offset_in_page(gpa) + sizeof(hc->ingpa) > PAGE_SIZE)\n\t\t\treturn HV_STATUS_INVALID_ALIGNMENT;\n\n\t\tret = kvm_vcpu_read_guest(vcpu, gpa,\n\t\t\t\t\t  &hc->ingpa, sizeof(hc->ingpa));\n\t\tif (ret < 0)\n\t\t\treturn HV_STATUS_INVALID_ALIGNMENT;\n\t}\n\n\t \n\tif (hc->ingpa & 0xffff00000000ULL)\n\t\treturn HV_STATUS_INVALID_PORT_ID;\n\t \n\tif (hc->ingpa & ~KVM_HYPERV_CONN_ID_MASK)\n\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t \n\trcu_read_lock();\n\teventfd = idr_find(&hv->conn_to_evt, hc->ingpa);\n\trcu_read_unlock();\n\tif (!eventfd)\n\t\treturn HV_STATUS_INVALID_PORT_ID;\n\n\teventfd_signal(eventfd, 1);\n\treturn HV_STATUS_SUCCESS;\n}\n\nstatic bool is_xmm_fast_hypercall(struct kvm_hv_hcall *hc)\n{\n\tswitch (hc->code) {\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST:\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE:\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX:\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX:\n\tcase HVCALL_SEND_IPI_EX:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void kvm_hv_hypercall_read_xmm(struct kvm_hv_hcall *hc)\n{\n\tint reg;\n\n\tkvm_fpu_get();\n\tfor (reg = 0; reg < HV_HYPERCALL_MAX_XMM_REGISTERS; reg++)\n\t\t_kvm_read_sse_reg(reg, &hc->xmm[reg]);\n\tkvm_fpu_put();\n}\n\nstatic bool hv_check_hypercall_access(struct kvm_vcpu_hv *hv_vcpu, u16 code)\n{\n\tif (!hv_vcpu->enforce_cpuid)\n\t\treturn true;\n\n\tswitch (code) {\n\tcase HVCALL_NOTIFY_LONG_SPIN_WAIT:\n\t\treturn hv_vcpu->cpuid_cache.enlightenments_ebx &&\n\t\t\thv_vcpu->cpuid_cache.enlightenments_ebx != U32_MAX;\n\tcase HVCALL_POST_MESSAGE:\n\t\treturn hv_vcpu->cpuid_cache.features_ebx & HV_POST_MESSAGES;\n\tcase HVCALL_SIGNAL_EVENT:\n\t\treturn hv_vcpu->cpuid_cache.features_ebx & HV_SIGNAL_EVENTS;\n\tcase HVCALL_POST_DEBUG_DATA:\n\tcase HVCALL_RETRIEVE_DEBUG_DATA:\n\tcase HVCALL_RESET_DEBUG_SESSION:\n\t\t \n\t\treturn !kvm_hv_is_syndbg_enabled(hv_vcpu->vcpu) ||\n\t\t\thv_vcpu->cpuid_cache.features_ebx & HV_DEBUGGING;\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX:\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX:\n\t\tif (!(hv_vcpu->cpuid_cache.enlightenments_eax &\n\t\t      HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED))\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST:\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE:\n\t\treturn hv_vcpu->cpuid_cache.enlightenments_eax &\n\t\t\tHV_X64_REMOTE_TLB_FLUSH_RECOMMENDED;\n\tcase HVCALL_SEND_IPI_EX:\n\t\tif (!(hv_vcpu->cpuid_cache.enlightenments_eax &\n\t\t      HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED))\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase HVCALL_SEND_IPI:\n\t\treturn hv_vcpu->cpuid_cache.enlightenments_eax &\n\t\t\tHV_X64_CLUSTER_IPI_RECOMMENDED;\n\tcase HV_EXT_CALL_QUERY_CAPABILITIES ... HV_EXT_CALL_MAX:\n\t\treturn hv_vcpu->cpuid_cache.features_ebx &\n\t\t\tHV_ENABLE_EXTENDED_HYPERCALLS;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nint kvm_hv_hypercall(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tstruct kvm_hv_hcall hc;\n\tu64 ret = HV_STATUS_SUCCESS;\n\n\t \n\tif (static_call(kvm_x86_get_cpl)(vcpu) != 0 || !is_protmode(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n#ifdef CONFIG_X86_64\n\tif (is_64_bit_hypercall(vcpu)) {\n\t\thc.param = kvm_rcx_read(vcpu);\n\t\thc.ingpa = kvm_rdx_read(vcpu);\n\t\thc.outgpa = kvm_r8_read(vcpu);\n\t} else\n#endif\n\t{\n\t\thc.param = ((u64)kvm_rdx_read(vcpu) << 32) |\n\t\t\t    (kvm_rax_read(vcpu) & 0xffffffff);\n\t\thc.ingpa = ((u64)kvm_rbx_read(vcpu) << 32) |\n\t\t\t    (kvm_rcx_read(vcpu) & 0xffffffff);\n\t\thc.outgpa = ((u64)kvm_rdi_read(vcpu) << 32) |\n\t\t\t     (kvm_rsi_read(vcpu) & 0xffffffff);\n\t}\n\n\thc.code = hc.param & 0xffff;\n\thc.var_cnt = (hc.param & HV_HYPERCALL_VARHEAD_MASK) >> HV_HYPERCALL_VARHEAD_OFFSET;\n\thc.fast = !!(hc.param & HV_HYPERCALL_FAST_BIT);\n\thc.rep_cnt = (hc.param >> HV_HYPERCALL_REP_COMP_OFFSET) & 0xfff;\n\thc.rep_idx = (hc.param >> HV_HYPERCALL_REP_START_OFFSET) & 0xfff;\n\thc.rep = !!(hc.rep_cnt || hc.rep_idx);\n\n\ttrace_kvm_hv_hypercall(hc.code, hc.fast, hc.var_cnt, hc.rep_cnt,\n\t\t\t       hc.rep_idx, hc.ingpa, hc.outgpa);\n\n\tif (unlikely(!hv_check_hypercall_access(hv_vcpu, hc.code))) {\n\t\tret = HV_STATUS_ACCESS_DENIED;\n\t\tgoto hypercall_complete;\n\t}\n\n\tif (unlikely(hc.param & HV_HYPERCALL_RSVD_MASK)) {\n\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\tgoto hypercall_complete;\n\t}\n\n\tif (hc.fast && is_xmm_fast_hypercall(&hc)) {\n\t\tif (unlikely(hv_vcpu->enforce_cpuid &&\n\t\t\t     !(hv_vcpu->cpuid_cache.features_edx &\n\t\t\t       HV_X64_HYPERCALL_XMM_INPUT_AVAILABLE))) {\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\n\t\tkvm_hv_hypercall_read_xmm(&hc);\n\t}\n\n\tswitch (hc.code) {\n\tcase HVCALL_NOTIFY_LONG_SPIN_WAIT:\n\t\tif (unlikely(hc.rep || hc.var_cnt)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tkvm_vcpu_on_spin(vcpu, true);\n\t\tbreak;\n\tcase HVCALL_SIGNAL_EVENT:\n\t\tif (unlikely(hc.rep || hc.var_cnt)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_hvcall_signal_event(vcpu, &hc);\n\t\tif (ret != HV_STATUS_INVALID_PORT_ID)\n\t\t\tbreak;\n\t\tfallthrough;\t \n\tcase HVCALL_POST_MESSAGE:\n\t\t \n\t\tif (unlikely(hc.rep || hc.var_cnt || !to_hv_synic(vcpu)->active)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tgoto hypercall_userspace_exit;\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST:\n\t\tif (unlikely(hc.var_cnt)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX:\n\t\tif (unlikely(!hc.rep_cnt || hc.rep_idx)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_hv_flush_tlb(vcpu, &hc);\n\t\tbreak;\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE:\n\t\tif (unlikely(hc.var_cnt)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX:\n\t\tif (unlikely(hc.rep)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_hv_flush_tlb(vcpu, &hc);\n\t\tbreak;\n\tcase HVCALL_SEND_IPI:\n\t\tif (unlikely(hc.var_cnt)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase HVCALL_SEND_IPI_EX:\n\t\tif (unlikely(hc.rep)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_hv_send_ipi(vcpu, &hc);\n\t\tbreak;\n\tcase HVCALL_POST_DEBUG_DATA:\n\tcase HVCALL_RETRIEVE_DEBUG_DATA:\n\t\tif (unlikely(hc.fast)) {\n\t\t\tret = HV_STATUS_INVALID_PARAMETER;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase HVCALL_RESET_DEBUG_SESSION: {\n\t\tstruct kvm_hv_syndbg *syndbg = to_hv_syndbg(vcpu);\n\n\t\tif (!kvm_hv_is_syndbg_enabled(vcpu)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(syndbg->options & HV_X64_SYNDBG_OPTION_USE_HCALLS)) {\n\t\t\tret = HV_STATUS_OPERATION_DENIED;\n\t\t\tbreak;\n\t\t}\n\t\tgoto hypercall_userspace_exit;\n\t}\n\tcase HV_EXT_CALL_QUERY_CAPABILITIES ... HV_EXT_CALL_MAX:\n\t\tif (unlikely(hc.fast)) {\n\t\t\tret = HV_STATUS_INVALID_PARAMETER;\n\t\t\tbreak;\n\t\t}\n\t\tgoto hypercall_userspace_exit;\n\tdefault:\n\t\tret = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\tbreak;\n\t}\n\nhypercall_complete:\n\treturn kvm_hv_hypercall_complete(vcpu, ret);\n\nhypercall_userspace_exit:\n\tvcpu->run->exit_reason = KVM_EXIT_HYPERV;\n\tvcpu->run->hyperv.type = KVM_EXIT_HYPERV_HCALL;\n\tvcpu->run->hyperv.u.hcall.input = hc.param;\n\tvcpu->run->hyperv.u.hcall.params[0] = hc.ingpa;\n\tvcpu->run->hyperv.u.hcall.params[1] = hc.outgpa;\n\tvcpu->arch.complete_userspace_io = kvm_hv_hypercall_complete_userspace;\n\treturn 0;\n}\n\nvoid kvm_hv_init_vm(struct kvm *kvm)\n{\n\tstruct kvm_hv *hv = to_kvm_hv(kvm);\n\n\tmutex_init(&hv->hv_lock);\n\tidr_init(&hv->conn_to_evt);\n}\n\nvoid kvm_hv_destroy_vm(struct kvm *kvm)\n{\n\tstruct kvm_hv *hv = to_kvm_hv(kvm);\n\tstruct eventfd_ctx *eventfd;\n\tint i;\n\n\tidr_for_each_entry(&hv->conn_to_evt, eventfd, i)\n\t\teventfd_ctx_put(eventfd);\n\tidr_destroy(&hv->conn_to_evt);\n}\n\nstatic int kvm_hv_eventfd_assign(struct kvm *kvm, u32 conn_id, int fd)\n{\n\tstruct kvm_hv *hv = to_kvm_hv(kvm);\n\tstruct eventfd_ctx *eventfd;\n\tint ret;\n\n\teventfd = eventfd_ctx_fdget(fd);\n\tif (IS_ERR(eventfd))\n\t\treturn PTR_ERR(eventfd);\n\n\tmutex_lock(&hv->hv_lock);\n\tret = idr_alloc(&hv->conn_to_evt, eventfd, conn_id, conn_id + 1,\n\t\t\tGFP_KERNEL_ACCOUNT);\n\tmutex_unlock(&hv->hv_lock);\n\n\tif (ret >= 0)\n\t\treturn 0;\n\n\tif (ret == -ENOSPC)\n\t\tret = -EEXIST;\n\teventfd_ctx_put(eventfd);\n\treturn ret;\n}\n\nstatic int kvm_hv_eventfd_deassign(struct kvm *kvm, u32 conn_id)\n{\n\tstruct kvm_hv *hv = to_kvm_hv(kvm);\n\tstruct eventfd_ctx *eventfd;\n\n\tmutex_lock(&hv->hv_lock);\n\teventfd = idr_remove(&hv->conn_to_evt, conn_id);\n\tmutex_unlock(&hv->hv_lock);\n\n\tif (!eventfd)\n\t\treturn -ENOENT;\n\n\tsynchronize_srcu(&kvm->srcu);\n\teventfd_ctx_put(eventfd);\n\treturn 0;\n}\n\nint kvm_vm_ioctl_hv_eventfd(struct kvm *kvm, struct kvm_hyperv_eventfd *args)\n{\n\tif ((args->flags & ~KVM_HYPERV_EVENTFD_DEASSIGN) ||\n\t    (args->conn_id & ~KVM_HYPERV_CONN_ID_MASK))\n\t\treturn -EINVAL;\n\n\tif (args->flags == KVM_HYPERV_EVENTFD_DEASSIGN)\n\t\treturn kvm_hv_eventfd_deassign(kvm, args->conn_id);\n\treturn kvm_hv_eventfd_assign(kvm, args->conn_id, args->fd);\n}\n\nint kvm_get_hv_cpuid(struct kvm_vcpu *vcpu, struct kvm_cpuid2 *cpuid,\n\t\t     struct kvm_cpuid_entry2 __user *entries)\n{\n\tuint16_t evmcs_ver = 0;\n\tstruct kvm_cpuid_entry2 cpuid_entries[] = {\n\t\t{ .function = HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS },\n\t\t{ .function = HYPERV_CPUID_INTERFACE },\n\t\t{ .function = HYPERV_CPUID_VERSION },\n\t\t{ .function = HYPERV_CPUID_FEATURES },\n\t\t{ .function = HYPERV_CPUID_ENLIGHTMENT_INFO },\n\t\t{ .function = HYPERV_CPUID_IMPLEMENT_LIMITS },\n\t\t{ .function = HYPERV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS },\n\t\t{ .function = HYPERV_CPUID_SYNDBG_INTERFACE },\n\t\t{ .function = HYPERV_CPUID_SYNDBG_PLATFORM_CAPABILITIES\t},\n\t\t{ .function = HYPERV_CPUID_NESTED_FEATURES },\n\t};\n\tint i, nent = ARRAY_SIZE(cpuid_entries);\n\n\tif (kvm_x86_ops.nested_ops->get_evmcs_version)\n\t\tevmcs_ver = kvm_x86_ops.nested_ops->get_evmcs_version(vcpu);\n\n\tif (cpuid->nent < nent)\n\t\treturn -E2BIG;\n\n\tif (cpuid->nent > nent)\n\t\tcpuid->nent = nent;\n\n\tfor (i = 0; i < nent; i++) {\n\t\tstruct kvm_cpuid_entry2 *ent = &cpuid_entries[i];\n\t\tu32 signature[3];\n\n\t\tswitch (ent->function) {\n\t\tcase HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS:\n\t\t\tmemcpy(signature, \"Linux KVM Hv\", 12);\n\n\t\t\tent->eax = HYPERV_CPUID_SYNDBG_PLATFORM_CAPABILITIES;\n\t\t\tent->ebx = signature[0];\n\t\t\tent->ecx = signature[1];\n\t\t\tent->edx = signature[2];\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_INTERFACE:\n\t\t\tent->eax = HYPERV_CPUID_SIGNATURE_EAX;\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_VERSION:\n\t\t\t \n\t\t\tent->eax = 0x00003839;\n\t\t\tent->ebx = 0x000A0000;\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_FEATURES:\n\t\t\tent->eax |= HV_MSR_VP_RUNTIME_AVAILABLE;\n\t\t\tent->eax |= HV_MSR_TIME_REF_COUNT_AVAILABLE;\n\t\t\tent->eax |= HV_MSR_SYNIC_AVAILABLE;\n\t\t\tent->eax |= HV_MSR_SYNTIMER_AVAILABLE;\n\t\t\tent->eax |= HV_MSR_APIC_ACCESS_AVAILABLE;\n\t\t\tent->eax |= HV_MSR_HYPERCALL_AVAILABLE;\n\t\t\tent->eax |= HV_MSR_VP_INDEX_AVAILABLE;\n\t\t\tent->eax |= HV_MSR_RESET_AVAILABLE;\n\t\t\tent->eax |= HV_MSR_REFERENCE_TSC_AVAILABLE;\n\t\t\tent->eax |= HV_ACCESS_FREQUENCY_MSRS;\n\t\t\tent->eax |= HV_ACCESS_REENLIGHTENMENT;\n\t\t\tent->eax |= HV_ACCESS_TSC_INVARIANT;\n\n\t\t\tent->ebx |= HV_POST_MESSAGES;\n\t\t\tent->ebx |= HV_SIGNAL_EVENTS;\n\t\t\tent->ebx |= HV_ENABLE_EXTENDED_HYPERCALLS;\n\n\t\t\tent->edx |= HV_X64_HYPERCALL_XMM_INPUT_AVAILABLE;\n\t\t\tent->edx |= HV_FEATURE_FREQUENCY_MSRS_AVAILABLE;\n\t\t\tent->edx |= HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE;\n\n\t\t\tent->ebx |= HV_DEBUGGING;\n\t\t\tent->edx |= HV_X64_GUEST_DEBUGGING_AVAILABLE;\n\t\t\tent->edx |= HV_FEATURE_DEBUG_MSRS_AVAILABLE;\n\t\t\tent->edx |= HV_FEATURE_EXT_GVA_RANGES_FLUSH;\n\n\t\t\t \n\t\t\tif (!vcpu || lapic_in_kernel(vcpu))\n\t\t\t\tent->edx |= HV_STIMER_DIRECT_MODE_AVAILABLE;\n\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_ENLIGHTMENT_INFO:\n\t\t\tent->eax |= HV_X64_REMOTE_TLB_FLUSH_RECOMMENDED;\n\t\t\tent->eax |= HV_X64_APIC_ACCESS_RECOMMENDED;\n\t\t\tent->eax |= HV_X64_RELAXED_TIMING_RECOMMENDED;\n\t\t\tent->eax |= HV_X64_CLUSTER_IPI_RECOMMENDED;\n\t\t\tent->eax |= HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED;\n\t\t\tif (evmcs_ver)\n\t\t\t\tent->eax |= HV_X64_ENLIGHTENED_VMCS_RECOMMENDED;\n\t\t\tif (!cpu_smt_possible())\n\t\t\t\tent->eax |= HV_X64_NO_NONARCH_CORESHARING;\n\n\t\t\tent->eax |= HV_DEPRECATING_AEOI_RECOMMENDED;\n\t\t\t \n\t\t\tent->ebx = 0x00000FFF;\n\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_IMPLEMENT_LIMITS:\n\t\t\t \n\t\t\tent->eax = KVM_MAX_VCPUS;\n\t\t\t \n\t\t\tent->ebx = 64;\n\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_NESTED_FEATURES:\n\t\t\tent->eax = evmcs_ver;\n\t\t\tent->eax |= HV_X64_NESTED_DIRECT_FLUSH;\n\t\t\tent->eax |= HV_X64_NESTED_MSR_BITMAP;\n\t\t\tent->ebx |= HV_X64_NESTED_EVMCS1_PERF_GLOBAL_CTRL;\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS:\n\t\t\tmemcpy(signature, \"Linux KVM Hv\", 12);\n\n\t\t\tent->eax = 0;\n\t\t\tent->ebx = signature[0];\n\t\t\tent->ecx = signature[1];\n\t\t\tent->edx = signature[2];\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_SYNDBG_INTERFACE:\n\t\t\tmemcpy(signature, \"VS#1\\0\\0\\0\\0\\0\\0\\0\\0\", 12);\n\t\t\tent->eax = signature[0];\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_SYNDBG_PLATFORM_CAPABILITIES:\n\t\t\tent->eax |= HV_X64_SYNDBG_CAP_ALLOW_KERNEL_DEBUGGING;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (copy_to_user(entries, cpuid_entries,\n\t\t\t nent * sizeof(struct kvm_cpuid_entry2)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}