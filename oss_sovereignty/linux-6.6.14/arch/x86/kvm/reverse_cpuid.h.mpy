{
  "module_name": "reverse_cpuid.h",
  "hash_id": "ecb6832cefadb0b1ed26ef07bdb32d0cce5cb5c7d98e7ce31e8b53afffd47151",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/reverse_cpuid.h",
  "human_readable_source": " \n#ifndef ARCH_X86_KVM_REVERSE_CPUID_H\n#define ARCH_X86_KVM_REVERSE_CPUID_H\n\n#include <uapi/asm/kvm.h>\n#include <asm/cpufeature.h>\n#include <asm/cpufeatures.h>\n\n \nenum kvm_only_cpuid_leafs {\n\tCPUID_12_EAX\t = NCAPINTS,\n\tCPUID_7_1_EDX,\n\tCPUID_8000_0007_EDX,\n\tCPUID_8000_0022_EAX,\n\tNR_KVM_CPU_CAPS,\n\n\tNKVMCAPINTS = NR_KVM_CPU_CAPS - NCAPINTS,\n};\n\n \n#define KVM_X86_FEATURE(w, f)\t\t((w)*32 + (f))\n\n \n#define KVM_X86_FEATURE_SGX1\t\tKVM_X86_FEATURE(CPUID_12_EAX, 0)\n#define KVM_X86_FEATURE_SGX2\t\tKVM_X86_FEATURE(CPUID_12_EAX, 1)\n#define KVM_X86_FEATURE_SGX_EDECCSSA\tKVM_X86_FEATURE(CPUID_12_EAX, 11)\n\n \n#define X86_FEATURE_AVX_VNNI_INT8       KVM_X86_FEATURE(CPUID_7_1_EDX, 4)\n#define X86_FEATURE_AVX_NE_CONVERT      KVM_X86_FEATURE(CPUID_7_1_EDX, 5)\n#define X86_FEATURE_AMX_COMPLEX         KVM_X86_FEATURE(CPUID_7_1_EDX, 8)\n#define X86_FEATURE_PREFETCHITI         KVM_X86_FEATURE(CPUID_7_1_EDX, 14)\n\n \n#define KVM_X86_FEATURE_CONSTANT_TSC\tKVM_X86_FEATURE(CPUID_8000_0007_EDX, 8)\n\n \n#define KVM_X86_FEATURE_PERFMON_V2\tKVM_X86_FEATURE(CPUID_8000_0022_EAX, 0)\n\nstruct cpuid_reg {\n\tu32 function;\n\tu32 index;\n\tint reg;\n};\n\nstatic const struct cpuid_reg reverse_cpuid[] = {\n\t[CPUID_1_EDX]         = {         1, 0, CPUID_EDX},\n\t[CPUID_8000_0001_EDX] = {0x80000001, 0, CPUID_EDX},\n\t[CPUID_8086_0001_EDX] = {0x80860001, 0, CPUID_EDX},\n\t[CPUID_1_ECX]         = {         1, 0, CPUID_ECX},\n\t[CPUID_C000_0001_EDX] = {0xc0000001, 0, CPUID_EDX},\n\t[CPUID_8000_0001_ECX] = {0x80000001, 0, CPUID_ECX},\n\t[CPUID_7_0_EBX]       = {         7, 0, CPUID_EBX},\n\t[CPUID_D_1_EAX]       = {       0xd, 1, CPUID_EAX},\n\t[CPUID_8000_0008_EBX] = {0x80000008, 0, CPUID_EBX},\n\t[CPUID_6_EAX]         = {         6, 0, CPUID_EAX},\n\t[CPUID_8000_000A_EDX] = {0x8000000a, 0, CPUID_EDX},\n\t[CPUID_7_ECX]         = {         7, 0, CPUID_ECX},\n\t[CPUID_8000_0007_EBX] = {0x80000007, 0, CPUID_EBX},\n\t[CPUID_7_EDX]         = {         7, 0, CPUID_EDX},\n\t[CPUID_7_1_EAX]       = {         7, 1, CPUID_EAX},\n\t[CPUID_12_EAX]        = {0x00000012, 0, CPUID_EAX},\n\t[CPUID_8000_001F_EAX] = {0x8000001f, 0, CPUID_EAX},\n\t[CPUID_7_1_EDX]       = {         7, 1, CPUID_EDX},\n\t[CPUID_8000_0007_EDX] = {0x80000007, 0, CPUID_EDX},\n\t[CPUID_8000_0021_EAX] = {0x80000021, 0, CPUID_EAX},\n\t[CPUID_8000_0022_EAX] = {0x80000022, 0, CPUID_EAX},\n};\n\n \nstatic __always_inline void reverse_cpuid_check(unsigned int x86_leaf)\n{\n\tBUILD_BUG_ON(x86_leaf == CPUID_LNX_1);\n\tBUILD_BUG_ON(x86_leaf == CPUID_LNX_2);\n\tBUILD_BUG_ON(x86_leaf == CPUID_LNX_3);\n\tBUILD_BUG_ON(x86_leaf == CPUID_LNX_4);\n\tBUILD_BUG_ON(x86_leaf >= ARRAY_SIZE(reverse_cpuid));\n\tBUILD_BUG_ON(reverse_cpuid[x86_leaf].function == 0);\n}\n\n \nstatic __always_inline u32 __feature_translate(int x86_feature)\n{\n\tif (x86_feature == X86_FEATURE_SGX1)\n\t\treturn KVM_X86_FEATURE_SGX1;\n\telse if (x86_feature == X86_FEATURE_SGX2)\n\t\treturn KVM_X86_FEATURE_SGX2;\n\telse if (x86_feature == X86_FEATURE_SGX_EDECCSSA)\n\t\treturn KVM_X86_FEATURE_SGX_EDECCSSA;\n\telse if (x86_feature == X86_FEATURE_CONSTANT_TSC)\n\t\treturn KVM_X86_FEATURE_CONSTANT_TSC;\n\telse if (x86_feature == X86_FEATURE_PERFMON_V2)\n\t\treturn KVM_X86_FEATURE_PERFMON_V2;\n\n\treturn x86_feature;\n}\n\nstatic __always_inline u32 __feature_leaf(int x86_feature)\n{\n\treturn __feature_translate(x86_feature) / 32;\n}\n\n \nstatic __always_inline u32 __feature_bit(int x86_feature)\n{\n\tx86_feature = __feature_translate(x86_feature);\n\n\treverse_cpuid_check(x86_feature / 32);\n\treturn 1 << (x86_feature & 31);\n}\n\n#define feature_bit(name)  __feature_bit(X86_FEATURE_##name)\n\nstatic __always_inline struct cpuid_reg x86_feature_cpuid(unsigned int x86_feature)\n{\n\tunsigned int x86_leaf = __feature_leaf(x86_feature);\n\n\treverse_cpuid_check(x86_leaf);\n\treturn reverse_cpuid[x86_leaf];\n}\n\nstatic __always_inline u32 *__cpuid_entry_get_reg(struct kvm_cpuid_entry2 *entry,\n\t\t\t\t\t\t  u32 reg)\n{\n\tswitch (reg) {\n\tcase CPUID_EAX:\n\t\treturn &entry->eax;\n\tcase CPUID_EBX:\n\t\treturn &entry->ebx;\n\tcase CPUID_ECX:\n\t\treturn &entry->ecx;\n\tcase CPUID_EDX:\n\t\treturn &entry->edx;\n\tdefault:\n\t\tBUILD_BUG();\n\t\treturn NULL;\n\t}\n}\n\nstatic __always_inline u32 *cpuid_entry_get_reg(struct kvm_cpuid_entry2 *entry,\n\t\t\t\t\t\tunsigned int x86_feature)\n{\n\tconst struct cpuid_reg cpuid = x86_feature_cpuid(x86_feature);\n\n\treturn __cpuid_entry_get_reg(entry, cpuid.reg);\n}\n\nstatic __always_inline u32 cpuid_entry_get(struct kvm_cpuid_entry2 *entry,\n\t\t\t\t\t   unsigned int x86_feature)\n{\n\tu32 *reg = cpuid_entry_get_reg(entry, x86_feature);\n\n\treturn *reg & __feature_bit(x86_feature);\n}\n\nstatic __always_inline bool cpuid_entry_has(struct kvm_cpuid_entry2 *entry,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\treturn cpuid_entry_get(entry, x86_feature);\n}\n\nstatic __always_inline void cpuid_entry_clear(struct kvm_cpuid_entry2 *entry,\n\t\t\t\t\t      unsigned int x86_feature)\n{\n\tu32 *reg = cpuid_entry_get_reg(entry, x86_feature);\n\n\t*reg &= ~__feature_bit(x86_feature);\n}\n\nstatic __always_inline void cpuid_entry_set(struct kvm_cpuid_entry2 *entry,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg = cpuid_entry_get_reg(entry, x86_feature);\n\n\t*reg |= __feature_bit(x86_feature);\n}\n\nstatic __always_inline void cpuid_entry_change(struct kvm_cpuid_entry2 *entry,\n\t\t\t\t\t       unsigned int x86_feature,\n\t\t\t\t\t       bool set)\n{\n\tu32 *reg = cpuid_entry_get_reg(entry, x86_feature);\n\n\t \n\tif (set)\n\t\t*reg |= __feature_bit(x86_feature);\n\telse\n\t\t*reg &= ~__feature_bit(x86_feature);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}