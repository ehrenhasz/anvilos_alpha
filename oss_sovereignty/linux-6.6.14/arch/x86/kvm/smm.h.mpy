{
  "module_name": "smm.h",
  "hash_id": "2f396027a18f8b895abd9fff9bbf6d3ccb19dd067f90bd8b796e424f8d8a0252",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/smm.h",
  "human_readable_source": " \n#ifndef ASM_KVM_SMM_H\n#define ASM_KVM_SMM_H\n\n#include <linux/build_bug.h>\n\n#ifdef CONFIG_KVM_SMM\n\n\n \n\nstruct kvm_smm_seg_state_32 {\n\tu32 flags;\n\tu32 limit;\n\tu32 base;\n} __packed;\n\nstruct kvm_smram_state_32 {\n\tu32 reserved1[62];\n\tu32 smbase;\n\tu32 smm_revision;\n\tu16 io_inst_restart;\n\tu16 auto_hlt_restart;\n\tu32 io_restart_rdi;\n\tu32 io_restart_rcx;\n\tu32 io_restart_rsi;\n\tu32 io_restart_rip;\n\tu32 cr4;\n\n\t \n\tu16 reserved2;\n\tu8 int_shadow;  \n\tu8 reserved3[17];\n\n\tstruct kvm_smm_seg_state_32 ds;\n\tstruct kvm_smm_seg_state_32 fs;\n\tstruct kvm_smm_seg_state_32 gs;\n\tstruct kvm_smm_seg_state_32 idtr;  \n\tstruct kvm_smm_seg_state_32 tr;\n\tu32 reserved;\n\tstruct kvm_smm_seg_state_32 gdtr;  \n\tstruct kvm_smm_seg_state_32 ldtr;\n\tstruct kvm_smm_seg_state_32 es;\n\tstruct kvm_smm_seg_state_32 cs;\n\tstruct kvm_smm_seg_state_32 ss;\n\n\tu32 es_sel;\n\tu32 cs_sel;\n\tu32 ss_sel;\n\tu32 ds_sel;\n\tu32 fs_sel;\n\tu32 gs_sel;\n\tu32 ldtr_sel;\n\tu32 tr_sel;\n\n\tu32 dr7;\n\tu32 dr6;\n\tu32 gprs[8];  \n\tu32 eip;\n\tu32 eflags;\n\tu32 cr3;\n\tu32 cr0;\n} __packed;\n\n\n \n\nstruct kvm_smm_seg_state_64 {\n\tu16 selector;\n\tu16 attributes;\n\tu32 limit;\n\tu64 base;\n};\n\nstruct kvm_smram_state_64 {\n\n\tstruct kvm_smm_seg_state_64 es;\n\tstruct kvm_smm_seg_state_64 cs;\n\tstruct kvm_smm_seg_state_64 ss;\n\tstruct kvm_smm_seg_state_64 ds;\n\tstruct kvm_smm_seg_state_64 fs;\n\tstruct kvm_smm_seg_state_64 gs;\n\tstruct kvm_smm_seg_state_64 gdtr;  \n\tstruct kvm_smm_seg_state_64 ldtr;\n\tstruct kvm_smm_seg_state_64 idtr;  \n\tstruct kvm_smm_seg_state_64 tr;\n\n\t \n\tu64 io_restart_rip;\n\tu64 io_restart_rcx;\n\tu64 io_restart_rsi;\n\tu64 io_restart_rdi;\n\tu32 io_restart_dword;\n\tu32 reserved1;\n\tu8 io_inst_restart;\n\tu8 auto_hlt_restart;\n\tu8 amd_nmi_mask;  \n\tu8 int_shadow;\n\tu32 reserved2;\n\n\tu64 efer;\n\n\t \n\tu64 svm_guest_flag;\n\tu64 svm_guest_vmcb_gpa;\n\tu64 svm_guest_virtual_int;  \n\n\tu32 reserved3[3];\n\tu32 smm_revison;\n\tu32 smbase;\n\tu32 reserved4[5];\n\n\t \n\tu64 ssp;\n\tu64 svm_guest_pat;\n\tu64 svm_host_efer;\n\tu64 svm_host_cr4;\n\tu64 svm_host_cr3;\n\tu64 svm_host_cr0;\n\n\tu64 cr4;\n\tu64 cr3;\n\tu64 cr0;\n\tu64 dr7;\n\tu64 dr6;\n\tu64 rflags;\n\tu64 rip;\n\tu64 gprs[16];  \n};\n\nunion kvm_smram {\n\tstruct kvm_smram_state_64 smram64;\n\tstruct kvm_smram_state_32 smram32;\n\tu8 bytes[512];\n};\n\nstatic inline int kvm_inject_smi(struct kvm_vcpu *vcpu)\n{\n\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\treturn 0;\n}\n\nstatic inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}\n\nvoid kvm_smm_changed(struct kvm_vcpu *vcpu, bool in_smm);\nvoid enter_smm(struct kvm_vcpu *vcpu);\nint emulator_leave_smm(struct x86_emulate_ctxt *ctxt);\nvoid process_smi(struct kvm_vcpu *vcpu);\n#else\nstatic inline int kvm_inject_smi(struct kvm_vcpu *vcpu) { return -ENOTTY; }\nstatic inline bool is_smm(struct kvm_vcpu *vcpu) { return false; }\n\n \n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}