{
  "module_name": "pmu.h",
  "hash_id": "bc1088e1980d113b9b94c8009304946ff67fde0ae277460afde7e5b5d9d83728",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/kvm/pmu.h",
  "human_readable_source": " \n#ifndef __KVM_X86_PMU_H\n#define __KVM_X86_PMU_H\n\n#include <linux/nospec.h>\n\n#define vcpu_to_pmu(vcpu) (&(vcpu)->arch.pmu)\n#define pmu_to_vcpu(pmu)  (container_of((pmu), struct kvm_vcpu, arch.pmu))\n#define pmc_to_pmu(pmc)   (&(pmc)->vcpu->arch.pmu)\n\n#define MSR_IA32_MISC_ENABLE_PMU_RO_MASK (MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL |\t\\\n\t\t\t\t\t  MSR_IA32_MISC_ENABLE_BTS_UNAVAIL)\n\n \n#define fixed_ctrl_field(ctrl_reg, idx) (((ctrl_reg) >> ((idx)*4)) & 0xf)\n\n#define VMWARE_BACKDOOR_PMC_HOST_TSC\t\t0x10000\n#define VMWARE_BACKDOOR_PMC_REAL_TIME\t\t0x10001\n#define VMWARE_BACKDOOR_PMC_APPARENT_TIME\t0x10002\n\nstruct kvm_pmu_ops {\n\tbool (*hw_event_available)(struct kvm_pmc *pmc);\n\tstruct kvm_pmc *(*pmc_idx_to_pmc)(struct kvm_pmu *pmu, int pmc_idx);\n\tstruct kvm_pmc *(*rdpmc_ecx_to_pmc)(struct kvm_vcpu *vcpu,\n\t\tunsigned int idx, u64 *mask);\n\tstruct kvm_pmc *(*msr_idx_to_pmc)(struct kvm_vcpu *vcpu, u32 msr);\n\tbool (*is_valid_rdpmc_ecx)(struct kvm_vcpu *vcpu, unsigned int idx);\n\tbool (*is_valid_msr)(struct kvm_vcpu *vcpu, u32 msr);\n\tint (*get_msr)(struct kvm_vcpu *vcpu, struct msr_data *msr_info);\n\tint (*set_msr)(struct kvm_vcpu *vcpu, struct msr_data *msr_info);\n\tvoid (*refresh)(struct kvm_vcpu *vcpu);\n\tvoid (*init)(struct kvm_vcpu *vcpu);\n\tvoid (*reset)(struct kvm_vcpu *vcpu);\n\tvoid (*deliver_pmi)(struct kvm_vcpu *vcpu);\n\tvoid (*cleanup)(struct kvm_vcpu *vcpu);\n\n\tconst u64 EVENTSEL_EVENT;\n\tconst int MAX_NR_GP_COUNTERS;\n\tconst int MIN_NR_GP_COUNTERS;\n};\n\nvoid kvm_pmu_ops_update(const struct kvm_pmu_ops *pmu_ops);\n\nstatic inline bool kvm_pmu_has_perf_global_ctrl(struct kvm_pmu *pmu)\n{\n\t \n\treturn pmu->version > 1;\n}\n\nstatic inline u64 pmc_bitmask(struct kvm_pmc *pmc)\n{\n\tstruct kvm_pmu *pmu = pmc_to_pmu(pmc);\n\n\treturn pmu->counter_bitmask[pmc->type];\n}\n\nstatic inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event && !pmc->is_paused)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t \n\treturn counter & pmc_bitmask(pmc);\n}\n\nstatic inline void pmc_write_counter(struct kvm_pmc *pmc, u64 val)\n{\n\tpmc->counter += val - pmc_read_counter(pmc);\n\tpmc->counter &= pmc_bitmask(pmc);\n}\n\nstatic inline bool pmc_is_gp(struct kvm_pmc *pmc)\n{\n\treturn pmc->type == KVM_PMC_GP;\n}\n\nstatic inline bool pmc_is_fixed(struct kvm_pmc *pmc)\n{\n\treturn pmc->type == KVM_PMC_FIXED;\n}\n\nstatic inline bool kvm_valid_perf_global_ctrl(struct kvm_pmu *pmu,\n\t\t\t\t\t\t u64 data)\n{\n\treturn !(pmu->global_ctrl_mask & data);\n}\n\n \nstatic inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_gp_counters);\n\n\t\treturn &pmu->gp_counters[index];\n\t}\n\n\treturn NULL;\n}\n\n \nstatic inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_fixed_counters);\n\n\t\treturn &pmu->fixed_counters[index];\n\t}\n\n\treturn NULL;\n}\n\nstatic inline u64 get_sample_period(struct kvm_pmc *pmc, u64 counter_value)\n{\n\tu64 sample_period = (-counter_value) & pmc_bitmask(pmc);\n\n\tif (!sample_period)\n\t\tsample_period = pmc_bitmask(pmc) + 1;\n\treturn sample_period;\n}\n\nstatic inline void pmc_update_sample_period(struct kvm_pmc *pmc)\n{\n\tif (!pmc->perf_event || pmc->is_paused ||\n\t    !is_sampling_event(pmc->perf_event))\n\t\treturn;\n\n\tperf_event_period(pmc->perf_event,\n\t\t\t  get_sample_period(pmc, pmc->counter));\n}\n\nstatic inline bool pmc_speculative_in_use(struct kvm_pmc *pmc)\n{\n\tstruct kvm_pmu *pmu = pmc_to_pmu(pmc);\n\n\tif (pmc_is_fixed(pmc))\n\t\treturn fixed_ctrl_field(pmu->fixed_ctr_ctrl,\n\t\t\t\t\tpmc->idx - INTEL_PMC_IDX_FIXED) & 0x3;\n\n\treturn pmc->eventsel & ARCH_PERFMON_EVENTSEL_ENABLE;\n}\n\nextern struct x86_pmu_capability kvm_pmu_cap;\n\nstatic inline void kvm_init_pmu_capability(const struct kvm_pmu_ops *pmu_ops)\n{\n\tbool is_intel = boot_cpu_data.x86_vendor == X86_VENDOR_INTEL;\n\tint min_nr_gp_ctrs = pmu_ops->MIN_NR_GP_COUNTERS;\n\n\t \n\tif (cpu_feature_enabled(X86_FEATURE_HYBRID_CPU))\n\t\tenable_pmu = false;\n\n\tif (enable_pmu) {\n\t\tperf_get_x86_pmu_capability(&kvm_pmu_cap);\n\n\t\t \n\t\tif (!kvm_pmu_cap.num_counters_gp ||\n\t\t    WARN_ON_ONCE(kvm_pmu_cap.num_counters_gp < min_nr_gp_ctrs))\n\t\t\tenable_pmu = false;\n\t\telse if (is_intel && !kvm_pmu_cap.version)\n\t\t\tenable_pmu = false;\n\t}\n\n\tif (!enable_pmu) {\n\t\tmemset(&kvm_pmu_cap, 0, sizeof(kvm_pmu_cap));\n\t\treturn;\n\t}\n\n\tkvm_pmu_cap.version = min(kvm_pmu_cap.version, 2);\n\tkvm_pmu_cap.num_counters_gp = min(kvm_pmu_cap.num_counters_gp,\n\t\t\t\t\t  pmu_ops->MAX_NR_GP_COUNTERS);\n\tkvm_pmu_cap.num_counters_fixed = min(kvm_pmu_cap.num_counters_fixed,\n\t\t\t\t\t     KVM_PMC_MAX_FIXED);\n}\n\nstatic inline void kvm_pmu_request_counter_reprogram(struct kvm_pmc *pmc)\n{\n\tset_bit(pmc->idx, pmc_to_pmu(pmc)->reprogram_pmi);\n\tkvm_make_request(KVM_REQ_PMU, pmc->vcpu);\n}\n\nstatic inline void reprogram_counters(struct kvm_pmu *pmu, u64 diff)\n{\n\tint bit;\n\n\tif (!diff)\n\t\treturn;\n\n\tfor_each_set_bit(bit, (unsigned long *)&diff, X86_PMC_IDX_MAX)\n\t\tset_bit(bit, pmu->reprogram_pmi);\n\tkvm_make_request(KVM_REQ_PMU, pmu_to_vcpu(pmu));\n}\n\n \nstatic inline bool pmc_is_globally_enabled(struct kvm_pmc *pmc)\n{\n\tstruct kvm_pmu *pmu = pmc_to_pmu(pmc);\n\n\tif (!kvm_pmu_has_perf_global_ctrl(pmu))\n\t\treturn true;\n\n\treturn test_bit(pmc->idx, (unsigned long *)&pmu->global_ctrl);\n}\n\nvoid kvm_pmu_deliver_pmi(struct kvm_vcpu *vcpu);\nvoid kvm_pmu_handle_event(struct kvm_vcpu *vcpu);\nint kvm_pmu_rdpmc(struct kvm_vcpu *vcpu, unsigned pmc, u64 *data);\nbool kvm_pmu_is_valid_rdpmc_ecx(struct kvm_vcpu *vcpu, unsigned int idx);\nbool kvm_pmu_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr);\nint kvm_pmu_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info);\nint kvm_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info);\nvoid kvm_pmu_refresh(struct kvm_vcpu *vcpu);\nvoid kvm_pmu_reset(struct kvm_vcpu *vcpu);\nvoid kvm_pmu_init(struct kvm_vcpu *vcpu);\nvoid kvm_pmu_cleanup(struct kvm_vcpu *vcpu);\nvoid kvm_pmu_destroy(struct kvm_vcpu *vcpu);\nint kvm_vm_ioctl_set_pmu_event_filter(struct kvm *kvm, void __user *argp);\nvoid kvm_pmu_trigger_event(struct kvm_vcpu *vcpu, u64 perf_hw_id);\n\nbool is_vmware_backdoor_pmc(u32 pmc_idx);\n\nextern struct kvm_pmu_ops intel_pmu_ops;\nextern struct kvm_pmu_ops amd_pmu_ops;\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}