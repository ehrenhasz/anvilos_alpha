{
  "module_name": "hibernate_64.c",
  "hash_id": "401f80f8329337ebe1c44d5e70087f62223b8e14cd79fecf8d4d8e58d3e9701b",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/power/hibernate_64.c",
  "human_readable_source": "\n \n\n#include <linux/gfp.h>\n#include <linux/smp.h>\n#include <linux/suspend.h>\n#include <linux/scatterlist.h>\n#include <linux/kdebug.h>\n#include <linux/pgtable.h>\n\n#include <crypto/hash.h>\n\n#include <asm/e820/api.h>\n#include <asm/init.h>\n#include <asm/proto.h>\n#include <asm/page.h>\n#include <asm/mtrr.h>\n#include <asm/sections.h>\n#include <asm/suspend.h>\n#include <asm/tlbflush.h>\n\nstatic int set_up_temporary_text_mapping(pgd_t *pgd)\n{\n\tpmd_t *pmd;\n\tpud_t *pud;\n\tp4d_t *p4d = NULL;\n\tpgprot_t pgtable_prot = __pgprot(_KERNPG_TABLE);\n\tpgprot_t pmd_text_prot = __pgprot(__PAGE_KERNEL_LARGE_EXEC);\n\n\t \n\tpgprot_val(pmd_text_prot) &= __default_kernel_pte_mask;\n\tpgprot_val(pgtable_prot)  &= __default_kernel_pte_mask;\n\n\t \n\n\tif (pgtable_l5_enabled()) {\n\t\tp4d = (p4d_t *)get_safe_page(GFP_ATOMIC);\n\t\tif (!p4d)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tpud = (pud_t *)get_safe_page(GFP_ATOMIC);\n\tif (!pud)\n\t\treturn -ENOMEM;\n\n\tpmd = (pmd_t *)get_safe_page(GFP_ATOMIC);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\n\tset_pmd(pmd + pmd_index(restore_jump_address),\n\t\t__pmd((jump_address_phys & PMD_MASK) | pgprot_val(pmd_text_prot)));\n\tset_pud(pud + pud_index(restore_jump_address),\n\t\t__pud(__pa(pmd) | pgprot_val(pgtable_prot)));\n\tif (p4d) {\n\t\tp4d_t new_p4d = __p4d(__pa(pud) | pgprot_val(pgtable_prot));\n\t\tpgd_t new_pgd = __pgd(__pa(p4d) | pgprot_val(pgtable_prot));\n\n\t\tset_p4d(p4d + p4d_index(restore_jump_address), new_p4d);\n\t\tset_pgd(pgd + pgd_index(restore_jump_address), new_pgd);\n\t} else {\n\t\t \n\t\tpgd_t new_pgd = __pgd(__pa(pud) | pgprot_val(pgtable_prot));\n\t\tset_pgd(pgd + pgd_index(restore_jump_address), new_pgd);\n\t}\n\n\treturn 0;\n}\n\nstatic void *alloc_pgt_page(void *context)\n{\n\treturn (void *)get_safe_page(GFP_ATOMIC);\n}\n\nstatic int set_up_temporary_mappings(void)\n{\n\tstruct x86_mapping_info info = {\n\t\t.alloc_pgt_page\t= alloc_pgt_page,\n\t\t.page_flag\t= __PAGE_KERNEL_LARGE_EXEC,\n\t\t.offset\t\t= __PAGE_OFFSET,\n\t};\n\tunsigned long mstart, mend;\n\tpgd_t *pgd;\n\tint result;\n\tint i;\n\n\tpgd = (pgd_t *)get_safe_page(GFP_ATOMIC);\n\tif (!pgd)\n\t\treturn -ENOMEM;\n\n\t \n\tresult = set_up_temporary_text_mapping(pgd);\n\tif (result)\n\t\treturn result;\n\n\t \n\tfor (i = 0; i < nr_pfn_mapped; i++) {\n\t\tmstart = pfn_mapped[i].start << PAGE_SHIFT;\n\t\tmend   = pfn_mapped[i].end << PAGE_SHIFT;\n\n\t\tresult = kernel_ident_mapping_init(&info, pgd, mstart, mend);\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\ttemp_pgt = __pa(pgd);\n\treturn 0;\n}\n\nasmlinkage int swsusp_arch_resume(void)\n{\n\tint error;\n\n\t \n\terror = set_up_temporary_mappings();\n\tif (error)\n\t\treturn error;\n\n\terror = relocate_restore_code();\n\tif (error)\n\t\treturn error;\n\n\trestore_image();\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}