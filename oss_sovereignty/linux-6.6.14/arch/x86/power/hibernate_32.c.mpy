{
  "module_name": "hibernate_32.c",
  "hash_id": "b76728b39d62e26342f08b2cf897c0f86e13c75f0c7e9fb0eb13294872aede78",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/power/hibernate_32.c",
  "human_readable_source": "\n \n\n#include <linux/gfp.h>\n#include <linux/suspend.h>\n#include <linux/memblock.h>\n#include <linux/pgtable.h>\n\n#include <asm/page.h>\n#include <asm/mmzone.h>\n#include <asm/sections.h>\n#include <asm/suspend.h>\n\n \npgd_t *resume_pg_dir;\n\n \n\n \nstatic pmd_t *resume_one_md_table_init(pgd_t *pgd)\n{\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd_table;\n\n#ifdef CONFIG_X86_PAE\n\tpmd_table = (pmd_t *)get_safe_page(GFP_ATOMIC);\n\tif (!pmd_table)\n\t\treturn NULL;\n\n\tset_pgd(pgd, __pgd(__pa(pmd_table) | _PAGE_PRESENT));\n\tp4d = p4d_offset(pgd, 0);\n\tpud = pud_offset(p4d, 0);\n\n\tBUG_ON(pmd_table != pmd_offset(pud, 0));\n#else\n\tp4d = p4d_offset(pgd, 0);\n\tpud = pud_offset(p4d, 0);\n\tpmd_table = pmd_offset(pud, 0);\n#endif\n\n\treturn pmd_table;\n}\n\n \nstatic pte_t *resume_one_page_table_init(pmd_t *pmd)\n{\n\tif (pmd_none(*pmd)) {\n\t\tpte_t *page_table = (pte_t *)get_safe_page(GFP_ATOMIC);\n\t\tif (!page_table)\n\t\t\treturn NULL;\n\n\t\tset_pmd(pmd, __pmd(__pa(page_table) | _PAGE_TABLE));\n\n\t\tBUG_ON(page_table != pte_offset_kernel(pmd, 0));\n\n\t\treturn page_table;\n\t}\n\n\treturn pte_offset_kernel(pmd, 0);\n}\n\n \nstatic int resume_physical_mapping_init(pgd_t *pgd_base)\n{\n\tunsigned long pfn;\n\tpgd_t *pgd;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint pgd_idx, pmd_idx;\n\n\tpgd_idx = pgd_index(PAGE_OFFSET);\n\tpgd = pgd_base + pgd_idx;\n\tpfn = 0;\n\n\tfor (; pgd_idx < PTRS_PER_PGD; pgd++, pgd_idx++) {\n\t\tpmd = resume_one_md_table_init(pgd);\n\t\tif (!pmd)\n\t\t\treturn -ENOMEM;\n\n\t\tif (pfn >= max_low_pfn)\n\t\t\tcontinue;\n\n\t\tfor (pmd_idx = 0; pmd_idx < PTRS_PER_PMD; pmd++, pmd_idx++) {\n\t\t\tif (pfn >= max_low_pfn)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (boot_cpu_has(X86_FEATURE_PSE)) {\n\t\t\t\tset_pmd(pmd, pfn_pmd(pfn, PAGE_KERNEL_LARGE_EXEC));\n\t\t\t\tpfn += PTRS_PER_PTE;\n\t\t\t} else {\n\t\t\t\tpte_t *max_pte;\n\n\t\t\t\tpte = resume_one_page_table_init(pmd);\n\t\t\t\tif (!pte)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tmax_pte = pte + PTRS_PER_PTE;\n\t\t\t\tfor (; pte < max_pte; pte++, pfn++) {\n\t\t\t\t\tif (pfn >= max_low_pfn)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tset_pte(pte, pfn_pte(pfn, PAGE_KERNEL_EXEC));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline void resume_init_first_level_page_table(pgd_t *pg_dir)\n{\n#ifdef CONFIG_X86_PAE\n\tint i;\n\n\t \n\tfor (i = 0; i < PTRS_PER_PGD; i++)\n\t\tset_pgd(pg_dir + i,\n\t\t\t__pgd(__pa(empty_zero_page) | _PAGE_PRESENT));\n#endif\n}\n\nstatic int set_up_temporary_text_mapping(pgd_t *pgd_base)\n{\n\tpgd_t *pgd;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\n\tpgd = pgd_base + pgd_index(restore_jump_address);\n\n\tpmd = resume_one_md_table_init(pgd);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\n\tif (boot_cpu_has(X86_FEATURE_PSE)) {\n\t\tset_pmd(pmd + pmd_index(restore_jump_address),\n\t\t__pmd((jump_address_phys & PMD_MASK) | pgprot_val(PAGE_KERNEL_LARGE_EXEC)));\n\t} else {\n\t\tpte = resume_one_page_table_init(pmd);\n\t\tif (!pte)\n\t\t\treturn -ENOMEM;\n\t\tset_pte(pte + pte_index(restore_jump_address),\n\t\t__pte((jump_address_phys & PAGE_MASK) | pgprot_val(PAGE_KERNEL_EXEC)));\n\t}\n\n\treturn 0;\n}\n\nasmlinkage int swsusp_arch_resume(void)\n{\n\tint error;\n\n\tresume_pg_dir = (pgd_t *)get_safe_page(GFP_ATOMIC);\n\tif (!resume_pg_dir)\n\t\treturn -ENOMEM;\n\n\tresume_init_first_level_page_table(resume_pg_dir);\n\n\terror = set_up_temporary_text_mapping(resume_pg_dir);\n\tif (error)\n\t\treturn error;\n\n\terror = resume_physical_mapping_init(resume_pg_dir);\n\tif (error)\n\t\treturn error;\n\n\ttemp_pgt = __pa(resume_pg_dir);\n\n\terror = relocate_restore_code();\n\tif (error)\n\t\treturn error;\n\n\t \n\trestore_image();\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}