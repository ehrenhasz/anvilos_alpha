{
  "module_name": "cpu.c",
  "hash_id": "240640998700091031cdd732abf093c4e5298ac2c222b7f01236e31ef26a27e3",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/power/cpu.c",
  "human_readable_source": "\n \n\n#include <linux/suspend.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n#include <linux/perf_event.h>\n#include <linux/tboot.h>\n#include <linux/dmi.h>\n#include <linux/pgtable.h>\n\n#include <asm/proto.h>\n#include <asm/mtrr.h>\n#include <asm/page.h>\n#include <asm/mce.h>\n#include <asm/suspend.h>\n#include <asm/fpu/api.h>\n#include <asm/debugreg.h>\n#include <asm/cpu.h>\n#include <asm/cacheinfo.h>\n#include <asm/mmu_context.h>\n#include <asm/cpu_device_id.h>\n#include <asm/microcode.h>\n\n#ifdef CONFIG_X86_32\n__visible unsigned long saved_context_ebx;\n__visible unsigned long saved_context_esp, saved_context_ebp;\n__visible unsigned long saved_context_esi, saved_context_edi;\n__visible unsigned long saved_context_eflags;\n#endif\nstruct saved_context saved_context;\n\nstatic void msr_save_context(struct saved_context *ctxt)\n{\n\tstruct saved_msr *msr = ctxt->saved_msrs.array;\n\tstruct saved_msr *end = msr + ctxt->saved_msrs.num;\n\n\twhile (msr < end) {\n\t\tif (msr->valid)\n\t\t\trdmsrl(msr->info.msr_no, msr->info.reg.q);\n\t\tmsr++;\n\t}\n}\n\nstatic void msr_restore_context(struct saved_context *ctxt)\n{\n\tstruct saved_msr *msr = ctxt->saved_msrs.array;\n\tstruct saved_msr *end = msr + ctxt->saved_msrs.num;\n\n\twhile (msr < end) {\n\t\tif (msr->valid)\n\t\t\twrmsrl(msr->info.msr_no, msr->info.reg.q);\n\t\tmsr++;\n\t}\n}\n\n \nstatic void __save_processor_state(struct saved_context *ctxt)\n{\n#ifdef CONFIG_X86_32\n\tmtrr_save_fixed_ranges(NULL);\n#endif\n\tkernel_fpu_begin();\n\n\t \n\tstore_idt(&ctxt->idt);\n\n\t \n\tctxt->gdt_desc.size = GDT_SIZE - 1;\n\tctxt->gdt_desc.address = (unsigned long)get_cpu_gdt_rw(smp_processor_id());\n\n\tstore_tr(ctxt->tr);\n\n\t \n\t \n\tsavesegment(gs, ctxt->gs);\n#ifdef CONFIG_X86_64\n\tsavesegment(fs, ctxt->fs);\n\tsavesegment(ds, ctxt->ds);\n\tsavesegment(es, ctxt->es);\n\n\trdmsrl(MSR_FS_BASE, ctxt->fs_base);\n\trdmsrl(MSR_GS_BASE, ctxt->kernelmode_gs_base);\n\trdmsrl(MSR_KERNEL_GS_BASE, ctxt->usermode_gs_base);\n\tmtrr_save_fixed_ranges(NULL);\n\n\trdmsrl(MSR_EFER, ctxt->efer);\n#endif\n\n\t \n\tctxt->cr0 = read_cr0();\n\tctxt->cr2 = read_cr2();\n\tctxt->cr3 = __read_cr3();\n\tctxt->cr4 = __read_cr4();\n\tctxt->misc_enable_saved = !rdmsrl_safe(MSR_IA32_MISC_ENABLE,\n\t\t\t\t\t       &ctxt->misc_enable);\n\tmsr_save_context(ctxt);\n}\n\n \nvoid save_processor_state(void)\n{\n\t__save_processor_state(&saved_context);\n\tx86_platform.save_sched_clock_state();\n}\n#ifdef CONFIG_X86_32\nEXPORT_SYMBOL(save_processor_state);\n#endif\n\nstatic void do_fpu_end(void)\n{\n\t \n\tkernel_fpu_end();\n}\n\nstatic void fix_processor_context(void)\n{\n\tint cpu = smp_processor_id();\n#ifdef CONFIG_X86_64\n\tstruct desc_struct *desc = get_cpu_gdt_rw(cpu);\n\ttss_desc tss;\n#endif\n\n\t \n\tset_tss_desc(cpu, &get_cpu_entry_area(cpu)->tss.x86_tss);\n\n#ifdef CONFIG_X86_64\n\tmemcpy(&tss, &desc[GDT_ENTRY_TSS], sizeof(tss_desc));\n\ttss.type = 0x9;  \n\twrite_gdt_entry(desc, GDT_ENTRY_TSS, &tss, DESC_TSS);\n\n\tsyscall_init();\t\t\t\t \n#else\n\tif (boot_cpu_has(X86_FEATURE_SEP))\n\t\tenable_sep_cpu();\n#endif\n\tload_TR_desc();\t\t\t\t \n\tload_mm_ldt(current->active_mm);\t \n\tinitialize_tlbstate_and_flush();\n\n\tfpu__resume_cpu();\n\n\t \n\tload_fixmap_gdt(cpu);\n}\n\n \nstatic void notrace __restore_processor_state(struct saved_context *ctxt)\n{\n\tstruct cpuinfo_x86 *c;\n\n\tif (ctxt->misc_enable_saved)\n\t\twrmsrl(MSR_IA32_MISC_ENABLE, ctxt->misc_enable);\n\t \n\t \n#ifdef CONFIG_X86_32\n\tif (ctxt->cr4)\n\t\t__write_cr4(ctxt->cr4);\n#else\n \n\twrmsrl(MSR_EFER, ctxt->efer);\n\t__write_cr4(ctxt->cr4);\n#endif\n\twrite_cr3(ctxt->cr3);\n\twrite_cr2(ctxt->cr2);\n\twrite_cr0(ctxt->cr0);\n\n\t \n\tload_idt(&ctxt->idt);\n\n\t \n\tloadsegment(ss, __KERNEL_DS);\n\tloadsegment(ds, __USER_DS);\n\tloadsegment(es, __USER_DS);\n\n\t \n#ifdef CONFIG_X86_64\n\twrmsrl(MSR_GS_BASE, ctxt->kernelmode_gs_base);\n#else\n\tloadsegment(fs, __KERNEL_PERCPU);\n#endif\n\n\t \n\tfix_processor_context();\n\n\t \n#ifdef CONFIG_X86_64\n\tloadsegment(ds, ctxt->es);\n\tloadsegment(es, ctxt->es);\n\tloadsegment(fs, ctxt->fs);\n\tload_gs_index(ctxt->gs);\n\n\t \n\twrmsrl(MSR_FS_BASE, ctxt->fs_base);\n\twrmsrl(MSR_KERNEL_GS_BASE, ctxt->usermode_gs_base);\n#else\n\tloadsegment(gs, ctxt->gs);\n#endif\n\n\tdo_fpu_end();\n\ttsc_verify_tsc_adjust(true);\n\tx86_platform.restore_sched_clock_state();\n\tcache_bp_restore();\n\tperf_restore_debug_store();\n\n\tc = &cpu_data(smp_processor_id());\n\tif (cpu_has(c, X86_FEATURE_MSR_IA32_FEAT_CTL))\n\t\tinit_ia32_feat_ctl(c);\n\n\tmicrocode_bsp_resume();\n\n\t \n\tmsr_restore_context(ctxt);\n}\n\n \nvoid notrace restore_processor_state(void)\n{\n\t__restore_processor_state(&saved_context);\n}\n#ifdef CONFIG_X86_32\nEXPORT_SYMBOL(restore_processor_state);\n#endif\n\n#if defined(CONFIG_HIBERNATION) && defined(CONFIG_HOTPLUG_CPU)\nstatic void __noreturn resume_play_dead(void)\n{\n\tplay_dead_common();\n\ttboot_shutdown(TB_SHUTDOWN_WFS);\n\thlt_play_dead();\n}\n\nint hibernate_resume_nonboot_cpu_disable(void)\n{\n\tvoid (*play_dead)(void) = smp_ops.play_dead;\n\tint ret;\n\n\t \n\tret = cpuhp_smt_enable();\n\tif (ret)\n\t\treturn ret;\n\tsmp_ops.play_dead = resume_play_dead;\n\tret = freeze_secondary_cpus(0);\n\tsmp_ops.play_dead = play_dead;\n\treturn ret;\n}\n#endif\n\n \nstatic int bsp_check(void)\n{\n\tif (cpumask_first(cpu_online_mask) != 0) {\n\t\tpr_warn(\"CPU0 is offline.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int bsp_pm_callback(struct notifier_block *nb, unsigned long action,\n\t\t\t   void *ptr)\n{\n\tint ret = 0;\n\n\tswitch (action) {\n\tcase PM_SUSPEND_PREPARE:\n\tcase PM_HIBERNATION_PREPARE:\n\t\tret = bsp_check();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn notifier_from_errno(ret);\n}\n\nstatic int __init bsp_pm_check_init(void)\n{\n\t \n\tpm_notifier(bsp_pm_callback, -INT_MAX);\n\treturn 0;\n}\n\ncore_initcall(bsp_pm_check_init);\n\nstatic int msr_build_context(const u32 *msr_id, const int num)\n{\n\tstruct saved_msrs *saved_msrs = &saved_context.saved_msrs;\n\tstruct saved_msr *msr_array;\n\tint total_num;\n\tint i, j;\n\n\ttotal_num = saved_msrs->num + num;\n\n\tmsr_array = kmalloc_array(total_num, sizeof(struct saved_msr), GFP_KERNEL);\n\tif (!msr_array) {\n\t\tpr_err(\"x86/pm: Can not allocate memory to save/restore MSRs during suspend.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (saved_msrs->array) {\n\t\t \n\t\tmemcpy(msr_array, saved_msrs->array,\n\t\t       sizeof(struct saved_msr) * saved_msrs->num);\n\n\t\tkfree(saved_msrs->array);\n\t}\n\n\tfor (i = saved_msrs->num, j = 0; i < total_num; i++, j++) {\n\t\tu64 dummy;\n\n\t\tmsr_array[i].info.msr_no\t= msr_id[j];\n\t\tmsr_array[i].valid\t\t= !rdmsrl_safe(msr_id[j], &dummy);\n\t\tmsr_array[i].info.reg.q\t\t= 0;\n\t}\n\tsaved_msrs->num   = total_num;\n\tsaved_msrs->array = msr_array;\n\n\treturn 0;\n}\n\n \nstatic int msr_initialize_bdw(const struct dmi_system_id *d)\n{\n\t \n\tu32 bdw_msr_id[] = { MSR_IA32_THERM_CONTROL };\n\n\tpr_info(\"x86/pm: %s detected, MSR saving is needed during suspending.\\n\", d->ident);\n\treturn msr_build_context(bdw_msr_id, ARRAY_SIZE(bdw_msr_id));\n}\n\nstatic const struct dmi_system_id msr_save_dmi_table[] = {\n\t{\n\t .callback = msr_initialize_bdw,\n\t .ident = \"BROADWELL BDX_EP\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"GRANTLEY\"),\n\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"E63448-400\"),\n\t\t},\n\t},\n\t{}\n};\n\nstatic int msr_save_cpuid_features(const struct x86_cpu_id *c)\n{\n\tu32 cpuid_msr_id[] = {\n\t\tMSR_AMD64_CPUID_FN_1,\n\t};\n\n\tpr_info(\"x86/pm: family %#hx cpu detected, MSR saving is needed during suspending.\\n\",\n\t\tc->family);\n\n\treturn msr_build_context(cpuid_msr_id, ARRAY_SIZE(cpuid_msr_id));\n}\n\nstatic const struct x86_cpu_id msr_save_cpu_table[] = {\n\tX86_MATCH_VENDOR_FAM(AMD, 0x15, &msr_save_cpuid_features),\n\tX86_MATCH_VENDOR_FAM(AMD, 0x16, &msr_save_cpuid_features),\n\t{}\n};\n\ntypedef int (*pm_cpu_match_t)(const struct x86_cpu_id *);\nstatic int pm_cpu_check(const struct x86_cpu_id *c)\n{\n\tconst struct x86_cpu_id *m;\n\tint ret = 0;\n\n\tm = x86_match_cpu(msr_save_cpu_table);\n\tif (m) {\n\t\tpm_cpu_match_t fn;\n\n\t\tfn = (pm_cpu_match_t)m->driver_data;\n\t\tret = fn(m);\n\t}\n\n\treturn ret;\n}\n\nstatic void pm_save_spec_msr(void)\n{\n\tstruct msr_enumeration {\n\t\tu32 msr_no;\n\t\tu32 feature;\n\t} msr_enum[] = {\n\t\t{ MSR_IA32_SPEC_CTRL,\t X86_FEATURE_MSR_SPEC_CTRL },\n\t\t{ MSR_IA32_TSX_CTRL,\t X86_FEATURE_MSR_TSX_CTRL },\n\t\t{ MSR_TSX_FORCE_ABORT,\t X86_FEATURE_TSX_FORCE_ABORT },\n\t\t{ MSR_IA32_MCU_OPT_CTRL, X86_FEATURE_SRBDS_CTRL },\n\t\t{ MSR_AMD64_LS_CFG,\t X86_FEATURE_LS_CFG_SSBD },\n\t\t{ MSR_AMD64_DE_CFG,\t X86_FEATURE_LFENCE_RDTSC },\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(msr_enum); i++) {\n\t\tif (boot_cpu_has(msr_enum[i].feature))\n\t\t\tmsr_build_context(&msr_enum[i].msr_no, 1);\n\t}\n}\n\nstatic int pm_check_save_msr(void)\n{\n\tdmi_check_system(msr_save_dmi_table);\n\tpm_cpu_check(msr_save_cpu_table);\n\tpm_save_spec_msr();\n\n\treturn 0;\n}\n\ndevice_initcall(pm_check_save_msr);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}