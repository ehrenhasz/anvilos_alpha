{
  "module_name": "sta2x11-fixup.c",
  "hash_id": "42521e11062a9484961c675ade4bc67c1139b4e592c9859aca90cc26556fb4b0",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/pci/sta2x11-fixup.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/dma-map-ops.h>\n#include <linux/swiotlb.h>\n#include <asm/iommu.h>\n\n#define STA2X11_SWIOTLB_SIZE (4*1024*1024)\n\n \n#define STA2X11_NR_EP\t\t4\t \n#define STA2X11_NR_FUNCS\t8\t \n#define STA2X11_AMBA_SIZE\t(512 << 20)\n\nstruct sta2x11_ahb_regs {  \n\tu32 base, pexlbase, pexhbase, crw;\n};\n\nstruct sta2x11_mapping {\n\tint is_suspended;\n\tstruct sta2x11_ahb_regs regs[STA2X11_NR_FUNCS];\n};\n\nstruct sta2x11_instance {\n\tstruct list_head list;\n\tint bus0;\n\tstruct sta2x11_mapping map[STA2X11_NR_EP];\n};\n\nstatic LIST_HEAD(sta2x11_instance_list);\n\n \nstatic void sta2x11_new_instance(struct pci_dev *pdev)\n{\n\tstruct sta2x11_instance *instance;\n\n\tinstance = kzalloc(sizeof(*instance), GFP_ATOMIC);\n\tif (!instance)\n\t\treturn;\n\t \n\tinstance->bus0 = pdev->subordinate->number + 1;\n\n\tif (list_empty(&sta2x11_instance_list)) {\n\t\tint size = STA2X11_SWIOTLB_SIZE;\n\t\t \n\t\tdev_info(&pdev->dev, \"Using SWIOTLB (size %i)\\n\", size);\n\t\tif (swiotlb_init_late(size, GFP_DMA, NULL))\n\t\t\tdev_emerg(&pdev->dev, \"init swiotlb failed\\n\");\n\t}\n\tlist_add(&instance->list, &sta2x11_instance_list);\n}\nDECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_STMICRO, 0xcc17, sta2x11_new_instance);\n\n \nstatic struct sta2x11_instance *sta2x11_pdev_to_instance(struct pci_dev *pdev)\n{\n\tstruct sta2x11_instance *instance;\n\tint ep;\n\n\tlist_for_each_entry(instance, &sta2x11_instance_list, list) {\n\t\tep = pdev->bus->number - instance->bus0;\n\t\tif (ep >= 0 && ep < STA2X11_NR_EP)\n\t\t\treturn instance;\n\t}\n\treturn NULL;\n}\n\nstatic int sta2x11_pdev_to_ep(struct pci_dev *pdev)\n{\n\tstruct sta2x11_instance *instance;\n\n\tinstance = sta2x11_pdev_to_instance(pdev);\n\tif (!instance)\n\t\treturn -1;\n\n\treturn pdev->bus->number - instance->bus0;\n}\n\n \nstruct sta2x11_instance *sta2x11_get_instance(struct pci_dev *pdev)\n{\n\treturn sta2x11_pdev_to_instance(pdev);\n}\nEXPORT_SYMBOL(sta2x11_get_instance);\n\n \nstatic void sta2x11_setup_pdev(struct pci_dev *pdev)\n{\n\tstruct sta2x11_instance *instance = sta2x11_pdev_to_instance(pdev);\n\n\tif (!instance)  \n\t\treturn;\n\n\t \n\tpci_set_master(pdev);\n}\nDECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_STMICRO, PCI_ANY_ID, sta2x11_setup_pdev);\n\n \n\n#define AHB_MAPB\t\t0xCA4\n#define AHB_CRW(i)\t\t(AHB_MAPB + 0  + (i) * 0x10)\n#define AHB_CRW_SZMASK\t\t\t0xfffffc00UL\n#define AHB_CRW_ENABLE\t\t\t(1 << 0)\n#define AHB_CRW_WTYPE_MEM\t\t(2 << 1)\n#define AHB_CRW_ROE\t\t\t(1UL << 3)\t \n#define AHB_CRW_NSE\t\t\t(1UL << 4)\t \n#define AHB_BASE(i)\t\t(AHB_MAPB + 4  + (i) * 0x10)\n#define AHB_PEXLBASE(i)\t\t(AHB_MAPB + 8  + (i) * 0x10)\n#define AHB_PEXHBASE(i)\t\t(AHB_MAPB + 12 + (i) * 0x10)\n\n \nstatic void sta2x11_map_ep(struct pci_dev *pdev)\n{\n\tstruct sta2x11_instance *instance = sta2x11_pdev_to_instance(pdev);\n\tstruct device *dev = &pdev->dev;\n\tu32 amba_base, max_amba_addr;\n\tint i, ret;\n\n\tif (!instance)\n\t\treturn;\n\n\tpci_read_config_dword(pdev, AHB_BASE(0), &amba_base);\n\tmax_amba_addr = amba_base + STA2X11_AMBA_SIZE - 1;\n\n\tret = dma_direct_set_offset(dev, 0, amba_base, STA2X11_AMBA_SIZE);\n\tif (ret)\n\t\tdev_err(dev, \"sta2x11: could not set DMA offset\\n\");\n\n\tdev->bus_dma_limit = max_amba_addr;\n\tdma_set_mask_and_coherent(&pdev->dev, max_amba_addr);\n\n\t \n\tpci_write_config_dword(pdev, AHB_PEXLBASE(0), 0);\n\tpci_write_config_dword(pdev, AHB_PEXHBASE(0), 0);\n\tpci_write_config_dword(pdev, AHB_CRW(0), STA2X11_AMBA_SIZE |\n\t\t\t       AHB_CRW_WTYPE_MEM | AHB_CRW_ENABLE);\n\n\t \n\tfor (i = 1; i < STA2X11_NR_FUNCS; i++)\n\t\tpci_write_config_dword(pdev, AHB_CRW(i), 0);\n\n\tdev_info(&pdev->dev,\n\t\t \"sta2x11: Map EP %i: AMBA address %#8x-%#8x\\n\",\n\t\t sta2x11_pdev_to_ep(pdev), amba_base, max_amba_addr);\n}\nDECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_STMICRO, PCI_ANY_ID, sta2x11_map_ep);\n\n#ifdef CONFIG_PM  \n\nstatic struct sta2x11_mapping *sta2x11_pdev_to_mapping(struct pci_dev *pdev)\n{\n\tstruct sta2x11_instance *instance;\n\tint ep;\n\n\tinstance = sta2x11_pdev_to_instance(pdev);\n\tif (!instance)\n\t\treturn NULL;\n\tep = sta2x11_pdev_to_ep(pdev);\n\treturn instance->map + ep;\n}\n\nstatic void suspend_mapping(struct pci_dev *pdev)\n{\n\tstruct sta2x11_mapping *map = sta2x11_pdev_to_mapping(pdev);\n\tint i;\n\n\tif (!map)\n\t\treturn;\n\n\tif (map->is_suspended)\n\t\treturn;\n\tmap->is_suspended = 1;\n\n\t \n\tfor (i = 0; i < STA2X11_NR_FUNCS; i++) {\n\t\tstruct sta2x11_ahb_regs *regs = map->regs + i;\n\n\t\tpci_read_config_dword(pdev, AHB_BASE(i), &regs->base);\n\t\tpci_read_config_dword(pdev, AHB_PEXLBASE(i), &regs->pexlbase);\n\t\tpci_read_config_dword(pdev, AHB_PEXHBASE(i), &regs->pexhbase);\n\t\tpci_read_config_dword(pdev, AHB_CRW(i), &regs->crw);\n\t}\n}\nDECLARE_PCI_FIXUP_SUSPEND(PCI_VENDOR_ID_STMICRO, PCI_ANY_ID, suspend_mapping);\n\nstatic void resume_mapping(struct pci_dev *pdev)\n{\n\tstruct sta2x11_mapping *map = sta2x11_pdev_to_mapping(pdev);\n\tint i;\n\n\tif (!map)\n\t\treturn;\n\n\n\tif (!map->is_suspended)\n\t\tgoto out;\n\tmap->is_suspended = 0;\n\n\t \n\tfor (i = 0; i < STA2X11_NR_FUNCS; i++) {\n\t\tstruct sta2x11_ahb_regs *regs = map->regs + i;\n\n\t\tpci_write_config_dword(pdev, AHB_BASE(i), regs->base);\n\t\tpci_write_config_dword(pdev, AHB_PEXLBASE(i), regs->pexlbase);\n\t\tpci_write_config_dword(pdev, AHB_PEXHBASE(i), regs->pexhbase);\n\t\tpci_write_config_dword(pdev, AHB_CRW(i), regs->crw);\n\t}\nout:\n\tpci_set_master(pdev);  \n}\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_STMICRO, PCI_ANY_ID, resume_mapping);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}