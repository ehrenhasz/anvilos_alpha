{
  "module_name": "intel_mid_pci.c",
  "hash_id": "379333d0fd549b5916f4c87d3ef13164a22977ed162046c817f911ba4a6e2968",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/pci/intel_mid_pci.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/pci.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/dmi.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n#include <linux/smp.h>\n\n#include <asm/cpu_device_id.h>\n#include <asm/segment.h>\n#include <asm/pci_x86.h>\n#include <asm/hw_irq.h>\n#include <asm/io_apic.h>\n#include <asm/intel-family.h>\n#include <asm/intel-mid.h>\n#include <asm/acpi.h>\n\n#define PCIE_CAP_OFFSET\t0x100\n\n \n#define PCI_DEVICE_ID_INTEL_MRFLD_MMC\t0x1190\n#define PCI_DEVICE_ID_INTEL_MRFLD_HSU\t0x1191\n\n \n#define PCIE_VNDR_CAP_ID_FIXED_BAR 0x00\t \n#define PCI_FIXED_BAR_0_SIZE\t0x04\n#define PCI_FIXED_BAR_1_SIZE\t0x08\n#define PCI_FIXED_BAR_2_SIZE\t0x0c\n#define PCI_FIXED_BAR_3_SIZE\t0x10\n#define PCI_FIXED_BAR_4_SIZE\t0x14\n#define PCI_FIXED_BAR_5_SIZE\t0x1c\n\nstatic int pci_soc_mode;\n\n \nstatic int fixed_bar_cap(struct pci_bus *bus, unsigned int devfn)\n{\n\tint pos;\n\tu32 pcie_cap = 0, cap_data;\n\n\tpos = PCIE_CAP_OFFSET;\n\n\tif (!raw_pci_ext_ops)\n\t\treturn 0;\n\n\twhile (pos) {\n\t\tif (raw_pci_ext_ops->read(pci_domain_nr(bus), bus->number,\n\t\t\t\t\t  devfn, pos, 4, &pcie_cap))\n\t\t\treturn 0;\n\n\t\tif (PCI_EXT_CAP_ID(pcie_cap) == 0x0000 ||\n\t\t\tPCI_EXT_CAP_ID(pcie_cap) == 0xffff)\n\t\t\tbreak;\n\n\t\tif (PCI_EXT_CAP_ID(pcie_cap) == PCI_EXT_CAP_ID_VNDR) {\n\t\t\traw_pci_ext_ops->read(pci_domain_nr(bus), bus->number,\n\t\t\t\t\t      devfn, pos + 4, 4, &cap_data);\n\t\t\tif ((cap_data & 0xffff) == PCIE_VNDR_CAP_ID_FIXED_BAR)\n\t\t\t\treturn pos;\n\t\t}\n\n\t\tpos = PCI_EXT_CAP_NEXT(pcie_cap);\n\t}\n\n\treturn 0;\n}\n\nstatic int pci_device_update_fixed(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t   int reg, int len, u32 val, int offset)\n{\n\tu32 size;\n\tunsigned int domain, busnum;\n\tint bar = (reg - PCI_BASE_ADDRESS_0) >> 2;\n\n\tdomain = pci_domain_nr(bus);\n\tbusnum = bus->number;\n\n\tif (val == ~0 && len == 4) {\n\t\tunsigned long decode;\n\n\t\traw_pci_ext_ops->read(domain, busnum, devfn,\n\t\t\t       offset + 8 + (bar * 4), 4, &size);\n\n\t\t \n\t\tif (size) {\n\t\t\tdecode = size - 1;\n\t\t\tdecode |= decode >> 1;\n\t\t\tdecode |= decode >> 2;\n\t\t\tdecode |= decode >> 4;\n\t\t\tdecode |= decode >> 8;\n\t\t\tdecode |= decode >> 16;\n\t\t\tdecode++;\n\t\t\tdecode = ~(decode - 1);\n\t\t} else {\n\t\t\tdecode = 0;\n\t\t}\n\n\t\t \n\t\treturn raw_pci_ext_ops->write(domain, busnum, devfn, reg, 4,\n\t\t\t\t       decode);\n\t}\n\n\t \n\treturn raw_pci_ext_ops->write(domain, busnum, devfn, reg, len, val);\n}\n\n \nstatic bool type1_access_ok(unsigned int bus, unsigned int devfn, int reg)\n{\n\t \n\tif (reg >= 0x100 || reg == PCI_STATUS || reg == PCI_HEADER_TYPE)\n\t\treturn false;\n\tif (bus == 0 && (devfn == PCI_DEVFN(2, 0)\n\t\t\t\t|| devfn == PCI_DEVFN(0, 0)\n\t\t\t\t|| devfn == PCI_DEVFN(3, 0)))\n\t\treturn true;\n\treturn false;  \n}\n\nstatic int pci_read(struct pci_bus *bus, unsigned int devfn, int where,\n\t\t    int size, u32 *value)\n{\n\tif (type1_access_ok(bus->number, devfn, where))\n\t\treturn pci_direct_conf1.read(pci_domain_nr(bus), bus->number,\n\t\t\t\t\tdevfn, where, size, value);\n\treturn raw_pci_ext_ops->read(pci_domain_nr(bus), bus->number,\n\t\t\t      devfn, where, size, value);\n}\n\nstatic int pci_write(struct pci_bus *bus, unsigned int devfn, int where,\n\t\t     int size, u32 value)\n{\n\tint offset;\n\n\t \n\tif (where == PCI_ROM_ADDRESS)\n\t\treturn 0;\n\n\t \n\toffset = fixed_bar_cap(bus, devfn);\n\tif (offset &&\n\t    (where >= PCI_BASE_ADDRESS_0 && where <= PCI_BASE_ADDRESS_5)) {\n\t\treturn pci_device_update_fixed(bus, devfn, where, size, value,\n\t\t\t\t\t       offset);\n\t}\n\n\t \n\tif (type1_access_ok(bus->number, devfn, where))\n\t\treturn pci_direct_conf1.write(pci_domain_nr(bus), bus->number,\n\t\t\t\t\t      devfn, where, size, value);\n\treturn raw_pci_ext_ops->write(pci_domain_nr(bus), bus->number, devfn,\n\t\t\t       where, size, value);\n}\n\nstatic const struct x86_cpu_id intel_mid_cpu_ids[] = {\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT_MID, NULL),\n\t{}\n};\n\nstatic int intel_mid_pci_irq_enable(struct pci_dev *dev)\n{\n\tconst struct x86_cpu_id *id;\n\tstruct irq_alloc_info info;\n\tbool polarity_low;\n\tu16 model = 0;\n\tint ret;\n\tu8 gsi;\n\n\tif (dev->irq_managed && dev->irq > 0)\n\t\treturn 0;\n\n\tret = pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &gsi);\n\tif (ret < 0) {\n\t\tdev_warn(&dev->dev, \"Failed to read interrupt line: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tid = x86_match_cpu(intel_mid_cpu_ids);\n\tif (id)\n\t\tmodel = id->model;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_ATOM_SILVERMONT_MID:\n\t\tpolarity_low = false;\n\n\t\t \n\t\tif (gsi == 0) {\n\t\t\t \n\t\t\tif (dev->device == PCI_DEVICE_ID_INTEL_MRFLD_HSU)\n\t\t\t\treturn -EBUSY;\n\t\t\t \n\t\t\tif (dev->device != PCI_DEVICE_ID_INTEL_MRFLD_MMC)\n\t\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpolarity_low = true;\n\t\tbreak;\n\t}\n\n\tioapic_set_alloc_attr(&info, dev_to_node(&dev->dev), 1, polarity_low);\n\n\t \n\tret = mp_map_gsi_to_irq(gsi, IOAPIC_MAP_ALLOC, &info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev->irq = ret;\n\tdev->irq_managed = 1;\n\n\treturn 0;\n}\n\nstatic void intel_mid_pci_irq_disable(struct pci_dev *dev)\n{\n\tif (!mp_should_keep_irq(&dev->dev) && dev->irq_managed &&\n\t    dev->irq > 0) {\n\t\tmp_unmap_irq(dev->irq);\n\t\tdev->irq_managed = 0;\n\t}\n}\n\nstatic const struct pci_ops intel_mid_pci_ops __initconst = {\n\t.read = pci_read,\n\t.write = pci_write,\n};\n\n \nint __init intel_mid_pci_init(void)\n{\n\tpr_info(\"Intel MID platform detected, using MID PCI ops\\n\");\n\tpci_mmcfg_late_init();\n\tpcibios_enable_irq = intel_mid_pci_irq_enable;\n\tpcibios_disable_irq = intel_mid_pci_irq_disable;\n\tpci_root_ops = intel_mid_pci_ops;\n\tpci_soc_mode = 1;\n\t \n\tacpi_noirq_set();\n\treturn 1;\n}\n\n \nstatic void pci_d3delay_fixup(struct pci_dev *dev)\n{\n\t \n\tif (!pci_soc_mode)\n\t\treturn;\n\t \n\tif (type1_access_ok(dev->bus->number, dev->devfn, PCI_DEVICE_ID))\n\t\treturn;\n\tdev->d3hot_delay = 0;\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, PCI_ANY_ID, pci_d3delay_fixup);\n\nstatic void mid_power_off_one_device(struct pci_dev *dev)\n{\n\tu16 pmcsr;\n\n\t \n\tpci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);\n\tdev->current_state = (pci_power_t __force)(pmcsr & PCI_PM_CTRL_STATE_MASK);\n\n\tpci_set_power_state(dev, PCI_D3hot);\n}\n\nstatic void mid_power_off_devices(struct pci_dev *dev)\n{\n\tint id;\n\n\tif (!pci_soc_mode)\n\t\treturn;\n\n\tid = intel_mid_pwr_get_lss_id(dev);\n\tif (id < 0)\n\t\treturn;\n\n\t \n\tmid_power_off_one_device(dev);\n}\n\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, PCI_ANY_ID, mid_power_off_devices);\n\n \nstatic void pci_fixed_bar_fixup(struct pci_dev *dev)\n{\n\tunsigned long offset;\n\tu32 size;\n\tint i;\n\n\tif (!pci_soc_mode)\n\t\treturn;\n\n\t \n\tif (dev->cfg_size < PCIE_CAP_OFFSET + 4)\n\t\treturn;\n\n\t \n\toffset = fixed_bar_cap(dev->bus, dev->devfn);\n\tif (!offset || PCI_DEVFN(2, 0) == dev->devfn ||\n\t    PCI_DEVFN(2, 2) == dev->devfn)\n\t\treturn;\n\n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++) {\n\t\tpci_read_config_dword(dev, offset + 8 + (i * 4), &size);\n\t\tdev->resource[i].end = dev->resource[i].start + size - 1;\n\t\tdev->resource[i].flags |= IORESOURCE_PCI_FIXED;\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_ANY_ID, pci_fixed_bar_fixup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}