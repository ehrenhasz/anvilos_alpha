{
  "module_name": "bus_numa.c",
  "hash_id": "18b413aecb1d7577aea85ac60b342cd3beb66ba2e6392f8a76bf9c8a5ff2f2c0",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/pci/bus_numa.c",
  "human_readable_source": "\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/range.h>\n\n#include \"bus_numa.h\"\n\nLIST_HEAD(pci_root_infos);\n\nstatic struct pci_root_info *x86_find_pci_root_info(int bus)\n{\n\tstruct pci_root_info *info;\n\n\tlist_for_each_entry(info, &pci_root_infos, list)\n\t\tif (info->busn.start == bus)\n\t\t\treturn info;\n\n\treturn NULL;\n}\n\nint x86_pci_root_bus_node(int bus)\n{\n\tstruct pci_root_info *info = x86_find_pci_root_info(bus);\n\n\tif (!info)\n\t\treturn NUMA_NO_NODE;\n\n\treturn info->node;\n}\n\nvoid x86_pci_root_bus_resources(int bus, struct list_head *resources)\n{\n\tstruct pci_root_info *info = x86_find_pci_root_info(bus);\n\tstruct pci_root_res *root_res;\n\tstruct resource_entry *window;\n\tbool found = false;\n\n\tif (!info)\n\t\tgoto default_resources;\n\n\tprintk(KERN_DEBUG \"PCI: root bus %02x: hardware-probed resources\\n\",\n\t       bus);\n\n\t \n\tresource_list_for_each_entry(window, resources)\n\t\tif (window->res->flags & IORESOURCE_BUS) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\tif (!found)\n\t\tpci_add_resource(resources, &info->busn);\n\n\tlist_for_each_entry(root_res, &info->resources, list)\n\t\tpci_add_resource(resources, &root_res->res);\n\n\treturn;\n\ndefault_resources:\n\t \n\tprintk(KERN_DEBUG \"PCI: root bus %02x: using default resources\\n\", bus);\n\tpci_add_resource(resources, &ioport_resource);\n\tpci_add_resource(resources, &iomem_resource);\n}\n\nstruct pci_root_info __init *alloc_pci_root_info(int bus_min, int bus_max,\n\t\t\t\t\t\t int node, int link)\n{\n\tstruct pci_root_info *info;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\n\tif (!info)\n\t\treturn info;\n\n\tsprintf(info->name, \"PCI Bus #%02x\", bus_min);\n\n\tINIT_LIST_HEAD(&info->resources);\n\tinfo->busn.name  = info->name;\n\tinfo->busn.start = bus_min;\n\tinfo->busn.end   = bus_max;\n\tinfo->busn.flags = IORESOURCE_BUS;\n\tinfo->node = node;\n\tinfo->link = link;\n\n\tlist_add_tail(&info->list, &pci_root_infos);\n\n\treturn info;\n}\n\nvoid update_res(struct pci_root_info *info, resource_size_t start,\n\t\tresource_size_t end, unsigned long flags, int merge)\n{\n\tstruct resource *res;\n\tstruct pci_root_res *root_res;\n\n\tif (start > end)\n\t\treturn;\n\n\tif (start == RESOURCE_SIZE_MAX)\n\t\treturn;\n\n\tif (!merge)\n\t\tgoto addit;\n\n\t \n\tlist_for_each_entry(root_res, &info->resources, list) {\n\t\tresource_size_t final_start, final_end;\n\t\tresource_size_t common_start, common_end;\n\n\t\tres = &root_res->res;\n\t\tif (res->flags != flags)\n\t\t\tcontinue;\n\n\t\tcommon_start = max(res->start, start);\n\t\tcommon_end = min(res->end, end);\n\t\tif (common_start > common_end + 1)\n\t\t\tcontinue;\n\n\t\tfinal_start = min(res->start, start);\n\t\tfinal_end = max(res->end, end);\n\n\t\tres->start = final_start;\n\t\tres->end = final_end;\n\t\treturn;\n\t}\n\naddit:\n\n\t \n\troot_res = kzalloc(sizeof(*root_res), GFP_KERNEL);\n\tif (!root_res)\n\t\treturn;\n\n\tres = &root_res->res;\n\tres->name = info->name;\n\tres->flags = flags;\n\tres->start = start;\n\tres->end = end;\n\n\tlist_add_tail(&root_res->list, &info->resources);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}