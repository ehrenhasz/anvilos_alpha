{
  "module_name": "i386.c",
  "hash_id": "d0210cafda0bda47073999db76cdce70bf7611af7162ae1380396f722255dacd",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/pci/i386.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/memblock.h>\n\n#include <asm/memtype.h>\n#include <asm/e820/api.h>\n#include <asm/pci_x86.h>\n#include <asm/io_apic.h>\n\n\n \nstruct pcibios_fwaddrmap {\n\tstruct list_head list;\n\tstruct pci_dev *dev;\n\tresource_size_t fw_addr[DEVICE_COUNT_RESOURCE];\n};\n\nstatic LIST_HEAD(pcibios_fwaddrmappings);\nstatic DEFINE_SPINLOCK(pcibios_fwaddrmap_lock);\nstatic bool pcibios_fw_addr_done;\n\n \nstatic struct pcibios_fwaddrmap *pcibios_fwaddrmap_lookup(struct pci_dev *dev)\n{\n\tstruct pcibios_fwaddrmap *map;\n\n\tlockdep_assert_held(&pcibios_fwaddrmap_lock);\n\n\tlist_for_each_entry(map, &pcibios_fwaddrmappings, list)\n\t\tif (map->dev == dev)\n\t\t\treturn map;\n\n\treturn NULL;\n}\n\nstatic void\npcibios_save_fw_addr(struct pci_dev *dev, int idx, resource_size_t fw_addr)\n{\n\tunsigned long flags;\n\tstruct pcibios_fwaddrmap *map;\n\n\tif (pcibios_fw_addr_done)\n\t\treturn;\n\n\tspin_lock_irqsave(&pcibios_fwaddrmap_lock, flags);\n\tmap = pcibios_fwaddrmap_lookup(dev);\n\tif (!map) {\n\t\tspin_unlock_irqrestore(&pcibios_fwaddrmap_lock, flags);\n\t\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\t\tif (!map)\n\t\t\treturn;\n\n\t\tmap->dev = pci_dev_get(dev);\n\t\tmap->fw_addr[idx] = fw_addr;\n\t\tINIT_LIST_HEAD(&map->list);\n\n\t\tspin_lock_irqsave(&pcibios_fwaddrmap_lock, flags);\n\t\tlist_add_tail(&map->list, &pcibios_fwaddrmappings);\n\t} else\n\t\tmap->fw_addr[idx] = fw_addr;\n\tspin_unlock_irqrestore(&pcibios_fwaddrmap_lock, flags);\n}\n\nresource_size_t pcibios_retrieve_fw_addr(struct pci_dev *dev, int idx)\n{\n\tunsigned long flags;\n\tstruct pcibios_fwaddrmap *map;\n\tresource_size_t fw_addr = 0;\n\n\tif (pcibios_fw_addr_done)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&pcibios_fwaddrmap_lock, flags);\n\tmap = pcibios_fwaddrmap_lookup(dev);\n\tif (map)\n\t\tfw_addr = map->fw_addr[idx];\n\tspin_unlock_irqrestore(&pcibios_fwaddrmap_lock, flags);\n\n\treturn fw_addr;\n}\n\nstatic void __init pcibios_fw_addr_list_del(void)\n{\n\tunsigned long flags;\n\tstruct pcibios_fwaddrmap *entry, *next;\n\n\tspin_lock_irqsave(&pcibios_fwaddrmap_lock, flags);\n\tlist_for_each_entry_safe(entry, next, &pcibios_fwaddrmappings, list) {\n\t\tlist_del(&entry->list);\n\t\tpci_dev_put(entry->dev);\n\t\tkfree(entry);\n\t}\n\tspin_unlock_irqrestore(&pcibios_fwaddrmap_lock, flags);\n\tpcibios_fw_addr_done = true;\n}\n\nstatic int\nskip_isa_ioresource_align(struct pci_dev *dev) {\n\n\tif ((pci_probe & PCI_CAN_SKIP_ISA_ALIGN) &&\n\t    !(dev->bus->bridge_ctl & PCI_BRIDGE_CTL_ISA))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nresource_size_t\npcibios_align_resource(void *data, const struct resource *res,\n\t\t\tresource_size_t size, resource_size_t align)\n{\n\tstruct pci_dev *dev = data;\n\tresource_size_t start = res->start;\n\n\tif (res->flags & IORESOURCE_IO) {\n\t\tif (skip_isa_ioresource_align(dev))\n\t\t\treturn start;\n\t\tif (start & 0x300)\n\t\t\tstart = (start + 0x3ff) & ~0x3ff;\n\t} else if (res->flags & IORESOURCE_MEM) {\n\t\t \n\t\tif (start < BIOS_END)\n\t\t\tstart = BIOS_END;\n\t}\n\treturn start;\n}\nEXPORT_SYMBOL(pcibios_align_resource);\n\n \n\nstatic void pcibios_allocate_bridge_resources(struct pci_dev *dev)\n{\n\tint idx;\n\tstruct resource *r;\n\n\tfor (idx = PCI_BRIDGE_RESOURCES; idx < PCI_NUM_RESOURCES; idx++) {\n\t\tr = &dev->resource[idx];\n\t\tif (!r->flags)\n\t\t\tcontinue;\n\t\tif (r->parent)\t \n\t\t\tcontinue;\n\t\tif (!r->start || pci_claim_bridge_resource(dev, idx) < 0) {\n\t\t\t \n\t\t\tr->start = r->end = 0;\n\t\t\tr->flags = 0;\n\t\t}\n\t}\n}\n\nstatic void pcibios_allocate_bus_resources(struct pci_bus *bus)\n{\n\tstruct pci_bus *child;\n\n\t \n\tif (bus->self)\n\t\tpcibios_allocate_bridge_resources(bus->self);\n\tlist_for_each_entry(child, &bus->children, node)\n\t\tpcibios_allocate_bus_resources(child);\n}\n\nstruct pci_check_idx_range {\n\tint start;\n\tint end;\n};\n\nstatic void pcibios_allocate_dev_resources(struct pci_dev *dev, int pass)\n{\n\tint idx, disabled, i;\n\tu16 command;\n\tstruct resource *r;\n\n\tstruct pci_check_idx_range idx_range[] = {\n\t\t{ PCI_STD_RESOURCES, PCI_STD_RESOURCE_END },\n#ifdef CONFIG_PCI_IOV\n\t\t{ PCI_IOV_RESOURCES, PCI_IOV_RESOURCE_END },\n#endif\n\t};\n\n\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\tfor (i = 0; i < ARRAY_SIZE(idx_range); i++)\n\t\tfor (idx = idx_range[i].start; idx <= idx_range[i].end; idx++) {\n\t\t\tr = &dev->resource[idx];\n\t\t\tif (r->parent)\t \n\t\t\t\tcontinue;\n\t\t\tif (!r->start)\t \n\t\t\t\tcontinue;\n\t\t\tif (r->flags & IORESOURCE_IO)\n\t\t\t\tdisabled = !(command & PCI_COMMAND_IO);\n\t\t\telse\n\t\t\t\tdisabled = !(command & PCI_COMMAND_MEMORY);\n\t\t\tif (pass == disabled) {\n\t\t\t\tdev_dbg(&dev->dev,\n\t\t\t\t\t\"BAR %d: reserving %pr (d=%d, p=%d)\\n\",\n\t\t\t\t\tidx, r, disabled, pass);\n\t\t\t\tif (pci_claim_resource(dev, idx) < 0) {\n\t\t\t\t\tif (r->flags & IORESOURCE_PCI_FIXED) {\n\t\t\t\t\t\tdev_info(&dev->dev, \"BAR %d %pR is immovable\\n\",\n\t\t\t\t\t\t\t idx, r);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\tpcibios_save_fw_addr(dev,\n\t\t\t\t\t\t\t\tidx, r->start);\n\t\t\t\t\t\tr->end -= r->start;\n\t\t\t\t\t\tr->start = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif (!pass) {\n\t\tr = &dev->resource[PCI_ROM_RESOURCE];\n\t\tif (r->flags & IORESOURCE_ROM_ENABLE) {\n\t\t\t \n\t\t\tu32 reg;\n\t\t\tdev_dbg(&dev->dev, \"disabling ROM %pR\\n\", r);\n\t\t\tr->flags &= ~IORESOURCE_ROM_ENABLE;\n\t\t\tpci_read_config_dword(dev, dev->rom_base_reg, &reg);\n\t\t\tpci_write_config_dword(dev, dev->rom_base_reg,\n\t\t\t\t\t\treg & ~PCI_ROM_ADDRESS_ENABLE);\n\t\t}\n\t}\n}\n\nstatic void pcibios_allocate_resources(struct pci_bus *bus, int pass)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tpcibios_allocate_dev_resources(dev, pass);\n\n\t\tchild = dev->subordinate;\n\t\tif (child)\n\t\t\tpcibios_allocate_resources(child, pass);\n\t}\n}\n\nstatic void pcibios_allocate_dev_rom_resource(struct pci_dev *dev)\n{\n\tstruct resource *r;\n\n\t \n\tr = &dev->resource[PCI_ROM_RESOURCE];\n\tif (!r->flags || !r->start)\n\t\treturn;\n\tif (r->parent)  \n\t\treturn;\n\n\tif (pci_claim_resource(dev, PCI_ROM_RESOURCE) < 0) {\n\t\tr->end -= r->start;\n\t\tr->start = 0;\n\t}\n}\nstatic void pcibios_allocate_rom_resources(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tpcibios_allocate_dev_rom_resource(dev);\n\n\t\tchild = dev->subordinate;\n\t\tif (child)\n\t\t\tpcibios_allocate_rom_resources(child);\n\t}\n}\n\nstatic int __init pcibios_assign_resources(void)\n{\n\tstruct pci_bus *bus;\n\n\tif (!(pci_probe & PCI_ASSIGN_ROMS))\n\t\tlist_for_each_entry(bus, &pci_root_buses, node)\n\t\t\tpcibios_allocate_rom_resources(bus);\n\n\tpci_assign_unassigned_resources();\n\tpcibios_fw_addr_list_del();\n\n\treturn 0;\n}\n\n \nfs_initcall(pcibios_assign_resources);\n\nvoid pcibios_resource_survey_bus(struct pci_bus *bus)\n{\n\tdev_printk(KERN_DEBUG, &bus->dev, \"Allocating resources\\n\");\n\n\tpcibios_allocate_bus_resources(bus);\n\n\tpcibios_allocate_resources(bus, 0);\n\tpcibios_allocate_resources(bus, 1);\n\n\tif (!(pci_probe & PCI_ASSIGN_ROMS))\n\t\tpcibios_allocate_rom_resources(bus);\n}\n\nvoid __init pcibios_resource_survey(void)\n{\n\tstruct pci_bus *bus;\n\n\tDBG(\"PCI: Allocating resources\\n\");\n\n\tlist_for_each_entry(bus, &pci_root_buses, node)\n\t\tpcibios_allocate_bus_resources(bus);\n\n\tlist_for_each_entry(bus, &pci_root_buses, node)\n\t\tpcibios_allocate_resources(bus, 0);\n\tlist_for_each_entry(bus, &pci_root_buses, node)\n\t\tpcibios_allocate_resources(bus, 1);\n\n\te820__reserve_resources_late();\n\t \n\tioapic_insert_resources();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}