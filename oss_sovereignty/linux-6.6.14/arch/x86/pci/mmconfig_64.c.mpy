{
  "module_name": "mmconfig_64.c",
  "hash_id": "f1803af3b4b14717a0512d8f1d05493394405a4fafcf0517cc9cf5843729f7c0",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/pci/mmconfig_64.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/acpi.h>\n#include <linux/bitmap.h>\n#include <linux/rcupdate.h>\n#include <asm/e820/api.h>\n#include <asm/pci_x86.h>\n\n#define PREFIX \"PCI: \"\n\nstatic char __iomem *pci_dev_base(unsigned int seg, unsigned int bus, unsigned int devfn)\n{\n\tstruct pci_mmcfg_region *cfg = pci_mmconfig_lookup(seg, bus);\n\n\tif (cfg && cfg->virt)\n\t\treturn cfg->virt + (PCI_MMCFG_BUS_OFFSET(bus) | (devfn << 12));\n\treturn NULL;\n}\n\nstatic int pci_mmcfg_read(unsigned int seg, unsigned int bus,\n\t\t\t  unsigned int devfn, int reg, int len, u32 *value)\n{\n\tchar __iomem *addr;\n\n\t \n\tif (unlikely((bus > 255) || (devfn > 255) || (reg > 4095))) {\nerr:\t\t*value = -1;\n\t\treturn -EINVAL;\n\t}\n\n\trcu_read_lock();\n\taddr = pci_dev_base(seg, bus, devfn);\n\tif (!addr) {\n\t\trcu_read_unlock();\n\t\tgoto err;\n\t}\n\n\tswitch (len) {\n\tcase 1:\n\t\t*value = mmio_config_readb(addr + reg);\n\t\tbreak;\n\tcase 2:\n\t\t*value = mmio_config_readw(addr + reg);\n\t\tbreak;\n\tcase 4:\n\t\t*value = mmio_config_readl(addr + reg);\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic int pci_mmcfg_write(unsigned int seg, unsigned int bus,\n\t\t\t   unsigned int devfn, int reg, int len, u32 value)\n{\n\tchar __iomem *addr;\n\n\t \n\tif (unlikely((bus > 255) || (devfn > 255) || (reg > 4095)))\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\taddr = pci_dev_base(seg, bus, devfn);\n\tif (!addr) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (len) {\n\tcase 1:\n\t\tmmio_config_writeb(addr + reg, value);\n\t\tbreak;\n\tcase 2:\n\t\tmmio_config_writew(addr + reg, value);\n\t\tbreak;\n\tcase 4:\n\t\tmmio_config_writel(addr + reg, value);\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nconst struct pci_raw_ops pci_mmcfg = {\n\t.read =\t\tpci_mmcfg_read,\n\t.write =\tpci_mmcfg_write,\n};\n\nstatic void __iomem *mcfg_ioremap(struct pci_mmcfg_region *cfg)\n{\n\tvoid __iomem *addr;\n\tu64 start, size;\n\tint num_buses;\n\n\tstart = cfg->address + PCI_MMCFG_BUS_OFFSET(cfg->start_bus);\n\tnum_buses = cfg->end_bus - cfg->start_bus + 1;\n\tsize = PCI_MMCFG_BUS_OFFSET(num_buses);\n\taddr = ioremap(start, size);\n\tif (addr)\n\t\taddr -= PCI_MMCFG_BUS_OFFSET(cfg->start_bus);\n\treturn addr;\n}\n\nint __init pci_mmcfg_arch_init(void)\n{\n\tstruct pci_mmcfg_region *cfg;\n\n\tlist_for_each_entry(cfg, &pci_mmcfg_list, list)\n\t\tif (pci_mmcfg_arch_map(cfg)) {\n\t\t\tpci_mmcfg_arch_free();\n\t\t\treturn 0;\n\t\t}\n\n\traw_pci_ext_ops = &pci_mmcfg;\n\n\treturn 1;\n}\n\nvoid __init pci_mmcfg_arch_free(void)\n{\n\tstruct pci_mmcfg_region *cfg;\n\n\tlist_for_each_entry(cfg, &pci_mmcfg_list, list)\n\t\tpci_mmcfg_arch_unmap(cfg);\n}\n\nint pci_mmcfg_arch_map(struct pci_mmcfg_region *cfg)\n{\n\tcfg->virt = mcfg_ioremap(cfg);\n\tif (!cfg->virt) {\n\t\tpr_err(PREFIX \"can't map MMCONFIG at %pR\\n\", &cfg->res);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid pci_mmcfg_arch_unmap(struct pci_mmcfg_region *cfg)\n{\n\tif (cfg && cfg->virt) {\n\t\tiounmap(cfg->virt + PCI_MMCFG_BUS_OFFSET(cfg->start_bus));\n\t\tcfg->virt = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}