{
  "module_name": "fixup.c",
  "hash_id": "42ef2e6576e94a33978a9d94b8efc7d4103d7f11d21bab2ea4e8084cb8d093e4",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/pci/fixup.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/pci.h>\n#include <linux/suspend.h>\n#include <linux/vgaarb.h>\n#include <asm/amd_nb.h>\n#include <asm/hpet.h>\n#include <asm/pci_x86.h>\n\nstatic void pci_fixup_i450nx(struct pci_dev *d)\n{\n\t \n\tint pxb, reg;\n\tu8 busno, suba, subb;\n\n\tdev_warn(&d->dev, \"Searching for i450NX host bridges\\n\");\n\treg = 0xd0;\n\tfor(pxb = 0; pxb < 2; pxb++) {\n\t\tpci_read_config_byte(d, reg++, &busno);\n\t\tpci_read_config_byte(d, reg++, &suba);\n\t\tpci_read_config_byte(d, reg++, &subb);\n\t\tdev_dbg(&d->dev, \"i450NX PXB %d: %02x/%02x/%02x\\n\", pxb, busno,\n\t\t\tsuba, subb);\n\t\tif (busno)\n\t\t\tpcibios_scan_root(busno);\t \n\t\tif (suba < subb)\n\t\t\tpcibios_scan_root(suba+1);\t \n\t}\n\tpcibios_last_bus = -1;\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82451NX, pci_fixup_i450nx);\n\nstatic void pci_fixup_i450gx(struct pci_dev *d)\n{\n\t \n\tu8 busno;\n\tpci_read_config_byte(d, 0x4a, &busno);\n\tdev_info(&d->dev, \"i440KX/GX host bridge; secondary bus %02x\\n\", busno);\n\tpcibios_scan_root(busno);\n\tpcibios_last_bus = -1;\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82454GX, pci_fixup_i450gx);\n\nstatic void pci_fixup_umc_ide(struct pci_dev *d)\n{\n\t \n\tint i;\n\n\tdev_warn(&d->dev, \"Fixing base address flags\\n\");\n\tfor(i = 0; i < 4; i++)\n\t\td->resource[i].flags |= PCI_BASE_ADDRESS_SPACE_IO;\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_UMC, PCI_DEVICE_ID_UMC_UM8886BF, pci_fixup_umc_ide);\n\nstatic void pci_fixup_latency(struct pci_dev *d)\n{\n\t \n\tdev_dbg(&d->dev, \"Setting max latency to 32\\n\");\n\tpcibios_max_latency = 32;\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_5597, pci_fixup_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_5598, pci_fixup_latency);\n\nstatic void pci_fixup_piix4_acpi(struct pci_dev *d)\n{\n\t \n\td->irq = 9;\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371AB_3, pci_fixup_piix4_acpi);\n\n \n\n#define VIA_8363_KL133_REVISION_ID 0x81\n#define VIA_8363_KM133_REVISION_ID 0x84\n\nstatic void pci_fixup_via_northbridge_bug(struct pci_dev *d)\n{\n\tu8 v;\n\tint where = 0x55;\n\tint mask = 0x1f;  \n\n\tif (d->device == PCI_DEVICE_ID_VIA_8367_0) {\n\t\t \n\t\tpci_write_config_byte(d, PCI_LATENCY_TIMER, 0);\n\n\t\twhere = 0x95;  \n\t} else if (d->device == PCI_DEVICE_ID_VIA_8363_0 &&\n\t\t\t(d->revision == VIA_8363_KL133_REVISION_ID ||\n\t\t\td->revision == VIA_8363_KM133_REVISION_ID)) {\n\t\t\tmask = 0x3f;  \n\t}\n\n\tpci_read_config_byte(d, where, &v);\n\tif (v & ~mask) {\n\t\tdev_warn(&d->dev, \"Disabling VIA memory write queue (PCI ID %04x, rev %02x): [%02x] %02x & %02x -> %02x\\n\", \\\n\t\t\td->device, d->revision, where, v, mask, v & mask);\n\t\tv &= mask;\n\t\tpci_write_config_byte(d, where, v);\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8363_0, pci_fixup_via_northbridge_bug);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8622, pci_fixup_via_northbridge_bug);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8361, pci_fixup_via_northbridge_bug);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8367_0, pci_fixup_via_northbridge_bug);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8363_0, pci_fixup_via_northbridge_bug);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8622, pci_fixup_via_northbridge_bug);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8361, pci_fixup_via_northbridge_bug);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8367_0, pci_fixup_via_northbridge_bug);\n\n \nstatic void pci_fixup_transparent_bridge(struct pci_dev *dev)\n{\n\tif ((dev->device & 0xff00) == 0x2400)\n\t\tdev->transparent = 1;\n}\nDECLARE_PCI_FIXUP_CLASS_HEADER(PCI_VENDOR_ID_INTEL, PCI_ANY_ID,\n\t\t\t PCI_CLASS_BRIDGE_PCI, 8, pci_fixup_transparent_bridge);\n\n \nstatic void pci_fixup_nforce2(struct pci_dev *dev)\n{\n\tu32 val;\n\n\t \n\tpci_read_config_dword(dev, 0x6c, &val);\n\n\t \n\tif ((val & 0x00FF0000) != 0x00010000) {\n\t\tdev_warn(&dev->dev, \"nForce2 C1 Halt Disconnect fixup\\n\");\n\t\tpci_write_config_dword(dev, 0x6c, (val & 0xFF00FFFF) | 0x00010000);\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE2, pci_fixup_nforce2);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE2, pci_fixup_nforce2);\n\n \n#define MAX_PCIEROOT\t6\nstatic int quirk_aspm_offset[MAX_PCIEROOT << 3];\n\n#define GET_INDEX(a, b) ((((a) - PCI_DEVICE_ID_INTEL_MCH_PA) << 3) + ((b) & 7))\n\nstatic int quirk_pcie_aspm_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 *value)\n{\n\treturn raw_pci_read(pci_domain_nr(bus), bus->number,\n\t\t\t\t\t\tdevfn, where, size, value);\n}\n\n \nstatic int quirk_pcie_aspm_write(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 value)\n{\n\tu8 offset;\n\n\toffset = quirk_aspm_offset[GET_INDEX(bus->self->device, devfn)];\n\n\tif ((offset) && (where == offset))\n\t\tvalue = value & ~PCI_EXP_LNKCTL_ASPMC;\n\n\treturn raw_pci_write(pci_domain_nr(bus), bus->number,\n\t\t\t\t\t\tdevfn, where, size, value);\n}\n\nstatic struct pci_ops quirk_pcie_aspm_ops = {\n\t.read = quirk_pcie_aspm_read,\n\t.write = quirk_pcie_aspm_write,\n};\n\n \nstatic void pcie_rootport_aspm_quirk(struct pci_dev *pdev)\n{\n\tint i;\n\tstruct pci_bus  *pbus;\n\tstruct pci_dev *dev;\n\n\tif ((pbus = pdev->subordinate) == NULL)\n\t\treturn;\n\n\t \n\tif ((pdev->device < PCI_DEVICE_ID_INTEL_MCH_PA) ||\n\t    (pdev->device > PCI_DEVICE_ID_INTEL_MCH_PC1))\n\t\treturn;\n\n\tif (list_empty(&pbus->devices)) {\n\t\t \n\t\tfor (i = GET_INDEX(pdev->device, 0); i <= GET_INDEX(pdev->device, 7); ++i)\n\t\t\tquirk_aspm_offset[i] = 0;\n\n\t\tpci_bus_set_ops(pbus, pbus->parent->ops);\n\t} else {\n\t\t \n\t\tlist_for_each_entry(dev, &pbus->devices, bus_list)\n\t\t\t \n\t\t\tquirk_aspm_offset[GET_INDEX(pdev->device, dev->devfn)] =\n\t\t\t\tdev->pcie_cap + PCI_EXP_LNKCTL;\n\n\t\tpci_bus_set_ops(pbus, &quirk_pcie_aspm_ops);\n\t\tdev_info(&pbus->dev, \"writes to ASPM control bits will be ignored\\n\");\n\t}\n\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_MCH_PA,\tpcie_rootport_aspm_quirk);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_MCH_PA1,\tpcie_rootport_aspm_quirk);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_MCH_PB,\tpcie_rootport_aspm_quirk);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_MCH_PB1,\tpcie_rootport_aspm_quirk);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_MCH_PC,\tpcie_rootport_aspm_quirk);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_MCH_PC1,\tpcie_rootport_aspm_quirk);\n\n \n\nstatic void pci_fixup_video(struct pci_dev *pdev)\n{\n\tstruct pci_dev *bridge;\n\tstruct pci_bus *bus;\n\tu16 config;\n\tstruct resource *res;\n\n\t \n\tbus = pdev->bus;\n\twhile (bus) {\n\t\tbridge = bus->self;\n\n\t\t \n\t\tif (bridge && (pci_is_bridge(bridge))) {\n\t\t\tpci_read_config_word(bridge, PCI_BRIDGE_CONTROL,\n\t\t\t\t\t\t&config);\n\t\t\tif (!(config & PCI_BRIDGE_CTL_VGA))\n\t\t\t\treturn;\n\t\t}\n\t\tbus = bus->parent;\n\t}\n\tif (!vga_default_device() || pdev == vga_default_device()) {\n\t\tpci_read_config_word(pdev, PCI_COMMAND, &config);\n\t\tif (config & (PCI_COMMAND_IO | PCI_COMMAND_MEMORY)) {\n\t\t\tres = &pdev->resource[PCI_ROM_RESOURCE];\n\n\t\t\tpci_disable_rom(pdev);\n\t\t\tif (res->parent)\n\t\t\t\trelease_resource(res);\n\n\t\t\tres->start = 0xC0000;\n\t\t\tres->end = res->start + 0x20000 - 1;\n\t\t\tres->flags = IORESOURCE_MEM | IORESOURCE_ROM_SHADOW |\n\t\t\t\t     IORESOURCE_PCI_FIXED;\n\t\t\tdev_info(&pdev->dev, \"Video device with shadowed ROM at %pR\\n\",\n\t\t\t\t res);\n\t\t}\n\t}\n}\nDECLARE_PCI_FIXUP_CLASS_HEADER(PCI_ANY_ID, PCI_ANY_ID,\n\t\t\t       PCI_CLASS_DISPLAY_VGA, 8, pci_fixup_video);\n\n\nstatic const struct dmi_system_id msi_k8t_dmi_table[] = {\n\t{\n\t\t.ident = \"MSI-K8T-Neo2Fir\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MSI\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MS-6702E\"),\n\t\t},\n\t},\n\t{}\n};\n\n \nstatic void pci_fixup_msi_k8t_onboard_sound(struct pci_dev *dev)\n{\n\tunsigned char val;\n\tif (!dmi_check_system(msi_k8t_dmi_table))\n\t\treturn;  \n\n\tpci_read_config_byte(dev, 0x50, &val);\n\tif (val & 0x40) {\n\t\tpci_write_config_byte(dev, 0x50, val & (~0x40));\n\n\t\t \n\t\tpci_read_config_byte(dev, 0x50, &val);\n\t\tif (val & 0x40)\n\t\t\tdev_info(&dev->dev, \"Detected MSI K8T Neo2-FIR; \"\n\t\t\t\t\t\"can't enable onboard soundcard!\\n\");\n\t\telse\n\t\t\tdev_info(&dev->dev, \"Detected MSI K8T Neo2-FIR; \"\n\t\t\t\t\t\"enabled onboard soundcard\\n\");\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8237,\n\t\tpci_fixup_msi_k8t_onboard_sound);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8237,\n\t\tpci_fixup_msi_k8t_onboard_sound);\n\n \nstatic u16 toshiba_line_size;\n\nstatic const struct dmi_system_id toshiba_ohci1394_dmi_table[] = {\n\t{\n\t\t.ident = \"Toshiba PS5 based laptop\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"PS5\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Toshiba PSM4 based laptop\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"PSM4\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Toshiba A40 based laptop\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"PSA40U\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic void pci_pre_fixup_toshiba_ohci1394(struct pci_dev *dev)\n{\n\tif (!dmi_check_system(toshiba_ohci1394_dmi_table))\n\t\treturn;  \n\n\tdev->current_state = PCI_D3cold;\n\tpci_read_config_word(dev, PCI_CACHE_LINE_SIZE, &toshiba_line_size);\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_TI, 0x8032,\n\t\t\t pci_pre_fixup_toshiba_ohci1394);\n\nstatic void pci_post_fixup_toshiba_ohci1394(struct pci_dev *dev)\n{\n\tif (!dmi_check_system(toshiba_ohci1394_dmi_table))\n\t\treturn;  \n\n\t \n\tpci_write_config_word(dev, PCI_CACHE_LINE_SIZE, toshiba_line_size);\n\tpci_read_config_byte(dev, PCI_INTERRUPT_LINE, (u8 *)&dev->irq);\n\tpci_write_config_dword(dev, PCI_BASE_ADDRESS_0,\n\t\t\t       pci_resource_start(dev, 0));\n\tpci_write_config_dword(dev, PCI_BASE_ADDRESS_1,\n\t\t\t       pci_resource_start(dev, 1));\n}\nDECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_TI, 0x8032,\n\t\t\t pci_post_fixup_toshiba_ohci1394);\n\n\n \nstatic void pci_early_fixup_cyrix_5530(struct pci_dev *dev)\n{\n\tu8 r;\n\t \n\tpci_read_config_byte(dev, 0x42, &r);\n\tr &= 0xfd;\n\tpci_write_config_byte(dev, 0x42, r);\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_CYRIX, PCI_DEVICE_ID_CYRIX_5530_LEGACY,\n\t\t\tpci_early_fixup_cyrix_5530);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_CYRIX, PCI_DEVICE_ID_CYRIX_5530_LEGACY,\n\t\t\tpci_early_fixup_cyrix_5530);\n\n \nstatic void pci_siemens_interrupt_controller(struct pci_dev *dev)\n{\n\tdev->resource[0].flags |= IORESOURCE_PCI_FIXED;\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SIEMENS, 0x0015,\n\t\t\t  pci_siemens_interrupt_controller);\n\n \nstatic void sb600_disable_hpet_bar(struct pci_dev *dev)\n{\n\tu8 val;\n\n\t \n\n\tpci_read_config_byte(dev, 0x08, &val);\n\n\tif (val < 0x2F) {\n\t\toutb(0x55, 0xCD6);\n\t\tval = inb(0xCD7);\n\n\t\t \n\t\toutb(0x55, 0xCD6);\n\t\toutb(val | 0x80, 0xCD7);\n\t}\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_ATI, 0x4385, sb600_disable_hpet_bar);\n\n#ifdef CONFIG_HPET_TIMER\nstatic void sb600_hpet_quirk(struct pci_dev *dev)\n{\n\tstruct resource *r = &dev->resource[1];\n\n\tif (r->flags & IORESOURCE_MEM && r->start == hpet_address) {\n\t\tr->flags |= IORESOURCE_PCI_FIXED;\n\t\tdev_info(&dev->dev, \"reg 0x14 contains HPET; making it immovable\\n\");\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATI, 0x4385, sb600_hpet_quirk);\n#endif\n\n \nstatic void twinhead_reserve_killing_zone(struct pci_dev *dev)\n{\n        if (dev->subsystem_vendor == 0x14FF && dev->subsystem_device == 0xA003) {\n                pr_info(\"Reserving memory on Twinhead H12Y\\n\");\n                request_mem_region(0xFFB00000, 0x100000, \"twinhead\");\n        }\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x27B9, twinhead_reserve_killing_zone);\n\n \nstatic void pci_invalid_bar(struct pci_dev *dev)\n{\n\tdev->non_compliant_bars = 1;\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x2fc0, pci_invalid_bar);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x6f60, pci_invalid_bar);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x6fa0, pci_invalid_bar);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x6fc0, pci_invalid_bar);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0xa1ec, pci_invalid_bar);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0xa1ed, pci_invalid_bar);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0xa26c, pci_invalid_bar);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0xa26d, pci_invalid_bar);\n\n \nstatic void pci_fixup_amd_ehci_pme(struct pci_dev *dev)\n{\n\tdev_info(&dev->dev, \"PME# does not work under D3, disabling it\\n\");\n\tdev->pme_support &= ~((PCI_PM_CAP_PME_D3hot | PCI_PM_CAP_PME_D3cold)\n\t\t>> PCI_PM_CAP_PME_SHIFT);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, 0x7808, pci_fixup_amd_ehci_pme);\n\n \nstatic void pci_fixup_amd_fch_xhci_pme(struct pci_dev *dev)\n{\n\tdev_info(&dev->dev, \"PME# does not work under D0, disabling it\\n\");\n\tdev->pme_support &= ~(PCI_PM_CAP_PME_D0 >> PCI_PM_CAP_PME_SHIFT);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, 0x7914, pci_fixup_amd_fch_xhci_pme);\n\n \nstatic void quirk_apple_mbp_poweroff(struct pci_dev *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\n\tif ((!dmi_match(DMI_PRODUCT_NAME, \"MacBookPro11,4\") &&\n\t     !dmi_match(DMI_PRODUCT_NAME, \"MacBookPro11,5\")) ||\n\t    pdev->bus->number != 0 || pdev->devfn != PCI_DEVFN(0x1c, 0))\n\t\treturn;\n\n\tres = request_mem_region(0x7fa00000, 0x200000,\n\t\t\t\t \"MacBook Pro poweroff workaround\");\n\tif (res)\n\t\tdev_info(dev, \"claimed %s %pR\\n\", res->name, res);\n\telse\n\t\tdev_info(dev, \"can't work around MacBook Pro poweroff issue\\n\");\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x8c10, quirk_apple_mbp_poweroff);\n\n \nstatic void quirk_no_aersid(struct pci_dev *pdev)\n{\n\t \n\tif (is_vmd(pdev->bus) && pci_is_root_bus(pdev->bus))\n\t\tpdev->bus->bus_flags |= PCI_BUS_FLAGS_NO_AERSID;\n}\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, PCI_ANY_ID,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8, quirk_no_aersid);\n\nstatic void quirk_intel_th_dnv(struct pci_dev *dev)\n{\n\tstruct resource *r = &dev->resource[4];\n\n\t \n\tif (r->end == r->start + 0x7ff) {\n\t\tr->start = 0;\n\t\tr->end   = 0x3fffff;\n\t\tr->flags |= IORESOURCE_UNSET;\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x19e1, quirk_intel_th_dnv);\n\n#ifdef CONFIG_PHYS_ADDR_T_64BIT\n\n#define AMD_141b_MMIO_BASE(x)\t(0x80 + (x) * 0x8)\n#define AMD_141b_MMIO_BASE_RE_MASK\t\tBIT(0)\n#define AMD_141b_MMIO_BASE_WE_MASK\t\tBIT(1)\n#define AMD_141b_MMIO_BASE_MMIOBASE_MASK\tGENMASK(31,8)\n\n#define AMD_141b_MMIO_LIMIT(x)\t(0x84 + (x) * 0x8)\n#define AMD_141b_MMIO_LIMIT_MMIOLIMIT_MASK\tGENMASK(31,8)\n\n#define AMD_141b_MMIO_HIGH(x)\t(0x180 + (x) * 0x4)\n#define AMD_141b_MMIO_HIGH_MMIOBASE_MASK\tGENMASK(7,0)\n#define AMD_141b_MMIO_HIGH_MMIOLIMIT_SHIFT\t16\n#define AMD_141b_MMIO_HIGH_MMIOLIMIT_MASK\tGENMASK(23,16)\n\n \nstatic void pci_amd_enable_64bit_bar(struct pci_dev *dev)\n{\n\tstatic const char *name = \"PCI Bus 0000:00\";\n\tstruct resource *res, *conflict;\n\tu32 base, limit, high;\n\tstruct pci_dev *other;\n\tunsigned i;\n\n\tif (!(pci_probe & PCI_BIG_ROOT_WINDOW))\n\t\treturn;\n\n\t \n\tother = pci_get_device(dev->vendor, dev->device, NULL);\n\tif (other != dev ||\n\t    (other = pci_get_device(dev->vendor, dev->device, other))) {\n\t\t \n\t\tpci_dev_put(other);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tpci_read_config_dword(dev, AMD_141b_MMIO_BASE(i), &base);\n\t\tpci_read_config_dword(dev, AMD_141b_MMIO_HIGH(i), &high);\n\n\t\t \n\t\tif (!(base & (AMD_141b_MMIO_BASE_RE_MASK |\n\t\t\t      AMD_141b_MMIO_BASE_WE_MASK)))\n\t\t\tbreak;\n\n\t\tbase >>= 8;\n\t\tbase |= high << 24;\n\n\t\t \n\t\tif (base > 0x10000)\n\t\t\treturn;\n\t}\n\tif (i == 8)\n\t\treturn;\n\n\tres = kzalloc(sizeof(*res), GFP_KERNEL);\n\tif (!res)\n\t\treturn;\n\n\t \n\tres->name = name;\n\tres->flags = IORESOURCE_PREFETCH | IORESOURCE_MEM |\n\t\tIORESOURCE_MEM_64 | IORESOURCE_WINDOW;\n\tres->start = 0xbd00000000ull;\n\tres->end = 0xfd00000000ull - 1;\n\n\tconflict = request_resource_conflict(&iomem_resource, res);\n\tif (conflict) {\n\t\tkfree(res);\n\t\tif (conflict->name != name)\n\t\t\treturn;\n\n\t\t \n\t\tres = conflict;\n\t} else {\n\t\tdev_info(&dev->dev, \"adding root bus resource %pR (tainting kernel)\\n\",\n\t\t\t res);\n\t\tadd_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);\n\t\tpci_bus_add_resource(dev->bus, res, 0);\n\t}\n\n\tbase = ((res->start >> 8) & AMD_141b_MMIO_BASE_MMIOBASE_MASK) |\n\t\tAMD_141b_MMIO_BASE_RE_MASK | AMD_141b_MMIO_BASE_WE_MASK;\n\tlimit = ((res->end + 1) >> 8) & AMD_141b_MMIO_LIMIT_MMIOLIMIT_MASK;\n\thigh = ((res->start >> 40) & AMD_141b_MMIO_HIGH_MMIOBASE_MASK) |\n\t\t((((res->end + 1) >> 40) << AMD_141b_MMIO_HIGH_MMIOLIMIT_SHIFT)\n\t\t & AMD_141b_MMIO_HIGH_MMIOLIMIT_MASK);\n\n\tpci_write_config_dword(dev, AMD_141b_MMIO_HIGH(i), high);\n\tpci_write_config_dword(dev, AMD_141b_MMIO_LIMIT(i), limit);\n\tpci_write_config_dword(dev, AMD_141b_MMIO_BASE(i), base);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, 0x1401, pci_amd_enable_64bit_bar);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, 0x141b, pci_amd_enable_64bit_bar);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, 0x1571, pci_amd_enable_64bit_bar);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, 0x15b1, pci_amd_enable_64bit_bar);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, 0x1601, pci_amd_enable_64bit_bar);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_AMD, 0x1401, pci_amd_enable_64bit_bar);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_AMD, 0x141b, pci_amd_enable_64bit_bar);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_AMD, 0x1571, pci_amd_enable_64bit_bar);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_AMD, 0x15b1, pci_amd_enable_64bit_bar);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_AMD, 0x1601, pci_amd_enable_64bit_bar);\n\n#define RS690_LOWER_TOP_OF_DRAM2\t0x30\n#define RS690_LOWER_TOP_OF_DRAM2_VALID\t0x1\n#define RS690_UPPER_TOP_OF_DRAM2\t0x31\n#define RS690_HTIU_NB_INDEX\t\t0xA8\n#define RS690_HTIU_NB_INDEX_WR_ENABLE\t0x100\n#define RS690_HTIU_NB_DATA\t\t0xAC\n\n \nstatic void rs690_fix_64bit_dma(struct pci_dev *pdev)\n{\n\tu32 val = 0;\n\tphys_addr_t top_of_dram = __pa(high_memory - 1) + 1;\n\n\tif (top_of_dram <= (1ULL << 32))\n\t\treturn;\n\n\tpci_write_config_dword(pdev, RS690_HTIU_NB_INDEX,\n\t\t\t\tRS690_LOWER_TOP_OF_DRAM2);\n\tpci_read_config_dword(pdev, RS690_HTIU_NB_DATA, &val);\n\n\tif (val)\n\t\treturn;\n\n\tpci_info(pdev, \"Adjusting top of DRAM to %pa for 64-bit DMA support\\n\", &top_of_dram);\n\n\tpci_write_config_dword(pdev, RS690_HTIU_NB_INDEX,\n\t\tRS690_UPPER_TOP_OF_DRAM2 | RS690_HTIU_NB_INDEX_WR_ENABLE);\n\tpci_write_config_dword(pdev, RS690_HTIU_NB_DATA, top_of_dram >> 32);\n\n\tpci_write_config_dword(pdev, RS690_HTIU_NB_INDEX,\n\t\tRS690_LOWER_TOP_OF_DRAM2 | RS690_HTIU_NB_INDEX_WR_ENABLE);\n\tpci_write_config_dword(pdev, RS690_HTIU_NB_DATA,\n\t\ttop_of_dram | RS690_LOWER_TOP_OF_DRAM2_VALID);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x7910, rs690_fix_64bit_dma);\n\n#endif\n\n#ifdef CONFIG_AMD_NB\n\n#define AMD_15B8_RCC_DEV2_EPF0_STRAP2                                  0x10136008\n#define AMD_15B8_RCC_DEV2_EPF0_STRAP2_NO_SOFT_RESET_DEV2_F0_MASK       0x00000080L\n\nstatic void quirk_clear_strap_no_soft_reset_dev2_f0(struct pci_dev *dev)\n{\n\tu32 data;\n\n\tif (!amd_smn_read(0, AMD_15B8_RCC_DEV2_EPF0_STRAP2, &data)) {\n\t\tdata &= ~AMD_15B8_RCC_DEV2_EPF0_STRAP2_NO_SOFT_RESET_DEV2_F0_MASK;\n\t\tif (amd_smn_write(0, AMD_15B8_RCC_DEV2_EPF0_STRAP2, data))\n\t\t\tpci_err(dev, \"Failed to write data 0x%x\\n\", data);\n\t} else {\n\t\tpci_err(dev, \"Failed to read data\\n\");\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, 0x15b8, quirk_clear_strap_no_soft_reset_dev2_f0);\n#endif\n\n \n\nstatic u16 prev_cap, l1ss_cap;\nstatic u32 prev_header, l1ss_header;\n\nstatic void chromeos_save_apl_pci_l1ss_capability(struct pci_dev *dev)\n{\n\tint pos = PCI_CFG_SPACE_SIZE, prev = 0;\n\tu32 header, pheader = 0;\n\n\twhile (pos) {\n\t\tpci_read_config_dword(dev, pos, &header);\n\t\tif (PCI_EXT_CAP_ID(header) == PCI_EXT_CAP_ID_L1SS) {\n\t\t\tprev_cap = prev;\n\t\t\tprev_header = pheader;\n\t\t\tl1ss_cap = pos;\n\t\t\tl1ss_header = header;\n\t\t\treturn;\n\t\t}\n\n\t\tprev = pos;\n\t\tpheader = header;\n\t\tpos = PCI_EXT_CAP_NEXT(header);\n\t}\n}\n\nstatic void chromeos_fixup_apl_pci_l1ss_capability(struct pci_dev *dev)\n{\n\tu32 header;\n\n\tif (!prev_cap || !prev_header || !l1ss_cap || !l1ss_header)\n\t\treturn;\n\n\t \n\tpci_read_config_dword(dev, l1ss_cap, &header);\n\tif (header != l1ss_header) {\n\t\tpci_write_config_dword(dev, l1ss_cap, l1ss_header);\n\t\tpci_info(dev, \"restore L1SS Capability header (was %#010x now %#010x)\\n\",\n\t\t\t header, l1ss_header);\n\t}\n\n\t \n\tpci_read_config_dword(dev, prev_cap, &header);\n\tif (header != prev_header) {\n\t\tpci_write_config_dword(dev, prev_cap, prev_header);\n\t\tpci_info(dev, \"restore previous Capability header (was %#010x now %#010x)\\n\",\n\t\t\t header, prev_header);\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x5ad6, chromeos_save_apl_pci_l1ss_capability);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_INTEL, 0x5ad6, chromeos_fixup_apl_pci_l1ss_capability);\n\n#ifdef CONFIG_SUSPEND\n \nstatic void amd_rp_pme_suspend(struct pci_dev *dev)\n{\n\tstruct pci_dev *rp;\n\n\t \n\tif (pm_suspend_target_state == PM_SUSPEND_ON)\n\t\treturn;\n\n\trp = pcie_find_root_port(dev);\n\tif (!rp->pm_cap)\n\t\treturn;\n\n\trp->pme_support &= ~((PCI_PM_CAP_PME_D3hot|PCI_PM_CAP_PME_D3cold) >>\n\t\t\t\t    PCI_PM_CAP_PME_SHIFT);\n\tdev_info_once(&rp->dev, \"quirk: disabling D3cold for suspend\\n\");\n}\n\nstatic void amd_rp_pme_resume(struct pci_dev *dev)\n{\n\tstruct pci_dev *rp;\n\tu16 pmc;\n\n\trp = pcie_find_root_port(dev);\n\tif (!rp->pm_cap)\n\t\treturn;\n\n\tpci_read_config_word(rp, rp->pm_cap + PCI_PM_PMC, &pmc);\n\trp->pme_support = FIELD_GET(PCI_PM_CAP_PME_MASK, pmc);\n}\n \nDECLARE_PCI_FIXUP_SUSPEND(PCI_VENDOR_ID_AMD, 0x162e, amd_rp_pme_suspend);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_AMD, 0x162e, amd_rp_pme_resume);\nDECLARE_PCI_FIXUP_SUSPEND(PCI_VENDOR_ID_AMD, 0x162f, amd_rp_pme_suspend);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_AMD, 0x162f, amd_rp_pme_resume);\n \nDECLARE_PCI_FIXUP_SUSPEND(PCI_VENDOR_ID_AMD, 0x1668, amd_rp_pme_suspend);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_AMD, 0x1668, amd_rp_pme_resume);\nDECLARE_PCI_FIXUP_SUSPEND(PCI_VENDOR_ID_AMD, 0x1669, amd_rp_pme_suspend);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_AMD, 0x1669, amd_rp_pme_resume);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}