{
  "module_name": "pcbios.c",
  "hash_id": "70b182ce9f28bb45d77b95b830a2439662c5913dc3da93a9f6a9a047f1cb6839",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/pci/pcbios.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#include <asm/pci_x86.h>\n#include <asm/e820/types.h>\n#include <asm/pci-functions.h>\n#include <asm/set_memory.h>\n\n \n#define BIOS32_SIGNATURE\t(('_' << 0) + ('3' << 8) + ('2' << 16) + ('_' << 24))\n\n \n#define PCI_SIGNATURE\t\t(('P' << 0) + ('C' << 8) + ('I' << 16) + (' ' << 24))\n\n \n#define PCI_SERVICE\t\t(('$' << 0) + ('P' << 8) + ('C' << 16) + ('I' << 24))\n\n \n#define PCIBIOS_HW_TYPE1\t\t0x01\n#define PCIBIOS_HW_TYPE2\t\t0x02\n#define PCIBIOS_HW_TYPE1_SPEC\t\t0x10\n#define PCIBIOS_HW_TYPE2_SPEC\t\t0x20\n\nint pcibios_enabled;\n\n \nstatic inline void set_bios_x(void)\n{\n\tpcibios_enabled = 1;\n\tset_memory_x(PAGE_OFFSET + BIOS_BEGIN, (BIOS_END - BIOS_BEGIN) >> PAGE_SHIFT);\n\tif (__supported_pte_mask & _PAGE_NX)\n\t\tprintk(KERN_INFO \"PCI: PCI BIOS area is rw and x. Use pci=nobios if you want it NX.\\n\");\n}\n\n \n\nunion bios32 {\n\tstruct {\n\t\tunsigned long signature;\t \n\t\tunsigned long entry;\t\t \n\t\tunsigned char revision;\t\t \n\t\tunsigned char length;\t\t \n\t\tunsigned char checksum;\t\t \n\t\tunsigned char reserved[5]; \t \n\t} fields;\n\tchar chars[16];\n};\n\n \n\nstatic struct {\n\tunsigned long address;\n\tunsigned short segment;\n} bios32_indirect __initdata = { 0, __KERNEL_CS };\n\n \n\nstatic unsigned long __init bios32_service(unsigned long service)\n{\n\tunsigned char return_code;\t \n\tunsigned long address;\t\t \n\tunsigned long length;\t\t \n\tunsigned long entry;\t\t \n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__asm__(\"lcall *(%%edi); cld\"\n\t\t: \"=a\" (return_code),\n\t\t  \"=b\" (address),\n\t\t  \"=c\" (length),\n\t\t  \"=d\" (entry)\n\t\t: \"0\" (service),\n\t\t  \"1\" (0),\n\t\t  \"D\" (&bios32_indirect));\n\tlocal_irq_restore(flags);\n\n\tswitch (return_code) {\n\t\tcase 0:\n\t\t\treturn address + entry;\n\t\tcase 0x80:\t \n\t\t\tprintk(KERN_WARNING \"bios32_service(0x%lx): not present\\n\", service);\n\t\t\treturn 0;\n\t\tdefault:  \n\t\t\tprintk(KERN_WARNING \"bios32_service(0x%lx): returned 0x%x -- BIOS bug!\\n\",\n\t\t\t\tservice, return_code);\n\t\t\treturn 0;\n\t}\n}\n\nstatic struct {\n\tunsigned long address;\n\tunsigned short segment;\n} pci_indirect __ro_after_init = {\n\t.address = 0,\n\t.segment = __KERNEL_CS,\n};\n\nstatic int pci_bios_present __ro_after_init;\n\nstatic int __init check_pcibios(void)\n{\n\tu32 signature, eax, ebx, ecx;\n\tu8 status, major_ver, minor_ver, hw_mech;\n\tunsigned long flags, pcibios_entry;\n\n\tif ((pcibios_entry = bios32_service(PCI_SERVICE))) {\n\t\tpci_indirect.address = pcibios_entry + PAGE_OFFSET;\n\n\t\tlocal_irq_save(flags);\n\t\t__asm__(\n\t\t\t\"lcall *(%%edi); cld\\n\\t\"\n\t\t\t\"jc 1f\\n\\t\"\n\t\t\t\"xor %%ah, %%ah\\n\"\n\t\t\t\"1:\"\n\t\t\t: \"=d\" (signature),\n\t\t\t  \"=a\" (eax),\n\t\t\t  \"=b\" (ebx),\n\t\t\t  \"=c\" (ecx)\n\t\t\t: \"1\" (PCIBIOS_PCI_BIOS_PRESENT),\n\t\t\t  \"D\" (&pci_indirect)\n\t\t\t: \"memory\");\n\t\tlocal_irq_restore(flags);\n\n\t\tstatus = (eax >> 8) & 0xff;\n\t\thw_mech = eax & 0xff;\n\t\tmajor_ver = (ebx >> 8) & 0xff;\n\t\tminor_ver = ebx & 0xff;\n\t\tif (pcibios_last_bus < 0)\n\t\t\tpcibios_last_bus = ecx & 0xff;\n\t\tDBG(\"PCI: BIOS probe returned s=%02x hw=%02x ver=%02x.%02x l=%02x\\n\",\n\t\t\tstatus, hw_mech, major_ver, minor_ver, pcibios_last_bus);\n\t\tif (status || signature != PCI_SIGNATURE) {\n\t\t\tprintk (KERN_ERR \"PCI: BIOS BUG #%x[%08x] found\\n\",\n\t\t\t\tstatus, signature);\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(KERN_INFO \"PCI: PCI BIOS revision %x.%02x entry at 0x%lx, last bus=%d\\n\",\n\t\t\tmajor_ver, minor_ver, pcibios_entry, pcibios_last_bus);\n#ifdef CONFIG_PCI_DIRECT\n\t\tif (!(hw_mech & PCIBIOS_HW_TYPE1))\n\t\t\tpci_probe &= ~PCI_PROBE_CONF1;\n\t\tif (!(hw_mech & PCIBIOS_HW_TYPE2))\n\t\t\tpci_probe &= ~PCI_PROBE_CONF2;\n#endif\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int pci_bios_read(unsigned int seg, unsigned int bus,\n\t\t\t unsigned int devfn, int reg, int len, u32 *value)\n{\n\tunsigned long result = 0;\n\tunsigned long flags;\n\tunsigned long bx = (bus << 8) | devfn;\n\tu16 number = 0, mask = 0;\n\n\tWARN_ON(seg);\n\tif (!value || (bus > 255) || (devfn > 255) || (reg > 255))\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&pci_config_lock, flags);\n\n\tswitch (len) {\n\tcase 1:\n\t\tnumber = PCIBIOS_READ_CONFIG_BYTE;\n\t\tmask = 0xff;\n\t\tbreak;\n\tcase 2:\n\t\tnumber = PCIBIOS_READ_CONFIG_WORD;\n\t\tmask = 0xffff;\n\t\tbreak;\n\tcase 4:\n\t\tnumber = PCIBIOS_READ_CONFIG_DWORD;\n\t\tbreak;\n\t}\n\n\t__asm__(\"lcall *(%%esi); cld\\n\\t\"\n\t\t\"jc 1f\\n\\t\"\n\t\t\"xor %%ah, %%ah\\n\"\n\t\t\"1:\"\n\t\t: \"=c\" (*value),\n\t\t  \"=a\" (result)\n\t\t: \"1\" (number),\n\t\t  \"b\" (bx),\n\t\t  \"D\" ((long)reg),\n\t\t  \"S\" (&pci_indirect));\n\t \n\tif (mask)\n\t\t*value &= mask;\n\n\traw_spin_unlock_irqrestore(&pci_config_lock, flags);\n\n\treturn (int)((result & 0xff00) >> 8);\n}\n\nstatic int pci_bios_write(unsigned int seg, unsigned int bus,\n\t\t\t  unsigned int devfn, int reg, int len, u32 value)\n{\n\tunsigned long result = 0;\n\tunsigned long flags;\n\tunsigned long bx = (bus << 8) | devfn;\n\tu16 number = 0;\n\n\tWARN_ON(seg);\n\tif ((bus > 255) || (devfn > 255) || (reg > 255)) \n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&pci_config_lock, flags);\n\n\tswitch (len) {\n\tcase 1:\n\t\tnumber = PCIBIOS_WRITE_CONFIG_BYTE;\n\t\tbreak;\n\tcase 2:\n\t\tnumber = PCIBIOS_WRITE_CONFIG_WORD;\n\t\tbreak;\n\tcase 4:\n\t\tnumber = PCIBIOS_WRITE_CONFIG_DWORD;\n\t\tbreak;\n\t}\n\n\t__asm__(\"lcall *(%%esi); cld\\n\\t\"\n\t\t\"jc 1f\\n\\t\"\n\t\t\"xor %%ah, %%ah\\n\"\n\t\t\"1:\"\n\t\t: \"=a\" (result)\n\t\t: \"0\" (number),\n\t\t  \"c\" (value),\n\t\t  \"b\" (bx),\n\t\t  \"D\" ((long)reg),\n\t\t  \"S\" (&pci_indirect));\n\n\traw_spin_unlock_irqrestore(&pci_config_lock, flags);\n\n\treturn (int)((result & 0xff00) >> 8);\n}\n\n\n \n\nstatic const struct pci_raw_ops pci_bios_access = {\n\t.read =\t\tpci_bios_read,\n\t.write =\tpci_bios_write\n};\n\n \n\nstatic const struct pci_raw_ops *__init pci_find_bios(void)\n{\n\tunion bios32 *check;\n\tunsigned char sum;\n\tint i, length;\n\n\t \n\n\tfor (check = (union bios32 *) __va(0xe0000);\n\t     check <= (union bios32 *) __va(0xffff0);\n\t     ++check) {\n\t\tlong sig;\n\t\tif (get_kernel_nofault(sig, &check->fields.signature))\n\t\t\tcontinue;\n\n\t\tif (check->fields.signature != BIOS32_SIGNATURE)\n\t\t\tcontinue;\n\t\tlength = check->fields.length * 16;\n\t\tif (!length)\n\t\t\tcontinue;\n\t\tsum = 0;\n\t\tfor (i = 0; i < length ; ++i)\n\t\t\tsum += check->chars[i];\n\t\tif (sum != 0)\n\t\t\tcontinue;\n\t\tif (check->fields.revision != 0) {\n\t\t\tprintk(\"PCI: unsupported BIOS32 revision %d at 0x%p\\n\",\n\t\t\t\tcheck->fields.revision, check);\n\t\t\tcontinue;\n\t\t}\n\t\tDBG(\"PCI: BIOS32 Service Directory structure at 0x%p\\n\", check);\n\t\tif (check->fields.entry >= 0x100000) {\n\t\t\tprintk(\"PCI: BIOS32 entry (0x%p) in high memory, \"\n\t\t\t\t\t\"cannot use.\\n\", check);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\tunsigned long bios32_entry = check->fields.entry;\n\t\t\tDBG(\"PCI: BIOS32 Service Directory entry at 0x%lx\\n\",\n\t\t\t\t\tbios32_entry);\n\t\t\tbios32_indirect.address = bios32_entry + PAGE_OFFSET;\n\t\t\tset_bios_x();\n\t\t\tif (check_pcibios())\n\t\t\t\treturn &pci_bios_access;\n\t\t}\n\t\tbreak;\t \n\t}\n\n\treturn NULL;\n}\n\n \n\nstruct irq_routing_options {\n\tu16 size;\n\tstruct irq_info *table;\n\tu16 segment;\n} __attribute__((packed));\n\nstruct irq_routing_table * pcibios_get_irq_routing_table(void)\n{\n\tstruct irq_routing_options opt;\n\tstruct irq_routing_table *rt = NULL;\n\tint ret, map;\n\tunsigned long page;\n\n\tif (!pci_bios_present)\n\t\treturn NULL;\n\tpage = __get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn NULL;\n\topt.table = (struct irq_info *) page;\n\topt.size = PAGE_SIZE;\n\topt.segment = __KERNEL_DS;\n\n\tDBG(\"PCI: Fetching IRQ routing table... \");\n\t__asm__(\"push %%es\\n\\t\"\n\t\t\"push %%ds\\n\\t\"\n\t\t\"pop  %%es\\n\\t\"\n\t\t\"lcall *(%%esi); cld\\n\\t\"\n\t\t\"pop %%es\\n\\t\"\n\t\t\"jc 1f\\n\\t\"\n\t\t\"xor %%ah, %%ah\\n\"\n\t\t\"1:\"\n\t\t: \"=a\" (ret),\n\t\t  \"=b\" (map),\n\t\t  \"=m\" (opt)\n\t\t: \"0\" (PCIBIOS_GET_ROUTING_OPTIONS),\n\t\t  \"1\" (0),\n\t\t  \"D\" ((long) &opt),\n\t\t  \"S\" (&pci_indirect),\n\t\t  \"m\" (opt)\n\t\t: \"memory\");\n\tDBG(\"OK  ret=%d, size=%d, map=%x\\n\", ret, opt.size, map);\n\tif (ret & 0xff00)\n\t\tprintk(KERN_ERR \"PCI: Error %02x when fetching IRQ routing table.\\n\", (ret >> 8) & 0xff);\n\telse if (opt.size) {\n\t\trt = kmalloc(sizeof(struct irq_routing_table) + opt.size, GFP_KERNEL);\n\t\tif (rt) {\n\t\t\tmemset(rt, 0, sizeof(struct irq_routing_table));\n\t\t\trt->size = opt.size + sizeof(struct irq_routing_table);\n\t\t\trt->exclusive_irqs = map;\n\t\t\tmemcpy(rt->slots, (void *) page, opt.size);\n\t\t\tprintk(KERN_INFO \"PCI: Using BIOS Interrupt Routing Table\\n\");\n\t\t}\n\t}\n\tfree_page(page);\n\treturn rt;\n}\nEXPORT_SYMBOL(pcibios_get_irq_routing_table);\n\nint pcibios_set_irq_routing(struct pci_dev *dev, int pin, int irq)\n{\n\tint ret;\n\n\t__asm__(\"lcall *(%%esi); cld\\n\\t\"\n\t\t\"jc 1f\\n\\t\"\n\t\t\"xor %%ah, %%ah\\n\"\n\t\t\"1:\"\n\t\t: \"=a\" (ret)\n\t\t: \"0\" (PCIBIOS_SET_PCI_HW_INT),\n\t\t  \"b\" ((dev->bus->number << 8) | dev->devfn),\n\t\t  \"c\" ((irq << 8) | (pin + 10)),\n\t\t  \"S\" (&pci_indirect));\n\treturn !(ret & 0xff00);\n}\nEXPORT_SYMBOL(pcibios_set_irq_routing);\n\nvoid __init pci_pcbios_init(void)\n{\n\tif ((pci_probe & PCI_PROBE_BIOS) \n\t\t&& ((raw_pci_ops = pci_find_bios()))) {\n\t\tpci_bios_present = 1;\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}