{
  "module_name": "amd_bus.c",
  "hash_id": "47f03589248662c7ead682df5985f1d47d125c09b621b031759d9c9dc4e0009c",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/pci/amd_bus.c",
  "human_readable_source": "\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/topology.h>\n#include <linux/cpu.h>\n#include <linux/range.h>\n\n#include <asm/amd_nb.h>\n#include <asm/pci_x86.h>\n\n#include <asm/pci-direct.h>\n\n#include \"bus_numa.h\"\n\n#define AMD_NB_F0_NODE_ID\t\t\t0x60\n#define AMD_NB_F0_UNIT_ID\t\t\t0x64\n#define AMD_NB_F1_CONFIG_MAP_REG\t\t0xe0\n\n#define RANGE_NUM\t\t\t\t16\n#define AMD_NB_F1_CONFIG_MAP_RANGES\t\t4\n\nstruct amd_hostbridge {\n\tu32 bus;\n\tu32 slot;\n\tu32 device;\n};\n\n \nstatic struct amd_hostbridge hb_probes[] __initdata = {\n\t{ 0, 0x18, 0x1100 },  \n\t{ 0, 0x18, 0x1200 },  \n\t{ 0xff, 0, 0x1200 },  \n\t{ 0, 0x18, 0x1300 },  \n\t{ 0, 0x18, 0x1600 },  \n};\n\nstatic struct pci_root_info __init *find_pci_root_info(int node, int link)\n{\n\tstruct pci_root_info *info;\n\n\t \n\tlist_for_each_entry(info, &pci_root_infos, list)\n\t\tif (info->node == node && info->link == link)\n\t\t\treturn info;\n\n\treturn NULL;\n}\n\nstatic inline resource_size_t cap_resource(u64 val)\n{\n\tif (val > RESOURCE_SIZE_MAX)\n\t\treturn RESOURCE_SIZE_MAX;\n\n\treturn val;\n}\n\n \nstatic int __init early_root_info_init(void)\n{\n\tint i;\n\tunsigned bus;\n\tunsigned slot;\n\tint node;\n\tint link;\n\tint def_node;\n\tint def_link;\n\tstruct pci_root_info *info;\n\tu32 reg;\n\tu64 start;\n\tu64 end;\n\tstruct range range[RANGE_NUM];\n\tu64 val;\n\tu32 address;\n\tbool found;\n\tstruct resource fam10h_mmconf_res, *fam10h_mmconf;\n\tu64 fam10h_mmconf_start;\n\tu64 fam10h_mmconf_end;\n\n\tif (!early_pci_allowed())\n\t\treturn -1;\n\n\tfound = false;\n\tfor (i = 0; i < ARRAY_SIZE(hb_probes); i++) {\n\t\tu32 id;\n\t\tu16 device;\n\t\tu16 vendor;\n\n\t\tbus = hb_probes[i].bus;\n\t\tslot = hb_probes[i].slot;\n\t\tid = read_pci_config(bus, slot, 0, PCI_VENDOR_ID);\n\t\tvendor = id & 0xffff;\n\t\tdevice = (id>>16) & 0xffff;\n\n\t\tif (vendor != PCI_VENDOR_ID_AMD &&\n\t\t    vendor != PCI_VENDOR_ID_HYGON)\n\t\t\tcontinue;\n\n\t\tif (hb_probes[i].device == device) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < AMD_NB_F1_CONFIG_MAP_RANGES; i++) {\n\t\tint min_bus;\n\t\tint max_bus;\n\t\treg = read_pci_config(bus, slot, 1,\n\t\t\t\tAMD_NB_F1_CONFIG_MAP_REG + (i << 2));\n\n\t\t \n\t\tif ((reg & 7) != 3)\n\t\t\tcontinue;\n\n\t\tmin_bus = (reg >> 16) & 0xff;\n\t\tmax_bus = (reg >> 24) & 0xff;\n\t\tnode = (reg >> 4) & 0x07;\n\t\tlink = (reg >> 8) & 0x03;\n\n\t\talloc_pci_root_info(min_bus, max_bus, node, link);\n\t}\n\n\t \n\tif (boot_cpu_data.x86 > 0x11)\n\t\treturn 0;\n\n\t \n\treg = read_pci_config(bus, slot, 0, AMD_NB_F0_NODE_ID);\n\tdef_node = (reg >> 8) & 0x07;\n\treg = read_pci_config(bus, slot, 0, AMD_NB_F0_UNIT_ID);\n\tdef_link = (reg >> 8) & 0x03;\n\n\tmemset(range, 0, sizeof(range));\n\tadd_range(range, RANGE_NUM, 0, 0, 0xffff + 1);\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\treg = read_pci_config(bus, slot, 1, 0xc0 + (i << 3));\n\t\tif (!(reg & 3))\n\t\t\tcontinue;\n\n\t\tstart = reg & 0xfff000;\n\t\treg = read_pci_config(bus, slot, 1, 0xc4 + (i << 3));\n\t\tnode = reg & 0x07;\n\t\tlink = (reg >> 4) & 0x03;\n\t\tend = (reg & 0xfff000) | 0xfff;\n\n\t\tinfo = find_pci_root_info(node, link);\n\t\tif (!info)\n\t\t\tcontinue;  \n\n\t\tprintk(KERN_DEBUG \"node %d link %d: io port [%llx, %llx]\\n\",\n\t\t       node, link, start, end);\n\n\t\t \n\t\tif (end > 0xffff)\n\t\t\tend = 0xffff;\n\t\tupdate_res(info, start, end, IORESOURCE_IO, 1);\n\t\tsubtract_range(range, RANGE_NUM, start, end + 1);\n\t}\n\t \n\t \n\tinfo = find_pci_root_info(def_node, def_link);\n\tif (info) {\n\t\tfor (i = 0; i < RANGE_NUM; i++) {\n\t\t\tif (!range[i].end)\n\t\t\t\tcontinue;\n\n\t\t\tupdate_res(info, range[i].start, range[i].end - 1,\n\t\t\t\t   IORESOURCE_IO, 1);\n\t\t}\n\t}\n\n\tmemset(range, 0, sizeof(range));\n\t \n\tend = cap_resource((0xfdULL<<32) - 1);\n\tend++;\n\tadd_range(range, RANGE_NUM, 0, 0, end);\n\n\t \n\taddress = MSR_K8_TOP_MEM1;\n\trdmsrl(address, val);\n\tend = (val & 0xffffff800000ULL);\n\tprintk(KERN_INFO \"TOM: %016llx aka %lldM\\n\", end, end>>20);\n\tif (end < (1ULL<<32))\n\t\tsubtract_range(range, RANGE_NUM, 0, end);\n\n\t \n\tfam10h_mmconf = amd_get_mmconfig_range(&fam10h_mmconf_res);\n\t \n\tif (fam10h_mmconf) {\n\t\tprintk(KERN_DEBUG \"Fam 10h mmconf %pR\\n\", fam10h_mmconf);\n\t\tfam10h_mmconf_start = fam10h_mmconf->start;\n\t\tfam10h_mmconf_end = fam10h_mmconf->end;\n\t\tsubtract_range(range, RANGE_NUM, fam10h_mmconf_start,\n\t\t\t\t fam10h_mmconf_end + 1);\n\t} else {\n\t\tfam10h_mmconf_start = 0;\n\t\tfam10h_mmconf_end = 0;\n\t}\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\treg = read_pci_config(bus, slot, 1, 0x80 + (i << 3));\n\t\tif (!(reg & 3))\n\t\t\tcontinue;\n\n\t\tstart = reg & 0xffffff00;  \n\t\tstart <<= 8;\n\t\treg = read_pci_config(bus, slot, 1, 0x84 + (i << 3));\n\t\tnode = reg & 0x07;\n\t\tlink = (reg >> 4) & 0x03;\n\t\tend = (reg & 0xffffff00);\n\t\tend <<= 8;\n\t\tend |= 0xffff;\n\n\t\tinfo = find_pci_root_info(node, link);\n\n\t\tif (!info)\n\t\t\tcontinue;\n\n\t\tprintk(KERN_DEBUG \"node %d link %d: mmio [%llx, %llx]\",\n\t\t       node, link, start, end);\n\t\t \n\t\tif (fam10h_mmconf_end) {\n\t\t\tint changed = 0;\n\t\t\tu64 endx = 0;\n\t\t\tif (start >= fam10h_mmconf_start &&\n\t\t\t    start <= fam10h_mmconf_end) {\n\t\t\t\tstart = fam10h_mmconf_end + 1;\n\t\t\t\tchanged = 1;\n\t\t\t}\n\n\t\t\tif (end >= fam10h_mmconf_start &&\n\t\t\t    end <= fam10h_mmconf_end) {\n\t\t\t\tend = fam10h_mmconf_start - 1;\n\t\t\t\tchanged = 1;\n\t\t\t}\n\n\t\t\tif (start < fam10h_mmconf_start &&\n\t\t\t    end > fam10h_mmconf_end) {\n\t\t\t\t \n\t\t\t\tendx = fam10h_mmconf_start - 1;\n\t\t\t\tupdate_res(info, start, endx, IORESOURCE_MEM, 0);\n\t\t\t\tsubtract_range(range, RANGE_NUM, start,\n\t\t\t\t\t\t endx + 1);\n\t\t\t\tprintk(KERN_CONT \" ==> [%llx, %llx]\", start, endx);\n\t\t\t\tstart = fam10h_mmconf_end + 1;\n\t\t\t\tchanged = 1;\n\t\t\t}\n\t\t\tif (changed) {\n\t\t\t\tif (start <= end) {\n\t\t\t\t\tprintk(KERN_CONT \" %s [%llx, %llx]\", endx ? \"and\" : \"==>\", start, end);\n\t\t\t\t} else {\n\t\t\t\t\tprintk(KERN_CONT \"%s\\n\", endx?\"\":\" ==> none\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tupdate_res(info, cap_resource(start), cap_resource(end),\n\t\t\t\t IORESOURCE_MEM, 1);\n\t\tsubtract_range(range, RANGE_NUM, start, end + 1);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\n\t \n\t \n\taddress = MSR_AMD64_SYSCFG;\n\trdmsrl(address, val);\n\t \n\tif (val & (1<<21)) {\n\t\t \n\t\taddress = MSR_K8_TOP_MEM2;\n\t\trdmsrl(address, val);\n\t\tend = (val & 0xffffff800000ULL);\n\t\tprintk(KERN_INFO \"TOM2: %016llx aka %lldM\\n\", end, end>>20);\n\t\tsubtract_range(range, RANGE_NUM, 1ULL<<32, end);\n\t}\n\n\t \n\tinfo = find_pci_root_info(def_node, def_link);\n\tif (info) {\n\t\tfor (i = 0; i < RANGE_NUM; i++) {\n\t\t\tif (!range[i].end)\n\t\t\t\tcontinue;\n\n\t\t\tupdate_res(info, cap_resource(range[i].start),\n\t\t\t\t   cap_resource(range[i].end - 1),\n\t\t\t\t   IORESOURCE_MEM, 1);\n\t\t}\n\t}\n\n\tlist_for_each_entry(info, &pci_root_infos, list) {\n\t\tint busnum;\n\t\tstruct pci_root_res *root_res;\n\n\t\tbusnum = info->busn.start;\n\t\tprintk(KERN_DEBUG \"bus: %pR on node %x link %x\\n\",\n\t\t       &info->busn, info->node, info->link);\n\t\tlist_for_each_entry(root_res, &info->resources, list)\n\t\t\tprintk(KERN_DEBUG \"bus: %02x %pR\\n\",\n\t\t\t\t       busnum, &root_res->res);\n\t}\n\n\treturn 0;\n}\n\n#define ENABLE_CF8_EXT_CFG      (1ULL << 46)\n\nstatic int amd_bus_cpu_online(unsigned int cpu)\n{\n\tu64 reg;\n\n\trdmsrl(MSR_AMD64_NB_CFG, reg);\n\tif (!(reg & ENABLE_CF8_EXT_CFG)) {\n\t\treg |= ENABLE_CF8_EXT_CFG;\n\t\twrmsrl(MSR_AMD64_NB_CFG, reg);\n\t}\n\treturn 0;\n}\n\nstatic void __init pci_enable_pci_io_ecs(void)\n{\n#ifdef CONFIG_AMD_NB\n\tunsigned int i, n;\n\n\tfor (n = i = 0; !n && amd_nb_bus_dev_ranges[i].dev_limit; ++i) {\n\t\tu8 bus = amd_nb_bus_dev_ranges[i].bus;\n\t\tu8 slot = amd_nb_bus_dev_ranges[i].dev_base;\n\t\tu8 limit = amd_nb_bus_dev_ranges[i].dev_limit;\n\n\t\tfor (; slot < limit; ++slot) {\n\t\t\tu32 val = read_pci_config(bus, slot, 3, 0);\n\n\t\t\tif (!early_is_amd_nb(val))\n\t\t\t\tcontinue;\n\n\t\t\tval = read_pci_config(bus, slot, 3, 0x8c);\n\t\t\tif (!(val & (ENABLE_CF8_EXT_CFG >> 32))) {\n\t\t\t\tval |= ENABLE_CF8_EXT_CFG >> 32;\n\t\t\t\twrite_pci_config(bus, slot, 3, 0x8c, val);\n\t\t\t}\n\t\t\t++n;\n\t\t}\n\t}\n#endif\n}\n\nstatic int __init pci_io_ecs_init(void)\n{\n\tint ret;\n\n\t \n\tif (boot_cpu_data.x86 < 0x10)\n\t\treturn 0;\n\n\t \n\tif (early_pci_allowed())\n\t\tpci_enable_pci_io_ecs();\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"pci/amd_bus:online\",\n\t\t\t\tamd_bus_cpu_online, NULL);\n\tWARN_ON(ret < 0);\n\n\tpci_probe |= PCI_HAS_IO_ECS;\n\n\treturn 0;\n}\n\nstatic int __init amd_postcore_init(void)\n{\n\tif (boot_cpu_data.x86_vendor != X86_VENDOR_AMD &&\n\t    boot_cpu_data.x86_vendor != X86_VENDOR_HYGON)\n\t\treturn 0;\n\n\tearly_root_info_init();\n\tpci_io_ecs_init();\n\n\treturn 0;\n}\n\npostcore_initcall(amd_postcore_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}