{
  "module_name": "mmconfig_32.c",
  "hash_id": "deb4340e1399e8f7059fa8afbfbfaa6bf249f3b19110b53451f7e981e5895c2d",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/pci/mmconfig_32.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/rcupdate.h>\n#include <asm/e820/api.h>\n#include <asm/pci_x86.h>\n\n \n#define mmcfg_virt_addr ((void __iomem *) fix_to_virt(FIX_PCIE_MCFG))\n\n \nstatic u32 mmcfg_last_accessed_device;\nstatic int mmcfg_last_accessed_cpu;\n\n \nstatic u32 get_base_addr(unsigned int seg, int bus, unsigned devfn)\n{\n\tstruct pci_mmcfg_region *cfg = pci_mmconfig_lookup(seg, bus);\n\n\tif (cfg)\n\t\treturn cfg->address;\n\treturn 0;\n}\n\n \nstatic void pci_exp_set_dev_base(unsigned int base, int bus, int devfn)\n{\n\tu32 dev_base = base | PCI_MMCFG_BUS_OFFSET(bus) | (devfn << 12);\n\tint cpu = smp_processor_id();\n\tif (dev_base != mmcfg_last_accessed_device ||\n\t    cpu != mmcfg_last_accessed_cpu) {\n\t\tmmcfg_last_accessed_device = dev_base;\n\t\tmmcfg_last_accessed_cpu = cpu;\n\t\tset_fixmap_nocache(FIX_PCIE_MCFG, dev_base);\n\t}\n}\n\nstatic int pci_mmcfg_read(unsigned int seg, unsigned int bus,\n\t\t\t  unsigned int devfn, int reg, int len, u32 *value)\n{\n\tunsigned long flags;\n\tu32 base;\n\n\tif ((bus > 255) || (devfn > 255) || (reg > 4095)) {\nerr:\t\t*value = -1;\n\t\treturn -EINVAL;\n\t}\n\n\trcu_read_lock();\n\tbase = get_base_addr(seg, bus, devfn);\n\tif (!base) {\n\t\trcu_read_unlock();\n\t\tgoto err;\n\t}\n\n\traw_spin_lock_irqsave(&pci_config_lock, flags);\n\n\tpci_exp_set_dev_base(base, bus, devfn);\n\n\tswitch (len) {\n\tcase 1:\n\t\t*value = mmio_config_readb(mmcfg_virt_addr + reg);\n\t\tbreak;\n\tcase 2:\n\t\t*value = mmio_config_readw(mmcfg_virt_addr + reg);\n\t\tbreak;\n\tcase 4:\n\t\t*value = mmio_config_readl(mmcfg_virt_addr + reg);\n\t\tbreak;\n\t}\n\traw_spin_unlock_irqrestore(&pci_config_lock, flags);\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic int pci_mmcfg_write(unsigned int seg, unsigned int bus,\n\t\t\t   unsigned int devfn, int reg, int len, u32 value)\n{\n\tunsigned long flags;\n\tu32 base;\n\n\tif ((bus > 255) || (devfn > 255) || (reg > 4095))\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tbase = get_base_addr(seg, bus, devfn);\n\tif (!base) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_lock_irqsave(&pci_config_lock, flags);\n\n\tpci_exp_set_dev_base(base, bus, devfn);\n\n\tswitch (len) {\n\tcase 1:\n\t\tmmio_config_writeb(mmcfg_virt_addr + reg, value);\n\t\tbreak;\n\tcase 2:\n\t\tmmio_config_writew(mmcfg_virt_addr + reg, value);\n\t\tbreak;\n\tcase 4:\n\t\tmmio_config_writel(mmcfg_virt_addr + reg, value);\n\t\tbreak;\n\t}\n\traw_spin_unlock_irqrestore(&pci_config_lock, flags);\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nconst struct pci_raw_ops pci_mmcfg = {\n\t.read =\t\tpci_mmcfg_read,\n\t.write =\tpci_mmcfg_write,\n};\n\nint __init pci_mmcfg_arch_init(void)\n{\n\tprintk(KERN_INFO \"PCI: Using MMCONFIG for extended config space\\n\");\n\traw_pci_ext_ops = &pci_mmcfg;\n\treturn 1;\n}\n\nvoid __init pci_mmcfg_arch_free(void)\n{\n}\n\nint pci_mmcfg_arch_map(struct pci_mmcfg_region *cfg)\n{\n\treturn 0;\n}\n\nvoid pci_mmcfg_arch_unmap(struct pci_mmcfg_region *cfg)\n{\n\tunsigned long flags;\n\n\t \n\traw_spin_lock_irqsave(&pci_config_lock, flags);\n\tmmcfg_last_accessed_device = 0;\n\traw_spin_unlock_irqrestore(&pci_config_lock, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}