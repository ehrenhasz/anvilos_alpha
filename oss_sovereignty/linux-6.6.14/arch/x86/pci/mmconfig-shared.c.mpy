{
  "module_name": "mmconfig-shared.c",
  "hash_id": "3da941d3b37b0df5a413e5430bc9172be1a08a7e17ccb263788f07198fe6f6e0",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/pci/mmconfig-shared.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/efi.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/bitmap.h>\n#include <linux/dmi.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/rculist.h>\n#include <asm/e820/api.h>\n#include <asm/pci_x86.h>\n#include <asm/acpi.h>\n\n#define PREFIX \"PCI: \"\n\n \nstatic bool pci_mmcfg_running_state;\nstatic bool pci_mmcfg_arch_init_failed;\nstatic DEFINE_MUTEX(pci_mmcfg_lock);\n#define pci_mmcfg_lock_held() lock_is_held(&(pci_mmcfg_lock).dep_map)\n\nLIST_HEAD(pci_mmcfg_list);\n\nstatic void __init pci_mmconfig_remove(struct pci_mmcfg_region *cfg)\n{\n\tif (cfg->res.parent)\n\t\trelease_resource(&cfg->res);\n\tlist_del(&cfg->list);\n\tkfree(cfg);\n}\n\nstatic void __init free_all_mmcfg(void)\n{\n\tstruct pci_mmcfg_region *cfg, *tmp;\n\n\tpci_mmcfg_arch_free();\n\tlist_for_each_entry_safe(cfg, tmp, &pci_mmcfg_list, list)\n\t\tpci_mmconfig_remove(cfg);\n}\n\nstatic void list_add_sorted(struct pci_mmcfg_region *new)\n{\n\tstruct pci_mmcfg_region *cfg;\n\n\t \n\tlist_for_each_entry_rcu(cfg, &pci_mmcfg_list, list, pci_mmcfg_lock_held()) {\n\t\tif (cfg->segment > new->segment ||\n\t\t    (cfg->segment == new->segment &&\n\t\t     cfg->start_bus >= new->start_bus)) {\n\t\t\tlist_add_tail_rcu(&new->list, &cfg->list);\n\t\t\treturn;\n\t\t}\n\t}\n\tlist_add_tail_rcu(&new->list, &pci_mmcfg_list);\n}\n\nstatic struct pci_mmcfg_region *pci_mmconfig_alloc(int segment, int start,\n\t\t\t\t\t\t   int end, u64 addr)\n{\n\tstruct pci_mmcfg_region *new;\n\tstruct resource *res;\n\n\tif (addr == 0)\n\t\treturn NULL;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tnew->address = addr;\n\tnew->segment = segment;\n\tnew->start_bus = start;\n\tnew->end_bus = end;\n\n\tres = &new->res;\n\tres->start = addr + PCI_MMCFG_BUS_OFFSET(start);\n\tres->end = addr + PCI_MMCFG_BUS_OFFSET(end + 1) - 1;\n\tres->flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\tsnprintf(new->name, PCI_MMCFG_RESOURCE_NAME_LEN,\n\t\t \"PCI MMCONFIG %04x [bus %02x-%02x]\", segment, start, end);\n\tres->name = new->name;\n\n\treturn new;\n}\n\nstruct pci_mmcfg_region *__init pci_mmconfig_add(int segment, int start,\n\t\t\t\t\t\t int end, u64 addr)\n{\n\tstruct pci_mmcfg_region *new;\n\n\tnew = pci_mmconfig_alloc(segment, start, end, addr);\n\tif (new) {\n\t\tmutex_lock(&pci_mmcfg_lock);\n\t\tlist_add_sorted(new);\n\t\tmutex_unlock(&pci_mmcfg_lock);\n\n\t\tpr_info(PREFIX\n\t\t       \"MMCONFIG for domain %04x [bus %02x-%02x] at %pR \"\n\t\t       \"(base %#lx)\\n\",\n\t\t       segment, start, end, &new->res, (unsigned long)addr);\n\t}\n\n\treturn new;\n}\n\nstruct pci_mmcfg_region *pci_mmconfig_lookup(int segment, int bus)\n{\n\tstruct pci_mmcfg_region *cfg;\n\n\tlist_for_each_entry_rcu(cfg, &pci_mmcfg_list, list, pci_mmcfg_lock_held())\n\t\tif (cfg->segment == segment &&\n\t\t    cfg->start_bus <= bus && bus <= cfg->end_bus)\n\t\t\treturn cfg;\n\n\treturn NULL;\n}\n\nstatic const char *__init pci_mmcfg_e7520(void)\n{\n\tu32 win;\n\traw_pci_ops->read(0, 0, PCI_DEVFN(0, 0), 0xce, 2, &win);\n\n\twin = win & 0xf000;\n\tif (win == 0x0000 || win == 0xf000)\n\t\treturn NULL;\n\n\tif (pci_mmconfig_add(0, 0, 255, win << 16) == NULL)\n\t\treturn NULL;\n\n\treturn \"Intel Corporation E7520 Memory Controller Hub\";\n}\n\nstatic const char *__init pci_mmcfg_intel_945(void)\n{\n\tu32 pciexbar, mask = 0, len = 0;\n\n\traw_pci_ops->read(0, 0, PCI_DEVFN(0, 0), 0x48, 4, &pciexbar);\n\n\t \n\tif (!(pciexbar & 1))\n\t\treturn NULL;\n\n\t \n\tswitch ((pciexbar >> 1) & 3) {\n\tcase 0:\n\t\tmask = 0xf0000000U;\n\t\tlen  = 0x10000000U;\n\t\tbreak;\n\tcase 1:\n\t\tmask = 0xf8000000U;\n\t\tlen  = 0x08000000U;\n\t\tbreak;\n\tcase 2:\n\t\tmask = 0xfc000000U;\n\t\tlen  = 0x04000000U;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\t \n\t \n\n\tif ((pciexbar & mask) & 0x0fffffffU)\n\t\treturn NULL;\n\n\t \n\tif ((pciexbar & mask) >= 0xf0000000U)\n\t\treturn NULL;\n\n\tif (pci_mmconfig_add(0, 0, (len >> 20) - 1, pciexbar & mask) == NULL)\n\t\treturn NULL;\n\n\treturn \"Intel Corporation 945G/GZ/P/PL Express Memory Controller Hub\";\n}\n\nstatic const char *__init pci_mmcfg_amd_fam10h(void)\n{\n\tu32 low, high, address;\n\tu64 base, msr;\n\tint i;\n\tunsigned segnbits = 0, busnbits, end_bus;\n\n\tif (!(pci_probe & PCI_CHECK_ENABLE_AMD_MMCONF))\n\t\treturn NULL;\n\n\taddress = MSR_FAM10H_MMIO_CONF_BASE;\n\tif (rdmsr_safe(address, &low, &high))\n\t\treturn NULL;\n\n\tmsr = high;\n\tmsr <<= 32;\n\tmsr |= low;\n\n\t \n\tif (!(msr & FAM10H_MMIO_CONF_ENABLE))\n\t\treturn NULL;\n\n\tbase = msr & (FAM10H_MMIO_CONF_BASE_MASK<<FAM10H_MMIO_CONF_BASE_SHIFT);\n\n\tbusnbits = (msr >> FAM10H_MMIO_CONF_BUSRANGE_SHIFT) &\n\t\t\t FAM10H_MMIO_CONF_BUSRANGE_MASK;\n\n\t \n\tif (!busnbits)\n\t\treturn NULL;\n\n\tif (busnbits > 8) {\n\t\tsegnbits = busnbits - 8;\n\t\tbusnbits = 8;\n\t}\n\n\tend_bus = (1 << busnbits) - 1;\n\tfor (i = 0; i < (1 << segnbits); i++)\n\t\tif (pci_mmconfig_add(i, 0, end_bus,\n\t\t\t\t     base + (1<<28) * i) == NULL) {\n\t\t\tfree_all_mmcfg();\n\t\t\treturn NULL;\n\t\t}\n\n\treturn \"AMD Family 10h NB\";\n}\n\nstatic bool __initdata mcp55_checked;\nstatic const char *__init pci_mmcfg_nvidia_mcp55(void)\n{\n\tint bus;\n\tint mcp55_mmconf_found = 0;\n\n\tstatic const u32 extcfg_regnum __initconst\t= 0x90;\n\tstatic const u32 extcfg_regsize __initconst\t= 4;\n\tstatic const u32 extcfg_enable_mask __initconst\t= 1 << 31;\n\tstatic const u32 extcfg_start_mask __initconst\t= 0xff << 16;\n\tstatic const int extcfg_start_shift __initconst\t= 16;\n\tstatic const u32 extcfg_size_mask __initconst\t= 0x3 << 28;\n\tstatic const int extcfg_size_shift __initconst\t= 28;\n\tstatic const int extcfg_sizebus[] __initconst\t= {\n\t\t0x100, 0x80, 0x40, 0x20\n\t};\n\tstatic const u32 extcfg_base_mask[] __initconst\t= {\n\t\t0x7ff8, 0x7ffc, 0x7ffe, 0x7fff\n\t};\n\tstatic const int extcfg_base_lshift __initconst\t= 25;\n\n\t \n\tif (!acpi_disabled || !list_empty(&pci_mmcfg_list) || mcp55_checked)\n\t\treturn NULL;\n\n\tmcp55_checked = true;\n\tfor (bus = 0; bus < 256; bus++) {\n\t\tu64 base;\n\t\tu32 l, extcfg;\n\t\tu16 vendor, device;\n\t\tint start, size_index, end;\n\n\t\traw_pci_ops->read(0, bus, PCI_DEVFN(0, 0), 0, 4, &l);\n\t\tvendor = l & 0xffff;\n\t\tdevice = (l >> 16) & 0xffff;\n\n\t\tif (PCI_VENDOR_ID_NVIDIA != vendor || 0x0369 != device)\n\t\t\tcontinue;\n\n\t\traw_pci_ops->read(0, bus, PCI_DEVFN(0, 0), extcfg_regnum,\n\t\t\t\t  extcfg_regsize, &extcfg);\n\n\t\tif (!(extcfg & extcfg_enable_mask))\n\t\t\tcontinue;\n\n\t\tsize_index = (extcfg & extcfg_size_mask) >> extcfg_size_shift;\n\t\tbase = extcfg & extcfg_base_mask[size_index];\n\t\t \n\t\tbase <<= extcfg_base_lshift;\n\t\tstart = (extcfg & extcfg_start_mask) >> extcfg_start_shift;\n\t\tend = start + extcfg_sizebus[size_index] - 1;\n\t\tif (pci_mmconfig_add(0, start, end, base) == NULL)\n\t\t\tcontinue;\n\t\tmcp55_mmconf_found++;\n\t}\n\n\tif (!mcp55_mmconf_found)\n\t\treturn NULL;\n\n\treturn \"nVidia MCP55\";\n}\n\nstruct pci_mmcfg_hostbridge_probe {\n\tu32 bus;\n\tu32 devfn;\n\tu32 vendor;\n\tu32 device;\n\tconst char *(*probe)(void);\n};\n\nstatic const struct pci_mmcfg_hostbridge_probe pci_mmcfg_probes[] __initconst = {\n\t{ 0, PCI_DEVFN(0, 0), PCI_VENDOR_ID_INTEL,\n\t  PCI_DEVICE_ID_INTEL_E7520_MCH, pci_mmcfg_e7520 },\n\t{ 0, PCI_DEVFN(0, 0), PCI_VENDOR_ID_INTEL,\n\t  PCI_DEVICE_ID_INTEL_82945G_HB, pci_mmcfg_intel_945 },\n\t{ 0, PCI_DEVFN(0x18, 0), PCI_VENDOR_ID_AMD,\n\t  0x1200, pci_mmcfg_amd_fam10h },\n\t{ 0xff, PCI_DEVFN(0, 0), PCI_VENDOR_ID_AMD,\n\t  0x1200, pci_mmcfg_amd_fam10h },\n\t{ 0, PCI_DEVFN(0, 0), PCI_VENDOR_ID_NVIDIA,\n\t  0x0369, pci_mmcfg_nvidia_mcp55 },\n};\n\nstatic void __init pci_mmcfg_check_end_bus_number(void)\n{\n\tstruct pci_mmcfg_region *cfg, *cfgx;\n\n\t \n\tlist_for_each_entry(cfg, &pci_mmcfg_list, list) {\n\t\tif (cfg->end_bus < cfg->start_bus)\n\t\t\tcfg->end_bus = 255;\n\n\t\t \n\t\tif (cfg->list.next == &pci_mmcfg_list)\n\t\t\tbreak;\n\n\t\tcfgx = list_entry(cfg->list.next, typeof(*cfg), list);\n\t\tif (cfg->end_bus >= cfgx->start_bus)\n\t\t\tcfg->end_bus = cfgx->start_bus - 1;\n\t}\n}\n\nstatic int __init pci_mmcfg_check_hostbridge(void)\n{\n\tu32 l;\n\tu32 bus, devfn;\n\tu16 vendor, device;\n\tint i;\n\tconst char *name;\n\n\tif (!raw_pci_ops)\n\t\treturn 0;\n\n\tfree_all_mmcfg();\n\n\tfor (i = 0; i < ARRAY_SIZE(pci_mmcfg_probes); i++) {\n\t\tbus =  pci_mmcfg_probes[i].bus;\n\t\tdevfn = pci_mmcfg_probes[i].devfn;\n\t\traw_pci_ops->read(0, bus, devfn, 0, 4, &l);\n\t\tvendor = l & 0xffff;\n\t\tdevice = (l >> 16) & 0xffff;\n\n\t\tname = NULL;\n\t\tif (pci_mmcfg_probes[i].vendor == vendor &&\n\t\t    pci_mmcfg_probes[i].device == device)\n\t\t\tname = pci_mmcfg_probes[i].probe();\n\n\t\tif (name)\n\t\t\tpr_info(PREFIX \"%s with MMCONFIG support\\n\", name);\n\t}\n\n\t \n\tpci_mmcfg_check_end_bus_number();\n\n\treturn !list_empty(&pci_mmcfg_list);\n}\n\nstatic acpi_status check_mcfg_resource(struct acpi_resource *res, void *data)\n{\n\tstruct resource *mcfg_res = data;\n\tstruct acpi_resource_address64 address;\n\tacpi_status status;\n\n\tif (res->type == ACPI_RESOURCE_TYPE_FIXED_MEMORY32) {\n\t\tstruct acpi_resource_fixed_memory32 *fixmem32 =\n\t\t\t&res->data.fixed_memory32;\n\t\tif (!fixmem32)\n\t\t\treturn AE_OK;\n\t\tif ((mcfg_res->start >= fixmem32->address) &&\n\t\t    (mcfg_res->end < (fixmem32->address +\n\t\t\t\t      fixmem32->address_length))) {\n\t\t\tmcfg_res->flags = 1;\n\t\t\treturn AE_CTRL_TERMINATE;\n\t\t}\n\t}\n\tif ((res->type != ACPI_RESOURCE_TYPE_ADDRESS32) &&\n\t    (res->type != ACPI_RESOURCE_TYPE_ADDRESS64))\n\t\treturn AE_OK;\n\n\tstatus = acpi_resource_to_address64(res, &address);\n\tif (ACPI_FAILURE(status) ||\n\t   (address.address.address_length <= 0) ||\n\t   (address.resource_type != ACPI_MEMORY_RANGE))\n\t\treturn AE_OK;\n\n\tif ((mcfg_res->start >= address.address.minimum) &&\n\t    (mcfg_res->end < (address.address.minimum + address.address.address_length))) {\n\t\tmcfg_res->flags = 1;\n\t\treturn AE_CTRL_TERMINATE;\n\t}\n\treturn AE_OK;\n}\n\nstatic acpi_status find_mboard_resource(acpi_handle handle, u32 lvl,\n\t\t\t\t\tvoid *context, void **rv)\n{\n\tstruct resource *mcfg_res = context;\n\n\tacpi_walk_resources(handle, METHOD_NAME__CRS,\n\t\t\t    check_mcfg_resource, context);\n\n\tif (mcfg_res->flags)\n\t\treturn AE_CTRL_TERMINATE;\n\n\treturn AE_OK;\n}\n\nstatic bool is_acpi_reserved(u64 start, u64 end, enum e820_type not_used)\n{\n\tstruct resource mcfg_res;\n\n\tmcfg_res.start = start;\n\tmcfg_res.end = end - 1;\n\tmcfg_res.flags = 0;\n\n\tacpi_get_devices(\"PNP0C01\", find_mboard_resource, &mcfg_res, NULL);\n\n\tif (!mcfg_res.flags)\n\t\tacpi_get_devices(\"PNP0C02\", find_mboard_resource, &mcfg_res,\n\t\t\t\t NULL);\n\n\treturn mcfg_res.flags;\n}\n\nstatic bool is_efi_mmio(u64 start, u64 end, enum e820_type not_used)\n{\n#ifdef CONFIG_EFI\n\tefi_memory_desc_t *md;\n\tu64 size, mmio_start, mmio_end;\n\n\tfor_each_efi_memory_desc(md) {\n\t\tif (md->type == EFI_MEMORY_MAPPED_IO) {\n\t\t\tsize = md->num_pages << EFI_PAGE_SHIFT;\n\t\t\tmmio_start = md->phys_addr;\n\t\t\tmmio_end = mmio_start + size;\n\n\t\t\t \n\t\t\tif (mmio_start <= start && end <= mmio_end)\n\t\t\t\treturn true;\n\t\t}\n\t}\n#endif\n\n\treturn false;\n}\n\ntypedef bool (*check_reserved_t)(u64 start, u64 end, enum e820_type type);\n\nstatic bool __ref is_mmconf_reserved(check_reserved_t is_reserved,\n\t\t\t\t     struct pci_mmcfg_region *cfg,\n\t\t\t\t     struct device *dev, const char *method)\n{\n\tu64 addr = cfg->res.start;\n\tu64 size = resource_size(&cfg->res);\n\tu64 old_size = size;\n\tint num_buses;\n\n\twhile (!is_reserved(addr, addr + size, E820_TYPE_RESERVED)) {\n\t\tsize >>= 1;\n\t\tif (size < (16UL<<20))\n\t\t\tbreak;\n\t}\n\n\tif (size < (16UL<<20) && size != old_size)\n\t\treturn false;\n\n\tif (dev)\n\t\tdev_info(dev, \"MMCONFIG at %pR reserved as %s\\n\",\n\t\t\t &cfg->res, method);\n\telse\n\t\tpr_info(PREFIX \"MMCONFIG at %pR reserved as %s\\n\",\n\t\t       &cfg->res, method);\n\n\tif (old_size != size) {\n\t\t \n\t\tcfg->end_bus = cfg->start_bus + ((size>>20) - 1);\n\t\tnum_buses = cfg->end_bus - cfg->start_bus + 1;\n\t\tcfg->res.end = cfg->res.start +\n\t\t    PCI_MMCFG_BUS_OFFSET(num_buses) - 1;\n\t\tsnprintf(cfg->name, PCI_MMCFG_RESOURCE_NAME_LEN,\n\t\t\t \"PCI MMCONFIG %04x [bus %02x-%02x]\",\n\t\t\t cfg->segment, cfg->start_bus, cfg->end_bus);\n\n\t\tif (dev)\n\t\t\tdev_info(dev,\n\t\t\t\t\"MMCONFIG \"\n\t\t\t\t\"at %pR (base %#lx) (size reduced!)\\n\",\n\t\t\t\t&cfg->res, (unsigned long) cfg->address);\n\t\telse\n\t\t\tpr_info(PREFIX\n\t\t\t\t\"MMCONFIG for %04x [bus%02x-%02x] \"\n\t\t\t\t\"at %pR (base %#lx) (size reduced!)\\n\",\n\t\t\t\tcfg->segment, cfg->start_bus, cfg->end_bus,\n\t\t\t\t&cfg->res, (unsigned long) cfg->address);\n\t}\n\n\treturn true;\n}\n\nstatic bool __ref\npci_mmcfg_check_reserved(struct device *dev, struct pci_mmcfg_region *cfg, int early)\n{\n\tstruct resource *conflict;\n\n\tif (!early && !acpi_disabled) {\n\t\tif (is_mmconf_reserved(is_acpi_reserved, cfg, dev,\n\t\t\t\t       \"ACPI motherboard resource\"))\n\t\t\treturn true;\n\n\t\tif (dev)\n\t\t\tdev_info(dev, FW_INFO\n\t\t\t\t \"MMCONFIG at %pR not reserved in \"\n\t\t\t\t \"ACPI motherboard resources\\n\",\n\t\t\t\t &cfg->res);\n\t\telse\n\t\t\tpr_info(FW_INFO PREFIX\n\t\t\t       \"MMCONFIG at %pR not reserved in \"\n\t\t\t       \"ACPI motherboard resources\\n\",\n\t\t\t       &cfg->res);\n\n\t\tif (is_mmconf_reserved(is_efi_mmio, cfg, dev,\n\t\t\t\t       \"EfiMemoryMappedIO\")) {\n\t\t\tconflict = insert_resource_conflict(&iomem_resource,\n\t\t\t\t\t\t\t    &cfg->res);\n\t\t\tif (conflict)\n\t\t\t\tpr_warn(\"MMCONFIG %pR conflicts with %s %pR\\n\",\n\t\t\t\t\t&cfg->res, conflict->name, conflict);\n\t\t\telse\n\t\t\t\tpr_info(\"MMCONFIG %pR reserved to work around lack of ACPI motherboard _CRS\\n\",\n\t\t\t\t\t&cfg->res);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t \n\tif (pci_mmcfg_running_state)\n\t\treturn true;\n\n\t \n\tif (raw_pci_ops)\n\t\treturn is_mmconf_reserved(e820__mapped_all, cfg, dev,\n\t\t\t\t\t  \"E820 entry\");\n\n\treturn false;\n}\n\nstatic void __init pci_mmcfg_reject_broken(int early)\n{\n\tstruct pci_mmcfg_region *cfg;\n\n\tlist_for_each_entry(cfg, &pci_mmcfg_list, list) {\n\t\tif (pci_mmcfg_check_reserved(NULL, cfg, early) == 0) {\n\t\t\tpr_info(PREFIX \"not using MMCONFIG\\n\");\n\t\t\tfree_all_mmcfg();\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int __init acpi_mcfg_check_entry(struct acpi_table_mcfg *mcfg,\n\t\t\t\t\tstruct acpi_mcfg_allocation *cfg)\n{\n\tif (cfg->address < 0xFFFFFFFF)\n\t\treturn 0;\n\n\tif (!strncmp(mcfg->header.oem_id, \"SGI\", 3))\n\t\treturn 0;\n\n\tif ((mcfg->header.revision >= 1) && (dmi_get_bios_year() >= 2010))\n\t\treturn 0;\n\n\tpr_err(PREFIX \"MCFG region for %04x [bus %02x-%02x] at %#llx \"\n\t       \"is above 4GB, ignored\\n\", cfg->pci_segment,\n\t       cfg->start_bus_number, cfg->end_bus_number, cfg->address);\n\treturn -EINVAL;\n}\n\nstatic int __init pci_parse_mcfg(struct acpi_table_header *header)\n{\n\tstruct acpi_table_mcfg *mcfg;\n\tstruct acpi_mcfg_allocation *cfg_table, *cfg;\n\tunsigned long i;\n\tint entries;\n\n\tif (!header)\n\t\treturn -EINVAL;\n\n\tmcfg = (struct acpi_table_mcfg *)header;\n\n\t \n\tfree_all_mmcfg();\n\tentries = 0;\n\ti = header->length - sizeof(struct acpi_table_mcfg);\n\twhile (i >= sizeof(struct acpi_mcfg_allocation)) {\n\t\tentries++;\n\t\ti -= sizeof(struct acpi_mcfg_allocation);\n\t}\n\tif (entries == 0) {\n\t\tpr_err(PREFIX \"MMCONFIG has no entries\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcfg_table = (struct acpi_mcfg_allocation *) &mcfg[1];\n\tfor (i = 0; i < entries; i++) {\n\t\tcfg = &cfg_table[i];\n\t\tif (acpi_mcfg_check_entry(mcfg, cfg)) {\n\t\t\tfree_all_mmcfg();\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (pci_mmconfig_add(cfg->pci_segment, cfg->start_bus_number,\n\t\t\t\t   cfg->end_bus_number, cfg->address) == NULL) {\n\t\t\tpr_warn(PREFIX \"no memory for MCFG entries\\n\");\n\t\t\tfree_all_mmcfg();\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI_APEI\nextern int (*arch_apei_filter_addr)(int (*func)(__u64 start, __u64 size,\n\t\t\t\t     void *data), void *data);\n\nstatic int pci_mmcfg_for_each_region(int (*func)(__u64 start, __u64 size,\n\t\t\t\t     void *data), void *data)\n{\n\tstruct pci_mmcfg_region *cfg;\n\tint rc;\n\n\tif (list_empty(&pci_mmcfg_list))\n\t\treturn 0;\n\n\tlist_for_each_entry(cfg, &pci_mmcfg_list, list) {\n\t\trc = func(cfg->res.start, resource_size(&cfg->res), data);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n#define set_apei_filter() (arch_apei_filter_addr = pci_mmcfg_for_each_region)\n#else\n#define set_apei_filter()\n#endif\n\nstatic void __init __pci_mmcfg_init(int early)\n{\n\tpci_mmcfg_reject_broken(early);\n\tif (list_empty(&pci_mmcfg_list))\n\t\treturn;\n\n\tif (pcibios_last_bus < 0) {\n\t\tconst struct pci_mmcfg_region *cfg;\n\n\t\tlist_for_each_entry(cfg, &pci_mmcfg_list, list) {\n\t\t\tif (cfg->segment)\n\t\t\t\tbreak;\n\t\t\tpcibios_last_bus = cfg->end_bus;\n\t\t}\n\t}\n\n\tif (pci_mmcfg_arch_init())\n\t\tpci_probe = (pci_probe & ~PCI_PROBE_MASK) | PCI_PROBE_MMCONF;\n\telse {\n\t\tfree_all_mmcfg();\n\t\tpci_mmcfg_arch_init_failed = true;\n\t}\n}\n\nstatic int __initdata known_bridge;\n\nvoid __init pci_mmcfg_early_init(void)\n{\n\tif (pci_probe & PCI_PROBE_MMCONF) {\n\t\tif (pci_mmcfg_check_hostbridge())\n\t\t\tknown_bridge = 1;\n\t\telse\n\t\t\tacpi_table_parse(ACPI_SIG_MCFG, pci_parse_mcfg);\n\t\t__pci_mmcfg_init(1);\n\n\t\tset_apei_filter();\n\t}\n}\n\nvoid __init pci_mmcfg_late_init(void)\n{\n\t \n\tif ((pci_probe & PCI_PROBE_MMCONF) == 0)\n\t\treturn;\n\n\tif (known_bridge)\n\t\treturn;\n\n\t \n\tif (pci_probe & PCI_PROBE_MASK & ~PCI_PROBE_MMCONF) {\n\t\tacpi_table_parse(ACPI_SIG_MCFG, pci_parse_mcfg);\n\t\t__pci_mmcfg_init(0);\n\t}\n}\n\nstatic int __init pci_mmcfg_late_insert_resources(void)\n{\n\tstruct pci_mmcfg_region *cfg;\n\n\tpci_mmcfg_running_state = true;\n\n\t \n\tif ((pci_probe & PCI_PROBE_MMCONF) == 0)\n\t\treturn 1;\n\n\t \n\tlist_for_each_entry(cfg, &pci_mmcfg_list, list)\n\t\tif (!cfg->res.parent)\n\t\t\tinsert_resource(&iomem_resource, &cfg->res);\n\n\treturn 0;\n}\n\n \nlate_initcall(pci_mmcfg_late_insert_resources);\n\n \nint pci_mmconfig_insert(struct device *dev, u16 seg, u8 start, u8 end,\n\t\t\tphys_addr_t addr)\n{\n\tint rc;\n\tstruct resource *tmp = NULL;\n\tstruct pci_mmcfg_region *cfg;\n\n\tif (!(pci_probe & PCI_PROBE_MMCONF) || pci_mmcfg_arch_init_failed)\n\t\treturn -ENODEV;\n\n\tif (start > end)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&pci_mmcfg_lock);\n\tcfg = pci_mmconfig_lookup(seg, start);\n\tif (cfg) {\n\t\tif (cfg->end_bus < end)\n\t\t\tdev_info(dev, FW_INFO\n\t\t\t\t \"MMCONFIG for \"\n\t\t\t\t \"domain %04x [bus %02x-%02x] \"\n\t\t\t\t \"only partially covers this bridge\\n\",\n\t\t\t\t  cfg->segment, cfg->start_bus, cfg->end_bus);\n\t\tmutex_unlock(&pci_mmcfg_lock);\n\t\treturn -EEXIST;\n\t}\n\n\tif (!addr) {\n\t\tmutex_unlock(&pci_mmcfg_lock);\n\t\treturn -EINVAL;\n\t}\n\n\trc = -EBUSY;\n\tcfg = pci_mmconfig_alloc(seg, start, end, addr);\n\tif (cfg == NULL) {\n\t\tdev_warn(dev, \"fail to add MMCONFIG (out of memory)\\n\");\n\t\trc = -ENOMEM;\n\t} else if (!pci_mmcfg_check_reserved(dev, cfg, 0)) {\n\t\tdev_warn(dev, FW_BUG \"MMCONFIG %pR isn't reserved\\n\",\n\t\t\t &cfg->res);\n\t} else {\n\t\t \n\t\tif (pci_mmcfg_running_state)\n\t\t\ttmp = insert_resource_conflict(&iomem_resource,\n\t\t\t\t\t\t       &cfg->res);\n\n\t\tif (tmp) {\n\t\t\tdev_warn(dev,\n\t\t\t\t \"MMCONFIG %pR conflicts with \"\n\t\t\t\t \"%s %pR\\n\",\n\t\t\t\t &cfg->res, tmp->name, tmp);\n\t\t} else if (pci_mmcfg_arch_map(cfg)) {\n\t\t\tdev_warn(dev, \"fail to map MMCONFIG %pR.\\n\",\n\t\t\t\t &cfg->res);\n\t\t} else {\n\t\t\tlist_add_sorted(cfg);\n\t\t\tdev_info(dev, \"MMCONFIG at %pR (base %#lx)\\n\",\n\t\t\t\t &cfg->res, (unsigned long)addr);\n\t\t\tcfg = NULL;\n\t\t\trc = 0;\n\t\t}\n\t}\n\n\tif (cfg) {\n\t\tif (cfg->res.parent)\n\t\t\trelease_resource(&cfg->res);\n\t\tkfree(cfg);\n\t}\n\n\tmutex_unlock(&pci_mmcfg_lock);\n\n\treturn rc;\n}\n\n \nint pci_mmconfig_delete(u16 seg, u8 start, u8 end)\n{\n\tstruct pci_mmcfg_region *cfg;\n\n\tmutex_lock(&pci_mmcfg_lock);\n\tlist_for_each_entry_rcu(cfg, &pci_mmcfg_list, list)\n\t\tif (cfg->segment == seg && cfg->start_bus == start &&\n\t\t    cfg->end_bus == end) {\n\t\t\tlist_del_rcu(&cfg->list);\n\t\t\tsynchronize_rcu();\n\t\t\tpci_mmcfg_arch_unmap(cfg);\n\t\t\tif (cfg->res.parent)\n\t\t\t\trelease_resource(&cfg->res);\n\t\t\tmutex_unlock(&pci_mmcfg_lock);\n\t\t\tkfree(cfg);\n\t\t\treturn 0;\n\t\t}\n\tmutex_unlock(&pci_mmcfg_lock);\n\n\treturn -ENOENT;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}