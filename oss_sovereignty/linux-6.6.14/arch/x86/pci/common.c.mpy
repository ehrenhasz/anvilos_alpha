{
  "module_name": "common.c",
  "hash_id": "6739b12130aabb698fe21a3e11d30dd67a1804f9386de30a7c002bd754845826",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/pci/common.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/pci.h>\n#include <linux/pci-acpi.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/dmi.h>\n#include <linux/slab.h>\n\n#include <asm/acpi.h>\n#include <asm/segment.h>\n#include <asm/io.h>\n#include <asm/smp.h>\n#include <asm/pci_x86.h>\n#include <asm/setup.h>\n#include <asm/irqdomain.h>\n\nunsigned int pci_probe = PCI_PROBE_BIOS | PCI_PROBE_CONF1 | PCI_PROBE_CONF2 |\n\t\t\t\tPCI_PROBE_MMCONF;\n\nstatic int pci_bf_sort;\nint pci_routeirq;\nint noioapicquirk;\n#ifdef CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS\nint noioapicreroute = 0;\n#else\nint noioapicreroute = 1;\n#endif\nint pcibios_last_bus = -1;\nunsigned long pirq_table_addr;\nconst struct pci_raw_ops *__read_mostly raw_pci_ops;\nconst struct pci_raw_ops *__read_mostly raw_pci_ext_ops;\n\nint raw_pci_read(unsigned int domain, unsigned int bus, unsigned int devfn,\n\t\t\t\t\t\tint reg, int len, u32 *val)\n{\n\tif (domain == 0 && reg < 256 && raw_pci_ops)\n\t\treturn raw_pci_ops->read(domain, bus, devfn, reg, len, val);\n\tif (raw_pci_ext_ops)\n\t\treturn raw_pci_ext_ops->read(domain, bus, devfn, reg, len, val);\n\treturn -EINVAL;\n}\n\nint raw_pci_write(unsigned int domain, unsigned int bus, unsigned int devfn,\n\t\t\t\t\t\tint reg, int len, u32 val)\n{\n\tif (domain == 0 && reg < 256 && raw_pci_ops)\n\t\treturn raw_pci_ops->write(domain, bus, devfn, reg, len, val);\n\tif (raw_pci_ext_ops)\n\t\treturn raw_pci_ext_ops->write(domain, bus, devfn, reg, len, val);\n\treturn -EINVAL;\n}\n\nstatic int pci_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 *value)\n{\n\treturn raw_pci_read(pci_domain_nr(bus), bus->number,\n\t\t\t\t devfn, where, size, value);\n}\n\nstatic int pci_write(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 value)\n{\n\treturn raw_pci_write(pci_domain_nr(bus), bus->number,\n\t\t\t\t  devfn, where, size, value);\n}\n\nstruct pci_ops pci_root_ops = {\n\t.read = pci_read,\n\t.write = pci_write,\n};\n\n \nDEFINE_RAW_SPINLOCK(pci_config_lock);\n\nstatic int __init can_skip_ioresource_align(const struct dmi_system_id *d)\n{\n\tpci_probe |= PCI_CAN_SKIP_ISA_ALIGN;\n\tprintk(KERN_INFO \"PCI: %s detected, can skip ISA alignment\\n\", d->ident);\n\treturn 0;\n}\n\nstatic const struct dmi_system_id can_skip_pciprobe_dmi_table[] __initconst = {\n \n\t{\n\t\t.callback = can_skip_ioresource_align,\n\t\t.ident = \"IBM System x3800\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"IBM\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"x3800\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = can_skip_ioresource_align,\n\t\t.ident = \"IBM System x3850\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"IBM\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"x3850\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = can_skip_ioresource_align,\n\t\t.ident = \"IBM System x3950\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"IBM\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"x3950\"),\n\t\t},\n\t},\n\t{}\n};\n\nvoid __init dmi_check_skip_isa_align(void)\n{\n\tdmi_check_system(can_skip_pciprobe_dmi_table);\n}\n\nstatic void pcibios_fixup_device_resources(struct pci_dev *dev)\n{\n\tstruct resource *rom_r = &dev->resource[PCI_ROM_RESOURCE];\n\tstruct resource *bar_r;\n\tint bar;\n\n\tif (pci_probe & PCI_NOASSIGN_BARS) {\n\t\t \n\t\tfor (bar = 0; bar < PCI_STD_NUM_BARS; bar++) {\n\t\t\tbar_r = &dev->resource[bar];\n\t\t\tif (bar_r->start == 0 && bar_r->end != 0) {\n\t\t\t\tbar_r->flags = 0;\n\t\t\t\tbar_r->end = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pci_probe & PCI_NOASSIGN_ROMS) {\n\t\tif (rom_r->parent)\n\t\t\treturn;\n\t\tif (rom_r->start) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t\trom_r->start = rom_r->end = rom_r->flags = 0;\n\t}\n}\n\n \n\nvoid pcibios_fixup_bus(struct pci_bus *b)\n{\n\tstruct pci_dev *dev;\n\n\tpci_read_bridge_bases(b);\n\tlist_for_each_entry(dev, &b->devices, bus_list)\n\t\tpcibios_fixup_device_resources(dev);\n}\n\nvoid pcibios_add_bus(struct pci_bus *bus)\n{\n\tacpi_pci_add_bus(bus);\n}\n\nvoid pcibios_remove_bus(struct pci_bus *bus)\n{\n\tacpi_pci_remove_bus(bus);\n}\n\n \n\nstatic int __init set_bf_sort(const struct dmi_system_id *d)\n{\n\tif (pci_bf_sort == pci_bf_sort_default) {\n\t\tpci_bf_sort = pci_dmi_bf;\n\t\tprintk(KERN_INFO \"PCI: %s detected, enabling pci=bfsort.\\n\", d->ident);\n\t}\n\treturn 0;\n}\n\nstatic void __init read_dmi_type_b1(const struct dmi_header *dm,\n\t\t\t\t    void *private_data)\n{\n\tu8 *data = (u8 *)dm + 4;\n\n\tif (dm->type != 0xB1)\n\t\treturn;\n\tif ((((*(u32 *)data) >> 9) & 0x03) == 0x01)\n\t\tset_bf_sort((const struct dmi_system_id *)private_data);\n}\n\nstatic int __init find_sort_method(const struct dmi_system_id *d)\n{\n\tdmi_walk(read_dmi_type_b1, (void *)d);\n\treturn 0;\n}\n\n \n#ifdef __i386__\nstatic int __init assign_all_busses(const struct dmi_system_id *d)\n{\n\tpci_probe |= PCI_ASSIGN_ALL_BUSSES;\n\tprintk(KERN_INFO \"%s detected: enabling PCI bus# renumbering\"\n\t\t\t\" (pci=assign-busses)\\n\", d->ident);\n\treturn 0;\n}\n#endif\n\nstatic int __init set_scan_all(const struct dmi_system_id *d)\n{\n\tprintk(KERN_INFO \"PCI: %s detected, enabling pci=pcie_scan_all\\n\",\n\t       d->ident);\n\tpci_add_flags(PCI_SCAN_ALL_PCIE_DEVS);\n\treturn 0;\n}\n\nstatic const struct dmi_system_id pciprobe_dmi_table[] __initconst = {\n#ifdef __i386__\n \n\t{\n\t\t.callback = assign_all_busses,\n\t\t.ident = \"Samsung X20 Laptop\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Samsung Electronics\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"SX20S\"),\n\t\t},\n\t},\n#endif\t\t \n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"Dell PowerEdge 1950\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"PowerEdge 1950\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"Dell PowerEdge 1955\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"PowerEdge 1955\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"Dell PowerEdge 2900\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"PowerEdge 2900\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"Dell PowerEdge 2950\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"PowerEdge 2950\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"Dell PowerEdge R900\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"PowerEdge R900\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = find_sort_method,\n\t\t.ident = \"Dell System\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"HP ProLiant BL20p G3\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ProLiant BL20p G3\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"HP ProLiant BL20p G4\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ProLiant BL20p G4\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"HP ProLiant BL30p G1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ProLiant BL30p G1\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"HP ProLiant BL25p G1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ProLiant BL25p G1\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"HP ProLiant BL35p G1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ProLiant BL35p G1\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"HP ProLiant BL45p G1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ProLiant BL45p G1\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"HP ProLiant BL45p G2\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ProLiant BL45p G2\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"HP ProLiant BL460c G1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ProLiant BL460c G1\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"HP ProLiant BL465c G1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ProLiant BL465c G1\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"HP ProLiant BL480c G1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ProLiant BL480c G1\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"HP ProLiant BL685c G1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ProLiant BL685c G1\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"HP ProLiant DL360\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ProLiant DL360\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"HP ProLiant DL380\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ProLiant DL380\"),\n\t\t},\n\t},\n#ifdef __i386__\n\t{\n\t\t.callback = assign_all_busses,\n\t\t.ident = \"Compaq EVO N800c\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Compaq\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"EVO N800c\"),\n\t\t},\n\t},\n#endif\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"HP ProLiant DL385 G2\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ProLiant DL385 G2\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_bf_sort,\n\t\t.ident = \"HP ProLiant DL585 G2\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ProLiant DL585 G2\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_scan_all,\n\t\t.ident = \"Stratus/NEC ftServer\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Stratus\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ftServer\"),\n\t\t},\n\t},\n        {\n                .callback = set_scan_all,\n                .ident = \"Stratus/NEC ftServer\",\n                .matches = {\n                        DMI_MATCH(DMI_SYS_VENDOR, \"NEC\"),\n                        DMI_MATCH(DMI_PRODUCT_NAME, \"Express5800/R32\"),\n                },\n        },\n        {\n                .callback = set_scan_all,\n                .ident = \"Stratus/NEC ftServer\",\n                .matches = {\n                        DMI_MATCH(DMI_SYS_VENDOR, \"NEC\"),\n                        DMI_MATCH(DMI_PRODUCT_NAME, \"Express5800/R31\"),\n                },\n        },\n\t{}\n};\n\nvoid __init dmi_check_pciprobe(void)\n{\n\tdmi_check_system(pciprobe_dmi_table);\n}\n\nvoid pcibios_scan_root(int busnum)\n{\n\tstruct pci_bus *bus;\n\tstruct pci_sysdata *sd;\n\tLIST_HEAD(resources);\n\n\tsd = kzalloc(sizeof(*sd), GFP_KERNEL);\n\tif (!sd) {\n\t\tprintk(KERN_ERR \"PCI: OOM, skipping PCI bus %02x\\n\", busnum);\n\t\treturn;\n\t}\n\tsd->node = x86_pci_root_bus_node(busnum);\n\tx86_pci_root_bus_resources(busnum, &resources);\n\tprintk(KERN_DEBUG \"PCI: Probing PCI hardware (bus %02x)\\n\", busnum);\n\tbus = pci_scan_root_bus(NULL, busnum, &pci_root_ops, sd, &resources);\n\tif (!bus) {\n\t\tpci_free_resource_list(&resources);\n\t\tkfree(sd);\n\t\treturn;\n\t}\n\tpci_bus_add_devices(bus);\n}\n\nvoid __init pcibios_set_cache_line_size(void)\n{\n\tstruct cpuinfo_x86 *c = &boot_cpu_data;\n\n\t \n\tif (c->x86_clflush_size > 0) {\n\t\tpci_dfl_cache_line_size = c->x86_clflush_size >> 2;\n\t\tprintk(KERN_DEBUG \"PCI: pci_cache_line_size set to %d bytes\\n\",\n\t\t\tpci_dfl_cache_line_size << 2);\n\t} else {\n \t\tpci_dfl_cache_line_size = 32 >> 2;\n\t\tprintk(KERN_DEBUG \"PCI: Unknown cacheline size. Setting to 32 bytes\\n\");\n\t}\n}\n\nint __init pcibios_init(void)\n{\n\tif (!raw_pci_ops && !raw_pci_ext_ops) {\n\t\tprintk(KERN_WARNING \"PCI: System does not support PCI\\n\");\n\t\treturn 0;\n\t}\n\n\tpcibios_set_cache_line_size();\n\tpcibios_resource_survey();\n\n\tif (pci_bf_sort >= pci_force_bf)\n\t\tpci_sort_breadthfirst();\n\treturn 0;\n}\n\nchar *__init pcibios_setup(char *str)\n{\n\tif (!strcmp(str, \"off\")) {\n\t\tpci_probe = 0;\n\t\treturn NULL;\n\t} else if (!strcmp(str, \"bfsort\")) {\n\t\tpci_bf_sort = pci_force_bf;\n\t\treturn NULL;\n\t} else if (!strcmp(str, \"nobfsort\")) {\n\t\tpci_bf_sort = pci_force_nobf;\n\t\treturn NULL;\n\t}\n#ifdef CONFIG_PCI_BIOS\n\telse if (!strcmp(str, \"bios\")) {\n\t\tpci_probe = PCI_PROBE_BIOS;\n\t\treturn NULL;\n\t} else if (!strcmp(str, \"nobios\")) {\n\t\tpci_probe &= ~PCI_PROBE_BIOS;\n\t\treturn NULL;\n\t} else if (!strcmp(str, \"biosirq\")) {\n\t\tpci_probe |= PCI_BIOS_IRQ_SCAN;\n\t\treturn NULL;\n\t} else if (!strncmp(str, \"pirqaddr=\", 9)) {\n\t\tpirq_table_addr = simple_strtoul(str+9, NULL, 0);\n\t\treturn NULL;\n\t}\n#endif\n#ifdef CONFIG_PCI_DIRECT\n\telse if (!strcmp(str, \"conf1\")) {\n\t\tpci_probe = PCI_PROBE_CONF1 | PCI_NO_CHECKS;\n\t\treturn NULL;\n\t}\n\telse if (!strcmp(str, \"conf2\")) {\n\t\tpci_probe = PCI_PROBE_CONF2 | PCI_NO_CHECKS;\n\t\treturn NULL;\n\t}\n#endif\n#ifdef CONFIG_PCI_MMCONFIG\n\telse if (!strcmp(str, \"nommconf\")) {\n\t\tpci_probe &= ~PCI_PROBE_MMCONF;\n\t\treturn NULL;\n\t}\n\telse if (!strcmp(str, \"check_enable_amd_mmconf\")) {\n\t\tpci_probe |= PCI_CHECK_ENABLE_AMD_MMCONF;\n\t\treturn NULL;\n\t}\n#endif\n\telse if (!strcmp(str, \"noacpi\")) {\n\t\tacpi_noirq_set();\n\t\treturn NULL;\n\t}\n\telse if (!strcmp(str, \"noearly\")) {\n\t\tpci_probe |= PCI_PROBE_NOEARLY;\n\t\treturn NULL;\n\t}\n\telse if (!strcmp(str, \"usepirqmask\")) {\n\t\tpci_probe |= PCI_USE_PIRQ_MASK;\n\t\treturn NULL;\n\t} else if (!strncmp(str, \"irqmask=\", 8)) {\n\t\tpcibios_irq_mask = simple_strtol(str+8, NULL, 0);\n\t\treturn NULL;\n\t} else if (!strncmp(str, \"lastbus=\", 8)) {\n\t\tpcibios_last_bus = simple_strtol(str+8, NULL, 0);\n\t\treturn NULL;\n\t} else if (!strcmp(str, \"rom\")) {\n\t\tpci_probe |= PCI_ASSIGN_ROMS;\n\t\treturn NULL;\n\t} else if (!strcmp(str, \"norom\")) {\n\t\tpci_probe |= PCI_NOASSIGN_ROMS;\n\t\treturn NULL;\n\t} else if (!strcmp(str, \"nobar\")) {\n\t\tpci_probe |= PCI_NOASSIGN_BARS;\n\t\treturn NULL;\n\t} else if (!strcmp(str, \"assign-busses\")) {\n\t\tpci_probe |= PCI_ASSIGN_ALL_BUSSES;\n\t\treturn NULL;\n\t} else if (!strcmp(str, \"use_crs\")) {\n\t\tpci_probe |= PCI_USE__CRS;\n\t\treturn NULL;\n\t} else if (!strcmp(str, \"nocrs\")) {\n\t\tpci_probe |= PCI_ROOT_NO_CRS;\n\t\treturn NULL;\n\t} else if (!strcmp(str, \"use_e820\")) {\n\t\tpci_probe |= PCI_USE_E820;\n\t\tadd_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);\n\t\treturn NULL;\n\t} else if (!strcmp(str, \"no_e820\")) {\n\t\tpci_probe |= PCI_NO_E820;\n\t\tadd_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);\n\t\treturn NULL;\n#ifdef CONFIG_PHYS_ADDR_T_64BIT\n\t} else if (!strcmp(str, \"big_root_window\")) {\n\t\tpci_probe |= PCI_BIG_ROOT_WINDOW;\n\t\treturn NULL;\n#endif\n\t} else if (!strcmp(str, \"routeirq\")) {\n\t\tpci_routeirq = 1;\n\t\treturn NULL;\n\t} else if (!strcmp(str, \"skip_isa_align\")) {\n\t\tpci_probe |= PCI_CAN_SKIP_ISA_ALIGN;\n\t\treturn NULL;\n\t} else if (!strcmp(str, \"noioapicquirk\")) {\n\t\tnoioapicquirk = 1;\n\t\treturn NULL;\n\t} else if (!strcmp(str, \"ioapicreroute\")) {\n\t\tif (noioapicreroute != -1)\n\t\t\tnoioapicreroute = 0;\n\t\treturn NULL;\n\t} else if (!strcmp(str, \"noioapicreroute\")) {\n\t\tif (noioapicreroute != -1)\n\t\t\tnoioapicreroute = 1;\n\t\treturn NULL;\n\t}\n\treturn str;\n}\n\nunsigned int pcibios_assign_all_busses(void)\n{\n\treturn (pci_probe & PCI_ASSIGN_ALL_BUSSES) ? 1 : 0;\n}\n\nstatic void set_dev_domain_options(struct pci_dev *pdev)\n{\n\tif (is_vmd(pdev->bus))\n\t\tpdev->hotplug_user_indicators = 1;\n}\n\nint pcibios_device_add(struct pci_dev *dev)\n{\n\tstruct pci_setup_rom *rom;\n\tstruct irq_domain *msidom;\n\tstruct setup_data *data;\n\tu64 pa_data;\n\n\tpa_data = boot_params.hdr.setup_data;\n\twhile (pa_data) {\n\t\tdata = memremap(pa_data, sizeof(*rom), MEMREMAP_WB);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tif (data->type == SETUP_PCI) {\n\t\t\trom = (struct pci_setup_rom *)data;\n\n\t\t\tif ((pci_domain_nr(dev->bus) == rom->segment) &&\n\t\t\t    (dev->bus->number == rom->bus) &&\n\t\t\t    (PCI_SLOT(dev->devfn) == rom->device) &&\n\t\t\t    (PCI_FUNC(dev->devfn) == rom->function) &&\n\t\t\t    (dev->vendor == rom->vendor) &&\n\t\t\t    (dev->device == rom->devid)) {\n\t\t\t\tdev->rom = pa_data +\n\t\t\t\t      offsetof(struct pci_setup_rom, romdata);\n\t\t\t\tdev->romlen = rom->pcilen;\n\t\t\t}\n\t\t}\n\t\tpa_data = data->next;\n\t\tmemunmap(data);\n\t}\n\tset_dev_domain_options(dev);\n\n\t \n\tmsidom = dev_get_msi_domain(&dev->bus->dev);\n\tif (!msidom)\n\t\tmsidom = x86_pci_msi_default_domain;\n\tdev_set_msi_domain(&dev->dev, msidom);\n\treturn 0;\n}\n\nint pcibios_enable_device(struct pci_dev *dev, int mask)\n{\n\tint err;\n\n\tif ((err = pci_enable_resources(dev, mask)) < 0)\n\t\treturn err;\n\n\tif (!pci_dev_msi_enabled(dev))\n\t\treturn pcibios_enable_irq(dev);\n\treturn 0;\n}\n\nvoid pcibios_disable_device (struct pci_dev *dev)\n{\n\tif (!pci_dev_msi_enabled(dev) && pcibios_disable_irq)\n\t\tpcibios_disable_irq(dev);\n}\n\n#ifdef CONFIG_ACPI_HOTPLUG_IOAPIC\nvoid pcibios_release_device(struct pci_dev *dev)\n{\n\tif (atomic_dec_return(&dev->enable_cnt) >= 0)\n\t\tpcibios_disable_device(dev);\n\n}\n#endif\n\nint pci_ext_cfg_avail(void)\n{\n\tif (raw_pci_ext_ops)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_VMD)\nstruct pci_dev *pci_real_dma_dev(struct pci_dev *dev)\n{\n\tif (is_vmd(dev->bus))\n\t\treturn to_pci_sysdata(dev->bus)->vmd_dev;\n\n\treturn dev;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}