{
  "module_name": "broadcom_bus.c",
  "hash_id": "1bf940ed30085d9a49f3f4ddbefd49c800088f1856dfb68f4378fd6fe48f376b",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/pci/broadcom_bus.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <asm/pci_x86.h>\n#include <asm/pci-direct.h>\n\n#include \"bus_numa.h\"\n\nstatic void __init cnb20le_res(u8 bus, u8 slot, u8 func)\n{\n\tstruct pci_root_info *info;\n\tstruct pci_root_res *root_res;\n\tstruct resource res;\n\tu16 word1, word2;\n\tu8 fbus, lbus;\n\n\t \n\tfbus = read_pci_config_byte(bus, slot, func, 0x44);\n\tlbus = read_pci_config_byte(bus, slot, func, 0x45);\n\tinfo = alloc_pci_root_info(fbus, lbus, 0, 0);\n\n\t \n\tif (fbus == 0) {\n\t\tupdate_res(info, 0x01f0, 0x01f7, IORESOURCE_IO, 0);\n\t\tupdate_res(info, 0x03f6, 0x03f6, IORESOURCE_IO, 0);\n\t\tupdate_res(info, 0x0170, 0x0177, IORESOURCE_IO, 0);\n\t\tupdate_res(info, 0x0376, 0x0376, IORESOURCE_IO, 0);\n\t\tupdate_res(info, 0xffa0, 0xffaf, IORESOURCE_IO, 0);\n\t}\n\n\t \n\tword1 = read_pci_config_16(bus, slot, func, 0xc0);\n\tword2 = read_pci_config_16(bus, slot, func, 0xc2);\n\tif (word1 != word2) {\n\t\tres.start = ((resource_size_t) word1 << 16) | 0x0000;\n\t\tres.end   = ((resource_size_t) word2 << 16) | 0xffff;\n\t\tres.flags = IORESOURCE_MEM;\n\t\tupdate_res(info, res.start, res.end, res.flags, 0);\n\t}\n\n\t \n\tword1 = read_pci_config_16(bus, slot, func, 0xc4);\n\tword2 = read_pci_config_16(bus, slot, func, 0xc6);\n\tif (word1 != word2) {\n\t\tres.start = ((resource_size_t) word1 << 16) | 0x0000;\n\t\tres.end   = ((resource_size_t) word2 << 16) | 0xffff;\n\t\tres.flags = IORESOURCE_MEM | IORESOURCE_PREFETCH;\n\t\tupdate_res(info, res.start, res.end, res.flags, 0);\n\t}\n\n\t \n\tword1 = read_pci_config_16(bus, slot, func, 0xd0);\n\tword2 = read_pci_config_16(bus, slot, func, 0xd2);\n\tif (word1 != word2) {\n\t\tres.start = word1;\n\t\tres.end   = word2;\n\t\tres.flags = IORESOURCE_IO;\n\t\tupdate_res(info, res.start, res.end, res.flags, 0);\n\t}\n\n\t \n\tres.start = fbus;\n\tres.end   = lbus;\n\tres.flags = IORESOURCE_BUS;\n\tprintk(KERN_INFO \"CNB20LE PCI Host Bridge (domain 0000 %pR)\\n\", &res);\n\n\tlist_for_each_entry(root_res, &info->resources, list)\n\t\tprintk(KERN_INFO \"host bridge window %pR\\n\", &root_res->res);\n}\n\nstatic int __init broadcom_postcore_init(void)\n{\n\tu8 bus = 0, slot = 0;\n\tu32 id;\n\tu16 vendor, device;\n\n#ifdef CONFIG_ACPI\n\t \n\tif (!acpi_disabled && acpi_os_get_root_pointer())\n\t\treturn 0;\n#endif\n\n\tid = read_pci_config(bus, slot, 0, PCI_VENDOR_ID);\n\tvendor = id & 0xffff;\n\tdevice = (id >> 16) & 0xffff;\n\n\tif (vendor == PCI_VENDOR_ID_SERVERWORKS &&\n\t    device == PCI_DEVICE_ID_SERVERWORKS_LE) {\n\t\tcnb20le_res(bus, slot, 0);\n\t\tcnb20le_res(bus, slot, 1);\n\t}\n\treturn 0;\n}\n\npostcore_initcall(broadcom_postcore_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}