{
  "module_name": "acpi.c",
  "hash_id": "89820f765472c0bf61dd38dffae9ed0bbfd5640293aa3b90a60c73e55d96e481",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/pci/acpi.c",
  "human_readable_source": "\n\n#define pr_fmt(fmt) \"PCI: \" fmt\n\n#include <linux/pci.h>\n#include <linux/acpi.h>\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/dmi.h>\n#include <linux/slab.h>\n#include <linux/pci-acpi.h>\n#include <asm/numa.h>\n#include <asm/pci_x86.h>\n\nstruct pci_root_info {\n\tstruct acpi_pci_root_info common;\n\tstruct pci_sysdata sd;\n#ifdef\tCONFIG_PCI_MMCONFIG\n\tbool mcfg_added;\n\tu8 start_bus;\n\tu8 end_bus;\n#endif\n};\n\nbool pci_use_e820 = true;\nstatic bool pci_use_crs = true;\nstatic bool pci_ignore_seg;\n\nstatic int __init set_use_crs(const struct dmi_system_id *id)\n{\n\tpci_use_crs = true;\n\treturn 0;\n}\n\nstatic int __init set_nouse_crs(const struct dmi_system_id *id)\n{\n\tpci_use_crs = false;\n\treturn 0;\n}\n\nstatic int __init set_ignore_seg(const struct dmi_system_id *id)\n{\n\tpr_info(\"%s detected: ignoring ACPI _SEG\\n\", id->ident);\n\tpci_ignore_seg = true;\n\treturn 0;\n}\n\nstatic int __init set_no_e820(const struct dmi_system_id *id)\n{\n\tpr_info(\"%s detected: not clipping E820 regions from _CRS\\n\",\n\t        id->ident);\n\tpci_use_e820 = false;\n\treturn 0;\n}\n\nstatic const struct dmi_system_id pci_crs_quirks[] __initconst = {\n\t \n        {\n\t\t.callback = set_use_crs,\n\t\t.ident = \"ASRock ALiveSATA2-GLAN\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ALiveSATA2-GLAN\"),\n                },\n        },\n\t \n\t{\n\t\t.callback = set_use_crs,\n\t\t.ident = \"ASUS M2V-MX SE\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"M2V-MX SE\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VENDOR, \"American Megatrends Inc.\"),\n\t\t},\n\t},\n\t \n\n\t \n\t{\n\t\t.callback = set_no_e820,\n\t\t.ident = \"Lenovo *IIL* product version\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"IIL\"),\n\t\t},\n\t},\n\n\t \n\t{\n\t\t.callback = set_no_e820,\n\t\t.ident = \"Acer Spin 5 (SP513-54N)\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Spin SP513-54N\"),\n\t\t},\n\t},\n\n\t \n\t{\n\t\t.callback = set_no_e820,\n\t\t.ident = \"Clevo X170KM-G Barebone\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"X170KM-G\"),\n\t\t},\n\t},\n\t{}\n};\n\nvoid __init pci_acpi_crs_quirks(void)\n{\n\tint year = dmi_get_bios_year();\n\n\tif (year >= 0 && year < 2008 && iomem_resource.end <= 0xffffffff)\n\t\tpci_use_crs = false;\n\n\t \n\tif (year >= 2023)\n\t\tpci_use_e820 = false;\n\n\tdmi_check_system(pci_crs_quirks);\n\n\t \n\tif (pci_probe & PCI_ROOT_NO_CRS)\n\t\tpci_use_crs = false;\n\telse if (pci_probe & PCI_USE__CRS)\n\t\tpci_use_crs = true;\n\n\tpr_info(\"%s host bridge windows from ACPI; if necessary, use \\\"pci=%s\\\" and report a bug\\n\",\n\t        pci_use_crs ? \"Using\" : \"Ignoring\",\n\t        pci_use_crs ? \"nocrs\" : \"use_crs\");\n\n\t \n\tif (pci_probe & PCI_NO_E820)\n\t\tpci_use_e820 = false;\n\telse if (pci_probe & PCI_USE_E820)\n\t\tpci_use_e820 = true;\n\n\tpr_info(\"%s E820 reservations for host bridge windows\\n\",\n\t        pci_use_e820 ? \"Using\" : \"Ignoring\");\n\tif (pci_probe & (PCI_NO_E820 | PCI_USE_E820))\n\t\tpr_info(\"Please notify linux-pci@vger.kernel.org so future kernels can do this automatically\\n\");\n}\n\n#ifdef\tCONFIG_PCI_MMCONFIG\nstatic int check_segment(u16 seg, struct device *dev, char *estr)\n{\n\tif (seg) {\n\t\tdev_err(dev, \"%s can't access configuration space under this host bridge\\n\",\n\t\t\testr);\n\t\treturn -EIO;\n\t}\n\n\t \n\tdev_warn(dev, \"%s can't access extended configuration space under this bridge\\n\",\n\t\t estr);\n\n\treturn 0;\n}\n\nstatic int setup_mcfg_map(struct acpi_pci_root_info *ci)\n{\n\tint result, seg;\n\tstruct pci_root_info *info;\n\tstruct acpi_pci_root *root = ci->root;\n\tstruct device *dev = &ci->bridge->dev;\n\n\tinfo = container_of(ci, struct pci_root_info, common);\n\tinfo->start_bus = (u8)root->secondary.start;\n\tinfo->end_bus = (u8)root->secondary.end;\n\tinfo->mcfg_added = false;\n\tseg = info->sd.domain;\n\n\t \n\tif (raw_pci_ext_ops && raw_pci_ext_ops != &pci_mmcfg)\n\t\treturn 0;\n\n\tif (!(pci_probe & PCI_PROBE_MMCONF))\n\t\treturn check_segment(seg, dev, \"MMCONFIG is disabled,\");\n\n\tresult = pci_mmconfig_insert(dev, seg, info->start_bus, info->end_bus,\n\t\t\t\t     root->mcfg_addr);\n\tif (result == 0) {\n\t\t \n\t\tif (raw_pci_ext_ops == NULL)\n\t\t\traw_pci_ext_ops = &pci_mmcfg;\n\t\tinfo->mcfg_added = true;\n\t} else if (result != -EEXIST)\n\t\treturn check_segment(seg, dev,\n\t\t\t \"fail to add MMCONFIG information,\");\n\n\treturn 0;\n}\n\nstatic void teardown_mcfg_map(struct acpi_pci_root_info *ci)\n{\n\tstruct pci_root_info *info;\n\n\tinfo = container_of(ci, struct pci_root_info, common);\n\tif (info->mcfg_added) {\n\t\tpci_mmconfig_delete(info->sd.domain,\n\t\t\t\t    info->start_bus, info->end_bus);\n\t\tinfo->mcfg_added = false;\n\t}\n}\n#else\nstatic int setup_mcfg_map(struct acpi_pci_root_info *ci)\n{\n\treturn 0;\n}\n\nstatic void teardown_mcfg_map(struct acpi_pci_root_info *ci)\n{\n}\n#endif\n\nstatic int pci_acpi_root_get_node(struct acpi_pci_root *root)\n{\n\tint busnum = root->secondary.start;\n\tstruct acpi_device *device = root->device;\n\tint node = acpi_get_node(device->handle);\n\n\tif (node == NUMA_NO_NODE) {\n\t\tnode = x86_pci_root_bus_node(busnum);\n\t\tif (node != 0 && node != NUMA_NO_NODE)\n\t\t\tdev_info(&device->dev, FW_BUG \"no _PXM; falling back to node %d from hardware (may be inconsistent with ACPI node numbers)\\n\",\n\t\t\t\tnode);\n\t}\n\tif (node != NUMA_NO_NODE && !node_online(node))\n\t\tnode = NUMA_NO_NODE;\n\n\treturn node;\n}\n\nstatic int pci_acpi_root_init_info(struct acpi_pci_root_info *ci)\n{\n\treturn setup_mcfg_map(ci);\n}\n\nstatic void pci_acpi_root_release_info(struct acpi_pci_root_info *ci)\n{\n\tteardown_mcfg_map(ci);\n\tkfree(container_of(ci, struct pci_root_info, common));\n}\n\n \nstatic bool resource_is_pcicfg_ioport(struct resource *res)\n{\n\treturn (res->flags & IORESOURCE_IO) &&\n\t\tres->start == 0xCF8 && res->end == 0xCFF;\n}\n\nstatic int pci_acpi_root_prepare_resources(struct acpi_pci_root_info *ci)\n{\n\tstruct acpi_device *device = ci->bridge;\n\tint busnum = ci->root->secondary.start;\n\tstruct resource_entry *entry, *tmp;\n\tint status;\n\n\tstatus = acpi_pci_probe_root_resources(ci);\n\n\tif (pci_use_crs) {\n\t\tresource_list_for_each_entry_safe(entry, tmp, &ci->resources)\n\t\t\tif (resource_is_pcicfg_ioport(entry->res))\n\t\t\t\tresource_list_destroy_entry(entry);\n\t\treturn status;\n\t}\n\n\tresource_list_for_each_entry_safe(entry, tmp, &ci->resources) {\n\t\tdev_printk(KERN_DEBUG, &device->dev,\n\t\t\t   \"host bridge window %pR (ignored)\\n\", entry->res);\n\t\tresource_list_destroy_entry(entry);\n\t}\n\tx86_pci_root_bus_resources(busnum, &ci->resources);\n\n\treturn 0;\n}\n\nstatic struct acpi_pci_root_ops acpi_pci_root_ops = {\n\t.pci_ops = &pci_root_ops,\n\t.init_info = pci_acpi_root_init_info,\n\t.release_info = pci_acpi_root_release_info,\n\t.prepare_resources = pci_acpi_root_prepare_resources,\n};\n\nstruct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)\n{\n\tint domain = root->segment;\n\tint busnum = root->secondary.start;\n\tint node = pci_acpi_root_get_node(root);\n\tstruct pci_bus *bus;\n\n\tif (pci_ignore_seg)\n\t\troot->segment = domain = 0;\n\n\tif (domain && !pci_domains_supported) {\n\t\tpr_warn(\"pci_bus %04x:%02x: ignored (multiple domains not supported)\\n\",\n\t\t        domain, busnum);\n\t\treturn NULL;\n\t}\n\n\tbus = pci_find_bus(domain, busnum);\n\tif (bus) {\n\t\t \n\t\tstruct pci_sysdata sd = {\n\t\t\t.domain = domain,\n\t\t\t.node = node,\n\t\t\t.companion = root->device\n\t\t};\n\n\t\tmemcpy(bus->sysdata, &sd, sizeof(sd));\n\t} else {\n\t\tstruct pci_root_info *info;\n\n\t\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\t\tif (!info)\n\t\t\tdev_err(&root->device->dev,\n\t\t\t\t\"pci_bus %04x:%02x: ignored (out of memory)\\n\",\n\t\t\t\tdomain, busnum);\n\t\telse {\n\t\t\tinfo->sd.domain = domain;\n\t\t\tinfo->sd.node = node;\n\t\t\tinfo->sd.companion = root->device;\n\t\t\tbus = acpi_pci_root_create(root, &acpi_pci_root_ops,\n\t\t\t\t\t\t   &info->common, &info->sd);\n\t\t}\n\t}\n\n\t \n\tif (bus) {\n\t\tstruct pci_bus *child;\n\t\tlist_for_each_entry(child, &bus->children, node)\n\t\t\tpcie_bus_configure_settings(child);\n\t}\n\n\treturn bus;\n}\n\nint pcibios_root_bridge_prepare(struct pci_host_bridge *bridge)\n{\n\t \n\tif (!bridge->dev.parent) {\n\t\tstruct pci_sysdata *sd = bridge->bus->sysdata;\n\t\tACPI_COMPANION_SET(&bridge->dev, sd->companion);\n\t}\n\treturn 0;\n}\n\nint __init pci_acpi_init(void)\n{\n\tstruct pci_dev *dev = NULL;\n\n\tif (acpi_noirq)\n\t\treturn -ENODEV;\n\n\tpr_info(\"Using ACPI for IRQ routing\\n\");\n\tacpi_irq_penalty_init();\n\tpcibios_enable_irq = acpi_pci_irq_enable;\n\tpcibios_disable_irq = acpi_pci_irq_disable;\n\tx86_init.pci.init_irq = x86_init_noop;\n\n\tif (pci_routeirq) {\n\t\t \n\t\tpr_info(\"Routing PCI interrupts for all devices because \\\"pci=routeirq\\\" specified\\n\");\n\t\tfor_each_pci_dev(dev)\n\t\t\tacpi_pci_irq_enable(dev);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}