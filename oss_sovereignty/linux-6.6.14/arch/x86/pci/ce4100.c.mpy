{
  "module_name": "ce4100.c",
  "hash_id": "21688069bbb36c00ac5ef870ac62573b1173fa19ece2a9818786428321cef66f",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/pci/ce4100.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n\n#include <asm/ce4100.h>\n#include <asm/pci_x86.h>\n\nstruct sim_reg {\n\tu32 value;\n\tu32 mask;\n};\n\nstruct sim_dev_reg {\n\tint dev_func;\n\tint reg;\n\tvoid (*init)(struct sim_dev_reg *reg);\n\tvoid (*read)(struct sim_dev_reg *reg, u32 *value);\n\tvoid (*write)(struct sim_dev_reg *reg, u32 value);\n\tstruct sim_reg sim_reg;\n};\n\nstruct sim_reg_op {\n\tvoid (*init)(struct sim_dev_reg *reg);\n\tvoid (*read)(struct sim_dev_reg *reg, u32 value);\n\tvoid (*write)(struct sim_dev_reg *reg, u32 value);\n};\n\n#define MB (1024 * 1024)\n#define KB (1024)\n#define SIZE_TO_MASK(size) (~(size - 1))\n\n#define DEFINE_REG(device, func, offset, size, init_op, read_op, write_op)\\\n{ PCI_DEVFN(device, func), offset, init_op, read_op, write_op,\\\n\t{0, SIZE_TO_MASK(size)} },\n\n \nstatic void reg_init(struct sim_dev_reg *reg)\n{\n\tpci_direct_conf1.read(0, 1, reg->dev_func, reg->reg, 4,\n\t\t\t      &reg->sim_reg.value);\n}\n\nstatic void reg_read(struct sim_dev_reg *reg, u32 *value)\n{\n\t*value = reg->sim_reg.value;\n}\n\nstatic void reg_write(struct sim_dev_reg *reg, u32 value)\n{\n\treg->sim_reg.value = (value & reg->sim_reg.mask) |\n\t\t(reg->sim_reg.value & ~reg->sim_reg.mask);\n}\n\nstatic void sata_reg_init(struct sim_dev_reg *reg)\n{\n\tpci_direct_conf1.read(0, 1, PCI_DEVFN(14, 0), 0x10, 4,\n\t\t\t      &reg->sim_reg.value);\n\treg->sim_reg.value += 0x400;\n}\n\nstatic void ehci_reg_read(struct sim_dev_reg *reg, u32 *value)\n{\n\treg_read(reg, value);\n\tif (*value != reg->sim_reg.mask)\n\t\t*value |= 0x100;\n}\n\nstatic void sata_revid_init(struct sim_dev_reg *reg)\n{\n\treg->sim_reg.value = 0x01060100;\n\treg->sim_reg.mask = 0;\n}\n\nstatic void sata_revid_read(struct sim_dev_reg *reg, u32 *value)\n{\n\treg_read(reg, value);\n}\n\nstatic void reg_noirq_read(struct sim_dev_reg *reg, u32 *value)\n{\n\t \n\t*value = reg->sim_reg.value & 0xfff00ff;\n}\n\nstatic struct sim_dev_reg bus1_fixups[] = {\n\tDEFINE_REG(2, 0, 0x10, (16*MB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(2, 0, 0x14, (256), reg_init, reg_read, reg_write)\n\tDEFINE_REG(2, 1, 0x10, (64*KB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(3, 0, 0x10, (64*KB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(4, 0, 0x10, (128*KB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(4, 1, 0x10, (128*KB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(6, 0, 0x10, (512*KB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(6, 1, 0x10, (512*KB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(6, 2, 0x10, (64*KB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(8, 0, 0x10, (1*MB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(8, 1, 0x10, (64*KB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(8, 2, 0x10, (64*KB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(9, 0, 0x10 , (1*MB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(9, 0, 0x14, (64*KB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(10, 0, 0x10, (256), reg_init, reg_read, reg_write)\n\tDEFINE_REG(10, 0, 0x14, (256*MB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(11, 0, 0x10, (256), reg_init, reg_read, reg_write)\n\tDEFINE_REG(11, 0, 0x14, (256), reg_init, reg_read, reg_write)\n\tDEFINE_REG(11, 1, 0x10, (256), reg_init, reg_read, reg_write)\n\tDEFINE_REG(11, 2, 0x10, (256), reg_init, reg_read, reg_write)\n\tDEFINE_REG(11, 2, 0x14, (256), reg_init, reg_read, reg_write)\n\tDEFINE_REG(11, 2, 0x18, (256), reg_init, reg_read, reg_write)\n\tDEFINE_REG(11, 3, 0x10, (256), reg_init, reg_read, reg_write)\n\tDEFINE_REG(11, 3, 0x14, (256), reg_init, reg_read, reg_write)\n\tDEFINE_REG(11, 4, 0x10, (256), reg_init, reg_read, reg_write)\n\tDEFINE_REG(11, 5, 0x10, (64*KB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(11, 6, 0x10, (256), reg_init, reg_read, reg_write)\n\tDEFINE_REG(11, 7, 0x10, (64*KB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(11, 7, 0x3c, 256, reg_init, reg_noirq_read, reg_write)\n\tDEFINE_REG(12, 0, 0x10, (128*KB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(12, 0, 0x14, (256), reg_init, reg_read, reg_write)\n\tDEFINE_REG(12, 1, 0x10, (1024), reg_init, reg_read, reg_write)\n\tDEFINE_REG(13, 0, 0x10, (32*KB), reg_init, ehci_reg_read, reg_write)\n\tDEFINE_REG(13, 1, 0x10, (32*KB), reg_init, ehci_reg_read, reg_write)\n\tDEFINE_REG(14, 0, 0x8,  0, sata_revid_init, sata_revid_read, 0)\n\tDEFINE_REG(14, 0, 0x10, 0, reg_init, reg_read, reg_write)\n\tDEFINE_REG(14, 0, 0x14, 0, reg_init, reg_read, reg_write)\n\tDEFINE_REG(14, 0, 0x18, 0, reg_init, reg_read, reg_write)\n\tDEFINE_REG(14, 0, 0x1C, 0, reg_init, reg_read, reg_write)\n\tDEFINE_REG(14, 0, 0x20, 0, reg_init, reg_read, reg_write)\n\tDEFINE_REG(14, 0, 0x24, (0x200), sata_reg_init, reg_read, reg_write)\n\tDEFINE_REG(15, 0, 0x10, (64*KB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(15, 0, 0x14, (64*KB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(16, 0, 0x10, (64*KB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(16, 0, 0x14, (64*MB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(16, 0, 0x18, (64*MB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(16, 0, 0x3c, 256, reg_init, reg_noirq_read, reg_write)\n\tDEFINE_REG(17, 0, 0x10, (128*KB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(18, 0, 0x10, (1*KB), reg_init, reg_read, reg_write)\n\tDEFINE_REG(18, 0, 0x3c, 256, reg_init, reg_noirq_read, reg_write)\n};\n\nstatic void __init init_sim_regs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bus1_fixups); i++) {\n\t\tif (bus1_fixups[i].init)\n\t\t\tbus1_fixups[i].init(&bus1_fixups[i]);\n\t}\n}\n\nstatic inline void extract_bytes(u32 *value, int reg, int len)\n{\n\tuint32_t mask;\n\n\t*value >>= ((reg & 3) * 8);\n\tmask = 0xFFFFFFFF >> ((4 - len) * 8);\n\t*value &= mask;\n}\n\nstatic int bridge_read(unsigned int devfn, int reg, int len, u32 *value)\n{\n\tu32 av_bridge_base, av_bridge_limit;\n\tint retval = 0;\n\n\tswitch (reg) {\n\t \n\tcase PCI_BASE_ADDRESS_0:\n\tcase PCI_BASE_ADDRESS_0 + 1:\n\tcase PCI_BASE_ADDRESS_0 + 2:\n\tcase PCI_BASE_ADDRESS_0 + 3:\n\t\t*value = 0;\n\t\tbreak;\n\n\t\t \n\tcase PCI_PRIMARY_BUS:\n\t\tif (len == 4)\n\t\t\t*value = 0x00010100;\n\t\tbreak;\n\n\tcase PCI_SUBORDINATE_BUS:\n\t\t*value = 1;\n\t\tbreak;\n\n\tcase PCI_MEMORY_BASE:\n\tcase PCI_MEMORY_LIMIT:\n\t\t \n\t\tpci_direct_conf1.read(0, 0, devfn,\n\t\t\t\tPCI_BASE_ADDRESS_0, 4, &av_bridge_base);\n\n\t\tav_bridge_limit = av_bridge_base + (512*MB - 1);\n\t\tav_bridge_limit >>= 16;\n\t\tav_bridge_limit &= 0xFFF0;\n\n\t\tav_bridge_base >>= 16;\n\t\tav_bridge_base &= 0xFFF0;\n\n\t\tif (reg == PCI_MEMORY_LIMIT)\n\t\t\t*value = av_bridge_limit;\n\t\telse if (len == 2)\n\t\t\t*value = av_bridge_base;\n\t\telse\n\t\t\t*value = (av_bridge_limit << 16) | av_bridge_base;\n\t\tbreak;\n\t\t \n\tcase PCI_PREF_MEMORY_BASE:\n\t\t*value = 0xFFF0;\n\t\tbreak;\n\tcase PCI_PREF_MEMORY_LIMIT:\n\t\t*value = 0x0;\n\t\tbreak;\n\t\t \n\tcase PCI_IO_BASE:\n\t\t*value = 0xF0;\n\t\tbreak;\n\tcase PCI_IO_LIMIT:\n\t\t*value = 0;\n\t\tbreak;\n\tdefault:\n\t\tretval = 1;\n\t}\n\treturn retval;\n}\n\nstatic int ce4100_bus1_read(unsigned int devfn, int reg, int len, u32 *value)\n{\n\tunsigned long flags;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bus1_fixups); i++) {\n\t\tif (bus1_fixups[i].dev_func == devfn &&\n\t\t    bus1_fixups[i].reg == (reg & ~3) &&\n\t\t    bus1_fixups[i].read) {\n\n\t\t\traw_spin_lock_irqsave(&pci_config_lock, flags);\n\t\t\tbus1_fixups[i].read(&(bus1_fixups[i]), value);\n\t\t\traw_spin_unlock_irqrestore(&pci_config_lock, flags);\n\t\t\textract_bytes(value, reg, len);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic int ce4100_conf_read(unsigned int seg, unsigned int bus,\n\t\t\t    unsigned int devfn, int reg, int len, u32 *value)\n{\n\tWARN_ON(seg);\n\n\tif (bus == 1 && !ce4100_bus1_read(devfn, reg, len, value))\n\t\treturn 0;\n\n\tif (bus == 0 && (PCI_DEVFN(1, 0) == devfn) &&\n\t    !bridge_read(devfn, reg, len, value))\n\t\treturn 0;\n\n\treturn pci_direct_conf1.read(seg, bus, devfn, reg, len, value);\n}\n\nstatic int ce4100_bus1_write(unsigned int devfn, int reg, int len, u32 value)\n{\n\tunsigned long flags;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bus1_fixups); i++) {\n\t\tif (bus1_fixups[i].dev_func == devfn &&\n\t\t    bus1_fixups[i].reg == (reg & ~3) &&\n\t\t    bus1_fixups[i].write) {\n\n\t\t\traw_spin_lock_irqsave(&pci_config_lock, flags);\n\t\t\tbus1_fixups[i].write(&(bus1_fixups[i]), value);\n\t\t\traw_spin_unlock_irqrestore(&pci_config_lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic int ce4100_conf_write(unsigned int seg, unsigned int bus,\n\t\t\t     unsigned int devfn, int reg, int len, u32 value)\n{\n\tWARN_ON(seg);\n\n\tif (bus == 1 && !ce4100_bus1_write(devfn, reg, len, value))\n\t\treturn 0;\n\n\t \n\tif (bus == 0 && PCI_DEVFN(1, 0) == devfn &&\n\t    ((reg & ~3) == PCI_BASE_ADDRESS_0))\n\t\treturn 0;\n\n\treturn pci_direct_conf1.write(seg, bus, devfn, reg, len, value);\n}\n\nstatic const struct pci_raw_ops ce4100_pci_conf = {\n\t.read\t= ce4100_conf_read,\n\t.write\t= ce4100_conf_write,\n};\n\nint __init ce4100_pci_init(void)\n{\n\tinit_sim_regs();\n\traw_pci_ops = &ce4100_pci_conf;\n\t \n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}