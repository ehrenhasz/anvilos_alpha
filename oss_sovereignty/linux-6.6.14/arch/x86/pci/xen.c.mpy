{
  "module_name": "xen.c",
  "hash_id": "f6a45dac365628f9f2248709841313e39661e2a7fd5a7c674754d4bf1ff810c7",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/pci/xen.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/acpi.h>\n\n#include <linux/io.h>\n#include <asm/io_apic.h>\n#include <asm/pci_x86.h>\n\n#include <asm/xen/hypervisor.h>\n\n#include <xen/features.h>\n#include <xen/events.h>\n#include <xen/pci.h>\n#include <asm/xen/pci.h>\n#include <asm/xen/cpuid.h>\n#include <asm/apic.h>\n#include <asm/acpi.h>\n#include <asm/i8259.h>\n\nstatic int xen_pcifront_enable_irq(struct pci_dev *dev)\n{\n\tint rc;\n\tint share = 1;\n\tint pirq;\n\tu8 gsi;\n\n\trc = pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &gsi);\n\tif (rc < 0) {\n\t\tdev_warn(&dev->dev, \"Xen PCI: failed to read interrupt line: %d\\n\",\n\t\t\t rc);\n\t\treturn rc;\n\t}\n\t \n\tpirq = gsi;\n\n\tif (gsi < nr_legacy_irqs())\n\t\tshare = 0;\n\n\trc = xen_bind_pirq_gsi_to_irq(gsi, pirq, share, \"pcifront\");\n\tif (rc < 0) {\n\t\tdev_warn(&dev->dev, \"Xen PCI: failed to bind GSI%d (PIRQ%d) to IRQ: %d\\n\",\n\t\t\t gsi, pirq, rc);\n\t\treturn rc;\n\t}\n\n\tdev->irq = rc;\n\tdev_info(&dev->dev, \"Xen PCI mapped GSI%d to IRQ%d\\n\", gsi, dev->irq);\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\nstatic int xen_register_pirq(u32 gsi, int triggering, bool set_pirq)\n{\n\tint rc, pirq = -1, irq;\n\tstruct physdev_map_pirq map_irq;\n\tint shareable = 0;\n\tchar *name;\n\n\tirq = xen_irq_from_gsi(gsi);\n\tif (irq > 0)\n\t\treturn irq;\n\n\tif (set_pirq)\n\t\tpirq = gsi;\n\n\tmap_irq.domid = DOMID_SELF;\n\tmap_irq.type = MAP_PIRQ_TYPE_GSI;\n\tmap_irq.index = gsi;\n\tmap_irq.pirq = pirq;\n\n\trc = HYPERVISOR_physdev_op(PHYSDEVOP_map_pirq, &map_irq);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"xen map irq failed %d\\n\", rc);\n\t\treturn -1;\n\t}\n\n\tif (triggering == ACPI_EDGE_SENSITIVE) {\n\t\tshareable = 0;\n\t\tname = \"ioapic-edge\";\n\t} else {\n\t\tshareable = 1;\n\t\tname = \"ioapic-level\";\n\t}\n\n\tirq = xen_bind_pirq_gsi_to_irq(gsi, map_irq.pirq, shareable, name);\n\tif (irq < 0)\n\t\tgoto out;\n\n\tprintk(KERN_DEBUG \"xen: --> pirq=%d -> irq=%d (gsi=%d)\\n\", map_irq.pirq, irq, gsi);\nout:\n\treturn irq;\n}\n\nstatic int acpi_register_gsi_xen_hvm(struct device *dev, u32 gsi,\n\t\t\t\t     int trigger, int polarity)\n{\n\tif (!xen_hvm_domain())\n\t\treturn -1;\n\n\treturn xen_register_pirq(gsi, trigger,\n\t\t\t\t false  );\n}\n\n#ifdef CONFIG_XEN_PV_DOM0\nstatic int xen_register_gsi(u32 gsi, int triggering, int polarity)\n{\n\tint rc, irq;\n\tstruct physdev_setup_gsi setup_gsi;\n\n\tif (!xen_pv_domain())\n\t\treturn -1;\n\n\tprintk(KERN_DEBUG \"xen: registering gsi %u triggering %d polarity %d\\n\",\n\t\t\tgsi, triggering, polarity);\n\n\tirq = xen_register_pirq(gsi, triggering, true);\n\n\tsetup_gsi.gsi = gsi;\n\tsetup_gsi.triggering = (triggering == ACPI_EDGE_SENSITIVE ? 0 : 1);\n\tsetup_gsi.polarity = (polarity == ACPI_ACTIVE_HIGH ? 0 : 1);\n\n\trc = HYPERVISOR_physdev_op(PHYSDEVOP_setup_gsi, &setup_gsi);\n\tif (rc == -EEXIST)\n\t\tprintk(KERN_INFO \"Already setup the GSI :%d\\n\", gsi);\n\telse if (rc) {\n\t\tprintk(KERN_ERR \"Failed to setup GSI :%d, err_code:%d\\n\",\n\t\t\t\tgsi, rc);\n\t}\n\n\treturn irq;\n}\n\nstatic int acpi_register_gsi_xen(struct device *dev, u32 gsi,\n\t\t\t\t int trigger, int polarity)\n{\n\treturn xen_register_gsi(gsi, trigger, polarity);\n}\n#endif\n#endif\n\n#if defined(CONFIG_PCI_MSI)\n#include <linux/msi.h>\n\nstruct xen_pci_frontend_ops *xen_pci_frontend;\nEXPORT_SYMBOL_GPL(xen_pci_frontend);\n\nstruct xen_msi_ops {\n\tint (*setup_msi_irqs)(struct pci_dev *dev, int nvec, int type);\n\tvoid (*teardown_msi_irqs)(struct pci_dev *dev);\n};\n\nstatic struct xen_msi_ops xen_msi_ops __ro_after_init;\n\nstatic int xen_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)\n{\n\tint irq, ret, i;\n\tstruct msi_desc *msidesc;\n\tint *v;\n\n\tif (type == PCI_CAP_ID_MSI && nvec > 1)\n\t\treturn 1;\n\n\tv = kcalloc(max(1, nvec), sizeof(int), GFP_KERNEL);\n\tif (!v)\n\t\treturn -ENOMEM;\n\n\tif (type == PCI_CAP_ID_MSIX)\n\t\tret = xen_pci_frontend_enable_msix(dev, v, nvec);\n\telse\n\t\tret = xen_pci_frontend_enable_msi(dev, v);\n\tif (ret)\n\t\tgoto error;\n\ti = 0;\n\tmsi_for_each_desc(msidesc, &dev->dev, MSI_DESC_NOTASSOCIATED) {\n\t\tirq = xen_bind_pirq_msi_to_irq(dev, msidesc, v[i],\n\t\t\t\t\t       (type == PCI_CAP_ID_MSI) ? nvec : 1,\n\t\t\t\t\t       (type == PCI_CAP_ID_MSIX) ?\n\t\t\t\t\t       \"pcifront-msi-x\" :\n\t\t\t\t\t       \"pcifront-msi\",\n\t\t\t\t\t\tDOMID_SELF);\n\t\tif (irq < 0) {\n\t\t\tret = irq;\n\t\t\tgoto free;\n\t\t}\n\t\ti++;\n\t}\n\tkfree(v);\n\treturn msi_device_populate_sysfs(&dev->dev);\n\nerror:\n\tif (ret == -ENOSYS)\n\t\tdev_err(&dev->dev, \"Xen PCI frontend has not registered MSI/MSI-X support!\\n\");\n\telse if (ret)\n\t\tdev_err(&dev->dev, \"Xen PCI frontend error: %d!\\n\", ret);\nfree:\n\tkfree(v);\n\treturn ret;\n}\n\nstatic void xen_msi_compose_msg(struct pci_dev *pdev, unsigned int pirq,\n\t\tstruct msi_msg *msg)\n{\n\t \n\tmemset(msg, 0, sizeof(*msg));\n\tmsg->address_hi = X86_MSI_BASE_ADDRESS_HIGH;\n\tmsg->arch_addr_hi.destid_8_31 = pirq >> 8;\n\tmsg->arch_addr_lo.destid_0_7 = pirq & 0xFF;\n\tmsg->arch_addr_lo.base_address = X86_MSI_BASE_ADDRESS_LOW;\n\tmsg->arch_data.delivery_mode = APIC_DELIVERY_MODE_EXTINT;\n}\n\nstatic int xen_hvm_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)\n{\n\tint irq, pirq;\n\tstruct msi_desc *msidesc;\n\tstruct msi_msg msg;\n\n\tif (type == PCI_CAP_ID_MSI && nvec > 1)\n\t\treturn 1;\n\n\tmsi_for_each_desc(msidesc, &dev->dev, MSI_DESC_NOTASSOCIATED) {\n\t\tpirq = xen_allocate_pirq_msi(dev, msidesc);\n\t\tif (pirq < 0) {\n\t\t\tirq = -ENODEV;\n\t\t\tgoto error;\n\t\t}\n\t\txen_msi_compose_msg(dev, pirq, &msg);\n\t\t__pci_write_msi_msg(msidesc, &msg);\n\t\tdev_dbg(&dev->dev, \"xen: msi bound to pirq=%d\\n\", pirq);\n\t\tirq = xen_bind_pirq_msi_to_irq(dev, msidesc, pirq,\n\t\t\t\t\t       (type == PCI_CAP_ID_MSI) ? nvec : 1,\n\t\t\t\t\t       (type == PCI_CAP_ID_MSIX) ?\n\t\t\t\t\t       \"msi-x\" : \"msi\",\n\t\t\t\t\t       DOMID_SELF);\n\t\tif (irq < 0)\n\t\t\tgoto error;\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"xen: msi --> pirq=%d --> irq=%d\\n\", pirq, irq);\n\t}\n\treturn msi_device_populate_sysfs(&dev->dev);\n\nerror:\n\tdev_err(&dev->dev, \"Failed to create MSI%s! ret=%d!\\n\",\n\t\ttype == PCI_CAP_ID_MSI ? \"\" : \"-X\", irq);\n\treturn irq;\n}\n\n#ifdef CONFIG_XEN_PV_DOM0\nstatic bool __read_mostly pci_seg_supported = true;\n\nstatic int xen_initdom_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)\n{\n\tint ret = 0;\n\tstruct msi_desc *msidesc;\n\n\tmsi_for_each_desc(msidesc, &dev->dev, MSI_DESC_NOTASSOCIATED) {\n\t\tstruct physdev_map_pirq map_irq;\n\t\tdomid_t domid;\n\n\t\tdomid = ret = xen_find_device_domain_owner(dev);\n\t\t \n\t\tif (ret < 0)\n\t\t\tdomid = DOMID_SELF;\n\n\t\tmemset(&map_irq, 0, sizeof(map_irq));\n\t\tmap_irq.domid = domid;\n\t\tmap_irq.type = MAP_PIRQ_TYPE_MSI_SEG;\n\t\tmap_irq.index = -1;\n\t\tmap_irq.pirq = -1;\n\t\tmap_irq.bus = dev->bus->number |\n\t\t\t      (pci_domain_nr(dev->bus) << 16);\n\t\tmap_irq.devfn = dev->devfn;\n\n\t\tif (type == PCI_CAP_ID_MSI && nvec > 1) {\n\t\t\tmap_irq.type = MAP_PIRQ_TYPE_MULTI_MSI;\n\t\t\tmap_irq.entry_nr = nvec;\n\t\t} else if (type == PCI_CAP_ID_MSIX) {\n\t\t\tint pos;\n\t\t\tunsigned long flags;\n\t\t\tu32 table_offset, bir;\n\n\t\t\tpos = dev->msix_cap;\n\t\t\tpci_read_config_dword(dev, pos + PCI_MSIX_TABLE,\n\t\t\t\t\t      &table_offset);\n\t\t\tbir = (u8)(table_offset & PCI_MSIX_TABLE_BIR);\n\t\t\tflags = pci_resource_flags(dev, bir);\n\t\t\tif (!flags || (flags & IORESOURCE_UNSET))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmap_irq.table_base = pci_resource_start(dev, bir);\n\t\t\tmap_irq.entry_nr = msidesc->msi_index;\n\t\t}\n\n\t\tret = -EINVAL;\n\t\tif (pci_seg_supported)\n\t\t\tret = HYPERVISOR_physdev_op(PHYSDEVOP_map_pirq,\n\t\t\t\t\t\t    &map_irq);\n\t\tif (type == PCI_CAP_ID_MSI && nvec > 1 && ret) {\n\t\t\t \n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret == -EINVAL && !pci_domain_nr(dev->bus)) {\n\t\t\tmap_irq.type = MAP_PIRQ_TYPE_MSI;\n\t\t\tmap_irq.index = -1;\n\t\t\tmap_irq.pirq = -1;\n\t\t\tmap_irq.bus = dev->bus->number;\n\t\t\tret = HYPERVISOR_physdev_op(PHYSDEVOP_map_pirq,\n\t\t\t\t\t\t    &map_irq);\n\t\t\tif (ret != -EINVAL)\n\t\t\t\tpci_seg_supported = false;\n\t\t}\n\t\tif (ret) {\n\t\t\tdev_warn(&dev->dev, \"xen map irq failed %d for %d domain\\n\",\n\t\t\t\t ret, domid);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = xen_bind_pirq_msi_to_irq(dev, msidesc, map_irq.pirq,\n\t\t                               (type == PCI_CAP_ID_MSI) ? nvec : 1,\n\t\t                               (type == PCI_CAP_ID_MSIX) ? \"msi-x\" : \"msi\",\n\t\t                               domid);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = msi_device_populate_sysfs(&dev->dev);\nout:\n\treturn ret;\n}\n\nbool xen_initdom_restore_msi(struct pci_dev *dev)\n{\n\tint ret = 0;\n\n\tif (!xen_initial_domain())\n\t\treturn true;\n\n\tif (pci_seg_supported) {\n\t\tstruct physdev_pci_device restore_ext;\n\n\t\trestore_ext.seg = pci_domain_nr(dev->bus);\n\t\trestore_ext.bus = dev->bus->number;\n\t\trestore_ext.devfn = dev->devfn;\n\t\tret = HYPERVISOR_physdev_op(PHYSDEVOP_restore_msi_ext,\n\t\t\t\t\t&restore_ext);\n\t\tif (ret == -ENOSYS)\n\t\t\tpci_seg_supported = false;\n\t\tWARN(ret && ret != -ENOSYS, \"restore_msi_ext -> %d\\n\", ret);\n\t}\n\tif (!pci_seg_supported) {\n\t\tstruct physdev_restore_msi restore;\n\n\t\trestore.bus = dev->bus->number;\n\t\trestore.devfn = dev->devfn;\n\t\tret = HYPERVISOR_physdev_op(PHYSDEVOP_restore_msi, &restore);\n\t\tWARN(ret && ret != -ENOSYS, \"restore_msi -> %d\\n\", ret);\n\t}\n\treturn false;\n}\n#else  \n#define xen_initdom_setup_msi_irqs\tNULL\n#endif  \n\nstatic void xen_teardown_msi_irqs(struct pci_dev *dev)\n{\n\tstruct msi_desc *msidesc;\n\tint i;\n\n\tmsi_for_each_desc(msidesc, &dev->dev, MSI_DESC_ASSOCIATED) {\n\t\tfor (i = 0; i < msidesc->nvec_used; i++)\n\t\t\txen_destroy_irq(msidesc->irq + i);\n\t\tmsidesc->irq = 0;\n\t}\n\n\tmsi_device_destroy_sysfs(&dev->dev);\n}\n\nstatic void xen_pv_teardown_msi_irqs(struct pci_dev *dev)\n{\n\tif (dev->msix_enabled)\n\t\txen_pci_frontend_disable_msix(dev);\n\telse\n\t\txen_pci_frontend_disable_msi(dev);\n\n\txen_teardown_msi_irqs(dev);\n}\n\nstatic int xen_msi_domain_alloc_irqs(struct irq_domain *domain,\n\t\t\t\t     struct device *dev,  int nvec)\n{\n\tint type;\n\n\tif (WARN_ON_ONCE(!dev_is_pci(dev)))\n\t\treturn -EINVAL;\n\n\ttype = to_pci_dev(dev)->msix_enabled ? PCI_CAP_ID_MSIX : PCI_CAP_ID_MSI;\n\n\treturn xen_msi_ops.setup_msi_irqs(to_pci_dev(dev), nvec, type);\n}\n\nstatic void xen_msi_domain_free_irqs(struct irq_domain *domain,\n\t\t\t\t     struct device *dev)\n{\n\tif (WARN_ON_ONCE(!dev_is_pci(dev)))\n\t\treturn;\n\n\txen_msi_ops.teardown_msi_irqs(to_pci_dev(dev));\n}\n\nstatic struct msi_domain_ops xen_pci_msi_domain_ops = {\n\t.domain_alloc_irqs\t= xen_msi_domain_alloc_irqs,\n\t.domain_free_irqs\t= xen_msi_domain_free_irqs,\n};\n\nstatic struct msi_domain_info xen_pci_msi_domain_info = {\n\t.flags\t\t\t= MSI_FLAG_PCI_MSIX | MSI_FLAG_FREE_MSI_DESCS | MSI_FLAG_DEV_SYSFS,\n\t.ops\t\t\t= &xen_pci_msi_domain_ops,\n};\n\n \nstatic __init struct irq_domain *xen_create_pci_msi_domain(void)\n{\n\tstruct irq_domain *d = NULL;\n\tstruct fwnode_handle *fn;\n\n\tfn = irq_domain_alloc_named_fwnode(\"XEN-MSI\");\n\tif (fn)\n\t\td = msi_create_irq_domain(fn, &xen_pci_msi_domain_info, NULL);\n\n\t \n\tBUG_ON(!d);\n\n\treturn d;\n}\n\nstatic __init void xen_setup_pci_msi(void)\n{\n\tif (xen_pv_domain()) {\n\t\tif (xen_initial_domain())\n\t\t\txen_msi_ops.setup_msi_irqs = xen_initdom_setup_msi_irqs;\n\t\telse\n\t\t\txen_msi_ops.setup_msi_irqs = xen_setup_msi_irqs;\n\t\txen_msi_ops.teardown_msi_irqs = xen_pv_teardown_msi_irqs;\n\t} else if (xen_hvm_domain()) {\n\t\txen_msi_ops.setup_msi_irqs = xen_hvm_setup_msi_irqs;\n\t\txen_msi_ops.teardown_msi_irqs = xen_teardown_msi_irqs;\n\t} else {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\t \n\tx86_init.irqs.create_pci_msi_domain = xen_create_pci_msi_domain;\n\t \n\tpci_msi_ignore_mask = 1;\n}\n\n#else  \nstatic inline void xen_setup_pci_msi(void) { }\n#endif  \n\nint __init pci_xen_init(void)\n{\n\tif (!xen_pv_domain() || xen_initial_domain())\n\t\treturn -ENODEV;\n\n\tprintk(KERN_INFO \"PCI: setting up Xen PCI frontend stub\\n\");\n\n\tpcibios_set_cache_line_size();\n\n\tpcibios_enable_irq = xen_pcifront_enable_irq;\n\tpcibios_disable_irq = NULL;\n\n\t \n\tacpi_noirq_set();\n\n\txen_setup_pci_msi();\n\treturn 0;\n}\n\n#ifdef CONFIG_PCI_MSI\nstatic void __init xen_hvm_msi_init(void)\n{\n\tif (!apic_is_disabled) {\n\t\t \n\t\tuint32_t eax = cpuid_eax(xen_cpuid_base() + 4);\n\n\t\tif (((eax & XEN_HVM_CPUID_X2APIC_VIRT) && x2apic_mode) ||\n\t\t    ((eax & XEN_HVM_CPUID_APIC_ACCESS_VIRT) && boot_cpu_has(X86_FEATURE_APIC)))\n\t\t\treturn;\n\t}\n\txen_setup_pci_msi();\n}\n#endif\n\nint __init pci_xen_hvm_init(void)\n{\n\tif (!xen_have_vector_callback || !xen_feature(XENFEAT_hvm_pirqs))\n\t\treturn 0;\n\n#ifdef CONFIG_ACPI\n\t \n\t__acpi_register_gsi = acpi_register_gsi_xen_hvm;\n\t__acpi_unregister_gsi = NULL;\n#endif\n\n#ifdef CONFIG_PCI_MSI\n\t \n\tx86_platform.apic_post_init = xen_hvm_msi_init;\n#endif\n\treturn 0;\n}\n\n#ifdef CONFIG_XEN_PV_DOM0\nint __init pci_xen_initial_domain(void)\n{\n\tint irq;\n\n\txen_setup_pci_msi();\n\t__acpi_register_gsi = acpi_register_gsi_xen;\n\t__acpi_unregister_gsi = NULL;\n\t \n\tfor (irq = 0; irq < NR_IRQS_LEGACY; irq++) {\n\t\tint trigger, polarity;\n\n\t\tif (acpi_get_override_irq(irq, &trigger, &polarity) == -1)\n\t\t\tcontinue;\n\n\t\txen_register_pirq(irq,\n\t\t\ttrigger ? ACPI_LEVEL_SENSITIVE : ACPI_EDGE_SENSITIVE,\n\t\t\ttrue  );\n\t}\n\tif (0 == nr_ioapics) {\n\t\tfor (irq = 0; irq < nr_legacy_irqs(); irq++)\n\t\t\txen_bind_pirq_gsi_to_irq(irq, irq, 0, \"xt-pic\");\n\t}\n\treturn 0;\n}\n#endif\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}