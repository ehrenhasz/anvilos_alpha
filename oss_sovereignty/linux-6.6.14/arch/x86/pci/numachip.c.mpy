{
  "module_name": "numachip.c",
  "hash_id": "3eb4f1282288f7250a2405f4c26e4163611cddc203740c461904c58711233cdc",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/pci/numachip.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <asm/pci_x86.h>\n#include <asm/numachip/numachip.h>\n\nstatic u8 limit __read_mostly;\n\nstatic inline char __iomem *pci_dev_base(unsigned int seg, unsigned int bus, unsigned int devfn)\n{\n\tstruct pci_mmcfg_region *cfg = pci_mmconfig_lookup(seg, bus);\n\n\tif (cfg && cfg->virt)\n\t\treturn cfg->virt + (PCI_MMCFG_BUS_OFFSET(bus) | (devfn << 12));\n\treturn NULL;\n}\n\nstatic int pci_mmcfg_read_numachip(unsigned int seg, unsigned int bus,\n\t\t\t  unsigned int devfn, int reg, int len, u32 *value)\n{\n\tchar __iomem *addr;\n\n\t \n\tif (unlikely((bus > 255) || (devfn > 255) || (reg > 4095))) {\nerr:\t\t*value = -1;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (unlikely(bus == 0 && devfn >= limit)) {\n\t\t*value = -1;\n\t\treturn 0;\n\t}\n\n\trcu_read_lock();\n\taddr = pci_dev_base(seg, bus, devfn);\n\tif (!addr) {\n\t\trcu_read_unlock();\n\t\tgoto err;\n\t}\n\n\tswitch (len) {\n\tcase 1:\n\t\t*value = mmio_config_readb(addr + reg);\n\t\tbreak;\n\tcase 2:\n\t\t*value = mmio_config_readw(addr + reg);\n\t\tbreak;\n\tcase 4:\n\t\t*value = mmio_config_readl(addr + reg);\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic int pci_mmcfg_write_numachip(unsigned int seg, unsigned int bus,\n\t\t\t   unsigned int devfn, int reg, int len, u32 value)\n{\n\tchar __iomem *addr;\n\n\t \n\tif (unlikely((bus > 255) || (devfn > 255) || (reg > 4095)))\n\t\treturn -EINVAL;\n\n\t \n\tif (unlikely(bus == 0 && devfn >= limit))\n\t\treturn 0;\n\n\trcu_read_lock();\n\taddr = pci_dev_base(seg, bus, devfn);\n\tif (!addr) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (len) {\n\tcase 1:\n\t\tmmio_config_writeb(addr + reg, value);\n\t\tbreak;\n\tcase 2:\n\t\tmmio_config_writew(addr + reg, value);\n\t\tbreak;\n\tcase 4:\n\t\tmmio_config_writel(addr + reg, value);\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic const struct pci_raw_ops pci_mmcfg_numachip = {\n\t.read = pci_mmcfg_read_numachip,\n\t.write = pci_mmcfg_write_numachip,\n};\n\nint __init pci_numachip_init(void)\n{\n\tint ret = 0;\n\tu32 val;\n\n\t \n\tret = raw_pci_read(0, 0, PCI_DEVFN(0x18, 0), 0x60, sizeof(val), &val);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tlimit = PCI_DEVFN(0x18 + ((val >> 4) & 7) + 1, 0);\n\n\t \n\traw_pci_ops = raw_pci_ext_ops = &pci_mmcfg_numachip;\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}