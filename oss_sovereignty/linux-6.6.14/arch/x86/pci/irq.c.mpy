{
  "module_name": "irq.c",
  "hash_id": "00b0029f875227874fb304e5a35b15403e9b696a513ac89ab1806766bcb76189",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/pci/irq.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/dmi.h>\n#include <linux/io.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <asm/io_apic.h>\n#include <linux/irq.h>\n#include <linux/acpi.h>\n\n#include <asm/i8259.h>\n#include <asm/pc-conf-reg.h>\n#include <asm/pci_x86.h>\n\n#define PIRQ_SIGNATURE\t(('$' << 0) + ('P' << 8) + ('I' << 16) + ('R' << 24))\n#define PIRQ_VERSION 0x0100\n\n#define IRT_SIGNATURE\t(('$' << 0) + ('I' << 8) + ('R' << 16) + ('T' << 24))\n\nstatic int broken_hp_bios_irq9;\nstatic int acer_tm360_irqrouting;\n\nstatic struct irq_routing_table *pirq_table;\n\nstatic int pirq_enable_irq(struct pci_dev *dev);\nstatic void pirq_disable_irq(struct pci_dev *dev);\n\n \nunsigned int pcibios_irq_mask = 0xfff8;\n\nstatic int pirq_penalty[16] = {\n\t1000000, 1000000, 1000000, 1000, 1000, 0, 1000, 1000,\n\t0, 0, 0, 0, 1000, 100000, 100000, 100000\n};\n\nstruct irq_router {\n\tchar *name;\n\tu16 vendor, device;\n\tint (*get)(struct pci_dev *router, struct pci_dev *dev, int pirq);\n\tint (*set)(struct pci_dev *router, struct pci_dev *dev, int pirq,\n\t\tint new);\n\tint (*lvl)(struct pci_dev *router, struct pci_dev *dev, int pirq,\n\t\tint irq);\n};\n\nstruct irq_router_handler {\n\tu16 vendor;\n\tint (*probe)(struct irq_router *r, struct pci_dev *router, u16 device);\n};\n\nint (*pcibios_enable_irq)(struct pci_dev *dev) = pirq_enable_irq;\nvoid (*pcibios_disable_irq)(struct pci_dev *dev) = pirq_disable_irq;\n\n \n\nstatic inline struct irq_routing_table *pirq_check_routing_table(u8 *addr,\n\t\t\t\t\t\t\t\t u8 *limit)\n{\n\tstruct irq_routing_table *rt;\n\tint i;\n\tu8 sum;\n\n\trt = (struct irq_routing_table *)addr;\n\tif (rt->signature != PIRQ_SIGNATURE ||\n\t    rt->version != PIRQ_VERSION ||\n\t    rt->size % 16 ||\n\t    rt->size < sizeof(struct irq_routing_table) ||\n\t    (limit && rt->size > limit - addr))\n\t\treturn NULL;\n\tsum = 0;\n\tfor (i = 0; i < rt->size; i++)\n\t\tsum += addr[i];\n\tif (!sum) {\n\t\tDBG(KERN_DEBUG \"PCI: Interrupt Routing Table found at 0x%lx\\n\",\n\t\t    __pa(rt));\n\t\treturn rt;\n\t}\n\treturn NULL;\n}\n\n \nstatic inline struct irq_routing_table *pirq_convert_irt_table(u8 *addr,\n\t\t\t\t\t\t\t       u8 *limit)\n{\n\tstruct irt_routing_table *ir;\n\tstruct irq_routing_table *rt;\n\tu16 size;\n\tu8 sum;\n\tint i;\n\n\tir = (struct irt_routing_table *)addr;\n\tif (ir->signature != IRT_SIGNATURE || !ir->used || ir->size < ir->used)\n\t\treturn NULL;\n\n\tsize = struct_size(ir, slots, ir->used);\n\tif (size > limit - addr)\n\t\treturn NULL;\n\n\tDBG(KERN_DEBUG \"PCI: $IRT Interrupt Routing Table found at 0x%lx\\n\",\n\t    __pa(ir));\n\n\tsize = struct_size(rt, slots, ir->used);\n\trt = kzalloc(size, GFP_KERNEL);\n\tif (!rt)\n\t\treturn NULL;\n\n\trt->signature = PIRQ_SIGNATURE;\n\trt->version = PIRQ_VERSION;\n\trt->size = size;\n\trt->exclusive_irqs = ir->exclusive_irqs;\n\tfor (i = 0; i < ir->used; i++)\n\t\trt->slots[i] = ir->slots[i];\n\n\taddr = (u8 *)rt;\n\tsum = 0;\n\tfor (i = 0; i < size; i++)\n\t\tsum += addr[i];\n\trt->checksum = -sum;\n\n\treturn rt;\n}\n\n \n\nstatic struct irq_routing_table * __init pirq_find_routing_table(void)\n{\n\tu8 * const bios_start = (u8 *)__va(0xf0000);\n\tu8 * const bios_end = (u8 *)__va(0x100000);\n\tu8 *addr;\n\tstruct irq_routing_table *rt;\n\n\tif (pirq_table_addr) {\n\t\trt = pirq_check_routing_table((u8 *)__va(pirq_table_addr),\n\t\t\t\t\t      NULL);\n\t\tif (rt)\n\t\t\treturn rt;\n\t\tprintk(KERN_WARNING \"PCI: PIRQ table NOT found at pirqaddr\\n\");\n\t}\n\tfor (addr = bios_start;\n\t     addr < bios_end - sizeof(struct irq_routing_table);\n\t     addr += 16) {\n\t\trt = pirq_check_routing_table(addr, bios_end);\n\t\tif (rt)\n\t\t\treturn rt;\n\t}\n\tfor (addr = bios_start;\n\t     addr < bios_end - sizeof(struct irt_routing_table);\n\t     addr++) {\n\t\trt = pirq_convert_irt_table(addr, bios_end);\n\t\tif (rt)\n\t\t\treturn rt;\n\t}\n\treturn NULL;\n}\n\n \n\nstatic void __init pirq_peer_trick(void)\n{\n\tstruct irq_routing_table *rt = pirq_table;\n\tu8 busmap[256];\n\tint i;\n\tstruct irq_info *e;\n\n\tmemset(busmap, 0, sizeof(busmap));\n\tfor (i = 0; i < (rt->size - sizeof(struct irq_routing_table)) / sizeof(struct irq_info); i++) {\n\t\te = &rt->slots[i];\n#ifdef DEBUG\n\t\t{\n\t\t\tint j;\n\t\t\tDBG(KERN_DEBUG \"%02x:%02x.%x slot=%02x\",\n\t\t\t    e->bus, e->devfn / 8, e->devfn % 8, e->slot);\n\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\tDBG(\" %d:%02x/%04x\", j, e->irq[j].link, e->irq[j].bitmap);\n\t\t\tDBG(\"\\n\");\n\t\t}\n#endif\n\t\tbusmap[e->bus] = 1;\n\t}\n\tfor (i = 1; i < 256; i++) {\n\t\tif (!busmap[i] || pci_find_bus(0, i))\n\t\t\tcontinue;\n\t\tpcibios_scan_root(i);\n\t}\n\tpcibios_last_bus = -1;\n}\n\n \n\nvoid elcr_set_level_irq(unsigned int irq)\n{\n\tunsigned char mask = 1 << (irq & 7);\n\tunsigned int port = PIC_ELCR1 + (irq >> 3);\n\tunsigned char val;\n\tstatic u16 elcr_irq_mask;\n\n\tif (irq >= 16 || (1 << irq) & elcr_irq_mask)\n\t\treturn;\n\n\telcr_irq_mask |= (1 << irq);\n\tprintk(KERN_DEBUG \"PCI: setting IRQ %u as level-triggered\\n\", irq);\n\tval = inb(port);\n\tif (!(val & mask)) {\n\t\tDBG(KERN_DEBUG \" -> edge\");\n\t\toutb(val | mask, port);\n\t}\n}\n\n \n\n#define PC_CONF_FINALI_LOCK\t\t0x03u\n#define PC_CONF_FINALI_PCI_INTX_RT1\t0x42u\n#define PC_CONF_FINALI_PCI_INTX_RT2\t0x43u\n#define PC_CONF_FINALI_PCI_INTX_SENS\t0x44u\n\n#define PC_CONF_FINALI_LOCK_KEY\t\t0xc5u\n\nstatic u8 read_pc_conf_nybble(u8 base, u8 index)\n{\n\tu8 reg = base + (index >> 1);\n\tu8 x;\n\n\tx = pc_conf_get(reg);\n\treturn index & 1 ? x >> 4 : x & 0xf;\n}\n\nstatic void write_pc_conf_nybble(u8 base, u8 index, u8 val)\n{\n\tu8 reg = base + (index >> 1);\n\tu8 x;\n\n\tx = pc_conf_get(reg);\n\tx = index & 1 ? (x & 0x0f) | (val << 4) : (x & 0xf0) | val;\n\tpc_conf_set(reg, x);\n}\n\n \nstatic int pirq_finali_get(struct pci_dev *router, struct pci_dev *dev,\n\t\t\t   int pirq)\n{\n\tstatic const u8 irqmap[16] = {\n\t\t0, 9, 3, 10, 4, 5, 7, 6, 0, 11, 0, 12, 0, 14, 0, 15\n\t};\n\tunsigned long flags;\n\tu8 index;\n\tu8 x;\n\n\tindex = (pirq & 1) << 1 | (pirq & 8) >> 3;\n\traw_spin_lock_irqsave(&pc_conf_lock, flags);\n\tpc_conf_set(PC_CONF_FINALI_LOCK, PC_CONF_FINALI_LOCK_KEY);\n\tx = irqmap[read_pc_conf_nybble(PC_CONF_FINALI_PCI_INTX_RT1, index)];\n\tpc_conf_set(PC_CONF_FINALI_LOCK, 0);\n\traw_spin_unlock_irqrestore(&pc_conf_lock, flags);\n\treturn x;\n}\n\nstatic int pirq_finali_set(struct pci_dev *router, struct pci_dev *dev,\n\t\t\t   int pirq, int irq)\n{\n\tstatic const u8 irqmap[16] = {\n\t\t0, 0, 0, 2, 4, 5, 7, 6, 0, 1, 3, 9, 11, 0, 13, 15\n\t};\n\tu8 val = irqmap[irq];\n\tunsigned long flags;\n\tu8 index;\n\n\tif (!val)\n\t\treturn 0;\n\n\tindex = (pirq & 1) << 1 | (pirq & 8) >> 3;\n\traw_spin_lock_irqsave(&pc_conf_lock, flags);\n\tpc_conf_set(PC_CONF_FINALI_LOCK, PC_CONF_FINALI_LOCK_KEY);\n\twrite_pc_conf_nybble(PC_CONF_FINALI_PCI_INTX_RT1, index, val);\n\tpc_conf_set(PC_CONF_FINALI_LOCK, 0);\n\traw_spin_unlock_irqrestore(&pc_conf_lock, flags);\n\treturn 1;\n}\n\nstatic int pirq_finali_lvl(struct pci_dev *router, struct pci_dev *dev,\n\t\t\t   int pirq, int irq)\n{\n\tu8 mask = ~((pirq & 0xf0u) >> 4);\n\tunsigned long flags;\n\tu8 trig;\n\n\telcr_set_level_irq(irq);\n\traw_spin_lock_irqsave(&pc_conf_lock, flags);\n\tpc_conf_set(PC_CONF_FINALI_LOCK, PC_CONF_FINALI_LOCK_KEY);\n\ttrig = pc_conf_get(PC_CONF_FINALI_PCI_INTX_SENS);\n\ttrig &= mask;\n\tpc_conf_set(PC_CONF_FINALI_PCI_INTX_SENS, trig);\n\tpc_conf_set(PC_CONF_FINALI_LOCK, 0);\n\traw_spin_unlock_irqrestore(&pc_conf_lock, flags);\n\treturn 1;\n}\n\n \nstatic unsigned int read_config_nybble(struct pci_dev *router, unsigned offset, unsigned nr)\n{\n\tu8 x;\n\tunsigned reg = offset + (nr >> 1);\n\n\tpci_read_config_byte(router, reg, &x);\n\treturn (nr & 1) ? (x >> 4) : (x & 0xf);\n}\n\nstatic void write_config_nybble(struct pci_dev *router, unsigned offset,\n\tunsigned nr, unsigned int val)\n{\n\tu8 x;\n\tunsigned reg = offset + (nr >> 1);\n\n\tpci_read_config_byte(router, reg, &x);\n\tx = (nr & 1) ? ((x & 0x0f) | (val << 4)) : ((x & 0xf0) | val);\n\tpci_write_config_byte(router, reg, x);\n}\n\n \nstatic int pirq_ali_get(struct pci_dev *router, struct pci_dev *dev, int pirq)\n{\n\tstatic const unsigned char irqmap[16] = { 0, 9, 3, 10, 4, 5, 7, 6, 1, 11, 0, 12, 0, 14, 0, 15 };\n\n\tWARN_ON_ONCE(pirq > 16);\n\treturn irqmap[read_config_nybble(router, 0x48, pirq-1)];\n}\n\nstatic int pirq_ali_set(struct pci_dev *router, struct pci_dev *dev, int pirq, int irq)\n{\n\tstatic const unsigned char irqmap[16] = { 0, 8, 0, 2, 4, 5, 7, 6, 0, 1, 3, 9, 11, 0, 13, 15 };\n\tunsigned int val = irqmap[irq];\n\n\tWARN_ON_ONCE(pirq > 16);\n\tif (val) {\n\t\twrite_config_nybble(router, 0x48, pirq-1, val);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \n\n#define PC_CONF_I82374_ESC_ID\t\t\t0x02u\n#define PC_CONF_I82374_PIRQ_ROUTE_CONTROL\t0x60u\n\n#define PC_CONF_I82374_ESC_ID_KEY\t\t0x0fu\n\nstatic int pirq_esc_get(struct pci_dev *router, struct pci_dev *dev, int pirq)\n{\n\tunsigned long flags;\n\tint reg;\n\tu8 x;\n\n\treg = pirq;\n\tif (reg >= 1 && reg <= 4)\n\t\treg += PC_CONF_I82374_PIRQ_ROUTE_CONTROL - 1;\n\n\traw_spin_lock_irqsave(&pc_conf_lock, flags);\n\tpc_conf_set(PC_CONF_I82374_ESC_ID, PC_CONF_I82374_ESC_ID_KEY);\n\tx = pc_conf_get(reg);\n\tpc_conf_set(PC_CONF_I82374_ESC_ID, 0);\n\traw_spin_unlock_irqrestore(&pc_conf_lock, flags);\n\treturn (x < 16) ? x : 0;\n}\n\nstatic int pirq_esc_set(struct pci_dev *router, struct pci_dev *dev, int pirq,\n\t\t       int irq)\n{\n\tunsigned long flags;\n\tint reg;\n\n\treg = pirq;\n\tif (reg >= 1 && reg <= 4)\n\t\treg += PC_CONF_I82374_PIRQ_ROUTE_CONTROL - 1;\n\n\traw_spin_lock_irqsave(&pc_conf_lock, flags);\n\tpc_conf_set(PC_CONF_I82374_ESC_ID, PC_CONF_I82374_ESC_ID_KEY);\n\tpc_conf_set(reg, irq);\n\tpc_conf_set(PC_CONF_I82374_ESC_ID, 0);\n\traw_spin_unlock_irqrestore(&pc_conf_lock, flags);\n\treturn 1;\n}\n\n \nstatic int pirq_piix_get(struct pci_dev *router, struct pci_dev *dev, int pirq)\n{\n\tu8 x;\n\n\tpci_read_config_byte(router, pirq, &x);\n\treturn (x < 16) ? x : 0;\n}\n\nstatic int pirq_piix_set(struct pci_dev *router, struct pci_dev *dev, int pirq, int irq)\n{\n\tpci_write_config_byte(router, pirq, irq);\n\treturn 1;\n}\n\n \n\n#define PCI_I82426EX_PIRQ_ROUTE_CONTROL\t0x66u\n\nstatic int pirq_ib_get(struct pci_dev *router, struct pci_dev *dev, int pirq)\n{\n\tint reg;\n\tu8 x;\n\n\treg = pirq;\n\tif (reg >= 1 && reg <= 2)\n\t\treg += PCI_I82426EX_PIRQ_ROUTE_CONTROL - 1;\n\n\tpci_read_config_byte(router, reg, &x);\n\treturn (x < 16) ? x : 0;\n}\n\nstatic int pirq_ib_set(struct pci_dev *router, struct pci_dev *dev, int pirq,\n\t\t       int irq)\n{\n\tint reg;\n\n\treg = pirq;\n\tif (reg >= 1 && reg <= 2)\n\t\treg += PCI_I82426EX_PIRQ_ROUTE_CONTROL - 1;\n\n\tpci_write_config_byte(router, reg, irq);\n\treturn 1;\n}\n\n \nstatic int pirq_via_get(struct pci_dev *router, struct pci_dev *dev, int pirq)\n{\n\treturn read_config_nybble(router, 0x55, pirq == 4 ? 5 : pirq);\n}\n\nstatic int pirq_via_set(struct pci_dev *router, struct pci_dev *dev, int pirq, int irq)\n{\n\twrite_config_nybble(router, 0x55, pirq == 4 ? 5 : pirq, irq);\n\treturn 1;\n}\n\n \nstatic int pirq_via586_get(struct pci_dev *router, struct pci_dev *dev, int pirq)\n{\n\tstatic const unsigned int pirqmap[5] = { 3, 2, 5, 1, 1 };\n\n\tWARN_ON_ONCE(pirq > 5);\n\treturn read_config_nybble(router, 0x55, pirqmap[pirq-1]);\n}\n\nstatic int pirq_via586_set(struct pci_dev *router, struct pci_dev *dev, int pirq, int irq)\n{\n\tstatic const unsigned int pirqmap[5] = { 3, 2, 5, 1, 1 };\n\n\tWARN_ON_ONCE(pirq > 5);\n\twrite_config_nybble(router, 0x55, pirqmap[pirq-1], irq);\n\treturn 1;\n}\n\n \nstatic int pirq_ite_get(struct pci_dev *router, struct pci_dev *dev, int pirq)\n{\n\tstatic const unsigned char pirqmap[4] = { 1, 0, 2, 3 };\n\n\tWARN_ON_ONCE(pirq > 4);\n\treturn read_config_nybble(router, 0x43, pirqmap[pirq-1]);\n}\n\nstatic int pirq_ite_set(struct pci_dev *router, struct pci_dev *dev, int pirq, int irq)\n{\n\tstatic const unsigned char pirqmap[4] = { 1, 0, 2, 3 };\n\n\tWARN_ON_ONCE(pirq > 4);\n\twrite_config_nybble(router, 0x43, pirqmap[pirq-1], irq);\n\treturn 1;\n}\n\n \nstatic int pirq_opti_get(struct pci_dev *router, struct pci_dev *dev, int pirq)\n{\n\treturn read_config_nybble(router, 0xb8, pirq >> 4);\n}\n\nstatic int pirq_opti_set(struct pci_dev *router, struct pci_dev *dev, int pirq, int irq)\n{\n\twrite_config_nybble(router, 0xb8, pirq >> 4, irq);\n\treturn 1;\n}\n\n \nstatic int pirq_cyrix_get(struct pci_dev *router, struct pci_dev *dev, int pirq)\n{\n\treturn read_config_nybble(router, 0x5C, (pirq-1)^1);\n}\n\nstatic int pirq_cyrix_set(struct pci_dev *router, struct pci_dev *dev, int pirq, int irq)\n{\n\twrite_config_nybble(router, 0x5C, (pirq-1)^1, irq);\n\treturn 1;\n}\n\n\n \n\n#define PCI_SIS497_INTA_TO_IRQ_LINK\t0xc0u\n\n#define PIRQ_SIS497_IRQ_MASK\t\t0x0fu\n#define PIRQ_SIS497_IRQ_ENABLE\t\t0x80u\n\nstatic int pirq_sis497_get(struct pci_dev *router, struct pci_dev *dev,\n\t\t\t   int pirq)\n{\n\tint reg;\n\tu8 x;\n\n\treg = pirq;\n\tif (reg >= 1 && reg <= 4)\n\t\treg += PCI_SIS497_INTA_TO_IRQ_LINK - 1;\n\n\tpci_read_config_byte(router, reg, &x);\n\treturn (x & PIRQ_SIS497_IRQ_ENABLE) ? (x & PIRQ_SIS497_IRQ_MASK) : 0;\n}\n\nstatic int pirq_sis497_set(struct pci_dev *router, struct pci_dev *dev,\n\t\t\t   int pirq, int irq)\n{\n\tint reg;\n\tu8 x;\n\n\treg = pirq;\n\tif (reg >= 1 && reg <= 4)\n\t\treg += PCI_SIS497_INTA_TO_IRQ_LINK - 1;\n\n\tpci_read_config_byte(router, reg, &x);\n\tx &= ~(PIRQ_SIS497_IRQ_MASK | PIRQ_SIS497_IRQ_ENABLE);\n\tx |= irq ? (PIRQ_SIS497_IRQ_ENABLE | irq) : PIRQ_SIS497_IRQ_MASK;\n\tpci_write_config_byte(router, reg, x);\n\treturn 1;\n}\n\n \n\n#define PIRQ_SIS503_IRQ_MASK\t0x0f\n#define PIRQ_SIS503_IRQ_DISABLE\t0x80\n#define PIRQ_SIS503_USB_ENABLE\t0x40\n\nstatic int pirq_sis503_get(struct pci_dev *router, struct pci_dev *dev,\n\t\t\t   int pirq)\n{\n\tu8 x;\n\tint reg;\n\n\treg = pirq;\n\tif (reg >= 0x01 && reg <= 0x04)\n\t\treg += 0x40;\n\tpci_read_config_byte(router, reg, &x);\n\treturn (x & PIRQ_SIS503_IRQ_DISABLE) ? 0 : (x & PIRQ_SIS503_IRQ_MASK);\n}\n\nstatic int pirq_sis503_set(struct pci_dev *router, struct pci_dev *dev,\n\t\t\t   int pirq, int irq)\n{\n\tu8 x;\n\tint reg;\n\n\treg = pirq;\n\tif (reg >= 0x01 && reg <= 0x04)\n\t\treg += 0x40;\n\tpci_read_config_byte(router, reg, &x);\n\tx &= ~(PIRQ_SIS503_IRQ_MASK | PIRQ_SIS503_IRQ_DISABLE);\n\tx |= irq ? irq : PIRQ_SIS503_IRQ_DISABLE;\n\tpci_write_config_byte(router, reg, x);\n\treturn 1;\n}\n\n\n \n\nstatic int pirq_vlsi_get(struct pci_dev *router, struct pci_dev *dev, int pirq)\n{\n\tWARN_ON_ONCE(pirq >= 9);\n\tif (pirq > 8) {\n\t\tdev_info(&dev->dev, \"VLSI router PIRQ escape (%d)\\n\", pirq);\n\t\treturn 0;\n\t}\n\treturn read_config_nybble(router, 0x74, pirq-1);\n}\n\nstatic int pirq_vlsi_set(struct pci_dev *router, struct pci_dev *dev, int pirq, int irq)\n{\n\tWARN_ON_ONCE(pirq >= 9);\n\tif (pirq > 8) {\n\t\tdev_info(&dev->dev, \"VLSI router PIRQ escape (%d)\\n\", pirq);\n\t\treturn 0;\n\t}\n\twrite_config_nybble(router, 0x74, pirq-1, irq);\n\treturn 1;\n}\n\n \nstatic int pirq_serverworks_get(struct pci_dev *router, struct pci_dev *dev, int pirq)\n{\n\toutb(pirq, 0xc00);\n\treturn inb(0xc01) & 0xf;\n}\n\nstatic int pirq_serverworks_set(struct pci_dev *router, struct pci_dev *dev,\n\tint pirq, int irq)\n{\n\toutb(pirq, 0xc00);\n\toutb(irq, 0xc01);\n\treturn 1;\n}\n\n \nstatic int pirq_amd756_get(struct pci_dev *router, struct pci_dev *dev, int pirq)\n{\n\tu8 irq;\n\tirq = 0;\n\tif (pirq <= 4)\n\t\tirq = read_config_nybble(router, 0x56, pirq - 1);\n\tdev_info(&dev->dev,\n\t\t \"AMD756: dev [%04x:%04x], router PIRQ %d get IRQ %d\\n\",\n\t\t dev->vendor, dev->device, pirq, irq);\n\treturn irq;\n}\n\nstatic int pirq_amd756_set(struct pci_dev *router, struct pci_dev *dev, int pirq, int irq)\n{\n\tdev_info(&dev->dev,\n\t\t \"AMD756: dev [%04x:%04x], router PIRQ %d set IRQ %d\\n\",\n\t\t dev->vendor, dev->device, pirq, irq);\n\tif (pirq <= 4)\n\t\twrite_config_nybble(router, 0x56, pirq - 1, irq);\n\treturn 1;\n}\n\n \nstatic int pirq_pico_get(struct pci_dev *router, struct pci_dev *dev, int pirq)\n{\n\toutb(0x10 + ((pirq - 1) >> 1), 0x24);\n\treturn ((pirq - 1) & 1) ? (inb(0x26) >> 4) : (inb(0x26) & 0xf);\n}\n\nstatic int pirq_pico_set(struct pci_dev *router, struct pci_dev *dev, int pirq,\n\t\t\tint irq)\n{\n\tunsigned int x;\n\toutb(0x10 + ((pirq - 1) >> 1), 0x24);\n\tx = inb(0x26);\n\tx = ((pirq - 1) & 1) ? ((x & 0x0f) | (irq << 4)) : ((x & 0xf0) | (irq));\n\toutb(x, 0x26);\n\treturn 1;\n}\n\n#ifdef CONFIG_PCI_BIOS\n\nstatic int pirq_bios_set(struct pci_dev *router, struct pci_dev *dev, int pirq, int irq)\n{\n\tstruct pci_dev *bridge;\n\tint pin = pci_get_interrupt_pin(dev, &bridge);\n\treturn pcibios_set_irq_routing(bridge, pin - 1, irq);\n}\n\n#endif\n\nstatic __init int intel_router_probe(struct irq_router *r, struct pci_dev *router, u16 device)\n{\n\tstatic struct pci_device_id __initdata pirq_440gx[] = {\n\t\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82443GX_0) },\n\t\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82443GX_2) },\n\t\t{ },\n\t};\n\n\t \n\tif (pci_dev_present(pirq_440gx))\n\t\treturn 0;\n\n\tswitch (device) {\n\tcase PCI_DEVICE_ID_INTEL_82375:\n\t\tr->name = \"PCEB/ESC\";\n\t\tr->get = pirq_esc_get;\n\t\tr->set = pirq_esc_set;\n\t\treturn 1;\n\tcase PCI_DEVICE_ID_INTEL_82371FB_0:\n\tcase PCI_DEVICE_ID_INTEL_82371SB_0:\n\tcase PCI_DEVICE_ID_INTEL_82371AB_0:\n\tcase PCI_DEVICE_ID_INTEL_82371MX:\n\tcase PCI_DEVICE_ID_INTEL_82443MX_0:\n\tcase PCI_DEVICE_ID_INTEL_82801AA_0:\n\tcase PCI_DEVICE_ID_INTEL_82801AB_0:\n\tcase PCI_DEVICE_ID_INTEL_82801BA_0:\n\tcase PCI_DEVICE_ID_INTEL_82801BA_10:\n\tcase PCI_DEVICE_ID_INTEL_82801CA_0:\n\tcase PCI_DEVICE_ID_INTEL_82801CA_12:\n\tcase PCI_DEVICE_ID_INTEL_82801DB_0:\n\tcase PCI_DEVICE_ID_INTEL_82801E_0:\n\tcase PCI_DEVICE_ID_INTEL_82801EB_0:\n\tcase PCI_DEVICE_ID_INTEL_ESB_1:\n\tcase PCI_DEVICE_ID_INTEL_ICH6_0:\n\tcase PCI_DEVICE_ID_INTEL_ICH6_1:\n\tcase PCI_DEVICE_ID_INTEL_ICH7_0:\n\tcase PCI_DEVICE_ID_INTEL_ICH7_1:\n\tcase PCI_DEVICE_ID_INTEL_ICH7_30:\n\tcase PCI_DEVICE_ID_INTEL_ICH7_31:\n\tcase PCI_DEVICE_ID_INTEL_TGP_LPC:\n\tcase PCI_DEVICE_ID_INTEL_ESB2_0:\n\tcase PCI_DEVICE_ID_INTEL_ICH8_0:\n\tcase PCI_DEVICE_ID_INTEL_ICH8_1:\n\tcase PCI_DEVICE_ID_INTEL_ICH8_2:\n\tcase PCI_DEVICE_ID_INTEL_ICH8_3:\n\tcase PCI_DEVICE_ID_INTEL_ICH8_4:\n\tcase PCI_DEVICE_ID_INTEL_ICH9_0:\n\tcase PCI_DEVICE_ID_INTEL_ICH9_1:\n\tcase PCI_DEVICE_ID_INTEL_ICH9_2:\n\tcase PCI_DEVICE_ID_INTEL_ICH9_3:\n\tcase PCI_DEVICE_ID_INTEL_ICH9_4:\n\tcase PCI_DEVICE_ID_INTEL_ICH9_5:\n\tcase PCI_DEVICE_ID_INTEL_EP80579_0:\n\tcase PCI_DEVICE_ID_INTEL_ICH10_0:\n\tcase PCI_DEVICE_ID_INTEL_ICH10_1:\n\tcase PCI_DEVICE_ID_INTEL_ICH10_2:\n\tcase PCI_DEVICE_ID_INTEL_ICH10_3:\n\tcase PCI_DEVICE_ID_INTEL_PATSBURG_LPC_0:\n\tcase PCI_DEVICE_ID_INTEL_PATSBURG_LPC_1:\n\t\tr->name = \"PIIX/ICH\";\n\t\tr->get = pirq_piix_get;\n\t\tr->set = pirq_piix_set;\n\t\treturn 1;\n\tcase PCI_DEVICE_ID_INTEL_82425:\n\t\tr->name = \"PSC/IB\";\n\t\tr->get = pirq_ib_get;\n\t\tr->set = pirq_ib_set;\n\t\treturn 1;\n\t}\n\n\tif ((device >= PCI_DEVICE_ID_INTEL_5_3400_SERIES_LPC_MIN && \n\t     device <= PCI_DEVICE_ID_INTEL_5_3400_SERIES_LPC_MAX) \n\t||  (device >= PCI_DEVICE_ID_INTEL_COUGARPOINT_LPC_MIN && \n\t     device <= PCI_DEVICE_ID_INTEL_COUGARPOINT_LPC_MAX)\n\t||  (device >= PCI_DEVICE_ID_INTEL_DH89XXCC_LPC_MIN &&\n\t     device <= PCI_DEVICE_ID_INTEL_DH89XXCC_LPC_MAX)\n\t||  (device >= PCI_DEVICE_ID_INTEL_PANTHERPOINT_LPC_MIN &&\n\t     device <= PCI_DEVICE_ID_INTEL_PANTHERPOINT_LPC_MAX)) {\n\t\tr->name = \"PIIX/ICH\";\n\t\tr->get = pirq_piix_get;\n\t\tr->set = pirq_piix_set;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic __init int via_router_probe(struct irq_router *r,\n\t\t\t\tstruct pci_dev *router, u16 device)\n{\n\t \n\n\t \n\tif (device == PCI_DEVICE_ID_VIA_82C586_0) {\n\t\tswitch (router->device) {\n\t\tcase PCI_DEVICE_ID_VIA_82C686:\n\t\t\t \n\t\t\tdevice = PCI_DEVICE_ID_VIA_82C686;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_VIA_8235:\n\t\t\t \n\t\t\tdevice = PCI_DEVICE_ID_VIA_8235;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_VIA_8237:\n\t\t\t \n\t\t\tdevice = PCI_DEVICE_ID_VIA_8237;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (device) {\n\tcase PCI_DEVICE_ID_VIA_82C586_0:\n\t\tr->name = \"VIA\";\n\t\tr->get = pirq_via586_get;\n\t\tr->set = pirq_via586_set;\n\t\treturn 1;\n\tcase PCI_DEVICE_ID_VIA_82C596:\n\tcase PCI_DEVICE_ID_VIA_82C686:\n\tcase PCI_DEVICE_ID_VIA_8231:\n\tcase PCI_DEVICE_ID_VIA_8233A:\n\tcase PCI_DEVICE_ID_VIA_8235:\n\tcase PCI_DEVICE_ID_VIA_8237:\n\t\t \n\t\tr->name = \"VIA\";\n\t\tr->get = pirq_via_get;\n\t\tr->set = pirq_via_set;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic __init int vlsi_router_probe(struct irq_router *r, struct pci_dev *router, u16 device)\n{\n\tswitch (device) {\n\tcase PCI_DEVICE_ID_VLSI_82C534:\n\t\tr->name = \"VLSI 82C534\";\n\t\tr->get = pirq_vlsi_get;\n\t\tr->set = pirq_vlsi_set;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nstatic __init int serverworks_router_probe(struct irq_router *r,\n\t\tstruct pci_dev *router, u16 device)\n{\n\tswitch (device) {\n\tcase PCI_DEVICE_ID_SERVERWORKS_OSB4:\n\tcase PCI_DEVICE_ID_SERVERWORKS_CSB5:\n\t\tr->name = \"ServerWorks\";\n\t\tr->get = pirq_serverworks_get;\n\t\tr->set = pirq_serverworks_set;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic __init int sis_router_probe(struct irq_router *r, struct pci_dev *router, u16 device)\n{\n\tswitch (device) {\n\tcase PCI_DEVICE_ID_SI_496:\n\t\tr->name = \"SiS85C497\";\n\t\tr->get = pirq_sis497_get;\n\t\tr->set = pirq_sis497_set;\n\t\treturn 1;\n\tcase PCI_DEVICE_ID_SI_503:\n\t\tr->name = \"SiS85C503\";\n\t\tr->get = pirq_sis503_get;\n\t\tr->set = pirq_sis503_set;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic __init int cyrix_router_probe(struct irq_router *r, struct pci_dev *router, u16 device)\n{\n\tswitch (device) {\n\tcase PCI_DEVICE_ID_CYRIX_5520:\n\t\tr->name = \"NatSemi\";\n\t\tr->get = pirq_cyrix_get;\n\t\tr->set = pirq_cyrix_set;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic __init int opti_router_probe(struct irq_router *r, struct pci_dev *router, u16 device)\n{\n\tswitch (device) {\n\tcase PCI_DEVICE_ID_OPTI_82C700:\n\t\tr->name = \"OPTI\";\n\t\tr->get = pirq_opti_get;\n\t\tr->set = pirq_opti_set;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic __init int ite_router_probe(struct irq_router *r, struct pci_dev *router, u16 device)\n{\n\tswitch (device) {\n\tcase PCI_DEVICE_ID_ITE_IT8330G_0:\n\t\tr->name = \"ITE\";\n\t\tr->get = pirq_ite_get;\n\t\tr->set = pirq_ite_set;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic __init int ali_router_probe(struct irq_router *r, struct pci_dev *router, u16 device)\n{\n\tswitch (device) {\n\tcase PCI_DEVICE_ID_AL_M1489:\n\t\tr->name = \"FinALi\";\n\t\tr->get = pirq_finali_get;\n\t\tr->set = pirq_finali_set;\n\t\tr->lvl = pirq_finali_lvl;\n\t\treturn 1;\n\tcase PCI_DEVICE_ID_AL_M1533:\n\tcase PCI_DEVICE_ID_AL_M1563:\n\t\tr->name = \"ALI\";\n\t\tr->get = pirq_ali_get;\n\t\tr->set = pirq_ali_set;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic __init int amd_router_probe(struct irq_router *r, struct pci_dev *router, u16 device)\n{\n\tswitch (device) {\n\tcase PCI_DEVICE_ID_AMD_VIPER_740B:\n\t\tr->name = \"AMD756\";\n\t\tbreak;\n\tcase PCI_DEVICE_ID_AMD_VIPER_7413:\n\t\tr->name = \"AMD766\";\n\t\tbreak;\n\tcase PCI_DEVICE_ID_AMD_VIPER_7443:\n\t\tr->name = \"AMD768\";\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tr->get = pirq_amd756_get;\n\tr->set = pirq_amd756_set;\n\treturn 1;\n}\n\nstatic __init int pico_router_probe(struct irq_router *r, struct pci_dev *router, u16 device)\n{\n\tswitch (device) {\n\tcase PCI_DEVICE_ID_PICOPOWER_PT86C523:\n\t\tr->name = \"PicoPower PT86C523\";\n\t\tr->get = pirq_pico_get;\n\t\tr->set = pirq_pico_set;\n\t\treturn 1;\n\n\tcase PCI_DEVICE_ID_PICOPOWER_PT86C523BBP:\n\t\tr->name = \"PicoPower PT86C523 rev. BB+\";\n\t\tr->get = pirq_pico_get;\n\t\tr->set = pirq_pico_set;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic __initdata struct irq_router_handler pirq_routers[] = {\n\t{ PCI_VENDOR_ID_INTEL, intel_router_probe },\n\t{ PCI_VENDOR_ID_AL, ali_router_probe },\n\t{ PCI_VENDOR_ID_ITE, ite_router_probe },\n\t{ PCI_VENDOR_ID_VIA, via_router_probe },\n\t{ PCI_VENDOR_ID_OPTI, opti_router_probe },\n\t{ PCI_VENDOR_ID_SI, sis_router_probe },\n\t{ PCI_VENDOR_ID_CYRIX, cyrix_router_probe },\n\t{ PCI_VENDOR_ID_VLSI, vlsi_router_probe },\n\t{ PCI_VENDOR_ID_SERVERWORKS, serverworks_router_probe },\n\t{ PCI_VENDOR_ID_AMD, amd_router_probe },\n\t{ PCI_VENDOR_ID_PICOPOWER, pico_router_probe },\n\t \n\t{ 0, NULL }\n};\nstatic struct irq_router pirq_router;\nstatic struct pci_dev *pirq_router_dev;\n\n\n \n\nstatic bool __init pirq_try_router(struct irq_router *r,\n\t\t\t\t   struct irq_routing_table *rt,\n\t\t\t\t   struct pci_dev *dev)\n{\n\tstruct irq_router_handler *h;\n\n\tDBG(KERN_DEBUG \"PCI: Trying IRQ router for [%04x:%04x]\\n\",\n\t    dev->vendor, dev->device);\n\n\tfor (h = pirq_routers; h->vendor; h++) {\n\t\t \n\t\tif (rt->rtr_vendor == h->vendor &&\n\t\t    h->probe(r, dev, rt->rtr_device))\n\t\t\treturn true;\n\t\t \n\t\tif (dev->vendor == h->vendor &&\n\t\t    h->probe(r, dev, dev->device))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void __init pirq_find_router(struct irq_router *r)\n{\n\tstruct irq_routing_table *rt = pirq_table;\n\tstruct pci_dev *dev;\n\n#ifdef CONFIG_PCI_BIOS\n\tif (!rt->signature) {\n\t\tprintk(KERN_INFO \"PCI: Using BIOS for IRQ routing\\n\");\n\t\tr->set = pirq_bios_set;\n\t\tr->name = \"BIOS\";\n\t\treturn;\n\t}\n#endif\n\n\t \n\tr->name = \"default\";\n\tr->get = NULL;\n\tr->set = NULL;\n\n\tDBG(KERN_DEBUG \"PCI: Attempting to find IRQ router for [%04x:%04x]\\n\",\n\t    rt->rtr_vendor, rt->rtr_device);\n\n\t \n\tif (rt->rtr_vendor) {\n\t\tdev = pci_get_domain_bus_and_slot(0, rt->rtr_bus,\n\t\t\t\t\t\t  rt->rtr_devfn);\n\t\tif (dev && pirq_try_router(r, rt, dev))\n\t\t\tpirq_router_dev = dev;\n\t} else {\n\t\tdev = NULL;\n\t\tfor_each_pci_dev(dev) {\n\t\t\tif (pirq_try_router(r, rt, dev)) {\n\t\t\t\tpirq_router_dev = dev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pirq_router_dev)\n\t\tdev_info(&pirq_router_dev->dev, \"%s IRQ router [%04x:%04x]\\n\",\n\t\t\t pirq_router.name,\n\t\t\t pirq_router_dev->vendor, pirq_router_dev->device);\n\telse\n\t\tDBG(KERN_DEBUG \"PCI: Interrupt router not found at \"\n\t\t    \"%02x:%02x\\n\", rt->rtr_bus, rt->rtr_devfn);\n\n\t \n}\n\n \nstatic struct irq_info *pirq_get_dev_info(struct pci_dev *dev)\n{\n\tstruct irq_routing_table *rt = pirq_table;\n\tint entries = (rt->size - sizeof(struct irq_routing_table)) /\n\t\tsizeof(struct irq_info);\n\tstruct irq_info *slotinfo = NULL;\n\tstruct irq_info *info;\n\n\tfor (info = rt->slots; entries--; info++)\n\t\tif (info->bus == dev->bus->number) {\n\t\t\tif (info->devfn == dev->devfn)\n\t\t\t\treturn info;\n\t\t\tif (!slotinfo &&\n\t\t\t    PCI_SLOT(info->devfn) == PCI_SLOT(dev->devfn))\n\t\t\t\tslotinfo = info;\n\t\t}\n\treturn slotinfo;\n}\n\n \nstatic struct irq_info *pirq_get_info(struct pci_dev *dev, u8 *pin)\n{\n\tstruct pci_dev *temp_dev = dev;\n\tstruct irq_info *info;\n\tu8 temp_pin = *pin;\n\tu8 dpin = temp_pin;\n\n\tinfo = pirq_get_dev_info(dev);\n\twhile (!info && temp_dev->bus->parent) {\n\t\tstruct pci_dev *bridge = temp_dev->bus->self;\n\n\t\ttemp_pin = pci_swizzle_interrupt_pin(temp_dev, temp_pin);\n\t\tinfo = pirq_get_dev_info(bridge);\n\t\tif (info)\n\t\t\tdev_warn(&dev->dev,\n\t\t\t\t \"using bridge %s INT %c to get INT %c\\n\",\n\t\t\t\t pci_name(bridge),\n\t\t\t\t 'A' + temp_pin - 1, 'A' + dpin - 1);\n\n\t\ttemp_dev = bridge;\n\t}\n\t*pin = temp_pin;\n\treturn info;\n}\n\nstatic int pcibios_lookup_irq(struct pci_dev *dev, int assign)\n{\n\tstruct irq_info *info;\n\tint i, pirq, newirq;\n\tu8 dpin, pin;\n\tint irq = 0;\n\tu32 mask;\n\tstruct irq_router *r = &pirq_router;\n\tstruct pci_dev *dev2 = NULL;\n\tchar *msg = NULL;\n\n\t \n\tpci_read_config_byte(dev, PCI_INTERRUPT_PIN, &dpin);\n\tif (!dpin) {\n\t\tdev_dbg(&dev->dev, \"no interrupt pin\\n\");\n\t\treturn 0;\n\t}\n\n\tif (io_apic_assign_pci_irqs)\n\t\treturn 0;\n\n\t \n\n\tif (!pirq_table)\n\t\treturn 0;\n\n\tpin = dpin;\n\tinfo = pirq_get_info(dev, &pin);\n\tif (!info) {\n\t\tdev_dbg(&dev->dev, \"PCI INT %c not found in routing table\\n\",\n\t\t\t'A' + dpin - 1);\n\t\treturn 0;\n\t}\n\tpirq = info->irq[pin - 1].link;\n\tmask = info->irq[pin - 1].bitmap;\n\tif (!pirq) {\n\t\tdev_dbg(&dev->dev, \"PCI INT %c not routed\\n\", 'A' + dpin - 1);\n\t\treturn 0;\n\t}\n\tdev_dbg(&dev->dev, \"PCI INT %c -> PIRQ %02x, mask %04x, excl %04x\",\n\t\t'A' + dpin - 1, pirq, mask, pirq_table->exclusive_irqs);\n\tmask &= pcibios_irq_mask;\n\n\t \n\n\tif (broken_hp_bios_irq9 && pirq == 0x59 && dev->irq == 9) {\n\t\tdev->irq = 11;\n\t\tpci_write_config_byte(dev, PCI_INTERRUPT_LINE, 11);\n\t\tr->set(pirq_router_dev, dev, pirq, 11);\n\t}\n\n\t \n\tif (acer_tm360_irqrouting && dev->irq == 11 &&\n\t\tdev->vendor == PCI_VENDOR_ID_O2) {\n\t\tpirq = 0x68;\n\t\tmask = 0x400;\n\t\tdev->irq = r->get(pirq_router_dev, dev, pirq);\n\t\tpci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);\n\t}\n\n\t \n\tnewirq = dev->irq;\n\tif (newirq && !((1 << newirq) & mask)) {\n\t\tif (pci_probe & PCI_USE_PIRQ_MASK)\n\t\t\tnewirq = 0;\n\t\telse\n\t\t\tdev_warn(&dev->dev, \"IRQ %d doesn't match PIRQ mask \"\n\t\t\t\t \"%#x; try pci=usepirqmask\\n\", newirq, mask);\n\t}\n\tif (!newirq && assign) {\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tif (!(mask & (1 << i)))\n\t\t\t\tcontinue;\n\t\t\tif (pirq_penalty[i] < pirq_penalty[newirq] &&\n\t\t\t\tcan_request_irq(i, IRQF_SHARED))\n\t\t\t\tnewirq = i;\n\t\t}\n\t}\n\tdev_dbg(&dev->dev, \"PCI INT %c -> newirq %d\", 'A' + dpin - 1, newirq);\n\n\t \n\tif ((pirq & 0xf0) == 0xf0) {\n\t\tirq = pirq & 0xf;\n\t\tmsg = \"hardcoded\";\n\t} else if (r->get && (irq = r->get(pirq_router_dev, dev, pirq)) && \\\n\t((!(pci_probe & PCI_USE_PIRQ_MASK)) || ((1 << irq) & mask))) {\n\t\tmsg = \"found\";\n\t\tif (r->lvl)\n\t\t\tr->lvl(pirq_router_dev, dev, pirq, irq);\n\t\telse\n\t\t\telcr_set_level_irq(irq);\n\t} else if (newirq && r->set &&\n\t\t(dev->class >> 8) != PCI_CLASS_DISPLAY_VGA) {\n\t\tif (r->set(pirq_router_dev, dev, pirq, newirq)) {\n\t\t\tif (r->lvl)\n\t\t\t\tr->lvl(pirq_router_dev, dev, pirq, newirq);\n\t\t\telse\n\t\t\t\telcr_set_level_irq(newirq);\n\t\t\tmsg = \"assigned\";\n\t\t\tirq = newirq;\n\t\t}\n\t}\n\n\tif (!irq) {\n\t\tif (newirq && mask == (1 << newirq)) {\n\t\t\tmsg = \"guessed\";\n\t\t\tirq = newirq;\n\t\t} else {\n\t\t\tdev_dbg(&dev->dev, \"can't route interrupt\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdev_info(&dev->dev, \"%s PCI INT %c -> IRQ %d\\n\",\n\t\t msg, 'A' + dpin - 1, irq);\n\n\t \n\tfor_each_pci_dev(dev2) {\n\t\tpci_read_config_byte(dev2, PCI_INTERRUPT_PIN, &dpin);\n\t\tif (!dpin)\n\t\t\tcontinue;\n\n\t\tpin = dpin;\n\t\tinfo = pirq_get_info(dev2, &pin);\n\t\tif (!info)\n\t\t\tcontinue;\n\t\tif (info->irq[pin - 1].link == pirq) {\n\t\t\t \n\t\t\tif (dev2->irq && dev2->irq != irq && \\\n\t\t\t(!(pci_probe & PCI_USE_PIRQ_MASK) || \\\n\t\t\t((1 << dev2->irq) & mask))) {\n#ifndef CONFIG_PCI_MSI\n\t\t\t\tdev_info(&dev2->dev, \"IRQ routing conflict: \"\n\t\t\t\t\t \"have IRQ %d, want IRQ %d\\n\",\n\t\t\t\t\t dev2->irq, irq);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdev2->irq = irq;\n\t\t\tpirq_penalty[irq]++;\n\t\t\tif (dev != dev2)\n\t\t\t\tdev_info(&dev->dev, \"sharing IRQ %d with %s\\n\",\n\t\t\t\t\t irq, pci_name(dev2));\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid __init pcibios_fixup_irqs(void)\n{\n\tstruct pci_dev *dev = NULL;\n\tu8 pin;\n\n\tDBG(KERN_DEBUG \"PCI: IRQ fixup\\n\");\n\tfor_each_pci_dev(dev) {\n\t\t \n\t\tif (dev->irq >= 16) {\n\t\t\tdev_dbg(&dev->dev, \"ignoring bogus IRQ %d\\n\", dev->irq);\n\t\t\tdev->irq = 0;\n\t\t}\n\t\t \n\t\tif (pirq_penalty[dev->irq] >= 100 &&\n\t\t\t\tpirq_penalty[dev->irq] < 100000)\n\t\t\tpirq_penalty[dev->irq] = 0;\n\t\tpirq_penalty[dev->irq]++;\n\t}\n\n\tif (io_apic_assign_pci_irqs)\n\t\treturn;\n\n\tdev = NULL;\n\tfor_each_pci_dev(dev) {\n\t\tpci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);\n\t\tif (!pin)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!dev->irq)\n\t\t\tpcibios_lookup_irq(dev, 0);\n\t}\n}\n\n \nstatic int __init fix_broken_hp_bios_irq9(const struct dmi_system_id *d)\n{\n\tif (!broken_hp_bios_irq9) {\n\t\tbroken_hp_bios_irq9 = 1;\n\t\tprintk(KERN_INFO \"%s detected - fixing broken IRQ routing\\n\",\n\t\t\td->ident);\n\t}\n\treturn 0;\n}\n\n \nstatic int __init fix_acer_tm360_irqrouting(const struct dmi_system_id *d)\n{\n\tif (!acer_tm360_irqrouting) {\n\t\tacer_tm360_irqrouting = 1;\n\t\tprintk(KERN_INFO \"%s detected - fixing broken IRQ routing\\n\",\n\t\t\td->ident);\n\t}\n\treturn 0;\n}\n\nstatic const struct dmi_system_id pciirq_dmi_table[] __initconst = {\n\t{\n\t\t.callback = fix_broken_hp_bios_irq9,\n\t\t.ident = \"HP Pavilion N5400 Series Laptop\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"GE.M1.03\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION,\n\t\t\t\t\"HP Pavilion Notebook Model GE\"),\n\t\t\tDMI_MATCH(DMI_BOARD_VERSION, \"OmniBook N32N-736\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = fix_acer_tm360_irqrouting,\n\t\t.ident = \"Acer TravelMate 36x Laptop\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 360\"),\n\t\t},\n\t},\n\t{ }\n};\n\nvoid __init pcibios_irq_init(void)\n{\n\tstruct irq_routing_table *rtable = NULL;\n\n\tDBG(KERN_DEBUG \"PCI: IRQ init\\n\");\n\n\tif (raw_pci_ops == NULL)\n\t\treturn;\n\n\tdmi_check_system(pciirq_dmi_table);\n\n\tpirq_table = pirq_find_routing_table();\n\n#ifdef CONFIG_PCI_BIOS\n\tif (!pirq_table && (pci_probe & PCI_BIOS_IRQ_SCAN)) {\n\t\tpirq_table = pcibios_get_irq_routing_table();\n\t\trtable = pirq_table;\n\t}\n#endif\n\tif (pirq_table) {\n\t\tpirq_peer_trick();\n\t\tpirq_find_router(&pirq_router);\n\t\tif (pirq_table->exclusive_irqs) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 16; i++)\n\t\t\t\tif (!(pirq_table->exclusive_irqs & (1 << i)))\n\t\t\t\t\tpirq_penalty[i] += 100;\n\t\t}\n\t\t \n\t\tif (io_apic_assign_pci_irqs) {\n\t\t\tkfree(rtable);\n\t\t\tpirq_table = NULL;\n\t\t}\n\t}\n\n\tx86_init.pci.fixup_irqs();\n\n\tif (io_apic_assign_pci_irqs && pci_routeirq) {\n\t\tstruct pci_dev *dev = NULL;\n\t\t \n\t\tprintk(KERN_INFO \"PCI: Routing PCI interrupts for all devices because \\\"pci=routeirq\\\" specified\\n\");\n\t\tfor_each_pci_dev(dev)\n\t\t\tpirq_enable_irq(dev);\n\t}\n}\n\nstatic void pirq_penalize_isa_irq(int irq, int active)\n{\n\t \n\tif (irq < 16) {\n\t\tif (active)\n\t\t\tpirq_penalty[irq] += 1000;\n\t\telse\n\t\t\tpirq_penalty[irq] += 100;\n\t}\n}\n\nvoid pcibios_penalize_isa_irq(int irq, int active)\n{\n#ifdef CONFIG_ACPI\n\tif (!acpi_noirq)\n\t\tacpi_penalize_isa_irq(irq, active);\n\telse\n#endif\n\t\tpirq_penalize_isa_irq(irq, active);\n}\n\nstatic int pirq_enable_irq(struct pci_dev *dev)\n{\n\tu8 pin = 0;\n\n\tpci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);\n\tif (pin && !pcibios_lookup_irq(dev, 1)) {\n\t\tchar *msg = \"\";\n\n\t\tif (!io_apic_assign_pci_irqs && dev->irq)\n\t\t\treturn 0;\n\n\t\tif (io_apic_assign_pci_irqs) {\n#ifdef CONFIG_X86_IO_APIC\n\t\t\tstruct pci_dev *temp_dev;\n\t\t\tint irq;\n\n\t\t\tif (dev->irq_managed && dev->irq > 0)\n\t\t\t\treturn 0;\n\n\t\t\tirq = IO_APIC_get_PCI_irq_vector(dev->bus->number,\n\t\t\t\t\t\tPCI_SLOT(dev->devfn), pin - 1);\n\t\t\t \n\t\t\ttemp_dev = dev;\n\t\t\twhile (irq < 0 && dev->bus->parent) {  \n\t\t\t\tstruct pci_dev *bridge = dev->bus->self;\n\n\t\t\t\tpin = pci_swizzle_interrupt_pin(dev, pin);\n\t\t\t\tirq = IO_APIC_get_PCI_irq_vector(bridge->bus->number,\n\t\t\t\t\t\tPCI_SLOT(bridge->devfn),\n\t\t\t\t\t\tpin - 1);\n\t\t\t\tif (irq >= 0)\n\t\t\t\t\tdev_warn(&dev->dev, \"using bridge %s \"\n\t\t\t\t\t\t \"INT %c to get IRQ %d\\n\",\n\t\t\t\t\t\t pci_name(bridge), 'A' + pin - 1,\n\t\t\t\t\t\t irq);\n\t\t\t\tdev = bridge;\n\t\t\t}\n\t\t\tdev = temp_dev;\n\t\t\tif (irq >= 0) {\n\t\t\t\tdev->irq_managed = 1;\n\t\t\t\tdev->irq = irq;\n\t\t\t\tdev_info(&dev->dev, \"PCI->APIC IRQ transform: \"\n\t\t\t\t\t \"INT %c -> IRQ %d\\n\", 'A' + pin - 1, irq);\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\tmsg = \"; probably buggy MP table\";\n#endif\n\t\t} else if (pci_probe & PCI_BIOS_IRQ_SCAN)\n\t\t\tmsg = \"\";\n\t\telse\n\t\t\tmsg = \"; please try using pci=biosirq\";\n\n\t\t \n\t\tif (dev->class >> 8 == PCI_CLASS_STORAGE_IDE &&\n\t\t\t\t!(dev->class & 0x5))\n\t\t\treturn 0;\n\n\t\tdev_warn(&dev->dev, \"can't find IRQ for PCI INT %c%s\\n\",\n\t\t\t 'A' + pin - 1, msg);\n\t}\n\treturn 0;\n}\n\nbool mp_should_keep_irq(struct device *dev)\n{\n\tif (dev->power.is_prepared)\n\t\treturn true;\n#ifdef CONFIG_PM\n\tif (dev->power.runtime_status == RPM_SUSPENDING)\n\t\treturn true;\n#endif\n\n\treturn false;\n}\n\nstatic void pirq_disable_irq(struct pci_dev *dev)\n{\n\tif (io_apic_assign_pci_irqs && !mp_should_keep_irq(&dev->dev) &&\n\t    dev->irq_managed && dev->irq) {\n\t\tmp_unmap_irq(dev->irq);\n\t\tdev->irq = 0;\n\t\tdev->irq_managed = 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}