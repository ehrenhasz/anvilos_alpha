{
  "module_name": "direct.c",
  "hash_id": "d12f1aff2aa2cd99368f536de240aef021cd91250024110dfb502162bd84d52e",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/pci/direct.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/dmi.h>\n#include <asm/pci_x86.h>\n\n \n\n#define PCI_CONF1_ADDRESS(bus, devfn, reg) \\\n\t(0x80000000 | ((reg & 0xF00) << 16) | (bus << 16) \\\n\t| (devfn << 8) | (reg & 0xFC))\n\nstatic int pci_conf1_read(unsigned int seg, unsigned int bus,\n\t\t\t  unsigned int devfn, int reg, int len, u32 *value)\n{\n\tunsigned long flags;\n\n\tif (seg || (bus > 255) || (devfn > 255) || (reg > 4095)) {\n\t\t*value = -1;\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_lock_irqsave(&pci_config_lock, flags);\n\n\toutl(PCI_CONF1_ADDRESS(bus, devfn, reg), 0xCF8);\n\n\tswitch (len) {\n\tcase 1:\n\t\t*value = inb(0xCFC + (reg & 3));\n\t\tbreak;\n\tcase 2:\n\t\t*value = inw(0xCFC + (reg & 2));\n\t\tbreak;\n\tcase 4:\n\t\t*value = inl(0xCFC);\n\t\tbreak;\n\t}\n\n\traw_spin_unlock_irqrestore(&pci_config_lock, flags);\n\n\treturn 0;\n}\n\nstatic int pci_conf1_write(unsigned int seg, unsigned int bus,\n\t\t\t   unsigned int devfn, int reg, int len, u32 value)\n{\n\tunsigned long flags;\n\n\tif (seg || (bus > 255) || (devfn > 255) || (reg > 4095))\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&pci_config_lock, flags);\n\n\toutl(PCI_CONF1_ADDRESS(bus, devfn, reg), 0xCF8);\n\n\tswitch (len) {\n\tcase 1:\n\t\toutb((u8)value, 0xCFC + (reg & 3));\n\t\tbreak;\n\tcase 2:\n\t\toutw((u16)value, 0xCFC + (reg & 2));\n\t\tbreak;\n\tcase 4:\n\t\toutl((u32)value, 0xCFC);\n\t\tbreak;\n\t}\n\n\traw_spin_unlock_irqrestore(&pci_config_lock, flags);\n\n\treturn 0;\n}\n\n#undef PCI_CONF1_ADDRESS\n\nconst struct pci_raw_ops pci_direct_conf1 = {\n\t.read =\t\tpci_conf1_read,\n\t.write =\tpci_conf1_write,\n};\n\n\n \n\n#define PCI_CONF2_ADDRESS(dev, reg)\t(u16)(0xC000 | (dev << 8) | reg)\n\nstatic int pci_conf2_read(unsigned int seg, unsigned int bus,\n\t\t\t  unsigned int devfn, int reg, int len, u32 *value)\n{\n\tunsigned long flags;\n\tint dev, fn;\n\n\tWARN_ON(seg);\n\tif ((bus > 255) || (devfn > 255) || (reg > 255)) {\n\t\t*value = -1;\n\t\treturn -EINVAL;\n\t}\n\n\tdev = PCI_SLOT(devfn);\n\tfn = PCI_FUNC(devfn);\n\n\tif (dev & 0x10) \n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\traw_spin_lock_irqsave(&pci_config_lock, flags);\n\n\toutb((u8)(0xF0 | (fn << 1)), 0xCF8);\n\toutb((u8)bus, 0xCFA);\n\n\tswitch (len) {\n\tcase 1:\n\t\t*value = inb(PCI_CONF2_ADDRESS(dev, reg));\n\t\tbreak;\n\tcase 2:\n\t\t*value = inw(PCI_CONF2_ADDRESS(dev, reg));\n\t\tbreak;\n\tcase 4:\n\t\t*value = inl(PCI_CONF2_ADDRESS(dev, reg));\n\t\tbreak;\n\t}\n\n\toutb(0, 0xCF8);\n\n\traw_spin_unlock_irqrestore(&pci_config_lock, flags);\n\n\treturn 0;\n}\n\nstatic int pci_conf2_write(unsigned int seg, unsigned int bus,\n\t\t\t   unsigned int devfn, int reg, int len, u32 value)\n{\n\tunsigned long flags;\n\tint dev, fn;\n\n\tWARN_ON(seg);\n\tif ((bus > 255) || (devfn > 255) || (reg > 255)) \n\t\treturn -EINVAL;\n\n\tdev = PCI_SLOT(devfn);\n\tfn = PCI_FUNC(devfn);\n\n\tif (dev & 0x10) \n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\traw_spin_lock_irqsave(&pci_config_lock, flags);\n\n\toutb((u8)(0xF0 | (fn << 1)), 0xCF8);\n\toutb((u8)bus, 0xCFA);\n\n\tswitch (len) {\n\tcase 1:\n\t\toutb((u8)value, PCI_CONF2_ADDRESS(dev, reg));\n\t\tbreak;\n\tcase 2:\n\t\toutw((u16)value, PCI_CONF2_ADDRESS(dev, reg));\n\t\tbreak;\n\tcase 4:\n\t\toutl((u32)value, PCI_CONF2_ADDRESS(dev, reg));\n\t\tbreak;\n\t}\n\n\toutb(0, 0xCF8);    \n\n\traw_spin_unlock_irqrestore(&pci_config_lock, flags);\n\n\treturn 0;\n}\n\n#undef PCI_CONF2_ADDRESS\n\nstatic const struct pci_raw_ops pci_direct_conf2 = {\n\t.read =\t\tpci_conf2_read,\n\t.write =\tpci_conf2_write,\n};\n\n\n \nstatic int __init pci_sanity_check(const struct pci_raw_ops *o)\n{\n\tu32 x = 0;\n\tint devfn;\n\n\tif (pci_probe & PCI_NO_CHECKS)\n\t\treturn 1;\n\t \n\tif (dmi_get_bios_year() >= 2001)\n\t\treturn 1;\n\n\tfor (devfn = 0; devfn < 0x100; devfn++) {\n\t\tif (o->read(0, 0, devfn, PCI_CLASS_DEVICE, 2, &x))\n\t\t\tcontinue;\n\t\tif (x == PCI_CLASS_BRIDGE_HOST || x == PCI_CLASS_DISPLAY_VGA)\n\t\t\treturn 1;\n\n\t\tif (o->read(0, 0, devfn, PCI_VENDOR_ID, 2, &x))\n\t\t\tcontinue;\n\t\tif (x == PCI_VENDOR_ID_INTEL || x == PCI_VENDOR_ID_COMPAQ)\n\t\t\treturn 1;\n\t}\n\n\tDBG(KERN_WARNING \"PCI: Sanity check failed\\n\");\n\treturn 0;\n}\n\nstatic int __init pci_check_type1(void)\n{\n\tunsigned long flags;\n\tunsigned int tmp;\n\tint works = 0;\n\n\tlocal_irq_save(flags);\n\n\toutb(0x01, 0xCFB);\n\ttmp = inl(0xCF8);\n\toutl(0x80000000, 0xCF8);\n\tif (inl(0xCF8) == 0x80000000 && pci_sanity_check(&pci_direct_conf1)) {\n\t\tworks = 1;\n\t}\n\toutl(tmp, 0xCF8);\n\tlocal_irq_restore(flags);\n\n\treturn works;\n}\n\nstatic int __init pci_check_type2(void)\n{\n\tunsigned long flags;\n\tint works = 0;\n\n\tlocal_irq_save(flags);\n\n\toutb(0x00, 0xCFB);\n\toutb(0x00, 0xCF8);\n\toutb(0x00, 0xCFA);\n\tif (inb(0xCF8) == 0x00 && inb(0xCFA) == 0x00 &&\n\t    pci_sanity_check(&pci_direct_conf2)) {\n\t\tworks = 1;\n\t}\n\n\tlocal_irq_restore(flags);\n\n\treturn works;\n}\n\nvoid __init pci_direct_init(int type)\n{\n\tif (type == 0)\n\t\treturn;\n\tprintk(KERN_INFO \"PCI: Using configuration type %d for base access\\n\",\n\t\t type);\n\tif (type == 1) {\n\t\traw_pci_ops = &pci_direct_conf1;\n\t\tif (raw_pci_ext_ops)\n\t\t\treturn;\n\t\tif (!(pci_probe & PCI_HAS_IO_ECS))\n\t\t\treturn;\n\t\tprintk(KERN_INFO \"PCI: Using configuration type 1 \"\n\t\t       \"for extended access\\n\");\n\t\traw_pci_ext_ops = &pci_direct_conf1;\n\t\treturn;\n\t}\n\traw_pci_ops = &pci_direct_conf2;\n}\n\nint __init pci_direct_probe(void)\n{\n\tif ((pci_probe & PCI_PROBE_CONF1) == 0)\n\t\tgoto type2;\n\tif (!request_region(0xCF8, 8, \"PCI conf1\"))\n\t\tgoto type2;\n\n\tif (pci_check_type1()) {\n\t\traw_pci_ops = &pci_direct_conf1;\n\t\tport_cf9_safe = true;\n\t\treturn 1;\n\t}\n\trelease_region(0xCF8, 8);\n\n type2:\n\tif ((pci_probe & PCI_PROBE_CONF2) == 0)\n\t\treturn 0;\n\tif (!request_region(0xCF8, 4, \"PCI conf2\"))\n\t\treturn 0;\n\tif (!request_region(0xC000, 0x1000, \"PCI conf2\"))\n\t\tgoto fail2;\n\n\tif (pci_check_type2()) {\n\t\traw_pci_ops = &pci_direct_conf2;\n\t\tport_cf9_safe = true;\n\t\treturn 2;\n\t}\n\n\trelease_region(0xC000, 0x1000);\n fail2:\n\trelease_region(0xCF8, 4);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}