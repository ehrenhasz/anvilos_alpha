{
  "module_name": "printf.c",
  "hash_id": "50c2f50486b9e51cf89e7f771fc1a710793521ff7e518bf60ea90c059202e867",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/printf.c",
  "human_readable_source": "\n \n\n \n\n#include \"boot.h\"\n\nstatic int skip_atoi(const char **s)\n{\n\tint i = 0;\n\n\twhile (isdigit(**s))\n\t\ti = i * 10 + *((*s)++) - '0';\n\treturn i;\n}\n\n#define ZEROPAD\t1\t\t \n#define SIGN\t2\t\t \n#define PLUS\t4\t\t \n#define SPACE\t8\t\t \n#define LEFT\t16\t\t \n#define SMALL\t32\t\t \n#define SPECIAL\t64\t\t \n\n#define __do_div(n, base) ({ \\\nint __res; \\\n__res = ((unsigned long) n) % (unsigned) base; \\\nn = ((unsigned long) n) / (unsigned) base; \\\n__res; })\n\nstatic char *number(char *str, long num, int base, int size, int precision,\n\t\t    int type)\n{\n\t \n\tstatic const char digits[16] = \"0123456789ABCDEF\";  \n\n\tchar tmp[66];\n\tchar c, sign, locase;\n\tint i;\n\n\t \n\tlocase = (type & SMALL);\n\tif (type & LEFT)\n\t\ttype &= ~ZEROPAD;\n\tif (base < 2 || base > 16)\n\t\treturn NULL;\n\tc = (type & ZEROPAD) ? '0' : ' ';\n\tsign = 0;\n\tif (type & SIGN) {\n\t\tif (num < 0) {\n\t\t\tsign = '-';\n\t\t\tnum = -num;\n\t\t\tsize--;\n\t\t} else if (type & PLUS) {\n\t\t\tsign = '+';\n\t\t\tsize--;\n\t\t} else if (type & SPACE) {\n\t\t\tsign = ' ';\n\t\t\tsize--;\n\t\t}\n\t}\n\tif (type & SPECIAL) {\n\t\tif (base == 16)\n\t\t\tsize -= 2;\n\t\telse if (base == 8)\n\t\t\tsize--;\n\t}\n\ti = 0;\n\tif (num == 0)\n\t\ttmp[i++] = '0';\n\telse\n\t\twhile (num != 0)\n\t\t\ttmp[i++] = (digits[__do_div(num, base)] | locase);\n\tif (i > precision)\n\t\tprecision = i;\n\tsize -= precision;\n\tif (!(type & (ZEROPAD + LEFT)))\n\t\twhile (size-- > 0)\n\t\t\t*str++ = ' ';\n\tif (sign)\n\t\t*str++ = sign;\n\tif (type & SPECIAL) {\n\t\tif (base == 8)\n\t\t\t*str++ = '0';\n\t\telse if (base == 16) {\n\t\t\t*str++ = '0';\n\t\t\t*str++ = ('X' | locase);\n\t\t}\n\t}\n\tif (!(type & LEFT))\n\t\twhile (size-- > 0)\n\t\t\t*str++ = c;\n\twhile (i < precision--)\n\t\t*str++ = '0';\n\twhile (i-- > 0)\n\t\t*str++ = tmp[i];\n\twhile (size-- > 0)\n\t\t*str++ = ' ';\n\treturn str;\n}\n\nint vsprintf(char *buf, const char *fmt, va_list args)\n{\n\tint len;\n\tunsigned long num;\n\tint i, base;\n\tchar *str;\n\tconst char *s;\n\n\tint flags;\t\t \n\n\tint field_width;\t \n\tint precision;\t\t \n\tint qualifier;\t\t \n\n\tfor (str = buf; *fmt; ++fmt) {\n\t\tif (*fmt != '%') {\n\t\t\t*str++ = *fmt;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tflags = 0;\n\t      repeat:\n\t\t++fmt;\t\t \n\t\tswitch (*fmt) {\n\t\tcase '-':\n\t\t\tflags |= LEFT;\n\t\t\tgoto repeat;\n\t\tcase '+':\n\t\t\tflags |= PLUS;\n\t\t\tgoto repeat;\n\t\tcase ' ':\n\t\t\tflags |= SPACE;\n\t\t\tgoto repeat;\n\t\tcase '#':\n\t\t\tflags |= SPECIAL;\n\t\t\tgoto repeat;\n\t\tcase '0':\n\t\t\tflags |= ZEROPAD;\n\t\t\tgoto repeat;\n\t\t}\n\n\t\t \n\t\tfield_width = -1;\n\t\tif (isdigit(*fmt))\n\t\t\tfield_width = skip_atoi(&fmt);\n\t\telse if (*fmt == '*') {\n\t\t\t++fmt;\n\t\t\t \n\t\t\tfield_width = va_arg(args, int);\n\t\t\tif (field_width < 0) {\n\t\t\t\tfield_width = -field_width;\n\t\t\t\tflags |= LEFT;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tprecision = -1;\n\t\tif (*fmt == '.') {\n\t\t\t++fmt;\n\t\t\tif (isdigit(*fmt))\n\t\t\t\tprecision = skip_atoi(&fmt);\n\t\t\telse if (*fmt == '*') {\n\t\t\t\t++fmt;\n\t\t\t\t \n\t\t\t\tprecision = va_arg(args, int);\n\t\t\t}\n\t\t\tif (precision < 0)\n\t\t\t\tprecision = 0;\n\t\t}\n\n\t\t \n\t\tqualifier = -1;\n\t\tif (*fmt == 'h' || *fmt == 'l' || *fmt == 'L') {\n\t\t\tqualifier = *fmt;\n\t\t\t++fmt;\n\t\t}\n\n\t\t \n\t\tbase = 10;\n\n\t\tswitch (*fmt) {\n\t\tcase 'c':\n\t\t\tif (!(flags & LEFT))\n\t\t\t\twhile (--field_width > 0)\n\t\t\t\t\t*str++ = ' ';\n\t\t\t*str++ = (unsigned char)va_arg(args, int);\n\t\t\twhile (--field_width > 0)\n\t\t\t\t*str++ = ' ';\n\t\t\tcontinue;\n\n\t\tcase 's':\n\t\t\ts = va_arg(args, char *);\n\t\t\tlen = strnlen(s, precision);\n\n\t\t\tif (!(flags & LEFT))\n\t\t\t\twhile (len < field_width--)\n\t\t\t\t\t*str++ = ' ';\n\t\t\tfor (i = 0; i < len; ++i)\n\t\t\t\t*str++ = *s++;\n\t\t\twhile (len < field_width--)\n\t\t\t\t*str++ = ' ';\n\t\t\tcontinue;\n\n\t\tcase 'p':\n\t\t\tif (field_width == -1) {\n\t\t\t\tfield_width = 2 * sizeof(void *);\n\t\t\t\tflags |= ZEROPAD;\n\t\t\t}\n\t\t\tstr = number(str,\n\t\t\t\t     (unsigned long)va_arg(args, void *), 16,\n\t\t\t\t     field_width, precision, flags);\n\t\t\tcontinue;\n\n\t\tcase 'n':\n\t\t\tif (qualifier == 'l') {\n\t\t\t\tlong *ip = va_arg(args, long *);\n\t\t\t\t*ip = (str - buf);\n\t\t\t} else {\n\t\t\t\tint *ip = va_arg(args, int *);\n\t\t\t\t*ip = (str - buf);\n\t\t\t}\n\t\t\tcontinue;\n\n\t\tcase '%':\n\t\t\t*str++ = '%';\n\t\t\tcontinue;\n\n\t\t\t \n\t\tcase 'o':\n\t\t\tbase = 8;\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\tflags |= SMALL;\n\t\tcase 'X':\n\t\t\tbase = 16;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\tcase 'i':\n\t\t\tflags |= SIGN;\n\t\tcase 'u':\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t*str++ = '%';\n\t\t\tif (*fmt)\n\t\t\t\t*str++ = *fmt;\n\t\t\telse\n\t\t\t\t--fmt;\n\t\t\tcontinue;\n\t\t}\n\t\tif (qualifier == 'l')\n\t\t\tnum = va_arg(args, unsigned long);\n\t\telse if (qualifier == 'h') {\n\t\t\tnum = (unsigned short)va_arg(args, int);\n\t\t\tif (flags & SIGN)\n\t\t\t\tnum = (short)num;\n\t\t} else if (flags & SIGN)\n\t\t\tnum = va_arg(args, int);\n\t\telse\n\t\t\tnum = va_arg(args, unsigned int);\n\t\tstr = number(str, num, base, field_width, precision, flags);\n\t}\n\t*str = '\\0';\n\treturn str - buf;\n}\n\nint sprintf(char *buf, const char *fmt, ...)\n{\n\tva_list args;\n\tint i;\n\n\tva_start(args, fmt);\n\ti = vsprintf(buf, fmt, args);\n\tva_end(args);\n\treturn i;\n}\n\nint printf(const char *fmt, ...)\n{\n\tchar printf_buf[1024];\n\tva_list args;\n\tint printed;\n\n\tva_start(args, fmt);\n\tprinted = vsprintf(printf_buf, fmt, args);\n\tva_end(args);\n\n\tputs(printf_buf);\n\n\treturn printed;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}