{
  "module_name": "video.c",
  "hash_id": "b6047a88cd6870a2bdfe6c6dcbf3940c341a463440d3d348e18fb35023d8d84c",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/video.c",
  "human_readable_source": "\n \n\n \n\n#include <uapi/asm/boot.h>\n\n#include \"boot.h\"\n#include \"video.h\"\n#include \"vesa.h\"\n\nstatic u16 video_segment;\n\nstatic void store_cursor_position(void)\n{\n\tstruct biosregs ireg, oreg;\n\n\tinitregs(&ireg);\n\tireg.ah = 0x03;\n\tintcall(0x10, &ireg, &oreg);\n\n\tboot_params.screen_info.orig_x = oreg.dl;\n\tboot_params.screen_info.orig_y = oreg.dh;\n\n\tif (oreg.ch & 0x20)\n\t\tboot_params.screen_info.flags |= VIDEO_FLAGS_NOCURSOR;\n\n\tif ((oreg.ch & 0x1f) > (oreg.cl & 0x1f))\n\t\tboot_params.screen_info.flags |= VIDEO_FLAGS_NOCURSOR;\n}\n\nstatic void store_video_mode(void)\n{\n\tstruct biosregs ireg, oreg;\n\n\t \n\tinitregs(&ireg);\n\tireg.ah = 0x0f;\n\tintcall(0x10, &ireg, &oreg);\n\n\t \n\tboot_params.screen_info.orig_video_mode = oreg.al & 0x7f;\n\tboot_params.screen_info.orig_video_page = oreg.bh;\n}\n\n \nstatic void store_mode_params(void)\n{\n\tu16 font_size;\n\tint x, y;\n\n\t \n\tif (graphic_mode)\n\t\treturn;\n\n\tstore_cursor_position();\n\tstore_video_mode();\n\n\tif (boot_params.screen_info.orig_video_mode == 0x07) {\n\t\t \n\t\tvideo_segment = 0xb000;\n\t} else {\n\t\t \n\t\tvideo_segment = 0xb800;\n\t}\n\n\tset_fs(0);\n\tfont_size = rdfs16(0x485);  \n\tboot_params.screen_info.orig_video_points = font_size;\n\n\tx = rdfs16(0x44a);\n\ty = (adapter == ADAPTER_CGA) ? 25 : rdfs8(0x484)+1;\n\n\tif (force_x)\n\t\tx = force_x;\n\tif (force_y)\n\t\ty = force_y;\n\n\tboot_params.screen_info.orig_video_cols  = x;\n\tboot_params.screen_info.orig_video_lines = y;\n}\n\nstatic unsigned int get_entry(void)\n{\n\tchar entry_buf[4];\n\tint i, len = 0;\n\tint key;\n\tunsigned int v;\n\n\tdo {\n\t\tkey = getchar();\n\n\t\tif (key == '\\b') {\n\t\t\tif (len > 0) {\n\t\t\t\tputs(\"\\b \\b\");\n\t\t\t\tlen--;\n\t\t\t}\n\t\t} else if ((key >= '0' && key <= '9') ||\n\t\t\t   (key >= 'A' && key <= 'Z') ||\n\t\t\t   (key >= 'a' && key <= 'z')) {\n\t\t\tif (len < sizeof(entry_buf)) {\n\t\t\t\tentry_buf[len++] = key;\n\t\t\t\tputchar(key);\n\t\t\t}\n\t\t}\n\t} while (key != '\\r');\n\tputchar('\\n');\n\n\tif (len == 0)\n\t\treturn VIDEO_CURRENT_MODE;  \n\n\tv = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tv <<= 4;\n\t\tkey = entry_buf[i] | 0x20;\n\t\tv += (key > '9') ? key-'a'+10 : key-'0';\n\t}\n\n\treturn v;\n}\n\nstatic void display_menu(void)\n{\n\tstruct card_info *card;\n\tstruct mode_info *mi;\n\tchar ch;\n\tint i;\n\tint nmodes;\n\tint modes_per_line;\n\tint col;\n\n\tnmodes = 0;\n\tfor (card = video_cards; card < video_cards_end; card++)\n\t\tnmodes += card->nmodes;\n\n\tmodes_per_line = 1;\n\tif (nmodes >= 20)\n\t\tmodes_per_line = 3;\n\n\tfor (col = 0; col < modes_per_line; col++)\n\t\tputs(\"Mode: Resolution:  Type: \");\n\tputchar('\\n');\n\n\tcol = 0;\n\tch = '0';\n\tfor (card = video_cards; card < video_cards_end; card++) {\n\t\tmi = card->modes;\n\t\tfor (i = 0; i < card->nmodes; i++, mi++) {\n\t\t\tchar resbuf[32];\n\t\t\tint visible = mi->x && mi->y;\n\t\t\tu16 mode_id = mi->mode ? mi->mode :\n\t\t\t\t(mi->y << 8)+mi->x;\n\n\t\t\tif (!visible)\n\t\t\t\tcontinue;  \n\n\t\t\tif (mi->depth)\n\t\t\t\tsprintf(resbuf, \"%dx%d\", mi->y, mi->depth);\n\t\t\telse\n\t\t\t\tsprintf(resbuf, \"%d\", mi->y);\n\n\t\t\tprintf(\"%c %03X %4dx%-7s %-6s\",\n\t\t\t       ch, mode_id, mi->x, resbuf, card->card_name);\n\t\t\tcol++;\n\t\t\tif (col >= modes_per_line) {\n\t\t\t\tputchar('\\n');\n\t\t\t\tcol = 0;\n\t\t\t}\n\n\t\t\tif (ch == '9')\n\t\t\t\tch = 'a';\n\t\t\telse if (ch == 'z' || ch == ' ')\n\t\t\t\tch = ' ';  \n\t\t\telse\n\t\t\t\tch++;\n\t\t}\n\t}\n\tif (col)\n\t\tputchar('\\n');\n}\n\n#define H(x)\t((x)-'a'+10)\n#define SCAN\t((H('s')<<12)+(H('c')<<8)+(H('a')<<4)+H('n'))\n\nstatic unsigned int mode_menu(void)\n{\n\tint key;\n\tunsigned int sel;\n\n\tputs(\"Press <ENTER> to see video modes available, \"\n\t     \"<SPACE> to continue, or wait 30 sec\\n\");\n\n\tkbd_flush();\n\twhile (1) {\n\t\tkey = getchar_timeout();\n\t\tif (key == ' ' || key == 0)\n\t\t\treturn VIDEO_CURRENT_MODE;  \n\t\tif (key == '\\r')\n\t\t\tbreak;\n\t\tputchar('\\a');\t \n\t}\n\n\n\tfor (;;) {\n\t\tdisplay_menu();\n\n\t\tputs(\"Enter a video mode or \\\"scan\\\" to scan for \"\n\t\t     \"additional modes: \");\n\t\tsel = get_entry();\n\t\tif (sel != SCAN)\n\t\t\treturn sel;\n\n\t\tprobe_cards(1);\n\t}\n}\n\n \nstatic struct saved_screen {\n\tint x, y;\n\tint curx, cury;\n\tu16 *data;\n} saved;\n\nstatic void save_screen(void)\n{\n\t \n\tsaved.x = boot_params.screen_info.orig_video_cols;\n\tsaved.y = boot_params.screen_info.orig_video_lines;\n\tsaved.curx = boot_params.screen_info.orig_x;\n\tsaved.cury = boot_params.screen_info.orig_y;\n\n\tif (!heap_free(saved.x*saved.y*sizeof(u16)+512))\n\t\treturn;\t\t \n\n\tsaved.data = GET_HEAP(u16, saved.x*saved.y);\n\n\tset_fs(video_segment);\n\tcopy_from_fs(saved.data, 0, saved.x*saved.y*sizeof(u16));\n}\n\nstatic void restore_screen(void)\n{\n\t \n\tint xs = boot_params.screen_info.orig_video_cols;\n\tint ys = boot_params.screen_info.orig_video_lines;\n\tint y;\n\taddr_t dst = 0;\n\tu16 *src = saved.data;\n\tstruct biosregs ireg;\n\n\tif (graphic_mode)\n\t\treturn;\t\t \n\n\tif (!src)\n\t\treturn;\t\t \n\n\t \n\n\tset_fs(video_segment);\n\tfor (y = 0; y < ys; y++) {\n\t\tint npad;\n\n\t\tif (y < saved.y) {\n\t\t\tint copy = (xs < saved.x) ? xs : saved.x;\n\t\t\tcopy_to_fs(dst, src, copy*sizeof(u16));\n\t\t\tdst += copy*sizeof(u16);\n\t\t\tsrc += saved.x;\n\t\t\tnpad = (xs < saved.x) ? 0 : xs-saved.x;\n\t\t} else {\n\t\t\tnpad = xs;\n\t\t}\n\n\t\t \n\t\tasm volatile(\"pushw %%es ; \"\n\t\t\t     \"movw %2,%%es ; \"\n\t\t\t     \"shrw %%cx ; \"\n\t\t\t     \"jnc 1f ; \"\n\t\t\t     \"stosw \\n\\t\"\n\t\t\t     \"1: rep;stosl ; \"\n\t\t\t     \"popw %%es\"\n\t\t\t     : \"+D\" (dst), \"+c\" (npad)\n\t\t\t     : \"bdS\" (video_segment),\n\t\t\t       \"a\" (0x07200720));\n\t}\n\n\t \n\tif (saved.curx >= xs)\n\t\tsaved.curx = xs-1;\n\tif (saved.cury >= ys)\n\t\tsaved.cury = ys-1;\n\n\tinitregs(&ireg);\n\tireg.ah = 0x02;\t\t \n\tireg.dh = saved.cury;\n\tireg.dl = saved.curx;\n\tintcall(0x10, &ireg, NULL);\n\n\tstore_cursor_position();\n}\n\nvoid set_video(void)\n{\n\tu16 mode = boot_params.hdr.vid_mode;\n\n\tRESET_HEAP();\n\n\tstore_mode_params();\n\tsave_screen();\n\tprobe_cards(0);\n\n\tfor (;;) {\n\t\tif (mode == ASK_VGA)\n\t\t\tmode = mode_menu();\n\n\t\tif (!set_mode(mode))\n\t\t\tbreak;\n\n\t\tprintf(\"Undefined video mode number: %x\\n\", mode);\n\t\tmode = ASK_VGA;\n\t}\n\tboot_params.hdr.vid_mode = mode;\n\tvesa_store_edid();\n\tstore_mode_params();\n\n\tif (do_restore)\n\t\trestore_screen();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}