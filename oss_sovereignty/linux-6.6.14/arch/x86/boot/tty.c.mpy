{
  "module_name": "tty.c",
  "hash_id": "522e4f37a2f46964bd7a4fab0c7b8688ae71c903689d2728bdba982d4782b9a6",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/tty.c",
  "human_readable_source": "\n \n\n \n\n#include \"boot.h\"\n\nint early_serial_base;\n\n#define XMTRDY          0x20\n\n#define TXR             0        \n#define LSR             5        \n\n \n\nstatic void __section(\".inittext\") serial_putchar(int ch)\n{\n\tunsigned timeout = 0xffff;\n\n\twhile ((inb(early_serial_base + LSR) & XMTRDY) == 0 && --timeout)\n\t\tcpu_relax();\n\n\toutb(ch, early_serial_base + TXR);\n}\n\nstatic void __section(\".inittext\") bios_putchar(int ch)\n{\n\tstruct biosregs ireg;\n\n\tinitregs(&ireg);\n\tireg.bx = 0x0007;\n\tireg.cx = 0x0001;\n\tireg.ah = 0x0e;\n\tireg.al = ch;\n\tintcall(0x10, &ireg, NULL);\n}\n\nvoid __section(\".inittext\") putchar(int ch)\n{\n\tif (ch == '\\n')\n\t\tputchar('\\r');\t \n\n\tbios_putchar(ch);\n\n\tif (early_serial_base != 0)\n\t\tserial_putchar(ch);\n}\n\nvoid __section(\".inittext\") puts(const char *str)\n{\n\twhile (*str)\n\t\tputchar(*str++);\n}\n\n \n\nstatic u8 gettime(void)\n{\n\tstruct biosregs ireg, oreg;\n\n\tinitregs(&ireg);\n\tireg.ah = 0x02;\n\tintcall(0x1a, &ireg, &oreg);\n\n\treturn oreg.dh;\n}\n\n \nint getchar(void)\n{\n\tstruct biosregs ireg, oreg;\n\n\tinitregs(&ireg);\n\t \n\tintcall(0x16, &ireg, &oreg);\n\n\treturn oreg.al;\n}\n\nstatic int kbd_pending(void)\n{\n\tstruct biosregs ireg, oreg;\n\n\tinitregs(&ireg);\n\tireg.ah = 0x01;\n\tintcall(0x16, &ireg, &oreg);\n\n\treturn !(oreg.eflags & X86_EFLAGS_ZF);\n}\n\nvoid kbd_flush(void)\n{\n\tfor (;;) {\n\t\tif (!kbd_pending())\n\t\t\tbreak;\n\t\tgetchar();\n\t}\n}\n\nint getchar_timeout(void)\n{\n\tint cnt = 30;\n\tint t0, t1;\n\n\tt0 = gettime();\n\n\twhile (cnt) {\n\t\tif (kbd_pending())\n\t\t\treturn getchar();\n\n\t\tt1 = gettime();\n\t\tif (t0 != t1) {\n\t\t\tcnt--;\n\t\t\tt0 = t1;\n\t\t}\n\t}\n\n\treturn 0;\t\t \n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}