{
  "module_name": "acpi.c",
  "hash_id": "cd84753eb944173e5fafb5c74beb061ee808f44e35cfc2432496752d3cda2bf4",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/compressed/acpi.c",
  "human_readable_source": "\n#define BOOT_CTYPE_H\n#include \"misc.h\"\n#include \"error.h\"\n#include \"../string.h\"\n#include \"efi.h\"\n\n#include <linux/numa.h>\n\n \n#define MAX_ACPI_ARG_LENGTH 10\n\n \nstruct mem_vector immovable_mem[MAX_NUMNODES*2];\n\nstatic acpi_physical_address\n__efi_get_rsdp_addr(unsigned long cfg_tbl_pa, unsigned int cfg_tbl_len)\n{\n#ifdef CONFIG_EFI\n\tunsigned long rsdp_addr;\n\tint ret;\n\n\t \n\trsdp_addr = efi_find_vendor_table(boot_params, cfg_tbl_pa, cfg_tbl_len,\n\t\t\t\t\t  ACPI_20_TABLE_GUID);\n\tif (rsdp_addr)\n\t\treturn (acpi_physical_address)rsdp_addr;\n\n\t \n\trsdp_addr = efi_find_vendor_table(boot_params, cfg_tbl_pa, cfg_tbl_len,\n\t\t\t\t\t  ACPI_TABLE_GUID);\n\tif (rsdp_addr)\n\t\treturn (acpi_physical_address)rsdp_addr;\n\n\tdebug_putstr(\"Error getting RSDP address.\\n\");\n#endif\n\treturn 0;\n}\n\nstatic acpi_physical_address efi_get_rsdp_addr(void)\n{\n#ifdef CONFIG_EFI\n\tunsigned long cfg_tbl_pa = 0;\n\tunsigned int cfg_tbl_len;\n\tunsigned long systab_pa;\n\tunsigned int nr_tables;\n\tenum efi_type et;\n\tint ret;\n\n\tet = efi_get_type(boot_params);\n\tif (et == EFI_TYPE_NONE)\n\t\treturn 0;\n\n\tsystab_pa = efi_get_system_table(boot_params);\n\tif (!systab_pa)\n\t\terror(\"EFI support advertised, but unable to locate system table.\");\n\n\tret = efi_get_conf_table(boot_params, &cfg_tbl_pa, &cfg_tbl_len);\n\tif (ret || !cfg_tbl_pa)\n\t\terror(\"EFI config table not found.\");\n\n\treturn __efi_get_rsdp_addr(cfg_tbl_pa, cfg_tbl_len);\n#else\n\treturn 0;\n#endif\n}\n\nstatic u8 compute_checksum(u8 *buffer, u32 length)\n{\n\tu8 *end = buffer + length;\n\tu8 sum = 0;\n\n\twhile (buffer < end)\n\t\tsum += *(buffer++);\n\n\treturn sum;\n}\n\n \nstatic u8 *scan_mem_for_rsdp(u8 *start, u32 length)\n{\n\tstruct acpi_table_rsdp *rsdp;\n\tu8 *address, *end;\n\n\tend = start + length;\n\n\t \n\tfor (address = start; address < end; address += ACPI_RSDP_SCAN_STEP) {\n\t\t \n\t\trsdp = (struct acpi_table_rsdp *)address;\n\n\t\t \n\t\tif (!ACPI_VALIDATE_RSDP_SIG(rsdp->signature))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (compute_checksum((u8 *)rsdp, ACPI_RSDP_CHECKSUM_LENGTH))\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((rsdp->revision >= 2) &&\n\t\t    (compute_checksum((u8 *)rsdp, ACPI_RSDP_XCHECKSUM_LENGTH)))\n\t\t\tcontinue;\n\n\t\t \n\t\treturn address;\n\t}\n\treturn NULL;\n}\n\n \nstatic acpi_physical_address bios_get_rsdp_addr(void)\n{\n\tunsigned long address;\n\tu8 *rsdp;\n\n\t \n\taddress = *(u16 *)ACPI_EBDA_PTR_LOCATION;\n\taddress <<= 4;\n\n\t \n\tif (address > 0x400) {\n\t\trsdp = scan_mem_for_rsdp((u8 *)address, ACPI_EBDA_WINDOW_SIZE);\n\t\tif (rsdp)\n\t\t\treturn (acpi_physical_address)(unsigned long)rsdp;\n\t}\n\n\t \n\trsdp = scan_mem_for_rsdp((u8 *) ACPI_HI_RSDP_WINDOW_BASE,\n\t\t\t\t\tACPI_HI_RSDP_WINDOW_SIZE);\n\tif (rsdp)\n\t\treturn (acpi_physical_address)(unsigned long)rsdp;\n\n\treturn 0;\n}\n\n \nacpi_physical_address get_rsdp_addr(void)\n{\n\tacpi_physical_address pa;\n\n\tpa = boot_params->acpi_rsdp_addr;\n\n\tif (!pa)\n\t\tpa = efi_get_rsdp_addr();\n\n\tif (!pa)\n\t\tpa = bios_get_rsdp_addr();\n\n\treturn pa;\n}\n\n#if defined(CONFIG_RANDOMIZE_BASE) && defined(CONFIG_MEMORY_HOTREMOVE)\n \n#define MAX_ADDR_LEN 19\n\nstatic unsigned long get_cmdline_acpi_rsdp(void)\n{\n\tunsigned long addr = 0;\n\n#ifdef CONFIG_KEXEC\n\tchar val[MAX_ADDR_LEN] = { };\n\tint ret;\n\n\tret = cmdline_find_option(\"acpi_rsdp\", val, MAX_ADDR_LEN);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tif (boot_kstrtoul(val, 16, &addr))\n\t\treturn 0;\n#endif\n\treturn addr;\n}\n\n \nstatic unsigned long get_acpi_srat_table(void)\n{\n\tunsigned long root_table, acpi_table;\n\tstruct acpi_table_header *header;\n\tstruct acpi_table_rsdp *rsdp;\n\tu32 num_entries, size, len;\n\tchar arg[10];\n\tu8 *entry;\n\n\t \n\trsdp = (struct acpi_table_rsdp *)get_cmdline_acpi_rsdp();\n\tif (!rsdp)\n\t\trsdp = (struct acpi_table_rsdp *)(long)\n\t\t\tboot_params->acpi_rsdp_addr;\n\n\tif (!rsdp)\n\t\treturn 0;\n\n\t \n\tif (!(cmdline_find_option(\"acpi\", arg, sizeof(arg)) == 4 &&\n\t    !strncmp(arg, \"rsdt\", 4)) &&\n\t    rsdp->xsdt_physical_address &&\n\t    rsdp->revision > 1) {\n\t\troot_table = rsdp->xsdt_physical_address;\n\t\tsize = ACPI_XSDT_ENTRY_SIZE;\n\t} else {\n\t\troot_table = rsdp->rsdt_physical_address;\n\t\tsize = ACPI_RSDT_ENTRY_SIZE;\n\t}\n\n\tif (!root_table)\n\t\treturn 0;\n\n\theader = (struct acpi_table_header *)root_table;\n\tlen = header->length;\n\tif (len < sizeof(struct acpi_table_header) + size)\n\t\treturn 0;\n\n\tnum_entries = (len - sizeof(struct acpi_table_header)) / size;\n\tentry = (u8 *)(root_table + sizeof(struct acpi_table_header));\n\n\twhile (num_entries--) {\n\t\tif (size == ACPI_RSDT_ENTRY_SIZE)\n\t\t\tacpi_table = *(u32 *)entry;\n\t\telse\n\t\t\tacpi_table = *(u64 *)entry;\n\n\t\tif (acpi_table) {\n\t\t\theader = (struct acpi_table_header *)acpi_table;\n\n\t\t\tif (ACPI_COMPARE_NAMESEG(header->signature, ACPI_SIG_SRAT))\n\t\t\t\treturn acpi_table;\n\t\t}\n\t\tentry += size;\n\t}\n\treturn 0;\n}\n\n \nint count_immovable_mem_regions(void)\n{\n\tunsigned long table_addr, table_end, table;\n\tstruct acpi_subtable_header *sub_table;\n\tstruct acpi_table_header *table_header;\n\tchar arg[MAX_ACPI_ARG_LENGTH];\n\tint num = 0;\n\n\tif (cmdline_find_option(\"acpi\", arg, sizeof(arg)) == 3 &&\n\t    !strncmp(arg, \"off\", 3))\n\t\treturn 0;\n\n\ttable_addr = get_acpi_srat_table();\n\tif (!table_addr)\n\t\treturn 0;\n\n\ttable_header = (struct acpi_table_header *)table_addr;\n\ttable_end = table_addr + table_header->length;\n\ttable = table_addr + sizeof(struct acpi_table_srat);\n\n\twhile (table + sizeof(struct acpi_subtable_header) < table_end) {\n\n\t\tsub_table = (struct acpi_subtable_header *)table;\n\t\tif (!sub_table->length) {\n\t\t\tdebug_putstr(\"Invalid zero length SRAT subtable.\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (sub_table->type == ACPI_SRAT_TYPE_MEMORY_AFFINITY) {\n\t\t\tstruct acpi_srat_mem_affinity *ma;\n\n\t\t\tma = (struct acpi_srat_mem_affinity *)sub_table;\n\t\t\tif (!(ma->flags & ACPI_SRAT_MEM_HOT_PLUGGABLE) && ma->length) {\n\t\t\t\timmovable_mem[num].start = ma->base_address;\n\t\t\t\timmovable_mem[num].size = ma->length;\n\t\t\t\tnum++;\n\t\t\t}\n\n\t\t\tif (num >= MAX_NUMNODES*2) {\n\t\t\t\tdebug_putstr(\"Too many immovable memory regions, aborting.\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\ttable += sub_table->length;\n\t}\n\treturn num;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}