{
  "module_name": "misc.h",
  "hash_id": "e8385de343a4b6f9117c13afe55d7662edbeb3ae0b7ea38e6d2754d67661e4fc",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/compressed/misc.h",
  "human_readable_source": " \n#ifndef BOOT_COMPRESSED_MISC_H\n#define BOOT_COMPRESSED_MISC_H\n\n \n#undef CONFIG_PARAVIRT\n#undef CONFIG_PARAVIRT_XXL\n#undef CONFIG_PARAVIRT_SPINLOCKS\n#undef CONFIG_KASAN\n#undef CONFIG_KASAN_GENERIC\n\n#define __NO_FORTIFY\n\n \n#define USE_EARLY_PGTABLE_L5\n\n \n#define __pa(x)  ((unsigned long)(x))\n#define __va(x)  ((void *)((unsigned long)(x)))\n\n#include <linux/linkage.h>\n#include <linux/screen_info.h>\n#include <linux/elf.h>\n#include <asm/page.h>\n#include <asm/boot.h>\n#include <asm/bootparam.h>\n#include <asm/desc_defs.h>\n\n#include \"tdx.h\"\n\n#define BOOT_CTYPE_H\n#include <linux/acpi.h>\n\n#define BOOT_BOOT_H\n#include \"../ctype.h\"\n#include \"../io.h\"\n\n#include \"efi.h\"\n\n#ifdef CONFIG_X86_64\n#define memptr long\n#else\n#define memptr unsigned\n#endif\n\n \nextern char _head[], _end[];\n\n \nextern memptr free_mem_ptr;\nextern memptr free_mem_end_ptr;\nvoid *malloc(int size);\nvoid free(void *where);\nextern struct boot_params *boot_params;\nvoid __putstr(const char *s);\nvoid __puthex(unsigned long value);\n#define error_putstr(__x)  __putstr(__x)\n#define error_puthex(__x)  __puthex(__x)\n\n#ifdef CONFIG_X86_VERBOSE_BOOTUP\n\n#define debug_putstr(__x)  __putstr(__x)\n#define debug_puthex(__x)  __puthex(__x)\n#define debug_putaddr(__x) { \\\n\t\tdebug_putstr(#__x \": 0x\"); \\\n\t\tdebug_puthex((unsigned long)(__x)); \\\n\t\tdebug_putstr(\"\\n\"); \\\n\t}\n\n#else\n\nstatic inline void debug_putstr(const char *s)\n{ }\nstatic inline void debug_puthex(unsigned long value)\n{ }\n#define debug_putaddr(x)  \n\n#endif\n\n \nint cmdline_find_option(const char *option, char *buffer, int bufsize);\nint cmdline_find_option_bool(const char *option);\n\nstruct mem_vector {\n\tu64 start;\n\tu64 size;\n};\n\n#ifdef CONFIG_RANDOMIZE_BASE\n \nvoid choose_random_location(unsigned long input,\n\t\t\t    unsigned long input_size,\n\t\t\t    unsigned long *output,\n\t\t\t    unsigned long output_size,\n\t\t\t    unsigned long *virt_addr);\n#else\nstatic inline void choose_random_location(unsigned long input,\n\t\t\t\t\t  unsigned long input_size,\n\t\t\t\t\t  unsigned long *output,\n\t\t\t\t\t  unsigned long output_size,\n\t\t\t\t\t  unsigned long *virt_addr)\n{\n}\n#endif\n\n \nbool has_cpuflag(int flag);\n\n#ifdef CONFIG_X86_64\nextern int set_page_decrypted(unsigned long address);\nextern int set_page_encrypted(unsigned long address);\nextern int set_page_non_present(unsigned long address);\nextern unsigned char _pgtable[];\n#endif\n\n#ifdef CONFIG_EARLY_PRINTK\n \nextern int early_serial_base;\nvoid console_init(void);\n#else\nstatic const int early_serial_base;\nstatic inline void console_init(void)\n{ }\n#endif\n\n#ifdef CONFIG_AMD_MEM_ENCRYPT\nvoid sev_enable(struct boot_params *bp);\nvoid snp_check_features(void);\nvoid sev_es_shutdown_ghcb(void);\nextern bool sev_es_check_ghcb_fault(unsigned long address);\nvoid snp_set_page_private(unsigned long paddr);\nvoid snp_set_page_shared(unsigned long paddr);\nvoid sev_prep_identity_maps(unsigned long top_level_pgt);\n#else\nstatic inline void sev_enable(struct boot_params *bp)\n{\n\t \n\tif (bp)\n\t\tbp->cc_blob_address = 0;\n}\nstatic inline void snp_check_features(void) { }\nstatic inline void sev_es_shutdown_ghcb(void) { }\nstatic inline bool sev_es_check_ghcb_fault(unsigned long address)\n{\n\treturn false;\n}\nstatic inline void snp_set_page_private(unsigned long paddr) { }\nstatic inline void snp_set_page_shared(unsigned long paddr) { }\nstatic inline void sev_prep_identity_maps(unsigned long top_level_pgt) { }\n#endif\n\n \n#ifdef CONFIG_ACPI\nacpi_physical_address get_rsdp_addr(void);\n#else\nstatic inline acpi_physical_address get_rsdp_addr(void) { return 0; }\n#endif\n\n#if defined(CONFIG_RANDOMIZE_BASE) && defined(CONFIG_MEMORY_HOTREMOVE) && defined(CONFIG_ACPI)\nextern struct mem_vector immovable_mem[MAX_NUMNODES*2];\nint count_immovable_mem_regions(void);\n#else\nstatic inline int count_immovable_mem_regions(void) { return 0; }\n#endif\n\n \nextern unsigned int __pgtable_l5_enabled, pgdir_shift, ptrs_per_p4d;\nextern void kernel_add_identity_map(unsigned long start, unsigned long end);\n\n \nextern pteval_t __default_kernel_pte_mask;\n\n \nextern gate_desc boot_idt[BOOT_IDT_ENTRIES];\nextern struct desc_ptr boot_idt_desc;\n\n#ifdef CONFIG_X86_64\nvoid cleanup_exception_handling(void);\n#else\nstatic inline void cleanup_exception_handling(void) { }\n#endif\n\n \nvoid boot_page_fault(void);\nvoid boot_stage1_vc(void);\nvoid boot_stage2_vc(void);\n\nunsigned long sev_verify_cbit(unsigned long cr3);\n\nenum efi_type {\n\tEFI_TYPE_64,\n\tEFI_TYPE_32,\n\tEFI_TYPE_NONE,\n};\n\n#ifdef CONFIG_EFI\n \nenum efi_type efi_get_type(struct boot_params *bp);\nunsigned long efi_get_system_table(struct boot_params *bp);\nint efi_get_conf_table(struct boot_params *bp, unsigned long *cfg_tbl_pa,\n\t\t       unsigned int *cfg_tbl_len);\nunsigned long efi_find_vendor_table(struct boot_params *bp,\n\t\t\t\t    unsigned long cfg_tbl_pa,\n\t\t\t\t    unsigned int cfg_tbl_len,\n\t\t\t\t    efi_guid_t guid);\n#else\nstatic inline enum efi_type efi_get_type(struct boot_params *bp)\n{\n\treturn EFI_TYPE_NONE;\n}\n\nstatic inline unsigned long efi_get_system_table(struct boot_params *bp)\n{\n\treturn 0;\n}\n\nstatic inline int efi_get_conf_table(struct boot_params *bp,\n\t\t\t\t     unsigned long *cfg_tbl_pa,\n\t\t\t\t     unsigned int *cfg_tbl_len)\n{\n\treturn -ENOENT;\n}\n\nstatic inline unsigned long efi_find_vendor_table(struct boot_params *bp,\n\t\t\t\t\t\t  unsigned long cfg_tbl_pa,\n\t\t\t\t\t\t  unsigned int cfg_tbl_len,\n\t\t\t\t\t\t  efi_guid_t guid)\n{\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_UNACCEPTED_MEMORY\nbool init_unaccepted_memory(void);\n#else\nstatic inline bool init_unaccepted_memory(void) { return false; }\n#endif\n\n \nextern struct efi_unaccepted_memory *unaccepted_table;\nvoid accept_memory(phys_addr_t start, phys_addr_t end);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}