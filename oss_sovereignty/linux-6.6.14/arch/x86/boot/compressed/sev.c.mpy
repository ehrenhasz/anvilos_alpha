{
  "module_name": "sev.c",
  "hash_id": "5a256cc3bd4bc938e4781d64bf82ea366aba9b5d316f3a0eccf10a4ac04e4fc6",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/compressed/sev.c",
  "human_readable_source": "\n \n\n \n#include \"misc.h\"\n\n#include <asm/pgtable_types.h>\n#include <asm/sev.h>\n#include <asm/trapnr.h>\n#include <asm/trap_pf.h>\n#include <asm/msr-index.h>\n#include <asm/fpu/xcr.h>\n#include <asm/ptrace.h>\n#include <asm/svm.h>\n#include <asm/cpuid.h>\n\n#include \"error.h\"\n#include \"../msr.h\"\n\nstruct ghcb boot_ghcb_page __aligned(PAGE_SIZE);\nstruct ghcb *boot_ghcb;\n\n \nstatic bool insn_has_rep_prefix(struct insn *insn)\n{\n\tinsn_byte_t p;\n\tint i;\n\n\tinsn_get_prefixes(insn);\n\n\tfor_each_insn_prefix(insn, i, p) {\n\t\tif (p == 0xf2 || p == 0xf3)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\treturn 0UL;\n}\n\nstatic inline u64 sev_es_rd_ghcb_msr(void)\n{\n\tstruct msr m;\n\n\tboot_rdmsr(MSR_AMD64_SEV_ES_GHCB, &m);\n\n\treturn m.q;\n}\n\nstatic inline void sev_es_wr_ghcb_msr(u64 val)\n{\n\tstruct msr m;\n\n\tm.q = val;\n\tboot_wrmsr(MSR_AMD64_SEV_ES_GHCB, &m);\n}\n\nstatic enum es_result vc_decode_insn(struct es_em_ctxt *ctxt)\n{\n\tchar buffer[MAX_INSN_SIZE];\n\tint ret;\n\n\tmemcpy(buffer, (unsigned char *)ctxt->regs->ip, MAX_INSN_SIZE);\n\n\tret = insn_decode(&ctxt->insn, buffer, MAX_INSN_SIZE, INSN_MODE_64);\n\tif (ret < 0)\n\t\treturn ES_DECODE_FAILED;\n\n\treturn ES_OK;\n}\n\nstatic enum es_result vc_write_mem(struct es_em_ctxt *ctxt,\n\t\t\t\t   void *dst, char *buf, size_t size)\n{\n\tmemcpy(dst, buf, size);\n\n\treturn ES_OK;\n}\n\nstatic enum es_result vc_read_mem(struct es_em_ctxt *ctxt,\n\t\t\t\t  void *src, char *buf, size_t size)\n{\n\tmemcpy(buf, src, size);\n\n\treturn ES_OK;\n}\n\nstatic enum es_result vc_ioio_check(struct es_em_ctxt *ctxt, u16 port, size_t size)\n{\n\treturn ES_OK;\n}\n\nstatic bool fault_in_kernel_space(unsigned long address)\n{\n\treturn false;\n}\n\n#undef __init\n#define __init\n\n#define __BOOT_COMPRESSED\n\n \n#include \"../../lib/inat.c\"\n#include \"../../lib/insn.c\"\n\n \n#include \"../../kernel/sev-shared.c\"\n\nbool sev_snp_enabled(void)\n{\n\treturn sev_status & MSR_AMD64_SEV_SNP_ENABLED;\n}\n\nstatic void __page_state_change(unsigned long paddr, enum psc_op op)\n{\n\tu64 val;\n\n\tif (!sev_snp_enabled())\n\t\treturn;\n\n\t \n\tif (op == SNP_PAGE_STATE_SHARED && pvalidate(paddr, RMP_PG_SIZE_4K, 0))\n\t\tsev_es_terminate(SEV_TERM_SET_LINUX, GHCB_TERM_PVALIDATE);\n\n\t \n\tsev_es_wr_ghcb_msr(GHCB_MSR_PSC_REQ_GFN(paddr >> PAGE_SHIFT, op));\n\tVMGEXIT();\n\n\t \n\tval = sev_es_rd_ghcb_msr();\n\tif ((GHCB_RESP_CODE(val) != GHCB_MSR_PSC_RESP) || GHCB_MSR_PSC_RESP_VAL(val))\n\t\tsev_es_terminate(SEV_TERM_SET_LINUX, GHCB_TERM_PSC);\n\n\t \n\tif (op == SNP_PAGE_STATE_PRIVATE && pvalidate(paddr, RMP_PG_SIZE_4K, 1))\n\t\tsev_es_terminate(SEV_TERM_SET_LINUX, GHCB_TERM_PVALIDATE);\n}\n\nvoid snp_set_page_private(unsigned long paddr)\n{\n\t__page_state_change(paddr, SNP_PAGE_STATE_PRIVATE);\n}\n\nvoid snp_set_page_shared(unsigned long paddr)\n{\n\t__page_state_change(paddr, SNP_PAGE_STATE_SHARED);\n}\n\nstatic bool early_setup_ghcb(void)\n{\n\tif (set_page_decrypted((unsigned long)&boot_ghcb_page))\n\t\treturn false;\n\n\t \n\tmemset(&boot_ghcb_page, 0, sizeof(boot_ghcb_page));\n\n\tboot_ghcb = &boot_ghcb_page;\n\n\t \n\tinat_init_tables();\n\n\t \n\tif (sev_snp_enabled())\n\t\tsnp_register_ghcb_early(__pa(&boot_ghcb_page));\n\n\treturn true;\n}\n\nstatic phys_addr_t __snp_accept_memory(struct snp_psc_desc *desc,\n\t\t\t\t       phys_addr_t pa, phys_addr_t pa_end)\n{\n\tstruct psc_hdr *hdr;\n\tstruct psc_entry *e;\n\tunsigned int i;\n\n\thdr = &desc->hdr;\n\tmemset(hdr, 0, sizeof(*hdr));\n\n\te = desc->entries;\n\n\ti = 0;\n\twhile (pa < pa_end && i < VMGEXIT_PSC_MAX_ENTRY) {\n\t\thdr->end_entry = i;\n\n\t\te->gfn = pa >> PAGE_SHIFT;\n\t\te->operation = SNP_PAGE_STATE_PRIVATE;\n\t\tif (IS_ALIGNED(pa, PMD_SIZE) && (pa_end - pa) >= PMD_SIZE) {\n\t\t\te->pagesize = RMP_PG_SIZE_2M;\n\t\t\tpa += PMD_SIZE;\n\t\t} else {\n\t\t\te->pagesize = RMP_PG_SIZE_4K;\n\t\t\tpa += PAGE_SIZE;\n\t\t}\n\n\t\te++;\n\t\ti++;\n\t}\n\n\tif (vmgexit_psc(boot_ghcb, desc))\n\t\tsev_es_terminate(SEV_TERM_SET_LINUX, GHCB_TERM_PSC);\n\n\tpvalidate_pages(desc);\n\n\treturn pa;\n}\n\nvoid snp_accept_memory(phys_addr_t start, phys_addr_t end)\n{\n\tstruct snp_psc_desc desc = {};\n\tunsigned int i;\n\tphys_addr_t pa;\n\n\tif (!boot_ghcb && !early_setup_ghcb())\n\t\tsev_es_terminate(SEV_TERM_SET_LINUX, GHCB_TERM_PSC);\n\n\tpa = start;\n\twhile (pa < end)\n\t\tpa = __snp_accept_memory(&desc, pa, end);\n}\n\nvoid sev_es_shutdown_ghcb(void)\n{\n\tif (!boot_ghcb)\n\t\treturn;\n\n\tif (!sev_es_check_cpu_features())\n\t\terror(\"SEV-ES CPU Features missing.\");\n\n\t \n\tif (set_page_encrypted((unsigned long)&boot_ghcb_page))\n\t\terror(\"Can't map GHCB page encrypted\");\n\n\t \n\tif (set_page_non_present((unsigned long)&boot_ghcb_page))\n\t\terror(\"Can't unmap GHCB page\");\n}\n\nstatic void __noreturn sev_es_ghcb_terminate(struct ghcb *ghcb, unsigned int set,\n\t\t\t\t\t     unsigned int reason, u64 exit_info_2)\n{\n\tu64 exit_info_1 = SVM_VMGEXIT_TERM_REASON(set, reason);\n\n\tvc_ghcb_invalidate(ghcb);\n\tghcb_set_sw_exit_code(ghcb, SVM_VMGEXIT_TERM_REQUEST);\n\tghcb_set_sw_exit_info_1(ghcb, exit_info_1);\n\tghcb_set_sw_exit_info_2(ghcb, exit_info_2);\n\n\tsev_es_wr_ghcb_msr(__pa(ghcb));\n\tVMGEXIT();\n\n\twhile (true)\n\t\tasm volatile(\"hlt\\n\" : : : \"memory\");\n}\n\nbool sev_es_check_ghcb_fault(unsigned long address)\n{\n\t \n\treturn ((address & PAGE_MASK) == (unsigned long)&boot_ghcb_page);\n}\n\nvoid do_boot_stage2_vc(struct pt_regs *regs, unsigned long exit_code)\n{\n\tstruct es_em_ctxt ctxt;\n\tenum es_result result;\n\n\tif (!boot_ghcb && !early_setup_ghcb())\n\t\tsev_es_terminate(SEV_TERM_SET_GEN, GHCB_SEV_ES_GEN_REQ);\n\n\tvc_ghcb_invalidate(boot_ghcb);\n\tresult = vc_init_em_ctxt(&ctxt, regs, exit_code);\n\tif (result != ES_OK)\n\t\tgoto finish;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_RDTSC:\n\tcase SVM_EXIT_RDTSCP:\n\t\tresult = vc_handle_rdtsc(boot_ghcb, &ctxt, exit_code);\n\t\tbreak;\n\tcase SVM_EXIT_IOIO:\n\t\tresult = vc_handle_ioio(boot_ghcb, &ctxt);\n\t\tbreak;\n\tcase SVM_EXIT_CPUID:\n\t\tresult = vc_handle_cpuid(boot_ghcb, &ctxt);\n\t\tbreak;\n\tdefault:\n\t\tresult = ES_UNSUPPORTED;\n\t\tbreak;\n\t}\n\nfinish:\n\tif (result == ES_OK)\n\t\tvc_finish_insn(&ctxt);\n\telse if (result != ES_RETRY)\n\t\tsev_es_terminate(SEV_TERM_SET_GEN, GHCB_SEV_ES_GEN_REQ);\n}\n\nstatic void enforce_vmpl0(void)\n{\n\tu64 attrs;\n\tint err;\n\n\t \n\tattrs = 1;\n\tif (rmpadjust((unsigned long)&boot_ghcb_page, RMP_PG_SIZE_4K, attrs))\n\t\tsev_es_terminate(SEV_TERM_SET_LINUX, GHCB_TERM_NOT_VMPL0);\n}\n\n \n#define SNP_FEATURES_IMPL_REQ\t(MSR_AMD64_SNP_VTOM |\t\t\t\\\n\t\t\t\t MSR_AMD64_SNP_REFLECT_VC |\t\t\\\n\t\t\t\t MSR_AMD64_SNP_RESTRICTED_INJ |\t\t\\\n\t\t\t\t MSR_AMD64_SNP_ALT_INJ |\t\t\\\n\t\t\t\t MSR_AMD64_SNP_DEBUG_SWAP |\t\t\\\n\t\t\t\t MSR_AMD64_SNP_VMPL_SSS |\t\t\\\n\t\t\t\t MSR_AMD64_SNP_SECURE_TSC |\t\t\\\n\t\t\t\t MSR_AMD64_SNP_VMGEXIT_PARAM |\t\t\\\n\t\t\t\t MSR_AMD64_SNP_VMSA_REG_PROTECTION |\t\\\n\t\t\t\t MSR_AMD64_SNP_RESERVED_BIT13 |\t\t\\\n\t\t\t\t MSR_AMD64_SNP_RESERVED_BIT15 |\t\t\\\n\t\t\t\t MSR_AMD64_SNP_RESERVED_MASK)\n\n \n#define SNP_FEATURES_PRESENT\tMSR_AMD64_SNP_DEBUG_SWAP\n\nu64 snp_get_unsupported_features(u64 status)\n{\n\tif (!(status & MSR_AMD64_SEV_SNP_ENABLED))\n\t\treturn 0;\n\n\treturn status & SNP_FEATURES_IMPL_REQ & ~SNP_FEATURES_PRESENT;\n}\n\nvoid snp_check_features(void)\n{\n\tu64 unsupported;\n\n\t \n\tunsupported = snp_get_unsupported_features(sev_status);\n\tif (unsupported) {\n\t\tif (ghcb_version < 2 || (!boot_ghcb && !early_setup_ghcb()))\n\t\t\tsev_es_terminate(SEV_TERM_SET_GEN, GHCB_SNP_UNSUPPORTED);\n\n\t\tsev_es_ghcb_terminate(boot_ghcb, SEV_TERM_SET_GEN,\n\t\t\t\t      GHCB_SNP_UNSUPPORTED, unsupported);\n\t}\n}\n\n \nstatic int sev_check_cpu_support(void)\n{\n\tunsigned int eax, ebx, ecx, edx;\n\n\t \n\teax = 0x80000000;\n\tecx = 0;\n\tnative_cpuid(&eax, &ebx, &ecx, &edx);\n\tif (eax < 0x8000001f)\n\t\treturn -ENODEV;\n\n\t \n\teax = 0x8000001f;\n\tecx = 0;\n\tnative_cpuid(&eax, &ebx, &ecx, &edx);\n\t \n\tif (!(eax & BIT(1)))\n\t\treturn -ENODEV;\n\n\treturn ebx & 0x3f;\n}\n\nvoid sev_enable(struct boot_params *bp)\n{\n\tstruct msr m;\n\tint bitpos;\n\tbool snp;\n\n\t \n\tif (bp)\n\t\tbp->cc_blob_address = 0;\n\n\t \n\n\tif (sev_check_cpu_support() < 0)\n\t\treturn;\n\n\t \n\tsnp = snp_init(bp);\n\n\t \n\n\tbitpos = sev_check_cpu_support();\n\tif (bitpos < 0) {\n\t\tif (snp)\n\t\t\terror(\"SEV-SNP support indicated by CC blob, but not CPUID.\");\n\t\treturn;\n\t}\n\n\t \n\tboot_rdmsr(MSR_AMD64_SEV, &m);\n\tsev_status = m.q;\n\tif (!(sev_status & MSR_AMD64_SEV_ENABLED))\n\t\treturn;\n\n\t \n\tif (sev_status & MSR_AMD64_SEV_ES_ENABLED) {\n\t\tif (!sev_es_negotiate_protocol())\n\t\t\tsev_es_terminate(SEV_TERM_SET_GEN, GHCB_SEV_ES_PROT_UNSUPPORTED);\n\t}\n\n\t \n\tif (sev_status & MSR_AMD64_SEV_SNP_ENABLED) {\n\t\tif (!(get_hv_features() & GHCB_HV_FT_SNP))\n\t\t\tsev_es_terminate(SEV_TERM_SET_GEN, GHCB_SNP_UNSUPPORTED);\n\n\t\tenforce_vmpl0();\n\t}\n\n\tif (snp && !(sev_status & MSR_AMD64_SEV_SNP_ENABLED))\n\t\terror(\"SEV-SNP supported indicated by CC blob, but not SEV status MSR.\");\n\n\tsme_me_mask = BIT_ULL(bitpos);\n}\n\n \nu64 sev_get_status(void)\n{\n\tstruct msr m;\n\n\tif (sev_check_cpu_support() < 0)\n\t\treturn 0;\n\n\tboot_rdmsr(MSR_AMD64_SEV, &m);\n\treturn m.q;\n}\n\n \nstatic struct cc_blob_sev_info *find_cc_blob_efi(struct boot_params *bp)\n{\n\tunsigned long cfg_table_pa;\n\tunsigned int cfg_table_len;\n\tint ret;\n\n\tret = efi_get_conf_table(bp, &cfg_table_pa, &cfg_table_len);\n\tif (ret)\n\t\treturn NULL;\n\n\treturn (struct cc_blob_sev_info *)efi_find_vendor_table(bp, cfg_table_pa,\n\t\t\t\t\t\t\t\tcfg_table_len,\n\t\t\t\t\t\t\t\tEFI_CC_BLOB_GUID);\n}\n\n \nstatic struct cc_blob_sev_info *find_cc_blob(struct boot_params *bp)\n{\n\tstruct cc_blob_sev_info *cc_info;\n\n\tcc_info = find_cc_blob_efi(bp);\n\tif (cc_info)\n\t\tgoto found_cc_info;\n\n\tcc_info = find_cc_blob_setup_data(bp);\n\tif (!cc_info)\n\t\treturn NULL;\n\nfound_cc_info:\n\tif (cc_info->magic != CC_BLOB_SEV_HDR_MAGIC)\n\t\tsev_es_terminate(SEV_TERM_SET_GEN, GHCB_SNP_UNSUPPORTED);\n\n\treturn cc_info;\n}\n\n \nbool snp_init(struct boot_params *bp)\n{\n\tstruct cc_blob_sev_info *cc_info;\n\n\tif (!bp)\n\t\treturn false;\n\n\tcc_info = find_cc_blob(bp);\n\tif (!cc_info)\n\t\treturn false;\n\n\t \n\tsetup_cpuid_table(cc_info);\n\n\t \n\tbp->cc_blob_address = (u32)(unsigned long)cc_info;\n\n\treturn true;\n}\n\nvoid sev_prep_identity_maps(unsigned long top_level_pgt)\n{\n\t \n\tif (sev_snp_enabled()) {\n\t\tunsigned long cc_info_pa = boot_params->cc_blob_address;\n\t\tstruct cc_blob_sev_info *cc_info;\n\n\t\tkernel_add_identity_map(cc_info_pa, cc_info_pa + sizeof(*cc_info));\n\n\t\tcc_info = (struct cc_blob_sev_info *)cc_info_pa;\n\t\tkernel_add_identity_map(cc_info->cpuid_phys, cc_info->cpuid_phys + cc_info->cpuid_len);\n\t}\n\n\tsev_verify_cbit(top_level_pgt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}