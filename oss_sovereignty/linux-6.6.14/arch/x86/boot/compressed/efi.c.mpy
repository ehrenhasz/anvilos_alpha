{
  "module_name": "efi.c",
  "hash_id": "3a81c2cde0c58d82a38fd8826f3ac852e844de35146989af003030d851ce81c6",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/compressed/efi.c",
  "human_readable_source": "\n \n\n#include \"misc.h\"\n\n \nenum efi_type efi_get_type(struct boot_params *bp)\n{\n\tstruct efi_info *ei;\n\tenum efi_type et;\n\tconst char *sig;\n\n\tei = &bp->efi_info;\n\tsig = (char *)&ei->efi_loader_signature;\n\n\tif (!strncmp(sig, EFI64_LOADER_SIGNATURE, 4)) {\n\t\tet = EFI_TYPE_64;\n\t} else if (!strncmp(sig, EFI32_LOADER_SIGNATURE, 4)) {\n\t\tet = EFI_TYPE_32;\n\t} else {\n\t\tdebug_putstr(\"No EFI environment detected.\\n\");\n\t\tet = EFI_TYPE_NONE;\n\t}\n\n#ifndef CONFIG_X86_64\n\t \n\tif (ei->efi_systab_hi || ei->efi_memmap_hi) {\n\t\tdebug_putstr(\"EFI system table is located above 4GB and cannot be accessed.\\n\");\n\t\tet = EFI_TYPE_NONE;\n\t}\n#endif\n\n\treturn et;\n}\n\n \nunsigned long efi_get_system_table(struct boot_params *bp)\n{\n\tunsigned long sys_tbl_pa;\n\tstruct efi_info *ei;\n\tenum efi_type et;\n\n\t \n\tei = &bp->efi_info;\n#ifdef CONFIG_X86_64\n\tsys_tbl_pa = ei->efi_systab | ((__u64)ei->efi_systab_hi << 32);\n#else\n\tsys_tbl_pa = ei->efi_systab;\n#endif\n\tif (!sys_tbl_pa) {\n\t\tdebug_putstr(\"EFI system table not found.\");\n\t\treturn 0;\n\t}\n\n\treturn sys_tbl_pa;\n}\n\n \nstatic struct efi_setup_data *get_kexec_setup_data(struct boot_params *bp,\n\t\t\t\t\t\t   enum efi_type et)\n{\n#ifdef CONFIG_X86_64\n\tstruct efi_setup_data *esd = NULL;\n\tstruct setup_data *data;\n\tu64 pa_data;\n\n\tpa_data = bp->hdr.setup_data;\n\twhile (pa_data) {\n\t\tdata = (struct setup_data *)pa_data;\n\t\tif (data->type == SETUP_EFI) {\n\t\t\tesd = (struct efi_setup_data *)(pa_data + sizeof(struct setup_data));\n\t\t\tbreak;\n\t\t}\n\n\t\tpa_data = data->next;\n\t}\n\n\t \n\tif (esd && !esd->tables) {\n\t\tdebug_putstr(\"kexec EFI environment missing valid configuration table.\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn esd;\n#endif\n\treturn NULL;\n}\n\n \nint efi_get_conf_table(struct boot_params *bp, unsigned long *cfg_tbl_pa,\n\t\t       unsigned int *cfg_tbl_len)\n{\n\tunsigned long sys_tbl_pa;\n\tenum efi_type et;\n\tint ret;\n\n\tif (!cfg_tbl_pa || !cfg_tbl_len)\n\t\treturn -EINVAL;\n\n\tsys_tbl_pa = efi_get_system_table(bp);\n\tif (!sys_tbl_pa)\n\t\treturn -EINVAL;\n\n\t \n\tet = efi_get_type(bp);\n\tif (et == EFI_TYPE_64) {\n\t\tefi_system_table_64_t *stbl = (efi_system_table_64_t *)sys_tbl_pa;\n\t\tstruct efi_setup_data *esd;\n\n\t\t \n\t\tesd = get_kexec_setup_data(bp, et);\n\n\t\t*cfg_tbl_pa = esd ? esd->tables : stbl->tables;\n\t\t*cfg_tbl_len = stbl->nr_tables;\n\t} else if (et == EFI_TYPE_32) {\n\t\tefi_system_table_32_t *stbl = (efi_system_table_32_t *)sys_tbl_pa;\n\n\t\t*cfg_tbl_pa = stbl->tables;\n\t\t*cfg_tbl_len = stbl->nr_tables;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int get_vendor_table(void *cfg_tbl, unsigned int idx,\n\t\t\t    unsigned long *vendor_tbl_pa,\n\t\t\t    efi_guid_t *vendor_tbl_guid,\n\t\t\t    enum efi_type et)\n{\n\tif (et == EFI_TYPE_64) {\n\t\tefi_config_table_64_t *tbl_entry = (efi_config_table_64_t *)cfg_tbl + idx;\n\n\t\tif (!IS_ENABLED(CONFIG_X86_64) && tbl_entry->table >> 32) {\n\t\t\tdebug_putstr(\"Error: EFI config table entry located above 4GB.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*vendor_tbl_pa = tbl_entry->table;\n\t\t*vendor_tbl_guid = tbl_entry->guid;\n\n\t} else if (et == EFI_TYPE_32) {\n\t\tefi_config_table_32_t *tbl_entry = (efi_config_table_32_t *)cfg_tbl + idx;\n\n\t\t*vendor_tbl_pa = tbl_entry->table;\n\t\t*vendor_tbl_guid = tbl_entry->guid;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nunsigned long efi_find_vendor_table(struct boot_params *bp,\n\t\t\t\t    unsigned long cfg_tbl_pa,\n\t\t\t\t    unsigned int cfg_tbl_len,\n\t\t\t\t    efi_guid_t guid)\n{\n\tenum efi_type et;\n\tunsigned int i;\n\n\tet = efi_get_type(bp);\n\tif (et == EFI_TYPE_NONE)\n\t\treturn 0;\n\n\tfor (i = 0; i < cfg_tbl_len; i++) {\n\t\tunsigned long vendor_tbl_pa;\n\t\tefi_guid_t vendor_tbl_guid;\n\t\tint ret;\n\n\t\tret = get_vendor_table((void *)cfg_tbl_pa, i,\n\t\t\t\t       &vendor_tbl_pa,\n\t\t\t\t       &vendor_tbl_guid, et);\n\t\tif (ret)\n\t\t\treturn 0;\n\n\t\tif (!efi_guidcmp(guid, vendor_tbl_guid))\n\t\t\treturn vendor_tbl_pa;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}