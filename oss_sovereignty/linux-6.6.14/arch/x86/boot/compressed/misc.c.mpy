{
  "module_name": "misc.c",
  "hash_id": "3dee2b22b2b4115eb5335d307a44e2314d2c2a5a39b533cf1e0c15554b0f8a64",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/compressed/misc.c",
  "human_readable_source": "\n \n\n#include \"misc.h\"\n#include \"error.h\"\n#include \"pgtable.h\"\n#include \"../string.h\"\n#include \"../voffset.h\"\n#include <asm/bootparam_utils.h>\n\n \n\n \n#define STATIC\t\tstatic\n \n#define MALLOC_VISIBLE\n#include <linux/decompress/mm.h>\n\n \n#define memzero(s, n)\tmemset((s), 0, (n))\n#ifndef memmove\n#define memmove\t\tmemmove\n \nvoid *memmove(void *dest, const void *src, size_t n);\n#endif\n\n \nstruct boot_params *boot_params;\n\nstruct port_io_ops pio_ops;\n\nmemptr free_mem_ptr;\nmemptr free_mem_end_ptr;\n\nstatic char *vidmem;\nstatic int vidport;\n\n \nstatic int lines __section(\".data\");\nstatic int cols __section(\".data\");\n\n#ifdef CONFIG_KERNEL_GZIP\n#include \"../../../../lib/decompress_inflate.c\"\n#endif\n\n#ifdef CONFIG_KERNEL_BZIP2\n#include \"../../../../lib/decompress_bunzip2.c\"\n#endif\n\n#ifdef CONFIG_KERNEL_LZMA\n#include \"../../../../lib/decompress_unlzma.c\"\n#endif\n\n#ifdef CONFIG_KERNEL_XZ\n#include \"../../../../lib/decompress_unxz.c\"\n#endif\n\n#ifdef CONFIG_KERNEL_LZO\n#include \"../../../../lib/decompress_unlzo.c\"\n#endif\n\n#ifdef CONFIG_KERNEL_LZ4\n#include \"../../../../lib/decompress_unlz4.c\"\n#endif\n\n#ifdef CONFIG_KERNEL_ZSTD\n#include \"../../../../lib/decompress_unzstd.c\"\n#endif\n \n\nstatic void scroll(void)\n{\n\tint i;\n\n\tmemmove(vidmem, vidmem + cols * 2, (lines - 1) * cols * 2);\n\tfor (i = (lines - 1) * cols * 2; i < lines * cols * 2; i += 2)\n\t\tvidmem[i] = ' ';\n}\n\n#define XMTRDY          0x20\n\n#define TXR             0        \n#define LSR             5        \nstatic void serial_putchar(int ch)\n{\n\tunsigned timeout = 0xffff;\n\n\twhile ((inb(early_serial_base + LSR) & XMTRDY) == 0 && --timeout)\n\t\tcpu_relax();\n\n\toutb(ch, early_serial_base + TXR);\n}\n\nvoid __putstr(const char *s)\n{\n\tint x, y, pos;\n\tchar c;\n\n\tif (early_serial_base) {\n\t\tconst char *str = s;\n\t\twhile (*str) {\n\t\t\tif (*str == '\\n')\n\t\t\t\tserial_putchar('\\r');\n\t\t\tserial_putchar(*str++);\n\t\t}\n\t}\n\n\tif (lines == 0 || cols == 0)\n\t\treturn;\n\n\tx = boot_params->screen_info.orig_x;\n\ty = boot_params->screen_info.orig_y;\n\n\twhile ((c = *s++) != '\\0') {\n\t\tif (c == '\\n') {\n\t\t\tx = 0;\n\t\t\tif (++y >= lines) {\n\t\t\t\tscroll();\n\t\t\t\ty--;\n\t\t\t}\n\t\t} else {\n\t\t\tvidmem[(x + cols * y) * 2] = c;\n\t\t\tif (++x >= cols) {\n\t\t\t\tx = 0;\n\t\t\t\tif (++y >= lines) {\n\t\t\t\t\tscroll();\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tboot_params->screen_info.orig_x = x;\n\tboot_params->screen_info.orig_y = y;\n\n\tpos = (x + cols * y) * 2;\t \n\toutb(14, vidport);\n\toutb(0xff & (pos >> 9), vidport+1);\n\toutb(15, vidport);\n\toutb(0xff & (pos >> 1), vidport+1);\n}\n\nvoid __puthex(unsigned long value)\n{\n\tchar alpha[2] = \"0\";\n\tint bits;\n\n\tfor (bits = sizeof(value) * 8 - 4; bits >= 0; bits -= 4) {\n\t\tunsigned long digit = (value >> bits) & 0xf;\n\n\t\tif (digit < 0xA)\n\t\t\talpha[0] = '0' + digit;\n\t\telse\n\t\t\talpha[0] = 'a' + (digit - 0xA);\n\n\t\t__putstr(alpha);\n\t}\n}\n\n#ifdef CONFIG_X86_NEED_RELOCS\nstatic void handle_relocations(void *output, unsigned long output_len,\n\t\t\t       unsigned long virt_addr)\n{\n\tint *reloc;\n\tunsigned long delta, map, ptr;\n\tunsigned long min_addr = (unsigned long)output;\n\tunsigned long max_addr = min_addr + (VO___bss_start - VO__text);\n\n\t \n\tdelta = min_addr - LOAD_PHYSICAL_ADDR;\n\n\t \n\tmap = delta - __START_KERNEL_map;\n\n\t \n\tif (IS_ENABLED(CONFIG_X86_64))\n\t\tdelta = virt_addr - LOAD_PHYSICAL_ADDR;\n\n\tif (!delta) {\n\t\tdebug_putstr(\"No relocation needed... \");\n\t\treturn;\n\t}\n\tdebug_putstr(\"Performing relocations... \");\n\n\t \n\tfor (reloc = output + output_len - sizeof(*reloc); *reloc; reloc--) {\n\t\tlong extended = *reloc;\n\t\textended += map;\n\n\t\tptr = (unsigned long)extended;\n\t\tif (ptr < min_addr || ptr > max_addr)\n\t\t\terror(\"32-bit relocation outside of kernel!\\n\");\n\n\t\t*(uint32_t *)ptr += delta;\n\t}\n#ifdef CONFIG_X86_64\n\twhile (*--reloc) {\n\t\tlong extended = *reloc;\n\t\textended += map;\n\n\t\tptr = (unsigned long)extended;\n\t\tif (ptr < min_addr || ptr > max_addr)\n\t\t\terror(\"inverse 32-bit relocation outside of kernel!\\n\");\n\n\t\t*(int32_t *)ptr -= delta;\n\t}\n\tfor (reloc--; *reloc; reloc--) {\n\t\tlong extended = *reloc;\n\t\textended += map;\n\n\t\tptr = (unsigned long)extended;\n\t\tif (ptr < min_addr || ptr > max_addr)\n\t\t\terror(\"64-bit relocation outside of kernel!\\n\");\n\n\t\t*(uint64_t *)ptr += delta;\n\t}\n#endif\n}\n#else\nstatic inline void handle_relocations(void *output, unsigned long output_len,\n\t\t\t\t      unsigned long virt_addr)\n{ }\n#endif\n\nstatic size_t parse_elf(void *output)\n{\n#ifdef CONFIG_X86_64\n\tElf64_Ehdr ehdr;\n\tElf64_Phdr *phdrs, *phdr;\n#else\n\tElf32_Ehdr ehdr;\n\tElf32_Phdr *phdrs, *phdr;\n#endif\n\tvoid *dest;\n\tint i;\n\n\tmemcpy(&ehdr, output, sizeof(ehdr));\n\tif (ehdr.e_ident[EI_MAG0] != ELFMAG0 ||\n\t   ehdr.e_ident[EI_MAG1] != ELFMAG1 ||\n\t   ehdr.e_ident[EI_MAG2] != ELFMAG2 ||\n\t   ehdr.e_ident[EI_MAG3] != ELFMAG3)\n\t\terror(\"Kernel is not a valid ELF file\");\n\n\tdebug_putstr(\"Parsing ELF... \");\n\n\tphdrs = malloc(sizeof(*phdrs) * ehdr.e_phnum);\n\tif (!phdrs)\n\t\terror(\"Failed to allocate space for phdrs\");\n\n\tmemcpy(phdrs, output + ehdr.e_phoff, sizeof(*phdrs) * ehdr.e_phnum);\n\n\tfor (i = 0; i < ehdr.e_phnum; i++) {\n\t\tphdr = &phdrs[i];\n\n\t\tswitch (phdr->p_type) {\n\t\tcase PT_LOAD:\n#ifdef CONFIG_X86_64\n\t\t\tif ((phdr->p_align % 0x200000) != 0)\n\t\t\t\terror(\"Alignment of LOAD segment isn't multiple of 2MB\");\n#endif\n#ifdef CONFIG_RELOCATABLE\n\t\t\tdest = output;\n\t\t\tdest += (phdr->p_paddr - LOAD_PHYSICAL_ADDR);\n#else\n\t\t\tdest = (void *)(phdr->p_paddr);\n#endif\n\t\t\tmemmove(dest, output + phdr->p_offset, phdr->p_filesz);\n\t\t\tbreak;\n\t\tdefault:   break;\n\t\t}\n\t}\n\n\tfree(phdrs);\n\n\treturn ehdr.e_entry - LOAD_PHYSICAL_ADDR;\n}\n\nconst unsigned long kernel_total_size = VO__end - VO__text;\n\nstatic u8 boot_heap[BOOT_HEAP_SIZE] __aligned(4);\n\nextern unsigned char input_data[];\nextern unsigned int input_len, output_len;\n\nunsigned long decompress_kernel(unsigned char *outbuf, unsigned long virt_addr,\n\t\t\t\tvoid (*error)(char *x))\n{\n\tunsigned long entry;\n\n\tif (!free_mem_ptr) {\n\t\tfree_mem_ptr     = (unsigned long)boot_heap;\n\t\tfree_mem_end_ptr = (unsigned long)boot_heap + sizeof(boot_heap);\n\t}\n\n\tif (__decompress(input_data, input_len, NULL, NULL, outbuf, output_len,\n\t\t\t NULL, error) < 0)\n\t\treturn ULONG_MAX;\n\n\tentry = parse_elf(outbuf);\n\thandle_relocations(outbuf, output_len, virt_addr);\n\n\treturn entry;\n}\n\n \nasmlinkage __visible void *extract_kernel(void *rmode, unsigned char *output)\n{\n\tunsigned long virt_addr = LOAD_PHYSICAL_ADDR;\n\tmemptr heap = (memptr)boot_heap;\n\tunsigned long needed_size;\n\tsize_t entry_offset;\n\n\t \n\tboot_params = rmode;\n\n\t \n\tboot_params->hdr.loadflags &= ~KASLR_FLAG;\n\n\tsanitize_boot_params(boot_params);\n\n\tif (boot_params->screen_info.orig_video_mode == 7) {\n\t\tvidmem = (char *) 0xb0000;\n\t\tvidport = 0x3b4;\n\t} else {\n\t\tvidmem = (char *) 0xb8000;\n\t\tvidport = 0x3d4;\n\t}\n\n\tlines = boot_params->screen_info.orig_video_lines;\n\tcols = boot_params->screen_info.orig_video_cols;\n\n\tinit_default_io_ops();\n\n\t \n\tearly_tdx_detect();\n\n\tconsole_init();\n\n\t \n\tboot_params->acpi_rsdp_addr = get_rsdp_addr();\n\n\tdebug_putstr(\"early console in extract_kernel\\n\");\n\n\tfree_mem_ptr     = heap;\t \n\tfree_mem_end_ptr = heap + BOOT_HEAP_SIZE;\n\n\t \n\tneeded_size = max_t(unsigned long, output_len, kernel_total_size);\n#ifdef CONFIG_X86_64\n\tneeded_size = ALIGN(needed_size, MIN_KERNEL_ALIGN);\n#endif\n\n\t \n\tdebug_putaddr(input_data);\n\tdebug_putaddr(input_len);\n\tdebug_putaddr(output);\n\tdebug_putaddr(output_len);\n\tdebug_putaddr(kernel_total_size);\n\tdebug_putaddr(needed_size);\n\n#ifdef CONFIG_X86_64\n\t \n\tdebug_putaddr(trampoline_32bit);\n#endif\n\n\tchoose_random_location((unsigned long)input_data, input_len,\n\t\t\t\t(unsigned long *)&output,\n\t\t\t\tneeded_size,\n\t\t\t\t&virt_addr);\n\n\t \n\tif ((unsigned long)output & (MIN_KERNEL_ALIGN - 1))\n\t\terror(\"Destination physical address inappropriately aligned\");\n\tif (virt_addr & (MIN_KERNEL_ALIGN - 1))\n\t\terror(\"Destination virtual address inappropriately aligned\");\n#ifdef CONFIG_X86_64\n\tif (heap > 0x3fffffffffffUL)\n\t\terror(\"Destination address too large\");\n\tif (virt_addr + needed_size > KERNEL_IMAGE_SIZE)\n\t\terror(\"Destination virtual address is beyond the kernel mapping area\");\n#else\n\tif (heap > ((-__PAGE_OFFSET-(128<<20)-1) & 0x7fffffff))\n\t\terror(\"Destination address too large\");\n#endif\n#ifndef CONFIG_RELOCATABLE\n\tif (virt_addr != LOAD_PHYSICAL_ADDR)\n\t\terror(\"Destination virtual address changed when not relocatable\");\n#endif\n\n\tdebug_putstr(\"\\nDecompressing Linux... \");\n\n\tif (init_unaccepted_memory()) {\n\t\tdebug_putstr(\"Accepting memory... \");\n\t\taccept_memory(__pa(output), __pa(output) + needed_size);\n\t}\n\n\tentry_offset = decompress_kernel(output, virt_addr, error);\n\n\tdebug_putstr(\"done.\\nBooting the kernel (entry_offset: 0x\");\n\tdebug_puthex(entry_offset);\n\tdebug_putstr(\").\\n\");\n\n\t \n\tcleanup_exception_handling();\n\n\treturn output + entry_offset;\n}\n\nvoid fortify_panic(const char *name)\n{\n\terror(\"detected buffer overflow\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}