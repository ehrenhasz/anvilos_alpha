{
  "module_name": "ident_map_64.c",
  "hash_id": "4ef7a4e10b1d777cadb0a033b528631cc4da3b4067ca315ada5808d21db67afc",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/compressed/ident_map_64.c",
  "human_readable_source": "\n \n\n \n#undef CONFIG_PAGE_TABLE_ISOLATION\n\n#include \"error.h\"\n#include \"misc.h\"\n\n \n#include <linux/pgtable.h>\n#include <asm/cmpxchg.h>\n#include <asm/trap_pf.h>\n#include <asm/trapnr.h>\n#include <asm/init.h>\n \n#undef __PAGE_OFFSET\n#define __PAGE_OFFSET __PAGE_OFFSET_BASE\n#include \"../../mm/ident_map.c\"\n\n#define _SETUP\n#include <asm/setup.h>\t \n#undef _SETUP\n\nextern unsigned long get_cmd_line_ptr(void);\n\n \npteval_t __default_kernel_pte_mask __read_mostly = ~0;\n\n \nstruct alloc_pgt_data {\n\tunsigned char *pgt_buf;\n\tunsigned long pgt_buf_size;\n\tunsigned long pgt_buf_offset;\n};\n\n \nstatic void *alloc_pgt_page(void *context)\n{\n\tstruct alloc_pgt_data *pages = (struct alloc_pgt_data *)context;\n\tunsigned char *entry;\n\n\t \n\tif (pages->pgt_buf_offset >= pages->pgt_buf_size) {\n\t\tdebug_putstr(\"out of pgt_buf in \" __FILE__ \"!?\\n\");\n\t\tdebug_putaddr(pages->pgt_buf_offset);\n\t\tdebug_putaddr(pages->pgt_buf_size);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (pages->pgt_buf_offset == BOOT_PGT_SIZE_WARN) {\n\t\tdebug_putstr(\"pgt_buf running low in \" __FILE__ \"\\n\");\n\t\tdebug_putstr(\"Need to raise BOOT_PGT_SIZE?\\n\");\n\t\tdebug_putaddr(pages->pgt_buf_offset);\n\t\tdebug_putaddr(pages->pgt_buf_size);\n\t}\n\n\tentry = pages->pgt_buf + pages->pgt_buf_offset;\n\tpages->pgt_buf_offset += PAGE_SIZE;\n\n\treturn entry;\n}\n\n \nstatic struct alloc_pgt_data pgt_data;\n\n \nstatic unsigned long top_level_pgt;\n\nphys_addr_t physical_mask = (1ULL << __PHYSICAL_MASK_SHIFT) - 1;\n\n \nstatic struct x86_mapping_info mapping_info;\n\n \nvoid kernel_add_identity_map(unsigned long start, unsigned long end)\n{\n\tint ret;\n\n\t \n\tstart = round_down(start, PMD_SIZE);\n\tend = round_up(end, PMD_SIZE);\n\tif (start >= end)\n\t\treturn;\n\n\t \n\tret = kernel_ident_mapping_init(&mapping_info, (pgd_t *)top_level_pgt, start, end);\n\tif (ret)\n\t\terror(\"Error: kernel_ident_mapping_init() failed\\n\");\n}\n\n \nvoid initialize_identity_maps(void *rmode)\n{\n\tunsigned long cmdline;\n\tstruct setup_data *sd;\n\n\t \n\tphysical_mask &= ~sme_me_mask;\n\n\t \n\tmapping_info.alloc_pgt_page = alloc_pgt_page;\n\tmapping_info.context = &pgt_data;\n\tmapping_info.page_flag = __PAGE_KERNEL_LARGE_EXEC | sme_me_mask;\n\tmapping_info.kernpg_flag = _KERNPG_TABLE;\n\n\t \n\tpgt_data.pgt_buf_offset = 0;\n\n\t \n\ttop_level_pgt = read_cr3_pa();\n\tif (p4d_offset((pgd_t *)top_level_pgt, 0) == (p4d_t *)_pgtable) {\n\t\tpgt_data.pgt_buf = _pgtable + BOOT_INIT_PGT_SIZE;\n\t\tpgt_data.pgt_buf_size = BOOT_PGT_SIZE - BOOT_INIT_PGT_SIZE;\n\t\tmemset(pgt_data.pgt_buf, 0, pgt_data.pgt_buf_size);\n\t} else {\n\t\tpgt_data.pgt_buf = _pgtable;\n\t\tpgt_data.pgt_buf_size = BOOT_PGT_SIZE;\n\t\tmemset(pgt_data.pgt_buf, 0, pgt_data.pgt_buf_size);\n\t\ttop_level_pgt = (unsigned long)alloc_pgt_page(&pgt_data);\n\t}\n\n\t \n\tkernel_add_identity_map((unsigned long)_head, (unsigned long)_end);\n\tboot_params = rmode;\n\tkernel_add_identity_map((unsigned long)boot_params, (unsigned long)(boot_params + 1));\n\tcmdline = get_cmd_line_ptr();\n\tkernel_add_identity_map(cmdline, cmdline + COMMAND_LINE_SIZE);\n\n\t \n\tsd = (struct setup_data *)boot_params->hdr.setup_data;\n\twhile (sd) {\n\t\tunsigned long sd_addr = (unsigned long)sd;\n\n\t\tkernel_add_identity_map(sd_addr, sd_addr + sizeof(*sd) + sd->len);\n\t\tsd = (struct setup_data *)sd->next;\n\t}\n\n\tsev_prep_identity_maps(top_level_pgt);\n\n\t \n\twrite_cr3(top_level_pgt);\n\n\t \n\tsnp_check_features();\n}\n\nstatic pte_t *split_large_pmd(struct x86_mapping_info *info,\n\t\t\t      pmd_t *pmdp, unsigned long __address)\n{\n\tunsigned long page_flags;\n\tunsigned long address;\n\tpte_t *pte;\n\tpmd_t pmd;\n\tint i;\n\n\tpte = (pte_t *)info->alloc_pgt_page(info->context);\n\tif (!pte)\n\t\treturn NULL;\n\n\taddress     = __address & PMD_MASK;\n\t \n\tpage_flags  = info->page_flag & ~_PAGE_PSE;\n\n\t \n\tfor (i = 0; i < PTRS_PER_PMD; i++) {\n\t\tset_pte(&pte[i], __pte(address | page_flags));\n\t\taddress += PAGE_SIZE;\n\t}\n\n\t \n\tpmd = __pmd((unsigned long)pte | info->kernpg_flag);\n\tset_pmd(pmdp, pmd);\n\t \n\twrite_cr3(top_level_pgt);\n\n\treturn pte + pte_index(__address);\n}\n\nstatic void clflush_page(unsigned long address)\n{\n\tunsigned int flush_size;\n\tchar *cl, *start, *end;\n\n\t \n\tflush_size = 64;\n\tstart      = (char *)(address & PAGE_MASK);\n\tend        = start + PAGE_SIZE;\n\n\t \n\tasm volatile(\"mfence\" : : : \"memory\");\n\n\tfor (cl = start; cl != end; cl += flush_size)\n\t\tclflush(cl);\n}\n\nstatic int set_clr_page_flags(struct x86_mapping_info *info,\n\t\t\t      unsigned long address,\n\t\t\t      pteval_t set, pteval_t clr)\n{\n\tpgd_t *pgdp = (pgd_t *)top_level_pgt;\n\tp4d_t *p4dp;\n\tpud_t *pudp;\n\tpmd_t *pmdp;\n\tpte_t *ptep, pte;\n\n\t \n\tasm volatile(\"mov %[address], %%r9\"\n\t\t     :: [address] \"g\" (*(unsigned long *)address)\n\t\t     : \"r9\", \"memory\");\n\n\t \n\tp4dp = p4d_offset(pgdp, address);\n\tpudp = pud_offset(p4dp, address);\n\tpmdp = pmd_offset(pudp, address);\n\n\tif (pmd_large(*pmdp))\n\t\tptep = split_large_pmd(info, pmdp, address);\n\telse\n\t\tptep = pte_offset_kernel(pmdp, address);\n\n\tif (!ptep)\n\t\treturn -ENOMEM;\n\n\t \n\tif ((set | clr) & _PAGE_ENC) {\n\t\tclflush_page(address);\n\n\t\t \n\t\tif (clr)\n\t\t\tsnp_set_page_shared(__pa(address & PAGE_MASK));\n\t}\n\n\t \n\tpte = *ptep;\n\tpte = pte_set_flags(pte, set);\n\tpte = pte_clear_flags(pte, clr);\n\tset_pte(ptep, pte);\n\n\t \n\tif (set & _PAGE_ENC)\n\t\tsnp_set_page_private(__pa(address & PAGE_MASK));\n\n\t \n\twrite_cr3(top_level_pgt);\n\n\treturn 0;\n}\n\nint set_page_decrypted(unsigned long address)\n{\n\treturn set_clr_page_flags(&mapping_info, address, 0, _PAGE_ENC);\n}\n\nint set_page_encrypted(unsigned long address)\n{\n\treturn set_clr_page_flags(&mapping_info, address, _PAGE_ENC, 0);\n}\n\nint set_page_non_present(unsigned long address)\n{\n\treturn set_clr_page_flags(&mapping_info, address, 0, _PAGE_PRESENT);\n}\n\nstatic void do_pf_error(const char *msg, unsigned long error_code,\n\t\t\tunsigned long address, unsigned long ip)\n{\n\terror_putstr(msg);\n\n\terror_putstr(\"\\nError Code: \");\n\terror_puthex(error_code);\n\terror_putstr(\"\\nCR2: 0x\");\n\terror_puthex(address);\n\terror_putstr(\"\\nRIP relative to _head: 0x\");\n\terror_puthex(ip - (unsigned long)_head);\n\terror_putstr(\"\\n\");\n\n\terror(\"Stopping.\\n\");\n}\n\nvoid do_boot_page_fault(struct pt_regs *regs, unsigned long error_code)\n{\n\tunsigned long address = native_read_cr2();\n\tunsigned long end;\n\tbool ghcb_fault;\n\n\tghcb_fault = sev_es_check_ghcb_fault(address);\n\n\taddress   &= PMD_MASK;\n\tend        = address + PMD_SIZE;\n\n\t \n\tif (error_code & (X86_PF_PROT | X86_PF_USER | X86_PF_RSVD))\n\t\tdo_pf_error(\"Unexpected page-fault:\", error_code, address, regs->ip);\n\telse if (ghcb_fault)\n\t\tdo_pf_error(\"Page-fault on GHCB page:\", error_code, address, regs->ip);\n\n\t \n\tkernel_add_identity_map(address, end);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}