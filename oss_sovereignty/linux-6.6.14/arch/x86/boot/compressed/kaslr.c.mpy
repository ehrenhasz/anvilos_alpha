{
  "module_name": "kaslr.c",
  "hash_id": "26fb45ff8251c3223d817c146818b2fdfbd6d3b77d86d13a6ee41e3793a4dd5e",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/compressed/kaslr.c",
  "human_readable_source": "\n \n\n \n#define BOOT_CTYPE_H\n\n#include \"misc.h\"\n#include \"error.h\"\n#include \"../string.h\"\n#include \"efi.h\"\n\n#include <generated/compile.h>\n#include <linux/module.h>\n#include <linux/uts.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <generated/utsversion.h>\n#include <generated/utsrelease.h>\n\n#define _SETUP\n#include <asm/setup.h>\t \n#undef _SETUP\n\nextern unsigned long get_cmd_line_ptr(void);\n\n \nstatic const char build_str[] = UTS_RELEASE \" (\" LINUX_COMPILE_BY \"@\"\n\t\tLINUX_COMPILE_HOST \") (\" LINUX_COMPILER \") \" UTS_VERSION;\n\nstatic unsigned long rotate_xor(unsigned long hash, const void *area,\n\t\t\t\tsize_t size)\n{\n\tsize_t i;\n\tunsigned long *ptr = (unsigned long *)area;\n\n\tfor (i = 0; i < size / sizeof(hash); i++) {\n\t\t \n\t\thash = (hash << ((sizeof(hash) * 8) - 7)) | (hash >> 7);\n\t\thash ^= ptr[i];\n\t}\n\n\treturn hash;\n}\n\n \nstatic unsigned long get_boot_seed(void)\n{\n\tunsigned long hash = 0;\n\n\thash = rotate_xor(hash, build_str, sizeof(build_str));\n\thash = rotate_xor(hash, boot_params, sizeof(*boot_params));\n\n\treturn hash;\n}\n\n#define KASLR_COMPRESSED_BOOT\n#include \"../../lib/kaslr.c\"\n\n\n \n#define MAX_MEMMAP_REGIONS\t4\n\nstatic bool memmap_too_large;\n\n\n \nstatic u64 mem_limit;\n\n \nstatic int num_immovable_mem;\n\nenum mem_avoid_index {\n\tMEM_AVOID_ZO_RANGE = 0,\n\tMEM_AVOID_INITRD,\n\tMEM_AVOID_CMDLINE,\n\tMEM_AVOID_BOOTPARAMS,\n\tMEM_AVOID_MEMMAP_BEGIN,\n\tMEM_AVOID_MEMMAP_END = MEM_AVOID_MEMMAP_BEGIN + MAX_MEMMAP_REGIONS - 1,\n\tMEM_AVOID_MAX,\n};\n\nstatic struct mem_vector mem_avoid[MEM_AVOID_MAX];\n\nstatic bool mem_overlaps(struct mem_vector *one, struct mem_vector *two)\n{\n\t \n\tif (one->start + one->size <= two->start)\n\t\treturn false;\n\t \n\tif (one->start >= two->start + two->size)\n\t\treturn false;\n\treturn true;\n}\n\nchar *skip_spaces(const char *str)\n{\n\twhile (isspace(*str))\n\t\t++str;\n\treturn (char *)str;\n}\n#include \"../../../../lib/ctype.c\"\n#include \"../../../../lib/cmdline.c\"\n\nenum parse_mode {\n\tPARSE_MEMMAP,\n\tPARSE_EFI,\n};\n\nstatic int\nparse_memmap(char *p, u64 *start, u64 *size, enum parse_mode mode)\n{\n\tchar *oldp;\n\n\tif (!p)\n\t\treturn -EINVAL;\n\n\t \n\tif (!strncmp(p, \"exactmap\", 8))\n\t\treturn -EINVAL;\n\n\toldp = p;\n\t*size = memparse(p, &p);\n\tif (p == oldp)\n\t\treturn -EINVAL;\n\n\tswitch (*p) {\n\tcase '#':\n\tcase '$':\n\tcase '!':\n\t\t*start = memparse(p + 1, &p);\n\t\treturn 0;\n\tcase '@':\n\t\tif (mode == PARSE_MEMMAP) {\n\t\t\t \n\t\t\t*size = 0;\n\t\t} else {\n\t\t\tu64 flags;\n\n\t\t\t \n\t\t\t*start = memparse(p + 1, &p);\n\t\t\tif (p && *p == ':') {\n\t\t\t\tp++;\n\t\t\t\tif (kstrtoull(p, 0, &flags) < 0)\n\t\t\t\t\t*size = 0;\n\t\t\t\telse if (flags & EFI_MEMORY_SP)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*size = 0;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\t*start = 0;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void mem_avoid_memmap(enum parse_mode mode, char *str)\n{\n\tstatic int i;\n\n\tif (i >= MAX_MEMMAP_REGIONS)\n\t\treturn;\n\n\twhile (str && (i < MAX_MEMMAP_REGIONS)) {\n\t\tint rc;\n\t\tu64 start, size;\n\t\tchar *k = strchr(str, ',');\n\n\t\tif (k)\n\t\t\t*k++ = 0;\n\n\t\trc = parse_memmap(str, &start, &size, mode);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\tstr = k;\n\n\t\tif (start == 0) {\n\t\t\t \n\t\t\tif (size > 0 && size < mem_limit)\n\t\t\t\tmem_limit = size;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tmem_avoid[MEM_AVOID_MEMMAP_BEGIN + i].start = start;\n\t\tmem_avoid[MEM_AVOID_MEMMAP_BEGIN + i].size = size;\n\t\ti++;\n\t}\n\n\t \n\tif ((i >= MAX_MEMMAP_REGIONS) && str)\n\t\tmemmap_too_large = true;\n}\n\n \nstatic unsigned long max_gb_huge_pages;\n\nstatic void parse_gb_huge_pages(char *param, char *val)\n{\n\tstatic bool gbpage_sz;\n\tchar *p;\n\n\tif (!strcmp(param, \"hugepagesz\")) {\n\t\tp = val;\n\t\tif (memparse(p, &p) != PUD_SIZE) {\n\t\t\tgbpage_sz = false;\n\t\t\treturn;\n\t\t}\n\n\t\tif (gbpage_sz)\n\t\t\twarn(\"Repeatedly set hugeTLB page size of 1G!\\n\");\n\t\tgbpage_sz = true;\n\t\treturn;\n\t}\n\n\tif (!strcmp(param, \"hugepages\") && gbpage_sz) {\n\t\tp = val;\n\t\tmax_gb_huge_pages = simple_strtoull(p, &p, 0);\n\t\treturn;\n\t}\n}\n\nstatic void handle_mem_options(void)\n{\n\tchar *args = (char *)get_cmd_line_ptr();\n\tsize_t len;\n\tchar *tmp_cmdline;\n\tchar *param, *val;\n\tu64 mem_size;\n\n\tif (!args)\n\t\treturn;\n\n\tlen = strnlen(args, COMMAND_LINE_SIZE-1);\n\ttmp_cmdline = malloc(len + 1);\n\tif (!tmp_cmdline)\n\t\terror(\"Failed to allocate space for tmp_cmdline\");\n\n\tmemcpy(tmp_cmdline, args, len);\n\ttmp_cmdline[len] = 0;\n\targs = tmp_cmdline;\n\n\t \n\targs = skip_spaces(args);\n\n\twhile (*args) {\n\t\targs = next_arg(args, &param, &val);\n\t\t \n\t\tif (!val && strcmp(param, \"--\") == 0)\n\t\t\tbreak;\n\n\t\tif (!strcmp(param, \"memmap\")) {\n\t\t\tmem_avoid_memmap(PARSE_MEMMAP, val);\n\t\t} else if (IS_ENABLED(CONFIG_X86_64) && strstr(param, \"hugepages\")) {\n\t\t\tparse_gb_huge_pages(param, val);\n\t\t} else if (!strcmp(param, \"mem\")) {\n\t\t\tchar *p = val;\n\n\t\t\tif (!strcmp(p, \"nopentium\"))\n\t\t\t\tcontinue;\n\t\t\tmem_size = memparse(p, &p);\n\t\t\tif (mem_size == 0)\n\t\t\t\tbreak;\n\n\t\t\tif (mem_size < mem_limit)\n\t\t\t\tmem_limit = mem_size;\n\t\t} else if (!strcmp(param, \"efi_fake_mem\")) {\n\t\t\tmem_avoid_memmap(PARSE_EFI, val);\n\t\t}\n\t}\n\n\tfree(tmp_cmdline);\n\treturn;\n}\n\n \nstatic void mem_avoid_init(unsigned long input, unsigned long input_size,\n\t\t\t   unsigned long output)\n{\n\tunsigned long init_size = boot_params->hdr.init_size;\n\tu64 initrd_start, initrd_size;\n\tunsigned long cmd_line, cmd_line_size;\n\n\t \n\tmem_avoid[MEM_AVOID_ZO_RANGE].start = input;\n\tmem_avoid[MEM_AVOID_ZO_RANGE].size = (output + init_size) - input;\n\n\t \n\tinitrd_start  = (u64)boot_params->ext_ramdisk_image << 32;\n\tinitrd_start |= boot_params->hdr.ramdisk_image;\n\tinitrd_size  = (u64)boot_params->ext_ramdisk_size << 32;\n\tinitrd_size |= boot_params->hdr.ramdisk_size;\n\tmem_avoid[MEM_AVOID_INITRD].start = initrd_start;\n\tmem_avoid[MEM_AVOID_INITRD].size = initrd_size;\n\t \n\n\t \n\tcmd_line = get_cmd_line_ptr();\n\t \n\tif (cmd_line) {\n\t\tcmd_line_size = strnlen((char *)cmd_line, COMMAND_LINE_SIZE-1) + 1;\n\t\tmem_avoid[MEM_AVOID_CMDLINE].start = cmd_line;\n\t\tmem_avoid[MEM_AVOID_CMDLINE].size = cmd_line_size;\n\t}\n\n\t \n\tmem_avoid[MEM_AVOID_BOOTPARAMS].start = (unsigned long)boot_params;\n\tmem_avoid[MEM_AVOID_BOOTPARAMS].size = sizeof(*boot_params);\n\n\t \n\n\t \n\thandle_mem_options();\n\n\t \n\tnum_immovable_mem = count_immovable_mem_regions();\n}\n\n \nstatic bool mem_avoid_overlap(struct mem_vector *img,\n\t\t\t      struct mem_vector *overlap)\n{\n\tint i;\n\tstruct setup_data *ptr;\n\tu64 earliest = img->start + img->size;\n\tbool is_overlapping = false;\n\n\tfor (i = 0; i < MEM_AVOID_MAX; i++) {\n\t\tif (mem_overlaps(img, &mem_avoid[i]) &&\n\t\t    mem_avoid[i].start < earliest) {\n\t\t\t*overlap = mem_avoid[i];\n\t\t\tearliest = overlap->start;\n\t\t\tis_overlapping = true;\n\t\t}\n\t}\n\n\t \n\tptr = (struct setup_data *)(unsigned long)boot_params->hdr.setup_data;\n\twhile (ptr) {\n\t\tstruct mem_vector avoid;\n\n\t\tavoid.start = (unsigned long)ptr;\n\t\tavoid.size = sizeof(*ptr) + ptr->len;\n\n\t\tif (mem_overlaps(img, &avoid) && (avoid.start < earliest)) {\n\t\t\t*overlap = avoid;\n\t\t\tearliest = overlap->start;\n\t\t\tis_overlapping = true;\n\t\t}\n\n\t\tif (ptr->type == SETUP_INDIRECT &&\n\t\t    ((struct setup_indirect *)ptr->data)->type != SETUP_INDIRECT) {\n\t\t\tavoid.start = ((struct setup_indirect *)ptr->data)->addr;\n\t\t\tavoid.size = ((struct setup_indirect *)ptr->data)->len;\n\n\t\t\tif (mem_overlaps(img, &avoid) && (avoid.start < earliest)) {\n\t\t\t\t*overlap = avoid;\n\t\t\t\tearliest = overlap->start;\n\t\t\t\tis_overlapping = true;\n\t\t\t}\n\t\t}\n\n\t\tptr = (struct setup_data *)(unsigned long)ptr->next;\n\t}\n\n\treturn is_overlapping;\n}\n\nstruct slot_area {\n\tu64 addr;\n\tunsigned long num;\n};\n\n#define MAX_SLOT_AREA 100\n\nstatic struct slot_area slot_areas[MAX_SLOT_AREA];\nstatic unsigned int slot_area_index;\nstatic unsigned long slot_max;\n\nstatic void store_slot_info(struct mem_vector *region, unsigned long image_size)\n{\n\tstruct slot_area slot_area;\n\n\tif (slot_area_index == MAX_SLOT_AREA)\n\t\treturn;\n\n\tslot_area.addr = region->start;\n\tslot_area.num = 1 + (region->size - image_size) / CONFIG_PHYSICAL_ALIGN;\n\n\tslot_areas[slot_area_index++] = slot_area;\n\tslot_max += slot_area.num;\n}\n\n \nstatic void\nprocess_gb_huge_pages(struct mem_vector *region, unsigned long image_size)\n{\n\tu64 pud_start, pud_end;\n\tunsigned long gb_huge_pages;\n\tstruct mem_vector tmp;\n\n\tif (!IS_ENABLED(CONFIG_X86_64) || !max_gb_huge_pages) {\n\t\tstore_slot_info(region, image_size);\n\t\treturn;\n\t}\n\n\t \n\tpud_start = ALIGN(region->start, PUD_SIZE);\n\tpud_end = ALIGN_DOWN(region->start + region->size, PUD_SIZE);\n\n\t \n\tif (pud_start >= pud_end) {\n\t\tstore_slot_info(region, image_size);\n\t\treturn;\n\t}\n\n\t \n\tif (pud_start >= region->start + image_size) {\n\t\ttmp.start = region->start;\n\t\ttmp.size = pud_start - region->start;\n\t\tstore_slot_info(&tmp, image_size);\n\t}\n\n\t \n\tgb_huge_pages = (pud_end - pud_start) >> PUD_SHIFT;\n\tif (gb_huge_pages > max_gb_huge_pages) {\n\t\tpud_end = pud_start + (max_gb_huge_pages << PUD_SHIFT);\n\t\tmax_gb_huge_pages = 0;\n\t} else {\n\t\tmax_gb_huge_pages -= gb_huge_pages;\n\t}\n\n\t \n\tif (region->start + region->size >= pud_end + image_size) {\n\t\ttmp.start = pud_end;\n\t\ttmp.size = region->start + region->size - pud_end;\n\t\tstore_slot_info(&tmp, image_size);\n\t}\n}\n\nstatic u64 slots_fetch_random(void)\n{\n\tunsigned long slot;\n\tunsigned int i;\n\n\t \n\tif (slot_max == 0)\n\t\treturn 0;\n\n\tslot = kaslr_get_random_long(\"Physical\") % slot_max;\n\n\tfor (i = 0; i < slot_area_index; i++) {\n\t\tif (slot >= slot_areas[i].num) {\n\t\t\tslot -= slot_areas[i].num;\n\t\t\tcontinue;\n\t\t}\n\t\treturn slot_areas[i].addr + ((u64)slot * CONFIG_PHYSICAL_ALIGN);\n\t}\n\n\tif (i == slot_area_index)\n\t\tdebug_putstr(\"slots_fetch_random() failed!?\\n\");\n\treturn 0;\n}\n\nstatic void __process_mem_region(struct mem_vector *entry,\n\t\t\t\t unsigned long minimum,\n\t\t\t\t unsigned long image_size)\n{\n\tstruct mem_vector region, overlap;\n\tu64 region_end;\n\n\t \n\tregion.start = max_t(u64, entry->start, minimum);\n\tregion_end = min(entry->start + entry->size, mem_limit);\n\n\t \n\twhile (slot_area_index < MAX_SLOT_AREA) {\n\t\t \n\t\tregion.start = ALIGN(region.start, CONFIG_PHYSICAL_ALIGN);\n\n\t\t \n\t\tif (region.start > region_end)\n\t\t\treturn;\n\n\t\t \n\t\tregion.size = region_end - region.start;\n\n\t\t \n\t\tif (region.size < image_size)\n\t\t\treturn;\n\n\t\t \n\t\tif (!mem_avoid_overlap(&region, &overlap)) {\n\t\t\tprocess_gb_huge_pages(&region, image_size);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (overlap.start >= region.start + image_size) {\n\t\t\tregion.size = overlap.start - region.start;\n\t\t\tprocess_gb_huge_pages(&region, image_size);\n\t\t}\n\n\t\t \n\t\tregion.start = overlap.start + overlap.size;\n\t}\n}\n\nstatic bool process_mem_region(struct mem_vector *region,\n\t\t\t       unsigned long minimum,\n\t\t\t       unsigned long image_size)\n{\n\tint i;\n\t \n\tif (!num_immovable_mem) {\n\t\t__process_mem_region(region, minimum, image_size);\n\n\t\tif (slot_area_index == MAX_SLOT_AREA) {\n\t\t\tdebug_putstr(\"Aborted e820/efi memmap scan (slot_areas full)!\\n\");\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n#if defined(CONFIG_MEMORY_HOTREMOVE) && defined(CONFIG_ACPI)\n\t \n\tfor (i = 0; i < num_immovable_mem; i++) {\n\t\tu64 start, end, entry_end, region_end;\n\t\tstruct mem_vector entry;\n\n\t\tif (!mem_overlaps(region, &immovable_mem[i]))\n\t\t\tcontinue;\n\n\t\tstart = immovable_mem[i].start;\n\t\tend = start + immovable_mem[i].size;\n\t\tregion_end = region->start + region->size;\n\n\t\tentry.start = clamp(region->start, start, end);\n\t\tentry_end = clamp(region_end, start, end);\n\t\tentry.size = entry_end - entry.start;\n\n\t\t__process_mem_region(&entry, minimum, image_size);\n\n\t\tif (slot_area_index == MAX_SLOT_AREA) {\n\t\t\tdebug_putstr(\"Aborted e820/efi memmap scan when walking immovable regions(slot_areas full)!\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n#endif\n\treturn false;\n}\n\n#ifdef CONFIG_EFI\n\n \nstatic inline bool memory_type_is_free(efi_memory_desc_t *md)\n{\n\tif (md->type == EFI_CONVENTIONAL_MEMORY)\n\t\treturn true;\n\n\tif (IS_ENABLED(CONFIG_UNACCEPTED_MEMORY) &&\n\t    md->type == EFI_UNACCEPTED_MEMORY)\n\t\t    return true;\n\n\treturn false;\n}\n\n \nstatic bool\nprocess_efi_entries(unsigned long minimum, unsigned long image_size)\n{\n\tstruct efi_info *e = &boot_params->efi_info;\n\tbool efi_mirror_found = false;\n\tstruct mem_vector region;\n\tefi_memory_desc_t *md;\n\tunsigned long pmap;\n\tchar *signature;\n\tu32 nr_desc;\n\tint i;\n\n\tsignature = (char *)&e->efi_loader_signature;\n\tif (strncmp(signature, EFI32_LOADER_SIGNATURE, 4) &&\n\t    strncmp(signature, EFI64_LOADER_SIGNATURE, 4))\n\t\treturn false;\n\n#ifdef CONFIG_X86_32\n\t \n\tif (e->efi_memmap_hi) {\n\t\twarn(\"EFI memmap is above 4GB, can't be handled now on x86_32. EFI should be disabled.\\n\");\n\t\treturn false;\n\t}\n\tpmap =  e->efi_memmap;\n#else\n\tpmap = (e->efi_memmap | ((__u64)e->efi_memmap_hi << 32));\n#endif\n\n\tnr_desc = e->efi_memmap_size / e->efi_memdesc_size;\n\tfor (i = 0; i < nr_desc; i++) {\n\t\tmd = efi_early_memdesc_ptr(pmap, e->efi_memdesc_size, i);\n\t\tif (md->attribute & EFI_MEMORY_MORE_RELIABLE) {\n\t\t\tefi_mirror_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < nr_desc; i++) {\n\t\tmd = efi_early_memdesc_ptr(pmap, e->efi_memdesc_size, i);\n\n\t\tif (!memory_type_is_free(md))\n\t\t\tcontinue;\n\n\t\tif (efi_soft_reserve_enabled() &&\n\t\t    (md->attribute & EFI_MEMORY_SP))\n\t\t\tcontinue;\n\n\t\tif (efi_mirror_found &&\n\t\t    !(md->attribute & EFI_MEMORY_MORE_RELIABLE))\n\t\t\tcontinue;\n\n\t\tregion.start = md->phys_addr;\n\t\tregion.size = md->num_pages << EFI_PAGE_SHIFT;\n\t\tif (process_mem_region(&region, minimum, image_size))\n\t\t\tbreak;\n\t}\n\treturn true;\n}\n#else\nstatic inline bool\nprocess_efi_entries(unsigned long minimum, unsigned long image_size)\n{\n\treturn false;\n}\n#endif\n\nstatic void process_e820_entries(unsigned long minimum,\n\t\t\t\t unsigned long image_size)\n{\n\tint i;\n\tstruct mem_vector region;\n\tstruct boot_e820_entry *entry;\n\n\t \n\tfor (i = 0; i < boot_params->e820_entries; i++) {\n\t\tentry = &boot_params->e820_table[i];\n\t\t \n\t\tif (entry->type != E820_TYPE_RAM)\n\t\t\tcontinue;\n\t\tregion.start = entry->addr;\n\t\tregion.size = entry->size;\n\t\tif (process_mem_region(&region, minimum, image_size))\n\t\t\tbreak;\n\t}\n}\n\nstatic unsigned long find_random_phys_addr(unsigned long minimum,\n\t\t\t\t\t   unsigned long image_size)\n{\n\tu64 phys_addr;\n\n\t \n\tif (minimum + image_size > mem_limit)\n\t\treturn 0;\n\n\t \n\tif (memmap_too_large) {\n\t\tdebug_putstr(\"Aborted memory entries scan (more than 4 memmap= args)!\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!process_efi_entries(minimum, image_size))\n\t\tprocess_e820_entries(minimum, image_size);\n\n\tphys_addr = slots_fetch_random();\n\n\t \n\tif (phys_addr < minimum || phys_addr + image_size > mem_limit) {\n\t\twarn(\"Invalid physical address chosen!\\n\");\n\t\treturn 0;\n\t}\n\n\treturn (unsigned long)phys_addr;\n}\n\nstatic unsigned long find_random_virt_addr(unsigned long minimum,\n\t\t\t\t\t   unsigned long image_size)\n{\n\tunsigned long slots, random_addr;\n\n\t \n\tslots = 1 + (KERNEL_IMAGE_SIZE - minimum - image_size) / CONFIG_PHYSICAL_ALIGN;\n\n\trandom_addr = kaslr_get_random_long(\"Virtual\") % slots;\n\n\treturn random_addr * CONFIG_PHYSICAL_ALIGN + minimum;\n}\n\n \nvoid choose_random_location(unsigned long input,\n\t\t\t    unsigned long input_size,\n\t\t\t    unsigned long *output,\n\t\t\t    unsigned long output_size,\n\t\t\t    unsigned long *virt_addr)\n{\n\tunsigned long random_addr, min_addr;\n\n\tif (cmdline_find_option_bool(\"nokaslr\")) {\n\t\twarn(\"KASLR disabled: 'nokaslr' on cmdline.\");\n\t\treturn;\n\t}\n\n\tboot_params->hdr.loadflags |= KASLR_FLAG;\n\n\tif (IS_ENABLED(CONFIG_X86_32))\n\t\tmem_limit = KERNEL_IMAGE_SIZE;\n\telse\n\t\tmem_limit = MAXMEM;\n\n\t \n\tmem_avoid_init(input, input_size, *output);\n\n\t \n\tmin_addr = min(*output, 512UL << 20);\n\t \n\tmin_addr = ALIGN(min_addr, CONFIG_PHYSICAL_ALIGN);\n\n\t \n\trandom_addr = find_random_phys_addr(min_addr, output_size);\n\tif (!random_addr) {\n\t\twarn(\"Physical KASLR disabled: no suitable memory region!\");\n\t} else {\n\t\t \n\t\tif (*output != random_addr)\n\t\t\t*output = random_addr;\n\t}\n\n\n\t \n\tif (IS_ENABLED(CONFIG_X86_64))\n\t\trandom_addr = find_random_virt_addr(LOAD_PHYSICAL_ADDR, output_size);\n\t*virt_addr = random_addr;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}