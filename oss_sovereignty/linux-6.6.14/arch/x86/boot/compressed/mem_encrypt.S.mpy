{
  "module_name": "mem_encrypt.S",
  "hash_id": "089d2ed287819c9b19fcea216bf8a2b5d3f7b9df4653ee56db6e31c1a1590b2c",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/compressed/mem_encrypt.S",
  "human_readable_source": " \n \n\n#include <linux/linkage.h>\n\n#include <asm/processor-flags.h>\n#include <asm/msr.h>\n#include <asm/asm-offsets.h>\n#include <asm/segment.h>\n#include <asm/trapnr.h>\n\n\t.text\n\t.code32\nSYM_FUNC_START(get_sev_encryption_bit)\n\tpush\t%ebx\n\n\tmovl\t$0x80000000, %eax\t \n\tcpuid\n\tcmpl\t$0x8000001f, %eax\t \n\tjb\t.Lno_sev\n\n\t \n\tmovl\t$0x8000001f, %eax\n\tcpuid\n\tbt\t$1, %eax\t\t \n\tjnc\t.Lno_sev\n\n\tmovl\t$MSR_AMD64_SEV, %ecx\t \n\trdmsr\n\tbt\t$MSR_AMD64_SEV_ENABLED_BIT, %eax\t \n\tjnc\t.Lno_sev\n\n\tmovl\t%ebx, %eax\n\tandl\t$0x3f, %eax\t\t \n\tjmp\t.Lsev_exit\n\n.Lno_sev:\n\txor\t%eax, %eax\n\n.Lsev_exit:\n\tpop\t%ebx\n\tRET\nSYM_FUNC_END(get_sev_encryption_bit)\n\n \nSYM_CODE_START_LOCAL(sev_es_req_cpuid)\n\tshll\t$30, %eax\n\torl     $0x00000004, %eax\n\tmovl    $MSR_AMD64_SEV_ES_GHCB, %ecx\n\twrmsr\n\trep; vmmcall\t\t# VMGEXIT\n\trdmsr\n\n\t \n\tmovl\t%eax, %ecx\n\tandl\t$0x3ffff000, %ecx\t# Bits [12-29] MBZ\n\tjnz\t2f\n\n\t \n\tandl    $0xfff, %eax\n\tcmpl    $5, %eax\n\tjne\t2f\n\n\t \n\txorl\t%eax, %eax\n1:\n\tRET\n2:\n\tmovl\t$-1, %eax\n\tjmp\t1b\nSYM_CODE_END(sev_es_req_cpuid)\n\nSYM_CODE_START_LOCAL(startup32_vc_handler)\n\tpushl\t%eax\n\tpushl\t%ebx\n\tpushl\t%ecx\n\tpushl\t%edx\n\n\t \n\tmovl\t%eax, %ebx\n\n\t \n\tcmpl\t$0x72, 16(%esp)\n\tjne\t.Lfail\n\n\tmovl\t$0, %eax\t\t# Request CPUID[fn].EAX\n\tmovl\t%ebx, %edx\t\t# CPUID fn\n\tcall\tsev_es_req_cpuid\t# Call helper\n\ttestl\t%eax, %eax\t\t# Check return code\n\tjnz\t.Lfail\n\tmovl\t%edx, 12(%esp)\t\t# Store result\n\n\tmovl\t$1, %eax\t\t# Request CPUID[fn].EBX\n\tmovl\t%ebx, %edx\t\t# CPUID fn\n\tcall\tsev_es_req_cpuid\t# Call helper\n\ttestl\t%eax, %eax\t\t# Check return code\n\tjnz\t.Lfail\n\tmovl\t%edx, 8(%esp)\t\t# Store result\n\n\tmovl\t$2, %eax\t\t# Request CPUID[fn].ECX\n\tmovl\t%ebx, %edx\t\t# CPUID fn\n\tcall\tsev_es_req_cpuid\t# Call helper\n\ttestl\t%eax, %eax\t\t# Check return code\n\tjnz\t.Lfail\n\tmovl\t%edx, 4(%esp)\t\t# Store result\n\n\tmovl\t$3, %eax\t\t# Request CPUID[fn].EDX\n\tmovl\t%ebx, %edx\t\t# CPUID fn\n\tcall\tsev_es_req_cpuid\t# Call helper\n\ttestl\t%eax, %eax\t\t# Check return code\n\tjnz\t.Lfail\n\tmovl\t%edx, 0(%esp)\t\t# Store result\n\n\t \n\n\t \n\tcmpl    $0x80000000, %ebx\n\tjne     .Lcheck_sev\n\tcmpl    $0x8000001f, 12(%esp)\n\tjb      .Lfail\n\tjmp     .Ldone\n\n.Lcheck_sev:\n\t \n\tcmpl    $0x8000001f, %ebx\n\tjne     .Ldone\n\tbtl     $1, 12(%esp)\n\tjnc     .Lfail\n\n.Ldone:\n\tpopl\t%edx\n\tpopl\t%ecx\n\tpopl\t%ebx\n\tpopl\t%eax\n\n\t \n\taddl\t$4, %esp\n\n\t \n\taddl\t$2, (%esp)\n\n\tiret\n.Lfail:\n\t \n\tmovl    $0x100, %eax\n\txorl    %edx, %edx\n\tmovl    $MSR_AMD64_SEV_ES_GHCB, %ecx\n\twrmsr\n\trep; vmmcall\n\n\t \n\thlt\n\tjmp .Lfail\nSYM_CODE_END(startup32_vc_handler)\n\n \nSYM_FUNC_START_LOCAL(startup32_set_idt_entry)\n\t \n\tleal\t(%ecx, %edx, 8), %ecx\n\n\t \n\tmovl    %eax, %edx\n\tandl    $0x0000ffff, %edx\t\t# Target code segment offset [15:0]\n\torl\t$(__KERNEL32_CS << 16), %edx\t# Target code segment selector\n\n\t \n\tmovl    %edx, (%ecx)\n\n\t \n\tmovl    %eax, %edx\n\tandl    $0xffff0000, %edx\t# Target code segment offset [31:16]\n\torl     $0x00008e00, %edx\t# Present, Type 32-bit Interrupt Gate\n\n\t \n\tmovl    %edx, 4(%ecx)\n\n\tRET\nSYM_FUNC_END(startup32_set_idt_entry)\n\nSYM_FUNC_START(startup32_load_idt)\n\tpush\t%ebp\n\tpush\t%ebx\n\n\tcall\t1f\n1:\tpop\t%ebp\n\n\tleal    (boot32_idt - 1b)(%ebp), %ebx\n\n\t \n\tleal    (startup32_vc_handler - 1b)(%ebp), %eax\n\tmovl    $X86_TRAP_VC, %edx\n\tmovl\t%ebx, %ecx\n\tcall    startup32_set_idt_entry\n\n\t \n\tleal\t(boot32_idt_desc - 1b)(%ebp), %ecx\n\tmovl\t%ebx, 2(%ecx)\n\tlidt    (%ecx)\n\n\tpop\t%ebx\n\tpop\t%ebp\n\tRET\nSYM_FUNC_END(startup32_load_idt)\n\n \nSYM_FUNC_START(startup32_check_sev_cbit)\n\tpushl\t%ebx\n\tpushl\t%ebp\n\n\tcall\t0f\n0:\tpopl\t%ebp\n\n\t \n\tmovl\t(sev_status - 0b)(%ebp), %eax\n\ttestl\t%eax, %eax\n\tjz\t4f\n\n\t \n1:\trdrand\t%eax\n\tjnc\t1b\n2:\trdrand\t%ebx\n\tjnc\t2b\n\n\t \n\tleal\t(sev_check_data - 0b)(%ebp), %ebp\n\tmovl\t%eax, 0(%ebp)\n\tmovl\t%ebx, 4(%ebp)\n\n\t \n\tmovl\t%cr0, %edx\t\t\t  \n\tmovl\t$(X86_CR0_PG | X86_CR0_PE), %ecx  \n\tmovl\t%ecx, %cr0\n\n\tcmpl\t%eax, 0(%ebp)\n\tjne\t3f\n\tcmpl\t%ebx, 4(%ebp)\n\tjne\t3f\n\n\tmovl\t%edx, %cr0\t \n\n\tjmp\t4f\n\n3:\t \n\thlt\n\tjmp\t3b\n\n4:\n\tpopl\t%ebp\n\tpopl\t%ebx\n\tRET\nSYM_FUNC_END(startup32_check_sev_cbit)\n\n\t.code64\n\n#include \"../../kernel/sev_verify_cbit.S\"\n\n\t.data\n\n\t.balign\t8\nSYM_DATA(sme_me_mask,\t\t.quad 0)\nSYM_DATA(sev_status,\t\t.quad 0)\nSYM_DATA(sev_check_data,\t.quad 0)\n\nSYM_DATA_START_LOCAL(boot32_idt)\n\t.rept\t32\n\t.quad\t0\n\t.endr\nSYM_DATA_END(boot32_idt)\n\nSYM_DATA_START_LOCAL(boot32_idt_desc)\n\t.word\t. - boot32_idt - 1\n\t.long\t0\nSYM_DATA_END(boot32_idt_desc)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}