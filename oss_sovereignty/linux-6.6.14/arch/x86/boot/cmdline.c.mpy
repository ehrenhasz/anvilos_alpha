{
  "module_name": "cmdline.c",
  "hash_id": "2e910ef0830cb675065c4671c4c21c5943fcc0f48de2a851136468e2c1f8a377",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/cmdline.c",
  "human_readable_source": "\n \n\n \n\n#include \"boot.h\"\n\nstatic inline int myisspace(u8 c)\n{\n\treturn c <= ' ';\t \n}\n\n \nint __cmdline_find_option(unsigned long cmdline_ptr, const char *option, char *buffer, int bufsize)\n{\n\taddr_t cptr;\n\tchar c;\n\tint len = -1;\n\tconst char *opptr = NULL;\n\tchar *bufptr = buffer;\n\tenum {\n\t\tst_wordstart,\t \n\t\tst_wordcmp,\t \n\t\tst_wordskip,\t \n\t\tst_bufcpy\t \n\t} state = st_wordstart;\n\n\tif (!cmdline_ptr)\n\t\treturn -1;       \n\n\tcptr = cmdline_ptr & 0xf;\n\tset_fs(cmdline_ptr >> 4);\n\n\twhile (cptr < 0x10000 && (c = rdfs8(cptr++))) {\n\t\tswitch (state) {\n\t\tcase st_wordstart:\n\t\t\tif (myisspace(c))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tstate = st_wordcmp;\n\t\t\topptr = option;\n\t\t\tfallthrough;\n\n\t\tcase st_wordcmp:\n\t\t\tif (c == '=' && !*opptr) {\n\t\t\t\tlen = 0;\n\t\t\t\tbufptr = buffer;\n\t\t\t\tstate = st_bufcpy;\n\t\t\t} else if (myisspace(c)) {\n\t\t\t\tstate = st_wordstart;\n\t\t\t} else if (c != *opptr++) {\n\t\t\t\tstate = st_wordskip;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase st_wordskip:\n\t\t\tif (myisspace(c))\n\t\t\t\tstate = st_wordstart;\n\t\t\tbreak;\n\n\t\tcase st_bufcpy:\n\t\t\tif (myisspace(c)) {\n\t\t\t\tstate = st_wordstart;\n\t\t\t} else {\n\t\t\t\tif (len < bufsize-1)\n\t\t\t\t\t*bufptr++ = c;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bufsize)\n\t\t*bufptr = '\\0';\n\n\treturn len;\n}\n\n \nint __cmdline_find_option_bool(unsigned long cmdline_ptr, const char *option)\n{\n\taddr_t cptr;\n\tchar c;\n\tint pos = 0, wstart = 0;\n\tconst char *opptr = NULL;\n\tenum {\n\t\tst_wordstart,\t \n\t\tst_wordcmp,\t \n\t\tst_wordskip,\t \n\t} state = st_wordstart;\n\n\tif (!cmdline_ptr)\n\t\treturn -1;       \n\n\tcptr = cmdline_ptr & 0xf;\n\tset_fs(cmdline_ptr >> 4);\n\n\twhile (cptr < 0x10000) {\n\t\tc = rdfs8(cptr++);\n\t\tpos++;\n\n\t\tswitch (state) {\n\t\tcase st_wordstart:\n\t\t\tif (!c)\n\t\t\t\treturn 0;\n\t\t\telse if (myisspace(c))\n\t\t\t\tbreak;\n\n\t\t\tstate = st_wordcmp;\n\t\t\topptr = option;\n\t\t\twstart = pos;\n\t\t\tfallthrough;\n\n\t\tcase st_wordcmp:\n\t\t\tif (!*opptr)\n\t\t\t\tif (!c || myisspace(c))\n\t\t\t\t\treturn wstart;\n\t\t\t\telse\n\t\t\t\t\tstate = st_wordskip;\n\t\t\telse if (!c)\n\t\t\t\treturn 0;\n\t\t\telse if (c != *opptr++)\n\t\t\t\tstate = st_wordskip;\n\t\t\tbreak;\n\n\t\tcase st_wordskip:\n\t\t\tif (!c)\n\t\t\t\treturn 0;\n\t\t\telse if (myisspace(c))\n\t\t\t\tstate = st_wordstart;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}