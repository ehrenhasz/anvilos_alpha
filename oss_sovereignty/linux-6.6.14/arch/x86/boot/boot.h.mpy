{
  "module_name": "boot.h",
  "hash_id": "da8b3ccf5ec16cf8edac586a93ca618610933286a8a1402861e1e348a9591d4a",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/boot.h",
  "human_readable_source": " \n \n\n \n\n#ifndef BOOT_BOOT_H\n#define BOOT_BOOT_H\n\n#define STACK_SIZE\t1024\t \n\n#ifndef __ASSEMBLY__\n\n#include <linux/stdarg.h>\n#include <linux/types.h>\n#include <linux/edd.h>\n#include <asm/setup.h>\n#include <asm/asm.h>\n#include \"bitops.h\"\n#include \"ctype.h\"\n#include \"cpuflags.h\"\n#include \"io.h\"\n\n \n#define ARRAY_SIZE(x) (sizeof(x) / sizeof(*(x)))\n\nextern struct setup_header hdr;\nextern struct boot_params boot_params;\n\n#define cpu_relax()\tasm volatile(\"rep; nop\")\n\nstatic inline void io_delay(void)\n{\n\tconst u16 DELAY_PORT = 0x80;\n\toutb(0, DELAY_PORT);\n}\n\n \n\nstatic inline u16 ds(void)\n{\n\tu16 seg;\n\tasm(\"movw %%ds,%0\" : \"=rm\" (seg));\n\treturn seg;\n}\n\nstatic inline void set_fs(u16 seg)\n{\n\tasm volatile(\"movw %0,%%fs\" : : \"rm\" (seg));\n}\nstatic inline u16 fs(void)\n{\n\tu16 seg;\n\tasm volatile(\"movw %%fs,%0\" : \"=rm\" (seg));\n\treturn seg;\n}\n\nstatic inline void set_gs(u16 seg)\n{\n\tasm volatile(\"movw %0,%%gs\" : : \"rm\" (seg));\n}\nstatic inline u16 gs(void)\n{\n\tu16 seg;\n\tasm volatile(\"movw %%gs,%0\" : \"=rm\" (seg));\n\treturn seg;\n}\n\ntypedef unsigned int addr_t;\n\nstatic inline u8 rdfs8(addr_t addr)\n{\n\tu8 *ptr = (u8 *)absolute_pointer(addr);\n\tu8 v;\n\tasm volatile(\"movb %%fs:%1,%0\" : \"=q\" (v) : \"m\" (*ptr));\n\treturn v;\n}\nstatic inline u16 rdfs16(addr_t addr)\n{\n\tu16 *ptr = (u16 *)absolute_pointer(addr);\n\tu16 v;\n\tasm volatile(\"movw %%fs:%1,%0\" : \"=r\" (v) : \"m\" (*ptr));\n\treturn v;\n}\nstatic inline u32 rdfs32(addr_t addr)\n{\n\tu32 *ptr = (u32 *)absolute_pointer(addr);\n\tu32 v;\n\tasm volatile(\"movl %%fs:%1,%0\" : \"=r\" (v) : \"m\" (*ptr));\n\treturn v;\n}\n\nstatic inline void wrfs8(u8 v, addr_t addr)\n{\n\tu8 *ptr = (u8 *)absolute_pointer(addr);\n\tasm volatile(\"movb %1,%%fs:%0\" : \"+m\" (*ptr) : \"qi\" (v));\n}\nstatic inline void wrfs16(u16 v, addr_t addr)\n{\n\tu16 *ptr = (u16 *)absolute_pointer(addr);\n\tasm volatile(\"movw %1,%%fs:%0\" : \"+m\" (*ptr) : \"ri\" (v));\n}\nstatic inline void wrfs32(u32 v, addr_t addr)\n{\n\tu32 *ptr = (u32 *)absolute_pointer(addr);\n\tasm volatile(\"movl %1,%%fs:%0\" : \"+m\" (*ptr) : \"ri\" (v));\n}\n\nstatic inline u8 rdgs8(addr_t addr)\n{\n\tu8 *ptr = (u8 *)absolute_pointer(addr);\n\tu8 v;\n\tasm volatile(\"movb %%gs:%1,%0\" : \"=q\" (v) : \"m\" (*ptr));\n\treturn v;\n}\nstatic inline u16 rdgs16(addr_t addr)\n{\n\tu16 *ptr = (u16 *)absolute_pointer(addr);\n\tu16 v;\n\tasm volatile(\"movw %%gs:%1,%0\" : \"=r\" (v) : \"m\" (*ptr));\n\treturn v;\n}\nstatic inline u32 rdgs32(addr_t addr)\n{\n\tu32 *ptr = (u32 *)absolute_pointer(addr);\n\tu32 v;\n\tasm volatile(\"movl %%gs:%1,%0\" : \"=r\" (v) : \"m\" (*ptr));\n\treturn v;\n}\n\nstatic inline void wrgs8(u8 v, addr_t addr)\n{\n\tu8 *ptr = (u8 *)absolute_pointer(addr);\n\tasm volatile(\"movb %1,%%gs:%0\" : \"+m\" (*ptr) : \"qi\" (v));\n}\nstatic inline void wrgs16(u16 v, addr_t addr)\n{\n\tu16 *ptr = (u16 *)absolute_pointer(addr);\n\tasm volatile(\"movw %1,%%gs:%0\" : \"+m\" (*ptr) : \"ri\" (v));\n}\nstatic inline void wrgs32(u32 v, addr_t addr)\n{\n\tu32 *ptr = (u32 *)absolute_pointer(addr);\n\tasm volatile(\"movl %1,%%gs:%0\" : \"+m\" (*ptr) : \"ri\" (v));\n}\n\n \nstatic inline bool memcmp_fs(const void *s1, addr_t s2, size_t len)\n{\n\tbool diff;\n\tasm volatile(\"fs; repe; cmpsb\" CC_SET(nz)\n\t\t     : CC_OUT(nz) (diff), \"+D\" (s1), \"+S\" (s2), \"+c\" (len));\n\treturn diff;\n}\nstatic inline bool memcmp_gs(const void *s1, addr_t s2, size_t len)\n{\n\tbool diff;\n\tasm volatile(\"gs; repe; cmpsb\" CC_SET(nz)\n\t\t     : CC_OUT(nz) (diff), \"+D\" (s1), \"+S\" (s2), \"+c\" (len));\n\treturn diff;\n}\n\n \nextern char _end[];\nextern char *HEAP;\nextern char *heap_end;\n#define RESET_HEAP() ((void *)( HEAP = _end ))\nstatic inline char *__get_heap(size_t s, size_t a, size_t n)\n{\n\tchar *tmp;\n\n\tHEAP = (char *)(((size_t)HEAP+(a-1)) & ~(a-1));\n\ttmp = HEAP;\n\tHEAP += s*n;\n\treturn tmp;\n}\n#define GET_HEAP(type, n) \\\n\t((type *)__get_heap(sizeof(type),__alignof__(type),(n)))\n\nstatic inline bool heap_free(size_t n)\n{\n\treturn (int)(heap_end-HEAP) >= (int)n;\n}\n\n \n\nvoid copy_to_fs(addr_t dst, void *src, size_t len);\nvoid *copy_from_fs(void *dst, addr_t src, size_t len);\nvoid copy_to_gs(addr_t dst, void *src, size_t len);\nvoid *copy_from_gs(void *dst, addr_t src, size_t len);\n\n \nint enable_a20(void);\n\n \nint query_apm_bios(void);\n\n \nstruct biosregs {\n\tunion {\n\t\tstruct {\n\t\t\tu32 edi;\n\t\t\tu32 esi;\n\t\t\tu32 ebp;\n\t\t\tu32 _esp;\n\t\t\tu32 ebx;\n\t\t\tu32 edx;\n\t\t\tu32 ecx;\n\t\t\tu32 eax;\n\t\t\tu32 _fsgs;\n\t\t\tu32 _dses;\n\t\t\tu32 eflags;\n\t\t};\n\t\tstruct {\n\t\t\tu16 di, hdi;\n\t\t\tu16 si, hsi;\n\t\t\tu16 bp, hbp;\n\t\t\tu16 _sp, _hsp;\n\t\t\tu16 bx, hbx;\n\t\t\tu16 dx, hdx;\n\t\t\tu16 cx, hcx;\n\t\t\tu16 ax, hax;\n\t\t\tu16 gs, fs;\n\t\t\tu16 es, ds;\n\t\t\tu16 flags, hflags;\n\t\t};\n\t\tstruct {\n\t\t\tu8 dil, dih, edi2, edi3;\n\t\t\tu8 sil, sih, esi2, esi3;\n\t\t\tu8 bpl, bph, ebp2, ebp3;\n\t\t\tu8 _spl, _sph, _esp2, _esp3;\n\t\t\tu8 bl, bh, ebx2, ebx3;\n\t\t\tu8 dl, dh, edx2, edx3;\n\t\t\tu8 cl, ch, ecx2, ecx3;\n\t\t\tu8 al, ah, eax2, eax3;\n\t\t};\n\t};\n};\nvoid intcall(u8 int_no, const struct biosregs *ireg, struct biosregs *oreg);\n\n \nint __cmdline_find_option(unsigned long cmdline_ptr, const char *option, char *buffer, int bufsize);\nint __cmdline_find_option_bool(unsigned long cmdline_ptr, const char *option);\nstatic inline int cmdline_find_option(const char *option, char *buffer, int bufsize)\n{\n\tunsigned long cmd_line_ptr = boot_params.hdr.cmd_line_ptr;\n\n\tif (cmd_line_ptr >= 0x100000)\n\t\treturn -1;       \n\n\treturn __cmdline_find_option(cmd_line_ptr, option, buffer, bufsize);\n}\n\nstatic inline int cmdline_find_option_bool(const char *option)\n{\n\tunsigned long cmd_line_ptr = boot_params.hdr.cmd_line_ptr;\n\n\tif (cmd_line_ptr >= 0x100000)\n\t\treturn -1;       \n\n\treturn __cmdline_find_option_bool(cmd_line_ptr, option);\n}\n\n \nint check_cpu(int *cpu_level_ptr, int *req_level_ptr, u32 **err_flags_ptr);\nint check_knl_erratum(void);\nint validate_cpu(void);\n\n \nextern int early_serial_base;\nvoid console_init(void);\n\n \nvoid query_edd(void);\n\n \nvoid __attribute__((noreturn)) die(void);\n\n \nvoid detect_memory(void);\n\n \nvoid __attribute__((noreturn)) go_to_protected_mode(void);\n\n \nvoid __attribute__((noreturn))\n\tprotected_mode_jump(u32 entrypoint, u32 bootparams);\n\n \nint sprintf(char *buf, const char *fmt, ...);\nint vsprintf(char *buf, const char *fmt, va_list args);\nint printf(const char *fmt, ...);\n\n \nvoid initregs(struct biosregs *regs);\n\n \nint strcmp(const char *str1, const char *str2);\nint strncmp(const char *cs, const char *ct, size_t count);\nsize_t strnlen(const char *s, size_t maxlen);\nunsigned int atou(const char *s);\nunsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base);\nsize_t strlen(const char *s);\nchar *strchr(const char *s, int c);\n\n \nvoid puts(const char *);\nvoid putchar(int);\nint getchar(void);\nvoid kbd_flush(void);\nint getchar_timeout(void);\n\n \nvoid set_video(void);\n\n \nint set_mode(u16 mode);\nint mode_defined(u16 mode);\nvoid probe_cards(int unsafe);\n\n \nvoid vesa_store_edid(void);\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}