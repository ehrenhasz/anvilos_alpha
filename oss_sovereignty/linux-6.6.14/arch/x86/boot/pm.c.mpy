{
  "module_name": "pm.c",
  "hash_id": "d0e18429de0996354c7d6ab4bc52c0957d51a5244a834d424c875be89e4721ce",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/pm.c",
  "human_readable_source": "\n \n\n \n\n#include \"boot.h\"\n#include <asm/segment.h>\n\n \nstatic void realmode_switch_hook(void)\n{\n\tif (boot_params.hdr.realmode_swtch) {\n\t\tasm volatile(\"lcallw *%0\"\n\t\t\t     : : \"m\" (boot_params.hdr.realmode_swtch)\n\t\t\t     : \"eax\", \"ebx\", \"ecx\", \"edx\");\n\t} else {\n\t\tasm volatile(\"cli\");\n\t\toutb(0x80, 0x70);  \n\t\tio_delay();\n\t}\n}\n\n \nstatic void mask_all_interrupts(void)\n{\n\toutb(0xff, 0xa1);\t \n\tio_delay();\n\toutb(0xfb, 0x21);\t \n\tio_delay();\n}\n\n \nstatic void reset_coprocessor(void)\n{\n\toutb(0, 0xf0);\n\tio_delay();\n\toutb(0, 0xf1);\n\tio_delay();\n}\n\n \n\nstruct gdt_ptr {\n\tu16 len;\n\tu32 ptr;\n} __attribute__((packed));\n\nstatic void setup_gdt(void)\n{\n\t \n\tstatic const u64 boot_gdt[] __attribute__((aligned(16))) = {\n\t\t \n\t\t[GDT_ENTRY_BOOT_CS] = GDT_ENTRY(0xc09b, 0, 0xfffff),\n\t\t \n\t\t[GDT_ENTRY_BOOT_DS] = GDT_ENTRY(0xc093, 0, 0xfffff),\n\t\t \n\t\t \n\t\t[GDT_ENTRY_BOOT_TSS] = GDT_ENTRY(0x0089, 4096, 103),\n\t};\n\t \n\tstatic struct gdt_ptr gdt;\n\n\tgdt.len = sizeof(boot_gdt)-1;\n\tgdt.ptr = (u32)&boot_gdt + (ds() << 4);\n\n\tasm volatile(\"lgdtl %0\" : : \"m\" (gdt));\n}\n\n \nstatic void setup_idt(void)\n{\n\tstatic const struct gdt_ptr null_idt = {0, 0};\n\tasm volatile(\"lidtl %0\" : : \"m\" (null_idt));\n}\n\n \nvoid go_to_protected_mode(void)\n{\n\t \n\trealmode_switch_hook();\n\n\t \n\tif (enable_a20()) {\n\t\tputs(\"A20 gate not responding, unable to boot...\\n\");\n\t\tdie();\n\t}\n\n\t \n\treset_coprocessor();\n\n\t \n\tmask_all_interrupts();\n\n\t \n\tsetup_idt();\n\tsetup_gdt();\n\tprotected_mode_jump(boot_params.hdr.code32_start,\n\t\t\t    (u32)&boot_params + (ds() << 4));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}