{
  "module_name": "genimage.sh",
  "hash_id": "91d0d57def890cafb86c1010e6155f9f55df3fde007946fcabae8ad2321a46ab",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/genimage.sh",
  "human_readable_source": "#!/bin/bash\n#\n# This file is subject to the terms and conditions of the GNU General Public\n# License.  See the file \"COPYING\" in the main directory of this archive\n# for more details.\n#\n# Copyright (C) 2017 by Changbin Du <changbin.du@intel.com>\n#\n# Adapted from code in arch/x86/boot/Makefile by H. Peter Anvin and others\n#\n# \"make fdimage/fdimage144/fdimage288/hdimage/isoimage\"\n# script for x86 architecture\n#\n# Arguments:\n#   $1  - fdimage format\n#   $2  - target image file\n#   $3  - kernel bzImage file\n#   $4  - mtools configuration file\n#   $5  - kernel cmdline\n#   $6+ - initrd image file(s)\n#\n# This script requires:\n#   bash\n#   syslinux\n#   mtools (for fdimage* and hdimage)\n#   edk2/OVMF (for hdimage)\n#\n# Otherwise try to stick to POSIX shell commands...\n#\n\n# Use \"make V=1\" to debug this script\ncase \"${KBUILD_VERBOSE}\" in\n*1*)\n        set -x\n        ;;\nesac\n\n# Exit the top-level shell with an error\ntopshell=$$\ntrap 'exit 1' USR1\ndie() {\n\techo \"\"        1>&2\n\techo \" *** $*\" 1>&2\n\techo \"\"        1>&2\n\tkill -USR1 $topshell\n}\n\n# Verify the existence and readability of a file\nverify() {\n\tif [ ! -f \"$1\" -o ! -r \"$1\" ]; then\n\t\tdie \"Missing file: $1\"\n\tfi\n}\n\ndiskfmt=\"$1\"\nFIMAGE=\"$2\"\nFBZIMAGE=\"$3\"\nMTOOLSRC=\"$4\"\nKCMDLINE=\"$5\"\nshift 5\t\t\t\t# Remaining arguments = initrd files\n\nexport MTOOLSRC\n\n# common options for dd\ndd='dd iflag=fullblock'\n\n# Make sure the files actually exist\nverify \"$FBZIMAGE\"\n\ndeclare -a FDINITRDS\nirdpfx=' initrd='\ninitrdopts_syslinux=''\ninitrdopts_efi=''\nfor f in \"$@\"; do\n\tif [ -f \"$f\" -a -r \"$f\" ]; then\n\t    FDINITRDS=(\"${FDINITRDS[@]}\" \"$f\")\n\t    fname=\"$(basename \"$f\")\"\n\t    initrdopts_syslinux=\"${initrdopts_syslinux}${irdpfx}${fname}\"\n\t    irdpfx=,\n\t    initrdopts_efi=\"${initrdopts_efi} initrd=${fname}\"\n\tfi\ndone\n\n# Read a $3-byte littleendian unsigned value at offset $2 from file $1\nle() {\n\tlocal n=0\n\tlocal m=1\n\tfor b in $(od -A n -v -j $2 -N $3 -t u1 \"$1\"); do\n\t\tn=$((n + b*m))\n\t\tm=$((m * 256))\n\tdone\n\techo $n\n}\n\n# Get the EFI architecture name such that boot{name}.efi is the default\n# boot file name. Returns false with no output if the file is not an\n# EFI image or otherwise unknown.\nefiarch() {\n\t[ -f \"$1\" ] || return\n\t[ $(le \"$1\" 0 2) -eq 23117 ] || return\t\t# MZ magic\n\tpeoffs=$(le \"$1\" 60 4)\t\t\t\t# PE header offset\n\t[ $peoffs -ge 64 ] || return\n\t[ $(le \"$1\" $peoffs 4) -eq 17744 ] || return\t# PE magic\n\tcase $(le \"$1\" $((peoffs+4+20)) 2) in\t\t# PE type\n\t\t267)\t;;\t\t\t\t# PE32\n\t\t523)\t;;\t\t\t\t# PE32+\n\t\t*) return 1 ;;\t\t\t\t# Invalid\n\tesac\n\t[ $(le \"$1\" $((peoffs+4+20+68)) 2) -eq 10 ] || return # EFI app\n\tcase $(le \"$1\" $((peoffs+4)) 2) in\t\t# Machine type\n\t\t 332)\techo i386\t;;\n\t\t 450)\techo arm\t;;\n\t\t 512)\techo ia64\t;;\n\t\t20530)\techo riscv32\t;;\n\t\t20580)\techo riscv64\t;;\n\t\t20776)\techo riscv128\t;;\n\t\t34404)\techo x64\t;;\n\t\t43620)\techo aa64\t;;\n\tesac\n}\n\n# Get the combined sizes in bytes of the files given, counting sparse\n# files as full length, and padding each file to cluster size\ncluster=16384\nfilesizes() {\n\tlocal t=0\n\tlocal s\n\tfor s in $(ls -lnL \"$@\" 2>/dev/null | awk '/^-/{ print $5; }'); do\n\t\tt=$((t + ((s+cluster-1)/cluster)*cluster))\n\tdone\n\techo $t\n}\n\n# Expand directory names which should be in /usr/share into a list\n# of possible alternatives\nsharedirs() {\n\tlocal dir file\n\tfor dir in /usr/share /usr/lib64 /usr/lib; do\n\t\tfor file; do\n\t\t\techo \"$dir/$file\"\n\t\t\techo \"$dir/${file^^}\"\n\t\tdone\n\tdone\n}\nefidirs() {\n\tlocal dir file\n\tfor dir in /usr/share /boot /usr/lib64 /usr/lib; do\n\t\tfor file; do\n\t\t\techo \"$dir/$file\"\n\t\t\techo \"$dir/${file^^}\"\n\t\tdone\n\tdone\n}\n\nfindsyslinux() {\n\tlocal f=\"$(find -L $(sharedirs syslinux isolinux) \\\n\t\t    -name \"$1\" -readable -type f -print -quit 2>/dev/null)\"\n\tif [ ! -f \"$f\" ]; then\n\t\tdie \"Need a $1 file, please install syslinux/isolinux.\"\n\tfi\n\techo \"$f\"\n\treturn 0\n}\n\nfindovmf() {\n\tlocal arch=\"$1\"\n\tshift\n\tlocal -a names=(-false)\n\tlocal name f\n\tfor name; do\n\t\tnames=(\"${names[@]}\" -or -iname \"$name\")\n\tdone\n\tfor f in $(find -L $(efidirs edk2 ovmf) \\\n\t\t\t\\( \"${names[@]}\" \\) -readable -type f \\\n\t\t\t-print 2>/dev/null); do\n\t\tif [ \"$(efiarch \"$f\")\" = \"$arch\" ]; then\n\t\t\techo \"$f\"\n\t\t\treturn 0\n\t\tfi\n\tdone\n\tdie \"Need a $1 file for $arch, please install EDK2/OVMF.\"\n}\n\ndo_mcopy() {\n\tif [ ${#FDINITRDS[@]} -gt 0 ]; then\n\t\tmcopy \"${FDINITRDS[@]}\" \"$1\"\n\tfi\n\tif [ -n \"$efishell\" ]; then\n\t\tmmd \"$1\"EFI \"$1\"EFI/Boot\n\t\tmcopy \"$efishell\" \"$1\"EFI/Boot/boot${kefiarch}.efi\n\tfi\n\tif [ -n \"$kefiarch\" ]; then\n\t\techo linux \"$KCMDLINE$initrdopts_efi\" | \\\n\t\t\tmcopy - \"$1\"startup.nsh\n\tfi\n\techo default linux \"$KCMDLINE$initrdopts_syslinux\" | \\\n\t\tmcopy - \"$1\"syslinux.cfg\n\tmcopy \"$FBZIMAGE\" \"$1\"linux\n}\n\ngenbzdisk() {\n\tverify \"$MTOOLSRC\"\n\tmformat -v 'LINUX_BOOT' a:\n\tsyslinux \"$FIMAGE\"\n\tdo_mcopy a:\n}\n\ngenfdimage144() {\n\tverify \"$MTOOLSRC\"\n\t$dd if=/dev/zero of=\"$FIMAGE\" bs=1024 count=1440 2>/dev/null\n\tmformat -v 'LINUX_BOOT' v:\n\tsyslinux \"$FIMAGE\"\n\tdo_mcopy v:\n}\n\ngenfdimage288() {\n\tverify \"$MTOOLSRC\"\n\t$dd if=/dev/zero of=\"$FIMAGE\" bs=1024 count=2880 2>/dev/null\n\tmformat -v 'LINUX_BOOT' w:\n\tsyslinux \"$FIMAGE\"\n\tdo_mcopy w:\n}\n\ngenhdimage() {\n\tverify \"$MTOOLSRC\"\n\tmbr=\"$(findsyslinux mbr.bin)\"\n\tkefiarch=\"$(efiarch \"$FBZIMAGE\")\"\n\tif [ -n \"$kefiarch\" ]; then\n\t\t# The efishell provides command line handling\n\t\tefishell=\"$(findovmf $kefiarch shell.efi shell${kefiarch}.efi)\"\n\t\tptype='-T 0xef'\t# EFI system partition, no GPT\n\tfi\n\tsizes=$(filesizes \"$FBZIMAGE\" \"${FDINITRDS[@]}\" \"$efishell\")\n\t# Allow 1% + 2 MiB for filesystem and partition table overhead,\n\t# syslinux, and config files; this is probably excessive...\n\tmegs=$(((sizes + sizes/100 + 2*1024*1024 - 1)/(1024*1024)))\n\t$dd if=/dev/zero of=\"$FIMAGE\" bs=$((1024*1024)) count=$megs 2>/dev/null\n\tmpartition -I -c -s 32 -h 64 $ptype -b 64 -a p:\n\t$dd if=\"$mbr\" of=\"$FIMAGE\" bs=440 count=1 conv=notrunc 2>/dev/null\n\tmformat -v 'LINUX_BOOT' -s 32 -h 64 -c $((cluster/512)) -t $megs h:\n\tsyslinux --offset $((64*512)) \"$FIMAGE\"\n\tdo_mcopy h:\n}\n\ngeniso() {\n\ttmp_dir=\"$(dirname \"$FIMAGE\")/isoimage\"\n\trm -rf \"$tmp_dir\"\n\tmkdir \"$tmp_dir\"\n\tisolinux=$(findsyslinux isolinux.bin)\n\tldlinux=$(findsyslinux  ldlinux.c32)\n\tcp \"$isolinux\" \"$ldlinux\" \"$tmp_dir\"\n\tcp \"$FBZIMAGE\" \"$tmp_dir\"/linux\n\techo default linux \"$KCMDLINE\" > \"$tmp_dir\"/isolinux.cfg\n\tcp \"${FDINITRDS[@]}\" \"$tmp_dir\"/\n\tgenisoimage -J -r -appid 'LINUX_BOOT' -input-charset=utf-8 \\\n\t\t    -quiet -o \"$FIMAGE\" -b isolinux.bin \\\n\t\t    -c boot.cat -no-emul-boot -boot-load-size 4 \\\n\t\t    -boot-info-table \"$tmp_dir\"\n\tisohybrid \"$FIMAGE\" 2>/dev/null || true\n\trm -rf \"$tmp_dir\"\n}\n\nrm -f \"$FIMAGE\"\n\ncase \"$diskfmt\" in\n\tbzdisk)     genbzdisk;;\n\tfdimage144) genfdimage144;;\n\tfdimage288) genfdimage288;;\n\thdimage)    genhdimage;;\n\tisoimage)   geniso;;\n\t*)          die \"Unknown image format: $diskfmt\";;\nesac\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}