{
  "module_name": "early_serial_console.c",
  "hash_id": "98d8d6aae158cd5c441d24549c8051b81f5c990b075e28de816728993c6e495f",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/early_serial_console.c",
  "human_readable_source": "\n \n#include \"boot.h\"\n\n#define DEFAULT_SERIAL_PORT 0x3f8  \n\n#define DLAB\t\t0x80\n\n#define TXR             0        \n#define RXR             0        \n#define IER             1        \n#define IIR             2        \n#define FCR             2        \n#define LCR             3        \n#define MCR             4        \n#define LSR             5        \n#define MSR             6        \n#define DLL             0        \n#define DLH             1        \n\n#define DEFAULT_BAUD 9600\n\nstatic void early_serial_init(int port, int baud)\n{\n\tunsigned char c;\n\tunsigned divisor;\n\n\toutb(0x3, port + LCR);\t \n\toutb(0, port + IER);\t \n\toutb(0, port + FCR);\t \n\toutb(0x3, port + MCR);\t \n\n\tdivisor\t= 115200 / baud;\n\tc = inb(port + LCR);\n\toutb(c | DLAB, port + LCR);\n\toutb(divisor & 0xff, port + DLL);\n\toutb((divisor >> 8) & 0xff, port + DLH);\n\toutb(c & ~DLAB, port + LCR);\n\n\tearly_serial_base = port;\n}\n\nstatic void parse_earlyprintk(void)\n{\n\tint baud = DEFAULT_BAUD;\n\tchar arg[32];\n\tint pos = 0;\n\tint port = 0;\n\n\tif (cmdline_find_option(\"earlyprintk\", arg, sizeof(arg)) > 0) {\n\t\tchar *e;\n\n\t\tif (!strncmp(arg, \"serial\", 6)) {\n\t\t\tport = DEFAULT_SERIAL_PORT;\n\t\t\tpos += 6;\n\t\t}\n\n\t\tif (arg[pos] == ',')\n\t\t\tpos++;\n\n\t\t \n\t\tif (pos == 7 && !strncmp(arg + pos, \"0x\", 2)) {\n\t\t\tport = simple_strtoull(arg + pos, &e, 16);\n\t\t\tif (port == 0 || arg + pos == e)\n\t\t\t\tport = DEFAULT_SERIAL_PORT;\n\t\t\telse\n\t\t\t\tpos = e - arg;\n\t\t} else if (!strncmp(arg + pos, \"ttyS\", 4)) {\n\t\t\tstatic const int bases[] = { 0x3f8, 0x2f8 };\n\t\t\tint idx = 0;\n\n\t\t\t \n\t\t\tpos += 4;\n\n\t\t\tif (arg[pos++] == '1')\n\t\t\t\tidx = 1;\n\n\t\t\tport = bases[idx];\n\t\t}\n\n\t\tif (arg[pos] == ',')\n\t\t\tpos++;\n\n\t\tbaud = simple_strtoull(arg + pos, &e, 0);\n\t\tif (baud == 0 || arg + pos == e)\n\t\t\tbaud = DEFAULT_BAUD;\n\t}\n\n\tif (port)\n\t\tearly_serial_init(port, baud);\n}\n\n#define BASE_BAUD (1843200/16)\nstatic unsigned int probe_baud(int port)\n{\n\tunsigned char lcr, dll, dlh;\n\tunsigned int quot;\n\n\tlcr = inb(port + LCR);\n\toutb(lcr | DLAB, port + LCR);\n\tdll = inb(port + DLL);\n\tdlh = inb(port + DLH);\n\toutb(lcr, port + LCR);\n\tquot = (dlh << 8) | dll;\n\n\treturn BASE_BAUD / quot;\n}\n\nstatic void parse_console_uart8250(void)\n{\n\tchar optstr[64], *options;\n\tint baud = DEFAULT_BAUD;\n\tint port = 0;\n\n\t \n\tif (cmdline_find_option(\"console\", optstr, sizeof(optstr)) <= 0)\n\t\treturn;\n\n\toptions = optstr;\n\n\tif (!strncmp(options, \"uart8250,io,\", 12))\n\t\tport = simple_strtoull(options + 12, &options, 0);\n\telse if (!strncmp(options, \"uart,io,\", 8))\n\t\tport = simple_strtoull(options + 8, &options, 0);\n\telse\n\t\treturn;\n\n\tif (options && (options[0] == ','))\n\t\tbaud = simple_strtoull(options + 1, &options, 0);\n\telse\n\t\tbaud = probe_baud(port);\n\n\tif (port)\n\t\tearly_serial_init(port, baud);\n}\n\nvoid console_init(void)\n{\n\tparse_earlyprintk();\n\n\tif (!early_serial_base)\n\t\tparse_console_uart8250();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}