{
  "module_name": "cpucheck.c",
  "hash_id": "e7e4652feb16150fc018de84414ab667cb683ddded03de58549ca3bed93086b2",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/cpucheck.c",
  "human_readable_source": "\n \n\n \n\n#ifdef _SETUP\n# include \"boot.h\"\n#endif\n#include <linux/types.h>\n#include <asm/intel-family.h>\n#include <asm/processor-flags.h>\n#include <asm/required-features.h>\n#include <asm/msr-index.h>\n#include \"string.h\"\n#include \"msr.h\"\n\nstatic u32 err_flags[NCAPINTS];\n\nstatic const int req_level = CONFIG_X86_MINIMUM_CPU_FAMILY;\n\nstatic const u32 req_flags[NCAPINTS] =\n{\n\tREQUIRED_MASK0,\n\tREQUIRED_MASK1,\n\t0,  \n\t0,  \n\tREQUIRED_MASK4,\n\t0,  \n\tREQUIRED_MASK6,\n\t0,  \n\t0,  \n\t0,  \n\t0,  \n\t0,  \n\t0,  \n\t0,  \n\t0,  \n\t0,  \n\tREQUIRED_MASK16,\n};\n\n#define A32(a, b, c, d) (((d) << 24)+((c) << 16)+((b) << 8)+(a))\n\nstatic int is_amd(void)\n{\n\treturn cpu_vendor[0] == A32('A', 'u', 't', 'h') &&\n\t       cpu_vendor[1] == A32('e', 'n', 't', 'i') &&\n\t       cpu_vendor[2] == A32('c', 'A', 'M', 'D');\n}\n\nstatic int is_centaur(void)\n{\n\treturn cpu_vendor[0] == A32('C', 'e', 'n', 't') &&\n\t       cpu_vendor[1] == A32('a', 'u', 'r', 'H') &&\n\t       cpu_vendor[2] == A32('a', 'u', 'l', 's');\n}\n\nstatic int is_transmeta(void)\n{\n\treturn cpu_vendor[0] == A32('G', 'e', 'n', 'u') &&\n\t       cpu_vendor[1] == A32('i', 'n', 'e', 'T') &&\n\t       cpu_vendor[2] == A32('M', 'x', '8', '6');\n}\n\nstatic int is_intel(void)\n{\n\treturn cpu_vendor[0] == A32('G', 'e', 'n', 'u') &&\n\t       cpu_vendor[1] == A32('i', 'n', 'e', 'I') &&\n\t       cpu_vendor[2] == A32('n', 't', 'e', 'l');\n}\n\n \nstatic int check_cpuflags(void)\n{\n\tu32 err;\n\tint i;\n\n\terr = 0;\n\tfor (i = 0; i < NCAPINTS; i++) {\n\t\terr_flags[i] = req_flags[i] & ~cpu.flags[i];\n\t\tif (err_flags[i])\n\t\t\terr |= 1 << i;\n\t}\n\n\treturn err;\n}\n\n \nint check_cpu(int *cpu_level_ptr, int *req_level_ptr, u32 **err_flags_ptr)\n{\n\tint err;\n\n\tmemset(&cpu.flags, 0, sizeof(cpu.flags));\n\tcpu.level = 3;\n\n\tif (has_eflag(X86_EFLAGS_AC))\n\t\tcpu.level = 4;\n\n\tget_cpuflags();\n\terr = check_cpuflags();\n\n\tif (test_bit(X86_FEATURE_LM, cpu.flags))\n\t\tcpu.level = 64;\n\n\tif (err == 0x01 &&\n\t    !(err_flags[0] &\n\t      ~((1 << X86_FEATURE_XMM)|(1 << X86_FEATURE_XMM2))) &&\n\t    is_amd()) {\n\t\t \n\n\t\tstruct msr m;\n\n\t\tboot_rdmsr(MSR_K7_HWCR, &m);\n\t\tm.l &= ~(1 << 15);\n\t\tboot_wrmsr(MSR_K7_HWCR, &m);\n\n\t\tget_cpuflags();\t \n\t\terr = check_cpuflags();\n\t} else if (err == 0x01 &&\n\t\t   !(err_flags[0] & ~(1 << X86_FEATURE_CX8)) &&\n\t\t   is_centaur() && cpu.model >= 6) {\n\t\t \n\n\t\tstruct msr m;\n\n\t\tboot_rdmsr(MSR_VIA_FCR, &m);\n\t\tm.l |= (1 << 1) | (1 << 7);\n\t\tboot_wrmsr(MSR_VIA_FCR, &m);\n\n\t\tset_bit(X86_FEATURE_CX8, cpu.flags);\n\t\terr = check_cpuflags();\n\t} else if (err == 0x01 && is_transmeta()) {\n\t\t \n\n\t\tstruct msr m, m_tmp;\n\t\tu32 level = 1;\n\n\t\tboot_rdmsr(0x80860004, &m);\n\t\tm_tmp = m;\n\t\tm_tmp.l = ~0;\n\t\tboot_wrmsr(0x80860004, &m_tmp);\n\t\tasm(\"cpuid\"\n\t\t    : \"+a\" (level), \"=d\" (cpu.flags[0])\n\t\t    : : \"ecx\", \"ebx\");\n\t\tboot_wrmsr(0x80860004, &m);\n\n\t\terr = check_cpuflags();\n\t} else if (err == 0x01 &&\n\t\t   !(err_flags[0] & ~(1 << X86_FEATURE_PAE)) &&\n\t\t   is_intel() && cpu.level == 6 &&\n\t\t   (cpu.model == 9 || cpu.model == 13)) {\n\t\t \n\t\tif (cmdline_find_option_bool(\"forcepae\")) {\n\t\t\tputs(\"WARNING: Forcing PAE in CPU flags\\n\");\n\t\t\tset_bit(X86_FEATURE_PAE, cpu.flags);\n\t\t\terr = check_cpuflags();\n\t\t}\n\t\telse {\n\t\t\tputs(\"WARNING: PAE disabled. Use parameter 'forcepae' to enable at your own risk!\\n\");\n\t\t}\n\t}\n\tif (!err)\n\t\terr = check_knl_erratum();\n\n\tif (err_flags_ptr)\n\t\t*err_flags_ptr = err ? err_flags : NULL;\n\tif (cpu_level_ptr)\n\t\t*cpu_level_ptr = cpu.level;\n\tif (req_level_ptr)\n\t\t*req_level_ptr = req_level;\n\n\treturn (cpu.level < req_level || err) ? -1 : 0;\n}\n\nint check_knl_erratum(void)\n{\n\t \n\tif (!is_intel() ||\n\t    cpu.family != 6 ||\n\t    cpu.model != INTEL_FAM6_XEON_PHI_KNL)\n\t\treturn 0;\n\n\t \n\tif (IS_ENABLED(CONFIG_X86_64) || IS_ENABLED(CONFIG_X86_PAE))\n\t\treturn 0;\n\n\tputs(\"This 32-bit kernel can not run on this Xeon Phi x200\\n\"\n\t     \"processor due to a processor erratum.  Use a 64-bit\\n\"\n\t     \"kernel, or enable PAE in this 32-bit kernel.\\n\\n\");\n\n\treturn -1;\n}\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}