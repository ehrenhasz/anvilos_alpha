{
  "module_name": "main.c",
  "hash_id": "c7bebabc0c41ed6c56df2443fcf43fae95be561e29e514d6bea793b761212914",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/main.c",
  "human_readable_source": "\n \n\n \n#include <linux/build_bug.h>\n\n#include \"boot.h\"\n#include \"string.h\"\n\nstruct boot_params boot_params __attribute__((aligned(16)));\n\nstruct port_io_ops pio_ops;\n\nchar *HEAP = _end;\nchar *heap_end = _end;\t\t \n\n \n\nstatic void copy_boot_params(void)\n{\n\tstruct old_cmdline {\n\t\tu16 cl_magic;\n\t\tu16 cl_offset;\n\t};\n\tconst struct old_cmdline * const oldcmd =\n\t\tabsolute_pointer(OLD_CL_ADDRESS);\n\n\tBUILD_BUG_ON(sizeof(boot_params) != 4096);\n\tmemcpy(&boot_params.hdr, &hdr, sizeof(hdr));\n\n\tif (!boot_params.hdr.cmd_line_ptr &&\n\t    oldcmd->cl_magic == OLD_CL_MAGIC) {\n\t\t \n\t\tu16 cmdline_seg;\n\n\t\t \n\t\tif (oldcmd->cl_offset < boot_params.hdr.setup_move_size)\n\t\t\tcmdline_seg = ds();\n\t\telse\n\t\t\tcmdline_seg = 0x9000;\n\n\t\tboot_params.hdr.cmd_line_ptr =\n\t\t\t(cmdline_seg << 4) + oldcmd->cl_offset;\n\t}\n}\n\n \nstatic void keyboard_init(void)\n{\n\tstruct biosregs ireg, oreg;\n\tinitregs(&ireg);\n\n\tireg.ah = 0x02;\t\t \n\tintcall(0x16, &ireg, &oreg);\n\tboot_params.kbd_status = oreg.al;\n\n\tireg.ax = 0x0305;\t \n\tintcall(0x16, &ireg, NULL);\n}\n\n \nstatic void query_ist(void)\n{\n\tstruct biosregs ireg, oreg;\n\n\t \n\tif (cpu.level < 6)\n\t\treturn;\n\n\tinitregs(&ireg);\n\tireg.ax  = 0xe980;\t  \n\tireg.edx = 0x47534943;\t  \n\tintcall(0x15, &ireg, &oreg);\n\n\tboot_params.ist_info.signature  = oreg.eax;\n\tboot_params.ist_info.command    = oreg.ebx;\n\tboot_params.ist_info.event      = oreg.ecx;\n\tboot_params.ist_info.perf_level = oreg.edx;\n}\n\n \nstatic void set_bios_mode(void)\n{\n#ifdef CONFIG_X86_64\n\tstruct biosregs ireg;\n\n\tinitregs(&ireg);\n\tireg.ax = 0xec00;\n\tireg.bx = 2;\n\tintcall(0x15, &ireg, NULL);\n#endif\n}\n\nstatic void init_heap(void)\n{\n\tchar *stack_end;\n\n\tif (boot_params.hdr.loadflags & CAN_USE_HEAP) {\n\t\tasm(\"leal %P1(%%esp),%0\"\n\t\t    : \"=r\" (stack_end) : \"i\" (-STACK_SIZE));\n\n\t\theap_end = (char *)\n\t\t\t((size_t)boot_params.hdr.heap_end_ptr + 0x200);\n\t\tif (heap_end > stack_end)\n\t\t\theap_end = stack_end;\n\t} else {\n\t\t \n\t\tputs(\"WARNING: Ancient bootloader, some functionality \"\n\t\t     \"may be limited!\\n\");\n\t}\n}\n\nvoid main(void)\n{\n\tinit_default_io_ops();\n\n\t \n\tcopy_boot_params();\n\n\t \n\tconsole_init();\n\tif (cmdline_find_option_bool(\"debug\"))\n\t\tputs(\"early console in setup code\\n\");\n\n\t \n\tinit_heap();\n\n\t \n\tif (validate_cpu()) {\n\t\tputs(\"Unable to boot - please use a kernel appropriate \"\n\t\t     \"for your CPU.\\n\");\n\t\tdie();\n\t}\n\n\t \n\tset_bios_mode();\n\n\t \n\tdetect_memory();\n\n\t \n\tkeyboard_init();\n\n\t \n\tquery_ist();\n\n\t \n#if defined(CONFIG_APM) || defined(CONFIG_APM_MODULE)\n\tquery_apm_bios();\n#endif\n\n\t \n#if defined(CONFIG_EDD) || defined(CONFIG_EDD_MODULE)\n\tquery_edd();\n#endif\n\n\t \n\tset_video();\n\n\t \n\tgo_to_protected_mode();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}