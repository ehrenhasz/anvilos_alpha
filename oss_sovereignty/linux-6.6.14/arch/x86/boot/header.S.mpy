{
  "module_name": "header.S",
  "hash_id": "678bd79c2e78c03cd61e129dbb5e173c24e2c2206e3b6f11e7dffb5b2fe4b5b6",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/header.S",
  "human_readable_source": " \n \n#include <linux/pe.h>\n#include <asm/segment.h>\n#include <asm/boot.h>\n#include <asm/page_types.h>\n#include <asm/setup.h>\n#include <asm/bootparam.h>\n#include \"boot.h\"\n#include \"voffset.h\"\n#include \"zoffset.h\"\n\nBOOTSEG\t\t= 0x07C0\t\t \nSYSSEG\t\t= 0x1000\t\t \n\n#ifndef SVGA_MODE\n#define SVGA_MODE ASK_VGA\n#endif\n\n#ifndef ROOT_RDONLY\n#define ROOT_RDONLY 1\n#endif\n\n\t.code16\n\t.section \".bstext\", \"ax\"\n\n\t.global bootsect_start\nbootsect_start:\n#ifdef CONFIG_EFI_STUB\n\t# \"MZ\", MS-DOS header\n\t.word\tMZ_MAGIC\n#endif\n\n\t# Normalize the start address\n\tljmp\t$BOOTSEG, $start2\n\nstart2:\n\tmovw\t%cs, %ax\n\tmovw\t%ax, %ds\n\tmovw\t%ax, %es\n\tmovw\t%ax, %ss\n\txorw\t%sp, %sp\n\tsti\n\tcld\n\n\tmovw\t$bugger_off_msg, %si\n\nmsg_loop:\n\tlodsb\n\tandb\t%al, %al\n\tjz\tbs_die\n\tmovb\t$0xe, %ah\n\tmovw\t$7, %bx\n\tint\t$0x10\n\tjmp\tmsg_loop\n\nbs_die:\n\t# Allow the user to press a key, then reboot\n\txorw\t%ax, %ax\n\tint\t$0x16\n\tint\t$0x19\n\n\t# int 0x19 should never return.  In case it does anyway,\n\t# invoke the BIOS reset code...\n\tljmp\t$0xf000,$0xfff0\n\n#ifdef CONFIG_EFI_STUB\n\t.org\t0x38\n\t#\n\t# Offset to the PE header.\n\t#\n\t.long\tLINUX_PE_MAGIC\n\t.long\tpe_header\n#endif  \n\n\t.section \".bsdata\", \"a\"\nbugger_off_msg:\n\t.ascii\t\"Use a boot loader.\\r\\n\"\n\t.ascii\t\"\\n\"\n\t.ascii\t\"Remove disk and press any key to reboot...\\r\\n\"\n\t.byte\t0\n\n#ifdef CONFIG_EFI_STUB\npe_header:\n\t.long\tPE_MAGIC\n\ncoff_header:\n#ifdef CONFIG_X86_32\n\t.set\timage_file_add_flags, IMAGE_FILE_32BIT_MACHINE\n\t.set\tpe_opt_magic, PE_OPT_MAGIC_PE32\n\t.word\tIMAGE_FILE_MACHINE_I386\n#else\n\t.set\timage_file_add_flags, 0\n\t.set\tpe_opt_magic, PE_OPT_MAGIC_PE32PLUS\n\t.word\tIMAGE_FILE_MACHINE_AMD64\n#endif\n\t.word\tsection_count\t\t\t# nr_sections\n\t.long\t0 \t\t\t\t# TimeDateStamp\n\t.long\t0\t\t\t\t# PointerToSymbolTable\n\t.long\t1\t\t\t\t# NumberOfSymbols\n\t.word\tsection_table - optional_header\t# SizeOfOptionalHeader\n\t.word\tIMAGE_FILE_EXECUTABLE_IMAGE\t| \\\n\t\timage_file_add_flags\t\t| \\\n\t\tIMAGE_FILE_DEBUG_STRIPPED\t| \\\n\t\tIMAGE_FILE_LINE_NUMS_STRIPPED\t# Characteristics\n\noptional_header:\n\t.word\tpe_opt_magic\n\t.byte\t0x02\t\t\t\t# MajorLinkerVersion\n\t.byte\t0x14\t\t\t\t# MinorLinkerVersion\n\n\t# Filled in by build.c\n\t.long\t0\t\t\t\t# SizeOfCode\n\n\t.long\t0\t\t\t\t# SizeOfInitializedData\n\t.long\t0\t\t\t\t# SizeOfUninitializedData\n\n\t# Filled in by build.c\n\t.long\t0x0000\t\t\t\t# AddressOfEntryPoint\n\n\t.long\t0x0200\t\t\t\t# BaseOfCode\n#ifdef CONFIG_X86_32\n\t.long\t0\t\t\t\t# data\n#endif\n\nextra_header_fields:\n\t# PE specification requires ImageBase to be 64k aligned\n\t.set\timage_base, (LOAD_PHYSICAL_ADDR + 0xffff) & ~0xffff\n#ifdef CONFIG_X86_32\n\t.long\timage_base\t\t\t# ImageBase\n#else\n\t.quad\timage_base\t\t\t# ImageBase\n#endif\n\t.long\t0x20\t\t\t\t# SectionAlignment\n\t.long\t0x20\t\t\t\t# FileAlignment\n\t.word\t0\t\t\t\t# MajorOperatingSystemVersion\n\t.word\t0\t\t\t\t# MinorOperatingSystemVersion\n\t.word\tLINUX_EFISTUB_MAJOR_VERSION\t# MajorImageVersion\n\t.word\tLINUX_EFISTUB_MINOR_VERSION\t# MinorImageVersion\n\t.word\t0\t\t\t\t# MajorSubsystemVersion\n\t.word\t0\t\t\t\t# MinorSubsystemVersion\n\t.long\t0\t\t\t\t# Win32VersionValue\n\n\t#\n\t# The size of the bzImage is written in tools/build.c\n\t#\n\t.long\t0\t\t\t\t# SizeOfImage\n\n\t.long\t0x200\t\t\t\t# SizeOfHeaders\n\t.long\t0\t\t\t\t# CheckSum\n\t.word\tIMAGE_SUBSYSTEM_EFI_APPLICATION\t# Subsystem (EFI application)\n#ifdef CONFIG_EFI_DXE_MEM_ATTRIBUTES\n\t.word\tIMAGE_DLL_CHARACTERISTICS_NX_COMPAT\t# DllCharacteristics\n#else\n\t.word\t0\t\t\t\t# DllCharacteristics\n#endif\n#ifdef CONFIG_X86_32\n\t.long\t0\t\t\t\t# SizeOfStackReserve\n\t.long\t0\t\t\t\t# SizeOfStackCommit\n\t.long\t0\t\t\t\t# SizeOfHeapReserve\n\t.long\t0\t\t\t\t# SizeOfHeapCommit\n#else\n\t.quad\t0\t\t\t\t# SizeOfStackReserve\n\t.quad\t0\t\t\t\t# SizeOfStackCommit\n\t.quad\t0\t\t\t\t# SizeOfHeapReserve\n\t.quad\t0\t\t\t\t# SizeOfHeapCommit\n#endif\n\t.long\t0\t\t\t\t# LoaderFlags\n\t.long\t(section_table - .) / 8\t\t# NumberOfRvaAndSizes\n\n\t.quad\t0\t\t\t\t# ExportTable\n\t.quad\t0\t\t\t\t# ImportTable\n\t.quad\t0\t\t\t\t# ResourceTable\n\t.quad\t0\t\t\t\t# ExceptionTable\n\t.quad\t0\t\t\t\t# CertificationTable\n\t.quad\t0\t\t\t\t# BaseRelocationTable\n\n\t# Section table\nsection_table:\n\t#\n\t# The offset & size fields are filled in by build.c.\n\t#\n\t.ascii\t\".setup\"\n\t.byte\t0\n\t.byte\t0\n\t.long\t0\n\t.long\t0x0\t\t\t\t# startup_{32,64}\n\t.long\t0\t\t\t\t# Size of initialized data\n\t\t\t\t\t\t# on disk\n\t.long\t0x0\t\t\t\t# startup_{32,64}\n\t.long\t0\t\t\t\t# PointerToRelocations\n\t.long\t0\t\t\t\t# PointerToLineNumbers\n\t.word\t0\t\t\t\t# NumberOfRelocations\n\t.word\t0\t\t\t\t# NumberOfLineNumbers\n\t.long\tIMAGE_SCN_CNT_CODE\t\t| \\\n\t\tIMAGE_SCN_MEM_READ\t\t| \\\n\t\tIMAGE_SCN_MEM_EXECUTE\t\t| \\\n\t\tIMAGE_SCN_ALIGN_16BYTES\t\t# Characteristics\n\n\t#\n\t# The EFI application loader requires a relocation section\n\t# because EFI applications must be relocatable. The .reloc\n\t# offset & size fields are filled in by build.c.\n\t#\n\t.ascii\t\".reloc\"\n\t.byte\t0\n\t.byte\t0\n\t.long\t0\n\t.long\t0\n\t.long\t0\t\t\t\t# SizeOfRawData\n\t.long\t0\t\t\t\t# PointerToRawData\n\t.long\t0\t\t\t\t# PointerToRelocations\n\t.long\t0\t\t\t\t# PointerToLineNumbers\n\t.word\t0\t\t\t\t# NumberOfRelocations\n\t.word\t0\t\t\t\t# NumberOfLineNumbers\n\t.long\tIMAGE_SCN_CNT_INITIALIZED_DATA\t| \\\n\t\tIMAGE_SCN_MEM_READ\t\t| \\\n\t\tIMAGE_SCN_MEM_DISCARDABLE\t| \\\n\t\tIMAGE_SCN_ALIGN_1BYTES\t\t# Characteristics\n\n#ifdef CONFIG_EFI_MIXED\n\t#\n\t# The offset & size fields are filled in by build.c.\n\t#\n\t.asciz\t\".compat\"\n\t.long\t0\n\t.long\t0x0\n\t.long\t0\t\t\t\t# Size of initialized data\n\t\t\t\t\t\t# on disk\n\t.long\t0x0\n\t.long\t0\t\t\t\t# PointerToRelocations\n\t.long\t0\t\t\t\t# PointerToLineNumbers\n\t.word\t0\t\t\t\t# NumberOfRelocations\n\t.word\t0\t\t\t\t# NumberOfLineNumbers\n\t.long\tIMAGE_SCN_CNT_INITIALIZED_DATA\t| \\\n\t\tIMAGE_SCN_MEM_READ\t\t| \\\n\t\tIMAGE_SCN_MEM_DISCARDABLE\t| \\\n\t\tIMAGE_SCN_ALIGN_1BYTES\t\t# Characteristics\n#endif\n\n\t#\n\t# The offset & size fields are filled in by build.c.\n\t#\n\t.ascii\t\".text\"\n\t.byte\t0\n\t.byte\t0\n\t.byte\t0\n\t.long\t0\n\t.long\t0x0\t\t\t\t# startup_{32,64}\n\t.long\t0\t\t\t\t# Size of initialized data\n\t\t\t\t\t\t# on disk\n\t.long\t0x0\t\t\t\t# startup_{32,64}\n\t.long\t0\t\t\t\t# PointerToRelocations\n\t.long\t0\t\t\t\t# PointerToLineNumbers\n\t.word\t0\t\t\t\t# NumberOfRelocations\n\t.word\t0\t\t\t\t# NumberOfLineNumbers\n\t.long\tIMAGE_SCN_CNT_CODE\t\t| \\\n\t\tIMAGE_SCN_MEM_READ\t\t| \\\n\t\tIMAGE_SCN_MEM_EXECUTE\t\t| \\\n\t\tIMAGE_SCN_ALIGN_16BYTES\t\t# Characteristics\n\n\t.set\tsection_count, (. - section_table) / 40\n#endif  \n\n\t# Kernel attributes; used by setup.  This is part 1 of the\n\t# header, from the old boot sector.\n\n\t.section \".header\", \"a\"\n\t.globl\tsentinel\nsentinel:\t.byte 0xff, 0xff         \n\n\t.globl\thdr\nhdr:\nsetup_sects:\t.byte 0\t\t\t \nroot_flags:\t.word ROOT_RDONLY\nsyssize:\t.long 0\t\t\t \nram_size:\t.word 0\t\t\t \nvid_mode:\t.word SVGA_MODE\nroot_dev:\t.word 0\t\t\t \nboot_flag:\t.word 0xAA55\n\n\t# offset 512, entry point\n\n\t.globl\t_start\n_start:\n\t\t# Explicitly enter this as bytes, or the assembler\n\t\t# tries to generate a 3-byte jump here, which causes\n\t\t# everything else to push off to the wrong offset.\n\t\t.byte\t0xeb\t\t# short (2-byte) jump\n\t\t.byte\tstart_of_setup-1f\n1:\n\n\t# Part 2 of the header, from the old setup.S\n\n\t\t.ascii\t\"HdrS\"\t\t# header signature\n\t\t.word\t0x020f\t\t# header version number (>= 0x0105)\n\t\t\t\t\t# or else old loadlin-1.5 will fail)\n\t\t.globl realmode_swtch\nrealmode_swtch:\t.word\t0, 0\t\t# default_switch, SETUPSEG\nstart_sys_seg:\t.word\tSYSSEG\t\t# obsolete and meaningless, but just\n\t\t\t\t\t# in case something decided to \"use\" it\n\t\t.word\tkernel_version-512 # pointing to kernel version string\n\t\t\t\t\t# above section of header is compatible\n\t\t\t\t\t# with loadlin-1.5 (header v1.5). Don't\n\t\t\t\t\t# change it.\n\ntype_of_loader:\t.byte\t0\t\t# 0 means ancient bootloader, newer\n\t\t\t\t\t# bootloaders know to change this.\n\t\t\t\t\t# See Documentation/arch/x86/boot.rst for\n\t\t\t\t\t# assigned ids\n\n# flags, unused bits must be zero (RFU) bit within loadflags\nloadflags:\n\t\t.byte\tLOADED_HIGH\t# The kernel is to be loaded high\n\nsetup_move_size: .word  0x8000\t\t# size to move, when setup is not\n\t\t\t\t\t# loaded at 0x90000. We will move setup\n\t\t\t\t\t# to 0x90000 then just before jumping\n\t\t\t\t\t# into the kernel. However, only the\n\t\t\t\t\t# loader knows how much data behind\n\t\t\t\t\t# us also needs to be loaded.\n\ncode32_start:\t\t\t\t# here loaders can put a different\n\t\t\t\t\t# start address for 32-bit code.\n\t\t.long\t0x100000\t# 0x100000 = default for big kernel\n\nramdisk_image:\t.long\t0\t\t# address of loaded ramdisk image\n\t\t\t\t\t# Here the loader puts the 32-bit\n\t\t\t\t\t# address where it loaded the image.\n\t\t\t\t\t# This only will be read by the kernel.\n\nramdisk_size:\t.long\t0\t\t# its size in bytes\n\nbootsect_kludge:\n\t\t.long\t0\t\t# obsolete\n\nheap_end_ptr:\t.word\t_end+STACK_SIZE-512\n\t\t\t\t\t# (Header version 0x0201 or later)\n\t\t\t\t\t# space from here (exclusive) down to\n\t\t\t\t\t# end of setup code can be used by setup\n\t\t\t\t\t# for local heap purposes.\n\next_loader_ver:\n\t\t.byte\t0\t\t# Extended boot loader version\next_loader_type:\n\t\t.byte\t0\t\t# Extended boot loader type\n\ncmd_line_ptr:\t.long\t0\t\t# (Header version 0x0202 or later)\n\t\t\t\t\t# If nonzero, a 32-bit pointer\n\t\t\t\t\t# to the kernel command line.\n\t\t\t\t\t# The command line should be\n\t\t\t\t\t# located between the start of\n\t\t\t\t\t# setup and the end of low\n\t\t\t\t\t# memory (0xa0000), or it may\n\t\t\t\t\t# get overwritten before it\n\t\t\t\t\t# gets read.  If this field is\n\t\t\t\t\t# used, there is no longer\n\t\t\t\t\t# anything magical about the\n\t\t\t\t\t# 0x90000 segment; the setup\n\t\t\t\t\t# can be located anywhere in\n\t\t\t\t\t# low memory 0x10000 or higher.\n\ninitrd_addr_max: .long 0x7fffffff\n\t\t\t\t\t# (Header version 0x0203 or later)\n\t\t\t\t\t# The highest safe address for\n\t\t\t\t\t# the contents of an initrd\n\t\t\t\t\t# The current kernel allows up to 4 GB,\n\t\t\t\t\t# but leave it at 2 GB to avoid\n\t\t\t\t\t# possible bootloader bugs.\n\nkernel_alignment:  .long CONFIG_PHYSICAL_ALIGN\t#physical addr alignment\n\t\t\t\t\t\t#required for protected mode\n\t\t\t\t\t\t#kernel\n#ifdef CONFIG_RELOCATABLE\nrelocatable_kernel:    .byte 1\n#else\nrelocatable_kernel:    .byte 0\n#endif\nmin_alignment:\t\t.byte MIN_KERNEL_ALIGN_LG2\t# minimum alignment\n\nxloadflags:\n#ifdef CONFIG_X86_64\n# define XLF0 XLF_KERNEL_64\t\t\t/* 64-bit kernel */\n#else\n# define XLF0 0\n#endif\n\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_X86_64)\n   /* kernel/boot_param/ramdisk could be loaded above 4g */\n# define XLF1 XLF_CAN_BE_LOADED_ABOVE_4G\n#else\n# define XLF1 0\n#endif\n\n#ifdef CONFIG_EFI_HANDOVER_PROTOCOL\n# ifdef CONFIG_EFI_MIXED\n#  define XLF23 (XLF_EFI_HANDOVER_32|XLF_EFI_HANDOVER_64)\n# else\n#  ifdef CONFIG_X86_64\n#   define XLF23 XLF_EFI_HANDOVER_64\t\t/* 64-bit EFI handover ok */\n#  else\n#   define XLF23 XLF_EFI_HANDOVER_32\t\t/* 32-bit EFI handover ok */\n#  endif\n# endif\n#else\n# define XLF23 0\n#endif\n\n#if defined(CONFIG_X86_64) && defined(CONFIG_EFI) && defined(CONFIG_KEXEC_CORE)\n# define XLF4 XLF_EFI_KEXEC\n#else\n# define XLF4 0\n#endif\n\n#ifdef CONFIG_X86_64\n#ifdef CONFIG_X86_5LEVEL\n#define XLF56 (XLF_5LEVEL|XLF_5LEVEL_ENABLED)\n#else\n#define XLF56 XLF_5LEVEL\n#endif\n#else\n#define XLF56 0\n#endif\n\n\t\t\t.word XLF0 | XLF1 | XLF23 | XLF4 | XLF56\n\ncmdline_size:   .long   COMMAND_LINE_SIZE-1     #length of the command line,\n                                                #added with boot protocol\n                                                #version 2.06\n\nhardware_subarch:\t.long 0\t\t\t# subarchitecture, added with 2.07\n\t\t\t\t\t\t# default to 0 for normal x86 PC\n\nhardware_subarch_data:\t.quad 0\n\npayload_offset:\t\t.long ZO_input_data\npayload_length:\t\t.long ZO_z_input_len\n\nsetup_data:\t\t.quad 0\t\t\t# 64-bit physical pointer to\n\t\t\t\t\t\t# single linked list of\n\t\t\t\t\t\t# struct setup_data\n\npref_address:\t\t.quad LOAD_PHYSICAL_ADDR\t# preferred load addr\n\n#\n# Getting to provably safe in-place decompression is hard. Worst case\n# behaviours need to be analyzed. Here let's take the decompression of\n# a gzip-compressed kernel as example, to illustrate it:\n#\n# The file layout of gzip compressed kernel is:\n#\n#    magic[2]\n#    method[1]\n#    flags[1]\n#    timestamp[4]\n#    extraflags[1]\n#    os[1]\n#    compressed data blocks[N]\n#    crc[4] orig_len[4]\n#\n# ... resulting in +18 bytes overhead of uncompressed data.\n#\n# (For more information, please refer to RFC 1951 and RFC 1952.)\n#\n# Files divided into blocks\n# 1 bit (last block flag)\n# 2 bits (block type)\n#\n# 1 block occurs every 32K -1 bytes or when there 50% compression\n# has been achieved. The smallest block type encoding is always used.\n#\n# stored:\n#    32 bits length in bytes.\n#\n# fixed:\n#    magic fixed tree.\n#    symbols.\n#\n# dynamic:\n#    dynamic tree encoding.\n#    symbols.\n#\n#\n# The buffer for decompression in place is the length of the uncompressed\n# data, plus a small amount extra to keep the algorithm safe. The\n# compressed data is placed at the end of the buffer.  The output pointer\n# is placed at the start of the buffer and the input pointer is placed\n# where the compressed data starts. Problems will occur when the output\n# pointer overruns the input pointer.\n#\n# The output pointer can only overrun the input pointer if the input\n# pointer is moving faster than the output pointer.  A condition only\n# triggered by data whose compressed form is larger than the uncompressed\n# form.\n#\n# The worst case at the block level is a growth of the compressed data\n# of 5 bytes per 32767 bytes.\n#\n# The worst case internal to a compressed block is very hard to figure.\n# The worst case can at least be bounded by having one bit that represents\n# 32764 bytes and then all of the rest of the bytes representing the very\n# very last byte.\n#\n# All of which is enough to compute an amount of extra data that is required\n# to be safe.  To avoid problems at the block level allocating 5 extra bytes\n# per 32767 bytes of data is sufficient.  To avoid problems internal to a\n# block adding an extra 32767 bytes (the worst case uncompressed block size)\n# is sufficient, to ensure that in the worst case the decompressed data for\n# block will stop the byte before the compressed data for a block begins.\n# To avoid problems with the compressed data's meta information an extra 18\n# bytes are needed.  Leading to the formula:\n#\n# extra_bytes = (uncompressed_size >> 12) + 32768 + 18\n#\n# Adding 8 bytes per 32K is a bit excessive but much easier to calculate.\n# Adding 32768 instead of 32767 just makes for round numbers.\n#\n# Above analysis is for decompressing gzip compressed kernel only. Up to\n# now 6 different decompressor are supported all together. And among them\n# xz stores data in chunks and has maximum chunk of 64K. Hence safety\n# margin should be updated to cover all decompressors so that we don't\n# need to deal with each of them separately. Please check\n# the description in lib/decompressor_xxx.c for specific information.\n#\n# extra_bytes = (uncompressed_size >> 12) + 65536 + 128\n#\n# LZ4 is even worse: data that cannot be further compressed grows by 0.4%,\n# or one byte per 256 bytes. OTOH, we can safely get rid of the +128 as\n# the size-dependent part now grows so fast.\n#\n# extra_bytes = (uncompressed_size >> 8) + 65536\n#\n# ZSTD compressed data grows by at most 3 bytes per 128K, and only has a 22\n# byte fixed overhead but has a maximum block size of 128K, so it needs a\n# larger margin.\n#\n# extra_bytes = (uncompressed_size >> 8) + 131072\n\n#define ZO_z_extra_bytes\t((ZO_z_output_len >> 8) + 131072)\n#if ZO_z_output_len > ZO_z_input_len\n# define ZO_z_extract_offset\t(ZO_z_output_len + ZO_z_extra_bytes - \\\n\t\t\t\t ZO_z_input_len)\n#else\n# define ZO_z_extract_offset\tZO_z_extra_bytes\n#endif\n\n \n#if (ZO__ehead - ZO_startup_32) > ZO_z_extract_offset\n# define ZO_z_min_extract_offset ((ZO__ehead - ZO_startup_32 + 4095) & ~4095)\n#else\n# define ZO_z_min_extract_offset ((ZO_z_extract_offset + 4095) & ~4095)\n#endif\n\n#define ZO_INIT_SIZE\t(ZO__end - ZO_startup_32 + ZO_z_min_extract_offset)\n\n#define VO_INIT_SIZE\t(VO__end - VO__text)\n#if ZO_INIT_SIZE > VO_INIT_SIZE\n# define INIT_SIZE ZO_INIT_SIZE\n#else\n# define INIT_SIZE VO_INIT_SIZE\n#endif\n\ninit_size:\t\t.long INIT_SIZE\t\t# kernel initialization size\nhandover_offset:\t.long 0\t\t\t# Filled in by build.c\nkernel_info_offset:\t.long 0\t\t\t# Filled in by build.c\n\n# End of setup header #####################################################\n\n\t.section \".entrytext\", \"ax\"\nstart_of_setup:\n# Force %es = %ds\n\tmovw\t%ds, %ax\n\tmovw\t%ax, %es\n\tcld\n\n# Apparently some ancient versions of LILO invoked the kernel with %ss != %ds,\n# which happened to work by accident for the old code.  Recalculate the stack\n# pointer if %ss is invalid.  Otherwise leave it alone, LOADLIN sets up the\n# stack behind its own code, so we can't blindly put it directly past the heap.\n\n\tmovw\t%ss, %dx\n\tcmpw\t%ax, %dx\t# %ds == %ss?\n\tmovw\t%sp, %dx\n\tje\t2f\t\t# -> assume %sp is reasonably set\n\n\t# Invalid %ss, make up a new stack\n\tmovw\t$_end, %dx\n\ttestb\t$CAN_USE_HEAP, loadflags\n\tjz\t1f\n\tmovw\theap_end_ptr, %dx\n1:\taddw\t$STACK_SIZE, %dx\n\tjnc\t2f\n\txorw\t%dx, %dx\t# Prevent wraparound\n\n2:\t# Now %dx should point to the end of our stack space\n\tandw\t$~3, %dx\t# dword align (might as well...)\n\tjnz\t3f\n\tmovw\t$0xfffc, %dx\t# Make sure we're not zero\n3:\tmovw\t%ax, %ss\n\tmovzwl\t%dx, %esp\t# Clear upper half of %esp\n\tsti\t\t\t# Now we should have a working stack\n\n# We will have entered with %cs = %ds+0x20, normalize %cs so\n# it is on par with the other segments.\n\tpushw\t%ds\n\tpushw\t$6f\n\tlretw\n6:\n\n# Check signature at end of setup\n\tcmpl\t$0x5a5aaa55, setup_sig\n\tjne\tsetup_bad\n\n# Zero the bss\n\tmovw\t$__bss_start, %di\n\tmovw\t$_end+3, %cx\n\txorl\t%eax, %eax\n\tsubw\t%di, %cx\n\tshrw\t$2, %cx\n\trep; stosl\n\n# Jump to C code (should not return)\n\tcalll\tmain\n\n# Setup corrupt somehow...\nsetup_bad:\n\tmovl\t$setup_corrupt, %eax\n\tcalll\tputs\n\t# Fall through...\n\n\t.globl\tdie\n\t.type\tdie, @function\ndie:\n\thlt\n\tjmp\tdie\n\n\t.size\tdie, .-die\n\n\t.section \".initdata\", \"a\"\nsetup_corrupt:\n\t.byte\t7\n\t.string\t\"No setup signature found...\\n\"\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}