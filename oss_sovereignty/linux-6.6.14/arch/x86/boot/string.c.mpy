{
  "module_name": "string.c",
  "hash_id": "4bc64e33840eb8428b75ba00780b08b441b1b080ca60356f38a31c0c8d6ede4f",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/string.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <linux/errno.h>\n#include <linux/limits.h>\n#include <asm/asm.h>\n#include \"ctype.h\"\n#include \"string.h\"\n\n#define KSTRTOX_OVERFLOW       (1U << 31)\n\n \n#undef memcpy\n#undef memset\n#undef memcmp\n\nint memcmp(const void *s1, const void *s2, size_t len)\n{\n\tbool diff;\n\tasm(\"repe; cmpsb\" CC_SET(nz)\n\t    : CC_OUT(nz) (diff), \"+D\" (s1), \"+S\" (s2), \"+c\" (len));\n\treturn diff;\n}\n\n \nint bcmp(const void *s1, const void *s2, size_t len)\n{\n\treturn memcmp(s1, s2, len);\n}\n\nint strcmp(const char *str1, const char *str2)\n{\n\tconst unsigned char *s1 = (const unsigned char *)str1;\n\tconst unsigned char *s2 = (const unsigned char *)str2;\n\tint delta = 0;\n\n\twhile (*s1 || *s2) {\n\t\tdelta = *s1 - *s2;\n\t\tif (delta)\n\t\t\treturn delta;\n\t\ts1++;\n\t\ts2++;\n\t}\n\treturn 0;\n}\n\nint strncmp(const char *cs, const char *ct, size_t count)\n{\n\tunsigned char c1, c2;\n\n\twhile (count) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t\tcount--;\n\t}\n\treturn 0;\n}\n\nsize_t strnlen(const char *s, size_t maxlen)\n{\n\tconst char *es = s;\n\twhile (*es && maxlen) {\n\t\tes++;\n\t\tmaxlen--;\n\t}\n\n\treturn (es - s);\n}\n\nunsigned int atou(const char *s)\n{\n\tunsigned int i = 0;\n\twhile (isdigit(*s))\n\t\ti = i * 10 + (*s++ - '0');\n\treturn i;\n}\n\n \n#define TOLOWER(x) ((x) | 0x20)\n\nstatic unsigned int simple_guess_base(const char *cp)\n{\n\tif (cp[0] == '0') {\n\t\tif (TOLOWER(cp[1]) == 'x' && isxdigit(cp[2]))\n\t\t\treturn 16;\n\t\telse\n\t\t\treturn 8;\n\t} else {\n\t\treturn 10;\n\t}\n}\n\n \nunsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base)\n{\n\tunsigned long long result = 0;\n\n\tif (!base)\n\t\tbase = simple_guess_base(cp);\n\n\tif (base == 16 && cp[0] == '0' && TOLOWER(cp[1]) == 'x')\n\t\tcp += 2;\n\n\twhile (isxdigit(*cp)) {\n\t\tunsigned int value;\n\n\t\tvalue = isdigit(*cp) ? *cp - '0' : TOLOWER(*cp) - 'a' + 10;\n\t\tif (value >= base)\n\t\t\tbreak;\n\t\tresult = result * base + value;\n\t\tcp++;\n\t}\n\tif (endp)\n\t\t*endp = (char *)cp;\n\n\treturn result;\n}\n\nlong simple_strtol(const char *cp, char **endp, unsigned int base)\n{\n\tif (*cp == '-')\n\t\treturn -simple_strtoull(cp + 1, endp, base);\n\n\treturn simple_strtoull(cp, endp, base);\n}\n\n \nsize_t strlen(const char *s)\n{\n\tconst char *sc;\n\n\tfor (sc = s; *sc != '\\0'; ++sc)\n\t\t ;\n\treturn sc - s;\n}\n\n \nchar *strstr(const char *s1, const char *s2)\n{\n\tsize_t l1, l2;\n\n\tl2 = strlen(s2);\n\tif (!l2)\n\t\treturn (char *)s1;\n\tl1 = strlen(s1);\n\twhile (l1 >= l2) {\n\t\tl1--;\n\t\tif (!memcmp(s1, s2, l2))\n\t\t\treturn (char *)s1;\n\t\ts1++;\n\t}\n\treturn NULL;\n}\n\n \nchar *strchr(const char *s, int c)\n{\n\twhile (*s != (char)c)\n\t\tif (*s++ == '\\0')\n\t\t\treturn NULL;\n\treturn (char *)s;\n}\n\nstatic inline u64 __div_u64_rem(u64 dividend, u32 divisor, u32 *remainder)\n{\n\tunion {\n\t\tu64 v64;\n\t\tu32 v32[2];\n\t} d = { dividend };\n\tu32 upper;\n\n\tupper = d.v32[1];\n\td.v32[1] = 0;\n\tif (upper >= divisor) {\n\t\td.v32[1] = upper / divisor;\n\t\tupper %= divisor;\n\t}\n\tasm (\"divl %2\" : \"=a\" (d.v32[0]), \"=d\" (*remainder) :\n\t\t\"rm\" (divisor), \"0\" (d.v32[0]), \"1\" (upper));\n\treturn d.v64;\n}\n\nstatic inline u64 __div_u64(u64 dividend, u32 divisor)\n{\n\tu32 remainder;\n\n\treturn __div_u64_rem(dividend, divisor, &remainder);\n}\n\nstatic inline char _tolower(const char c)\n{\n\treturn c | 0x20;\n}\n\nstatic const char *_parse_integer_fixup_radix(const char *s, unsigned int *base)\n{\n\tif (*base == 0) {\n\t\tif (s[0] == '0') {\n\t\t\tif (_tolower(s[1]) == 'x' && isxdigit(s[2]))\n\t\t\t\t*base = 16;\n\t\t\telse\n\t\t\t\t*base = 8;\n\t\t} else\n\t\t\t*base = 10;\n\t}\n\tif (*base == 16 && s[0] == '0' && _tolower(s[1]) == 'x')\n\t\ts += 2;\n\treturn s;\n}\n\n \nstatic unsigned int _parse_integer(const char *s,\n\t\t\t\t   unsigned int base,\n\t\t\t\t   unsigned long long *p)\n{\n\tunsigned long long res;\n\tunsigned int rv;\n\n\tres = 0;\n\trv = 0;\n\twhile (1) {\n\t\tunsigned int c = *s;\n\t\tunsigned int lc = c | 0x20;  \n\t\tunsigned int val;\n\n\t\tif ('0' <= c && c <= '9')\n\t\t\tval = c - '0';\n\t\telse if ('a' <= lc && lc <= 'f')\n\t\t\tval = lc - 'a' + 10;\n\t\telse\n\t\t\tbreak;\n\n\t\tif (val >= base)\n\t\t\tbreak;\n\t\t \n\t\tif (unlikely(res & (~0ull << 60))) {\n\t\t\tif (res > __div_u64(ULLONG_MAX - val, base))\n\t\t\t\trv |= KSTRTOX_OVERFLOW;\n\t\t}\n\t\tres = res * base + val;\n\t\trv++;\n\t\ts++;\n\t}\n\t*p = res;\n\treturn rv;\n}\n\nstatic int _kstrtoull(const char *s, unsigned int base, unsigned long long *res)\n{\n\tunsigned long long _res;\n\tunsigned int rv;\n\n\ts = _parse_integer_fixup_radix(s, &base);\n\trv = _parse_integer(s, base, &_res);\n\tif (rv & KSTRTOX_OVERFLOW)\n\t\treturn -ERANGE;\n\tif (rv == 0)\n\t\treturn -EINVAL;\n\ts += rv;\n\tif (*s == '\\n')\n\t\ts++;\n\tif (*s)\n\t\treturn -EINVAL;\n\t*res = _res;\n\treturn 0;\n}\n\n \nint kstrtoull(const char *s, unsigned int base, unsigned long long *res)\n{\n\tif (s[0] == '+')\n\t\ts++;\n\treturn _kstrtoull(s, base, res);\n}\n\nstatic int _kstrtoul(const char *s, unsigned int base, unsigned long *res)\n{\n\tunsigned long long tmp;\n\tint rv;\n\n\trv = kstrtoull(s, base, &tmp);\n\tif (rv < 0)\n\t\treturn rv;\n\tif (tmp != (unsigned long)tmp)\n\t\treturn -ERANGE;\n\t*res = tmp;\n\treturn 0;\n}\n\n \nint boot_kstrtoul(const char *s, unsigned int base, unsigned long *res)\n{\n\t \n\tif (sizeof(unsigned long) == sizeof(unsigned long long) &&\n\t    __alignof__(unsigned long) == __alignof__(unsigned long long))\n\t\treturn kstrtoull(s, base, (unsigned long long *)res);\n\telse\n\t\treturn _kstrtoul(s, base, res);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}