{
  "module_name": "memory.c",
  "hash_id": "cf2a4bdf44d623991eaa3b43e95401710c094ff57e1e5b027fe7f6148def5286",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/memory.c",
  "human_readable_source": "\n \n\n \n\n#include \"boot.h\"\n\n#define SMAP\t0x534d4150\t \n\nstatic void detect_memory_e820(void)\n{\n\tint count = 0;\n\tstruct biosregs ireg, oreg;\n\tstruct boot_e820_entry *desc = boot_params.e820_table;\n\tstatic struct boot_e820_entry buf;  \n\n\tinitregs(&ireg);\n\tireg.ax  = 0xe820;\n\tireg.cx  = sizeof(buf);\n\tireg.edx = SMAP;\n\tireg.di  = (size_t)&buf;\n\n\t \n\n\tdo {\n\t\tintcall(0x15, &ireg, &oreg);\n\t\tireg.ebx = oreg.ebx;  \n\n\t\t \n\t\tif (oreg.eflags & X86_EFLAGS_CF)\n\t\t\tbreak;\n\n\t\t \n\t\tif (oreg.eax != SMAP) {\n\t\t\tcount = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t*desc++ = buf;\n\t\tcount++;\n\t} while (ireg.ebx && count < ARRAY_SIZE(boot_params.e820_table));\n\n\tboot_params.e820_entries = count;\n}\n\nstatic void detect_memory_e801(void)\n{\n\tstruct biosregs ireg, oreg;\n\n\tinitregs(&ireg);\n\tireg.ax = 0xe801;\n\tintcall(0x15, &ireg, &oreg);\n\n\tif (oreg.eflags & X86_EFLAGS_CF)\n\t\treturn;\n\n\t \n\tif (oreg.cx || oreg.dx) {\n\t\toreg.ax = oreg.cx;\n\t\toreg.bx = oreg.dx;\n\t}\n\n\tif (oreg.ax > 15*1024) {\n\t\treturn;\t \n\t} else if (oreg.ax == 15*1024) {\n\t\tboot_params.alt_mem_k = (oreg.bx << 6) + oreg.ax;\n\t} else {\n\t\t \n\t\tboot_params.alt_mem_k = oreg.ax;\n\t}\n}\n\nstatic void detect_memory_88(void)\n{\n\tstruct biosregs ireg, oreg;\n\n\tinitregs(&ireg);\n\tireg.ah = 0x88;\n\tintcall(0x15, &ireg, &oreg);\n\n\tboot_params.screen_info.ext_mem_k = oreg.ax;\n}\n\nvoid detect_memory(void)\n{\n\tdetect_memory_e820();\n\n\tdetect_memory_e801();\n\n\tdetect_memory_88();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}