{
  "module_name": "edd.c",
  "hash_id": "8db91c9f2d0abe58f864e8d1831b05f581958233c0ba163e1d0baf4fbe194c7b",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/boot/edd.c",
  "human_readable_source": "\n \n\n \n\n#include \"boot.h\"\n#include <linux/edd.h>\n#include \"string.h\"\n\n#if defined(CONFIG_EDD) || defined(CONFIG_EDD_MODULE)\n\n \nstatic int read_mbr(u8 devno, void *buf)\n{\n\tstruct biosregs ireg, oreg;\n\n\tinitregs(&ireg);\n\tireg.ax = 0x0201;\t\t \n\tireg.cx = 0x0001;\t\t \n\tireg.dl = devno;\n\tireg.bx = (size_t)buf;\n\n\tintcall(0x13, &ireg, &oreg);\n\n\treturn -(oreg.eflags & X86_EFLAGS_CF);  \n}\n\nstatic u32 read_mbr_sig(u8 devno, struct edd_info *ei, u32 *mbrsig)\n{\n\tint sector_size;\n\tchar *mbrbuf_ptr, *mbrbuf_end;\n\tu32 buf_base, mbr_base;\n\textern char _end[];\n\tu16 mbr_magic;\n\n\tsector_size = ei->params.bytes_per_sector;\n\tif (!sector_size)\n\t\tsector_size = 512;  \n\n\t \n\tbuf_base = (ds() << 4) + (u32)&_end;\n\tmbr_base = (buf_base+sector_size-1) & ~(sector_size-1);\n\tmbrbuf_ptr = _end + (mbr_base-buf_base);\n\tmbrbuf_end = mbrbuf_ptr + sector_size;\n\n\t \n\tif (!(boot_params.hdr.loadflags & CAN_USE_HEAP))\n\t\treturn -1;\n\tif (mbrbuf_end > (char *)(size_t)boot_params.hdr.heap_end_ptr)\n\t\treturn -1;\n\n\tmemset(mbrbuf_ptr, 0, sector_size);\n\tif (read_mbr(devno, mbrbuf_ptr))\n\t\treturn -1;\n\n\t*mbrsig = *(u32 *)&mbrbuf_ptr[EDD_MBR_SIG_OFFSET];\n\tmbr_magic = *(u16 *)&mbrbuf_ptr[510];\n\n\t \n\treturn mbr_magic == 0xAA55 ? 0 : -1;\n}\n\nstatic int get_edd_info(u8 devno, struct edd_info *ei)\n{\n\tstruct biosregs ireg, oreg;\n\n\tmemset(ei, 0, sizeof(*ei));\n\n\t \n\n\tinitregs(&ireg);\n\tireg.ah = 0x41;\n\tireg.bx = EDDMAGIC1;\n\tireg.dl = devno;\n\tintcall(0x13, &ireg, &oreg);\n\n\tif (oreg.eflags & X86_EFLAGS_CF)\n\t\treturn -1;\t \n\n\tif (oreg.bx != EDDMAGIC2)\n\t\treturn -1;\n\n\tei->device  = devno;\n\tei->version = oreg.ah;\t\t  \n\tei->interface_support = oreg.cx;  \n\n\t \n\n\tei->params.length = sizeof(ei->params);\n\tireg.ah = 0x48;\n\tireg.si = (size_t)&ei->params;\n\tintcall(0x13, &ireg, &oreg);\n\n\t \n\n\t \n\tireg.ah = 0x08;\n\tireg.es = 0;\n\tintcall(0x13, &ireg, &oreg);\n\n\tif (!(oreg.eflags & X86_EFLAGS_CF)) {\n\t\tei->legacy_max_cylinder = oreg.ch + ((oreg.cl & 0xc0) << 2);\n\t\tei->legacy_max_head = oreg.dh;\n\t\tei->legacy_sectors_per_track = oreg.cl & 0x3f;\n\t}\n\n\treturn 0;\n}\n\nvoid query_edd(void)\n{\n\tchar eddarg[8];\n\tint do_mbr = 1;\n#ifdef CONFIG_EDD_OFF\n\tint do_edd = 0;\n#else\n\tint do_edd = 1;\n#endif\n\tint be_quiet;\n\tint devno;\n\tstruct edd_info ei, *edp;\n\tu32 *mbrptr;\n\n\tif (cmdline_find_option(\"edd\", eddarg, sizeof(eddarg)) > 0) {\n\t\tif (!strcmp(eddarg, \"skipmbr\") || !strcmp(eddarg, \"skip\")) {\n\t\t\tdo_edd = 1;\n\t\t\tdo_mbr = 0;\n\t\t}\n\t\telse if (!strcmp(eddarg, \"off\"))\n\t\t\tdo_edd = 0;\n\t\telse if (!strcmp(eddarg, \"on\"))\n\t\t\tdo_edd = 1;\n\t}\n\n\tbe_quiet = cmdline_find_option_bool(\"quiet\");\n\n\tedp    = boot_params.eddbuf;\n\tmbrptr = boot_params.edd_mbr_sig_buffer;\n\n\tif (!do_edd)\n\t\treturn;\n\n\t \n\n\tif (!be_quiet)\n\t\tprintf(\"Probing EDD (edd=off to disable)... \");\n\n\tfor (devno = 0x80; devno < 0x80+EDD_MBR_SIG_MAX; devno++) {\n\t\t \n\t\tif (!get_edd_info(devno, &ei)\n\t\t    && boot_params.eddbuf_entries < EDDMAXNR) {\n\t\t\tmemcpy(edp, &ei, sizeof(ei));\n\t\t\tedp++;\n\t\t\tboot_params.eddbuf_entries++;\n\t\t}\n\n\t\tif (do_mbr && !read_mbr_sig(devno, &ei, mbrptr++))\n\t\t\tboot_params.edd_mbr_sig_buf_entries = devno-0x80+1;\n\t}\n\n\tif (!be_quiet)\n\t\tprintf(\"ok\\n\");\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}