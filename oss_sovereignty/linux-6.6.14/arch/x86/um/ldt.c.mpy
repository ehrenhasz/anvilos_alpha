{
  "module_name": "ldt.c",
  "hash_id": "44c5501f21f7a853e05b5223b55a37db5a166136ed49faabba152e208340c126",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/um/ldt.c",
  "human_readable_source": " \n\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <asm/unistd.h>\n#include <os.h>\n#include <skas.h>\n#include <sysdep/tls.h>\n\nstatic inline int modify_ldt (int func, void *ptr, unsigned long bytecount)\n{\n\treturn syscall(__NR_modify_ldt, func, ptr, bytecount);\n}\n\nstatic long write_ldt_entry(struct mm_id *mm_idp, int func,\n\t\t     struct user_desc *desc, void **addr, int done)\n{\n\tlong res;\n\tvoid *stub_addr;\n\n\tBUILD_BUG_ON(sizeof(*desc) % sizeof(long));\n\n\tres = syscall_stub_data(mm_idp, (unsigned long *)desc,\n\t\t\t\tsizeof(*desc) / sizeof(long),\n\t\t\t\taddr, &stub_addr);\n\tif (!res) {\n\t\tunsigned long args[] = { func,\n\t\t\t\t\t (unsigned long)stub_addr,\n\t\t\t\t\t sizeof(*desc),\n\t\t\t\t\t 0, 0, 0 };\n\t\tres = run_syscall_stub(mm_idp, __NR_modify_ldt, args,\n\t\t\t\t       0, addr, done);\n\t}\n\n\treturn res;\n}\n\n \n\nstatic int read_ldt(void __user * ptr, unsigned long bytecount)\n{\n\tint i, err = 0;\n\tunsigned long size;\n\tuml_ldt_t *ldt = &current->mm->context.arch.ldt;\n\n\tif (!ldt->entry_count)\n\t\tgoto out;\n\tif (bytecount > LDT_ENTRY_SIZE*LDT_ENTRIES)\n\t\tbytecount = LDT_ENTRY_SIZE*LDT_ENTRIES;\n\terr = bytecount;\n\n\tmutex_lock(&ldt->lock);\n\tif (ldt->entry_count <= LDT_DIRECT_ENTRIES) {\n\t\tsize = LDT_ENTRY_SIZE*LDT_DIRECT_ENTRIES;\n\t\tif (size > bytecount)\n\t\t\tsize = bytecount;\n\t\tif (copy_to_user(ptr, ldt->u.entries, size))\n\t\t\terr = -EFAULT;\n\t\tbytecount -= size;\n\t\tptr += size;\n\t}\n\telse {\n\t\tfor (i=0; i<ldt->entry_count/LDT_ENTRIES_PER_PAGE && bytecount;\n\t\t     i++) {\n\t\t\tsize = PAGE_SIZE;\n\t\t\tif (size > bytecount)\n\t\t\t\tsize = bytecount;\n\t\t\tif (copy_to_user(ptr, ldt->u.pages[i], size)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbytecount -= size;\n\t\t\tptr += size;\n\t\t}\n\t}\n\tmutex_unlock(&ldt->lock);\n\n\tif (bytecount == 0 || err == -EFAULT)\n\t\tgoto out;\n\n\tif (clear_user(ptr, bytecount))\n\t\terr = -EFAULT;\n\nout:\n\treturn err;\n}\n\nstatic int read_default_ldt(void __user * ptr, unsigned long bytecount)\n{\n\tint err;\n\n\tif (bytecount > 5*LDT_ENTRY_SIZE)\n\t\tbytecount = 5*LDT_ENTRY_SIZE;\n\n\terr = bytecount;\n\t \n\tif (clear_user(ptr, bytecount))\n\t\terr = -EFAULT;\n\n\treturn err;\n}\n\nstatic int write_ldt(void __user * ptr, unsigned long bytecount, int func)\n{\n\tuml_ldt_t *ldt = &current->mm->context.arch.ldt;\n\tstruct mm_id * mm_idp = &current->mm->context.id;\n\tint i, err;\n\tstruct user_desc ldt_info;\n\tstruct ldt_entry entry0, *ldt_p;\n\tvoid *addr = NULL;\n\n\terr = -EINVAL;\n\tif (bytecount != sizeof(ldt_info))\n\t\tgoto out;\n\terr = -EFAULT;\n\tif (copy_from_user(&ldt_info, ptr, sizeof(ldt_info)))\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif (ldt_info.entry_number >= LDT_ENTRIES)\n\t\tgoto out;\n\tif (ldt_info.contents == 3) {\n\t\tif (func == 1)\n\t\t\tgoto out;\n\t\tif (ldt_info.seg_not_present == 0)\n\t\t\tgoto out;\n\t}\n\n\tmutex_lock(&ldt->lock);\n\n\terr = write_ldt_entry(mm_idp, func, &ldt_info, &addr, 1);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tif (ldt_info.entry_number >= ldt->entry_count &&\n\t    ldt_info.entry_number >= LDT_DIRECT_ENTRIES) {\n\t\tfor (i=ldt->entry_count/LDT_ENTRIES_PER_PAGE;\n\t\t     i*LDT_ENTRIES_PER_PAGE <= ldt_info.entry_number;\n\t\t     i++) {\n\t\t\tif (i == 0)\n\t\t\t\tmemcpy(&entry0, ldt->u.entries,\n\t\t\t\t       sizeof(entry0));\n\t\t\tldt->u.pages[i] = (struct ldt_entry *)\n\t\t\t\t__get_free_page(GFP_KERNEL|__GFP_ZERO);\n\t\t\tif (!ldt->u.pages[i]) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\t \n\t\t\t\tmemset(&ldt_info, 0, sizeof(ldt_info));\n\t\t\t\twrite_ldt_entry(mm_idp, 1, &ldt_info, &addr, 1);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\tmemcpy(ldt->u.pages[0], &entry0,\n\t\t\t\t       sizeof(entry0));\n\t\t\t\tmemcpy(ldt->u.pages[0]+1, ldt->u.entries+1,\n\t\t\t\t       sizeof(entry0)*(LDT_DIRECT_ENTRIES-1));\n\t\t\t}\n\t\t\tldt->entry_count = (i + 1) * LDT_ENTRIES_PER_PAGE;\n\t\t}\n\t}\n\tif (ldt->entry_count <= ldt_info.entry_number)\n\t\tldt->entry_count = ldt_info.entry_number + 1;\n\n\tif (ldt->entry_count <= LDT_DIRECT_ENTRIES)\n\t\tldt_p = ldt->u.entries + ldt_info.entry_number;\n\telse\n\t\tldt_p = ldt->u.pages[ldt_info.entry_number/LDT_ENTRIES_PER_PAGE] +\n\t\t\tldt_info.entry_number%LDT_ENTRIES_PER_PAGE;\n\n\tif (ldt_info.base_addr == 0 && ldt_info.limit == 0 &&\n\t   (func == 1 || LDT_empty(&ldt_info))) {\n\t\tldt_p->a = 0;\n\t\tldt_p->b = 0;\n\t}\n\telse{\n\t\tif (func == 1)\n\t\t\tldt_info.useable = 0;\n\t\tldt_p->a = LDT_entry_a(&ldt_info);\n\t\tldt_p->b = LDT_entry_b(&ldt_info);\n\t}\n\terr = 0;\n\nout_unlock:\n\tmutex_unlock(&ldt->lock);\nout:\n\treturn err;\n}\n\nstatic long do_modify_ldt_skas(int func, void __user *ptr,\n\t\t\t       unsigned long bytecount)\n{\n\tint ret = -ENOSYS;\n\n\tswitch (func) {\n\t\tcase 0:\n\t\t\tret = read_ldt(ptr, bytecount);\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 0x11:\n\t\t\tret = write_ldt(ptr, bytecount, func);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret = read_default_ldt(ptr, bytecount);\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic DEFINE_SPINLOCK(host_ldt_lock);\nstatic short dummy_list[9] = {0, -1};\nstatic short * host_ldt_entries = NULL;\n\nstatic void ldt_get_host_info(void)\n{\n\tlong ret;\n\tstruct ldt_entry * ldt;\n\tshort *tmp;\n\tint i, size, k, order;\n\n\tspin_lock(&host_ldt_lock);\n\n\tif (host_ldt_entries != NULL) {\n\t\tspin_unlock(&host_ldt_lock);\n\t\treturn;\n\t}\n\thost_ldt_entries = dummy_list+1;\n\n\tspin_unlock(&host_ldt_lock);\n\n\tfor (i = LDT_PAGES_MAX-1, order=0; i; i>>=1, order++)\n\t\t;\n\n\tldt = (struct ldt_entry *)\n\t      __get_free_pages(GFP_KERNEL|__GFP_ZERO, order);\n\tif (ldt == NULL) {\n\t\tprintk(KERN_ERR \"ldt_get_host_info: couldn't allocate buffer \"\n\t\t       \"for host ldt\\n\");\n\t\treturn;\n\t}\n\n\tret = modify_ldt(0, ldt, (1<<order)*PAGE_SIZE);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"ldt_get_host_info: couldn't read host ldt\\n\");\n\t\tgoto out_free;\n\t}\n\tif (ret == 0) {\n\t\t \n\t\thost_ldt_entries = dummy_list;\n\t\tgoto out_free;\n\t}\n\n\tfor (i=0, size=0; i<ret/LDT_ENTRY_SIZE; i++) {\n\t\tif (ldt[i].a != 0 || ldt[i].b != 0)\n\t\t\tsize++;\n\t}\n\n\tif (size < ARRAY_SIZE(dummy_list))\n\t\thost_ldt_entries = dummy_list;\n\telse {\n\t\tsize = (size + 1) * sizeof(dummy_list[0]);\n\t\ttmp = kmalloc(size, GFP_KERNEL);\n\t\tif (tmp == NULL) {\n\t\t\tprintk(KERN_ERR \"ldt_get_host_info: couldn't allocate \"\n\t\t\t       \"host ldt list\\n\");\n\t\t\tgoto out_free;\n\t\t}\n\t\thost_ldt_entries = tmp;\n\t}\n\n\tfor (i=0, k=0; i<ret/LDT_ENTRY_SIZE; i++) {\n\t\tif (ldt[i].a != 0 || ldt[i].b != 0)\n\t\t\thost_ldt_entries[k++] = i;\n\t}\n\thost_ldt_entries[k] = -1;\n\nout_free:\n\tfree_pages((unsigned long)ldt, order);\n}\n\nlong init_new_ldt(struct mm_context *new_mm, struct mm_context *from_mm)\n{\n\tstruct user_desc desc;\n\tshort * num_p;\n\tint i;\n\tlong page, err=0;\n\tvoid *addr = NULL;\n\n\n\tmutex_init(&new_mm->arch.ldt.lock);\n\n\tif (!from_mm) {\n\t\tmemset(&desc, 0, sizeof(desc));\n\t\t \n\t\tldt_get_host_info();\n\t\tfor (num_p=host_ldt_entries; *num_p != -1; num_p++) {\n\t\t\tdesc.entry_number = *num_p;\n\t\t\terr = write_ldt_entry(&new_mm->id, 1, &desc,\n\t\t\t\t\t      &addr, *(num_p + 1) == -1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\tnew_mm->arch.ldt.entry_count = 0;\n\n\t\tgoto out;\n\t}\n\n\t \n\tmutex_lock(&from_mm->arch.ldt.lock);\n\tif (from_mm->arch.ldt.entry_count <= LDT_DIRECT_ENTRIES)\n\t\tmemcpy(new_mm->arch.ldt.u.entries, from_mm->arch.ldt.u.entries,\n\t\t       sizeof(new_mm->arch.ldt.u.entries));\n\telse {\n\t\ti = from_mm->arch.ldt.entry_count / LDT_ENTRIES_PER_PAGE;\n\t\twhile (i-->0) {\n\t\t\tpage = __get_free_page(GFP_KERNEL|__GFP_ZERO);\n\t\t\tif (!page) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnew_mm->arch.ldt.u.pages[i] =\n\t\t\t\t(struct ldt_entry *) page;\n\t\t\tmemcpy(new_mm->arch.ldt.u.pages[i],\n\t\t\t       from_mm->arch.ldt.u.pages[i], PAGE_SIZE);\n\t\t}\n\t}\n\tnew_mm->arch.ldt.entry_count = from_mm->arch.ldt.entry_count;\n\tmutex_unlock(&from_mm->arch.ldt.lock);\n\n    out:\n\treturn err;\n}\n\n\nvoid free_ldt(struct mm_context *mm)\n{\n\tint i;\n\n\tif (mm->arch.ldt.entry_count > LDT_DIRECT_ENTRIES) {\n\t\ti = mm->arch.ldt.entry_count / LDT_ENTRIES_PER_PAGE;\n\t\twhile (i-- > 0)\n\t\t\tfree_page((long) mm->arch.ldt.u.pages[i]);\n\t}\n\tmm->arch.ldt.entry_count = 0;\n}\n\nSYSCALL_DEFINE3(modify_ldt, int , func , void __user * , ptr ,\n\t\tunsigned long , bytecount)\n{\n\t \n\treturn (unsigned int)do_modify_ldt_skas(func, ptr, bytecount);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}