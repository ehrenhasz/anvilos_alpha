{
  "module_name": "elf.h",
  "hash_id": "fdba4405810f7af3bc40d1a092f38613f049b610b612e2c4c5c5963b742d2446",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/um/asm/elf.h",
  "human_readable_source": " \n#ifndef __UM_ELF_X86_H\n#define __UM_ELF_X86_H\n\n#include <asm/user.h>\n#include <skas.h>\n\n#ifdef CONFIG_X86_32\n\n#define R_386_NONE\t0\n#define R_386_32\t1\n#define R_386_PC32\t2\n#define R_386_GOT32\t3\n#define R_386_PLT32\t4\n#define R_386_COPY\t5\n#define R_386_GLOB_DAT\t6\n#define R_386_JMP_SLOT\t7\n#define R_386_RELATIVE\t8\n#define R_386_GOTOFF\t9\n#define R_386_GOTPC\t10\n#define R_386_NUM\t11\n\n \n#define elf_check_arch(x) \\\n\t(((x)->e_machine == EM_386) || ((x)->e_machine == EM_486))\n\n#define ELF_CLASS\tELFCLASS32\n#define ELF_DATA        ELFDATA2LSB\n#define ELF_ARCH        EM_386\n\n#define ELF_PLAT_INIT(regs, load_addr) do { \\\n\tPT_REGS_BX(regs) = 0; \\\n\tPT_REGS_CX(regs) = 0; \\\n\tPT_REGS_DX(regs) = 0; \\\n\tPT_REGS_SI(regs) = 0; \\\n\tPT_REGS_DI(regs) = 0; \\\n\tPT_REGS_BP(regs) = 0; \\\n\tPT_REGS_AX(regs) = 0; \\\n} while (0)\n\n \n\n#define ELF_CORE_COPY_REGS(pr_reg, regs) do {\t\\\n\tpr_reg[0] = PT_REGS_BX(regs);\t\t\\\n\tpr_reg[1] = PT_REGS_CX(regs);\t\t\\\n\tpr_reg[2] = PT_REGS_DX(regs);\t\t\\\n\tpr_reg[3] = PT_REGS_SI(regs);\t\t\\\n\tpr_reg[4] = PT_REGS_DI(regs);\t\t\\\n\tpr_reg[5] = PT_REGS_BP(regs);\t\t\\\n\tpr_reg[6] = PT_REGS_AX(regs);\t\t\\\n\tpr_reg[7] = PT_REGS_DS(regs);\t\t\\\n\tpr_reg[8] = PT_REGS_ES(regs);\t\t\\\n\t \t\\\n\tpr_reg[9] = PT_REGS_DS(regs);\t\t\\\n\tpr_reg[10] = PT_REGS_DS(regs);\t\t\\\n\tpr_reg[11] = PT_REGS_SYSCALL_NR(regs);\t\\\n\tpr_reg[12] = PT_REGS_IP(regs);\t\t\\\n\tpr_reg[13] = PT_REGS_CS(regs);\t\t\\\n\tpr_reg[14] = PT_REGS_EFLAGS(regs);\t\\\n\tpr_reg[15] = PT_REGS_SP(regs);\t\t\\\n\tpr_reg[16] = PT_REGS_SS(regs);\t\t\\\n} while (0);\n\nextern char * elf_aux_platform;\n#define ELF_PLATFORM (elf_aux_platform)\n\nextern unsigned long vsyscall_ehdr;\nextern unsigned long vsyscall_end;\nextern unsigned long __kernel_vsyscall;\n\n \n#define FIXADDR_USER_START      vsyscall_ehdr\n#define FIXADDR_USER_END        vsyscall_end\n\n\n \n#define AT_SYSINFO\t\t32\n#define AT_SYSINFO_EHDR\t\t33\n\n#define ARCH_DLINFO\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ( vsyscall_ehdr ) {\t\t\t\t\t\\\n\t\tNEW_AUX_ENT(AT_SYSINFO,\t__kernel_vsyscall);\t\\\n\t\tNEW_AUX_ENT(AT_SYSINFO_EHDR, vsyscall_ehdr);\t\\\n\t}\t\t\t\t\t\t\t\\\n} while (0)\n\n#else\n\n \n#define R_X86_64_NONE\t\t0\t \n#define R_X86_64_64\t\t1\t \n#define R_X86_64_PC32\t\t2\t \n#define R_X86_64_GOT32\t\t3\t \n#define R_X86_64_PLT32\t\t4\t \n#define R_X86_64_COPY\t\t5\t \n#define R_X86_64_GLOB_DAT\t6\t \n#define R_X86_64_JUMP_SLOT\t7\t \n#define R_X86_64_RELATIVE\t8\t \n#define R_X86_64_GOTPCREL\t9\t \n#define R_X86_64_32\t\t10\t \n#define R_X86_64_32S\t\t11\t \n#define R_X86_64_16\t\t12\t \n#define R_X86_64_PC16\t\t13\t \n#define R_X86_64_8\t\t14\t \n#define R_X86_64_PC8\t\t15\t \n#define R_X86_64_PC64\t\t24\t \n\n \n#define elf_check_arch(x) \\\n\t((x)->e_machine == EM_X86_64)\n\n#define ELF_CLASS\tELFCLASS64\n#define ELF_DATA        ELFDATA2LSB\n#define ELF_ARCH        EM_X86_64\n\n#define ELF_PLAT_INIT(regs, load_addr)    do { \\\n\tPT_REGS_BX(regs) = 0; \\\n\tPT_REGS_CX(regs) = 0; \\\n\tPT_REGS_DX(regs) = 0; \\\n\tPT_REGS_SI(regs) = 0; \\\n\tPT_REGS_DI(regs) = 0; \\\n\tPT_REGS_BP(regs) = 0; \\\n\tPT_REGS_AX(regs) = 0; \\\n\tPT_REGS_R8(regs) = 0; \\\n\tPT_REGS_R9(regs) = 0; \\\n\tPT_REGS_R10(regs) = 0; \\\n\tPT_REGS_R11(regs) = 0; \\\n\tPT_REGS_R12(regs) = 0; \\\n\tPT_REGS_R13(regs) = 0; \\\n\tPT_REGS_R14(regs) = 0; \\\n\tPT_REGS_R15(regs) = 0; \\\n} while (0)\n\n#define ELF_CORE_COPY_REGS(pr_reg, _regs)\t\t\\\n\t(pr_reg)[0] = (_regs)->regs.gp[0];\t\t\t\\\n\t(pr_reg)[1] = (_regs)->regs.gp[1];\t\t\t\\\n\t(pr_reg)[2] = (_regs)->regs.gp[2];\t\t\t\\\n\t(pr_reg)[3] = (_regs)->regs.gp[3];\t\t\t\\\n\t(pr_reg)[4] = (_regs)->regs.gp[4];\t\t\t\\\n\t(pr_reg)[5] = (_regs)->regs.gp[5];\t\t\t\\\n\t(pr_reg)[6] = (_regs)->regs.gp[6];\t\t\t\\\n\t(pr_reg)[7] = (_regs)->regs.gp[7];\t\t\t\\\n\t(pr_reg)[8] = (_regs)->regs.gp[8];\t\t\t\\\n\t(pr_reg)[9] = (_regs)->regs.gp[9];\t\t\t\\\n\t(pr_reg)[10] = (_regs)->regs.gp[10];\t\t\t\\\n\t(pr_reg)[11] = (_regs)->regs.gp[11];\t\t\t\\\n\t(pr_reg)[12] = (_regs)->regs.gp[12];\t\t\t\\\n\t(pr_reg)[13] = (_regs)->regs.gp[13];\t\t\t\\\n\t(pr_reg)[14] = (_regs)->regs.gp[14];\t\t\t\\\n\t(pr_reg)[15] = (_regs)->regs.gp[15];\t\t\t\\\n\t(pr_reg)[16] = (_regs)->regs.gp[16];\t\t\t\\\n\t(pr_reg)[17] = (_regs)->regs.gp[17];\t\t\t\\\n\t(pr_reg)[18] = (_regs)->regs.gp[18];\t\t\t\\\n\t(pr_reg)[19] = (_regs)->regs.gp[19];\t\t\t\\\n\t(pr_reg)[20] = (_regs)->regs.gp[20];\t\t\t\\\n\t(pr_reg)[21] = current->thread.arch.fs;\t\t\t\\\n\t(pr_reg)[22] = 0;\t\t\t\t\t\\\n\t(pr_reg)[23] = 0;\t\t\t\t\t\\\n\t(pr_reg)[24] = 0;\t\t\t\t\t\\\n\t(pr_reg)[25] = 0;\t\t\t\t\t\\\n\t(pr_reg)[26] = 0;\n\n#define ELF_PLATFORM \"x86_64\"\n\n \n#define FIXADDR_USER_START      0\n#define FIXADDR_USER_END        0\n\n#define ARCH_HAS_SETUP_ADDITIONAL_PAGES 1\nstruct linux_binprm;\nextern int arch_setup_additional_pages(struct linux_binprm *bprm,\n\tint uses_interp);\n\nextern unsigned long um_vdso_addr;\n#define AT_SYSINFO_EHDR 33\n#define ARCH_DLINFO\tNEW_AUX_ENT(AT_SYSINFO_EHDR, um_vdso_addr)\n\n#endif\n\ntypedef unsigned long elf_greg_t;\n\n#define ELF_NGREG (sizeof(struct user_regs_struct) / sizeof(elf_greg_t))\ntypedef elf_greg_t elf_gregset_t[ELF_NGREG];\n\ntypedef struct user_i387_struct elf_fpregset_t;\n\nstruct task_struct;\n\n#define ELF_EXEC_PAGESIZE 4096\n\n#define ELF_ET_DYN_BASE (TASK_SIZE / 3 * 2)\n\nextern long elf_aux_hwcap;\n#define ELF_HWCAP (elf_aux_hwcap)\n\n#define SET_PERSONALITY(ex) do {} while(0)\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}