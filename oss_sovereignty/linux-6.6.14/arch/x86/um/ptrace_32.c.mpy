{
  "module_name": "ptrace_32.c",
  "hash_id": "f5aad36d2379bb05468493f7e86e623ec132304935e4ef3ac08606a85611809b",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/um/ptrace_32.c",
  "human_readable_source": " \n\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <asm/ptrace-abi.h>\n#include <registers.h>\n#include <skas.h>\n\nextern int arch_switch_tls(struct task_struct *to);\n\nvoid arch_switch_to(struct task_struct *to)\n{\n\tint err = arch_switch_tls(to);\n\tif (!err)\n\t\treturn;\n\n\tif (err != -EINVAL)\n\t\tprintk(KERN_WARNING \"arch_switch_tls failed, errno %d, \"\n\t\t       \"not EINVAL\\n\", -err);\n\telse\n\t\tprintk(KERN_WARNING \"arch_switch_tls failed, errno = EINVAL\\n\");\n}\n\nint is_syscall(unsigned long addr)\n{\n\tunsigned short instr;\n\tint n;\n\n\tn = copy_from_user(&instr, (void __user *) addr, sizeof(instr));\n\tif (n) {\n\t\t \n\t\tn = access_process_vm(current, addr, &instr, sizeof(instr),\n\t\t\t\tFOLL_FORCE);\n\t\tif (n != sizeof(instr)) {\n\t\t\tprintk(KERN_ERR \"is_syscall : failed to read \"\n\t\t\t       \"instruction from 0x%lx\\n\", addr);\n\t\t\treturn 1;\n\t\t}\n\t}\n\t \n\treturn (instr == 0x80cd) || (instr == 0x340f);\n}\n\n \n \n#define FLAG_MASK 0x00044dd5\n\nstatic const int reg_offsets[] = {\n\t[EBX] = HOST_BX,\n\t[ECX] = HOST_CX,\n\t[EDX] = HOST_DX,\n\t[ESI] = HOST_SI,\n\t[EDI] = HOST_DI,\n\t[EBP] = HOST_BP,\n\t[EAX] = HOST_AX,\n\t[DS] = HOST_DS,\n\t[ES] = HOST_ES,\n\t[FS] = HOST_FS,\n\t[GS] = HOST_GS,\n\t[EIP] = HOST_IP,\n\t[CS] = HOST_CS,\n\t[EFL] = HOST_EFLAGS,\n\t[UESP] = HOST_SP,\n\t[SS] = HOST_SS,\n\t[ORIG_EAX] = HOST_ORIG_AX,\n};\n\nint putreg(struct task_struct *child, int regno, unsigned long value)\n{\n\tregno >>= 2;\n\tswitch (regno) {\n\tcase EBX:\n\tcase ECX:\n\tcase EDX:\n\tcase ESI:\n\tcase EDI:\n\tcase EBP:\n\tcase EAX:\n\tcase EIP:\n\tcase UESP:\n\t\tbreak;\n\tcase ORIG_EAX:\n\t\t \n\t\tUPT_SYSCALL_NR(&child->thread.regs.regs) = value;\n\t\tbreak;\n\tcase FS:\n\t\tif (value && (value & 3) != 3)\n\t\t\treturn -EIO;\n\t\tbreak;\n\tcase GS:\n\t\tif (value && (value & 3) != 3)\n\t\t\treturn -EIO;\n\t\tbreak;\n\tcase DS:\n\tcase ES:\n\t\tif (value && (value & 3) != 3)\n\t\t\treturn -EIO;\n\t\tvalue &= 0xffff;\n\t\tbreak;\n\tcase SS:\n\tcase CS:\n\t\tif ((value & 3) != 3)\n\t\t\treturn -EIO;\n\t\tvalue &= 0xffff;\n\t\tbreak;\n\tcase EFL:\n\t\tvalue &= FLAG_MASK;\n\t\tchild->thread.regs.regs.gp[HOST_EFLAGS] |= value;\n\t\treturn 0;\n\tdefault :\n\t\tpanic(\"Bad register in putreg() : %d\\n\", regno);\n\t}\n\tchild->thread.regs.regs.gp[reg_offsets[regno]] = value;\n\treturn 0;\n}\n\nint poke_user(struct task_struct *child, long addr, long data)\n{\n\tif ((addr & 3) || addr < 0)\n\t\treturn -EIO;\n\n\tif (addr < MAX_REG_OFFSET)\n\t\treturn putreg(child, addr, data);\n\telse if ((addr >= offsetof(struct user, u_debugreg[0])) &&\n\t\t (addr <= offsetof(struct user, u_debugreg[7]))) {\n\t\taddr -= offsetof(struct user, u_debugreg[0]);\n\t\taddr = addr >> 2;\n\t\tif ((addr == 4) || (addr == 5))\n\t\t\treturn -EIO;\n\t\tchild->thread.arch.debugregs[addr] = data;\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}\n\nunsigned long getreg(struct task_struct *child, int regno)\n{\n\tunsigned long mask = ~0UL;\n\n\tregno >>= 2;\n\tswitch (regno) {\n\tcase FS:\n\tcase GS:\n\tcase DS:\n\tcase ES:\n\tcase SS:\n\tcase CS:\n\t\tmask = 0xffff;\n\t\tbreak;\n\tcase EIP:\n\tcase UESP:\n\tcase EAX:\n\tcase EBX:\n\tcase ECX:\n\tcase EDX:\n\tcase ESI:\n\tcase EDI:\n\tcase EBP:\n\tcase EFL:\n\tcase ORIG_EAX:\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"Bad register in getreg() : %d\\n\", regno);\n\t}\n\treturn mask & child->thread.regs.regs.gp[reg_offsets[regno]];\n}\n\n \nint peek_user(struct task_struct *child, long addr, long data)\n{\n\tunsigned long tmp;\n\n\tif ((addr & 3) || addr < 0)\n\t\treturn -EIO;\n\n\ttmp = 0;   \n\tif (addr < MAX_REG_OFFSET) {\n\t\ttmp = getreg(child, addr);\n\t}\n\telse if ((addr >= offsetof(struct user, u_debugreg[0])) &&\n\t\t (addr <= offsetof(struct user, u_debugreg[7]))) {\n\t\taddr -= offsetof(struct user, u_debugreg[0]);\n\t\taddr = addr >> 2;\n\t\ttmp = child->thread.arch.debugregs[addr];\n\t}\n\treturn put_user(tmp, (unsigned long __user *) data);\n}\n\nstatic int get_fpregs(struct user_i387_struct __user *buf, struct task_struct *child)\n{\n\tint err, n, cpu = task_cpu(child);\n\tstruct user_i387_struct fpregs;\n\n\terr = save_i387_registers(userspace_pid[cpu],\n\t\t\t\t  (unsigned long *) &fpregs);\n\tif (err)\n\t\treturn err;\n\n\tn = copy_to_user(buf, &fpregs, sizeof(fpregs));\n\tif(n > 0)\n\t\treturn -EFAULT;\n\n\treturn n;\n}\n\nstatic int set_fpregs(struct user_i387_struct __user *buf, struct task_struct *child)\n{\n\tint n, cpu = task_cpu(child);\n\tstruct user_i387_struct fpregs;\n\n\tn = copy_from_user(&fpregs, buf, sizeof(fpregs));\n\tif (n > 0)\n\t\treturn -EFAULT;\n\n\treturn restore_i387_registers(userspace_pid[cpu],\n\t\t\t\t    (unsigned long *) &fpregs);\n}\n\nstatic int get_fpxregs(struct user_fxsr_struct __user *buf, struct task_struct *child)\n{\n\tint err, n, cpu = task_cpu(child);\n\tstruct user_fxsr_struct fpregs;\n\n\terr = save_fpx_registers(userspace_pid[cpu], (unsigned long *) &fpregs);\n\tif (err)\n\t\treturn err;\n\n\tn = copy_to_user(buf, &fpregs, sizeof(fpregs));\n\tif(n > 0)\n\t\treturn -EFAULT;\n\n\treturn n;\n}\n\nstatic int set_fpxregs(struct user_fxsr_struct __user *buf, struct task_struct *child)\n{\n\tint n, cpu = task_cpu(child);\n\tstruct user_fxsr_struct fpregs;\n\n\tn = copy_from_user(&fpregs, buf, sizeof(fpregs));\n\tif (n > 0)\n\t\treturn -EFAULT;\n\n\treturn restore_fpx_registers(userspace_pid[cpu],\n\t\t\t\t     (unsigned long *) &fpregs);\n}\n\nlong subarch_ptrace(struct task_struct *child, long request,\n\t\t    unsigned long addr, unsigned long data)\n{\n\tint ret = -EIO;\n\tvoid __user *datap = (void __user *) data;\n\tswitch (request) {\n\tcase PTRACE_GETFPREGS:  \n\t\tret = get_fpregs(datap, child);\n\t\tbreak;\n\tcase PTRACE_SETFPREGS:  \n\t\tret = set_fpregs(datap, child);\n\t\tbreak;\n\tcase PTRACE_GETFPXREGS:  \n\t\tret = get_fpxregs(datap, child);\n\t\tbreak;\n\tcase PTRACE_SETFPXREGS:  \n\t\tret = set_fpxregs(datap, child);\n\t\tbreak;\n\tdefault:\n\t\tret = -EIO;\n\t}\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}