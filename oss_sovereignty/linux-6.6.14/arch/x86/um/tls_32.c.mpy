{
  "module_name": "tls_32.c",
  "hash_id": "4b64293cbc34f6aa3ca3289bb5bab0d396504b85383c158f8983a4068210b3b0",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/um/tls_32.c",
  "human_readable_source": " \n\n#include <linux/percpu.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <asm/ptrace-abi.h>\n#include <os.h>\n#include <skas.h>\n#include <sysdep/tls.h>\n\n \nstatic int host_supports_tls = -1;\nint host_gdt_entry_tls_min;\n\nint do_set_thread_area(struct user_desc *info)\n{\n\tint ret;\n\tu32 cpu;\n\n\tcpu = get_cpu();\n\tret = os_set_thread_area(info, userspace_pid[cpu]);\n\tput_cpu();\n\n\tif (ret)\n\t\tprintk(KERN_ERR \"PTRACE_SET_THREAD_AREA failed, err = %d, \"\n\t\t       \"index = %d\\n\", ret, info->entry_number);\n\n\treturn ret;\n}\n\nint do_get_thread_area(struct user_desc *info)\n{\n\tint ret;\n\tu32 cpu;\n\n\tcpu = get_cpu();\n\tret = os_get_thread_area(info, userspace_pid[cpu]);\n\tput_cpu();\n\n\tif (ret)\n\t\tprintk(KERN_ERR \"PTRACE_GET_THREAD_AREA failed, err = %d, \"\n\t\t       \"index = %d\\n\", ret, info->entry_number);\n\n\treturn ret;\n}\n\n \nstatic int get_free_idx(struct task_struct* task)\n{\n\tstruct thread_struct *t = &task->thread;\n\tint idx;\n\n\tfor (idx = 0; idx < GDT_ENTRY_TLS_ENTRIES; idx++)\n\t\tif (!t->arch.tls_array[idx].present)\n\t\t\treturn idx + GDT_ENTRY_TLS_MIN;\n\treturn -ESRCH;\n}\n\nstatic inline void clear_user_desc(struct user_desc* info)\n{\n\t \n\tmemset(info, 0, sizeof(*info));\n\n\t \n\tinfo->read_exec_only = 1;\n\tinfo->seg_not_present = 1;\n}\n\n#define O_FORCE 1\n\nstatic int load_TLS(int flags, struct task_struct *to)\n{\n\tint ret = 0;\n\tint idx;\n\n\tfor (idx = GDT_ENTRY_TLS_MIN; idx < GDT_ENTRY_TLS_MAX; idx++) {\n\t\tstruct uml_tls_struct* curr =\n\t\t\t&to->thread.arch.tls_array[idx - GDT_ENTRY_TLS_MIN];\n\n\t\t \n\t\tif (!curr->present) {\n\t\t\tif (!curr->flushed) {\n\t\t\t\tclear_user_desc(&curr->tls);\n\t\t\t\tcurr->tls.entry_number = idx;\n\t\t\t} else {\n\t\t\t\tWARN_ON(!LDT_empty(&curr->tls));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!(flags & O_FORCE) && curr->flushed)\n\t\t\tcontinue;\n\n\t\tret = do_set_thread_area(&curr->tls);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tcurr->flushed = 1;\n\t}\nout:\n\treturn ret;\n}\n\n \nstatic inline int needs_TLS_update(struct task_struct *task)\n{\n\tint i;\n\tint ret = 0;\n\n\tfor (i = GDT_ENTRY_TLS_MIN; i < GDT_ENTRY_TLS_MAX; i++) {\n\t\tstruct uml_tls_struct* curr =\n\t\t\t&task->thread.arch.tls_array[i - GDT_ENTRY_TLS_MIN];\n\n\t\t \n\t\tif (curr->flushed)\n\t\t\tcontinue;\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nvoid clear_flushed_tls(struct task_struct *task)\n{\n\tint i;\n\n\tfor (i = GDT_ENTRY_TLS_MIN; i < GDT_ENTRY_TLS_MAX; i++) {\n\t\tstruct uml_tls_struct* curr =\n\t\t\t&task->thread.arch.tls_array[i - GDT_ENTRY_TLS_MIN];\n\n\t\t \n\t\tif (!curr->present)\n\t\t\tcontinue;\n\n\t\tcurr->flushed = 0;\n\t}\n}\n\n \n\nint arch_switch_tls(struct task_struct *to)\n{\n\tif (!host_supports_tls)\n\t\treturn 0;\n\n\t \n\tif (likely(to->mm))\n\t\treturn load_TLS(O_FORCE, to);\n\n\treturn 0;\n}\n\nstatic int set_tls_entry(struct task_struct* task, struct user_desc *info,\n\t\t\t int idx, int flushed)\n{\n\tstruct thread_struct *t = &task->thread;\n\n\tif (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)\n\t\treturn -EINVAL;\n\n\tt->arch.tls_array[idx - GDT_ENTRY_TLS_MIN].tls = *info;\n\tt->arch.tls_array[idx - GDT_ENTRY_TLS_MIN].present = 1;\n\tt->arch.tls_array[idx - GDT_ENTRY_TLS_MIN].flushed = flushed;\n\n\treturn 0;\n}\n\nint arch_set_tls(struct task_struct *new, unsigned long tls)\n{\n\tstruct user_desc info;\n\tint idx, ret = -EFAULT;\n\n\tif (copy_from_user(&info, (void __user *) tls, sizeof(info)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (LDT_empty(&info))\n\t\tgoto out;\n\n\tidx = info.entry_number;\n\n\tret = set_tls_entry(new, &info, idx, 0);\nout:\n\treturn ret;\n}\n\n \nstatic int get_tls_entry(struct task_struct *task, struct user_desc *info,\n\t\t\t int idx)\n{\n\tstruct thread_struct *t = &task->thread;\n\n\tif (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)\n\t\treturn -EINVAL;\n\n\tif (!t->arch.tls_array[idx - GDT_ENTRY_TLS_MIN].present)\n\t\tgoto clear;\n\n\t*info = t->arch.tls_array[idx - GDT_ENTRY_TLS_MIN].tls;\n\nout:\n\t \n\tif (unlikely(task == current &&\n\t\t     !t->arch.tls_array[idx - GDT_ENTRY_TLS_MIN].flushed)) {\n\t\tprintk(KERN_ERR \"get_tls_entry: task with pid %d got here \"\n\t\t\t\t\"without flushed TLS.\", current->pid);\n\t}\n\n\treturn 0;\nclear:\n\t \n\tclear_user_desc(info);\n\tinfo->entry_number = idx;\n\tgoto out;\n}\n\nSYSCALL_DEFINE1(set_thread_area, struct user_desc __user *, user_desc)\n{\n\tstruct user_desc info;\n\tint idx, ret;\n\n\tif (!host_supports_tls)\n\t\treturn -ENOSYS;\n\n\tif (copy_from_user(&info, user_desc, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tidx = info.entry_number;\n\n\tif (idx == -1) {\n\t\tidx = get_free_idx(current);\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\t\tinfo.entry_number = idx;\n\t\t \n\t\tif (put_user(idx, &user_desc->entry_number))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_set_thread_area(&info);\n\tif (ret)\n\t\treturn ret;\n\treturn set_tls_entry(current, &info, idx, 1);\n}\n\n \nint ptrace_set_thread_area(struct task_struct *child, int idx,\n\t\t\t   struct user_desc __user *user_desc)\n{\n\tstruct user_desc info;\n\n\tif (!host_supports_tls)\n\t\treturn -EIO;\n\n\tif (copy_from_user(&info, user_desc, sizeof(info)))\n\t\treturn -EFAULT;\n\n\treturn set_tls_entry(child, &info, idx, 0);\n}\n\nSYSCALL_DEFINE1(get_thread_area, struct user_desc __user *, user_desc)\n{\n\tstruct user_desc info;\n\tint idx, ret;\n\n\tif (!host_supports_tls)\n\t\treturn -ENOSYS;\n\n\tif (get_user(idx, &user_desc->entry_number))\n\t\treturn -EFAULT;\n\n\tret = get_tls_entry(current, &info, idx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (copy_to_user(user_desc, &info, sizeof(info)))\n\t\tret = -EFAULT;\n\nout:\n\treturn ret;\n}\n\n \nint ptrace_get_thread_area(struct task_struct *child, int idx,\n\t\tstruct user_desc __user *user_desc)\n{\n\tstruct user_desc info;\n\tint ret;\n\n\tif (!host_supports_tls)\n\t\treturn -EIO;\n\n\tret = get_tls_entry(child, &info, idx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (copy_to_user(user_desc, &info, sizeof(info)))\n\t\tret = -EFAULT;\nout:\n\treturn ret;\n}\n\n \nstatic int __init __setup_host_supports_tls(void)\n{\n\tcheck_host_supports_tls(&host_supports_tls, &host_gdt_entry_tls_min);\n\tif (host_supports_tls) {\n\t\tprintk(KERN_INFO \"Host TLS support detected\\n\");\n\t\tprintk(KERN_INFO \"Detected host type: \");\n\t\tswitch (host_gdt_entry_tls_min) {\n\t\tcase GDT_ENTRY_TLS_MIN_I386:\n\t\t\tprintk(KERN_CONT \"i386\");\n\t\t\tbreak;\n\t\tcase GDT_ENTRY_TLS_MIN_X86_64:\n\t\t\tprintk(KERN_CONT \"x86_64\");\n\t\t\tbreak;\n\t\t}\n\t\tprintk(KERN_CONT \" (GDT indexes %d to %d)\\n\",\n\t\t       host_gdt_entry_tls_min,\n\t\t       host_gdt_entry_tls_min + GDT_ENTRY_TLS_ENTRIES);\n\t} else\n\t\tprintk(KERN_ERR \"  Host TLS support NOT detected! \"\n\t\t\t\t\"TLS support inside UML will not work\\n\");\n\treturn 0;\n}\n\n__initcall(__setup_host_supports_tls);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}