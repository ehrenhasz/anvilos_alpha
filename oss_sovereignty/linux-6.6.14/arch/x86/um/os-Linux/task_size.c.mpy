{
  "module_name": "task_size.c",
  "hash_id": "314276b27a50130610e804e9434b2c18b8eb4517d972ecfdfbc5ea3e780f8935",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/um/os-Linux/task_size.c",
  "human_readable_source": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/mman.h>\n#include <longjmp.h>\n\n#ifdef __i386__\n\nstatic jmp_buf buf;\n\nstatic void segfault(int sig)\n{\n\tlongjmp(buf, 1);\n}\n\nstatic int page_ok(unsigned long page)\n{\n\tunsigned long *address = (unsigned long *) (page << UM_KERN_PAGE_SHIFT);\n\tunsigned long n = ~0UL;\n\tvoid *mapped = NULL;\n\tint ok = 0;\n\n\t \n\tif (setjmp(buf) == 0)\n\t\tn = *address;\n\telse {\n\t\tmapped = mmap(address, UM_KERN_PAGE_SIZE,\n\t\t\t      PROT_READ | PROT_WRITE,\n\t\t\t      MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\t\tif (mapped == MAP_FAILED)\n\t\t\treturn 0;\n\t\tif (mapped != address)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (setjmp(buf) == 0) {\n\t\t*address = n;\n\t\tok = 1;\n\t\tgoto out;\n\t} else if (mprotect(address, UM_KERN_PAGE_SIZE,\n\t\t\t    PROT_READ | PROT_WRITE) != 0)\n\t\tgoto out;\n\n\tif (setjmp(buf) == 0) {\n\t\t*address = n;\n\t\tok = 1;\n\t}\n\n out:\n\tif (mapped != NULL)\n\t\tmunmap(mapped, UM_KERN_PAGE_SIZE);\n\treturn ok;\n}\n\nunsigned long os_get_top_address(void)\n{\n\tstruct sigaction sa, old;\n\tunsigned long bottom = 0;\n\t \n\tunsigned long top = 0xffffd000 >> UM_KERN_PAGE_SHIFT;\n\tunsigned long test, original;\n\n\tprintf(\"Locating the bottom of the address space ... \");\n\tfflush(stdout);\n\n\t \n\tsa.sa_handler = segfault;\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = SA_NODEFER;\n\tif (sigaction(SIGSEGV, &sa, &old)) {\n\t\tperror(\"os_get_top_address\");\n\t\texit(1);\n\t}\n\n\t \n\tfor (bottom = 0; bottom < top; bottom++) {\n\t\tif (page_ok(bottom))\n\t\t\tbreak;\n\t}\n\n\t \n\tif (bottom == top) {\n\t\tfprintf(stderr, \"Unable to determine bottom of address \"\n\t\t\t\"space.\\n\");\n\t\texit(1);\n\t}\n\n\tprintf(\"0x%lx\\n\", bottom << UM_KERN_PAGE_SHIFT);\n\tprintf(\"Locating the top of the address space ... \");\n\tfflush(stdout);\n\n\toriginal = bottom;\n\n\t \n\tif (page_ok(top))\n\t\tgoto out;\n\n\tdo {\n\t\ttest = bottom + (top - bottom) / 2;\n\t\tif (page_ok(test))\n\t\t\tbottom = test;\n\t\telse\n\t\t\ttop = test;\n\t} while (top - bottom > 1);\n\nout:\n\t \n\tif (sigaction(SIGSEGV, &old, NULL)) {\n\t\tperror(\"os_get_top_address\");\n\t\texit(1);\n\t}\n\ttop <<= UM_KERN_PAGE_SHIFT;\n\tprintf(\"0x%lx\\n\", top);\n\n\treturn top;\n}\n\n#else\n\nunsigned long os_get_top_address(void)\n{\n\t \n\treturn 0x7fc0002000;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}