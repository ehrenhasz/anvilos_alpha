{
  "module_name": "registers.c",
  "hash_id": "0ca15e87384dd20b0021b9211435909a9954ed45d3f1fdb27a331a957c085c80",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/um/os-Linux/registers.c",
  "human_readable_source": " \n\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/ptrace.h>\n#ifdef __i386__\n#include <sys/user.h>\n#endif\n#include <longjmp.h>\n#include <sysdep/ptrace_user.h>\n#include <sys/uio.h>\n#include <asm/sigcontext.h>\n#include <linux/elf.h>\n#include <registers.h>\n\nint have_xstate_support;\n\nint save_i387_registers(int pid, unsigned long *fp_regs)\n{\n\tif (ptrace(PTRACE_GETFPREGS, pid, 0, fp_regs) < 0)\n\t\treturn -errno;\n\treturn 0;\n}\n\nint save_fp_registers(int pid, unsigned long *fp_regs)\n{\n#ifdef PTRACE_GETREGSET\n\tstruct iovec iov;\n\n\tif (have_xstate_support) {\n\t\tiov.iov_base = fp_regs;\n\t\tiov.iov_len = FP_SIZE * sizeof(unsigned long);\n\t\tif (ptrace(PTRACE_GETREGSET, pid, NT_X86_XSTATE, &iov) < 0)\n\t\t\treturn -errno;\n\t\treturn 0;\n\t} else\n#endif\n\t\treturn save_i387_registers(pid, fp_regs);\n}\n\nint restore_i387_registers(int pid, unsigned long *fp_regs)\n{\n\tif (ptrace(PTRACE_SETFPREGS, pid, 0, fp_regs) < 0)\n\t\treturn -errno;\n\treturn 0;\n}\n\nint restore_fp_registers(int pid, unsigned long *fp_regs)\n{\n#ifdef PTRACE_SETREGSET\n\tstruct iovec iov;\n\tif (have_xstate_support) {\n\t\tiov.iov_base = fp_regs;\n\t\tiov.iov_len = FP_SIZE * sizeof(unsigned long);\n\t\tif (ptrace(PTRACE_SETREGSET, pid, NT_X86_XSTATE, &iov) < 0)\n\t\t\treturn -errno;\n\t\treturn 0;\n\t} else\n#endif\n\t\treturn restore_i387_registers(pid, fp_regs);\n}\n\n#ifdef __i386__\nint have_fpx_regs = 1;\nint save_fpx_registers(int pid, unsigned long *fp_regs)\n{\n\tif (ptrace(PTRACE_GETFPXREGS, pid, 0, fp_regs) < 0)\n\t\treturn -errno;\n\treturn 0;\n}\n\nint restore_fpx_registers(int pid, unsigned long *fp_regs)\n{\n\tif (ptrace(PTRACE_SETFPXREGS, pid, 0, fp_regs) < 0)\n\t\treturn -errno;\n\treturn 0;\n}\n\nint get_fp_registers(int pid, unsigned long *regs)\n{\n\tif (have_fpx_regs)\n\t\treturn save_fpx_registers(pid, regs);\n\telse\n\t\treturn save_fp_registers(pid, regs);\n}\n\nint put_fp_registers(int pid, unsigned long *regs)\n{\n\tif (have_fpx_regs)\n\t\treturn restore_fpx_registers(pid, regs);\n\telse\n\t\treturn restore_fp_registers(pid, regs);\n}\n\nvoid arch_init_registers(int pid)\n{\n\tstruct user_fpxregs_struct fpx_regs;\n\tint err;\n\n\terr = ptrace(PTRACE_GETFPXREGS, pid, 0, &fpx_regs);\n\tif (!err)\n\t\treturn;\n\n\tif (errno != EIO)\n\t\tpanic(\"check_ptrace : PTRACE_GETFPXREGS failed, errno = %d\",\n\t\t      errno);\n\n\thave_fpx_regs = 0;\n}\n#else\n\nint get_fp_registers(int pid, unsigned long *regs)\n{\n\treturn save_fp_registers(pid, regs);\n}\n\nint put_fp_registers(int pid, unsigned long *regs)\n{\n\treturn restore_fp_registers(pid, regs);\n}\n\nvoid arch_init_registers(int pid)\n{\n#ifdef PTRACE_GETREGSET\n\tvoid * fp_regs;\n\tstruct iovec iov;\n\n\tfp_regs = malloc(FP_SIZE * sizeof(unsigned long));\n\tif(fp_regs == NULL)\n\t\treturn;\n\n\tiov.iov_base = fp_regs;\n\tiov.iov_len = FP_SIZE * sizeof(unsigned long);\n\tif (ptrace(PTRACE_GETREGSET, pid, NT_X86_XSTATE, &iov) == 0)\n\t\thave_xstate_support = 1;\n\n\tfree(fp_regs);\n#endif\n}\n#endif\n\nunsigned long get_thread_reg(int reg, jmp_buf *buf)\n{\n\tswitch (reg) {\n#ifdef __i386__\n\tcase HOST_IP:\n\t\treturn buf[0]->__eip;\n\tcase HOST_SP:\n\t\treturn buf[0]->__esp;\n\tcase HOST_BP:\n\t\treturn buf[0]->__ebp;\n#else\n\tcase HOST_IP:\n\t\treturn buf[0]->__rip;\n\tcase HOST_SP:\n\t\treturn buf[0]->__rsp;\n\tcase HOST_BP:\n\t\treturn buf[0]->__rbp;\n#endif\n\tdefault:\n\t\tprintk(UM_KERN_ERR \"get_thread_regs - unknown register %d\\n\",\n\t\t       reg);\n\t\treturn 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}