{
  "module_name": "ptrace_64.c",
  "hash_id": "c41bde4ea30459816140881814e9bae20e9f3d9d60a079c57b42567cfdb31e68",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/um/ptrace_64.c",
  "human_readable_source": " \n\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#define __FRAME_OFFSETS\n#include <asm/ptrace.h>\n#include <linux/uaccess.h>\n#include <registers.h>\n#include <asm/ptrace-abi.h>\n\n \n#define FLAG_MASK 0x44dd5UL\n\nstatic const int reg_offsets[] =\n{\n\t[R8 >> 3] = HOST_R8,\n\t[R9 >> 3] = HOST_R9,\n\t[R10 >> 3] = HOST_R10,\n\t[R11 >> 3] = HOST_R11,\n\t[R12 >> 3] = HOST_R12,\n\t[R13 >> 3] = HOST_R13,\n\t[R14 >> 3] = HOST_R14,\n\t[R15 >> 3] = HOST_R15,\n\t[RIP >> 3] = HOST_IP,\n\t[RSP >> 3] = HOST_SP,\n\t[RAX >> 3] = HOST_AX,\n\t[RBX >> 3] = HOST_BX,\n\t[RCX >> 3] = HOST_CX,\n\t[RDX >> 3] = HOST_DX,\n\t[RSI >> 3] = HOST_SI,\n\t[RDI >> 3] = HOST_DI,\n\t[RBP >> 3] = HOST_BP,\n\t[CS >> 3] = HOST_CS,\n\t[SS >> 3] = HOST_SS,\n\t[FS_BASE >> 3] = HOST_FS_BASE,\n\t[GS_BASE >> 3] = HOST_GS_BASE,\n\t[DS >> 3] = HOST_DS,\n\t[ES >> 3] = HOST_ES,\n\t[FS >> 3] = HOST_FS,\n\t[GS >> 3] = HOST_GS,\n\t[EFLAGS >> 3] = HOST_EFLAGS,\n\t[ORIG_RAX >> 3] = HOST_ORIG_AX,\n};\n\nint putreg(struct task_struct *child, int regno, unsigned long value)\n{\n\tswitch (regno) {\n\tcase R8:\n\tcase R9:\n\tcase R10:\n\tcase R11:\n\tcase R12:\n\tcase R13:\n\tcase R14:\n\tcase R15:\n\tcase RIP:\n\tcase RSP:\n\tcase RAX:\n\tcase RBX:\n\tcase RCX:\n\tcase RDX:\n\tcase RSI:\n\tcase RDI:\n\tcase RBP:\n\t\tbreak;\n\n\tcase ORIG_RAX:\n\t\t \n\t\tUPT_SYSCALL_NR(&child->thread.regs.regs) = value;\n\t\tbreak;\n\n\tcase FS:\n\tcase GS:\n\tcase DS:\n\tcase ES:\n\tcase SS:\n\tcase CS:\n\t\tif (value && (value & 3) != 3)\n\t\t\treturn -EIO;\n\t\tvalue &= 0xffff;\n\t\tbreak;\n\n\tcase FS_BASE:\n\tcase GS_BASE:\n\t\tif (!((value >> 48) == 0 || (value >> 48) == 0xffff))\n\t\t\treturn -EIO;\n\t\tbreak;\n\n\tcase EFLAGS:\n\t\tvalue &= FLAG_MASK;\n\t\tchild->thread.regs.regs.gp[HOST_EFLAGS] |= value;\n\t\treturn 0;\n\n\tdefault:\n\t\tpanic(\"Bad register in putreg(): %d\\n\", regno);\n\t}\n\n\tchild->thread.regs.regs.gp[reg_offsets[regno >> 3]] = value;\n\treturn 0;\n}\n\nint poke_user(struct task_struct *child, long addr, long data)\n{\n\tif ((addr & 3) || addr < 0)\n\t\treturn -EIO;\n\n\tif (addr < MAX_REG_OFFSET)\n\t\treturn putreg(child, addr, data);\n\telse if ((addr >= offsetof(struct user, u_debugreg[0])) &&\n\t\t(addr <= offsetof(struct user, u_debugreg[7]))) {\n\t\taddr -= offsetof(struct user, u_debugreg[0]);\n\t\taddr = addr >> 3;\n\t\tif ((addr == 4) || (addr == 5))\n\t\t\treturn -EIO;\n\t\tchild->thread.arch.debugregs[addr] = data;\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}\n\nunsigned long getreg(struct task_struct *child, int regno)\n{\n\tunsigned long mask = ~0UL;\n\n\tswitch (regno) {\n\tcase R8:\n\tcase R9:\n\tcase R10:\n\tcase R11:\n\tcase R12:\n\tcase R13:\n\tcase R14:\n\tcase R15:\n\tcase RIP:\n\tcase RSP:\n\tcase RAX:\n\tcase RBX:\n\tcase RCX:\n\tcase RDX:\n\tcase RSI:\n\tcase RDI:\n\tcase RBP:\n\tcase ORIG_RAX:\n\tcase EFLAGS:\n\tcase FS_BASE:\n\tcase GS_BASE:\n\t\tbreak;\n\tcase FS:\n\tcase GS:\n\tcase DS:\n\tcase ES:\n\tcase SS:\n\tcase CS:\n\t\tmask = 0xffff;\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"Bad register in getreg: %d\\n\", regno);\n\t}\n\treturn mask & child->thread.regs.regs.gp[reg_offsets[regno >> 3]];\n}\n\nint peek_user(struct task_struct *child, long addr, long data)\n{\n\t \n\tunsigned long tmp;\n\n\tif ((addr & 3) || addr < 0)\n\t\treturn -EIO;\n\n\ttmp = 0;   \n\tif (addr < MAX_REG_OFFSET)\n\t\ttmp = getreg(child, addr);\n\telse if ((addr >= offsetof(struct user, u_debugreg[0])) &&\n\t\t(addr <= offsetof(struct user, u_debugreg[7]))) {\n\t\taddr -= offsetof(struct user, u_debugreg[0]);\n\t\taddr = addr >> 2;\n\t\ttmp = child->thread.arch.debugregs[addr];\n\t}\n\treturn put_user(tmp, (unsigned long *) data);\n}\n\n \nint is_syscall(unsigned long addr)\n{\n\tunsigned short instr;\n\tint n;\n\n\tn = copy_from_user(&instr, (void __user *) addr, sizeof(instr));\n\tif (n) {\n\t\t \n\t\tn = access_process_vm(current, addr, &instr, sizeof(instr),\n\t\t\t\tFOLL_FORCE);\n\t\tif (n != sizeof(instr)) {\n\t\t\tprintk(\"is_syscall : failed to read instruction from \"\n\t\t\t       \"0x%lx\\n\", addr);\n\t\t\treturn 1;\n\t\t}\n\t}\n\t \n\treturn instr == 0x050f;\n}\n\nstatic int get_fpregs(struct user_i387_struct __user *buf, struct task_struct *child)\n{\n\tint err, n, cpu = ((struct thread_info *) child->stack)->cpu;\n\tstruct user_i387_struct fpregs;\n\n\terr = save_i387_registers(userspace_pid[cpu],\n\t\t\t\t  (unsigned long *) &fpregs);\n\tif (err)\n\t\treturn err;\n\n\tn = copy_to_user(buf, &fpregs, sizeof(fpregs));\n\tif (n > 0)\n\t\treturn -EFAULT;\n\n\treturn n;\n}\n\nstatic int set_fpregs(struct user_i387_struct __user *buf, struct task_struct *child)\n{\n\tint n, cpu = ((struct thread_info *) child->stack)->cpu;\n\tstruct user_i387_struct fpregs;\n\n\tn = copy_from_user(&fpregs, buf, sizeof(fpregs));\n\tif (n > 0)\n\t\treturn -EFAULT;\n\n\treturn restore_i387_registers(userspace_pid[cpu],\n\t\t\t\t      (unsigned long *) &fpregs);\n}\n\nlong subarch_ptrace(struct task_struct *child, long request,\n\t\t    unsigned long addr, unsigned long data)\n{\n\tint ret = -EIO;\n\tvoid __user *datap = (void __user *) data;\n\n\tswitch (request) {\n\tcase PTRACE_GETFPREGS:  \n\t\tret = get_fpregs(datap, child);\n\t\tbreak;\n\tcase PTRACE_SETFPREGS:  \n\t\tret = set_fpregs(datap, child);\n\t\tbreak;\n\tcase PTRACE_ARCH_PRCTL:\n\t\t \n\t\tret = arch_prctl(child, data, (void __user *) addr);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}