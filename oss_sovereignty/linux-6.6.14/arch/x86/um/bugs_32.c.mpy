{
  "module_name": "bugs_32.c",
  "hash_id": "bd02a117682420138226fea376b52c8969ff903e17557f2bba4d05827bb97eea",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/um/bugs_32.c",
  "human_readable_source": " \n\n#include <signal.h>\n#include <kern_util.h>\n#include <longjmp.h>\n#include <sysdep/ptrace.h>\n#include <generated/asm-offsets.h>\n\n \nstatic int host_has_cmov = 1;\nstatic jmp_buf cmov_test_return;\n\nstatic void cmov_sigill_test_handler(int sig)\n{\n\thost_has_cmov = 0;\n\tlongjmp(cmov_test_return, 1);\n}\n\nvoid arch_check_bugs(void)\n{\n\tstruct sigaction old, new;\n\n\tprintk(UM_KERN_INFO \"Checking for host processor cmov support...\");\n\tnew.sa_handler = cmov_sigill_test_handler;\n\n\t \n\tnew.sa_flags = SA_NODEFER;\n\tsigemptyset(&new.sa_mask);\n\tsigaction(SIGILL, &new, &old);\n\n\tif (setjmp(cmov_test_return) == 0) {\n\t\tunsigned long foo = 0;\n\t\t__asm__ __volatile__(\"cmovz %0, %1\" : \"=r\" (foo) : \"0\" (foo));\n\t\tprintk(UM_KERN_CONT \"Yes\\n\");\n\t} else\n\t\tprintk(UM_KERN_CONT \"No\\n\");\n\n\tsigaction(SIGILL, &old, &new);\n}\n\nvoid arch_examine_signal(int sig, struct uml_pt_regs *regs)\n{\n\tunsigned char tmp[2];\n\n\t \n\tif ((sig != SIGILL) || (get_current_pid() != 1))\n\t\treturn;\n\n\tif (copy_from_user_proc(tmp, (void *) UPT_IP(regs), 2)) {\n\t\tprintk(UM_KERN_ERR \"SIGILL in init, could not read \"\n\t\t       \"instructions!\\n\");\n\t\treturn;\n\t}\n\n\tif ((tmp[0] != 0x0f) || ((tmp[1] & 0xf0) != 0x40))\n\t\treturn;\n\n\tif (host_has_cmov == 0)\n\t\tprintk(UM_KERN_ERR \"SIGILL caused by cmov, which this \"\n\t\t       \"processor doesn't implement.  Boot a filesystem \"\n\t\t       \"compiled for older processors\");\n\telse if (host_has_cmov == 1)\n\t\tprintk(UM_KERN_ERR \"SIGILL caused by cmov, which this \"\n\t\t       \"processor claims to implement\");\n\telse\n\t\tprintk(UM_KERN_ERR \"Bad value for host_has_cmov (%d)\",\n\t\t\thost_has_cmov);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}