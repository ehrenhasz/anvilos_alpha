{
  "module_name": "elfcore.c",
  "hash_id": "662478714debe34f0043b8d33f87011c8ea1b491f0ae9eb45eafb7078835cca0",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/um/elfcore.c",
  "human_readable_source": "\n#include <linux/elf.h>\n#include <linux/coredump.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n\n#include <asm/elf.h>\n\n\nElf32_Half elf_core_extra_phdrs(struct coredump_params *cprm)\n{\n\treturn vsyscall_ehdr ? (((struct elfhdr *)vsyscall_ehdr)->e_phnum) : 0;\n}\n\nint elf_core_write_extra_phdrs(struct coredump_params *cprm, loff_t offset)\n{\n\tif ( vsyscall_ehdr ) {\n\t\tconst struct elfhdr *const ehdrp =\n\t\t\t(struct elfhdr *) vsyscall_ehdr;\n\t\tconst struct elf_phdr *const phdrp =\n\t\t\t(const struct elf_phdr *) (vsyscall_ehdr + ehdrp->e_phoff);\n\t\tint i;\n\t\tElf32_Off ofs = 0;\n\n\t\tfor (i = 0; i < ehdrp->e_phnum; ++i) {\n\t\t\tstruct elf_phdr phdr = phdrp[i];\n\n\t\t\tif (phdr.p_type == PT_LOAD) {\n\t\t\t\tofs = phdr.p_offset = offset;\n\t\t\t\toffset += phdr.p_filesz;\n\t\t\t} else {\n\t\t\t\tphdr.p_offset += ofs;\n\t\t\t}\n\t\t\tphdr.p_paddr = 0;  \n\t\t\tif (!dump_emit(cprm, &phdr, sizeof(phdr)))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint elf_core_write_extra_data(struct coredump_params *cprm)\n{\n\tif ( vsyscall_ehdr ) {\n\t\tconst struct elfhdr *const ehdrp =\n\t\t\t(struct elfhdr *) vsyscall_ehdr;\n\t\tconst struct elf_phdr *const phdrp =\n\t\t\t(const struct elf_phdr *) (vsyscall_ehdr + ehdrp->e_phoff);\n\t\tint i;\n\n\t\tfor (i = 0; i < ehdrp->e_phnum; ++i) {\n\t\t\tif (phdrp[i].p_type == PT_LOAD) {\n\t\t\t\tvoid *addr = (void *) phdrp[i].p_vaddr;\n\t\t\t\tsize_t filesz = phdrp[i].p_filesz;\n\t\t\t\tif (!dump_emit(cprm, addr, filesz))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nsize_t elf_core_extra_data_size(struct coredump_params *cprm)\n{\n\tif ( vsyscall_ehdr ) {\n\t\tconst struct elfhdr *const ehdrp =\n\t\t\t(struct elfhdr *)vsyscall_ehdr;\n\t\tconst struct elf_phdr *const phdrp =\n\t\t\t(const struct elf_phdr *) (vsyscall_ehdr + ehdrp->e_phoff);\n\t\tint i;\n\n\t\tfor (i = 0; i < ehdrp->e_phnum; ++i)\n\t\t\tif (phdrp[i].p_type == PT_LOAD)\n\t\t\t\treturn (size_t) phdrp[i].p_filesz;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}