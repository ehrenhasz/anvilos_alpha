{
  "module_name": "signal.c",
  "hash_id": "2926d2ae2975bd8393a764fa8da5a76d53d5a4702e65a10ebf2e0ab0ce0471d4",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/um/signal.c",
  "human_readable_source": " \n\n\n#include <linux/personality.h>\n#include <linux/ptrace.h>\n#include <linux/kernel.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/ucontext.h>\n#include <frame_kern.h>\n#include <registers.h>\n#include <skas.h>\n\n#ifdef CONFIG_X86_32\n\n \n\nstatic inline unsigned short twd_i387_to_fxsr(unsigned short twd)\n{\n\tunsigned int tmp;  \n\n\t \n\ttmp = ~twd;\n\ttmp = (tmp | (tmp>>1)) & 0x5555;  \n\t \n\ttmp = (tmp | (tmp >> 1)) & 0x3333;  \n\ttmp = (tmp | (tmp >> 2)) & 0x0f0f;  \n\ttmp = (tmp | (tmp >> 4)) & 0x00ff;  \n\treturn tmp;\n}\n\nstatic inline unsigned long twd_fxsr_to_i387(struct user_fxsr_struct *fxsave)\n{\n\tstruct _fpxreg *st = NULL;\n\tunsigned long twd = (unsigned long) fxsave->twd;\n\tunsigned long tag;\n\tunsigned long ret = 0xffff0000;\n\tint i;\n\n#define FPREG_ADDR(f, n)\t((char *)&(f)->st_space + (n) * 16)\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (twd & 0x1) {\n\t\t\tst = (struct _fpxreg *) FPREG_ADDR(fxsave, i);\n\n\t\t\tswitch (st->exponent & 0x7fff) {\n\t\t\tcase 0x7fff:\n\t\t\t\ttag = 2;\t\t \n\t\t\t\tbreak;\n\t\t\tcase 0x0000:\n\t\t\t\tif ( !st->significand[0] &&\n\t\t\t\t     !st->significand[1] &&\n\t\t\t\t     !st->significand[2] &&\n\t\t\t\t     !st->significand[3] ) {\n\t\t\t\t\ttag = 1;\t \n\t\t\t\t} else {\n\t\t\t\t\ttag = 2;\t \n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (st->significand[3] & 0x8000) {\n\t\t\t\t\ttag = 0;\t \n\t\t\t\t} else {\n\t\t\t\t\ttag = 2;\t \n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\ttag = 3;\t\t\t \n\t\t}\n\t\tret |= (tag << (2 * i));\n\t\ttwd = twd >> 1;\n\t}\n\treturn ret;\n}\n\nstatic int convert_fxsr_to_user(struct _fpstate __user *buf,\n\t\t\t\tstruct user_fxsr_struct *fxsave)\n{\n\tunsigned long env[7];\n\tstruct _fpreg __user *to;\n\tstruct _fpxreg *from;\n\tint i;\n\n\tenv[0] = (unsigned long)fxsave->cwd | 0xffff0000ul;\n\tenv[1] = (unsigned long)fxsave->swd | 0xffff0000ul;\n\tenv[2] = twd_fxsr_to_i387(fxsave);\n\tenv[3] = fxsave->fip;\n\tenv[4] = fxsave->fcs | ((unsigned long)fxsave->fop << 16);\n\tenv[5] = fxsave->foo;\n\tenv[6] = fxsave->fos;\n\n\tif (__copy_to_user(buf, env, 7 * sizeof(unsigned long)))\n\t\treturn 1;\n\n\tto = &buf->_st[0];\n\tfrom = (struct _fpxreg *) &fxsave->st_space[0];\n\tfor (i = 0; i < 8; i++, to++, from++) {\n\t\tunsigned long __user *t = (unsigned long __user *)to;\n\t\tunsigned long *f = (unsigned long *)from;\n\n\t\tif (__put_user(*f, t) ||\n\t\t\t\t__put_user(*(f + 1), t + 1) ||\n\t\t\t\t__put_user(from->exponent, &to->exponent))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int convert_fxsr_from_user(struct user_fxsr_struct *fxsave,\n\t\t\t\t  struct _fpstate __user *buf)\n{\n\tunsigned long env[7];\n\tstruct _fpxreg *to;\n\tstruct _fpreg __user *from;\n\tint i;\n\n\tif (copy_from_user( env, buf, 7 * sizeof(long)))\n\t\treturn 1;\n\n\tfxsave->cwd = (unsigned short)(env[0] & 0xffff);\n\tfxsave->swd = (unsigned short)(env[1] & 0xffff);\n\tfxsave->twd = twd_i387_to_fxsr((unsigned short)(env[2] & 0xffff));\n\tfxsave->fip = env[3];\n\tfxsave->fop = (unsigned short)((env[4] & 0xffff0000ul) >> 16);\n\tfxsave->fcs = (env[4] & 0xffff);\n\tfxsave->foo = env[5];\n\tfxsave->fos = env[6];\n\n\tto = (struct _fpxreg *) &fxsave->st_space[0];\n\tfrom = &buf->_st[0];\n\tfor (i = 0; i < 8; i++, to++, from++) {\n\t\tunsigned long *t = (unsigned long *)to;\n\t\tunsigned long __user *f = (unsigned long __user *)from;\n\n\t\tif (__get_user(*t, f) ||\n\t\t    __get_user(*(t + 1), f + 1) ||\n\t\t    __get_user(to->exponent, &from->exponent))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nextern int have_fpx_regs;\n\n#endif\n\nstatic int copy_sc_from_user(struct pt_regs *regs,\n\t\t\t     struct sigcontext __user *from)\n{\n\tstruct sigcontext sc;\n\tint err, pid;\n\n\t \n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\terr = copy_from_user(&sc, from, sizeof(sc));\n\tif (err)\n\t\treturn err;\n\n#define GETREG(regno, regname) regs->regs.gp[HOST_##regno] = sc.regname\n\n#ifdef CONFIG_X86_32\n\tGETREG(GS, gs);\n\tGETREG(FS, fs);\n\tGETREG(ES, es);\n\tGETREG(DS, ds);\n#endif\n\tGETREG(DI, di);\n\tGETREG(SI, si);\n\tGETREG(BP, bp);\n\tGETREG(SP, sp);\n\tGETREG(BX, bx);\n\tGETREG(DX, dx);\n\tGETREG(CX, cx);\n\tGETREG(AX, ax);\n\tGETREG(IP, ip);\n\n#ifdef CONFIG_X86_64\n\tGETREG(R8, r8);\n\tGETREG(R9, r9);\n\tGETREG(R10, r10);\n\tGETREG(R11, r11);\n\tGETREG(R12, r12);\n\tGETREG(R13, r13);\n\tGETREG(R14, r14);\n\tGETREG(R15, r15);\n#endif\n\n\tGETREG(CS, cs);\n\tGETREG(EFLAGS, flags);\n#ifdef CONFIG_X86_32\n\tGETREG(SS, ss);\n#endif\n\n#undef GETREG\n\n\tpid = userspace_pid[current_thread_info()->cpu];\n#ifdef CONFIG_X86_32\n\tif (have_fpx_regs) {\n\t\tstruct user_fxsr_struct fpx;\n\n\t\terr = copy_from_user(&fpx,\n\t\t\t&((struct _fpstate __user *)sc.fpstate)->_fxsr_env[0],\n\t\t\t\t     sizeof(struct user_fxsr_struct));\n\t\tif (err)\n\t\t\treturn 1;\n\n\t\terr = convert_fxsr_from_user(&fpx, (void *)sc.fpstate);\n\t\tif (err)\n\t\t\treturn 1;\n\n\t\terr = restore_fpx_registers(pid, (unsigned long *) &fpx);\n\t\tif (err < 0) {\n\t\t\tprintk(KERN_ERR \"copy_sc_from_user - \"\n\t\t\t       \"restore_fpx_registers failed, errno = %d\\n\",\n\t\t\t       -err);\n\t\t\treturn 1;\n\t\t}\n\t} else\n#endif\n\t{\n\t\terr = copy_from_user(regs->regs.fp, (void *)sc.fpstate,\n\t\t\t\t     sizeof(struct _xstate));\n\t\tif (err)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int copy_sc_to_user(struct sigcontext __user *to,\n\t\t\t   struct _xstate __user *to_fp, struct pt_regs *regs,\n\t\t\t   unsigned long mask)\n{\n\tstruct sigcontext sc;\n\tstruct faultinfo * fi = &current->thread.arch.faultinfo;\n\tint err, pid;\n\tmemset(&sc, 0, sizeof(struct sigcontext));\n\n#define PUTREG(regno, regname) sc.regname = regs->regs.gp[HOST_##regno]\n\n#ifdef CONFIG_X86_32\n\tPUTREG(GS, gs);\n\tPUTREG(FS, fs);\n\tPUTREG(ES, es);\n\tPUTREG(DS, ds);\n#endif\n\tPUTREG(DI, di);\n\tPUTREG(SI, si);\n\tPUTREG(BP, bp);\n\tPUTREG(SP, sp);\n\tPUTREG(BX, bx);\n\tPUTREG(DX, dx);\n\tPUTREG(CX, cx);\n\tPUTREG(AX, ax);\n#ifdef CONFIG_X86_64\n\tPUTREG(R8, r8);\n\tPUTREG(R9, r9);\n\tPUTREG(R10, r10);\n\tPUTREG(R11, r11);\n\tPUTREG(R12, r12);\n\tPUTREG(R13, r13);\n\tPUTREG(R14, r14);\n\tPUTREG(R15, r15);\n#endif\n\n\tsc.cr2 = fi->cr2;\n\tsc.err = fi->error_code;\n\tsc.trapno = fi->trap_no;\n\tPUTREG(IP, ip);\n\tPUTREG(CS, cs);\n\tPUTREG(EFLAGS, flags);\n#ifdef CONFIG_X86_32\n\tPUTREG(SP, sp_at_signal);\n\tPUTREG(SS, ss);\n#endif\n#undef PUTREG\n\tsc.oldmask = mask;\n\tsc.fpstate = (unsigned long)to_fp;\n\n\terr = copy_to_user(to, &sc, sizeof(struct sigcontext));\n\tif (err)\n\t\treturn 1;\n\n\tpid = userspace_pid[current_thread_info()->cpu];\n\n#ifdef CONFIG_X86_32\n\tif (have_fpx_regs) {\n\t\tstruct user_fxsr_struct fpx;\n\n\t\terr = save_fpx_registers(pid, (unsigned long *) &fpx);\n\t\tif (err < 0){\n\t\t\tprintk(KERN_ERR \"copy_sc_to_user - save_fpx_registers \"\n\t\t\t       \"failed, errno = %d\\n\", err);\n\t\t\treturn 1;\n\t\t}\n\n\t\terr = convert_fxsr_to_user(&to_fp->fpstate, &fpx);\n\t\tif (err)\n\t\t\treturn 1;\n\n\t\terr |= __put_user(fpx.swd, &to_fp->fpstate.status);\n\t\terr |= __put_user(X86_FXSR_MAGIC, &to_fp->fpstate.magic);\n\t\tif (err)\n\t\t\treturn 1;\n\n\t\tif (copy_to_user(&to_fp->fpstate._fxsr_env[0], &fpx,\n\t\t\t\t sizeof(struct user_fxsr_struct)))\n\t\t\treturn 1;\n\t} else\n#endif\n\t{\n\t\tif (copy_to_user(to_fp, regs->regs.fp, sizeof(struct _xstate)))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_X86_32\nstatic int copy_ucontext_to_user(struct ucontext __user *uc,\n\t\t\t\t struct _xstate __user *fp, sigset_t *set,\n\t\t\t\t unsigned long sp)\n{\n\tint err = 0;\n\n\terr |= __save_altstack(&uc->uc_stack, sp);\n\terr |= copy_sc_to_user(&uc->uc_mcontext, fp, &current->thread.regs, 0);\n\terr |= copy_to_user(&uc->uc_sigmask, set, sizeof(*set));\n\treturn err;\n}\n\nstruct sigframe\n{\n\tchar __user *pretcode;\n\tint sig;\n\tstruct sigcontext sc;\n\tstruct _xstate fpstate;\n\tunsigned long extramask[_NSIG_WORDS-1];\n\tchar retcode[8];\n};\n\nstruct rt_sigframe\n{\n\tchar __user *pretcode;\n\tint sig;\n\tstruct siginfo __user *pinfo;\n\tvoid __user *puc;\n\tstruct siginfo info;\n\tstruct ucontext uc;\n\tstruct _xstate fpstate;\n\tchar retcode[8];\n};\n\nint setup_signal_stack_sc(unsigned long stack_top, struct ksignal *ksig,\n\t\t\t  struct pt_regs *regs, sigset_t *mask)\n{\n\tstruct sigframe __user *frame;\n\tvoid __user *restorer;\n\tint err = 0, sig = ksig->sig;\n\n\t \n\tstack_top = ((stack_top + 4) & -16UL) - 4;\n\tframe = (struct sigframe __user *) stack_top - 1;\n\tif (!access_ok(frame, sizeof(*frame)))\n\t\treturn 1;\n\n\trestorer = frame->retcode;\n\tif (ksig->ka.sa.sa_flags & SA_RESTORER)\n\t\trestorer = ksig->ka.sa.sa_restorer;\n\n\terr |= __put_user(restorer, &frame->pretcode);\n\terr |= __put_user(sig, &frame->sig);\n\terr |= copy_sc_to_user(&frame->sc, &frame->fpstate, regs, mask->sig[0]);\n\tif (_NSIG_WORDS > 1)\n\t\terr |= __copy_to_user(&frame->extramask, &mask->sig[1],\n\t\t\t\t      sizeof(frame->extramask));\n\n\t \n\terr |= __put_user(0xb858, (short __user *)(frame->retcode+0));\n\terr |= __put_user(__NR_sigreturn, (int __user *)(frame->retcode+2));\n\terr |= __put_user(0x80cd, (short __user *)(frame->retcode+6));\n\n\tif (err)\n\t\treturn err;\n\n\tPT_REGS_SP(regs) = (unsigned long) frame;\n\tPT_REGS_IP(regs) = (unsigned long) ksig->ka.sa.sa_handler;\n\tPT_REGS_AX(regs) = (unsigned long) sig;\n\tPT_REGS_DX(regs) = (unsigned long) 0;\n\tPT_REGS_CX(regs) = (unsigned long) 0;\n\treturn 0;\n}\n\nint setup_signal_stack_si(unsigned long stack_top, struct ksignal *ksig,\n\t\t\t  struct pt_regs *regs, sigset_t *mask)\n{\n\tstruct rt_sigframe __user *frame;\n\tvoid __user *restorer;\n\tint err = 0, sig = ksig->sig;\n\n\tstack_top &= -8UL;\n\tframe = (struct rt_sigframe __user *) stack_top - 1;\n\tif (!access_ok(frame, sizeof(*frame)))\n\t\treturn 1;\n\n\trestorer = frame->retcode;\n\tif (ksig->ka.sa.sa_flags & SA_RESTORER)\n\t\trestorer = ksig->ka.sa.sa_restorer;\n\n\terr |= __put_user(restorer, &frame->pretcode);\n\terr |= __put_user(sig, &frame->sig);\n\terr |= __put_user(&frame->info, &frame->pinfo);\n\terr |= __put_user(&frame->uc, &frame->puc);\n\terr |= copy_siginfo_to_user(&frame->info, &ksig->info);\n\terr |= copy_ucontext_to_user(&frame->uc, &frame->fpstate, mask,\n\t\t\t\t\tPT_REGS_SP(regs));\n\n\t \n\terr |= __put_user(0xb8, (char __user *)(frame->retcode+0));\n\terr |= __put_user(__NR_rt_sigreturn, (int __user *)(frame->retcode+1));\n\terr |= __put_user(0x80cd, (short __user *)(frame->retcode+5));\n\n\tif (err)\n\t\treturn err;\n\n\tPT_REGS_SP(regs) = (unsigned long) frame;\n\tPT_REGS_IP(regs) = (unsigned long) ksig->ka.sa.sa_handler;\n\tPT_REGS_AX(regs) = (unsigned long) sig;\n\tPT_REGS_DX(regs) = (unsigned long) &frame->info;\n\tPT_REGS_CX(regs) = (unsigned long) &frame->uc;\n\treturn 0;\n}\n\nlong sys_sigreturn(void)\n{\n\tunsigned long sp = PT_REGS_SP(&current->thread.regs);\n\tstruct sigframe __user *frame = (struct sigframe __user *)(sp - 8);\n\tsigset_t set;\n\tstruct sigcontext __user *sc = &frame->sc;\n\tint sig_size = (_NSIG_WORDS - 1) * sizeof(unsigned long);\n\n\tif (copy_from_user(&set.sig[0], &sc->oldmask, sizeof(set.sig[0])) ||\n\t    copy_from_user(&set.sig[1], frame->extramask, sig_size))\n\t\tgoto segfault;\n\n\tset_current_blocked(&set);\n\n\tif (copy_sc_from_user(&current->thread.regs, sc))\n\t\tgoto segfault;\n\n\t \n\tPT_REGS_SYSCALL_NR(&current->thread.regs) = -1;\n\treturn PT_REGS_SYSCALL_RET(&current->thread.regs);\n\n segfault:\n\tforce_sig(SIGSEGV);\n\treturn 0;\n}\n\n#else\n\nstruct rt_sigframe\n{\n\tchar __user *pretcode;\n\tstruct ucontext uc;\n\tstruct siginfo info;\n\tstruct _xstate fpstate;\n};\n\nint setup_signal_stack_si(unsigned long stack_top, struct ksignal *ksig,\n\t\t\t  struct pt_regs *regs, sigset_t *set)\n{\n\tstruct rt_sigframe __user *frame;\n\tint err = 0, sig = ksig->sig;\n\tunsigned long fp_to;\n\n\tframe = (struct rt_sigframe __user *)\n\t\tround_down(stack_top - sizeof(struct rt_sigframe), 16);\n\t \n\tframe = (struct rt_sigframe __user *) ((unsigned long) frame - 128 - 8);\n\n\tif (!access_ok(frame, sizeof(*frame)))\n\t\tgoto out;\n\n\tif (ksig->ka.sa.sa_flags & SA_SIGINFO) {\n\t\terr |= copy_siginfo_to_user(&frame->info, &ksig->info);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t \n\terr |= __put_user(0, &frame->uc.uc_flags);\n\terr |= __put_user(0, &frame->uc.uc_link);\n\terr |= __save_altstack(&frame->uc.uc_stack, PT_REGS_SP(regs));\n\terr |= copy_sc_to_user(&frame->uc.uc_mcontext, &frame->fpstate, regs,\n\t\t\t       set->sig[0]);\n\n\tfp_to = (unsigned long)&frame->fpstate;\n\n\terr |= __put_user(fp_to, &frame->uc.uc_mcontext.fpstate);\n\tif (sizeof(*set) == 16) {\n\t\terr |= __put_user(set->sig[0], &frame->uc.uc_sigmask.sig[0]);\n\t\terr |= __put_user(set->sig[1], &frame->uc.uc_sigmask.sig[1]);\n\t}\n\telse\n\t\terr |= __copy_to_user(&frame->uc.uc_sigmask, set,\n\t\t\t\t      sizeof(*set));\n\n\t \n\t \n\tif (ksig->ka.sa.sa_flags & SA_RESTORER)\n\t\terr |= __put_user((void *)ksig->ka.sa.sa_restorer,\n\t\t\t\t  &frame->pretcode);\n\telse\n\t\t \n\t\treturn err;\n\n\tif (err)\n\t\treturn err;\n\n\tPT_REGS_SP(regs) = (unsigned long) frame;\n\tPT_REGS_DI(regs) = sig;\n\t \n\tPT_REGS_AX(regs) = 0;\n\n\t \n\tPT_REGS_SI(regs) = (unsigned long) &frame->info;\n\tPT_REGS_DX(regs) = (unsigned long) &frame->uc;\n\tPT_REGS_IP(regs) = (unsigned long) ksig->ka.sa.sa_handler;\n out:\n\treturn err;\n}\n#endif\n\nlong sys_rt_sigreturn(void)\n{\n\tunsigned long sp = PT_REGS_SP(&current->thread.regs);\n\tstruct rt_sigframe __user *frame =\n\t\t(struct rt_sigframe __user *)(sp - sizeof(long));\n\tstruct ucontext __user *uc = &frame->uc;\n\tsigset_t set;\n\n\tif (copy_from_user(&set, &uc->uc_sigmask, sizeof(set)))\n\t\tgoto segfault;\n\n\tset_current_blocked(&set);\n\n\tif (copy_sc_from_user(&current->thread.regs, &uc->uc_mcontext))\n\t\tgoto segfault;\n\n\t \n\tPT_REGS_SYSCALL_NR(&current->thread.regs) = -1;\n\treturn PT_REGS_SYSCALL_RET(&current->thread.regs);\n\n segfault:\n\tforce_sig(SIGSEGV);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}