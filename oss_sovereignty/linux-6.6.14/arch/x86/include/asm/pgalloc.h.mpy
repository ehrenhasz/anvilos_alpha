{
  "module_name": "pgalloc.h",
  "hash_id": "6276beaee8825ca17129f6ccf644f0c0de6ef1d01bc51491e7de8bd09ff89e60",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/pgalloc.h",
  "human_readable_source": " \n#ifndef _ASM_X86_PGALLOC_H\n#define _ASM_X86_PGALLOC_H\n\n#include <linux/threads.h>\n#include <linux/mm.h>\t\t \n#include <linux/pagemap.h>\n\n#define __HAVE_ARCH_PTE_ALLOC_ONE\n#define __HAVE_ARCH_PGD_FREE\n#include <asm-generic/pgalloc.h>\n\nstatic inline int  __paravirt_pgd_alloc(struct mm_struct *mm) { return 0; }\n\n#ifdef CONFIG_PARAVIRT_XXL\n#include <asm/paravirt.h>\n#else\n#define paravirt_pgd_alloc(mm)\t__paravirt_pgd_alloc(mm)\nstatic inline void paravirt_pgd_free(struct mm_struct *mm, pgd_t *pgd) {}\nstatic inline void paravirt_alloc_pte(struct mm_struct *mm, unsigned long pfn)\t{}\nstatic inline void paravirt_alloc_pmd(struct mm_struct *mm, unsigned long pfn)\t{}\nstatic inline void paravirt_alloc_pmd_clone(unsigned long pfn, unsigned long clonepfn,\n\t\t\t\t\t    unsigned long start, unsigned long count) {}\nstatic inline void paravirt_alloc_pud(struct mm_struct *mm, unsigned long pfn)\t{}\nstatic inline void paravirt_alloc_p4d(struct mm_struct *mm, unsigned long pfn)\t{}\nstatic inline void paravirt_release_pte(unsigned long pfn) {}\nstatic inline void paravirt_release_pmd(unsigned long pfn) {}\nstatic inline void paravirt_release_pud(unsigned long pfn) {}\nstatic inline void paravirt_release_p4d(unsigned long pfn) {}\n#endif\n\n \nextern gfp_t __userpte_alloc_gfp;\n\n#ifdef CONFIG_PAGE_TABLE_ISOLATION\n \n#define PGD_ALLOCATION_ORDER 1\n#else\n#define PGD_ALLOCATION_ORDER 0\n#endif\n\n \nextern pgd_t *pgd_alloc(struct mm_struct *);\nextern void pgd_free(struct mm_struct *mm, pgd_t *pgd);\n\nextern pgtable_t pte_alloc_one(struct mm_struct *);\n\nextern void ___pte_free_tlb(struct mmu_gather *tlb, struct page *pte);\n\nstatic inline void __pte_free_tlb(struct mmu_gather *tlb, struct page *pte,\n\t\t\t\t  unsigned long address)\n{\n\t___pte_free_tlb(tlb, pte);\n}\n\nstatic inline void pmd_populate_kernel(struct mm_struct *mm,\n\t\t\t\t       pmd_t *pmd, pte_t *pte)\n{\n\tparavirt_alloc_pte(mm, __pa(pte) >> PAGE_SHIFT);\n\tset_pmd(pmd, __pmd(__pa(pte) | _PAGE_TABLE));\n}\n\nstatic inline void pmd_populate_kernel_safe(struct mm_struct *mm,\n\t\t\t\t       pmd_t *pmd, pte_t *pte)\n{\n\tparavirt_alloc_pte(mm, __pa(pte) >> PAGE_SHIFT);\n\tset_pmd_safe(pmd, __pmd(__pa(pte) | _PAGE_TABLE));\n}\n\nstatic inline void pmd_populate(struct mm_struct *mm, pmd_t *pmd,\n\t\t\t\tstruct page *pte)\n{\n\tunsigned long pfn = page_to_pfn(pte);\n\n\tparavirt_alloc_pte(mm, pfn);\n\tset_pmd(pmd, __pmd(((pteval_t)pfn << PAGE_SHIFT) | _PAGE_TABLE));\n}\n\n#if CONFIG_PGTABLE_LEVELS > 2\nextern void ___pmd_free_tlb(struct mmu_gather *tlb, pmd_t *pmd);\n\nstatic inline void __pmd_free_tlb(struct mmu_gather *tlb, pmd_t *pmd,\n\t\t\t\t  unsigned long address)\n{\n\t___pmd_free_tlb(tlb, pmd);\n}\n\n#ifdef CONFIG_X86_PAE\nextern void pud_populate(struct mm_struct *mm, pud_t *pudp, pmd_t *pmd);\n#else\t \nstatic inline void pud_populate(struct mm_struct *mm, pud_t *pud, pmd_t *pmd)\n{\n\tparavirt_alloc_pmd(mm, __pa(pmd) >> PAGE_SHIFT);\n\tset_pud(pud, __pud(_PAGE_TABLE | __pa(pmd)));\n}\n\nstatic inline void pud_populate_safe(struct mm_struct *mm, pud_t *pud, pmd_t *pmd)\n{\n\tparavirt_alloc_pmd(mm, __pa(pmd) >> PAGE_SHIFT);\n\tset_pud_safe(pud, __pud(_PAGE_TABLE | __pa(pmd)));\n}\n#endif\t \n\n#if CONFIG_PGTABLE_LEVELS > 3\nstatic inline void p4d_populate(struct mm_struct *mm, p4d_t *p4d, pud_t *pud)\n{\n\tparavirt_alloc_pud(mm, __pa(pud) >> PAGE_SHIFT);\n\tset_p4d(p4d, __p4d(_PAGE_TABLE | __pa(pud)));\n}\n\nstatic inline void p4d_populate_safe(struct mm_struct *mm, p4d_t *p4d, pud_t *pud)\n{\n\tparavirt_alloc_pud(mm, __pa(pud) >> PAGE_SHIFT);\n\tset_p4d_safe(p4d, __p4d(_PAGE_TABLE | __pa(pud)));\n}\n\nextern void ___pud_free_tlb(struct mmu_gather *tlb, pud_t *pud);\n\nstatic inline void __pud_free_tlb(struct mmu_gather *tlb, pud_t *pud,\n\t\t\t\t  unsigned long address)\n{\n\t___pud_free_tlb(tlb, pud);\n}\n\n#if CONFIG_PGTABLE_LEVELS > 4\nstatic inline void pgd_populate(struct mm_struct *mm, pgd_t *pgd, p4d_t *p4d)\n{\n\tif (!pgtable_l5_enabled())\n\t\treturn;\n\tparavirt_alloc_p4d(mm, __pa(p4d) >> PAGE_SHIFT);\n\tset_pgd(pgd, __pgd(_PAGE_TABLE | __pa(p4d)));\n}\n\nstatic inline void pgd_populate_safe(struct mm_struct *mm, pgd_t *pgd, p4d_t *p4d)\n{\n\tif (!pgtable_l5_enabled())\n\t\treturn;\n\tparavirt_alloc_p4d(mm, __pa(p4d) >> PAGE_SHIFT);\n\tset_pgd_safe(pgd, __pgd(_PAGE_TABLE | __pa(p4d)));\n}\n\nstatic inline p4d_t *p4d_alloc_one(struct mm_struct *mm, unsigned long addr)\n{\n\tgfp_t gfp = GFP_KERNEL_ACCOUNT;\n\n\tif (mm == &init_mm)\n\t\tgfp &= ~__GFP_ACCOUNT;\n\treturn (p4d_t *)get_zeroed_page(gfp);\n}\n\nstatic inline void p4d_free(struct mm_struct *mm, p4d_t *p4d)\n{\n\tif (!pgtable_l5_enabled())\n\t\treturn;\n\n\tBUG_ON((unsigned long)p4d & (PAGE_SIZE-1));\n\tfree_page((unsigned long)p4d);\n}\n\nextern void ___p4d_free_tlb(struct mmu_gather *tlb, p4d_t *p4d);\n\nstatic inline void __p4d_free_tlb(struct mmu_gather *tlb, p4d_t *p4d,\n\t\t\t\t  unsigned long address)\n{\n\tif (pgtable_l5_enabled())\n\t\t___p4d_free_tlb(tlb, p4d);\n}\n\n#endif\t \n#endif\t \n#endif\t \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}