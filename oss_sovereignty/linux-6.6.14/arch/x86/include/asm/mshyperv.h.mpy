{
  "module_name": "mshyperv.h",
  "hash_id": "ecbaf1351da9982244f73f8c1697597fe80e9a2ebeea352cb44b1e232770b0ed",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/mshyperv.h",
  "human_readable_source": " \n#ifndef _ASM_X86_MSHYPER_H\n#define _ASM_X86_MSHYPER_H\n\n#include <linux/types.h>\n#include <linux/nmi.h>\n#include <linux/msi.h>\n#include <linux/io.h>\n#include <asm/hyperv-tlfs.h>\n#include <asm/nospec-branch.h>\n#include <asm/paravirt.h>\n#include <asm/mshyperv.h>\n\n \n#define HV_IOAPIC_BASE_ADDRESS 0xfec00000\n\n#define HV_VTL_NORMAL 0x0\n#define HV_VTL_SECURE 0x1\n#define HV_VTL_MGMT   0x2\n\nunion hv_ghcb;\n\nDECLARE_STATIC_KEY_FALSE(isolation_type_snp);\nDECLARE_STATIC_KEY_FALSE(isolation_type_tdx);\n\ntypedef int (*hyperv_fill_flush_list_func)(\n\t\tstruct hv_guest_mapping_flush_list *flush,\n\t\tvoid *data);\n\nvoid hyperv_vector_handler(struct pt_regs *regs);\n\nstatic inline unsigned char hv_get_nmi_reason(void)\n{\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_HYPERV)\nextern int hyperv_init_cpuhp;\nextern bool hyperv_paravisor_present;\n\nextern void *hv_hypercall_pg;\n\nextern u64 hv_current_partition_id;\n\nextern union hv_ghcb * __percpu *hv_ghcb_pg;\n\nbool hv_isolation_type_snp(void);\nbool hv_isolation_type_tdx(void);\nu64 hv_tdx_hypercall(u64 control, u64 param1, u64 param2);\n\n \n#define HV_AP_INIT_GPAT_DEFAULT\t\t0x0007040600070406ULL\n#define HV_AP_SEGMENT_LIMIT\t\t0xffffffff\n\nint hv_call_deposit_pages(int node, u64 partition_id, u32 num_pages);\nint hv_call_add_logical_proc(int node, u32 lp_index, u32 acpi_id);\nint hv_call_create_vp(int node, u64 partition_id, u32 vp_index, u32 flags);\n\n \nstatic inline u64 hv_do_hypercall(u64 control, void *input, void *output)\n{\n\tu64 input_address = input ? virt_to_phys(input) : 0;\n\tu64 output_address = output ? virt_to_phys(output) : 0;\n\tu64 hv_status;\n\n#ifdef CONFIG_X86_64\n\tif (hv_isolation_type_tdx() && !hyperv_paravisor_present)\n\t\treturn hv_tdx_hypercall(control, input_address, output_address);\n\n\tif (hv_isolation_type_snp() && !hyperv_paravisor_present) {\n\t\t__asm__ __volatile__(\"mov %4, %%r8\\n\"\n\t\t\t\t     \"vmmcall\"\n\t\t\t\t     : \"=a\" (hv_status), ASM_CALL_CONSTRAINT,\n\t\t\t\t       \"+c\" (control), \"+d\" (input_address)\n\t\t\t\t     :  \"r\" (output_address)\n\t\t\t\t     : \"cc\", \"memory\", \"r8\", \"r9\", \"r10\", \"r11\");\n\t\treturn hv_status;\n\t}\n\n\tif (!hv_hypercall_pg)\n\t\treturn U64_MAX;\n\n\t__asm__ __volatile__(\"mov %4, %%r8\\n\"\n\t\t\t     CALL_NOSPEC\n\t\t\t     : \"=a\" (hv_status), ASM_CALL_CONSTRAINT,\n\t\t\t       \"+c\" (control), \"+d\" (input_address)\n\t\t\t     :  \"r\" (output_address),\n\t\t\t\tTHUNK_TARGET(hv_hypercall_pg)\n\t\t\t     : \"cc\", \"memory\", \"r8\", \"r9\", \"r10\", \"r11\");\n#else\n\tu32 input_address_hi = upper_32_bits(input_address);\n\tu32 input_address_lo = lower_32_bits(input_address);\n\tu32 output_address_hi = upper_32_bits(output_address);\n\tu32 output_address_lo = lower_32_bits(output_address);\n\n\tif (!hv_hypercall_pg)\n\t\treturn U64_MAX;\n\n\t__asm__ __volatile__(CALL_NOSPEC\n\t\t\t     : \"=A\" (hv_status),\n\t\t\t       \"+c\" (input_address_lo), ASM_CALL_CONSTRAINT\n\t\t\t     : \"A\" (control),\n\t\t\t       \"b\" (input_address_hi),\n\t\t\t       \"D\"(output_address_hi), \"S\"(output_address_lo),\n\t\t\t       THUNK_TARGET(hv_hypercall_pg)\n\t\t\t     : \"cc\", \"memory\");\n#endif  \n\treturn hv_status;\n}\n\n \nstatic inline u64 hv_do_nested_hypercall(u64 control, void *input, void *output)\n{\n\treturn hv_do_hypercall(control | HV_HYPERCALL_NESTED, input, output);\n}\n\n \nstatic inline u64 _hv_do_fast_hypercall8(u64 control, u64 input1)\n{\n\tu64 hv_status;\n\n#ifdef CONFIG_X86_64\n\tif (hv_isolation_type_tdx() && !hyperv_paravisor_present)\n\t\treturn hv_tdx_hypercall(control, input1, 0);\n\n\tif (hv_isolation_type_snp() && !hyperv_paravisor_present) {\n\t\t__asm__ __volatile__(\n\t\t\t\t\"vmmcall\"\n\t\t\t\t: \"=a\" (hv_status), ASM_CALL_CONSTRAINT,\n\t\t\t\t\"+c\" (control), \"+d\" (input1)\n\t\t\t\t:: \"cc\", \"r8\", \"r9\", \"r10\", \"r11\");\n\t} else {\n\t\t__asm__ __volatile__(CALL_NOSPEC\n\t\t\t\t     : \"=a\" (hv_status), ASM_CALL_CONSTRAINT,\n\t\t\t\t       \"+c\" (control), \"+d\" (input1)\n\t\t\t\t     : THUNK_TARGET(hv_hypercall_pg)\n\t\t\t\t     : \"cc\", \"r8\", \"r9\", \"r10\", \"r11\");\n\t}\n#else\n\t{\n\t\tu32 input1_hi = upper_32_bits(input1);\n\t\tu32 input1_lo = lower_32_bits(input1);\n\n\t\t__asm__ __volatile__ (CALL_NOSPEC\n\t\t\t\t      : \"=A\"(hv_status),\n\t\t\t\t\t\"+c\"(input1_lo),\n\t\t\t\t\tASM_CALL_CONSTRAINT\n\t\t\t\t      :\t\"A\" (control),\n\t\t\t\t\t\"b\" (input1_hi),\n\t\t\t\t\tTHUNK_TARGET(hv_hypercall_pg)\n\t\t\t\t      : \"cc\", \"edi\", \"esi\");\n\t}\n#endif\n\t\treturn hv_status;\n}\n\nstatic inline u64 hv_do_fast_hypercall8(u16 code, u64 input1)\n{\n\tu64 control = (u64)code | HV_HYPERCALL_FAST_BIT;\n\n\treturn _hv_do_fast_hypercall8(control, input1);\n}\n\nstatic inline u64 hv_do_fast_nested_hypercall8(u16 code, u64 input1)\n{\n\tu64 control = (u64)code | HV_HYPERCALL_FAST_BIT | HV_HYPERCALL_NESTED;\n\n\treturn _hv_do_fast_hypercall8(control, input1);\n}\n\n \nstatic inline u64 _hv_do_fast_hypercall16(u64 control, u64 input1, u64 input2)\n{\n\tu64 hv_status;\n\n#ifdef CONFIG_X86_64\n\tif (hv_isolation_type_tdx() && !hyperv_paravisor_present)\n\t\treturn hv_tdx_hypercall(control, input1, input2);\n\n\tif (hv_isolation_type_snp() && !hyperv_paravisor_present) {\n\t\t__asm__ __volatile__(\"mov %4, %%r8\\n\"\n\t\t\t\t     \"vmmcall\"\n\t\t\t\t     : \"=a\" (hv_status), ASM_CALL_CONSTRAINT,\n\t\t\t\t       \"+c\" (control), \"+d\" (input1)\n\t\t\t\t     : \"r\" (input2)\n\t\t\t\t     : \"cc\", \"r8\", \"r9\", \"r10\", \"r11\");\n\t} else {\n\t\t__asm__ __volatile__(\"mov %4, %%r8\\n\"\n\t\t\t\t     CALL_NOSPEC\n\t\t\t\t     : \"=a\" (hv_status), ASM_CALL_CONSTRAINT,\n\t\t\t\t       \"+c\" (control), \"+d\" (input1)\n\t\t\t\t     : \"r\" (input2),\n\t\t\t\t       THUNK_TARGET(hv_hypercall_pg)\n\t\t\t\t     : \"cc\", \"r8\", \"r9\", \"r10\", \"r11\");\n\t}\n#else\n\t{\n\t\tu32 input1_hi = upper_32_bits(input1);\n\t\tu32 input1_lo = lower_32_bits(input1);\n\t\tu32 input2_hi = upper_32_bits(input2);\n\t\tu32 input2_lo = lower_32_bits(input2);\n\n\t\t__asm__ __volatile__ (CALL_NOSPEC\n\t\t\t\t      : \"=A\"(hv_status),\n\t\t\t\t\t\"+c\"(input1_lo), ASM_CALL_CONSTRAINT\n\t\t\t\t      :\t\"A\" (control), \"b\" (input1_hi),\n\t\t\t\t\t\"D\"(input2_hi), \"S\"(input2_lo),\n\t\t\t\t\tTHUNK_TARGET(hv_hypercall_pg)\n\t\t\t\t      : \"cc\");\n\t}\n#endif\n\treturn hv_status;\n}\n\nstatic inline u64 hv_do_fast_hypercall16(u16 code, u64 input1, u64 input2)\n{\n\tu64 control = (u64)code | HV_HYPERCALL_FAST_BIT;\n\n\treturn _hv_do_fast_hypercall16(control, input1, input2);\n}\n\nstatic inline u64 hv_do_fast_nested_hypercall16(u16 code, u64 input1, u64 input2)\n{\n\tu64 control = (u64)code | HV_HYPERCALL_FAST_BIT | HV_HYPERCALL_NESTED;\n\n\treturn _hv_do_fast_hypercall16(control, input1, input2);\n}\n\nextern struct hv_vp_assist_page **hv_vp_assist_page;\n\nstatic inline struct hv_vp_assist_page *hv_get_vp_assist_page(unsigned int cpu)\n{\n\tif (!hv_vp_assist_page)\n\t\treturn NULL;\n\n\treturn hv_vp_assist_page[cpu];\n}\n\nvoid __init hyperv_init(void);\nvoid hyperv_setup_mmu_ops(void);\nvoid set_hv_tscchange_cb(void (*cb)(void));\nvoid clear_hv_tscchange_cb(void);\nvoid hyperv_stop_tsc_emulation(void);\nint hyperv_flush_guest_mapping(u64 as);\nint hyperv_flush_guest_mapping_range(u64 as,\n\t\thyperv_fill_flush_list_func fill_func, void *data);\nint hyperv_fill_flush_guest_mapping_list(\n\t\tstruct hv_guest_mapping_flush_list *flush,\n\t\tu64 start_gfn, u64 end_gfn);\n\n#ifdef CONFIG_X86_64\nvoid hv_apic_init(void);\nvoid __init hv_init_spinlocks(void);\nbool hv_vcpu_is_preempted(int vcpu);\n#else\nstatic inline void hv_apic_init(void) {}\n#endif\n\nstruct irq_domain *hv_create_pci_msi_domain(void);\n\nint hv_map_ioapic_interrupt(int ioapic_id, bool level, int vcpu, int vector,\n\t\tstruct hv_interrupt_entry *entry);\nint hv_unmap_ioapic_interrupt(int ioapic_id, struct hv_interrupt_entry *entry);\n\n#ifdef CONFIG_AMD_MEM_ENCRYPT\nbool hv_ghcb_negotiate_protocol(void);\nvoid __noreturn hv_ghcb_terminate(unsigned int set, unsigned int reason);\nint hv_snp_boot_ap(int cpu, unsigned long start_ip);\n#else\nstatic inline bool hv_ghcb_negotiate_protocol(void) { return false; }\nstatic inline void hv_ghcb_terminate(unsigned int set, unsigned int reason) {}\nstatic inline int hv_snp_boot_ap(int cpu, unsigned long start_ip) { return 0; }\n#endif\n\n#if defined(CONFIG_AMD_MEM_ENCRYPT) || defined(CONFIG_INTEL_TDX_GUEST)\nvoid hv_vtom_init(void);\nvoid hv_ivm_msr_write(u64 msr, u64 value);\nvoid hv_ivm_msr_read(u64 msr, u64 *value);\n#else\nstatic inline void hv_vtom_init(void) {}\nstatic inline void hv_ivm_msr_write(u64 msr, u64 value) {}\nstatic inline void hv_ivm_msr_read(u64 msr, u64 *value) {}\n#endif\n\nstatic inline bool hv_is_synic_reg(unsigned int reg)\n{\n\treturn (reg >= HV_REGISTER_SCONTROL) &&\n\t       (reg <= HV_REGISTER_SINT15);\n}\n\nstatic inline bool hv_is_sint_reg(unsigned int reg)\n{\n\treturn (reg >= HV_REGISTER_SINT0) &&\n\t       (reg <= HV_REGISTER_SINT15);\n}\n\nu64 hv_get_register(unsigned int reg);\nvoid hv_set_register(unsigned int reg, u64 value);\nu64 hv_get_non_nested_register(unsigned int reg);\nvoid hv_set_non_nested_register(unsigned int reg, u64 value);\n\nstatic __always_inline u64 hv_raw_get_register(unsigned int reg)\n{\n\treturn __rdmsr(reg);\n}\n\n#else  \nstatic inline void hyperv_init(void) {}\nstatic inline void hyperv_setup_mmu_ops(void) {}\nstatic inline void set_hv_tscchange_cb(void (*cb)(void)) {}\nstatic inline void clear_hv_tscchange_cb(void) {}\nstatic inline void hyperv_stop_tsc_emulation(void) {};\nstatic inline struct hv_vp_assist_page *hv_get_vp_assist_page(unsigned int cpu)\n{\n\treturn NULL;\n}\nstatic inline int hyperv_flush_guest_mapping(u64 as) { return -1; }\nstatic inline int hyperv_flush_guest_mapping_range(u64 as,\n\t\thyperv_fill_flush_list_func fill_func, void *data)\n{\n\treturn -1;\n}\nstatic inline void hv_set_register(unsigned int reg, u64 value) { }\nstatic inline u64 hv_get_register(unsigned int reg) { return 0; }\nstatic inline void hv_set_non_nested_register(unsigned int reg, u64 value) { }\nstatic inline u64 hv_get_non_nested_register(unsigned int reg) { return 0; }\n#endif  \n\n\n#ifdef CONFIG_HYPERV_VTL_MODE\nvoid __init hv_vtl_init_platform(void);\nint __init hv_vtl_early_init(void);\n#else\nstatic inline void __init hv_vtl_init_platform(void) {}\nstatic inline int __init hv_vtl_early_init(void) { return 0; }\n#endif\n\n#include <asm-generic/mshyperv.h>\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}