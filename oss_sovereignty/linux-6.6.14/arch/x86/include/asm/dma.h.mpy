{
  "module_name": "dma.h",
  "hash_id": "30dab29e5295bbde71a43eb5913ba845b98c7f7161d2d91729617aa63378ae7d",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/dma.h",
  "human_readable_source": " \n \n\n#ifndef _ASM_X86_DMA_H\n#define _ASM_X86_DMA_H\n\n#include <linux/spinlock.h>\t \n#include <asm/io.h>\t\t \n\n#ifdef HAVE_REALLY_SLOW_DMA_CONTROLLER\n#define dma_outb\toutb_p\n#else\n#define dma_outb\toutb\n#endif\n\n#define dma_inb\t\tinb\n\n \n\n#define MAX_DMA_CHANNELS\t8\n\n \n#define MAX_DMA_PFN   ((16UL * 1024 * 1024) >> PAGE_SHIFT)\n\n \n#define MAX_DMA32_PFN (1UL << (32 - PAGE_SHIFT))\n\n#ifdef CONFIG_X86_32\n \n#define MAX_DMA_ADDRESS      (PAGE_OFFSET + 0x1000000)\n#else\n \n#define MAX_DMA_ADDRESS ((unsigned long)__va(MAX_DMA_PFN << PAGE_SHIFT))\n#endif\n\n \n#define IO_DMA1_BASE\t0x00\t \n#define IO_DMA2_BASE\t0xC0\t \n\n \n#define DMA1_CMD_REG\t\t0x08\t \n#define DMA1_STAT_REG\t\t0x08\t \n#define DMA1_REQ_REG\t\t0x09     \n#define DMA1_MASK_REG\t\t0x0A\t \n#define DMA1_MODE_REG\t\t0x0B\t \n#define DMA1_CLEAR_FF_REG\t0x0C\t \n#define DMA1_TEMP_REG\t\t0x0D     \n#define DMA1_RESET_REG\t\t0x0D\t \n#define DMA1_CLR_MASK_REG       0x0E     \n#define DMA1_MASK_ALL_REG       0x0F     \n\n#define DMA2_CMD_REG\t\t0xD0\t \n#define DMA2_STAT_REG\t\t0xD0\t \n#define DMA2_REQ_REG\t\t0xD2     \n#define DMA2_MASK_REG\t\t0xD4\t \n#define DMA2_MODE_REG\t\t0xD6\t \n#define DMA2_CLEAR_FF_REG\t0xD8\t \n#define DMA2_TEMP_REG\t\t0xDA     \n#define DMA2_RESET_REG\t\t0xDA\t \n#define DMA2_CLR_MASK_REG       0xDC     \n#define DMA2_MASK_ALL_REG       0xDE     \n\n#define DMA_ADDR_0\t\t0x00     \n#define DMA_ADDR_1\t\t0x02\n#define DMA_ADDR_2\t\t0x04\n#define DMA_ADDR_3\t\t0x06\n#define DMA_ADDR_4\t\t0xC0\n#define DMA_ADDR_5\t\t0xC4\n#define DMA_ADDR_6\t\t0xC8\n#define DMA_ADDR_7\t\t0xCC\n\n#define DMA_CNT_0\t\t0x01     \n#define DMA_CNT_1\t\t0x03\n#define DMA_CNT_2\t\t0x05\n#define DMA_CNT_3\t\t0x07\n#define DMA_CNT_4\t\t0xC2\n#define DMA_CNT_5\t\t0xC6\n#define DMA_CNT_6\t\t0xCA\n#define DMA_CNT_7\t\t0xCE\n\n#define DMA_PAGE_0\t\t0x87     \n#define DMA_PAGE_1\t\t0x83\n#define DMA_PAGE_2\t\t0x81\n#define DMA_PAGE_3\t\t0x82\n#define DMA_PAGE_5\t\t0x8B\n#define DMA_PAGE_6\t\t0x89\n#define DMA_PAGE_7\t\t0x8A\n\n \n#define DMA_MODE_READ\t\t0x44\n \n#define DMA_MODE_WRITE\t\t0x48\n \n#define DMA_MODE_CASCADE\t0xC0\n\n#define DMA_AUTOINIT\t\t0x10\n\n\n#ifdef CONFIG_ISA_DMA_API\nextern spinlock_t  dma_spin_lock;\n\nstatic inline unsigned long claim_dma_lock(void)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&dma_spin_lock, flags);\n\treturn flags;\n}\n\nstatic inline void release_dma_lock(unsigned long flags)\n{\n\tspin_unlock_irqrestore(&dma_spin_lock, flags);\n}\n#endif  \n\n \nstatic inline void enable_dma(unsigned int dmanr)\n{\n\tif (dmanr <= 3)\n\t\tdma_outb(dmanr, DMA1_MASK_REG);\n\telse\n\t\tdma_outb(dmanr & 3, DMA2_MASK_REG);\n}\n\nstatic inline void disable_dma(unsigned int dmanr)\n{\n\tif (dmanr <= 3)\n\t\tdma_outb(dmanr | 4, DMA1_MASK_REG);\n\telse\n\t\tdma_outb((dmanr & 3) | 4, DMA2_MASK_REG);\n}\n\n \nstatic inline void clear_dma_ff(unsigned int dmanr)\n{\n\tif (dmanr <= 3)\n\t\tdma_outb(0, DMA1_CLEAR_FF_REG);\n\telse\n\t\tdma_outb(0, DMA2_CLEAR_FF_REG);\n}\n\n \nstatic inline void set_dma_mode(unsigned int dmanr, char mode)\n{\n\tif (dmanr <= 3)\n\t\tdma_outb(mode | dmanr, DMA1_MODE_REG);\n\telse\n\t\tdma_outb(mode | (dmanr & 3), DMA2_MODE_REG);\n}\n\n \nstatic inline void set_dma_page(unsigned int dmanr, char pagenr)\n{\n\tswitch (dmanr) {\n\tcase 0:\n\t\tdma_outb(pagenr, DMA_PAGE_0);\n\t\tbreak;\n\tcase 1:\n\t\tdma_outb(pagenr, DMA_PAGE_1);\n\t\tbreak;\n\tcase 2:\n\t\tdma_outb(pagenr, DMA_PAGE_2);\n\t\tbreak;\n\tcase 3:\n\t\tdma_outb(pagenr, DMA_PAGE_3);\n\t\tbreak;\n\tcase 5:\n\t\tdma_outb(pagenr & 0xfe, DMA_PAGE_5);\n\t\tbreak;\n\tcase 6:\n\t\tdma_outb(pagenr & 0xfe, DMA_PAGE_6);\n\t\tbreak;\n\tcase 7:\n\t\tdma_outb(pagenr & 0xfe, DMA_PAGE_7);\n\t\tbreak;\n\t}\n}\n\n\n \nstatic inline void set_dma_addr(unsigned int dmanr, unsigned int a)\n{\n\tset_dma_page(dmanr, a>>16);\n\tif (dmanr <= 3)  {\n\t\tdma_outb(a & 0xff, ((dmanr & 3) << 1) + IO_DMA1_BASE);\n\t\tdma_outb((a >> 8) & 0xff, ((dmanr & 3) << 1) + IO_DMA1_BASE);\n\t}  else  {\n\t\tdma_outb((a >> 1) & 0xff, ((dmanr & 3) << 2) + IO_DMA2_BASE);\n\t\tdma_outb((a >> 9) & 0xff, ((dmanr & 3) << 2) + IO_DMA2_BASE);\n\t}\n}\n\n\n \nstatic inline void set_dma_count(unsigned int dmanr, unsigned int count)\n{\n\tcount--;\n\tif (dmanr <= 3)  {\n\t\tdma_outb(count & 0xff, ((dmanr & 3) << 1) + 1 + IO_DMA1_BASE);\n\t\tdma_outb((count >> 8) & 0xff,\n\t\t\t ((dmanr & 3) << 1) + 1 + IO_DMA1_BASE);\n\t} else {\n\t\tdma_outb((count >> 1) & 0xff,\n\t\t\t ((dmanr & 3) << 2) + 2 + IO_DMA2_BASE);\n\t\tdma_outb((count >> 9) & 0xff,\n\t\t\t ((dmanr & 3) << 2) + 2 + IO_DMA2_BASE);\n\t}\n}\n\n\n \nstatic inline int get_dma_residue(unsigned int dmanr)\n{\n\tunsigned int io_port;\n\t \n\tunsigned short count;\n\n\tio_port = (dmanr <= 3) ? ((dmanr & 3) << 1) + 1 + IO_DMA1_BASE\n\t\t: ((dmanr & 3) << 2) + 2 + IO_DMA2_BASE;\n\n\tcount = 1 + dma_inb(io_port);\n\tcount += dma_inb(io_port) << 8;\n\n\treturn (dmanr <= 3) ? count : (count << 1);\n}\n\n\n \n#ifdef CONFIG_ISA_DMA_API\nextern int request_dma(unsigned int dmanr, const char *device_id);\nextern void free_dma(unsigned int dmanr);\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}