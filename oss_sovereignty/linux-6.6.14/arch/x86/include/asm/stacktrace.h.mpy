{
  "module_name": "stacktrace.h",
  "hash_id": "6eb1693e05148556183c72d773b0bd4fcf1735146bae875d002c7059077eba77",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/stacktrace.h",
  "human_readable_source": " \n \n\n#ifndef _ASM_X86_STACKTRACE_H\n#define _ASM_X86_STACKTRACE_H\n\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n\n#include <asm/cpu_entry_area.h>\n#include <asm/switch_to.h>\n\nenum stack_type {\n\tSTACK_TYPE_UNKNOWN,\n\tSTACK_TYPE_TASK,\n\tSTACK_TYPE_IRQ,\n\tSTACK_TYPE_SOFTIRQ,\n\tSTACK_TYPE_ENTRY,\n\tSTACK_TYPE_EXCEPTION,\n\tSTACK_TYPE_EXCEPTION_LAST = STACK_TYPE_EXCEPTION + N_EXCEPTION_STACKS-1,\n};\n\nstruct stack_info {\n\tenum stack_type type;\n\tunsigned long *begin, *end, *next_sp;\n};\n\nbool in_task_stack(unsigned long *stack, struct task_struct *task,\n\t\t   struct stack_info *info);\n\nbool in_entry_stack(unsigned long *stack, struct stack_info *info);\n\nint get_stack_info(unsigned long *stack, struct task_struct *task,\n\t\t   struct stack_info *info, unsigned long *visit_mask);\nbool get_stack_info_noinstr(unsigned long *stack, struct task_struct *task,\n\t\t\t    struct stack_info *info);\n\nstatic __always_inline\nbool get_stack_guard_info(unsigned long *stack, struct stack_info *info)\n{\n\t \n\tif (get_stack_info_noinstr(stack, current, info))\n\t\treturn false;\n\t \n\treturn get_stack_info_noinstr((void *)stack + PAGE_SIZE, current, info);\n}\n\nconst char *stack_type_name(enum stack_type type);\n\nstatic inline bool on_stack(struct stack_info *info, void *addr, size_t len)\n{\n\tvoid *begin = info->begin;\n\tvoid *end   = info->end;\n\n\treturn (info->type != STACK_TYPE_UNKNOWN &&\n\t\taddr >= begin && addr < end &&\n\t\taddr + len > begin && addr + len <= end);\n}\n\n#ifdef CONFIG_X86_32\n#define STACKSLOTS_PER_LINE 8\n#else\n#define STACKSLOTS_PER_LINE 4\n#endif\n\n#ifdef CONFIG_FRAME_POINTER\nstatic inline unsigned long *\nget_frame_pointer(struct task_struct *task, struct pt_regs *regs)\n{\n\tif (regs)\n\t\treturn (unsigned long *)regs->bp;\n\n\tif (task == current)\n\t\treturn __builtin_frame_address(0);\n\n\treturn &((struct inactive_task_frame *)task->thread.sp)->bp;\n}\n#else\nstatic inline unsigned long *\nget_frame_pointer(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn NULL;\n}\n#endif  \n\nstatic inline unsigned long *\nget_stack_pointer(struct task_struct *task, struct pt_regs *regs)\n{\n\tif (regs)\n\t\treturn (unsigned long *)regs->sp;\n\n\tif (task == current)\n\t\treturn __builtin_frame_address(0);\n\n\treturn (unsigned long *)task->thread.sp;\n}\n\n \nstruct stack_frame {\n\tstruct stack_frame *next_frame;\n\tunsigned long return_address;\n};\n\nstruct stack_frame_ia32 {\n    u32 next_frame;\n    u32 return_address;\n};\n\nvoid show_opcodes(struct pt_regs *regs, const char *loglvl);\nvoid show_ip(struct pt_regs *regs, const char *loglvl);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}