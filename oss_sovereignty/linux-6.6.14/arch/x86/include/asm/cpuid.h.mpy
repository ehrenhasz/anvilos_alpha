{
  "module_name": "cpuid.h",
  "hash_id": "4631c00458312eca19bf31520d8d3f5ce4be4eb5379363e23ecf71978639060e",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/cpuid.h",
  "human_readable_source": " \n \n\n#ifndef _ASM_X86_CPUID_H\n#define _ASM_X86_CPUID_H\n\n#include <asm/string.h>\n\nstruct cpuid_regs {\n\tu32 eax, ebx, ecx, edx;\n};\n\nenum cpuid_regs_idx {\n\tCPUID_EAX = 0,\n\tCPUID_EBX,\n\tCPUID_ECX,\n\tCPUID_EDX,\n};\n\n#ifdef CONFIG_X86_32\nextern int have_cpuid_p(void);\n#else\nstatic inline int have_cpuid_p(void)\n{\n\treturn 1;\n}\n#endif\nstatic inline void native_cpuid(unsigned int *eax, unsigned int *ebx,\n\t\t\t\tunsigned int *ecx, unsigned int *edx)\n{\n\t \n\tasm volatile(\"cpuid\"\n\t    : \"=a\" (*eax),\n\t      \"=b\" (*ebx),\n\t      \"=c\" (*ecx),\n\t      \"=d\" (*edx)\n\t    : \"0\" (*eax), \"2\" (*ecx)\n\t    : \"memory\");\n}\n\n#define native_cpuid_reg(reg)\t\t\t\t\t\\\nstatic inline unsigned int native_cpuid_##reg(unsigned int op)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tunsigned int eax = op, ebx, ecx = 0, edx;\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tnative_cpuid(&eax, &ebx, &ecx, &edx);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\treturn reg;\t\t\t\t\t\t\\\n}\n\n \nnative_cpuid_reg(eax)\nnative_cpuid_reg(ebx)\nnative_cpuid_reg(ecx)\nnative_cpuid_reg(edx)\n\n#ifdef CONFIG_PARAVIRT_XXL\n#include <asm/paravirt.h>\n#else\n#define __cpuid\t\t\tnative_cpuid\n#endif\n\n \nstatic inline void cpuid(unsigned int op,\n\t\t\t unsigned int *eax, unsigned int *ebx,\n\t\t\t unsigned int *ecx, unsigned int *edx)\n{\n\t*eax = op;\n\t*ecx = 0;\n\t__cpuid(eax, ebx, ecx, edx);\n}\n\n \nstatic inline void cpuid_count(unsigned int op, int count,\n\t\t\t       unsigned int *eax, unsigned int *ebx,\n\t\t\t       unsigned int *ecx, unsigned int *edx)\n{\n\t*eax = op;\n\t*ecx = count;\n\t__cpuid(eax, ebx, ecx, edx);\n}\n\n \nstatic inline unsigned int cpuid_eax(unsigned int op)\n{\n\tunsigned int eax, ebx, ecx, edx;\n\n\tcpuid(op, &eax, &ebx, &ecx, &edx);\n\n\treturn eax;\n}\n\nstatic inline unsigned int cpuid_ebx(unsigned int op)\n{\n\tunsigned int eax, ebx, ecx, edx;\n\n\tcpuid(op, &eax, &ebx, &ecx, &edx);\n\n\treturn ebx;\n}\n\nstatic inline unsigned int cpuid_ecx(unsigned int op)\n{\n\tunsigned int eax, ebx, ecx, edx;\n\n\tcpuid(op, &eax, &ebx, &ecx, &edx);\n\n\treturn ecx;\n}\n\nstatic inline unsigned int cpuid_edx(unsigned int op)\n{\n\tunsigned int eax, ebx, ecx, edx;\n\n\tcpuid(op, &eax, &ebx, &ecx, &edx);\n\n\treturn edx;\n}\n\nstatic __always_inline bool cpuid_function_is_indexed(u32 function)\n{\n\tswitch (function) {\n\tcase 4:\n\tcase 7:\n\tcase 0xb:\n\tcase 0xd:\n\tcase 0xf:\n\tcase 0x10:\n\tcase 0x12:\n\tcase 0x14:\n\tcase 0x17:\n\tcase 0x18:\n\tcase 0x1d:\n\tcase 0x1e:\n\tcase 0x1f:\n\tcase 0x8000001d:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n#define for_each_possible_hypervisor_cpuid_base(function) \\\n\tfor (function = 0x40000000; function < 0x40010000; function += 0x100)\n\nstatic inline uint32_t hypervisor_cpuid_base(const char *sig, uint32_t leaves)\n{\n\tuint32_t base, eax, signature[3];\n\n\tfor_each_possible_hypervisor_cpuid_base(base) {\n\t\tcpuid(base, &eax, &signature[0], &signature[1], &signature[2]);\n\n\t\tif (!memcmp(sig, signature, 12) &&\n\t\t    (leaves == 0 || ((eax - base) >= leaves)))\n\t\t\treturn base;\n\t}\n\n\treturn 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}