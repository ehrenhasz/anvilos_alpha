{
  "module_name": "local.h",
  "hash_id": "7dab9e4c5fa0f3ec06bbabda249f2be8fddcc3dcd9803163d9daaf2f3ff1e9f8",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/local.h",
  "human_readable_source": " \n#ifndef _ASM_X86_LOCAL_H\n#define _ASM_X86_LOCAL_H\n\n#include <linux/percpu.h>\n\n#include <linux/atomic.h>\n#include <asm/asm.h>\n\ntypedef struct {\n\tatomic_long_t a;\n} local_t;\n\n#define LOCAL_INIT(i)\t{ ATOMIC_LONG_INIT(i) }\n\n#define local_read(l)\tatomic_long_read(&(l)->a)\n#define local_set(l, i)\tatomic_long_set(&(l)->a, (i))\n\nstatic inline void local_inc(local_t *l)\n{\n\tasm volatile(_ASM_INC \"%0\"\n\t\t     : \"+m\" (l->a.counter));\n}\n\nstatic inline void local_dec(local_t *l)\n{\n\tasm volatile(_ASM_DEC \"%0\"\n\t\t     : \"+m\" (l->a.counter));\n}\n\nstatic inline void local_add(long i, local_t *l)\n{\n\tasm volatile(_ASM_ADD \"%1,%0\"\n\t\t     : \"+m\" (l->a.counter)\n\t\t     : \"ir\" (i));\n}\n\nstatic inline void local_sub(long i, local_t *l)\n{\n\tasm volatile(_ASM_SUB \"%1,%0\"\n\t\t     : \"+m\" (l->a.counter)\n\t\t     : \"ir\" (i));\n}\n\n \nstatic inline bool local_sub_and_test(long i, local_t *l)\n{\n\treturn GEN_BINARY_RMWcc(_ASM_SUB, l->a.counter, e, \"er\", i);\n}\n\n \nstatic inline bool local_dec_and_test(local_t *l)\n{\n\treturn GEN_UNARY_RMWcc(_ASM_DEC, l->a.counter, e);\n}\n\n \nstatic inline bool local_inc_and_test(local_t *l)\n{\n\treturn GEN_UNARY_RMWcc(_ASM_INC, l->a.counter, e);\n}\n\n \nstatic inline bool local_add_negative(long i, local_t *l)\n{\n\treturn GEN_BINARY_RMWcc(_ASM_ADD, l->a.counter, s, \"er\", i);\n}\n\n \nstatic inline long local_add_return(long i, local_t *l)\n{\n\tlong __i = i;\n\tasm volatile(_ASM_XADD \"%0, %1;\"\n\t\t     : \"+r\" (i), \"+m\" (l->a.counter)\n\t\t     : : \"memory\");\n\treturn i + __i;\n}\n\nstatic inline long local_sub_return(long i, local_t *l)\n{\n\treturn local_add_return(-i, l);\n}\n\n#define local_inc_return(l)  (local_add_return(1, l))\n#define local_dec_return(l)  (local_sub_return(1, l))\n\nstatic inline long local_cmpxchg(local_t *l, long old, long new)\n{\n\treturn cmpxchg_local(&l->a.counter, old, new);\n}\n\nstatic inline bool local_try_cmpxchg(local_t *l, long *old, long new)\n{\n\treturn try_cmpxchg_local(&l->a.counter,\n\t\t\t\t (typeof(l->a.counter) *) old, new);\n}\n\n \n#define local_xchg(l, n) (xchg(&((l)->a.counter), (n)))\n\n \n#define local_add_unless(l, a, u)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tlong c, old;\t\t\t\t\t\t\\\n\tc = local_read((l));\t\t\t\t\t\\\n\tfor (;;) {\t\t\t\t\t\t\\\n\t\tif (unlikely(c == (u)))\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\\\n\t\told = local_cmpxchg((l), c, c + (a));\t\t\\\n\t\tif (likely(old == c))\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\\\n\t\tc = old;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tc != (u);\t\t\t\t\t\t\\\n})\n#define local_inc_not_zero(l) local_add_unless((l), 1, 0)\n\n \n#define __local_inc(l)\t\tlocal_inc(l)\n#define __local_dec(l)\t\tlocal_dec(l)\n#define __local_add(i, l)\tlocal_add((i), (l))\n#define __local_sub(i, l)\tlocal_sub((i), (l))\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}