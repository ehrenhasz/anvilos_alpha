{
  "module_name": "kexec.h",
  "hash_id": "05242e46c81f8c962f9293aee7bddf5bce78374a16503e11fd1e933d999a6f87",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/kexec.h",
  "human_readable_source": " \n#ifndef _ASM_X86_KEXEC_H\n#define _ASM_X86_KEXEC_H\n\n#ifdef CONFIG_X86_32\n# define PA_CONTROL_PAGE\t0\n# define VA_CONTROL_PAGE\t1\n# define PA_PGD\t\t\t2\n# define PA_SWAP_PAGE\t\t3\n# define PAGES_NR\t\t4\n#else\n# define PA_CONTROL_PAGE\t0\n# define VA_CONTROL_PAGE\t1\n# define PA_TABLE_PAGE\t\t2\n# define PA_SWAP_PAGE\t\t3\n# define PAGES_NR\t\t4\n#endif\n\n# define KEXEC_CONTROL_CODE_MAX_SIZE\t2048\n\n#ifndef __ASSEMBLY__\n\n#include <linux/string.h>\n#include <linux/kernel.h>\n\n#include <asm/page.h>\n#include <asm/ptrace.h>\n#include <asm/bootparam.h>\n\nstruct kimage;\n\n \n#ifdef CONFIG_X86_32\n \n# define KEXEC_SOURCE_MEMORY_LIMIT (-1UL)\n \n# define KEXEC_DESTINATION_MEMORY_LIMIT (-1UL)\n \n# define KEXEC_CONTROL_MEMORY_LIMIT TASK_SIZE\n\n# define KEXEC_CONTROL_PAGE_SIZE\t4096\n\n \n# define KEXEC_ARCH KEXEC_ARCH_386\n\n \n# define vmcore_elf_check_arch_cross(x) ((x)->e_machine == EM_X86_64)\n#else\n \n# define KEXEC_SOURCE_MEMORY_LIMIT      (MAXMEM-1)\n \n# define KEXEC_DESTINATION_MEMORY_LIMIT (MAXMEM-1)\n \n# define KEXEC_CONTROL_MEMORY_LIMIT     (MAXMEM-1)\n\n \n# define KEXEC_CONTROL_PAGE_SIZE  (4096UL + 4096UL)\n\n \n# define KEXEC_ARCH KEXEC_ARCH_X86_64\n#endif\n\n \nstatic inline void crash_setup_regs(struct pt_regs *newregs,\n\t\t\t\t    struct pt_regs *oldregs)\n{\n\tif (oldregs) {\n\t\tmemcpy(newregs, oldregs, sizeof(*newregs));\n\t} else {\n#ifdef CONFIG_X86_32\n\t\tasm volatile(\"movl %%ebx,%0\" : \"=m\"(newregs->bx));\n\t\tasm volatile(\"movl %%ecx,%0\" : \"=m\"(newregs->cx));\n\t\tasm volatile(\"movl %%edx,%0\" : \"=m\"(newregs->dx));\n\t\tasm volatile(\"movl %%esi,%0\" : \"=m\"(newregs->si));\n\t\tasm volatile(\"movl %%edi,%0\" : \"=m\"(newregs->di));\n\t\tasm volatile(\"movl %%ebp,%0\" : \"=m\"(newregs->bp));\n\t\tasm volatile(\"movl %%eax,%0\" : \"=m\"(newregs->ax));\n\t\tasm volatile(\"movl %%esp,%0\" : \"=m\"(newregs->sp));\n\t\tasm volatile(\"movl %%ss, %%eax;\" :\"=a\"(newregs->ss));\n\t\tasm volatile(\"movl %%cs, %%eax;\" :\"=a\"(newregs->cs));\n\t\tasm volatile(\"movl %%ds, %%eax;\" :\"=a\"(newregs->ds));\n\t\tasm volatile(\"movl %%es, %%eax;\" :\"=a\"(newregs->es));\n\t\tasm volatile(\"pushfl; popl %0\" :\"=m\"(newregs->flags));\n#else\n\t\tasm volatile(\"movq %%rbx,%0\" : \"=m\"(newregs->bx));\n\t\tasm volatile(\"movq %%rcx,%0\" : \"=m\"(newregs->cx));\n\t\tasm volatile(\"movq %%rdx,%0\" : \"=m\"(newregs->dx));\n\t\tasm volatile(\"movq %%rsi,%0\" : \"=m\"(newregs->si));\n\t\tasm volatile(\"movq %%rdi,%0\" : \"=m\"(newregs->di));\n\t\tasm volatile(\"movq %%rbp,%0\" : \"=m\"(newregs->bp));\n\t\tasm volatile(\"movq %%rax,%0\" : \"=m\"(newregs->ax));\n\t\tasm volatile(\"movq %%rsp,%0\" : \"=m\"(newregs->sp));\n\t\tasm volatile(\"movq %%r8,%0\" : \"=m\"(newregs->r8));\n\t\tasm volatile(\"movq %%r9,%0\" : \"=m\"(newregs->r9));\n\t\tasm volatile(\"movq %%r10,%0\" : \"=m\"(newregs->r10));\n\t\tasm volatile(\"movq %%r11,%0\" : \"=m\"(newregs->r11));\n\t\tasm volatile(\"movq %%r12,%0\" : \"=m\"(newregs->r12));\n\t\tasm volatile(\"movq %%r13,%0\" : \"=m\"(newregs->r13));\n\t\tasm volatile(\"movq %%r14,%0\" : \"=m\"(newregs->r14));\n\t\tasm volatile(\"movq %%r15,%0\" : \"=m\"(newregs->r15));\n\t\tasm volatile(\"movl %%ss, %%eax;\" :\"=a\"(newregs->ss));\n\t\tasm volatile(\"movl %%cs, %%eax;\" :\"=a\"(newregs->cs));\n\t\tasm volatile(\"pushfq; popq %0\" :\"=m\"(newregs->flags));\n#endif\n\t\tnewregs->ip = _THIS_IP_;\n\t}\n}\n\n#ifdef CONFIG_X86_32\nasmlinkage unsigned long\nrelocate_kernel(unsigned long indirection_page,\n\t\tunsigned long control_page,\n\t\tunsigned long start_address,\n\t\tunsigned int has_pae,\n\t\tunsigned int preserve_context);\n#else\nunsigned long\nrelocate_kernel(unsigned long indirection_page,\n\t\tunsigned long page_list,\n\t\tunsigned long start_address,\n\t\tunsigned int preserve_context,\n\t\tunsigned int host_mem_enc_active);\n#endif\n\n#define ARCH_HAS_KIMAGE_ARCH\n\n#ifdef CONFIG_X86_32\nstruct kimage_arch {\n\tpgd_t *pgd;\n#ifdef CONFIG_X86_PAE\n\tpmd_t *pmd0;\n\tpmd_t *pmd1;\n#endif\n\tpte_t *pte0;\n\tpte_t *pte1;\n};\n#else\nstruct kimage_arch {\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n};\n#endif  \n\n#ifdef CONFIG_X86_64\n \nstruct kexec_entry64_regs {\n\tuint64_t rax;\n\tuint64_t rcx;\n\tuint64_t rdx;\n\tuint64_t rbx;\n\tuint64_t rsp;\n\tuint64_t rbp;\n\tuint64_t rsi;\n\tuint64_t rdi;\n\tuint64_t r8;\n\tuint64_t r9;\n\tuint64_t r10;\n\tuint64_t r11;\n\tuint64_t r12;\n\tuint64_t r13;\n\tuint64_t r14;\n\tuint64_t r15;\n\tuint64_t rip;\n};\n\nextern int arch_kexec_post_alloc_pages(void *vaddr, unsigned int pages,\n\t\t\t\t       gfp_t gfp);\n#define arch_kexec_post_alloc_pages arch_kexec_post_alloc_pages\n\nextern void arch_kexec_pre_free_pages(void *vaddr, unsigned int pages);\n#define arch_kexec_pre_free_pages arch_kexec_pre_free_pages\n\nvoid arch_kexec_protect_crashkres(void);\n#define arch_kexec_protect_crashkres arch_kexec_protect_crashkres\n\nvoid arch_kexec_unprotect_crashkres(void);\n#define arch_kexec_unprotect_crashkres arch_kexec_unprotect_crashkres\n\n#ifdef CONFIG_KEXEC_FILE\nstruct purgatory_info;\nint arch_kexec_apply_relocations_add(struct purgatory_info *pi,\n\t\t\t\t     Elf_Shdr *section,\n\t\t\t\t     const Elf_Shdr *relsec,\n\t\t\t\t     const Elf_Shdr *symtab);\n#define arch_kexec_apply_relocations_add arch_kexec_apply_relocations_add\n\nint arch_kimage_file_post_load_cleanup(struct kimage *image);\n#define arch_kimage_file_post_load_cleanup arch_kimage_file_post_load_cleanup\n#endif\n#endif\n\nextern void kdump_nmi_shootdown_cpus(void);\n\n#ifdef CONFIG_CRASH_HOTPLUG\nvoid arch_crash_handle_hotplug_event(struct kimage *image);\n#define arch_crash_handle_hotplug_event arch_crash_handle_hotplug_event\n\n#ifdef CONFIG_HOTPLUG_CPU\nint arch_crash_hotplug_cpu_support(void);\n#define crash_hotplug_cpu_support arch_crash_hotplug_cpu_support\n#endif\n\n#ifdef CONFIG_MEMORY_HOTPLUG\nint arch_crash_hotplug_memory_support(void);\n#define crash_hotplug_memory_support arch_crash_hotplug_memory_support\n#endif\n\nunsigned int arch_crash_get_elfcorehdr_size(void);\n#define crash_get_elfcorehdr_size arch_crash_get_elfcorehdr_size\n#endif\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}