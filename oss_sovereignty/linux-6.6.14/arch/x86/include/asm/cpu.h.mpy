{
  "module_name": "cpu.h",
  "hash_id": "da20f4c8e5bdd818159461281cecd640b9f4f10d949165f6402dd2b0ba808642",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/cpu.h",
  "human_readable_source": " \n#ifndef _ASM_X86_CPU_H\n#define _ASM_X86_CPU_H\n\n#include <linux/device.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/nodemask.h>\n#include <linux/percpu.h>\n#include <asm/ibt.h>\n\n#ifdef CONFIG_SMP\n\nextern void prefill_possible_map(void);\n\n#else  \n\nstatic inline void prefill_possible_map(void) {}\n\n#define cpu_physical_id(cpu)\t\t\tboot_cpu_physical_apicid\n#define cpu_acpi_id(cpu)\t\t\t0\n#define safe_smp_processor_id()\t\t\t0\n\n#endif  \n\nstruct x86_cpu {\n\tstruct cpu cpu;\n};\n\n#ifdef CONFIG_HOTPLUG_CPU\nextern void soft_restart_cpu(void);\n#endif\n\nextern void ap_init_aperfmperf(void);\n\nint mwait_usable(const struct cpuinfo_x86 *);\n\nunsigned int x86_family(unsigned int sig);\nunsigned int x86_model(unsigned int sig);\nunsigned int x86_stepping(unsigned int sig);\n#ifdef CONFIG_CPU_SUP_INTEL\nextern void __init sld_setup(struct cpuinfo_x86 *c);\nextern bool handle_user_split_lock(struct pt_regs *regs, long error_code);\nextern bool handle_guest_split_lock(unsigned long ip);\nextern void handle_bus_lock(struct pt_regs *regs);\nu8 get_this_hybrid_cpu_type(void);\n#else\nstatic inline void __init sld_setup(struct cpuinfo_x86 *c) {}\nstatic inline bool handle_user_split_lock(struct pt_regs *regs, long error_code)\n{\n\treturn false;\n}\n\nstatic inline bool handle_guest_split_lock(unsigned long ip)\n{\n\treturn false;\n}\n\nstatic inline void handle_bus_lock(struct pt_regs *regs) {}\n\nstatic inline u8 get_this_hybrid_cpu_type(void)\n{\n\treturn 0;\n}\n#endif\n#ifdef CONFIG_IA32_FEAT_CTL\nvoid init_ia32_feat_ctl(struct cpuinfo_x86 *c);\n#else\nstatic inline void init_ia32_feat_ctl(struct cpuinfo_x86 *c) {}\n#endif\n\nextern __noendbr void cet_disable(void);\n\nstruct ucode_cpu_info;\n\nint intel_cpu_collect_info(struct ucode_cpu_info *uci);\n\nstatic inline bool intel_cpu_signatures_match(unsigned int s1, unsigned int p1,\n\t\t\t\t\t      unsigned int s2, unsigned int p2)\n{\n\tif (s1 != s2)\n\t\treturn false;\n\n\t \n\tif (!p1 && !p2)\n\t\treturn true;\n\n\t \n\treturn p1 & p2;\n}\n\nextern u64 x86_read_arch_cap_msr(void);\nint intel_find_matching_signature(void *mc, unsigned int csig, int cpf);\nint intel_microcode_sanity_check(void *mc, bool print_err, int hdr_type);\n\nextern struct cpumask cpus_stop_mask;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}