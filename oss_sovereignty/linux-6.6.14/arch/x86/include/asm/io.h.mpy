{
  "module_name": "io.h",
  "hash_id": "7c71a4c41328ebfaff21738d2d6e5b6e8bb63e456d9afa3570ade0b8fda79fc7",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/io.h",
  "human_readable_source": " \n#ifndef _ASM_X86_IO_H\n#define _ASM_X86_IO_H\n\n \n\n \n\n  \n\n#include <linux/string.h>\n#include <linux/compiler.h>\n#include <linux/cc_platform.h>\n#include <asm/page.h>\n#include <asm/early_ioremap.h>\n#include <asm/pgtable_types.h>\n#include <asm/shared/io.h>\n\n#define build_mmio_read(name, size, type, reg, barrier) \\\nstatic inline type name(const volatile void __iomem *addr) \\\n{ type ret; asm volatile(\"mov\" size \" %1,%0\":reg (ret) \\\n:\"m\" (*(volatile type __force *)addr) barrier); return ret; }\n\n#define build_mmio_write(name, size, type, reg, barrier) \\\nstatic inline void name(type val, volatile void __iomem *addr) \\\n{ asm volatile(\"mov\" size \" %0,%1\": :reg (val), \\\n\"m\" (*(volatile type __force *)addr) barrier); }\n\nbuild_mmio_read(readb, \"b\", unsigned char, \"=q\", :\"memory\")\nbuild_mmio_read(readw, \"w\", unsigned short, \"=r\", :\"memory\")\nbuild_mmio_read(readl, \"l\", unsigned int, \"=r\", :\"memory\")\n\nbuild_mmio_read(__readb, \"b\", unsigned char, \"=q\", )\nbuild_mmio_read(__readw, \"w\", unsigned short, \"=r\", )\nbuild_mmio_read(__readl, \"l\", unsigned int, \"=r\", )\n\nbuild_mmio_write(writeb, \"b\", unsigned char, \"q\", :\"memory\")\nbuild_mmio_write(writew, \"w\", unsigned short, \"r\", :\"memory\")\nbuild_mmio_write(writel, \"l\", unsigned int, \"r\", :\"memory\")\n\nbuild_mmio_write(__writeb, \"b\", unsigned char, \"q\", )\nbuild_mmio_write(__writew, \"w\", unsigned short, \"r\", )\nbuild_mmio_write(__writel, \"l\", unsigned int, \"r\", )\n\n#define readb readb\n#define readw readw\n#define readl readl\n#define readb_relaxed(a) __readb(a)\n#define readw_relaxed(a) __readw(a)\n#define readl_relaxed(a) __readl(a)\n#define __raw_readb __readb\n#define __raw_readw __readw\n#define __raw_readl __readl\n\n#define writeb writeb\n#define writew writew\n#define writel writel\n#define writeb_relaxed(v, a) __writeb(v, a)\n#define writew_relaxed(v, a) __writew(v, a)\n#define writel_relaxed(v, a) __writel(v, a)\n#define __raw_writeb __writeb\n#define __raw_writew __writew\n#define __raw_writel __writel\n\n#ifdef CONFIG_X86_64\n\nbuild_mmio_read(readq, \"q\", u64, \"=r\", :\"memory\")\nbuild_mmio_read(__readq, \"q\", u64, \"=r\", )\nbuild_mmio_write(writeq, \"q\", u64, \"r\", :\"memory\")\nbuild_mmio_write(__writeq, \"q\", u64, \"r\", )\n\n#define readq_relaxed(a)\t__readq(a)\n#define writeq_relaxed(v, a)\t__writeq(v, a)\n\n#define __raw_readq\t\t__readq\n#define __raw_writeq\t\t__writeq\n\n \n#define readq\t\t\treadq\n#define writeq\t\t\twriteq\n\n#endif\n\n#define ARCH_HAS_VALID_PHYS_ADDR_RANGE\nextern int valid_phys_addr_range(phys_addr_t addr, size_t size);\nextern int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);\n\n \n\nstatic inline phys_addr_t virt_to_phys(volatile void *address)\n{\n\treturn __pa(address);\n}\n#define virt_to_phys virt_to_phys\n\n \n\nstatic inline void *phys_to_virt(phys_addr_t address)\n{\n\treturn __va(address);\n}\n#define phys_to_virt phys_to_virt\n\n \n#define page_to_phys(page)    ((dma_addr_t)page_to_pfn(page) << PAGE_SHIFT)\n\n \nstatic inline unsigned int isa_virt_to_bus(volatile void *address)\n{\n\treturn (unsigned int)virt_to_phys(address);\n}\n#define isa_bus_to_virt\t\tphys_to_virt\n\n \nextern void __iomem *ioremap_uc(resource_size_t offset, unsigned long size);\n#define ioremap_uc ioremap_uc\nextern void __iomem *ioremap_cache(resource_size_t offset, unsigned long size);\n#define ioremap_cache ioremap_cache\nextern void __iomem *ioremap_prot(resource_size_t offset, unsigned long size, unsigned long prot_val);\n#define ioremap_prot ioremap_prot\nextern void __iomem *ioremap_encrypted(resource_size_t phys_addr, unsigned long size);\n#define ioremap_encrypted ioremap_encrypted\n\n \nvoid __iomem *ioremap(resource_size_t offset, unsigned long size);\n#define ioremap ioremap\n\nextern void iounmap(volatile void __iomem *addr);\n#define iounmap iounmap\n\n#ifdef __KERNEL__\n\nvoid memcpy_fromio(void *, const volatile void __iomem *, size_t);\nvoid memcpy_toio(volatile void __iomem *, const void *, size_t);\nvoid memset_io(volatile void __iomem *, int, size_t);\n\n#define memcpy_fromio memcpy_fromio\n#define memcpy_toio memcpy_toio\n#define memset_io memset_io\n\n \n#define __ISA_IO_base ((char __iomem *)(PAGE_OFFSET))\n\n#endif  \n\nextern void native_io_delay(void);\n\nextern int io_delay_type;\nextern void io_delay_init(void);\n\n#if defined(CONFIG_PARAVIRT)\n#include <asm/paravirt.h>\n#else\n\nstatic inline void slow_down_io(void)\n{\n\tnative_io_delay();\n#ifdef REALLY_SLOW_IO\n\tnative_io_delay();\n\tnative_io_delay();\n\tnative_io_delay();\n#endif\n}\n\n#endif\n\n#define BUILDIO(bwl, bw, type)\t\t\t\t\t\t\\\nstatic inline void out##bwl##_p(type value, u16 port)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tout##bwl(value, port);\t\t\t\t\t\t\\\n\tslow_down_io();\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic inline type in##bwl##_p(u16 port)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype value = in##bwl(port);\t\t\t\t\t\\\n\tslow_down_io();\t\t\t\t\t\t\t\\\n\treturn value;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic inline void outs##bwl(u16 port, const void *addr, unsigned long count) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (cc_platform_has(CC_ATTR_GUEST_UNROLL_STRING_IO)) {\t\t\\\n\t\ttype *value = (type *)addr;\t\t\t\t\\\n\t\twhile (count) {\t\t\t\t\t\t\\\n\t\t\tout##bwl(*value, port);\t\t\t\t\\\n\t\t\tvalue++;\t\t\t\t\t\\\n\t\t\tcount--;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tasm volatile(\"rep; outs\" #bwl\t\t\t\t\\\n\t\t\t     : \"+S\"(addr), \"+c\"(count)\t\t\t\\\n\t\t\t     : \"d\"(port) : \"memory\");\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic inline void ins##bwl(u16 port, void *addr, unsigned long count)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (cc_platform_has(CC_ATTR_GUEST_UNROLL_STRING_IO)) {\t\t\\\n\t\ttype *value = (type *)addr;\t\t\t\t\\\n\t\twhile (count) {\t\t\t\t\t\t\\\n\t\t\t*value = in##bwl(port);\t\t\t\t\\\n\t\t\tvalue++;\t\t\t\t\t\\\n\t\t\tcount--;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tasm volatile(\"rep; ins\" #bwl\t\t\t\t\\\n\t\t\t     : \"+D\"(addr), \"+c\"(count)\t\t\t\\\n\t\t\t     : \"d\"(port) : \"memory\");\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\nBUILDIO(b, b, u8)\nBUILDIO(w, w, u16)\nBUILDIO(l,  , u32)\n#undef BUILDIO\n\n#define inb_p inb_p\n#define inw_p inw_p\n#define inl_p inl_p\n#define insb insb\n#define insw insw\n#define insl insl\n\n#define outb_p outb_p\n#define outw_p outw_p\n#define outl_p outl_p\n#define outsb outsb\n#define outsw outsw\n#define outsl outsl\n\nextern void *xlate_dev_mem_ptr(phys_addr_t phys);\nextern void unxlate_dev_mem_ptr(phys_addr_t phys, void *addr);\n\n#define xlate_dev_mem_ptr xlate_dev_mem_ptr\n#define unxlate_dev_mem_ptr unxlate_dev_mem_ptr\n\nextern int ioremap_change_attr(unsigned long vaddr, unsigned long size,\n\t\t\t\tenum page_cache_mode pcm);\nextern void __iomem *ioremap_wc(resource_size_t offset, unsigned long size);\n#define ioremap_wc ioremap_wc\nextern void __iomem *ioremap_wt(resource_size_t offset, unsigned long size);\n#define ioremap_wt ioremap_wt\n\nextern bool is_early_ioremap_ptep(pte_t *ptep);\n\n#define IO_SPACE_LIMIT 0xffff\n\n#include <asm-generic/io.h>\n#undef PCI_IOBASE\n\n#ifdef CONFIG_MTRR\nextern int __must_check arch_phys_wc_index(int handle);\n#define arch_phys_wc_index arch_phys_wc_index\n\nextern int __must_check arch_phys_wc_add(unsigned long base,\n\t\t\t\t\t unsigned long size);\nextern void arch_phys_wc_del(int handle);\n#define arch_phys_wc_add arch_phys_wc_add\n#endif\n\n#ifdef CONFIG_X86_PAT\nextern int arch_io_reserve_memtype_wc(resource_size_t start, resource_size_t size);\nextern void arch_io_free_memtype_wc(resource_size_t start, resource_size_t size);\n#define arch_io_reserve_memtype_wc arch_io_reserve_memtype_wc\n#endif\n\n#ifdef CONFIG_AMD_MEM_ENCRYPT\nextern bool arch_memremap_can_ram_remap(resource_size_t offset,\n\t\t\t\t\tunsigned long size,\n\t\t\t\t\tunsigned long flags);\n#define arch_memremap_can_ram_remap arch_memremap_can_ram_remap\n\nextern bool phys_mem_access_encrypted(unsigned long phys_addr,\n\t\t\t\t      unsigned long size);\n#else\nstatic inline bool phys_mem_access_encrypted(unsigned long phys_addr,\n\t\t\t\t\t     unsigned long size)\n{\n\treturn true;\n}\n#endif\n\n \nstatic inline void iosubmit_cmds512(void __iomem *dst, const void *src,\n\t\t\t\t    size_t count)\n{\n\tconst u8 *from = src;\n\tconst u8 *end = from + count * 64;\n\n\twhile (from < end) {\n\t\tmovdir64b(dst, from);\n\t\tfrom += 64;\n\t}\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}