{
  "module_name": "msr.h",
  "hash_id": "e7bda68d98cd74a62398e150bb71041df4f7612c6cac5e34fdc200550ae9ada2",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/msr.h",
  "human_readable_source": " \n#ifndef _ASM_X86_MSR_H\n#define _ASM_X86_MSR_H\n\n#include \"msr-index.h\"\n\n#ifndef __ASSEMBLY__\n\n#include <asm/asm.h>\n#include <asm/errno.h>\n#include <asm/cpumask.h>\n#include <uapi/asm/msr.h>\n#include <asm/shared/msr.h>\n\nstruct msr_info {\n\tu32 msr_no;\n\tstruct msr reg;\n\tstruct msr *msrs;\n\tint err;\n};\n\nstruct msr_regs_info {\n\tu32 *regs;\n\tint err;\n};\n\nstruct saved_msr {\n\tbool valid;\n\tstruct msr_info info;\n};\n\nstruct saved_msrs {\n\tunsigned int num;\n\tstruct saved_msr *array;\n};\n\n \n#ifdef CONFIG_X86_64\n \n#define DECLARE_ARGS(val, low, high)\tunsigned long low, high\n#define EAX_EDX_VAL(val, low, high)\t((low) | (high) << 32)\n#define EAX_EDX_RET(val, low, high)\t\"=a\" (low), \"=d\" (high)\n#else\n#define DECLARE_ARGS(val, low, high)\tunsigned long long val\n#define EAX_EDX_VAL(val, low, high)\t(val)\n#define EAX_EDX_RET(val, low, high)\t\"=A\" (val)\n#endif\n\n \n#include <asm/atomic.h>\n#include <linux/tracepoint-defs.h>\n\n#ifdef CONFIG_TRACEPOINTS\nDECLARE_TRACEPOINT(read_msr);\nDECLARE_TRACEPOINT(write_msr);\nDECLARE_TRACEPOINT(rdpmc);\nextern void do_trace_write_msr(unsigned int msr, u64 val, int failed);\nextern void do_trace_read_msr(unsigned int msr, u64 val, int failed);\nextern void do_trace_rdpmc(unsigned int msr, u64 val, int failed);\n#else\nstatic inline void do_trace_write_msr(unsigned int msr, u64 val, int failed) {}\nstatic inline void do_trace_read_msr(unsigned int msr, u64 val, int failed) {}\nstatic inline void do_trace_rdpmc(unsigned int msr, u64 val, int failed) {}\n#endif\n\n \nstatic __always_inline unsigned long long __rdmsr(unsigned int msr)\n{\n\tDECLARE_ARGS(val, low, high);\n\n\tasm volatile(\"1: rdmsr\\n\"\n\t\t     \"2:\\n\"\n\t\t     _ASM_EXTABLE_TYPE(1b, 2b, EX_TYPE_RDMSR)\n\t\t     : EAX_EDX_RET(val, low, high) : \"c\" (msr));\n\n\treturn EAX_EDX_VAL(val, low, high);\n}\n\nstatic __always_inline void __wrmsr(unsigned int msr, u32 low, u32 high)\n{\n\tasm volatile(\"1: wrmsr\\n\"\n\t\t     \"2:\\n\"\n\t\t     _ASM_EXTABLE_TYPE(1b, 2b, EX_TYPE_WRMSR)\n\t\t     : : \"c\" (msr), \"a\"(low), \"d\" (high) : \"memory\");\n}\n\n#define native_rdmsr(msr, val1, val2)\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tu64 __val = __rdmsr((msr));\t\t\t\\\n\t(void)((val1) = (u32)__val);\t\t\t\\\n\t(void)((val2) = (u32)(__val >> 32));\t\t\\\n} while (0)\n\n#define native_wrmsr(msr, low, high)\t\t\t\\\n\t__wrmsr(msr, low, high)\n\n#define native_wrmsrl(msr, val)\t\t\t\t\\\n\t__wrmsr((msr), (u32)((u64)(val)),\t\t\\\n\t\t       (u32)((u64)(val) >> 32))\n\nstatic inline unsigned long long native_read_msr(unsigned int msr)\n{\n\tunsigned long long val;\n\n\tval = __rdmsr(msr);\n\n\tif (tracepoint_enabled(read_msr))\n\t\tdo_trace_read_msr(msr, val, 0);\n\n\treturn val;\n}\n\nstatic inline unsigned long long native_read_msr_safe(unsigned int msr,\n\t\t\t\t\t\t      int *err)\n{\n\tDECLARE_ARGS(val, low, high);\n\n\tasm volatile(\"1: rdmsr ; xor %[err],%[err]\\n\"\n\t\t     \"2:\\n\\t\"\n\t\t     _ASM_EXTABLE_TYPE_REG(1b, 2b, EX_TYPE_RDMSR_SAFE, %[err])\n\t\t     : [err] \"=r\" (*err), EAX_EDX_RET(val, low, high)\n\t\t     : \"c\" (msr));\n\tif (tracepoint_enabled(read_msr))\n\t\tdo_trace_read_msr(msr, EAX_EDX_VAL(val, low, high), *err);\n\treturn EAX_EDX_VAL(val, low, high);\n}\n\n \nstatic inline void notrace\nnative_write_msr(unsigned int msr, u32 low, u32 high)\n{\n\t__wrmsr(msr, low, high);\n\n\tif (tracepoint_enabled(write_msr))\n\t\tdo_trace_write_msr(msr, ((u64)high << 32 | low), 0);\n}\n\n \nstatic inline int notrace\nnative_write_msr_safe(unsigned int msr, u32 low, u32 high)\n{\n\tint err;\n\n\tasm volatile(\"1: wrmsr ; xor %[err],%[err]\\n\"\n\t\t     \"2:\\n\\t\"\n\t\t     _ASM_EXTABLE_TYPE_REG(1b, 2b, EX_TYPE_WRMSR_SAFE, %[err])\n\t\t     : [err] \"=a\" (err)\n\t\t     : \"c\" (msr), \"0\" (low), \"d\" (high)\n\t\t     : \"memory\");\n\tif (tracepoint_enabled(write_msr))\n\t\tdo_trace_write_msr(msr, ((u64)high << 32 | low), err);\n\treturn err;\n}\n\nextern int rdmsr_safe_regs(u32 regs[8]);\nextern int wrmsr_safe_regs(u32 regs[8]);\n\n \nstatic __always_inline unsigned long long rdtsc(void)\n{\n\tDECLARE_ARGS(val, low, high);\n\n\tasm volatile(\"rdtsc\" : EAX_EDX_RET(val, low, high));\n\n\treturn EAX_EDX_VAL(val, low, high);\n}\n\n \nstatic __always_inline unsigned long long rdtsc_ordered(void)\n{\n\tDECLARE_ARGS(val, low, high);\n\n\t \n\tasm volatile(ALTERNATIVE_2(\"rdtsc\",\n\t\t\t\t   \"lfence; rdtsc\", X86_FEATURE_LFENCE_RDTSC,\n\t\t\t\t   \"rdtscp\", X86_FEATURE_RDTSCP)\n\t\t\t: EAX_EDX_RET(val, low, high)\n\t\t\t \n\t\t\t:: \"ecx\");\n\n\treturn EAX_EDX_VAL(val, low, high);\n}\n\nstatic inline unsigned long long native_read_pmc(int counter)\n{\n\tDECLARE_ARGS(val, low, high);\n\n\tasm volatile(\"rdpmc\" : EAX_EDX_RET(val, low, high) : \"c\" (counter));\n\tif (tracepoint_enabled(rdpmc))\n\t\tdo_trace_rdpmc(counter, EAX_EDX_VAL(val, low, high), 0);\n\treturn EAX_EDX_VAL(val, low, high);\n}\n\n#ifdef CONFIG_PARAVIRT_XXL\n#include <asm/paravirt.h>\n#else\n#include <linux/errno.h>\n \n\n#define rdmsr(msr, low, high)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tu64 __val = native_read_msr((msr));\t\t\t\\\n\t(void)((low) = (u32)__val);\t\t\t\t\\\n\t(void)((high) = (u32)(__val >> 32));\t\t\t\\\n} while (0)\n\nstatic inline void wrmsr(unsigned int msr, u32 low, u32 high)\n{\n\tnative_write_msr(msr, low, high);\n}\n\n#define rdmsrl(msr, val)\t\t\t\\\n\t((val) = native_read_msr((msr)))\n\nstatic inline void wrmsrl(unsigned int msr, u64 val)\n{\n\tnative_write_msr(msr, (u32)(val & 0xffffffffULL), (u32)(val >> 32));\n}\n\n \nstatic inline int wrmsr_safe(unsigned int msr, u32 low, u32 high)\n{\n\treturn native_write_msr_safe(msr, low, high);\n}\n\n \n#define rdmsr_safe(msr, low, high)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tint __err;\t\t\t\t\t\t\\\n\tu64 __val = native_read_msr_safe((msr), &__err);\t\\\n\t(*low) = (u32)__val;\t\t\t\t\t\\\n\t(*high) = (u32)(__val >> 32);\t\t\t\t\\\n\t__err;\t\t\t\t\t\t\t\\\n})\n\nstatic inline int rdmsrl_safe(unsigned int msr, unsigned long long *p)\n{\n\tint err;\n\n\t*p = native_read_msr_safe(msr, &err);\n\treturn err;\n}\n\n#define rdpmc(counter, low, high)\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tu64 _l = native_read_pmc((counter));\t\t\\\n\t(low)  = (u32)_l;\t\t\t\t\\\n\t(high) = (u32)(_l >> 32);\t\t\t\\\n} while (0)\n\n#define rdpmcl(counter, val) ((val) = native_read_pmc(counter))\n\n#endif\t \n\n \nstatic inline int wrmsrl_safe(u32 msr, u64 val)\n{\n\treturn wrmsr_safe(msr, (u32)val,  (u32)(val >> 32));\n}\n\nstruct msr *msrs_alloc(void);\nvoid msrs_free(struct msr *msrs);\nint msr_set_bit(u32 msr, u8 bit);\nint msr_clear_bit(u32 msr, u8 bit);\n\n#ifdef CONFIG_SMP\nint rdmsr_on_cpu(unsigned int cpu, u32 msr_no, u32 *l, u32 *h);\nint wrmsr_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h);\nint rdmsrl_on_cpu(unsigned int cpu, u32 msr_no, u64 *q);\nint wrmsrl_on_cpu(unsigned int cpu, u32 msr_no, u64 q);\nvoid rdmsr_on_cpus(const struct cpumask *mask, u32 msr_no, struct msr *msrs);\nvoid wrmsr_on_cpus(const struct cpumask *mask, u32 msr_no, struct msr *msrs);\nint rdmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 *l, u32 *h);\nint wrmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h);\nint rdmsrl_safe_on_cpu(unsigned int cpu, u32 msr_no, u64 *q);\nint wrmsrl_safe_on_cpu(unsigned int cpu, u32 msr_no, u64 q);\nint rdmsr_safe_regs_on_cpu(unsigned int cpu, u32 regs[8]);\nint wrmsr_safe_regs_on_cpu(unsigned int cpu, u32 regs[8]);\n#else   \nstatic inline int rdmsr_on_cpu(unsigned int cpu, u32 msr_no, u32 *l, u32 *h)\n{\n\trdmsr(msr_no, *l, *h);\n\treturn 0;\n}\nstatic inline int wrmsr_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h)\n{\n\twrmsr(msr_no, l, h);\n\treturn 0;\n}\nstatic inline int rdmsrl_on_cpu(unsigned int cpu, u32 msr_no, u64 *q)\n{\n\trdmsrl(msr_no, *q);\n\treturn 0;\n}\nstatic inline int wrmsrl_on_cpu(unsigned int cpu, u32 msr_no, u64 q)\n{\n\twrmsrl(msr_no, q);\n\treturn 0;\n}\nstatic inline void rdmsr_on_cpus(const struct cpumask *m, u32 msr_no,\n\t\t\t\tstruct msr *msrs)\n{\n\trdmsr_on_cpu(0, msr_no, &(msrs[0].l), &(msrs[0].h));\n}\nstatic inline void wrmsr_on_cpus(const struct cpumask *m, u32 msr_no,\n\t\t\t\tstruct msr *msrs)\n{\n\twrmsr_on_cpu(0, msr_no, msrs[0].l, msrs[0].h);\n}\nstatic inline int rdmsr_safe_on_cpu(unsigned int cpu, u32 msr_no,\n\t\t\t\t    u32 *l, u32 *h)\n{\n\treturn rdmsr_safe(msr_no, l, h);\n}\nstatic inline int wrmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h)\n{\n\treturn wrmsr_safe(msr_no, l, h);\n}\nstatic inline int rdmsrl_safe_on_cpu(unsigned int cpu, u32 msr_no, u64 *q)\n{\n\treturn rdmsrl_safe(msr_no, q);\n}\nstatic inline int wrmsrl_safe_on_cpu(unsigned int cpu, u32 msr_no, u64 q)\n{\n\treturn wrmsrl_safe(msr_no, q);\n}\nstatic inline int rdmsr_safe_regs_on_cpu(unsigned int cpu, u32 regs[8])\n{\n\treturn rdmsr_safe_regs(regs);\n}\nstatic inline int wrmsr_safe_regs_on_cpu(unsigned int cpu, u32 regs[8])\n{\n\treturn wrmsr_safe_regs(regs);\n}\n#endif   \n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}