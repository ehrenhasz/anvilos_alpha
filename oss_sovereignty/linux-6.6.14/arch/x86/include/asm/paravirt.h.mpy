{
  "module_name": "paravirt.h",
  "hash_id": "c98709d6a77cbbaccc979becafcbd020aff3914a8f86be010c0cce32b9dc6924",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/paravirt.h",
  "human_readable_source": " \n#ifndef _ASM_X86_PARAVIRT_H\n#define _ASM_X86_PARAVIRT_H\n \n\n#include <asm/paravirt_types.h>\n\n#ifdef CONFIG_PARAVIRT\n#include <asm/pgtable_types.h>\n#include <asm/asm.h>\n#include <asm/nospec-branch.h>\n\n#ifndef __ASSEMBLY__\n#include <linux/bug.h>\n#include <linux/types.h>\n#include <linux/cpumask.h>\n#include <linux/static_call_types.h>\n#include <asm/frame.h>\n\nu64 dummy_steal_clock(int cpu);\nu64 dummy_sched_clock(void);\n\nDECLARE_STATIC_CALL(pv_steal_clock, dummy_steal_clock);\nDECLARE_STATIC_CALL(pv_sched_clock, dummy_sched_clock);\n\nvoid paravirt_set_sched_clock(u64 (*func)(void));\n\nstatic __always_inline u64 paravirt_sched_clock(void)\n{\n\treturn static_call(pv_sched_clock)();\n}\n\nstruct static_key;\nextern struct static_key paravirt_steal_enabled;\nextern struct static_key paravirt_steal_rq_enabled;\n\n__visible void __native_queued_spin_unlock(struct qspinlock *lock);\nbool pv_is_native_spin_unlock(void);\n__visible bool __native_vcpu_is_preempted(long cpu);\nbool pv_is_native_vcpu_is_preempted(void);\n\nstatic inline u64 paravirt_steal_clock(int cpu)\n{\n\treturn static_call(pv_steal_clock)(cpu);\n}\n\n#ifdef CONFIG_PARAVIRT_SPINLOCKS\nvoid __init paravirt_set_cap(void);\n#endif\n\n \nstatic inline void slow_down_io(void)\n{\n\tPVOP_VCALL0(cpu.io_delay);\n#ifdef REALLY_SLOW_IO\n\tPVOP_VCALL0(cpu.io_delay);\n\tPVOP_VCALL0(cpu.io_delay);\n\tPVOP_VCALL0(cpu.io_delay);\n#endif\n}\n\nvoid native_flush_tlb_local(void);\nvoid native_flush_tlb_global(void);\nvoid native_flush_tlb_one_user(unsigned long addr);\nvoid native_flush_tlb_multi(const struct cpumask *cpumask,\n\t\t\t     const struct flush_tlb_info *info);\n\nstatic inline void __flush_tlb_local(void)\n{\n\tPVOP_VCALL0(mmu.flush_tlb_user);\n}\n\nstatic inline void __flush_tlb_global(void)\n{\n\tPVOP_VCALL0(mmu.flush_tlb_kernel);\n}\n\nstatic inline void __flush_tlb_one_user(unsigned long addr)\n{\n\tPVOP_VCALL1(mmu.flush_tlb_one_user, addr);\n}\n\nstatic inline void __flush_tlb_multi(const struct cpumask *cpumask,\n\t\t\t\t      const struct flush_tlb_info *info)\n{\n\tPVOP_VCALL2(mmu.flush_tlb_multi, cpumask, info);\n}\n\nstatic inline void paravirt_tlb_remove_table(struct mmu_gather *tlb, void *table)\n{\n\tPVOP_VCALL2(mmu.tlb_remove_table, tlb, table);\n}\n\nstatic inline void paravirt_arch_exit_mmap(struct mm_struct *mm)\n{\n\tPVOP_VCALL1(mmu.exit_mmap, mm);\n}\n\nstatic inline void notify_page_enc_status_changed(unsigned long pfn,\n\t\t\t\t\t\t  int npages, bool enc)\n{\n\tPVOP_VCALL3(mmu.notify_page_enc_status_changed, pfn, npages, enc);\n}\n\n#ifdef CONFIG_PARAVIRT_XXL\nstatic inline void load_sp0(unsigned long sp0)\n{\n\tPVOP_VCALL1(cpu.load_sp0, sp0);\n}\n\n \nstatic inline void __cpuid(unsigned int *eax, unsigned int *ebx,\n\t\t\t   unsigned int *ecx, unsigned int *edx)\n{\n\tPVOP_VCALL4(cpu.cpuid, eax, ebx, ecx, edx);\n}\n\n \nstatic __always_inline unsigned long paravirt_get_debugreg(int reg)\n{\n\treturn PVOP_CALL1(unsigned long, cpu.get_debugreg, reg);\n}\n#define get_debugreg(var, reg) var = paravirt_get_debugreg(reg)\nstatic __always_inline void set_debugreg(unsigned long val, int reg)\n{\n\tPVOP_VCALL2(cpu.set_debugreg, reg, val);\n}\n\nstatic inline unsigned long read_cr0(void)\n{\n\treturn PVOP_CALL0(unsigned long, cpu.read_cr0);\n}\n\nstatic inline void write_cr0(unsigned long x)\n{\n\tPVOP_VCALL1(cpu.write_cr0, x);\n}\n\nstatic __always_inline unsigned long read_cr2(void)\n{\n\treturn PVOP_ALT_CALLEE0(unsigned long, mmu.read_cr2,\n\t\t\t\t\"mov %%cr2, %%rax;\",\n\t\t\t\tALT_NOT(X86_FEATURE_XENPV));\n}\n\nstatic __always_inline void write_cr2(unsigned long x)\n{\n\tPVOP_VCALL1(mmu.write_cr2, x);\n}\n\nstatic inline unsigned long __read_cr3(void)\n{\n\treturn PVOP_ALT_CALL0(unsigned long, mmu.read_cr3,\n\t\t\t      \"mov %%cr3, %%rax;\", ALT_NOT(X86_FEATURE_XENPV));\n}\n\nstatic inline void write_cr3(unsigned long x)\n{\n\tPVOP_ALT_VCALL1(mmu.write_cr3, x,\n\t\t\t\"mov %%rdi, %%cr3\", ALT_NOT(X86_FEATURE_XENPV));\n}\n\nstatic inline void __write_cr4(unsigned long x)\n{\n\tPVOP_VCALL1(cpu.write_cr4, x);\n}\n\nstatic __always_inline void arch_safe_halt(void)\n{\n\tPVOP_VCALL0(irq.safe_halt);\n}\n\nstatic inline void halt(void)\n{\n\tPVOP_VCALL0(irq.halt);\n}\n\nextern noinstr void pv_native_wbinvd(void);\n\nstatic __always_inline void wbinvd(void)\n{\n\tPVOP_ALT_VCALL0(cpu.wbinvd, \"wbinvd\", ALT_NOT(X86_FEATURE_XENPV));\n}\n\nstatic inline u64 paravirt_read_msr(unsigned msr)\n{\n\treturn PVOP_CALL1(u64, cpu.read_msr, msr);\n}\n\nstatic inline void paravirt_write_msr(unsigned msr,\n\t\t\t\t      unsigned low, unsigned high)\n{\n\tPVOP_VCALL3(cpu.write_msr, msr, low, high);\n}\n\nstatic inline u64 paravirt_read_msr_safe(unsigned msr, int *err)\n{\n\treturn PVOP_CALL2(u64, cpu.read_msr_safe, msr, err);\n}\n\nstatic inline int paravirt_write_msr_safe(unsigned msr,\n\t\t\t\t\t  unsigned low, unsigned high)\n{\n\treturn PVOP_CALL3(int, cpu.write_msr_safe, msr, low, high);\n}\n\n#define rdmsr(msr, val1, val2)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n\tu64 _l = paravirt_read_msr(msr);\t\\\n\tval1 = (u32)_l;\t\t\t\t\\\n\tval2 = _l >> 32;\t\t\t\\\n} while (0)\n\n#define wrmsr(msr, val1, val2)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n\tparavirt_write_msr(msr, val1, val2);\t\\\n} while (0)\n\n#define rdmsrl(msr, val)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n\tval = paravirt_read_msr(msr);\t\t\\\n} while (0)\n\nstatic inline void wrmsrl(unsigned msr, u64 val)\n{\n\twrmsr(msr, (u32)val, (u32)(val>>32));\n}\n\n#define wrmsr_safe(msr, a, b)\tparavirt_write_msr_safe(msr, a, b)\n\n \n#define rdmsr_safe(msr, a, b)\t\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\tint _err;\t\t\t\t\t\\\n\tu64 _l = paravirt_read_msr_safe(msr, &_err);\t\\\n\t(*a) = (u32)_l;\t\t\t\t\t\\\n\t(*b) = _l >> 32;\t\t\t\t\\\n\t_err;\t\t\t\t\t\t\\\n})\n\nstatic inline int rdmsrl_safe(unsigned msr, unsigned long long *p)\n{\n\tint err;\n\n\t*p = paravirt_read_msr_safe(msr, &err);\n\treturn err;\n}\n\nstatic inline unsigned long long paravirt_read_pmc(int counter)\n{\n\treturn PVOP_CALL1(u64, cpu.read_pmc, counter);\n}\n\n#define rdpmc(counter, low, high)\t\t\\\ndo {\t\t\t\t\t\t\\\n\tu64 _l = paravirt_read_pmc(counter);\t\\\n\tlow = (u32)_l;\t\t\t\t\\\n\thigh = _l >> 32;\t\t\t\\\n} while (0)\n\n#define rdpmcl(counter, val) ((val) = paravirt_read_pmc(counter))\n\nstatic inline void paravirt_alloc_ldt(struct desc_struct *ldt, unsigned entries)\n{\n\tPVOP_VCALL2(cpu.alloc_ldt, ldt, entries);\n}\n\nstatic inline void paravirt_free_ldt(struct desc_struct *ldt, unsigned entries)\n{\n\tPVOP_VCALL2(cpu.free_ldt, ldt, entries);\n}\n\nstatic inline void load_TR_desc(void)\n{\n\tPVOP_VCALL0(cpu.load_tr_desc);\n}\nstatic inline void load_gdt(const struct desc_ptr *dtr)\n{\n\tPVOP_VCALL1(cpu.load_gdt, dtr);\n}\nstatic inline void load_idt(const struct desc_ptr *dtr)\n{\n\tPVOP_VCALL1(cpu.load_idt, dtr);\n}\nstatic inline void set_ldt(const void *addr, unsigned entries)\n{\n\tPVOP_VCALL2(cpu.set_ldt, addr, entries);\n}\nstatic inline unsigned long paravirt_store_tr(void)\n{\n\treturn PVOP_CALL0(unsigned long, cpu.store_tr);\n}\n\n#define store_tr(tr)\t((tr) = paravirt_store_tr())\nstatic inline void load_TLS(struct thread_struct *t, unsigned cpu)\n{\n\tPVOP_VCALL2(cpu.load_tls, t, cpu);\n}\n\nstatic inline void load_gs_index(unsigned int gs)\n{\n\tPVOP_VCALL1(cpu.load_gs_index, gs);\n}\n\nstatic inline void write_ldt_entry(struct desc_struct *dt, int entry,\n\t\t\t\t   const void *desc)\n{\n\tPVOP_VCALL3(cpu.write_ldt_entry, dt, entry, desc);\n}\n\nstatic inline void write_gdt_entry(struct desc_struct *dt, int entry,\n\t\t\t\t   void *desc, int type)\n{\n\tPVOP_VCALL4(cpu.write_gdt_entry, dt, entry, desc, type);\n}\n\nstatic inline void write_idt_entry(gate_desc *dt, int entry, const gate_desc *g)\n{\n\tPVOP_VCALL3(cpu.write_idt_entry, dt, entry, g);\n}\n\n#ifdef CONFIG_X86_IOPL_IOPERM\nstatic inline void tss_invalidate_io_bitmap(void)\n{\n\tPVOP_VCALL0(cpu.invalidate_io_bitmap);\n}\n\nstatic inline void tss_update_io_bitmap(void)\n{\n\tPVOP_VCALL0(cpu.update_io_bitmap);\n}\n#endif\n\nstatic inline void paravirt_enter_mmap(struct mm_struct *next)\n{\n\tPVOP_VCALL1(mmu.enter_mmap, next);\n}\n\nstatic inline int paravirt_pgd_alloc(struct mm_struct *mm)\n{\n\treturn PVOP_CALL1(int, mmu.pgd_alloc, mm);\n}\n\nstatic inline void paravirt_pgd_free(struct mm_struct *mm, pgd_t *pgd)\n{\n\tPVOP_VCALL2(mmu.pgd_free, mm, pgd);\n}\n\nstatic inline void paravirt_alloc_pte(struct mm_struct *mm, unsigned long pfn)\n{\n\tPVOP_VCALL2(mmu.alloc_pte, mm, pfn);\n}\nstatic inline void paravirt_release_pte(unsigned long pfn)\n{\n\tPVOP_VCALL1(mmu.release_pte, pfn);\n}\n\nstatic inline void paravirt_alloc_pmd(struct mm_struct *mm, unsigned long pfn)\n{\n\tPVOP_VCALL2(mmu.alloc_pmd, mm, pfn);\n}\n\nstatic inline void paravirt_release_pmd(unsigned long pfn)\n{\n\tPVOP_VCALL1(mmu.release_pmd, pfn);\n}\n\nstatic inline void paravirt_alloc_pud(struct mm_struct *mm, unsigned long pfn)\n{\n\tPVOP_VCALL2(mmu.alloc_pud, mm, pfn);\n}\nstatic inline void paravirt_release_pud(unsigned long pfn)\n{\n\tPVOP_VCALL1(mmu.release_pud, pfn);\n}\n\nstatic inline void paravirt_alloc_p4d(struct mm_struct *mm, unsigned long pfn)\n{\n\tPVOP_VCALL2(mmu.alloc_p4d, mm, pfn);\n}\n\nstatic inline void paravirt_release_p4d(unsigned long pfn)\n{\n\tPVOP_VCALL1(mmu.release_p4d, pfn);\n}\n\nstatic inline pte_t __pte(pteval_t val)\n{\n\treturn (pte_t) { PVOP_ALT_CALLEE1(pteval_t, mmu.make_pte, val,\n\t\t\t\t\t  \"mov %%rdi, %%rax\",\n\t\t\t\t\t  ALT_NOT(X86_FEATURE_XENPV)) };\n}\n\nstatic inline pteval_t pte_val(pte_t pte)\n{\n\treturn PVOP_ALT_CALLEE1(pteval_t, mmu.pte_val, pte.pte,\n\t\t\t\t\"mov %%rdi, %%rax\", ALT_NOT(X86_FEATURE_XENPV));\n}\n\nstatic inline pgd_t __pgd(pgdval_t val)\n{\n\treturn (pgd_t) { PVOP_ALT_CALLEE1(pgdval_t, mmu.make_pgd, val,\n\t\t\t\t\t  \"mov %%rdi, %%rax\",\n\t\t\t\t\t  ALT_NOT(X86_FEATURE_XENPV)) };\n}\n\nstatic inline pgdval_t pgd_val(pgd_t pgd)\n{\n\treturn PVOP_ALT_CALLEE1(pgdval_t, mmu.pgd_val, pgd.pgd,\n\t\t\t\t\"mov %%rdi, %%rax\", ALT_NOT(X86_FEATURE_XENPV));\n}\n\n#define  __HAVE_ARCH_PTEP_MODIFY_PROT_TRANSACTION\nstatic inline pte_t ptep_modify_prot_start(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\t\t   pte_t *ptep)\n{\n\tpteval_t ret;\n\n\tret = PVOP_CALL3(pteval_t, mmu.ptep_modify_prot_start, vma, addr, ptep);\n\n\treturn (pte_t) { .pte = ret };\n}\n\nstatic inline void ptep_modify_prot_commit(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\t\t   pte_t *ptep, pte_t old_pte, pte_t pte)\n{\n\n\tPVOP_VCALL4(mmu.ptep_modify_prot_commit, vma, addr, ptep, pte.pte);\n}\n\nstatic inline void set_pte(pte_t *ptep, pte_t pte)\n{\n\tPVOP_VCALL2(mmu.set_pte, ptep, pte.pte);\n}\n\nstatic inline void set_pmd(pmd_t *pmdp, pmd_t pmd)\n{\n\tPVOP_VCALL2(mmu.set_pmd, pmdp, native_pmd_val(pmd));\n}\n\nstatic inline pmd_t __pmd(pmdval_t val)\n{\n\treturn (pmd_t) { PVOP_ALT_CALLEE1(pmdval_t, mmu.make_pmd, val,\n\t\t\t\t\t  \"mov %%rdi, %%rax\",\n\t\t\t\t\t  ALT_NOT(X86_FEATURE_XENPV)) };\n}\n\nstatic inline pmdval_t pmd_val(pmd_t pmd)\n{\n\treturn PVOP_ALT_CALLEE1(pmdval_t, mmu.pmd_val, pmd.pmd,\n\t\t\t\t\"mov %%rdi, %%rax\", ALT_NOT(X86_FEATURE_XENPV));\n}\n\nstatic inline void set_pud(pud_t *pudp, pud_t pud)\n{\n\tPVOP_VCALL2(mmu.set_pud, pudp, native_pud_val(pud));\n}\n\nstatic inline pud_t __pud(pudval_t val)\n{\n\tpudval_t ret;\n\n\tret = PVOP_ALT_CALLEE1(pudval_t, mmu.make_pud, val,\n\t\t\t       \"mov %%rdi, %%rax\", ALT_NOT(X86_FEATURE_XENPV));\n\n\treturn (pud_t) { ret };\n}\n\nstatic inline pudval_t pud_val(pud_t pud)\n{\n\treturn PVOP_ALT_CALLEE1(pudval_t, mmu.pud_val, pud.pud,\n\t\t\t\t\"mov %%rdi, %%rax\", ALT_NOT(X86_FEATURE_XENPV));\n}\n\nstatic inline void pud_clear(pud_t *pudp)\n{\n\tset_pud(pudp, native_make_pud(0));\n}\n\nstatic inline void set_p4d(p4d_t *p4dp, p4d_t p4d)\n{\n\tp4dval_t val = native_p4d_val(p4d);\n\n\tPVOP_VCALL2(mmu.set_p4d, p4dp, val);\n}\n\n#if CONFIG_PGTABLE_LEVELS >= 5\n\nstatic inline p4d_t __p4d(p4dval_t val)\n{\n\tp4dval_t ret = PVOP_ALT_CALLEE1(p4dval_t, mmu.make_p4d, val,\n\t\t\t\t\t\"mov %%rdi, %%rax\",\n\t\t\t\t\tALT_NOT(X86_FEATURE_XENPV));\n\n\treturn (p4d_t) { ret };\n}\n\nstatic inline p4dval_t p4d_val(p4d_t p4d)\n{\n\treturn PVOP_ALT_CALLEE1(p4dval_t, mmu.p4d_val, p4d.p4d,\n\t\t\t\t\"mov %%rdi, %%rax\", ALT_NOT(X86_FEATURE_XENPV));\n}\n\nstatic inline void __set_pgd(pgd_t *pgdp, pgd_t pgd)\n{\n\tPVOP_VCALL2(mmu.set_pgd, pgdp, native_pgd_val(pgd));\n}\n\n#define set_pgd(pgdp, pgdval) do {\t\t\t\t\t\\\n\tif (pgtable_l5_enabled())\t\t\t\t\t\t\\\n\t\t__set_pgd(pgdp, pgdval);\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tset_p4d((p4d_t *)(pgdp), (p4d_t) { (pgdval).pgd });\t\\\n} while (0)\n\n#define pgd_clear(pgdp) do {\t\t\t\t\t\t\\\n\tif (pgtable_l5_enabled())\t\t\t\t\t\\\n\t\tset_pgd(pgdp, native_make_pgd(0));\t\t\t\\\n} while (0)\n\n#endif   \n\nstatic inline void p4d_clear(p4d_t *p4dp)\n{\n\tset_p4d(p4dp, native_make_p4d(0));\n}\n\nstatic inline void set_pte_atomic(pte_t *ptep, pte_t pte)\n{\n\tset_pte(ptep, pte);\n}\n\nstatic inline void pte_clear(struct mm_struct *mm, unsigned long addr,\n\t\t\t     pte_t *ptep)\n{\n\tset_pte(ptep, native_make_pte(0));\n}\n\nstatic inline void pmd_clear(pmd_t *pmdp)\n{\n\tset_pmd(pmdp, native_make_pmd(0));\n}\n\n#define  __HAVE_ARCH_START_CONTEXT_SWITCH\nstatic inline void arch_start_context_switch(struct task_struct *prev)\n{\n\tPVOP_VCALL1(cpu.start_context_switch, prev);\n}\n\nstatic inline void arch_end_context_switch(struct task_struct *next)\n{\n\tPVOP_VCALL1(cpu.end_context_switch, next);\n}\n\n#define  __HAVE_ARCH_ENTER_LAZY_MMU_MODE\nstatic inline void arch_enter_lazy_mmu_mode(void)\n{\n\tPVOP_VCALL0(mmu.lazy_mode.enter);\n}\n\nstatic inline void arch_leave_lazy_mmu_mode(void)\n{\n\tPVOP_VCALL0(mmu.lazy_mode.leave);\n}\n\nstatic inline void arch_flush_lazy_mmu_mode(void)\n{\n\tPVOP_VCALL0(mmu.lazy_mode.flush);\n}\n\nstatic inline void __set_fixmap(unsigned   idx,\n\t\t\t\tphys_addr_t phys, pgprot_t flags)\n{\n\tpv_ops.mmu.set_fixmap(idx, phys, flags);\n}\n#endif\n\n#if defined(CONFIG_SMP) && defined(CONFIG_PARAVIRT_SPINLOCKS)\n\nstatic __always_inline void pv_queued_spin_lock_slowpath(struct qspinlock *lock,\n\t\t\t\t\t\t\tu32 val)\n{\n\tPVOP_VCALL2(lock.queued_spin_lock_slowpath, lock, val);\n}\n\nstatic __always_inline void pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tPVOP_ALT_VCALLEE1(lock.queued_spin_unlock, lock,\n\t\t\t  \"movb $0, (%%\" _ASM_ARG1 \");\",\n\t\t\t  ALT_NOT(X86_FEATURE_PVUNLOCK));\n}\n\nstatic __always_inline void pv_wait(u8 *ptr, u8 val)\n{\n\tPVOP_VCALL2(lock.wait, ptr, val);\n}\n\nstatic __always_inline void pv_kick(int cpu)\n{\n\tPVOP_VCALL1(lock.kick, cpu);\n}\n\nstatic __always_inline bool pv_vcpu_is_preempted(long cpu)\n{\n\treturn PVOP_ALT_CALLEE1(bool, lock.vcpu_is_preempted, cpu,\n\t\t\t\t\"xor %%\" _ASM_AX \", %%\" _ASM_AX \";\",\n\t\t\t\tALT_NOT(X86_FEATURE_VCPUPREEMPT));\n}\n\nvoid __raw_callee_save___native_queued_spin_unlock(struct qspinlock *lock);\nbool __raw_callee_save___native_vcpu_is_preempted(long cpu);\n\n#endif  \n\n#ifdef CONFIG_X86_32\n \n#define PV_SAVE_ALL_CALLER_REGS\t\t\"pushl %ecx;\"\n#define PV_RESTORE_ALL_CALLER_REGS\t\"popl  %ecx;\"\n#else\n \n#define PV_SAVE_ALL_CALLER_REGS\t\t\t\t\t\t\\\n\t\"push %rcx;\"\t\t\t\t\t\t\t\\\n\t\"push %rdx;\"\t\t\t\t\t\t\t\\\n\t\"push %rsi;\"\t\t\t\t\t\t\t\\\n\t\"push %rdi;\"\t\t\t\t\t\t\t\\\n\t\"push %r8;\"\t\t\t\t\t\t\t\\\n\t\"push %r9;\"\t\t\t\t\t\t\t\\\n\t\"push %r10;\"\t\t\t\t\t\t\t\\\n\t\"push %r11;\"\n#define PV_RESTORE_ALL_CALLER_REGS\t\t\t\t\t\\\n\t\"pop %r11;\"\t\t\t\t\t\t\t\\\n\t\"pop %r10;\"\t\t\t\t\t\t\t\\\n\t\"pop %r9;\"\t\t\t\t\t\t\t\\\n\t\"pop %r8;\"\t\t\t\t\t\t\t\\\n\t\"pop %rdi;\"\t\t\t\t\t\t\t\\\n\t\"pop %rsi;\"\t\t\t\t\t\t\t\\\n\t\"pop %rdx;\"\t\t\t\t\t\t\t\\\n\t\"pop %rcx;\"\n#endif\n\n \n#define PV_THUNK_NAME(func) \"__raw_callee_save_\" #func\n#define __PV_CALLEE_SAVE_REGS_THUNK(func, section)\t\t\t\\\n\textern typeof(func) __raw_callee_save_##func;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tasm(\".pushsection \" section \", \\\"ax\\\";\"\t\t\t\t\\\n\t    \".globl \" PV_THUNK_NAME(func) \";\"\t\t\t\t\\\n\t    \".type \" PV_THUNK_NAME(func) \", @function;\"\t\t\t\\\n\t    ASM_FUNC_ALIGN\t\t\t\t\t\t\\\n\t    PV_THUNK_NAME(func) \":\"\t\t\t\t\t\\\n\t    ASM_ENDBR\t\t\t\t\t\t\t\\\n\t    FRAME_BEGIN\t\t\t\t\t\t\t\\\n\t    PV_SAVE_ALL_CALLER_REGS\t\t\t\t\t\\\n\t    \"call \" #func \";\"\t\t\t\t\t\t\\\n\t    PV_RESTORE_ALL_CALLER_REGS\t\t\t\t\t\\\n\t    FRAME_END\t\t\t\t\t\t\t\\\n\t    ASM_RET\t\t\t\t\t\t\t\\\n\t    \".size \" PV_THUNK_NAME(func) \", .-\" PV_THUNK_NAME(func) \";\"\t\\\n\t    \".popsection\")\n\n#define PV_CALLEE_SAVE_REGS_THUNK(func)\t\t\t\\\n\t__PV_CALLEE_SAVE_REGS_THUNK(func, \".text\")\n\n \n#define PV_CALLEE_SAVE(func)\t\t\t\t\t\t\\\n\t((struct paravirt_callee_save) { __raw_callee_save_##func })\n\n \n#define __PV_IS_CALLEE_SAVE(func)\t\t\t\\\n\t((struct paravirt_callee_save) { func })\n\n#ifdef CONFIG_PARAVIRT_XXL\nstatic __always_inline unsigned long arch_local_save_flags(void)\n{\n\treturn PVOP_ALT_CALLEE0(unsigned long, irq.save_fl, \"pushf; pop %%rax;\",\n\t\t\t\tALT_NOT(X86_FEATURE_XENPV));\n}\n\nstatic __always_inline void arch_local_irq_disable(void)\n{\n\tPVOP_ALT_VCALLEE0(irq.irq_disable, \"cli;\", ALT_NOT(X86_FEATURE_XENPV));\n}\n\nstatic __always_inline void arch_local_irq_enable(void)\n{\n\tPVOP_ALT_VCALLEE0(irq.irq_enable, \"sti;\", ALT_NOT(X86_FEATURE_XENPV));\n}\n\nstatic __always_inline unsigned long arch_local_irq_save(void)\n{\n\tunsigned long f;\n\n\tf = arch_local_save_flags();\n\tarch_local_irq_disable();\n\treturn f;\n}\n#endif\n\n\n \n#undef PARAVIRT_CALL\n#undef __PVOP_CALL\n#undef __PVOP_VCALL\n#undef PVOP_VCALL0\n#undef PVOP_CALL0\n#undef PVOP_VCALL1\n#undef PVOP_CALL1\n#undef PVOP_VCALL2\n#undef PVOP_CALL2\n#undef PVOP_VCALL3\n#undef PVOP_CALL3\n#undef PVOP_VCALL4\n#undef PVOP_CALL4\n\n#define DEFINE_PARAVIRT_ASM(func, instr, sec)\t\t\\\n\tasm (\".pushsection \" #sec \", \\\"ax\\\"\\n\"\t\t\\\n\t     \".global \" #func \"\\n\\t\"\t\t\t\\\n\t     \".type \" #func \", @function\\n\\t\"\t\t\\\n\t     ASM_FUNC_ALIGN \"\\n\"\t\t\t\\\n\t     #func \":\\n\\t\"\t\t\t\t\\\n\t     ASM_ENDBR\t\t\t\t\t\\\n\t     instr \"\\n\\t\"\t\t\t\t\\\n\t     ASM_RET\t\t\t\t\t\\\n\t     \".size \" #func \", . - \" #func \"\\n\\t\"\t\\\n\t     \".popsection\")\n\nextern void default_banner(void);\nvoid native_pv_lock_init(void) __init;\n\n#else   \n\n#define _PVSITE(ptype, ops, word, algn)\t\t\\\n771:;\t\t\t\t\t\t\\\n\tops;\t\t\t\t\t\\\n772:;\t\t\t\t\t\t\\\n\t.pushsection .parainstructions,\"a\";\t\\\n\t .align\talgn;\t\t\t\t\\\n\t word 771b;\t\t\t\t\\\n\t .byte ptype;\t\t\t\t\\\n\t .byte 772b-771b;\t\t\t\\\n\t _ASM_ALIGN;\t\t\t\t\\\n\t.popsection\n\n\n#ifdef CONFIG_X86_64\n#ifdef CONFIG_PARAVIRT_XXL\n\n#define PARA_PATCH(off)\t\t((off) / 8)\n#define PARA_SITE(ptype, ops)\t_PVSITE(ptype, ops, .quad, 8)\n#define PARA_INDIRECT(addr)\t*addr(%rip)\n\n#ifdef CONFIG_DEBUG_ENTRY\n.macro PARA_IRQ_save_fl\n\tPARA_SITE(PARA_PATCH(PV_IRQ_save_fl),\n\t\t  ANNOTATE_RETPOLINE_SAFE;\n\t\t  call PARA_INDIRECT(pv_ops+PV_IRQ_save_fl);)\n.endm\n\n#define SAVE_FLAGS\tALTERNATIVE \"PARA_IRQ_save_fl;\", \"pushf; pop %rax;\", \\\n\t\t\t\t    ALT_NOT(X86_FEATURE_XENPV)\n#endif\n#endif  \n#endif\t \n\n#endif  \n#else   \n# define default_banner x86_init_noop\n\n#ifndef __ASSEMBLY__\nstatic inline void native_pv_lock_init(void)\n{\n}\n#endif\n#endif  \n\n#ifndef __ASSEMBLY__\n#ifndef CONFIG_PARAVIRT_XXL\nstatic inline void paravirt_enter_mmap(struct mm_struct *mm)\n{\n}\n#endif\n\n#ifndef CONFIG_PARAVIRT\nstatic inline void paravirt_arch_exit_mmap(struct mm_struct *mm)\n{\n}\n#endif\n\n#ifndef CONFIG_PARAVIRT_SPINLOCKS\nstatic inline void paravirt_set_cap(void)\n{\n}\n#endif\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}