{
  "module_name": "apic.h",
  "hash_id": "fc7b4032dac20122f69b5beabcca05934e8a58ff7624cd29b99d24d51cfe2d5c",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/apic.h",
  "human_readable_source": " \n#ifndef _ASM_X86_APIC_H\n#define _ASM_X86_APIC_H\n\n#include <linux/cpumask.h>\n#include <linux/static_call.h>\n\n#include <asm/alternative.h>\n#include <asm/cpufeature.h>\n#include <asm/apicdef.h>\n#include <linux/atomic.h>\n#include <asm/fixmap.h>\n#include <asm/mpspec.h>\n#include <asm/msr.h>\n#include <asm/hardirq.h>\n\n#define ARCH_APICTIMER_STOPS_ON_C3\t1\n\n \n#define APIC_QUIET   0\n#define APIC_VERBOSE 1\n#define APIC_DEBUG   2\n\n \n#define APIC_EXTNMI_BSP\t\t0  \n#define APIC_EXTNMI_ALL\t\t1\n#define APIC_EXTNMI_NONE\t2\n\n \n#define apic_printk(v, s, a...) do {       \\\n\t\tif ((v) <= apic_verbosity) \\\n\t\t\tprintk(s, ##a);    \\\n\t} while (0)\n\n\n#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_X86_32)\nextern void x86_32_probe_apic(void);\n#else\nstatic inline void x86_32_probe_apic(void) { }\n#endif\n\n#ifdef CONFIG_X86_LOCAL_APIC\n\nextern int apic_verbosity;\nextern int local_apic_timer_c2_ok;\n\nextern bool apic_is_disabled;\nextern unsigned int lapic_timer_period;\n\nextern int cpuid_to_apicid[];\n\nextern enum apic_intr_mode_id apic_intr_mode;\nenum apic_intr_mode_id {\n\tAPIC_PIC,\n\tAPIC_VIRTUAL_WIRE,\n\tAPIC_VIRTUAL_WIRE_NO_CONFIG,\n\tAPIC_SYMMETRIC_IO,\n\tAPIC_SYMMETRIC_IO_NO_ROUTING\n};\n\n \nstatic inline bool apic_from_smp_config(void)\n{\n\treturn smp_found_config && !apic_is_disabled;\n}\n\n \n#ifdef CONFIG_PARAVIRT\n#include <asm/paravirt.h>\n#endif\n\nstatic inline void native_apic_mem_write(u32 reg, u32 v)\n{\n\tvolatile u32 *addr = (volatile u32 *)(APIC_BASE + reg);\n\n\talternative_io(\"movl %0, %P1\", \"xchgl %0, %P1\", X86_BUG_11AP,\n\t\t       ASM_OUTPUT2(\"=r\" (v), \"=m\" (*addr)),\n\t\t       ASM_OUTPUT2(\"0\" (v), \"m\" (*addr)));\n}\n\nstatic inline u32 native_apic_mem_read(u32 reg)\n{\n\treturn *((volatile u32 *)(APIC_BASE + reg));\n}\n\nstatic inline void native_apic_mem_eoi(void)\n{\n\tnative_apic_mem_write(APIC_EOI, APIC_EOI_ACK);\n}\n\nextern void native_apic_icr_write(u32 low, u32 id);\nextern u64 native_apic_icr_read(void);\n\nstatic inline bool apic_is_x2apic_enabled(void)\n{\n\tu64 msr;\n\n\tif (rdmsrl_safe(MSR_IA32_APICBASE, &msr))\n\t\treturn false;\n\treturn msr & X2APIC_ENABLE;\n}\n\nextern void enable_IR_x2apic(void);\n\nextern int get_physical_broadcast(void);\n\nextern int lapic_get_maxlvt(void);\nextern void clear_local_APIC(void);\nextern void disconnect_bsp_APIC(int virt_wire_setup);\nextern void disable_local_APIC(void);\nextern void apic_soft_disable(void);\nextern void lapic_shutdown(void);\nextern void sync_Arb_IDs(void);\nextern void init_bsp_APIC(void);\nextern void apic_intr_mode_select(void);\nextern void apic_intr_mode_init(void);\nextern void init_apic_mappings(void);\nvoid register_lapic_address(unsigned long address);\nextern void setup_boot_APIC_clock(void);\nextern void setup_secondary_APIC_clock(void);\nextern void lapic_update_tsc_freq(void);\n\n#ifdef CONFIG_X86_64\nstatic inline bool apic_force_enable(unsigned long addr)\n{\n\treturn false;\n}\n#else\nextern bool apic_force_enable(unsigned long addr);\n#endif\n\nextern void apic_ap_setup(void);\n\n \n#ifdef CONFIG_X86_64\nextern int apic_is_clustered_box(void);\n#else\nstatic inline int apic_is_clustered_box(void)\n{\n\treturn 0;\n}\n#endif\n\nextern int setup_APIC_eilvt(u8 lvt_off, u8 vector, u8 msg_type, u8 mask);\nextern void lapic_assign_system_vectors(void);\nextern void lapic_assign_legacy_vector(unsigned int isairq, bool replace);\nextern void lapic_update_legacy_vectors(void);\nextern void lapic_online(void);\nextern void lapic_offline(void);\nextern bool apic_needs_pit(void);\n\nextern void apic_send_IPI_allbutself(unsigned int vector);\n\n#else  \nstatic inline void lapic_shutdown(void) { }\n#define local_apic_timer_c2_ok\t\t1\nstatic inline void init_apic_mappings(void) { }\nstatic inline void disable_local_APIC(void) { }\n# define setup_boot_APIC_clock x86_init_noop\n# define setup_secondary_APIC_clock x86_init_noop\nstatic inline void lapic_update_tsc_freq(void) { }\nstatic inline void init_bsp_APIC(void) { }\nstatic inline void apic_intr_mode_select(void) { }\nstatic inline void apic_intr_mode_init(void) { }\nstatic inline void lapic_assign_system_vectors(void) { }\nstatic inline void lapic_assign_legacy_vector(unsigned int i, bool r) { }\nstatic inline bool apic_needs_pit(void) { return true; }\n#endif  \n\n#ifdef CONFIG_X86_X2APIC\nstatic inline void native_apic_msr_write(u32 reg, u32 v)\n{\n\tif (reg == APIC_DFR || reg == APIC_ID || reg == APIC_LDR ||\n\t    reg == APIC_LVR)\n\t\treturn;\n\n\twrmsr(APIC_BASE_MSR + (reg >> 4), v, 0);\n}\n\nstatic inline void native_apic_msr_eoi(void)\n{\n\t__wrmsr(APIC_BASE_MSR + (APIC_EOI >> 4), APIC_EOI_ACK, 0);\n}\n\nstatic inline u32 native_apic_msr_read(u32 reg)\n{\n\tu64 msr;\n\n\tif (reg == APIC_DFR)\n\t\treturn -1;\n\n\trdmsrl(APIC_BASE_MSR + (reg >> 4), msr);\n\treturn (u32)msr;\n}\n\nstatic inline void native_x2apic_icr_write(u32 low, u32 id)\n{\n\twrmsrl(APIC_BASE_MSR + (APIC_ICR >> 4), ((__u64) id) << 32 | low);\n}\n\nstatic inline u64 native_x2apic_icr_read(void)\n{\n\tunsigned long val;\n\n\trdmsrl(APIC_BASE_MSR + (APIC_ICR >> 4), val);\n\treturn val;\n}\n\nextern int x2apic_mode;\nextern int x2apic_phys;\nextern void __init x2apic_set_max_apicid(u32 apicid);\nextern void x2apic_setup(void);\nstatic inline int x2apic_enabled(void)\n{\n\treturn boot_cpu_has(X86_FEATURE_X2APIC) && apic_is_x2apic_enabled();\n}\n\n#define x2apic_supported()\t(boot_cpu_has(X86_FEATURE_X2APIC))\n#else  \nstatic inline void x2apic_setup(void) { }\nstatic inline int x2apic_enabled(void) { return 0; }\nstatic inline u32 native_apic_msr_read(u32 reg) { BUG(); }\n#define x2apic_mode\t\t(0)\n#define\tx2apic_supported()\t(0)\n#endif  \nextern void __init check_x2apic(void);\n\nstruct irq_data;\n\n \nstruct apic {\n\t \n\tvoid\t(*eoi)(void);\n\tvoid\t(*native_eoi)(void);\n\tvoid\t(*write)(u32 reg, u32 v);\n\tu32\t(*read)(u32 reg);\n\n\t \n\tvoid\t(*wait_icr_idle)(void);\n\tu32\t(*safe_wait_icr_idle)(void);\n\n\tvoid\t(*send_IPI)(int cpu, int vector);\n\tvoid\t(*send_IPI_mask)(const struct cpumask *mask, int vector);\n\tvoid\t(*send_IPI_mask_allbutself)(const struct cpumask *msk, int vec);\n\tvoid\t(*send_IPI_allbutself)(int vector);\n\tvoid\t(*send_IPI_all)(int vector);\n\tvoid\t(*send_IPI_self)(int vector);\n\n\tenum apic_delivery_modes delivery_mode;\n\n\tu32\tdisable_esr\t\t: 1,\n\t\tdest_mode_logical\t: 1,\n\t\tx2apic_set_max_apicid\t: 1;\n\n\tu32\t(*calc_dest_apicid)(unsigned int cpu);\n\n\t \n\tu64\t(*icr_read)(void);\n\tvoid\t(*icr_write)(u32 low, u32 high);\n\n\t \n\tu32\tmax_apic_id;\n\n\t \n\tint\t(*probe)(void);\n\tint\t(*acpi_madt_oem_check)(char *oem_id, char *oem_table_id);\n\tbool\t(*apic_id_registered)(void);\n\n\tbool\t(*check_apicid_used)(physid_mask_t *map, int apicid);\n\tvoid\t(*init_apic_ldr)(void);\n\tvoid\t(*ioapic_phys_id_map)(physid_mask_t *phys_map, physid_mask_t *retmap);\n\tint\t(*cpu_present_to_apicid)(int mps_cpu);\n\tint\t(*phys_pkg_id)(int cpuid_apic, int index_msb);\n\n\tu32\t(*get_apic_id)(unsigned long x);\n\tu32\t(*set_apic_id)(unsigned int id);\n\n\t \n\tint\t(*wakeup_secondary_cpu)(int apicid, unsigned long start_eip);\n\t \n\tint\t(*wakeup_secondary_cpu_64)(int apicid, unsigned long start_eip);\n\n\tchar\t*name;\n};\n\nstruct apic_override {\n\tvoid\t(*eoi)(void);\n\tvoid\t(*native_eoi)(void);\n\tvoid\t(*write)(u32 reg, u32 v);\n\tu32\t(*read)(u32 reg);\n\tvoid\t(*send_IPI)(int cpu, int vector);\n\tvoid\t(*send_IPI_mask)(const struct cpumask *mask, int vector);\n\tvoid\t(*send_IPI_mask_allbutself)(const struct cpumask *msk, int vec);\n\tvoid\t(*send_IPI_allbutself)(int vector);\n\tvoid\t(*send_IPI_all)(int vector);\n\tvoid\t(*send_IPI_self)(int vector);\n\tu64\t(*icr_read)(void);\n\tvoid\t(*icr_write)(u32 low, u32 high);\n\tint\t(*wakeup_secondary_cpu)(int apicid, unsigned long start_eip);\n\tint\t(*wakeup_secondary_cpu_64)(int apicid, unsigned long start_eip);\n};\n\n \nextern struct apic *apic;\n\n \n#define apic_driver(sym)\t\t\t\t\t\\\n\tstatic const struct apic *__apicdrivers_##sym __used\t\t\\\n\t__aligned(sizeof(struct apic *))\t\t\t\\\n\t__section(\".apicdrivers\") = { &sym }\n\n#define apic_drivers(sym1, sym2)\t\t\t\t\t\\\n\tstatic struct apic *__apicdrivers_##sym1##sym2[2] __used\t\\\n\t__aligned(sizeof(struct apic *))\t\t\t\t\\\n\t__section(\".apicdrivers\") = { &sym1, &sym2 }\n\nextern struct apic *__apicdrivers[], *__apicdrivers_end[];\n\n \n#ifdef CONFIG_SMP\nextern int lapic_can_unplug_cpu(void);\n#endif\n\n#ifdef CONFIG_X86_LOCAL_APIC\nextern struct apic_override __x86_apic_override;\n\nvoid __init apic_setup_apic_calls(void);\nvoid __init apic_install_driver(struct apic *driver);\n\n#define apic_update_callback(_callback, _fn) {\t\t\t\t\t\\\n\t\t__x86_apic_override._callback = _fn;\t\t\t\t\\\n\t\tapic->_callback = _fn;\t\t\t\t\t\t\\\n\t\tstatic_call_update(apic_call_##_callback, _fn);\t\t\t\\\n\t\tpr_info(\"APIC: %s() replaced with %ps()\\n\", #_callback, _fn);\t\\\n}\n\n#define DECLARE_APIC_CALL(__cb)\t\t\t\t\t\t\t\\\n\tDECLARE_STATIC_CALL(apic_call_##__cb, *apic->__cb)\n\nDECLARE_APIC_CALL(eoi);\nDECLARE_APIC_CALL(native_eoi);\nDECLARE_APIC_CALL(icr_read);\nDECLARE_APIC_CALL(icr_write);\nDECLARE_APIC_CALL(read);\nDECLARE_APIC_CALL(send_IPI);\nDECLARE_APIC_CALL(send_IPI_mask);\nDECLARE_APIC_CALL(send_IPI_mask_allbutself);\nDECLARE_APIC_CALL(send_IPI_allbutself);\nDECLARE_APIC_CALL(send_IPI_all);\nDECLARE_APIC_CALL(send_IPI_self);\nDECLARE_APIC_CALL(wait_icr_idle);\nDECLARE_APIC_CALL(wakeup_secondary_cpu);\nDECLARE_APIC_CALL(wakeup_secondary_cpu_64);\nDECLARE_APIC_CALL(write);\n\nstatic __always_inline u32 apic_read(u32 reg)\n{\n\treturn static_call(apic_call_read)(reg);\n}\n\nstatic __always_inline void apic_write(u32 reg, u32 val)\n{\n\tstatic_call(apic_call_write)(reg, val);\n}\n\nstatic __always_inline void apic_eoi(void)\n{\n\tstatic_call(apic_call_eoi)();\n}\n\nstatic __always_inline void apic_native_eoi(void)\n{\n\tstatic_call(apic_call_native_eoi)();\n}\n\nstatic __always_inline u64 apic_icr_read(void)\n{\n\treturn static_call(apic_call_icr_read)();\n}\n\nstatic __always_inline void apic_icr_write(u32 low, u32 high)\n{\n\tstatic_call(apic_call_icr_write)(low, high);\n}\n\nstatic __always_inline void __apic_send_IPI(int cpu, int vector)\n{\n\tstatic_call(apic_call_send_IPI)(cpu, vector);\n}\n\nstatic __always_inline void __apic_send_IPI_mask(const struct cpumask *mask, int vector)\n{\n\tstatic_call_mod(apic_call_send_IPI_mask)(mask, vector);\n}\n\nstatic __always_inline void __apic_send_IPI_mask_allbutself(const struct cpumask *mask, int vector)\n{\n\tstatic_call(apic_call_send_IPI_mask_allbutself)(mask, vector);\n}\n\nstatic __always_inline void __apic_send_IPI_allbutself(int vector)\n{\n\tstatic_call(apic_call_send_IPI_allbutself)(vector);\n}\n\nstatic __always_inline void __apic_send_IPI_all(int vector)\n{\n\tstatic_call(apic_call_send_IPI_all)(vector);\n}\n\nstatic __always_inline void __apic_send_IPI_self(int vector)\n{\n\tstatic_call_mod(apic_call_send_IPI_self)(vector);\n}\n\nstatic __always_inline void apic_wait_icr_idle(void)\n{\n\tstatic_call_cond(apic_call_wait_icr_idle)();\n}\n\nstatic __always_inline u32 safe_apic_wait_icr_idle(void)\n{\n\treturn apic->safe_wait_icr_idle ? apic->safe_wait_icr_idle() : 0;\n}\n\nstatic __always_inline bool apic_id_valid(u32 apic_id)\n{\n\treturn apic_id <= apic->max_apic_id;\n}\n\n#else  \n\nstatic inline u32 apic_read(u32 reg) { return 0; }\nstatic inline void apic_write(u32 reg, u32 val) { }\nstatic inline void apic_eoi(void) { }\nstatic inline u64 apic_icr_read(void) { return 0; }\nstatic inline void apic_icr_write(u32 low, u32 high) { }\nstatic inline void apic_wait_icr_idle(void) { }\nstatic inline u32 safe_apic_wait_icr_idle(void) { return 0; }\nstatic inline void apic_set_eoi_cb(void (*eoi)(void)) {}\nstatic inline void apic_native_eoi(void) { WARN_ON_ONCE(1); }\nstatic inline void apic_setup_apic_calls(void) { }\n\n#define apic_update_callback(_callback, _fn) do { } while (0)\n\n#endif  \n\nextern void apic_ack_irq(struct irq_data *data);\n\nstatic inline bool lapic_vector_set_in_irr(unsigned int vector)\n{\n\tu32 irr = apic_read(APIC_IRR + (vector / 32 * 0x10));\n\n\treturn !!(irr & (1U << (vector % 32)));\n}\n\nstatic inline unsigned default_get_apic_id(unsigned long x)\n{\n\tunsigned int ver = GET_APIC_VERSION(apic_read(APIC_LVR));\n\n\tif (APIC_XAPIC(ver) || boot_cpu_has(X86_FEATURE_EXTD_APICID))\n\t\treturn (x >> 24) & 0xFF;\n\telse\n\t\treturn (x >> 24) & 0x0F;\n}\n\n \n#define TRAMPOLINE_PHYS_LOW\t\t0x467\n#define TRAMPOLINE_PHYS_HIGH\t\t0x469\n\nextern void generic_bigsmp_probe(void);\n\n#ifdef CONFIG_X86_LOCAL_APIC\n\n#include <asm/smp.h>\n\nextern struct apic apic_noop;\n\nstatic inline unsigned int read_apic_id(void)\n{\n\tunsigned int reg = apic_read(APIC_ID);\n\n\treturn apic->get_apic_id(reg);\n}\n\n#ifdef CONFIG_X86_64\ntypedef int (*wakeup_cpu_handler)(int apicid, unsigned long start_eip);\nextern int default_acpi_madt_oem_check(char *, char *);\nextern void x86_64_probe_apic(void);\n#else\nstatic inline int default_acpi_madt_oem_check(char *a, char *b) { return 0; }\nstatic inline void x86_64_probe_apic(void) { }\n#endif\n\nextern int default_apic_id_valid(u32 apicid);\n\nextern u32 apic_default_calc_apicid(unsigned int cpu);\nextern u32 apic_flat_calc_apicid(unsigned int cpu);\n\nextern bool default_check_apicid_used(physid_mask_t *map, int apicid);\nextern void default_ioapic_phys_id_map(physid_mask_t *phys_map, physid_mask_t *retmap);\nextern int default_cpu_present_to_apicid(int mps_cpu);\n\n#else  \n\nstatic inline unsigned int read_apic_id(void) { return 0; }\n\n#endif  \n\n#ifdef CONFIG_SMP\nvoid apic_smt_update(void);\n#else\nstatic inline void apic_smt_update(void) { }\n#endif\n\nstruct msi_msg;\nstruct irq_cfg;\n\nextern void __irq_msi_compose_msg(struct irq_cfg *cfg, struct msi_msg *msg,\n\t\t\t\t  bool dmar);\n\nextern void ioapic_zap_locks(void);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}