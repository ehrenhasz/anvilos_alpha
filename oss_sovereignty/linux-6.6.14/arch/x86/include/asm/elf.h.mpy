{
  "module_name": "elf.h",
  "hash_id": "6590202415174af2e2911ddbf706f2a0f4c05f19001e40fdd2704e56ba58f213",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/elf.h",
  "human_readable_source": " \n#ifndef _ASM_X86_ELF_H\n#define _ASM_X86_ELF_H\n\n \n#include <linux/thread_info.h>\n\n#include <asm/ptrace.h>\n#include <asm/user.h>\n#include <asm/auxvec.h>\n#include <asm/fsgsbase.h>\n\ntypedef unsigned long elf_greg_t;\n\n#define ELF_NGREG (sizeof(struct user_regs_struct) / sizeof(elf_greg_t))\ntypedef elf_greg_t elf_gregset_t[ELF_NGREG];\n\ntypedef struct user_i387_struct elf_fpregset_t;\n\n#ifdef __i386__\n\n#define R_386_NONE\t0\n#define R_386_32\t1\n#define R_386_PC32\t2\n#define R_386_GOT32\t3\n#define R_386_PLT32\t4\n#define R_386_COPY\t5\n#define R_386_GLOB_DAT\t6\n#define R_386_JMP_SLOT\t7\n#define R_386_RELATIVE\t8\n#define R_386_GOTOFF\t9\n#define R_386_GOTPC\t10\n#define R_386_NUM\t11\n\n \n#define ELF_CLASS\tELFCLASS32\n#define ELF_DATA\tELFDATA2LSB\n#define ELF_ARCH\tEM_386\n\n#else\n\n \n#define R_X86_64_NONE\t\t0\t \n#define R_X86_64_64\t\t1\t \n#define R_X86_64_PC32\t\t2\t \n#define R_X86_64_GOT32\t\t3\t \n#define R_X86_64_PLT32\t\t4\t \n#define R_X86_64_COPY\t\t5\t \n#define R_X86_64_GLOB_DAT\t6\t \n#define R_X86_64_JUMP_SLOT\t7\t \n#define R_X86_64_RELATIVE\t8\t \n#define R_X86_64_GOTPCREL\t9\t \n#define R_X86_64_32\t\t10\t \n#define R_X86_64_32S\t\t11\t \n#define R_X86_64_16\t\t12\t \n#define R_X86_64_PC16\t\t13\t \n#define R_X86_64_8\t\t14\t \n#define R_X86_64_PC8\t\t15\t \n#define R_X86_64_PC64\t\t24\t \n\n \n#define ELF_CLASS\tELFCLASS64\n#define ELF_DATA\tELFDATA2LSB\n#define ELF_ARCH\tEM_X86_64\n\n#endif\n\n#include <asm/vdso.h>\n\n#ifdef CONFIG_X86_64\nextern unsigned int vdso64_enabled;\n#endif\n#if defined(CONFIG_X86_32) || defined(CONFIG_IA32_EMULATION)\nextern unsigned int vdso32_enabled;\n#endif\n\n \n#define elf_check_arch_ia32(x) \\\n\t(((x)->e_machine == EM_386) || ((x)->e_machine == EM_486))\n\n#include <asm/processor.h>\n\n#ifdef CONFIG_X86_32\n#include <asm/desc.h>\n\n#define elf_check_arch(x)\telf_check_arch_ia32(x)\n\n \n#define ELF_PLAT_INIT(_r, load_addr)\t\t\\\n\tdo {\t\t\t\t\t\\\n\t_r->bx = 0; _r->cx = 0; _r->dx = 0;\t\\\n\t_r->si = 0; _r->di = 0; _r->bp = 0;\t\\\n\t_r->ax = 0;\t\t\t\t\\\n} while (0)\n\n \n\n#define ELF_CORE_COPY_REGS(pr_reg, regs)\t\\\ndo {\t\t\t\t\t\t\\\n\tpr_reg[0] = regs->bx;\t\t\t\\\n\tpr_reg[1] = regs->cx;\t\t\t\\\n\tpr_reg[2] = regs->dx;\t\t\t\\\n\tpr_reg[3] = regs->si;\t\t\t\\\n\tpr_reg[4] = regs->di;\t\t\t\\\n\tpr_reg[5] = regs->bp;\t\t\t\\\n\tpr_reg[6] = regs->ax;\t\t\t\\\n\tpr_reg[7] = regs->ds;\t\t\t\\\n\tpr_reg[8] = regs->es;\t\t\t\\\n\tpr_reg[9] = regs->fs;\t\t\t\\\n\tsavesegment(gs, pr_reg[10]);\t\t\\\n\tpr_reg[11] = regs->orig_ax;\t\t\\\n\tpr_reg[12] = regs->ip;\t\t\t\\\n\tpr_reg[13] = regs->cs;\t\t\t\\\n\tpr_reg[14] = regs->flags;\t\t\\\n\tpr_reg[15] = regs->sp;\t\t\t\\\n\tpr_reg[16] = regs->ss;\t\t\t\\\n} while (0);\n\n#define ELF_PLATFORM\t(utsname()->machine)\n#define set_personality_64bit()\tdo { } while (0)\n\n#else  \n\n \n#define elf_check_arch(x)\t\t\t\\\n\t((x)->e_machine == EM_X86_64)\n\n#define compat_elf_check_arch(x)\t\t\t\t\t\\\n\t(elf_check_arch_ia32(x) ||\t\t\t\t\t\\\n\t (IS_ENABLED(CONFIG_X86_X32_ABI) && (x)->e_machine == EM_X86_64))\n\nstatic inline void elf_common_init(struct thread_struct *t,\n\t\t\t\t   struct pt_regs *regs, const u16 ds)\n{\n\t \n\t  regs->bx = regs->cx = regs->dx = 0;\n\tregs->si = regs->di = regs->bp = 0;\n\tregs->r8 = regs->r9 = regs->r10 = regs->r11 = 0;\n\tregs->r12 = regs->r13 = regs->r14 = regs->r15 = 0;\n\tt->fsbase = t->gsbase = 0;\n\tt->fsindex = t->gsindex = 0;\n\tt->ds = t->es = ds;\n}\n\n#define ELF_PLAT_INIT(_r, load_addr)\t\t\t\\\n\telf_common_init(&current->thread, _r, 0)\n\n#define\tCOMPAT_ELF_PLAT_INIT(regs, load_addr)\t\t\\\n\telf_common_init(&current->thread, regs, __USER_DS)\n\nvoid compat_start_thread(struct pt_regs *regs, u32 new_ip, u32 new_sp, bool x32);\n#define COMPAT_START_THREAD(ex, regs, new_ip, new_sp)\t\\\n\tcompat_start_thread(regs, new_ip, new_sp, ex->e_machine == EM_X86_64)\n\nvoid set_personality_ia32(bool);\n#define COMPAT_SET_PERSONALITY(ex)\t\t\t\\\n\tset_personality_ia32((ex).e_machine == EM_X86_64)\n\n#define COMPAT_ELF_PLATFORM\t\t\t(\"i686\")\n\n \n\n#define ELF_CORE_COPY_REGS(pr_reg, regs)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tunsigned v;\t\t\t\t\t\t\\\n\t(pr_reg)[0] = (regs)->r15;\t\t\t\t\\\n\t(pr_reg)[1] = (regs)->r14;\t\t\t\t\\\n\t(pr_reg)[2] = (regs)->r13;\t\t\t\t\\\n\t(pr_reg)[3] = (regs)->r12;\t\t\t\t\\\n\t(pr_reg)[4] = (regs)->bp;\t\t\t\t\\\n\t(pr_reg)[5] = (regs)->bx;\t\t\t\t\\\n\t(pr_reg)[6] = (regs)->r11;\t\t\t\t\\\n\t(pr_reg)[7] = (regs)->r10;\t\t\t\t\\\n\t(pr_reg)[8] = (regs)->r9;\t\t\t\t\\\n\t(pr_reg)[9] = (regs)->r8;\t\t\t\t\\\n\t(pr_reg)[10] = (regs)->ax;\t\t\t\t\\\n\t(pr_reg)[11] = (regs)->cx;\t\t\t\t\\\n\t(pr_reg)[12] = (regs)->dx;\t\t\t\t\\\n\t(pr_reg)[13] = (regs)->si;\t\t\t\t\\\n\t(pr_reg)[14] = (regs)->di;\t\t\t\t\\\n\t(pr_reg)[15] = (regs)->orig_ax;\t\t\t\t\\\n\t(pr_reg)[16] = (regs)->ip;\t\t\t\t\\\n\t(pr_reg)[17] = (regs)->cs;\t\t\t\t\\\n\t(pr_reg)[18] = (regs)->flags;\t\t\t\t\\\n\t(pr_reg)[19] = (regs)->sp;\t\t\t\t\\\n\t(pr_reg)[20] = (regs)->ss;\t\t\t\t\\\n\t(pr_reg)[21] = x86_fsbase_read_cpu();\t\t\t\\\n\t(pr_reg)[22] = x86_gsbase_read_cpu_inactive();\t\t\\\n\tasm(\"movl %%ds,%0\" : \"=r\" (v)); (pr_reg)[23] = v;\t\\\n\tasm(\"movl %%es,%0\" : \"=r\" (v)); (pr_reg)[24] = v;\t\\\n\tasm(\"movl %%fs,%0\" : \"=r\" (v)); (pr_reg)[25] = v;\t\\\n\tasm(\"movl %%gs,%0\" : \"=r\" (v)); (pr_reg)[26] = v;\t\\\n} while (0);\n\n \n#define ELF_PLATFORM       (\"x86_64\")\nextern void set_personality_64bit(void);\nextern int force_personality32;\n\n#endif  \n\n#define CORE_DUMP_USE_REGSET\n#define ELF_EXEC_PAGESIZE\t4096\n\n \n#define ELF_ET_DYN_BASE\t\t(mmap_is_ia32() ? 0x000400000UL : \\\n\t\t\t\t\t\t  (DEFAULT_MAP_WINDOW / 3 * 2))\n\n \n\n#define ELF_HWCAP\t\t(boot_cpu_data.x86_capability[CPUID_1_EDX])\n\nextern u32 elf_hwcap2;\n\n \n#define ELF_HWCAP2\t\t(elf_hwcap2)\n\n \n\n#define SET_PERSONALITY(ex) set_personality_64bit()\n\n \n#define elf_read_implies_exec(ex, executable_stack)\t\\\n\t(mmap_is_ia32() && executable_stack == EXSTACK_DEFAULT)\n\nstruct task_struct;\n\n#define\tARCH_DLINFO_IA32\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (VDSO_CURRENT_BASE) {\t\t\t\t\t\\\n\t\tNEW_AUX_ENT(AT_SYSINFO,\tVDSO_ENTRY);\t\t\t\\\n\t\tNEW_AUX_ENT(AT_SYSINFO_EHDR, VDSO_CURRENT_BASE);\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tNEW_AUX_ENT(AT_MINSIGSTKSZ, get_sigframe_size());\t\t\\\n} while (0)\n\n \nstatic inline int mmap_is_ia32(void)\n{\n\treturn IS_ENABLED(CONFIG_X86_32) ||\n\t       (IS_ENABLED(CONFIG_COMPAT) &&\n\t\ttest_thread_flag(TIF_ADDR32));\n}\n\nextern unsigned long task_size_32bit(void);\nextern unsigned long task_size_64bit(int full_addr_space);\nextern unsigned long get_mmap_base(int is_legacy);\nextern bool mmap_address_hint_valid(unsigned long addr, unsigned long len);\nextern unsigned long get_sigframe_size(void);\n\n#ifdef CONFIG_X86_32\n\n#define __STACK_RND_MASK(is32bit) (0x7ff)\n#define STACK_RND_MASK (0x7ff)\n\n#define ARCH_DLINFO\t\tARCH_DLINFO_IA32\n\n \n\n#else  \n\n \n#define __STACK_RND_MASK(is32bit) ((is32bit) ? 0x7ff : 0x3fffff)\n#define STACK_RND_MASK __STACK_RND_MASK(mmap_is_ia32())\n\n#define ARCH_DLINFO\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (vdso64_enabled)\t\t\t\t\t\t\\\n\t\tNEW_AUX_ENT(AT_SYSINFO_EHDR,\t\t\t\t\\\n\t\t\t    (unsigned long __force)current->mm->context.vdso); \\\n\tNEW_AUX_ENT(AT_MINSIGSTKSZ, get_sigframe_size());\t\t\\\n} while (0)\n\n \n#define ARCH_DLINFO_X32\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (vdso64_enabled)\t\t\t\t\t\t\\\n\t\tNEW_AUX_ENT(AT_SYSINFO_EHDR,\t\t\t\t\\\n\t\t\t    (unsigned long __force)current->mm->context.vdso); \\\n\tNEW_AUX_ENT(AT_MINSIGSTKSZ, get_sigframe_size());\t\t\\\n} while (0)\n\n#define AT_SYSINFO\t\t32\n\n#define COMPAT_ARCH_DLINFO\t\t\t\t\t\t\\\nif (exec->e_machine == EM_X86_64)\t\t\t\t\t\\\n\tARCH_DLINFO_X32;\t\t\t\t\t\t\\\nelse if (IS_ENABLED(CONFIG_IA32_EMULATION))\t\t\t\t\\\n\tARCH_DLINFO_IA32\n\n#define COMPAT_ELF_ET_DYN_BASE\t(TASK_UNMAPPED_BASE + 0x1000000)\n\n#endif  \n\n#define VDSO_CURRENT_BASE\t((unsigned long)current->mm->context.vdso)\n\n#define VDSO_ENTRY\t\t\t\t\t\t\t\\\n\t((unsigned long)current->mm->context.vdso +\t\t\t\\\n\t vdso_image_32.sym___kernel_vsyscall)\n\nstruct linux_binprm;\n\n#define ARCH_HAS_SETUP_ADDITIONAL_PAGES 1\nextern int arch_setup_additional_pages(struct linux_binprm *bprm,\n\t\t\t\t       int uses_interp);\nextern int compat_arch_setup_additional_pages(struct linux_binprm *bprm,\n\t\t\t\t\t      int uses_interp, bool x32);\n#define COMPAT_ARCH_SETUP_ADDITIONAL_PAGES(bprm, ex, interpreter)\t\\\n\tcompat_arch_setup_additional_pages(bprm, interpreter,\t\t\\\n\t\t\t\t\t   (ex->e_machine == EM_X86_64))\n\nextern bool arch_syscall_is_vdso_sigreturn(struct pt_regs *regs);\n\n \nenum align_flags {\n\tALIGN_VA_32\t= BIT(0),\n\tALIGN_VA_64\t= BIT(1),\n};\n\nstruct va_alignment {\n\tint flags;\n\tunsigned long mask;\n\tunsigned long bits;\n} ____cacheline_aligned;\n\nextern struct va_alignment va_align;\nextern unsigned long align_vdso_addr(unsigned long);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}