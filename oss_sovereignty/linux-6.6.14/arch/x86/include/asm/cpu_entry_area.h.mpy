{
  "module_name": "cpu_entry_area.h",
  "hash_id": "379eddbbd7a5ee21ced6622213b3718da2f3ca49455bc5f0e1d254069c2bada5",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/cpu_entry_area.h",
  "human_readable_source": " \n\n#ifndef _ASM_X86_CPU_ENTRY_AREA_H\n#define _ASM_X86_CPU_ENTRY_AREA_H\n\n#include <linux/percpu-defs.h>\n#include <asm/processor.h>\n#include <asm/intel_ds.h>\n#include <asm/pgtable_areas.h>\n\n#ifdef CONFIG_X86_64\n\n#ifdef CONFIG_AMD_MEM_ENCRYPT\n#define VC_EXCEPTION_STKSZ\tEXCEPTION_STKSZ\n#else\n#define VC_EXCEPTION_STKSZ\t0\n#endif\n\n \n#define ESTACKS_MEMBERS(guardsize, optional_stack_size)\t\t\\\n\tchar\tDF_stack_guard[guardsize];\t\t\t\\\n\tchar\tDF_stack[EXCEPTION_STKSZ];\t\t\t\\\n\tchar\tNMI_stack_guard[guardsize];\t\t\t\\\n\tchar\tNMI_stack[EXCEPTION_STKSZ];\t\t\t\\\n\tchar\tDB_stack_guard[guardsize];\t\t\t\\\n\tchar\tDB_stack[EXCEPTION_STKSZ];\t\t\t\\\n\tchar\tMCE_stack_guard[guardsize];\t\t\t\\\n\tchar\tMCE_stack[EXCEPTION_STKSZ];\t\t\t\\\n\tchar\tVC_stack_guard[guardsize];\t\t\t\\\n\tchar\tVC_stack[optional_stack_size];\t\t\t\\\n\tchar\tVC2_stack_guard[guardsize];\t\t\t\\\n\tchar\tVC2_stack[optional_stack_size];\t\t\t\\\n\tchar\tIST_top_guard[guardsize];\t\t\t\\\n\n \nstruct exception_stacks {\n\tESTACKS_MEMBERS(0, VC_EXCEPTION_STKSZ)\n};\n\n \nstruct cea_exception_stacks {\n\tESTACKS_MEMBERS(PAGE_SIZE, EXCEPTION_STKSZ)\n};\n\n \nenum exception_stack_ordering {\n\tESTACK_DF,\n\tESTACK_NMI,\n\tESTACK_DB,\n\tESTACK_MCE,\n\tESTACK_VC,\n\tESTACK_VC2,\n\tN_EXCEPTION_STACKS\n};\n\n#define CEA_ESTACK_SIZE(st)\t\t\t\t\t\\\n\tsizeof(((struct cea_exception_stacks *)0)->st## _stack)\n\n#define CEA_ESTACK_BOT(ceastp, st)\t\t\t\t\\\n\t((unsigned long)&(ceastp)->st## _stack)\n\n#define CEA_ESTACK_TOP(ceastp, st)\t\t\t\t\\\n\t(CEA_ESTACK_BOT(ceastp, st) + CEA_ESTACK_SIZE(st))\n\n#define CEA_ESTACK_OFFS(st)\t\t\t\t\t\\\n\toffsetof(struct cea_exception_stacks, st## _stack)\n\n#define CEA_ESTACK_PAGES\t\t\t\t\t\\\n\t(sizeof(struct cea_exception_stacks) / PAGE_SIZE)\n\n#endif\n\n#ifdef CONFIG_X86_32\nstruct doublefault_stack {\n\tunsigned long stack[(PAGE_SIZE - sizeof(struct x86_hw_tss)) / sizeof(unsigned long)];\n\tstruct x86_hw_tss tss;\n} __aligned(PAGE_SIZE);\n#endif\n\n \nstruct cpu_entry_area {\n\tchar gdt[PAGE_SIZE];\n\n\t \n#ifdef CONFIG_X86_32\n\tchar guard_entry_stack[PAGE_SIZE];\n#endif\n\tstruct entry_stack_page entry_stack_page;\n\n#ifdef CONFIG_X86_32\n\tchar guard_doublefault_stack[PAGE_SIZE];\n\tstruct doublefault_stack doublefault_stack;\n#endif\n\n\t \n\tstruct tss_struct tss;\n\n#ifdef CONFIG_X86_64\n\t \n\tstruct cea_exception_stacks estacks;\n#endif\n\t \n\tstruct debug_store cpu_debug_store;\n\t \n\tstruct debug_store_buffers cpu_debug_buffers;\n};\n\n#define CPU_ENTRY_AREA_SIZE\t\t(sizeof(struct cpu_entry_area))\n\nDECLARE_PER_CPU(struct cpu_entry_area *, cpu_entry_area);\nDECLARE_PER_CPU(struct cea_exception_stacks *, cea_exception_stacks);\n\nextern void setup_cpu_entry_areas(void);\nextern void cea_set_pte(void *cea_vaddr, phys_addr_t pa, pgprot_t flags);\n\nextern struct cpu_entry_area *get_cpu_entry_area(int cpu);\n\nstatic __always_inline struct entry_stack *cpu_entry_stack(int cpu)\n{\n\treturn &get_cpu_entry_area(cpu)->entry_stack_page.stack;\n}\n\n#define __this_cpu_ist_top_va(name)\t\t\t\t\t\\\n\tCEA_ESTACK_TOP(__this_cpu_read(cea_exception_stacks), name)\n\n#define __this_cpu_ist_bottom_va(name)\t\t\t\t\t\\\n\tCEA_ESTACK_BOT(__this_cpu_read(cea_exception_stacks), name)\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}