{
  "module_name": "api.h",
  "hash_id": "27c08b1bb0e8c6c26272a2607b0b3b2ded80ca71c765b7b46b770f108cf2004d",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/fpu/api.h",
  "human_readable_source": " \n \n\n#ifndef _ASM_X86_FPU_API_H\n#define _ASM_X86_FPU_API_H\n#include <linux/bottom_half.h>\n\n#include <asm/fpu/types.h>\n\n \n\n \n#define KFPU_387\t_BITUL(0)\t \n#define KFPU_MXCSR\t_BITUL(1)\t \n\nextern void kernel_fpu_begin_mask(unsigned int kfpu_mask);\nextern void kernel_fpu_end(void);\nextern bool irq_fpu_usable(void);\nextern void fpregs_mark_activate(void);\n\n \nstatic inline void kernel_fpu_begin(void)\n{\n#ifdef CONFIG_X86_64\n\t \n\tkernel_fpu_begin_mask(KFPU_MXCSR);\n#else\n\t \n\tkernel_fpu_begin_mask(KFPU_387 | KFPU_MXCSR);\n#endif\n}\n\n \nstatic inline void fpregs_lock(void)\n{\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tlocal_bh_disable();\n\telse\n\t\tpreempt_disable();\n}\n\nstatic inline void fpregs_unlock(void)\n{\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tlocal_bh_enable();\n\telse\n\t\tpreempt_enable();\n}\n\n \nvoid fpregs_lock_and_load(void);\n\n#ifdef CONFIG_X86_DEBUG_FPU\nextern void fpregs_assert_state_consistent(void);\n#else\nstatic inline void fpregs_assert_state_consistent(void) { }\n#endif\n\n \nextern void switch_fpu_return(void);\n\n \nextern int cpu_has_xfeatures(u64 xfeatures_mask, const char **feature_name);\n\n \nextern int  fpu__exception_code(struct fpu *fpu, int trap_nr);\nextern void fpu_sync_fpstate(struct fpu *fpu);\nextern void fpu_reset_from_exception_fixup(void);\n\n \nextern void fpu__init_cpu(void);\nextern void fpu__init_system(void);\nextern void fpu__init_check_bugs(void);\nextern void fpu__resume_cpu(void);\n\n#ifdef CONFIG_MATH_EMULATION\nextern void fpstate_init_soft(struct swregs_state *soft);\n#else\nstatic inline void fpstate_init_soft(struct swregs_state *soft) {}\n#endif\n\n \nDECLARE_PER_CPU(struct fpu *, fpu_fpregs_owner_ctx);\n\n \n#ifdef CONFIG_X86_64\nextern void fpstate_free(struct fpu *fpu);\n#else\nstatic inline void fpstate_free(struct fpu *fpu) { }\n#endif\n\n \nextern void fpstate_clear_xstate_component(struct fpstate *fps, unsigned int xfeature);\n\nextern u64 xstate_get_guest_group_perm(void);\n\n \nextern bool fpu_alloc_guest_fpstate(struct fpu_guest *gfpu);\nextern void fpu_free_guest_fpstate(struct fpu_guest *gfpu);\nextern int fpu_swap_kvm_fpstate(struct fpu_guest *gfpu, bool enter_guest);\nextern int fpu_enable_guest_xfd_features(struct fpu_guest *guest_fpu, u64 xfeatures);\n\n#ifdef CONFIG_X86_64\nextern void fpu_update_guest_xfd(struct fpu_guest *guest_fpu, u64 xfd);\nextern void fpu_sync_guest_vmexit_xfd_state(void);\n#else\nstatic inline void fpu_update_guest_xfd(struct fpu_guest *guest_fpu, u64 xfd) { }\nstatic inline void fpu_sync_guest_vmexit_xfd_state(void) { }\n#endif\n\nextern void fpu_copy_guest_fpstate_to_uabi(struct fpu_guest *gfpu, void *buf,\n\t\t\t\t\t   unsigned int size, u64 xfeatures, u32 pkru);\nextern int fpu_copy_uabi_to_guest_fpstate(struct fpu_guest *gfpu, const void *buf, u64 xcr0, u32 *vpkru);\n\nstatic inline void fpstate_set_confidential(struct fpu_guest *gfpu)\n{\n\tgfpu->fpstate->is_confidential = true;\n}\n\nstatic inline bool fpstate_is_confidential(struct fpu_guest *gfpu)\n{\n\treturn gfpu->fpstate->is_confidential;\n}\n\n \nextern long fpu_xstate_prctl(int option, unsigned long arg2);\n\nextern void fpu_idle_fpregs(void);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}