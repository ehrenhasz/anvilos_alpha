{
  "module_name": "pvclock.h",
  "hash_id": "312a398af870fc2f40b6a79b18a154464ea7657daa0e2d8e0187ef6ae3fa065a",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/pvclock.h",
  "human_readable_source": " \n#ifndef _ASM_X86_PVCLOCK_H\n#define _ASM_X86_PVCLOCK_H\n\n#include <asm/clocksource.h>\n#include <asm/pvclock-abi.h>\n\n \nu64 pvclock_clocksource_read(struct pvclock_vcpu_time_info *src);\nu64 pvclock_clocksource_read_nowd(struct pvclock_vcpu_time_info *src);\nu8 pvclock_read_flags(struct pvclock_vcpu_time_info *src);\nvoid pvclock_set_flags(u8 flags);\nunsigned long pvclock_tsc_khz(struct pvclock_vcpu_time_info *src);\nvoid pvclock_read_wallclock(struct pvclock_wall_clock *wall,\n\t\t\t    struct pvclock_vcpu_time_info *vcpu,\n\t\t\t    struct timespec64 *ts);\nvoid pvclock_resume(void);\n\nvoid pvclock_touch_watchdogs(void);\n\nstatic __always_inline\nunsigned pvclock_read_begin(const struct pvclock_vcpu_time_info *src)\n{\n\tunsigned version = src->version & ~1;\n\t \n\tvirt_rmb();\n\treturn version;\n}\n\nstatic __always_inline\nbool pvclock_read_retry(const struct pvclock_vcpu_time_info *src,\n\t\t\tunsigned version)\n{\n\t \n\tvirt_rmb();\n\treturn unlikely(version != src->version);\n}\n\n \nstatic __always_inline u64 pvclock_scale_delta(u64 delta, u32 mul_frac, int shift)\n{\n\tu64 product;\n#ifdef __i386__\n\tu32 tmp1, tmp2;\n#else\n\tulong tmp;\n#endif\n\n\tif (shift < 0)\n\t\tdelta >>= -shift;\n\telse\n\t\tdelta <<= shift;\n\n#ifdef __i386__\n\t__asm__ (\n\t\t\"mul  %5       ; \"\n\t\t\"mov  %4,%%eax ; \"\n\t\t\"mov  %%edx,%4 ; \"\n\t\t\"mul  %5       ; \"\n\t\t\"xor  %5,%5    ; \"\n\t\t\"add  %4,%%eax ; \"\n\t\t\"adc  %5,%%edx ; \"\n\t\t: \"=A\" (product), \"=r\" (tmp1), \"=r\" (tmp2)\n\t\t: \"a\" ((u32)delta), \"1\" ((u32)(delta >> 32)), \"2\" (mul_frac) );\n#elif defined(__x86_64__)\n\t__asm__ (\n\t\t\"mulq %[mul_frac] ; shrd $32, %[hi], %[lo]\"\n\t\t: [lo]\"=a\"(product),\n\t\t  [hi]\"=d\"(tmp)\n\t\t: \"0\"(delta),\n\t\t  [mul_frac]\"rm\"((u64)mul_frac));\n#else\n#error implement me!\n#endif\n\n\treturn product;\n}\n\nstatic __always_inline\nu64 __pvclock_read_cycles(const struct pvclock_vcpu_time_info *src, u64 tsc)\n{\n\tu64 delta = tsc - src->tsc_timestamp;\n\tu64 offset = pvclock_scale_delta(delta, src->tsc_to_system_mul,\n\t\t\t\t\t     src->tsc_shift);\n\treturn src->system_time + offset;\n}\n\nstruct pvclock_vsyscall_time_info {\n\tstruct pvclock_vcpu_time_info pvti;\n} __attribute__((__aligned__(SMP_CACHE_BYTES)));\n\n#define PVTI_SIZE sizeof(struct pvclock_vsyscall_time_info)\n\n#ifdef CONFIG_PARAVIRT_CLOCK\nvoid pvclock_set_pvti_cpu0_va(struct pvclock_vsyscall_time_info *pvti);\nstruct pvclock_vsyscall_time_info *pvclock_get_pvti_cpu0_va(void);\n#else\nstatic inline struct pvclock_vsyscall_time_info *pvclock_get_pvti_cpu0_va(void)\n{\n\treturn NULL;\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}