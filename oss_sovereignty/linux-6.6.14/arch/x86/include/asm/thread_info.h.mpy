{
  "module_name": "thread_info.h",
  "hash_id": "18ccfa1b8dd24a619f047f0bfac089da321c9746c0b500d0cf8df9dc9a662d23",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/thread_info.h",
  "human_readable_source": " \n \n\n#ifndef _ASM_X86_THREAD_INFO_H\n#define _ASM_X86_THREAD_INFO_H\n\n#include <linux/compiler.h>\n#include <asm/page.h>\n#include <asm/percpu.h>\n#include <asm/types.h>\n\n \n#ifdef CONFIG_X86_32\n# ifdef CONFIG_VM86\n#  define TOP_OF_KERNEL_STACK_PADDING 16\n# else\n#  define TOP_OF_KERNEL_STACK_PADDING 8\n# endif\n#else\n# define TOP_OF_KERNEL_STACK_PADDING 0\n#endif\n\n \n#ifndef __ASSEMBLY__\nstruct task_struct;\n#include <asm/cpufeature.h>\n#include <linux/atomic.h>\n\nstruct thread_info {\n\tunsigned long\t\tflags;\t\t \n\tunsigned long\t\tsyscall_work;\t \n\tu32\t\t\tstatus;\t\t \n#ifdef CONFIG_SMP\n\tu32\t\t\tcpu;\t\t \n#endif\n};\n\n#define INIT_THREAD_INFO(tsk)\t\t\t\\\n{\t\t\t\t\t\t\\\n\t.flags\t\t= 0,\t\t\t\\\n}\n\n#else  \n\n#include <asm/asm-offsets.h>\n\n#endif\n\n \n#define TIF_NOTIFY_RESUME\t1\t \n#define TIF_SIGPENDING\t\t2\t \n#define TIF_NEED_RESCHED\t3\t \n#define TIF_SINGLESTEP\t\t4\t \n#define TIF_SSBD\t\t5\t \n#define TIF_SPEC_IB\t\t9\t \n#define TIF_SPEC_L1D_FLUSH\t10\t \n#define TIF_USER_RETURN_NOTIFY\t11\t \n#define TIF_UPROBE\t\t12\t \n#define TIF_PATCH_PENDING\t13\t \n#define TIF_NEED_FPU_LOAD\t14\t \n#define TIF_NOCPUID\t\t15\t \n#define TIF_NOTSC\t\t16\t \n#define TIF_NOTIFY_SIGNAL\t17\t \n#define TIF_MEMDIE\t\t20\t \n#define TIF_POLLING_NRFLAG\t21\t \n#define TIF_IO_BITMAP\t\t22\t \n#define TIF_SPEC_FORCE_UPDATE\t23\t \n#define TIF_FORCED_TF\t\t24\t \n#define TIF_BLOCKSTEP\t\t25\t \n#define TIF_LAZY_MMU_UPDATES\t27\t \n#define TIF_ADDR32\t\t29\t \n\n#define _TIF_NOTIFY_RESUME\t(1 << TIF_NOTIFY_RESUME)\n#define _TIF_SIGPENDING\t\t(1 << TIF_SIGPENDING)\n#define _TIF_NEED_RESCHED\t(1 << TIF_NEED_RESCHED)\n#define _TIF_SINGLESTEP\t\t(1 << TIF_SINGLESTEP)\n#define _TIF_SSBD\t\t(1 << TIF_SSBD)\n#define _TIF_SPEC_IB\t\t(1 << TIF_SPEC_IB)\n#define _TIF_SPEC_L1D_FLUSH\t(1 << TIF_SPEC_L1D_FLUSH)\n#define _TIF_USER_RETURN_NOTIFY\t(1 << TIF_USER_RETURN_NOTIFY)\n#define _TIF_UPROBE\t\t(1 << TIF_UPROBE)\n#define _TIF_PATCH_PENDING\t(1 << TIF_PATCH_PENDING)\n#define _TIF_NEED_FPU_LOAD\t(1 << TIF_NEED_FPU_LOAD)\n#define _TIF_NOCPUID\t\t(1 << TIF_NOCPUID)\n#define _TIF_NOTSC\t\t(1 << TIF_NOTSC)\n#define _TIF_NOTIFY_SIGNAL\t(1 << TIF_NOTIFY_SIGNAL)\n#define _TIF_POLLING_NRFLAG\t(1 << TIF_POLLING_NRFLAG)\n#define _TIF_IO_BITMAP\t\t(1 << TIF_IO_BITMAP)\n#define _TIF_SPEC_FORCE_UPDATE\t(1 << TIF_SPEC_FORCE_UPDATE)\n#define _TIF_FORCED_TF\t\t(1 << TIF_FORCED_TF)\n#define _TIF_BLOCKSTEP\t\t(1 << TIF_BLOCKSTEP)\n#define _TIF_LAZY_MMU_UPDATES\t(1 << TIF_LAZY_MMU_UPDATES)\n#define _TIF_ADDR32\t\t(1 << TIF_ADDR32)\n\n \n#define _TIF_WORK_CTXSW_BASE\t\t\t\t\t\\\n\t(_TIF_NOCPUID | _TIF_NOTSC | _TIF_BLOCKSTEP |\t\t\\\n\t _TIF_SSBD | _TIF_SPEC_FORCE_UPDATE)\n\n \n#ifdef CONFIG_SMP\n# define _TIF_WORK_CTXSW\t(_TIF_WORK_CTXSW_BASE | _TIF_SPEC_IB)\n#else\n# define _TIF_WORK_CTXSW\t(_TIF_WORK_CTXSW_BASE)\n#endif\n\n#ifdef CONFIG_X86_IOPL_IOPERM\n# define _TIF_WORK_CTXSW_PREV\t(_TIF_WORK_CTXSW| _TIF_USER_RETURN_NOTIFY | \\\n\t\t\t\t _TIF_IO_BITMAP)\n#else\n# define _TIF_WORK_CTXSW_PREV\t(_TIF_WORK_CTXSW| _TIF_USER_RETURN_NOTIFY)\n#endif\n\n#define _TIF_WORK_CTXSW_NEXT\t(_TIF_WORK_CTXSW)\n\n#define STACK_WARN\t\t(THREAD_SIZE/8)\n\n \n#ifndef __ASSEMBLY__\n\n \n__no_kmsan_checks\nstatic inline int arch_within_stack_frames(const void * const stack,\n\t\t\t\t\t   const void * const stackend,\n\t\t\t\t\t   const void *obj, unsigned long len)\n{\n#if defined(CONFIG_FRAME_POINTER)\n\tconst void *frame = NULL;\n\tconst void *oldframe;\n\n\toldframe = __builtin_frame_address(1);\n\tif (oldframe)\n\t\tframe = __builtin_frame_address(2);\n\t \n\twhile (stack <= frame && frame < stackend) {\n\t\t \n\t\tif (obj + len <= frame)\n\t\t\treturn obj >= oldframe + 2 * sizeof(void *) ?\n\t\t\t\tGOOD_FRAME : BAD_STACK;\n\t\toldframe = frame;\n\t\tframe = *(const void * const *)frame;\n\t}\n\treturn BAD_STACK;\n#else\n\treturn NOT_STACK;\n#endif\n}\n\n#endif   \n\n \n#define TS_COMPAT\t\t0x0002\t \n\n#ifndef __ASSEMBLY__\n#ifdef CONFIG_COMPAT\n#define TS_I386_REGS_POKED\t0x0004\t \n\n#define arch_set_restart_data(restart)\t\\\n\tdo { restart->arch_data = current_thread_info()->status; } while (0)\n\n#endif\n\n#ifdef CONFIG_X86_32\n#define in_ia32_syscall() true\n#else\n#define in_ia32_syscall() (IS_ENABLED(CONFIG_IA32_EMULATION) && \\\n\t\t\t   current_thread_info()->status & TS_COMPAT)\n#endif\n\nextern void arch_setup_new_exec(void);\n#define arch_setup_new_exec arch_setup_new_exec\n#endif\t \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}