{
  "module_name": "pgtable_64.h",
  "hash_id": "b87e86150f2cf09a786ea113169680f7070dc52651beeceadd3d08cb571422ce",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/pgtable_64.h",
  "human_readable_source": " \n#ifndef _ASM_X86_PGTABLE_64_H\n#define _ASM_X86_PGTABLE_64_H\n\n#include <linux/const.h>\n#include <asm/pgtable_64_types.h>\n\n#ifndef __ASSEMBLY__\n\n \n#include <asm/processor.h>\n#include <linux/bitops.h>\n#include <linux/threads.h>\n#include <asm/fixmap.h>\n\nextern p4d_t level4_kernel_pgt[512];\nextern p4d_t level4_ident_pgt[512];\nextern pud_t level3_kernel_pgt[512];\nextern pud_t level3_ident_pgt[512];\nextern pmd_t level2_kernel_pgt[512];\nextern pmd_t level2_fixmap_pgt[512];\nextern pmd_t level2_ident_pgt[512];\nextern pte_t level1_fixmap_pgt[512 * FIXMAP_PMD_NUM];\nextern pgd_t init_top_pgt[];\n\n#define swapper_pg_dir init_top_pgt\n\nextern void paging_init(void);\nstatic inline void sync_initial_page_table(void) { }\n\n#define pte_ERROR(e)\t\t\t\t\t\\\n\tpr_err(\"%s:%d: bad pte %p(%016lx)\\n\",\t\t\\\n\t       __FILE__, __LINE__, &(e), pte_val(e))\n#define pmd_ERROR(e)\t\t\t\t\t\\\n\tpr_err(\"%s:%d: bad pmd %p(%016lx)\\n\",\t\t\\\n\t       __FILE__, __LINE__, &(e), pmd_val(e))\n#define pud_ERROR(e)\t\t\t\t\t\\\n\tpr_err(\"%s:%d: bad pud %p(%016lx)\\n\",\t\t\\\n\t       __FILE__, __LINE__, &(e), pud_val(e))\n\n#if CONFIG_PGTABLE_LEVELS >= 5\n#define p4d_ERROR(e)\t\t\t\t\t\\\n\tpr_err(\"%s:%d: bad p4d %p(%016lx)\\n\",\t\t\\\n\t       __FILE__, __LINE__, &(e), p4d_val(e))\n#endif\n\n#define pgd_ERROR(e)\t\t\t\t\t\\\n\tpr_err(\"%s:%d: bad pgd %p(%016lx)\\n\",\t\t\\\n\t       __FILE__, __LINE__, &(e), pgd_val(e))\n\nstruct mm_struct;\n\n#define mm_p4d_folded mm_p4d_folded\nstatic inline bool mm_p4d_folded(struct mm_struct *mm)\n{\n\treturn !pgtable_l5_enabled();\n}\n\nvoid set_pte_vaddr_p4d(p4d_t *p4d_page, unsigned long vaddr, pte_t new_pte);\nvoid set_pte_vaddr_pud(pud_t *pud_page, unsigned long vaddr, pte_t new_pte);\n\nstatic inline void native_set_pte(pte_t *ptep, pte_t pte)\n{\n\tWRITE_ONCE(*ptep, pte);\n}\n\nstatic inline void native_pte_clear(struct mm_struct *mm, unsigned long addr,\n\t\t\t\t    pte_t *ptep)\n{\n\tnative_set_pte(ptep, native_make_pte(0));\n}\n\nstatic inline void native_set_pte_atomic(pte_t *ptep, pte_t pte)\n{\n\tnative_set_pte(ptep, pte);\n}\n\nstatic inline void native_set_pmd(pmd_t *pmdp, pmd_t pmd)\n{\n\tWRITE_ONCE(*pmdp, pmd);\n}\n\nstatic inline void native_pmd_clear(pmd_t *pmd)\n{\n\tnative_set_pmd(pmd, native_make_pmd(0));\n}\n\nstatic inline pte_t native_ptep_get_and_clear(pte_t *xp)\n{\n#ifdef CONFIG_SMP\n\treturn native_make_pte(xchg(&xp->pte, 0));\n#else\n\t \n\tpte_t ret = *xp;\n\tnative_pte_clear(NULL, 0, xp);\n\treturn ret;\n#endif\n}\n\nstatic inline pmd_t native_pmdp_get_and_clear(pmd_t *xp)\n{\n#ifdef CONFIG_SMP\n\treturn native_make_pmd(xchg(&xp->pmd, 0));\n#else\n\t \n\tpmd_t ret = *xp;\n\tnative_pmd_clear(xp);\n\treturn ret;\n#endif\n}\n\nstatic inline void native_set_pud(pud_t *pudp, pud_t pud)\n{\n\tWRITE_ONCE(*pudp, pud);\n}\n\nstatic inline void native_pud_clear(pud_t *pud)\n{\n\tnative_set_pud(pud, native_make_pud(0));\n}\n\nstatic inline pud_t native_pudp_get_and_clear(pud_t *xp)\n{\n#ifdef CONFIG_SMP\n\treturn native_make_pud(xchg(&xp->pud, 0));\n#else\n\t \n\tpud_t ret = *xp;\n\n\tnative_pud_clear(xp);\n\treturn ret;\n#endif\n}\n\nstatic inline void native_set_p4d(p4d_t *p4dp, p4d_t p4d)\n{\n\tpgd_t pgd;\n\n\tif (pgtable_l5_enabled() || !IS_ENABLED(CONFIG_PAGE_TABLE_ISOLATION)) {\n\t\tWRITE_ONCE(*p4dp, p4d);\n\t\treturn;\n\t}\n\n\tpgd = native_make_pgd(native_p4d_val(p4d));\n\tpgd = pti_set_user_pgtbl((pgd_t *)p4dp, pgd);\n\tWRITE_ONCE(*p4dp, native_make_p4d(native_pgd_val(pgd)));\n}\n\nstatic inline void native_p4d_clear(p4d_t *p4d)\n{\n\tnative_set_p4d(p4d, native_make_p4d(0));\n}\n\nstatic inline void native_set_pgd(pgd_t *pgdp, pgd_t pgd)\n{\n\tWRITE_ONCE(*pgdp, pti_set_user_pgtbl(pgdp, pgd));\n}\n\nstatic inline void native_pgd_clear(pgd_t *pgd)\n{\n\tnative_set_pgd(pgd, native_make_pgd(0));\n}\n\n \n\n \n\n \n\n \n\n \n\n \n#define SWP_TYPE_BITS\t\t5\n\n#define SWP_OFFSET_FIRST_BIT\t(_PAGE_BIT_PROTNONE + 1)\n\n \n#define SWP_OFFSET_SHIFT\t(SWP_OFFSET_FIRST_BIT+SWP_TYPE_BITS)\n\n#define MAX_SWAPFILES_CHECK() BUILD_BUG_ON(MAX_SWAPFILES_SHIFT > SWP_TYPE_BITS)\n\n \n#define __swp_type(x) ((x).val >> (64 - SWP_TYPE_BITS))\n\n \n#define __swp_offset(x) (~(x).val << SWP_TYPE_BITS >> SWP_OFFSET_SHIFT)\n\n \n#define __swp_entry(type, offset) ((swp_entry_t) { \\\n\t(~(unsigned long)(offset) << SWP_OFFSET_SHIFT >> SWP_TYPE_BITS) \\\n\t| ((unsigned long)(type) << (64-SWP_TYPE_BITS)) })\n\n#define __pte_to_swp_entry(pte)\t\t((swp_entry_t) { pte_val((pte)) })\n#define __pmd_to_swp_entry(pmd)\t\t((swp_entry_t) { pmd_val((pmd)) })\n#define __swp_entry_to_pte(x)\t\t(__pte((x).val))\n#define __swp_entry_to_pmd(x)\t\t(__pmd((x).val))\n\nextern void cleanup_highmap(void);\n\n#define HAVE_ARCH_UNMAPPED_AREA\n#define HAVE_ARCH_UNMAPPED_AREA_TOPDOWN\n\n#define PAGE_AGP    PAGE_KERNEL_NOCACHE\n#define HAVE_PAGE_AGP 1\n\n \n#define\tkc_vaddr_to_offset(v) ((v) & __VIRTUAL_MASK)\n#define\tkc_offset_to_vaddr(o) ((o) | ~__VIRTUAL_MASK)\n\n#define __HAVE_ARCH_PTE_SAME\n\n#define vmemmap ((struct page *)VMEMMAP_START)\n\nextern void init_extra_mapping_uc(unsigned long phys, unsigned long size);\nextern void init_extra_mapping_wb(unsigned long phys, unsigned long size);\n\n#define gup_fast_permitted gup_fast_permitted\nstatic inline bool gup_fast_permitted(unsigned long start, unsigned long end)\n{\n\tif (end >> __VIRTUAL_MASK_SHIFT)\n\t\treturn false;\n\treturn true;\n}\n\n#include <asm/pgtable-invert.h>\n\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}