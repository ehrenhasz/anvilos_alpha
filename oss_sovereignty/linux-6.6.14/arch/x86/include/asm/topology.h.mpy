{
  "module_name": "topology.h",
  "hash_id": "2284a39713b42f97186f82d18c7f46880dc8dd508ab34dc3585705ed772ea7fb",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/topology.h",
  "human_readable_source": " \n#ifndef _ASM_X86_TOPOLOGY_H\n#define _ASM_X86_TOPOLOGY_H\n\n \n#include <linux/numa.h>\n#include <linux/cpumask.h>\n\n#ifdef CONFIG_NUMA\n\n#include <asm/mpspec.h>\n#include <asm/percpu.h>\n\n \nDECLARE_EARLY_PER_CPU(int, x86_cpu_to_node_map);\n\n#ifdef CONFIG_DEBUG_PER_CPU_MAPS\n \nextern int __cpu_to_node(int cpu);\n#define cpu_to_node __cpu_to_node\n\nextern int early_cpu_to_node(int cpu);\n\n#else\t \n\n \nstatic inline int early_cpu_to_node(int cpu)\n{\n\treturn early_per_cpu(x86_cpu_to_node_map, cpu);\n}\n\n#endif  \n\n \nextern cpumask_var_t node_to_cpumask_map[MAX_NUMNODES];\n\n#ifdef CONFIG_DEBUG_PER_CPU_MAPS\nextern const struct cpumask *cpumask_of_node(int node);\n#else\n \nstatic inline const struct cpumask *cpumask_of_node(int node)\n{\n\treturn node_to_cpumask_map[node];\n}\n#endif\n\nextern void setup_node_to_cpumask_map(void);\n\n#define pcibus_to_node(bus) __pcibus_to_node(bus)\n\nextern int __node_distance(int, int);\n#define node_distance(a, b) __node_distance(a, b)\n\n#else  \n\nstatic inline int numa_node_id(void)\n{\n\treturn 0;\n}\n \n#define numa_node_id numa_node_id\n\nstatic inline int early_cpu_to_node(int cpu)\n{\n\treturn 0;\n}\n\nstatic inline void setup_node_to_cpumask_map(void) { }\n\n#endif\n\n#include <asm-generic/topology.h>\n\nextern const struct cpumask *cpu_coregroup_mask(int cpu);\nextern const struct cpumask *cpu_clustergroup_mask(int cpu);\n\n#define topology_logical_package_id(cpu)\t(cpu_data(cpu).logical_proc_id)\n#define topology_physical_package_id(cpu)\t(cpu_data(cpu).phys_proc_id)\n#define topology_logical_die_id(cpu)\t\t(cpu_data(cpu).logical_die_id)\n#define topology_die_id(cpu)\t\t\t(cpu_data(cpu).cpu_die_id)\n#define topology_core_id(cpu)\t\t\t(cpu_data(cpu).cpu_core_id)\n#define topology_ppin(cpu)\t\t\t(cpu_data(cpu).ppin)\n\nextern unsigned int __max_die_per_package;\n\n#ifdef CONFIG_SMP\n#define topology_cluster_id(cpu)\t\t(per_cpu(cpu_l2c_id, cpu))\n#define topology_die_cpumask(cpu)\t\t(per_cpu(cpu_die_map, cpu))\n#define topology_cluster_cpumask(cpu)\t\t(cpu_clustergroup_mask(cpu))\n#define topology_core_cpumask(cpu)\t\t(per_cpu(cpu_core_map, cpu))\n#define topology_sibling_cpumask(cpu)\t\t(per_cpu(cpu_sibling_map, cpu))\n\nextern unsigned int __max_logical_packages;\n#define topology_max_packages()\t\t\t(__max_logical_packages)\n\nstatic inline int topology_max_die_per_package(void)\n{\n\treturn __max_die_per_package;\n}\n\nextern int __max_smt_threads;\n\nstatic inline int topology_max_smt_threads(void)\n{\n\treturn __max_smt_threads;\n}\n\n#include <linux/cpu_smt.h>\n\nint topology_update_package_map(unsigned int apicid, unsigned int cpu);\nint topology_update_die_map(unsigned int dieid, unsigned int cpu);\nint topology_phys_to_logical_pkg(unsigned int pkg);\n\nextern struct cpumask __cpu_primary_thread_mask;\n#define cpu_primary_thread_mask ((const struct cpumask *)&__cpu_primary_thread_mask)\n\n \nstatic inline bool topology_is_primary_thread(unsigned int cpu)\n{\n\treturn cpumask_test_cpu(cpu, cpu_primary_thread_mask);\n}\n#else  \n#define topology_max_packages()\t\t\t(1)\nstatic inline int\ntopology_update_package_map(unsigned int apicid, unsigned int cpu) { return 0; }\nstatic inline int\ntopology_update_die_map(unsigned int dieid, unsigned int cpu) { return 0; }\nstatic inline int topology_phys_to_logical_pkg(unsigned int pkg) { return 0; }\nstatic inline int topology_max_die_per_package(void) { return 1; }\nstatic inline int topology_max_smt_threads(void) { return 1; }\nstatic inline bool topology_is_primary_thread(unsigned int cpu) { return true; }\n#endif  \n\nstatic inline void arch_fix_phys_package_id(int num, u32 slot)\n{\n}\n\nstruct pci_bus;\nint x86_pci_root_bus_node(int bus);\nvoid x86_pci_root_bus_resources(int bus, struct list_head *resources);\n\nextern bool x86_topology_update;\n\n#ifdef CONFIG_SCHED_MC_PRIO\n#include <asm/percpu.h>\n\nDECLARE_PER_CPU_READ_MOSTLY(int, sched_core_priority);\nextern unsigned int __read_mostly sysctl_sched_itmt_enabled;\n\n \nvoid sched_set_itmt_core_prio(int prio, int core_cpu);\n\n \nint sched_set_itmt_support(void);\n\n \nvoid sched_clear_itmt_support(void);\n\n#else  \n\n#define sysctl_sched_itmt_enabled\t0\nstatic inline void sched_set_itmt_core_prio(int prio, int core_cpu)\n{\n}\nstatic inline int sched_set_itmt_support(void)\n{\n\treturn 0;\n}\nstatic inline void sched_clear_itmt_support(void)\n{\n}\n#endif  \n\n#if defined(CONFIG_SMP) && defined(CONFIG_X86_64)\n#include <asm/cpufeature.h>\n\nDECLARE_STATIC_KEY_FALSE(arch_scale_freq_key);\n\n#define arch_scale_freq_invariant() static_branch_likely(&arch_scale_freq_key)\n\nDECLARE_PER_CPU(unsigned long, arch_freq_scale);\n\nstatic inline long arch_scale_freq_capacity(int cpu)\n{\n\treturn per_cpu(arch_freq_scale, cpu);\n}\n#define arch_scale_freq_capacity arch_scale_freq_capacity\n\nextern void arch_set_max_freq_ratio(bool turbo_disabled);\nextern void freq_invariance_set_perf_ratio(u64 ratio, bool turbo_disabled);\n#else\nstatic inline void arch_set_max_freq_ratio(bool turbo_disabled) { }\nstatic inline void freq_invariance_set_perf_ratio(u64 ratio, bool turbo_disabled) { }\n#endif\n\nextern void arch_scale_freq_tick(void);\n#define arch_scale_freq_tick arch_scale_freq_tick\n\n#ifdef CONFIG_ACPI_CPPC_LIB\nvoid init_freq_invariance_cppc(void);\n#define arch_init_invariance_cppc init_freq_invariance_cppc\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}