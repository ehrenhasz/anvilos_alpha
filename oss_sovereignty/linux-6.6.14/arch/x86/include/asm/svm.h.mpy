{
  "module_name": "svm.h",
  "hash_id": "b3f5c1ce3656fed16fdd87180c60708fd4436a2fb623f9e6c9b40583bfcdab78",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/svm.h",
  "human_readable_source": " \n#ifndef __SVM_H\n#define __SVM_H\n\n#include <uapi/asm/svm.h>\n#include <uapi/asm/kvm.h>\n\n#include <asm/hyperv-tlfs.h>\n\n \n\nenum intercept_words {\n\tINTERCEPT_CR = 0,\n\tINTERCEPT_DR,\n\tINTERCEPT_EXCEPTION,\n\tINTERCEPT_WORD3,\n\tINTERCEPT_WORD4,\n\tINTERCEPT_WORD5,\n\tMAX_INTERCEPT,\n};\n\nenum {\n\t \n\tINTERCEPT_CR0_READ = 0,\n\tINTERCEPT_CR3_READ = 3,\n\tINTERCEPT_CR4_READ = 4,\n\tINTERCEPT_CR8_READ = 8,\n\tINTERCEPT_CR0_WRITE = 16,\n\tINTERCEPT_CR3_WRITE = 16 + 3,\n\tINTERCEPT_CR4_WRITE = 16 + 4,\n\tINTERCEPT_CR8_WRITE = 16 + 8,\n\t \n\tINTERCEPT_DR0_READ = 32,\n\tINTERCEPT_DR1_READ,\n\tINTERCEPT_DR2_READ,\n\tINTERCEPT_DR3_READ,\n\tINTERCEPT_DR4_READ,\n\tINTERCEPT_DR5_READ,\n\tINTERCEPT_DR6_READ,\n\tINTERCEPT_DR7_READ,\n\tINTERCEPT_DR0_WRITE = 48,\n\tINTERCEPT_DR1_WRITE,\n\tINTERCEPT_DR2_WRITE,\n\tINTERCEPT_DR3_WRITE,\n\tINTERCEPT_DR4_WRITE,\n\tINTERCEPT_DR5_WRITE,\n\tINTERCEPT_DR6_WRITE,\n\tINTERCEPT_DR7_WRITE,\n\t \n\tINTERCEPT_EXCEPTION_OFFSET = 64,\n\t \n\tINTERCEPT_INTR = 96,\n\tINTERCEPT_NMI,\n\tINTERCEPT_SMI,\n\tINTERCEPT_INIT,\n\tINTERCEPT_VINTR,\n\tINTERCEPT_SELECTIVE_CR0,\n\tINTERCEPT_STORE_IDTR,\n\tINTERCEPT_STORE_GDTR,\n\tINTERCEPT_STORE_LDTR,\n\tINTERCEPT_STORE_TR,\n\tINTERCEPT_LOAD_IDTR,\n\tINTERCEPT_LOAD_GDTR,\n\tINTERCEPT_LOAD_LDTR,\n\tINTERCEPT_LOAD_TR,\n\tINTERCEPT_RDTSC,\n\tINTERCEPT_RDPMC,\n\tINTERCEPT_PUSHF,\n\tINTERCEPT_POPF,\n\tINTERCEPT_CPUID,\n\tINTERCEPT_RSM,\n\tINTERCEPT_IRET,\n\tINTERCEPT_INTn,\n\tINTERCEPT_INVD,\n\tINTERCEPT_PAUSE,\n\tINTERCEPT_HLT,\n\tINTERCEPT_INVLPG,\n\tINTERCEPT_INVLPGA,\n\tINTERCEPT_IOIO_PROT,\n\tINTERCEPT_MSR_PROT,\n\tINTERCEPT_TASK_SWITCH,\n\tINTERCEPT_FERR_FREEZE,\n\tINTERCEPT_SHUTDOWN,\n\t \n\tINTERCEPT_VMRUN = 128,\n\tINTERCEPT_VMMCALL,\n\tINTERCEPT_VMLOAD,\n\tINTERCEPT_VMSAVE,\n\tINTERCEPT_STGI,\n\tINTERCEPT_CLGI,\n\tINTERCEPT_SKINIT,\n\tINTERCEPT_RDTSCP,\n\tINTERCEPT_ICEBP,\n\tINTERCEPT_WBINVD,\n\tINTERCEPT_MONITOR,\n\tINTERCEPT_MWAIT,\n\tINTERCEPT_MWAIT_COND,\n\tINTERCEPT_XSETBV,\n\tINTERCEPT_RDPRU,\n\tTRAP_EFER_WRITE,\n\tTRAP_CR0_WRITE,\n\tTRAP_CR1_WRITE,\n\tTRAP_CR2_WRITE,\n\tTRAP_CR3_WRITE,\n\tTRAP_CR4_WRITE,\n\tTRAP_CR5_WRITE,\n\tTRAP_CR6_WRITE,\n\tTRAP_CR7_WRITE,\n\tTRAP_CR8_WRITE,\n\t \n\tINTERCEPT_INVLPGB = 160,\n\tINTERCEPT_INVLPGB_ILLEGAL,\n\tINTERCEPT_INVPCID,\n\tINTERCEPT_MCOMMIT,\n\tINTERCEPT_TLBSYNC,\n};\n\n\nstruct __attribute__ ((__packed__)) vmcb_control_area {\n\tu32 intercepts[MAX_INTERCEPT];\n\tu32 reserved_1[15 - MAX_INTERCEPT];\n\tu16 pause_filter_thresh;\n\tu16 pause_filter_count;\n\tu64 iopm_base_pa;\n\tu64 msrpm_base_pa;\n\tu64 tsc_offset;\n\tu32 asid;\n\tu8 tlb_ctl;\n\tu8 reserved_2[3];\n\tu32 int_ctl;\n\tu32 int_vector;\n\tu32 int_state;\n\tu8 reserved_3[4];\n\tu32 exit_code;\n\tu32 exit_code_hi;\n\tu64 exit_info_1;\n\tu64 exit_info_2;\n\tu32 exit_int_info;\n\tu32 exit_int_info_err;\n\tu64 nested_ctl;\n\tu64 avic_vapic_bar;\n\tu64 ghcb_gpa;\n\tu32 event_inj;\n\tu32 event_inj_err;\n\tu64 nested_cr3;\n\tu64 virt_ext;\n\tu32 clean;\n\tu32 reserved_5;\n\tu64 next_rip;\n\tu8 insn_len;\n\tu8 insn_bytes[15];\n\tu64 avic_backing_page;\t \n\tu8 reserved_6[8];\t \n\tu64 avic_logical_id;\t \n\tu64 avic_physical_id;\t \n\tu8 reserved_7[8];\n\tu64 vmsa_pa;\t\t \n\tu8 reserved_8[720];\n\t \n\tunion {\n\t\tstruct hv_vmcb_enlightenments hv_enlightenments;\n\t\tu8 reserved_sw[32];\n\t};\n};\n\n\n#define TLB_CONTROL_DO_NOTHING 0\n#define TLB_CONTROL_FLUSH_ALL_ASID 1\n#define TLB_CONTROL_FLUSH_ASID 3\n#define TLB_CONTROL_FLUSH_ASID_LOCAL 7\n\n#define V_TPR_MASK 0x0f\n\n#define V_IRQ_SHIFT 8\n#define V_IRQ_MASK (1 << V_IRQ_SHIFT)\n\n#define V_GIF_SHIFT 9\n#define V_GIF_MASK (1 << V_GIF_SHIFT)\n\n#define V_NMI_PENDING_SHIFT 11\n#define V_NMI_PENDING_MASK (1 << V_NMI_PENDING_SHIFT)\n\n#define V_NMI_BLOCKING_SHIFT 12\n#define V_NMI_BLOCKING_MASK (1 << V_NMI_BLOCKING_SHIFT)\n\n#define V_INTR_PRIO_SHIFT 16\n#define V_INTR_PRIO_MASK (0x0f << V_INTR_PRIO_SHIFT)\n\n#define V_IGN_TPR_SHIFT 20\n#define V_IGN_TPR_MASK (1 << V_IGN_TPR_SHIFT)\n\n#define V_IRQ_INJECTION_BITS_MASK (V_IRQ_MASK | V_INTR_PRIO_MASK | V_IGN_TPR_MASK)\n\n#define V_INTR_MASKING_SHIFT 24\n#define V_INTR_MASKING_MASK (1 << V_INTR_MASKING_SHIFT)\n\n#define V_GIF_ENABLE_SHIFT 25\n#define V_GIF_ENABLE_MASK (1 << V_GIF_ENABLE_SHIFT)\n\n#define V_NMI_ENABLE_SHIFT 26\n#define V_NMI_ENABLE_MASK (1 << V_NMI_ENABLE_SHIFT)\n\n#define AVIC_ENABLE_SHIFT 31\n#define AVIC_ENABLE_MASK (1 << AVIC_ENABLE_SHIFT)\n\n#define X2APIC_MODE_SHIFT 30\n#define X2APIC_MODE_MASK (1 << X2APIC_MODE_SHIFT)\n\n#define LBR_CTL_ENABLE_MASK BIT_ULL(0)\n#define VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK BIT_ULL(1)\n\n#define SVM_INTERRUPT_SHADOW_MASK\tBIT_ULL(0)\n#define SVM_GUEST_INTERRUPT_MASK\tBIT_ULL(1)\n\n#define SVM_IOIO_STR_SHIFT 2\n#define SVM_IOIO_REP_SHIFT 3\n#define SVM_IOIO_SIZE_SHIFT 4\n#define SVM_IOIO_ASIZE_SHIFT 7\n\n#define SVM_IOIO_TYPE_MASK 1\n#define SVM_IOIO_STR_MASK (1 << SVM_IOIO_STR_SHIFT)\n#define SVM_IOIO_REP_MASK (1 << SVM_IOIO_REP_SHIFT)\n#define SVM_IOIO_SIZE_MASK (7 << SVM_IOIO_SIZE_SHIFT)\n#define SVM_IOIO_ASIZE_MASK (7 << SVM_IOIO_ASIZE_SHIFT)\n\n#define SVM_VM_CR_VALID_MASK\t0x001fULL\n#define SVM_VM_CR_SVM_LOCK_MASK 0x0008ULL\n#define SVM_VM_CR_SVM_DIS_MASK  0x0010ULL\n\n#define SVM_NESTED_CTL_NP_ENABLE\tBIT(0)\n#define SVM_NESTED_CTL_SEV_ENABLE\tBIT(1)\n#define SVM_NESTED_CTL_SEV_ES_ENABLE\tBIT(2)\n\n\n#define SVM_TSC_RATIO_RSVD\t0xffffff0000000000ULL\n#define SVM_TSC_RATIO_MIN\t0x0000000000000001ULL\n#define SVM_TSC_RATIO_MAX\t0x000000ffffffffffULL\n#define SVM_TSC_RATIO_DEFAULT\t0x0100000000ULL\n\n\n \n#define AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK\t(0xFFULL)\n#define AVIC_LOGICAL_ID_ENTRY_VALID_BIT\t\t\t31\n#define AVIC_LOGICAL_ID_ENTRY_VALID_MASK\t\t(1 << 31)\n\n#define AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK\tGENMASK_ULL(11, 0)\n#define AVIC_PHYSICAL_ID_ENTRY_BACKING_PAGE_MASK\t(0xFFFFFFFFFFULL << 12)\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n#define AVIC_PHYSICAL_ID_ENTRY_VALID_MASK\t\t(1ULL << 63)\n#define AVIC_PHYSICAL_ID_TABLE_SIZE_MASK\t\t(0xFFULL)\n\n#define AVIC_DOORBELL_PHYSICAL_ID_MASK\t\t\tGENMASK_ULL(11, 0)\n\n#define VMCB_AVIC_APIC_BAR_MASK\t\t\t\t0xFFFFFFFFFF000ULL\n\n#define AVIC_UNACCEL_ACCESS_WRITE_MASK\t\t1\n#define AVIC_UNACCEL_ACCESS_OFFSET_MASK\t\t0xFF0\n#define AVIC_UNACCEL_ACCESS_VECTOR_MASK\t\t0xFFFFFFFF\n\nenum avic_ipi_failure_cause {\n\tAVIC_IPI_FAILURE_INVALID_INT_TYPE,\n\tAVIC_IPI_FAILURE_TARGET_NOT_RUNNING,\n\tAVIC_IPI_FAILURE_INVALID_TARGET,\n\tAVIC_IPI_FAILURE_INVALID_BACKING_PAGE,\n\tAVIC_IPI_FAILURE_INVALID_IPI_VECTOR,\n};\n\n#define AVIC_PHYSICAL_MAX_INDEX_MASK\tGENMASK_ULL(8, 0)\n\n \n#define AVIC_MAX_PHYSICAL_ID\t\t0XFEULL\n\n \n#define X2AVIC_MAX_PHYSICAL_ID\t\t0x1FFUL\n\nstatic_assert((AVIC_MAX_PHYSICAL_ID & AVIC_PHYSICAL_MAX_INDEX_MASK) == AVIC_MAX_PHYSICAL_ID);\nstatic_assert((X2AVIC_MAX_PHYSICAL_ID & AVIC_PHYSICAL_MAX_INDEX_MASK) == X2AVIC_MAX_PHYSICAL_ID);\n\n#define AVIC_HPA_MASK\t~((0xFFFULL << 52) | 0xFFF)\n\n#define SVM_SEV_FEAT_DEBUG_SWAP                        BIT(5)\n\nstruct vmcb_seg {\n\tu16 selector;\n\tu16 attrib;\n\tu32 limit;\n\tu64 base;\n} __packed;\n\n \nstruct vmcb_save_area {\n\tstruct vmcb_seg es;\n\tstruct vmcb_seg cs;\n\tstruct vmcb_seg ss;\n\tstruct vmcb_seg ds;\n\tstruct vmcb_seg fs;\n\tstruct vmcb_seg gs;\n\tstruct vmcb_seg gdtr;\n\tstruct vmcb_seg ldtr;\n\tstruct vmcb_seg idtr;\n\tstruct vmcb_seg tr;\n\t \n\tu8 reserved_0xa0[42];\n\tu8 vmpl;\n\tu8 cpl;\n\tu8 reserved_0xcc[4];\n\tu64 efer;\n\tu8 reserved_0xd8[112];\n\tu64 cr4;\n\tu64 cr3;\n\tu64 cr0;\n\tu64 dr7;\n\tu64 dr6;\n\tu64 rflags;\n\tu64 rip;\n\tu8 reserved_0x180[88];\n\tu64 rsp;\n\tu64 s_cet;\n\tu64 ssp;\n\tu64 isst_addr;\n\tu64 rax;\n\tu64 star;\n\tu64 lstar;\n\tu64 cstar;\n\tu64 sfmask;\n\tu64 kernel_gs_base;\n\tu64 sysenter_cs;\n\tu64 sysenter_esp;\n\tu64 sysenter_eip;\n\tu64 cr2;\n\tu8 reserved_0x248[32];\n\tu64 g_pat;\n\tu64 dbgctl;\n\tu64 br_from;\n\tu64 br_to;\n\tu64 last_excp_from;\n\tu64 last_excp_to;\n\tu8 reserved_0x298[72];\n\tu64 spec_ctrl;\t\t \n} __packed;\n\n \nstruct sev_es_save_area {\n\tstruct vmcb_seg es;\n\tstruct vmcb_seg cs;\n\tstruct vmcb_seg ss;\n\tstruct vmcb_seg ds;\n\tstruct vmcb_seg fs;\n\tstruct vmcb_seg gs;\n\tstruct vmcb_seg gdtr;\n\tstruct vmcb_seg ldtr;\n\tstruct vmcb_seg idtr;\n\tstruct vmcb_seg tr;\n\tu64 vmpl0_ssp;\n\tu64 vmpl1_ssp;\n\tu64 vmpl2_ssp;\n\tu64 vmpl3_ssp;\n\tu64 u_cet;\n\tu8 reserved_0xc8[2];\n\tu8 vmpl;\n\tu8 cpl;\n\tu8 reserved_0xcc[4];\n\tu64 efer;\n\tu8 reserved_0xd8[104];\n\tu64 xss;\n\tu64 cr4;\n\tu64 cr3;\n\tu64 cr0;\n\tu64 dr7;\n\tu64 dr6;\n\tu64 rflags;\n\tu64 rip;\n\tu64 dr0;\n\tu64 dr1;\n\tu64 dr2;\n\tu64 dr3;\n\tu64 dr0_addr_mask;\n\tu64 dr1_addr_mask;\n\tu64 dr2_addr_mask;\n\tu64 dr3_addr_mask;\n\tu8 reserved_0x1c0[24];\n\tu64 rsp;\n\tu64 s_cet;\n\tu64 ssp;\n\tu64 isst_addr;\n\tu64 rax;\n\tu64 star;\n\tu64 lstar;\n\tu64 cstar;\n\tu64 sfmask;\n\tu64 kernel_gs_base;\n\tu64 sysenter_cs;\n\tu64 sysenter_esp;\n\tu64 sysenter_eip;\n\tu64 cr2;\n\tu8 reserved_0x248[32];\n\tu64 g_pat;\n\tu64 dbgctl;\n\tu64 br_from;\n\tu64 br_to;\n\tu64 last_excp_from;\n\tu64 last_excp_to;\n\tu8 reserved_0x298[80];\n\tu32 pkru;\n\tu32 tsc_aux;\n\tu8 reserved_0x2f0[24];\n\tu64 rcx;\n\tu64 rdx;\n\tu64 rbx;\n\tu64 reserved_0x320;\t \n\tu64 rbp;\n\tu64 rsi;\n\tu64 rdi;\n\tu64 r8;\n\tu64 r9;\n\tu64 r10;\n\tu64 r11;\n\tu64 r12;\n\tu64 r13;\n\tu64 r14;\n\tu64 r15;\n\tu8 reserved_0x380[16];\n\tu64 guest_exit_info_1;\n\tu64 guest_exit_info_2;\n\tu64 guest_exit_int_info;\n\tu64 guest_nrip;\n\tu64 sev_features;\n\tu64 vintr_ctrl;\n\tu64 guest_exit_code;\n\tu64 virtual_tom;\n\tu64 tlb_id;\n\tu64 pcpu_id;\n\tu64 event_inj;\n\tu64 xcr0;\n\tu8 reserved_0x3f0[16];\n\n\t \n\tu64 x87_dp;\n\tu32 mxcsr;\n\tu16 x87_ftw;\n\tu16 x87_fsw;\n\tu16 x87_fcw;\n\tu16 x87_fop;\n\tu16 x87_ds;\n\tu16 x87_cs;\n\tu64 x87_rip;\n\tu8 fpreg_x87[80];\n\tu8 fpreg_xmm[256];\n\tu8 fpreg_ymm[256];\n} __packed;\n\nstruct ghcb_save_area {\n\tu8 reserved_0x0[203];\n\tu8 cpl;\n\tu8 reserved_0xcc[116];\n\tu64 xss;\n\tu8 reserved_0x148[24];\n\tu64 dr7;\n\tu8 reserved_0x168[16];\n\tu64 rip;\n\tu8 reserved_0x180[88];\n\tu64 rsp;\n\tu8 reserved_0x1e0[24];\n\tu64 rax;\n\tu8 reserved_0x200[264];\n\tu64 rcx;\n\tu64 rdx;\n\tu64 rbx;\n\tu8 reserved_0x320[8];\n\tu64 rbp;\n\tu64 rsi;\n\tu64 rdi;\n\tu64 r8;\n\tu64 r9;\n\tu64 r10;\n\tu64 r11;\n\tu64 r12;\n\tu64 r13;\n\tu64 r14;\n\tu64 r15;\n\tu8 reserved_0x380[16];\n\tu64 sw_exit_code;\n\tu64 sw_exit_info_1;\n\tu64 sw_exit_info_2;\n\tu64 sw_scratch;\n\tu8 reserved_0x3b0[56];\n\tu64 xcr0;\n\tu8 valid_bitmap[16];\n\tu64 x87_state_gpa;\n} __packed;\n\n#define GHCB_SHARED_BUF_SIZE\t2032\n\nstruct ghcb {\n\tstruct ghcb_save_area save;\n\tu8 reserved_save[2048 - sizeof(struct ghcb_save_area)];\n\n\tu8 shared_buffer[GHCB_SHARED_BUF_SIZE];\n\n\tu8 reserved_0xff0[10];\n\tu16 protocol_version;\t \n\tu32 ghcb_usage;\n} __packed;\n\n\n#define EXPECTED_VMCB_SAVE_AREA_SIZE\t\t744\n#define EXPECTED_GHCB_SAVE_AREA_SIZE\t\t1032\n#define EXPECTED_SEV_ES_SAVE_AREA_SIZE\t\t1648\n#define EXPECTED_VMCB_CONTROL_AREA_SIZE\t\t1024\n#define EXPECTED_GHCB_SIZE\t\t\tPAGE_SIZE\n\n#define BUILD_BUG_RESERVED_OFFSET(x, y) \\\n\tASSERT_STRUCT_OFFSET(struct x, reserved ## _ ## y, y)\n\nstatic inline void __unused_size_checks(void)\n{\n\tBUILD_BUG_ON(sizeof(struct vmcb_save_area)\t!= EXPECTED_VMCB_SAVE_AREA_SIZE);\n\tBUILD_BUG_ON(sizeof(struct ghcb_save_area)\t!= EXPECTED_GHCB_SAVE_AREA_SIZE);\n\tBUILD_BUG_ON(sizeof(struct sev_es_save_area)\t!= EXPECTED_SEV_ES_SAVE_AREA_SIZE);\n\tBUILD_BUG_ON(sizeof(struct vmcb_control_area)\t!= EXPECTED_VMCB_CONTROL_AREA_SIZE);\n\tBUILD_BUG_ON(sizeof(struct ghcb)\t\t!= EXPECTED_GHCB_SIZE);\n\n\t \n\n\tBUILD_BUG_RESERVED_OFFSET(vmcb_save_area, 0xa0);\n\tBUILD_BUG_RESERVED_OFFSET(vmcb_save_area, 0xcc);\n\tBUILD_BUG_RESERVED_OFFSET(vmcb_save_area, 0xd8);\n\tBUILD_BUG_RESERVED_OFFSET(vmcb_save_area, 0x180);\n\tBUILD_BUG_RESERVED_OFFSET(vmcb_save_area, 0x248);\n\tBUILD_BUG_RESERVED_OFFSET(vmcb_save_area, 0x298);\n\n\tBUILD_BUG_RESERVED_OFFSET(sev_es_save_area, 0xc8);\n\tBUILD_BUG_RESERVED_OFFSET(sev_es_save_area, 0xcc);\n\tBUILD_BUG_RESERVED_OFFSET(sev_es_save_area, 0xd8);\n\tBUILD_BUG_RESERVED_OFFSET(sev_es_save_area, 0x1c0);\n\tBUILD_BUG_RESERVED_OFFSET(sev_es_save_area, 0x248);\n\tBUILD_BUG_RESERVED_OFFSET(sev_es_save_area, 0x298);\n\tBUILD_BUG_RESERVED_OFFSET(sev_es_save_area, 0x2f0);\n\tBUILD_BUG_RESERVED_OFFSET(sev_es_save_area, 0x320);\n\tBUILD_BUG_RESERVED_OFFSET(sev_es_save_area, 0x380);\n\tBUILD_BUG_RESERVED_OFFSET(sev_es_save_area, 0x3f0);\n\n\tBUILD_BUG_RESERVED_OFFSET(ghcb_save_area, 0x0);\n\tBUILD_BUG_RESERVED_OFFSET(ghcb_save_area, 0xcc);\n\tBUILD_BUG_RESERVED_OFFSET(ghcb_save_area, 0x148);\n\tBUILD_BUG_RESERVED_OFFSET(ghcb_save_area, 0x168);\n\tBUILD_BUG_RESERVED_OFFSET(ghcb_save_area, 0x180);\n\tBUILD_BUG_RESERVED_OFFSET(ghcb_save_area, 0x1e0);\n\tBUILD_BUG_RESERVED_OFFSET(ghcb_save_area, 0x200);\n\tBUILD_BUG_RESERVED_OFFSET(ghcb_save_area, 0x320);\n\tBUILD_BUG_RESERVED_OFFSET(ghcb_save_area, 0x380);\n\tBUILD_BUG_RESERVED_OFFSET(ghcb_save_area, 0x3b0);\n\n\tBUILD_BUG_RESERVED_OFFSET(ghcb, 0xff0);\n}\n\nstruct vmcb {\n\tstruct vmcb_control_area control;\n\tstruct vmcb_save_area save;\n} __packed;\n\n#define SVM_CPUID_FUNC 0x8000000a\n\n#define SVM_VM_CR_SVM_DISABLE 4\n\n#define SVM_SELECTOR_S_SHIFT 4\n#define SVM_SELECTOR_DPL_SHIFT 5\n#define SVM_SELECTOR_P_SHIFT 7\n#define SVM_SELECTOR_AVL_SHIFT 8\n#define SVM_SELECTOR_L_SHIFT 9\n#define SVM_SELECTOR_DB_SHIFT 10\n#define SVM_SELECTOR_G_SHIFT 11\n\n#define SVM_SELECTOR_TYPE_MASK (0xf)\n#define SVM_SELECTOR_S_MASK (1 << SVM_SELECTOR_S_SHIFT)\n#define SVM_SELECTOR_DPL_MASK (3 << SVM_SELECTOR_DPL_SHIFT)\n#define SVM_SELECTOR_P_MASK (1 << SVM_SELECTOR_P_SHIFT)\n#define SVM_SELECTOR_AVL_MASK (1 << SVM_SELECTOR_AVL_SHIFT)\n#define SVM_SELECTOR_L_MASK (1 << SVM_SELECTOR_L_SHIFT)\n#define SVM_SELECTOR_DB_MASK (1 << SVM_SELECTOR_DB_SHIFT)\n#define SVM_SELECTOR_G_MASK (1 << SVM_SELECTOR_G_SHIFT)\n\n#define SVM_SELECTOR_WRITE_MASK (1 << 1)\n#define SVM_SELECTOR_READ_MASK SVM_SELECTOR_WRITE_MASK\n#define SVM_SELECTOR_CODE_MASK (1 << 3)\n\n#define SVM_EVTINJ_VEC_MASK 0xff\n\n#define SVM_EVTINJ_TYPE_SHIFT 8\n#define SVM_EVTINJ_TYPE_MASK (7 << SVM_EVTINJ_TYPE_SHIFT)\n\n#define SVM_EVTINJ_TYPE_INTR (0 << SVM_EVTINJ_TYPE_SHIFT)\n#define SVM_EVTINJ_TYPE_NMI (2 << SVM_EVTINJ_TYPE_SHIFT)\n#define SVM_EVTINJ_TYPE_EXEPT (3 << SVM_EVTINJ_TYPE_SHIFT)\n#define SVM_EVTINJ_TYPE_SOFT (4 << SVM_EVTINJ_TYPE_SHIFT)\n\n#define SVM_EVTINJ_VALID (1 << 31)\n#define SVM_EVTINJ_VALID_ERR (1 << 11)\n\n#define SVM_EXITINTINFO_VEC_MASK SVM_EVTINJ_VEC_MASK\n#define SVM_EXITINTINFO_TYPE_MASK SVM_EVTINJ_TYPE_MASK\n\n#define\tSVM_EXITINTINFO_TYPE_INTR SVM_EVTINJ_TYPE_INTR\n#define\tSVM_EXITINTINFO_TYPE_NMI SVM_EVTINJ_TYPE_NMI\n#define\tSVM_EXITINTINFO_TYPE_EXEPT SVM_EVTINJ_TYPE_EXEPT\n#define\tSVM_EXITINTINFO_TYPE_SOFT SVM_EVTINJ_TYPE_SOFT\n\n#define SVM_EXITINTINFO_VALID SVM_EVTINJ_VALID\n#define SVM_EXITINTINFO_VALID_ERR SVM_EVTINJ_VALID_ERR\n\n#define SVM_EXITINFOSHIFT_TS_REASON_IRET 36\n#define SVM_EXITINFOSHIFT_TS_REASON_JMP 38\n#define SVM_EXITINFOSHIFT_TS_HAS_ERROR_CODE 44\n\n#define SVM_EXITINFO_REG_MASK 0x0F\n\n#define SVM_CR0_SELECTIVE_MASK (X86_CR0_TS | X86_CR0_MP)\n\n \n\n#define GHCB_BITMAP_IDX(field)\t\t\t\t\t\t\t\\\n\t(offsetof(struct ghcb_save_area, field) / sizeof(u64))\n\n#define DEFINE_GHCB_ACCESSORS(field)\t\t\t\t\t\t\\\n\tstatic __always_inline bool ghcb_##field##_is_valid(const struct ghcb *ghcb) \\\n\t{\t\t\t\t\t\t\t\t\t\\\n\t\treturn test_bit(GHCB_BITMAP_IDX(field),\t\t\t\t\\\n\t\t\t\t(unsigned long *)&ghcb->save.valid_bitmap);\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tstatic __always_inline u64 ghcb_get_##field(struct ghcb *ghcb)\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\\\n\t\treturn ghcb->save.field;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tstatic __always_inline u64 ghcb_get_##field##_if_valid(struct ghcb *ghcb) \\\n\t{\t\t\t\t\t\t\t\t\t\\\n\t\treturn ghcb_##field##_is_valid(ghcb) ? ghcb->save.field : 0;\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tstatic __always_inline void ghcb_set_##field(struct ghcb *ghcb, u64 value) \\\n\t{\t\t\t\t\t\t\t\t\t\\\n\t\t__set_bit(GHCB_BITMAP_IDX(field),\t\t\t\t\\\n\t\t\t  (unsigned long *)&ghcb->save.valid_bitmap);\t\t\\\n\t\tghcb->save.field = value;\t\t\t\t\t\\\n\t}\n\nDEFINE_GHCB_ACCESSORS(cpl)\nDEFINE_GHCB_ACCESSORS(rip)\nDEFINE_GHCB_ACCESSORS(rsp)\nDEFINE_GHCB_ACCESSORS(rax)\nDEFINE_GHCB_ACCESSORS(rcx)\nDEFINE_GHCB_ACCESSORS(rdx)\nDEFINE_GHCB_ACCESSORS(rbx)\nDEFINE_GHCB_ACCESSORS(rbp)\nDEFINE_GHCB_ACCESSORS(rsi)\nDEFINE_GHCB_ACCESSORS(rdi)\nDEFINE_GHCB_ACCESSORS(r8)\nDEFINE_GHCB_ACCESSORS(r9)\nDEFINE_GHCB_ACCESSORS(r10)\nDEFINE_GHCB_ACCESSORS(r11)\nDEFINE_GHCB_ACCESSORS(r12)\nDEFINE_GHCB_ACCESSORS(r13)\nDEFINE_GHCB_ACCESSORS(r14)\nDEFINE_GHCB_ACCESSORS(r15)\nDEFINE_GHCB_ACCESSORS(sw_exit_code)\nDEFINE_GHCB_ACCESSORS(sw_exit_info_1)\nDEFINE_GHCB_ACCESSORS(sw_exit_info_2)\nDEFINE_GHCB_ACCESSORS(sw_scratch)\nDEFINE_GHCB_ACCESSORS(xcr0)\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}