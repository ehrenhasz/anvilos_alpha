{
  "module_name": "ftrace.h",
  "hash_id": "331d8537b2dd293df769bab0fa5e8f35d54a1e1fbfe103a9dfc39cc2703e1219",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/ftrace.h",
  "human_readable_source": " \n#ifndef _ASM_X86_FTRACE_H\n#define _ASM_X86_FTRACE_H\n\n#ifdef CONFIG_FUNCTION_TRACER\n#ifndef CC_USING_FENTRY\n# error Compiler does not support fentry?\n#endif\n# define MCOUNT_ADDR\t\t((unsigned long)(__fentry__))\n#define MCOUNT_INSN_SIZE\t5  \n\n \n#ifdef CONFIG_HAVE_FENTRY\n# include <asm/ibt.h>\n \n# define FTRACE_MCOUNT_MAX_OFFSET\tENDBR_INSN_SIZE\n#endif\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n#define ARCH_SUPPORTS_FTRACE_OPS 1\n#endif\n\n#define HAVE_FUNCTION_GRAPH_RET_ADDR_PTR\n\n#ifndef __ASSEMBLY__\nextern void __fentry__(void);\n\nstatic inline unsigned long ftrace_call_adjust(unsigned long addr)\n{\n\t \n\treturn addr;\n}\n\n#ifdef CONFIG_HAVE_DYNAMIC_FTRACE_WITH_ARGS\nstruct ftrace_regs {\n\tstruct pt_regs\t\tregs;\n};\n\nstatic __always_inline struct pt_regs *\narch_ftrace_get_regs(struct ftrace_regs *fregs)\n{\n\t \n\tif (!fregs->regs.cs)\n\t\treturn NULL;\n\treturn &fregs->regs;\n}\n\n#define ftrace_regs_set_instruction_pointer(fregs, _ip)\t\\\n\tdo { (fregs)->regs.ip = (_ip); } while (0)\n\n#define ftrace_regs_get_instruction_pointer(fregs) \\\n\t((fregs)->regs.ip)\n\n#define ftrace_regs_get_argument(fregs, n) \\\n\tregs_get_kernel_argument(&(fregs)->regs, n)\n#define ftrace_regs_get_stack_pointer(fregs) \\\n\tkernel_stack_pointer(&(fregs)->regs)\n#define ftrace_regs_return_value(fregs) \\\n\tregs_return_value(&(fregs)->regs)\n#define ftrace_regs_set_return_value(fregs, ret) \\\n\tregs_set_return_value(&(fregs)->regs, ret)\n#define ftrace_override_function_with_return(fregs) \\\n\toverride_function_with_return(&(fregs)->regs)\n#define ftrace_regs_query_register_offset(name) \\\n\tregs_query_register_offset(name)\n\nstruct ftrace_ops;\n#define ftrace_graph_func ftrace_graph_func\nvoid ftrace_graph_func(unsigned long ip, unsigned long parent_ip,\n\t\t       struct ftrace_ops *op, struct ftrace_regs *fregs);\n#else\n#define FTRACE_GRAPH_TRAMP_ADDR FTRACE_GRAPH_ADDR\n#endif\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS\n \nstatic inline void\n__arch_ftrace_set_direct_caller(struct pt_regs *regs, unsigned long addr)\n{\n\t \n\tregs->orig_ax = addr;\n}\n#define arch_ftrace_set_direct_caller(fregs, addr) \\\n\t__arch_ftrace_set_direct_caller(&(fregs)->regs, addr)\n#endif  \n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\nstruct dyn_arch_ftrace {\n\t \n};\n\n#endif  \n#endif  \n#endif  \n\n\n#ifndef __ASSEMBLY__\n\nvoid prepare_ftrace_return(unsigned long ip, unsigned long *parent,\n\t\t\t   unsigned long frame_pointer);\n\n#if defined(CONFIG_FUNCTION_TRACER) && defined(CONFIG_DYNAMIC_FTRACE)\nextern void set_ftrace_ops_ro(void);\n#else\nstatic inline void set_ftrace_ops_ro(void) { }\n#endif\n\n#define ARCH_HAS_SYSCALL_MATCH_SYM_NAME\nstatic inline bool arch_syscall_match_sym_name(const char *sym, const char *name)\n{\n\t \n\treturn !strcmp(sym + 3, name + 3) ||\n\t\t(!strncmp(sym, \"__x64_\", 6) && !strcmp(sym + 9, name + 3)) ||\n\t\t(!strncmp(sym, \"__ia32_\", 7) && !strcmp(sym + 10, name + 3)) ||\n\t\t(!strncmp(sym, \"__do_sys\", 8) && !strcmp(sym + 8, name + 3));\n}\n\n#ifndef COMPILE_OFFSETS\n\n#if defined(CONFIG_FTRACE_SYSCALLS) && defined(CONFIG_IA32_EMULATION)\n#include <linux/compat.h>\n\n \n#define ARCH_TRACE_IGNORE_COMPAT_SYSCALLS 1\nstatic inline bool arch_trace_is_compat_syscall(struct pt_regs *regs)\n{\n\treturn in_32bit_syscall();\n}\n#endif  \n#endif  \n#endif  \n\n#ifndef __ASSEMBLY__\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\nstruct fgraph_ret_regs {\n\tunsigned long ax;\n\tunsigned long dx;\n\tunsigned long bp;\n};\n\nstatic inline unsigned long fgraph_ret_regs_return_value(struct fgraph_ret_regs *ret_regs)\n{\n\treturn ret_regs->ax;\n}\n\nstatic inline unsigned long fgraph_ret_regs_frame_pointer(struct fgraph_ret_regs *ret_regs)\n{\n\treturn ret_regs->bp;\n}\n#endif  \n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}