{
  "module_name": "syscall.h",
  "hash_id": "3d30251058182f964d5ff0c161939dbb26055abd5307cdf7a3ac85ad2b053ead",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/syscall.h",
  "human_readable_source": " \n \n\n#ifndef _ASM_X86_SYSCALL_H\n#define _ASM_X86_SYSCALL_H\n\n#include <uapi/linux/audit.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <asm/thread_info.h>\t \n#include <asm/unistd.h>\n\ntypedef long (*sys_call_ptr_t)(const struct pt_regs *);\nextern const sys_call_ptr_t sys_call_table[];\n\n#if defined(CONFIG_X86_32)\n#define ia32_sys_call_table sys_call_table\n#else\n \nextern const sys_call_ptr_t ia32_sys_call_table[];\nextern const sys_call_ptr_t x32_sys_call_table[];\n#endif\n\n \nstatic inline int syscall_get_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn regs->orig_ax;\n}\n\nstatic inline void syscall_rollback(struct task_struct *task,\n\t\t\t\t    struct pt_regs *regs)\n{\n\tregs->ax = regs->orig_ax;\n}\n\nstatic inline long syscall_get_error(struct task_struct *task,\n\t\t\t\t     struct pt_regs *regs)\n{\n\tunsigned long error = regs->ax;\n#ifdef CONFIG_IA32_EMULATION\n\t \n\tif (task->thread_info.status & (TS_COMPAT|TS_I386_REGS_POKED))\n\t\t \n\t\terror = (long) (int) error;\n#endif\n\treturn IS_ERR_VALUE(error) ? error : 0;\n}\n\nstatic inline long syscall_get_return_value(struct task_struct *task,\n\t\t\t\t\t    struct pt_regs *regs)\n{\n\treturn regs->ax;\n}\n\nstatic inline void syscall_set_return_value(struct task_struct *task,\n\t\t\t\t\t    struct pt_regs *regs,\n\t\t\t\t\t    int error, long val)\n{\n\tregs->ax = (long) error ?: val;\n}\n\n#ifdef CONFIG_X86_32\n\nstatic inline void syscall_get_arguments(struct task_struct *task,\n\t\t\t\t\t struct pt_regs *regs,\n\t\t\t\t\t unsigned long *args)\n{\n\tmemcpy(args, &regs->bx, 6 * sizeof(args[0]));\n}\n\nstatic inline int syscall_get_arch(struct task_struct *task)\n{\n\treturn AUDIT_ARCH_I386;\n}\n\n#else\t  \n\nstatic inline void syscall_get_arguments(struct task_struct *task,\n\t\t\t\t\t struct pt_regs *regs,\n\t\t\t\t\t unsigned long *args)\n{\n# ifdef CONFIG_IA32_EMULATION\n\tif (task->thread_info.status & TS_COMPAT) {\n\t\t*args++ = regs->bx;\n\t\t*args++ = regs->cx;\n\t\t*args++ = regs->dx;\n\t\t*args++ = regs->si;\n\t\t*args++ = regs->di;\n\t\t*args   = regs->bp;\n\t} else\n# endif\n\t{\n\t\t*args++ = regs->di;\n\t\t*args++ = regs->si;\n\t\t*args++ = regs->dx;\n\t\t*args++ = regs->r10;\n\t\t*args++ = regs->r8;\n\t\t*args   = regs->r9;\n\t}\n}\n\nstatic inline int syscall_get_arch(struct task_struct *task)\n{\n\t \n\treturn (IS_ENABLED(CONFIG_IA32_EMULATION) &&\n\t\ttask->thread_info.status & TS_COMPAT)\n\t\t? AUDIT_ARCH_I386 : AUDIT_ARCH_X86_64;\n}\n\nvoid do_syscall_64(struct pt_regs *regs, int nr);\n\n#endif\t \n\nvoid do_int80_syscall_32(struct pt_regs *regs);\nlong do_fast_syscall_32(struct pt_regs *regs);\nlong do_SYSENTER_32(struct pt_regs *regs);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}