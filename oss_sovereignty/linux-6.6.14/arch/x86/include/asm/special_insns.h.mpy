{
  "module_name": "special_insns.h",
  "hash_id": "748fe8443b4c3a56efd80bbb1bffa63b802fe5f72538084e58ac567b4b7c73e4",
  "original_prompt": "Ingested from linux-6.6.14/arch/x86/include/asm/special_insns.h",
  "human_readable_source": " \n#ifndef _ASM_X86_SPECIAL_INSNS_H\n#define _ASM_X86_SPECIAL_INSNS_H\n\n\n#ifdef __KERNEL__\n\n#include <asm/nops.h>\n#include <asm/processor-flags.h>\n#include <linux/irqflags.h>\n#include <linux/jump_label.h>\n\n \n\n#define __FORCE_ORDER \"m\"(*(unsigned int *)0x1000UL)\n\nvoid native_write_cr0(unsigned long val);\n\nstatic inline unsigned long native_read_cr0(void)\n{\n\tunsigned long val;\n\tasm volatile(\"mov %%cr0,%0\\n\\t\" : \"=r\" (val) : __FORCE_ORDER);\n\treturn val;\n}\n\nstatic __always_inline unsigned long native_read_cr2(void)\n{\n\tunsigned long val;\n\tasm volatile(\"mov %%cr2,%0\\n\\t\" : \"=r\" (val) : __FORCE_ORDER);\n\treturn val;\n}\n\nstatic __always_inline void native_write_cr2(unsigned long val)\n{\n\tasm volatile(\"mov %0,%%cr2\": : \"r\" (val) : \"memory\");\n}\n\nstatic inline unsigned long __native_read_cr3(void)\n{\n\tunsigned long val;\n\tasm volatile(\"mov %%cr3,%0\\n\\t\" : \"=r\" (val) : __FORCE_ORDER);\n\treturn val;\n}\n\nstatic inline void native_write_cr3(unsigned long val)\n{\n\tasm volatile(\"mov %0,%%cr3\": : \"r\" (val) : \"memory\");\n}\n\nstatic inline unsigned long native_read_cr4(void)\n{\n\tunsigned long val;\n#ifdef CONFIG_X86_32\n\t \n\tasm volatile(\"1: mov %%cr4, %0\\n\"\n\t\t     \"2:\\n\"\n\t\t     _ASM_EXTABLE(1b, 2b)\n\t\t     : \"=r\" (val) : \"0\" (0), __FORCE_ORDER);\n#else\n\t \n\tasm volatile(\"mov %%cr4,%0\\n\\t\" : \"=r\" (val) : __FORCE_ORDER);\n#endif\n\treturn val;\n}\n\nvoid native_write_cr4(unsigned long val);\n\n#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\nstatic inline u32 rdpkru(void)\n{\n\tu32 ecx = 0;\n\tu32 edx, pkru;\n\n\t \n\tasm volatile(\".byte 0x0f,0x01,0xee\\n\\t\"\n\t\t     : \"=a\" (pkru), \"=d\" (edx)\n\t\t     : \"c\" (ecx));\n\treturn pkru;\n}\n\nstatic inline void wrpkru(u32 pkru)\n{\n\tu32 ecx = 0, edx = 0;\n\n\t \n\tasm volatile(\".byte 0x0f,0x01,0xef\\n\\t\"\n\t\t     : : \"a\" (pkru), \"c\"(ecx), \"d\"(edx));\n}\n\n#else\nstatic inline u32 rdpkru(void)\n{\n\treturn 0;\n}\n\nstatic inline void wrpkru(u32 pkru)\n{\n}\n#endif\n\nstatic __always_inline void native_wbinvd(void)\n{\n\tasm volatile(\"wbinvd\": : :\"memory\");\n}\n\nstatic inline unsigned long __read_cr4(void)\n{\n\treturn native_read_cr4();\n}\n\n#ifdef CONFIG_PARAVIRT_XXL\n#include <asm/paravirt.h>\n#else\n\nstatic inline unsigned long read_cr0(void)\n{\n\treturn native_read_cr0();\n}\n\nstatic inline void write_cr0(unsigned long x)\n{\n\tnative_write_cr0(x);\n}\n\nstatic __always_inline unsigned long read_cr2(void)\n{\n\treturn native_read_cr2();\n}\n\nstatic __always_inline void write_cr2(unsigned long x)\n{\n\tnative_write_cr2(x);\n}\n\n \nstatic inline unsigned long __read_cr3(void)\n{\n\treturn __native_read_cr3();\n}\n\nstatic inline void write_cr3(unsigned long x)\n{\n\tnative_write_cr3(x);\n}\n\nstatic inline void __write_cr4(unsigned long x)\n{\n\tnative_write_cr4(x);\n}\n\nstatic __always_inline void wbinvd(void)\n{\n\tnative_wbinvd();\n}\n\n#endif  \n\nstatic __always_inline void clflush(volatile void *__p)\n{\n\tasm volatile(\"clflush %0\" : \"+m\" (*(volatile char __force *)__p));\n}\n\nstatic inline void clflushopt(volatile void *__p)\n{\n\talternative_io(\".byte 0x3e; clflush %P0\",\n\t\t       \".byte 0x66; clflush %P0\",\n\t\t       X86_FEATURE_CLFLUSHOPT,\n\t\t       \"+m\" (*(volatile char __force *)__p));\n}\n\nstatic inline void clwb(volatile void *__p)\n{\n\tvolatile struct { char x[64]; } *p = __p;\n\n\tasm volatile(ALTERNATIVE_2(\n\t\t\".byte 0x3e; clflush (%[pax])\",\n\t\t\".byte 0x66; clflush (%[pax])\",  \n\t\tX86_FEATURE_CLFLUSHOPT,\n\t\t\".byte 0x66, 0x0f, 0xae, 0x30\",   \n\t\tX86_FEATURE_CLWB)\n\t\t: [p] \"+m\" (*p)\n\t\t: [pax] \"a\" (p));\n}\n\n#ifdef CONFIG_X86_USER_SHADOW_STACK\nstatic inline int write_user_shstk_64(u64 __user *addr, u64 val)\n{\n\tasm_volatile_goto(\"1: wrussq %[val], (%[addr])\\n\"\n\t\t\t  _ASM_EXTABLE(1b, %l[fail])\n\t\t\t  :: [addr] \"r\" (addr), [val] \"r\" (val)\n\t\t\t  :: fail);\n\treturn 0;\nfail:\n\treturn -EFAULT;\n}\n#endif  \n\n#define nop() asm volatile (\"nop\")\n\nstatic inline void serialize(void)\n{\n\t \n\tasm volatile(\".byte 0xf, 0x1, 0xe8\" ::: \"memory\");\n}\n\n \nstatic inline void movdir64b(void __iomem *dst, const void *src)\n{\n\tconst struct { char _[64]; } *__src = src;\n\tstruct { char _[64]; } __iomem *__dst = dst;\n\n\t \n\tasm volatile(\".byte 0x66, 0x0f, 0x38, 0xf8, 0x02\"\n\t\t     : \"+m\" (*__dst)\n\t\t     :  \"m\" (*__src), \"a\" (__dst), \"d\" (__src));\n}\n\n \nstatic inline int enqcmds(void __iomem *dst, const void *src)\n{\n\tconst struct { char _[64]; } *__src = src;\n\tstruct { char _[64]; } __iomem *__dst = dst;\n\tbool zf;\n\n\t \n\tasm volatile(\".byte 0xf3, 0x0f, 0x38, 0xf8, 0x02, 0x66, 0x90\"\n\t\t     CC_SET(z)\n\t\t     : CC_OUT(z) (zf), \"+m\" (*__dst)\n\t\t     : \"m\" (*__src), \"a\" (__dst), \"d\" (__src));\n\n\t \n\tif (zf)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic __always_inline void tile_release(void)\n{\n\t \n\tasm volatile(\".byte 0xc4, 0xe2, 0x78, 0x49, 0xc0\");\n}\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}